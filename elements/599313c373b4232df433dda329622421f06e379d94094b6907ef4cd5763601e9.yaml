"hash": |-
  599313c373b4232df433dda329622421f06e379d94094b6907ef4cd5763601e9
"type": |-
  Content
"comment": !!null |-
  null
"original": |2-
     A client sending a request without using Transport Layer Security
     (Section 9) SHOULD use a nontrivial, randomized token to guard
     against spoofing of responses (Section 11.4).  This protective use of
     tokens is the reason they are allowed to be up to 8 bytes in size.
     The actual size of the random component to be used for the Token
     depends on the security requirements of the client and the level of
     threat posed by spoofing of responses.  A client that is connected to
     the general Internet SHOULD use at least 32 bits of randomness,
     keeping in mind that not being directly connected to the Internet is
     not necessarily sufficient protection against spoofing.  (Note that
     the Message ID adds little in protection as it is usually
     sequentially assigned, i.e., guessable, and can be circumvented by
     spoofing a separate response.)  Clients that want to optimize the
     Token length may further want to detect the level of ongoing attacks
     (e.g., by tallying recent Token mismatches in incoming messages) and
     adjust the Token length upwards appropriately.  [RFC4086] discusses
     randomness requirements for security.
"fixed": |-
  A client sending a request without using Transport Layer Security (Section 9) SHOULD use a nontrivial, randomized token to guard against spoofing of responses (Section 11.4).  This protective use of tokens is the reason they are allowed to be up to 8 bytes in size. The actual size of the random component to be used for the Token depends on the security requirements of the client and the level of threat posed by spoofing of responses.  A client that is connected to the general Internet SHOULD use at least 32 bits of randomness, keeping in mind that not being directly connected to the Internet is not necessarily sufficient protection against spoofing.  (Note that the Message ID adds little in protection as it is usually sequentially assigned, i.e., guessable, and can be circumvented by spoofing a separate response.)  Clients that want to optimize the Token length may further want to detect the level of ongoing attacks (e.g., by tallying recent Token mismatches in incoming messages) and adjust the Token length upwards appropriately.  [RFC4086] discusses randomness requirements for security.
"ko": |-
  전송 계층 보안(섹션 9)을 사용하지 않고 요청을 보내는 클라이언트는 응답 스푸핑(섹션 11.4)을 방지하기 위해 중요하지 않은 무작위 토큰을 사용해야 합니다. 이러한 토큰의 보호적 사용으로 인해 최대 8바이트 크기가 허용됩니다. 토큰에 사용되는 무작위 구성 요소의 실제 크기는 클라이언트의 보안 요구 사항과 응답 스푸핑으로 인한 위협 수준에 따라 다릅니다. 일반 인터넷에 연결된 클라이언트는 최소 32비트의 임의성을 사용해야 하며, 인터넷에 직접 연결되지 않는다고 해서 반드시 스푸핑에 대한 충분한 보호가 되지는 않는다는 점을 명심해야 합니다. (메시지 ID는 일반적으로 순차적으로 할당되므로(예: 추측 가능하고 별도의 응답을 스푸핑하여 우회할 수 있으므로) 보호 기능을 거의 추가하지 않습니다.) 토큰 길이를 최적화하려는 클라이언트는 진행 중인 공격 수준을 추가로 감지하기를 원할 수 있습니다. (예: 수신 메시지의 최근 토큰 불일치를 집계하여) 토큰 길이를 적절하게 상향 조정합니다. [RFC4086]에서는 보안에 대한 무작위성 요구 사항을 논의합니다.

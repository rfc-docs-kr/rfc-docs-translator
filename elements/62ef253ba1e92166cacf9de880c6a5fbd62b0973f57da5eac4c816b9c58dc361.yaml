"hash": |-
  62ef253ba1e92166cacf9de880c6a5fbd62b0973f57da5eac4c816b9c58dc361
"type": |-
  Content
"comment": !!null |-
  null
"original": |2-
     The author of a standards track protocol needs to consider several
     things before they use a formal syntax notation.  Is the formal
     specification language being used parseable by an existing machine?
     If no parser exists, is there enough information provided in the
     specification to permit the building of a parser?  If not, it is
     likely the reader will not have enough information to decide what the
     notation means.  In addition, the author should remember machine
     parseable syntax is often unreadable by humans, and can make the
     specification excessive in length.  Therefore, syntax notations
     cannot take the place of a clearly written protocol description.
"fixed": |-
  The author of a standards track protocol needs to consider several things before they use a formal syntax notation.  Is the formal specification language being used parseable by an existing machine? If no parser exists, is there enough information provided in the specification to permit the building of a parser?  If not, it is likely the reader will not have enough information to decide what the notation means.  In addition, the author should remember machine parseable syntax is often unreadable by humans, and can make the specification excessive in length.  Therefore, syntax notations cannot take the place of a clearly written protocol description.
"ko": |-
  표준 트랙 프로토콜 작성자는 공식 구문 표기법을 사용하기 전에 몇 가지 사항을 고려해야 합니다. 사용되는 공식 사양 언어가 기존 기계에서 구문 분석 가능합니까? 파서가 존재하지 않는 경우 파서 구축을 허용할 만큼 충분한 정보가 사양에 제공되어 있습니까? 그렇지 않다면 독자는 표기법의 의미를 결정할 만큼 충분한 정보를 갖고 있지 않을 가능성이 높습니다. 또한 작성자는 기계로 구문 분석 가능한 구문이 사람이 읽을 수 없는 경우가 많으며 사양의 길이가 너무 길어질 수 있다는 점을 기억해야 합니다. 따라서 구문 표기법은 명확하게 작성된 프로토콜 설명을 대신할 수 없습니다.

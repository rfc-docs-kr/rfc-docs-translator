"hash": |-
  c89cac635128085de772bc0d240c382eadcbaa0f448db9b11ea020f2ab2106ab
"type": |-
  Content
"comment": !!null |-
  null
"original": |2-
        To ensure data integrity in addition to data origin authentication
        requires extra computation steps in which Alice and Bob use a
        cryptographic hash function h (see: digital signature). Alice
        computes the hash value h(m) = v, and then encrypts v with her
        private key to get s. She sends m and s. Bob receives m' and s',
        either of which might have been changed from the m and s that
        Alice sent. To test this, he decrypts s' with Alice's public key
        to get v'. He then computes h(m') = v". If v' equals v", Bob is
        assured that m' is the same m that Alice sent.
"fixed": |-
  - To ensure data integrity in addition to data origin authentication requires extra computation steps in which Alice and Bob use a cryptographic hash function h (see: digital signature). Alice computes the hash value h(m) = v, and then encrypts v with her private key to get s. She sends m and s. Bob receives m' and s', either of which might have been changed from the m and s that Alice sent. To test this, he decrypts s' with Alice's public key to get v'. He then computes h(m') = v". If v' equals v", Bob is assured that m' is the same m that Alice sent.
"ko": |-
  - 데이터 원본 인증 외에도 데이터 무결성을 보장하려면 Alice와 Bob이 암호화 해시 함수 h(디지털 서명 참조)를 사용하는 추가 계산 단계가 필요합니다. Alice는 해시 값 h(m) = v를 계산한 다음 개인 키로 v를 암호화하여 s를 얻습니다. 그녀는 m과 s를 보냅니다. Bob은 m'과 s'를 수신합니다. 둘 중 하나는 Alice가 보낸 m과 s에서 변경되었을 수 있습니다. 이를 테스트하기 위해 그는 Alice의 공개 키로 s'를 해독하여 v'를 얻습니다. 그런 다음 그는 h(m') = v"를 계산합니다. v'가 v"와 같다면 Bob은 m'이 Alice가 보낸 m과 동일하다고 확신합니다.

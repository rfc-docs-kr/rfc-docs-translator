"hash": |-
  18986dee729dbcd7a865e1d51d3d062d2ab6e7c184aa35803c95567740f3d1a3
"type": |-
  Content
"comment": !!null |-
  null
"original": |2-
     Note that because of packet loss, it is possible for one side to be
     sending application data even though the other side has not received
     the first side's Finished message.  Implementations MUST either
     discard or buffer all application data packets for the new epoch
     until they have received the Finished message for that epoch.
     Implementations MAY treat receipt of application data with a new
     epoch prior to receipt of the corresponding Finished message as
     evidence of reordering or packet loss and retransmit their final
     flight immediately, shortcutting the retransmission timer.
"fixed": |-
  Note that because of packet loss, it is possible for one side to be sending application data even though the other side has not received the first side's Finished message.  Implementations MUST either discard or buffer all application data packets for the new epoch until they have received the Finished message for that epoch. Implementations MAY treat receipt of application data with a new epoch prior to receipt of the corresponding Finished message as evidence of reordering or packet loss and retransmit their final flight immediately, shortcutting the retransmission timer.
"ko": |-
  패킷 손실로 인해 다른 쪽이 첫 번째 쪽의 완료 메시지를 받지 못하더라도 한 쪽에서는 애플리케이션 데이터를 보낼 수 있습니다. 구현은 해당 에포크에 대한 완료 메시지를 수신할 때까지 새로운 에포크에 대한 모든 애플리케이션 데이터 패킷을 삭제하거나 버퍼링해야 합니다. 구현은 재정렬 또는 패킷 손실의 증거로 해당 완료 메시지를 수신하기 전에 새로운 에포크의 애플리케이션 데이터 수신을 처리하고 최종 비행을 즉시 재전송하여 재전송 타이머를 단축할 수 있습니다.

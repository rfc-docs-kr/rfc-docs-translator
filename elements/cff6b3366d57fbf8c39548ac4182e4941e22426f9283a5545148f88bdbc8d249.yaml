"hash": |-
  cff6b3366d57fbf8c39548ac4182e4941e22426f9283a5545148f88bdbc8d249
"type": |-
  Content
"comment": !!null |-
  null
"original": |2-
        Tutorial: If the input data object is changed, a new,
        corresponding hash result cannot be correctly computed without
        knowledge of the secret key. Thus, the secret key protects the
        hash result so it can be used as a checksum even when there is a
        threat of an active attack on the data. There are two basic types
        of keyed hash:
        -  A function based on a keyed encryption algorithm. Example: Data
           Authentication Code.
        -  A function based on a keyless hash that is enhanced by
           combining (e.g., by concatenating) the input data object
           parameter with a key parameter before mapping to the hash
           result. Example: HMAC.
"fixed": |-
  - Tutorial: If the input data object is changed, a new, corresponding hash result cannot be correctly computed without knowledge of the secret key. Thus, the secret key protects the hash result so it can be used as a checksum even when there is a threat of an active attack on the data. There are two basic types of keyed hash: -  A function based on a keyed encryption algorithm. Example: Data Authentication Code. -  A function based on a keyless hash that is enhanced by combining (e.g., by concatenating) the input data object parameter with a key parameter before mapping to the hash result. Example: HMAC.
"ko": |-
  - 튜토리얼: 입력 데이터 객체가 변경되면 비밀 키를 알지 못하면 새로운 해당 해시 결과를 올바르게 계산할 수 없습니다. 따라서 비밀 키는 해시 결과를 보호하므로 데이터에 대한 적극적인 공격 위협이 있는 경우에도 체크섬으로 사용할 수 있습니다. 키 해시에는 두 가지 기본 유형이 있습니다. - 키 암호화 알고리즘을 기반으로 하는 기능. 예: 데이터 인증 코드. - 해시 결과에 매핑하기 전에 입력 데이터 객체 매개변수를 키 매개변수와 결합(예: 연결)하여 강화된 키 없는 해시 기반 기능입니다. 예: HMAC.

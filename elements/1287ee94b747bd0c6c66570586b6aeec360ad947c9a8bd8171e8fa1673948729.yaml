"hash": |-
  1287ee94b747bd0c6c66570586b6aeec360ad947c9a8bd8171e8fa1673948729
"type": |-
  Content
"comment": !!null |-
  null
"original": |2-
     A number of different security mitigations have been designed into
     the protocol and will be instantiated if the specification is
     implemented as written, for example, by ensuring sufficient amounts
     of entropy in the randomly generated session identifiers when not
     using client authentication to minimize the risk of session
     hijacking.  When client authentication is used, protection against
     hijacking will be greatly improved by scoping the accessible sessions
     to the one this client identity has created.  Some of the above
     threats are such that the implementation of the RTSP functionality
     itself needs to consider which policy and strategy it uses to
     mitigate them.
"fixed": |-
  A number of different security mitigations have been designed into the protocol and will be instantiated if the specification is implemented as written, for example, by ensuring sufficient amounts of entropy in the randomly generated session identifiers when not using client authentication to minimize the risk of session hijacking.  When client authentication is used, protection against hijacking will be greatly improved by scoping the accessible sessions to the one this client identity has created.  Some of the above threats are such that the implementation of the RTSP functionality itself needs to consider which policy and strategy it uses to mitigate them.
"ko": |-
  다양한 보안 완화가 프로토콜에 설계되었으며 사양이 작성된 대로 구현되면 인스턴스화됩니다. 예를 들어 클라이언트 인증을 사용하지 않을 때 무작위로 생성된 세션 식별자에 충분한 양의 엔트로피를 보장하여 세션 위험을 최소화합니다. 납치. 클라이언트 인증을 사용하면 액세스 가능한 세션의 범위를 이 클라이언트 ID가 생성한 세션으로 지정하여 하이재킹에 대한 보호가 크게 향상됩니다. 위의 위협 중 일부는 RTSP 기능 구현 자체에서 이를 완화하기 위해 어떤 정책과 전략을 사용할지 고려해야 할 정도입니다.

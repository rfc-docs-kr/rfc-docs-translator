"hash": |-
  cb1c83aad9fb7f0630073693f14c7927d59711edea80373568039d52dc45dcf8
"type": |-
  Content
"comment": !!null |-
  null
"original": |2-
     Scalars are assumed to be randomly generated bytes.  For X25519, in
     order to decode 32 random bytes as an integer scalar, set the three
     least significant bits of the first byte and the most significant bit
     of the last to zero, set the second most significant bit of the last
     byte to 1 and, finally, decode as little-endian.  This means that the
     resulting integer is of the form 2^254 plus eight times a value
     between 0 and 2^251 - 1 (inclusive).  Likewise, for X448, set the two
     least significant bits of the first byte to 0, and the most
     significant bit of the last byte to 1.  This means that the resulting
     integer is of the form 2^447 plus four times a value between 0 and
     2^445 - 1 (inclusive).
"fixed": |-
  Scalars are assumed to be randomly generated bytes.  For X25519, in order to decode 32 random bytes as an integer scalar, set the three least significant bits of the first byte and the most significant bit of the last to zero, set the second most significant bit of the last byte to 1 and, finally, decode as little-endian.  This means that the resulting integer is of the form 2^254 plus eight times a value between 0 and 2^251 - 1 (inclusive).  Likewise, for X448, set the two least significant bits of the first byte to 0, and the most significant bit of the last byte to 1.  This means that the resulting integer is of the form 2^447 plus four times a value between 0 and 2^445 - 1 (inclusive).
"ko": |-
  스칼라는 무작위로 생성된 바이트로 간주됩니다. X25519의 경우 32개의 임의 바이트를 정수 스칼라로 디코딩하려면 첫 번째 바이트의 최하위 비트 3개와 마지막 바이트의 최상위 비트를 0으로 설정하고 마지막 바이트의 두 번째 최상위 비트를 1로 설정하고, 마지막으로 리틀 엔디안으로 디코딩합니다. 이는 결과 정수가 2^254에 0과 2^251 - 1(포함) 사이 값의 8배를 더한 형태라는 것을 의미합니다. 마찬가지로 X448의 경우 첫 번째 바이트의 최하위 비트 2개를 0으로 설정하고 마지막 바이트의 최상위 비트를 1로 설정합니다. 즉, 결과 정수는 2^447에 0 사이의 값을 4배 더한 형식이 됩니다. 및 2^445 - 1(포함).

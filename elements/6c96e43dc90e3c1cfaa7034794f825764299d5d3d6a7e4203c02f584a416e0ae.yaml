"hash": |-
  6c96e43dc90e3c1cfaa7034794f825764299d5d3d6a7e4203c02f584a416e0ae
"type": |-
  Content
"comment": !!null |-
  null
"original": |2-
     In addition, to avoid accidental misuse, TLS implementations MUST NOT
     enable 0-RTT (either sending or accepting) unless specifically
     requested by the application and MUST NOT automatically resend 0-RTT
     data if it is rejected by the server unless instructed by the
     application.  Server-side applications may wish to implement special
     processing for 0-RTT data for some kinds of application traffic
     (e.g., abort the connection, request that data be resent at the
     application layer, or delay processing until the handshake
     completes).  In order to allow applications to implement this kind of
     processing, TLS implementations MUST provide a way for the
     application to determine if the handshake has completed.
"fixed": |-
  In addition, to avoid accidental misuse, TLS implementations MUST NOT enable 0-RTT (either sending or accepting) unless specifically requested by the application and MUST NOT automatically resend 0-RTT data if it is rejected by the server unless instructed by the application.  Server-side applications may wish to implement special processing for 0-RTT data for some kinds of application traffic (e.g., abort the connection, request that data be resent at the application layer, or delay processing until the handshake completes).  In order to allow applications to implement this kind of processing, TLS implementations MUST provide a way for the application to determine if the handshake has completed.
"ko": |-
  또한 실수로 인한 오용을 방지하기 위해 TLS 구현은 애플리케이션에서 특별히 요청하지 않는 한 0-RTT(전송 또는 수락)를 활성화해서는 안 되며, 애플리케이션에서 지시하지 않는 한 서버에서 거부하는 경우 0-RTT 데이터를 자동으로 다시 전송해서는 안 됩니다. 서버 측 애플리케이션은 일부 애플리케이션 트래픽에 대해 0-RTT 데이터에 대한 특수 처리를 구현하려고 할 수 있습니다(예: 연결 중단, 애플리케이션 계층에서 데이터 재전송 요청, 핸드셰이크가 완료될 때까지 처리 지연). 애플리케이션이 이러한 종류의 처리를 구현할 수 있도록 하려면 TLS 구현은 애플리케이션이 핸드셰이크가 완료되었는지 확인할 수 있는 방법을 제공해야 합니다.

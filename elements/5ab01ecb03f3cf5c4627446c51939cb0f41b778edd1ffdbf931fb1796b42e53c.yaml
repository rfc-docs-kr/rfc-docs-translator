"hash": |-
  5ab01ecb03f3cf5c4627446c51939cb0f41b778edd1ffdbf931fb1796b42e53c
"type": |-
  Content
"comment": !!null |-
  null
"original": |2-
     Once A has synchronized the two connections, since the keys are the
     same on the two sides, it can step away and transparently forward
     messages between C and S, reading and modifying when it desires.  In
     the key exchange literature, such occurrences are called unknown key-
     share attacks, since C and S share a secret but they both think that
     their secret is shared only with A.  In themselves, these attacks do
     not break integrity or confidentiality between honest parties, but
     they offer a useful starting point from which to mount impersonation
     attacks on C and S.
"fixed": |-
  Once A has synchronized the two connections, since the keys are the same on the two sides, it can step away and transparently forward messages between C and S, reading and modifying when it desires.  In the key exchange literature, such occurrences are called unknown key- share attacks, since C and S share a secret but they both think that their secret is shared only with A.  In themselves, these attacks do not break integrity or confidentiality between honest parties, but they offer a useful starting point from which to mount impersonation attacks on C and S.
"ko": |-
  A가 두 연결을 동기화하면 양쪽 키가 동일하므로, A는 물러나서 C와 S 사이에서 메시지를 투명하게 전달하고, 원할 때 읽고 수정할 수 있습니다. 키 교환 문헌에서 이러한 현상을 알 수 없는 키 공유 공격이라고 하는데, C와 S가 비밀을 공유하지만 둘 다 자신의 비밀이 A와만 공유된다고 생각하기 때문입니다. 이러한 공격 자체는 정직한 당사자 간의 무결성이나 기밀성을 깨지 않지만, C와 S에 대한 사칭 공격을 시작하기에 유용한 시작점을 제공합니다.

"hash": |-
  93dd47596e529e2e52cf18995e7ba7b6362b7c81f0e0fc235aa18a95caf7f77e
"type": |-
  Content
"comment": !!null |-
  null
"original": |2-
     The dangerous effects of RSTs on TCP have been known for many years,
     even when used by the legitimate endpoints of a connection.  TCP RSTs
     cause the receiver to drop all connection state; because the source
     is not required to maintain a TIME_WAIT state, such a RST can cause
     premature reuse of address/port pairs, potentially allowing segments
     from a previous connection to contaminate the data of a new
     connection, known as TIME_WAIT assassination [8].  In this case,
     assassination occurs inadvertently as the result of duplicate
     segments from a legitimate source, and can be avoided by blocking RST
     processing while in TIME_WAIT.  However, assassination can be useful
     to deliberately reduce the state held at servers; this requires that
     the source of the RSTs go into TIME_WAIT state to avoid such hazards,
     and that RSTs are not blocked in the TIME_WAIT state [12].
"fixed": |-
  The dangerous effects of RSTs on TCP have been known for many years, even when used by the legitimate endpoints of a connection.  TCP RSTs cause the receiver to drop all connection state; because the source is not required to maintain a TIME_WAIT state, such a RST can cause premature reuse of address/port pairs, potentially allowing segments from a previous connection to contaminate the data of a new connection, known as TIME_WAIT assassination [8].  In this case, assassination occurs inadvertently as the result of duplicate segments from a legitimate source, and can be avoided by blocking RST processing while in TIME_WAIT.  However, assassination can be useful to deliberately reduce the state held at servers; this requires that the source of the RSTs go into TIME_WAIT state to avoid such hazards, and that RSTs are not blocked in the TIME_WAIT state [12].
"ko": |-
  TCP에 대한 RST의 위험한 영향은 연결의 합법적인 끝점에서 사용되는 경우에도 수년 동안 알려져 왔습니다. TCP RST는 수신자가 모든 연결 상태를 삭제하도록 합니다. 소스가 TIME_WAIT 상태를 유지할 필요가 없기 때문에 이러한 RST는 주소/포트 쌍의 조기 재사용을 유발하여 잠재적으로 이전 연결의 세그먼트가 TIME_WAIT 암살이라고 알려진 새 연결의 데이터를 오염시킬 수 있습니다[8]. 이 경우 합법적인 소스의 세그먼트 중복으로 인해 암살이 실수로 발생하며 TIME_WAIT 동안 RST 처리를 차단하여 피할 수 있습니다. 그러나 암살은 서버에 있는 상태를 의도적으로 줄이는 데 유용할 수 있습니다. 이를 위해서는 이러한 위험을 피하기 위해 RST의 소스가 TIME_WAIT 상태로 들어가고 RST가 TIME_WAIT 상태에서 차단되지 않아야 합니다[12].

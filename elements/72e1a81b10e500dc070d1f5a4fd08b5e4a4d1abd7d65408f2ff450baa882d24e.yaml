"hash": |-
  72e1a81b10e500dc070d1f5a4fd08b5e4a4d1abd7d65408f2ff450baa882d24e
"type": |-
  Content
"comment": !!null |-
  null
"original": |2-
     Note: If a rehandshake occurs while data is flowing on a connection,
     the communicating parties may continue to send data using the old
     CipherSpec.  However, once the ChangeCipherSpec has been sent, the
     new CipherSpec MUST be used.  The first side to send the
     ChangeCipherSpec does not know that the other side has finished
     computing the new keying material (e.g., if it has to perform a
     time-consuming public key operation).  Thus, a small window of time,
     during which the recipient must buffer the data, MAY exist.  In
     practice, with modern machines this interval is likely to be fairly
     short.
"fixed": |-
  Note: If a rehandshake occurs while data is flowing on a connection, the communicating parties may continue to send data using the old CipherSpec.  However, once the ChangeCipherSpec has been sent, the new CipherSpec MUST be used.  The first side to send the ChangeCipherSpec does not know that the other side has finished computing the new keying material (e.g., if it has to perform a time-consuming public key operation).  Thus, a small window of time, during which the recipient must buffer the data, MAY exist.  In practice, with modern machines this interval is likely to be fairly short.
"ko": |-
  참고: 연결에서 데이터가 흐르는 동안 재핸드셰이크가 발생하는 경우 통신 당사자는 이전 CipherSpec을 사용하여 계속 데이터를 보낼 수 있습니다. 그러나 ChangeCipherSpec이 전송되면 새 CipherSpec을 사용해야 합니다. ChangeCipherSpec을 보내는 첫 번째 측은 다른 쪽이 새로운 키 자료 계산을 완료했다는 사실을 알지 못합니다(예: 시간이 많이 걸리는 공개 키 작업을 수행해야 하는 경우). 따라서 수신자가 데이터를 버퍼링해야 하는 작은 시간 창이 존재할 수 있습니다. 실제로 현대 기계에서는 이 간격이 상당히 짧을 수 있습니다.

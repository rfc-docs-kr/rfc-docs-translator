"hash": |-
  4037a474e78501d8546374ef68af550018e8b4c2076fb4ad89524d2017c6b205
"type": |-
  Content
"comment": !!null |-
  null
"original": |2-
     Unfortunately, this composition of SASL and TLS is less strong than
     one would expect.  It's easy for an active attacker to hijack this
     connection.  The client man-in-the-middles the SSL connection
     (remember we're not authenticating the server, which is what
     ordinarily prevents this attack) and then simply proxies the SASL
     handshake.  From then on, it's as if the connection were in the
"fixed": |-
  Unfortunately, this composition of SASL and TLS is less strong than one would expect.  It's easy for an active attacker to hijack this connection.  The client man-in-the-middles the SSL connection (remember we're not authenticating the server, which is what ordinarily prevents this attack) and then simply proxies the SASL handshake.  From then on, it's as if the connection were in the
"ko": |-
  불행하게도 SASL과 TLS의 이러한 구성은 예상보다 덜 강력합니다. 적극적인 공격자가 이 연결을 가로채는 것은 쉽습니다. 클라이언트는 중간자 역할을 하며 SSL 연결을 수행하고(일반적으로 이 공격을 방지하기 위해 서버를 인증하는 것이 아니라는 점을 기억하십시오) SASL 핸드셰이크를 간단히 프록시합니다. 그 이후로는 마치 연결이 된 것처럼 보입니다.

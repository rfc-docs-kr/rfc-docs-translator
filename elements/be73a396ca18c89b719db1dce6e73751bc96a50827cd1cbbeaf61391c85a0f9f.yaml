"hash": |-
  be73a396ca18c89b719db1dce6e73751bc96a50827cd1cbbeaf61391c85a0f9f
"type": |-
  Content
"comment": !!null |-
  null
"original": |2-
     Proof: (a) Any peak hash is always the left sibling.  Otherwise, if
     it is the right sibling, its left neighbor/sibling must also be a
     filled node, because of the way chunks are laid out in the leaves,
     which contradicts the definition of a peak hash. (b) For the
     rightmost peak hash, its right sibling is zero. (c) For any peak
     hash, the right sibling might be calculated using peak hashes to the
     left and zeros for empty nodes. (d) Once the right sibling of the
     leftmost peak hash is calculated, its parent might be calculated. (e)
     Once that parent is calculated, we might trivially get to the root
     hash by concatenating the hash with zeros and hashing it repeatedly.
"fixed": |-
  Proof: (a) Any peak hash is always the left sibling.  Otherwise, if it is the right sibling, its left neighbor/sibling must also be a filled node, because of the way chunks are laid out in the leaves, which contradicts the definition of a peak hash. (b) For the rightmost peak hash, its right sibling is zero. (c) For any peak hash, the right sibling might be calculated using peak hashes to the left and zeros for empty nodes. (d) Once the right sibling of the leftmost peak hash is calculated, its parent might be calculated. (e) Once that parent is calculated, we might trivially get to the root hash by concatenating the hash with zeros and hashing it repeatedly.
"ko": |-
  증명: (a) 모든 피크 해시는 항상 왼쪽 형제입니다. 그렇지 않고 오른쪽 형제인 경우 왼쪽 이웃/형제도 채워진 노드여야 합니다. 왜냐하면 청크가 리프에 배치되는 방식으로 인해 피크 해시의 정의와 모순되기 때문입니다. (b) 가장 오른쪽 피크 해시의 경우 오른쪽 형제는 0입니다. (c) 피크 해시의 경우 오른쪽 형제는 왼쪽의 피크 해시와 빈 노드의 0을 사용하여 계산될 수 있습니다. (d) 가장 왼쪽 피크 해시의 오른쪽 형제가 계산되면 해당 상위가 계산될 수 있습니다. (e) 해당 상위 항목이 계산되면 해시를 0으로 연결하고 반복적으로 해싱하여 루트 해시에 쉽게 접근할 수 있습니다.

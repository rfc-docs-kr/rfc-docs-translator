"hash": |-
  1b48c231a27f28a48247551432a348224d6e5212cb2db423d615e3621c61b75b
"type": |-
  Content
"comment": !!null |-
  null
"original": |2-
     There are several ways to perform QNAME minimisation.  See Section 2
     for the suggested way.  It can be called the aggressive algorithm,
     since the resolver only sends NS queries as long as it does not know
     the zone cuts.  This is the safest, from a privacy point of view.
     Another possible algorithm, not fully studied at this time, could be
     to "piggyback" on the traditional resolution code.  At startup, it
     sends traditional full QNAMEs and learns the zone cuts from the
     referrals received, then switches to NS queries asking only for the
     minimum domain name.  This leaks more data but could require fewer
     changes in the existing resolver codebase.
"fixed": |-
  There are several ways to perform QNAME minimisation.  See Section 2 for the suggested way.  It can be called the aggressive algorithm, since the resolver only sends NS queries as long as it does not know the zone cuts.  This is the safest, from a privacy point of view. Another possible algorithm, not fully studied at this time, could be to "piggyback" on the traditional resolution code.  At startup, it sends traditional full QNAMEs and learns the zone cuts from the referrals received, then switches to NS queries asking only for the minimum domain name.  This leaks more data but could require fewer changes in the existing resolver codebase.
"ko": |-
  QNAME 최소화를 수행하는 방법에는 여러 가지가 있습니다. 제안된 방법은 섹션 2를 참조하세요. 리졸버는 존 컷을 모르는 한 NS 쿼리만 보내기 때문에 공격적인 알고리즘이라고 부를 수 있습니다. 개인 정보 보호 관점에서 볼 때 이것이 가장 안전합니다. 현재 완전히 연구되지 않은 또 다른 가능한 알고리즘은 기존 해상도 코드를 "피기백"하는 것일 수 있습니다. 시작 시 기존의 전체 QNAME을 보내고 수신된 추천에서 영역 분할을 학습한 다음 최소 도메인 이름만 묻는 NS 쿼리로 전환합니다. 이로 인해 더 많은 데이터가 누출되지만 기존 확인자 코드베이스에서 더 적은 변경이 필요할 수 있습니다.

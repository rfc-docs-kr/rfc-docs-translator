"hash": |-
  c49be6452a1746cd838b4e47ab87dea7428d4954322a38c509161c5c0b6bb033
"type": |-
  Content
"comment": !!null |-
  null
"original": |2-
     As noted earlier, transport layer solutions require separate
     modification of all transport protocols to include authentication.
     Not all transport protocols support negotiated endpoint state (e.g.,
     UDP), and legacy protocols have been notoriously difficult to safely
     augment.  Not all authentication solutions are created equal, either,
     and relying on a variety of transport solutions exposes end-systems
     to increased potential for incorrectly specified or implemented
     solutions.  Transport authentication has often been developed piece-
     wise, in response to specific attacks, e.g., SYN cookies and RST
     window attenuation [4][36].
"fixed": |-
  As noted earlier, transport layer solutions require separate modification of all transport protocols to include authentication. Not all transport protocols support negotiated endpoint state (e.g., UDP), and legacy protocols have been notoriously difficult to safely augment.  Not all authentication solutions are created equal, either, and relying on a variety of transport solutions exposes end-systems to increased potential for incorrectly specified or implemented solutions.  Transport authentication has often been developed piece- wise, in response to specific attacks, e.g., SYN cookies and RST window attenuation [4][36].
"ko": |-
  앞서 언급한 것처럼 전송 계층 솔루션에는 인증을 포함하도록 모든 전송 프로토콜을 별도로 수정해야 합니다. 모든 전송 프로토콜이 협상된 엔드포인트 상태(예: UDP)를 지원하는 것은 아니며 레거시 프로토콜은 안전하게 확장하기가 매우 어렵습니다. 모든 인증 솔루션이 동일하게 생성되는 것은 아니며 다양한 전송 솔루션에 의존하면 최종 시스템이 잘못 지정되거나 구현된 솔루션의 가능성이 높아질 수 있습니다. 전송 인증은 SYN 쿠키 및 RST 창 감쇠[4][36]와 같은 특정 공격에 대응하여 조각별로 개발되는 경우가 많습니다.

"hash": |-
  82ca9fea83f85c7038f6575d936feb5913d190884f64a64174389e1f8ceff056
"type": |-
  Content
"comment": !!null |-
  null
"original": |2-
     3.  Without compromising the security proof for RSASSA-PSS, one may
         perform Steps 1 and 2 of EMSA-PSS-ENCODE and EMSA-PSS-VERIFY (the
         application of the hash function to the message) outside the
         module that computes the rest of the signature operation, so that
         mHash rather than the message M itself is input to the module.
         In other words, the security proof for RSASSA-PSS still holds
         even if an opponent can control the value of mHash.  This is
         convenient if the module has limited I/O bandwidth, e.g., a smart
         card.  Note that previous versions of PSS [RSARABIN][PSS] did not
         have this property.  Of course, it may be desirable for other
         security reasons to have the module process the full message.
         For instance, the module may need to "see" what it is signing if
         it does not trust the component that computes the hash value.
"fixed": |-
  1.  Without compromising the security proof for RSASSA-PSS, one may perform Steps 1 and 2 of EMSA-PSS-ENCODE and EMSA-PSS-VERIFY (the application of the hash function to the message) outside the module that computes the rest of the signature operation, so that mHash rather than the message M itself is input to the module. In other words, the security proof for RSASSA-PSS still holds even if an opponent can control the value of mHash.  This is convenient if the module has limited I/O bandwidth, e.g., a smart card.  Note that previous versions of PSS [RSARABIN][PSS] did not have this property.  Of course, it may be desirable for other security reasons to have the module process the full message. For instance, the module may need to "see" what it is signing if it does not trust the component that computes the hash value.
"ko": |-
  1. RSASSA-PSS에 대한 보안 증명을 손상시키지 않으면서 나머지를 계산하는 모듈 외부에서 EMSA-PSS-ENCODE 및 EMSA-PSS-VERIFY(메시지에 해시 함수 적용)의 1단계와 2단계를 수행할 수 있습니다. 메시지 M 자체가 아닌 mHash가 모듈에 입력되도록 서명 작업을 수행합니다. 즉, 상대방이 mHash의 가치를 통제할 수 있더라도 RSASSA-PSS의 보안 증명은 여전히 ​​유효합니다. 이는 모듈(예: 스마트 카드)에 제한된 I/O 대역폭이 있는 경우 편리합니다. PSS [RSARABIN][PSS]의 이전 버전에는 이 속성이 없었습니다. 물론, 다른 보안상의 이유로 모듈이 전체 메시지를 처리하도록 하는 것이 바람직할 수도 있습니다. 예를 들어 모듈은 해시 값을 계산하는 구성 요소를 신뢰하지 않는 경우 서명 내용을 "확인"해야 할 수 있습니다.

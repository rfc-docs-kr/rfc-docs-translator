"hash": |-
  6bf3fe7f90cf6194034b998000d25ba64146845a6a775448113ac4dbe45f5d12
"type": |-
  Content
"comment": !!null |-
  null
"original": |2-
     In the simplest implementation, control would not return to the
     calling program until either the buffer was filled or some error
     occurred, but this scheme is highly subject to deadlocks.  A more
     sophisticated implementation would permit several RECEIVEs to be
     outstanding at once.  These would be filled as segments arrive.  This
     strategy permits increased throughput at the cost of a more elaborate
     scheme (possibly asynchronous) to notify the calling program that a
     PUSH has been seen or a buffer filled.
"fixed": |-
  In the simplest implementation, control would not return to the calling program until either the buffer was filled or some error occurred, but this scheme is highly subject to deadlocks.  A more sophisticated implementation would permit several RECEIVEs to be outstanding at once.  These would be filled as segments arrive.  This strategy permits increased throughput at the cost of a more elaborate scheme (possibly asynchronous) to notify the calling program that a PUSH has been seen or a buffer filled.
"ko": |-
  가장 간단한 구현에서는 버퍼가 채워지거나 일부 오류가 발생할 때까지 제어가 호출 프로그램으로 반환되지 않지만 이 체계는 교착 상태에 빠지기 쉽습니다. 보다 정교한 구현을 통해 여러 RECEIVE를 동시에 뛰어난 상태로 유지할 수 있습니다. 세그먼트가 도착하면 채워집니다. 이 전략을 사용하면 PUSH가 확인되었거나 버퍼가 채워졌음을 호출 프로그램에 알리기 위해 보다 정교한 체계(아마도 비동기식)를 사용하여 처리량을 늘릴 수 있습니다.



```text
Internet Engineering Task Force (IETF)                            Y. Nir
Request for Comments: 8422                                   Check Point
Obsoletes: 4492                                             S. Josefsson
Category: Standards Track                                         SJD AB
ISSN: 2070-1721                                      M. Pegourie-Gonnard
                                                                     ARM
                                                             August 2018
```

ECC\(Elliptic Curve Cryptography\) 암호 제품군

- TLS\(Transport Layer Security\) 버전 1.2 이하의 경우

---
# **Abstract**

이 문서는 TLS\(Transport Layer Security\) 프로토콜용 ECC\(Elliptic Curve Cryptography\) 기반 키 교환 알고리즘에 대해 설명합니다. 특히 TLS 핸드셰이크에서 Ephemeral Elliptic Curve Diffie-Hellman\(ECDHE\) 키 계약을 사용하고 ECDSA\(Elliptic Curve Digital Signature Algorithm\) 및 EdDSA\(Edwards-curve Digital Signature Algorithm\)를 인증 메커니즘으로 사용하도록 지정합니다.

이 문서는 RFC 4492를 폐기합니다.

---
# **Status of This Memo**

이것은 인터넷 표준 추적 문서입니다.

이 문서는 IETF\(Internet Engineering Task Force\)의 제품입니다. 이는 IETF 커뮤니티의 합의를 나타냅니다. 공개 검토를 받았으며 IESG\(Internet Engineering Steering Group\)의 출판 승인을 받았습니다. 인터넷 표준에 대한 자세한 내용은 RFC 7841의 섹션 2에서 확인할 수 있습니다.

이 문서의 현재 상태, 오류 및 이에 대한 피드백 제공 방법에 대한 정보는 https://www.rfc-editor.org/info/rfc8422에서 얻을 수 있습니다.

---
# **Copyright Notice**

Copyright \(c\) 2018 IETF Trust 및 문서 작성자로 확인된 사람. 판권 소유.

이 문서는 이 문서의 발행일에 유효한 BCP 78 및 IETF 문서에 관한 IETF 트러스트의 법적 조항\(https://trustee.ietf.org/license-info\)의 적용을 받습니다. 이 문서와 관련된 귀하의 권리 및 제한 사항을 설명하므로 이 문서를 주의 깊게 검토하십시오. 이 문서에서 추출한 코드 구성 요소는 Trust Legal Provisions의 섹션 4.e에 설명된 대로 Simplified BSD License 텍스트를 포함해야 하며 Simplified BSD License에 설명된 대로 보증 없이 제공됩니다.

---
# **Table of Contents**

```text
   1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   4
     1.1.  Conventions Used in This Document . . . . . . . . . . . .   4
   2.  Key Exchange Algorithm  . . . . . . . . . . . . . . . . . . .   4
     2.1.  ECDHE_ECDSA . . . . . . . . . . . . . . . . . . . . . . .   6
     2.2.  ECDHE_RSA . . . . . . . . . . . . . . . . . . . . . . . .   7
     2.3.  ECDH_anon . . . . . . . . . . . . . . . . . . . . . . . .   7
     2.4.  Algorithms in Certificate Chains  . . . . . . . . . . . .   7
   3.  Client Authentication . . . . . . . . . . . . . . . . . . . .   8
     3.1.  ECDSA_sign  . . . . . . . . . . . . . . . . . . . . . . .   8
   4.  TLS Extensions for ECC  . . . . . . . . . . . . . . . . . . .   9
   5.  Data Structures and Computations  . . . . . . . . . . . . . .  10
     5.1.  Client Hello Extensions . . . . . . . . . . . . . . . . .  10
       5.1.1.  Supported Elliptic Curves Extension . . . . . . . . .  11
       5.1.2.  Supported Point Formats Extension . . . . . . . . . .  13
       5.1.3.  The signature_algorithms Extension and EdDSA  . . . .  13
     5.2.  Server Hello Extension  . . . . . . . . . . . . . . . . .  14
     5.3.  Server Certificate  . . . . . . . . . . . . . . . . . . .  15
     5.4.  Server Key Exchange . . . . . . . . . . . . . . . . . . .  16
       5.4.1.  Uncompressed Point Format for NIST Curves . . . . . .  19
     5.5.  Certificate Request . . . . . . . . . . . . . . . . . . .  20
     5.6.  Client Certificate  . . . . . . . . . . . . . . . . . . .  21
     5.7.  Client Key Exchange . . . . . . . . . . . . . . . . . . .  22
     5.8.  Certificate Verify  . . . . . . . . . . . . . . . . . . .  23
     5.9.  Elliptic Curve Certificates . . . . . . . . . . . . . . .  24
     5.10. ECDH, ECDSA, and RSA Computations . . . . . . . . . . . .  24
     5.11. Public Key Validation . . . . . . . . . . . . . . . . . .  26
   6.  Cipher Suites . . . . . . . . . . . . . . . . . . . . . . . .  26
   7.  Implementation Status . . . . . . . . . . . . . . . . . . . .  27
   8.  Security Considerations . . . . . . . . . . . . . . . . . . .  27
   9.  IANA Considerations . . . . . . . . . . . . . . . . . . . . .  28
   10. References  . . . . . . . . . . . . . . . . . . . . . . . . .  29
     10.1.  Normative References . . . . . . . . . . . . . . . . . .  29
     10.2.  Informative References . . . . . . . . . . . . . . . . .  31
   Appendix A.  Equivalent Curves (Informative)  . . . . . . . . . .  32
   Appendix B.  Differences from RFC 4492  . . . . . . . . . . . . .  33
   Acknowledgements  . . . . . . . . . . . . . . . . . . . . . . . .  34
   Authors' Addresses  . . . . . . . . . . . . . . . . . . . . . . .  34
```

---
## **1.  Introduction**

이 문서는 TLS 버전 1.0\[RFC2246\], 1.1\[RFC4346\] 및 1.2\[RFC5246\]에 적용 가능한 ECC를 지원하기 위한 TLS 추가 사항에 대해 설명합니다. TLS 1.3에서 ECC의 사용은 \[TLS1.3\]에 정의되어 있으며 명시적으로 이 문서의 범위를 벗어납니다. 특히 이 문서는 다음을 정의합니다.

o 임시 키와 함께 ECDHE 키 계약 체계를 사용하여 TLS 사전 마스터 비밀을 설정합니다.

o TLS 피어 인증을 위한 ECDSA 및 EdDSA 서명 사용.

이 문서의 나머지 부분은 다음과 같이 구성되어 있습니다. 섹션 2에서는 TLS를 위한 ECC 기반 키 교환 알고리즘의 개요를 제공합니다. 섹션 3에서는 클라이언트 인증을 위한 ECC 인증서 사용에 대해 설명합니다. 클라이언트가 특정 곡선 및 포인트 형식의 사용을 협상할 수 있도록 하는 TLS 확장은 섹션 4에 나와 있습니다. 섹션 5는 ECC 기반 핸드셰이크에 필요한 다양한 데이터 구조, TLS 메시지의 인코딩 및 해당 메시지 처리를 지정합니다. 섹션 6은 ECC 기반 암호화 제품군을 정의하고 이 사양의 모든 구현에 권장되는 이들 중 작은 하위 집합을 식별합니다. 섹션 8에서는 보안 고려 사항에 대해 설명합니다. 섹션 9는 이 문서의 전신에 의해 생성된 이름 공간에 대한 IANA 고려 사항을 설명합니다. 부록 B는 이 문서가 대체하는 문서인 \[RFC4492\]와의 차이점을 제공합니다.

이 사양을 구현하려면 TLS, TLS 확장\[RFC4366\] 및 ECC에 익숙해야 합니다.

---
### **1.1.  Conventions Used in This Document**

키워드 "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY" 및 "OPTIONAL" "는 BCP 14 \[RFC2119\] \[RFC8174\]에 설명된 대로 여기에 표시된 것처럼 모두 대문자로 표시되는 경우에만 해석됩니다.\(MUST NOT\)

---
## **2.  Key Exchange Algorithm**

이 문서는 TLS에 대한 세 가지 새로운 ECC 기반 키 교환 알고리즘을 정의합니다. 모두 Ephemeral ECDH\(ECDHE\)를 사용하여 TLS premaster secret을 계산하며 인증에 사용되는 메커니즘\(있는 경우\)만 다릅니다. premaster secret에서 TLS master secret의 파생과 대량 암호화/MAC 키 및 초기화 벡터의 후속 생성은 키 교환 알고리즘과 독립적이며 ECC 도입의 영향을 받지 않습니다.

표 1은 새로운 키 교환 알고리즘을 요약한 것입니다. 이러한 모든 키 교환 알고리즘은 새로운 임시 키가 생성 및 사용되는 경우에만 순방향 비밀성을 제공하며 사용 후 폐기됩니다.

```text
     +-------------+------------------------------------------------+
     | Algorithm   | Description                                    |
     +-------------+------------------------------------------------+
     | ECDHE_ECDSA | Ephemeral ECDH with ECDSA or EdDSA signatures. |
     | ECDHE_RSA   | Ephemeral ECDH with RSA signatures.            |
     | ECDH_anon   | Anonymous ephemeral ECDH, no signatures.       |
     +-------------+------------------------------------------------+

                   Table 1: ECC Key Exchange Algorithms
```

이러한 키 교환은 각각 DHE\_DSS, DHE\_RSA 및 DH\_anon과 유사합니다.

ECDHE\_RSA를 사용하면 서버가 기존 RSA 인증서를 재사용하고 제한된 클라이언트의 타원 곡선 기본 설정을 쉽게 준수할 수 있습니다\(섹션 4 참조\). 그러나 순방향 보안을 제공하지 않는 기존 RSA 키 교환보다 ECDHE\_RSA의 경우 서버에서 발생하는 계산 비용이 더 높습니다.

익명 키 교환 알고리즘은 서버 또는 클라이언트의 인증을 제공하지 않습니다. 다른 익명 TLS 키 교환과 마찬가지로 메시지 가로채기\(man-in-the-middle\) 공격을 받을 수 있습니다. 이 알고리즘과 함께 TLS를 사용하는 애플리케이션은 다른 방법으로 인증을 제공해야 합니다\(SHOULD\).\(SHOULD\)

```text
          Client                                        Server
          ------                                        ------
          ClientHello          -------->
                                                   ServerHello
                                                  Certificate*
                                            ServerKeyExchange*
                                          CertificateRequest*+
                               <--------       ServerHelloDone
          Certificate*+
          ClientKeyExchange
          CertificateVerify*+
          [ChangeCipherSpec]
          Finished             -------->
                                            [ChangeCipherSpec]
                               <--------              Finished
          Application Data     <------->      Application Data
```

\* 일부 조건에서는 메시지가 전송되지 않습니다.

- + 클라이언트 인증이 필요하지 않으면 메시지가 전송되지 않습니다.

- 그림 1: 전체 TLS 1.2 핸드셰이크의 메시지 흐름

그림 1은 TLS 키 설정 프로토콜\(일명 전체 핸드셰이크\)과 관련된 모든 메시지를 보여줍니다. ECC 추가는 ClientHello, ServerHello, 서버의 인증서 메시지, ServerKeyExchange, ClientKeyExchange, CertificateRequest, 클라이언트의 인증서 메시지 및 CertificateVerify에만 직접적인 영향을 미칩니다. 다음으로 이러한 메시지의 내용 및 처리 측면에서 ECC 키 교환 알고리즘을 자세히 설명합니다. 설명을 쉽게 하기 위해 클라이언트 인증 및 관련 메시지\(그림 1에서 '+'로 식별됨\)에 대한 논의는 섹션 3까지, 선택적인 ECC 특정 확장\(Hello 메시지에 영향을 미침\)은 섹션 4까지 연기합니다.

---
### **2.1.  ECDHE_ECDSA**

ECDHE\_ECDSA에서 서버의 인증서는 ECDSA 또는 EdDSA 가능 공개 키를 포함해야 합니다.\(MUST\)

서버는 임시 ECDH 공개 키와 ServerKeyExchange 메시지의 해당 곡선 사양을 보냅니다. 이러한 매개변수는 서버 인증서의 공개 키에 해당하는 개인 키를 사용하여 ECDSA 또는 EdDSA로 서명해야 합니다.\(MUST\)

클라이언트는 서버의 임시 ECDH 키와 동일한 곡선에서 ECDH 키 쌍을 생성하고 공개 키를 ClientKeyExchange 메시지로 보냅니다.

클라이언트와 서버 모두 ECDH 작업\(섹션 5.10 참조\)을 수행하고 결과 공유 비밀을 premaster secret으로 사용합니다.

---
### **2.2.  ECDHE_RSA**

이 키 교환 알고리즘은 서버의 인증서에 서명이 승인된 RSA 공개 키가 포함되어야 하고 ServerKeyExchange 메시지의 서명이 해당 RSA 개인 키로 계산되어야 한다는 점을 제외하면 ECDHE\_ECDSA와 동일합니다.\(MUST\)

---
### **2.3.  ECDH_anon**

참고: "ECDH\_"\(E 없음\)로 시작하는 이름에도 불구하고 ECDH\_anon에서 사용되는 키는 ECDHE\_RSA 및 ECDHE\_ECDSA의 키처럼 일시적입니다. 이름은 DH\_anon의 예를 따르며 키도 임시이지만 이름에 키가 반영되지 않습니다.

ECDH\_anon에서 서버의 인증서, CertificateRequest, 클라이언트의 인증서 및 CertificateVerify 메시지는 보내서는 안 됩니다\(MUST NOT\).\(MUST NOT\)

서버는 임시 ECDH 공개 키와 ServerKeyExchange 메시지의 해당 곡선 사양을 보내야 합니다. 이러한 매개변수는 서명되지 않아야 합니다\(MUST NOT\).\(MUST, MUST NOT\)

클라이언트는 서버의 임시 ECDH 키와 동일한 곡선에서 ECDH 키 쌍을 생성하고 공개 키를 ClientKeyExchange 메시지로 보냅니다.

클라이언트와 서버 모두 ECDH 작업을 수행하고 결과 공유 비밀을 premaster secret으로 사용합니다. 모든 ECDH 계산은 섹션 5.10에 지정된 대로 수행됩니다.

---
### **2.4.  Algorithms in Certificate Chains**

이 사양은 인증서 체인의 어디에서나 사용되는 서명 체계에 제한을 두지 않습니다. 이 문서의 이전 버전에서는 일치하는 서명이 필요했지만 이전 TLS 버전에서 시작된 이 제한은 RFC 5246에서와 마찬가지로 여기에서 해제됩니다.

---
## **3.  Client Authentication**

이 문서는 관련된 클라이언트 인증서 유형인 ECDSA\_sign의 이름을 딴 클라이언트 인증 메커니즘을 정의합니다. ECDSA\_sign 메커니즘은 섹션 2에 설명된 모든 비익명 ECC 키 교환 알고리즘과 TLS에 정의된 기타 비익명\(비ECC\) 키 교환 알고리즘과 함께 사용할 수 있습니다.

EdDSA 공개 키가 있는 클라이언트 인증서도 이 메커니즘을 사용합니다.

서버는 CertificateRequest 메시지에 이 인증서 유형을 포함하여 ECC 기반 클라이언트 인증을 요청할 수 있습니다. 클라이언트는 서버가 제안한 방식에 맞는 인증서를 보유하고 있는지, 이를 인증에 사용할 의향이 있는지 확인해야 합니다.

이러한 조건이 충족되지 않으면 클라이언트는 인증서가 포함되지 않은 클라이언트 인증서 메시지를 보내야 합니다\(SHOULD\). 이 경우 ClientKeyExchange는 섹션 2에 설명된 대로 전송되어야 하며 CertificateVerify는 전송되어서는 안 됩니다. 서버에 클라이언트 인증이 필요한 경우 치명적인 핸드셰이크 실패 경고로 응답할 수 있습니다.\(SHOULD, MUST NOT\)

클라이언트가 적절한 인증서를 가지고 있고 이를 인증에 사용할 의향이 있는 경우 클라이언트의 인증서 메시지\(섹션 5.6에 따라\)에 해당 인증서를 보내고 인증된 키에 해당하는 개인 키의 소유를 증명해야 합니다. 적절한 인증서를 결정하고 소유를 증명하는 프로세스는 인증 메커니즘마다 다르며 아래에 설명되어 있습니다.

참고: 서버가 서버 인증서와 다른 유형의 클라이언트 인증서를 요청하고 클라이언트가 보내는 것이 허용됩니다.

---
### **3.1.  ECDSA_sign**

이 인증 메커니즘을 사용하려면 클라이언트는 ECDSA 또는 EdDSA 가능 공개 키가 포함된 인증서를 소유해야 합니다.\(MUST\)

클라이언트는 5.8절에 설명된 대로 CertificateVerify 메시지에 서명을 포함하여 인증된 키에 해당하는 개인 키의 소유를 증명합니다.

---
## **4.  TLS Extensions for ECC**

이 사양에는 \(i\) 지원되는 타원 곡선 확장 및 \(ii\) 지원되는 포인트 형식 확장의 두 가지 TLS 확장이 정의되어 있습니다. 이를 통해 새 세션을 시작하는 핸드셰이크 중에 특정 곡선 및 포인트 형식\(예: 각각 압축 및 비압축\)의 사용을 협상할 수 있습니다. 이러한 확장은 제한된 수의 곡선 또는 점 형식만 지원할 수 있는 제한된 클라이언트와 특히 관련이 있습니다. \[RFC4366\]에 설명된 일반적인 접근 방식을 따릅니다. 메시지 세부 사항은 섹션 5에 지정되어 있습니다. 클라이언트는 ClientHello 메시지에 적절한 확장을 포함하여 구문 분석할 수 있는 포인트 형식과 지원하는 곡선을 열거합니다. 서버는 ServerHello 메시지에 확장을 포함하여 구문 분석할 수 있는 포인트 형식을 유사하게 열거합니다.

ClientHello 메시지에서 ECC 암호화 제품군을 제안하는 TLS 클라이언트는 이러한 확장을 포함해야 합니다\(SHOULD\). ECC 암호화 제품군을 구현하는 서버는 이러한 확장을 지원해야 하며 클라이언트가 이러한 확장을 사용할 때 서버는 클라이언트가 지정한 곡선 선택을 존중하면서 핸드셰이크를 완료할 수 없는 한 ECC 암호화 제품군의 사용을 협상해서는 안 됩니다\(MUST NOT\). 이렇게 하면 클라이언트가 서버의 EC 키를 처리할 수 없기 때문에 협상된 ECC 핸드셰이크가 나중에 중단될 가능성이 제거됩니다.\(SHOULD, MUST NOT\)

클라이언트는 ECC 암호화 제품군을 제안하지 않는 경우 ClientHello 메시지에 이러한 확장을 포함해서는 안 됩니다\(MUST NOT\). ECC 암호화 제품군을 제안하는 클라이언트는 이러한 확장을 포함하지 않도록 선택할 수 있습니다. 이 경우 서버는 섹션 5에 나열된 타원 곡선 또는 점 형식 중 하나를 자유롭게 선택할 수 있습니다. 해당 섹션에서는 이러한 확장의 구조 및 처리에 대해서도 자세히 설명합니다.\(MUST NOT\)

세션 재개의 경우 서버는 단순히 현재 ClientHello 메시지에 나타나는 Supported Elliptic Curves Extension 및 Supported Point Formats Extension을 무시합니다. 이러한 확장은 새 세션을 협상하는 핸드셰이크 중에만 역할을 합니다.

---
## **5.  Data Structures and Computations**

이 섹션에서는 이전 세 섹션에서 지정한 ECC 기반 키 메커니즘에서 사용하는 데이터 구조 및 계산을 지정합니다. 여기서 사용되는 프레젠테이션 언어는 TLS에서 사용되는 것과 동일합니다. 이 사양은 TLS를 확장하므로 이러한 설명은 TLS 사양 및 TLS를 확장하는 다른 모든 설명과 병합되어야 합니다. 이는 열거형 유형이 가능한 모든 값을 지정하지 않을 수 있으며 select\(\) 절로 선택한 여러 형식의 구조가 모든 가능한 경우를 나타내지 않을 수 있음을 의미합니다.

---
### **5.1.  Client Hello Extensions**

이 섹션은 \[RFC4366\]에 설명된 대로 ClientHello 메시지에 포함될 수 있는 두 가지 TLS 확장인 지원되는 타원 곡선 확장과 지원되는 포인트 형식 확장을 지정합니다.

이러한 확장이 전송될 때:

확장은 ECC 암호화 제품군을 제안하는 ClientHello 메시지와 함께 전송되어야 합니다\(SHOULD\).\(SHOULD\)

이러한 확장의 의미:

이러한 확장을 통해 클라이언트는 지원하는 타원 곡선 및/또는 구문 분석할 수 있는 포인트 형식을 열거할 수 있습니다.

이러한 확장의 구조:

TLS 확장의 일반적인 구조는 \[RFC4366\]에 설명되어 있으며 이 사양에서는 ExtensionType에 두 가지 유형을 추가합니다.

```text
      enum {
          elliptic_curves(10),
          ec_point_formats(11)
      } ExtensionType;
```

o elliptic\_curves\(지원되는 타원 곡선 확장\): 클라이언트에서 지원하는 타원 곡선 집합을 나타냅니다. 이 확장의 경우 불투명 extension\_data 필드에 NamedCurveList가 포함됩니다. 자세한 내용은 섹션 5.1.1을 참조하십시오.

o ec\_point\_formats\(지원되는 포인트 형식 확장\): 클라이언트가 구문 분석할 수 있는 포인트 형식 집합을 나타냅니다. 이 확장의 경우 불투명 extension\_data 필드에 ECPointFormatList가 포함됩니다. 자세한 내용은 섹션 5.1.2를 참조하십시오.

발신자의 조치:

ClientHello 메시지에서 ECC 암호화 제품군을 제안하는 클라이언트는 지원하는 곡선과 구문 분석할 수 있는 포인트 형식을 열거하면서 이러한 확장을 추가합니다\(다른 확장과 함께\). 클라이언트는 Supported Elliptic Curves Extension과 Supported Point Formats Extension을 모두 보내야 합니다\(SHOULD\). 지원되는 포인트 형식 확장이 실제로 전송되면 포인트 형식 목록의 항목 중 하나로 값 0\(압축되지 않음\)을 포함해야 합니다.\(SHOULD, MUST\)

수신자의 조치:

이러한 확장 중 하나 또는 둘 모두를 포함하는 ClientHello를 수신하는 서버는 클라이언트의 열거 기능을 사용하여 적절한 암호화 제품군의 선택을 안내해야 합니다. 제안된 ECC 암호화 제품군 중 하나는 클라이언트가 지원하는 곡선 및 포인트 형식을 사용하는 동안 서버가 핸드셰이크를 성공적으로 완료할 수 있는 경우에만 협상되어야 합니다\(섹션 5.3 및 5.4 참조\).\(MUST\)

참고: ECDHE\_ECDSA 키 교환에 참여하는 서버는 인증서의 ECDSA 또는 EdDSA 키와 ServerKeyExchange 메시지의 임시 ECDH 키에 대해 서로 다른 곡선을 사용할 수 있습니다. 서버는 두 경우 모두 확장을 고려해야 합니다.\(MUST\)

서버가 지원되는 타원 곡선 확장을 이해하지 못하거나 지원되는 포인트 형식 확장을 이해하지 못하거나 열거된 곡선 및 포인트 형식으로 자신을 제한하면서 ECC 핸드셰이크를 완료할 수 없는 경우 ECC 암호 사용을 협상해서는 안 됩니다\(MUST NOT\). 모음곡. 클라이언트에서 제안하고 서버에서 지원하는 다른 암호 제품군에 따라 공통 암호 제품군이 없기 때문에 치명적인 핸드셰이크 실패 경고가 발생할 수 있습니다.\(MUST NOT\)

---
#### **5.1.1.  Supported Elliptic Curves Extension**

RFC 4492는 TLS에서 사용하기 위해 NamedCurve 레지스트리\(현재는 "TLS 지원 그룹" 레지스트리로 이름이 바뀌었지만 아래 열거형 이름은 여전히 ​​NamedCurve임\)에서 25개의 서로 다른 곡선을 정의했습니다. 세 가지만 많이 사용되었습니다. 이 사양은 나머지\(숫자 1-22\)를 더 이상 사용하지 않습니다. 이 사양은 또한 명시적

식별자가 0xFF01 및 0xFF02인 곡선. 또한 \[RFC7748\]에 정의된 새 곡선을 추가합니다. 최종 결과는 다음과 같습니다.

```text
           enum {
               deprecated(1..22),
               secp256r1 (23), secp384r1 (24), secp521r1 (25),
               x25519(29), x448(30),
               reserved (0xFE00..0xFEFF),
               deprecated(0xFF01..0xFF02),
               (0xFFFF)
           } NamedCurve;
```

이후 다른 사양에서 이 열거형에 다른 값을 추가했습니다. 이러한 값 중 일부는 곡선이 아니라 유한 필드 그룹입니다. \[RFC7919\]를 참조하십시오.

secp256r1 등: 해당 명명된 곡선 또는 그룹의 지원을 나타냅니다. 명명된 곡선 secp256r1, secp384r1 및 secp521r1은 SEC 2 \[SECG-SEC2\]에 지정되어 있습니다. 이러한 곡선은 ANSI X9.62 \[ANSI.X9-62.2005\] 및 FIPS 186-4 \[FIPS.186-4\]에서도 권장됩니다. 이 문서의 나머지 부분에서는 이 세 가지 곡선을 "NIST 곡선"이라고 합니다. 왜냐하면 원래 NIST\(National Institute of Standards and Technology\)에서 표준화했기 때문입니다. 곡선 x25519 및 x448은 \[RFC7748\]에 정의되어 있습니다. 0xFE00에서 0xFEFF까지의 값은 개인용으로 예약되어 있습니다.

이 문서의 이전 버전도 명시적으로 정의된 프라임 및 char2 곡선을 지원했지만 이 사양에서는 더 이상 사용되지 않습니다.

NamedCurve 이름 공간\(현재 "TLS 지원 그룹"\)은 IANA에서 유지 관리합니다. 새 값 할당이 추가되는 방법에 대한 정보는 섹션 9를 참조하십시오.

```text
           struct {
               NamedCurve named_curve_list<2..2^16-1>
           } NamedCurveList;
```

named\_curve\_list의 항목은 클라이언트의 기본 설정에 따라 정렬됩니다\(선호하는 항목 먼저\).

예를 들어, secp256r1\(일명 NIST P-256, 값 23 = 0x0017\) 및 secp384r1\(일명 NIST P-384, 값 24 = 0x0018\)만 지원하고 secp256r1 사용을 선호하는 클라이언트는 다음으로 구성된 TLS 확장을 포함합니다. 옥텟. 처음 두 옥텟은 확장 유형\(지원되는 타원 곡선 확장\)을 나타냅니다.

```text
           00 0A 00 06 00 04 00 17 00 18
```

---
#### **5.1.2.  Supported Point Formats Extension**

```text
           enum {
               uncompressed (0),
               deprecated (1..2),
               reserved (248..255)
           } ECPointFormat;
           struct {
               ECPointFormat ec_point_format_list<1..2^8-1>
           } ECPointFormatList;
```

위의 ECPointFormat 정의에는 세 가지 포인트 형식이 포함되어 있습니다. 이 사양은 압축되지 않은 포인트 형식을 제외한 모든 형식을 더 이상 사용하지 않습니다. 이 문서의 구현은 지원되는 모든 곡선에 대해 압축되지 않은 형식을 지원해야 하며 이 사양에 정의된 곡선에 대해 다른 형식을 지원해서는 안 됩니다\(MUST NOT\). 이전 버전과의 호환성을 위해 포인트 형식 목록 확장이 여전히 포함될 수 있으며 압축되지 않은 포인트 형식\(0\)이라는 정확히 하나의 값을 포함할 수 있습니다. RFC 4492는 이 확장이 누락된 경우 압축되지 않은 포인트 형식만 지원됨을 의미하므로 압축되지 않은 형식을 지원하는 구현과의 상호 운용성은 확장이 있든 없든 작동해야 한다고 지정했습니다.\(MUST NOT, MAY\)

클라이언트가 확장을 보내고 확장이 압축되지 않은 포인트 형식을 포함하지 않고 클라이언트가 지원 그룹 확장을 사용하여 이 사양에 정의된 곡선에 대한 지원을 표시한 경우 서버는 핸드셰이크를 중단하고 불법 매개변수를 반환해야 합니다. 알리다.\(MUST\)

ECPointFormat 이름 공간\(현재 "TLS EC 포인트 형식"\)은 IANA에서 유지 관리합니다. 새 값 할당이 추가되는 방법에 대한 정보는 섹션 9를 참조하십시오.

다른 곡선을 지원하지 않는 이 사양을 준수하는 클라이언트는 다음 옥텟을 보내야 합니다. 처음 두 옥텟은 확장 유형\(지원되는 포인트 형식 확장\)을 나타냅니다.\(MUST\)

```text
           00 0B 00 02 01 00
```

---
#### **5.1.3.  The signature_algorithms Extension and EdDSA**

\[RFC5246\]의 섹션 7.4.1.4.1에 정의된 signature\_algorithms 확장은 클라이언트가 지원하는 서명 알고리즘과 해시 함수의 조합을 알립니다. EdDSA의 순수\(사전 해시되지 않은\) 형식은 서명하기 전에 데이터를 해시하지 않습니다. 이러한 이유로 확장에서 해시 함수와 결합하는 것은 의미가 없습니다.

TLS 1.3과의 bit-on-the-wire 호환성을 위해 "Intrinsic"\(값 8\)이라고 하는 "TLS HashAlgorithm" 레지스트리에 새로운 더미 값을 정의합니다. 즉, 해싱이 서명 알고리즘에 내재되어 있음을 의미합니다.

signature\_algorithms 확장에서 ed25519 및 ed448을 나타내려면 값이 각각 \(8,7\) 및 \(8,8\)이어야 합니다.

---
### **5.2.  Server Hello Extension**

이 섹션은 Supported Point Formats Extension인 \[RFC4366\]에 설명된 대로 ServerHello 메시지에 포함될 수 있는 TLS 확장을 지정합니다.

이 확장이 전송될 때:

Supported Point Formats Extension은 ECC 암호화 제품군을 협상할 때 Supported Point Formats Extension을 포함하는 ClientHello 메시지에 대한 응답으로 ServerHello 메시지에 포함됩니다.

이 확장의 의미:

이 확장을 통해 서버는 구문 분석할 수 있는 포인트 형식을 열거할 수 있습니다\(ECDHE\_ECDSA, ECDHE\_RSA 또는 ECDH\_anon 키 교환 알고리즘을 사용할 때 ServerKeyExchange 메시지에 표시되는 곡선의 경우\).

이 확장의 구조:

서버의 Supported Point Formats Extension은 클라이언트의 Supported Point Formats Extension과 구조가 동일합니다\(섹션 5.1.2 참조\). 여기서 ec\_point\_format\_list의 항목은 서버의 기본 설정에 따라 정렬됩니다\(선호하는 항목 먼저\). 서버는 클라이언트 목록에서 찾을 수 없는 항목을 포함할 수 있습니다. 그러나 확장이 없으면 이 사양은 정확히 하나의 포인트 형식을 허용하므로 실제로 불일치의 기회가 없습니다.\(MAY\)

발신자의 조치:

Supported Point Formats Extension을 포함하는 ClientHello 메시지에 대한 응답으로 ECC 암호화 제품군을 선택하는 서버는 이 확장을 ServerHello 메시지에 추가하여 구문 분석할 수 있는 포인트 형식을 열거합니다. Supported Point Formats Extension이 사용될 때 포인트 형식 목록의 항목 중 하나로 값 0\(압축되지 않음\)을 포함해야 합니다.\(MUST\)

수신자의 조치:

Supported Point Formats Extension이 포함된 ServerHello 메시지를 수신하는 클라이언트는 핸드셰이크 동안 서버의 포인트 형식 선택을 존중해야 합니다\(섹션 5.6 및 5.7 참조\). 지원되는 포인트 형식 확장이 ServerHello와 함께 수신되지 않는 경우 이는 비압축 포인트 형식만 허용하는 확장과 동일합니다.\(MUST\)

---
### **5.3.  Server Certificate**

이 메시지가 전송될 때:

이 메시지는 모든 비익명 ECC 기반 키 교환 알고리즘으로 전송됩니다.

이 메시지의 의미:

이 메시지는 서버의 정적 공개 키를 클라이언트에 확실하게 전달하는 데 사용됩니다. 다음 표는 각 키 교환 알고리즘에 적합한 서버 인증서 유형을 보여줍니다. ECC 공개 키는 섹션 5.9에 설명된 대로 인증서에 인코딩되어야 합니다.\(MUST\)

참고: 서버의 인증서 메시지는 일련의 인증서를 전달할 수 있습니다. 표 2에 언급된 제한 사항은 서버의 인증서\(체인의 첫 번째\)에만 적용됩니다.

```text
   +-------------+-----------------------------------------------------+
   | Algorithm   | Server Certificate Type                             |
   +-------------+-----------------------------------------------------+
   | ECDHE_ECDSA | Certificate MUST contain an ECDSA- or EdDSA-capable |
   |             | public key.                                         |
   | ECDHE_RSA   | Certificate MUST contain an RSA public key.         |
   +-------------+-----------------------------------------------------+

                     Table 2: Server Certificate Types
```

이 메시지의 구조:

TLS 인증서 형식과 동일합니다.

발신자의 조치:

서버는 적절한 인증서 체인을 구성하고 이를 인증서 메시지로 클라이언트에 전달합니다. 클라이언트가 지원되는 타원 곡선 확장을 사용한 경우 서버의 공개 키

인증서는 클라이언트의 타원 곡선 선택을 존중해야 합니다. 이 요구 사항을 충족할 수 없는 서버는 ServerHello 메시지에서 ECC 암호화 제품군을 선택하면 안 됩니다.\)\(MUST, MUST NOT\)

수신자의 조치:

클라이언트는 인증서 체인의 유효성을 검사하고 서버의 공개 키를 추출하며 키 유형이 협상된 키 교환 알고리즘에 적합한지 확인합니다. \(치명적인 핸드셰이크 실패의 가능한 이유는 타원 곡선 및 포인트 형식을 처리하는 클라이언트의 기능이 초과되었기 때문입니다. 섹션 5.1. 참조\)

---
### **5.4.  Server Key Exchange**

이 메시지가 전송될 때:

이 메시지는 ECDHE\_ECDSA, ECDHE\_RSA 및 ECDH\_anon 키 교환 알고리즘을 사용할 때 전송됩니다.

이 메시지의 의미:

이 메시지는 서버의 임시 ECDH 공개 키\(및 해당 타원 곡선 도메인 매개변수\)를 클라이언트에 전달하는 데 사용됩니다.

명시적 프라임 및 명시적 char2 곡선에 대한 값을 갖는 데 사용되는 ECCurveType 열거형. 이러한 값은 이제 더 이상 사용되지 않으므로 하나의 값만 남습니다.

이 메시지의 구조:

```text
           enum {
               deprecated (1..2),
               named_curve (3),
               reserved(248..255)
           } ECCurveType;
```

named\_curve 값은 명명된 곡선이 사용됨을 나타냅니다. 이 옵션은 이제 유일하게 남아 있는 형식입니다.

248에서 255 사이의 값은 개인용으로 예약되어 있습니다.

ECCurveType 이름 공간\(현재 "TLS EC 곡선 유형"\)은 IANA에서 유지 관리합니다. 새 값 할당이 추가되는 방법에 대한 정보는 섹션 9를 참조하십시오.

RFC 4492에는 ECCurve 구조 및 ECBasisType 구조에 대한 사양이 있습니다. 이 두 가지 모두 지금은 사용되지 않는 명시적 곡선에만 사용되었기 때문에 지금은 생략되었습니다.

```text
           struct {
               opaque point <1..2^8-1>;
           } ECPoint;
```

point: 이것은 \[ANSI.X9-62.2005\]의 섹션 4.3.6에 있는 변환 루틴을 따르는 타원 곡선 점의 바이트 문자열 표현입니다. 이 바이트 문자열은 비압축, 압축 또는 하이브리드 형식의 타원 곡선 점을 나타낼 수 있지만 이 사양은 비압축 형식을 제외한 모든 형식을 사용하지 않습니다. NIST 곡선의 경우 형식은 편의상 섹션 5.4.1에서 반복됩니다. X25519 및 X448 곡선의 경우 유일하게 유효한 표현은 \[RFC7748\]에 지정된 점의 u 값에 대한 32 또는 56 옥텟 표현입니다. 이 구조는 Ed25519 및 Ed448 공개 키와 함께 사용하면 안 됩니다.\(MUST NOT\)

```text
           struct {
               ECCurveType    curve_type;
               select (curve_type) {
                   case named_curve:
                       NamedCurve namedcurve;
               };
           } ECParameters;
```

curve\_type: 타원 곡선 도메인 매개변수의 유형을 식별합니다.

namedCurve: 타원 곡선 도메인 매개변수의 권장 세트를 지정합니다. Diffie-Hellman이 가능한 곡선을 참조하는 NamedCurve의 모든 값이 허용됩니다. 명시적 곡선의 사용이 중단됨에 따라 이제 여기에는 모든 NamedCurve 값이 포함됩니다.

```text
           struct {
               ECParameters    curve_params;
               ECPoint         public;
           } ServerECDHParams;
```

curve\_params: ECDH 공개 키와 관련된 타원 곡선 도메인 매개변수를 지정합니다.

공개: 임시 ECDH 공개 키입니다.

ServerKeyExchange 메시지는 다음과 같이 확장됩니다.

```text
           enum {
               ec_diffie_hellman
           } KeyExchangeAlgorithm;
```

o ec\_diffie\_hellman: ServerKeyExchange 메시지에 ECDH 공개 키가 포함되어 있음을 나타냅니다.

```text
      select (KeyExchangeAlgorithm) {
          case ec_diffie_hellman:
              ServerECDHParams    params;
              Signature           signed_params;
      } ServerKeyExchange;
```

o 매개변수: ECDH 공개 키 및 관련 도메인 매개변수를 지정합니다.

o signed\_params: 서명이 포함된 매개변수의 해시

- 적용된 해시에 적합합니다. 서명에는 서버의 인증서 메시지에 있는 인증된 공개 키에 해당하는 개인 키가 사용됩니다.

```text
        enum {
            ecdsa(3),
            ed25519(7)
            ed448(8)
        } SignatureAlgorithm;
        select (SignatureAlgorithm) {
           case ecdsa:
                digitally-signed struct {
                    opaque sha_hash[sha_size];
                };
           case ed25519,ed448:
                digitally-signed struct {
                    opaque rawdata[rawdata_size];
                };
        } Signature;
      ServerKeyExchange.signed_params.sha_hash
          SHA(ClientHello.random + ServerHello.random +
                                 ServerKeyExchange.params);
      ServerKeyExchange.signed_params.rawdata
          ClientHello.random + ServerHello.random +
                                 ServerKeyExchange.params;
```

참고: SignatureAlgorithm은 ECDHE\_RSA 키 교환 알고리즘의 경우 "rsa"이고 ECDH\_anon의 경우 "익명"입니다. 이러한 경우는 TLS에 정의되어 있습니다. SignatureAlgorithm은 ECDHE\_ECDSA에 대해 "ecdsa" 또는 "eddsa"입니다.

ECDSA 서명은 섹션 5.10에 설명된 대로 생성되고 확인됩니다. 위의 sha\_hash 템플릿에서 SHA는 SHA-1 이외의 해시 알고리즘을 나타낼 수 있습니다. ANSI X9.62에 따라 ECDSA 서명은 정수 쌍 r과 s로 구성됩니다. 디지털 서명 요소는 불투명 벡터 <0..2^16-1\>로 인코딩되며, 그 내용은 다음 ASN.1 표기법에 해당하는 DER 인코딩입니다.

```text
              Ecdsa-Sig-Value ::= SEQUENCE {
                  r       INTEGER,
                  s       INTEGER
              }
```

프로토콜과 \[RFC8410\]을 준수하는 인증서의 EdDSA 서명은 \[RFC8032\]에 따라 생성되고 확인됩니다. 디지털 서명된 요소는 불투명 벡터 <0..2^16-1\>로 인코딩되며 그 내용에는 EdDSA 서명 알고리즘의 옥텟 문자열 출력이 포함됩니다.

발신자의 조치:

서버는 IEEE 1363\[IEEE.P1363\]의 ECKAS-DH1 체계에 따라 타원 곡선 도메인 매개변수와 이러한 매개변수에 해당하는 임시 ECDH 공개 키를 선택합니다. 위에서 정의한 형식을 사용하여 ServerKeyExchange 메시지에서 이 정보를 클라이언트에 전달합니다.

수신자의 조치:

클라이언트는 서명\(있는 경우\)을 확인하고 ServerKeyExchange 메시지에서 서버의 타원 곡선 도메인 매개변수 및 임시 ECDH 공개 키를 검색합니다. \(치명적인 핸드셰이크 실패의 가능한 이유는 타원 곡선 및 포인트 형식을 처리하는 클라이언트의 기능이 초과되었기 때문입니다. 섹션 5.1. 참조\)

---
#### **5.4.1.  Uncompressed Point Format for NIST Curves**

다음은 ServerKeyExchange 레코드에서 ECPoint를 나타내는 연결 형식을 나타냅니다. 표현의 첫 번째 옥텟은 형식을 나타내며 압축, 비압축 또는 하이브리드일 수 있습니다. 이 사양은 이러한 곡선에 대해 압축되지 않은 형식만 지원합니다. 그 다음에는 "big-endian" 또는 "network" 형식의 X 값에 대한 이진 표현이 오고 "big-endian" 또는 "network" 형식의 Y 값에 대한 이진 표현이 이어집니다. 내부 길이 마커가 없으므로 각 숫자 표현은 곡선 매개변수가 암시하는 만큼 많은 옥텟을 차지합니다. 을 위한

P-256 이것은 X와 Y 각각이 32 옥텟을 사용하고 필요한 경우 왼쪽에 0을 채운다는 것을 의미합니다. P-384의 경우 각각 48옥텟을 사용하고 P-521의 경우 각각 66옥텟을 사용합니다.

보다 공식적인 표현은 다음과 같습니다.

```text
             enum {
                 uncompressed(4),
                 (255)
               } PointConversionForm;

             struct {
                 PointConversionForm  form;
                 opaque               X[coordinate_length];
                 opaque               Y[coordinate_length];
             } UncompressedPointRepresentation;
```

---
### **5.5.  Certificate Request**

이 메시지가 전송될 때:

이 메시지는 클라이언트 인증을 요청할 때 전송됩니다.

이 메시지의 의미:

서버는 이 메시지를 사용하여 허용 가능한 클라이언트 인증 방법을 제안합니다.

이 메시지의 구조:

TLS CertificateRequest 메시지는 다음과 같이 확장됩니다.

```text
           enum {
               ecdsa_sign(64),
               deprecated1(65),  /* was rsa_fixed_ecdh */
               deprecated2(66),  /* was ecdsa_fixed_ecdh */
               (255)
           } ClientCertificateType;
```

o ecdsa\_sign: 서버가 섹션 3에 지정된 해당 클라이언트 인증 방법을 사용하려고 함을 나타냅니다.

RFC 4492는 고정 ECDH 공개 키가 포함된 RSA 및 ECDSA 인증서도 정의했습니다. 이러한 메커니즘은 거의 구현되지 않았으므로 이 사양에서는 더 이상 사용하지 않습니다.

발신자의 조치:

서버는 사용할 클라이언트 인증 방법을 결정하고 위에 정의된 형식을 사용하여 이 정보를 클라이언트에 전달합니다.

수신자의 조치:

클라이언트는 요청된 방법과 함께 사용하기에 적합한 인증서가 있는지 여부와 클라이언트 인증을 진행할지 여부를 결정합니다.

---
### **5.6.  Client Certificate**

이 메시지가 전송될 때:

이 메시지는 클라이언트가 적합한 인증서를 가지고 있고 클라이언트 인증을 진행하기로 결정한 경우 CertificateRequest에 대한 응답으로 전송됩니다. \(서버가 지원되는 포인트 형식 확장을 사용한 경우 인증서에 지정된 공개 키 포인트가 압축되지 않은 경우에만 ECDSA\_sign 인증 방법과 함께 사용하기에 인증서가 적합한 것으로 간주될 수 있습니다. 이는 여전히 지원되는 유일한 포인트 형식이기 때문입니다.

이 메시지의 의미:

이 메시지는 클라이언트의 정적 공개 키를 서버에 확실하게 전달하는 데 사용됩니다. ECC 공개 키는 섹션 5.9에 설명된 대로 인증서에 인코딩되어야 합니다. 인증서에는 ECDSA 또는 EdDSA 가능 공개 키가 포함되어야 합니다.\(MUST\)

참고: 클라이언트의 인증서 메시지는 일련의 인증서를 전달할 수 있습니다. 위에서 언급한 제한 사항은 클라이언트의 인증서\(체인의 첫 번째\)에만 적용됩니다.

이 메시지의 구조:

TLS 클라이언트 인증서 형식과 동일합니다.

발신자의 조치:

클라이언트는 적절한 인증서 체인을 구성하고 이를 인증서 메시지로 서버에 전달합니다.

수신자의 조치:

TLS 서버는 인증서 체인의 유효성을 검사하고 클라이언트의 공개 키를 추출하며 키 유형이 클라이언트 인증 방법에 적합한지 확인합니다.

---
### **5.7.  Client Key Exchange**

이 메시지가 전송될 때:

이 메시지는 모든 키 교환 알고리즘에서 전송됩니다. 여기에는 클라이언트의 임시 ECDH 공개 키가 포함됩니다.

메시지의 의미:

이 메시지는 클라이언트에 속한 키 교환과 관련된 임시 데이터\(예: 임시 ECDH 공개 키\)를 전달하는 데 사용됩니다.

이 메시지의 구조:

TLS ClientKeyExchange 메시지는 다음과 같이 확장됩니다.

```text
           enum {
               implicit,
               explicit
           } PublicValueEncoding;
```

o 암시적, 명시적: ECC 암호화 제품군의 경우 클라이언트의 ECDH 공개 키가 클라이언트의 인증서에 있는지\("암시적"\) 또는 ClientKeyExchange 메시지에서 임시 ECDH 공개 키로 제공되는지\("명시적"\)를 나타냅니다. 암시적 인코딩은 더 이상 사용되지 않으며 이전 버전과의 호환성을 위해서만 여기에서 유지됩니다.

```text
           struct {
               ECPoint ecdh_Yc;
           } ClientECDiffieHellmanPublic;
```

ecdh\_Yc: 압축되지 않은 형식의 타원 곡선 점을 나타낼 수 있는 바이트 문자열 ECPoint.point로 클라이언트의 임시 ECDH 공개 키를 포함합니다.

```text
           struct {
               select (KeyExchangeAlgorithm) {
                   case ec_diffie_hellman: ClientECDiffieHellmanPublic;
               } exchange_keys;
           } ClientKeyExchange;
```

발신자의 조치:

클라이언트는 서버에서 받은 매개변수에 해당하는 임시 ECDH 공개 키를 선택합니다. 형식은 5.4절과 동일합니다.

수신자의 조치:

서버는 ClientKeyExchange 메시지에서 클라이언트의 임시 ECDH 공개 키를 검색하고 서버의 ECDH 키와 동일한 타원 곡선에 있는지 확인합니다.

---
### **5.8.  Certificate Verify**

이 메시지가 전송될 때:

이 메시지는 클라이언트가 디지털 서명에 사용할 수 있는 공개 키가 포함된 클라이언트 인증서를 보낼 때 전송됩니다.

메시지의 의미:

이 메시지에는 클라이언트 인증서 메시지의 공개 키에 해당하는 개인 키의 소유를 증명하는 서명이 포함되어 있습니다.

이 메시지의 구조:

TLS CertificateVerify 메시지와 기본 서명 유형은 TLS 기본 사양에 정의되어 있으며 후자는 섹션 5.4에서 확장됩니다. "ecdsa" 및 "eddsa" 사례의 경우 CertificateVerify 메시지의 서명 필드에는 지금까지 교환된 핸드셰이크 메시지를 통해 계산된 ECDSA 또는 EdDSA 서명이 포함되어 있으며 다른 서명 알고리즘을 사용하는 CertificateVerify와 정확히 유사합니다.

```text
           CertificateVerify.signature.sha_hash
               SHA(handshake_messages);
           CertificateVerify.signature.rawdata
               handshake_messages;
```

ECDSA 서명은 섹션 5.10에 설명된 대로 계산되며 sha\_hash에 대한 위 템플릿의 SHA는 그에 따라 SHA-1 이외의 해시 알고리즘을 나타낼 수 있습니다. ANSI X9.62에 따라 ECDSA 서명은 정수 쌍 r과 s로 구성됩니다. 디지털 서명된 요소는 불투명 벡터 <0..2^16-1\>로 인코딩되며, 그 내용은 다음 ASN.1 표기법 \[X.680\]에 해당하는 DER 인코딩 \[X.690\]입니다.

```text
           Ecdsa-Sig-Value ::= SEQUENCE {
               r       INTEGER,
               s       INTEGER
           }
```

EdDSA 서명은 \[RFC8032\]에 따라 생성되고 확인됩니다. 디지털 서명된 요소는 불투명 벡터 <0..2^16-1\>로 인코딩되며 그 내용에는 EdDSA 서명 알고리즘의 옥텟 문자열 출력이 포함됩니다.

발신자의 조치:

클라이언트는 client hello에서 시작하여 이 메시지를 포함하지 않고 전송되거나 수신된 모든 핸드셰이크 메시지에 대한 서명을 계산합니다. 위에서 정의한 형식으로 전달되는 서명을 계산하기 위해 인증된 공개 키에 해당하는 개인 키를 사용합니다.

수신자의 조치:

서버는 CertificateVerify 메시지에서 클라이언트의 서명을 추출하고 클라이언트의 인증서 메시지에서 받은 공개 키를 사용하여 서명을 확인합니다.

---
### **5.9.  Elliptic Curve Certificates**

ECC 공개 키를 포함하거나 ECDSA를 사용하여 서명된 X.509 인증서는 \[RFC3279\] 또는 이를 대체하거나 확장하는 다른 RFC를 준수해야 합니다. ECC 공개 키를 포함하거나 EdDSA를 사용하여 서명된 X.509 인증서는 \[RFC8410\]을 준수해야 합니다. 클라이언트는 ANSI X9.62, FIPS 186-4 및 SEC 2\[SECG-SEC2\] 또는 \[RFC8032\]에서 권장하는 타원 곡선 도메인 매개변수를 사용해야 합니다\(SHOULD\).\(MUST, MUST, SHOULD\)

Ed25519 알고리즘을 사용하는 EdDSA 키는 ed25519 서명 알고리즘을 사용해야 하며 Ed448 키는 ed448 서명 알고리즘을 사용해야 합니다. 이 문서는 TLS와 함께 Ed25519ph 및 Ed448ph 키의 사용을 정의하지 않습니다. Ed25519, Ed25519ph, Ed448 및 Ed448ph 키는 ECDSA와 함께 사용하면 안 됩니다\(MUST NOT\).\(MUST, MUST NOT\)

---
### **5.10.  ECDH, ECDSA, and RSA Computations**

NIST 곡선에 대한 모든 ECDH 계산\(공유 비밀 계산뿐만 아니라 매개변수 및 키 생성 포함\)은 ECKAS-DH1 체계를 사용하여 \[IEEE.P1363\]에 따라 ID 맵을 키 파생 함수\(KDF\)로 사용하여 수행되므로 프리마스터 비밀은 옥텟 문자열로 표현되는 ECDH 공유 비밀 타원 곡선 점의 x 좌표입니다. FE2OSP\(Field

요소에서 옥텟 문자열 변환 프리미티브로\), 주어진 필드에 대해 일정한 길이를 가집니다. 이 옥텟 문자열에서 발견된 선행 0은 절단되어서는 안 됩니다\(MUST NOT\).\(MUST NOT\)

\(ID KDF의 이러한 사용은 기술적인 문제라는 점에 유의하십시오. 전체 그림은 TLS가 마스터 암호를 계산하는 것 외에 다른 용도로 사전 마스터 암호를 직접 사용하지 않기 때문에 ECDH가 사소한 KDF와 함께 사용된다는 것입니다. TLS 1.0 및 1.1에서 이는 MD5 및 SHA-1 기반 TLS PRF\(Pseudorandom Function\)가 KDF 역할을 한다는 것을 의미합니다. 미래에는 이 계산이 달라질 수 있습니다.\)

X25519\(곡선 x25519\)를 사용하는 ECDHE 키 교환은 다음과 같이 진행됩니다. \(2\) 당사자는 공개 키를 교환하고 공유 비밀을 x\_S = X25519\(d, x\_peer\)로 계산합니다. \(3\) 어느 한쪽이 모두 0인 x\_S를 얻으면 핸드셰이크를 중단해야 합니다\(X25519 및 X448의 정의에서 요구하는 대로\). X448용 ECDHE는 유사하게 작동하여 X25519를 X448로, x25519를 x448로 대체합니다. 파생된 공유 암호는 X25519가 있는 ECDHE가 사용될 때 항상 정확히 32바이트이고 X448이 있는 ECDHE가 사용될 때 56바이트인 사전 마스터 암호로 직접 사용됩니다.\(MUST\)

모든 ECDSA 계산은 ANSI X9.62 또는 그 후속 버전에 따라 수행되어야 합니다. 서명/검증할 데이터는 해싱되며 결과는 추가 해싱 없이 ECDSA 알고리즘을 통해 직접 실행됩니다. \[FIPS.180-4\]의 SHA-256, SHA-384 또는 SHA-512와 같은 보안 해시 함수를 사용해야 합니다.\(MUST, MUST\)

모든 EdDSA 계산은 \[RFC8032\] 또는 그 후속 작업에 따라 수행되어야 합니다. 서명/검증할 데이터는 해싱 없이 EdDSA 알고리즘을 통해 실행됩니다\(EdDSA는 내부적으로 "프리해시" 기능 PH를 통해 데이터를 실행합니다\). Ed448에 대한 컨텍스트 매개변수는 반드시 빈 문자열로 설정되어야 합니다.\(MUST, MUST\)

RFC 4492는 인증서, 아마도 subjectPublicKeyInfo의 매개변수 필드에 필요한 해시 함수를 지정하기 위한 메커니즘의 표준화를 예상했습니다. 이러한 표준화는 이루어지지 않았고 결과적으로 SHA-1은 TLS 1.1 이전 버전에서 사용됩니다\(식별 기능을 사용하는 EdDSA 제외\). TLS 1.2는 DigitallySigned 구조체에 SignatureAndHashAlgorithm 매개변수를 추가하여 서명 해시를 선택할 때 민첩성을 허용했습니다. EdDSA 서명에는 HashAlgorithm이 8\(고유\)이어야 합니다.\(MUST\)

모든 RSA 서명은 \[RFC8017\]의 섹션 7.2에 따라 생성되고 확인되어야 합니다.

---
### **5.11.  Public Key Validation**

NIST 곡선을 사용하여 각 당사자는 ClientKeyExchange 및 ServerKeyExchange 메시지에서 피어가 보낸 공개 키를 확인해야 합니다. 수신 당사자는 피어의 공개 값에서 x 및 y 매개변수가 곡선 방정식 y^2 = x^3 + ax + b mod p를 충족하는지 확인해야 합니다. 자세한 내용은 \[Menezes\]의 섹션 2.3을 참조하십시오. 그렇게 하지 않으면 공격자가 개인 키에 대한 정보를 얻을 수 있어 해당 키가 실제로 임시가 아닌 경우 몇 번의 요청으로 전체 개인 키를 복구할 수 있습니다.\(MUST, MUST\)

X25519 및 X448에서 \[RFC7748\]의 섹션 6에 설명된 대로 수신 당사자는 계산된 프리마스터 비밀이 모두 0인지 여부를 확인하고 그렇다면 핸드셰이크를 중단해야 합니다.\(MUST\)

Ed25519 및 Ed448은 내부적으로 서명 확인의 일부로 공개 키 유효성 검사를 수행합니다.

---
## **6.  Cipher Suites**

아래 표는 섹션 2에 지정된 키 교환 알고리즘을 사용하는 ECC 암호화 제품군을 정의합니다.

```text
       +-----------------------------------------+----------------+
       | CipherSuite                             | Identifier     |
       +-----------------------------------------+----------------+
       | TLS_ECDHE_ECDSA_WITH_NULL_SHA           | { 0xC0, 0x06 } |
       | TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA   | { 0xC0, 0x08 } |
       | TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA    | { 0xC0, 0x09 } |
       | TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA    | { 0xC0, 0x0A } |
       | TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256 | { 0xC0, 0x2B } |
       | TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384 | { 0xC0, 0x2C } |
       |                                         |                |
       | TLS_ECDHE_RSA_WITH_NULL_SHA             | { 0xC0, 0x10 } |
       | TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA     | { 0xC0, 0x12 } |
       | TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA      | { 0xC0, 0x13 } |
       | TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA      | { 0xC0, 0x14 } |
       | TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256   | { 0xC0, 0x2F } |
       | TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384   | { 0xC0, 0x30 } |
       |                                         |                |
       | TLS_ECDH_anon_WITH_NULL_SHA             | { 0xC0, 0x15 } |
       | TLS_ECDH_anon_WITH_3DES_EDE_CBC_SHA     | { 0xC0, 0x17 } |
       | TLS_ECDH_anon_WITH_AES_128_CBC_SHA      | { 0xC0, 0x18 } |
       | TLS_ECDH_anon_WITH_AES_256_CBC_SHA      | { 0xC0, 0x19 } |
       +-----------------------------------------+----------------+

                      Table 3: TLS ECC Cipher Suites
```

키 교환 방법, 암호 및 이러한 각 암호 제품군에 대한 해시 알고리즘은 이름을 검사하여 쉽게 결정됩니다. 암호\(AES 암호 이외\) 및 해시 알고리즘은 \[RFC2246\] 및 \[RFC4346\]에 정의되어 있습니다. AES 암호는 \[RFC5246\]에 정의되어 있고 AES-GCM 암호 모음은 \[RFC5289\]에 있습니다.

서버 구현은 다음 암호 제품군을 모두 지원해야 하며\(SHOULD\) 클라이언트 구현은 이들 중 적어도 하나를 지원해야 합니다\(SHOULD\).\(SHOULD\)

```text
   o  TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256

   o  TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA

   o  TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256

   o  TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA
```

---
## **7.  Implementation Status**

NIST 곡선이 있는 ECDHE 및 ECDSA는 모두 모든 주요 브라우저와 널리 사용되는 모든 TLS 라이브러리에서 광범위하게 구현되고 지원됩니다. Curve25519가 포함된 ECDHE는 이제 여러 브라우저와 OpenSSL을 포함한 여러 TLS 라이브러리에서 구현됩니다. Curve448과 EdDSA는 상호 운용 가능한 구현을 가지고 있지만 아직 널리 배포되지는 않았습니다.

---
## **8.  Security Considerations**

보안 문제는 이 메모 전체에서 논의됩니다.

ECC 암호화 제품군을 사용하는 TLS 핸드셰이크의 경우 세 가지 TLS 기본 문서 각각의 부록 D에 있는 보안 고려 사항이 그에 따라 적용됩니다.

ECC와 관련된 보안 논의는 \[IEEE.P1363\] 및 \[ANSI.X9-62.2005\]에서 찾을 수 있습니다. 구현자와 사용자가 고려해야 하는 한 가지 중요한 문제는 타원 곡선 선택입니다. 적절한 타원 곡선 크기 선택에 대한 지침은 표 1에 나와 있습니다. X25519 및 X448과 관련된 보안 고려 사항은 \[RFC7748\]의 섹션 7에서 설명합니다.

타원곡선의 크기 외에 주요 이슈는 타원곡선 구조이다. 일반적으로 가능한 대수 구조가 적은 타원 곡선을 사용하는 것이 더 보수적입니다. 따라서 랜덤 곡선은 코블리츠 곡선과 같은 특수 곡선보다 더 보수적이며, p 랜덤을 갖는 F\_p에 대한 곡선은 특수한 형태의 p를 갖는 F\_p에 대한 곡선보다 더 보수적이며,

특성 2에 대해 유사한 크기의 여러 필드 간에 선택이 없기 때문에 p 랜덤이 있는 F\_p에 대한 곡선은 F\_2^m에 대한 곡선보다 더 보수적인 것으로 간주됩니다.

또 다른 문제는 단일 타원 곡선이 널리 사용될 때 치명적인 오류가 발생할 가능성입니다. 이 경우 타원 곡선에 대한 공격으로 인해 많은 수의 키가 손상될 수 있습니다. 다시 말하지만, 이 문제는 널리 사용되는 곡선과 관련된 효율성 및 상호 운용성 개선과 균형을 이루어야 할 수 있습니다. 타원 곡선 선택에 대한 실질적인 추가 정보는 \[IEEE.P1363\], \[ANSI.X9-62.2005\] 및 \[FIPS.186-4\]에서 찾을 수 있습니다.

\[RFC8032\] 소개에는 NIST 곡선을 사용하는 ECDSA 서명에 비해 EdDSA 서명의 보안, 성능 및 운영상의 이점이 나열되어 있습니다.

이 문서에 정의된 모든 키 교환 알고리즘은 순방향 비밀성을 제공합니다. 더 이상 사용되지 않는 일부 키 교환 알고리즘은 그렇지 않습니다.

---
## **9.  IANA Considerations**

이 문서의 전신인 \[RFC4492\]는 다음에 대한 IANA 레지스트리를 정의했습니다.

```text
   o  Supported Groups (Section 5.1)

   o  EC Point Format (Section 5.1)

   o  EC Curve Type (Section 5.4)
```

IANA는 이 세 개의 레지스트리 이름 앞에 "TLS"를 추가했습니다.

각 네임스페이스에 대해 이 문서는 초기 값 할당을 정의하고 개인용으로 예약된 256개 값\(NamedCurve\) 또는 8개 값\(ECPointFormat 및 ECCurveType\) 범위를 정의합니다. 추가 할당에 대한 정책은 "사양 필수"입니다. \(RFC 4492는 IETF 검토를 요구합니다.\)

RFC 4492를 참조하는 "ExtensionType Values", "TLS ClientCertificateType Identifiers", "TLS Cipher Suites", "TLS Supported Groups", "TLS EC Point Format" 및 "TLS EC Curve Type" 레지스트리의 모든 기존 항목은 이 문서를 참조하도록 업데이트되었습니다.

IANA는 "TLS 지원 그룹" 레지스트리에서 값 29를 x25519에, 값 30을 x448에 할당했습니다.

IANA는 이 문서를 참조로 사용하여 ed25519\(7\) 및 ed448\(8\)에 대한 "TLS SignatureAlgorithm" 레지스트리에 두 개의 값을 할당했습니다. 이렇게 하면 TLS 1.3과의 호환성이 유지됩니다.

IANA는 DTLS-OK가 true\(Y\)로 설정되고 이 문서를 참조로 설정하여 Intrinsic\(8\)에 대해 "TLS HashAlgorithm" 레지스트리에서 하나의 값을 할당했습니다. 이렇게 하면 TLS 1.3과의 호환성이 유지됩니다.

---
## **10.  References**
---
### **10.1.  Normative References**

\[ANSI.X9-62.2005\]

- American National Standards Institute, "금융 서비스 산업을 위한 공개 키 암호화: 타원 곡선 디지털 서명 알고리즘\(ECDSA\)", ANSI X9.62, 2005년 11월.

```text
   [FIPS.186-4]
              National Institute of Standards and Technology, "Digital
              Signature Standard (DSS)", FIPS PUB 186-4,
              DOI 10.6028/NIST.FIPS.186-4, July 2013,
              <http://nvlpubs.nist.gov/nistpubs/FIPS/
              NIST.FIPS.186-4.pdf>.

   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", BCP 14, RFC 2119,
              DOI 10.17487/RFC2119, March 1997,
              <https://www.rfc-editor.org/info/rfc2119>.

   [RFC2246]  Dierks, T. and C. Allen, "The TLS Protocol Version 1.0",
              RFC 2246, DOI 10.17487/RFC2246, January 1999,
              <https://www.rfc-editor.org/info/rfc2246>.

   [RFC3279]  Bassham, L., Polk, W., and R. Housley, "Algorithms and
              Identifiers for the Internet X.509 Public Key
              Infrastructure Certificate and Certificate Revocation List
              (CRL) Profile", RFC 3279, DOI 10.17487/RFC3279, April
              2002, <https://www.rfc-editor.org/info/rfc3279>.

   [RFC4346]  Dierks, T. and E. Rescorla, "The Transport Layer Security
              (TLS) Protocol Version 1.1", RFC 4346,
              DOI 10.17487/RFC4346, April 2006,
              <https://www.rfc-editor.org/info/rfc4346>.

   [RFC4366]  Blake-Wilson, S., Nystrom, M., Hopwood, D., Mikkelsen, J.,
              and T. Wright, "Transport Layer Security (TLS)
              Extensions", RFC 4366, DOI 10.17487/RFC4366, April 2006,
              <https://www.rfc-editor.org/info/rfc4366>.

   [RFC5246]  Dierks, T. and E. Rescorla, "The Transport Layer Security
              (TLS) Protocol Version 1.2", RFC 5246,
              DOI 10.17487/RFC5246, August 2008,
              <https://www.rfc-editor.org/info/rfc5246>.

   [RFC5289]  Rescorla, E., "TLS Elliptic Curve Cipher Suites with SHA-
              256/384 and AES Galois Counter Mode (GCM)", RFC 5289,
              DOI 10.17487/RFC5289, August 2008,
              <https://www.rfc-editor.org/info/rfc5289>.

   [RFC7748]  Langley, A., Hamburg, M., and S. Turner, "Elliptic Curves
              for Security", RFC 7748, DOI 10.17487/RFC7748, January
              2016, <https://www.rfc-editor.org/info/rfc7748>.

   [RFC8017]  Moriarty, K., Ed., Kaliski, B., Jonsson, J., and A. Rusch,
              "PKCS #1: RSA Cryptography Specifications Version 2.2",
              RFC 8017, DOI 10.17487/RFC8017, November 2016,
              <https://www.rfc-editor.org/info/rfc8017>.

   [RFC8032]  Josefsson, S. and I. Liusvaara, "Edwards-Curve Digital
              Signature Algorithm (EdDSA)", RFC 8032,
              DOI 10.17487/RFC8032, January 2017,
              <https://www.rfc-editor.org/info/rfc8032>.

   [RFC8174]  Leiba, B., "Ambiguity of Uppercase vs Lowercase in RFC
              2119 Key Words", BCP 14, RFC 8174, DOI 10.17487/RFC8174,
              May 2017, <https://www.rfc-editor.org/info/rfc8174>.

   [RFC8410]  Josefsson, S. and J. Schaad, "Algorithm Identifiers for
              Ed25519, Ed448, X25519 and X448 for Use in the Internet
              X.509 Public Key Infrastructure", RFC 8410,
              DOI 10.17487/RFC8410, August 2018,
              <https://www.rfc-editor.org/info/rfc8410>.

   [SECG-SEC2]
              Certicom Research, "SEC 2: Recommended Elliptic Curve
              Domain Parameters", Standards for Efficient Cryptography 2
              (SEC 2), Version 2.0, January 2010,
              <http://www.secg.org/sec2-v2.pdf>.
```

\[X.680\] ITU-T, "Abstract Syntax Notation One\(ASN.1\):

- 기본 표기법 사양", ITU-T Recommendation X.680, ISO/IEC 8824-1, 2015년 8월.

\[X.690\] ITU-T, "정보 기술-ASN.1 인코딩 규칙: BER\(Basic Encoding Rules\), CER\(Canonical Encoding Rules\) 및 DER\(Distinguished Encoding Rules\)", ITU-T Recommendation X.690 , ISO/IEC 8825-1, 2015년 8월.

---
### **10.2.  Informative References**

```text
   [FIPS.180-4]
              National Institute of Standards and Technology, "Secure
              Hash Standard (SHS)", FIPS PUB 180-4, DOI
              10.6028/NIST.FIPS.180-4, August 2015,
              <http://nvlpubs.nist.gov/nistpubs/FIPS/
              NIST.FIPS.180-4.pdf>.

   [IEEE.P1363]
              IEEE, "Standard Specifications for Public Key
              Cryptography", IEEE Std P1363,
              <http://ieeexplore.ieee.org/document/891000/>.
```

\[Menezes\] Menezes, A. 및 B. Ustaoglu, "Diffie-Hellman 키 합의 프로토콜에서 임시 키 재사용", 국제 응용 암호화 저널, Vol. 2, 2호, DOI 10.1504/IJACT.2010.038308, 2010년 1월.

```text
   [RFC4492]  Blake-Wilson, S., Bolyard, N., Gupta, V., Hawk, C., and B.
              Moeller, "Elliptic Curve Cryptography (ECC) Cipher Suites
              for Transport Layer Security (TLS)", RFC 4492,
              DOI 10.17487/RFC4492, May 2006,
              <https://www.rfc-editor.org/info/rfc4492>.

   [RFC7919]  Gillmor, D., "Negotiated Finite Field Diffie-Hellman
              Ephemeral Parameters for Transport Layer Security (TLS)",
              RFC 7919, DOI 10.17487/RFC7919, August 2016,
              <https://www.rfc-editor.org/info/rfc7919>.
```

\[TLS1.3\] Rescorla, E., "TLS\(전송 계층 보안\) 프로토콜 버전 1.3", 진행 중인 작업, draft-ietf-tls-tls13-28, 2018년 3월.

---
# **Appendix A.  Equivalent Curves (Informative)**

모든 NIST 곡선\[FIPS.186-4\]과 여러 ANSI 곡선\[ANSI.X9-62.2005\]은 섹션 5.1.1에 나열된 곡선과 동일합니다. 다음 표는 다양한 표준 기관에서 선택한 곡선 이름을 표시합니다. 한 행의 여러 이름은 동일한 곡선의 별칭을 나타냅니다.

```text
                  +-----------+------------+------------+
                  | SECG      | ANSI X9.62 | NIST       |
                  +-----------+------------+------------+
                  | sect163k1 |            | NIST K-163 |
                  | sect163r1 |            |            |
                  | sect163r2 |            | NIST B-163 |
                  | sect193r1 |            |            |
                  | sect193r2 |            |            |
                  | sect233k1 |            | NIST K-233 |
                  | sect233r1 |            | NIST B-233 |
                  | sect239k1 |            |            |
                  | sect283k1 |            | NIST K-283 |
                  | sect283r1 |            | NIST B-283 |
                  | sect409k1 |            | NIST K-409 |
                  | sect409r1 |            | NIST B-409 |
                  | sect571k1 |            | NIST K-571 |
                  | sect571r1 |            | NIST B-571 |
                  | secp160k1 |            |            |
                  | secp160r1 |            |            |
                  | secp160r2 |            |            |
                  | secp192k1 |            |            |
                  | secp192r1 | prime192v1 | NIST P-192 |
                  | secp224k1 |            |            |
                  | secp224r1 |            | NIST P-224 |
                  | secp256k1 |            |            |
                  | secp256r1 | prime256v1 | NIST P-256 |
                  | secp384r1 |            | NIST P-384 |
                  | secp521r1 |            | NIST P-521 |
                  +-----------+------------+------------+

        Table 4: Equivalent Curves Defined by SECG, ANSI, and NIST
```

---
# **Appendix B.  Differences from RFC 4492**

o EllipticCurveList의 이름을 NamedCurveList로 변경했습니다.

```text
   o  Added TLS 1.2.

   o  Merged errata.
```

o ECDH 키 교환 알고리즘 제거: ECDH\_RSA 및 ECDH\_ECDSA

o 사용되지 않는 여러 암호 모음:

```text
         TLS_ECDH_ECDSA_WITH_NULL_SHA

         TLS_ECDH_ECDSA_WITH_RC4_128_SHA

         TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA

         TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA

         TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA

         TLS_ECDH_RSA_WITH_NULL_SHA

         TLS_ECDH_RSA_WITH_RC4_128_SHA

         TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA

         TLS_ECDH_RSA_WITH_AES_128_CBC_SHA

         TLS_ECDH_RSA_WITH_AES_256_CBC_SHA
```

- 다른 모든 RC4 암호화 모음

o 압축되지 않은 점 형식을 제외하고 사용하지 않는 곡선과 모든 항목을 제거했습니다.

o X25519 및 X448을 추가했습니다.

```text
   o  Deprecated explicit curves.
```

o 인증서의 서명 알고리즘에 대한 제한이 제거되었습니다.

---
# **Acknowledgements**

이 문서의 대부분의 텍스트는 이 문서의 전신인 \[RFC4492\]에서 가져왔습니다. 해당 문서의 작성자는 다음과 같습니다.

```text
   o  Simon Blake-Wilson
   o  Nelson Bolyard
   o  Vipul Gupta
   o  Chris Hawk
   o  Bodo Moeller
```

이전 문서에서 작성자는 Bill Anderson과 Tim Dierks의 기여를 인정했습니다.

저자는 이 문서에 기여한 Nikos Mavrogiannopoulos, Martin Thomson 및 Tanja Lange에게 감사를 표합니다.

---
# **Authors' Addresses**

```text
   Yoav Nir
   Check Point Software Technologies Ltd.
   5 Hasolelim st.
   Tel Aviv  6789735
   Israel

   Email: ynir.ietf@gmail.com

   Simon Josefsson
   SJD AB

   Email: simon@josefsson.org

   Manuel Pegourie-Gonnard
   ARM

   Email: mpg@elzevir.fr
```
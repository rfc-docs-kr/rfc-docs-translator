

```text
Network Working Group                                     H. Schulzrinne
Request for Comments: 3550                           Columbia University
Obsoletes: 1889                                               S.  Casner
Category: Standards Track                                  Packet Design
                                                            R. Frederick
                                                  Blue Coat Systems Inc.
                                                             V. Jacobson
                                                           Packet Design
                                                               July 2003

          RTP: A Transport Protocol for Real-Time Applications
```

---
# **Status of this Memo**

이 문서는 인터넷 커뮤니티를 위한 인터넷 표준 추적 프로토콜을 지정하고 개선을 위한 토론 및 제안을 요청합니다. 이 프로토콜의 표준화 상태 및 상태에 대해서는 "Internet Official Protocol Standards"\(STD 1\) 최신판을 참조하십시오. 이 메모의 배포는 무제한입니다.

---
# **Copyright Notice**

저작권\(C\)인터넷학회\(2003\). 판권 소유.

---
# **Abstract**

이 각서는 실시간 전송 프로토콜인 RTP에 대해 설명합니다. RTP는 멀티캐스트 또는 유니캐스트 네트워크 서비스를 통해 오디오, 비디오 또는 시뮬레이션 데이터와 같은 실시간 데이터를 전송하는 애플리케이션에 적합한 종단 간 네트워크 전송 기능을 제공합니다. RTP는 자원 예약을 다루지 않으며 실시간 서비스에 대한 서비스 품질을 보장하지 않습니다. 데이터 전송은 제어 프로토콜\(RTCP\)에 의해 강화되어 대규모 멀티캐스트 네트워크로 확장 가능한 방식으로 데이터 전달을 모니터링하고 최소한의 제어 및 식별 기능을 제공합니다. RTP 및 RTCP는 기본 전송 및 네트워크 계층과 독립적으로 설계되었습니다. 이 프로토콜은 RTP 수준 변환기 및 믹서의 사용을 지원합니다.

이 각서의 텍스트 대부분은 더 이상 사용되지 않는 RFC 1889와 동일합니다. 유선상의 패킷 형식에는 변경 사항이 없으며 프로토콜 사용 방법을 관리하는 규칙 및 알고리즘만 변경됩니다. 가장 큰 변화는 많은 참가자가 동시에 세션에 참여할 때 의도한 속도를 초과하는 전송을 최소화하기 위해 RTCP 패킷을 보낼 시기를 계산하는 확장 가능한 타이머 알고리즘이 향상되었다는 것입니다.

---
# **Table of Contents**

```text
   1.  Introduction ................................................   4
       1.1  Terminology ............................................   5
   2.  RTP Use Scenarios ...........................................   5
       2.1  Simple Multicast Audio Conference ......................   6
       2.2  Audio and Video Conference .............................   7
       2.3  Mixers and Translators .................................   7
       2.4  Layered Encodings ......................................   8
   3.  Definitions .................................................   8
   4.  Byte Order, Alignment, and Time Format ......................  12
   5.  RTP Data Transfer Protocol ..................................  13
       5.1  RTP Fixed Header Fields ................................  13
       5.2  Multiplexing RTP Sessions ..............................  16
       5.3  Profile-Specific Modifications to the RTP Header .......  18
            5.3.1  RTP Header Extension ............................  18
   6.  RTP Control Protocol -- RTCP ................................  19
       6.1  RTCP Packet Format .....................................  21
       6.2  RTCP Transmission Interval .............................  24
            6.2.1  Maintaining the Number of Session Members .......  28
       6.3  RTCP Packet Send and Receive Rules .....................  28
            6.3.1  Computing the RTCP Transmission Interval ........  29
            6.3.2  Initialization ..................................  30
            6.3.3  Receiving an RTP or Non-BYE RTCP Packet .........  31
            6.3.4  Receiving an RTCP BYE Packet ....................  31
            6.3.5  Timing Out an SSRC ..............................  32
            6.3.6  Expiration of Transmission Timer ................  32
            6.3.7  Transmitting a BYE Packet .......................  33
            6.3.8  Updating we_sent ................................  34
            6.3.9  Allocation of Source Description Bandwidth ......  34
       6.4  Sender and Receiver Reports ............................  35
            6.4.1  SR: Sender Report RTCP Packet ...................  36
            6.4.2  RR: Receiver Report RTCP Packet .................  42
            6.4.3  Extending the Sender and Receiver Reports .......  42
            6.4.4  Analyzing Sender and Receiver Reports ...........  43
       6.5  SDES: Source Description RTCP Packet ...................  45
            6.5.1  CNAME: Canonical End-Point Identifier SDES Item .  46
            6.5.2  NAME: User Name SDES Item .......................  48
            6.5.3  EMAIL: Electronic Mail Address SDES Item ........  48
            6.5.4  PHONE: Phone Number SDES Item ...................  49
            6.5.5  LOC: Geographic User Location SDES Item .........  49
            6.5.6  TOOL: Application or Tool Name SDES Item ........  49
            6.5.7  NOTE: Notice/Status SDES Item ...................  50
            6.5.8  PRIV: Private Extensions SDES Item ..............  50
       6.6  BYE: Goodbye RTCP Packet ...............................  51
       6.7  APP: Application-Defined RTCP Packet ...................  52
   7.  RTP Translators and Mixers ..................................  53
       7.1  General Description ....................................  53
       7.2  RTCP Processing in Translators .........................  55
       7.3  RTCP Processing in Mixers ..............................  57
       7.4  Cascaded Mixers ........................................  58
   8.  SSRC Identifier Allocation and Use ..........................  59
       8.1  Probability of Collision ...............................  59
       8.2  Collision Resolution and Loop Detection ................  60
       8.3  Use with Layered Encodings .............................  64
   9.  Security ....................................................  65
       9.1  Confidentiality ........................................  65
       9.2  Authentication and Message Integrity ...................  67
   10. Congestion Control ..........................................  67
   11. RTP over Network and Transport Protocols ....................  68
   12. Summary of Protocol Constants ...............................  69
       12.1 RTCP Packet Types ......................................  70
       12.2 SDES Types .............................................  70
   13. RTP Profiles and Payload Format Specifications ..............  71
   14. Security Considerations .....................................  73
   15. IANA Considerations .........................................  73
   16. Intellectual Property Rights Statement ......................  74
   17. Acknowledgments .............................................  74
   Appendix A.   Algorithms ........................................  75
   Appendix A.1  RTP Data Header Validity Checks ...................  78
   Appendix A.2  RTCP Header Validity Checks .......................  82
   Appendix A.3  Determining Number of Packets Expected and Lost ...  83
   Appendix A.4  Generating RTCP SDES Packets ......................  84
   Appendix A.5  Parsing RTCP SDES Packets .........................  85
   Appendix A.6  Generating a Random 32-bit Identifier .............  85
   Appendix A.7  Computing the RTCP Transmission Interval ..........  87
   Appendix A.8  Estimating the Interarrival Jitter ................  94
   Appendix B.   Changes from RFC 1889 .............................  95
   References ...................................................... 100
   Normative References ............................................ 100
   Informative References .......................................... 100
   Authors' Addresses .............................................. 103
   Full Copyright Statement ........................................ 104
```

---
## **1. Introduction**

이 각서는 대화형 오디오 및 비디오와 같은 실시간 특성을 가진 데이터에 대한 엔드투엔드 전달 서비스를 제공하는 실시간 전송 프로토콜\(RTP\)을 지정합니다. 이러한 서비스에는 페이로드 유형 식별, 시퀀스 번호 지정, 타임스탬프 및 배달 모니터링이 포함됩니다. 애플리케이션은 일반적으로 UDP 위에서 RTP를 실행하여 멀티플렉싱 및 체크섬 서비스를 활용합니다. 두 프로토콜 모두 전송 프로토콜 기능의 일부를 제공합니다. 그러나 RTP는 다른 적합한 기본 네트워크 또는 전송 프로토콜과 함께 사용될 수 있습니다\(섹션 11 참조\). RTP는 기본 네트워크에서 제공하는 경우 멀티캐스트 배포를 사용하여 여러 대상으로의 데이터 전송을 지원합니다.

RTP 자체는 적시 전달을 보장하거나 기타 서비스 품질 보장을 제공하는 메커니즘을 제공하지 않지만 이를 위해 하위 계층 서비스에 의존합니다. 이는 전달을 보장하거나 잘못된 전달을 방지하지 않으며, 기본 네트워크가 안정적이고 패킷을 순서대로 전달한다고 가정하지도 않습니다. RTP에 포함된 시퀀스 번호를 사용하면 수신자가 보낸 사람의 패킷 시퀀스를 재구성할 수 있지만, 시퀀스 번호는 패킷을 순서대로 디코딩할 필요 없이 비디오 디코딩 등에서 패킷의 적절한 위치를 결정하는 데 사용될 수도 있습니다.

RTP는 주로 다중 참가자 멀티미디어 회의의 요구 사항을 충족하도록 설계되었지만 특정 응용 프로그램에만 국한되지는 않습니다. 지속적인 데이터 저장, 대화형 분산 시뮬레이션, 활성 배지, 제어 및 측정 애플리케이션에도 RTP를 적용할 수 있습니다.

이 문서는 밀접하게 연결된 두 부분으로 구성된 RTP를 정의합니다.

o 실시간 속성을 가진 데이터를 전달하기 위한 실시간 전송 프로토콜\(RTP\).

o RTCP\(RTP 제어 프로토콜\), 서비스 품질을 모니터링하고 진행 중인 세션의 참가자에 대한 정보를 전달합니다. RTCP의 후자 측면은 "느슨하게 제어되는" 세션, 즉 명시적인 멤버십 제어 및 설정이 없는 세션에 충분할 수 있지만 반드시 애플리케이션의 제어 통신 요구 사항을 모두 지원하도록 의도된 것은 아닙니다. 이 기능은 이 문서의 범위를 벗어나는 별도의 세션 제어 프로토콜에 완전히 또는 부분적으로 포함될 수 있습니다.

RTP는 Clark과 Tennenhouse가 제안한 애플리케이션 수준 프레이밍 및 통합 계층 처리 원칙을 따르는 새로운 스타일의 프로토콜을 나타냅니다. 즉, RTP는 가단성을 갖도록 설계되었습니다.

특정 애플리케이션에 필요한 정보를 제공하기 위해 별도의 레이어로 구현되기보다는 애플리케이션 처리에 통합되는 경우가 많습니다. RTP는 의도적으로 완전하지 않은 프로토콜 프레임워크입니다. 이 문서에서는 RTP가 적합한 모든 애플리케이션에서 공통적으로 사용될 것으로 예상되는 기능을 지정합니다. 프로토콜을 보다 일반적으로 만들거나 구문 분석이 필요한 옵션 메커니즘을 추가하여 추가 기능을 수용할 수 있는 기존 프로토콜과 달리 RTP는 필요에 따라 헤더에 대한 수정 및/또는 추가를 통해 맞춤화되도록 고안되었습니다. 예제는 섹션 5.3과 6.4.3에 나와 있습니다.

따라서 이 문서 외에도 특정 애플리케이션에 대한 RTP의 전체 사양에는 하나 이상의 동반 문서가 필요합니다\(섹션 13 참조\).

o 페이로드 유형 코드 세트와 페이로드 형식\(예: 미디어 인코딩\)에 대한 매핑을 정의하는 프로필 사양 문서. 프로필은 특정 응용 프로그램 클래스에 특정한 RTP에 대한 확장이나 수정을 정의할 수도 있습니다. 일반적으로 응용 프로그램은 하나의 프로필에서만 작동합니다. 오디오 및 비디오 데이터에 대한 프로필은 RFC 3551 \[1\]에서 찾을 수 있습니다.

o 오디오 또는 비디오 인코딩과 같은 특정 페이로드가 RTP로 전달되는 방법을 정의하는 페이로드 형식 사양 문서.

구현을 위한 실시간 서비스 및 알고리즘에 대한 논의와 일부 RTP 설계 결정에 대한 배경 논의는 \[11\]에서 확인할 수 있습니다.

---
## **1.1 Terminology**

이 문서의 핵심 단어 "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY" 및 "OPTIONAL"은 다음과 같습니다. BCP 14, RFC 2119 \[2\]에 설명된 대로 해석되며 호환 RTP 구현을 위한 요구 사항 수준을 나타냅니다.\(MUST NOT\)

---
## **2. RTP Use Scenarios**

다음 섹션에서는 RTP 사용의 몇 가지 측면을 설명합니다. 예제는 RTP의 용도를 제한하지 않고 RTP를 사용하는 애플리케이션의 기본 작동을 설명하기 위해 선택되었습니다. 이 예에서 RTP는 IP 및 UDP 위에 전달되며 RFC 3551과 함께 지정된 오디오 및 비디오 프로필에 의해 설정된 규칙을 따릅니다.

---
## **2.1 Simple Multicast Audio Conference**

IETF의 실무 그룹은 음성 통신을 위해 인터넷의 IP 멀티캐스트 서비스를 사용하여 최신 프로토콜 문서를 논의하기 위해 회의를 갖습니다. 일부 할당 메커니즘을 통해 작업 그룹 의장은 멀티캐스트 그룹 주소와 포트 쌍을 얻습니다. 한 포트는 오디오 데이터에 사용되고 다른 포트는 제어\(RTCP\) 패킷에 사용됩니다. 이 주소와 포트 정보는 의도된 참가자에게 배포됩니다. 개인 정보 보호가 필요한 경우 섹션 9.1에 지정된 대로 데이터 및 제어 패킷을 암호화할 수 있으며, 이 경우 암호화 키도 생성 및 배포되어야 합니다. 이러한 할당 및 배포 메커니즘의 정확한 세부 사항은 RTP의 범위를 벗어납니다.

각 회의 참가자가 사용하는 오디오 회의 애플리케이션은 20ms 정도의 작은 단위로 오디오 데이터를 전송합니다. 오디오 데이터의 각 청크 앞에는 RTP 헤더가 옵니다. RTP 헤더와 데이터는 차례로 UDP 패킷에 포함됩니다. RTP 헤더는 각 패킷에 포함된 오디오 인코딩 유형\(예: PCM, ADPCM 또는 LPC\)을 나타냅니다. 예를 들어 낮은 대역폭을 통해 연결된 새 참가자를 수용하기 위해 발신자가 회의 중에 인코딩을 변경할 수 있습니다. 네트워크 정체 표시에 연결하거나 반응합니다.

다른 패킷 네트워크와 마찬가지로 인터넷은 때때로 패킷을 잃어버리거나 재정렬하고 다양한 시간만큼 지연시킵니다. 이러한 손상에 대처하기 위해 RTP 헤더에는 수신기가 소스에서 생성된 타이밍을 재구성할 수 있도록 하는 타이밍 정보와 시퀀스 번호가 포함되어 있으므로 이 예에서는 오디오 청크가 20ms마다 스피커에서 연속적으로 재생됩니다. 이 타이밍 재구성은 회의에서 RTP 패킷의 각 소스에 대해 별도로 수행됩니다. 시퀀스 번호는 수신기에서 손실되는 패킷 수를 추정하는 데 사용될 수도 있습니다.

실무 그룹 구성원은 컨퍼런스 중에 참여하고 나가기 때문에 언제든지 누가 참여하고 있는지, 오디오 데이터를 얼마나 잘 수신하고 있는지 아는 것이 유용합니다. 이를 위해 회의에 있는 오디오 응용 프로그램의 각 인스턴스는 RTCP\(제어\) 포트에서 수신 보고서와 사용자 이름을 주기적으로 멀티캐스트합니다. 수신 보고서는 현재 화자가 얼마나 잘 수신되고 있는지를 나타내며 적응형 인코딩을 제어하는 ​​데 사용될 수 있습니다. 사용자 이름 외에도 제어 대역폭 제한에 따라 기타 식별 정보가 포함될 수도 있습니다. 사이트는 회의에서 나갈 때 RTCP BYE 패킷\(섹션 6.6\)을 보냅니다.

---
## **2.2 Audio and Video Conference**

회의에서 오디오 및 비디오 미디어가 모두 사용되는 경우 별도의 RTP 세션으로 전송됩니다. 즉, 별도의 RTP 및 RTCP 패킷이 두 개의 서로 다른 UDP 포트 쌍 및/또는 멀티캐스트 주소를 사용하여 각 매체에 대해 전송됩니다. 두 세션에 참여하는 사용자가 세션을 연결할 수 있도록 두 세션에 모두 RTCP 패킷에서 동일한 고유\(정규\) 이름을 사용해야 한다는 점을 제외하면 오디오 세션과 비디오 세션 사이에는 RTP 수준에서 직접적인 결합이 없습니다.

이러한 분리의 한 가지 동기는 컨퍼런스의 일부 참가자가 선택한 경우 하나의 매체만 받을 수 있도록 허용하는 것입니다. 자세한 설명은 섹션 5.2에 나와 있습니다. 분리에도 불구하고 두 세션의 RTCP 패킷에 전달된 타이밍 정보를 사용하여 소스 오디오 및 비디오의 동기화된 재생을 달성할 수 있습니다.

---
## **2.3 Mixers and Translators**

지금까지 우리는 모든 사이트가 동일한 형식의 미디어 데이터를 수신하기를 원한다고 가정했습니다. 그러나 이것이 항상 적절한 것은 아닙니다. 한 영역의 참가자가 고속 네트워크 액세스를 사용하는 대부분의 회의 참가자와 저속 링크를 통해 연결되는 경우를 생각해 보십시오. 모든 사람에게 더 낮은 대역폭, 낮은 품질의 오디오 인코딩을 사용하도록 강요하는 대신 믹서라고 하는 RTP 수준 릴레이를 낮은 대역폭 영역 근처에 배치할 수 있습니다. 이 믹서는 수신 오디오 패킷을 재동기화하여 발신자가 생성한 일정한 20ms 간격을 재구성하고, 이렇게 재구성된 오디오 스트림을 단일 스트림으로 혼합하고, 오디오 인코딩을 낮은 대역폭으로 변환하고, 낮은 대역폭 패킷 스트림을 낮은 대역폭을 통해 전달합니다. 속도 링크. 이러한 패킷은 단일 수신자에게 유니캐스트되거나 여러 수신자에게 다른 주소로 멀티캐스트될 수 있습니다. RTP 헤더에는 수신기에서 올바른 화자 표시가 제공될 수 있도록 혼합기에서 혼합 패킷에 기여한 소스를 식별하는 수단이 포함되어 있습니다.

오디오 컨퍼런스의 의도된 참가자 중 일부는 고대역폭 링크로 연결될 수 있지만 IP 멀티캐스트를 통해 직접 연결되지 않을 수 있습니다. 예를 들어, IP 패킷이 통과하지 못하도록 하는 애플리케이션 수준 방화벽 뒤에 있을 수 있습니다. 이러한 사이트의 경우 혼합이 필요하지 않을 수 있으며, 이 경우 변환기라고 하는 다른 유형의 RTP 수준 릴레이를 사용할 수 있습니다. 두 개의 변환기가 방화벽 양쪽에 하나씩 설치되어 있으며, 외부 변환기는 보안 연결을 통해 수신된 모든 멀티캐스트 패킷을 방화벽 내부의 변환기로 전달합니다. 방화벽 내부의 변환기는 이를 사이트 내부 네트워크로 제한된 멀티캐스트 그룹에 멀티캐스트 패킷으로 다시 보냅니다.

혼합기와 변환기는 다양한 목적으로 설계될 수 있습니다. 예를 들어 개별 비디오 스트림에서 개별 사람의 이미지 크기를 조정하고 이를 하나의 비디오 스트림으로 합성하여 그룹 장면을 시뮬레이션하는 비디오 믹서가 있습니다. 변환의 다른 예로는 IP/UDP만 사용하는 호스트 그룹을 ST-II만 이해하는 호스트 그룹에 연결하거나 재동기화나 믹싱 없이 개별 소스의 비디오 스트림을 패킷 단위로 인코딩 변환하는 것이 있습니다. 혼합기 및 변환기의 작동에 대한 자세한 내용은 섹션 7에 나와 있습니다.

---
## **2.4 Layered Encodings**

멀티미디어 애플리케이션은 수신기 용량에 맞게 전송 속도를 조정하거나 네트워크 정체에 적응할 수 있어야 합니다. 많은 구현에서는 속도 적응성의 책임을 소스에 둡니다. 이는 이기종 수신기의 대역폭 요구 사항이 충돌하기 때문에 멀티캐스트 전송에서는 제대로 작동하지 않습니다. 그 결과는 네트워크 메시의 가장 작은 파이프가 전체 라이브 멀티미디어 "방송"의 품질과 충실도를 결정하는 최소 공통 분모 시나리오인 경우가 많습니다.

대신, 계층화된 인코딩과 계층화된 전송 시스템을 결합하여 속도 적응에 대한 책임을 수신기에 둘 수 있습니다. RTP over IP 멀티캐스트의 맥락에서 소스는 각각 자체 멀티캐스트 그룹에서 전달되는 여러 RTP 세션에 걸쳐 계층적으로 표현된 신호의 프로그레시브 레이어를 스트라이프할 수 있습니다. 그런 다음 수신기는 네트워크 이질성에 적응하고 멀티캐스트 그룹의 적절한 하위 집합에만 참여하여 수신 대역폭을 제어할 수 있습니다.

계층화된 인코딩과 함께 RTP 사용에 대한 자세한 내용은 섹션 6.3.9, 8.3 및 11에 나와 있습니다.

---
## **3. Definitions**

RTP 페이로드: RTP가 패킷으로 전송하는 데이터입니다.

- 오디오 샘플 또는 압축된 비디오 데이터의 예. 페이로드 형식과 해석은 이 문서의 범위를 벗어납니다.

RTP 패킷: 고정 RTP 헤더, 비어 있을 수 있는 기여 소스 목록\(아래 참조\) 및 페이로드 데이터로 구성된 데이터 패킷입니다. 일부 기본 프로토콜에서는 정의할 RTP 패킷의 캡슐화가 필요할 수 있습니다. 일반적으로 기본 프로토콜의 한 패킷에는 단일 RTP 패킷이 포함되지만 캡슐화 방법에 의해 허용되는 경우 여러 RTP 패킷이 포함될 수 있습니다\(섹션 11 참조\).\(MAY\)

RTCP 패킷: RTP 데이터 패킷과 유사한 고정 헤더 부분과 RTCP 패킷 유형에 따라 달라지는 구조적 요소로 구성된 제어 패킷입니다. 형식은 섹션 6에 정의되어 있습니다. 일반적으로 여러 RTCP 패킷은 기본 프로토콜의 단일 패킷에 복합 RTCP 패킷으로 함께 전송됩니다. 이는 각 RTCP 패킷의 고정 헤더에 있는 길이 필드에 의해 활성화됩니다.

포트: 전송 프로토콜이 사용하는 "추상화"

- 주어진 호스트 컴퓨터 내의 여러 대상을 구별합니다. TCP/IP 프로토콜은 작은 양의 정수를 사용하여 포트를 식별합니다." \[12\] OSI 전송 계층에서 사용하는 전송 선택기\(TSEL\)는 포트와 동일합니다. RTP는 하위 계층 프로토콜에 의존하여 포트를 다중화하는 포트와 같은 일부 메커니즘을 제공합니다. 세션의 RTP 및 RTCP 패킷입니다.

전송 주소: 전송 수준 끝점을 식별하는 네트워크 주소와 포트의 조합\(예: IP 주소 및 UDP 포트\)입니다. 패킷은 소스 전송 주소에서 대상 전송 주소로 전송됩니다.

RTP 미디어 유형: RTP 미디어 유형은 단일 RTP 세션 내에서 전달될 수 있는 페이로드 유형의 모음입니다. RTP 프로필은 RTP 미디어 유형을 RTP 페이로드 유형에 할당합니다.

멀티미디어 세션: 여러 장치 간의 동시 RTP 세션 집합

- 공통 참가자 그룹. 예를 들어 화상회의\(멀티미디어 세션\)에는 오디오 RTP 세션과 비디오 RTP 세션이 포함될 수 있습니다.

RTP 세션: 참가자 집합 간의 연결

- RTP와 통신합니다. 참가자는 동시에 여러 RTP 세션에 참여할 수 있습니다. 멀티미디어 세션에서 각 매체는 일반적으로 인코딩 자체가 여러 미디어를 단일 데이터 스트림으로 다중화하지 않는 한 자체 RTCP 패킷과 함께 별도의 RTP 세션으로 전달됩니다. 참가자는 서로 다른 대상 전송 주소 쌍을 사용하여 서로 다른 세션을 수신함으로써 여러 RTP 세션을 구별합니다. 여기서 전송 주소 쌍은 하나의 네트워크 주소와 RTP 및 RTCP용 포트 쌍으로 구성됩니다. RTP 세션의 모든 참가자는 IP 멀티캐스트의 경우처럼 공통 대상 전송 주소 쌍을 공유할 수도 있고, 개별 유니캐스트 네트워크 주소 및 포트 쌍의 경우처럼 각 참가자마다 쌍이 다를 수도 있습니다. 유니캐스트의 경우 참가자는 동일한 포트 쌍을 사용하여 세션의 다른 모든 참가자로부터 수신하거나 각각에 대해 고유한 포트 쌍을 사용할 수 있습니다.

RTP 세션의 구별되는 특징은 각 세션이

- SSRC 식별자의 별도의 완전한 공간을 유지합니다\(다음에 정의됨\). 하나의 RTP 세션에 포함된 참가자 집합은 SSRC나 CSRC\(아래 정의됨\)인 RTP 또는 RTCP에서 참가자 중 어느 하나가 전송한 SSRC 식별자를 수신할 수 있는 참가자들로 구성됩니다. 예를 들어, 각 참가자가 별도의 포트 쌍을 통해 다른 두 참가자로부터 수신하는 유니캐스트 UDP를 사용하여 구현된 3자 회의를 생각해 보십시오. 각 참가자가 다른 참가자로부터 받은 데이터에 대한 RTCP 피드백을 해당 참가자에게만 보내는 경우 회의는 세 개의 개별 지점 간 RTP 세션으로 구성됩니다. 각 참가자가 다른 참가자의 수신에 대한 RTCP 피드백을 다른 참가자 모두에게 제공하는 경우 회의는 하나의 다자간 RTP 세션으로 구성됩니다. 후자의 경우는 세 참가자 간의 IP 멀티캐스트 통신에서 발생하는 동작을 시뮬레이션합니다.

- RTP 프레임워크는 여기에 정의된 변형을 허용하지만 특정 제어 프로토콜이나 애플리케이션 설계는 일반적으로 이러한 변형에 제약을 가합니다.

동기화 소스\(SSRC\): RTP 스트림의 소스

- 네트워크 주소에 종속되지 않도록 RTP 헤더에 전달되는 32비트 숫자 SSRC 식별자로 식별되는 패킷입니다. 동기화 소스의 모든 패킷은 동일한 타이밍 및 시퀀스 번호 공간의 일부를 형성하므로 수신기는 재생을 위해 동기화 소스별로 패킷을 그룹화합니다. 동기화 소스의 예로는 마이크나 카메라 또는 RTP 믹서\(아래 참조\)와 같은 신호 소스에서 파생된 패킷 스트림의 발신자가 포함됩니다. 동기화 소스는 시간이 지남에 따라 오디오 인코딩과 같은 데이터 형식을 변경할 수 있습니다. SSRC 식별자는 특정 RTP 세션 내에서 전역적으로 고유하도록 무작위로 선택된 값입니다\(섹션 8 참조\). 참가자는 멀티미디어 세션의 모든 RTP 세션에 대해 동일한 SSRC 식별자를 사용할 필요가 없습니다. SSRC 식별자의 바인딩은 RTCP를 통해 제공됩니다\(섹션 6.5.1 참조\). 참가자가 하나의 RTP 세션에서 여러 스트림을 생성하는 경우\(예: 별도의 비디오 카메라에서\) 각각은 서로 다른 SSRC로 식별되어야 합니다.\(MUST\)

기여 소스\(CSRC\): RTP 믹서에 의해 생성된 결합 스트림에 기여한 RTP 패킷 스트림의 소스입니다\(아래 참조\). 믹서는 특정 패킷 생성에 기여한 소스의 SSRC 식별자 목록을 해당 패킷의 RTP 헤더에 삽입합니다. 이 목록을 CSRC 목록이라고 합니다. 예제 응용 프로그램은 믹서가 발언한 모든 발화자를 나타내는 오디오 회의입니다.

- 모든 오디오 패킷이 동일한 SSRC 식별자\(믹서의 식별자\)를 포함하더라도 수신기가 현재 화자를 나타낼 수 있도록 결합되어 나가는 패킷을 생성합니다.

최종 시스템: RTP 패킷으로 전송할 콘텐츠를 생성하거나 수신된 RTP 패킷의 콘텐츠를 소비하는 애플리케이션입니다. 최종 시스템은 특정 RTP 세션에서 하나 이상의 동기화 소스 역할을 할 수 있지만 일반적으로 하나만 가능합니다.

믹서: 하나 이상의 소스로부터 RTP 패킷을 수신하고 데이터 형식을 변경하고 어떤 방식으로든 패킷을 결합한 다음 새 RTP 패킷을 전달하는 중간 시스템입니다. 여러 입력 소스 간의 타이밍은 일반적으로 동기화되지 않으므로 믹서는 스트림 간의 타이밍을 조정하고 결합된 스트림에 대한 자체 타이밍을 생성합니다. 따라서 믹서에서 발생하는 모든 데이터 패킷은 믹서를 동기화 소스로 갖는 것으로 식별됩니다.

변환기: RTP 패킷을 전달하는 중간 시스템

- 동기화 소스 식별자가 그대로 유지됩니다. 변환기의 예로는 혼합 없이 인코딩을 변환하는 장치, 멀티캐스트에서 유니캐스트로 복제기, 방화벽의 애플리케이션 수준 필터 등이 있습니다.

모니터: 에서 보낸 RTCP 패킷을 수신하는 응용 프로그램입니다.

- RTP 세션 참가자, 특히 수신 보고서는 배포 모니터링, 결함 진단 및 장기 통계를 위한 현재 서비스 품질을 추정합니다. 모니터 기능은 세션에 참여하는 애플리케이션에 내장될 가능성이 높지만, 별도로 참여하지 않고 RTP 데이터 패킷을 보내거나 받지 않는 별도의 애플리케이션일 수도 있습니다\(별도의 포트에 있으므로\). . 이를 타사 모니터라고 합니다. 타사 모니터가 RTP 데이터 패킷을 수신하지만 RTCP 패킷을 보내지 않거나 세션에서 계산되지 않는 것도 허용됩니다.

비RTP는 사용 가능한 서비스를 제공하기 위해 RTP 외에 필요할 수 있는 프로토콜 및 메커니즘을 의미합니다. 특히 멀티미디어 회의의 경우 제어 프로토콜은 암호화를 위한 멀티캐스트 주소와 키를 배포하고, 사용할 암호화 알고리즘을 협상하고, RTP 페이로드 유형 값과 사전 정의되지 않은 형식에 대해 나타내는 페이로드 형식 간의 동적 매핑을 정의할 수 있습니다. 페이로드 유형 값. 이러한 프로토콜의 예로는 SIP\(Session Initiation Protocol\)\(RFC 3261\[13\]\), ITU Recommendation H.323\[14\] 및 RTSP\(RFC 2326\[16\]\)와 같은 SDP\(RFC 2327\[15\]\)를 사용하는 애플리케이션이 있습니다. . 간단한

- 응용 프로그램, 전자 메일 또는 회의 데이터베이스도 사용할 수 있습니다. 그러한 프로토콜과 메커니즘의 사양은 이 문서의 범위를 벗어납니다.

---
## **4. Byte Order, Alignment, and Time Format**

모든 정수 필드는 네트워크 바이트 순서, 즉 최상위 바이트\(옥텟\)부터 전달됩니다. 이 바이트 순서는 일반적으로 빅엔디안으로 알려져 있습니다. 전송 순서는 \[3\]에서 자세히 설명한다. 달리 명시하지 않는 한, 숫자 상수는 10진수\(기본 10\)로 표시됩니다.

모든 헤더 데이터는 자연 길이에 맞춰 정렬됩니다. 즉, 16비트 필드는 짝수 오프셋에 정렬되고, 32비트 필드는 4로 나눌 수 있는 오프셋에 정렬됩니다. 패딩으로 지정된 옥텟의 값은 0입니다.

벽시계 시간\(절대 날짜 및 시간\)은 NTP\(Network Time Protocol\)의 타임스탬프 형식을 사용하여 표시되며, 이는 1900년 1월 1일 0시 UTC를 기준으로 초 단위로 표시됩니다\[4\]. 전체 해상도 NTP 타임스탬프는 처음 32비트에 정수 부분이 있고 마지막 32비트에 소수 부분이 있는 64비트 부호 없는 고정 소수점 숫자입니다. 보다 간결한 표현이 적합한 일부 필드에서는 중간 32비트만 사용됩니다. 즉, 정수 부분의 하위 16비트와 소수 부분의 상위 16비트입니다. 정수 부분의 상위 16비트는 독립적으로 결정되어야 합니다.

RTP를 사용하기 위해 네트워크 시간 프로토콜을 실행하는 구현이 필요하지 않습니다. 다른 시간 소스를 사용하거나 전혀 사용하지 않을 수도 있습니다\(섹션 6.4.1의 NTP 타임스탬프 필드 설명 참조\). 그러나 NTP를 실행하면 별도의 호스트에서 전송된 스트림을 동기화하는 데 유용할 수 있습니다.

NTP 타임스탬프는 2036년에 0으로 바뀔 예정이지만 RTP 목적으로는 NTP 타임스탬프 쌍 간의 차이점만 사용됩니다. 타임스탬프 쌍이 서로 68년 이내에 있다고 가정할 수 있는 한, 빼기 및 비교에 모듈식 산술을 사용하면 랩어라운드가 부적합해집니다.

---
## **5. RTP Data Transfer Protocol**
---
## **5.1 RTP Fixed Header Fields**

RTP 헤더의 형식은 다음과 같습니다.

```text
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |V=2|P|X|  CC   |M|     PT      |       sequence number         |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                           timestamp                           |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |           synchronization source (SSRC) identifier            |
   +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
   |            contributing source (CSRC) identifiers             |
   |                             ....                              |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

처음 12개의 옥텟은 모든 RTP 패킷에 존재하는 반면 CSRC 식별자 목록은 믹서에 의해 삽입될 때만 존재합니다. 필드의 의미는 다음과 같습니다.

버전\(V\): 2비트

- 이 필드는 RTP 버전을 식별합니다. 이 사양에서 정의한 버전은 2입니다. \(값 1은 RTP의 첫 번째 초안 버전에서 사용되며 값 0은 "vat" 오디오 도구에 처음 구현된 프로토콜에서 사용됩니다.\)

패딩\(P\): 1비트

- 패딩 비트가 설정된 경우 패킷 끝에 페이로드의 일부가 아닌 하나 이상의 추가 패딩 옥텟이 포함됩니다. 패딩의 마지막 옥텟에는 자신을 포함하여 무시해야 하는 패딩 옥텟 수의 개수가 포함됩니다. 고정된 블록 크기를 가진 일부 암호화 알고리즘이나 하위 계층 프로토콜 데이터 단위에서 여러 RTP 패킷을 전달하기 위해 패딩이 필요할 수 있습니다.

확장자\(X\): 1비트

- 확장 비트가 설정된 경우 고정 헤더 뒤에는 섹션 5.3.1에 정의된 형식을 사용하여 정확히 하나의 헤더 확장이 와야 합니다.\(MUST\)

CSRC 카운트\(CC\): 4비트

- CSRC 수에는 고정 헤더 뒤에 오는 CSRC 식별자의 수가 포함됩니다.

마커\(M\): 1비트

- 마커의 해석은 프로필에 의해 정의됩니다. 이는 프레임 경계와 같은 중요한 이벤트를 패킷 스트림에 표시할 수 있도록 하기 위한 것입니다. 프로필은 추가 마커 비트를 정의하거나 페이로드 유형 필드의 비트 수를 변경하여 마커 비트가 없음을 지정할 수 있습니다\(섹션 5.3 참조\).\(MAY\)

페이로드 유형\(PT\): 7비트

- 이 필드는 RTP 페이로드의 형식을 식별하고 애플리케이션에 의한 해석을 결정합니다. 프로필은 페이로드 유형 코드와 페이로드 형식의 기본 정적 매핑을 지정할 수 있습니다. 추가 페이로드 유형 코드는 RTP가 아닌 수단을 통해 동적으로 정의될 수 있습니다\(섹션 3 참조\). 오디오 및 비디오에 대한 기본 매핑 세트는 RFC 3551 \[1\]에 지정되어 있습니다. RTP 소스는 세션 중에 페이로드 유형을 변경할 수 있지만 이 필드는 별도의 미디어 스트림을 다중화하는 데 사용되어서는 안 됩니다\(섹션 5.2 참조\).\(MAY, MAY, SHOULD NOT\)

- 수신기는 자신이 이해하지 못하는 페이로드 유형을 가진 패킷을 무시해야 합니다.\(MUST\)

시퀀스 번호: 16비트

- 시퀀스 번호는 RTP 데이터 패킷이 전송될 때마다 1씩 증가하며, 수신기에서 패킷 손실을 감지하고 패킷 순서를 복원하는 데 사용될 수 있습니다. 시퀀스 번호의 초기 값은 암호화에 대한 알려진 일반 텍스트 공격을 더 어렵게 만들기 위해 무작위\(예측 불가능\)여야 합니다. 비록 소스 자체가 섹션 9.1의 방법에 따라 암호화하지 않더라도 패킷이 변환기를 통해 흐를 수 있기 때문입니다. . 예측할 수 없는 숫자를 선택하는 기술은 \[17\]에서 논의됩니다.\(SHOULD\)

타임스탬프: 32비트

- 타임스탬프는 RTP 데이터 패킷의 첫 번째 옥텟의 샘플링 순간을 반영합니다. 샘플링 순간은 동기화 및 지터 계산을 허용하기 위해 시간에 따라 단조롭고 선형적으로 증가하는 클록에서 파생되어야 합니다\(섹션 6.4.1 참조\). 클록의 해상도는 원하는 동기화 정확도와 패킷 도착 지터 측정에 충분해야 합니다\(일반적으로 비디오 프레임당 1틱은 충분하지 않습니다\). 클록 주파수는 페이로드로 전달되는 데이터 형식에 따라 달라지며 형식을 정의하는 프로필이나 페이로드 형식 사양에 정적으로 지정되거나 비RTP 수단을 통해 정의된 페이로드 형식에 대해 동적으로 지정될 수도 있습니다. RTP 패킷이 주기적으로 생성되는 경우 시스템 시계를 읽는 것이 아니라 샘플링 시계에서 결정된 명목 샘플링 순간이 사용됩니다. 예를 들어 고정 속도 오디오의 경우 타임스탬프 클럭은 각 샘플링 기간마다 1씩 증가할 수 있습니다. 오디오 애플리케이션이 해당 블록을 읽는 경우\(MUST, MUST, MAY\)

- 입력 장치에서 160개의 샘플링 기간이 있는 경우, 블록이 패킷으로 전송되는지 또는 무음으로 삭제되는지 여부에 관계없이 각 블록에 대해 타임스탬프가 160씩 증가합니다.

- 타임스탬프의 초기 값은 시퀀스 번호와 마찬가지로 무작위여야 합니다. 여러 연속 RTP 패킷이 \(논리적으로\) 동시에 생성되는 경우\(예: 동일한 비디오 프레임에 속하는 경우\) 동일한 타임스탬프를 갖습니다. 연속적인 RTP 패킷에는 MPEG 보간된 비디오 프레임의 경우처럼 데이터가 샘플링된 순서대로 전송되지 않는 경우 단조롭지 않은 타임스탬프가 포함될 수 있습니다. \(전송된 패킷의 시퀀스 번호는 여전히 단조롭습니다.\)\(SHOULD, MAY\)

- 다양한 미디어 스트림의 RTP 타임스탬프는 다양한 속도로 진행될 수 있으며 일반적으로 독립적인 임의 오프셋을 갖습니다. 따라서 이러한 타임스탬프는 단일 스트림의 타이밍을 재구성하는 데 충분하지만 다른 미디어의 RTP 타임스탬프를 직접 비교하는 것은 동기화에 효과적이지 않습니다. 대신, 각 매체에 대해 RTP 타임스탬프는 RTP 타임스탬프에 해당하는 데이터가 샘플링된 시간을 나타내는 참조 시계\(wallclock\)의 타임스탬프와 쌍을 이루어 샘플링 순간과 관련됩니다. 참조 클럭은 동기화할 모든 미디어에서 공유됩니다. 타임스탬프 쌍은 모든 데이터 패킷에서 전송되지 않지만 섹션 6.4에 설명된 대로 RTCP SR 패킷에서 더 낮은 속도로 전송됩니다.

- 샘플링 순간은 전송 엔드포인트에 알려져 있고 인코딩 지연이나 기타 처리와 관계없이 모든 미디어에 대해 공통 정의를 갖기 때문에 RTP 타임스탬프에 대한 참조 지점으로 선택됩니다. 목적은 동시에 샘플링된 모든 미디어의 동기화된 프레젠테이션을 허용하는 것입니다.

- 실시간으로 샘플링된 데이터가 아닌 저장된 데이터를 전송하는 애플리케이션은 일반적으로 저장된 데이터에 있는 각 매체의 다음 프레임이나 다른 단위가 표시되어야 하는 시기를 결정하기 위해 벽시계 시간에서 파생된 가상 프리젠테이션 타임라인을 사용합니다. 이 경우 RTP 타임스탬프는 각 장치의 프레젠테이션 시간을 반영합니다. 즉, 각 장치의 RTP 타임스탬프는 해당 장치가 가상 프리젠테이션 타임라인에서 현재 상태가 되는 벽시계 시간과 관련됩니다. 실제 프리젠테이션은 수신자의 결정에 따라 얼마 후에 발생합니다.

- 사전 녹화된 비디오의 라이브 오디오 내레이션을 설명하는 예는 샘플링 순간을 기준점으로 선택하는 것의 중요성을 보여줍니다. 이 시나리오에서 비디오는 내레이터가 볼 수 있도록 로컬로 표시되며 RTP를 사용하여 동시에 전송됩니다. RTP로 전송된 비디오 프레임의 "샘플링 순간"은 다음을 참조하여 설정됩니다.

- 해당 비디오 프레임이 내레이터에게 제시된 벽시계 시간에 대한 타임스탬프입니다. 내레이터의 음성이 포함된 오디오 RTP 패킷의 샘플링 순간은 오디오가 샘플링될 때 동일한 벽시계 시간을 참조하여 설정됩니다. 두 호스트의 참조 클럭이 NTP와 같은 수단으로 동기화되면 오디오와 비디오가 서로 다른 호스트에 의해 전송될 수도 있습니다. 그런 다음 수신기는 RTCP SR 패킷의 타임스탬프 쌍을 사용하여 RTP 타임스탬프를 연결함으로써 오디오 및 비디오 패킷의 표시를 동기화할 수 있습니다.

SSRC: 32비트

- SSRC 필드는 동기화 소스를 식별합니다. 이 식별자는 동일한 RTP 세션 내의 두 동기화 소스가 동일한 SSRC 식별자를 갖지 않도록 무작위로 선택해야 합니다. 무작위 식별자를 생성하는 알고리즘의 예는 부록 A.6에 나와 있습니다. 여러 소스가 동일한 식별자를 선택할 확률은 낮지만 모든 RTP 구현은 충돌을 감지하고 해결할 준비가 되어 있어야 합니다. 섹션 8에서는 SSRC 식별자의 고유성을 기반으로 충돌을 해결하고 RTP 수준 전달 루프를 감지하는 메커니즘과 함께 충돌 확률을 설명합니다. 소스가 소스 전송 주소를 변경하는 경우 루프 소스로 해석되는 것을 방지하기 위해 새로운 SSRC 식별자도 선택해야 합니다\(섹션 8.2 참조\).\(SHOULD\)

CSRC 목록: 0\~15개 항목, 각각 32비트

- CSRC 목록은 이 패킷에 포함된 페이로드에 대한 기여 소스를 식별합니다. 식별자의 수는 CC 필드에 의해 제공됩니다. 기여 소스가 15개를 초과하는 경우 15개만 식별할 수 있습니다. CSRC 식별자는 기여 소스의 SSRC 식별자를 사용하여 혼합기\(섹션 7.1 참조\)에 의해 삽입됩니다. 예를 들어, 오디오 패킷의 경우 패킷을 생성하기 위해 함께 혼합된 모든 소스의 SSRC 식별자가 나열되어 수신기에서 올바른 발화자를 표시할 수 있습니다.

---
## **5.2 Multiplexing RTP Sessions**

효율적인 프로토콜 처리를 위해서는 통합 계층 처리 설계 원리\[10\]에서 설명된 것처럼 다중화 지점의 수를 최소화해야 합니다. RTP에서는 각 RTP 세션마다 다른 대상 전송 주소\(네트워크 주소 및 포트 번호\)에 의해 다중화가 제공됩니다. 예를 들어, 별도로 인코딩된 오디오 및 비디오 미디어로 구성된 원격 회의에서 각 매체는 자체 대상 전송 주소를 사용하여 별도의 RTP 세션에서 전달되어야 합니다.\(SHOULD\)

별도의 오디오 및 비디오 스트림은 단일 RTP 세션으로 전달되어서는 안 되며 페이로드 유형 또는 SSRC 필드에 따라 역다중화되어서는 안 됩니다. RTP 미디어 유형은 다르지만 동일한 SSRC를 사용하여 패킷을 인터리빙하면 몇 가지 문제가 발생합니다.\(SHOULD NOT\)

1. 예를 들어 두 개의 오디오 스트림이 동일한 RTP 세션과 동일한 SSRC 값을 공유하고 하나가 인코딩을 변경하여 다른 RTP 페이로드 유형을 획득하는 경우 어떤 스트림이 인코딩을 변경했는지 식별하는 일반적인 방법이 없습니다.

2. SSRC는 단일 타이밍 및 시퀀스 번호 공간을 식별하기 위해 정의됩니다. 여러 페이로드 유형을 인터리빙하려면 미디어 클럭 속도가 다른 경우 다른 타이밍 공간이 필요하며 어떤 페이로드 유형이 패킷 손실을 겪었는지 알려면 다른 시퀀스 번호 공간이 필요합니다.

3. RTCP 발신자 및 수신자 보고서\(섹션 6.4 참조\)는 SSRC당 하나의 타이밍 및 시퀀스 번호 공간만 설명할 수 있으며 페이로드 유형 필드를 전달하지 않습니다.

4. RTP 믹서는 호환되지 않는 미디어의 인터리빙된 스트림을 하나의 스트림으로 결합할 수 없습니다.

5. 하나의 RTP 세션에서 여러 미디어를 전달하면 다음이 제외됩니다. 적절한 경우 다른 네트워크 경로 또는 네트워크 리소스 할당을 사용합니다. 원하는 경우 미디어의 하위 집합 수신\(예: 비디오가 사용 가능한 대역폭을 초과하는 경우 오디오만 수신\) 다른 미디어에 대해 별도의 프로세스를 사용하는 수신기 구현은 별도의 RTP 세션을 사용하면 단일 또는 다중 프로세스 구현을 허용합니다.

각 매체에 대해 서로 다른 SSRC를 사용하지만 동일한 RTP 세션에서 전송하면 처음 세 가지 문제는 피할 수 있지만 마지막 두 가지 문제는 피할 수 없습니다.

반면, 서로 다른 SSRC 값을 사용하여 하나의 RTP 세션에서 동일한 매체의 여러 관련 소스를 멀티플렉싱하는 것이 멀티캐스트 세션의 표준입니다. 위에 나열된 문제는 적용되지 않습니다. 예를 들어 RTP 믹서는 여러 오디오 소스를 결합할 수 있으며 모든 소스에 동일한 처리가 적용됩니다. 마지막 두 가지 문제가 적용되지 않는 다른 시나리오에서는 서로 다른 SSRC 값을 사용하여 동일한 매체의 스트림을 다중화하는 것이 적절할 수도 있습니다.

---
## **5.3 Profile-Specific Modifications to the RTP Header**

기존 RTP 데이터 패킷 헤더는 RTP가 지원할 수 있는 모든 애플리케이션 클래스에서 공통적으로 필요한 기능 세트에 대해 완전한 것으로 간주됩니다. 그러나 ALF 설계 원칙에 따라 헤더는 프로필에 독립적인 모니터링 및 기록 도구가 작동하도록 허용하면서 프로필 사양에 정의된 수정 또는 추가를 통해 맞춤화될 수 있습니다.\(MAY\)

o 마커 비트 및 페이로드 유형 필드는 프로필별 정보를 전달하지만 많은 응용 프로그램에서 필요할 것으로 예상되고 그렇지 않으면 이를 유지하기 위해 다른 32비트 단어를 추가해야 할 수 있으므로 고정 헤더에 할당됩니다. 이러한 필드를 포함하는 옥텟은 예를 들어 더 많거나 더 적은 마커 비트를 사용하여 다양한 요구 사항에 맞게 프로필에 의해 재정의될 수 있습니다. 마커 비트가 있는 경우 프로필 독립적 모니터가 패킷 손실 패턴과 마커 비트 간의 상관 관계를 관찰할 수 있으므로 해당 비트는 옥텟의 최상위 비트에 위치해야 합니다.\(MAY, SHOULD\)

o 비디오 인코딩과 같은 특정 페이로드 형식에 필요한 추가 정보는 패킷의 페이로드 섹션에 전달되어야 합니다. 이는 페이로드 섹션의 시작 부분에 항상 존재하는 헤더에 있거나 데이터 패턴에서 예약된 값으로 표시될 수 있습니다.\(SHOULD\)

o 특정 애플리케이션 클래스에 추가가 필요한 경우

- 페이로드 형식과 무관한 기능, 해당 애플리케이션이 작동하는 프로필은 기존 고정 헤더의 SSRC 필드 바로 뒤에 추가 고정 필드를 정의해야 합니다. 이러한 애플리케이션은 추가 필드에 신속하고 직접적으로 액세스할 수 있는 반면 프로필 독립적인 모니터나 레코더는 처음 12옥텟만 해석하여 RTP 패킷을 계속 처리할 수 있습니다.\(SHOULD\)

모든 프로필에 공통적으로 추가 기능이 필요한 것으로 밝혀지면 고정 헤더를 영구적으로 변경하기 위해 새 버전의 RTP를 정의해야 합니다.

---
### **5.3.1 RTP Header Extension**

RTP 데이터 패킷 헤더에 추가 정보를 전달해야 하는 새로운 페이로드 형식 독립적 기능을 개별 구현에서 실험할 수 있도록 확장 메커니즘이 제공됩니다. 이 메커니즘은 확장되지 않은 다른 상호 운용 구현에서 헤더 확장을 무시할 수 있도록 설계되었습니다.

이 헤더 확장은 제한된 용도로만 사용됩니다. 이 메커니즘의 대부분의 잠재적인 용도는 이전 섹션에서 설명한 방법을 사용하여 다른 방법으로 수행하는 것이 더 좋습니다. 예를 들어 고정 헤더에 대한 프로필별 확장은 조건부도 아니고 가변 위치도 아니기 때문에 처리 비용이 저렴합니다. 특정 페이로드 형식에 필요한 추가 정보는 이 헤더 확장을 사용해서는 안 되며, 패킷의 페이로드 섹션에 전달되어야 합니다.\(SHOULD NOT\)

```text
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |      defined by profile       |           length              |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                        header extension                       |
   |                             ....                              |
```

RTP 헤더의 X 비트가 1이면 가변 길이 헤더 확장이 CSRC 목록\(있는 경우\) 다음에 RTP 헤더에 추가되어야 합니다. 헤더 확장에는 4옥텟 확장 헤더를 제외한 확장의 32비트 단어 수를 계산하는 16비트 길이 필드가 포함되어 있습니다\(따라서 0은 유효한 길이입니다\). RTP 데이터 헤더에는 단일 확장자만 추가할 수 있습니다. 여러 상호 운용 구현이 서로 다른 헤더 확장을 독립적으로 실험하도록 허용하거나 특정 구현이 두 가지 이상의 헤더 확장 유형을 실험할 수 있도록 허용하기 위해 헤더 확장의 처음 16비트는 식별자 또는 매개변수를 구별하기 위해 열려 있습니다. 이러한 16비트의 형식은 구현이 작동하는 프로필 사양에 의해 정의됩니다. 이 RTP 사양은 헤더 확장 자체를 정의하지 않습니다.\(MUST\)

---
## **6. RTP Control Protocol -- RTCP**

RTCP\(RTP 제어 프로토콜\)는 데이터 패킷과 동일한 배포 메커니즘을 사용하여 세션의 모든 참가자에게 제어 패킷을 주기적으로 전송하는 것을 기반으로 합니다. 기본 프로토콜은 데이터 및 제어 패킷의 다중화를 제공해야 합니다\(예: UDP와 별도의 포트 번호 사용\). RTCP는 네 가지 기능을 수행합니다.\(MUST\)

1. 주요 기능은 데이터 배포 품질에 대한 피드백을 제공하는 것입니다. 이는 전송 프로토콜로서 RTP 역할의 필수적인 부분이며 다른 전송 프로토콜의 흐름 및 혼잡 제어 기능과 관련됩니다\(혼잡 제어 요구 사항에 대한 섹션 10 참조\). 피드백은 적응형 인코딩 제어에 직접적으로 유용할 수 있지만\[18,19\], IP 멀티캐스팅을 사용한 실험에서는 이것이 또한 유용하다는 것을 보여주었습니다.

- 분배의 결함을 진단하기 위해 수신기로부터 피드백을 얻는 것이 중요합니다. 모든 참가자에게 수신 피드백 보고서를 보내면 문제를 관찰하는 사람이 해당 문제가 로컬인지 글로벌인지 평가할 수 있습니다. IP 멀티캐스트와 같은 배포 메커니즘을 사용하면 세션에 별도로 참여하지 않는 네트워크 서비스 공급자와 같은 엔터티가 피드백 정보를 수신하고 제3자 모니터 역할을 하여 네트워크 문제를 진단하는 것도 가능합니다. 이 피드백 기능은 아래 섹션 6.4에 설명된 RTCP 발신자 및 수신자 보고서에 의해 수행됩니다.

2. RTCP는 표준 이름 또는 CNAME\(섹션 6.5.1\)이라고 하는 RTP 소스에 대한 지속적인 전송 수준 식별자를 전달합니다. 충돌이 발견되거나 프로그램이 다시 시작되면 SSRC 식별자가 변경될 수 있으므로 수신자는 각 참가자를 추적하기 위해 CNAME을 요구합니다. 또한 수신기는 오디오와 비디오를 동기화하기 위해 관련 RTP 세션 집합에서 지정된 참가자의 여러 데이터 스트림을 연결하기 위해 CNAME을 요구할 수도 있습니다. 미디어 간 동기화에는 데이터 발신자가 RTCP 패킷에 포함한 NTP 및 RTP 타임스탬프도 필요합니다.

3. 처음 두 기능에서는 모든 참가자가 RTCP 패킷을 보내야 하므로 RTP가 많은 수의 참가자로 확장되도록 속도를 제어해야 합니다. 각 참가자가 자신의 제어 패킷을 다른 모든 참가자에게 보내도록 함으로써 각 참가자는 독립적으로 참가자 수를 관찰할 수 있습니다. 이 숫자는 섹션 6.2에 설명된 대로 패킷이 전송되는 속도를 계산하는 데 사용됩니다.

4. 네 번째 선택 기능은 최소한의 세션 제어 정보\(예: 사용자 인터페이스에 표시되는 참가자 식별 정보\)를 전달하는 것입니다. 이는 참가자가 멤버십 제어나 매개변수 협상 없이 들어오고 나가는 "느슨하게 제어되는" 세션에 유용할 가능성이 높습니다. RTCP는 모든 참가자에게 접근할 수 있는 편리한 채널 역할을 하지만 애플리케이션의 모든 제어 통신 요구 사항을 반드시 지원할 것으로 예상되는 것은 아닙니다. 이 문서의 범위를 벗어나는 더 높은 수준의 세션 제어 프로토콜이 필요할 수 있습니다.\(MAY\)

기능 1-3은 모든 환경에서 사용해야 하지만 특히 IP 멀티캐스트 환경에서 사용해야 합니다. RTP 애플리케이션 설계자는 유니캐스트 모드에서만 작동할 수 있고 더 큰 수로 확장되지 않는 메커니즘을 피해야 합니다. RTCP 전송은 수신자의 피드백이 불가능한 단방향 링크와 같은 경우 섹션 6.2에 설명된 대로 송신자와 수신자에 대해 별도로 제어될 수 있습니다.\(SHOULD, SHOULD, MAY\)

비표준 참고 사항: 멀티캐스트 라우팅 접근 방식에서

- SSM\(소스 특정 멀티캐스트\)이라고 하며 "채널"\(소스 주소, 그룹 주소 쌍\)당 하나의 발신자만 있고 수신자\(채널 소스 제외\)는 멀티캐스트를 사용하여 다른 채널 구성원과 직접 통신할 수 없습니다. 여기 권장 사항은 수신기의 RTCP를 완전히 끄는 섹션 6.2의 옵션을 통해서만 SSM을 수용합니다. 향후 작업에서는 수신기의 피드백이 유지될 수 있도록 SSM에 대한 RTCP 적용을 지정할 것입니다.

---
## **6.1 RTCP Packet Format**

이 사양은 다양한 제어 정보를 전달하는 여러 RTCP 패킷 유형을 정의합니다.

SR: 활성 발신자인 참가자의 전송 및 수신 통계에 대한 발신자 보고서

RR: 활성 발신자가 아닌 참가자의 수신 통계에 대한 수신자 보고서이며 31개 이상의 소스에 대해 보고하는 활성 발신자에 대한 SR과 결합됩니다.

```text
   SDES: Source description items, including CNAME
```

BYE: 참여 종료를 나타냅니다.

```text
   APP:  Application-specific functions
```

각 RTCP 패킷은 RTP 데이터 패킷과 유사한 고정 부분으로 시작하고 패킷 유형에 따라 길이가 가변적일 수 있지만 32비트 경계에서 끝나야 하는 구조적 요소가 뒤따릅니다. RTCP 패킷을 "스택 가능"하게 만들기 위해 정렬 요구 사항과 각 패킷의 고정 부분에 있는 길이 필드가 포함됩니다. 여러 RTCP 패킷을 중간 구분 기호 없이 연결하여 하위 계층 프로토콜\(예: UDP\)의 단일 패킷으로 전송되는 복합 RTCP 패킷을 형성할 수 있습니다. 하위 계층 프로토콜은 복합 패킷의 끝을 결정하기 위해 전체 길이를 제공할 것으로 예상되므로 복합 패킷에 개별 RTCP 패킷의 명시적인 개수는 없습니다.\(MUST\)

복합 패킷의 각 개별 RTCP 패킷은 패킷의 순서나 조합에 대한 요구 사항 없이 독립적으로 처리될 수 있습니다. 그러나 프로토콜의 기능을 수행하기 위해서는 다음과 같은 제약이 적용됩니다.

o 수신 통계\(SR 또는 RR\)는 대역폭 제약이 통계의 해상도를 최대화할 수 있는 만큼 자주 전송되어야 합니다. 따라서 주기적으로 전송되는 각 복합 RTCP 패킷에는 보고 패킷이 포함되어야 합니다.\(MUST\)

o 새로운 수신기는 소스를 식별하고 립싱크와 같은 목적으로 미디어 연결을 시작하기 위해 가능한 한 빨리 소스에 대한 CNAME을 수신해야 합니다. 따라서 각 복합 RTCP 패킷은 복합 RTCP 패킷이 다음과 같은 경우를 제외하고 SDES CNAME도 포함해야 합니다. 섹션 9.1에 설명된 대로 부분 암호화를 위해 분할됩니다.\(MUST\)

o 복합 패킷에서 처음 나타날 수 있는 패킷 유형의 수는 첫 번째 단어의 상수 비트 수를 늘리고 주소가 잘못 지정된 RTP 데이터 패킷 또는 기타 관련 없는 패킷에 대해 RTCP 패킷을 성공적으로 확인할 확률을 늘리기 위해 제한되어야 합니다.

따라서 모든 RTCP 패킷은 다음 형식을 사용하여 최소한 두 개의 개별 패킷으로 구성된 복합 패킷으로 전송되어야 합니다.\(MUST\)

암호화 접두사: 복합 패킷이 섹션 9.1의 방법에 따라 암호화되는 경우에만 전송된 모든 복합 패킷에 대해 다시 그려진 무작위 32비트 수량을 접두사로 붙여야 합니다. 암호화를 위해 패딩이 필요한 경우 복합 패킷의 마지막 패킷에 패딩을 추가해야 합니다.\(MUST, MUST\)

SR 또는 RR: 복합 패킷의 첫 번째 RTCP 패킷은 반드시

- 부록 A.2에 설명된 대로 헤더 검증을 용이하게 하기 위해 항상 보고 패킷이어야 합니다. 이는 데이터가 전송되거나 수신되지 않은 경우에도 마찬가지입니다. 이 경우 빈 RR을 전송해야 하며, 복합 패킷의 유일한 다른 RTCP 패킷이 BYE인 경우에도 마찬가지입니다.\(MUST, MUST\)

추가 RR: 수신 통계가 보고되는 소스의 수가 31개\(하나의 SR 또는 RR 패킷에 맞는 수\)를 초과하는 경우 추가 RR 패킷이 초기 보고 패킷 뒤에 와야 합니다.\(SHOULD\)

SDES: CNAME 항목을 포함하는 SDES 패킷은 섹션 9.1에 명시된 경우를 제외하고 각 복합 RTCP 패킷에 포함되어야 합니다. 다른 소스 설명 항목은 대역폭 제약에 따라 특정 애플리케이션에 필요한 경우 선택적으로 포함될 수 있습니다\(섹션 6.3.9 참조\).\(MUST, MAY\)

BYE 또는 APP: 아직 정의되지 않은 유형을 포함한 기타 RTCP 패킷 유형은 어떤 순서로든 따를 수 있습니다. 단, BYE는 지정된 SSRC/CSRC와 함께 전송된 마지막 패킷이어야 합니다. 패킷 유형은 두 번 이상 나타날 수 있습니다.\(SHOULD, MAY\)

개별 RTP 참가자는 섹션 9.1에 설명된 대로 복합 RTCP 패킷이 부분 암호화를 위해 분할되는 경우를 제외하고 참가자당 RTCP 대역폭이 올바르게 추정되도록 보고 간격당 하나의 복합 RTCP 패킷만 전송해야 합니다\(섹션 6.2 참조\). 네트워크 경로의 최대 전송 단위\(MTU\)를 초과하지 않고 필요한 모든 RR 패킷을 하나의 복합 RTCP 패킷에 맞추기에는 소스가 너무 많은 경우 하나의 MTU에 맞는 하위 집합만 각 간격에 포함되어야 합니다. 모든 소스가 보고되도록 여러 간격에 걸쳐 하위 집합을 라운드 로빈으로 선택해야 합니다.\(SHOULD, SHOULD, SHOULD\)

패킷 오버헤드를 상각하기 위해 변환기와 혼합기가 가능할 때마다 전달하는 여러 소스의 개별 RTCP 패킷을 하나의 복합 패킷으로 결합하는 것이 권장됩니다\(섹션 7 참조\). 믹서에 의해 생성될 수 있는 RTCP 복합 패킷의 예가 그림 1에 나와 있습니다. 복합 패킷의 전체 길이가 네트워크 경로의 MTU를 초과하는 경우 여러 개의 더 짧은 복합 패킷으로 분할하여 별도로 전송해야 합니다. 기본 프로토콜의 패킷. 각 복합 패킷은 최소한 하나의 개별 참가자를 나타내기 때문에 이는 RTCP 대역폭 추정을 손상시키지 않습니다. 각 복합 패킷은 SR 또는 RR 패킷으로 시작해야 합니다.\(SHOULD, SHOULD, MUST\)

구현은 유형을 알 수 없는 수신 RTCP 패킷을 무시해야 합니다\(SHOULD\). 추가 RTCP 패킷 유형은 섹션 15에 설명된 대로 IANA\(Internet Assigned Numbers Authority\)에 등록될 수 있습니다.\(SHOULD\)

```text
   if encrypted: random 32-bit integer
   |
   |[--------- packet --------][---------- packet ----------][-packet-]
   |
   |                receiver            chunk        chunk
   V                reports           item  item   item  item
   --------------------------------------------------------------------
   R[SR #sendinfo #site1#site2][SDES #CNAME PHONE #CNAME LOC][BYE##why]
   --------------------------------------------------------------------
   |                                                                  |
   |<-----------------------  compound packet ----------------------->|
   |<--------------------------  UDP packet ------------------------->|

   #: SSRC/CSRC identifier

              Figure 1: Example of an RTCP compound packet
```

---
## **6.2 RTCP Transmission Interval**

RTP는 소수의 참가자부터 수천 명에 이르는 세션 규모에 걸쳐 애플리케이션이 자동으로 확장될 수 있도록 설계되었습니다. 예를 들어 오디오 회의에서는 한 번에 한두 사람만 발언하므로 데이터 트래픽은 본질적으로 자체적으로 제한됩니다. 따라서 멀티캐스트 배포를 사용하면 특정 링크의 데이터 속도가 참가자 수에 관계없이 상대적으로 일정하게 유지됩니다. 그러나 제어 트래픽은 자체적으로 제한되지 않습니다. 각 참가자의 수신 보고서가 일정한 속도로 전송되면 제어 트래픽은 참가자 수에 따라 선형적으로 증가합니다. 따라서 RTCP 패킷 전송 간격을 동적으로 계산하여 속도를 줄여야 합니다.

각 세션에 대해 데이터 트래픽은 참가자 간에 분배되는 "세션 대역폭"이라는 집합적 제한을 받는다고 가정됩니다. 이 대역폭은 예약될 수 있으며 네트워크에 의해 제한이 적용될 수 있습니다. 예약이 없는 경우 환경에 따라 세션에서 사용할 "합리적인" 최대값을 설정하는 다른 제약 조건이 있을 수 있으며 이것이 바로 세션 대역폭입니다. 세션 대역폭은 일부 비용이나 세션에 사용 가능한 네트워크 대역폭에 대한 사전 지식을 기반으로 선택될 수 있습니다. 이는 미디어 인코딩과 다소 독립적이지만 인코딩 선택은 세션 대역폭에 의해 제한될 수 있습니다. 세션 대역폭은 동시에 활성화될 것으로 예상되는 발신자의 공칭 대역폭의 합인 경우가 많습니다. 원격 회의 오디오의 경우 이 숫자는 일반적으로 발신자 1명의 대역폭입니다. 계층화된 인코딩의 경우 각 계층은 자체 세션 대역폭 매개변수가 있는 별도의 RTP 세션입니다.

세션 대역폭 매개변수는 세션 관리 응용 프로그램이 미디어 응용 프로그램을 호출할 때 제공될 것으로 예상되지만 미디어 응용 프로그램은 세션에 대해 선택된 인코딩에 대한 단일 보낸 사람 데이터 대역폭을 기반으로 기본값을 설정할 수 있습니다. 또한 애플리케이션은 멀티캐스트 범위 규칙이나 기타 기준에 따라 대역폭 제한을 적용할 수도 있습니다. 모든 참가자는 반드시 동일한 세션 대역폭 값을 사용해야 동일한 RTCP 간격이 계산됩니다.\(MAY, MAY, MUST\)

제어 및 데이터 트래픽에 대한 대역폭 계산에는 리소스 예약 시스템이 알아야 하는 하위 계층 전송 및 네트워크 프로토콜\(예: UDP 및 IP\)이 포함됩니다. 응용 프로그램은 이러한 프로토콜 중 어떤 프로토콜이 사용 중인지 알 것으로 예상할 수도 있습니다. 패킷이 이동하면서 다른 링크 수준 헤더로 캡슐화되므로 링크 수준 헤더는 계산에 포함되지 않습니다.

제어 트래픽은 세션 대역폭의 알려진 작은 부분으로 제한되어야 합니다. 즉, 데이터를 전달하는 전송 프로토콜의 주요 기능이 손상되지 않도록 작습니다. 자원 예약 프로토콜에 부여된 대역폭 사양에 제어 트래픽이 포함될 수 있도록 하고, 각 참가자가 독립적으로 자신의 점유율을 계산할 수 있도록 알려져 있습니다. 제어 트래픽 대역폭은 데이터 트래픽을 위한 세션 대역폭에 추가됩니다. RTCP에 추가되는 세션 대역폭의 비율을 5%로 고정하는 것이 좋습니다. 또한 RTCP 대역폭의 1/4을 데이터를 전송하는 참가자에게 전용으로 사용하여 수신자는 많지만 발신자 수는 적은 세션에서 새로 합류하는 참가자가 전송 사이트에 대한 CNAME을 더 빨리 받을 수 있도록 하는 것이 좋습니다. . 발신자 비율이 참가자의 1/4보다 크면 발신자는 전체 RTCP 대역폭의 해당 비율을 얻습니다. 간격 계산에서 이러한 상수와 기타 상수의 값은 중요하지 않지만 세션의 모든 참가자는 동일한 값을 사용해야 동일한 간격이 계산됩니다. 따라서 이러한 상수는 특정 프로필에 대해 고정되어야 합니다.\(SHOULD, SHOULD, MUST, SHOULD\)

프로필은 제어 트래픽 대역폭이 세션 대역폭의 엄격한 비율이 아닌 세션의 별도 매개변수가 될 수 있음을 지정할 수 있습니다. 별도의 매개변수를 사용하면 속도 적응형 애플리케이션이 세션 대역폭 매개변수로 지정된 최대 대역폭보다 낮은 "일반" 데이터 대역폭과 일치하는 RTCP 대역폭을 설정할 수 있습니다.\(MAY\)

프로파일은 제어 트래픽 대역폭이 활성 데이터 전송자인 참가자와 그렇지 않은 참가자에 대해 두 개의 별도 세션 매개변수로 분할될 수 있음을 추가로 지정할 수 있습니다. 매개변수 S와 R을 호출하겠습니다. RTCP 대역폭의 1/4을 데이터 전송자에게 할당하라는 권장 사항에 따라 이 두 매개변수에 대한 권장 기본값은 각각 1.25%와 3.75%입니다. 발신자의 비율이 참가자의 S/\(S+R\)보다 큰 경우 발신자는 이러한 매개변수의 합에 대한 비율을 얻습니다. 두 개의 매개변수를 사용하면 데이터 발신자가 아닌 사람에 대한 RTCP 대역폭을 0으로 설정하고 데이터 발신자에 대한 RTCP 대역폭을 0이 아닌 상태로 유지하여 발신자 보고서가 계속 전송될 수 있도록 함으로써 특정 세션에 대해 RTCP 수신 보고서를 완전히 끌 수 있습니다. -미디어 동기화. RTCP 수신 보고서를 끄는 것은 섹션 6의 시작 부분에 나열된 기능, 특히 수신 품질 피드백 및 혼잡 제어에 필요하기 때문에 권장되지 않습니다. 그러나 그렇게 하는 것은 단방향 링크에서 작동하는 시스템이나 수신 품질이나 수신기의 활성 상태에 대한 피드백이 필요하지 않고 혼잡을 피하기 위한 다른 수단이 있는 세션에 적합할 수 있습니다.\(MAY, SHOULD, SHOULD NOT\)

또한 복합 RTCP 패킷 전송 간 계산된 간격은 참가자 수가 적고 트래픽이 대수의 법칙에 따라 평탄화되지 않을 때 패킷 버스트가 허용된 대역폭을 초과하는 것을 방지하기 위해 하한을 가져야 합니다. 또한 네트워크 파티션과 같은 일시적인 중단 중에 보고 간격이 너무 작아져 파티션이 복구될 때 적응이 지연되는 것을 방지합니다. 애플리케이션 시작 시 첫 번째 복합 RTCP 패킷이 전송되기 전에 지연을 적용하여 RTCP 패킷이 다른 참가자로부터 수신될 수 있도록 시간을 허용해야 합니다. 그러면 보고 간격이 더 빨리 올바른 값으로 수렴됩니다. 이 지연은 새 참가자가 있다는 것을 더 빨리 알릴 수 있도록 최소 간격의 절반으로 설정될 수 있습니다. 고정된 최소 간격에 대한 권장 값은 5초입니다.\(SHOULD, SHOULD, MAY, SHOULD\)

구현에서는 다음 제한 사항을 적용하여 최소 RTCP 간격을 세션 대역폭 매개변수에 반비례하여 더 작은 값으로 확장할 수 있습니다.\(MAY\)

o 멀티캐스트 세션의 경우 활성 데이터 전송자만 축소된 최소값을 사용하여 복합 RTCP 패킷 전송 간격을 계산할 수 있습니다.\(MAY\)

o 유니캐스트 세션의 경우 감소된 값은 다음에 의해 사용될 수 있습니다.

- 활성 데이터 발신자가 아닌 참가자 및 초기 복합 RTCP 패킷을 보내기 전의 지연은 0일 수 있습니다.\(MAY\)

o 모든 세션에 대해 다음과 같은 경우 고정된 최소값을 사용해야 합니다.

- RTCP 패킷 전송에 감소된 값을 사용하지 않는 구현이 다른 참가자에 의해 조기에 타임아웃되지 않도록 참가자 타임아웃 간격\(섹션 6.3.5 참조\)을 계산합니다.\(SHOULD\)

o 감소된 최소값\(초\)에 대한 권장 값은 360을 킬로비트/초 단위의 세션 대역폭으로 나눈 값입니다. 이 최소값은 72kb/s보다 큰 대역폭의 경우 5초보다 작습니다.\(SHOULD\)

섹션 6.3과 부록 A.7에 설명된 알고리즘은 이 섹션에 설명된 목표를 달성하도록 설계되었습니다. 참가자들에게 허용되는 제어 트래픽 대역폭을 나누기 위해 복합 RTCP 패킷 전송 간격을 계산합니다. 이를 통해 애플리케이션은 예를 들어 모든 참가자의 식별이 중요한 소규모 세션에 대해 빠른 응답을 제공하면서도 대규모 세션에 자동으로 적응할 수 있습니다. 알고리즘에는 다음과 같은 특성이 포함되어 있습니다.

o RTCP 패킷 사이의 계산된 간격은 그룹의 구성원 수에 따라 선형적으로 확장됩니다. 모든 구성원을 합산할 때 일정한 양의 제어 트래픽을 허용하는 것은 바로 이 선형 요소입니다.

o RTCP 패킷 사이의 간격은 모든 참가자의 의도하지 않은 동기화를 피하기 위해 계산된 간격의 \[0.5,1.5\]배 범위에서 무작위로 변경됩니다\[20\]. 세션에 참여한 후 전송된 첫 번째 RTCP 패킷도 최소 RTCP 간격의 절반에 해당하는 무작위 변화로 지연됩니다.

o 전달되는 제어 정보 양의 변화에 ​​자동으로 적응하기 위해 수신 및 전송된 모든 패킷을 포함하여 평균 복합 RTCP 패킷 크기의 동적 추정이 계산됩니다.

o 계산된 간격은 관찰된 그룹 구성원의 수에 따라 달라지므로 새 사용자가 기존 세션에 참여하거나 많은 사용자가 동시에 새 세션에 참여할 때 바람직하지 않은 시작 효과가 있을 수 있습니다. 이러한 새로운 사용자는 처음에 그룹 구성원에 대한 잘못된 추정을 갖게 되므로 RTCP 전송 간격이 너무 짧아집니다. 많은 사용자가 동시에 세션에 참가하는 경우 이 문제는 심각할 수 있습니다. 이를 처리하기 위해 "타이머 재검토"라는 알고리즘이 사용됩니다. 이 알고리즘은 그룹 크기가 증가하는 경우 사용자가 RTCP 패킷 전송을 보류하도록 하는 간단한 백오프 메커니즘을 구현합니다.

o 사용자가 BYE 또는 시간 초과로 세션을 종료하면 그룹 멤버십이 감소하므로 계산된 간격도 감소해야 합니다. "역 재검토" 알고리즘은 그룹 멤버십 감소에 대응하여 구성원이 더 신속하게 간격을 줄일 수 있도록 사용됩니다.

o BYE 패킷은 다른 RTCP 패킷과 다르게 처리됩니다. 사용자가 그룹을 떠나 BYE 패킷을 보내려는 경우 다음 예약된 RTCP 패킷 전에 그렇게 할 수 있습니다. 그러나 BYE 전송은 많은 수의 구성원이 동시에 세션을 떠날 경우 BYE 패킷의 플러드를 방지하는 백오프 알고리즘을 따릅니다.

이 알고리즘은 모든 참가자가 전송하도록 허용된 세션에 사용될 수 있습니다. 이 경우 세션 대역폭 매개변수는 개별 발신자의 대역폭과 참가자 수를 곱한 것이며 RTCP 대역폭은 그 5%입니다.

알고리즘 작동에 대한 자세한 내용은 다음 섹션에 나와 있습니다. 부록 A.7에는 구현 예가 나와 있습니다.

---
### **6.2.1 Maintaining the Number of Session Members**

RTCP 패킷 간격 계산은 세션에 참여하는 사이트 수의 추정치에 따라 달라집니다. 새로운 사이트는 청취될 때 카운트에 추가되며 각 항목에 대한 항목은 이를 추적하기 위해 SSRC 또는 CSRC 식별자\(섹션 8.2 참조\)로 색인화된 테이블에 생성되어야 합니다. 새 항목은 새 SSRC를 전달하는 여러 패킷이 수신되거나\(부록 A.1 참조\) 해당 SSRC에 대한 CNAME이 포함된 SDES RTCP 패킷이 수신될 때까지 유효하지 않은 것으로 간주될 수 있습니다. 해당 SSRC 식별자가 포함된 RTCP BYE 패킷이 수신되면 항목이 테이블에서 삭제될 수 있습니다. 단, 일부 낙오자 데이터 패킷은 BYE 이후에 도착하여 항목이 다시 생성될 수 있습니다. 대신, 항목은 BYE를 수신한 것으로 표시되어야 하며 적절한 지연 후에 삭제되어야 합니다.\(SHOULD, MAY, MAY, SHOULD\)

참가자는 적은 수의 RTCP 보고 간격\(5는 권장\) 동안 RTP 또는 RTCP 패킷이 수신되지 않은 경우 다른 사이트를 비활성으로 표시하거나 아직 유효하지 않은 경우 삭제할 수 있습니다. 이는 패킷 손실에 대해 어느 정도 견고성을 제공합니다. 모든 사이트는 이 승수에 대해 동일한 값을 가져야 하며 이 시간 초과가 제대로 작동하려면 RTCP 보고 간격에 대해 대략 동일한 값을 계산해야 합니다. 따라서 이 승수는 특정 프로필에 대해 고정되어야 합니다.\(SHOULD, SHOULD\)

참가자 수가 매우 많은 세션의 경우 모든 참가자에 대한 SSRC 식별자와 상태 정보를 저장하는 테이블을 유지하는 것이 비현실적일 수 있습니다. 구현에서는 저장 요구 사항을 줄이기 위해 \[21\]에 설명된 대로 SSRC 샘플링을 사용할 수 있습니다. 구현에서는 유사한 성능을 가진 다른 알고리즘을 사용할 수 있습니다. 핵심 요구 사항은 고려되는 모든 알고리즘이 그룹 크기를 과대평가할 수는 있지만 크게 과소평가해서는 안 된다는 것입니다.\(MAY, MAY, SHOULD NOT\)

---
## **6.3 RTCP Packet Send and Receive Rules**

RTCP 패킷을 보내는 방법과 수신 시 수행할 작업에 대한 규칙은 여기에 설명되어 있습니다. 멀티캐스트 환경 또는 멀티포인트 유니캐스트 환경에서의 작동을 허용하는 구현은 섹션 6.2의 요구 사항을 충족해야 합니다. 이러한 구현은 해당 요구 사항을 충족하기 위해 이 섹션에 정의된 알고리즘을 사용하거나 동등하거나 더 나은 성능을 제공하는 한 다른 알고리즘을 사용할 수 있습니다. 두 당사자 유니캐스트 작업으로 제한된 구현은 동일한 환경에서 작동하는 여러 인스턴스의 의도하지 않은 동기화를 피하기 위해 RTCP 전송 간격의 무작위화를 계속 사용해야 하지만 섹션 6.3의 "타이머 재검토" 및 "역 재검토" 알고리즘을 생략할 수 있습니다\(MAY\). .3, 6.3.6 및 6.3.7.\(MUST, MAY, SHOULD\)

이러한 규칙을 실행하려면 세션 참가자가 여러 상태를 유지해야 합니다.

```text
   tp: the last time an RTCP packet was transmitted;

   tc: the current time;

   tn: the next scheduled transmission time of an RTCP packet;

   pmembers: the estimated number of session members at the time tn
      was last recomputed;

   members: the most current estimate for the number of session
      members;

   senders: the most current estimate for the number of senders in
      the session;
```

rtcp\_bw: 대상 RTCP 대역폭, 즉 이 세션의 모든 구성원이 RTCP 패킷에 사용할 총 대역폭\(초당 옥텟\)입니다. 이는 시작 시 애플리케이션에 제공되는 "세션 대역폭" 매개변수의 지정된 부분입니다.

we\_sent: 애플리케이션이 데이터를 전송한 경우 참인 플래그

- 두 번째 이전 RTCP 보고가 전송된 이후입니다.

avg\_rtcp\_size: 이 참가자가 보내고 받는 모든 RTCP 패킷에 대한 평균 복합 RTCP 패킷 크기\(옥텟\)입니다. 크기에는 섹션 6.2에 설명된 대로 하위 계층 전송 및 네트워크 프로토콜 헤더\(예: UDP 및 IP\)가 포함됩니다.

초기: 애플리케이션이 아직 RTCP 패킷을 전송하지 않은 경우 참인 플래그입니다.

이러한 규칙 중 다수는 패킷 전송 간의 "계산된 간격"을 활용합니다. 이 간격은 다음 섹션에 설명되어 있습니다.

---
### **6.3.1 Computing the RTCP Transmission Interval**

확장성을 유지하려면 세션 참가자의 패킷 간 평균 간격이 그룹 크기에 따라 확장되어야 합니다. 이 간격을 계산된 간격이라고 합니다. 이는 위에서 설명한 여러 상태 조각을 결합하여 얻습니다. 계산된 간격 T는 다음과 같이 결정됩니다.

1. 발송인의 수가 회원\(members\)의 25% 이하인 경우, 간격은 참가자가 발송인인지 여부에 따라 달라집니다\(we\_sent 값 기준\). 참가자가 발신자\(we\_sent true\)인 경우 상수 C는 평균 RTCP 패킷 크기\(avg\_rtcp\_size\)를 RTCP 대역폭\(rtcp\_bw\)의 25%로 나눈 값으로 설정되고 상수 n은 발신자 수로 설정됩니다. we\_sent가 true가 아닌 경우 상수 C는 평균 RTCP 패킷 크기를 RTCP 대역폭의 75%로 나눈 값으로 설정됩니다. 상수 n은 수신자\(구성원 - 발신자\) 수로 설정됩니다. 보낸 사람 수가 25%를 초과하면 보낸 사람과 받는 사람이 함께 처리됩니다. 상수 C는 평균 RTCP 패킷 크기를 총 RTCP 대역폭으로 나눈 값으로 설정되고 n은 총 구성원 수로 설정됩니다. 섹션 6.2에 명시된 바와 같이, RTP 프로필은 RTCP 대역폭이 송신자인 참가자와 송신자가 아닌 참가자에 대해 두 개의 개별 매개변수\(S 및 R이라고 함\)에 의해 명시적으로 정의될 수 있음을 지정할 수 있습니다. 이 경우 25% 비율은 S/\(S+R\)이 되고 75% 비율은 R/\(S+R\)이 됩니다. R이 0인 경우 보낸 사람의 비율은 S/\(S+R\)보다 크지 않으며 구현 시 0으로 나누는 것을 방지해야 합니다.\(MAY\)

2. 참가자가 아직 RTCP 패킷을 전송하지 않은 경우\(initial 변수는 true\) 상수 Tmin은 2.5초로 설정되고, 그렇지 않으면 5초로 설정됩니다.

3. 결정론적 계산 간격 Td는 max\(Tmin, n\*C\)로 설정됩니다.

4. 계산된 간격 T는 결정론적 계산 간격의 0.5\~1.5배 사이에 균일하게 분포된 숫자로 설정됩니다.

5. 타이머 재검토 알고리즘이 의도한 평균보다 낮은 RTCP 대역폭 값으로 수렴한다는 사실을 보상하기 위해 T의 결과 값을 e-3/2=1.21828로 나눕니다.

이 절차를 통해 간격은 무작위로 발생하지만 평균적으로 RTCP 대역폭의 최소 25%를 발신자에게 제공하고 나머지는 수신자에게 제공합니다. 발신자가 멤버십의 1/4 이상을 구성하는 경우 이 절차는 평균적으로 모든 참가자에게 대역폭을 균등하게 분할합니다.

---
### **6.3.2 Initialization**

세션에 참여하면 참가자는 tp를 0으로, tc를 0으로, 보낸 사람을 0으로, pmembers를 1로, 구성원을 1로, we\_sent를 false로, rtcp\_bw를 세션 대역폭의 지정된 부분으로, 초기를 true로, avg\_rtcp\_size를 애플리케이션이 나중에 구성할 첫 번째 RTCP 패킷의 예상 크기입니다. 그런 다음 계산된 간격 T가 계산되고 첫 번째 패킷이 예약됩니다.

시간 tn = T. 이는 시간 T에 만료되는 전송 타이머가 설정되었음을 의미합니다. 애플리케이션은 이 타이머를 구현하기 위해 원하는 접근 방식을 사용할 수 있습니다.\(MAY\)

참가자는 자신의 SSRC를 멤버 테이블에 추가합니다.

---
### **6.3.3 Receiving an RTP or Non-BYE RTCP Packet**

멤버 테이블에 SSRC가 없는 참가자로부터 RTP 또는 RTCP 패킷이 수신되면 SSRC가 테이블에 추가되고 섹션 6.2.1에 설명된 대로 참가자가 검증되면 멤버 값이 업데이트됩니다. 검증된 RTP 패킷의 각 CSRC에 대해 동일한 처리가 발생합니다.

송신자 테이블에 SSRC가 없는 참가자로부터 RTP 패킷이 수신되면 SSRC가 테이블에 추가되고 송신자에 대한 값이 업데이트됩니다.

수신된 각 복합 RTCP 패킷에 대해 avg\_rtcp\_size 값이 업데이트됩니다.

```text
      avg_rtcp_size = (1/16) * packet_size + (15/16) * avg_rtcp_size
```

여기서 packet\_size는 방금 수신한 RTCP 패킷의 크기입니다.

---
### **6.3.4 Receiving an RTCP BYE Packet**

RTCP BYE가 전송되는 경우에 대해 섹션 6.3.7에 설명된 경우를 제외하고 수신된 패킷이 RTCP BYE 패킷인 경우 SSRC는 멤버 테이블과 비교하여 확인됩니다. 있는 경우 항목이 테이블에서 제거되고 멤버 값이 업데이트됩니다. 그런 다음 SSRC를 보낸 사람 테이블과 비교하여 확인합니다. 있는 경우 항목이 테이블에서 제거되고 보낸 사람에 대한 값이 업데이트됩니다.

또한 RTCP 패킷의 전송 속도를 그룹 구성원의 변경에 더 잘 적응시키려면 구성원을 pmembers보다 작은 값으로 줄이는 BYE 패킷이 수신될 때 다음 "역 재검토" 알고리즘을 실행해야 합니다.\(SHOULD\)

o tn 값은 다음 공식에 따라 업데이트됩니다.

```text
         tn = tc + (members/pmembers) * (tn - tc)
```

o tp 값은 다음 공식에 따라 업데이트됩니다.

```text
         tp = tc - (members/pmembers) * (tc - tp).
```

o 다음 RTCP 패킷은 현재 더 빠른 시간 tn에 전송되도록 다시 예약됩니다.

o pmembers의 값은 member와 동일하게 설정됩니다.

이 알고리즘은 대규모 세션의 대부분의 참가자가 한 번에 나가지만 일부는 남아 있는 조기 시간 초과로 인해 짧은 시간 동안 그룹 크기 추정치가 0으로 잘못 떨어지는 것을 방지하지 않습니다. 알고리즘은 추정치를 더 빠르게 올바른 값으로 되돌립니다. 이러한 상황은 충분히 이례적이며 결과는 이 문제가 부차적인 문제로 간주될 만큼 충분히 무해합니다.

---
### **6.3.5 Timing Out an SSRC**

가끔씩 참가자는 다른 참가자 중 시간 초과가 발생했는지 확인해야 합니다. 이를 위해 참가자는 수신기에 대해 결정론적\(무작위 인자 없이\) 계산된 간격 Td를 계산합니다. 즉, we\_sent false를 사용합니다. tc - MTd 시간\(M은 시간 초과 배수이며 기본값은 5\) 이후 RTP 또는 RTCP 패킷을 보내지 않은 다른 세션 구성원은 시간 초과됩니다. 이는 해당 SSRC가 구성원 목록에서 제거되고 구성원이 업데이트됨을 의미합니다. 보낸 사람 목록에서도 유사한 확인이 수행됩니다. tc - 2T 시간\(마지막 두 RTCP 보고 간격 내\) 이후 RTP 패킷을 보내지 않은 보낸 사람 목록의 모든 구성원은 보낸 사람 목록에서 제거되고 보낸 사람이 업데이트됩니다.\(MUST\)

멤버가 시간 초과되면 섹션 6.3.4에 설명된 역방향 재검토 알고리즘을 수행해야 합니다.\(SHOULD\)

참가자는 RTCP 전송 간격당 적어도 한 번 이 확인을 수행해야 합니다.\(MUST\)

---
### **6.3.6 Expiration of Transmission Timer**

패킷 전송 타이머가 만료되면 참가자는 다음 작업을 수행합니다.

o 전송 간격 T는 무작위 인자를 포함하여 섹션 6.3.1에 설명된 대로 계산됩니다.

o tp + T가 tc보다 작거나 같으면 RTCP 패킷은 다음과 같습니다.

- 전송되었습니다. tp를 tc로 설정한 다음 이전 단계와 같이 T에 대한 다른 값을 계산하고 tn을 tc + T로 설정합니다. 전송 타이머는 tn 시간에 다시 만료되도록 설정됩니다. tp + T가 tc보다 크면 tn은 tp + T로 설정됩니다. RTCP 패킷은 전송되지 않습니다. 전송 타이머는 시간 tn에 만료되도록 설정됩니다.

o pmembers는 멤버로 설정됩니다.

RTCP 패킷이 전송되면 초기 값은 FALSE로 설정됩니다. 또한 avg\_rtcp\_size 값이 업데이트됩니다.

```text
      avg_rtcp_size = (1/16) * packet_size + (15/16) * avg_rtcp_size
```

여기서 packet\_size는 방금 전송된 RTCP 패킷의 크기입니다.

---
### **6.3.7 Transmitting a BYE Packet**

참가자가 세션에서 나가기를 원하면 다른 참가자에게 이벤트를 알리기 위해 BYE 패킷이 전송됩니다. 많은 참가자가 시스템을 떠날 때 BYE 패킷의 홍수를 피하기 위해 참가자는 참가자가 떠나기로 선택할 때 구성원 수가 50명을 초과하는 경우 다음 알고리즘을 실행해야 합니다. 이 알고리즘은 대신 BYE 패킷을 계산하기 위해 멤버 변수의 일반적인 역할을 빼앗습니다.\(MUST\)

o 참가자가 시스템을 떠나기로 결정하면 tp는 tc로 재설정되고 현재 시간, 멤버 및 pmembers는 1로 초기화되고 초기 값은 1로 설정되고 we\_sent는 false로 설정되고 senders는 0으로 설정되고 avg\_rtcp\_size가 설정됩니다. 복합 BYE 패킷의 크기에 따라 달라집니다. 계산된 간격 T가 계산됩니다. 그러면 BYE 패킷이 tn = tc + T 시간으로 예약됩니다.

o 다른 참가자로부터 BYE 패킷을 수신할 때마다 해당 참가자가 멤버 테이블에 있는지 여부에 관계없이 멤버가 1씩 증가하고, SSRC 샘플링을 사용하는 경우 BYE SSRC가 멤버 테이블에 포함되는지 여부에 관계없이 멤버가 1씩 증가합니다. 샘플. 다른 RTCP 패킷이나 RTP 패킷이 수신되면 멤버가 증가하지 않으며 BYE 패킷에 대해서만 증가합니다. 마찬가지로 avg\_rtcp\_size는 수신된 BYE 패킷에 대해서만 업데이트됩니다. RTP 패킷이 도착할 때 발신자는 업데이트되지 않습니다. 0으로 남아있습니다.

o BYE 패킷의 전송은 다음에 대한 규칙을 따릅니다.

- 위와 같이 일반 RTCP 패킷을 전송합니다.

이를 통해 BYE 패킷을 즉시 전송할 수 있지만 총 대역폭 사용량을 제어할 수 있습니다. 최악의 경우 RTCP 제어 패킷이 평소보다 두 배의 대역폭\(10%\)을 사용하게 될 수 있습니다. 즉, BYE가 아닌 RTCP 패킷의 경우 5%, BYE의 경우 5%입니다.

위의 메커니즘이 BYE 패킷 전송을 허용할 때까지 기다리기를 원하지 않는 참가자는 BYE를 전혀 전송하지 않고 그룹을 떠날 수 있습니다. 해당 참가자는 결국 다른 그룹 구성원에 의해 시간 초과됩니다.\(MAY\)

참가자가 떠나기로 결정했을 때 그룹 크기 예상 구성원이 50명 미만인 경우 참가자는 즉시 BYE 패킷을 보낼 수 있습니다. 또는 참가자는 위의 BYE 백오프 알고리즘을 실행하도록 선택할 수 있습니다.\(MAY, MAY\)

두 경우 모두 RTP 또는 RTCP 패킷을 보낸 적이 없는 참가자는 그룹을 떠날 때 BYE 패킷을 보내서는 안 됩니다.\(MUST NOT\)

---
### **6.3.8 Updating we_sent**

we\_sent 변수에는 참가자가 최근에 RTP 패킷을 보낸 경우 true가 포함되고, 그렇지 않으면 false가 포함됩니다. 이 결정은 보낸 사람 테이블에 나열된 다른 참가자 집합을 관리하는 것과 동일한 메커니즘을 사용하여 이루어집니다. we\_sent가 false일 때 참가자가 RTP 패킷을 보내면 자신을 sender 테이블에 추가하고 we\_sent를 true로 설정합니다. 섹션 6.3.4에 설명된 역방향 재검토 알고리즘은 SR 패킷을 보내기 전에 지연을 줄이기 위해 수행되어야 합니다. 다른 RTP 패킷이 전송될 때마다 해당 패킷의 전송 시간이 테이블에 유지됩니다. 그런 다음 일반 발신자 시간 초과 알고리즘이 참가자에게 적용됩니다. RTP 패킷이 tc - 2T 시간 이후 전송되지 않은 경우 참가자는 발신자 테이블에서 자신을 제거하고 발신자 수를 줄이고 we\_sent를 false로 설정합니다.\(SHOULD\)

---
### **6.3.9 Allocation of Source Description Bandwidth**

이 사양은 NAME\(개인 이름\) 및 EMAIL\(이메일 주소\)과 같은 필수 CNAME 항목 외에도 여러 소스 설명\(SDES\) 항목을 정의합니다. 또한 새로운 애플리케이션별 RTCP 패킷 유형을 정의하는 수단도 제공합니다. 응용 프로그램은 이 추가 정보에 제어 대역폭을 할당할 때 주의를 기울여야 합니다. 수신 보고서와 CNAME이 전송되는 속도가 느려지고 프로토콜 성능이 저하되기 때문입니다. 추가 정보를 전달하는 데 단일 참가자에게 할당된 RTCP 대역폭의 20% 이하를 사용하는 것이 좋습니다. 또한 모든 SDES 항목이 모든 애플리케이션에 포함되는 것은 아닙니다. 포함된 항목은 유틸리티에 따라 대역폭의 일부를 할당해야 합니다. 이러한 부분을 동적으로 추정하는 대신 백분율을 항목의 일반적인 길이를 기반으로 보고 간격 수로 정적으로 변환하는 것이 좋습니다.\(SHOULD, SHOULD\)

예를 들어, 애플리케이션은 CNAME, NAME 및 EMAIL만 보내고 다른 것은 보내지 않도록 설계될 수 있습니다. NAME은 애플리케이션의 사용자 인터페이스에 지속적으로 표시되는 반면 EMAIL은 요청된 경우에만 표시되므로 EMAIL보다 훨씬 더 높은 우선순위가 부여될 수 있습니다. 모든 RTCP 간격마다 CNAME 항목이 포함된 RR 패킷과 SDES 패킷이 전송됩니다. 소규모 세션의 경우

최소 간격으로 작동하며 평균적으로 5초마다 작동합니다. 세 번째 간격\(15초\)마다 하나의 추가 항목이 SDES 패킷에 포함됩니다. 8번 중 7번은 NAME 항목이 되고, 8번마다\(2분\) EMAIL 항목이 됩니다.

예를 들어, 각 매체에 대한 RTP 세션으로 구성된 멀티미디어 회의에서와 같이 여러 애플리케이션이 각 참가자에 대한 공통 CNAME을 통한 애플리케이션 간 바인딩을 사용하여 동시에 작동하는 경우 추가 SDES 정보는 하나의 RTP 세션에서만 전송될 수 있습니다. 다른 세션은 CNAME 항목만 전달합니다. 특히, 이 접근법은 계층화된 인코딩 체계의 다중 세션에 적용되어야 합니다\(섹션 2.4 참조\).\(MAY\)

---
## **6.4 Sender and Receiver Reports**

RTP 수신자는 수신자가 발신자인지 여부에 따라 두 가지 형식 중 하나를 취할 수 있는 RTCP 보고 패킷을 사용하여 수신 품질 피드백을 제공합니다. 패킷 유형 코드 외에 발신자 보고서\(SR\)와 수신자 보고서\(RR\) 양식의 유일한 차이점은 발신자 보고서에 활성 발신자가 사용할 수 있는 20바이트 발신자 정보 섹션이 포함되어 있다는 것입니다. 사이트가 마지막 보고서나 이전 보고서를 발행한 이후 간격 동안 데이터 패킷을 전송한 경우 SR이 발행되고, 그렇지 않으면 RR이 발행됩니다.

SR 및 RR 형식 모두 0개 이상의 수신 보고 블록을 포함하며, 이는 이 수신기가 마지막 보고 이후 RTP 데이터 패킷을 수신한 각 동기화 소스에 대해 하나씩 포함됩니다. CSRC 목록에 나열된 기여 소스에 대한 보고서는 발행되지 않습니다. 각 수신 보고서 블록은 해당 블록에 표시된 특정 소스로부터 수신된 데이터에 대한 통계를 제공합니다. 최대 31개의 수신 보고 블록이 SR 또는 RR 패킷에 적합하므로 추가 RR 패킷은 마지막 보고 이후 간격 동안 청취된 모든 소스에 대한 수신 보고를 포함하는 데 필요한 만큼 초기 SR 또는 RR 패킷 뒤에 스택되어야 합니다. 네트워크 경로의 MTU를 초과하지 않고 필요한 모든 RR 패킷을 하나의 복합 RTCP 패킷에 맞추기에는 소스가 너무 많은 경우 하나의 MTU에 맞는 하위 집합만 각 간격에 포함되어야 합니다. 모든 소스가 보고되도록 여러 간격에 걸쳐 하위 집합을 라운드 로빈으로 선택해야 합니다.\(SHOULD, SHOULD, SHOULD\)

다음 섹션에서는 두 보고서의 형식, 응용 프로그램에 추가 피드백 정보가 필요한 경우 프로필별 방식으로 확장할 수 있는 방법 및 보고서를 사용할 수 있는 방법을 정의합니다. 번역자와 혼합자의 수신 보고에 대한 자세한 내용은 섹션 7에 나와 있습니다.

---
### **6.4.1 SR: Sender Report RTCP Packet**

```text
        0                   1                   2                   3
        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
header |V=2|P|    RC   |   PT=SR=200   |             length            |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |                         SSRC of sender                        |
       +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
sender |              NTP timestamp, most significant word             |
info   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |             NTP timestamp, least significant word             |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |                         RTP timestamp                         |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |                     sender's packet count                     |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |                      sender's octet count                     |
       +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
report |                 SSRC_1 (SSRC of first source)                 |
block  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  1    | fraction lost |       cumulative number of packets lost       |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |           extended highest sequence number received           |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |                      interarrival jitter                      |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |                         last SR (LSR)                         |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |                   delay since last SR (DLSR)                  |
       +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
report |                 SSRC_2 (SSRC of second source)                |
block  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  2    :                               ...                             :
       +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
       |                  profile-specific extensions                  |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

보낸 사람 보고서 패킷은 세 개의 섹션으로 구성되며 정의된 경우 네 번째 프로필별 확장 섹션이 뒤따를 수도 있습니다. 첫 번째 섹션인 헤더의 길이는 8옥텟입니다. 필드의 의미는 다음과 같습니다.

버전\(V\): 2비트

- RTP 데이터 패킷과 RTCP 패킷이 동일한 RTP 버전을 식별합니다. 이 사양에서 정의한 버전은 2입니다.

패딩\(P\): 1비트

- 패딩 비트가 설정된 경우 이 개별 RTCP 패킷에는 제어 정보의 일부는 아니지만 길이 필드에 포함된 추가 패딩 옥텟이 끝에 포함됩니다. 패딩의 마지막 옥텟은 자신을 포함하여 무시해야 하는 패딩 옥텟 수를 나타냅니다\(4의 배수임\). 블록 크기가 고정된 일부 암호화 알고리즘에서는 패딩이 필요할 수 있습니다. 복합 RTCP 패킷에서는 섹션 9.1의 방법에 대해 복합 패킷이 전체적으로 암호화되기 때문에 하나의 개별 패킷에만 패딩이 필요합니다. 따라서 패딩은 마지막 개별 패킷에만 추가되어야 하며 해당 패킷에 패딩이 추가된 경우 패딩 비트는 해당 패킷에만 설정되어야 합니다. 이 규칙은 부록 A.2에 설명된 헤더 유효성 검사에 도움이 되며 첫 번째 개별 패킷에 패딩 비트를 잘못 설정하고 마지막 개별 패킷에 패딩을 추가하는 일부 초기 구현에서 패킷을 감지할 수 있습니다.\(MUST\)

수신 보고 수\(RC\): 5비트

- 이 패킷에 포함된 수신 보고 블록의 수입니다. 0 값이 유효합니다.

패킷 유형\(PT\): 8비트

- 이를 RTCP SR 패킷으로 식별하기 위한 상수 200을 포함합니다.

길이: 16비트

- 헤더와 패딩을 포함하여 32비트 단어에서 1을 뺀 이 RTCP 패킷의 길이입니다. \(1의 오프셋은 0을 유효한 길이로 만들고 복합 RTCP 패킷을 검색할 때 가능한 무한 루프를 방지하는 반면, 32비트 단어를 계산하면 4의 배수에 대한 유효성 검사를 방지합니다.\)

SSRC: 32비트

- 이 SR 패킷의 발신자에 대한 동기화 소스 식별자입니다.

두 번째 섹션인 발신자 정보는 길이가 20옥텟이며 모든 발신자 보고 패킷에 있습니다. 이 발신자의 데이터 전송을 요약합니다. 필드의 의미는 다음과 같습니다.

NTP 타임스탬프: 64비트

- 이 보고서가 전송된 벽시계 시간\(섹션 4 참조\)을 표시하므로 다른 수신기의 수신 보고서에 반환된 타임스탬프와 함께 사용하여 해당 수신기로의 왕복 전파를 측정할 수 있습니다. 수신기는 타임스탬프의 측정 정확도가 NTP 타임스탬프의 해상도보다 훨씬 낮은 수준으로 제한될 수 있다는 점을 예상해야 합니다. 타임스탬프의 측정 불확도는 표시되지 않습니다.

- 모르실 수도 있습니다. 벽시계 시간 개념은 없지만 "시스템 가동 시간"과 같은 일부 시스템별 시계가 있는 시스템에서 발신자는 해당 시계를 참조로 사용하여 상대 NTP 타임스탬프를 계산할 수 있습니다. 멀티미디어 세션의 개별 스트림을 생성하기 위해 별도의 구현을 사용하는 경우 모든 구현이 동일한 시계를 사용하도록 일반적으로 사용되는 시계를 선택하는 것이 중요합니다. 2036년까지는 상대 타임스탬프와 절대 타임스탬프가 상위 비트에서 다르기 때문에 \(잘못된\) 비교에서는 큰 차이가 나타납니다. 그때쯤에는 상대 타임스탬프가 더 이상 필요하지 않기를 바랍니다. 벽시계 또는 경과 시간에 대한 개념이 없는 발신자는 NTP 타임스탬프를 0으로 설정할 수 있습니다.\(MAY, MAY\)

RTP 타임스탬프: 32비트

- NTP 타임스탬프\(위\)와 동일한 시간에 해당하지만 데이터 패킷의 RTP 타임스탬프와 동일한 단위 및 동일한 무작위 오프셋을 갖습니다. 이 대응은 NTP 타임스탬프가 동기화된 소스에 대한 미디어 내 및 미디어 간 동기화에 사용될 수 있으며 미디어 독립적 수신기에서 공칭 RTP 클록 주파수를 추정하는 데 사용될 수 있습니다. 대부분의 경우 이 타임스탬프는 인접한 데이터 패킷의 RTP 타임스탬프와 동일하지 않습니다. 오히려 샘플링 순간에 벽시계 시간을 주기적으로 확인하여 유지되는 RTP 타임스탬프 카운터와 실시간 사이의 관계를 사용하여 해당 NTP 타임스탬프에서 계산해야 합니다.\(MUST\)

발신자의 패킷 수: 32비트

- 전송 시작부터 이 SR 패킷이 생성된 시간까지 보낸 사람이 전송한 총 RTP 데이터 패킷 수입니다. 발신자가 SSRC 식별자를 변경하면 카운트를 재설정해야 합니다.\(SHOULD\)

발신자의 옥텟 수: 32비트

- 전송 시작부터 이 SR 패킷이 생성된 시간까지 발신자가 RTP 데이터 패킷에 전송한 페이로드 옥텟\(즉, 헤더 또는 패딩을 포함하지 않음\)의 총 개수입니다. 발신자가 SSRC 식별자를 변경하면 카운트를 재설정해야 합니다. 이 필드는 평균 페이로드 데이터 속도를 추정하는 데 사용할 수 있습니다.\(SHOULD\)

세 번째 섹션에는 마지막 보고 이후 이 발신자가 들은 다른 소스의 수에 따라 0개 이상의 수신 보고 블록이 포함됩니다. 각 수신 보고 블록은 단일 동기화 소스로부터의 RTP 패킷 수신에 대한 통계를 전달합니다. 충돌로 인해 소스가 SSRC 식별자를 변경할 때 수신기는 통계를 전달해서는 안 됩니다. 이러한 통계는 다음과 같습니다.\(SHOULD NOT\)

SSRC\_n\(소스 식별자\): 32비트

- 이 수신 보고 블록의 정보가 속하는 소스의 SSRC 식별자입니다.

손실된 분수: 8비트

- 이전 SR 또는 RR 패킷이 전송된 이후 손실된 소스 SSRC\_n의 RTP 데이터 패킷 비율로, 필드 왼쪽 가장자리에 이진 소수점이 있는 고정 소수점 숫자로 표현됩니다. \(이는 손실 부분에 256을 곱한 후 정수 부분을 취하는 것과 같습니다.\) 이 부분은 다음 단락에 정의된 대로 손실된 패킷 수를 예상되는 패킷 수로 나눈 값으로 정의됩니다. 구현은 부록 A.3에 나와 있습니다. 중복으로 인해 손실이 음수인 경우 손실된 부분은 0으로 설정됩니다. 수신자는 마지막 패킷 수신 이후 손실된 패킷이 있는지 여부를 알 수 없으며, 마지막 보고 간격 동안 전송된 해당 소스의 모든 패킷이 손실된 경우 소스에 대해 발행된 수신 보고 블록이 없다는 점에 유의하십시오.

손실된 패킷의 누적 수: 24비트

- 수신 시작 이후 손실된 소스 SSRC\_n의 총 RTP 데이터 패킷 수입니다. 이 숫자는 예상되는 패킷 수에서 실제로 수신된 패킷 수를 뺀 값으로 정의됩니다. 여기서 수신된 패킷 수에는 지연되었거나 중복된 패킷이 포함됩니다. 따라서 늦게 도착하는 패킷은 손실된 것으로 간주되지 않으며, 중복되는 경우 손실이 음수가 될 수 있습니다. 예상되는 패킷 수는 다음에 정의된 것처럼 수신된 확장된 마지막 시퀀스 번호에서 수신된 초기 시퀀스 번호를 뺀 값으로 정의됩니다. 이는 부록 A.3에 표시된 대로 계산될 수 있습니다.

수신된 확장된 가장 높은 시퀀스 번호: 32비트

- 하위 16비트는 소스 SSRC\_n에서 RTP 데이터 패킷으로 수신된 가장 높은 시퀀스 번호를 포함하고, 가장 중요한 16비트는 해당 시퀀스 번호 사이클 수로 해당 시퀀스 번호를 확장합니다. 이는 부록 A의 알고리즘에 따라 유지될 수 있습니다. .1. 동일한 세션 내의 서로 다른 수신자는 시작 시간이 크게 다를 경우 시퀀스 번호에 대해 서로 다른 확장을 생성합니다.

```text
   interarrival jitter: 32 bits
      An estimate of the statistical variance of the RTP data packet
      interarrival time, measured in timestamp units and expressed as an
      unsigned integer.  The interarrival jitter J is defined to be the
      mean deviation (smoothed absolute value) of the difference D in
      packet spacing at the receiver compared to the sender for a pair
      of packets.  As shown in the equation below, this is equivalent to
      the difference in the "relative transit time" for the two packets;
```

- 상대 전송 시간은 패킷의 RTP 타임스탬프와 도착 시 수신자의 시계 간의 차이이며 동일한 단위로 측정됩니다.

- Si가 패킷 i의 RTP 타임스탬프이고, Ri가 패킷 i에 대한 RTP 타임스탬프 단위의 도착 시간이라면, 두 패킷 i와 j에 대해 D는 다음과 같이 표현될 수 있습니다.

```text
         D(i,j) = (Rj - Ri) - (Sj - Si) = (Rj - Sj) - (Ri - Si)
```

- 도착 간 지터는 다음 공식에 따라 각 데이터 패킷 i가 소스 SSRC\_n에서 수신될 때 해당 패킷과 이전 패킷 i-1에 대한 차이 D를 도착 순서대로\(반드시 순서대로일 필요는 없음\) 사용하여 연속적으로 계산되어야 합니다.\(SHOULD\)

```text
         J(i) = J(i-1) + (|D(i-1,i)| - J(i-1))/16
```

- 수신 보고서가 발행될 때마다 J의 현재 값이 샘플링됩니다.

- 프로필 독립적인 모니터가 다양한 구현에서 나오는 보고서를 유효하게 해석할 수 있도록 하려면 지터 계산이 여기에 지정된 공식을 따라야 합니다. 이 알고리즘은 최적의 1차 추정기이며 이득 매개변수 1/16은 합리적인 수렴 속도를 유지하면서 우수한 잡음 감소 비율을 제공합니다\[22\]. 샘플 구현은 부록 A.8에 나와 있습니다. 전송 전 다양한 패킷 지속 시간과 지연의 영향에 대한 논의는 섹션 6.4.4를 참조하십시오.\(MUST\)

마지막 SR 타임스탬프\(LSR\): 32비트

- 소스 SSRC\_n에서 가장 최근의 RTCP 발신자 보고\(SR\) 패킷의 일부로 수신된 NTP 타임스탬프\(섹션 4에 설명됨\)의 64비트 중 중간 32비트입니다. 아직 SR이 수신되지 않은 경우 필드는 0으로 설정됩니다.

마지막 SR 이후 지연\(DLSR\): 32비트

- 소스 SSRC\_n에서 마지막 SR 패킷을 수신한 후 이 수신 보고 블록을 보내는 사이의 지연\(1/65536초 단위로 표시\)입니다. SSRC\_n으로부터 아직 SR 패킷이 수신되지 않은 경우 DLSR 필드는 0으로 설정됩니다.

- SSRC\_r은 이 수신자 보고서를 발행하는 수신자를 나타냅니다. 소스 SSRC\_n은 이 수신 보고 블록이 수신되는 시간 A를 기록하여 SSRC\_r에 대한 왕복 전파 지연을 계산할 수 있습니다. 마지막 SR 타임스탬프\(LSR\) 필드를 사용하여 총 왕복 시간 A-LSR을 계산한 다음 이 필드를 빼서 왕복 전파 지연을 \(A - LSR - DLSR\)로 유지합니다. 이것

- 그림 2에 설명되어 있습니다. 시간은 32비트 필드의 16진수 표현과 동등한 부동 소수점 10진수 표현으로 표시됩니다. 콜론은 16비트 정수 부분과 16비트 분수 부분으로 나누어진 32비트 필드를 나타냅니다.

- 일부 링크에는 매우 비대칭적인 지연이 있지만 이는 클러스터 수신기까지의 거리를 대략적으로 측정하는 데 사용될 수 있습니다.

```text
   [10 Nov 1995 11:33:25.125 UTC]       [10 Nov 1995 11:33:36.5 UTC]
   n                 SR(n)              A=b710:8000 (46864.500 s)
   ---------------------------------------------------------------->
                      v                 ^
   ntp_sec =0xb44db705 v               ^ dlsr=0x0005:4000 (    5.250s)
   ntp_frac=0x20000000  v             ^  lsr =0xb705:2000 (46853.125s)
     (3024992005.125 s)  v           ^
   r                      v         ^ RR(n)
   ---------------------------------------------------------------->
                          |<-DLSR->|
                           (5.250 s)

   A     0xb710:8000 (46864.500 s)
   DLSR -0x0005:4000 (    5.250 s)
   LSR  -0xb705:2000 (46853.125 s)
   -------------------------------
   delay 0x0006:2000 (    6.125 s)

           Figure 2: Example for round-trip time computation
```

---
### **6.4.2 RR: Receiver Report RTCP Packet**

```text
        0                   1                   2                   3
        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
header |V=2|P|    RC   |   PT=RR=201   |             length            |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |                     SSRC of packet sender                     |
       +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
report |                 SSRC_1 (SSRC of first source)                 |
block  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  1    | fraction lost |       cumulative number of packets lost       |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |           extended highest sequence number received           |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |                      interarrival jitter                      |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |                         last SR (LSR)                         |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |                   delay since last SR (DLSR)                  |
       +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
report |                 SSRC_2 (SSRC of second source)                |
block  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  2    :                               ...                             :
       +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
       |                  profile-specific extensions                  |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

RR\(Receiver Report\) 패킷의 형식은 패킷 유형 필드에 상수 201이 포함되어 있고 보낸 사람 정보의 5개 단어가 생략된 점을 제외하면 SR 패킷의 형식과 동일합니다\(NTP 및 RTP 타임스탬프와 보낸 사람의 패킷 및 옥텟 수\). 나머지 필드는 SR 패킷과 동일한 의미를 갖습니다.

보고할 데이터 전송 또는 수신이 없는 경우 빈 RR 패킷\(RC = 0\)을 복합 RTCP 패킷의 헤드에 배치해야 합니다.\(MUST\)

---
### **6.4.3 Extending the Sender and Receiver Reports**

프로필은 발신자 또는 수신자에 대해 정기적으로 보고해야 하는 추가 정보가 있는 경우 발신자 보고서 및 수신자 보고서에 대한 프로필별 확장을 정의해야 합니다\(SHOULD\). 이 방법은 오버헤드가 덜 필요하므로 다른 RTCP 패킷 유형을 정의하는 것보다 우선적으로 사용해야 합니다.\(SHOULD, SHOULD\)

```text
   o  fewer octets in the packet (no RTCP header or SSRC field);
```

o 해당 프로필에서 실행되는 응용 프로그램은 수신 보고 후 직접 액세스할 수 있는 위치에서 확장 필드를 항상 예상하도록 프로그래밍되므로 구문 분석이 더 간단하고 빠릅니다.

확장은 수신 보고가 차단된 후 끝에 오는 송신자 또는 수신자 보고 패킷의 네 번째 섹션입니다. 추가 발신자 정보가 필요한 경우 발신자 보고서의 경우 해당 정보가 확장 섹션에 먼저 포함되지만 수신자 보고서의 경우에는 표시되지 않습니다. 수신자에 대한 정보가 포함되어야 하는 경우 해당 데이터는 기존 수신 보고 블록 배열과 평행한 블록 배열로 구성되어야 합니다. 즉, 블록 수는 RC 필드로 표시됩니다.\(SHOULD\)

---
### **6.4.4 Analyzing Sender and Receiver Reports**

수신 품질 피드백은 송신자뿐만 아니라 다른 수신자 및 타사 모니터에게도 유용할 것으로 예상됩니다. 발신자는 피드백을 기반으로 전송 내용을 수정할 수 있습니다. 수신자는 문제가 지역적인지, 지역적인지 또는 세계적인지 여부를 판단할 수 있습니다. 네트워크 관리자는 RTCP 패킷만 수신하고 해당 RTP 데이터 패킷은 수신하지 않는 프로필 독립적 모니터를 사용하여 멀티캐스트 배포에 대한 네트워크 성능을 평가할 수 있습니다.

누적 개수는 발신자 정보와 수신자 보고서 블록 모두에서 사용되므로 두 보고서 간의 차이를 계산하여 단기 및 장기 기간에 걸쳐 측정을 수행하고 보고서 손실에 대한 복원력을 제공할 수 있습니다. 수신된 마지막 두 보고서의 차이를 사용하여 최근 배포 품질을 추정할 수 있습니다. NTP 타임스탬프가 포함되어 두 보고서 사이의 간격에 대한 이러한 차이로부터 요율이 계산될 수 있습니다. 해당 타임스탬프는 데이터 인코딩의 클럭 속도와 무관하므로 인코딩 및 프로필에 독립적인 품질 모니터를 구현하는 것이 가능합니다.

계산 예로는 두 개의 수신 보고서 사이의 간격에 따른 패킷 손실률이 있습니다. 손실된 누적 패킷 수의 차이는 해당 간격 동안 손실된 수를 나타냅니다. 수신된 확장된 마지막 시퀀스 번호의 차이는 해당 간격 동안 예상되는 패킷 수를 제공합니다. 이 둘의 비율은 해당 간격 동안의 패킷 손실 비율입니다. 두 보고서가 연속되는 경우 이 비율은 손실된 부분 필드와 같아야 하지만 그렇지 않으면 그렇지 않을 수도 있습니다. 초당 손실률은 손실 비율을 초 단위로 표시되는 NTP 타임스탬프의 차이로 나누어 얻을 수 있습니다. 수신된 패킷 수는 예상되는 패킷 수에서 손실된 수를 뺀 값입니다. 개수

예상되는 패킷은 손실 추정치의 통계적 타당성을 판단하는 데 사용될 수도 있습니다. 예를 들어 손실된 패킷 5개 중 1개는 1000개 중 200개보다 중요성이 낮습니다.

발신자 정보를 통해 타사 모니터는 데이터를 수신하지 않고도 일정 간격 동안 평균 페이로드 데이터 속도와 평균 패킷 속도를 계산할 수 있습니다. 이 둘의 비율을 취하면 평균 페이로드 크기가 제공됩니다. 패킷 손실이 패킷 크기와 무관하다고 가정할 수 있는 경우 특정 수신기에서 수신한 패킷 수에 평균 페이로드 크기\(또는 해당 패킷 크기\)를 곱하면 해당 수신기에서 사용할 수 있는 명백한 처리량이 제공됩니다.

보고서 간의 차이를 사용하여 장기 패킷 손실 측정을 허용하는 누적 개수 외에도 손실 비율 필드는 단일 보고서에서 단기 측정을 제공합니다. 이는 수신 상태 정보가 모든 수신자에 대해 유지되지 않을 정도로 세션 크기가 확장되거나 특정 수신자로부터 하나의 보고서만 수신될 만큼 보고서 간의 간격이 길어질수록 더욱 중요해집니다.

도착간 지터 필드는 네트워크 정체에 대한 두 번째 단기 측정값을 제공합니다. 패킷 손실은 지속적인 정체를 추적하고, 지터 측정은 일시적인 정체를 추적합니다. 지터 측정은 패킷 손실로 이어지기 전에 정체를 나타낼 수 있습니다. 도착 간 지터 필드는 보고 당시의 지터에 대한 스냅샷일 뿐이며 정량적으로 측정할 수 없습니다. 오히려 이는 시간이 지남에 따라 하나의 수신자 또는 여러 수신자\(예: 단일 네트워크 내에서 동시에\)의 여러 보고서를 비교하기 위한 것입니다. 수신기 간 비교를 허용하려면 모든 수신기에서 동일한 공식에 따라 지터를 계산하는 것이 중요합니다.

지터 계산은 패킷의 첫 번째 데이터가 샘플링된 순간을 나타내는 RTP 타임스탬프를 기반으로 하기 때문에 해당 샘플링 순간과 패킷이 전송되는 시간 사이의 지연 변화는 계산되는 결과 지터에 영향을 미칩니다. 이러한 지연 변화는 지속 시간이 다양한 오디오 패킷에 대해 발생합니다. 타임스탬프는 한 프레임의 모든 패킷에 대해 동일하지만 해당 패킷이 모두 동시에 전송되지는 않기 때문에 비디오 인코딩에서도 발생합니다. 전송까지 지연의 변화는 네트워크 자체의 동작을 측정하는 지터 계산의 정확성을 감소시키지만, 수신기 버퍼가 이를 수용해야 한다는 점을 고려하여 포함하는 것이 적절합니다. 지터 계산을 비교 측정으로 사용하는 경우 전송까지 지연의 변화로 인한 \(일정한\) 구성 요소를 빼서

네트워크 지터 구성 요소는 상대적으로 작지 않는 한 관찰할 수 있습니다. 변화가 작다면 중요하지 않을 가능성이 높습니다.

---
## **6.5 SDES: Source Description RTCP Packet**

```text
        0                   1                   2                   3
        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
header |V=2|P|    SC   |  PT=SDES=202  |             length            |
       +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
chunk  |                          SSRC/CSRC_1                          |
  1    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |                           SDES items                          |
       |                              ...                              |
       +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
chunk  |                          SSRC/CSRC_2                          |
  2    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |                           SDES items                          |
       |                              ...                              |
       +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
```

SDES 패킷은 헤더와 0개 이상의 청크로 구성된 3단계 구조로, 각 청크는 해당 청크에서 식별된 소스를 설명하는 항목으로 구성됩니다. 항목은 다음 섹션에서 개별적으로 설명됩니다.

버전\(V\), 패딩\(P\), 길이:

- SR 패킷에 대해 설명된 것과 같습니다\(섹션 6.4.1 참조\).

패킷 유형\(PT\): 8비트

- 이를 RTCP SDES 패킷으로 식별하기 위한 상수 202가 포함되어 있습니다.

소스 카운트\(SC\): 5비트

- 이 SDES 패킷에 포함된 SSRC/CSRC 청크 수입니다. 0 값은 유효하지만 쓸모가 없습니다.

각 청크는 SSRC/CSRC 식별자와 SSRC/CSRC에 대한 정보를 전달하는 0개 이상의 항목 목록으로 구성됩니다. 각 청크는 32비트 경계에서 시작됩니다. 각 항목은 8비트 유형 필드, 텍스트 길이를 설명하는 8비트 옥텟 수\(따라서 이 2옥텟 헤더는 포함되지 않음\) 및 텍스트 자체로 구성됩니다. 텍스트는 255옥텟을 초과할 수 없지만 이는 RTCP 대역폭 소비를 제한해야 하는 필요성과 일치합니다.

텍스트는 RFC 2279 \[5\]에 지정된 UTF-8 인코딩에 따라 인코딩됩니다. US-ASCII는 이 인코딩의 하위 집합이며 추가 인코딩이 필요하지 않습니다. 다중 옥텟 인코딩의 존재는 문자의 최상위 비트를 1의 값으로 설정하여 표시됩니다.

항목은 연속적입니다. 즉, 항목이 32비트 경계에 개별적으로 채워지지 않습니다. 일부 다중 옥텟 인코딩에는 널 옥텟이 포함되어 있으므로 텍스트는 널로 끝나지 않습니다. 각 청크의 항목 목록은 하나 이상의 null 옥텟으로 종료되어야 하며, 그 중 첫 번째는 목록의 끝을 나타내기 위해 항목 유형 0으로 해석됩니다. 널 항목 유형 옥텟 뒤에는 길이 옥텟이 없지만 다음 32비트 경계까지 채워야 하는 경우 추가 널 옥텟이 포함되어야 합니다. 이 패딩은 RTCP 헤더의 P 비트가 나타내는 패딩과 별개입니다. 항목이 없는 청크\(4개의 널 옥텟\)는 유효하지만 쓸모가 없습니다.\(MUST, MUST\)

최종 시스템은 자체 소스 식별자\(고정 RTP 헤더의 SSRC와 동일\)가 포함된 하나의 SDES 패킷을 보냅니다. 믹서는 SDES 정보를 수신하는 각 기여 소스에 대한 청크를 포함하는 하나의 SDES 패킷을 보내거나, 그러한 소스가 31개보다 많은 경우 위 형식의 여러 완전한 SDES 패킷을 보냅니다\(섹션 7 참조\).

현재 정의된 SDES 항목은 다음 섹션에서 설명됩니다. CNAME 항목만 필수입니다. 여기에 표시된 일부 항목은 특정 프로필에만 유용할 수 있지만 항목 유형은 공유 사용을 촉진하고 프로필 독립적인 응용 프로그램을 단순화하기 위해 모두 하나의 공통 공간에서 할당됩니다. 섹션 15에 설명된 대로 IANA에 유형 번호를 등록하여 프로필에 추가 항목을 정의할 수 있습니다.

---
### **6.5.1 CNAME: Canonical End-Point Identifier SDES Item**

```text
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |    CNAME=1    |     length    | user and domain name        ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

CNAME 식별자에는 다음과 같은 속성이 있습니다.

o 무작위로 할당된 SSRC 식별자는 충돌이 발견되거나 프로그램이 다시 시작되는 경우 변경될 수 있으므로 SSRC 식별자에서 일정하게 유지되는 소스\(발신자 또는 수신자\) 식별자에 대한 바인딩을 제공하기 위해 CNAME 항목을 포함해야 합니다.\(MUST\)

o SSRC 식별자와 마찬가지로 CNAME 식별자도 하나의 RTP 세션 내의 모든 참가자 간에 고유해야 합니다.\(SHOULD\)

o 관련 RTP 세션 세트에서 한 참가자가 사용하는 여러 미디어 도구에 걸쳐 바인딩을 제공하려면 해당 참가자에 대해 CNAME을 수정해야 합니다.\(SHOULD\)

o 제3자 모니터링을 용이하게 하려면 CNAME은 프로그램이나 사람이 소스를 찾는 데 적합해야 합니다.\(SHOULD\)

따라서 CNAME은 알고리즘에 따라 파생되어야 하며 가능하면 수동으로 입력해서는 안 됩니다. 이러한 요구 사항을 충족하려면 프로필이 대체 구문이나 의미를 지정하지 않는 한 다음 형식을 사용해야 합니다. CNAME 항목은 "user@host" 형식을 가져야 하며, 단일 사용자 시스템에서처럼 사용자 이름을 사용할 수 없는 경우 "host" 형식을 가져야 합니다. 두 형식 모두에서 "호스트"는 RFC 1034 \[6\], RFC 1035 \[7\] 및 RFC 1123의 섹션 2.1에 지정된 규칙에 따라 형식이 지정된 실시간 데이터가 발생하는 호스트의 정규화된 도메인 이름입니다. \[8\]; 또는 RTP 통신에 사용되는 인터페이스의 호스트 숫자 주소에 대한 표준 ASCII 표현입니다. 예를 들어, IP 버전 4 주소의 표준 ASCII 표현은 "점으로 구분된 10진수"\(점으로 구분된 쿼드라고도 함\)이며 IP 버전 6의 경우 주소는 텍스트로 콜론으로 구분된 16진수 그룹으로 표시됩니다\(RFC에 자세히 설명된 변형 포함\). 3513\[23\]\). 다른 주소 유형에는 상호 고유한 ASCII 표현이 있어야 합니다. 정규화된 도메인 이름은 인간 관찰자에게 더 편리하며 추가로 NAME 항목을 보낼 필요가 없지만 일부 운영 환경에서는 안정적으로 얻는 것이 어렵거나 불가능할 수 있습니다. 그러한 환경에서 실행될 수 있는 애플리케이션은 대신 주소의 ASCII 표현을 사용해야 합니다.\(SHOULD, SHOULD, SHOULD, SHOULD\)

예를 들어 다중 사용자 시스템의 경우 "doe@sleepy.example.com", "doe@192.0.2.89" 또는 "doe@2201:056D::112E:144A:1E24"입니다. 사용자 이름이 없는 시스템의 예는 "sleepy.example.com", "192.0.2.89" 또는 "2201:056D::112E:144A:1E24"입니다.

사용자 이름은 "finger" 또는 "talk"와 같은 프로그램이 사용할 수 있는 형식이어야 합니다. 즉, 일반적으로 개인 이름이 아닌 로그인 이름입니다. 호스트 이름은 참가자의 전자 메일 주소와 반드시 동일할 필요는 없습니다.\(SHOULD\)

응용 프로그램이 사용자가 하나의 호스트에서 여러 소스를 생성하도록 허용하는 경우 이 구문은 각 소스에 대한 고유 식별자를 제공하지 않습니다. 이러한 애플리케이션은 소스를 추가로 식별하기 위해 SSRC에 의존해야 하거나 해당 애플리케이션의 프로필이 CNAME 식별자에 대한 추가 구문을 지정해야 합니다.

각 애플리케이션이 CNAME을 독립적으로 생성하는 경우 결과 CNAME은 관련 RTP 세션 집합의 한 참가자에게 속한 여러 미디어 도구에 바인딩을 제공하는 데 필요한 것과 동일하지 않을 수 있습니다. 미디어 간 바인딩이 필요한 경우 각 도구의 CNAME을 조정 도구를 통해 외부에서 동일한 값으로 구성해야 할 수도 있습니다.

애플리케이션 작성자는 RFC 1918 \[24\]에서 제안된 Net-10 할당과 같은 개인 네트워크 주소 할당이 전역적으로 고유하지 않은 네트워크 주소를 생성할 수 있다는 점을 알고 있어야 합니다. 개인 주소가 있고 공용 인터넷에 직접 IP 연결이 없는 호스트가 RTP 수준 변환기를 통해 RTP 패킷을 공용 인터넷으로 전달하는 경우 이로 인해 고유하지 않은 CNAME이 발생합니다. \(RFC 1627 \[25\]도 참조하십시오.\) 이 경우를 처리하기 위해 애플리케이션은 고유한 CNAME을 구성하는 수단을 제공할 수 있지만 개인 주소가 공개되지 않도록 유지하기 위해 필요한 경우 CNAME을 개인 주소에서 공용 주소로 변환하는 부담은 변환기에게 있습니다. 노출된.\(MAY\)

---
### **6.5.2 NAME: User Name SDES Item**

```text
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |     NAME=2    |     length    | common name of source       ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

이는 소스를 설명하는 데 사용되는 실제 이름입니다\(예: "John Doe, Bit Recycler"\). 사용자가 원하는 어떤 형태로든 가능합니다. 회의와 같은 애플리케이션의 경우 이 이름 형식은 참가자 목록에 표시하는 데 가장 적합할 수 있으므로 CNAME 이외의 항목 중 가장 자주 전송될 수 있습니다. 프로필은 그러한 우선순위를 설정할 수 있습니다. NAME 값은 적어도 세션 기간 동안 일정하게 유지되어야 합니다. 세션의 모든 참가자 사이에서 고유하다고 의존하면 안 됩니다.\(MAY, SHOULD NOT\)

---
### **6.5.3 EMAIL: Electronic Mail Address SDES Item**

```text
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |    EMAIL=3    |     length    | email address of source     ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

이메일 주소는 RFC 2822 \[9\]에 따라 형식화됩니다\(예: "John.Doe@example.com"\). EMAIL 값은 세션 기간 동안 일정하게 유지되어야 합니다.

---
### **6.5.4 PHONE: Phone Number SDES Item**

```text
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |    PHONE=4    |     length    | phone number of source      ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

전화번호는 국제 접속 코드를 대체하는 더하기 기호로 형식을 지정해야 합니다. 예를 들어 미국 전화번호의 경우 '+1 908 555 1212'입니다.\(SHOULD\)

---
### **6.5.5 LOC: Geographic User Location SDES Item**

```text
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |     LOC=5     |     length    | geographic location of site ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

응용 분야에 따라 이 항목에 적합한 세부 수준이 다릅니다. 컨퍼런스 애플리케이션의 경우 "Murray Hill, New Jersey"와 같은 문자열이면 충분할 수 있지만 활성 배지 시스템의 경우 "Room 2A244, AT&T BL MH"와 같은 문자열이 적절할 수 있습니다. 세부사항의 정도는 구현 및/또는 사용자에게 달려 있지만 형식과 내용은 프로필에 의해 규정될 수 있습니다. LOC 값은 모바일 호스트를 제외하고 세션 기간 동안 일정하게 유지될 것으로 예상됩니다.\(MAY\)

---
### **6.5.6 TOOL: Application or Tool Name SDES Item**

```text
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |     TOOL=6    |     length    |name/version of source appl. ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

스트림을 생성하는 애플리케이션의 이름과 버전을 제공하는 문자열입니다\(예: "videotool 1.2"\). 이 정보는 디버깅 목적으로 유용할 수 있으며 메일러 또는 메일 시스템 버전 SMTP 헤더와 유사합니다. TOOL 값은 세션 기간 동안 일정하게 유지되어야 합니다.

---
### **6.5.7 NOTE: Notice/Status SDES Item**

```text
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |     NOTE=7    |     length    | note about the source       ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

이 항목에 대해 다음 의미 체계가 제안되지만 이러한 의미 체계 또는 다른 의미 체계는 프로필에 의해 명시적으로 정의될 수 있습니다. 참고 항목은 소스의 현재 상태를 설명하는 일시적인 메시지\(예: "통화 중이므로 통화할 수 없음"\)를 위한 것입니다. 또는 세미나 중에 이 항목을 사용하여 강연 제목을 전달할 수도 있습니다. 이는 예외적인 정보를 전달하는 데에만 사용해야 하며 모든 참가자가 일상적으로 포함해서는 안 됩니다. 이렇게 하면 수신 보고서와 CNAME이 전송되는 속도가 느려지고 프로토콜 성능이 저하될 수 있기 때문입니다. 특히, 사용자 구성 파일의 항목으로 포함되거나 오늘의 견적처럼 자동으로 생성되어서는 안 됩니다.\(MAY, SHOULD NOT, SHOULD NOT\)

NOTE 항목은 활성화된 동안 표시하는 것이 중요할 수 있으므로 NAME과 같은 CNAME이 아닌 다른 항목이 전송되는 속도가 줄어들어 NOTE 항목이 RTCP 대역폭의 해당 부분을 차지할 수 있습니다. 임시 메시지가 비활성화되면 NOTE 항목은 동일한 반복 속도로 여러 번 계속 전송되어야 하지만 수신자에게 신호를 보내기 위해 길이가 0인 문자열을 사용해야 합니다. 그러나 수신기는 반복 속도의 작은 배수 또는 20-30 RTCP 간격 동안 수신되지 않은 경우 NOTE 항목을 비활성 상태로 간주해야 합니다.\(SHOULD, SHOULD\)

---
### **6.5.8 PRIV: Private Extensions SDES Item**

```text
     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |     PRIV=8    |     length    | prefix length |prefix string...
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    ...             |                  value string               ...
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

이 항목은 실험적 또는 애플리케이션별 SDES 확장을 정의하는 데 사용됩니다. 항목에는 길이-문자열 쌍으로 구성된 접두사가 포함되어 있으며 그 뒤에는 항목의 나머지 부분을 채우고 원하는 정보를 전달하는 값 문자열이 옵니다. 접두사 길이 필드의 길이는 8비트입니다. 접두사 문자열은 이 애플리케이션이 수신할 수 있는 다른 PRIV 항목과 관련하여 고유하도록 PRIV 항목을 정의하는 사람이 선택한 이름입니다. 응용 프로그램 작성자는 다음과 같은 경우 응용 프로그램 이름과 추가 하위 유형 식별을 사용하도록 선택할 수 있습니다.

필요합니다. 또는 다른 사람들이 자신이 나타내는 엔터티를 기반으로 이름을 선택한 다음 해당 엔터티 내에서 이름 사용을 조정하는 것이 좋습니다.\(SHOULD\)

접두사는 항목의 총 길이인 255옥텟 내에서 일부 공간을 사용하므로 접두사는 최대한 짧게 유지해야 합니다. 이 기능과 제한된 RTCP 대역폭은 과부하되어서는 안 됩니다. 이는 모든 애플리케이션의 모든 제어 통신 요구 사항을 충족하기 위한 것이 아닙니다.\(SHOULD NOT\)

SDES PRIV 접두사는 IANA에 의해 등록되지 않습니다. PRIV 항목의 일부 형식이 일반 유용성이 입증된 경우 접두사가 필요하지 않도록 대신 IANA에 등록된 일반 SDES 항목 유형을 할당해야 합니다. 이는 사용을 단순화하고 전송 효율성을 높입니다.\(SHOULD\)

---
## **6.6 BYE: Goodbye RTCP Packet**

```text
       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |V=2|P|    SC   |   PT=BYE=203  |             length            |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                           SSRC/CSRC                           |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      :                              ...                              :
      +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
(opt) |     length    |               reason for leaving            ...
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

BYE 패킷은 하나 이상의 소스가 더 이상 활성 상태가 아님을 나타냅니다.

버전\(V\), 패딩\(P\), 길이:

- SR 패킷에 대해 설명된 것과 같습니다\(섹션 6.4.1 참조\).

패킷 유형\(PT\): 8비트

- 이를 RTCP BYE 패킷으로 식별하기 위한 상수 203을 포함합니다.

소스 카운트\(SC\): 5비트

- 이 BYE 패킷에 포함된 SSRC/CSRC 식별자의 수입니다. 카운트 값 0은 유효하지만 쓸모가 없습니다.

BYE 패킷을 전송해야 하는 시기에 대한 규칙은 섹션 6.3.7 및 8.2에 지정되어 있습니다.

BYE 패킷이 믹서에 의해 수신되면 믹서는 SSRC/CSRC 식별자를 변경하지 않고 BYE 패킷을 전달해야 합니다. 믹서가 종료되면 믹서는 자신이 처리하는 모든 기여 소스와 자체 SSRC 식별자를 나열하는 BYE 패킷을 보내야 합니다. 선택적으로 BYE 패킷에는 8비트 옥텟 수와 이탈 이유를 나타내는 많은 옥텟\(예: "카메라 오작동" 또는 "RTP 루프 감지"\)이 포함될 수 있습니다. 문자열은 SDES에 대해 설명된 것과 동일한 인코딩을 갖습니다. 문자열이 패킷을 다음 32비트 경계까지 채우는 경우 문자열은 null로 끝나지 않습니다. 그렇지 않은 경우 BYE 패킷은 다음 32비트 경계까지 널 옥텟으로 채워져야 합니다. 이 패딩은 RTCP 헤더의 P 비트가 나타내는 패딩과 별개입니다.\(SHOULD, SHOULD, MAY, MUST\)

---
## **6.7 APP: Application-Defined RTCP Packet**

```text
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |V=2|P| subtype |   PT=APP=204  |             length            |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                           SSRC/CSRC                           |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                          name (ASCII)                         |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                   application-dependent data                ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

APP 패킷은 패킷 유형 값 등록을 요구하지 않고 새로운 애플리케이션과 새로운 기능이 개발됨에 따라 실험적으로 사용하기 위한 것입니다. 인식할 수 없는 이름을 가진 APP 패킷은 무시되어야 합니다. 테스트 후 더 넓은 사용이 정당화되면 각 APP 패킷을 하위 유형 및 이름 필드 없이 재정의하고 RTCP 패킷 유형을 사용하여 IANA에 등록하는 것이 좋습니다.\(SHOULD, SHOULD\)

버전\(V\), 패딩\(P\), 길이:

- SR 패킷에 대해 설명된 것과 같습니다\(섹션 6.4.1 참조\).

하위 유형: 5비트

- APP 패킷 세트를 하나의 고유한 이름으로 정의하거나 애플리케이션 종속 데이터에 대해 정의할 수 있도록 하위 유형으로 사용할 수 있습니다.

패킷 유형\(PT\): 8비트

- 이를 RTCP APP 패킷으로 식별하기 위한 상수 204가 포함되어 있습니다.

이름: 4옥텟

- 이 애플리케이션이 수신할 수 있는 다른 APP 패킷과 관련하여 고유하도록 APP 패킷 세트를 정의하는 사람이 선택한 이름입니다. 응용 프로그램 작성자는 응용 프로그램 이름을 사용하도록 선택한 다음 응용 프로그램에 대한 새 패킷 유형을 정의하려는 다른 사용자에게 하위 유형 값 할당을 조정할 수 있습니다. 또는 다른 사람들이 자신이 나타내는 엔터티를 기반으로 이름을 선택한 다음 해당 엔터티 내에서 이름 사용을 조정하는 것이 좋습니다. 이름은 4개의 ASCII 문자 시퀀스로 해석되며 대문자와 소문자는 별개로 처리됩니다.\(SHOULD\)

애플리케이션 종속 데이터: 가변 길이

- 애플리케이션 종속 데이터는 APP 패킷에 나타날 수도 있고 나타나지 않을 수도 있습니다. 이는 RTP 자체가 아닌 애플리케이션에 의해 해석됩니다. 길이는 32비트의 배수여야 합니다.\(MUST\)

---
## **7. RTP Translators and Mixers**

최종 시스템 외에도 RTP는 RTP 수준에서 "중간 시스템"으로 간주될 수 있는 "번역기" 및 "믹서" 개념을 지원합니다. 이 지원이 프로토콜에 약간의 복잡성을 추가하기는 하지만 인터넷에서 멀티캐스트 오디오 및 비디오 응용 프로그램을 사용한 실험을 통해 이러한 기능에 대한 필요성이 명확하게 확립되었습니다. 섹션 2.3에 제시된 변환기 및 믹서의 사용 예는 방화벽과 낮은 대역폭 연결의 존재에서 비롯되며 둘 다 남아 있을 가능성이 높습니다.

---
## **7.1 General Description**

RTP 변환기/믹서는 두 개 이상의 전송 수준 "클라우드"를 연결합니다. 일반적으로 각 클라우드는 공통 네트워크 및 전송 프로토콜\(예: IP/UDP\)과 멀티캐스트 주소 및 전송 수준 대상 포트 또는 유니캐스트 주소 및 포트 쌍으로 정의됩니다. \(IP 버전 4에서 IP 버전 6까지의 네트워크 수준 프로토콜 변환기는 RTP에 보이지 않게 클라우드 내에 존재할 수 있습니다.\) 하나의 시스템은 여러 RTP 세션에 대한 변환기 또는 혼합기 역할을 할 수 있지만 각 시스템은 논리적으로 별도의 실체.

변환기나 믹서를 설치할 때 루프 생성을 방지하려면 다음 규칙을 준수해야 합니다.\(MUST\)

o 번역기와 혼합기로 연결된 각 클라우드

- 하나의 RTP 세션에 참여하는 것은 이러한 매개변수\(프로토콜, 주소, 포트\) 중 적어도 하나에서 다른 모든 세션과 구별되어야 하거나 네트워크 수준에서 다른 세션과 격리되어야 합니다.\(MUST\)

o 첫 번째 규칙의 파생물은 어떤 배열에 의해 전달될 소스 세트를 분할하지 않는 한 여러 변환기 또는 믹서가 병렬로 연결되어서는 안 된다는 것입니다.\(MUST NOT\)

마찬가지로, 하나 이상의 RTP 변환기 또는 믹서를 통해 통신할 수 있는 모든 RTP 최종 시스템은 동일한 SSRC 공간을 공유합니다. 즉, SSRC 식별자는 이러한 모든 최종 시스템 중에서 고유해야 합니다. 섹션 8.2에서는 SSRC 식별자를 고유하게 유지하고 루프를 감지하는 충돌 해결 알고리즘을 설명합니다.\(MUST\)

다양한 목적과 응용 분야에 맞게 설계된 다양한 종류의 변환기와 혼합기가 있을 수 있습니다. 몇 가지 예로는 암호화 추가 또는 제거, 데이터 인코딩 또는 기본 프로토콜 변경, 멀티캐스트 주소와 하나 이상의 유니캐스트 주소 간 복제 등이 있습니다. 변환기와 믹서의 차이점은 변환기는 서로 다른 소스의 데이터 스트림을 개별적으로 통과하는 반면 믹서는 이를 결합하여 하나의 새로운 스트림을 형성한다는 것입니다.

변환기: SSRC 식별자를 사용하여 RTP 패킷을 전달합니다.

- 그대로; 이를 통해 모든 소스의 패킷이 동일한 변환기를 통과하고 변환기의 네트워크 소스 주소를 전달하더라도 수신자가 개별 소스를 식별할 수 있습니다. 일부 종류의 변환기는 데이터를 그대로 전달하지만 다른 변환기는 데이터 인코딩을 변경하여 RTP 데이터 페이로드 유형 및 타임스탬프를 변경할 수도 있습니다. 여러 데이터 패킷이 하나로 다시 인코딩되거나 그 반대로 인코딩되는 경우 변환기는 나가는 패킷에 새로운 시퀀스 번호를 할당해야 합니다. 들어오는 패킷 스트림의 손실로 인해 나가는 시퀀스 번호에 해당 간격이 발생할 수 있습니다. 수신기는 원본 소스에서 어떤 페이로드 유형이나 전송 주소가 사용되었는지 다른 방법으로 알지 않는 한 번역기의 존재를 감지할 수 없습니다.\(MAY, MUST\)

믹서: 하나 이상의 RTP 데이터 패킷 스트림을 수신합니다.

- 소스는 데이터 형식을 변경하고 어떤 방식으로든 스트림을 결합한 다음 결합된 스트림을 전달합니다. 여러 입력 소스 간의 타이밍은 일반적으로 동기화되지 않으므로 믹서는 스트림 간의 타이밍을 조정하고 결합된 스트림에 대한 자체 타이밍을 생성하므로 이것이 동기화 소스입니다. 따라서 믹서가 전달하는 모든 데이터 패킷은 반드시 믹서 자체의 SSRC 식별자로 표시되어야 합니다. 혼합 패킷에 기여하는 원래 소스의 ID를 보존하기 위해 믹서는 SSRC 식별자를 패킷의 고정 RTP 헤더 다음에 있는 CSRC 식별자 목록에 삽입해야 합니다. 자체적으로 일부 패킷의 기여 소스이기도 한 믹서는 해당 패킷의 CSRC 목록에 자신의 SSRC 식별자를 명시적으로 포함해야 합니다.\(MUST, SHOULD, SHOULD\)

- 일부 애플리케이션의 경우 믹서가 CSRC 목록에서 소스를 식별하지 않는 것이 허용될 수 있습니다. 그러나 이로 인해 해당 소스와 관련된 루프를 감지할 수 없는 위험이 발생합니다.\(MAY\)

오디오와 같은 응용 분야에서 변환기에 비해 믹서가 갖는 장점은 입력 측에서 여러 소스가 활성화되어 있는 경우에도 출력 대역폭이 하나의 소스로 제한된다는 것입니다. 이는 낮은 대역폭 링크에 중요할 수 있습니다. 단점은 믹서의 원격 제어를 위한 일부 메커니즘이 구현되지 않는 한 출력 측의 수신기가 소스가 통과되거나 음소거되는 것을 제어할 수 없다는 것입니다. 믹서에 의한 동기화 정보 재생성은 수신기가 원본 스트림의 미디어 간 동기화를 수행할 수 없음을 의미하기도 합니다. 멀티미디어 믹서가 그것을 할 수 있다.

```text
         [E1]                                    [E6]
          |                                       |
    E1:17 |                                 E6:15 |
          |                                       |   E6:15
          V  M1:48 (1,17)         M1:48 (1,17)    V   M1:48 (1,17)
         (M1)-------------><T1>-----------------><T2>-------------->[E7]
          ^                 ^     E4:47           ^   E4:47
     E2:1 |           E4:47 |                     |   M3:89 (64,45)
          |                 |                     |
         [E2]              [E4]     M3:89 (64,45) |
                                                  |        legend:
   [E3] --------->(M2)----------->(M3)------------|        [End system]
          E3:64        M2:12 (64)  ^                       (Mixer)
                                   | E5:45                 <Translator>
                                   |
                                  [E5]          source: SSRC (CSRCs)
                                                ------------------->
```

그림 3: 최종 시스템, 믹서 및 변환기가 포함된 샘플 RTP 네트워크

SSRC 및 CSRC 식별자에 미치는 영향을 설명하기 위해 혼합기 및 변환기 모음이 그림 3에 표시되어 있습니다. 그림에서 말단 시스템은 직사각형\(E\)으로, 변환기는 삼각형\(T\)으로, 믹서는 타원\(M\)으로 표시됩니다. "M1: 48\(1,17\)" 표기는 M1의 \(임의\) SSRC 값 48과 E1 및 E2 패킷의 SSRC 식별자에서 복사된 두 개의 CSRC 식별자 1과 17로 식별되는 믹서 M1에서 발생하는 패킷을 나타냅니다. .

---
## **7.2 RTCP Processing in Translators**

수정된 데이터 패킷을 전달하는 것 외에도 변환기와 믹서는 RTCP 패킷도 처리해야 합니다. 대부분의 경우 최종 시스템에서 수신된 복합 RTCP 패킷을 분리하여\(MUST\)

SDES 정보를 집계하고 SR 또는 RR 패킷을 수정합니다. 이 정보의 재전송은 패킷 도착이나 변환기나 믹서 자체의 RTCP 간격 타이머에 의해 트리거될 수 있습니다.

데이터 패킷을 수정하지 않는 변환기\(예: 멀티캐스트 주소와 유니캐스트 주소 사이만 복제하는 변환기\)도 수정되지 않은 RTCP 패킷을 단순히 전달할 수 있습니다. 어떤 방식으로든 페이로드를 변환하는 변환기는 데이터의 특성과 수신 품질을 반영하도록 SR 및 RR 정보에서 해당 변환을 수행해야 합니다. 이러한 변환기는 단순히 RTCP 패킷을 전달해서는 안 됩니다. 일반적으로 변환기는 LSR 및 DLSR 필드를 기반으로 하는 전파 지연 측정의 정확도를 감소시키기 때문에 서로 다른 소스의 SR 및 RR 패킷을 하나의 패킷으로 집계해서는 안 됩니다.\(MAY, MUST, MUST NOT, SHOULD NOT\)

SR 송신자 정보: 변환기는 자체 송신자 정보를 생성하지 않고, 한 클라우드에서 수신된 SR 패킷을 다른 클라우드로 전달합니다. SSRC는 그대로 유지되지만 번역에 필요한 경우 보낸 사람 정보를 수정해야 합니다. 변환기가 데이터 인코딩을 변경하는 경우 "발신자의 바이트 수" 필드를 변경해야 합니다. 여러 데이터 패킷을 하나의 출력 패킷으로 결합하는 경우 "발신자의 패킷 수" 필드를 변경해야 합니다. 타임스탬프 빈도를 변경하는 경우 SR 패킷의 "RTP 타임스탬프" 필드를 변경해야 합니다.\(MUST, MUST, MUST, MUST\)

SR/RR 수신 보고서 블록: 변환기는 한 클라우드에서 수신된 수신 보고서를 다른 클라우드로 전달합니다. 이는 데이터의 반대 방향으로 흐른다는 점에 유의하세요. SSRC는 그대로 유지됩니다. 변환기가 여러 데이터 패킷을 하나의 출력 패킷으로 결합하여 시퀀스 번호를 변경하는 경우 패킷 손실 필드와 "확장된 마지막 시퀀스 번호" 필드에 대한 역 조작을 수행해야 합니다. 이는 복잡할 수 있습니다. 극단적인 경우 수신 보고서를 번역하는 의미 있는 방법이 없을 수 있으므로 번역자는 수신 보고서를 전혀 전달하지 않거나 자체 수신을 기반으로 종합 보고서를 전달할 수도 있습니다. 일반적인 규칙은 특정 번역에 적합한 작업을 수행하는 것입니다.\(MUST, MAY\)

- 번역가는 자신의 SSRC 식별자를 요구하지 않지만 수신한 내용에 대한 보고서를 보낼 목적으로 하나를 할당하도록 선택할 수 있습니다. 수신 보고서는 일반적으로 모든 참가자에게 멀티캐스트되므로 이는 연결된 모든 클라우드로 전송되며, 각각은 해당 클라우드로 전송된 데이터 스트림의 변환에 해당합니다.\(MAY\)

SDES: 번역자는 일반적으로 SDES를 변경하지 않고 전달합니다.

- 한 클라우드에서 다른 클라우드로 정보를 수신하지만 예를 들어 대역폭이 제한되는 경우 CNAME SDES가 아닌 정보를 필터링하도록 결정할 수 있습니다. SSRC 식별자 충돌 감지가 작동하려면 CNAME을 전달해야 합니다. 자체 RR 패킷을 생성하는 변환기는 해당 RR 패킷을 보내는 동일한 클라우드에 자신에 대한 SDES CNAME 정보를 보내야 합니다.\(MAY, MUST, MUST\)

BYE: 변환기는 BYE 패킷을 변경 없이 전달합니다. 패킷 전달을 중단하려는 변환기는 자체 보고서를 보낸 경우 변환기의 자체 SSRC 식별자를 포함하여 이전에 해당 클라우드로 전달되었던 모든 SSRC 식별자를 포함하는 연결된 각 클라우드에 BYE 패킷을 보내야 합니다.\(SHOULD\)

```text
   APP:  Translators forward APP packets unchanged.
```

---
## **7.3 RTCP Processing in Mixers**

믹서는 자체적으로 새로운 데이터 스트림을 생성하므로 SR 또는 RR 패킷을 전혀 통과하지 않고 대신 양쪽에 대한 새로운 정보를 생성합니다.

SR 송신자 정보: 믹서는 송신자를 통과하지 않습니다.

- 소스 스트림의 특성이 믹스에서 손실되기 때문에 믹스되는 소스의 정보입니다. 동기화 소스로서 믹서는 혼합 데이터 스트림에 대한 발신자 정보가 포함된 자체 SR 패킷을 생성하고 이를 혼합 스트림과 동일한 방향으로 전송해야 합니다\(SHOULD\).\(SHOULD\)

SR/RR 수신 보고 블록: 믹서가 자체적으로 생성합니다.

- 각 클라우드의 소스에 대한 수신 보고서를 작성하여 동일한 클라우드로만 보냅니다. 이러한 수신 보고서를 다른 클라우드로 보내면 안 되며, 소스가 SSRC가 아니기 때문에\(CSRC만\) 한 클라우드에서 다른 클라우드로 수신 보고서를 전달해서는 안 됩니다.\(MUST NOT\)

SDES: 믹서는 일반적으로 SDES를 변경하지 않고 전달합니다.

- 한 클라우드에서 다른 클라우드로 정보를 수신하지만 예를 들어 대역폭이 제한되는 경우 CNAME SDES가 아닌 정보를 필터링하도록 결정할 수 있습니다. SSRC 식별자 충돌 감지가 작동하려면 CNAME을 전달해야 합니다. \(믹서에 의해 생성된 CSRC 목록의 식별자는 최종 시스템에 의해 생성된 SSRC 식별자와 충돌할 수 있습니다.\) 믹서는 SR 또는 RR 패킷을 보내는 동일한 클라우드에 자신에 대한 SDES CNAME 정보를 보내야 합니다.\(MAY, MUST, MUST\)

- 믹서는 SR 또는 RR 패킷을 전달하지 않으므로 일반적으로 복합 RTCP 패킷에서 SDES 패킷을 추출합니다. 오버헤드를 최소화하기 위해 SDES 패킷의 청크는 단일 SDES 패킷으로 집계된 다음 믹서에서 발생하는 SR 또는 RR 패킷에 쌓일 수 있습니다. SDES 패킷을 집계하는 믹서는 복합 패킷이 더 길기 때문에 개별 소스보다 더 많은 RTCP 대역폭을 사용하지만 믹서가 여러 소스를 나타내기 때문에 이는 적절합니다. 마찬가지로, 수신된 SDES 패킷을 통과하는 믹서는 단일 소스 속도보다 높은 속도로 RTCP 패킷을 전송하지만 패킷이 여러 소스에서 오기 때문에 이는 올바른 것입니다. RTCP 패킷 속도는 믹서의 양쪽에서 다를 수 있습니다.\(MAY\)

- CSRC 식별자를 삽입하지 않는 믹서는 SDES CNAME 전달을 삼가할 수도 있습니다. 이 경우 두 클라우드의 SSRC 식별자 공간은 독립적입니다. 앞서 언급했듯이 이 작동 모드에서는 루프를 감지할 수 없는 위험이 발생합니다.\(MAY\)

BYE: 믹서는 BYE 패킷을 전달해야 합니다. 패킷 전달을 중단하려는 믹서는 자체 보고서를 보낸 경우 믹서의 자체 SSRC 식별자를 포함하여 이전에 해당 클라우드로 전달되었던 모든 SSRC 식별자를 포함하는 연결된 각 클라우드에 BYE 패킷을 보내야 합니다.\(MUST, SHOULD\)

APP: 믹서에 의한 APP 패킷 처리는 애플리케이션별로 다릅니다.

---
## **7.4 Cascaded Mixers**

RTP 세션에는 그림 3에 표시된 대로 믹서 및 변환기 모음이 포함될 수 있습니다. 그림의 M2 및 M3와 같이 두 개의 믹서가 계단식으로 연결된 경우 믹서에 의해 수신된 패킷은 이미 혼합되었을 수 있으며 다음과 같은 CSRC 목록을 포함할 수 있습니다. 여러 식별자. 두 번째 믹서는 이미 혼합된 입력 패킷의 CSRC 식별자와 혼합되지 않은 입력 패킷의 SSRC 식별자를 사용하여 발신 패킷에 대한 CSRC 목록을 구축해야 합니다\(SHOULD\). 이는 그림에서 M3:89\(64,45\)로 표시된 믹서 M3의 출력 아크에 표시됩니다. 계단식으로 연결되지 않은 믹서의 경우와 마찬가지로 결과 CSRC 목록에 15개 이상의 식별자가 있으면 나머지는 포함될 수 없습니다.\(SHOULD\)

---
## **8.  SSRC Identifier Allocation and Use**

RTP 헤더와 RTCP 패킷의 다양한 필드에 전달되는 SSRC 식별자는 RTP 세션 내에서 전역적으로 고유해야 하는 임의의 32비트 숫자입니다. 동일한 네트워크에 있거나 동시에 시작하는 참가자가 동일한 번호를 선택할 가능성이 없도록 번호를 신중하게 선택하는 것이 중요합니다.

주소가 고유하지 않을 수 있으므로 식별자로 로컬 네트워크 주소\(예: IPv4 주소\)를 사용하는 것만으로는 충분하지 않습니다. RTP 변환기와 혼합기는 서로 다른 주소 공간을 가진 여러 네트워크 간의 상호 운용을 가능하게 하기 때문에 두 공간 내의 주소에 대한 할당 패턴은 무작위 할당에서 발생하는 것보다 훨씬 더 높은 충돌 비율을 초래할 수 있습니다.

하나의 호스트에서 실행되는 여러 소스도 충돌할 수 있습니다.

또한 상태를 신중하게 초기화하지 않고 단순히 Random\(\)을 호출하여 SSRC 식별자를 얻는 것만으로는 충분하지 않습니다. 무작위 식별자를 생성하는 방법의 예는 부록 A.6에 나와 있습니다.

---
## **8.1 Probability of Collision**

식별자는 무작위로 선택되므로 둘 이상의 소스가 동일한 번호를 선택할 가능성이 있습니다. 예를 들어 일부 세션 관리 이벤트에 의해 자동으로 트리거되는 경우와 같이 모든 소스가 동시에 시작될 때 충돌이 가장 높은 확률로 발생합니다. N이 소스의 수이고 L이 식별자의 길이\(여기서는 32비트\)인 경우 두 소스가 독립적으로 동일한 값을 선택할 확률은 큰 N \[26\]에 대해 1 - exp\(-N\*\*2\)로 근사화될 수 있습니다. / 2\*\*\(L+1\)\). N=1000의 경우 확률은 대략 10\*\*-4입니다.

일반적인 충돌 확률은 위의 최악의 경우보다 훨씬 낮습니다. 하나의 새로운 소스가 다른 모든 소스에 이미 고유 식별자가 있는 RTP 세션에 참가하면 충돌 가능성은 공간에서 사용되는 숫자의 일부일 뿐입니다. 다시 말하면, N이 소스의 개수이고 L이 식별자의 길이라면 충돌 확률은 N/2\*\*L입니다. N=1000의 경우 확률은 대략 2\*10\*\*-7입니다.

새로운 소스가 첫 번째 패킷\(데이터 또는 제어\)을 보내기 전에 다른 참가자로부터 패킷을 수신할 수 있으므로 충돌 가능성이 더욱 줄어듭니다. 새 소스가 \(SSRC 식별자를 통해\) 다른 참가자를 추적하는 경우

첫 번째 패킷을 전송하기 전에 새로운 소스는 해당 식별자가 수신된 것과 충돌하지 않는지 확인하거나 다시 선택할 수 있습니다.

---
## **8.2 Collision Resolution and Loop Detection**

SSRC 식별자 충돌 가능성은 낮지만 모든 RTP 구현은 충돌을 감지하고 이를 해결하기 위한 적절한 조치를 취하도록 준비되어야 합니다. 소스가 언제든지 다른 소스가 자신과 동일한 SSRC 식별자를 사용하고 있음을 발견하면 이전 식별자에 대해 RTCP BYE 패킷을 보내고 다른 임의의 식별자를 선택해야 합니다. \(아래에 설명된 대로 이 단계는 루프의 경우 한 번만 수행됩니다.\) 수신기가 두 개의 다른 소스가 충돌하고 있음을 발견하면 다른 소스에서 이를 감지할 수 있는 경우 하나의 패킷을 유지하고 다른 소스의 패킷을 삭제할 수 있습니다. 소스 전송 주소 또는 CNAME. 두 소스는 사태가 지속되지 않도록 충돌을 해소할 것으로 예상된다.\(MUST, MUST, MAY\)

무작위 SSRC 식별자는 각 RTP 세션에 대해 전역적으로 고유하게 유지되므로 믹서나 변환기에 의해 발생할 수 있는 루프를 감지하는 데에도 사용할 수 있습니다. 루프는 다음 예와 같이 수정되지 않거나 혼합될 수 있는 데이터 및 제어 정보의 중복을 발생시킵니다.

o 번역자가 패킷을 동일한 대상으로 잘못 전달할 수 있습니다.

- 직접 또는 변환기 체인을 통해 패킷을 수신한 멀티캐스트 그룹입니다. 이 경우 동일한 패킷이 여러 번 나타나며 다른 네트워크 소스에서 시작됩니다.

o 병렬로 잘못 설정된 두 개의 변환기, 즉 양쪽에 동일한 멀티캐스트 그룹이 있으면 둘 다 한 멀티캐스트 그룹에서 다른 멀티캐스트 그룹으로 패킷을 전달합니다. 단방향 번역자는 두 개의 사본을 생성합니다. 양방향 변환기는 루프를 형성합니다.

o 믹서는 동일한 전송으로 전송하여 루프를 닫을 수 있습니다.

- 직접적으로 또는 다른 믹서나 변환기를 통해 패킷을 수신하는 대상입니다. 이 경우 소스는 데이터 패킷의 SSRC와 혼합 데이터 패킷의 CSRC로 모두 표시될 수 있습니다.

소스는 자신의 패킷이 루핑되고 있거나 다른 소스의 패킷이 루핑되고 있음\(타사 루프\)을 발견할 수 있습니다. 소스 식별자의 무작위 선택에서 루프와 충돌로 인해 패킷은 동일한 SSRC 식별자로 도착하지만 소스 전송 주소는 달라집니다. 이는 패킷을 발생시킨 최종 시스템이나 중간 시스템의 주소일 수 있습니다.

따라서 소스가 소스 전송 주소를 변경하는 경우 루프 소스로 해석되는 것을 피하기 위해 새로운 SSRC 식별자를 선택할 수도 있습니다. \(일부 RTP 애플리케이션에서는 세션 중에 주소가 변경될 것으로 예상될 수 있으므로 이는 반드시 필요한 것은 아닙니다.\) 변환기가 다시 시작되어 결과적으로 전달하는 소스 전송 주소가 변경되는 경우\(예: UDP 소스 포트 번호 변경\) 참고하세요. 그러면 SSRC 식별자가 원본 소스에 적용되고 변경되지 않기 때문에 모든 패킷이 수신기에 루프된 것으로 나타납니다. 이 문제는 다시 시작하는 동안 소스 전송 주소를 고정하여 피할 수 있지만 어떤 경우에도 수신기에서 시간 초과 후에 해결됩니다.\(MAY, MUST\)

변환기 또는 믹서의 반대쪽에서 발생하는 루프 또는 충돌은 패킷의 모든 복사본이 변환기 또는 믹서를 통과하는 경우 소스 전송 주소를 사용하여 감지할 수 없습니다. 그러나 두 RTCP SDES 패킷의 청크에 다음이 포함된 경우 충돌은 여전히 ​​감지될 수 있습니다. SSRC 식별자는 동일하지만 CNAME은 다릅니다.

이러한 충돌을 감지하고 해결하려면 RTP 구현에 아래 설명된 것과 유사한 알고리즘이 포함되어야 합니다. 하지만 구현에서는 충돌하는 타사 소스의 패킷을 보관하는 다른 정책을 선택할 수 있습니다. 아래에 설명된 알고리즘은 설정된 소스와 충돌하는 새로운 소스 또는 루프의 패킷을 무시합니다. 이전 식별자에 대해 RTCP BYE를 보내고 새 식별자를 선택하여 참가자 자신의 SSRC 식별자와의 충돌을 해결합니다. 그러나 참가자 자신의 패킷 루프로 인해 충돌이 발생한 경우 알고리즘은 새 식별자를 한 번만 선택한 다음 루프 소스 전송 주소의 패킷을 무시합니다. 이는 BYE 패킷의 홍수를 방지하는 데 필요합니다.\(MUST\)

이 알고리즘을 사용하려면 소스 식별자로 인덱싱된 테이블을 유지해야 하며 해당 소스에 대한 다른 상태와 함께 해당 식별자로 수신된 첫 번째 RTP 패킷과 첫 번째 RTCP 패킷의 소스 전송 주소를 포함해야 합니다. 예를 들어 UDP 소스 포트 번호가 RTP 및 RTCP 패킷에서 다를 수 있으므로 두 개의 소스 전송 주소가 필요합니다. 그러나 두 소스 전송 주소 모두에서 네트워크 주소가 동일하다고 가정할 수 있습니다.

RTP 또는 RTCP 패킷으로 수신된 각 SSRC 또는 CSRC 식별자는 해당 데이터 또는 제어 정보를 처리하기 위해 소스 식별자 테이블에서 조회됩니다. 패킷의 소스 전송 주소는 테이블의 해당 소스 전송 주소와 비교되어 일치하지 않는 경우 루프 또는 충돌을 감지합니다. 제어 패킷의 경우 자체 SSRC 식별자가 있는 각 요소\(예: SDES 청크\)에는 별도의 조회가 필요합니다. \(수신 보고 블록의 SSRC 식별자는 예외입니다.

보고자가 듣는 소스를 식별하며 SSRC 식별자는 보고자가 보낸 RTCP 패킷의 소스 전송 주소와 관련이 없습니다.\) SSRC 또는 CSRC를 찾을 수 없으면 새 항목이 생성됩니다. 이러한 테이블 항목은 해당 SSRC 식별자와 함께 RTCP BYE 패킷이 수신되고 일치하는 소스 전송 주소에 의해 유효성이 검사되거나 상대적으로 오랜 시간 동안 패킷이 도착하지 않은 후에 제거됩니다\(섹션 6.2.1 참조\).

수신기가 작업을 시작할 때 동일한 호스트의 두 소스가 동일한 소스 식별자로 전송하는 경우 수신된 첫 번째 RTP 패킷은 소스 중 하나에서 온 반면 수신된 첫 번째 RTCP 패킷은 다른 소스에서 왔을 수 있습니다. . 이로 인해 잘못된 RTCP 정보가 RTP 데이터와 연결될 수 있지만 이러한 상황은 무시할 수 있을 만큼 매우 드물고 무해해야 합니다.

참가자 자신의 데이터 패킷의 루프를 추적하기 위해 구현에서는 충돌하는 것으로 밝혀진 소스 전송 주소\(식별자가 아님\)의 별도 목록도 유지해야 합니다. 소스 식별자 테이블에서와 같이 충돌하는 RTP 및 RTCP 패킷을 별도로 추적하려면 두 개의 소스 전송 주소를 유지해야 합니다. 충돌하는 주소 목록은 짧아야 하며 일반적으로 비어 있어야 합니다. 이 목록의 각 요소에는 소스 주소와 가장 최근에 충돌하는 패킷이 수신된 시간이 저장됩니다. 10 RTCP 보고 간격 동안 해당 소스로부터 충돌하는 패킷이 도착하지 않으면 목록에서 요소가 제거될 수 있습니다\(섹션 6.2 참조\).\(MUST, MUST, MAY\)

표시된 알고리즘의 경우 소스 식별자 테이블에는 참가자 자신의 소스 식별자와 상태가 포함되어 있다고 가정합니다. 참가자 자신의 소스 식별자에 대해 먼저 별도의 비교를 수행하도록 알고리즘을 재구성할 수 있습니다.

```text
      if (SSRC or CSRC identifier is not found in the source
          identifier table) {
          create a new entry storing the data or control source
              transport address, the SSRC or CSRC and other state;
      }

      /* Identifier is found in the table */

      else if (table entry was created on receipt of a control packet
               and this is the first data packet or vice versa) {
          store the source transport address from this packet;
      }
      else if (source transport address from the packet does not match
               the one saved in the table entry for this identifier) {

          /* An identifier collision or a loop is indicated */

          if (source identifier is not the participant's own) {
              /* OPTIONAL error counter step */
              if (source identifier is from an RTCP SDES chunk
                  containing a CNAME item that differs from the CNAME
                  in the table entry) {
                  count a third-party collision;
              } else {
                  count a third-party loop;
              }
              abort processing of data packet or control element;
              /* MAY choose a different policy to keep new source */
          }

          /* A collision or loop of the participant's own packets */

          else if (source transport address is found in the list of
                   conflicting data or control source transport
                   addresses) {
              /* OPTIONAL error counter step */
              if (source identifier is not from an RTCP SDES chunk
                  containing a CNAME item or CNAME is the
                  participant's own) {
                  count occurrence of own traffic looped;
              }
              mark current time in conflicting address list entry;
              abort processing of data packet or control element;
          }

          /* New collision, change SSRC identifier */

          else {
              log occurrence of a collision;
              create a new entry in the conflicting data or control
                  source transport address list and mark current time;
              send an RTCP BYE packet with the old SSRC identifier;
              choose a new SSRC identifier;
              create a new entry in the source identifier table with
                  the old SSRC plus the source transport address from
                  the data or control packet being processed;
          }
      }
```

이 알고리즘에서는 새로 충돌하는 소스 주소의 패킷이 무시되고 원래 소스 주소의 패킷이 유지됩니다. 오랜 기간 동안 원래 소스에서 패킷이 도착하지 않으면 테이블 항목이 시간 초과되고 새 소스가 삭제됩니다.

인수할 수 있습니다. 이는 원래 소스가 충돌을 감지하고 새 소스 식별자로 이동하는 경우 발생할 수 있지만 일반적인 경우 RTCP BYE 패킷이 원래 소스에서 수신되어 시간 초과를 기다리지 않고 상태를 삭제합니다.

원래 소스 주소가 믹서를 통해 수신되고\(예: CSRC로 학습됨\) 나중에 동일한 소스가 직접 수신되는 경우 믹스의 다른 소스가 손실되지 않는 한 수신기는 새 소스 주소로 전환하는 것이 좋습니다. 또한 모바일 엔터티와 같은 일부 소스가 RTP 세션 중에 주소를 변경할 수 있는 전화 통신과 같은 애플리케이션의 경우 RTP 구현은 충돌 감지 알고리즘을 수정하여 새로운 소스 전송 주소의 패킷을 수락해야 합니다. 실제 충돌이 발생하는 경우 주소 간의 플립플롭을 방지하기 위해 알고리즘은 이 경우를 감지하고 전환을 방지하는 몇 가지 수단을 포함해야 합니다.\(SHOULD, SHOULD\)

충돌로 인해 새로운 SSRC 식별자가 선택되면 후보 식별자를 먼저 소스 식별자 테이블에서 조회하여 다른 소스에서 이미 사용 중인지 확인해야 합니다. 그렇다면 다른 후보를 생성하고 프로세스를 반복해야 합니다.\(SHOULD, MUST\)

멀티캐스트 대상으로의 데이터 패킷 루프로 인해 심각한 네트워크 플러딩이 발생할 수 있습니다. 모든 믹서와 변환기는 루프를 끊을 수 있도록 여기에 나와 있는 것과 같은 루프 감지 알고리즘을 구현해야 합니다. 이렇게 하면 초과 트래픽이 원본 트래픽의 중복 복사본 1개 이하로 제한되어 루프의 원인을 찾아 수정할 수 있도록 세션이 계속될 수 있습니다. 그러나 믹서나 변환기가 루프를 적절하게 중단하지 못하고 트래픽 수준이 높아지는 극단적인 경우에는 최종 시스템이 데이터 전송을 중단하거나 패킷을 완전히 제어해야 할 수도 있습니다. 이 결정은 애플리케이션에 따라 달라질 수 있습니다. 오류 조건은 적절하게 표시되어야 합니다. 전송은 길고 무작위적인 시간\(분 단위\) 후에 주기적으로 다시 시도될 수 있습니다.\(MUST, SHOULD, MAY\)

---
## **8.3 Use with Layered Encodings**

별도의 RTP 세션에서 전송되는 계층화된 인코딩의 경우\(섹션 2.4 참조\) 모든 계층의 세션에서 단일 SSRC 식별자 공간을 사용해야 하며 SSRC 식별자 할당 및 충돌 해결을 위해 코어\(기본\) 계층을 사용해야 합니다. 소스가 충돌했음을 발견하면 기본 계층에서만 RTCP BYE 패킷을 전송하지만 모든 계층에서 SSRC 식별자를 새로운 값으로 변경합니다.\(SHOULD\)

---
## **9. Security**

하위 계층 프로토콜은 결국 인증, 무결성 및 기밀성을 포함하여 RTP 애플리케이션에 필요할 수 있는 모든 보안 서비스를 제공할 수 있습니다. 이러한 서비스는 \[27\]에서 IP에 대해 지정되었습니다. RTP를 사용하는 초기 오디오 및 비디오 애플리케이션에는 IP 계층에서 이러한 서비스를 사용할 수 있기 전에 기밀성 서비스가 필요했기 때문에 다음 섹션에서 설명하는 기밀성 서비스는 RTP 및 RTCP와 함께 사용하도록 정의되었습니다. 해당 설명은 기존 관행을 체계화하기 위해 여기에 포함되었습니다. RTP의 새로운 애플리케이션은 이전 버전과의 호환성을 위해 이 RTP 관련 기밀 서비스를 구현할 수 있으며/또는 대체 보안 서비스를 구현할 수도 있습니다. 이 기밀성 서비스에 대한 RTP 프로토콜의 오버헤드는 낮으므로 나중에 이 서비스가 다른 서비스에 의해 폐기되는 경우 페널티가 최소화됩니다.\(MAY\)

대안으로, 다른 서비스, 다른 서비스 구현 및 다른 알고리즘이 향후 RTP에 대해 정의될 수 있습니다. 특히, 링크 수준 헤더 압축 알고리즘이 계속 작동할 수 있도록 RTP 헤더를 명확하게 유지하면서 RTP 페이로드의 기밀성을 제공하기 위해 SRTP\(Secure Real-time Transport Protocol\)\[28\]라는 RTP 프로파일이 개발되고 있습니다. SRTP는 많은 애플리케이션에 적합한 선택이 될 것으로 예상됩니다. SRTP는 AES\(Advanced Encryption Standard\)를 기반으로 하며 여기에 설명된 서비스보다 더 강력한 보안을 제공합니다. 여기에 제시된 방법이 특정 보안 요구에 적합하다는 주장은 없습니다. 프로필은 애플리케이션이 제공해야 하는 서비스와 알고리즘을 지정하고 적절한 사용에 대한 지침을 제공할 수 있습니다.

키 배포 및 인증서는 이 문서의 범위를 벗어납니다.

---
## **9.1 Confidentiality**

기밀성은 의도된 수신자만이 수신된 패킷을 디코딩할 수 있음을 의미합니다. 다른 경우에는 패킷에 유용한 정보가 포함되어 있지 않습니다. 콘텐츠의 기밀성은 암호화를 통해 달성됩니다.

이 섹션에 지정된 방법에 따라 RTP 또는 RTCP를 암호화하려는 경우 단일 하위 계층 패킷의 전송을 위해 캡슐화되는 모든 옥텟이 하나의 단위로 암호화됩니다. RTCP의 경우 각 장치에 대해 다시 그려진 32비트 난수를 암호화하기 전에 장치 앞에 추가해야 합니다. RTP의 경우 접두사가 추가되지 않습니다. 대신, 시퀀스 번호와 타임스탬프 필드는 임의의 오프셋으로 초기화됩니다. 이는 약한 것으로 간주됩니다.\(MUST\)

무작위성 속성이 좋지 않기 때문에 초기화 벡터\(IV\)입니다. 또한, 후속 필드인 SSRC가 적에 의해 조작될 수 있는 경우 암호화 방식의 취약점은 더욱 존재한다.

RTCP의 경우 구현에서는 복합 RTCP 패킷의 개별 RTCP 패킷을 두 개의 별도 복합 RTCP 패킷\(하나는 암호화되고 다른 하나는 일반 전송됨\)으로 분리할 수 있습니다. 예를 들어, 암호화 키에 접근할 수 없는 타사 모니터를 수용하기 위해 수신 보고서가 암호화되지 않은 상태로 전송되는 동안 SDES 정보가 암호화될 수 있습니다. 그림 4에 설명된 이 예에서는 모든 복합 RTCP 패킷이 SR 또는 RR 패킷으로 시작한다는 요구 사항을 충족하기 위해 보고\(및 난수\)가 없는 RR 패킷에 SDES 정보를 추가해야 합니다. SDES CNAME 항목은 암호화된 패킷이나 암호화되지 않은 패킷에 필요하지만 둘 다에는 필요하지 않습니다. 동일한 SDES 정보는 암호화를 손상시킬 수 있으므로 두 패킷 모두에 전달되어서는 안 됩니다.\(MAY, MUST, SHOULD NOT\)

```text
             UDP packet                     UDP packet
   -----------------------------  ------------------------------
   [random][RR][SDES #CNAME ...]  [SR #senderinfo #site1 #site2]
   -----------------------------  ------------------------------
             encrypted                     not encrypted
```

```text
   #: SSRC identifier

       Figure 4: Encrypted and non-encrypted RTCP packets
```

암호화 여부와 올바른 키 사용 여부는 수신자가 헤더 또는 페이로드 유효성 검사를 통해 확인합니다. RTP 및 RTCP 헤더에 대한 유효성 검사의 예는 부록 A.1 및 A.2에 나와 있습니다.

RFC 1889의 RTP 초기 사양에 대한 기존 구현과 일관성을 유지하기 위해 기본 암호화 알고리즘은 RFC 1423 \[29\]의 섹션 1.1에 설명된 대로 CBC\(암호 블록 체인\) 모드의 DES\(데이터 암호화 표준\) 알고리즘입니다. 단, 8옥텟의 배수에 대한 패딩은 섹션 5.1의 P 비트에 대해 설명된 대로 표시됩니다. RTP 헤더에 또는 복합 RTCP 패킷의 무작위 접두사에 의해 무작위 값이 제공되기 때문에 초기화 벡터는 0입니다. CBC 초기화 벡터 사용에 대한 자세한 내용은 \[30\]을 참조하세요.

여기에 지정된 암호화 방법을 지원하는 구현은 상호 운용성을 최대화하기 위해 항상 CBC 모드에서 DES 알고리즘을 이 방법의 기본 암호로 지원해야 합니다. 이 방법을 선택한 이유는 인터넷에서 작동 중인 실험적인 오디오 및 비디오 도구에 사용하는 것이 쉽고 실용적이라는 것이 입증되었기 때문입니다. 그러나 DES는 이후 너무 쉽게 깨지는 것으로 밝혀졌습니다.\(SHOULD\)

기본 알고리즘 대신 Triple-DES와 같은 더 강력한 암호화 알고리즘을 사용하는 것이 좋습니다. 또한 보안 CBC 모드에서는 각 패킷의 첫 번째 블록이 암호의 블록 크기와 동일한 크기의 무작위 독립 IV와 XOR되어야 합니다. RTCP의 경우 이는 각 패킷에 대해 독립적으로 선택된 32비트 난수를 각 패킷 앞에 추가하여 \(부분적으로\) 달성됩니다. RTP의 경우 타임스탬프와 시퀀스 번호는 임의의 값에서 시작하지만 연속된 패킷은 독립적으로 무작위화되지 않습니다. 두 경우 모두\(RTP와 RTCP\) 무작위성이 제한된다는 점에 유의해야 합니다. 높은 보안 애플리케이션은 보다 일반적인 다른 보호 수단을 고려해야 합니다. 다른 암호화 알고리즘은 RTP가 아닌 수단으로 세션에 대해 동적으로 지정될 수 있습니다. 특히, AES 기반의 SRTP 프로파일\[28\]은 알려진 일반 텍스트 및 CBC 일반 텍스트 조작 문제를 고려하여 개발 중이며 향후 올바른 선택이 될 것입니다.\(SHOULD, SHOULD, MAY\)

위에서 설명한 대로 IP 수준 또는 RTP 수준의 암호화 대신 프로필은 암호화된 인코딩에 대한 추가 페이로드 유형을 정의할 수 있습니다. 이러한 인코딩은 패딩 및 암호화의 기타 측면을 처리하는 방법을 지정해야 합니다. 이 방법을 사용하면 원하는 애플리케이션의 헤더를 그대로 두고 데이터만 암호화할 수 있습니다. 이는 암호 해독과 디코딩을 모두 처리하는 하드웨어 장치에 특히 유용할 수 있습니다. 또한 RTP 및 하위 계층 헤더의 링크 수준 압축이 필요하고 헤더 암호화로 압축이 불가능하므로 페이로드\(주소는 아님\)의 기밀성이 충분한 애플리케이션에도 유용합니다.\(MAY, MUST\)

---
## **9.2 Authentication and Message Integrity**

인증 및 메시지 무결성 서비스는 RTP 수준에서 정의되지 않습니다. 이러한 서비스는 키 관리 인프라 없이는 직접적으로 실현 가능하지 않기 때문입니다. 인증 및 무결성 서비스는 하위 계층 프로토콜을 통해 제공될 것으로 예상됩니다.

---
## **10. Congestion Control**

인터넷에서 사용되는 모든 전송 프로토콜은 어떤 방식으로든 혼잡 제어를 처리해야 합니다\[31\]. RTP도 예외는 아니지만 RTP를 통해 전송되는 데이터는 종종 비탄력적\(고정 또는 제어된 속도로 생성됨\)이기 때문에 RTP에서 혼잡을 제어하는 ​​방법은 TCP와 같은 다른 전송 프로토콜의 방법과 상당히 다를 수 있습니다. 어떤 의미에서 RTP 스트림은 TCP 스트림처럼 사용 가능한 모든 대역폭을 소비하도록 확장되지 않기 때문에 비탄력성은 정체 위험을 줄여줍니다. 그러나 비탄력성은 RTP 스트림이 혼잡이 발생할 때 이를 제거하기 위해 네트워크의 부하를 임의로 줄일 수 없음을 의미하기도 합니다.

RTP는 다양한 상황에서 다양한 애플리케이션에 사용될 수 있으므로 모든 용도에 사용할 수 있는 단일 혼잡 제어 메커니즘은 없습니다. 그러므로 혼잡 제어는 각 RTP 프로필에 적절하게 정의되어야 합니다. 일부 프로필의 경우 엔지니어링을 통해 혼잡이 방지되는 환경으로 해당 프로필의 사용을 제한하는 적용 가능성 설명을 포함하는 것으로 충분할 수 있습니다. 다른 프로필의 경우 RTCP 피드백을 기반으로 한 데이터 속도 적응과 같은 특정 방법이 필요할 수 있습니다.\(SHOULD\)

---
## **11. RTP over Network and Transport Protocols**

이 섹션에서는 특정 네트워크 및 전송 프로토콜 내에서 RTP 패킷을 전달하는 것과 관련된 문제를 설명합니다. 이 사양 외부의 프로토콜별 정의로 대체되지 않는 한 다음 규칙이 적용됩니다.

RTP는 기본 프로토콜을 사용하여 RTP 데이터 및 RTCP 제어 스트림의 역다중화를 제공합니다. UDP 및 유사한 프로토콜의 경우 RTP는 짝수 대상 포트 번호를 사용해야 하며 해당 RTCP 스트림은 다음으로 높은\(홀수\) 대상 포트 번호를 사용해야 합니다. 단일 포트 번호를 매개변수로 사용하고 해당 번호에서 RTP 및 RTCP 포트 쌍을 파생시키는 애플리케이션의 경우, 홀수 번호가 제공되면 애플리케이션은 해당 번호를 다음 낮은\(짝수\) 번호로 대체하여 기본으로 사용해야 합니다. 포트 쌍. RTP 및 RTCP 대상 포트 번호가 명시적이고 별도의 매개변수\(신호 프로토콜 또는 기타 수단 사용\)를 통해 지정되는 애플리케이션의 경우, 애플리케이션은 짝수를 사용하더라도 포트 번호가 짝수/홀수 및 연속적이어야 한다는 제한을 무시할 수 있습니다. /odd 포트 쌍은 여전히 ​​권장됩니다. RTP는 포트 번호에 의존하여 RTP 데이터와 RTCP 제어 스트림을 역다중화하므로 RTP와 RTCP 포트 번호는 동일해서는 안 됩니다.\(SHOULD, SHOULD, MAY, MUST NOT\)

유니캐스트 세션에서는 두 참가자 모두 RTP 및 RTCP 패킷을 수신하기 위한 포트 쌍을 식별해야 합니다. 두 참가자 모두 동일한 포트 쌍을 사용할 수 있습니다. 참가자는 들어오는 RTP 또는 RTCP 패킷의 소스 포트가 나가는 RTP 또는 RTCP 패킷의 대상 포트로 사용될 수 있다고 가정해서는 안 됩니다. RTP 데이터 패킷이 양방향으로 전송되는 경우 각 참가자의 RTCP SR 패킷은 다른 참가자가 RTCP 수신을 위해 지정한 포트로 전송되어야 합니다. RTCP SR 패킷은 발신 데이터에 대한 발신자 정보와 수신 데이터에 대한 수신 보고 정보를 결합합니다. 한 쪽이 적극적으로 데이터를 전송하지 않는 경우\(섹션 6.4 참조\) RTCP RR 패킷이 대신 전송됩니다.\(MAY, MUST NOT, MUST\)

계층화된 인코딩 응용 프로그램\(섹션 2.4 참조\)은 일련의 연속 포트 번호를 사용하는 것이 좋습니다. 기존 운영 방식의 광범위한 결함으로 인해 포트 번호는 반드시 구별되어야 합니다.\(SHOULD, MUST\)

다중 멀티캐스트 주소가 있는 동일한 포트의 사용을 방지하는 시스템이며, 유니캐스트의 경우 허용되는 주소는 하나만 있습니다. 따라서 계층 n의 경우 데이터 포트는 P + 2n이고 제어 포트는 P + 2n + 1입니다. IP 멀티캐스트가 사용되는 경우 멀티캐스트 라우팅 및 그룹 멤버십이 주소 세분성에서 관리되므로 주소도 구별되어야 합니다. 그러나 일부 그룹에는 다른 범위가 필요할 수 있고 그에 따라 다른 주소 범위에서 할당될 수 있으므로 연속 IP 멀티캐스트 주소 할당을 가정할 수 없습니다.\(MUST\)

이전 단락은 주소와 포트의 연결이 모호할 수 있으므로 동일한 세션 설명에 여러 주소와 여러 포트를 모두 지정하는 것은 불법이라고 말하는 SDP 사양인 RFC 2327\[15\]과 충돌합니다. 이 제한은 RFC 2327 개정판에서 완화되어 일대일 매핑을 암시하여 동일한 수의 주소와 포트를 지정할 수 있도록 할 예정입니다.

RTP 데이터 패킷에는 길이 필드나 기타 설명이 포함되어 있지 않으므로 RTP는 기본 프로토콜을 사용하여 길이 표시를 제공합니다. RTP 패킷의 최대 길이는 기본 프로토콜에 의해서만 제한됩니다.

RTP 패킷이 메시지\(패킷\)가 아닌 연속 옥텟 스트림의 추상화를 제공하는 기본 프로토콜에서 전달되어야 하는 경우 프레이밍 메커니즘을 제공하기 위해 RTP 패킷의 캡슐화가 정의되어야 합니다. 기본 프로토콜에 패딩이 포함되어 RTP 페이로드의 범위를 확인할 수 없는 경우에도 프레이밍이 필요합니다. 프레이밍 메커니즘은 여기에 정의되어 있지 않습니다.\(MUST\)

프로필은 UDP 패킷과 같은 하나의 하위 계층 프로토콜 데이터 단위에서 여러 RTP 패킷을 전달할 수 있도록 프레이밍을 제공하는 프로토콜에서 RTP가 전달되는 경우에도 사용할 프레이밍 방법을 지정할 수 있습니다. 하나의 네트워크 또는 전송 패킷에서 여러 RTP 패킷을 전달하면 헤더 오버헤드가 줄어들고 서로 다른 스트림 간의 동기화가 단순화될 수 있습니다.\(MAY\)

---
## **12. Summary of Protocol Constants**

이 섹션에는 이 사양에 정의된 상수의 요약 목록이 포함되어 있습니다.

RTP 페이로드 유형\(PT\) 상수는 이 문서가 아닌 프로필에 정의됩니다. 그러나 마커 비트와 페이로드 유형을 포함하는 RTP 헤더의 옥텟은 설명된 헤더 검증 절차에 대해 RTP 패킷을 RTCP SR 및 RR 패킷 유형과 구별하기 위해 예약된 값 200 및 201\(10진수\)을 피해야 합니다.\(MUST\)

부록 A.1에서. 본 사양에 표시된 1개의 마커 비트와 7비트 페이로드 유형 필드의 표준 정의에 대해 이러한 제한은 페이로드 유형 72 및 73이 예약되어 있음을 의미합니다.

---
## **12.1 RTCP Packet Types**

```text
   abbrev.  name                 value
   SR       sender report          200
   RR       receiver report        201
   SDES     source description     202
   BYE      goodbye                203
   APP      application-defined    204
```

이러한 유형 값은 RTP 패킷 또는 기타 관련 없는 패킷과 비교하여 RTCP 패킷의 향상된 헤더 유효성 검사를 위해 200-204 범위에서 선택되었습니다. RTCP 패킷 유형 필드를 RTP 헤더의 해당 옥텟과 비교할 때 이 범위는 마커 비트가 1\(보통 데이터 패킷에 없음\)이고 표준 페이로드 유형 필드의 상위 비트가 1인 것에 해당합니다\( 왜냐하면 정적 페이로드 유형은 일반적으로 하위 절반에 정의되어 있기 때문입니다. 이 범위는 또한 모두 0과 모두 1이 일반적인 데이터 패턴이기 때문에 수치적으로 0과 255 사이의 어느 정도 거리를 두고 선택되었습니다.

모든 복합 RTCP 패킷은 SR 또는 RR로 시작해야 하므로 이러한 코드는 RTCP 유효성 검사가 마스크와 값을 사용하여 최대 비트 수를 테스트할 수 있도록 짝수/홀수 쌍으로 선택되었습니다.\(MUST\)

추가적인 RTCP 패킷 유형은 IANA를 통해 등록될 수 있습니다\(섹션 15 참조\).

---
## **12.2 SDES Types**

```text
   abbrev.  name                            value
   END      end of SDES list                    0
   CNAME    canonical name                      1
   NAME     user name                           2
   EMAIL    user's electronic mail address      3
   PHONE    user's phone number                 4
   LOC      geographic user location            5
   TOOL     name of application or tool         6
   NOTE     notice about the source             7
   PRIV     private extensions                  8
```

추가 SDES 유형은 IANA를 통해 등록할 수 있습니다\(섹션 15 참조\).

---
## **13.  RTP Profiles and Payload Format Specifications**

특정 애플리케이션에 대한 RTP의 전체 사양에는 여기에 설명된 프로필 및 페이로드 형식 사양이라는 두 가지 유형의 동반 문서가 하나 이상 필요합니다.

RTP는 요구 사항이 다소 다른 다양한 애플리케이션에 사용될 수 있습니다. 이러한 요구 사항에 적응할 수 있는 유연성은 기본 프로토콜 사양에서 다중 선택을 허용한 다음 적절한 선택을 선택하거나 별도의 프로필 문서에서 특정 환경 및 응용 프로그램 클래스에 대한 확장을 정의함으로써 제공됩니다. 일반적으로 애플리케이션은 특정 RTP 세션에서 하나의 프로필에서만 작동하므로 RTP 프로토콜 자체에는 어떤 프로필이 사용 중인지에 대한 명시적인 표시가 없습니다. 오디오 및 비디오 애플리케이션에 대한 프로필은 RFC 3551에서 찾을 수 있습니다. 프로필의 제목은 일반적으로 "...에 대한 RTP 프로필"입니다.

두 번째 유형의 동반 문서는 페이로드 형식 사양으로, H.261로 인코딩된 비디오와 같은 특정 종류의 페이로드 데이터가 RTP에서 전달되어야 하는 방식을 정의합니다. 이 문서의 제목은 일반적으로 "XYZ 오디오/비디오 인코딩을 위한 RTP 페이로드 형식"입니다. 페이로드 형식은 여러 프로필에서 유용할 수 있으므로 특정 프로필과 독립적으로 정의될 수 있습니다. 그런 다음 프로필 문서는 필요한 경우 해당 형식의 기본 매핑을 페이로드 유형 값에 할당하는 일을 담당합니다.

이 사양 내에서 프로필 내에서 가능한 정의를 위해 다음 항목이 식별되었지만 이 목록이 완전한 것은 아닙니다.

RTP 데이터 헤더: 마커 비트와 페이로드 유형 필드를 포함하는 RTP 데이터 헤더의 옥텟은 예를 들어 더 많거나 더 적은 마커 비트를 사용하여 다양한 요구 사항에 맞게 프로필에 의해 재정의될 수 있습니다\(섹션 5.3, 18페이지\).\(MAY\)

페이로드 유형: 페이로드 유형 필드가 포함되어 있다고 가정하면 프로필은 일반적으로 페이로드 형식 집합\(예: 미디어 인코딩\)과 해당 형식을 페이로드 유형 값에 대한 기본 정적 매핑을 정의합니다. 일부 페이로드 형식은 별도의 페이로드 형식 사양을 참조하여 정의될 수 있습니다. 정의된 각 페이로드 유형에 대해 프로필은 사용할 RTP 타임스탬프 클럭 속도를 지정해야 합니다\(14페이지의 섹션 5.1\).\(MUST\)

RTP 데이터 헤더 추가: 페이로드 유형과 관계없이 프로필의 애플리케이션 클래스 전체에 일부 추가 기능이 필요한 경우 고정 RTP 데이터 헤더에 추가 필드를 추가할 수 있습니다\(18페이지의 섹션 5.3\).\(MAY\)

RTP 데이터 헤더 확장: RTP 데이터 헤더 확장 구조의 처음 16비트의 내용은 해당 메커니즘의 사용이 구현별 확장에 대한 프로필에서 허용되는 경우 정의되어야 합니다\(18페이지의 섹션 5.3.1\).\(MUST\)

RTCP 패킷 유형: 새로운 애플리케이션 클래스별 RTCP 패킷 유형을 정의하고 IANA에 등록할 수 있습니다.\(MAY\)

RTCP 보고 간격: 프로필은 RTCP 보고 간격 계산에 사용되는 상수에 대해 섹션 6.2에 제안된 값이 사용되도록 지정해야 합니다. 이는 세션 대역폭의 RTCP 비율, 최소 보고 간격, 발신자와 수신자 간의 대역폭 분할입니다. 프로필은 확장 가능한 방식으로 작동하는 것으로 입증된 경우 대체 값을 지정할 수 있습니다.\(SHOULD, MAY\)

SR/RR 확장: 확장 섹션은 다음에 대해 정의될 수 있습니다.

- 발신자 또는 수신자에 대해 정기적으로 보고해야 하는 추가 정보가 있는 경우 RTCP SR 및 RR 패킷\(섹션 6.4.3, p. 42 및 43\).\(MAY\)

SDES 사용: 프로필은 전송되거나 완전히 제외될 RTCP SDES 항목에 대한 상대적 우선순위를 지정할 수 있습니다\(섹션 6.3.9\). CNAME 항목에 대한 대체 구문 또는 의미\(섹션 6.5.1\) LOC 항목의 형식\(6.5.5절\) NOTE 항목의 의미 및 사용\(6.5.7절\) 또는 IANA에 등록할 새로운 SDES 항목 유형.\(MAY\)

보안: 프로필은 어떤 보안 서비스와

- 알고리즘은 애플리케이션에 의해 제공되어야 하며 적절한 사용에 대한 지침을 제공할 수 있습니다\(65페이지 9항\).\(MAY\)

문자열-키 매핑: 프로필은 사용자가 제공한 비밀번호 또는 암호 문구가 암호화 키에 매핑되는 방법을 지정할 수 있습니다.\(MAY\)

혼잡: 프로필은 혼잡 제어를 지정해야 합니다.

- 해당 프로필에 적합한 동작.\(SHOULD\)

기본 프로토콜: RTP 패킷을 전달하기 위해 특정 기본 네트워크 또는 전송 계층 프로토콜을 사용해야 할 수도 있습니다.\(MAY\)

전송 매핑: 섹션 11, p에 정의된 표준 매핑 이외의 UDP 포트와 같은 전송 수준 주소에 대한 RTP 및 RTCP의 매핑입니다. 68을 지정할 수 있습니다.

캡슐화: RTP 패킷의 캡슐화는 여러 RTP 데이터 패킷이 하나의 하위 계층 패킷으로 전달되도록 허용하거나 아직 그렇게 하지 않은 기본 프로토콜을 통해 프레이밍을 제공하도록 정의될 수 있습니다\(69페이지 11항\).

모든 애플리케이션에 새 프로필이 필요할 것으로 예상되지는 않습니다. 하나의 응용 프로그램 클래스 내에서 각 응용 프로그램은 일반적으로 하나의 프로필에서만 실행되므로 응용 프로그램 간의 상호 운용을 용이하게 하기 위해 새 프로필을 만드는 것보다 기존 프로필을 확장하는 것이 더 좋습니다. 추가 페이로드 유형 값 또는 RTCP 패킷 유형의 정의와 같은 간단한 확장은 IANA를 통해 등록하고 해당 설명을 프로필에 대한 부록이나 페이로드 형식 사양에 게시하여 수행할 수 있습니다.

---
## **14. Security Considerations**

RTP는 기본 프로토콜과 동일한 보안 책임을 안고 있습니다. 예를 들어 사기꾼은 소스 또는 대상 네트워크 주소를 위조하거나 헤더 또는 페이로드를 변경할 수 있습니다. RTCP 내에서 CNAME 및 NAME 정보는 다른 참가자를 가장하는 데 사용될 수 있습니다. 또한 RTP는 IP 멀티캐스트를 통해 전송될 수 있는데, 이는 전송자가 전송된 데이터의 모든 수신자를 알 수 있는 직접적인 수단을 제공하지 않으므로 개인 정보 보호를 측정할 수 없습니다. 옳든 아니든 사용자는 전통적인 형태의 네트워크 통신보다 오디오 및 비디오 통신의 개인 정보 보호 문제에 더 민감할 수 있습니다\[33\]. 따라서 RTP와 함께 보안 메커니즘을 사용하는 것이 중요합니다. 이러한 메커니즘은 섹션 9에서 논의됩니다.

RTP 수준 변환기 또는 혼합기를 사용하여 RTP 트래픽이 방화벽 뒤의 호스트에 도달하도록 허용할 수 있습니다. 이 문서의 범위를 벗어나는 적절한 방화벽 보안 원칙 및 관행은 이러한 장치의 설계 및 설치와 방화벽 뒤에서 사용하기 위한 RTP 애플리케이션 승인 시 따라야 합니다.

---
## **15. IANA Considerations**

```text
   Additional RTCP packet types and SDES item types may be registered
   through the Internet Assigned Numbers Authority (IANA).  Since these
   number spaces are small, allowing unconstrained registration of new
   values would not be prudent.  To facilitate review of requests and to
   promote shared use of new types among multiple applications, requests
   for registration of new values must be documented in an RFC or other
   permanent and readily available reference such as the product of
   another cooperative standards body (e.g., ITU-T).  Other requests may
   also be accepted, under the advice of a "designated expert."
```

\(현재 전문가의 연락처 정보는 IANA에 문의하세요.\)

RTP 프로필 사양은 "RTP/xxx" 형식의 프로필 이름을 IANA에 등록해야 합니다. 여기서 xxx는 프로필 제목의 짧은 약어입니다. 이러한 이름은 전송 방법을 참조하기 위해 SDP\(Session Description Protocol\), RFC 2327\[15\]과 같은 상위 수준 제어 프로토콜에서 사용됩니다.\(SHOULD\)

---
## **16. Intellectual Property Rights Statement**

IETF는 이 문서에 설명된 기술의 구현 또는 사용과 관련이 있다고 주장될 수 있는 지적 재산권 또는 기타 권리의 유효성이나 범위 또는 그러한 권리에 따른 라이센스가 적용되거나 적용되지 않을 수 있는 범위에 대해 어떠한 입장도 취하지 않습니다. 사용 가능; 또한 그러한 권리를 확인하기 위해 어떠한 노력도 했다는 뜻도 아닙니다. 표준 트랙 및 표준 관련 문서의 권리와 관련된 IETF 절차에 대한 정보는 BCP-11에서 찾을 수 있습니다. 출판을 위해 제공되는 권리 주장의 사본 및 제공될 라이센스에 대한 보증, 또는 이 사양의 구현자 또는 사용자가 해당 독점 권리의 사용에 대한 일반 라이센스 또는 허가를 얻으려는 시도의 결과를 얻을 수 있습니다. IETF 사무국에서.

IETF는 이 표준을 실행하는 데 필요할 수 있는 기술에 적용될 수 있는 모든 저작권, 특허, 특허 출원 또는 기타 독점권에 관심을 가져오도록 관심 있는 당사자를 초대합니다. 해당 정보를 IETF 전무 이사에게 전달하십시오.

---
## **17.  Acknowledgments**

이 각서는 Stephen Casner와 Colin Perkins가 의장을 맡은 IETF 오디오/비디오 전송 실무 그룹 내 논의를 바탕으로 작성되었습니다. 현재 프로토콜은 네트워크 음성 프로토콜 및 패킷 비디오 프로토콜\(Danny Cohen 및 Randy Cole\)과 vat 애플리케이션\(Van Jacobson 및 Steve McCanne\)에 의해 구현된 프로토콜에서 유래되었습니다. Christian Huitema는 무작위 식별자 생성기에 대한 아이디어를 제공했습니다. 타이머 재검토 알고리즘의 광범위한 분석과 시뮬레이션은 Jonathan Rosenberg가 수행했습니다. 계층화된 인코딩에 대한 추가 사항은 Michael Speer와 Steve McCanne이 지정했습니다.

---
# **Appendix A - Algorithms**

우리는 RTP 발신자 및 수신자 알고리즘 측면에 대한 C 코드의 예를 제공합니다. 특정 운영 환경에서는 더 빠르거나 다른 장점이 있는 다른 구현 방법이 있을 수 있습니다. 이러한 구현 노트는 정보 제공 목적으로만 제공되며 RTP 사양을 명확히 하기 위한 것입니다.

모든 예에는 다음 정의가 사용됩니다. 명확성과 간결성을 위해 구조 정의는 32비트 빅엔디안\(가장 중요한 옥텟 우선\) 아키텍처에만 유효합니다. 비트 필드는 추가 패딩 없이 빅엔디안 비트 순서로 촘촘하게 채워져 있다고 가정합니다. 이식 가능한 구현을 구성하려면 수정이 필요합니다.

```text
   /*
    * rtp.h  --  RTP header file
    */
   #include <sys/types.h>

   /*
    * The type definitions below are valid for 32-bit architectures and
    * may have to be adjusted for 16- or 64-bit architectures.
    */
   typedef unsigned char  u_int8;
   typedef unsigned short u_int16;
   typedef unsigned int   u_int32;
   typedef          short int16;

   /*
    * Current protocol version.
    */
   #define RTP_VERSION    2

   #define RTP_SEQ_MOD (1<<16)
   #define RTP_MAX_SDES 255      /* maximum text length for SDES */

   typedef enum {
       RTCP_SR   = 200,
       RTCP_RR   = 201,
       RTCP_SDES = 202,
       RTCP_BYE  = 203,
       RTCP_APP  = 204
   } rtcp_type_t;

   typedef enum {
       RTCP_SDES_END   = 0,
       RTCP_SDES_CNAME = 1,

       RTCP_SDES_NAME  = 2,
       RTCP_SDES_EMAIL = 3,
       RTCP_SDES_PHONE = 4,
       RTCP_SDES_LOC   = 5,
       RTCP_SDES_TOOL  = 6,
       RTCP_SDES_NOTE  = 7,
       RTCP_SDES_PRIV  = 8
   } rtcp_sdes_type_t;

   /*
    * RTP data header
    */
   typedef struct {
       unsigned int version:2;   /* protocol version */
       unsigned int p:1;         /* padding flag */
       unsigned int x:1;         /* header extension flag */
       unsigned int cc:4;        /* CSRC count */
       unsigned int m:1;         /* marker bit */
       unsigned int pt:7;        /* payload type */
       unsigned int seq:16;      /* sequence number */
       u_int32 ts;               /* timestamp */
       u_int32 ssrc;             /* synchronization source */
       u_int32 csrc[1];          /* optional CSRC list */
   } rtp_hdr_t;

   /*
    * RTCP common header word
    */
   typedef struct {
       unsigned int version:2;   /* protocol version */
       unsigned int p:1;         /* padding flag */
       unsigned int count:5;     /* varies by packet type */
       unsigned int pt:8;        /* RTCP packet type */
       u_int16 length;           /* pkt len in words, w/o this word */
   } rtcp_common_t;

   /*
    * Big-endian mask for version, padding bit and packet type pair
    */
   #define RTCP_VALID_MASK (0xc000 | 0x2000 | 0xfe)
   #define RTCP_VALID_VALUE ((RTP_VERSION << 14) | RTCP_SR)

   /*
    * Reception report block
    */
   typedef struct {
       u_int32 ssrc;             /* data source being reported */
       unsigned int fraction:8;  /* fraction lost since last SR/RR */

       int lost:24;              /* cumul. no. pkts lost (signed!) */
       u_int32 last_seq;         /* extended last seq. no. received */
       u_int32 jitter;           /* interarrival jitter */
       u_int32 lsr;              /* last SR packet from this source */
       u_int32 dlsr;             /* delay since last SR packet */
   } rtcp_rr_t;

   /*
    * SDES item
    */
   typedef struct {
       u_int8 type;              /* type of item (rtcp_sdes_type_t) */
       u_int8 length;            /* length of item (in octets) */
       char data[1];             /* text, not null-terminated */
   } rtcp_sdes_item_t;

   /*
    * One RTCP packet
    */
   typedef struct {
       rtcp_common_t common;     /* common header */
       union {
           /* sender report (SR) */
           struct {
               u_int32 ssrc;     /* sender generating this report */
               u_int32 ntp_sec;  /* NTP timestamp */
               u_int32 ntp_frac;
               u_int32 rtp_ts;   /* RTP timestamp */
               u_int32 psent;    /* packets sent */
               u_int32 osent;    /* octets sent */
               rtcp_rr_t rr[1];  /* variable-length list */
           } sr;

           /* reception report (RR) */
           struct {
               u_int32 ssrc;     /* receiver generating this report */
               rtcp_rr_t rr[1];  /* variable-length list */
           } rr;

           /* source description (SDES) */
           struct rtcp_sdes {
               u_int32 src;      /* first SSRC/CSRC */
               rtcp_sdes_item_t item[1]; /* list of SDES items */
           } sdes;

           /* BYE */
           struct {
               u_int32 src[1];   /* list of sources */

               /* can't express trailing text for reason */
           } bye;
       } r;
   } rtcp_t;

   typedef struct rtcp_sdes rtcp_sdes_t;

   /*
    * Per-source state information
    */
   typedef struct {
       u_int16 max_seq;        /* highest seq. number seen */
       u_int32 cycles;         /* shifted count of seq. number cycles */
       u_int32 base_seq;       /* base seq number */
       u_int32 bad_seq;        /* last 'bad' seq number + 1 */
       u_int32 probation;      /* sequ. packets till source is valid */
       u_int32 received;       /* packets received */
       u_int32 expected_prior; /* packet expected at last interval */
       u_int32 received_prior; /* packet received at last interval */
       u_int32 transit;        /* relative trans time for prev pkt */
       u_int32 jitter;         /* estimated jitter */
       /* ... */
   } source;
```

---
## **A.1 RTP Data Header Validity Checks**

RTP 수신자는 수신 패킷에서 RTP 헤더의 유효성을 확인해야 합니다. 왜냐하면 해당 패킷이 암호화되었을 수 있거나 주소가 잘못 지정된 다른 애플리케이션에서 왔을 수 있기 때문입니다. 마찬가지로, 섹션 9에 설명된 방법에 따른 암호화가 활성화된 경우 헤더 유효성 검사가 실패하더라도\(예: 알 수 없는 페이로드 유형\) 수신 패킷이 올바르게 해독되었는지 확인하기 위해 헤더 유효성 검사가 필요합니다. 암호 해독 실패.

이전에 들어본 적이 없는 소스의 RTP 데이터 패킷에 대해서는 약한 유효성 검사만 가능합니다.

```text
   o  RTP version field must equal 2.
```

o 페이로드 유형을 알아야 하며, 특히 SR 또는 RR과 동일해서는 안 됩니다.

o P 비트가 설정된 경우 패킷의 마지막 옥텟에는 유효한 옥텟 수가 포함되어야 하며, 특히 총 패킷 길이에서 헤더 크기를 뺀 값보다 작아야 합니다.

o 프로필이 헤더 확장 메커니즘을 사용할 수 있도록 지정하지 않은 경우 X 비트는 0이어야 합니다. 그렇지 않은 경우 확장 길이 필드는 전체 패킷 크기에서 고정 헤더 길이와 패딩을 뺀 값보다 작아야 합니다.

o 패킷 길이는 CC 및 페이로드 유형과 일치해야 합니다\(페이로드의 길이가 알려진 경우\).

마지막 세 가지 검사는 다소 복잡하고 항상 가능한 것은 아니며 총 몇 비트에 불과한 처음 두 개만 남깁니다. 패킷의 SSRC 식별자가 이전에 수신된 식별자인 경우 패킷은 유효할 가능성이 높으며 시퀀스 번호가 예상 범위에 있는지 확인하면 추가 유효성 검사가 제공됩니다. SSRC 식별자가 이전에 확인되지 않은 경우 해당 식별자를 전달하는 데이터 패킷 중 소수가 연속 시퀀스 번호와 함께 도착할 때까지 유효하지 않은 것으로 간주될 수 있습니다. 이러한 유효하지 않은 패킷은 폐기되거나 결과 지연이 허용되는 경우 유효성 검사가 달성된 후에 저장 및 전달될 수 있습니다.\(MAY\)

아래 표시된 루틴 update\_seq는 MIN\_SEQUENTIAL 패킷이 순서대로 수신된 후에만 소스가 유효하다고 선언되도록 보장합니다. 또한 새로 수신된 패킷의 시퀀스 번호 seq를 검증하고 s가 가리키는 구조에서 패킷 소스의 시퀀스 상태를 업데이트합니다.

새로운 소스가 처음으로 청취될 때, 즉 SSRC 식별자가 테이블에 없고\(8.2절 참조\) 소스별 상태가 할당되면 s-\>probation이 순차적 개수로 설정됩니다. 유효한 소스\(매개변수 MIN\_SEQUENTIAL\)를 선언하기 전에 필요한 패킷과 기타 변수가 초기화됩니다.

```text
      init_seq(s, seq);
      s->max_seq = seq - 1;
      s->probation = MIN_SEQUENTIAL;
```

0이 아닌 s-\>검증은 소스가 아직 유효하지 않은 것으로 표시하므로 섹션 6.2.1에서 설명한 대로 긴 시간 초과가 아닌 짧은 시간 초과 후에 상태가 폐기될 수 있습니다.

소스가 유효한 것으로 간주된 후 시퀀스 번호가 s-\>max\_seq보다 MAX\_DROPOUT보다 크지 않고 뒤의 MAX\_MISORDER보다 크지 않으면 유효한 것으로 간주됩니다. 새 시퀀스 번호가 RTP 시퀀스 번호 범위\(16비트\)의 모듈로 max\_seq보다 앞에 있지만 max\_seq보다 작은 경우 순환되고 시퀀스 번호 주기의 \(이동된\) 수가 증가합니다. 유효한 시퀀스 번호를 나타내기 위해 값 1이 반환됩니다.

그렇지 않으면 유효성 검사가 실패했음을 나타내기 위해 값 0이 반환되고 잘못된 시퀀스 번호에 1을 더한 값이 저장됩니다. 수신된 다음 패킷이 다음으로 높은 시퀀스 번호를 전달하는 경우 확장된 드롭아웃 또는 소스 재시작으로 인해 발생한 것으로 추정되는 새 패킷 시퀀스의 유효한 시작으로 간주됩니다. 여러 개의 전체 시퀀스 번호 주기가 누락되었을 수 있으므로 패킷 손실 통계가 재설정됩니다.

매개변수의 일반적인 값은 50패킷/초에서 최대 순서 오류 시간 2초와 최대 드롭아웃 1분을 기준으로 표시됩니다. 드롭아웃 매개변수 MAX\_DROPOUT은 재시작 후 새 시퀀스 번호가 재시작 전의 시퀀스 번호에 대해 허용 가능한 범위에 속하지 않을 합리적인 확률을 제공하기 위해 16비트 시퀀스 번호 공간의 작은 부분이어야 합니다.

```text
   void init_seq(source *s, u_int16 seq)
   {
       s->base_seq = seq;
       s->max_seq = seq;
       s->bad_seq = RTP_SEQ_MOD + 1;   /* so seq == bad_seq is false */
       s->cycles = 0;
       s->received = 0;
       s->received_prior = 0;
       s->expected_prior = 0;
       /* other initialization */
   }

   int update_seq(source *s, u_int16 seq)
   {
       u_int16 udelta = seq - s->max_seq;
       const int MAX_DROPOUT = 3000;
       const int MAX_MISORDER = 100;
       const int MIN_SEQUENTIAL = 2;

       /*
        * Source is not valid until MIN_SEQUENTIAL packets with
        * sequential sequence numbers have been received.
        */
       if (s->probation) {
           /* packet is in sequence */
           if (seq == s->max_seq + 1) {
               s->probation--;
               s->max_seq = seq;
               if (s->probation == 0) {
                   init_seq(s, seq);
                   s->received++;
                   return 1;

               }
           } else {
               s->probation = MIN_SEQUENTIAL - 1;
               s->max_seq = seq;
           }
           return 0;
       } else if (udelta < MAX_DROPOUT) {
           /* in order, with permissible gap */
           if (seq < s->max_seq) {
               /*
                * Sequence number wrapped - count another 64K cycle.
                */
               s->cycles += RTP_SEQ_MOD;
           }
           s->max_seq = seq;
       } else if (udelta <= RTP_SEQ_MOD - MAX_MISORDER) {
           /* the sequence number made a very large jump */
           if (seq == s->bad_seq) {
               /*
                * Two sequential packets -- assume that the other side
                * restarted without telling us so just re-sync
                * (i.e., pretend this was the first packet).
                */
               init_seq(s, seq);
           }
           else {
               s->bad_seq = (seq + 1) & (RTP_SEQ_MOD-1);
               return 0;
           }
       } else {
           /* duplicate or reordered packet */
       }
       s->received++;
       return 1;
   }
```

유효성 검사는 두 개 이상의 패킷을 순서대로 요구하여 더욱 강력하게 수행될 수 있습니다. 단점은 더 많은 수의 초기 패킷이 삭제되거나 대기열에서 지연되고 패킷 손실률이 높으면 유효성 검사를 방해할 수 있다는 것입니다. 그러나 RTCP 헤더 유효성 검사가 상대적으로 강력하기 때문에 RTCP 패킷이 데이터 패킷보다 먼저 소스로부터 수신되면 순서대로 두 개의 패킷만 필요하도록 개수를 조정할 수 있습니다. 몇 초 동안 초기 데이터 손실이 허용될 수 있는 경우 애플리케이션은 해당 소스에서 유효한 RTCP 패킷이 수신될 때까지 해당 소스의 모든 데이터 패킷을 삭제하도록 선택할 수 있습니다.\(MAY\)

애플리케이션 및 인코딩에 따라 알고리즘은 추가 검증을 위해 페이로드 형식에 대한 추가 지식을 활용할 수 있습니다. 타임스탬프 증분이 모든 패킷에 대해 동일한 페이로드 유형의 경우 시퀀스 번호 차이를 사용하여 동일한 소스에서 수신된 이전 패킷에서 타임스탬프 값을 예측할 수 있습니다\(페이로드 유형에 변화가 없다고 가정\).

새로 수신된 RTP 데이터 패킷의 헤더에 있는 처음 4옥텟은 시퀀스 번호가 하나 늘렸습니다. 마찬가지로, 일반적으로 한 번에 하나의 소스에서 데이터를 수신하는 애플리케이션에서 더 빠른 SSRC 조회를 위해 단일 항목 캐시를 사용할 수 있습니다.

---
## **A.2 RTCP Header Validity Checks**

RTCP 패킷에는 다음 검사를 적용해야 합니다.

```text
   o  RTP version field must equal 2.
```

o 복합 패킷의 첫 번째 RTCP 패킷의 페이로드 유형 필드는 SR 또는 RR과 동일해야 합니다.

o 패딩은 필요한 경우 마지막 패킷에만 적용되어야 하기 때문에 복합 RTCP 패킷의 첫 번째 패킷에 대해 패딩 비트\(P\)는 0이어야 합니다.

o 개별 RTCP 패킷의 길이 필드는 수신된 복합 RTCP 패킷의 전체 길이에 합산되어야 합니다. 이것은 상당히 강력한 검사입니다.

아래 코드 조각은 이러한 모든 검사를 수행합니다. 알 수 없는 패킷 유형이 있을 수 있으므로 무시해야 하므로 후속 패킷에 대해서는 패킷 유형을 확인하지 않습니다.

```text
      u_int32 len;        /* length of compound RTCP packet in words */
      rtcp_t *r;          /* RTCP header */
      rtcp_t *end;        /* end of compound RTCP packet */

      if ((*(u_int16 *)r & RTCP_VALID_MASK) != RTCP_VALID_VALUE) {
          /* something wrong with packet format */
      }
      end = (rtcp_t *)((u_int32 *)r + len);

      do r = (rtcp_t *)((u_int32 *)r + r->common.length + 1);
      while (r < end && r->common.version == 2);

      if (r != end) {
          /* something wrong with packet format */
      }
```

---
## **A.3 Determining Number of Packets Expected and Lost**

패킷 손실률을 계산하려면 아래 코드에서 포인터 s를 통해 참조되는 구조체 소스에 정의된 소스별 상태 정보를 사용하여 각 소스에서 예상되고 실제로 수신된 RTP 패킷 수를 알아야 합니다. 수신된 패킷 수는 지연되거나 중복된 패킷을 포함하여 도착하는 패킷의 수입니다. 예상되는 패킷 수는 수신된 가장 높은 시퀀스 번호\(s-\>max\_seq\)와 수신된 첫 번째 시퀀스 번호\(s-\>base\_seq\) 간의 차이로 수신기에서 계산할 수 있습니다. 시퀀스 번호는 16비트에 불과하고 순환하므로 시퀀스 번호 순환\(s-\>사이클\)의 \(이동된\) 횟수로 가장 높은 시퀀스 번호를 확장해야 합니다. 수신된 패킷 수와 사이클 수는 모두 부록 A.1의 RTP 헤더 유효성 확인 루틴을 통해 유지됩니다.

```text
      extended_max = s->cycles + s->max_seq;
      expected = extended_max - s->base_seq + 1;
```

손실된 패킷 수는 예상되는 패킷 수에서 실제로 수신된 패킷 수를 뺀 값으로 정의됩니다.

```text
      lost = expected - s->received;
```

이 부호 있는 숫자는 24비트로 전달되므로 래핑보다는 양수 손실의 경우 0x7fffff, 음수 손실의 경우 0x800000으로 고정되어야 합니다.

마지막 보고 간격\(이전 SR 또는 RR 패킷이 전송된 이후\) 동안 손실된 패킷의 비율은 간격 전체의 예상 패킷 수와 수신된 패킷 수의 차이에서 계산됩니다. 여기서 Expected\_prior 및 received\_prior는 이전 수신 보고가 전송되었을 때 저장된 값입니다. 생성됨:

```text
      expected_interval = expected - s->expected_prior;
      s->expected_prior = expected;
      received_interval = s->received - s->received_prior;
      s->received_prior = s->received;
      lost_interval = expected_interval - received_interval;
      if (expected_interval == 0 || lost_interval <= 0) fraction = 0;
      else fraction = (lost_interval << 8) / expected_interval;
```

결과 분수는 왼쪽 가장자리에 이진 소수점이 있는 8비트 고정 소수점 숫자입니다.

---
## **A.4 Generating RTCP SDES Packets**

이 함수는 배열 유형, 값 및 길이로 제공되는 argc 항목으로 구성된 버퍼 b에 하나의 SDES 청크를 빌드합니다. b 내에서 사용 가능한 다음 위치에 대한 포인터를 반환합니다.

```text
   char *rtp_write_sdes(char *b, u_int32 src, int argc,
                        rtcp_sdes_type_t type[], char *value[],
                        int length[])
   {
       rtcp_sdes_t *s = (rtcp_sdes_t *)b;
       rtcp_sdes_item_t *rsp;
       int i;
       int len;
       int pad;

       /* SSRC header */
       s->src = src;
       rsp = &s->item[0];

       /* SDES items */
       for (i = 0; i < argc; i++) {
           rsp->type = type[i];
           len = length[i];
           if (len > RTP_MAX_SDES) {
               /* invalid length, may want to take other action */
               len = RTP_MAX_SDES;
           }
           rsp->length = len;
           memcpy(rsp->data, value[i], len);
           rsp = (rtcp_sdes_item_t *)&rsp->data[len];
       }

       /* terminate with end marker and pad to next 4-octet boundary */
       len = ((char *) rsp) - b;
       pad = 4 - (len & 0x3);
       b = (char *) rsp;
       while (pad--) *b++ = RTCP_SDES_END;

       return b;
   }
```

---
## **A.5 Parsing RTCP SDES Packets**

이 함수는 SSRC 식별자가 제공된 세션 멤버에 대한 정보에 대한 포인터를 찾기 위해 find\_member\(\) 함수를 호출하고 해당 멤버에 대한 새 SDES 정보를 저장하기 위해 member\_sdes\(\) 함수를 호출하여 SDES 패킷을 구문 분석합니다. 이 함수는 RTCP 패킷의 헤더에 대한 포인터를 기대합니다.

```text
   void rtp_read_sdes(rtcp_t *r)
   {
       int count = r->common.count;
       rtcp_sdes_t *sd = &r->r.sdes;
       rtcp_sdes_item_t *rsp, *rspn;
       rtcp_sdes_item_t *end = (rtcp_sdes_item_t *)
                               ((u_int32 *)r + r->common.length + 1);
       source *s;

       while (--count >= 0) {
           rsp = &sd->item[0];
           if (rsp >= end) break;
           s = find_member(sd->src);

           for (; rsp->type; rsp = rspn ) {
               rspn = (rtcp_sdes_item_t *)((char*)rsp+rsp->length+2);
               if (rspn >= end) {
                   rsp = rspn;
                   break;
               }
               member_sdes(s, rsp->type, rsp->data, rsp->length);
           }
           sd = (rtcp_sdes_t *)
                ((u_int32 *)sd + (((char *)rsp - (char *)sd) >> 2)+1);
       }
       if (count >= 0) {
           /* invalid packet format */
       }
   }
```

---
## **A.6 Generating a Random 32-bit Identifier**

다음 서브루틴은 RFC 1321\[32\]에 게시된 MD5 루틴을 사용하여 임의의 32비트 식별자를 생성합니다. 시스템 루틴은 모든 운영 체제에 존재하지 않을 수 있지만 어떤 종류의 정보가 사용될 수 있는지에 대한 힌트 역할을 해야 합니다. 적절할 수 있는 다른 시스템 호출은 다음과 같습니다.

```text
   o  getdomainname(),

   o  getwd(), or

   o  getrusage().
```

"라이브" 비디오 또는 오디오 샘플도 난수의 좋은 소스이지만 꺼진 마이크나 눈이 먼 카메라를 소스로 사용하지 않도록 주의해야 합니다\[17\].

RTCP 기간\(부록 A.7 참조\)을 생성하는 난수 생성기에 대한 초기 시드를 생성하고, 시퀀스 번호 및 타임스탬프에 대한 초기 값을 생성하고, SSRC 값을 생성하려면 이 루틴이나 유사한 루틴을 사용하는 것이 좋습니다. . 이 루틴은 CPU를 많이 사용하기 때문에 예측 가능성이 문제가 되지 않으므로 RTCP 기간을 생성하는 데 직접 사용하는 것은 부적절합니다. 이 루틴은 유형 인수에 다른 값이 제공되지 않는 한 시스템 시계 값이 변경될 때까지 반복 호출에 대해 동일한 결과를 생성합니다.

```text
   /*
    * Generate a random 32-bit quantity.
    */
   #include <sys/types.h>   /* u_long */
   #include <sys/time.h>    /* gettimeofday() */
   #include <unistd.h>      /* get..() */
   #include <stdio.h>       /* printf() */
   #include <time.h>        /* clock() */
   #include <sys/utsname.h> /* uname() */
   #include "global.h"      /* from RFC 1321 */
   #include "md5.h"         /* from RFC 1321 */

   #define MD_CTX MD5_CTX
   #define MDInit MD5Init
   #define MDUpdate MD5Update
   #define MDFinal MD5Final

   static u_long md_32(char *string, int length)
   {
       MD_CTX context;
       union {
           char   c[16];
           u_long x[4];
       } digest;
       u_long r;
       int i;

       MDInit (&context);

       MDUpdate (&context, string, length);
       MDFinal ((unsigned char *)&digest, &context);
       r = 0;
       for (i = 0; i < 3; i++) {
           r ^= digest.x[i];
       }
       return r;
   }                               /* md_32 */

   /*
    * Return random unsigned 32-bit quantity.  Use 'type' argument if
    * you need to generate several different values in close succession.
    */
   u_int32 random32(int type)
   {
       struct {
           int     type;
           struct  timeval tv;
           clock_t cpu;
           pid_t   pid;
           u_long  hid;
           uid_t   uid;
           gid_t   gid;
           struct  utsname name;
       } s;

       gettimeofday(&s.tv, 0);
       uname(&s.name);
       s.type = type;
       s.cpu  = clock();
       s.pid  = getpid();
       s.hid  = gethostid();
       s.uid  = getuid();
       s.gid  = getgid();
       /* also: system uptime */

       return md_32((char *)&s, sizeof(s));
   }                               /* random32 */
```

---
## **A.7 Computing the RTCP Transmission Interval**

다음 기능은 6.2절에 설명된 RTCP 전송 및 수신 규칙을 구현합니다. 이러한 규칙은 여러 기능으로 코딩됩니다.

o rtcp\_interval\(\)은 초 단위로 측정되는 결정론적 계산 간격을 계산합니다. 매개변수는 섹션 6.3에 정의되어 있습니다.

o RTCP 전송 타이머가 만료되면 OnExpire\(\)가 호출됩니다.

o OnReceive\(\)는 RTCP 패킷이 수신될 때마다 호출됩니다.

OnExpire\(\) 및 OnReceive\(\) 모두 이벤트 e를 인수로 갖습니다. 이는 해당 참가자에 대해 예정된 다음 이벤트\(RTCP 보고서 또는 BYE 패킷\)입니다. 다음 기능을 사용할 수 있다고 가정합니다.

o Schedule\(time t, event e\)는 이벤트 e가 시간 t에 발생하도록 예약합니다. 시간 t에 도달하면 e를 인수로 사용하여 OnExpire 함수가 호출됩니다.

o Reschedule\(time t, event e\)는 시간 t에 대해 이전에 예약된 이벤트 e를 다시 예약합니다.

o SendRTCPReport\(이벤트 e\)는 RTCP 보고서를 보냅니다.

o SendBYEPacket\(event e\)는 BYE 패킷을 보냅니다.

o TypeOfEvent\(event e\)는 이벤트가 다음과 같은 경우 EVENT\_BYE를 반환합니다.

- 처리된 것은 BYE 패킷이 전송되는 것이고, 그렇지 않으면 EVENT\_REPORT를 반환합니다.

o PacketType\(p\)는 패킷 p가 RTCP 보고서\(BYE 아님\)인 경우 PACKET\_RTCP\_REPORT를 반환하고, BYE RTCP 패킷인 경우 PACKET\_BYE를, 일반 RTP 데이터 패킷인 경우 PACKET\_RTP를 반환합니다.

o ReceiverdPacketSize\(\) 및 SentPacketSize\(\)는 참조된 패킷의 크기를 옥텟 단위로 반환합니다.

o NewMember\(p\)는 패킷 p를 보낸 참가자가 현재 구성원 목록에 없으면 1을 반환하고 그렇지 않으면 0을 반환합니다. RTP 패킷의 각 CSRC 식별자와 BYE 패킷의 각 SSRC를 처리해야 하기 때문에 이 기능은 전체 구현에 충분하지 않습니다.

o NewSender\(p\)는 패킷 p를 보낸 참가자가 현재 구성원 목록의 보낸 사람 하위 목록에 없으면 1을 반환하고, 그렇지 않으면 0을 반환합니다.

o AddMember\(\) 및 RemoveMember\(\)는 구성원 목록에서 참가자를 추가하고 제거합니다.

o AddSender\(\) 및 RemoveSender\(\)는 구성원 목록의 보낸 사람 하위 목록에서 참가자를 추가하고 제거합니다.

이러한 기능은 발신자와 비발신자에 대한 RTCP 대역폭 비율을 25% 및 75%의 고정 값이 아닌 명시적 매개변수로 지정하도록 허용하는 구현을 위해 확장되어야 합니다. rtcp\_interval\(\)의 확장된 구현은 매개변수 중 하나가 0인 경우 0으로 나누는 것을 방지해야 합니다.

```text
   double rtcp_interval(int members,
                        int senders,
                        double rtcp_bw,
                        int we_sent,
                        double avg_rtcp_size,
                        int initial)
   {
       /*
        * Minimum average time between RTCP packets from this site (in
        * seconds).  This time prevents the reports from `clumping' when
        * sessions are small and the law of large numbers isn't helping
        * to smooth out the traffic.  It also keeps the report interval
        * from becoming ridiculously small during transient outages like
        * a network partition.
        */
       double const RTCP_MIN_TIME = 5.;
       /*
        * Fraction of the RTCP bandwidth to be shared among active
        * senders.  (This fraction was chosen so that in a typical
        * session with one or two active senders, the computed report
        * time would be roughly equal to the minimum report time so that
        * we don't unnecessarily slow down receiver reports.)  The
        * receiver fraction must be 1 - the sender fraction.
        */
       double const RTCP_SENDER_BW_FRACTION = 0.25;
       double const RTCP_RCVR_BW_FRACTION = (1-RTCP_SENDER_BW_FRACTION);
       /*
       /* To compensate for "timer reconsideration" converging to a
        * value below the intended average.
        */
       double const COMPENSATION = 2.71828 - 1.5;

       double t;                   /* interval */
       double rtcp_min_time = RTCP_MIN_TIME;
       int n;                      /* no. of members for computation */
```

/\*

- \* 응용 프로그램 시작 시 첫 번째 호출은 더 빠른 알림을 위해 분의 절반 \* 지연을 사용하는 동시에 무작위화를 보고하고 다른 \* 소스에 대해 배우기 전에 약간의 시간을 \* 허용하므로 보고 간격이 더 빨리 올바른 \* 간격으로 수렴됩니다.

```text
        */
       if (initial) {
           rtcp_min_time /= 2;
       }
       /*
        * Dedicate a fraction of the RTCP bandwidth to senders unless
        * the number of senders is large enough that their share is
        * more than that fraction.
        */
       n = members;
       if (senders <= members * RTCP_SENDER_BW_FRACTION) {
           if (we_sent) {
               rtcp_bw *= RTCP_SENDER_BW_FRACTION;
               n = senders;
           } else {
               rtcp_bw *= RTCP_RCVR_BW_FRACTION;
               n -= senders;
           }
       }

       /*
        * The effective number of sites times the average packet size is
        * the total number of octets sent when each site sends a report.
        * Dividing this by the effective bandwidth gives the time
        * interval over which those packets must be sent in order to
        * meet the bandwidth target, with a minimum enforced.  In that
        * time interval we send one report so this time is also our
        * average time between reports.
        */
       t = avg_rtcp_size * n / rtcp_bw;
       if (t < rtcp_min_time) t = rtcp_min_time;

       /*
        * To avoid traffic bursts from unintended synchronization with
        * other sites, we then pick our actual next report interval as a
        * random number uniformly distributed between 0.5*t and 1.5*t.
        */
       t = t * (drand48() + 0.5);
       t = t / COMPENSATION;
       return t;
   }

   void OnExpire(event e,
                 int    members,
                 int    senders,
                 double rtcp_bw,
                 int    we_sent,
                 double *avg_rtcp_size,

                 int    *initial,
                 time_tp   tc,
                 time_tp   *tp,
                 int    *pmembers)
   {
       /* This function is responsible for deciding whether to send an
        * RTCP report or BYE packet now, or to reschedule transmission.
        * It is also responsible for updating the pmembers, initial, tp,
        * and avg_rtcp_size state variables.  This function should be
        * called upon expiration of the event timer used by Schedule().
        */

       double t;     /* Interval */
       double tn;    /* Next transmit time */

       /* In the case of a BYE, we use "timer reconsideration" to
        * reschedule the transmission of the BYE if necessary */

       if (TypeOfEvent(e) == EVENT_BYE) {
           t = rtcp_interval(members,
                             senders,
                             rtcp_bw,
                             we_sent,
                             *avg_rtcp_size,
                             *initial);
           tn = *tp + t;
           if (tn <= tc) {
               SendBYEPacket(e);
               exit(1);
           } else {
               Schedule(tn, e);
           }

       } else if (TypeOfEvent(e) == EVENT_REPORT) {
           t = rtcp_interval(members,
                             senders,
                             rtcp_bw,
                             we_sent,
                             *avg_rtcp_size,
                             *initial);
           tn = *tp + t;
           if (tn <= tc) {
               SendRTCPReport(e);
               *avg_rtcp_size = (1./16.)*SentPacketSize(e) +
                   (15./16.)*(*avg_rtcp_size);
               *tp = tc;
```

- /\* 간격을 다시 그려야 합니다. 재사용하지 마세요.

```text
                  one computed above, since its not actually
                  distributed the same, as we are conditioned
                  on it being small enough to cause a packet to
                  be sent */

               t = rtcp_interval(members,
                                 senders,
                                 rtcp_bw,
                                 we_sent,
                                 *avg_rtcp_size,
                                 *initial);

               Schedule(t+tc,e);
               *initial = 0;
           } else {
               Schedule(tn, e);
           }
           *pmembers = members;
       }
   }

   void OnReceive(packet p,
                  event e,
                  int *members,
                  int *pmembers,
                  int *senders,
                  double *avg_rtcp_size,
                  double *tp,
                  double tc,
                  double tn)
   {
       /* What we do depends on whether we have left the group, and are
        * waiting to send a BYE (TypeOfEvent(e) == EVENT_BYE) or an RTCP
        * report.  p represents the packet that was just received.  */

       if (PacketType(p) == PACKET_RTCP_REPORT) {
           if (NewMember(p) && (TypeOfEvent(e) == EVENT_REPORT)) {
               AddMember(p);
               *members += 1;
           }
           *avg_rtcp_size = (1./16.)*ReceivedPacketSize(p) +
               (15./16.)*(*avg_rtcp_size);
       } else if (PacketType(p) == PACKET_RTP) {
           if (NewMember(p) && (TypeOfEvent(e) == EVENT_REPORT)) {
               AddMember(p);
               *members += 1;
           }
           if (NewSender(p) && (TypeOfEvent(e) == EVENT_REPORT)) {

               AddSender(p);
               *senders += 1;
           }
       } else if (PacketType(p) == PACKET_BYE) {
           *avg_rtcp_size = (1./16.)*ReceivedPacketSize(p) +
               (15./16.)*(*avg_rtcp_size);

           if (TypeOfEvent(e) == EVENT_REPORT) {
               if (NewSender(p) == FALSE) {
                   RemoveSender(p);
                   *senders -= 1;
               }

               if (NewMember(p) == FALSE) {
                   RemoveMember(p);
                   *members -= 1;
               }

               if (*members < *pmembers) {
                   tn = tc +
                       (((double) *members)/(*pmembers))*(tn - tc);
                   *tp = tc -
                       (((double) *members)/(*pmembers))*(tc - *tp);

                   /* Reschedule the next report for time tn */

                   Reschedule(tn, e);
                   *pmembers = *members;
               }

           } else if (TypeOfEvent(e) == EVENT_BYE) {
               *members += 1;
           }
       }
   }
```

---
## **A.8 Estimating the Interarrival Jitter**

아래 코드 조각은 수신 보고서의 도착 간 지터 필드에 삽입될 RTP 데이터 도착 간 시간의 통계적 분산 추정치를 계산하기 위해 섹션 6.4.1에 제공된 알고리즘을 구현합니다. 입력은 수신 패킷의 타임스탬프인 r-\>ts와 동일한 단위의 현재 시간인 도착입니다. 다음은 소스에 대한 상태를 나타냅니다. s-\>transit은 이전 패킷의 상대적 전송 시간을 보유하고 s-\>jitter는 추정된 지터를 보유합니다. 수신 보고서의 지터 필드는 타임스탬프 단위로 측정되어 부호 없는 정수로 표현되지만 지터 추정치는 부동 소수점으로 유지됩니다. 각 데이터 패킷이 도착하면 지터 추정치가 업데이트됩니다.

```text
      int transit = arrival - r->ts;
      int d = transit - s->transit;
      s->transit = transit;
      if (d < 0) d = -d;
      s->jitter += (1./16.) * ((double)d - s->jitter);
```

이 멤버에 대해 수신 보고 블록\(rr이 가리키는\)이 생성되면 현재 지터 추정치가 반환됩니다.

```text
      rr->jitter = (u_int32) s->jitter;
```

또는 지터 추정치를 정수로 유지하면서 반올림 오류를 줄이기 위해 크기를 조정할 수도 있습니다. 마지막 줄을 제외하고 계산은 동일합니다.

```text
      s->jitter += d - ((s->jitter + 8) >> 4);
```

이 경우 수신 보고서에 대한 견적은 다음과 같이 샘플링됩니다.

```text
      rr->jitter = s->jitter >> 4;
```

---
# **Appendix B - Changes from RFC 1889**

이 RFC의 대부분은 RFC 1889와 동일합니다. 유선상의 패킷 형식에는 변경 사항이 없으며 프로토콜 사용 방법을 관리하는 규칙 및 알고리즘만 변경됩니다. 가장 큰 변화는 RTCP 패킷을 보낼 시기를 계산하기 위한 확장 가능한 타이머 알고리즘이 향상된 것입니다.

o 섹션 6.2 및 6.3에 지정되고 부록 A.7에 설명된 RTCP 전송 간격을 계산하는 알고리즘은 많은 참가자가 동시에 세션에 참여할 때 의도된 속도를 초과하는 전송을 최소화하기 위한 "재고려"와 "역재고려"를 포함하도록 확장되었습니다. " 참가자 수가 급격하게 감소할 때 잘못된 참가자 시간 초과의 발생률과 기간을 줄입니다. 역방향 재검토는 수동 수신자 모드에서 활성 발신자 모드로 전환할 때 RTCP SR을 전송하기 전 지연 시간을 단축하는 데에도 사용됩니다.

o 섹션 6.3.7에서는 많은 참가자가 동시에 세션을 떠날 때 패킷의 홍수를 피하기 위해 RTCP BYE 패킷을 보내야 하는 시기를 제어하는 ​​새로운 규칙을 지정합니다.

o 일반적인 네트워크 파티션에 걸쳐 있을 만큼 충분한 기간 동안 비활성 참가자의 상태를 유지해야 한다는 요구 사항이 섹션 6.2.1에서 제거되었습니다. 많은 참가자가 짧은 시간 동안 참여하고 BYE를 전송하지 못하는 세션에서 이 요구 사항은 참가자 수를 상당히 과대평가하게 만듭니다. 이번 개정판에 추가된 재검토 알고리즘은 파티션이 복구될 때 동시에 참여하는 많은 수의 신규 참가자를 보완합니다.

이러한 개선 사항은 세션 참가자 수가 많고\(수천명\) 대부분의 참가자가 동시에 참여하거나 탈퇴하는 경우에만 중요한 효과가 있다는 점에 유의해야 합니다. 이로 인해 실제 네트워크에서의 테스트가 어려워집니다. 그러나 알고리즘은 성능을 검증하기 위해 철저한 분석과 시뮬레이션을 거쳤습니다. 또한 향상된 알고리즘은 RFC 1889의 알고리즘과 상호 운용되도록 설계되어 단계 조인 중 초과 RTCP 대역폭의 감소 정도가 향상된 알고리즘을 구현하는 참가자의 비율에 비례합니다. 두 알고리즘의 상호 운용성은 라이브 네트워크에서 실험적으로 검증되었습니다.

```text
   Other functional changes were:
```

o 섹션 6.2.1에서는 구현 시 매우 큰 세션으로 확장할 수 있도록 참가자의 SSRC 식별자 샘플링만 저장할 수 있다고 명시합니다. 알고리즘은 RFC 2762 \[21\]에 지정되어 있습니다.

o 섹션 6.2에서는 RTCP 발신자 및 비발신자 대역폭이 세션 대역폭의 엄격한 비율이 아닌 세션의 별도 매개변수로 설정될 수 있으며 0으로 설정될 수 있다고 명시되어 있습니다. IP 멀티캐스트를 사용하는 RTP 세션에 대해 RTCP가 필수라는 요구 사항이 완화되었습니다. 그러나 RTCP를 끄는 것은 권장되지 않는다는 설명도 추가되었습니다.\(SHOULD NOT\)

o 섹션 6.2, 6.3.1 및 부록 A.7에서는 발신자가 전용 RTCP 대역폭을 받는 참가자의 비율이 고정 1/4에서 RTCP 발신자 및 비발신자 대역폭 매개변수에 따른 비율로 변경되도록 명시되어 있습니다. 그것이 주어졌을 때. 송신자가 없을 때 송신자에게 대역폭이 할당되지 않는 조건은 일시적인 상태일 것으로 예상되므로 제거되었습니다. 또한 의도하지 않은 경우 발신자가 아닌 사람이 발신자 RTCP 대역폭을 사용하는 것을 방지합니다.

o 또한 섹션 6.2에는 고대역폭 세션에 대해 최소 RTCP 간격이 더 작은 값으로 조정될 수 있고 유니캐스트 세션에 대해 초기 RTCP 지연이 0으로 설정될 수 있음이 지정되어 있습니다.

o 참가자의 시간 초과는 활성 발신자에 대해서도 수신기 RTCP 대역폭 비율을 사용하여 계산된 RTCP 보고 간격 수에 대한 비활성을 기반으로 합니다.

o 섹션 7.2 및 7.3에서는 변환기와 혼합기가 더 이상 전달하지 않는 소스에 대해 BYE 패킷을 보내야 한다고 지정합니다.

o 계층화된 인코딩에 대한 규칙 변경 사항은 섹션 2.4, 6.3.9, 8.3 및 11에 정의되어 있습니다. 마지막 부분에서는 주소 및 포트 할당 규칙이 SDP 사양인 RFC 2327\[15\]과 충돌하지만 RFC 2327 개정판에서는 이 제한이 완화될 예정입니다.

o 섹션 11의 RTP 및 RTCP에 짝수/홀수 포트 쌍을 사용하는 규칙이 대상 포트를 참조하도록 명확해졌습니다. 두 포트가 명시적으로 지정된 경우 짝수/홀수 포트 쌍을 사용해야 하는 요구 사항이 제거되었습니다. 유니캐스트 RTP 세션의 경우 두 끝 부분에 서로 다른 포트 쌍을 사용할 수 있습니다\(섹션 3, 7.1 및 11\).

o 다음에 대한 요구 사항을 설명하기 위해 새로운 섹션 10이 추가되었습니다.

- RTP를 사용하는 애플리케이션의 혼잡 제어.

o 섹션 8.2에서는 소스 전송 주소가 변경될 때마다 새로운 SSRC 식별자를 선택해야 한다는 요구 사항이 완화되어 새로운 SSRC 식별자를 선택할 수 있다고 명시했습니다. 이에 따라 구현이 다음과 같이 이루어질 수 있음이 명확해졌습니다.\(MUST, MAY\)

- 다른 두 참가자 사이에 SSRC 충돌이 발생할 때 기존 소스 주소가 아닌 새 소스 주소의 패킷을 유지하도록 선택하고, 모바일 엔터티와 같은 일부 소스가 프로세스 중에 주소를 변경할 수 있는 전화 통신과 같은 애플리케이션에 대해 그렇게 해야 합니다. RTP 세션.\(SHOULD\)

o 섹션 8.2의 충돌 감지 및 해결 알고리즘을 위한 의사 코드의 RFC 1889 인쇄에서 들여쓰기 버그가 구문을 의사 C 언어로 변환하여 수정되었으며, 알고리즘은 RTP와 RTP 및 해결 알고리즘이 모두 제한되지 않도록 수정되었습니다. RTCP는 동일한 소스 포트 번호에서 전송되어야 합니다.

o RTCP 패킷에 대한 패딩 메커니즘에 대한 설명이 명확해졌으며 패딩은 복합 RTCP 패킷의 마지막 패킷에만 적용되어야 한다고 지정되었습니다.\(MUST\)

o 섹션 A.1에서는 base\_seq의 초기화가 seq - 1이 아닌 seq로 수정되었으며, 잘못된 시퀀스 번호에 1을 더한 값이 저장되었다고 텍스트가 수정되었습니다. 알고리즘에 대한 max\_seq 및 기타 변수의 초기화는 init\_seq\(\) 함수를 호출하는 것 외에도 이 초기화가 수행되어야 함을 명확하게 하기 위해 텍스트와 분리되었습니다\(그리고 소스에서 출력으로 문서를 처리할 때 RFC 1889에서 몇 단어가 손실됨\). 양식이 복원되었습니다\).

o 섹션 A.3에서 손실된 패킷 수 제한이 양수 및 음수 제한을 모두 사용하도록 수정되었습니다.

o RTCP SR 섹션의 "상대적" NTP 타임스탬프 사양은 이제 여러 애플리케이션에 대해 동일하지 않은 세션 경과 시간이 아닌 시스템 가동 시간과 같은 가장 일반적인 시스템별 시계를 기반으로 이러한 타임스탬프를 정의합니다. 같은 컴퓨터에서 다른 시간에 시작되었습니다.

```text
   Non-functional changes:
```

o 수신기는 자신이 이해하지 못하는 페이로드 유형의 패킷을 무시해야 한다고 명시되어 있습니다.\(MUST\)

o 그림 2에서는 부동 소수점 NTP 타임스탬프 값이 수정되었으며 일부 누락된 선행 0이 16진수에 추가되었으며 UTC 시간대가 지정되었습니다.

o 2036년을 기준으로 하는 NTP 타임스탬프의 중요성이 설명됩니다.

o RTCP 패킷 유형 및 SDES 유형 등록에 대한 정책은 새로운 섹션 15, IANA 고려 사항에 명시되어 있습니다. 실험자가 필요한 번호를 등록한 다음 필요하지 않은 것으로 판명된 번호를 등록 취소하라는 제안은 APP 및 PRIV 사용을 위해 제거되었습니다. 프로필 이름 등록도 지정되었습니다.

o UTF-8 문자 집합에 대한 참조가 X/Open 예비 사양에서 RFC 2279로 변경되었습니다.

o RFC 1597에 대한 참조는 RFC 1918로 업데이트되었고 RFC 2543에 대한 참조는 RFC 3261로 업데이트되었습니다.

o RFC 1889 소개의 마지막 단락은 다음과 같습니다.

- 구현자에게 인터넷 배포를 제한하도록 주의를 주었지만 더 이상 관련이 없는 것으로 간주되어 제거되었습니다.

o SSM\(Source-Specific Multicast\)과 함께 RTP 사용에 관한 비표준 참고 사항이 섹션 6에 추가되었습니다.

o 섹션 3의 "RTP 세션" 정의는 단일 세션이 여러 대상 전송 주소를 사용할 수 있다는 점\(항상 번역기나 믹서의 경우와 마찬가지로\)을 인정하고 RTP 세션의 구별되는 특징은 다음과 같다는 점을 설명하기 위해 확장되었습니다. 각각은 별도의 SSRC 식별자 공간에 해당합니다. "세션"이라는 단어에 대한 혼동을 줄이기 위해 "멀티미디어 세션"의 새로운 정의가 추가되었습니다.

o "샘플링 순간"의 의미는 섹션 5.1의 RTP 헤더의 타임스탬프 필드 정의의 일부로 더 자세히 설명되었습니다.

o 텍스트에 대한 약간의 설명이 여러 곳에서 이루어졌으며 일부는 독자의 질문에 대한 응답이었습니다. 특히:

- - RFC 1889에서는 소스에서 출력 형식으로 문서를 처리하는 동안 섹션 2.2의 두 번째 문장의 처음 5개 단어가 손실되었으나 현재는 복원되었습니다.

- - 다중 미디어의 다중화와 관련하여 섹션 5.2의 다중화 RTP 세션에 대한 설명을 보다 명확하게 하기 위해 섹션 3에 "RTP 미디어 유형"에 대한 정의가 추가되었습니다. 또한 해당 섹션에서는 SSRC 식별자를 기반으로 동일한 매체의 여러 소스를 멀티플렉싱하는 것이 적절할 수 있으며 멀티캐스트 세션의 표준임을 설명합니다.

- - "비RTP 수단"에 대한 정의가 비RTP 수단을 구성하는 다른 프로토콜의 예를 포함하도록 확장되었습니다.

- - 세션 대역폭 매개변수에 대한 설명은 데이터 트래픽을 위한 세션 대역폭에 제어 트래픽 대역폭이 추가된다는 설명을 포함하여 섹션 6.2에서 확장됩니다.

- - 지터 계산에 대한 다양한 패킷 지속 시간의 효과는 섹션 6.4.4에서 설명되었습니다.

- - SDES 항목 시퀀스를 종료하고 채우는 방법은 섹션 6.5에서 명확해졌습니다.

- - 섹션 6.5.1의 SDES CNAME 설명에 IPv6 주소 예제가 추가되었으며, 다른 예제 도메인 이름 대신 "example.com"이 사용되었습니다.

- - 보안 섹션에서는 이제 사용할 수 있는 IPSEC에 대한 공식적인 참조를 추가했으며, 이 사양에 정의된 기밀 유지 방법은 주로 기존 관행을 체계화하는 것이라고 말합니다. 기본 알고리즘 대신 Triple-DES와 같은 더 강력한 암호화 알고리즘을 사용하는 것이 권장되며, 앞으로는 AES 기반 SRTP 프로필이 올바른 선택이 될 것이라는 점에 유의하세요. 초기화 벡터로서 RTP 헤더의 취약점에 대한 주의 사항이 추가되었습니다. 또한 헤더 압축을 허용하려면 페이로드 전용 암호화가 필요하다는 점도 언급되었습니다.\(SHOULD\)

- - RTCP 부분 암호화 방법이 명확해졌습니다. 특히 SDES CNAME은 복합 RTCP 패킷이 분할될 때 한 부분으로만 전달됩니다.

- - 보고 간격당 하나의 복합 RTCP 패킷만 전송해야 하며 보고에 대한 활성 소스가 너무 많아 MTU에 맞지 않는 경우 소스의 하위 집합을 여러 간격에 걸쳐 라운드 로빈으로 선택해야 한다는 점이 명확해졌습니다. .

- - RTP 헤더 검증 중에 패킷이 저장되고 성공 시 전달될 수 있다는 메모가 부록 A.1에 추가되었습니다.

- - 이제 섹션 7.3에서는 SDES 패킷을 집계하는 믹서가 더 긴 패킷으로 인해 더 많은 RTCP 대역폭을 사용하고 RTCP를 통과하는 믹서는 자연스럽게 단일 소스 속도보다 높은 속도로 패킷을 전송하지만 두 동작 모두 유효함을 설명합니다.

- - 섹션 13에서는 RTP 애플리케이션이 여러 프로필을 사용할 수 있지만 일반적으로 특정 세션에서는 하나만 사용할 수 있음을 명시합니다.

- - MUST, SHOULD, MAY 등의 용어는 RFC 2119에 정의된 대로 사용됩니다.\(MUST\)

- - 참고문헌은 규범적 참고문헌과 정보 참고문헌으로 구분하였다.

---
# **References**
---
# **Normative References**

\[1\] Schulzrinne, H. 및 S. Casner, "최소 제어를 통한 오디오 및 비디오 회의용 RTP 프로필", RFC 3551, 2003년 7월.

\[2\] Bradner, S., "요구 사항 수준을 나타내기 위해 RFC에서 사용하는 핵심 단어", BCP 14, RFC 2119, 1997년 3월.

```text
   [3]  Postel, J., "Internet Protocol", STD 5, RFC 791, September 1981.
```

\[4\] Mills, D., "Network Time Protocol\(버전 3\) 사양, 구현 및 분석", RFC 1305, 1992년 3월.

\[5\] Yergeau, F., "UTF-8, ISO 10646의 변환 형식", RFC 2279, 1998년 1월.

\[6\] Mockapetris, P., "도메인 이름 - 개념 및 시설", STD 13, RFC 1034, 1987년 11월.

\[7\] Mockapetris, P., "도메인 이름 - 구현 및

- 사양", STD 13, RFC 1035, 1987년 11월.

\[8\] Braden, R., "인터넷 호스트 요구 사항 - 응용 프로그램 및 지원", STD 3, RFC 1123, 1989년 10월.

```text
   [9]  Resnick, P., "Internet Message Format", RFC 2822, April 2001.
```

---
# **Informative References**

\[10\] Clark, D. 및 D. Tennenhouse, "신세대 프로토콜을 위한 아키텍처 고려 사항", 통신 아키텍처 및 프로토콜에 관한 SIGCOMM 심포지엄, \(필라델피아, 펜실베이니아\), pp. 200--208, IEEE Computer Communications Review, Vol. 1990년 9월 20\(4\).

\[11\] Schulzrinne, H., "음성 및 화상 회의와 기타 다중 참가자 실시간 애플리케이션을 위한 전송 프로토콜 설계 문제." 만료된 인터넷 초안, 1993년 10월.

\[12\] Comer, D., TCP/IP를 이용한 인터네트워킹, vol. 1. 뉴저지 주 잉글우드 클리프: 프렌티스 홀, 1991년.

\[13\] Rosenberg, J., Schulzrinne, H., Camarillo, G., Johnston, A., Peterson, J., Sparks, R., Handley, M. 및 E. Schooler, "SIP: 세션 시작 프로토콜", RFC 3261, 2002년 6월.

\[14\] 국제전기통신연합\(International Telecommunication Union\), "보장되지 않은 서비스 품질을 제공하는 근거리 통신망용 영상 전화 시스템 및 장비", 권고사항 H.323, ITU 통신 표준화 부문, 스위스 제네바, 2003년 7월.

\[15\] Handley, M. 및 V. Jacobson, "SDP: 세션 설명

- 프로토콜", RFC 2327, 1998년 4월.

\[16\] Schulzrinne, H., Rao, A. 및 R. Lanphier, "실시간 스트리밍 프로토콜\(RTSP\)", RFC 2326, 1998년 4월.

\[17\] Eastlake 3rd, D., Crocker, S. 및 J. Schiller, "보안을 위한 무작위성 권장 사항", RFC 1750, 1994년 12월.

\[18\] Bolot, J.-C., Turletti, T. 및 I. Wakeman, "인터넷의 멀티캐스트 비디오 배포를 위한 확장 가능한 피드백 제어", 통신 아키텍처 및 프로토콜에 관한 SIGCOMM 심포지엄\(영국 런던\), pp. 58-67, ACM, 1994년 8월.

\[19\] Busse, I., Deffner, B. 및 H. Schulzrinne, "RTP 기반 멀티미디어 애플리케이션의 동적 QoS 제어", 컴퓨터 통신, vol. 19, 49\~58페이지, 1996년 1월.

\[20\] Floyd, S. 및 V. Jacobson, "주기적인 라우팅 메시지의 동기화", 통신 아키텍처 및 프로토콜에 관한 SIGCOMM 심포지엄\(D. P. Sidhu, ed.\), \(캘리포니아주 샌프란시스코\), pp. 33-44 , ACM, 1993년 9월. \[34\]에도 있습니다.

\[21\] Rosenberg, J. 및 H. Schulzrinne, "RTP의 그룹 구성원 샘플링", RFC 2762, 2000년 2월.

\[22\] Cadzow, J., 디지털 신호 처리 및 데이터 분석의 기초 뉴욕, 뉴욕: Macmillan, 1987.

\[23\] Hinden, R. 및 S. Deering, "인터넷 프로토콜 버전 6\(IPv6\) 주소 지정 아키텍처", RFC 3513, 2003년 4월.

\[24\] Rekhter, Y., Moskowitz, B., Karrenberg, D., de Groot, G. 및 E. Lear, "개인 인터넷에 대한 주소 할당", RFC 1918, 1996년 2월.

\[25\] Lear, E., Fair, E., Crocker, D. 및 T. Kessler, "유해한 것으로 간주되는 네트워크 10\(일부 관행은 성문화해서는 안 됨\)", RFC 1627, 1994년 7월.

\[26\] Feller, W., 확률 이론 및 그 응용 소개, vol. 1. 뉴욕, 뉴욕: John Wiley and Sons, 3판, 1968.

\[27\] Kent, S. 및 R. Atkinson, "인터넷 프로토콜을 위한 보안 아키텍처", RFC 2401, 1998년 11월.

\[28\] Baugher, M., Blom, R., Carrara, E., McGrew, D., Naslund, M., Norrman, K. 및 D. Oran, "보안 실시간 전송 프로토콜", 진행 중인 작업, 2003년 4월.

\[29\] Balenson, D., "인터넷 전자 메일의 개인 정보 보호 강화: 파트 III", RFC 1423, 1993년 2월.

\[30\] Voydock, V. 및 S. Kent, "고위 수준 네트워크 프로토콜의 보안 메커니즘", ACM Computing Surveys, vol. 15, pp. 135-171, 1983년 6월.

```text
   [31] Floyd, S., "Congestion Control Principles", BCP 41, RFC 2914,
        September 2000.

   [32] Rivest, R., "The MD5 Message-Digest Algorithm", RFC 1321, April
        1992.
```

\[33\] Stubblebine, S., "멀티미디어 보안 서비스

- 회의", 제16차 전국 컴퓨터 보안 회의\(메릴랜드주 볼티모어\), pp. 391--395, 1993년 9월.

\[34\] Floyd, S. 및 V. Jacobson, "주기적인 라우팅 메시지의 동기화", 네트워킹에 대한 IEEE/ACM 트랜잭션, vol. 2, pp. 122-136, 1994년 4월.

---
# **Authors' Addresses**

Henning Schulzrinne 컴퓨터 과학과 Columbia University 1214 Amsterdam Avenue New York, NY 10027 United States

```text
   EMail: schulzrinne@cs.columbia.edu

   Stephen L. Casner
   Packet Design
   3400 Hillview Avenue, Building 3
   Palo Alto, CA 94304
   United States

   EMail: casner@acm.org

   Ron Frederick
   Blue Coat Systems Inc.
   650 Almanor Avenue
   Sunnyvale, CA 94085
   United States

   EMail: ronf@bluecoat.com

   Van Jacobson
   Packet Design
   3400 Hillview Avenue, Building 3
   Palo Alto, CA 94304
   United States

   EMail: van@packetdesign.com
```

---
# **Full Copyright Statement**

저작권\(C\)인터넷학회\(2003\). 판권 소유.

이 문서와 그 번역본은 복사되어 타인에게 제공될 수 있으며, 이에 대해 설명하거나 설명하거나 구현을 지원하는 파생물은 어떤 종류의 제한 없이 전체적으로 또는 부분적으로 준비, 복사, 출판 및 배포될 수 있습니다. , 단, 위의 저작권 표시와 이 단락은 그러한 모든 사본 및 파생물에 포함됩니다. 그러나 이 문서 자체는 인터넷 표준 개발 목적으로 필요한 경우를 제외하고는 저작권 표시를 제거하거나 Internet Society 또는 기타 인터넷 조직에 대한 참조를 제거하는 등 어떤 식으로든 수정할 수 없습니다. 인터넷 표준 프로세스를 따르거나 영어 이외의 언어로 번역하는 데 필요한 대로 따라야 합니다.

위에서 부여된 제한된 권한은 영구적이며 Internet Society 또는 그 승계자 또는 양수인에 의해 취소되지 않습니다.

이 문서와 여기에 포함된 정보는 "있는 그대로" 제공되며 인터넷 사회 및 인터넷 공학 태스크포스는 여기에 포함된 정보의 사용이 상품성 또는 특정 목적에의 적합성에 대한 권리 또는 묵시적 보증을 침해하는 행위.

---
# **Acknowledgement**

RFC 편집기 기능에 대한 자금은 현재 Internet Society에서 제공하고 있습니다.
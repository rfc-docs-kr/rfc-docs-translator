

```text
Internet Engineering Task Force (IETF)                         A. Freier
Request for Comments: 6101                                    P. Karlton
Category: Historic                               Netscape Communications
ISSN: 2070-1721                                                P. Kocher
                                                  Independent Consultant
                                                             August 2011

          The Secure Sockets Layer (SSL) Protocol Version 3.0
```

---
# **Abstract**

이 문서는 SSL 3.0 프로토콜의 역사 기록으로 게시됩니다. 원본 초록은 다음과 같습니다.

이 문서는 인터넷을 통해 통신 프라이버시를 제공하는 보안 프로토콜인 SSL 3.0\(Secure Sockets Layer\) 프로토콜 버전 3.0을 지정합니다. 이 프로토콜을 사용하면 클라이언트/서버 애플리케이션이 도청, 변조 또는 메시지 위조를 방지하도록 설계된 방식으로 통신할 수 있습니다.

---
# **Foreword**

SSL 3.0 프로토콜은 널리 구현된 프로토콜이고 보안 통신 프로토콜의 선구자이며 TLS\(전송 계층 보안\)의 기반이지만 만료된 여러 인터넷 초안을 제외하고는 IETF에서 공식적으로 게시한 적이 없습니다. 이로 인해 프로토콜을 쉽게 참조할 수 없었습니다. 우리는 원본 문서에 대한 안정적인 참조가 존재해야 한다고 믿으며 그러한 이유로 이 문서는 SSL 3.0 프로토콜의 마지막 게시 버전, 즉 1996년 11월 18일 프로토콜 버전으로 알려진 것을 설명합니다.

사소한 편집 변경 및 "보안 고려 사항" 섹션 추가 외에 원본 문서에는 변경 사항이 없습니다. 그러나 더 이상 적용되지 않는 원본 문서 부분은 포함되지 않았습니다. "Patent Statement" 섹션, "Reserved Ports Assignment" 섹션 및 "The CipherSuite" 섹션의 Cipher-suite 등록자 메모와 같은 것입니다. 문서에서 논의된 "미국 수출 규칙"은 현재 적용되지 않지만 프로토콜 설계에서 취해진 결정에 대한 컨텍스트를 제공하기 위해 그대로 유지됩니다. "이 문서의 목표" 섹션은 IETF의 목표가 아니라 SSL 3.0 채택자의 목표를 나타냅니다.

저자와 편집자는 원본 문서와 동일하게 유지되었습니다. 이 문서의 편집자는 Nikos Mavrogiannopoulos\(nikos.mavrogiannopoulos@esat.kuleuven.be\)입니다. 편집자는 이 문서를 검토하고 유용한 의견을 제공한 Dan Harkins, Linda Dunbar, Sean Turner 및 Geoffrey Keating에게 감사를 표합니다.

---
# **Status of This Memo**

이 문서는 인터넷 표준 추적 사양이 아닙니다. 그것은 역사적 기록을 위해 출판되었습니다.

이 문서는 인터넷 커뮤니티를 위한 역사적 문서를 정의합니다. 이 문서는 IETF\(Internet Engineering Task Force\)의 제품입니다. 이는 IETF 커뮤니티의 합의를 나타냅니다. 공개 검토를 받았으며 IESG\(Internet Engineering Steering Group\)의 출판 승인을 받았습니다. IESG에서 승인한 모든 문서가 모든 수준의 인터넷 표준에 적합한 것은 아닙니다. RFC 5741의 섹션 2를 참조하십시오.

이 문서의 현재 상태, 정오표 및 피드백 제공 방법에 대한 정보는 http://www.rfc-editor.org/info/rfc6101에서 얻을 수 있습니다.

---
# **Copyright Notice**

Copyright \(c\) 2011 IETF Trust 및 문서 작성자로 확인된 사람. 판권 소유.

이 문서는 이 문서의 발행일에 유효한 BCP 78 및 IETF 문서에 관한 IETF 트러스트의 법적 조항\(http://trustee.ietf.org/license-info\)의 적용을 받습니다. 이 문서와 관련된 귀하의 권리 및 제한 사항을 설명하므로 이 문서를 주의 깊게 검토하십시오. 이 문서에서 추출한 코드 구성 요소는 Trust Legal Provisions의 섹션 4.e에 설명된 대로 Simplified BSD License 텍스트를 포함해야 하며 Simplified BSD License에 설명된 대로 보증 없이 제공됩니다.

이 문서에는 2008년 11월 10일 이전에 공개되거나 공개된 IETF 문서 또는 IETF 기고문의 자료가 포함될 수 있습니다. 이 자료의 일부에 대한 저작권을 제어하는 ​​사람은 해당 자료의 수정을 허용할 권리를 IETF 트러스트에 부여하지 않았을 수 있습니다. IETF 표준 프로세스 외부. 이러한 자료의 저작권을 관리하는 사람으로부터 적절한 라이센스를 얻지 않고 이 문서는 IETF 표준 프로세스 외부에서 수정할 수 없으며 IETF 표준 프로세스 외부에서 이 문서의 파생물을 생성할 수 없습니다. RFC로 게시하거나 영어 이외의 언어로 번역합니다.

---
# **Table of Contents**

```text
   1. Introduction ....................................................5
   2. Goals ...........................................................5
   3. Goals of This Document ..........................................6
   4. Presentation Language ...........................................6
      4.1. Basic Block Size ...........................................7
      4.2. Miscellaneous ..............................................7
      4.3. Vectors ....................................................7
      4.4. Numbers ....................................................8
      4.5. Enumerateds ................................................8
      4.6. Constructed Types ..........................................9
           4.6.1. Variants ...........................................10
      4.7. Cryptographic Attributes ..................................11
      4.8. Constants .................................................12
   5. SSL Protocol ...................................................12
      5.1. Session and Connection States .............................12
      5.2. Record Layer ..............................................14
           5.2.1. Fragmentation ......................................14
           5.2.2. Record Compression and Decompression ...............15
           5.2.3. Record Payload Protection and the CipherSpec .......16
      5.3. Change Cipher Spec Protocol ...............................18
      5.4. Alert Protocol ............................................18
           5.4.1. Closure Alerts .....................................19
           5.4.2. Error Alerts .......................................20
      5.5. Handshake Protocol Overview ...............................21
      5.6. Handshake Protocol ........................................23
           5.6.1. Hello messages .....................................24
           5.6.2. Server Certificate .................................28
           5.6.3. Server Key Exchange Message ........................28
           5.6.4. Certificate Request ................................30
           5.6.5. Server Hello Done ..................................31
           5.6.6. Client Certificate .................................31
           5.6.7. Client Key Exchange Message ........................31
           5.6.8. Certificate Verify .................................34
           5.6.9. Finished ...........................................35
      5.7. Application Data Protocol .................................36
   6. Cryptographic Computations .....................................36
      6.1. Asymmetric Cryptographic Computations .....................36
           6.1.1. RSA ................................................36
           6.1.2. Diffie-Hellman .....................................37
           6.1.3. FORTEZZA ...........................................37
      6.2. Symmetric Cryptographic Calculations and the CipherSpec ...37
           6.2.1. The Master Secret ..................................37
           6.2.2. Converting the Master Secret into Keys and
                  MAC Secrets ........................................37
   7. Security Considerations ........................................39
   8. Informative References .........................................40
   Appendix A. Protocol Constant Values ..............................42
     A.1. Record Layer ...............................................42
     A.2. Change Cipher Specs Message ................................43
     A.3. Alert Messages .............................................43
     A.4. Handshake Protocol .........................................44
       A.4.1. Hello Messages .........................................44
       A.4.2. Server Authentication and Key Exchange Messages ........45
     A.5. Client Authentication and Key Exchange Messages ............46
       A.5.1. Handshake Finalization Message .........................47
     A.6. The CipherSuite ............................................47
     A.7. The CipherSpec .............................................49
   Appendix B. Glossary ..............................................50
   Appendix C. CipherSuite Definitions ...............................53
   Appendix D. Implementation Notes ..................................56
     D.1. Temporary RSA Keys .........................................56
     D.2. Random Number Generation and Seeding .......................56
     D.3. Certificates and Authentication ............................57
     D.4. CipherSuites ...............................................57
     D.5. FORTEZZA ...................................................57
       D.5.1. Notes on Use of FORTEZZA Hardware ......................57
       D.5.2. FORTEZZA Cipher Suites .................................58
       D.5.3. FORTEZZA Session Resumption ............................58
   Appendix E. Version 2.0 Backward Compatibility ....................59
     E.1. Version 2 Client Hello .....................................59
     E.2. Avoiding Man-in-the-Middle Version Rollback ..............61
   Appendix F. Security Analysis .....................................61
     F.1. Handshake Protocol .........................................61
       F.1.1. Authentication and Key Exchange ........................61
       F.1.2. Version Rollback Attacks ...............................64
       F.1.3. Detecting Attacks against the Handshake Protocol .......64
       F.1.4. Resuming Sessions ......................................65
       F.1.5. MD5 and SHA ............................................65
     F.2. Protecting Application Data ................................65
     F.3. Final Notes ................................................66
   Appendix G. Acknowledgements ......................................66
     G.1. Other Contributors .........................................66
     G.2. Early Reviewers ............................................67
```

---
## **1.  Introduction**

SSL 프로토콜의 주요 목표는 통신하는 두 응용 프로그램 간에 개인 정보 보호 및 안정성을 제공하는 것입니다. 프로토콜은 두 개의 계층으로 구성됩니다. 신뢰할 수 있는 전송 프로토콜\(예: TCP \[RFC0793\]\) 위에 계층화된 가장 낮은 수준에는 SSL 레코드 프로토콜이 있습니다. SSL 레코드 프로토콜은 다양한 상위 수준 프로토콜의 캡슐화에 사용됩니다. 이러한 캡슐화된 프로토콜 중 하나인 SSL 핸드셰이크 프로토콜을 사용하면 서버와 클라이언트가 서로를 인증하고 애플리케이션 프로토콜이 데이터의 첫 번째 바이트를 전송하거나 수신하기 전에 암호화 알고리즘과 암호화 키를 협상할 수 있습니다. SSL의 장점 중 하나는 애플리케이션 프로토콜에 독립적이라는 것입니다. 더 높은 수준의 프로토콜은 SSL 프로토콜 위에 투명하게 계층화될 수 있습니다. SSL 프로토콜은 세 가지 기본 속성이 있는 연결 보안을 제공합니다.

o 연결이 비공개입니다. 암호화는 비밀 키를 정의하기 위해 초기 핸드셰이크 후에 사용됩니다. 대칭 암호화는 데이터 암호화에 사용됩니다\(예: DES\[DES\], 3DES\[3DES\], RC4\[SCH\]\).

o 피어의 신원은 비대칭 또는 공개 키 암호화\(예: RSA\[RSA\], DSS\[DSS\]\)를 사용하여 인증될 수 있습니다.

o 연결이 안정적입니다. 메시지 전송에는 키 MAC\(Message Authentication Code\)\[RFC2104\]를 사용하는 메시지 무결성 검사가 포함됩니다. 보안 해시 함수\(예: SHA, MD5\)는 MAC 계산에 사용됩니다.

---
## **2.  Goals**

SSL 프로토콜 버전 3.0의 목표는 우선순위에 따라 다음과 같습니다.

```text
   1.  Cryptographic security
```

- 두 당사자 간에 보안 연결을 설정하려면 SSL을 사용해야 합니다.

```text
   2.  Interoperability
```

- 독립적인 프로그래머는 SSL 3.0을 활용하여 서로의 코드를 몰라도 암호화 매개변수를 성공적으로 교환할 수 있는 응용 프로그램을 개발할 수 있어야 합니다.

- 참고: SSL의 모든 인스턴스\(동일한 애플리케이션 도메인에서도\)가 성공적으로 연결할 수 있는 것은 아닙니다. 예를 들어, 서버가 특정 하드웨어 토큰을 지원하고 클라이언트가 그러한 토큰에 액세스할 수 없는 경우 연결에 성공하지 못합니다.

```text
   3.  Extensibility
```

- SSL은 필요에 따라 새로운 공개 키 및 대량 암호화 방법을 통합할 수 있는 프레임워크를 제공하려고 합니다. 이것은 또한 두 가지 하위 목표를 달성할 것입니다. 새로운 프로토콜을 생성할 필요성을 방지하고\(및 가능한 새로운 약점의 도입 위험\) 완전히 새로운 보안 라이브러리를 구현해야 할 필요성을 방지합니다.

```text
   4.  Relative efficiency
```

- 암호화 작업은 특히 공개 키 작업과 같이 CPU를 많이 사용하는 경향이 있습니다. 이러한 이유로 SSL 프로토콜은 선택적 세션 캐싱 체계를 통합하여 처음부터 설정해야 하는 연결 수를 줄입니다. 또한 네트워크 활동을 줄이기 위해 주의를 기울였습니다.

---
## **3.  Goals of This Document**

SSL 프로토콜 버전 3.0 사양은 주로 프로토콜을 구현할 독자와 이에 대한 암호화 분석을 수행하는 독자를 위한 것입니다. 사양은 이를 염두에 두고 작성되었으며 이 두 그룹의 요구 사항을 반영하기 위한 것입니다. 이러한 이유로 많은 알고리즘 종속 데이터 구조 및 규칙이 텍스트 본문에 포함되어\(부록과는 반대로\) 더 쉽게 액세스할 수 있습니다.

이 문서는 서비스 정의 또는 인터페이스 정의에 대한 세부 정보를 제공하기 위한 것이 아니지만 견고한 보안을 유지 관리하는 데 필요한 일부 정책 영역을 다루고 있습니다.

---
## **4.  Presentation Language**

이 문서는 외부 표현의 데이터 형식을 다룹니다. 다음의 매우 기본적이고 다소 캐주얼하게 정의된 프레젠테이션 구문이 사용됩니다. 구문은 구조의 여러 소스에서 가져옵니다. 구문 및 의도에서 XDR\(External Data Representation\)\[RFC1832\]과 구문에서 프로그래밍 언어 "C"와 유사하지만,

너무 많은 유사점을 그리는 것은 위험합니다. 이 프리젠테이션 언어의 목적은 SSL만을 문서화하는 것이며 특정 목표를 넘어서는 일반적인 적용은 하지 않는 것입니다.

---
### **4.1.  Basic Block Size**

모든 데이터 항목의 표현은 명시적으로 지정됩니다. 기본 데이터 블록 크기는 1바이트\(즉, 8비트\)입니다. 다중 바이트 데이터 항목은 왼쪽에서 오른쪽으로, 위에서 아래로 바이트를 연결한 것입니다. 바이트 스트림에서 멀티바이트 항목\(예제에서는 숫자\)은 다음과 같이 구성됩니다\(C 표기법 사용\).

```text
        value = (byte[0] << 8*(n-1)) | (byte[1] << 8*(n-2)) | ...
        | byte[n-1];
```

멀티바이트 값에 대한 이 바이트 순서는 일반적인 네트워크 바이트 순서 또는 빅 엔디안 형식입니다.

---
### **4.2.  Miscellaneous**

주석은 "/\*"로 시작하고 "\*/"로 끝납니다. 선택적 구성 요소는 "\[\[ \]\]" 이중 괄호로 묶어서 표시합니다. 해석되지 않은 데이터를 포함하는 1바이트 엔터티는 불투명한 유형입니다.

---
### **4.3.  Vectors**

벡터\(단일 차원 배열\)는 동종 데이터 요소의 스트림입니다. 벡터의 크기는 문서화 시 지정되거나 런타임까지 지정되지 않은 상태로 남을 수 있습니다. 두 경우 모두 길이는 벡터의 요소 수가 아니라 바이트 수를 선언합니다. 유형 T의 고정 길이 벡터인 새 유형 T'를 지정하기 위한 구문은 다음과 같습니다.

```text
        T T'[n];
```

여기서 T'는 데이터 스트림에서 n바이트를 차지하며, 여기서 n은 T 크기의 배수입니다. 벡터의 길이는 인코딩된 스트림에 포함되지 않습니다.

다음 예에서 Datum은 프로토콜이 해석하지 않는 3개의 연속 바이트로 정의되는 반면 Data는 3개의 연속 Datum으로 총 9바이트를 소비합니다.

```text
        opaque Datum[3];      /* three uninterpreted bytes */
        Datum Data[9];        /* 3 consecutive 3 byte vectors */
```

가변 길이 벡터는 <floor..ceiling\> 표기법을 사용하여 법적 길이의 하위 범위를 지정하여 정의됩니다. 인코딩될 때 실제 길이는 바이트 스트림에서 벡터의 내용 앞에 옵니다. 길이는 벡터의 지정된 최대\(천장\) 길이를 유지하는 데 필요한 만큼의 바이트를 소비하는 숫자 형식입니다. 실제 길이 필드가 0인 가변 길이 벡터를 빈 벡터라고 합니다.

```text
        T T'<floor..ceiling>;
```

다음 예에서 필수는 불투명 유형의 300\~400바이트를 포함해야 하는 벡터입니다. 절대 비워둘 수 없습니다. 실제 길이 필드는 값 400을 나타내기에 충분한 uint16인 2바이트를 사용합니다\(섹션 4.4 참조\). 반면 long은 최대 800바이트의 데이터 또는 400개의 uint16 요소를 나타낼 수 있으며 비어 있을 수 있습니다. 해당 인코딩에는 벡터 앞에 추가된 2바이트 실제 길이 필드가 포함됩니다.

```text
        opaque mandatory<300..400>;
              /* length field is 2 bytes, cannot be empty */
        uint16 longer<0..800>;
              /* zero to 400 16-bit unsigned integers */
```

---
### **4.4.  Numbers**

기본 숫자 데이터 유형은 부호 없는 바이트\(uint8\)입니다. 모든 더 큰 숫자 데이터 유형은 섹션 4.1에 설명된 대로 연결된 고정 길이 일련의 바이트로 구성되며 부호도 없습니다. 다음 숫자 유형은 미리 정의되어 있습니다.

```text
        uint8 uint16[2];
        uint8 uint24[3];
        uint8 uint32[4];
        uint8 uint64[8];
```

---
### **4.5.  Enumerateds**

enum이라는 추가 희소 데이터 유형을 사용할 수 있습니다. enum 유형의 필드는 정의에서 선언된 값만 가정할 수 있습니다. 각 정의는 다른 유형입니다. 동일한 유형의 열거형만 할당하거나 비교할 수 있습니다. 열거형의 모든 요소에는 다음 예제와 같이 값이 할당되어야 합니다. 열거된 요소는 순서가 없기 때문에 순서에 관계없이 고유한 값을 할당할 수 있습니다.

```text
        enum { e1(v1), e2(v2), ... , en(vn), [[(n)]] } Te;
```

열거형은 정의된 최대 서수 값만큼 바이트 스트림에서 많은 공간을 차지합니다. 다음 정의는 색상 유형의 필드를 전달하는 데 1바이트가 사용되도록 합니다.

```text
        enum { red(3), blue(5), white(7) } Color;
```

선택적으로 관련 태그 없이 값을 지정하여 불필요한 요소를 정의하지 않고 너비 정의를 강제할 수 있습니다. 다음 예에서 Taste는 데이터 스트림에서 2바이트를 소비하지만 값 1, 2 또는 4만 가정할 수 있습니다.

```text
        enum { sweet(1), sour(2), bitter(4), (32000) } Taste;
```

열거형 요소의 이름은 정의된 유형 내에서 범위가 지정됩니다. 첫 번째 예에서 열거형의 두 번째 요소에 대한 정규화된 참조는 Color.blue입니다. 과제의 대상이 잘 지정된 경우에는 이러한 자격이 필요하지 않습니다.

```text
        Color color = Color.blue;     /* overspecified, legal */
        Color color = blue;           /* correct, type implicit */
```

외부 표현으로 변환되지 않는 열거형의 경우 숫자 정보가 생략될 수 있습니다.

```text
        enum { low, medium, high } Amount;
```

---
### **4.6.  Constructed Types**

편의상 기본 유형에서 구조 유형을 구성할 수 있습니다. 각 사양은 새롭고 고유한 유형을 선언합니다. 정의 구문은 C와 매우 유사합니다.

```text
      struct {
          T1 f1;
          T2 f2;
          ...
          Tn fn;
      } [[T]];
```

구조 내의 필드는 열거에 사용할 수 있는 것과 매우 유사한 구문을 사용하여 유형의 이름을 사용하여 한정될 수 있습니다. 예를 들어 T.f2는 이전 선언의 두 번째 필드를 나타냅니다. 구조 정의를 포함할 수 있습니다.

---
#### **4.6.1.  Variants**

정의된 구조에는 환경 내에서 사용할 수 있는 일부 지식을 기반으로 하는 변형이 있을 수 있습니다. 선택자는 구조가 정의하는 가능한 변형을 정의하는 열거 유형이어야 합니다. select에서 선언된 열거형의 모든 요소에 대해 case arm이 있어야 합니다. 변형 구조의 본문에는 참조용 레이블이 지정될 수 있습니다. 런타임 시 변형이 선택되는 메커니즘은 프레젠테이션 언어로 규정되지 않습니다.

```text
        struct {
            T1 f1;
            T2 f2;
             ....
            Tn fn;
            select (E) {
                case e1: Te1;
                case e2: Te2;
                    ....
                case en: Ten;
            } [[fv]];
        } [[Tv]];
```

-  예를 들어,

```text
        enum { apple, orange } VariantTag;
        struct {
            uint16 number;
            opaque string<0..10>; /* variable length */
        } V1;

        struct {
            uint32 number;
            opaque string[10];    /* fixed length */
        } V2;
        struct {
            select (VariantTag) { /* value of selector is implicit */
                case apple: V1;   /* VariantBody, tag = apple */
                case orange: V2;  /* VariantBody, tag = orange */
            } variant_body;       /* optional label on variant */
        } VariantRecord;
```

유형 이전에 선택자에 대한 값을 지정하여 변형 구조를 한정\(축소\)할 수 있습니다. 예를 들어,

```text
        orange VariantRecord
```

V2 유형의 variant\_body를 포함하는 VariantRecord의 제한된 유형입니다.

---
### **4.7.  Cryptographic Attributes**

네 가지 암호화 작업 디지털 서명, 스트림 암호화, 블록 암호화 및 공개 키 암호화는 각각 디지털 서명, 스트림 암호화, 블록 암호화 및 공개 키 암호화로 지정됩니다. 필드의 암호화 처리는 필드 유형 사양 앞에 적절한 키워드 지정을 추가하여 지정됩니다. 암호화 키는 현재 세션 상태에 의해 암시됩니다\(섹션 5.1 참조\).

디지털 서명에서 단방향 해시 함수는 서명 알고리즘의 입력으로 사용됩니다. RSA 서명에서는 2개의 해시\(SHA 1개와 MD5 1개\)의 36바이트 구조가 서명됩니다\(개인 키로 암호화됨\). DSS에서 SHA 해시의 20바이트는 추가 해시 없이 디지털 서명 알고리즘을 통해 직접 실행됩니다.

스트림 암호 암호화에서 일반 텍스트는 암호학적으로 안전한 키 의사 난수 생성기에서 생성된 동일한 양의 출력과 배타적 OR됩니다.

블록 암호 암호화에서는 평문의 모든 블록이 암호문 블록으로 암호화됩니다. 일반 텍스트\(전송되는 데이터가 무엇이든\)가 필요한 블록 크기\(보통 64비트\)로 깔끔하게 분할될 가능성이 없기 때문에 짧은 블록의 끝을 일정한 패턴\(일반적으로 모두 0\)으로 채워야 합니다.

공개 키 암호화에서는 비밀 "트랩도어"가 있는 단방향 기능을 사용하여 나가는 데이터를 암호화합니다. 주어진 키 쌍의 공개 키로 암호화된 데이터는 개인 키로만 해독할 수 있으며 그 반대도 마찬가지입니다. 다음 예에서:

```text
        stream-ciphered struct {
            uint8 field1;
            uint8 field2;
            digitally-signed opaque hash[20];
        } UserType;
```

해시의 내용은 서명 알고리즘의 입력으로 사용되며 전체 구조는 스트림 암호로 암호화됩니다.

---
### **4.8.  Constants**

유형이 지정된 상수는 원하는 유형의 기호를 선언하고 여기에 값을 할당하여 지정 목적으로 정의할 수 있습니다. 과소 지정 유형\(불투명, 가변 길이 벡터 및 불투명을 포함하는 구조\)에는 값을 할당할 수 없습니다. 다중 요소 구조 또는 벡터의 필드는 생략할 수 없습니다.

```text
      For example,
        struct {
            uint8 f1;
            uint8 f2;
        } Example1;

        Example1 ex1 = {1, 4};/* assigns f1 = 1, f2 = 4 */
```

---
## **5.  SSL Protocol**

SSL은 계층화된 프로토콜입니다. 각 계층에서 메시지에는 길이, 설명 및 콘텐츠에 대한 필드가 포함될 수 있습니다. SSL은 전송할 메시지를 가져오고, 데이터를 관리 가능한 블록으로 분할하고, 선택적으로 데이터를 압축하고, MAC을 적용하고, 암호화하고 결과를 전송합니다. 수신된 데이터는 복호화, 확인, 압축 해제 및 재조립된 다음 상위 클라이언트로 전달됩니다.

---
### **5.1.  Session and Connection States**

SSL 세션은 상태 저장입니다. SSL 핸드셰이크 프로토콜은 클라이언트와 서버의 상태를 조정하여 상태가 정확히 병렬이 아님에도 불구하고 각 프로토콜 상태 머신이 일관되게 작동할 수 있도록 합니다. 논리적으로 상태는 현재 작동 상태로 한 번, \(핸드셰이크 프로토콜 동안\) 다시 보류 상태로 두 번 표시됩니다. 또한 별도의 읽기 및 쓰기 상태가 유지됩니다. 클라이언트 또는 서버가 암호 사양 변경 메시지를 수신하면 보류 중인 읽기 상태를 현재 읽기 상태로 복사합니다. 클라이언트 또는 서버가 암호 사양 변경 메시지를 보낼 때 보류 중인 쓰기 상태를 현재 쓰기 상태로 복사합니다. 핸드셰이크 협상이 완료되면 클라이언트와 서버는 변경 암호 사양 메시지\(섹션 5.3 참조\)를 교환한 다음 새로 합의된 암호 사양을 사용하여 통신합니다.

SSL 세션에는 여러 보안 연결이 포함될 수 있습니다. 또한 당사자는 여러 개의 동시 세션을 가질 수 있습니다.

세션 상태에는 다음 요소가 포함됩니다.

세션 식별자: 활성 또는 재개 가능한 세션 상태를 식별하기 위해 서버에서 선택한 임의의 바이트 시퀀스입니다.

피어 인증서: 피어의 X509.v3 \[X509\] 인증서. 상태의 이 요소는 null일 수 있습니다.

압축 방법: 암호화 전에 데이터를 압축하는 데 사용되는 알고리즘입니다.

암호 사양: 대량 데이터 암호화 알고리즘\(예: null, DES 등\) 및 MAC 알고리즘\(예: MD5 또는 SHA\)을 지정합니다. 또한 hash\_size와 같은 암호화 속성을 정의합니다. \(정식 정의는 부록 A.7 참조\)

마스터 시크릿: 클라이언트와 서버 간에 공유되는 48바이트 시크릿입니다.

is resumable: 세션을 사용하여 새 연결을 시작할 수 있는지 여부를 나타내는 플래그입니다.

연결 상태에는 다음 요소가 포함됩니다.

서버 및 클라이언트 임의: 각 연결에 대해 서버와 클라이언트가 선택한 바이트 시퀀스.

서버 쓰기 MAC 비밀: 서버가 쓴 데이터에 대한 MAC 작업에 사용되는 비밀입니다.

클라이언트 쓰기 MAC 비밀: 클라이언트가 쓴 데이터에 대한 MAC 작업에 사용되는 비밀입니다.

서버 쓰기 키: 서버에서 암호화하고 클라이언트에서 해독한 데이터의 대량 암호 키입니다.

클라이언트 쓰기 키: 클라이언트에서 암호화하고 서버에서 해독한 데이터의 대량 암호 키입니다.

초기화 벡터: CBC\(Cipher Block Chaining\) 모드의 블록 암호를 사용하는 경우 각 키에 대해 초기화 벡터\(IV\)가 유지됩니다. 이 필드는 먼저 SSL 핸드셰이크 프로토콜에 의해 초기화됩니다. 그 후 각 레코드의 최종 암호문 블록은 다음 레코드와 함께 사용하기 위해 보존됩니다.

시퀀스 번호: 각 당사자는 각 연결에 대해 전송 및 수신된 메시지에 대해 별도의 시퀀스 번호를 유지합니다. 당사자가 암호 사양 변경 메시지를 보내거나 받을 때 해당 시퀀스 번호가 0으로 설정됩니다. 시퀀스 번호는 uint64 유형이며 2^64-1을 초과할 수 없습니다.

---
### **5.2.  Record Layer**

SSL 레코드 계층은 임의 크기의 비어 있지 않은 블록으로 상위 계층에서 해석되지 않은 데이터를 수신합니다.

---
#### **5.2.1.  Fragmentation**

레코드 레이어는 정보 블록을 2^14바이트 이하의 SSLPlaintext 레코드로 분할합니다. 클라이언트 메시지 경계는 레코드 레이어에서 보존되지 않습니다\(즉, 동일한 ContentType의 여러 클라이언트 메시지가 단일 SSLPlaintext 레코드로 통합될 수 있음\).

```text
        struct {
            uint8 major, minor;
        } ProtocolVersion;

        enum {
            change_cipher_spec(20), alert(21), handshake(22),
            application_data(23), (255)
        } ContentType;

        struct {
            ContentType type;
            ProtocolVersion version;
            uint16 length;
            opaque fragment[SSLPlaintext.length];
        } SSLPlaintext;
```

유형: 동봉된 조각을 처리하는 데 사용되는 상위 수준 프로토콜입니다.

version: 사용 중인 프로토콜의 버전입니다. 이 문서는 SSL 버전 3.0에 대해 설명합니다\(부록 A.1 참조\).

길이: 다음의 길이\(바이트\)

- SSLPlaintext.fragment. 길이는 2^14를 초과하면 안 됩니다.

fragment: 애플리케이션 데이터. 이 데이터는 투명하며 유형 필드에 지정된 상위 수준 프로토콜에 의해 처리되는 독립적인 블록으로 처리됩니다.

참고: 서로 다른 SSL 레코드 레이어 콘텐츠 유형의 데이터가 인터리브될 수 있습니다. 애플리케이션 데이터는 일반적으로 다른 콘텐츠 유형보다 전송 우선 순위가 낮습니다.

---
#### **5.2.2.  Record Compression and Decompression**

모든 레코드는 현재 세션 상태에 정의된 압축 알고리즘을 사용하여 압축됩니다. 항상 활성 압축 알고리즘이 있습니다. 그러나 처음에는 CompressionMethod.null로 정의됩니다. 압축 알고리즘은 SSLPlaintext 구조를 SSLCompressed 구조로 변환합니다. 압축 기능은 CipherSpec이 교체될 때마다 상태 정보를 지웁니다.

참고: CipherSpec은 섹션 5.1에 설명된 세션 상태의 일부입니다. CipherSpec의 필드에 대한 참조는 프레젠테이션 구문을 사용하여 이 문서 전체에서 만들어집니다. CipherSpec에 대한 자세한 설명은 부록 A.7에 나와 있습니다.

압축은 무손실이어야 하며 콘텐츠 길이를 1024바이트 이상 늘릴 수 없습니다. 압축 해제 기능이 2^14바이트를 초과하는 길이로 압축을 해제하는 SSLCompressed.fragment를 발견하면 치명적인 decompression\_failure 경고\(섹션 5.4.2\)를 발행해야 합니다.

```text
        struct {
            ContentType type;       /* same as SSLPlaintext.type */
            ProtocolVersion version;/* same as SSLPlaintext.version */
            uint16 length;
            opaque fragment[SSLCompressed.length];
        } SSLCompressed;
```

길이: 다음의 길이\(바이트\)

- SSLCompressed.fragment. 길이는 2^14 + 1024를 초과할 수 없습니다.

조각: SSLPlaintext.fragment의 압축된 형식입니다.

참고: CompressionMethod.null 작업은 ID 작업입니다. 어떤 필드도 변경되지 않습니다\(부록 A.4.1 참조\).

구현 참고 사항: 압축 해제 기능은 메시지가 내부 버퍼 오버플로를 일으키지 않도록 하는 역할을 합니다.

---
#### **5.2.3.  Record Payload Protection and the CipherSpec**

모든 레코드는 현재 CipherSpec에 정의된 암호화 및 MAC 알고리즘을 사용하여 보호됩니다. 항상 활성 CipherSpec이 있습니다. 그러나 처음에는 보안을 제공하지 않는 SSL\_NULL\_WITH\_NULL\_NULL입니다.

핸드셰이크가 완료되면 두 당사자는 레코드를 암호화하고 콘텐츠의 키 MAC\(메시지 인증 코드\)를 계산하는 데 사용되는 공유 비밀을 갖게 됩니다. 암호화 및 MAC 작업을 수행하는 데 사용되는 기술은 CipherSpec에 의해 정의되고 CipherSpec.cipher\_type에 의해 제한됩니다. 암호화 및 MAC 기능은 SSLCompressed 구조를 SSLCiphertext로 변환합니다. 암호 해독 기능은 프로세스를 반대로 합니다. 누락, 변경 또는 추가 메시지를 감지할 수 있도록 전송에는 시퀀스 번호도 포함됩니다.

```text
        struct {
            ContentType type;
            ProtocolVersion version;
            uint16 length;
            select (CipherSpec.cipher_type) {
                case stream: GenericStreamCipher;
                case block: GenericBlockCipher;
            } fragment;
        } SSLCiphertext;
```

유형: 유형 필드는 SSLCompressed.type과 동일합니다.

버전: 버전 필드는 SSLCompressed.version과 동일합니다.

길이: 다음의 길이\(바이트\)

- SSLCiphertext.fragment. 길이는 2^14 + 2048을 초과할 수 없습니다.

조각: MAC을 포함하는 SSLCompressed.fragment의 암호화된 형식입니다.

---
##### **5.2.3.1.  Null or Standard Stream Cipher**

스트림 암호\(BulkCipherAlgorithm.null 포함, 부록 A.7 참조\)는 SSLCompressed.fragment 구조와 스트림 SSLCiphertext.fragment 구조 간에 변환합니다.

```text
        stream-ciphered struct {
            opaque content[SSLCompressed.length];
            opaque MAC[CipherSpec.hash_size];
        } GenericStreamCipher;
```

MAC은 다음과 같이 생성됩니다.

```text
        hash(MAC_write_secret + pad_2 +
             hash(MAC_write_secret + pad_1 + seq_num +
                  SSLCompressed.type + SSLCompressed.length +
                  SSLCompressed.fragment));
```

여기서 "+"는 연결을 나타냅니다.

pad\_1: 문자 0x36이 MD5의 경우 48번, SHA의 경우 40번 반복됩니다.

pad\_2: 문자 0x5c가 MD5의 경우 48번, SHA의 경우 40번 반복됩니다.

seq\_num: 이 메시지의 시퀀스 번호입니다.

hash: 암호 그룹에서 파생된 해싱 알고리즘입니다.

MAC은 암호화 전에 계산됩니다. 스트림 암호는 MAC을 포함한 전체 블록을 암호화합니다. 동기화 벡터\(예: RC4\)를 사용하지 않는 스트림 암호의 경우 한 레코드 끝의 스트림 암호 상태가 후속 패킷에서 단순히 사용됩니다. CipherSuite가 SSL\_NULL\_WITH\_NULL\_NULL인 경우 암호화는 ID 작업으로 구성됩니다\(즉, 데이터가 암호화되지 않고 MAC 크기가 0이므로 MAC이 사용되지 않음을 나타냄\). SSLCiphertext.length는 SSLCompressed.length에 CipherSpec.hash\_size를 더한 값입니다.

---
##### **5.2.3.2.  CBC Block Cipher**

블록 암호\(예: RC2 또는 DES\)의 경우 암호화 및 MAC 함수는 SSLCompressed.fragment 구조와 블록 SSLCiphertext.fragment 구조 간에 변환합니다.

```text
        block-ciphered struct {
            opaque content[SSLCompressed.length];
            opaque MAC[CipherSpec.hash_size];
            uint8 padding[GenericBlockCipher.padding_length];
            uint8 padding_length;
        } GenericBlockCipher;
```

MAC은 섹션 5.2.3.1에 설명된 대로 생성됩니다.

패딩\(padding\): 일반 텍스트의 길이가 블록 암호의 블록 길이의 배수가 되도록 강제하기 위해 추가되는 패딩.

padding\_length: 패딩 길이는 암호의 블록 길이보다 작아야 하며 0일 수 있습니다. 패딩 길이는 GenericBlockCipher 구조의 전체 크기가 암호 블록 길이의 배수가 되도록 해야 합니다.

암호화된 데이터 길이\(SSLCiphertext.length\)는 SSLCompressed.length, CipherSpec.hash\_size 및 padding\_length의 합보다 하나 더 큽니다.

참고: CBC를 사용하면 첫 번째 레코드의 IV\(초기화 벡터\)가 핸드셰이크 프로토콜에서 제공됩니다. 후속 레코드의 IV는 이전 레코드의 마지막 암호문 블록입니다.

---
### **5.3.  Change Cipher Spec Protocol**

변경 암호 사양 프로토콜은 암호 전략의 전환을 알리기 위해 존재합니다. 프로토콜은 현재\(보류 중인 것이 아님\) CipherSpec에서 암호화 및 압축되는 단일 메시지로 구성됩니다. 메시지는 값 1의 단일 바이트로 구성됩니다.

```text
        struct {
            enum { change_cipher_spec(1), (255) } type;
        } ChangeCipherSpec;
```

Change Cipher Spec 메시지는 클라이언트와 서버 모두에서 전송되어 방금 협상된 CipherSpec 및 키에 따라 후속 레코드가 보호됨을 수신자에게 알립니다. 이 메시지를 수신하면 수신자는 읽기 보류 상태를 현재 읽기 상태로 복사하게 됩니다. 클라이언트는 핸드셰이크 키 교환 및 인증서 확인 메시지\(있는 경우\)에 이어 암호 사양 변경 메시지를 보내고 서버는 클라이언트로부터 받은 키 교환 메시지를 성공적으로 처리한 후 보냅니다. 예기치 않은 변경 암호 사양 메시지는 예기치 않은\_메시지 경고를 생성해야 합니다\(섹션 5.4.2\). 이전 세션을 재개할 때 change cipher spec 메시지가 hello 메시지 이후에 전송됩니다.

---
### **5.4.  Alert Protocol**

SSL 레코드 레이어에서 지원하는 콘텐츠 유형 중 하나는 알림 유형입니다. 경보 메시지는 메시지의 심각도와 경보에 대한 설명을 전달합니다. 치명적인 수준의 경고 메시지는 연결을 즉시 종료합니다. 이 경우 해당 세션에 해당하는 다른 연결은 계속할 수 있지만 세션 식별자를 무효화하여 실패한 세션이 새 연결을 설정하는 데 사용되지 않도록 해야 합니다. 다른 메시지와 마찬가지로 경고 메시지는 현재 연결 상태에 지정된 대로 암호화되고 압축됩니다.

```text
        enum { warning(1), fatal(2), (255) } AlertLevel;

        enum {
            close_notify(0),
            unexpected_message(10),
            bad_record_mac(20),
            decompression_failure(30),
            handshake_failure(40),
            no_certificate(41),
            bad_certificate(42),
            unsupported_certificate(43),
            certificate_revoked(44),
            certificate_expired(45),
            certificate_unknown(46),
            illegal_parameter (47)
            (255)
        } AlertDescription;

        struct {
            AlertLevel level;
            AlertDescription description;
        } Alert;
```

---
#### **5.4.1.  Closure Alerts**

클라이언트와 서버는 잘림 공격을 피하기 위해 연결이 종료된다는 정보를 공유해야 합니다. 어느 쪽이든 종료 메시지 교환을 시작할 수 있습니다.

close\_notify: 이 메시지는 발신자가 이 연결에서 더 이상 메시지를 보내지 않을 것임을 수신자에게 알립니다. 경고 수준의 적절한 close\_notify 메시지 없이 연결이 종료되면 세션을 재개할 수 없게 됩니다.

각 당사자는 close\_notify 경고를 전송하여 청산을 시작할 수 있습니다. 종료 알림 이후 수신된 모든 데이터는 무시됩니다.

각 당사자는 연결의 쓰기 쪽을 닫기 전에 close\_notify 경고를 보내야 합니다. 상대방은 자신의 close\_notify 경고로 응답하고 즉시 연결을 닫아 대기 중인 쓰기를 버려야 합니다. 연결의 읽기 쪽을 닫기 전에 닫기 시작자가 응답하는 close\_notify 경고를 기다릴 필요가 없습니다.

NB: 연결을 닫으면 전송이 중단되기 전에 보류 중인 데이터가 안정적으로 전달된다고 가정합니다.

---
#### **5.4.2.  Error Alerts**

SSL 핸드셰이크 프로토콜의 오류 처리는 매우 간단합니다. 오류가 감지되면 감지한 당사자는 상대방에게 메시지를 보냅니다. 치명적인 경고 메시지를 전송하거나 수신하면 양 당사자는 즉시 연결을 닫습니다. 서버와 클라이언트는 실패한 연결과 관련된 모든 세션 식별자, 키 및 비밀을 잊어버려야 합니다. 다음 오류 경고가 정의됩니다.

expected\_message: 부적절한 메시지가 수신되었습니다. 이 경고는 항상 치명적이며 적절한 구현 간의 통신에서 관찰되어서는 안 됩니다.

bad\_record\_mac: MAC이 잘못된 레코드가 수신된 경우 이 경고가 반환됩니다. 이 메시지는 항상 치명적입니다.

decompression\_failure: 압축 해제 기능이 부적절한 입력을 받았습니다\(예: 과도한 길이로 확장되는 데이터\). 이 메시지는 항상 치명적입니다.

handshake\_failure: handshake\_failure 경고 메시지 수신은 발신자가 사용 가능한 옵션이 있는 경우 허용 가능한 보안 매개변수 집합을 협상할 수 없음을 나타냅니다. 이것은 치명적인 오류입니다.

no\_certificate: 적절한 인증서를 사용할 수 없는 경우 인증 요청에 대한 응답으로 no\_certificate 경고 메시지를 보낼 수 있습니다.

bad\_certificate: 인증서가 손상되었거나 올바르게 확인되지 않은 서명이 포함되어 있습니다.

unsupported\_certificate: 인증서가 지원되지 않는 유형입니다.

certificate\_revoked: 서명자가 인증서를 취소했습니다.

certificate\_expired: 인증서가 만료되었거나 현재 유효하지 않습니다.

certificate\_unknown: 인증서를 처리하는 동안 다른\(지정되지 않은\) 문제가 발생하여 허용되지 않습니다.

Illegal\_parameter: 핸드셰이크의 필드가 범위를 벗어났거나 다른 필드와 일치하지 않습니다. 이것은 항상 치명적입니다.

---
### **5.5.  Handshake Protocol Overview**

세션 상태의 암호화 매개변수는 SSL 레코드 레이어 위에서 작동하는 SSL 핸드셰이크 프로토콜에 의해 생성됩니다. SSL 클라이언트와 서버가 처음 통신을 시작하면 프로토콜 버전에 동의하고, 암호화 알고리즘을 선택하고, 선택적으로 서로를 인증하고, 공개 키 암호화 기술을 사용하여 공유 비밀을 생성합니다. 이러한 프로세스는 핸드셰이크 프로토콜에서 수행되며 다음과 같이 요약할 수 있습니다. 클라이언트는 서버가 서버 Hello 메시지로 응답해야 하는 클라이언트 Hello 메시지를 보냅니다. 그렇지 않으면 치명적인 오류가 발생하고 연결이 실패합니다. client hello 및 server hello는 클라이언트와 서버 간의 보안 강화 기능을 설정하는 데 사용됩니다. 클라이언트 hello 및 server hello는 프로토콜 버전, 세션 ID, 암호 그룹 및 압축 방법과 같은 속성을 설정합니다. 또한 ClientHello.random 및 ServerHello.random이라는 두 개의 임의 값이 생성되고 교환됩니다.

Hello 메시지 다음에 서버는 인증을 받아야 하는 경우 인증서를 보냅니다. 또한 필요한 경우 서버 키 교환 메시지를 보낼 수 있습니다\(예: 서버에 인증서가 없거나 인증서가 서명 전용인 경우\). 서버가 인증되면 선택한 암호 제품군에 적합한 경우 클라이언트에서 인증서를 요청할 수 있습니다. 이제 서버는 핸드셰이크의 hello-message 단계가 완료되었음을 나타내는 hello done 메시지를 서버에 보냅니다. 그러면 서버는 클라이언트 응답을 기다립니다. 서버가 인증서 요청 메시지를 보낸 경우 클라이언트는 인증서 메시지 또는 no\_certificate 경고를 보내야 합니다. 이제 클라이언트 키 교환 메시지가 전송되고 해당 메시지의 내용은 클라이언트 hello와 서버 hello 사이에서 선택된 공개 키 알고리즘에 따라 달라집니다. 클라이언트가 서명 기능이 있는 인증서를 보낸 경우 인증서를 명시적으로 확인하기 위해 디지털 서명된 인증서 확인 메시지가 전송됩니다.

이 시점에서 클라이언트는 암호 사양 변경 메시지를 보내고 클라이언트는 보류 중인 CipherSpec을 현재 CipherSpec에 복사합니다. 그런 다음 클라이언트는 새 알고리즘, 키 및 비밀에 따라 완성된 메시지를 즉시 보냅니다. 이에 대한 응답으로 서버는 자체 변경 암호 사양 메시지를 보내고 보류 중인 내용을 현재 CipherSpec으로 전송하고 완료된 메시지를 새 CipherSpec으로 보냅니다. 이 시점에서 핸드셰이크가 완료되고 클라이언트와 서버는 응용 프로그램 계층 데이터 교환을 시작할 수 있습니다. \(아래 순서도 참조\)

```text
      Client                                                Server

      ClientHello                   -------->
                                                       ServerHello
                                                      Certificate*
                                                ServerKeyExchange*
                                               CertificateRequest*
                                    <--------      ServerHelloDone
      Certificate*
      ClientKeyExchange
      CertificateVerify*
      [ChangeCipherSpec]
      Finished                      -------->
                                                [ChangeCipherSpec]
                                    <--------             Finished
      Application Data              <------->     Application Data
```

- \* 항상 전송되지 않는 선택적 또는 상황에 따른 메시지를 나타냅니다.

참고: 파이프라인 중단을 방지하기 위해 ChangeCipherSpec은 독립적인 SSL 프로토콜 콘텐츠 유형이며 실제로는 SSL 핸드셰이크 메시지가 아닙니다.

클라이언트와 서버가 이전 세션을 재개하거나 기존 세션을 복제하기로 결정할 때\(새 보안 매개변수를 협상하는 대신\) 메시지 흐름은 다음과 같습니다.

클라이언트는 재개할 세션의 세션 ID를 사용하여 ClientHello를 보냅니다. 그런 다음 서버는 일치하는 세션 캐시를 확인합니다. 일치하는 항목이 있고 서버가 지정된 세션 상태에서 연결을 다시 설정하려는 경우 동일한 세션 ID 값으로 ServerHello를 보냅니다. 이 시점에서 클라이언트와 서버 모두 변경 암호 사양 메시지를 보내고 완료된 메시지로 바로 진행해야 합니다. 재설정이 완료되면 클라이언트와 서버는 응용 프로그램 계층 데이터 교환을 시작할 수 있습니다. \(아래 순서도 참조\) 일치하는 세션 ID가 없으면 서버는 새 세션 ID를 생성하고 SSL 클라이언트와 서버는 전체 핸드셰이크를 수행합니다.

```text
      Client                                                Server

      ClientHello                   -------->
                                                       ServerHello
                                              [change cipher spec]
                                    <--------             Finished
      change cipher spec
      Finished                      -------->
      Application Data              <------->     Application Data
```

각 메시지의 내용과 의미는 다음 섹션에서 자세히 설명합니다.

---
### **5.6.  Handshake Protocol**

SSL 핸드셰이크 프로토콜은 SSL 레코드 프로토콜의 정의된 상위 수준 클라이언트 중 하나입니다. 이 프로토콜은 세션의 보안 속성을 협상하는 데 사용됩니다. 핸드셰이크 메시지는 현재 활성 세션 상태에 지정된 대로 처리되고 전송되는 하나 이상의 SSLPlaintext 구조 내에서 캡슐화되는 SSL 레코드 레이어에 제공됩니다.

```text
        enum {
            hello_request(0), client_hello(1), server_hello(2),
            certificate(11), server_key_exchange (12),
            certificate_request(13), server_hello_done(14),
            certificate_verify(15), client_key_exchange(16),
            finished(20), (255)
        } HandshakeType;

        struct {
            HandshakeType msg_type;    /* handshake type */
            uint24 length;             /* bytes in message */
            select (HandshakeType) {
                case hello_request: HelloRequest;
                case client_hello: ClientHello;
                case server_hello: ServerHello;
                case certificate: Certificate;
                case server_key_exchange: ServerKeyExchange;
                case certificate_request: CertificateRequest;
                case server_hello_done: ServerHelloDone;
                case certificate_verify: CertificateVerify;
                case client_key_exchange: ClientKeyExchange;
                case finished: Finished;
            } body;
        } Handshake;
```

핸드셰이크 프로토콜 메시지는 전송되어야 하는 순서대로 표시됩니다. 예기치 않은 순서로 핸드셰이크 메시지를 보내면 치명적인 오류가 발생합니다.

---
#### **5.6.1.  Hello messages**

Hello 단계 메시지는 클라이언트와 서버 간에 보안 강화 기능을 교환하는 데 사용됩니다. 새 세션이 시작되면 CipherSpec 암호화, 해시 및 압축 알고리즘이 null로 초기화됩니다. 현재 CipherSpec은 재협상 메시지에 사용됩니다.

---
##### **5.6.1.1.  Hello Request**

Hello 요청 메시지는 서버에서 언제든지 보낼 수 있지만 핸드셰이크 프로토콜이 이미 진행 중인 경우 클라이언트에서 무시됩니다. 클라이언트가 편리할 때 클라이언트 안녕하세요 메시지를 전송하여 협상 프로세스를 새로 시작해야 한다는 간단한 알림입니다.

참고: 핸드셰이크 메시지는 애플리케이션 데이터보다 전송 우선순위를 가지도록 되어 있으므로 최대 길이 애플리케이션 데이터 메시지 전송 시간의 1\~2배 이내에서 협상이 시작되어야 합니다.

Hello 요청을 보낸 후 서버는 후속 핸드셰이크 협상이 완료될 때까지 요청을 반복해서는 안 됩니다. 핸드셰이크 협상 상태에 있는 동안 Hello 요청을 받는 클라이언트는 단순히 메시지를 무시해야 합니다.

Hello 요청 메시지의 구조는 다음과 같습니다.

```text
        struct { } HelloRequest;
```

---
##### **5.6.1.2.  Client Hello**

클라이언트가 서버에 처음 연결할 때 첫 번째 메시지로 클라이언트 hello를 보내야 합니다. 또한 클라이언트는 기존 연결에서 보안 매개변수를 재협상하기 위해 Hello 요청에 대한 응답으로 또는 자체 이니셔티브에서 클라이언트 Hello를 보낼 수 있습니다. 클라이언트 안녕하세요 메시지는 나중에 프로토콜에서 사용되는 임의의 구조를 포함합니다.

```text
      struct {
          uint32 gmt_unix_time;
          opaque random_bytes[28];
      } Random;
```

gmt\_unix\_time: 발신자의 내부 시계에 따른 표준 UNIX 32비트 형식의 현재 시간 및 날짜입니다. 기본 SSL 프로토콜에서는 시계를 올바르게 설정할 필요가 없습니다. 더 높은 수준 또는 응용 프로그램 프로토콜은 추가 요구 사항을 정의할 수 있습니다.

random\_bytes: 보안 난수로 생성된 28바이트

- 발전기.

클라이언트 헬로 메시지에는 가변 길이 세션 식별자가 포함됩니다. 비어 있지 않은 경우 값은 클라이언트가 재사용하려는 보안 매개변수가 있는 동일한 클라이언트와 서버 간의 세션을 식별합니다. 세션 식별자는 이전 연결, 이 연결 또는 현재 활성화된 다른 연결에서 온 것일 수 있습니다. 두 번째 옵션은 클라이언트가 연결의 임의 구조 및 파생된 값만 업데이트하려는 경우에 유용하고 세 번째 옵션은 전체 핸드셰이크 프로토콜을 반복하지 않고 여러 동시 독립 보안 ​​연결을 설정할 수 있도록 합니다. SessionID의 실제 내용은 서버에서 정의합니다.

```text
        opaque SessionID<0..32>;
```

경고: 서버는 세션 식별자에 기밀 정보를 배치하거나 가짜 세션 식별자의 내용으로 인해 보안이 침해되지 않도록 해야 합니다.

클라이언트 헬로 메시지에서 클라이언트에서 서버로 전달되는 CipherSuite 목록에는 클라이언트의 기본 설정\(첫 번째 선택이 먼저\)에 따라 클라이언트에서 지원하는 암호화 알고리즘의 조합이 포함되어 있습니다. 각 CipherSuite는 키 교환 알고리즘과 CipherSpec을 모두 정의합니다. 서버는 암호 그룹을 선택하거나 허용 가능한 선택 항목이 없으면 핸드셰이크 실패 경고를 반환하고 연결을 닫습니다.

```text
        uint8 CipherSuite[2];  /* Cryptographic suite selector */
```

클라이언트 hello에는 클라이언트가 지원하는 압축 알고리즘 목록이 포함되어 있으며 클라이언트의 기본 설정에 따라 정렬됩니다. 서버가 클라이언트가 지정한 항목을 지원하지 않으면 세션이 실패해야 합니다.

```text
        enum { null(0), (255) } CompressionMethod;
```

문제: 지원할 압축 방법을 조사 중입니다.

클라이언트 hello의 구조는 다음과 같습니다.

```text
        struct {
            ProtocolVersion client_version;
            Random random;
            SessionID session_id;
            CipherSuite cipher_suites<2..2^16-1>;
            CompressionMethod compression_methods<1..2^8-1>;
        } ClientHello;
```

client\_version: 클라이언트가 이 세션 동안 통신하고자 하는 SSL 프로토콜의 버전입니다. 클라이언트에서 지원하는 가장 최신\(가장 높은 값\) 버전이어야 합니다. 이 사양 버전의 경우 버전은 3.0입니다\(이전 버전과의 호환성에 대한 자세한 내용은 부록 E 참조\).

random: 클라이언트가 생성한 무작위 구조입니다.

session\_id: 클라이언트가 이 연결에 사용하려는 세션의 ID입니다. 사용 가능한 session\_id가 없거나 클라이언트가 새 보안 매개변수를 생성하려는 경우 이 필드는 비어 있어야 합니다.

cipher\_suites: 클라이언트가 지원하는 암호화 옵션 목록으로, 클라이언트의 첫 번째 기본 설정을 먼저 정렬합니다. session\_id 필드가 비어 있지 않은 경우\(세션 재개 요청을 의미\) 이 벡터에는 적어도 해당 세션의 cipher\_suite가 포함되어야 합니다. 값은 부록 A.6에 정의되어 있습니다.

compression\_methods: 클라이언트 기본 설정에 따라 정렬된 클라이언트에서 지원하는 압축 방법 목록입니다. session\_id 필드가 비어 있지 않은 경우\(세션 재개 요청을 의미\) 이 벡터에는 적어도 해당 세션의 compression\_method가 포함되어야 합니다. 모든 구현은 CompressionMethod.null을 지원해야 합니다.

클라이언트 Hello 메시지를 보낸 후 클라이언트는 서버 Hello 메시지를 기다립니다. hello 요청을 제외하고 서버에서 반환된 다른 모든 핸드셰이크 메시지는 치명적인 오류로 처리됩니다.

구현 참고 사항: 완료된 메시지가 전송되기 전에는 애플리케이션 데이터가 전송되지 않을 수 있습니다. 전송된 애플리케이션 데이터는 유효한 완료 메시지가 수신될 때까지 안전하지 않은 것으로 알려져 있습니다. 이 절대 제한은 이 연결에 현재 null이 아닌 암호화가 있는 경우 완화됩니다.

전방 호환성 참고: 전방 호환성을 위해 클라이언트 Hello 메시지에 압축 방법 뒤에 추가 데이터를 포함하는 것이 허용됩니다. 이 데이터는 핸드셰이크 해시에 포함되어야 하지만 그렇지 않으면 무시되어야 합니다.

---
##### **5.6.1.3.  Server Hello**

서버는 클라이언트 hello 메시지를 처리하고 handshake\_failure 경고 또는 서버 hello 메시지로 응답합니다.

```text
        struct {
            ProtocolVersion server_version;
            Random random;
            SessionID session_id;
            CipherSuite cipher_suite;
            CompressionMethod compression_method;
        } ServerHello;
```

server\_version: 이 필드에는 클라이언트 hello에서 클라이언트가 제안한 것 중 낮은 값과 서버에서 지원하는 가장 높은 값이 포함됩니다. 이 사양 버전의 경우 버전은 3.0입니다\(이전 버전과의 호환성에 대한 자세한 내용은 부록 E 참조\).

random: 이 구조는 서버에서 생성되며 ClientHello.random과 달라야 합니다.

session\_id: 이 연결에 해당하는 세션의 ID입니다. ClientHello.session\_id가 비어 있지 않은 경우 서버는 세션 캐시에서 일치 항목을 찾습니다. 일치하는 항목이 있고 서버가 지정된 세션 상태를 사용하여 새 연결을 설정하려는 경우 서버는 클라이언트가 제공한 것과 동일한 값으로 응답합니다. 이는 재개된 세션을 나타내며 당사자가 완료된 메시지로 직접 진행해야 함을 나타냅니다. 그렇지 않으면 이 필드에는 새 세션을 식별하는 다른 값이 포함됩니다. 서버는 세션이 캐시되지 않으므로 재개할 수 없음을 나타내기 위해 빈 session\_id를 반환할 수 있습니다.

cipher\_suite: ClientHello.cipher\_suites의 목록에서 서버가 선택한 단일 암호 제품군입니다. 재개된 세션의 경우 이 필드는 재개 중인 세션 상태의 값입니다.

compression\_method: ClientHello.compression\_methods의 목록에서 서버가 선택한 단일 압축 알고리즘입니다. 재개된 세션의 경우 이 필드는 재개된 세션 상태의 값입니다.

---
#### **5.6.2.  Server Certificate**

서버가 인증되어야 하는 경우\(일반적인 경우\) 서버는 server hello 메시지 바로 다음에 인증서를 보냅니다. 인증서 유형은 선택한 암호 그룹의 키 교환 알고리즘에 적합해야 하며 일반적으로 X.509.v3 인증서\(또는 FORTEZZA\(tm\) \[FOR\]의 경우 수정된 X.509 인증서\)입니다. 인증서 요청 메시지에 대한 클라이언트의 응답에 동일한 메시지 유형이 사용됩니다.

```text
        opaque ASN.1Cert<1..2^24-1>;
        struct {
            ASN.1Cert certificate_list<1..2^24-1>;
        } Certificate;
```

certificate\_list: X.509.v3의 시퀀스\(체인\)입니다.

- 인증서, 발신인의 인증서를 순서대로 정렬한 다음 모든 인증 기관 인증서가 순서대로 위쪽으로 진행됩니다.

참고: PKCS #6\[PKCS6\] 확장 인증서가 사용되지 않기 때문에 PKCS #7\[PKCS7\]은 인증서 벡터의 형식으로 사용되지 않습니다. 또한 PKCS #7은 시퀀스가 ​​아닌 세트를 정의하므로 목록 구문 분석 작업이 더 어려워집니다.

---
#### **5.6.3.  Server Key Exchange Message**

서버 키 교환 메시지는 인증서가 없거나 서명에만 사용되는 인증서\(예: DSS\[DSS\] 인증서, 서명 전용 RSA\[RSA\] 인증서\)가 있거나 FORTEZZA KEA 키 교환이 사용되는 경우 서버에서 전송됩니다. 서버 인증서에 Diffie-Hellman \[DH1\] 매개변수가 포함된 경우 이 메시지는 사용되지 않습니다.

참고: 현행 미국 수출법에 따르면 512비트보다 큰 RSA 계수는 미국에서 수출되는 소프트웨어의 키 교환에 사용할 수 없습니다. 이 메시지와 함께 더 큰 RSA 키는 키 교환을 위해 임시로 더 짧은 RSA 키에 서명하기 위한 서명 전용 인증서로 사용될 수 있습니다.

```text
        enum { rsa, diffie_hellman, fortezza_kea }
               KeyExchangeAlgorithm;

        struct {
            opaque rsa_modulus<1..2^16-1>;
            opaque rsa_exponent<1..2^16-1>;
        } ServerRSAParams;
```

rsa\_modulus: 서버의 임시 RSA 키 계수입니다.

rsa\_exponent: 서버 임시 RSA 키의 공개 지수.

```text
        struct {
            opaque dh_p<1..2^16-1>;
            opaque dh_g<1..2^16-1>;
            opaque dh_Ys<1..2^16-1>;
        } ServerDHParams;     /* Ephemeral DH parameters */
```

dh\_p: Diffie-Hellman 연산에 사용되는 프라임 모듈러스.

dh\_g: Diffie-Hellman 작업에 사용되는 생성기입니다.

dh\_Ys: 서버의 Diffie-Hellman 공개 값\(gX mod p\).

```text
        struct {
            opaque r_s [128];
        } ServerFortezzaParams;
```

r\_s: FORTEZZA KEA\(키 교환 알고리즘\)의 서버 난수.

```text
        struct {
            select (KeyExchangeAlgorithm) {
                case diffie_hellman:
                    ServerDHParams params;
                    Signature signed_params;
                case rsa:
                    ServerRSAParams params;
                    Signature signed_params;
                case fortezza_kea:
                    ServerFortezzaParams params;
            };
        } ServerKeyExchange;
```

params: 서버의 키 교환 매개변수.

signed\_params: 해당 해시에 적절한 서명이 적용된 해당 params 값의 해시입니다.

```text
   md5_hash:  MD5(ClientHello.random + ServerHello.random +
      ServerParams);

   sha_hash:  SHA(ClientHello.random + ServerHello.random +
      ServerParams);

        enum { anonymous, rsa, dsa } SignatureAlgorithm;

        digitally-signed struct {
            select(SignatureAlgorithm) {
                case anonymous: struct { };
                case rsa:
                    opaque md5_hash[16];
                    opaque sha_hash[20];
                case dsa:
                    opaque sha_hash[20];
            };
        } Signature;
```

---
#### **5.6.4.  Certificate Request**

비익명 서버는 선택한 암호 그룹에 적합한 경우 선택적으로 클라이언트에서 인증서를 요청할 수 있습니다.

```text
        enum {
            rsa_sign(1), dss_sign(2), rsa_fixed_dh(3), dss_fixed_dh(4),
            rsa_ephemeral_dh(5), dss_ephemeral_dh(6), fortezza_kea(20),
            (255)
        } ClientCertificateType;

        opaque DistinguishedName<1..2^16-1>;

        struct {
            ClientCertificateType certificate_types<1..2^8-1>;
            DistinguishedName certificate_authorities<3..2^16-1>;
        } CertificateRequest;
```

certificate\_types: 이 필드는 서버의 기본 설정 순서대로 정렬된 요청된 인증서 유형 목록입니다.

certificate\_authorities: 허용되는 인증 기관의 고유 이름 목록입니다.

참고: DistinguishedName은 \[X509\]에서 파생됩니다.

참고: 익명 서버가 클라이언트 식별을 요청하는 것은 치명적인 handshake\_failure 경고입니다.

---
#### **5.6.5.  Server Hello Done**

server hello done 메시지는 서버 hello 및 관련 메시지의 끝을 나타내기 위해 서버에서 보냅니다. 이 메시지를 보낸 후 서버는 클라이언트 응답을 기다립니다.

```text
        struct { } ServerHelloDone;
```

서버 헬로 완료 메시지를 수신하면 클라이언트는 필요한 경우 서버가 유효한 인증서를 제공했는지 확인하고 서버 헬로 매개변수가 허용 가능한지 확인해야 합니다.

---
#### **5.6.6.  Client Certificate**

이것은 클라이언트가 서버 헬로 완료 메시지를 수신한 후 보낼 수 있는 첫 번째 메시지입니다. 이 메시지는 서버가 인증서를 요청하는 경우에만 전송됩니다. 적절한 인증서를 사용할 수 없는 경우 클라이언트는 대신 no\_certificate 경고를 보내야 합니다. 이 경고는 경고일 뿐입니다. 그러나 클라이언트 인증이 필요한 경우 서버는 치명적인 핸드셰이크 실패 경고로 응답할 수 있습니다. 클라이언트 인증서는 섹션 5.6.2에 정의된 인증서를 사용하여 전송됩니다.

참고: 클라이언트 Diffie-Hellman 인증서는 서버에서 지정한 Diffie-Hellman 매개변수와 일치해야 합니다.

---
#### **5.6.7.  Client Key Exchange Message**

메시지 선택은 어떤 공개 키 알고리즘이 선택되었는지에 따라 다릅니다. KeyExchangeAlgorithm 정의에 대해서는 섹션 5.6.3을 참조하십시오.

```text
        struct {
            select (KeyExchangeAlgorithm) {
                case rsa: EncryptedPreMasterSecret;
                case diffie_hellman: ClientDiffieHellmanPublic;
                case fortezza_kea: FortezzaKeys;
            } exchange_keys;
        } ClientKeyExchange;
```

적절한 레코드 구조를 선택하기 위한 정보는 보류 중인 세션 상태에 있습니다\(섹션 5.1 참조\).

---
##### **5.6.7.1.  RSA Encrypted Premaster Secret Message**

키 동의 및 인증에 RSA를 사용하는 경우 클라이언트는 48바이트의 premaster secret을 생성하여 서버 인증서의 공개 키 또는 서버 키 교환 메시지의 임시 RSA 키로 암호화하여 암호화된 premaster로 결과를 보냅니다. 비밀 메시지.

```text
        struct {
            ProtocolVersion client_version;
            opaque random[46];
        } PreMasterSecret;
```

client\_version: 클라이언트에서 지원하는 최신\(최신\) 버전입니다. 이것은 버전 롤백 공격을 탐지하는 데 사용됩니다.

```text
   random:  46 securely-generated random bytes.

        struct {
            public-key-encrypted PreMasterSecret pre_master_secret;
        } EncryptedPreMasterSecret;
```

pre\_master\_secret: 이 무작위 값은 클라이언트에 의해 생성되며 섹션 6.1에 지정된 대로 마스터 비밀을 생성하는 데 사용됩니다.

---
##### **5.6.7.2.  FORTEZZA Key Exchange Message**

FORTEZZA에서 클라이언트는 FORTEZZA 키 교환 알고리즘\(KEA\)을 사용하여 토큰 암호화 키\(TEK\)를 파생합니다. 클라이언트의 KEA 계산은 클라이언트 토큰의 개인 매개변수와 함께 서버 인증서의 공개 키를 사용합니다. 클라이언트는 고유한 개인 매개변수를 사용하여 서버가 TEK를 생성하는 데 필요한 공용 매개변수를 보냅니다. 클라이언트는 세션 키를 생성하고 TEK를 사용하여 래핑하고 결과를 서버로 보냅니다. 클라이언트는 세션 키 및 TEK에 대한 IV를 생성하고 이들도 보냅니다. 클라이언트는 임의의 48바이트 premaster secret을 생성하고 TEK를 사용하여 암호화한 후 결과를 전송합니다.

```text
        struct {
            opaque y_c<0..128>;
            opaque r_c[128];
            opaque y_signature[40];
            opaque wrapped_client_write_key[12];
            opaque wrapped_server_write_key[12];
            opaque client_write_iv[24];
            opaque server_write_iv[24];
            opaque master_secret_iv[24];
            block-ciphered opaque encrypted_pre_master_secret[48];
        } FortezzaKeys;
```

y\_signature: y\_signature는 클라이언트의 DSS 개인 키로 서명된 KEA 공개 키의 서명입니다.

y\_c: KEA 계산을 위한 클라이언트의 Yc 값\(공개 키\)입니다. 클라이언트가 인증서를 보냈고 해당 KEA 공개 키가 적합한 경우 인증서에 이미 이 값이 포함되어 있으므로 이 값은 비어 있어야 합니다. 클라이언트가 적절한 공개 키 없이 인증서를 보낸 경우 y\_c가 사용되며 y\_signature는 클라이언트의 DSS 개인 키로 서명된 KEA 공개 키입니다. 이 값을 사용하려면 64\~128바이트 사이여야 합니다.

r\_c: KEA 계산을 위한 클라이언트의 Rc 값입니다.

wrap\_client\_write\_key: 이것은 TEK로 래핑된 클라이언트의 쓰기 키입니다.

Wrapped\_server\_write\_key: 이것은 TEK에 의해 래핑된 서버의 쓰기 키입니다.

client\_write\_iv: 클라이언트 쓰기 키의 IV입니다.

server\_write\_iv: 서버 쓰기 키의 IV입니다.

master\_secret\_iv: premaster secret을 암호화하는 데 사용되는 TEK의 IV입니다.

pre\_master\_secret: 섹션 6.1에 명시된 대로 클라이언트가 생성하고 마스터 비밀을 생성하는 데 사용되는 임의의 값입니다. 위 구조에서는 TEK를 사용하여 암호화합니다.

---
##### **5.6.7.3.  Client Diffie-Hellman Public Value**

이 구조는 클라이언트의 인증서에 아직 포함되지 않은 경우 클라이언트의 Diffie-Hellman 공개 값\(Yc\)을 전달합니다. Yc에 사용되는 인코딩은 열거된 PublicValueEncoding에 의해 결정됩니다.

```text
        enum { implicit, explicit } PublicValueEncoding;
```

암시적: 클라이언트 인증서에 이미 공개 값이 포함되어 있으면 암시적이며 Yc를 다시 보낼 필요가 없습니다.

명시적: Yc를 보내야 합니다.

```text
        struct {
            select (PublicValueEncoding) {
                case implicit: struct { };
                case explicit: opaque dh_Yc<1..2^16-1>;
            } dh_public;
        } ClientDiffieHellmanPublic;
```

dh\_Yc: 클라이언트의 Diffie-Hellman 공개 값\(Yc\).

---
#### **5.6.8.  Certificate Verify**

이 메시지는 클라이언트 인증서의 명시적 확인을 제공하는 데 사용됩니다. 이 메시지는 서명 기능이 있는 클라이언트 인증서\(즉, 고정 Diffie-Hellman 매개변수를 포함하는 인증서를 제외한 모든 인증서\) 다음에만 전송됩니다.

```text
          struct {
               Signature signature;
          } CertificateVerify;

        CertificateVerify.signature.md5_hash
                   MD5(master_secret + pad_2 +
                       MD5(handshake_messages + master_secret + pad_1));
        Certificate.signature.sha_hash
                   SHA(master_secret + pad_2 +
                       SHA(handshake_messages + master_secret + pad_1));
```

pad\_1: 5.2.3.1절에서 정의한 pad\_1과 동일하다.

pad\_2: 5.2.3.1절에서 정의한 pad\_2와 동일하다.

여기서 handshake\_messages는 client hello에서 시작하여 이 메시지를 포함하지 않는 모든 핸드셰이크 메시지를 나타냅니다.

---
#### **5.6.9.  Finished**

완료된 메시지는 항상 키 교환 및 인증 프로세스가 성공했는지 확인하기 위해 암호 사양 변경 메시지 직후에 전송됩니다. 완료된 메시지는 방금 협상된 알고리즘, 키 및 비밀로 첫 번째로 보호됩니다. 완료된 메시지에 대한 승인이 필요하지 않습니다. 당사자는 완성된 메시지를 보낸 후 즉시 암호화된 데이터를 보낼 수 있습니다. 완성된 메시지의 수신자는 내용이 올바른지 확인해야 합니다.

```text
        enum { client(0x434C4E54), server(0x53525652) } Sender;

        struct {
            opaque md5_hash[16];
            opaque sha_hash[20];
        } Finished;

   md5_hash:  MD5(master_secret + pad2 + MD5(handshake_messages + Sender
      + master_secret + pad1));

   sha_hash:  SHA(master_secret + pad2 + SHA(handshake_messages + Sender
      + master_secret + pad1));
```

handshake\_messages: 이 메시지를 포함하지 않는 모든 핸드셰이크 메시지의 모든 데이터입니다. 이는 핸드셰이크 레이어에서만 볼 수 있는 데이터이며 레코드 레이어 헤더는 포함하지 않습니다.

핸드셰이크의 적절한 지점에서 완료된 메시지 앞에 변경 암호 사양 메시지가 오지 않으면 치명적인 오류입니다.

서버에서 보낸 완료된 메시지에 포함된 해시는 Sender.server를 통합합니다. 클라이언트가 보낸 메시지는 Sender.client를 통합합니다. handshake\_messages 값은 client hello에서 시작하여 이 완료된 메시지를 포함하지 않는 모든 핸드셰이크 메시지를 포함합니다. 이는 인증서 확인 메시지\(전송된 경우\)를 포함하기 때문에 섹션 5.6.8의 handshake\_messages와 다를 수 있습니다.

참고: 암호 사양 변경 메시지는 핸드셰이크 메시지가 아니며 해시 계산에 포함되지 않습니다.

---
### **5.7.  Application Data Protocol**

애플리케이션 데이터 메시지는 레코드 레이어에 의해 전달되며 현재 연결 상태를 기반으로 단편화, 압축 및 암호화됩니다. 메시지는 레코드 레이어에 투명한 데이터로 처리됩니다.

---
## **6.  Cryptographic Computations**

키 교환, 인증, 암호화 및 MAC 알고리즘은 서버에서 선택한 cipher\_suite에 의해 결정되며 서버 hello 메시지에 표시됩니다.

---
### **6.1.  Asymmetric Cryptographic Computations**

비대칭 알고리즘은 핸드셰이크 프로토콜에서 당사자를 인증하고 공유 키와 비밀을 생성하는 데 사용됩니다.

Diffie-Hellman, RSA 및 FORTEZZA의 경우 동일한 알고리즘을 사용하여 pre\_master\_secret을 master\_secret으로 변환합니다. pre\_master\_secret은 master\_secret이 계산되면 메모리에서 삭제되어야 합니다.

```text
        master_secret =
          MD5(pre_master_secret + SHA('A' + pre_master_secret +
              ClientHello.random + ServerHello.random)) +
          MD5(pre_master_secret + SHA('BB' + pre_master_secret +
              ClientHello.random + ServerHello.random)) +
          MD5(pre_master_secret + SHA('CCC' + pre_master_secret +
              ClientHello.random + ServerHello.random));
```

---
#### **6.1.1.  RSA**

서버 인증 및 키 교환에 RSA를 사용하는 경우 클라이언트에서 48바이트 pre\_master\_secret을 생성하고 서버의 공개 키로 암호화하여 서버로 보냅니다. 서버는 개인 키를 사용하여 pre\_master\_secret을 해독합니다. 그런 다음 양 당사자는 위에 지정된 대로 pre\_master\_secret을 master\_secret으로 변환합니다.

RSA 디지털 서명은 PKCS #1 \[PKCS1\] 블록 유형 1을 사용하여 수행됩니다. RSA 공개 키 암호화는 PKCS #1 블록 유형 2를 사용하여 수행됩니다.

---
#### **6.1.2.  Diffie-Hellman**

기존의 Diffie-Hellman 계산이 수행됩니다. 협상된 키\(Z\)는 pre\_master\_secret으로 사용되며 위에서 지정한 대로 master\_secret으로 변환됩니다.

참고: Diffie-Hellman 매개변수는 서버에서 지정하며 일시적이거나 서버의 인증서 내에 포함될 수 있습니다.

---
#### **6.1.3.  FORTEZZA**

무작위 48바이트 pre\_master\_secret은 TEK 및 해당 IV에서 암호화되어 전송됩니다. 서버는 pre\_master\_secret을 해독하고 위에 지정된 대로 master\_secret으로 변환합니다. 암호화를 위한 대량 암호 키 및 IV는 클라이언트의 토큰에 의해 생성되고 키 교환 메시지에서 교환됩니다. master\_secret은 MAC 계산에만 사용됩니다.

---
### **6.2.  Symmetric Cryptographic Calculations and the CipherSpec**

SSL 레코드의 무결성을 암호화하고 확인하는 데 사용되는 기술은 현재 활성화된 CipherSpec에 의해 지정됩니다. 전형적인 예는 DES를 사용하여 데이터를 암호화하고 MD5를 사용하여 인증 코드를 생성하는 것입니다. 암호화 및 MAC 알고리즘은 SSL 핸드셰이크 프로토콜의 시작 부분에서 SSL\_NULL\_WITH\_NULL\_NULL로 설정되어 메시지 인증 또는 암호화가 수행되지 않음을 나타냅니다. 핸드셰이크 프로토콜은 보다 안전한 CipherSpec을 협상하고 암호화 키를 생성하는 데 사용됩니다.

---
#### **6.2.1.  The Master Secret**

레코드에서 보안 암호화 또는 무결성 확인을 수행하려면 먼저 클라이언트와 서버가 자신에게만 알려진 공유 비밀 정보를 생성해야 합니다. 이 값은 마스터 비밀이라고 하는 48바이트 수량입니다. 마스터 비밀은 암호화 및 MAC 계산을 위한 키와 비밀을 생성하는 데 사용됩니다. FORTEZZA와 같은 일부 알고리즘에는 암호화 키 생성을 위한 자체 절차가 있을 수 있습니다\(마스터 암호는 FORTEZZA에서 MAC 계산에만 사용됨\).

---
#### **6.2.2.  Converting the Master Secret into Keys and MAC Secrets**

마스터 비밀은 현재 CipherSpec에서 요구하는 MAC 비밀, 키 및 비수출 IV에 할당되는 일련의 보안 바이트로 해시됩니다\(부록 A.7 참조\). CipherSpecs에는 클라이언트 쓰기 MAC 비밀, 서버 쓰기 MAC 비밀, 클라이언트 쓰기 키, 서버 쓰기 키, 클라이언트 쓰기 IV 및 서버 쓰기 IV가 필요하며 마스터 비밀에서 순서대로 생성됩니다. 미사용

KeyExchange 메시지에서 전달되는 FORTEZZA 키와 같은 값은 비어 있습니다. 다음 입력은 키 정의 프로세스에 사용할 수 있습니다.

```text
          opaque MasterSecret[48]
          ClientHello.random
          ServerHello.random
```

키 및 MAC 비밀을 생성할 때 마스터 비밀은 엔트로피 소스로 사용되며 임의의 값은 내보낼 수 있는 암호에 대한 암호화되지 않은 솔트 자료 및 IV를 제공합니다.

키 자료를 생성하려면 다음을 계산하십시오.

```text
        key_block =
          MD5(master_secret + SHA(`A' + master_secret +
                                  ServerHello.random +
                                  ClientHello.random)) +
          MD5(master_secret + SHA(`BB' + master_secret +
                                  ServerHello.random +
                                  ClientHello.random)) +
          MD5(master_secret + SHA(`CCC' + master_secret +
                                  ServerHello.random +
                                  ClientHello.random)) + [...];
```

충분한 출력이 생성될 때까지. 그러면 다음과 같이 key\_block이 분할됩니다.

```text
        client_write_MAC_secret[CipherSpec.hash_size]
        server_write_MAC_secret[CipherSpec.hash_size]
        client_write_key[CipherSpec.key_material]
        server_write_key[CipherSpec.key_material]
        client_write_IV[CipherSpec.IV_size] /* non-export ciphers */
        server_write_IV[CipherSpec.IV_size] /* non-export ciphers */
```

여분의 key\_block 자료는 버려집니다.

내보낼 수 있는 암호화 알고리즘\(CipherSpec.is\_exportable이 true인 경우\)은 최종 쓰기 키를 파생시키기 위해 다음과 같은 추가 처리가 필요합니다.

```text
        final_client_write_key = MD5(client_write_key +
                                     ClientHello.random +
                                     ServerHello.random);
        final_server_write_key = MD5(server_write_key +
                                     ServerHello.random +
                                     ClientHello.random);
```

내보낼 수 있는 암호화 알고리즘은 임의 메시지에서 IV를 파생합니다.

```text
        client_write_IV = MD5(ClientHello.random + ServerHello.random);
        server_write_IV = MD5(ServerHello.random + ClientHello.random);
```

MD5 출력은 최하위 바이트를 버림으로써 적절한 크기로 잘립니다.

---
##### **6.2.2.1.  Export Key Generation Example**

SSL\_RSA\_EXPORT\_WITH\_RC2\_CBC\_40\_MD5에는 2개의 암호화 키 각각에 대해 5개의 임의 바이트와 각 MAC 키에 대해 16바이트가 필요하므로 총 42바이트의 키 자료가 필요합니다. MD5는 호출당 16바이트의 출력을 생성하므로 MD5에 대한 세 번의 호출이 필요합니다. MD5 출력은 48바이트 key\_block으로 연결되며 첫 번째 MD5 호출은 0에서 15까지의 바이트를 제공하고 두 번째는 16에서 31까지의 바이트를 제공합니다. .

```text
        client_write_MAC_secret = key_block[0..15]
        server_write_MAC_secret = key_block[16..31]
        client_write_key      = key_block[32..36]
        server_write_key      = key_block[37..41]
        final_client_write_key = MD5(client_write_key +
                                     ClientHello.random +
                                     ServerHello.random)[0..15];
        final_server_write_key = MD5(server_write_key +
                                     ServerHello.random +
                                     ClientHello.random)[0..15];
        client_write_IV = MD5(ClientHello.random +
                              ServerHello.random)[0..7];
        server_write_IV = MD5(ServerHello.random +
                              ClientHello.random)[0..7];
```

---
## **7.  Security Considerations**

```text
   See Appendix F.
```

---
## **8.  Informative References**

\[DH1\] Diffie, W. 및 M. Hellman, "새로운 방향

- 암호화", 정보 이론 V. IT-22에 관한 IEEE 트랜잭션, n. 6, pp. 74-84, 1977년 6월.

```text
   [SSL-2]    Hickman, K., "The SSL Protocol", February 1995.
```

\[3DES\] Tuchman, W., "Hellman은 DES에 대한 지름길 솔루션을 제공하지 않습니다", IEEE Spectrum, v. 16, n. 7, 40-41페이지, 1979년 7월.

\[DES\] ANSI X3.106, "정보 시스템에 대한 미국 국가 표준 - 데이터 링크 암호화", 미국 표준 협회, 1983.

\[DSS\] NIST FIPS PUB 186, "디지털 서명 표준", 국립 표준 기술 연구소 미국 상무부, 1994년 5월.

```text
   [FOR]      NSA X22, "FORTEZZA: Application Implementers Guide",
              Document # PD4002103-1.01, April 1995.
```

\[RFC0959\] Postel, J. 및 J. Reynolds, "파일 전송 프로토콜", STD 9, RFC 959, 1985년 10월.

```text
   [RFC0791]  Postel, J., "Internet Protocol", STD 5, RFC 791,
              September 1981.
```

\[RFC1945\] Berners-Lee, T., Fielding, R. 및 H. Nielsen, "Hypertext Transfer Protocol -- HTTP/1.0", RFC 1945, 1996년 5월.

```text
   [RFC1321]  Rivest, R., "The MD5 Message-Digest Algorithm", RFC 1321,
              April 1992.

   [RFC0793]  Postel, J., "Transmission Control Protocol", STD 7,
              RFC 793, September 1981.
```

\[RFC0854\] Postel, J. 및 J. Reynolds, "텔넷 프로토콜

- 사양", STD 8, RFC 854, 1983년 5월.

```text
   [RFC1832]  Srinivasan, R., "XDR: External Data Representation
              Standard", RFC 1832, August 1995.
```

\[RFC2104\] Krawczyk, H., Bellare, M. 및 R. Canetti, "HMAC: 메시지 인증을 위한 키 해싱", RFC 2104, 1997년 2월.

\[IDEA\] Lai, X., "On the Design and Security of Block Ciphers", ETH Series in Information Processing, v. 1, Konstanz: Hartung-Gorre Verlag, 1992.

```text
   [PKCS1]    RSA Laboratories, "PKCS #1: RSA Encryption Standard
              version 1.5", November 1993.

   [PKCS6]    RSA Laboratories, "PKCS #6: RSA Extended Certificate
              Syntax Standard version 1.5", November 1993.

   [PKCS7]    RSA Laboratories, "PKCS #7: RSA Cryptographic Message
              Syntax Standard version 1.5", November 1993.
```

\[RSA\] Rivest, R., Shamir, A. 및 L. Adleman, "A Method for Obtaining Digital Signatures and Public-Key Cryptosystems", Communications of the ACM v. 21, n. 2페이지 120-126., 1978년 2월.

\[SCH\] Schneier, B., "적용된 암호화: 프로토콜,

- C의 알고리즘 및 소스 코드", John Wiley & Sons, 1994.

```text
   [SHA]      NIST FIPS PUB 180-1, "Secure Hash Standard", May 1994.

              National Institute of Standards and Technology, U.S.
              Department of Commerce, DRAFT

   [X509]     CCITT, "The Directory - Authentication Framework",
              Recommendation X.509 , 1988.

   [RSADSI]   RSA Data Security, Inc., "Unpublished works".
```

---
# **Appendix A.  Protocol Constant Values**

이 섹션에서는 프로토콜 유형 및 상수에 대해 설명합니다.

---
### **A.1.  Record Layer**

```text
        struct {
            uint8 major, minor;
        } ProtocolVersion;

        ProtocolVersion version = { 3,0 };

        enum {
            change_cipher_spec(20), alert(21), handshake(22),
            application_data(23), (255)
        } ContentType;

        struct {
            ContentType type;
            ProtocolVersion version;
            uint16 length;
            opaque fragment[SSLPlaintext.length];
        } SSLPlaintext;

        struct {
            ContentType type;
            ProtocolVersion version;
            uint16 length;
            opaque fragment[SSLCompressed.length];
        } SSLCompressed;

        struct {
            ContentType type;
            ProtocolVersion version;
            uint16 length;
            select (CipherSpec.cipher_type) {
                case stream: GenericStreamCipher;
                case block:  GenericBlockCipher;
            } fragment;
        } SSLCiphertext;

        stream-ciphered struct {
            opaque content[SSLCompressed.length];
            opaque MAC[CipherSpec.hash_size];
        } GenericStreamCipher;

        block-ciphered struct {
            opaque content[SSLCompressed.length];

            opaque MAC[CipherSpec.hash_size];
            uint8 padding[GenericBlockCipher.padding_length];
            uint8 padding_length;
        } GenericBlockCipher;
```

---
### **A.2.  Change Cipher Specs Message**

```text
        struct {
            enum { change_cipher_spec(1), (255) } type;
        } ChangeCipherSpec;
```

---
### **A.3.  Alert Messages**

```text
        enum { warning(1), fatal(2), (255) } AlertLevel;

        enum {
            close_notify(0),
            unexpected_message(10),
            bad_record_mac(20),
            decompression_failure(30),
            handshake_failure(40),
            no_certificate(41),
            bad_certificate(42),
            unsupported_certificate(43),
            certificate_revoked(44),
            certificate_expired(45),
            certificate_unknown(46),
            illegal_parameter (47),
            (255)
        } AlertDescription;

        struct {
            AlertLevel level;
            AlertDescription description;
        } Alert;
```

---
### **A.4.  Handshake Protocol**

```text
      enum {
          hello_request(0), client_hello(1), server_hello(2),
          certificate(11), server_key_exchange (12),
          certificate_request(13), server_done(14),
          certificate_verify(15), client_key_exchange(16),
          finished(20), (255)
      } HandshakeType;

        struct {
            HandshakeType msg_type;
            uint24 length;
            select (HandshakeType) {
                case hello_request: HelloRequest;
                case client_hello: ClientHello;
                case server_hello: ServerHello;
                case certificate: Certificate;
                case server_key_exchange: ServerKeyExchange;
                case certificate_request: CertificateRequest;
                case server_done: ServerHelloDone;
                case certificate_verify: CertificateVerify;
                case client_key_exchange: ClientKeyExchange;
                case finished: Finished;
            } body;
        } Handshake;
```

---
#### **A.4.1.  Hello Messages**

```text
        struct { } HelloRequest;

        struct {
            uint32 gmt_unix_time;
            opaque random_bytes[28];
        } Random;

        opaque SessionID<0..32>;

        uint8 CipherSuite[2];

        enum { null(0), (255) } CompressionMethod;

        struct {
            ProtocolVersion client_version;
            Random random;
            SessionID session_id;
            CipherSuite cipher_suites<0..2^16-1>;
            CompressionMethod compression_methods<0..2^8-1>;

        } ClientHello;

        struct {
            ProtocolVersion server_version;
            Random random;
            SessionID session_id;
            CipherSuite cipher_suite;
            CompressionMethod compression_method;
        } ServerHello;
```

---
#### **A.4.2.  Server Authentication and Key Exchange Messages**

```text
        opaque ASN.1Cert<2^24-1>;

        struct {
            ASN.1Cert certificate_list<1..2^24-1>;
        } Certificate;

        enum { rsa, diffie_hellman, fortezza_kea } KeyExchangeAlgorithm;

        struct {
            opaque RSA_modulus<1..2^16-1>;
            opaque RSA_exponent<1..2^16-1>;
        } ServerRSAParams;

        struct {
            opaque DH_p<1..2^16-1>;
            opaque DH_g<1..2^16-1>;
            opaque DH_Ys<1..2^16-1>;
        } ServerDHParams;

        struct {
            opaque r_s [128]
        } ServerFortezzaParams

        struct {
            select (KeyExchangeAlgorithm) {
                case diffie_hellman:
                    ServerDHParams params;
                    Signature signed_params;
                case rsa:
                    ServerRSAParams params;
                    Signature signed_params;
                case fortezza_kea:
                    ServerFortezzaParams params;
            };
        } ServerKeyExchange;

        enum { anonymous, rsa, dsa } SignatureAlgorithm;

        digitally-signed struct {
            select(SignatureAlgorithm) {
                case anonymous: struct { };
                case rsa:
                    opaque md5_hash[16];
                    opaque sha_hash[20];
                case dsa:
                    opaque sha_hash[20];
            };
        } Signature;

        enum {
            RSA_sign(1), DSS_sign(2), RSA_fixed_DH(3),
            DSS_fixed_DH(4), RSA_ephemeral_DH(5), DSS_ephemeral_DH(6),
            FORTEZZA_MISSI(20), (255)
        } CertificateType;

        opaque DistinguishedName<1..2^16-1>;

        struct {
            CertificateType certificate_types<1..2^8-1>;
            DistinguishedName certificate_authorities<3..2^16-1>;
        } CertificateRequest;

        struct { } ServerHelloDone;
```

---
### **A.5.  Client Authentication and Key Exchange Messages**

```text
        struct {
            select (KeyExchangeAlgorithm) {
                case rsa: EncryptedPreMasterSecret;
                case diffie_hellman: DiffieHellmanClientPublicValue;
                case fortezza_kea: FortezzaKeys;
            } exchange_keys;
        } ClientKeyExchange;

        struct {
            ProtocolVersion client_version;
            opaque random[46];
        } PreMasterSecret;

        struct {
            public-key-encrypted PreMasterSecret pre_master_secret;
        } EncryptedPreMasterSecret;

        struct {
            opaque y_c<0..128>;
            opaque r_c[128];
            opaque y_signature[40];
            opaque wrapped_client_write_key[12];
            opaque wrapped_server_write_key[12];
            opaque client_write_iv[24];
            opaque server_write_iv[24];
            opaque master_secret_iv[24];
            opaque encrypted_preMasterSecret[48];
        } FortezzaKeys;

        enum { implicit, explicit } PublicValueEncoding;

        struct {
            select (PublicValueEncoding) {
                case implicit: struct {};
                case explicit: opaque DH_Yc<1..2^16-1>;
            } dh_public;
        } ClientDiffieHellmanPublic;

        struct {
            Signature signature;
        } CertificateVerify;
```

---
#### **A.5.1.  Handshake Finalization Message**

```text
        struct {
            opaque md5_hash[16];
            opaque sha_hash[20];
        } Finished;
```

---
### **A.6.  The CipherSuite**

다음 값은 클라이언트 hello 및 server hello 메시지에 사용되는 CipherSuite 코드를 정의합니다.

CipherSuite는 SSL 버전 3.0에서 지원되는 암호 사양을 정의합니다.

```text
     CipherSuite SSL_NULL_WITH_NULL_NULL                = { 0x00,0x00 };
```

다음 CipherSuite 정의에서는 서버가 키 교환에 사용할 수 있는 RSA 인증서를 제공해야 합니다. 서버는 인증서 요청 메시지에서 RSA 또는 DSS 서명 가능 인증서를 요청할 수 있습니다.

```text
     CipherSuite SSL_RSA_WITH_NULL_MD5                  = { 0x00,0x01 };
     CipherSuite SSL_RSA_WITH_NULL_SHA                  = { 0x00,0x02 };
     CipherSuite SSL_RSA_EXPORT_WITH_RC4_40_MD5         = { 0x00,0x03 };
     CipherSuite SSL_RSA_WITH_RC4_128_MD5               = { 0x00,0x04 };
     CipherSuite SSL_RSA_WITH_RC4_128_SHA               = { 0x00,0x05 };
     CipherSuite SSL_RSA_EXPORT_WITH_RC2_CBC_40_MD5     = { 0x00,0x06 };
     CipherSuite SSL_RSA_WITH_IDEA_CBC_SHA              = { 0x00,0x07 };
     CipherSuite SSL_RSA_EXPORT_WITH_DES40_CBC_SHA      = { 0x00,0x08 };
     CipherSuite SSL_RSA_WITH_DES_CBC_SHA               = { 0x00,0x09 };
     CipherSuite SSL_RSA_WITH_3DES_EDE_CBC_SHA          = { 0x00,0x0A };
```

다음 CipherSuite 정의는 서버 인증\(및 선택적으로 클라이언트 인증\) Diffie-Hellman에 사용됩니다. DH는 서버의 인증서에 인증 기관\(CA\)에서 서명한 Diffie-Hellman 매개변수가 포함된 암호화 제품군을 나타냅니다. DHE는 임시 Diffie-Hellman을 나타내며 Diffie-Hellman 매개변수는 CA에서 서명한 DSS 또는 RSA 인증서로 서명됩니다. 사용된 서명 알고리즘은 DH 또는 DHE 매개변수 뒤에 지정됩니다. 모든 경우에 클라이언트는 동일한 유형의 인증서를 가지고 있어야 하며 서버에서 선택한 Diffie-Hellman 매개변수를 사용해야 합니다.

```text
     CipherSuite SSL_DH_DSS_EXPORT_WITH_DES40_CBC_SHA   = { 0x00,0x0B };
     CipherSuite SSL_DH_DSS_WITH_DES_CBC_SHA            = { 0x00,0x0C };
     CipherSuite SSL_DH_DSS_WITH_3DES_EDE_CBC_SHA       = { 0x00,0x0D };
     CipherSuite SSL_DH_RSA_EXPORT_WITH_DES40_CBC_SHA   = { 0x00,0x0E };
     CipherSuite SSL_DH_RSA_WITH_DES_CBC_SHA            = { 0x00,0x0F };
     CipherSuite SSL_DH_RSA_WITH_3DES_EDE_CBC_SHA       = { 0x00,0x10 };
     CipherSuite SSL_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA  = { 0x00,0x11 };
     CipherSuite SSL_DHE_DSS_WITH_DES_CBC_SHA           = { 0x00,0x12 };
     CipherSuite SSL_DHE_DSS_WITH_3DES_EDE_CBC_SHA      = { 0x00,0x13 };
     CipherSuite SSL_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA  = { 0x00,0x14 };
     CipherSuite SSL_DHE_RSA_WITH_DES_CBC_SHA           = { 0x00,0x15 };
     CipherSuite SSL_DHE_RSA_WITH_3DES_EDE_CBC_SHA      = { 0x00,0x16 };
```

다음 암호 그룹은 어느 당사자도 인증되지 않은 완전히 익명의 Diffie-Hellman 통신에 사용됩니다. 이 모드는 중간자 공격에 취약하므로 사용하지 않는 것이 좋습니다.

```text
     CipherSuite SSL_DH_anon_EXPORT_WITH_RC4_40_MD5     = { 0x00,0x17 };
     CipherSuite SSL_DH_anon_WITH_RC4_128_MD5           = { 0x00,0x18 };
     CipherSuite SSL_DH_anon_EXPORT_WITH_DES40_CBC_SHA  = { 0x00,0x19 };
     CipherSuite SSL_DH_anon_WITH_DES_CBC_SHA           = { 0x00,0x1A };
     CipherSuite SSL_DH_anon_WITH_3DES_EDE_CBC_SHA      = { 0x00,0x1B };
```

최종 암호화 스위트는 FORTEZZA 토큰용입니다.

```text
     CipherSuite SSL_FORTEZZA_KEA_WITH_NULL_SHA         = { 0X00,0X1C };
     CipherSuite SSL_FORTEZZA_KEA_WITH_FORTEZZA_CBC_SHA = { 0x00,0x1D };
     CipherSuite SSL_FORTEZZA_KEA_WITH_RC4_128_SHA      = { 0x00,0x1E };
```

참고: 첫 번째 바이트가 0xFF인 모든 암호 그룹은 비공개로 간주되며 로컬/실험 알고리즘을 정의하는 데 사용할 수 있습니다. 이러한 유형의 상호 운용성은 지역 문제입니다.

---
### **A.7.  The CipherSpec**

암호 스위트는 CipherSpec을 식별합니다. 이러한 구조는 SSL 세션 상태의 일부입니다. CipherSpec에는 다음이 포함됩니다.

```text
        enum { stream, block } CipherType;

        enum { true, false } IsExportable;

        enum { null, rc4, rc2, des, 3des, des40, fortezza }
            BulkCipherAlgorithm;

        enum { null, md5, sha } MACAlgorithm;

        struct {
            BulkCipherAlgorithm bulk_cipher_algorithm;
            MACAlgorithm mac_algorithm;
            CipherType cipher_type;
            IsExportable is_exportable
            uint8 hash_size;
            uint8 key_material;
            uint8 IV_size;
        } CipherSpec;
```

---
# **Appendix B.  Glossary**

애플리케이션 프로토콜: 애플리케이션 프로토콜은 일반적으로 전송 계층 바로 위에 있는 프로토콜입니다\(예: TCP/IP \[RFC0793\]/\[RFC0791\]\). 예를 들면 HTTP\[RFC1945\], TELNET\[RFC0959\], FTP\[RFC0854\] 및 SMTP가 있습니다.

```text
   asymmetric cipher:  See public key cryptography.
```

인증: 인증은 한 엔터티가 다른 엔터티의 신원을 확인하는 기능입니다.

블록 암호: 블록 암호는 블록이라고 하는 비트 그룹의 일반 텍스트에서 작동하는 알고리즘입니다. 64비트는 일반적인 블록 크기입니다.

대량 암호: 대량의 데이터를 암호화하는 데 사용되는 대칭 암호화 알고리즘입니다.

CBC\(Cipher Block Chaining\) 모드: CBC는 블록 암호로 암호화된 모든 평문 블록이 먼저 이전 암호문 블록\(또는 첫 번째 블록의 경우 초기화 벡터\)과 배타적 논리합을 하는 모드입니다.

인증서: X.509 프로토콜\(일명 ISO

- 인증 프레임워크\) 인증서는 신뢰할 수 있는 인증 기관에서 할당하고 당사자의 신원 확인을 제공하며 공개 키를 제공할 수도 있습니다.

클라이언트: 서버에 대한 연결을 시작하는 애플리케이션 엔터티입니다.

클라이언트 쓰기 키: 클라이언트가 쓴 데이터를 암호화하는 데 사용되는 키입니다.

클라이언트 쓰기 MAC 비밀: 클라이언트가 작성한 데이터를 인증하는 데 사용되는 비밀 데이터입니다.

연결: 연결은 적절한 유형의 서비스를 제공하는 전송\(OSI 계층화 모델 정의에서\)입니다. SSL의 경우 이러한 연결은 피어 투 피어 관계입니다. 연결은 일시적입니다. 모든 연결은 하나의 세션과 연결됩니다.

데이터 암호화 표준\(DES\): DES는 매우 널리 사용되는 대칭 암호화 알고리즘입니다. DES는 블록 암호 \[DES\] \[3DES\]입니다.

디지털 서명 표준: \(DSS\) NIST FIPS PUB 186, "디지털 서명 표준"에 정의된 NIST\(National Institute of Standards and Technology\)에서 승인한 디지털 서명 알고리즘을 포함한 디지털 서명을 위한 표준입니다. 상업.

디지털 서명: 디지털 서명은 공개 키를 사용합니다.

- 인증할 수 있고 위조하거나 부인하기 어려운 데이터의 서명을 생성하는 암호화 및 단방향 해시 기능.

FORTEZZA: 암호화와 디지털 서명을 모두 제공하는 PCMCIA 카드입니다.

핸드셰이크: 트랜잭션의 매개변수를 설정하는 클라이언트와 서버 간의 초기 협상입니다.

IV\(초기화 벡터\): CBC 모드에서 블록 암호를 사용하는 경우 초기화 벡터는 암호화 전에 첫 번째 평문 블록과 배타적 논리합을 합니다.

IDEA: Xuejia Lai와 James Massey\[IDEA\]가 설계한 64비트 블록 암호입니다.

메시지 인증 코드\(MAC\): 메시지 인증 코드는 메시지와 일부 비밀 데이터에서 계산된 단방향 해시입니다. 그 목적은 메시지가 변경되었는지 감지하는 것입니다.

마스터 비밀: 암호화 키, MAC 비밀 및 IV를 생성하는 데 사용되는 보안 비밀 데이터입니다.

MD5: MD5\[RFC1321\]는 임의로 긴 데이터 스트림을 고정 크기의 다이제스트로 변환하는 보안 해싱 함수입니다.

공개 키 암호화: 2개의 키 암호를 사용하는 암호화 기술 클래스입니다. 공개 키로 암호화된 메시지는 연결된 개인 키로만 해독할 수 있습니다. 반대로 개인 키로 서명된 메시지는 공개 키로 확인할 수 있습니다.

단방향 해시 함수: 임의의 양의 데이터를 고정 길이 해시로 변환하는 단방향 변환입니다. 변환을 되돌리거나 충돌을 찾는 것은 계산적으로 어렵습니다. MD5 및 SHA는 단방향 해시 함수의 예입니다.

RC2, RC4: RSA Data Security, Inc.의 독점 벌크 암호\(출판되지 않은 작업이므로 이에 대한 적절한 참조가 없습니다. 그러나 \[RSADSI\] 참조\). RC2는 블록 암호이고 RC4는 스트림 암호입니다.

RSA: 암호화 또는 디지털 서명에 사용할 수 있는 널리 사용되는 공개 키 알고리즘입니다.

소금: 내보내기 암호화 키가 사전 계산 공격에 저항하도록 만드는 데 사용되는 비비밀 임의 데이터입니다.

서버: 서버는 클라이언트의 연결 요청에 응답하는 애플리케이션 엔터티입니다. 서버는 수동적이며 클라이언트의 요청을 기다립니다.

세션: SSL 세션은 클라이언트와 서버 간의 연결입니다. 세션은 핸드셰이크 프로토콜에 의해 생성됩니다. 세션은 여러 연결 간에 공유할 수 있는 암호화 보안 매개변수 세트를 정의합니다. 세션은 각 연결에 대한 새로운 보안 매개변수의 값비싼 협상을 피하기 위해 사용됩니다.

세션 식별자: 세션 식별자는 특정 세션을 식별하는 서버에서 생성된 값입니다.

서버 쓰기 키: 서버가 쓴 데이터를 암호화하는 데 사용되는 키입니다.

서버 쓰기 MAC 비밀: 서버에서 쓴 데이터를 인증하는 데 사용되는 비밀 데이터입니다.

SHA: 보안 해시 알고리즘은 FIPS PUB 180-1에 정의되어 있습니다. 20바이트 출력\[SHA\]을 생성합니다.

스트림 암호: 키를 암호학적으로 강력한 키스트림으로 변환한 다음 일반 텍스트와 배타적 OR로 변환하는 암호화 알고리즘입니다.

```text
   symmetric cipher:  See bulk cipher.
```

---
# **Appendix C.  CipherSuite Definitions**

```text
CipherSuite                  Is         Key            Cipher       Hash
                             Exportable Exchange

SSL_NULL_WITH_NULL_NULL               * NULL           NULL         NULL
SSL_RSA_WITH_NULL_MD5                 * RSA            NULL         MD5
SSL_RSA_WITH_NULL_SHA                 * RSA            NULL         SHA
SSL_RSA_EXPORT_WITH_RC4_40_MD5        * RSA_EXPORT     RC4_40       MD5
SSL_RSA_WITH_RC4_128_MD5                RSA            RC4_128      MD5
SSL_RSA_WITH_RC4_128_SHA                RSA            RC4_128      SHA
SSL_RSA_EXPORT_WITH_RC2_CBC_40_MD5    * RSA_EXPORT     RC2_CBC_40   MD5
SSL_RSA_WITH_IDEA_CBC_SHA               RSA            IDEA_CBC     SHA
SSL_RSA_EXPORT_WITH_DES40_CBC_SHA     * RSA_EXPORT     DES40_CBC    SHA
SSL_RSA_WITH_DES_CBC_SHA                RSA            DES_CBC      SHA
SSL_RSA_WITH_3DES_EDE_CBC_SHA           RSA            3DES_EDE_CBC SHA
SSL_DH_DSS_EXPORT_WITH_DES40_CBC_SHA  * DH_DSS_EXPORT  DES40_CBC    SHA
SSL_DH_DSS_WITH_DES_CBC_SHA             DH_DSS         DES_CBC      SHA
SSL_DH_DSS_WITH_3DES_EDE_CBC_SHA        DH_DSS         3DES_EDE_CBC SHA
SSL_DH_RSA_EXPORT_WITH_DES40_CBC_SHA  * DH_RSA_EXPORT  DES40_CBC    SHA
SSL_DH_RSA_WITH_DES_CBC_SHA             DH_RSA         DES_CBC      SHA
SSL_DH_RSA_WITH_3DES_EDE_CBC_SHA        DH_RSA         3DES_EDE_CBC SHA
SSL_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA * DHE_DSS_EXPORT DES40_CBC    SHA
SSL_DHE_DSS_WITH_DES_CBC_SHA            DHE_DSS        DES_CBC      SHA
SSL_DHE_DSS_WITH_3DES_EDE_CBC_SHA       DHE_DSS        3DES_EDE_CBC SHA
SSL_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA * DHE_RSA_EXPORT DES40_CBC    SHA
SSL_DHE_RSA_WITH_DES_CBC_SHA            DHE_RSA        DES_CBC      SHA
SSL_DHE_RSA_WITH_3DES_EDE_CBC_SHA       DHE_RSA        3DES_EDE_CBC SHA
SSL_DH_anon_EXPORT_WITH_RC4_40_MD5    * DH_anon_EXPORT RC4_40       MD5
SSL_DH_anon_WITH_RC4_128_MD5            DH_anon        RC4_128      MD5
SSL_DH_anon_EXPORT_WITH_DES40_CBC_SHA   DH_anon        DES40_CBC    SHA
SSL_DH_anon_WITH_DES_CBC_SHA            DH_anon        DES_CBC      SHA
SSL_DH_anon_WITH_3DES_EDE_CBC_SHA       DH_anon        3DES_EDE_CBC SHA
SSL_FORTEZZA_KEA_WITH_NULL_SHA          FORTEZZA_KEA   NULL         SHA
SSL_FORTEZZA_KEA_WITH_FORTEZZA_CBC_SHA  FORTEZZA_KEA   FORTEZZA_CBC SHA
SSL_FORTEZZA_KEA_WITH_RC4_128_SHA       FORTEZZA_KEA   RC4_128      SHA

   +----------------+------------------------------+-------------------+
   |  Key Exchange  |          Description         |   Key Size Limit  |
   |    Algorithm   |                              |                   |
   +----------------+------------------------------+-------------------+
   |     DHE_DSS    |     Ephemeral DH with DSS    |        None       |
   |                |          signatures          |                   |
   | DHE_DSS_EXPORT |     Ephemeral DH with DSS    |   DH = 512 bits   |
   |                |          signatures          |                   |
   |     DHE_RSA    |     Ephemeral DH with RSA    |        None       |
   |                |          signatures          |                   |
   | DHE_RSA_EXPORT |     Ephemeral DH with RSA    |   DH = 512 bits,  |
   |                |          signatures          |     RSA = none    |
   |     DH_anon    |  Anonymous DH, no signatures |        None       |
   | DH_anon_EXPORT |  Anonymous DH, no signatures |   DH = 512 bits   |
   |     DH_DSS     |       DH with DSS-based      |        None       |
   |                |         certificates         |                   |
   |  DH_DSS_EXPORT |       DH with DSS-based      |   DH = 512 bits   |
   |                |         certificates         |                   |
   |     DH_RSA     |       DH with RSA-based      |        None       |
   |                |         certificates         |                   |
   |  DH_RSA_EXPORT |       DH with RSA-based      |   DH = 512 bits,  |
   |                |         certificates         |     RSA = none    |
   |  FORTEZZA_KEA  |     FORTEZZA KEA. Details    |        N/A        |
   |                |          unpublished         |                   |
   |      NULL      |        No key exchange       |        N/A        |
   |       RSA      |       RSA key exchange       |        None       |
   |   RSA_EXPORT   |       RSA key exchange       |   RSA = 512 bits  |
   +----------------+------------------------------+-------------------+

                                  Table 1
```

키 크기 제한: 키 크기 제한은 내보낼 수 있는 암호 그룹에서 암호화에 합법적으로 사용할 수 있는 가장 큰 공개 키의 크기를 제공합니다.

```text
   +--------------+--------+-----+-------+-------+-------+------+------+
   | Cipher       | Cipher | IsE |  Key  |  Exp. | Effec |  IV  | Bloc |
   |              |  Type  | xpo | Mater |  Key  |  tive | Size |   k  |
   |              |        | rta |  ial  | Mater |  Key  |      | Size |
   |              |        | ble |       |  ial  |  Bits |      |      |
   +--------------+--------+-----+-------+-------+-------+------+------+
   | NULL         | Stream |  *  |   0   |   0   |   0   |   0  |  N/A |
   | FORTEZZA_CBC |  Block |     |   NA  |   12  |   96  |  20  |   8  |
   |              |        |     |  (**) |  (**) |  (**) | (**) |      |
   | IDEA_CBC     |  Block |     |   16  |   16  |  128  |   8  |   8  |
   | RC2_CBC_40   |  Block |  *  |   5   |   16  |   40  |   8  |   8  |
   | RC4_40       | Stream |  *  |   5   |   16  |   40  |   0  |  N/A |
   | RC4_128      | Stream |     |   16  |   16  |  128  |   0  |  N/A |
   | DES40_CBC    |  Block |  *  |   5   |   8   |   40  |   8  |   8  |
   | DES_CBC      |  Block |     |   8   |   8   |   56  |   8  |   8  |
   | 3DES_EDE_CBC |  Block |     |   24  |   24  |  168  |   8  |   8  |
   +--------------+--------+-----+-------+-------+-------+------+------+
```

\* IsExportable이 참임을 나타냅니다.

- \*\* FORTEZZA는 자체 키 및 IV 생성 알고리즘을 사용합니다.

```text
                                  Table 2
```

키 자료: 쓰기 키를 생성하는 데 사용되는 key\_block의 바이트 수입니다.

확장 키 자료: 암호화 알고리즘에 실제로 입력된 바이트 수입니다.

효과적인 키 비트: 암호화 루틴에 공급되는 키 자료에 얼마나 많은 엔트로피 자료가 있는지.

```text
               +---------------+-----------+--------------+
               | Hash Function | Hash Size | Padding Size |
               +---------------+-----------+--------------+
               |      NULL     |     0     |       0      |
               |      MD5      |     16    |      48      |
               |      SHA      |     20    |      40      |
               +---------------+-----------+--------------+

                                  Table 3
```

---
# **Appendix D.  Implementation Notes**

SSL 프로토콜은 많은 일반적인 보안 실수를 방지할 수 없습니다. 이 섹션에서는 구현자를 지원하기 위한 몇 가지 권장 사항을 제공합니다.

---
### **D.1.  Temporary RSA Keys**

미국 수출 제한은 암호화에 사용되는 RSA 키를 512비트로 제한하지만 서명 작업에 사용되는 RSA 키의 길이에는 제한을 두지 않습니다. 인증서는 종종 512비트보다 커야 합니다. 512비트 RSA 키는 가치가 높은 트랜잭션이나 장기 보안이 필요한 애플리케이션에 충분히 안전하지 않기 때문입니다. 일부 인증서는 서명 전용으로 지정되어 키 교환에 사용할 수 없습니다.

인증서의 공개 키를 암호화에 사용할 수 없는 경우 서버는 임시 RSA 키에 서명한 다음 교환합니다. 내보낼 수 있는 애플리케이션에서 임시 RSA 키는 최대 허용 길이\(즉, 512비트\)여야 합니다. 512비트 RSA 키는 비교적 안전하지 않기 때문에 자주 변경해야 합니다. 일반적인 전자 상거래 응용 프로그램의 경우 키를 매일 또는 500건의 트랜잭션마다 변경하고 가능하면 더 자주 변경하는 것이 좋습니다. 여러 트랜잭션에 동일한 임시 키를 사용할 수 있지만 사용할 때마다 서명해야 합니다.

RSA 키 생성은 시간이 많이 걸리는 프로세스입니다. 대부분의 경우 우선 순위가 낮은 프로세스에 키 생성 작업을 할당할 수 있습니다. 새 키가 완성될 때마다 기존 임시 키를 새 키로 교체할 수 있습니다.

---
### **D.2.  Random Number Generation and Seeding**

SSL에는 암호화된 보안 의사 난수 생성기\(PRNG\)가 필요합니다. PRNG를 설계하고 시드할 때 주의를 기울여야 합니다. 보안 해시 작업, 특히 MD5 및/또는 SHA를 기반으로 하는 PRNG는 허용되지만 난수 생성기 상태의 크기보다 더 많은 보안을 제공할 수 없습니다. \(예를 들어, MD5 기반 PRNG는 일반적으로 128비트의 상태를 제공합니다.\)

생산되는 시드 물질의 양을 추정하려면 각 시드 바이트에 예측할 수 없는 정보의 비트 수를 추가하십시오. 예를 들어 카운터 값의 총 크기가 16비트 이상인 경우에도 PC 호환 18.2Hz 타이머에서 가져온 키 입력 타이밍 값은 각각 1 또는 2개의 보안 비트를 제공합니다. 따라서 128비트 PRNG를 시드하려면 이러한 타이머 값이 약 100개 필요합니다.

참고: RSAREF 및 BSAFE 3.0 이전 버전의 시딩 기능은 순서에 독립적입니다. 예를 들어, 한 번에 하나씩 1000개의 시드 비트가 제공되면 시드 함수에 대한 1000개의 개별 호출에서 PRNG는 시드 데이터의 0 또는 1 시드 비트 수에만 의존하는 상태\(즉, , 1001개의 가능한 최종 상태가 있습니다\). BSAFE 또는 RSAREF를 사용하는 응용 프로그램은 적절한 시드를 보장하기 위해 특별한 주의를 기울여야 합니다.

---
### **D.3.  Certificates and Authentication**

구현은 인증서의 무결성을 확인할 책임이 있으며 일반적으로 인증서 해지 메시지를 지원해야 합니다. 신뢰할 수 있는 인증 기관\(CA\)의 적절한 서명을 보장하기 위해 인증서를 항상 확인해야 합니다. 신뢰할 수 있는 CA의 선택 및 추가는 매우 신중하게 수행해야 합니다. 사용자는 인증서 및 루트 CA에 대한 정보를 볼 수 있어야 합니다.

---
### **D.4.  CipherSuites**

SSL은 보안을 전혀 제공하지 않거나 최소한으로 제공하는 키 크기와 보안 수준을 포함하여 다양한 키 크기와 보안 수준을 지원합니다. 적절한 구현은 아마도 많은 암호 제품군을 지원하지 않을 것입니다. 예를 들어 40비트 암호화는 쉽게 깨지므로 강력한 보안이 필요한 구현에서는 40비트 키를 허용하지 않아야 합니다. 마찬가지로 익명의 Diffie-Hellman은 중간자 공격을 방지할 수 없기 때문에 사용하지 않는 것이 좋습니다. 애플리케이션은 또한 최소 및 최대 키 크기를 적용해야 합니다. 예를 들어 512비트 RSA 키 또는 서명이 포함된 인증서 체인은 보안 수준이 높은 애플리케이션에 적합하지 않습니다.

---
### **D.5.  FORTEZZA**

이 섹션에서는 FORTEZZA 하드웨어 암호화 시스템을 사용하는 암호 제품군에 대한 구현 세부 정보를 설명합니다.

---
#### **D.5.1.  Notes on Use of FORTEZZA Hardware**

FORTEZZA 하드웨어 사용과 관련된 모든 문제에 대한 완전한 설명은 이 문서의 범위를 벗어납니다. 그러나 언급할 가치가 있는 SSL의 몇 가지 특별한 요구 사항이 있습니다.

SSL은 전이중 프로토콜이기 때문에 읽기용과 쓰기용의 두 가지 암호화 상태를 유지해야 합니다. 또한 FORTEZZA 카드의 암호화 상태가 손실될 수 있는 여러 가지 상황이 있습니다. 이러한 이유로 레코드를 처리한 후 현재 암호화 상태를 저장하고 다음 처리 전에 로드하는 것이 좋습니다.

클라이언트는 TEK를 생성한 후 두 개의 MEK\(메시지 암호화 키\)도 생성합니다. 하나는 읽기용이고 다른 하나는 쓰기용입니다. 이러한 각 키를 생성한 후 클라이언트는 해당 IV를 생성한 다음 암호화 상태를 저장해야 합니다. 클라이언트는 또한 TEK를 사용하여 IV를 생성하고 premaster secret을 암호화합니다. 클라이언트 키 교환 메시지의 래핑된 키 및 암호화된 premaster secret과 함께 세 개의 IV가 모두 서버로 전송됩니다. 이 시점에서 TEK는 더 이상 필요하지 않으며 폐기될 수 있습니다.

서버 측에서 서버는 마스터 IV와 TEK를 사용하여 premaster secret을 해독합니다. 또한 래핑된 MEK를 카드에 로드합니다. 서버는 IV가 키와 일치하는지 확인하기 위해 두 IV를 모두 로드합니다. 그러나 카드는 IV를 로드한 후 암호화할 수 없기 때문에 서버는 서버 쓰기 키에 대한 새 IV를 생성해야 합니다. 이 IV는 폐기됩니다.

첫 번째 암호화된 레코드\(및 해당 레코드만\)를 암호화할 때 서버는 조각의 시작 부분에 8바이트의 임의 데이터를 추가합니다. 이 8바이트는 암호 해독 후 클라이언트에서 버립니다. 이것의 목적은 서로 다른 IV로 인해 발생하는 클라이언트와 서버의 상태를 동기화하는 것입니다.

---
#### **D.5.2.  FORTEZZA Cipher Suites**

5\) FORTEZZA\_NULL\_WITH\_NULL\_SHA: 서버 및 클라이언트 쓰기 키 및 IV 전송을 포함하여 전체 FORTEZZA 키 교환을 사용합니다.

---
#### **D.5.3.  FORTEZZA Session Resumption**

FORTEZZA 세션을 다시 시작할 수 있는 두 가지 가능성이 있습니다. 1\) FORTEZZA 세션을 다시 시작하지 마십시오. 2\) 이전에 협상된 키와 IV로 세션을 다시 시작합니다.

FORTEZZA 세션을 다시 시작하지 않음:

FORTEZZA 세션을 다시 시작하지 않는 클라이언트는 이전에 FORTEZZA 세션에서 ClientHello의 일부로 사용된 세션 ID를 보내면 안 됩니다. FORTEZZA 세션을 다시 시작하지 않는 서버는 협상된 세션이 FORTEZZA인 경우 ServerHello에서 이전 세션 ID를 보내면 안 됩니다.

세션을 다시 시작하십시오.

완전한 FORTEZZA 키 교환을 수행하지 않은 세션에서는 FORTEZZA를 다시 시작할 수 없습니다\(즉, 세션이 FORTEZZA에 대해 재협상된 RSA/RC4 세션인 경우 FORTEZZA를 다시 시작할 수 없음\). FORTEZZA 세션을 다시 시작하려면 MEK를 저장하고

이 세션에 대한 초기 키 교환의 IV를 가져오고 해당 세션의 새 연결에 재사용합니다. 권장되지는 않지만 가능합니다.

---
# **Appendix E.  Version 2.0 Backward Compatibility**

버전 2.0 서버를 지원하는 버전 3.0 클라이언트는 버전 2.0 클라이언트 Hello 메시지\[SSL-2\]를 보내야 합니다. 버전 3.0 서버는 클라이언트 hello 형식 중 하나를 수락해야 합니다. 버전 2.0 사양과의 유일한 차이점은 값이 3인 버전을 지정하는 기능과 CipherSpec에서 더 많은 암호화 유형에 대한 지원입니다.

경고: 버전 2.0 클라이언트 Hello 메시지를 보내는 기능은 서둘러 단계적으로 중단됩니다. 구현자는 가능한 한 빨리 진행하기 위해 모든 노력을 기울여야 합니다. 버전 3.0은 최신 버전으로 전환하기 위한 더 나은 메커니즘을 제공합니다.

다음 암호 사양은 SSL 버전 2.0에서 이월됩니다. 이들은 키 교환 및 인증에 RSA를 사용하는 것으로 가정합니다.

```text
        V2CipherSpec SSL_RC4_128_WITH_MD5          = { 0x01,0x00,0x80 };
        V2CipherSpec SSL_RC4_128_EXPORT40_WITH_MD5 = { 0x02,0x00,0x80 };
        V2CipherSpec SSL_RC2_CBC_128_CBC_WITH_MD5  = { 0x03,0x00,0x80 };
        V2CipherSpec SSL_RC2_CBC_128_CBC_EXPORT40_WITH_MD5
                                                   = { 0x04,0x00,0x80 };
        V2CipherSpec SSL_IDEA_128_CBC_WITH_MD5     = { 0x05,0x00,0x80 };
        V2CipherSpec SSL_DES_64_CBC_WITH_MD5       = { 0x06,0x00,0x40 };
        V2CipherSpec SSL_DES_192_EDE3_CBC_WITH_MD5 = { 0x07,0x00,0xC0 };
```

버전 3.0에 도입된 암호 사양은 아래 구문을 사용하여 버전 2.0 클라이언트 Hello 메시지에 포함될 수 있습니다. 첫 번째 바이트가 0인 V2CipherSpec 요소는 버전 2.0 서버에서 무시됩니다. 위의 V2CipherSpec 중 하나를 전송하는 클라이언트는 버전 3.0도 포함해야 합니다\(부록 A.6 참조\).

```text
        V2CipherSpec (see Version 3.0 name) = { 0x00, CipherSuite };
```

---
### **E.1.  Version 2 Client Hello**

버전 2.0 클라이언트 hello 메시지는 이 문서의 표현 모델을 사용하여 아래에 표현됩니다. 진정한 정의는 여전히 SSL 버전 2.0 사양으로 간주됩니다.

```text
        uint8 V2CipherSpec[3];

        struct {
            unit8 msg_type;
            Version version;
            uint16 cipher_spec_length;
            uint16 session_id_length;
            uint16 challenge_length;
            V2CipherSpec cipher_specs[V2ClientHello.cipher_spec_length];
            opaque session_id[V2ClientHello.session_id_length];
            Random challenge;
        } V2ClientHello;
```

session msg\_type: 이 필드는 version 필드와 함께 버전 2 클라이언트 hello 메시지를 식별합니다. 값은 일\(1\)이어야 합니다.

version: 클라이언트가 지원하는 프로토콜의 가장 높은 버전입니다\(ProtocolVersion.version과 같습니다. 부록 A.1 참조\).

cipher\_spec\_length: 이 필드는 cipher\_specs 필드의 총 길이입니다. 0일 수 없으며 V2CipherSpec 길이\(3\)의 배수여야 합니다.

session\_id\_length: 이 필드의 값은 0 또는 16이어야 합니다. 0이면 클라이언트가 새 세션을 생성합니다. 16이면 session\_id 필드에 16바이트의 세션 ID가 포함됩니다.

challenge\_length: 자신을 인증하기 위해 서버에 대한 클라이언트의 챌린지 길이\(바이트\)입니다. 이 값은 32여야 합니다.

cipher\_specs: 이것은 클라이언트가 사용할 의향이 있고 사용할 수 있는 모든 CipherSpec의 목록입니다. 서버에 허용되는 CipherSpec이 하나 이상 있어야 합니다.

session\_id: 이 필드의 길이가 0이 아닌 경우 클라이언트가 재개하려는 세션의 ID가 포함됩니다.

챌린지: 서버가 자신을 식별하기 위해 서버에 대한 클라이언트의 챌린지는 \(거의\) 임의 길이 임의입니다. 버전 3.0 서버는 이 버전 3.0 프로토콜에 지정된 대로 ClientHello.random 데이터\(필요한 경우 선행 0으로 채워짐\)가 되도록 챌린지 데이터를 올바르게 정당화합니다. 챌린지 길이가 32바이트보다 크면 마지막 32바이트만 사용됩니다. V3 서버가 챌린지 데이터가 16바이트 미만인 V2 ClientHello를 거부하는 것은 합법적이지만 필수는 아닙니다.

참고: SSL 3.0 세션 재개 요청은 SSL 3.0 클라이언트 hello를 사용해야 합니다.

---
### **E.2.  Avoiding Man-in-the-Middle Version Rollback**

SSL 버전 3.0 클라이언트가 버전 2.0 호환성 모드로 돌아가는 경우 특수 PKCS #1 블록 형식을 사용합니다. 이것은 버전 3.0 서버가 버전 3.0 가능 클라이언트와의 버전 2.0 세션을 거부하도록 수행됩니다.

버전 3.0 클라이언트가 버전 2.0 호환 모드에 있을 때 ENCRYPTED-KEY-DATA의 RSA 암호화를 위해 PKCS 패딩의 오른쪽\(최하위\) 8바이트\(패딩의 터미널 null 제외\)를 설정합니다. CLIENT-MASTER-KEY의 필드를 0x03으로 설정합니다\(다른 패딩 바이트는 임의임\). ENCRYPTED-KEY-DATA 필드를 해독한 후 SSL 3.0을 지원하는 서버는 이 8개의 패딩 바이트가 0x03인 경우 오류를 발행해야 합니다. 이렇게 채워진 블록을 수신하는 버전 2.0 서버는 정상적으로 진행됩니다.

---
# **Appendix F.  Security Analysis**

SSL 프로토콜은 비보안 채널을 통해 통신하는 클라이언트와 서버 간에 보안 연결을 설정하도록 설계되었습니다. 이 문서는 공격자가 상당한 계산 리소스를 가지고 있고 프로토콜 외부 소스에서 비밀 정보를 얻을 수 없다는 것을 포함하여 몇 가지 전통적인 가정을 합니다. 공격자는 통신 채널을 통해 전송된 메시지를 캡처, 수정, 삭제, 재생 및 변조할 수 있는 능력이 있다고 가정합니다. 이 부록에서는 다양한 공격에 저항하도록 SSL이 어떻게 설계되었는지 간략하게 설명합니다.

---
### **F.1.  Handshake Protocol**

핸드셰이크 프로토콜은 CipherSpec을 선택하고 MasterSecret을 생성하는 역할을 하며 보안 세션과 관련된 기본 암호화 매개변수를 함께 구성합니다. 핸드셰이크 프로토콜은 신뢰할 수 있는 인증 기관에서 서명한 인증서가 있는 당사자를 선택적으로 인증할 수도 있습니다.

---
#### **F.1.1.  Authentication and Key Exchange**

SSL은 양 당사자 인증, 인증되지 않은 클라이언트를 사용한 서버 인증, 완전한 익명성의 세 가지 인증 모드를 지원합니다. 서버가 인증될 때마다 채널은 중간자 공격으로부터 안전해야 하지만 완전히 익명인 세션은 본질적으로 이러한 공격에 취약합니다.

익명 서버는 클라이언트를 인증할 수 없습니다. 인증서 확인 메시지의 클라이언트 서명에는 서명을 특정 서버에 바인딩하기 위해 서버 인증서가 필요할 수 있기 때문입니다. 서버가 인증되면 해당 인증서 메시지는 허용 가능한 인증 기관으로 이어지는 유효한 인증서 체인을 제공해야 합니다. 마찬가지로 인증된 클라이언트는 허용 가능한 인증서를 서버에 제공해야 합니다. 각 당사자는 상대방의 인증서가 유효하고 만료되거나 취소되지 않았는지 확인할 책임이 있습니다.

키 교환 프로세스의 일반적인 목표는 공격자가 아닌 통신 당사자에게 알려진 pre\_master\_secret을 만드는 것입니다. pre\_master\_secret은 master\_secret을 생성하는 데 사용됩니다\(섹션 6.1 참조\). 완성된 메시지, 암호화 키 및 MAC 비밀을 생성하려면 master\_secret이 필요합니다\(섹션 5.6.9 및 6.2.2 참조\). 올바른 완료 메시지를 보내면 당사자는 올바른 pre\_master\_secret을 알고 있음을 증명합니다.

---
##### **F.1.1.1.  Anonymous Key Exchange**

키 교환을 위해 RSA, Diffie-Hellman 또는 FORTEZZA를 사용하여 완전한 익명 세션을 설정할 수 있습니다. 익명 RSA를 사용하면 클라이언트는 서버 키 교환 메시지에서 추출한 서버의 인증되지 않은 공개 키로 pre\_master\_secret을 암호화합니다. 결과는 클라이언트 키 교환 메시지로 전송됩니다. 도청자는 서버의 개인 키를 모르기 때문에 pre\_master\_secret을 해독하는 것은 불가능합니다.

Diffie-Hellman 또는 FORTEZZA를 사용하면 서버의 공개 매개변수가 서버 키 교환 메시지에 포함되고 클라이언트의 공개 매개변수는 클라이언트 키 교환 메시지에 전송됩니다. 개인 값을 모르는 도청자는 Diffie-Hellman 결과\(즉, pre\_master\_secret\) 또는 FORTEZZA 토큰 암호화 키\(TEK\)를 찾을 수 없어야 합니다.

경고: 완전 익명 연결은 수동적 도청에 대한 보호만 제공합니다. 완성된 메시지가 공격자에 의해 대체되지 않았는지 확인하기 위해 독립적인 변조 방지 채널을 사용하지 않는 한 적극적인 중간자 공격이 우려되는 환경에서는 서버 인증이 필요합니다.

---
##### **F.1.1.2.  RSA Key Exchange and Authentication**

RSA를 사용하면 키 교환과 서버 인증이 결합됩니다. 공개 키는 서버의 인증서에 포함되어 있거나 서버 키 교환 메시지로 전송된 임시 RSA 키일 수 있습니다. 임시 RSA 키가 사용되면 서버의 RSA 또는 DSS 인증서로 서명됩니다. 서명에는 현재

ClientHello.random이므로 이전 서명과 임시 키를 재생할 수 없습니다. 서버는 여러 협상 세션에 단일 임시 RSA 키를 사용할 수 있습니다.

참고: 임시 RSA 키 옵션은 서버에 대용량 인증서가 필요하지만 키 교환에 사용되는 키에 대해 정부가 부과한 크기 제한을 준수해야 하는 경우에 유용합니다.

서버의 인증서를 확인한 후 클라이언트는 서버의 공개 키로 pre\_master\_secret을 암호화합니다. pre\_master\_secret을 성공적으로 디코딩하고 올바르게 완료된 메시지를 생성함으로써 서버는 서버 인증서에 해당하는 개인 키를 알고 있음을 보여줍니다.

RSA가 키 교환에 사용될 때 클라이언트는 인증서 확인 메시지를 사용하여 인증됩니다\(섹션 5.6.8 참조\). 클라이언트는 master\_secret 및 이전의 모든 핸드셰이크 메시지에서 파생된 값에 서명합니다. 이러한 핸드셰이크 메시지에는 서명을 서버에 바인딩하는 서버 인증서와 서명을 현재 핸드셰이크 프로세스에 바인딩하는 ServerHello.random이 포함됩니다.

---
##### **F.1.1.3.  Diffie-Hellman Key Exchange with Authentication**

Diffie-Hellman 키 교환이 사용되면 서버는 고정된 Diffie-Hellman 매개변수가 포함된 인증서를 제공하거나 서버 키 교환 메시지를 사용하여 DSS 또는 RSA 인증서로 서명된 임시 Diffie-Hellman 매개변수 집합을 보낼 수 있습니다. 임시 매개변수는 공격자가 이전 매개변수를 재생하지 않도록 하기 위해 서명하기 전에 hello.random 값으로 해시됩니다. 두 경우 모두 클라이언트는 매개변수가 서버에 속하는지 확인하기 위해 인증서 또는 서명을 확인할 수 있습니다.

클라이언트에 고정된 Diffie-Hellman 매개변수가 포함된 인증서가 있는 경우 해당 인증서에는 키 교환을 완료하는 데 필요한 정보가 포함되어 있습니다. 이 경우 클라이언트와 서버는 통신할 때마다 동일한 Diffie-Hellman 결과\(예: pre\_master\_secret\)를 생성합니다. pre\_master\_secret이 필요 이상으로 메모리에 머무르는 것을 방지하려면 가능한 한 빨리 master\_secret으로 변환해야 합니다. 클라이언트 Diffie-Hellman 매개변수는 키 교환이 작동하려면 서버에서 제공하는 매개변수와 호환되어야 합니다.

클라이언트에 표준 DSS 또는 RSA 인증서가 있거나 인증되지 않은 경우 클라이언트 키 교환 메시지에서 서버에 임시 매개 변수 집합을 보낸 다음 선택적으로 인증서 확인 메시지를 사용하여 자신을 인증합니다.

---
##### **F.1.1.4.  FORTEZZA**

FORTEZZA의 설계는 분류되어 있지만 프로토콜 수준에서는 인증서에 포함된 고정된 공용 값이 있는 Diffie-Hellman과 유사합니다. 키 교환 프로세스의 결과는 데이터 암호화 키, 클라이언트 쓰기 키, 서버 쓰기 키 및 마스터 비밀 암호화 키를 래핑하는 데 사용되는 토큰 암호화 키\(TEK\)입니다. 언래핑된 키는 토큰 외부에서 액세스할 수 없기 때문에 데이터 암호화 키는 pre\_master\_secret에서 파생되지 않습니다. 암호화된 pre\_master\_secret은 클라이언트 키 교환 메시지로 서버로 전송됩니다.

---
#### **F.1.2.  Version Rollback Attacks**

SSL 버전 3.0에는 SSL 버전 2.0에 비해 상당한 개선 사항이 포함되어 있으므로 공격자는 버전 3.0 지원 클라이언트 및 서버를 버전 2.0으로 대체하려고 시도할 수 있습니다. 이 공격은 버전 3.0을 사용할 수 있는 두 당사자가 SSL 2.0 핸드셰이크를 사용하는 경우에만 발생합니다.

비무작위 PKCS #1 블록 유형 2 메시지 패딩을 사용하는 솔루션은 정교하지 않지만 버전 3.0 서버가 공격을 감지할 수 있는 상당히 안전한 방법을 제공합니다. 이 솔루션은 응용 프로그램에서 지정한 대기 임계값이 만료되기 전에 키를 무차별 대입하고 동일한 키를 포함하는 새 ENCRYPTED-KEY-DATA 메시지로 대체할 수 있는 공격자에 대해 안전하지 않습니다. 이 규모의 공격을 우려하는 당사자는 어쨌든 40비트 암호화 키를 사용해서는 안 됩니다. PKCS 패딩의 최하위 8바이트 패딩을 변경해도 보안에 영향을 미치지 않습니다. 기본적으로 입력 블록 크기를 8바이트로 늘리는 것과 동일하기 때문입니다.

---
#### **F.1.3.  Detecting Attacks against the Handshake Protocol**

공격자는 당사자가 일반적으로 선택하는 것과 다른 암호화 알고리즘을 선택하도록 핸드셰이크 교환에 영향을 주려고 할 수 있습니다. 많은 구현이 40비트 내보낼 수 있는 암호화를 지원하고 일부는 null 암호화 또는 MAC 알고리즘을 지원할 수도 있기 때문에 이 공격은 특히 우려됩니다.

이 공격의 경우 공격자는 하나 이상의 핸드셰이크 메시지를 능동적으로 변경해야 합니다. 이 경우 클라이언트와 서버는 핸드셰이크 메시지 해시에 대해 서로 다른 값을 계산합니다. 결과적으로 당사자들은 서로의 완료된 메시지를 수락하지 않습니다. master\_secret이 없으면 공격자는 완료된 메시지를 복구할 수 없으므로 공격이 발견됩니다.

---
#### **F.1.4.  Resuming Sessions**

세션을 재개하여 연결이 설정되면 새로운 ClientHello.random 및 ServerHello.random 값이 세션의 master\_secret으로 해시됩니다. master\_secret이 손상되지 않았고 암호화 키와 MAC 비밀을 생성하는 데 사용되는 보안 해시 작업이 안전하다면 연결은 안전해야 하며 이전 연결과 효과적으로 독립적이어야 합니다. 공격자는 알려진 암호화 키 또는 MAC 암호를 사용하여 보안 해시 작업\(SHA 및 MD5 모두 사용\)을 중단하지 않고 master\_secret을 손상시킬 수 없습니다.

클라이언트와 서버가 모두 동의하지 않으면 세션을 재개할 수 없습니다. 어느 쪽이든 세션이 손상되었거나 인증서가 만료 또는 해지되었다고 의심하는 경우 전체 핸드셰이크를 강제로 수행해야 합니다. master\_secret을 얻은 공격자는 해당 세션 ID가 만료될 때까지 손상된 당사자를 가장할 수 있으므로 세션 ID 수명에 대해 24시간의 상한이 제안됩니다. 상대적으로 안전하지 않은 환경에서 실행될 수 있는 애플리케이션은 세션 ID를 안정적인 저장소에 쓰지 않아야 합니다.

---
#### **F.1.5.  MD5 and SHA**

SSL은 매우 보수적으로 해시 함수를 사용합니다. 가능한 경우 MD5와 SHA를 함께 사용하여 하나의 알고리즘에 치명적인 결함이 있어도 전체 프로토콜이 손상되지 않도록 합니다.

---
### **F.2.  Protecting Application Data**

master\_secret은 ClientHello.random 및 ServerHello.random으로 해시되어 각 연결에 대해 고유한 데이터 암호화 키 및 MAC 비밀을 생성합니다. FORTEZZA 암호화 키는 토큰에 의해 생성되며 master\_secret에서 파생되지 않습니다.

나가는 데이터는 전송 전에 MAC으로 보호됩니다. 메시지 재생 또는 수정 공격을 방지하기 위해 MAC은 MAC 암호, 시퀀스 번호, 메시지 길이, 메시지 내용 및 두 개의 고정 문자열에서 계산됩니다. 하나의 SSL 레코드 레이어 클라이언트를 위한 메시지가 다른 클라이언트로 리디렉션되지 않도록 하려면 메시지 유형 필드가 필요합니다. 시퀀스 번호는 메시지를 삭제하거나 재정렬하려는 시도가 감지되도록 합니다. 시퀀스 번호는 64비트 길이이므로 절대 오버플로되어서는 안 됩니다. 한 당사자의 메시지는 독립적인 MAC 비밀을 사용하기 때문에 상대방의 출력에 삽입될 수 없습니다. 마찬가지로 서버 쓰기 및 클라이언트 쓰기 키는 독립적이므로 스트림 암호 키는 한 번만 사용됩니다.

공격자가 암호화 키를 해독하면 암호화된 모든 메시지를 읽을 수 있습니다. 마찬가지로 MAC 키가 손상되면 메시지 수정 공격이 가능해질 수 있습니다. MAC도 암호화되기 때문에 메시지 변경 공격은 일반적으로 MAC뿐만 아니라 암호화 알고리즘도 깨뜨려야 합니다.

참고: MAC 암호는 암호화 키보다 클 수 있으므로 암호화 키가 손상되더라도 메시지가 변조되지 않도록 유지될 수 있습니다.

---
### **F.3.  Final Notes**

SSL이 보안 연결을 제공할 수 있으려면 클라이언트 및 서버 시스템, 키 및 응용 프로그램이 모두 안전해야 합니다. 또한 구현에 보안 오류가 없어야 합니다.

이 시스템은 지원되는 가장 약한 키 교환 및 인증 알고리즘만큼만 강력하며 신뢰할 수 있는 암호화 기능만 사용해야 합니다. 짧은 공개 키, 40비트 대량 암호화 키 및 익명 서버는 매우 주의해서 사용해야 합니다. 구현 및 사용자는 어떤 인증서 및 인증 기관이 허용되는지 결정할 때 주의해야 합니다. 부정직한 인증 기관은 엄청난 피해를 입힐 수 있습니다.

---
# **Appendix G.  Acknowledgements**
---
### **G.1.  Other Contributors**

```text
   Martin Abadi                  Robert Relyea
   Digital Equipment Corporation Netscape Communications
   ma@pa.dec.com                 relyea@netscape.com

   Taher Elgamal                 Jim Roskind
   Netscape Communications       Netscape Communications
   elgamal@netscape.com          jar@netscape.com

   Anil Gangolli                 Micheal J. Sabin, Ph.D.
   Netscape Communications       Consulting Engineer
   gangolli@netscape.com         msabin@netcom.com

   Kipp E.B. Hickman             Tom Weinstein
   Netscape Communications       Netscape Communications
   kipp@netscape.com             tomw@netscape.com
```

---
### **G.2.  Early Reviewers**

```text
   Robert Baldwin                Clyde Monma
   RSA Data Security, Inc.       Bellcore
   baldwin@rsa.com               clyde@bellcore.com

   George Cox                    Eric Murray
   Intel Corporation             ericm@lne.com
   cox@ibeam.jf.intel.com

   Cheri Dowell                  Avi Rubin
   Sun Microsystems              Bellcore
   cheri@eng.sun.com             rubin@bellcore.com

   Stuart Haber                  Don Stephenson
   Bellcore                      Sun Microsystems
   stuart@bellcore.com           don.stephenson@eng.sun.com

   Burt Kaliski                  Joe Tardo
   RSA Data Security, Inc.       General Magic
   burt@rsa.com                  tardo@genmagic.com
```

---
# **Authors' Addresses**

```text
   Alan O. Freier
   Netscape Communications

   Philip Karlton
   Netscape Communications

   Paul C. Kocher
   Independent Consultant
```


```text
Network Working Group                                     T. Berners-Lee
Request for Comments: 1945                                       MIT/LCS
Category: Informational                                      R. Fielding
                                                               UC Irvine
                                                              H. Frystyk
                                                                 MIT/LCS
                                                                May 1996

                Hypertext Transfer Protocol -- HTTP/1.0
```

---
# **Status of This Memo**

이 메모는 인터넷 커뮤니티에 대한 정보를 제공합니다. 이 메모는 어떤 종류의 인터넷 표준도 지정하지 않습니다. 이 메모의 배포는 무제한입니다.

---
# **IESG Note:**

IESG는 이 프로토콜에 대해 우려하고 있으며 이 문서가 비교적 곧 표준 추적 문서로 대체될 것으로 예상합니다.

---
# **Abstract**

HTTP\(Hypertext Transfer Protocol\)는 분산, 협업, 하이퍼미디어 정보 시스템에 필요한 가벼움과 속도를 갖춘 애플리케이션 수준 프로토콜입니다. 이는 요청 방법\(명령\)의 확장을 통해 이름 서버 및 분산 객체 관리 시스템과 같은 많은 작업에 사용할 수 있는 일반적인 상태 비저장 객체 지향 프로토콜입니다. HTTP의 특징은 데이터 표현을 입력하는 것입니다. 이를 통해 전송되는 데이터와 독립적으로 시스템을 구축할 수 있습니다.

HTTP는 1990년부터 World-Wide Web 글로벌 정보 이니셔티브에서 사용되어 왔습니다. 이 사양은 "HTTP/1.0"이라는 프로토콜의 일반적인 사용을 반영합니다.

---
# **Table of Contents**

```text
   1.  Introduction ..............................................  4
       1.1  Purpose ..............................................  4
       1.2  Terminology ..........................................  4
       1.3  Overall Operation ....................................  6
       1.4  HTTP and MIME ........................................  8
   2.  Notational Conventions and Generic Grammar ................  8
       2.1  Augmented BNF ........................................  8
       2.2  Basic Rules .......................................... 10
   3.  Protocol Parameters ....................................... 12
       3.1  HTTP Version ......................................... 12
       3.2  Uniform Resource Identifiers ......................... 14
            3.2.1  General Syntax ................................ 14
            3.2.2  http URL ...................................... 15
       3.3  Date/Time Formats .................................... 15
       3.4  Character Sets ....................................... 17
       3.5  Content Codings ...................................... 18
       3.6  Media Types .......................................... 19
            3.6.1  Canonicalization and Text Defaults ............ 19
            3.6.2  Multipart Types ............................... 20
       3.7  Product Tokens ....................................... 20
   4.  HTTP Message .............................................. 21
       4.1  Message Types ........................................ 21
       4.2  Message Headers ...................................... 22
       4.3  General Header Fields ................................ 23
   5.  Request ................................................... 23
       5.1  Request-Line ......................................... 23
            5.1.1  Method ........................................ 24
            5.1.2  Request-URI ................................... 24
       5.2  Request Header Fields ................................ 25
   6.  Response .................................................. 25
       6.1  Status-Line .......................................... 26
            6.1.1  Status Code and Reason Phrase ................. 26
       6.2  Response Header Fields ............................... 28
   7.  Entity .................................................... 28
       7.1  Entity Header Fields ................................. 29
       7.2  Entity Body .......................................... 29
            7.2.1  Type .......................................... 29
            7.2.2  Length ........................................ 30
   8.  Method Definitions ........................................ 30
       8.1  GET .................................................. 31
       8.2  HEAD ................................................. 31
       8.3  POST ................................................. 31
   9.  Status Code Definitions ................................... 32
       9.1  Informational 1xx .................................... 32
       9.2  Successful 2xx ....................................... 32
       9.3  Redirection 3xx ...................................... 34
       9.4  Client Error 4xx ..................................... 35
       9.5  Server Error 5xx ..................................... 37
   10. Header Field Definitions .................................. 37
       10.1  Allow ............................................... 38
       10.2  Authorization ....................................... 38
       10.3  Content-Encoding .................................... 39
       10.4  Content-Length ...................................... 39
       10.5  Content-Type ........................................ 40
       10.6  Date ................................................ 40
       10.7  Expires ............................................. 41
       10.8  From ................................................ 42
       10.9  If-Modified-Since ................................... 42
       10.10 Last-Modified ....................................... 43
       10.11 Location ............................................ 44
       10.12 Pragma .............................................. 44
       10.13 Referer ............................................. 44
       10.14 Server .............................................. 45
       10.15 User-Agent .......................................... 46
       10.16 WWW-Authenticate .................................... 46
   11. Access Authentication ..................................... 47
       11.1  Basic Authentication Scheme ......................... 48
   12. Security Considerations ................................... 49
       12.1  Authentication of Clients ........................... 49
       12.2  Safe Methods ........................................ 49
       12.3  Abuse of Server Log Information ..................... 50
       12.4  Transfer of Sensitive Information ................... 50
       12.5  Attacks Based On File and Path Names ................ 51
   13. Acknowledgments ........................................... 51
   14. References ................................................ 52
   15. Authors' Addresses ........................................ 54
   Appendix A.   Internet Media Type message/http ................ 55
   Appendix B.   Tolerant Applications ........................... 55
   Appendix C.   Relationship to MIME ............................ 56
       C.1  Conversion to Canonical Form ......................... 56
       C.2  Conversion of Date Formats ........................... 57
       C.3  Introduction of Content-Encoding ..................... 57
       C.4  No Content-Transfer-Encoding ......................... 57
       C.5  HTTP Header Fields in Multipart Body-Parts ........... 57
   Appendix D.   Additional Features ............................. 57
       D.1  Additional Request Methods ........................... 58
            D.1.1  PUT ........................................... 58
            D.1.2  DELETE ........................................ 58
            D.1.3  LINK .......................................... 58
            D.1.4  UNLINK ........................................ 58
       D.2  Additional Header Field Definitions .................. 58
            D.2.1  Accept ........................................ 58
            D.2.2  Accept-Charset ................................ 59
            D.2.3  Accept-Encoding ............................... 59
            D.2.4  Accept-Language ............................... 59
            D.2.5  Content-Language .............................. 59
            D.2.6  Link .......................................... 59
            D.2.7  MIME-Version .................................. 59
            D.2.8  Retry-After ................................... 60
            D.2.9  Title ......................................... 60
            D.2.10 URI ........................................... 60
```

---
## **1.  Introduction**
---
## **1.1  Purpose**

HTTP\(Hypertext Transfer Protocol\)는 분산, 협업, 하이퍼미디어 정보 시스템에 필요한 가벼움과 속도를 갖춘 애플리케이션 수준 프로토콜입니다. HTTP는 1990년부터 World-Wide Web 글로벌 정보 이니셔티브에서 사용되어 왔습니다. 이 사양은 "HTTP/1.0"이라고도 하는 프로토콜의 일반적인 사용을 반영합니다. 이 사양은 대부분의 HTTP/1.0 클라이언트 및 서버에서 일관되게 구현되는 것으로 보이는 기능을 설명합니다. 사양은 두 부분으로 나뉩니다. 일반적으로 구현이 일관적인 HTTP의 기능은 이 문서의 본문에 설명되어 있습니다. 구현이 적거나 일관성이 없는 기능은 부록 D에 나열되어 있습니다.

실용적인 정보 시스템에는 검색, 프런트엔드 업데이트, 주석 등 단순 검색보다 더 많은 기능이 필요합니다. HTTP를 사용하면 개방형 메서드 집합을 사용하여 요청 목적을 나타낼 수 있습니다. 이는 방법이 적용될 리소스를 표시하기 위해 URI\(Uniform Resource Identifier\) ​​\[2\]에서 위치\(URL\) \[4\] 또는 이름\(URN\) \[16\]으로 제공하는 참조 규칙을 기반으로 합니다. . 메시지는 인터넷 메일\[7\] 및 다목적 인터넷 메일 확장\(MIME\) \[5\]에서 사용되는 것과 유사한 형식으로 전달됩니다.

HTTP는 사용자 에이전트와 SMTP \[12\], NNTP \[11\], FTP \[14\], Gopher \[1\] 및 WAIS \[8\]와 같은 다른 인터넷 프로토콜에 대한 프록시/게이트웨이 간의 통신을 위한 일반 프로토콜로도 사용됩니다. 다양한 애플리케이션에서 사용할 수 있는 리소스에 대한 기본 하이퍼미디어 액세스를 허용하고 사용자 에이전트 구현을 단순화합니다.

---
## **1.2  Terminology**

이 사양에서는 HTTP 통신의 참가자와 개체가 수행하는 역할을 나타내기 위해 다양한 용어를 사용합니다.

```text
   connection
```

- 통신을 목적으로 두 응용 프로그램 사이에 설정된 전송 계층 가상 회선입니다.

```text
   message
```

- HTTP 통신의 기본 단위로, 섹션 4에 정의된 구문과 일치하는 구조화된 옥텟 시퀀스로 구성되고 연결을 통해 전송됩니다.

```text
   request
```

- HTTP 요청 메시지\(섹션 5에 정의됨\).

```text
   response
```

- HTTP 응답 메시지\(섹션 6에 정의됨\).

```text
   resource
```

- URI로 식별할 수 있는 네트워크 데이터 개체 또는 서비스\(섹션 3.2\).

```text
   entity
```

- 요청이나 응답 메시지에 포함될 수 있는 데이터 리소스의 특정 표현이나 변환, 서비스 리소스의 응답입니다. 엔터티는 엔터티 헤더 형태의 메타정보와 엔터티 바디 형태의 콘텐츠로 구성됩니다.

```text
   client
```

- 요청 전송을 목적으로 연결을 설정하는 응용 프로그램입니다.

```text
   user agent
```

- 요청을 시작하는 클라이언트입니다. 이는 브라우저, 편집기, 스파이더\(웹 탐색 로봇\) 또는 기타 최종 사용자 도구인 경우가 많습니다.

```text
   server
```

- 응답을 다시 보내 요청을 처리하기 위해 연결을 수락하는 응용 프로그램입니다.

```text
   origin server
```

- 특정 리소스가 상주하거나 생성될 서버입니다.

```text
   proxy

       An intermediary program which acts as both a server and a client
       for the purpose of making requests on behalf of other clients.
       Requests are serviced internally or by passing them, with
       possible translation, on to other servers. A proxy must
       interpret and, if necessary, rewrite a request message before
```

- 전달합니다. 프록시는 네트워크 방화벽을 통해 클라이언트측 포털로 사용되거나 사용자 에이전트에서 구현되지 않은 프로토콜을 통해 요청을 처리하기 위한 도우미 애플리케이션으로 사용되는 경우가 많습니다.

```text
   gateway
```

- 다른 서버의 중개자 역할을 하는 서버입니다. 프록시와 달리 게이트웨이는 요청된 리소스에 대한 원본 서버인 것처럼 요청을 받습니다. 요청 클라이언트는 자신이 게이트웨이와 통신하고 있다는 사실을 인식하지 못할 수도 있습니다. 게이트웨이는 네트워크 방화벽을 통한 서버 측 포털로 사용되거나 HTTP가 아닌 시스템에 저장된 리소스에 액세스하기 위한 프로토콜 변환기로 사용되는 경우가 많습니다.

```text
   tunnel
```

- 터널은 두 연결 사이에서 블라인드 릴레이 역할을 하는 중개 프로그램입니다. 일단 활성화되면 터널은 HTTP 요청에 의해 시작되었을 수 있지만 HTTP 통신의 당사자로 간주되지 않습니다. 릴레이된 연결의 양쪽 끝이 닫히면 터널은 더 이상 존재하지 않습니다. 터널은 포털이 필요하고 중개자가 중계된 통신을 해석할 수 없거나 해석해서는 안 되는 경우에 사용됩니다.

```text
   cache
```

- 응답 메시지의 프로그램 로컬 저장소와 메시지 저장, 검색 및 삭제를 제어하는 ​​하위 시스템입니다. 캐시는 향후 동등한 요청에 대한 응답 시간과 네트워크 대역폭 소비를 줄이기 위해 캐시 가능한 응답을 저장합니다. 모든 클라이언트나 서버에는 캐시가 포함될 수 있지만 캐시는 터널 역할을 하는 동안 서버에서 사용할 수 없습니다.

특정 프로그램은 클라이언트이자 서버가 될 수 있습니다. 이러한 용어의 사용은 일반적인 프로그램 기능이 아닌 특정 연결을 위해 프로그램이 수행하는 역할만을 의미합니다. 마찬가지로 모든 서버는 원본 서버, 프록시, 게이트웨이 또는 터널 역할을 할 수 있으며 각 요청의 특성에 따라 동작을 전환할 수 있습니다.

---
## **1.3  Overall Operation**

HTTP 프로토콜은 요청/응답 패러다임을 기반으로 합니다. 클라이언트는 서버와의 연결을 설정하고 요청 메서드, URI 및 프로토콜 버전 형식으로 서버에 요청을 보낸 다음 요청 수정자, 클라이언트 정보 및 가능한 본문 콘텐츠가 포함된 MIME 형식 메시지를 보냅니다. 서버는 다음과 같이 응답합니다.

메시지의 프로토콜 버전과 성공 또는 오류 코드를 포함하는 상태 줄과 서버 정보, 엔터티 메타 정보 및 가능한 본문 내용을 포함하는 MIME 형식의 메시지가 표시됩니다.

대부분의 HTTP 통신은 사용자 에이전트에 의해 시작되며 일부 원본 서버의 리소스에 적용되는 요청으로 구성됩니다. 가장 간단한 경우 이는 사용자 에이전트\(UA\)와 원본 서버\(O\) 간의 단일 연결\(v\)을 통해 수행될 수 있습니다.

```text
          request chain ------------------------>
       UA -------------------v------------------- O
          <----------------------- response chain
```

요청/응답 체인에 하나 이상의 중개자가 있으면 더 복잡한 상황이 발생합니다. 중개자에는 프록시, 게이트웨이, 터널의 세 가지 일반적인 형태가 있습니다. 프록시는 절대 형식으로 URI에 대한 요청을 수신하고, 메시지의 전체 또는 일부를 다시 작성하고, 형식이 변경된 요청을 URI로 식별되는 서버로 전달하는 전달 에이전트입니다. 게이트웨이는 수신 에이전트로서 다른 서버 위의 계층 역할을 하며 필요한 경우 요청을 기본 서버의 프로토콜로 변환합니다. 터널은 메시지를 변경하지 않고 두 연결 간의 중계 지점 역할을 합니다. 터널은 중개자가 메시지의 내용을 이해할 수 없는 경우에도 통신이 중개자\(예: 방화벽\)를 통과해야 할 때 사용됩니다.

```text
          request chain -------------------------------------->
       UA -----v----- A -----v----- B -----v----- C -----v----- O
          <------------------------------------- response chain
```

위 그림은 사용자 에이전트와 원본 서버 사이의 세 가지 중개자\(A, B, C\)를 보여줍니다. 전체 체인을 이동하는 요청 또는 응답 메시지는 4개의 개별 연결을 통과해야 합니다. 일부 HTTP 통신 옵션은 가장 가까운 터널이 아닌 이웃과의 연결에만 적용되거나 체인의 끝점에만 적용되거나 체인을 따른 모든 연결에 적용될 수 있으므로 이러한 구별이 중요합니다. 다이어그램은 선형이지만 각 참가자는 여러 동시 통신에 참여할 수 있습니다. 예를 들어, B는 A 이외의 많은 클라이언트로부터 요청을 수신하거나 A의 요청을 처리하는 동시에 C 이외의 서버로 요청을 전달할 수 있습니다.

터널 역할을 하지 않는 통신 당사자는 요청 처리를 위해 내부 캐시를 사용할 수 있습니다. 캐시의 효과는 체인에 있는 참가자 중 하나가 해당 요청에 적용할 수 있는 캐시된 응답을 가지고 있는 경우 요청/응답 체인이 단축된다는 것입니다. 다음은 B가

UA 또는 A에 의해 캐시되지 않은 요청에 대해 \(C를 통해\) O로부터의 이전 응답의 캐시된 복사본.

```text
          request chain ---------->
       UA -----v----- A -----v----- B - - - - - - C - - - - - - O
          <--------- response chain
```

모든 응답을 캐시할 수 있는 것은 아니며 일부 요청에는 캐시 동작에 특별한 요구 사항을 적용하는 수정자가 포함될 수 있습니다. 일부 HTTP/1.0 애플리케이션은 경험적 방법을 사용하여 "캐시 가능" 응답인지 여부를 설명하지만 이러한 규칙은 표준화되어 있지 않습니다.

인터넷에서 HTTP 통신은 일반적으로 TCP/IP 연결을 통해 이루어집니다. 기본 포트는 TCP 80\[15\]이지만 다른 포트도 사용할 수 있다. 이는 HTTP가 인터넷이나 다른 네트워크의 다른 프로토콜 위에 구현되는 것을 배제하지 않습니다. HTTP는 안정적인 전송만을 가정합니다. 그러한 보장을 제공하는 모든 프로토콜이 사용될 수 있으며 문제의 프로토콜의 전송 데이터 단위에 대한 HTTP/1.0 요청 및 응답 구조의 매핑은 이 사양의 범위를 벗어납니다.

실험적인 응용 프로그램을 제외하고 현재 관행에서는 각 요청 전에 클라이언트가 연결을 설정하고 응답을 보낸 후 서버에서 닫아야 합니다. 클라이언트와 서버 모두는 사용자 작업, 자동화된 시간 초과 또는 프로그램 오류로 인해 한쪽 당사자가 연결을 조기에 닫을 수 있다는 점을 인식하고 이러한 종료를 예측 가능한 방식으로 처리해야 합니다. 어떤 경우든 한쪽 또는 양쪽 당사자가 연결을 닫으면 상태에 관계없이 항상 현재 요청이 종료됩니다.

---
## **1.4  HTTP and MIME**

HTTP/1.0은 RFC 1521 \[5\]에 정의된 대로 MIME에 대해 정의된 많은 구성을 사용합니다. 부록 C에서는 HTTP 컨텍스트에서 일반적으로 인터넷 메일에서 발견되는 것과 다른 인터넷 미디어 유형의 사용을 허용하는 방식을 설명하고 이러한 차이점에 대한 근거를 제공합니다.

---
## **2.  Notational Conventions and Generic Grammar**
---
## **2.1  Augmented BNF**

이 문서에 명시된 모든 메커니즘은 RFC 822 \[7\]에서 사용되는 것과 유사한 산문과 확장된 BNF\(Backus-Naur Form\)로 설명됩니다. 구현자는 이 사양을 이해하기 위해 표기법에 익숙해야 합니다. 증강된 BNF에는 다음 구성이 포함됩니다.

```text
   name = definition
```

- 규칙의 이름은 단순히 이름 자체이며\("<" 및 "\>"를 묶지 않음\) 등호 문자 "="로 정의와 구분됩니다. 공백은 연속 줄의 들여쓰기가 두 줄 이상에 걸쳐 있는 규칙 정의를 나타내는 데 사용된다는 점에서만 중요합니다. SP, LWS, HT, CRLF, DIGIT, ALPHA 등과 같은 특정 기본 규칙은 대문자로 표시됩니다. 꺾쇠 괄호는 해당 규칙 이름의 사용을 쉽게 식별할 수 있도록 정의 내에서 사용됩니다.

```text
   "literal"
```

- 따옴표는 리터럴 텍스트를 둘러쌉니다. 달리 명시하지 않는 한 텍스트는 대소문자를 구분하지 않습니다.

```text
   rule1 | rule2
```

- 막대\("I"\)로 구분된 요소는 대안입니다. 예를 들어 "yes | no"는 예 또는 아니오를 허용합니다.

```text
   (rule1 rule2)
```

- 괄호 안의 요소는 단일 요소로 취급됩니다. 따라서 "\(elem \(foo | bar\) elem\)"은 토큰 시퀀스 "elem foo elem" 및 "elem bar elem"을 허용합니다.

```text
   *rule
```

- 요소 앞의 문자 "\*"는 반복을 나타냅니다. 전체 형식은 "<n\>\*<m\>element"로, 요소가 <n\>회 이상, 최대 <m\>회 발생함을 나타냅니다. 기본값은 0과 무한대이므로 "\*\(요소\)"는 0을 포함한 모든 숫자를 허용합니다. "1\*요소"에는 최소한 하나가 필요합니다. "1\*2element"는 1개 또는 2개를 허용합니다.

```text
   [rule]
```

- 대괄호는 선택적 요소를 묶습니다. "\[foo bar\]"는 "\*1\(foo bar\)"와 동일합니다.

```text
   N rule
```

- 특정 반복: "<n\>\(요소\)"는 "<n\>\*<n\>\(요소\)"와 동일합니다. 즉, \(요소\)가 정확히 <n\>회 발생합니다. 따라서 2DIGIT는 2자리 숫자이고 3ALPHA는 세 개의 알파벳 문자로 구성된 문자열입니다.

```text
   #rule
```

- 요소 목록을 정의하기 위해 "\*"와 유사한 구성 "#"이 정의됩니다. 전체 형식은 "<n\>#<m\>element"이며, 각각 하나 이상의 쉼표\(","\)와 선택적 선형 공백\(LWS\)으로 구분된 <n\>개 이상, <m\>개 이하의 요소를 나타냅니다. 이는 일반적인 목록 형식을 매우 쉽게 만듭니다. "\( \*LWS 요소 \*\( \*LWS "," \*LWS 요소 \)\)"와 같은 규칙은 "1#element"로 표시될 수 있습니다. 이 구성이 사용될 때마다 null 요소가 허용되지만 존재하는 요소 수에 영향을 주지는 않습니다. 즉, "\(요소\), , \(요소\)"는 허용되지만 두 요소로만 계산됩니다. 따라서 하나 이상의 요소가 필요한 경우 null이 아닌 요소가 하나 이상 있어야 합니다. 기본값은 0과 무한대이므로 "#\(element\)"는 0을 포함한 모든 숫자를 허용합니다. "1#element"에는 하나 이상이 필요합니다. "1#2element"는 1개 또는 2개를 허용합니다.

```text
   ; comment
```

- 규칙 텍스트 오른쪽에 약간의 거리를 두고 있는 세미콜론은 줄 끝까지 계속되는 주석을 시작합니다. 이는 사양과 병행하여 유용한 참고 사항을 포함하는 간단한 방법입니다.

```text
   implied *LWS
```

- 본 명세서에서 설명하는 문법은 단어 기반이다. 별도로 명시하지 않는 한 선형 공백\(LWS\)은 필드 해석을 변경하지 않고 인접한 두 단어\(토큰 또는 인용 문자열\) 사이와 인접한 토큰과 구분 기호\(tspecials\) 사이에 포함될 수 있습니다. 두 토큰 사이에는 최소한 하나의 구분 기호\(tspecials\)가 있어야 합니다. 그렇지 않으면 단일 토큰으로 해석되기 때문입니다. 그러나 응용 프로그램은 HTTP 구성을 생성할 때 "일반 형식"을 따르도록 시도해야 합니다. 일반 형식을 넘어서는 어떤 것도 허용하지 않는 일부 구현이 있기 때문입니다.

---
## **2.2  Basic Rules**

다음 규칙은 기본 구문 분석 구성을 설명하기 위해 이 사양 전체에서 사용됩니다. US-ASCII 코드 문자 집합은 \[17\]에 의해 정의됩니다.

```text
       OCTET          = <any 8-bit sequence of data>
       CHAR           = <any US-ASCII character (octets 0 - 127)>
       UPALPHA        = <any US-ASCII uppercase letter "A".."Z">
       LOALPHA        = <any US-ASCII lowercase letter "a".."z">

       ALPHA          = UPALPHA | LOALPHA
       DIGIT          = <any US-ASCII digit "0".."9">
       CTL            = <any US-ASCII control character
                        (octets 0 - 31) and DEL (127)>
       CR             = <US-ASCII CR, carriage return (13)>
       LF             = <US-ASCII LF, linefeed (10)>
       SP             = <US-ASCII SP, space (32)>
       HT             = <US-ASCII HT, horizontal-tab (9)>
       <">            = <US-ASCII double-quote mark (34)>
```

HTTP/1.0은 옥텟 시퀀스 CR LF를 Entity-Body를 제외한 모든 프로토콜 요소에 대한 줄 끝 표시로 정의합니다\(허용 응용 프로그램에 대해서는 부록 B 참조\). Entity-Body 내의 줄 끝 표시는 섹션 3.6에 설명된 대로 관련 미디어 유형에 의해 정의됩니다.

```text
       CRLF           = CR LF
```

각 연속 줄이 공백이나 가로 탭으로 시작하는 경우 HTTP/1.0 헤더는 여러 줄로 접힐 수 있습니다. 접기를 포함한 모든 선형 공백은 SP와 동일한 의미를 갖습니다.

```text
       LWS            = [CRLF] 1*( SP | HT )
```

그러나 일부 응용 프로그램에서는 헤더 줄 접기가 예상되지 않으며 HTTP/1.0 응용 프로그램에서 생성해서는 안 됩니다.

TEXT 규칙은 메시지 구문 분석기에 의해 해석되지 않는 설명 필드 내용 및 값에만 사용됩니다. \*TEXT의 단어에는 US-ASCII 이외의 문자 집합의 옥텟이 포함될 수 있습니다.

```text
       TEXT           = <any OCTET except CTLs,
                        but including LWS>
```

US-ASCII 문자 집합 외부의 옥텟을 포함하는 헤더 필드 TEXT의 수신자는 자신이 ISO-8859-1 문자를 나타내는 것으로 가정할 수 있습니다.

16진수 문자는 여러 프로토콜 요소에 사용됩니다.

```text
       HEX            = "A" | "B" | "C" | "D" | "E" | "F"
                      | "a" | "b" | "c" | "d" | "e" | "f" | DIGIT
```

많은 HTTP/1.0 헤더 필드 값은 LWS 또는 특수 문자로 구분된 단어로 구성됩니다. 매개변수 값 내에서 사용하려면 이러한 특수 문자를 따옴표로 묶어야 합니다.

```text
       word           = token | quoted-string

       token          = 1*<any CHAR except CTLs or tspecials>

       tspecials      = "(" | ")" | "<" | ">" | "@"
                      | "," | ";" | ":" | "\" | <">
                      | "/" | "[" | "]" | "?" | "="
                      | "{" | "}" | SP | HT
```

주석 텍스트를 괄호로 묶어 일부 HTTP 헤더 필드에 주석을 포함할 수 있습니다. 설명은 필드 값 정의의 일부로 "설명"을 포함하는 필드에서만 허용됩니다. 다른 모든 필드에서는 괄호가 필드 값의 일부로 간주됩니다.

```text
       comment        = "(" *( ctext | comment ) ")"
       ctext          = <any TEXT excluding "(" and ")">
```

텍스트 문자열이 큰따옴표를 사용하여 인용된 경우 단일 단어로 구문 분석됩니다.

```text
       quoted-string  = ( <"> *(qdtext) <"> )

       qdtext         = <any CHAR except <"> and CTLs,
                        but including LWS>
```

HTTP/1.0에서는 백슬래시\("\"\) 문자를 사용한 단일 문자 인용이 허용되지 않습니다.

---
## **3.  Protocol Parameters**
---
## **3.1  HTTP Version**

HTTP는 "<major\>.<minor\>" 번호 지정 체계를 사용하여 프로토콜 버전을 나타냅니다. 프로토콜 버전 관리 정책은 보낸 사람이 해당 통신을 통해 얻은 기능보다는 추가 HTTP 통신을 이해하기 위한 메시지 형식과 용량을 표시할 수 있도록 하기 위한 것입니다. 통신 동작에 영향을 주지 않거나 확장 가능한 필드 값에만 추가되는 메시지 구성 요소를 추가하는 경우 버전 번호는 변경되지 않습니다. <minor\> 번호는 일반 메시지 구문 분석 알고리즘을 변경하지 않지만 메시지 의미를 추가하고 보낸 사람의 추가 기능을 암시할 수 있는 프로토콜 추가 기능에 대한 변경 사항이 있을 때 증가됩니다. <major\> 번호는 프로토콜 내의 메시지 형식이 변경되면 증가됩니다.

HTTP 메시지의 버전은 메시지의 첫 번째 줄에 있는 HTTP-Version 필드로 표시됩니다. 프로토콜 버전이 지정되지 않은 경우 수신자는 메시지가 프로토콜 버전에 있다고 가정해야 합니다.

```text
   simple HTTP/0.9 format.

       HTTP-Version   = "HTTP" "/" 1*DIGIT "." 1*DIGIT
```

메이저 번호와 마이너 번호는 별도의 정수로 처리되어야 하며 각각은 한 자리보다 높게 증가할 수 있습니다. 따라서 HTTP/2.4는 HTTP/2.13보다 낮은 버전이고 HTTP/12.3보다 낮은 버전입니다. 수신자는 앞에 오는 0을 무시해야 하며 발신자는 절대 생성하지 않아야 합니다.

이 문서는 HTTP 프로토콜의 0.9 및 1.0 버전을 모두 정의합니다. 이 사양에 정의된 대로 전체 요청 또는 전체 응답 메시지를 보내는 애플리케이션에는 "HTTP/1.0"의 HTTP 버전이 포함되어야 합니다.

```text
   HTTP/1.0 servers must:
```

- HTTP/0.9 및 HTTP/1.0 요청에 대한 요청 라인의 형식을 인식합니다.

- HTTP/0.9 또는 HTTP/1.0 형식의 유효한 요청을 이해합니다.

- 클라이언트가 사용하는 것과 동일한 프로토콜 버전의 메시지로 적절하게 응답합니다.

```text
   HTTP/1.0 clients must:
```

- HTTP/1.0 응답에 대한 Status-Line 형식을 인식합니다.

- HTTP/0.9 또는 HTTP/1.0 형식의 유효한 응답을 이해합니다.

프록시 및 게이트웨이 애플리케이션은 애플리케이션의 기본 HTTP 버전과 다른 형식으로 수신된 요청을 전달할 때 주의해야 합니다. 프로토콜 버전은 보낸 사람의 프로토콜 기능을 나타내므로 프록시/게이트웨이는 기본 버전보다 높은 버전 표시가 있는 메시지를 보내면 안 됩니다. 더 높은 버전의 요청이 수신되면 프록시/게이트웨이는 요청 버전을 다운그레이드하거나 오류로 응답해야 합니다. 애플리케이션의 기본 형식보다 낮은 버전의 요청은 전달되기 전에 업그레이드될 수 있습니다. 해당 요청에 대한 프록시/게이트웨이의 응답은 위에 나열된 서버 요구 사항을 따라야 합니다.

---
## **3.2  Uniform Resource Identifiers**

URI는 WWW 주소, 범용 문서 식별자\(Universal Document Identifier\), 범용 자원 식별자\(Universal Resource Identifier\)\[2\], 그리고 마지막으로 URL\(Uniform Resource Locator\)\[4\]과 이름\(URN\)\[16\]의 조합 등 다양한 이름으로 알려져 있습니다. HTTP에 관한 한, 통일 자원 식별자는 이름, 위치 또는 기타 특성을 통해 네트워크 자원을 식별하는 단순한 형식의 문자열입니다.

---
### **3.2.1 General Syntax**

HTTP의 URI는 사용 상황에 따라 절대 형식이나 일부 알려진 기본 URI\[9\]에 상대적인 형식으로 표시될 수 있습니다. 두 형식은 절대 URI가 항상 콜론이 뒤따르는 체계 이름으로 시작한다는 사실로 구별됩니다.

```text
       URI            = ( absoluteURI | relativeURI ) [ "#" fragment ]

       absoluteURI    = scheme ":" *( uchar | reserved )

       relativeURI    = net_path | abs_path | rel_path

       net_path       = "//" net_loc [ abs_path ]
       abs_path       = "/" rel_path
       rel_path       = [ path ] [ ";" params ] [ "?" query ]

       path           = fsegment *( "/" segment )
       fsegment       = 1*pchar
       segment        = *pchar

       params         = param *( ";" param )
       param          = *( pchar | "/" )

       scheme         = 1*( ALPHA | DIGIT | "+" | "-" | "." )
       net_loc        = *( pchar | ";" | "?" )
       query          = *( uchar | reserved )
       fragment       = *( uchar | reserved )

       pchar          = uchar | ":" | "@" | "&" | "=" | "+"
       uchar          = unreserved | escape
       unreserved     = ALPHA | DIGIT | safe | extra | national

       escape         = "%" HEX HEX
       reserved       = ";" | "/" | "?" | ":" | "@" | "&" | "=" | "+"
       extra          = "!" | "*" | "'" | "(" | ")" | ","
       safe           = "$" | "-" | "_" | "."
       unsafe         = CTL | SP | <"> | "#" | "%" | "<" | ">"
       national       = <any OCTET excluding ALPHA, DIGIT,
```

- 예약됨, 추가, 안전 및 안전하지 않음\>

URL 구문 및 의미에 대한 최종 정보는 RFC 1738 \[4\] 및 RFC 1808 \[9\]을 참조하세요. 위의 BNF에는 RFC 1738에 지정된 대로 유효한 URL에 허용되지 않는 국가 문자가 포함되어 있습니다. 이는 HTTP 서버가 주소의 rel\_path 부분을 나타내는 데 허용되는 예약되지 않은 문자 집합에 제한되지 않고 HTTP 프록시가 RFC에 정의되지 않은 URI에 대한 요청을 받을 수 있기 때문입니다. 1738.

---
### **3.2.2 http URL**

"http" 체계는 HTTP 프로토콜을 통해 네트워크 리소스를 찾는 데 사용됩니다. 이 섹션에서는 http URL에 대한 체계별 구문과 의미를 정의합니다.

```text
       http_URL       = "http:" "//" host [ ":" port ] [ abs_path ]

       host           = <A legal Internet host domain name
                         or IP address (in dotted-decimal form),
                         as defined by Section 2.1 of RFC 1123>

       port           = *DIGIT
```

포트가 비어 있거나 지정되지 않은 경우 포트 80이 가정됩니다. 의미론은 식별된 리소스가 해당 호스트의 해당 포트에서 TCP 연결을 수신하는 서버에 있고 리소스에 대한 요청-URI가 abs\_path라는 것입니다. URL에 abs\_path가 없으면 Request-URI로 사용될 때 "/"로 제공되어야 합니다\(섹션 5.1.2\).

- 참고: HTTP 프로토콜은 전송 계층 프로토콜과 독립적이지만 http URL은 TCP 위치로만 리소스를 식별하므로 비 TCP 리소스는 다른 URI 체계로 식별해야 합니다.

"http" URL의 표준 형식은 호스트의 모든 UPALPHA 문자를 해당 LOALPHA 문자로 변환하고\(호스트 이름은 대소문자를 구분하지 않음\) 포트가 80인 경우 \[ ":" 포트 \]를 삭제하고 빈 abs\_path를 " /".

---
## **3.3  Date/Time Formats**

HTTP/1.0 애플리케이션은 역사적으로 날짜/시간 스탬프 표시에 대해 세 가지 다른 형식을 허용했습니다.

```text
       Sun, 06 Nov 1994 08:49:37 GMT    ; RFC 822, updated by RFC 1123
       Sunday, 06-Nov-94 08:49:37 GMT   ; RFC 850, obsoleted by RFC 1036
       Sun Nov  6 08:49:37 1994         ; ANSI C's asctime() format
```

첫 번째 형식은 인터넷 표준으로 선호되며 RFC 1123\[6\]\(RFC 822\[7\]에 대한 업데이트\)에 정의된 형식의 고정 길이 하위 집합을 나타냅니다. 두 번째 형식은 일반적으로 사용되지만 더 이상 사용되지 않는 RFC 850 \[10\] 날짜 형식을 기반으로 하며 4자리 연도가 없습니다. 날짜 값을 구문 분석하는 HTTP/1.0 클라이언트와 서버는 세 가지 형식을 모두 허용해야 하지만 세 번째\(asctime\) 형식을 생성해서는 안 됩니다.

- 참고: 날짜 값 수신자는 프록시/게이트웨이를 통해 SMTP 또는 NNTP에 대한 메시지를 검색하거나 게시할 때 가끔 발생하는 것처럼 HTTP가 아닌 애플리케이션에 의해 생성되었을 수 있는 날짜 값을 수용하는 데 강력하도록 권장됩니다.

모든 HTTP/1.0 날짜/시간 스탬프는 예외 없이 GMT\(그리니치 표준시\)라고도 알려진 UT\(세계시\)로 표시되어야 합니다. 이는 시간대에 대한 3글자 약어로 "GMT"를 포함하여 처음 두 형식으로 표시되며 asctime 형식을 읽을 때 가정되어야 합니다.

```text
       HTTP-date      = rfc1123-date | rfc850-date | asctime-date

       rfc1123-date   = wkday "," SP date1 SP time SP "GMT"
       rfc850-date    = weekday "," SP date2 SP time SP "GMT"
       asctime-date   = wkday SP date3 SP time SP 4DIGIT

       date1          = 2DIGIT SP month SP 4DIGIT
                        ; day month year (e.g., 02 Jun 1982)
       date2          = 2DIGIT "-" month "-" 2DIGIT
                        ; day-month-year (e.g., 02-Jun-82)
       date3          = month SP ( 2DIGIT | ( SP 1DIGIT ))
                        ; month day (e.g., Jun  2)

       time           = 2DIGIT ":" 2DIGIT ":" 2DIGIT
                        ; 00:00:00 - 23:59:59

       wkday          = "Mon" | "Tue" | "Wed"
                      | "Thu" | "Fri" | "Sat" | "Sun"

       weekday        = "Monday" | "Tuesday" | "Wednesday"
                      | "Thursday" | "Friday" | "Saturday" | "Sunday"

       month          = "Jan" | "Feb" | "Mar" | "Apr"
                      | "May" | "Jun" | "Jul" | "Aug"
                      | "Sep" | "Oct" | "Nov" | "Dec"

       Note: HTTP requirements for the date/time stamp format apply
       only to their usage within the protocol stream. Clients and
       servers are not required to use these formats for user

       presentation, request logging, etc.
```

---
## **3.4  Character Sets**

HTTP는 MIME에 대해 설명된 것과 동일한 "문자 집합"이라는 용어 정의를 사용합니다.

- 이 문서에서 "문자 집합"이라는 용어는 일련의 옥텟을 문자 시퀀스로 변환하기 위해 하나 이상의 테이블에 사용되는 방법을 나타내는 데 사용됩니다. 지정된 문자 집합에서 모든 문자를 사용할 수 있는 것은 아니며 문자 집합이 특정 문자를 나타내기 위해 두 개 이상의 옥텟 시퀀스를 제공할 수 있다는 점에서 반대 방향의 무조건적인 변환은 필요하지 않습니다. 이 정의는 US-ASCII와 같은 간단한 단일 테이블 매핑부터 ISO 2022 기술을 사용하는 복잡한 테이블 전환 방법에 이르기까지 다양한 종류의 문자 인코딩을 허용하기 위한 것입니다. 그러나 MIME 문자 집합 이름과 관련된 정의는 옥텟에서 문자로 수행될 매핑을 완전히 지정해야 합니다. 특히, 정확한 매핑을 결정하기 위해 외부 프로파일링 정보를 사용하는 것은 허용되지 않습니다.

- 참고: "문자 집합"이라는 용어를 사용하는 것은 일반적으로 "문자 인코딩"이라고 합니다. 그러나 HTTP와 MIME은 동일한 레지스트리를 공유하므로 용어도 공유하는 것이 중요합니다.

HTTP 문자 집합은 대소문자를 구분하지 않는 토큰으로 식별됩니다. 전체 토큰 세트는 IANA 문자 세트 레지스트리\[15\]에 의해 정의됩니다. 그러나 해당 레지스트리는 각 문자 집합에 대해 일관된 단일 토큰을 정의하지 않기 때문에 여기서는 HTTP 엔터티와 함께 ​​사용될 가능성이 가장 높은 문자 집합에 대한 기본 이름을 정의합니다. 이러한 문자 세트에는 RFC 1521 \[5\]에 등록된 US-ASCII \[17\] 및 ISO-8859 \[18\] 문자 세트와 MIME 문자 세트 매개변수 내에서 사용하도록 특별히 권장되는 기타 이름이 포함됩니다.

```text
     charset = "US-ASCII"
             | "ISO-8859-1" | "ISO-8859-2" | "ISO-8859-3"
             | "ISO-8859-4" | "ISO-8859-5" | "ISO-8859-6"
             | "ISO-8859-7" | "ISO-8859-8" | "ISO-8859-9"
             | "ISO-2022-JP" | "ISO-2022-JP-2" | "ISO-2022-KR"
             | "UNICODE-1-1" | "UNICODE-1-1-UTF-7" | "UNICODE-1-1-UTF-8"
             | token
```

HTTP에서는 임의의 토큰을 charset 값으로 사용할 수 있지만 IANA 문자 집합 레지스트리\[15\] 내에서 미리 정의된 값을 가진 모든 토큰은 정의된 문자 집합을 나타내야 합니다.

해당 레지스트리에 의해. 애플리케이션은 문자 집합 사용을 IANA 레지스트리에서 정의한 문자 집합으로 제한해야 합니다.

엔터티 본문의 문자 집합은 해당 본문 내에서 사용되는 문자 코드의 최소 공통 분모로 라벨을 지정해야 합니다. 단, US-ASCII 또는 ISO-8859-1 라벨보다 선호되는 라벨은 없습니다.

---
## **3.5  Content Codings**

콘텐츠 코딩 값은 리소스에 적용된 인코딩 변환을 나타내는 데 사용됩니다. 콘텐츠 코딩은 기본 미디어 유형의 ID를 잃지 않고 문서를 압축하거나 암호화하는 데 주로 사용됩니다. 일반적으로 리소스는 이 인코딩으로 저장되며 렌더링 또는 유사한 사용 전에만 디코딩됩니다.

```text
       content-coding = "x-gzip" | "x-compress" | token
```

- 참고: 향후 호환성을 위해 HTTP/1.0 응용 프로그램은 "gzip" 및 "compress"를 각각 "x-gzip" 및 "x-compress"와 동일하게 간주해야 합니다.

모든 콘텐츠 코딩 값은 대소문자를 구분하지 않습니다. HTTP/1.0은 Content-Encoding\(섹션 10.3\) 헤더 필드에서 콘텐츠 코딩 값을 사용합니다. 값은 콘텐츠 코딩을 설명하지만 더 중요한 것은 인코딩을 제거하는 데 필요한 디코딩 메커니즘이 무엇인지 나타내는 것입니다. 단일 프로그램이 여러 콘텐츠 코딩 형식을 디코딩할 수 있다는 점에 유의하세요. 이 사양에서는 두 가지 값을 정의합니다.

x-gzip - Jean-loup Gailly가 개발한 파일 압축 프로그램 "gzip"\(GNU zip\)으로 생성된 인코딩 형식입니다. 이 형식은 일반적으로 32비트 CRC를 사용하는 Lempel-Ziv 코딩\(LZ77\)입니다.

x-compress - 파일 압축 프로그램 "compress"에 의해 생성된 인코딩 형식입니다. 이 형식은 적응형 Lempel-Ziv-Welch 코딩\(LZW\)입니다.

- 참고: 인코딩 형식을 식별하기 위해 프로그램 이름을 사용하는 것은 바람직하지 않으며 향후 인코딩에서는 권장되지 않습니다. 여기서의 사용은 좋은 디자인이 아니라 역사적 관행을 대표합니다.

---
## **3.6  Media Types**

HTTP는 개방적이고 확장 가능한 데이터 유형을 제공하기 위해 Content-Type 헤더 필드\(섹션 10.5\)에서 인터넷 미디어 유형\[13\]을 사용합니다.

```text
       media-type     = type "/" subtype *( ";" parameter )
       type           = token
       subtype        = token
```

매개변수는 속성/값 쌍의 형태로 유형/하위 유형을 따를 수 있습니다.

```text
       parameter      = attribute "=" value
       attribute      = token
       value          = token | quoted-string
```

유형, 하위 유형 및 매개변수 속성 이름은 대소문자를 구분하지 않습니다. 매개변수 값은 매개변수 이름의 의미에 따라 대소문자를 구분할 수도 있고 그렇지 않을 수도 있습니다. LWS는 유형과 하위 유형 사이, 속성과 해당 값 사이에서 생성되어서는 안 됩니다. 인식할 수 없는 매개변수가 있는 미디어 유형을 수신하면 사용자 에이전트는 인식할 수 없는 매개변수와 그 값이 존재하지 않는 것처럼 미디어 유형을 처리해야 합니다.

일부 이전 HTTP 애플리케이션은 미디어 유형 매개변수를 인식하지 못합니다. HTTP/1.0 애플리케이션은 메시지 내용을 정의하는 데 필요한 경우에만 미디어 유형 매개변수를 사용해야 합니다.

미디어 유형 값은 IANA \[15\]\)에 등록됩니다. 미디어 유형 등록 프로세스는 RFC 1590 \[13\]에 요약되어 있습니다. 등록되지 않은 미디어 유형의 사용은 권장되지 않습니다.

---
### **3.6.1 Canonicalization and Text Defaults**

인터넷 미디어 유형은 표준 형식으로 등록됩니다. 일반적으로 HTTP를 통해 전송되는 Entity-Body는 전송 전에 적절한 표준 형식으로 표현되어야 합니다. 본문이 Content-Encoding으로 인코딩된 경우 기본 데이터는 인코딩되기 전에 표준 형식이어야 합니다.

"텍스트" 유형의 미디어 하위 유형은 표준 형식일 때 CRLF를 텍스트 줄 바꿈으로 사용합니다. 그러나 HTTP는 Entity-Body 내에서 일관되게 사용될 때 줄 바꿈을 나타내는 일반 CR 또는 LF만으로 텍스트 미디어 전송을 허용합니다. HTTP 애플리케이션은 HTTP를 통해 수신된 텍스트 미디어의 줄 바꿈을 나타내는 CRLF, 베어 CR 및 베어 LF를 허용해야 합니다.

또한 텍스트 미디어가 일부 멀티바이트 문자 집합의 경우처럼 CR과 LF에 각각 옥텟 13과 10을 사용하지 않는 문자 집합으로 표현되는 경우 HTTP는 다음과 같이 정의된 옥텟 시퀀스의 사용을 허용합니다. 줄 바꿈에 대한 CR 및 LF와 동일한 문자 집합입니다. 줄 바꿈과 관련된 이러한 유연성은 Entity-Body의 텍스트 미디어에만 적용됩니다. HTTP 제어 구조\(예: 헤더 필드 및 멀티파트 경계\) 내에서 CRLF를 베어 CR 또는 LF로 대체해서는 안 됩니다.

"charset" 매개변수는 일부 미디어 유형에서 데이터의 문자 집합\(섹션 3.4\)을 정의하는 데 사용됩니다. 보낸 사람이 명시적인 charset 매개 변수를 제공하지 않으면 "text" 유형의 미디어 하위 유형은 HTTP를 통해 수신될 때 "ISO-8859-1"의 기본 문자 집합 값을 갖도록 정의됩니다. "ISO-8859-1" 이외의 문자 세트 또는 그 하위 세트의 데이터는 수신자가 일관되게 해석할 수 있도록 적절한 문자 세트 값으로 레이블을 지정해야 합니다.

- 참고: 현재 많은 HTTP 서버는 적절한 라벨링 없이 "ISO-8859-1" 이외의 문자 세트를 사용하여 데이터를 제공합니다. 이 상황은 상호 운용성을 감소시키므로 권장되지 않습니다. 이를 보완하기 위해 일부 HTTP 사용자 에이전트는 charset 매개변수가 제공되지 않을 때 사용자가 미디어 유형 문자 집합의 기본 해석을 변경할 수 있도록 구성 옵션을 제공합니다.

---
### **3.6.2 Multipart Types**

MIME은 단일 메시지의 Entity-Body 내에 여러 엔터티를 캡슐화하는 다양한 "다중 부분" 유형을 제공합니다. IANA \[15\]에 등록된 다중 부분 유형은 HTTP/1.0에 대해 특별한 의미를 갖지 않지만 사용자 에이전트는 각 본문 부분의 목적을 올바르게 해석하기 위해 각 유형을 이해해야 할 수 있습니다. HTTP 사용자 에이전트는 멀티파트 유형을 수신할 때 MIME 사용자 에이전트가 수행하는 것과 동일하거나 유사한 동작을 따라야 합니다. HTTP 서버는 모든 HTTP 클라이언트가 멀티파트 유형을 처리할 준비가 되어 있다고 가정해서는 안 됩니다.

모든 멀티파트 유형은 공통 구문을 공유하며 미디어 유형 값의 일부로 경계 매개변수를 포함해야 합니다. 메시지 본문은 그 자체로 프로토콜 요소이므로 본문 부분 사이의 줄 바꿈을 나타내기 위해 CRLF만 사용해야 합니다. 다중 부분 본문 부분에는 해당 부분의 의미에 중요한 HTTP 헤더 필드가 포함될 수 있습니다.

---
## **3.7  Product Tokens**

제품 토큰은 선택적 슬래시 및 버전 지정자를 사용하여 간단한 제품 토큰을 통해 통신 애플리케이션이 자신을 식별할 수 있도록 하는 데 사용됩니다. 제품 토큰을 사용하는 대부분의 필드에서는 애플리케이션의 중요한 부분을 구성하는 하위 제품도 허용합니다.

공백으로 구분하여 나열됩니다. 일반적으로 제품은 용도를 식별하는 데 중요한 순서대로 나열됩니다.

```text
       product         = token ["/" product-version]
       product-version = token

   Examples:

       User-Agent: CERN-LineMode/2.15 libwww/2.17b3

       Server: Apache/0.8.4
```

제품 토큰은 짧고 명확해야 합니다. 광고나 기타 중요하지 않은 정보에 사용하는 것은 명시적으로 금지됩니다. 제품 버전에 토큰 문자가 나타날 수 있더라도 이 토큰은 버전 식별자로만 사용해야 합니다. 즉, 동일한 제품의 후속 버전은 제품 값의 제품 버전 부분에서만 달라야 합니다.

---
## **4.  HTTP Message**
---
## **4.1  Message Types**

HTTP 메시지는 클라이언트에서 서버로의 요청과 서버에서 클라이언트로의 응답으로 구성됩니다.

```text
       HTTP-message   = Simple-Request           ; HTTP/0.9 messages
                      | Simple-Response
                      | Full-Request             ; HTTP/1.0 messages
                      | Full-Response
```

전체 요청 및 전체 응답은 엔터티 전송을 위해 RFC 822 \[7\]의 일반 메시지 형식을 사용합니다. 두 메시지 모두 선택적 헤더 필드\("헤더"라고도 함\)와 엔터티 본문을 포함할 수 있습니다. 엔터티 본문은 null 줄\(즉, CRLF 앞에 아무것도 없는 줄\)로 헤더와 구분됩니다.

```text
       Full-Request   = Request-Line             ; Section 5.1
                        *( General-Header        ; Section 4.3
                         | Request-Header        ; Section 5.2
                         | Entity-Header )       ; Section 7.1
                        CRLF
                        [ Entity-Body ]          ; Section 7.2

       Full-Response  = Status-Line              ; Section 6.1
                        *( General-Header        ; Section 4.3
                         | Response-Header       ; Section 6.2

                         | Entity-Header )       ; Section 7.1
                        CRLF
                        [ Entity-Body ]          ; Section 7.2
```

Simple-Request와 Simple-Response는 헤더 정보의 사용을 허용하지 않으며 단일 요청 방식\(GET\)으로 제한됩니다.

```text
       Simple-Request  = "GET" SP Request-URI CRLF

       Simple-Response = [ Entity-Body ]
```

단순 요청 형식을 사용하면 서버가 반환된 엔터티의 미디어 유형을 식별할 수 없으므로 사용하지 않는 것이 좋습니다.

---
## **4.2  Message Headers**

General-Header\(섹션 4.3\), Request-Header\(섹션 5.2\), Response-Header\(섹션 6.2\) 및 Entity-Header\(섹션 7.1\) 필드를 포함하는 HTTP 헤더 필드는 섹션에 제공된 것과 동일한 일반 형식을 따릅니다. RFC 822 \[7\]의 3.1. 각 헤더 필드는 이름 바로 뒤에 콜론\(":"\), 단일 공백\(SP\) 문자 및 필드 값으로 구성됩니다. 필드 이름은 대소문자를 구분합니다. 헤더 필드는 각 추가 줄 앞에 최소한 하나의 SP 또는 HT를 추가하여 여러 줄로 확장할 수 있지만 권장되지는 않습니다.

```text
       HTTP-header    = field-name ":" [ field-value ] CRLF

       field-name     = token
       field-value    = *( field-content | LWS )

       field-content  = <the OCTETs making up the field-value
                        and consisting of either *TEXT or combinations
                        of token, tspecials, and quoted-string>
```

헤더 필드가 수신되는 순서는 중요하지 않습니다. 그러나 General-Header 필드를 먼저 보낸 다음 Entity-Header 필드보다 먼저 Request-Header 또는 Response-Header 필드를 보내는 것이 "좋은 습관"입니다.

해당 헤더 필드의 전체 필드 값이 쉼표로 구분된 목록\[예: #\(값\)\]으로 정의된 경우에만 필드 이름이 동일한 여러 HTTP 헤더 필드가 메시지에 존재할 수 있습니다. 메시지의 의미를 변경하지 않고 여러 헤더 필드를 하나의 "필드-이름: 필드-값" 쌍으로 결합할 수 있어야 하며, 각 후속 필드 값을 첫 번째 필드에 추가하고 각각을 쉼표로 구분해야 합니다.

---
## **4.3  General Header Fields**

요청 및 응답 메시지 모두에 일반적으로 적용할 수 있지만 전송되는 엔터티에는 적용되지 않는 몇 가지 헤더 필드가 있습니다. 이러한 헤더는 전송되는 메시지에만 적용됩니다.

```text
       General-Header = Date                     ; Section 10.6
                      | Pragma                   ; Section 10.12
```

일반 헤더 필드 이름은 프로토콜 버전이 변경된 경우에만 안정적으로 확장될 수 있습니다. 그러나 통신의 모든 당사자가 해당 헤더 필드를 일반 헤더 필드로 인식하는 경우 새롭거나 실험적인 헤더 필드에 일반 헤더 필드의 의미가 부여될 수 있습니다. 인식할 수 없는 헤더 필드는 엔터티 헤더 필드로 처리됩니다.

---
## **5. Request**

클라이언트에서 서버로 보내는 요청 메시지에는 해당 메시지의 첫 번째 줄에 리소스에 적용할 메서드, 리소스 식별자 및 사용 중인 프로토콜 버전이 포함됩니다. 보다 제한된 HTTP/0.9 프로토콜과의 이전 버전 호환성을 위해 HTTP 요청에 대해 두 가지 유효한 형식이 있습니다.

```text
       Request        = Simple-Request | Full-Request

       Simple-Request = "GET" SP Request-URI CRLF

       Full-Request   = Request-Line             ; Section 5.1
                        *( General-Header        ; Section 4.3
                         | Request-Header        ; Section 5.2
                         | Entity-Header )       ; Section 7.1
                        CRLF
                        [ Entity-Body ]          ; Section 7.2
```

HTTP/1.0 서버가 Simple-Request를 받으면 HTTP/0.9 Simple-Response로 응답해야 합니다. 전체 응답을 수신할 수 있는 HTTP/1.0 클라이언트는 단순 요청을 생성해서는 안 됩니다.

---
## **5.1  Request-Line**

Request-Line은 메소드 토큰으로 시작하고 그 뒤에 Request-URI와 프로토콜 버전이 오고 CRLF로 끝납니다. 요소는 SP 문자로 구분됩니다. 최종 CRLF 시퀀스를 제외하고 CR 또는 LF는 허용되지 않습니다.

```text
       Request-Line = Method SP Request-URI SP HTTP-Version CRLF
```

단순 요청과 전체 요청의 요청 라인의 차이점은 HTTP 버전 필드가 있고 GET 이외의 방법을 사용할 수 있다는 것입니다.

---
### **5.1.1 Method**

Method 토큰은 Request-URI에 의해 식별된 리소스에 대해 수행될 메서드를 나타냅니다. 이 방법은 대소문자를 구분합니다.

```text
       Method         = "GET"                    ; Section 8.1
                      | "HEAD"                   ; Section 8.2
                      | "POST"                   ; Section 8.3
                      | extension-method

       extension-method = token
```

특정 리소스에서 허용되는 메서드 목록은 동적으로 변경될 수 있습니다. 리소스에 메소드가 허용되지 않는 경우 클라이언트는 응답의 반환 코드를 통해 알림을 받습니다. 메서드가 인식되지 않거나 구현되지 않은 경우 서버는 상태 코드 501\(구현되지 않음\)을 반환해야 합니다.

HTTP/1.0 애플리케이션에서 일반적으로 사용되는 방법은 섹션 8에 완전히 정의되어 있습니다.

---
### **5.1.2 Request-URI**

요청-URI는 통일 자원 식별자\(섹션 3.2\)이며 요청을 적용할 자원을 식별합니다.

```text
       Request-URI    = absoluteURI | abs_path
```

Request-URI의 두 가지 옵션은 요청의 성격에 따라 다릅니다.

절대URI 형식은 요청이 프록시에 이루어질 때만 허용됩니다. 프록시는 요청을 전달하고 응답을 반환하도록 요청됩니다. 요청이 GET 또는 HEAD이고 이전 응답이 캐시된 경우 프록시는 Expires 헤더 필드의 제한 사항을 통과하면 캐시된 메시지를 사용할 수 있습니다. 프록시는 요청을 다른 프록시로 전달할 수도 있고, 절대URI에 의해 지정된 서버로 직접 전달할 수도 있습니다. 요청 루프를 방지하려면 프록시는 별칭, 로컬 변형 및 숫자 IP 주소를 포함하여 모든 서버 이름을 인식할 수 있어야 합니다. 요청 라인의 예는 다음과 같습니다.

```text
       GET http://www.w3.org/pub/WWW/TheProject.html HTTP/1.0
```

요청-URI의 가장 일반적인 형태는 원본 서버나 게이트웨이에서 리소스를 식별하는 데 사용되는 것입니다. 이 경우 URI의 절대 경로만 전송됩니다\(섹션 3.2.1, abs\_path 참조\). 예를 들어, 원본 서버에서 직접 위의 리소스를 검색하려는 클라이언트는 호스트 "www.w3.org"의 포트 80에 대한 TCP 연결을 생성하고 다음 행을 보냅니다.

```text
       GET /pub/WWW/TheProject.html HTTP/1.0
```

전체 요청의 나머지 부분이 이어집니다. 절대 경로는 비워둘 수 없습니다. 원래 URI에 아무것도 없으면 "/"\(서버 루트\)로 제공되어야 합니다.

Request-URI는 인코딩된 문자열로 전송되며, 여기서 일부 문자는 RFC 1738\[4\]에 정의된 "% HEX HEX" 인코딩을 사용하여 이스케이프될 수 있습니다. 원본서버는 요청을 적절하게 해석하기 위해 Request-URI를 디코딩해야 합니다.

---
## **5.2  Request Header Fields**

요청 헤더 필드를 사용하면 클라이언트는 요청 및 클라이언트 자체에 대한 추가 정보를 서버에 전달할 수 있습니다. 이러한 필드는 프로그래밍 언어 메소드\(프로시저\) 호출의 매개변수와 동일한 의미를 갖는 요청 수정자 역할을 합니다.

```text
       Request-Header = Authorization            ; Section 10.2
                      | From                     ; Section 10.8
                      | If-Modified-Since        ; Section 10.9
                      | Referer                  ; Section 10.13
                      | User-Agent               ; Section 10.15
```

요청 헤더 필드 이름은 프로토콜 버전이 변경된 경우에만 안정적으로 확장될 수 있습니다. 그러나 통신의 모든 당사자가 해당 헤더 필드를 요청 헤더 필드로 인식하는 경우 새롭거나 실험적인 헤더 필드에 요청 헤더 필드의 의미가 부여될 수 있습니다. 인식할 수 없는 헤더 필드는 엔터티 헤더 필드로 처리됩니다.

---
## **6.  Response**

서버는 요청 메시지를 수신하고 해석한 후 HTTP 응답 메시지 형식으로 응답합니다.

```text
       Response        = Simple-Response | Full-Response

       Simple-Response = [ Entity-Body ]

       Full-Response   = Status-Line             ; Section 6.1
                         *( General-Header       ; Section 4.3
                          | Response-Header      ; Section 6.2
                          | Entity-Header )      ; Section 7.1
                         CRLF
                         [ Entity-Body ]         ; Section 7.2
```

Simple-Response는 HTTP/0.9 Simple-Request에 대한 응답으로 또는 서버가 더 제한된 HTTP/0.9 프로토콜만 지원하는 경우에만 전송되어야 합니다. 클라이언트가 HTTP/1.0 전체 요청을 보내고 상태 줄로 시작하지 않는 응답을 받으면 해당 응답이 단순 응답이라고 가정하고 이에 따라 구문 분석해야 합니다. Simple-Response는 엔터티 본문으로만 구성되며 서버가 연결을 닫으면 종료됩니다.

---
## **6.1  Status-Line**

전체 응답 메시지의 첫 번째 줄은 프로토콜 버전, 숫자 상태 코드 및 관련 텍스트 문구로 구성된 상태 줄입니다. 각 요소는 SP 문자로 구분됩니다. 최종 CRLF 시퀀스를 제외하고 CR 또는 LF는 허용되지 않습니다.

```text
       Status-Line = HTTP-Version SP Status-Code SP Reason-Phrase CRLF
```

상태 줄은 항상 프로토콜 버전과 상태 코드로 시작되므로

```text
       "HTTP/" 1*DIGIT "." 1*DIGIT SP 3DIGIT SP
```

\(예: "HTTP/1.0 200 "\), 해당 표현의 존재만으로도 전체 응답과 단순 응답을 구별하기에 충분합니다. Simple-Response 형식에서는 이러한 표현이 엔터티 본문의 시작 부분에 발생할 수 있으므로 Full-Request에 대한 응답으로 제공된 경우 메시지가 잘못 해석될 수 있지만 대부분의 HTTP/0.9 서버는 응답으로 제한됩니다. "text/html" 유형이므로 그러한 응답을 생성하지 않습니다.

---
### **6.1.1 Status Code and Reason Phrase**

Status-Code 요소는 요청을 이해하고 만족시키려는 시도의 3자리 정수 결과 코드입니다. Reason-Phrase는 상태 코드에 대한 간단한 텍스트 설명을 제공하기 위한 것입니다. Status-Code는 오토마타에서 사용하기 위한 것이고 Reason-Phrase는 인간 사용자를 위한 것입니다. 클라이언트는 이유 문구를 검사하거나 표시할 필요가 없습니다.

상태 코드의 첫 번째 숫자는 응답 클래스를 정의합니다. 마지막 두 자리에는 분류 역할이 없습니다. 첫 번째 숫자에는 5개의 값이 있습니다.

- 1xx: 정보용 - 사용되지 않지만 향후 사용을 위해 예약되어 있습니다.

```text
      o 2xx: Success - The action was successfully received,
             understood, and accepted.

      o 3xx: Redirection - Further action must be taken in order to
             complete the request

      o 4xx: Client Error - The request contains bad syntax or cannot
             be fulfilled

      o 5xx: Server Error - The server failed to fulfill an apparently
             valid request
```

HTTP/1.0에 정의된 숫자 상태 코드의 개별 값과 해당 이유 구문의 예시 세트가 아래에 나와 있습니다. 여기에 나열된 이유 문구는 권장 사항일 뿐입니다. 프로토콜에 영향을 주지 않고 해당 지역의 문구로 대체될 수 있습니다. 이러한 코드는 섹션 9에 완전히 정의되어 있습니다.

```text
       Status-Code    = "200"   ; OK
                      | "201"   ; Created
                      | "202"   ; Accepted
                      | "204"   ; No Content
                      | "301"   ; Moved Permanently
                      | "302"   ; Moved Temporarily
                      | "304"   ; Not Modified
                      | "400"   ; Bad Request
                      | "401"   ; Unauthorized
                      | "403"   ; Forbidden
                      | "404"   ; Not Found
                      | "500"   ; Internal Server Error
                      | "501"   ; Not Implemented
                      | "502"   ; Bad Gateway
                      | "503"   ; Service Unavailable
                      | extension-code

       extension-code = 3DIGIT

       Reason-Phrase  = *<TEXT, excluding CR, LF>
```

HTTP 상태 코드는 확장 가능하지만 위의 코드는 현재 실무에서 일반적으로 인식되는 유일한 코드입니다. HTTP 애플리케이션은 등록된 모든 상태의 의미를 이해할 필요가 없습니다.

코드를 이해하는 것이 분명히 바람직하지만. 그러나 애플리케이션은 첫 번째 숫자로 표시된 모든 상태 코드의 클래스를 이해해야 하며, 인식할 수 없는 응답을 캐시해서는 안 된다는 점을 제외하고는 인식할 수 없는 모든 응답을 해당 클래스의 x00 상태 코드와 동일한 것으로 처리해야 합니다. 예를 들어, 클라이언트가 인식할 수 없는 상태 코드 431을 수신하면 요청에 문제가 있다고 안전하게 가정하고 응답을 400 상태 코드를 수신한 것처럼 처리할 수 있습니다. 그러한 경우, 사용자 에이전트는 응답과 함께 반환된 엔터티를 사용자에게 제시해야 합니다. 그 엔터티에는 비정상적인 상태를 설명하는 사람이 읽을 수 있는 정보가 포함될 가능성이 높기 때문입니다.

---
## **6.2  Response Header Fields**

응답 헤더 필드를 사용하면 서버는 StatusLine에 배치할 수 없는 응답에 대한 추가 정보를 전달할 수 있습니다. 이러한 헤더 필드는 서버에 대한 정보와 Request-URI로 식별된 리소스에 대한 추가 액세스에 대한 정보를 제공합니다.

```text
       Response-Header = Location                ; Section 10.11
                       | Server                  ; Section 10.14
                       | WWW-Authenticate        ; Section 10.16
```

응답 헤더 필드 이름은 프로토콜 버전이 변경되는 경우에만 안정적으로 확장될 수 있습니다. 그러나 통신의 모든 당사자가 해당 헤더 필드를 응답 헤더 필드로 인식하는 경우 새롭거나 실험적인 헤더 필드에 응답 헤더 필드의 의미가 부여될 수 있습니다. 인식할 수 없는 헤더 필드는 엔터티 헤더 필드로 처리됩니다.

---
## **7.  Entity**

전체 요청 및 전체 응답 메시지는 일부 요청 및 응답 내에서 엔터티를 전송할 수 있습니다. 엔터티는 Entity-Header 필드와 \(일반적으로\) Entity-Body로 구성됩니다. 이 섹션에서 보낸 사람과 받는 사람 모두 엔터티를 보내는 사람과 받는 사람에 따라 클라이언트나 서버를 나타냅니다.

---
## **7.1  Entity Header Fields**

Entity-Header 필드는 Entity-Body 또는 본문이 없는 경우 요청에 의해 식별된 리소스에 대한 선택적 메타 정보를 정의합니다.

```text
       Entity-Header  = Allow                    ; Section 10.1
                      | Content-Encoding         ; Section 10.3
                      | Content-Length           ; Section 10.4
                      | Content-Type             ; Section 10.5
                      | Expires                  ; Section 10.7
                      | Last-Modified            ; Section 10.10
                      | extension-header

       extension-header = HTTP-header
```

확장 헤더 메커니즘을 사용하면 프로토콜을 변경하지 않고도 추가 Entity-Header 필드를 정의할 수 있지만 이러한 필드는 수신자가 인식할 수 있다고 가정할 수 없습니다. 인식되지 않는 헤더 필드는 수신자가 무시하고 프록시에 의해 전달되어야 합니다.

---
## **7.2  Entity Body**

HTTP 요청 또는 응답과 함께 전송된 엔터티 본문\(있는 경우\)은 엔터티 헤더 필드에 정의된 형식 및 인코딩을 따릅니다.

```text
       Entity-Body    = *OCTET
```

엔터티 본문은 요청 메서드가 엔터티 본문을 호출할 때만 요청 메시지에 포함됩니다. 요청에 엔터티 본문이 있다는 것은 요청 메시지 헤더에 Content-Length 헤더 필드가 포함되어 있음을 나타냅니다. 엔터티 본문이 포함된 HTTP/1.0 요청에는 유효한 Content-Length 헤더 필드가 포함되어야 합니다.

응답 메시지의 경우 엔터티 본문이 메시지에 포함되는지 여부는 요청 방법과 응답 코드에 따라 달라집니다. HEAD 요청 메서드에 대한 모든 응답에는 본문이 포함되어서는 안 됩니다. 비록 엔터티 헤더 필드가 있으면 본문이 포함되어 있다고 믿을 수 있습니다. 모든 1xx\(정보\), 204\(콘텐츠 없음\) 및 304\(수정되지 않음\) 응답에는 본문이 포함되어서는 안 됩니다. 다른 모든 응답에는 0 값으로 정의된 엔터티 본문 또는 Content-Length 헤더 필드가 포함되어야 합니다.

---
### **7.2.1 Type**

Entity-Body가 메시지에 포함된 경우 해당 본문의 데이터 유형은 헤더 필드 Content-Type 및 Content-Encoding을 통해 결정됩니다. 이는 순서가 지정된 2계층 인코딩 모델을 정의합니다.

```text
       entity-body := Content-Encoding( Content-Type( data ) )
```

Content-Type은 기본 데이터의 미디어 유형을 지정합니다. Content-Encoding은 일반적으로 데이터 압축을 목적으로 요청된 리소스의 속성인 유형에 적용되는 추가 콘텐츠 코딩을 나타내는 데 사용될 수 있습니다. 콘텐츠 인코딩의 기본값은 없음\(즉, ID 함수\)입니다.

엔터티 본문을 포함하는 모든 HTTP/1.0 메시지에는 해당 본문의 미디어 유형을 정의하는 Content-Type 헤더 필드가 포함되어야 합니다. Simple-Response 메시지의 경우처럼 미디어 유형이 Content-Type 헤더에 의해 제공되지 않는 경우에만 수신자는 콘텐츠 및/또는 이름 확장자를 검사하여 미디어 유형을 추측하려고 시도할 수 있습니다. 리소스를 식별하는 데 사용되는 URL입니다. 미디어 유형을 알 수 없는 경우 수신자는 이를 "application/octet-stream" 유형으로 처리해야 합니다.

---
### **7.2.2 Length**

Entity-Body가 메시지에 포함된 경우 해당 본문의 길이는 두 가지 방법 중 하나로 결정될 수 있습니다. Content-Length 헤더 필드가 있는 경우 해당 값\(바이트\)은 Entity-Body의 길이를 나타냅니다. 그렇지 않으면 본문 길이는 서버의 연결 종료에 따라 결정됩니다.

연결을 닫으면 서버가 응답을 다시 보낼 가능성이 없기 때문에 요청 본문의 끝을 나타내는 데 사용할 수 없습니다. 따라서 엔터티 본문이 포함된 HTTP/1.0 요청에는 유효한 Content-Length 헤더 필드가 포함되어야 합니다. 요청에 엔터티 본문이 포함되어 있고 Content-Length가 지정되지 않았고 서버가 다른 필드의 길이를 인식하지 못하거나 계산할 수 없는 경우 서버는 400\(잘못된 요청\) 응답을 보내야 합니다.

- 참고: 일부 이전 서버는 데이터 스트림에 동적으로 삽입된 서버 측 포함이 포함된 문서를 보낼 때 잘못된 Content-Length를 제공합니다. 이는 향후 버전의 HTTP에서는 허용되지 않을 것이라는 점을 강조해야 합니다. 클라이언트가 규격 서버로부터 응답을 받고 있다는 사실을 알지 않는 한, Content-Length 값이 올바른지에 의존해서는 안 됩니다.

---
## **8.  Method Definitions**

HTTP/1.0의 일반적인 메소드 세트는 아래에 정의되어 있습니다. 이 세트는 확장될 수 있지만 추가 메소드가 별도로 확장된 클라이언트 및 서버에 대해 동일한 의미를 공유한다고 가정할 수는 없습니다.

---
## **8.1  GET**

GET 메소드는 요청-URI에 의해 식별되는 모든 정보\(엔티티 형식\)를 검색하는 것을 의미합니다. 요청-URI가 데이터 생성 프로세스를 참조하는 경우 해당 텍스트가 프로세스의 출력이 아닌 한 프로세스의 소스 텍스트가 아닌 응답의 엔터티로 반환되는 것은 생성된 데이터입니다.

요청 메시지에 If-Modified-Since 헤더 필드가 포함되어 있으면 GET 메서드의 의미가 "조건부 GET"으로 변경됩니다. 조건부 GET 방법은 섹션 10.9에 설명된 대로 If-Modified-Since 헤더에 의해 제공된 날짜 이후 수정된 경우에만 식별된 리소스가 전송되도록 요청합니다. 조건부 GET 방법은 여러 요청을 요구하거나 불필요한 데이터를 전송하지 않고도 캐시된 엔터티를 새로 고칠 수 있도록 하여 네트워크 사용량을 줄이기 위한 것입니다.

---
## **8.2  HEAD**

HEAD 메소드는 서버가 응답에 Entity-Body를 반환해서는 안 된다는 점을 제외하면 GET과 동일합니다. HEAD 요청에 대한 응답으로 HTTP 헤더에 포함된 메타정보는 GET 요청에 대한 응답으로 전송된 정보와 동일해야 합니다. 이 방법은 Entity-Body 자체를 전송하지 않고 Request-URI에 의해 식별된 자원에 대한 메타정보를 얻는 데 사용될 수 있습니다. 이 방법은 하이퍼텍스트 링크의 유효성, 접근성 및 최근 수정 사항을 테스트하는 데 자주 사용됩니다.

조건부 GET과 유사한 "조건부 HEAD" 요청은 없습니다. If-Modified-Since 헤더 필드가 HEAD 요청에 포함된 경우 무시해야 합니다.

---
## **8.3  POST**

POST 메소드는 요청 라인의 Request-URI에 의해 식별되는 자원의 새로운 하위 항목으로 요청에 포함된 엔터티를 대상 서버가 수락하도록 요청하는 데 사용됩니다. POST는 다음 기능을 처리하는 균일한 방법을 허용하도록 설계되었습니다.

- 기존 자원에 대한 주석;

- 게시판, 뉴스그룹, 메일링 리스트 또는 유사한 기사 그룹에 메시지 게시

- 양식 \[3\] 제출 결과와 같은 데이터 블록을 데이터 처리 프로세스에 제공합니다.

- 추가 작업을 통해 데이터베이스를 확장합니다.

POST 메서드에 의해 수행되는 실제 기능은 서버에 의해 결정되며 일반적으로 Request-URI에 따라 달라집니다. 게시된 엔터티는 파일이 이를 포함하는 디렉터리에 종속되고, 뉴스 기사가 게시된 뉴스 그룹에 종속되거나, 레코드가 데이터베이스에 종속되는 것과 같은 방식으로 해당 URI에 종속됩니다.

성공적인 POST에서는 엔터티가 원본 서버의 리소스로 생성되거나 향후 참조를 위해 액세스 가능하도록 요구되지 않습니다. 즉, POST 메서드로 수행된 작업으로 인해 URI로 식별할 수 있는 리소스가 생성되지 않을 수 있습니다. 이 경우 응답에 결과를 설명하는 엔터티가 포함되어 있는지 여부에 따라 200\(정상\) 또는 204\(콘텐츠 없음\)가 적절한 응답 상태입니다.

원본 서버에서 리소스가 생성된 경우 응답은 201\(생성됨\)이어야 하며 요청 상태를 설명하고 새 리소스를 참조하는 엔터티\(가급적 "text/html" 유형\)를 포함해야 합니다.

모든 HTTP/1.0 POST 요청에는 유효한 Content-Length가 필요합니다. HTTP/1.0 서버는 요청 메시지 내용의 길이를 확인할 수 없는 경우 400\(잘못된 요청\) 메시지로 응답해야 합니다.

애플리케이션은 서버가 향후 요청에 대해 동일한 응답을 반환할지 알 수 없기 때문에 POST 요청에 대한 응답을 캐시해서는 안 됩니다.

---
## **9.  Status Code Definitions**

각 상태 코드는 아래에 설명되어 있습니다. 여기에는 따를 수 있는 메서드에 대한 설명과 응답에 필요한 메타정보가 포함됩니다.

---
## **9.1  Informational 1xx**

이 상태 코드 클래스는 상태 줄과 선택적 헤더로만 구성된 임시 응답을 나타내며 빈 줄로 종료됩니다. HTTP/1.0은 1xx 상태 코드를 정의하지 않으며 HTTP/1.0 요청에 대한 유효한 응답이 아닙니다. 그러나 이 사양의 범위를 벗어나는 실험적 응용에는 유용할 수 있습니다.

---
## **9.2  Successful 2xx**

이 상태 코드 클래스는 클라이언트의 요청이 성공적으로 수신되고, 이해되고, 승인되었음을 나타냅니다.

```text
   200 OK
```

요청이 성공했습니다. 응답과 함께 반환되는 정보는 다음과 같이 요청에 사용된 방법에 따라 달라집니다.

```text
   GET    an entity corresponding to the requested resource is sent
          in the response;

   HEAD   the response must only contain the header information and
          no Entity-Body;
```

작업 결과를 설명하거나 포함하는 엔터티를 게시합니다.

```text
   201 Created
```

요청이 이행되어 새 리소스가 생성되었습니다. 새로 생성된 리소스는 응답 엔터티에 반환된 URI로 참조될 수 있습니다. 원본 서버는 이 상태 코드를 사용하기 전에 리소스를 생성해야 합니다. 작업을 즉시 수행할 수 없는 경우 서버는 리소스를 사용할 수 있는 시기에 대한 설명을 응답 본문에 포함해야 합니다. 그렇지 않으면 서버는 202\(수락됨\)로 응답해야 합니다.

본 사양에서 정의한 메소드 중 POST만이 리소스를 생성할 수 있습니다.

```text
   202 Accepted
```

처리 요청이 승인되었지만 처리가 완료되지 않았습니다. 요청이 실제로 처리될 때 허용되지 않을 수 있으므로 결국에는 조치가 취해질 수도 있고 이루어지지 않을 수도 있습니다. 이와 같은 비동기 작업에서 상태 코드를 다시 보내는 기능은 없습니다.

202 응답은 의도적으로 비커밋입니다. 그 목적은 프로세스가 완료될 때까지 서버에 대한 사용자 에이전트의 연결이 지속될 필요 없이 서버가 다른 프로세스\(아마도 하루에 한 번만 실행되는 배치 지향 프로세스\)에 대한 요청을 수락할 수 있도록 하는 것입니다. 이 응답과 함께 반환된 엔터티에는 요청의 현재 상태에 대한 표시와 상태 모니터에 대한 포인터 또는 사용자가 요청이 이행될 것으로 예상할 수 있는 시기에 대한 일부 추정이 포함되어야 합니다.

```text
   204 No Content
```

서버가 요청을 이행했지만 다시 보낼 새로운 정보가 없습니다. 클라이언트가 사용자 에이전트인 경우 요청을 발생시킨 문서 보기를 변경해서는 안 됩니다.

생성될 수 있습니다. 이 응답은 주로 사용자 에이전트의 활성 문서 보기를 변경하지 않고 스크립트 또는 기타 작업에 대한 입력을 허용하기 위한 것입니다. 응답에는 현재 사용자 에이전트의 활성 보기에 있는 문서에 적용되어야 하는 엔터티 헤더 형식의 새로운 메타정보가 포함될 수 있습니다.

---
## **9.3  Redirection 3xx**

이 상태 코드 클래스는 요청을 이행하기 위해 사용자 에이전트가 추가 조치를 취해야 함을 나타냅니다. 필요한 작업은 후속 요청에 사용된 메서드가 GET 또는 HEAD인 경우에만 사용자와의 상호 작용 없이 사용자 에이전트에 의해 수행될 수 있습니다. 사용자 에이전트는 자동으로 요청을 5회 이상 리디렉션해서는 안 됩니다. 이러한 리디렉션은 일반적으로 무한 루프를 나타내기 때문입니다.

```text
   300 Multiple Choices
```

이 응답 코드는 HTTP/1.0 애플리케이션에서 직접 사용되지 않지만 3xx 클래스의 응답을 해석하기 위한 기본값으로 사용됩니다.

요청한 리소스를 하나 이상의 위치에서 사용할 수 있습니다. HEAD 요청이 아닌 한, 응답에는 사용자 또는 사용자 에이전트가 가장 적절한 것을 선택할 수 있는 리소스 특성 및 위치 목록이 포함된 엔터티가 포함되어야 합니다. 서버가 선호하는 선택 사항이 있는 경우 위치 필드에 URL을 포함해야 합니다. 사용자 에이전트는 자동 리디렉션을 위해 이 필드 값을 사용할 수 있습니다.

```text
   301 Moved Permanently
```

요청된 리소스에는 새로운 영구 URL이 할당되었으며 이 리소스에 대한 향후 참조는 해당 URL을 사용하여 수행되어야 합니다. 링크 편집 기능이 있는 클라이언트는 가능한 경우 요청-URI에 대한 참조를 서버에서 반환된 새 참조에 자동으로 다시 연결해야 합니다.

새 URL은 응답의 위치 필드에 제공되어야 합니다. HEAD 요청이 아닌 이상 응답의 Entity-Body에는 새 URL에 대한 하이퍼링크가 포함된 짧은 메모가 포함되어야 합니다.

POST 메서드를 사용하는 요청에 대한 응답으로 301 상태 코드가 수신되면 사용자 에이전트는 사용자가 확인할 수 없는 한 요청을 자동으로 리디렉션해서는 안 됩니다. 이로 인해 요청이 발행된 조건이 변경될 수 있기 때문입니다.

- 참고: 301 상태 코드를 수신한 후 자동으로 POST 요청을 리디렉션할 때 일부 기존 사용자 에이전트는 이를 GET 요청으로 잘못 변경합니다.

```text
   302 Moved Temporarily
```

요청된 리소스는 일시적으로 다른 URL에 있습니다. 때때로 리디렉션이 변경될 수 있으므로 클라이언트는 향후 요청에 대해 계속해서 Request-URI를 사용해야 합니다.

URL은 응답의 위치 필드에 제공되어야 합니다. HEAD 요청이 아닌 한, 응답의 Entity-Body에는 새 URI에 대한 하이퍼링크가 포함된 짧은 메모가 포함되어야 합니다.

POST 메서드를 사용하는 요청에 대한 응답으로 302 상태 코드가 수신되면 사용자 에이전트는 사용자가 확인할 수 없는 한 요청을 자동으로 리디렉션해서는 안 됩니다. 이로 인해 요청이 발행된 조건이 변경될 수 있기 때문입니다.

- 참고: 302 상태 코드를 수신한 후 자동으로 POST 요청을 리디렉션할 때 일부 기존 사용자 에이전트는 이를 GET 요청으로 잘못 변경합니다.

```text
   304 Not Modified
```

클라이언트가 조건부 GET 요청을 수행하고 액세스가 허용되었지만 If-Modified-Since 필드에 지정된 날짜 및 시간 이후 문서가 수정되지 않은 경우 서버는 이 상태 코드로 응답해야 하며 Entity-를 보내지 않아야 합니다. 클라이언트에게 신체. 응답에 포함된 헤더 필드에는 캐시 관리자와 관련되거나 엔터티의 마지막 수정 날짜와 관계없이 변경되었을 수 있는 정보만 포함되어야 합니다. 관련 헤더 필드의 예로는 날짜, 서버 및 만료가 있습니다. 캐시는 304 응답에 제공된 새로운 필드 값을 반영하도록 캐시된 엔터티를 업데이트해야 합니다.

---
## **9.4  Client Error 4xx**

4xx 클래스의 상태 코드는 클라이언트가 오류를 범한 것으로 보이는 경우를 위한 것입니다. 4xx 코드를 받았을 때 클라이언트가 요청을 완료하지 않은 경우 서버로의 데이터 전송을 즉시 중단해야 합니다. HEAD 요청에 응답할 때를 제외하고 서버는 오류 상황에 대한 설명과 그것이 일시적인지 영구적인지 여부를 포함하는 엔터티를 포함해야 합니다. 이러한 상태 코드는 모든 요청 방법에 적용 가능합니다.

- 참고: 클라이언트가 데이터를 보내는 경우 TCP의 서버 구현은 입력 연결을 닫기 전에 클라이언트가 응답이 포함된 패킷의 수신을 확인하도록 주의해야 합니다. 클라이언트가 닫힌 후에도 계속해서 서버에 데이터를 보내는 경우 서버의 컨트롤러는 클라이언트에 재설정 패킷을 보내며, 이로 인해 클라이언트의 확인되지 않은 입력 버퍼가 HTTP 애플리케이션에서 읽고 해석되기 전에 지워질 수 있습니다.

```text
   400 Bad Request
```

잘못된 구문으로 인해 서버에서 요청을 이해할 수 없습니다. 클라이언트는 수정 없이 요청을 반복해서는 안 됩니다.

```text
   401 Unauthorized
```

요청에는 사용자 인증이 필요합니다. 응답에는 요청된 리소스에 적용 가능한 챌린지를 포함하는 WWW-Authenticate 헤더 필드\(섹션 10.16\)가 포함되어야 합니다. 클라이언트는 적절한 Authorization 헤더 필드\(섹션 10.2\)를 사용하여 요청을 반복할 수 있습니다. 요청에 이미 인증 자격 증명이 포함된 경우 401 응답은 해당 자격 증명에 대한 인증이 거부되었음을 나타냅니다. 401 응답에 이전 응답과 동일한 챌린지가 포함되어 있고 사용자 에이전트가 이미 한 번 이상 인증을 시도한 경우 응답에 제공된 엔터티가 관련 진단 정보를 포함할 수 있으므로 사용자에게 해당 엔터티가 표시되어야 합니다. HTTP 액세스 인증은 섹션 11에 설명되어 있습니다.

```text
   403 Forbidden
```

서버가 요청을 이해했지만 이행을 거부하고 있습니다. 승인은 도움이 되지 않으며 요청을 반복해서는 안 됩니다. 요청 방법이 HEAD가 아니고 서버가 요청이 이행되지 않은 이유를 공개하려는 경우 엔터티 본문에 거부 이유를 설명해야 합니다. 이 상태 코드는 서버가 요청이 거부된 정확한 이유를 밝히고 싶지 않거나 적용할 수 있는 다른 응답이 없을 때 일반적으로 사용됩니다.

```text
   404 Not Found
```

서버가 Request-URI와 일치하는 항목을 찾지 못했습니다. 상태가 일시적인지 영구적인지에 대한 표시는 없습니다. 서버가 이 정보를 클라이언트에 제공하지 않으려면 상태 코드 403\(금지됨\)을 대신 사용할 수 있습니다.

---
## **9.5  Server Error 5xx**

숫자 "5"로 시작하는 응답 상태 코드는 서버가 오류가 발생했거나 요청을 수행할 수 없음을 인식하는 경우를 나타냅니다. 5xx 코드가 수신되었을 때 클라이언트가 요청을 완료하지 않은 경우 서버로의 데이터 전송을 즉시 중단해야 합니다. HEAD 요청에 응답할 때를 제외하고 서버는 오류 상황에 대한 설명과 그것이 일시적인지 영구적인지 여부를 포함하는 엔터티를 포함해야 합니다. 이러한 응답 코드는 모든 요청 방법에 적용 가능하며 필수 헤더 필드가 없습니다.

```text
   500 Internal Server Error
```

서버에서 요청을 이행할 수 없는 예상치 못한 상황이 발생했습니다.

```text
   501 Not Implemented
```

서버가 요청을 이행하는 데 필요한 기능을 지원하지 않습니다. 이는 서버가 요청 방법을 인식하지 못하고 어떤 리소스에도 이를 지원할 수 없는 경우에 적합한 응답입니다.

```text
   502 Bad Gateway
```

서버가 게이트웨이 또는 프록시 역할을 하는 동안 요청을 이행하려고 시도하는 동안 액세스한 업스트림 서버로부터 잘못된 응답을 받았습니다.

```text
   503 Service Unavailable
```

일시적인 과부하 또는 서버 점검으로 인해 현재 서버에서 요청을 처리할 수 없습니다. 이는 이것이 일시적인 상태이며 약간의 시간이 지나면 완화될 것이라는 의미입니다.

- 참고: 503 상태 코드가 존재한다고 해서 서버가 과부하 상태일 때 이를 사용해야 한다는 의미는 아닙니다. 일부 서버에서는 단순히 연결을 거부할 수도 있습니다.

---
## **10.  Header Field Definitions**

이 섹션에서는 일반적으로 사용되는 모든 HTTP/1.0 헤더 필드의 구문과 의미를 정의합니다. 일반 및 엔터티 헤더 필드의 경우 보낸 사람과 받는 사람 모두 메시지를 보내는 사람과 받는 사람에 따라 클라이언트나 서버를 참조합니다.

---
## **10.1  Allow**

허용 엔터티 헤더 필드에는 요청-URI로 식별된 리소스가 지원하는 메서드 집합이 나열됩니다. 이 필드의 목적은 엄격하게 리소스와 관련된 유효한 방법을 수신자에게 알리는 것입니다. Allow 헤더 필드는 POST 메서드를 사용하는 요청에서 허용되지 않으므로 POST 엔터티의 일부로 수신된 경우 무시되어야 합니다.

```text
       Allow          = "Allow" ":" 1#method
```

사용 예:

```text
       Allow: GET, HEAD
```

이 필드는 클라이언트가 다른 방법을 시도하는 것을 막을 수 없습니다. 그러나 허용 헤더 필드 값이 제공하는 표시를 따라야 합니다. 허용되는 실제 메소드 세트는 각 요청 시 원본 서버에 의해 정의됩니다.

프록시는 지정된 모든 방법을 이해하지 못하더라도 Allow 헤더 필드를 수정해서는 안 됩니다. 사용자 에이전트가 원본 서버와 통신하는 다른 수단을 가질 수 있기 때문입니다.

Allow 헤더 필드는 서버가 어떤 메소드를 구현하는지 나타내지 않습니다.

---
## **10.2  Authorization**

서버에 자신을 인증하려는 사용자 에이전트는 일반적으로 401 응답을 받은 후 반드시 그런 것은 아니지만 요청에 Authorization 요청 헤더 필드를 포함시켜 인증할 수 있습니다. Authorization 필드 값은 요청 중인 리소스 영역에 대한 사용자 에이전트의 인증 정보가 포함된 자격 증명으로 구성됩니다.

```text
       Authorization  = "Authorization" ":" credentials
```

HTTP 액세스 인증은 섹션 11에 설명되어 있습니다. 요청이 인증되고 영역이 지정된 경우 이 영역 내의 다른 모든 요청에 ​​대해 동일한 자격 증명이 유효해야 합니다.

Authorization 필드가 포함된 요청에 대한 응답은 캐시할 수 없습니다.

---
## **10.3  Content-Encoding**

Content-Encoding 엔터티 헤더 필드는 미디어 유형에 대한 수정자로 사용됩니다. 존재하는 경우 해당 값은 리소스에 어떤 추가 콘텐츠 코딩이 적용되었는지, 따라서 Content-Type 헤더 필드에서 참조하는 미디어 유형을 얻기 위해 어떤 디코딩 메커니즘을 적용해야 하는지를 나타냅니다. Content-Encoding은 기본 미디어 유형의 ID를 잃지 않고 문서를 압축할 수 있도록 하는 데 주로 사용됩니다.

```text
       Content-Encoding = "Content-Encoding" ":" content-coding
```

콘텐츠 코딩은 섹션 3.5에 정의되어 있습니다. 그 사용 예는 다음과 같습니다.

```text
       Content-Encoding: x-gzip
```

Content-Encoding은 Request-URI로 식별되는 리소스의 특성입니다. 일반적으로 리소스는 이 인코딩으로 저장되며 렌더링 또는 유사한 사용 전에만 디코딩됩니다.

---
## **10.4  Content-Length**

Content-Length Entity-Header 필드는 수신자에게 전송된 Entity-Body의 크기를 십진수 옥텟으로 표시하거나, HEAD 메소드의 경우 전송되었을 Entity-Body의 크기를 나타냅니다. 요청은 GET이었습니다.

```text
       Content-Length = "Content-Length" ":" 1*DIGIT
```

예는 다음과 같습니다

```text
       Content-Length: 3495
```

애플리케이션은 이 필드를 사용하여 엔터티의 미디어 유형에 관계없이 전송할 Entity-Body의 크기를 나타내야 합니다. 엔터티 본문이 포함된 모든 HTTP/1.0 요청 메시지에는 유효한 Content-Length 필드 값이 필요합니다.

0보다 크거나 같은 모든 Content-Length는 유효한 값입니다. 7.2.2절에서는 Content-Length가 제공되지 않은 경우 응답 엔터티 본문의 길이를 결정하는 방법을 설명합니다.

- 참고: 이 필드의 의미는 "message/external-body" 콘텐츠 유형 내에서 사용되는 선택적 필드인 MIME의 해당 정의와 크게 다릅니다. HTTP에서는 엔터티의 길이가 전송되기 전에 결정될 수 있을 때마다 사용해야 합니다.

---
## **10.5  Content-Type**

Content-Type Entity-Header 필드는 수신자에게 전송된 Entity-Body의 미디어 유형을 나타냅니다. 또는 HEAD 메소드의 경우 요청이 GET이었다면 전송되었을 미디어 유형을 나타냅니다.

```text
       Content-Type   = "Content-Type" ":" media-type
```

미디어 유형은 섹션 3.6에 정의되어 있습니다. 해당 분야의 예는 다음과 같습니다.

```text
       Content-Type: text/html
```

엔터티의 미디어 유형을 식별하는 방법에 대한 추가 논의는 섹션 7.2.1에 제공됩니다.

---
## **10.6  Date**

Date 일반 헤더 필드는 메시지가 시작된 날짜와 시간을 나타내며 RFC 822의 orig-date와 동일한 의미를 갖습니다. 필드 값은 섹션 3.3에 설명된 대로 HTTP 날짜입니다.

```text
       Date           = "Date" ":" HTTP-date
```

예는 다음과 같습니다

```text
       Date: Tue, 15 Nov 1994 08:12:31 GMT
```

사용자 에이전트\(요청의 경우\) 또는 원본 서버\(응답의 경우\)와의 직접 연결을 통해 메시지가 수신된 경우 날짜는 수신 측의 현재 날짜로 가정할 수 있습니다. 그러나 원본에서 믿는 날짜는 캐시된 응답을 평가하는 데 중요하므로 원본 서버는 항상 Date 헤더를 포함해야 합니다. 클라이언트는 POST 요청의 경우처럼 엔터티 본문을 포함하는 메시지에 날짜 헤더 필드만 보내야 하며, 이 경우에도 선택 사항입니다. 날짜 헤더 필드가 없는 수신 메시지는 메시지가 수신자에 의해 캐시되거나 날짜가 필요한 프로토콜을 통해 게이트웨이되는 경우 수신자에 의해 할당되어야 합니다.

이론적으로 날짜는 엔터티가 생성되기 직전의 순간을 나타내야 합니다. 실제로 날짜는 의미 값에 영향을 주지 않고 메시지가 생성되는 동안 언제든지 생성될 수 있습니다.

- 참고: 이 문서의 이전 버전에서는 이 필드에 포함된 Entity-Body의 생성 날짜가 포함되어야 한다고 잘못 지정했습니다. 이는 실제\(그리고 적절한\)를 반영하도록 변경되었습니다.

```text
      usage.
```

---
## **10.7  Expires**

Expires 엔터티 헤더 필드는 엔터티가 오래된 것으로 간주되어야 하는 날짜/시간을 제공합니다. 이를 통해 정보 제공자는 리소스의 변동성 또는 정보가 더 이상 유효하지 않을 수 있는 날짜를 제안할 수 있습니다. 애플리케이션은 지정된 날짜 이후에 이 엔터티를 캐시하면 안 됩니다. Expires 필드가 있다고 해서 원래 리소스가 해당 시점, 이전 또는 이후에 변경되거나 존재하지 않게 된다는 의미는 아닙니다. 그러나 리소스가 특정 날짜까지 변경될 것이라고 알고 있거나 심지어 의심하는 정보 제공자는 해당 날짜가 포함된 Expires 헤더를 포함해야 합니다. 형식은 섹션 3.3의 HTTP-date에 정의된 절대 날짜 및 시간입니다.

```text
       Expires        = "Expires" ":" HTTP-date
```

그 사용 예는 다음과 같습니다.

```text
       Expires: Thu, 01 Dec 1994 16:00:00 GMT
```

제공된 날짜가 Date 헤더 값과 같거나 이전인 경우 수신자는 포함된 엔터티를 캐시하면 안 됩니다. 많은 데이터 생성 프로세스의 경우처럼 리소스가 본질적으로 동적이라면 해당 리소스의 엔터티에는 해당 역동성을 반영하는 적절한 Expires 값이 제공되어야 합니다.

Expires 필드는 사용자 에이전트가 디스플레이를 새로 고치거나 리소스를 다시 로드하도록 강제하는 데 사용할 수 없습니다. 그 의미는 캐싱 메커니즘에만 적용되며 이러한 메커니즘은 해당 리소스에 대한 새 요청이 시작될 때 리소스의 만료 상태만 확인하면 됩니다.

사용자 에이전트에는 세션에서 이전에 검색된 엔터티를 다시 표시하는 데 사용할 수 있는 "뒤로" 버튼 및 기록 목록과 같은 기록 메커니즘이 있는 경우가 많습니다. 기본적으로 만료 필드는 기록 메커니즘에 적용되지 않습니다. 엔터티가 아직 저장되어 있는 경우 사용자가 만료된 기록 문서를 새로 고치도록 에이전트를 특별히 구성하지 않은 한 엔터티가 만료된 경우에도 기록 메커니즘에 이를 표시해야 합니다.

- 참고: 응용 프로그램은 Expires 헤더의 잘못된 구현이나 잘못된 정보를 허용하는 것이 좋습니다. 값이 0이거나 유효하지 않은 날짜 형식은 "즉시 만료"와 동일한 것으로 간주되어야 합니다. 이러한 값은 HTTP/1.0에 적합하지 않지만 강력한 구현은 항상 바람직합니다.

---
## **10.8  From**

From 요청 헤더 필드는 요청하는 사용자 에이전트를 제어하는 ​​인간 사용자의 인터넷 이메일 주소를 포함해야 합니다. 주소는 RFC 822 \[7\]의 메일박스에 정의된 대로\(RFC 1123 \[6\]에 의해 업데이트됨\) 컴퓨터에서 사용할 수 있어야 합니다.

```text
       From           = "From" ":" mailbox
```

예는 다음과 같습니다:

```text
       From: webmaster@w3.org
```

이 헤더 필드는 로깅 목적으로 그리고 유효하지 않거나 원치 않는 요청의 소스를 식별하는 수단으로 사용될 수 있습니다. 안전하지 않은 형태의 액세스 보호로 사용해서는 안 됩니다. 이 필드의 해석은 수행된 방법에 대한 책임을 수락하는 지정된 사람을 대신하여 요청이 수행된다는 것입니다. 특히, 로봇 에이전트는 수신 측에서 문제가 발생할 경우 로봇을 실행하는 담당자에게 연락할 수 있도록 이 헤더를 포함해야 합니다.

이 필드의 인터넷 이메일 주소는 요청을 발행한 인터넷 호스트와 별개일 수 있습니다. 예를 들어 요청이 프록시를 통해 전달되는 경우 원래 발급자의 주소를 사용해야 합니다.

- 참고: 클라이언트는 사용자의 승인 없이 From 헤더 필드를 보내서는 안 됩니다. 이는 사용자의 개인 정보 보호 이익이나 해당 사이트의 보안 정책과 충돌할 수 있기 때문입니다. 사용자는 요청하기 전에 언제든지 이 필드의 값을 비활성화, 활성화 및 수정할 수 있는 것이 좋습니다.

---
## **10.9  If-Modified-Since**

If-Modified-Since 요청 헤더 필드는 조건부로 만들기 위해 GET 메소드와 함께 사용됩니다. 요청된 리소스가 이 필드에 지정된 시간 이후 수정되지 않은 경우 리소스 복사본이 서버에서 반환되지 않습니다. 대신 Entity-Body 없이 304\(수정되지 않음\) 응답이 반환됩니다.

```text
       If-Modified-Since = "If-Modified-Since" ":" HTTP-date
```

필드의 예는 다음과 같습니다.

```text
       If-Modified-Since: Sat, 29 Oct 1994 19:43:31 GMT
```

조건부 GET 방법은 식별된 리소스가 If-Modified-Since 헤더에 지정된 날짜 이후 수정된 경우에만 전송되도록 요청합니다. 이를 결정하는 알고리즘에는 다음과 같은 경우가 포함됩니다.

- a\) 요청이 일반적으로 200\(ok\) 상태 이외의 결과를 초래하거나 전달된 If-Modified-Since 날짜가 유효하지 않은 경우 응답은 일반 GET의 경우와 정확히 동일합니다. 서버의 현재 시간보다 이후의 날짜는 유효하지 않습니다.

- b\) If-Modified-Since 날짜 이후 리소스가 수정된 경우 응답은 일반 GET의 경우와 정확히 동일합니다.

- c\) 유효한 If-Modified-Since 날짜 이후 리소스가 수정되지 않은 경우 서버는 304\(수정되지 않음\) 응답을 반환해야 합니다.

이 기능의 목적은 최소한의 트랜잭션 오버헤드로 캐시된 정보를 효율적으로 업데이트할 수 있도록 하는 것입니다.

---
## **10.10  Last-Modified**

Last-Modified 엔터티 헤더 필드는 보낸 사람이 리소스가 마지막으로 수정되었다고 믿는 날짜와 시간을 나타냅니다. 이 필드의 정확한 의미는 수신자가 이를 어떻게 해석해야 하는지에 따라 정의됩니다. 수신자가 Last-Modified 필드에 지정된 날짜보다 오래된 이 리소스의 복사본을 가지고 있는 경우 해당 복사본은 오래된 것으로 간주되어야 합니다.

```text
       Last-Modified  = "Last-Modified" ":" HTTP-date
```

그 사용 예는 다음과 같습니다.

```text
       Last-Modified: Tue, 15 Nov 1994 12:45:26 GMT
```

이 헤더 필드의 정확한 의미는 보낸 사람의 구현과 원본 리소스의 성격에 따라 다릅니다. 파일의 경우 파일 시스템이 마지막으로 수정된 시간일 수 있습니다. 동적으로 포함된 부분이 있는 엔터티의 경우 구성 요소 부분의 마지막 수정 시간 집합 중 가장 최근일 수 있습니다. 데이터베이스 게이트웨이의 경우 레코드의 마지막 업데이트 타임스탬프일 수 있습니다. 가상 개체의 경우 내부 상태가 마지막으로 변경된 시간일 수 있습니다.

원본 서버는 서버의 메시지 발생 시간보다 이후의 최종 수정 날짜를 보내서는 안 됩니다. 이러한 경우 리소스의 마지막 수정은 해당 리소스의 특정 시간을 나타냅니다.

앞으로 서버는 해당 날짜를 메시지 발생 날짜로 바꿔야 합니다.

---
## **10.11  Location**

Location 응답 헤더 필드는 Request-URI에 의해 식별된 리소스의 정확한 위치를 정의합니다. 3xx 응답의 경우 위치는 리소스로의 자동 리디렉션을 위한 서버의 기본 URL을 나타내야 합니다. 절대 URL은 하나만 허용됩니다.

```text
       Location       = "Location" ":" absoluteURI
```

예는 다음과 같습니다

```text
       Location: http://www.w3.org/hypertext/WWW/NewLocation.html
```

---
## **10.12  Pragma**

Pragma 일반 헤더 필드는 요청/응답 체인을 따라 모든 수신자에게 적용될 수 있는 구현별 지시문을 포함하는 데 사용됩니다. 모든 pragma 지시문은 프로토콜의 관점에서 선택적 동작을 지정합니다. 그러나 일부 시스템에서는 동작이 지시문과 일치하도록 요구할 수 있습니다.

```text
       Pragma           = "Pragma" ":" 1#pragma-directive

       pragma-directive = "no-cache" | extension-pragma
       extension-pragma = token [ "=" word ]
```

요청 메시지에 "no-cache" 지시문이 있으면 애플리케이션은 요청 내용의 캐시된 복사본이 있더라도 요청을 원본 서버로 전달해야 합니다. 이를 통해 클라이언트는 요청에 대한 권위 있는 응답을 받아야 한다고 주장할 수 있습니다. 또한 클라이언트는 손상되었거나 오래된 것으로 알려진 캐시된 복사본을 새로 고칠 수 있습니다.

Pragma 지시문은 요청/응답 체인을 따라 모든 수신자에게 적용될 수 있으므로 해당 애플리케이션에 대한 중요성에 관계없이 프록시 또는 게이트웨이 애플리케이션을 통해 전달되어야 합니다. 특정 수신자에 대해 pragma를 지정하는 것은 불가능합니다. 그러나 수신자와 관련되지 않은 pragma 지시문은 해당 수신자에 의해 무시되어야 합니다.

---
## **10.13  Referer**

Referer 요청 헤더 필드를 사용하면 클라이언트는 서버의 이익을 위해 요청 URI를 얻은 리소스의 주소\(URI\)를 지정할 수 있습니다. 이를 통해 서버는 목록을 생성할 수 있습니다.

관심 있는 리소스, 로깅, 최적화된 캐싱 등을 위한 백링크. 또한 유지 관리를 위해 오래되었거나 잘못 입력된 링크를 추적할 수 있습니다. 사용자 키보드의 입력과 같이 자체 URI가 없는 소스에서 Request-URI를 얻은 경우 Referer 필드를 보내서는 안 됩니다.

```text
       Referer        = "Referer" ":" ( absoluteURI | relativeURI )

   Example:

       Referer: http://www.w3.org/hypertext/DataSources/Overview.html
```

부분 URI가 제공되면 요청-URI를 기준으로 해석되어야 합니다. URI에는 조각이 포함되어서는 안 됩니다.

- 참고: 링크의 소스는 개인 정보이거나 개인 정보 소스를 노출할 수 있으므로 추천자 필드 전송 여부를 사용자가 선택할 수 있도록 하는 것이 좋습니다. 예를 들어, 브라우저 클라이언트에는 공개/익명 탐색을 위한 토글 스위치가 있을 수 있으며, 이를 통해 추천자 및 보낸 사람 정보 전송을 각각 활성화/비활성화할 수 있습니다.

---
## **10.14  Server**

서버 응답 헤더 필드에는 원본 서버가 요청을 처리하는 데 사용하는 소프트웨어에 대한 정보가 포함됩니다. 필드에는 여러 제품 토큰\(섹션 3.7\)과 서버 및 중요한 하위 제품을 식별하는 설명이 포함될 수 있습니다. 일반적으로 제품 토큰은 응용 프로그램을 식별하는 데 중요한 순서대로 나열됩니다.

```text
       Server         = "Server" ":" 1*( product | comment )

   Example:

       Server: CERN/3.0 libwww/2.17
```

응답이 프록시를 통해 전달되는 경우 프록시 애플리케이션은 해당 데이터를 제품 목록에 추가하면 안 됩니다.

- 참고: 서버의 특정 소프트웨어 버전을 공개하면 서버 시스템이 보안 허점이 있는 것으로 알려진 소프트웨어에 대한 공격에 더욱 취약해질 수 있습니다. 서버 구현자는 이 필드를 구성 가능한 옵션으로 만드는 것이 좋습니다.

- 참고: 일부 기존 서버는 서버 필드 내의 제품 토큰 구문으로 자신을 제한하지 못합니다.

---
## **10.15  User-Agent**

User-Agent 요청 헤더 필드에는 요청을 보낸 사용자 에이전트에 대한 정보가 포함되어 있습니다. 이는 통계 목적, 프로토콜 위반 추적 및 특정 사용자 에이전트 제한을 피하기 위한 응답 맞춤화를 위한 사용자 에이전트 자동 인식을 위한 것입니다. 필수는 아니지만 사용자 에이전트는 요청에 이 필드를 포함해야 합니다. 필드에는 여러 제품 토큰\(섹션 3.7\)과 사용자 에이전트의 중요한 부분을 구성하는 에이전트 및 하위 제품을 식별하는 주석이 포함될 수 있습니다. 일반적으로 제품 토큰은 응용 프로그램을 식별하는 데 중요한 순서대로 나열됩니다.

```text
       User-Agent     = "User-Agent" ":" 1*( product | comment )

   Example:

       User-Agent: CERN-LineMode/2.15 libwww/2.17b3
```

- 참고: 현재 일부 프록시 응용 프로그램은 사용자 에이전트 필드의 목록에 제품 정보를 추가합니다. 이는 이러한 필드의 기계 해석을 모호하게 만들기 때문에 권장되지 않습니다.

- 참고: 일부 기존 클라이언트는 User-Agent 필드 내의 제품 토큰 구문으로 자신을 제한하지 못합니다.

---
## **10.16  WWW-Authenticate**

WWW-Authenticate 응답 헤더 필드는 401\(인증되지 않은\) 응답 메시지에 포함되어야 합니다. 필드 값은 요청-URI에 적용 가능한 인증 체계와 매개변수를 나타내는 하나 이상의 챌린지로 구성됩니다.

```text
       WWW-Authenticate = "WWW-Authenticate" ":" 1#challenge
```

HTTP 액세스 인증 프로세스는 섹션 11에 설명되어 있습니다. 사용자 에이전트는 하나 이상의 챌린지를 포함하거나 하나 이상의 WWW-Authenticate 헤더 필드가 제공되는 경우 WWW-Authenticate 필드 값을 구문 분석할 때 특별한 주의를 기울여야 합니다. 챌린지 자체에는 쉼표로 구분된 인증 매개변수 목록이 포함될 수 있습니다.

---
## **11.  Access Authentication**

HTTP는 서버가 클라이언트 요청에 도전하고 클라이언트가 인증 정보를 제공하는 데 사용할 수 있는 간단한 도전-응답 인증 메커니즘을 제공합니다. 확장 가능하고 대소문자를 구분하지 않는 토큰을 사용하여 인증 체계를 식별한 다음 해당 체계를 통해 인증을 달성하는 데 필요한 매개변수를 전달하는 쉼표로 구분된 속성-값 쌍 목록을 사용합니다.

```text
       auth-scheme    = token

       auth-param     = token "=" quoted-string
```

401\(인증되지 않음\) 응답 메시지는 원본 서버에서 사용자 에이전트의 인증을 요청하는 데 사용됩니다. 이 응답에는 요청된 리소스에 적용할 수 있는 챌린지가 하나 이상 포함된 WWW-Authenticate 헤더 필드가 포함되어야 합니다.

```text
       challenge      = auth-scheme 1*SP realm *( "," auth-param )

       realm          = "realm" "=" realm-value
       realm-value    = quoted-string
```

챌린지를 발행하는 모든 인증 체계에는 영역 속성\(대소문자 구분\)이 필요합니다. 영역 값\(대소문자 구분\)은 액세스 중인 서버의 표준 루트 URL과 함께 보호 공간을 정의합니다. 이러한 영역을 사용하면 서버의 보호된 리소스를 각각 고유한 인증 체계 및/또는 권한 부여 데이터베이스가 있는 보호 공간 집합으로 분할할 수 있습니다. 영역 값은 일반적으로 원본 서버에 의해 할당되는 문자열이며, 인증 체계에 특정한 추가 의미를 가질 수 있습니다.

서버에 자신을 인증하려는 사용자 에이전트는 일반적으로 401 응답을 받은 후 반드시 그런 것은 아니지만 요청에 Authorization 헤더 필드를 포함하여 인증할 수 있습니다. Authorization 필드 값은 요청 중인 리소스 영역에 대한 사용자 에이전트의 인증 정보가 포함된 자격 증명으로 구성됩니다.

```text
       credentials    = basic-credentials
                      | ( auth-scheme #auth-param )
```

사용자 에이전트가 자격 증명을 자동으로 적용할 수 있는 도메인은 보호 공간에 따라 결정됩니다. 이전 요청이 승인된 경우, 결정된 기간 동안 해당 보호 공간 내에서 다른 모든 요청에 ​​대해 동일한 자격 증명을 재사용할 수 있습니다.

인증 체계, 매개변수 및/또는 사용자 기본 설정에 따라 결정됩니다. 인증 체계에서 달리 정의하지 않는 한 단일 보호 공간은 해당 서버 범위 외부로 확장될 수 없습니다.

서버가 요청과 함께 전송된 자격 증명을 수락하지 않으려면 403\(금지됨\) 응답을 반환해야 합니다.

HTTP 프로토콜은 액세스 인증을 위한 이 간단한 시도-응답 메커니즘으로 애플리케이션을 제한하지 않습니다. 전송 수준의 암호화 또는 메시지 캡슐화를 통한 암호화와 인증 정보를 지정하는 추가 헤더 필드와 같은 추가 메커니즘이 사용될 수 있습니다. 그러나 이러한 추가 메커니즘은 이 사양에서 정의되지 않습니다.

프록시는 사용자 에이전트 인증과 관련하여 완전히 투명해야 합니다. 즉, WWW-Authenticate 및 Authorization 헤더를 그대로 전달해야 하며 Authorization이 포함된 요청에 대한 응답을 캐시해서는 안 됩니다. HTTP/1.0은 클라이언트가 프록시를 통해 인증되는 수단을 제공하지 않습니다.

---
## **11.1  Basic Authentication Scheme**

"기본" 인증 체계는 사용자 에이전트가 각 영역에 대한 사용자 ID와 비밀번호를 사용하여 자신을 인증해야 하는 모델을 기반으로 합니다. 영역 값은 해당 서버의 다른 영역과 동일한지 비교만 가능한 불투명 문자열로 간주되어야 합니다. 서버는 Request-URI의 보호 공간에 대한 사용자 ID와 비밀번호를 확인할 수 있는 경우에만 요청을 승인합니다. 선택적 인증 매개변수가 없습니다.

보호 공간 내에서 URI에 대한 무단 요청을 받으면 서버는 다음과 같은 질문으로 응답해야 합니다.

```text
       WWW-Authenticate: Basic realm="WallyWorld"
```

여기서 "WallyWorld"는 Request-URI의 보호 공간을 식별하기 위해 서버에서 할당한 문자열입니다.

인증을 받기 위해 클라이언트는 자격 증명의 base64 \[5\] 인코딩 문자열 내에서 단일 콜론\(":"\) 문자로 구분된 사용자 ID와 비밀번호를 보냅니다.

```text
       basic-credentials = "Basic" SP basic-cookie

       basic-cookie      = <base64 [5] encoding of userid-password,
                            except not limited to 76 char/line>

       userid-password   = [ token ] ":" *TEXT
```

사용자 에이전트가 사용자 ID "Aladdin"과 비밀번호 "open sesame"을 보내려는 경우 다음 헤더 필드를 사용합니다.

```text
       Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==
```

기본 인증 체계는 HTTP 서버의 리소스에 대한 무단 액세스를 필터링하는 비보안 방법입니다. 이는 클라이언트와 서버 간의 연결을 신뢰할 수 있는 캐리어로 간주할 수 있다는 가정에 기반합니다. 이는 개방형 네트워크에서는 일반적으로 사실이 아니므로 그에 따라 기본 인증 체계를 사용해야 합니다. 그럼에도 불구하고 클라이언트는 이를 사용하는 서버와 통신하기 위해 이 체계를 구현해야 합니다.

---
## **12.  Security Considerations**

이 섹션은 이 문서에 설명된 대로 HTTP/1.0의 보안 제한 사항을 응용 프로그램 개발자, 정보 제공자 및 사용자에게 알리기 위한 것입니다. 토론에는 드러난 문제에 대한 최종적인 해결책이 포함되어 있지 않지만 보안 위험을 줄이기 위한 몇 가지 제안은 포함되어 있습니다.

---
## **12.1  Authentication of Clients**

섹션 11.1에서 언급했듯이 기본 인증 방식은 안전한 사용자 인증 방법이 아니며 Entity-Body가 반송파로 사용되는 물리적 네트워크를 통해 일반 텍스트로 전송되는 것을 방지하지도 않습니다. HTTP/1.0은 보안을 강화하기 위해 추가 인증 체계와 암호화 메커니즘을 사용하는 것을 방지하지 않습니다.

---
## **12.2  Safe Methods**

클라이언트 소프트웨어 작성자는 소프트웨어가 인터넷을 통한 상호 작용에서 사용자를 대표한다는 점을 인식해야 하며, 자신이나 다른 사람에게 예상치 못한 의미를 가질 수 있는 자신이 취할 수 있는 모든 작업을 사용자가 인식할 수 있도록 주의해야 합니다.

특히, GET 및 HEAD 메소드는 검색 이외의 조치를 취하는 의미를 가져서는 안 된다는 규칙이 확립되었습니다. 이러한 방법은 "안전한" 것으로 간주되어야 합니다. 이를 통해 사용자 에이전트는 POST와 같은 다른 메서드를 특별한 방식으로 나타낼 수 있으므로 사용자는 안전하지 않을 수 있는 작업이 요청되고 있다는 사실을 알 수 있습니다.

당연히 서버가 GET 요청 수행의 결과로 부작용을 생성하지 않는다는 것을 보장하는 것은 불가능합니다. 실제로 일부 동적 리소스에서는 이를 기능으로 간주합니다. 여기서 중요한 차이점은 사용자가 부작용을 요청하지 않았으므로 이에 대해 책임을 질 수 없다는 것입니다.

---
## **12.3  Abuse of Server Log Information**

서버는 사용자의 독서 패턴이나 관심 주제를 식별할 수 있는 사용자 요청에 대한 개인 데이터를 저장할 위치에 있습니다. 이 정보는 본질적으로 명백히 기밀이며 특정 국가에서는 해당 정보의 처리가 법률에 의해 제한될 수 있습니다. 데이터를 제공하기 위해 HTTP 프로토콜을 사용하는 사람들은 게시된 결과로 식별 가능한 개인의 허가 없이 해당 자료가 배포되지 않도록 할 책임이 있습니다.

---
## **12.4  Transfer of Sensitive Information**

일반 데이터 전송 프로토콜과 마찬가지로 HTTP는 전송되는 데이터의 내용을 규제할 수 없으며 특정 요청의 맥락에서 특정 정보 조각의 민감도를 결정하는 선험적 방법도 없습니다. 따라서 애플리케이션은 해당 정보 제공자에게 이 정보에 대해 가능한 한 많은 제어권을 제공해야 합니다. 이 맥락에서 세 가지 헤더 필드, 즉 Server, Referer 및 From을 특별히 언급할 가치가 있습니다.

서버의 특정 소프트웨어 버전을 공개하면 서버 시스템이 보안 허점이 있는 것으로 알려진 소프트웨어에 대한 공격에 더욱 취약해질 수 있습니다. 구현자는 서버 헤더 필드를 구성 가능한 옵션으로 만들어야 합니다.

Referer 필드를 사용하면 읽기 패턴을 연구하고 역방향 링크를 그릴 수 있습니다. 매우 유용할 수 있지만 사용자 세부 정보가 Referer에 포함된 정보와 분리되지 않으면 그 힘이 남용될 수 있습니다. 개인 정보가 제거된 경우에도 추천자 필드에는 게시가 부적절한 개인 문서의 URI가 표시될 수 있습니다.

보낸 사람 필드에 전송된 정보는 사용자의 개인 정보 보호 이익이나 해당 사이트의 보안 정책과 충돌할 수 있으므로 사용자가 필드의 내용을 비활성화, 활성화 및 수정할 수 없는 상태에서는 전송되어서는 안 됩니다. 사용자는 사용자 기본 설정 또는 애플리케이션 기본 구성 내에서 이 필드의 내용을 설정할 수 있어야 합니다.

필수는 아니지만 사용자가 보낸 사람 및 추천자 정보 전송을 활성화하거나 비활성화할 수 있도록 편리한 토글 인터페이스를 제공하는 것이 좋습니다.

---
## **12.5  Attacks Based On File and Path Names**

HTTP 원본 서버 구현에서는 HTTP 요청에 의해 반환되는 문서를 서버 관리자가 의도한 문서로만 제한하도록 주의해야 합니다. HTTP 서버가 HTTP URI를 파일 시스템 호출로 직접 변환하는 경우 서버는 HTTP 클라이언트에 전달하려는 의도가 아닌 파일을 제공하지 않도록 특별한 주의를 기울여야 합니다. 예를 들어 Unix, Microsoft Windows 및 기타 운영 체제에서는 ".."를 경로 구성 요소로 사용하여 현재 디렉터리 수준 위의 디렉터리 수준을 나타냅니다. 이러한 시스템에서 HTTP 서버는 HTTP 서버를 통해 액세스할 수 있도록 의도된 리소스 외부의 리소스에 대한 액세스를 허용하는 경우 Request-URI에서 그러한 구성을 허용하지 않아야 합니다. 마찬가지로, 서버 내부에서만 참조하기 위한 파일\(예: 액세스 제어 파일, 구성 파일, 스크립트 코드\)은 민감한 정보를 포함할 수 있으므로 부적절한 검색으로부터 보호해야 합니다. 경험에 따르면 이러한 HTTP 서버 구현의 사소한 버그가 보안 위험으로 바뀌는 것으로 나타났습니다.

---
## **13.  Acknowledgments**

이 사양에서는 David H. Crocker가 RFC 822\[7\]에 대해 정의한 확장된 BNF 및 일반 구성을 많이 사용합니다. 마찬가지로 Nathaniel Borenstein과 Ned Freed가 MIME에 대해 제공한 많은 정의를 재사용합니다\[5\]. 우리는 이 사양에 이를 포함시키면 HTTP/1.0과 인터넷 메일 메시지 형식 간의 관계에 대한 과거의 혼란을 줄이는 데 도움이 되기를 바랍니다.

HTTP 프로토콜은 지난 4년 동안 상당히 발전했습니다. 이는 www-talk 메일링 리스트에 참여한 많은 사람들과 같은 크고 활동적인 개발자 커뮤니티의 혜택을 받았으며, HTTP와 World-Wide Web의 성공에 가장 큰 책임을 맡은 커뮤니티입니다. 일반적인. Marc Andreessen, Robert Cailliau, Daniel W. Connolly, Bob Denny, Jean-Francois Groff, Phillip M. Hallam-Baker, Hakon W. Lie, Ari Luotonen, Rob McCool, Lou Montulli, Dave Raggett, Tony Sanders 및 Marc VanHeyningen은 자격이 있습니다. 이 사양의 초기 버전에 대한 프로토콜 측면을 정의하려는 노력에 대해 특별한 감사를 표합니다.

Paul Hoffman은 이 문서와 부록 C 및 D의 정보 상태에 관한 섹션을 제공했습니다.

이 문서는 HTTP-WG에 참여하는 모든 사람들의 의견으로부터 큰 도움을 받았습니다. 이미 언급된 사람들 외에도 다음 개인이 이 사양에 기여했습니다.

```text
       Gary Adams                         Harald Tveit Alvestrand
       Keith Ball                         Brian Behlendorf
       Paul Burchard                      Maurizio Codogno
       Mike Cowlishaw                     Roman Czyborra
       Michael A. Dolan                   John Franks
       Jim Gettys                         Marc Hedlund
       Koen Holtman                       Alex Hopmann
       Bob Jernigan                       Shel Kaphan
       Martijn Koster                     Dave Kristol
       Daniel LaLiberte                   Paul Leach
       Albert Lunde                       John C. Mallery
       Larry Masinter                     Mitra
       Jeffrey Mogul                      Gavin Nicol
       Bill Perry                         Jeffrey Perry
       Owen Rees                          Luigi Rizzo
       David Robinson                     Marc Salomon
       Rich Salz                          Jim Seidman
       Chuck Shotton                      Eric W. Sink
       Simon E. Spero                     Robert S. Thau
       Francois Yergeau                   Mary Ellen Zurko
       Jean-Philippe Martin-Flatin
```

---
## **14. References**

```text
   [1]  Anklesaria, F., McCahill, M., Lindner, P., Johnson, D.,
        Torrey, D., and B. Alberti, "The Internet Gopher Protocol: A
        Distributed Document Search and Retrieval Protocol", RFC 1436,
        University of Minnesota, March 1993.

   [2]  Berners-Lee, T., "Universal Resource Identifiers in WWW: A
        Unifying Syntax for the Expression of Names and Addresses of
        Objects on the Network as used in the World-Wide Web",
        RFC 1630, CERN, June 1994.

   [3]  Berners-Lee, T., and D. Connolly, "Hypertext Markup Language -
        2.0", RFC 1866, MIT/W3C, November 1995.

   [4]  Berners-Lee, T., Masinter, L., and M. McCahill, "Uniform
        Resource Locators (URL)", RFC 1738, CERN, Xerox PARC,
        University of Minnesota, December 1994.

   [5]  Borenstein, N., and N. Freed, "MIME (Multipurpose Internet Mail
        Extensions) Part One: Mechanisms for Specifying and Describing
        the Format of Internet Message Bodies", RFC 1521, Bellcore,
        Innosoft, September 1993.

   [6]  Braden, R., "Requirements for Internet hosts - Application and
        Support", STD 3, RFC 1123, IETF, October 1989.

   [7]  Crocker, D., "Standard for the Format of ARPA Internet Text
        Messages", STD 11, RFC 822, UDEL, August 1982.

   [8]  F. Davis, B. Kahle, H. Morris, J. Salem, T. Shen, R. Wang,
        J. Sui, and M. Grinbaum. "WAIS Interface Protocol Prototype
        Functional Specification." (v1.5), Thinking Machines
        Corporation, April 1990.

   [9]  Fielding, R., "Relative Uniform Resource Locators", RFC 1808,
        UC Irvine, June 1995.
```

\[10\] Horton, M. 및 R. Adams, "USENET 교환 표준 - 메시지", RFC 1036\(폐기된 RFC 850\), AT&T Bell Laboratories, Center for Seismic Studies, 1987년 12월.

\[11\] Kantor, B. 및 P. Lapsley, "네트워크 뉴스 전송 프로토콜: - 뉴스의 스트림 기반 전송을 위해 제안된 표준", RFC 977, UC San Diego, UC Berkeley, 1986년 2월.

```text
   [12] Postel, J., "Simple Mail Transfer Protocol." STD 10, RFC 821,
        USC/ISI, August 1982.

   [13] Postel, J., "Media Type Registration Procedure." RFC 1590,
        USC/ISI, March 1994.
```

\[14\] Postel, J. 및 J. Reynolds, "파일 전송 프로토콜\(FTP\)", - STD 9, RFC 959, USC/ISI, 1985년 10월.

\[15\] Reynolds, J. 및 J. Postel, "할당된 번호", STD 2, RFC - 1700, USC/ISI, 1994년 10월.

\[16\] Sollins, K. 및 L. Masinter, "Uniform Resource Names에 대한 기능 요구 사항", RFC 1737, MIT/LCS, Xerox Corporation, 1994년 12월.

\[17\] US-ASCII. 코드화된 문자 세트 - 7비트 미국 표준 코드 - 정보 교환용. 표준 ANSI X3.4-1986, ANSI, 1986.

```text
   [18] ISO-8859. International Standard -- Information Processing --
        8-bit Single-Byte Coded Graphic Character Sets --
        Part 1: Latin alphabet No. 1, ISO 8859-1:1987.
        Part 2: Latin alphabet No. 2, ISO 8859-2, 1987.
        Part 3: Latin alphabet No. 3, ISO 8859-3, 1988.
        Part 4: Latin alphabet No. 4, ISO 8859-4, 1988.
        Part 5: Latin/Cyrillic alphabet, ISO 8859-5, 1988.
        Part 6: Latin/Arabic alphabet, ISO 8859-6, 1987.
        Part 7: Latin/Greek alphabet, ISO 8859-7, 1987.
        Part 8: Latin/Hebrew alphabet, ISO 8859-8, 1988.
        Part 9: Latin alphabet No. 5, ISO 8859-9, 1990.
```

---
## **15.  Authors' Addresses**

Tim Berners-Lee W3 컨소시엄 MIT 컴퓨터 공학 연구소 소장 545 Technology Square Cambridge, MA 02139, U.S.A.

```text
   Fax: +1 (617) 258 8682
   EMail: timbl@w3.org
```

Roy T. Fielding 정보 및 컴퓨터 과학과 University of California Irvine, CA 92717-3425, U.S.A.

```text
   Fax: +1 (714) 824-4056
   EMail: fielding@ics.uci.edu
```

Henrik Frystyk Nielsen W3 컨소시엄 MIT 컴퓨터 공학 연구소 545 Technology Square Cambridge, MA 02139, U.S.A.

```text
   Fax: +1 (617) 258 8682
   EMail: frystyk@w3.org
```

---
# **Appendices**

이 부록은 정보 제공 목적으로만 제공되며 HTTP/1.0 사양의 일부를 구성하지 않습니다.

---
## **A.  Internet Media Type message/http**

HTTP/1.0 프로토콜을 정의하는 것 외에도 이 문서는 인터넷 미디어 유형 "message/http"에 대한 사양 역할을 합니다. 다음은 IANA \[13\]에 등록됩니다.

```text
       Media Type name:         message

       Media subtype name:      http

       Required parameters:     none

       Optional parameters:     version, msgtype

              version: The HTTP-Version number of the enclosed message
                       (e.g., "1.0"). If not present, the version can be
                       determined from the first line of the body.

              msgtype: The message type -- "request" or "response". If
                       not present, the type can be determined from the
                       first line of the body.

       Encoding considerations: only "7bit", "8bit", or "binary" are
                                permitted

       Security considerations: none
```

---
## **B.  Tolerant Applications**

이 문서에서는 HTTP/1.0 메시지 생성에 대한 요구 사항을 지정하지만 모든 애플리케이션이 구현에 있어서 올바른 것은 아닙니다. 따라서 운영 애플리케이션에서는 편차가 명확하게 해석될 수 있을 때마다 편차를 허용할 것을 권장합니다.

클라이언트는 상태 라인 구문 분석에 관대해야 하며 서버는 요청 라인 구문 분석에 관대해야 합니다. 특히 단일 SP만 필요하더라도 필드 사이에 SP 또는 HT 문자를 얼마든지 허용해야 합니다.

HTTP 헤더 필드의 줄 종결자는 시퀀스 CRLF입니다. 그러나 애플리케이션이 이러한 헤더를 구문 분석할 때 단일 LF를 줄 종결자로 인식하고 선행 CR을 무시하는 것이 좋습니다.

---
## **C.  Relationship to MIME**

HTTP/1.0은 인터넷 메일\(RFC 822 \[7\]\) 및 다목적 인터넷 메일 확장\(MIME \[5\]\)에 대해 정의된 많은 구성을 사용하여 엔터티가 개방형 다양한 표현과 확장 가능한 메커니즘으로 전송될 수 있도록 합니다. 그러나 RFC 1521은 메일에 대해 설명하고 HTTP에는 RFC 1521에 설명된 것과 다른 몇 가지 기능이 있습니다. 이러한 차이점은 바이너리 연결을 통해 성능을 최적화하고 새로운 미디어 유형을 더 자유롭게 사용할 수 있도록 신중하게 선택되었습니다. 비교를 더 쉽게 하고 일부 초기 HTTP 서버 및 클라이언트의 관행을 인정합니다.

이 글을 쓰는 시점에서는 RFC 1521이 개정될 것으로 예상됩니다. 개정판에는 HTTP/1.0에는 있지만 RFC 1521에는 없는 일부 관행이 포함될 수 있습니다.

이 부록에서는 HTTP가 RFC 1521과 다른 특정 영역을 설명합니다. 엄격한 MIME 환경에 대한 프록시 및 게이트웨이는 이러한 차이점을 인식하고 필요한 경우 적절한 변환을 제공해야 합니다. MIME 환경에서 HTTP로의 프록시 및 게이트웨이도 일부 변환이 필요할 수 있으므로 차이점을 인식해야 합니다.

---
## **C.1  Conversion to Canonical Form**

RFC 1521에서는 RFC 1521 \[5\]의 부록 G에 설명된 대로 인터넷 메일 엔터티를 전송하기 전에 정식 형식으로 변환하도록 요구합니다. 이 문서의 섹션 3.6.1에서는 HTTP를 통해 전송될 때 "텍스트" 미디어 유형의 하위 유형에 허용되는 형식을 설명합니다.

RFC 1521에서는 Content-Type이 "text"인 콘텐츠가 줄 바꿈을 CRLF로 나타내도록 요구하고 줄 바꿈 시퀀스 외부에서 CR 또는 LF를 사용하는 것을 금지합니다. HTTP에서는 메시지가 HTTP를 통해 전송될 때 CRLF, Bare CR 및 Bare LF가 텍스트 내용 내에서 줄바꿈을 표시하도록 허용합니다.

가능한 경우 HTTP에서 엄격한 RFC 1521 환경으로의 프록시 또는 게이트웨이는 이 문서의 섹션 3.6.1에 설명된 텍스트 미디어 유형 내의 모든 줄 바꿈을 RFC 1521 표준 형식의 CRLF로 변환해야 합니다. 그러나 이것은 Content-Encoding의 존재와 HTTP가 CR 및 LF를 표현하기 위해 옥텟 13 및 10을 사용하지 않는 일부 문자 세트의 사용을 허용한다는 사실로 인해 복잡해질 수 있습니다. 멀티바이트 문자 세트.

---
## **C.2  Conversion of Date Formats**

HTTP/1.0은 날짜 비교 프로세스를 단순화하기 위해 제한된 날짜 형식 집합\(섹션 3.3\)을 사용합니다. 다른 프로토콜의 프록시 및 게이트웨이는 메시지에 있는 모든 날짜 헤더 필드가 HTTP/1.0 형식 중 하나를 준수하는지 확인하고 필요한 경우 날짜를 다시 작성해야 합니다.

---
## **C.3  Introduction of Content-Encoding**

RFC 1521에는 HTTP/1.0의 Content-Encoding 헤더 필드와 동일한 개념이 포함되어 있지 않습니다. 이는 미디어 유형에 대한 수정자 역할을 하기 때문에 HTTP에서 MIME 호환 프로토콜로의 프록시 및 게이트웨이는 메시지를 전달하기 전에 Content-Type 헤더 필드의 값을 변경하거나 Entity-Body를 디코딩해야 합니다. \(인터넷 메일에 대한 Content-Type의 일부 실험적 응용 프로그램에서는 Content-Encoding과 동일한 기능을 수행하기 위해 ";conversions=<content-coding\>"이라는 미디어 유형 매개 변수를 사용했습니다. 그러나 이 매개 변수는 RFC 1521의 일부가 아닙니다. \)

---
## **C.4  No Content-Transfer-Encoding**

HTTP는 RFC 1521의 CTE\(Content-Transfer-Encoding\) 필드를 사용하지 않습니다. MIME 호환 프로토콜에서 HTTP로의 프록시 및 게이트웨이는 전달하기 전에 모든 비식별 CTE\("quoted-printable" 또는 "base64"\) 인코딩을 제거해야 합니다. HTTP 클라이언트에 대한 응답 메시지입니다.

HTTP에서 MIME 호환 프로토콜까지의 프록시와 게이트웨이는 메시지가 해당 프로토콜의 안전한 전송을 위해 올바른 형식과 인코딩으로 되어 있는지 확인하는 역할을 합니다. 여기서 "안전한 전송"은 사용 중인 프로토콜의 제한 사항에 따라 정의됩니다. 이러한 프록시나 게이트웨이는 데이터에 적절한 콘텐츠 전송 인코딩을 사용하여 라벨을 지정해야 합니다. 그렇게 하면 대상 프로토콜을 통한 안전한 전송 가능성이 높아집니다.

---
## **C.5  HTTP Header Fields in Multipart Body-Parts**

RFC 1521에서는 필드 이름이 "Content-"로 시작하지 않는 한 다중 부분 본문 부분의 대부분 헤더 필드가 일반적으로 무시됩니다. HTTP/1.0에서 다중 부분 본문 부분에는 해당 부분의 의미에 중요한 HTTP 헤더 필드가 포함될 수 있습니다.

---
## **D.  Additional Features**

이 부록에는 일부 기존 HTTP 구현에서 사용되는 프로토콜 요소가 설명되어 있지만 대부분의 HTTP/1.0 응용 프로그램에서 일관되고 정확하지는 않습니다. 구현자는 이러한 기능을 알고 있어야 하지만 해당 기능의 존재나 상호 운용성에 의존할 수는 없습니다.

```text
   with, other HTTP/1.0 applications.
```

---
## **D.1  Additional Request Methods**
---
### **D.1.1 PUT**

PUT 메소드는 동봉된 엔터티가 제공된 Request-URI에 저장되도록 요청합니다. Request-URI가 이미 존재하는 리소스를 참조하는 경우 동봉된 엔터티는 원서버에 있는 엔터티의 수정된 버전으로 간주되어야 합니다. 요청-URI가 기존 리소스를 가리키지 않고 해당 URI가 요청하는 사용자 에이전트에 의해 새 리소스로 정의될 수 있는 경우 원서버는 해당 URI를 사용하여 리소스를 생성할 수 있습니다.

POST와 PUT 요청의 근본적인 차이점은 Request-URI의 다른 의미에 반영됩니다. POST 요청의 URI는 포함된 엔터티를 처리할 데이터로 처리할 리소스를 식별합니다. 해당 리소스는 데이터를 수용하는 프로세스, 다른 프로토콜에 대한 게이트웨이 또는 주석을 수용하는 별도의 엔터티일 수 있습니다. 대조적으로, PUT 요청의 URI는 요청에 포함된 엔터티를 식별합니다. 즉, 사용자 에이전트는 어떤 URI가 의도되었는지 알고 있으며 서버는 요청을 다른 리소스에 적용해서는 안 됩니다.

---
### **D.1.2 DELETE**

DELETE 메소드는 원서버가 Request-URI로 식별된 자원을 삭제하도록 요청한다.

---
### **D.1.3 LINK**

LINK 방법은 요청-URI로 식별된 기존 리소스와 다른 기존 리소스 간에 하나 이상의 링크 관계를 설정합니다.

---
### **D.1.4 UNLINK**

UNLINK 메서드는 요청-URI로 식별된 기존 리소스에서 하나 이상의 링크 관계를 제거합니다.

---
## **D.2  Additional Header Field Definitions**
---
### **D.2.1 Accept**

Accept 요청 헤더 필드는 요청에 대한 응답으로 허용되는 미디어 범위 목록을 나타내는 데 사용될 수 있습니다. 별표 "\*" 문자는 미디어 유형을 범위로 그룹화하는 데 사용됩니다. "\*/\*"는 모든 미디어 유형을 나타내고 "type/\*"은 모든 하위 유형을 나타냅니다.

그런 종류의. 클라이언트가 제공한 범위 집합은 요청 컨텍스트에 따라 허용되는 유형을 나타내야 합니다.

---
### **D.2.2 Accept-Charset**

Accept-Charset 요청 헤더 필드는 기본 US-ASCII 및 ISO-8859-1 이외의 기본 문자 집합 목록을 나타내는 데 사용할 수 있습니다. 이 필드를 사용하면 보다 포괄적이거나 특수 목적의 문자 집합을 이해할 수 있는 클라이언트가 해당 문자 집합으로 문서를 표현할 수 있는 서버에 해당 기능을 알릴 수 있습니다.

---
### **D.2.3 Accept-Encoding**

Accept-Encoding 요청 헤더 필드는 Accept와 유사하지만 응답에서 허용되는 콘텐츠 코딩 값을 제한합니다.

---
### **D.2.4 Accept-Language**

Accept-Language 요청 헤더 필드는 Accept와 유사하지만 요청에 대한 응답으로 선호되는 자연어 세트를 제한합니다.

---
### **D.2.5 Content-Language**

Content-Language 엔터티 헤더 필드는 포함된 엔터티에 대한 대상 청중의 자연 언어를 설명합니다. 이는 엔터티 내에서 사용되는 모든 언어와 동일하지 않을 수도 있습니다.

---
### **D.2.6 Link**

Link 엔터티 헤더 필드는 엔터티와 다른 리소스 간의 관계를 설명하는 수단을 제공합니다. 엔터티에는 여러 Link 값이 포함될 수 있습니다. 메타정보 수준의 링크는 일반적으로 계층 구조 및 탐색 경로와 같은 관계를 나타냅니다.

---
### **D.2.7 MIME-Version**

HTTP 메시지에는 메시지를 구성하는 데 사용된 MIME 프로토콜 버전을 나타내는 단일 MIME-Version 일반 헤더 필드가 포함될 수 있습니다. RFC 1521 \[5\]에 정의된 대로 MIME 버전 헤더 필드를 사용하면 메시지가 MIME 규격임을 나타내야 합니다. 불행하게도 일부 오래된 HTTP/1.0 서버는 이를 무차별적으로 전송하므로 이 필드는 무시해야 합니다.

---
### **D.2.8 Retry-After**

Retry-After 응답 헤더 필드는 503\(서비스 사용 불가\) 응답과 함께 사용하여 요청 클라이언트가 서비스를 사용할 수 없는 기간을 나타낼 수 있습니다. 이 필드의 값은 HTTP 날짜이거나 응답 시간 이후의 정수\(십진수\)일 수 있습니다.

---
### **D.2.9 Title**

Title 엔터티 헤더 필드는 엔터티의 제목을 나타냅니다.

---
### **D.2.10 URI**

URI 엔터티 헤더 필드에는 요청-URI 자원을 식별할 수 있는 통일 자원 식별자\(3.2절\)의 일부 또는 전부가 포함될 수 있습니다. 지정된 URI를 사용하여 리소스에 액세스할 수 있다는 보장은 없습니다.
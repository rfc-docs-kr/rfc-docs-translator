

```text
﻿

Internet Engineering Task Force (IETF)                    D. Noveck, Ed.
Request for Comments: 8881                                        NetApp
Obsoletes: 5661                                                 C. Lever
Category: Standards Track                                         ORACLE
ISSN: 2070-1721                                              August 2020

      Network File System (NFS) Version 4 Minor Version 1 Protocol
```

---
# **Abstract**

이 문서에서는 기본 프로토콜\(RFC 7530에 지정된 NFS 버전 4 부 버전 0\)에서 유지되는 기능과 이후에 만들어진 프로토콜 확장을 포함하여 NFS\(Network File System\) 버전 4 부 버전 1에 대해 설명합니다. 최신 마이너 버전은 NFS 버전 4 마이너 버전 0에 종속되지 않으며 별도의 프로토콜로 간주됩니다.

이 문서는 RFC 5661을 폐기합니다. 이는 다중 서버 네임스페이스와 관련된 기능의 처리를 실질적으로 개정하여 RFC 5661에 나타나는 기능에 대한 설명을 대체합니다.

---
# **Status of This Memo**

이것은 인터넷 표준 추적 문서입니다.

이 문서는 IETF\(Internet Engineering Task Force\)의 제품입니다. 이는 IETF 커뮤니티의 합의를 나타냅니다. 공개 검토를 받았으며 IESG\(Internet Engineering Steering Group\)의 출판 승인을 받았습니다. 인터넷 표준에 대한 자세한 내용은 RFC 7841의 섹션 2에서 확인할 수 있습니다.

이 문서의 현재 상태, 정오표, 피드백 제공 방법에 대한 정보는 https://www.rfc-editor.org/info/rfc8881에서 얻을 수 있습니다.

---
# **Copyright Notice**

Copyright \(c\) 2020 IETF Trust 및 문서 작성자로 확인된 사람. 판권 소유.

이 문서는 이 문서의 발행일에 유효한 BCP 78 및 IETF 문서에 관한 IETF 트러스트의 법적 조항\(https://trustee.ietf.org/license-info\)의 적용을 받습니다. 이 문서와 관련된 귀하의 권리 및 제한 사항을 설명하므로 이 문서를 주의 깊게 검토하십시오. 이 문서에서 추출한 코드 구성 요소는 Trust Legal Provisions의 섹션 4.e에 설명된 대로 Simplified BSD License 텍스트를 포함해야 하며 Simplified BSD License에 설명된 대로 보증 없이 제공됩니다.

이 문서에는 2008년 11월 10일 이전에 공개되거나 공개된 IETF 문서 또는 IETF 기고문의 자료가 포함될 수 있습니다. 이 자료의 일부에 대한 저작권을 제어하는 ​​사람은 해당 자료의 수정을 허용할 권리를 IETF 트러스트에 부여하지 않았을 수 있습니다. IETF 표준 프로세스 외부. 이러한 자료의 저작권을 관리하는 사람으로부터 적절한 라이센스를 얻지 않고 이 문서는 IETF 표준 프로세스 외부에서 수정할 수 없으며 IETF 표준 프로세스 외부에서 이 문서의 파생물을 생성할 수 없습니다. RFC로 게시하거나 영어 이외의 언어로 번역합니다.

---
# **Table of Contents**

```text
   1.  Introduction
     1.1.  Introduction to This Update
     1.2.  The NFS Version 4 Minor Version 1 Protocol
     1.3.  Requirements Language
     1.4.  Scope of This Document
     1.5.  NFSv4 Goals
     1.6.  NFSv4.1 Goals
     1.7.  General Definitions
     1.8.  Overview of NFSv4.1 Features
     1.9.  Differences from NFSv4.0
   2.  Core Infrastructure
     2.1.  Introduction
     2.2.  RPC and XDR
     2.3.  COMPOUND and CB_COMPOUND
     2.4.  Client Identifiers and Client Owners
     2.5.  Server Owners
     2.6.  Security Service Negotiation
     2.7.  Minor Versioning
     2.8.  Non-RPC-Based Security Services
     2.9.  Transport Layers
     2.10. Session
   3.  Protocol Constants and Data Types
     3.1.  Basic Constants
     3.2.  Basic Data Types
     3.3.  Structured Data Types
   4.  Filehandles
     4.1.  Obtaining the First Filehandle
     4.2.  Filehandle Types
     4.3.  One Method of Constructing a Volatile Filehandle
     4.4.  Client Recovery from Filehandle Expiration
   5.  File Attributes
     5.1.  REQUIRED Attributes
     5.2.  RECOMMENDED Attributes
     5.3.  Named Attributes
     5.4.  Classification of Attributes
     5.5.  Set-Only and Get-Only Attributes
     5.6.  REQUIRED Attributes - List and Definition References
     5.7.  RECOMMENDED Attributes - List and Definition References
     5.8.  Attribute Definitions
     5.9.  Interpreting owner and owner_group
     5.10. Character Case Attributes
     5.11. Directory Notification Attributes
     5.12. pNFS Attribute Definitions
     5.13. Retention Attributes
   6.  Access Control Attributes
     6.1.  Goals
     6.2.  File Attributes Discussion
     6.3.  Common Methods
     6.4.  Requirements
   7.  Single-Server Namespace
     7.1.  Server Exports
     7.2.  Browsing Exports
     7.3.  Server Pseudo File System
     7.4.  Multiple Roots
     7.5.  Filehandle Volatility
     7.6.  Exported Root
     7.7.  Mount Point Crossing
     7.8.  Security Policy and Namespace Presentation
   8.  State Management
     8.1.  Client and Session ID
     8.2.  Stateid Definition
     8.3.  Lease Renewal
     8.4.  Crash Recovery
     8.5.  Server Revocation of Locks
     8.6.  Short and Long Leases
     8.7.  Clocks, Propagation Delay, and Calculating Lease Expiration
     8.8.  Obsolete Locking Infrastructure from NFSv4.0
   9.  File Locking and Share Reservations
     9.1.  Opens and Byte-Range Locks
     9.2.  Lock Ranges
     9.3.  Upgrading and Downgrading Locks
     9.4.  Stateid Seqid Values and Byte-Range Locks
     9.5.  Issues with Multiple Open-Owners
     9.6.  Blocking Locks
     9.7.  Share Reservations
     9.8.  OPEN/CLOSE Operations
     9.9.  Open Upgrade and Downgrade
     9.10. Parallel OPENs
     9.11. Reclaim of Open and Byte-Range Locks
   10. Client-Side Caching
     10.1.  Performance Challenges for Client-Side Caching
     10.2.  Delegation and Callbacks
     10.3.  Data Caching
     10.4.  Open Delegation
     10.5.  Data Caching and Revocation
     10.6.  Attribute Caching
     10.7.  Data and Metadata Caching and Memory Mapped Files
     10.8.  Name and Directory Caching without Directory Delegations
     10.9.  Directory Delegations
   11. Multi-Server Namespace
     11.1.  Terminology
     11.2.  File System Location Attributes
     11.3.  File System Presence or Absence
     11.4.  Getting Attributes for an Absent File System
     11.5.  Uses of File System Location Information
     11.6.  Trunking without File System Location Information
     11.7.  Users and Groups in a Multi-Server Namespace
     11.8.  Additional Client-Side Considerations
     11.9.  Overview of File Access Transitions
     11.10. Effecting Network Endpoint Transitions
     11.11. Effecting File System Transitions
     11.12. Transferring State upon Migration
     11.13. Client Responsibilities When Access Is Transitioned
     11.14. Server Responsibilities Upon Migration
     11.15. Effecting File System Referrals
     11.16. The Attribute fs_locations
     11.17. The Attribute fs_locations_info
     11.18. The Attribute fs_status
   12. Parallel NFS (pNFS)
     12.1.  Introduction
     12.2.  pNFS Definitions
     12.3.  pNFS Operations
     12.4.  pNFS Attributes
     12.5.  Layout Semantics
     12.6.  pNFS Mechanics
     12.7.  Recovery
     12.8.  Metadata and Storage Device Roles
     12.9.  Security Considerations for pNFS
   13. NFSv4.1 as a Storage Protocol in pNFS: the File Layout Type
     13.1.  Client ID and Session Considerations
     13.2.  File Layout Definitions
     13.3.  File Layout Data Types
     13.4.  Interpreting the File Layout
     13.5.  Data Server Multipathing
     13.6.  Operations Sent to NFSv4.1 Data Servers
     13.7.  COMMIT through Metadata Server
     13.8.  The Layout Iomode
     13.9.  Metadata and Data Server State Coordination
     13.10. Data Server Component File Size
     13.11. Layout Revocation and Fencing
     13.12. Security Considerations for the File Layout Type
   14. Internationalization
     14.1.  Stringprep Profile for the utf8str_cs Type
     14.2.  Stringprep Profile for the utf8str_cis Type
     14.3.  Stringprep Profile for the utf8str_mixed Type
     14.4.  UTF-8 Capabilities
     14.5.  UTF-8 Related Errors
   15. Error Values
     15.1.  Error Definitions
     15.2.  Operations and Their Valid Errors
     15.3.  Callback Operations and Their Valid Errors
     15.4.  Errors and the Operations That Use Them
   16. NFSv4.1 Procedures
     16.1.  Procedure 0: NULL - No Operation
     16.2.  Procedure 1: COMPOUND - Compound Operations
   17. Operations: REQUIRED, RECOMMENDED, or OPTIONAL
   18. NFSv4.1 Operations
     18.1.  Operation 3: ACCESS - Check Access Rights
     18.2.  Operation 4: CLOSE - Close File
     18.3.  Operation 5: COMMIT - Commit Cached Data
     18.4.  Operation 6: CREATE - Create a Non-Regular File Object
     18.5.  Operation 7: DELEGPURGE - Purge Delegations Awaiting
             Recovery
     18.6.  Operation 8: DELEGRETURN - Return Delegation
     18.7.  Operation 9: GETATTR - Get Attributes
     18.8.  Operation 10: GETFH - Get Current Filehandle
     18.9.  Operation 11: LINK - Create Link to a File
     18.10. Operation 12: LOCK - Create Lock
     18.11. Operation 13: LOCKT - Test for Lock
     18.12. Operation 14: LOCKU - Unlock File
     18.13. Operation 15: LOOKUP - Lookup Filename
     18.14. Operation 16: LOOKUPP - Lookup Parent Directory
     18.15. Operation 17: NVERIFY - Verify Difference in Attributes
     18.16. Operation 18: OPEN - Open a Regular File
     18.17. Operation 19: OPENATTR - Open Named Attribute Directory
     18.18. Operation 21: OPEN_DOWNGRADE - Reduce Open File Access
     18.19. Operation 22: PUTFH - Set Current Filehandle
     18.20. Operation 23: PUTPUBFH - Set Public Filehandle
     18.21. Operation 24: PUTROOTFH - Set Root Filehandle
     18.22. Operation 25: READ - Read from File
     18.23. Operation 26: READDIR - Read Directory
     18.24. Operation 27: READLINK - Read Symbolic Link
     18.25. Operation 28: REMOVE - Remove File System Object
     18.26. Operation 29: RENAME - Rename Directory Entry
     18.27. Operation 31: RESTOREFH - Restore Saved Filehandle
     18.28. Operation 32: SAVEFH - Save Current Filehandle
     18.29. Operation 33: SECINFO - Obtain Available Security
     18.30. Operation 34: SETATTR - Set Attributes
     18.31. Operation 37: VERIFY - Verify Same Attributes
     18.32. Operation 38: WRITE - Write to File
     18.33. Operation 40: BACKCHANNEL_CTL - Backchannel Control
     18.34. Operation 41: BIND_CONN_TO_SESSION - Associate Connection
             with Session
     18.35. Operation 42: EXCHANGE_ID - Instantiate Client ID
     18.36. Operation 43: CREATE_SESSION - Create New Session and
             Confirm Client ID
     18.37. Operation 44: DESTROY_SESSION - Destroy a Session
     18.38. Operation 45: FREE_STATEID - Free Stateid with No Locks
     18.39. Operation 46: GET_DIR_DELEGATION - Get a Directory
             Delegation
     18.40. Operation 47: GETDEVICEINFO - Get Device Information
     18.41. Operation 48: GETDEVICELIST - Get All Device Mappings for
             a File System
     18.42. Operation 49: LAYOUTCOMMIT - Commit Writes Made Using a
             Layout
     18.43. Operation 50: LAYOUTGET - Get Layout Information
     18.44. Operation 51: LAYOUTRETURN - Release Layout Information
     18.45. Operation 52: SECINFO_NO_NAME - Get Security on Unnamed
             Object
     18.46. Operation 53: SEQUENCE - Supply Per-Procedure Sequencing
             and Control
     18.47. Operation 54: SET_SSV - Update SSV for a Client ID
     18.48. Operation 55: TEST_STATEID - Test Stateids for Validity
     18.49. Operation 56: WANT_DELEGATION - Request Delegation
     18.50. Operation 57: DESTROY_CLIENTID - Destroy a Client ID
     18.51. Operation 58: RECLAIM_COMPLETE - Indicates Reclaims
             Finished
     18.52. Operation 10044: ILLEGAL - Illegal Operation
   19. NFSv4.1 Callback Procedures
     19.1.  Procedure 0: CB_NULL - No Operation
     19.2.  Procedure 1: CB_COMPOUND - Compound Operations
   20. NFSv4.1 Callback Operations
     20.1.  Operation 3: CB_GETATTR - Get Attributes
     20.2.  Operation 4: CB_RECALL - Recall a Delegation
     20.3.  Operation 5: CB_LAYOUTRECALL - Recall Layout from Client
     20.4.  Operation 6: CB_NOTIFY - Notify Client of Directory
             Changes
     20.5.  Operation 7: CB_PUSH_DELEG - Offer Previously Requested
             Delegation to Client
     20.6.  Operation 8: CB_RECALL_ANY - Keep Any N Recallable Objects
     20.7.  Operation 9: CB_RECALLABLE_OBJ_AVAIL - Signal Resources
             for Recallable Objects
     20.8.  Operation 10: CB_RECALL_SLOT - Change Flow Control Limits
     20.9.  Operation 11: CB_SEQUENCE - Supply Backchannel Sequencing
             and Control
     20.10. Operation 12: CB_WANTS_CANCELLED - Cancel Pending
             Delegation Wants
     20.11. Operation 13: CB_NOTIFY_LOCK - Notify Client of Possible
             Lock Availability
     20.12. Operation 14: CB_NOTIFY_DEVICEID - Notify Client of Device
             ID Changes
     20.13. Operation 10044: CB_ILLEGAL - Illegal Callback Operation
   21. Security Considerations
   22. IANA Considerations
     22.1.  IANA Actions
     22.2.  Named Attribute Definitions
     22.3.  Device ID Notifications
     22.4.  Object Recall Types
     22.5.  Layout Types
     22.6.  Path Variable Definitions
   23. References
     23.1.  Normative References
     23.2.  Informative References
   Appendix A.  The Need for This Update
   Appendix B.  Changes in This Update
     B.1.  Revisions Made to Section 11 of RFC 5661
     B.2.  Revisions Made to Operations in RFC 5661
     B.3.  Revisions Made to Error Definitions in RFC 5661
     B.4.  Other Revisions Made to RFC 5661
   Appendix C.  Security Issues That Need to Be Addressed
   Acknowledgments
   Authors' Addresses
```

---
## **1.  Introduction**
---
### **1.1.  Introduction to This Update**

이전에 마이너 버전 0에서 정의되었지만 마이너 버전 1에서 완전히 해결되지 않은 두 가지 중요한 기능은 클라이언트와 서버 간, 잠재적으로 다른 네트워크 주소에 대한 여러 연결을 동시에 사용하는 트렁킹과 파일 시스템을 허용하는 투명 상태 마이그레이션입니다. 전송 중에 기존 잠금 상태를 유지할 수 있는 기능을 클라이언트에 제공하는 방식으로 서버 간에 전송됩니다.

이 업데이트에 제시된 NFS 버전 4 부 버전 1\(NFSv4.1\) 프로토콜에 대한 수정된 설명은 이러한 기능을 다른 다중 서버 네임스페이스 기능과 함께 완전히 사용하려면 필요합니다. 이 문서는 이전에 RFC 5661 \[66\]에 정의된 NFSv4.1 프로토콜에 대한 업데이트된 설명 형식입니다. RFC 5661은 이 문서에서 더 이상 사용되지 않습니다. 그러나 업데이트의 범위는 제한되어 있으며 트렁킹 및 투명 상태 마이그레이션을 최대한 활용하는 데 중점을 두고 있습니다. 이러한 변경의 필요성은 부록 A에서 논의됩니다. 부록 B는 현재 텍스트에 도달하기 위해 이루어진 구체적인 변경 사항을 설명합니다.

이 제한된 범위 업데이트는 권위 있고 완전한 사양을 제공하려는 의도로 현재 NFSv4.1 RFC를 대체합니다. 이에 대한 동기는 \[36\]에서 논의되어 업데이트 범위 내의 문제를 해결합니다. 그러나 프로토콜의 전체 업데이트에서 예상할 수 있는 제한된 범위를 벗어나는 알려진 문제는 해결하지 않습니다. 다음은 향후 프로토콜 업데이트에서 해결이 필요한 것으로 알려진 일부 영역입니다.

\* 작업은 RFC 8178 \[67\]에 따라 수행되어야 합니다.

- NFSv4 전체 버전 관리 규칙을 설정합니다. RFC 5661은 현재 해당 문서와 일치하지 않으므로 RFC 8178이 NFSv4.1 사양을 업데이트할 필요가 없는 상황에 도달하려면 변경이 필요합니다.

\* RFC 8434 \[70\]에 관한 작업이 수행되어야 합니다.

- RFC 5661에 명확하게 정의되지 않은 병렬 NFS\(pNFS\) 레이아웃 유형에 대한 요구 사항을 설정합니다. 해당 작업이 완료되고 결과 문서가 승인되면 새 NFSv4.1 사양 문서는 레이아웃 유형에 대한 명확한 요구 사항 세트를 제공합니다. 그리고 해당 요구 사항을 준수하는 파일 레이아웃 유형에 대한 설명입니다. 다른 레이아웃 유형에도 해당 요구 사항을 준수하는 자체 사양 문서가 있습니다.

\* 이 문서에서 다루는 정오표 보고서 2006 \[64\] 외에 RFC 5661과 관련된 많은 정오표 보고서를 해결하기 위한 작업이 수행되어야 합니다. 해당 보고서에 제안된 변경 사항과 새로 설명된 상태 및 세션 마이그레이션 처리의 상호 작용으로 인해 해당 보고서의 처리를 연기할 수 없었습니다.

- 연기되었으며 이후 문서에서 해결해야 할 정오표 보고서에는 승인됨으로 표시된 보고서와 변경 사항이 너무 미미하여 문서 업데이트 보류로 표시된 보고서를 포함하여 현재 정오표 보고 시스템에서 다양한 상태가 할당된 보고서가 포함됩니다. 즉시 해결하기 위해.

- 또한 거부됨 상태의 최소 하나를 포함하여 이후 문서에서 해결해야 할 일련의 다른 보고서가 있습니다. 여기에는 작업 그룹이 RFC 5661의 처리가 올바르지 않고 작업 그룹의 새로운 합의를 반영하고 기존 구현과의 호환성을 보장하기 위해 수정되어야 한다고 결정한 상황에서 RFC 5661에 반영된 합의 결정을 변경하는 것이 포함됩니다. RFC 5661에 설명된 처리를 따르지 마세요.

- 이 문서가 RFC 5661 \[66\]을 폐기했다는 사실에도 불구하고 이러한 모든 정오표 보고서는 구현자와 최종 rfc5661bis 작성자와 관련성이 유지될 것으로 예상됩니다.

\* 기술에 대한 새로운 접근이 필요하다.

- 현재 국제화 섹션\(섹션 14\) 이후 국제화는 구현된 적이 없으며 NFSv4 프로토콜의 요구 사항을 충족하지 않습니다. 가능한 해결책은 \[68\]을 모델로 한 새로운 국제화 섹션을 생성하거나 모든 NFSv4 부 버전에 대한 국제화를 설명하는 새로운 문서를 생성하고 NFSv4.0 및 NFSv4.1을 모두 정의하는 RFC에서 해당 문서를 참조하는 것입니다.

\* NFSv4.1에서는 보안 처리 방식을 개정할 필요가 있습니다. 기존 치료법의 문제는 부록 C에서 논의됩니다.

위 작업이 완료될 때까지는 NFSv4.1 프로토콜에 대한 설명을 제공하는 일관된 문서 세트가 없으며 전체 설명에는 사양 내의 다른 문서를 업데이트하는 문서가 포함됩니다. RFC 8434 \[70\] 및 RFC 8178 \[67\]에서 RFC 5661에 적용한 업데이트도 이 사양에 적용되며 해당 작업이 완료될 때까지 모든 후속 v4.1 사양에 적용됩니다.

---
### **1.2.  The NFS Version 4 Minor Version 1 Protocol**

NFS 버전 4 마이너 버전 1\(NFSv4.1\) 프로토콜은 NFS 버전 4\(NFSv4\) 프로토콜의 두 번째 마이너 버전입니다. 첫 번째 마이너 버전인 NFSv4.0은 이제 RFC 7530 \[68\]에 설명되어 있습니다. 이는 일반적으로 RFC 3530 \[37\]의 섹션 10에 나열된 부 버전 관리 지침을 따릅니다. 그러나 이는 지침 11\("부 버전 X를 지원하는 클라이언트 및 서버는 부 버전 0부터 X-1까지 지원해야 함"\) 및 12\("부 버전에서는 새로운 기능을 필수로 도입할 수 없음"\)와 다릅니다. 이러한 차이는 비멱등성 작업과 RECLAIM\_COMPLETE 작업을 관리하기 위한 세션 모델의 도입으로 인해 발생합니다. 이 두 가지 새로운 기능은 본질적으로 인프라적이며 기존 기능과 기타 새로운 기능의 구현을 단순화합니다. REQUIRED가 아닌 다른 것으로 만들면 프로토콜 정의 및 구현이 지나치게 복잡해집니다. NFSv4.1은 그에 따라 부 버전 관리 지침을 업데이트합니다\(섹션 2.7\).\(MUST\)

마이너 버전인 NFSv4.1은 NFSv4의 전반적인 목표와 일치하지만 NFSv4.0에 대한 경험을 바탕으로 해당 목표를 더 잘 충족할 수 있도록 프로토콜을 확장합니다. 또한 NFSv4.1은 NFSv4.1의 일부 주요 확장에 동기를 부여하는 몇 가지 추가 목표를 채택했습니다.

---
### **1.3.  Requirements Language**

이 문서의 키워드 "MUST", "MUST NOT", "REQUIRED", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY" 및 "OPTIONAL"은 RFC 2119 \[1\]에 설명된 대로 해석되어야 합니다.\(MUST NOT\)

---
### **1.4.  Scope of This Document**

이 문서에서는 NFSv4.1 프로토콜에 대해 설명합니다. NFSv4.0과 관련하여 이 문서에서는 다음을 수행하지 않습니다.

\* NFSv4.1과 대조해야 하는 경우를 제외하고 NFSv4.0 프로토콜을 설명합니다.

\* NFSv4.0 프로토콜의 사양을 수정합니다.

\* NFSv4.0 프로토콜을 명확히 합니다.

---
### **1.5.  NFSv4 Goals**

NFSv4 프로토콜은 NFSv3\[38\]에 의해 이미 정의된 NFS 프로토콜의 추가 개정판입니다. 이전 버전의 필수 특성을 유지합니다. 즉, 복구가 용이합니다. 전송 프로토콜, 운영 체제 및 파일 시스템의 독립성; 간단; 그리고 좋은 성능. NFSv4에는 다음과 같은 목표가 있습니다.

\* 인터넷 접속 개선 및 성능 향상

- 이 프로토콜은 방화벽을 쉽게 통과하고 대기 시간이 길고 대역폭이 낮은 곳에서 잘 작동하며 서버당 매우 많은 수의 클라이언트로 확장되도록 설계되었습니다.

\* 프로토콜에 내장된 협상을 통한 강력한 보안

- 이 프로토콜은 RPCSEC\_GSS 프로토콜을 지원하는 ONCRPC 작업 그룹의 작업을 기반으로 구축되었습니다. 또한 NFSv4.1 프로토콜은 클라이언트와 서버가 보안을 협상할 수 있도록 하고 클라이언트와 서버가 최소한의 보안 체계 집합을 지원하도록 요구하는 메커니즘을 제공합니다.

```text
   *  Good cross-platform interoperability
```

- 프로토콜은 하나의 파일 시스템이나 운영 체제를 다른 파일 시스템이나 운영 체제보다 과도하게 선호하지 않는 유용하고 공통된 기능 세트를 제공하는 파일 시스템 모델을 특징으로 합니다.

\* 프로토콜 확장을 위해 설계됨

- 프로토콜은 이전 버전과의 호환성을 활성화하고 장려하는 프레임워크 내에서 표준 확장을 허용하도록 설계되었습니다.

---
### **1.6.  NFSv4.1 Goals**

NFSv4.1은 전체 NFSv4 목표에 의해 설정된 프레임워크 내에서 다음과 같은 목표를 가지고 있습니다.

\* 기본 프로토콜에서 발견된 중요한 구조적 약점과 실수를 수정합니다.

\* 기본 프로토콜에서 아직 다루어지지 않았거나 충분히 자세하게 다루어지지 않은 영역에 명확성과 구체성을 추가합니다. 그러나 1.4절에서 설명한 것처럼 NFSv4.1 사양에서 NFSv4.0 프로토콜을 명확히 하는 것이 목표는 아닙니다.

\* 기존 프로토콜 경험과 최근 업계 발전을 바탕으로 특정 기능을 추가합니다.

\* 여러 서버에 분산된 파일에 대한 확장 가능한 병렬 액세스를 제공하는 기능을 포함하여 클러스터된 서버 배포를 활용하기 위한 프로토콜 지원을 제공합니다.

---
### **1.7.  General Definitions**

다음 정의는 독자에게 적절한 맥락을 제공합니다.

바이트: 이 문서에서 바이트는 옥텟, 즉 길이가 정확히 8비트인 데이텀입니다.

클라이언트: 클라이언트는 NFS 서버의 리소스에 액세스하는 엔터티입니다. 클라이언트는 NFS 서버에 직접 액세스하는 논리를 포함하는 애플리케이션일 수 있습니다. 클라이언트는 일련의 애플리케이션에 원격 파일 시스템 서비스를 제공하는 기존 운영 체제 클라이언트일 수도 있습니다.

- 클라이언트는 클라이언트 소유자에 의해 고유하게 식별됩니다.

- 바이트 범위 잠금과 관련하여 클라이언트는 하나 이상의 애플리케이션을 대신하여 잠금 세트를 유지 관리하는 엔터티이기도 합니다. 이 클라이언트는 자신이 관리하는 잠금에 대한 충돌 또는 오류 복구를 담당합니다.

- 여러 클라이언트가 동일한 전송 및 연결을 공유할 수 있으며 여러 클라이언트가 동일한 네트워크 노드에 존재할 수 있습니다.

클라이언트 ID: 클라이언트 ID는 클라이언트 제공 검증자 및 클라이언트 소유자에 대한 고유한 약식 참조로 사용되는 64비트 수량입니다. 서버는 클라이언트 ID 제공을 담당합니다.

클라이언트 소유자: 클라이언트 소유자는 클라이언트를 식별하는 서버에 불투명한 고유 문자열입니다. 여러 네트워크 연결과 해당 연결에서 발생하는 소스 네트워크 주소는 클라이언트 소유자를 공유할 수 있습니다. 서버는 동일한 클라이언트 소유자와의 연결 요청을 동일한 클라이언트에서 오는 것으로 처리해야 합니다.

파일 시스템: 파일 시스템은 동일한 fsid 속성\(섹션 5.8.1.9 참조\)을 공유하는 서버\(이 섹션의 뒷부분에서 정의되는 서버 소유자의 주요 식별자로 식별됨\)에 있는 개체 모음입니다.

임대: 임대는 클라이언트에 취소할 수 없는 잠금이 부여되는 서버에서 정의한 시간 간격입니다. 임대 기간 종료 시 임대 기간이 연장되지 않은 경우 잠금이 취소될 수 있습니다. 임대 간격 이후 충돌하는 잠금이 부여된 경우 잠금을 취소해야 합니다.

- 서버는 클라이언트에게 모든 상태에 대한 단일 임대를 부여합니다.

잠금: "잠금"이라는 용어는 별도로 명시하지 않는 한 바이트 범위\(UNIX 환경에서는 레코드라고도 함\) 잠금, 공유 예약, 위임 또는 레이아웃을 나타내는 데 사용됩니다.

SSV\(Secret State Verifier\): SSV는 클라이언트와 서버 간에 공유되는 고유한 비밀 키입니다. SSV는 내부\(즉, NFSv4.1 내부\) 일반 보안 서비스\(GSS\) 메커니즘\(SSV GSS 메커니즘, 섹션 2.10.9 참조\)에 대한 비밀 키 역할을 합니다. SSV GSS 메커니즘은 SSV를 사용하여 MIC\(메시지 무결성 코드\) 및 랩 토큰을 계산합니다. NFSv4.1이 SSV 및 SSV GSS 메커니즘을 사용하는 방법에 대한 자세한 내용은 섹션 2.10.8.3을 참조하세요.

서버: 서버는 파일 시스템 집합에 대한 클라이언트 액세스를 조정하는 역할을 담당하는 개체이며 서버 소유자에 의해 식별됩니다. 서버는 여러 네트워크 주소에 걸쳐 있을 수 있습니다.

서버 소유자: 서버 소유자는 클라이언트에 대해 서버를 식별합니다. 서버 소유자는 주 식별자와 부 식별자로 구성됩니다. 클라이언트가 동일한 주요 식별자를 가진 피어에 대해 각각 두 개의 연결을 갖고 있는 경우 클라이언트는 두 피어가 모두 동일한 서버이고\(서버 네임스페이스는 각 연결을 통해 동일함\) 잠금 상태가 두 연결에서 공유 가능하다고 가정합니다. 각 피어에 동일한 주 식별자와 부 식별자가 모두 있는 경우 클라이언트는 각 연결이 동일한 세션과 연결될 수 있다고 가정합니다.

안정적인 스토리지: 안정적인 스토리지는 NFSv4.1 서버에 저장된 데이터가 여러 정전\(계단식 정전, 즉 빠르게 연속적으로 발생하는 정전 포함\), 운영 체제 장애 및/또는 운영 체제 장애로 인한 데이터 손실 없이 복구할 수 있는 스토리지입니다. 또는 저장 매체 자체 이외의 구성 요소\(예: 디스크, 비휘발성 RAM, 플래시 메모리 등\)의 하드웨어 오류.

- NFS 서버에 허용되는 안정적인 저장소의 몇 가지 예는 다음과 같습니다.

- 1. 데이터의 미디어 커밋 즉, 수정된 데이터가 디스크 미디어\(예: 디스크 플래터\)에 성공적으로 기록되었습니다.

- 2. 배터리 지원, 온드라이브 중간 스토리지 또는 무정전 전원 시스템\(UPS\)을 갖춘 즉시 응답 디스크 드라이브입니다.

- 3. 배터리 지원 중간 저장 및 복구 소프트웨어를 사용하여 서버에서 데이터를 커밋합니다.

- 4. 무정전 전원 시스템\(UPS\) 및 복구 소프트웨어를 사용한 캐시 커밋.

Stateid: stateid는 특정 파일 및 잠금 유형에 대한 잠금 소유자/열기 소유자 쌍 또는 특정 열기 소유자에 대해 서버에서 제공하는 열기 및 잠금 상태를 고유하게 정의하는 서버에서 반환되는 128비트 수량입니다.

검증자: 검증자는 클라이언트가 다시 시작되었고 이전 잠금 상태가 모두 손실되었는지 확인하는 데 서버가 사용할 수 있는 클라이언트가 생성한 64비트 수량입니다.

---
### **1.8.  Overview of NFSv4.1 Features**

NFSv4.1 프로토콜의 주요 기능을 간략하게 검토합니다. 이는 이전 버전의 NFS 프로토콜에 익숙한 독자와 NFS 프로토콜을 처음 접하는 독자 모두에게 적절한 컨텍스트를 제공하기 위해 수행됩니다. NFS 프로토콜을 처음 접하는 독자에게는 여전히 기본적인 지식이 필요합니다. 독자는 \[2\]와 \[3\]에 설명된 XDR\(외부 데이터 표현\) 및 RPC\(원격 프로시저 호출\) 프로토콜에 익숙해야 합니다. 파일 시스템 및 분산 파일 시스템에 대한 기본 지식도 필요합니다.

일반적으로 NFSv4.1의 이 사양은 마이너 버전 1에 추가된 기능을 기본 프로토콜에 있는 기능과 구별하지 않지만 NFSv4.1을 통합된 전체로 취급합니다. NFSv4.0과 NFSv4.1의 차이점 요약은 섹션 1.9를 참조하세요.

---
#### **1.8.1.  RPC and Security**

이전 버전의 NFS와 마찬가지로 NFSv4.1 프로토콜에 사용되는 XDR\(외부 데이터 표현\) 및 RPC\(원격 프로시저 호출\) 메커니즘은 \[2\] 및 \[3\]에 정의되어 있습니다. 엔드 투 엔드 보안 요구 사항을 충족하기 위해 RPCSEC\_GSS 프레임워크\[4\]를 사용하여 기본 RPC 보안을 확장합니다. RPCSEC\_GSS를 사용하면 NFSv4 프로토콜에 인증, 무결성 및 개인정보 보호를 제공하는 다양한 메커니즘이 제공될 수 있습니다. Kerberos V5는 \[5\]에 설명된 대로 하나의 보안 프레임워크를 제공하는 데 사용됩니다. RPCSEC\_GSS를 사용하면 NFSv4.1 보안을 위해 다른 메커니즘을 지정하고 사용할 수도 있습니다.

대역 내 보안 협상을 활성화하기 위해 NFSv4.1 프로토콜에는 서버의 파일 시스템 리소스에 액세스하는 데 사용해야 하는 보안 메커니즘과 관련된 정책에 대해 서버에 쿼리하는 방법을 클라이언트에 제공하는 작업이 있습니다. 이를 통해 클라이언트는 클라이언트와 서버 모두에 지정된 정책을 충족하는 보안 메커니즘을 안전하게 일치시킬 수 있습니다.

NFSv4.1에는 pNFS라고 하는 병렬 액세스\(섹션 1.8.2.2 참조\)가 도입되었습니다. 이 섹션에서 설명하는 보안 프레임워크는 pNFS\(섹션 12.9 참조\)의 도입으로 크게 수정되었습니다. 왜냐하면 데이터 액세스가 RPC를 통하지 않는 경우가 있기 때문입니다. 유의성 수준은 저장 프로토콜\(섹션 12.2.5 참조\)에 따라 다르며 영향이 전혀 없을 정도로 낮을 수 있습니다\(섹션 13.12 참조\).

---
#### **1.8.2.  Protocol Structure**
---
##### **1.8.2.1.  Core Protocol**

일련의 보조 프로토콜\(예: NLM, NSM\(네트워크 상태 모니터\), MOUNT\)을 사용하는 NFSv3와 달리 NFSv4의 모든 마이너 버전에서는 단일 RPC 프로토콜을 사용하여 서버에 요청합니다. 잠금 등 별도의 프로토콜이었던 시설이 이제는 하나의 통합 프로토콜로 통합되었습니다.

---
##### **1.8.2.2.  Parallel Access**

마이너 버전 1은 메타데이터 액세스와 데이터 액세스를 분리하여 클러스터된 서버 구현에 대한 고성능 데이터 액세스를 지원하며, 후자는 여러 서버에 병렬로 수행됩니다.

이러한 병렬 데이터 액세스는 프로토콜 잠금 모델에 통합된 "레이아웃"이라는 호출 가능한 개체에 의해 제어됩니다. 클라이언트는 NFSv4.1이거나 다른 프로토콜일 수 있는 데이터 저장 프로토콜을 통해 레이아웃에 지정된 데이터 서버 세트에 대한 데이터 액세스 요청을 보냅니다.

병렬 데이터 액세스에 사용되는 프로토콜이 반드시 RPC 기반일 필요는 없으므로 RPC 기반 보안 모델\(섹션 1.8.1\)이 분명히 영향을 받습니다\(섹션 12.9 참조\). 영향의 정도는 데이터 액세스에 사용되는 저장 프로토콜\(섹션 12.2.5 참조\)에 따라 다르며 0까지 낮을 수 있습니다\(섹션 13.12 참조\).

---
#### **1.8.3.  File System Model**

NFSv4.1 프로토콜에 사용되는 일반 파일 시스템 모델은 이전 버전과 동일합니다. 서버 파일 시스템은 내부에 포함된 일반 파일이 불투명 바이트 스트림으로 처리되는 계층 구조입니다. 약간 다른 점은 파일 및 디렉터리 이름이 국제화의 기본 사항을 처리하기 위해 UTF-8로 인코딩된다는 점입니다.

NFSv4.1 프로토콜은 경로 이름과 파일 핸들 간의 초기 매핑을 제공하기 위해 별도의 프로토콜이 필요하지 않습니다. 서버에서 내보낸 모든 파일 시스템은 트리로 표시되므로 특별한 서버별 전역 루트 파일 핸들에서 모든 파일 시스템에 접근할 수 있습니다. 이를 통해 LOOKUP 작업을 사용하여 이전에 MOUNT 프로토콜에서 제공한 기능을 수행할 수 있습니다. 서버는 내보낸 파일 시스템 간의 내보내지 않은 간격으로 인해 발생하는 간격을 연결하는 데 필요한 의사 파일 시스템을 제공합니다.

---
##### **1.8.3.1.  Filehandles**

이전 버전의 NFS 프로토콜과 마찬가지로 불투명 파일 핸들은 개별 파일과 디렉터리를 식별하는 데 사용됩니다. 조회 유형 및 생성 작업은 파일 및 디렉터리 이름을 파일 핸들로 변환한 후 후속 작업에서 개체를 식별하는 데 사용됩니다.

NFSv4.1 프로토콜은 지정된 파일 시스템 객체의 수명 동안 유효함을 보장하는 영구 파일 핸들에 대한 지원을 제공합니다. 또한 휘발성 파일 핸들이라고 하는 보다 제한적인 유효성 보장을 갖춘 파일 핸들을 제공하기 위해 서버를 지원합니다.

---
##### **1.8.3.2.  File Attributes**

NFSv4.1 프로토콜에는 REQUIRED, RECOMMENDED 및 명명된 속성으로 구분되는 풍부하고 확장 가능한 파일 객체 속성 구조가 있습니다\(섹션 5 참조\).\(MUST\)

필수 속성 중 일부\(전부는 아님\)는 NFSv3의 속성에서 파생됩니다\(\[38\]의 fattr3 데이터 유형 정의 참조\). REQUIRED 속성의 예로는 일반 파일을 디렉터리\(일부 운영 환경에서는 폴더라고도 함\) 및 기타 유형의 개체와 구별할 수 있도록 하는 파일 개체 유형\(섹션 5.8.1.2\)이 있습니다. 필수 속성은 섹션 5.1에서 논의됩니다.\(MUST, MUST, MUST\)

세 가지 RECOMMENDED 속성의 예로는 acl, sacl 및 dacl이 있습니다. 이러한 속성은 파일 객체에 대한 액세스 제어 목록\(ACL\)을 정의합니다\(섹션 6\). ACL은 NFSv3에서 사용되는 모델 이상의 디렉터리 및 파일 액세스 제어를 제공합니다. ACL 정의를 사용하면 개별 사용자 및 그룹에 대한 특정 권한 집합을 지정할 수 있습니다. 또한 ACL 상속을 통해 파일 시스템 개체가 생성될 때 액세스 권한 및 제한 사항이 디렉터리 트리 아래로 전파될 수 있습니다. RECOMMENDED 속성은 섹션 5.2에서 논의됩니다.\(SHOULD, SHOULD\)

명명된 속성은 디렉터리나 파일과 연결되고 문자열 이름으로 참조되는 불투명 바이트 스트림입니다. 명명된 속성은 클라이언트 응용 프로그램에서 응용 프로그램별 데이터를 일반 파일이나 디렉터리와 연결하는 방법으로 사용하기 위한 것입니다. NFSv4.1은 상호 운용이 불가능한 구현의 개발을 방지하기 위해 허용된 작업을 강화하여 NFSv4.0과 관련된 명명된 속성을 수정합니다. 명명된 속성은 섹션 5.3에서 논의됩니다.

---
##### **1.8.3.3.  Multi-Server Namespace**

NFSv4.1에는 서버 경계를 넘나들고 서버 간 개별 파일 시스템에 대한 지원을 중단 없이 전송할 수 있는 네임스페이스 구현을 허용하는 다양한 기능이 포함되어 있습니다. 이는 모두 하나의 파일 시스템이 클라이언트가 해당 파일 시스템에 액세스하는 방법을 지정하는 대체, 추가 및 새 위치 정보를 지정할 수 있도록 하는 속성을 기반으로 합니다.

이러한 속성은 개별 활성 파일 시스템을 제공하는 데 사용될 수 있습니다.

\* 현재 파일 시스템 인스턴스에 액세스하기 위한 대체 네트워크 주소입니다.

\* 현재 파일 시스템 인스턴스를 사용할 수 없게 되는 경우 사용할 대체 파일 시스템 인스턴스 또는 복제본의 위치입니다.

이러한 파일 시스템 위치 속성은 현재 서버에 해당 파일 시스템 인스턴스가 없는 상태에서 서버 네임스페이스의 위치가 다른 서버의 위치와 연결되는 부재 파일 시스템 개념과 함께 사용될 수 있습니다. 예를 들어,

\* 이러한 속성은 파일 시스템이 없는 경우 한 서버가 클라이언트를 다른 서버가 제공하는 파일 시스템으로 안내할 수 있는 참조를 구현하는 데 사용될 수 있습니다. 이를 통해 광범위한 다중 서버 네임스페이스를 구성할 수 있습니다.

\* 이러한 속성은 이전에 존재했던 파일 시스템이 없을 때 제공될 수 있습니다. 이를 통해 파일 시스템을 대체 서버로 중단 없이 마이그레이션할 수 있습니다.

---
#### **1.8.4.  Locking Facilities**

앞서 언급했듯이 NFSv4.1은 잠금 기능을 포함하는 단일 프로토콜입니다. 이러한 잠금 기능에는 다양한 유형의 호출 가능한 잠금을 포함하여 다양한 유형의 잠금에 대한 지원이 포함됩니다. 위임과 같은 호출 가능한 잠금을 사용하면 해당 잠금이 유지되는 동안 특정 이벤트가 발생하지 않는다는 것을 클라이언트가 확신할 수 있습니다. 상황이 바뀌면 콜백 요청을 통해 잠금이 회수됩니다. 위임이 제공하는 보증을 통해 상황이 허용하는 경우 보다 광범위한 캐싱을 안전하게 수행할 수 있습니다.

잠금 유형은 다음과 같습니다.

\* OPEN 작업을 통해 설정된 공유 예약입니다.

```text
   *  Byte-range locks.
```

\* 파일 위임은 위임이 유지되는 동안 일관되지 않은 열기 및 파일 변경이 발생할 수 없음을 소유자에게 보장하는 회수 가능한 잠금 장치입니다.

\* 디렉터리 위임은 위임이 유지되는 동안 일관성 없는 디렉터리 수정이 발생할 수 없음을 소유자에게 보장하는 회수 가능한 잠금 장치입니다.

\* 파일 데이터에 대한 직접 액세스가 클라이언트에 의해 직접 수행될 수 있으며 해당 액세스와 일치하지 않는 데이터 위치에 대한 변경이 레이아웃이 유지되는 동안 이루어질 수 없음을 소유자에게 보장하는 호출 가능한 객체인 레이아웃.

특정 클라이언트에 대한 모든 잠금은 단일 클라이언트 전체 임대에 따라 함께 연결됩니다. 클라이언트와 연결된 세션에 대한 모든 요청은 해당 임대를 갱신합니다. 클라이언트의 임대가 즉시 갱신되지 않으면 클라이언트의 잠금이 취소될 수 있습니다. 서버가 다시 시작되는 경우 클라이언트는 특별 유예 기간 내에 잠금을 안전하게 회수할 수 있습니다.

---
### **1.9.  Differences from NFSv4.0**

다음은 마이너 버전 1과 기본 프로토콜 간의 주요 차이점을 요약한 것입니다.

\* 세션 모델 구현\(섹션 2.10\).

\* 데이터에 대한 병렬 액세스\(섹션 12\).

\* 잠금 회수 프로세스를 더 효과적으로 구성하기 위해 RECLAIM\_COMPLETE 작업을 추가했습니다\(18.51절\).

\* 위임 지원이 다음과 같이 강화되었습니다.

- - 일반 파일 외에 디렉터리 및 기타 파일 형식에 대한 위임\(18.39절, 18.49절\).

- - 회수 또는 거부된 위임 획득을 최적화하기 위한 작업\(18.49항, 20.5항, 20.7항\).

- 파일 및 디렉터리 변경 알림

- \(18.39항, 20.4항\).

- - 서버가 리소스 관리상의 이유로 하나 이상의 위임을 회수하고 있음을 나타낼 수 있도록 하는 방법과 클라이언트가 반환할 위임을 선택할 수 있는 방법\(20.6절\).

\* OPEN 작업을 통해 독점 파일을 생성하는 동안 속성을 원자적으로 설정할 수 있습니다\(섹션 18.16의 새로운 EXCLUSIVE4\_1 생성 방법 참조\).

\* 제거된 파일은 보존될 수 있으며 하드 링크 수\("하드 링크"는 Open Group \[6\] 표준에 정의됨\)가 0이 되어 클라이언트가 삭제된 파일의 이름을 부분적으로 숨겨진 이름으로 바꿀 필요가 없습니다. "어리석은 이름 바꾸기"라고 합니다\(섹션 18.16의 새로운 OPEN4\_RESULT\_PRESERVE\_UNLINKED 응답 플래그 참조\).

\* 액세스 제어 목록에 대한 Microsoft Windows와의 호환성이 향상되었습니다\(섹션 6.2.3, 섹션 6.2.2, 섹션 6.4.3.2\).

```text
   *  Data retention (Section 5.13).
```

\* NFS 클라이언트 및 서버 구현 식별\(18.35절\)

\* 바이트 범위 잠금의 가용성 알림 지원\(섹션 18.16의 새로운 OPEN4\_RESULT\_MAY\_NOTIFY\_LOCK 응답 플래그 및 섹션 20.11 참조\).\(MAY\)

\* NFSv4.1에서는 LIPKEY와 SPKM-3이 필수 보안 메커니즘이 아니다\[39\].

---
## **2.  Core Infrastructure**
---
### **2.1.  Introduction**

NFSv4.1은 거의 모든 작업에 공통적인 핵심 인프라를 사용합니다. 이 핵심 인프라는 이 섹션의 나머지 부분에서 설명됩니다.

---
### **2.2.  RPC and XDR**

NFSv4.1 프로토콜은 \[3\]과 \[2\]에 정의된 대로 RPC 버전 2와 해당 XDR\(eXternal Data Representation\)을 사용하는 RPC\(원격 프로시저 호출\) 애플리케이션입니다.

---
#### **2.2.1.  RPC-Based Security**

이전 NFS 버전은 NFS 서버가 NFS 클라이언트를 인증하고 클라이언트가 모든 사용자를 인증하도록 신뢰하는 호스트 기반 인증 모델을 사용하는 것으로 간주되었습니다. 실제로 NFS는 인증을 위해 항상 RPC에 의존해 왔습니다. RPC 인증의 첫 번째 형태 중 하나인 AUTH\_SYS에는 강력한 인증이 없으며 호스트 기반 인증 접근 방식이 필요했습니다. NFSv4.1은 또한 기본 보안 서비스를 위해 RPC에 의존하며 사용자 기반 인증 모델에 대해 RPC 지원을 요구합니다. 사용자 기반 인증 모델에는 서버에 의해 인증된 사용자 주체가 있고, 차례로 사용자 주체에 의해 인증된 서버가 있습니다. RPC는 NFSv4.1에서 사용되는 몇 가지 기본 보안 서비스를 제공합니다.

---
##### **2.2.1.1.  RPC Security Flavors**

\[3\]의 섹션 7의 "인증"에 설명된 대로 RPC 보안은 보안 또는 인증 플레이버와 지정된 보안 플레이버에 특정한 정보를 통해 RPC 헤더에 캡슐화됩니다. 모든 RPC 헤더는 클라이언트와 서버를 식별하고 인증하는 데 사용되는 정보를 전달합니다. 섹션 2.2.1.1.1에서 설명한 대로 일부 보안 유형은 추가 보안 서비스를 제공합니다.

NFSv4.1 클라이언트와 서버는 RPCSEC\_GSS를 구현해야 합니다. \(이 구현 요구 사항은 사용 요구 사항이 아닙니다.\) AUTH\_NONE 및 AUTH\_SYS와 같은 다른 버전도 구현할 수 있습니다.\(MUST, MAY\)

---
###### **2.2.1.1.1.  RPCSEC_GSS and Security Services**

RPCSEC\_GSS\[4\]는 GSS-API\[7\]의 기능을 사용합니다. 이를 통해 RPC 보안 기능을 추가하는 추가 구현 오버헤드 없이 RPC 계층에서 다양한 보안 메커니즘을 사용할 수 있습니다.

---
####### **2.2.1.1.1.1.  Identification, Authentication, Integrity, Privacy**

GSS-API를 통해 RPCSEC\_GSS는 클라이언트에서 서버로, 서버에서 사용자로 사용자를 식별하고 인증하는 데 사용할 수 있습니다. 또한 RPC 헤더를 포함한 전체 RPC 메시지와 인수 또는 결과에 대해 무결성 검사를 수행할 수도 있습니다. 마지막으로 일반적으로 암호화를 통한 개인 정보 보호는 RPCSEC\_GSS를 통해 제공되는 서비스입니다. 개인정보 보호는 인수 및 결과에 대해 수행됩니다. 개인 정보 보호를 선택하면 무결성, 인증 및 식별이 활성화됩니다. 개인정보 보호를 선택하지 않고 무결성을 선택한 경우 인증 및 식별이 활성화됩니다. 무결성 및 개인정보 보호를 선택하지 않았지만 인증이 활성화된 경우 식별이 활성화됩니다. RPCSEC\_GSS는 별도의 서비스로 식별정보를 제공하지 않습니다.

GSS-API에는 개인 정보 보호 및 무결성 서비스와는 다른 인증 서비스가 있지만 GSS-API의 인증 서비스는 RPCSEC\_GSS의 인증 서비스에 사용되지 않습니다. 대신, 각 RPC 요청 및 응답 헤더는 GSS-API 무결성 서비스로 무결성 보호되며, 이를 통해 RPCSEC\_GSS는 RPC별 인증 및 ID를 제공할 수 있습니다. 자세한 내용은 \[4\]를 참조하세요.

NFSv4.1 클라이언트와 서버는 RPCSEC\_GSS의 무결성 및 인증 서비스를 지원해야 합니다. NFSv4.1 서버는 RPCSEC\_GSS의 개인 정보 보호 서비스를 지원해야 합니다. NFSv4.1 클라이언트는 RPCSEC\_GSS의 개인 정보 보호 서비스를 지원해야 합니다.\(MUST, MUST, SHOULD\)

---
####### **2.2.1.1.1.2.  Security Mechanisms for NFSv4.1**

RPCSEC\_GSS는 GSS-API를 통해 보안 서비스를 제공하는 메커니즘에 대한 액세스를 표준화합니다. 따라서 NFSv4.1 클라이언트와 서버는 Kerberos V5 보안 메커니즘을 지원해야 합니다.\(MUST\)

RPCSEC\_GSS를 사용하려면 메커니즘, QOP\(보호 품질\) 및 서비스\(인증, 무결성, 개인 정보 보호\)를 선택해야 합니다. 필수 보안 메커니즘의 경우 NFSv4.1은 QOP 0이 사용되도록 지정하고 QOP 0을 적절한 보호 수준에 매핑하는 것은 메커니즘 또는 메커니즘의 구성에 달려 있습니다. 각 필수 메커니즘은 무결성 및 개인정보 보호를 구현하기 위한 최소 암호화 알고리즘 세트를 지정합니다. NFSv4.1 클라이언트와 서버는 각 필수 메커니즘의 필수 암호화 알고리즘을 준수하는 운영 환경에서 구현되어야 합니다.\(MUST\)

---
######## **2.2.1.1.1.2.1.  Kerberos V5**

\[5\]에 설명된 Kerberos V5 GSS-API 메커니즘은 다음 표에 지정된 RPCSEC\_GSS 서비스로 구현되어야 합니다.\(MUST\)

열 설명:

- 1 == 유사 플레이버 수 2 == 유사 플레이버 이름 3 == 메커니즘의 OID 4 == RPCSEC\_GSS 서비스 5 == NFSv4.1 클라이언트는 반드시 지원해야 함 6 == NFSv4.1 서버는 반드시 지원해야 함\(MUST\)

```text
      1      2        3                    4                     5   6
      ------------------------------------------------------------------
      390003 krb5     1.2.840.113554.1.2.2 rpc_gss_svc_none      yes yes
      390004 krb5i    1.2.840.113554.1.2.2 rpc_gss_svc_integrity yes yes
      390005 krb5p    1.2.840.113554.1.2.2 rpc_gss_svc_privacy    no yes
```

의사 플레이버의 번호와 이름은 구현자에 대한 매핑 보조 수단으로 여기에 표시됩니다. NFSv4.1 프로토콜에는 보안 협상 방법이 포함되어 있고 GSS-API 메커니즘을 이해하므로 의사 플레이버가 필요하지 않습니다. \[40\]에 설명된 대로 보안 협상이 MOUNT 프로토콜을 통해 수행되므로 NFSv3에는 의사 플레이버가 필요합니다.

NFSv4.1이 지정되었을 때 HMAC-SHA1을 사용한 AES\(Advanced Encryption Standard\)는 Kerberos V5에 대해 필수 알고리즘 세트였습니다. 대조적으로 NFSv4.0이 지정되면 Kerberos V5에는 더 약한 알고리즘 세트가 필수이고 NFSv4.0 사양에서는 필수였습니다. 그 이유는 당시 Kerberos V5 사양이 더 강력한 알고리즘을 지정하지 않았기 때문입니다. NFSv4.1 사양은 Kerberos V5에 대한 필수 알고리즘을 지정하지 않으며 대신 더 강력한 알고리즘이 지정된 경우 구현자는 Kerberos V5 표준의 발전을 추적할 것으로 예상됩니다.\(MUST, MUST, MUST\)

2.2.1.1.1.2.1.1. Kerberos V5의 암호화 알고리즘에 대한 보안 고려 사항

NFSv4.1을 배포할 때 달성되는 보안 강도는 기존 Kerberos V5 인프라에 따라 달라집니다. Kerberos V5의 알고리즘은 클라이언트 또는 서버에 직접 노출되거나 선택 가능하지 않으므로 NFSv4.1 사용자는 필요한 경우 보안이 허용되는지 확인하기 위해 몇 가지 실사를 수행해야 합니다.

---
####### **2.2.1.1.1.3.  GSS Server Principal**

RPCSEC\_GSS에서 사용되는 보안 메커니즘에 관계없이 NFS 서버는 GSS\_C\_NT\_HOSTBASED\_SERVICE 이름 유형을 통해 GSS-API에서 자신을 식별해야 합니다. GSS\_C\_NT\_HOSTBASED\_SERVICE 이름의 형식은 다음과 같습니다.\(MUST\)

```text
        service@hostname
```

NFS의 경우 "service" 요소는 다음과 같습니다.

```text
        nfs
```

보안 메커니즘을 구현하면 nfs@hostname을 다양한 형식으로 변환합니다. Kerberos V5의 경우 다음 형식이 권장됩니다.\(SHOULD\)

```text
        nfs/hostname
```

---
### **2.3.  COMPOUND and CB_COMPOUND**

NFSv4 이전 NFS 프로토콜 버전과 크게 다른 점은 COMPOUND 프로시저가 도입되었다는 점입니다. NFSv4 프로토콜의 경우 모든 마이너 버전에는 정확히 두 개의 RPC 프로시저\(NULL 및 COMPOUND\)가 있습니다. COMPOUND 프로시저는 일련의 개별 작업으로 정의되며 이러한 작업은 기존 NFS 프로시저에서 수행되는 일종의 기능을 수행합니다.

COMPOUND 요청 내에서 결합된 작업은 원자성을 보장하지 않고 서버에 의해 순서대로 평가됩니다. 한 작업에서 다른 작업으로 결과를 전달하기 위한 제한된 기능 세트가 존재합니다. 작업이 실패한 결과를 반환하면 평가가 종료되고 평가된 모든 작업의 ​​결과가 클라이언트에 반환됩니다.

COMPOUND 프로시저를 사용하면 클라이언트는 단순하거나 복잡한 요청을 작성할 수 있습니다. 이러한 COMPOUND 요청을 사용하면 논리적 파일 시스템 작업에 필요한 RPC 수를 줄일 수 있습니다. 예를 들어, 여러 LOOKUP 작업을 결합하여 다중 구성 요소 조회 요청을 구성할 수 있습니다. 이러한 작업은 GETATTR, READDIR 또는 OPEN + READ와 같은 작업과 추가로 결합되어 추가 대기 시간 없이 더 복잡한 작업 세트를 수행할 수 있습니다.

NFSv4.1에는 서버가 클라이언트를 향한 RPC를 만드는 상당한 콜백 작업 세트도 포함되어 있습니다. 콜백 RPC는 일반 서버 요청과 유사한 구조를 가지고 있습니다. NFSv4 프로토콜의 모든 마이너 버전에는 두 개의 콜백 RPC 프로시저\(CB\_NULL 및 CB\_COMPOUND\)가 있습니다. CB\_COMPOUND 프로시저는 자체 콜백 작업 세트를 사용하여 COMPOUND 프로시저와 유사한 방식으로 정의됩니다.

COMPOUND 및 CB\_COMPOUND 요청 프레임워크 내에 새로운 서버 및 콜백 작업을 추가하면 후속 마이너 버전에서 프로토콜을 확장할 수 있는 수단이 제공됩니다.

세션 생성에 필요한 소수의 작업을 제외하고 서버 요청 및 콜백 요청은 세션 컨텍스트 내에서 수행됩니다. 세션은 모든 요청에 ​​대해 클라이언트 컨텍스트를 제공하고 멱등성이 아닌 요청에 대한 강력한 재생 보호를 지원합니다.

---
### **2.4.  Client Identifiers and Client Owners**

잠금 상태를 얻거나 잠금 상태에 의존하는 각 작업에 대해 서버는 특정 클라이언트를 식별할 수 있어야 합니다.

각각의 고유한 클라이언트 인스턴스는 클라이언트 ID로 표시됩니다. 클라이언트 ID는 주어진 시간에 특정 클라이언트를 나타내는 64비트 식별자입니다. 클라이언트 ID는 클라이언트가 다시 초기화될 때마다 변경되며, 서버가 다시 초기화되면 변경될 수 있습니다. 클라이언트 ID는 잠금 식별 및 충돌 복구를 지원하는 데 사용됩니다.

안정된 상태 작업 중에 각 작업과 관련된 클라이언트 ID는 작업이 전송되는 세션\(섹션 2.10 참조\)에서 파생됩니다. 세션이 생성될 때 세션은 클라이언트 ID와 연결됩니다.

NFSv4.0과 달리 클라이언트 ID가 설정되기 전에 가능한 유일한 NFSv4.1 작업은 클라이언트 ID를 설정하는 데 필요한 작업입니다.

서버에서 클라이언트 ID를 설정하고 확인하려면 해당 클라이언트 ID\(EXCHANGE\_ID에서 반환된 eir\_clientid\)를 사용하는 CREATE\_SESSION 작업이 뒤따르는 EXCHANGE\_ID 작업 시퀀스가 ​​필요합니다. 클라이언트의 새로운 구현에 의한 식별 설정은 동일한 클라이언트의 이전 구현이 서버에서 가졌을 수 있는 모든 잠금 상태를 즉시 해제하는 효과도 있습니다. 이러한 해제 상태에는 모든 바이트 범위 잠금, 공유 예약, 레이아웃 상태 및 서버가 CLAIM\_DELEGATE\_PREV 또는 CLAIM\_DELEG\_CUR\_FH 클레임 유형을 지원하지 않는 경우 동일한 ID를 가진 동일한 클라이언트와 연결된 모든 위임 상태가 포함됩니다. 위임 상태 복구에 대한 논의는 섹션 10.2.1을 참조하세요. 레이아웃 상태 복구에 대한 논의는 섹션 12.7.1을 참조하세요.

이러한 상태를 해제하려면 서버가 한 클라이언트 인스턴스가 다른 클라이언트 인스턴스의 후속 인스턴스인지 확인할 수 있어야 합니다. 여러 가지 이유로 이를 수행할 수 없는 경우 잠금 상태는 임대 만료\(섹션 8.3 참조\)에 따라 한동안 유지되며 충돌이 발생하는 경우 새 클라이언트는 해당 상태가 제거될 때까지 기다려야 합니다. 잠금 요청.

클라이언트 식별은 다음 클라이언트 소유자 데이터 유형으로 캡슐화됩니다.

```text
   struct client_owner4 {
           verifier4       co_verifier;
           opaque          co_ownerid<NFS4_OPAQUE_LIMIT>;
   };
```

첫 번째 필드인 co\_verifier는 클라이언트 구현 검증기로서 서버가 동일한 클라이언트의 연속적인 구현\(예: 재부팅\)을 구별할 수 있게 해줍니다. co\_verifier가 식별된 클라이언트에 대해 서버가 이전에 기록한 것과 다른 경우\(co\_ownerid 필드에 지정된 대로\) 서버는 클라이언트의 임대 상태를 취소하는 프로세스를 시작합니다.

두 번째 필드인 co\_ownerid는 동일한 클라이언트의 후속 인스턴스가 다른 검증자와 동일한 co\_ownerid를 갖도록 클라이언트를 고유하게 정의하는 가변 길이 문자열입니다.

클라이언트가 co\_ownerid 문자열을 생성하는 방법에 대해 몇 가지 고려 사항이 있습니다.

\* 문자열은 여러 클라이언트가 동일한 문자열을 제공하지 않도록 고유해야 합니다. 동일한 문자열 범위를 제공하는 두 클라이언트의 결과는 한 클라이언트에서 오류가 발생하고 임대 상태가 갑자기 취소된 한 클라이언트까지 발생합니다.

\* 동일한 클라이언트의 후속 구현\(예: 재시작\)으로 인해 클라이언트가 동일한 문자열을 제공하도록 문자열을 선택해야 합니다. 구현자는 로컬 파일에 문자열을 기록해야 하는 접근 방식에 주의해야 합니다. 이는 로컬 디스크가 없고 모든 파일 액세스가 NFSv4.1 서버에서 이루어지는 환경에서 구현을 사용할 수 없기 때문입니다.

\* 문자열은 클라이언트가 접속하는 각 서버 네트워크 주소에 대해 동일해야 합니다. 이렇게 하면 서버에 여러 인터페이스가 있는 경우 클라이언트는 섹션 2.10.5에 설명된 대로 여러 네트워크 경로를 통해 트래픽을 트렁크할 수 있습니다. \(참고: NFSv4.0 사양\[37\]에서는 정반대의 내용이 권장되었습니다.\)

\* 문자열을 생성하는 알고리즘은 클라이언트 구현이 정적으로 할당된 네트워크 주소를 사용하고 있다는 것을 알지 않는 한 클라이언트의 네트워크 주소가 변경되지 않을 것이라고 가정해서는 안 됩니다. 여기에는 클라이언트 구현 간의 변경 사항과 클라이언트가 현재 구현에서 계속 실행되는 동안의 변경 사항도 포함됩니다. 따라서 동적 주소 할당을 사용하면 클라이언트가 co\_ownerid 문자열에 클라이언트의 네트워크 주소만 포함하는 경우 클라이언트가 네트워크 주소를 포기한 후 co\_ownerid 문자열을 생성하기 위해 유사한 알고리즘을 사용하는 다른 클라이언트가 충돌하는 co\_ownerid 문자열을 생성합니다.

위의 고려 사항을 고려하여 잘 생성된 co\_ownerid 문자열의 예는 다음을 포함합니다.

\* 해당되는 경우 클라이언트의 정적으로 할당된 네트워크 주소입니다.

\* 다음 중 하나 이상과 같이 고유한 경향이 있는 추가 정보:

- - 클라이언트 시스템의 일련 번호\(개인 정보 보호를 위해 일련 번호에 대해 단방향 기능을 수행하는 것이 가장 좋습니다\).

- - MAC\(Media Access Control\) 주소\(역시 단방향 기능이 수행되어야 함\).

- - NFSv4.1 소프트웨어가 클라이언트에 처음 설치되었을 때의 타임스탬프\(단, 파일은 NFSv4.1을 통해서만 액세스할 수 있으므로 파일에 저장된 정보 사용에 대해 앞서 언급한 주의 사항이 적용됩니다\).

- - 실제 난수입니다. 그러나 이 숫자는 클라이언트 구현 간에 동일해야 하므로 이는 소프트웨어 설치의 타임스탬프를 사용하는 것과 동일한 문제를 공유합니다.

\* 사용자 수준 NFSv4.1 클라이언트의 경우 프로세스 식별자 또는 기타 고유 시퀀스와 같이 클라이언트를 동일한 호스트에서 실행 중인 다른 사용자 수준 클라이언트와 구별하기 위한 추가 정보를 포함해야 합니다.

클라이언트 ID는 서버에서 할당되며\(EXCHANGE\_ID의 eir\_clientid 결과\) 서버에서 이전에 할당한 클라이언트 ID와 충돌하지 않도록 선택해야 합니다. 이는 서버를 다시 시작할 때마다 적용됩니다.

서버가 다시 시작되는 경우 클라이언트는 NFS4ERR\_STALE\_CLIENTID 오류를 수신하면 현재 클라이언트 ID가 더 이상 유효하지 않다는 것을 알 수 있습니다. 정확한 상황은 관련된 세션의 특성, 특히 세션이 지속되는지 여부\(섹션 2.10.6.5 참조\)에 따라 다르지만, 각 경우 클라이언트는 기존 클라이언트 ID를 사용하여 새 세션을 설정하려고 시도할 때 이 오류를 수신하게 됩니다. NFS4ERR\_STALE\_CLIENTID 오류를 수신합니다. 이는 EXCHANGE\_ID를 통해 새 클라이언트 ID를 가져와야 하며 해당 클라이언트 ID로 새 세션을 설정해야 함을 나타냅니다.

세션이 지속되지 않으면 클라이언트는 NFS4ERR\_BADSESSION을 얻은 결과 새 세션을 생성해야 한다는 것을 알게 됩니다. 문제의 세션이 서버 재시작의 일부로 손실되었기 때문입니다. 세션 생성의 일부로 기존 클라이언트 ID가 서버에 제공되고 해당 클라이언트 ID가 인식되지 않으면 서버를 다시 시작한 후 서버가 NFS4ERR\_STALE\_CLIENTID 오류와 함께 요청을 거부합니다.

세션이 지속되는 경우 클라이언트는 다시 시작한 후 기존 세션을 사용하여 통신을 다시 설정합니다. 이 세션은 기존 클라이언트 ID와 연결되지만 클라이언트가 이전에 전송했지만 응답을 보지 못한 작업을 재전송하는 데에만 사용할 수 있습니다. 서버가 이전에 수행한 작업에 대한 응답은 응답 캐시에서 나옵니다. 그렇지 않으면 NFS4ERR\_DEADSESSION이 반환됩니다. 따라서 이러한 세션을 "죽은" 세션이라고 합니다. 이 상황에서 새로운 작업을 수행하려면 클라이언트가 새 세션을 설정해야 합니다. 기존 클라이언트 ID를 사용하여 이 새 세션을 설정하려고 하면 서버는 NFS4ERR\_STALE\_CLIENTID를 사용한 요청을 거부합니다.

이러한 상황 중 하나에서 NFS4ERR\_STALE\_CLIENTID가 수신되면 클라이언트는 EXCHANGE\_ID 작업을 사용하여 새 클라이언트 ID를 얻은 다음 해당 클라이언트 ID를 새 세션의 기초로 사용한 다음 서버에 필요한 기타 복구를 진행해야 합니다. 케이스를 다시 시작합니다\(섹션 8.4.2 참조\).

이러한 작업에 대한 전체 사양은 EXCHANGE\_ID\(섹션 18.35\) 및 CREATE\_SESSION\(섹션 18.36\)에 대한 설명을 참조하세요.

---
#### **2.4.1.  Upgrade from NFSv4.0 to NFSv4.1**

NFSv4.0에서 NFSv4.1로의 업그레이드를 용이하게 하기 위해 서버는 EXCHANGE\_ID의 client\_owner4 데이터 유형 값을 NFSv4.0의 SETCLIENTID 작업을 사용하여 설정된 nfs\_client\_id4 데이터 유형 값과 비교할 수 있습니다. 이를 수행하는 서버는 업그레이드된 클라이언트가 임대\(즉, NFSv4.0 인스턴스 클라이언트에 의해 설정된 임대\)가 만료될 때까지 기다리지 않도록 허용합니다. 이를 위해서는 데이터 유형 client\_owner4의 값이 nfs\_client\_id4 데이터 유형의 값과 동일한 방식으로 구성되어야 합니다. 후자의 내용에 서버의 네트워크 주소가 포함되어 있고\(NFSv4.0 사양 \[37\]의 권장 사항에 따라\) NFSv4.1 클라이언트가 트렁킹을 방지하는 클라이언트 ID를 사용하지 않으려면 두 개의 EXCHANGE\_ID 작업을 보내야 합니다. 첫 번째 EXCHANGE\_ID는 nfs\_client\_id4와 동일한 client\_owner4를 갖습니다. 이렇게 하면 NFSv4.0 클라이언트에서 생성된 상태가 지워집니다. 두 번째 EXCHANGE\_ID에는 서버의 네트워크 주소가 없습니다. 두 번째 EXCHANGE\_ID에 대해 생성된 상태는 만료될 상태가 없기 때문에 임대 만료를 기다릴 필요가 없습니다.

---
#### **2.4.2.  Server Release of Client ID**

NFSv4.1에는 클라이언트가 더 이상 필요하지 않은 클라이언트 ID를 삭제하는 데 사용해야 하는 DESTROY\_CLIENTID\(섹션 18.50\)라는 새로운 작업이 도입되었습니다. 이를 통해 클라이언트 ID의 원활한 양방향 릴리스가 가능해집니다. 클라이언트 ID와 연결된 세션이 있거나 임대가 만료되지 않은 상태인 경우 작업을 사용할 수 없습니다.\(SHOULD\)

서버가 클라이언트가 클라이언트 ID에 대해 연결된 상태를 보유하지 않는다고 판단하는 경우\(연결된 상태에는 취소되지 않은 세션, 열기, 잠금, 위임, 레이아웃 및 원하는 것이 포함됨\) 서버는 리소스를 절약하기 위해 클라이언트 ID를 일방적으로 해제하도록 선택할 수 있습니다. 이 릴리스 이후에 클라이언트가 서버에 접속하는 경우 서버는 클라이언트가 적절한 오류를 수신하여 EXCHANGE\_ID/CREATE\_SESSION 시퀀스를 사용하여 새 클라이언트 ID를 설정하도록 해야 합니다. 서버는 클라이언트 ID를 공개하는 것을 매우 주저해야 합니다. 왜냐하면 이러한 이벤트로부터 클라이언트를 복구하기 위한 클라이언트의 작업 결과는 서버가 실패하고 다시 시작된 것과 동일한 부담이 되기 때문입니다. 일반적으로 서버는 해당 클라이언트에서 몇 분 동안 활동이 없으면 클라이언트 ID를 해제하지 않습니다. 세션, 열기, 잠금, 위임, 레이아웃 또는 원하는 사항이 있는 한 서버는 클라이언트 ID를 공개해서는 안 됩니다. 비활성 세션 해제에 대한 논의는 섹션 2.10.13.1.4를 참조하십시오.\(MAY, MUST, MUST NOT\)

---
#### **2.4.3.  Resolving Client Owner Conflicts**

서버가 현재 상태가 없거나 상태가 있지만 임대가 만료된 클라이언트 소유자에 대해 EXCHANGE\_ID를 얻는 경우 서버는 EXCHANGE\_ID를 허용하고 적절한 CREATE\_SESSION이 뒤따르는 경우 새 클라이언트 ID를 확인해야 합니다.\(MUST\)

서버가 현재 상태가 있는 이전 구현 및 만료되지 않은 임대를 갖고 있는 클라이언트 소유자의 새로운 구현에 대한 EXCHANGE\_ID를 얻을 때 다음 중 하나에 해당하는 경우 서버는 클라이언트 소유자의 이전 구현 상태를 삭제할 수 있습니다. 진실:

\* 클라이언트 소유자의 클라이언트 ID를 생성한 주체는 EXCHANGE\_ID 작업을 보내는 주체와 동일합니다. 클라이언트 ID가 SP4\_MACH\_CRED 상태 보호\(섹션 18.35\)로 생성된 경우 주체는 RPCSEC\_GSS 인증을 기반으로 해야 하며, 사용된 RPCSEC\_GSS 서비스는 무결성 또는 개인 정보 보호여야 하며, 동일한 GSS 메커니즘과 주체를 사용해야 합니다. 클라이언트 ID가 생성되었습니다.\(MUST\)

\* 클라이언트 ID는 SP4\_SSV 보호로 설정되었습니다.

- \(섹션 18.35, 섹션 2.10.8.3\) 클라이언트는 GSS SSV 메커니즘\(섹션 2.10.9\)을 사용하여 보안 특성이 RPCSEC\_GSS로 설정된 EXCHANGE\_ID를 보냅니다.

\* 클라이언트 ID는 SP4\_SSV 보호로 설정되었으며, 여기에 설명된 조건에서 EXCHANGE\_ID가 SP4\_MACH\_CRED 상태 보호로 전송되었습니다. SSV는 클라이언트와 서버가 다시 시작되는 동안 지속되지 않을 수 있고 클라이언트가 EXCHANGE\_ID를 서버에 처음 보낼 때 SSV가 없기 때문에 클라이언트는 SSV RPCSEC\_GSS 핸들 없이 후속 EXCHANGE\_ID를 보낼 수 있습니다. 대신, SP4\_MACH\_CRED 보호와 마찬가지로 주체는 RPCSEC\_GSS 인증을 기반으로 해야 하고, 사용된 RPCSEC\_GSS 서비스는 무결성 또는 개인 정보 보호여야 하며, 클라이언트 ID가 생성될 때 사용된 것과 동일한 GSS 메커니즘 및 주체를 사용해야 합니다.\(MAY, MUST\)

위의 상황 중 어느 것도 적용되지 않으면 서버는 NFS4ERR\_CLID\_INUSE를 반환해야 합니다.\(MUST\)

서버가 클라이언트 ID를 생성한 것과 일치하는 주체 및 co\_ownerid를 수락하고 EXCHANGE\_ID의 co\_verifier가 클라이언트 ID가 생성될 때 사용된 co\_verifier와 다른 경우 서버는 클라이언트 ID를 확인하는 CREATE\_SESSION을 수신한 후 상태를 삭제합니다. co\_verifier 값이 동일한 경우\(예: 클라이언트가 클라이언트 ID의 속성을 업데이트 중이거나\(섹션 18.35\) 트렁킹을 시도 중인 경우\(섹션 2.10.5\) 서버는 상태를 삭제해서는 안 됩니다.\(MUST NOT\)

---
### **2.5.  Server Owners**

서버 소유자는 클라이언트 소유자\(섹션 2.4\)와 유사하지만 클라이언트 소유자와 달리 단축형 서버 ID가 없습니다. 서버 소유자는 다음 데이터 유형으로 정의됩니다.

```text
   struct server_owner4 {
    uint64_t       so_minor_id;
    opaque         so_major_id<NFS4_OPAQUE_LIMIT>;
   };
```

서버 소유자는 EXCHANGE\_ID에서 반환됩니다. 두 개의 EXCHANGE\_ID 결과에서 so\_major\_id 필드가 동일한 경우 각 EXCHANGE\_ID가 전송된 연결은 동일한 서버를 주소로 가정할 수 있습니다\(섹션 1.7에 정의됨\). so\_minor\_id 필드도 동일한 경우 두 연결이 모두 동일한 서버에 연결될 뿐만 아니라 두 연결에서 세션을 공유할 수 있습니다. 독자는 여러 서버가 의도적으로 또는 실수로 동일한 so\_major\_id 또는 so\_major\_id/so\_minor\_id를 가지고 있다고 주장할 수 있다는 점에 주의해야 합니다. 독자는 잘못 일치하는 서버 소유자 값에 대한 조치를 피하기 위해 섹션 2.10.5 및 18.35를 검토해야 합니다.

so\_major\_id 생성에 대한 고려 사항은 co\_ownerid 문자열 생성에 대한 고려 사항과 유사합니다\(섹션 2.4 참조\). 충돌하는 so\_major\_id 값을 생성하는 두 서버의 결과는 클라이언트가 RPCSEC\_GSS를 사용하여 각 서버의 신뢰성을 비교할 수 있기 때문에 co\_ownerid 충돌보다 덜 심각합니다\(섹션 2.10.5 참조\).

---
### **2.6.  Security Service Negotiation**

NFSv4.1 서버가 잠재적으로 여러 보안 메커니즘을 제공하는 경우 클라이언트는 서버와의 통신에 사용할 메커니즘을 결정하거나 협상하는 방법이 필요합니다. NFS 서버에는 NFS 클라이언트가 사용할 수 있는 파일 시스템 네임스페이스 내에 여러 지점이 있을 수 있습니다. 이러한 지점은 보안 정책 경계로 간주될 수 있으며 일부 NFS 구현에서는 NFS 내보내기 지점에 연결됩니다. 결과적으로 NFS 서버는 이러한 보안 정책 경계 각각이 서로 다르거나 여러 보안 메커니즘을 사용할 수 있도록 구성될 수 있습니다.

클라이언트와 서버 간의 보안 협상은 제3자가 협상 순서를 가로채고 클라이언트와 서버가 필요하거나 원하는 것보다 낮은 수준의 보안을 선택하도록 강요할 가능성을 제거하기 위해 보안 채널을 사용하여 수행되어야 합니다. 자세한 내용은 섹션 21을 참조하세요.\(SHOULD\)

---
#### **2.6.1.  NFSv4.1 Security Tuples**

NFS 서버는 네임스페이스의 각 보안 정책 경계에 하나 이상의 "보안 튜플"을 할당할 수 있습니다. 각 보안 튜플은 보안 특성\(섹션 2.2.1.1 참조\)과 특성이 RPCSEC\_GSS인 경우 GSS-API 메커니즘 개체 식별자\(OID\), GSS-API 보호 품질 및 RPCSEC\_GSS 서비스로 구성됩니다.

---
#### **2.6.2.  SECINFO and SECINFO_NO_NAME**

SECINFO 및 SECINFO\_NO\_NAME 작업을 통해 클라이언트는 파일 핸들별로 서버 액세스에 사용할 보안 튜플을 결정할 수 있습니다. 일반적으로 클라이언트는 서버와의 초기 통신 중이나 클라이언트가 서버의 보안 정책 경계를 넘을 때를 제외하고 두 작업을 모두 사용할 필요가 없습니다. 그러나 서버의 정책은 언제든지 변경될 수 있으며 클라이언트가 새로운 보안 튜플을 협상하도록 강요할 수도 있습니다.

서로 다른 보안 튜플을 사용하면 요청이 SECINFO 또는 SECINFO\_NO\_NAME 작업에 사용된 동일한 연결을 통해 전송된 경우 허용되는 액세스 유형\(예: 읽기 전용 대 읽기-쓰기\)에 영향을 미치며, 보안 튜플은 더 큰 액세스를 허용하는 것이 먼저 제시되어야 합니다. 일반적인 액세스 수준이 동일하고 서로 다른 보안 유형이 권한이 인식되는 주체의 범위를 제한하는 경우\(예: 루트 액세스 허용 또는 허용하지 않음\), 가장 큰 범위의 주체를 지원하는 버전이 먼저 나열되어야 합니다.

---
#### **2.6.3.  Security Error**

각 NFSv4.1 클라이언트와 서버가 최소 보안 세트\(즉, RPCSEC\_GSS의 Kerberos V5\)를 지원해야 한다는 가정에 따라 NFS 클라이언트는 최소 보안 튜플 중 하나를 사용하여 서버에 대한 파일 액세스를 시작합니다. 서버와 통신하는 동안 클라이언트는 NFS4ERR\_WRONGSEC의 NFS 오류를 수신할 수 있습니다. 이 오류를 통해 서버는 현재 사용 중인 보안 튜플이 서버의 보안 정책을 위반한다는 사실을 클라이언트에 알릴 수 있습니다. 그런 다음 클라이언트는 서버에서 사용할 수 있는 보안 튜플을 결정하고\(섹션 2.6.3.1 참조\) 클라이언트에 적합한 보안 튜플을 선택해야 합니다.\(MUST\)

---
##### **2.6.3.1.  Using NFS4ERR_WRONGSEC, SECINFO, and SECINFO_NO_NAME**

이 섹션에서는 NFSv4.1 보안 협상의 메커니즘을 설명합니다.

---
###### **2.6.3.1.1.  Put Filehandle Operations**

"파일 핸들 넣기 작업"이라는 용어는 PUTROOTFH, PUTPUBFH, PUTFH 및 RESTOREFH를 나타냅니다. 여기의 각 하위 섹션에서는 서버가 파일 핸들 넣기 작업으로 시작하는 일련의 작업을 처리하는 방법을 설명합니다.

---
####### **2.6.3.1.1.1.  Put Filehandle Operation + SAVEFH**

클라이언트는 향후 RESTOREFH, LINK 또는 RENAME을 위해 파일 핸들을 저장하고 있습니다. SAVEFH는 NFS4ERR\_WRONGSEC를 반환해서는 안 됩니다. 파일 핸들 넣기 작업이 NFS4ERR\_WRONGSEC를 반환하는지 여부를 결정하기 위해 서버 구현에서는 SAVEFH가 일련의 작업에 없는 것처럼 가장하고 섹션 2.6.3.1.1의 다른 하위 섹션에 설명된 상황 중 어떤 것이 적용되는지 검사합니다.\(MUST NOT\)

---
####### **2.6.3.1.1.2.  Two or More Put Filehandle Operations**

일련의 N put 파일 핸들 작업의 경우 서버는 첫 번째 N-1 put 파일 핸들 작업에 NFS4ERR\_WRONGSEC를 반환해서는 안 됩니다. N번째 put 파일핸들 작업은 일련의 작업 중 첫 번째인 것처럼 처리됩니다. 예를 들어 서버가 PUTFH, PUTROOTFH, LOOKUP 등 일련의 작업이 포함된 COMPOUND 요청을 수신한 경우 NFS4ERR\_WRONGSEC 목적에 대해 PUTFH 작업이 무시되고 PUTROOTFH, LOOKUP 하위 시리즈는 섹션 2.6.3.1에 따라 처리됩니다. 1.3.\(MUST NOT\)

```text
2.6.3.1.1.3.  Put Filehandle Operation + LOOKUP (or OPEN of an Existing
              Name)
```

이 상황은 기존 구성 요소 이름을 지정하는 LOOKUP 또는 OPEN 작업이 뒤따르는 파일 핸들 넣기 작업에도 적용됩니다.

이 상황에서 클라이언트는 잠재적으로 보안 정책 경계를 넘고 있으며 상위 디렉터리에서 지원하는 보안 튜플 집합은 하위 디렉터리의 보안 튜플 집합과 다를 수 있습니다. 서버 구현에서는 보안 정책 관리에 대한 제한 사항을 부과할지 여부를 결정할 수 있습니다. 최소한 세 가지 접근 방식이 있습니다\(sec\_policy\_child는 하위 내보내기의 튜플 세트이고, sec\_policy\_parent는 상위의 튜플 세트입니다\).

\(a\) sec\_policy\_child <= sec\_policy\_parent\(하위 집합의 경우 <=\). 이는 하위 디렉터리의 보안 정책에 지정된 보안 튜플 집합이 항상 해당 상위 디렉터리의 하위 집합임을 의미합니다.

\(b\) sec\_policy\_child ^ sec\_policy\_parent != {} \(교차의 경우 ^, 빈 세트의 경우 {}\). 이는 하위 디렉터리의 보안 정책에 지정된 보안 튜플 집합에는 항상 상위 디렉터리와 비어 있지 않은 교차점이 있음을 의미합니다.

\(c\) sec\_policy\_child ^ sec\_policy\_parent == {}. 이는 하위 디렉터리의 보안 정책에 지정된 보안 튜플 집합이 상위 디렉터리의 보안 튜플 집합과 교차할 수 없음을 의미합니다. 즉, 시스템 관리자가 이러한 튜플을 설정하는 방법에는 제한이 없습니다.

서버가 접근 방식 \(b\)\(클라이언트가 sec\_policy\_parent의 멤버가 아닌 플레이버를 선택하는 경우\) 및 \(c\)를 지원하기 위해 보안 튜플 불일치가 있을 때 put filehandle 작업이 NFS4ERR\_WRONGSEC를 반환할 수 없습니다. 대신, 다음에 나오는 LOOKUP\(또는 기존 구성 요소 이름으로 OPEN\)에서 반환되어야 합니다.

위의 지침은 접근법 \(a\)와 모순되지 않으므로 일반적으로 따라야 합니다. 접근 방식 \(a\)가 구현되더라도 LOOKUP의 대상에는 허용되는 보안 튜플이 허용되지만 put filehandle 작업에 사용되는 파일 핸들에는 허용되지 않을 수 있습니다. put 파일 핸들 작업은 PUTROOTFH 또는 PUTPUBFH일 수 있으며, 여기서 클라이언트는 루트 또는 공용 파일 핸들에 대한 보안 튜플을 알 수 없습니다. 또는 파일 핸들을 가져온 이후 파일 핸들 넣기 작업에서 사용하는 파일 핸들에 대한 보안 정책이 변경되었을 수 있습니다.

따라서 NFSv4.1 서버는 작업 바로 뒤에 LOOKUP 또는 구성 요소 이름별 OPEN이 따라오는 경우 파일 핸들 넣기 작업에 대한 응답으로 NFS4ERR\_WRONGSEC를 반환해서는 안 됩니다.\(MUST NOT\)

---
####### **2.6.3.1.1.4.  Put Filehandle Operation + LOOKUPP**

SECINFO는 아래쪽으로만 작동하므로 LOOKUPP가 SECINFO\_NO\_NAME 없이 NFS4ERR\_WRONGSEC를 반환할 수 있는 방법은 없습니다. SECINFO\_NO\_NAME은 SECINFO와 반대 방향으로 작동하는 SECINFO\_STYLE4\_PARENT 스타일을 통해 이 문제를 해결합니다. 섹션 2.6.3.1.1.3과 마찬가지로, LOOKUPP 다음에 오는 파일 핸들 넣기 작업은 NFS4ERR\_WRONGSEC를 반환해서는 안 됩니다. 서버가 SECINFO\_NO\_NAME을 지원하지 않는 경우 클라이언트의 유일한 방법은 지원하는 모든 보안 튜플과 함께 파일 핸들 넣기 작업, LOOKUPP, GETFH 작업 시퀀스를 보내는 것입니다.\(MUST NOT\)

SECINFO\_NO\_NAME이 지원되는지 여부에 관계없이 NFSv4.1 서버는 작업이 LOOKUPP 바로 뒤에 오는 경우 파일 핸들 넣기 작업에 대한 응답으로 NFS4ERR\_WRONGSEC를 반환해서는 안 됩니다.\(MUST NOT\)

---
####### **2.6.3.1.1.5.  Put Filehandle Operation + SECINFO/SECINFO_NO_NAME**

보안에 민감한 클라이언트는 파일 객체에 허용되는 보안 튜플을 결정하기 위해 서버에 쿼리할 때 강력한 보안 튜플을 선택할 수 있습니다. 클라이언트가 선택한 보안 튜플은 put filehandle 작업에 표시된 상위 디렉터리 또는 SECINFO에 표시된 하위 파일 개체\(또는 SECINFO\_NO\_NAME에 표시된 모든 상위 디렉터리\)의 보안 정책 튜플 목록에 포함될 필요가 없습니다. 물론 클라이언트가 선택한 보안 튜플에 맞게 서버를 구성해야 합니다. 그렇지 않으면 적절한 인증 오류로 인해 RPC 계층에서 요청이 실패합니다.

이론적으로 SECINFO 또는 SECINFO\_NO\_NAME에서 사용하는 보안 유형과 보안 정책에서 지원하는 보안 유형 사이에는 연관성이 없습니다. 그러나 실제로 클라이언트는 보안 정책에서 지원하는 것 중에서 강력한 특성을 찾기 시작한 다음 REQUIRED 세트의 특성을 찾기 시작할 수 있습니다.\(MUST\)

NFSv4.1 서버는 SECINFO 또는 SECINFO\_NO\_NAME 바로 뒤에 오는 파일 핸들 넣기 작업에 NFS4ERR\_WRONGSEC를 반환해서는 안 됩니다. NFSv4.1 서버는 SECINFO 또는 SECINFO\_NO\_NAME에서 NFS4ERR\_WRONGSEC를 반환해서는 안 됩니다.\(MUST NOT, MUST NOT\)

---
####### **2.6.3.1.1.6.  Put Filehandle Operation + Nothing**

NFSv4.1 서버는 NFS4ERR\_WRONGSEC를 반환해서는 안 됩니다.\(MUST NOT\)

---
####### **2.6.3.1.1.7.  Put Filehandle Operation + Anything Else**

"다른 것"에는 파일 핸들에 의한 OPEN이 포함됩니다.

보안 정책 적용은 put filehandle 작업에 지정된 파일 핸들에 적용됩니다. 따라서 보안 튜플 불일치가 있는 경우 파일 핸들 넣기 작업은 NFS4ERR\_WRONGSEC를 반환해야 합니다. 이렇게 하면 NFS4ERR\_WRONGSEC를 다른 모든 작업에 허용 가능한 오류로 추가하는 복잡성이 방지됩니다.\(MUST\)

시리즈 넣기 파일 핸들 작업 + SECINFO\_NO\_NAME\(스타일 SECINFO\_STYLE4\_CURRENT\_FH\)을 포함하는 COMPOUND는 클라이언트가 NFS4ERR\_WRONGSEC에서 복구하는 효율적인 방법입니다.

NFSv4.1 서버는 파일 핸들 넣기 작업, LOOKUP, LOOKUPP 및 OPEN\(컴포넌트 이름별\) 이외의 작업에 NFS4ERR\_WRONGSEC를 반환해서는 안 됩니다.\(MUST NOT\)

---
####### **2.6.3.1.1.8.  Operations after SECINFO and SECINFO_NO_NAME**

클라이언트가 SEQUENCE, PUTFH, SECINFO\_NONAME, READ 시리즈를 포함하는 COMPOUND 프로시저를 보내고 사용된 보안 튜플이 대상 파일에 필요한 것과 일치하지 않는다고 가정합니다. 규칙에 따라\(섹션 2.6.3.1.1.5 참조\) PUTFH나 SECINFO\_NO\_NAME은 NFS4ERR\_WRONGSEC를 반환할 수 없습니다. 규칙에 따라\(섹션 2.6.3.1.1.7 참조\) READ는 NFS4ERR\_WRONGSEC를 반환할 수 없습니다. 이 문제는 SECINFO 및 SECINFO\_NO\_NAME이 현재 파일 핸들을 사용한다는 사실로 해결됩니다\(NFSv4.0에서 변경된 사항입니다\). 이로 인해 READ에서 사용할 현재 파일 핸들이 남지 않으며 READ는 NFS4ERR\_NOFILEHANDLE을 반환합니다.

---
###### **2.6.3.1.2.  LINK and RENAME**

LINK 및 RENAME 작업은 현재 파일 핸들과 저장된 파일 핸들을 모두 사용합니다. 기술적으로 저장된 파일 핸들의 보안 정책이 COMPOUND 요청의 자격 증명에 사용된 보안 방식을 거부하는 경우 서버는 LINK 또는 RENAME에서 NFS4ERR\_WRONGSEC를 반환할 수 있습니다. 서버가 그렇게 하는 경우 저장된 파일 핸들과 현재 파일 핸들의 보안 정책 사이에 교차점이 없으면 클라이언트가 의도한 LINK 또는 RENAME 작업을 수행하는 것이 불가능하다는 의미입니다.\(MAY\)

예를 들어 클라이언트가 SEQUENCE, PUTFH bFH, SAVEFH, PUTFH aFH, RENAME "c" "d"라는 COMPOUND 요청을 보낸다고 가정합니다. 여기서 파일 핸들 bFH와 aFH는 서로 다른 디렉터리를 참조합니다. aFH와 bFH의 보안 정책 간에 공통 보안 튜플이 존재하지 않는다고 가정합니다. 클라이언트가 bFH의 보안 정책에는 허용되지만 aFH의 정책에는 허용되지 않는 자격 증명을 사용하여 요청을 보내는 경우 PUTFH aFH 작업은 NFS4ERR\_WRONGSEC와 함께 실패합니다. SECINFO\_NO\_NAME 요청 후 클라이언트는 aFH의 보안 정책에서는 허용되지만 bFH의 정책에서는 허용되지 않는 자격 증명을 사용하여 SEQUENCE, PUTFH bFH, SAVEFH, PUTFH aFH, RENAME "c" "d"를 보냅니다. 서버는 RENAME 작업에서 NFS4ERR\_WRONGSEC를 반환합니다.

클라이언트가 LINK 또는 RENAME을 포함하는 요청과 SECINFO\_NO\_NAME 또는 SECINFO를 포함하는 요청의 끝없는 시퀀스를 방지하려면 서버는 현재 및 저장된 파일 핸들의 보안 정책에 상호 허용 가능한 보안 튜플이 없는 경우를 감지해야 하며 반환해서는 안 됩니다. 해당 상황에서는 LINK 또는 RENAME의 NFS4ERR\_WRONGSEC입니다. 대신 서버는 다음 두 가지 중 하나를 수행해야 합니다.\(MUST NOT, MUST\)

\* 서버는 NFS4ERR\_XDEV를 반환할 수 있습니다.

\* 서버는 현재 파일 핸들의 보안 정책이 저장된 파일 핸들의 보안 정책을 무시하도록 허용할 수 있으므로 NFS4\_OK를 반환합니다.

---
### **2.7.  Minor Versioning**

필요에 따라 발전할 수 있는 NFS 프로토콜의 요구 사항을 해결하기 위해 NFSv4.1 프로토콜에는 향후 사소한 변경이나 버전 관리를 허용하는 규칙과 프레임워크가 포함되어 있습니다.

부 버전 관리와 관련된 기본 가정은 향후 승인되는 모든 부 버전이 하나 이상의 표준 트랙 RFC에 문서화된다는 것입니다. NFSv4 프로토콜의 마이너 버전 0은 \[37\]로 표시되고, 마이너 버전 1은 이 RFC로 표시됩니다. COMPOUND 및 CB\_COMPOUND 프로시저는 클라이언트가 요청하는 부 버전의 인코딩을 지원합니다.

다음 항목은 마이너 버전 개발을 위한 기본 규칙을 나타냅니다. 향후 부 버전에서는 부 버전 정의의 일부로 다음 규칙을 수정하거나 추가할 수 있습니다.

1. 프로시저가 추가되거나 삭제되지 않습니다.

- 일반 RPC 모델을 유지하기 위해 NFSv4 마이너 버전은 NFS 프로그램의 프로시저를 추가하거나 삭제하지 않습니다.

2. 마이너 버전은 COMPOUND에 작업을 추가할 수 있으며

- CB\_COMPOUND 프로시저.

- COMPOUND 및 CB\_COMPOUND 프로시저에 작업을 추가해도 RPC 모델에는 영향을 미치지 않습니다.

- \* 마이너 버전은 속성 집합을 나타내는 bitmap4와 속성 값 집합을 나타내는 fattr4에 속성을 추가할 수 있습니다.

- 이는 미래의 성장이나 적응을 허용하기 위해 속성 모델의 확장을 허용합니다.

- \* 부 버전 X는 마지막으로 문서화된 속성 뒤에 새 속성을 추가해야 합니다.

- 속성 결과는 속성별 XDR 인코딩 결과의 불투명 배열로 지정되므로 현재 정의 중에 새 속성을 추가하는 복잡성이 너무 부담스럽습니다.

3. 마이너 버전은 기존 작업의 인수 또는 결과 구조를 수정해서는 안 됩니다.

- 다시 말하지만, 단일 작업에 대해 여러 구조 정의를 처리하는 복잡성은 너무 부담스럽습니다. 부 버전의 기존 구조를 수정하는 대신 새로운 작업을 추가해야 합니다.

- 이 규칙은 부 버전에서 다음과 같은 조정을 배제하지 않습니다.

- \* GETATTR의 bitmap4 데이터 유형에 대한 새로운 속성과 같은 플래그 필드에 비트를 추가하고 해당 비트맵과 함께 사용되는 inform4와 같은 불투명 배열의 해당 변형 제공

- \* 플래그 단어가 있는 ACL과 같은 기존 속성에 비트 추가

- \* 열거형 유형\(NFS4ERR\_\* 포함\)을 새로운 값으로 확장

- \* 전환된 조합에 사례 추가

4. 마이너 버전은 기존 속성의 구조를 수정해서는 안 됩니다.

```text
   5.   Minor versions must not delete operations.
```

- 이는 향후 마이너 버전에서 특정 작업 "슬롯"의 잠재적인 재사용을 방지합니다.

```text
   6.   Minor versions must not delete attributes.
```

7. 마이너 버전에서는 플래그 비트나 열거형 값을 삭제하면 안 됩니다.

8. 마이너 버전에서는 작업을 구현해서는 안 된다고 선언할 수 있습니다.\(MUST NOT\)

작업을 구현해서는 안 된다고 지정하는 것은

- 작업을 폐기하는 것과 같습니다. 클라이언트의 경우 이는 작업이 서버로 전송되어서는 안 된다는 것을 의미합니다. 서버의 경우 XDR 디코드 오류로 요청을 "삭제"하는 것과 반대로 NFS 오류가 반환될 수 있습니다. 이 접근 방식을 사용하면 향후 부 버전에서 해당 작업을 다시 도입할 수 있도록 구조를 유지하면서 작업을 폐기할 수 있습니다.\(MUST NOT, MUST NOT\)

- 1. 마이너 버전에서는 속성을 구현해서는 안 된다고 선언할 수 있습니다.\(MUST NOT\)

- 2. 부 버전에서는 플래그 비트 또는 열거형 값을 구현해서는 안 된다고 선언할 수 있습니다.\(MUST NOT\)

9. 부 버전에서는 기능을 필수에서 다음으로 다운그레이드할 수 있습니다.

- 권장 또는 선택 사항으로 권장됩니다.\(MUST\)

10. 부 버전에서는 기능을 OPTIONAL에서 다음으로 업그레이드할 수 있습니다.

- 권장 또는 필수로 권장됩니다.\(MUST\)

11. 마이너 버전 X를 지원하는 클라이언트와 서버는 마이너 버전 0부터 X-1까지도 지원해야 합니다.\(SHOULD\)

12. 인프라 변경을 제외하고 마이너 버전은 필수 새 기능을 도입해서는 안 됩니다.\(MUST\)

- 이 규칙은 새로운 기능의 도입을 허용하고 기능을 필수로 지정하기 전에 구현 경험을 강제로 사용하도록 합니다. 반면에 일부 기능 클래스는 인프라적이며 광범위한 영향을 미칩니다. 인프라 기능을 RECOMMENDED 또는 OPTIONAL로 허용하면 부 버전 구현이 복잡해집니다.\(MUST, SHOULD\)

13. 클라이언트는 마이너 버전 Y가 있는 다른 COMPOUND 프로시저에 대해 마이너 버전 X가 있는 COMPOUND 프로시저에서 stateid, 파일 핸들 또는 유사한 반환 개체를 사용하려고 시도해서는 안 됩니다\(여기서 X != Y\).\(MUST NOT\)

---
### **2.8.  Non-RPC-Based Security Services**

섹션 2.2.1.1.1.1에 설명된 대로 NFSv4.1은 식별, 인증, 무결성 및 개인 정보 보호를 위해 RPC를 사용합니다. NFSv4.1 자체는 다음 여러 하위 섹션에 설명된 대로 추가 보안 서비스를 제공하거나 활성화합니다.

---
#### **2.8.1.  Authorization**

NFSv4.1 작업을 통해 파일 객체에 액세스하는 권한은 궁극적으로 NFSv4.1 서버에 의해 결정됩니다. 클라이언트는 OPEN\(18.16절\) 및 ACCESS\(18.1절\) 작업을 통해 파일 개체에 대한 액세스를 미리 결정할 수 있습니다.

적절한 액세스 권한이 있는 주체는 SETATTR\(섹션 18.30\) 작업을 통해 파일 개체에 대한 인증을 수정할 수 있습니다. 액세스 권한에 영향을 미치는 속성에는 mode, owner, owner\_group, acl, dacl 및 sacl이 포함됩니다. 섹션 5를 참조하세요.

---
#### **2.8.2.  Auditing**

NFSv4.1은 섹션 6에 설명된 대로 acl 및 sacl 속성을 통해 파일별 개체 기반으로 감사를 제공합니다. 감사 로그 형식이나 관리 정책을 지정하는 것은 이 사양의 범위를 벗어납니다.

---
#### **2.8.3.  Intrusion Detection**

NFSv4.1은 섹션 6에 설명된 대로 acl 및 sacl 속성을 통해 파일 개체별로 경보 제어를 제공합니다. 경보는 침입 탐지의 기초 역할을 할 수 있습니다. 경보를 통해 침입을 탐지하기 위한 경험적 방법을 지정하는 것은 이 사양의 범위를 벗어납니다.

---
### **2.9.  Transport Layers**
---
#### **2.9.1.  REQUIRED and RECOMMENDED Properties of Transports**

NFSv4.1은 다음 속성을 사용하여 RDMA\(Remote Direct Memory Access\) 및 비RDMA 기반 전송을 통해 작동합니다.

\* 전송은 NFSv4.1에서 요구하는 안정적인 데이터 전달을 지원하지만 NFSv4.1이나 RPC에는 이를 보장할 수 있는 기능이 없습니다\[41\].

\* 전송은 전송된 순서대로 데이터를 전달합니다. 순서대로 전달하면 전송 오류 감지가 단순화되고 레코드 표시 프로토콜\[3\]을 통해 임의 크기의 요청 및 응답 전송이 단순화됩니다.

NFSv4.1 구현이 IP 네트워크 프로토콜을 통한 작업을 지원하는 경우 NFS와 IP 간에 사용되는 모든 전송은 IETF에서 승인한 혼잡 제어 전송 프로토콜 중 하나여야 합니다. 이 문서가 작성될 당시 위 속성을 가진 전송은 TCP와 SCTP\(스트림 제어 전송 프로토콜\)뿐이었습니다. 상호 운용성을 향상시키기 위해 NFSv4.1 구현은 TCP 전송 프로토콜을 통한 작업을 지원해야 합니다.\(MUST, MUST\)

NFSv4.1이 비IP 네트워크 프로토콜을 통해 사용되는 경우에도 전송에서 혼잡 제어를 지원하는 것이 좋습니다.\(SHOULD\)

NFSv4.1에서는 비연결 전송을 사용할 수 있습니다. 그러나 비연결 전송에 의한 혼잡 제어와 결합된 안정적이고 순차적인 데이터 전달이 필요합니다. 결과적으로 UDP 자체는 NFSv4.1 전송으로 사용되어서는 안 됩니다. NFSv4.1에서는 기본 전송이 연결 개념을 피하더라도 전송을 통해 데이터를 전송하는 데 사용되는 클라이언트 전송 주소와 서버 전송 주소가 함께 연결을 구성한다고 가정합니다.\(MUST, MUST NOT\)

---
#### **2.9.2.  Client and Server Transport Behavior**

연결 지향 전송\(예: TCP\)이 사용되는 경우 클라이언트와 서버는 최소한 다음 세 가지 이유로 장기 연결을 사용해야 합니다.\(SHOULD\)

1. 이는 단기 연결을 통해 전송의 혼잡 제어 메커니즘이 약화되는 것을 방지합니다.

2. 이를 통해 WAN 환경의 성능이 향상됩니다.

- 연결 설정 핸드셰이크가 필요하지 않습니다.

3. NFSv4.1 콜백 모델은 NFSv4.0과 다르며 클라이언트와 서버는 서버가 사용할 클라이언트 생성 백채널\(섹션 2.10.3.1 참조\)을 유지해야 합니다.

혼잡을 줄이기 위해 연결 지향 전송이 사용되고 요청이 NULL 프로시저가 아닌 경우:

\* 응답이 수신되기 전에 요청이 전송된 연결이 끊어지지 않는 한 요청자는 요청을 재시도해서는 안 됩니다.\(MUST NOT\)

\* 응답자는 요청이 재시도인 경우에도 자동으로 요청을 삭제해서는 안 됩니다. \(RPCSEC\_GSS\[4\]의 자동 삭제 동작은 요청 처리의 하위 계층인 RPCSEC\_GSS 계층에서 발생하기 때문에 적용되지 않습니다.\) 대신 응답자는 적절한 오류\(섹션 2.10.6.1 참조\)를 반환해야 합니다. 연결을 끊을 수도 있습니다.\(MUST NOT, SHOULD\)

응답을 보낼 때 응답자는 요청자가 요청을 보낸 동일한 전체 네트워크 주소\(예: IP 기반 전송을 사용하는 경우 요청자의 소스 포트가 전체 네트워크 주소의 일부임\)로 응답을 보내야 합니다. 연결 지향 전송을 사용하는 경우 응답은 요청을 수신한 동일한 연결에서 전송되어야 합니다.\(MUST, MUST\)

응답자가 요청을 받은 후 응답을 보내기 전에 연결이 끊어지면 응답자에게 보류 중인 응답이 있을 수 있습니다. 연결이 끊어진 연결과 동일한 소스 및 대상 전체 네트워크 주소로 설정된 경우 응답자는 요청자가 요청을 재시도할 때까지 응답을 보내서는 안 됩니다. 이러한 금지 이유는 요청자가 다른 연결을 통해 요청을 재시도할 수 있기 때문입니다\(단, 연결이 원래 요청의 세션과 연결되어 있는 경우\).\(MUST NOT, MAY\)

RDMA 전송을 사용할 때 동일한 연결을 통한 재시도를 허용하지 않는 다른 이유가 있습니다.

\* RDMA 전송은 "크레딧"을 사용하여 흐름 제어를 시행합니다. 여기서 크레딧은 피어가 메시지를 전송할 수 있는 권리입니다. 한 피어가 요청\(또는 응답\)을 재전송하는 경우 추가 크레딧이 소비됩니다. 응답자가 응답을 재전송하는 경우 요청자는 일반적으로 각 요청에 대해 단일 수신 버퍼만 게시하므로 확실히 RDMA 연결이 손실됩니다. 요청자가 요청을 재전송한 경우 클라이언트가 이를 고려하고 사용 가능한 크레딧을 줄이지 않으면 서버에서 소비된 추가 크레딧으로 인해 RDMA 연결이 실패하여 리소스가 낭비될 수 있습니다.

\* RDMA 크레딧은 NFSv4.1의 응답 캐시에 새로운 문제를 제시합니다. 응답 캐시는 클라이언트가 다시 연결된 후와 같이 세션 내 연결이 끊어졌을 때 사용될 수 있습니다. 신용 정보는 RDMA 연결의 동적 속성이므로 오래된 값은 캐시에서 재생되어서는 안 됩니다. 이는 응답이 전송될 때 응답 캐시 콘텐츠를 맹목적으로 사용해서는 안 되며 채널에 적합한 신용 정보가 RPC 계층에 의해 새로 고쳐져야 함을 의미합니다.

또한 섹션 2.10.6.2에 설명된 대로 세션이 활성화된 동안 NFSv4.1 요청자는 응답 대기를 중지해서는 안 됩니다.\(MUST NOT\)

---
#### **2.9.3.  Ports**

역사적으로 NFSv3 서버는 TCP 포트 2049를 통해 수신했습니다. NFS 프로토콜에 대해 등록된 포트 2049\[42\]가 기본 구성이어야 합니다. NFSv4.1 클라이언트는 \[43\]에 설명된 대로 RPC 바인딩 프로토콜을 사용해서는 안 됩니다.\(SHOULD NOT\)

---
### **2.10.  Session**

NFSv4.1 클라이언트와 서버는 이 섹션에 설명된 대로 세션 기능을 지원하고 사용해야 합니다.\(MUST\)

---
#### **2.10.1.  Motivation and Overview**

NFS의 이전 버전과 부 버전은 다음과 같은 문제를 겪었습니다.

\* 정확히 한 번 의미론\(EOS\)에 대한 지원이 부족합니다. 여기에는 서버 장애 및 복구를 통한 EOS 지원 부족이 포함됩니다.

\* 방화벽을 통한 콜백 전송 지원 없음, 일반 요청에 대한 응답과 콜백 간의 경쟁 등 제한된 콜백 지원.

\* 여러 네트워크 경로에 대한 트렁킹이 제한됩니다.

\* 완전히 안전한 작업을 위해서는 컴퓨터 자격 증명이 필요합니다.

세션 도입을 통해 NFSv4.1은 실용적인 솔루션을 통해 위의 단점을 해결합니다.

\* EOS는 제한된 크기의 응답 캐시로 활성화되므로 캐시를 영구 저장소에 유지하고 서버 장애 및 복구를 통해 EOS를 활성화하는 것이 가능합니다. NFS의 이전 개정판이 EOS를 지원하지 않은 이유 중 하나는 일부 EOS 접근 방식이 병렬성을 제한하는 경우가 많았기 때문입니다. 섹션 2.10.6에서 설명하겠지만 NFSv4.1은 EOS와 무제한 병렬성을 모두 지원합니다.

\* NFSv4.1 클라이언트\(섹션 1.7에 정의됨\)는 전송 연결을 생성하고 콜백 요청 전송에 사용할 서버에 이를 제공하여 방화벽 문제를 해결합니다\(섹션 18.34\). 클라이언트 요청의 응답과 요청으로 인한 콜백 간의 경합은 EOS\(섹션 2.10.6.3\)의 결과인 세션의 순서 속성을 통해 감지됩니다.

\* NFSv4.1 클라이언트는 임의의 개수를 연결할 수 있습니다.

- 세션과 연결하여 트렁킹을 제공합니다\(섹션 2.10.5\).

\* NFSv4.1 클라이언트 및 서버는 중요한 세션 관리 작업을 보호하기 위한 다이제스트를 계산하는 데 사용할 수 있는 클라이언트 및 서버 시스템 자격 증명과 독립적인 세션 키를 생성합니다\(섹션 2.10.8.3\).

\* NFSv4.1 클라이언트는 서버가 클라이언트 시스템 주체에 인증할 필요가 없는 세션의 백채널에서 사용할 보안 RPCSEC\_GSS 컨텍스트를 생성할 수도 있습니다\(섹션 2.10.8.2\).

세션은 클라이언트에 의해 생성되고 시간이 지남에 따라 하나 이상의 전송 연결에서 사용되는 동적으로 생성되고 수명이 긴 서버 개체입니다. 그 기능은 클라이언트 인스턴스에 속한 연결과 관련된 서버의 상태를 유지하는 것입니다. 이 상태는 연결 자체와 완전히 독립적이며 실제로 연결이 존재하는지 여부에 관계없이 상태가 존재합니다. 클라이언트에는 연결된 하나 이상의 세션이 있을 수 있으므로 연결이 해당 세션과 연결되어 있는 경우 해당 클라이언트의 클라이언트 ID와 연결된 세션 중 하나를 사용하여 클라이언트 관련 상태에 액세스할 수 있습니다. 오랜 시간 동안 클라이언트 ID의 세션과 연결이 연결되지 않으면 잠금, 열기, 위임, 레이아웃 등과 같은 개체가 만료될 수 있습니다. 세션은 해당 상태에 대한 물리적 액세스 수단과 관계없이 클라이언트가 서버의 관련 클라이언트 상태에 액세스하는 수단을 나타내는 개체 역할을 합니다.

단일 클라이언트가 여러 세션을 생성할 수 있습니다. 단일 세션이 여러 클라이언트를 서비스해서는 안 됩니다.\(MUST NOT\)

---
#### **2.10.2.  NFSv4 Integration**

세션은 NFSv4.0이 아닌 NFSv4.1의 일부입니다. 일반적으로 세션과 같은 주요 인프라 변경에는 NFS와 같은 ONC\(Open Network Computing\) RPC 프로그램에 대한 새로운 주요 버전 번호가 필요합니다. 그러나 NFSv4는 해당 기능을 단일 프로시저인 COMPOUND로 캡슐화하고 COMPOUND가 임의의 수의 작업을 지원할 수 있기 때문에 NFSv4.1에 세션이 거의 어려움 없이 추가되었습니다. COMPOUND에는 부 버전 번호 필드가 포함되어 있으며 NFSv4.1의 경우 이 부 버전은 1로 설정됩니다. NFSv4 서버는 부 버전이 1로 설정된 COMPOUND를 처리할 때 NFSv4.0에서와는 다른 작업 집합을 예상합니다. . NFSv4.1은 DESTROY\_SESSION\(18.37절\)과 같은 일부 세션 관리 작업을 제외하고 설정된 세션에서 작동하는 모든 COMPOUND에 필요한 SEQUENCE 작업을 정의합니다.

---
##### **2.10.2.1.  SEQUENCE and CB_SEQUENCE**

NFSv4.1에서는 SEQUENCE 작업이 있는 경우 COMPOUND 프로시저의 첫 번째 작업이어야 합니다. SEQUENCE의 주요 목적은 세션 식별자를 전달하는 것입니다. 세션 식별자는 COMPOUND 프로시저의 다른 모든 작업을 특정 세션과 연결합니다. SEQUENCE에는 EOS 유지에 필요한 정보도 포함되어 있습니다\(섹션 2.10.6 참조\). 따라서 세션이 활성화된 NFSv4.1 COMPOUND 요청의 형식은 다음과 같습니다.\(MUST\)

```text
       +-----+--------------+-----------+------------+-----------+----
       | tag | minorversion | numops    |SEQUENCE op | op + args | ...
       |     |   (== 1)     | (limited) |  + args    |           |
       +-----+--------------+-----------+------------+-----------+----
```

응답의 형식은 다음과 같습니다.

```text
       +------------+-----+--------+-------------------------------+--//
       |last status | tag | numres |status + SEQUENCE op + results |  //
       +------------+-----+--------+-------------------------------+--//
               //-----------------------+----
               // status + op + results | ...
               //-----------------------+----
```

CB\_COMPOUND 프로시저의 요청과 응답은 COMPOUND와 비슷한 형태이지만 SEQUENCE 연산 대신 CB\_SEQUENCE 연산이 있다. CB\_COMPOUND에는 "callback\_ident"라는 추가 필드도 있는데, 이는 NFSv4.1에서는 불필요하며 클라이언트에서는 무시해야 합니다. CB\_SEQUENCE는 SEQUENCE와 동일한 정보를 가지며 콜백 경합을 해결하는 데 필요한 기타 정보도 포함합니다\(2.10.6.3 단원\).\(MUST\)

---
##### **2.10.2.2.  Client ID and Session Association**

각 클라이언트 ID\(섹션 2.4\)에는 0개 이상의 활성 세션이 있을 수 있습니다. NFSv4.1에서 파일 액세스를 수행하려면 클라이언트 ID 및 관련 세션이 필요합니다. 세션이 사용될 때마다\(클라이언트가 서버에 요청을 보내거나 클라이언트가 서버의 콜백 요청에 응답하는 경우\) 관련 클라이언트 ID에 임대된 상태가 자동으로 갱신됩니다.

상태\(공유 예약, 잠금, 위임 및 레이아웃\(섹션 1.8.4\)으로 구성될 수 있음\)은 클라이언트 ID에 연결됩니다. 클라이언트 상태는 개별 세션에 연결되지 않습니다. 특정 상태 소유자의 연속적인 상태 변경 작업은 세션이 동일한 클라이언트 ID와 연결되어 있는 경우 다른 세션을 통해 진행될 수 있습니다. 콜백은 원래 콜백과 관련된 상태를 획득한 요청의 세션과 다른 세션을 통해 도착할 수 있습니다. 예를 들어 세션 A가 위임을 획득하는 데 사용되는 경우 두 세션이 모두 동일한 클라이언트 ID와 연결되어 있으면 위임 회수 요청이 세션 B를 통해 도착할 수 있습니다. 섹션 2.10.8.1 및 2.10.8.2에서는 콜백과 관련된 보안 고려 사항을 논의합니다.\(MAY, MAY, MAY\)

---
#### **2.10.3.  Channels**

채널은 연결이 아닙니다. 채널은 ONC RPC 요청이 전송되는 방향을 나타냅니다.

각 세션에는 전방 채널과 후방 채널이라는 하나 또는 두 개의 채널이 있습니다. 세션당 최대 2개의 채널이 있고 각 채널에는 고유한 목적이 있으므로 채널에는 식별자가 할당되지 않습니다.

Fore 채널은 클라이언트에서 서버로의 일반적인 요청에 사용되며 COMPOUND 요청과 응답을 전달합니다. 세션에는 항상 포어 채널이 있습니다.

백채널은 서버에서 클라이언트로의 콜백 요청에 사용되며 CB\_COMPOUND 요청과 응답을 전달합니다. 백채널이 있는지 여부는 클라이언트에 의해 결정됩니다. 그러나 NFSv4.1의 많은 기능에는 백채널이 필요합니다. NFSv4.1 서버는 백채널을 지원해야 합니다.\(MUST\)

각 세션에는 별도의 응답 캐시를 포함하여 각 채널에 대한 리소스가 있습니다\(섹션 2.10.6.1 참조\). 일부 콜백 작업은 멱등성이 없기 때문에 백채널에도 응답 캐시\(또는 최소한 재시도를 감지하기 위한 슬롯 테이블\)가 필요합니다.

---
##### **2.10.3.1.  Association of Connections, Channels, and Sessions**

각 채널은 0개 이상의 전송 연결\(동일한 전송 프로토콜이든 다른 전송 프로토콜이든\)과 연관됩니다. 연결은 세션의 한 채널 또는 두 채널 모두와 연관될 수 있습니다. 클라이언트와 서버는 CREATE\_SESSION\(18.36절\) 및 BIND\_CONN\_TO\_SESSION\(18.34절\) 작업을 통해 연결이 한 채널 또는 두 채널 모두에 대한 트래픽을 전달할지 여부를 협상합니다. CREATE\_SESSION을 통해 세션이 생성되면 CREATE\_SESSION 요청을 전송한 연결이 자동으로 전면 채널 및 선택적으로 백채널과 연결됩니다. 세션이 생성될 때 클라이언트가 상태 보호를 지정하지 않으면\(18.35절\) SEQUENCE가 다른 연결에서 전송될 때 연결은 SEQUENCE 작업에 지정된 세션의 전면 채널과 자동으로 연결됩니다.

세션과 연결의 연관은 배타적이지 않습니다. 한 세션의 채널과 연관된 연결은 다른 클라이언트 ID와 연관된 세션을 포함하여 다른 세션의 채널과 동시에 연관될 수 있습니다.

여러 전송 유형의 연결이 동일한 채널과 연결되는 것이 허용됩니다. 예를 들어 TCP 및 RDMA 연결은 모두 전방 채널과 연결될 수 있습니다. RDMA 및 비RDMA 연결이 동일한 채널과 연결된 경우 최대 슬롯 수는 RDMA 크레딧의 총 수\(섹션 2.10.6.1\)보다 최소한 하나 더 많아야 합니다. 이렇게 하면 모든 RDMA 크레딧이 사용되는 경우 비RDMA 연결에 미해결 요청이 하나 이상 있을 수 있습니다. 서버가 여러 전송 유형을 지원하는 경우 클라이언트가 각 전송의 연결을 채널에 연결할 수 있도록 허용해야 합니다\(MUST\).\(SHOULD, MUST\)

한 유형의 전송 연결이 전방 채널과 연결되고 다른 유형의 연결이 백채널과 연결되는 것이 허용됩니다.

---
#### **2.10.4.  Server Scope**

각 서버는 EXCHANGE\_ID 작업 결과의 일부로 반환된 불투명 문자열 eir\_server\_scope 형식으로 서버 범위 값을 지정합니다. 서버 범위의 목적은 동일한 서버 범위 값을 공유하는 서버 집합이 불투명 식별자의 고유한 값을 사용하도록 배열되었음을 서버 그룹이 클라이언트에게 표시하여 두 서버가 서로 다른 두 서버에 동일한 값을 할당하지 않도록 하는 것입니다. 사물. 따라서 해당 세트 내의 두 서버에 의해 생성된 식별자는 호환 가능하다고 가정할 수 있으므로 중요한 경우 해당 세트의 한 서버에 의해 생성된 식별자가 동일한 범위의 다른 서버에 제공될 수 있습니다.

이러한 호환 가능한 값을 사용한다고 해서 한 서버에서 생성된 값이 다른 서버에서 항상 승인된다는 의미는 아닙니다. 대부분의 경우에는 그렇지 않습니다. 그러나 서버는 다른 서버에서 생성된 값을 실수로 받아들이지 않습니다. 이를 수락하는 경우 이는 유효하고 동일한 범위의 다른 서버에서와 동일한 의미를 전달하는 것으로 인식되기 때문입니다.

서버가 동일한 서버 범위에 속하면 이 값 호환성은 다음 식별자에 적용됩니다.

\* 파일핸들 값. 동일한 서버 범위의 두 서버에서 허용되는 파일 핸들 값은 동일한 개체를 나타냅니다. 한 서버에 전송된 WRITE 작업은 다른 서버에 전송된 READ에 즉시 반영됩니다.

\* 서버 소유자 값. 서버 범위 값이 동일할 경우 서버 소유자 값을 유효하게 비교할 수 있습니다. 서버 범위 값이 다른 경우 서버 소유자 값은 동일한 바이트 문자열을 포함하더라도 다른 것으로 처리됩니다.

이러한 호환성을 제공하는 데 필요한 서버 간의 조정은 매우 최소화될 수 있으며 ID 공간의 단순한 분할로 제한됩니다. 공통 가치를 인정하려면 추가적인 구현이 필요하지만 이는 해당 인식이 필요한 특정 상황에 맞게 조정될 수 있습니다.

클라이언트는 다양한 상황에서 여러 서버의 서버 범위 값을 비교할 기회를 갖게 되며, 각 상황은 적절한 기능 섹션에서 논의됩니다.

\* 여러 네트워크 주소로 전송된 EXCHANGE\_ID 작업에 대한 응답으로 수신된 서버 소유자 값을 섹션 11.5.2에 설명된 대로 다양한 형태의 트렁킹의 유효성을 판단할 목적으로 비교하는 경우.

\* 네트워크 또는 서버 재구성으로 인해 동일한 네트워크 주소가 다른 서버로 전달될 가능성이 있는 경우 섹션 8.4.2.1에 설명된 대로 클라이언트가 잠금 회수를 시도해야 하는 시기를 결정해야 합니다.

각각 서로 다른 두 서버 네트워크 주소에서 온 EXCHANGE\_ID의 두 응답이 동일한 서버 범위를 갖는 경우 클라이언트가 공통 서버 범위가 그룹에서 협력하는 두 서버로 인한 것인지 확인할 수 있는 여러 가지 방법이 있습니다.

\* 두 EXCHANGE\_ID 요청이 RPCSEC\_GSS\(\[4\], \[9\], \[27\]\) 인증을 사용하여 전송되었고 서버 주체가 두 대상 모두 동일한 경우 서버 범위가 동일한지 검증됩니다. 동일한 서버 범위와 server\_owner major\_id를 공유하려는 두 서버가 동일한 주체 이름을 공유하는 것이 좋습니다. 경우에 따라 이는 서버 범위를 검증하는 클라이언트의 작업을 단순화합니다.\(SHOULD\)

\* 클라이언트는 관련 파일 시스템에 대한 fs\_locations 또는 fs\_locations\_info 속성에서 두 번째 서버의 모양을 수락할 수 있습니다. 예를 들어, 특정 파일 시스템에 대한 마이그레이션 이벤트가 있거나 특정 파일 시스템에서 회수할 잠금이 있는 경우 해당 특정 파일 시스템에 대한 속성이 사용될 수 있습니다. 클라이언트는 RPCSEC\_GSS 인증을 사용하여 fs\_locations 또는 fs\_locations\_info 속성에 대한 GETATTR 요청을 첫 번째 서버에 보냅니다. 공통 서버 범위를 확인하기 전에 이 작업을 수행해야 할 수도 있습니다. 클라이언트가 GETATTR에 대한 응답을 성공적으로 인증하고 fs\_locations 또는 fs\_locations\_info 속성을 포함하는 GETATTR 요청 및 응답이 두 번째 서버를 참조하는 경우 서버 범위 동일성이 지원됩니다. 클라이언트는 관련된 특정 파일 시스템\(예: 마이그레이션 중인 파일 시스템\)과 관련된 정보에 대해 이러한 지원 형식의 사용을 제한하도록 선택할 수 있습니다.

---
#### **2.10.5.  Trunking**

트렁킹은 데이터 전송 속도를 높이기 위해 클라이언트와 서버 간에 다중 연결을 사용하는 것입니다. NFSv4.1은 세션 트렁킹과 클라이언트 ID 트렁킹이라는 두 가지 유형의 트렁킹을 지원합니다.

단일 서버 네트워크 주소의 맥락에서는 모든 연결이 동일한 서버에 액세스하고 있다고 가정할 수 있으며 NFSv4.1 서버는 두 가지 형태의 트렁킹을 모두 지원해야 합니다. 여러 연결이 일련의 네트워크 주소를 사용하여 동일한 서버에 액세스하는 경우 서버는 두 가지 형태의 트렁킹을 모두 지원해야 합니다. 클러스터 구성의 NFSv4.1 서버는 다양한 서버의 네트워크 주소가 클라이언트 ID 트렁킹을 사용하도록 허용할 수 있습니다.\(MUST, MUST, MAY\)

클라이언트는 서로 다른 서버 네트워크 주소 간 트렁킹을 수행할 때 허용되는 트렁킹 종류에 대한 서버의 명령을 위반하지 않는 한 어느 형태의 트렁킹이든 사용할 수 있습니다\(아래 참조\). 콜백 채널과 관련하여 클라이언트는 서버가 주어진 클라이언트 ID에 유효한 모든 콜백 채널 중에서 선택할 수 있도록 허용해야 하며 백채널을 지원하는 연결이 세션 또는 클라이언트 ID 트렁킹을 콜백에 사용할 수 있도록 허용하는 경우 트렁킹을 지원해야 합니다\(MUST\).\(MUST\)

세션 트렁킹은 기본적으로 각각 잠재적으로 다른 대상 및/또는 소스 네트워크 주소를 가진 여러 연결을 동일한 세션에 연결하는 것입니다. 두 연결의 대상 네트워크 주소\(서버 주소\)가 동일한 경우 서버는 이러한 세션 트렁킹을 지원해야 합니다. 대상 네트워크 주소가 다른 경우 서버는 EXCHANGE\_ID 작업에서 반환된 데이터를 사용하여 이러한 지원을 나타낼 수 있습니다\(아래 참조\).\(MUST, MAY\)

클라이언트 ID 트렁킹은 여러 세션을 동일한 클라이언트 ID에 연결하는 것입니다. 서버는 동일한 두 네트워크 주소에 대한 세션 트렁킹을 허용할 때마다 두 대상 네트워크 주소에 대한 클라이언트 ID 트렁킹을 지원해야 합니다. 또한 서버는 동일한 주요 서버 소유자 ID\(섹션 2.5\) 및 서버 범위\(섹션 2.10.4\)를 제시하여 클라이언트 ID 트렁킹의 추가 사례를 허용할 수 있습니다. 두 서버가 동일한 주요 서버 소유자 및 서버 범위를 반환하는 경우 이는 두 서버가 클라이언트 ID 트렁킹의 전제 조건인 잠금 상태 관리에 협력하고 있음을 의미합니다.\(MUST, MAY\)

클라이언트가 세션 및 클라이언트 ID 트렁킹을 사용할 수 있는 시기를 구별하려면 EXCHANGE\_ID\(섹션 18.35\) 작업의 결과가 서버를 식별하는 방법을 이해해야 합니다. 클라이언트가 두 개의 서로 다른 연결을 통해 EXCHANGE\_ID를 전송하고 각각은 서로 다른 대상 네트워크 주소를 가지고 있지만 각 EXCHANGE\_ID 작업은 eia\_clientowner 필드의 값이 동일하다고 가정합니다. 동일한 NFSv4.1 서버가 각 연결을 수신하는 경우 각 EXCHANGE\_ID 결과는 eir\_clientid, eir\_server\_owner.so\_major\_id 및 eir\_server\_scope의 동일한 값을 반환해야 합니다. 그런 다음 클라이언트는 각 연결을 동일한 서버를 참조하는 것으로 처리할 수 있으며\(검증 대상, 아래 섹션 2.10.5.1 참조\) 각 연결을 트렁크 요청 및 응답에 사용할 수 있습니다. 클라이언트는 세션 트렁킹을 적용할지 클라이언트 ID 트렁킹을 적용할지 여부를 선택합니다.\(MUST\)

세션 트렁킹. eia\_clientowner 인수가 두 개의 서로 다른 EXCHANGE\_ID 요청에서 동일하고 eir\_clientid, eir\_server\_owner.so\_major\_id, eir\_server\_owner.so\_minor\_id 및 eir\_server\_scope 결과가 두 EXCHANGE\_ID 결과에서 일치하는 경우 클라이언트는 세션 트렁킹을 수행할 수 있습니다. 클라이언트에 eir\_clientid, eir\_server\_owner.so\_major\_id, eir\_server\_scope 및 eir\_server\_owner.so\_minor\_id의 튜플에 대한 세션 매핑이 없으면 연결 중 하나를 통해 CREATE\_SESSION 작업을 통해 세션을 생성하고 연결을 세션에 연결합니다. 튜플에 대한 세션이 있는 경우 클라이언트는 BIND\_CONN\_TO\_SESSION을 보내 연결을 세션에 연결할 수 있습니다.

- 물론, 클라이언트가 세션 트렁킹 사용을 원하지 않는다면 반드시 그렇게 할 필요는 없습니다. 연결에서 CREATE\_SESSION을 호출할 수 있습니다. 그러면 아래 설명된 대로 클라이언트 ID 트렁킹이 발생합니다. 또한 트렁킹 사용을 선택하지 않은 경우 연결을 끊기로 결정할 수도 있습니다.

클라이언트 ID 트렁킹. eia\_clientowner 인수가 두 개의 서로 다른 EXCHANGE\_ID 요청에서 동일하고 eir\_clientid, eir\_server\_owner.so\_major\_id 및 eir\_server\_scope 결과가 두 EXCHANGE\_ID 결과에서 일치하는 경우 클라이언트는 eir\_server\_owner.so\_minor\_id 결과가 일치하는지 여부에 관계없이 클라이언트 ID 트렁킹을 수행할 수 있습니다. \). 클라이언트는 각 연결을 다른 세션과 연결할 수 있으며, 각 세션은 동일한 서버와 연결됩니다.

- 클라이언트는 eir\_clientid에 반환된 동일한 클라이언트 ID를 사용하여 각 연결에서 CREATE\_SESSION을 호출하여 클라이언트 ID 트렁킹 작업을 완료합니다. 이러한 호출은 두 개의 세션을 생성하고 각 연결을 해당 세션과 연결합니다. 클라이언트는 이 시점에서 연결을 끊는 것만으로 클라이언트 ID 트렁킹 사용을 자유롭게 거부할 수 있습니다.

- 클라이언트 ID 트렁킹을 수행할 때 잠금 상태는 동일한 클라이언트 ID와 연결된 세션 간에 공유됩니다. 이를 위해서는 서버가 세션 전체의 상태를 조정해야 하고 클라이언트가 동일한 잠금 상태를 여러 세션과 연결할 수 있어야 합니다.

다양한 종류의 재구성 이벤트로 인해 동일한 네트워크 주소에 대한 후속 EXCHANGE\_ID 요청에서 eir\_server\_scope 및 eir\_server\_owner 값이 다를 수 있는 것은 항상 가능합니다.

대부분의 경우 이러한 재구성 이벤트는 중단을 일으키며 이전에 한 서버에 연결되었던 IP 주소가 이제 완전히 다른 서버에 연결되었음을 나타냅니다.

이러한 상황에 대한 클라이언트 처리에 대한 일부 지침은 다음과 같습니다.

\* eir\_server\_scope가 변경되면 클라이언트는 이전에 얻은 ID\(예: 파일 핸들\)가 새 서버에서 유효하게 사용될 수 있다는 보장이 없으며, 새 서버가 이를 수락하더라도 이것이 기한이 아니라는 보장이 없습니다. 사고에. 따라서 클라이언트가 실수로 수락할 가능성이 낮다고 가정하고 이 상황을 다음 사례와 같이 처리하더라도 이러한 모든 상태를 손실 또는 부실 상태로 처리하는 것이 가장 좋습니다.

\* eir\_server\_scope가 동일하게 유지되고

- eir\_server\_owner.so\_major\_id가 변경되면 클라이언트는 자신이 가지고 있는 파일 핸들을 사용할 수 있고 잠금 상태가 손실된 것으로 간주하고 잠금을 회수하거나 다시 획득하려고 시도할 수 있습니다. 해당 파일 핸들이 이제 오래되었음을 알 수 있습니다. 그러나 NFS4ERR\_STALE이 반환되지 않으면 회수를 진행하거나 열린 잠금 상태를 다시 획득할 수 있습니다.

\* eir\_server\_scope와 eir\_server\_owner.so\_major\_id가 동일하게 유지되면 클라이언트는 적절한 트렁킹 형식을 결정할 때 eir\_server\_owner.so\_minor\_id의 현재 값을 사용해야 합니다. 이로 인해 연결이 끊어지거나 새 세션이 생성될 수 있습니다.

---
##### **2.10.5.1.  Verifying Claims of Matching Server Identity**

서버가 eir\_server\_owner, eir\_server\_scope 및 eir\_clientid 값과 일치하거나 부분적으로 일치한다고 주장하는 서로 다른 두 연결을 사용하여 응답하는 경우 클라이언트는 서버의 주장을 신뢰할 필요가 없습니다. 클라이언트는 다음과 같은 방법으로 트래픽을 트렁킹하기 전에 이러한 클레임을 확인할 수 있습니다.

\* 세션 트렁킹의 경우 클라이언트는 다음 사항을 안정적으로 확인해야 합니다.

- 서로 다른 네트워크 경로 간의 연결은 실제로 동일한 NFSv4.1 서버와 연결되어 있으며 동일한 세션에서 사용할 수 있으며, 서버는 클라이언트가 안정적인 검증을 수행할 수 있도록 허용해야 합니다. 클라이언트 ID가 생성되면 클라이언트는 BIND\_CONN\_TO\_SESSION이 SP4\_SSV 또는 SP4\_MACH\_CRED\(18.35절\) 상태 보호 옵션에 따라 확인되도록 지정해야 합니다. SP4\_SSV의 경우 신뢰할 수 있는 검증은 SET\_SSV\(섹션 18.47 참조\) 작업을 통해 설정된 공유 비밀\(SSV\)에 따라 달라집니다.\(MUST, SHOULD\)

- 새 연결이 세션과 연결될 때\(BIND\_CONN\_TO\_SESSION 작업을 통해, 섹션 18.34 참조\) 클라이언트가 BIND\_CONN\_TO\_SESSION 작업에 대해 SP4\_SSV 상태 보호를 지정한 경우 클라이언트는 무결성 또는 개인 정보 보호를 사용하여 RPCSEC\_GSS 보호와 함께 BIND\_CONN\_TO\_SESSION을 보내야 합니다. GSS SSV 메커니즘으로 생성된 RPCSEC\_GSS 핸들입니다\(섹션 2.10.9 참조\).\(MUST\)

- 클라이언트가 실수로 잘못된 서버의 세션에 연결을 연결하려고 시도하는 경우 서버는 BIND\_CONN\_TO\_SESSION 인수의 세션 식별자를 인식하지 못하기 때문에 시도를 거부하거나 RPCSEC\_GSS 인증이 실패하기 때문에 시도를 거부합니다. . 서버가 실수로 또는 악의적으로 연결 연결 시도를 수락하더라도 응답에서 계산하는 RPCSEC\_GSS 검증자는 클라이언트에 의해 확인되지 않으므로 클라이언트는 지정된 세션을 트렁킹하는 데 연결을 사용할 수 없다는 것을 알게 됩니다.

- 클라이언트가 SP4\_MACH\_CRED 상태 보호를 지정한 경우 BIND\_CONN\_TO\_SESSION 작업은 클라이언트 ID가 생성될 때 사용된 것과 동일한 자격 증명을 사용하여 RPCSEC\_GSS 무결성 또는 개인 정보 보호를 사용합니다. RPCSEC\_GSS를 통한 상호 인증은 연결이 올바른 서버의 올바른 세션과 연결되어 있음을 클라이언트에게 보장합니다.

\* 클라이언트 ID 트렁킹의 경우 클라이언트에는 두 개의 서로 다른 EXCHANGE\_ID 작업에서 얻은 동일한 클라이언트 ID가 동일한 서버에서 왔는지 확인하기 위한 두 가지 이상의 옵션이 있습니다. 첫 번째 옵션은 각 EXCHANGE\_ID 작업을 보낼 때 RPCSEC\_GSS 인증을 사용하는 것입니다. EXCHANGE\_ID가 RPCSEC\_GSS 인증과 함께 전송될 때마다 클라이언트는 GSS 대상의 주체 이름을 기록합니다. EXCHANGE\_ID 결과가 클라이언트 ID 트렁킹이 가능함을 나타내고 GSS 대상의 주체 이름이 동일한 경우 서버는 동일하며 클라이언트 ID 트렁킹이 허용됩니다.

- 두 번째 확인 옵션은 SP4\_SSV 보호를 사용하는 것입니다. 클라이언트는 EXCHANGE\_ID를 보낼 때 SP4\_SSV 보호를 지정합니다. 클라이언트가 보내는 첫 번째 EXCHANGE\_ID는 항상 CREATE\_SESSION 호출로 확인되어야 합니다. 그런 다음 클라이언트는 SET\_SSV를 보냅니다. 나중에 클라이언트는 첫 번째 EXCHANGE\_ID가 전송된 주소와 다른 두 번째 대상 네트워크 주소로 EXCHANGE\_ID를 보냅니다. 클라이언트는 각 EXCHANGE\_ID 응답에 동일한 eir\_clientid, eir\_server\_owner.so\_major\_id 및 eir\_server\_scope가 있는지 확인합니다. 그렇다면 클라이언트는 두 번째 EXCHANGE\_ID에서 반환된 RPCSEC\_GSS 핸들을 사용하여 RPCSEC\_GSS 무결성으로 보호된 두 번째 대상 주소로 CREATE\_SESSION 작업을 전송하여 클레임을 확인합니다. 서버가 CREATE\_SESSION 요청을 수락하고 클라이언트가 RPCSEC\_GSS 검증자 및 무결성 코드를 확인하면 클라이언트는 두 번째 서버가 SSV를 알고 있다는 증거를 갖게 되며 따라서 두 서버는 서버 범위 및 클라이언트 ID 트렁킹을 지정하기 위해 협력하고 있는 것입니다. .

---
#### **2.10.6.  Exactly Once Semantics**

NFSv4.1은 세션을 통해 채널을 통해 전송된 요청에 대해 EOS\(정확히 한 번만 의미\)를 제공합니다. EOS는 포채널과 백채널 모두에서 지원됩니다.

선행 SEQUENCE 또는 CB\_SEQUENCE 작업과 함께 전송되는 각 COMPOUND 또는 CB\_COMPOUND 요청은 수신자에 의해 정확히 한 번 실행되어야 합니다. 이 요구 사항은 요청이 응답 캐싱이 지정된 상태로 전송되는지 여부에 관계없이 적용됩니다\(섹션 2.10.6.1.3 참조\). 요청자가 pNFS 데이터 클라이언트와 pNFS 데이터 서버 간에 생성된 세션을 통해 요청을 보내는 경우에도 요구 사항이 유지됩니다. 이 요구 사항에 대한 근거를 이해하려면 요청을 세 가지 분류로 나눕니다.\(MUST\)

```text
   *  Non-idempotent requests.

   *  Idempotent modifying requests.

   *  Idempotent non-modifying requests.
```

비멱등성 요청의 예는 RENAME입니다. 분명히 응답자가 동일한 RENAME 요청을 두 번 실행하고 첫 번째 실행이 성공하면 재실행은 실패합니다. 응답자가 재실행 결과를 반환하는 경우 이 결과는 잘못된 것입니다. 따라서 비멱등성 요청에는 EOS가 필요합니다.

멱등성 수정 요청의 예는 WRITE 작업이 포함된 COMPOUND 요청입니다. 동일한 WRITE를 반복적으로 실행하면 해당 WRITE를 한 번 실행한 것과 동일한 효과가 있습니다. 그럼에도 불구하고 데이터 손상을 방지하려면 WRITE 및 기타 멱등성 수정 요청에 EOS를 적용해야 합니다.

클라이언트가 EOS를 시행하지 않는 비호환 서버에 WRITE A를 보내고 네트워크 파티션으로 인해 응답을 받지 못한다고 가정해 보겠습니다. 클라이언트는 서버에 다시 연결하고 WRITE A를 다시 보냅니다. 이제 서버에는 A의 미해결 인스턴스 두 개가 있습니다. 서버는 A의 재시도를 실행하고 응답하는 상황에 처할 수 있지만 첫 번째 A는 여전히 기다리고 있습니다. 일부 리소스에 대한 서버의 내부 I/O 시스템에서. WRITE A의 두 번째 시도에 대한 응답을 받으면 클라이언트는 WRITE가 완료되었다고 믿고 A의 바이트 범위와 겹치는 WRITE B를 자유롭게 보낼 수 있습니다. 원래 A가 서버의 I/O 시스템에서 디스패치되면 그리고 실행되면\(따라서 A가 두 번째로 기록됨\) B가 작성한 내용을 덮어쓰게 되어 손상될 수 있습니다.

멱등성 비수정 요청의 예로는 SEQUENCE, PUTFH, READLINK만 포함하는 COMPOUND가 있습니다. 이러한 요청을 다시 실행해도 데이터가 손상되거나 잘못된 결과가 발생하지 않습니다. 그럼에도 불구하고 구현을 단순하게 유지하기 위해 응답자는 멱등성 및 비수정 여부에 관계없이 모든 요청에 ​​대해 EOS를 시행해야 합니다.\(MUST\)

서버가 안정적인 저장소에 응답 캐시를 유지하지 않는 한, 그리고 서버가 다시 시작을 요구하지 않도록 구현되지 않는 한\(실제로 그러한 서버가 존재하는 경우 안정적으로 유지되는 응답 캐시 간의 구별은\) 진정한 완전한 EOS는 불가능합니다. 저장 대 저장이 아닌 것은 의미가 없는 것입니다\). 응답 캐시의 지속성에 대한 논의는 섹션 2.10.6.5를 참조하세요. 그럼에도 불구하고 서버가 응답 캐시를 유지하지 않더라도 기존 중복 요청/응답 캐시가 ONC RPC 트랜잭션 식별자\(XID\)를 기반으로 했기 때문에 EOS는 이전 NFS 버전에 비해 견고성과 정확성을 향상시킵니다. 섹션 2.10.6.1에서는 응답 캐시의 기반인 XID의 단점을 설명하고 NFSv4.1 세션이 XID를 어떻게 향상시키는지 설명합니다.

---
##### **2.10.6.1.  Slot Identifiers and Reply Cache**

RPC 계층은 고유해야 하지만 두 가지 이유로 요청을 추적하는 데 편리하지 않은 트랜잭션 ID\(XID\)를 제공합니다. 첫째, XID는 요청자에게만 의미가 있습니다. 이전에 보낸 요청과 동일한지 테스트하는 경우를 제외하고 응답자는 이를 해석할 수 없습니다. RPC 기반 중복 요청 캐시를 참조할 때 XID의 불투명성 때문에 계산 비용이 많이 드는 조회\(종종 XID 및 소스 주소가 포함된 해시를 통해\)가 필요합니다. NFSv4.1 요청은 훨씬 더 효율적인 슬롯 테이블에 대한 인덱스인 불투명하지 않은 슬롯 ID를 사용합니다. 둘째, RPC 요청은 응답자에 의해 어떤 순서로든 실행될 수 있으므로 언제든지 처리되지 않은 요청 수에 제한이 없습니다. 완벽한 EOS를 달성하려면 ONC RPC를 사용하면 모든 응답을 응답 캐시에 저장해야 합니다. XID는 32비트입니다. 40억\(2^\(32\)\)개 이상의 응답을 응답 캐시에 저장하는 것은 실용적이지 않습니다. 실제로 이전 버전의 NFS에서는 캐시에 고정된 수의 응답을 저장하고 LRU\(최근 사용\) 접근 방식을 사용하여 캐시가 가득 찼을 때 캐시 항목을 새 항목으로 바꾸는 방식을 선택했습니다. NFSv4.1에서 처리되지 않은 요청 수는 슬롯 테이블의 크기에 따라 제한되며 슬롯당 시퀀스 ID는 캐시된 응답을 삭제해도 안전한 시기를 응답자에게 알리는 데 사용됩니다.

NFSv4.1 응답 캐시에서 요청자가 새 요청을 보낼 때 0..N 범위의 슬롯 ID를 선택합니다. 여기서 N은 요청이 있는 세션에서 요청자에게 부여된 응답자의 현재 최대 슬롯 ID입니다. 전송됩니다. N 값은 ca\_maxrequests - 1\(섹션 18.36\)과 동일하게 시작하지만 이 섹션의 뒷부분에 설명된 대로 SEQUENCE 또는 CB\_SEQUENCE에 대한 응답으로 조정할 수 있습니다. 슬롯 ID는 요청자가 세션에서 이미 활성화한 요청에서 사용되지 않아야 합니다. 여기서 '사용되지 않음'은 요청자에게 해당 슬롯 ID에 대한 미해결 요청이 없음을 의미합니다.

슬롯에는 시퀀스 ID와 해당 시퀀스 ID로 전송된 요청에 해당하는 캐시된 응답이 포함되어 있습니다. 시퀀스 ID는 32비트 부호 없는 값이므로 0..0xFFFFFFFF\(2^\(32\) - 1\) 범위에 있습니다. 슬롯이 처음 사용될 때 요청자는 시퀀스 ID 1을 지정해야 합니다\(18.36절\). 슬롯이 재사용될 때마다 요청은 슬롯의 이전 요청보다 1 큰 시퀀스 ID를 지정해야 합니다. 이전 시퀀스 ID가 0xFFFFFFFF인 경우 슬롯에 대한 다음 요청에는 0으로 설정된 시퀀스 ID가 있어야 합니다\(예: \(2^\(32\) - 1\) + 1 mod 2^\(32\)\).\(MUST, MUST, MUST\)

시퀀스 ID는 각 요청의 슬롯 ID와 함께 제공됩니다. 이는 응답자의 중요한 확인을 위한 것입니다. 특정 슬롯 ID를 사용하는 요청이 재전송인지 이전에 본 적이 없는 새로운 요청인지를 효율적으로 결정하는 데 사용됩니다. 요청자가 이를 구현하기 위해 재전송하고 있다고 주장하는 것은 실현 가능하지 않습니다. 왜냐하면 주어진 요청에 대해 요청자는 응답자가 실제로 응답하지 않는 한 응답자가 이를 보았는지 여부를 알 수 없기 때문입니다. 물론 요청자가 응답을 본 경우 요청자는 재전송하지 않을 것입니다.

응답자는 수신된 각 요청의 시퀀스 ID를 해당 슬롯 ID에 대해 이전에 수신된 마지막 시퀀스 ID와 비교하여 새 요청이 다음과 같은지 확인합니다.

\* 시퀀스 ID가 이전에 슬롯에 표시된 것보다 하나 더 큰 새 요청입니다\(시퀀스 랩어라운드 고려\). 응답자는 계속해서 새로운 요청을 실행하며, 응답자는 슬롯의 시퀀스 ID를 1씩 늘려야 합니다.\(MUST\)

\* 현재 슬롯에 ​​기록된 시퀀스 ID와 동일한 재전송 요청입니다. 원래 요청이 완료될 때까지 실행되면 응답자는 캐시된 응답을 반환합니다. 응답자가 아직 진행 중인 요청의 재시도를 처리하는 방법에 대한 지침은 섹션 2.10.6.2를 참조하세요.

\* 시퀀스 ID가 다음보다 작은 잘못된 순서의 재시도

- \(시퀀스 랩어라운드를 고려하여\) 이전에 슬롯에서 본 것입니다. 응답자는 NFS4ERR\_SEQ\_MISORDERED\(SEQUENCE 또는 CB\_SEQUENCE의 결과\)를 반환해야 합니다.\(MUST\)

\* 시퀀스 ID가 이전에 슬롯에서 본 것보다 \(시퀀스 랩어라운드를 고려하여\) 2개 이상인 잘못된 순서의 새 요청입니다. 시퀀스 ID는 0xFFFFFFFF에 도달하면 0으로 바뀌어야 하기 때문에 순서가 잘못된 새 요청과 순서가 잘못된 재시도를 구별할 수 없습니다. 따라서 응답자는 NFS4ERR\_SEQ\_MISORDERED\(SEQUENCE 또는 CB\_SEQUENCE의 결과\)를 반환해야 합니다.\(MUST, MUST\)

XID와 달리 슬롯 ID는 항상 특정 범위 내에 있습니다. 이는 두 가지 의미를 갖습니다. 첫 번째 의미는 주어진 세션에 대해 응답자는 제한된 수의 COMPOUND 요청 결과만 캐시하면 된다는 것입니다. 두 번째 의미는 첫 번째 의미에서 파생됩니다. 즉, XID 인덱스 응답 캐시\(중복 요청 캐시 - DRC라고도 함\)와 달리 슬롯 ID 기반 응답 캐시는 오버플로될 수 없습니다. 재전송된 요청을 식별하기 위해 시퀀스 ID를 사용하면 응답자는 실제로 요청 자체를 캐시할 필요가 없으므로 응답 캐시의 저장 요구 사항이 더욱 줄어듭니다. 이러한 기능을 사용하면 효과적인 응답 캐시에 필요한 모든 항목을 유지하는 것이 실용적입니다.

따라서 슬롯 ID, 시퀀스 ID 및 세션 ID는 응답자의 응답 캐시 구현에서 XID 및 소스 네트워크 주소의 전통적인 역할을 대신합니다. 이 접근 방식은 이식성이 훨씬 뛰어나고 완전히 강력합니다. 클라이언트가 IP 네트워크를 통해 다시 연결할 때 포트를 다시 할당할 필요가 없습니다. 또한 RPC XID는 응답 캐시에 사용되지 않으므로 요청자가 XID를 빠르게 재사용하는 경우에도 캐시의 견고성이 향상됩니다. 응답자는 응답 캐시 관리를 위해 XID에 관심이 없지만\(그러나 응답자는 요청에 있었던 동일한 XID를 반환해야 함\) 그럼에도 불구하고 NFSv4.1의 XID에 대한 고려 사항은 다른 모든 것과 동일합니다. 이전 버전의 NFS. RPC XID는 각 메시지에 남아 있으며 다른 ONC RPC 요청과 마찬가지로 NFSv4.1 요청에서 공식화되어야 합니다. 그 이유는 다음과 같습니다:\(MUST\)

\* RPC 계층은 기존 의미와 구현을 유지합니다.

\* 요청자와 응답자는 SEQUENCE 또는 CB\_SEQUENCE 작업을 NFSv4.1로 디코딩하기 전에 RPC 계층에서 상호 운용할 수 있어야 합니다.

\* SEQUENCE 또는 CB\_SEQUENCE\(예: BIND\_CONN\_TO\_SESSION\)로 시작하지 않는 작업을 사용하는 경우 올바른 작업이 요청에 대한 응답과 일치하려면 RPC XID가 필요합니다.

\* SEQUENCE 또는 CB\_SEQUENCE 작업에서 오류가 발생할 수 있습니다. 그렇다면 요청에 포함된 슬롯 ID, 시퀀스 ID 및 세션 ID\(있는 경우\)는 응답에 포함되지 않으며 요청자는 요청에 대한 응답과 일치하는 XID만 갖습니다.

잘 구성된 XID가 계속 필요하다는 점을 고려하면 SEQUENCE 및 CB\_SEQUENCE 응답에 세션 ID, 슬롯 ID 및 시퀀스 ID가 있는 이유는 무엇입니까?라는 질문이 제기됩니다. 응답에 세션 ID가 있다는 것은 요청자가 세션 ID를 조회하기 위해 XID를 사용할 필요가 없다는 것을 의미합니다. 이는 연결이 여러 세션과 연결된 경우 필요합니다. 응답에 슬롯 ID와 시퀀스 ID가 있다는 것은 요청자가 슬롯 ID와 시퀀스 ID를 조회하기 위해 XID를 사용할 필요가 없다는 것을 의미합니다. 게다가 XID는 32비트에 불과하기 때문에 응답과 요청의 재연관을 보장하기에는 너무 작습니다\[44\]. 응답에 세션 ID, 슬롯 ID 및 시퀀스 ID가 있으면 클라이언트는 응답이 실제로 일치하는 요청에 속하는지 확인할 수 있습니다.

SEQUENCE\(및 CB\_SEQUENCE\) 작업은 추가 요청자 슬롯 사용 정보를 전달하는 "highest\_slotid" 값도 전달합니다. 요청자는 항상 가장 높은 번호의 슬롯 값으로 미해결 요청을 나타내는 슬롯 ID를 표시해야 합니다. 요청자는 모든 경우에 가능한 가장 보수적인 값을 제공해야 하지만, 최소 또는 최적 수준을 유지하기 위해 실제 순간 사용량보다 다소 증가할 수 있습니다. 이는 요청자가 사용되지 않은 요청 슬롯을 응답자에게 다시 제공하는 방법을 제공하며, 응답자는 해당 정보를 사용하여 리소스를 재할당할 수 있습니다.\(MUST\)

응답자는 다음과 같이 새로운 대상 maximum\_slotid와 강제된 maximum\_slotid로 응답합니다.

\* 대상 maximum\_slotid는 응답자가 요청자가 사용하기를 원하는 maximum\_slotid를 요청자에게 표시합니다. 이를 통해 응답자는 다른 요청자의 다양한 요구 수준에서 리소스를 보다 공정하게 공유하기 위해 리소스를 사용하지 않는 것으로 확인된 요청자로부터 리소스를 철회\(또는 추가\)할 수 있습니다. 요청자는 응답자의 값 업데이트를 항상 준수해야 합니다. 이는 세션 리소스에 대한 요청자의 액세스에 대해 새로 설정된 엄격한 제한을 나타내기 때문입니다. 그러나 요청 파이프라인으로 인해 요청자는 이전 값을 반영하는 진행 중인 활성 요청을 가질 수 있습니다. 따라서 회신자는 요청자에게 즉시 준수를 요구해서는 안 됩니다.

\* 적용된 maximum\_slotid는 요청자가 후속 SEQUENCE 또는 CB\_SEQUENCE 작업에 사용할 수 있는 가장 높은 슬롯 ID를 나타냅니다. 응답자의 시행된 maximum\_slotid는 SEQUENCE 또는 CB\_SEQUENCE 인수에 표시된 요청자의 maximum\_slotid보다 작지 않아야 합니다.\(SHOULD\)

- 요청자는 high\_slotid 인수를 Sequence 작업으로 낮추는 것과 관련하여 비타협적일 수 있습니다. 즉, 요청자는 Sequence 작업에 대한 응답에서 대상 maximum\_slotid를 계속 무시하고, high\_slotid 인수를 대상 maximum\_slotid보다 높게 계속 설정합니다. 응답자가 대상 maximum\_slotid보다 높은 슬롯 ID를 가진 미해결 요청이 없다는 것을 알고 있는 경우 이는 특히 심각한 동작으로 간주될 수 있습니다. 그러한 비타협적 태도에 직면했을 때 응답자는 더 강력한 조치를 자유롭게 취할 수 있으며 이전에 시행된 maximum\_slotid보다 작은 새로운 시행된 maximum\_slotid로 응답할 수 있습니다. 그 후, 요청자가 응답자의 새로 적용된 maximum\_slotid보다 큰 maximum\_slotid로 요청을 계속 보내는 경우, 요청의 슬롯 ID가 새로 적용된 maximum\_slotid보다 크고 요청이 재시도되지 않는 한 서버는 NFS4ERR\_BAD\_HIGH\_SLOT을 반환할 수 있습니다.\(MAY, MAY\)

- 응답자는 요청자가 응답자의 새로 시행된 maximum\_slotid보다 작거나 같은 high\_slotid가 있는 요청을 보낼 때까지 폐기하려는 슬롯을 유지해야 합니다.\(SHOULD\)

- 요청자는 응답자의 maximum\_slotid를 초과하는 슬롯 ID를 가진 비재시도 요청 전송에 대해 비타협적일 수도 있습니다. 응답자가 강제로 적용된 maximum\_slotid를 낮추면 요청자는 응답자의 maximum\_slotid를 초과하는 슬롯에서만 재시도를 보낼 수 있습니다. 새로 적용된 maximum\_slotid보다 높은 슬롯 ID로 요청이 수신되고 시퀀스 ID가 슬롯의 응답 캐시에 있는 것보다 하나 더 높은 경우 서버는 슬롯을 폐기하고 NFS4ERR\_BADSLOT을 반환할 수 있습니다\(그러나 서버는 하나만 수행하고 다른 하나는 수행하면 안 됩니다.\) 슬롯을 폐기하는 것이 안전한 이유는 다음 시퀀스 ID를 사용하여 요청자가 슬롯에 대한 이전 응답을 수신했음을 나타내기 때문입니다.\(MUST NOT\)

\* 요청자는 새 요청을 보낼 때 사용 가능한 가장 낮은 슬롯을 사용해야 합니다. 이렇게 하면 응답자는 슬롯 항목을 더 빨리 폐기할 수 있습니다. 그러나 응답자가 부여된 최고 슬롯 ID를 적극적으로 조정하는 경우 요청에서 슬롯 ID 및 최고 슬롯 ID의 수신만 사용할 수는 없습니다. 요청에 사용된 슬롯 ID나 maximum\_slotid는 요청자의 세션 제한에 대한 응답자의 현재 아이디어를 반영하지 않을 수 있습니다. 업데이트가 수신되기 전에 요청이 요청자로부터 전송되었을 수 있기 때문입니다. 따라서 하향 조정의 경우 응답자는 요청자가 새로 부여된 maximum\_slotid가 포함된 응답을 보았다고 추론할 수 있을 때까지 최소한 기존 최대 요청 미결 값만큼 큰 응답 캐시 항목 수를 유지해야 할 수 있습니다. 응답자는 요청에 응답한 슬롯 ID와 다음으로 높은 시퀀스 ID를 가진 새 요청을 수신할 때 요청자가 이러한 응답을 본 것으로 추론할 수 있습니다.\(SHOULD\)

---
###### **2.10.6.1.1.  Caching of SEQUENCE and CB_SEQUENCE Replies**

SEQUENCE 또는 CB\_SEQUENCE 작업이 성공적으로 실행되면 해당 응답은 항상 캐시되어야 합니다. 특히 세션 ID, 시퀀스 ID 및 슬롯 ID는 응답 캐시에 캐시되어야 합니다. SEQUENCE의 응답에는 가장 높은 슬롯 ID, 대상 가장 높은 슬롯 ID 및 상태 플래그도 포함됩니다. 이러한 값을 캐싱하는 대신 서버는 적절하게 포어 채널, 세션 및/또는 클라이언트 ID의 현재 상태에서 값을 다시 계산할 수 있습니다. 마찬가지로 CB\_SEQUENCE의 응답에는 가장 높은 슬롯 ID와 대상 가장 높은 슬롯 ID가 포함됩니다. 클라이언트는 세션의 현재 상태에서 적절하게 값을 다시 계산할 수 있습니다.\(MUST, MUST, MAY, MAY\)

응답자가 가장 높은 슬롯 ID, 대상 슬롯 ID 및 재시도에 대한 응답 상태를 다시 계산하는지 여부에 관계없이 요청자는 재시도가 전송된 후 응답을 받을 때마다 값이 다시 계산되고 있다고 가정해서는 안 됩니다. 수신한 응답이 재시도에 대한 응답으로 응답자에 의해 전송되었는지 아니면 원래 요청에 대한 지연된 응답인지 알 수 없기 때문입니다. 따라서 가장 높은 슬롯 ID, 대상 슬롯 ID 또는 상태 비트가 요청이 처음 실행되었을 때의 상황을 반영할 수 있는 경우가 있을 수 있습니다. 이렇게 지연된 정보를 토대로 조치를 취하는 것은 유효하지만 회신을 받는 사람이 불필요한 작업을 수행하게 될 수 있습니다. 요청자는 최신 상태가 아닐 수 있는 데이터에 대해 즉시 조치를 취하는 것보다 현재 상태를 확인하기 위해 추가 요청을 보내거나 후속 요청에 의해 보고된 상태를 사용하도록 선택할 수 있습니다.\(MUST NOT, MAY\)

---
###### **2.10.6.1.2.  Errors from SEQUENCE and CB_SEQUENCE**

SEQUENCE 또는 CB\_SEQUENCE가 오류를 반환할 때마다 슬롯의 시퀀스 ID는 변경되어서는 안 됩니다. 응답자는 SEQUENCE 또는 CB\_SEQUENCE에서 오류가 반환될 때마다 슬롯에 대한 응답 캐시 항목을 수정해서는 안 됩니다.\(MUST NOT, MUST NOT\)

---
###### **2.10.6.1.3.  Optional Reply Caching**

요청별로 요청자는 SEQUENCE 또는 CB\_SEQUENCE에 대한 인수의 sa\_cachethis 또는 csa\_cachethis 필드를 통해 첫 번째 작업\(SEQUENCE 또는 CB\_SEQUENCE\) 이후 모든 작업에 대한 응답을 캐시하도록 응답자에게 지시하도록 선택할 수 있습니다. 응답자에게 전체 응답을 캐시하도록 지시하지 않는 이유는 요청이 모든 멱등성 작업으로 구성되어 있기 때문입니다\[41\]. 응답을 캐싱하면 이점이 거의 없을 수 있습니다. 응답이 너무 크면\(섹션 2.10.6.4 참조\) 어쨌든 캐시하지 못할 수 있습니다. 멱등성 요청에 대한 응답이 캐시할 만큼 작더라도 응답을 불필요하게 캐시하면 서버 속도가 느려지고 RPC 대기 시간이 늘어납니다.

요청자가 응답을 캐시하도록 요청하는지 여부는 슬롯 처리에 영향을 주지 않습니다. SEQUENCE 또는 CB\_SEQUENCE의 결과가 NFS4\_OK인 경우 슬롯의 시퀀스 ID는 1씩 증가해야 합니다. 요청자가 응답자에게 응답을 캐시하도록 지시하지 않는 경우 응답자는 다음 중 하나를 수행해야 합니다.\(MUST, MUST\)

\* 답글 작성자는 원본 답글 전체를 캐시할 수 있습니다. sa\_cachethis 또는 csa\_cachethis가 FALSE인 경우에도 응답자는 항상 캐시할 수 있습니다. 구현을 단순화하기 위해 이 접근 방식을 선택할 수 있습니다.

\* 응답자는 SEQUENCE 또는 CB\_SEQUENCE 작업에 대한 원래 결과와 NFS4ERR\_RETRY\_UNCACHED\_REP 오류가 있는 COMPOUND 또는 CB\_COMPOUND의 다음 작업으로 구성된 응답을 응답 캐시에 입력합니다. 따라서 요청자가 나중에 요청을 재시도하면 NFS4ERR\_RETRY\_UNCACHED\_REP를 얻게 됩니다. 응답자가 COMPOUND 또는 CB\_COMPOUND에 대한 응답이 캐시되지 않은 재시도된 Sequence 작업을 수신하는 경우 응답자는 다음과 같습니다.

- - Sequence 작업이 첫 번째 작업이 아닌 경우 Sequence 작업에 대한 응답으로 NFS4ERR\_RETRY\_UNCACHED\_REP를 반환할 수 있습니다\(허용됩니다. 그렇게 하는 요청자는 NFSv4.1 프로토콜을 위반하는 것입니다\).\(MAY\)

- - 시퀀스 작업이 첫 번째 작업인 경우 시퀀스 작업에 대한 응답으로 NFS4ERR\_RETRY\_UNCACHED\_REP를 반환해서는 안 됩니다.\(MUST NOT\)

\* 두 번째 작업이 불법 작업이거나 NFSv4의 이전 마이너 버전에서 적법했고 현재 마이너 버전\(예: SETCLIENTID\)에서 지원되어서는 안 되는 작업인 경우 응답자는 NFS4ERR\_RETRY\_UNCACHED\_REP를 반환해서는 안 됩니다. 대신 응답자는 NFS4ERR\_OP\_ILLEGAL, NFS4ERR\_BADXDR 또는 NFS4ERR\_NOTSUPP를 적절하게 반환해야 합니다.\(MUST NOT, MUST\)

\* 두 번째 작업으로 인해 또 다른 오류 상태가 발생할 수 있는 경우 응답자의 상태가 변경되는 방식으로 작업이 실행되지 않는다면 응답자는 NFS4ERR\_RETRY\_UNCACHED\_REP 이외의 상태를 반환할 수 있습니다. 이러한 오류 상태의 예는 다음과 같습니다: 합법적이지만 현재 마이너 버전에서는 필수가 아니므로 응답자가 지원하지 않는 작업에 대해 NFS4ERR\_NOTSUPP가 반환되었습니다. NFS4ERR\_SEQUENCE\_POS; 및 NFS4ERR\_REQ\_TOO\_BIG.\(MAY, MUST\)

위의 논의에서는 재시도된 요청이 원래 요청과 일치한다고 가정합니다. 섹션 2.10.6.1.3.1에서는 응답자가 수행할 수 있는 작업에 대해 설명하고 원본 요청과 재시도된 요청이 일치하지 않을 때 반드시 수행해야 합니다. 응답자는 이것이 잘못된 재시도인지 여부를 결정하는 데 필요한 소량의 정보만 캐시할 수 있으므로 응답자는 다음 응답 중 하나를 클라이언트에 보낼 수 있습니다.\(MUST\)

\* 원래 요청에 대한 캐시된 응답\(응답자가 전체를 캐시했고 원래 요청의 사용자와 재시도가 일치하는 경우\)

\* NFS4ERR\_SEQ\_FALSE\_RETRY 오류가 있는 Sequence 작업만으로 구성된 응답입니다.

\* NFS4ERR\_RETRY\_UNCACHED\_REP 오류 또는 위에 설명된 기타 오류와 함께 재시도된 요청에 나타난 두 번째 작업과 함께 NFS4\_OK 상태의 Sequence에 대한 응답으로 구성된 응답입니다.

\* NFS4ERR\_RETRY\_UNCACHED\_REP 오류 또는 위에 설명된 기타 오류와 함께 원래 요청에 나타난 두 번째 작업과 함께 NFS4\_OK 상태의 Sequence에 대한 응답으로 구성된 응답입니다.

---
####### **2.10.6.1.3.1.  False Retry**

요청자가 응답 캐시에 있는 슬롯 ID 및 시퀀스 ID를 사용하여 시퀀스 작업을 보냈지만 응답자가 다른 작업 또는 작업 인수가 다른 재시도를 포함하여 재시도된 요청이 원래 요청과 동일하지 않음을 감지한 경우 원본과 다른 사용자로 변환되는 RPC 요청의 자격 증명 필드에서 다른 주체를 사용하는 재시도는 잘못된 재시도입니다. 응답자가 잘못된 재시도를 감지하면 Sequence 작업에 대한 응답으로 NFS4ERR\_SEQ\_FALSE\_RETRY를 반환하는 것이 허용됩니다\(항상 의무는 아니지만\).

응답자에 구성된 적절한 보안 자격 증명이 없기 때문에 특히 권한이 있는 사용자 값을 다른 사용자에게 변환하는 것은 사용자가 동일한지 다른지 확인하기 전에 적용되어야 합니다. 응답자가 원래 요청과 재시도 사이에 사용자가 다르다고 판단하면 응답자는 NFS4ERR\_SEQ\_FALSE\_RETRY를 반환해야 합니다.\(MUST\)

재시도 작업이 불법적인 작업이거나 NFSv4의 이전 마이너 버전에서 적법했고 현재 마이너 버전\(예: SETCLIENTID\)에서 지원되어서는 안 되는 작업인 경우 응답자는 NFS4ERR\_SEQ\_FALSE\_RETRY를 반환할 수 있습니다\(반드시 그렇게 해야 합니다\). 원래 요청과 재시도의 사용자가 다른 경우\). 그렇지 않으면 응답자는 적절하게 NFS4ERR\_OP\_ILLEGAL, NFS4ERR\_BADXDR 또는 NFS4ERR\_NOTSUPP를 반환할 수 있습니다. 처리 방법은 응답자가 캐시된 응답 없이 재시도 요청을 처리하는 방식과 대조됩니다. 차이점은 NFS4ERR\_SEQ\_FALSE\_RETRY가 시퀀스 작업에만 유효한 오류인 반면, NFS4ERR\_RETRY\_UNCACHED\_REP는 불법 작업과 NFSv4의 현재 마이너 버전에서 지원해서는 안 되는 작업을 제외한 모든 작업에 유효한 오류이기 때문입니다.\(MUST NOT, MAY, MUST NOT\)

---
##### **2.10.6.2.  Retry and Replay of Reply**

요청자는 요청을 보내는 데 사용한 연결이 끊어지지 않는 한 요청을 재시도해서는 안 됩니다. 그런 다음 요청자는 요청을 다시 연결하고 다시 보내거나 동일한 세션과 연결된 다른 연결을 통해 요청을 다시 보낼 수 있습니다.\(MUST NOT\)

요청자가 세션의 백채널을 통해 콜백 작업을 다시 보내려는 서버인 경우 클라이언트만 백채널과 연결을 연결할 수 있으므로 요청자는 물론 다시 연결할 수 없습니다. 서버는 동일한 세션의 백채널에 바인딩된 다른 연결을 통해 요청을 다시 보낼 수 있습니다. 그러한 연결이 없는 경우 서버는 클라이언트의 다음 SEQUENCE 작업에 대한 응답에서 SEQ4\_STATUS\_CB\_PATH\_DOWN\_SESSION 플래그 비트를 설정하여 세션에 백채널이 없음을 나타내야 합니다. 그런 다음 클라이언트는 연결을 세션과 연결해야 합니다\(또는 세션을 삭제해야 함\).\(MUST, MUST\)

요청과 재시도 사이의 연결을 끊지 않고 요청자가 재시도하는 것은 치명적이지 않습니다. 그러나 재시도는 특히 RDMA의 경우 리소스를 소비하며, 각 요청은 재시도 여부에 관계없이 크레딧을 소비합니다. 이유 없는 재시도, 특히 이전 시도 직후 전송된 재시도는 네트워크 대역폭을 제대로 사용하지 못하고 전송의 고유한 혼잡 제어 시스템의 목적을 무효화합니다.

요청자는 다른 요청에 슬롯을 사용하기 전에 요청에 대한 응답을 기다려야 합니다. 응답을 기다리지 않으면 요청자는 다음 요청 시 슬롯에 어떤 시퀀스 ID를 사용할지 알 수 없습니다. 예를 들어, 요청자가 시퀀스 ID 1로 요청을 보내고 응답을 기다리지 않는다고 가정합니다. 다음에 슬롯을 사용할 때 시퀀스 ID 2의 새 요청을 보냅니다. 응답자가 시퀀스 ID 1의 요청을 보지 못한 경우 응답자는 시퀀스 ID 2를 기대하지 않고 NFS4ERR\_SEQ\_MISORDERED\( SEQUENCE 또는 CB\_SEQUENCE의 결과\).\(MUST\)

RDMA 패브릭은 각 RPC/RDMA "청크"\[32\] 내의 메모리 핸들\(스티어링 태그\)이 단일 연결 범위 외부의 범위에서 유효하다는 것을 보장하지 않습니다. 따라서 직접 작업에 사용된 핸들은 연결이 끊어진 후에는 유효하지 않게 됩니다. 서버는 응답 캐시에서 재생되어야 하는 모든 RDMA 작업이 가장 최근 요청에서 새로 제공된 핸들을 사용하는지 확인해야 합니다.

원래 요청이 응답에서 아직 진행 중인 동안 재시도가 전송될 수 있습니다. 응답자는 SEQUENCE 또는 CB\_SEQUENCE 작업에 대한 응답으로 NFS4ERR\_DELAY를 반환하여 문제를 처리해야 하지만 구현에서는 NFS4ERR\_MISORDERED를 반환할 수 있습니다. SEQUENCE 및 CB\_SEQUENCE의 오류는 응답 캐시에 기록되지 않으므로 이 접근 방식을 사용하면 원래 요청의 실행 결과가 응답 캐시에 올바르게 기록될 수 있습니다\(요청자가 응답을 캐시하도록 지정했다고 가정\).\(SHOULD\)

---
##### **2.10.6.3.  Resolving Server Callback Races**

관련된 전방 채널 작업의 응답 전에 서버 콜백이 클라이언트에 도착할 수 있습니다. 예를 들어, 클라이언트가 자신이 연 파일에 대한 위임을 받았을 수 있지만 OPEN에 대한 응답\(클라이언트에게 위임 승인을 알리는 것\)이 네트워크에서 지연될 수 있습니다. 충돌하는 작업이 서버에 도달하면 다른 전송 연결, 다른 네트워크 또는 동일한 클라이언트 ID와 연결된 다른 세션에 있을 수 있는 백채널을 사용하여 위임을 회수합니다.

클라이언트와 서버 사이에 세션이 있으면 이 문제가 완화됩니다. 세션이 설정되면 각 클라이언트 요청은 {세션 ID, 슬롯 ID, 시퀀스 ID } 트리플로 고유하게 식별됩니다. 슬롯 항목\(응답 캐시 항목\)이 폐기되는 규칙에 따라 서버는 클라이언트가 각 서버 응답을 "봤는지" 여부를 알 수 있습니다. 따라서 서버는 오류가 있거나 충돌하는 콜백 경쟁 조건을 명확하게 구분할 수 있도록 클라이언트에 충분한 정보를 제공할 수 있습니다.

일종의 서버 콜백이 발생할 수 있는 각 클라이언트 작업에 대해 서버는 슬롯 ID 폐기 규칙에 따라 서버가 클라이언트 요청의 {세션 ID, 슬롯 ID, 시퀀스 ID } 삼중을 "기억"해야 합니다. 실제로 서버의 응답을 보았습니다. { 세션 ID, 슬롯 ID, 시퀀스 ID } 요청 트리플이 폐기될 수 있을 때까지 연결된 객체의 모든 호출은 클라이언트의 이익을 위해 이러한 참조 식별자의 배열\(CB\_SEQUENCE 작업 인수에\)을 전달해야 합니다. 이 시간 이후에는 경쟁 조건이 더 이상 발생하지 않을 것이 확실하므로 서버가 관련 콜백에 이 정보를 제공할 필요가 없습니다.\(SHOULD, MUST\)

각 서버 콜백을 시작하는 CB\_SEQUENCE 작업은 "참조" {세션 ID, 슬롯 ID, 시퀀스 ID } 트리플 목록을 전달합니다. 클라이언트가 현재 처리되지 않은 참조 세션 ID, 슬롯 ID 및 시퀀스 ID에 해당하는 요청을 발견한 경우\(즉, 클라이언트가 서버의 응답을 보지 못한 경우\) 콜백이 응답을 경주했다고 판단할 수 있습니다. 그에 따라 행동하십시오. 클라이언트가 참조 트리플에 해당하는 요청이 미해결 상태임을 발견하지 못한 경우\(파괴된 세션을 참조하는 세션 ID의 경우 포함\) 이 트리플과 관련하여 경합이 없습니다. 서버는 참조 트리플을 CB\_COMPOUND 프로시저에서 참조된 객체에 적용되는 요청으로 제한해야 합니다.\(SHOULD\)

클라이언트는 경주에서 승리한 CB\_COMPOUND에 응답하기 전에 예상되는 서버 응답이 도착할 때까지 영원히 기다리면 안 됩니다. 왜냐하면 응답이 무기한 지연될 수 있기 때문입니다. 클라이언트는 서버에 대한 COMPOUND 요청의 평균 왕복 시간 내에 응답이 도착할 가능성이 있는 경우를 가정하고 해당 시간 동안 기다려야 합니다. 해당 기간이 만료되면 NFS4ERR\_DELAY로 CB\_COMPOUND에 응답할 수 있습니다. 콜백이 응답을 경주할 수 있는 다른 시나리오가 있습니다. 그중에는 섹션 12.5.5.2에 설명된 pNFS 레이아웃 리콜이 있습니다.

---
##### **2.10.6.4.  COMPOUND and CB_COMPOUND Construction Issues**

매우 큰 요청과 응답은 버퍼 관리 문제\(특히 RDMA의 경우\)와 응답 캐시 문제를 모두 일으킬 수 있습니다. 세션이 생성되면\(18.36절\) 각 채널\(전면 및 후면\)에 대해 클라이언트와 서버는 보내거나 처리할 최대 크기의 요청\(ca\_maxrequestsize\), 반환하거나 처리할 최대 크기의 응답\(ca\_maxresponsesize\)을 협상합니다. \) 및 응답 캐시에 저장할 최대 크기의 응답\(ca\_maxresponsesize\_cached\)입니다.

요청이 ca\_maxrequestsize를 초과하면 응답 상태는 NFS4ERR\_REQ\_TOO\_BIG가 됩니다. 응답자는 요청의 첫 번째 작업\(SEQUENCE 또는 CB\_SEQUENCE\)에 대한 상태로 NFS4ERR\_REQ\_TOO\_BIG를 반환할 수 있습니다\(이는 요청에 실행된 작업이 없으며 응답 캐시의 슬롯 상태가 변경되지 않음을 의미함\). 동일한 COMPOUND 또는 CB\_COMPOUND 요청의 후속 작업에서 이를 반환합니다. 이는 적어도 하나의 작업이 실행되었고 응답 캐시의 슬롯 상태가 변경되었음을 의미합니다. 응답자는 ca\_maxrequestsize를 초과하는 작업에 NFS4ERR\_REQ\_TOO\_BIG를 설정해야 합니다.\(MAY, SHOULD\)

회신이 ca\_maxresponsesize를 초과하면 회신 상태는 NFS4ERR\_REP\_TOO\_BIG가 됩니다. 응답자는 요청의 첫 번째 작업\(SEQUENCE 또는 CB\_SEQUENCE\)에 대한 상태로 NFS4ERR\_REP\_TOO\_BIG를 반환할 수도 있고, 후속 작업\(동일한 COMPOUND 또는 CB\_COMPOUND 응답에서\)에서 이를 반환하도록 선택할 수도 있습니다. 응답자는 응답이 여전히 ca\_maxresponsesize를 초과하더라도 SEQUENCE 또는 CB\_SEQUENCE에 대한 응답으로 NFS4ERR\_REP\_TOO\_BIG를 반환할 수 있습니다.\(MAY, MAY\)

sa\_cachethis 또는 csa\_cachethis가 TRUE이면 응답자는 SEQUENCE 또는 CB\_SEQUENCE 작업에 의해 오류가 반환되는 경우를 제외하고 응답을 캐시해야 합니다\(섹션 2.10.6.1.2 참조\). 응답이 ca\_maxresponsesize\_cached를 초과하는 경우\(그리고 sa\_cachethis 또는 csa\_cachethis가 TRUE인 경우\) 서버는 NFS4ERR\_REP\_TOO\_BIG\_TO\_CACHE를 반환해야 합니다. NFS4ERR\_REP\_TOO\_BIG\_TO\_CACHE\(또는 해당 문제에 대한 다른 오류\)가 첫 번째 작업\(SEQUENCE 또는 CB\_SEQUENCE\) 이외의 작업에서 반환되는 경우에도 sa\_cachethis 또는 csa\_cachethis가 TRUE이면 응답을 캐시해야 합니다. 예를 들어 COMPOUND에 SEQUENCE를 포함하여 11개의 작업이 있고 다섯 번째 작업이 RENAME이고 10번째 작업이 100만 바이트에 대한 READ인 경우 서버는 10번째 작업에서 NFS4ERR\_REP\_TOO\_BIG\_TO\_CACHE를 반환할 수 있습니다. 서버가 여러 작업, 특히 멱등성이 아닌 RENAME을 실행했기 때문에 정확히 한 번만 의미 체계가 올바르게 작동하려면 응답을 캐시하라는 클라이언트의 요청을 받아들여야 합니다. 클라이언트가 요청을 재시도하면 서버는 요청된 작업 11개 중 10개에 대한 결과가 포함된 응답을 캐시하며, 10번째 작업의 상태는 NFS4ERR\_REP\_TOO\_BIG\_TO\_CACHE입니다.\(MUST, MUST, MUST\)

클라이언트는 현재 파일 핸들을 변경하는 작업\(PUTFH, PUTPUBFH, PUTROOTFH 및 RESTOREFH 제외\)을 보낼 때 GETFH 작업 전 최대 응답 버퍼를 초과하지 않도록 주의해야 합니다. 그렇지 않으면 클라이언트는 원하는 파일 핸들을 얻기 위해 현재 파일 핸들을 변경한 작업을 다시 시도해야 합니다. OPEN 작업\(18.16절 참조\)의 경우 재시도가 항상 옵션으로 제공되는 것은 아닙니다. 파일 핸들 변경 작업 처리에 대해 다음 지침을 따르는 것이 좋습니다.

\* 동일한 COMPOUND 프로시저 내에서 클라이언트는 현재 파일 핸들 변경 작업 직후에 GETFH를 보내야 합니다. 클라이언트는 작업이 RESTOREFH가 아닌 한 멱등성이 아닌 현재 파일 핸들 변경 작업\(예: OPEN 작업\) 후에 GETFH를 보내야 합니다. RESTOREFH는 멱등성이 아니더라도 생성된 파일 핸들 RESTOREFH가 멱등성\(예: PUTFH, LOOKUP\)이거나 비멱등성\(예: OPEN, CREATE\)인 작업에서 시작되었기 때문에 예외입니다. 원본이 멱등성이 아닌 경우 클라이언트는 원본 작업 후에 GETFH를 보내야 하기 때문에 RESTOREFH가 오류를 반환하면 클라이언트는 복구할 수 있습니다.\(SHOULD, MUST, MUST\)

\* 서버는 NFS4ERR\_REP\_TOO\_BIG를 반환하거나

- 다음 작업에서 응답이 너무 클 경우 파일 핸들 변경 작업에 대한 NFS4ERR\_REP\_TOO\_BIG\_TO\_CACHE\(sa\_cachethis가 TRUE인 경우\).\(MAY\)

\* 서버는 NFS4ERR\_REP\_TOO\_BIG를 반환해야 합니다.

- 파일 핸들 변경, 비멱등성 작업에 대한 NFS4ERR\_REP\_TOO\_BIG\_TO\_CACHE\(sa\_cachethis가 TRUE인 경우\), 특히 작업이 OPEN인 경우 다음 작업에서 응답이 너무 클 경우.\(SHOULD\)

\* 서버는 \(동일한 COMPOUND 프로시저에서\) 다음 작업을 살펴보고 GETFH가 아닌 것을 발견한 경우 멱등성이 아닌 현재 파일 핸들 변경 작업에 NFS4ERR\_UNSAFE\_COMPOUND를 반환할 수 있습니다. 서버는 총 응답 크기가 ca\_maxresponsesize\_cached 또는 ca\_maxresponsesize를 초과할지 여부를 미리 결정할 수 없는 경우 이 작업을 수행해야 합니다.\(MAY, SHOULD\)

---
##### **2.10.6.5.  Persistence**

응답 캐시는 제한되어 있으므로 서버를 다시 시작해도 응답 캐시가 지속되는 것이 실용적입니다. 회신자는 세션을 유지하기로 동의한 경우\(세션이 생성되었을 때, 섹션 18.36 참조\) 다음 정보를 유지해야 합니다.\(MUST\)

\* 세션 ID입니다.

\* 각 슬롯에 대한 시퀀스 ID와 캐시된 응답을 포함하는 슬롯 테이블입니다.

위의 내용은 서버가 다시 시작되기 전에 전송되고 실행된 모든 요청에 ​​대해 응답자가 EOS 의미 체계를 제공하는 데 충분합니다. 응답자가 클라이언트인 경우 클라이언트가 클라이언트를 다시 시작하는 동안 다른 모든 상태를 유지하지 않는 한 더 이상 정보를 유지할 필요가 없습니다. 이 경우 서버는 NFSv4.1 수준 프로토콜 표현을 볼 수 없습니다. 클라이언트 재시작 중. 응답자가 슬롯 테이블과 세션 ID만 유지되는 서버인 경우 서버를 다시 시작한 후 클라이언트가 재시도하는 모든 요청은 응답 캐시에 캐시된 결과를 반환하고 모든 새 요청\(즉, 시퀀스 ID는 1입니다. 슬롯의 시퀀스 ID보다 큼\)은 NFS4ERR\_DEADSESSION\(SEQUENCE에 의해 반환됨\)으로 거부되어야 합니다. 이러한 세션은 죽은 것으로 간주됩니다. 서버는 서버를 다시 시작한 후 세션을 다시 활성화하여 세션이 재시도는 물론 새로운 요청도 수락할 수 있도록 할 수 있습니다. 세션을 다시 활성화하려면 서버가 서버 다시 시작을 통해 추가 정보를 유지해야 합니다.\(MUST, MAY\)

\* 클라이언트 ID입니다. 이는 클라이언트가 다시 애니메이션된 세션과 동일한 클라이언트 ID와 연결된 추가 세션을 생성할 수 있도록 하기 위한 전제 조건입니다.

\* 세션 생성에 사용되는 클라이언트 ID의 시퀀스 ID입니다\(섹션 18.35 및 18.36 참조\). 이는 클라이언트가 더 많은 세션을 생성할 수 있도록 하기 위한 전제 조건입니다.

\* 클라이언트 ID를 생성한 주체입니다. 이를 통해 서버는 EXCHANGE\_ID를 보낼 때 클라이언트를 인증할 수 있습니다.

\* SSV\(클라이언트 ID가 생성될 때 SP4\_SSV 상태 보호가 지정된 경우\)\(섹션 18.35 참조\). 이를 통해 클라이언트는 새 세션을 생성하고 새 세션과 기존 세션에 연결을 연결할 수 있습니다.

\* 섹션 18.35에 정의된 클라이언트 ID의 속성.

영구 응답 캐시는 서버에 특정 요구 사항을 적용합니다. 일련의 작업 실행\(SEQUENCE로 시작\)과 해당 결과를 영구 캐시에 배치하는 것은 원자적이어야 합니다. 클라이언트가 이전에 서버에서 실행된 일련의 작업을 재시도하는 경우 허용되는 유일한 결과는 원래 캐시된 응답이거나 클라이언트 ID 또는 세션이 손실되었다는 표시\(응답 캐시 또는 세션의 치명적인 손실을 나타냄\)입니다. 클라이언트가 장기간 세션을 사용하지 못해 삭제된 것입니다\).\(MUST\)

하나 이상의 멱등성이 없거나 수정하는 작업이 포함된 COMPOUND 프로시저 도중에 서버가 실패하고 다시 시작될 수 있습니다. 이로 인해 원자 실행 및 응답 캐시에 결과 배치에 대한 훨씬 더 높은 문제가 발생합니다. 문제를 보는 한 가지 방법은 COMPOUND의 각 작업으로 구성된 단일 트랜잭션과 그 결과를 영구 저장소에 저장한 다음 마지막으로 트랜잭션 커밋으로 보는 것입니다. 트랜잭션이 커밋되기 전에 오류가 발생하면 서버는 트랜잭션을 롤백합니다. 서버 자체에 오류가 발생한 경우 서버를 다시 시작하면 해당 복구 논리가 NFSv4.1 서버를 시작하기 전에 트랜잭션을 롤백할 수 있습니다.

요청의 원자적 실행 및 응답 캐싱에 대한 구현에 대한 설명은 이 문서의 범위를 벗어나지만 NFSv2\[45\]에 대한 예제 구현은 \[46\]에 설명되어 있습니다.

---
#### **2.10.7.  RDMA Considerations**

RDMA 전송을 통한 RPC 기반 프로토콜의 작동에 대한 완전한 논의는 \[32\]에 있습니다. RDMA를 통한 NFSv4.1을 포함한 NFSv4의 작동에 대한 논의는 \[33\]에 있습니다. RDMA가 고려되는 경우 이 사양에서는 이러한 계층화의 사용을 가정합니다. RPC/RDMA를 최대한 활용하는 것과 관련된 상위 계층 문제만 다룹니다.

---
##### **2.10.7.1.  RDMA Connection Resources**

RDMA에서는 소비자가 수신 작업을 위해 특정 크기와 개수의 메모리와 게시 버퍼를 등록해야 합니다.

메모리 등록은 버퍼 고정, 속성 할당\(예: 읽기/쓰기 가능\) 및 하드웨어 변환 초기화가 필요하기 때문에 상대적으로 오버헤드가 높은 작업일 수 있습니다. 오버헤드를 줄이려면 사전 등록이 바람직합니다. 이러한 등록은 하드웨어 인터페이스 및 RDMA 연결 엔드포인트에만 적용됩니다. 따라서 자원을 효과적으로 관리하려면 한계를 협상하는 것이 바람직합니다.

기본 등록 후에는 수신을 처리하기 위해 RPC 계층에서 이러한 버퍼를 게시해야 합니다. 이러한 버퍼는 RPC/NFSv4.1 구현에서 계속 사용됩니다. RDMA 연결에서 치명적인 오류를 일으킬 수 있는 RDMA 오류를 방지하려면 해당 크기와 개수를 원격 피어에 알려야 합니다.

NFSv4.1은 세션별로 슬롯을 리소스로 관리하는 반면\(섹션 2.10 참조\), RDMA 연결은 연결별로 크레딧을 관리합니다. 이는 피어가 RDMA를 통해 원격 버퍼로 데이터를 보내려면 NFSv4.1 슬롯과 RDMA 크레딧이 모두 있어야 함을 의미합니다. 여러 RDMA 연결이 세션과 연결된 경우 해당 세션과 연결된 모든 RDMA 연결의 총 크레딧 수가 X이고 세션의 슬롯 수가 Y인 경우 미해결 요청의 최대 수는 다음 중 더 작습니다. X와 Y.

---
##### **2.10.7.2.  Flow Control**

이전 버전의 NFS는 흐름 제어를 제공하지 않습니다. 대신 TCP와 같은 전송에서 제공하는 윈도우 기능을 사용하여 요청을 제한합니다. 이는 작업 흐름 제어를 제공하지 않고 제한을 초과할 때 오류로 연결을 종료하는 RDMA에서는 작동하지 않습니다. 따라서 최대 요청 수와 같은 제한은 세션이 생성될 때 협상됩니다\(섹션 18.36의 ca\_maxrequests 필드 참조\). 그런 다음 이러한 제한은 세션의 채널과 연결된 각 연결이 유지되어야 하는 최대값을 제공합니다. RDMA 연결은 \[32\]의 섹션 3.3에 설명된 대로 이러한 제한 내에서 관리됩니다. RDMA 연결이 여러 개인 경우 채널에 대한 최대 요청 수가 RDMA 연결 간에 나누어집니다. 다르게 말하면, 응답자 채널과 연관된 모든 연결에서 총 RDMA 크레딧 수가 채널의 최대 미해결 요청 수를 초과하는지 확인하는 책임은 응답자에게 있습니다.

각 NFSv4.1 응답에 있는 특정 매개변수를 조작하여 응답자의 선택에 따라 제한을 동적으로 수정할 수도 있습니다. 또한 CB\_RECALL\_SLOT 콜백 작업\(섹션 20.8 참조\)은 서버에서 클라이언트로 전송되어 RDMA 크레딧을 서버에 반환할 수 있으므로 클라이언트가 서버에 대해 처리할 수 있는 최대 요청 수를 낮출 수 있습니다.

---
##### **2.10.7.3.  Padding**

헤더 패딩은 세션 시작 시 각 피어에 의해 요청되며\(섹션 18.36의 CREATE\_SESSION에 대한 ca\_headerpadsize 인수 참조\), 이후 \[32\]에 설명된 대로 RPC RDMA 계층에서 사용됩니다. 제로 패딩이 허용됩니다.

패딩은 데이터가 익명\(태그 없음\) 버퍼에 배치된 경우에도 RDMA가 데이터 정렬을 유지하는 유용한 속성을 활용합니다. 요청된 경우 클라이언트 인라인 쓰기는 요청 헤더 내에 적절한 패드 바이트를 삽입하여 지정된 경계에 데이터 페이로드를 정렬합니다. 클라이언트는 WRITE 작업의 "데이터" 필드가 정렬되도록 충분한 패딩\(협상된 크기까지\)을 추가하는 것이 좋습니다. 대부분의 서버는 이러한 패딩을 잘 활용할 수 있습니다. 이를 통해 클라이언트 요청에 의해 전달된 모든 데이터가 파일 시스템 처리 준비가 된 서버의 적절한 버퍼에 배치되는 방식으로 수신 버퍼를 연결할 수 있습니다. 수신자의 RPC 계층은 패드 바이트를 건너뛰는 데 따른 오버헤드가 발생하지 않으며 RDMA 계층의 높은 성능으로 인해 송신자에 대한 패딩 삽입 및 전송이 크게 최적화됩니다. 이러한 방식으로 서버가 가장 큰 클라이언트 쓰기를 제외한 모든 쓰기를 만족시키기 위해 RDMA 읽기를 수행할 필요성이 제거됩니다. 추가적인 이점은 네트워크에서 메시지 왕복이 감소한다는 것입니다. 이는 대기 시간이 존재하는 경우 잠재적으로 좋은 거래입니다.

패딩을 위해 선택할 값에는 다양한 기준이 적용됩니다. RPC 헤더에 있는 가변 길이 데이터의 주요 소스는 인증 정보이며, 그 형식은 서버 사양에 따라 클라이언트가 결정합니다. COMPOUND의 내용, RENAME에 전달된 문자열 크기 등은 모두 최대 NFSv4.1 요청 크기와 최소 버퍼 크기를 결정하는 데 사용됩니다. 클라이언트는 서버에 과도한 부담을 주지 않도록 제공된 값을 신중하게 선택해야 하며, 그 반대의 경우도 마찬가지입니다. 적절한 패딩 값의 이점은 성능이 향상된다는 것입니다.

```text
                    Sender gather:
        |RPC Request|Pad  bytes|Length| -> |User data...|
        \------+----------------------/      \
                \                             \
                 \    Receiver scatter:        \-----------+- ...
            /-----+----------------\            \           \
            |RPC Request|Pad|Length|   ->  |FS buffer|->|FS buffer|->...
```

위의 경우 서버는 실제 수신된 요청에 사용되지 않은 경우 사용되지 않은 버퍼를 다음 게시된 수신으로 재활용하거나 정상적인 쓰기 처리를 위해 참조로 현재 완료된 버퍼를 전달할 수 있습니다. 이를 활용할 수 있는 서버의 경우 복잡한 종단 간 버퍼 광고 및 관리에 의존하지 않고도 들어오는 데이터의 데이터 복사본이 필요하지 않습니다. 여기에는 대부분의 커널 기반 및 통합 서버 설계가 포함됩니다. 원하는 경우 클라이언트는 유사한 최적화를 수행할 수 있습니다.

---
##### **2.10.7.4.  Dual RDMA and Non-RDMA Transports**

일부 RDMA 전송\(예: RFC 5040 \[8\]\)은 RDMA 트래픽을 시작하여 RDMA 모드로 "단계화"하기 전에 일반 트래픽이 흐를 수 있는 "스트리밍"\(비RDMA\) 단계를 허용합니다. 일부 RDMA 전송은 항상 RDMA 모드에서 연결을 시작합니다. NFSv4.1은 RDMA 모드 이전의 스트리밍 단계를 허용하지만 가정하지는 않습니다. 연결이 세션과 연결되면 클라이언트와 서버는 연결이 RDMA 또는 비RDMA 모드에서 사용되는지 여부를 협상합니다\(섹션 18.36 및 18.34 참조\).

---
#### **2.10.8.  Session Security**
---
##### **2.10.8.1.  Session Callback Security**

NFSv4.1은 세션/연결 연결을 통해 백채널에 대해 NFSv4.0에서 제공하는 것보다 보안을 향상시킵니다. 연결은 클라이언트에서 시작되며\(18.34절 참조\) 전면 채널과 동일한 방화벽 및 라우팅 검사를 받습니다. 클라이언트의 선택에 따라\(섹션 18.35 참조\) 연결 연관은 활성화되기 전에 완전히 인증됩니다\(섹션 18.34 참조\). 백채널을 통한 서버의 트래픽은 클라이언트가 지정한 대로 정확하게 인증됩니다\(섹션 2.10.8.2 참조\).

---
##### **2.10.8.2.  Backchannel RPC Security**

NFSv4.1 클라이언트는 백채널을 설정할 때 요청을 보낼 때 사용할 보안 특징과 주체를 서버에 알립니다. 보안 특성이 RPCSEC\_GSS인 경우 클라이언트는 설정된 RPCSEC\_GSS 컨텍스트 형식으로 주체를 표현합니다. 서버는 클라이언트가 제공하는 플레이버/주요 조합을 자유롭게 사용할 수 있지만 제공되지 않는 조합을 사용해서는 안 됩니다. 이렇게 하면 클라이언트는 NFSv4.0에서처럼 백채널에 대한 대상 GSS 주체를 제공할 필요가 없고, 서버는 NFSv4.0에서 했던 것처럼 RPCSEC\_GSS 개시자를 구현할 필요가 없습니다\[37\].\(MUST NOT\)

CREATE\_SESSION\(섹션 18.36\) 및 BACKCHANNEL\_CTL\(섹션 18.33\) 작업을 통해 클라이언트는 플레이버/주체 조합을 지정할 수 있습니다.

또한 SP4\_SSV 상태 보호 모드\(섹션 18.35 및 2.10.8.3 참조\)에는 SSV 파생 RPCSEC\_GSS 컨텍스트\(섹션 2.10.9\)를 제공하는 측면 이점이 있습니다.

---
##### **2.10.8.3.  Protection from Unauthorized State Changes**

사양의 이 지점에 설명된 대로 NFSv4.1의 상태 모델은 위조된 세션 ID와 합법적인 클라이언트가 다음에 사용할 것으로 예상되는 슬롯 ID를 사용하여 SEQUENCE 작업을 보내는 공격자에게 취약합니다. 합법적인 클라이언트가 동일한 시퀀스 번호를 가진 슬롯 ID를 사용하면 서버는 응답 캐시에서 공격자의 결과를 반환하고, 이는 합법적인 클라이언트를 방해하여 서비스를 거부합니다. 마찬가지로, 공격자는 위조된 클라이언트 ID와 함께 CREATE\_SESSION을 보내 해당 클라이언트 ID와 연결된 새 세션을 생성할 수 있습니다. 공격자는 합법적인 클라이언트가 획득한 잠금을 해제하기 위한 LOCKU 작업과 같이 잠금 상태를 변경하는 새 세션을 사용하여 요청을 보낼 수 있습니다. 파일 상태를 조작할 때 RPCSEC\_GSS 자격 증명을 요구하는 보안 정책을 파일에 설정하는 것은 잠재적인 해결 방법 중 하나이지만 RPCSEC\_GSS가 필요한 경우 합법적인 클라이언트가 상태를 공개하지 못하게 하는 단점이 있지만 GSS 컨텍스트를 얻을 수 없습니다\( 아마도 사용자가 클라이언트에서 로그오프했기 때문일 수 있습니다\).

NFSv4.1은 클라이언트가 EXCHANGE\_ID\(섹션 18.35\)를 통해 클라이언트 ID를 생성할 때 지정되는 상태 보호를 위해 클라이언트에 세 가지 옵션을 제공합니다.

첫 번째\(SP4\_NONE\)는 단순히 상태 보호를 포기하는 것입니다.

다른 두 옵션\(SP4\_MACH\_CRED 및 SP4\_SSV\)은 몇 가지 특성을 공유합니다.

\* RPCSEC\_GSS 기반 자격 증명은 세션 생성 및 삭제, 세션과 연결 연결, 클라이언트 ID 삭제를 포함하여 클라이언트 ID 및 세션 유지 관리 작업을 인증하는 데 사용됩니다.

\* RPCSEC\_GSS는 클라이언트 ID 인증 및 세션 유지에 사용되기 때문에 공격자는 CLOSE, LOCKU, DELEGRETURN, LAYOUTRETURN 등

\* 네임스페이스 일부에 대한 서버의 보안 정책에 RPCSEC\_GSS 인증이 필요한 경우 클라이언트는 RPCSEC\_GSS 자격 증명을 사용하여 파일별 상태\(예: LOCKU, CLOSE 등\)를 제거해야 할 수 있습니다. 서버는 상태를 제거하는 주체가 특정 기준과 일치하도록 요구할 수 있습니다\(예: 주체는 상태를 획득한 주체와 동일해야 할 수 있습니다\). 그러나 클라이언트에는 해당 주체에 대한 RPCSEC\_GSS 컨텍스트가 없을 수도 있고 그러한 컨텍스트를 생성하지 못할 수도 있습니다\(아마도 사용자가 로그오프했기 때문일 수 있음\). 클라이언트가 SP4\_MACH\_CRED 또는 SP4\_SSV 보호를 설정할 때 서버가 컴퓨터 자격 증명\(SP4\_MACH\_CRED가 사용되는 경우\) 또는 SSV 자격 증명\(SP4\_SSV가 사용되는 경우\)을 사용하여 허용해야 하는 작업 목록을 지정할 수 있습니다.\(MUST\)

SP4\_MACH\_CRED 상태 보호 옵션은 클라이언트 ID를 생성하는 주체가 클라이언트 ID 및 세션 유지 관리 작업을 수행하는 주체이기도 해야 하는 시스템 자격 증명을 사용합니다. 머신 자격 증명 상태 보호 접근 방식의 보안은 전적으로 머신별 자격 증명을 보호하는 데 달려 있습니다. CREATE\_SESSION, BIND\_CONN\_TO\_SESSION, DESTROY\_SESSION 및 DESTROY\_CLIENTID와 같은 작업에 대해 머신별 자격 증명을 사용하여 적절한 보호 조치를 취하면 공격자가 불량 연결을 세션과 연결하거나 불량 세션을 클라이언트 ID와 연결하는 것을 방지할 수 있습니다.\(MUST\)

SP4\_MACH\_CRED 옵션에는 최소한 세 가지 시나리오가 있습니다.

1. 시스템 관리자는 필수 GSS 메커니즘 중 하나에 대해 고유하고 영구적인 컴퓨터별 자격 증명을 구성합니다\(예: Kerberos V5를 사용하는 경우 클라이언트 호스트 이름에서 파생된 주체가 포함된 "keytab"을 사용할 수 있음\).

2. 클라이언트는 단일 사용자가 사용하므로 클라이언트 ID와 해당 세션은 해당 사용자만 사용합니다. 사용자의 자격 증명이 만료되면 세션 및 클라이언트 ID 유지 관리가 발생할 수 없지만 클라이언트에는 단일 사용자가 있으므로 해당 사용자만 불편을 겪습니다.

3. 물리적 클라이언트에는 여러 사용자가 있지만 클라이언트는

- 구현에는 각 사용자마다 고유한 클라이언트 ID가 있습니다. 이는 사실상 두 번째 시나리오와 동일하지만, 각 사용자에게 최소한 하나의 세션을 할당해야 하므로 접근 방식의 경제성이 떨어지는 단점이 있습니다.

SP4\_SSV 보호 옵션은 RPCSEC\_GSS 및 SSV GSS 메커니즘\(섹션 2.10.9\)을 통해 SSV\(섹션 1.7\)를 사용하여 공격으로부터 상태를 보호합니다. SP4\_SSV 보호 옵션은 활성 사용자가 여러 명 있는 클라이언트와 각 클라이언트에 영구 컴퓨터 자격 증명을 설치해야 하는 부담을 피하려는 시스템 관리자로 구성된 상황을 위한 것입니다. SSV는 SET\_SSV를 통해 서버에서 설정되고 업데이트됩니다\(섹션 18.47 참조\). 도청을 방지하려면 클라이언트는 개인 정보 보호 서비스와 함께 RPCSEC\_GSS를 통해 SET\_SSV를 보내야 합니다. SSV의 여러 측면은 공격자가 SSV를 추측하기 어렵게 만들어서 불량 연결을 세션과 연결하고 불량 세션을 클라이언트 ID와 연결합니다.\(SHOULD\)

\* SET\_SSV에 대한 인수와 결과에는 각각 이전 SSV와 새 SSV의 다이제스트가 포함됩니다.

\* SSV의 초기 값은 0이므로 SP4\_SSV 보호를 선택하고 BIND\_CONN\_TO\_SESSION 및 CREATE\_SESSION에 SP4\_SSV 보호를 적용하기로 선택한 클라이언트는 첫 번째 BIND\_CONN\_TO\_SESSION 작업 이전 또는 두 번째 CREATE\_SESSION 작업 이전에 최소한 하나의 SET\_SSV 작업을 보내야 합니다. 클라이언트 ID. 그렇지 않은 경우 SSV 메커니즘은 토큰을 생성하지 않습니다\(섹션 2.10.9\). 클라이언트는 세션이 생성되자마자 SET\_SSV를 보내야 합니다.\(MUST, SHOULD\)

\* SET\_SSV 요청은 SSV를 SET\_SSV에 대한 인수로 대체하지 않습니다. 대신 서버의 현재 SSV는 SET\_SSV에 대한 인수와 논리적으로 배타적 OR\(XOR\)입니다. 새로운 주체가 처음으로 클라이언트 ID를 사용할 때마다 클라이언트는 RPCSEC\_GSS 서비스가 RPC\_GSS\_SVC\_PRIVACY로 설정된 상태에서 해당 주체의 RPCSEC\_GSS 자격 증명과 함께 SET\_SSV를 보내야 합니다.\(SHOULD\)

Bob이라는 피해자에게 Eve라는 공격자가 시도할 수 있는 공격 유형과 SP4\_SSV 보호가 각 공격을 저지하는 방법은 다음과 같습니다.

\* Eve가 합법적인 클라이언트에 로그인한 첫 번째 사용자라고 가정합니다. Eve가 NFSv4.1 파일 시스템을 사용하면 합법적인 클라이언트가 BIND\_CONN\_TO\_SESSION 작업이 반드시 SSV 자격 증명을 사용해야 함을 지정하여 SP4\_SSV 보호가 포함된 클라이언트 ID를 생성하게 됩니다. Eve가 파일 시스템을 사용하면 SSV도 생성됩니다. SSV를 생성하는 SET\_SSV 작업은 Eve의 GSS 주체 및 자격 증명을 사용하는 합법적인 클라이언트가 생성한 RPCSEC\_GSS 컨텍스트에 의해 보호됩니다. Eve는 자신의 RPCSEC\_GSS 컨텍스트가 생성되고 자신의 컨텍스트를 사용하는 SET\_SSV가 전송되는 동안 네트워크를 도청할 수 있습니다. 합법적인 클라이언트가 RPC\_GSS\_SVC\_PRIVACY와 함께 SET\_SSV를 보내더라도 Eve는 자신의 자격 증명을 알고 있으므로 SSV를 해독할 수 있습니다. Eve는 BIND\_CONN\_TO\_SESSION이 수락할 RPCSEC\_GSS 자격 증명을 계산하여 새로운 연결을 합법적인 세션과 연결할 수 있습니다. Eve는 Bob이 동일한 합법적인 클라이언트를 통해 서버에 액세스할 때 합법적인 클라이언트가 세션을 사용할 수 없도록 하는 방식으로 합법적인 세션의 슬롯 ID와 시퀀스 상태 및/또는 SSV 상태를 변경할 수 있습니다.\(MUST\)

- 클라이언트의 유일한 수단은 Bob이 사용할 새 클라이언트 ID를 생성하고 클라이언트 ID에 대한 새 SSV를 설정하는 것입니다. 클라이언트는 이전 클라이언트 ID를 삭제할 수 없으며 이전 클라이언트 ID에 대한 임대가 만료되도록 합니다.

- 합법적인 클라이언트가 Bob의 RPCSEC\_GSS 컨텍스트를 사용하여 새 세션에 대해 SSV를 설정하면 Eve는 합법적인 클라이언트를 통해 새 세션을 사용할 수 있지만 Bob을 방해할 수는 없습니다. 더욱이 클라이언트는 Eve가 새 세션을 사용하기 때문에 SSV를 수정해야 하므로 Bob은 불량 연결을 세션과 연결하여 Eve에게 복수할 수 없습니다.\(SHOULD\)

- 문제는 합법적인 클라이언트가 Eve가 이전 세션을 하이재킹했다는 사실을 어떻게 감지했는가 하는 것입니다. 클라이언트가 새로운 주체인 Bob이 세션을 사용하려고 한다는 것을 감지하면 다음 하위 시나리오로 이어지는 SET\_SSV를 보내야 합니다.\(SHOULD\)

- - 불량 연결에서 Eve가 나중에 합법적인 클라이언트가 사용하는 것과 동일한 슬롯 ID 및 시퀀스 ID를 사용하여 SET\_SSV를 보냈다고 가정해 보겠습니다. 서버는 Bob의 자격 증명과 함께 전송된 SET\_SSV를 재시도라고 가정하고 Eve에게 보낸 응답을 합법적인 클라이언트에 반환합니다. 그러나 Eve가 합법적인 클라이언트가 사용할 SSV를 올바르게 추측할 수 없으면 SET\_SSV 응답의 다이제스트 확인 확인이 실패합니다. 이는 세션이 분명히 하이재킹되었음을 클라이언트에 표시하는 것입니다.

- - 또는 Eve는 합법적인 클라이언트가 SET\_SSV에 사용하는 것과 다른 슬롯 ID를 사용하여 SET\_SSV를 보냈습니다. 그러면 Bob의 자격 증명과 함께 전송된 SET\_SSV의 다이제스트 확인이 서버에서 실패하고 클라이언트에 반환된 오류를 통해 세션이 하이재킹되었음을 알 수 있습니다.

- - 또는 Eve는 SET\_SSV가 아닌 작업을 보냈지만 합법적인 클라이언트가 SET\_SSV에 사용하는 것과 동일한 슬롯 ID 및 시퀀스를 사용했습니다. 서버는 Eve에게 보낸 응답을 합법적인 클라이언트에게 반환합니다. 클라이언트는 응답이 예상한 것과 전혀 다르다는 것을 알게 됩니다. 클라이언트는 세션 하이재킹이나 서버 버그를 가정하고 어느 쪽이든 이전 세션을 파괴합니다.

\* Eve는 위와 같이 세션에 Rogue 연결을 연결한 후 세션을 파괴합니다. 이번에도 Bob은 Bob의 자격 증명을 사용하여 SET\_SSV를 보내는 합법적인 클라이언트의 서버를 사용합니다. 클라이언트는 세션이 존재하지 않음을 나타내는 오류를 수신합니다. 클라이언트가 새 세션을 생성하려고 하면 SSV가 서버의 SSV와 일치하지 않기 때문에 실패하게 되며 이제 클라이언트는 세션이 하이재킹되었음을 알게 됩니다. 합법적인 클라이언트는 새로운 클라이언트 ID를 설정합니다.

\* Eve가 합법적인 클라이언트보다 먼저 연결을 생성하는 경우

- SSV를 설정합니다. SSV의 초기 값은 0이므로 알려져 있으므로 Eve는 다이제스트 검증 검사를 통과하는 SET\_SSV를 보낼 수 있습니다. 그러나 새 연결이 세션과 연결되지 않았기 때문에 SET\_SSV가 거부됩니다.

요약하면, SP4\_SSV 보호가 사용 중일 때 공격자의 상태 중단은 클라이언트 ID의 형성 기간, 첫 번째 세션 및 SSV 설정으로 제한됩니다. 악의적이지 않은 사용자가 클라이언트 ID를 사용하면 클라이언트는 신속하게 하이재킹을 감지하고 상황을 수정합니다. 악의적이지 않은 사용자가 SSV를 성공적으로 수정하면 공격자는 NFSv4.1 작업을 사용하여 악의적이지 않은 사용자를 방해할 수 없습니다.

SP4\_MACH\_CRED나 SP4\_SSV 보호 접근 방식 모두 이전에 세션과 연결된 전송 연결 하이재킹을 방지하지 못합니다. 위협 대응 전략의 목표가 연결 하이재킹을 방지하는 것이라면 IPsec을 사용하는 것이 좋습니다.\(SHOULD\)

연결 하이재킹이 발생하면 하이재커는 이론적으로 잠금 상태를 변경하고 합법적인 클라이언트에 대한 서비스에 부정적인 영향을 미칠 수 있습니다. 그러나 영향을 받는 파일 개체에 대한 무결성 또는 개인 정보 보호와 함께 RPCSEC\_GSS를 사용하도록 서버가 구성되고 EXCHGID4\_FLAG\_BIND\_PRINC\_STATEID 기능\(18.35절\)이 적용되는 경우 잠금 상태를 변경하려는 무단 시도가 방지됩니다.

---
#### **2.10.9.  The Secret State Verifier (SSV) GSS Mechanism**

SSV는 NFSv4.1이 상태 보호를 위해 사용하는 NFSv4.1 내부의 GSS 메커니즘에 대한 비밀 키를 제공합니다. 이 메커니즘에 대한 컨텍스트는 RPCSEC\_GSS 프로토콜을 통해 설정되지 않습니다. 대신 EXCHANGE\_ID가 SP4\_SSV 보호를 지정하면 컨텍스트가 자동으로 생성됩니다. 정의된 유일한 토큰은 PerMsgToken\(GSS\_GetMIC에 의해 생성됨\) 및 SealedMessage 토큰\(GSS\_Wrap에 의해 생성됨\)입니다.

SSV 메커니즘의 메커니즘 OID는 iso.org.dod.internet.private.enterprise.Michael Eisler.nfs.ssv\_mech\(1.3.6.1.4.1.28882.1.1\)입니다. SSV 메커니즘은 초기 컨텍스트 토큰을 정의하지 않지만 OID를 사용하면 클라이언트가 SECINFO 또는 SECINFO\_NO\_NAME 작업을 보낼 때마다 SSV 메커니즘이 허용됨을 서버가 나타낼 수 있습니다\(섹션 2.6 참조\).

SSV 메커니즘은 SSV 값에서 파생된 4개의 하위 키를 정의합니다. SET\_SSV가 호출될 때마다 클라이언트와 서버가 하위 키를 다시 계산합니다. 4개의 하위 키 각각의 계산은 4개의 해당 ssv\_subkey4 열거 값에 따라 달라집니다. 계산에서는 현재 SSV를 키로 사용하는 HMAC \[52\] 알고리즘, EXCHANGE\_ID로 협상되는 단방향 해시 알고리즘, 데이터 유형 ssv\_subkey4의 하위 키에 대한 XDR 인코딩 열거형 값으로 표시되는 입력 텍스트를 사용합니다. HMAC 알고리즘의 출력 길이가 암호화 알고리즘의 키 길이\(EXCHANGE\_ID로도 협상됨\)를 초과하는 경우 하위 키는 HMAC 출력에서 ​​잘려야 합니다. 즉, 하위 키의 길이가 N 바이트인 경우 그런 다음 HMAC 출력의 처음 N 바이트를 하위 키에 사용해야 합니다. EXCHANGE\_ID 사양에는 HMAC 알고리즘의 출력 길이가 암호화 알고리즘에 필요한 하위 키 길이보다 작아서는 안 된다고 명시되어 있습니다\(섹션 18.35 참조\).\(MUST, MUST NOT\)

```text
   /* Input for computing subkeys */
   enum ssv_subkey4 {
           SSV4_SUBKEY_MIC_I2T     = 1,
           SSV4_SUBKEY_MIC_T2I     = 2,
           SSV4_SUBKEY_SEAL_I2T    = 3,
           SSV4_SUBKEY_SEAL_T2I    = 4
   };
```

SSV4\_SUBKEY\_MIC\_I2T에서 파생된 하위 키는 포어 채널을 통한 요청 또는 백채널을 통한 응답의 일부로 NFSv4.1 클라이언트에서 발생하는 MIC\(메시지 무결성 코드\)를 계산하는 데 사용됩니다. SSV4\_SUBKEY\_MIC\_T2I에서 파생된 하위 키는 NFSv4.1 서버에서 발생하는 MIC에 사용됩니다. SSV4\_SUBKEY\_SEAL\_I2T에서 파생된 하위 키는 NFSv4.1 클라이언트에서 시작되는 암호화 텍스트에 사용되고, SSV4\_SUBKEY\_SEAL\_T2I에서 파생된 하위 키는 NFSv4.1 서버에서 시작되는 암호화 텍스트에 사용됩니다.

PerMsgToken 설명은 XDR 정의를 기반으로 합니다.

```text
   /* Input for computing smt_hmac */
   struct ssv_mic_plain_tkn4 {
     uint32_t        smpt_ssv_seq;
     opaque          smpt_orig_plain<>;
   };

   /* SSV GSS PerMsgToken token */
   struct ssv_mic_tkn4 {
     uint32_t        smt_ssv_seq;
     opaque          smt_hmac<>;
   };
```

smt\_hmac 필드는 SSV4\_SUBKEY\_MIC\_I2T 또는 SSV4\_SUBKEY\_MIC\_T2I에서 파생된 하위 키를 키로 사용하고 EXCHANGE\_ID로 협상된 단방향 해시 알고리즘 및 ssv\_mic\_plain\_tkn4 유형의 데이터로 표시되는 입력 텍스트를 사용하여 계산된 HMAC입니다. smpt\_ssv\_seq 필드는 smt\_ssv\_seq와 동일합니다. smpt\_orig\_plain 필드는 GSS\_GetMIC\(\)에 전달된 "메시지" 입력입니다\(\[7\]의 섹션 2.3.1 참조\). GSS\_GetMIC\(\) 호출자는 일반 텍스트가 포함된 버퍼에 대한 포인터를 제공합니다. GSS\_GetMIC\(\)에 대한 SSV 메커니즘의 진입점은 이를 불투명 배열로 인코딩하며 인코딩에는 초기 4바이트 길이와 필요한 패딩이 포함됩니다. 여기에는 smpt\_ssv\_seq의 XDR 인코딩 값이 추가되어 데이터 유형 ssv\_mic\_plain\_tkn4 값의 XDR 인코딩을 구성하며 이는 차례로 HMAC에 대한 입력이 됩니다.

GSS\_GetMIC\(\)에 의해 방출된 토큰은 XDR로 인코딩되었으며 XDR 데이터 유형 ssv\_mic\_tkn4입니다. smt\_ssv\_seq 필드는 클라이언트 ID에서 SET\_SSV\(섹션 18.47\)가 처음 호출된 후의 1과 동일한 SSV 시퀀스 번호에서 가져옵니다. 이후 SSV 시퀀스 번호는 각 SET\_SSV에서 증가됩니다. 따라서 smt\_ssv\_seq는 GSS\_GetMIC\(\)이 호출된 당시의 SSV 버전을 나타냅니다. 섹션 18.35에 명시된 대로 클라이언트와 서버는 SSV의 여러 동시 버전을 유지할 수 있습니다. 이를 통해 SET\_SSV 작업과 함께 SSV 메커니즘을 사용하는 모든 RPC 호출을 직렬화하지 않고도 SSV를 변경할 수 있습니다. HMAC가 계산되면 smt\_hmac로 XDR 인코딩됩니다. 여기에는 초기 4바이트 길이와 필요한 패딩이 포함됩니다. 이 앞에는 smt\_ssv\_seq의 XDR 인코딩 값이 추가됩니다.

SealedMessage 설명은 XDR 정의를 기반으로 합니다.

```text
   /* Input for computing ssct_encr_data and ssct_hmac */
   struct ssv_seal_plain_tkn4 {
     opaque          sspt_confounder<>;
     uint32_t        sspt_ssv_seq;
     opaque          sspt_orig_plain<>;
     opaque          sspt_pad<>;
   };

   /* SSV GSS SealedMessage token */
   struct ssv_seal_cipher_tkn4 {
     uint32_t      ssct_ssv_seq;
     opaque        ssct_iv<>;
     opaque        ssct_encr_data<>;
     opaque        ssct_hmac<>;
   };
```

GSS\_Wrap\(\)이 내보낸 토큰은 XDR로 인코딩되었으며 XDR 데이터 유형 ssv\_seal\_cipher\_tkn4입니다.

ssct\_ssv\_seq 필드는 smt\_ssv\_seq와 동일한 의미를 갖습니다.

ssct\_encr\_data 필드는 XDR 인코딩 데이터 유형 ssv\_seal\_plain\_tkn4의 값을 암호화한 결과입니다. 암호화 키는 SSV4\_SUBKEY\_SEAL\_I2T 또는 SSV4\_SUBKEY\_SEAL\_T2I에서 파생된 하위 키이고, 암호화 알고리즘은 EXCHANGE\_ID로 협상된 것입니다.

ssct\_iv 필드는 암호화 알고리즘\(해당되는 경우\)에 대한 초기화 벡터\(IV\)이며 일반 텍스트로 전송됩니다. IV의 내용과 크기는 암호화 알고리즘의 사양을 준수해야 합니다. 예를 들어, id-aes256-CBC 알고리즘은 16바이트 초기화 벡터\(IV\)를 사용해야 하며, 이는 특정 SSV 키로 암호화된 ssv\_seal\_plain\_tkn4 데이터 유형 값의 각 인스턴스에 대해 예측할 수 없어야 합니다.\(MUST, MUST\)

ssct\_hmac 필드는 XDR 인코딩 데이터 유형 ssv\_seal\_plain\_tkn4의 값을 입력 텍스트로 사용하여 HMAC를 계산한 결과입니다. 키는 SSV4\_SUBKEY\_MIC\_I2T 또는 SSV4\_SUBKEY\_MIC\_T2I에서 파생된 하위 키이고, 단방향 해시 알고리즘은 EXCHANGE\_ID에 의해 협상되는 것입니다.

sspt\_confounder 필드는 임의의 값입니다.

sspt\_ssv\_seq 필드는 ssvt\_ssv\_seq와 동일합니다.

sspt\_orig\_plain 필드는 원래 일반 텍스트이며 GSS\_Wrap\(\)에 전달된 "input\_message" 입력입니다\(\[7\]의 섹션 2.3.3 참조\). SSV 메커니즘의 GSS\_GetMIC\(\) 진입점에 의한 일반 텍스트 처리와 마찬가지로 GSS\_Wrap\(\)의 진입점은 일반 텍스트에 대한 포인터를 예상하고 불투명 배열을 다른 필드와 함께 일반 텍스트를 나타내는 sspt\_orig\_plain으로 XDR 인코딩합니다. 데이터 유형 ssv\_seal\_plain\_tkn4의 인스턴스입니다.

sspt\_pad 필드는 입력이 고정 크기 블록에 있어야 하는 암호화 알고리즘을 지원하기 위해 존재합니다. sspt\_pad의 내용은 길이를 제외하고 0으로 채워집니다. ssv\_seal\_plain\_tkn4의 XDR 인코딩에는 3개의 가변 길이 배열이 포함되어 있으므로 각 배열은 배열 길이에 대해 4바이트를 소비하고 길이 뒤에 오는 각 배열은 항상 XDR 표준에 따라 4바이트의 배수로 채워집니다.

예를 들어 암호화 알고리즘이 16바이트 블록을 사용하고 sspt\_confounder의 길이가 3바이트이고 sspt\_orig\_plain 필드의 길이가 15바이트라고 가정합니다. sspt\_confounder의 XDR 인코딩은 8바이트\(4 + 3 + 1바이트 패드\)를 사용하고, sspt\_ssv\_seq의 XDR 인코딩은 4바이트를 사용하며, sspt\_orig\_plain의 XDR 인코딩은 20바이트\(4 + 15 + 1바이트 패드\)를 사용하며, 가장 작은 sspt\_pad 필드의 XDR 인코딩은 4바이트입니다. 총 36바이트입니다. 16의 다음 배수는 48입니다. 따라서 sspt\_pad의 길이 필드는 12바이트 또는 총 인코딩 16바이트로 설정되어야 합니다. 따라서 XDR로 인코딩된 총 바이트 수는 8 + 4 + 20 + 16 = 48입니다.

GSS\_Wrap\(\)은 ssv\_seal\_cipher\_tkn4 데이터 유형 값의 XDR 인코딩인 토큰을 내보냅니다. GSS\_Wrap\(\) 호출자가 기밀성을 요청하는지 여부에 관계없이 토큰은 항상 기밀성을 갖습니다. 이는 SSV 메커니즘이 RPCSEC\_GSS용이고 RPCSEC\_GSS는 기밀성 없이 GSS\_wrap\(\) 토큰을 생성하지 않기 때문입니다.

클라이언트 ID당 하나의 SSV가 있습니다. 클라이언트 ID/SSV 쌍에 대한 단일 GSS 컨텍스트가 있습니다. 클라이언트 ID/SSV 쌍의 모든 SSV 메커니즘 RPCSEC\_GSS 핸들은 동일한 GSS 컨텍스트를 공유합니다. SSV GSS 컨텍스트는 SSV가 삭제되는 경우를 제외하고는 만료되지 않습니다\(원인에는 클라이언트 ID가 삭제되거나 서버가 다시 시작되는 경우가 포함됩니다\). 컨텍스트 만료의 목적 중 하나는 "너무 오랫동안" 사용되어 무차별 대입이나 사고로 인한 손상에 취약한 키를 교체하는 것이므로 클라이언트는 주기적으로 SET\_SSV 작업을 전송하여 SSV 키를 교체할 수 있습니다. 다른 사용자의 RPCSEC\_GSS 자격 증명. 이런 방식으로 SSV의 GSS 컨텍스트를 파괴하지 않고 SSV가 대체됩니다.

SSV RPCSEC\_GSS 핸들은 언제든지 서버에 의해 만료되거나 삭제될 수 있으며 EXCHANGE\_ID 작업을 사용하여 더 많은 SSV RPCSEC\_GSS 핸들을 생성할 수 있습니다. SSV RPCSEC\_GSS 핸들의 만료는 SSV 또는 해당 GSS 컨텍스트가 만료되었음을 의미하지 않습니다.

클라이언트는 SSV GSS 컨텍스트를 사용하여 GSS\_Wrap\(\) 및 GSS\_GetMIC\(\)에서 토큰을 방출하기 전에 SET\_SSV를 통해 SSV를 설정해야 합니다. SET\_SSV가 성공적으로 호출되지 않은 경우 토큰을 내보내려는 시도는 반드시 실패해야 합니다.\(MUST, MUST\)

RPCSEC\_GSS가 이러한 기능을 사용하지 않기 때문에 SSV 메커니즘은 토큰에서 재생 감지 및 순서 지정을 지원하지 않습니다\("컨텍스트 생성 요청", \[4\]의 섹션 5.2.2 참조\). 그러나 섹션 2.10.10에서는 RPCSEC\_GSS와 함께 사용할 때 SSV 메커니즘에 대한 특별 고려 사항을 논의합니다.

2.10.10. SSV 메커니즘을 사용할 때 RPCSEC\_GSS에 대한 보안 고려 사항

클라이언트 ID가 SP4\_SSV 상태 보호\(섹션 18.35 참조\)로 생성되면 클라이언트는 여러 RPCSEC\_GSS 핸들을 단일 SSV GSS 컨텍스트\(섹션 2.10.9 참조\)와 연결할 수 있습니다. RPCSEC\_GSS\(버전 1과 버전 2 모두, \[4\] 및 \[9\] 참조\)가 응답 검증자를 계산하는 방식으로 인해 NFSv4.1 클라이언트 구현에서는 사람의 공격을 방지하기 위해 특별한 주의를 기울여야 합니다. 중간에. RPCSEC\_GSS 응답의 검증자는 RPCSEC\_GSS 자격 증명\(데이터 유형 rpc\_gss\_cred\_ver\_1\_t\)의 seq\_num 필드 입력 값에 적용된 GSS\_GetMIC\(\)의 출력입니다\(\[4\]의 섹션 5.3.3.2 참조\). 여러 RPCSEC\_GSS 핸들이 동일한 GSS 컨텍스트를 공유하는 경우 한 핸들을 사용하여 다른 핸들과 동일한 seq\_num 값을 가진 요청을 보내는 경우 공격자는 응답을 차단하고 이를 다른 핸들에 사용되는 검증자로 대체할 수 있습니다.

응답에서 SSV RPCSEC\_GSS 검증자에 대한 공격을 방지하는 방법은 여러 가지가 있습니다. 가장 간단한 것은 다음과 같습니다.

\* 하나 이상의 새로운 SSV RPCSEC\_GSS 핸들이 EXCHANGE\_ID를 통해 생성될 때마다 클라이언트는 SSV를 수정하기 위해 SET\_SSV 작업을 보내야 합니다. SSV를 변경하면 새 핸들로 인해 응답에서 SSV RPCSEC\_GSS 검증 도구가 재사용되지 않습니다.\(SHOULD\)

\* 요청자가 N SSV RPCSEC\_GSS 핸들을 사용하기로 결정한 경우 각 SSV RPCSEC\_GSS 핸들에 고유하고 겹치지 않는 seq\_nums 범위를 할당해야 합니다. 각 범위의 크기는 MAXSEQ / N과 동일해야 합니다\(MAXSEQ 정의는 \[4\]의 섹션 5 참조\). SSV RPCSEC\_GSS 핸들이 최대값에 도달하면 seq\_num이 MAXSEQ + 1로 설정된 NULL RPC 요청을 보내 응답자가 핸들을 삭제하도록 강제해야 합니다\(\[4\]의 섹션 5.3.3.3 참조\).\(SHOULD, SHOULD, SHOULD\)

\* 요청자가 N을 늘리거나 줄이려면 seq\_num이 MAXSEQ + 1로 설정된 각 핸들에 대해 NULL RPC 요청을 보내 응답자가 모든 N 핸들을 삭제하도록 강제해야 합니다. 요청자가 클라이언트인 경우 SET\_SSV를 보내야 합니다. 새 핸들을 사용하기 전에 작동하십시오. 요청자가 서버인 경우 클라이언트는 서버가 강제로 백채널의 SSV RPCSEC\_GSS 핸들을 삭제했음을 감지하면 SET\_SSV 작업을 보내야 합니다. SET\_SSV 작업을 보내면 SSV가 변경되므로 공격자는 요청자에 대한 응답으로 이전 검증자를 성공적으로 재생할 수 없게 됩니다.\(SHOULD, SHOULD, SHOULD\)

응답자가 SSV RPCSEC\_GSS 핸들을 신중하게 생성하는 경우 중간자\(man-in-the-middle\)가 위조된 SSV RPCSEC\_GSS 자격 증명을 다른 핸들에 대한 검증자와 연결하는 관련 위험이 존재하지 않습니다. 이는 RPCSEC\_GSS 요청의 검증자가 RPCSEC\_GSS 핸들과 seq\_num을 모두 포함하는 입력에서 계산되기 때문입니다\(\[4\]의 섹션 5.3.1 참조\). 회신자가 자신이 생성한 RPCSEC\_GSS 핸들 값을 재사용하지 않도록 주의를 기울이는 경우\(예: 핸들에 세대 번호 포함\) 중간자\(man-in-the-middle\)는 이전 검증자를 성공적으로 재생할 수 없습니다. 응답자에게 요청합니다.

---
#### **2.10.11.  Session Mechanics - Steady State**
---
##### **2.10.11.1.  Obligations of the Server**

서버에는 클라이언트가 서버에 대해 생성한 백채널 리소스\(RPCSEC\_GSS 컨텍스트 및 백채널 연결\)의 상태를 모니터링하는 기본 의무가 있습니다. 이러한 리소스가 사라지면 서버는 섹션 2.10.13.2에 지정된 대로 조치를 취합니다.

---
##### **2.10.11.2.  Obligations of the Client**

클라이언트는 세션을 활용하기 위해 다음 의무를 준수해야 합니다.\(SHOULD\)

\* 필요한 세션이 서버에서 유휴 상태가 되지 않도록 하세요. 세션이 필요하지만 그럼에도 불구하고 작업을 보내지 않는 클라이언트는 서버에 의해 세션이 삭제될 위험이 있습니다. 이는 세션이 리소스를 소비하고 리소스 제한으로 인해 서버가 비활성 세션을 제거할 수 있기 때문입니다. 세션 비활성 타이머\(섹션 2.10.12\)가 만료되기 전에 클라이언트가 세션을 사용하지 않은 경우 서버는 세션을 비활성 상태로 간주할 수 있습니다.\(MAY\)

\* 필요하지 않은 경우 세션을 삭제합니다. 클라이언트에 여러 세션이 있고 그 중 하나에 응답을 기다리는 요청이 없고 일정 기간 동안 유휴 상태인 경우 세션을 삭제해야 합니다\(SHOULD\).\(SHOULD\)

\* 백채널에 대한 GSS 컨텍스트 및 RPCSEC\_GSS 핸들을 유지합니다. 클라이언트가 서버가 콜백에 대해 RPCSEC\_GSS 보안 특성을 사용하도록 요구하는 경우 RPCSEC\_GSS 핸들 및/또는 BACKCHANNEL\_CTL 또는 CREATE\_SESSION을 통해 서버에 전달되는 해당 GSS 컨텍스트가 만료되지 않았는지 확인해야 합니다.

\* 백채널에 대한 연결을 유지합니다. 서버는 회수 가능한 상태를 정상적으로 호출하거나 클라이언트에 특정 이벤트를 알리기 위해 백채널이 필요합니다. 연결이 전방 채널에 사용되지 않는 경우 클라이언트는 연결이 여전히 활성 상태인지 알 수 있는 방법이 없습니다\(예: 연결 해제를 보내지 않고 서버가 다시 시작됨\). 백채널의 연결이 활성 상태인지 확인하고 세션의 백채널과 연결된 마지막 연결이 끊어졌을 때 SEQUENCE 작업에 대한 응답으로 표시하는 책임은 클라이언트가 아닌 서버에 있습니다.

---
##### **2.10.11.3.  Steps the Client Takes to Establish a Session**

클라이언트에 클라이언트 ID가 없으면 클라이언트는 EXCHANGE\_ID를 보내 클라이언트 ID를 설정합니다. SP4\_MACH\_CRED 또는 SP4\_SSV 보호를 선택한 경우 spo\_must\_enforce 작업 목록에서 최소한 CREATE\_SESSION, DESTROY\_SESSION, BIND\_CONN\_TO\_SESSION, BACKCHANNEL\_CTL 및 DESTROY\_CLIENTID를 지정해야 합니다. SP4\_SSV 보호를 선택한 경우 클라이언트는 SSV 기반 RPCSEC\_GSS 핸들을 요청해야 합니다.\(SHOULD\)

클라이언트는 클라이언트 ID를 사용하여 서버 연결 시 CREATE\_SESSION을 보냅니다. CREATE\_SESSION의 결과는 서버가 다시 시작된 서버를 통해 세션 응답 캐시를 유지할지 여부를 나타내며 클라이언트는 나중에 참조할 수 있도록 이를 기록합니다.

클라이언트 ID가 생성될 때 클라이언트가 SP4\_SSV 상태 보호를 지정한 경우 세션이 생성된 후 첫 번째 COMPOUND에서 SET\_SSV를 보내야 합니다. 새로운 주체가 클라이언트 ID를 사용하려고 할 때마다 SET\_SSV를 다시 보내야 합니다.\(SHOULD, SHOULD\)

클라이언트가 위임, 레이아웃, 디렉터리 알림 또는 백채널이 필요한 기타 상태를 사용하려는 경우 CREATE\_SESSION이 아직 수행하지 않은 경우 백채널에 연결을 추가해야 합니다. 클라이언트는 연결을 생성하고 BIND\_CONN\_TO\_SESSION을 호출하여 연결을 세션 및 세션의 백채널과 연결합니다. CREATE\_SESSION이 아직 수행하지 않은 경우 클라이언트는 클라이언트가 콜백을 수락하기 위해 필요한 보안이 무엇인지 서버에 알려야 합니다. 클라이언트는 BACKCHANNEL\_CTL을 통해 이 작업을 수행합니다. 클라이언트가 EXCHANGE\_ID를 호출할 때 SP4\_MACH\_CRED 또는 SP4\_SSV 보호를 선택한 경우 클라이언트는 백채널이 보안을 위해 RPCSEC\_GSS 컨텍스트를 사용하도록 지정해야 합니다.\(MUST, SHOULD\)

클라이언트가 백채널에 추가 연결을 사용하려는 경우 세션과 함께 사용하려는 각 연결에서 BIND\_CONN\_TO\_SESSION을 호출해야 합니다. 클라이언트가 포 채널에 대한 추가 연결을 사용하려는 경우 클라이언트 ID가 생성될 때 SP4\_SSV 또는 SP4\_MACH\_CRED 상태 보호를 지정했다면 BIND\_CONN\_TO\_SESSION을 호출해야 합니다.

이 시점에서 세션은 안정된 상태에 도달했습니다.

---
#### **2.10.12.  Session Inactivity Timer**

서버는 각 세션에 대해 세션 비활성 타이머를 유지할 수 있습니다. 세션 비활성 타이머가 만료되면 서버는 세션을 삭제할 수 있습니다. 비활성으로 인한 세션 손실을 방지하려면 클라이언트는 세션 비활성 타이머를 갱신해야 합니다. 세션 비활성 타이머의 길이는 Lease\_time 속성\(섹션 5.8.1.11\)보다 작아서는 안 됩니다. 임대 갱신\(8.3절\)과 마찬가지로 서버가 SEQUENCE 작업을 수신하면 세션 비활성 타이머를 재설정하고 COMPOUND 프로시저 요청의 나머지 작업이 계속 실행되는 동안 타이머가 만료되도록 허용해서는 안 됩니다. 마지막 작업이 완료되면 서버는 세션 비활성 타이머가 현재 시간과 Lease\_time 속성 값의 합보다 빨리 만료되도록 설정해야 합니다.\(MAY, MAY, MUST, MUST NOT, MUST NOT, MUST\)

---
#### **2.10.13.  Session Mechanics - Recovery**
---
##### **2.10.13.1.  Events Requiring Client Action**

다음 이벤트를 복구하려면 클라이언트 작업이 필요합니다.

---
###### **2.10.13.1.1.  RPCSEC_GSS Context Loss by Callback Path**

콜백 사용을 위해 클라이언트가 서버에 부여한 모든 RPCSEC\_GSS 핸들이 만료된 경우 클라이언트는 BACKCHANNEL\_CTL을 통해 새 핸들을 설정해야 합니다. SEQUENCE 결과의 sr\_status\_flags 필드는 콜백 핸들이 거의 만료되거나 완전히 만료되는 시기를 나타냅니다\(섹션 18.46.3 참조\).\(MUST\)

---
###### **2.10.13.1.2.  Connection Loss**

클라이언트가 세션의 마지막 연결이 끊어지고 세션을 유지하려는 경우 새 연결을 생성해야 하며, 클라이언트 ID가 생성될 때 BIND\_CONN\_TO\_SESSION이 spo\_must\_enforce 목록에 지정된 경우 클라이언트는 BIND\_CONN\_TO\_SESSION을 사용해야 합니다. 세션과 연결을 연결합니다.\(MUST\)

연결이 끊어졌을 때 미해결 요청이 있었던 경우 클라이언트가 세션을 계속 사용하려면 섹션 2.10.6.2에 설명된 대로 요청을 다시 시도해야 합니다. 끊어진 연결과 동일한 소스 네트워크 주소 또는 동일한 대상 네트워크 주소를 사용하는 연결을 통해 요청을 재시도할 필요는 없습니다. 재시도의 세션 ID, 슬롯 ID 및 시퀀스 ID가 원래 요청과 일치하는 한 서버는 연결 해제 전에 요청을 실행한 경우 해당 요청을 재시도로 인식합니다.\(MUST\)

손실된 연결이 백채널과 연결된 마지막 연결이고 클라이언트가 백채널을 유지하고/하거나 회수 가능한 상태의 취소를 방지하려는 경우 클라이언트는 다시 연결해야 하며, 그렇다면 연결을 연결해야 합니다. BIND\_CONN\_TO\_SESSION을 통한 세션 및 백채널. 서버는 SEQUENCE의 sr\_status\_flags 결과를 통해 콜백 연결이 없는 시기를 표시해야 합니다.\(MUST, SHOULD\)

---
###### **2.10.13.1.3.  Backchannel GSS Context Loss**

SEQUENCE 작업의 sr\_status\_flags 결과 또는 다른 수단을 통해 클라이언트는 백채널에 할당된 RPCSEC\_GSS 컨텍스트 중 일부 또는 전체가 손실되었는지 여부를 알게 됩니다. 클라이언트가 백채널을 유지하고/하거나 취소할 수 있는 회수 가능한 상태를 설정하지 않으려는 경우 클라이언트는 BACKCHANNEL\_CTL을 사용하여 새 컨텍스트를 할당해야 합니다.

---
###### **2.10.13.1.4.  Loss of Session**

응답자는 세션 기록을 잃을 수 있습니다. 원인은 다음과 같습니다:

\* 응답기가 실패하고 다시 시작됩니다.

\* 응답 캐시가 저장된 미디어에서 손상되거나 손실되는 재앙입니다. 이는 CREATE\_SESSION 결과에 표시된 응답자가 캐시를 유지하는 경우에도 적용됩니다.

\* 서버는 매우 오랜 기간 동안 비활성 상태인 클라이언트의 세션을 제거합니다.

\* 클러스터된 서버 집합 간의 구성 변경으로 인해 이전에 한 서버에 연결되었던 네트워크 주소가 해당 세션을 알지 못하는 다른 서버에 연결됩니다. 이러한 구성 변경은 일반적으로 원래 서버가 한동안 작동을 멈출 때만 발생합니다.

응답 캐시 손실은 세션 손실과 동일합니다. 응답자는 손실된 세션을 참조하는 세션 ID를 사용하는 다음 작업에서 NFS4ERR\_BADSESSION을 반환하여 요청자에게 세션 손실을 나타냅니다.

서버 다시 시작과 같은 이벤트가 발생한 후 클라이언트의 연결이 끊어졌을 수 있습니다. 클라이언트는 세션이 손실되지 않았다고 가정합니다. 다시 연결하고, 세션이 생성될 때 연결 연관 적용을 지정한 경우 세션 ID를 사용하여 BIND\_CONN\_TO\_SESSION을 호출합니다. 그렇지 않으면 SEQUENCE를 호출합니다. BIND\_CONN\_TO\_SESSION 또는 SEQUENCE가 NFS4ERR\_BADSESSION을 반환하면 클라이언트는 해당 네트워크 주소와 통신할 때 세션을 사용할 수 없다는 것을 알게 됩니다. 연결이 세션 손실에서 살아남으면 클라이언트가 연결을 통해 보내는 다음 SEQUENCE 작업은 NFS4ERR\_BADSESSION을 다시 가져옵니다. 클라이언트는 세션이 손실되었음을 다시 알고 있습니다.

다음은 클라이언트가 NFS4ERR\_BADSESSION을 받을 때 제안되는 알고리즘 중 하나입니다. 클라이언트가 트렁킹과 같은 기능을 활용하기를 원하지 않는 경우 해당 기능의 일부를 생략할 수 있다는 점에서 이는 의무 사항은 아닙니다. 그러나 이는 가능한 다양한 복구 문제에 주의를 환기시키는 유용한 예입니다.

1. 클라이언트가 동일한 세션과 연결된 다른 서버 네트워크 주소에 대한 다른 연결을 갖고 있는 경우 다른 각 연결에서 단일 작업인 SEQUENCE를 사용하여 COMPOUND를 시도합니다.

2. 시도가 성공하면 세션이 여전히 살아 있는 것이며 이는 서버의 네트워크 주소가 이동했음을 나타내는 강력한 표시입니다. 클라이언트는 NFS4ERR\_BADSESSION을 반환한 연결에서 EXCHANGE\_ID를 보내 클라이언트 ID 트렁킹에 대한 기회가 있는지 확인할 수 있습니다\(즉, 동일한 클라이언트 ID와 so\_major\_id 값이 반환됨\). 클라이언트는 DNS를 사용하여 이동된 네트워크 주소가 다른 주소로 대체되었는지 확인하여 세션 트렁킹의 성능 및 가용성 이점을 계속 누릴 수 있습니다.

3. NFS4ERR\_BADSESSION으로 인해 SEQUENCE 요청이 실패하면 클라이언트가 해당 세션 ID와 연결된 연결을 갖고 있는 서버 네트워크 주소에 세션이 더 이상 존재하지 않습니다. 세션이 아직 살아 있고 다른 네트워크 주소에서 사용 가능할 수도 있습니다. 클라이언트는 모든 연결에 대해 EXCHANGE\_ID를 보내 서버 소유자가 해당 네트워크 주소를 계속 수신하고 있는지 확인합니다. 동일한 서버 소유자가 반환되었지만 새 클라이언트 ID가 반환된 경우 이는 서버가 다시 시작되었음을 나타내는 강력한 표시입니다. 동일한 서버 소유자와 동일한 클라이언트 ID가 모두 반환되면 이는 서버가 세션을 삭제했다는 강력한 표시이며 클라이언트는 해당 클라이언트 ID에 대한 다른 세션이 없는 경우 CREATE\_SESSION을 보내야 합니다. 다른 서버 소유자가 반환되면 클라이언트는 DNS를 사용하여 다른 네트워크 주소를 찾을 수 있습니다. 그렇지 않거나 DNS가 서버에 대한 다른 주소를 찾지 못하는 경우 클라이언트는 NFSv4.1 서비스를 제공할 수 없으며 서버를 사용하고 있던 프로세스에 치명적인 오류가 반환되어야 합니다. 클라이언트가 "마운트" 패러다임을 사용하는 경우 서버를 마운트 해제하는 것이 좋습니다.

4. 클라이언트가 세션 ID와 연관된 다른 연결 및 세션 ID와 연관되어 있거나 연관되었던 서버 네트워크 주소를 알지 못하는 경우 클라이언트는 DNS를 사용하여 다른 네트워크 주소를 찾을 수 있습니다. 그렇지 않거나 DNS가 서버에 대한 다른 주소를 찾지 못하는 경우 클라이언트는 NFSv4.1 서비스를 제공할 수 없으며 서버를 사용하고 있던 프로세스에 치명적인 오류가 반환되어야 합니다. 클라이언트가 "마운트" 패러다임을 사용하는 경우 서버를 마운트 해제하는 것이 좋습니다.

eir\_server\_scope 값이 다른 서버에 동일한 네트워크 주소가 할당되는 재구성 이벤트가 있는 경우 첫 번째에서 생성된 세션 ID가 첫 번째에서 유효하지 않은 것으로 인식된다는 것을 보장할 수 없습니다. 따라서 서버 범위 값이 서로 다른 서버 간의 서버 재구성을 관리하는 경우 재구성을 수행하기 전에 모든 클라이언트가 첫 번째 서버에서 연결이 끊어졌는지 확인해야 합니다. 그럼에도 불구하고 클라이언트는 서버가 항상 이 요구 사항을 준수할 것이라고 가정해서는 안 됩니다. 클라이언트는 서버 재구성의 예상치 못한 영향을 처리할 준비가 되어 있어야 합니다. 세션 ID가 유효하다고 부적절하게 인식되는 경우에도 연결이 유효한 것으로 인식되지 않거나 슬롯에 대한 시퀀스 값이 정확하지 않을 가능성이 높습니다. 따라서 클라이언트가 예상치 못한 오류를 나타내는 결과를 받으면 EXCHANGE\_ID를 사용하여 현재 서버 구성을 확인하는 것이 좋습니다.\(MUST, SHOULD\)

위의 변형은 서버의 네트워크 주소가 이동한 후 수신 대기하는 NFSv4.1 서버가 없다는 것입니다\(예: 포트 2049에 수신기가 없음\). 이 예에서는 다음 중 하나가 발생합니다. NFSv4 서버는 NFS4ERR\_MINOR\_VERS\_MISMATCH를 반환하고 NFS 서버는 NFS4ERR\_MINOR\_VERS\_MISMATCH를 반환합니다. PROG\_MISMATCH 오류를 반환하거나 2049의 RPC 수신기가 PROG\_UNVAIL을 반환하거나 네트워크 주소 시간 초과에 다시 연결을 시도합니다. 이는 이러한 목적으로 NFS4ERR\_BADSESSION을 반환하는 SEQUENCE와 동일하게 처리되어야 합니다.\(SHOULD\)

클라이언트가 세션 손실을 감지하면 복구를 위해 CREATE\_SESSION을 호출해야 합니다. 진행 중이던 모든 비멱등성 작업은 세션 손실 시 서버에서 수행되었을 수 있습니다. 클라이언트에게는 이 문제를 복구할 수 있는 일반적인 방법이 없습니다.

세션 손실은 바이트 범위 잠금, 열기, 위임 또는 레이아웃 상태의 손실을 의미하지 않습니다. 잠금, 열기, 위임 및 레이아웃은 클라이언트 ID에 연결되어 있고 세션이 아닌 클라이언트 ID에 의존하기 때문입니다. 세션이 클라이언트 ID에 따라 달라지므로 바이트 범위 잠금, 열기, 위임 또는 레이아웃 상태의 손실이 세션 상태의 손실을 의미하지도 않습니다. 그러나 클라이언트 ID의 손실은 세션, 바이트 범위 잠금, 열기, 위임 및 레이아웃 상태의 손실을 의미합니다. 섹션 8.4.2를 참조하십시오. 세션은 서버를 다시 시작해도 유지될 수 있지만 여전히 잠금 복구가 필요할 수 있습니다.

NFS4ERR\_STALE\_CLIENTID로 인해 CREATE\_SESSION이 실패할 수 있습니다\(예: 서버가 다시 시작되고 클라이언트 ID 상태가 유지되지 않음\). 그렇다면 클라이언트는 EXCHANGE\_ID를 호출한 다음 CREATE\_SESSION을 호출해야 합니다.

---
##### **2.10.13.2.  Events Requiring Server Action**

다음 이벤트를 복구하려면 서버 작업이 필요합니다.

---
###### **2.10.13.2.1.  Client Crash and Restart**

섹션 18.35에 설명된 대로 다시 시작된 클라이언트는 서버가 보유한 모든 세션을 삭제하도록 하는 방식으로 EXCHANGE\_ID를 보냅니다.

---
###### **2.10.13.2.2.  Client Crash with No Restart**

클라이언트가 충돌하고 다시 돌아오지 않으면 이전 클라이언트 소유자와 함께 EXCHANGE\_ID를 보내지 않습니다. 따라서 서버에는 다시는 사용되지 않을 세션 상태가 있습니다. 오랜 시간이 지난 후 서버에 리소스 제약이 있는 경우 잠금 상태뿐만 아니라 이전 세션도 파괴될 수 있습니다.\(MAY\)

---
###### **2.10.13.2.3.  Extended Network Partition**

서버의 경우 확장된 네트워크 파티션은 다시 시작하지 않은 클라이언트 충돌과 다르지 않을 수 있습니다\(섹션 2.10.13.2.2 참조\). 서버가 네트워크 분할이 있음을 식별할 수 없는 한, 클라이언트가 영구적으로 충돌한 것처럼 상황을 자유롭게 처리할 수 있습니다.

---
###### **2.10.13.2.4.  Backchannel Connection Loss**

연결이 끊어졌을 때 미해결된 콜백 요청이 있는 경우 서버는 섹션 2.10.6.2에 설명된 대로 요청을 다시 시도해야 합니다. 끊어진 연결과 동일한 소스 네트워크 주소 또는 동일한 대상 네트워크 주소를 사용하는 연결을 통해 요청을 재시도할 필요는 없습니다. 재시도의 세션 ID, 슬롯 ID 및 시퀀스 ID가 원래 요청과 일치하는 한 콜백 대상은 연결 해제 전에 요청을 확인했더라도 해당 요청을 재시도로 인식합니다.\(MUST\)

손실된 연결이 백채널과 관련된 마지막 연결인 경우 서버는 백채널이 다시 설정될 때까지 모든 SEQUENCE 응답의 sr\_status\_flags 필드에 이를 표시해야 합니다. 각각 서로 다른 상태 플래그를 사용하는 두 가지 상황이 있습니다. 즉, 세션의 백채널에 연결되지 않은 경우와 클라이언트의 세션 백채널에 연결되지 않은 경우입니다. sr\_status\_flags의 적절한 플래그에 대한 설명은 섹션 18.46을 참조하세요.\(MUST\)

---
###### **2.10.13.2.5.  GSS Context Loss**

서버는 백채널에 할당된 RPCSEC\_GSS 핸들 수가 1에 도달할 때와 핸들 하나가 만료에 가까워졌을 때\(즉, 임대 시간의 1\~2 기간 사이\)를 모니터링하고 모든 SEQUENCE 응답의 sr\_status\_flags 필드에 이를 표시해야 합니다. 서버는 모든 SEQUENCE 응답의 sr\_status\_flags 필드를 통해 백채널에 할당된 RPCSEC\_GSS 핸들이 모두 만료되는 시기를 표시해야 합니다.\(SHOULD, MUST\)

---
#### **2.10.14.  Parallel NFS and Sessions**

클라이언트와 서버는 잠재적으로 비pNFS 구현, 메타데이터 서버 구현, 데이터 서버 구현 또는 두세 가지 유형의 구현일 수 있습니다. EXCHGID4\_FLAG\_USE\_NON\_PNFS, EXCHGID4\_FLAG\_USE\_PNFS\_MDS 및 EXCHGID4\_FLAG\_USE\_PNFS\_DS 플래그\(상호 배타적이지 않음\)는 EXCHANGE\_ID 인수 및 결과에 전달되어 클라이언트가 클라이언트 ID 아래에 생성된 세션을 사용하려는 방법을 나타내고 서버가 허용하는 방법을 나타낼 수 있도록 합니다. 사용할 세션. pNFS 세션 고려 사항은 섹션 13.1을 참조하세요.

---
## **3.  Protocol Constants and Data Types**

NFSv4.1 프로토콜의 데이터 유형을 설명하는 구문과 의미는 XDR\(RFC 4506 \[2\]\) 및 RPC\(RFC 5531 \[3\]\) 문서에 정의되어 있습니다. 다음 섹션에서는 XDR 데이터 유형을 기반으로 이 프로토콜에 특정한 상수, 유형 및 구조를 정의합니다. XDR 데이터 유형의 전체 목록은 \[10\]에 있습니다.

---
### **3.1.  Basic Constants**

```text
   const NFS4_FHSIZE               = 128;
   const NFS4_VERIFIER_SIZE        = 8;
   const NFS4_OPAQUE_LIMIT         = 1024;
   const NFS4_SESSIONID_SIZE       = 16;

   const NFS4_INT64_MAX            = 0x7fffffffffffffff;
   const NFS4_UINT64_MAX           = 0xffffffffffffffff;
   const NFS4_INT32_MAX            = 0x7fffffff;
   const NFS4_UINT32_MAX           = 0xffffffff;

   const NFS4_MAXFILELEN           = 0xffffffffffffffff;
   const NFS4_MAXFILEOFF           = 0xfffffffffffffffe;
```

명시된 경우를 제외하고 이러한 모든 상수는 바이트 단위로 정의됩니다.

\* NFS4\_FHSIZE는 파일핸들의 최대 크기입니다.

\* NFS4\_VERIFIER\_SIZE는 검증기의 고정 크기입니다.

\* NFS4\_OPAQUE\_LIMIT는 특정 불투명의 최대 크기입니다.

-  정보.

\* NFS4\_SESSIONID\_SIZE는 세션 식별자의 고정 크기입니다.

\* NFS4\_INT64\_MAX는 부호 있는 64비트 정수의 최대값입니다.

\* NFS4\_UINT64\_MAX는 부호 없는 64비트 정수의 최대값입니다.

\* NFS4\_INT32\_MAX는 부호 있는 32비트 정수의 최대값입니다.

\* NFS4\_UINT32\_MAX는 부호 없는 32비트 정수의 최대값입니다.

\* NFS4\_MAXFILELEN은 일반 파일의 최대 길이입니다.

\* NFS4\_MAXFILEOFF는 일반 파일에 대한 최대 오프셋입니다.

---
### **3.2.  Basic Data Types**

이는 기본 NFSv4.1 데이터 유형입니다.

```text
     +===============+==============================================+
     | Data Type     | Definition                                   |
     +===============+==============================================+
     | int32_t       | typedef int int32_t;                         |
     +---------------+----------------------------------------------+
     | uint32_t      | typedef unsigned int uint32_t;               |
     +---------------+----------------------------------------------+
     | int64_t       | typedef hyper int64_t;                       |
     +---------------+----------------------------------------------+
     | uint64_t      | typedef unsigned hyper uint64_t;             |
     +---------------+----------------------------------------------+
     | attrlist4     | typedef opaque attrlist4<>;                  |
     |               |                                              |
     |               | Used for file/directory attributes.          |
     +---------------+----------------------------------------------+
     | bitmap4       | typedef uint32_t bitmap4<>;                  |
     |               |                                              |
     |               | Used in attribute array encoding.            |
     +---------------+----------------------------------------------+
     | changeid4     | typedef uint64_t changeid4;                  |
     |               |                                              |
     |               | Used in the definition of change_info4.      |
     +---------------+----------------------------------------------+
     | clientid4     | typedef uint64_t clientid4;                  |
     |               |                                              |
     |               | Shorthand reference to client                |
     |               | identification.                              |
     +---------------+----------------------------------------------+
     | count4        | typedef uint32_t count4;                     |
     |               |                                              |
     |               | Various count parameters (READ, WRITE,       |
     |               | COMMIT).                                     |
     +---------------+----------------------------------------------+
     | length4       | typedef uint64_t length4;                    |
     |               |                                              |
     |               | The length of a byte-range within a file.    |
     +---------------+----------------------------------------------+
     | mode4         | typedef uint32_t mode4;                      |
     |               |                                              |
     |               | Mode attribute data type.                    |
     +---------------+----------------------------------------------+
     | nfs_cookie4   | typedef uint64_t nfs_cookie4;                |
     |               |                                              |
     |               | Opaque cookie value for READDIR.             |
     +---------------+----------------------------------------------+
     | nfs_fh4       | typedef opaque nfs_fh4<NFS4_FHSIZE>;         |
     |               |                                              |
     |               | Filehandle definition.                       |
     +---------------+----------------------------------------------+
     | nfs_ftype4    | enum nfs_ftype4;                             |
     |               |                                              |
     |               | Various defined file types.                  |
     +---------------+----------------------------------------------+
     | nfsstat4      | enum nfsstat4;                               |
     |               |                                              |
     |               | Return value for operations.                 |
     +---------------+----------------------------------------------+
     | offset4       | typedef uint64_t offset4;                    |
     |               |                                              |
     |               | Various offset designations (READ, WRITE,    |
     |               | LOCK, COMMIT).                               |
     +---------------+----------------------------------------------+
     | qop4          | typedef uint32_t qop4;                       |
     |               |                                              |
     |               | Quality of protection designation in         |
     |               | SECINFO.                                     |
     +---------------+----------------------------------------------+
     | sec_oid4      | typedef opaque sec_oid4<>;                   |
     |               |                                              |
     |               | Security Object Identifier.  The sec_oid4    |
     |               | data type is not really opaque.  Instead, it |
     |               | contains an ASN.1 OBJECT IDENTIFIER as used  |
     |               | by GSS-API in the mech_type argument to      |
     |               | GSS_Init_sec_context.  See [7] for details.  |
     +---------------+----------------------------------------------+
     | sequenceid4   | typedef uint32_t sequenceid4;                |
     |               |                                              |
     |               | Sequence number used for various session     |
     |               | operations (EXCHANGE_ID, CREATE_SESSION,     |
     |               | SEQUENCE, CB_SEQUENCE).                      |
     +---------------+----------------------------------------------+
     | seqid4        | typedef uint32_t seqid4;                     |
     |               |                                              |
     |               | Sequence identifier used for locking.        |
     +---------------+----------------------------------------------+
     | sessionid4    | typedef opaque                               |
     |               | sessionid4[NFS4_SESSIONID_SIZE];             |
     |               |                                              |
     |               | Session identifier.                          |
     +---------------+----------------------------------------------+
     | slotid4       | typedef uint32_t slotid4;                    |
     |               |                                              |
     |               | Sequencing artifact for various session      |
     |               | operations (SEQUENCE, CB_SEQUENCE).          |
     +---------------+----------------------------------------------+
     | utf8string    | typedef opaque utf8string<>;                 |
     |               |                                              |
     |               | UTF-8 encoding for strings.                  |
     +---------------+----------------------------------------------+
     | utf8str_cis   | typedef utf8string utf8str_cis;              |
     |               |                                              |
     |               | Case-insensitive UTF-8 string.               |
     +---------------+----------------------------------------------+
     | utf8str_cs    | typedef utf8string utf8str_cs;               |
     |               |                                              |
     |               | Case-sensitive UTF-8 string.                 |
     +---------------+----------------------------------------------+
     | utf8str_mixed | typedef utf8string utf8str_mixed;            |
     |               |                                              |
     |               | UTF-8 strings with a case-sensitive prefix   |
     |               | and a case-insensitive suffix.               |
     +---------------+----------------------------------------------+
     | component4    | typedef utf8str_cs component4;               |
     |               |                                              |
     |               | Represents pathname components.              |
     +---------------+----------------------------------------------+
     | linktext4     | typedef utf8str_cs linktext4;                |
     |               |                                              |
     |               | Symbolic link contents ("symbolic link" is   |
     |               | defined in an Open Group [11] standard).     |
     +---------------+----------------------------------------------+
     | pathname4     | typedef component4 pathname4<>;              |
     |               |                                              |
     |               | Represents pathname for fs_locations.        |
     +---------------+----------------------------------------------+
     | verifier4     | typedef opaque                               |
     |               | verifier4[NFS4_VERIFIER_SIZE];               |
     |               |                                              |
     |               | Verifier used for various operations         |
     |               | (COMMIT, CREATE, EXCHANGE_ID, OPEN, READDIR, |
     |               | WRITE) NFS4_VERIFIER_SIZE is defined as 8.   |
     +---------------+----------------------------------------------+

                                 Table 1
```

기본 데이터 유형의 끝

---
### **3.3.  Structured Data Types**
---
#### **3.3.1.  nfstime4**

```text
   struct nfstime4 {
           int64_t         seconds;
           uint32_t        nseconds;
   };
```

nfstime4 데이터 유형은 1970년 1월 1일 협정 세계시\(UTC\) 자정 또는 0시 이후의 초 및 나노초 수를 제공합니다. 초 필드의 0보다 큰 값은 1970년 1월 1일 0시 이후의 날짜를 나타냅니다. 초 필드의 0보다 작은 값은 1970년 1월 1일 0시 이전의 날짜를 나타냅니다. 두 경우 모두 nseconds 필드가 추가됩니다. 최종 시간 표현을 위한 초 필드입니다. 예를 들어, 표시할 시간이 1970년 1월 1일 0시 이전의 0.5초인 경우 초 필드의 값은 음수 1\(-1\)이고 nseconds 필드의 값은 0.5초\( 500000000\). n초에 대해 999,999,999보다 큰 값은 유효하지 않습니다.

이 데이터 유형은 시간 및 날짜 정보를 전달하는 데 사용됩니다. 서버는 시간 값을 처리할 때 로컬 시간 표현으로 변환하고 가능한 한 많은 정확도를 유지합니다. 파일 시스템 객체에 대해 저장된 타임스탬프의 정밀도가 정의된 것보다 낮으면 정밀도가 손실될 수 있습니다. 클라이언트 및 서버 시간 차이를 줄이기 위해 보조 시간 유지 관리 프로토콜을 권장합니다.\(SHOULD\)

---
#### **3.3.2.  time_how4**

```text
   enum time_how4 {
           SET_TO_SERVER_TIME4 = 0,
           SET_TO_CLIENT_TIME4 = 1
   };
```

---
#### **3.3.3.  settime4**

```text
   union settime4 switch (time_how4 set_it) {
    case SET_TO_CLIENT_TIME4:
            nfstime4       time;
    default:
            void;
   };
```

time\_how4 및 settime4 데이터 유형은 파일 객체 속성에서 타임스탬프를 설정하는 데 사용됩니다. set\_it가 SET\_TO\_SERVER\_TIME4이면 서버는 시간 값에 대한 로컬 시간 표현을 사용합니다.

---
#### **3.3.4.  specdata4**

```text
   struct specdata4 {
    uint32_t specdata1; /* major device number */
    uint32_t specdata2; /* minor device number */
   };
```

이 데이터 유형은 장치 파일 유형 NF4CHR 및 NF4BLK에 대한 장치 번호를 나타냅니다.

---
#### **3.3.5.  fsid4**

```text
   struct fsid4 {
           uint64_t        major;
           uint64_t        minor;
   };
```

---
#### **3.3.6.  change_policy4**

```text
   struct change_policy4 {
           uint64_t        cp_major;
           uint64_t        cp_minor;
   };
```

Change\_policy4 데이터 유형은 Change\_policy RECOMMENDED 속성에 사용됩니다. 이는 변경 속성과 유사한 변경 순서 표시를 제공합니다. 서버가 영구 저장소 없이 서버 재초기화 시 유효한 값을 제공할 수 있도록 두 개의 64비트 수량을 사용하여 하나는 서버 인스턴스 ID가 되고 두 번째는 지정된 서버 인스턴스 내에서 비지속적으로 증가할 수 있습니다. .\(SHOULD\)

---
#### **3.3.7.  fattr4**

```text
   struct fattr4 {
           bitmap4         attrmask;
           attrlist4       attr_vals;
   };
```

fattr4 데이터 유형은 파일 및 디렉토리 속성을 나타내는 데 사용됩니다.

비트맵은 비트 값을 포함하는 데 사용되는 32비트 정수의 계산된 배열입니다. 비트 n을 포함하는 배열의 정수 위치는 \(n / 32\) 표현식으로 계산할 수 있으며 해당 정수 내의 비트는 \(n mod 32\)입니다.

```text
                     0            1
   +-----------+-----------+-----------+--
   |  count    | 31  ..  0 | 63  .. 32 |
   +-----------+-----------+-----------+--
```

---
#### **3.3.8.  change_info4**

```text
   struct change_info4 {
           bool            atomic;
           changeid4       before;
           changeid4       after;
   };
```

이 데이터 유형은 CREATE, LINK, OPEN, REMOVE 및 RENAME 작업과 함께 사용되어 대상 파일 시스템 개체가 있는 디렉터리에 대한 변경 속성 값을 클라이언트에 알립니다.

---
#### **3.3.9.  netaddr4**

```text
   struct netaddr4 {
           /* see struct rpcb in RFC 1833 */
           string na_r_netid<>; /* network id */
           string na_r_addr<>;  /* universal address */
   };
```

netaddr4 데이터 유형은 네트워크 전송 끝점을 식별하는 데 사용됩니다. na\_r\_netid 및 na\_r\_addr 필드에는 각각 netid 및 uaddr이 포함되어 있습니다. netid 및 uaddr 개념은 \[12\]에 정의되어 있습니다. IPv4를 통한 TCP 및 IPv6을 통한 TCP의 netid 및 uaddr 형식은 \[12\], 특히 표 2와 3, 섹션 5.2.3.3과 5.2.3.4에 정의되어 있습니다.

---
#### **3.3.10.  state_owner4**

```text
   struct state_owner4 {
           clientid4       clientid;
           opaque          owner<NFS4_OPAQUE_LIMIT>;
   };

   typedef state_owner4 open_owner4;
   typedef state_owner4 lock_owner4;
```

state\_owner4 데이터 유형은 open\_owner4\(섹션 3.3.10.1\) 및 lock\_owner4\(섹션 3.3.10.2\)의 기본 유형입니다.

---
##### **3.3.10.1.  open_owner4**

이 데이터 유형은 OPEN 상태의 소유자를 식별하는 데 사용됩니다.

---
##### **3.3.10.2.  lock_owner4**

이 구조는 바이트 범위 잠금 상태의 소유자를 식별하는 데 사용됩니다.

---
#### **3.3.11.  open_to_lock_owner4**

```text
   struct open_to_lock_owner4 {
           seqid4          open_seqid;
           stateid4        open_stateid;
           seqid4          lock_seqid;
           lock_owner4     lock_owner;
   };
```

이 데이터 유형은 open\_owner4에 대해 수행된 첫 번째 LOCK 작업에 사용됩니다. 유효한 open\_stateid 시퀀스에서 새 lock\_stateid 시퀀스로 전환되도록 open\_stateid와 lock\_owner를 모두 제공합니다. 이 메커니즘을 사용하면 open\_stateid/open\_seqid 형식으로 설정된 상태에 연결되어 있으므로 lock\_owner/lock\_seqid 쌍의 확인을 피할 수 있습니다.

---
#### **3.3.12.  stateid4**

```text
   struct stateid4 {
           uint32_t        seqid;
           opaque          other[12];
   };
```

이 데이터 유형은 클라이언트와 서버 간의 다양한 상태 공유 메커니즘에 사용됩니다. 클라이언트는 stateid 데이터 유형의 값을 수정하지 않습니다. "seqid" 필드의 시작 값은 정의되지 않았습니다. 서버는 stateid가 전환될 때마다 "seqid" 필드를 1씩 증가시켜야 합니다. 클라이언트는 OPEN stateid의 seqid를 검사하여 서버에서 수행되는 OPEN 처리 순서를 결정하므로 이는 중요합니다.

---
#### **3.3.13.  layouttype4**

```text
   enum layouttype4 {
           LAYOUT4_NFSV4_1_FILES   = 0x1,
           LAYOUT4_OSD2_OBJECTS    = 0x2,
           LAYOUT4_BLOCK_VOLUME    = 0x3
   };
```

이 데이터 유형은 사용 중인 레이아웃 유형을 나타냅니다. 파일 서버는 fs\_layout\_type 파일 시스템 속성\(섹션 5.12.1\)을 통해 지원하는 레이아웃 유형을 광고합니다. 클라이언트는 LAYOUTGET에서 특정 유형의 레이아웃을 요청하고 해당 레이아웃을 레이아웃 유형별 로직으로 처리합니다.

레이아웃 유형4 데이터 유형의 길이는 32비트입니다. 레이아웃 유형으로 표시되는 범위는 세 부분으로 나뉩니다. 유형 0x0은 예약되어 있습니다. 0x00000001-0x7FFFFFFF 범위 내의 유형은 전역적으로 고유하며 섹션 22.5의 설명에 따라 할당됩니다. IANA에서 관리합니다. 0x80000000-0xFFFFFFFF 범위 내의 유형은 사이트별로 다르며 개인용으로만 사용됩니다.

LAYOUT4\_NFSV4\_1\_FILES 열거형은 섹션 13에 정의된 NFSv4.1 파일 레이아웃 유형이 사용되도록 지정합니다. LAYOUT4\_OSD2\_OBJECTS 열거형은 \[47\]에 정의된 객체 레이아웃이 사용되도록 지정합니다. 마찬가지로 LAYOUT4\_BLOCK\_VOLUME 열거형은 \[48\]에 정의된 대로 블록/볼륨 레이아웃이 사용되도록 지정합니다.

---
#### **3.3.14.  deviceid4**

```text
   const NFS4_DEVICEID4_SIZE = 16;

   typedef opaque  deviceid4[NFS4_DEVICEID4_SIZE];
```

레이아웃 정보에는 컴팩트 핸들을 통해 저장 장치를 지정하는 장치 ID가 포함됩니다. 주소 지정 및 유형 정보는 GEDEVICEINFO 작업을 통해 얻습니다. 메타데이터 서버를 다시 시작해도 장치 ID의 유효성이 보장되지 않습니다. 장치 ID는 클라이언트 ID 및 레이아웃 유형별로 고유합니다. 자세한 내용은 섹션 12.2.10을 참조하세요.

---
#### **3.3.15.  device_addr4**

```text
   struct device_addr4 {
           layouttype4             da_layout_type;
           opaque                  da_addr_body<>;
   };
```

장치 주소는 저장 장치와의 통신 채널을 설정하는 데 사용됩니다. 다양한 레이아웃 유형에는 저장 장치와 통신하는 방법을 정의하기 위한 다양한 데이터 유형이 필요합니다. 불투명한 da\_addr\_body 필드는 지정된 da\_layout\_type 필드를 기반으로 해석됩니다.

이 문서에서는 네트워크 IP 주소와 포트 번호로 저장 장치를 식별하는 NFSv4.1 파일 레이아웃\(섹션 13.3 참조\)에 대한 장치 주소를 정의합니다. 이는 클라이언트가 NFSv4.1 스토리지 장치와 통신하는 데 충분하며 다른 레이아웃 유형에도 충분할 수 있습니다. 객체 기반 저장 장치 및 블록 저장 장치\(예: SCSI\(Small Computer System Interface\) 볼륨 레이블\)의 장치 유형은 해당 레이아웃 사양에 따라 정의됩니다.

---
#### **3.3.16.  layout_content4**

```text
   struct layout_content4 {
           layouttype4 loc_type;
           opaque      loc_body<>;
   };
```

loc\_body 필드는 레이아웃 유형\(loc\_type\)에 따라 해석됩니다. 이 문서는 NFSv4.1 파일 레이아웃 유형에 대한 loc\_body를 정의합니다. 정의는 섹션 13.3을 참조하세요.

---
#### **3.3.17.  layout4**

```text
   struct layout4 {
           offset4                 lo_offset;
           length4                 lo_length;
           layoutiomode4           lo_iomode;
           layout_content4         lo_content;
   };
```

레이아웃4 데이터 유형은 파일의 레이아웃을 정의합니다. 레이아웃 유형별 데이터는 lo\_content 내에서 불투명합니다. 레이아웃은 분할 가능하므로 파일의 파일 핸들, 클라이언트 ID, iomode 및 레이아웃 유형과 함께 오프셋 및 길이로 레이아웃을 식별합니다.

---
#### **3.3.18.  layoutupdate4**

```text
   struct layoutupdate4 {
           layouttype4             lou_type;
           opaque                  lou_body<>;
   };
```

layoutupdate4 데이터 유형은 클라이언트가 LAYOUTCOMMIT\(섹션 18.42\) 작업을 통해 업데이트된 레이아웃 정보를 메타데이터 서버에 반환하는 데 사용됩니다. 이 데이터 유형은 레이아웃 유형별 정보\(lou\_body 필드\)를 메타데이터 서버로 다시 전달하는 채널을 제공합니다. 예를 들어 블록/볼륨 레이아웃 유형의 경우 여기에는 기록된 예약된 블록 목록이 포함될 수 있습니다. 불투명 lou\_body 인수의 내용은 레이아웃 유형에 따라 결정됩니다. NFSv4.1 파일 기반 레이아웃은 이 데이터 유형을 사용하지 않습니다. lou\_type이 LAYOUT4\_NFSV4\_1\_FILES인 경우 lou\_body 필드의 길이는 0이어야 합니다.\(MUST\)

---
#### **3.3.19.  layouthint4**

```text
   struct layouthint4 {
           layouttype4             loh_type;
           opaque                  loh_body<>;
   };
```

레이아웃힌트4 데이터 유형은 클라이언트가 특정 파일에 대해 생성하려는 레이아웃 유형에 대한 힌트를 전달하는 데 사용됩니다. 5.12.4절에 설명된 레이아웃\_힌트 속성에 의해 지정된 데이터 유형입니다. 메타데이터 서버는 힌트를 무시하거나 힌트 내의 필드를 선택적으로 무시할 수 있습니다. 이 힌트는 생성 시 OPEN 내의 초기 속성의 일부로 제공되어야 합니다. loh\_body 필드는 레이아웃 유형\(loh\_type\)에 따라 다릅니다. NFSv4.1 파일 기반 레이아웃은 섹션 13.3에 정의된 nfsv4\_1\_file\_layouthint4 데이터 유형을 사용합니다.

---
#### **3.3.20.  layoutiomode4**

```text
   enum layoutiomode4 {
           LAYOUTIOMODE4_READ      = 1,
           LAYOUTIOMODE4_RW        = 2,
           LAYOUTIOMODE4_ANY       = 3
   };
```

iomode는 클라이언트가 레이아웃에 표시된 데이터를 읽기만 할 것인지 아니면 읽고 쓸 것인지를 지정합니다. LAYOUTIOMODE4\_ANY iomode는 LAYOUTGET 작업에 대한 인수에 사용되어서는 안 되지만, LAYOUTRETURN 및 CB\_LAYOUTRECALL 작업에 대한 인수에는 사용될 수 있습니다. LAYOUTIOMODE4\_ANY iomode는 LAYOUTIOMODE4\_READ 및 LAYOUTIOMODE4\_RW iomode와 관련된 레이아웃이 각각 반환되거나 호출되도록 지정합니다. 메타데이터 서버의 iomode 사용은 사용 중인 레이아웃 유형에 따라 달라질 수 있습니다. 저장 장치는 iomode에 대해 I/O 액세스를 검증하고 유효하지 않은 액세스를 거부할 수 있습니다.\(MUST NOT, MAY\)

---
#### **3.3.21.  nfs_impl_id4**

```text
   struct nfs_impl_id4 {
           utf8str_cis   nii_domain;
           utf8str_cs    nii_name;
           nfstime4      nii_date;
   };
```

이 데이터 유형은 클라이언트 및 서버 구현 세부 정보를 식별하는 데 사용됩니다. nii\_domain 필드는 구현자가 연결된 DNS 도메인 이름입니다. nii\_name 필드는 구현의 제품 이름이며 완전히 자유 형식입니다. 기계 아키텍처, 기계 플랫폼, 개정판, 버전 및 패치 수준을 구별하기 위해 nii\_name을 사용하는 것이 권장됩니다. nii\_date 필드는 소프트웨어 인스턴스가 게시되거나 구축된 시점의 타임스탬프입니다.\(SHOULD\)

---
#### **3.3.22.  threshold_item4**

```text
   struct threshold_item4 {
           layouttype4     thi_layout_type;
           bitmap4         thi_hintset;
           opaque          thi_hintlist<>;
   };
```

이 데이터 유형에는 클라이언트가 메타데이터 서버와 저장 장치를 통해 직접 I/O를 보내야 하는 시기를 결정하는 데 도움이 되는 레이아웃 유형별 힌트 목록이 포함되어 있습니다. 데이터 유형은 레이아웃 유형\(thi\_layout\_type\), 서버에서 지원하는 힌트 세트\(레이아웃 유형에 따라 다를 수 있음\)를 설명하는 비트맵\(thi\_hintset\), 내용이 다음에 의해 결정되는 힌트 목록\(thi\_hintlist\)으로 구성됩니다. 힌트셋 비트맵 자세한 내용은 mdsthreshold 속성을 참조하세요.

thi\_hintset 필드는 다음 값의 비트맵입니다.

```text
   +=========================+===+=========+===========================+
   | name                    | # | Data    | Description               |
   |                         |   | Type    |                           |
   +=========================+===+=========+===========================+
   | threshold4_read_size    | 0 | length4 | If a file's length is     |
   |                         |   |         | less than the value of    |
   |                         |   |         | threshold4_read_size,     |
   |                         |   |         | then it is RECOMMENDED    |
   |                         |   |         | that the client read      |
   |                         |   |         | from the file via the     |
   |                         |   |         | MDS and not a storage     |
   |                         |   |         | device.                   |
   +-------------------------+---+---------+---------------------------+
   | threshold4_write_size   | 1 | length4 | If a file's length is     |
   |                         |   |         | less than the value of    |
   |                         |   |         | threshold4_write_size,    |
   |                         |   |         | then it is RECOMMENDED    |
   |                         |   |         | that the client write     |
   |                         |   |         | to the file via the       |
   |                         |   |         | MDS and not a storage     |
   |                         |   |         | device.                   |
   +-------------------------+---+---------+---------------------------+
   | threshold4_read_iosize  | 2 | length4 | For read I/O sizes        |
   |                         |   |         | below this threshold,     |
   |                         |   |         | it is RECOMMENDED to      |
   |                         |   |         | read data through the     |
   |                         |   |         | MDS.                      |
   +-------------------------+---+---------+---------------------------+
   | threshold4_write_iosize | 3 | length4 | For write I/O sizes       |
   |                         |   |         | below this threshold,     |
   |                         |   |         | it is RECOMMENDED to      |
   |                         |   |         | write data through the    |
   |                         |   |         | MDS.                      |
   +-------------------------+---+---------+---------------------------+

                                  Table 2
```

---
#### **3.3.23.  mdsthreshold4**

```text
   struct mdsthreshold4 {
           threshold_item4 mth_hints<>;
   };
```

이 데이터 유형은 데이터 유형 Threshold\_item4의 요소 배열을 보유하며, 각 요소는 특정 레이아웃 유형에 유효합니다. 서버는 단일 파일에 대해 여러 레이아웃 유형을 지원할 수 있으므로 배열이 필요합니다.

---
## **4.  Filehandles**

NFS 프로토콜의 파일 핸들은 파일 시스템 개체에 대한 서버별 고유 식별자입니다. 파일 핸들의 내용은 클라이언트에게 불투명합니다. 따라서 서버는 파일 핸들을 파일 시스템 개체의 내부 표현으로 변환하는 일을 담당합니다.

---
### **4.1.  Obtaining the First Filehandle**

NFS 프로토콜의 작업은 하나 이상의 파일 핸들 측면에서 정의됩니다. 따라서 클라이언트는 서버와의 통신을 시작하기 위해 파일 핸들이 필요합니다. NFSv3 프로토콜\(RFC 1813 \[38\]\)에는 이 첫 번째 파일 핸들을 얻기 위한 보조 프로토콜이 있습니다. MOUNT 프로토콜\(RPC 프로그램 번호 100005\)은 문자열 기반 파일 시스템 경로 이름을 NFS 프로토콜에서 사용할 수 있는 파일 핸들로 변환하는 메커니즘을 제공합니다.

MOUNT 프로토콜은 보안 및 방화벽을 통한 사용 측면에서 결함이 있습니다. 이것이 RFC 2054\[49\] 및 RFC 2055\[50\]에 공개 파일 핸들의 사용이 도입된 이유 중 하나입니다. NFSv3 프로토콜의 LOOKUP 작업과 함께 공용 파일 핸들을 사용하면 NFS 클라이언트와 서버 간의 실행 가능한 상호 작용에 MOUNT 프로토콜이 필요하지 않다는 것이 입증되었습니다.

따라서 NFSv4.1 프로토콜은 문자열 기반 경로 이름을 파일 핸들로 변환하기 위해 보조 프로토콜을 사용하지 않습니다. 두 개의 특수 파일 핸들이 NFS 클라이언트의 시작점으로 사용됩니다.

---
#### **4.1.1.  Root Filehandle**

특수 파일 핸들 중 첫 번째는 ROOT 파일 핸들입니다. ROOT 파일핸들은 NFS 서버에 있는 파일 시스템 네임스페이스의 "개념적" 루트입니다. 클라이언트는 PUTROOTFH 작업을 사용하여 ROOT 파일 핸들을 사용하거나 시작합니다. PUTROOTFH 작업은 "현재" 파일 핸들을 서버 파일 트리의 ROOT로 설정하도록 서버에 지시합니다. 이 PUTROOTFH 작업이 사용되면 클라이언트는 LOOKUP 작업을 통해 서버의 파일 트리 전체를 탐색할 수 있습니다. 서버 네임스페이스에 대한 전체 논의는 섹션 7에 있습니다.

---
#### **4.1.2.  Public Filehandle**

두 번째 특수 파일 핸들은 PUBLIC 파일 핸들입니다. ROOT 파일 핸들과 달리 PUBLIC 파일 핸들은 서버에서 임의의 파일 시스템 개체를 바인딩하거나 나타낼 수 있습니다. 서버는 이 바인딩을 담당합니다. PUBLIC 파일 핸들과 ROOT 파일 핸들이 동일한 파일 시스템 개체를 참조할 수 있습니다. 그러나 PUBLIC 파일 핸들과 서버 파일 시스템 객체의 바인딩을 정의하는 것은 서버의 관리 소프트웨어와 서버 관리자의 정책에 달려 있습니다. 클라이언트는 이 바인딩에 대해 어떤 가정도 하지 않을 수 있습니다. 클라이언트는 PUTPUBFH 작업을 통해 PUBLIC 파일 핸들을 사용합니다.

---
### **4.2.  Filehandle Types**

NFSv3 프로토콜에는 단일 의미 집합을 가진 한 가지 유형의 파일 핸들이 있었습니다. NFSv4.1에서는 이러한 유형의 파일 핸들을 "지속적"이라고 합니다. 영구 파일 핸들의 의미는 이전과 동일하게 유지됩니다. NFSv4.1에 도입된 새로운 유형의 파일 핸들은 특정 서버 환경을 수용하려고 시도하는 "휘발성" 파일 핸들입니다.

휘발성 파일 핸들 유형은 영구 파일 핸들의 올바른 구현을 불가능하게 만드는 서버 기능 또는 구현 문제를 해결하기 위해 도입되었습니다. 일부 서버 환경에서는 영구 파일 핸들을 구성하는 데 사용할 수 있는 파일 시스템 수준 불변성을 제공하지 않습니다. 기본 서버 파일 시스템이 불변성을 제공하지 않거나 서버의 파일 시스템 프로그래밍 인터페이스가 필요한 불변성에 대한 액세스를 제공하지 않을 수 있습니다. 휘발성 파일 핸들은 계층적 스토리지 관리, 파일 시스템 재구성 또는 마이그레이션과 같은 서버 기능의 구현을 용이하게 할 수 있습니다. 그러나 휘발성 파일 핸들은 클라이언트의 구현 부담을 증가시킵니다.

클라이언트는 영구 파일 핸들과 휘발성 파일 핸들을 다르게 처리해야 하므로 클라이언트가 서버에서 반환하는 파일 핸들 유형을 결정하는 데 사용할 수 있는 파일 속성이 정의됩니다.

---
#### **4.2.1.  General Properties of a Filehandle**

파일 핸들에는 서버가 개별 파일을 구별하는 데 필요한 모든 정보가 포함되어 있습니다. 클라이언트에게는 파일 핸들이 불투명합니다. 클라이언트는 이후 요청에 사용할 파일 핸들을 저장하고 바이트 단위 비교를 수행하여 동일한 서버의 두 파일 핸들이 동일한지 비교할 수 있습니다. 그러나 클라이언트는 파일 핸들의 내용을 달리 해석해서는 안 됩니다. 동일한 서버의 두 파일 핸들이 동일한 경우 동일한 파일을 참조해야 합니다. 서버는 파일 핸들과 파일 간의 일대일 대응을 유지하려고 노력해야 하지만 이것이 필수는 아닙니다. 클라이언트는 올바른 동작이 아닌 성능 향상을 위해서만 파일 핸들 비교를 사용해야 합니다. 모든 클라이언트는 두 파일 핸들이 동일한 개체를 나타내는지 여부를 확인할 수 없는 상황에 대비해야 하며, 이러한 경우 잘못된 동작을 유발할 수 있는 잘못된 가정을 피해야 합니다. 데이터 캐싱의 맥락에서 파일 핸들과 속성 비교에 대한 추가 논의는 섹션 10.3.4에 나와 있습니다.\(MUST NOT, MUST, SHOULD, MUST\)

예를 들어, 서버에서 탐색할 때 두 개의 서로 다른 경로 이름이 동일한 파일 시스템 개체에서 종료되는 경우 서버는 각 경로에 대해 동일한 파일 핸들을 반환해야 합니다\(SHOULD\). 이는 하드 링크\(\[6\] 참조\)를 사용하여 동일한 기본 파일 개체 및 관련 데이터를 참조하는 두 개의 파일 이름을 만드는 경우 발생할 수 있습니다. 예를 들어, /a/b/c 및 /a/d/c 경로가 동일한 파일을 참조하는 경우 서버는 두 경로 이름의 순회에 대해 동일한 파일 핸들을 반환해야 합니다\(SHOULD\).\(SHOULD, SHOULD\)

---
#### **4.2.2.  Persistent Filehandle**

영구 파일 핸들은 참조하는 파일 시스템 객체의 수명 동안 고정된 값을 갖는 것으로 정의됩니다. 서버가 파일 시스템 개체에 대한 파일 핸들을 생성하면 서버는 개체의 수명 동안 해당 개체에 대해 동일한 파일 핸들을 수락해야 합니다. 서버가 다시 시작되면 NFS 서버는 서버의 이전 인스턴스화에서와 동일한 파일 핸들 값을 존중해야 합니다. 마찬가지로, 파일 시스템이 마이그레이션되면 새 NFS 서버는 이전 NFS 서버와 동일한 파일 핸들을 존중해야 합니다.\(MUST, MUST, MUST\)

파일 시스템 객체가 제거되면 영구 파일 핸들은 오래되거나 유효하지 않게 됩니다. 서버에 삭제된 객체를 참조하는 영구 파일 핸들이 표시되면 NFS4ERR\_STALE 오류를 반환해야 합니다. 객체를 포함하는 파일 시스템을 더 이상 사용할 수 없으면 파일 핸들이 오래될 수 있습니다. 파일 시스템이 이동식 미디어에 존재하고 해당 미디어를 서버에서 더 이상 사용할 수 없거나 파일 시스템 전체가 삭제되었거나 파일 시스템이 서버의 네임스페이스에서 제거된 경우\(예: UNIX에서 마운트 해제된 경우\) 파일 시스템을 사용할 수 없게 될 수 있습니다. 환경\).\(MUST\)

---
#### **4.2.3.  Volatile Filehandle**

휘발성 파일 핸들은 영구 파일 핸들과 동일한 수명 특성을 공유하지 않습니다. 서버는 여러 시점에서 휘발성 파일 핸들이 더 이상 유효하지 않다고 판단할 수 있습니다. 서버가 휘발성 파일 핸들이 제거된 객체를 참조한다는 것을 확실히 확인할 수 있는 경우 서버는 NFS4ERR\_STALE을 클라이언트에 반환해야 합니다\(영구 파일 핸들의 경우와 마찬가지로\). 서버가 휘발성 파일 핸들을 더 이상 사용할 수 없다고 판단하는 다른 모든 경우에는 NFS4ERR\_FHEXPIRED 오류를 반환해야 합니다.

필수 속성 "fh\_expire\_type"은 클라이언트가 서버가 특정 파일 시스템에 제공하는 파일 핸들 유형을 결정하는 데 사용됩니다. 이 속성은 다음 값을 가진 비트마스크입니다.\(MUST\)

FH4\_PERSISTENT FH4\_PERSISTENT 값은 객체가 파일 시스템에서 제거될 때까지 유효한 영구 파일 핸들을 나타내는 데 사용됩니다. 서버는 이 파일 핸들에 대해 NFS4ERR\_FHEXPIRED를 반환하지 않습니다. FH4\_PERSISTENT는 아래에 명시된 비트가 하나도 설정되지 않은 값으로 정의됩니다.

FH4\_VOLATILE\_ANY 파일 핸들은 특별히 제외된 경우\(예: FH4\_NO\_EXPIRE\_WITH\_OPEN\)를 제외하고 언제든지 만료될 수 있습니다.

FH4\_NOEXPIRE\_WITH\_OPEN FH4\_VOLATILE\_ANY가 설정된 경우에만 설정할 수 있습니다. 이 비트가 설정되면 FH4\_VOLATILE\_ANY의 의미는 파일 핸들이 열려 있을 때 파일 핸들의 만료를 제외하도록 규정됩니다.

FH4\_VOL\_MIGRATION 파일 핸들 사용의 연속성이 fs\_locations\_info 속성 내의 핸들 클래스 정보에 의해 지정되지 않은 경우 파일 시스템 전환\(마이그레이션 또는 복제\)의 결과로 파일 핸들이 만료됩니다. 이 비트가 설정되면 fs\_locations\_info 정보에 액세스할 수 없는 클라이언트는 파일 시스템 전환 시 파일 핸들이 만료된다고 가정해야 합니다.

FH4\_VOL\_RENAME 이름을 바꾸는 동안 파일 핸들이 만료됩니다. 여기에는 요청 클라이언트에 의한 이름 바꾸기 또는 다른 클라이언트에 의한 이름 바꾸기가 포함됩니다. FH4\_VOL\_ANY가 설정된 경우 FH4\_VOL\_RENAME은 중복됩니다.

열려 있는 동안 만료될 수 있는 휘발성 파일 핸들을 제공하는 서버는 RENAME 및 REMOVE 처리와 관련하여 특별한 주의가 필요합니다. 이러한 상황은 FH4\_VOL\_MIGRATION 또는 FH4\_VOL\_RENAME이 설정된 경우, FH4\_VOLATILE\_ANY가 설정되고 FH4\_NOEXPIRE\_WITH\_OPEN이 설정되지 않은 경우 또는 읽기 전용이 아닌 파일 시스템에 다른 핸들 클래스의 전환 대상이 있는 경우 발생할 수 있습니다. 이러한 경우 서버는 OPEN 파일로 이어지는 모든 구성 요소의 OPEN 파일에 영향을 미치는 RENAME 또는 REMOVE를 거부해야 합니다. 또한 파일 핸들이 만료되었을 수 있는 파일의 회수가 잘못된 파일에 대한 회수를 수행하지 않도록 하기 위해 서버는 유예 기간 동안 모든 RENAME 또는 REMOVE 요청을 거부해야 합니다.

휘발성 파일 핸들은 내보내기를 연결하는 데 사용되는 의사 파일 시스템 구현에 특히 적합합니다. 이에 대한 논의는 섹션 7.5를 참조하십시오.

---
### **4.3.  One Method of Constructing a Volatile Filehandle**

휘발성 파일 핸들은 클라이언트에게는 불투명하지만 다음을 포함할 수 있습니다.

```text
   [volatile bit = 1 | server boot time | slot | generation number]
```

\* 슬롯은 서버 휘발성 파일 핸들 테이블의 인덱스입니다.

\* 세대번호는 테이블 엔트리/슬롯의 세대번호입니다.

클라이언트가 휘발성 파일 핸들을 제시하면 서버는 휘발성 비트에 대한 검사가 통과되었다고 가정하여 다음 검사를 수행합니다. 서버 부팅 시간이 현재 서버 부팅 시간보다 짧으면 NFS4ERR\_FHEXPIRED를 반환합니다. 슬롯이 범위를 벗어나면 NFS4ERR\_BADHANDLE을 반환합니다. 세대 번호가 일치하지 않으면 NFS4ERR\_FHEXPIRED를 반환합니다.

서버가 다시 시작되면 테이블이 사라집니다\(휘발성임\).

휘발성 비트가 0이면 그 뒤에 다른 구조가 있는 영구 파일 핸들입니다.

---
### **4.4.  Client Recovery from Filehandle Expiration**

가능하다면 클라이언트는 NFS4ERR\_FHEXPIRED 오류 수신으로부터 복구해야 합니다. 클라이언트는 휘발성 파일 핸들의 만료로부터 복구할 준비를 할 수 있도록 추가 책임을 져야 합니다. 서버가 영구 파일 핸들을 반환하는 경우 클라이언트에는 이러한 추가 단계가 필요하지 않습니다.\(SHOULD\)

휘발성 파일 핸들의 경우 가장 일반적으로 클라이언트는 문제의 파일 시스템 개체를 포함하여 이어지는 구성 요소 이름을 저장해야 합니다. 이러한 이름을 사용하면 클라이언트는 여전히 사용 가능한 네임스페이스에서 파일 핸들을 찾거나 서버의 파일 시스템 네임스페이스 루트에서 시작하여 복구할 수 있어야 합니다.

만료된 파일 핸들이 파일 시스템에서 제거된 개체를 참조하는 경우 클라이언트는 만료된 파일 핸들에서 복구할 수 없습니다.

만료된 파일 핸들이 이름이 변경된 파일을 참조할 수도 있습니다. 다른 클라이언트가 파일 이름을 바꾼 경우 원래 클라이언트가 복구하지 못할 수도 있습니다. 그러나 클라이언트 자체가 파일 이름을 바꾸는 중이고 파일이 열려 있는 경우에는 클라이언트가 복구할 수도 있습니다. 클라이언트는 이름 바꾸기 요청 처리를 기반으로 새 경로 이름을 결정할 수 있습니다. 그런 다음 클라이언트는 새 경로 이름을 기반으로 새 파일 핸들을 다시 생성할 수 있습니다. 클라이언트는 COMPOUND 프로시저를 사용하여 다음과 같은 일련의 작업을 구성할 수도 있습니다.

```text
             RENAME A B
             LOOKUP B
             GETFH
```

COMPOUND 프로시저는 원자성을 제공하지 않습니다. 이 예는 만료된 파일 핸들에서 복구하는 오버헤드만 줄입니다.

---
## **5.  File Attributes**

확장성 및 비 UNIX 플랫폼과의 상호 운용성 향상 요구 사항을 충족하려면 속성을 유연한 방식으로 처리해야 합니다. NFSv3 fattr3 구조에는 모든 클라이언트와 서버가 지원하거나 관심을 가질 수 없는 고정된 속성 목록이 포함되어 있습니다. fattr3 구조는 새로운 요구가 발생할 때 확장될 수 없으며 지원되지 않음을 나타낼 방법을 제공하지 않습니다. NFSv4.1 프로토콜을 사용하면 클라이언트는 서버가 지원하는 속성을 쿼리하고 지원되는 속성\(또는 그 하위 집합\)만으로 요청을 구성할 수 있습니다.

이를 위해 속성은 REQUIRED, RECOMMENDED 및 명명된 세 그룹으로 나뉩니다. REQUIRED 및 RECOMMENDED 속성은 NFSv4.1 프로토콜에서 구체적이고 잘 정의된 인코딩으로 지원되며 숫자로 식별됩니다. GETATTR 요청에서 전송된 비트 벡터에 비트를 설정하여 요청됩니다. 서버 응답에는 응답에 반환된 속성을 나열하는 비트 벡터가 포함되어 있습니다. 새로운 REQUIRED 또는 RECOMMENDED 속성은 새로운 속성 번호 값을 할당하고 속성에 대한 인코딩을 정의하는 표준 트랙 RFC를 게시하여 새로운 마이너 버전의 일부로 NFSv4 프로토콜에 추가될 수 있습니다. 자세한 내용은 섹션 2.7을 참조하세요.\(MUST, MUST, MUST\)

명명된 속성은 파일 시스템 객체와 연관된 속성의 숨겨진 디렉터리에 액세스하는 새로운 OPENATTR 작업을 통해 액세스됩니다. OPENATTR은 객체에 대한 파일 핸들을 취하고 속성 계층에 대한 파일 핸들을 반환합니다. 명명된 속성에 대한 파일 핸들은 LOOKUP 또는 READDIR로 액세스할 수 있는 디렉터리 개체이며 이름이 명명된 속성을 나타내고 데이터 바이트가 속성의 값인 파일을 포함합니다. 예를 들어:

```text
        +----------+-----------+---------------------------------+
        | LOOKUP   | "foo"     | ; look up file                  |
        +----------+-----------+---------------------------------+
        | GETATTR  | attrbits  |                                 |
        +----------+-----------+---------------------------------+
        | OPENATTR |           | ; access foo's named attributes |
        +----------+-----------+---------------------------------+
        | LOOKUP   | "x11icon" | ; look up specific attribute    |
        +----------+-----------+---------------------------------+
        | READ     | 0,4096    | ; read stream of bytes          |
        +----------+-----------+---------------------------------+

                                 Table 3
```

명명된 속성은 NFS 클라이언트 구현이 아닌 애플리케이션에 필요한 데이터를 위한 것입니다. NFS 구현자는 새로운 속성을 IETF 표준 추적 프로세스에 적용하여 RECOMMENDED 속성으로 정의하는 것이 좋습니다.\(SHOULD\)

REQUIRED로 분류된 속성 세트는 서버가 이를 지원하기 위해 필요한 모든 작업을 수행해야 하기 때문에 의도적으로 작습니다. 서버는 가능한 한 많은 RECOMMENDED 속성을 지원해야 하지만 정의에 따르면 서버는 모든 속성을 지원할 필요는 없습니다. 데이터가 다수의 클라이언트에 의해 필요하고 서버에서 지원이 제공되지 않을 때 클라이언트가 합리적으로 계산할 수 없는 경우 속성은 필수로 간주됩니다.\(MUST, SHOULD, MUST\)

OPENATTR에 의해 반환된 숨겨진 디렉터리는 프로토콜 처리의 편의를 위한 것입니다. 클라이언트는 서버의 명명된 속성 구현과 서버의 기본 파일 시스템에 명명된 속성 디렉터리가 있는지 여부에 대해 어떤 가정도 해서는 안 됩니다. 따라서 명명된 특성 디렉터리에 대한 SETATTR 및 GETATTR과 같은 작업은 정의되지 않습니다.

---
### **5.1.  REQUIRED Attributes**

최소 수준의 상호 운용성을 보장하려면 모든 NFSv4.1 클라이언트 및 서버에서 이를 지원해야 합니다. 서버는 이러한 속성을 저장하고 반환해야 하며\(MUST\), 클라이언트는 이러한 속성으로 제한된 속성 세트로 작동할 수 있어야 합니다\(MUST\). 필수 속성만 사용하면 일부 클라이언트 기능이 어떤 방식으로든 손상되거나 제한될 수 있습니다. 클라이언트는 GETATTR 요청에서 비트를 설정하여 이러한 속성 중 하나가 반환되도록 요청할 수 있으며 서버는 해당 값을 반환해야 합니다.\(MUST, MUST, MUST, MUST\)

---
### **5.2.  RECOMMENDED Attributes**

이러한 속성은 NFSv4.1 프로토콜의 지원을 보증할 만큼 충분히 잘 이해되어 있습니다. 그러나 일부 클라이언트 및 서버에서는 지원되지 않을 수 있습니다. 클라이언트는 GETATTR 요청에 비트를 설정하여 이러한 속성이 반환되도록 요청할 수 있지만 서버가 해당 속성을 반환하지 않는 경우를 처리해야 합니다. 클라이언트는 서버가 지원하는 속성 세트를 요청할 수 있으며 서버가 지원하지 않는 속성을 요청해서는 안 됩니다. 서버는 지원되지 않는 속성에 대한 요청을 허용해야 하며 요청을 오류로 간주하기보다는 단순히 해당 속성을 반환하지 않아야 합니다. 서버는 편안하게 할 수 있는 모든 속성을 지원하고 운영 환경에서 지원하기 어려운 속성만 지원하지 못할 것으로 예상됩니다. 서버는 클라이언트에게 "거짓말"을 할 필요가 없을 때마다 속성을 제공해야 합니다. 예를 들어, 파일 수정 시간은 정확한 시간이어야 하며 서버에서 지원하지 않아야 합니다. 때로는 이것이 내담자에게 어려울 수도 있지만, 내담자는 속성을 조작하거나 구성할지 여부와 속성 없이 수행할지 여부와 방법을 결정하는 데 더 나은 위치에 있습니다.\(SHOULD NOT\)

---
### **5.3.  Named Attributes**

이러한 속성은 NFSv4 프로토콜의 직접 인코딩에서는 지원되지 않지만 숫자가 아닌 문자열 이름으로 액세스되며 파일 시스템 개체와 함께 저장되는 해석되지 않은 바이트 스트림에 해당합니다. 이러한 속성의 네임스페이스는 OPENATTR 작업을 사용하여 액세스할 수 있습니다. OPENATTR 작업은 가상의 "명명된 속성 디렉터리"에 대한 파일 핸들을 반환하며, 보다 일반적인 디렉터리에서 작동하는 작업을 사용하여 네임스페이스를 자세히 살펴보고 수정할 수 있습니다. 특히, READDIR은 그러한 명명된 속성의 목록을 가져오는 데 사용될 수 있으며 LOOKUP 및 OPEN은 특정 속성을 선택할 수 있습니다. 새로운 명명된 속성의 생성은 파일 생성을 지정하는 OPEN의 결과일 수 있습니다.

OPEN이 완료되면 명명된 속성은 OPEN에서 반환된 파일 핸들 및 상태 ID를 사용하여 일반적인 READ 및 WRITE 작업으로 검사하고 변경할 수 있습니다.

명명된 속성과 명명된 속성 디렉터리에는 고유한\(이름이 지정되지 않은\) 속성이 있을 수 있습니다. 이들 객체 각각은 REQUIRED 속성을 모두 가져야 하며 추가적인 RECOMMENDED 속성을 가질 수도 있습니다. 그러나 명명된 속성 및 명명된 속성 디렉터리에 대한 속성 집합은 해당 파일 시스템의 다른 객체에 대한 집합만큼 클 필요는 없으며 일반적으로 클 필요도 없습니다.\(MUST\)

명명된 특성과 명명된 특성 디렉터리는 위임 대상이 될 수 있습니다. 명명된 특성 디렉터리의 경우 디렉터리 위임이 됩니다. 그러나 위임 승인은 서버의 재량에 달려 있으므로 서버는 명명된 속성이나 명명된 속성 디렉터리에 대한 위임을 지원할 필요가 없습니다.

서버가 임의의 명명된 속성을 지원하는 것이 좋습니다. 클라이언트는 서버의 파일 시스템에 명명된 속성을 저장하는 기능에 의존해서는 안 됩니다. 서버가 명명된 속성을 지원하는 경우 이를 처리할 수 있는 클라이언트는 파일의 데이터와 메타데이터를 한 위치에서 다른 위치로 완전히 투명하게 복사할 수 있어야 합니다. 이는 일반 디렉토리 항목에 허용되는 이름이 명명된 속성 이름에도 유효함을 의미합니다.\(SHOULD\)

NFSv4.1에서는 일부 서버가 명명된 속성에 대해 완전히 일반적인 계층적 디렉터리 구조를 지원하는 반면 다른 서버에서는 제한적이지만 지원하는 비상호 운용 구현의 개발을 방지하기 위해 명명된 속성 디렉터리의 구조가 여러 가지 방식으로 제한됩니다. 명명된 속성에 대한 적절한 구조. 이러한 환경에서는 클라이언트나 애플리케이션이 이식 불가능한 확장에 의존하게 될 수 있습니다. 제한사항은 다음과 같습니다.

\* 명명된 속성 디렉터리에서는 CREATE가 허용되지 않습니다. 따라서 기호 링크 및 특수 파일과 같은 객체에는 이름 속성이 허용되지 않습니다. 또한 명명된 특성 디렉터리에는 디렉터리를 생성할 수 없으므로 단일 개체에 대한 명명된 특성의 계층 구조는 허용되지 않습니다.

\* OPENATTR이 명명된 속성 디렉터리 또는 명명된 속성에서 수행되면 서버는 NFS4ERR\_WRONG\_TYPE을 반환해야 합니다.\(MUST\)

\* 이름이 지정된 속성의 RENAME을 다른 이름의 속성 디렉터리 또는 일반\(즉, 이름이 지정되지 않은 속성\) 디렉터리로 수행하는 것은 허용되지 않습니다.

\* 명명된 속성 디렉터리 간 또는 명명된 속성 디렉터리와 일반 디렉터리 간에 하드 링크를 만드는 것은 허용되지 않습니다.

속성 이름은 이 문서나 다른 IETF 표준 트랙 문서에 의해 제어되지 않습니다. 자세한 내용은 섹션 22.2를 참조하세요.

---
### **5.4.  Classification of Attributes**

REQUIRED 및 RECOMMENDED 속성 각각은 세 가지 범주 중 하나로 분류될 수 있습니다. 서버별\(즉, 속성 값은 동일한 서버 소유자를 공유하는 모든 파일 객체에 대해 동일합니다. 서버 소유자 정의는 섹션 2.5를 참조하세요. \), 파일 시스템당\(즉, 속성 값은 동일한 fsid 속성\(섹션 5.8.1.9\) 및 서버 소유자를 공유하는 일부 또는 모든 파일 객체에 대해 동일합니다\) 또는 파일 시스템 객체별로. "동종"\(섹션 5.8.2.16\) 속성 값에 따라 파일 시스템별 일부 속성이 파일 시스템 내에서 달라질 수 있다는 점에 유의하세요. time\_access\_set 및 time\_modify\_set 속성은 time\_access 및 time\_modify에 해당하는 쓰기 전용 속성이고 SETATTR의 특수 인스턴스에서 사용되기 때문에 이 섹션에 나열되지 않습니다.\(MUST\)

\* 서버별 속성은 다음과 같습니다.

```text
         lease_time
```

\* 파일별 시스템 속성은 다음과 같습니다.

```text
         supported_attrs, suppattr_exclcreat, fh_expire_type,
         link_support, symlink_support, unique_handles, aclsupport,
         cansettime, case_insensitive, case_preserving,
         chown_restricted, files_avail, files_free, files_total,
         fs_locations, homogeneous, maxfilesize, maxname, maxread,
         maxwrite, no_trunc, space_avail, space_free, space_total,
         time_delta, change_policy, fs_status, fs_layout_type,
         fs_locations_info, fs_charset_cap
```

\* 파일 시스템별 개체 속성은 다음과 같습니다.

```text
         type, change, size, named_attr, fsid, rdattr_error, filehandle,
         acl, archive, fileid, hidden, maxlink, mimetype, mode,
         numlinks, owner, owner_group, rawdev, space_used, system,
         time_access, time_backup, time_create, time_metadata,
         time_modify, mounted_on_fileid, dir_notif_delay,
         dirent_notif_delay, dacl, sacl, layout_type, layout_hint,
         layout_blksize, layout_alignment, mdsthreshold, retention_get,
         retention_set, retentevt_get, retentevt_set, retention_hold,
         mode_set_masked
```

quota\_avail\_hard, quota\_avail\_soft 및 quota\_used의 경우 적절한 분류에 대해서는 아래 정의를 참조하세요.

---
### **5.5.  Set-Only and Get-Only Attributes**

일부 REQUIRED 및 RECOMMENDED 속성은 설정 전용입니다. 즉, SETATTR을 통해 설정할 수 있지만 GETATTR을 통해 검색할 수는 없습니다. 마찬가지로 일부 REQUIRED 및 RECOMMENDED 속성은 가져오기 전용입니다. 즉, GETATTR을 통해 검색할 수 있지만 SETATTR을 통해 설정할 수는 없습니다. 클라이언트가 get-only 속성을 설정하거나 set-only 속성을 얻으려고 시도하는 경우 서버는 NFS4ERR\_INVAL을 반환해야 합니다.\(MUST, MUST, MUST\)

---
### **5.6.  REQUIRED Attributes - List and Definition References**

필수 속성 목록은 표 4에 나와 있습니다. 표 열의 의미는 다음과 같습니다.\(MUST\)

이름: 속성의 이름입니다.

Id: 속성에 할당된 번호입니다. 할당된 번호와 \[10\] 사이에 충돌이 있는 경우 후자가 신뢰할 수 있지만 이 문서 및/또는 \[10\]에 대한 정오표를 사용하여 해결해야 합니다. Errata 프로세스는 \[51\]을 참조하십시오.

데이터 유형: 속성의 XDR 데이터 유형입니다.

Acc: 속성에 대한 액세스가 허용됩니다. R은 읽기 전용을 의미합니다\(GETATTR은 검색할 수 있고 SETATTR은 설정할 수 없음\). W는 쓰기 전용을 의미합니다\(SETATTR은 설정할 수 있고 GETATTR은 검색할 수 없음\). R W는 읽기/쓰기를 의미합니다\(GETATTR은 검색할 수 있고 SETATTR은 설정할 수 있음\).

정의: 속성을 설명하는 이 사양의 섹션입니다.

```text
     +====================+====+============+=====+==================+
     | Name               | Id | Data Type  | Acc | Defined in:      |
     +====================+====+============+=====+==================+
     | supported_attrs    | 0  | bitmap4    | R   | Section 5.8.1.1  |
     +--------------------+----+------------+-----+------------------+
     | type               | 1  | nfs_ftype4 | R   | Section 5.8.1.2  |
     +--------------------+----+------------+-----+------------------+
     | fh_expire_type     | 2  | uint32_t   | R   | Section 5.8.1.3  |
     +--------------------+----+------------+-----+------------------+
     | change             | 3  | uint64_t   | R   | Section 5.8.1.4  |
     +--------------------+----+------------+-----+------------------+
     | size               | 4  | uint64_t   | R W | Section 5.8.1.5  |
     +--------------------+----+------------+-----+------------------+
     | link_support       | 5  | bool       | R   | Section 5.8.1.6  |
     +--------------------+----+------------+-----+------------------+
     | symlink_support    | 6  | bool       | R   | Section 5.8.1.7  |
     +--------------------+----+------------+-----+------------------+
     | named_attr         | 7  | bool       | R   | Section 5.8.1.8  |
     +--------------------+----+------------+-----+------------------+
     | fsid               | 8  | fsid4      | R   | Section 5.8.1.9  |
     +--------------------+----+------------+-----+------------------+
     | unique_handles     | 9  | bool       | R   | Section 5.8.1.10 |
     +--------------------+----+------------+-----+------------------+
     | lease_time         | 10 | nfs_lease4 | R   | Section 5.8.1.11 |
     +--------------------+----+------------+-----+------------------+
     | rdattr_error       | 11 | enum       | R   | Section 5.8.1.12 |
     +--------------------+----+------------+-----+------------------+
     | filehandle         | 19 | nfs_fh4    | R   | Section 5.8.1.13 |
     +--------------------+----+------------+-----+------------------+
     | suppattr_exclcreat | 75 | bitmap4    | R   | Section 5.8.1.14 |
     +--------------------+----+------------+-----+------------------+

                                  Table 4
```

---
### **5.7.  RECOMMENDED Attributes - List and Definition References**

RECOMMENDED 속성은 표 5에 정의되어 있습니다. 열 헤더의 의미는 표 4와 동일합니다. 의미는 섹션 5.6을 참조하십시오.\(SHOULD\)

```text
   +====================+====+====================+=====+=============+
   | Name               | Id | Data Type          | Acc | Defined in: |
   +====================+====+====================+=====+=============+
   | acl                | 12 | nfsace4<>          | R W | Section     |
   |                    |    |                    |     | 6.2.1       |
   +--------------------+----+--------------------+-----+-------------+
   | aclsupport         | 13 | uint32_t           | R   | Section     |
   |                    |    |                    |     | 6.2.1.2     |
   +--------------------+----+--------------------+-----+-------------+
   | archive            | 14 | bool               | R W | Section     |
   |                    |    |                    |     | 5.8.2.1     |
   +--------------------+----+--------------------+-----+-------------+
   | cansettime         | 15 | bool               | R   | Section     |
   |                    |    |                    |     | 5.8.2.2     |
   +--------------------+----+--------------------+-----+-------------+
   | case_insensitive   | 16 | bool               | R   | Section     |
   |                    |    |                    |     | 5.8.2.3     |
   +--------------------+----+--------------------+-----+-------------+
   | case_preserving    | 17 | bool               | R   | Section     |
   |                    |    |                    |     | 5.8.2.4     |
   +--------------------+----+--------------------+-----+-------------+
   | change_policy      | 60 | chg_policy4        | R   | Section     |
   |                    |    |                    |     | 5.8.2.5     |
   +--------------------+----+--------------------+-----+-------------+
   | chown_restricted   | 18 | bool               | R   | Section     |
   |                    |    |                    |     | 5.8.2.6     |
   +--------------------+----+--------------------+-----+-------------+
   | dacl               | 58 | nfsacl41           | R W | Section     |
   |                    |    |                    |     | 6.2.2       |
   +--------------------+----+--------------------+-----+-------------+
   | dir_notif_delay    | 56 | nfstime4           | R   | Section     |
   |                    |    |                    |     | 5.11.1      |
   +--------------------+----+--------------------+-----+-------------+
   | dirent_notif_delay | 57 | nfstime4           | R   | Section     |
   |                    |    |                    |     | 5.11.2      |
   +--------------------+----+--------------------+-----+-------------+
   | fileid             | 20 | uint64_t           | R   | Section     |
   |                    |    |                    |     | 5.8.2.7     |
   +--------------------+----+--------------------+-----+-------------+
   | files_avail        | 21 | uint64_t           | R   | Section     |
   |                    |    |                    |     | 5.8.2.8     |
   +--------------------+----+--------------------+-----+-------------+
   | files_free         | 22 | uint64_t           | R   | Section     |
   |                    |    |                    |     | 5.8.2.9     |
   +--------------------+----+--------------------+-----+-------------+
   | files_total        | 23 | uint64_t           | R   | Section     |
   |                    |    |                    |     | 5.8.2.10    |
   +--------------------+----+--------------------+-----+-------------+
   | fs_charset_cap     | 76 | uint32_t           | R   | Section     |
   |                    |    |                    |     | 5.8.2.11    |
   +--------------------+----+--------------------+-----+-------------+
   | fs_layout_type     | 62 | layouttype4<>      | R   | Section     |
   |                    |    |                    |     | 5.12.1      |
   +--------------------+----+--------------------+-----+-------------+
   | fs_locations       | 24 | fs_locations       | R   | Section     |
   |                    |    |                    |     | 5.8.2.12    |
   +--------------------+----+--------------------+-----+-------------+
   | fs_locations_info  | 67 | fs_locations_info4 | R   | Section     |
   |                    |    |                    |     | 5.8.2.13    |
   +--------------------+----+--------------------+-----+-------------+
   | fs_status          | 61 | fs4_status         | R   | Section     |
   |                    |    |                    |     | 5.8.2.14    |
   +--------------------+----+--------------------+-----+-------------+
   | hidden             | 25 | bool               | R W | Section     |
   |                    |    |                    |     | 5.8.2.15    |
   +--------------------+----+--------------------+-----+-------------+
   | homogeneous        | 26 | bool               | R   | Section     |
   |                    |    |                    |     | 5.8.2.16    |
   +--------------------+----+--------------------+-----+-------------+
   | layout_alignment   | 66 | uint32_t           | R   | Section     |
   |                    |    |                    |     | 5.12.2      |
   +--------------------+----+--------------------+-----+-------------+
   | layout_blksize     | 65 | uint32_t           | R   | Section     |
   |                    |    |                    |     | 5.12.3      |
   +--------------------+----+--------------------+-----+-------------+
   | layout_hint        | 63 | layouthint4        |   W | Section     |
   |                    |    |                    |     | 5.12.4      |
   +--------------------+----+--------------------+-----+-------------+
   | layout_type        | 64 | layouttype4<>      | R   | Section     |
   |                    |    |                    |     | 5.12.5      |
   +--------------------+----+--------------------+-----+-------------+
   | maxfilesize        | 27 | uint64_t           | R   | Section     |
   |                    |    |                    |     | 5.8.2.17    |
   +--------------------+----+--------------------+-----+-------------+
   | maxlink            | 28 | uint32_t           | R   | Section     |
   |                    |    |                    |     | 5.8.2.18    |
   +--------------------+----+--------------------+-----+-------------+
   | maxname            | 29 | uint32_t           | R   | Section     |
   |                    |    |                    |     | 5.8.2.19    |
   +--------------------+----+--------------------+-----+-------------+
   | maxread            | 30 | uint64_t           | R   | Section     |
   |                    |    |                    |     | 5.8.2.20    |
   +--------------------+----+--------------------+-----+-------------+
   | maxwrite           | 31 | uint64_t           | R   | Section     |
   |                    |    |                    |     | 5.8.2.21    |
   +--------------------+----+--------------------+-----+-------------+
   | mdsthreshold       | 68 | mdsthreshold4      | R   | Section     |
   |                    |    |                    |     | 5.12.6      |
   +--------------------+----+--------------------+-----+-------------+
   | mimetype           | 32 | utf8str_cs         | R W | Section     |
   |                    |    |                    |     | 5.8.2.22    |
   +--------------------+----+--------------------+-----+-------------+
   | mode               | 33 | mode4              | R W | Section     |
   |                    |    |                    |     | 6.2.4       |
   +--------------------+----+--------------------+-----+-------------+
   | mode_set_masked    | 74 | mode_masked4       |   W | Section     |
   |                    |    |                    |     | 6.2.5       |
   +--------------------+----+--------------------+-----+-------------+
   | mounted_on_fileid  | 55 | uint64_t           | R   | Section     |
   |                    |    |                    |     | 5.8.2.23    |
   +--------------------+----+--------------------+-----+-------------+
   | no_trunc           | 34 | bool               | R   | Section     |
   |                    |    |                    |     | 5.8.2.24    |
   +--------------------+----+--------------------+-----+-------------+
   | numlinks           | 35 | uint32_t           | R   | Section     |
   |                    |    |                    |     | 5.8.2.25    |
   +--------------------+----+--------------------+-----+-------------+
   | owner              | 36 | utf8str_mixed      | R W | Section     |
   |                    |    |                    |     | 5.8.2.26    |
   +--------------------+----+--------------------+-----+-------------+
   | owner_group        | 37 | utf8str_mixed      | R W | Section     |
   |                    |    |                    |     | 5.8.2.27    |
   +--------------------+----+--------------------+-----+-------------+
   | quota_avail_hard   | 38 | uint64_t           | R   | Section     |
   |                    |    |                    |     | 5.8.2.28    |
   +--------------------+----+--------------------+-----+-------------+
   | quota_avail_soft   | 39 | uint64_t           | R   | Section     |
   |                    |    |                    |     | 5.8.2.29    |
   +--------------------+----+--------------------+-----+-------------+
   | quota_used         | 40 | uint64_t           | R   | Section     |
   |                    |    |                    |     | 5.8.2.30    |
   +--------------------+----+--------------------+-----+-------------+
   | rawdev             | 41 | specdata4          | R   | Section     |
   |                    |    |                    |     | 5.8.2.31    |
   +--------------------+----+--------------------+-----+-------------+
   | retentevt_get      | 71 | retention_get4     | R   | Section     |
   |                    |    |                    |     | 5.13.3      |
   +--------------------+----+--------------------+-----+-------------+
   | retentevt_set      | 72 | retention_set4     |   W | Section     |
   |                    |    |                    |     | 5.13.4      |
   +--------------------+----+--------------------+-----+-------------+
   | retention_get      | 69 | retention_get4     | R   | Section     |
   |                    |    |                    |     | 5.13.1      |
   +--------------------+----+--------------------+-----+-------------+
   | retention_hold     | 73 | uint64_t           | R W | Section     |
   |                    |    |                    |     | 5.13.5      |
   +--------------------+----+--------------------+-----+-------------+
   | retention_set      | 70 | retention_set4     |   W | Section     |
   |                    |    |                    |     | 5.13.2      |
   +--------------------+----+--------------------+-----+-------------+
   | sacl               | 59 | nfsacl41           | R W | Section     |
   |                    |    |                    |     | 6.2.3       |
   +--------------------+----+--------------------+-----+-------------+
   | space_avail        | 42 | uint64_t           | R   | Section     |
   |                    |    |                    |     | 5.8.2.32    |
   +--------------------+----+--------------------+-----+-------------+
   | space_free         | 43 | uint64_t           | R   | Section     |
   |                    |    |                    |     | 5.8.2.33    |
   +--------------------+----+--------------------+-----+-------------+
   | space_total        | 44 | uint64_t           | R   | Section     |
   |                    |    |                    |     | 5.8.2.34    |
   +--------------------+----+--------------------+-----+-------------+
   | space_used         | 45 | uint64_t           | R   | Section     |
   |                    |    |                    |     | 5.8.2.35    |
   +--------------------+----+--------------------+-----+-------------+
   | system             | 46 | bool               | R W | Section     |
   |                    |    |                    |     | 5.8.2.36    |
   +--------------------+----+--------------------+-----+-------------+
   | time_access        | 47 | nfstime4           | R   | Section     |
   |                    |    |                    |     | 5.8.2.37    |
   +--------------------+----+--------------------+-----+-------------+
   | time_access_set    | 48 | settime4           |   W | Section     |
   |                    |    |                    |     | 5.8.2.38    |
   +--------------------+----+--------------------+-----+-------------+
   | time_backup        | 49 | nfstime4           | R W | Section     |
   |                    |    |                    |     | 5.8.2.39    |
   +--------------------+----+--------------------+-----+-------------+
   | time_create        | 50 | nfstime4           | R W | Section     |
   |                    |    |                    |     | 5.8.2.40    |
   +--------------------+----+--------------------+-----+-------------+
   | time_delta         | 51 | nfstime4           | R   | Section     |
   |                    |    |                    |     | 5.8.2.41    |
   +--------------------+----+--------------------+-----+-------------+
   | time_metadata      | 52 | nfstime4           | R   | Section     |
   |                    |    |                    |     | 5.8.2.42    |
   +--------------------+----+--------------------+-----+-------------+
   | time_modify        | 53 | nfstime4           | R   | Section     |
   |                    |    |                    |     | 5.8.2.43    |
   +--------------------+----+--------------------+-----+-------------+
   | time_modify_set    | 54 | settime4           |   W | Section     |
   |                    |    |                    |     | 5.8.2.44    |
   +--------------------+----+--------------------+-----+-------------+

                                 Table 5
```

---
### **5.8.  Attribute Definitions**
---
#### **5.8.1.  Definitions of REQUIRED Attributes**
---
##### **5.8.1.1.  Attribute 0: supported_attrs**

이 객체에 대해 지원되는 모든 REQUIRED 및 RECOMMENDED 속성을 검색하는 비트 벡터입니다. 이 속성의 범위는 일치하는 fsid가 있는 모든 개체에 적용됩니다.\(MUST\)

---
##### **5.8.1.2.  Attribute 1: type**

여러 특수 상수 중 하나를 사용하여 객체의 유형을 지정합니다.

\* NF4REG는 일반 파일을 지정합니다.

\* NF4DIR은 디렉터리를 지정합니다.

\* NF4BLK는 블록 디바이스 특수 파일을 지정합니다.

\* NF4CHR은 캐릭터 디바이스 특수 파일을 지정합니다.

\* NF4LNK는 심볼릭 링크를 지정합니다.

\* NF4SOCK은 명명된 소켓 특수 파일을 지정합니다.

\* NF4FIFO는 fifo 특수 파일을 지정합니다.

\* NF4ATTRDIR은 명명된 속성 디렉터리를 지정합니다.

\* NF4NAMEDATTR은 명명된 속성을 지정합니다.

설명 텍스트 및 작동 설명 내에서 다음 문구는 아래 주어진 의미와 함께 사용됩니다.

\* "디렉토리입니다"라는 문구는 객체의 유형 속성이 NF4DIR 또는 NF4ATTRDIR임을 의미합니다.

\* "특수 파일입니다"라는 문구는 객체의 유형 속성이 NF4BLK, NF4CHR, NF4SOCK 또는 NF4FIFO임을 의미합니다.

\* "일반 파일입니다" 및 "일반 파일입니다"라는 문구는 개체의 유형 속성이 NF4REG 또는 NF4NAMEDATTR임을 의미합니다.

---
##### **5.8.1.3.  Attribute 2: fh_expire_type**

서버는 이를 사용하여 클라이언트에 파일 핸들 만료 동작을 지정합니다. 추가 설명은 섹션 4를 참조하세요.

---
##### **5.8.1.4.  Attribute 3: change**

클라이언트가 파일 데이터, 디렉터리 내용 또는 객체 속성이 수정되었는지 확인하는 데 사용할 수 있는 서버에서 생성된 값입니다. 서버는 이 속성 값에 대해 객체의 time\_metadata 속성을 반환할 수 있지만 파일 시스템 객체가 time\_metadata의 확인보다 더 자주 업데이트될 수 없는 경우에만 해당됩니다.

---
##### **5.8.1.5.  Attribute 4: size**

객체의 크기\(바이트\)입니다.

---
##### **5.8.1.6.  Attribute 5: link_support**

객체의 파일 시스템이 하드 링크를 지원하는 경우 TRUE입니다.

---
##### **5.8.1.7.  Attribute 6: symlink_support**

객체의 파일 시스템이 심볼릭 링크를 지원하는 경우 TRUE입니다.

---
##### **5.8.1.8.  Attribute 7: named_attr**

이 객체에 명명된 속성이 있는 경우 TRUE입니다. 즉, 개체에 비어 있지 않은 명명된 속성 디렉터리가 있습니다.

---
##### **5.8.1.9.  Attribute 8: fsid**

이 객체를 보유하는 파일 시스템의 고유한 파일 시스템 식별자입니다. fsid 속성에는 주요 구성 요소와 보조 구성 요소가 있으며 각 구성 요소의 데이터 유형은 uint64\_t입니다.

---
##### **5.8.1.10.  Attribute 9: unique_handles**

두 개의 서로 다른 파일 핸들이 두 개의 서로 다른 파일 시스템 개체를 참조하는 것이 보장되는 경우 TRUE입니다.

---
##### **5.8.1.11.  Attribute 10: lease_time**

서버 임대 기간\(초\)입니다.

---
##### **5.8.1.12.  Attribute 11: rdattr_error**

READDIR 작업 중 속성을 검색하려는 시도에서 오류가 반환되었습니다.

---
##### **5.8.1.13.  Attribute 19: filehandle**

이 객체의 파일 핸들입니다\(주로 READDIR 요청용\).

---
##### **5.8.1.14.  Attribute 75: suppattr_exclcreat**

OPEN 작업을 통한 파일 생성의 EXCLUSIVE4\_1 방법에서 지원되는 모든 REQUIRED 및 RECOMMENDED 속성을 설정하는 비트 벡터입니다. 이 속성의 범위는 일치하는 fsid가 있는 모든 개체에 적용됩니다.\(MUST\)

---
#### **5.8.2.  Definitions of Uncategorized RECOMMENDED Attributes**

RECOMMENDED 속성 대부분의 정의는 다음과 같습니다. 공통 카테고리를 공유하는 컬렉션은 다른 섹션에서 정의됩니다.\(SHOULD\)

---
##### **5.8.2.1.  Attribute 14: archive**

TRUE, 이 파일이 마지막 수정 이후 보관된 경우\(time\_backup을 위해 더 이상 사용되지 않음\)

---
##### **5.8.2.2.  Attribute 15: cansettime**

서버가 SETATTR 작업에 지정된 대로 파일 시스템 개체의 시간을 변경할 수 있는 경우 TRUE입니다.

---
##### **5.8.2.3.  Attribute 16: case_insensitive**

TRUE, 이 파일 시스템의 파일 이름 비교가 대소문자를 구분하지 않는 경우.

---
##### **5.8.2.4.  Attribute 17: case_preserving**

TRUE, 이 파일 시스템의 파일 이름 대소문자가 유지되는 경우.

---
##### **5.8.2.5.  Attribute 60: change_policy**

클라이언트가 현재 파일 시스템과 관련된 일부 서버 정책이 변경되었는지 확인하는 데 사용할 수 있는 서버에서 생성된 값입니다. 값이 동일하게 유지되면 클라이언트는 fs 위치와 관련된 속성 값과 fs\_status 속성의 fss\_type 필드가 변경되지 않았음을 확신할 수 있습니다. 반면, 이 값의 변경은 필연적으로 정책의 변경을 의미합니다. 서버와 관련된 일부 정책이 변경되었는지 확인하기 위해 서버를 조사하는 것은 클라이언트의 몫입니다. 자세한 내용은 섹션 3.3.6을 참조하세요.

이 속성은 fs\_locations 또는 fs\_locations\_info 속성에 의해 반환된 값이 변경될 때, 파일 시스템이 읽기 전용에서 쓰기 가능으로 또는 그 반대로 변경될 때, 또는 파일 시스템이나 그 일부에 허용되는 보안 특성 세트가 변경될 때 변경되어야 합니다.\(MUST\)

---
##### **5.8.2.6.  Attribute 18: chown_restricted**

TRUE인 경우 호출자가 권한 있는 사용자\(예: UNIX 운영 환경의 "루트" 또는 Windows 2000의 "소유권 가져오기"\)가 아닌 경우 서버는 소유자 또는 파일과 연관된 그룹을 변경하라는 요청을 거부합니다. " 특권\).

---
##### **5.8.2.7.  Attribute 20: fileid**

파일 시스템 내에서 파일을 고유하게 식별하는 번호입니다.

---
##### **5.8.2.8.  Attribute 21: files_avail**

이 객체를 포함하는 파일 시스템에서 이 사용자가 사용할 수 있는 파일 슬롯 - 관련 최소 한도여야 합니다.

---
##### **5.8.2.9.  Attribute 22: files_free**

이 객체를 포함하는 파일 시스템의 여유 파일 슬롯 - 관련 최소 한도여야 합니다.

---
##### **5.8.2.10.  Attribute 23: files_total**

이 객체를 포함하는 파일 시스템의 총 파일 슬롯입니다.

---
##### **5.8.2.11.  Attribute 76: fs_charset_cap**

이 파일 시스템에 대한 문자 세트 기능입니다. 섹션 14.4를 참조하십시오.

---
##### **5.8.2.12.  Attribute 24: fs_locations**

이 파일 시스템을 찾을 수 있는 위치입니다. 서버가 NFS4ERR\_MOVED를 오류로 반환하는 경우 이 속성을 지원해야 합니다. 자세한 내용은 섹션 11.16을 참조하세요.\(MUST\)

---
##### **5.8.2.13.  Attribute 67: fs_locations_info**

전체 기능 파일 시스템 위치. 자세한 내용은 섹션 11.17.2를 참조하세요.

---
##### **5.8.2.14.  Attribute 61: fs_status**

일반 파일 시스템 유형 정보입니다. 자세한 내용은 섹션 11.18을 참조하세요.

---
##### **5.8.2.15.  Attribute 25: hidden**

Windows API와 관련하여 파일이 숨겨진 것으로 간주되는 경우 TRUE입니다.

---
##### **5.8.2.16.  Attribute 26: homogeneous**

TRUE, 이 객체의 파일 시스템이 동종인 경우; 즉, 파일 시스템의 모든 객체\(동일한 fsid를 가진 서버의 모든 객체\)는 모든 파일 시스템별 속성에 대해 공통 값을 갖습니다.

---
##### **5.8.2.17.  Attribute 27: maxfilesize**

이 개체의 파일 시스템에 대해 지원되는 최대 파일 크기입니다.

---
##### **5.8.2.18.  Attribute 28: maxlink**

이 개체에 대한 최대 링크 수입니다.

---
##### **5.8.2.19.  Attribute 29: maxname**

이 개체에 지원되는 최대 파일 이름 크기입니다.

---
##### **5.8.2.20.  Attribute 30: maxread**

이 객체에 대해 READ 작업이 반환할 최대 데이터 양입니다.

---
##### **5.8.2.21.  Attribute 31: maxwrite**

WRITE 작업이 이 개체에 대해 허용할 최대 데이터 양입니다. 파일이 쓰기 가능한 경우 이 속성을 지원해야 합니다. 이 속성이 부족하면 클라이언트가 대역폭을 낭비하거나 최상의 성능을 얻지 못할 수 있습니다.\(SHOULD\)

---
##### **5.8.2.22.  Attribute 32: mimetype**

이 개체의 MIME 본문 유형/하위 유형입니다.

---
##### **5.8.2.23.  Attribute 55: mounted_on_fileid**

fileid와 비슷하지만 대상 파일 핸들이 파일 시스템의 루트인 경우 이 속성은 기본 디렉터리의 fileid를 나타냅니다.

UNIX 기반 운영 환경은 파일 시스템을 기존 파일 시스템의 기존 파일 개체\(마운트 지점, 일반적으로 디렉터리\)에 연결\(마운트\)하여 파일 시스템을 네임스페이스에 연결합니다. readdir\(\)과 같은 API를 통해 마운트 지점의 상위 디렉터리를 읽으면 반환 결과는 각각 구성 요소 이름과 파일 ID가 포함된 디렉터리 항목입니다. 마운트 지점 디렉토리 항목의 파일 ID는 stat\(\) 시스템 호출이 반환하는 파일 ID와 다릅니다. stat\(\) 시스템 호출은 마운트된 파일 시스템 루트의 파일 ID를 반환하는 반면, readdir\(\)은 파일 시스템이 마운트 지점에 마운트되기 전에 stat\(\)가 반환했을 파일 ID를 반환합니다.

NFSv3과 달리 NFSv4.1에서는 클라이언트의 LOOKUP 요청이 다른 파일 시스템을 통과할 수 있습니다. 클라이언트는 LOOKUP의 파일 핸들 인수에 LOOKUP이 반환한 파일 핸들의 fsid 속성과 다른 fsid 속성이 있을 때마다 파일 시스템 교차를 감지합니다. UNIX 기반 클라이언트는 이를 "마운트 지점 교차"로 간주합니다. UNIX에는 프로세스가 현재 작업 디렉토리를 결정할 수 있도록 하는 레거시 체계가 있습니다. 이는 앞서 설명한 대로 마운트 지점 상위의 readdir\(\)과 파일 ID를 반환하는 마운트 지점의 stat\(\)에 의존합니다. Mounted\_on\_fileid 속성은 앞에서 설명한 대로 readdir\(\)이 반환한 파일 ID에 해당합니다.

NFSv4.1 클라이언트는 Mounted\_on\_fileid가 제공하는 것과 일치하는 파일 ID를 간단하게 조작할 수 있지만\(서버가 Mounted\_on\_fileid를 지원하지 않는 경우 클라이언트는 선택의 여지가 없음\) 클라이언트가 다음과 충돌하는 파일 ID를 생성할 위험이 있습니다. 파일 시스템의 다른 개체에 이미 할당되었습니다. 대신, 서버가 Mounted\_on\_fileid를 제공할 수 있으면 이 영역에서 클라이언트 작동 문제가 발생할 가능성이 제거됩니다.

서버가 대상 파일 객체에 탑재 지점이 없음을 감지하면 반환되는 Mounted\_on\_fileid 값은 fileid 속성의 값과 동일합니다.

Mounted\_on\_fileid 속성은 RECOMMENDED이므로 서버는 가능하면 이를 제공해야 하며 UNIX 기반 서버의 경우 이는 간단합니다. 일반적으로 Mounted\_on\_fileid는 READDIR 작업 중에 요청되며, 이 경우에 mount\_on\_fileid가 readdir\(\)에 의해 반환된 디렉터리 항목의 fileid와 동일하기 때문에 이를 반환하는 것은 쉽지 않습니다\(적어도 UNIX 기반 서버의 경우\). GETATTR 작업에서 Mounted\_on\_fileid가 요청되면 서버는 개체의 부모 디렉터리에 있는 파일 개체 항목과 동일한 값, 즉 readdir\(\)이 반환한 값을 반환하는 불변성을 따라야 합니다. 일부 운영 환경에서는 두 개 이상의 일련의 파일 시스템을 단일 마운트 지점에 마운트할 수 있습니다. 이 경우 서버가 앞서 언급한 불변성을 따르려면 중간 마운트 지점이 아닌 기본 마운트 지점을 찾아야 합니다.\(SHOULD\)

---
##### **5.8.2.24.  Attribute 34: no_trunc**

이 속성이 TRUE인 경우 클라이언트가 name\_max보다 긴 파일 이름을 사용하면 이름이 잘리는 대신 오류가 반환됩니다.

---
##### **5.8.2.25.  Attribute 35: numlinks**

이 개체에 대한 하드 링크 수입니다.

---
##### **5.8.2.26.  Attribute 36: owner**

이 개체 소유자의 문자열 이름입니다.

---
##### **5.8.2.27.  Attribute 37: owner_group**

이 개체의 그룹 소유권에 대한 문자열 이름입니다.

---
##### **5.8.2.28.  Attribute 38: quota_avail_hard**

추가 할당이 거부되기 전에 이 파일이나 디렉터리에 할당할 수 있는 현재 할당을 초과하는 추가 디스크 공간의 양을 나타내는 값\(바이트\)입니다. 이 공간은 다른 파일이나 디렉터리에 대한 할당으로 인해 소모될 수 있는 것으로 이해됩니다.

---
##### **5.8.2.29.  Attribute 39: quota_avail_soft**

사용자에게 합리적으로 경고하기 전에 이 파일이나 디렉터리에 할당할 수 있는 추가 디스크 공간의 양을 나타내는 값\(바이트\)입니다. 다른 파일이나 디렉터리에 대한 규칙이 있지만 이 공간은 다른 파일이나 디렉터리에 할당하여 소비될 수 있는 것으로 이해됩니다.

---
##### **5.8.2.30.  Attribute 40: quota_used**

이 파일이나 디렉터리 및 기타 유사한 파일이나 디렉터리에서 사용하는 디스크 공간의 양을 나타내는 바이트 단위의 값입니다. 여기서 "유사" 집합은 최소한 다음의 모든 파일이나 디렉터리에 공간을 할당하는 기준을 충족합니다. set은 세트에 있는 다른 모든 파일이나 디렉터리의 "quota\_avail\_hard"를 줄입니다.

quota\_used 값이 유지되는 고유하지만 겹치는 파일 또는 디렉터리 집합이 여러 개 있을 수 있습니다\(예: "주어진 소유자가 있는 모든 파일", "주어진 그룹 소유자가 있는 모든 파일" 등\). 서버는 quota\_used 속성의 내용을 제공할 때 이러한 세트 중 하나를 자유롭게 선택할 수 있지만 반복 가능한 방식으로 수행해야 합니다. 규칙은 파일 시스템별로 구성되거나 "할당량이 가장 적은 집합을 선택"할 수 있습니다.

---
##### **5.8.2.31.  Attribute 41: rawdev**

NF4BLK 또는 NF4CHR 유형 파일의 원시 장치 번호입니다. 장치 번호는 메이저 번호와 마이너 번호로 구분됩니다. 파일의 유형 속성이 NF4BLK 또는 NF4CHR이 아닌 경우 반환된 값은 유용한 것으로 간주되어서는 안 됩니다.\(SHOULD NOT\)

---
##### **5.8.2.32.  Attribute 42: space_avail**

이 객체를 포함하는 파일 시스템에서 이 사용자가 사용할 수 있는 디스크 공간\(바이트\) - 관련 최소 한도여야 합니다.

---
##### **5.8.2.33.  Attribute 43: space_free**

이 개체를 포함하는 파일 시스템의 여유 디스크 공간\(바이트\) - 관련 최소 한도여야 합니다.

---
##### **5.8.2.34.  Attribute 44: space_total**

이 객체를 포함하는 파일 시스템의 총 디스크 공간\(바이트\)입니다.

---
##### **5.8.2.35.  Attribute 45: space_used**

이 객체에 할당된 파일 시스템 바이트 수입니다.

---
##### **5.8.2.36.  Attribute 46: system**

이 파일이 Windows 운영 환경과 관련하여 "시스템" 파일인 경우 이 속성은 TRUE입니다.

---
##### **5.8.2.37.  Attribute 47: time_access**

time\_access 속성은 서버에 전송된 READ 작업을 통해 객체에 마지막으로 액세스한 시간을 나타냅니다. "액세스"라는 개념은 서버의 운영 환경 및/또는 서버의 파일 시스템 의미에 따라 달라집니다. 예를 들어 POSIX\(Portable Operating System Interface\) 의미 체계를 따르는 서버의 경우 time\_access는 READ 및 READDIR 작업에 의해서만 업데이트되며 객체의 내용을 수정하는 작업에는 업데이트되지 않습니다\[13\], \[14\], \[15\] . 물론 해당 time\_access\_set 속성을 설정하는 것은 time\_access 속성을 수정하는 또 다른 방법입니다.

파일 객체가 쓰기 가능한 파일 시스템에 있을 때마다 서버는 time\_access를 안정적인 저장소에 기록하기 위해 최선을 다해야 합니다. 그러나 이렇게 하면 성능에 미치는 영향을 완화하기 위해, 특히 서버가 캐시에서 개체 콘텐츠 읽기를 만족할 때마다 서버는 액세스 시간 업데이트를 캐시하고 안정적인 저장소에 느리게 쓸 수 있습니다. 서버 관리자에게 time\_access 업데이트를 비활성화하는 옵션을 제공하는 것도 허용됩니다.\(MAY\)

---
##### **5.8.2.38.  Attribute 48: time_access_set**

개체에 대한 마지막 액세스 시간을 설정합니다. SETATTR만 사용하세요.

---
##### **5.8.2.39.  Attribute 49: time_backup**

개체의 마지막 백업 시간입니다.

---
##### **5.8.2.40.  Attribute 50: time_create**

객체가 생성된 시간입니다. 이 속성은 기존 UNIX 파일 속성 "ctime" 또는 "change time"과 아무런 관련이 없습니다.

---
##### **5.8.2.41.  Attribute 51: time_delta**

```text
   Smallest useful server time granularity.
```

---
##### **5.8.2.42.  Attribute 52: time_metadata**

객체의 마지막 메타데이터 수정 시간입니다.

---
##### **5.8.2.43.  Attribute 53: time_modify**

객체를 마지막으로 수정한 시간입니다.

---
##### **5.8.2.44.  Attribute 54: time_modify_set**

객체를 마지막으로 수정한 시간을 설정합니다. SETATTR만 사용하세요.

---
### **5.9.  Interpreting owner and owner_group**

RECOMMENDED 속성 "owner" 및 "owner\_group"\(또한 "acl" 속성 내의 사용자 및 그룹\)은 UTF-8 문자열로 표시됩니다. 클라이언트나 서버의 특정 기본 구현과 관련된 표현을 피하기 위해 UTF-8 문자열의 사용이 선택되었습니다. RFC 2624 \[53\]의 섹션 6.1은 추가적인 근거를 제공합니다. 클라이언트와 서버는 로컬 저장이나 최종 사용자에게 표시하는 데 사용되는 owner 및 owner\_group에 대한 고유한 로컬 표현을 갖게 될 것으로 예상됩니다. 따라서 이러한 특성이 클라이언트와 서버 간에 전송될 때 로컬 표현은 "user@dns\_domain" 형식의 구문으로 변환될 것으로 예상됩니다. 이렇게 하면 동일한 로컬 표현을 사용하지 않는 클라이언트와 서버가 둘 다 해석할 수 있는 공통 구문으로 변환할 수 있습니다.\(SHOULD\)

마찬가지로 보안 주체는 다양한 보안 메커니즘에 따라 다양한 방식으로 표현될 수 있습니다. 서버는 일반적으로 이러한 표현을 일반적으로 로컬 저장소에서 사용되는 공통 형식으로 변환하여 이러한 보안 주체에 해당하는 사용자를 식별하는 수단으로 사용됩니다. 이러한 로컬 식별자가 해당 보안 주체에 의해 생성된 파일과 연결된 소유자 특성의 형태로 변환되면 공통 형식으로 각 해당 보안 주체 집합과 연결된 사용자를 식별합니다.

소유자 및 그룹 문자열을 해석하는 데 사용되는 번역은 프로토콜의 일부로 지정되지 않습니다. 이를 통해 다양한 솔루션을 사용할 수 있습니다. 예를 들어 숫자 식별자를 user@dns\_domain 구문에 매핑하는 로컬 변환 테이블을 참조할 수 있습니다. 번역을 완료하기 위해 이름 서비스를 사용할 수도 있습니다. 서버는 소유자 및 owner\_group 속성을 번역 없이 로컬 저장소에 저장하여 특정 번역\(가능한 문자열의 제한된 집합만 번역\)에 제한되지 않고 보다 일반적인 서비스를 제공할 수 있습니다. 번역이 가능한 경우 로컬 표현을 사용하는 동안 번역이 불가능한 속성에 대한 전체 문자열입니다.

owner 및 owner\_group 속성의 가능한 모든 값에 대한 지원을 제공하지 않는 서버는 번역이 없는 문자열이 제시될 때 소유자, owner\_group 또는 acl의 SETATTR에 대해 설정되는 값으로 오류\(NFS4ERR\_BADOWNER\)를 반환해야 합니다. 속성. 서버가 owner 또는 owner\_group 값을 SETATTR에서 유효한 것으로 승인하면\(그리고 acl의 소유자 및 그룹 문자열에 대해서도 유사하게\) 해당 GETATTR이 완료되면 동일한 문자열을 반환할 것을 약속합니다. 구성 변경\(문자열을 로컬 표현으로 매핑하는 변경 포함\)과 잘못 구성된 이름 변환\(별칭 포함\)으로 인해 해당 약속을 이행하는 것이 불가능해질 수 있습니다. 서버는 소유권에 대한 실제 변경이 발생하지 않은 경우 이러한 속성의 값이 변경되는 상황을 피하기 위해 적절한 노력을 기울여야 합니다.\(SHOULD\)

소유자 문자열의 "dns\_domain" 부분은 DNS 도메인 이름을 의미합니다\(예: user@example.org\). 서버는 하나 이상의 도메인에 대해 유효한 사용자 집합을 허용해야 합니다. 서버는 다른 도메인을 유효한 번역이 없는 것으로 처리할 수 있습니다. 서버가 보안 제약에 따라 여러 도메인 또는 모든 도메인에 대한 사용자를 수락할 수 있는 경우 보다 일반적인 서비스가 제공됩니다.

클라이언트나 서버에서 사용할 수 있는 번역이 없는 경우 속성 값은 "@" 없이 구성됩니다. 따라서 owner 또는 owner\_group 속성에 @가 없으면 보낸 사람이 번역할 수 없으며 속성을 받는 사람이 해당 문자열을 자체 내부 형식으로 번역하기 위한 기초로 사용해서는 안 된다는 것을 의미합니다. 속성 값을 번역할 수 없더라도 여전히 유용할 수 있습니다. 클라이언트의 경우 속성 문자열은 소유권의 로컬 표시에 사용될 수 있습니다.

32비트 부호 없는 사용자 식별자와 그룹 식별자로 사용자와 그룹을 식별하는 NFSv3과의 호환성을 높이기 위해 앞에 0이 없는 10진수 값으로 구성된 소유자 및 그룹 문자열에 클라이언트와 서버가 특수하게 해석할 수 있습니다. 그러한 지원을 제공하기로 선택한 사람입니다. 수신자는 이러한 사용자 또는 그룹 문자열을 해당 숫자 값을 갖는 NFSv3 uid 또는 gid로 표시되는 것과 동일한 사용자를 나타내는 것으로 처리할 수 있습니다. 서버는 이러한 문자열을 받아들일 의무가 없지만 대신 NFS4ERR\_BADOWNER를 반환할 수 있습니다. 이 메커니즘이 사용자 및 그룹 변환을 파괴하는 데 사용되는 것을 방지하여 클라이언트가 모든 소유자 및 그룹을 숫자 형식으로 전달할 수 있도록 서버는 이 항목에 지정된 사용자 또는 소유자에 대한 유효한 변환이 있을 때 NFS4ERR\_BADOWNER 오류를 반환해야 합니다. 방법. 이 경우 클라이언트는 호환성을 위해 특수 형식이 아닌 적절한 name@domain 문자열을 사용해야 합니다.\(SHOULD\)

소유자 문자열 "nobody"는 익명 사용자를 지정하는 데 사용될 수 있으며, 이는 일반적인 방법을 통해 소유자 특성에 매핑될 수 없는 보안 주체에 의해 생성된 파일과 연결됩니다. NFSv4.1의 사용자 및 구현은 액세스가 익명이 아닌 실제 사용자를 지정하기 위해 "nobody"를 사용해서는 안 됩니다.\(SHOULD NOT\)

---
### **5.10.  Character Case Attributes**

Case\_insensitive 및 Case\_preserving 속성과 관련하여 각 UCS-4 문자\(UTF-8로 인코딩됨\)는 RFC 3454 \[16\]의 부록 B.2에 따라 매핑될 수 있습니다. 일반적인 문자 처리 및 국제화 문제에 대해서는 섹션 14를 참조하세요.

---
### **5.11.  Directory Notification Attributes**

섹션 18.39에 설명된 대로 클라이언트는 속성 변경 알림에 대한 최소 지연을 요청할 수 있지만 서버는 클라이언트가 요청하는 것을 자유롭게 무시할 수 있습니다. 클라이언트는 두 디렉터리 알림 속성 중 하나 또는 둘 다에 대해 GETATTR 작업을 보내 서버가 수락할 알림 지연을 미리 결정할 수 있습니다. 클라이언트가 GET\_DIR\_DELEGATION 작업을 호출하고 속성 변경 알림을 요청할 때 서버 제공 속성의 값보다 작지 않은 알림 지연을 요청해야 합니다.

---
#### **5.11.1.  Attribute 56: dir_notif_delay**

dir\_notif\_delay 속성은 클라이언트에 디렉토리 속성 변경을 알리기 전에 서버가 지연하는 최소 시간\(초\)입니다.

---
#### **5.11.2.  Attribute 57: dirent_notif_delay**

dirent\_notif\_delay 속성은 디렉토리에 항목이 있는 파일 객체에 대한 변경 사항을 클라이언트에 알리기 전에 서버가 지연하는 최소 시간\(초\)입니다.

---
### **5.12.  pNFS Attribute Definitions**
---
#### **5.12.1.  Attribute 62: fs_layout_type**

fs\_layout\_type 속성\(섹션 3.3.13 참조\)은 파일 시스템에 적용되며 파일 시스템에서 지원되는 레이아웃 유형을 나타냅니다. 클라이언트가 새 fsid를 발견하면 클라이언트는 새 파일 시스템과 관련된 fs\_layout\_type 속성 값을 얻어야 합니다. 이 속성은 클라이언트가 서버에서 지원하는 레이아웃 유형이 클라이언트에서 지원되는 레이아웃 유형과 일치하는지 확인하는 데 사용됩니다.\(SHOULD\)

---
#### **5.12.2.  Attribute 66: layout_alignment**

클라이언트가 파일 시스템의 파일에 대한 레이아웃을 보유하는 경우,layout\_alignment 속성은 해당 파일 시스템의 파일에 대한 I/O의 기본 정렬을 나타냅니다. 가능한 경우 클라이언트는 레이아웃\_정렬 속성의 정수배인 오프셋을 사용하여 읽기 및 쓰기 작업을 보내야 합니다.

---
#### **5.12.3.  Attribute 65: layout_blksize**

클라이언트가 파일 시스템의 파일에 대한 레이아웃을 보유하는 경우,layout\_blksize 속성은 해당 파일 시스템의 파일에 대한 I/O에 대한 기본 블록 크기를 나타냅니다. 가능한 경우 클라이언트는 count 인수가 count 인수로 된 READ 작업을 레이아웃\_blksize의 정수 배수인 데이터 인수로 보내야 하고, WRITE 작업의 데이터 인수가 레이아웃\_blksize의 정수 배수인 경우를 보내야 합니다.

---
#### **5.12.4.  Attribute 63: layout_hint**

layout\_hint 속성\(섹션 3.3.19 참조\)은 새로 생성된 파일에 설정되어 파일 레이아웃에 대한 메타데이터 서버의 선택에 영향을 줄 수 있습니다. 가능하다면 이 속성은 OPEN 작업 내의 초기 속성에 설정된 속성 중 하나입니다. 메타데이터 서버는 이 속성을 무시하도록 선택할 수 있습니다. 레이아웃\_힌트 속성은 LAYOUTGET에 의해 반환된 레이아웃 구조의 하위 집합입니다. 예를 들어 특정 장치를 지정하는 대신 파일의 스트라이프 너비를 제안하는 데 사용됩니다. 서버 구현에 따라 레이아웃 내의 어떤 필드가 사용될지 결정됩니다.

---
#### **5.12.5.  Attribute 64: layout_type**

이 속성은 파일에 사용할 수 있는 레이아웃 유형을 나열합니다. 서버에서 반환된 값은 정보 제공용으로만 사용됩니다. 클라이언트는 LAYOUTGET 작업을 사용하여 I/O를 수행하는 데 필요한 정보\(예: 파일 및 해당 레이아웃에 대한 특정 장치 정보\)를 얻습니다.

---
#### **5.12.6.  Attribute 68: mdsthreshold**

이 속성은 메타데이터 서버 또는 데이터 서버에 읽기 및 쓰기 작업을 보내는 것이 더 효율적인 경우 클라이언트와 통신하는 데 사용되는 서버 제공 힌트입니다. 설명된 두 가지 유형의 임계값은 파일 크기 임계값과 I/O 크기 임계값입니다. 파일 크기가 파일 크기 임계값보다 작은 경우 데이터 액세스는 메타데이터 서버로 전송되어야 합니다. I/O 요청의 길이가 I/O 크기 임계값보다 짧은 경우 I/O는 메타데이터 서버로 전송되어야 합니다. 각 임계값 유형은 읽기 및 쓰기에 대해 별도로 지정됩니다.\(SHOULD, SHOULD\)

서버는 파일에 대해 두 가지 유형의 임계값을 모두 제공할 수 있습니다. 파일 크기와 I/O 크기가 모두 제공된 경우 클라이언트는 읽기 또는 쓰기 요청을 데이터 서버에 보내기 전에 두 임계값에 모두 도달하거나 초과해야 합니다. 또는 지정된 임계값 중 하나만 도달하거나 초과하는 경우 I/O 요청이 메타데이터 서버로 전송됩니다.\(MAY, SHOULD\)

각 임계값 유형에 대해 0 값은 READ 또는 WRITE가 메타데이터 서버로 전송되지 않음을 나타내고, 값이 모두 1이면 모든 READ 또는 WRITE가 메타데이터 서버로 전송되어야 함을 나타냅니다.

이 속성은 파일 핸들별로 사용할 수 있습니다. 현재 파일 핸들이 pNFS가 아닌 파일이나 디렉터리를 참조하는 경우 메타데이터 서버는 파일 핸들의 파일 시스템을 나타내는 속성을 반환해야 합니다. 이 속성은 OPEN 작업의 일부로 쿼리되는 것이 좋습니다. 동적 시스템 변경으로 인해 클라이언트는 속성이 특정 기간 동안 일정하게 유지될 것이라고 가정해서는 안 됩니다. 따라서 주기적으로 새로 고쳐야 합니다.

---
### **5.13.  Retention Attributes**

보존은 파일 객체를 고정 또는 무한 기간 동안 변경 불가능, 삭제 불가능, 이름 변경 불가능 상태로 둘 수 있는 개념입니다. 일단 이 "보존" 상태가 되면 파일은 보존 기간에 도달할 때까지 해당 상태에서 벗어날 수 없습니다.

보존이 활성화되면 보존은 파일의 데이터와 파일 이름까지 확장되어야 합니다. 서버는 이 섹션에 명시된 예외를 제외하고 REQUIRED, RECOMMENDED 및 명명된 속성의 하위 집합을 포함하여 파일의 다른 속성으로 보존 기간을 확장할 수 있습니다.\(MUST, MUST\)

서버는 모든 파일 객체 유형에 대한 보존을 지원하거나 지원하지 않을 수 있습니다.\(MAY\)

5가지 보존 속성은 다음 하위 섹션에서 설명됩니다.

---
#### **5.13.1.  Attribute 69: retention_get**

연관된 파일에 대해 보존이 활성화된 경우 이 속성의 값은 파일 객체의 보존 시작 시간을 나타냅니다. 이 속성의 값은 GETATTR 작업을 통해서만 읽을 수 있으며 SETATTR 작업\(섹션 5.5\)에 의해 수정되어서는 안 됩니다. 속성 값은 다음으로 구성됩니다.\(MUST NOT\)

```text
   const RET4_DURATION_INFINITE    = 0xffffffffffffffff;
   struct retention_get4 {
           uint64_t        rg_duration;
           nfstime4        rg_begin_time<1>;
   };
```

rg\_duration 필드는 보존이 활성화된 후 파일이 보존되는 기간을 나타내는 기간\(초\)입니다. rg\_begin\_time 필드는 최대 하나의 절대 시간 값 배열입니다. 어레이의 길이가 0인 경우 시작 보존 시간이 설정되지 않았으며 보존이 활성화되지 않습니다. rg\_duration이 RET4\_DURATION\_INFINITE와 같으면 보존이 활성화되면 파일은 무한 기간 동안 보존됩니다.

rg\_duration이 0이 되자마자 rg\_begin\_time의 길이는 0이 되며, 다시 보존이 \(더 이상\) 활성화되지 않습니다.

---
#### **5.13.2.  Attribute 70: retention_set**

이 속성은 보존 기간을 설정하고 선택적으로 연관된 파일 객체에 대한 보존을 활성화하는 데 사용됩니다. 이 속성은 SETATTR 작업을 통해서만 수정할 수 있으며 GETATTR 작업\(섹션 5.5\)으로 검색해서는 안 됩니다. 이 속성은tention\_get에 해당합니다. 속성 값은 다음으로 구성됩니다.\(MUST NOT\)

```text
   struct retention_set4 {
           bool            rs_enable;
           uint64_t        rs_duration<1>;
   };
```

클라이언트가 rs\_enable을 TRUE로 설정하면 서버의 현재 시간 및 날짜부터 보존 시작 시간을 사용하여 파일 객체에 대한 보존이 활성화됩니다. rs\_duration 배열의 길이가 1인 경우 보존 기간도 제공될 수 있습니다. 기간은 보관 시작 시점부터 초 단위 시간으로, RET4\_DURATION\_INFINITE로 설정하면 파일이 영구 보관된다. 이 SETATTR 또는 이전 SETATTR에 기간이 지정되지 않고 보존이 활성화된 경우 기간은 기본적으로 0초로 설정됩니다. 서버는 ACE4\_WRITE\_RETENTION ACL 권한을 기반으로 보존 활성화 또는 보존 기간을 제한할 수 있습니다. 보존 활성화로 인해 이벤트 기반 보존 활성화 또는 보유\_hold 속성 수정이 방해되어서는 안 됩니다.\(MAY, MUST NOT\)

다음 규칙은tention\_set 및 retentevt\_set 속성 모두에 적용됩니다.

\* 보존이 활성화되지 않는 한 클라이언트는 기간을 줄이는 것이 허용됩니다.

\* 보존이 활성화된 경우에도 기간은 항상 같거나 더 높은 값으로 설정할 수 있습니다. 보존이 활성화되면 실제 기간\(retention\_get 또는 retentevt\_get 속성에 의해 반환됨, 섹션 5.13.1 또는 섹션 5.13.3 참조\)은 기간이 다음으로 설정되지 않는 한 지속적으로 0\(초당 1단위\)으로 카운트다운됩니다. RET4\_DURATION\_INFINITE. 따라서 클라이언트가 보존이 활성화된 파일의 기간을 정확하게 연장하는 것은 불가능합니다.

\* 보존이 활성화된 동안 보존을 비활성화하거나 보존 기간을 줄이려는 시도는 NFS4ERR\_INVAL 오류와 함께 실패해야 합니다.\(MUST\)

\* 주체가tention\_set을 변경하려고 시도하는 경우 또는

- retentevt\_set에는 ACE4\_WRITE\_RETENTION 권한이 없으므로 NFS4ERR\_ACCESS로 인해 시도가 실패해야 합니다.\(MUST\)

---
#### **5.13.3.  Attribute 71: retentevt_get**

이벤트 기반 보존 기간을 가져오고, 활성화된 경우 파일 객체의 이벤트 기반 보존 시작 시간을 가져옵니다. 이 속성은tention\_get과 유사하지만 이벤트 기반 보존을 나타냅니다. 이벤트 기반 보존을 트리거하는 이벤트는 NFSv4.1 사양에 의해 정의되지 않습니다.

---
#### **5.13.4.  Attribute 72: retentevt_set**

이벤트 기반 보존 기간을 설정하고 선택적으로 파일 객체에 대한 이벤트 기반 보존을 활성화합니다. 이 속성은 retentevt\_get에 해당하고 보유\_세트와 유사하지만 이벤트 기반 보존을 나타냅니다. 이벤트 기반 보존이 설정되면 비이벤트 기반 보존이 설정되고 비이벤트 기반 보존 기간에 도달한 경우에도 파일을 보존해야 합니다. 반대로, 비이벤트 기반 보존이 설정된 경우 이벤트 기반 보존이 설정되고 이벤트 기반 보존 기간에 도달한 경우에도 파일을 보존해야 합니다. 서버는 ACE4\_WRITE\_RETENTION ACL 권한을 기반으로 이벤트 기반 보존 활성화 또는 이벤트 기반 보존 기간을 제한할 수 있습니다. 이벤트 기반 보존 활성화는 비이벤트 기반 보존 활성화 또는 보유\_hold 속성 수정을 방해해서는 안 됩니다.\(MUST, MUST, MAY, MUST NOT\)

---
#### **5.13.5.  Attribute 73: retention_hold**

관리 보존 보류\(비트당 하나의 보류 위치\)를 가져오거나 설정합니다.

이 속성은 1\~64개의 관리 보류\(속성 비트당 하나의 보류\)를 허용합니다. tention\_hold가 0이 아닌 경우 활성화된 이벤트 또는 비이벤트 기반 보존 기간에 도달한 경우에도 파일을 삭제하거나 이름을 바꾸거나 수정해서는 안 됩니다. 서버는 ACE4\_WRITE\_RETENTION\_HOLD ACL 권한을 기반으로 Retention\_hold의 수정을 제한할 수 있습니다. 관리 보존을 활성화해도 이벤트 기반 또는 비이벤트 기반 보존을 활성화할 수 있습니다.\(MUST NOT, MAY\)

Retention\_hold를 변경하려는 주체에게 ACE4\_WRITE\_RETENTION\_HOLD 권한이 없는 경우 해당 시도는 NFS4ERR\_ACCESS로 인해 실패해야 합니다.\(MUST\)

---
## **6.  Access Control Attributes**

ACL\(액세스 제어 목록\)은 세분화된 액세스 제어를 지정하는 파일 속성입니다. 이 섹션에서는 "acl", "dacl", "sacl", "aclsupport", "mode" 및 "mode\_set\_masked" 파일 속성과 해당 상호 작용을 다룹니다. 파일 속성은 모든 파일 시스템 개체에 적용될 수 있습니다.

---
### **6.1.  Goals**

ACL과 모드는 권한 지정을 위한 두 가지 잘 확립된 모델을 나타냅니다. 이 섹션에서는 다음 목표를 달성하기 위한 요구 사항을 지정합니다.

\* 서버가 모드 속성을 지원하는 경우 모드 속성만 설정하고 검색하는 클라이언트에 합리적인 의미를 제공해야 합니다.

\* 서버가 ACL 속성을 지원하는 경우 해당 속성만 설정하고 검색하는 클라이언트에 합리적인 의미를 제공해야 합니다.

\* 모드 속성을 지원하는 서버에서 ACL 속성이 상속을 통해 또는 명시적으로 객체에 설정된 적이 없는 경우 동작은 전통적인 UNIX와 유사한 동작이어야 합니다.

\* 모드 속성을 지원하는 서버에서 ACL 속성이 이전에 명시적으로 또는 상속을 통해 객체에 설정된 경우:

- - 모드 속성만 설정하면 소유자, 소유자 그룹 및 기타에 대한 읽기, 쓰기 및 실행에 대한 기존 UNIX와 유사한 권한을 효과적으로 제어해야 합니다.

- - 모드 속성만 설정하면 합리적인 보안이 제공됩니다. 예를 들어, 000 모드를 설정하면 이전의 기존 ACL 또는 상속된 ACL에 관계없이 모든 보안 주체에 의한 OPEN4\_SHARE\_ACCESS\_READ 또는 OPEN4\_SHARE\_ACCESS\_WRITE에 대한 향후 OPEN 작업이 실패하도록 보장하기에 충분해야 합니다.

\* NFSv4.1은 모드 및 ACL 속성과 관련된 다양한 의미를 도입할 수 있지만 이전의 기존 구현을 무효화하지는 않습니다. 또한 이 섹션에서는 이전 구현 및 이에 대한 논의를 기반으로 설명을 제공합니다.

\* 모드와 acl 또는 dacl을 모두 지원하는 서버의 경우

- 속성, 서버는 두 속성을 서로 일관성 있게 유지해야 합니다. 모드 속성의 값\(섹션 6.2.4에 설명된 상위 3개 비트 제외\)은 전적으로 ACL 값에 의해 결정되어야 하므로 모드 사용은 모드 설정 이외의 다른 용도로 필요하지 않습니다. 세 개의 상위 비트. 정확한 요구 사항은 섹션 6.4.1을 참조하세요.

\* 객체에 모드 속성이 설정된 경우 새 모드와 충돌하지 않도록 ACL 속성을 수정해야 할 수도 있습니다. 이러한 경우 ACL은 최대한 많은 정보를 유지하는 것이 바람직합니다. 여기에는 상속, AUDIT 및 ALARM ACE, 새 모드와 충돌하지 않는 부여 및 거부된 권한에 대한 정보가 포함됩니다.

---
### **6.2.  File Attributes Discussion**
---
#### **6.2.1.  Attribute 12: acl**

NFSv4.1 ACL 속성에는 파일 시스템 객체와 연결된 ACE\(액세스 제어 항목\) 배열이 포함되어 있습니다. 클라이언트는 acl 속성을 설정하고 가져올 수 있지만 서버는 ACL을 사용하여 액세스 제어를 수행해야 합니다. 클라이언트는 OPEN 또는 ACCESS 작업을 사용하여 데이터나 메타데이터를 수정하거나 읽지 않고도 액세스를 확인할 수 있습니다.

NFS ACE 구조는 다음과 같이 정의됩니다.

```text
   typedef uint32_t        acetype4;

   typedef uint32_t aceflag4;

   typedef uint32_t        acemask4;

   struct nfsace4 {
           acetype4        type;
           aceflag4        flag;
           acemask4        access_mask;
           utf8str_mixed   who;
   };
```

요청이 성공했는지 확인하기 위해 서버는 각 nfsace4 항목을 순서대로 처리합니다. 요청자와 일치하는 "누구"가 있는 ACE만 고려됩니다. 각 ACE는 요청자의 액세스 비트가 모두 허용될 때까지 처리됩니다. ACCESS\_ALLOWED\_ACE에 의해 비트\(아래 참조\)가 허용되면 이후 ACE 처리에서 더 이상 고려되지 않습니다. 요청자의 액세스에 ACE의 "access\_mask"와 공통된 허용되지 않은 비트가 여전히 있는 ACCESS\_DENIED\_ACE가 발생하면 요청이 거부됩니다. ACL이 완전히 처리되었을 때 요청자의 마스크에 허용되거나 거부되지 않은 비트가 있으면 액세스가 거부됩니다.

ALLOW 및 DENY ACE 유형과 달리 ALARM 및 AUDIT ACE 유형은 요청자의 액세스에 영향을 주지 않으며 대신 요청자의 액세스 시도의 결과로 이벤트를 트리거하는 데 사용됩니다. 따라서 AUDIT 및 ALARM ACE는 ALLOW 및 DENY ACE를 처리한 후에만 처리됩니다.

NFSv4.1 ACL 모델은 매우 풍부합니다. 일부 서버 플랫폼은 UNIX 스타일 모드 속성을 넘어서는 액세스 제어 기능을 제공할 수 있지만 NFS ACL 모델만큼 풍부하지는 않습니다. 사용자가 이 보다 제한된 기능을 활용할 수 있도록 서버는 ACL 모델과 NFSv4.1 ACL 모델 간의 매핑을 통해 acl 속성을 지원할 수 있습니다. 서버는 실제로 저장하거나 적용하는 ACL이 최소한 설정된 NFSv4 ACL만큼 엄격한지 확인해야 합니다. 정확하게 표현될 수 있는 작은 집합을 벗어나는 ACL을 거부하여 이를 달성하려는 유혹이 있습니다. 그러나 이러한 접근 방식은 서버 매핑에 대한 특별한 클라이언트 측 지식 없이는 ACL을 사용할 수 없게 만들 수 있으며, 이로 인해 공통 NFSv4 ACL 프로토콜을 사용하는 목적이 무산됩니다. 따라서 서버는 보안을 손상시키지 않으면서 가능한 모든 ACL을 수락해야 합니다. 이를 달성하기 위해 서버는 지원되지 않는 권한 비트의 경우 ACL에 의해 허용되거나 거부되지 않은 비트를 거부해야 한다는 규칙에 대해 특별한 예외를 만들 수 있습니다. 예를 들어 UNIX 스타일 서버는 ACL이 해당 권한을 명시적으로 허용하지 않더라도 속성 읽기 권한을 자동으로 허용하도록 선택할 수 있습니다. \(속성을 읽을 수 있는 권한을 명시적으로 거부하는 ACL은 여전히 ​​거부되어야 합니다.\)

서버에 ACL을 적용하는 여러 모듈이 있을 수 있다는 사실로 인해 상황이 복잡해집니다. 예를 들어, NFSv4.1 액세스에 대한 적용은 로컬 액세스에 대한 적용과 다를 수 있지만 그보다 약하지는 않으며, 둘 다 SMB\(서버 메시지 블록\)와 같은 다른 프로토콜을 통한 액세스에 대한 적용과 다를 수 있습니다. 따라서 모든 모듈이 ACL을 지원할 수 없더라도 서버가 ACL을 수락하는 것이 유용할 수 있습니다.

NFSv4 액세스와 관련된 기본 원칙은 파일에 대한 액세스를 실제보다 더 제한적으로 만드는 것처럼 보이는 ACL을 서버가 허용해서는 안 된다는 것입니다.

---
##### **6.2.1.1.  ACE Type**

유형 필드\(acetype4\)에 사용되는 상수는 다음과 같습니다.

```text
   const ACE4_ACCESS_ALLOWED_ACE_TYPE      = 0x00000000;
   const ACE4_ACCESS_DENIED_ACE_TYPE       = 0x00000001;
   const ACE4_SYSTEM_AUDIT_ACE_TYPE        = 0x00000002;
   const ACE4_SYSTEM_ALARM_ACE_TYPE        = 0x00000003;
```

dacl 속성에는 ALLOWED 및 DENIED 비트만 사용할 수 있고 sacl 속성에는 AUDIT 및 ALARM 비트만 사용할 수 있습니다. 네 가지 모두 acl 속성에 허용됩니다.

```text
   +==============================+==============+=====================+
   | Value                        | Abbreviation | Description         |
   +==============================+==============+=====================+
   | ACE4_ACCESS_ALLOWED_ACE_TYPE | ALLOW        | Explicitly grants   |
   |                              |              | the access          |
   |                              |              | defined in          |
   |                              |              | acemask4 to the     |
   |                              |              | file or             |
   |                              |              | directory.          |
   +------------------------------+--------------+---------------------+
   | ACE4_ACCESS_DENIED_ACE_TYPE  | DENY         | Explicitly denies   |
   |                              |              | the access          |
   |                              |              | defined in          |
   |                              |              | acemask4 to the     |
   |                              |              | file or             |
   |                              |              | directory.          |
   +------------------------------+--------------+---------------------+
   | ACE4_SYSTEM_AUDIT_ACE_TYPE   | AUDIT        | Log (in a system-   |
   |                              |              | dependent way)      |
   |                              |              | any access          |
   |                              |              | attempt to a file   |
   |                              |              | or directory that   |
   |                              |              | uses any of the     |
   |                              |              | access methods      |
   |                              |              | specified in        |
   |                              |              | acemask4.           |
   +------------------------------+--------------+---------------------+
   | ACE4_SYSTEM_ALARM_ACE_TYPE   | ALARM        | Generate an alarm   |
   |                              |              | (in a system-       |
   |                              |              | dependent way)      |
   |                              |              | when any access     |
   |                              |              | attempt is made     |
   |                              |              | to a file or        |
   |                              |              | directory for the   |
   |                              |              | access methods      |
   |                              |              | specified in        |
   |                              |              | acemask4.           |
   +------------------------------+--------------+---------------------+

                                  Table 6
```

"약어" 열은 이 섹션의 나머지 부분에서 유형이 참조되는 방식을 나타냅니다.

---
##### **6.2.1.2.  Attribute 13: aclsupport**

서버는 위의 ACE 유형을 모두 지원할 필요는 없습니다. 이 속성은 현재 파일 시스템에 지원되는 ACE 유형을 나타냅니다. aclsupport 속성 내에서 위 정의를 나타내는 데 사용되는 비트마스크 상수는 다음과 같습니다.

```text
   const ACL4_SUPPORT_ALLOW_ACL    = 0x00000001;
   const ACL4_SUPPORT_DENY_ACL     = 0x00000002;
   const ACL4_SUPPORT_AUDIT_ACL    = 0x00000004;
   const ACL4_SUPPORT_ALARM_ACL    = 0x00000008;
```

ALLOW 또는 DENY ACE 유형을 지원하는 서버는 ALLOW 및 DENY ACE 유형을 모두 지원해야 합니다.\(SHOULD\)

서버가 해당 ACE 유형에 대한 지원을 요청하지 않는 한 클라이언트는 ACE 설정을 시도해서는 안 됩니다. 서버가 저장할 수 없는 ACE를 설정하라는 요청을 받으면 NFS4ERR\_ATTRNOTSUPP를 사용하여 요청을 거부해야 합니다. 서버가 저장할 수는 있지만 시행할 수 없는 ACE를 설정하라는 요청을 수신하는 경우 서버는 NFS4ERR\_ATTRNOTSUPP를 사용하여 요청을 거부해야 합니다.\(MUST, SHOULD\)

ACL 속성에 대한 지원은 선택 사항입니다\(권장됨\). 그러나 새로운 ACL 속성\(dacl 또는 sacl\) 중 하나를 지원하는 서버는 지원하는 모든 ACE 유형에 액세스하기 위해 새로운 ACL 속성의 사용을 허용해야 합니다. 즉, 해당 서버가 ALLOW 또는 DENY ACE를 지원하는 경우 dacl 속성을 지원해야 하며, AUDIT 또는 ALARM ACE를 지원하는 경우 sacl 속성을 지원해야 합니다.\(SHOULD, MUST, MUST\)

---
##### **6.2.1.3.  ACE Access Mask**

액세스 마스크 필드에 사용되는 비트마스크 상수는 다음과 같습니다.

```text
   const ACE4_READ_DATA            = 0x00000001;
   const ACE4_LIST_DIRECTORY       = 0x00000001;
   const ACE4_WRITE_DATA           = 0x00000002;
   const ACE4_ADD_FILE             = 0x00000002;
   const ACE4_APPEND_DATA          = 0x00000004;
   const ACE4_ADD_SUBDIRECTORY     = 0x00000004;
   const ACE4_READ_NAMED_ATTRS     = 0x00000008;
   const ACE4_WRITE_NAMED_ATTRS    = 0x00000010;
   const ACE4_EXECUTE              = 0x00000020;
   const ACE4_DELETE_CHILD         = 0x00000040;
   const ACE4_READ_ATTRIBUTES      = 0x00000080;
   const ACE4_WRITE_ATTRIBUTES     = 0x00000100;
   const ACE4_WRITE_RETENTION      = 0x00000200;
   const ACE4_WRITE_RETENTION_HOLD = 0x00000400;

   const ACE4_DELETE               = 0x00010000;
   const ACE4_READ_ACL             = 0x00020000;
   const ACE4_WRITE_ACL            = 0x00040000;
   const ACE4_WRITE_OWNER          = 0x00080000;
   const ACE4_SYNCHRONIZE          = 0x00100000;
```

일부 마스크에는 일치하는 값이 있습니다\(예: ACE4\_READ\_DATA 및 ACE4\_LIST\_DIRECTORY\). 마스크 항목 ACE4\_LIST\_DIRECTORY, ACE4\_ADD\_FILE 및 ACE4\_ADD\_SUBDIRECTORY는 디렉터리 개체에 사용하기 위한 반면, ACE4\_READ\_DATA, ACE4\_WRITE\_DATA 및 ACE4\_APPEND\_DATA는 디렉터리가 아닌 개체에 사용하기 위한 것입니다.

---
###### **6.2.1.3.1.  Discussion of Mask Attributes**

```text
   ACE4_READ_DATA

      Operation(s) affected:
         READ

         OPEN
```

논의:

- 파일의 데이터를 읽기 위한 권한입니다.

- 서버는 ACE4\_EXECUTE 액세스 마스크 비트만 허용되는 경우 사용자가 파일의 데이터를 읽을 수 있는 기능을 허용해야 합니다.\(SHOULD\)

```text
   ACE4_LIST_DIRECTORY

      Operation(s) affected:
         READDIR
```

논의:

- 디렉토리의 내용을 나열할 수 있는 권한입니다.

```text
   ACE4_WRITE_DATA

      Operation(s) affected:
         WRITE

         OPEN
```

- SETATTR 크기

논의:

- 파일의 데이터를 수정하기 위한 권한입니다.

```text
   ACE4_ADD_FILE

      Operation(s) affected:
         CREATE

         LINK

         OPEN

         RENAME
```

논의:

- 디렉토리에 새 파일을 추가하기 위한 권한입니다. nfs\_ftype4가 NF4LNK, NF4BLK, NF4CHR, NF4SOCK 또는 NF4FIFO인 경우 CREATE 작업이 영향을 받습니다. \(NF4DIR은 ACE4\_ADD\_SUBDIRECTORY에 포함되어 나열되지 않습니다.\) OPEN은 일반 파일을 생성하는 데 사용될 때 영향을 받습니다. LINK 및 RENAME은 항상 영향을 받습니다.

```text
   ACE4_APPEND_DATA

      Operation(s) affected:
         WRITE

         OPEN
```

- SETATTR 크기

논의:

- 파일의 데이터를 수정하는 기능이 있지만 EOF에서만 시작됩니다. 이는 동일한 사용자 또는 그룹에 대해 ACE4\_APPEND\_DATA를 허용하고 ACE4\_WRITE\_DATA를 거부함으로써 추가 전용 파일 개념을 허용합니다. 파일에 위에서 설명한 것과 같은 ACL이 있고 EOF가 아닌 다른 위치에 대해 WRITE 요청이 이루어진 경우 서버는 NFS4ERR\_ACCESS를 반환해야 합니다.\(SHOULD\)

```text
   ACE4_ADD_SUBDIRECTORY

      Operation(s) affected:
         CREATE

         RENAME
```

논의:

- 디렉토리 내에 하위 디렉토리를 생성하기 위한 권한입니다. nfs\_ftype4가 NF4DIR인 경우 CREATE 작업이 영향을 받습니다. RENAME 작업은 항상 영향을 받습니다.

```text
   ACE4_READ_NAMED_ATTRS

      Operation(s) affected:
         OPENATTR
```

논의:

- 파일의 명명된 속성을 읽거나 명명된 속성 디렉터리를 조회하기 위한 권한입니다. OPENATTR은 명명된 속성 디렉터리를 생성하는 데 사용되지 않을 때 영향을 받습니다. 이는 1\)creater가 TRUE이지만 명명된 속성 디렉터리가 이미 존재하거나 2\)creater가 FALSE인 경우입니다.

```text
   ACE4_WRITE_NAMED_ATTRS

      Operation(s) affected:
         OPENATTR
```

논의:

- 파일의 명명된 속성을 쓰거나 명명된 속성 디렉터리를 생성할 수 있는 권한입니다. OPENATTR은 명명된 특성 디렉터리를 만드는 데 사용될 때 영향을 받습니다. 이것은creater이 TRUE이고 명명된 속성 디렉터리가 존재하지 않는 경우입니다. 명명된 속성 디렉터리가 존재하는지 여부를 확인하는 능력은 그것을 찾는 능력에 달려 있습니다. 따라서 사용자는 명명된 특성 디렉터리를 생성하려면 ACE4\_READ\_NAMED\_ATTRS 권한도 필요합니다.

```text
   ACE4_EXECUTE

      Operation(s) affected:
         READ

         OPEN

         REMOVE

         RENAME

         LINK

         CREATE
```

논의:

- 파일을 실행하기 위한 권한입니다.

- 서버는 ACE4\_EXECUTE 액세스 마스크 비트만 허용되는 경우 사용자가 파일의 데이터를 읽을 수 있는 기능을 허용해야 합니다. 내용을 읽지 않고서는 파일을 실행할 수 있는 방법이 없기 때문이다. 서버가 READ 작업을 허용하기로 결정할 때 ACE4\_EXECUTE 및 ACE4\_READ\_DATA 비트를 동일하게 처리할 수 있더라도 ACL에서 두 비트가 독립적으로 설정되도록 허용해야 하며 ACCESS 작업에 응답할 때 두 비트를 구별해야 합니다\(MUST\). 특히, 서버는 다른 비트가 설정될 때 두 비트 중 하나를 자동으로 켜서는 안 됩니다. 그렇게 하면 클라이언트가 읽기 권한과 실행 권한 간의 구별을 올바르게 시행하는 것이 불가능해지기 때문입니다.\(SHOULD, MUST, SHOULD NOT\)

- 예를 들어 다음 ACL의 SETATTR을 따릅니다.

```text
            nfsuser:ACE4_EXECUTE:ALLOW
```

- 해당 파일에 대한 ACL의 후속 GETATTR은 다음을 반환해야 합니다.\(SHOULD\)

```text
            nfsuser:ACE4_EXECUTE:ALLOW

         Rather than:

            nfsuser:ACE4_EXECUTE/ACE4_READ_DATA:ALLOW

   ACE4_EXECUTE

      Operation(s) affected:
         LOOKUP
```

논의:

- 디렉토리를 탐색/탐색하기 위한 권한입니다.

```text
   ACE4_DELETE_CHILD

      Operation(s) affected:
         REMOVE

         RENAME
```

논의:

- 디렉토리 내의 파일이나 디렉토리를 삭제하기 위한 권한입니다. ACE4\_DELETE 및 ACE4\_DELETE\_CHILD 상호 작용에 대한 자세한 내용은 섹션 6.2.1.3.2를 참조하세요.

```text
   ACE4_READ_ATTRIBUTES
```

영향을 받는 작업:

- 파일 시스템 객체 속성의 GETATTR

```text
         VERIFY

         NVERIFY

         READDIR
```

논의:

- 파일의 기본 속성\(비ACL\)을 읽는 기능. UNIX 시스템에서 기본 속성은 상태 수준 속성으로 간주될 수 있습니다. 이 액세스 마스크 비트를 허용하면 엔터티가 "ls -l" 및 stat를 실행할 수 있음을 의미합니다. READDIR 작업이 속성을 요청하는 경우 READDIR이 성공하려면 이 마스크를 허용해야 합니다.

```text
   ACE4_WRITE_ATTRIBUTES
```

영향을 받는 작업:

- time\_access\_set, time\_backup의 SETATTR,

```text
         time_create, time_modify_set, mimetype, hidden, system
```

논의:

- 파일이나 디렉터리와 관련된 시간을 임의의 값으로 변경하는 권한입니다. 또한 mimetype, 숨김 및 시스템 속성을 변경할 수 있는 권한입니다. ACE4\_WRITE\_DATA 또는 ACE4\_WRITE\_ATTRIBUTES가 있는 사용자는 파일과 관련된 시간을 현재 서버 시간으로 설정할 수 있습니다.

```text
   ACE4_WRITE_RETENTION
```

영향을 받는 작업:

- 보유\_세트의 SETATTR, retentevt\_set.

논의:

- 이벤트 및 비이벤트 기반 보존 기간을 수정하는 권한입니다. 또한 이벤트 및 비이벤트 기반 보존을 활성화할 수 있는 권한입니다. 서버는 ACE4\_WRITE\_ATTRIBUTES 설정이 ACE4\_WRITE\_RETENTION을 허용하도록 동작할 수 있습니다.\(MAY\)

```text
   ACE4_WRITE_RETENTION_HOLD
```

영향을 받는 작업:

- 보유\_보류의 SETATTR입니다.

논의:

- 관리 보존 보류를 수정할 수 있는 권한입니다. 서버는 ACE4\_WRITE\_ATTRIBUTES를 ACE\_WRITE\_RETENTION\_HOLD에 매핑할 수 있습니다.\(MAY\)

```text
   ACE4_DELETE

      Operation(s) affected:
         REMOVE
```

논의:

- 파일이나 디렉터리를 삭제하기 위한 권한입니다. ACE4\_DELETE 및 ACE4\_DELETE\_CHILD 상호 작용에 대한 자세한 내용은 섹션 6.2.1.3.2를 참조하세요.

```text
   ACE4_READ_ACL
```

영향을 받는 작업:

- acl, dacl 또는 sacl의 GETATTR

```text
         NVERIFY

         VERIFY
```

논의:

- ACL을 읽을 수 있는 권한입니다.

```text
   ACE4_WRITE_ACL
```

영향을 받는 작업:

- acl 및 모드의 SETATTR

논의:

- acl 및 mode 속성을 쓰기 위한 권한입니다.

```text
   ACE4_WRITE_OWNER
```

영향을 받는 작업:

- 소유자 및 owner\_group의 SETATTR

논의:

- 소유자, 소유자\_그룹 속성을 쓰기 위한 권한입니다. UNIX 시스템에서는 chown\(\) 및 chgrp\(\)를 실행하는 기능입니다.

```text
   ACE4_SYNCHRONIZE

      Operation(s) affected:
         NONE
```

논의:

- 파일 객체를 프로세스 간 통신을 위한 동기화 프리미티브로 사용하기 위한 권한입니다. 이 권한은 클라이언트를 대신하여 NFSv4.1 서버에 의해 적용되거나 해석되지 않습니다.

- 일반적으로 ACE4\_SYNCHRONIZE 권한은 로컬 파일 시스템, 즉 NFSv4.1을 통해 액세스되지 않는 파일 시스템에서만 의미가 있습니다. 권한 비트가 존재하는 이유는 Windows와 같은 일부 운영 환경에서는 ACE4\_SYNCHRONIZE를 사용하기 때문입니다.

예를 들어, 클라이언트가 다음과 같은 파일을 복사하는 경우

- ACE4\_SYNCHRONIZE는 로컬 파일 시스템에서 NFSv4.1 서버로 설정되고 나중에 NFSv4.1 서버의 파일을 로컬 파일 시스템으로 복사합니다. ACE4\_SYNCHRONIZE가 원본 파일에 설정된 경우 클라이언트는 두 번째 사본에 설정되었습니다. NFSv4.1 서버에 ACE4\_SYNCHRONIZE 비트를 설정할 수 있는 수단이 없으면 첫 번째 복사본에는 권한 집합이 없습니다. NFSv4.1 서버에 ACE4\_SYNCHRONIZE 비트를 검색할 수 있는 수단이 없으면 두 번째 복사본에는 권한 집합이 없습니다.

서버 구현에서는 이 마스크 목록이 암시하는 제어 세분성을 제공할 필요가 없습니다. 예를 들어 POSIX 기반 시스템은 ACE4\_APPEND\_DATA\(파일에 추가하는 기능\)와 ACE4\_WRITE\_DATA\(기존 콘텐츠를 수정하는 기능\)를 구별하지 못할 수 있습니다. 두 마스크 모두 단일 "쓰기" 권한에 연결됩니다\[17\]. 이러한 서버가 클라이언트에 속성을 반환하면 쓰기 권한이 활성화된 경우에만 ACE4\_APPEND\_DATA 및 ACE4\_WRITE\_DATA가 모두 표시됩니다.

서버가 정확하게 구현할 수 없는 SETATTR 요청을 수신하면 이전에 설명한 실행 및 읽기 사례를 제외하고 액세스가 더 제한된 방향으로 오류가 발생해야 합니다. 예를 들어, 이전 단락에서 설명한 대로 서버가 데이터 덮어쓰기와 새 데이터 추가를 구별할 수 없다고 가정합니다. 클라이언트가 ACE4\_APPEND\_DATA가 설정되어 있지만 ACE4\_WRITE\_DATA가 설정되지 않은 ALLOW ACE를 제출하는 경우\(또는 그 반대\) 서버는 ACE4\_APPEND\_DATA를 끄거나 NFS4ERR\_ATTRNOTSUPP를 사용하여 요청을 거부해야 합니다.

---
###### **6.2.1.3.2.  ACE4_DELETE vs. ACE4_DELETE_CHILD**

두 개의 액세스 마스크 비트가 디렉터리 항목 삭제 기능을 제어합니다. 개체 자체\("대상"\)의 ACE4\_DELETE와 포함 디렉터리\("상위"\)의 ACE4\_DELETE\_CHILD입니다.

많은 시스템은 또한 대상 또는 상위를 소유한 사용자에 대해서만 연결 해제를 허용하기 위해 디렉터리에서 "고정 비트"\(MODE4\_SVTX\)를 사용합니다. 일부 시스템에서는 대상이 쓰기 가능한지 여부에 따라 결정이 달라집니다.

서버는 대상에서 ACE4\_DELETE가 허용되거나 상위에서 ACE4\_DELETE\_CHILD가 허용되는 경우 연결 해제를 허용해야 합니다. \(상위 또는 대상이 이러한 권한 중 하나를 명시적으로 거부하는 경우에도 마찬가지입니다.\)\(SHOULD\)

문제의 ACL이 위 항목 중 하나를 명시적으로 허용하거나 거부하지 않고 MODE4\_SVTX가 상위 항목에 설정되지 않은 경우 서버는 ACE4\_ADD\_FILE이 허용되는 경우에만 제거를 허용해야 합니다. MODE4\_SVTX가 설정된 경우 서버는 제거 프로그램이 상위 또는 대상을 소유하도록 요구하거나 대상이 쓰기 가능하도록 요구할 수도 있습니다.\(SHOULD\)

이를 통해 서버는 ACE4\_ADD\_FILE이 쓰기 비트를 대신하여 전통적인 UNIX와 유사한 의미론에 가까운 것을 지원할 수 있습니다.

---
##### **6.2.1.4.  ACE flag**

플래그 필드에 사용되는 비트마스크 상수는 다음과 같습니다.

```text
   const ACE4_FILE_INHERIT_ACE             = 0x00000001;
   const ACE4_DIRECTORY_INHERIT_ACE        = 0x00000002;
   const ACE4_NO_PROPAGATE_INHERIT_ACE     = 0x00000004;
   const ACE4_INHERIT_ONLY_ACE             = 0x00000008;
   const ACE4_SUCCESSFUL_ACCESS_ACE_FLAG   = 0x00000010;
   const ACE4_FAILED_ACCESS_ACE_FLAG       = 0x00000020;
   const ACE4_IDENTIFIER_GROUP             = 0x00000040;
   const ACE4_INHERITED_ACE                = 0x00000080;
```

서버는 이러한 플래그를 지원할 필요가 없습니다. 서버가 이러한 플래그와 유사하지만 정확히 동일하지는 않은 플래그를 지원하는 경우 구현에서는 프로토콜 정의 플래그와 구현 정의 플래그 간의 매핑을 정의할 수 있습니다.

예를 들어, 클라이언트가 ACE4\_FILE\_INHERIT\_ACE가 설정된 ACE를 설정하려고 하지만 ACE4\_DIRECTORY\_INHERIT\_ACE는 설정하지 않는다고 가정해 보겠습니다. 서버가 어떤 형태의 ACL 상속도 지원하지 않는 경우 서버는 NFS4ERR\_ATTRNOTSUPP를 사용하여 요청을 거부해야 합니다. 서버가 파일과 디렉터리 모두에 적용되는 단일 "ACE 상속" 플래그를 지원하는 경우 서버는 요청을 거부할 수 있습니다\(즉, 클라이언트가 파일 및 디렉터리 상속 플래그를 모두 설정하도록 요구함\). 서버는 요청을 수락하고 ACE4\_DIRECTORY\_INHERIT\_ACE 플래그를 자동으로 켤 수도 있습니다.

---
###### **6.2.1.4.1.  Discussion of Flag Bits**

ACE4\_FILE\_INHERIT\_ACE

- 하위 디렉터리에 있는 디렉터리가 아닌 모든 파일은 이 ACE를 상속받습니다.

ACE4\_DIRECTORY\_INHERIT\_ACE

- 디렉터리에 배치할 수 있으며 생성된 각 새 디렉터리에 이 ACE를 추가해야 함을 나타냅니다.

- 이 플래그가 디렉토리가 아닌 파일 시스템 객체에 설정될 ACL 속성의 ACE에 설정된 경우 ACL을 설정하려는 작업은 NFS4ERR\_ATTRNOTSUPP와 함께 실패해야 합니다.\(SHOULD\)

ACE4\_NO\_PROPAGATE\_INHERIT\_ACE

- 디렉토리에 배치할 수 있습니다. 이 플래그는 이 ACE의 상속이 새로 생성된 하위 디렉터리에서 중지되어야 함을 서버에 알립니다.

ACE4\_INHERIT\_ONLY\_ACE

- 디렉토리에 배치할 수 있지만 디렉토리에 적용되지는 않습니다. 이 비트가 설정된 ALLOW 및 DENY ACE는 디렉터리에 대한 액세스에 영향을 주지 않으며, 이 비트가 설정된 AUDIT 및 ALARM ACE는 로그 또는 경보 이벤트를 트리거하지 않습니다. 이러한 ACE는 ACE4\_FILE\_INHERIT\_ACE 및 ACE4\_DIRECTORY\_INHERIT\_ACE 플래그에 지정된 대로 새로 생성된 파일 및 디렉터리에 적용\(이 비트가 지워진 상태\)된 후에만 적용됩니다.

이 플래그가 ACE에 있지만 둘 다 없는 경우

- ACE4\_DIRECTORY\_INHERIT\_ACE 또는 ACE4\_FILE\_INHERIT\_ACE가 존재하는 경우 이러한 속성을 설정하려는 작업은 NFS4ERR\_ATTRNOTSUPP로 인해 실패해야 합니다.\(SHOULD\)

ACE4\_SUCCESSFUL\_ACCESS\_ACE\_FLAG 및 ACE4\_FAILED\_ACCESS\_ACE\_FLAG ACE4\_SUCCESSFUL\_ACCESS\_ACE\_FLAG\(SUCCESS\) 및 ACE4\_FAILED\_ACCESS\_ACE\_FLAG\(FAILED\) 플래그 비트는 ACE4\_SYSTEM\_AUDIT\_ACE\_TYPE\(AUDIT\) 및 ACE4\_SYSTEM\_ALARM\_ACE\_TYPE에서만 설정할 수 있습니다. \(ALARM\) ACE 유형. 파일의 ACL을 처리하는 동안 서버가 OPEN을 시도하는 주체와 일치하는 AUDIT 또는 ALARM ACE를 발견하면 서버는 해당 사실과 AUDIT 또는 ALARM에서 발견된 SUCCESS 및 FAILED 플래그의 존재 여부를 기록합니다. 에이스. 서버가 ACL 처리를 완료하면 작업이 성공했는지 실패했는지 기록됩니다. 작업이 성공하고 일치하는 AUDIT 또는 ALARM ACE에 대해 SUCCESS 플래그가 설정된 경우 적절한 AUDIT 또는 ALARM 이벤트가 발생합니다. 작업이 실패하고 일치하는 AUDIT 또는 ALARM ACE에 대해 FAILED 플래그가 설정된 경우 적절한 AUDIT 또는 ALARM 이벤트가 발생합니다. SUCCESS 또는 FAILED 중 하나 또는 둘 다를 설정할 수 있지만 둘 다 설정하지 않으면 AUDIT 또는 ALARM ACE가 유용하지 않습니다.

- 앞에서 설명한 처리는 NFS4\_OK를 반환하는 경우에도 ACCESS 작업에 적용됩니다. AUDIT 및 ALARM의 목적을 위해 요청 및 지원된 비트를 반환하지 못하는 경우 ACCESS 작업을 "실패"로 간주합니다.

ACE4\_IDENTIFIER\_GROUP

- "누구"가 UNIX에서 정의된 GROUP 또는 Windows에서 정의된 GROUP ACCOUNT를 나타냄을 나타냅니다. 클라이언트와 서버는 섹션 6.2.1.5에 설명된 특수 식별자 중 하나와 동일한 who 값을 가진 ACE의 ACE4\_IDENTIFIER\_GROUP 플래그를 무시해야 합니다.\(MUST\)

ACE4\_INHERITED\_ACE

- 이 ACE가 상위 디렉터리에서 상속되었음을 나타냅니다. 자동 상속을 지원하는 서버는 새 개체를 만들 때 상위 디렉터리에서 상속된 모든 ACE에 이 플래그를 배치합니다. 클라이언트 애플리케이션은 이를 사용하여 자동 상속을 수행합니다. 클라이언트와 서버는 acl 속성에서 이 비트를 지워야 합니다. dacl 및 sacl 속성에만 사용할 수 있습니다.\(MUST\)

---
##### **6.2.1.5.  ACE Who**

ACE의 "누구" 필드는 ACE가 적용되는 주체를 지정하는 식별자입니다. 플래그 비트 ACE4\_IDENTIFIER\_GROUP을 사용하여 사용자 또는 그룹을 나타낼 수 있습니다.

특정 DNS 도메인의 맥락이 아닌 보편적으로 이해해야 하는 몇 가지 특수 식별자가 있습니다. 이러한 식별자 중 일부는 NFS 클라이언트가 서버에 액세스할 때 이해할 수 없지만 로컬 프로세스가 파일에 액세스할 때는 의미가 있습니다. 이러한 권한을 표시하고 수정하는 기능은 서버의 액세스 방법 중 어느 것도 식별자를 이해하지 못하는 경우에도 NFS를 통해 허용됩니다.

```text
   +===============+==================================================+
   | Who           | Description                                      |
   +===============+==================================================+
   | OWNER         | The owner of the file.                           |
   +---------------+--------------------------------------------------+
   | GROUP         | The group associated with the file.              |
   +---------------+--------------------------------------------------+
   | EVERYONE      | The world, including the owner and owning group. |
   +---------------+--------------------------------------------------+
   | INTERACTIVE   | Accessed from an interactive terminal.           |
   +---------------+--------------------------------------------------+
   | NETWORK       | Accessed via the network.                        |
   +---------------+--------------------------------------------------+
   | DIALUP        | Accessed as a dialup user to the server.         |
   +---------------+--------------------------------------------------+
   | BATCH         | Accessed from a batch job.                       |
   +---------------+--------------------------------------------------+
   | ANONYMOUS     | Accessed without any authentication.             |
   +---------------+--------------------------------------------------+
   | AUTHENTICATED | Any authenticated user (opposite of ANONYMOUS).  |
   +---------------+--------------------------------------------------+
   | SERVICE       | Access from a system service.                    |
   +---------------+--------------------------------------------------+

                                 Table 7

   To avoid conflict, these special identifiers are distinguished by an
   appended "@" and should appear in the form "xxxx@" (with no domain
   name after the "@"), for example, ANONYMOUS@.
```

이러한 특수 식별자가 있는 항목에서는 ACE4\_IDENTIFIER\_GROUP 플래그를 무시해야 합니다. 이러한 특수 식별자를 사용하여 항목을 인코딩할 때 ACE4\_IDENTIFIER\_GROUP 플래그를 0으로 설정해야 합니다.\(MUST, SHOULD\)

---
###### **6.2.1.5.1.  Discussion of EVERYONE@**

"EVERYONE@"은 UNIX의 "기타" 엔터티와 동일하지 않다는 점에 유의하는 것이 중요합니다. 이는 정의에 따라 UNIX "기타"에는 파일의 소유자 또는 소유 그룹이 포함되지 않기 때문입니다. "EVERYONE@"은 문자 그대로 소유자 또는 소유 그룹을 포함한 모든 사람을 의미합니다.

---
#### **6.2.2.  Attribute 58: dacl**

dacl 속성은 acl 속성과 유사하지만 dacl은 ALLOW 및 DENY ACE만 허용합니다. dacl 속성은 자동 상속을 지원합니다\(섹션 6.4.3.2 참조\).

---
#### **6.2.3.  Attribute 59: sacl**

sacl 속성은 acl 속성과 유사하지만 sacl은 AUDIT 및 ALARM ACE만 허용합니다. sacl 속성은 자동 상속을 지원합니다\(섹션 6.4.3.2 참조\).

---
#### **6.2.4.  Attribute 33: mode**

NFSv4.1 모드 속성은 UNIX 모드 비트를 기반으로 합니다. 다음 비트가 정의됩니다:

```text
   const MODE4_SUID = 0x800;  /* set user id on execution */
   const MODE4_SGID = 0x400;  /* set group id on execution */
   const MODE4_SVTX = 0x200;  /* save text even after use */
   const MODE4_RUSR = 0x100;  /* read permission: owner */
   const MODE4_WUSR = 0x080;  /* write permission: owner */
   const MODE4_XUSR = 0x040;  /* execute permission: owner */
   const MODE4_RGRP = 0x020;  /* read permission: group */
   const MODE4_WGRP = 0x010;  /* write permission: group */
   const MODE4_XGRP = 0x008;  /* execute permission: group */
   const MODE4_ROTH = 0x004;  /* read permission: other */
   const MODE4_WOTH = 0x002;  /* write permission: other */
   const MODE4_XOTH = 0x001;  /* execute permission: other */
```

비트 MODE4\_RUSR, MODE4\_WUSR 및 MODE4\_XUSR은 소유자 속성에서 식별된 주체에 적용됩니다. 비트 MODE4\_RGRP, MODE4\_WGRP 및 MODE4\_XGRP는 owner\_group 속성에서 식별되었지만 소유자 속성에서는 식별되지 않은 주체에 적용됩니다. 비트 MODE4\_ROTH, MODE4\_WOTH 및 MODE4\_XOTH는 소유자 속성과 일치하지 않고 owner\_group 속성과 일치하는 그룹이 없는 모든 주체에 적용됩니다.

위에 지정된 모드 이외의 비트는 이 프로토콜에 의해 정의되지 않습니다. 서버는 GETATTR 또는 READDIR 작업에서 위에 정의된 비트 이외의 비트를 반환해서는 안 되며, 위에 정의된 비트 이외의 비트가 SETATTR, CREATE, OPEN, VERIFY 또는 NVERIFY 작업에서 설정된 경우 NFS4ERR\_INVAL을 반환해야 합니다.\(MUST NOT\)

---
#### **6.2.5.  Attribute 74: mode_set_masked**

mode\_set\_masked 속성은 다른 속성을 변경하지 않고 모드 속성의 개별 비트를 설정하거나 재설정할 수 있는 쓰기 전용 속성입니다. 예를 들어, MODE4\_SUID, MODE4\_SGID 및 MODE4\_SVTX 비트를 수정하는 동시에 권한에 할당된 9개의 하위 모드 비트 중 하나를 수정하지 않은 상태로 둘 수 있습니다.

9개의 하위 비트가 수정되지 않은 채 남아 있는 경우 섹션 6.4.1에서 설명한 대로 acl이나 dacl 속성이 자동으로 수정되어서는 안 됩니다.

mode\_set\_masked 속성은 각각 mode4 형식의 두 단어로 구성됩니다. 첫 번째는 현재 모드 값에 적용할 값으로 구성되고 두 번째는 마스크입니다. 마스크 워드에서 1로 설정된 비트만 파일 모드에서 변경\(설정 또는 재설정\)됩니다. 모드의 다른 모든 비트는 변경되지 않습니다. 마스크에서 0인 비트에 해당하는 첫 번째 워드의 비트는 무시됩니다. 단, 정의되지 않은 비트는 유효성이 검사되어 아래 설명된 대로 NFS4ERR\_INVAL이 발생할 수 있습니다.

mode\_set\_masked 속성은 SETATTR 작업에서만 유효합니다. CREATE 또는 OPEN 작업에 사용되는 경우 서버는 NFS4ERR\_INVAL을 반환해야 합니다.\(MUST\)

mode 속성에서 유효한 것으로 정의되지 않은 비트는 mode\_set\_masked 속성의 어느 단어에서도 유효하지 않습니다. SETATTR에서 해당 비트가 1로 설정된 경우 서버는 NFS4ERR\_INVAL을 반환해야 합니다. mode 및 mode\_set\_masked 속성이 모두 동일한 SETATTR에 지정된 경우 서버는 NFS4ERR\_INVAL도 반환해야 합니다.\(MUST, MUST\)

---
### **6.3.  Common Methods**

이 섹션의 요구 사항은 향후 섹션, 특히 섹션 6.4에서 참조됩니다.

---
#### **6.3.1.  Interpreting an ACL**
---
##### **6.3.1.1.  Server Considerations**

서버는 섹션 6.2.1에 설명된 알고리즘을 사용하여 ACL이 객체에 대한 액세스를 허용하는지 여부를 결정합니다. 그러나 ACL이 유일한 액세스 결정자가 아닐 수도 있습니다. 예를 들어:

\* 읽기 전용으로 내보낸 파일 시스템의 경우 객체의 ACL이 쓰기 액세스를 허용하더라도 서버에서 쓰기 액세스를 거부할 수 있습니다.

\* 서버 구현은 ACL을 수정할 수 있는 유효한 방법이 없는 상황이 발생하는 것을 방지하기 위해 ACE4\_WRITE\_ACL 및 ACE4\_READ\_ACL 권한을 부여할 수 있습니다.\(MAY\)

\* 모든 서버는 실행 권한만 부여된 경우 사용자에게 파일의 데이터를 읽을 수 있는 기능을 허용합니다. 즉, ACL이 사용자의 ACE4\_READ\_DATA 액세스를 거부하고 사용자 ACE4\_EXECUTE를 허용하는 경우 서버는 사용자가 파일의 데이터를 읽을 수 있도록 허용합니다. 파일의 데이터\).

\* 많은 서버에는 객체 소유자가 ACL에서 거부한 액세스를 재정의할 수 있도록 허용하는 소유자 재정의 개념이 있습니다. 예를 들어, 이는 권한이 변경된 열린 파일에 대해 사용자가 계속 액세스할 수 있도록 허용하는 데 도움이 될 수 있습니다.

\* 많은 서버에는 일반 사용자 이상의 권한을 갖는 "수퍼유저"라는 개념이 있습니다. 수퍼유저는 ACL에서 허용하지 않는 방식으로 데이터나 메타데이터를 읽거나 쓸 수 있습니다.

\* 보존 속성은 ACL에서 허용하는 액세스를 차단할 수도 있습니다\(섹션 5.13 참조\).

---
##### **6.3.1.2.  Client Considerations**

클라이언트는 ACL 해석을 기반으로 자체 액세스 확인을 수행해서는 안 되며, OPEN 및 ACCESS 작업을 사용하여 액세스 확인을 수행해야 합니다. 이를 통해 클라이언트는 ACL 해석을 기반으로 액세스 권한을 부여해야 하는지 여부를 서버가 결정하도록 한 결과에 따라 조치를 취할 수 있습니다.\(SHOULD NOT\)

클라이언트는 서버가 이를 시행하지 않더라도 객체의 ACL이 특정 액세스를 정의하는 상황을 인식해야 합니다. 일반적으로, 특히 이러한 상황에서 클라이언트는 ACL에 정의된 대로 액세스를 적용하는 데 있어 자신의 역할을 수행해야 합니다. 이를 위해 클라이언트는 사용자 또는 애플리케이션이 요청된 액세스 권한을 부여 받아야 하는지 여부를 결정하기 위해 사용자 또는 애플리케이션의 요청을 서비스하기 전에 적절한 ACCESS 작업을 보낼 수 있습니다. ACL이 서버가 시행하지 않는 액세스를 정의할 수 있는 예는 섹션 6.3.1.1을 참조하세요.\(MAY\)

---
#### **6.3.2.  Computing a Mode Attribute from an ACL**

다음 방법을 사용하여 ACL을 기반으로 모드 속성의 MODE4\_R\*, MODE4\_W\* 및 MODE4\_X\* 비트를 계산할 수 있습니다.

먼저, 각 특수 식별자 OWNER@, GROUP@ 및 EVERYONE@에 대해 식별자 EVERYONE@과 고려 중인 식별자에 대한 ALLOW 및 DENY ACE만 고려하여 ACL을 순서대로 평가합니다. 평가 결과는 해당 식별자에 허용되는 비트를 정확하게 보여주는 NFSv4 ACL 마스크입니다.

그런 다음 OWNER@, GROUP@ 및 EVERYONE@에 대해 계산된 마스크를 다음과 같이 각각 사용자, 그룹 및 기타에 대한 모드 비트로 변환합니다.

1. ACE4\_READ\_DATA가 해당 마스크에 설정된 경우에만 읽기 비트\(MODE4\_RUSR, MODE4\_RGRP 또는 MODE4\_ROTH\)를 설정합니다.

2. 해당 마스크에 ACE4\_WRITE\_DATA 및 ACE4\_APPEND\_DATA가 모두 설정된 경우에만 쓰기 비트\(MODE4\_WUSR, MODE4\_WGRP 또는 MODE4\_WOTH\)를 설정합니다.

3. 해당 마스크에 ACE4\_EXECUTE가 설정된 경우에만 실행 비트\(MODE4\_XUSR, MODE4\_XGRP 또는 MODE4\_XOTH\)를 설정합니다.

---
##### **6.3.2.1.  Discussion**

일부 서버 구현에서는 명명된 사용자 및 그룹에 허용되는 비트를 그룹 비트\(MODE4\_RGRP, MODE4\_WGRP 및 MODE4\_XGRP\)에 추가합니다.

모드 비트가 허용하는 것처럼 보이는 액세스가 거부된 파일 그룹의 구성원을 보는 사용자에게 혼란을 야기하는 것으로 밝혀졌기 때문에 구현에서는 이를 수행하지 않는 것이 좋습니다. \(DENY ACE가 있으면 이러한 동작이 발생할 수도 있지만 DENY ACE는 거의 사용되지 않을 것으로 예상됩니다.\)

모드를 가져올 때 나타나는 동일한 사용자 혼란은 모드 설정이 소유자, 그룹 및 기타 사용자에 대한 권한을 효과적으로 제어하지 못하는 경우에도 발생합니다. 이는 다음 요구 사항 중 일부에 동기를 부여합니다.

---
### **6.4.  Requirements**

모드와 ACL을 모두 지원하는 서버는 MODE4\_\*USR, MODE4\_\*GRP 및 MODE4\_\*OTH 비트를 "OWNER@", "GROUP@" 및 "EVERYONE@"의 각 who 필드가 있는 ACE와 동기화하도록 주의해야 합니다. ". 이런 방식으로 클라이언트는 소유자, owner\_group 및 모드 속성을 요청하는지 아니면 ACL만 요청하는지에 관계없이 의미상 동일한 액세스 권한이 존재하는지 확인할 수 있습니다.

이 섹션에서는 섹션 6.3.2의 방법을 많이 사용합니다. 많은 요구 사항이 이 섹션을 참조합니다. 그러나 메소드에는 "SHOULD"로 지정된 동작이 있습니다. 이는 소유자, 그룹 및 기타에 대한 실제 권한이 아닌 철회된 POSIX ACL 초안\(1003.1e 초안 17\)에 따라 모드를 계산하는 기존 구현을 무효화하지 않기 위한 의도적인 것입니다.\(SHOULD\)

---
#### **6.4.1.  Setting the Mode and/or ACL Attributes**

서버가 acl 속성 외에도 sacl 또는 dacl 속성을 지원하는 경우 서버는 dacl 또는 sacl 속성과 동시에 acl 속성을 설정하라는 요청에 실패해야 합니다. 제공되는 오류는 NFS4ERR\_ATTRNOTSUPP입니다.\(MUST\)

---
##### **6.4.1.1.  Setting Mode and not ACL**

모드 속성이 설정되었거나 mode\_set\_masked 속성이 설정되고 마스크에 9개의 하위 모드 비트 중 하나 이상의 비트가 포함되어 있고 ACL 속성이 없기 때문에 9개의 하위 모드 비트 중 하나라도 변경될 수 있는 경우 명시적으로 설정되면 해당 비트의 업데이트된 값에 따라 acl 및 dacl 속성을 수정해야 합니다. 이는 모드를 이전과 같이 설정한 후에도 하위 비트의 값이 동일하더라도 발생해야 합니다.

AUDIT 또는 ALARM ACE\(따라서 sacl 속성의 ACE\)는 모드 변경에 영향을 받지 않습니다.

권한 비트가 변경될 수 있는 경우 섹션 6.3.2의 방법을 통해 계산된 모드가 하위 9비트\(MODE4\_R\*, MODE4\_W\*, MODE4\_X\*\)를 생성하도록 acl 및 dacl 속성을 수정해야 합니다. 속성 변경으로 수정된 모드 속성의 모습입니다. ACL 속성도 다음과 같이 수정되어야 합니다.\(MUST, SHOULD\)

1. MODE4\_RGRP가 설정되지 않은 경우 OWNER@ 및 EVERYONE@ 이외의 ACL에 명시적으로 나열된 엔터티에는 ACE4\_READ\_DATA가 부여되어서는 안 됩니다.\(SHOULD NOT\)

2. MODE4\_WGRP가 설정되지 않은 경우 OWNER@ 및 EVERYONE@ 이외의 ACL에 명시적으로 나열된 엔터티에는 ACE4\_WRITE\_DATA 또는 ACE4\_APPEND\_DATA가 부여되어서는 안 됩니다.\(SHOULD NOT\)

3. MODE4\_XGRP가 설정되지 않은 경우 OWNER@ 및 EVERYONE@ 이외의 ACL에 명시적으로 나열된 엔터티에는 ACE4\_EXECUTE가 부여되어서는 안 됩니다.\(SHOULD NOT\)

ALLOW ACE에 나타나는 위에 나열된 것 이외의 액세스 마스크 비트도 비활성화될 수 있습니다.\(MAY\)

ACE4\_INHERIT\_ONLY\_ACE 플래그가 설정된 ACE는 ACL 자체의 권한에 영향을 주지 않으며 AUDIT 및 ALARM 유형의 ACE에도 영향을 미치지 않습니다. 따라서 ACL 속성을 수정할 때 이러한 ACE를 수정되지 않은 상태로 두는 것이 바람직합니다.

또한 모드만 나타내는 ACL을 위해 acl 및 dacl을 삭제하여 요구 사항을 충족할 수도 있습니다. 이는 허용되지만 서버에서는 위의 요구 사항을 위반하지 않고 가능한 한 많은 ACL을 보존하는 것이 좋습니다. ACL을 폐기하면 모드 속성으로 생성된 파일이 ACL을 상속하는 것이 사실상 불가능해집니다\(섹션 6.4.3 참조\).

---
##### **6.4.1.2.  Setting ACL and Not Mode**

acl 또는 dacl을 설정하고 mode 또는 mode\_set\_masked 속성을 설정하지 않는 경우 모드의 권한 비트는 ACL에서 파생되어야 합니다. 이 경우 ACL 속성은 주어진 대로 설정되어야 합니다. 모드 속성\(MODE4\_R\*, MODE4\_W\*, MODE4\_X\*\)의 하위 9개 비트는 섹션 6.3.2의 방법 결과와 일치하도록 수정되어야 합니다. 모드의 상위 3개 비트\(MODE4\_SUID, MODE4\_SGID, MODE4\_SVTX\)는 변경되지 않고 유지되어야 합니다.\(SHOULD, MUST, SHOULD\)

---
##### **6.4.1.3.  Setting Both ACL and Mode**

동일한 작업에서 모드\(모드 속성 또는 mode\_set\_masked 속성 사용 포함\)와 acl 또는 dacl 속성을 모두 설정할 때 속성은 모드\(또는 mode\_set\_masked\), ACL 순서로 적용되어야 합니다. 모드 관련 속성은 지정된 대로 설정되고, ACL 속성은 지정된 대로 설정되며, 위의 섹션 6.4.1.2에 설명된 대로 최종 모드를 변경할 수 있습니다.\(MUST\)

---
#### **6.4.2.  Retrieving the Mode and/or ACL Attributes**

이 섹션은 모드 및 ACL 속성을 모두 지원하는 서버에만 적용됩니다.

일부 서버 구현에는 "ACL이 없는 개체"라는 개념이 있을 수 있습니다. 즉, 모드 속성에 따라 모든 권한이 부여 및 거부되고 해당 개체에 대해 ACL 속성이 저장되지 않음을 의미합니다. 그러한 서버에 ACL 속성이 요청되면 서버는 모드와 충돌하지 않는 ACL을 반환해야 합니다. 즉, 반환된 ACL은 섹션 6.3.2에 설명된 대로 모드 속성\(MODE4\_R\*, MODE4\_W\*, MODE4\_X\*\)의 하위 9개 비트를 나타내야 합니다.\(SHOULD\)

다른 서버 구현의 경우 ACL 속성은 모든 개체에 대해 항상 존재합니다. 이러한 서버는 모드 속성\(MODE4\_SUID, MODE4\_SGID, MODE4\_SVTX\)의 상위 비트 3개 이상을 저장해야 합니다. 서버는 요청된 경우 모드 속성을 반환해야 하며, 모드의 하위 9비트\(MODE4\_R\*, MODE4\_W\*, MODE4\_X\*\)는 섹션 6.3.2의 메서드를 ACL 속성에 적용한 결과와 일치해야 합니다.\(SHOULD, MUST\)

---
#### **6.4.3.  Creating New Objects**

서버가 ACL 속성을 지원하는 경우 상위 디렉터리의 ACL 속성을 사용하여 새로 생성된 객체에 대한 초기 ACL 속성을 계산할 수 있습니다. 이 섹션에서는 이를 상속된 ACL이라고 합니다. 상위 디렉터리의 ACL에 있는 ACE를 기반으로 하는 상속된 ACL에 하나 이상의 ACE를 추가하는 행위를 이 섹션에서는 ACE 상속이라고 합니다.

구현자는 모드 및 ACL 속성의 유무에 따라 CREATE 및 OPEN의 동작을 표준화해야 합니다.

1. 호출에 모드만 제공된 경우:

- 이 경우 상속이 이루어져야 하지만 섹션 6.4.1.1에 설명된 대로 상속된 ACL에 모드를 적용하여 ACL을 수정해야 합니다.\(MUST\)

2. 호출에 ACL만 제공되는 경우:

- 이 경우 상속이 발생해서는 안 되며 CREATE 또는 OPEN에 정의된 ACL이 수정 없이 설정되고 모드는 6.4.1.2절과 같이 수정됩니다.\(SHOULD NOT\)

3. 호출에 모드와 ACL이 모두 제공된 경우:

- 이 경우 상속이 발생해서는 안 되며 두 속성 모두 섹션 6.4.1.3에 설명된 대로 설정됩니다.\(SHOULD NOT\)

4. 통화에 모드나 ACL이 모두 제공되지 않은 경우:

- 초기 속성이 전혀 없이 객체가 생성되는 경우\(예: OPEN4\_CREATE의 opentype4 및 EXCLUSIVE4의 createmode4를 사용하는 OPEN 작업\) 상속이 발생해서는 안 됩니다\(참고로 EXCLUSIVE4\_1은 createmode4보다 더 나은 선택입니다. 초기 속성을 허용합니다\). 대신, 서버는 새로 생성된 개체에 대한 모든 액세스를 거부하도록 권한을 설정해야 합니다. 적절한 클라이언트가 후속 SETATTR 작업에서 원하는 속성을 설정할 것으로 예상되며, 서버는 개체가 생성된 권한에 관계없이 해당 작업이 성공하도록 허용해야 합니다. 예를 들어, 빈 ACL은 모든 권한을 거부하지만 서버는 WRITE\_ACL이 암시적으로 거부되더라도 소유자의 SETATTR이 성공하도록 허용해야 합니다.\(SHOULD NOT, SHOULD, SHOULD\)

다른 경우에는 상속이 이루어져야 하며

- ACL이 수정됩니다. 지원되는 경우 모드 속성은 MODE4\_SUID, MODE4\_SGID 및 MODE4\_SVTX 비트가 지워진 상태에서 섹션 6.3.2에서 계산된 대로 이루어져야 합니다. 상위 디렉터리에 상속 가능한 ACE가 없으면 acl, dacl 또는 sacl 속성을 생성하는 규칙이 구현에 따라 정의됩니다. dacl 또는 sacl 속성이 지원되는 경우 새로 생성된 속성에 ACL4\_DEFAULTED 플래그를 설정해야 합니다.\(SHOULD, MUST, SHOULD\)

---
##### **6.4.3.1.  The Inherited ACL**

생성되는 개체가 디렉터리가 아닌 경우 상속된 ACL은 ACE4\_FILE\_INHERIT\_FLAG가 설정되지 않은 한 상위 디렉터리 ACL에서 ACE를 상속해서는 안 됩니다.\(SHOULD NOT\)

생성되는 개체가 디렉터리인 경우 상속된 ACL은 상위 디렉터리, 즉 ACE4\_FILE\_INHERIT\_ACE 또는 ACE4\_DIRECTORY\_INHERIT\_ACE 플래그가 설정된 디렉터리에서 상속 가능한 모든 ACE를 상속해야 합니다. 상속 가능한 ACE에 ACE4\_FILE\_INHERIT\_ACE가 설정되어 있지만 ACE4\_DIRECTORY\_INHERIT\_ACE가 지워진 경우 새로 생성된 디렉터리의 상속된 ACE에는 디렉터리가 아닌 디렉터리를 위한 ACE의 영향을 받지 않도록 디렉터리가 설정된 ACE4\_INHERIT\_ONLY\_ACE 플래그가 있어야 합니다.\(MUST\)

새 디렉터리가 생성되면 서버는 상속 가능하고 효과적인 상속된 ACE\(즉, ACE4\_INHERIT\_ONLY\_ACE나 ACE4\_NO\_PROPAGATE\_INHERIT\_ACE가 설정되지 않음\)를 두 개의 ACE\(상속 플래그가 없는 ACE와 ACE4\_INHERIT\_ONLY\_ACE가 설정된 ACE\)로 분할할 수 있습니다. \(dacl 또는 sacl 속성의 경우 두 ACE 모두 ACE4\_INHERITED\_ACE 플래그가 설정되어 있어야 합니다.\) 이렇게 하면 새 디렉토리의 하위 항목에 상속될 ACE를 수정하지 않고도 디렉토리에 대한 유효 권한을 수정하는 것이 더 간단해집니다. .\(MAY, SHOULD\)

---
##### **6.4.3.2.  Automatic Inheritance**

acl 속성은 ACE 배열로만 구성되지만 sacl\(섹션 6.2.3\) 및 dacl\(섹션 6.2.2\) 속성에는 추가 플래그 필드도 포함됩니다.

```text
   struct nfsacl41 {
           aclflag4        na41_flag;
           nfsace4         na41_aces<>;
   };
```

플래그 필드는 전체 sacl 또는 dacl에 적용됩니다. 세 가지 플래그 값이 정의됩니다.

```text
   const ACL4_AUTO_INHERIT         = 0x00000001;
   const ACL4_PROTECTED            = 0x00000002;
   const ACL4_DEFAULTED            = 0x00000004;
```

다른 모든 비트는 지워져야 합니다. ACE4\_INHERITED\_ACE 플래그는 sacl 또는 dacl의 ACE에 설정될 수 있습니다\(반면 acl에서는 항상 지워져야 함\).

이러한 기능을 함께 사용하면 서버가 자동 상속을 지원할 수 있습니다. 이제 이에 대해 자세히 설명합니다.

상속 가능한 ACE는 일반적으로 하위 개체가 생성될 때만 하위 개체에 의해 상속됩니다. 상속 가능한 ACE를 나중에 수정해도 하위 항목의 상속된 ACE가 수정되지 않습니다.

그러나 dacl 및 sacl은 클라이언트 응용 프로그램이 상속 가능한 ACE에 대한 변경 사항을 전체 디렉터리 계층 구조에 전파할 수 있도록 하는 선택적 메커니즘을 제공합니다.\(MAY\)

이를 지원하는 서버는 개체 생성 시 일반적인 방법으로 상속을 수행하고, 상속된 ACE가 새 개체에 추가될 때 ACE4\_INHERITED\_ACE 플래그를 설정해야 합니다.\(SHOULD\)

그런 다음 ACL 편집기와 같은 클라이언트 응용 프로그램은 해당 디렉터리의 하위 항목을 재귀적으로 탐색하고 발견된 각 ACL을 수정하여 ACE4\_INHERITED\_ACE 플래그가 있는 ACE를 제거하고 이를 새로운 상속 가능한 ACE\(또한 ACE4\_INHERITED\_ACE 플래그가 설정됨\). 이는 전파할 ACE를 결정하기 위해 확실한 방법으로 기존 ACE 상속 플래그를 사용합니다. \(디렉터리 계층 구조를 내려갈 때 추가 상속 가능한 ACE가 발생할 수 있으며 상속 가능한 ACE를 추가 하위 항목으로 전파할 때도 이를 고려해야 합니다.\)

이 전파 범위는 두 가지 방법으로 제한될 수 있습니다. 첫째, ACL4\_AUTO\_INHERIT 플래그가 지워진 디렉터리 ACL에서는 자동 상속이 수행되지 않습니다. 둘째, ACL4\_PROTECTED 플래그가 있는 ACL이 설정될 때마다 자동 상속이 중지되어 해당 ACL은 물론 객체의 하위 항목에 있는 ACL\(ACL이 디렉터리에 설정된 경우\)도 수정되지 않습니다.

이 전파는 sacl 및 dacl 속성에 대해 독립적으로 수행됩니다. 따라서 ACL4\_AUTO\_INHERIT 및 ACL4\_PROTECTED 플래그는 sacl 및 dacl에 대해 독립적으로 설정될 수 있으며, 한 유형의 acl 전파는 다른 acl 전파가 중지된 경우에도 계층 구조 아래로 계속될 수 있습니다.

ACL4\_PROTECTED 플래그가 지워지고 ACL4\_AUTO\_INHERIT 플래그가 각각 상위 개체의 sacl 또는 dacl과 동일한 값으로 설정된 dacl 및 sacl을 사용하여 새 개체를 만들어야 합니다.

dacl 및 sacl 속성은 모두 권장되며, 서버는 다른 속성을 지원하지 않고 하나만 지원할 수 있습니다.\(SHOULD\)

이전 acl 속성과 새 dacl 또는 sacl 속성 중 하나 또는 둘 다를 모두 지원하는 서버는 세 가지 속성이 모두 서로 일관성을 유지하는 방식으로 이를 수행해야 합니다. 따라서 acl 속성에 보고된 ACE는 acl의 ACE에서 ACE4\_INHERITED\_ACE 플래그를 지워야 한다는 점을 제외하면 dacl 및 sacl 속성에 보고된 ACE의 통합이어야 합니다. 물론 acl만 쿼리하는 클라이언트는 sacl 또는 dacl 플래그 필드의 값을 확인할 수 없습니다.

클라이언트가 acl 속성에 대해 SETATTR을 수행하면 서버는 sacl과 dacl 모두에서 ACL4\_PROTECTED 플래그를 true로 설정해야 합니다. dacl 또는 sacl 속성과 달리 acl 속성을 사용하면 클라이언트는 자동 상속을 이해하지 못할 수 있으므로 자동 상속이 적합한 ACL을 설정하는 것을 신뢰할 수 없다는 신호를 보냅니다.\(SHOULD\)

클라이언트 애플리케이션이 ACL을 쿼리하고 이를 수정하고 다시 설정할 때 ACL 끝에 ACE4\_INHERITED\_ACE로 표시된 모든 ACE를 원래 순서대로 변경하지 않고 그대로 두어야 합니다. 애플리케이션이 이를 수행할 수 없는 경우 ACL4\_PROTECTED 플래그를 설정해야 합니다. 이 동작은 서버에서 강제되지 않지만 이 규칙을 위반하면 응용 프로그램이 자동 상속을 수행할 때 예기치 않은 결과가 발생할 수 있습니다.

서버가 모드 속성도 지원하는 경우 ACL 끝에서 상속된 ACE를 원래 순서대로 변경하지 않는 방식으로 모드를 설정해야 합니다. 그렇게 할 수 없는 경우 파일의 dacl에 ACL4\_PROTECTED 플래그를 설정해야 합니다.\(SHOULD, SHOULD\)

마지막으로, 새 파일이나 디렉터리를 생성하는 요청이 해당 파일이나 디렉터리에 대한 권한도 설정하지 않고 상위 디렉터리에서 상속할 ACE도 없는 경우 새 개체에 대한 서버의 ACL 선택은 다음과 같습니다. 구현에 따라 다릅니다. 이 경우 서버는 새 개체에 대해 선택한 ACL에 ACL4\_DEFAULTED 플래그를 설정해야 합니다. 자동 상속을 수행하는 애플리케이션은 ACL4\_DEFAULTED 플래그를 ACL이 자동 상속 규칙을 사용하여 생성된 ACL로 완전히 대체되어야 한다는 신호로 사용합니다.\(SHOULD\)

---
## **7.  Single-Server Namespace**

이 섹션에서는 NFSv4 단일 서버 네임스페이스에 대해 설명합니다. 단일 서버 네임스페이스는 클라이언트에 직접 제공될 수도 있고, 섹션 11에 설명된 대로 클라이언트에 제공될 더 큰 다중 서버 네임스페이스\(예: 사이트 전체 또는 조직 전체\)를 형성하기 위한 기반으로 사용될 수도 있습니다.

---
### **7.1.  Server Exports**

UNIX 서버에서 네임스페이스는 루트 디렉터리 또는 "/" 아래의 경로 이름으로 접근할 수 있는 모든 파일을 설명합니다. Windows 서버에서 네임스페이스는 매핑된 디스크 문자로 명명된 디스크의 모든 파일을 구성합니다. NFS 서버 관리자는 NFS 클라이언트가 전체 서버의 파일 시스템 네임스페이스를 사용할 수 있도록 하는 경우가 거의 없습니다. 네임스페이스의 일부는 "내보내기" 기능을 통해 사용 가능한 경우가 더 많습니다. 이전 버전의 NFS 프로토콜에서는 각 내보내기에 대한 루트 파일 핸들이 MOUNT 프로토콜을 통해 획득되었습니다. 클라이언트는 네임스페이스 내의 내보내기 이름을 식별하는 문자열을 보냈고 서버는 해당 내보내기에 대한 루트 파일 핸들을 반환했습니다. MOUNT 프로토콜은 서버의 내보내기를 열거하는 EXPORTS 프로시저도 제공했습니다.

---
### **7.2.  Browsing Exports**

NFSv4.1 프로토콜은 클라이언트가 경로를 통과하기 위해 COMPOUND 내의 일련의 LOOKUP 작업을 통해 특정 서버 내보내기에 대한 파일 핸들을 얻는 데 사용할 수 있는 루트 파일 핸들을 제공합니다. 일반적인 사용자 경험은 그래픽 사용자 인터페이스\(예: 파일 "열기" 대화 상자 창\)를 사용하여 디렉터리 트리를 통한 점진적인 탐색을 통해 파일을 찾는 것입니다. 클라이언트는 단일 구성 요소의 점진적인 LOOKUP 작업을 통해 한 내보내기에서 다른 내보내기로 이동할 수 있어야 합니다.

이러한 검색 스타일은 NFSv3 프로토콜에서 잘 지원되지 않습니다. NFSv3에서 클라이언트는 모든 LOOKUP 작업이 단일 서버 파일 시스템 내에 유지되기를 기대합니다. 예를 들어 장치 속성은 변경되지 않습니다. 이렇게 하면 클라이언트가 내보내기에 걸쳐 있는 네임스페이스 경로를 사용하지 못하게 됩니다.

NFSv3의 경우 클라이언트의 자동 마운트는 MOUNT 프로토콜의 EXPORTS 프로시저를 사용하여 서버 네임스페이스의 스냅샷을 얻을 수 있습니다. 서버의 경로 이름 구문을 이해하면 클라이언트에 서버 네임스페이스의 이미지를 생성할 수 있습니다. 서버에서 내보내지 않은 네임스페이스 부분은 사용자가 마운트된 파일 시스템에서 다른 파일 시스템으로 탐색할 수 있도록 하는 NFSv4.1 "의사 파일 시스템"\(섹션 7.3 참조\)과 유사하게 구성될 수 있는 디렉터리로 채워집니다. . 클라이언트의 서버 네임스페이스 표현에는 단점이 있습니다. 즉, 정적이라는 것입니다. 서버 관리자가 새 내보내기를 추가하면 클라이언트는 이를 인식하지 못합니다.

---
### **7.3.  Server Pseudo File System**

NFSv4.1 서버는 해당 서버의 단일 네임스페이스 프레임워크 내에서 특정 서버에 대한 모든 내보내기를 제공하여 이러한 네임스페이스 불일치를 방지합니다. NFSv4.1 클라이언트는 LOOKUP 및 READDIR 작업을 사용하여 한 내보내기에서 다른 내보내기로 원활하게 찾아봅니다.

내보내지지 않은 서버 네임스페이스 부분이 있는 경우 클라이언트는 실제 내보낸 파일 시스템에 도달하기 위해 해당 부분을 탐색하는 방법이 필요합니다. 이를 제공하기 위해 서버가 사용할 수 있는 기술은 내보낸 디렉터리 보기만 제공하는 "의사 파일 시스템"을 통해 이름 공간의 내보내지 않은 부분을 연결하는 것입니다. 의사 파일 시스템에는 고유한 fsid가 있으며 일반 읽기 전용 파일 시스템처럼 작동합니다.

서버의 네임스페이스 구성에 따라 여러 의사 파일 시스템이 존재할 수 있습니다. 예를 들어,

```text
           /a              pseudo file system
           /a/b            real file system
           /a/b/c          pseudo file system
           /a/b/c/d        real file system
```

각각의 의사 파일 시스템은 별도의 엔터티로 간주되므로 해당 서버의 모든 fsid 중에서 고유한 자체 fsid를 가져야 합니다.\(MUST\)

---
### **7.4.  Multiple Roots**

특정 운영 환경은 때때로 "다중 루트"를 갖는 것으로 설명됩니다. 이러한 환경에서는 개별 파일 시스템이 일반적으로 디스크 또는 볼륨 이름으로 표시됩니다. 이러한 플랫폼용 NFSv4 서버는 디스크 문자나 볼륨 이름이 단순히 의사 루트의 디렉터리 이름이 되도록 이러한 루트 이름 위에 의사 파일 시스템을 구성할 수 있습니다.

---
### **7.5.  Filehandle Volatility**

서버 의사 파일 시스템의 특성은 서버에서 사용 가능한 파일 시스템을 논리적으로 표현한 것입니다. 따라서 의사 파일 시스템은 서버가 처음 인스턴스화될 때 동적으로 구성될 가능성이 높습니다. 의사 파일 시스템에는 영구 파일 핸들을 구성할 수 있는 디스크상 대응 항목이 없을 수 있습니다. 서버가 의사 파일 시스템에 영구 파일 핸들을 제공하는 것이 바람직하더라도 NFS 클라이언트는 의사 파일 시스템 파일 핸들이 일시적이라는 것을 예상해야 합니다. 이는 문제의 파일 핸들과 관련된 "fh\_expire\_type" 속성을 확인하여 확인할 수 있습니다. 파일 핸들이 일시적인 경우 NFS4ERR\_FHEXPIRED 오류를 수신할 때 NFS 클라이언트는 일련의 LOOKUP 작업을 통해 파일 핸들 값을 복구할 준비를 해야 합니다.

서버가 휘발성 파일 핸들을 사용하여 의사 파일 시스템을 구현할 가능성이 높으므로 클라이언트는 모든 파일 핸들이 영구적일 것이라고 가정하기보다는 이에 대비해야 합니다.

---
### **7.6.  Exported Root**

서버의 루트 파일 시스템을 내보내는 경우 의사 파일 시스템이 필요하지 않다고 결론을 내릴 수도 있습니다. 반드시 그런 것은 아닙니다. 서버에 다음 파일 시스템이 있다고 가정합니다.

```text
           /       fs1  (exported)
           /a      fs2  (not exported)
           /a/b    fs3  (exported)
```

fs2는 내보내지지 않으므로 간단한 LOOKUP으로 fs3에 접근할 수 없습니다. 서버는 의사 파일 시스템을 사용하여 격차를 해소해야 합니다.

---
### **7.7.  Mount Point Crossing**

서버 파일 시스템 환경은 하나의 파일 시스템이 두 번째 파일 시스템에 의해 '덮이거나' 마운트되는 디렉토리를 포함하는 방식으로 구성될 수 있습니다. 예를 들어:

```text
           /a/b            (file system 1)
           /a/b/c/d        (file system 2)
```

이 서버의 의사 파일 시스템은 다음과 같이 구성될 수 있습니다.

```text
           /               (place holder/not exported)
           /a/b            (file system 1)
           /a/b/c/d        (file system 2)
```

완전한 의사 파일 시스템을 클라이언트에 제공하는 것은 서버의 책임입니다. 클라이언트가 /a/b/c/d 경로에 대한 LOOKUP 요청을 보내는 경우 서버의 응답은 파일 시스템 /a/b/c/d 루트의 파일 핸들입니다. 이전 버전의 NFS 프로토콜에서 서버는 파일 시스템 /a/b 내 디렉토리 /a/b/c/d의 파일 핸들로 응답했습니다.

NFS 클라이언트는 "fsid" 속성 값의 변경을 통해 서버 마운트 지점을 통과하는지 확인할 수 있습니다.

---
### **7.8.  Security Policy and Namespace Presentation**

NFSv4 클라이언트는 SECINFO 및 SECINFO\_NONAME을 사용하여 무엇이 허용되는지 결정한 후 사용되는 보안 메커니즘을 변경할 수 있는 기능을 보유하고 있으므로 서버는 클라이언트가 사용하는 보안 메커니즘을 기반으로 네임스페이스의 다른 보기를 제시해서는 안 됩니다. 대신, 부적절한 보안 메커니즘을 사용하여 데이터에 액세스하려는 시도가 있는 경우 일관된 보기를 제공하고 NFS4ERR\_WRONGSEC를 반환해야 합니다.\(SHOULD NOT\)

보안 고려 사항으로 인해 특정 파일 시스템의 존재를 숨겨야 하는 경우\(그 안에 있는 모든 데이터와는 반대로\) 서버는 서버 네임스페이스에 있는 공유 리소스의 보안 정책을 리소스의 상위 구성 요소에 적용할 수 있습니다. 예를 들어:

```text
           /                           (place holder/not exported)
           /a/b                        (file system 1)
           /a/b/MySecretProject        (file system 2)
```

/a/b/MySecretProject 디렉터리는 실제 파일 시스템이며 공유 리소스입니다. /a/b/ MySecretProject에 대한 보안 정책이 무결성을 갖춘 Kerberos이고 이 파일 시스템의 존재에 대한 지식을 제한하는 것이 바람직하다고 가정합니다. 이 경우 서버는 /a/b에도 동일한 보안 정책을 적용해야 합니다. 이를 통해 필요할 때 보안을 유지할 파일 시스템의 존재 여부를 알 수 있습니다.

서버 리소스에서 여러 개의 분리된 보안 메커니즘을 사용하는 경우 이러한 종류의 정책을 적용하면 보안 방식을 사용하여 더 높은 수준의 파일 시스템에 액세스할 수 없게 됩니다. 따라서 이러한 종류의 구성은 서로 분리된 여러 보안 특성 세트를 사용하여 클라이언트로부터 존재\(내용이 아닌\)를 숨기는 것과 호환되지 않습니다.

다른 상황에서는 서버 이름 공간에 있는 특정 개체의 보안에 모든 직계 자손의 모든 보안 메커니즘을 통합하는 것이 바람직한 정책입니다. 강력한 보안 요구 사항이 달리 지정되지 않는 한 일반적이고 편리한 방법은 모든 유효한 보안 메커니즘에서 전체 의사 파일 시스템에 액세스할 수 있도록 만드는 것입니다.

네트워크의 데이터 보안이 우려되는 경우 클라이언트는 중간자 공격을 방지하기 위해 강력한 보안 메커니즘을 사용하여 의사 파일 시스템에 액세스해야 합니다.

---
## **8.  State Management**

NFS 프로토콜에 잠금을 통합하면 반드시 상태 저장이 가능해집니다. 공유 예약, 파일 및 디렉터리 위임, 호출 가능한 레이아웃, 필수 바이트 범위 잠금 지원과 같은 기능이 포함되어 프로토콜은 NFS와 NLM\(Network Lock Manager\)의 전통적인 조합보다 적절한 상태 관리에 훨씬 더 의존하게 됩니다. \) \[54\]. 이러한 기능에는 클라이언트 간 제외를 어느 정도 제공하는 확장된 잠금 기능이 포함되어 있지만 상태는 무상태 모델을 사용하여 쉽게 제공할 수 없는 기능도 제공합니다. 이 상태를 관리 가능하게 만드는 데는 세 가지 구성 요소가 있습니다.

\* 클라이언트와 서버 간의 명확한 구분

\* 클라이언트와 서버 사이의 상태 불일치를 안정적으로 감지하는 능력

\* 간단하고 강력한 복구 메커니즘

이 모델에서는 서버가 상태 정보를 소유합니다. 클라이언트는 잠금 변경을 요청하고 서버는 변경된 내용으로 응답합니다. 클라이언트가 시작하지 않은 잠금 상태 변경은 자주 발생하지 않습니다. 클라이언트는 이러한 변경 사항에 대한 즉각적인 알림을 받고 서버의 변경 사항을 반영하도록 잠금 상태 보기를 조정할 수 있습니다.

서버에서 생성되어 요청 시 클라이언트에 전달되는 개별 상태 조각은 128비트 상태 ID로 표시됩니다. 이러한 상태 ID는 특정 열린 파일, 특정 소유자가 보유한 바이트 범위 잠금 세트 또는 특정 방법이나 특정 위치에서 파일에 액세스하기 위한 회수 가능한 권한 위임을 나타낼 수 있습니다.

모든 경우에 클라이언트 전체를 나타내는 가장 일반적인 정보에서 대부분의 클라이언트 및 서버 잠금 상호 작용에 사용되는 최종 경량 상태 ID로 전환됩니다. 이 전환의 세부정보는 개체 유형에 따라 다르지만 항상 클라이언트 ID로 시작됩니다.

---
### **8.1.  Client and Session ID**

클라이언트는 파일 객체에 대한 레이아웃 열기, 바이트 범위 잠금, 위임 또는 획득을 위한 작업을 수행하기 전에 클라이언트 ID\(섹션 2.4 참조\)와 하나 이상의 세션 ID\(섹션 2.10 참조\)를 설정해야 합니다. 각 세션 ID는 특정 클라이언트 ID와 연결되므로 NFSv4.1 클라이언트에 대한 간략한 참조 역할을 합니다.

일부 유형의 잠금 상호 작용의 경우 클라이언트는 일반적으로 클라이언트 내부 프로세스에 해당하는 "소유자"라고 하는 내부 잠금 엔터티 수를 나타냅니다. 위임 및 레이아웃과 같은 다른 유형의 잠금 관련 개체의 경우 이러한 중간 엔터티가 제공되지 않으며 잠금 관련 개체는 서버와 단일 클라이언트 간에 직접 전송되는 것으로 간주됩니다.

---
### **8.2.  Stateid Definition**

서버가 모든 유형의 잠금\(열기, 바이트 범위 잠금, 위임 및 레이아웃 포함\)을 허용하면 동일한 파일에 대한 잠금 세트\(종종 단일 잠금\)를 나타내는 고유한 상태 ID로 응답합니다. 유형을 지정하고 동일한 소유권 특성을 공유합니다. 따라서 서로 다른 공개 소유자가 동일한 파일을 열면 각각 식별 가능한 상태 ID가 있습니다. 마찬가지로, 특정 잠금 소유자가 소유한 파일의 각 바이트 범위 잠금 세트에는 고유한 식별 상태 ID가 있습니다. 위임 및 레이아웃에는 참조할 수 있는 관련 상태 ID도 있습니다. stateid는 잠금 또는 잠금 세트에 대한 간략한 참조로 사용되며, stateid가 주어지면 서버는 연관된 상태 소유자 또는 상태 소유자\(공개 소유자/잠금 소유자 쌍의 경우\)를 결정할 수 있습니다. 연관된 파일 핸들. stateid를 사용하는 경우 현재 파일 핸들은 해당 stateid와 연결된 핸들이어야 합니다.

특정 클라이언트 ID와 연관된 모든 stateid는 해당 stateid의 청구를 나타내는 공통 임대와 서버에서 유지 관리하기 위해 나타내는 객체와 연관됩니다. 임대에 대한 논의는 섹션 8.3을 참조하십시오.

서버는 서로 다른 클라이언트에 독립적으로 상태 ID를 할당할 수 있습니다. 한 클라이언트에 대해 동일한 비트 패턴을 가진 stateid는 다른 클라이언트에 대해 완전히 다른 잠금 세트를 지정할 수 있습니다. stateid는 항상 현재 세션과 연결된 클라이언트 ID와 관련하여 해석됩니다. Stateid는 지정된 클라이언트 ID와 연결된 모든 세션에 적용되며 클라이언트는 동일한 클라이언트 ID와 연결된 다른 세션의 한 세션에서 얻은 stateid를 사용할 수 있습니다.

---
#### **8.2.1.  Stateid Types**

특별한 상태 ID\(8.2.3절 참조\)를 제외하고 각 상태 ID는 NFSv4.1 프로토콜에 의해 정의된 유형 세트 중 하나의 잠금 객체를 나타냅니다. 보증에 관해 언급한 이러한 모든 경우에는 클라이언트 재시작이나 잠금 취소와 같은 상황이 있어 보증이 무효화될 수 있다는 점에 유의하세요.

\* 상태 ID는 파일 열기를 나타낼 수 있습니다.

- 이 경우 각 stateid는 지정된 클라이언트 ID/open-owner/filehandle 트리플에 대한 OPEN 상태를 나타냅니다. 이러한 stateid는 업그레이드 및 OPEN\_DOWNGRADE 작업을 초래하는 OPEN에 대한 응답으로 변경될 수 있습니다\(결과적으로 stateid의 seqid가 증가함\).

\* Stateid는 바이트 범위 잠금 세트를 나타낼 수 있습니다.

- 특정 소유자가 특정 파일에 대해 보유하고 특정 열린 파일의 보호를 받는 모든 잠금은 LOCK 및 LOCKU 작업이 해당 잠금 세트에 영향을 미칠 때마다 증가되는 seqid를 갖는 단일 상태 ID와 연결됩니다.

\* Stateid는 파일 위임을 나타낼 수 있습니다. 이는 위임이 반환될 때까지 다른 클라이언트가 특정 파일을 참조하거나 수정하지 않는다는 것을 서버가 클라이언트에 대해 상기할 수 있는 보증입니다. NFSv4.1에서는 일반 파일과 비정규 파일 모두에 대해 파일 위임을 얻을 수 있습니다.

- stateid는 특정 파일 핸들에 대해 클라이언트가 보유한 단일 위임을 나타냅니다.

\* 상태 ID는 위임이 반환될 때까지 다른 클라이언트가 디렉터리를 수정하지 않을 것임을 서버가 클라이언트에 대해 상기할 수 있는 보장인 디렉터리 위임을 나타낼 수 있습니다.

- stateid는 특정 디렉터리 파일 핸들에 대해 클라이언트가 보유한 단일 위임을 나타냅니다.

\* Stateid는 특정 파일이 특정 위치에서 대체 데이터 액세스 프로토콜을 통해 액세스될 수 있음을 서버가 클라이언트에 대해 회상할 수 있는 보증인 레이아웃을 나타낼 수 있습니다. 이러한 액세스는 특정 바이트 범위 세트로 제한되며 해당 바이트 범위가 줄어들거나 레이아웃이 반환될 때까지 계속될 수 있습니다.

- stateid는 주어진 레이아웃 유형을 가진 특정 파일 핸들에 대해 특정 클라이언트가 보유하는 모든 레이아웃 세트를 나타냅니다. SEQID는 LAYOUTGET 및 LAYOUTRETURN과 같은 레이아웃 상태 ID 변경 작업을 통해 해당 바이트 범위 집합의 레이아웃이 변경됨에 따라 업데이트됩니다.

---
#### **8.2.2.  Stateid Structure**

Stateid는 두 개의 필드, 즉 특정 잠금 세트를 식별하는 96비트 "기타" 필드와 32비트 "seqid" 시퀀스 값으로 나뉩니다. 특별한 상태 ID\(섹션 8.2.3 참조\)의 경우를 제외하고 "기타" 필드의 특정 값은 동일한 유형의 잠금 세트\(예: 바이트 범위 잠금, 열기, 위임 또는 레이아웃\)를 나타냅니다. 특정 파일이나 디렉토리에 대해 동일한 소유권 특성을 공유합니다. seqid는 이러한 잠금 세트의 특정 인스턴스를 지정하고 세트에서 잠금을 추가하거나 삭제하거나 적용되는 바이트 범위의 변경을 통해 해당 잠금 세트의 변경 사항을 나타내기 위해 증가됩니다. 하나 이상의 잠금 유형의 업그레이드 또는 다운그레이드.

이러한 잠금 세트가 처음 생성되면 서버는 seqid 값이 1인 stateid를 반환합니다. 잠금 세트를 수정하는 후속 작업에서 서버는 동일한 상태 소유자/파일/유형 조합에 대한 stateid를 반환하고 실제로 잠금 세트에 일부 변경이 있을 때마다 "seqid" 필드를 1씩 증가시켜야 합니다. 지정. 이 경우 서버는 이전에 해당 상태 소유자/파일/유형 조합에 사용된 것과 동일한 "기타" 필드와 함께 "seqid" 필드가 증가된 상태 ID를 반환합니다. 이 패턴은 seqid가 NFS4\_UINT32\_MAX를 지나 증가하고 1\(0이 아님\)이 다음 seqid 값이 될 때까지 계속됩니다.

seqid를 증가시키는 목적은 서버가 stateid와 관련된 잠금 상태를 수정하는 작업이 처리된 순서를 클라이언트에 전달할 수 있도록 하고 클라이언트가 seqid에 대한 조건부 요청을 보낼 수 있도록 하는 것입니다. 문제의 stateid가 반환된 이후 변경되지 않은 잠금 집합입니다.

레이아웃 상태 ID\(12.5.3절\)를 제외하고 클라이언트가 서버에 상태 ID를 보낼 때 전송된 seqid와 관련하여 두 가지 선택 사항이 있습니다. 해당 stateid의 "other" 필드에 대한 최신 seqid가 사용되기를 원한다는 것을 서버에 나타내기 위해 seqid를 0으로 설정할 수 있습니다. 이는 READ 또는 WRITE 작업과 함께 전송된 stateid의 경우 일반적인 선택입니다. 또한 0이 아닌 값을 설정할 수도 있으며, 이 경우 서버는 해당 seqid가 올바른지 확인합니다. 이 경우 서버는 seqid가 최신 값보다 낮으면 NFS4ERR\_OLD\_STATEID를 반환하고, seqid가 최신 값보다 크면 NFS4ERR\_BAD\_STATEID를 반환해야 합니다. 이는 CLOSE 또는 OPEN\_DOWNGRADE와 함께 전송된 상태 ID의 경우 일반적인 선택입니다. OPEN은 동일한 소유자에 대해 병렬로 전송될 수 있으므로 클라이언트는 서버에서 OPEN 업그레이드를 수행했다는 사실을 모르고 문제의 잠금을 변경하여 파일을 닫을 수 있습니다. CLOSE가 0 seqid와 함께 전송되면 클라이언트가 업그레이드가 발생했다는 표시를 받기 전에 OPEN 업그레이드가 취소됩니다.

콜백 작업의 일부로 서버에서 클라이언트로 stateid를 전송하는 경우 현재 seqid를 확인하고 NFS4ERR\_OLD\_STATEID를 반환하지 않습니다. 이는 클라이언트가 최신 seqid를 알 수 있는 위치에 있지 않아 이를 확인할 수 없기 때문입니다. 특별히 언급하지 않는 한 서버가 콜백의 일부로 클라이언트에 보낸 stateid의 seqid 값은 0이어야 하며 그렇지 않은 경우 NFS4ERR\_BAD\_STATEID가 반환됩니다.

작업 순서를 결정하는 클라이언트와 NFS4ERR\_OLD\_STATEID가 반환될지 여부를 결정하는 서버에 의해 seqid를 비교할 때 NFS4\_UINT32\_MAX 값을 지나서 seqid가 교체될 가능성을 고려해야 합니다. 두 개의 seqid 값을 비교할 때 현재 클라이언트와 연결된 모든 세션의 총 슬롯 수가 이를 수행하는 데 사용됩니다. 하나의 seqid 값이 이 총 슬롯 수보다 작고 다른 seqid 값이 NFS4\_UINT32\_MAX에서 총 슬롯 수를 뺀 값보다 큰 경우 전자는 숫자상으로 더 크다는 사실에도 불구하고 후자보다 낮은 것으로 처리됩니다.

---
#### **8.2.3.  Special Stateids**

"기타" 필드가 모두 0이거나 모두 1인 Stateid 값은 예약되어 있습니다. 이는 서버에 의해 할당되지 않을 수 있지만 프로토콜에 의해 정의된 특별한 의미를 갖습니다. 특별한 의미는 "other" 필드가 모두 0인지 아니면 모두 1인지 여부와 "seqid" 필드의 특정 값에 따라 달라집니다.

NFSv4.1에는 "other"와 "seqid"의 다음 조합이 정의되어 있습니다.

\* "other"와 "seqid"가 모두 0인 경우 stateid는 요청과 관련된 OPEN 상태가 없음을 나타내기 위해 READ, WRITE 및 SETATTR 요청에 사용할 수 있는 특별한 익명 stateid로 처리됩니다. 익명의 stateid 값이 사용되고 기존 열기가 요청된 액세스 형식을 거부하면 해당 요청에 대한 액세스가 거부됩니다. 이 stateid는 데이터 서버에 대한 작업에 사용되어서는 안 됩니다\(섹션 13.6\).\(MUST NOT\)

\* "other"와 "seqid"가 모두 1인 경우 stateid는 특수 READ 우회 stateid입니다. 이 값이 WRITE 또는 SETATTR에 사용되면 익명 값처럼 처리됩니다. READ에서 사용될 때 서버는 일반적으로 READ 작업에 대한 액세스가 거부되더라도 액세스를 허용할 수 있습니다. 이 상태 ID는 데이터 서버에 대한 작업에 사용되어서는 안 됩니다.\(MAY, MUST NOT\)

\* "other"가 0이고 "seqid"가 1인 경우 stateid는 현재 stateid를 나타내며, 이는 COMPOUND 내의 작업에서 반환된 마지막 stateid 값입니다. OPEN의 경우 위임이 아닌 열린 파일에 대해 반환된 stateid가 사용됩니다. 특수 값 대신 작업에 전달된 stateid의 "seqid" 값은 0으로 설정됩니다. 단, 현재 stateid가 CLOSE 또는 OPEN\_DOWNGRADE 작업에서 사용되는 경우는 제외됩니다. stateid 값을 반환한 COMPOUND에 작업이 없으면 서버는 NFS4ERR\_BAD\_STATEID 오류를 반환해야 합니다. 그림 6에 표시된 것처럼 현재 stateid 값이 특수 stateid이고 작업 인수의 stateid에 "other"가 0으로 설정되고 "seqid"가 1로 설정된 경우 서버는 NFS4ERR\_BAD\_STATEID 오류를 반환해야 합니다.\(MUST, MUST\)

\* "other"가 0이고 "seqid"가 NFS4\_UINT32\_MAX인 경우 stateid는 유효하지 않은 것으로 정의된 예약된 stateid 값을 나타냅니다. 이 stateid가 사용되면 서버는 NFS4ERR\_BAD\_STATEID 오류를 반환해야 합니다.\(MUST\)

"기타" 필드에 모두 0 또는 모두 1이 있지만 위의 경우 중 하나와 일치하지 않는 stateid 값이 사용되는 경우 서버는 NFS4ERR\_BAD\_STATEID 오류를 반환해야 합니다.\(MUST\)

다른 상태 ID와 달리 특수 상태 ID는 개별 클라이언트 ID 또는 파일 핸들과 연결되지 않으며 모든 유효한 클라이언트 ID 및 파일 핸들과 함께 사용할 수 있습니다. 현재 stateid를 지정하는 특수 stateid의 경우 특수 stateid를 대체하는 현재 stateid 값은 특정 클라이언트 ID 및 파일 핸들과 연결되므로 현재 파일 핸들이 현재와 연결된 것과 일치하지 않는 경우 사용됩니다. stateid, stateid가 전달된 작업은 NFS4ERR\_BAD\_STATEID를 반환합니다.

---
#### **8.2.4.  Stateid Lifetime and Validation**

Stateid는 클라이언트가 다시 시작되거나 서버가 다시 시작될 때까지 또는 클라이언트가 CLOSE 또는 DELEGRETURN과 같은 작업을 통해 stateid와 관련된 모든 잠금을 반환할 때까지 유효한 상태로 유지되어야 합니다. 해지로 인해 잠금이 손실된 경우 클라이언트 ID가 유효한 한 stateid는 클라이언트가 FREE\_STATEID를 사용하여 잠금을 해제할 때까지 해당 해지된 상태의 유효한 지정으로 유지됩니다. 바이트 범위 잠금과 관련된 Stateid는 예외입니다. LOCKU가 남아 있는 모든 잠금을 해제하더라도 클라이언트가 FREE\_STATEID 작업을 통해 상태 ID를 해제하지 않는 한 연결된 열려 있는 파일이 열려 있는 한 유효한 상태로 유지됩니다.

클라이언트가 반환을 요청하지 않고도 클라이언트의 잠금이 무효화되는 상황이 있다는 점에 유의해야 합니다. 여기에는 임대 만료 및 임대 기간 내의 다양한 형태의 잠금 취소가 포함됩니다. 이러한 상황에서는 stateid가 유효한 상태로 유지되며 클라이언트는 이를 사용하여 관련된 손실된 잠금의 처리를 결정할 수 있다는 점에 유의하는 것이 중요합니다.

"기타" 값은 단일 클라이언트 ID의 컨텍스트 내에서 다른 목적\(예: 다른 파일 핸들, 소유자 또는 잠금 유형\)으로 재사용되어서는 안 됩니다. 서버는 해제될 수 있는 지점을 넘어 동일한 목적으로 "기타" 값을 유지할 수 있지만, 그렇게 하는 경우 이전 값과 "seqid" 연속성을 유지해야 합니다.

서버가 유효하지 않고 오래된 stateid를 인식해야 한다는 요구 사항을 충족하는 데 사용할 수 있는 메커니즘 중 하나는 서버가 stateid의 "기타" 필드를 두 개의 필드로 나누는 것입니다.

\* 잠금 상태 구조 테이블에 대한 인덱스입니다.

\* 특정 용도로 테이블 항목을 할당할 때마다 증가하는 세대 번호입니다.

그런 다음 각 테이블 항목에 저장합니다.

\* stateid가 연결된 클라이언트 ID입니다.

\* 이 인덱스 값을 공유하는 \(최대 1개\) 유효한 stateid에 대한 현재 세대 번호입니다.

\* 잠금이 수행된 파일의 파일 핸들입니다.

\* 상태 ID 유형 표시\(공개, 바이트 범위 잠금, 파일 위임, 디렉토리 위임, 레이아웃\).

\* 현재 "기타" 값에 해당하는 마지막 "seqid" 값이 반환됩니다.

\* 이 stateid와 관련된 잠금의 현재 상태 표시, 특히 이것이 취소되었는지 여부와 그렇다면 그 이유는 무엇입니까?

이 정보를 사용하면 수신 stateid를 검증할 수 있으며 필요한 경우 적절한 오류가 반환됩니다. 특수 및 비특수 상태 ID는 별도로 처리됩니다. \(특별한 상태에 대한 논의는 섹션 8.2.3을 참조하십시오.\)

stateid는 현재 세션과 연결된 클라이언트 ID에서 파생된 현재 클라이언트 ID에 의해 암시적으로 한정됩니다. 그러나 세션의 의미는 이전 클라이언트 또는 서버 인스턴스와 연관된 상태 ID가 이 절차에 의해 분석되는 것을 방지한다는 점에 유의하십시오.

서버를 다시 시작해 잘못된 클라이언트 ID 또는 잘못된 세션 ID가 발생한 경우 SEQUENCE는 오류를 반환하고 stateid를 인수로 사용하는 작업은 처리되지 않습니다.

영구 세션이 있는 서버가 다시 시작되고 모든 임대 상태가 손실된 경우 해당 세션은 유효하더라도 죽은 것으로 표시되며 응답 캐시를 통해 충족되지 않은 모든 작업은 NFS4ERR\_DEADSESSION 오류가 발생하여 아래와 같이 처리되지 않습니다.

stateid가 테스트되고 "other" 필드가 모두 0 또는 모두 1인 경우 "other" 및 "seqid" 필드가 특수 stateid에 대해 정의된 조합과 일치하는지 확인하고 결과는 다음과 같이 결정됩니다.

\* "other" 및 "seqid" 필드가 정의된 필드와 일치하지 않는 경우

- 특수 stateid와 연관된 조합인 경우 NFS4ERR\_BAD\_STATEID 오류가 반환됩니다.

\* 특수 stateid가 현재 stateid를 지정하는 것이고 현재 stateid가 있는 경우 특수 stateid를 현재 stateid로 대체하고 비특수 stateid에 해당하는 검사를 수행합니다.

\* 조합이 일반적으로 유효하지만 stateid가 사용되는 컨텍스트에 적합하지 않은 경우\(예: LOCK 작업에서 OPEN stateid가 필요할 때 모두 0인 stateid가 사용되는 경우\) NFS4ERR\_BAD\_STATEID 오류도 반환됩니다.

\* 그렇지 않으면 확인이 완료되고 특수한 stateid가 유효한 것으로 승인됩니다.

stateid가 테스트 중이고 "other" 필드가 모두 0도 아니고 모두 1도 아닌 경우 다음 절차를 사용하여 들어오는 stateid를 검증하고 필요한 경우 "other" 필드가 다음과 같다고 가정하여 적절한 오류를 반환할 수 있습니다. 테이블 인덱스와 엔트리 생성으로 나누어집니다.

\* 테이블 인덱스 필드가 연관된 테이블의 범위를 벗어나면 NFS4ERR\_BAD\_STATEID를 반환한다.

\* 선택한 테이블 항목이 수신 stateid에 지정된 것과 다른 세대인 경우 NFS4ERR\_BAD\_STATEID를 반환합니다.

\* 선택한 테이블 항목이 현재 파일 핸들과 일치하지 않으면 NFS4ERR\_BAD\_STATEID를 반환합니다.

\* 테이블 항목의 클라이언트 ID가 현재 세션과 연결된 클라이언트 ID와 일치하지 않는 경우 NFS4ERR\_BAD\_STATEID를 반환합니다.

\* stateid가 취소된 상태를 나타내는 경우 반환

- NFS4ERR\_EXPIRED, NFS4ERR\_ADMIN\_REVOKED 또는 NFS4ERR\_DELEG\_REVOKED\(해당하는 경우\)

\* stateid 유형이 해당 stateid가 나타나는 컨텍스트에 대해 유효하지 않은 경우 NFS4ERR\_BAD\_STATEID를 반환합니다. stateid는 TEST\_STATEID 작업에 의해 보고되는 것처럼 일반적으로 유효할 수 있지만 특정 작업\(예: 바이트 범위 잠금을 나타내지 않는 stateid가 비-상태에 전달되는 경우\)에는 유효하지 않을 수 있습니다. from\_open LOCK 또는 LOCKU의 경우, 또는 열기를 나타내지 않는 stateid가 CLOSE 또는 OPEN\_DOWNGRADE로 전달되는 경우. 이러한 경우 서버는 NFS4ERR\_BAD\_STATEID를 반환해야 합니다.\(MUST\)

\* "seqid" 필드가 0이 아니고 현재 "other" 필드에 해당하는 현재 시퀀스 값보다 큰 경우 NFS4ERR\_BAD\_STATEID를 반환합니다.

\* "seqid" 필드가 0이 아니고 현재 "other" 필드에 해당하는 현재 시퀀스 값보다 작은 경우 NFS4ERR\_OLD\_STATEID를 반환합니다.

\* 그렇지 않은 경우 stateid는 유효하며 테이블 항목에는 stateid 유형에 대한 추가 정보 및 관련 잠금 세트\(예: 개방 소유자 및 잠금 소유자 정보\)와 같은 특정 유형의 stateid와 관련된 정보가 포함되어야 합니다. 개방 모드 및 바이트 범위와 같은 특정 잠금에 대한 정보도 포함됩니다.

---
#### **8.2.5.  Stateid Use for I/O Operations**

I/O 작업을 수행하는 클라이언트는 클라이언트가 보유한 잠금\(열기 및 위임 포함\)과 I/O 요청을 보내는 다양한 유형의 상태 소유자를 기반으로 적절한 stateid를 선택해야 합니다. 이 점에서 파일 크기를 변경하는 SETATTR 작업은 I/O 작업처럼 처리됩니다.

우선순위가 낮은 순서대로 적용되는 다음 규칙은 적절한 stateid 선택을 관리합니다. 이러한 규칙을 따르면 클라이언트는 적절한 작업 응답이나 콜백을 통해 실제로 알림을 받은 잠금만 고려합니다. 파일 레이아웃이 사용되는 경우 데이터 서버에 대한 I/O의 경우 규칙이 약간 다르다는 점에 유의하십시오\(섹션 13.9.1 참조\).

\* 클라이언트가 문제의 파일에 대한 위임을 보유한 경우 위임 stateid를 사용해야 합니다.\(SHOULD\)

\* 그렇지 않고, I/O를 보내는 잠금 소유자\(예: 프로세스\)에 해당하는 엔터티가 연관된 열린 파일에 대한 바이트 범위 잠금 상태 ID를 갖는 경우 해당 잠금 소유자 및 열기에 대한 바이트 범위 잠금 상태 ID 파일을 사용해야 합니다.\(SHOULD\)

\* 바이트 범위 잠금 상태 ID가 없으면 문제의 열린 파일에 대한 OPEN 상태 ID를 사용해야 합니다.\(SHOULD\)

\* 마지막으로, 위의 사항 중 어느 것도 적용되지 않으면 특별한 stateid를 사용해야 합니다.\(SHOULD\)

이러한 규칙을 무시하면 서버에 요청을 적절하게 처리하는 데 필요한 정보가 없는 상황이 발생할 수 있습니다. 예를 들어, 필수 바이트 범위 잠금이 적용될 때 stateid가 잠금 stateid를 통해 적절한 잠금 소유자를 나타내지 않으면 요청이 거부될 수 있습니다.

그러나 서버는 이러한 순서 규칙을 적용하려고 시도해서는 안 되며 I/O 요청을 적절하게 처리하기 위해 사용 가능한 모든 정보를 사용해야 합니다. 특히, 클라이언트가 특정 파일에 대한 위임을 갖고 있는 경우 요청이 특수한 상태 ID와 함께 전송되더라도 요청을 처리할 때 이 사실을 기록해야 합니다.\(SHOULD\)

---
#### **8.2.6.  Stateid Use for SETATTR Operations**

각 작업은 세션 ID와 연결되어 있고 이를 통해 클라이언트 ID를 확인할 수 있으므로 서버가 위임을 회수해야 하는지 또는 완료된 것으로 처리해야 하는지 여부를 결정할 수 있도록 작업에 상태 ID를 포함할 필요가 없습니다. 위임 범위 내에서.

SETATTR 작업의 경우 stateid가 존재합니다. 파일 크기를 설정하는 경우가 아닌 경우 클라이언트는 특수한 상태 ID를 보내거나 해당 파일에 대한 위임이 보류된 경우 위임 상태 ID를 보낼 수 있습니다. 서버는 stateid를 검증해야 하며 위임 보유 여부에 대한 결정을 최적화하기 위해 stateid를 사용할 수 있지만 특수 stateid가 전송될 때에도 위임의 존재를 기록해야 하며 전송 시 유효한 위임 stateid를 수락해야 합니다\(MUST\).\(MUST\)

---
### **8.3.  Lease Renewal**

클라이언트 ID로 표시되는 각 클라이언트/서버 쌍에는 단일 임대가 있습니다. 임대의 목적은 클라이언트가 낮은 오버헤드 방식으로 서버가 활성 상태임을 서버에 표시하여 서버가 클라이언트의 잠금을 유지하도록 하는 것입니다. 이 배열을 사용하면 관련 임대가 만료되면 충돌이 발생했거나 다른 방식으로 연결할 수 없는 클라이언트가 보유하고 있는 오래된 잠금 관련 개체를 서버에서 제거할 수 있습니다. 그러면 다른 클라이언트는 비활성이거나 연결할 수 없는 클라이언트로 인해 무기한 지연되지 않고 충돌하는 잠금을 얻을 수 있습니다. 이는 캐시 일관성을 위한 메커니즘이 아니며 임대 간격이 만료되지 않은 경우 임대 갱신이 거부되지 않을 수 있습니다.

각 세션은 특정 클라이언트\(클라이언트의 클라이언트 ID로 식별됨\)와 연결되어 있으므로 해당 세션에서 전송된 모든 작업은 연결된 클라이언트에 연결할 수 있음을 나타냅니다. 특정 세션에 대해 요청이 전송되면 만료되지 않은 임대에 대한 SEQUENCE 작업의 성공적인 실행\(또는 응답 캐시에서 SEQUENCE 결과 검색\)이 성공하면 표준 갱신 기간\(동일\) 동안 임대가 암시적으로 갱신됩니다. Lease\_time 속성에 추가\).

서버가 SEQUENCE 작업을 수신할 때 클라이언트 ID의 임대가 만료되지 않은 경우 서버는 임대를 갱신해야 합니다. 서버가 SEQUENCE 작업을 수신할 때 클라이언트 ID의 임대가 만료된 경우 서버는 임대를 갱신할 수 있습니다. 이는 클라이언트가 만료 전에 임대를 갱신하지 못해 취소된 상태가 있는지 여부에 따라 달라집니다.\(MUST, MAY\)

임대를 갱신하는 다른 활동이 없으면 단일 SEQUENCE 작업으로 구성된 COMPOUND로 충분합니다. 클라이언트는 또한 통신 관련 지연을 고려하고 갱신 메시지가 실제로 적시에 서버에 도달하도록 조치를 취해야 합니다. 예를 들어:

\* 트렁킹이 적용되는 경우 클라이언트는 해당 연결 중 하나에 사용되는 경로가 차단되는 경우에도 갱신이 발생하도록 서로 다른 연결에서 여러 요청을 보내는 것을 고려해야 합니다.

\* 전송 재전송 지연은 임대 기간에 근접하거나 초과할 정도로 커질 수 있습니다. 재시작으로 인해 서버가 응답하지 않을 때 특히 그럴 가능성이 높습니다. 섹션 8.4.2.1을 참조하십시오. 클라이언트 구현이 주의되지 않으면 전송 재전송 지연으로 인해 유예 기간이 끝나기 전에 클라이언트가 서버 다시 시작을 감지하지 못할 수 있습니다. 시나리오에서는 클라이언트가 지수 백오프가 있는 전송을 사용하여 최대 재전송 제한 시간이 유예 기간과 Lease\_time 속성을 모두 초과하는 것입니다. 네트워크 파티션으로 인해 클라이언트 연결의 재전송 간격이 백오프되고, 파티션이 복구된 후에도 서버가 다시 시작되고 유예 기간이 끝난 후에 다음 전송 수준 재전송이 전송됩니다.

- 클라이언트는 계속되는 NFS4ERR\_NO\_GRACE 오류에서 복구해야 합니다. 또는 Lease\_time을 초과하는 전송 수준 재전송 간격에도 불구하고 만료 전에 임대를 갱신하는 SEQUENCE 작업이 전송되도록 해야 합니다. 클라이언트는 새 연결을 세션과 연결하고 해당 연결에 SEQUENCE 작업을 보내 이를 수행할 수 있습니다. 그러나 새로운 연결 설정 시도가 어떤 이유로 지연되는 경우\(예: 연결 설정 패킷의 기하급수적 백오프\) 클라이언트는 임대가 만료되기 전에 연결 설정 시도를 중단하고 다시 연결을 시도해야 합니다.\(MUST\)

서버가 SEQUENCE 작업을 수신한 후 임대를 갱신하는 경우 서버는 COMPOUND 프로시저 요청의 나머지 작업이 계속 실행되는 동안 임대가 만료되는 것을 허용해서는 안 됩니다. 마지막 작업이 완료되고 COMPOUND에 대한 응답이 전송되면 서버는 현재 시간과 Lease\_time 속성 값의 합보다 빨리 만료되도록 임대를 설정해야 합니다.\(MUST NOT, MUST\)

클라이언트 ID의 임대는 마지막 임대 갱신 SEQUENCE 작업이 클라이언트 ID의 세션 중 하나에서 전송된 이후 최소 임대 간격\(lease\_time\) 이상이고 해당 세션에 활성 COMPOUND 작업이 없는 경우 만료될 수 있습니다.

SEQUENCE 작업은 임대를 갱신하는 기본 메커니즘이고 각 임대 기간에 대해 적어도 한 번 수행되어야 하기 때문에 클라이언트가 임대 상태의 변경 사항을 서버에서 클라이언트에 알리는 자연스러운 메커니즘입니다. 통보받다. 클라이언트는 시퀀스에 의해 반환된 상태 플래그\(sr\_status\_flags\)를 검사하고 적절한 조치를 취해야 합니다\(자세한 내용은 섹션 18.46.3 참조\).

\* 상태 비트 SEQ4\_STATUS\_CB\_PATH\_DOWN 및

- SEQ4\_STATUS\_CB\_PATH\_DOWN\_SESSION은 클라이언트가 콜백 요청을 수신하기 위해 해결해야 할 수 있는 백채널 문제를 나타냅니다.

\* 상태 비트 SEQ4\_STATUS\_CB\_GSS\_CONTEXTS\_EXPIRING 및

- SEQ4\_STATUS\_CB\_GSS\_CONTEXTS\_EXPIRED는 콜백 요청 전송을 허용하기 위해 클라이언트가 해결해야 할 수 있는 백채널에 대한 GSS 컨텍스트 또는 RPCSEC\_GSS 핸들 관련 문제를 나타냅니다.

\* 상태 비트 SEQ4\_STATUS\_EXPIRED\_ALL\_STATE\_REVOKED,

- SEQ4\_STATUS\_EXPIRED\_SOME\_STATE\_REVOKED, SEQ4\_STATUS\_ADMIN\_STATE\_REVOKED 및 SEQ4\_STATUS\_RECALLABLE\_STATE\_REVOKED는 클라이언트에 잠금 취소 이벤트를 알립니다. 이러한 비트가 설정되면 클라이언트는 TEST\_STATEID를 사용하여 어떤 stateid가 취소되었는지 찾고 FREE\_STATEID를 사용하여 관련 상태의 손실을 확인해야 합니다.

\* 상태 비트 SEQ4\_STATUS\_LEASE\_MOVE는 다음을 나타냅니다.

- 임대 갱신에 대한 책임이 하나 이상의 새 서버로 이전되었습니다.

\* 상태 비트 SEQ4\_STATUS\_RESTART\_RECLAIM\_NEEDED는 서버 재시작으로 인해 클라이언트가 잠금 상태를 회복해야 함을 나타냅니다.

\* 상태 비트 SEQ4\_STATUS\_BACKCHANNEL\_FAULT는 서버가 백채널에서 복구할 수 없는 오류를 발견했음을 나타냅니다\(예: 백채널에 있는 슬롯의 시퀀스 ID 추적이 손실됨\).

---
### **8.4.  Crash Recovery**

충돌 복구의 중요한 요구 사항은 클라이언트와 서버 모두 상대방이 언제 실패했는지 알 수 있어야 한다는 것입니다. 또한 클라이언트는 서버를 다시 시작해도 일관된 데이터 보기를 볼 수 있어야 합니다. 클라이언트 또는 네트워크 버퍼 내에서 대기열에 있을 수 있는 모든 읽기 및 쓰기 작업은 클라이언트가 읽기 및 쓰기 작업을 보호하는 잠금을 성공적으로 복구할 때까지 기다려야 합니다. 클라이언트가 이러한 작업을 안전하게 처리할 수 있을 만큼 충분한 잠금 상태를 복구했는지 서버가 안전하게 판단하기 전에 서버에 도달하는 모든 작업은 거부되어야 합니다. 이는 다음 중 하나 때문에 발생합니다.

\* 표시된 상태는 현재 유효하지 않은 클라이언트 ID와 연결되어 있으므로 더 이상 유효하지 않습니다. 이 경우 클라이언트는 NFS4ERR\_BADSESSION 또는 NFS4ERR\_DEADSESSION 오류를 수신하게 되며 해당 잘못된 클라이언트 ID에 새 세션을 연결하려고 시도하면 NFS4ERR\_STALE\_CLIENTID 오류가 발생합니다.

\* 후속 잠금 복구로 인해 작업 실행이 부적절해질 수 있습니다\(NFS4ERR\_GRACE\).

---
#### **8.4.1.  Client Failure and Recovery**

클라이언트에 오류가 발생하는 경우 서버는 관련 임대가 만료되면 클라이언트의 잠금을 해제할 수 있습니다. 다른 클라이언트의 잠금 충돌은 이 임대 만료 후에만 부여될 수 있습니다. 섹션 8.3에서 설명한 대로 클라이언트가 실패하지 않고 만료가 발생하기 전에 임대를 다시 설정하면 충돌하는 잠금에 대한 요청이 승인되지 않습니다.

다시 시작 시 클라이언트 지연을 최소화하기 위해 잠금 요청은 클라이언트 제공 검증자에 의해 클라이언트 인스턴스와 연결됩니다. 이 검증자는 클라이언트가 수행한 초기 EXCHANGE\_ID 호출에서 전송된 client\_owner4의 일부입니다. 서버는 EXCHANGE\_ID 작업의 결과로 클라이언트 ID를 반환합니다. 그런 다음 클라이언트는 해당 클라이언트 ID와 연관된 세션을 설정하여 클라이언트 ID의 사용을 확인합니다\(이 작업이 수행되는 방법에 대한 설명은 섹션 18.36.3 참조\). 해당 클라이언트 ID를 사용하여 세션에서 얻은 열기, 바이트 범위 잠금, 위임 및 레이아웃을 포함한 모든 잠금은 해당 클라이언트 ID와 연결됩니다.

검증자는 초기화할 때마다 클라이언트에 의해 변경되므로 서버는 새 검증자를 현재 보유된 잠금과 관련된 검증자와 비교하여 일치하지 않는지 결정할 수 있습니다. 이는 클라이언트의 새로운 인스턴스화 및 잠금 상태의 후속 손실\(새 클라이언트 ID 확인 시\)을 나타냅니다. 결과적으로 서버는 이전 검증자에서 파생된 이전 클라이언트 ID와 연관된 모든 잠금을 자유롭게 해제할 수 있습니다. 이 시점에서 임대가 아직 만료되지 않은 동안 계속 대기 중인 다른 클라이언트의 잠금 충돌이 허용될 수 있습니다. 또한 이전 클라이언트 ID와 연결된 모든 상태 ID는 더 이상 참조할 수 없으므로 해제될 수도 있습니다.

검증자는 COMMIT 작업에 대한 검증자와 동일한 고유성 속성을 가지고 있어야 합니다.

---
#### **8.4.2.  Server Failure and Recovery**

서버가 잠금 상태를 잃으면\(일반적으로 다시 시작의 결과로\) 클라이언트가 이 사실을 발견하고 손실된 잠금 상태를 다시 설정할 시간을 허용해야 합니다. 서버가 다른 클라이언트에 충돌하는 액세스 권한을 부여했기 때문에 서버가 유효한 요청을 거부하지 않고도 클라이언트는 잠금 상태를 다시 설정할 수 있어야 합니다. 마찬가지로, 클라이언트가 아직 파일에 대한 잠금 상태를 재설정하지 않았고 그러한 잠금 상태로 인해 읽기 또는 쓰기 작업을 수행하는 것이 무효화될 가능성이 있는 경우. 예를 들어, 필수 잠금이 가능한 경우 서버는 해당 파일에 대한 읽기 및 쓰기 작업을 허용하지 않아야 합니다.

클라이언트는 여러 가지 방법을 통해 잠금 상태 손실이 발생했는지 확인할 수 있습니다.

1. SEQUENCE\(가장 일반적\) 또는 기타 연산이 반환되는 경우

- NFS4ERR\_BADSESSION, 이는 세션이 파괴되었지만 클라이언트 ID가 여전히 유효함을 의미할 수 있습니다. 클라이언트는 세션을 다시 설정하기 위해 클라이언트 ID와 함께 CREATE\_SESSION 요청을 보냅니다. NFS4ERR\_STALE\_CLIENTID로 인해 CREATE\_SESSION이 실패하는 경우 클라이언트는 CREATE\_SESSION 작업이 성공한 후\(섹션 8.4.2.1 참조\) 새 클라이언트 ID를 설정하고\(섹션 8.1 참조\) 새 클라이언트 ID로 잠금 상태를 다시 설정해야 합니다.

2. 영구 세션의 SEQUENCE\(가장 일반적인\) 또는 기타 작업이 NFS4ERR\_DEADSESSION을 반환하는 경우 이는 세션을 더 이상 새로운 작업, 즉 응답 캐시에서 충족되지 않는 작업에 사용할 수 없음을 나타냅니다. 보류 중인 모든 작업이 재시도 전에 수행되는지 여부가 결정되면 클라이언트는 클라이언트 ID와 함께 CREATE\_SESSION 요청을 보내 세션을 다시 설정합니다. NFS4ERR\_STALE\_CLIENTID로 인해 CREATE\_SESSION이 실패하는 경우 클라이언트는 새 클라이언트 ID\(섹션 8.1 참조\)를 설정하고 CREATE\_SESSION이 성공한 후 새 클라이언트 ID로 잠금 상태를 다시 설정해야 합니다\(섹션 8.4.2.1\).

3. SEQUENCE나 SEQUENCE가 선행되지 않는 작업\(예: CREATE\_SESSION, DESTROY\_SESSION\)이 NFS4ERR\_STALE\_CLIENTID를 반환하는 경우 클라이언트는 반드시 새 클라이언트 ID\(섹션 8.1\)를 설정하고 잠금 상태\(섹션 8.4.2.1\)를 다시 설정해야 합니다.\(MUST\)

---
##### **8.4.2.1.  State Reclaim**

서버 재시작으로 인해 상태 정보 및 관련 잠금이 손실된 경우 프로토콜은 해당 상태를 다시 설정하는 방법을 제공해야 합니다. 사용되는 접근 방식은 대부분의 잠금 상태 유형\(레이아웃은 예외\)에 대해 클라이언트가 이전 인스턴스에서 처음 얻은 잠금을 서버에 다시 설정하도록 허용하는 기능을 갖는 요청을 정의하는 것입니다. 일반적으로 이러한 요청은 해당 유형의 잠금을 생성하는 데 일반적으로 사용되는 요청의 변형이며 "재확보 유형" 요청이라고 하며 이러한 잠금을 다시 설정하는 프로세스를 "재확보"라고 합니다.

각 클라이언트는 다른 클라이언트에 충돌하는 잠금이 부여될 가능성 없이 자신이 갖고 있는 모든 잠금을 회수할 수 있는 기회를 가져야 하기 때문에 회수 프로세스에 "유예 기간"이 할당됩니다. 이 기간 동안 클라이언트 ID 및 세션 생성 요청은 정상적으로 처리되지만 잠금 요청에는 특별한 제한 사항이 적용됩니다. 서버가 그러한 잠금을 부여하는 것이 후속 재확보와 충돌할 가능성이 없다는 것을 서버가 안정적으로 결정할 수 있는 경우\(다시 시작 인스턴스 전체에 걸쳐 지속적으로 유지되는 상태를 통해\)를 제외하고는 재확보 유형 잠금 요청만 허용됩니다. 유예 기간 동안 새로운 잠금을 얻기 위한 요청\(즉, 회수 유형 요청이 아님\)이 발생하고 그러한 결정을 내릴 수 없는 경우 서버는 NFS4ERR\_GRACE 오류를 반환해야 합니다.

새 클라이언트 ID를 사용하여 세션이 설정되면 클라이언트는 회수 유형 잠금 요청\(예: 회수가 TRUE로 설정된 LOCK 작업 및 CLAIM\_PREVIOUS 클레임 유형의 OPEN 작업, 섹션 9.11 참조\)을 사용하여 잠금을 다시 설정합니다. 상태. 이 작업이 완료되거나 회수할 잠금 상태가 없는 경우 클라이언트는 전역 RECLAIM\_COMPLETE 작업, 즉 rca\_one\_fs 인수가 FALSE로 설정된 작업을 보내 회수할 모든 잠금 상태를 회수했음을 나타냅니다. . 클라이언트가 RECLAIM\_COMPLETE 작업을 전송하면 비재확보 잠금 작업을 시도할 수 있지만 특수 처리 기간이 끝날 때까지 각 작업에서 NFS4ERR\_GRACE 상태 결과를 얻을 수도 있습니다. 서버에서 서버로 파일 시스템을 전환하는 경우 유사한 처리 잠금 회수에 대한 논의는 섹션 11.11.9를 참조하십시오.

유예 기간 동안 서버는 아래 설명된 대로 이러한 작업이 안전하게 수행될 수 있다고 보장할 수 없는 한 NFS4ERR\_GRACE 오류와 함께 READ 및 WRITE 작업과 비재확보 잠금 요청\(예: 기타 LOCK 및 OPEN 작업\)을 거부해야 합니다.

유예 기간은 잠금이 있을 수 있는 것으로 알려진 모든 클라이언트가 전역 RECLAIM\_COMPLETE 작업을 수행하여 서버가 다시 시작되기 전에 보유한 잠금 회수를 완료했음을 나타낼 때까지 지속될 수 있습니다. 이는 RECLAIM\_COMPLETE를 수행한 클라이언트가 새 잠금을 획득하려고 시도할 때 NFS4ERR\_GRACE를 수신할 준비가 되어 있어야 함을 의미합니다. 서버가 이전 잠금 상태가 가능한 모든 클라이언트가 RECLAIM\_COMPLETE를 수행했음을 알기 위해 서버는 그러한 잠금을 가질 수 있는 클라이언트 목록을 안정적인 저장소에 유지해야 합니다. 서버는 모든 클라이언트가 전역 RECLAIM\_COMPLETE를 수행하기 전에 유예 기간을 종료할 수도 있습니다. 임대 시간에 따라 결정되는 빈도로 관련 세션에 대한 요청을 보낸 결과로 클라이언트가 서버 다시 시작에 대해 알 수 있는 기회를 제공하기 위해 서버는 임대 기간과 동일한 시간 전에 유예 기간을 종료해서는 안 됩니다. 클라이언트가 그러한 요청을 보내지 않는 경우\(또는 클라이언트가 요청을 보냈지만 서버에서 받지 못한 경우\) 클라이언트가 서버 다시 시작이 발생했음을 알기 전에 유예 기간이 만료될 수 있습니다.\(SHOULD NOT\)

클라이언트가 새로운 클라이언트 ID와 세션을 설정하고 잠금 회수를 수행할 수 있도록 일부 추가 시간이 임대 시간에 추가될 수 있습니다. 섹션 11.11.9에서 설명한 파일 시스템별 유예 기간에도 유사한 규칙이 적용된다는 점에 유의하세요.

비재확보 요청을 허용하는 것이 다른 클라이언트의 잠금 재확보와 충돌하지 않는다는 것을 서버가 안정적으로 결정할 수 있는 경우 NFS4ERR\_GRACE 오류는 유예 기간 내에라도 반환될 필요가 없습니다. - 자체 전역 RECLAIM\_COMPLETE를 수행하기 전에 잠금 요청을 회수합니다. 서버가 유예 기간 동안 READ 및 WRITE 작업을 서비스할 수 있으려면 잠재적인 회수 잠금 요청과 READ 또는 WRITE 작업 간에 충돌이 발생할 수 없음을 다시 보장할 수 있어야 합니다. 서버가 해당 보증을 제공할 수 없는 경우 NFS4ERR\_GRACE 오류가 클라이언트에 반환되어야 합니다.

서버가 유예 기간 동안 간단하고 유효한 처리를 제공하는 가장 쉬운 방법은 NFS4ERR\_GRACE 오류를 반환하여 모든 비재확보 잠금 요청과 READ 및 WRITE 작업을 거부하는 것입니다. 그러나 서버는 부여된 잠금에 대한 정보를 안정적인 저장소에 보관할 수 있습니다. 이 정보를 사용하여 서버는 잠금, 읽기 또는 쓰기 작업을 안전하게 처리할 수 있는지 확인할 수 있습니다.

예를 들어 서버가 필수 잠금, 필수 바이트 범위 잠금 또는 거부 모드를 지정하는 공유 예약의 존재 여부에 대한 안정적인 저장소 요약 정보를 유지 관리하는 경우 유예 기간 동안 많은 요청이 허용될 수 있습니다. 그러한 공유 예약이 존재하지 않는 것으로 알려진 경우 거부 모드를 지정하지 않은 OPEN 요청이 안전하게 승인될 수 있습니다. 또한, 안정적인 저장소에 저장된 정보를 통해 또는 단순히 서버가 이러한 잠금을 지원하지 않는다는 이유로 필수 바이트 범위 잠금이 존재하지 않는 것으로 알려진 경우 유예 기간 동안 READ 및 WRITE 작업이 안전하게 처리될 수 있습니다. 또 다른 중요한 경우는 서버가 잠금을 지원하지 않거나 지속적으로 기록된 데이터를 통해 잠금이 없음을 알 수 있기 때문에 필수 바이트 범위 잠금이 존재하지 않는 것으로 알려진 경우입니다. 이 경우 회수 유형 작업에서 파생된 상태 ID를 지정하는 READ 및 WRITE 작업은 유예 기간 동안 유효하게 처리될 수 있습니다. 왜냐하면 유효한 회수를 통해 이후에 부여된 잠금이 I/O를 방해할 수 없도록 보장하기 때문입니다.

다시 말하면, 유예 기간 동안 비재확보 잠금 및 I/O 요청 처리를 허용하는 서버의 경우, 이후에 재확보된 잠금이 거부되지 않고 이후에 재확보된 잠금이 I/O 작업을 방해하지 않았는지 결정해야 합니다. 유예기간 동안 처리됩니다.\(MUST\)

클라이언트는 비재확보 잠금 및 I/O 요청에 대한 NFS4ERR\_GRACE 오류 반환에 대비해야 합니다. 이 경우 클라이언트는 요청에 대한 재시도 메커니즘을 사용해야 합니다. 서버에 부담을 주지 않으려면 재시도 사이에 몇 초 정도의 지연 시간을 두어야 합니다. 일반적인 문제에 대한 추가 논의는 \[55\]에 포함되어 있습니다. 클라이언트는 유예 기간 내에 I/O 및 비재확보 잠금 요청을 수행할 수 있는 서버와 그렇게 할 수 없는 서버를 모두 고려해야 합니다.

서버의 유예 기간 이외의 회수 유형 잠금 요청은 서버가 재시작 이후 충돌하는 잠금이나 I/O 요청이 허용되지 않았음을 보장할 수 있는 경우에만 성공할 수 있습니다.

서버는 재시작 시 임대 기간에 대한 새로운 값을 설정할 수 있습니다. 따라서 클라이언트는 새 클라이언트 ID가 설정되면 Lease\_time 속성을 다시 가져와 해당 서버와 관련된 임대에 대한 임대 갱신의 기초로 사용해야 합니다. 그러나 서버는 이 다시 시작 이벤트에 대해 최소한 이전 서버 인스턴스화에 대한 임대 기간만큼 긴 유예 기간을 설정해야 합니다. 이를 통해 이전 서버 인스턴스에서 얻은 클라이언트 상태를 안정적으로 다시 설정할 수 있습니다.

eir\_server\_scope와 eir\_server\_owner의 조합에서 알 수 있듯이 서버 구성 이벤트로 인해 클라이언트가 잠금을 획득한 서버가 아닌 다른 서버와 통신할 가능성이 있습니다. 이로 인해 클라이언트가 다른 서버로 보고되는 항목에서 이전에 얻은 잠금을 회수하려고 시도해야 하는지 여부와 시기에 대한 문제가 발생합니다. 이 문제를 해결하기 위한 규칙은 다음과 같습니다.

\* 서버 범위가 다른 경우 클라이언트는 잠금 회수를 시도해서는 안 됩니다. 이 상황에서는 잠금 회수가 불가능합니다. 비재확보 작업으로 잠금을 다시 얻으려는 시도는 기존 파일 핸들이 새 서버에서 인식되거나 인식된 경우 동일한 개체를 표시한다는 보장이 없기 때문에 문제가 됩니다. 재구성 이벤트로 인해 잠금이 취소된 것으로 처리하는 것이 가장 좋습니다.

\* 서버 범위가 동일하면 eir\_server\_owner 값이 다르더라도 클라이언트는 잠금 회수를 시도해야 합니다. 이 상황에서 엣지 조건 방지를 포함하여 잠금 회수 작업에 대한 올바른 지원을 제공할 수 없는 경우 NFS4ERR\_NO\_GRACE를 반환하는 것은 서버의 책임입니다.

eir\_server\_owner 필드는 이 결정을 내리는 데 사용되지 않습니다. 그 기능은 클라이언트에 대한 트렁킹 가능성을 지정하는 것이며\(섹션 2.10.5 참조\) 잠금 회수를 제어하는 ​​것은 아닙니다.

---
###### **8.4.2.1.1.  Security Considerations for State Reclaim**

유예 기간 동안 클라이언트는 서버가 다시 시작되기 전에 믿었거나 주장했던 상태를 회수할 수 있습니다. 서버가 클라이언트의 모든 상태에 대한 완전한 기록을 유지하지 않는 한 서버는 클라이언트를 신뢰하는 것 외에는 선택의 여지가 없습니다. \(물론 서버가 완전한 기록을 유지한다면 서버를 다시 시작한 후 클라이언트가 상태를 회수하도록 강제할 필요는 없습니다.\) 서버는 클라이언트가 진실을 말할 것이라고 믿어야 하지만 보안에 대한 부정적인 결과는 다음과 같이 제한됩니다. AUTH\_SYS가 지원되는 상황에서 서비스 거부 공격을 활성화합니다. 회수 요청을 처리할 때 서버의 기본 규칙은 액세스 제어 또는 액세스 충돌 문제로 인해 안정적인 상태 동안 동일한 비재확보 요청이 승인되지 않는 경우 서버가 회수를 승인해서는 안 된다는 것입니다. 예를 들어, 요청을 하는 주체가 파일에 대한 임의 ACL\(섹션 6.2.2\)에 따라 파일을 열 수 있는 액세스 권한이 없으면 회수 중 OPEN 요청이 NFS4ERR\_ACCESS로 거부됩니다.\(MUST NOT\)

그럼에도 불구하고 오류가 있거나 악의적으로 작동하는 클라이언트가 회수 중에 다른 클라이언트가 상태에 대한 액세스를 회수하지 못하게 할 수 있습니다. 예를 들어 공격자는 다른 클라이언트가 서버를 다시 시작하기 전의 OPEN 상태를 회수하지 못하도록 하는 거부 모드를 사용하여 OPEN 회수 작업을 보낼 수 있습니다. 공격자는 권한이 있는 한 서버를 다시 시작하기 전 안정된 상태에서 동일한 서비스 거부를 수행할 수 있습니다. 공격 벡터가 동등하다는 점을 감안할 때 유예 기간은 서비스 거부에 대한 추가 기회를 제공하지 않으며 유예 기간이든 정상 상태이든 관계없이 이 공격 벡터에 대한 모든 우려 사항은 동일한 방식으로 해결됩니다. 즉, 인증에 RPCSEC\_GSS를 사용하고 액세스를 제한합니다. 파일 소유자가 신뢰하는 주체에게만 파일을 보냅니다.

다시 시작하기 전에 서버에 EXCHGID4\_FLAG\_BIND\_PRINC\_STATEID\(18.35절\) 기능 세트가 있는 클라이언트 ID가 있는 경우 서버는 클라이언트 소유자와 EXCHANGE\_ID를 통해 클라이언트 ID를 설정한 주체를 안정적인 저장소에 기록해야 합니다. 서버가 그렇지 않은 경우 원래 상태를 설정하도록 승인된 주체에 대한 자격 증명이 없으면 클라이언트가 상태를 회수할 수 없게 될 위험이 있습니다.\(SHOULD\)

---
#### **8.4.3.  Network Partitions and Recovery**

네트워크 파티션 기간이 서버에서 제공한 임대 기간보다 길면 서버는 클라이언트로부터 임대 갱신을 받지 못합니다. 이런 일이 발생하면 서버는 클라이언트에 대해 보유한 모든 잠금을 해제하거나 충돌하는 잠금에 대한 요청이 있는 경우 만료된 임대와 관련된 잠금이 해제된다는 제약 조건에 따라 상당한 기간 동안 잠금 상태를 유지하도록 허용할 수 있습니다. 그러한 충돌하는 잠금이 부여되는 것을 방지할 수는 없지만 그러한 충돌하는 요청을 방해하지 않도록 필요에 따라 취소해야 합니다.\(MUST\)

서버가 충돌이 발생할 때까지 잠금 상태 해제를 지연하기로 선택한 경우 충돌이 발생한 후 클라이언트의 모든 잠금을 해제하거나 충돌하는 요청을 허용하는 데 필요한 최소 잠금 집합만 취소할 수 있습니다. 보다 세분화된 접근 방식을 채택하면 충돌이 잠금의 하위 집합에서만 발생하는 경우에도 지정된 상태 ID와 관련된 모든 잠금을 취소해야 합니다.

서버가 임대 만료 직후 또는 충돌하는 잠금을 얻으려는 첫 번째 시도의 결과로 클라이언트의 모든 잠금 상태를 해제하기로 선택한 경우 서버는 다양한 방법으로 잠금 상태 손실을 보고할 수 있습니다.

서버는 세션 및 관련 클라이언트 ID를 무효화하도록 선택할 수 있습니다. 이 경우 클라이언트가 서버와 통신할 수 있게 되면 NFS4ERR\_BADSESSION 오류가 발생합니다. 새 세션을 생성하려고 하면 NFS4ERR\_STALE\_CLIENTID를 받게 됩니다. 새 클라이언트 ID와 새 세션을 생성하면 클라이언트는 잠금 회수를 시도합니다. 일반적으로 서버는 복구 유예 기간이 아니기 때문에 클라이언트가 잠금을 회수하는 것을 허용하지 않습니다.

또 다른 가능성은 서버가 세션과 클라이언트 ID를 유지하지만 클라이언트가 보유한 모든 상태 ID가 유효하지 않거나 유효하지 않게 되는 것입니다. 클라이언트가 네트워크 분할 후 서버에 도달할 수 있게 되면 SEQUENCE 작업에서 반환된 상태는 잠금 상태가 손실되었음을 나타냅니다. 즉, SEQ4\_STATUS\_EXPIRED\_ALL\_STATE\_REVOKED 플래그가 sr\_status\_flags에 설정됩니다. 또한 현재 유효하지 않은 상태 ID를 사용하여 클라이언트가 제출한 모든 I/O는 실패하고 서버는 NFS4ERR\_EXPIRED 오류를 반환합니다. 클라이언트가 잠금 상태 손실을 알게 되면 무효화된 잠금을 보유한 애플리케이션에 적절하게 알립니다. 그런 다음 클라이언트는 새 검증자를 사용하여 새 클라이언트 ID를 설정하거나 FREE\_STATEID 작업을 수행하여 무효화된 각 stateid를 해제함으로써 무효화된 stateid를 해제하기 위한 조치를 취해야 합니다.

클라이언트의 임대가 만료되었을 때 서버가 잠금을 취소하기 위해 보다 세분화된 접근 방식을 채택하면 일반적으로 네트워크 분할 중에 상태 ID의 하위 집합만 유효하지 않게 됩니다. 이러한 네트워크 파티션이 복구된 후 클라이언트가 서버와 통신할 수 있으면 SEQUENCE 작업에서 반환된 상태는 잠금 상태의 부분적 손실\(SEQ4\_STATUS\_EXPIRED\_SOME\_STATE\_REVOKED\)을 나타냅니다. 또한 클라이언트가 제출한 I/O를 포함하여 현재 유효하지 않은 상태 ID를 사용하는 작업은 서버가 NFS4ERR\_EXPIRED 오류를 반환하면서 실패합니다. 클라이언트가 잠금 상태 손실을 알게 되면 모든 상태 ID에 대해 TEST\_STATEID 작업을 사용하여 어떤 잠금이 손실되었는지 확인한 다음 무효화된 잠금을 보유한 애플리케이션에 적절하게 알립니다. 그런 다음 클라이언트는 무효화된 각 stateid에 대해 FREE\_STATEID 작업을 수행하여 무효화된 잠금 상태를 해제하고 관련 잠금의 취소를 승인할 수 있습니다.

네트워크 파티션이 서버 다시 시작과 결합되면 서버 다시 시작 후 자동 데이터 손상을 방지하기 위해 서버에 요구 사항을 적용하는 엣지 조건이 있습니다. 이러한 에지 조건 중 두 가지는 알려져 있으며 아래에서 설명합니다.

첫 번째 경계 조건은 다음과 같은 시나리오의 결과로 발생합니다.

1. 클라이언트 A가 잠금을 획득합니다.

2. 클라이언트 A와 서버는 상호 네트워크 분할을 경험하므로 클라이언트 A는 임대를 갱신할 수 없습니다.

3. 클라이언트 A의 임대가 만료되고 서버는 잠금을 해제합니다.

4. 클라이언트 B는 클라이언트 A의 잠금과 충돌할 수 있는 잠금을 획득합니다.

```text
   5.  Client B releases its lock.

   6.  Server restarts.
```

7. 클라이언트 A와 서버 복구 간의 네트워크 파티션.

8. 클라이언트 A는 새 서버 인스턴스에 연결하고 서버 다시 시작에 대해 알아봅니다.

9. 클라이언트 A는 서버의 유예 기간 내에 잠금을 회수합니다.

따라서 마지막 단계에서 서버는 클라이언트 A의 잠금 회수를 잘못 허용했습니다. 클라이언트 B가 잠금으로 보호하는 개체를 수정한 경우 클라이언트 A는 개체 손상을 경험하게 됩니다.

두 번째로 알려진 경계 조건은 다음과 같은 상황에서 발생합니다.

1. 클라이언트 A는 하나 이상의 잠금을 획득합니다.

```text
   2.   Server restarts.
```

3. 클라이언트 A와 서버는 상호 네트워크 분할을 경험하므로 클라이언트 A는 유예 기간 내에 모든 잠금을 회수할 수 없습니다.

4. 서버의 회수 유예 기간이 종료됩니다. 클라이언트 A에는 잠금이 없거나 서버에 알려진 불완전한 잠금 세트가 있습니다.

5. 클라이언트 B는 회수되지 않은 클라이언트 A의 잠금과 충돌할 수 있는 잠금을 획득합니다.

6. 클라이언트 B가 잠금을 해제합니다.

7. 서버가 두 번째로 다시 시작됩니다.

8. 클라이언트 A와 서버 복구 간의 네트워크 파티션.

9. 클라이언트 A는 새 서버 인스턴스에 연결하고 서버 다시 시작에 대해 알아봅니다.

10. 클라이언트 A는 서버의 유예 기간 내에 잠금을 회수합니다.

첫 번째 경계 조건과 마찬가지로 두 번째 경계 조건 시나리오의 마지막 단계에서는 서버가 클라이언트 A의 잠금 회수를 잘못 승인했습니다.

첫 번째 및 두 번째 엣지 조건을 해결하려면 서버가 다시 시작된 후 항상 일부 엣지 조건이 발생한다고 가정하여 모든 회수 시도에 대해 NFS4ERR\_NO\_GRACE를 반환하거나 서버가 일부 정보를 안정적인 저장소에 기록해야 합니다. 서버가 안정적인 저장소에 기록하는 정보의 양은 엣지 조건이 발생할 때마다 서버가 얼마나 가혹하게 처리하려고 하는지에 반비례합니다. 모든 엣지 조건을 완벽하게 허용하는 서버는 획득된 모든 잠금을 안정적인 저장소에 기록하고 잠금이 해제된 경우에만 안정적인 저장소에서 잠금 기록을 제거합니다. 위에서 설명한 두 가지 엣지 조건의 경우 서버가 가장 가혹할 수 있고 여전히 회수 유예 기간을 지원하려면 서버가 최소한의 정보를 안정적인 저장소에 기록해야 합니다. 예를 들어, 서버 구현은 각 클라이언트에 대해 다음을 포함하는 레코드를 안정적인 저장소에 저장할 수 있습니다.

\* EXCHANGE\_ID 작업에 표시된 client\_owner4의 co\_ownerid 필드입니다.

\* 클라이언트의 임대가 만료되었거나 바이트 범위 잠금, 공유 예약 또는 위임을 취소하기 위한 관리 개입\(섹션 8.5 참조\)이 있었고 FREE\_STATEID를 통해 그러한 취소에 대한 승인이 없었는지 여부를 나타내는 부울입니다.

\* 유예 기간이 종료된 상황에서 클라이언트가 회수 가능한 것으로 간주되는 잠금을 보유하여 서버의 잠금 회수 가능성에 대한 관점을 의심하게 만드는지 여부를 나타내는 부울입니다. 서버는 새로운\(즉, 회수되지 않은\) 잠금을 부여하기 전에 클라이언트가 적절한 RECLAIM\_COMPLETE\(잠금 요청 대상에 따라 전역 또는 파일 시스템별\)를 수행하지 않은 안정적인 저장소의 모든 클라이언트 레코드에 대해 이를 설정합니다. 어떤 클라이언트.

위의 기록 유지를 가정하면 첫 번째 경계 조건의 경우 서버가 다시 시작된 후 클라이언트 A의 임대가 만료되었다는 기록은 다른 클라이언트가 충돌하는 바이트 범위 잠금, 공유 예약 또는 위임을 획득했을 수 있음을 의미합니다. 따라서 서버는 NFS4ERR\_NO\_GRACE 오류와 함께 클라이언트 A의 회수를 거부해야 합니다.

두 번째 엣지 조건의 경우 서버가 두 번째로 다시 시작된 후 유예 기간이 종료된 시점에 클라이언트가 회수를 완료하지 않았다는 표시는 서버가 NFS4ERR\_NO\_GRACE 오류와 함께 클라이언트 A의 회수를 거부해야 함을 의미합니다.

엣지 조건 중 하나가 발생하면 클라이언트가 잠금을 회수하려고 시도하면 NFS4ERR\_NO\_GRACE 오류가 발생합니다. 이를 수신하거나 클라이언트가 잠금 상태 없이 다시 시작된 후 클라이언트는 전역 RECLAIM\_COMPLETE를 보냅니다. RECLAIM\_COMPLETE가 수신되면 서버와 클라이언트는 회수 가능한 잠금에 대해 다시 합의하고 영구 저장소의 두 부울을 모두 재설정할 수 있습니다. 잠금 회수 작업을 의심스럽게 만드는 후속 이벤트가 있는 경우에만 다시 설정할 수 있습니다.

기록 보관 수준 및 접근 방식에 관계없이 서버는 다음 전략 중 하나를 구현해야 합니다\(공유 예약 회수, 바이트 범위 잠금 및 위임에 적용됨\).\(MUST\)

1. NFS4ERR\_NO\_GRACE를 사용하여 모든 회수를 거부합니다. 이것은 매우 가혹한 일이지만 서버가 안정적인 저장소에 잠금 상태를 기록하지 않는 경우 필요합니다.

2. 이 섹션에 언급된 두 가지를 포함하여 서버 다시 시작과 관련된 알려진 모든 엣지 조건이 감지되도록 안정적인 저장소에 충분한 상태를 기록합니다. 충분한 지식이 있으면 재생이 허용되지만 경계 조건을 잘못 인식하고 재생을 허용하지 않는 것은 허용됩니다. 이 경우 서버가 반환하는 오류는 NFS4ERR\_NO\_GRACE입니다. 다른 가장자리 조건이 있는지는 알 수 없습니다.

- 서버를 다시 시작한 후 안정적인 저장소의 정보에 복구할 수 없는 손상이나 손상이 있다고 서버가 판단하는 경우, 영향을 받을 수 있는 모든 클라이언트 및/또는 잠금에 대해 서버는 NFS4ERR\_NO\_GRACE를 반환해야 합니다.\(MUST\)

클라이언트의 NFS4ERR\_NO\_GRACE 오류 처리에 대한 명령은 이 사양의 범위를 벗어납니다. 이러한 처리 전략은 클라이언트의 운영 환경에 따라 크게 달라지기 때문입니다. 그러나 한 가지 잠재적인 접근 방식이 아래에 설명되어 있습니다.

클라이언트가 NFS4ERR\_NO\_GRACE를 수신하면 클라이언트가 상태를 회수하려고 하는 객체의 변경 속성을 검사하고 이를 사용하여 일반 OPEN 또는 LOCK 작업을 통해 상태를 다시 설정할지 여부를 결정할 수 있습니다. 이는 클라이언트의 운영 환경이 허용하는 경우 허용됩니다. 즉, 클라이언트 구현자는 사용자를 위해 동작을 문서화하는 것이 좋습니다. 클라이언트는 UNIX 신호, GUI\(그래픽 사용자 인터페이스\) 팝업 창 등을 통해 바이트 범위 잠금 또는 공유 예약\(위임 여부에 관계없이\)이 손실되었음을 애플리케이션에 알릴 수도 있습니다. 클라이언트 상태에서 회수되지 않은 위임을 처리하기 위해 클라이언트가 수행해야 하는 작업에 대한 논의는 섹션 10.5입니다.

잠금 취소에 대한 자세한 내용은 섹션 8.5를 참조하세요.

---
### **8.5.  Server Revocation of Locks**

언제든지 서버는 클라이언트가 보유한 잠금을 취소할 수 있으며 클라이언트는 이 이벤트에 대비해야 합니다. 클라이언트가 잠금이 취소되었거나 취소되었을 수 있음을 감지하면 클라이언트는 자신과 서버 간의 상태 정보를 검증해야 합니다. 클라이언트의 잠금 상태를 검증한다는 것은 클라이언트가 현재 보유하고 있는 각 잠금의 상태를 확인하거나 회수해야 함을 의미합니다.

잠금이 처음으로 취소되는 경우는 서버를 다시 시작할 때입니다. 여기에는 세션이 지속되고 잠금 상태가 손실되는 상황이 포함됩니다. 이 클래스의 인스턴스에서 클라이언트는 일반적으로 현재 세션의 문제에 대한 복구의 일부로 클라이언트 ID를 사용하는 작업에서 오류\(NFS4ERR\_STALE\_CLIENTID\)를 수신하고 클라이언트는 설명된 대로 정상적인 충돌 복구를 진행합니다. 섹션 8.4.2.1에서.

잠금 취소의 두 번째 경우는 섹션 8.4.3에 설명된 대로 만료 전에 임대를 갱신할 수 없는 경우입니다. 이는 드물거나 특이한 사건으로 간주되지만 고객은 회복할 준비가 되어 있어야 합니다. 서버는 임대 만료의 정확한 결과를 결정하고 결정된 잠금 취소 범위를 클라이언트에 알리는 역할을 담당합니다. 그런 다음 클라이언트는 SEQUENCE 결과\(sr\_status\_flags 필드, 섹션 18.46.3 참조\)에서 서버가 제공한 상태 정보를 사용하여 복구를 위해 잠금 상태를 서버의 잠금 상태와 동기화합니다.

잠금 취소의 세 번째 경우는 관리 개입으로 인해 또는 회수 가능한 잠금\(위임 또는 레이아웃\)이 회수된 후 임대 기간 내에 반환되지 않았기 때문에 임대 기간 내에 잠금이 취소된 결과로 발생할 수 있습니다. 이는 드문 사건으로 간주되지만 발생할 수 있으므로 고객은 이를 처리할 준비가 되어 있어야 합니다. 이러한 이벤트 중 하나가 발생하면 클라이언트는 SEQUENCE 작업에서 반환된 상태를 통해 상황을 알아냅니다. 임대 기간 동안 취소된 잠금과 연관된 상태 ID를 사용하면 NFS4ERR\_ADMIN\_REVOKED 또는 NFS4ERR\_DELEG\_REVOKED 오류가 발생합니다.

임대 기간 내에 잠금 상태가 취소되는 모든 경우를 포함하여 잠금 상태의 하위 집합이 취소되었을 수 있는 모든 상황에서 취소된 잠금과 취소되지 않은 잠금을 결정하는 것은 클라이언트의 몫입니다. 이는 적절한 stateid 세트에 대해 TEST\_STATEID 작업을 사용하여 수행됩니다. 취소된 잠금 세트가 결정되면 애플리케이션에 알릴 수 있으며, 무효화된 stateid를 해제하고 FREE\_STATEID를 사용하여 잠금 취소를 승인할 수 있습니다.

---
### **8.6.  Short and Long Leases**

서버 임대 기간을 결정할 때 일반적인 임대 절충안이 적용됩니다. 짧은 임대는 임대 갱신을 수행하기 위한 작업 증가\(부작용으로 임대 갱신을 수행할 기간 동안 다른 작업이 없는 경우\) 비용으로 빠른 서버 복구에 좋습니다. 장기 임대는 매우 많은 수의 클라이언트를 처리하려는 서버에 확실히 더 친절하고 온화합니다. 잠금 갱신을 실행하기 위한 추가 요청 수는 임대 시간에 반비례하여 감소합니다. 장기 임대의 단점은 특정 오류가 발생한 후 복구 속도가 느려질 수 있다는 것입니다. 서버 장애 후 일부 클라이언트가 잠금을 즉시 회수하지 않고 글로벌 RECLAIM\_COMPLETE를 수행하지 않으면 더 긴 유예 기간이 필요할 수 있습니다. 클라이언트 오류가 발생하는 경우 임대 만료 기간이 길어지면 충돌하는 요청이 더 오래 대기하게 됩니다.

서버가 안정적인 저장소에 임대 상태를 저장할 수 있는 경우 장기 임대가 실용적입니다. 복구 시 서버는 안정적인 저장소에서 임대 상태를 재구성하고 클라이언트와 계속 작업할 수 있습니다.

---
### **8.7.  Clocks, Propagation Delay, and Calculating Lease Expiration**

동기화된 시계의 필요성을 피하기 위해 임대 시간은 서버에서 시간 델타로 부여됩니다. 그러나 임대 기간 동안 클라이언트와 서버 시계가 과도하게 변동하지 않아야 한다는 요구 사항이 있습니다. 또한 네트워크 전반에 걸친 전파 지연 문제\(쉽게 수백 밀리초가 될 수 있음\)와 요청이 손실되어 재전송되어야 할 가능성도 있습니다.

전파 지연을 고려하려면 클라이언트는 이를 임대 시간에서 빼야 합니다. 예를 들어 클라이언트가 단방향 전파 지연을 200밀리초로 추정하는 경우 임대를 얻을 때 이미 200밀리초가 지났다고 가정할 수 있습니다. 또한 서버에 응답을 다시 받는 데 200밀리초가 더 걸립니다. 따라서 클라이언트는 임대가 만료되기 최소 400밀리초 전에 임대 갱신을 보내거나 서버에 데이터를 다시 써야 합니다. 임대 기간 동안 전파 지연이 달라지는 경우\(예: 클라이언트가 모바일 호스트에 있는 경우\) 클라이언트는 임대 시간에서 전파 지연의 증가분을 계속해서 빼야 합니다.

서버의 임대 기간 구성은 서버의 리소스에 액세스할 클라이언트의 네트워크 거리를 고려해야 합니다. 임대 기간은 클라이언트 집단에 대한 네트워크 전파 지연 및 기타 네트워크 지연 요인을 고려할 것으로 예상됩니다. 프로토콜은 적절한 임대 기간을 결정하는 자동 방법을 허용하지 않으므로 서버 관리자는 임대 기간을 조정해야 할 수도 있습니다.

---
### **8.8.  Obsolete Locking Infrastructure from NFSv4.0**

NFSv4.1에는 더 이상 기능이 없는 기존 작업 내에는 여러 작업과 필드가 있습니다. 어떤 방식으로든 이러한 변경 사항은 모두 잠금 자체와 별개로 프로토콜의 기본 기능으로 클라이언트 컨텍스트와 정확히 한 번 의미론을 제공하는 세션 구현으로 인해 발생합니다.

다음 NFSv4.0 작업은 NFSv4.1에서 구현되어서는 안 됩니다. 이러한 작업이 NFSv4.1 COMPOUND에서 발견되면 서버는 NFS4ERR\_NOTSUPP를 반환해야 합니다.\(MUST NOT, MUST\)

\* SETCLIENTID는 해당 기능이 EXCHANGE\_ID로 대체되었기 때문입니다.

\* 클라이언트 ID 확인이 이제 CREATE\_SESSION을 통해 이루어지기 때문에 SETCLIENTID\_CONFIRM입니다.

\* OPEN\_CONFIRM은 상태 소유자 기반 seqid가 SEQUENCE 작업에서 시퀀스 ID로 대체되었기 때문입니다.

\* RELEASE\_LOCKOWNER 연결된 잠금이 없는 잠금 소유자는 시퀀스 관련 상태가 없으므로 서버에서 마음대로 삭제할 수 있기 때문입니다.

\* RENEW는 세션에 대한 모든 SEQUENCE 작업으로 인해 임대 갱신이 발생하여 별도의 작업이 불필요해지기 때문입니다.

또한 부 버전 1에서는 사용되지 않는 잠금과 관련된 기존 작업에 존재하는 여러 필드가 있습니다. 이러한 필드는 이제 다른 방식으로 제공되는 기능을 수행하기 위해 부 버전 0에서 사용되었습니다.

\* 특정 상태 소유자에 대한 요청 순서를 지정하고 재시도 보호를 제공하는 데 사용되는 시퀀스 ID가 이제 세션을 통해 제공됩니다.

\* 특정 요청과 관련된 클라이언트를 식별하는 데 사용되는 클라이언트 ID입니다. 이제 명시적인 클라이언트 ID 필드 없이 현재 세션과 연결된 클라이언트 ID를 사용하여 클라이언트 식별을 사용할 수 있습니다.

기존 작업의 이러한 흔적 필드는 NFSv4.1에서 기능이 없으며 서버에서 무시됩니다. NFSv4.1에 대한 새로운 작업의 클라이언트 ID\(예: CREATE\_SESSION 및 DESTROY\_CLIENTID\)는 무시되지 않습니다.

---
## **9.  File Locking and Share Reservations**

Win32 공유 예약을 지원하려면 파일을 원자적으로 열거나 생성하는 작업을 제공해야 합니다. 별도의 공유/공유 해제 작업을 사용하면 Win32 OpenFile API를 올바르게 구현할 수 없습니다. 공유 의미 체계를 올바르게 구현하려면 파일을 열거나 생성할 때 사용된 이전 NFS 프로토콜 메커니즘\(LOOKUP, CREATE, ACCESS\)을 교체해야 합니다. NFSv4.1 프로토콜은 서버에서 파일을 원자적으로 조회, 생성 및 잠글 수 있는 OPEN 작업을 정의합니다.

---
### **9.1.  Opens and Byte-Range Locks**

READ 및 WRITE 작업과 비교할 때 바이트 범위 잠금을 조작하는 일은 드물다고 가정됩니다. 또한 서버가 다시 시작되거나 네트워크가 분할되는 경우는 상대적으로 드물다고 가정됩니다. 따라서 READ 및 WRITE 작업이 잠금을 보유하고 있는지 여부를 나타내는 간단한 메커니즘을 갖는 것이 중요합니다. LOCK 작업에는 바이트 범위 잠금을 설정하고 잠금 소유자를 고유하게 정의하는 데 필요한 중량 정보가 포함되어 있습니다.

---
#### **9.1.1.  State-Owner Definition**

파일을 열거나 바이트 범위 잠금을 요청할 때 클라이언트는 요청된 잠금의 소유자를 나타내는 식별자를 지정해야 합니다. 이 식별자는 프로토콜에서 state\_owner4로 표시되는 상태 소유자 형식입니다. 이 배열은 현재 클라이언트 ID와 연결될 때 클라이언트가 관리하는 잠금 소유자를 고유하게 정의하는 가변 길이 불투명 배열입니다. 이는 스레드 ID, 프로세스 ID 또는 기타 고유 값일 수 있습니다.

열기 소유자와 바이트 범위 잠금 소유자는 별도의 엔터티이며 동일한 불투명 배열을 사용하여 각각의 소유자를 지정하더라도 별도의 상태로 유지됩니다. 프로토콜은 공개 소유자\(open\_owner4 구조로 표시\)와 잠금 소유자\(lock\_owner4 구조로 표시\)를 구별합니다.

각각의 열기는 특정 열기 소유자와 연관되어 있고 각 바이트 범위 잠금은 잠금 소유자 및 열기 소유자와 연관되어 있으며 후자는 LOCK 작업이 수행된 열린 파일과 연관된 열기 소유자입니다. 반면 위임 및 레이아웃은 특정 소유자와 연결되지 않고 클라이언트 전체\(클라이언트 ID로 식별\)와 연결됩니다.

---
#### **9.1.2.  Use of the Stateid and Locking**

모든 READ, WRITE 및 SETATTR 작업에는 stateid가 포함됩니다. 이 섹션의 목적에 따라 파일의 크기 속성을 변경하는 SETATTR 작업은 이전 크기와 새 크기 사이의 영역\(즉, SETATTR을 통해 잘리거나 파일에 추가된 바이트 범위\)을 쓰는 것처럼 처리됩니다. \), SETATTR이 본문에 명시적으로 언급되지 않은 경우에도 마찬가지입니다. 이러한 작업 중 하나에 전달된 stateid는 공개, 바이트 범위 잠금 집합 또는 위임을 나타내는 것이어야 하며, 익명 액세스를 나타내는 특수 stateid 또는 특수 우회 stateid일 수도 있습니다.

상태 소유자가 서버에서 바이트 범위 잠금 또는 공유 예약을 설정한 상황에서 READ 또는 WRITE 작업을 수행하는 경우\(모든 OPEN은 공유 예약을 구성함\) stateid\(이전에 서버에서 반환됨\)는 다음과 같아야 합니다. 바이트 범위 잠금 및 공유 예약을 포함하여 상태 소유자가 보유한 잠금을 나타내는 데 사용됩니다. 클라이언트가 바이트 범위 잠금이나 공유 예약 등 상태를 설정하지 않은 경우 익명 상태에 대한 특수 stateid\("other" 및 "seqid" 값은 0\)가 사용됩니다. \(일반적인 '특수' 상태 ID에 대한 설명은 섹션 8.2.3을 참조하십시오.\) 익명 상태에 대한 상태 ID 또는 서버에서 반환된 상태 ID가 사용되는지 여부에 관계없이 충돌하는 공유 예약 또는 필수 바이트 범위 잠금이 유지되는 경우 파일에서 서버는 읽기 또는 쓰기 작업 서비스를 거부해야 합니다.\(MUST\)

공유 예약은 OPEN 작업에 의해 설정되며 OPEN이 READ 또는 WRITE 작업을 거부하면 해당 작업이 NFS4ERR\_LOCKED 오류와 함께 거부된다는 점에서 본질적으로 필수입니다. 바이트 범위 잠금은 서버에 의해 필수 또는 권고로 구현될 수 있으며, 필수 또는 권고 동작의 선택은 액세스되는 파일을 기반으로 서버에 의해 결정될 수 있습니다\(예를 들어 일부 UNIX 기반 서버는 " 모드 속성에 필수 잠금 비트"가 설정되어 있으면 I/O가 가능하기 전에 파일에 바이트 범위 잠금이 필요합니다. 바이트 범위 잠금이 권장되는 경우 충돌하는 잠금 요청의 승인만 방지하고 읽기 또는 쓰기에는 영향을 미치지 않습니다. 그러나 필수 바이트 범위 잠금은 I/O 작업 충돌을 방지합니다. 시도되면 NFS4ERR\_LOCKED로 거부됩니다. 클라이언트가 적절한 공유 예약이 있음을 알고 있는 파일에서 NFS4ERR\_LOCKED를 받으면 I/O가 수행될 바이트 범위를 포함하는 파일의 바이트 범위에 대해 LOCK 작업을 보내야 합니다. , LOCK 작업 인수의 적절한 잠금 유형 필드\(예: READ 작업의 경우 READ\*\_LT, WRITE 작업의 경우 WRITE\*\_LT\).

필수 바이트 범위 잠금을 지원하는 UNIX 환경의 경우 권고 잠금과 필수 잠금 간의 차이가 미묘합니다. 실제로 권고 및 필수 바이트 범위 잠금은 API 및 구현 요구 사항과 정확히 동일합니다. 파일에 필수 잠금 속성이 설정된 경우 서버는 잠금 소유자가 읽거나 쓰려는 바이트 범위에 대해 적절한 공유\(READ\_LT\) 또는 배타적\(WRITE\_LT\) 바이트 범위 잠금을 가지고 있는지 확인합니다. . 적절한 잠금이 없으면 서버는 충돌하는 잠금이 있는지 확인합니다. 이는 잠금 소유자를 대신하여 충돌하는 잠금을 획득하려고 시도하고 성공하면 READ 또는 WRITE 작업이 완료된 후 잠금을 해제합니다. done\), 존재하는 경우 서버는 NFS4ERR\_LOCKED를 반환합니다.

Windows 환경의 경우 바이트 범위 잠금은 항상 필수이므로 서버는 I/O 요청 중에 항상 바이트 범위 잠금을 확인합니다.

따라서 LOCK 작업에서는 권고 및 필수 바이트 범위 잠금을 구별할 필요가 없습니다. 구별을 가져오는 것은 서버의 READ 및 WRITE 작업 처리입니다.

특수 stateid 값을 제외하고 READ, WRITE 또는 SETATTR에 유효하게 전달된 모든 stateid는 파일에 대한 액세스 모드\(예: OPEN4\_SHARE\_ACCESS\_READ, OPEN4\_SHARE\_ACCESS\_WRITE 또는 OPEN4\_SHARE\_ACCESS\_BOTH\)를 정의합니다.

\* 열기와 연관된 상태 ID의 경우 이는 OPEN 상태 ID 할당을 유발한 원래 OPEN에 의해 ​​정의되고 동일한 열기 소유자/파일 쌍에 대한 후속 OPEN 및 OPEN\_DOWNGRADE에 의해 수정된 모드입니다.

\* 바이트 범위 LOCK 작업에서 반환된 상태 ID의 경우

- 적절한 모드는 stateid로 표시되는 잠금 세트와 연관된 OPEN stateid에 대한 액세스 모드입니다.

\* 위임 상태 ID의 경우 액세스 모드는 위임 유형에 따라 결정됩니다.

READ, WRITE 또는 SETATTR\(크기 속성 지정\) 작업이 완료되면 해당 작업은 액세스 모드를 검사하여 해당 작업과 연결된 stateid를 고려하여 해당 작업이 적절한지 확인합니다.

WRITE 유형 작업\(즉, 크기를 설정하는 WRITE 및 SETATTR\)의 경우 서버는 액세스 모드가 쓰기를 허용하는지 확인해야 하며 그렇지 않은 경우 NFS4ERR\_OPENMODE 오류를 반환해야 합니다. READ의 경우 서버는 액세스 모드에서 해당 검사를 수행하거나 WRITE 구현이 불가피하게 읽기를 수행할 수 있는 클라이언트를 수용하기 위해 OPEN4\_SHARE\_ACCESS\_WRITE에 대한 OPEN에 대한 READ를 허용하도록 선택할 수 있습니다\(예: 버퍼 캐시 제약 조건으로 인해\). 그러나 이러한 상황에서 READ가 허용되더라도 서버는 READ와 충돌하는 잠금\(예: OPEN4\_SHARE\_DENY\_READ 또는 OPEN4\_SHARE\_DENY\_BOTH를 지정한 다른 OPEN\)을 계속 확인해야 합니다. OPEN4\_SHARE\_ACCESS\_READ에 대한 OPEN이 있으면 충돌하는 공유 예약이 존재할 수 없음을 보장하므로 READ에 대한 액세스 모드 확인을 시행하는 서버는 충돌하는 공유 예약을 명시적으로 확인할 필요가 없습니다.\(MUST, MUST\)

READ 우회 특수 stateid\("other" 및 "seqid"의 모든 비트가 1로 설정됨\)는 잠금 검사를 우회하려는 의도를 나타냅니다. 서버는 이 특수 상태 ID가 사용될 때 READ 작업이 서버의 잠금 검사를 우회하도록 허용할 수 있습니다. 그러나 이 특수 stateid 값을 사용한 WRITE 작업은 잠금 검사를 우회해서는 안 되며 익명 상태에 대한 특수 stateid가 사용된 것과 정확히 동일하게 처리됩니다.\(MAY, MUST NOT\)

특수 상태 ID 중 하나를 사용하는 READ 또는 WRITE 작업이 수행되는 동안 잠금이 부여되지 않을 수 있으며, 부여되는 잠금 범위는 READ 또는 WRITE 작업과 충돌합니다. 이는 다음과 같은 경우에 발생할 수 있습니다.

\* READ 또는 WRITE 작업의 바이트 범위와 충돌하는 바이트 범위로 필수 바이트 범위 잠금이 요청됩니다. 이 단락의 목적에 따라 공유 잠금이 요청되고 WRITE 작업이 수행되는 경우 또는 배타적 잠금이 요청되고 READ 또는 WRITE 작업이 수행되는 경우 충돌이 발생합니다.

\* 읽기 및/또는 쓰기를 거부하는 공유 예약을 요청하고 해당 작업을 수행하고 있습니다.

\* 위임이 허용되고 위임 유형은 I/O 작업을 방지합니다. 즉, READ 및 WRITE는 OPEN\_DELEGATE\_WRITE 위임과 충돌하고 WRITE는 OPEN\_DELEGATE\_READ 위임과 충돌합니다.

클라이언트가 위임을 보유하는 경우 위임이 불가피하게 회수되는 것을 방지하기 위해 전송된 stateid가 위임과의 작업 연관성을 전달하는지 확인해야 합니다. 위임 stateid, 해당 위임과 관련된 open stateid, 또는 그러한 open에서 파생된 바이트 범위 잠금을 나타내는 stateid가 사용되는 경우 서버는 READ, WRITE 또는 SETATTR이 위임과 충돌하지 않지만 아래에 전송된다는 것을 알고 있습니다. 대표단의 비호. 클라이언트가 실제로 위임을 가지고 있음을 서버가 클라이언트 ID\(세션 ID를 통해\)에서 확인할 수 있더라도 서버는 이를 확인할 의무가 없으므로 특별한 상태 ID를 사용하면 대표단.

---
### **9.2.  Lock Ranges**

이 프로토콜을 사용하면 잠금 소유자가 바이트 범위의 잠금을 요청한 다음 초기 잠금의 하위 범위를 업그레이드, 다운그레이드 또는 잠금 해제하거나 완전히 또는 부분적으로 겹치는 바이트 범위를 잠금 해제할 수 있습니다. 초기 잠금 또는 동일한 잠금 소유자에 대한 기존 잠금 집합의 조합입니다. 이는 흔하지 않은 유형의 요청이 될 것으로 예상됩니다. 어떤 경우에도 서버 또는 서버 파일 시스템은 하위 범위 잠금 의미를 지원하지 못할 수 있습니다. 서버가 잠금 소유자에 대한 현재 잠금 상태의 하위 범위를 나타내는 잠금 요청을 수신하는 경우 서버는 하위 범위 잠금 작업을 지원하지 않음을 나타내기 위해 NFS4ERR\_LOCK\_RANGE 오류를 반환할 수 있습니다. 따라서 클라이언트는 이 오류를 받을 준비가 되어 있어야 하며, 적절한 경우 요청 응용 프로그램에 오류를 보고해야 합니다.

서버 장애 시 바이트 범위 잠금 상태 복구와 관련된 이유로 서버가 하위 범위 요청을 지원하지 않을 수 있으므로 클라이언트는 인접한 여러 개의 독립적인 잠금 범위를 단일 요청으로 결합하지 않는 것이 좋습니다. 섹션 8.4.2에서 설명한 대로 서버는 잠금 복구 중 클라이언트의 동작이 서버 오류 이전 클라이언트의 잠금 동작과 유사한 경우에만 효과적으로 작동하는 복구 중 특정 최적화를 사용할 수 있습니다.

---
### **9.3.  Upgrading and Downgrading Locks**

클라이언트가 바이트 범위에 WRITE\_LT 잠금을 설정한 경우 유형을 READ\_LT로 설정하여 LOCK 작업을 통해 잠금을 READ\_LT 잠금으로 원자적으로 다운그레이드하도록 요청할 수 있습니다. 서버가 원자성 다운그레이드를 지원하면 요청이 성공합니다. 그렇지 않은 경우 NFS4ERR\_LOCK\_NOTSUPP를 반환합니다. 클라이언트는 이 오류를 받을 준비가 되어 있어야 하며, 적절한 경우 요청 응용 프로그램에 오류를 보고해야 합니다.

클라이언트가 바이트 범위에 READ\_LT 잠금을 설정한 경우 유형을 WRITE\_LT 또는 WRITEW\_LT로 설정하여 LOCK 작업을 통해 잠금을 WRITE\_LT 잠금으로 원자성 업그레이드하도록 요청할 수 있습니다. 서버가 원자성 업그레이드를 지원하지 않으면 NFS4ERR\_LOCK\_NOTSUPP를 반환합니다. 기존 충돌 없이 업그레이드를 수행할 수 있으면 요청이 성공합니다. 그렇지 않으면 서버는 NFS4ERR\_DENIED 또는 NFS4ERR\_DEADLOCK을 반환합니다. 클라이언트가 WRITEW\_LT로 설정된 유형으로 LOCK 작업을 보냈고 서버가 교착 상태를 감지한 경우 NFS4ERR\_DEADLOCK 오류가 반환됩니다. 클라이언트는 그러한 오류를 수신할 준비가 되어 있어야 하며, 적절한 경우 요청 응용 프로그램에 오류를 보고해야 합니다.

---
### **9.4.  Stateid Seqid Values and Byte-Range Locks**

LOCK 또는 LOCKU 작업이 수행되면 반환된 stateid는 인수의 stateid와 동일한 "other" 값을 가지며, LOCK 또는 LOCKU 작업의 발생을 반영하기 위해 \(인수의 stateid를 기준으로\) 증가되는 "seqid" 값을 갖습니다. . 서버는 stateid가 적용되는 잠금에 의해 설명된 대로 바이트 오프셋의 잠금 상태가 변경될 때마다 "seqid" 필드의 값을 증가시켜야 합니다. 잠금 상태 변경에는 잠금에서 잠금 해제로 변경, 그 반대, READ\_LT에 대한 잠금에서 WRITE\_LT에 대한 잠금 또는 그 반대로의 변경이 포함됩니다.\(MUST\)

예를 들어, WRITE\_LT에 대해 이미 잠긴 범위가 WRITE\_LT에 대해 다시 잠기는 경우와 같이 변경 사항이 없는 경우 서버는 "seqid" 값을 증가시킬 수 있습니다.\(MAY\)

---
### **9.5.  Issues with Multiple Open-Owners**

여러 오픈 소유자가 동일한 파일을 열면 클라이언트는 해당 파일에 대해 각각 다른 오픈 소유자와 연결된 여러 OPEN 상태 ID를 갖게 됩니다. 이 경우 동일한 잠금 소유자에 대해 서로 다른 OPEN 상태 ID를 사용하여 전송된 여러 LOCK 및 LOCKU 요청이 있을 수 있으므로 각각 동일한 파일에 대한 바이트 범위 잠금을 나타내고 유지되는 여러 상태 ID가 있는 상황이 발생할 수 있습니다. 동일한 잠금 소유자이지만 각각은 다른 공개 소유자와 연결되어 있습니다.

이러한 상황에서 각 바이트의 잠금 상태\(즉, 잠겨 있는지 여부, 잠금의 READ\_LT 또는 WRITE\_LT 유형, 잠금을 보유한 잠금 소유자\)는 잠금에 대해 수행된 마지막 LOCK 또는 LOCKU 작업을 반영해야 합니다. 요청이 전송된 국가 ID와는 별개로 문제의 소유자입니다.\(MUST\)

문제의 잠금 소유자에 의해 바이트가 잠긴 경우, 해당 바이트 범위 잠금이 할당된 공개 소유자는 해당 바이트의 마지막 LOCK이 수행된 상태 ID와 연관된 공개 소유자의 소유자여야 합니다. LOCK 또는 LOCKU가 수행된 stateid에 대한 잠금과 관련된 공개 소유자가 변경되면 stateid의 "seqid" 필드는 잠금 소유자 측면에서 잠금이 설정되지 않은 경우에도 증가해야 합니다. 변경되었습니다. 동일한 잠금 소유자에 대한 다른 stateid와 관련된, 즉 다른 open-owner와 관련된 잠긴 바이트 집합이 변경되면 해당 stateid에 대한 "seqid" 값은 증가되어서는 안 됩니다.\(SHOULD, MUST, MUST NOT\)

---
### **9.6.  Blocking Locks**

일부 클라이언트에는 차단 잠금 지원이 필요합니다. NFSv4.1은 이전에 사용할 수 없었던 잠금을 사용할 수 있을 때 콜백을 제공하지만 이는 선택 사항 기능이며 클라이언트는 해당 잠금의 존재 여부에 의존할 수 없습니다. 클라이언트는 잠금을 지속적으로 폴링할 준비가 되어 있어야 합니다. 이는 공정성 문제를 야기합니다. 두 가지 잠금 유형인 READW\_LT 및 WRITEW\_LT는 클라이언트가 차단 잠금을 요청하고 있음을 서버에 나타내는 데 사용됩니다. 콜백이 사용되지 않는 경우 서버는 보류 중인 차단 잠금의 정렬된 목록을 유지해야 합니다. 충돌하는 잠금이 해제되면 서버는 첫 번째 대기 클라이언트가 잠금을 다시 요청할 때까지 Lease\_time과 동일한 시간 동안 기다릴 수 있습니다. 임대 기간이 만료된 후 다음 대기 클라이언트 요청에 잠금이 허용됩니다. 클라이언트는 적시에 잠금을 획득할 수 있도록 충분히 작은 간격으로 폴링해야 합니다. 서버는 공정성을 높이고 올바른 작업이 아닌 보류 중인 차단 잠금 목록을 유지 관리할 필요가 없습니다. 크래시 복구의 순서가 지정되지 않은 특성으로 인해 잠금 상태를 안정적인 저장소에 저장해야 차단 잠금의 순서가 부여되는 것을 보장할 수 있습니다.\(MAY\)

또한 서버는 잠금 유형을 기록하고 요청 거부 반환을 지연하여 충돌하는 잠금이 해제될 때까지 추가 시간을 허용하여 성공적인 반환을 허용할 수 있습니다. 이러한 방식으로 클라이언트는 잠금 차단을 위해 불필요하게 자주 폴링하는 부담을 피할 수 있습니다. 서버는 클라이언트가 요청을 재전송하는 경우 지연 시간에 주의해야 합니다.

서버가 차단 LOCK 작업을 수신하고 이를 거부한 다음 나중에 동일한 잠금에 대한 비차단 요청을 수신하면 이 역시 거부됩니다. 그러면 서버는 보류 중인 차단 잠금 목록에서 문제의 잠금을 제거해야 합니다. 클라이언트는 이러한 비차단 요청을 사용하여 잠금을 요청하는 프로세스가 중단될 때 발생할 수 있는 것처럼 이번이 잠금을 폴링하려는 마지막 시간임을 서버에 나타내야 합니다. 이는 다른 LOCK 작업을 승인하기 전에 임대 기간을 불필요하게 기다리는 것을 방지하기 위한 서버에 대한 배려입니다. 그러나 클라이언트는 이러한 예의를 이행할 필요가 없으며 서버는 클라이언트의 그렇게 하는 것에 의존해서는 안 됩니다. 또한 클라이언트는 이 최종 잠금 요청이 수락될 가능성에 대비해야 합니다.

서버가 OPEN4\_RESULT\_MAY\_NOTIFY\_LOCK 플래그를 통해 현재 열려 있는 파일에 대해 CB\_NOTIFY\_LOCK 콜백이 수행될 수 있음을 나타내는 경우 클라이언트는 이를 주의해야 하지만 이는 힌트이므로 CB\_NOTIFY\_LOCK이 항상 수행된다고 의존할 수는 없습니다. 클라이언트는 거부된 잠금에 대해 폴링하는 빈도를 합리적으로 줄일 수 있습니다. 발생할 수 있는 더 큰 대기 시간은 프롬프트 콜백을 통해 제거될 가능성이 높지만 여전히 폴링해야 하기 때문입니다. CB\_NOTIFY\_LOCK을 수신하면 즉시 잠금을 얻으려고 시도해야 하지만 다른 클라이언트가 폴링 중일 수 있으며 서버가 해당 특정 클라이언트에 대해 잠금을 예약할 의무가 없다는 점을 알아야 합니다.\(MAY\)

---
### **9.7.  Share Reservations**

공유 예약은 파일에 대한 액세스를 제어하는 ​​메커니즘입니다. 이는 바이트 범위 잠금과 별개의 독립적인 메커니즘입니다. 클라이언트가 파일을 열면 필요한 액세스 유형\(READ, WRITE 또는 BOTH\)과 다른 액세스를 거부할 액세스 유형\(OPEN4\_SHARE\_DENY\_NONE, OPEN4\_SHARE\_DENY\_READ, OPEN4\_SHARE\_DENY\_WRITE 또는 OPEN4\_SHARE\_DENY\_BOTH\)을 지정하는 OPEN 작업을 서버에 보냅니다. OPEN이 실패하면 클라이언트는 애플리케이션의 열기 요청에 실패합니다.

의미론의 의사 코드 정의:

```text
           if (request.access == 0) {
             return (NFS4ERR_INVAL)
           } else {
             if ((request.access & file_state.deny)) ||
                (request.deny & file_state.access)) {
               return (NFS4ERR_SHARE_DENIED)
           }
           return (NFS4ERR_OK);
```

OPEN에서 공유 예약을 검사할 때 알고리즘에 사용된 현재 file\_state에는 새로운 OPEN 요청을 하는 공개 소유자에 대한 비트를 포함하여 현재 모든 열기를 반영하는 비트가 포함됩니다.

액세스 및 거부 필드에 대한 OPEN 및 OPEN\_DOWNGRADE 작업에 사용되는 상수는 다음과 같습니다.

```text
   const OPEN4_SHARE_ACCESS_READ   = 0x00000001;
   const OPEN4_SHARE_ACCESS_WRITE  = 0x00000002;
   const OPEN4_SHARE_ACCESS_BOTH   = 0x00000003;

   const OPEN4_SHARE_DENY_NONE     = 0x00000000;
   const OPEN4_SHARE_DENY_READ     = 0x00000001;
   const OPEN4_SHARE_DENY_WRITE    = 0x00000002;
   const OPEN4_SHARE_DENY_BOTH     = 0x00000003;
```

---
### **9.8.  OPEN/CLOSE Operations**

올바른 공유 의미를 제공하려면 클라이언트는 OPEN 작업을 사용하여 초기 파일 핸들을 얻고 원하는 액세스와 거부할 액세스\(있는 경우\)를 나타내야 합니다. 클라이언트가 익명 상태 또는 READ 바이패스를 위해 특별한 상태 ID를 사용하려는 경우에도 적절한 공유 의미가 적용될 수 있도록 OPEN 작업을 통해 일반 파일에 대한 파일 핸들을 얻어야 합니다. 파일 열기를 위한 프로그래밍 인터페이스에 기본 거부 모드가 없는 클라이언트는 OPEN4\_SHARE\_DENY\_NONE 거부 모드를 요청해야 합니다.\(MUST\)

CREATE 플래그를 사용한 OPEN 작업은 이전 버전의 NFS 프로토콜에서 사용된 일반 파일에 대한 CREATE 작업도 포함합니다. 이를 통해 공유를 통한 생성이 원자적으로 수행될 수 있습니다.

CLOSE 작업은 해당 파일에 대해 공개 소유자가 보유한 모든 공유 예약을 제거합니다. 바이트 범위 잠금이 유지되면 클라이언트는 CLOSE 작업을 보내기 전에 모든 잠금을 해제해야 합니다. 서버는 CLOSE 시 미해결 잠금을 모두 해제할 수 있지만 일부 서버는 여전히 바이트 범위 잠금이 유지된 파일의 CLOSE를 지원하지 않을 수 있습니다. CLOSE 이후 잠금이 존재하는 경우 서버는 실패 NFS4ERR\_LOCKS\_HELD를 반환해야 합니다.\(SHOULD, MAY, MUST\)

LOOKUP 작업은 서버에 잠금 상태를 설정하지 않고 파일 핸들을 반환합니다. 유효한 stateid가 없으면 서버는 클라이언트의 액세스 권한이 가장 적은 것으로 가정합니다. 예를 들어 한 클라이언트가 OPEN4\_SHARE\_DENY\_BOTH를 사용하여 파일을 열고 다른 클라이언트가 LOOKUP을 통해 얻은 파일 핸들을 통해 파일에 액세스하는 경우 두 번째 클라이언트는 특수 읽기 우회 상태 ID를 사용하여 파일을 읽을 수만 있습니다. 두 번째 클라이언트는 OPEN의 유효한 상태 ID가 없고 특수 익명 상태 ID에 대한 액세스가 허용되지 않기 때문에 파일을 전혀 쓸 수 없습니다.

---
### **9.9.  Open Upgrade and Downgrade**

파일에 대해 OPEN이 수행되고 OPEN이 수행 중인 개방 소유자가 이미 파일을 연 경우 결과적으로 서버에서 유지 관리되는 열린 파일 상태가 새 파일에 의해 지정된 액세스 및 거부 비트를 포함하도록 업그레이드됩니다. OPEN은 물론 기존 OPEN에 대한 것들도 포함됩니다. 결과적으로 프로토콜에 관한 한 하나의 열린 파일이 있으며, 여기에는 완료된 모든 OPEN 요청에 대한 액세스 및 거부 비트의 통합이 포함됩니다. OPEN은 "other" 값이 원래 개방의 값과 일치하고 "seqid" 값이 업그레이드 발생을 반영하기 위해 증가되는 단일 stateid로 표시됩니다. "업그레이드"로 인해 열기 모드가 변경되지 않는 경우 증분이 필요합니다\(예: 기존 열린 파일이 OPEN4\_SHARE\_ACCESS\_BOTH에 대해 열릴 때 읽기를 위해 OPEN이 수행됨\). 두 OPEN의 효과를 재설정하기 위해 단 한 번의 CLOSE만 수행됩니다. 클라이언트는 업그레이드에 영향을 미치는 OPEN에서 반환된 stateid를 사용하거나 동일한 "other" 필드와 seqid 0을 공유하는 stateid를 사용할 수 있습니다. 단, CLOSE가 보류 중인 동안 발생하는 업그레이드에 대해서는 주의가 필요합니다. OPEN을 보낼 때 클라이언트는 동일한 파일이 실제로 열려 있다는 것을 알지 못할 수도 있습니다. 위의 내용은 두 OPEN으로 인해 OPENed 개체가 동일한 파일 핸들로 지정되는 경우에만 적용됩니다.

서버가 동일한 파일 객체에 해당하는 여러 파일 핸들을 내보내도록 선택하고 동일한 파일 객체의 두 개의 다른 OPEN에서 서로 다른 파일 핸들을 반환하는 경우 서버는 액세스 비트와 거부 비트를 함께 "OR"하여 열려 있는 두 파일을 통합해서는 안 됩니다. 대신 서버는 별도의 stateid를 사용하여 별도의 OPEN을 유지해야 하며 이를 해제하려면 별도의 CLOSE가 필요합니다.\(MUST NOT\)

클라이언트에 열려 있는 여러 파일이 서버에 있는 단일 OPEN 파일 개체로 병합되면 클라이언트에 있는 열린 파일 중 하나를 닫으면 서버에 있는 열린 파일에 대한 액세스 및 거부 상태가 변경되어야 할 수 있습니다. 이는 나머지 열기에 대한 액세스 및 거부 비트의 결합이 이전보다 더 작을 수 있기 때문입니다\(즉, 적절한 하위 집합\). OPEN\_DOWNGRADE 작업은 필요한 변경을 수행하는 데 사용되며 클라이언트는 이를 사용하여 다른 클라이언트의 공유 예약 요청이 올바르게 처리되도록 서버를 업데이트해야 합니다. 반환된 stateid에는 서버에 전달된 것과 동일한 "other" 필드가 있습니다. 반환된 stateid의 "seqid" 값은 파일에 대한 액세스 및 거부 비트가 변경되지 않은 상황에서도 증가해야 합니다.\(MUST\)

---
### **9.10.  Parallel OPENs**

동일한 오픈 소유자에 대한 OPEN 작업이 소유자 기반 seqid로 인해 본질적으로 직렬화되는 NFSv4.0의 경우와 달리 동일한 오픈 소유자에 대한 여러 OPEN이 병렬로 수행될 수 있습니다. 클라이언트가 이 작업을 수행하면 하드 링크가 존재하기 때문에 두 개의 OPEN 작업이 동일한 파일을 열 수 있고 나중에 수행된 OPEN은 첫 번째 작업의 업그레이드가 되는 상황에 직면할 수 있습니다. 이 사실은 다음 사용자에게만 표시됩니다. 작업이 완료되면 클라이언트.

이 상황에서 클라이언트는 OPEN이 반환한 stateid를 검사하여 OPEN이 수행된 순서를 결정할 수 있습니다. "other" 필드의 공통 값을 공유하는 Stateid는 "seqid" 필드의 순서에서 결정 가능한 작업 순서를 사용하여 동일한 파일을 연 것으로 인식될 수 있으며, 32비트 필드의 가능한 랩어라운드를 수정합니다.

클라이언트가 동일한 공개 소유자에 대해 여러 OPEN을 병렬로 보낼 가능성이 있는 경우 클라이언트가 이러한 일이 발생할 수 있다는 사실을 미리 알지 못한 채 공개 업그레이드가 발생할 수 있습니다. 이러한 가능성으로 인해 공개 업그레이드와 관련된 상태 변경이 실수로 손실되지 않을 가능성을 방지하기 위해 CLOSE 및 OPEN\_DOWNGRADE는 일반적으로 stateid에 0이 아닌 seqid를 사용하여 전송되어야 합니다.

---
### **9.11.  Reclaim of Open and Byte-Range Locks**

서버 장애 후 바이트 범위 잠금을 다시 설정하거나 열어야 하는 경우 LOCK 및 OPEN 작업의 특수 형식이 제공됩니다.

\* 기존 오픈을 회수하기 위해 CLAIM\_PREVIOUS를 사용하여 OPEN 작업을 수행합니다. 이러한 유형의 상황에서 클라이언트는 이미 파일을 열고 대상 파일의 파일 핸들을 갖고 있으므로 이 작업을 수행하려면 현재 파일 핸들이 디렉터리가 아닌 대상 파일이어야 하며 파일 이름이 지정되지 않습니다.

\* 바이트 범위 잠금을 회수하려면 회수 매개변수가 true로 설정된 LOCK 작업이 사용됩니다.

위임과 관련된 공개 회수는 섹션 10.2.1에서 논의됩니다.

---
## **10.  Client-Side Caching**

NFS 프로토콜로 우수한 성능을 제공하려면 클라이언트측 데이터, 파일 속성 및 파일 이름 캐싱이 필수적입니다. 분산된 캐시 일관성을 제공하는 것은 어려운 문제이며 이전 버전의 NFS 프로토콜에서는 이를 시도하지 않았습니다. 대신 일관성 부족으로 인해 사용자에게 발생하는 문제를 줄이기 위해 여러 NFS 클라이언트 구현 기술이 사용되었습니다. 이러한 기술은 이전 프로토콜 사양에 의해 명확하게 정의되지 않았으며 클라이언트 동작이 유효한지 또는 유효하지 않은지 불분명한 경우가 많습니다.

NFSv4.1 프로토콜은 이전 프로토콜 버전에서 사용된 것과 유사한 많은 기술을 사용합니다. NFSv4.1 프로토콜은 분산 캐시 일관성을 제공하지 않습니다. 그러나 클라이언트 측 캐싱으로 인한 파괴적인 간섭 없이 잠금 및 공유 예약을 사용할 수 있도록 보다 제한된 캐싱 보장 세트를 정의합니다.

또한 NFSv4.1 프로토콜은 일반적으로 서버에서 내리는 많은 결정을 클라이언트가 로컬에서 내릴 수 있도록 하는 위임 메커니즘을 도입합니다. 이 메커니즘은 공유가 자주 발생하지 않거나 공유가 읽기 전용인 일반적인 경우를 효율적으로 지원합니다.

---
### **10.1.  Performance Challenges for Client-Side Caching**

NFS 프로토콜의 이전 버전에서 사용된 캐싱 기술은 우수한 성능을 제공하는 데 성공했습니다. 그러나 이러한 기술을 매우 많은 수의 클라이언트에서 사용할 경우 몇 가지 확장성 문제가 발생할 수 있습니다. 이는 클라이언트가 지리적으로 분산되어 있는 경우 특히 그렇습니다. 이는 일반적으로 캐시 재검증 요청에 대한 대기 시간을 증가시킵니다.

이전 버전의 NFS 프로토콜은 파일이 열릴 때 파일 데이터 캐시 유효성 검사 요청을 반복합니다. 이 동작은 심각한 성능 문제를 일으킬 수 있습니다. 일반적인 경우는 단일 클라이언트에서만 파일에 액세스하는 경우입니다. 따라서 공유가 자주 발생하지 않습니다.

이 경우 충돌이 없는지 확인하기 위해 서버를 반복적으로 참조하는 것은 비용이 많이 듭니다. 성능과 관련하여 더 나은 옵션은 서버를 참조하지 않고 반복적으로 파일을 여는 클라이언트를 허용하는 것입니다. 이는 다른 클라이언트의 잠재적인 충돌 작업이 실제로 발생할 때까지 수행됩니다.

바이트 범위 잠금과 관련하여 유사한 상황이 발생합니다. 데이터 캐싱을 잠금 의미론\(섹션 10.3.2 참조\)과 일치시키는 데 필요한 LOCK 및 LOCKU 작업과 READ 및 WRITE 작업을 전송하면 성능이 심각하게 제한될 수 있습니다. 자주 발생하지 않는 충돌로부터 보호하기 위해 잠금을 사용하면 큰 페널티가 발생합니다. 이 페널티로 인해 애플리케이션의 바이트 범위 잠금 사용이 방해받을 수 있습니다.

NFSv4.1 프로토콜은 다음 설계 목표에 따라 보다 공격적인 캐싱 전략을 제공합니다.

\* 광범위한 서버 의미론과의 호환성.

\* 보다 공격적인 모델을 지원할 수 없는 경우 이전 버전의 NFS 프로토콜과 동일한 캐싱 이점을 제공합니다.

\* 공격적 캐싱에 대한 요구사항은 요구사항을 모두 충족하지 못하는 경우에도 많은 부분의 이점을 얻을 수 있도록 구성되어 있습니다.

서버에 대한 적절한 요구 사항은 특정 형태의 캐싱을 다루는 이후 섹션에서 논의됩니다\(섹션 10.4 참조\).

---
### **10.2.  Delegation and Callbacks**

파일에 대한 서버 책임을 클라이언트에 다시 위임하면 클라이언트 간 충돌이 없을 때 서버에 대한 반복 요청을 방지하여 성능이 향상됩니다. 서버에서 클라이언트로의 "콜백" RPC를 사용하면 다른 클라이언트가 위임된 파일 공유에 참여할 때 서버는 위임된 책임을 회수합니다.

위임 대상과 위임 유형을 지정하여 위임이 서버에서 클라이언트로 전달됩니다. 다양한 유형의 위임이 있지만 각 유형에는 위임에 의존하는 작업을 수행할 때 위임을 나타내는 데 사용되는 상태 ID가 포함되어 있습니다. 이 stateid는 잠금 및 공유 예약과 관련된 것과 유사하지만 위임에 대한 stateid가 클라이언트 ID와 연결되어 있으며 해당 클라이언트의 모든 공개 소유자를 대신하여 사용될 수 있다는 점에서 다릅니다. 위임은 클라이언트 내부의 특정 프로세스나 제어 스레드가 아닌 클라이언트 전체에 대해 이루어집니다.

백채널은 CREATE\_SESSION 및 BIND\_CONN\_TO\_SESSION에 의해 ​​설정되며 클라이언트는 이를 유지해야 합니다. 백채널이 일시적으로라도 다운될 수 있으므로 올바른 프로토콜 작동은 백채널에 의존하지 않습니다. 단일 작업인 CB\_SEQUENCE를 사용하는 CB\_COMPOUND 프로시저를 통해 백채널 기능에 대한 예비 테스트를 사용하여 백채널의 연속성을 확인할 수 있습니다. 서버는 백채널이 존재한다는 것을 확인할 때까지 책임 위임을 피합니다. 위임 승인은 항상 액세스 충돌이 없을 때 조건부로 이루어지기 때문에 클라이언트는 위임이 승인될 것이라고 가정해서는 안 되며\(MUST\) 항상 OPEN, WANT\_DELEGATION 및 GET\_DIR\_DELEGATION이 위임 승인 없이 처리되도록 준비해야 합니다\(MUST\).\(MUST NOT\)

잠금과 달리 위임된 파일에 대한 두 번째 클라이언트의 작업으로 인해 서버는 콜백을 통해 위임을 회수하게 됩니다. 개별 작업의 경우, 리콜을 수행하기 위해 해당 작업이 필요한 시기를 구현 항목에서 설명합니다. 그러나 여러 가지 사항에 주목해야 합니다.

\* 서버는 바람직하다고 느낄 때마다 자유롭게 위임을 회수할 수 있으며, 회수가 필요한 작업이 수행되지 않는 경우에도 그렇게 할 수 있습니다.

\* 예를 들어 다른 프로토콜에 의한 액세스 또는 로컬 액세스로 인해 NFSv4.1 프로토콜 외부에서 수행된 작업은 파일 시스템 데이터를 유사하게 변경할 때 위임 회수를 발생시켜야 합니다. 중요한 것은 변경으로 인해 대표단이 제공한 보증이 무효화되는지 여부입니다. 이것이 가능하다면 위임을 회수해야 하며 작업을 계속하기 전에 위임을 반환하거나 취소해야 합니다.\(MUST\)

\* 파일 시스템의 의미는 위임 회수가 필요한 시기를 정의하는 데 중요합니다. 특정 구현 내의 특정 변경으로 인해 파일 속성이 변경되는 경우 해당 작업이 위임 회수를 요구하는 것으로 구체적으로 나열되었는지 여부에 관계없이 위임 회수가 필요합니다. 여기서도 중요한 것은 대표단이 제공한 보증이 무효화되는지 여부이다.

이러한 주의 사항에도 불구하고 여러 작업에 대한 구현 섹션에서는 몇 가지 일반적인 상황에서 위임 회수가 필요한 상황을 설명합니다.

\* GETATTR에 대해서는 섹션 18.7.4를 참조하세요.

\* OPEN에 대해서는 18.16.4항을 참조하십시오.

\* READ에 대해서는 18.22.4항을 참조하십시오.

\* REMOVE에 대해서는 섹션 18.25.4를 참조하십시오.

\* RENAME에 대해서는 섹션 18.26.4를 참조하세요.

\* SETATTR에 대해서는 섹션 18.30.4를 참조하세요.

\* WRITE에 대해서는 18.32.4항을 참조하세요.

회수 시 위임을 보유한 클라이언트는 수정된 상태\(예: 수정된 데이터\)를 서버에 플러시하고 위임을 반환해야 합니다. 회수가 완료될 때까지 충돌하는 요청은 처리되지 않습니다. 클라이언트가 위임을 반환하거나 서버가 위임이 반환될 때까지 대기 시간을 초과하고 시간 초과로 인해 위임을 취소하면 회수가 완료된 것으로 간주됩니다. 그 사이에 서버는 충돌하는 요청에 대한 응답을 지연하거나 NFS4ERR\_DELAY로 응답합니다. 회수 해결 후 서버는 두 번째 클라이언트의 요청을 승인하거나 거부하는 데 필요한 정보를 갖게 됩니다.

클라이언트가 위임 회수를 수신할 때 서버에 플러시해야 하는 실질적인 상태가 있을 수 있습니다. 따라서 서버에 대한 수많은 RPC가 포함될 수 있으므로 서버는 위임이 반환될 때까지 충분한 시간을 허용해야 합니다. 클라이언트가 회수 결과에 따라 상태를 서버에 부지런히 플러시하고 있음을 서버에서 확인할 수 있는 경우 서버는 회수에 허용되는 일반적인 시간을 연장할 수 있습니다. 그러나 회수 완료에 허용되는 시간은 제한이 없어야 합니다.

이에 대한 예는 특정 파일에 대한 열기를 중재하는 책임이 클라이언트에 위임되는 경우입니다\(섹션 10.4 참조\). 서버는 클라이언트에 어떤 열기가 적용되는지 알 수 없습니다. 이 지식이 없으면 서버는 파일에 대한 위임이 반환될 때까지 파일에 대한 액세스 및 거부 상태가 특정 열기를 허용하는지 확인할 수 없습니다.

클라이언트 오류 또는 네트워크 파티션으로 인해 회수 콜백에 응답하지 못할 수 있습니다. 이 경우 서버는 위임을 취소하고 클라이언트에 남아 있는 모든 수정된 상태를 쓸모 없게 만듭니다.

---
#### **10.2.1.  Delegation Recovery**

위임 복구에서 처리해야 하는 세 가지 상황은 다음과 같습니다.

```text
   *  client restart

   *  server restart

   *  network partition (full or backchannel-only)
```

클라이언트가 다시 시작되는 경우 임대 갱신에 실패하면 바이트 범위 잠금 및 공유 예약이 취소됩니다. 그러나 위임은 약간 다르게 처리될 수 있습니다.

클라이언트가 다시 시작된 후 위임을 다시 설정해야 하는 상황이 있습니다. 그 이유는 클라이언트가 로컬에 저장된 파일 데이터를 가지고 있을 수 있고 이 데이터가 이전에 보유한 위임과 연관되어 있기 때문입니다. 클라이언트는 서버에서 적절한 파일 상태를 다시 설정해야 합니다.

이러한 유형의 클라이언트 복구를 허용하기 위해 서버는 위임 복구 기간을 일반적인 임대 만료 기간 이상으로 연장할 수 있습니다. 이는 이러한 위임과 충돌하는 다른 클라이언트의 요청이 기다려야 함을 의미합니다. 일반적인 회수 프로세스에서는 클라이언트가 변경된 상태를 서버에 플러시하는 데 상당한 시간이 필요할 수 있으므로 다른 클라이언트는 위임 충돌로 인해 발생하는 지연에 대비해야 합니다. 간격이 길어지면 클라이언트가 다시 시작하고 안정적인 저장소를 참조하여 위임을 회수할 수 있는 기간이 늘어납니다. OPEN 위임의 경우 이러한 위임은 CLAIM\_DELEGATE\_PREV 또는 CLAIM\_DELEG\_PREV\_FH 클레임 유형과 함께 OPEN을 사용하여 회수됩니다\(OPEN 위임 및 OPEN 세부 사항에 대한 논의는 각각 섹션 10.5 및 18.16 참조\).\(MAY\)

서버는 CLAIM\_DELEGATE\_PREV 및 CLAIM\_DELEG\_PREV\_FH의 클레임 유형을 지원할 수 있으며, 지원하는 경우 EXCHANGE\_ID에 의해 생성된 클라이언트 ID를 확인하는 CREATE\_SESSION 시 위임을 제거해서는 안 됩니다. 대신 서버는 Lease\_time 속성 값 이상의 기간 동안 클라이언트가 CLAIM\_DELEGATE\_PREV 및/또는 CLAIM\_DELEG\_PREV\_FH 요청을 보낼 수 있는 시간을 허용하도록 클라이언트의 위임을 유지해야 합니다. CLAIM\_DELEGATE\_PREV 및/또는 CLAIM\_DELEG\_PREV\_FH를 지원하는 서버는 DELEGPURGE 작업을 지원해야 합니다.\(MUST NOT, MUST, MUST\)

서버가 다시 시작되면 바이트 범위 잠금 및 공유 예약과 유사한 방식으로 위임이 회수됩니다\(CLAIM\_PREVIOUS와 함께 OPEN 작업 사용\). 그러나 의미상 약간의 차이가 있습니다. 일반적인 경우 서버는 위임을 허용하지 않아야 한다고 결정하면 위임을 허용하지 않고 요청된 작업\(예: OPEN\)을 수행합니다. 회수의 경우 서버는 위임을 승인하지만 클라이언트는 위임이 서버에 의해 회수되었지만 위임이 회수된 것으로 처리하도록 특별한 지정이 적용됩니다. 이 때문에 클라이언트는 수정된 모든 상태를 서버에 쓴 다음 위임을 반환해야 할 의무가 있습니다. 위임 회수를 처리하는 이 프로세스는 NFSv4.1 프로토콜의 세 가지 원칙을 조화시킵니다.

\* 회수 시 이전 서버 인스턴스에 의해 할당된 클라이언트 보고 리소스에는 해당 리소스가 부여되어야 합니다.

\* 서버는 위임이 허용되는지 여부와 일단 허용되면 위임이 계속되는지 여부를 결정할 수 있는 확실한 권한을 가지고 있습니다.

\* 클라이언트가 콜백 수신 능력을 입증할 때까지 콜백 사용에 의존해서는 안 됩니다.

클라이언트가 위임을 회수해야 하고 관련 공개가 없는 경우 클라이언트는 WANT\_DELEGATION 작업의 CLAIM\_PREVIOUS 변형을 사용할 수 있습니다. 그러나 서버는 이 작업을 지원할 필요가 없으므로 대안은 CLAIM\_PREVIOUS 유형의 OPEN을 사용하는 위임과 함께 더미 OPEN을 통해 회수하는 것입니다. 더미 열린 파일은 CLOSE를 사용하여 해제되어 회수할 원래 상태를 다시 설정할 수 있으며, 관련 열기 없이 위임할 수 있습니다.

클라이언트에 위임과 관련된 열기가 두 개 이상 있는 경우 CLAIM\_DELEGATE\_CUR 유형의 OPEN 작업을 사용하여 추가 열기에 대한 상태를 설정할 수 있습니다. 이것이 회수된 위임과 관련된 열기를 설정하는 데 사용되는 경우 서버는 유예 기간 내에 이를 허용해야 합니다.\(MUST\)

네트워크 분할이 발생하면 임대 갱신 기간이 만료되면 서버에서 위임을 해제할 수 있습니다. 이는 잠금 및 공유 예약의 동작과 유사합니다. 그러나 위임의 경우 서버는 충돌하는 요청이 보류되는 기간을 연장할 수 있습니다. 결국 다른 클라이언트로부터 충돌하는 요청이 발생하면 위임이 취소됩니다. 백채널 손실\(예: 나중에 네트워크 구성 변경으로 인해\)도 동일한 효과를 갖습니다. 회수 요청이 실패하고 위임이 취소됩니다.

클라이언트는 일반적으로 위임과 연결된 stateid를 사용하고 NFS4ERR\_EXPIRED, NFS4ERR\_ADMIN\_REVOKED 또는 NFS4ERR\_DELEG\_REVOKED 오류 중 하나를 수신할 때 위임 취소에 대해 알아냅니다. 또한 클라이언트를 다시 시작한 후 위임을 회수하려고 시도하고 동일한 오류가 수신되면 위임 취소에 대해 알아낼 수도 있습니다. OPEN\_DELEGATE\_WRITE 위임이 취소된 경우에는 위임이 취소된 클라이언트와 다른 클라이언트가 별도로 데이터를 수정했을 수 있으므로 문제가 있습니다. 그러한 문제에 대한 논의는 섹션 10.5.1을 참조하십시오. 또한 위임이 취소되면 취소된 위임에 대한 정보가 서버에 의해 안정적인 저장소에 기록됩니다\(섹션 8.4.3에 설명됨\). 이는 위임을 취소한 후 취소된 위임을 보유하고 있는 클라이언트에게 취소 사실이 통보되기 전에 서버가 다시 시작되는 경우를 처리하기 위해 수행됩니다.

---
### **10.3.  Data Caching**

응용 프로그램이 파일 집합에 대한 액세스를 공유하는 경우 다른 응용 프로그램의 액세스 충돌 가능성을 고려하여 구현해야 합니다. 이는 문제의 응용 프로그램이 다른 클라이언트에서 실행되거나 동일한 클라이언트에 상주하는지 여부에 관계없이 적용됩니다.

공유 예약 및 바이트 범위 잠금은 애플리케이션이 상호 배제 기능을 사용하여 액세스를 조정할 수 있도록 NFSv4.1 프로토콜이 제공하는 기능입니다. NFSv4.1 프로토콜의 데이터 캐싱은 이러한 기능을 사용하는 사람들이 의존하는 가정을 무효화하지 않도록 구현되어야 합니다.

---
#### **10.3.1.  Data Caching and OPENs**

애플리케이션이 의존하는 공유 가정이 무효화되는 것을 방지하기 위해 NFSv4.1 클라이언트는 READ 또는 WRITE를 통해 동일한 데이터를 얻거나 수정하는 것이 유효하지 않은 경우 캐시된 데이터를 애플리케이션에 제공하거나 애플리케이션을 대신하여 수정해서는 안 됩니다. 작업.

또한 OPEN 위임이 없는 경우\(섹션 10.4 참조\) 두 가지 추가 규칙이 적용됩니다. 이러한 규칙은 실제로 많은 NFSv3 클라이언트에서 준수됩니다.

\* 먼저 OPEN을 수행한 후 클라이언트에 캐시된 데이터를 재검증해야 합니다. 재검증이란 클라이언트가 서버에서 변경 속성을 가져와 캐시된 변경 속성과 비교하고, 다를 경우 캐시된 데이터\(및 캐시된 속성\)를 유효하지 않은 것으로 선언하는 것을 의미합니다. 이는 OPEN된 파일의 데이터가 여전히 클라이언트 캐시에 올바르게 반영되도록 하기 위한 것입니다. 이 유효성 검사는 최소한 클라이언트의 OPEN 작업에 OPEN4\_SHARE\_DENY\_WRITE 또는 OPEN4\_SHARE\_DENY\_BOTH 거부가 포함되어 다른 클라이언트가 OPEN4\_SHARE\_ACCESS\_WRITE/OPEN4\_SHARE\_ACCESS\_BOTH 액세스 권한으로 파일을 열 수 있는 기간을 종료하는 경우 수행되어야 합니다. 클라이언트는 이 수준의 캐시 재검증을 가정하는 사용자의 이익을 위해 NFSv3 프로토콜의 실행과 병행하기 위해 재검증을 더 자주\(즉, OPEN4\_SHARE\_DENY\_NONE의 거부 모드를 지정하는 OPEN에서\) 수행하도록 선택할 수 있습니다.

- 변경 속성은 데이터 및 메타데이터 수정에 대해 업데이트되므로 일부 클라이언트 구현자는 캐시된 데이터의 유효성을 검사하기 위해 변경 속성이 아닌 time\_modify 속성을 사용하여 메타데이터 변경으로 인해 순수 데이터가 무효화되지 않도록 유혹을 받을 수 있습니다. 구현자는 이 접근 방식에 대해 주의를 받습니다. 변경 속성은 파일이 업데이트될 때마다 변경되도록 보장되는 반면, time\_modify는 time\_delta 속성의 세분성에서만 변경되도록 보장됩니다. 클라이언트의 데이터 캐시 검증 로직인 time\_modify를 변경하지 않고 사용하면 클라이언트가 오래된 데이터를 유효한 것으로 잘못 표시할 위험이 있습니다. 따라서 클라이언트의 모든 캐시 유효성 검사 접근 방식에는 변경 속성의 사용이 포함되어야 합니다.\(MUST\)

\* 둘째, OPEN4\_SHARE\_ACCESS\_WRITE에 대해 OPEN된 파일을 닫기 전에 수정된 데이터를 서버로 플러시해야 합니다. 이는 첫 번째 규칙을 보완합니다. CLOSE 시 데이터가 플러시되지 않으면 클라이언트가 파일을 OPEN한 후 수행된 유효성 재검사는 해당 목적을 달성할 수 없습니다. 닫기 전에 데이터를 플러시하는 또 다른 측면은 클라이언트가 CLOSE 작업을 요청하기 전에 데이터를 서버의 안정적인 저장소에 커밋해야 한다는 것입니다. 서버가 다시 시작되고 파일이 닫힌 경우 파일에 쓸 데이터를 재전송하지 못할 수 있으므로 이 요구 사항이 적용됩니다.

---
#### **10.3.2.  Data Caching and File Locking**

일관되지 않은 파일 액세스를 제외하기 위해 공유 예약 대신 바이트 범위 잠금을 사용하도록 선택한 애플리케이션의 경우 클라이언트 측 데이터 캐싱에 적용되는 유사한 제약 조건 세트가 있습니다. 이러한 규칙은 실제 READ 및 WRITE 작업이 실행되는 것과 동일한 방식으로 바이트 범위 잠금이 사용되는 경우에만 유효합니다. 이는 순수 규칙을 기반으로 하는 바이트 범위 잠금과 반대입니다. 예를 들어, 파일을 두 개의 1MB 범위로 나누고 바이트 0과 1에 대한 바이트 범위 잠금을 통해 두 바이트 범위에 대한 액세스를 보호함으로써 2MB 파일을 조작할 수 있습니다. 파일의 바이트 0에 대한 WRITE\_LT 잠금은 첫 번째 바이트 범위에서 READ 및 WRITE 작업을 수행할 수 있는 권한을 나타냅니다. 파일의 첫 번째 바이트에 대한 WRITE\_LT 잠금은 두 번째 바이트 범위에서 읽기 및 쓰기 작업을 수행할 수 있는 권한을 나타냅니다. 파일을 조작하는 모든 응용 프로그램이 이 규칙을 준수하는 한 로컬 파일 시스템에서 작동합니다. 그러나 클라이언트가 데이터 캐싱을 삼가하지 않는 한 NFSv4.1 프로토콜에서는 작동하지 않을 수 있습니다.

바이트 범위 잠금 환경의 데이터 캐싱 규칙은 다음과 같습니다.

\* 먼저 클라이언트가 특정 바이트 범위에 대한 바이트 범위 잠금을 획득하면 해당 바이트 범위에 해당하는 데이터 캐시\(캐시 데이터가 있는 경우\)를 재검증해야 합니다. 변경 속성이 캐시된 데이터를 얻은 이후 파일이 업데이트되었을 수 있음을 나타내는 경우 클라이언트는 새로 잠긴 바이트 범위에 대해 캐시된 데이터를 플러시하거나 무효화해야 합니다. 클라이언트는 파일에 대해 수정되지 않은 캐시된 데이터를 모두 무효화하도록 선택할 수 있지만 올바른 작업을 위한 유일한 요구 사항은 새로 잠긴 바이트 범위의 모든 데이터를 무효화하는 것입니다.

\* 둘째, 바이트 범위에 대한 WRITE\_LT 잠금을 해제하기 전에 해당 바이트 범위에 대해 수정된 모든 데이터를 서버로 플러시해야 합니다. 수정된 데이터는 안정적인 저장소에도 기록되어야 합니다.

데이터를 서버로 플러시하고 캐시된 데이터를 무효화하려면 잠기거나 잠금 해제된 실제 바이트 범위가 반영되어야 합니다. 클라이언트 캐시 블록 경계를 반영하기 위해 이를 반올림하거나 내림하면 주의 깊게 수행하지 않으면 문제가 발생할 수 있습니다. 예를 들어, 해당 블록의 절반만 잠금 해제되는 영역 내에 있을 때 수정된 블록을 쓰면 잠금 해제된 영역 외부의 바이트 범위에 잘못된 수정이 발생할 수 있습니다. 이는 결국 다른 클라이언트에 의해 잠긴 바이트 범위의 일부일 수 있습니다. 클라이언트는 전체 블록이 아닌 부분\(초기 또는 최종\)과 겹치는 WRITE 작업 부분을 동기적으로 수행하여 이러한 상황을 피할 수 있습니다. 마찬가지로, 전체 버퍼 블록의 정수수가 아닌 잠긴 영역을 무효화하려면 클라이언트가 소유한 데이터가 유효하지 않을 수 있다는 재검증 절차를 통해 클라이언트가 서버에서 하나 또는 두 개의 부분 블록을 읽어야 합니다.

바이트 범위 잠금 해제의 전제 조건으로 서버에 기록되는 데이터는 서버에서 안정적인 저장소에 기록되어야 합니다. 클라이언트는 동기 쓰기를 사용하거나 COMMIT 작업을 통한 비동기 쓰기를 수행하여 이를 수행할 수 있습니다. 이는 서버를 다시 시작한 후 수정된 데이터를 재전송하면 다른 클라이언트가 보유한 잠금과 충돌할 수 있기 때문에 필요합니다.

클라이언트 구현은 LOCKU 시 잠긴 범위에 포함된 것보다 더 많은 데이터를 서버에 플러시하여 비표준 방식\(예: 바이트 범위 잠금을 전역 세마포로 사용\)으로 바이트 범위 잠금을 사용하는 애플리케이션을 수용하도록 선택할 수 있습니다. . 여기에는 잠금 해제가 수행되는 파일이 아닌 다른 파일 내의 수정된 데이터가 포함될 수 있습니다. 이러한 경우 클라이언트는 애플리케이션이 보유한 바이트 범위 잠금 범위 내에서만 읽기 및 쓰기가 수행되는 애플리케이션을 방해해서는 안 됩니다. 예를 들어, 애플리케이션은 파일의 단일 바이트를 잠그고 계속해서 해당 단일 바이트를 씁니다. 수정된 모든 데이터를 서버에 플러시하여 LOCKU를 처리하기로 선택한 클라이언트는 관련 없는 LOCKU 작업에 대한 응답으로 해당 단일 바이트를 유효하게 쓸 수 있습니다. 그러나 기록된 단일 바이트가 위치한 전체 블록을 기록하는 것은 유효하지 않습니다. 왜냐하면 여기에는 잠겨 있지 않고 다른 클라이언트에 의해 잠겨 있을 수 있는 영역이 포함되어 있기 때문입니다. 클라이언트 구현은 수정된 데이터가 있는 파일을 적절한 바이트 범위 잠금이 적용되는 영역에 대해 모든 수정이 수행되는 파일과 바이트 범위 잠금이 적용되지 않는 수정이 있는 파일로 나누어 이 문제를 피할 수 있습니다. 이전 파일 클래스에 대해 수행된 모든 쓰기에는 잠기지 않아 클라이언트에서 수정되지 않은 영역이 포함되어서는 안 됩니다.

---
#### **10.3.3.  Data Caching and Mandatory File Locking**

클라이언트 측 데이터 캐싱은 적용될 때 필수 바이트 범위 잠금을 준수해야 합니다. 특정 파일에 대한 필수 바이트 범위 잠금이 있음은 클라이언트가 적절한 공유 예약이 있는 파일에 대한 읽기 또는 쓰기 작업에서 NFS4ERR\_LOCKED를 다시 얻을 때 표시됩니다. 파일에 필수 잠금이 적용되면 클라이언트는 읽거나 쓰는 데이터에 대해 적절한 바이트 범위 잠금이 있는지 확인해야 합니다. 읽거나 쓰는 범위에 대해 바이트 범위 잠금이 존재하는 경우 클라이언트는 클라이언트의 검증된 캐시를 사용하여 요청을 충족할 수 있습니다. 읽기 또는 쓰기 범위에 대해 적절한 바이트 범위 잠금이 유지되지 않으면 클라이언트 캐시에서 읽기 또는 쓰기 요청을 충족할 수 없으며 처리를 위해 요청을 서버로 보내야 합니다. 읽기 또는 쓰기 요청이 잠긴 바이트 범위와 부분적으로 겹치는 경우 요청은 각 바이트 범위\(잠금 여부\)를 적절하게 처리하여 여러 조각으로 나누어야 합니다.

---
#### **10.3.4.  Data Caching and File Identity**

클라이언트가 데이터를 캐시할 때 파일 데이터는 해당 데이터가 속한 파일 시스템 개체에 따라 구성되어야 합니다. NFSv3 클라이언트의 경우 캐싱을 위해 고유한 파일 핸들이 고유한 파일 시스템 개체를 나타낸다고 가정하는 것이 일반적인 관행이었습니다. 그러면 클라이언트는 이를 기반으로 데이터 캐시를 구성하고 유지 관리할 수 있습니다.

NFSv4.1 프로토콜에서는 파일 핸들이 객체의 경로 이름을 기반으로 구성될 수 있기 때문에 "객체당 하나의 파일 핸들" 모델에서 크게 벗어날 가능성이 있습니다. 따라서 클라이언트에는 두 개의 파일 핸들이 동일한 파일 시스템 개체를 지정하는지 확인하는 안정적인 방법이 필요합니다. 클라이언트가 단순히 모든 고유한 파일 핸들이 고유한 개체를 나타낸다고 가정하고 이를 기반으로 데이터 캐싱을 진행하면 동일한 서버측 개체에 매핑된 고유한 클라이언트측 개체 간에 캐싱 불일치가 발생할 수 있습니다.

NFSv4.1 프로토콜은 파일 핸들을 구별하는 방법을 제공함으로써 NFSv3 프로토콜과 비교하여 잠재적인 기능 회귀를 완화합니다. 이 방법이 없으면 동일한 클라이언트 내에서 캐싱 불일치가 발생할 수 있으며 이는 이전 버전의 NFS 프로토콜에서는 발생하지 않았습니다. 여러 클라이언트에서 실행되는 응용 프로그램에서 이러한 불일치가 발생할 수 있지만 여기서는 해당 문제를 다루지 않습니다.

데이터 캐싱을 위해 다음 단계를 통해 NFSv4.1 클라이언트는 두 개의 서로 다른 파일 핸들이 동일한 서버 측 개체를 나타내는지 여부를 확인할 수 있습니다.

\* 두 개의 파일 핸들로 전달된 GETATTR이 fsid 속성의 서로 다른 값을 반환하는 경우 파일 핸들은 고유한 개체를 나타냅니다.

\* 문제의 두 파일 핸들의 fsid와 일치하는 fsid가 있는 파일에 대한 GETATTR이 값이 TRUE인 Unique\_handles 속성을 반환하는 경우 두 개체는 서로 다릅니다.

\* 두 개의 파일 핸들로 전달된 GETATTR이 두 핸들 모두에 대한 fileid 속성을 반환하지 않으면 두 개체가 동일한지 여부를 확인할 수 없습니다. 따라서 해당 지식\(예: 클라이언트 측 데이터 캐싱\)에 의존하는 작업을 안정적으로 수행할 수 없습니다. GETATTR이 두 파일 핸들 모두에 대해 fileid 속성을 반환하지 않는 경우 두 파일 핸들의 fsid가 동일하므로 두 파일 핸들 중 어느 쪽에도 해당 속성을 반환하지 않습니다.

\* 두 개의 파일 핸들로 전달된 GETATTR이 fileid 속성에 대해 서로 다른 값을 반환하는 경우 해당 두 파일 핸들은 별개의 개체입니다.

\* 그렇지 않으면 동일한 객체입니다.

---
### **10.4.  Open Delegation**

파일이 열려 있는 동안 서버는 해당 파일에 대한 열기 및 닫기의 추가 처리를 열기 클라이언트에 위임할 수 있습니다. 위임을 허용하는 상황은 변경될 수 있으므로 그러한 위임은 취소 가능합니다. 특히 서버가 다른 클라이언트로부터 충돌하는 OPEN을 수신하는 경우 서버는 다른 클라이언트의 OPEN이 승인될 수 있는지 여부를 결정하기 전에 위임을 회수해야 합니다. 위임을 하는 것은 서버에 달려 있으며 클라이언트는 특정 OPEN이 OPEN 위임을 초래하거나 발생하지 않을 것이라고 가정해서는 안 됩니다. 다음은 OPEN을 위임해야 하는지 여부를 결정할 때 서버가 사용할 수 있는 일반적인 조건 집합입니다.

\* 클라이언트는 서버의 콜백 요청에 응답할 수 있어야 합니다. 백채널이 설정된 경우 서버는 백채널 가용성 테스트를 위해 단일 작업 CB\_SEQUENCE가 포함된 CB\_COMPOUND 요청을 보냅니다.

\* 고객은 이전 리콜에 대해 올바르게 응답해야 합니다.

\* 요청한 위임과 충돌하는 현재 OPEN이 없어야 합니다.

\* 현재 요청 중인 위임과 충돌하는 위임이 없어야 합니다.

\* 파일의 최근 기록을 기준으로 향후 열기 요청이 충돌할 확률은 낮아야 합니다.

\* 필요한 처리가 위임된 클라이언트가 적용할 규정된 처리와 호환되지 않게 만드는 OPEN/CLOSE의 서버별 의미 체계가 존재합니다\(아래 참조\).

OPEN 위임에는 OPEN\_DELEGATE\_READ와 OPEN\_DELEGATE\_WRITE의 두 가지 유형이 있습니다. OPEN\_DELEGATE\_READ 위임을 사용하면 클라이언트가 다른 사람의 OPEN4\_SHARE\_ACCESS\_READ 액세스를 거부하지 않는 읽기용 파일 열기 요청을 자체적으로 처리할 수 있습니다. 여러 OPEN\_DELEGATE\_READ 위임이 동시에 처리될 수 있으며 충돌하지 않습니다. OPEN\_DELEGATE\_WRITE 위임을 사용하면 클라이언트가 모든 열기를 자체적으로 처리할 수 있습니다. 특정 시간에 특정 파일에 대해 하나의 OPEN\_DELEGATE\_WRITE 위임만 존재할 수 있으며 이는 OPEN\_DELEGATE\_READ 위임과 일치하지 않습니다.

클라이언트가 OPEN\_DELEGATE\_READ 위임을 갖고 있는 경우, 위임이 유지되는 한 내용, 속성\(time\_access 제외\), 파일에 대한 링크 이름은 클라이언트가 알지 못하는 사이에 변경되지 않습니다. 클라이언트에 OPEN\_DELEGATE\_WRITE 위임이 있으면 다른 클라이언트가 파일 데이터에 액세스하지 않으므로 로컬에서 파일 데이터를 수정할 수 있습니다. OPEN\_DELEGATE\_WRITE 위임을 보유한 클라이언트는 파일 데이터와 밀접하게 연결된 파일 속성\(크기, 변경, time\_access, time\_metadata 및 time\_modify\)에만 로컬로 영향을 미칠 수 있습니다. 다른 모든 속성은 서버에 반영되어야 합니다.

클라이언트에 OPEN 위임이 있으면 OPEN 또는 CLOSE를 서버에 보낼 필요가 없습니다. 대신 클라이언트는 내부적으로 적절한 상태를 업데이트할 수 있습니다. OPEN\_DELEGATE\_READ 위임의 경우 로컬로 처리할 수 없는 열기\(OPEN4\_SHARE\_ACCESS\_WRITE/OPEN4\_SHARE\_ACCESS\_BOTH용 열기 또는 OPEN4\_SHARE\_ACCESS\_READ 액세스를 거부하는 열기\)를 서버로 보내야 합니다.

OPEN 위임이 이루어지면 OPEN에 대한 응답에는 다음을 지정하는 OPEN 위임 구조가 포함됩니다.

\* 위임 유형\(OPEN\_DELEGATE\_READ 또는

- OPEN\_DELEGATE\_WRITE\).

```text
   *  space limitation information to control flushing of data on close
      (OPEN_DELEGATE_WRITE delegation only; see Section 10.4.1)
```

\* 읽기 및 쓰기 권한을 지정하는 nfsace4

\* 대표단을 대표하는 stateid

위임 stateid는 OPEN 고유의 stateid와는 별개입니다. 위임 stateid와 달리 표준 stateid는 특정 잠금 소유자와 연결되어 있으며 위임이 회수되고 파일이 열린 후에도 계속 유효합니다.

클라이언트 내부에서 파일 열기 요청이 이루어지고 OPEN 위임이 유효한 경우 다음 조건에 따라서만 해당 요청이 수락되거나 거부됩니다. 대리인이 수행해야 하는 다른 검사에 대한 요구 사항은 서버 자체에서 검사를 수행할 수 있도록 OPEN 위임이 거부되는 결과를 가져옵니다.

\* 요청 및 파일에 대한 액세스 및 거부 비트는 섹션 9.7에 설명되어 있습니다.

\* 읽기 및 쓰기 권한은 아래와 같이 결정됩니다.

위임과 함께 전달된 nfsace4를 사용하면 빈번한 ACCESS 호출을 피할 수 있습니다. 권한 확인은 다음과 같아야 합니다.

\* nfsace4가 열기가 완료될 수 있음을 나타내는 경우 서버를 참조하지 않고 승인되어야 합니다.

\* nfsace4에서 열기가 수행되지 않을 수 있음을 나타내는 경우 최종 응답을 얻기 위해 ACCESS 요청을 서버로 보내야 합니다.

서버는 파일의 실제 ACL보다 더 제한적인 nfsace4를 반환할 수 있습니다. 여기에는 모든 액세스 거부를 지정하는 nfsace4가 포함됩니다. 기존 사용자 "root"를 사용자 "nobody"\(섹션 5.9 참조\)로 매핑하는 것과 같은 일부 일반적인 관행에서는 위임 응답에서 파일의 실제 ACL을 반환하는 것이 올바르지 않을 수 있습니다.

다양한 다른 형태의 캐싱과 함께 위임을 사용하면 사용자의 모든 요청이 로컬에서 충족될 수 있으므로 특정 사용자에 대해 서버 인증 및 권한 부여가 수행되지 않을 가능성이 생깁니다. 클라이언트가 인증 및 권한 부여를 서버에 의존하는 경우 클라이언트는 ACCESS 작업을 사용하여 각 사용자에 대해 인증 및 권한 부여가 발생하는지 확인해야 합니다. 그렇지 않으면 ACCESS 작업이 필요하지 않은 경우에도 마찬가지입니다. 앞서 언급했듯이 서버는 모든 OPEN 위임에 대해 모든 액세스를 거부하는 nfsace4를 반환하여 빈번한 인증을 시행할 수 있습니다.

---
#### **10.4.1.  Open Delegation and Data Caching**

OPEN 위임을 사용하면 파일 열기 및 닫기와 관련된 메시지 오버헤드의 대부분을 제거할 수 있습니다. OPEN 위임이 적용될 때 열기에는 유효성 검사 메시지를 서버로 보낼 필요가 없습니다. "OPEN\_DELEGATE\_READ 위임"의 지속적인 지속은 OPEN4\_SHARE\_ACCESS\_WRITE/OPEN4\_SHARE\_ACCESS\_BOTH에 대한 OPEN이 발생하지 않음을 보장하므로 쓰기가 발생하지 않습니다. 마찬가지로, OPEN4\_SHARE\_ACCESS\_WRITE/OPEN4\_SHARE\_ACCESS\_BOTH에 대해 열린 파일을 닫고 OPEN\_DELEGATE\_WRITE 위임이 적용되는 경우 기록된 데이터는 OPEN 위임이 회수될 때까지 서버에 기록될 필요가 없습니다. OPEN 위임의 지속적인 인내는 다른 클라이언트가 열기, 즉 읽기 또는 쓰기를 수행하지 않았음을 보장합니다.

OPEN 위임의 경우 OPEN 없이 수행된 읽기 및 쓰기는 해당 유형의 OPEN과 기능적으로 동등한 것으로 처리됩니다. 클라이언트는 공개가 존재할 때 특수 상태 ID를 사용해서는 안 되지만, 서버에서의 위임 처리는 현재 세션과 연관된 클라이언트 ID를 사용하여 위임 소유자가 해당 작업을 수행했는지 확인할 수 있습니다\(이 경우 리콜은 없습니다\). 필요한 경우\) 또는 다른 클라이언트에 의해 수행됩니다\(이 경우 위임을 회수해야 하며 위임이 반환되거나 취소될 때까지 I/O가 진행되지 않습니다\).\(SHOULD NOT\)

위임을 사용하면 클라이언트는 파일 CLOSE가 서비스될 때 서버에 데이터를 쓰는 것을 피할 수 있습니다. 파일 닫기 시스템 호출은 애플리케이션에서 생성된 수정된 파일 데이터에 대한 안정적인 저장소가 부족하다는 알림을 클라이언트에 알리는 일반적인 지점입니다. 종료 시 파일 데이터가 서버에 기록되고 일반 계정을 통해 서버는 데이터에 사용 가능한 파일 시스템 공간이 초과되었는지 확인할 수 있습니다\(즉, 서버가 NFS4ERR\_NOSPC 또는 NFS4ERR\_DQUOT를 반환함\). 이 회계에는 할당량이 포함됩니다. 위임을 도입하려면 클라이언트와 서버 간에 동일한 유형의 통신이 발생하도록 대체 방법을 마련해야 합니다.

위임 응답에서 서버는 파일 크기 제한이나 수정된 ​​블록 수 및 관련 블록 크기를 제공합니다. 서버는 클라이언트가 원래 위임에 제공된 것과 동일한 크기의 수정된 데이터를 서버에 쓸 수 있는지 확인해야 합니다. 서버는 모든 미결 위임에 대해 이러한 보증을 해야 합니다. 따라서 서버는 사용 가능한 파일 시스템 공간과 적용 가능한 할당량을 고려하여 새 데이터나 수정된 ​​데이터에 사용 가능한 공간을 주의 깊게 관리해야 합니다. 서버는 사용 가능한 파일 시스템 공간을 관리한 결과 위임을 회수할 수 있습니다. 클라이언트는 위임을 위한 서버의 상태 공간 제한을 준수해야 합니다. 클라이언트가 위임에 대해 명시된 제한을 초과하는 경우 서버의 동작은 정의되지 않습니다.

서버 조건, 할당량 또는 사용 가능한 파일 시스템 공간에 따라 서버는 매우 제한적인 공간 제한을 통해 OPEN\_DELEGATE\_WRITE 위임을 부여할 수 있습니다. 수정된 데이터가 서버를 닫을 때 항상 강제로 플러시되는 방식으로 제한 사항을 정의할 수 있습니다.

인증과 관련하여 CLOSE가 발생한 후 수정된 데이터를 서버에 플러시하는 것은 문제가 될 수 있습니다. 예를 들어, 응용 프로그램 사용자가 클라이언트에서 로그오프했을 수 있으며 만료되지 않은 인증 자격 증명이 없을 수 있습니다. 이 경우 클라이언트는 만료되지 않은 로컬 자격 증명을 실제로 사용할 수 있도록 특별한 주의를 기울여야 할 수도 있습니다. 이는 자격 증명의 만료 시간을 추적하고 만료되기 훨씬 전에 데이터를 플러시하거나 필요할 때 가용성을 보장하기 위해 자격 증명의 개인 복사본을 만들어 수행할 수 있습니다.

---
#### **10.4.2.  Open Delegation and File Locks**

클라이언트가 OPEN\_DELEGATE\_WRITE 위임을 보유하면 잠금 작업이 로컬로 수행됩니다. 여기에는 필수 바이트 범위 잠금에 필요한 항목이 포함됩니다. 위임은 충돌하는 잠금이 있을 수 없음을 암시하므로 이는 수행될 수 있습니다. 마찬가지로 일반적으로 잠금 획득 및 잠금 해제와 관련된 데이터 플러시와 관련된 모든 재검증을 수행할 필요가 없습니다.

클라이언트가 OPEN\_DELEGATE\_READ 위임을 보유하면 잠금 작업이 로컬로 수행되지 않습니다. 비독점 잠금 요청을 포함한 모든 잠금 작업은 해결을 위해 서버로 전송됩니다.

---
#### **10.4.3.  Handling of CB_GETATTR**

서버는 대상이 OPEN\_DELEGATE\_WRITE 위임이 유효한 파일인 GETATTR에 대해 특별한 처리를 사용해야 합니다. 그 이유는 OPEN\_DELEGATE\_WRITE 위임을 보유한 클라이언트가 데이터를 수정했을 수 있으며 서버는 이 변경 사항을 GETATTR을 제출한 두 번째 클라이언트에 반영해야 하기 때문입니다. 따라서 OPEN\_DELEGATE\_WRITE 위임을 보유한 클라이언트를 조사해야 합니다. 서버는 CB\_GETATTR 작업을 사용합니다. 서버가 CB\_GETATTR을 통해 안정적으로 쿼리할 수 있는 유일한 속성은 크기와 변경입니다.

CB\_GETATTR은 다른 클라이언트의 GETATTR 요청을 충족하는 데 사용되므로 서버는 위임을 보유한 클라이언트가 파일의 수정된 버전을 가지고 있는지만 알면 됩니다. 클라이언트의 위임된 파일 복사본이 수정되지 않은 경우\(데이터 또는 크기\) 서버는 서버에 로컬로 저장된 속성을 사용하여 두 번째 클라이언트의 GETATTR 요청을 충족할 수 있습니다. 파일이 수정되면 서버는 이 수정된 상태에 대해서만 알면 됩니다. 서버가 파일이 현재 수정되었다고 판단하면 파일이 서버에서 로컬로 수정된 것처럼 두 번째 클라이언트의 GETATTR에 응답합니다.

변경 속성의 형식은 서버에 의해 결정되고 클라이언트에게는 불투명하므로 클라이언트와 서버는 파일의 수정된 상태를 전달하는 방법에 동의해야 합니다. 크기 속성의 경우 클라이언트는 파일 크기의 현재 보기를 보고합니다. 변경 속성의 경우 처리가 더 복잡합니다.

클라이언트의 경우 OPEN\_DELEGATE\_WRITE 위임을 받으면 다음 단계가 수행됩니다.

\* 변경 속성의 값은 서버에서 가져와 캐시됩니다. 이 값을 c로 표현하겠습니다.

\* 클라이언트는 수정된 데이터가 클라이언트에 보관되어 있음을 전달하는 데 사용되는 c보다 큰 값을 생성합니다. 이 값을 d로 표현하겠습니다.

\* 클라이언트가 CB\_GETATTR을 통해 변경 사항을 쿼리하는 경우

- 속성은 수정된 데이터를 보유하고 있는지 확인합니다. 파일이 수정되면 변경 속성 값으로 d 값이 반환됩니다. 이 파일이 현재 수정되지 않은 경우 클라이언트는 변경 속성에 대해 c 값을 반환합니다.

구현을 단순화하기 위해 클라이언트는 각 CB\_GETATTR에 대해 동일한 값 d를 반환할 수 있습니다. 이는 연속적인 CB\_GETATTR 작업 사이에 클라이언트가 캐시에서 파일의 데이터나 메타데이터를 다시 수정하는 경우에도 마찬가지입니다. 유일한 요구 사항은 클라이언트가 수정된 데이터를 보유하고 있음을 서버에 표시할 수 있어야 하기 때문에 클라이언트는 동일한 값을 반환할 수 있습니다. 따라서 d의 값은 항상 c + 1일 수 있습니다.\(MAY\)

서버가 변경 사항을 계산하는 시간 단위가 무엇인지 알 수 없다는 점에서 변경 속성은 클라이언트에게 불투명하지만, 클라이언트가 이를 부호 없는 정수로 처리해야 한다는 점에서는 불투명하지 않습니다. 서버는 해당 정수에 대한 클라이언트의 변경 결과를 볼 수 있어야 합니다. 따라서 서버는 변경 속성을 클라이언트에 전송할 때 네트워크 순서대로 인코딩해야 합니다. 클라이언트는 이를 수신할 때 네트워크 순서에서 기본 순서로 디코딩해야 하며, 클라이언트는 서버에 보낼 때 네트워크 순서대로 인코딩해야 합니다. 이러한 이유로 변경은 불투명한 바이트 배열이 아닌 부호 없는 정수로 정의됩니다.\(MUST, MUST\)

서버의 경우 OPEN\_DELEGATE\_WRITE 위임을 제공할 때 다음 단계가 수행됩니다.

\* OPEN\_DELEGATE\_WRITE 위임을 제공하면 서버는 위임을 기록하는 데 사용하는 데이터 구조에 변경 속성의 복사본을 캐시합니다. 이 값을 sc로 표현하겠습니다.

\* 두 번째 클라이언트가 동일한 파일에 대한 GETATTR 작업을 서버에 보내면 서버는 첫 번째 클라이언트로부터 변경 속성을 얻습니다. 이 값을 cc로 둡니다.

\* cc 값이 sc와 같으면 파일은 수정되지 않으며 서버는 변경 사항, time\_metadata 및 time\_modify\(예:\)에 대한 현재 값을 두 번째 클라이언트에 반환합니다.

\* cc 값이 sc와 같지 않으면 파일은 현재 첫 번째 클라이언트에서 수정되었으며 나중에 서버에서도 수정될 가능성이 높습니다. 그런 다음 서버는 현재 시간을 사용하여 time\_metadata 및 time\_modify에 대한 속성 값을 구성합니다. nsc라고 부르는 새로운 sc 값은 nsc \>= sc + 1과 같이 서버에 의해 계산됩니다. 그런 다음 서버는 구성된 time\_metadata, time\_modify 및 nsc 값을 요청자에게 반환합니다. 서버는 위임 레코드의 sc를 nsc로 바꿉니다. time\_modify, time\_metadata 및 변경 사항이 뒤로 이동하는 것처럼 보일 가능성을 방지하려면\(위임이 취소되거나 반환되기 전에 위임을 보유한 클라이언트가 수정된 데이터를 서버에 기록하지 못한 경우 발생\) 서버는 파일의 구성된 속성 값이 있는 메타데이터 레코드입니다. 합리적인 성능을 위해 구성된 속성 값을 안정적인 저장소에 커밋하는 것은 선택 사항입니다.\(SHOULD, MAY\)

이 섹션의 앞부분에서 설명한 것처럼 클라이언트는 후속 CB\_GETATTR 호출에서 동일한 cc 값을 반환할 수 있습니다. 이는 연속적인 CB\_GETATTR 호출 사이에 클라이언트 캐시에서 파일이 다시 수정된 경우에도 마찬가지입니다. 따라서 서버는 파일이 다시 수정되었다고 가정해야 하며, 구성하고 반환하는 새 nsc가 반환한 이전 nsc보다 큰지 확인해야 합니다. 예제 구현의 위임 레코드는 위임이 승인될 때 FALSE로 설정되는 부울 필드\("수정"이라고 함\)와 변경 속성 값에 대한 승인 시 설정된 sc 값을 포함하여 이 명령을 충족합니다. 수정된 필드는 처음 cc != sc일 때 TRUE로 설정되고 위임이 반환되거나 취소될 때까지 TRUE로 유지됩니다. nsc, time\_modify 및 time\_metadata 구성 처리에서는 다음 의사 코드를 사용합니다.\(MAY, MUST\)

```text
       if (!modified) {
           do CB_GETATTR for change and size;

           if (cc != sc)
               modified = TRUE;
       } else {
           do CB_GETATTR for size;
       }

       if (modified) {
           sc = sc + 1;
           time_modify = time_metadata = current_time;
           update sc, time_modify, time_metadata into file's metadata;
       }
```

그러면 클라이언트\(GETATTR을 보낸\)에게 요청한 속성이 반환되지만 크기는 CB\_GETATTR이 반환한 것에서 나오는지 확인하세요. 서버는 클라이언트가 수정한 크기로 파일의 메타데이터를 업데이트하지 않습니다.

파일 속성 크기가 서버의 현재 값과 다른 경우, 서버는 CB\_GETATTR을 통해 검색된 변경 속성 값과 관계없이 이를 수정으로 처리하고 마지막 단계와 마찬가지로 두 번째 클라이언트에 응답합니다.

이 방법론은 클라이언트와 서버 간의 클럭 차이 문제와 CB\_GETATTR 사용이 중단되는 기타 시나리오를 해결합니다.

서버는 CB\_GETATTR을 사용할 의무가 없으므로 서버는 위임 사용을 피하기 위해 단순히 위임을 회수할 수도 있습니다.\(MAY\)

---
#### **10.4.4.  Recall of Open Delegation**

다음 이벤트에서는 OPEN 위임을 회수해야 합니다.

```text
   *  potentially conflicting OPEN request (or a READ or WRITE operation
      done with a special stateid)
```

\* 다른 클라이언트가 보낸 SETATTR

\* 파일 삭제 요청

\* RENAME의 소스 또는 대상으로 파일에 대한 RENAME 요청

파일로 이어지는 경로에 있는 디렉터리의 RENAME으로 인해 OPEN 위임이 회수되는지 여부는 서버 파일 시스템의 의미에 따라 달라집니다. 파일이 열려 있을 때 해당 파일 시스템이 이러한 RENAME을 거부하는 경우 문제의 파일이 실제로 열려 있는지 확인하기 위해 호출을 수행해야 합니다.

위의 상황 외에도 서버는 자원 제약으로 인해 그렇게 하는 것이 바람직할 경우 언제든지 OPEN 위임을 회수하도록 선택할 수 있습니다. 고객은 항상 리콜 가능성에 대비해야 합니다.

클라이언트가 OPEN 위임에 대한 회수를 받으면 위임을 반환하기 전에 서버의 상태를 업데이트해야 합니다. 클라이언트가 자발적으로 위임을 반환하기로 선택할 때마다 이와 동일한 업데이트를 수행해야 합니다. 다음과 같은 상태 항목을 처리해야 합니다.

\* 위임과 관련된 파일이 더 이상 열려 있지 않고 이전 CLOSE 작업이 서버로 전송되지 않은 경우 CLOSE 작업을 서버로 전송해야합니다.

\* 파일에 클라이언트에 다른 열린 참조가 있는 경우 OPEN 작업을 서버로 보내야 합니다. 위임 stateid가 더 이상 유효하지 않으므로 클라이언트가 나중에 사용할 수 있도록 서버에서 적절한 stateid를 제공합니다. 이러한 OPEN 요청은 CLAIM\_DELEGATE\_CUR의 클레임 유형으로 수행됩니다. 이를 통해 클라이언트가 OPEN을 수행하기 위한 적절한 권한을 설정할 수 있도록 위임 stateid를 표시할 수 있습니다. \(자세한 내용은 OPEN 동작을 설명하는 섹션 18.16을 참조하십시오.\)

\* 바이트 범위 잠금이 허용된 경우 해당 LOCK 작업을 수행해야 합니다. 이는 OPEN\_DELEGATE\_WRITE 위임 사례에만 적용됩니다.

\* OPEN\_DELEGATE\_WRITE 위임의 경우 회수 시 파일이 OPEN4\_SHARE\_ACCESS\_WRITE/OPEN4\_SHARE\_ACCESS\_BOTH에 대해 열려 있지 않으면 파일에 대해 수정된 모든 데이터를 서버로 플러시해야 합니다. 위임이 존재하지 않았다면 클라이언트는 CLOSE 작업 전에 이 데이터 플러시를 수행했을 것입니다.

\* OPEN\_DELEGATE\_WRITE 위임의 경우 파일이 회수 시점에 아직 열려 있는 경우 해당 파일에 대해 수정된 모든 데이터를 서버로 플러시해야 합니다.

\* OPEN\_DELEGATE\_WRITE 위임이 적용되면 위임 기간 동안 파일이 잘릴 수 있습니다. 예를 들어 크기 속성 값이 0인 OPEN UNCHECKED의 결과로 잘림이 발생할 수 있습니다. 따라서 파일 잘림이 발생했지만 이 작업이 서버에 전파되지 않은 경우 수정된 데이터가 서버에 기록되기 전에 잘림이 발생해야 합니다.

OPEN\_DELEGATE\_WRITE 위임의 경우 바이트 범위 잠금에는 몇 가지 추가 요구 사항이 적용됩니다. 연관된 불변성을 정확하게 유지하려면 OPEN\_DELEGATE\_WRITE 위임이 유효한 동안 WRITE\_LT 잠금이 해제된 모든 바이트 범위에서 수정된 데이터를 플러시해야 합니다. 그러나 OPEN\_DELEGATE\_WRITE 위임은 다른 클라이언트에 의한 다른 잠금을 의미하지 않기 때문에 OPEN\_DELEGATE\_WRITE 위임이 적용되는 동안 WRITE\_LT 잠금이 해제된 경우 파일에 대해 수정된 모든 데이터를 플러시하는 것이 더 간단한 구현입니다\(위에서 설명한 대로\).

구현 고려 사항\(예: 리소스 가용성 제약\)으로 인해 위의 작업을 수행하는 것이 바람직할 경우 구현은 위임 회수\(또는 위임을 자발적으로 반환하기로 결정\)까지 기다릴 필요가 없습니다. 그러나 일반적으로 파일의 실제 OPEN 상태가 계속 변경될 수 있다는 사실로 인해 위임 반환의 일부를 제외하고 열기 및 닫기에 대한 정보를 서버에 보내는 것은 가치가 없습니다. 클라이언트가 더 이상 파일의 내부 열기를 갖지 않는 경우는 예외입니다. 이 경우 CLOSE를 보내는 것은 클라이언트와 서버의 리소스 사용량을 줄여주기 때문에 유용합니다. 이러한 작업 예약에 대한 클라이언트의 선택에 관계없이 위임을 초래한 OPEN에 해당하는 마감을 포함하여 \(해당되는 경우\) 위임이 반환되기 전에 모든 작업을 수행해야 합니다. 이러한 작업은 이전 요청이나 동일한 COMPOUND 요청의 이전 작업에서 수행될 수 있습니다.

---
#### **10.4.5.  Clients That Fail to Honor Delegation Recalls**

클라이언트는 서버에서 클라이언트로의 백채널 오류 등 다양한 이유로 회수에 응답하지 못할 수 있습니다. 클라이언트는 백채널의 오류를 인식하지 못할 수 있습니다. 이러한 인식 부족으로 인해 클라이언트는 위임이 취소된 후 오랜 시간이 지나서 클라이언트가 위임한 데이터를 다른 클라이언트가 수정했다는 사실을 알게 될 수 있습니다. 이는 특히 OPEN\_DELEGATE\_WRITE 위임을 보유한 클라이언트의 문제입니다.

SEQUENCE 작업에서 반환된 상태 비트는 클라이언트에게 백채널 상태 및 회수된 위임과 관련된 문제를 알리는 대체 방법을 제공하는 데 도움이 됩니다. 백채널을 사용할 수 없는 경우 서버는 SEQUENCE 작업에서 상태 비트 SEQ4\_STATUS\_CB\_PATH\_DOWN을 반환합니다. 클라이언트는 백채널 재설정을 시도하고 백채널을 성공적으로 재설정할 수 없는 경우 회수 가능한 개체를 반환함으로써 대응할 수 있습니다.

백채널이 작동하는지 여부에 관계없이 회수된 위임이 반환되지 않을 수 있습니다. 회수된 위임이 반환되지 않더라도 클라이언트의 임대는 여전히 갱신될 수 있습니다. 이 상황에서 서버는 임대 기간과 동일한 기간 내에 반환되지 않은 위임을 취소해야 합니다. 이 기간은 클라이언트가 백채널 다운 상태를 확인하고 백채널을 다시 설정할 수 있는 시간을 허용해야 합니다.\(SHOULD\)

위임이 취소되면 서버는 후속 SEQUENCE 작업에 SEQ4\_STATUS\_RECALLABLE\_STATE\_REVOKED 상태 비트가 설정된 상태로 반환됩니다. 클라이언트는 이를 기록한 다음 TEST\_STATEID를 사용하여 어떤 위임이 취소되었는지 찾아야 합니다.

---
#### **10.4.6.  Delegation Revocation**

위임이 취소되는 시점에 클라이언트에 연결된 열기가 있는 경우 해당 열기가 취소될 수도 있고 취소되지 않을 수도 있습니다. 기존 열기와 일치하지 않는 바이트 범위 잠금 또는 열기가 허용되지 않으면 위임이 반환된 경우와 마찬가지로 열기에 대한 stateid가 유효한 상태로 유지되고 취소된 위임과의 연결이 끊어질 수 있습니다.

예를 들어, OPEN4\_SHARE\_DENY\_NONE 거부가 포함된 OPEN4\_SHARE\_ACCESS\_BOTH에 대한 OPEN이 위임과 연결된 경우 다른 클라이언트에 이러한 OPEN을 부여하면 위임이 취소되지만 두 OPEN이 서로 일치하므로 OPEN을 취소할 필요는 없습니다. 반면에 쓰기 액세스를 거부하는 OPEN이 부여되면 기존 OPEN을 취소해야 합니다.

열기 및/또는 잠금이 취소되면 이러한 열기 또는 잠금을 보유하는 애플리케이션에 알려야 합니다. 이 알림은 일반적으로 읽기/쓰기 작업에 대한 오류를 반환하거나 열린 파일에 대해 닫기를 시도할 때 발생합니다.

위임이 취소된 시점에 파일에 대한 열기가 없으면 취소 알림이 필요하지 않습니다. 그러나 클라이언트에 파일에 대한 수정된 데이터가 있는 경우 애플리케이션 사용자에게 알려야 합니다. 안타깝게도 활성 애플리케이션이 클라이언트에 없을 수 있으므로 사용자에게 알리는 것이 불가능할 수 있습니다. 자세한 내용은 섹션 10.5.1을 참조하세요.

---
#### **10.4.7.  Delegations via WANT_DELEGATION**

OPEN 작업에 대한 응답의 일부로 위임을 제공하는 것 외에도 서버는 OPTIONAL WANT\_DELEGATION 작업을 통해 공개와 별도로 위임을 제공할 수 있습니다. 이를 통해 OPEN의 유효한 대상이 아닌 객체에 대해 OPEN으로부터 이익을 얻을 수 있는 위임을 미리 얻을 수 있거나 위임이 회수되어 클라이언트가 다시 시도하려는 경우를 처리할 수 있습니다. -다른 클라이언트가 사용하지 않는 경우 이를 설정합니다.\(MAY\)

WANT\_DELEGATION 작업은 디렉터리가 아닌 모든 유형의 파일 개체에 대해 수행될 수 있습니다.

WANT\_DELEGATION을 사용하여 위임을 획득하면 해당 클라이언트가 보유한 동일한 파일 핸들에 대해 열려 있는 모든 파일은 마치 CLAIM\_DELEGATE\_CUR 유형의 OPEN을 사용하여 생성된 것처럼 위임의 하위 파일로 처리됩니다. 그 외에 seqid, 액세스 및 거부 모드, 바이트 범위 잠금과의 관계는 변경되지 않습니다. 마찬가지로 기존 바이트 범위 잠금은 열기에 종속되므로 해당 바이트 범위 잠금도 새 위임에 간접적으로 종속됩니다.

WANT\_DELEGATION 작업은 위임을 즉시 사용할 수 없는 경우 콜백을 통해 위임 전달을 제공합니다. 요청된 위임이 가능해지면 CB\_PUSH\_DELEG 작업을 통해 클라이언트에 전달됩니다. 이런 일이 발생하면 동일한 파일 핸들에 대한 열린 파일은 마치 CLAIM\_DELEGATE\_CUR 유형의 OPEN을 사용하여 생성된 것처럼 위임이 전달되는 시점에서 새 위임에 종속됩니다. 마찬가지로 이는 열기에 종속된 기존 바이트 범위 잠금에 대해서도 발생합니다.

---
### **10.5.  Data Caching and Revocation**

잠금 및 위임이 취소되면 성공적인 캐싱이 좌우되는 가정이 더 이상 보장되지 않습니다. 잠금 또는 공유 예약이 취소된 경우 해당 상태 소유자에게 통보해야 합니다. 이 알림에는 취소된 해당 위임이 있는 파일이 열려 있는 애플리케이션이 포함됩니다. 취소와 관련된 캐시된 데이터는 클라이언트에서 제거되어야 합니다. 클라이언트 캐시에 수정된 데이터가 존재하는 경우 해당 데이터는 서버에 기록되지 않고 클라이언트에서 제거되어야 합니다. 언급한 대로 클라이언트가 가정한 가정은 잠금이나 위임이 취소된 시점에는 더 이상 유효하지 않습니다. 예를 들어, 첫 번째 클라이언트에서 바이트 범위 잠금이 취소된 후 다른 클라이언트에 충돌하는 바이트 범위 잠금이 부여되었을 수 있습니다. 따라서 잠금 범위 내의 데이터가 다른 클라이언트에 의해 수정되었을 수 있습니다. 분명히 첫 번째 클라이언트는 해지 시 파일에 어떤 일이 발생했는지 애플리케이션에 보장할 수 없습니다.

상태 소유자에 대한 알림은 대부분의 경우 열린 파일에 대한 다음 및 모든 후속 읽기/쓰기 또는 닫기 시 오류를 반환하는 것으로 구성됩니다. 특정 작업에 대한 오류가 반환되지 않을 수 있기 때문에 클라이언트가 사용할 수 있는 방법으로 인해 그러한 알림이 불가능해지는 경우 신호 또는 프로세스 종료와 같은 보다 과감한 조치가 적절할 수 있습니다. 여기서의 정당성은 응용 프로그램이 의존하는 불변성이 위반될 수 있다는 것입니다. 클라이언트 운영 환경에서 오류가 일반적으로 처리되는 방식에 따라 로깅, 콘솔 메시지 및 GUI 팝업을 포함한 추가 알림 수준이 적절할 수 있습니다.

---
#### **10.5.1.  Revocation Recovery for Write Open Delegation**

OPEN\_DELEGATE\_WRITE 위임에 대한 해지 복구는 파일이 열려 있지 않은 동안 클라이언트 캐시에서 수정된 데이터라는 특별한 문제를 발생시킵니다. 이 상황에서 각 닫을 때 수정된 데이터를 서버에 플러시하지 않는 클라이언트는 사용자가 해지 결과로 발생한 실패에 대한 적절한 알림을 받도록 해야 합니다. 이러한 상황에서는 문제를 해결하기 위해 사람의 조치가 필요할 수 있으므로 해당 사용자나 관리자에게 알리는 알림 체계가 필요할 수 있습니다. 로깅 및 콘솔 메시지가 일반적인 예입니다.

클라이언트에 수정된 데이터가 있는 경우 서버에 정상적으로 플러시되어서는 안 됩니다. 클라이언트는 복구를 용이하게 하기 위해 파일 시스템 네임스페이스의 다른 이름으로 위임 중에 수정된 파일 데이터의 복사본을 제공하려고 시도할 수 있습니다. 파일이 다른 클라이언트에 의해 수정되지 않았음을 클라이언트가 확인할 수 있거나 클라이언트가 문제의 파일에 대해 완전히 캐시된 복사본을 가지고 있는 경우, 클라이언트의 파일 보기에 대한 저장된 복사본은 특별한 가치를 가질 수 있습니다. 회복을 위해. 또 다른 경우에는 부분적으로는 클라이언트의 캐시된 데이터를 기반으로 하고 부분적으로는 다른 클라이언트가 수정한 서버의 복사본을 기반으로 하는 파일 복사본을 사용하여 복구하는 것은 결코 간단하지 않으므로 클라이언트는 이러한 상황에서 파일 내용 저장을 피하거나 특별히 결과를 표시할 수 있습니다. 사용자에게 발생할 수 있는 문제를 경고합니다.

위임 철회 상황에서 수정된 데이터의 저장은 특정 크기의 파일로 제한되거나 대상 파일 시스템 내에서 충분한 디스크 공간을 사용할 수 있는 경우에만 사용될 수 있습니다. 이러한 저장은 캐시된 복사본이 대상 파일 시스템에 적절하게 저장될 때까지 캐시된 복사본을 계속 사용할 수 있을 만큼 클라이언트에 충분한 버퍼링 리소스가 있는 상황으로 제한될 수도 있습니다.

---
### **10.6.  Attribute Caching**

이 섹션은 클라이언트가 파일에 대한 위임을 보유하지 않을 때 클라이언트의 파일 속성 캐싱과 관련됩니다.

이 섹션에서 설명하는 속성에는 명명된 속성이 포함되지 않습니다. 명명된 개별 속성은 파일과 유사하며, 이러한 데이터 캐싱은 일반 파일에 대한 데이터 캐싱과 마찬가지로 처리되어야 합니다. 마찬가지로 OPENATTR 디렉터리의 LOOKUP 결과\(디렉터리 내용 포함\)는 다른 경로 이름과 동일한 기반으로 캐시됩니다.

클라이언트는 서버에서 얻은 파일 속성을 캐시하고 이를 사용하여 후속 GETATTR 요청을 피할 수 있습니다. 이러한 캐싱은 파일 속성에 대한 수정이 항상 서버에 대한 요청을 통해 수행되고 로컬로 수행되어서는 안 되며 캐시되어서도 안 된다는 점에서 write through입니다. 이에 대한 예외는 데이터 캐싱과 밀접하게 연결된 속성에 대한 수정입니다. 따라서 로컬 데이터 캐시에 데이터를 써서 파일을 확장하면 이러한 변경 사항이 서버에 즉시 반영되지 않고 클라이언트에 표시되는 크기에 즉시 반영됩니다. 일반적으로 이러한 변경 사항은 서버에 직접 전파되지 않지만 수정된 데이터가 서버로 플러시되면 유사한 속성 변경이 서버에서 수행됩니다. OPEN 위임이 적용되면 수정된 속성이 CB\_RECALL 호출에 대한 반응으로 서버에 반환될 수 있습니다.

속성의 로컬 캐싱으로 인해 개별 클라이언트에서 유지 관리되는 속성 캐시가 일관되지 않게 됩니다. 서버에서 한 순서로 변경된 사항은 한 클라이언트에서는 다른 순서로, 다른 클라이언트에서는 세 번째 순서로 나타날 수 있습니다.

일반적인 파일 시스템 애플리케이션 프로그래밍 인터페이스는 동시에 여러 파일의 속성을 원자적으로 수정하거나 조사하는 수단을 제공하지 않습니다. 다음 규칙은 위에 언급된 잠재적 불일치를 합리적으로 관리할 수 있는 환경을 제공합니다. 이러한 규칙은 이전 NFS 프로토콜의 관행에서 파생되었습니다.

\* 특정 파일의 모든 속성\(fsid별 속성 제외\)은 클라이언트에서 하나의 단위로 캐시되므로 단일 파일의 컨텍스트 내에서 직렬화 불가능이 발생할 수 없습니다.

\* 클라이언트 캐시 항목이 서버에서 새로 고쳐지지 않고 유지될 수 있는 기간에 대한 상한 시간 경계가 유지됩니다.

\* 서버에서 속성을 변경하는 작업이 수행되면 업데이트된 속성 세트가 포함된 RPC의 일부로 요청됩니다. 여기에는 속성을 간접적으로 업데이트하는 디렉터리 작업이 포함됩니다. 이는 GETATTR 작업으로 수정 작업을 수행한 다음 GETATTR의 결과를 사용하여 클라이언트의 캐시된 속성을 업데이트함으로써 수행됩니다.

캐시할 속성의 전체 집합이 READDIR에 의해 요청되면 클라이언트는 GETATTR을 통해 얻은 속성과 동일한 기반으로 결과를 캐시할 수 있습니다.

클라이언트는 변경 속성과 time\_access 속성을 모두 가져오고 변경 속성이 속성이 캐시되었을 때와 동일한 값을 갖는 경우 time\_access 이외의 속성은 변경되지 않았다고 가정하여 파일에 대한 캐시된 속성 버전의 유효성을 검사할 수 있습니다. time\_access도 가져오는 이유는 변경 내용을 업데이트하는 작업이 time\_access를 업데이트하지 않는 환경에서 운영되는 서버가 많기 때문입니다. 예를 들어, POSIX 파일 의미론은 쓰기 시스템 호출\[15\]에 의해 파일이 수정될 때 액세스 시간을 업데이트하지 않습니다. 따라서 현재 time\_access 값을 원하는 클라이언트는 속성 캐시 검증 처리 중에 변경된 값을 가져와서 캐시된 time\_access를 업데이트해야 합니다.

클라이언트는 수정된 일반 파일의 데이터\(크기, 시간\_수정 및 변경\)와 밀접하게 연결된 속성에 대한 수정된 속성의 캐시를 유지할 수 있습니다. 이 세 가지 속성 외에 클라이언트는 수정된 속성의 캐시를 유지해서는 안 됩니다. 대신 속성 변경 사항이 즉시 서버로 전송됩니다.\(MUST NOT\)

일부 운영 환경에서는 파일 객체의 내용을 읽을 때마다 time\_access에 해당하는 내용이 암시적으로 업데이트될 것으로 예상됩니다. NFS 클라이언트가 일반 파일, 디렉터리, 심볼릭 링크 등 파일 객체의 콘텐츠를 캐싱하는 경우 클라이언트는 각 항목으로 서버의 time\_access 속성\(SETATTR 또는 작은 READ 또는 READDIR 요청을 통해\)을 업데이트해서는 안 됩니다. 캐시에서 만족된 읽기입니다. 그 이유는 특히 time\_access의 명시적인 SETATTR이 서버의 변경 속성을 변경할 수 있기 때문에 콘텐츠 캐싱의 성능 이점을 상실할 수 있기 때문입니다. 변경 속성이 변경되면 콘텐츠를 캐싱하는 클라이언트는 콘텐츠가 변경되었다고 생각하고 서버에서 수정되지 않은 데이터를 다시 읽습니다. 또한 클라이언트는 캐시에 time\_access의 수정된 버전을 유지하도록 권장되지 않습니다. 왜냐하면 클라이언트는 결국 나쁜 성능 영향으로 서버에 액세스 시간을 기록해야 하거나 서버의 time\_access를 업데이트하지 않아야 하므로 애플리케이션이 다음과 같은 상황이 발생하기 때문입니다. 동일한 파일의 닫힘과 열기 사이의 액세스 시간을 캐시하는 것은 과거와 현재 사이를 오가는 액세스 시간을 관찰합니다. time\_access 속성은 항상 서버에서 만족한 읽기를 통해 파일에 마지막으로 액세스한 시간을 의미합니다. 이런 식으로 클라이언트는 앞으로 진행되는 time\_access 변경 사항만 보는 경향이 있습니다.\(SHOULD NOT\)

---
### **10.7.  Data and Metadata Caching and Memory Mapped Files**

일부 운영 환경에는 응용 프로그램이 파일 내용을 응용 프로그램의 주소 공간에 매핑하는 기능이 포함되어 있습니다. 응용 프로그램이 주소 공간에 로드되지 않은 블록에 해당하는 메모리 위치에 접근할 때마다 페이지 폴트가 발생하여 파일을 읽습니다\(또는 해당 블록이 파일에 없으면 블록을 할당한 다음 애플리케이션의 주소 공간에서 인스턴스화됨\)

파일에 대한 각 메모리 매핑 액세스에 페이지 오류가 필요한 한 액세스 및 수정을 감지하는 데 사용되는 파일의 관련 속성\(time\_access, time\_metadata, time\_modify 및 변경\)이 업데이트됩니다. 그러나 많은 운영 환경에서 페이지 폴트가 필요하지 않은 경우 이러한 속성은 메모리 액세스를 통해 파일을 읽거나 업데이트할 때 업데이트되지 않습니다\(파일이 로컬인지 또는 원격으로 액세스되는지 여부에 관계 없음\). 클라이언트나 서버는 메모리 매핑된 I/O를 통해 액세스되는 파일의 속성을 업데이트하지 못할 수 있습니다. 이는 다음과 같은 몇 가지 의미를 갖습니다.\(MAY\)

\* 클라이언트도 액세스하고 있는 파일에 매핑된 메모리가 있는 응용 프로그램이 서버에 있는 경우 클라이언트는 캐시가 오래되었는지 여부를 확인하기 위해 변경 속성의 일관된 값을 가져오지 못할 수 있습니다. 파일이 메모리 매핑되어 있음을 알고 있는 서버는 항상 변경 사항에 대해 업데이트된 값을 비관적으로 반환하여 응용 프로그램이 항상 파일에 대한 최신 데이터와 메타데이터를 가져오도록 할 수 있습니다. 그러나 이는 성능에 부정적인 영향을 미치므로 이러한 동작은 선택 사항입니다.\(MAY\)

\* 메모리 매핑된 파일이 서버에서 수정되지 않고 대신 메모리 매핑된 인터페이스를 통해 애플리케이션에서 읽는 중인 경우 클라이언트에는 업데이트된 time\_access 속성이 표시되지 않습니다. 그러나 많은 운영 환경에서는 서버에서 프로세스가 실행되지 않습니다. 따라서 NFS 클라이언트는 로컬 프로세스와 관련하여 불리한 점이 없습니다.

\* 파일을 메모리 매핑하는 다른 클라이언트가 있고 해당 클라이언트가 OPEN\_DELEGATE\_WRITE 위임을 보유한 경우 이전 두 글머리 기호에서 설명한 것과 동일한 문제 세트가 적용됩니다. 따라서 서버가 클라이언트가 캐시에서 수정한 파일에 대해 CB\_GETATTR을 수행하면 CB\_GETATTR의 응답이 반드시 정확하지는 않습니다. 앞에서 설명한 것처럼 클라이언트의 의무는 연속적인 CB\_GETATTR 호출 사이에 파일이 다시 수정되었는지 여부가 아니라 위임이 허용된 이후 파일이 수정되었음을 보고하는 것이며 서버는 클라이언트가 캐시에서 수정한 모든 파일이 수정되었다고 가정해야 합니다. 연속적인 CB\_GETATTR 호출 사이에서 다시 수정되었습니다. 클라이언트의 메모리 관리 시스템의 특성에 따라 이러한 약한 의무는 불가능할 수도 있습니다. 클라이언트는 파일이 메모리 매핑될 때마다 CB\_GETATTR에 오래된 정보를 반환할 수 있습니다.\(MUST, MAY\)

\* 동일한 파일에 메모리 매핑과 바이트 범위 잠금을 혼합하면 문제가 됩니다. 각 클라이언트의 페이지 크기가 8192바이트인 다음 시나리오를 고려해 보세요.

- - 클라이언트 A 메모리는 파일 X의 첫 번째 페이지\(8192바이트\)를 매핑합니다.

- - 클라이언트 B 메모리는 파일 X의 첫 번째 페이지\(8192바이트\)를 매핑합니다.

- - 클라이언트 A WRITE\_LT는 처음 4096바이트를 잠급니다.

- - 클라이언트 B WRITE\_LT는 두 번째 4096바이트를 잠급니다.

- - 클라이언트 A는 STORE 명령을 통해 잠긴 바이트 범위의 일부를 수정합니다.

- - 클라이언트 A와 동시에 클라이언트 B는 잠긴 바이트 범위의 일부에서 STORE를 실행합니다.

여기서 과제는 첫 번째 페이지의 올바른 보기를 얻기 위해 각 클라이언트가 재동기화하는 것입니다. 많은 운영 환경에서 각 클라이언트의 가상 메모리 관리 시스템은 페이지가 수정되었다는 사실만 알고 각 잠금 바이트 범위에 해당하는 페이지의 하위 집합이 수정되었다는 사실은 알지 못합니다. 따라서 각 클라이언트가 올바른 작업, 즉 잠긴 페이지 부분만 서버에 쓰는 것은 불가능합니다. 예를 들어 클라이언트 A가 단순히 페이지를 작성한 다음 클라이언트 B가 페이지를 작성한 경우 클라이언트 A의 데이터가 손실됩니다.

게다가 파일에 필수 잠금이 활성화되어 있으면 다른 문제가 발생합니다. 클라이언트 A와 B가 STORE 명령을 실행하면 결과 페이지 오류로 인해 전체 페이지에 대한 바이트 범위 잠금이 필요합니다. 그런 다음 각 클라이언트는 잠긴 범위를 전체 페이지로 확장하려고 시도하며 이로 인해 교착 상태가 발생합니다. NFS4ERR\_DEADLOCK 오류를 STORE 명령에 전달하는 것은 기껏해야 어렵습니다.

클라이언트가 전체 메모리 매핑된 파일을 잠그는 경우 적어도 클라이언트가 파일 중간에 있는 바이트 범위를 잠금 해제할 때까지는 권고 또는 필수 바이트 범위 잠금에 문제가 없습니다.

위의 문제를 고려하여 다음이 허용됩니다.

\* 클라이언트와 서버는 바이트 범위 잠금이 있음을 알고 있는 파일에 대한 메모리 매핑을 거부할 수 있습니다.\(MAY\)

\* 클라이언트와 서버는 메모리 매핑된 파일에 대한 바이트 범위 잠금을 거부할 수 있습니다.\(MAY\)

\* 클라이언트는 I/O에 대한 필수 잠금이 필요하다는 것을 알고 있는 파일에 대한 메모리 매핑을 거부할 수 있습니다. 파일이 열리고 매핑된 후 필수 잠금이 활성화되면 클라이언트는 매핑된 파일에 대한 응용 프로그램의 추가 액세스를 거부할 수 있습니다.\(MAY, MAY\)

---
### **10.8.  Name and Directory Caching without Directory Delegations**

NFSv4.1 디렉터리 위임 기능\(아래 섹션 10.9에 설명되어 있음\)은 서버에서 구현할 수 있는 선택 사항입니다. 구현된 경우에도 리소스 가용성 문제나 기타 제약으로 인해 항상 작동하지 않을 수 있습니다. 따라서 디렉터리 위임이 없을 때 이름 및 디렉터리 캐싱이 수행되는 방식을 이해하는 것이 중요합니다. 이러한 주제는 다음 두 하위 섹션에서 논의됩니다.\(MAY\)

---
#### **10.8.1.  Name Caching**

LOOKUP 및 READDIR 작업의 결과는 후속 LOOKUP 작업 비용을 피하기 위해 캐시될 수 있습니다. 속성 캐싱의 경우와 마찬가지로 다양한 클라이언트 캐시 간에 불일치가 발생할 수 있습니다. 이러한 불일치로 인한 영향을 완화하고 일반적인 파일 시스템 API의 컨텍스트를 고려하여 클라이언트 이름 캐시 항목이 수행된 디렉터리 변경 작업으로 인해 항목이 무효화되지 않았는지 확인하지 않고 해당 항목을 유지할 수 있는 상한 시간 경계가 유지됩니다. 다른 클라이언트에 의해.

클라이언트가 이름 캐시 항목이 있는 디렉터리를 변경하지 않는 경우 클라이언트는 해당 디렉터리가 수정되지 않도록 정기적으로 해당 디렉터리의 속성을 가져와야 합니다. 수정 사항이 발생하지 않았음을 확인한 후 관련 이름 캐시 항목의 만료 시간은 현재 시간에 이름 캐시 유효 기간 제한을 더한 값으로 업데이트될 수 있습니다.

클라이언트가 특정 디렉터리를 변경할 때 다른 클라이언트가 해당 디렉터리를 변경했는지 여부를 확인해야 합니다. 이는 작업에 대해 반환된 관련change\_info4 값에서 디렉터리 작업 전후에 보고된 변경 속성을 사용하여 수행됩니다. 서버는 디렉토리 작업과 관련하여 Change\_info4 데이터가 원자적으로 제공되는지 여부를 클라이언트와 통신할 수 있습니다. 변경 값이 원자적으로 제공되는 경우 클라이언트는 적절한 주의를 기울여 다른 클라이언트가 문제의 디렉터리를 수정하고 있는지 여부를 결정할 수 있는 기반을 갖습니다.

클라이언트가 이러한 결정을 내릴 수 있도록 하는 가장 간단한 방법은 클라이언트가 특정 디렉터리에 대한 모든 변경 사항을 직렬화하는 것입니다. 이 작업이 완료되고 서버가 변경 속성의 이전 및 이후 값을 원자적으로 제공하면 클라이언트는 디렉터리에 대한 한 작업의 변경 속성 이후 값을 해당 디렉터리를 수정하는 후속 작업의 이전 값과 간단히 비교할 수 있습니다. 이것이 동일하면 클라이언트는 다른 클라이언트가 문제의 디렉터리를 수정하지 않는다는 것을 확신합니다.

이러한 직렬화가 사용되지 않고 단일 클라이언트에서 전송된 단일 디렉터리를 수정하는 여러 개의 동시 처리 작업이 있을 수 있으므로 이러한 종류의 결정이 더 복잡해질 수 있습니다. 이러한 두 작업이 실제로 수행된 순서와 다른 순서로 완료되면 다른 클라이언트가 수정한 것과 일치하는 것처럼 보일 수 있습니다. 이런 일이 발생하는 것으로 보이는 경우 클라이언트는 이전에 시작된 모든 수정이 완료될 때까지 기다려야 변경 번호 전후의 미해결 항목이 한 변경 번호의 이전 값이 이후 값과 일치하도록 체인으로 정렬될 수 있는지 확인해야 합니다. 이 클라이언트가 디렉토리를 수정하는 유일한 클라이언트와 일치하는 체인에서 이전 값입니다.

두 경우 모두 클라이언트는 디렉터리가 다른 클라이언트에 의해 수정되고 있는지 여부를 확인할 수 있습니다. 비교 결과 디렉터리가 다른 클라이언트에 의해 업데이트되었음을 ​​나타내는 경우 수정된 디렉터리와 관련된 이름 캐시가 클라이언트에서 제거됩니다. 비교 결과 수정 사항이 없는 것으로 나타나면 클라이언트에서 이름 캐시를 업데이트하여 디렉터리 작업을 반영하고 관련 시간 제한을 연장할 수 있습니다. 작업 후 변경 값은 향후change\_info4 비교를 위한 기초로 저장되어야 합니다.

위의 시나리오에서 설명한 것처럼 이름 캐싱을 위해서는 클라이언트가 이름 캐시 항목이 캐시된 시점에 디렉터리의 변경 특성을 검사하여 이름 캐시 데이터의 유효성을 다시 검사해야 합니다. 이를 위해서는 해당 디렉토리의 내용이 수정될 때 서버가 디렉토리의 변경 속성을 업데이트해야 합니다. 클라이언트가 Change\_info4 정보를 적절하고 정확하게 사용하기 위해서는 서버가 작업 전후의 변경 속성 값을 원자적으로 보고해야 합니다. 서버가 디렉터리 작업과 관련하여 이전 및 이후 값을 원자적으로 보고할 수 없는 경우 서버는 Change\_info4 반환 값에 해당 사실을 표시해야 합니다. 정보가 원자적으로 보고되지 않는 경우 클라이언트는 다른 클라이언트가 디렉터리를 변경하지 않았다고 가정해서는 안 됩니다.

---
#### **10.8.2.  Directory Caching**

READDIR 작업의 결과는 후속 READDIR 작업을 방지하는 데 사용될 수 있습니다. 속성 및 이름 캐싱의 경우와 마찬가지로 다양한 클라이언트 캐시 간에 불일치가 발생할 수 있습니다. 이러한 불일치로 인한 영향을 완화하고 일반적인 파일 시스템 API의 컨텍스트를 고려하여 다음 규칙을 따라야 합니다.

\* 단일 READDIR 작업에서 가져오지 않은 디렉터리에 대해 캐시된 READDIR 정보는 항상 디렉터리 내용의 일관된 스냅샷이어야 합니다. 이는 첫 번째 READDIR 이전과 캐시에 기여하는 마지막 READDIR 이후에 GETATTR을 사용하여 결정됩니다.

\* 클라이언트가 캐시된 정보를 재검증해야 하기 전에 디렉터리 캐시 항목이 유효한 것으로 간주되는 기간을 나타내기 위해 상한 시간 경계가 유지됩니다.

유효성 재검사 기술은 이름 캐싱의 경우에서 설명한 것과 유사합니다. 클라이언트가 문제의 디렉터리를 변경하지 않는 경우 GETATTR을 사용하여 디렉터리의 변경 속성을 확인하는 것이 적절합니다. 캐시 항목의 수명은 이러한 검사점에서 연장될 수 있습니다. 클라이언트가 디렉터리를 수정할 때 클라이언트는change\_info4 데이터를 사용하여 디렉터리를 수정하는 다른 클라이언트가 있는지 확인해야 합니다. 다른 클라이언트 수정이 발생하지 않는 것으로 확인되면 클라이언트는 자체 변경 사항을 반영하도록 디렉터리 캐시를 업데이트할 수 있습니다.

이전에 설명했듯이 디렉터리 캐싱에서는 클라이언트가 디렉터리가 캐시된 시점에서 디렉터리의 변경 특성을 검사하여 디렉터리 캐시 데이터의 유효성을 다시 검사해야 합니다. 이를 위해서는 해당 디렉토리의 내용이 수정될 때 서버가 디렉토리의 변경 속성을 업데이트해야 합니다. 클라이언트가 Change\_info4 정보를 적절하고 정확하게 사용하기 위해서는 서버가 작업 전후의 변경 속성 값을 원자적으로 보고해야 합니다. 서버가 디렉터리 작업과 관련하여 이전 및 이후 값을 원자적으로 보고할 수 없는 경우 서버는 Change\_info4 반환 값에 해당 사실을 표시해야 합니다. 정보가 원자적으로 보고되지 않는 경우 클라이언트는 다른 클라이언트가 디렉터리를 변경하지 않았다고 가정해서는 안 됩니다.

---
### **10.9.  Directory Delegations**
---
#### **10.9.1.  Introduction to Directory Delegations**

앞에서 설명한 대로 NFSv4.1 프로토콜에 대한 디렉터리 캐싱은 이전 버전의 파일 캐싱과 유사합니다. 클라이언트는 일반적으로 클라이언트가 결정한 기간 동안 디렉터리 정보를 캐시합니다. 미리 정의된 시간 초과가 끝나면 클라이언트는 서버에 쿼리하여 디렉터리가 업데이트되었는지 확인합니다. 속성을 캐싱함으로써 클라이언트는 속성을 검증하기 위해 서버에 대한 GETATTR 호출 수를 줄입니다. 또한 현재 작업 디렉토리와 같이 자주 액세스되는 파일 및 디렉토리에는 해당 속성이 클라이언트에 캐시되어 있으므로 RPC 호출을 하지 않고도 일부 NFS 작업을 수행할 수 있습니다. DNLC\(디렉터리 이름 조회 캐시\)에서 가장 최근에 조회된 항목에 대한 이름 및 inode 정보를 캐시함으로써 클라이언트는 이러한 파일에 액세스할 때마다 서버에 LOOKUP 호출을 보낼 필요가 없습니다.

이 캐싱 접근 방식은 여러 환경에서 네트워크 트래픽을 줄이는 데 합리적으로 효과적입니다. 그러나 존재하지 않는 파일에 대한 쿼리가 많은 환경은 다루지 않습니다. 이러한 "누락"의 경우 클라이언트는 합리적인 애플리케이션 의미 체계를 제공하고 새 디렉터리 항목 생성을 즉시 감지하기 위해 서버에 요청을 보냅니다. 높은 누락 활동의 예로는 소프트웨어 개발 환경에서의 컴파일이 있습니다. NFS의 현재 동작은 이러한 유형의 환경에서 잠재적인 확장성과 광역 공유 효율성을 제한합니다. AFS 및 DFS와 같은 기타 분산 상태 저장 파일 시스템 아키텍처에서는 디렉토리 내용에 상태를 추가하면 하이미스\(high-miss\) 환경에서 네트워크 트래픽을 크게 줄일 수 있다는 것이 입증되었습니다.

디렉토리 내용 위임은 NFSv4.1의 선택적 기능입니다. 디렉터리 위임은 파일 위임과 유사한 트래픽 감소 이점을 제공합니다. 변경 사항에 대한 알림을 받으면서 클라이언트가 디렉터리 내용을 캐시\(읽기 전용 방식으로\)할 수 있도록 함으로써 클라이언트는 느리게 변경되는 디렉터리의 내용을 조사하라는 빈번한 요청을 피하고 네트워크 트래픽을 줄이고 클라이언트 성능을 향상시킬 수 있습니다. 또한 클라이언트 자체가 디렉터리를 많이 변경하고 변경 사항이 직렬화되지 않은 경우 다른 클라이언트가 디렉터리를 변경하고 있는지 확인하는 작업을 단순화할 수 있습니다.\(MAY\)

디렉터리 위임을 사용하면 알림이 없을 때 위임 및 동기 회수를 통해 향상된 네임스페이스 캐시 일관성을 얻을 수 있습니다. 또한 시간 기반 일관성이 충분할 경우 비동기 알림은 느리게 변경되거나 매우 큰 디렉터리와 같은 일부 일반적인 작동 조건에서 클라이언트 및 서버에 성능 이점을 제공할 수 있습니다.

---
#### **10.9.2.  Directory Delegation Design**

NFSv4.1에는 클라이언트가 디렉터리 위임을 요청할 수 있도록 GET\_DIR\_DELEGATION\(섹션 18.39\) 작업이 도입되었습니다. 위임에는 디렉터리 특성과 디렉터리의 모든 항목이 포함됩니다. 둘 중 하나가 변경되면 위임이 동시에 회수됩니다. 회수를 유발하는 작업은 회수가 완료될 때까지 기다려야 합니다. 디렉토리 항목 속성을 변경해도 위임이 회수되지 않습니다.

위임을 요청하는 것 외에도 클라이언트는 특정 이벤트에 대한 알림을 요청할 수도 있습니다. 이러한 이벤트에는 디렉터리 속성 및/또는 해당 내용에 대한 변경 사항이 포함됩니다. 클라이언트가 특정 이벤트에 대한 알림을 요청하면 서버는 해당 이벤트가 발생할 때 클라이언트에 알립니다. 이로 인해 해당 클라이언트에 대한 위임이 회수되지는 않습니다. 알림은 비동기식이며 클라이언트가 상당한 이점을 얻을 수 있도록 시도하는 동안 순수 회수 모델이 효과적이지 않을 정도로 디렉토리가 변경되는 상황에서 회수를 방지하는 방법을 제공합니다. 알림이 없는 경우 위임이 회수되면 클라이언트는 디렉터리 캐시를 새로 고쳐야 합니다. 이는 매우 큰 디렉토리의 경우 그다지 효율적이지 않을 수 있습니다.

위임은 읽기 전용이며 클라이언트는 서버가 이러한 변경 사항을 알 수 있도록 디렉토리 또는 관련 파일 속성을 수정하는 NFSv4.1 작업을 수행하는 것 외에는 디렉토리를 변경할 수 없습니다. 클라이언트의 네임스페이스를 서버의 네임스페이스와 동기화된 상태로 유지하기 위해 서버는 클라이언트의 디렉터리 수정 작업의 결과로 변경된 사항을 위임 보유 클라이언트\(알림을 요청했다고 가정\)에 알립니다. 이는 해당 클라이언트가 후속 GETATTR 또는 READDIR 작업을 서버에 보낼 필요가 없도록 하기 위한 것입니다. 단일 클라이언트가 위임을 보유하고 있고 해당 클라이언트가 디렉터리를 변경하는 경우\(즉, 위임을 보유하고 있는 클라이언트 ID와 연결된 세션에서 전송된 작업을 통해 변경이 이루어진 경우\) 위임은 회수되지 않습니다. 여러 클라이언트가 동일한 디렉터리에 위임을 보유할 수 있지만 그러한 클라이언트가 디렉터리를 수정하는 경우 해당 클라이언트가 그러한 종류의 수정에 대해 알림을 받도록 규정을 설정하지 않은 한 서버는 다른 클라이언트의 위임을 회수해야 합니다.\(MUST\)

위임은 서버에서 언제든지 회수할 수 있습니다. 일반적으로 서버는 알림에서 다루지 않는 방식으로 디렉터리가 변경되거나 디렉터리 변경 및 알림이 요청되지 않은 경우 위임을 회수합니다. 다른 클라이언트가 위임이 부여된 디렉터리를 제거하면 서버는 위임을 회수합니다.

---
#### **10.9.3.  Attributes in Support of Directory Notifications**

디렉터리 알림과 관련된 속성에 대한 설명은 섹션 5.11을 참조하세요.

---
#### **10.9.4.  Directory Delegation Recall**

서버는 클라이언트에 콜백을 보내 디렉터리 위임을 회수합니다. 파일 위임을 호출하는 데 사용된 것과 동일한 콜백 절차를 사용합니다. 알림에서 다루지 않는 방식으로 디렉토리가 변경되면 서버는 위임을 회수합니다. 그러나 디렉토리 내의 항목 속성이 변경되면 서버는 위임을 회수할 필요가 없습니다.

서버가 디렉터리에 대한 위임을 전달하면 너무 많은 알림이 전송된다는 사실을 알게 되면 해당 디렉터리에 대한 위임을 전달하지 않거나 이미 부여된 위임을 회수하기로 결정할 수 있습니다. 클라이언트가 위임이 부여된 디렉터리를 제거하려고 하면 서버는 관련된 모든 위임을 회수합니다.

다양한 작업에 대한 구현 섹션에서는 일부 일반적인 상황에서 알림 또는 위임 회수가 필요한 상황을 설명합니다. 이와 관련하여 섹션 10.2에 나열된 것과 유사한 주의 사항이 적용됩니다.

\* CREATE에 대해서는 18.4.4절을 참조하세요.

\* LINK에 대해서는 18.9.4항을 참조하십시오.

\* OPEN에 대해서는 18.16.4항을 참조하십시오.

\* REMOVE에 대해서는 섹션 18.25.4를 참조하십시오.

\* RENAME에 대해서는 섹션 18.26.4를 참조하세요.

\* SETATTR에 대해서는 섹션 18.30.4를 참조하세요.

---
#### **10.9.5.  Directory Delegation Recovery**

일반 파일의 상태에 대해 클라이언트 또는 서버 다시 시작에서 복구하는 데는 두 가지 주요 목표가 있습니다. 즉, 잠긴 파일과 관련하여 애플리케이션 보증을 위반할 필요성을 방지하고 클라이언트에 캐시된 업데이트를 전달하는 것입니다. 이러한 목표는 OPEN\_DELEGATE\_READ 위임 및 알림으로 보호되는 디렉터리에는 적용되지 않습니다. 따라서 클라이언트 또는 서버가 다시 시작되는 경우 디렉터리 위임을 회수하기 위한 규정이 제공되지 않습니다. 클라이언트는 처음에 수행했던 것과 동일한 방식으로 간단히 디렉터리 위임을 설정할 수 있습니다.

---
## **11.  Multi-Server Namespace**

NFSv4.1은 네임스페이스가 단일 서버의 경계를 넘어 확장될 수 있도록 하는 속성을 지원합니다. 클라이언트와 서버는 이러한 다중 서버 네임스페이스 구성을 지원하는 것이 바람직합니다. 이러한 다중 서버 네임스페이스의 사용은 선택 사항입니다. 그러나 다양한 목적으로 단일 서버 네임스페이스는 완벽하게 허용됩니다. 다중 서버 네임스페이스를 사용하면 네임스페이스에서 파일 시스템의 논리적 위치를 단일 네트워크 액세스 경로를 통해 특정 파일 시스템이 특정 서버에 위치하도록 하는\(변경 가능\) 물류 및 관리 고려 사항과 분리함으로써 많은 이점을 제공할 수 있습니다. 사전에 알려지거나 DNS를 사용하여 결정되어야 합니다.\(MAY\)

---
### **11.1.  Terminology**

이 섹션 전체\(즉, 섹션 11 전체\)에서 "클라이언트 ID"라는 문구는 항상 서버가 할당한 64비트 단축 식별자\(clientid4\)를 의미하며 클라이언트가 식별하는 데 사용하는 구조를 의미하지 않습니다. \(NFSv4.0 및 NFSv4.1에서는 각각 nfs\_client\_id4 또는 client\_owner라고 함\) 해당 구조 내의 불투명 식별자를 "클라이언트 ID 문자열"이라고 합니다.

---
#### **11.1.1.  Terminology Related to Trunking**

트렁킹 탐지와 트렁킹 발견 간의 차이를 명확히 하는 것이 특히 중요합니다. 제시된 정의는 NFSv4의 모든 부 버전에 적용 가능하지만 이러한 용어가 NFS 버전 4.1에 어떻게 적용되는지에 중점을 둘 것입니다.

\* 트렁킹 감지는 두 개의 특정 네트워크 주소가 동일한 NFSv4 서버에 연결되어 있는지 확인하는 방법을 의미합니다. 이를 결정하는 데 사용할 수 있는 수단은 프로토콜 버전에 따라 다르며 경우에 따라 클라이언트 구현에 따라 다릅니다.

- NFS 버전 4.1 이상의 마이너 버전의 경우 트렁킹 감지 방법은 이 문서에 설명된 대로이며 모든 클라이언트에서 사용할 수 있습니다. 동일한 서버에 연결된 두 개의 네트워크 주소는 특정 서버에 액세스하기 위해 항상 함께 사용할 수 있지만 단일 세션에 액세스하기 위해 반드시 함께 사용할 수는 없습니다. "서버 트렁크 가능" 및 "세션 트렁크 가능"이라는 용어의 정의는 아래를 참조하십시오.

\* 트렁킹 검색은 하나의 네트워크 주소를 사용하는 클라이언트가 동일한 서버에 연결된 다른 주소를 얻을 수 있는 프로세스입니다. 일반적으로 클라이언트가 후보 주소를 사용할 수 있도록 하는 하나 이상의 방법을 제공하여 트렁킹 감지 기능을 기반으로 구축되며, 클라이언트는 트렁킹 감지를 사용하여 주소를 적절하게 필터링할 수 있습니다.

트렁킹 감지 지원에도 불구하고

- RFC 5661 \[66\]에 제공된 트렁킹 검색에 대한 설명으로 인해 이 문서에서 해당 수단을 제공해야 합니다.

서버 네트워크 주소와 연결에 사용되는 특정 연결 유형의 조합을 "서버 엔드포인트"라고 합니다. 서로 다른 연결 유형을 사용하면 서로 다른 포트가 사용될 수 있지만, 이러한 경우 동일한 네트워크 주소에 대한 여러 연결에서 서로 다른 포트를 사용하는 것은 사용되는 두 엔드포인트 간의 구별의 핵심이 아닙니다. 이는 단일 서버 노드가 여러 NFS 서버를 지원할 수 있도록 네트워크 주소 내의 포트 번호를 명시적으로 지정하는 데 사용되는 포트별 엔드포인트의 경우와 대조됩니다.

동일한 서버에 연결된 두 개의 네트워크 주소를 서버 트렁크 가능이라고 합니다. 이러한 두 주소는 섹션 2.10.5에 설명된 대로 클라이언트 ID 트렁킹 사용을 지원합니다.

단일 공통 세션을 지원하는 데 사용할 수 있도록 동일한 서버에 연결된 두 개의 네트워크 주소를 세션 트렁크 가능이라고 합니다. 두 개의 주소는 세션 트렁크가 아닌 서버 트렁킹이 가능할 수 있으며, 서로 다른 연결 유형의 두 연결이 동일한 네트워크 주소에 대해 이루어지고 단일 파일 시스템 위치 항목을 기반으로 하는 경우 항상 세션 트렁크가 가능합니다. 섹션 2.10.5에 지정된 연결 유형과 관계없이 동일한 파일 시스템 위치 항목에서 파생되므로 네트워크 주소의 ID와 함께 두 연결이 모두 동일한 서버에 대한 것이며 서버 소유자 정보를 반환하므로 , 세션 트렁킹을 사용할 수 있습니다.

---
#### **11.1.2.  Terminology Related to File System Location**

로컬 서버별 네임스페이스 집합에서 다중 서버 네임스페이스를 구성하는 것과 관련된 용어는 다음과 같습니다.

\* 각 서버에는 NFSv4 클라이언트가 액세스할 수 있는 내보낸 파일 시스템 세트가 있습니다. 일반적으로 이는 서버와 연결된 pseudo-fs 내에서 각 파일 시스템에 이름을 할당하여 수행됩니다. 단, 내보낸 파일 시스템이 하나만 있는 경우 pseudo-fs가 생략될 수도 있습니다. 이러한 각 파일 시스템은 서버의 로컬 네임스페이스의 일부이며 더 큰 다중 서버 네임스페이스 내의 파일 시스템 인스턴스로 간주될 수 있습니다.

\* 특정 서버에 대해 내보낸 모든 파일 시스템 세트

- 해당 서버의 로컬 네임스페이스를 구성합니다.

\* 어떤 경우에는 서버가 파일 시스템 위치 정보를 제공하는 속성과 관련된 기능을 사용하여 로컬 네임스페이스보다 더 광범위한 네임스페이스를 갖게 됩니다. 다중 서버 네임스페이스 구축을 허용하는 이러한 기능은 모두 아래 개별 섹션에 설명되어 있으며 조회\(섹션 11.5.6\), 마이그레이션\(섹션 11.5.5\) 및 복제\(섹션 11.5.4\)가 포함됩니다.

\* 서버의 pseudo-fs에 있는 파일 시스템은 이와 연결된 여러 서버에 여러 파일 시스템 인스턴스를 가질 수 있습니다. 이러한 모든 인스턴스는 서로의 복제본으로 간주됩니다. 이러한 복제본을 동시에 사용할 수 있는지 여부는 섹션 11.11.1에서 논의하고, 그들 사이의 조정 수준\(서로 전환할 때 중요\)은 아래 섹션 11.11.2부터 11.11.8까지에서 논의합니다.

\* 서버의 pseudo-fs에 파일 시스템이 있지만 해당 로컬 파일 시스템이 없는 경우 "없음"이라고 합니다. 이러한 경우 연결된 모든 인스턴스는 다른 서버에서 액세스됩니다.

트렁킹 검색 및 기타 다중 서버 네임스페이스 기능에 사용되는 속성과 관련된 용어에 대해:

\* 파일 시스템 위치 속성에는 fs\_locations 및 fs\_locations\_info 속성이 포함됩니다.

\* 파일 시스템 위치 항목은 파일 시스템 위치 속성 내의 개별 파일 시스템 위치를 제공합니다. 이러한 각 항목은 호스트 이름이나 주소 형식으로 서버를 지정하고 서버의 로컬 네임스페이스 내에서 파일 시스템의 위치를 ​​지정하는 fs 이름을 지정합니다. 파일 시스템 위치 항목은 클라이언트가 연결을 설정할 수 있는 서버 끝점 집합을 지정합니다. 호스트 이름이 여러 네트워크 주소에 매핑될 수 있고 여러 연결 유형을 사용하여 단일 네트워크 주소와 통신할 수 있으므로 끝점이 여러 개 있을 수 있습니다. 그러나 단일 서버 노드 내의 서버 집합을 지정하기 위해 명시적인 포트 번호가 사용되는 경우를 제외하고 이러한 모든 끝점은 단일 서버에 연결하는 방법을 지정해야 합니다. 위치 항목의 정확한 형식은 섹션 11.2에 설명된 대로 사용된 특정 파일 시스템 위치 속성에 따라 다릅니다.\(MUST\)

- 파일 시스템 위치 항목에 사용되는 네트워크 주소는 일반적으로 포트 번호 표시 없이 나타나며 NFS 액세스를 위한 표준 포트 중 하나에서 서버를 지정하는 데 사용됩니다\(예: TCP의 경우 2049, RPC-over-RDMA에 사용되는 경우 20049\). 포트 번호는 다른 포트 번호를 사용하여 액세스되는 서버\(일반적으로 사용자 수준 서버\)를 지정하기 위해 파일 시스템 위치 항목에 사용될 수 있습니다. 네트워크 주소가 트렁킹 관계를 나타내는 경우 트렁킹은 네트워크 주소 간의 관계이므로 명시적인 포트 번호를 사용하는 것은 부적절합니다. 자세한 내용은 섹션 11.5.2를 참조하세요.

\* 파일 시스템 위치 요소는 위치 항목에서 파생되며 각 요소는 네트워크 주소와 서버의 로컬 네임스페이스 내의 위치로 구성된 특정 네트워크 액세스 경로를 설명합니다. 이러한 위치 요소는 파일 시스템 위치 속성 내에 나타날 필요는 없지만 각 위치 요소의 존재는 해당 위치 항목에서 파생됩니다. 위치 항목이 IP 주소를 지정하는 경우 해당하는 위치 요소는 하나만 있습니다. 호스트 이름이 포함된 파일 시스템 위치 항목은 DNS를 사용하여 확인되며 하나 이상의 위치 요소가 발생할 수 있습니다. 모든 위치 요소는 서버에 대한 인터페이스의 IP 주소를 포함하는 위치 주소와 서버의 로컬 네임스페이스 내의 파일 시스템 위치인 fs 이름으로 구성됩니다. 서버에 pseudo-fs가 없고 루트 파일 핸들에 단일 내보낸 파일 시스템만 있는 경우 fs 이름이 비어 있을 수 있습니다.

\* 두 개의 파일 시스템 위치 요소가 동일한 fs 이름을 지정하고 위치 주소가 서버 트렁크 가능한 위치 주소인 경우 서버 트렁크 가능하다고 합니다. 해당 네트워크 경로가 사용되면 클라이언트는 항상 클라이언트 ID 트렁킹을 사용할 수 있지만 경로가 세션 트렁킹도 가능한 경우에만 세션 트렁킹을 사용할 수 있습니다.

\* 두 개의 파일 시스템 위치 요소가 동일한 fs 이름을 지정하고 위치 주소가 세션 트렁크 가능한 위치 주소인 경우 세션 트렁크가 가능하다고 합니다. 해당 네트워크 경로가 사용되면 클라이언트는 클라이언트 ID 트렁킹 또는 세션 트렁킹을 사용할 수 있습니다.

"복제본"이라는 용어에 대한 논의는 이 용어가 RFC 5661 \[66\]에서 이 문서에서 사용된 것과 다른 의미로 사용되었다는 사실로 인해 복잡해졌습니다. 간단히 말해서, \[66\]에서는 각 복제본이 단일 네트워크 액세스 경로로 식별되는 반면, 현재 문서에서는 서버 트렁크 가능 네트워크 주소와 동일한 루트 상대 파일 시스템 경로 이름을 갖는 네트워크 액세스 경로 집합으로 간주됩니다. 여러 네트워크 액세스 경로가 있는 단일 복제본.

서버 트렁크 가능 위치 요소의 각 세트는 특정 파일 시스템에 대해 사용 가능한 네트워크 액세스 경로 세트를 정의합니다. 이러한 파일 시스템이 여러 개 있고 각각 동일한 데이터를 포함하는 경우 이러한 파일 시스템은 서로의 복제본으로 간주됩니다. 논리적으로 이러한 복제는 현재 사용 중인 fs와 대체 fs가 서로의 복제본이므로 대칭적입니다. 종종 다른 문서에서는 복제 관계가 본질적으로 대칭이라는 사실에도 불구하고 현재 사용 중인 fs에 "복제본"이라는 용어가 적용되지 않습니다.

---
### **11.2.  File System Location Attributes**

NFSv4.1에는 특정 파일 시스템에 액세스하는 방법\(예: 네트워크 주소 및 네임스페이스 위치\)에 대한 정보를 제공하는 속성이 포함되어 있습니다. 결과적으로 한 서버의 네임스페이스에 있는 파일 시스템은 다른 서버에 있는 해당 파일 시스템의 하나 이상의 인스턴스와 연결될 수 있습니다. 이러한 속성에는 연관된 단일 서버 네임스페이스 내의 해당 파일 시스템의 경로 이름과 함께 서버 주소 대상\(하나 이상의 IP 주소를 나타내는 DNS 이름 또는 특정 IP 주소\)을 지정하는 파일 시스템 위치 항목이 포함됩니다.

fs\_locations\_info RECOMMENDED 속성을 사용하면 특정 파일 시스템에 해당하는 데이터를 찾을 수 있는 하나 이상의 파일 시스템 인스턴스 위치를 지정할 수 있습니다. 파일 시스템 인스턴스 위치 지정 외에도 이 속성은 다음을 수행하는 데 유용한 정보를 제공합니다.\(SHOULD\)

\* 제공된 다양한 파일 시스템 인스턴스 중에서 선택을 안내합니다\(예: 사용 우선순위, 쓰기 가능성, 통화 등\).

\* 필요한 경우 클라이언트가 여러 파일 시스템 인스턴스 간에 최대한 원활하게 전환할 수 있도록 효율적으로 지원합니다.

\* 연결을 설정할 때 사용할 적절한 연결 유형을 선택하도록 안내합니다.

fs\_locations\_info 속성 내에서 각 fs\_locations\_server4 항목은 파일 시스템 위치 항목에 해당합니다. fls\_server 필드는 서버를 지정하고, 포함하는 fs\_locations\_item4의 fl\_rootpath 필드는 서버의 pseudo-fs 내의 위치 경로 이름을 제공합니다.

NFSv4.0에 정의된 fs\_locations 속성은 NFSv4.1의 일부이기도 합니다. 이 속성은 지정된 파일 시스템에 해당하는 데이터를 찾을 수 있는 파일 시스템 위치 지정만 허용합니다. 서버는 fs\_locations\_info가 지원될 때마다 이 속성을 사용할 수 있도록 해야 하지만 더 많은 정보를 제공하므로 클라이언트에서 fs\_locations\_info를 사용하는 것이 더 좋습니다.\(SHOULD\)

fs\_locations 속성 내에서 각 fs\_location4에는 서버를 지정하는 서버 필드와 서버의 pseudo-fs 내에서 위치 경로 이름을 제공하는 rootpath 필드가 있는 파일 시스템 위치 항목이 포함되어 있습니다.

---
### **11.3.  File System Presence or Absence**

NFSv4.1 네임스페이스\(일반적으로 다중 서버 네임스페이스일 필요는 없음\)의 지정된 위치에는 fs\_locations 또는 fs\_locations\_info 속성을 통해 이와 연관된 여러 파일 시스템 인스턴스 위치가 있을 수 있습니다. 해당 위치에는 일반적인 네임스페이스 작업\(예: LOOKUP\)을 통해 액세스할 수 있는 실제 현재 파일 시스템이 있을 수도 있습니다. 이 경우 파일 시스템은 네임스페이스의 해당 위치에 "존재"한다고 하며 클라이언트는 일반적으로 이를 사용하며 주요 위치가 더 이상 존재하지 않는 상황에 대해 위치 관련 속성을 통해 지정된 추가 위치의 사용을 예약합니다. 사용 가능.

문제의 네임스페이스 위치에 실제 파일 시스템이 없으면 파일 시스템이 "없다"고 합니다. 부재 파일 시스템에는 루트 이외의 파일이나 디렉터리가 포함되어 있지 않습니다. 대체 위치를 결정하는 데 유용한 작은 속성 세트에 액세스하는 것을 제외하고 이를 참조하면 NFS4ERR\_MOVED 오류가 발생합니다. 서버가 NFS4ERR\_MOVED 오류를 반환하는 경우 fs\_locations 속성을 지원해야 하며 fs\_locations\_info 및 fs\_status 속성을 지원해야 합니다.\(MUST\)

오류 이름은 한때 존재했다가 나중에 없어진 파일 시스템의 경우를 암시하지만 이는 하나의 가능성일 뿐입니다. 네임스페이스의 위치는 위치 속성으로 지정된 파일 시스템 집합이 유일한 실현이므로 영구적으로 없을 수 있습니다. NFS4ERR\_MOVED라는 이름은 해당 기능에 대한 이전의 보다 제한된 개념을 반영하지만, 이동 여부에 관계없이 참조된 파일 시스템이 없을 때마다 이 오류가 반환됩니다.

GETATTR 유형 작업\(나중에 논의됨\)의 경우를 제외하고, 작업 시작 시 현재 파일 핸들이 없는 파일 시스템 내에 있으면 해당 작업은 수행되지 않고 NFS4ERR\_MOVED 오류가 반환됩니다. 현재 서버에는 시스템이 없습니다.

현재 파일 핸들이 없는 파일 시스템 내에 있으면 GETFH가 성공할 수 없기 때문에 없는 파일 시스템 내의 파일 핸들을 클라이언트로 전송할 수 없습니다. 클라이언트가 없는 파일 시스템 내에 파일 핸들을 갖고 있는 경우 이는 파일 시스템이 존재할 때 해당 파일 핸들을 획득하고 이후에 파일 시스템이 없게 된 결과입니다.

존재하지 않는 파일 시스템 내에 있는 현재 파일 핸들에 대한 검사는 모든 작업 시작 시 발생하기 때문에 존재하지 않는 파일 시스템 내에 있도록 현재 파일 핸들을 변경하는 작업에서는 오류가 발생하지 않습니다. 이를 통해 PUTFH-GETATTR 및 LOOKUP-GETATTR과 같은 조합을 사용하여 아래에 설명된 대로 속성 정보, 특히 위치 속성 정보를 얻을 수 있습니다.

RECOMMENDED 파일 시스템 속성 fs\_status는 주어진 파일 시스템의 현재/부재 상태를 조사하는 데 사용될 수 있습니다.\(SHOULD\)

---
### **11.4.  Getting Attributes for an Absent File System**

파일 시스템이 없으면 대부분의 속성을 사용할 수 없지만 사용 가능한 작은 속성 세트, 특히 이 파일 시스템의 올바른 현재 위치에 대한 정보를 제공하는 속성\(fs\_locations\)에 대한 클라이언트 액세스를 허용해야 합니다. 및 fs\_locations\_info.

---
#### **11.4.1.  GETATTR within an Absent File System**

위에서 언급한 것처럼 GETATTR의 경우 부재한 파일 시스템 내에서 파일 핸들에 대한 속성을 얻을 수 있다는 점에서 예외가 있습니다. 이 예외는 클라이언트가 부재 파일 시스템에 관한 결과\(fs\_locations, fs\_locations\_info 또는 fs\_status\)에 관심이 있음을 나타내는 속성 비트가 속성 마스크에 하나 이상 포함된 경우에만 적용됩니다. 이러한 속성 중 어느 것도 요청되지 않으면 GETATTR은 NFS4ERR\_MOVED 오류를 발생시킵니다.

존재하지 않는 파일 시스템에서 GETATTR이 수행되면 지원되는 속성 세트가 매우 제한됩니다. 일반적으로 필수 속성을 포함하여 많은 속성은 부재 파일 시스템에서는 사용할 수 없습니다. 위에서 언급한 속성\(fs\_locations, fs\_locations\_info, fs\_status\) 외에도 다음 속성을 부재 파일 시스템에서 사용할 수 있어야 합니다. RECOMMENDED 속성의 경우 최소한 현재 파일 시스템에서 사용할 수 있는 것과 동일한 수준으로 사용할 수 있어야 합니다.\(MUST, SHOULD, SHOULD\)

change\_policy: 이 속성은 파일 시스템이 없는 경우 유용하며 위치 관련 속성이 변경될 때 클라이언트에 요약하는 데 도움이 될 수 있습니다.

fsid: 이 속성은 클라이언트가 특히 현재 파일 시스템과 존재하지 않는 파일 시스템 사이의 경계를 포함하여 파일 시스템 경계를 결정할 수 있도록 제공되어야 합니다. 이 값은 현재 서버의 다른 fsid와 달라야 하며 클라이언트가 연결될 수 있는 특정 대상의 fsid와 특별한 관계가 있을 필요가 없습니다.

Mounted\_on\_fileid: 존재하지 않는 파일 시스템의 상단에 있는 객체의 경우 이 속성을 사용할 수 있어야 합니다. 파일 ID는 현재 상위 파일 시스템 내에 있으므로 이 정보를 제공하기 위해 존재하지 않는 파일 시스템을 참조할 필요가 없습니다.

다른 속성을 제공할 수 있는 경우에도 없는 파일 시스템에 대해 다른 속성을 사용해서는 안 됩니다. 서버는 정보가 많을수록 항상 더 좋다고 가정해서는 안 되며, 추가 정보를 불필요하게 제공하는 것도 피해야 합니다.\(SHOULD NOT\)

GETATTR 작업에 fs\_locations, fs\_locations\_info 또는 fs\_status 속성 중 하나에 대한 비트 마스크가 포함되어 있지만 비트 마스크에 지원되지 않는 속성이 포함된 경우 GETATTR은 오류를 반환하지 않지만 지원되는 실제 속성의 마스크를 반환합니다. 결과.

VERIFY/NVERIFY 처리는 속성 마스크에 fs\_locations, fs\_locations\_info 또는 fs\_status가 포함되지 않은 경우 NFS4ERR\_MOVED 오류가 발생한다는 점에서 GETATTR과 유사합니다. 부재 파일 시스템에 대해 지원되지 않는 속성의 속성 마스크에 나타나는 모든 점\(여기에는 일반적으로 필수 속성이 일부 포함됨\)도 NFS4ERR\_MOVED 결과를 초래한다는 점에서 다릅니다.\(MUST\)

---
#### **11.4.2.  READDIR and Absent File Systems**

현재 파일 핸들이 없는 파일 시스템 내에 있을 때 수행되는 READDIR은 NFS4ERR\_MOVED 오류를 발생시킵니다. GETATTR의 경우와 달리 READDIR에 대해서는 그러한 예외가 발생하지 않기 때문입니다.

존재하지 않는 파일 시스템에 대한 속성은 해당 디렉토리에 하나 이상의 존재하지 않는 파일 시스템의 루트 디렉터리가 포함되어 있는 경우 현재 파일 시스템의 디렉터리에 대한 READDIR을 통해 가져올 수 있습니다. 이 경우 처리는 다음과 같습니다.

\* 요청된 속성 세트에 fs\_locations, fs\_locations\_info 또는 fs\_status 속성 중 하나가 포함된 경우 속성 페치는 정상적으로 진행되며 rdattr\_error 속성이 요청된 경우에도 NFS4ERR\_MOVED 표시가 반환되지 않습니다.

\* 요청된 속성 세트에 fs\_locations, fs\_locations\_info 또는 fs\_status 속성 중 하나가 포함되어 있지 않은 경우, rdattr\_error 속성이 요청되면 존재하지 않는 파일 시스템의 루트에 대한 각 디렉토리 항목은 NFS4ERR\_MOVED를 rdattr\_error 속성의 값으로 보고합니다.

\* 요청된 속성 세트에 fs\_locations, fs\_locations\_info, fs\_status 또는 rdattr\_error 속성이 포함되어 있지 않은 경우 디렉터리 내에 없는 파일 시스템의 루트가 발생하면 NFS4ERR\_MOVED 오류로 인해 READDIR이 실패하게 됩니다.

\* 파일 시스템이 없어서 속성을 사용할 수 없는 경우\(일반적으로 필수 속성인 경우에도\) 오류 표시가 발생하지 않습니다. 이 경우 존재하지 않는 파일 시스템의 루트 디렉토리에 대해 반환되는 속성 집합은 단순히 실제로 사용 가능한 속성으로 제한됩니다.\(MUST\)

---
### **11.5.  Uses of File System Location Information**

파일 시스템 위치 속성\(예: fs\_locations 및 fs\_locations\_info\)은 파일 시스템이 없을 가능성과 함께 안정적이고 관리 가능하며 확장 가능한 데이터 액세스를 위한 여러 가지 중요한 기능을 제공합니다.

파일 시스템이 있는 경우 이러한 속성은 다음을 제공할 수 있습니다.

\* 서버 오류, 통신 문제 또는 기타 문제로 인해 현재 복제본에 대한 지속적인 액세스가 불가능하거나 비현실적인 경우 동일한 데이터에 액세스하는 데 사용할 대체 복제본의 위치입니다. 이러한 대체 복제본의 프로비저닝 및 사용을 "복제"라고 하며 아래 섹션 11.5.4에서 설명합니다.

\* 현재 파일 시스템 인스턴스 또는 그 복제본에 액세스하는 데 사용되는 네트워크 주소입니다. 이 정보의 고객 사용은 아래 섹션 11.5.2에서 논의됩니다.

어떤 상황에서는 여러 복제본을 동시에 사용하여 문제의 파일 시스템에 대한 고성능 액세스를 제공할 수 있지만 서버 간 상태 공유가 부족하여 이러한 사용에 장애가 될 수 있습니다.

파일 시스템이 존재하지만 존재하지 않는 경우 클라이언트는 다른 복제본을 사용하여 데이터에 계속 액세스할 수 있는 기회를 얻을 수 있습니다. 이 경우 현재 존재하지 않는 파일 시스템의 데이터를 계속 사용하려고 시도하면 NFS4ERR\_MOVED 오류가 발생하고 후속 복제본 또는 가능한 복제본 선택 항목 세트를 가져와서 액세스를 계속하는 데 사용할 수 있습니다. 새로운 복제본 위치로의 액세스 이전을 "마이그레이션"이라고 하며 아래 섹션 11.5.4에서 설명합니다.

현재 파일 시스템이 없는 경우 파일 시스템 위치 지정은 한 서버에 있는 파일 시스템을 다른 서버에서 정의한 네임스페이스와 연결할 수 있는 수단을 제공하여 일반적인 다중 서버 네임스페이스 기능을 허용합니다. 이전에 존재하지 않았던 파일 시스템을 대신하여 이러한 원격 인스턴스를 지정하는 것을 "순수 참조"라고 하며 아래 섹션 11.5.6에서 설명합니다.

파일 시스템 위치와 관련된 속성에 대한 클라이언트 지원은 선택 사항이므로 서버는 예를 들어 프록시 역할을 하여 해당 클라이언트로부터 마이그레이션 및 참조 이벤트를 숨기는 조치를 취할 수 있습니다. 서버는 EXCHANGE\_ID 작업의 인수에서 클라이언트 지원 여부를 확인할 수 있습니다\(섹션 18.35.3 참조\).\(MAY\)

---
#### **11.5.1.  Combining Multiple Uses in a Single Attribute**

파일 시스템 위치 속성에는 여러 복제본의 위치와 관련된 정보가 포함되는 경우가 있으며, 이는 다양한 방식으로 사용될 수 있습니다.

\* 현재 사용 중인 파일 시스템 인스턴스와 관련된 파일 시스템 위치 항목은 클라이언트가 인스턴스에 액세스할 수 있는 추가 네트워크 주소를 찾을 수 있도록 트렁킹 정보를 제공합니다.

\* 액세스가 전송될 복제본에 대한 정보를 제공하는 파일 시스템 위치 항목입니다.

\* 현재 복제본에 대한 액세스가 만족스럽지 못한 경우 사용할 수 있는 복제본과 관련된 기타 파일 시스템 위치 항목입니다.

클라이언트 처리를 단순화하고 최상의 복제본에 액세스할 수 있도록 하려면 서버는 다음 지침을 준수해야 합니다.

\* 단일 파일 시스템 인스턴스와 관련된 모든 파일 시스템 위치 항목은 인접해야 합니다.

\* 현재 사용 중인 인스턴스와 관련된 파일 시스템 위치 항목이 먼저 나타나야 합니다.

\* 마이그레이션이 발생하는 복제본과 관련된 파일 시스템 위치 항목은 현재 복제본에 액세스할 수 없게 되는 경우 나중에 사용할 수 있는 복제본 앞에 나타나야 합니다.

---
#### **11.5.2.  File System Location Attributes and Trunking**

트렁킹은 데이터 전송 속도를 높이기 위해 클라이언트와 서버 간에 다중 연결을 사용하는 것입니다. 클라이언트는 다양한 방법으로 특정 파일 시스템에 액세스하는 데 사용할 네트워크 주소 집합을 결정할 수 있습니다.

\* 서버 이름이 클라이언트에 알려지면 DNS를 사용하여 서버에 액세스하는 데 사용할 네트워크 주소 집합을 얻을 수 있습니다.

\* 클라이언트는 파일 시스템에 대한 파일 시스템 위치 속성을 가져올 수 있습니다. 이는 서버 이름\(DNS를 사용하여 네트워크 주소 집합으로 변환될 수 있음\) 또는 서버 트렁크 가능 위치 항목 집합을 제공합니다. 후자의 대안을 사용하면 서버는 문제의 파일 시스템에 액세스하는 데 사용하는 것이 바람직하다고 간주되는 주소를 제공할 수 있습니다. 이러한 항목에는 포트 번호가 포함될 수 있지만 이러한 포트 번호는 트렁킹 관계를 결정하는 데 사용되지 않습니다. 후보 주소가 결정되고 EXCHANGE\_ID가 적절한 서버에 수행되면 문제의 서버에서 반환된 so\_major\_id 필드의 값만이 트렁킹 관계가 실제로 존재하는지 여부를 결정합니다.

클라이언트가 파일 시스템에 대한 위치 속성을 가져올 때 클라이언트는 여러 가지 이유로 여러 항목을 만날 수 있다는 점에 유의해야 합니다. 예를 들어 트렁킹 정보를 결정할 때 이미 알려진 주소로 트렁킹할 수 없는 주소를 우회해야 할 수도 있습니다.

서버는 이름이나 네트워크 주소가 포함된 위치 항목을 제공할 수 있습니다. DNS 관련 보안 문제로 인해 또는 사용할 주소 집합을 서버에서 적극적으로 관리해야 할 수 있기 때문에 후자 형식을 사용할 수 있습니다.

트렁킹에 사용할 후보 주소를 찾는 데 사용되는 위치 항목은 아래 섹션 11.5.7에 설명된 대로 변경될 수 있습니다. 클라이언트는 확인된 후 추가 주소를 사용하거나 기존 주소 사용을 중단함으로써 이러한 변경에 대응할 수 있습니다. 서버는 해당 주소가 파일 시스템에 액세스하는 데 사용될 때 NFS4ERR\_MOVED를 반환하여 클라이언트가 주소 사용을 중단하도록 강제할 수 있습니다. 이를 통해 전체에서 동일한 파일 시스템 인스턴스에 액세스하더라도 마이그레이션과 유사한 클라이언트 액세스 전송이 가능합니다.

---
#### **11.5.3.  File System Location Attributes and Connection Type Selection**

여러 유형의 연결을 지원해야 하기 때문에 클라이언트는 지정된 서버 네트워크 주소에 대한 연결을 설정할 때 사용할 적절한 연결 유형을 결정하는 문제에 직면합니다. 어떤 경우에는 이 문제가 섹션 18.36에 설명된 연결 "단계별" 기능을 사용하여 해결될 수 있습니다. 그러나 해당 기능을 사용할 수 없는 경우가 있으므로 클라이언트는 단일 연결 범위 내에서 변경할 가능성이 없는 연결 유형을 선택해야 할 수도 있습니다.

두 파일 시스템 위치 속성은 이와 관련하여 제공되는 정보에 따라 다릅니다. fs\_locations 속성은 연결 유형 선택을 지원하는 정보를 제공하지 않습니다. 결과적으로 여러 연결 유형을 지원하는 클라이언트는 클라이언트가 선호하는 연결 유형이 성공적으로 설정될 때까지 여러 연결 유형을 사용하여 연결 설정을 시도해야 합니다.

fs\_locations\_info 속성에는 RDMA를 사용하려는 클라이언트에 편리한 FSLI4TF\_RDMA 플래그가 포함되어 있습니다. 이 플래그가 설정되면 지정된 위치 항목을 사용하여 RPC-over-RDMA 지원을 사용할 수 있음을 나타냅니다. 클라이언트는 TCP 연결을 설정한 다음 스텝업 기능을 사용하여 RDMA를 사용하도록 해당 연결을 변환할 수 있습니다.

사용된 특정 속성에 관계없이 step-up 작업을 수행할 수 있다는 표시가 없는 경우 RDMA 작업을 지원하는 클라이언트는 새로운 RDMA 연결을 설정할 수 있으며 TCP 연결에 의해 이미 설정된 세션에 바인딩될 수 있습니다. 서버가 이를 지원하는 경우 TCP 연결이 삭제되고 세션이 RDMA 모드에서 추가로 사용되도록 변환됩니다.

---
#### **11.5.4.  File System Replication**

fs\_locations 및 fs\_locations\_info 속성은 현재 파일 시스템 인스턴스 대신 또는 그에 추가하여 데이터에 액세스하는 데 사용할 대체 파일 시스템 위치를 제공합니다. 파일 시스템에 처음 액세스할 때 클라이언트는 fs\_locations 또는 fs\_locations\_info 속성을 조사하여 대체 위치 세트를 얻어야 하며 후자가 선호됩니다.

서버 오류, 통신 문제 또는 기타 어려움으로 인해 현재 파일 시스템에 대한 지속적인 액세스가 불가능하거나 비현실적인 경우 클라이언트는 해당 데이터에 대한 지속적인 액세스를 얻는 방법으로 대체 위치를 사용할 수 있습니다.

대체 위치는 비동기식 업데이트 전파로 보완되는 파일 시스템 데이터\(일반적으로 읽기 전용\)의 물리적 복제본일 수 있습니다. 대안으로, 여러 서버가 동일한 물리적 파일 시스템에 액세스하는 대체 방법을 제공하는 다양한 형태의 서버 클러스터링을 사용할 수 있습니다. 복제본 간의 차이가 파일 시스템 전환에 미치는 영향은 fs\_locations 및 fs\_locations\_info 속성 내에서 표시할 수 있으며, 클라이언트가 파일 시스템 전환 문제를 처리하는 방법은 이후 섹션에서 자세히 설명합니다.

위치 속성은 복제본 간 전환의 특성에 대한 일부 정보를 제공하지만 가능한 비동기 업데이트의 의미론적 측면은 현재 프로토콜에 설명되어 있지 않습니다. 따라서 복제를 사용하는 클라이언트는 변경이 진행 중인 복제본 간에 전환하여 익숙해져야 합니다. 사용된 업데이트 접근 방식의 의미를 그대로 사용합니다. 이러한 특정성 부족으로 인해 서버는 마이그레이션 이벤트의 일부로 설정된 특정 시점 이전에 수행된 모든 업데이트를 새 복제본에 전파할 수 있기 때문에 많은 애플리케이션에서 마이그레이션 사용이 더 적절하다고 생각할 수 있습니다.

---
##### **11.5.4.1.  File System Trunking Presented as Replication**

어떤 상황에서는 파일 시스템 위치 항목이 복제 대신 트렁킹이 사용되는 대체 위치로 사용될 파일 시스템 액세스 경로를 나타낼 수 있습니다. 이것이 적절한 상황은 다음 두 가지 모두에 해당하는 경우로 제한됩니다.

\* 두 개의 파일 시스템 위치\(즉, 위치 속성을 얻은 위치와 파일 시스템 위치 항목에 지정된 위치\)는 각각의 단일 서버 네임스페이스 내에서 동일한 위치를 지정합니다.

\* 두 개의 서버 네트워크 주소\(즉, 위치 속성을 얻는 데 사용되는 주소와 파일 시스템 위치 항목에 지정된 주소\)는 동일한 서버를 지정합니다\(eir\_server\_owner 필드의 so\_major\_id 필드 값이 동일함\). EXCHANGE\_ID에 대한 응답\).

이러한 조건이 유지되면 fs\_locations\_info 속성이 사용될 때 트렁킹이 허용되지 않을 수 있지만 두 액세스 경로를 사용하는 작업은 일반적으로 트렁킹됩니다.

\* fs\_locations\_info 속성에 두 항목이 동일한 동시 사용 클래스가 없는 것으로 표시되면 트렁킹이 금지되고 두 액세스 경로를 함께 사용할 수 없습니다.

이 경우 두 경로를 아무런 문제 없이 직렬로 사용할 수 있습니다.

- 클라이언트 측에서 필요한 전환 활동과 액세스 경로 간의 모든 전환이 투명합니다. 한 곳에서 다른 곳으로 액세스를 전송할 때 클라이언트는 통신이 중단된 것처럼 작동하여 동일한 파일 시스템에 계속 액세스할 수 있도록 새 연결과 새 세션을 설정합니다.

\* 이러한 두 위치 항목의 경우 특별한 전환 활동이 필요함을 나타내는 fs\_locations\_info 속성 내의 모든 정보\(예: 서로 다른 핸들, fileid, write-verifier, 변경 및 readdir 클래스가 있는 두 파일 시스템 위치 항목의 모양\)에 유의하세요. , 심각한 문제를 나타냅니다. 클라이언트가 파일 시스템 인스턴스로의 전환을 허용하는 경우 어떤 전환도 투명한 전환으로 처리하면 안 됩니다. 서버는 두 항목이 동일한 동시 항목에 속하는 것으로 표시되는지 여부에 관계없이 이러한 두 항목\(동일한 서버의 동일한 파일 시스템에 대한\)이 서로 다른 핸들, 파일 ID, 쓰기 검증자, 변경 및 readdir 클래스에 속한다고 표시해서는 안 됩니다. - 수업을 이용하세요.\(SHOULD NOT\)

이러한 상황은 해당 문서에서 트렁킹에 대해 명시적으로 언급하지 않았음에도 불구하고 \[66\]에서 인식되었습니다.

\* 트렁킹으로 설명하는 상황을 두 개의 서로 다른 파일 시스템 인스턴스를 동시에 사용하는 상황으로 취급했습니다. 그러나 현재 상황을 설명하는 데 사용되는 설명 프레임워크에서는 단일 파일 시스템에 두 개의 파일 시스템이 액세스하는 경우가 있습니다. 다른 트렁크 주소.

\* 두 경로가 연속적으로 사용되는 상황을 특별한 종류의 "투명 전환"으로 처리했습니다. 그러나 현재 전환 상황을 분류하는 데 사용되는 설명적 프레임워크에서는 이는 "네트워크 종단점 전환"의 사례로 간주됩니다\(섹션 11.9 참조\).

---
#### **11.5.5.  File System Migration**

파일 시스템이 존재하고 현재 액세스 경로를 사용하여 액세스할 수 없게 되면 NFSv4.1 프로토콜은 클라이언트가 해당 데이터에 계속 액세스할 수 있는 기회를 제공할 수 있는 수단을 제공합니다. 여기에는 기존 복제본에 대한 다른 액세스 경로를 사용하거나 다른 복제본에 대한 경로를 제공하는 것이 포함될 수 있습니다. 새 액세스 경로 또는 새 복제본의 위치는 파일 시스템 위치 속성으로 지정됩니다. 후속 액세스 마이그레이션에는 전환 전반에 걸쳐 잠금을 유지하는 기능이 포함됩니다. 상황에 따라 여기에는 다음이 포함될 수 있습니다.

\* 새 액세스 경로를 사용하여 현재 복제본에 액세스할 때 기존 클라이언트 ID를 계속 사용합니다.

\* fs별 유예 기간을 활용하여 잠금 회수를 사용합니다.

\* 투명한 상태 마이그레이션 사용.

일반적으로 클라이언트는 문제의 파일 시스템에 액세스하고 NFS4ERR\_MOVED 오류가 발생한 다음 파일 시스템 위치 속성을 사용하여 데이터에 대한 새 액세스 경로를 결정합니다. fs\_locations\_info를 사용하면 새 서버로의 전환에 대한 클라이언트 처리 특성을 정의하는 추가 정보를 사용할 수 있습니다.

대부분의 경우 서버는 여러 클라이언트가 서로 다른 복제본을 업데이트하는 경우를 피하기 위해 특정 파일 시스템을 사용하는 모든 클라이언트를 동시에 후속 복제본으로 마이그레이션하도록 선택합니다. 그러나 문제의 복제본이 섹션 11.11.8에 설명된 것과 동일한 데이터를 나타내는 한 개별 클라이언트의 마이그레이션은 로드 균형 조정을 제공하는 데 도움이 될 수 있습니다.

\* 레플리카 간 전환이 없는 경우\(즉, 액세스 경로만 변경된 경우\) 로드 밸런싱에 영향을 주기 위해 이 메커니즘을 사용하는 데 특별한 어려움은 없습니다.

\* 두 개의 복제본이 단일 클라이언트가 두 가지 모두에 일관되게 동시에 액세스할 수 있도록 충분히 조정된 경우 일반적으로 로드 밸런싱을 수행하기 위해 특정 클라이언트를 마이그레이션하는 데 장애가 없습니다. 일반적으로 이러한 동시 사용에는 두 개의 조정된 복제본에 부여된 잠금이 충돌하지 않고 공통 복제본으로 전송될 때 유효한 상태를 유지할 수 있도록 서버 간의 협력이 필요합니다.

\* 대규모 클라이언트 집합이 읽기 전용 방식으로 파일 시스템에 액세스하는 경우 읽기 전용 복사본 집합에서 로드 밸런싱을 사용하는 동시에 쓰기 가능한 액세스 권한이 있는 모든 클라이언트를 마이그레이션하는 것이 도움이 될 수 있습니다. 데이터 반환을 방지하도록 설계된 섹션 11.11.8의 규칙을 준수하는 한.

다른 경우에는 클라이언트가 제대로 작동하기 위한 데이터 유사성 또는 일관성을 충분히 보장하지 못할 수도 있습니다\(예: 두 복제본의 데이터가 유사하지만 동일하지 않음\). 서로 다른 클라이언트가 서로 다른 복제본을 업데이트할 가능성이 문제를 더욱 악화시킬 수 있습니다. 그러한 상황에서 로드 밸런싱을 사용하는 것은 위험한 일입니다.

프로토콜은 서버 간에 파일 시스템을 이동하는 방법이나 여러 복제본에 대한 업데이트를 조정하는 방법을 지정하지 않습니다. 다양한 서버 간 조정 메커니즘이 사용될 수 있으며 선택은 서버 구현자에게 맡겨질 것으로 예상됩니다. NFSv4.1 프로토콜은 클라이언트와 서버 간에 마이그레이션 이벤트를 전달하는 데 사용되는 방법을 지정합니다.

다양한 형태의 서버 클러스터링의 경우 새 위치는 동일한 물리적 파일 시스템에 대한 액세스를 제공하는 다른 서버일 수 있습니다. 이 전환을 처리하는 클라이언트의 책임은 복제본 간의 전환이 발생했는지 여부와 서버가 잠금 상태의 연속성을 제공하기 위해 선택한 방법에 따라 달라집니다. 이러한 문제는 아래에서 자세히 논의됩니다.

단일 후속 위치가 일반적이지만 여러 위치가 제공될 수도 있습니다. 여러 위치가 제공되는 경우 클라이언트는 일반적으로 제공된 첫 번째 위치를 사용합니다. 어떤 이유로든 액세스할 수 없는 경우 나중에 사용할 수 있습니다. 이러한 경우 클라이언트는 관련된 서버 중 일부가 액세스할 수 없는 서버의 사용을 인식하지 못하더라도 새 복제본으로의 전환을 마이그레이션 이벤트로 간주할 수 있습니다. 이러한 경우 클라이언트는 액세스 전송의 결과로 잠금 상태에 대한 액세스를 잃을 수 있습니다.

대체 위치가 마이그레이션 대상으로 지정되면 동일한 데이터를 지정해야 합니다\(메타데이터는 fs\_locations\_info 속성에 표시된 정도와 동일함\). 파일 시스템이 쓰기 가능한 경우 원래 파일 시스템에 대한 변경 사항이 모든 마이그레이션 대상에서 표시되어야 합니다. 파일 시스템이 쓰기 가능하지 않지만 쓰기 가능한 파일 시스템의 읽기 전용 복사본\(주기적으로 업데이트될 수 있음\)을 나타내는 경우 업데이트 전파에 유사한 요구 사항이 적용됩니다. 원본 파일 시스템에 표시되는 모든 변경 사항은 모든 마이그레이션 대상에 이미 적용되어 있어야 합니다. 이는 클라이언트가 마이그레이션 대상으로 전환할 때 파일 시스템 상태가 반전되는 것을 볼 가능성을 방지하기 위한 것입니다.

---
#### **11.5.6.  Referrals**

조회를 통해 서버는 한 서버에 있는 파일 시스템 네임스페이스 항목을 다른 서버에 있는 파일 시스템과 연결할 수 있습니다. 여기에 순수 참조 사용이 포함되는 경우 서버에는 특정 서버의 물리적 위치와 관계없이 본질적으로 네임스페이스 내의 위치에 파일 시스템을 배치하는 방법이 제공됩니다. 이를 통해 단일 서버 또는 서버 세트는 더 넓은 범위의 서버에 위치한 파일 시스템을 포함하는 다중 서버 네임스페이스를 제공할 수 있습니다. 이 기능의 일부 가능한 용도에는 사이트 전체 또는 조직 전체 네임스페이스의 설정이 포함되며, 궁극적으로 이러한 네임스페이스를 AFS\(Andrew File System\)에서 제공하는 것과 같은 진정한 글로벌 네임스페이스로 결합할 수 있습니다\[65\].

클라이언트가 현재 네임스페이스의 위치를 ​​처음 참조할 때 해당 위치가 새 파일 시스템의 일부이고 해당 파일 시스템이 없다고 판단하면 참조가 발생합니다. 이런 일이 발생하면 일반적으로 NFS4ERR\_MOVED 오류가 수신되면 위치 속성을 가져와서 파일 시스템의 실제 위치를 확인할 수 있습니다.

파일 시스템 위치 속성은 클라이언트의 요구에 따라 선택될 단일 파일 시스템 위치 또는 다중 파일 시스템 위치를 지정할 수 있습니다. 서버는 fs\_locations\_info 속성에서 다양한 파일 시스템 위치 선택과 연관될 우선순위를 지정할 수 있습니다. 서버는 클라이언트의 물리적 위치에 적응하거나 로드 밸런싱에 영향을 미치기 위해 개별 클라이언트에 보고된 대로 서로 다른 위치에 서로 다른 우선순위를 할당할 수 있습니다. 읽기 전용 파일 시스템과 읽기/쓰기 파일 시스템이 모두 존재하는 경우 읽기 전용 위치 중 일부는 완전히 최신 상태가 아닐 수 있습니다\(복제 및 마이그레이션의 경우에는 최신 상태여야 함\). 서버는 또한 클라이언트 대체 변수를 포함하는 파일 시스템 위치를 지정할 수 있으므로 CPU 아키텍처와 같은 클라이언트 속성을 기반으로 다양한 클라이언트가 다양한 파일 시스템\(다른 데이터 콘텐츠 포함\)을 참조할 수 있습니다.

fs\_locations\_info 속성이 여러 개의 가능한 대상을 나열하는 경우 클라이언트가 사용할 대상을 선택할 때 이들 사이의 관계가 중요할 수 있습니다. 여러 마이그레이션 대상과 관련하여 아래 섹션 11.5.5에 지정된 동일한 규칙이 이러한 여러 복제본에도 적용됩니다. 예를 들어, 클라이언트는 나중에 전환할 수 있는 추가 쓰기 가능한 복제본이 있는 서버의 쓰기 가능한 대상을 선호할 수 있습니다. 복제의 경우와 달리 현재 클라이언트가 해당 파일 시스템에 액세스하지 않았으므로 현재 클라이언트에서 업데이트를 전파하는 경우를 처리할 필요가 없습니다.

다중 서버 네임스페이스 사용은 NFSv4.1에서 활성화되지만 필수는 아닙니다. 다중 서버 네임스페이스의 사용과 그 범위는 사용되는 애플리케이션과 시스템 관리 기본 설정에 따라 달라집니다.

다중 서버 네임스페이스는 포함된 모든 파일 시스템에 대한 대규모 순수 참조 세트를 제공하는 단일 서버에 의해 구축될 수 있습니다. 대안으로, 단일 다중 서버 네임스페이스는 네임스페이스의 개별적으로 관리되는 각 부분에 대해 별도의 참조 파일 시스템\(별도의 서버에 있음\)으로 관리상 분할될 수 있습니다. 최상위 참조 파일 시스템 또는 모든 세그먼트는 가용성을 높이기 위해 복제된 참조 파일 시스템을 사용할 수 있습니다.

일반적으로 다중 서버 네임스페이스는 네임스페이스의 특정 위치에 있는 한 클라이언트에 제공되는 동일한 데이터가 해당 네임스페이스 위치에 있는 모든 클라이언트에 제공된다는 점에서 대부분 균일합니다. 그러나 CPU 아키텍처와 같은 클라이언트 특성에 적응할 수 있도록 하는 등의 이유로 다양한 클라이언트를 다양한 데이터 세트로 지정할 수 있는 기능이 제공됩니다. 이러한 시설은 섹션 11.17.3에 설명되어 있습니다.

균일한 네임스페이스를 제공할 때 각 클라이언트에 물리적으로 가장 가까운 데이터 복사본을 제공하거나 액세스를 최적화\(예: 로드 밸런싱 제공\)하기 위해 서로 다른 클라이언트에 서로 다른 위치 항목을 제공하는 것이 가능합니다.

---
#### **11.5.7.  Changes in a File System Location Attribute**

클라이언트는 일반적으로 파일 시스템에 처음 액세스할 때와 NFS4ERR\_MOVED가 반환될 때 파일 시스템 위치 속성을 가져오지만 클라이언트는 주기적으로 속성을 가져오도록 선택할 수 있습니다. 이 경우 가져온 값은 시간이 지남에 따라 변경될 수 있습니다.

여러 복제본에 동시에 액세스할 준비가 되지 않은 클라이언트의 경우\(섹션 11.11.1 참조\) 다양한 위치 변경 사례를 처리하는 방법은 다음과 같습니다.

\* 복제본 목록이나 복제본과 연결된 네트워크 주소가 변경되는 경우 즉각적인 조치가 필요하지 않습니다. 클라이언트는 일반적으로 새 정보를 반영하기 위해 복제본 목록을 업데이트합니다.

\* 현재 파일 시스템 인스턴스의 네트워크 주소 목록에 대한 추가 사항은 즉시 조치를 취할 필요가 없습니다. 그러나 후속 마이그레이션 이벤트를 준비하기 위해 클라이언트는 새 주소를 기록한 다음 새 복제본에 대한 액세스를 전환해야 할 때마다 이를 사용하도록 선택할 수 있습니다.

\* 현재 파일 시스템 인스턴스에 대한 네트워크 주소 목록에서 삭제하더라도 삭제된 주소에 새 연결이 설정되지는 않지만 클라이언트가 기존 액세스 경로의 사용을 즉시 중단할 필요는 없습니다. 그러나 클라이언트는 현재 파일 시스템에 액세스하는 데 특정 네트워크 액세스 경로를 사용할 수 없음을 나타내기 위해 서버가 NFS4ERR\_MOVED를 반환하자마자 피할 수 없게 되는 최종 액세스 전환에 대비하여 이러한 삭제에 대한 조치를 취하도록 선택할 수 있습니다.

여러 복제본에 동시에 액세스할 준비가 된 클라이언트의 경우 다음과 같은 추가 사례를 해결해야 합니다. 위에서 설명한 경우처럼, 클라이언트가 새 복제본을 선택하는 데 어려움이 없더라도 액세스를 조정할 수 있는 옵션이 있더라도 복제본 세트의 변경 사항은 즉시 조치를 취할 필요가 없습니다.

\* 현재 사용 중인 복제본과 동시에 액세스할 수 있는 새 복제본이 추가되면 클라이언트는 새 복제본을 즉시 자유롭게 사용할 수 있습니다.

\* 현재 사용 중인 복제본이 목록에서 삭제된 경우 클라이언트는 해당 복제본의 사용을 즉시 중단할 필요가 없습니다. 그러나 서버는 이후에 이러한 사용을 강제로 중지할 수 있으므로\(NFS4ERR\_MOVED를 반환하여\) 클라이언트는 나중에 상태 전송의 필요성을 제한하기로 결정할 수 있습니다. 예를 들어 목록에 없는 복제본이 아닌 다른 복제본에서 새로 열기가 수행될 수 있습니다.

---
### **11.6.  Trunking without File System Location Information**

두 개의 서버 트렁크 가능 주소\(EXCHANGE\_ID에 대한 응답으로 반환된 eir\_server\_owner 필드의 so\_major\_id 필드 값이 동일함\)를 사용하여 파일 시스템에 액세스하는 경우 위치 항목이 없더라도 트렁크 액세스가 허용됩니다. 특히 해당 파일 시스템에 대한 트렁킹 사용을 나타냅니다.

이 상황은 \[66\]에 의해 인식되었지만 해당 문서에서는 트렁킹에 대해 명시적으로 언급하지 않았으며 이 상황을 두 개의 개별 파일 시스템 인스턴스를 동시에 사용하는 상황으로 취급했습니다. 현재 상황을 설명하는 데 사용되는 설명 프레임워크에서는 단일 파일 시스템이 두 개의 서로 다른 트렁크 주소로 액세스되는 경우입니다.

---
### **11.7.  Users and Groups in a Multi-Server Namespace**

단일 서버 환경\(섹션 5.9 참조\)의 경우와 마찬가지로 "id@domain" 형식의 소유자 또는 그룹 이름이 파일에 할당되면 해당 속성이 반환될 때 동일한 문자열을 반환하겠다는 암시적 약속이 있습니다. 이후 심문을 받습니다. 다중 서버 네임스페이스의 경우 서버 경계를 넘어도 동일한 약속이 적용됩니다. 마찬가지로 파일의 소유자 특성이 파일을 만든 보안 주체에서 파생된 경우 파일 생성과 다른 서버에서 질문이 발생하더라도 해당 특성은 동일한 값을 가져야 합니다.

마찬가지로 모든 참여 서버에서 인식되는 보안 주체 집합은 동일해야 하며, 액세스되는 특정 서버에 관계없이 각 주체는 동일한 자격 증명을 가지고 있어야 합니다.

이러한 요구 사항을 충족하려면 다중 서버 네임스페이스를 설정하는 사람들은 다음과 같이 포함된 서버를 제한해야 합니다.

\* 단일 도메인 이상이 지원되는 모든 경우에는 RFC 8000 \[31\]에 명시된 요구 사항을 준수해야 합니다.

\* 모든 서버는 클라이언트가 사용하고 "id@domain" 형식의 소유자 또는 그룹의 도메인 부분으로 반환될 것으로 예상되는 모든 도메인을 포함하는 공통 도메인 집합을 지원합니다. 이 세트는 대부분 단일 도메인으로 구성되지만 여러 도메인이 지원될 수도 있습니다.

\* 모든 서버는 지원하는 각 도메인에 대해 동일한 사용자 및 그룹 ID 세트를 유효한 것으로 허용합니다.

\* 모든 서버는 동일한 보안 주체 집합을 인식합니다. 각 보안 주체에는 액세스 중인 서버와 관계없이 동일한 자격 증명이 필요합니다. 또한 각 주체의 그룹 구성원은 액세스하는 서버와 관계없이 동일해야 합니다.

일반적으로 특정 보안 주체에 해당하는 사용자가 각 서버에서 동일한 로컬 표현을 가져야 한다는 요구 사항은 없습니다. 이는 대부분의 경우에도 마찬가지입니다.

AUTH\_SYS를 사용하는 경우 다음 추가 요구 사항을 충족해야 합니다.

\* AUTH\_SYS를 사용하면 단일 NFSv4 도메인만 지원할 수 있습니다.

\* 모든 소유자 및 그룹의 "로컬" 표현은 모든 서버에서 동일해야 합니다. "로컬"이라는 단어는 섹션 5.9에서 숫자 사용자 및 그룹 ID를 설명하는 방식이므로 여기에서 사용됩니다. 그러나 AUTH\_SYS 또는 문자열화된 숫자 소유자 또는 그룹이 사용되는 경우 이러한 식별자는 서버뿐만 아니라 클라이언트에도 알려지기 때문에 실제로 로컬이 아닙니다.

마찬가지로, 문자열화된 숫자 사용자 및 그룹 ID가 사용되는 경우 모든 소유자 및 그룹의 "로컬" 표현은 AUTH\_SYS가 사용되지 않는 경우에도 모든 서버에서 동일해야 합니다.

---
### **11.8.  Additional Client-Side Considerations**

클라이언트가 참조, 복제 및 마이그레이션을 구현하는 서버를 사용할 때 참조 또는 재배치된 파일 시스템을 포함하는 지정된 파일 시스템을 마운트하는 사용자가 해당 사용자 측 파일 시스템의 일관된 그림을 계속 볼 수 있도록 주의해야 합니다. 다른 서버에 있을 수 있는 다수의 서버측 파일 시스템이 포함되어 있음에도 불구하고.

한 가지 중요한 문제는 서버측 파일 시스템의 루트에서 상위\(UNIX의 경우 ".."로 지정됨\)로 상향 탐색하는 것입니다. 이 경우 참조, 마이그레이션 또는 작업의 결과로 해당 파일 시스템으로 전환됩니다. 복제 결과로 인한 전환. 클라이언트가 그러한 지점에 있고 상위로 올라가야 하는 경우 LOOKUPP 작업을 서버에 보내는 대신 다중 서버 네임스페이스 내에서 볼 수 있듯이 상위로 돌아가야 합니다. 해당 서버의 단일 서버 네임스페이스입니다. 이를 수행하려면 클라이언트는 해당 파일 시스템 루트를 나타내는 파일 핸들을 기억하고 현재 서버에 LOOKUPP 작업을 보내는 대신 이를 사용해야 합니다. 이를 통해 클라이언트는 상향 탐색과 하향 탐색이 일관된 일관된 네임스페이스를 애플리케이션에 제공할 수 있습니다.

또 다른 문제는 추천 위치 새로 고침과 관련이 있습니다. 조회가 광범위하게 사용되면 서버 구성이 변경됨에 따라 조회도 변경될 수 있습니다. 클라이언트는 참조 순회와 관련된 정보를 캐시하여 향후 클라이언트 측 요청이 서버 통신 없이 로컬로 해결될 것으로 예상됩니다. 이는 일반적으로 클라이언트측 이름 조회 캐싱에 뿌리를 두고 있습니다. 고객은 위치 정보의 변화를 감지하기 위해 추천 지점에 대한 이 데이터를 주기적으로 제거해야 합니다. 참조 항목을 보유하는 디렉토리 또는 참조 항목 자체에 대한change\_policy 속성이 변경되면 클라이언트는 연관된 캐시된 참조 정보가 최신이 아닌 것으로 간주해야 합니다.

---
### **11.9.  Overview of File Access Transitions**

파일 액세스 전환에는 두 가지 유형이 있습니다.

\* 복제 또는 마이그레이션과 관련하여 현재 복제본에 대한 액세스에서 다른 복제본으로의 전환이 포함되는 것입니다. 이것이 어떻게 처리되는지는 섹션 11.11에서 논의됩니다.

\* 현재 파일 시스템 인스턴스에 대한 액세스는 유지되지만 해당 인스턴스에 액세스하는 데 사용되는 네트워크 경로가 변경되는 경우. 이 경우는 섹션 11.10에서 논의됩니다.

---
### **11.10.  Effecting Network Endpoint Transitions**

특정 파일 시스템 인스턴스에 액세스하는 데 사용되는 엔드포인트는 아래 나열된 것처럼 다양한 방식으로 변경될 수 있습니다. 이러한 각 경우에는 동일한 fsid, 클라이언트 ID, 파일 핸들 및 상태 ID가 잠금 상태의 연속성과 함께 계속 액세스하는 데 사용됩니다. 대부분의 경우 동일한 세션을 사용할 수도 있습니다.

적절한 조치는 사용할 수 있는 대체 주소 세트\(예: 이전에 사용된 주소로 서버 트렁킹이 가능한 서버 엔드포인트\)에 따라 다릅니다.

\* 특정 주소의 사용이 중단될 예정이고, 현재 사용 중인 다른 주소와 함께 서버 트렁킹이 가능한 경우, 사용이 중단될 주소에서 발행되었던 요청이 나머지 주소에서 발행될 수 있습니다. \(에스\). 주소가 서버 트렁크 가능하지만 사용이 중단될 주소와 함께 세션 트렁크 가능하지 않은 경우 다른 세션이 사용된다는 사실을 반영하도록 요청을 수정해야 할 수도 있습니다.

\* 해당 연결을 사용할 때 NFS4ERR\_MOVED를 수신하여 특정 연결의 사용이 중단되지만 해당 주소가 적절한 파일 시스템 위치 항목에 따라 여전히 액세스 가능한 것으로 표시되는 경우 새 연결에서 요청이 발행될 수 있습니다. 연결이 설정되면 다른 연결 유형으로 변경됩니다. 네트워크 주소를 공유하는 포트별이 아닌 두 개의 서버 끝점은 본질적으로 세션 트렁크가 가능하므로 클라이언트는 BIND\_CONN\_TO\_SESSION을 사용하여 새 연결로 기존 세션에 액세스할 수 있습니다.

\* 사용 중인 잠재적인 대체 주소는 없지만 사용이 중단될 주소와 세션 트렁크 가능한 유효한 주소가 있는 경우 클라이언트는 BIND\_CONN\_TO\_SESSION을 사용하여 새 주소를 사용하여 기존 세션에 액세스할 수 있습니다. 일반적으로 대상 세션에 액세스할 수 있지만 새 연결을 바인딩하려고 시도할 때 해당 세션에 더 이상 액세스할 수 없는 드문 상황이 있을 수 있습니다. 이 경우 클라이언트는 새 연결을 사용하여 기존 인스턴스에 계속 액세스할 수 있도록 새 세션을 생성하여 잠금 상태의 연속성을 제공하는 동시에 기존 파일 핸들, 상태 ID 및 클라이언트 ID를 사용할 수 있습니다.

\* 사용 중인 잠재적인 대체 주소가 없고 사용이 중단될 주소와 세션 트렁크 가능한 유효한 주소가 없는 경우 지속적인 액세스를 제공하기 위해 다른 서버 트렁크 가능 주소를 사용할 수 있습니다. 기존 인스턴스에 대한 지속적인 액세스를 제공하기 위해 CREATE\_SESSION을 사용할 수 있지만 서버에는 세션 마이그레이션에서 제공되는 것과 유사한 방식으로 새 네트워크 액세스 경로를 통해 기존 세션에 대한 지속적인 액세스를 제공하는 옵션이 있습니다\(섹션 11.12 참조\). 이 가능성을 활용하기 위해 클라이언트는 이전 사례와 같이 초기 BIND\_CONN\_TO\_SESSION을 수행하고 실패할 경우에만 CREATE\_SESSION을 사용할 수 있습니다.

---
### **11.11.  Effecting File System Transitions**

특정 파일 시스템에 액세스하는 데 사용되는 복제본 세트에 변경 사항이 적용되는 상황은 다양합니다. 이들 중 일부는 아래 섹션 11.11.1에서 설명한 대로 사용된 복제본 세트의 확장 또는 축소를 포함할 수 있습니다.

해당 섹션에 설명된 이유로 인해 대부분의 전환에는 단일 복제본에서 해당 대체 복제본으로의 전환이 포함됩니다. 복제본 전환을 수행할 때 복제본 간의 일부 공유 유형은 아래 섹션 11.11.2\~11.11.8에 설명된 대로 전환 처리에 영향을 미칠 수 있습니다. fs\_locations\_info 속성은 클라이언트가 복제본 간 공유 정도를 결정할 수 있도록 유용한 정보를 제공합니다.

일부 상태 유형과 관련하여 전환 전체의 연속성 정도는 전환을 촉발하는 경우에 따라 달라지며, 서버에 의해 시작된 전환\(예: 마이그레이션\)은 클라이언트가 실행 중인 경우보다 훨씬 더 많은 무중단 전환 범위를 제공합니다. 자신의 액세스 권한을 다른 복제본\(즉, 복제\)으로 이동합니다. 이 문제는 잠재적으로 잠금 상태 및 세션 상태에 적용되며, 아래에서 다음과 같이 처리됩니다.

\* 이러한 영역에서 연속성을 제공할 수 있는 가능한 방법에 대한 소개는 아래 섹션 11.11.9에 나와 있습니다.

\* 투명한 상태 마이그레이션은 섹션 11.12에 소개되어 있습니다. 세션 상태의 가능한 전송도 여기서 다루어집니다.

\* 서버가 잠금 상태의 효과적인 연속성을 제공하기 위해 취할 수 있는 다양한 수단을 처리하는 방법을 결정하는 것을 포함하여 클라이언트 전환 처리는 섹션 11.13에서 논의됩니다.

\* 잠금 및 세션 상태의 Transparent State Migration을 수행하는 소스 및 대상 서버의 책임은 섹션 11.14에서 논의됩니다.

---
#### **11.11.1.  File System Transitions and Simultaneous Access**

fs\_locations\_info 속성\(섹션 11.17에 설명됨\)은 두 개의 복제본이 동시에 사용될 수 있음을 나타낼 수 있지만 그러한 동시 액세스가 허용되는 일부 상황은 트렁킹의 인스턴스로 더 적절하게 설명됩니다\(섹션 11.5.4.1 참조\). 여러 복제본에 동시에 액세스할 수 있는 상황은 여러 네트워크 주소에서 단일 복제본에 액세스하는 상황과 다소 유사하지만 잠금 상태가 여러 복제본 간에 공유되지 않는다는 점에서 중요한 차이점이 있습니다.

이러한 상태 처리 차이로 인해 많은 클라이언트는 이러한 복제본이 동일한 데이터를 나타낸다는 사실을 활용할 수 없습니다. 이러한 클라이언트는 여러 복제본을 동시에 사용할 준비가 되어 있지 않지만 선택한 복제본으로 인해 여러 서버 트렁크 가능 주소를 사용할 수 있더라도 단일 복제본만 사용하여 각 파일 시스템에 액세스합니다.

여러 복제본을 동시에 사용할 준비가 된 클라이언트는 원하는 대로 복제본 간에 열기를 나눌 수 있습니다. 해당 선택이 이루어지면 이후의 모든 전환은 각 복제본과 연관된 잠금 상태 세트를 단일 엔터티로 처리합니다.

예를 들어, 복제본 중 하나를 사용할 수 없게 되면 액세스가 다른 복제본으로 이전되며, 이 복제본은 아직 사용 중인 복제본과 동시에 액세스할 수도 있습니다.

해당 복제본이 없으면 이미 사용 중인 복제본으로 전환될 수 있습니다. 이 시점에서 클라이언트는 사용 중인 유일한 복제본의 보호 하에 두 복제본의 잠금 상태를 병합하거나 동시 액세스가 가능한 다른 복제본이 나타날 때까지 별도로 처리하는 것 중에서 선택할 수 있습니다.

---
#### **11.11.2.  Filehandles and File System Transitions**

파일 시스템 전환 전반에 걸쳐 파일 핸들을 처리할 수 있는 방법에는 여러 가지가 있습니다. 이는 전환이 발생하는 두 파일 시스템이 일종의 파일 시스템 처리 연속성에 영향을 미칠 만큼 충분한 상태를 공유하는지 여부에 따라 두 가지 광범위한 클래스로 나눌 수 있습니다.

파일 핸들 할당에 이러한 협력이 없으면 두 파일 시스템이 서로 다른 핸들 클래스에 있는 것으로 보고됩니다. 이 경우 모든 파일 핸들은 파일 시스템 전환의 일부로 만료되는 것으로 가정됩니다. 이 동작은 fh\_expire\_type 속성에 의존하지 않으며 fs\_locations\_info를 사용할 수 없는 경우에만 동작에 영향을 미치는 FH4\_VOL\_MIGRATION 비트의 사양을 대체합니다.

파일 핸들 할당에 협력이 있는 경우 두 파일 시스템이 동일한 핸들 클래스에 있는 것으로 보고됩니다. 이 경우 영구 파일 핸들은 파일 시스템 전환 후에도 유효한 상태로 유지되는 반면, 휘발성 파일 핸들\(FH4\_VOL\_MIGRATION 비트로 인해 휘발성인 파일 핸들 제외\)은 대상 서버에서 만료될 수 있습니다.

---
#### **11.11.3.  Fileids and File System Transitions**

NFSv4.0에서는 파일 시스템 전환 시 파일 ID 연속성 문제가 해결되지 않았습니다. 일반적인 기대는 두 개의 파일 시스템 인스턴스가 일종의 파일 시스템 이미지 복사본을 사용하여 단일 공급업체에 의해 생성되는 상황에서 파일 ID가 전환 전반에 걸쳐 일관될 것이지만 유사한 다중 공급업체 전환에서는 그렇지 않을 것이라는 것이었습니다. 이는 특히 서버가 채택한 전환 메커니즘에 대한 특별한 지식이 없는 클라이언트의 경우 어려움을 야기합니다. fileid가 필수 속성은 아니지만 많은 서버가 fileid를 지원하고 많은 클라이언트가 fileid에 의존하는 API를 제공한다는 점에 유의하세요.\(MUST\)

클라이언트 자체는 파일 시스템 전환 이벤트로 인해 파일 ID가 변경되는 데 아무런 문제가 없을 수 있지만 애플리케이션은 일반적으로 \(예: stat를 통해\) 파일 ID에 액세스할 수 있다는 점에 유의하는 것이 중요합니다. 결과적으로 파일 시스템 인스턴스 전환이 없거나 단일 벤더가 생성한 인스턴스 간에 그러한 전환이 있는 경우 애플리케이션이 완벽하게 작동할 수 있지만, 다중 벤더 전환이 발생하는 상황을 처리할 수 없습니다. 잘못된 시간.

다중 공급업체\(여러 서버 공급업체\) 환경에서 동일한 파일 ID를 제공하는 것은 일반적으로 상당히 어려운 것으로 간주되어 왔습니다. 해야 할 일이 있지만 이러한 어려움은 부분적으로 스스로 부과한 것임을 지적할 필요가 있습니다. 서버는 일반적으로 inode 번호, 즉 문제의 파일을 찾는 데 사용되는 수량으로 파일 ID를 식별합니다. 이러한 식별은 특정 파일에 동일한 인덱스를 할당하는 것이 불가능할 수 있는 공급업체 간의 파일 시스템 마이그레이션에 특별한 어려움을 초래합니다. 파일 ID는 문제의 파일을 찾는 데 유용할 필요는 없으며 단지 주어진 파일 시스템 내에서 고유해야 한다는 점에 유의하십시오. fileid를 단일 메타데이터로 받아들이고 파일 정보를 인덱싱하는 데 사용되는 값과 별도로 저장하도록 준비된 서버는 마이그레이션 이벤트 전반에 걸쳐 fileid 값을 상대적으로 쉽게 유지할 수 있으므로 진정으로 투명한 마이그레이션 이벤트가 가능합니다.

어떤 경우든 서버가 파일 ID의 연속성을 제공할 수 있어야 하며, 클라이언트는 그러한 연속성이 사용 가능한지 확인하고 적절한 조치를 취할 수 있어야 합니다. 파일 시스템 전환 전반에 걸쳐 파일 ID의 연속성\(또는 연속성 부족\)에 대한 정보는 해당 파일 시스템이 동일한 파일 ID 클래스인지 여부를 지정하여 표시됩니다.

전환 전체에서 일관된 파일 ID가 존재하지 않는 경우\(파일 ID의 연속성이 없거나 관련된 인스턴스 중 하나에서 fileid가 지원되는 속성이 아니기 때문에\) 전환 이벤트 전체에서 신뢰할 수 있는 파일 핸들이 없는 경우\( 파일 핸들 연속성이 없거나 파일 핸들이 휘발성이기 때문에\) 클라이언트는 전환 전에 액세스했던 파일이 동일한 개체인지 확인할 수 없는 위치에 있습니다. 이름이 변경된 개체가 없다고 가정해야 하며 이를 제공한다는 보장이 없으면\(예: 파일 시스템이 읽기 전용임\) 애플리케이션에 문제가 발생할 수 있습니다. 따라서 이러한 구성의 사용은 이로 인해 발생할 수 있는 문제가 허용될 수 있는 상황으로 제한되어야 합니다.

---
#### **11.11.4.  Fsids and File System Transitions**

fsid는 일반적으로 서버별로 고유하므로 파일 시스템 전환 중에 변경될 가능성이 높습니다. 클라이언트는 서버에서 받은 fsid를 응용 프로그램에 표시해서는 안 됩니다. fsid는 전역적으로 고유하지 않을 수 있고 파일 시스템 전환 이벤트 중에 변경될 수 있기 때문입니다. 애플리케이션은 가능한 한 그러한 전환으로부터 격리되는 경우 가장 잘 제공됩니다.

일반적으로 단일 소스 파일 시스템이 단일 대상 파일 시스템으로 전환되지만 FSLI4F\_MULTI\_FS 플래그를 지정하여 단일 소스 파일 시스템을 여러 대상 파일 시스템으로 분할할 수 있는 규정이 있습니다.

---
##### **11.11.4.1.  File System Splitting**

파일 시스템 전환이 이루어지고 fs\_locations\_info가 문제의 파일 시스템이 여러 파일 시스템으로 분할될 수 있음을 나타낼 때\(FSLI4F\_MULTI\_FS 플래그를 통해\) 클라이언트는 GETATTR을 수행하여 전환이 진행 중인 파일 시스템 내의 알려진 모든 객체에 대한 fsid 속성을 결정해야 합니다. 새로운 파일 시스템 경계를 결정하기 위해 전환합니다.\(SHOULD\)

클라이언트는 하위 파일 시스템의 모든 fsid를 원래 파일 시스템에 사용된 공통 fsid에 매핑하여 기존 응용 프로그램에 전달된 fsid를 유지하도록 선택할 수 있습니다.

파일 시스템 분할은 동일한 파일 ID 클래스의 파일 시스템 간 전환 시 수행될 수 있습니다. 파일 ID가 소스 파일 시스템 내에서 고유하다는 사실이 각 대상 파일 시스템에서도 고유함을 보장하기 때문입니다.

---
#### **11.11.5.  The Change Attribute and File System Transitions**

변경 속성은 서버별 속성으로 정의되므로 한 서버에서 가져온 변경 속성은 일반적으로 다른 서버에서는 유효하지 않은 것으로 간주됩니다. 이러한 가정은 캐시된 모든 변경 속성을 무효화하고 다시 가져와야 하므로 문제가 됩니다. 더욱 혼란스러운 점은 변경 속성에 대한 연속성이 보장되지 않는다는 점입니다. 이는 다시 가져올 때 동일한 값이 검색되더라도 문제의 개체가 변경되었는지 여부에 대한 결론을 도출할 수 없다는 의미입니다. 동일한 변경 속성은 단지 다른 변경 속성 구성 알고리즘을 사용하여 수정된 파일의 아티팩트일 수 있으며, 해당 새 알고리즘은 동일한 변경 값을 생성합니다.

두 파일 시스템이 일관된 변경 속성 형식을 갖고 이 사실이 동일한 변경 클래스를 보고하여 클라이언트에 전달되는 경우 클라이언트는 변경 속성 구성의 연속성을 가정하고 파일 없이 처리되는 것처럼 이 상황을 처리할 수 있습니다. 시스템 전환.

---
#### **11.11.6.  Write Verifiers and File System Transitions**

파일 시스템 전환 시 두 파일 시스템이 불안정하게 기록된 데이터를 처리하는 데 협력할 수 있습니다. 클라이언트는 두 파일 시스템이 동일한 쓰기 검증자 클래스에 속하는지 확인하여 이러한 경우인지 확인할 수 있습니다. 이 경우 한 시스템에서 반환된 쓰기 검증 프로그램을 다른 시스템에서 반환한 것과 비교할 수 있으며 불필요한 쓰기를 방지할 수 있습니다.

두 파일 시스템이 서로 다른 쓰기 검증자 클래스에 속할 경우, 한 쪽에서 생성된 검증자는 다른 쪽에서 제공한 검증자와 비교하면 안 됩니다. 대신, 값이 동일하더라도 두 검증자는 동일하지 않은 것으로 처리되어야 합니다.

---
#### **11.11.7.  READDIR Cookies and Verifiers and File System Transitions**

파일 시스템 전환에서 두 파일 시스템은 READDIR 쿠키 및 검증자를 처리하는 데 일관성이 있을 수 있습니다. 클라이언트는 두 파일 시스템이 동일한 readdir 클래스에 속하는지 확인하여 이러한 경우인지 확인할 수 있습니다. 이 경우 한 시스템의 readdir 클래스, READDIR 쿠키 및 검증자는 다른 시스템에서 인식되며, 한 서버에서 시작된 READDIR 작업은 READDIR 작업에서 반환된 쿠키 및 검증자를 제시하기만 하면 다른 서버에서 유효하게 계속될 수 있습니다. 첫 번째 파일 시스템에서 두 번째 파일 시스템까지 완료되었습니다.

두 파일 시스템이 서로 다른 readdir 클래스에 속하면 하나에서 생성된 READDIR 쿠키와 검증자는 두 번째 파일 시스템에서는 유효하지 않으며 클라이언트가 해당 서버에 제공해서는 안 됩니다. 클라이언트는 검증자가 거부된 것처럼 행동해야 합니다.

---
#### **11.11.8.  File System Data and File System Transitions**

여러 복제본이 존재하고 클라이언트가 동시에 또는 연속해서 사용하는 경우 이를 사용하는 애플리케이션은 일반적으로 해당 복제본에 동일한 데이터 또는 다른 클라이언트의 데이터를 업데이트하는 일반적인 변경 사항과 일치하는 데이터가 포함되어 있다고 예상합니다. 파일 시스템\(fs\_locations\_info 속성에 표시된 정도와 동일한 메타데이터 포함\) 그러나 여러 파일 시스템이 서로의 복제본으로 표시되는 경우 일반적으로 NFSv4.1 프로토콜에서 한 데이터와 다른 데이터 간의 정확한 관계가 지정되지 않습니다. 일부 애플리케이션이 복제본 간의 전환을 처리하는 데 문제가 있을 정도로 파일 시스템의 데이터가 충분히 다른 경우 복제본 파일 시스템을 제공하는 것이 가능합니다. 네임스페이스는 일반적으로 애플리케이션이 적절한 지원 수준을 선택할 수 있도록 구성됩니다. 따라서 네임스페이스의 한 위치에는 다양한 복제본 세트가 나열될 수 있고 다른 위치에는 최신 복제본 세트만 나열될 수 있습니다. 복제품으로 간주됩니다. 프로토콜은 서버가 지정하고 클라이언트가 의존하는 복제본 간의 관계에 대한 세 가지 특별한 경우를 정의합니다.

\* 여러 개의 복제본이 존재하고 클라이언트에서 동시에 사용되는 경우\(fs\_locations\_info 내의 FSLIB4\_CLSIMUL 정의 참조\) 동일한 데이터를 지정해야 합니다. 파일 시스템이 쓰기 가능한 경우, 한 인스턴스에 대한 변경 사항은 조사된 인스턴스가 수정이 수행된 인스턴스인지 여부에 관계없이 모든 인스턴스에서 동시에 표시되어야 합니다. 이를 통해 클라이언트는 하나의 복제본에서 얻은 잠금이 별도로\(즉, 다른 클라이언트 ID로\) 유지된다는 사실을 적용하는 것 외에 여러 개의 복제본이 있다는 사실에 대한 특별한 조정 없이 이러한 복제본을 동시에 사용할 수 있습니다. 이 경우 하나의 복제본에서 얻은 잠금\(공유 예약 또는 바이트 범위 잠금\) 및 위임은 사용된 복제본에 관계없이 다른 모든 서버의 액세스가 금지된다는 의미에서 모든 복제본에 즉시 반영됩니다. 그러나 서버는 두 개의 연결된 클라이언트 ID를 동일한 클라이언트를 나타내는 것으로 처리할 필요가 없으므로 단일 클라이언트 ID만 사용하여 각 파일에 액세스하는 것이 가장 좋습니다.

\* NFS4ERR\_MOVED 반환 후 하나의 복제본이 다른 기존 인스턴스의 후속 인스턴스로 지정되는 경우\(즉, 마이그레이션의 경우\) 클라이언트는 원본 인스턴스의 stable 스토리지에 기록된 모든 변경 사항이 stable에 기록된다는 사실에 의존할 수 있습니다. 후속 항목의 저장\(커밋되지 않은 쓰기는 위의 섹션 11.11.6에서 처리됩니다\)

\* 파일 시스템이 쓰기 가능하지 않지만 쓰기 가능한 파일 시스템의 읽기 전용 복사본\(주기적으로 업데이트될 수 있음\)을 나타내는 경우 클라이언트는 업데이트 전파와 관련하여 유사한 요구 사항을 갖습니다. 클라이언트가 복제본으로의 전환에 영향을 미칠 가능성을 피하기 위해 클라이언트가 해당 복제본에 대한 액세스를 전환하기 전에 원본 파일 시스템 인스턴스에 표시되는 모든 변경 사항이 모든 복제본에 즉시 표시되어야 한다는 보장이 필요할 수 있습니다. 파일 시스템 상태의 복귀를 확인하세요. 이 보장의 구체적인 수단은 fs\_status 속성의 일부로 보고되는 fss\_type 필드의 값에 따라 다릅니다\(섹션 11.18 참조\). 이러한 파일 시스템은 동시 사용에 적합하지 않은 것으로 간주되므로 잠금 처리 방법에 대한 사양이 없습니다. 일반적으로 한 파일 시스템에서 얻은 잠금은 다른 파일 시스템의 잠금과 별개입니다. 이는 읽기 전용 파일 시스템으로 예상되므로 클라이언트나 애플리케이션에 문제를 일으킬 가능성은 없습니다.

이러한 특별한 상황이 적용되지 않는 경우 클라이언트가 복제본 파일 시스템의 내용이나 이전 파일 시스템 인스턴스와의 관계에 대해 가정할 수 있는 기반이 프로토콜 내에 없습니다. 따라서 클라이언트가 fs\_locations\_info 속성을 사용하지 않거나 서버가 이를 지원하지 않기 때문에 명목상 동일한 읽기-쓰기 파일 시스템 간 전환은 불가능합니다.

---
#### **11.11.9.  Lock State and File System Transitions**

파일 시스템에 액세스하는 동안 클라이언트는 서버에서 시행하는 잠금을 얻습니다. 이는 해당 잠금과 일치하지 않는 다른 클라이언트의 작업을 방지할 수 있습니다.

복제본 간에 액세스가 전송될 때 클라이언트는 이러한 잠금을 보유하여 허용되지 않는 작업이 전환 중에 발생할 수 없다는 것을 확신해야 합니다. 이는 아래 방법으로 보장할 수 있습니다. 다음 중 하나 이상이 구현되지 않으면 클라이언트는 마이그레이션 이벤트 전반에 걸쳐 잠금 소유의 연속성을 보장할 수 없습니다.

\* 대상 서버에서 fs별 유예 기간을 통해 클라이언트에게 잠금을 다시 얻을 수 있는 기회를 제공하고, 대상 파일 시스템을 사용하는 모든 클라이언트가 이전된 클라이언트가 보유한 잠금과 충돌하는 새 잠금을 얻을 수 있는 기회를 거부합니다. 해당 클라이언트는 fs별 유예 기간을 완료하지 않았습니다. 잠금 회수 메커니즘은 원래 서버 재부팅을 지원하도록 정의되었기 때문에 파일 핸들이 회수 시 열릴 때와 동일할 것이라고 암시적으로 가정합니다. 마이그레이션의 경우 동일한 서버 범위\(섹션 2.10.4 참조\)를 사용하거나 fs\_locations\_info\(위 섹션 11.11.2 참조\)를 사용하여 이 계약을 표시함으로써 입증된 것처럼 소스 및 대상 서버가 동일한 파일 핸들을 사용해야 합니다.

이러한 유예 기간은 별도의 조치 없이 시행될 수 있습니다.

- 진행 중인 새 잠금을 획득하기 위해 전송되지 않은 클라이언트의 기능을 방해합니다. 대상 서버가 전송된 잠금을 인식하는 한 기존 잠금과 대조되는 새 잠금을 얻기 위한 요청과 그렇지 않은 요청을 구별할 수 있으므로 진행 중인 유예 기간을 참조하지 않고 해당 클라이언트 요청을 처리할 수 있습니다.

\* 섹션 11.12에 설명된 대로 투명 상태 마이그레이션을 제공하여 잠금 상태를 전환의 일부로 전송할 수 있습니다.

이 중에서 Transparent State Migration은 새 잠금을 얻기 전에 회수 프로세스를 거칠 필요가 없다는 점에서 클라이언트에게 더 원활한 환경을 제공합니다. 그러나 더 높은 수준의 서버 간 조정이 필요합니다. 일반적으로 마이그레이션에 참여하는 서버는 두 가지 기능 중 하나를 자유롭게 제공합니다. 그러나 파일 핸들이 마이그레이션 이벤트에 따라 다를 수 있는 경우 투명 상태 마이그레이션은 필요한 기능을 제공하는 유일한 수단입니다.

이 두 가지 방법은 상호 배타적이지 않으며 서버가 두 가지 방법을 모두 제공할 수도 있다는 점에 유의해야 합니다. 특히 특정 잠금이 투명하게 전송되는 것을 방해하는 상황이 있는 경우 대상 서버는 마이그레이션된 파일 시스템에 대해 fs별 유예 기간을 구현하여 잠금을 회수하도록 허용할 수 있습니다.

11.11.9.1. 파일 시스템 전환 후 잠금 상태 회수와 관련된 보안 고려 사항

상태를 재생하는 클라이언트가 섹션 8.4.2.1.1에 설명된 것과 동일한 방식으로 상태를 잘못 표시할 수 있지만 파일 시스템 전환의 경우 이러한 재생을 제공하는 대부분의 구현에는 이러한 잘못된 표시를 감지할 수 있는 기능이 있습니다. 이는 인증되지 않은 클라이언트가 이러한 상황에서 서비스 거부 공격을 실행하는 능력을 제한합니다. 그럼에도 불구하고, 회수 요청에 대한 본인 확인과 관련하여 섹션 8.4.2.1.1에 명시된 규칙은 이 상황에도 적용됩니다.

일반적으로 파일 시스템 전환을 지원하는 구현에는 전송될 잠금에 대한 광범위한 정보가 있습니다. 그 이유는 다음과 같습니다.

\* 장애가 발생하지 않으므로 영구 저장소에 잠금 정보를 저장할 필요가 없습니다.

\* 실패 사례의 경우처럼 동기화를 유지하기 위해 잠금 상태가 포함된 여러 저장소를 업데이트할 필요가 없습니다. 대신 원본에서 대상 서버로 잠금 상태에 대한 일회성 통신이 이루어집니다.

\* 이 정보를 제공하면 대상 파일 시스템을 사용하는 기존 클라이언트가 유예 기간 동안 새 잠금을 얻을 수 있는 능력을 거부함으로써 잠재적인 간섭을 방지할 수 있습니다.

연관된 상태 ID를 반드시 포함할 필요는 없는 상세한 잠금 정보를 사용할 수 있는 경우:

\* 전송 전에 존재하지 않았던 잠금을 회수하려는 회수 요청을 감지하고 NFS4ERR\_RECLAIM\_BAD\(15.1.9.4절\)를 사용하여 거부할 수 있습니다.

\* 비회수 요청을 처리하는 경우에는 가능합니다.

- 기존 잠금과 충돌하는지 확인하여 비재확보 요청에 대해 NFS4ERR\_GRACE\(섹션 15.1.9.2\)를 반환할 필요가 없도록 합니다.

파일 시스템 전환과 관련된 유예 기간 구현이 대상 서버에서 사용 가능한 자세한 잠금 정보를 갖지 않는 것이 가능하며, 이 경우 보안 상황은 섹션 8.4.2.1.1에 설명된 것과 정확히 같습니다.

---
##### **11.11.9.2.  Leases and File System Transitions**

임대 갱신의 경우 클라이언트는 다른 서버로 전송된 파일 시스템에 대한 요청을 제출하지 않을 수 있습니다. 이는 임대 갱신 메커니즘으로 인해 발생할 수 있습니다. 클라이언트는 참조되는 특정 파일 시스템에 관계없이 연관된 세션에 대한 요청을 제출할 때 모든 파일 시스템과 연관된 임대를 갱신합니다.

클라이언트가 새 서버로 재배치되었을 수 있는 잠금 상태가 있는 임대 갱신을 예약하려면 클라이언트는 해당 임대가 만료되기 전에 임대 재배치에 대해 알아내야 합니다. 이를 달성하기 위해 갱신된 잠금 상태에 대한 책임이 새 서버로 이전된 경우 SEQUENCE 작업은 상태 비트 SEQ4\_STATUS\_LEASE\_MOVED를 반환합니다. 이는 클라이언트가 잠금 상태 재배치가 있었던 각 파일 시스템에 대해 NFS4ERR\_MOVED 오류를 수신할 때까지 계속됩니다.

클라이언트는 서버로부터 SEQ4\_STATUS\_LEASE\_MOVED 지시를 받으면 클라이언트가 잠금 상태에 있는 서버의 각 파일 시스템에 대해 작업을 수행해야 합니다. 단순화를 위해 클라이언트는 모든 파일 시스템을 참조하도록 선택할 수 있지만 중요한 것은 해당 상태가 이동된 잠금 상태가 있었던 모든 파일 시스템을 참조해야 한다는 것입니다. 클라이언트가 각 파일 시스템에 대해 NFS4ERR\_MOVED 오류를 수신하면 서버는 SEQ4\_STATUS\_LEASE\_MOVED 표시를 지웁니다. 클라이언트는 이 표시가 지워지면 파일 시스템 검사 프로세스를 종료할 수 있습니다\(단, 클라이언트가 서버와의 모든 세션에서 처리되지 않은 모든 SEQUENCE 요청에 대한 응답을 받은 경우에만 해당\). 잠금 상태에 있는 다른 요청이 없기 때문입니다. 움직이는.

클라이언트는 모든 파일 시스템에서 fs\_status\(또는 fs\_locations\_info\) 속성의 GETATTR을 사용하여 단일\(또는 몇 가지\) 요청에서 부재 표시를 얻을 수 있습니다. 파일 시스템이 없어도 이 컨텍스트에서 오류가 발생하지 않기 때문입니다. 그러나 SEQ4\_STATUS\_LEASE\_MOVED 표시를 지우려면 여전히 각 파일 시스템에서 NFS4ERR\_MOVED를 수신하는 작업을 수행해야 합니다.

전송된 잠금 상태가 있는 파일 시스템 세트가 결정되면 클라이언트는 일반 프로세스에 따라 새 서버 정보를 얻고\(fs\_locations 및 fs\_locations\_info 속성을 통해\) 새 서버에서 해당 임대 갱신을 수행할 수 있습니다. fs\_locations\_info 속성은 상태가 전송될 수 없음을 나타냅니다. 서버의 상태가 투명하게 전송되지 않은 경우 클라이언트는 위에서 설명한 대로 새 서버로부터 NFS4ERR\_STALE\_CLIENTID를 받게 되며, 그런 다음 클라이언트는 서버 오류 발생 시 수행되는 잠금을 회수할 수 있습니다.

---
##### **11.11.9.3.  Transitions and the Lease_time Attribute**

파일 시스템 전환 시 클라이언트가 해당 임대를 적절하게 관리할 수 있도록 대상 서버는 Lease\_time 속성에 대한 적절한 값을 설정해야 합니다.

상태가 투명하게 전송되면 해당 상태에는 Lease\_time 속성의 올바른 값이 포함되어야 합니다. 대상 서버의 Lease\_time 속성은 원본의 임대 시간 속성보다 작아서는 안 됩니다. 이렇게 하면 원본 서버에서 부여한 임대가 조기에 만료될 수 있기 때문입니다. 상태가 투명하게 전송되는 전환 시 클라이언트는 rent\_time 속성을 다시 가져올 의무가 없으며 소스 서버에서 이전에 가져온 값을 계속 사용할 수 있습니다.

연결된 서버가 다른 eir\_server\_scope 문자열을 갖는 것으로 표시되거나 새 서버에 제공될 때 클라이언트 ID가 거부되어 상태가 투명하게 전송되지 않은 경우 클라이언트는 새 서버\(예: 대상\)에서 Lease\_time 값을 가져와야 합니다. 서버에 저장하고 후속 잠금 요청에 이를 사용합니다. 그러나 서버는 잠재적으로 충돌할 수 있는 비재확보 잠금이 부여되기 전에 클라이언트가 잠금을 재확보할 수 있는 충분한 시간을 갖도록 하기 위해 최소한 소스 서버의 rent\_time만큼 긴 유예 기간을 준수해야 합니다.

---
### **11.12.  Transferring State upon Migration**

전환이 액세스 전환에 대한 서버 시작 결정의 결과이고 원본 서버와 대상 서버가 적절한 협력을 구현한 경우 다음을 수행할 수 있습니다.

\* \[69\]에 설명된 대로 NFSv4.0의 Transparent State Migration에서 제공하는 것과 유사한 방식으로 소스에서 대상 서버로 잠금 상태를 전송합니다. 서버 책임은 섹션 11.14.2에 설명되어 있습니다.

\* 소스 서버에서 대상 서버로 세션 상태를 전송합니다. 그러한 전송을 수행하는 데 있어 서버의 책임은 섹션 11.14.3에 설명되어 있습니다.

클라이언트가 이러한 전송 이벤트 중 어떤 것이 발생했는지 결정하는 방법은 섹션 11.13에 설명되어 있습니다.

---
#### **11.12.1.  Transparent State Migration and pNFS**

pNFS가 관련되면 프로토콜은 다음을 지원할 수 있습니다.

\* 데이터 서버\(DS\)는 그대로 두고 메타데이터 서버\(MDS\)를 마이그레이션합니다.

\* MDS 및 관련 DS를 포함하여 파일 시스템 전체를 마이그레이션합니다.

\* 하나의 DS를 다른 DS로 교체합니다.

\* pNFS 파일 시스템을 pNFS가 사용되지 않는 시스템으로 마이그레이션합니다.

\* pNFS를 사용하지 않는 파일 시스템을 레이아웃이 가능한 파일 시스템으로 마이그레이션합니다.

마이그레이션 자체는 MDS 기능의 전송에만 관련된다는 점에 유의하십시오. 레이아웃 서비스가 한 데이터 서버에서 다른 데이터 서버로 전송될 수 있지만 이는 파일 시스템 위치 속성을 사용하여 수행되지 않습니다. MDS는 기존 레이아웃을 불러오거나 취소하고 다른 데이터 서버에 새 레이아웃을 부여하여 이러한 전송을 수행할 수 있습니다.

MDS 기능의 마이그레이션은 Transparent State Migration을 통해 직접 지원됩니다. 레이아웃 상태는 일반적으로 다른 상태와 마찬가지로 투명하게 전송됩니다. 결과적으로 투명한 상태 마이그레이션은 적절한 MDS 간 데이터 전송이 제공되면 하나의 MDS를 다른 MDS로 대체할 수 있는 프레임워크를 제공합니다.

파일 시스템 기능 전체의 마이그레이션은 마이그레이션 프로세스의 초기 단계의 일부로 모든 레이아웃을 호출하여 수행할 수 있습니다. 결과적으로 I/O는 마이그레이션 프로세스 중에 MDS를 통해 수행되며 클라이언트가 새 MDS와 상호 작용하면 새 레이아웃이 부여될 수 있습니다. MDS는 클라이언트에게 잠금 상태 손실에 대한 알림을 제공하는 한 투명 상태 마이그레이션의 일부로 모든 레이아웃을 취소하여 이러한 종류의 전환에 영향을 미칠 수도 있습니다.

pNFS가 지원되지 않는 파일 시스템으로의 마이그레이션을 허용하려면 클라이언트는 대상 파일 시스템에서 레이아웃을 사용할 수 없거나 지원되지 않는 상황에 대비해야 하므로 I/O 요청을 대상 서버로 직접 보내야 합니다. 사용 가능한 레이아웃에 따라 다릅니다.

하나의 DS를 다른 DS로 교체하는 것은 마이그레이션으로 처리되지 않지만 MDS가 교체할 DS의 레이아웃을 호출하고 후속 DS에서 제공할 새 레이아웃을 발행함으로써 영향을 받을 수 있습니다.

마이그레이션을 통해 pNFS를 지원하지 않는 서버의 파일 시스템을 지원하는 서버로 전송할 수 있습니다. 이러한 상황에 적절히 적응하려면 pNFS를 지원하지만 pNFS가 없을 때 적절하게 작동하는 클라이언트는 파일 시스템이 마이그레이션될 때 pNFS 지원을 확인하고 대상에서 지원이 가능할 때 pNFS를 사용할 준비를 해야 합니다.

---
### **11.13.  Client Responsibilities When Access Is Transitioned**

클라이언트가 액세스 전환에 응답하려면 이를 인식해야 합니다. 이러한 일이 발생할 수 있는 방식은 섹션 11.13.1에서 논의됩니다. 여기서는 특정 파일 시스템 액세스 경로가 전환되었다는 표시와 마이그레이션된 파일 시스템 세트를 결정하기 위해 추가 활동이 필요한 상황을 논의합니다. 섹션 11.13.2에서는 마이그레이션된 파일 시스템 세트를 결정하는 방법에 대한 논의를 완료합니다. 섹션 11.13.3부터 11.13.5까지는 클라이언트가 직접적으로 또는 마이그레이션 검색의 결과로 인식하게 된 각 전환을 어떻게 처리해야 하는지 논의합니다.

다음 용어는 클라이언트 활동을 설명하는 데 사용됩니다.

\* "전환 복구"는 NFS4ERR\_MOVED를 수신한 파일 시스템에 대한 액세스를 복원하는 프로세스를 의미합니다.

\* "마이그레이션 복구"는 파일 시스템이 다른 복제본으로 마이그레이션되었을 때 적용되는 전환 복구의 하위 집합을 나타냅니다.

\* "마이그레이션 검색"은 어떤 파일 시스템이 마이그레이션되었는지 확인하는 프로세스를 의미합니다. 마이그레이션을 인식하지 못하는 클라이언트가 마이그레이션되지 않은 파일 시스템을 참조하고 마이그레이션된 파일과 관련된 임대를 갱신하지 않을 수 있으므로 장기간 파일 시스템에 액세스하지 않을 때 임대가 만료될 수 있는 상황을 피해야 합니다. 체계.

---
#### **11.13.1.  Client Transition Notifications**

클라이언트가 파일 시스템에 액세스하는 데 사용할 네트워크 액세스 경로에 변경이 있는 경우 클라이언트가 처리해야 하는 여러 가지 관련 상태 표시가 있습니다.

\* 이전에 액세스하는 데 사용된 주소에서 더 이상 액세스할 수 없는 파일 시스템 내에서 파일 핸들을 사용하거나 반환하려고 하면 NFS4ERR\_MOVED 오류가 반환됩니다.

- 파일 시스템 위치 속성을 조사할 때 이러한 파일 핸들을 사용하도록 허용하는 예외가 있습니다. 이를 통해 클라이언트는 새 복제본의 위치나 새 네트워크 액세스 경로를 결정할 수 있습니다.

- 이 상태는 문제의 파일 시스템에 대한 후속 시도에서 계속됩니다. 클라이언트가 오류를 피할 수 있는 유일한 방법은 이전 서버 위치에서 문제의 파일 시스템에 대한 액세스를 중단하고 대신 현재 사용할 수 있는 다른 주소를 사용하여 액세스하는 것입니다.

\* 클라이언트가 해당 클라이언트에 유지되고 해당 서버에서 더 이상 액세스할 수 없는 파일 시스템과 연결된 상태를 생성한 서버에 SEQUENCE 작업을 보낼 때마다 응답에는 임대 마이그레이션이 있음을 나타내는 상태 비트 SEQ4\_STATUS\_LEASE\_MOVED가 포함됩니다.

- 이 조건은 클라이언트가 네트워크 액세스 경로가 변경되는 파일 시스템에 대한 파일 시스템 위치 속성을 가져와 알림을 확인할 때까지 계속됩니다. 이러한 파일 시스템이 여러 개 있는 경우 각 파일 시스템에 대한 위치 속성을 가져와야 합니다. 조건을 지우려면 마이그레이션된 모든 파일 시스템의 위치 속성을 가져와야 합니다. 조건이 해결된 후에도 클라이언트는 임대가 불필요하게 만료되지 않도록 위치 정보를 사용하여 새 위치의 파일 시스템에 액세스함으로써 응답해야 합니다.

해당 조건이 모두 오류이므로 상호 배타적인 NFSv4.0과 달리 NFSv4.1에서는 클라이언트가 동일한 요청에 대해 두 가지 표시를 모두 받을 수 있으며 종종 받게 됩니다. 결과적으로 구현에서는 동일한 요청에 대한 응답으로 두 가지 표시가 모두 도착할 때 필요한 복구 작업을 조정하는 방법에 대한 문제를 해결해야 합니다. NFSv4 COMPOUND를 처리할 때 서버는 일반적으로 어떤 파일 시스템이 참조될지 또는 NFS4ERR\_MOVED가 반환될지 여부를 결정하기 전에 SEQ4\_STATUS\_LEASE\_MOVED를 설정할지 여부를 결정합니다.

이러한 표시는 NFSv4.1에서 상호 배타적이지 않으므로 COMPOUND가 실행될 때 다음 조합이 가능한 결과입니다.

\* COMPOUND 상태는 NFS4ERR\_MOVED이고, SEQ4\_STATUS\_LEASE\_MOVED가 주장됩니다.

- 이 경우 전환 복구가 필요합니다. 추가로 마이그레이션 검색이 필요할 수도 있지만 액세스된 파일 시스템만 전환되었을 가능성이 높습니다. 어떤 경우든 거부된 요청이 대상에서 처리되도록 하려면 NFS4ERR\_MOVED를 처리해야 하므로 일반적으로 이를 처리하는 것이 마이그레이션 검색보다 우선합니다.

\* COMPOUND 상태는 NFS4ERR\_MOVED, SEQ4\_STATUS\_LEASE\_MOVED는 클리어입니다.

- 이 경우 전환 복구도 필요합니다. NFS4ERR\_MOVED를 반환하는 파일 시스템이 아닌 마이그레이션된 파일 시스템을 찾는 데 마이그레이션 검색이 필요하지 않다는 것은 분명합니다. 이 결과가 발생할 수 있는 경우에는 관련 잠금 상태가 없는 참조 또는 마이그레이션이 포함됩니다. 이는 마이그레이션 이외의 액세스 경로 전환이 동일한 서버 내에서 발생하는 경우에도 발생할 수 있습니다. 이러한 경우 액세스 경로가 변경되더라도 임대는 현재 서버와 연결되어 있으므로 SEQ4\_STATUS\_LEASE\_MOVED를 설정할 필요가 없습니다.

\* COMPOUND 상태가 NFS4ERR\_MOVED가 아니고,

- SEQ4\_STATUS\_LEASE\_MOVED가 주장되었습니다.

- 이 경우 요청에 의해 액세스되는 파일 시스템에 대한 전환 복구 활동이 필요하지 않습니다. 그러나 피할 수 있는 임대 만료를 방지하려면 마이그레이션 검색을 수행해야 합니다.

\* COMPOUND 상태가 NFS4ERR\_MOVED가 아니고,

- SEQ4\_STATUS\_LEASE\_MOVED가 지워졌습니다.

- 이 경우 전환 관련 활동이나 마이그레이션 검색이 필요하지 않습니다.

지정된 작업은 아직 진행되지 않은 경우에만 수행하면 됩니다. 예를 들어, 전환 복구가 이미 진행 중인 파일 시스템에 액세스하는 동안 NFS4ERR\_MOVED가 수신되면 클라이언트는 해당 복구가 완료될 때까지 기다리기만 하는 반면, SEQ4\_STATUS\_LEASE\_MOVED 표시 수신은 그러한 발견이 있는 경우 서버에 대한 마이그레이션 검색을 시작하기만 하면 됩니다. 해당 서버에서는 아직 진행 중이 아닙니다.

NFSv4.1에서 임대 마이그레이션 조건으로 인해 오류가 발생하지 않는다는 사실은 여러 가지 중요한 결과를 가져옵니다. 위에서 설명한 것처럼 두 가지 표시가 상호 배타적이지 않다는 사실 외에도 섹션 11.13.2에서 설명한 것처럼 마이그레이션 검색 구현을 고려할 때 중요한 문제가 많이 있습니다.

SEQ4\_STATUS\_LEASE\_MOVED는 오류 조건이 아니기 때문에 동일한 서버의 다른 파일 시스템에 대한 복구가 필요하더라도 액세스 경로가 변경되지 않은 파일 시스템에 대해 해당 서버에서 성공적으로 액세스할 수 있습니다. 결과적으로 다음과 같은 동안 액세스가 발생할 수 있습니다.

\* 해당 서버에 대한 마이그레이션 검색 프로세스가 진행 중입니다.

\* 해당 서버에 연결된 다른 파일 시스템에 대해 전환 복구 프로세스가 진행 중입니다.

---
#### **11.13.2.  Performing Migration Discovery**

마이그레이션 검색은 전환 복구와 동일한 컨텍스트에서 수행될 수 있으므로 마이그레이션된 각 파일 시스템이 검색될 때 복구가 호출될 수 있습니다. 또는 별도의 마이그레이션 검색 스레드에서 수행하여 하나 이상의 전환 복구 인스턴스와 병렬로 마이그레이션 검색을 수행할 수 있습니다.

두 경우 모두 임대 마이그레이션 표시로 인해 오류가 발생하지 않기 때문에 서버의 파일 시스템에 대한 다른 액세스가 정상적으로 진행될 수 있으며 이러한 표시가 추가로 수신될 가능성이 있으므로 이러한 표시가 어떻게 될지에 대한 문제가 제기됩니다. 다루었다. 일반적으로:

\* 마이그레이션 검색을 수행하는 스레드에서 수신한 이러한 표시에 대해 조치를 취할 필요가 없습니다. 해당 작업을 계속하면 문제가 해결될 것이기 때문입니다.

\* 현재 마이그레이션 검색이 수행되고 있는 다른 경우에는 마이그레이션 검색 프로세스가 해당 표시를 처리할 것이라고 확신할 수 있는 한 그러한 임대 마이그레이션 표시에 응답하기 위해 더 이상 수행할 필요가 없습니다. 자세한 내용은 아래를 참조하세요.

\* 다른 모든 상황에서 수신된 그러한 표시의 경우,

- 적절한 응답은 표시를 반환하는 서버 IP 주소와 연관된 파일 시스템에 대한 마이그레이션 검색 실행을 시작하거나 제공하는 것입니다.

이는 마이그레이션 검색 프로세스가 거의 완료되었지만 여전히 작동 중인 상황에서 잠재적인 어려움을 남깁니다. 마이그레이션 검색 프로세스가 추가 지원 없이 추가 마이그레이션 파일 시스템 검색에 응답할 수 없는 경우 SEQ4\_STATUS\_LEASE\_MOVED 표시를 무시해서는 안 됩니다. 이러한 상황을 해결하는 데 있어 더 복잡한 점은 임대 마이그레이션 표시가 SEQUENCE 작업이 처리된 당시의 서버 상태를 반영할 수 있다는 것입니다. 이는 응답이 수신된 당시의 상태와 다를 수 있습니다. 새로운 마이그레이션 이벤트는 언제든지 발생할 수 있고 SEQ4\_STATUS\_LEASE\_MOVED 표시는 표시가 수신되기 전 상당한 시간 동안 실제 상황을 반영할 수 있으므로 SEQ4\_STATUS\_LEASE\_MOVED 표시가 부적절하게 무시되지 않도록 특별한 주의가 필요합니다.

이 문제에 대한 유용한 접근 방식은 각 서버에 대해 외부에서 볼 수 있는 별도의 마이그레이션 검색 상태를 사용하는 것입니다. 별도의 값은 서버의 마이그레이션 검색 프로세스에 대해 가능한 다양한 상태를 나타낼 수 있습니다.

\* 마이그레이션 검색이 진행되지 않는 비작업

- 수행.

\* 마이그레이션된 파일 시스템을 지속적으로 검사하는 일반 작업입니다.

\* 마이그레이션 검색 처리 완료/검증: 마이그레이션 검색 처리의 완료 가능성을 확인해야 합니다.

해당 프레임워크가 주어지면 마이그레이션 검색 처리는 다음과 같이 진행됩니다.

\* 정상 작동 상태에서 검색을 수행하는 스레드는 작업 중인 서버의 클라이언트에 알려진 연속적인 파일 시스템에 대해 파일 시스템 위치 속성과 fs\_status 속성을 가져옵니다.

\* fs\_status 속성이 파일 시스템이 마이그레이션된 시스템임을 나타내는 경우\(즉, fss\_absent가 true이고 fss\_type != STATUS4\_REFERRAL\) 마이그레이션된 파일 시스템이 발견된 것입니다. 이 상황에서는 파일 시스템 위치 속성을 가져오면서 임대 마이그레이션 표시에 기여하는 파일 시스템 중 하나가 지워졌을 가능성이 높습니다.

\* 그러한 경우 스레드는 임대 마이그레이션 표시가 지워졌는지 여부를 알 수 없으므로 완료/검증 상태로 진입하고 SEQ4\_STATUS\_LEASE\_MOVED 표시가 지워졌는지 확인하기 위해 COMPOUND를 발행합니다.

\* 검색 프로세스가 완료/검증 상태일 때 다른 요청이 임대 마이그레이션 표시를 받으면 이를 수신했음을 알립니다. 나중에 아래 설명된 대로 요청이 완료되면 이러한 표시의 존재가 사용됩니다.

완료/검증 상태에서 사용된 요청이 완료되면:

\* 임대 마이그레이션 표시가 반환되면 검색은

- 정상적으로 계속됩니다. 프로세스가 진행되는 동안 새로운 마이그레이션이 발생할 수 있으므로 모든 파일 시스템을 탐색한 경우에도 마찬가지입니다.

\* 그렇지 않은 경우 해당 요청이 발생하는 동안 다른 요청에서 임대 마이그레이션 표시를 본 기록이 있는 경우 해당 기록을 삭제하고 확인 요청을 다시 시도합니다. 검색 프로세스는 완료/확인 상태로 유지됩니다.

\* 임대 이관 표시가 없는 경우 이관 검색 작업이 완료된 것으로 간주하여 비운영 상태가 됩니다. 이 상태가 되면 후속 임대 마이그레이션 표시가 새로운 마이그레이션 검색 프로세스를 트리거합니다.

일련의 긴 일련의 새로운 마이그레이션 이벤트로 인해 SEQ4\_STATUS\_LEASE\_MOVED 표시 지우기가 지속적으로 지연될 수 있으므로 위에 설명된 프로세스가 종료된다는 보장은 없습니다. 불필요한 임대 만료를 방지하려면 클라이언트가 전체 마이그레이션 세트를 사용할 수 있을 때 SEQ4\_STATUS\_LEASE\_MOVED 표시가 지워질 때까지 기다리는 대신 마이그레이션 검색을 사용하여 즉시 임대 갱신을 수행하는 것이 적절합니다.

위에서 설명한 대로 임대 검색을 제공해야 합니다. 이렇게 하면 클라이언트가 만료되기 전에 각 대상 서버에서 임대를 갱신할 수 있을 만큼 빨리 파일 시스템 마이그레이션을 검색할 수 있습니다. 임대를 갱신하지 않으면 잠금 상태가 손실될 수 있습니다. 이러한 손실의 결과는 무료 잠금 구현을 통해 개선될 수 있지만 서버는 그렇게 할 의무가 없으며 잠금 요청이 충돌하면 잠금이 예기치 않게 취소될 수 있습니다. 고객은 이러한 가능성을 인지하고 있어야 합니다.

---
#### **11.13.3.  Overview of Client Response to NFS4ERR_MOVED**

이 섹션에서는 NFS4ERR\_MOVED를 수신한 클라이언트가 새 서버나 서버 엔드포인트\(사용 가능한 경우\)를 사용하여 전환 복구를 수행할 수 있는 방법을 간략하게 설명합니다. 해당 프로세스의 일부로 다음을 결정합니다.

\* NFS4ERR\_MOVED가 마이그레이션이 발생했음을 나타내는지, 아니면 위 섹션 11.10에서 설명한 다른 종류의 파일 시스템 액세스 전환을 나타내는지 여부입니다.

\* 마이그레이션의 경우 Transparent State Migration이 발생했는지 여부.

\* Transparent State Migration 과정에서 손실된 상태가 있는지 여부.

\* 세션이 Transparent State Migration의 일부로 전송되었는지 여부.

이 프로세스의 첫 번째 단계에서 클라이언트는 파일 시스템에 계속 액세스하거나 대체하는 데 사용할 초기 네트워크 주소를 찾기 위해 파일 시스템 위치 항목을 검사합니다. 클라이언트가 검사하는 각 위치 항목에 대해 프로세스는 5단계로 구성됩니다.

1. 해당 위치 주소로 EXCHANGE\_ID를 수행합니다. 이 작업은 클라이언트 소유자\(client\_owner4 형식\)를 서버에 등록하고, 이후 통신에 사용할 클라이언트 ID를 획득하고, 해당 클라이언트 ID의 확인 상태를 획득하고, server\_owner4 및 범위를 결정하는 데 사용됩니다. 이전에 파일 시스템에 액세스하는 데 사용된 주소로 항목을 트렁크할 수 있는지 확인하는 목적\(즉, 동일한 파일 시스템에 대한 다른 네트워크 액세스 경로를 나타내고 잠금 상태를 공유할 수 있음\).

2. 이주 여부에 대한 초기 결정

- 발생했습니다. 초기 결정은 EXCHANGE\_ID 결과가 NFS4ERR\_MOVED를 수신하여 액세스가 종료되었을 때 파일 시스템에 액세스하는 데 사용된 현재 위치 요소가 서버 트렁크 가능함을 나타내는지 여부에 따라 결정됩니다. 그렇다면 마이그레이션이 발생하지 않은 것입니다. 이 경우 전환은 적어도 처음에는 새 네트워크 주소를 통해 동일한 서버의 동일한 파일 시스템에 대한 지속적인 액세스를 포함하는 것으로 처리됩니다.

3. 기존 세션 상태에 대한 액세스 권한을 얻거나 새 세션을 생성합니다. 이것이 수행되는 방법은 마이그레이션이 발생했는지 여부에 대한 초기 결정에 따라 다르며 마이그레이션의 경우 아래 섹션 11.13.4에 설명된 대로 수행될 수 있고 마이그레이션 없이 네트워크 주소 전송의 경우 아래 섹션 11.13.5에 설명된 대로 수행될 수 있습니다. .

4. 2단계에서 가정한 트렁킹 관계를 다음과 같이 검증한다.

- 섹션 2.10.5.1에서 논의됨. 이 단계에서는 일반적으로 초기 결정을 확인하지만, 검증을 통해 \(마이그레이션 없이\) 네트워크 주소 이동에 대한 초기 결정을 무효화하고 대신 마이그레이션이 발생했다고 판단할 수도 있습니다. 이미 설정된 세션을 계속 사용할 수 있으므로 위의 3단계를 다시 실행할 필요가 없습니다.

5. 기존 잠금 상태에 대한 액세스 권한을 얻거나 이를 다시 얻습니다. 이것이 수행되는 방법은 마이그레이션이 발생했는지 여부에 대한 최종 결정에 따라 다르며 마이그레이션의 경우 섹션 11.13.4에 설명된 대로 수행될 수 있고 마이그레이션 없이 네트워크 주소 전송의 경우 섹션 11.13.5에 설명된 대로 수행될 수 있습니다.

초기 주소가 결정되면 클라이언트는 단축된 프로세스를 적용하여 트렁크 가능한 추가 주소를 찾을 수 있습니다. 클라이언트는 클라이언트 ID 트렁킹을 지원하는지 여부에 따라 세션 트렁크 가능 주소나 서버 트렁크 가능 주소를 찾을 수 있습니다. 프로세스의 후반 단계에서는 아래에 지정된 약식 절차를 사용하여 추가 위치 항목을 검사합니다.

A: EXCHANGE\_ID 이전에 위치 항목의 fs 이름을 검사하여 현재 사용 중인 이름과 일치하지 않으면 해당 항목을 무시합니다. 그렇지 않으면 위의 1단계에서 지정한 대로 진행됩니다.

B: 네트워크 주소가 이전에 사용된 주소로 세션 트렁킹이 가능한 경우 BIND\_CONN\_TO\_SESSION을 사용하여 새 네트워크 주소를 사용하여 해당 세션에 액세스합니다. 그렇지 않거나 바인드 작업이 실패하면 CREATE\_SESSION이 수행됩니다.

C: 위의 4단계에서 언급한 검증 절차가 사용됩니다. 그러나 실패할 경우 해당 항목은 무시되고 다음 사용 가능한 항목이 사용됩니다.

---
#### **11.13.4.  Obtaining Access to Sessions and State after Migration**

마이그레이션이 발생한 경우 마이그레이션 복구에는 투명한 상태 마이그레이션이 발생했는지 확인하는 작업이 포함됩니다. 이 결정은 EXCHANGE\_ID에서 반환된 클라이언트 ID와 보고된 확인 상태를 기반으로 이루어집니다.

\* 클라이언트 ID가 이전에 클라이언트에 알려지지 않은 확인되지 않은 클라이언트 ID인 경우 Transparent State Migration이 발생하지 않은 것입니다.

\* 클라이언트 ID가 이전에 클라이언트에게 알려진 확인된 클라이언트 ID인 경우 전송된 모든 상태는 클라이언트를 나타내는 기존 클라이언트 ID와 대상 서버로 병합되었을 것입니다. 이 상태 병합의 경우 투명한 상태 마이그레이션이 발생했을 수도 있고 발생하지 않았을 수도 있으며, 발생 여부에 대한 결정은 세션이 설정되고 클라이언트가 상태 복구를 시작할 준비가 될 때까지 연기됩니다.

\* 클라이언트 ID가 이전에 클라이언트에게 알려지지 않은 확인된 클라이언트 ID인 경우 클라이언트는 클라이언트 ID가 Transparent State Migration의 일부로 전송되었다고 결론을 내릴 수 있습니다. 이 전송된 클라이언트 ID 사례에서는 일부 상태가 손실되었을 수 있지만 투명한 상태 마이그레이션이 발생했습니다.

클라이언트 ID를 얻은 후에는 새 서버와 계속 통신하려면 세션에 대한 액세스 권한을 얻어야 합니다. 투명 상태 마이그레이션이 발생한 경우 세션도 전송되었을 수 있습니다. 이러한 가능성을 처리하기 위해 클라이언트는 EXCHANGE\_ID를 수행한 후 BIND\_CONN\_TO\_SESSION을 실행하여 전송된 세션을 새 서버에 연결할 수 있습니다. 실패하면 세션이 전송되지 않았으며 해당 세션을 대신하려면 새 세션을 만들어야 함을 나타냅니다.

어떤 상황에서는 세션 마이그레이션이 발생하지 않고도 BIND\_CONN\_TO\_SESSION이 성공할 수 있습니다. 상태 병합이 발생한 경우 연결된 클라이언트 ID에 이미 기존 세션 집합이 있을 수 있으며, 특정 세션의 세션 ID가 마이그레이션된 세션 ID와 동일할 수도 있습니다. 이 경우 해당 세션 ID를 사용하는 세션이 마이그레이션되지 않았더라도 BIND\_CONN\_TO\_SESSION이 성공할 수 있습니다. 이러한 경우, 사용된 슬롯 시퀀스 값이 새 세션에 적합하지 않으면 클라이언트는 시퀀스 오류를 받게 됩니다. 이런 일이 발생하면 클라이언트는 새 세션을 생성하고 기존 세션 사용을 중단할 수 있습니다.

클라이언트가 초기 마이그레이션 상태를 확인하고 새 서버로 이동했음을 확인하면 가능하면 잠금 상태를 다시 설정해야 합니다. 잠금을 통해 일반적으로 제공되는 보장을 잃지 않고 이를 수행하려면 투명 상태 마이그레이션이 구현되지 않은 경우를 포함하여 잠금 상태가 손실된 모든 경우에 대상 서버에서 fs별 유예 기간을 구현해야 합니다. 잠금 상태가 새 서버로 전송된 각 클라이언트는 잠금이 전송된 시점부터 잠금을 회수할 수 있는 유예 기간을 갖게 됩니다.

고객은 다음과 같은 경우를 처리해야 합니다.

\* 상태 병합의 경우 서버가 Transparent State Migration을 시도하지 않았을 가능성이 있으며, 이 경우 상태는 SEQ4\_STATUS 비트에 반영되지 않고 손실될 수 있습니다. 이러한 일이 발생했는지 확인하기 위해 클라이언트는 TEST\_STATEID를 사용하여 원본 서버에서 생성된 stateid가 대상 서버에서 계속 액세스 가능한지 확인할 수 있습니다. 단일 stateid가 성공적으로 전송된 것으로 확인되면 클라이언트는 Transparent State Migration이 시작되었다고 결론을 내릴 수 있으며 모든 stateid 전송에 실패하면 SEQ4\_STATUS 비트에 반영됩니다. 그렇지 않으면 투명 상태 마이그레이션이 발생하지 않은 것입니다.

\* Transparent State Migration이 발생하지 않은 경우 클라이언트는 대상 서버에서 제공하는 per-fs 유예 기간을 사용하여 원본 서버에 보유된 잠금을 회수할 수 있습니다.

\* Transparent State Migration이 발생하고 잠금 상태가 손실되지 않은 경우\(SEQ4\_STATUS 플래그에 표시됨\) 잠금 회수가 필요하지 않습니다.

\* Transparent State Migration이 발생하고 일부 잠금 상태가 손실된 경우\(SEQ4\_STATUS 플래그에 표시됨\) TEST\_STATEID를 사용하여 기존 stateid의 유효성을 확인하고 전송되지 않은 상태를 다시 설정하는 데 사용되는 재생을 사용해야 합니다.

위의 모든 경우에 대해 파일 시스템에 대한 새 잠금 획득을 포함하여 파일 시스템을 정상적으로 사용하기 전에 rca\_one\_fs 값이 TRUE인 RECLAIM\_COMPLETE를 수행해야 합니다. 이는 잠금이 손실되지 않았고 잠금을 회수할 필요가 없는 경우에도 적용됩니다.

11.13.5. 네트워크 주소 전송 후 세션 및 상태에 대한 액세스 권한 얻기

마이그레이션 없이 새로운 네트워크 주소로 전송되는 경우는 필요한 세션 및 잠금 상태에 대한 접근 권한을 얻어야 한다는 점에서 위의 11.13.4절에서 설명한 것과 유사합니다. 그러나 세부 사항은 더 간단하며 NFS4ERR\_MOVED를 수신하는 주소와 전송될 주소 간의 트렁킹 유형에 따라 달라집니다.

세션을 사용할 수 있게 만들려면 BIND\_CONN\_TO\_SESSION을 사용하여 이전에 사용 중인 세션에 대한 액세스 권한을 얻어야 합니다. 이것이 실패하는 경우에만 CREATE\_SESSION을 수행해야 합니다. 이 절차는 위 섹션 11.13.4의 내용을 반영하지만 세션 보존이 순전히 선택 사항이 아니라 트렁킹 유형에 따라 다르다는 점에서 중요한 차이점이 있습니다.

적절한 잠금 상태에 액세스하려면 일반적으로 세션 액세스 이외의 조치가 필요하지 않습니다. 그러나 잠금 상태가 손실될 가능성이 항상 있기 때문에 서버 재부팅 후 잠금을 회수해야 하는 필요성을 포함하여 잠금 상태가 손실되었는지 SEQ4\_STATUS 비트를 검사해야 합니다.

---
### **11.14.  Server Responsibilities Upon Migration**

파일 시스템 마이그레이션의 경우 클라이언트가 대상 서버에 연결되면 해당 서버는 원본 서버에서 열려 있던 파일에 대한 클라이언트의 지속적인 액세스를 제공할 수 있어야 합니다. 이를 제공하는 방법에는 두 가지가 있습니다.

\* fs별 유예 기간을 제공하여 클라이언트가 서버 다시 시작에서 복구하는 경우와 유사한 방식으로 잠금을 회수할 수 있도록 합니다. 보다 완전한 논의를 위해서는 섹션 11.14.1을 참조하십시오.

\* 세션 마이그레이션과 연계하여 Transparent State Migration을 구현함으로써 서버는 대상 서버에서 소스 서버에 구축된 상태에 대한 클라이언트의 즉각적인 액세스를 제공할 수 있습니다.

- 이러한 기능은 투명한 상태 마이그레이션과 세션 마이그레이션을 각각 논의하는 섹션 11.14.2 및 11.14.3에서 별도로 논의됩니다.

위에 설명된 모든 기능에는 원본 서버와 대상 서버 간의 잠금 관련 정보 전송이 포함될 수 있습니다. 어떤 경우에는 이 전송이 구현에 필요한 부분인 반면, 다른 경우에는 서버가 사용할 수도 있고 사용하지 않을 수도 있는 유용한 구현 지원이 됩니다. 아래 하위 섹션에서는 전송될 정보에 대해 논의하지만 전송 프로토콜의 세부 사항을 정의하지는 않습니다. 이 분야의 표준은 나중에 개발될 수 있지만 이는 구현 선택 사항으로 남아 있습니다.

11.14.1. 마이그레이션 후 상태 회수 수행에 대한 서버의 책임

이 경우 대상 서버는 원본 서버의 잠금에 대해 알 필요가 없습니다. 클라이언트가 이전에 보유한 잠금을 정확하게 보고\(재확보 작업을 통해\)하고 유예 기간이 만료될 때까지 마이그레이션된 파일 시스템에 새 잠금이 부여되는 것을 허용하지 않습니다. 새 잠금을 허용하지 않으면 이러한 파일 시스템에 액세스하는 모든 클라이언트에 적용되는 반면 유예 기간 만료는 마이그레이션된 각 클라이언트에 대해 독립적으로 발생합니다.

이 유예 기간 동안 클라이언트는 서버 재시작에서 복구할 때와 동일한 방식으로 회수 작업을 사용하여 마이그레이션된 파일 시스템 내의 파일 시스템 개체에 대한 잠금을 얻을 수 있으며, 서버는 일반적으로 클라이언트에 의존하여 해당 작업을 정확하게 보고합니다. 그러나 이러한 요청을 검증할 수 있는 옵션이 있습니다. 클라이언트가 원본 서버에 보관된 잠금만 회수하는 경우에는 충돌이 발생할 수 없습니다. 클라이언트가 잠금을 회수하면 rca\_one\_fs를 TRUE로 지정하여 RECLAIM\_COMPLETE를 수행하여 잠금 회수가 완료되었음을 나타냅니다.

잠금에 대한 정보를 전송하기 위해 원본 서버와 대상 서버가 협력할 필요는 없지만 구현 시 다음과 같은 유용한 정보 전송을 고려하는 것이 좋습니다.

\* 전송된 파일 시스템에 대한 잠금 상태가 있는 클라이언트 집합에 대한 정보가 사용 가능하게 되면 대상 서버는 모든 클라이언트가 잠금을 회수한 후 유예 기간을 종료하여 정상적인 잠금 활동을 그보다 먼저 재개할 수 있습니다. 그렇지 않았다면 그랬을 것이다.

\* 개별 클라이언트에 대한 잠금 요약 정보\(가능한 다양한 세부 수준\)는 클라이언트가 원본 서버에 설정된 잠금을 정확하게 나타내지 않는 일부 인스턴스를 감지할 수 있습니다.

11.14.2. 투명한 상태 마이그레이션 수행에 대한 서버의 책임

투명한 상태 마이그레이션을 수행하는 원본 서버의 기본 책임은 마이그레이션 중인 파일 시스템과 관련된 각 잠금 상태에 대한 설명을 대상 서버에 제공하는 것입니다. 클라이언트 ID 문자열 및 검증자 외에도 소스 서버는 각 상태 ID에 대해 다음을 제공해야 합니다.

\* 현재 시퀀스 값을 포함하는 stateid입니다.

\* 연결된 클라이언트 ID입니다.

\* 관련 파일의 핸들입니다.

\* 공개, 바이트 범위 잠금, 위임 또는 레이아웃과 같은 잠금 유형입니다.

\* 열기 및 바이트 범위 잠금과 같은 잠금의 경우 잠금 소유자에 대한 정보가 있습니다.

\* 회수 가능/취소 가능 잠금 유형의 경우 현재 회수 상태가 포함되어야 합니다.

\* 각 잠금 유형마다 관련 유형별 정보가 있습니다. 열기의 경우 공유 및 거부 모드가 포함되는 반면, 바이트 범위 잠금 및 레이아웃의 경우 유형과 바이트 범위가 있습니다.

이러한 정보는 클라이언트에 알려질 때 각 클라이언트에 적절한 컨텍스트를 제공하는 데 사용될 수 있도록 대상 서버의 클라이언트 ID 문자열로 구성될 가능성이 높습니다. 다른 클라이언트의 클라이언트 ID 문자열을 제시하여 다른 클라이언트를 가장하는 클라이언트와 연결된 문제는 섹션 21에 설명된 대로 NFSv4.1 상태 보호 기능을 사용하여 해결할 수 있습니다.

추가 서버 책임은 파일 시스템 마이그레이션 프로세스 중에 취소되거나 손실된 잠금과 관련됩니다. 마이그레이션 프로세스 중에 손실된 것으로 보이는 잠금은 클라이언트에 의해 회수되므로 서버는 마이그레이션 직전이나 직후에 취소된 잠금이 마이그레이션의 연속성이 보장되지 않는 상황에서 실수로 회수되는 것을 방지하기 위한 조치를 취해야 합니다. 자물쇠 소유를 보장할 수 없습니다.

\* 원본에서 잠금이 손실되었지만 클라이언트에서 손실을 아직 확인하지 않은 경우\(FREE\_STATEID 사용\) 대상에서 이 손실을 인식해야 잠금 회수 요청을 거부할 수 있습니다.

\* 상태 전송 후 클라이언트의 RECLAIM\_COMPLETE가 완료되기 전에 대상에서 잠금이 손실된 경우 대상 서버는 이를 기록하고 회수를 허용하지 않아야 합니다.

협력 서버의 추가적인 책임은 stateid가 클라이언트가 보유하고 다른 파일 시스템과 연결된 기존 stateid와 충돌하기 때문에 투명하게 전송할 수 없는 상황과 관련됩니다. 이 경우 두 가지 유효한 선택이 있습니다.

\* NFSv4.0에서와 같이 전송을 Transparent State Migration이 없는 전송으로 처리합니다. 이 경우 충돌하는 잠금은 클라이언트가 보유한 잠금을 회수한 후 RECLAIM\_COMPLETE를 수행할 때까지 허용될 수 없습니다. 단, 손실된 잠금을 회수하려는 시도였기 때문에 회수가 거부된 경우는 예외입니다.

\* 충돌하는 stateid가 있는 잠금을 제외하고 투명한 상태 마이그레이션을 구현합니다. 이 경우 클라이언트는 SEQ4\_STATUS 플래그를 통해 손실된 잠금을 인식하고 이를 회수할 수 있습니다.

소스와 대상 간에 상태를 전송할 때 \[69\]의 섹션 7.2에서 논의된 문제에 여전히 주의를 기울여야 합니다. 이 경우 전송 중에 잠금 상태가 변경되는 것을 방지하기 위해 NFSv4.0에서와 마찬가지로 NFS4ERR\_DELAY를 사용하는 것이 NFSv4.1에서도 필요할 수 있습니다. NFS4ERR\_DELAY가 반환되는 경우 적절한 클라이언트 재시도 접근 방식에 대한 자세한 내용은 섹션 15.1.1.3을 참조하세요.

NFS4.1 컨텍스트에는 여러 가지 중요한 차이점이 있습니다.

\* RELEASE\_LOCKOWNER가 없다는 것은 NFS4ERR\_DELAY를 사용하여 작업을 연기할 수 없는 경우가 더 이상 존재하지 않음을 의미합니다.

\* 작업 순서 지정은 더 이상 소유자 기반 작업 순서 번호를 사용하여 수행되지 않습니다. 대신 시퀀싱은 세션 기반입니다.

결과적으로 세션이 전송되지 않는 경우 \[69\]의 섹션 7.2에 설명된 기술이 적절하므로 더 이상 설명하지 않습니다.

---
#### **11.14.3.  Server Responsibilities in Effecting Session Transfer**

세션 전송을 수행하는 소스 서버의 기본 책임은 다음을 포함하여 세션과 함께 각 슬롯의 현재 상태에 대한 설명을 대상 서버에 제공하는 것입니다.

\* 해당 슬롯에 대해 수신된 마지막 시퀀스 값입니다.

\* 마지막으로 실행된 요청에 대해 캐시된 응답 데이터가 있는지 여부, 그리고 그렇다면 캐시된 응답이 있는지 여부.

세션이 전송되면 세션이 수집되어 대상 서버로 전송되는 기간 동안 전송된 상태를 수정할 수 없도록 만드는 것과 관련된 여러 가지 문제가 있습니다.

\* 단일 세션을 사용하여 여러 파일 시스템에 액세스할 수 있지만 일부 파일 시스템은 전송되지 않습니다.

\* 세션에 대한 요청은 거부되더라도 사용된 슬롯과 관련된 시퀀스 번호를 앞당겨 세션 상태에 영향을 미칠 수 있습니다.

결과적으로 파일 시스템 상태가 수정 불가능한 것으로 간주될 수 있는 경우 클라이언트에는 진행 중인 요청이 얼마든지 있을 수 있으며, 각 요청은 다양한 유형의 세션 상태를 변경할 수 있습니다.

1. 마이그레이션이 시작되기 전에 마이그레이션하는 파일 시스템에서 처리된 요청입니다.

2. 액세스 중인 파일 시스템이 마이그레이션되는 중이었기 때문에 NFS4ERR\_DELAY 오류를 수신한 요청입니다.

3. 액세스 중인 파일 시스템이 마이그레이션되었기 때문에 NFS4ERR\_MOVED 오류를 수신한 요청입니다.

4. 위치 또는 상태 정보를 얻기 위해 마이그레이션 파일 시스템에 액세스한 요청입니다.

5. 마이그레이션하는 파일 시스템을 참조하지 않은 요청입니다.

특정 슬롯의 기록에는 이러한 요청 클래스가 다수 포함될 가능성이 있다는 점에 유의해야 합니다. 마이그레이션된 세션이 마이그레이션된 세션이 아닌 다른 파일 시스템에서 사용되는 경우 클래스 5의 요청이 일반적일 수 있으며 많은 슬롯에 대해 마지막으로 처리되는 요청일 수 있습니다.

마이그레이션 프로세스의 일부로 잠금 상태가 수정된 후에도 세션 상태가 변경될 수 있으므로 클라이언트에 알려진 세션 상태는 대상 서버의 세션 상태와 다를 수 있으며 이는 필연적으로 이전에 원본 서버의 세션 상태를 반영합니다. 시간. 이 상황을 처리하는 방법을 결정할 때 초기 시퀀스 ID 값 선택에 따른 두 가지 종류의 행동 결과를 구별하는 것이 도움이 됩니다.

\* NFS4ERR\_SEQ\_MISORDERED 오류는 요청의 시퀀스 ID가 현재 슬롯에 ​​표시된 마지막 ID와 동일하지 않거나 다음으로 큰 ID와 같지 않을 때 반환됩니다.

- 마이그레이션 시점에서 올바른 마지막 시퀀스 값에 대해 상호 허용 가능한 값에 도달하는 것이 어렵다는 점을 고려하여 시퀀스 ID가 다음과 같은 경우 허용되지 않는 것으로 간주되는 경우 서버는 어느 정도 관용을 표시해야 할 수 있습니다. 세션 마이그레이션은 포함되지 않았습니다.

\* 요청의 시퀀스 ID가 슬롯에 기록된 마지막 값과 일치하는 경우 이전에 실행된 요청에 대해 캐시된 응답을 반환합니다.

- 오류가 반환되고 비멱등성 작업이 실행될 가능성이 없는 경우 세션 마이그레이션이 포함되지 않은 경우 이를 엄격하게 준수할 필요가 없을 수도 있습니다. 예를 들어, NFS4ERR\_DELAY 오류가 반환되었다는 사실은 어떤 실질적인 방식으로 클라이언트에 도움이 되지 않을 수 있지만, 원본 서버에서 NFS4ERR\_MOVED가 반환되었다는 사실은 요청이 재발행되어 대상 서버로 전달될 때 관련이 없을 수 있습니다.

중요한 문제는 사양이 실제로는 가능성이 없을지라도 모든 잠재적인 COMPOUND를 기록해야 한다는 것입니다. 예를 들어, COMPOUND는 여러 파일 시스템에 액세스할 수 있으며 마이그레이션 중인 파일 시스템에 액세스하기 전에 그 중 일부에서 비멱등성 작업을 수행할 수 있습니다. 또한 COMPOUND는 NFS4ERR\_DELAY 또는 NFS4ERR\_MOVED로 거부되기 전에 응답으로 상당한 데이터를 반환할 수 있으며 추가로 sa\_cachethis로 표시될 수도 있습니다. 그러나 클라이언트와 서버가 섹션 15.1.1.3의 규칙을 준수하는 경우 NFS4ERR\_DELAY 응답을 받은 후 비멱등성 작업이 잘못 재발행될 가능성이 없습니다.

이러한 문제를 해결하기 위해 대상 서버는 세션 전송을 구현할 때 다음 중 하나를 수행할 수 있습니다.\(MAY\)

\* 클라이언트가 대상 서버에서 해당 슬롯에 대한 시작 시퀀스를 설정할 때까지 특정 슬롯에 대한 시퀀스 의미 체계를 적용하지 마세요.

\* 각 슬롯에 대해 캐시된 응답을 반환하지 마세요.

- 클라이언트가 대상 서버에서 해당 슬롯에 대한 시작 시퀀스를 설정할 때까지 NFS4ERR\_DELAY 또는 NFS4ERR\_MOVED입니다.

\* 클라이언트가 대상 서버의 특정 슬롯에 대한 시작 시퀀스를 설정할 때까지 NFS4ERR\_SEQ\_MISORDERED를 보고하거나 NFS4ERR\_DELAY 또는 NFS4ERR\_MOVED를 포함하고 최종 오류까지 응답이 NFS4\_OK인 일련의 작업으로만 구성된 캐시된 응답을 반환하지 마십시오.

섹션 15.1.1.3에 포함된 NFS4ERR\_DELAY 처리 규칙을 포함하여 위에서 언급한 고려 사항으로 인해 대상 서버는 아래 나열된 세 가지 정책을 채택하여 클라이언트로부터 수신된 SEQUENCE 작업에 적절하게 응답할 수 있습니다.

\* 서버 핸드오프 후 클라이언트가 전환을 인식하기 전에 대상 서버가 클라이언트의 요청을 인식할 수 없기 때문에 전송된 세션 내 슬롯의 초기 요청에 대해 NFS4ERR\_SEQ\_MISORDERED로 응답하지 않습니다. NFS4ERR\_SEQ\_MISORDERED가 정상적으로 보고된 경우 해당 요청은 새 요청으로 정상적으로 처리됩니다.

\* 원본 서버에서 전송한 시퀀스와 일치할 때마다 재시도를 위해 응답하는 것처럼 응답합니다. 비록 이것이 서버 핸드오프 이후에 발행된 요청에 대한 재시도 처리를 제공하지 않더라도 그러한 요청이 발행될 때 결코 재시도되지 않을 것이라는 가정하에. 상태를 변경하는 방식으로 응답하므로 이에 대한 재시도 지원이 불필요해집니다.

\* 특정 슬롯에 대해 재시도되지 않은 SEQUENCE가 수신되면 이를 추가 시퀀스 확인의 기초로 사용하고 소스 서버에서 전송한 시퀀스 값을 더 이상 참조하지 않습니다.

---
### **11.15.  Effecting File System Referrals**

파일 시스템이 없고 fs\_locations 또는 fs\_locations\_info 속성을 통해 하나 이상의 대체 위치를 사용할 수 있게 되면 참조가 적용됩니다. 클라이언트는 일반적으로 NFS4ERR\_MOVED 오류를 받고, 적절한 위치 정보를 가져온 다음, 원래 네임스페이스 내의 논리적 위치를 유지하더라도 다른 서버의 파일 시스템에 계속 액세스합니다. 참조는 클라이언트가 이전에 문제의 파일 시스템을 참조하지 않은 경우에만 발생한다는 점에서 마이그레이션 이벤트와 다릅니다\(따라서 전환할 항목이 없음\). 참조는 해당 루트에 없는 파일 시스템이 있는 경우에만 적용됩니다.

아래 섹션에 제공된 예는 실제 클라이언트가 일반적으로 다중 구성 요소 조회를 수행하지 않지만 이름 계층의 상위 수준에 관한 캐시된 정보를 갖는다는 점에서 다소 인위적입니다. 그러나 이러한 예는 특정 클라이언트가 캐시를 선택하는 방법에 대한 세부 사항을 논의하지 않고 필요한 동작을 소수의 요청 범위 내에 명확하고 쉽게 넣을 수 있도록 선택되었습니다.

---
#### **11.15.1.  Referral Example (LOOKUP)**

대상 서버에 /this/is/the/path가 없는 환경에서 다음 COMPOUND를 보낸다고 가정해보자. 이는 여러 가지 이유 때문일 수 있습니다. 파일 시스템이 이동되었거나 대상 서버가 주로 또는 단독으로 클라이언트를 다양한 파일 시스템이 있는 서버로 참조하도록 기능하고 있을 수 있습니다.

```text
   *  PUTROOTFH

   *  LOOKUP "this"

   *  LOOKUP "is"

   *  LOOKUP "the"

   *  LOOKUP "path"

   *  GETFH

   *  GETATTR (fsid, fileid, size, time_modify)
```

주어진 상황에서 결과는 다음과 같습니다.

```text
   *  PUTROOTFH --> NFS_OK.  The current fh is now the root of the
      pseudo-fs.

   *  LOOKUP "this" --> NFS_OK.  The current fh is for /this and is
      within the pseudo-fs.

   *  LOOKUP "is" --> NFS_OK.  The current fh is for /this/is and is
      within the pseudo-fs.

   *  LOOKUP "the" --> NFS_OK.  The current fh is for /this/is/the and
      is within the pseudo-fs.

   *  LOOKUP "path" --> NFS_OK.  The current fh is for /this/is/the/path
      and is within a new, absent file system, but ...  the client will
      never see the value of that fh.

   *  GETFH --> NFS4ERR_MOVED.  Fails because current fh is in an absent
      file system at the start of the operation, and the specification
      makes no exception for GETFH.
```

\* GETATTR\(fsid, 파일 ID, 크기, time\_modify\). GETFH의 실패로 인해 COMPOUND 처리가 중지되므로 실행되지 않습니다.

GETFH가 실패하면 클라이언트는 존재하지 않는 파일 시스템의 루트와 해당 파일 시스템을 찾을 수 있는 위치, 즉 서버와 해당 서버의 루트 fh에 상대적인 경로를 결정하는 작업을 수행합니다. 이 예에서 클라이언트는 중간 디렉터리에 대한 파일 핸들 및 속성 정보\(예: fsid\)를 얻지 않았으므로 부재 파일 시스템이 시작되는 위치를 확신할 수 없습니다. 예를 들어, /this/is/the가 이동된 파일 시스템의 루트이고 "경로" 조회가 성공한 이유는 해당 작업에서 파일 시스템이 없는 것이 아니라 마지막 LOOKUP과 GETFH 사이에서 이동했습니다\(COMPOUND가 원자적이지 않기 때문에\). 모든 중간 디렉터리에 대한 fsid가 있더라도 아직 fsid가 없기 때문에 /this/is/the/path가 새 파일 시스템의 루트인지 알 수 없습니다.

필요한 정보를 얻으려면 적절한 파일 시스템 경계가 어디에 있는지 확인할 수 있도록 GETFH 및 GETATTR과 함께 LOOKUP 체인을 다시 보내 적어도 fsid를 얻도록 합시다. 클라이언트는 fs\_locations\_info를 동시에 가져오도록 선택할 수 있지만 대부분의 경우 클라이언트는 파일 시스템 경계가 어디에 있는지\(NFS4ERR\_MOVED가 수신되었거나 수신되지 않은 위치로 인해\) 추측할 수 있으므로 fs\_locations\_info를 가져올 필요가 없습니다.

```text
   OP01:  PUTROOTFH --> NFS_OK
```

- \* 현재 fh는 pseudo-fs의 루트입니다.

```text
   OP02:  GETATTR(fsid) --> NFS_OK
```

- \* 완전성을 위해서입니다. 일반적으로 클라이언트는 서버와 통신을 설정하자마자 pseudo-fs의 fsid를 알게 됩니다.

```text
   OP03:  LOOKUP "this" --> NFS_OK

   OP04:  GETATTR(fsid) --> NFS_OK
```

- \* 파일 시스템 경계가 어디에 있는지 확인하려면 현재 fsid를 가져옵니다. fsid는 이 예에서 pseudo-fs의 ID이므로 경계가 없습니다.

```text
   OP05:  GETFH --> NFS_OK
```

- \* 현재 fh는 /this에 대한 것이며 pseudo-fs 내에 있습니다.

```text
   OP06:  LOOKUP "is" --> NFS_OK
```

- \* 현재 fh는 /this/is에 대한 것이며 pseudo-fs 내에 있습니다.

```text
   OP07:  GETATTR(fsid) --> NFS_OK
```

- \* 파일 시스템 경계가 어디에 있는지 확인하려면 현재 fsid를 가져옵니다. fsid는 이 예에서 pseudo-fs의 ID이므로 경계가 없습니다.

```text
   OP08:  GETFH --> NFS_OK
```

- \* 현재 fh는 /this/is에 대한 것이며 pseudo-fs 내에 있습니다.

```text
   OP09:  LOOKUP "the" --> NFS_OK
```

- \* 현재 fh는 /this/is/the에 대한 것이며 pseudo-fs 내에 있습니다.

```text
   OP10:  GETATTR(fsid) --> NFS_OK
```

- \* 파일 시스템 경계가 어디에 있는지 확인하려면 현재 fsid를 가져옵니다. fsid는 이 예에서 pseudo-fs의 ID이므로 경계가 없습니다.

```text
   OP11:  GETFH --> NFS_OK
```

- \* 현재 fh는 /this/is/the에 대한 것이며 pseudo-fs 내에 있습니다.

```text
   OP12:  LOOKUP "path" --> NFS_OK

      *  Current fh is for /this/is/the/path and is within a new, absent
         file system, but ...
```

- \* 클라이언트는 해당 fh의 값을 결코 볼 수 없습니다.

```text
   OP13:  GETATTR(fsid, fs_locations_info) --> NFS_OK
```

\* 우리는 fsid를 통해 파일 시스템이 어디에 있는지 알고 있습니다.

- 경계가 있습니다. 이 작업에서 fsid는 상위 디렉토리\(OP10에서 검색됨\)의 그것과 다릅니다. 우리에게 주어진 fsid가 반드시 새 위치에 보존되는 것은 아닙니다. 해당 fsid는 다를 수 있으며 실제로 이 파일 시스템에 대해 가지고 있는 fsid는 해당 새 서버에 있는 다른 파일 시스템의 유효한 fsid일 수 있습니다.

- \* 이 특별한 경우에 우리는 /this/is/the가 아닌 /this/is/the/path로 이동했다고 확신합니다. 왜냐하면 우리는 후자의 fsid를 갖고 있고 pseudo-fs의 fsid이기 때문입니다. , 아마도 움직일 수 없습니다. 그러나 다른 예에서는 의존할 수 있는 이러한 종류의 정보가 없을 수 있습니다\(예: /this/is/the는 /this/is/the/path와 별개의 비 의사 파일 시스템일 수 있음\). 이동되는 파일 시스템의 경계에 다른 신뢰할 수 있는 소스 정보가 있어야 합니다. 예를 들어 /this/is 파일 시스템이 이동된 경우 참조가 아닌 마이그레이션의 경우가 발생하고 마이그레이션된 파일 시스템의 경계가 명확해지면 fs\_locations\_info를 가져올 수 있습니다.

- \* 이 시점에서 NFS4ERR\_MOVED를 받았다는 사실은 이것이 추천일 가능성이 높으며 대상이 필요하다는 것을 의미하기 때문에 fs\_locations\_info를 가져오는 중입니다. /this/is/the가 마이그레이션된 파일 시스템인 경우에도 해당 파일 시스템에 대한 위치 정보가 필요합니다.

```text
   OP14:  GETFH --> NFS4ERR_MOVED
```

- \* 작업 시작 시 현재 fh가 없는 파일 시스템에 있고 사양에서 GETFH에 대한 예외를 두지 않기 때문에 실패합니다. 이는 서버가 존재하지 않는 파일 시스템 내에서 클라이언트에게 파일 핸들을 절대 보내지 않는다는 것을 의미합니다.

위의 내용을 고려하면 클라이언트는 fsid 변경이 발생한 위치\("the"와 "path" 사이\)를 기록하여 부재 파일 시스템의 루트가 어디에 있는지\(/this/is/the/path\) 압니다. fs\_locations\_info 속성은 참조가 진행될 수 있도록 클라이언트에 없는 파일 시스템의 실제 위치도 제공합니다. 서버는 참조 서버가 보낸 정보와 파일 시스템의 홈 정보 간에 충돌 문제가 발생할 가능성이 거의 없도록 클라이언트에 부재하는 파일 시스템에 대한 최소한의 정보를 제공합니다. 참조 서버에는 파일 핸들과 속성이 거의 없으며 클라이언트는 참조를 활성화하는 기능을 사용하여 수신한 정보를 임시 정보로 처리할 수 있습니다.

---
#### **11.15.2.  Referral Example (READDIR)**

클라이언트가 참조를 만날 수 있는 또 다른 상황은 일부 하위 디렉터리가 존재하지 않는 파일 시스템의 루트인 디렉터리에서 READDIR을 수행하는 경우입니다.

해당 디렉토리가 다음과 같이 읽혀진다고 가정합니다.

```text
   *  PUTROOTFH

   *  LOOKUP "this"

   *  LOOKUP "is"

   *  LOOKUP "the"

   *  READDIR (fsid, size, time_modify, mounted_on_fileid)
```

이 경우 rdattr\_error가 요청되지 않고 fs\_locations\_info가 요청되지 않으며 일부 속성을 제공할 수 없기 때문에 결과는 READDIR에서 NFS4ERR\_MOVED 오류가 되며 자세한 결과는 다음과 같습니다.

```text
   *  PUTROOTFH --> NFS_OK.  The current fh is at the root of the
      pseudo-fs.

   *  LOOKUP "this" --> NFS_OK.  The current fh is for /this and is
      within the pseudo-fs.

   *  LOOKUP "is" --> NFS_OK.  The current fh is for /this/is and is
      within the pseudo-fs.

   *  LOOKUP "the" --> NFS_OK.  The current fh is for /this/is/the and
      is within the pseudo-fs.

   *  READDIR (fsid, size, time_modify, mounted_on_fileid) -->
      NFS4ERR_MOVED.  Note that the same error would have been returned
      if /this/is/the had migrated, but it is returned because the
      directory contains the root of an absent file system.
```

이제 rdattr\_error를 사용하여 다시 보낸다고 가정해 보겠습니다.

```text
   *  PUTROOTFH

   *  LOOKUP "this"

   *  LOOKUP "is"

   *  LOOKUP "the"

   *  READDIR (rdattr_error, fsid, size, time_modify, mounted_on_fileid)
```

결과는 다음과 같습니다:

```text
   *  PUTROOTFH --> NFS_OK.  The current fh is at the root of the
      pseudo-fs.

   *  LOOKUP "this" --> NFS_OK.  The current fh is for /this and is
      within the pseudo-fs.

   *  LOOKUP "is" --> NFS_OK.  The current fh is for /this/is and is
      within the pseudo-fs.

   *  LOOKUP "the" --> NFS_OK.  The current fh is for /this/is/the and
      is within the pseudo-fs.

   *  READDIR (rdattr_error, fsid, size, time_modify, mounted_on_fileid)
      --> NFS_OK.  The attributes for directory entry with the component
      named "path" will only contain rdattr_error with the value
      NFS4ERR_MOVED, together with an fsid value and a value for
      mounted_on_fileid.
```

fs\_locations\_info를 얻기 위해 또 다른 READDIR을 수행한다고 가정합니다\(비록 섹션 11.15.1에서처럼 GETATTR을 직접 사용할 수도 있었지만\).

```text
   *  PUTROOTFH

   *  LOOKUP "this"

   *  LOOKUP "is"

   *  LOOKUP "the"

   *  READDIR (rdattr_error, fs_locations_info, mounted_on_fileid, fsid,
      size, time_modify)
```

결과는 다음과 같습니다.

```text
   *  PUTROOTFH --> NFS_OK.  The current fh is at the root of the
      pseudo-fs.

   *  LOOKUP "this" --> NFS_OK.  The current fh is for /this and is
      within the pseudo-fs.

   *  LOOKUP "is" --> NFS_OK.  The current fh is for /this/is and is
      within the pseudo-fs.

   *  LOOKUP "the" --> NFS_OK.  The current fh is for /this/is/the and
      is within the pseudo-fs.

   *  READDIR (rdattr_error, fs_locations_info, mounted_on_fileid, fsid,
      size, time_modify) --> NFS_OK.  The attributes will be as shown
      below.
```

"path"라는 구성요소가 있는 디렉토리 항목의 속성에는 다음만 포함됩니다.

```text
   *  rdattr_error (value: NFS_OK)

   *  fs_locations_info

   *  mounted_on_fileid (value: unique fileid within referring file
      system)

   *  fsid (value: unique value within referring server)
```

"path" 항목의 속성에는 size 또는 time\_modify가 포함되지 않습니다. 이러한 속성은 존재하지 않는 파일 시스템 내에서 사용할 수 없기 때문입니다.

---
### **11.16.  The Attribute fs_locations**

fs\_locations 속성은 다음과 같은 방식으로 구성됩니다.

```text
   struct fs_location4 {
           utf8str_cis     server<>;
           pathname4       rootpath;
   };

   struct fs_locations4 {
           pathname4       fs_root;
           fs_location4    locations<>;
   };
```

fs\_location4 데이터 유형은 서버 이름과 해당 서버의 네임스페이스 내 파일 시스템 루트에 대한 경로를 제공하여 파일 시스템의 위치를 ​​나타내는 데 사용됩니다. 서버 세트의 네임스페이스 내 동일한 경로에 해당 파일 시스템이 있는 경우 서버 이름 배열이 제공될 수 있습니다. 서버 배열의 항목은 UTF-8 문자열이며 기존 DNS 호스트 이름, IPv4 주소, IPv6 주소 또는 길이가 0인 문자열 중 하나를 나타냅니다. IPv4 또는 IPv6 주소는 netid를 뺀 범용 주소\(섹션 3.3.9 및 \[12\] 참조\)로 표시되며, 포트 번호를 나타내는 후행 ".p1.p2" 접미사가 있거나 없이 표시됩니다. 접미사가 생략된 경우 기본 포트인 2049를 가정해야 합니다\(SHOULD\). RPC 호출에 사용되는 현재 주소를 나타내기 위해 길이가 0인 문자열을 사용해야 합니다. 동일한 루트 경로를 공유하는 모든 서버가 하나의 fs\_location4 인스턴스에 나열될 필요는 없습니다. 편의를 위해 서버 이름 배열이 제공됩니다. 동일한 루트 경로를 공유하는 서버는 fs\_locations 속성의 별도 fs\_location4 항목에 나열될 수도 있습니다.\(SHOULD, SHOULD\)

fs\_locations4 데이터 유형과 fs\_locations 속성에는 각각 그러한 위치의 배열이 포함되어 있습니다. 각 서버의 네임스페이스는 다르게 구성될 수 있으므로 "fs\_root" 필드를 제공한다. fs\_root가 나타내는 경로는 현재 서버의 네임스페이스, 즉 fs\_locations 속성을 얻은 서버의 파일 시스템 위치를 나타냅니다. fs\_root 경로는 현재 파일 핸들이 지정하는 현재 파일 시스템 내의 개체에 관계없이 위치가 보고되는 파일 시스템의 루트를 명확하게 참조하여 클라이언트를 지원하기 위한 것입니다. fs\_root는 단순히 클라이언트가 현재 서버의 개체\(즉, fs\_locations 속성이 적용되는 개체\)에 도달하는 데 사용하는 경로 이름입니다.

fs\_locations 속성이 조사되고 대체 파일 시스템 위치가 없는 경우 서버는 유효한 fs\_root와 함께 길이가 0인 fs\_location4 구조 배열을 반환해야 합니다.\(SHOULD\)

예를 들어, 두 서버\(servA 및 servB\)에 복제된 파일 시스템이 있다고 가정합니다. servA에서 파일 시스템은 /a/b/c 경로에 있습니다. servB에서 파일 시스템은 /x/y/z 경로에 있습니다. 클라이언트가 /a/b/c/d에 있는 디렉토리에 대한 fs\_locations 값을 얻는 경우 파일 시스템의 루트가 /a/b/c에 있는 servA의 네임스페이스에 있는지 반드시 알지 못할 수도 있습니다. 클라이언트가 servB로 전환할 때 servA에서 처음 참조한 디렉토리가 이제 servB의 /x/y/z/d 경로로 표시되는지 확인해야 합니다. 이를 용이하게 하기 위해 servA가 제공하는 fs\_locations 속성에는 fs\_root 값 /a/b/c와 fs\_locations에 두 개의 항목이 있습니다. fs\_locations의 한 항목은 자체\(servA\)에 대한 것이고 다른 항목은 경로가 /x/y/z인 servB에 대한 것입니다. 이 정보를 사용하여 클라이언트는 액세스 경로 시작 부분에서 /a/b/c를 /x/y/z로 대체하고 /x/y/z/d를 구성하여 새 서버에 사용할 수 있습니다.

각 루트 경로의 구성 요소 수가 동일해야 한다는 요구 사항은 없습니다. rootpath 또는 fs\_root의 구성 요소 수 사이에는 관계가 없으며 rootpath와 fs\_root의 구성 요소 중 어느 것도 동일할 필요가 없습니다. 위의 예에서는 위치 배열의 세 번째 요소\(서버는 "servC", 루트 경로는 "/I/II"\), 서버는 "servD", 루트 경로의 네 번째 요소를 가질 수 있습니다. "/aleph/beth/gimel/daleth/he"와 같습니다.

fs\_root와 루트 경로 간의 관계는 클라이언트가 현재 서버의 fs\_root에 표시된 경로 이름을 새 서버의 rootpath에 표시된 대체 이름으로 바꾸는 것입니다.

참조 또는 마이그레이션된 파일 시스템의 예로 serv1에 파일 시스템이 있다고 가정합니다. serv1에서 파일 시스템은 /az/buky/vedi/glagoli에 있습니다. 클라이언트는 Glagoli의 개체가 마이그레이션된\(또는 추천인\) 것을 발견합니다. 클라이언트는 /az/buky/vedi/glagoli의 fs\_root와 위치 배열의 한 요소\(서버는 serv2, 루트 경로는 /izhitsa/fita\)를 포함하는 fs\_locations 속성을 가져옵니다. 클라이언트는 /az/buky/vedi/glagoli를 /izhitsa/fita로 바꾸고 serv2에서 후자의 경로 이름을 사용합니다.

따라서 서버는 클라이언트가 fs\_locations 속성이 적용되는 객체에 도달하는 데 사용한 경로와 동일한 fs\_root를 반환해야 합니다. 그렇지 않으면 클라이언트는 새 서버에서 사용할 새 경로를 결정할 수 없습니다.\(MUST\)

fs\_locations 속성에는 제시된 다양한 파일 시스템 선택의 다양한 속성을 정의하는 정보가 부족하므로 fs\_locations\_info를 사용할 수 없는 경우에만 조사하고 사용해야 합니다. fs\_locations를 사용하는 경우 다음 규칙에 따라 특정 위치에 대한 정보를 가정해야 합니다.\(SHOULD\)

다음 규칙은 일반적이며 상황에 관계없이 적용됩니다.

\* 나열된 모든 파일 시스템 인스턴스는 현재 fh\_expire\_type 속성에 FH4\_VOL\_MIGRATION 비트가 포함되지 않은 경우에만 동일한 핸들 클래스로 간주되어야 합니다. 참조의 경우 현재 파일 시스템 내에 알려진 파일 핸들이 없고 참조\(부재\) 파일 시스템의 fh\_expire\_type 속성에 대한 액세스가 없기 때문에 파일 핸들 문제가 적용되지 않습니다.

\* 나열된 모든 파일 시스템 인스턴스는 fh\_expire\_type 속성이 영구 파일 핸들을 나타내고 FH4\_VOL\_MIGRATION 비트를 포함하지 않는 경우에만 동일한 fileid 클래스로 간주되어야 합니다. 참조의 경우 참조\(부재\) 파일 시스템 내에 알려진 파일 ID가 없고 fh\_expire\_type 속성에 대한 액세스가 없기 때문에 파일 ID 문제가 적용되지 않습니다.

\* 모든 파일 시스템 인스턴스 서버는 서로 다른 변경 클래스로 간주되어야 합니다.

다른 수업 과제의 경우 파일 시스템 전환 처리는 전환 이유에 따라 다릅니다.

\* 마이그레이션으로 인해 전환이 발생한 경우, 즉 클라이언트가 NFS4ERR\_MOVED 오류를 수신한 후 새 파일 시스템으로 이동한 경우 대상은 소스와 동일한 쓰기 검증자 클래스로 처리되어야 합니다.

\* 전환이 다른 복제본으로의 페일오버로 인해 발생하는 경우, 즉 클라이언트가 NFS4ERR\_MOVED 오류를 수신하지 않고 다른 복제본을 선택한 경우 대상은 소스와 다른 쓰기 검증자 클래스에 속하는 것으로 처리되어야 합니다.

특정 선택 사항은 각각 장애 조치 및 제어된 마이그레이션에 대한 일반적인 구현 패턴을 반영합니다. 다른 선택도 가능하고 유용하므로 fs\_locations\_info를 사용하면 이 정보를 더 잘 얻을 수 있습니다. 서버 구현이 다른 선택 사항을 전달해야 하는 경우 fs\_locations\_info 속성을 지원해야 합니다.\(MUST\)

fs\_locations 속성을 요청하는 GETATTR 작업에서 사용할 보안 유형에 대한 권장 사항에 대한 논의는 섹션 21을 참조하세요.

---
### **11.17.  The Attribute fs_locations_info**

fs\_locations\_info 속성은 계속해서 존재하고 지원될 fs\_locations 속성을 보다 기능적으로 대체하기 위한 것입니다. 클라이언트는 이를 사용하여 사용 중인 복제본 및 추가 복제본에 액세스하기 위한 추가 네트워크 경로를 포함하여 대체 파일 시스템 위치에 대한 보다 완전한 데이터 세트를 얻을 수 있습니다. 서버가 fs\_locations\_info를 지원하지 않는 경우 fs\_locations를 사용하여 데이터의 하위 집합을 가져올 수 있습니다. fs\_locations\_info를 지원하는 서버는 fs\_locations도 지원해야 합니다.\(MUST\)

fs\_locations에서 사용할 수 없는 fs\_locations\_info에는 추가 데이터가 있습니다.

\* 속성 연속성 정보. 이 정보를 통해 클라이언트는 데이터에 액세스하는 애플리케이션의 투명성 요구 사항을 충족하는 복제본을 선택하고 속성 연속성에 대한 서버 보장으로 인해 최적화를 활용할 수 있습니다\(예: 파일 시스템의 파일 변경 속성이 여러 복제본이 있는 경우 클라이언트는 다른 복제본으로 전환할 때 파일의 캐시를 무효화할 필요가 없습니다.

\* 클라이언트의 관점에서 여러 복제본이 동일한 대상 파일 시스템에 해당하는 경우를 나타내는 파일 시스템 ID 정보로, 동일한 파일 데이터의 별개의 동기화된 복제본으로서 중단 없이 상호 교환적으로 사용할 수 있습니다.

- 공통 ID 정보가 있는 두 개의 복제본을 갖는 것은 동일한 복제본에 대한 두 개의 \(트렁킹된\) 경로가 있는 경우와 다릅니다.

\* 고객이 의도하는 용도에 따라 다양한 복제본의 적합성을 결정하는 정보입니다. 예를 들어, 많은 응용 프로그램에는 완전히 최신 복사본\(예: 쓰기 응용 프로그램\)이 필요한 반면, 다른 응용 프로그램에는 합리적으로 사용 가능한 가장 최신 복사본에만 액세스해야 할 수도 있습니다.

\* 복제본에 대한 서버 파생 기본 설정 정보. 이는 로드 밸런싱을 구현하는 동시에 기본 데이터베이스가 실패할 경우 사용할 전체 파일 시스템 목록을 클라이언트에 제공하는 데 사용할 수 있습니다.

fs\_locations\_info 속성은 fs\_locations 속성과 유사하게 구성됩니다. 최상위 구조\(fs\_locations\_info4\)에는 파일 시스템의 루트 경로 이름과 해당 서버에서 공통 루트 경로를 공유하는 복제본을 정의하는 하위 수준 구조의 배열을 포함한 전체 속성이 포함되어 있습니다. 하위 수준 구조\(fs\_locations\_item4\)에는 특정 경로 이름과 하나 이상의 개별 네트워크 액세스 경로에 대한 정보가 포함됩니다. 마지막으로 가장 낮은 수준인 fs\_locations\_info에는 파일 시스템 위치 항목 외에 서버별 복제본 정보를 포함하는 fs\_locations\_server4 구조가 있습니다. 이 서버 복제본별 정보에는 명목상 불투명한 배열인 fls\_info가 포함되어 있으며, 이 배열 내에서 특정 정보 조각이 아래 나열된 특정 인덱스에 위치합니다.

서로 다른 fs\_location\_item4 구조 내에 있는 두 개의 fs\_location\_server4 항목은 트렁크 가능하지 않지만 동일한 fs\_location\_item4 구조 내의 두 항목은 트렁크 가능하거나 그렇지 않을 수 있습니다. 트렁크 가능한 두 항목은 동일한 ID 정보를 갖지만 위에서 언급한 것처럼 반대의 경우는 아닙니다.

속성에는 항상 하나 이상의 fs\_locations\_server 항목이 포함됩니다. 일반적으로 FS4LIGF\_CUR\_REQ 플래그가 설정된 항목이 있지만 추천의 경우 해당 플래그가 설정된 항목은 없습니다.

다양한 복제본에 대해 서버에서 반환된 fs\_locations\_info 속성은 여러 가지 이유로 다를 수 있다는 점에 유의해야 합니다. 한 서버는 다른 서버에 알려지지 않은 복제본 세트에 대해 알고 있을 수 있습니다. 또한 호환성 속성이 다를 수 있습니다. 파일 핸들은 복제본 A에서 복제본 B로 이동하지만 반대 방향으로 이동하지 않는 동일한 클래스일 수 있습니다. 이는 파일 핸들이 동일하기 때문에 발생할 수 있지만 복제본 B의 서버 구현에는 해당 동등성을 기록하고 보고하는 규정이 없을 수 있습니다.

fs\_locations\_info 속성은 fs\_location\_item4 구조의 배열과 함께 루트 경로 이름\(fs\_locations 속성의 fs\_root와 마찬가지로 fli\_fs\_root\)으로 구성됩니다. fs\_location\_item4 구조는 루트 경로 이름\(fli\_rootpath\)과 fs\_locations\_server4 데이터 유형 요소의 배열\(fli\_entries\)로 구성되며 모두 다음과 같이 정의됩니다.

```text
   /*
    * Defines an individual server access path
    */
   struct  fs_locations_server4 {
           int32_t         fls_currency;
           opaque          fls_info<>;
           utf8str_cis     fls_server;
   };

   /*
    * Byte indices of items within
    * fls_info: flag fields, class numbers,
    * bytes indicating ranks and orders.
    */
   const FSLI4BX_GFLAGS            = 0;
   const FSLI4BX_TFLAGS            = 1;

   const FSLI4BX_CLSIMUL           = 2;
   const FSLI4BX_CLHANDLE          = 3;
   const FSLI4BX_CLFILEID          = 4;
   const FSLI4BX_CLWRITEVER        = 5;
   const FSLI4BX_CLCHANGE          = 6;
   const FSLI4BX_CLREADDIR         = 7;

   const FSLI4BX_READRANK          = 8;
   const FSLI4BX_WRITERANK         = 9;
   const FSLI4BX_READORDER         = 10;
   const FSLI4BX_WRITEORDER        = 11;

   /*
    * Bits defined within the general flag byte.
    */
   const FSLI4GF_WRITABLE          = 0x01;
   const FSLI4GF_CUR_REQ           = 0x02;
   const FSLI4GF_ABSENT            = 0x04;
   const FSLI4GF_GOING             = 0x08;
   const FSLI4GF_SPLIT             = 0x10;

   /*
    * Bits defined within the transport flag byte.
    */
   const FSLI4TF_RDMA              = 0x01;

   /*
    * Defines a set of replicas sharing
    * a common value of the rootpath
    * within the corresponding
    * single-server namespaces.
    */
   struct  fs_locations_item4 {
           fs_locations_server4    fli_entries<>;
           pathname4               fli_rootpath;
   };

   /*
    * Defines the overall structure of
    * the fs_locations_info attribute.
    */
   struct  fs_locations_info4 {
           uint32_t                fli_flags;
           int32_t                 fli_valid_for;
           pathname4               fli_fs_root;
           fs_locations_item4      fli_items<>;
   };

   /*
    * Flag bits in fli_flags.
    */
   const FSLI4IF_VAR_SUB           = 0x00000001;

   typedef fs_locations_info4 fattr4_fs_locations_info;
```

위에서 언급한 대로 fs\_locations\_info 속성은 지원되는 경우 NFS4ERR\_MOVED가 반환되지 않고 없는 파일 시스템에 대해 요청할 수 있습니다. 일반적으로 현재\(현재\) 파일 시스템을 지정하는 fs\_locations\_server4 항목이 하나만 있거나 존재하지 않는 파일 시스템의 이전 위치를 지정하는 두 개의 fs\_locations\_server4 항목\( 방금 참조한 항목\) 및 후속 위치입니다. 서버는 모든 파일 시스템에서 이 속성을 지원하는 경우 모든 파일 시스템에서 이 속성을 지원할 것을 강력히 권장합니다.

fs\_locations\_info 속성에 표시된 데이터는 관리자가 지정하거나 아직 개발되지 않은 복제본과 프로토콜 간에 데이터를 전송하기 위한 현재 프로토콜을 포함하여 다양한 방법으로 서버에서 얻을 수 있습니다. NFSv4.1은 이 정보가 서버에서 클라이언트에 표시되는 방식만 정의합니다.

---
#### **11.17.1.  The fs_locations_server4 Structure**

fs\_locations\_server4 구조는 지정된 파일 시스템에 액세스하는 데 사용되는 네트워크 주소 또는 주소 집합을 지정하는 fls\_server 필드 외에 다음 항목으로 구성됩니다. 이 두 항목\(예: fls\_currency 및 fls\_info\)은 모두 파일 시스템 복제본의 속성을 지정하며 동일한 복제본에 대해 선택한 복제본에 대한 네트워크 경로를 각각 지정하는 여러 fs\_locations\_server4 구조가 있는 경우 달라서는 안 됩니다.

두 개의 fs\_locations\_server4 구조에서 이러한 값이 다른 경우 클라이언트는 하나를 다른 것보다 선택할 기준이 없으며 이러한 항목이 마이그레이션 복제 또는 참조에 적용되는지 여부에 관계없이 두 항목을 모두 무시하는 것이 가장 좋습니다. 그러한 항목이 2개 이상인 경우 다수결 투표를 사용하여 하나의 잘못된 항목을 고려 대상에서 제외할 수 있습니다. 현재 접속 중인 복제본에 대한 트렁킹 정보가 제공되는 경우, 해당 경로에 해당하는 항목이 유효하지 않은 것으로 간주되더라도 현재 사용 중인 주소에 대한 접속이 계속되는 동안 추가 트렁킹된 주소는 무시될 수 있습니다.

\* 파일 시스템의 최신 상태\(fls\_currency\)를 초 단위로 표시합니다. 이 값은 마스터 복사본을 기준으로 합니다. 음수 값은 서버가 여기서 합리적으로 유용한 값을 제공할 수 없음을 나타냅니다. 0 값은 파일 시스템이 실제로 쓰기 가능한 데이터이거나 안정적으로 일관되고 완전히 최신 복사본임을 나타냅니다. 양수 값은 이 복사본이 업데이트를 고려하기 전에 일반적으로 얼마나 오래되었는지 나타냅니다. 이러한 값은 해당 업데이트가 항상 필요한 일정에 따라 수행된다는 것을 보장하지 않지만 대신 데이터 복사본이 최신 복사본보다 얼마나 뒤쳐질 것으로 예상되는지에 대한 힌트 역할을 합니다.

\* 다음을 포함하는 1바이트 값\(fls\_info\)의 계산된 배열

- 특정 파일 시스템 인스턴스에 대한 정보. 이 데이터에는 일반 플래그, 전송 기능 플래그, 파일 시스템 동등 클래스 정보 및 선택 우선순위 정보가 포함됩니다. 인코딩에 대해서는 아래에서 설명하겠습니다.

\* 서버 문자열\(fls\_server\). 현재 \(GETATTR을 통해\) 액세스 중인 복제본의 경우 길이가 0인 문자열을 사용하여 RPC 호출에 사용되는 현재 주소를 나타낼 수 있습니다. fls\_server 필드는 fs\_location4 데이터 유형의 "서버" 필드에 있는 IPv4 또는 IPv6 주소와 동일한 방식으로 형식화된 IPv4 또는 IPv6 주소일 수도 있습니다\(섹션 11.16 참조\).\(MAY\)

Transport-flag 필드\(fls\_info 배열의 오프셋 FSLI4BX\_TFLAGS에 있음\)를 제외하고, 이 사양에 정의된 이 모든 데이터는 항목에 액세스하는 데 사용되는 특정 네트워크 경로가 아니라 항목에서 지정한 복제본에 적용됩니다. 이 데이터에 대한 확장의 데이터 분류는 아래에 설명되어 있습니다.

fls\_info 배열 내의 데이터는 이 특정 파일 시스템 인스턴스를 설명하는 다양한 값의 배열 내에서 오프셋을 제공하는 상수가 있는 8비트 데이터 항목 형식입니다. 여러 가지 이유로 이러한 값에 대한 명시적인 XDR 구조 정의보다 이러한 정의 스타일이 선택되었습니다.

\* 동일한 데이터를 나타내는 파일 시스템 집합 간의 플래그, 파일 시스템 클래스 및 우선 순위를 나타내는 fls\_info 배열의 데이터 종류는 8비트가 상당히 허용 가능한 값 범위를 제공합니다. 그러한 파일 시스템 인스턴스가 256개 이상 있을 수 있는 경우에도 256개 이상의 개별 클래스 또는 우선 순위를 가질 가능성은 거의 없습니다.

\* XDR 내의 다양한 특정 데이터 항목에 대한 명시적인 정의는 내부의 모든 확장이 또 다른 속성을 요구하므로 사양 및 구현이 서투르게 된다는 점에서 확장성을 제한합니다. fs\_locations\_info가 설계되었을 때 유효한 NFSv4 확장 모델\(즉, RFC 5661 \[66\]에 설명된 모델\)의 맥락에서 fls\_info의 데이터에 대한 표준 추적 확장을 적용하려면 새로운 마이너 버전이 필요합니다.

fls\_info 데이터 세트는 향후 부 버전이나 단일 부 버전의 컨텍스트 내 표준 트랙 RFC에서 확장될 수 있습니다. 서버는 전송해서는 안 되며 클라이언트는 표준 트랙 RFC에 정의되지 않은 fls\_info 배열 또는 플래그 비트 내의 인덱스를 사용해서는 안 됩니다.\(MUST NOT\)

RFC 8178 \[67\]에 정의된 새로운 확장 모델과 fls\_info 내의 개별 항목이 XDR에서 명시적으로 참조되지 않는다는 사실을 고려하여 fls\_info에 반환된 데이터 구조를 확장하거나 변경할 때 다음 관행을 따라야 합니다. 단일 마이너 버전의 범위 내에서:

\* 모든 확장은 표준 추적 문서에 설명되어 있어야 합니다. 그러한 문서에 RFC 5661 \[66\] 또는 이 문서를 업데이트한 것으로 표시할 필요는 없습니다.

\* 추가된 데이터 항목의 정보가 항목에 지정된 복제본에 적용되는지 아니면 항목에 지정된 특정 네트워크 경로에 적용되는지 명확하게 해야 합니다.

\* 서버가 확장 프로그램을 인식하는지 여부를 확인하는 신뢰할 수 있는 방법이 정의되어 있어야 합니다. 이는 fls\_info 배열의 길이 필드를 기반으로 할 수 있지만 어떤 확장이 제공되는지 나타내기 위해 fs 범위 또는 서버 범위 속성을 제공하는 것이 더 유연합니다.

이 인코딩 체계는 현재 정의된 값이 없더라도 멀티바이트 숫자 값 사양에 맞게 조정할 수 있습니다. 표준 트랙 RFC를 통해 확장이 이루어진 경우 멀티바이트 수량은 인덱스 범위가 포함된 바이트 범위로 인코딩되며 바이트는 빅엔디안 바이트 순서로 해석됩니다. 또한, 그러한 색인 할당은 XDR 단어 경계를 넘지 않는 관련 수량에 대한 필요성에 의해 제한됩니다.

fls\_info 배열에는 현재 다음이 포함됩니다.

\* 두 개의 8비트 플래그 필드\(하나는 일반 파일 시스템 전용\)

- 특성과 두 번째는 전송 관련 기능을 위해 예약되어 있습니다.

\* 아래 설명과 같이 다양한 파일 시스템 동등 클래스를 정의하는 6개의 8비트 클래스 값입니다.

\* 아래에 설명된 대로 파일 시스템 선택을 제어하는 ​​4개의 8비트 우선 순위 값입니다.

일반 파일 시스템 특성 플래그\(바이트 인덱스 FSLI4BX\_GFLAGS\)에는 다음 비트가 정의되어 있습니다.

\* FSLI4GF\_WRITABLE은 이 파일 시스템 대상이 쓰기 가능하므로 이 파일 시스템에 써야 할 수도 있는 클라이언트가 선택할 수 있음을 나타냅니다. 현재 파일 시스템 인스턴스가 쓰기 가능하고 클라이언트가 이전에 쓰고 있던 동일한 동시 사용 클래스\(FSLI4BX\_CLSIMUL 인덱스의 값으로 지정됨\)로 정의된 경우 소스에서 수행된 모든 커밋된 쓰기를 해당 데이터 내에 통합해야 합니다. 파일 시스템 인스턴스. 쓰기 검증자 클래스에 대해 설명하는 섹션 11.11.6을 참조하세요. 쓰기 가능한 것으로 판명된 파일 시스템에 대해 이 플래그를 설정하지 않아도 문제가 없지만 읽기 전용 파일 시스템에 대해 플래그를 설정하면 플래그를 기반으로 마이그레이션 또는 복제 대상을 선택한 클라이언트에 문제가 발생할 수 있습니다. 글을 쓸 수 없다는 것을 알게 됩니다.

\* FSLI4GF\_CUR\_REQ는 이 복제본이 요청이 이루어지는 복제본임을 나타냅니다. 단일 서버 항목에만 이 플래그가 설정될 수 있으며 추천의 경우 어떤 항목에도 이 플래그가 설정되지 않습니다. 현재 항목에 지정된 경로와 다른 네트워크 액세스 경로에서 요청이 이루어진 경우에도 이 플래그가 설정될 수 있습니다.

\* FSLI4GF\_ABSENT는 이 항목이 파일 시스템 복제본이 없음을 나타냅니다. FSLI4GF\_CUR\_REQ가 설정된 경우에만 설정할 수 있습니다. 두 비트가 모두 설정되면 파일 시스템 인스턴스를 사용할 수 없지만 항목의 정보를 사용하여 이 복제본에서 다른 가능한 복제본으로 전환할 때 사용할 수 있는 연속성의 종류를 결정할 수 있음을 나타냅니다. 이 비트는 FSLI4GF\_CUR\_REQ가 true인 경우에만 true일 수 있으므로 fs\_status 속성을 사용하여 값을 결정할 수 있지만 클라이언트의 편의를 위해 여기에서 정보도 사용할 수 있습니다. 이 비트가 있는 항목은 실제 파일 시스템\(비록 없음\)을 나타내기 때문에 참조 시에는 표시되지 않고 이 위치에서 파일 시스템에 액세스한 후 마이그레이션된 경우에만 표시됩니다.

\* FSLI4GF\_GOING은 복제본이 아직 사용 가능하지만 더 이상 사용해서는 안 됨을 나타냅니다. 클라이언트는 이를 사용하는 경우 가능한 한 신속하게 다른 파일 시스템 인스턴스로 순서대로 전송해야 합니다. 서비스가 중단되는 파일 시스템은 실제 서비스가 중단되기 얼마 전에 FSLI4GF\_GOING으로 발표될 것으로 예상됩니다. 또한 fli\_valid\_for 값은 클라이언트가 예약된 이벤트를 감지하고 조치를 취할 수 있을 만큼 충분히 작은 동시에 fs\_locations\_info 값을 가져오기 위한 요청 비용이 과도하지 않을 만큼 충분히 클 것으로 예상됩니다. 10분 정도의 값이 합리적으로 보입니다.

- 이 플래그가 새 파일 시스템으로의 전환의 일부로 표시되면 클라이언트는 즉시 다른 복제본으로 전송하도록 선택하거나 현재 파일 시스템을 참조하고 마이그레이션 이벤트가 발생할 때만 전환할 수 있습니다. 마찬가지로 이 플래그가 참조에서 복제본으로 나타나면 클라이언트는 다른 선택이 있을 때마다 이 인스턴스를 참조하지 않을 가능성이 높습니다.

- fls\_info 내의 다른 항목과 마찬가지로 이 플래그는 해당 복제본에 대한 특정 경로가 아닌 복제본에 적용됩니다. 이 메시지가 나타나면 동일한 복제본에 대한 다른 경로가 아닌 새 복제본으로의 전환이 표시됩니다.

\* FSLI4GF\_SPLIT는 현재 파일 시스템 인스턴스에서 이 인스턴스로 전환이 발생할 때 교체가 여러 파일 시스템으로 구성될 수 있음을 나타냅니다. 이 경우 클라이언트는 마이그레이션 전 동일한 파일 시스템의 개체가 나중에 다른 개체에 있을 가능성에 대비해야 합니다. FSLI4GF\_SPLIT는 동일한 파일 ID 클래스에 속하는 파일 시스템과 호환되지 않습니다. 파일 시스템 내에서 고유한 파일 ID 세트가 있는 경우 마이그레이션 후 더 작은 파일 시스템에 할당된 각 하위 세트는 내부적으로 충돌이 발생하지 않기 때문입니다. 그 파일 시스템.

- 분할 파일 시스템의 경우 클라이언트는 계속 연결되어 있는 기존 파일을 조사합니다\(캐시된 파일 핸들을 잊어버릴 수도 있습니다\). 클라이언트가 열려 있는 각 파일과 연관된 디렉토리 파일 핸들을 기억하는 경우 LOOKUPP를 사용하여 위쪽으로 계속 진행하여 새 파일 시스템 경계를 찾을 수 있습니다. 추천이 발생하는 경우 해당 파일이 없으므로 해당 작업이 수행되지 않습니다. 대신, 이제 다른 파일 시스템으로 분할된 원본 파일 시스템의 일부에 대한 참조에서 fsid 변경이 발생하고 추가 참조가 발생할 수 있습니다.

- 클라이언트가 하나의 파일 시스템이 두 개로 분할되었음을 인식하면, 재시작과 같이 전환을 인식하기 편리한 지점까지 두 개의 파일 시스템을 단일 파일 시스템으로 제시하여 실행 중인 애플리케이션이 중단되는 것을 방지할 수 있습니다. 이를 위해서는 서버의 fsid를 클라이언트가 볼 수 있는 fsid로 매핑해야 하지만 다른 이유로 인해 이미 필요합니다. 위에서 언급한 것처럼 두 하위 파일 시스템 내의 기존 파일 ID는 충돌하지 않습니다. 분할 파일 시스템에서 새로 생성된 파일에 대해 충돌하지 않는 파일 ID를 제공하는 것은 서버\(또는 함께 작동하는 서버\)의 책임입니다. 서버는 분할 이벤트 전에 생성된 파일 핸들을 분할 후에 생성된 파일 핸들과 식별할 수 있도록 파일 핸들을 인코딩할 수 있으므로 서버는 두 개의 파일 시스템을 하나로 에뮬레이트해야 하는 필요성이 끝나는 시기를 결정할 수 있습니다.

- 추천 시 이 플래그가 존재할 수 있지만 일반적으로 클라이언트에게는 별 관심이 없습니다. 클라이언트는 부재 파일 시스템의 현재 내용에 관한 정보를 갖고 있을 것으로 예상되지 않기 때문입니다.

전송 플래그 필드\(바이트 인덱스 FSLI4BX\_TFLAGS\)에는 항목에 지정된 특정 네트워크 경로의 전송 기능과 관련된 다음 비트가 포함됩니다.

\* FSLI4TF\_RDMA는 지정된 네트워크 경로가 RDMA 지원 전송을 사용하여 NFSv4.1 클라이언트 액세스를 제공한다는 것을 나타냅니다.

속성 연속성과 파일 시스템 ID 정보는 클라이언트에 제시된 파일 시스템 세트에 대한 동등 관계를 정의하여 표현됩니다. 이러한 각 관계는 파일 시스템 등가 클래스 집합으로 표현됩니다. 각 관계에 대해 파일 시스템은 8비트 클래스 번호를 갖습니다. 두 파일 시스템 모두 0이 아닌 동일한 클래스 번호를 갖는 경우 동일한 클래스에 속합니다. 0은 일치하지 않는 것으로 처리됩니다. 대부분의 경우 클라이언트에 대한 관련 질문은 주어진 복제본이 특정 측면에서 현재 복제본과 동일/연속적인지 여부이지만, 해당 측면에서 다른 두 복제본도 일치하는지 여부에 대한 정보도 제공되어야 합니다.

다음 필드는 파일 시스템 전환의 특성을 결정하는 데 사용되는 동등 관계에 대한 파일 시스템의 클래스 번호를 지정합니다. 이 정보가 어떻게 사용되는지에 대한 자세한 내용은 섹션 11.9부터 11.14까지와 다양한 하위 섹션을 참조하세요. 동일한 값을 공유하는 파일 시스템 인스턴스가 서로 지정된 관계를 갖는 한 서버는 원하는 대로 이러한 값을 할당할 수 있습니다. 반대로, 서로 지정된 관계를 갖는 파일 시스템은 공통 클래스 값을 공유합니다. 각 인스턴스 항목이 추가됨에 따라 이전에 입력된 인스턴스에 대한 이 인스턴스의 관계를 참조할 수 있으며 지정된 관계를 포함하는 항목이 발견되면 해당 항목의 클래스 값을 새 항목에 복사할 수 있습니다. 그러한 이전 항목이 존재하지 않는 경우 해당 바이트 인덱스\(이전에 사용되지 않은\)에 대한 새 값을 선택할 수 있으며, 이는 해당 인덱스에 할당된 마지막 클래스 값의 값을 증가시키는 방식일 가능성이 높습니다.

\* 바이트 인덱스 FSLI4BX\_CLSIMUL이 있는 필드는

- 파일 시스템에 대한 동시 사용 클래스입니다.

\* 바이트 인덱스 FSLI4BX\_CLHANDLE이 있는 필드는 파일 시스템의 핸들 클래스를 정의합니다.

\* 바이트 인덱스 FSLI4BX\_CLFILEID가 있는 필드는 파일 시스템의 fileid 클래스를 정의합니다.

\* 바이트 인덱스 FSLI4BX\_CLWRITEVER가 있는 필드는 파일 시스템에 대한 쓰기 검증자 클래스를 정의합니다.

\* 바이트 인덱스 FSLI4BX\_CLCHANGE가 있는 필드는 파일 시스템에 대한 변경 클래스를 정의합니다.

\* 바이트 인덱스 FSLI4BX\_CLREADDIR이 있는 필드는 파일 시스템에 대한 readdir 클래스를 정의합니다.

서버가 지정한 기본 설정 정보도 fls\_info 배열 내의 8비트 값을 통해 제공됩니다. 값은 읽기 전용 및 쓰기 가능한 파일 시스템의 경우 지정할 수 있는 별도의 값과 함께 사용되는 순위 및 순서\(아래 참조\)를 제공합니다. 이러한 값은 서버 지정 기본 설정을 설정하기 위해 다양한 파일 시스템에 대해 비교되며, 값이 낮을수록 "더 선호됨"을 나타냅니다.

순위는 클라이언트에 대해 서버가 부과하는 엄격한 순서를 표현하는 데 사용되며, 값이 낮을수록 "더 선호됨"을 나타냅니다. 클라이언트는 더 높은 순위의 복제본을 사용하기 전에 주어진 순위의 모든 복제본을 사용하도록 시도해야 합니다. 해당 파일 시스템을 모두 사용할 수 없는 경우에만 클라이언트는 더 높은 순위의 파일 시스템으로 진행해야 합니다. 순위를 지정하면 클라이언트 기본 설정이 무시되므로 서버는 이 메커니즘을 사용하는 것에 대해 보수적이어야 합니다. 특히 클라이언트 통신 특성이 엄격하게 제어되지 않거나 서버에 표시되지 않는 환경인 경우에는 더욱 그렇습니다.

순위 내에서 순서 값은 클라이언트 자신의 기본 설정이 제어되지 않을 때 클라이언트의 선택을 안내하기 위해 서버의 기본 설정을 지정하는 데 사용되며, 순서 값이 낮을수록 "더 선호됨"을 나타냅니다. 복제본이 모든 측면에서 거의 동일한 경우 클라이언트는 서버가 지정한 순서를 따라야 합니다. 클라이언트가 선택의 일부로 서버 대기 시간을 고려할 때 이 기준을 자유롭게 사용할 수 있지만 대기 시간 차이가 크지 않은 경우 서버에서 지정한 순서에 따라 선택하는 것이 좋습니다.

\* 바이트 인덱스 FSLI4BX\_READRANK의 필드는 읽기 전용 액세스에 사용할 순위 값을 제공합니다.

\* 바이트 인덱스 FSLI4BX\_READORDER의 필드는 읽기 전용 액세스에 사용되는 순서 값을 제공합니다.

\* 바이트 인덱스 FSLI4BX\_WRITERANK의 필드는 쓰기 가능한 액세스에 사용되는 순위 값을 제공합니다.

\* 바이트 인덱스 FSLI4BX\_WRITEORDER의 필드는 쓰기 가능한 액세스에 사용될 순서 값을 제공합니다.

특정 클라이언트의 쓰기 액세스에 대한 잠재적 필요성에 따라 순위 및 순서 값 쌍 중 하나가 사용됩니다. 읽기 순위 및 순서는 클라이언트가 읽기만 수행된다는 것을 알고 있거나 나중에 쓰기 액세스 기능이 필요한 경우 다른 복제본으로 전환할 준비가 된 경우에만 사용해야 합니다.

---
#### **11.17.2.  The fs_locations_info4 Structure**

fs\_locations\_info 속성을 인코딩하는 fs\_locations\_info4 구조에는 다음이 포함됩니다.

\* fs\_locations\_info4 구조와 그 안에 있는 모든 fs\_locations\_item4 구조의 해석에 영향을 미치는 일반 플래그가 포함된 fli\_flags 필드. 현재 정의된 유일한 플래그는 FSLI4IF\_VAR\_SUB입니다. 정의되지 않은 fli\_flags 필드의 모든 비트는 항상 0으로 반환되어야 합니다.

\* fs\_locations4 구조에서와 마찬가지로 현재 서버에 있는 현재 파일 시스템의 루트 경로 이름을 포함하는 fli\_fs\_root 필드.

\* 현재 파일 시스템의 복제본에 대한 정보를 포함하는 fs\_locations4\_item 구조의 fli\_items라는 배열입니다. 현재 파일 시스템이 실제로 존재하거나 존재했던 경우, 즉 참조 상황이 아닌 경우 fs\_locations\_item4 구조 중 하나에는 현재 서버에 대한 fs\_locations\_server4가 포함됩니다. 현재 파일 시스템이 없는 경우 이 구조에는 FSLI4GF\_ABSENT가 설정됩니다. 즉, 해당 파일 시스템에 대한 일반적인 액세스는 NFS4ERR\_MOVED를 반환합니다.

\* fli\_valid\_for 필드는 클라이언트가 다시 가져오지 않고 fs\_locations\_info 속성을 사용하는 것이 합리적인 시간\(초\)을 지정합니다. fli\_valid\_for 값은 서버가 예기치 않게 서비스를 중단하거나 여러 가지 이유로 액세스할 수 없게 될 수 있으므로 유효성을 보장하지 않습니다. 클라이언트는 fli\_valid\_for 초마다 활발하게 액세스되는 파일 시스템에 대해 이 정보를 다시 가져오는 것이 좋습니다. 이는 진행 중인 변경 사항을 전달하기 위해 FSLI4GF\_GOING 플래그를 사용하여 제어된 방식으로 파일 시스템 복제본이 서비스를 중단할 수 있는 경우 특히 중요합니다. 서버는 선의로 행동하는 클라이언트가 FSLI4GF\_GOING 플래그를 확인하고 서비스 손실이 발생하기 전에 순서대로 전환할 수 있도록 fli\_valid\_for를 값으로 설정해야 합니다. 이 값이 0이면 다시 가져오기 간격이 적합하지 않으며 클라이언트는 특정 일정에 따라 이 데이터를 다시 가져올 필요가 없습니다. 새 파일 시스템 인스턴스로 전환하는 경우 fs\_locations\_info 속성의 새 값을 대상에서 가져옵니다. 이는 다른 fli\_valid\_for 값을 가질 수 있으며 클라이언트는 이전 값과 동일한 방식으로 사용해야 합니다. 속성을 다시 가져오면 모든 구성 요소 항목의 정보가 다시 가져오기 때문에 짧은 시간 내에 복제본이 서비스 중단될 가능성이 있는 경우 서버는 일반적으로 이 필드에 낮은 값을 제공합니다. 서버가 NFS4ERR\_MOVED를 반환하여 다른 경로의 사용을 트리거할 수 있기 때문에 대체 트렁크 경로를 사용할 수 있는 경우 일반적으로 동일한 경로에 대한 대체 경로 관리와 관련하여 fli\_valid\_for의 낮은 값을 사용할 필요가 없습니다. 레플리카.

fli\_flags 내의 FSLI4IF\_VAR\_SUB 플래그는 변수 대체 활성화 여부를 제어합니다. 변수 대체에 대한 설명은 섹션 11.17.3을 참조하십시오.

---
#### **11.17.3.  The fs_locations_item4 Structure**

fs\_locations\_item4 구조에는 포함된 fs\_locations\_server4 항목으로 지정된 서버 세트의 대상 파일 시스템 복제본의 경로를 인코딩하는 경로 이름\(fli\_rootpath 필드\)이 포함되어 있습니다. 이 대상 위치가 지정되는 정확한 방식은 연관된 fs\_locations\_info4 구조 내의 FSLI4IF\_VAR\_SUB 플래그 값에 따라 다릅니다.

이 플래그가 설정되지 않으면 fli\_rootpath는 fs\_location4 구조 내의 루트 경로에 대해 지정하는 것처럼 단순히 각 서버의 단일 서버 네임스페이스 내에서 대상 파일 시스템의 위치를 ​​지정합니다. 그러나 이 비트가 설정되면 클라이언트별 파일 시스템 대상 선택을 수용하기 위해 네임스페이스 불균일성을 허용하기 위해 특정 형식의 구성 요소 항목이 클라이언트별 변수 대체에 적용됩니다. 클라이언트 아키텍처 또는 기타 특성.

이러한 대체가 적용되는 경우 문자열 "${"로 시작하고 문자열 "}"로 끝나며 콜론을 포함하는 변수는 해당 변수와 연결된 클라이언트별 값으로 대체됩니다. "알 수 없음" 문자열은 해당 변수에 대한 값이 없을 때 클라이언트에서 사용해야 합니다. 이러한 대체 결과로 생성된 경로 이름은 대상 파일 시스템을 지정하는 데 사용되므로 서로 다른 클라이언트는 다중 서버 이름 공간의 해당 위치에 해당하는 서로 다른 파일 시스템을 가질 수 있습니다.

위에서 언급한 것처럼 대체된 경로 이름 변수에는 콜론이 포함됩니다. 콜론 앞 부분은 DNS 도메인 이름이고 뒤 부분은 대소문자를 구분하지 않는 영숫자 문자열입니다.

도메인이 "ietf.org"인 경우 이 문서 또는 후속 표준 트랙 RFC에 정의된 변수 이름만 대체될 수 있습니다. 조직은 도메인 이름을 사용하여 클라이언트별 변수 세트를 생성하고 그러한 대체 대상이 될 수 있습니다. 이러한 변수를 단일 조직보다 더 광범위하게 사용하려는 경우 해당 변수를 정의하는 정보용 RFC를 게시하는 것이 좋습니다.\(SHOULD\)

${ietf.org:CPU\_ARCH} 변수는 CPU 아키텍처 개체 파일이 컴파일되었음을 나타내는 데 사용됩니다. 이 사양은 허용되는 값을 제한하지 않습니다\(유효한 UTF-8 문자열이어야 한다는 점 제외\). 그러나 "x86", "x86\_64" 및 "sparc"와 같은 값은 업계 관행에 따라 사용될 것으로 예상됩니다.

${ietf.org:OS\_TYPE} 변수는 운영 체제, 즉 코드가 컴파일될 수 있는 커널 및 라이브러리 API를 나타내는 데 사용됩니다. 이 사양은 허용되는 값을 제한하지 않습니다\(유효한 UTF-8 문자열이어야 한다는 점 제외\). 그러나 "linux" 및 "freebsd"와 같은 값은 업계 관행에 따라 사용될 것으로 예상됩니다.

${ietf.org:OS\_VERSION} 변수는 운영 체제 버전을 나타내는 데 사용되므로 코드가 컴파일될 수 있는 버전이 지정된 인터페이스의 특정 세부 정보를 나타냅니다. 이 사양은 허용되는 값을 제한하지 않습니다\(유효한 UTF-8 문자열이어야 한다는 점 제외\). 그러나 점이 산재된 숫자와 문자의 조합은 업계 관행에 따라 사용될 것으로 예상되며 버전 형식의 세부 사항은 사용되는 변수 ${ietf.org:OS\_TYPE}의 특정 값에 따라 다릅니다. .

이러한 변수를 사용하면 특정 클라이언트에 따라 다른 클라이언트가 동일한 서버의 다른 파일 시스템으로 방향이 지정될 수 있습니다. 대상 파일 시스템이 서로 다른 서버에 있는 경우 단일 서버가 참조 지점 역할을 할 수 있으므로 변수 값의 각 유효한 조합은 단일 서버에서 호스팅되는 참조를 지정하고 해당 참조 대상은 번호에 따라 지정됩니다. 다양한 서버의

네임스페이스 관리는 다양한 변수를 대체하기 위해 선택된 값의 영향을 받기 때문에 클라이언트는 클라이언트가 구현할 변수 대체를 결정하는 편리한 수단을 제공해야 할 뿐만 아니라 적절한 경우 사용할 대체를 제어할 수 있는 수단도 제공해야 합니다. 이를 수행하는 정확한 수단은 이 사양의 범위를 벗어납니다.

변수 대체는 참조 컨텍스트에서 사용하기에 가장 적합하지만 복제 및 마이그레이션 컨텍스트에서도 사용될 수 있습니다. 이러한 컨텍스트에서 사용되는 경우 서버는 클라이언트가 대체 변수에 대해 어떤 값을 제공하든 결과가 항상 전환이 발생하는 인스턴스에 대한 유효한 후속 파일 시스템 인스턴스인지 확인해야 합니다. 즉, 데이터가 다음과 같습니다. 동일하거나 쓰기 가능한 파일 시스템의 최신 이미지를 나타냅니다.

fli\_rootpath가 null 경로 이름\(즉, 구성 요소가 없는 경로 이름\)인 경우 연결된 fs\_locations\_info4 구조 내의 FSLI4IF\_VAR\_SUB 플래그 설정 여부에 관계없이 지정된 파일 시스템은 지정된 서버의 루트에 있습니다.

---
### **11.18.  The Attribute fs_status**

동일한 기본 데이터 세트의 여러 복사본을 사용할 수 있는 환경에서 해당 데이터의 특정 소스 및 여러 복사본 간의 관계에 관한 정보는 애플리케이션에 일관된 데이터를 제공하는 데 매우 도움이 될 수 있습니다.

```text
   enum fs4_status_type {
           STATUS4_FIXED = 1,
           STATUS4_UPDATED = 2,
           STATUS4_VERSIONED = 3,
           STATUS4_WRITABLE = 4,
           STATUS4_REFERRAL = 5
   };

   struct fs4_status {
           bool            fss_absent;
           fs4_status_type fss_type;
           utf8str_cs      fss_source;
           utf8str_cs      fss_current;
           int32_t         fss_age;
           nfstime4        fss_version;
   };
```

부울 fss\_absent는 파일 시스템이 현재 없는지 여부를 나타냅니다. 파일 시스템이 이전에 존재했다가 없어진 경우 또는 파일 시스템이 존재한 적이 없고 유형이 STATUS4\_REFERRAL인 경우 이 값이 설정됩니다. 이 부울이 설정되고 유형이 STATUS4\_REFERRAL이 아닌 경우 fs4\_status의 나머지 정보는 파일 시스템이 존재했을 때 마지막으로 유효했던 정보를 반영합니다.

fss\_type 필드는 표시되는 파일 시스템 이미지의 종류를 나타냅니다. 이는 버전 값을 사용하여 파일 시스템 이미지의 적절한 연속을 결정할 때 특히 중요합니다. fss\_absent가 설정되고 파일 시스템이 이전에 존재했다면 반영된 fss\_type 값은 파일이 마지막으로 존재했을 때의 값입니다. 다섯 가지 가치가 구별됩니다.

\* STATUS4\_FIXED는 절대 변경되지 않는다는 의미에서 읽기 전용 이미지를 나타냅니다. 마이그레이션 또는 다른 이미지로의 전환으로 인해 변경된 데이터에 액세스할 수 있지만 이 인스턴스 범위 내에서는 변경이 허용되지 않습니다. 클라이언트는 이 사실을 사용하여 적극적으로 캐시할 수 있습니다.

\* STATUS4\_VERSIONED, 이는 STATUS4\_UPDATED 사례와 같이 이미지가 외부적으로 업데이트되지만 클라이언트가 데이터를 읽는 상황에서 클라이언트가 스스로를 보호할 수 있도록 서버가 관련 버전 값을 신중하게 업데이트한다는 보장을 제공합니다. 버전의 파일 시스템을 읽고 나중에 동일한 파일 시스템의 이전 버전에서 데이터를 읽습니다. 이 작업을 수행하는 방법에 대한 설명은 아래를 참조하세요.

\* STATUS4\_UPDATED는 사용자가 작성하여 업데이트할 수 없지만 외부적으로는 변경될 수 있는 이미지를 나타냅니다. 일반적으로 다른 쓰기 가능한 파일 시스템의 주기적으로 업데이트되는 복사본이기 때문입니다. 이 경우 버전 정보는 제공되지 않으며 클라이언트는 파일 시스템 인스턴스 전환 시에만 이 버전이 발전하는지 확인할 책임이 없습니다. 이 경우 파일 시스템 인스턴스 전환 후에 표시되는 데이터가 적절한 후속 이미지인지 확인하고 클라이언트에 표시되는 모든 변경 사항과 이러한 변경 이전에 발생한 모든 변경 사항을 포함하는지 확인하는 것은 서버의 책임입니다.

\* STATUS4\_WRITABLE은 파일 시스템이 실제로 쓰기 가능한 시스템임을 나타냅니다. 물론 클라이언트는 실제로 파일 시스템에 쓸 필요는 없지만 일단 쓰고 나면 동일한 파일 시스템의 쓰기 가능한 인스턴스 이외의 다른 것으로의 전환을 허용해서는 안 됩니다.

\* STATUS4\_REFERRAL은 문제의 파일 시스템이 없고 이 서버에 존재한 적이 없음을 나타냅니다.

STATUS4\_UPDATED 및 STATUS4\_VERSIONED 경우 서버는 위임에 대한 외부 변경 사항과 일치하지 않는 잠금을 적절하게 처리해야 합니다. 서버가 위임을 제공하는 경우 데이터에 일관되지 않은 변경이 발생하기 전에 이를 회수해야 하며 이것이 가능하지 않은 경우 취소해야 합니다. 마찬가지로 OPEN이 변경된 데이터와 일치하지 않는 경우\(OPEN에 OPEN4\_SHARE\_DENY\_WRITE/OPEN4\_SHARE\_DENY\_BOTH가 있고 데이터가 변경됨\) 해당 OPEN은 관리상 취소된 것으로 간주되어야 합니다.\(MUST, SHOULD\)

불투명 문자열 fss\_source 및 fss\_current는 존재하는 파일 시스템 이미지의 소스에 대한 정보를 표시하는 방법을 제공합니다. 클라이언트는 이 정보를 관리 도구에 제공하는 것 외에 다른 작업을 수행할 의도가 없습니다. 이 정보는 올바른 이미지에 액세스하고 있는지, 그렇지 않은 경우 해당 이미지가 어떻게 만들어졌는지 확실하지 않을 때 발생할 수 있는 파일 시스템 이미지 관련 문제를 조사할 때 도움이 되도록 만들어졌습니다. 이러한 종류의 진단 정보는 파일 시스템의 복사본이 다양한 방식으로 생성되는 경우\(예: 간단한 사용자 수준 복사본, 파일 시스템 수준 특정 시점 복사본, 기본 복사본의 복사본\) 도움이 될 것입니다. 보관\), 다양한 관리 조치에 따라. 이러한 환경에서는 주어진 데이터 세트가 어떻게 구성되었는지 확인하는 것이 문제 해결에 매우 도움이 될 수 있습니다.

불투명 문자열 fss\_source는 파일 시스템 이미지를 생성할 수 있는 도구가 가능한 경우 이 정보를 전파할 것으로 기대하면서 특정 파일 시스템의 소스를 나타내는 데 사용됩니다. 사용자 수준 복사본은 새로운 데이터 세트를 생성하는 것으로 간주될 수 있고 사용된 도구에는 이 데이터를 전파하는 메커니즘이 없기 때문에 이것이 항상 가능하지는 않을 수도 있다는 점을 이해합니다. 파일 시스템이 처음 생성될 때 파일 시스템이 생성된 방법, 생성 위치, 생성자 등에 관한 데이터를 연결하는 것이 바람직합니다. 이 정보를 사람이 읽을 수 있는 문자열로 이 속성에서 사용할 수 있게 만드는 것은 응용 프로그램 및 시스템 관리자에게 도움이 되며 원본 파일 시스템을 사용하여 후속 복사본을 만들 때 사용할 수 있도록 하는 역할도 합니다.

불투명 문자열 fss\_current는 현재 복사본의 소스에 대해 사용 가능한 모든 정보를 제공해야 합니다. 이러한 정보에는 이를 생성하는 도구, 해당 도구에 대한 관련 매개변수, 복사가 완료된 시간, 변경을 수행한 사용자, 변경이 수행된 서버 등이 포함됩니다. 모든 정보는 사람이 읽을 수 있는 형식이어야 합니다. 끈.

fss\_age 필드는 최종 데이터 소스와 관련하여 파일 시스템이 현재 얼마나 오래되었는지 표시합니다\(계단식 데이터 업데이트의 경우\). 이는 다음과 같은 방식으로 fs\_locations\_server4의 fls\_currency 필드\(11.17절 참조\)를 보완합니다. fls\_currency의 정보는 파일 시스템의 데이터가 일반적으로 얼마나 오래되었는지에 대한 한계를 제공하는 반면, fss\_age의 값은 얼마나 오래되었는지에 대한 한계를 제공합니다. -데이터가 실제 날짜입니다. 음수 값은 사용 가능한 정보가 없음을 의미합니다. 0은 이 데이터가 현재 유효한 것으로 알려져 있음을 의미합니다. 양수 값은 이 데이터가 최종 데이터 소스와 관련하여 해당 시간\(초\)보다 오래되지 않은 것으로 알려져 있음을 의미합니다. 이 값을 사용하면 클라이언트는 데이터 복사본이 너무 오래되었다고 판단하여 사용할 최신 버전을 검색할 수 있습니다.

fss\_version 필드는 연속 버전이 항상 이후의 시간 값을 갖도록 시간 값 형식으로 버전 식별을 제공합니다. fs\_type이 STATUS4\_VERSIONED가 아닌 경우 서버는 해당 값을 제공할 수 있지만 유효성에 대한 보장은 없으며 클라이언트는 fss\_source 및 fss\_current에 추가할 추가 정보를 제공하는 경우를 제외하고는 이를 사용하지 않습니다.

fss\_type이 STATUS4\_VERSIONED인 경우 서버는 데이터의 새 버전이 설정될 때마다 단조롭게 진행되는 fss\_version 값을 제공해야 합니다. 이를 통해 클라이언트는 안정적인 이미지 진행이 중요한 경우 파일 시스템의 데이터 또는 메타데이터가 사용되는 각 COMPOUND의 일부로 이 속성을 가져올 수 있습니다.\(SHOULD\)

클라이언트가 유효한 후속 이미지만 허용하는지 확인하는 것이 중요한 경우 이미지의 현재 상태에 대한 감각을 업데이트하지 않고 파일 시스템에서 데이터나 메타데이터를 읽지 않도록 해야 합니다. 이는 클라이언트가 보유하는 fs\_status가 이전 이미지에 대한 상태일 가능성을 방지하기 위한 것입니다. 이로 인해 클라이언트는 그 이후이지만 클라이언트가 읽은 업데이트된 데이터보다 여전히 이전인 새 파일 시스템 인스턴스를 수락하게 됩니다.

유효한 이미지를 안정적으로 승인하려면 클라이언트는 문제의 파일 시스템 내에서 데이터 또는 메타데이터에 대한 조사를 따르는 fs\_status 속성의 GETATTR을 수행해야 합니다. 종종 이는 지정된 파일 시스템을 참조하는 다른 모든 작업 뒤에 이러한 GETATTR을 추가하여 가장 편리하게 수행됩니다. 파일 시스템 데이터 읽기와 GETATTR 수행 사이에 오류가 발생하면 적절한 fs\_status 값을 얻기 전에 문제의 데이터가 사용되지 않도록 주의해야 합니다. 이와 관련하여 버전이 지정된 파일 시스템 내에서 OPEN이 수행되고 fs\_status의 관련 GETATTR이 성공적으로 완료되지 않은 경우 해당 fs\_status를 가져올 때까지 문제의 열린 파일에 액세스해서는 안 됩니다.

위의 절차는 파일 시스템의 데이터를 사용하기 전에 클라이언트가 새로 가져온 현재 버전의 파일 시스템 이미지를 보유하고 있는지 확인합니다. 진행 중인 여러 요청에 대한 여러 값은 필요한 부분 순서로 조합하고\(요소는 부분 순서 내에서 전체 순서를 형성해야 함\) 마지막 값을 사용하여 해결할 수 있습니다. 그러면 클라이언트는 파일 시스템 인스턴스 간에 전환할 때 fss\_type이 STATUS4\_VERSIONED가 아니거나 fss\_version 필드가 이전 파일 시스템 인스턴스에서 얻은 마지막 필드보다 이전인 인스턴스 사용을 거부할 수 있습니다.

---
## **12.  Parallel NFS (pNFS)**
---
### **12.1.  Introduction**

pNFS는 NFSv4.1의 선택적 기능입니다. pNFS 기능 세트를 사용하면 클라이언트가 파일 데이터가 포함된 저장 장치에 직접 액세스할 수 있습니다. 단일 NFSv4 서버의 파일 데이터가 여러 및/또는 더 높은 처리량의 스토리지 장치에 저장되면\(서버의 처리량 기능과 비교하여\) 파일 액세스 성능이 훨씬 향상될 수 있습니다. 여러 클라이언트, 단일 서버 및 pNFS용 여러 스토리지 장치\(서버와 클라이언트는 모든 스토리지 장치에 액세스할 수 있음\) 간의 관계가 그림 1에 나와 있습니다.\(MAY\)

```text
       +-----------+
       |+-----------+                                 +-----------+
       ||+-----------+                                |           |
       |||           |        NFSv4.1 + pNFS          |           |
       +||  Clients  |<------------------------------>|   Server  |
        +|           |                                |           |
         +-----------+                                |           |
              |||                                     +-----------+
              |||                                           |
              |||                                           |
              ||| Storage        +-----------+              |
              ||| Protocol       |+-----------+             |
              ||+----------------||+-----------+  Control   |
              |+-----------------|||           |    Protocol|
              +------------------+||  Storage  |------------+
                                  +|  Devices  |
                                   +-----------+

                                  Figure 1
```

이 모델에서는 클라이언트, 서버 및 저장 장치가 파일 액세스 관리를 담당합니다. 이는 주로 서버의 책임인 pNFS가 없는 NFSv4와 대조됩니다. 이 책임 중 일부는 엄격하게 지정된 조건에 따라 고객에게 위임될 수 있습니다. 스토리지 프로토콜에 대한 설명은 섹션 12.2.5를 참조하세요. 제어 프로토콜에 대한 논의는 섹션 12.2.6을 참조하십시오.

pNFS는 바이트 범위 및 저장 위치 정보를 포함하는 '레이아웃'\(섹션 12.2.7\)이라는 프로토콜 개체를 관리하는 선택적 작업의 형태를 취합니다. 레이아웃은 NFSv4.1 데이터 위임과 유사한 방식으로 관리됩니다. 예를 들어 레이아웃은 임대, 회수 가능 및 취소 가능합니다. 그러나 레이아웃은 별개의 추상화이며 새로운 작업으로 조작됩니다. 클라이언트가 레이아웃을 보유하면 레이아웃에 지정된 저장 위치의 바이트 범위에 직접 액세스할 수 있는 기능이 부여됩니다.\(MAY\)

레이아웃과 데이터 위임 및 바이트 범위 잠금과 같은 기타 NFSv4.1 추상화 간에 상호 작용이 있습니다. 위임 문제는 섹션 12.5.5에서 논의됩니다. 바이트 범위 잠금 문제는 섹션 12.2.9 및 12.5.1에서 논의됩니다.

---
### **12.2.  pNFS Definitions**

NFSv4.1의 pNFS 기능은 여러 스토리지 서버에 콘텐츠를 스트라이핑하는 파일 시스템에 대한 병렬 데이터 액세스를 제공합니다. NFSv4.1의 일부인 pNFS의 첫 번째 인스턴스화는 파일 시스템 프로토콜 처리를 메타데이터 처리와 데이터 처리라는 두 부분으로 분리합니다. 데이터는 스토리지 서버에 걸쳐 스트라이프된 일반 파일의 내용으로 구성됩니다. 데이터 스트라이핑은 최소한 두 가지 방법, 즉 파일 단위로 발생하고, 충분히 큰 파일 내에서는 블록 단위로 발생합니다. 이와 대조적으로, pNFS 서버의 파일 시스템 백엔드가 메타데이터를 스트라이프할 수 있더라도 pNFS 클라이언트에 의한 메타데이터에 대한 스트라이프 액세스는 NFSv4.1에서 제공되지 않습니다. 메타데이터는 비정규 파일\(예: 디렉터리\)의 콘텐츠를 포함한 다른 모든 것으로 구성됩니다. 섹션 12.2.1을 참조하세요. 메타데이터 기능은 pNFS와 섹션 18에 설명된 작업을 지원하는 NFSv4.1 서버에 의해 구현됩니다. 이러한 서버를 메타데이터 서버라고 합니다\(12.2.2절\).

데이터 기능은 하나 이상의 저장 장치에 의해 구현되며, 각 저장 장치는 저장 프로토콜을 통해 클라이언트에 의해 액세스됩니다. NFSv4.1의 하위 집합\(섹션 13.6에 정의됨\)은 그러한 스토리지 프로토콜 중 하나입니다. NFSv4.1 명명법에 새로운 용어가 도입되었으며 pNFS 기능을 설명할 수 있도록 기존 용어가 명확해졌습니다.

---
#### **12.2.1.  Metadata**

이름, 네임스페이스 내 위치, 소유자, ACL 및 기타 속성과 같은 파일 시스템 개체에 대한 정보입니다. 메타데이터에는 저장 위치 정보도 포함될 수 있으며 이는 사용되는 기본 저장 메커니즘에 따라 달라집니다.

---
#### **12.2.2.  Metadata Server**

pNFS 기능을 지원하는 NFSv4.1 서버입니다. 메타데이터 서버와 서버에 보관된 파일 시스템 정보의 사용에 대한 다양한 아키텍처 선택이 존재합니다. 일부 서버에는 메타데이터 서버에 있는 파일 개체에 대한 메타데이터만 포함될 수 있으며, 파일 데이터는 관련 저장 장치에 있습니다. 다른 메타데이터 서버는 메타데이터와 다양한 수준의 파일 데이터를 모두 보유할 수 있습니다.

---
#### **12.2.3.  pNFS Client**

pNFS 작업을 지원하고 스토리지 장치에 대한 I/O를 수행하기 위한 하나 이상의 스토리지 프로토콜을 지원하는 NFSv4.1 클라이언트입니다.

---
#### **12.2.4.  Storage Device**

저장 장치는 일반 파일의 데이터를 저장하지만 메타데이터 관리는 메타데이터 서버에 맡깁니다. 저장 장치는 다른 NFSv4.1 서버, 객체 기반 저장 장치\(OSD\), 시스템 영역 네트워크\(SAN, 예: FiberChannel 또는 iSCSI SAN\)를 통해 액세스되는 블록 장치 또는 기타 엔터티일 수 있습니다.

---
#### **12.2.5.  Storage Protocol**

그림 1에서 설명한 것처럼 스토리지 프로토콜은 클라이언트가 스토리지 장치에서 직접 데이터를 저장하고 검색하는 데 사용하는 방법입니다.

NFSv4.1 pNFS 기능은 다양한 스토리지 프로토콜을 정의하고 사용할 수 있도록 구성되었습니다. 스토리지 프로토콜의 한 가지 예는 NFSv4.1 자체입니다\(섹션 13에 설명되어 있음\). 저장 프로토콜에 대한 다른 옵션은 다른 곳에서 설명되며 다음을 포함합니다.

\* 인터넷 SCSI\(iSCSI\)\[56\] 및 FCP\[57\]와 같은 블록/볼륨 프로토콜. 블록/볼륨 프로토콜 지원은 사용된 블록/볼륨 프로토콜의 주소 지정 구조와 독립적일 수 있으므로 둘 이상의 프로토콜이 동일한 파일 데이터에 액세스할 수 있도록 하고 다른 블록/볼륨 프로토콜로의 확장성을 가능하게 합니다. pNFS가 블록/볼륨 스토리지 프로토콜을 사용할 수 있도록 하는 레이아웃 사양은 \[48\]을 참조하세요.

\* iSCSI 또는 파이버 채널을 통한 OSD와 같은 개체 프로토콜 \[58\] pNFS가 객체 스토리지 프로토콜을 사용할 수 있도록 허용하는 레이아웃 사양은 \[47\]을 참조하세요.

클라이언트와 서버 모두에서 다양한 스토리지 프로토콜을 사용할 수 있지만 클라이언트와 서버에 사용 가능한 일치하는 스토리지 프로토콜이 없을 수도 있습니다. 이 때문에 pNFS 서버는 pNFS 기능으로 액세스할 수 있는 모든 파일에 대한 일반 NFSv4.1 액세스를 지원해야 합니다. 이를 통해 NFSv4.1 클라이언트와 서버 간의 지속적인 상호 운용성이 가능해집니다.\(MUST\)

---
#### **12.2.6.  Control Protocol**

그림 1에 표시된 대로 제어 프로토콜은 메타데이터 서버와 저장 장치 사이의 내보낸 파일 시스템에서 사용됩니다. 이러한 프로토콜의 사양은 NFSv4.1 프로토콜의 범위를 벗어납니다. 이러한 제어 프로토콜은 저장소 할당 및 할당 해제, 클라이언트 액세스 제어를 수행하기 위해 저장소 장치에 필요한 상태 관리, 저장소 프로토콜에 따라 인증 및 권한 부여 시행과 같은 활동을 제어하는 ​​데 사용됩니다. 메타데이터 서버에 의해 시행되는 것은 저장 장치에 의해서도 시행됩니다.

NFSv4.1에서는 특정 제어 프로토콜이 필수가 아니지만 수정 시간, 변경 속성, EOF\(파일 끝\) 위치와 같은 속성을 유지 관리하기 위한 요구 사항이 제어 프로토콜에 적용됩니다. pNFS가 클러스터형 병렬 파일 시스템\(예: PVFS\[59\]\) 위에 계층화되어 있는 경우 해당 파일 시스템에서 클러스터링 및 병렬 처리를 활성화하는 메커니즘이 제어 프로토콜로 간주될 수 있습니다.\(MUST\)

---
#### **12.2.7.  Layout Types**

레이아웃은 데이터를 보유하는 저장 장치에 대한 파일 데이터의 매핑을 설명합니다. 레이아웃은 특정 레이아웃 유형\(레이아웃 유형4 데이터 유형, 섹션 3.3.13 참조\)에 속한다고 합니다. 레이아웃 유형을 사용하면 변형이 블록/볼륨\[48\], 객체\[47\] 및 파일\(섹션 13\) 레이아웃 유형과 관련된 것과 같은 다양한 저장 프로토콜을 처리할 수 있습니다. 메타데이터 서버는 제어 프로토콜과 함께 최소한 하나의 레이아웃 유형을 지원해야 합니다. 레이아웃 유형 네임스페이스의 비공개 하위 범위도 정의됩니다. 비공개 레이아웃 유형 범위의 값은 내부 테스트 또는 실험에 사용될 수 있습니다\(섹션 3.3.13 참조\).\(MUST, MAY\)

예를 들어, 파일 레이아웃 유형의 구성은 데이터가 장치 전체에 저장되는 방식\(예: 스트라이핑\)에 대한 정의와 함께 튜플 배열\(예: 장치 ID, 파일 핸들\)일 수 있습니다. 블록/볼륨 레이아웃은 블록 크기 및 블록 번호의 관련 파일 오프셋에 대한 정보와 함께 <장치 ID, 블록 번호, 블록 수\>를 저장하는 튜플 배열일 수 있습니다. 객체 레이아웃은 <장치 ID, 객체 ID\> 튜플의 배열과 파일 데이터의 논리적 바이트 시퀀스가 ​​다른 객체로 직렬화되는 방식을 정의하는 추가 구조\(즉, 집계 맵\)일 수 있습니다. 실제 레이아웃은 일반적으로 이러한 간단한 설명 예제보다 더 복잡합니다.

pNFS 관련 작업에 대한 요청은 레이아웃 유형을 지정하는 경우가 많습니다. 이러한 작업의 예로는 GEDEVICEINFO 및 LAYOUTGET이 있습니다. 이러한 작업에 대한 응답에는 device\_addr4 또는 레이아웃4와 같은 구조가 포함되며, 각 구조에는 레이아웃 유형이 포함되어 있습니다. 서버가 보낸 레이아웃 유형은 항상 클라이언트가 요청한 것과 동일해야 합니다. 서버가 다른 레이아웃 유형을 포함하는 응답을 보낼 때 클라이언트는 응답을 무시하고 서버가 오류 응답을 반환한 것처럼 행동해야 합니다.\(MUST, SHOULD\)

---
#### **12.2.8.  Layout**

레이아웃은 하나 이상의 저장 장치에서 파일 데이터가 구성되는 방식을 정의합니다. 잠재적인 레이아웃 유형은 다양합니다. 각 레이아웃 유형은 데이터에 액세스하는 데 사용되는 저장 프로토콜과 기본 저장 장치에 파일 데이터를 배치하는 집계 체계에 따라 구별됩니다. 레이아웃은 튜플 <클라이언트 ID, 파일 핸들, 레이아웃 유형, iomode, 범위\>로 정확하게 식별됩니다. 여기서 filehandle은 메타데이터 서버에 있는 파일의 파일 핸들을 나타냅니다.

레이아웃이 서로 겹치거나 충돌하는 경우를 정의하는 것이 중요합니다. 바이트 범위가 겹치는 두 레이아웃이 실제로 서로 겹치려면 두 레이아웃이 모두 동일한 레이아웃 유형이어야 하고, 동일한 파일 핸들에 해당하며, 동일한 iomode를 가져야 합니다. 레이아웃이 겹쳐지고 레이아웃 내용이 다를 때\(예: 저장 장치/파일 매핑 매개변수가 다름\) 레이아웃이 충돌합니다. iomode가 달라도 레이아웃 충돌이 발생하지 않습니다. 동일한 바이트 범위에 속하는 서로 다른 iomode의 레이아웃을 동일한 클라이언트가 보유하는 것이 허용됩니다. 이에 대한 예는 블록/볼륨 레이아웃 유형에 대한 기록 중 복사 기능입니다.

---
#### **12.2.9.  Layout Iomode**

레이아웃 iomode\(데이터 유형 레이아웃iomode4, 섹션 3.3.20 참조\)는 클라이언트가 읽기 작업만 수행하거나 읽기 및 쓰기 작업이 포함된 혼합 작업을 수행하려는 의도를 메타데이터 서버에 나타냅니다. 특정 레이아웃 유형의 경우 클라이언트가 LAYOUTGET을 전송할 때 이 인텐트를 지정하는 것이 유용합니다\(섹션 18.43\). 예를 들어 블록/볼륨 기반 프로토콜의 경우 LAYOUTIOMODE4\_RW iomode가 지정되면 블록 할당이 발생할 수 있습니다. 특별한 LAYOUTIOMODE4\_ANY iomode가 정의되어 있으며 LAYOUTGET에는 사용할 수 없고 LAYOUTRETURN 및 CB\_LAYOUTRECALL에만 사용할 수 있습니다. LAYOUTIOMODE4\_READ 및 LAYOUTIOMODE4\_RW iomode와 관련된 레이아웃이 각각 반환되거나 호출되도록 지정합니다.

저장 장치는 iomode와 관련하여 I/O의 유효성을 검사할 수 있습니다. 이는 저장 장치 구현 및 레이아웃 유형에 따라 다릅니다. 따라서 클라이언트의 레이아웃 iomode가 수행 중인 I/O와 일치하지 않는 경우 저장 장치는 LAYOUTGET을 통해 올바른 iomode가 포함된 새 레이아웃을 가져와야 함을 나타내는 오류와 함께 클라이언트의 I/O를 거부할 수 있습니다. 예를 들어 클라이언트가 LAYOUTIOMODE4\_READ iomode가 포함된 레이아웃을 가져와 저장 장치에 쓰기를 수행하는 경우 저장 장치는 해당 쓰기를 거부할 수 있습니다.

iomode 레이아웃의 사용은 OPEN 공유 모드 또는 바이트 범위 LOCK 작업과 충돌하지 않습니다. 공개 공유 모드 및 바이트 범위 잠금 충돌은 pNFS를 사용하지 않고 pNFS 레이아웃 수준과 논리적으로 분리되어 있으므로 적용됩니다. 공개 공유 모드와 바이트 범위 잠금은 데이터 파일에 대한 사용자 액세스를 제한하는 데 선호되는 방법입니다. 예를 들어, OPEN4\_SHARE\_ACCESS\_WRITE의 OPEN은 다른 클라이언트가 수행한 LAYOUTIOMODE4\_RW의 iomode를 포함하는 LAYOUTGET과 충돌하지 않습니다. 동일한 파일에 동시에 쓰는 것에 의존하는 애플리케이션은 바이트 범위 잠금을 사용하여 액세스를 직렬화할 수 있습니다.

---
#### **12.2.10.  Device IDs**

장치 ID\(데이터 유형 deviceid4, 섹션 3.3.14 참조\)는 저장 장치 그룹을 식별합니다. 장치 ID의 범위는 <클라이언트 ID, 레이아웃 유형\> 쌍입니다. 실제로 저장 장치의 주소를 완전히 지정하려면 상당한 양의 정보가 필요할 수 있습니다. 이러한 모든 정보를 레이아웃에 포함하는 대신 레이아웃은 장치 ID를 포함합니다. NFSv4.1 작업 GEDEVICEINFO\(섹션 18.40\)는 레이아웃 유형 및 장치 ID에 따라 저장 장치에 관한 전체 주소 정보\(장치 ID에 대한 모든 장치 주소 포함\)를 검색하는 데 사용됩니다. 예를 들어 NFSv4.1 데이터 서버 또는 객체 기반 스토리지 장치의 주소는 IP 주소 및 포트일 수 있습니다. 블록 저장 장치의 주소는 볼륨 레이블일 수 있습니다.

클라이언트는 메타데이터 서버를 다시 시작해도 장치 ID와 해당 저장 장치 주소 간의 매핑이 지속될 것이라고 기대할 수 없습니다. 해당 상황에서 복구가 어떻게 작동하는지에 대한 설명은 섹션 12.7.4를 참조하세요.

장치 ID는 장치 ID를 참조하는 레이아웃이 있는 한 유지됩니다. 장치 ID를 참조하는 레이아웃이 없으면 서버는 언제든지 장치 ID를 삭제할 수 있습니다. 서버에 의해 장치 ID가 삭제되면 서버는 동일한 레이아웃 유형 및 클라이언트 ID에 대해 장치 ID를 다시 재사용해서는 안 됩니다. 이 요구 사항은 장치 ID의 길이가 16바이트이므로 서버 구현 시 장치 ID의 나머지 콘텐츠 대부분을 재사용해야 하는 경우 세대 번호를 저장할 수 있는 충분한 공간이 있기 때문에 가능합니다. 그렇지 않으면 장치 ID 추가와 삭제에 대한 비동기 알림 사이의 경쟁 조건을 분류하기가 너무 어렵기 때문에 이 요구 사항이 필요합니다.\(MUST NOT\)

장치 ID와 장치 주소 매핑은 임대되지 않으며 언제든지 변경될 수 있습니다. \(메타데이터 서버가 다시 시작된 후 장치 ID 대 장치 주소 매핑이 변경될 수 있지만 서버는 매핑을 변경할 필요가 없습니다.\) 서버에는 매핑 변경을 위한 두 가지 선택 사항이 있습니다. 장치 ID를 참조하는 모든 레이아웃을 불러오거나 알림 메커니즘을 사용할 수 있습니다.

NFSv4.1 프로토콜에는 특정 장치 ID를 참조하는 모든 레이아웃을 호출하는 최적의 방법이 없습니다\(서버가 단일 장치 ID를 단일 fsid 또는 단일 클라이언트 ID와 연결하지 않는 한, 이 경우 CB\_LAYOUTRECALL에는 모든 레이아웃을 호출하는 옵션이 있습니다\). fsid, 클라이언트 ID 쌍 또는 단지 클라이언트 ID와 연관됨\).

알림 메커니즘\(섹션 20.12 참조\)을 통해 장치 ID와 장치 주소 매핑은 장치 ID를 참조하는 레이아웃을 불러오거나 취소하지 않고도 서버 작동 기간 동안 변경될 수 있습니다. 알림 메커니즘은 장치 ID를 삭제할 수도 있지만 클라이언트에 장치 ID를 참조하는 레이아웃이 없는 경우에만 가능합니다. 장치 주소 매핑에 대한 장치 ID 변경 알림은 즉시 또는 결국 장치 ID 매핑의 일부 또는 전체를 무효화합니다. 서버는 알림을 지원해야 하며 클라이언트는 이를 사용하기 전에 알림을 요청해야 합니다. 알림 유형에 대한 자세한 내용은 섹션 20.12를 참조하세요.\(MUST\)

---
### **12.3.  pNFS Operations**

NFSv4.1에는 레이아웃 유형이나 스토리지 프로토콜에 관계없이 pNFS 서버에 필요한 여러 작업이 있습니다. 이러한 작업은 모두 메타데이터 서버로 전송되고 여기에 요약됩니다. pNFS는 선택적 기능이지만, pNFS가 구현된 경우 pNFS를 준수하려면 일부 작업이 필수입니다. 섹션 17을 참조하세요.\(MUST\)

전면 채널 pNFS 작업은 다음과 같습니다.

이전에 언급한 GEDEVICEINFO\(섹션 18.40\)

- \(12.2.10절\), 장치 ID와 저장 장치 주소의 매핑을 반환합니다.

GETDEVICELIST\(섹션 18.41\)를 사용하면 클라이언트가 특정 파일 시스템에 대한 모든 장치 ID를 가져올 수 있습니다.

LAYOUTGET\(섹션 18.43\)은 클라이언트가 파일의 레이아웃을 가져오는 데 사용됩니다.

LAYOUTCOMMIT\(18.42절\)은 저장 장치\(LAYOUTGET의 반환 값에 원래 표시된 저장 장치\)에 기록된 데이터를 커밋하려는 클라이언트의 의도를 메타데이터 서버에 알리는 데 사용됩니다.

LAYOUTRETURN\(섹션 18.44\)은 파일, 파일 시스템 ID\(FSID\) 또는 클라이언트 ID에 대한 레이아웃을 반환하는 데 사용됩니다.

백채널 pNFS 작업은 다음과 같습니다.

CB\_LAYOUTRECALL\(섹션 20.3\)은 레이아웃, 파일 시스템에 속한 모든 레이아웃 또는 클라이언트 ID에 속한 모든 레이아웃을 호출합니다.

CB\_RECALL\_ANY\(섹션 20.6\)는 클라이언트에게 레이아웃을 포함하여 일부 회수 가능한 개체를 메타데이터 서버에 반환해야 함을 알려줍니다.

CB\_RECALLABLE\_OBJ\_AVAIL\(섹션 20.7\)은 리소스 소진으로 인해 거부된 회수 가능한 개체\(pNFS의 경우 LAYOUTGET에 의해 거부된 레이아웃\)를 이제 사용할 수 있음을 클라이언트에 알립니다.

CB\_NOTIFY\_DEVICEID\(섹션 20.12\)는 클라이언트에 장치 ID 변경 사항을 알립니다.

---
### **12.4.  pNFS Attributes**

pNFS와 관련된 다양한 속성이 섹션 5.12에 나열 및 설명되어 있습니다.

---
### **12.5.  Layout Semantics**
---
#### **12.5.1.  Guarantees Provided by Layouts**

레이아웃은 적절한 저장 프로토콜을 사용하여 저장 장치에 있는 데이터에 액세스할 수 있는 기능을 클라이언트에 부여합니다. 클라이언트는 충돌하는 레이아웃이 요청되거나 레이아웃에 의해 캡슐화된 상태가 유효하지 않게 되는 두 가지 중 하나가 발생할 때 레이아웃이 호출된다는 것을 보장합니다\(이는 이벤트가 레이아웃을 직접 또는 간접적으로 수정하는 경우 발생할 수 있습니다\). 클라이언트가 레이아웃을 호출하고 반환하면 클라이언트는 메타데이터 서버를 통해 일반적인 NFSv4.1 작업으로 파일 데이터에 계속 액세스할 수 있습니다. 저장 장치에 액세스하는 기능만 영향을 받습니다.

모든 사용자 액세스 권한은 적절한 OPEN, LOCK 및 ACCESS 작업을 통해 획득해야 한다는 NFSv4.1의 요구 사항은 레이아웃이 있어도 수정되지 않습니다. 레이아웃은 NFSv4.1 클라이언트에 제공되며 사용자 액세스는 마치 존재하지 않는 것처럼 프로토콜 규칙을 따릅니다. 클라이언트가 저장 장치에 액세스하려면 클라이언트가 레이아웃을 보유해야 한다는 요구 사항이 있습니다. 저장 장치가 클라이언트가 레이아웃을 보유하지 않는 바이트 범위에 대한 I/O 요청을 수신하는 경우 저장 장치는 해당 I/O 요청을 거부해야 합니다. 레이아웃이 보관된 파일을 수정하는 행위가 수정 중인 파일을 설명하는 레이아웃을 보관하는 것과 반드시 ​​충돌하는 것은 아닙니다. 따라서 필요한 동작을 결정하는 것은 스토리지 프로토콜이나 레이아웃 유형의 요구 사항입니다. 예를 들어 블록/볼륨 레이아웃 유형에서는 레이아웃의 iomode가 수행 중인 I/O 유형과 일치해야 합니다.\(MUST, SHOULD\)

사용 중인 레이아웃 유형 및 저장 프로토콜에 따라 저장 장치 액세스 권한은 LAYOUTGET에 의해 부여될 수 있으며 유형별 레이아웃 내에서 인코딩될 수 있습니다. 저장 장치 액세스 권한의 예는 \[58\]과 같은 객체 기반 프로토콜을 참조하세요. 액세스 권한이 레이아웃 내에 인코딩된 경우 메타데이터 서버는 해당 권한이 어떤 이유로든 무효화될 때\(예: 파일을 쓸 수 없거나 클라이언트가 액세스할 수 없는 경우\) 레이아웃을 호출해야 합니다. 클라이언트는 위에서 설명한 대로 적절한 OPEN, LOCK 및 ACCESS 작업을 수행해야 합니다. 클라이언트가 이러한 작업을 회피할 수 있는 정도와 그 결과는 개별 레이아웃 유형 사양에 의해 명확하게 지정되어야 합니다. 또한 이러한 사양에는 서버에서 수행하는 검사에 대한 요구 사항과 비요구 사항이 명확해야 합니다.\(SHOULD\)

pNFS 기능이 있는 경우 필수 바이트 범위 잠금은 pNFS 없이 작동해야 합니다. 따라서 필수 파일 잠금과 레이아웃이 동시에 제공되는 경우 저장 장치는 필수 바이트 범위 잠금을 시행할 수 있어야 합니다. 예를 들어, 한 클라이언트가 필수 바이트 범위 잠금을 획득하고 두 번째 클라이언트가 저장 장치에 액세스하는 경우 저장 장치는 필수 바이트 범위 잠금 범위에 대한 I/O를 적절하게 제한해야 합니다. 필수 바이트 범위 잠금이 있는 경우 저장 장치가 이 검사를 제공할 수 없는 경우 메타데이터 서버는 레이아웃과 필수 바이트 범위 잠금을 동시에 부여해서는 안 됩니다.\(MUST, MUST, MUST, MUST NOT\)

---
#### **12.5.2.  Getting a Layout**

클라이언트는 LAYOUTGET 작업을 통해 레이아웃을 얻습니다. 메타데이터 서버는 특정 유형\(예: 블록/볼륨, 개체 또는 파일\)의 레이아웃을 부여합니다. 클라이언트는 서버가 지원하고 클라이언트가 사용할 준비가 된 적절한 레이아웃 유형을 선택합니다. 클라이언트에 반환된 레이아웃은 섹션 18.43.3에 설명된 대로 요청된 바이트 범위와 정확히 일치하지 않을 수 있습니다. 필요에 따라 클라이언트는 여러 LAYOUTGET 작업을 보낼 수 있습니다. 이로 인해 여러 개의 중복되고 충돌하지 않는 레이아웃이 발생할 수 있습니다\(섹션 12.2.8 참조\).

레이아웃을 얻으려면 클라이언트가 먼저 OPEN 작업을 통해 파일을 열어야 합니다. 클라이언트가 파일에 레이아웃이 없으면 loga\_stateid 인수에 공개 상태 ID, 위임 상태 ID 또는 바이트 범위 잠금 상태 ID를 제시해야 합니다. 성공적인 LAYOUTGET 결과에는 레이아웃 상태 ID가 포함됩니다. 비레이아웃 상태 ID를 인수로 사용하여 서버에서 처리한 첫 번째 성공적인 LAYOUTGET에는 응답에서 레이아웃 상태 ID의 "seqid" 필드가 1로 설정되어 있어야 합니다. 그 후에 클라이언트는 나중에 파일에서 LAYOUTGET을 호출할 때 레이아웃 상태 ID\(섹션 12.5.3 참조\)를 사용해야 하며 "seqid"는 0으로 설정되어서는 안 됩니다. 레이아웃이 검색되면 여러 OPEN 및 CLOSE 시퀀스에 걸쳐 보관될 수 있습니다. 따라서 클라이언트는 현재 클라이언트의 어떤 사용자도 열지 않은 파일에 대한 레이아웃을 보유할 수 있습니다. 이는 CLOSE 이후의 레이아웃 캐싱을 허용합니다.\(MUST, MUST, MUST NOT\)

저장 장치의 데이터에 액세스하기 위해 클라이언트가 사용하는 저장 프로토콜은 레이아웃 유형에 따라 결정됩니다. 클라이언트는 레이아웃 유형을 레이아웃 해석 및 사용에 사용 가능한 방법과 일치시키는 역할을 담당합니다. 이 레이아웃 유형 선택 방법은 pNFS 기능 범위를 벗어납니다.

메타데이터 서버는 파일 레이아웃을 제어하지만 파일이 열리거나 생성될 때 pNFS 클라이언트는 기본 레이아웃 유형 및 집계 체계에 대한 힌트를 서버에 제공할 수 있습니다. pNFS는 새 파일에 대한 힌트를 서버에 제공하기 위해 클라이언트가 파일 생성 시 설정할 수 있는layout\_hint 속성\(섹션 5.12.4\)을 도입합니다. 파일이 생성된 후 이 속성을 별도로 설정하면 서버 구현이 이를 따르기가 어렵거나 불가능할 수 있습니다.

EXCLUSIVE4 createmode4는 파일 생성 시 속성 설정을 허용하지 않기 때문에 NFSv4.1에서는 파일 생성 시 속성 설정을 허용하는 EXCLUSIVE4\_1 createmode4를 도입했습니다. 또한 영구 응답 캐시를 사용하여 세션이 생성된 경우 EXCLUSIVE4\_1은 필요하지도 않고 허용되지도 않습니다. 대신 GUARDED4가 더 잘 작동하고 처방됩니다. 섹션 18.16.3의 표 18에는 클라이언트가 배타적 생성을 보낼 수 있는 방법이 요약되어 있습니다.

---
#### **12.5.3.  Layout Stateid**

다른 모든 stateid와 마찬가지로 레이아웃 stateid는 "seqid" 및 "other" 필드로 구성됩니다. 레이아웃 stateid가 설정되면 stateid가 취소되거나 클라이언트가 파일의 모든 레이아웃을 반환하고 서버가 stateid를 삭제하지 않는 한 "other" 필드는 그대로 유지됩니다. "seqid" 필드는 처음에 1로 설정되며 포채널 작업이든 백채널 작업이든 상관없이 레이아웃 상태 ID를 사용하는 NFSv4.1 작업에서는 절대 0이 아닙니다. 레이아웃 stateid가 설정된 후 서버는 각 후속 LAYOUTGET 및 LAYOUTRETURN 응답과 각 CB\_LAYOUTRECALL 요청에서 "seqid" 값을 1씩 증가시킵니다.

병렬성을 제공한다는 pNFS의 설계 목표를 고려할 때 레이아웃 stateid는 클라이언트가 LAYOUTGET 및 LAYOUTRETURN 작업을 병렬로 전송해야 한다는 점에서 다른 stateid 유형과 다릅니다. "seqid" 값은 클라이언트가 LAYOUTGET 및 LAYOUTRETURN에 대한 응답을 적절하게 정렬하는 데 사용됩니다. "seqid"는 LAYOUTGET과 CB\_LAYOUTRECALL 간의 경쟁 조건을 방지하는 데에도 사용됩니다. 처리 규칙이 레이아웃 stateid 및 기타 stateid 유형과 다르다는 점을 고려하면 적절한 레이아웃 stateid 처리를 결정하려면 이 문서의 pNFS 섹션만 고려해야 합니다.

클라이언트가 레이아웃 상태 ID를 수신하면 후속 LAYOUTGET 또는 LAYOUTRETURN 작업에 올바른 "seqid"를 사용해야 합니다. 올바른 "seqid"는 완전히 처리된 LAYOUTGET 또는 LAYOUTRETURN 작업의 응답이나 완전히 처리된 CB\_LAYOUTRECALL 작업의 인수에서 가장 높은 "seqid" 값으로 정의됩니다. 서버는 레이아웃 작업마다 "seqid" 값을 증가시키므로 클라이언트는 "seqid" 값을 검사하여 작업 처리 순서를 결정할 수 있습니다. 레이아웃 범위가 겹치는 경우 주문 정보를 통해 고객에게 어떤 레이아웃 범위가 유지되는지 알 수 있습니다. 클라이언트의 특정 요청으로 인해 또는 서버가 요청된 레이아웃의 범위를 확장하고 LAYOUTRETURN 결과를 통해 클라이언트에 알리도록 허용되었기 때문에 레이아웃 범위가 겹칠 수 있습니다. 추가 레이아웃 stateid 순서 요구 사항은 섹션 12.5.5.2에 제공됩니다.\(MUST\)

클라이언트가 "seqid"를 수신하는 것만으로는 후속 사용에 충분하지 않습니다. 클라이언트는 "seqid"를 사용하기 전에 작업을 완전히 처리해야 합니다. LAYOUTGET 결과의 경우 클라이언트가 망각 모델\(섹션 12.5.5.1\)을 사용하지 않는 경우 seqid를 사용하기 전에 먼저 파일 레이아웃의 범위에 대한 기록을 업데이트해야 합니다. LAYOUTRETURN 결과의 경우 클라이언트는 seqid를 사용하기 전에 파일 레이아웃의 범위에 대한 기록에서 범위를 삭제해야 합니다. CB\_LAYOUTRECALL 인수의 경우 클라이언트는 seqid를 사용하기 전에 회수에 대한 응답을 보내야 합니다. 클라이언트 처리의 기본 요구 사항은 "seqid"가 처리 순서를 제공하는 데 사용된다는 것입니다. LAYOUTGET 결과는 병렬로 처리될 수 있습니다. LAYOUTRETURN 결과는 병렬로 처리될 수 있습니다. LAYOUTGET 및 LAYOUTRETURN 응답은 범위가 겹치지 않는 한 병렬로 처리될 수 있습니다. CB\_LAYOUTRECALL 요청 처리는 항상 "seqid" 순서로 처리되어야 합니다.\(MUST, MUST, MUST, MUST\)

클라이언트의 파일에 더 이상 레이아웃이 없으면 레이아웃 상태 ID는 더 이상 유효하지 않으며 사용하면 안 됩니다. 이러한 레이아웃 상태 ID를 사용하려고 시도하면 NFS4ERR\_BAD\_STATEID가 발생합니다.\(MUST NOT\)

---
#### **12.5.4.  Committing a Layout**

다양한 스토리지 프로토콜 기능을 허용하는 pNFS 프로토콜에서는 메타데이터 서버 및 스토리지 장치가 파일 속성 및 데이터 위치 매핑에 대한 일관된 보기를 가질 필요가 없습니다. 데이터 위치 매핑은 홀을 저장하는 것과 반대로 데이터를 저장하는 오프셋과 같은 측면을 나타냅니다\(토론은 섹션 13.4.4 참조\). 클라이언트와 서버가 모두 완전히 다시 시작된 후에도 해당 블록의 할당이 유지되지 않는 임시 할당 블록을 레이아웃에 보유할 수 있는 스토리지 프로토콜에 관련 문제가 발생합니다. 이러한 불일치로 인해 클라이언트를 메타데이터 서버 및 해당 저장 장치와 다시 동기화하고 잠재적인 변경 사항을 다른 클라이언트에서 사용할 수 있도록 해야 합니다. 이는 LAYOUTCOMMIT 작업을 사용하여 수행됩니다.

LAYOUTCOMMIT 작업은 수정된 레이아웃을 메타데이터 서버에 커밋하는 역할을 합니다. LAYOUTCOMMIT가 발생하기 전에 데이터가 적절한 저장 장치에 기록되고 커밋되어야 합니다. LAYOUTCOMMIT 작업의 범위는 사용 중인 스토리지 프로토콜에 따라 다릅니다. 동기화 수준은 LAYOUTCOMMIT를 보낸 클라이언트의 관점에서 결정된다는 점에 유의하는 것이 중요합니다. 메타데이터 서버의 업데이트된 상태는 LAYOUTCOMMIT 이전 클라이언트의 마지막 작업 상태만 반영하면 됩니다. 메타데이터 서버는 동일한 시간 내에 발생했을 수 있는 다른 클라이언트의 I/O를 설명하는 전역 보기를 유지하는 데 필수가 아닙니다.\(MUST\)

블록/볼륨 기반 레이아웃의 경우 LAYOUTCOMMIT는 파일을 구성하는 블록 목록을 업데이트하고 이 레이아웃을 안정적인 저장소에 커밋해야 할 수 있습니다. 파일 기반 레이아웃의 경우 메타데이터와 저장 장치 간의 속성\(주로 크기 속성\) 동기화가 필요합니다.

제어 프로토콜은 LAYOUTCOMMIT를 수신하기 전에 속성을 자유롭게 동기화할 수 있습니다. 그러나 LAYOUTCOMMIT가 성공적으로 완료되면 파일을 설명하는 메타데이터 서버에 존재하는 상태는 클라이언트가 마지막으로 전송한 작업으로 해당 파일을 구성하는 저장 장치에 존재하는 상태와 동기화되어야 합니다. 따라서 저장 장치에 대한 WRITE와 LAYOUTCOMMIT 사이의 파일 크기를 쿼리하는 클라이언트는 작성된 실제 데이터를 반영하지 않는 크기를 관찰할 수 있습니다.\(MUST\)

LAYOUTCOMMIT 작업을 보내려면 클라이언트에 레이아웃이 있어야 합니다.\(MUST\)

---
##### **12.5.4.1.  LAYOUTCOMMIT and change/time_modify**

LAYOUTCOMMIT 작업이 처리되면 서버에서 변경 및 시간 수정 속성을 업데이트할 수 있습니다. 그 이유는 저장 장치가 I/O 작업을 처리할 때 일부 레이아웃 유형이 이러한 속성 업데이트를 지원하지 않기 때문입니다. 클라이언트의 파일에 LAYOUTIOMODE4\_RW iomode가 있는 레이아웃이 있는 경우 클라이언트는 LAYOUTCOMMIT에 대한 인수 내에서 time\_modify에 대한 제안 값을 서버에 제공할 수 있습니다. 레이아웃 유형에 따라 제공된 값이 사용될 수도 있고 사용되지 않을 수도 있습니다. 서버는 클라이언트가 제공한 값을 사용하기 전에 온전한지 확인해야 합니다. 예를 들어, 서버는 시간이 거꾸로 흐르지 않도록 해야 합니다. 클라이언트에는 항상 명시적인 SETATTR 작업을 통해 time\_modify를 설정할 수 있는 옵션이 있습니다.\(MAY\)

일부 레이아웃 프로토콜의 경우 저장 장치는 I/O 발생을 메타데이터 서버에 알릴 수 있습니다. 결과적으로 변경 및 time\_modify 속성이 메타데이터 서버에서 업데이트될 수 있습니다. 변경 및 time\_modify 속성에 대한 업데이트를 모니터링할 수 있는 메타데이터 서버의 경우 변경 속성을 업데이트하는 데 LAYOUTCOMMIT 처리가 필요하지 않습니다. 이 경우 메타데이터 서버는 속성의 마지막 업데이트 이후 데이터에 대한 추가 업데이트가 발생하지 않았는지 확인해야 합니다. 파일 기반 프로토콜에는 이러한 결정을 내리는 데 충분한 정보가 있거나 각 파일 수정 시 변경 속성을 업데이트할 수 있습니다. 이는 time\_modify 속성에도 적용됩니다. 서버 구현에서 마지막 time\_modify 업데이트 이후 파일이 수정되지 않았음을 확인할 수 있는 경우 서버는 LAYOUTCOMMIT에서 time\_modify를 업데이트할 필요가 없습니다. LAYOUTCOMMIT 완료 시 최신 이전 LAYOUTCOMMIT 또는 LAYOUTGET 이후 해당 파일이 수정된 경우 업데이트된 속성이 표시되어야 합니다.

---
##### **12.5.4.2.  LAYOUTCOMMIT and size**

클라이언트에서 LAYOUTCOMMIT 작업을 사용하면 파일 크기가 업데이트될 수 있습니다. LAYOUTCOMMIT 인수의 필드 중 하나는 loca\_last\_write\_offset입니다. 이 필드는 기록되었지만 아직 LAYOUTCOMMIT 작업으로 커밋되지 않은 가장 높은 바이트 오프셋을 나타냅니다. loca\_last\_write\_offset의 데이터 유형은 newoffset4이며 이전 쓰기가 발생했는지 여부를 나타내는 부울 값 no\_newoffset으로 전환됩니다. no\_newoffset이 FALSE이면 오프셋이 제공되지 않습니다. 클라이언트가 파일에 LAYOUTIOMODE4\_RW iomode가 있고 loca\_last\_write\_offset과 겹치는 바이트 범위\(lo\_offset 및 lo\_length 값으로 표시됨\)가 있는 레이아웃이 있는 경우 클라이언트는 no\_newoffset을 TRUE로 설정하고 파일 크기를 업데이트하는 오프셋을 제공할 수 있습니다. . 오프셋은 서로 관련되어 있지만 길이와 동일하지는 않습니다. 예를 들어, loca\_last\_write\_offset 값이 0이면 1바이트가 오프셋 0에 기록되었으므로 파일 길이가 1바이트 이상이라는 의미입니다.\(MAY\)

메타데이터 서버는 다음 중 하나를 수행할 수 있습니다.

1. 클라이언트가 실제 파일 크기 또는 파일 크기에 대한 힌트로 제공한 마지막 쓰기 오프셋을 사용하여 파일 크기를 업데이트합니다. 메타데이터 서버에 사용 가능한 방법이 있는 경우 파일 크기에 대한 새 값이 있는지 확인해야 합니다. 예를 들어 클라이언트가 파일의 현재 크기보다 작은 마지막 쓰기 오프셋을 제공하는 경우 파일을 자르면 안 됩니다.

2. 클라이언트가 제공한 마지막 쓰기 오프셋을 무시합니다. 메타데이터 서버는 파일 크기를 결정하기 위해 다른 소스로부터 충분한 지식을 갖고 있어야 합니다. 예를 들어 메타데이터 서버는 제어 프로토콜을 사용하여 저장 장치를 쿼리합니다.

파일 크기를 업데이트하기 위해 선택한 방법은 저장 장치 및/또는 제어 프로토콜의 기능에 따라 달라집니다. 예를 들어 저장 장치가 파일 크기를 모르는 블록 장치인 경우 메타데이터 서버는 클라이언트에 의존하여 마지막 쓰기 오프셋을 적절하게 설정해야 합니다.

LAYOUTCOMMIT의 결과에는 newsize4 통합 데이터 유형 형식의 새 크기 값이 포함됩니다. LAYOUTCOMMIT의 결과로 파일 크기가 설정된 경우 메타데이터 서버는 새 크기로 응답해야 합니다. 그렇지 않으면 새 크기가 제공되지 않습니다. 파일 크기가 업데이트되면 메타데이터 서버는 LAYOUTCOMMIT 처리가 완료될 때 새 파일 크기가 반영되도록 저장 장치를 업데이트해야 합니다. 예를 들어 클라이언트는 새 파일 크기까지 읽을 수 있어야 합니다.\(SHOULD\)

클라이언트는 지정된 크기 속성을 사용하여 SETATTR 작업을 메타데이터 서버에 전송하여 파일 길이를 확장하거나 파일을 자를 수 있습니다. 지정된 크기가 파일의 현재 크기보다 크면 파일은 "0 확장"됩니다. 즉, 파일의 이전 EOF와 새 EOF 사이에 0이 암시적으로 추가됩니다. \(많은 구현에서 파일의 0 확장 바이트 범위는 파일의 할당되지 않은 구멍으로 구성됩니다.\) 클라이언트가 WRITE를 통해 과거 EOF를 쓰는 경우 SETATTR 작업을 사용할 필요가 없습니다.

---
##### **12.5.4.3.  LAYOUTCOMMIT and layoutupdate**

LAYOUTCOMMIT 인수에는 데이터 유형layoutupdate4\(섹션 3.3.18\)의 loca\_layoutupdate 필드\(섹션 18.42.1\)가 포함되어 있습니다. 이 인수는 레이아웃 유형별 구조입니다. 구조는 LAYOUTCOMMIT 시간에 클라이언트에서 메타데이터 서버로 임의의 레이아웃 유형별 정보를 전달하는 데 사용될 수 있습니다. 예를 들어, 블록/볼륨 레이아웃을 사용하는 경우 클라이언트는 클라이언트가 사용했거나 사용하지 않은 블록을 예약하거나 할당한 메타데이터 서버에 표시할 수 있습니다. loca\_layoutupdate\(lou\_body 필드\)의 콘텐츠는 logr\_layout 필드의 lo\_content 필드에 있는 loc\_body 필드의 LAYOUTGET\(섹션 18.43.2\)에서 반환된 레이아웃 유형별 콘텐츠와 동일할 필요는 없습니다. loca\_layoutupdate의 내용은 레이아웃 유형 사양에 의해 정의되며 LAYOUTCOMMIT에는 불투명합니다.

---
#### **12.5.5.  Recalling a Layout**

레이아웃은 직접적인 클라이언트-저장-장치 경로를 통해 파일에 대한 클라이언트의 액세스를 보호하므로 레이아웃은 의미상 이 기능을 제공할 수 없는 경우에만 호출하면 됩니다. 일반적으로 이는 레이아웃이 나타내는 바이트 범위에 걸쳐 파일의 실제 위치를 더 이상 캡슐화하지 않을 때 발생합니다. 서버 기반 재스트라이핑 또는 로드 밸런싱과 같이 레이아웃을 변경하는 모든 작업이나 작업으로 인해 레이아웃이 다시 호출됩니다. 레이아웃은 CB\_LAYOUTRECALL 콜백 작업\(섹션 20.3 참조\)에 의해 호출되고 LAYOUTRETURN\(섹션 18.44 참조\)과 함께 반환됩니다. CB\_LAYOUTRECALL 작업은 바이트 범위로 식별된 레이아웃, FSID\(파일 시스템 ID\)와 연결된 모든 레이아웃 또는 클라이언트 ID와 연결된 모든 레이아웃을 호출할 수 있습니다. 섹션 12.5.5.2에서는 레이아웃 가져오기, 반환 및 호출과 관련된 순서 문제를 논의합니다.

레이아웃을 불러올 때 iomode도 지정됩니다. 일반적으로 회수 요청의 iomode는 반환되는 레이아웃과 일치해야 합니다. 예를 들어, iomode가 LAYOUTIOMODE4\_RW인 리콜로 인해 클라이언트는 LAYOUTIOMODE4\_READ 레이아웃이 아닌 LAYOUTIOMODE4\_RW 레이아웃만 반환해야 합니다. 그러나 모든 iomode의 레이아웃을 호출할 수 있도록 특수 LAYOUTIOMODE4\_ANY 열거형이 정의되어 있습니다. 즉, 클라이언트는 LAYOUTIOMODE4\_READ 및 LAYOUTIOMODE4\_RW 레이아웃을 모두 반환해야 합니다.

REMOVE 작업은 클라이언트가 존재하지 않는 파일에 액세스하는 것을 방지하고 클라이언트에 저장된 상태를 회수하기 위해 메타데이터 서버가 레이아웃을 호출하도록 해야 합니다. 파일이 마지막으로 닫힐 때까지 REMOVE가 지연될 수 있으므로 호출도 이 시간까지 지연될 수 있습니다. 파일의 마지막 참조가 해제되고 파일이 제거된 후에는 클라이언트가 더 이상 레이아웃을 사용하여 I/O를 수행할 수 없습니다. 파일 기반 레이아웃의 경우 데이터 서버는 제거된 파일에 대한 작업에 대한 응답으로 NFS4ERR\_STALE를 반환해야 합니다\(SHOULD\).\(SHOULD, SHOULD\)

레이아웃이 반환되면 클라이언트는 반환된 레이아웃이 나타내는 파일, 바이트 범위 및 iomode에 대한 저장 장치에 I/O를 전송해서는 안 됩니다. 클라이언트가 레이아웃을 보유하지 않는 저장 장치에 I/O를 보내는 경우 저장 장치는 I/O를 거부해야 합니다.\(MUST NOT, SHOULD\)

pNFS는 클라이언트의 파일 데이터 캐싱 기능이나 의미 체계를 변경하지 않지만 일부 클라이언트는 pNFS가 제공하는 이점을 최적화하기 위해 보다 적극적인 write-behind 캐싱을 수행할 수 있다는 점을 인식합니다. 그러나 write-behind 캐싱은 CB\_LAYOUTRECALL에 대한 응답으로 레이아웃을 반환할 때 대기 시간에 부정적인 영향을 미칠 수 있습니다. 이는 파일 위임 및 파일 데이터 캐싱이 DELEGRETURN에 미치는 영향과 유사합니다. 클라이언트 구현은 CB\_LAYOUTRECALL에 대한 응답이 지나치게 긴 것을 방지하기 위해 한 번에 처리되지 않은 기록되지 않은 데이터의 양을 제한해야 합니다. 레이아웃이 회수되면 서버는 추가 조치를 취하기 전에 임대 기간 1회를 기다려야 합니다. 임대 기간이 지나면 클라이언트가 레이아웃을 반환하는 데 너무 오랜 시간이 걸린다고 서버가 인식하는 경우 서버는 클라이언트의 저장 장치 액세스를 차단하도록 선택할 수 있습니다. 그러나 데이터 위임 및 DELEGRETURN의 경우와 마찬가지로 클라이언트가 레이아웃을 반환하는 과정에서 진행 상황을 표시하고 있다는 점을 고려하여 서버는 대기하도록 선택할 수 있습니다. 이러한 진행 과정은 저장 장치와의 성공적인 상호 작용 또는 클라이언트가 반환하는 레이아웃의 하위 부분의 형태를 취할 수 있습니다. 또한 서버는 레이아웃에 초기에 제공되는 바이트 범위와 미해결 수정 데이터의 양을 제한하여 이러한 문제에 대한 노출을 제한할 수 있습니다.\(SHOULD, MUST\)

---
##### **12.5.5.1.  Layout Recall Callback Robustness**

지금까지는 파일에 대한 pNFS 클라이언트 상태\(레이아웃 범위 및 iomode\)가 해당 파일에 대한 pNFS 서버의 상태와 정확히 일치한다고 가정했습니다. 이러한 가정은 클라이언트와 서버 모두 유지되는 상태에 대해 동의하므로 모든 콜백이 콜백의 범위와 정확히 일치하는 LAYOUTRETURN 또는 LAYOUTRETURN 세트를 생성한다는 의미로 이어집니다. 그러나 이 가정이 항상 유지되지 않는 경우에는 유용할 수 있습니다. 예를 들어:

\* 콜백이 필요한 충돌이 매우 드물고 서버가 다중 파일 콜백을 사용하여 클라이언트별 리소스를 복구할 수 있는 경우\(예: FSID 리콜 또는 단일 CB\_COMPOUND 내의 다중 파일 리콜을 통해\) 결과는 상당히 달라질 수 있습니다. 클라이언트-서버 pNFS 트래픽이 줄어듭니다.

\* 서버가 대략적으로 클라이언트가 보유하는 범위에 대한 정보를 유지하는 것이 유용할 수 있으며, 이로 인해 서버의 레이아웃 범위가 클라이언트가 실제로 보유하는 범위를 벗어나게 됩니다. 극단적으로, 서버는 클라이언트가 하위 파일 범위를 요청하고 허용하더라도 전체 파일 콜백만 전송하여 파일별로 충돌을 관리할 수 있습니다.

\* 클라이언트가 실제로 어떤 레이아웃과 범위를 갖고 있는지에 대한 세부 정보를 "잊어" 클라이언트가 "생각"하는 범위를 벗어나는 서버의 레이아웃 범위를 만드는 것이 클라이언트에게 유용할 수 있습니다. 클라이언트가 서버가 허용한 것 이상의 레이아웃을 가지고 있다고 가정하지 않는 한 이는 안전한 방법입니다. 클라이언트가 어떤 범위와 레이아웃이 있는지 잊어버리고 CB\_LAYOUTRECALL 작업을 수신하면 클라이언트는 서버가 호출한 내용에 대해 LAYOUTRETURN을 수행해야 합니다. 또는 호출된 범위에 반환할 레이아웃이 없는 경우 대안적으로 NFS4ERR\_NOMATCHING\_LAYOUT 오류를 반환해야 합니다.\(MUST\)

\* 오류를 방지하려면 클라이언트가 서버가 부여한 것 이상의 레이아웃 권한을 할당하지 않고 서버가 부여된 레이아웃 권한을 잊지 않는 것이 중요합니다. 반면, 클라이언트가 클라이언트가 알지 못하는 레이아웃을 보유하고 있다고 서버가 판단하는 경우, 요청된 전체 범위에 대해 LAYOUTRETURN 작업을 보내거나 다음을 통해 요청된 호출이 완료되었음을 클라이언트가 명확하게 나타내는 것이 유용합니다. CB\_LAYOUTRECALL에 NFS4ERR\_NOMATCHING\_LAYOUT 오류를 반환합니다.

따라서 위의 관점에서 서버가 클라이언트에 부여하지 않은 레이아웃 범위에 대한 콜백을 보낼 수 있고 클라이언트가 보유하지 않는 범위를 반환하는 것이 유용합니다. pNFS 클라이언트는 항상 리콜에 의해 지정된 전체 범위를 구성하는 레이아웃을 반환해야 합니다. 전체 호출된 레이아웃 범위는 단일 작업의 일부로 반환될 필요는 없지만 부분적으로 반환될 수 있습니다. 이를 통해 클라이언트는 더티 데이터 플러시와 레이아웃 커밋 및 반환을 단계적으로 수행할 수 있습니다. 또한 클라이언트가 진행 중임을 메타데이터 서버에 나타냅니다.\(MUST\)

레이아웃이 반환되면 클라이언트는 레이아웃과 관련된 저장 장치에 대한 미해결 I/O 요청을 가져서는 안 됩니다. 바꿔 말하면, 클라이언트는 저장 장치에 대한 처리되지 않은 I/O 요청이 있는 동안 레이아웃을 반환해서는 안 됩니다.\(MUST NOT, MUST NOT\)

클라이언트에 대한 이러한 요구 사항이 있더라도 I/O 요청이 더 이상 수행이 허용되지 않는 저장 장치에 제공될 수 있습니다. 서버는 클라이언트가 레이아웃을 반환할 시기를 엄격하게 제어할 수 없기 때문에 나중에 레이아웃에서 제공하는 저장 장치에 대한 클라이언트의 액세스를 일방적으로 취소하기로 결정할 수도 있습니다. 액세스 취소를 선택할 때 서버는 지연되는 I/O 요청\(즉, 취소된 레이아웃으로 식별되는 저장 장치에 대해 아직 진행 중인 I/O 요청\) 가능성을 처리해야 합니다. 모든 레이아웃 유형 사양은 메타데이터 서버에 의한 일방적인 레이아웃 취소가 지원되는지 여부를 정의해야 합니다. 그렇다면 사양은 느린 쓰기가 처리되는 방법도 설명해야 합니다. 예를 들어, 취소된 레이아웃으로 식별된 저장 장치는 해당 레이아웃을 보유한 클라이언트로부터 차단될 수 있습니다.\(MUST\)

레이아웃 상태와 관련된 클라이언트/서버 수렴을 보장하기 위해 특정 호출에 대한 LAYOUTRETURN 작업 시퀀스의 최종 LAYOUTRETURN 작업은 호출되는 레이아웃 유형, iomode, 호출/반환 유형\(FILE\)을 반영하여 호출되는 전체 범위를 지정해야 합니다. , FSID 또는 ALL\) 및 바이트 범위\(부분 범위와 관련된 레이아웃이 이전에 반환된 경우에도 마찬가지\) 또한 클라이언트가 리콜되는 범위와 겹치는 레이아웃을 보유하지 않은 경우 클라이언트는 NFS4ERR\_NOMATCHING\_LAYOUT 오류 코드를 CB\_LAYOUTRECALL에 반환해야 합니다. 이를 통해 서버는 클라이언트의 레이아웃 상태 보기를 업데이트할 수 있습니다.\(MUST\)

---
##### **12.5.5.2.  Sequencing of Layout Operations**

다른 상태 저장 작업과 마찬가지로 pNFS에는 레이아웃 작업의 올바른 순서가 필요합니다. pNFS는 레이아웃 stateid의 "seqid"를 사용하여 일반 작업과 콜백 간의 올바른 순서를 제공합니다. 제공된 레이아웃과 관련된 불일치를 피하는 것은 서버의 책임이고 레이아웃 요청과 레이아웃 반환을 적절하게 직렬화하는 것은 클라이언트의 책임입니다.

---
###### **12.5.5.2.1.  Layout Recall and Return Sequencing**

레이아웃 작업 순서 지정과 관련된 한 가지 중요한 문제는 콜백과 관련이 있습니다. 프로토콜은 LAYOUTGET 또는 LAYOUTRETURN 작업에 대한 응답과 후속 CB\_LAYOUTRECALL 간의 경합을 방어해야 합니다. 클라이언트는 클라이언트가 아직 응답을 받지 못한 하나 이상의 미해결 LAYOUTGET 또는 LAYOUTRETURN 작업을 암시하는 CB\_LAYOUTRECALL을 처리해서는 안 됩니다. 클라이언트는 리콜 레이아웃 stateid의 "seqid" 필드를 검사하여 이러한 CB\_LAYOUTRECALL을 감지합니다. "seqid"가 클라이언트가 현재 기록한 것보다 정확히 하나 높지 않고 클라이언트에 미해결된 LAYOUTGET 및/또는 LAYOUTRETURN 작업이 하나 이상 있는 경우 클라이언트는 서버가 미해결된 LAYOUTGET에 대한 응답을 보낸 후 CB\_LAYOUTRECALL을 보냈다는 것을 알고 있습니다. 레이아웃반환. 클라이언트는 CB\_LAYOUTRECALL에 의해 제공된 seqid보다 작은 seqid를 가진 해당 파일에 대한 미해결 LAYOUTGET 및 LAYOUTRETURN 작업에 대한 모든 응답을 처리할 때까지 이러한 CB\_LAYOUTRECALL을 처리하기 전에 기다려야 합니다\(lor\_stateid, 섹션 20.3 참조\).\(MUST NOT, MUST\)

seqid 기반 메커니즘 외에도 섹션 2.10.6.3에서는 클라이언트가 콜백 경쟁 조건을 감지하고 CB\_LAYOUTRECALL과 같은 처리를 지연할 수 있도록 하는 세션 메커니즘을 설명합니다. 서버는 CB\_LAYOUTRECALL 앞에 오는 CB\_SEQUENCE에서 충돌하는 작업을 참조할 수 있습니다. 서버는 콜백을 보내기 전에 이미 이러한 작업에 대한 응답을 보냈기 때문에 응답은 CB\_LAYOUTRECALL과 경쟁할 수 있습니다. 클라이언트는 CB\_LAYOUTRECALL을 처리하기 전에 참조된 모든 호출이 완료되고 레이아웃 상태 보기를 업데이트할 때까지 기다려야 합니다.\(MAY, MUST\)

---
####### **12.5.5.2.1.1.  Get/Return Sequencing**

이 프로토콜을 사용하면 클라이언트가 동시 LAYOUTGET 및 LAYOUTRETURN 작업을 서버에 보낼 수 있습니다. 프로토콜은 서버가 요청이 생성된 순서대로 요청을 처리할 수 있는 수단을 제공하지 않습니다. 그러나 클라이언트는 레이아웃 stateid의 "seqid" 필드를 사용하여 서버에서 처리되지 않은 병렬 작업의 순서를 결정할 수 있습니다. 따라서 미해결 LAYOUTGET 작업으로 검색된 레이아웃이 동일한 파일의 미해결 LAYOUTRETURN에서 반환된 레이아웃과 교차하는 경우 충돌하는 두 작업이 처리되는 순서에 따라 겹치는 레이아웃의 최종 상태가 결정됩니다. 순서는 각 작업에서 반환된 "seqid"에 의해 결정됩니다. seqid가 더 높은 작업이 나중에 실행되었습니다.

클라이언트가 동일한 파일에 대해 여러 병렬 LAYOUTGET 작업을 보내거나 동일한 파일에 대해 여러 병렬 LAYOUTRETURN 작업을 보내거나 둘을 혼합하여 보내는 것이 허용됩니다.

예를 들어 LAYOUTGET을 합성하거나 OPEN과 LAYOUTGET을 합성할 때 클라이언트가 LAYOUTGET 작업에 현재 stateid\(섹션 16.2.3.1.2 참조\)를 사용하는 것이 허용됩니다. LAYOUTRETURN을 합성할 때 현재 stateid를 사용하는 것도 허용됩니다.

서버가 이를 순서대로 처리해야 하기 때문에 동일한 COMPOUND 요청에서 동일한 파일에 대한 LAYOUTRETURN 및 LAYOUTGET 작업을 결합할 때 클라이언트가 현재 stateid를 사용하는 것이 허용됩니다. 그러나 클라이언트가 그러한 COMPOUND 요청을 보내는 경우 동일한 파일에 대해 동시에 둘 이상의 미해결 작업이 있어서는 안 되며, 동일한 파일에 대해 동시에 미해결된 다른 LAYOUTGET 또는 LAYOUTRETURN 작업이 있어서도 안 됩니다.\(MUST, MUST NOT\)

---
####### **12.5.5.2.1.2.  Client Considerations**

LAYOUTGET을 보낸 pNFS 클라이언트를 생각해 보세요. LAYOUTGET에 대한 응답을 받기 전에 범위가 겹치는 동일한 파일에 대해 CB\_LAYOUTRECALL을 받습니다. 고객이 리콜의 레이아웃 stateid를 통해 구별할 수 있는 두 가지 가능성이 있습니다.

1. 서버는 리콜을 보내기 전에 LAYOUTGET을 처리했습니다. 따라서 LAYOUTGET은 CB\_LAYOUTRECALL을 처리하기 위해 반환되어야 하는 레이아웃 정보를 전달할 수 있으므로 기다려야 합니다.

2. 서버는 LAYOUTGET을 받기 전에 콜백을 보냈습니다. 서버는 CB\_LAYOUTRECALL이 처리될 때까지 LAYOUTGET에 응답하지 않습니다.

이러한 가능성을 구별할 수 없는 경우 클라이언트는 첫 번째 경우에서 호출을 처리하기 전에 LAYOUTGET 응답을 기다려야 하지만 두 번째 경우에서는 호출이 처리될 때까지 해당 응답이 도착하지 않으므로 교착 상태가 발생할 수 있습니다. 첫 번째 경우, 리콜 레이아웃 stateid의 "seqid"는 클라이언트가 기록한 것보다 2가 더 큽니다. 두 번째 경우에는 "seqid"가 클라이언트가 기록한 것보다 1이 더 큽니다. 이를 통해 클라이언트는 두 경우를 명확하게 구분할 수 있습니다. 따라서 고객은 어떤 가능성이 적용되는지 정확하게 알고 있습니다.

사례 1의 경우 클라이언트는 회수를 처리하기 전에 LAYOUTGET 응답을 기다려야 한다는 것을 알고 있습니다\(또는 클라이언트가 NFS4ERR\_DELAY를 반환할 수 있음\).

사례 2의 경우 클라이언트는 호출을 처리하기 전에 LAYOUTGET 응답을 기다리지 않습니다. 기다리면 교착 상태가 발생하기 때문입니다. 따라서 클라이언트에서의 작업은 클라이언트가 LAYOUTGET 작업에 대한 서버의 이전 응답을 아직 확인하지 못한 경우에만 대기하면 됩니다.

호출된 범위에 대한 최종 LAYOUTRETURN 작업이 완료되면 호출 프로세스가 완료된 것으로 간주될 수 있습니다. LAYOUTRETURN은 CB\_LAYOUTRECALL에 지정된 레이아웃 stateid\(seqid 포함\)를 사용합니다. 클라이언트가 회수 처리 시 여러 LAYOUTRETURN을 사용하는 경우 첫 번째 LAYOUTRETURN은 CB\_LAYOUTRECALL에 지정된 레이아웃 상태 ID를 사용합니다. 후속 LAYOUTRETURN은 일반적인 경우와 마찬가지로 가장 높은 seqid를 사용합니다.

---
####### **12.5.5.2.1.3.  Server Considerations**

메타데이터 서버의 관점에서 경쟁을 생각해 보세요. 메타데이터 서버가 CB\_LAYOUTRECALL을 보냈고 CB\_LAYOUTRECALL에 응답하는 LAYOUTRETURN 전에 동일한 파일에 대해 겹치는 LAYOUTGET을 받았습니다. 세 가지 경우가 있습니다:

1. 클라이언트는 처리하기 전에 LAYOUTGET을 보냈습니다.

- CB\_LAYOUTRECALL. LAYOUTGET 인수의 레이아웃 stateid에 있는 "seqid"는 CB\_LAYOUTRECALL의 "seqid"보다 1 적습니다. 서버는 NFS4ERR\_RECALLCONFLICT를 클라이언트에 반환하며, 이는 보류 중인 회수가 있음을 클라이언트에 나타냅니다.

2. 클라이언트는 처리 후 LAYOUTGET을 보냈습니다.

- CB\_LAYOUTRECALL, 그러나 LAYOUTRETURN 및 해당 처리를 완료한 CB\_LAYOUTRECALL에 대한 응답 이전에 LAYOUTGET이 도착했습니다. LAYOUTGET 레이아웃 stateid의 "seqid"는 CB\_LAYOUTRECALL의 "seqid"와 같거나 그보다 큽니다. 서버가 CB\_LAYOUTRECALL에 대한 응답을 받지 못하여 NFS4ERR\_RECALLCONFLICT를 반환합니다.

3. 클라이언트는 처리 후 LAYOUTGET을 보냈습니다.

- CB\_LAYOUTRECALL; 서버는 CB\_LAYOUTRECALL 응답을 받았지만 해당 처리를 완료한 LAYOUTRETURN 전에 LAYOUTGET이 도착했습니다. LAYOUTGET 레이아웃 stateid의 "seqid"는 CB\_LAYOUTRECALL의 "seqid"와 동일합니다. 서버는 CB\_LAYOUTRECALL에 대한 응답을 받았으므로 NFS4ERR\_RETURNCONFLICT를 반환합니다.

---
####### **12.5.5.2.1.4.  Wraparound and Validation of Seqid**

"seqid" 값은 0이 될 수 없고 stateid의 "seqid" 값은 CB\_LAYOUTRECALL 작업에서 변경되기 때문에 레이아웃 stateid 처리 규칙은 프로토콜의 다른 stateid와 다릅니다. 레이아웃 작업의 고유한 병렬성과 결합된 0이 아닌 요구 사항은 LAYOUTGET 및 LAYOUTRETURN 작업 집합이 "seqid"에 대해 동일한 값을 포함할 수 있음을 의미합니다. 서버는 레이아웃 상태 ID의 "seqid"를 증가시킬 때 섹션 2.10.6.1에 설명된 대로 모듈로 산술의 약간 수정된 버전을 사용합니다. 차이점은 0은 "seqid"에 대한 유효한 값이 아니라는 것입니다. "seqid" 값이 0xFFFFFFFF이면 다음 유효한 값은 0x00000001입니다. 모듈로 산술은 위의 섹션 12.5.5.2.1.3에 설명된 대로 CB\_LAYOUTRECALL 이벤트 처리에서 "seqid" 값을 비교하는 데에도 사용됩니다.

섹션 12.5.5.2.1.3에 설명된 대로 서버가 CB\_LAYOUTRECALL 사용 시 "seqid"의 유효성을 검사하는 것처럼 서버도 "seqid" 값이 적절한 범위 내에 있는지 확인합니다. 이 범위는 서버가 레이아웃 상태 ID에 대해 지원하는 병렬 처리 수준을 나타냅니다. 클라이언트가 여러 레이아웃 작업을 서버에 병렬로 보내는 경우 정의에 따라 제공된 stateid의 "seqid" 값은 서버가 보유한 현재 "seqid"가 아닙니다. 병렬 처리의 범위는 가장 높거나 현재의 "seqid"부터 과거의 "seqid" 값까지입니다. 논의를 돕기 위해 레이아웃 상태 ID에 대한 서버의 현재 "seqid" 값은 SERVER\_CURRENT\_SEQID로 정의됩니다. 서버에 허용되는 가장 낮은 "seqid" 값은 PAST\_SEQID로 표시됩니다. 유효한 "seqid" 범위 또는 병렬 처리 범위의 값은 VALID\_SEQID\_RANGE입니다. 따라서 VALID\_SEQID\_RANGE = SERVER\_CURRENT\_SEQID - PAST\_SEQID가 유지됩니다. 다음에서 모든 연산은 위에서 설명한 모듈로 연산입니다.

서버는 최소 VALID\_SEQID\_RANGE를 지원해야 합니다. 최소값은 다음과 같이 정의됩니다. VALID\_SEQID\_RANGE = \(ca\_maxOperations\(i\) - 1\)의 1..N에 대한 합계. 여기서 N은 세션 전방 채널의 수이고 ca\_maxOperations\(i\)는 i의 CREATE\_SESSION에서 반환된 ca\_maxOperations의 값입니다. '번째 세션. "- 1"의 이유는 필요한 SEQUENCE 작업을 허용하기 위한 것입니다. 서버는 최소값보다 큰 VALID\_SEQID\_RANGE 값을 지원할 수 있습니다. 최대 VALID\_SEQID\_RANGE는 \(2^\(32\) - 2\)입니다\(0은 유효한 "seqid" 값이 아님을 고려\).\(MUST, MAY\)

서버가 "seqid"가 0임을 발견하면 NFS4ERR\_BAD\_STATEID 오류가 클라이언트에 반환됩니다. 서버는 "seqid"의 유효성을 추가로 검증하여 병렬 처리 범위 VALID\_SEQID\_RANGE 내에 있는지 확인합니다. "seqid" 값이 해당 범위를 벗어나면 NFS4ERR\_OLD\_STATEID 오류가 클라이언트에 반환됩니다. NFS4ERR\_OLD\_STATEID를 수신하면 클라이언트는 다른 레이아웃 요청 처리를 기반으로 레이아웃 요청의 stateid를 업데이트하고 해당 작업을 서버에 다시 보냅니다.

---
####### **12.5.5.2.1.5.  Bulk Recall and Return**

pNFS는 특정 fsid\(LAYOUTRECALL4\_FSID, LAYOUTRETURN4\_FSID\) 또는 클라이언트 ID\(LAYOUTRECALL4\_ALL, LAYOUTRETURN4\_ALL\)에 속하는 파일에 대한 모든 레이아웃의 호출 및 반환을 지원합니다. "대량" stateid가 없으므로 seqid를 통한 인종 감지는 불가능합니다. 서버는 다른 호출이 진행 중이거나 해당 LAYOUTRETURN이 진행 중이거나 보류 중인 동안 대량 호출을 시작해서는 안 됩니다. 클라이언트에 보류 중이거나 진행 중인 LAYOUTRETURN, CB\_LAYOUTRECALL 또는 LAYOUTGET이 있는 동안 서버가 대량 회수를 보내는 경우 클라이언트는 NFS4ERR\_DELAY를 반환합니다. 대량 회수가 진행되는 동안 클라이언트가 LAYOUTGET 또는 LAYOUTRETURN을 보내는 경우 서버는 NFS4ERR\_RECALLCONFLICT를 반환합니다. 서버가 대량 호출에서 NFS4ERR\_DELAY를 수신한 후 클라이언트가 LAYOUTGET 또는 LAYOUTRETURN을 보내는 경우 앞으로 진행을 보장하기 위해 서버는 NFS4ERR\_RECALLCONFLICT를 반환할 수 있습니다.\(MUST NOT, MAY\)

LAYOUTRECALL4\_ALL의 CB\_LAYOUTRECALL이 전송되면 서버는 클라이언트가 LAYOUTCOMMIT 작업을 제외한 모든 레이아웃 상태 ID를 사용하도록 허용해서는 안 됩니다. 클라이언트가 LAYOUTRECALL4\_ALL의 CB\_LAYOUTRECALL을 수신하면 LAYOUTCOMMIT 작업을 제외하고 레이아웃 상태 ID를 사용해서는 안 됩니다. LAYOUTRETURN4\_ALL의 LAYOUTRETURN이 전송되면 클라이언트 ID에 부여된 모든 레이아웃 상태 ID가 해제됩니다. 클라이언트는 레이아웃 상태 ID를 다시 사용해서는 안 됩니다. 새로운 레이아웃 상태 ID를 얻으려면 반드시 LAYOUTGET을 사용해야 합니다.\(MUST NOT, MUST NOT, MUST NOT, MUST\)

LAYOUTRECALL4\_FSID의 CB\_LAYOUTRECALL이 전송되면 서버는 클라이언트가 LAYOUTCOMMIT 작업을 제외하고 지정된 fsid를 가진 파일을 참조하는 레이아웃 상태 ID를 사용하도록 허용해서는 안 됩니다. 클라이언트가 LAYOUTRECALL4\_ALL의 CB\_LAYOUTRECALL을 수신하면 LAYOUTCOMMIT 작업을 제외하고 지정된 fsid를 가진 파일을 참조하는 레이아웃 상태 ID를 사용해서는 안 됩니다. LAYOUTRETURN4\_FSID의 LAYOUTRETURN이 전송되면 참조된 fsid에 부여된 모든 레이아웃 상태 ID가 해제됩니다. 클라이언트는 참조된 fsid가 있는 파일에 대해 해제된 레이아웃 상태 ID를 다시 사용해서는 안 됩니다. 이후에 참조된 fsid가 있는 파일에 대해 레이아웃을 사용하려면 클라이언트는 해당 파일에 대한 새 레이아웃 stateid를 얻기 위해 먼저 LAYOUTGET 작업을 보내야 합니다.\(MUST NOT, MUST NOT, MUST NOT, MUST\)

서버가 대량 CB\_LAYOUTRECALL을 전송하고 LAYOUTGET 또는 stateid가 포함된 LAYOUTRETURN을 수신하는 경우 서버는 NFS4ERR\_RECALLCONFLICT를 반환해야 합니다. 서버가 대량 CB\_LAYOUTRECALL을 전송하고 CB\_LAYOUTRECALL의 lor\_recalltype과 동일하지 않은 lr\_returntype을 사용하여 LAYOUTRETURN을 수신한 경우 서버는 NFS4ERR\_RECALLCONFLICT를 반환해야 합니다.\(MUST, MUST\)

---
#### **12.5.6.  Revoking Layouts**

병렬 NFS를 사용하면 서버가 회수에 응답하지 않거나 임대를 제때 갱신하지 못하는 클라이언트의 레이아웃을 취소할 수 있습니다. 레이아웃 유형에 따라 서버는 레이아웃을 취소하고 데이터 서버에 대한 클라이언트 I/O와 관련하여 특정 작업을 수행할 수 있습니다.

---
#### **12.5.7.  Metadata Server Write Propagation**

메타데이터 서버를 통해 작성된 비동기 쓰기는 저장 장치에 느리게 전파될 수 있습니다. 메타데이터 서버를 통해 비동기적으로 작성된 데이터의 경우 해당 저장 장치에서 읽기를 수행하는 클라이언트는 메타데이터 서버에서 COMMIT가 발생할 때까지 새로 작성된 데이터를 볼 수 있다는 보장이 없습니다. 쓰기가 보류 중인 동안 저장 장치에 대한 읽기는 이전 데이터, 새 데이터 또는 새 데이터와 이전 데이터의 혼합을 제공할 수 있습니다. 동기식 WRITE 또는 COMMIT\(비동기식으로 작성된 데이터의 경우\)가 완료되면 메타데이터 서버는 저장 장치가 새 데이터를 제공하고 데이터가 안정적인 저장소에 기록되었는지 확인해야 합니다. 서버가 이러한 제약 조건을 준수할 수 없는 방식으로 저장소를 구현하는 경우 올바르게 처리할 수 없는 읽기가 수행되는 것을 방지하기 위해 레이아웃을 호출해야 합니다. 서버가 관련 WRITE 작업에 응답하기 전에 레이아웃을 불러와야 합니다.\(MUST, MUST, MUST\)

---
### **12.6.  pNFS Mechanics**

이 섹션에서는 pNFS 클라이언트에서 메타데이터 서버 및 스토리지 장치로 이동하는 작업 흐름을 설명합니다.

pNFS 클라이언트는 새 FSID를 발견하면 fs\_layout\_type\(섹션 5.12.1\) 속성에 대해 NFSv4.1 서버에 GETATTR을 보냅니다. 속성이 하나 이상의 레이아웃 유형을 반환하고 반환된 레이아웃 유형이 클라이언트가 지원하는 집합에 속한다면 클라이언트는 파일 시스템에 pNFS가 가능하다는 것을 알게 됩니다. 새 FSID를 반환한 서버에서 클라이언트가 EXCHGID4\_FLAG\_USE\_PNFS\_MDS를 반환한 EXCHANGE\_ID 결과에서 나온 클라이언트 ID를 가지고 있지 않은 경우 EXCHGID4\_FLAG\_USE\_PNFS\_MDS 비트가 설정된 서버에 EXCHANGE\_ID를 보내야 합니다. 서버의 응답에 EXCHGID4\_FLAG\_USE\_PNFS\_MDS가 없으면 fs\_layout\_type 속성에 명시된 것과 달리 서버는 pNFS를 지원하지 않으며 클라이언트는 해당 서버에 대해 pNFS를 사용할 수 없습니다. 이 경우 서버는 pNFS 작업에 대한 응답으로 NFS4ERR\_NOTSUPP를 반환해야 합니다.\(MUST, MUST\)

그런 다음 클라이언트는 영구 세션을 요청하는 세션을 생성하므로 GUARDED4의 createmode4를 통해 단일 왕복으로 단독 생성이 수행될 수 있습니다. 세션이 지속되지 않으면 클라이언트는 독점 생성을 위해 EXCLUSIVE4\_1을 사용합니다.

pNFS 지원 파일 시스템에서 파일을 생성하려는 경우 클라이언트는 OPEN 작업을 사용합니다. 생성에 사용되는 OPEN 시 제공될 수 있는 일반적인 속성 집합에는 OPTIONAL 레이아웃\_힌트 속성이 있습니다. 클라이언트는 레이아웃\_힌트를 사용하여 클라이언트가 레이아웃 유형 및 관련 레이아웃 세부 사항에 대한 선호도를 표현할 수 있습니다. UNCHECKED4, GUARDED4 또는 EXCLUSIVE4\_1의 createmode4를 사용하면 클라이언트가 생성 시에layout\_hint 속성을 제공할 수 있습니다. 클라이언트는 EXCLUSIVE4를 사용해서는 안 됩니다\(표 18 참조\). 클라이언트는 동일한 COMPOUND 내에서 OPEN 이후 GETATTR 작업을 결합하는 것이 좋습니다. 그런 다음 GETATTR은 새로 생성된 파일에 대한layout\_type 속성을 검색할 수 있습니다. 그러면 클라이언트는 서버가 파일에 대해 선택한 레이아웃 유형과 클라이언트가 사용해야 하는 저장 프로토콜을 알게 됩니다.\(MAY, MUST NOT, SHOULD\)

클라이언트가 기존 파일을 열려고 하면 파일이 지원하는 레이아웃 유형을 결정하는 GETATTR도 포함됩니다.

파일 생성 또는 일반 파일 열기의 GETATTR에는 클라이언트가 파일의 I/O에 대한 최적의 오프셋과 길이를 결정할 수 있도록layout\_blksize 및layout\_alignment 속성도 포함될 수 있습니다.

클라이언트가 GETATTR에서 반환된 레이아웃 유형을 지원하고 데이터 액세스에 pNFS를 사용하기로 선택했다고 가정하면 클라이언트는 OPEN에서 반환된 파일 핸들 및 stateid를 사용하여 LAYOUTGET을 전송하고 I/O를 수행할 범위를 지정합니다. 응답은 클라이언트가 요청한 범위의 하위 집합일 수 있는 레이아웃입니다. 여기에는 장치 ID와 장치 전체에서 데이터가 구성되는 방식\(또는 쓰기의 경우 데이터가 구성되는 방식\)에 대한 설명이 포함됩니다. 장치 ID와 데이터 설명은 레이아웃 유형에 특정한 형식으로 인코딩되지만 클라이언트는 이를 이해할 것으로 예상됩니다.

클라이언트가 I/O를 보내려고 할 때 레이아웃의 데이터 설명을 검사하여 I/O 명령을 보내야 하는 장치 ID를 결정합니다. 그런 다음 GEDEVICEINFO를 전송하여 장치 ID의 장치 주소를 찾습니다. 그런 다음 클라이언트는 레이아웃 유형에 정의된 스토리지 프로토콜을 사용하여 장치 ID의 장치 주소 중 하나로 I/O 요청을 보냅니다. 클라이언트에 전송할 I/O가 여러 개 있는 경우 이러한 I/O 요청은 병렬로 수행될 수 있습니다.

I/O가 WRITE인 경우 클라이언트는 어느 시점에서 LAYOUTCOMMIT를 사용하여 수정 시간과 파일의 새 크기\(파일 크기가 확장되었다고 판단되는 경우\)를 메타데이터 서버 및 수정된 데이터에 커밋할 수 있습니다. 파일 시스템에.

---
### **12.7.  Recovery**

pNFS 프로토콜의 분산 특성으로 인해 복구가 복잡합니다. 일반적으로 레이아웃에 대한 충돌 복구는 기본 NFSv4.1 프로토콜의 위임에 대한 충돌 복구와 유사합니다. 그러나 메타데이터 서버에 접속하지 않고 I/O를 수행할 수 있는 클라이언트의 기능은 파일 시스템 손상 가능성을 피하려면 올바르게 처리해야 하는 미묘한 문제를 야기합니다.

---
#### **12.7.1.  Recovery from Client Restart**

레이아웃에 대한 클라이언트 복구는 다른 잠금 및 위임 상태에 대한 클라이언트 복구와 유사합니다. pNFS 클라이언트가 다시 시작되면 이전에 소유했던 레이아웃에 대한 모든 정보가 손실됩니다. 서버가 이러한 리소스를 회수하고 충돌하는 레이아웃이 다른 클라이언트에 제공되도록 허용하는 방법에는 두 가지가 있습니다.

첫 번째는 고객의 임대 만료를 통한 것입니다. 클라이언트 복구 시간이 임대 기간보다 길면 클라이언트의 임대가 만료되고 서버는 상태가 해제될 수 있음을 알게 됩니다. 레이아웃의 경우 서버는 임대 만료 시 즉시 상태를 해제하거나 다른 레이아웃이 충돌하지 않는 한 임대 부활 가능성을 기다리면서 레이아웃이 지속되도록 허용할 수 있습니다.

두 번째는 임대 기간이 만료되는 데 걸리는 시간보다 짧은 시간 내에 클라이언트를 다시 시작하는 것입니다. 이러한 경우 클라이언트는 표준 EXCHANGE\_ID 프로토콜을 통해 서버에 접속합니다. 서버는 클라이언트의 co\_ownerid가 이전 클라이언트 호출의 co\_ownerid와 일치하지만 검증자가 다르다는 것을 알게 됩니다. 서버는 이를 클라이언트의 이전 호출과 관련된 모든 레이아웃 상태를 해제하는 신호로 사용합니다. 이 시나리오에서 클라이언트가 작성했지만 성공적인 LAYOUTCOMMIT에 포함되지 않은 데이터는 정의되지 않은 상태입니다. 그것은 기록되었을 수도 있고 지금은 사라졌을 수도 있습니다. 이는 허용 가능한 동작이며 원하는 수준의 안정성을 달성하기 위해 LAYOUTCOMMIT를 사용하는 것은 클라이언트의 책임입니다.

---
#### **12.7.2.  Dealing with Lease Expiration on the Client**

클라이언트가 임대가 만료되었다고 생각하는 경우 임대를 검증할 때까지 저장 장치에 I/O를 전송해서는 안 됩니다. 클라이언트는 메타데이터 서버에 SEQUENCE 작업을 보낼 수 있습니다. SEQUENCE 작업이 성공했지만 sr\_status\_flag에 SEQ4\_STATUS\_EXPIRED\_ALL\_STATE\_REVOKED, SEQ4\_STATUS\_EXPIRED\_SOME\_STATE\_REVOKED 또는 SEQ4\_STATUS\_ADMIN\_STATE\_REVOKED가 설정된 경우 클라이언트는 현재 보유된 레이아웃을 사용해서는 안 됩니다. 클라이언트는 임대 만료를 복구할 수 있는 두 가지 선택 사항이 있습니다. 첫째, 수정되었지만 커밋되지 않은 모든 데이터에 대해 클라이언트는 WRITE 또는 WRITE 및 COMMIT에 대해 FILE\_SYNC4 플래그를 사용하여 이를 메타데이터 서버에 씁니다. 둘째, 클라이언트는 서버와의 클라이언트 ID 및 세션을 다시 설정하고 수정된 데이터 범위에 대한 새로운 레이아웃과 장치 ID-장치 주소 매핑을 얻은 다음 새로 얻은 레이아웃을 사용하여 저장 장치에 데이터를 씁니다.\(MUST NOT, MUST NOT\)

메타데이터 서버의 sr\_status\_flags에 SEQ4\_STATUS\_RESTART\_RECLAIM\_NEEDED가 설정되어 있는 경우\(또는 SEQUENCE가 NFS4ERR\_BAD\_SESSION을 반환하고 CREATE\_SESSION이 NFS4ERR\_STALE\_CLIENTID를 반환하는 경우\) 메타데이터 서버가 다시 시작된 것이며 클라이언트는 섹션 12.7.4에 설명된 방법을 사용하여 복구해야 합니다.\(SHOULD\)

메타데이터 서버의 sr\_status\_flags에 SEQ4\_STATUS\_LEASE\_MOVED가 설정된 경우 클라이언트는 섹션 11.11.9.2에 설명된 절차에 따라 복구합니다. 그 후 클라이언트는 레이아웃 상태가 파일 시스템과 함께 이동되지 않았다는 표시를 받을 수 있습니다. 클라이언트는 이 섹션의 처음 두 단락에서 논의된 다른 적용 가능한 상황에서와 같이 회복합니다.

sr\_status\_flags가 상태 손실을 보고하지 않으면 클라이언트가 보유한 레이아웃에 대한 임대가 유효하고 갱신되며 클라이언트는 다시 한번 저장 장치에 I/O 요청을 보낼 수 있습니다.

클라이언트는 임대 만료 기간을 초과할 수 있는 저장 장치에 I/O를 전송해서는 안 되지만, 이것이 항상 가능한 것은 아닙니다. 예를 들어 I/O가 전송된 후 시작되고 I/O가 전송될 때까지 복구되지 않는 확장된 네트워크 파티션이 있습니다. /O 요청이 저장 장치에 의해 수신되었습니다. 따라서 메타데이터 서버 및/또는 저장 장치는 임대가 만료되기 전에 전송되고 임대가 만료된 후에 도착하는 I/O로부터 자신을 보호할 책임이 있습니다. 섹션 12.7.3을 참조하십시오.\(SHOULD NOT\)

---
#### **12.7.3.  Dealing with Loss of Layout State on the Metadata Server**

이는 다음 사항이 모두 참인 경우에 대한 설명입니다.

\* 메타데이터 서버가 다시 시작되지 않았습니다.

\* pNFS 클라이언트의 레이아웃이 삭제되었으며\(대개 클라이언트의 임대가 만료되었기 때문에\) 유효하지 않습니다.

\* pNFS 클라이언트의 I/O가 스토리지 장치에 도착합니다.

메타데이터 서버와 해당 저장 장치는 클라이언트를 펜싱하여 이 문제를 해결해야 합니다. 즉, 레이아웃 상태 손실 후 클라이언트에서 저장 장치로의 I/O 작업 실행을 방지하여 이 문제를 해결해야 합니다. 펜싱이 수행되는 방법에 대한 세부 사항은 레이아웃 유형에 따라 다릅니다. NFSv4.1 파일 기반 레이아웃에 대한 솔루션은 \(섹션 13.11\)에 설명되어 있으며, 다른 레이아웃 유형에 대한 솔루션은 해당 외부 사양 문서에 있습니다.\(MUST, MUST\)

---
#### **12.7.4.  Recovery from Metadata Server Restart**

pNFS 클라이언트는 섹션 8.4.2에 설명되고 섹션 12.7.2, 단락 2의 pNFS 관련 컨텍스트에서 논의된 방법을 통해 메타데이터 서버가 다시 시작되었음을 발견합니다. 클라이언트는 레이아웃 사용을 중지하고 장치에 대한 장치 ID를 삭제해야 합니다. 이전에 메타데이터 서버로부터 받은 주소 매핑입니다. 그렇게 하고 클라이언트가 LAYOUTCOMMIT를 통해 레이아웃을 커밋하지 않고 저장 장치에 데이터를 썼다면 클라이언트, 메타데이터 서버 및 저장 장치가 모두 해당 상태에서 동기화되도록 하기 위해 클라이언트는 추가 작업을 수행해야 합니다. 자료.\(MUST\)

\* 클라이언트의 메모리에 아직 수정되고 기록되지 않은 데이터가 클라이언트의 메모리에 있는 경우 클라이언트는 두 가지 선택만 할 수 있습니다.

- 1. 클라이언트는 서버의 유예 기간 이후 LAYOUTGET을 통해 레이아웃을 얻어 저장 장치에 데이터를 쓸 수 있습니다.

- 2. 클라이언트는 WRITE\(18.32절\) 작업을 사용하여 메타데이터 서버를 통해 해당 데이터를 쓴 다음 원하는 대로 레이아웃을 얻을 수 있습니다.

\* 클라이언트가 저장 장치에 데이터를 비동기적으로 썼지만 여전히 메모리에 데이터 복사본이 있는 경우 위의 이전 글머리 기호에 나열된 복구 옵션을 사용할 수 있습니다. 메타데이터 서버도 유예 기간에 있는 경우 클라이언트는 다음 글머리 기호에서 아래 옵션을 사용할 수 있습니다.

\* 클라이언트의 메모리에 데이터 복사본이 없으며 메타데이터 서버가 아직 유예 기간에 있습니다. LAYOUTGET의 응답 내용이 이전 내용과 일치하지 않을 수 있으므로 클라이언트는 레이아웃을 회수하기 위해 LAYOUTGET\(유예 기간 내 또는 외부\)을 사용할 수 없습니다. 범위가 다를 수도 있고 클라이언트가 동일한 범위를 얻을 수도 있지만 레이아웃의 내용이 다를 수 있습니다. 레이아웃의 내용이 동일해 보이더라도 장치 ID는 다른 장치 주소에 매핑될 수 있으며, 장치 주소가 동일하더라도 장치 주소는 다른 저장 장치에 할당되었을 수 있습니다. 위에서 설명한 복구 시나리오에 따라 저장 장치에서 데이터를 검색하고 이를 메타데이터 서버에 쓰는 옵션을 사용할 수 없습니다. 왜냐하면 범위를 장치 ID로, 장치 ID를 장치 주소로, 장치 주소를 물리적 장치로 매핑하기 때문입니다. 오래되었으며 새로운 LAYOUTGET을 통한 새로운 매핑으로는 문제가 해결되지 않습니다.

이 시나리오의 유일한 복구 옵션은

- 재생 모드의 LAYOUTCOMMIT. 메타데이터 서버는 유예 기간 동안 이를 수락합니다. 재생 모드에서 LAYOUTCOMMIT를 사용하면 메타데이터 서버에 레이아웃이 변경되었음을 알립니다. 메타데이터 서버는 유예 기간이 끝나기 전, 즉 파일 시스템에 대한 업데이트를 허용하기 전에 이 정보를 수신하는 것이 중요합니다.

회수 모드에서 LAYOUTCOMMIT를 전송하기 위해 클라이언트는

- 작업 인수\(18.42.1절\)의 loca\_reclaim 필드를 TRUE로 설정합니다. 메타데이터 서버의 복구 유예 기간 동안\(복구 유예 기간 동안에만\) 메타데이터 서버는 loca\_reclaim 필드가 TRUE로 설정된 LAYOUTCOMMIT 요청을 수락할 준비가 되어 있습니다.

- loca\_reclaim이 TRUE이면 클라이언트는 메타데이터 서버를 다시 시작하기 전에 발생한 레이아웃에 대한 변경 사항을 커밋하려고 시도합니다. 메타데이터 서버는 인수의 loca\_layoutupdate 필드에 대해 일부 일관성 검사를 적용하여 클라이언트가 저장 장치에 기록된 데이터를 파일 시스템에 커밋할 수 있는지 여부를 결정합니다. loca\_layoutupdate 필드는 데이터 유형이layoutupdate4이고 레이아웃 유형별 콘텐츠\(loca\_layoutupdate의 lou\_body 필드에 있음\)를 포함합니다. loca\_layoutupdate가 가질 수 있는 레이아웃 유형별 정보는 섹션 12.5.4.3에서 논의됩니다. loca\_layoutupdate에 대한 메타데이터 서버의 일관성 검사가 성공하면 메타데이터 서버는 저장 장치에 기록된 데이터\(인수 loca\_offset, loca\_length 및 loca\_layoutupdate 필드에 설명된 대로\)를 커밋해야 합니다. loca\_layoutupdate에 대한 메타데이터 서버의 일관성 검사가 실패하면 메타데이터 서버는 LAYOUTCOMMIT 작업을 거부하고 파일 시스템을 변경하지 않습니다. 그러나 loca\_reclaim TRUE를 사용한 LAYOUTCOMMIT가 실패할 때마다 pNFS 클라이언트는 <loca\_offset, loca\_length\>에 정의된 범위의 모든 데이터를 잃게 됩니다. 클라이언트는 메모리에 동기식 또는 비동기식으로 기록된 모든 데이터를 캐시하고 LAYOUTCOMMIT가 성공할 때까지 캐시된 데이터를 해제하지 않음으로써 이러한 위험을 방어할 수 있습니다. 이 조건은 모든 레이아웃 유형에 적용되지 않습니다. 예를 들어 파일 기반 저장 장치에는 이러한 제한이 적용되지 않습니다.\(MUST\)

\* 클라이언트의 메모리에 데이터 복사본이 없으며 메타데이터 서버가 더 이상 유예 기간에 있지 않습니다. 즉, 메타데이터 서버가 NFS4ERR\_NO\_GRACE를 반환합니다. 위 글머리 기호의 시나리오와 마찬가지로 LAYOUTCOMMIT 실패는 <loca\_offset, loca\_length\> 범위의 데이터가 손실되었음을 의미합니다. 위험에 대한 방어 방법은 동일합니다. 즉, LAYOUTCOMMIT가 성공할 때까지 클라이언트에 기록된 모든 데이터를 캐시합니다.

---
#### **12.7.5.  Operations during Metadata Server Grace Period**

지금까지 일부 복구 시나리오에서는 일부 작업\(즉, WRITE 및 LAYOUTGET\)이 메타데이터 서버의 유예 기간 동안 허용될 수 있다고 언급했습니다. 메타데이터 서버는 유예 기간 동안 이러한 작업을 허용할 수 있습니다. LAYOUTGET의 경우 메타데이터 서버는 그러한 요청을 처리하는 것이 임박한 LAYOUTCOMMIT 회수 요청과 충돌하지 않는다는 것을 확실하게 결정해야 합니다. WRITE의 경우 메타데이터 서버는 요청 처리가 임박한 OPEN 또는 파일에 필수 바이트 범위 잠금이 활성화된 LOCK과 충돌하지 않는지 확실하게 결정해야 합니다.

앞서 언급한 것처럼 편의상 메타데이터 서버는 유예 기간 동안 일부 작업\(즉, WRITE 및 LAYOUTGET\)을 거부할 수 있습니다. 가장 간단한 올바른 접근 방식은 NFS4ERR\_GRACE 오류를 반환하여 모든 비재확보 pNFS 요청 및 WRITE 작업을 거부하는 것이기 때문입니다. 그러나 저장 프로토콜\(레이아웃 유형에 따라 다름\) 및 메타데이터 서버 구현에 따라 메타데이터 서버는 특정 요청이 안전한지 결정할 수 있습니다. 예를 들어, 메타데이터 서버는 각 파일에 대한 임시 할당 매핑을 안정적인 저장소에 저장할 수 있을 뿐만 아니라 잠재적으로 충돌하는 OPEN 공유 모드 및 재시작 시 적용되었을 수 있는 필수 바이트 범위 잠금에 대한 정보와 메타데이터 서버를 저장할 수 있습니다. 복구 유예 기간 동안 이 정보를 사용하여 WRITE 요청이 안전한지 확인할 수 있습니다.

---
#### **12.7.6.  Storage Device Recovery**

저장 장치 재시작 시 복구는 주로 사용 중인 레이아웃 유형에 따라 달라집니다. 그러나 클라이언트가 비동기적으로 작성된 수정되고 커밋되지 않은 데이터를 보유하는 동안 저장 장치가 충돌한 것을 발견한 경우 클라이언트가 사용할 수 있는 몇 가지 일반적인 기술이 있습니다. 무엇보다도 클라이언트는 수정된 데이터를 보유하고 있으며 다른 어떤 것도 수행하지 않으므로 커밋되지 않은 데이터를 복구하는 데 필요한 정보를 가진 유일한 클라이언트라는 점을 인식하는 것이 중요합니다. 둘째, 최선의 해결책은 클라이언트가 부주의하게 실수를 하고 수정된 데이터를 다른 경로를 통해 다시 쓰려고 시도하는 것입니다.

클라이언트는 WRITE4args의 stable 필드가 FILE\_SYNC4로 설정된 상태에서 즉시 데이터를 메타데이터 서버에 써야 합니다. 이 작업을 수행하면 원래 저장 장치를 기다릴 필요가 없습니다.\(SHOULD\)

---
### **12.8.  Metadata and Storage Device Roles**

메타데이터 서버와 저장 장치를 모두 구현하는 데 동일한 물리적 하드웨어가 사용되는 경우 동일한 하드웨어 엔터티는 두 가지 서로 다른 역할을 구현하는 것으로 이해되어야 하며 하드웨어가 어떤 역할을 실행하는지 명확하게 이해하는 것이 중요합니다. 언제든지.

두 가지 하위 사례를 구별할 수 있습니다.

1. 저장 장치는 NFSv4.1을 저장 프로토콜로 사용합니다. 즉, 동일한 물리적 하드웨어가 메타데이터와 데이터 서버를 모두 구현하는 데 사용됩니다. 여러 역할을 처리하는 방법에 대한 설명은 섹션 13.1을 참조하세요.

2. 저장 장치는 NFSv4.1을 저장 프로토콜로 사용하지 않으며, 동일한 물리적 하드웨어를 사용하여 메타데이터와 저장 장치를 모두 구현합니다. 메타데이터 서버 및 저장 장치에 액세스하는 데 고유한 네트워크 주소가 사용되는지 여부는 중요하지 않습니다. 이는 사용 중인 상위 계층 프로토콜\(NFSv4.1 또는 비NFSv4.1\)을 통해 공통 서버 네트워크 주소에 대한 요청이 어느 역할로 전달되는지가 pNFS 클라이언트 및 서버에 항상 명확하기 때문입니다.

---
### **12.9.  Security Considerations for pNFS**

pNFS는 파일 시스템 메타데이터와 데이터를 분리하고 두 가지 모두에 대한 액세스를 제공합니다. 메타데이터에 대한 액세스를 제공하는 pNFS 관련 작업\(섹션 12.3에 나열됨\)이 있습니다. 모든 기존 NFSv4.1 기존\(비pNFS\) 보안 메커니즘 및 기능은 메타데이터 액세스에 적용됩니다. pNFS 시스템의 구성 요소 조합\(그림 1 참조\)은 NFSv4에 대한 위협을 방어하기 위한 보안 대책을 포함하여 클라이언트에서 스토리지 장치에 액세스하는 엔터티와 관련하여 NFSv4.1의 보안 속성을 유지하는 데 필요합니다. 1은 이러한 위협이 중요하다고 간주되는 환경에서 방어 기능을 제공합니다.

경우에 따라 스토리지 장치 연결에 대한 보안 대책은 환경에서 pNFS 사용을 방지하기 위한 물리적 격리 또는 권장 사항의 형태를 취할 수 있습니다. 예를 들어, 도청을 방지하기 위해 일부 스토리지 프로토콜에 대한 기밀 보호를 제공하는 것은 비실용적일 수 있습니다. 이러한 프로토콜에 대한 도청이 대응책, 통신 채널의 물리적 격리\(예: 클라이언트에서 저장 장치로의 직접 연결을 통해\) 및/또는 pNFS 사용을 중단하기로 한 결정이 필요할 만큼 충분히 우려되는 환경에서는\( 예를 들어 기존 NFSv4.1로 대체하는 것이 적절한 조치일 수 있습니다.

저장 장치와의 통신이 클라이언트-메타데이터 서버 통신과 동일한 위협에 노출되는 경우 해당 통신에 사용되는 프로토콜은 NFSv4.1용 RPCSEC\_GSS를 통해 사용할 수 있는 보안 메커니즘만큼 강력하거나 약하지 않은 보안 메커니즘을 제공해야 합니다. LAYOUT4\_NFSV4\_1\_FILES 레이아웃에 사용되는 스토리지 프로토콜\(섹션 13 참조\)을 제외하고, 즉 NFSv4.1을 제외하고 스토리지 액세스 프로토콜에 대한 보안 메커니즘을 지정하는 것은 이 문서의 범위를 벗어납니다.

pNFS 구현은 NFSv4.1의 액세스 제어를 제거해서는 안 됩니다. 클라이언트, 저장 장치 및 메타데이터 서버의 조합은 모든 클라이언트-저장 장치 파일 데이터 액세스가 NFSv4.1의 ACL 및 파일 열기 모드를 준수하는지 확인하는 역할을 합니다. 이는 클라이언트, 저장 장치 또는 둘 모두의 모든 액세스에 대해 이러한 검사를 모두 수행하는 것을 수반합니다\(해당되는 경우 저장 장치가 NFSv4.1 서버인 경우 저장 장치는 궁극적으로 섹션 13.9에 설명된 대로 액세스 제어를 담당합니다. 2\). pNFS 구성이 클라이언트에서만 이러한 검사를 수행하는 경우, 오작동하는 클라이언트가 무단 액세스를 얻을 위험은 그러한 pNFS 구성을 사용하는 것이 적절한 시기를 결정할 때 중요한 고려 사항입니다. 클라이언트 전용 액세스 확인이 NFSv4.1 액세스 제어가 올바르게 적용되고 있다는 충분한 보증을 제공하지 못하는 경우 이러한 레이아웃 유형을 사용하면 안 됩니다. \(LAYOUT4\_NFSV4\_1\_FILES에 대한 저장소 액세스 프로토콜이 NFSv4.1이고 따라서 LAYOUT4\_NFSv4\_1\_FILES를 통한 저장소 장치 액세스에 대한 보안 모델이 메타데이터 서버의 보안 모델과 동일하기 때문에 섹션 13에 설명된 파일 레이아웃 유형에서는 문제가 되지 않습니다.\) 레이아웃에 특정한 액세스 제어를 처리하려면 독자는 이 문서의 NFSv4.1/파일 기반 레이아웃\(섹션 13\), 블록 레이아웃\[48\] 및 객체 레이아웃\[47\]과 같은 레이아웃 사양을 조사해야 합니다.\(MUST NOT, SHOULD NOT\)

---
## **13.  NFSv4.1 as a Storage Protocol in pNFS: the File Layout Type**

이 섹션에서는 pNFS에 대한 NFSv4.1 파일 기반 레이아웃의 의미와 형식에 대해 설명합니다. NFSv4.1 파일 기반 레이아웃은 LAYOUT4\_NFSV4\_1\_FILES 레이아웃 유형을 사용합니다. LAYOUT4\_NFSV4\_1\_FILES 유형은 여러 NFSv4.1 데이터 서버에 걸쳐 스트라이핑 데이터를 정의합니다.

---
### **13.1.  Client ID and Session Considerations**

세션은 NFSv4.1의 필수 기능이며 이는 메타데이터 서버와 파일 기반\(NFSv4.1 기반\) 데이터 서버 모두로 확장됩니다.\(MUST\)

pNFS에서 서버가 수행하는 역할은 EXCHANGE\_ID에서 반환하는 결과에 따라 결정됩니다. 역할은 다음과 같습니다.

\* 메타데이터 서버\(EXCHGID4\_FLAG\_USE\_PNFS\_MDS는 결과 eir\_flags에 설정됨\)

```text
   *  Data server (EXCHGID4_FLAG_USE_PNFS_DS).
```

\* 비메타데이터 서버\(EXCHGID4\_FLAG\_USE\_NON\_PNFS\). 이는 pNFS와 관련된 작업\(예: LAYOUTGET\) 또는 속성을 지원하지 않는 NFSv4.1 서버입니다.

클라이언트는 일부 조합\(예: EXCHGID4\_FLAG\_USE\_NON\_PNFS | EXCHGID4\_FLAG\_USE\_PNFS\_MDS\)이 모순되더라도 EXCHGID4\_FLAG\_USE\_NON\_PNFS, EXCHGID4\_FLAG\_USE\_PNFS\_DS 또는 EXCHGID4\_FLAG\_USE\_PNFS\_MDS 중 0개 이상을 요청할 수 있습니다. 그러나 서버는 다음과 같은 허용 가능한 조합만 반환해야 합니다.\(MAY, MUST\)

```text
        +========================================================+
        | Acceptable Results from EXCHANGE_ID                    |
        +========================================================+
        | EXCHGID4_FLAG_USE_PNFS_MDS                             |
        +--------------------------------------------------------+
        | EXCHGID4_FLAG_USE_PNFS_MDS | EXCHGID4_FLAG_USE_PNFS_DS |
        +--------------------------------------------------------+
        | EXCHGID4_FLAG_USE_PNFS_DS                              |
        +--------------------------------------------------------+
        | EXCHGID4_FLAG_USE_NON_PNFS                             |
        +--------------------------------------------------------+
        | EXCHGID4_FLAG_USE_PNFS_DS | EXCHGID4_FLAG_USE_NON_PNFS |
        +--------------------------------------------------------+

                                 Table 8
```

위의 표에서 알 수 있듯이 서버는 하나 또는 두 개의 역할을 가질 수 있습니다. 서버는 메타데이터 서버이자 데이터 서버일 수도 있고, 데이터 서버이자 비메타데이터 서버일 수도 있습니다. EXCHANGE\_ID의 결과에 두 가지 역할을 반환하고 공통 클라이언트 ID를 통해 두 역할을 모두 제공하는 것 외에도 서버는 두 개의 EXCHANGE\_ID 결과 각각에서 각 역할에 대해 고유한 클라이언트 ID와 서버 소유자를 반환하여 두 가지 역할을 제공할 수 있습니다. 각 역할을 나타냅니다.

공통 클라이언트 ID로 제공되는 동시 pNFS 역할이 있는 서버의 경우, 클라이언트의 EXCHANGE\_ID 요청에 0이 있거나 eia\_flags에 설정된 비트 조합이 있는 경우 서버 결과는 다음 중 더 높은 값을 나타내는 비트를 설정해야 합니다. 클라이언트가 요청한 역할과 일치하는 기본 설정을 갖춘 서버 역할의 허용 가능한 조합입니다. 따라서 클라이언트 요청에 \(EXCHGID4\_FLAG\_USE\_NON\_PNFS | EXCHGID4\_FLAG\_USE\_PNFS\_MDS | EXCHGID4\_FLAG\_USE\_PNFS\_DS\) 플래그가 설정되어 있고 서버가 메타데이터 서버이자 데이터 서버인 경우 공통 클라이언트 ID로 두 역할을 모두 제공하는 경우 서버는 \(EXCHGID4\_FLAG\_USE\_PNFS\_MDS | EXCHGID4\_FLAG\_USE\_PN을 반환해야 합니다. FS\_DS\) 세트.\(SHOULD\)

여러 개의 동시 pNFS 역할\(각 역할은 고유한 클라이언트 ID로 제공됨\)이 있는 서버의 경우 클라이언트가 요청에 0 또는 역할 조합을 지정하는 경우 서버 결과는 지정된 조합에서 역할 중 하나만 반환해야 합니다. 클라이언트 요청으로. 서버 결과에 의해 지정된 역할이 클라이언트의 의도된 용도와 일치하지 않는 경우 클라이언트는 관심 있는 pNFS 역할만 지정하는 EXCHANGE\_ID를 보내야 합니다.\(SHOULD\)

pNFS 메타데이터 클라이언트가 NFSv4.1 데이터 서버를 참조하는 레이아웃을 얻는 경우 해당 데이터 서버에 클라이언트 ID가 필요합니다. EXCHANGE\_ID 결과에 EXCHGID4\_FLAG\_USE\_PNFS\_DS 플래그가 설정된 서버의 클라이언트 ID가 아직 없는 경우 클라이언트는 메타데이터 서버에 보낸 것과 동일한 co\_ownerid를 사용하여 EXCHANGE\_ID를 데이터 서버에 보내야 합니다. EXCHGID4\_FLAG\_USE\_PNFS\_DS 플래그가 인수에 설정되었습니다. 서버의 EXCHANGE\_ID 결과에 EXCHGID4\_FLAG\_USE\_PNFS\_DS가 설정된 경우 클라이언트는 클라이언트 ID를 사용하여 pNFS 데이터 작업을 교환하는 세션을 생성할 수 있습니다. 데이터 서버가 반환한 클라이언트 ID는 클라이언트 ID가 동일하지 않고 데이터 서버와 메타데이터 서버의 서버 소유자 및 서버 범위가 동일하지 않는 한 메타데이터 서버가 반환한 클라이언트 ID와 관계가 없습니다.

NFSv4.1에서 SEQUENCE 작업의 세션 ID는 클라이언트 ID를 의미하며, 클라이언트 ID는 서버에서 stateid를 올바른 클라이언트/서버 쌍에 매핑하는 데 사용될 수 있습니다. 그러나 데이터 서버에 stateid가 포함된 READ 또는 WRITE 작업이 표시되면 stateid가 메타데이터 서버의 클라이언트 ID와 연결되어 있고 이전 SEQUENCE 작업의 세션 ID가 클라이언트 ID와 연결되어 있기 때문입니다. 데이터 서버에는 COMPOUND 프로시저에서 메타데이터 서버를 확인할 수 있는 명확한 방법이 없으므로 stateid의 유효성을 검사할 방법이 없습니다. 권장되는 접근 방식 중 하나는 pNFS 서버가 레이아웃에 반환된 대로 데이터 서버 파일 핸들의 메타데이터 서버 라우팅 및/또는 ID 정보를 인코딩하는 것입니다.\(SHOULD\)

메타데이터 서버 라우팅 및/또는 ID 정보가 데이터 서버 파일 핸들에 인코딩된 경우 메타데이터 서버 ID 또는 위치가 변경되면 제공한 데이터 서버 파일 핸들이 유효하지 않게\(부실\)되므로 메타데이터 서버는 먼저 레이아웃을 불러와야 합니다. 데이터 서버 파일 핸들을 무효화해도 NFS 클라이언트의 데이터 캐시가 무효화되지 않습니다. 클라이언트의 캐시는 데이터 서버 파일 핸들을 메타 데이터 서버 파일 핸들에 매핑하고, 메타 데이터 서버 파일 핸들을 캐시된 데이터에 매핑해야 합니다.\(MUST\)

서버가 메타데이터 서버이자 데이터 서버인 경우, 서버는 메타데이터 서버로 전달되는 파일 작업과 데이터 서버로 전달되는 파일 작업을 구별해야 할 수도 있습니다. LAYOUTGET 작업에 의해 반환된 파일 핸들 값은 동일한 파일의 OPEN에 의해 ​​반환된 파일 핸들 값과 다른 것이 좋습니다.\(SHOULD\)

또 다른 시나리오는 메타데이터 서버와 저장 장치가 한 클라이언트의 관점에서 구별되고 역할이 다른 클라이언트의 관점에서 바뀌는 것입니다. 예를 들어 클러스터 파일 시스템 모델에서 한 클라이언트에 대한 메타데이터 서버는 다른 클라이언트에 대한 데이터 서버일 수 있습니다. NFSv4.1이 스토리지 프로토콜로 사용되는 경우 pNFS 서버는 특정 역할에 따라 파일 핸들 값을 인코딩해야 합니다.

---
#### **13.1.1.  Sessions Considerations for Data Servers**

섹션 2.10.11.2에는 서버가 세션을 삭제하는 것을 방지하기 위해 클라이언트가 임대를 갱신해야 한다고 명시되어 있습니다. EXCHANGE\_ID에 대한 응답에 EXCHGID4\_FLAG\_USE\_PNFS\_DS 역할 세트만 있는 경우\(13.6절에 설명된 대로\) GETATTR이 허용되지 않기 때문에 클라이언트는 데이터 서버의 Lease\_time 속성을 확인할 수 없습니다. 대신, 클라이언트가 EXCHGID4\_FLAG\_USE\_PNFS\_DS 역할만 반환하는 데이터 서버를 참조하는 레이아웃을 수신할 때마다 클라이언트는 레이아웃을 반환한 메타데이터 서버의 Lease\_time 속성이 데이터 서버에 적용된다고 가정할 수 있다는 것이 규칙입니다. 따라서 데이터 서버는 I/O를 제공하는 모든 메타데이터 서버의 모든 Lease\_time 속성 값을 인식해야 하며, 이러한 모든 Lease\_time 값의 최대값을 설정된 모든 클라이언트 ID 및 세션에 대한 임대 간격으로 사용해야 합니다. 그 위에.\(MAY, MUST\)

예를 들어, 하나의 메타데이터 서버에 20초의 Lease\_time 속성이 있고 두 번째 메타데이터 서버에 10초의 Lease\_time 속성이 있는 경우 두 서버 모두 EXCHGID4\_FLAG\_USE\_PNFS\_DS 전용 데이터 서버를 참조하는 레이아웃을 반환하는 경우 데이터 서버는 반드시 서로 다른 COMPOUND 요청에 대한 두 SEQUENCE 작업 간의 간격이 20초 미만인 경우 클라이언트의 임대입니다.\(MUST\)

---
### **13.2.  File Layout Definitions**

다음 정의는 LAYOUT4\_NFSV4\_1\_FILES 레이아웃 유형에 적용되며 다른 레이아웃 유형에도 적용될 수 있습니다.

단위. 단위는 데이터 서버에 기록되는 고정된 크기의 데이터 양입니다.

무늬. 패턴은 데이터 서버 세트 전체에 하나 이상의 동일한 크기의 단위를 배포하는 방법입니다. 패턴은 한 번 이상 반복됩니다.

줄무늬. 스트라이프는 해당 패턴이 반복되기 전에 일정한 패턴으로 데이터 서버 세트에 분산된 데이터 세트입니다.

스트라이프 수. 스트라이프 수는 패턴의 단위 수입니다.

스트라이프 너비. 스트라이프 너비는 바이트 단위의 스트라이프 크기입니다. 스트라이프 너비 = 스트라이프 수 \* 스트라이프 단위의 크기입니다.

이하 본 문서에서는 패턴으로 쓰여진 단위를 "스트라이프 단위"라 칭한다.

패턴에는 데이터 서버보다 더 많은 스트라이프 단위가 있을 수 있습니다. 그렇다면 일부 데이터 서버에는 스트라이프당 둘 이상의 스트라이프 장치가 있습니다. 스트라이프당 여러 스트라이프 유닛이 있는 데이터 서버는 각 유닛을 서로 다른 데이터 파일에 저장할 수 있습니다\(그리고 구현에 따라 고유한 데이터 파일 핸들을 각 데이터 파일에 할당할 수도 있습니다\).\(MAY\)

---
### **13.3.  File Layout Data Types**

높은 수준의 NFSv4.1 레이아웃 유형은 nfsv4\_1\_file\_layouthint4, nfsv4\_1\_file\_layout\_ds\_addr4 및 nfsv4\_1\_file\_layout4입니다.

SETATTR 작업은 레이아웃 힌트 속성\(섹션 5.12.4\)을 지원합니다. 클라이언트가 레이아웃 유형이 LAYOUT4\_NFSV4\_1\_FILES\(loh\_type 필드\)인 레이아웃 힌트\(레이아웃 힌트4 데이터 유형\)를 설정하면 loh\_body 필드에는 nfsv4\_1\_file\_layouthint4 데이터 유형의 값이 포함됩니다.

```text
   const NFL4_UFLG_MASK            = 0x0000003F;
   const NFL4_UFLG_DENSE           = 0x00000001;
   const NFL4_UFLG_COMMIT_THRU_MDS = 0x00000002;
   const NFL4_UFLG_STRIPE_UNIT_SIZE_MASK
                                   = 0xFFFFFFC0;

   typedef uint32_t nfl_util4;

   enum filelayout_hint_care4 {
           NFLH4_CARE_DENSE        = NFL4_UFLG_DENSE,

           NFLH4_CARE_COMMIT_THRU_MDS
                                   = NFL4_UFLG_COMMIT_THRU_MDS,

           NFLH4_CARE_STRIPE_UNIT_SIZE
                                   = 0x00000040,

           NFLH4_CARE_STRIPE_COUNT = 0x00000080
   };

   /* Encoded in the loh_body field of data type layouthint4: */

   struct nfsv4_1_file_layouthint4 {
           uint32_t        nflh_care;
           nfl_util4       nflh_util;
           count4          nflh_stripe_count;
   };
```

일반적인 레이아웃 힌트 구조는 섹션 3.3.19에 설명되어 있습니다. 클라이언트는 새로 생성된 파일에 사용할 기본 레이아웃 유형을 나타내기 위해layout\_hint\(섹션 5.12.4\) 속성의 레이아웃 힌트를 사용합니다. 레이아웃 힌트에 대한 LAYOUT4\_NFSV4\_1\_FILES 레이아웃 유형별 콘텐츠는 세 개의 필드로 구성됩니다. 첫 번째 필드인 nflh\_care는 클라이언트가 관심을 갖는 힌트 값을 나타내는 플래그 집합입니다. NFLH4\_CARE\_DENSE 플래그가 설정된 경우 클라이언트는 nflh\_util & NFL4\_UFLG\_DENSE\("&" 표현식의 값에 의해 제어되는 데이터 파일 압축 방식\(섹션 13.4.4\)에 대한 기본 설정인 두 번째 필드 nflh\_util에 표시합니다. 비트 AND 연산자를 나타냅니다\). NFLH4\_CARE\_COMMIT\_THRU\_MDS 플래그가 설정된 경우 클라이언트는 클라이언트가 COMMIT 작업을 메타데이터 서버 또는 데이터 서버\(섹션 13.7\)에 보내야 하는지에 대한 기본 설정을 나타냅니다. 이는 nflh\_util & NFL4\_UFLG\_COMMIT\_THRU\_MDS 값에 의해 제어됩니다. NFLH4\_CARE\_STRIPE\_UNIT\_SIZE 플래그가 설정된 경우 클라이언트는 nflh\_util & NFL4\_UFLG\_STRIPE\_UNIT\_SIZE\_MASK에 표시된 기본 스트라이프 단위 크기를 나타냅니다\(따라서 스트라이프 단위 크기는 64바이트의 배수여야 합니다\). 최소 스트라이프 단위 크기는 64바이트입니다. NFLH4\_CARE\_STRIPE\_COUNT 플래그가 설정된 경우 클라이언트는 세 번째 필드인 nflh\_stripe\_count에 스트라이프 수를 나타냅니다. 스트라이프 수에 스트라이프 단위 크기를 곱한 값이 스트라이프 너비입니다.\(MUST\)

LAYOUTGET이 LAYOUT4\_NFSV4\_1\_FILES 레이아웃\(lo\_content 필드의 loc\_type 필드에 표시됨\)을 반환하는 경우 lo\_content 필드의 loc\_body 필드에는 nfsv4\_1\_file\_layout4 데이터 유형의 값이 포함됩니다. 다른 콘텐츠 중에서 nfsv4\_1\_file\_layout4에는 데이터 유형 deviceid4의 저장 장치 ID\(nfl\_deviceid 필드\)가 있습니다. GEDEVICEINFO 작업은 장치 ID를 저장 장치 주소\(device\_addr4 유형\)에 매핑합니다. GEDEVICEINFO가 레이아웃 유형이 LAYOUT4\_NFSV4\_1\_FILES\(da\_layout\_type 필드\)인 장치 주소를 반환하는 경우 da\_addr\_body 필드에는 nfsv4\_1\_file\_layout\_ds\_addr4 데이터 유형의 값이 포함됩니다.

```text
   typedef netaddr4 multipath_list4<>;

   /*
    * Encoded in the da_addr_body field of
    * data type device_addr4:
    */
   struct nfsv4_1_file_layout_ds_addr4 {
           uint32_t        nflda_stripe_indices<>;
           multipath_list4 nflda_multipath_ds_list<>;
   };
```

nfsv4\_1\_file\_layout\_ds\_addr4 데이터 유형은 장치 주소를 나타냅니다. 이는 두 개의 필드로 구성됩니다.

1. nflda\_multipath\_ds\_list: 데이터 서버 목록의 배열입니다. 여기서 각 목록은 하나 이상의 요소일 수 있으며, 각 요소는 I/O 작업의 대상과 동일하게 역할을 할 수 있는 데이터 서버 주소를 나타냅니다\(섹션 13.5 참조\). 이 배열의 길이는 스트라이프 수와 다를 수 있습니다.

2. nflda\_stripe\_indices: nflda\_multipath\_ds\_list에 인덱싱하는 데 사용되는 인덱스 배열입니다. nflda\_stripe\_indices의 각 요소 값은 nflda\_multipath\_ds\_list의 요소 수보다 작아야 합니다. nflda\_multipath\_ds\_list의 각 요소는 nflda\_stripe\_indices의 하나 이상의 요소에 의해 참조되어야 합니다. nflda\_stripe\_indices의 요소 수는 항상 스트라이프 수와 같습니다.\(MUST, SHOULD\)

```text
   /*
    * Encoded in the loc_body field of
    * data type layout_content4:
    */
   struct nfsv4_1_file_layout4 {
            deviceid4      nfl_deviceid;
            nfl_util4      nfl_util;
            uint32_t       nfl_first_stripe_index;
            offset4        nfl_pattern_offset;
            nfs_fh4        nfl_fh_list<>;
   };
```

nfsv4\_1\_file\_layout4 데이터 유형은 레이아웃을 나타냅니다. 이는 다음 필드로 구성됩니다.

1. nfl\_deviceid: 유형의 값에 매핑되는 장치 ID입니다.

- nfsv4\_1\_file\_layout\_ds\_addr4.

2. nfl\_util : 데이터 타입의 nflh\_util 필드와 같습니다.

- nfsv4\_1\_file\_layouthint4는 각 데이터 서버의 파일 데이터가 압축되는 방식, 클라이언트가 COMMIT 작업을 메타데이터 서버나 데이터 서버로 보내야 하는지 여부, 스트라이프 단위 크기를 간략하게 표현합니다. 서버가 두 개 이상의 겹치는 레이아웃을 반환하는 경우 각 겹치는 레이아웃의 각 스트라이프 단위 크기는 동일해야 합니다.\(MUST\)

3. nfl\_first\_stripe\_index: 사용할 nflda\_stripe\_indices 배열의 첫 번째 요소에 대한 인덱스입니다.

4. nfl\_pattern\_offset: 이 필드는 스트라이핑 패턴이 시작되는 파일에 대한 논리적 오프셋입니다. 클라이언트의 논리적 I/O 오프셋\(예: read\(\) 또는 write\(\) 시스템 호출이 전송되기 전 POSIX 파일 설명자의 현재 오프셋\)을 스트라이프 단위 번호\(섹션 13.4.1 참조\)로 변환하는 데 필요합니다.

- 조밀한 패킹이 사용되는 경우 클라이언트의 논리적 I/O 오프셋을 스트라이프 단위 번호에 해당하는 데이터 서버의 파일에 대한 오프셋으로 변환하려면 nfl\_pattern\_offset도 필요합니다\(섹션 13.4.4 참조\).

- nfl\_pattern\_offset이 항상 lo\_offset과 동일하지는 않습니다. 예를 들어, LAYOUTGET 작업을 통해 클라이언트는 스트라이프 패턴이 오프셋 0에서 시작하는 파일의 오프셋 1000에서 시작하는 레이아웃을 요청할 수 있습니다.

5. nfl\_fh\_list: nflda\_multipath\_ds\_list 배열의 각 요소에 있는 각 데이터 서버 목록에 대한 데이터 서버 파일 핸들 배열입니다. nfl\_fh\_list의 요소 수는 희소 패킹 또는 조밀 패킹이 사용되는지 여부에 따라 달라집니다.

- \* 스파스 패킹이 사용되는 경우 nfl\_fh\_list의 요소 수는 다음 세 가지 값 중 하나여야 합니다.\(MUST\)

-      -  영. 이는 각 데이터 서버에 사용되는 파일 핸들이 메타데이터 서버의 OPEN 작업에 의해 반환된 파일 핸들과 동일함을 의미합니다.

-      -  하나. 이는 모든 데이터 서버가 nfl\_fh\_list\[0\]에 지정된 것과 동일한 파일 핸들을 사용한다는 것을 의미합니다.

- - nflda\_multipath\_ds\_list의 요소 수는 동일합니다. 따라서 이 경우 nflda\_multipath\_ds\_list\[X\]의 데이터 서버에 I/O 작업을 보낼 때 nfl\_fh\_list\[X\]의 파일 핸들을 사용해야 합니다.\(MUST\)

- 섹션 13.4.4의 희소 패킹에 대한 논의를 참조하세요.

- \* 조밀한 패킹이 사용되는 경우 nfl\_fh\_list의 요소 수는 nflda\_stripe\_indices의 요소 수와 동일해야 합니다. 따라서 nflda\_multipath\_ds\_list\[nflda\_stripe\_indices\[Y\]\]의 데이터 서버에 I/O 작업을 보낼 때 nfl\_fh\_list\[Y\]의 파일 핸들을 사용해야 합니다. 또한 nflda\_multipath\_ds\_list\[nflda\_stripe\_indices\[i\]\]와 nflda\_multipath\_ds\_list\[nflda\_stripe\_indices\[j\]\]의 교차점이 비어 있지 않도록 i와 j\(i != j\)가 존재할 때마다 nfl\_fh\_list\[i\]는 동일해서는 안 됩니다. nfl\_fh\_list\[j\]. 즉, 조밀한 패킹이 사용되는 경우 데이터 서버가 두 개 이상의 스트라이핑 패턴 단위로 나타나는 경우 데이터 서버에 대한 각 참조는 서로 다른 파일 핸들을 사용해야 합니다.\(MUST, MUST, MUST NOT, MUST\)

- 실제로 여러 개의 스트라이핑 패턴이 있는 경우\(하나 또는 여러 개의 LAYOUTGET 작업에서 반환된\) 데이터 유형 레이아웃4의 여러 개체가 존재하고 데이터 서버가 한 패턴 단위와 다른 단위의 대상인 경우 다른 패턴이면 각 데이터 서버에 대한 각 참조는 반드시 다른 파일 핸들을 사용해야 합니다.\(MUST\)

- 13.4.4절의 조밀한 패킹에 대한 논의를 참조하십시오.

레이아웃 해석에 대한 자세한 내용은 섹션 13.4에 나와 있습니다.

---
### **13.4.  Interpreting the File Layout**
---
#### **13.4.1.  Determining the Stripe Unit Number**

클라이언트의 논리 파일 오프셋에 해당하는 스트라이프 단위 번호를 찾으려면 패턴 오프셋도 사용됩니다. i번째 스트라이프 유닛\(SUi\)은 다음과 같습니다.

```text
       relative_offset = file_offset - nfl_pattern_offset;
       SUi = floor(relative_offset / stripe_unit_size);
```

---
#### **13.4.2.  Interpreting the File Layout Using Sparse Packing**

스파스 패킹이 사용되는 경우 스트라이프 유닛 i\(SUi\)를 쓸 데이터 서버 네트워크 주소 세트와 파일 핸들을 결정하는 알고리즘은 다음과 같습니다.

```text
      stripe_count = number of elements in nflda_stripe_indices;

      j = (SUi + nfl_first_stripe_index) % stripe_count;

      idx = nflda_stripe_indices[j];

      fh_count = number of elements in nfl_fh_list;
      ds_count = number of elements in nflda_multipath_ds_list;

      switch (fh_count) {
        case ds_count:
          fh = nfl_fh_list[idx];
          break;

        case 1:
          fh = nfl_fh_list[0];
          break;

        case 0:
          fh = filehandle returned by OPEN;
          break;

        default:
          throw a fatal exception;
          break;
      }

      address_list = nflda_multipath_ds_list[idx];
```

그런 다음 클라이언트는 address\_list에서 데이터 서버를 선택하고 fh에 지정된 파일 핸들을 사용하여 READ 또는 WRITE 작업을 보냅니다.

다음 예를 고려하십시오.

3개의 등가 클래스\(13.5절\)로 배열된 7개의 데이터 서버로 구성된 장치 주소가 있다고 가정합니다.

```text
      { A, B, C, D }, { E }, { F, G }
```

여기서 A부터 G까지는 네트워크 주소입니다.

```text
   Then

      nflda_multipath_ds_list<> = { A, B, C, D }, { E }, { F, G }

   i.e.,

      nflda_multipath_ds_list[0] = { A, B, C, D }

      nflda_multipath_ds_list[1] = { E }

      nflda_multipath_ds_list[2] = { F, G }
```

스트라이핑 인덱스 배열이 다음과 같다고 가정합니다.

```text
      nflda_stripe_indices<> = { 2, 0, 1, 0 }
```

이제 클라이언트가 위의 장치 주소에 매핑되는 장치 ID가 있는 레이아웃을 가져온다고 가정합니다. 초기 인덱스에는 다음이 포함됩니다.

```text
      nfl_first_stripe_index = 2,
```

파일 핸들 목록은 다음과 같습니다.

```text
      nfl_fh_list = { 0x36, 0x87, 0x67 }.
```

클라이언트가 SU0에 쓰기를 원하는 경우 SUi에 대한 유효한 { 네트워크 주소, 파일 핸들 } 조합 세트는 다음과 같이 결정됩니다.

```text
      nfl_first_stripe_index = 2

   So

      idx = nflda_stripe_indices[(0 + 2) % 4]

         = nflda_stripe_indices[2]

         = 1

   So

      nflda_multipath_ds_list[1] = { E }

   and

      nfl_fh_list[1] = { 0x87 }
```

따라서 클라이언트는 SU0을 { 0x87, { E } }에 쓸 수 있습니다.

처음 13개 저장 장치의 대상은 다음과 같습니다.

```text
                    +=====+============+==============+
                    | SUi | filehandle | data servers |
                    +=====+============+==============+
                    | 0   | 87         | E            |
                    +-----+------------+--------------+
                    | 1   | 36         | A,B,C,D      |
                    +-----+------------+--------------+
                    | 2   | 67         | F,G          |
                    +-----+------------+--------------+
                    | 3   | 36         | A,B,C,D      |
                    +-----+------------+--------------+
                    +-----+------------+--------------+
                    | 4   | 87         | E            |
                    +-----+------------+--------------+
                    | 5   | 36         | A,B,C,D      |
                    +-----+------------+--------------+
                    | 6   | 67         | F,G          |
                    +-----+------------+--------------+
                    | 7   | 36         | A,B,C,D      |
                    +-----+------------+--------------+
                    +-----+------------+--------------+
                    | 8   | 87         | E            |
                    +-----+------------+--------------+
                    | 9   | 36         | A,B,C,D      |
                    +-----+------------+--------------+
                    | 10  | 67         | F,G          |
                    +-----+------------+--------------+
                    | 11  | 36         | A,B,C,D      |
                    +-----+------------+--------------+
                    +-----+------------+--------------+
                    | 12  | 87         | E            |
                    +-----+------------+--------------+

                                  Table 9
```

---
#### **13.4.3.  Interpreting the File Layout Using Dense Packing**

조밀한 패킹이 사용되는 경우 스트라이프 유닛 i\(SUi\)를 쓸 데이터 서버 네트워크 주소 세트와 파일 핸들을 결정하는 알고리즘은 다음과 같습니다.

```text
      stripe_count = number of elements in nflda_stripe_indices;

      j = (SUi + nfl_first_stripe_index) % stripe_count;

      idx = nflda_stripe_indices[j];

      fh_count = number of elements in nfl_fh_list;
      ds_count = number of elements in nflda_multipath_ds_list;

      switch (fh_count) {
        case stripe_count:
          fh = nfl_fh_list[j];
          break;

        default:
          throw a fatal exception;
          break;
      }

      address_list = nflda_multipath_ds_list[idx];
```

그런 다음 클라이언트는 address\_list에서 데이터 서버를 선택하고 fh에 지정된 파일 핸들을 사용하여 READ 또는 WRITE 작업을 보냅니다.

다음 예제를 고려하십시오\(파일 핸들 목록을 제외하고 희소 패킹 예제와 동일\).

3개의 등가 클래스\(13.5절\)로 배열된 7개의 데이터 서버로 구성된 장치 주소가 있다고 가정합니다.

```text
      { A, B, C, D }, { E }, { F, G }
```

여기서 A부터 G까지는 네트워크 주소입니다.

```text
   Then

      nflda_multipath_ds_list<> = { A, B, C, D }, { E }, { F, G }

   i.e.,

      nflda_multipath_ds_list[0] = { A, B, C, D }

      nflda_multipath_ds_list[1] = { E }

      nflda_multipath_ds_list[2] = { F, G }
```

스트라이핑 인덱스 배열이 다음과 같다고 가정합니다.

```text
      nflda_stripe_indices<> = { 2, 0, 1, 0 }
```

이제 클라이언트가 위의 장치 주소에 매핑되는 장치 ID가 있는 레이아웃을 가져온다고 가정합니다. 초기 인덱스에는 다음이 포함됩니다.

```text
      nfl_first_stripe_index = 2,

   and

      nfl_fh_list = { 0x67, 0x37, 0x87, 0x36 }.
```

조밀한 패킹의 흥미로운 예는 SU1과 SU3입니다. 왜냐하면 각 스트라이프 단위는 동일한 데이터 서버 목록을 참조하지만 각 스트라이프 단위는 서로 다른 파일 핸들을 사용해야 하기 때문입니다. 클라이언트가 SU1에 쓰기를 원하는 경우 SUi에 대한 유효한 { 네트워크 주소, 파일 핸들 } 조합 집합은 다음과 같이 결정됩니다.\(MUST\)

```text
      nfl_first_stripe_index = 2

   So

      j = (1 + 2) % 4 = 3

         idx = nflda_stripe_indices[j]

         = nflda_stripe_indices[3]

         = 0

   So

      nflda_multipath_ds_list[0] = { A, B, C, D }

   and

      nfl_fh_list[3] = { 0x36 }
```

따라서 클라이언트는 SU1을 { 0x36, { A, B, C, D } }에 쓸 수 있습니다.

SU3의 경우 j = \(3 + 2\) % 4 = 1, nflda\_stripe\_indices\[1\] = 0. 그러면 nflda\_multipath\_ds\_list\[0\] = { A, B, C, D }, nfl\_fh\_list\[1\] = 0x37입니다. 따라서 클라이언트는 SU3을 { 0x37, { A, B, C, D } }에 쓸 수 있습니다.

처음 13개 저장 장치의 대상은 다음과 같습니다.

```text
                    +=====+============+==============+
                    | SUi | filehandle | data servers |
                    +=====+============+==============+
                    | 0   | 87         | E            |
                    +-----+------------+--------------+
                    | 1   | 36         | A,B,C,D      |
                    +-----+------------+--------------+
                    | 2   | 67         | F,G          |
                    +-----+------------+--------------+
                    | 3   | 37         | A,B,C,D      |
                    +-----+------------+--------------+
                    +-----+------------+--------------+
                    | 4   | 87         | E            |
                    +-----+------------+--------------+
                    | 5   | 36         | A,B,C,D      |
                    +-----+------------+--------------+
                    | 6   | 67         | F,G          |
                    +-----+------------+--------------+
                    | 7   | 37         | A,B,C,D      |
                    +-----+------------+--------------+
                    +-----+------------+--------------+
                    | 8   | 87         | E            |
                    +-----+------------+--------------+
                    | 9   | 36         | A,B,C,D      |
                    +-----+------------+--------------+
                    | 10  | 67         | F,G          |
                    +-----+------------+--------------+
                    | 11  | 37         | A,B,C,D      |
                    +-----+------------+--------------+
                    +-----+------------+--------------+
                    | 12  | 87         | E            |
                    +-----+------------+--------------+

                                  Table 10
```

---
#### **13.4.4.  Sparse and Dense Stripe Unit Packing**

nfl\_util4 데이터 유형의 NFL4\_UFLG\_DENSE 플래그\(nfsv4\_1\_file\_layouthint4 데이터 유형의 nflh\_util 필드 및 nfsv4\_1\_file\_layout\_ds\_addr4 데이터 유형의 nfl\_util 필드\)는 데이터 서버의 데이터 파일 내에 데이터가 압축되는 방식을 지정합니다. 이는 희소 데이터와 밀도 데이터의 두 가지 데이터 패킹을 허용합니다. 패킹 유형은 클라이언트에 표시되는 파일 오프셋을 데이터 서버에 있는 데이터 파일 내의 오프셋에 매핑하기 위해 수행되는 계산을 결정합니다.

nfl\_util & NFL4\_UFLG\_DENSE가 0이면 이는 희소 패킹이 사용된다는 의미입니다. 따라서 메타데이터 서버에 직접 READ 및 WRITE를 보내는 클라이언트가 보는 파일의 논리적 오프셋은 스트라이프 단위를 저장할 때 각 데이터 서버가 사용하는 오프셋과 동일합니다. 그러면 두 개 이상의 스트라이프 단위로 구성된 스트라이프 패턴의 경우 각 데이터 서버 파일이 희박하거나 "구멍이 많아지는" 효과가 있습니다. 예를 들어, 3개의 스트라이프 단위가 있는 패턴이 있고 스트라이프 단위 크기는 4096바이트이며 패턴에 3개의 데이터 서버가 있다고 가정합니다. 그러면 데이터 서버 1의 파일에는 스트라이프 단위 0, 3, 6, 9, ...이 채워집니다. 데이터 서버 2의 파일에는 스트라이프 장치 1, 4, 7, 10, ...이 채워집니다. 데이터 서버 3의 파일에는 스트라이프 단위 2, 5, 8, 11, ...이 채워집니다. 각 파일의 채워지지 않은 스트라이프 단위는 구멍이 됩니다. 따라서 각 데이터 서버의 파일이 드물게 됩니다.

스파스 패킹이 사용되고 클라이언트가 홀 중 하나에 대한 I/O를 시도하는 경우 데이터 서버는 오류를 반환해야 합니다. 위의 예를 사용하면 데이터 서버 3이 블록 4에 대한 READ 또는 WRITE 작업을 수신한 경우 데이터 서버는 NFS4ERR\_PNFS\_IO\_HOLE을 반환합니다. 따라서 데이터 서버는 스파스 패킹을 지원하기 위해 스트라이핑 패턴을 이해해야 합니다.\(MUST\)

nfl\_util & NFL4\_UFLG\_DENSE가 1이면 밀집 패킹이 사용되며 데이터 서버 파일에 구멍이 없음을 의미합니다. 데이터 서버가 구멍이 있는 파일을 \(효율적으로\) 지원하지 않거나 구멍이 없으면 데이터 서버가 미리 읽기를 인식할 수 없기 때문에 촘촘한 패킹이 선택될 수 있습니다. 레이아웃에 빽빽한 패킹이 표시된 경우 데이터 파일이 패킹됩니다. 희소 패킹 예제에 사용된 것과 동일한 스트라이프 패턴 및 스트라이프 단위 크기를 사용하면 해당 조밀 패킹 예제에서는 모든 데이터 파일의 모든 스트라이프 단위가 다음과 같이 채워집니다.

\* 파일의 논리적 스트라이프 단위 0, 3, 6, ...은 데이터 서버 1 파일의 스트라이프 단위 0, 1, 2, ...에 존재합니다.

\* 파일의 논리적 스트라이프 단위 1, 4, 7, ...은 데이터 서버 2 파일의 스트라이프 단위 0, 1, 2, ...에 존재합니다.

\* 파일의 논리적 스트라이프 단위 2, 5, 8, ...은 데이터 서버 3 파일의 스트라이프 단위 0, 1, 2, ...에 있습니다.

고밀도 패킹은 데이터 서버에 구멍을 남기지 않기 때문에 pNFS 클라이언트는 스트라이프에 있는 모든 데이터 서버의 모든 데이터 파일 오프셋에 쓸 수 있습니다. 따라서 데이터 서버는 파일의 스트라이핑 패턴을 알 필요가 없습니다.

밀집된 데이터 서버 레이아웃에 대한 데이터 파일 내의 바이트 오프셋을 결정하는 계산은 다음과 같습니다.

스트라이프\_폭 = 스트라이프\_유닛\_크기 \* N;

- 여기서 N = nflda\_stripe\_indices의 요소 수입니다.

```text
      relative_offset = file_offset - nfl_pattern_offset;

      data_file_offset = floor(relative_offset / stripe_width)
         * stripe_unit_size
         + relative_offset % stripe_unit_size
```

조밀한 패킹이 사용되고 데이터 서버가 스트라이핑 패턴에서 두 번 이상 나타나는 경우 하나의 스트라이프 단위를 다른 스트라이프 단위와 구별하기 위해 데이터 서버는 다른 파일 핸들을 사용해야 합니다. 두 개의 데이터 서버가 있다고 가정해 보겠습니다. 논리적 스트라이프 장치 0, 3, 6은 데이터 서버 1에서 제공됩니다. 논리적 스트라이프 장치 1, 4, 7은 데이터 서버 2에서 제공됩니다. 논리 스트라이프 장치 2, 5, 8도 데이터 서버 2에서 제공됩니다. 데이터 서버 2에 두 개의 파일 핸들\(각각 다른 데이터 파일 참조\)이 없으면 예를 들어 논리 스트라이프 장치 1에 대한 쓰기가 다음에 대한 쓰기를 덮어씁니다. 논리적 스트라이프 장치 2는 모두 데이터 서버 2의 동일한 스트라이프 장치\(0\)에 위치하기 때문입니다.\(MUST\)

---
### **13.5.  Data Server Multipathing**

NFSv4.1 파일 레이아웃은 여러 데이터 서버 주소에 대한 다중 경로 지정을 지원합니다. 데이터 서버 수준 다중 경로는 트렁킹을 통한 대역폭 확장\(섹션 2.10.5\)과 데이터 서버 장애 시 사용 가용성을 높이기 위해 사용됩니다. 다중 경로를 사용하면 클라이언트는 새 레이아웃을 위해 메타데이터 서버에 연결할 필요 없이 동일한 데이터 스트라이프 단위를 내보내는 다른 데이터 서버의 주소일 수 있는 다른 데이터 서버 주소로 전환할 수 있습니다.

데이터 서버 다중 경로를 지원하기 위해 nflda\_multipath\_ds\_list의 각 요소에는 하나 이상의 데이터 서버 네트워크 주소 배열이 포함됩니다. 이 배열\(데이터 유형 multipath\_list4\)은 데이터 서버 목록\(각각 네트워크 주소로 식별됨\)을 나타내며, 일부 데이터 서버는 목록에 여러 번 나타날 가능성이 있습니다.

클라이언트는 데이터 서버 요청을 보내기 위한 대상으로 네트워크 주소 중 하나를 자유롭게 사용할 수 있습니다. 일부 네트워크 주소가 다른 주소보다 데이터에 대한 최적의 경로가 아닌 경우 MDS는 해당 네트워크 주소를 nflda\_multipath\_ds\_list 요소에 포함해서는 안 됩니다. 장애 조치를 제공하기 위한 최적의 네트워크 주소가 존재하지 않는 경우 주소를 제공하는 권장 방법은 해당 주소를 대체 장치-ID-장치-주소 매핑 또는 대체 장치 ID로 제공하는 것입니다. 클라이언트가 nflda\_multipath\_ds\_list 요소의 데이터 서버가 응답하지 않음을 발견하면 기존 장치 ID-장치 주소 매핑을 교체하려고 시도하기 위해 GEDEVICEINFO를 보내야 합니다. MDS가 nflda\_multipath\_ds\_list의 요소로 표시되는 모든 데이터 서버를 사용할 수 없음을 감지하면 MDS는 CB\_NOTIFY\_DEVICEID\(클라이언트가 변경된 장치 ID에 대한 장치 ID 알림을 원한다고 표시한 경우\)를 보내 장치 ID를 장치 ID로 변경해야 합니다. 사용 가능한 데이터 서버에 대한 주소 매핑. 장치 ID 자체가 교체되는 경우 MDS는 장치 ID가 포함된 모든 레이아웃을 호출해야 하며 따라서 클라이언트가 LAYOUTGET 및 GEDEVICEINFO를 통해 새로운 레이아웃 및 장치 ID 매핑을 가져오도록 해야 합니다.\(SHOULD NOT, SHOULD, SHOULD, SHOULD, SHOULD\)

일반적으로 두 개의 네트워크 주소가 nflda\_multipath\_ds\_list의 요소에 나타나면 동일한 데이터 서버를 지정하며 두 개의 데이터 서버 주소는 섹션 2.10.5에 정의된 대로 클라이언트 ID 또는 세션 트렁킹\(후자가 권장됨\) 구현을 지원합니다. . 두 데이터 서버 주소는 동일한 서버 소유자 또는 서버 소유자의 주요 ID를 공유합니다. 두 개의 데이터 서버 주소가 트렁킹이 사용되는 동일한 서버를 지정하는 것이 항상 필요한 것은 아닙니다. 예를 들어 데이터는 읽기 전용일 수 있으며 데이터는 정확한 복제본으로 구성됩니다.\(SHOULD\)

---
### **13.6.  Operations Sent to NFSv4.1 Data Servers**

NFSv4.1 데이터 서버의 데이터에 액세스하는 클라이언트는 유효한 NFSv4.1 작업으로 정의된 작업의 제한된 두 하위 집합에서만 해당 작업을 수행하는 NULL 프로시저와 COMPOUND 프로시저만 보내야 합니다. 클라이언트는 NFSv4.1 데이터 서버의 데이터에 액세스할 때 레이아웃에 지정된 파일 핸들을 사용해야 합니다.\(MUST, MUST\)

이러한 작업 하위 집합 중 첫 번째는 관리 작업으로 구성됩니다. 이 하위 집합은 BACKCHANNEL\_CTL, BIND\_CONN\_TO\_SESSION, CREATE\_SESSION, DESTROY\_CLIENTID, DESTROY\_SESSION, EXCHANGE\_ID, SECINFO\_NO\_NAME, SET\_SSV 및 SEQUENCE 작업으로 구성됩니다. 클라이언트는 데이터 서버와의 통신과 관련된 적절한 클라이언트 ID, 세션 및 보안 컨텍스트를 설정하고 유지하기 위해 이러한 작업을 사용할 수 있습니다. 이후부터는 이를 데이터 서버 하우스키핑 작업이라고 합니다.

두 번째 하위 집합은 COMMIT, READ, WRITE 및 PUTFH로 구성됩니다. 이러한 작업은 레이아웃에 지정된 현재 파일 핸들과 함께 사용해야 합니다. PUTFH의 경우 새로운 현재 파일 핸들은 레이아웃에서 가져온 것이어야 합니다. 이후부터는 이를 데이터 서버 I/O 작업이라고 합니다. 섹션 12.5.1에 ​​설명된 대로 클라이언트는 유효한 레이아웃을 보유하지 않는 데이터 서버에 I/O를 보내면 안 됩니다. 데이터 서버는 그러한 I/O를 거부해야 합니다.\(MUST, MUST, MUST NOT\)

서버에 동시 비데이터 서버 특성이 있는 경우를 제외하고, 즉 EXCHANGE\_ID 결과가 반환됨\(EXCHGID4\_FLAG\_USE\_PNFS\_DS | EXCHGID4\_FLAG\_USE\_PNFS\_MDS\) 또는 \(EXCHGID4\_FLAG\_USE\_PNFS\_DS | EXCHGID4\_FLAG\_USE\_NON\_PNFS\) 섹션 13.1을 참조하세요. 위의 두 하위 집합은 NFS4ERR\_NOTSUPP를 클라이언트에 반환해야 합니다.\(MUST\)

서버에 동시 데이터 서버 및 비데이터 서버 특성이 있는 경우 클라이언트가 보낸 각 COMPOUND는 두 특성 중 하나에 적합하도록 구성되어야 하며 이러한 특성의 혼합에 대한 작업을 포함해서는 안 됩니다. . 서버는 이를 시행해야 합니다. 제약 조건을 이해하기 위해 COMPOUND 내의 작업은 다음 세 가지 클래스로 나뉩니다.\(MUST NOT, MUST\)

1. 성격이 모호한 수술

-   과제. 여기에는 모든 데이터 서버 관리 작업이 포함됩니다. 또한 레이아웃에 의해 정의된 파일 핸들이 메타데이터 서버에서 사용되는 것과 동일하도록 서버가 파일 핸들을 할당한 경우 이러한 파일 핸들을 사용하는 모든 작업은 다음 예외를 제외하고 이 클래스 내에 있습니다. 예외는 작업이 데이터 서버 특성과 호환되지 않는 stateid를 사용하는 경우\(예: 특수 stateid 또는 stateid에 0이 아닌 "seqid" 필드가 있음, 섹션 13.9.1 참조\) 작업이 클래스에 있다는 것입니다. 3, 아래 설명과 같습니다. 여러 클래스 1 작업\(및 다른 클래스의 작업\)을 포함하는 COMPOUND는 여러 동시 데이터 서버 및 비데이터 서버 특성이 있는 서버로 전송될 수 있습니다.\(MAY\)

2. 데이터 서버 특성을 명확하게 참조할 수 있는 작업입니다. 여기에는 파일 핸들이 데이터 서버 특성으로만 유효하게 전달될 수 있는 데이터 서버 I/O 작업이 포함됩니다.

3. 비데이터 서버 특성을 명확하게 참조할 수 있는 작업입니다. 여기에는 데이터 서버 하우스키핑이나 데이터 서버 I/O 작업이 아닌 모든 COMPOUND 작업과 현재 fh\(또는 PUTFH의 경우 현재 fh로 만들어질 fh\)가 다음과 같은 데이터 서버 I/O 작업이 포함됩니다. 메타데이터 서버에서만 유효하거나 데이터 서버와 호환되지 않는 stateid가 사용되는 경우에만 유효합니다. 즉, 특수 stateid이거나 seqid 값이 0이 아닙니다.

COMPOUND가 위 클래스 3의 작업을 처음 실행하면 다른 서버에서 일반 COMPOUND로 작동하고 데이터 서버 특성은 더 이상 관련되지 않습니다. COMPOUND에서의 작업에는 데이터 서버에 대한 작업으로 제한하기 위한 특별한 제한이 없습니다. PUTFH가 완료되면 레이아웃에서 파생된 파일 핸들이 유효하지 않습니다. 해당 형식이 일반적으로 허용되지 않는 경우 NFS4ERR\_BADHANDLE이 발생해야 합니다. 마찬가지로, 다른 작업에 대한 현재 파일 핸들은 레이아웃에서 파생된 파일 핸들을 허용하지 않으며 일반적으로 메타데이터 서버에서 사용할 수 없습니다. 이를 사용하면 NFS4ERR\_STALE가 발생합니다.\(MUST\)

COMPOUND가 파일 핸들이 레이아웃의 하나인 PUTFH인 클래스 2에서 작업을 처음 실행하면 이후부터 COMPOUND는 데이터 서버 특성과 관련하여 해석됩니다. 위에서 설명한 두 클래스 이외의 작업은 NFS4ERR\_NOTSUPP를 발생시켜야 합니다. 파일 핸들은 데이터 서버의 규칙을 사용하여 검증되며, 비데이터 서버 특성으로 주소 지정될 때 일반적으로 그렇게 하지 않는 경우에도 NFS4ERR\_BADHANDLE 및/또는 NFS4ERR\_STALE이 발생합니다. Stateid는 특수 stateid 또는 seqid 값이 0이 아닌 stateid를 사용하면 NFS4ERR\_BAD\_STATEID가 발생해야 한다는 점에서 데이터 서버의 규칙을 따라야 합니다.\(MUST\)

서버가 클래스 2 또는 클래스 3의 작업을 처음 실행할 때까지 클라이언트는 데이터 서버 또는 비데이터 서버 성격에 의해 실행되는 작업에 의존해서는 안 됩니다. 서버는 주어진 COMPOUND에 대해 일관되게 하나의 성격을 선택해야 하며, 클래스 2 또는 클래스 3의 첫 번째 작업이 실행될 때 가능한 유일한 전환은 단일 성격입니다.\(MUST NOT, MUST\)

데이터 서버와 메타데이터 서버 모두에서 사용할 수 있도록 파일 핸들을 할당하면 발생하는 복잡성 때문에 동일한 서버가 두 특성을 모두 가질 수 있는 경우 서버가 두 특성에 별도의 고유한 파일 핸들을 할당하는 것이 좋습니다. 이렇게 하면 해당 요청이 어떤 서버를 대상으로 하는지 명확해집니다.\(SHOULD\)

GETATTR 및 SETATTR은 메타데이터 서버로 연결되어야 합니다. 크기 속성의 SETATTR의 경우 제어 프로토콜은 크기 업데이트/잘림을 데이터 서버에 전파하는 역할을 담당합니다. WRITE를 데이터 서버로 확장하는 경우 LAYOUTCOMMIT가 완료되면 새로운 크기가 메타데이터 서버에 표시되어야 합니다\(섹션 12.5.4.2 참조\). 13.10절에서는 클라이언트가 메타데이터 서버의 크기를 반영하지 않는 데이터 서버 파일을 처리하는 메커니즘을 설명합니다.\(MUST\)

---
### **13.7.  COMMIT through Metadata Server**

파일 레이아웃은 데이터 서버를 통해 기록된 데이터 커밋을 제공하는 두 가지 대체 수단을 제공합니다. 파일 레이아웃\(데이터 유형 nfsv4\_1\_file\_layout4\)의 nfl\_util 필드에 있는 NFL4\_UFLG\_COMMIT\_THRU\_MDS 플래그는 COMMIT를 데이터 서버 또는 메타데이터 서버로 보내는 방식으로 COMMIT를 수행하는 필수 방법을 메타데이터 서버에서 클라이언트로 표시합니다. 문제를 처리하는 이 두 가지 방법은 파일 레이아웃 유형을 지원하는 pNFS 서버에 대한 광범위한 구현 스타일에 해당합니다.\(MUST\)

\* 플래그가 FALSE인 경우 COMMIT 작업은 해당 WRITE 작업이 전송된 데이터 서버로 전송되어야 합니다. 이 접근 방식은 파일 스트라이핑이 파일 시스템 대신 pNFS 서버 내에서 구현되고 개별 데이터 서버가 각각 자체 파일 시스템을 구현하는 경우 유용할 수 있습니다.\(MUST\)

\* 플래그가 TRUE인 경우 COMMIT 작업은 개별 데이터 서버가 아닌 메타데이터 서버로 전송되어야 합니다. 이 접근 방식은 pNFS 서버의 백엔드인 클러스터 파일 시스템 내에서 파일 스트라이핑을 구현할 때 유용할 때도 있습니다. 이러한 구현에서는 각 데이터 서버에 대한 각 COMMIT로 인해 쓰기 성능이 저하되는 메타데이터 블록 쓰기가 반복될 수 있습니다. 이러한 조정된 COMMIT를 구현할 수 있는 클러스터 파일 시스템이 있는 경우 단일 COMMIT를 메타데이터 서버로 보내는 것이 더 효율적일 수 있습니다.\(MUST\)

- nfl\_util & NFL4\_UFLG\_COMMIT\_THRU\_MDS가 TRUE인 경우 현재 NFSv4.1 커밋 및 복구 모델을 유지하려면 데이터 서버는 지정된 파일 레이아웃에 대한 모든 WRITE 응답에서 공통 writeverf 검증자를 반환해야 하며 메타데이터 서버의 COMMIT 구현은 반환해야 합니다. 같은 writeverf. 커밋되지 않은 데이터의 손실을 초래할 수 있는 서버 이벤트가 있을 때마다 writeverf 검증자의 값은 메타데이터 서버 또는 레이아웃에서 참조되는 데이터 서버에서 변경되어야 합니다. 검증자의 범위는 파일 또는 전체 pNFS 서버일 수 있습니다. 서버가 파일 수준에서 확인 프로그램을 유지하는 것이 더 어려울 수 있지만 특정 파일에 영향을 미치는 이벤트에만 복구 작업이 필요하다는 이점이 있습니다.\(MUST, MUST\)

레이아웃이 조밀한 패킹을 지정한 경우 MDS에 대한 COMMIT에 사용되는 오프셋은 데이터 서버에 대한 COMMIT에 사용되는 오프셋과 다를 수 있습니다.

메타데이터 서버에 대한 단일 COMMIT는 검증자를 반환하며 클라이언트는 이를 WRITE의 모든 검증자와 비교하고 일치하지 않는 검증자가 있는 경우 COMMIT에 실패해야 합니다. 메타데이터 서버에 대한 COMMIT가 실패하면 클라이언트는 파일에서 수정된 모든 데이터에 대해 WRITE를 다시 보내야 합니다. 클라이언트는 일치하지 않는 검증자로 수정된 데이터를 WRITE 실패로 처리하고 WRITE를 원래 데이터 서버로 다시 보내거나 레이아웃이 회수되지 않은 경우 해당 데이터에 대한 다른 경로를 사용하여 복구를 시도해야 합니다. 또는 클라이언트가 새 레이아웃을 얻거나 메타데이터 서버에 직접 데이터를 다시 쓸 수 있습니다. nfl\_util & NFL4\_UFLG\_COMMIT\_THRU\_MDS가 FALSE인 경우 COMMIT를 메타데이터 서버로 보내도 아무런 효과가 없을 수 있습니다. nfl\_util & NFL4\_UFLG\_COMMIT\_THRU\_MDS가 FALSE인 경우 메타데이터 서버로 전송된 COMMIT는 메타데이터 서버에 기록된 데이터를 커밋하는 데에만 사용해야 합니다. 복구 옵션은 섹션 12.7.6을 참조하세요.

---
### **13.8.  The Layout Iomode**

일부 상황에서는 유용할 수 있지만 NFSv4.1 파일 기반 레이아웃을 서비스할 때 메타데이터 서버에서 레이아웃 iomode를 사용할 필요는 없습니다. 예를 들어, 서버 구현이 읽기 전용 복제본이나 미러에서 읽기를 지원하는 경우 클라이언트가 그렇게 할 수 있도록 서버가 레이아웃을 반환하는 것이 유용할 것입니다. 따라서 클라이언트는 데이터를 읽거나 쓰려는 의도에 따라 iomode를 설정해야 합니다. 클라이언트는 기본적으로 LAYOUTIOMODE4\_RW의 iomode를 사용할 수 있습니다. 클라이언트가 I/O를 수행할 때 데이터 서버에서 iomode를 확인할 필요가 없습니다. 그러나 데이터 서버는 클라이언트가 유효한 레이아웃을 보유하고 있는지 확인하고 클라이언트가 그렇지 않은 경우 오류를 반환해야 합니다.\(SHOULD, SHOULD\)

---
### **13.9.  Metadata and Data Server State Coordination**
---
#### **13.9.1.  Global Stateid Requirements**

클라이언트가 데이터 서버에 I/O를 보낼 때 사용된 상태 ID는 LAYOUTGET에 의해 반환되거나 CB\_LAYOUTRECALL에 의해 전송된 레이아웃 상태 ID가 되어서는 안 됩니다. 허용된 stateid는 다음 중 하나를 기반으로 합니다. OPEN stateid\(OPEN에 의해 ​​반환된 OPEN4resok 데이터 유형의 stateid 필드\), 위임 stateid\(OPEN 또는 WANT\_DELEGATION에 의해 ​​반환된 open\_read\_delegation4 및 open\_write\_delegation4 데이터 유형의 stateid 필드 또는 전송됨\) CB\_PUSH\_DELEG\) 또는 LOCK 또는 LOCKU 작업에서 반환된 상태 ID입니다. 데이터 서버로 전송된 stateid는 0이 아닌 특정 seqid 값을 나타내는 것이 아니라 해당 stateid의 최신 버전을 나타내는 0으로 설정된 seqid와 함께 전송되어야 합니다. 어떠한 경우에도 특수한 stateid 값을 사용하는 것은 허용되지 않습니다.\(MUST NOT, MUST\)

I/O에 사용되는 stateid는 pNFS가 없을 때 메타데이터 서버 자체에서 I/O가 수행되는 경우와 동일한 효과를 가지며 데이터 서버에서 동일한 유효성 검사를 받아야 합니다. 이는 stateid가 메타데이터와 데이터 서버 모두에서 전역적으로 유효하다는 의미를 갖습니다. 이를 위해서는 데이터 서버가 I/O 액세스의 유효성을 검사할 수 있도록 메타데이터 서버가 LOCK 및 OPEN 상태의 변경 사항을 데이터 서버에 전파해야 합니다. 이에 대해서는 섹션 13.9.2에서 자세히 설명합니다. stateid가 전파되는 시기에 따라 데이터 서버에 유효한 stateid가 존재하면 유효한 레이아웃의 증거로 작용할 수 있습니다.\(MUST\)

I/O 작업을 수행하는 클라이언트는 클라이언트가 보유한 잠금\(열기 및 위임 포함\)과 I/O 요청을 보내는 다양한 유형의 상태 소유자를 기반으로 적절한 stateid를 선택해야 합니다. 데이터 서버를 참조할 때 이를 수행하는 규칙은 메타데이터 서버에 액세스할 때 적용되는 섹션 8.2.5에서 설명한 규칙과 다소 다릅니다.

우선순위가 낮은 순서대로 적용되는 다음 규칙은 적절한 stateid 선택을 관리합니다.

\* 클라이언트가 문제의 파일에 대한 위임을 보유한 경우 위임 stateid를 사용해야 합니다.

\* 그렇지 않으면 현재 열린 소유자에 대한 OPEN 상태 ID가 있어야 하며, 필수 잠금으로 인해 이를 방지하지 않는 한 문제의 열린 파일에 대한 OPEN 상태 ID가 사용됩니다. 아래를 참조하세요.

\* 데이터 서버가 이전에 OPEN 상태 ID를 사용하기 위해 NFS4ERR\_LOCKED로 응답한 경우 클라이언트는 현재 잠금 소유자가 있는 해당 열린 파일에 대해 바이트 범위 잠금 상태 ID가 존재할 때마다 바이트 범위 잠금 상태 ID를 사용해야 합니다.

\* 특수 상태 ID는 절대 사용하면 안 됩니다. 이를 사용하는 경우 데이터 서버는 NFS4ERR\_BAD\_STATEID 오류로 I/O를 거부해야 합니다.\(MUST\)

---
#### **13.9.2.  Data Server State Propagation**

바이트 범위 잠금 및 개방 모드 상태 변경과 ACL을 처리하는 메타데이터 서버는 I/O 액세스가 검증되는 데이터 서버와 같은 위치에 있지 않을 수 있으므로 서버 구현에서는 다음의 변경 사항 전파를 처리해야 합니다. 이 상태를 데이터 서버에 보냅니다. 데이터 서버로의 전파가 완료되면 해당 변경 사항의 전체 효과가 데이터 서버에 적용되어야 합니다. 그러나 모든 변경 사항은 즉시 전파되어야 하지만 일부 상태 변경 사항은 즉시 전파될 필요가 없습니다. 제어 프로토콜이 이 사양의 범위를 벗어나더라도 이러한 상태 전파는 제어 프로토콜의 설계에 영향을 미칩니다. 즉각적인 전파는 메타데이터 서버에서 데이터 서버로 상태가 동기적으로 전파되는 것을 의미합니다. 클라이언트로 반환되기 전에 전파가 완료되어야 합니다.\(MUST, MUST, SHOULD\)

---
##### **13.9.2.1.  Lock State Propagation**

pNFS 서버가 필수 바이트 범위 잠금을 지원하는 경우 파일에 대한 필수 바이트 범위 잠금은 이를 설정하는 요청이 호출자에게 반환되기 전에 데이터 서버에서 유효해야 합니다. 제어 프로토콜의 세부 사항이 특정 상황에서 상태의 실제 전송을 피할 수 있더라도 효과는 필수 바이트 범위 잠금 상태가 데이터 서버에 동기식으로 전파된 것과 동일해야 합니다.\(MUST, MUST\)

반면에 권고 바이트 범위 잠금 상태는 데이터 서버에서 I/O 액세스를 확인하는 데 사용되지 않으므로 권고 바이트 범위 잠금 상태를 데이터 서버에 전파할 의미론적 이유가 없습니다. 권고 잠금에 대한 업데이트는 권한을 부여하거나 제거하지 않으므로 이러한 변경 사항은 즉시 전파될 필요가 없으며 즉시 전파될 필요도 없습니다. 권고 잠금에 대한 업데이트는 데이터 서버가 stateid에 대한 질문을 해결해야 하는 경우에만 전파되어야 합니다. 실제로 바이트 범위 잠금이 필수가 아닌 경우\(즉, 권고 사항\) 클라이언트는 I/O에 바이트 범위 잠금 기반 상태 ID를 사용하지 않는 것이 좋습니다. OPEN에 의해 ​​반환된 stateid는 충분하며 이러한 종류의 상태 전파에 대한 오버헤드를 제거합니다.

클라이언트가 데이터 서버로부터 NFS4ERR\_LOCKED 오류를 받으면 이는 필수 바이트 범위 잠금이 적용되고 있음을 나타냅니다. 클라이언트는 영향을 받은 범위를 포함하는 바이트 범위 잠금을 가져와서 이 문제를 복구하고 바이트 범위 잠금의 상태 ID를 사용하여 I/O를 다시 보냅니다.

---
##### **13.9.2.2.  Open and Deny Mode Validation**

개방 및 거부 모드 유효성 검사는 데이터 서버가 보유한 개방 및 거부 모드에 대해 수행되어야 합니다. 액세스가 줄어들거나 거부 모드가 더욱 제한적으로 설정된 경우\(CLOSE 또는 OPEN\_DOWNGRADE로 인해\) 데이터 서버는 메타데이터 서버에서 수행될 경우 거부될 모든 I/O를 방지해야 합니다. 액세스가 확장되면 데이터 서버는 이전 완화를 고려하여 더 이상 적용되지 않는 공개 또는 거부 문제로 인해 이후에 요청이 거부되지 않도록 해야 합니다.\(MUST, MUST, MUST\)

---
##### **13.9.2.3.  File Attributes**

SETATTR 작업에는 메타데이터와 데이터 서버 모두에 표시되는 상태\(예: 크기\)를 수정할 수 있는 기능이 있으므로 특히 자르거나 자르는 경우 데이터 서버 집합 전체에서 결과 상태가 일관되도록 주의를 기울여야 합니다. 파일을 키우는 중입니다.

앞서 설명한 대로 LAYOUTCOMMIT 작업은 메타데이터가 데이터 서버에 대한 변경 사항과 동기화되도록 하는 데 사용됩니다. NFSv4.1 기반의 데이터 저장 프로토콜의 경우 크기 속성, mtime/change/atime 설정 등의 상태를 재동기화하는 작업이 필요합니다. LAYOUTCOMMIT 및 속성 동기화에 관한 의미에 대한 전체 설명은 섹션 12.5.4를 참조하세요. NFSv4.1 기반 레이아웃 유형을 사용하면 LAYOUTCOMMIT이 발생하기 전에 이 상태를 동기화할 수 있다는 점에 유의해야 합니다. 예를 들어 제어 프로토콜을 사용하여 데이터 서버에 있는 속성을 쿼리할 수 있습니다.

메타데이터 서버의 ACCESS 호출이나 READ 및 WRITE에 의해 반영된 권한 부여 또는 액세스를 제어하는 ​​파일 속성에 대한 모든 변경 사항은 READ 및 WRITE I/O 호출에 대한 시행을 위해 데이터 서버에 전파되어야 합니다. 메타데이터 서버에 대한 변경 사항으로 인해 모든 사용자에 대한 액세스 권한이 더 제한되는 경우 해당 변경 사항은 데이터 서버에 동기식으로 전파되어야 합니다.\(MUST, MUST\)

OPEN 작업\(섹션 18.16.4\)은 열린 파일에 대한 I/O 작업이 OPEN 자체와 동일한 자격 증명을 가져야 한다는 요구 사항을 부과하지 않습니다\(EXCHANGE\_ID가 클라이언트 ID를 생성할 때 EXCHGID4\_FLAG\_BIND\_PRINC\_STATEID가 설정되지 않은 경우\). 따라서 서버의 적절한 액세스 검사를 수행하기 위한 읽기 및 쓰기 작업. ACL을 변경하려면 서버에서 READ 및 WRITE를 통한 새로운 액세스 확인도 필요합니다. ACL 변경으로 인한 액세스 권한 변경 전파는 업데이트된 ACL이 이전 ACL에 지정된 사용자에 대해 더 제한적이지 않다는 것을 서버 구현에서 확인할 수 있는 경우에만 비동기식일 수 있습니다. ACL 업데이트는 상대적으로 빈도가 낮기 때문에 모든 변경 사항을 동기식으로 전파하는 것이 좋습니다.

---
### **13.10.  Data Server Component File Size**

특정 데이터 서버의 구성 요소 데이터 파일이 EOF를 초과하면 잠재적인 문제가 발생합니다. 조밀한 레이아웃과 희박한 레이아웃 모두에 문제가 있습니다. 다음 시나리오를 상상해 보십시오. 클라이언트가 새 파일\(크기 == 0\)을 생성하고 바이트 131072에 씁니다. 그런 다음 클라이언트는 파일의 시작 부분을 찾아 100바이트를 읽습니다. 클라이언트는 READ 결과로 0을 다시 받아야 합니다. 그러나 스트라이핑 패턴이 클라이언트에게 클라이언트의 원래 WRITE를 수신한 데이터 서버가 아닌 다른 데이터 서버로 READ를 보내도록 지시하는 경우 READ를 서비스하는 데이터 서버는 파일 크기가 여전히 0바이트라고 믿을 수 있습니다. 이 경우 데이터 서버의 READ 응답에는 0바이트와 EOF 표시가 포함됩니다. 데이터 서버는 파일 크기가 확장되었음을 알고 있는 경우에만 0을 반환할 수 있습니다. 이를 위해서는 파일 크기를 모든 데이터 서버에 즉시 전파해야 하며, 이는 잠재적으로 비용이 매우 많이 듭니다. 따라서 파일 크기 확장을 시작한 클라이언트는 이러한 EOF 조건을 처리할 준비가 되어 있어야 합니다. READ에 대한 인수의 오프셋이 클라이언트가 보는 파일 크기보다 작을 때, READ 응답이 EOF를 나타내거나 요청한 것보다 적은 바이트를 포함하면 클라이언트는 이러한 응답을 파일의 구멍으로 해석합니다. NFS 클라이언트는 데이터를 0으로 대체합니다.\(MUST\)

NFSv4.1 프로토콜은 열린 파일 데이터 캐시 의미 체계만 제공합니다. 즉, 파일이 닫히면 수정된 모든 데이터가 서버에 기록됩니다. 파일의 후속 OPEN이 완료되면 변경 속성에 대해 캐시된 값과의 차이가 있는지 변경 속성이 검사됩니다. 위의 경우 이는 LAYOUTCOMMIT가 닫힐 때\(데이터 쓰기와 함께\) 수행되고 파일의 크기 및 변경 속성을 업데이트한다는 의미입니다. 해당 시점 이후에 다른 클라이언트에서 액세스하면 적절한 크기가 반환됩니다.

---
### **13.11.  Layout Revocation and Fencing**

섹션 12.7에 설명된 대로 레이아웃 유형별 스토리지 프로토콜은 임대 만료 이전에 시작되어 임대 만료까지 연장된 I/O의 영향을 처리하는 역할을 합니다. LAYOUT4\_NFSV4\_1\_FILES 레이아웃 유형은 정확한 클라이언트 임대 타이머에 의존하지 않고 데이터 서버가 임대 타이머를 유지하도록 요구하지 않고도 임대 만료 후 데이터 서버에 대한 모든 I/O가 실행되는 것을 방지할 수 있습니다\(이 방지를 "펜싱"이라고 함\). LAYOUT4\_NFSV4\_1\_FILES pNFS 서버는 개별 레이아웃을 취소할 수 있는 유연성을 갖추고 있으므로 파일별로 I/O를 차단합니다.

임대 만료 외에도 레이아웃이 취소될 수 있는 이유에는 클라이언트가 CB\_LAYOUTRECALL에 응답하지 못하거나 메타데이터 서버가 다시 시작되거나 관리 개입이 포함됩니다. 이유에 관계없이 클라이언트의 레이아웃이 취소되면 pNFS 서버는 클라이언트가 모든 데이터 서버에서 영향을 받는 파일에 대한 I/O를 전송하는 것을 방지해야 합니다. 즉, 데이터 서버의 영향을 받는 파일로부터 클라이언트를 차단해야 합니다.\(MUST\)

펜싱은 다음과 같이 작동합니다. 섹션 13.1에 설명된 대로 데이터 서버에 대한 COMPOUND 프로시저 요청에서 PUTFH 작업에서 제공하는 데이터 파일 핸들과 READ 또는 WRITE 작업의 stateid를 사용하여 클라이언트가 수행 중인 I/O에 대해 유효한 레이아웃을 가지고 있는지 확인합니다. ; 그렇지 않은 경우 I/O는 NFS4ERR\_PNFS\_NO\_LAYOUT으로 거부됩니다. 서버는 단순히 stateid를 확인하고 추가적으로 레이아웃이 파일에 대한 메타데이터 서버의 파일 핸들과 다른 데이터 파일 핸들을 지정한 경우 데이터 파일 핸들을 부실하게 만들 수 있습니다\(섹션 13.3의 nfl\_fh\_list 설명 참조\).

메타데이터 서버는 이전 인스턴스에서 제공한 레이아웃 상태를 취소하는 작업을 수행하기 전에 해당 이전 인스턴스의 모든 레이아웃 상태가 데이터 서버에서 무효화되었는지 확인해야 합니다. 이는 다음과 같은 의미를 갖습니다.

\* 메타데이터 서버는 파일이 복구될 때까지 파일을 다시 스트라이프해서는 안 됩니다.

- 이전 인스턴스의 레이아웃을 무효화하기 위해 모든 데이터 서버에 접속했습니다.

\* 메타데이터 서버는 특정 레이아웃 무효화\(어차피 해야 하는 것처럼\)를 수행하거나 글로벌 데이터 서버 무효화를 수행하지 않고 이전 인스턴스의 레이아웃과 충돌하는 필수 잠금을 제공해서는 안 됩니다.

---
### **13.12.  Security Considerations for the File Layout Type**

NFSv4.1 파일 레이아웃 유형은 섹션 12.9에 설명된 보안 고려 사항을 준수해야 합니다. NFSv4.1 데이터 서버는 NFSv4.1 프로토콜에 의해 결정된 대로 각 READ 또는 WRITE I/O에 대해 필요한 모든 액세스 검사를 수행해야 합니다. 메타데이터 서버가 ACL, 모드 속성, 개방형 액세스 모드, 개방형 거부 모드, 필수 바이트 범위 잠금 상태 또는 기타 속성 및 상태로 인해 파일에 대한 읽기 또는 쓰기 작업을 거부하는 경우 데이터 서버도 반드시 거부해야 합니다. 읽기 또는 쓰기 작업. 이는 제어 프로토콜과 메타데이터 서버에서 데이터 서버로의 상태 전파에 영향을 미칩니다. 자세한 내용은 섹션 13.9.2를 참조하세요.\(MUST, MUST, MUST\)

LAYOUT4\_NFSV4\_1\_FILES 레이아웃 유형을 기반으로 하는 데이터 서버의 인증, 무결성 및 개인 정보 보호 방법은 메타데이터 서버에서 사용되는 방법과 동일합니다. 메타데이터 및 데이터 서버는 ONC RPC 보안 특성을 사용하여 인증하고 SECINFO 및 SECINFO\_NO\_NAME을 사용하여 사용할 보안 메커니즘과 서비스를 협상합니다. 따라서 LAYOUT4\_NFSV4\_1\_FILES 레이아웃 유형을 사용할 때 pNFS\(섹션 1.8.1 및 1.8.2.2에서 언급한 대로\)로 인해 RPC 기반 보안 모델에 미치는 영향은 0입니다.

특정 파일 객체에 대해 메타데이터 서버는 데이터 서버와 다른 보안 매개변수\(secinfo4 값\)를 요구할 수 있습니다. 여러 데이터 서버가 있는 특정 파일 객체의 경우 secinfo4 값은 모든 데이터 서버에서 동일해야 합니다. 메타데이터 서버와 해당 데이터 서버의 secinfo4 값이 특정 파일에 대해 다른 경우 ACL, 모드, 열기 및 거부를 기반으로 하는 액세스 제어 검사를 위해서는 서버의 내부 사용자 식별자에 대한 주체의 매핑이 동일해야 합니다. 모드 및 필수 잠금이 pNFS 서버 전체에서 일관되게 유지됩니다.\(MAY, SHOULD, MUST\)

NFSv4.1 구현이 pNFS를 지원하고 NFSv4.1 파일 레이아웃을 지원하는 경우 구현은 메타데이터와 데이터 서버 모두에서 SECINFO\_NO\_NAME 작업을 지원해야 합니다.\(MUST\)

---
## **14.  Internationalization**

NFSv4.1이 국제화\(I18N\)를 처리해야 하는 주요 문제는 프로토콜 내에서 사용되는 파일 이름 및 기타 문자열과 관련됩니다. 문자열 표현을 선택하면 다양한 언어를 사용하는 클라이언트에 대한 합리적인 이름/문자열 액세스가 허용되어야 합니다. ISO10646 \[18\]에 정의된 UCS\(Universal Multiple-Octet Coded Character Set\)의 UTF-8 인코딩은 이러한 유형의 액세스를 허용하며 "문자 세트 및 언어에 대한 IETF 정책", RFC 2277 \[19\]에 설명된 정책을 따릅니다. \].

"stringprep"이라고도 알려진 RFC 3454 \[16\]는 "문자열 입력 및 문자열 비교가 전체 사용자에게 적합한 방식으로 작동할 가능성을 높이기 위해 네트워킹 프로토콜에서 유니코드/UTF-8을 사용하기 위한 프레임워크를 문서화합니다. 세계". 프로토콜은 "처리 옵션을 완전히 지정하기 위해" stringprep의 프로필을 정의해야 합니다. 이 섹션의 나머지 부분에서는 NFSv4.1 stringprep 프로필을 정의합니다. 이 섹션의 나머지 부분에 사용된 용어의 대부분은 stringprep에서 나온 것입니다.

NFSv4.1에는 utf8str\_cs, utf8str\_cis 및 utf8str\_mixed의 세 가지 UTF-8 문자열 유형이 정의되어 있습니다. 각각에 대해 별도의 프로필이 정의됩니다. 각 프로필은 stringprep의 요구에 따라 다음을 정의합니다.

\* 프로파일의 의도된 적용 가능성.

\* 입력과 출력이 되는 캐릭터 레퍼토리

- stringprep\(참조된 stringprep 버전의 유니코드 3.2\). 그러나 NFSv4.1 구현은 3.2로 제한되지 않습니다.

\* stringprep의 매핑 테이블이 사용되었습니다\(stringprep의 섹션 3에 설명된 대로\).

\* 프로필과 관련된 추가 매핑 테이블입니다.

\* 사용된 유니코드 정규화\(있는 경우 stringprep의 섹션 4에 설명됨\).

\* 출력으로 금지된 문자의 stringprep 목록에 있는 표입니다\(stringprep의 섹션 5에 설명되어 있음\).

\* 사용된 양방향 문자열 테스트\(있는 경우 stringprep의 섹션 6에 설명됨\).

\* 프로필 특정 출력으로 금지된 추가 문자입니다.

Stringprep은 유니코드 문자를 설명하는 반면 NFSv4.1은 UTF-8 문자를 렌더링합니다. UTF-8에서 유니코드로의 일대일 매핑이 있으므로 이 문서의 나머지 부분에서 유니코드를 참조하는 경우 독자는 UTF-8을 가정해야 합니다.

프로필 텍스트의 대부분은 RFC 3491 \[20\]에서 유래되었습니다.

---
### **14.1.  Stringprep Profile for the utf8str_cs Type**

NFSv4 프로토콜 사양에서 utf8str\_cs 유형 정의를 사용할 때마다 nfs4\_cs\_prep라는 프로필을 따릅니다.

---
#### **14.1.1.  Intended Applicability of the nfs4_cs_prep Profile**

utf8str\_cs 유형은 대소문자를 구분하는 UTF-8 문자 문자열입니다. NFSv4.1의 주요 용도는 구성 요소 및 경로 이름을 지정하는 것입니다. 구성 요소와 경로 이름은 서버의 파일 시스템에 저장됩니다. utf8str\_cs 프로필을 통해 처리한 후 두 개의 유효한 고유 UTF-8 문자열이 동일할 수 있습니다. 문자열이 디렉터리 내에 두 개의 이름인 경우 NFSv4.1 서버는 다음 중 하나를 수행해야 합니다.

\* 후처리된 형식이 기존 이름의 형식과 충돌하는 경우 두 번째 이름 생성을 허용하지 않습니다.

\* 두 번째 이름의 생성을 허용하되, 후처리 후 두 번째 이름이 첫 번째 이름의 후처리 형태와 다르도록 정리한다.

---
#### **14.1.2.  Character Repertoire of nfs4_cs_prep**

nfs4\_cs\_prep 프로필은 stringprep의 부록 A.1에 정의된 대로 유니코드 3.2를 사용합니다. 그러나 NFSv4.1 구현은 3.2로 제한되지 않습니다.

---
#### **14.1.3.  Mapping Used by nfs4_cs_prep**

nfs4\_cs\_prep 프로필은 stringprep의 다음 테이블을 사용하여 매핑을 지정합니다.

```text
      Table B.1
```

표 B.2는 주로 대소문자를 구분하지 않는 비교를 처리하기 위한 것이므로 일반적으로 nfs4\_cs\_prep 프로필의 일부가 아닙니다. 그러나 NFSv4.1 파일 서버가 case\_insensitive 파일 시스템 속성을 지원하고 case\_insensitive가 TRUE인 경우 NFSv4.1 서버는 utf8str\_cs 문자열을 처리할 때 Table B.2\(Table B1 외에\)를 사용해야 하며 NFSv4.1은 클라이언트는 \(표 B.1 외에\) 표 B.2가 사용되고 있다고 가정해야 합니다.\(MUST\)

case\_preserving 속성이 존재하고 FALSE로 설정된 경우 NFSv4.1 서버는 utf8str\_cs 문자열을 처리할 때 표 B.2를 사용하여 대소문자를 매핑해야 합니다. 서버가 소문자에서 대문자로 매핑되는지 또는 대문자에서 소문자로 매핑되는지 여부는 구현 종속성입니다.\(MUST\)

---
#### **14.1.4.  Normalization used by nfs4_cs_prep**

nfs4\_cs\_prep 프로필은 정규화 형식을 지정하지 않습니다. 이 사양의 이후 개정판에서는 특정 정규화 형식을 지정할 수 있습니다. 따라서 서버와 클라이언트는 프로토콜 요청 및 응답 내에서 정규화되지 않은 문자를 받을 수 있다고 예상할 수 있습니다. 운영 환경에 정규화가 필요한 경우 구현 시 애플리케이션\(클라이언트\) 또는 로컬 파일 시스템\(서버\)에 정보를 제공하기 전에 프로토콜 내에서 utf8str\_cs 문자열을 정규화해야 합니다.

---
#### **14.1.5.  Prohibited Output for nfs4_cs_prep**

nfs4\_cs\_prep 프로필은 stringprep에서 다음 테이블의 사용을 금지하도록 권장합니다.

```text
      Table C.5

      Table C.6
```

---
#### **14.1.6.  Bidirectional Output for nfs4_cs_prep**

nfs4\_cs\_prep 프로필은 양방향 문자열 검사를 지정하지 않습니다.

---
### **14.2.  Stringprep Profile for the utf8str_cis Type**

NFSv4.1 프로토콜 사양에서 utf8str\_cis 유형 정의를 사용할 때마다 nfs4\_cis\_prep이라는 프로필을 따릅니다.

---
#### **14.2.1.  Intended Applicability of the nfs4_cis_prep Profile**

utf8str\_cis 유형은 대소문자를 구분하지 않는 UTF-8 문자 문자열입니다. NFSv4.1의 주요 용도는 NFS 서버 이름을 지정하는 것입니다.

---
#### **14.2.2.  Character Repertoire of nfs4_cis_prep**

nfs4\_cis\_prep 프로필은 stringprep의 부록 A.1에 정의된 대로 유니코드 3.2를 사용합니다. 그러나 NFSv4.1 구현은 3.2로 제한되지 않습니다.

---
#### **14.2.3.  Mapping Used by nfs4_cis_prep**

nfs4\_cis\_prep 프로필은 stringprep의 다음 테이블을 사용하여 매핑을 지정합니다.

```text
      Table B.1

      Table B.2
```

---
#### **14.2.4.  Normalization Used by nfs4_cis_prep**

nfs4\_cis\_prep 프로필은 stringprep에 설명된 대로 유니코드 정규화 형식 KC를 사용하도록 지정합니다.

---
#### **14.2.5.  Prohibited Output for nfs4_cis_prep**

nfs4\_cis\_prep 프로필은 stringprep에서 다음 테이블을 사용하는 것을 금지하도록 지정합니다.

```text
      Table C.1.2

      Table C.2.2

      Table C.3

      Table C.4

      Table C.5

      Table C.6

      Table C.7

      Table C.8

      Table C.9
```

---
#### **14.2.6.  Bidirectional Output for nfs4_cis_prep**

nfs4\_cis\_prep 프로필은 stringprep의 섹션 6에 설명된 대로 양방향 문자열 검사를 지정합니다.

---
### **14.3.  Stringprep Profile for the utf8str_mixed Type**

NFSv4.1 프로토콜 사양에서 utf8str\_mixed 유형 정의를 사용할 때마다 nfs4\_mixed\_prep이라는 프로필을 따릅니다.

---
#### **14.3.1.  Intended Applicability of the nfs4_mixed_prep Profile**

utf8str\_mixed 유형은 대소문자를 구분하는 접두사, '@'과 동일한 구분 기호 및 정규화된 도메인 이름인 접미사를 포함하는 UTF-8 문자의 문자열입니다. NFSv4.1의 주요 용도는 액세스 제어 항목에서 식별된 주체의 이름을 지정하는 것입니다.

---
#### **14.3.2.  Character Repertoire of nfs4_mixed_prep**

nfs4\_mixed\_prep 프로필은 stringprep의 부록 A.1에 정의된 대로 Unicode 3.2를 사용합니다. 그러나 NFSv4.1 구현은 3.2로 제한되지 않습니다.

---
#### **14.3.3.  Mapping Used by nfs4_cis_prep**

utf8str\_mixed 문자열의 접두사 및 구분 기호의 경우 nfs4\_mixed\_prep 프로필은 stringprep의 다음 테이블을 사용하여 매핑을 지정합니다.

```text
      Table B.1
```

utf8str\_mixed 문자열의 접미사에 대해 nfs4\_mixed\_prep 프로필은 stringprep의 다음 테이블을 사용하여 매핑을 지정합니다.

```text
      Table B.1

      Table B.2
```

---
#### **14.3.4.  Normalization Used by nfs4_mixed_prep**

nfs4\_mixed\_prep 프로필은 stringprep에 설명된 대로 유니코드 정규화 형식 KC를 사용하도록 지정합니다.

---
#### **14.3.5.  Prohibited Output for nfs4_mixed_prep**

nfs4\_mixed\_prep 프로필은 stringprep에서 다음 테이블을 사용하는 것을 금지하도록 지정합니다.

```text
      Table C.1.2

      Table C.2.2

      Table C.3

      Table C.4

      Table C.5

      Table C.6

      Table C.7

      Table C.8

      Table C.9
```

---
#### **14.3.6.  Bidirectional Output for nfs4_mixed_prep**

nfs4\_mixed\_prep 프로필은 stringprep의 섹션 6에 설명된 대로 양방향 문자열 검사를 지정합니다.

---
### **14.4.  UTF-8 Capabilities**

```text
   const FSCHARSET_CAP4_CONTAINS_NON_UTF8  = 0x1;
   const FSCHARSET_CAP4_ALLOWS_ONLY_UTF8   = 0x2;

   typedef uint32_t        fs_charset_cap4;
```

일부 운영 환경과 파일 시스템에서는 문자 세트 인코딩을 적용하지 않기 때문에 NFSv4.1은 클라이언트에 파일 시스템의 UTF-8 기능을 나타내는 fs\_charset\_cap 속성\(섹션 5.8.2.11\)을 지원합니다. 속성은 한 쌍의 플래그를 포함하는 정수입니다. 첫 번째 플래그는 FSCHARSET\_CAP4\_CONTAINS\_NON\_UTF8입니다. 이 플래그를 1로 설정하면 파일 시스템에 UTF-8이 아닌 문자가 포함되어 있고 클라이언트가 기호 링크를 읽는 경우 서버가 UTF-8이 아닌 문자를 UTF-8로 변환하지 않는다는 것을 클라이언트에 알립니다. 디렉터리의 경우 인수에 구성 요소 이름이나 경로 이름을 사용한 작업도 문자열을 UTF-8로 변환하지 않습니다. 두 번째 플래그는 FSCHARSET\_CAP4\_ALLOWS\_ONLY\_UTF8이며, 1로 설정된 경우 서버가 파일 시스템에서 UTF-8 문자만 허용\(및 생성\)함을 나타냅니다. FSCHARSET\_CAP4\_ALLOWS\_ONLY\_UTF8이 1로 설정된 경우 FSCHARSET\_CAP4\_CONTAINS\_NON\_UTF8은 0으로 설정되어야 합니다. FSCHARSET\_CAP4\_ALLOWS\_ONLY\_UTF8은 항상 1로 설정되어야 합니다.\(MUST, SHOULD\)

---
### **14.5.  UTF-8 Related Errors**

클라이언트가 잘못된 UTF-8 문자열을 보내는 경우 서버는 NFS4ERR\_INVAL을 반환해야 합니다\(표 11 참조\). 여기에는 부적절한 접두사가 감지되는 경우와 전체 UCS 문자를 구성하지 않는 후행 바이트가 개수에 포함되는 경우가 포함됩니다.

클라이언트 제공 문자열은 유효한 UTF-8이지만 서버에서 해당 문자열의 값으로 지원하지 않는 문자를 포함하는 경우\(예: 파일 시스템의 유니코드 플레인 0 외부 문자가 포함되어 있음에도 불구하고 해당 문자를 지원하지 못하는 이름\) 유니코드 표준에서\) 서버는 NFS4ERR\_BADCHAR을 반환해야 합니다.

UTF-8 문자열이 파일 이름으로 사용되고 파일 시스템\(이름 내의 모든 문자를 지원하지만\)에서 해당 특정 이름의 사용을 허용하지 않는 경우 서버는 NFS4ERR\_BADNAME 오류를 반환해야 합니다\(표 11\). 여기에는 서버 파일 시스템이 이름 문자열에 정규화 제약 조건을 부과하는 상황이 포함되지만 파일 시스템에서 "."를 금지하는 상황도 포함됩니다. 및 ".."는 특정 작업의 파일 이름 및 기타 제약 조건입니다.

---
## **15.  Error Values**

NFS 오류 번호는 복합\(COMPOUND 또는 CB\_COMPOUND\) 요청 내에서 실패한 작업에 할당됩니다. 복합 요청에는 결과가 복합 응답에 순서대로 인코딩된 여러 NFS 작업이 포함되어 있습니다. 성공적인 작업의 결과는 NFS4\_OK 상태와 그 뒤에 인코딩된 작업 결과로 구성됩니다. NFS 작업이 실패하면 응답에 오류 상태가 입력되고 복합 요청이 종료됩니다.

---
### **15.1.  Error Definitions**

```text
    +===================================+========+===================+
    | Error                             | Number | Description       |
    +===================================+========+===================+
    | NFS4_OK                           | 0      | Section 15.1.3.1  |
    +-----------------------------------+--------+-------------------+
    | NFS4ERR_ACCESS                    | 13     | Section 15.1.6.1  |
    +-----------------------------------+--------+-------------------+
    | NFS4ERR_ATTRNOTSUPP               | 10032  | Section 15.1.15.1 |
    +-----------------------------------+--------+-------------------+
    | NFS4ERR_ADMIN_REVOKED             | 10047  | Section 15.1.5.1  |
    +-----------------------------------+--------+-------------------+
    | NFS4ERR_BACK_CHAN_BUSY            | 10057  | Section 15.1.12.1 |
    +-----------------------------------+--------+-------------------+
    | NFS4ERR_BADCHAR                   | 10040  | Section 15.1.7.1  |
    +-----------------------------------+--------+-------------------+
    | NFS4ERR_BADHANDLE                 | 10001  | Section 15.1.2.1  |
    +-----------------------------------+--------+-------------------+
    | NFS4ERR_BADIOMODE                 | 10049  | Section 15.1.10.1 |
    +-----------------------------------+--------+-------------------+
    | NFS4ERR_BADLAYOUT                 | 10050  | Section 15.1.10.2 |
    +-----------------------------------+--------+-------------------+
    | NFS4ERR_BADNAME                   | 10041  | Section 15.1.7.2  |
    +-----------------------------------+--------+-------------------+
    | NFS4ERR_BADOWNER                  | 10039  | Section 15.1.15.2 |
    +-----------------------------------+--------+-------------------+
    | NFS4ERR_BADSESSION                | 10052  | Section 15.1.11.1 |
    +-----------------------------------+--------+-------------------+
    | NFS4ERR_BADSLOT                   | 10053  | Section 15.1.11.2 |
    +-----------------------------------+--------+-------------------+
    | NFS4ERR_BADTYPE                   | 10007  | Section 15.1.4.1  |
    +-----------------------------------+--------+-------------------+
    | NFS4ERR_BADXDR                    | 10036  | Section 15.1.1.1  |
    +-----------------------------------+--------+-------------------+
    | NFS4ERR_BAD_COOKIE                | 10003  | Section 15.1.1.2  |
    +-----------------------------------+--------+-------------------+
    | NFS4ERR_BAD_HIGH_SLOT             | 10077  | Section 15.1.11.3 |
    +-----------------------------------+--------+-------------------+
    | NFS4ERR_BAD_RANGE                 | 10042  | Section 15.1.8.1  |
    +-----------------------------------+--------+-------------------+
    | NFS4ERR_BAD_SEQID                 | 10026  | Section 15.1.16.1 |
    +-----------------------------------+--------+-------------------+
    | NFS4ERR_BAD_SESSION_DIGEST        | 10051  | Section 15.1.12.2 |
    +-----------------------------------+--------+-------------------+
    | NFS4ERR_BAD_STATEID               | 10025  | Section 15.1.5.2  |
    +-----------------------------------+--------+-------------------+
    | NFS4ERR_CB_PATH_DOWN              | 10048  | Section 15.1.11.4 |
    +-----------------------------------+--------+-------------------+
    | NFS4ERR_CLID_INUSE                | 10017  | Section 15.1.13.2 |
    +-----------------------------------+--------+-------------------+
    | NFS4ERR_CLIENTID_BUSY             | 10074  | Section 15.1.13.1 |
    +-----------------------------------+--------+-------------------+
    | NFS4ERR_COMPLETE_ALREADY          | 10054  | Section 15.1.9.1  |
    +-----------------------------------+--------+-------------------+
    | NFS4ERR_CONN_NOT_BOUND_TO_SESSION | 10055  | Section 15.1.11.6 |
    +-----------------------------------+--------+-------------------+
    | NFS4ERR_DEADLOCK                  | 10045  | Section 15.1.8.2  |
    +-----------------------------------+--------+-------------------+
    | NFS4ERR_DEADSESSION               | 10078  | Section 15.1.11.5 |
    +-----------------------------------+--------+-------------------+
    | NFS4ERR_DELAY                     | 10008  | Section 15.1.1.3  |
    +-----------------------------------+--------+-------------------+
    | NFS4ERR_DELEG_ALREADY_WANTED      | 10056  | Section 15.1.14.1 |
    +-----------------------------------+--------+-------------------+
    | NFS4ERR_DELEG_REVOKED             | 10087  | Section 15.1.5.3  |
    +-----------------------------------+--------+-------------------+
    | NFS4ERR_DENIED                    | 10010  | Section 15.1.8.3  |
    +-----------------------------------+--------+-------------------+
    | NFS4ERR_DIRDELEG_UNAVAIL          | 10084  | Section 15.1.14.2 |
    +-----------------------------------+--------+-------------------+
    | NFS4ERR_DQUOT                     | 69     | Section 15.1.4.2  |
    +-----------------------------------+--------+-------------------+
    | NFS4ERR_ENCR_ALG_UNSUPP           | 10079  | Section 15.1.13.3 |
    +-----------------------------------+--------+-------------------+
    | NFS4ERR_EXIST                     | 17     | Section 15.1.4.3  |
    +-----------------------------------+--------+-------------------+
    | NFS4ERR_EXPIRED                   | 10011  | Section 15.1.5.4  |
    +-----------------------------------+--------+-------------------+
    | NFS4ERR_FBIG                      | 27     | Section 15.1.4.4  |
    +-----------------------------------+--------+-------------------+
    | NFS4ERR_FHEXPIRED                 | 10014  | Section 15.1.2.2  |
    +-----------------------------------+--------+-------------------+
    | NFS4ERR_FILE_OPEN                 | 10046  | Section 15.1.4.5  |
    +-----------------------------------+--------+-------------------+
    | NFS4ERR_GRACE                     | 10013  | Section 15.1.9.2  |
    +-----------------------------------+--------+-------------------+
    | NFS4ERR_HASH_ALG_UNSUPP           | 10072  | Section 15.1.13.4 |
    +-----------------------------------+--------+-------------------+
    | NFS4ERR_INVAL                     | 22     | Section 15.1.1.4  |
    +-----------------------------------+--------+-------------------+
    | NFS4ERR_IO                        | 5      | Section 15.1.4.6  |
    +-----------------------------------+--------+-------------------+
    | NFS4ERR_ISDIR                     | 21     | Section 15.1.2.3  |
    +-----------------------------------+--------+-------------------+
    | NFS4ERR_LAYOUTTRYLATER            | 10058  | Section 15.1.10.3 |
    +-----------------------------------+--------+-------------------+
    | NFS4ERR_LAYOUTUNAVAILABLE         | 10059  | Section 15.1.10.4 |
    +-----------------------------------+--------+-------------------+
    | NFS4ERR_LEASE_MOVED               | 10031  | Section 15.1.16.2 |
    +-----------------------------------+--------+-------------------+
    | NFS4ERR_LOCKED                    | 10012  | Section 15.1.8.4  |
    +-----------------------------------+--------+-------------------+
    | NFS4ERR_LOCKS_HELD                | 10037  | Section 15.1.8.5  |
    +-----------------------------------+--------+-------------------+
    | NFS4ERR_LOCK_NOTSUPP              | 10043  | Section 15.1.8.6  |
    +-----------------------------------+--------+-------------------+
    | NFS4ERR_LOCK_RANGE                | 10028  | Section 15.1.8.7  |
    +-----------------------------------+--------+-------------------+
    | NFS4ERR_MINOR_VERS_MISMATCH       | 10021  | Section 15.1.3.2  |
    +-----------------------------------+--------+-------------------+
    | NFS4ERR_MLINK                     | 31     | Section 15.1.4.7  |
    +-----------------------------------+--------+-------------------+
    | NFS4ERR_MOVED                     | 10019  | Section 15.1.2.4  |
    +-----------------------------------+--------+-------------------+
    | NFS4ERR_NAMETOOLONG               | 63     | Section 15.1.7.3  |
    +-----------------------------------+--------+-------------------+
    | NFS4ERR_NOENT                     | 2      | Section 15.1.4.8  |
    +-----------------------------------+--------+-------------------+
    | NFS4ERR_NOFILEHANDLE              | 10020  | Section 15.1.2.5  |
    +-----------------------------------+--------+-------------------+
    | NFS4ERR_NOMATCHING_LAYOUT         | 10060  | Section 15.1.10.5 |
    +-----------------------------------+--------+-------------------+
    | NFS4ERR_NOSPC                     | 28     | Section 15.1.4.9  |
    +-----------------------------------+--------+-------------------+
    | NFS4ERR_NOTDIR                    | 20     | Section 15.1.2.6  |
    +-----------------------------------+--------+-------------------+
    | NFS4ERR_NOTEMPTY                  | 66     | Section 15.1.4.10 |
    +-----------------------------------+--------+-------------------+
    | NFS4ERR_NOTSUPP                   | 10004  | Section 15.1.1.5  |
    +-----------------------------------+--------+-------------------+
    | NFS4ERR_NOT_ONLY_OP               | 10081  | Section 15.1.3.3  |
    +-----------------------------------+--------+-------------------+
    | NFS4ERR_NOT_SAME                  | 10027  | Section 15.1.15.3 |
    +-----------------------------------+--------+-------------------+
    | NFS4ERR_NO_GRACE                  | 10033  | Section 15.1.9.3  |
    +-----------------------------------+--------+-------------------+
    | NFS4ERR_NXIO                      | 6      | Section 15.1.16.3 |
    +-----------------------------------+--------+-------------------+
    | NFS4ERR_OLD_STATEID               | 10024  | Section 15.1.5.5  |
    +-----------------------------------+--------+-------------------+
    | NFS4ERR_OPENMODE                  | 10038  | Section 15.1.8.8  |
    +-----------------------------------+--------+-------------------+
    | NFS4ERR_OP_ILLEGAL                | 10044  | Section 15.1.3.4  |
    +-----------------------------------+--------+-------------------+
    | NFS4ERR_OP_NOT_IN_SESSION         | 10071  | Section 15.1.3.5  |
    +-----------------------------------+--------+-------------------+
    | NFS4ERR_PERM                      | 1      | Section 15.1.6.2  |
    +-----------------------------------+--------+-------------------+
    | NFS4ERR_PNFS_IO_HOLE              | 10075  | Section 15.1.10.6 |
    +-----------------------------------+--------+-------------------+
    | NFS4ERR_PNFS_NO_LAYOUT            | 10080  | Section 15.1.10.7 |
    +-----------------------------------+--------+-------------------+
    | NFS4ERR_RECALLCONFLICT            | 10061  | Section 15.1.14.3 |
    +-----------------------------------+--------+-------------------+
    | NFS4ERR_RECLAIM_BAD               | 10034  | Section 15.1.9.4  |
    +-----------------------------------+--------+-------------------+
    | NFS4ERR_RECLAIM_CONFLICT          | 10035  | Section 15.1.9.5  |
    +-----------------------------------+--------+-------------------+
    | NFS4ERR_REJECT_DELEG              | 10085  | Section 15.1.14.4 |
    +-----------------------------------+--------+-------------------+
    | NFS4ERR_REP_TOO_BIG               | 10066  | Section 15.1.3.6  |
    +-----------------------------------+--------+-------------------+
    | NFS4ERR_REP_TOO_BIG_TO_CACHE      | 10067  | Section 15.1.3.7  |
    +-----------------------------------+--------+-------------------+
    | NFS4ERR_REQ_TOO_BIG               | 10065  | Section 15.1.3.8  |
    +-----------------------------------+--------+-------------------+
    | NFS4ERR_RESTOREFH                 | 10030  | Section 15.1.16.4 |
    +-----------------------------------+--------+-------------------+
    | NFS4ERR_RETRY_UNCACHED_REP        | 10068  | Section 15.1.3.9  |
    +-----------------------------------+--------+-------------------+
    | NFS4ERR_RETURNCONFLICT            | 10086  | Section 15.1.10.8 |
    +-----------------------------------+--------+-------------------+
    | NFS4ERR_ROFS                      | 30     | Section 15.1.4.11 |
    +-----------------------------------+--------+-------------------+
    | NFS4ERR_SAME                      | 10009  | Section 15.1.15.4 |
    +-----------------------------------+--------+-------------------+
    | NFS4ERR_SHARE_DENIED              | 10015  | Section 15.1.8.9  |
    +-----------------------------------+--------+-------------------+
    | NFS4ERR_SEQUENCE_POS              | 10064  | Section 15.1.3.10 |
    +-----------------------------------+--------+-------------------+
    | NFS4ERR_SEQ_FALSE_RETRY           | 10076  | Section 15.1.11.7 |
    +-----------------------------------+--------+-------------------+
    | NFS4ERR_SEQ_MISORDERED            | 10063  | Section 15.1.11.8 |
    +-----------------------------------+--------+-------------------+
    | NFS4ERR_SERVERFAULT               | 10006  | Section 15.1.1.6  |
    +-----------------------------------+--------+-------------------+
    | NFS4ERR_STALE                     | 70     | Section 15.1.2.7  |
    +-----------------------------------+--------+-------------------+
    | NFS4ERR_STALE_CLIENTID            | 10022  | Section 15.1.13.5 |
    +-----------------------------------+--------+-------------------+
    | NFS4ERR_STALE_STATEID             | 10023  | Section 15.1.16.5 |
    +-----------------------------------+--------+-------------------+
    | NFS4ERR_SYMLINK                   | 10029  | Section 15.1.2.8  |
    +-----------------------------------+--------+-------------------+
    | NFS4ERR_TOOSMALL                  | 10005  | Section 15.1.1.7  |
    +-----------------------------------+--------+-------------------+
    | NFS4ERR_TOO_MANY_OPS              | 10070  | Section 15.1.3.11 |
    +-----------------------------------+--------+-------------------+
    | NFS4ERR_UNKNOWN_LAYOUTTYPE        | 10062  | Section 15.1.10.9 |
    +-----------------------------------+--------+-------------------+
    | NFS4ERR_UNSAFE_COMPOUND           | 10069  | Section 15.1.3.12 |
    +-----------------------------------+--------+-------------------+
    | NFS4ERR_WRONGSEC                  | 10016  | Section 15.1.6.3  |
    +-----------------------------------+--------+-------------------+
    | NFS4ERR_WRONG_CRED                | 10082  | Section 15.1.6.4  |
    +-----------------------------------+--------+-------------------+
    | NFS4ERR_WRONG_TYPE                | 10083  | Section 15.1.2.9  |
    +-----------------------------------+--------+-------------------+
    | NFS4ERR_XDEV                      | 18     | Section 15.1.4.12 |
    +-----------------------------------+--------+-------------------+

                   Table 11: Protocol Error Definitions
```

---
#### **15.1.1.  General Errors**

이 섹션에서는 다양한 목적에 적용할 수 있는 오류를 다룹니다.

---
##### **15.1.1.1.  NFS4ERR_BADXDR (Error Code 10036)**

이 작업의 인수가 XDR 정의에 지정된 인수와 일치하지 않습니다. 여기에는 모든 인수가 확인되기 전에 요청이 종료되는 상황이 포함됩니다. 이 오류는 고정 열거형\(부울 포함\)에 열거형에 유효하지 않은 입력 스트림 내 값이 있을 때 적용됩니다. 응답자는 작업 실행을 수행하기 전에 복합 프로시저에 대한 모든 작업을 미리 구문 분석하고 이 경우 RPC 수준 XDR 오류를 반환할 수 있습니다.

---
##### **15.1.1.2.  NFS4ERR_BAD_COOKIE (Error Code 10003)**

클라이언트가 제공한 일부 수량 또는 이전 호출을 위해 서버가 보낸 쿠키로 인덱싱된 정보 세트를 제공하는 작업에 사용됩니다. 값을 의도한 목적으로 사용할 수 없는 경우 이 오류가 발생합니다.

---
##### **15.1.1.3.  NFS4ERR_DELAY (Error Code 10008)**

여러 가지 이유로 인해 회신자는 합리적인 시간 내에 이 작업을 처리할 수 없었습니다. 클라이언트는 기다렸다가 새 슬롯 및 시퀀스 값으로 요청을 시도해야 합니다.

이러한 상황으로 이어질 수 있는 시나리오의 몇 가지 예는 다음과 같습니다.

\* 계층적 저장소를 지원하는 서버는 마이그레이션된 파일을 처리하라는 요청을 받습니다.

\* 작업을 진행하려면 위임 회수가 필요하지만 이 위임이 회수되어 반환될 때까지 기다려야 하기 때문에 적시에 이 요청을 처리하는 것이 불가능합니다.

\* 11.14.3절에 설명된 대로 다른 서버에서 마이그레이션되는 세션에 대해 요청이 수행되고 있으며 소스의 세션 상태에 대한 전체 정보가 부족하여 즉시 요청을 처리할 수 없습니다.

이러한 경우 NFS4ERR\_DELAY 오류를 반환하면 세션 슬롯과 같은 요청자 리소스를 보류하지 않고 필요한 준비 작업을 진행할 수 있습니다. 일정 시간 동안 지연된 후 클라이언트는 종종 거의 동일한 요청의 일부로 문제의 작업을 다시 보낼 수 있습니다. 비멱등성 작업의 잘못된 재발행을 방지하고 응답자의 응답 캐시에서 반환된 응답에서 반환된 NFS4ERR\_DELAY 오류에 대한 응답을 방지해야 하기 때문에 세션 제공 응답 캐시와의 통합이 필요합니다. 처리해야 할 사례가 많이 있으며, 각 사례에는 요청자와 응답자가 서로 다른 종류의 처리가 필요합니다.

\* SEQUENCE 작업에서 NFS4ERR\_DELAY가 반환되면 동일한 슬롯 및 시퀀스 값을 포함하는 SEQUENCE 작업으로 전체 요청이 재시도됩니다. 이 경우 응답자는 동일한 요청의 이전 인스턴스가 해당 오류를 반환하고 응답 캐시에 저장되었기 때문에 SEQUENCE에 대한 응답으로 NFS4ERR\_DELAY가 포함된 응답을 반환하는 것을 피해야 합니다. 응답자가 이렇게 하면 응답자가 NFS4ERR\_DELAY를 생성한 조건이 원래 요청과 재시도 사이의 중간에 수정되었는지 확인할 기회가 없기 때문에 재시도가 효과적이지 않습니다.\(MUST\)

\* 요청의 첫 번째 작업으로 유효하게 나타나는 SEQUENCE 이외의 작업에서 NFS4ERR\_DELAY가 반환되는 경우 처리는 비슷합니다. 수정 없이 전체 요청을 재시도할 수 있습니다. 이 경우에도 응답자는 응답 캐시에 존재한다는 이유만으로 요청의 초기 작업에 대한 응답으로 NFS4ERR\_DELAY가 포함된 응답을 반환하는 것을 피해야 합니다. 응답자가 이렇게 하면 응답자가 NFS4ERR\_DELAY를 생성한 조건이 원래 요청과 재시도 사이의 중간에 수정되었는지 확인할 기회가 없기 때문에 재시도가 효과적이지 않습니다.\(MUST\)

\* 요청의 첫 번째 작업이 아닌 다른 작업에서 NFS4ERR\_DELAY가 반환되는 경우 재시도할 때 요청에는 원래 요청과 다른 SEQUENCE 작업이 포함되어야 하며, 슬롯 ID나 시퀀스 값은 원래 요청과 달라야 합니다. 요청자가 이를 수행하기 때문에 응답 캐시에서 얻은 NFS4ERR\_DELAY 오류를 반환하지 않도록 응답자가 특별한 주의를 기울일 필요가 없습니다. NFS4ERR\_DELAY가 반환되기 전에 비멱등성 작업이 처리되지 않은 경우 요청자는 재발행된 SEQUENCE 작업의 슬롯 ID 또는 시퀀스 값을 수정한다는 점을 제외하고 원래 요청과의 유일한 차이점을 제외하고 전체 요청을 재시도해야 합니다.\(MUST\)

\* 요청 내 첫 번째 작업이 아닌 작업에 대해 NFS4ERR\_DELAY가 반환되고 NFS4ERR\_DELAY가 반환되기 전에 처리된 비멱등 작업이 있는 경우, 정상적으로 요청을 다시 실행하면 비멱등 작업이 잘못 다시 실행되는 문제가 있었습니다. 작업.

- 이러한 상황을 방지하려면 클라이언트가 비멱등성 작업 없이 요청을 다시 발행해야 합니다. 요청은 원래 요청의 SEQUENCE와 다른 슬롯 ID 또는 시퀀스 값을 사용하여 SEQUENCE 작업을 사용해야 합니다. 이것이 완료되었으므로 응답자가 비멱등성 작업을 재실행하는 것을 피할 수 있는 방법은 없습니다. 왜냐하면 다른 SEQUENCE 매개변수로 인해 요청자가 비멱등성 작업이 재시도되고 있음을 인식하지 못하기 때문입니다.

NFS4ERR\_DELAY를 반환하는 기능과 이를 수신할 때 요청자가 다시 보내려는 의지가 없으면 교착 상태가 발생할 수 있습니다. 예를 들어, 회수가 수행되고 위임 반환 또는 위임 반환을 준비하는 작업이 위임 반환이 필요한 다른 작업에 의해 보류되는 경우 세션 슬롯을 사용하지 못할 수 있습니다. 결과적으로 교착 상태가 발생할 수 있습니다.

---
##### **15.1.1.4.  NFS4ERR_INVAL (Error Code 22)**

이 작업에 대한 인수는 요청에 대한 XDR 정의에 지정된 인수와 일치하더라도 어떤 이유로 유효하지 않습니다.

---
##### **15.1.1.5.  NFS4ERR_NOTSUPP (Error Code 10004)**

작업이 선택 사항이고 이 서버에서 지원되지 않거나 작업이 현재 마이너 버전에서 구현되어서는 안 되기 때문에 지원되지 않는 작업입니다.\(MUST NOT\)

---
##### **15.1.1.6.  NFS4ERR_SERVERFAULT (Error Code 10006)**

특정 법적 NFSv4.1 프로토콜 오류 값에 매핑되지 않는 서버에서 오류가 발생했습니다. 클라이언트는 이를 적절한 오류로 변환해야 합니다. UNIX 클라이언트는 이를 EIO로 변환하도록 선택할 수 있습니다.

---
##### **15.1.1.7.  NFS4ERR_TOOSMALL (Error Code 10005)**

클라이언트가 지정한 제한에 따라 작업이 다양한 양의 데이터를 반환하는 경우에 사용됩니다. 반환된 데이터가 클라이언트가 지정한 제한 내에 들어갈 수 없는 경우 이 오류가 발생합니다.

---
#### **15.1.2.  Filehandle Errors**

이러한 오류는 현재 또는 저장된 파일 핸들 또는 현재 파일 핸들이 되도록 PUTFH에 전달된 파일 핸들이 어떤 방식으로든 유효하지 않은 상황을 처리합니다. 여기에는 파일 핸들이 일반적으로 유효한 파일 핸들이지만 현재 작업에 적합한 개체 유형이 아닌 상황이 포함됩니다.

오류 설명이 현재 또는 저장된 파일 핸들에 문제가 있음을 나타내는 경우, 파일 핸들이 해당 작업의 암시적 인수인 경우에만 조건을 확인한다는 점을 이해해야 합니다.

---
##### **15.1.2.1.  NFS4ERR_BADHANDLE (Error Code 10001)**

현재 서버에 대한 잘못된 NFS 파일 핸들입니다. 현재 파일 핸들이 내부 일관성 검사에 실패했습니다. 일단 PUTFH에 의해 유효한 것으로 승인되면 후속 상태 변경으로 인해 파일 핸들이 이 오류를 생성할 수 없습니다.

---
##### **15.1.2.2.  NFS4ERR_FHEXPIRED (Error Code 10014)**

현재 작업의 인수인 현재 또는 저장된 파일 핸들은 일시적이며 서버에서 만료되었습니다.

---
##### **15.1.2.3.  NFS4ERR_ISDIR (Error Code 21)**

현재 작업에서 디렉터리가 이 작업의 대상으로 허용되지 않는 경우 현재 또는 저장된 파일 핸들은 디렉터리를 지정합니다.

---
##### **15.1.2.4.  NFS4ERR_MOVED (Error Code 10019)**

현재 파일 핸들 객체를 포함하는 파일 시스템이 서버에 없거나 사용된 네트워크 주소로 액세스할 수 없습니다. 다른 네트워크 주소 집합에서 액세스할 수 있게 되었거나, 다른 서버로 재배치 또는 마이그레이션되었거나, 존재하지 않았을 수도 있습니다. 클라이언트는 현재 파일 핸들에 대한 fs\_locations 또는 fs\_locations\_info 속성을 획득하여 새 파일 시스템 위치를 획득할 수 있습니다. 자세한 내용은 섹션 11.3을 참조하세요.

NFS4ERR\_DELAY의 경우와 마찬가지로 NFS4ERR\_MOVED가 반환되기 전에 하나 이상의 멱등성이 아닌 작업이 COMPOUND 내에서 성공적으로 실행되었을 수 있습니다. 이 때문에 새 위치가 결정되면 NFS4ERR\_MOVED를 수신한 원래 요청이 완전히 다시 실행되어서는 안 됩니다. 대신, 클라이언트는 성공적으로 실행된 비멱등성 작업을 제거한 새 COMPOUND를 보내야 합니다. 클라이언트가 새 COMPOUND에 대해 동일한 세션을 사용하는 경우 해당 SEQUENCE 작업은 다른 슬롯 ID 또는 시퀀스를 사용해야 합니다.

---
##### **15.1.2.5.  NFS4ERR_NOFILEHANDLE (Error Code 10020)**

현재 작업에 논리적 현재 또는 저장된 파일 핸들 값이 필요하며 설정되지 않았습니다. 이는 잘못된 COMPOUND 작업의 결과일 수 있습니다\(즉, 현재 파일 핸들을 설정해야 하는 작업 앞에 PUTFH 또는 PUTROOTFH가 설정되지 않음\).

---
##### **15.1.2.6.  NFS4ERR_NOTDIR (Error Code 20)**

현재\(또는 저장된\) 파일 핸들은 디렉터리가 필요한 작업에 대한 디렉터리가 아닌 개체를 지정합니다.

---
##### **15.1.2.7.  NFS4ERR_STALE (Error Code 70)**

현재 작업에 대한 인수를 지정하는 현재 또는 저장된 파일 핸들 값이 잘못되었습니다. 해당 파일 핸들이 참조하는 파일이 더 이상 존재하지 않거나 해당 파일에 대한 액세스가 취소되었습니다.

---
##### **15.1.2.8.  NFS4ERR_SYMLINK (Error Code 10029)**

현재 파일 핸들은 현재 작업이 대상으로 기호 링크를 허용하지 않는 경우 기호 링크를 지정합니다.

---
##### **15.1.2.9.  NFS4ERR_WRONG_TYPE (Error Code 10083)**

현재\(또는 저장된\) 파일 핸들은 현재 작업에 대해 유효하지 않은 유형의 객체를 지정하며 더 이상 적용되는 특정 오류\(예: NFS4ERR\_ISDIR 또는 NFS4ERR\_SYMLINK\)가 없습니다. NFSv4.0에서는 이러한 상황에서 일반적으로 덜 구체적인 오류 NFS4ERR\_INVAL이 발생합니다.

---
#### **15.1.3.  Compound Structure Errors**

이 섹션에서는 특정 작업보다는 복합 요청의 전체 구조\(COMPOUND 및 CB\_COMPOUND를 모두 포함함을 의미\)와 관련된 오류를 다룹니다.

복합 요청에 나타날 수 있는 작업에는 여러 가지 기본 제약이 있습니다. 세션은 화합물 시작 시 시퀀스 작업\(SEQUENCE 또는 CB\_SEQUENCE\)을 요구하여 이러한 기본 제약 조건을 추가합니다.

---
##### **15.1.3.1.  NFS_OK (Error code 0)**

모든 구성 작업이 오류 없이 완료되어 작업이 성공적으로 완료되었음을 나타냅니다.

---
##### **15.1.3.2.  NFS4ERR_MINOR_VERS_MISMATCH (Error code 10021)**

지정된 부 버전이 현재 수신기에서 지원하는 버전이 아닙니다. 이 값은 복합의 전체 상태에서 반환되지만 결과는 결과 개수를 0으로 지정하므로 특정 작업과 연관되지 않습니다.

---
##### **15.1.3.3.  NFS4ERR_NOT_ONLY_OP (Error Code 10081)**

세션 외부에서 실행이 허용되는 특정 작업은 화합물이 시퀀스 작업으로 시작되지 않을 때마다 화합물 내의 유일한 작업이어야 합니다. 이 오류는 해당 제약 조건이 충족되지 않을 때 발생합니다.\(MUST\)

---
##### **15.1.3.4.  NFS4ERR_OP_ILLEGAL (Error Code 10044)**

작업 코드가 현재 복합 프로시저에 대해 유효한 코드가 아닙니다. 이 오류와 일치하는 결과 스트림의 opcode는 잘못된 값이지만 요청 스트림에 나타나는 값은 다를 수 있습니다. 잘못된 값이 나타나고 응답자가 작업 실행을 수행하기 전에 복합 프로시저에 대한 모든 작업을 미리 구문 분석하는 경우 RPC 수준 XDR 오류가 반환될 수 있습니다.

---
##### **15.1.3.5.  NFS4ERR_OP_NOT_IN_SESSION (Error Code 10071)**

대부분의 전달 작업과 모든 콜백 작업은 세션 컨텍스트 내에서만 유효하므로 문제의 복합 요청은 시퀀스 작업으로 시작해야 합니다. 세션 컨텍스트 외부에서 이러한 작업을 실행하려고 하면 이 오류가 발생합니다.\(MUST\)

---
##### **15.1.3.6.  NFS4ERR_REP_TOO_BIG (Error Code 10066)**

복합에 대한 응답은 채널의 협상된 최대 응답 크기를 초과합니다.

---
##### **15.1.3.7.  NFS4ERR_REP_TOO_BIG_TO_CACHE (Error Code 10067)**

현재 요청에 대한 시퀀스가 ​​이 요청이 캐시되도록 지정하는 경우 복합에 대한 응답은 응답 캐시에 캐시된 응답에 대해 채널의 협상된 최대 크기를 초과합니다.

---
##### **15.1.3.8.  NFS4ERR_REQ_TOO_BIG (Error Code 10065)**

복합 요청이 채널의 협상된 요청 최대 크기를 초과합니다.

---
##### **15.1.3.9.  NFS4ERR_RETRY_UNCACHED_REP (Error Code 10068)**

요청자가 이전에 응답 캐시에 배치되지 않도록 요청한 화합물을 재시도했습니다.

---
##### **15.1.3.10.  NFS4ERR_SEQUENCE_POS (Error Code 10064)**

복합 요청의 첫 번째 작업이 아닌 다른 위치에 시퀀스 작업이 나타났습니다.

---
##### **15.1.3.11.  NFS4ERR_TOO_MANY_OPS (Error Code 10070)**

복합 요청에 작업이 너무 많아 세션이 생성될 때 협상된 수를 초과했습니다.

---
##### **15.1.3.12.  NFS4ERR_UNSAFE_COMPOUND (Error Code 10068)**

클라이언트가 안전하지 않은 작업 혼합, 특히 현재 파일 핸들을 변경하고 뒤에 GETFH가 오지 않는 비멱등성 작업을 사용하여 COMPOUND 요청을 보냈습니다.

---
#### **15.1.4.  File System Errors**

이러한 오류는 프로토콜이나 NFSv4.x 기능이 아닌 기본 파일 시스템 구현에서 발생한 상황을 설명합니다.

---
##### **15.1.4.1.  NFS4ERR_BADTYPE (Error Code 10007)**

CREATE에 부적절한 유형이 지정된 객체를 생성하려고 했습니다. 이는 유형이 정의되지 않았거나, 유형이 서버에서 지원되지 않거나, 유형이 CREATE에 의해 생성되도록 의도되지 않았기 때문일 수 있습니다\(예: OPEN을 사용하여 파일을 수행하는 데 사용되는 일반 파일 또는 명명된 속성\). 창조\).

---
##### **15.1.4.2.  NFS4ERR_DQUOT (Error Code 69)**

리소스\(할당량\) 하드 한도를 초과했습니다. 서버의 사용자 리소스 제한이 초과되었습니다.

---
##### **15.1.4.3.  NFS4ERR_EXIST (Error Code 17)**

\(생성, 이름 변경 또는 링크 시\) 지정된 대상 이름의 파일이 이미 존재합니다.

---
##### **15.1.4.4.  NFS4ERR_FBIG (Error Code 27)**

파일이 너무 큽니다. 이 작업으로 인해 파일이 서버 제한을 ​​초과하게 되었을 수 있습니다.

---
##### **15.1.4.5.  NFS4ERR_FILE_OPEN (Error Code 10046)**

작업과 관련된 파일이 현재 열려 있으므로 작업이 허용되지 않습니다. 서버는 열려 있는 파일에 대한 연결, 제거 또는 이름 변경을 허용하지 않을 수 있지만 필수는 아닙니다.

---
##### **15.1.4.6.  NFS4ERR_IO (Error Code 5)**

파일 시스템이 복구를 제공할 수 없는 I/O 오류가 발생했음을 나타냅니다.

---
##### **15.1.4.7.  NFS4ERR_MLINK (Error Code 31)**

요청으로 인해 파일이 초과해야 할 수 있는 하드 링크 수에 대한 서버 제한이 발생했을 수 있습니다.

---
##### **15.1.4.8.  NFS4ERR_NOENT (Error Code 2)**

해당 파일이나 디렉터리가 없음을 나타냅니다. 지정한 파일 또는 디렉터리 이름이 존재하지 않습니다.

---
##### **15.1.4.9.  NFS4ERR_NOSPC (Error Code 28)**

장치에 남은 공간이 없음을 나타냅니다. 이 작업으로 인해 서버의 파일 시스템이 해당 제한을 초과했을 수 있습니다.

---
##### **15.1.4.10.  NFS4ERR_NOTEMPTY (Error Code 66)**

비어 있지 않은 디렉토리를 제거하려고 했습니다.

---
##### **15.1.4.11.  NFS4ERR_ROFS (Error Code 30)**

읽기 전용 파일 시스템을 나타냅니다. 읽기 전용 파일 시스템에서 수정 작업을 시도했습니다.

---
##### **15.1.4.12.  NFS4ERR_XDEV (Error Code 18)**

연결과 같이 부적절하게 경계를 넘는 작업을 수행하려는 시도를 나타냅니다. 이는 다음과 같은 경계로 인해 발생할 수 있습니다.

\* 파일 시스템 간\(fsid가 다른 경우\)

\* 서로 다른 명명된 속성 디렉터리 간 또는 명명된 속성 디렉터리와 일반 디렉터리 간.

\* 파일 시스템 구현이 별도의 것으로 처리하는 파일 시스템의 바이트 범위 간\(예: 공간 계산 목적\) 및 바이트 범위 간의 교차 연결이 허용되지 않는 경우.

---
#### **15.1.5.  State Management Errors**

이러한 오류는 지정된 작업에 전달된 stateid\(또는 stateid 중 하나\)에 문제가 있음을 나타냅니다. 여기에는 stateid가 유효하지 않은 상황과 stateid가 유효하지만 취소된 잠금 상태를 지정하는 상황이 포함됩니다. 작업에 따라 유효한 상태 ID는 열기, 바이트 범위 잠금, 파일 또는 디렉터리 위임, 레이아웃 또는 장치 맵을 지정할 수 있습니다.

---
##### **15.1.5.1.  NFS4ERR_ADMIN_REVOKED (Error Code 10047)**

stateid는 임대가 유효한 동안 관리 상호 작용으로 인해 취소된 모든 유형의 잠금 상태를 지정합니다.

---
##### **15.1.5.2.  NFS4ERR_BAD_STATEID (Error Code 10026)**

stateid가 유효한 상태를 올바르게 지정하지 않습니다. stateid가 검증되는 방법에 대한 논의는 섹션 8.2.4 및 8.2.3을 참조하십시오.

---
##### **15.1.5.3.  NFS4ERR_DELEG_REVOKED (Error Code 10087)**

stateid는 클라이언트가 잠금을 회수할 때 잠금을 반환하지 못하여 취소된 모든 유형\(위임 또는 레이아웃\)의 회수 가능한 잠금 상태를 지정합니다.

---
##### **15.1.5.4.  NFS4ERR_EXPIRED (Error Code 10011)**

stateid는 클라이언트의 임대 만료로 인해 취소된 모든 유형의 잠금 상태를 지정합니다\(임대 만료 직후 또는 나중에 충돌하는 잠금 요청 이후\).

---
##### **15.1.5.5.  NFS4ERR_OLD_STATEID (Error Code 10024)**

seqid 값이 0이 아닌 stateid는 사용자가 지정한 주의 현재 seqid와 일치합니다.

---
#### **15.1.6.  Security Errors**

NFSv4.1의 다양한 권한 관련 오류는 다음과 같습니다.

---
##### **15.1.6.1.  NFS4ERR_ACCESS (Error Code 13)**

권한이 거부되었음을 나타냅니다. 호출자에게 요청된 작업을 수행할 수 있는 올바른 권한이 없습니다. 이를 소유자 또는 권한이 있는 사용자 권한 실패로 제한하는 NFS4ERR\_PERM\(섹션 15.1.6.2\) 및 사용자의 자격 증명을 기반으로 임시 객체를 삭제하거나 수정하기 위한 적절한 권한을 처리하는 NFS4ERR\_WRONG\_CRED\(섹션 15.1.6.4\)와 대조해 보세요. 그것이 그들을 창조했습니다.

---
##### **15.1.6.2.  NFS4ERR_PERM (Error Code 1)**

요청자가 소유자가 아님을 나타냅니다. 호출자가 권한 있는 사용자\(루트\)도 아니고 작업 대상의 소유자도 아니기 때문에 작업이 허용되지 않았습니다.

---
##### **15.1.6.3.  NFS4ERR_WRONGSEC (Error Code 10016)**

작업을 위해 클라이언트에서 사용 중인 보안 메커니즘이 서버의 보안 정책과 일치하지 않음을 나타냅니다. 클라이언트는 사용 중인 보안 메커니즘을 변경하고 작업을 다시 보내야 합니다\(그러나 동일한 슬롯 ID와 시퀀스 ID를 사용해서는 안 됩니다. 다시 보낼 때 둘 중 하나 또는 둘 다 달라야 합니다\). SECINFO 및 SECINFO\_NO\_NAME을 사용하여 적절한 메커니즘을 결정할 수 있습니다.\(MUST\)

---
##### **15.1.6.4.  NFS4ERR_WRONG_CRED (Error Code 10082)**

상태를 수정하는 것이 허용되지 않은 보안 주체가 상태를 조작하는 작업을 시도했습니다.

---
#### **15.1.7.  Name Errors**

NFSv4의 이름은 UTF-8 문자열입니다. 문자열이 유효한 UTF-8이 아니거나 길이가 0인 경우 NFS4ERR\_INVAL 오류가 발생합니다. 이 외에도 이름과 관련된 특정 문제를 나타내는 다른 오류가 많이 있습니다.

---
##### **15.1.7.1.  NFS4ERR_BADCHAR (Error Code 10040)**

UTF-8 문자열에는 사용되는 컨텍스트에서 서버가 지원하지 않는 문자가 포함되어 있습니다.

---
##### **15.1.7.2.  NFS4ERR_BADNAME (Error Code 10041)**

요청의 이름 문자열은 서버에서 지원하는 유효한 UTF-8 문자로 구성되어 있지만 해당 이름은 서버에서 현재 작업에 대한 유효한 이름으로 지원되지 않습니다. 예를 들어, 파일 시스템이 상위 디렉터리에 대한 링크에 해당 이름을 사용하는 서버에 ".."라는 이름의 파일이나 디렉터리를 만드는 경우가 있습니다.

---
##### **15.1.7.3.  NFS4ERR_NAMETOOLONG (Error Code 63)**

작업의 파일 이름이 서버의 구현 제한을 초과하는 경우 반환됩니다.

---
#### **15.1.8.  Locking Errors**

이 섹션에서는 공유 예약 및 바이트 범위 잠금과 관련된 잠금 관련 오류를 다룹니다. 잠금 회수 프로세스와 관련된 오류는 처리하지 않습니다. 이는 섹션 15.1.9에서 다루어집니다.

---
##### **15.1.8.1.  NFS4ERR_BAD_RANGE (Error Code 10042)**

LOCK, LOCKT 또는 LOCKU 작업의 바이트 범위는 서버에서 허용되지 않습니다. 예를 들어, 이 오류는 32비트 범위만 지원하는 서버가 해당 서버에서 처리할 수 없는 범위를 수신할 때 발생합니다. \(섹션 18.10.3 참조\)

---
##### **15.1.8.2.  NFS4ERR_DEADLOCK (Error Code 10045)**

서버는 READW\_LT 또는 WRITEW\_LT LOCK 작업에 대한 바이트 범위 잠금 교착 상태 조건을 확인할 수 있습니다.

---
##### **15.1.8.3.  NFS4ERR_DENIED (Error Code 10010)**

파일을 잠그려는 시도가 거부되었습니다. 이는 일시적인 조건일 수 있으므로 클라이언트는 잠금이 수락될 때까지 잠금 요청을 다시 보내는 것이 좋습니다\(그러나 동일한 슬롯 ID와 시퀀스 ID를 사용하면 안 됩니다. 재전송 시 둘 중 하나 또는 둘 다 달라야 합니다\). 재전송에 대한 설명은 섹션 9.6을 참조하세요.\(MUST\)

---
##### **15.1.8.4.  NFS4ERR_LOCKED (Error Code 10012)**

I/O와 기존 잠금 사이에 충돌이 있는 파일에서 읽기 또는 쓰기 작업이 시도되었습니다.

\* 수행 중인 I/O와 일치하지 않는 공유 예약이 있습니다.

\* 읽거나 쓸 범위가 기존 필수 바이트 범위 잠금과 교차합니다.

---
##### **15.1.8.5.  NFS4ERR_LOCKS_HELD (Error Code 10037)**

예상치 못한 잠금으로 인해 작업이 차단되었습니다.

---
##### **15.1.8.6.  NFS4ERR_LOCK_NOTSUPP (Error Code 10043)**

소유자가 이미 보유하고 있는 바이트 범위 잠금 범위의 업그레이드 또는 다운그레이드가 필요한 LOCK 작업이 시도되었으며 서버는 잠금의 원자성 업그레이드 또는 다운그레이드를 지원하지 않습니다.

---
##### **15.1.8.7.  NFS4ERR_LOCK_RANGE (Error Code 10028)**

LOCK 작업은 현재 잠금 소유자에 대해 현재 보유하고 있는 바이트 범위 잠금과 부분적으로 겹치는 범위에서 작동하고 있으며 서버가 이러한 유형의 요청을 지원하지 않는 단일 바이트 범위 잠금과 정확하게 일치하지 않습니다. POSIX 잠금 의미 체계를 구현하지 않습니다\[21\]. 이것이 LOCK, LOCKT 및 LOCKU에 각각 어떻게 적용되는지에 대한 설명은 섹션 18.10.4, 18.11.4 및 18.12.4를 참조하세요.

---
##### **15.1.8.8.  NFS4ERR_OPENMODE (Error Code 10038)**

클라이언트가 READ, WRITE, LOCK 또는 전달된 stateid에 의해 승인되지 않은 기타 작업\(예: 읽기 전용 액세스를 위해 열린 파일에 쓰기\)을 시도했습니다.

---
##### **15.1.8.9.  NFS4ERR_SHARE_DENIED (Error Code 10015)**

공유 충돌로 인해 공유 예약이 있는 파일을 열려는 시도가 실패했습니다.

---
#### **15.1.9.  Reclaim Errors**

이러한 오류는 서버를 다시 시작한 후 잠금을 회수하는 프로세스와 관련이 있습니다.

---
##### **15.1.9.1.  NFS4ERR_COMPLETE_ALREADY (Error Code 10054)**

클라이언트는 이전에 해당 범위가 전역인지 또는 per-fs RECLAIM\_COMPLETE의 경우 동일한 파일 시스템인지 여부에 관계없이 동일한 범위를 지정하여 성공적인 RECLAIM\_COMPLETE 작업을 보냈습니다. 추가 RECLAIM\_COMPLETE 작업은 필요하지 않으며 이로 인해 이 오류가 발생합니다.

---
##### **15.1.9.2.  NFS4ERR_GRACE (Error Code 10013)**

이 오류는 잠금이 요청된 파일 시스템 개체와 관련하여 서버가 유예 기간에 있을 때 반환됩니다. 이 상황에서는 비재확보 잠금 요청을 승인할 수 없습니다. 이는 다음 중 하나 때문에 발생할 수 있습니다.

\* 서버에는 잠금이 부여될 수 있는지 여부를 결정하기 위해 잠재적으로 회수될 수 있는 잠금에 대한 충분한 정보가 없습니다.

\* 해당 요청은 아직 적절한 RECLAIM\_COMPLETE 작업을 수행하지 않은 잠금을 회수하여 새 잠금을 획득할 수 있도록 하는 클라이언트에 의해 이루어집니다.

per-fs 유예 기간의 경우 유예 기간이 시작되는 상황을 인식하지 못하는 클라이언트\(예: 현재 대상 파일 시스템을 사용하는 클라이언트\)가 있을 수 있습니다. 이러한 클라이언트는 다른 클라이언트와 마찬가지로 유예 기간이 끝날 때까지 주기적으로 요청을 다시 시도해야 합니다.

---
##### **15.1.9.3.  NFS4ERR_NO_GRACE (Error Code 10033)**

서버가 충돌하는 상태가 다른 클라이언트에 제공되지 않았음을 보장할 수 없는 상황에서 클라이언트 상태 회수를 시도했습니다. 이는 다음 상황 중 하나에서 발생합니다.

\* 요청이 이루어진 파일 시스템 개체에 적용되는 활성 유예 기간이 없습니다.

\* 요청하는 클라이언트에는 잠금 회수에 대한 현재 역할이 없습니다.

\* 이전 작업으로 인해 서버가 회수 간섭 엣지 조건이 존재하지 않는다고 판단할 수 없는 상황이 발생했습니다.

---
##### **15.1.9.4.  NFS4ERR_RECLAIM_BAD (Error Code 10034)**

서버는 클라이언트가 시도한 회수가 유효하지 않다고 판단했습니다. 즉, 회수 중인 것으로 지정된 잠금이 서버 재시작 또는 파일 시스템 마이그레이션 이벤트 이전에는 존재할 수 없었을 가능성이 있습니다. 서버는 이러한 결정을 내릴 의무가 없으며 일반적으로 다시 시작하기 전에 클라이언트에 부여된 잠금만 회수하기 위해 클라이언트에 의존합니다. 그러나 서버에 이러한 결정을 내릴 수 있는 신뢰할 수 있는 정보가 있는 경우 이 오류는 회수가 유효하지 않아 거부되었음을 나타냅니다. 이는 NFS4ERR\_RECLAIM\_CONFLICT\(섹션 15.1.9.5 참조\) 오류와 반대입니다. 여기서 서버는 잘못된 회수가 있었는지 확인할 수만 있고 어떤 요청이 잘못된지는 확인할 수 없습니다.

---
##### **15.1.9.5.  NFS4ERR_RECLAIM_CONFLICT (Error Code 10035)**

클라이언트가 시도한 회수에서 충돌이 발생하여 만족할 수 없습니다. 이는 클라이언트가 잘못 동작하고 있음을 나타낼 수 있지만 반드시 오류를 수신한 클라이언트는 아닙니다. 잘못된 동작은 이 클라이언트가 충돌한 잠금을 설정한 클라이언트 측에서 발생할 수 있습니다. 관련 오류 NFS4ERR\_RECLAIM\_BAD에 대해서는 섹션 15.1.9.4를 참조하십시오.

---
#### **15.1.10.  pNFS Errors**

이 섹션에서는 NFSv4.1을 사용하여 데이터 서버와 통신하는 것과 관련된 오류를 포함하여 pNFS 관련 오류를 다룹니다.

---
##### **15.1.10.1.  NFS4ERR_BADIOMODE (Error Code 10049)**

유효하지 않거나 부적절한 레이아웃 iomode가 지정되었습니다. 예를 들어 부적절한 레이아웃 iomode의 경우, 클라이언트의 LAYOUTGET 작업이 LAYOUTIOMODE4\_RW의 iomode를 지정했고 서버가 클라이언트가 데이터 서버에 쓰기 요청을 보내는 것을 허용할 수도 없고 허용할 의사도 없다고 가정합니다. 서버는 NFS4ERR\_BADIOMODE로 응답할 수 있습니다. 그러면 클라이언트는 iomode가 LAYOUTIOMODE4\_READ인 또 다른 LAYOUTGET을 보냅니다.

---
##### **15.1.10.2.  NFS4ERR_BADLAYOUT (Error Code 10050)**

지정된 레이아웃이 어떤 면에서 잘못되었습니다. LAYOUTCOMMIT의 경우 이는 지정된 레이아웃이 클라이언트에 의해 유지되지 않거나 LAYOUTIOMODE4\_RW 모드가 아님을 나타냅니다. LAYOUTGET의 경우 클라이언트의 최소 길이 사양과 일치하는 레이아웃을 허용할 수 없음을 나타냅니다.

---
##### **15.1.10.3.  NFS4ERR_LAYOUTTRYLATER (Error Code 10058)**

파일에 대한 레이아웃을 일시적으로 사용할 수 없습니다. 클라이언트는 나중에 다시 전송해야 합니다\(그러나 동일한 슬롯 ID와 시퀀스 ID를 사용해서는 안 됩니다. 다시 전송할 때 둘 중 하나 또는 둘 다 달라야 합니다\).\(MUST\)

---
##### **15.1.10.4.  NFS4ERR_LAYOUTUNAVAILABLE (Error Code 10059)**

현재 파일 시스템이나 특정 지정된 파일에 레이아웃을 사용할 수 없는 경우 반환됩니다.

---
##### **15.1.10.5.  NFS4ERR_NOMATCHING_LAYOUT (Error Code 10060)**

레이아웃이 호출되고 클라이언트에 호출되는 레이아웃의 사양과 일치하는 레이아웃이 없을 때 반환됩니다.

---
##### **15.1.10.6.  NFS4ERR_PNFS_IO_HOLE (Error Code 10075)**

pNFS 클라이언트가 스파스 패킹을 사용하는 데이터 서버 파일의 불법적인 홀에 읽기 또는 쓰기를 시도했습니다. 섹션 13.4.4를 참조하십시오.

---
##### **15.1.10.7.  NFS4ERR_PNFS_NO_LAYOUT (Error Code 10080)**

pNFS 클라이언트가 유효한 레이아웃을 보유하지 않은 채\(데이터 서버에 대한 요청을 사용하여\) 파일 읽기 또는 쓰기를 시도했습니다. 여기에는 클라이언트에 레이아웃이 있지만 iomode가 쓰기를 허용하지 않는 경우가 포함됩니다.

---
##### **15.1.10.8.  NFS4ERR_RETURNCONFLICT (Error Code 10086)**

파일에 대해 보류 중인 LAYOUTRETURN이 수신되기 전에 LAYOUTGET을 수행하려고 했기 때문에 레이아웃을 사용할 수 없습니다. 섹션 12.5.5.2.1.3을 참조하십시오.

---
##### **15.1.10.9.  NFS4ERR_UNKNOWN_LAYOUTTYPE (Error Code 10062)**

클라이언트가 서버에서 지원하지 않는 레이아웃 유형을 지정했습니다.

---
#### **15.1.11.  Session Use Errors**

이 섹션에서는 세션을 사용할 때 발생하는 오류, 즉 요청이 Sequence\(예: SEQUENCE 또는 CB\_SEQUENCE\) 작업을 사용할 때 발생하는 오류를 다룹니다.

---
##### **15.1.11.1.  NFS4ERR_BADSESSION (Error Code 10052)**

지정된 세션 ID는 작업이 처리되는 서버에서 알 수 없습니다.

---
##### **15.1.11.2.  NFS4ERR_BADSLOT (Error Code 10053)**

요청자가 응답자의 슬롯 테이블에 없는 슬롯을 사용하려고 시도하는 Sequence 작업을 보냈습니다. 슬롯이 폐기되었을 수도 있습니다.

---
##### **15.1.11.3.  NFS4ERR_BAD_HIGH_SLOT (Error Code 10077)**

Sequence 작업의 maximum\_slot 인수가 응답자의 강제된 maximum\_slotid를 초과합니다.

---
##### **15.1.11.4.  NFS4ERR_CB_PATH_DOWN (Error Code 10048)**

콜백 경로를 통해 클라이언트에 접속하는 중에 문제가 발생했습니다. 이 오류의 기능은 SEQUENCE 작업에 대한 응답에서 상태 플래그를 사용하여 대부분 대체되었습니다\(섹션 18.46 참조\).

---
##### **15.1.11.5.  NFS4ERR_DEADSESSION (Error Code 10078)**

지정된 세션은 종료된 영구 세션이며 새 요청을 수락하지 않거나 기존 요청에 대한 새 작업을 수행하지 않습니다\(서버를 다시 시작하기 전에 요청이 부분적으로 실행된 경우\).

---
##### **15.1.11.6.  NFS4ERR_CONN_NOT_BOUND_TO_SESSION (Error Code 10055)**

지정된 세션과 연결되지 않은 연결에서 시퀀스 작업이 전송되었습니다. 여기서 클라이언트는 연결 연결이 SP4\_MACH\_CRED 또는 SP4\_SSV 상태 보호를 통해 적용되도록 지정했습니다.

---
##### **15.1.11.7.  NFS4ERR_SEQ_FALSE_RETRY (Error Code 10076)**

요청자가 응답 캐시에 있는 슬롯 ID 및 시퀀스 ID를 사용하여 Sequence 작업을 보냈지만 응답자는 재시도된 요청이 원래 요청과 동일하지 않음을 감지했습니다. 섹션 2.10.6.1.3.1을 참조하십시오.

---
##### **15.1.11.8.  NFS4ERR_SEQ_MISORDERED (Error Code 10063)**

요청자가 잘못된 시퀀스 ID를 사용하여 시퀀스 작업을 보냈습니다.

---
#### **15.1.12.  Session Management Errors**

이 섹션에서는 세션 관리에 사용되는 요청과 관련된 오류를 다룹니다.

---
##### **15.1.12.1.  NFS4ERR_BACK_CHAN_BUSY (Error Code 10057)**

서버에 미해결 콜백 요청이 있어서 세션을 삭제할 수 없을 때 세션을 삭제하려고 했습니다.

---
##### **15.1.12.2.  NFS4ERR_BAD_SESSION_DIGEST (Error Code 10051)**

SET\_SSV 요청에 사용된 다이제스트가 유효하지 않습니다.

---
#### **15.1.13.  Client Management Errors**

이 섹션에서는 클라이언트 ID를 생성하고 관리하는 데 사용되는 요청과 관련된 오류를 다룹니다.

---
##### **15.1.13.1.  NFS4ERR_CLIENTID_BUSY (Error Code 10074)**

DESTROY\_CLIENTID 작업에서 폐기할 클라이언트 ID와 연결된 세션 및/또는 만료되지 않은 상태가 있음을 발견했습니다.

---
##### **15.1.13.2.  NFS4ERR_CLID_INUSE (Error Code 10017)**

EXCHANGE\_ID 작업을 처리하는 동안 유효한 임대 상태의 기존 클라이언트와 일치하는 co\_ownerid 필드가 서버에 표시되었지만 EXCHANGE\_ID 작업을 보내는 주체가 기존 클라이언트를 설정한 주체와 다릅니다. 이는 클라이언트 간의 충돌\(대부분 우연으로 인한\)을 나타냅니다. 클라이언트는 co\_ownerid를 변경하고 EXCHANGE\_ID를 다시 전송하여 복구해야 합니다\(그러나 동일한 슬롯 ID와 시퀀스 ID를 사용하면 안 됩니다. 재전송 시 하나 또는 둘 다 달라야 합니다\).\(MUST\)

---
##### **15.1.13.3.  NFS4ERR_ENCR_ALG_UNSUPP (Error Code 10079)**

SSV를 통해 상태 보호를 지정하는 EXCHANGE\_ID가 전송되었으며 클라이언트가 제공한 암호화 알고리즘 세트에는 서버에서 지원하는 것이 포함되지 않았습니다.

---
##### **15.1.13.4.  NFS4ERR_HASH_ALG_UNSUPP (Error Code 10072)**

SSV를 통해 상태 보호를 지정하는 EXCHANGE\_ID가 전송되었으며 클라이언트가 제공한 해싱 알고리즘 세트에는 서버에서 지원하는 것이 포함되지 않았습니다.

---
##### **15.1.13.5.  NFS4ERR_STALE_CLIENTID (Error Code 10022)**

서버에서 인식되지 않는 클라이언트 ID가 작업에 전달되었습니다. NFSv4.0의 경우와 달리 일반 잠금 작업에서는 클라이언트 ID가 명시적으로 서버에 전달되지 않으므로 이 오류가 발생할 수 없습니다. 대신 서버가 다시 시작되면 연결된 세션의 오류를 통해 먼저 나타나며, 클라이언트 ID를 새 세션과 연결하려고 하면 클라이언트 ID의 오래된 상태가 감지됩니다.

---
#### **15.1.14.  Delegation Errors**

이 섹션에서는 위임 요청 및 반환과 관련된 오류를 다룹니다.

---
##### **15.1.14.1.  NFS4ERR_DELEG_ALREADY_WANTED (Error Code 10056)**

클라이언트가 동일한 위임을 원한다고 이미 등록한 상태에서 위임을 요청했습니다.

---
##### **15.1.14.2.  NFS4ERR_DIRDELEG_UNAVAIL (Error Code 10084)**

이 오류는 서버가 요청된 디렉터리 위임을 제공할 수 없거나 제공할 의사가 없을 때 반환됩니다.

---
##### **15.1.14.3.  NFS4ERR_RECALLCONFLICT (Error Code 10061)**

해당 개체에 대해 현재 진행 중인 회수 작업 충돌로 인해 회수 가능한 개체\(예: 레이아웃 또는 위임\)를 사용할 수 없습니다.

---
##### **15.1.14.4.  NFS4ERR_REJECT_DELEG (Error Code 10085)**

새 위임을 처리하기 위해 호출된 콜백 작업이 이를 거부했습니다.

---
#### **15.1.15.  Attribute Handling Errors**

이 섹션에서는 NFSv4 내 속성 처리와 관련된 오류를 다룹니다.

---
##### **15.1.15.1.  NFS4ERR_ATTRNOTSUPP (Error Code 10032)**

지정된 속성은 서버에서 지원되지 않습니다. 이 오류는 GETATTR 작업에 의해 반환되어서는 안 됩니다.\(MUST NOT\)

---
##### **15.1.15.2.  NFS4ERR_BADOWNER (Error Code 10039)**

이 오류는 owner 또는 owner\_group 속성 값이나 ACL 속성 값 내 ACE의 who 필드를 로컬 표현으로 변환할 수 없을 때 반환됩니다.

---
##### **15.1.15.3.  NFS4ERR_NOT_SAME (Error Code 10027)**

이 오류는 비교된 속성이 클라이언트 요청에 제공된 속성과 동일하지 않음을 나타내기 위해 VERIFY 작업에 의해 반환됩니다.

---
##### **15.1.15.4.  NFS4ERR_SAME (Error Code 10009)**

이 오류는 비교된 속성이 클라이언트 요청에 제공된 속성과 동일했음을 나타내기 위해 NVERIFY 작업에 의해 반환됩니다.

---
#### **15.1.16.  Obsoleted Errors**

이러한 오류는 NFSv4.1 작업으로 인해 생성되어서는 안 됩니다. 여기에는 여러 가지 이유가 있을 수 있습니다.\(MUST NOT\)

\* 오류로 인해 제공된 기능이 SEQUENCE 작업에서 반환된 상태 비트 중 하나로 대체되었습니다.

\* 새로운 세션 구조와 관련 잠금 변경으로 인해 오류가 불필요해졌습니다.

\* NFSv4.1의 일부 오류가 재구성되어 특정 오류가 제거되었습니다.

---
##### **15.1.16.1.  NFS4ERR_BAD_SEQID (Error Code 10026)**

잠금 요청의 시퀀스 번호\(seqid\)는 다음 예상 번호도 아니고 처리된 마지막 번호도 아닙니다. NFSv4.1에서는 이러한 seqid가 무시됩니다.

---
##### **15.1.16.2.  NFS4ERR_LEASE_MOVED (Error Code 10031)**

갱신되는 임대는 새 서버로 마이그레이션된 파일 시스템과 연결됩니다. 오류는 SEQ4\_STATUS\_LEASE\_MOVED 상태 비트로 대체되었습니다\(섹션 18.46 참조\).

---
##### **15.1.16.3.  NFS4ERR_NXIO (Error Code 5)**

I/O 오류입니다. 해당 장치나 주소가 없습니다. 이 오류는 블록 및 문자 장치 액세스와 관련된 오류에 대한 것이지만 NFSv4.1은 장치 액세스 프로토콜이 아니기 때문에 이 오류는 적용되지 않습니다.

---
##### **15.1.16.4.  NFS4ERR_RESTOREFH (Error Code 10030)**

RESTOREFH 작업에 작업할 저장된 파일 핸들\(SAVEFH로 식별됨\)이 없습니다. NFSv4.1에서는 이 오류가 NFS4ERR\_NOFILEHANDLE로 대체되었습니다.

---
##### **15.1.16.5.  NFS4ERR_STALE_STATEID (Error Code 10023)**

이전 서버 인스턴스에서 생성된 stateid가 사용되었습니다. stateid를 사용하는 모든 작업은 SEQUENCE 작업보다 먼저 수행되어야 하며 이전 서버 인스턴스는 SEQUENCE를 지원하는 세션 인프라에 의해 감지되므로 NFSv4.1에서는 이 오류가 문제가 됩니다.\(MUST\)

---
### **15.2.  Operations and Their Valid Errors**

이 섹션에는 각 프로토콜 작업에 대한 유효한 오류 반환을 제공하는 표가 포함되어 있습니다. 오류 코드 NFS4\_OK\(오류 없음을 나타냄\)는 나열되지 않지만 다음 두 가지 중요한 예외를 제외하고 모든 작업에서 반환될 수 있는 것으로 이해해야 합니다.

\* 구현해서는 안 되는 작업: OPEN\_CONFIRM, RELEASE\_LOCKOWNER, RENEW, SETCLIENTID 및 SETCLIENTID\_CONFIRM.\(MUST NOT\)

\* 잘못된 작업: ILLEGAL.

```text
     +======================+========================================+
     | Operation            | Errors                                 |
     +======================+========================================+
     | ACCESS               | NFS4ERR_ACCESS, NFS4ERR_BADXDR,        |
     |                      | NFS4ERR_DEADSESSION, NFS4ERR_DELAY,    |
     |                      | NFS4ERR_FHEXPIRED, NFS4ERR_INVAL,      |
     |                      | NFS4ERR_IO, NFS4ERR_MOVED,             |
     |                      | NFS4ERR_NOFILEHANDLE,                  |
     |                      | NFS4ERR_OP_NOT_IN_SESSION,             |
     |                      | NFS4ERR_REP_TOO_BIG,                   |
     |                      | NFS4ERR_REP_TOO_BIG_TO_CACHE,          |
     |                      | NFS4ERR_REQ_TOO_BIG,                   |
     |                      | NFS4ERR_RETRY_UNCACHED_REP,            |
     |                      | NFS4ERR_SERVERFAULT, NFS4ERR_STALE,    |
     |                      | NFS4ERR_TOO_MANY_OPS                   |
     +----------------------+----------------------------------------+
     | BACKCHANNEL_CTL      | NFS4ERR_BADXDR, NFS4ERR_DEADSESSION,   |
     |                      | NFS4ERR_DELAY, NFS4ERR_INVAL,          |
     |                      | NFS4ERR_NOENT,                         |
     |                      | NFS4ERR_OP_NOT_IN_SESSION,             |
     |                      | NFS4ERR_REP_TOO_BIG,                   |
     |                      | NFS4ERR_REP_TOO_BIG_TO_CACHE,          |
     |                      | NFS4ERR_REQ_TOO_BIG,                   |
     |                      | NFS4ERR_RETRY_UNCACHED_REP,            |
     |                      | NFS4ERR_TOO_MANY_OPS                   |
     +----------------------+----------------------------------------+
     | BIND_CONN_TO_SESSION | NFS4ERR_BADSESSION, NFS4ERR_BADXDR,    |
     |                      | NFS4ERR_BAD_SESSION_DIGEST,            |
     |                      | NFS4ERR_DEADSESSION, NFS4ERR_DELAY,    |
     |                      | NFS4ERR_INVAL, NFS4ERR_NOT_ONLY_OP,    |
     |                      | NFS4ERR_REP_TOO_BIG,                   |
     |                      | NFS4ERR_REP_TOO_BIG_TO_CACHE,          |
     |                      | NFS4ERR_REQ_TOO_BIG,                   |
     |                      | NFS4ERR_RETRY_UNCACHED_REP,            |
     |                      | NFS4ERR_SERVERFAULT,                   |
     |                      | NFS4ERR_TOO_MANY_OPS                   |
     +----------------------+----------------------------------------+
     | CLOSE                | NFS4ERR_ADMIN_REVOKED, NFS4ERR_BADXDR, |
     |                      | NFS4ERR_BAD_STATEID,                   |
     |                      | NFS4ERR_DEADSESSION, NFS4ERR_DELAY,    |
     |                      | NFS4ERR_EXPIRED, NFS4ERR_FHEXPIRED,    |
     |                      | NFS4ERR_LOCKS_HELD, NFS4ERR_MOVED,     |
     |                      | NFS4ERR_NOFILEHANDLE,                  |
     |                      | NFS4ERR_OLD_STATEID,                   |
     |                      | NFS4ERR_OP_NOT_IN_SESSION,             |
     |                      | NFS4ERR_REP_TOO_BIG,                   |
     |                      | NFS4ERR_REP_TOO_BIG_TO_CACHE,          |
     |                      | NFS4ERR_REQ_TOO_BIG,                   |
     |                      | NFS4ERR_RETRY_UNCACHED_REP,            |
     |                      | NFS4ERR_SERVERFAULT, NFS4ERR_STALE,    |
     |                      | NFS4ERR_TOO_MANY_OPS,                  |
     |                      | NFS4ERR_WRONG_CRED                     |
     +----------------------+----------------------------------------+
     | COMMIT               | NFS4ERR_ACCESS, NFS4ERR_BADXDR,        |
     |                      | NFS4ERR_DEADSESSION, NFS4ERR_DELAY,    |
     |                      | NFS4ERR_FHEXPIRED, NFS4ERR_IO,         |
     |                      | NFS4ERR_ISDIR, NFS4ERR_MOVED,          |
     |                      | NFS4ERR_NOFILEHANDLE,                  |
     |                      | NFS4ERR_OP_NOT_IN_SESSION,             |
     |                      | NFS4ERR_REP_TOO_BIG,                   |
     |                      | NFS4ERR_REP_TOO_BIG_TO_CACHE,          |
     |                      | NFS4ERR_REQ_TOO_BIG,                   |
     |                      | NFS4ERR_RETRY_UNCACHED_REP,            |
     |                      | NFS4ERR_SERVERFAULT, NFS4ERR_STALE,    |
     |                      | NFS4ERR_SYMLINK, NFS4ERR_TOO_MANY_OPS, |
     |                      | NFS4ERR_WRONG_TYPE                     |
     +----------------------+----------------------------------------+
     | CREATE               | NFS4ERR_ACCESS, NFS4ERR_ATTRNOTSUPP,   |
     |                      | NFS4ERR_BADCHAR, NFS4ERR_BADNAME,      |
     |                      | NFS4ERR_BADOWNER, NFS4ERR_BADTYPE,     |
     |                      | NFS4ERR_BADXDR, NFS4ERR_DEADSESSION,   |
     |                      | NFS4ERR_DELAY, NFS4ERR_DQUOT,          |
     |                      | NFS4ERR_EXIST, NFS4ERR_FHEXPIRED,      |
     |                      | NFS4ERR_INVAL, NFS4ERR_IO,             |
     |                      | NFS4ERR_MLINK, NFS4ERR_MOVED,          |
     |                      | NFS4ERR_NAMETOOLONG,                   |
     |                      | NFS4ERR_NOFILEHANDLE, NFS4ERR_NOSPC,   |
     |                      | NFS4ERR_NOTDIR,                        |
     |                      | NFS4ERR_OP_NOT_IN_SESSION,             |
     |                      | NFS4ERR_PERM, NFS4ERR_REP_TOO_BIG,     |
     |                      | NFS4ERR_REP_TOO_BIG_TO_CACHE,          |
     |                      | NFS4ERR_REQ_TOO_BIG,                   |
     |                      | NFS4ERR_RETRY_UNCACHED_REP,            |
     |                      | NFS4ERR_ROFS, NFS4ERR_SERVERFAULT,     |
     |                      | NFS4ERR_STALE, NFS4ERR_TOO_MANY_OPS,   |
     |                      | NFS4ERR_UNSAFE_COMPOUND                |
     +----------------------+----------------------------------------+
     | CREATE_SESSION       | NFS4ERR_BADXDR, NFS4ERR_CLID_INUSE,    |
     |                      | NFS4ERR_DEADSESSION, NFS4ERR_DELAY,    |
     |                      | NFS4ERR_INVAL, NFS4ERR_NOENT,          |
     |                      | NFS4ERR_NOT_ONLY_OP, NFS4ERR_NOSPC,    |
     |                      | NFS4ERR_REP_TOO_BIG,                   |
     |                      | NFS4ERR_REP_TOO_BIG_TO_CACHE,          |
     |                      | NFS4ERR_REQ_TOO_BIG,                   |
     |                      | NFS4ERR_RETRY_UNCACHED_REP,            |
     |                      | NFS4ERR_SEQ_MISORDERED,                |
     |                      | NFS4ERR_SERVERFAULT,                   |
     |                      | NFS4ERR_STALE_CLIENTID,                |
     |                      | NFS4ERR_TOOSMALL,                      |
     |                      | NFS4ERR_TOO_MANY_OPS,                  |
     |                      | NFS4ERR_WRONG_CRED                     |
     +----------------------+----------------------------------------+
     | DELEGPURGE           | NFS4ERR_BADXDR, NFS4ERR_DEADSESSION,   |
     |                      | NFS4ERR_DELAY, NFS4ERR_NOTSUPP,        |
     |                      | NFS4ERR_OP_NOT_IN_SESSION,             |
     |                      | NFS4ERR_REP_TOO_BIG,                   |
     |                      | NFS4ERR_REP_TOO_BIG_TO_CACHE,          |
     |                      | NFS4ERR_REQ_TOO_BIG,                   |
     |                      | NFS4ERR_RETRY_UNCACHED_REP,            |
     |                      | NFS4ERR_SERVERFAULT,                   |
     |                      | NFS4ERR_TOO_MANY_OPS,                  |
     |                      | NFS4ERR_WRONG_CRED                     |
     +----------------------+----------------------------------------+
     | DELEGRETURN          | NFS4ERR_ADMIN_REVOKED, NFS4ERR_BADXDR, |
     |                      | NFS4ERR_BAD_STATEID,                   |
     |                      | NFS4ERR_DEADSESSION, NFS4ERR_DELAY,    |
     |                      | NFS4ERR_DELEG_REVOKED,                 |
     |                      | NFS4ERR_EXPIRED, NFS4ERR_FHEXPIRED,    |
     |                      | NFS4ERR_INVAL, NFS4ERR_MOVED,          |
     |                      | NFS4ERR_NOFILEHANDLE, NFS4ERR_NOTSUPP, |
     |                      | NFS4ERR_OLD_STATEID,                   |
     |                      | NFS4ERR_OP_NOT_IN_SESSION,             |
     |                      | NFS4ERR_REP_TOO_BIG,                   |
     |                      | NFS4ERR_REP_TOO_BIG_TO_CACHE,          |
     |                      | NFS4ERR_REQ_TOO_BIG,                   |
     |                      | NFS4ERR_RETRY_UNCACHED_REP,            |
     |                      | NFS4ERR_SERVERFAULT, NFS4ERR_STALE,    |
     |                      | NFS4ERR_TOO_MANY_OPS,                  |
     |                      | NFS4ERR_WRONG_CRED                     |
     +----------------------+----------------------------------------+
     | DESTROY_CLIENTID     | NFS4ERR_BADXDR, NFS4ERR_CLIENTID_BUSY, |
     |                      | NFS4ERR_DEADSESSION, NFS4ERR_DELAY,    |
     |                      | NFS4ERR_NOT_ONLY_OP,                   |
     |                      | NFS4ERR_REP_TOO_BIG,                   |
     |                      | NFS4ERR_REP_TOO_BIG_TO_CACHE,          |
     |                      | NFS4ERR_REQ_TOO_BIG,                   |
     |                      | NFS4ERR_RETRY_UNCACHED_REP,            |
     |                      | NFS4ERR_SERVERFAULT,                   |
     |                      | NFS4ERR_STALE_CLIENTID,                |
     |                      | NFS4ERR_TOO_MANY_OPS,                  |
     |                      | NFS4ERR_WRONG_CRED                     |
     +----------------------+----------------------------------------+
     | DESTROY_SESSION      | NFS4ERR_BACK_CHAN_BUSY,                |
     |                      | NFS4ERR_BADSESSION, NFS4ERR_BADXDR,    |
     |                      | NFS4ERR_CB_PATH_DOWN,                  |
     |                      | NFS4ERR_CONN_NOT_BOUND_TO_SESSION,     |
     |                      | NFS4ERR_DEADSESSION, NFS4ERR_DELAY,    |
     |                      | NFS4ERR_NOT_ONLY_OP,                   |
     |                      | NFS4ERR_REP_TOO_BIG,                   |
     |                      | NFS4ERR_REP_TOO_BIG_TO_CACHE,          |
     |                      | NFS4ERR_REQ_TOO_BIG,                   |
     |                      | NFS4ERR_RETRY_UNCACHED_REP,            |
     |                      | NFS4ERR_SERVERFAULT,                   |
     |                      | NFS4ERR_STALE_CLIENTID,                |
     |                      | NFS4ERR_TOO_MANY_OPS,                  |
     |                      | NFS4ERR_WRONG_CRED                     |
     +----------------------+----------------------------------------+
     | EXCHANGE_ID          | NFS4ERR_BADCHAR, NFS4ERR_BADXDR,       |
     |                      | NFS4ERR_CLID_INUSE,                    |
     |                      | NFS4ERR_DEADSESSION, NFS4ERR_DELAY,    |
     |                      | NFS4ERR_ENCR_ALG_UNSUPP,               |
     |                      | NFS4ERR_HASH_ALG_UNSUPP,               |
     |                      | NFS4ERR_INVAL, NFS4ERR_NOENT,          |
     |                      | NFS4ERR_NOT_ONLY_OP, NFS4ERR_NOT_SAME, |
     |                      | NFS4ERR_REP_TOO_BIG,                   |
     |                      | NFS4ERR_REP_TOO_BIG_TO_CACHE,          |
     |                      | NFS4ERR_REQ_TOO_BIG,                   |
     |                      | NFS4ERR_RETRY_UNCACHED_REP,            |
     |                      | NFS4ERR_SERVERFAULT,                   |
     |                      | NFS4ERR_TOO_MANY_OPS                   |
     +----------------------+----------------------------------------+
     | FREE_STATEID         | NFS4ERR_BADXDR, NFS4ERR_BAD_STATEID,   |
     |                      | NFS4ERR_DEADSESSION, NFS4ERR_DELAY,    |
     |                      | NFS4ERR_LOCKS_HELD,                    |
     |                      | NFS4ERR_OLD_STATEID,                   |
     |                      | NFS4ERR_OP_NOT_IN_SESSION,             |
     |                      | NFS4ERR_REP_TOO_BIG,                   |
     |                      | NFS4ERR_REP_TOO_BIG_TO_CACHE,          |
     |                      | NFS4ERR_REQ_TOO_BIG,                   |
     |                      | NFS4ERR_RETRY_UNCACHED_REP,            |
     |                      | NFS4ERR_SERVERFAULT,                   |
     |                      | NFS4ERR_TOO_MANY_OPS,                  |
     |                      | NFS4ERR_WRONG_CRED                     |
     +----------------------+----------------------------------------+
     | GET_DIR_DELEGATION   | NFS4ERR_ACCESS, NFS4ERR_BADXDR,        |
     |                      | NFS4ERR_DEADSESSION, NFS4ERR_DELAY,    |
     |                      | NFS4ERR_DIRDELEG_UNAVAIL,              |
     |                      | NFS4ERR_FHEXPIRED, NFS4ERR_GRACE,      |
     |                      | NFS4ERR_INVAL, NFS4ERR_IO,             |
     |                      | NFS4ERR_MOVED, NFS4ERR_NOFILEHANDLE,   |
     |                      | NFS4ERR_NOTDIR, NFS4ERR_NOTSUPP,       |
     |                      | NFS4ERR_OP_NOT_IN_SESSION,             |
     |                      | NFS4ERR_REP_TOO_BIG,                   |
     |                      | NFS4ERR_REP_TOO_BIG_TO_CACHE,          |
     |                      | NFS4ERR_REQ_TOO_BIG,                   |
     |                      | NFS4ERR_RETRY_UNCACHED_REP,            |
     |                      | NFS4ERR_SERVERFAULT, NFS4ERR_STALE,    |
     |                      | NFS4ERR_TOO_MANY_OPS                   |
     +----------------------+----------------------------------------+
     | GETATTR              | NFS4ERR_ACCESS, NFS4ERR_BADXDR,        |
     |                      | NFS4ERR_DEADSESSION, NFS4ERR_DELAY,    |
     |                      | NFS4ERR_FHEXPIRED, NFS4ERR_GRACE,      |
     |                      | NFS4ERR_INVAL, NFS4ERR_IO,             |
     |                      | NFS4ERR_MOVED, NFS4ERR_NOFILEHANDLE,   |
     |                      | NFS4ERR_OP_NOT_IN_SESSION,             |
     |                      | NFS4ERR_REP_TOO_BIG,                   |
     |                      | NFS4ERR_REP_TOO_BIG_TO_CACHE,          |
     |                      | NFS4ERR_REQ_TOO_BIG,                   |
     |                      | NFS4ERR_RETRY_UNCACHED_REP,            |
     |                      | NFS4ERR_SERVERFAULT, NFS4ERR_STALE,    |
     |                      | NFS4ERR_TOO_MANY_OPS,                  |
     |                      | NFS4ERR_WRONG_TYPE                     |
     +----------------------+----------------------------------------+
     | GETDEVICEINFO        | NFS4ERR_BADXDR, NFS4ERR_DEADSESSION,   |
     |                      | NFS4ERR_DELAY, NFS4ERR_INVAL,          |
     |                      | NFS4ERR_NOENT, NFS4ERR_NOTSUPP,        |
     |                      | NFS4ERR_OP_NOT_IN_SESSION,             |
     |                      | NFS4ERR_REP_TOO_BIG,                   |
     |                      | NFS4ERR_REP_TOO_BIG_TO_CACHE,          |
     |                      | NFS4ERR_REQ_TOO_BIG,                   |
     |                      | NFS4ERR_RETRY_UNCACHED_REP,            |
     |                      | NFS4ERR_SERVERFAULT, NFS4ERR_TOOSMALL, |
     |                      | NFS4ERR_TOO_MANY_OPS,                  |
     |                      | NFS4ERR_UNKNOWN_LAYOUTTYPE             |
     +----------------------+----------------------------------------+
     | GETDEVICELIST        | NFS4ERR_BADXDR, NFS4ERR_BAD_COOKIE,    |
     |                      | NFS4ERR_DEADSESSION, NFS4ERR_DELAY,    |
     |                      | NFS4ERR_FHEXPIRED, NFS4ERR_INVAL,      |
     |                      | NFS4ERR_IO, NFS4ERR_NOFILEHANDLE,      |
     |                      | NFS4ERR_NOTSUPP, NFS4ERR_NOT_SAME,     |
     |                      | NFS4ERR_OP_NOT_IN_SESSION,             |
     |                      | NFS4ERR_REP_TOO_BIG,                   |
     |                      | NFS4ERR_REP_TOO_BIG_TO_CACHE,          |
     |                      | NFS4ERR_REQ_TOO_BIG,                   |
     |                      | NFS4ERR_RETRY_UNCACHED_REP,            |
     |                      | NFS4ERR_SERVERFAULT,                   |
     |                      | NFS4ERR_TOO_MANY_OPS,                  |
     |                      | NFS4ERR_UNKNOWN_LAYOUTTYPE             |
     +----------------------+----------------------------------------+
     | GETFH                | NFS4ERR_FHEXPIRED, NFS4ERR_MOVED,      |
     |                      | NFS4ERR_NOFILEHANDLE,                  |
     |                      | NFS4ERR_OP_NOT_IN_SESSION,             |
     |                      | NFS4ERR_STALE                          |
     +----------------------+----------------------------------------+
     | ILLEGAL              | NFS4ERR_BADXDR, NFS4ERR_OP_ILLEGAL     |
     +----------------------+----------------------------------------+
     | LAYOUTCOMMIT         | NFS4ERR_ACCESS, NFS4ERR_ADMIN_REVOKED, |
     |                      | NFS4ERR_ATTRNOTSUPP,                   |
     |                      | NFS4ERR_BADIOMODE, NFS4ERR_BADLAYOUT,  |
     |                      | NFS4ERR_BADXDR, NFS4ERR_DEADSESSION,   |
     |                      | NFS4ERR_DELAY, NFS4ERR_DELEG_REVOKED,  |
     |                      | NFS4ERR_EXPIRED, NFS4ERR_FBIG,         |
     |                      | NFS4ERR_FHEXPIRED, NFS4ERR_GRACE,      |
     |                      | NFS4ERR_INVAL, NFS4ERR_IO,             |
     |                      | NFS4ERR_ISDIR NFS4ERR_MOVED,           |
     |                      | NFS4ERR_NOFILEHANDLE, NFS4ERR_NOTSUPP, |
     |                      | NFS4ERR_NO_GRACE,                      |
     |                      | NFS4ERR_OP_NOT_IN_SESSION,             |
     |                      | NFS4ERR_RECLAIM_BAD,                   |
     |                      | NFS4ERR_RECLAIM_CONFLICT,              |
     |                      | NFS4ERR_REP_TOO_BIG,                   |
     |                      | NFS4ERR_REP_TOO_BIG_TO_CACHE,          |
     |                      | NFS4ERR_REQ_TOO_BIG,                   |
     |                      | NFS4ERR_RETRY_UNCACHED_REP,            |
     |                      | NFS4ERR_SERVERFAULT, NFS4ERR_STALE,    |
     |                      | NFS4ERR_SYMLINK, NFS4ERR_TOO_MANY_OPS, |
     |                      | NFS4ERR_UNKNOWN_LAYOUTTYPE,            |
     |                      | NFS4ERR_WRONG_CRED                     |
     +----------------------+----------------------------------------+
     | LAYOUTGET            | NFS4ERR_ACCESS, NFS4ERR_ADMIN_REVOKED, |
     |                      | NFS4ERR_BADIOMODE, NFS4ERR_BADLAYOUT,  |
     |                      | NFS4ERR_BADXDR, NFS4ERR_BAD_STATEID,   |
     |                      | NFS4ERR_DEADSESSION, NFS4ERR_DELAY,    |
     |                      | NFS4ERR_DELEG_REVOKED, NFS4ERR_DQUOT,  |
     |                      | NFS4ERR_FHEXPIRED, NFS4ERR_GRACE,      |
     |                      | NFS4ERR_INVAL, NFS4ERR_IO,             |
     |                      | NFS4ERR_LAYOUTTRYLATER,                |
     |                      | NFS4ERR_LAYOUTUNAVAILABLE,             |
     |                      | NFS4ERR_LOCKED, NFS4ERR_MOVED,         |
     |                      | NFS4ERR_NOFILEHANDLE, NFS4ERR_NOSPC,   |
     |                      | NFS4ERR_NOTSUPP, NFS4ERR_OLD_STATEID,  |
     |                      | NFS4ERR_OPENMODE,                      |
     |                      | NFS4ERR_OP_NOT_IN_SESSION,             |
     |                      | NFS4ERR_RECALLCONFLICT,                |
     |                      | NFS4ERR_REP_TOO_BIG,                   |
     |                      | NFS4ERR_REP_TOO_BIG_TO_CACHE,          |
     |                      | NFS4ERR_REQ_TOO_BIG,                   |
     |                      | NFS4ERR_RETRY_UNCACHED_REP,            |
     |                      | NFS4ERR_SERVERFAULT, NFS4ERR_STALE,    |
     |                      | NFS4ERR_TOOSMALL,                      |
     |                      | NFS4ERR_TOO_MANY_OPS,                  |
     |                      | NFS4ERR_UNKNOWN_LAYOUTTYPE,            |
     |                      | NFS4ERR_WRONG_TYPE                     |
     +----------------------+----------------------------------------+
     | LAYOUTRETURN         | NFS4ERR_ADMIN_REVOKED, NFS4ERR_BADXDR, |
     |                      | NFS4ERR_BAD_STATEID,                   |
     |                      | NFS4ERR_DEADSESSION, NFS4ERR_DELAY,    |
     |                      | NFS4ERR_DELEG_REVOKED,                 |
     |                      | NFS4ERR_EXPIRED, NFS4ERR_FHEXPIRED,    |
     |                      | NFS4ERR_GRACE, NFS4ERR_INVAL,          |
     |                      | NFS4ERR_ISDIR, NFS4ERR_MOVED,          |
     |                      | NFS4ERR_NOFILEHANDLE, NFS4ERR_NOTSUPP, |
     |                      | NFS4ERR_NO_GRACE, NFS4ERR_OLD_STATEID, |
     |                      | NFS4ERR_OP_NOT_IN_SESSION,             |
     |                      | NFS4ERR_REP_TOO_BIG,                   |
     |                      | NFS4ERR_REP_TOO_BIG_TO_CACHE,          |
     |                      | NFS4ERR_REQ_TOO_BIG,                   |
     |                      | NFS4ERR_RETRY_UNCACHED_REP,            |
     |                      | NFS4ERR_SERVERFAULT, NFS4ERR_STALE,    |
     |                      | NFS4ERR_TOO_MANY_OPS,                  |
     |                      | NFS4ERR_UNKNOWN_LAYOUTTYPE,            |
     |                      | NFS4ERR_WRONG_CRED, NFS4ERR_WRONG_TYPE |
     +----------------------+----------------------------------------+
     | LINK                 | NFS4ERR_ACCESS, NFS4ERR_BADCHAR,       |
     |                      | NFS4ERR_BADNAME, NFS4ERR_BADXDR,       |
     |                      | NFS4ERR_DEADSESSION, NFS4ERR_DELAY,    |
     |                      | NFS4ERR_DQUOT, NFS4ERR_EXIST,          |
     |                      | NFS4ERR_FHEXPIRED, NFS4ERR_FILE_OPEN,  |
     |                      | NFS4ERR_GRACE, NFS4ERR_INVAL,          |
     |                      | NFS4ERR_ISDIR, NFS4ERR_IO,             |
     |                      | NFS4ERR_MLINK, NFS4ERR_MOVED,          |
     |                      | NFS4ERR_NAMETOOLONG,                   |
     |                      | NFS4ERR_NOFILEHANDLE, NFS4ERR_NOSPC,   |
     |                      | NFS4ERR_NOTDIR, NFS4ERR_NOTSUPP,       |
     |                      | NFS4ERR_OP_NOT_IN_SESSION,             |
     |                      | NFS4ERR_REP_TOO_BIG,                   |
     |                      | NFS4ERR_REP_TOO_BIG_TO_CACHE,          |
     |                      | NFS4ERR_REQ_TOO_BIG,                   |
     |                      | NFS4ERR_RETRY_UNCACHED_REP,            |
     |                      | NFS4ERR_ROFS, NFS4ERR_SERVERFAULT,     |
     |                      | NFS4ERR_STALE, NFS4ERR_SYMLINK,        |
     |                      | NFS4ERR_TOO_MANY_OPS,                  |
     |                      | NFS4ERR_WRONGSEC, NFS4ERR_WRONG_TYPE,  |
     |                      | NFS4ERR_XDEV                           |
     +----------------------+----------------------------------------+
     | LOCK                 | NFS4ERR_ACCESS, NFS4ERR_ADMIN_REVOKED, |
     |                      | NFS4ERR_BADXDR, NFS4ERR_BAD_RANGE,     |
     |                      | NFS4ERR_BAD_STATEID, NFS4ERR_DEADLOCK, |
     |                      | NFS4ERR_DEADSESSION, NFS4ERR_DELAY,    |
     |                      | NFS4ERR_DENIED, NFS4ERR_EXPIRED,       |
     |                      | NFS4ERR_FHEXPIRED, NFS4ERR_GRACE,      |
     |                      | NFS4ERR_INVAL, NFS4ERR_ISDIR,          |
     |                      | NFS4ERR_LOCK_NOTSUPP,                  |
     |                      | NFS4ERR_LOCK_RANGE, NFS4ERR_MOVED,     |
     |                      | NFS4ERR_NOFILEHANDLE,                  |
     |                      | NFS4ERR_NO_GRACE, NFS4ERR_OLD_STATEID, |
     |                      | NFS4ERR_OPENMODE,                      |
     |                      | NFS4ERR_OP_NOT_IN_SESSION,             |
     |                      | NFS4ERR_RECLAIM_BAD,                   |
     |                      | NFS4ERR_RECLAIM_CONFLICT,              |
     |                      | NFS4ERR_REP_TOO_BIG,                   |
     |                      | NFS4ERR_REP_TOO_BIG_TO_CACHE,          |
     |                      | NFS4ERR_REQ_TOO_BIG,                   |
     |                      | NFS4ERR_RETRY_UNCACHED_REP,            |
     |                      | NFS4ERR_ROFS, NFS4ERR_SERVERFAULT,     |
     |                      | NFS4ERR_STALE, NFS4ERR_SYMLINK,        |
     |                      | NFS4ERR_TOO_MANY_OPS,                  |
     |                      | NFS4ERR_WRONG_CRED, NFS4ERR_WRONG_TYPE |
     +----------------------+----------------------------------------+
     | LOCKT                | NFS4ERR_ACCESS, NFS4ERR_BADXDR,        |
     |                      | NFS4ERR_BAD_RANGE,                     |
     |                      | NFS4ERR_DEADSESSION, NFS4ERR_DELAY,    |
     |                      | NFS4ERR_DENIED, NFS4ERR_FHEXPIRED,     |
     |                      | NFS4ERR_GRACE, NFS4ERR_INVAL,          |
     |                      | NFS4ERR_ISDIR, NFS4ERR_LOCK_RANGE,     |
     |                      | NFS4ERR_MOVED, NFS4ERR_NOFILEHANDLE,   |
     |                      | NFS4ERR_OP_NOT_IN_SESSION,             |
     |                      | NFS4ERR_REP_TOO_BIG,                   |
     |                      | NFS4ERR_REP_TOO_BIG_TO_CACHE,          |
     |                      | NFS4ERR_REQ_TOO_BIG,                   |
     |                      | NFS4ERR_RETRY_UNCACHED_REP,            |
     |                      | NFS4ERR_ROFS, NFS4ERR_STALE,           |
     |                      | NFS4ERR_SYMLINK, NFS4ERR_TOO_MANY_OPS, |
     |                      | NFS4ERR_WRONG_CRED, NFS4ERR_WRONG_TYPE |
     +----------------------+----------------------------------------+
     | LOCKU                | NFS4ERR_ACCESS, NFS4ERR_ADMIN_REVOKED, |
     |                      | NFS4ERR_BADXDR, NFS4ERR_BAD_RANGE,     |
     |                      | NFS4ERR_BAD_STATEID,                   |
     |                      | NFS4ERR_DEADSESSION, NFS4ERR_DELAY,    |
     |                      | NFS4ERR_EXPIRED, NFS4ERR_FHEXPIRED,    |
     |                      | NFS4ERR_INVAL, NFS4ERR_LOCK_RANGE,     |
     |                      | NFS4ERR_MOVED, NFS4ERR_NOFILEHANDLE,   |
     |                      | NFS4ERR_OLD_STATEID,                   |
     |                      | NFS4ERR_OP_NOT_IN_SESSION,             |
     |                      | NFS4ERR_REP_TOO_BIG,                   |
     |                      | NFS4ERR_REP_TOO_BIG_TO_CACHE,          |
     |                      | NFS4ERR_REQ_TOO_BIG,                   |
     |                      | NFS4ERR_RETRY_UNCACHED_REP,            |
     |                      | NFS4ERR_SERVERFAULT, NFS4ERR_STALE,    |
     |                      | NFS4ERR_TOO_MANY_OPS,                  |
     |                      | NFS4ERR_WRONG_CRED                     |
     +----------------------+----------------------------------------+
     | LOOKUP               | NFS4ERR_ACCESS, NFS4ERR_BADCHAR,       |
     |                      | NFS4ERR_BADNAME, NFS4ERR_BADXDR,       |
     |                      | NFS4ERR_DEADSESSION, NFS4ERR_DELAY,    |
     |                      | NFS4ERR_FHEXPIRED, NFS4ERR_INVAL,      |
     |                      | NFS4ERR_IO, NFS4ERR_MOVED,             |
     |                      | NFS4ERR_NAMETOOLONG, NFS4ERR_NOENT,    |
     |                      | NFS4ERR_NOFILEHANDLE, NFS4ERR_NOTDIR,  |
     |                      | NFS4ERR_OP_NOT_IN_SESSION,             |
     |                      | NFS4ERR_REP_TOO_BIG,                   |
     |                      | NFS4ERR_REP_TOO_BIG_TO_CACHE,          |
     |                      | NFS4ERR_REQ_TOO_BIG,                   |
     |                      | NFS4ERR_RETRY_UNCACHED_REP,            |
     |                      | NFS4ERR_SERVERFAULT, NFS4ERR_STALE,    |
     |                      | NFS4ERR_SYMLINK, NFS4ERR_TOO_MANY_OPS, |
     |                      | NFS4ERR_WRONGSEC                       |
     +----------------------+----------------------------------------+
     | LOOKUPP              | NFS4ERR_ACCESS, NFS4ERR_DEADSESSION,   |
     |                      | NFS4ERR_DELAY, NFS4ERR_FHEXPIRED,      |
     |                      | NFS4ERR_IO, NFS4ERR_MOVED,             |
     |                      | NFS4ERR_NOENT, NFS4ERR_NOFILEHANDLE,   |
     |                      | NFS4ERR_NOTDIR,                        |
     |                      | NFS4ERR_OP_NOT_IN_SESSION,             |
     |                      | NFS4ERR_REP_TOO_BIG,                   |
     |                      | NFS4ERR_REP_TOO_BIG_TO_CACHE,          |
     |                      | NFS4ERR_REQ_TOO_BIG,                   |
     |                      | NFS4ERR_RETRY_UNCACHED_REP,            |
     |                      | NFS4ERR_SERVERFAULT, NFS4ERR_STALE,    |
     |                      | NFS4ERR_SYMLINK, NFS4ERR_TOO_MANY_OPS, |
     |                      | NFS4ERR_WRONGSEC                       |
     +----------------------+----------------------------------------+
     | NVERIFY              | NFS4ERR_ACCESS, NFS4ERR_ATTRNOTSUPP,   |
     |                      | NFS4ERR_BADCHAR, NFS4ERR_BADXDR,       |
     |                      | NFS4ERR_DEADSESSION, NFS4ERR_DELAY,    |
     |                      | NFS4ERR_FHEXPIRED, NFS4ERR_GRACE,      |
     |                      | NFS4ERR_INVAL, NFS4ERR_IO,             |
     |                      | NFS4ERR_MOVED, NFS4ERR_NOFILEHANDLE,   |
     |                      | NFS4ERR_OP_NOT_IN_SESSION,             |
     |                      | NFS4ERR_REP_TOO_BIG,                   |
     |                      | NFS4ERR_REP_TOO_BIG_TO_CACHE,          |
     |                      | NFS4ERR_REQ_TOO_BIG,                   |
     |                      | NFS4ERR_RETRY_UNCACHED_REP,            |
     |                      | NFS4ERR_SAME, NFS4ERR_SERVERFAULT,     |
     |                      | NFS4ERR_STALE, NFS4ERR_TOO_MANY_OPS,   |
     |                      | NFS4ERR_UNKNOWN_LAYOUTTYPE,            |
     |                      | NFS4ERR_WRONG_TYPE                     |
     +----------------------+----------------------------------------+
     | OPEN                 | NFS4ERR_ACCESS, NFS4ERR_ADMIN_REVOKED, |
     |                      | NFS4ERR_ATTRNOTSUPP, NFS4ERR_BADCHAR,  |
     |                      | NFS4ERR_BADNAME, NFS4ERR_BADOWNER,     |
     |                      | NFS4ERR_BADXDR, NFS4ERR_BAD_STATEID,   |
     |                      | NFS4ERR_DEADSESSION, NFS4ERR_DELAY,    |
     |                      | NFS4ERR_DELEG_ALREADY_WANTED,          |
     |                      | NFS4ERR_DELEG_REVOKED, NFS4ERR_DQUOT,  |
     |                      | NFS4ERR_EXIST, NFS4ERR_EXPIRED,        |
     |                      | NFS4ERR_FBIG, NFS4ERR_FHEXPIRED,       |
     |                      | NFS4ERR_GRACE, NFS4ERR_INVAL,          |
     |                      | NFS4ERR_ISDIR, NFS4ERR_IO,             |
     |                      | NFS4ERR_MOVED, NFS4ERR_NAMETOOLONG,    |
     |                      | NFS4ERR_NOENT, NFS4ERR_NOFILEHANDLE,   |
     |                      | NFS4ERR_NOSPC, NFS4ERR_NOTDIR,         |
     |                      | NFS4ERR_NO_GRACE, NFS4ERR_OLD_STATEID, |
     |                      | NFS4ERR_OP_NOT_IN_SESSION,             |
     |                      | NFS4ERR_PERM, NFS4ERR_RECLAIM_BAD,     |
     |                      | NFS4ERR_RECLAIM_CONFLICT,              |
     |                      | NFS4ERR_REP_TOO_BIG,                   |
     |                      | NFS4ERR_REP_TOO_BIG_TO_CACHE,          |
     |                      | NFS4ERR_REQ_TOO_BIG,                   |
     |                      | NFS4ERR_RETRY_UNCACHED_REP,            |
     |                      | NFS4ERR_ROFS, NFS4ERR_SERVERFAULT,     |
     |                      | NFS4ERR_SHARE_DENIED, NFS4ERR_STALE,   |
     |                      | NFS4ERR_SYMLINK, NFS4ERR_TOO_MANY_OPS, |
     |                      | NFS4ERR_UNSAFE_COMPOUND,               |
     |                      | NFS4ERR_WRONGSEC, NFS4ERR_WRONG_TYPE   |
     +----------------------+----------------------------------------+
     | OPEN_CONFIRM         | NFS4ERR_NOTSUPP                        |
     +----------------------+----------------------------------------+
     | OPEN_DOWNGRADE       | NFS4ERR_ADMIN_REVOKED, NFS4ERR_BADXDR, |
     |                      | NFS4ERR_BAD_STATEID,                   |
     |                      | NFS4ERR_DEADSESSION, NFS4ERR_DELAY,    |
     |                      | NFS4ERR_EXPIRED, NFS4ERR_FHEXPIRED,    |
     |                      | NFS4ERR_INVAL, NFS4ERR_MOVED,          |
     |                      | NFS4ERR_NOFILEHANDLE,                  |
     |                      | NFS4ERR_OLD_STATEID,                   |
     |                      | NFS4ERR_OP_NOT_IN_SESSION,             |
     |                      | NFS4ERR_REP_TOO_BIG,                   |
     |                      | NFS4ERR_REP_TOO_BIG_TO_CACHE,          |
     |                      | NFS4ERR_REQ_TOO_BIG,                   |
     |                      | NFS4ERR_RETRY_UNCACHED_REP,            |
     |                      | NFS4ERR_ROFS, NFS4ERR_SERVERFAULT,     |
     |                      | NFS4ERR_STALE, NFS4ERR_TOO_MANY_OPS,   |
     |                      | NFS4ERR_WRONG_CRED                     |
     +----------------------+----------------------------------------+
     | OPENATTR             | NFS4ERR_ACCESS, NFS4ERR_BADXDR,        |
     |                      | NFS4ERR_DEADSESSION, NFS4ERR_DELAY,    |
     |                      | NFS4ERR_DQUOT, NFS4ERR_FHEXPIRED,      |
     |                      | NFS4ERR_IO, NFS4ERR_MOVED,             |
     |                      | NFS4ERR_NOENT, NFS4ERR_NOFILEHANDLE,   |
     |                      | NFS4ERR_NOSPC, NFS4ERR_NOTSUPP,        |
     |                      | NFS4ERR_OP_NOT_IN_SESSION,             |
     |                      | NFS4ERR_REP_TOO_BIG,                   |
     |                      | NFS4ERR_REP_TOO_BIG_TO_CACHE,          |
     |                      | NFS4ERR_REQ_TOO_BIG,                   |
     |                      | NFS4ERR_RETRY_UNCACHED_REP,            |
     |                      | NFS4ERR_ROFS, NFS4ERR_SERVERFAULT,     |
     |                      | NFS4ERR_STALE, NFS4ERR_TOO_MANY_OPS,   |
     |                      | NFS4ERR_UNSAFE_COMPOUND,               |
     |                      | NFS4ERR_WRONG_TYPE                     |
     +----------------------+----------------------------------------+
     | PUTFH                | NFS4ERR_BADHANDLE, NFS4ERR_BADXDR,     |
     |                      | NFS4ERR_DEADSESSION, NFS4ERR_DELAY,    |
     |                      | NFS4ERR_MOVED,                         |
     |                      | NFS4ERR_OP_NOT_IN_SESSION,             |
     |                      | NFS4ERR_REP_TOO_BIG,                   |
     |                      | NFS4ERR_REP_TOO_BIG_TO_CACHE,          |
     |                      | NFS4ERR_REQ_TOO_BIG,                   |
     |                      | NFS4ERR_RETRY_UNCACHED_REP,            |
     |                      | NFS4ERR_SERVERFAULT, NFS4ERR_STALE,    |
     |                      | NFS4ERR_TOO_MANY_OPS, NFS4ERR_WRONGSEC |
     +----------------------+----------------------------------------+
     | PUTPUBFH             | NFS4ERR_DEADSESSION, NFS4ERR_DELAY,    |
     |                      | NFS4ERR_OP_NOT_IN_SESSION,             |
     |                      | NFS4ERR_REP_TOO_BIG,                   |
     |                      | NFS4ERR_REP_TOO_BIG_TO_CACHE,          |
     |                      | NFS4ERR_REQ_TOO_BIG,                   |
     |                      | NFS4ERR_RETRY_UNCACHED_REP,            |
     |                      | NFS4ERR_SERVERFAULT,                   |
     |                      | NFS4ERR_TOO_MANY_OPS, NFS4ERR_WRONGSEC |
     +----------------------+----------------------------------------+
     | PUTROOTFH            | NFS4ERR_DEADSESSION, NFS4ERR_DELAY,    |
     |                      | NFS4ERR_OP_NOT_IN_SESSION,             |
     |                      | NFS4ERR_REP_TOO_BIG,                   |
     |                      | NFS4ERR_REP_TOO_BIG_TO_CACHE,          |
     |                      | NFS4ERR_REQ_TOO_BIG,                   |
     |                      | NFS4ERR_RETRY_UNCACHED_REP,            |
     |                      | NFS4ERR_SERVERFAULT,                   |
     |                      | NFS4ERR_TOO_MANY_OPS, NFS4ERR_WRONGSEC |
     +----------------------+----------------------------------------+
     | READ                 | NFS4ERR_ACCESS, NFS4ERR_ADMIN_REVOKED, |
     |                      | NFS4ERR_BADXDR, NFS4ERR_BAD_STATEID,   |
     |                      | NFS4ERR_DEADSESSION, NFS4ERR_DELAY,    |
     |                      | NFS4ERR_DELEG_REVOKED,                 |
     |                      | NFS4ERR_EXPIRED, NFS4ERR_FHEXPIRED,    |
     |                      | NFS4ERR_GRACE, NFS4ERR_INVAL,          |
     |                      | NFS4ERR_ISDIR, NFS4ERR_IO,             |
     |                      | NFS4ERR_LOCKED, NFS4ERR_MOVED,         |
     |                      | NFS4ERR_NOFILEHANDLE,                  |
     |                      | NFS4ERR_OLD_STATEID, NFS4ERR_OPENMODE, |
     |                      | NFS4ERR_OP_NOT_IN_SESSION,             |
     |                      | NFS4ERR_PNFS_IO_HOLE,                  |
     |                      | NFS4ERR_PNFS_NO_LAYOUT,                |
     |                      | NFS4ERR_REP_TOO_BIG,                   |
     |                      | NFS4ERR_REP_TOO_BIG_TO_CACHE,          |
     |                      | NFS4ERR_REQ_TOO_BIG,                   |
     |                      | NFS4ERR_RETRY_UNCACHED_REP,            |
     |                      | NFS4ERR_SERVERFAULT, NFS4ERR_STALE,    |
     |                      | NFS4ERR_SYMLINK, NFS4ERR_TOO_MANY_OPS, |
     |                      | NFS4ERR_WRONG_TYPE                     |
     +----------------------+----------------------------------------+
     | READDIR              | NFS4ERR_ACCESS, NFS4ERR_BADXDR,        |
     |                      | NFS4ERR_BAD_COOKIE,                    |
     |                      | NFS4ERR_DEADSESSION, NFS4ERR_DELAY,    |
     |                      | NFS4ERR_FHEXPIRED, NFS4ERR_INVAL,      |
     |                      | NFS4ERR_IO, NFS4ERR_MOVED,             |
     |                      | NFS4ERR_NOFILEHANDLE, NFS4ERR_NOTDIR,  |
     |                      | NFS4ERR_NOT_SAME,                      |
     |                      | NFS4ERR_OP_NOT_IN_SESSION,             |
     |                      | NFS4ERR_REP_TOO_BIG,                   |
     |                      | NFS4ERR_REP_TOO_BIG_TO_CACHE,          |
     |                      | NFS4ERR_REQ_TOO_BIG,                   |
     |                      | NFS4ERR_RETRY_UNCACHED_REP,            |
     |                      | NFS4ERR_SERVERFAULT, NFS4ERR_STALE,    |
     |                      | NFS4ERR_TOOSMALL, NFS4ERR_TOO_MANY_OPS |
     +----------------------+----------------------------------------+
     | READLINK             | NFS4ERR_ACCESS, NFS4ERR_DEADSESSION,   |
     |                      | NFS4ERR_DELAY, NFS4ERR_FHEXPIRED,      |
     |                      | NFS4ERR_INVAL, NFS4ERR_IO,             |
     |                      | NFS4ERR_MOVED, NFS4ERR_NOFILEHANDLE,   |
     |                      | NFS4ERR_OP_NOT_IN_SESSION,             |
     |                      | NFS4ERR_REP_TOO_BIG,                   |
     |                      | NFS4ERR_REP_TOO_BIG_TO_CACHE,          |
     |                      | NFS4ERR_REQ_TOO_BIG,                   |
     |                      | NFS4ERR_RETRY_UNCACHED_REP,            |
     |                      | NFS4ERR_SERVERFAULT, NFS4ERR_STALE,    |
     |                      | NFS4ERR_TOO_MANY_OPS,                  |
     |                      | NFS4ERR_WRONG_TYPE                     |
     +----------------------+----------------------------------------+
     | RECLAIM_COMPLETE     | NFS4ERR_BADXDR,                        |
     |                      | NFS4ERR_COMPLETE_ALREADY,              |
     |                      | NFS4ERR_DEADSESSION, NFS4ERR_DELAY,    |
     |                      | NFS4ERR_FHEXPIRED, NFS4ERR_INVAL,      |
     |                      | NFS4ERR_MOVED, NFS4ERR_NOFILEHANDLE,   |
     |                      | NFS4ERR_OP_NOT_IN_SESSION,             |
     |                      | NFS4ERR_REP_TOO_BIG,                   |
     |                      | NFS4ERR_REP_TOO_BIG_TO_CACHE,          |
     |                      | NFS4ERR_REQ_TOO_BIG,                   |
     |                      | NFS4ERR_RETRY_UNCACHED_REP,            |
     |                      | NFS4ERR_SERVERFAULT, NFS4ERR_STALE,    |
     |                      | NFS4ERR_TOO_MANY_OPS,                  |
     |                      | NFS4ERR_WRONG_CRED, NFS4ERR_WRONG_TYPE |
     +----------------------+----------------------------------------+
     | RELEASE_LOCKOWNER    | NFS4ERR_NOTSUPP                        |
     +----------------------+----------------------------------------+
     | REMOVE               | NFS4ERR_ACCESS, NFS4ERR_BADCHAR,       |
     |                      | NFS4ERR_BADNAME, NFS4ERR_BADXDR,       |
     |                      | NFS4ERR_DEADSESSION, NFS4ERR_DELAY,    |
     |                      | NFS4ERR_FHEXPIRED, NFS4ERR_FILE_OPEN,  |
     |                      | NFS4ERR_GRACE, NFS4ERR_INVAL,          |
     |                      | NFS4ERR_IO, NFS4ERR_MOVED,             |
     |                      | NFS4ERR_NAMETOOLONG, NFS4ERR_NOENT,    |
     |                      | NFS4ERR_NOFILEHANDLE, NFS4ERR_NOTDIR,  |
     |                      | NFS4ERR_NOTEMPTY,                      |
     |                      | NFS4ERR_OP_NOT_IN_SESSION,             |
     |                      | NFS4ERR_REP_TOO_BIG,                   |
     |                      | NFS4ERR_REP_TOO_BIG_TO_CACHE,          |
     |                      | NFS4ERR_REQ_TOO_BIG,                   |
     |                      | NFS4ERR_RETRY_UNCACHED_REP,            |
     |                      | NFS4ERR_ROFS, NFS4ERR_SERVERFAULT,     |
     |                      | NFS4ERR_STALE, NFS4ERR_TOO_MANY_OPS    |
     +----------------------+----------------------------------------+
     | RENAME               | NFS4ERR_ACCESS, NFS4ERR_BADCHAR,       |
     |                      | NFS4ERR_BADNAME, NFS4ERR_BADXDR,       |
     |                      | NFS4ERR_DEADSESSION, NFS4ERR_DELAY,    |
     |                      | NFS4ERR_DQUOT, NFS4ERR_EXIST,          |
     |                      | NFS4ERR_FHEXPIRED, NFS4ERR_FILE_OPEN,  |
     |                      | NFS4ERR_GRACE, NFS4ERR_INVAL,          |
     |                      | NFS4ERR_IO, NFS4ERR_MLINK,             |
     |                      | NFS4ERR_MOVED, NFS4ERR_NAMETOOLONG,    |
     |                      | NFS4ERR_NOENT, NFS4ERR_NOFILEHANDLE,   |
     |                      | NFS4ERR_NOSPC, NFS4ERR_NOTDIR,         |
     |                      | NFS4ERR_NOTEMPTY,                      |
     |                      | NFS4ERR_OP_NOT_IN_SESSION,             |
     |                      | NFS4ERR_REP_TOO_BIG,                   |
     |                      | NFS4ERR_REP_TOO_BIG_TO_CACHE,          |
     |                      | NFS4ERR_REQ_TOO_BIG,                   |
     |                      | NFS4ERR_RETRY_UNCACHED_REP,            |
     |                      | NFS4ERR_ROFS, NFS4ERR_SERVERFAULT,     |
     |                      | NFS4ERR_STALE, NFS4ERR_TOO_MANY_OPS,   |
     |                      | NFS4ERR_WRONGSEC, NFS4ERR_XDEV         |
     +----------------------+----------------------------------------+
     | RENEW                | NFS4ERR_NOTSUPP                        |
     +----------------------+----------------------------------------+
     | RESTOREFH            | NFS4ERR_DEADSESSION,                   |
     |                      | NFS4ERR_FHEXPIRED, NFS4ERR_MOVED,      |
     |                      | NFS4ERR_NOFILEHANDLE,                  |
     |                      | NFS4ERR_OP_NOT_IN_SESSION,             |
     |                      | NFS4ERR_REP_TOO_BIG,                   |
     |                      | NFS4ERR_REP_TOO_BIG_TO_CACHE,          |
     |                      | NFS4ERR_REQ_TOO_BIG,                   |
     |                      | NFS4ERR_RETRY_UNCACHED_REP,            |
     |                      | NFS4ERR_SERVERFAULT, NFS4ERR_STALE,    |
     |                      | NFS4ERR_TOO_MANY_OPS, NFS4ERR_WRONGSEC |
     +----------------------+----------------------------------------+
     | SAVEFH               | NFS4ERR_DEADSESSION,                   |
     |                      | NFS4ERR_FHEXPIRED, NFS4ERR_MOVED,      |
     |                      | NFS4ERR_NOFILEHANDLE,                  |
     |                      | NFS4ERR_OP_NOT_IN_SESSION,             |
     |                      | NFS4ERR_REP_TOO_BIG,                   |
     |                      | NFS4ERR_REP_TOO_BIG_TO_CACHE,          |
     |                      | NFS4ERR_REQ_TOO_BIG,                   |
     |                      | NFS4ERR_RETRY_UNCACHED_REP,            |
     |                      | NFS4ERR_SERVERFAULT, NFS4ERR_STALE,    |
     |                      | NFS4ERR_TOO_MANY_OPS                   |
     +----------------------+----------------------------------------+
     | SECINFO              | NFS4ERR_ACCESS, NFS4ERR_BADCHAR,       |
     |                      | NFS4ERR_BADNAME, NFS4ERR_BADXDR,       |
     |                      | NFS4ERR_DEADSESSION, NFS4ERR_DELAY,    |
     |                      | NFS4ERR_FHEXPIRED, NFS4ERR_INVAL,      |
     |                      | NFS4ERR_MOVED, NFS4ERR_NAMETOOLONG,    |
     |                      | NFS4ERR_NOENT, NFS4ERR_NOFILEHANDLE,   |
     |                      | NFS4ERR_NOTDIR,                        |
     |                      | NFS4ERR_OP_NOT_IN_SESSION,             |
     |                      | NFS4ERR_REP_TOO_BIG,                   |
     |                      | NFS4ERR_REP_TOO_BIG_TO_CACHE,          |
     |                      | NFS4ERR_REQ_TOO_BIG,                   |
     |                      | NFS4ERR_RETRY_UNCACHED_REP,            |
     |                      | NFS4ERR_SERVERFAULT, NFS4ERR_STALE,    |
     |                      | NFS4ERR_TOO_MANY_OPS                   |
     +----------------------+----------------------------------------+
     | SECINFO_NO_NAME      | NFS4ERR_ACCESS, NFS4ERR_BADXDR,        |
     |                      | NFS4ERR_DEADSESSION, NFS4ERR_DELAY,    |
     |                      | NFS4ERR_FHEXPIRED, NFS4ERR_INVAL,      |
     |                      | NFS4ERR_MOVED, NFS4ERR_NOENT,          |
     |                      | NFS4ERR_NOFILEHANDLE, NFS4ERR_NOTDIR,  |
     |                      | NFS4ERR_NOTSUPP,                       |
     |                      | NFS4ERR_OP_NOT_IN_SESSION,             |
     |                      | NFS4ERR_REP_TOO_BIG,                   |
     |                      | NFS4ERR_REP_TOO_BIG_TO_CACHE,          |
     |                      | NFS4ERR_REQ_TOO_BIG,                   |
     |                      | NFS4ERR_RETRY_UNCACHED_REP,            |
     |                      | NFS4ERR_SERVERFAULT, NFS4ERR_STALE,    |
     |                      | NFS4ERR_TOO_MANY_OPS                   |
     +----------------------+----------------------------------------+
     | SEQUENCE             | NFS4ERR_BADSESSION, NFS4ERR_BADSLOT,   |
     |                      | NFS4ERR_BADXDR, NFS4ERR_BAD_HIGH_SLOT, |
     |                      | NFS4ERR_CONN_NOT_BOUND_TO_SESSION,     |
     |                      | NFS4ERR_DEADSESSION, NFS4ERR_DELAY,    |
     |                      | NFS4ERR_REP_TOO_BIG,                   |
     |                      | NFS4ERR_REP_TOO_BIG_TO_CACHE,          |
     |                      | NFS4ERR_REQ_TOO_BIG,                   |
     |                      | NFS4ERR_RETRY_UNCACHED_REP,            |
     |                      | NFS4ERR_SEQUENCE_POS,                  |
     |                      | NFS4ERR_SEQ_FALSE_RETRY,               |
     |                      | NFS4ERR_SEQ_MISORDERED,                |
     |                      | NFS4ERR_TOO_MANY_OPS                   |
     +----------------------+----------------------------------------+
     | SET_SSV              | NFS4ERR_BADXDR,                        |
     |                      | NFS4ERR_BAD_SESSION_DIGEST,            |
     |                      | NFS4ERR_DEADSESSION, NFS4ERR_DELAY,    |
     |                      | NFS4ERR_INVAL,                         |
     |                      | NFS4ERR_OP_NOT_IN_SESSION,             |
     |                      | NFS4ERR_REP_TOO_BIG,                   |
     |                      | NFS4ERR_REP_TOO_BIG_TO_CACHE,          |
     |                      | NFS4ERR_REQ_TOO_BIG,                   |
     |                      | NFS4ERR_RETRY_UNCACHED_REP,            |
     |                      | NFS4ERR_TOO_MANY_OPS                   |
     +----------------------+----------------------------------------+
     | SETATTR              | NFS4ERR_ACCESS, NFS4ERR_ADMIN_REVOKED, |
     |                      | NFS4ERR_ATTRNOTSUPP, NFS4ERR_BADCHAR,  |
     |                      | NFS4ERR_BADOWNER, NFS4ERR_BADXDR,      |
     |                      | NFS4ERR_BAD_STATEID,                   |
     |                      | NFS4ERR_DEADSESSION, NFS4ERR_DELAY,    |
     |                      | NFS4ERR_DELEG_REVOKED, NFS4ERR_DQUOT,  |
     |                      | NFS4ERR_EXPIRED, NFS4ERR_FBIG,         |
     |                      | NFS4ERR_FHEXPIRED, NFS4ERR_GRACE,      |
     |                      | NFS4ERR_INVAL, NFS4ERR_IO,             |
     |                      | NFS4ERR_LOCKED, NFS4ERR_MOVED,         |
     |                      | NFS4ERR_NOFILEHANDLE, NFS4ERR_NOSPC,   |
     |                      | NFS4ERR_OLD_STATEID, NFS4ERR_OPENMODE, |
     |                      | NFS4ERR_OP_NOT_IN_SESSION,             |
     |                      | NFS4ERR_PERM, NFS4ERR_REP_TOO_BIG,     |
     |                      | NFS4ERR_REP_TOO_BIG_TO_CACHE,          |
     |                      | NFS4ERR_REQ_TOO_BIG,                   |
     |                      | NFS4ERR_RETRY_UNCACHED_REP,            |
     |                      | NFS4ERR_ROFS, NFS4ERR_SERVERFAULT,     |
     |                      | NFS4ERR_STALE, NFS4ERR_TOO_MANY_OPS,   |
     |                      | NFS4ERR_UNKNOWN_LAYOUTTYPE,            |
     |                      | NFS4ERR_WRONG_TYPE                     |
     +----------------------+----------------------------------------+
     | SETCLIENTID          | NFS4ERR_NOTSUPP                        |
     +----------------------+----------------------------------------+
     | SETCLIENTID_CONFIRM  | NFS4ERR_NOTSUPP                        |
     +----------------------+----------------------------------------+
     | TEST_STATEID         | NFS4ERR_BADXDR, NFS4ERR_DEADSESSION,   |
     |                      | NFS4ERR_DELAY,                         |
     |                      | NFS4ERR_OP_NOT_IN_SESSION,             |
     |                      | NFS4ERR_REP_TOO_BIG,                   |
     |                      | NFS4ERR_REP_TOO_BIG_TO_CACHE,          |
     |                      | NFS4ERR_REQ_TOO_BIG,                   |
     |                      | NFS4ERR_RETRY_UNCACHED_REP,            |
     |                      | NFS4ERR_SERVERFAULT,                   |
     |                      | NFS4ERR_TOO_MANY_OPS                   |
     +----------------------+----------------------------------------+
     | VERIFY               | NFS4ERR_ACCESS, NFS4ERR_ATTRNOTSUPP,   |
     |                      | NFS4ERR_BADCHAR, NFS4ERR_BADXDR,       |
     |                      | NFS4ERR_DEADSESSION, NFS4ERR_DELAY,    |
     |                      | NFS4ERR_FHEXPIRED, NFS4ERR_GRACE,      |
     |                      | NFS4ERR_INVAL, NFS4ERR_IO,             |
     |                      | NFS4ERR_MOVED, NFS4ERR_NOFILEHANDLE,   |
     |                      | NFS4ERR_NOT_SAME,                      |
     |                      | NFS4ERR_OP_NOT_IN_SESSION,             |
     |                      | NFS4ERR_REP_TOO_BIG,                   |
     |                      | NFS4ERR_REP_TOO_BIG_TO_CACHE,          |
     |                      | NFS4ERR_REQ_TOO_BIG,                   |
     |                      | NFS4ERR_RETRY_UNCACHED_REP,            |
     |                      | NFS4ERR_SERVERFAULT, NFS4ERR_STALE,    |
     |                      | NFS4ERR_TOO_MANY_OPS,                  |
     |                      | NFS4ERR_UNKNOWN_LAYOUTTYPE,            |
     |                      | NFS4ERR_WRONG_TYPE                     |
     +----------------------+----------------------------------------+
     | WANT_DELEGATION      | NFS4ERR_BADXDR, NFS4ERR_DEADSESSION,   |
     |                      | NFS4ERR_DELAY,                         |
     |                      | NFS4ERR_DELEG_ALREADY_WANTED,          |
     |                      | NFS4ERR_FHEXPIRED, NFS4ERR_GRACE,      |
     |                      | NFS4ERR_INVAL, NFS4ERR_IO,             |
     |                      | NFS4ERR_MOVED, NFS4ERR_NOFILEHANDLE,   |
     |                      | NFS4ERR_NOTSUPP, NFS4ERR_NO_GRACE,     |
     |                      | NFS4ERR_OP_NOT_IN_SESSION,             |
     |                      | NFS4ERR_RECALLCONFLICT,                |
     |                      | NFS4ERR_RECLAIM_BAD,                   |
     |                      | NFS4ERR_RECLAIM_CONFLICT,              |
     |                      | NFS4ERR_REP_TOO_BIG,                   |
     |                      | NFS4ERR_REP_TOO_BIG_TO_CACHE,          |
     |                      | NFS4ERR_REQ_TOO_BIG,                   |
     |                      | NFS4ERR_RETRY_UNCACHED_REP,            |
     |                      | NFS4ERR_SERVERFAULT, NFS4ERR_STALE,    |
     |                      | NFS4ERR_TOO_MANY_OPS,                  |
     |                      | NFS4ERR_WRONG_TYPE                     |
     +----------------------+----------------------------------------+
     | WRITE                | NFS4ERR_ACCESS, NFS4ERR_ADMIN_REVOKED, |
     |                      | NFS4ERR_BADXDR, NFS4ERR_BAD_STATEID,   |
     |                      | NFS4ERR_DEADSESSION, NFS4ERR_DELAY,    |
     |                      | NFS4ERR_DELEG_REVOKED, NFS4ERR_DQUOT,  |
     |                      | NFS4ERR_EXPIRED, NFS4ERR_FBIG,         |
     |                      | NFS4ERR_FHEXPIRED, NFS4ERR_GRACE,      |
     |                      | NFS4ERR_INVAL, NFS4ERR_IO,             |
     |                      | NFS4ERR_ISDIR, NFS4ERR_LOCKED,         |
     |                      | NFS4ERR_MOVED, NFS4ERR_NOFILEHANDLE,   |
     |                      | NFS4ERR_NOSPC, NFS4ERR_OLD_STATEID,    |
     |                      | NFS4ERR_OPENMODE,                      |
     |                      | NFS4ERR_OP_NOT_IN_SESSION,             |
     |                      | NFS4ERR_PNFS_IO_HOLE,                  |
     |                      | NFS4ERR_PNFS_NO_LAYOUT,                |
     |                      | NFS4ERR_REP_TOO_BIG,                   |
     |                      | NFS4ERR_REP_TOO_BIG_TO_CACHE,          |
     |                      | NFS4ERR_REQ_TOO_BIG,                   |
     |                      | NFS4ERR_RETRY_UNCACHED_REP,            |
     |                      | NFS4ERR_ROFS, NFS4ERR_SERVERFAULT,     |
     |                      | NFS4ERR_STALE, NFS4ERR_SYMLINK,        |
     |                      | NFS4ERR_TOO_MANY_OPS,                  |
     |                      | NFS4ERR_WRONG_TYPE                     |
     +----------------------+----------------------------------------+
```

- 표 12: 각 프로토콜 작업에 대한 유효한 오류 반환

---
### **15.3.  Callback Operations and Their Valid Errors**

이 섹션에는 각 콜백 작업에 대한 유효한 오류 반환을 제공하는 표가 포함되어 있습니다. 오류 코드 NFS4\_OK\(오류 없음을 나타냄\)는 나열되지 않지만 CB\_ILLEGAL을 제외한 모든 콜백 작업에서 반환될 수 있는 것으로 이해해야 합니다.

```text
    +=========================+=======================================+
    | Callback Operation      | Errors                                |
    +=========================+=======================================+
    | CB_GETATTR              | NFS4ERR_BADHANDLE, NFS4ERR_BADXDR,    |
    |                         | NFS4ERR_DELAY, NFS4ERR_INVAL,         |
    |                         | NFS4ERR_OP_NOT_IN_SESSION,            |
    |                         | NFS4ERR_REP_TOO_BIG,                  |
    |                         | NFS4ERR_REP_TOO_BIG_TO_CACHE,         |
    |                         | NFS4ERR_REQ_TOO_BIG,                  |
    |                         | NFS4ERR_RETRY_UNCACHED_REP,           |
    |                         | NFS4ERR_SERVERFAULT,                  |
    |                         | NFS4ERR_TOO_MANY_OPS,                 |
    +-------------------------+---------------------------------------+
    | CB_ILLEGAL              | NFS4ERR_BADXDR, NFS4ERR_OP_ILLEGAL    |
    +-------------------------+---------------------------------------+
    | CB_LAYOUTRECALL         | NFS4ERR_BADHANDLE, NFS4ERR_BADIOMODE, |
    |                         | NFS4ERR_BADXDR, NFS4ERR_BAD_STATEID,  |
    |                         | NFS4ERR_DELAY, NFS4ERR_INVAL,         |
    |                         | NFS4ERR_NOMATCHING_LAYOUT,            |
    |                         | NFS4ERR_NOTSUPP,                      |
    |                         | NFS4ERR_OP_NOT_IN_SESSION,            |
    |                         | NFS4ERR_REP_TOO_BIG,                  |
    |                         | NFS4ERR_REP_TOO_BIG_TO_CACHE,         |
    |                         | NFS4ERR_REQ_TOO_BIG,                  |
    |                         | NFS4ERR_RETRY_UNCACHED_REP,           |
    |                         | NFS4ERR_TOO_MANY_OPS,                 |
    |                         | NFS4ERR_UNKNOWN_LAYOUTTYPE,           |
    |                         | NFS4ERR_WRONG_TYPE                    |
    +-------------------------+---------------------------------------+
    | CB_NOTIFY               | NFS4ERR_BADHANDLE, NFS4ERR_BADXDR,    |
    |                         | NFS4ERR_BAD_STATEID, NFS4ERR_DELAY,   |
    |                         | NFS4ERR_INVAL, NFS4ERR_NOTSUPP,       |
    |                         | NFS4ERR_OP_NOT_IN_SESSION,            |
    |                         | NFS4ERR_REP_TOO_BIG,                  |
    |                         | NFS4ERR_REP_TOO_BIG_TO_CACHE,         |
    |                         | NFS4ERR_REQ_TOO_BIG,                  |
    |                         | NFS4ERR_RETRY_UNCACHED_REP,           |
    |                         | NFS4ERR_SERVERFAULT,                  |
    |                         | NFS4ERR_TOO_MANY_OPS                  |
    +-------------------------+---------------------------------------+
    | CB_NOTIFY_DEVICEID      | NFS4ERR_BADXDR, NFS4ERR_DELAY,        |
    |                         | NFS4ERR_INVAL, NFS4ERR_NOTSUPP,       |
    |                         | NFS4ERR_OP_NOT_IN_SESSION,            |
    |                         | NFS4ERR_REP_TOO_BIG,                  |
    |                         | NFS4ERR_REP_TOO_BIG_TO_CACHE,         |
    |                         | NFS4ERR_REQ_TOO_BIG,                  |
    |                         | NFS4ERR_RETRY_UNCACHED_REP,           |
    |                         | NFS4ERR_SERVERFAULT,                  |
    |                         | NFS4ERR_TOO_MANY_OPS                  |
    +-------------------------+---------------------------------------+
    | CB_NOTIFY_LOCK          | NFS4ERR_BADHANDLE, NFS4ERR_BADXDR,    |
    |                         | NFS4ERR_BAD_STATEID, NFS4ERR_DELAY,   |
    |                         | NFS4ERR_NOTSUPP,                      |
    |                         | NFS4ERR_OP_NOT_IN_SESSION,            |
    |                         | NFS4ERR_REP_TOO_BIG,                  |
    |                         | NFS4ERR_REP_TOO_BIG_TO_CACHE,         |
    |                         | NFS4ERR_REQ_TOO_BIG,                  |
    |                         | NFS4ERR_RETRY_UNCACHED_REP,           |
    |                         | NFS4ERR_SERVERFAULT,                  |
    |                         | NFS4ERR_TOO_MANY_OPS                  |
    +-------------------------+---------------------------------------+
    | CB_PUSH_DELEG           | NFS4ERR_BADHANDLE, NFS4ERR_BADXDR,    |
    |                         | NFS4ERR_DELAY, NFS4ERR_INVAL,         |
    |                         | NFS4ERR_NOTSUPP,                      |
    |                         | NFS4ERR_OP_NOT_IN_SESSION,            |
    |                         | NFS4ERR_REJECT_DELEG,                 |
    |                         | NFS4ERR_REP_TOO_BIG,                  |
    |                         | NFS4ERR_REP_TOO_BIG_TO_CACHE,         |
    |                         | NFS4ERR_REQ_TOO_BIG,                  |
    |                         | NFS4ERR_RETRY_UNCACHED_REP,           |
    |                         | NFS4ERR_SERVERFAULT,                  |
    |                         | NFS4ERR_TOO_MANY_OPS,                 |
    |                         | NFS4ERR_WRONG_TYPE                    |
    +-------------------------+---------------------------------------+
    | CB_RECALL               | NFS4ERR_BADHANDLE, NFS4ERR_BADXDR,    |
    |                         | NFS4ERR_BAD_STATEID, NFS4ERR_DELAY,   |
    |                         | NFS4ERR_OP_NOT_IN_SESSION,            |
    |                         | NFS4ERR_REP_TOO_BIG,                  |
    |                         | NFS4ERR_REP_TOO_BIG_TO_CACHE,         |
    |                         | NFS4ERR_REQ_TOO_BIG,                  |
    |                         | NFS4ERR_RETRY_UNCACHED_REP,           |
    |                         | NFS4ERR_SERVERFAULT,                  |
    |                         | NFS4ERR_TOO_MANY_OPS                  |
    +-------------------------+---------------------------------------+
    | CB_RECALL_ANY           | NFS4ERR_BADXDR, NFS4ERR_DELAY,        |
    |                         | NFS4ERR_INVAL,                        |
    |                         | NFS4ERR_OP_NOT_IN_SESSION,            |
    |                         | NFS4ERR_REP_TOO_BIG,                  |
    |                         | NFS4ERR_REP_TOO_BIG_TO_CACHE,         |
    |                         | NFS4ERR_REQ_TOO_BIG,                  |
    |                         | NFS4ERR_RETRY_UNCACHED_REP,           |
    |                         | NFS4ERR_TOO_MANY_OPS                  |
    +-------------------------+---------------------------------------+
    | CB_RECALLABLE_OBJ_AVAIL | NFS4ERR_BADXDR, NFS4ERR_DELAY,        |
    |                         | NFS4ERR_INVAL, NFS4ERR_NOTSUPP,       |
    |                         | NFS4ERR_OP_NOT_IN_SESSION,            |
    |                         | NFS4ERR_REP_TOO_BIG,                  |
    |                         | NFS4ERR_REP_TOO_BIG_TO_CACHE,         |
    |                         | NFS4ERR_REQ_TOO_BIG,                  |
    |                         | NFS4ERR_RETRY_UNCACHED_REP,           |
    |                         | NFS4ERR_SERVERFAULT,                  |
    |                         | NFS4ERR_TOO_MANY_OPS                  |
    +-------------------------+---------------------------------------+
    | CB_RECALL_SLOT          | NFS4ERR_BADXDR,                       |
    |                         | NFS4ERR_BAD_HIGH_SLOT, NFS4ERR_DELAY, |
    |                         | NFS4ERR_OP_NOT_IN_SESSION,            |
    |                         | NFS4ERR_REP_TOO_BIG,                  |
    |                         | NFS4ERR_REP_TOO_BIG_TO_CACHE,         |
    |                         | NFS4ERR_REQ_TOO_BIG,                  |
    |                         | NFS4ERR_RETRY_UNCACHED_REP,           |
    |                         | NFS4ERR_TOO_MANY_OPS                  |
    +-------------------------+---------------------------------------+
    | CB_SEQUENCE             | NFS4ERR_BADSESSION, NFS4ERR_BADSLOT,  |
    |                         | NFS4ERR_BADXDR,                       |
    |                         | NFS4ERR_BAD_HIGH_SLOT,                |
    |                         | NFS4ERR_CONN_NOT_BOUND_TO_SESSION,    |
    |                         | NFS4ERR_DELAY, NFS4ERR_REP_TOO_BIG,   |
    |                         | NFS4ERR_REP_TOO_BIG_TO_CACHE,         |
    |                         | NFS4ERR_REQ_TOO_BIG,                  |
    |                         | NFS4ERR_RETRY_UNCACHED_REP,           |
    |                         | NFS4ERR_SEQUENCE_POS,                 |
    |                         | NFS4ERR_SEQ_FALSE_RETRY,              |
    |                         | NFS4ERR_SEQ_MISORDERED,               |
    |                         | NFS4ERR_TOO_MANY_OPS                  |
    +-------------------------+---------------------------------------+
    | CB_WANTS_CANCELLED      | NFS4ERR_BADXDR, NFS4ERR_DELAY,        |
    |                         | NFS4ERR_NOTSUPP,                      |
    |                         | NFS4ERR_OP_NOT_IN_SESSION,            |
    |                         | NFS4ERR_REP_TOO_BIG,                  |
    |                         | NFS4ERR_REP_TOO_BIG_TO_CACHE,         |
    |                         | NFS4ERR_REQ_TOO_BIG,                  |
    |                         | NFS4ERR_RETRY_UNCACHED_REP,           |
    |                         | NFS4ERR_SERVERFAULT,                  |
    |                         | NFS4ERR_TOO_MANY_OPS                  |
    +-------------------------+---------------------------------------+

     Table 13: Valid Error Returns for Each Protocol Callback Operation
```

---
### **15.4.  Errors and the Operations That Use Them**

```text
   +===================================+===============================+
   | Error                             | Operations                    |
   +===================================+===============================+
   | NFS4ERR_ACCESS                    | ACCESS, COMMIT, CREATE,       |
   |                                   | GETATTR, GET_DIR_DELEGATION,  |
   |                                   | LAYOUTCOMMIT, LAYOUTGET,      |
   |                                   | LINK, LOCK, LOCKT, LOCKU,     |
   |                                   | LOOKUP, LOOKUPP, NVERIFY,     |
   |                                   | OPEN, OPENATTR, READ,         |
   |                                   | READDIR, READLINK, REMOVE,    |
   |                                   | RENAME, SECINFO,              |
   |                                   | SECINFO_NO_NAME, SETATTR,     |
   |                                   | VERIFY, WRITE                 |
   +-----------------------------------+-------------------------------+
   | NFS4ERR_ADMIN_REVOKED             | CLOSE, DELEGRETURN,           |
   |                                   | LAYOUTCOMMIT, LAYOUTGET,      |
   |                                   | LAYOUTRETURN, LOCK, LOCKU,    |
   |                                   | OPEN, OPEN_DOWNGRADE, READ,   |
   |                                   | SETATTR, WRITE                |
   +-----------------------------------+-------------------------------+
   | NFS4ERR_ATTRNOTSUPP               | CREATE, LAYOUTCOMMIT,         |
   |                                   | NVERIFY, OPEN, SETATTR,       |
   |                                   | VERIFY                        |
   +-----------------------------------+-------------------------------+
   | NFS4ERR_BACK_CHAN_BUSY            | DESTROY_SESSION               |
   +-----------------------------------+-------------------------------+
   | NFS4ERR_BADCHAR                   | CREATE, EXCHANGE_ID, LINK,    |
   |                                   | LOOKUP, NVERIFY, OPEN,        |
   |                                   | REMOVE, RENAME, SECINFO,      |
   |                                   | SETATTR, VERIFY               |
   +-----------------------------------+-------------------------------+
   | NFS4ERR_BADHANDLE                 | CB_GETATTR, CB_LAYOUTRECALL,  |
   |                                   | CB_NOTIFY, CB_NOTIFY_LOCK,    |
   |                                   | CB_PUSH_DELEG, CB_RECALL,     |
   |                                   | PUTFH                         |
   +-----------------------------------+-------------------------------+
   | NFS4ERR_BADIOMODE                 | CB_LAYOUTRECALL,              |
   |                                   | LAYOUTCOMMIT, LAYOUTGET       |
   +-----------------------------------+-------------------------------+
   | NFS4ERR_BADLAYOUT                 | LAYOUTCOMMIT, LAYOUTGET       |
   +-----------------------------------+-------------------------------+
   | NFS4ERR_BADNAME                   | CREATE, LINK, LOOKUP, OPEN,   |
   |                                   | REMOVE, RENAME, SECINFO       |
   +-----------------------------------+-------------------------------+
   | NFS4ERR_BADOWNER                  | CREATE, OPEN, SETATTR         |
   +-----------------------------------+-------------------------------+
   | NFS4ERR_BADSESSION                | BIND_CONN_TO_SESSION,         |
   |                                   | CB_SEQUENCE,                  |
   |                                   | DESTROY_SESSION, SEQUENCE     |
   +-----------------------------------+-------------------------------+
   | NFS4ERR_BADSLOT                   | CB_SEQUENCE, SEQUENCE         |
   +-----------------------------------+-------------------------------+
   | NFS4ERR_BADTYPE                   | CREATE                        |
   +-----------------------------------+-------------------------------+
   | NFS4ERR_BADXDR                    | ACCESS, BACKCHANNEL_CTL,      |
   |                                   | BIND_CONN_TO_SESSION,         |
   |                                   | CB_GETATTR, CB_ILLEGAL,       |
   |                                   | CB_LAYOUTRECALL, CB_NOTIFY,   |
   |                                   | CB_NOTIFY_DEVICEID,           |
   |                                   | CB_NOTIFY_LOCK,               |
   |                                   | CB_PUSH_DELEG, CB_RECALL,     |
   |                                   | CB_RECALLABLE_OBJ_AVAIL,      |
   |                                   | CB_RECALL_ANY,                |
   |                                   | CB_RECALL_SLOT, CB_SEQUENCE,  |
   |                                   | CB_WANTS_CANCELLED, CLOSE,    |
   |                                   | COMMIT, CREATE,               |
   |                                   | CREATE_SESSION, DELEGPURGE,   |
   |                                   | DELEGRETURN,                  |
   |                                   | DESTROY_CLIENTID,             |
   |                                   | DESTROY_SESSION,              |
   |                                   | EXCHANGE_ID, FREE_STATEID,    |
   |                                   | GETATTR, GETDEVICEINFO,       |
   |                                   | GETDEVICELIST,                |
   |                                   | GET_DIR_DELEGATION, ILLEGAL,  |
   |                                   | LAYOUTCOMMIT, LAYOUTGET,      |
   |                                   | LAYOUTRETURN, LINK, LOCK,     |
   |                                   | LOCKT, LOCKU, LOOKUP,         |
   |                                   | NVERIFY, OPEN, OPENATTR,      |
   |                                   | OPEN_DOWNGRADE, PUTFH, READ,  |
   |                                   | READDIR, RECLAIM_COMPLETE,    |
   |                                   | REMOVE, RENAME, SECINFO,      |
   |                                   | SECINFO_NO_NAME, SEQUENCE,    |
   |                                   | SETATTR, SET_SSV,             |
   |                                   | TEST_STATEID, VERIFY,         |
   |                                   | WANT_DELEGATION, WRITE        |
   +-----------------------------------+-------------------------------+
   | NFS4ERR_BAD_COOKIE                | GETDEVICELIST, READDIR        |
   +-----------------------------------+-------------------------------+
   | NFS4ERR_BAD_HIGH_SLOT             | CB_RECALL_SLOT, CB_SEQUENCE,  |
   |                                   | SEQUENCE                      |
   +-----------------------------------+-------------------------------+
   | NFS4ERR_BAD_RANGE                 | LOCK, LOCKT, LOCKU            |
   +-----------------------------------+-------------------------------+
   | NFS4ERR_BAD_SESSION_DIGEST        | BIND_CONN_TO_SESSION,         |
   |                                   | SET_SSV                       |
   +-----------------------------------+-------------------------------+
   | NFS4ERR_BAD_STATEID               | CB_LAYOUTRECALL, CB_NOTIFY,   |
   |                                   | CB_NOTIFY_LOCK, CB_RECALL,    |
   |                                   | CLOSE, DELEGRETURN,           |
   |                                   | FREE_STATEID, LAYOUTGET,      |
   |                                   | LAYOUTRETURN, LOCK, LOCKU,    |
   |                                   | OPEN, OPEN_DOWNGRADE, READ,   |
   |                                   | SETATTR, WRITE                |
   +-----------------------------------+-------------------------------+
   | NFS4ERR_CB_PATH_DOWN              | DESTROY_SESSION               |
   +-----------------------------------+-------------------------------+
   | NFS4ERR_CLID_INUSE                | CREATE_SESSION, EXCHANGE_ID   |
   +-----------------------------------+-------------------------------+
   | NFS4ERR_CLIENTID_BUSY             | DESTROY_CLIENTID              |
   +-----------------------------------+-------------------------------+
   | NFS4ERR_COMPLETE_ALREADY          | RECLAIM_COMPLETE              |
   +-----------------------------------+-------------------------------+
   | NFS4ERR_CONN_NOT_BOUND_TO_SESSION | CB_SEQUENCE,                  |
   |                                   | DESTROY_SESSION, SEQUENCE     |
   +-----------------------------------+-------------------------------+
   | NFS4ERR_DEADLOCK                  | LOCK                          |
   +-----------------------------------+-------------------------------+
   | NFS4ERR_DEADSESSION               | ACCESS, BACKCHANNEL_CTL,      |
   |                                   | BIND_CONN_TO_SESSION, CLOSE,  |
   |                                   | COMMIT, CREATE,               |
   |                                   | CREATE_SESSION, DELEGPURGE,   |
   |                                   | DELEGRETURN,                  |
   |                                   | DESTROY_CLIENTID,             |
   |                                   | DESTROY_SESSION,              |
   |                                   | EXCHANGE_ID, FREE_STATEID,    |
   |                                   | GETATTR, GETDEVICEINFO,       |
   |                                   | GETDEVICELIST,                |
   |                                   | GET_DIR_DELEGATION,           |
   |                                   | LAYOUTCOMMIT, LAYOUTGET,      |
   |                                   | LAYOUTRETURN, LINK, LOCK,     |
   |                                   | LOCKT, LOCKU, LOOKUP,         |
   |                                   | LOOKUPP, NVERIFY, OPEN,       |
   |                                   | OPENATTR, OPEN_DOWNGRADE,     |
   |                                   | PUTFH, PUTPUBFH, PUTROOTFH,   |
   |                                   | READ, READDIR, READLINK,      |
   |                                   | RECLAIM_COMPLETE, REMOVE,     |
   |                                   | RENAME, RESTOREFH, SAVEFH,    |
   |                                   | SECINFO, SECINFO_NO_NAME,     |
   |                                   | SEQUENCE, SETATTR, SET_SSV,   |
   |                                   | TEST_STATEID, VERIFY,         |
   |                                   | WANT_DELEGATION, WRITE        |
   +-----------------------------------+-------------------------------+
   | NFS4ERR_DELAY                     | ACCESS, BACKCHANNEL_CTL,      |
   |                                   | BIND_CONN_TO_SESSION,         |
   |                                   | CB_GETATTR, CB_LAYOUTRECALL,  |
   |                                   | CB_NOTIFY,                    |
   |                                   | CB_NOTIFY_DEVICEID,           |
   |                                   | CB_NOTIFY_LOCK,               |
   |                                   | CB_PUSH_DELEG, CB_RECALL,     |
   |                                   | CB_RECALLABLE_OBJ_AVAIL,      |
   |                                   | CB_RECALL_ANY,                |
   |                                   | CB_RECALL_SLOT, CB_SEQUENCE,  |
   |                                   | CB_WANTS_CANCELLED, CLOSE,    |
   |                                   | COMMIT, CREATE,               |
   |                                   | CREATE_SESSION, DELEGPURGE,   |
   |                                   | DELEGRETURN,                  |
   |                                   | DESTROY_CLIENTID,             |
   |                                   | DESTROY_SESSION,              |
   |                                   | EXCHANGE_ID, FREE_STATEID,    |
   |                                   | GETATTR, GETDEVICEINFO,       |
   |                                   | GETDEVICELIST,                |
   |                                   | GET_DIR_DELEGATION,           |
   |                                   | LAYOUTCOMMIT, LAYOUTGET,      |
   |                                   | LAYOUTRETURN, LINK, LOCK,     |
   |                                   | LOCKT, LOCKU, LOOKUP,         |
   |                                   | LOOKUPP, NVERIFY, OPEN,       |
   |                                   | OPENATTR, OPEN_DOWNGRADE,     |
   |                                   | PUTFH, PUTPUBFH, PUTROOTFH,   |
   |                                   | READ, READDIR, READLINK,      |
   |                                   | RECLAIM_COMPLETE, REMOVE,     |
   |                                   | RENAME, SECINFO,              |
   |                                   | SECINFO_NO_NAME, SEQUENCE,    |
   |                                   | SETATTR, SET_SSV,             |
   |                                   | TEST_STATEID, VERIFY,         |
   |                                   | WANT_DELEGATION, WRITE        |
   +-----------------------------------+-------------------------------+
   | NFS4ERR_DELEG_ALREADY_WANTED      | OPEN, WANT_DELEGATION         |
   +-----------------------------------+-------------------------------+
   | NFS4ERR_DELEG_REVOKED             | DELEGRETURN, LAYOUTCOMMIT,    |
   |                                   | LAYOUTGET, LAYOUTRETURN,      |
   |                                   | OPEN, READ, SETATTR, WRITE    |
   +-----------------------------------+-------------------------------+
   | NFS4ERR_DENIED                    | LOCK, LOCKT                   |
   +-----------------------------------+-------------------------------+
   | NFS4ERR_DIRDELEG_UNAVAIL          | GET_DIR_DELEGATION            |
   +-----------------------------------+-------------------------------+
   | NFS4ERR_DQUOT                     | CREATE, LAYOUTGET, LINK,      |
   |                                   | OPEN, OPENATTR, RENAME,       |
   |                                   | SETATTR, WRITE                |
   +-----------------------------------+-------------------------------+
   | NFS4ERR_ENCR_ALG_UNSUPP           | EXCHANGE_ID                   |
   +-----------------------------------+-------------------------------+
   | NFS4ERR_EXIST                     | CREATE, LINK, OPEN, RENAME    |
   +-----------------------------------+-------------------------------+
   | NFS4ERR_EXPIRED                   | CLOSE, DELEGRETURN,           |
   |                                   | LAYOUTCOMMIT, LAYOUTRETURN,   |
   |                                   | LOCK, LOCKU, OPEN,            |
   |                                   | OPEN_DOWNGRADE, READ,         |
   |                                   | SETATTR, WRITE                |
   +-----------------------------------+-------------------------------+
   | NFS4ERR_FBIG                      | LAYOUTCOMMIT, OPEN, SETATTR,  |
   |                                   | WRITE                         |
   +-----------------------------------+-------------------------------+
   | NFS4ERR_FHEXPIRED                 | ACCESS, CLOSE, COMMIT,        |
   |                                   | CREATE, DELEGRETURN,          |
   |                                   | GETATTR, GETDEVICELIST,       |
   |                                   | GETFH, GET_DIR_DELEGATION,    |
   |                                   | LAYOUTCOMMIT, LAYOUTGET,      |
   |                                   | LAYOUTRETURN, LINK, LOCK,     |
   |                                   | LOCKT, LOCKU, LOOKUP,         |
   |                                   | LOOKUPP, NVERIFY, OPEN,       |
   |                                   | OPENATTR, OPEN_DOWNGRADE,     |
   |                                   | READ, READDIR, READLINK,      |
   |                                   | RECLAIM_COMPLETE, REMOVE,     |
   |                                   | RENAME, RESTOREFH, SAVEFH,    |
   |                                   | SECINFO, SECINFO_NO_NAME,     |
   |                                   | SETATTR, VERIFY,              |
   |                                   | WANT_DELEGATION, WRITE        |
   +-----------------------------------+-------------------------------+
   | NFS4ERR_FILE_OPEN                 | LINK, REMOVE, RENAME          |
   +-----------------------------------+-------------------------------+
   | NFS4ERR_GRACE                     | GETATTR, GET_DIR_DELEGATION,  |
   |                                   | LAYOUTCOMMIT, LAYOUTGET,      |
   |                                   | LAYOUTRETURN, LINK, LOCK,     |
   |                                   | LOCKT, NVERIFY, OPEN, READ,   |
   |                                   | REMOVE, RENAME, SETATTR,      |
   |                                   | VERIFY, WANT_DELEGATION,      |
   |                                   | WRITE                         |
   +-----------------------------------+-------------------------------+
   | NFS4ERR_HASH_ALG_UNSUPP           | EXCHANGE_ID                   |
   +-----------------------------------+-------------------------------+
   | NFS4ERR_INVAL                     | ACCESS, BACKCHANNEL_CTL,      |
   |                                   | BIND_CONN_TO_SESSION,         |
   |                                   | CB_GETATTR, CB_LAYOUTRECALL,  |
   |                                   | CB_NOTIFY,                    |
   |                                   | CB_NOTIFY_DEVICEID,           |
   |                                   | CB_PUSH_DELEG,                |
   |                                   | CB_RECALLABLE_OBJ_AVAIL,      |
   |                                   | CB_RECALL_ANY, CREATE,        |
   |                                   | CREATE_SESSION, DELEGRETURN,  |
   |                                   | EXCHANGE_ID, GETATTR,         |
   |                                   | GETDEVICEINFO,                |
   |                                   | GETDEVICELIST,                |
   |                                   | GET_DIR_DELEGATION,           |
   |                                   | LAYOUTCOMMIT, LAYOUTGET,      |
   |                                   | LAYOUTRETURN, LINK, LOCK,     |
   |                                   | LOCKT, LOCKU, LOOKUP,         |
   |                                   | NVERIFY, OPEN,                |
   |                                   | OPEN_DOWNGRADE, READ,         |
   |                                   | READDIR, READLINK,            |
   |                                   | RECLAIM_COMPLETE, REMOVE,     |
   |                                   | RENAME, SECINFO,              |
   |                                   | SECINFO_NO_NAME, SETATTR,     |
   |                                   | SET_SSV, VERIFY,              |
   |                                   | WANT_DELEGATION, WRITE        |
   +-----------------------------------+-------------------------------+
   | NFS4ERR_IO                        | ACCESS, COMMIT, CREATE,       |
   |                                   | GETATTR, GETDEVICELIST,       |
   |                                   | GET_DIR_DELEGATION,           |
   |                                   | LAYOUTCOMMIT, LAYOUTGET,      |
   |                                   | LINK, LOOKUP, LOOKUPP,        |
   |                                   | NVERIFY, OPEN, OPENATTR,      |
   |                                   | READ, READDIR, READLINK,      |
   |                                   | REMOVE, RENAME, SETATTR,      |
   |                                   | VERIFY, WANT_DELEGATION,      |
   |                                   | WRITE                         |
   +-----------------------------------+-------------------------------+
   | NFS4ERR_ISDIR                     | COMMIT, LAYOUTCOMMIT,         |
   |                                   | LAYOUTRETURN, LINK, LOCK,     |
   |                                   | LOCKT, OPEN, READ, WRITE      |
   +-----------------------------------+-------------------------------+
   | NFS4ERR_LAYOUTTRYLATER            | LAYOUTGET                     |
   +-----------------------------------+-------------------------------+
   | NFS4ERR_LAYOUTUNAVAILABLE         | LAYOUTGET                     |
   +-----------------------------------+-------------------------------+
   | NFS4ERR_LOCKED                    | LAYOUTGET, READ, SETATTR,     |
   |                                   | WRITE                         |
   +-----------------------------------+-------------------------------+
   | NFS4ERR_LOCKS_HELD                | CLOSE, FREE_STATEID           |
   +-----------------------------------+-------------------------------+
   | NFS4ERR_LOCK_NOTSUPP              | LOCK                          |
   +-----------------------------------+-------------------------------+
   | NFS4ERR_LOCK_RANGE                | LOCK, LOCKT, LOCKU            |
   +-----------------------------------+-------------------------------+
   | NFS4ERR_MLINK                     | CREATE, LINK, RENAME          |
   +-----------------------------------+-------------------------------+
   | NFS4ERR_MOVED                     | ACCESS, CLOSE, COMMIT,        |
   |                                   | CREATE, DELEGRETURN,          |
   |                                   | GETATTR, GETFH,               |
   |                                   | GET_DIR_DELEGATION,           |
   |                                   | LAYOUTCOMMIT, LAYOUTGET,      |
   |                                   | LAYOUTRETURN, LINK, LOCK,     |
   |                                   | LOCKT, LOCKU, LOOKUP,         |
   |                                   | LOOKUPP, NVERIFY, OPEN,       |
   |                                   | OPENATTR, OPEN_DOWNGRADE,     |
   |                                   | PUTFH, READ, READDIR,         |
   |                                   | READLINK, RECLAIM_COMPLETE,   |
   |                                   | REMOVE, RENAME, RESTOREFH,    |
   |                                   | SAVEFH, SECINFO,              |
   |                                   | SECINFO_NO_NAME, SETATTR,     |
   |                                   | VERIFY, WANT_DELEGATION,      |
   |                                   | WRITE                         |
   +-----------------------------------+-------------------------------+
   | NFS4ERR_NAMETOOLONG               | CREATE, LINK, LOOKUP, OPEN,   |
   |                                   | REMOVE, RENAME, SECINFO       |
   +-----------------------------------+-------------------------------+
   | NFS4ERR_NOENT                     | BACKCHANNEL_CTL,              |
   |                                   | CREATE_SESSION, EXCHANGE_ID,  |
   |                                   | GETDEVICEINFO, LOOKUP,        |
   |                                   | LOOKUPP, OPEN, OPENATTR,      |
   |                                   | REMOVE, RENAME, SECINFO,      |
   |                                   | SECINFO_NO_NAME               |
   +-----------------------------------+-------------------------------+
   | NFS4ERR_NOFILEHANDLE              | ACCESS, CLOSE, COMMIT,        |
   |                                   | CREATE, DELEGRETURN,          |
   |                                   | GETATTR, GETDEVICELIST,       |
   |                                   | GETFH, GET_DIR_DELEGATION,    |
   |                                   | LAYOUTCOMMIT, LAYOUTGET,      |
   |                                   | LAYOUTRETURN, LINK, LOCK,     |
   |                                   | LOCKT, LOCKU, LOOKUP,         |
   |                                   | LOOKUPP, NVERIFY, OPEN,       |
   |                                   | OPENATTR, OPEN_DOWNGRADE,     |
   |                                   | READ, READDIR, READLINK,      |
   |                                   | RECLAIM_COMPLETE, REMOVE,     |
   |                                   | RENAME, RESTOREFH, SAVEFH,    |
   |                                   | SECINFO, SECINFO_NO_NAME,     |
   |                                   | SETATTR, VERIFY,              |
   |                                   | WANT_DELEGATION, WRITE        |
   +-----------------------------------+-------------------------------+
   | NFS4ERR_NOMATCHING_LAYOUT         | CB_LAYOUTRECALL               |
   +-----------------------------------+-------------------------------+
   | NFS4ERR_NOSPC                     | CREATE, CREATE_SESSION,       |
   |                                   | LAYOUTGET, LINK, OPEN,        |
   |                                   | OPENATTR, RENAME, SETATTR,    |
   |                                   | WRITE                         |
   +-----------------------------------+-------------------------------+
   | NFS4ERR_NOTDIR                    | CREATE, GET_DIR_DELEGATION,   |
   |                                   | LINK, LOOKUP, LOOKUPP, OPEN,  |
   |                                   | READDIR, REMOVE, RENAME,      |
   |                                   | SECINFO, SECINFO_NO_NAME      |
   +-----------------------------------+-------------------------------+
   | NFS4ERR_NOTEMPTY                  | REMOVE, RENAME                |
   +-----------------------------------+-------------------------------+
   | NFS4ERR_NOTSUPP                   | CB_LAYOUTRECALL, CB_NOTIFY,   |
   |                                   | CB_NOTIFY_DEVICEID,           |
   |                                   | CB_NOTIFY_LOCK,               |
   |                                   | CB_PUSH_DELEG,                |
   |                                   | CB_RECALLABLE_OBJ_AVAIL,      |
   |                                   | CB_WANTS_CANCELLED,           |
   |                                   | DELEGPURGE, DELEGRETURN,      |
   |                                   | GETDEVICEINFO,                |
   |                                   | GETDEVICELIST,                |
   |                                   | GET_DIR_DELEGATION,           |
   |                                   | LAYOUTCOMMIT, LAYOUTGET,      |
   |                                   | LAYOUTRETURN, LINK,           |
   |                                   | OPENATTR, OPEN_CONFIRM,       |
   |                                   | RELEASE_LOCKOWNER, RENEW,     |
   |                                   | SECINFO_NO_NAME,              |
   |                                   | SETCLIENTID,                  |
   |                                   | SETCLIENTID_CONFIRM,          |
   |                                   | WANT_DELEGATION               |
   +-----------------------------------+-------------------------------+
   | NFS4ERR_NOT_ONLY_OP               | BIND_CONN_TO_SESSION,         |
   |                                   | CREATE_SESSION,               |
   |                                   | DESTROY_CLIENTID,             |
   |                                   | DESTROY_SESSION, EXCHANGE_ID  |
   +-----------------------------------+-------------------------------+
   | NFS4ERR_NOT_SAME                  | EXCHANGE_ID, GETDEVICELIST,   |
   |                                   | READDIR, VERIFY               |
   +-----------------------------------+-------------------------------+
   | NFS4ERR_NO_GRACE                  | LAYOUTCOMMIT, LAYOUTRETURN,   |
   |                                   | LOCK, OPEN, WANT_DELEGATION   |
   +-----------------------------------+-------------------------------+
   | NFS4ERR_OLD_STATEID               | CLOSE, DELEGRETURN,           |
   |                                   | FREE_STATEID, LAYOUTGET,      |
   |                                   | LAYOUTRETURN, LOCK, LOCKU,    |
   |                                   | OPEN, OPEN_DOWNGRADE, READ,   |
   |                                   | SETATTR, WRITE                |
   +-----------------------------------+-------------------------------+
   | NFS4ERR_OPENMODE                  | LAYOUTGET, LOCK, READ,        |
   |                                   | SETATTR, WRITE                |
   +-----------------------------------+-------------------------------+
   | NFS4ERR_OP_ILLEGAL                | CB_ILLEGAL, ILLEGAL           |
   +-----------------------------------+-------------------------------+
   | NFS4ERR_OP_NOT_IN_SESSION         | ACCESS, BACKCHANNEL_CTL,      |
   |                                   | CB_GETATTR, CB_LAYOUTRECALL,  |
   |                                   | CB_NOTIFY,                    |
   |                                   | CB_NOTIFY_DEVICEID,           |
   |                                   | CB_NOTIFY_LOCK,               |
   |                                   | CB_PUSH_DELEG, CB_RECALL,     |
   |                                   | CB_RECALLABLE_OBJ_AVAIL,      |
   |                                   | CB_RECALL_ANY,                |
   |                                   | CB_RECALL_SLOT,               |
   |                                   | CB_WANTS_CANCELLED, CLOSE,    |
   |                                   | COMMIT, CREATE, DELEGPURGE,   |
   |                                   | DELEGRETURN, FREE_STATEID,    |
   |                                   | GETATTR, GETDEVICEINFO,       |
   |                                   | GETDEVICELIST, GETFH,         |
   |                                   | GET_DIR_DELEGATION,           |
   |                                   | LAYOUTCOMMIT, LAYOUTGET,      |
   |                                   | LAYOUTRETURN, LINK, LOCK,     |
   |                                   | LOCKT, LOCKU, LOOKUP,         |
   |                                   | LOOKUPP, NVERIFY, OPEN,       |
   |                                   | OPENATTR, OPEN_DOWNGRADE,     |
   |                                   | PUTFH, PUTPUBFH, PUTROOTFH,   |
   |                                   | READ, READDIR, READLINK,      |
   |                                   | RECLAIM_COMPLETE, REMOVE,     |
   |                                   | RENAME, RESTOREFH, SAVEFH,    |
   |                                   | SECINFO, SECINFO_NO_NAME,     |
   |                                   | SETATTR, SET_SSV,             |
   |                                   | TEST_STATEID, VERIFY,         |
   |                                   | WANT_DELEGATION, WRITE        |
   +-----------------------------------+-------------------------------+
   | NFS4ERR_PERM                      | CREATE, OPEN, SETATTR         |
   +-----------------------------------+-------------------------------+
   | NFS4ERR_PNFS_IO_HOLE              | READ, WRITE                   |
   +-----------------------------------+-------------------------------+
   | NFS4ERR_PNFS_NO_LAYOUT            | READ, WRITE                   |
   +-----------------------------------+-------------------------------+
   | NFS4ERR_RECALLCONFLICT            | LAYOUTGET, WANT_DELEGATION    |
   +-----------------------------------+-------------------------------+
   | NFS4ERR_RECLAIM_BAD               | LAYOUTCOMMIT, LOCK, OPEN,     |
   |                                   | WANT_DELEGATION               |
   +-----------------------------------+-------------------------------+
   | NFS4ERR_RECLAIM_CONFLICT          | LAYOUTCOMMIT, LOCK, OPEN,     |
   |                                   | WANT_DELEGATION               |
   +-----------------------------------+-------------------------------+
   | NFS4ERR_REJECT_DELEG              | CB_PUSH_DELEG                 |
   +-----------------------------------+-------------------------------+
   | NFS4ERR_REP_TOO_BIG               | ACCESS, BACKCHANNEL_CTL,      |
   |                                   | BIND_CONN_TO_SESSION,         |
   |                                   | CB_GETATTR, CB_LAYOUTRECALL,  |
   |                                   | CB_NOTIFY,                    |
   |                                   | CB_NOTIFY_DEVICEID,           |
   |                                   | CB_NOTIFY_LOCK,               |
   |                                   | CB_PUSH_DELEG, CB_RECALL,     |
   |                                   | CB_RECALLABLE_OBJ_AVAIL,      |
   |                                   | CB_RECALL_ANY,                |
   |                                   | CB_RECALL_SLOT, CB_SEQUENCE,  |
   |                                   | CB_WANTS_CANCELLED, CLOSE,    |
   |                                   | COMMIT, CREATE,               |
   |                                   | CREATE_SESSION, DELEGPURGE,   |
   |                                   | DELEGRETURN,                  |
   |                                   | DESTROY_CLIENTID,             |
   |                                   | DESTROY_SESSION,              |
   |                                   | EXCHANGE_ID, FREE_STATEID,    |
   |                                   | GETATTR, GETDEVICEINFO,       |
   |                                   | GETDEVICELIST,                |
   |                                   | GET_DIR_DELEGATION,           |
   |                                   | LAYOUTCOMMIT, LAYOUTGET,      |
   |                                   | LAYOUTRETURN, LINK, LOCK,     |
   |                                   | LOCKT, LOCKU, LOOKUP,         |
   |                                   | LOOKUPP, NVERIFY, OPEN,       |
   |                                   | OPENATTR, OPEN_DOWNGRADE,     |
   |                                   | PUTFH, PUTPUBFH, PUTROOTFH,   |
   |                                   | READ, READDIR, READLINK,      |
   |                                   | RECLAIM_COMPLETE, REMOVE,     |
   |                                   | RENAME, RESTOREFH, SAVEFH,    |
   |                                   | SECINFO, SECINFO_NO_NAME,     |
   |                                   | SEQUENCE, SETATTR, SET_SSV,   |
   |                                   | TEST_STATEID, VERIFY,         |
   |                                   | WANT_DELEGATION, WRITE        |
   +-----------------------------------+-------------------------------+
   | NFS4ERR_REP_TOO_BIG_TO_CACHE      | ACCESS, BACKCHANNEL_CTL,      |
   |                                   | BIND_CONN_TO_SESSION,         |
   |                                   | CB_GETATTR, CB_LAYOUTRECALL,  |
   |                                   | CB_NOTIFY,                    |
   |                                   | CB_NOTIFY_DEVICEID,           |
   |                                   | CB_NOTIFY_LOCK,               |
   |                                   | CB_PUSH_DELEG, CB_RECALL,     |
   |                                   | CB_RECALLABLE_OBJ_AVAIL,      |
   |                                   | CB_RECALL_ANY,                |
   |                                   | CB_RECALL_SLOT, CB_SEQUENCE,  |
   |                                   | CB_WANTS_CANCELLED, CLOSE,    |
   |                                   | COMMIT, CREATE,               |
   |                                   | CREATE_SESSION, DELEGPURGE,   |
   |                                   | DELEGRETURN,                  |
   |                                   | DESTROY_CLIENTID,             |
   |                                   | DESTROY_SESSION,              |
   |                                   | EXCHANGE_ID, FREE_STATEID,    |
   |                                   | GETATTR, GETDEVICEINFO,       |
   |                                   | GETDEVICELIST,                |
   |                                   | GET_DIR_DELEGATION,           |
   |                                   | LAYOUTCOMMIT, LAYOUTGET,      |
   |                                   | LAYOUTRETURN, LINK, LOCK,     |
   |                                   | LOCKT, LOCKU, LOOKUP,         |
   |                                   | LOOKUPP, NVERIFY, OPEN,       |
   |                                   | OPENATTR, OPEN_DOWNGRADE,     |
   |                                   | PUTFH, PUTPUBFH, PUTROOTFH,   |
   |                                   | READ, READDIR, READLINK,      |
   |                                   | RECLAIM_COMPLETE, REMOVE,     |
   |                                   | RENAME, RESTOREFH, SAVEFH,    |
   |                                   | SECINFO, SECINFO_NO_NAME,     |
   |                                   | SEQUENCE, SETATTR, SET_SSV,   |
   |                                   | TEST_STATEID, VERIFY,         |
   |                                   | WANT_DELEGATION, WRITE        |
   +-----------------------------------+-------------------------------+
   | NFS4ERR_REQ_TOO_BIG               | ACCESS, BACKCHANNEL_CTL,      |
   |                                   | BIND_CONN_TO_SESSION,         |
   |                                   | CB_GETATTR, CB_LAYOUTRECALL,  |
   |                                   | CB_NOTIFY,                    |
   |                                   | CB_NOTIFY_DEVICEID,           |
   |                                   | CB_NOTIFY_LOCK,               |
   |                                   | CB_PUSH_DELEG, CB_RECALL,     |
   |                                   | CB_RECALLABLE_OBJ_AVAIL,      |
   |                                   | CB_RECALL_ANY,                |
   |                                   | CB_RECALL_SLOT, CB_SEQUENCE,  |
   |                                   | CB_WANTS_CANCELLED, CLOSE,    |
   |                                   | COMMIT, CREATE,               |
   |                                   | CREATE_SESSION, DELEGPURGE,   |
   |                                   | DELEGRETURN,                  |
   |                                   | DESTROY_CLIENTID,             |
   |                                   | DESTROY_SESSION,              |
   |                                   | EXCHANGE_ID, FREE_STATEID,    |
   |                                   | GETATTR, GETDEVICEINFO,       |
   |                                   | GETDEVICELIST,                |
   |                                   | GET_DIR_DELEGATION,           |
   |                                   | LAYOUTCOMMIT, LAYOUTGET,      |
   |                                   | LAYOUTRETURN, LINK, LOCK,     |
   |                                   | LOCKT, LOCKU, LOOKUP,         |
   |                                   | LOOKUPP, NVERIFY, OPEN,       |
   |                                   | OPENATTR, OPEN_DOWNGRADE,     |
   |                                   | PUTFH, PUTPUBFH, PUTROOTFH,   |
   |                                   | READ, READDIR, READLINK,      |
   |                                   | RECLAIM_COMPLETE, REMOVE,     |
   |                                   | RENAME, RESTOREFH, SAVEFH,    |
   |                                   | SECINFO, SECINFO_NO_NAME,     |
   |                                   | SEQUENCE, SETATTR, SET_SSV,   |
   |                                   | TEST_STATEID, VERIFY,         |
   |                                   | WANT_DELEGATION, WRITE        |
   +-----------------------------------+-------------------------------+
   | NFS4ERR_RETRY_UNCACHED_REP        | ACCESS, BACKCHANNEL_CTL,      |
   |                                   | BIND_CONN_TO_SESSION,         |
   |                                   | CB_GETATTR, CB_LAYOUTRECALL,  |
   |                                   | CB_NOTIFY,                    |
   |                                   | CB_NOTIFY_DEVICEID,           |
   |                                   | CB_NOTIFY_LOCK,               |
   |                                   | CB_PUSH_DELEG, CB_RECALL,     |
   |                                   | CB_RECALLABLE_OBJ_AVAIL,      |
   |                                   | CB_RECALL_ANY,                |
   |                                   | CB_RECALL_SLOT, CB_SEQUENCE,  |
   |                                   | CB_WANTS_CANCELLED, CLOSE,    |
   |                                   | COMMIT, CREATE,               |
   |                                   | CREATE_SESSION, DELEGPURGE,   |
   |                                   | DELEGRETURN,                  |
   |                                   | DESTROY_CLIENTID,             |
   |                                   | DESTROY_SESSION,              |
   |                                   | EXCHANGE_ID, FREE_STATEID,    |
   |                                   | GETATTR, GETDEVICEINFO,       |
   |                                   | GETDEVICELIST,                |
   |                                   | GET_DIR_DELEGATION,           |
   |                                   | LAYOUTCOMMIT, LAYOUTGET,      |
   |                                   | LAYOUTRETURN, LINK, LOCK,     |
   |                                   | LOCKT, LOCKU, LOOKUP,         |
   |                                   | LOOKUPP, NVERIFY, OPEN,       |
   |                                   | OPENATTR, OPEN_DOWNGRADE,     |
   |                                   | PUTFH, PUTPUBFH, PUTROOTFH,   |
   |                                   | READ, READDIR, READLINK,      |
   |                                   | RECLAIM_COMPLETE, REMOVE,     |
   |                                   | RENAME, RESTOREFH, SAVEFH,    |
   |                                   | SECINFO, SECINFO_NO_NAME,     |
   |                                   | SEQUENCE, SETATTR, SET_SSV,   |
   |                                   | TEST_STATEID, VERIFY,         |
   |                                   | WANT_DELEGATION, WRITE        |
   +-----------------------------------+-------------------------------+
   | NFS4ERR_ROFS                      | CREATE, LINK, LOCK, LOCKT,    |
   |                                   | OPEN, OPENATTR,               |
   |                                   | OPEN_DOWNGRADE, REMOVE,       |
   |                                   | RENAME, SETATTR, WRITE        |
   +-----------------------------------+-------------------------------+
   | NFS4ERR_SAME                      | NVERIFY                       |
   +-----------------------------------+-------------------------------+
   | NFS4ERR_SEQUENCE_POS              | CB_SEQUENCE, SEQUENCE         |
   +-----------------------------------+-------------------------------+
   | NFS4ERR_SEQ_FALSE_RETRY           | CB_SEQUENCE, SEQUENCE         |
   +-----------------------------------+-------------------------------+
   | NFS4ERR_SEQ_MISORDERED            | CB_SEQUENCE, CREATE_SESSION,  |
   |                                   | SEQUENCE                      |
   +-----------------------------------+-------------------------------+
   | NFS4ERR_SERVERFAULT               | ACCESS,                       |
   |                                   | BIND_CONN_TO_SESSION,         |
   |                                   | CB_GETATTR, CB_NOTIFY,        |
   |                                   | CB_NOTIFY_DEVICEID,           |
   |                                   | CB_NOTIFY_LOCK,               |
   |                                   | CB_PUSH_DELEG, CB_RECALL,     |
   |                                   | CB_RECALLABLE_OBJ_AVAIL,      |
   |                                   | CB_WANTS_CANCELLED, CLOSE,    |
   |                                   | COMMIT, CREATE,               |
   |                                   | CREATE_SESSION, DELEGPURGE,   |
   |                                   | DELEGRETURN,                  |
   |                                   | DESTROY_CLIENTID,             |
   |                                   | DESTROY_SESSION,              |
   |                                   | EXCHANGE_ID, FREE_STATEID,    |
   |                                   | GETATTR, GETDEVICEINFO,       |
   |                                   | GETDEVICELIST,                |
   |                                   | GET_DIR_DELEGATION,           |
   |                                   | LAYOUTCOMMIT, LAYOUTGET,      |
   |                                   | LAYOUTRETURN, LINK, LOCK,     |
   |                                   | LOCKU, LOOKUP, LOOKUPP,       |
   |                                   | NVERIFY, OPEN, OPENATTR,      |
   |                                   | OPEN_DOWNGRADE, PUTFH,        |
   |                                   | PUTPUBFH, PUTROOTFH, READ,    |
   |                                   | READDIR, READLINK,            |
   |                                   | RECLAIM_COMPLETE, REMOVE,     |
   |                                   | RENAME, RESTOREFH, SAVEFH,    |
   |                                   | SECINFO, SECINFO_NO_NAME,     |
   |                                   | SETATTR, TEST_STATEID,        |
   |                                   | VERIFY, WANT_DELEGATION,      |
   |                                   | WRITE                         |
   +-----------------------------------+-------------------------------+
   | NFS4ERR_SHARE_DENIED              | OPEN                          |
   +-----------------------------------+-------------------------------+
   | NFS4ERR_STALE                     | ACCESS, CLOSE, COMMIT,        |
   |                                   | CREATE, DELEGRETURN,          |
   |                                   | GETATTR, GETFH,               |
   |                                   | GET_DIR_DELEGATION,           |
   |                                   | LAYOUTCOMMIT, LAYOUTGET,      |
   |                                   | LAYOUTRETURN, LINK, LOCK,     |
   |                                   | LOCKT, LOCKU, LOOKUP,         |
   |                                   | LOOKUPP, NVERIFY, OPEN,       |
   |                                   | OPENATTR, OPEN_DOWNGRADE,     |
   |                                   | PUTFH, READ, READDIR,         |
   |                                   | READLINK, RECLAIM_COMPLETE,   |
   |                                   | REMOVE, RENAME, RESTOREFH,    |
   |                                   | SAVEFH, SECINFO,              |
   |                                   | SECINFO_NO_NAME, SETATTR,     |
   |                                   | VERIFY, WANT_DELEGATION,      |
   |                                   | WRITE                         |
   +-----------------------------------+-------------------------------+
   | NFS4ERR_STALE_CLIENTID            | CREATE_SESSION,               |
   |                                   | DESTROY_CLIENTID,             |
   |                                   | DESTROY_SESSION               |
   +-----------------------------------+-------------------------------+
   | NFS4ERR_SYMLINK                   | COMMIT, LAYOUTCOMMIT, LINK,   |
   |                                   | LOCK, LOCKT, LOOKUP,          |
   |                                   | LOOKUPP, OPEN, READ, WRITE    |
   +-----------------------------------+-------------------------------+
   | NFS4ERR_TOOSMALL                  | CREATE_SESSION,               |
   |                                   | GETDEVICEINFO, LAYOUTGET,     |
   |                                   | READDIR                       |
   +-----------------------------------+-------------------------------+
   | NFS4ERR_TOO_MANY_OPS              | ACCESS, BACKCHANNEL_CTL,      |
   |                                   | BIND_CONN_TO_SESSION,         |
   |                                   | CB_GETATTR, CB_LAYOUTRECALL,  |
   |                                   | CB_NOTIFY,                    |
   |                                   | CB_NOTIFY_DEVICEID,           |
   |                                   | CB_NOTIFY_LOCK,               |
   |                                   | CB_PUSH_DELEG, CB_RECALL,     |
   |                                   | CB_RECALLABLE_OBJ_AVAIL,      |
   |                                   | CB_RECALL_ANY,                |
   |                                   | CB_RECALL_SLOT, CB_SEQUENCE,  |
   |                                   | CB_WANTS_CANCELLED, CLOSE,    |
   |                                   | COMMIT, CREATE,               |
   |                                   | CREATE_SESSION, DELEGPURGE,   |
   |                                   | DELEGRETURN,                  |
   |                                   | DESTROY_CLIENTID,             |
   |                                   | DESTROY_SESSION,              |
   |                                   | EXCHANGE_ID, FREE_STATEID,    |
   |                                   | GETATTR, GETDEVICEINFO,       |
   |                                   | GETDEVICELIST,                |
   |                                   | GET_DIR_DELEGATION,           |
   |                                   | LAYOUTCOMMIT, LAYOUTGET,      |
   |                                   | LAYOUTRETURN, LINK, LOCK,     |
   |                                   | LOCKT, LOCKU, LOOKUP,         |
   |                                   | LOOKUPP, NVERIFY, OPEN,       |
   |                                   | OPENATTR, OPEN_DOWNGRADE,     |
   |                                   | PUTFH, PUTPUBFH, PUTROOTFH,   |
   |                                   | READ, READDIR, READLINK,      |
   |                                   | RECLAIM_COMPLETE, REMOVE,     |
   |                                   | RENAME, RESTOREFH, SAVEFH,    |
   |                                   | SECINFO, SECINFO_NO_NAME,     |
   |                                   | SEQUENCE, SETATTR, SET_SSV,   |
   |                                   | TEST_STATEID, VERIFY,         |
   |                                   | WANT_DELEGATION, WRITE        |
   +-----------------------------------+-------------------------------+
   | NFS4ERR_UNKNOWN_LAYOUTTYPE        | CB_LAYOUTRECALL,              |
   |                                   | GETDEVICEINFO,                |
   |                                   | GETDEVICELIST, LAYOUTCOMMIT,  |
   |                                   | LAYOUTGET, LAYOUTRETURN,      |
   |                                   | NVERIFY, SETATTR, VERIFY      |
   +-----------------------------------+-------------------------------+
   | NFS4ERR_UNSAFE_COMPOUND           | CREATE, OPEN, OPENATTR        |
   +-----------------------------------+-------------------------------+
   | NFS4ERR_WRONGSEC                  | LINK, LOOKUP, LOOKUPP, OPEN,  |
   |                                   | PUTFH, PUTPUBFH, PUTROOTFH,   |
   |                                   | RENAME, RESTOREFH             |
   +-----------------------------------+-------------------------------+
   | NFS4ERR_WRONG_CRED                | CLOSE, CREATE_SESSION,        |
   |                                   | DELEGPURGE, DELEGRETURN,      |
   |                                   | DESTROY_CLIENTID,             |
   |                                   | DESTROY_SESSION,              |
   |                                   | FREE_STATEID, LAYOUTCOMMIT,   |
   |                                   | LAYOUTRETURN, LOCK, LOCKT,    |
   |                                   | LOCKU, OPEN_DOWNGRADE,        |
   |                                   | RECLAIM_COMPLETE              |
   +-----------------------------------+-------------------------------+
   | NFS4ERR_WRONG_TYPE                | CB_LAYOUTRECALL,              |
   |                                   | CB_PUSH_DELEG, COMMIT,        |
   |                                   | GETATTR, LAYOUTGET,           |
   |                                   | LAYOUTRETURN, LINK, LOCK,     |
   |                                   | LOCKT, NVERIFY, OPEN,         |
   |                                   | OPENATTR, READ, READLINK,     |
   |                                   | RECLAIM_COMPLETE, SETATTR,    |
   |                                   | VERIFY, WANT_DELEGATION,      |
   |                                   | WRITE                         |
   +-----------------------------------+-------------------------------+
   | NFS4ERR_XDEV                      | LINK, RENAME                  |
   +-----------------------------------+-------------------------------+

             Table 14: Errors and the Operations That Use Them
```

---
## **16.  NFSv4.1 Procedures**

NULL 및 COMPOUND 프로시저를 모두 구현해야 합니다.\(MUST\)

---
### **16.1.  Procedure 0: NULL - No Operation**
---
#### **16.1.1.  ARGUMENTS**

```text
   void;
```

---
#### **16.1.2.  RESULTS**

```text
   void;
```

---
#### **16.1.3.  DESCRIPTION**

이는 표준 void 인수와 void 응답을 사용하는 표준 NULL 프로시저입니다. 이 절차에는 관련된 기능이 없습니다. 이 때문에 서비스 요청 처리에 따른 오버헤드를 측정하는 데 사용되는 경우도 있습니다. 따라서 서버는 이 절차를 서비스하는 데 불필요한 작업이 수행되지 않도록 해야 합니다.\(SHOULD\)

---
#### **16.1.4.  ERRORS**

```text
   None.
```

---
### **16.2.  Procedure 1: COMPOUND - Compound Operations**
---
#### **16.2.1.  ARGUMENTS**

```text
   enum nfs_opnum4 {
    OP_ACCESS              = 3,
    OP_CLOSE               = 4,
    OP_COMMIT              = 5,
    OP_CREATE              = 6,
    OP_DELEGPURGE          = 7,
    OP_DELEGRETURN         = 8,
    OP_GETATTR             = 9,
    OP_GETFH               = 10,
    OP_LINK                = 11,
    OP_LOCK                = 12,
    OP_LOCKT               = 13,
    OP_LOCKU               = 14,
    OP_LOOKUP              = 15,
    OP_LOOKUPP             = 16,
    OP_NVERIFY             = 17,
    OP_OPEN                = 18,
    OP_OPENATTR            = 19,
    OP_OPEN_CONFIRM        = 20, /* Mandatory not-to-implement */
    OP_OPEN_DOWNGRADE      = 21,
    OP_PUTFH               = 22,
    OP_PUTPUBFH            = 23,
    OP_PUTROOTFH           = 24,
    OP_READ                = 25,
    OP_READDIR             = 26,
    OP_READLINK            = 27,
    OP_REMOVE              = 28,
    OP_RENAME              = 29,
    OP_RENEW               = 30, /* Mandatory not-to-implement */
    OP_RESTOREFH           = 31,
    OP_SAVEFH              = 32,
    OP_SECINFO             = 33,
    OP_SETATTR             = 34,
    OP_SETCLIENTID         = 35, /* Mandatory not-to-implement */
    OP_SETCLIENTID_CONFIRM = 36, /* Mandatory not-to-implement */
    OP_VERIFY              = 37,
    OP_WRITE               = 38,
    OP_RELEASE_LOCKOWNER   = 39, /* Mandatory not-to-implement */

   /* new operations for NFSv4.1 */

    OP_BACKCHANNEL_CTL     = 40,
    OP_BIND_CONN_TO_SESSION = 41,
    OP_EXCHANGE_ID         = 42,
    OP_CREATE_SESSION      = 43,
    OP_DESTROY_SESSION     = 44,
    OP_FREE_STATEID        = 45,
    OP_GET_DIR_DELEGATION  = 46,
    OP_GETDEVICEINFO       = 47,
    OP_GETDEVICELIST       = 48,
    OP_LAYOUTCOMMIT        = 49,
    OP_LAYOUTGET           = 50,
    OP_LAYOUTRETURN        = 51,
    OP_SECINFO_NO_NAME     = 52,
    OP_SEQUENCE            = 53,
    OP_SET_SSV             = 54,
    OP_TEST_STATEID        = 55,
    OP_WANT_DELEGATION     = 56,
    OP_DESTROY_CLIENTID    = 57,
    OP_RECLAIM_COMPLETE    = 58,
    OP_ILLEGAL             = 10044
   };

   union nfs_argop4 switch (nfs_opnum4 argop) {
    case OP_ACCESS:        ACCESS4args opaccess;
    case OP_CLOSE:         CLOSE4args opclose;
    case OP_COMMIT:        COMMIT4args opcommit;
    case OP_CREATE:        CREATE4args opcreate;
    case OP_DELEGPURGE:    DELEGPURGE4args opdelegpurge;
    case OP_DELEGRETURN:   DELEGRETURN4args opdelegreturn;
    case OP_GETATTR:       GETATTR4args opgetattr;
    case OP_GETFH:         void;
    case OP_LINK:          LINK4args oplink;
    case OP_LOCK:          LOCK4args oplock;
    case OP_LOCKT:         LOCKT4args oplockt;
    case OP_LOCKU:         LOCKU4args oplocku;
    case OP_LOOKUP:        LOOKUP4args oplookup;
    case OP_LOOKUPP:       void;
    case OP_NVERIFY:       NVERIFY4args opnverify;
    case OP_OPEN:          OPEN4args opopen;
    case OP_OPENATTR:      OPENATTR4args opopenattr;

    /* Not for NFSv4.1 */
    case OP_OPEN_CONFIRM:  OPEN_CONFIRM4args opopen_confirm;

    case OP_OPEN_DOWNGRADE:
                           OPEN_DOWNGRADE4args opopen_downgrade;

    case OP_PUTFH:         PUTFH4args opputfh;
    case OP_PUTPUBFH:      void;
    case OP_PUTROOTFH:     void;
    case OP_READ:          READ4args opread;
    case OP_READDIR:       READDIR4args opreaddir;
    case OP_READLINK:      void;
    case OP_REMOVE:        REMOVE4args opremove;
    case OP_RENAME:        RENAME4args oprename;

    /* Not for NFSv4.1 */
    case OP_RENEW:         RENEW4args oprenew;

    case OP_RESTOREFH:     void;
    case OP_SAVEFH:        void;
    case OP_SECINFO:       SECINFO4args opsecinfo;
    case OP_SETATTR:       SETATTR4args opsetattr;

    /* Not for NFSv4.1 */
    case OP_SETCLIENTID: SETCLIENTID4args opsetclientid;

    /* Not for NFSv4.1 */
    case OP_SETCLIENTID_CONFIRM: SETCLIENTID_CONFIRM4args
                                   opsetclientid_confirm;
    case OP_VERIFY:        VERIFY4args opverify;
    case OP_WRITE:         WRITE4args opwrite;

    /* Not for NFSv4.1 */
    case OP_RELEASE_LOCKOWNER:
                           RELEASE_LOCKOWNER4args
                           oprelease_lockowner;

    /* Operations new to NFSv4.1 */
    case OP_BACKCHANNEL_CTL:
                           BACKCHANNEL_CTL4args opbackchannel_ctl;

    case OP_BIND_CONN_TO_SESSION:
                           BIND_CONN_TO_SESSION4args
                           opbind_conn_to_session;

    case OP_EXCHANGE_ID:   EXCHANGE_ID4args opexchange_id;

    case OP_CREATE_SESSION:
                           CREATE_SESSION4args opcreate_session;

    case OP_DESTROY_SESSION:
                           DESTROY_SESSION4args opdestroy_session;

    case OP_FREE_STATEID:  FREE_STATEID4args opfree_stateid;

    case OP_GET_DIR_DELEGATION:
                           GET_DIR_DELEGATION4args
                                   opget_dir_delegation;

    case OP_GETDEVICEINFO: GETDEVICEINFO4args opgetdeviceinfo;
    case OP_GETDEVICELIST: GETDEVICELIST4args opgetdevicelist;
    case OP_LAYOUTCOMMIT:  LAYOUTCOMMIT4args oplayoutcommit;
    case OP_LAYOUTGET:     LAYOUTGET4args oplayoutget;
    case OP_LAYOUTRETURN:  LAYOUTRETURN4args oplayoutreturn;

    case OP_SECINFO_NO_NAME:
                           SECINFO_NO_NAME4args opsecinfo_no_name;

    case OP_SEQUENCE:      SEQUENCE4args opsequence;
    case OP_SET_SSV:       SET_SSV4args opset_ssv;
    case OP_TEST_STATEID:  TEST_STATEID4args optest_stateid;

    case OP_WANT_DELEGATION:
                           WANT_DELEGATION4args opwant_delegation;

    case OP_DESTROY_CLIENTID:
                           DESTROY_CLIENTID4args
                                   opdestroy_clientid;

    case OP_RECLAIM_COMPLETE:
                           RECLAIM_COMPLETE4args
                                   opreclaim_complete;

    /* Operations not new to NFSv4.1 */
    case OP_ILLEGAL:       void;
   };

   struct COMPOUND4args {
           utf8str_cs      tag;
           uint32_t        minorversion;
           nfs_argop4      argarray<>;
   };
```

---
#### **16.2.2.  RESULTS**

```text
   union nfs_resop4 switch (nfs_opnum4 resop) {
    case OP_ACCESS:        ACCESS4res opaccess;
    case OP_CLOSE:         CLOSE4res opclose;
    case OP_COMMIT:        COMMIT4res opcommit;
    case OP_CREATE:        CREATE4res opcreate;
    case OP_DELEGPURGE:    DELEGPURGE4res opdelegpurge;
    case OP_DELEGRETURN:   DELEGRETURN4res opdelegreturn;
    case OP_GETATTR:       GETATTR4res opgetattr;
    case OP_GETFH:         GETFH4res opgetfh;
    case OP_LINK:          LINK4res oplink;
    case OP_LOCK:          LOCK4res oplock;
    case OP_LOCKT:         LOCKT4res oplockt;
    case OP_LOCKU:         LOCKU4res oplocku;
    case OP_LOOKUP:        LOOKUP4res oplookup;
    case OP_LOOKUPP:       LOOKUPP4res oplookupp;
    case OP_NVERIFY:       NVERIFY4res opnverify;
    case OP_OPEN:          OPEN4res opopen;
    case OP_OPENATTR:      OPENATTR4res opopenattr;
    /* Not for NFSv4.1 */
    case OP_OPEN_CONFIRM:  OPEN_CONFIRM4res opopen_confirm;

    case OP_OPEN_DOWNGRADE:
                           OPEN_DOWNGRADE4res
                                   opopen_downgrade;

    case OP_PUTFH:         PUTFH4res opputfh;
    case OP_PUTPUBFH:      PUTPUBFH4res opputpubfh;
    case OP_PUTROOTFH:     PUTROOTFH4res opputrootfh;
    case OP_READ:          READ4res opread;
    case OP_READDIR:       READDIR4res opreaddir;
    case OP_READLINK:      READLINK4res opreadlink;
    case OP_REMOVE:        REMOVE4res opremove;
    case OP_RENAME:        RENAME4res oprename;
    /* Not for NFSv4.1 */
    case OP_RENEW:         RENEW4res oprenew;
    case OP_RESTOREFH:     RESTOREFH4res oprestorefh;
    case OP_SAVEFH:        SAVEFH4res opsavefh;
    case OP_SECINFO:       SECINFO4res opsecinfo;
    case OP_SETATTR:       SETATTR4res opsetattr;
    /* Not for NFSv4.1 */
    case OP_SETCLIENTID: SETCLIENTID4res opsetclientid;

    /* Not for NFSv4.1 */
    case OP_SETCLIENTID_CONFIRM:
                           SETCLIENTID_CONFIRM4res
                                   opsetclientid_confirm;
    case OP_VERIFY:        VERIFY4res opverify;
    case OP_WRITE:         WRITE4res opwrite;

    /* Not for NFSv4.1 */
    case OP_RELEASE_LOCKOWNER:
                           RELEASE_LOCKOWNER4res
                                   oprelease_lockowner;

    /* Operations new to NFSv4.1 */
    case OP_BACKCHANNEL_CTL:
                           BACKCHANNEL_CTL4res
                                   opbackchannel_ctl;

    case OP_BIND_CONN_TO_SESSION:
                           BIND_CONN_TO_SESSION4res
                                    opbind_conn_to_session;

    case OP_EXCHANGE_ID:   EXCHANGE_ID4res opexchange_id;

    case OP_CREATE_SESSION:
                           CREATE_SESSION4res
                                   opcreate_session;

    case OP_DESTROY_SESSION:
                           DESTROY_SESSION4res
                                   opdestroy_session;

    case OP_FREE_STATEID:  FREE_STATEID4res
                                   opfree_stateid;

    case OP_GET_DIR_DELEGATION:
                           GET_DIR_DELEGATION4res
                                   opget_dir_delegation;

    case OP_GETDEVICEINFO: GETDEVICEINFO4res
                                   opgetdeviceinfo;

    case OP_GETDEVICELIST: GETDEVICELIST4res
                                   opgetdevicelist;

    case OP_LAYOUTCOMMIT:  LAYOUTCOMMIT4res oplayoutcommit;
    case OP_LAYOUTGET:     LAYOUTGET4res oplayoutget;
    case OP_LAYOUTRETURN:  LAYOUTRETURN4res oplayoutreturn;

    case OP_SECINFO_NO_NAME:
                           SECINFO_NO_NAME4res
                                   opsecinfo_no_name;

    case OP_SEQUENCE:      SEQUENCE4res opsequence;
    case OP_SET_SSV:       SET_SSV4res opset_ssv;
    case OP_TEST_STATEID:  TEST_STATEID4res optest_stateid;

    case OP_WANT_DELEGATION:
                           WANT_DELEGATION4res
                                   opwant_delegation;

    case OP_DESTROY_CLIENTID:
                           DESTROY_CLIENTID4res
                                   opdestroy_clientid;

    case OP_RECLAIM_COMPLETE:
                           RECLAIM_COMPLETE4res
                                   opreclaim_complete;

    /* Operations not new to NFSv4.1 */
    case OP_ILLEGAL:       ILLEGAL4res opillegal;
   };

   struct COMPOUND4res {
           nfsstat4        status;
           utf8str_cs      tag;
           nfs_resop4      resarray<>;
   };
```

---
#### **16.2.3.  DESCRIPTION**

COMPOUND 프로시저는 하나 이상의 NFSv4 작업을 단일 RPC 요청으로 결합하는 데 사용됩니다. 서버는 각 작업을 차례로 해석합니다. 서버에서 작업이 실행되고 해당 작업의 상태가 NFS4\_OK이면 COMPOUND 프로시저의 다음 작업이 실행됩니다. 서버는 더 이상 실행할 작업이 없거나 작업 중 하나가 NFS4\_OK 이외의 상태 값을 가질 때까지 이 프로세스를 계속합니다.

COMPOUND 프로시저를 처리하는 동안 서버는 COMPOUND 시퀀스 내의 작업 중 일부 또는 전부를 실행하는 데 사용할 수 있는 리소스가 없다는 것을 알 수 있습니다. 더 자세한 내용은 섹션 2.10.6.4를 참조하세요.

서버는 일반적으로 클라이언트 요청을 디코딩하는 두 가지 방법 중에서 선택합니다. 첫 번째는 전통적인 원패스 XDR 디코드입니다. 이 경우 XDR 디코딩 오류가 있으면 RPC XDR 디코드 오류가 반환됩니다. 두 번째 방법은 기본 COMPOUND 요청을 디코딩하기 위한 초기 패스를 만든 다음 개별 작업을 XDR 디코딩하는 것입니다. 가장 흥미로운 것은 속성의 디코드입니다. 이 경우 서버는 두 번째 패스 중에 XDR 디코드 오류가 발생할 수 있습니다. 그렇다면 서버는 NFS4ERR\_BADXDR 오류를 반환하여 디코딩 오류를 나타냅니다.

COMPOUND 인수에는 "minorversion" 필드가 포함되어 있습니다. NFSv4.1의 경우 이 필드의 값은 1입니다. 서버가 지원하지 않는 마이너 버전 필드 값이 있는 COMPOUND 프로시저를 수신하는 경우 서버는 NFS4ERR\_MINOR\_VERS\_MISMATCH 오류와 길이가 0인 결과 데이터 배열을 반환해야 합니다.\(MUST\)

COMPOUND 결과에는 "상태" 필드가 포함되어 있습니다. 결과 배열 길이가 0이 아닌 경우 이 상태는 COMPOUND 프로시저 내에서 실행된 마지막 작업의 상태와 동일해야 합니다. 따라서 작업에서 오류가 발생한 경우 "상태" 값은 실패한 작업에 대해 반환되는 오류 값과 동일합니다.

COMPOUND 프로시저에는 연산 0과 1이 정의되어 있지 않습니다. 작업 2는 정의되지 않았으며 향후 정의 및 부 버전 관리와 함께 사용하도록 예약되어 있습니다. 서버가 작업 2가 포함된 작업 배열을 수신하고 majorversion 필드의 값이 0인 경우 다음 단락에 설명된 대로 NFS4ERR\_OP\_ILLEGAL 오류가 클라이언트에 반환됩니다. 작업 배열에 작업 2가 포함되어 있고 Minorversion 필드가 0이 아니고 서버가 마이너 버전을 지원하지 않는 경우 서버는 NFS4ERR\_MINOR\_VERS\_MISMATCH 오류를 반환합니다. 따라서 NFS4ERR\_MINOR\_VERS\_MISMATCH 오류는 다른 모든 오류보다 우선합니다.

서버는 첫 번째 적법한 작업\(OP\_ACCESS\)보다 작거나 마지막 적법한 작업\(OP\_RELEASE\_LOCKOWNER\)보다 큰 작업이 포함된 요청을 받을 수 있습니다. 이 경우 서버의 응답은 요청의 잘못된 opcode가 아닌 opcode OP\_ILLEGAL을 인코딩합니다. ILLEGAL 반환 결과의 상태 필드는 NFS4ERR\_OP\_ILLEGAL로 설정됩니다. COMPOUND 프로시저의 반환 결과도 NFS4ERR\_OP\_ILLEGAL입니다.

요청의 "태그" 정의는 구현자에게 달려 있습니다. 이는 패킷 스니퍼 및 엔지니어 디버깅 구현의 이점을 위해 복합 요청의 내용을 요약하는 데 사용될 수 있습니다. 그러나 응답의 "태그" 값은 요청에 제공된 값과 동일해야 합니다. 이는 CB\_COMPOUND 프로시저의 태그 필드에도 적용됩니다.\(SHOULD\)

---
##### **16.2.3.1.  Current Filehandle and Stateid**

COMPOUND 프로시저는 클라이언트가 지정한 작업 실행을 위한 간단한 환경을 제공합니다. 처음 두 개는 파일 핸들과 관련이 있고 두 번째 두 개는 현재 상태 ID와 관련이 있습니다.

---
###### **16.2.3.1.1.  Current Filehandle**

현재 및 저장된 파일 핸들은 프로토콜 전체에서 사용됩니다. 대부분의 작업은 암시적으로 현재 파일 핸들을 인수로 사용하며 많은 작업이 현재 파일 핸들을 결과의 일부로 설정합니다. 클라이언트가 지정한 작업 순서와 현재 및 저장된 파일 핸들 인수 및 결과를 결합하면 프로토콜 유연성이 향상됩니다. 현재 파일 핸들 사용법의 가장 좋고 가장 쉬운 예는 다음과 같은 순서입니다.

```text
         PUTFH fh1              {fh1}
         LOOKUP "compA"         {fh2}
         GETATTR                {fh2}
         LOOKUP "compB"         {fh3}
         GETATTR                {fh3}
         LOOKUP "compC"         {fh4}
         GETATTR                {fh4}
         GETFH

                                  Figure 2
```

이 예에서 PUTFH\(18.19절\) 작업은 현재 파일 핸들 값을 명시적으로 설정하는 반면, 각 LOOKUP 작업의 결과는 현재 파일 핸들 값을 결과 파일 시스템 개체로 설정합니다. 또한 클라이언트는 현재 파일 핸들을 인수로 사용하여 GETATTR 작업을 삽입할 수 있습니다.

PUTROOTFH\(섹션 18.21\) 및 PUTPUBFH\(섹션 18.20\) 작업도 현재 파일 핸들을 설정합니다. 위의 예에서는 동일한 효과를 얻기 위해 "PUTFH fh1"을 PUTROOTFH로 바꾸거나 파일 핸들 인수가 없는 PUTPUBFH로 바꿉니다\("compA"가 네임스페이스 루트 바로 아래에 있다는 가정하에\).

현재 파일핸들과 함께 저장된 파일핸들이 있습니다. 현재 파일 핸들은 LOOKUP과 같은 작업의 결과로 설정되지만 저장된 파일 핸들은 SAVEFH 작업을 사용하여 직접 설정해야 합니다. SAVEFH 작업은 현재 파일 핸들 값을 저장된 값으로 복사합니다. 저장된 파일 핸들 값은 LINK 및 RENAME 작업에 대한 현재 파일 핸들 값과 함께 사용됩니다. RESTOREFH 작업은 저장된 파일 핸들 값을 현재 파일 핸들 값으로 복사합니다. 결과적으로 저장된 파일 핸들 값은 클라이언트의 일련의 작업에 대한 일종의 "스크래치" 영역으로 사용될 수 있습니다.

---
###### **16.2.3.1.2.  Current Stateid**

NFSv4.1에서는 현재 stateid와 저장된 stateid가 COMPOUND 처리 환경에 추가되었습니다. 이를 통해 작업 간에 stateid를 전달할 수 있습니다. 프로토콜 구문에는 변경 사항이 없으며 몇 가지 작업의 의미만 변경됩니다.

"현재 상태 ID"는 현재 파일 핸들과 연결된 상태 ID입니다. 현재 stateid는 현재 파일 핸들을 수정하거나 stateid를 반환하는 작업에 의해서만 변경될 수 있습니다. 작업이 stateid를 반환하는 경우 현재 stateid를 반환된 값으로 설정해야 합니다. 작업이 현재 파일 핸들을 설정하지만 stateid를 반환하지 않는 경우 현재 stateid는 모두 0인 특수 stateid로 설정되어야 합니다\(예: \(seqid, other\) = \(0, 0\)\). 작업이 stateid를 인수로 사용하지만 stateid를 반환하지 않는 경우 현재 stateid를 변경해서는 안 됩니다. 예를 들어, PUTFH, PUTROOTFH 및 PUTPUBFH는 현재 서버 상태를 {ocfh, \(osid\)}에서 {cfh, \(0, 0\)}로 변경하고, LOCK은 현재 서버 상태를 {cfh, \(osid}\)에서 { cfh, \(nsid\)}. 현재 파일 핸들 및 구성 요소 이름을 새로운 현재 파일 핸들로 변환하는 LOOKUP과 같은 작업도 현재 상태를 {0, 0}으로 변경합니다. SAVEFH 및 RESTOREFH 작업은 현재 파일 핸들과 구성 요소 이름을 모두 저장하고 복원합니다. 현재 stateid를 세트로 합니다.\(MUST, MUST, MUST NOT\)

다음 예는 PUTFH가 현재 stateid를 \(0, 0\)으로 초기화함을 보여주는 일반 stateid를 사용한 간단한 READ 작업의 일반적인 경우입니다. stateid\(sid1\)를 사용한 후속 READ에서는 현재 stateid가 변경되지 않은 상태로 유지됩니다.

```text
       PUTFH fh1                             - -> {fh1, (0, 0)}
       READ (sid1), 0, 1024      {fh1, (0, 0)} -> {fh1, (0, 0)}

                                  Figure 3
```

다음 예에서는 루트 파일 핸들을 사용하여 OPEN을 수행하고 결과적으로 stateid\(sid1\)를 생성합니다. 다음 작업에서는 \(seqid, other\)가 \(1, 0\)과 같도록 설정된 stateid 인수로 READ를 지정하지만 이전 작업에서 설정된 현재 stateid는 작업이 평가될 때 실제로 사용됩니다. 이를 통해 잠재적으로 충돌할 수 있는 기존 잠금과의 올바른 상호 작용이 가능합니다.

```text
       PUTROOTFH                             - -> {fh1, (0, 0)}
       OPEN "compA"              {fh1, (0, 0)} -> {fh2, (sid1)}
       READ (1, 0), 0, 1024      {fh2, (sid1)} -> {fh2, (sid1)}
       CLOSE (1, 0)              {fh2, (sid1)} -> {fh2, (sid2)}

                                  Figure 4
```

다음 예는 LOCK 작업으로 생성된 stateid sid2를 다음 READ 작업에 전달하는 방법에서 두 번째 예와 유사합니다. 이를 통해 클라이언트는 단일 I/O 작업을 잠금 및 적절한 상태 ID로 명시적으로 둘러싸 다른 클라이언트 잠금과의 정확성을 보장할 수 있습니다. 또한 이 예에서는 SAVEFH 및 RESTOREFH가 파일 핸들 및 stateid를 저장하고 나중에 재사용하여 이를 현재 파일 핸들 및 stateid로 READ 작업에 전달하는 방법을 보여줍니다.

```text
       PUTFH fh1                             - -> {fh1, (0, 0)}
       LOCK 0, 1024, (sid1)      {fh1, (sid1)} -> {fh1, (sid2)}
       READ (1, 0), 0, 1024      {fh1, (sid2)} -> {fh1, (sid2)}
       LOCKU 0, 1024, (1, 0)     {fh1, (sid2)} -> {fh1, (sid3)}
       SAVEFH                    {fh1, (sid3)} -> {fh1, (sid3)}

       PUTFH fh2                 {fh1, (sid3)} -> {fh2, (0, 0)}
       WRITE (1, 0), 0, 1024     {fh2, (0, 0)} -> {fh2, (0, 0)}

       RESTOREFH                 {fh2, (0, 0)} -> {fh1, (sid3)}
       READ (1, 0), 1024, 1024   {fh1, (sid3)} -> {fh1, (sid3)}

                                  Figure 5
```

마지막 예는 현재 stateid의 사용이 허용되지 않는 것을 보여줍니다. 클라이언트는 익명의 특수 상태 ID\(0,0\)를 READ 작업에 암시적으로 전달하려고 합니다. 서버는 READ 작업에 대한 응답으로 NFS4ERR\_BAD\_STATEID를 반환해야 합니다.\(MUST\)

```text
       PUTFH fh1                             - -> {fh1, (0, 0)}
       READ (1, 0), 0, 1024      {fh1, (0, 0)} -> NFS4ERR_BAD_STATEID

                                  Figure 6
```

---
#### **16.2.4.  ERRORS**

물론 COMPOUND는 전방 채널의 각 작업이 반환할 수 있는 모든 오류를 반환합니다\(표 12 참조\). 그러나 COMPOUND가 0 작업을 반환하는 경우 분명히 COMPOUND에서 반환된 오류는 작업에서 반환된 오류와 아무 관련이 없습니다. COMPOUND가 제로 작업을 처리하는 경우 반환되는 오류 목록은 다음과 같습니다.

```text
    +==============================+==================================+
    | Error                        | Notes                            |
    +==============================+==================================+
    | NFS4ERR_BADCHAR              | The tag argument has a character |
    |                              | the replier does not support.    |
    +------------------------------+----------------------------------+
    | NFS4ERR_BADXDR               |                                  |
    +------------------------------+----------------------------------+
    | NFS4ERR_DELAY                |                                  |
    +------------------------------+----------------------------------+
    | NFS4ERR_INVAL                | The tag argument is not in UTF-8 |
    |                              | encoding.                        |
    +------------------------------+----------------------------------+
    | NFS4ERR_MINOR_VERS_MISMATCH  |                                  |
    +------------------------------+----------------------------------+
    | NFS4ERR_SERVERFAULT          |                                  |
    +------------------------------+----------------------------------+
    | NFS4ERR_TOO_MANY_OPS         |                                  |
    +------------------------------+----------------------------------+
    | NFS4ERR_REP_TOO_BIG          |                                  |
    +------------------------------+----------------------------------+
    | NFS4ERR_REP_TOO_BIG_TO_CACHE |                                  |
    +------------------------------+----------------------------------+
    | NFS4ERR_REQ_TOO_BIG          |                                  |
    +------------------------------+----------------------------------+

                      Table 15: COMPOUND Error Returns
```

---
## **17.  Operations: REQUIRED, RECOMMENDED, or OPTIONAL**

다음 표에는 NFSv4.1 프로토콜의 작업과 해당 지정\(REQUIRED, RECOMMENDED, OPTIONAL to Implement\) 또는 MUST NOT\(MUST NOT\) 지정이 요약되어 있습니다. MUST NOT 구현 지정은 NFSv4.0에 정의된 작업에 대해 예약되어 있으며 NFSv4.1에서는 구현하면 안 됩니다.\(MUST NOT, MUST NOT\)

대부분의 경우 클라이언트가 보낸 작업에 대한 REQUIRED, RECOMMENDED 또는 OPTIONAL 지정은 서버 구현을 위한 것입니다. 클라이언트는 일반적으로 클라이언트가 서비스를 제공하는 운영 환경에 필요한 작업을 구현해야 합니다. 예를 들어, 읽기 전용 NFSv4.1 클라이언트는 WRITE 작업을 구현할 필요가 없으며 그렇게 할 필요도 없습니다.\(MUST\)

서버에서 보낸 콜백 작업에 대한 REQUIRED 또는 OPTIONAL 지정은 클라이언트와 서버 모두에 대한 것입니다. 일반적으로 클라이언트에는 백채널을 생성하고 콜백 작업을 보내는 서버의 촉매제가 될 작업을 포어 채널에 보내는 옵션이 있습니다. 부분적인 예외는 CB\_RECALL\_SLOT입니다. 클라이언트가 이 작업 지원을 피할 수 있는 유일한 방법은 백채널을 생성하지 않는 것입니다.\(MUST\)

이는 작업 및 해당 지정에 대한 요약이므로 여기에 제시되지 않은 미묘한 부분이 있습니다. 따라서 구현 요구 사항에 대한 질문이 있는 경우 이 사양 내의 다른 관련 설명 텍스트와 함께 작업 설명 자체를 참조해야 합니다.

표의 두 번째 열과 세 번째 열에 사용된 약어는 다음과 같이 정의됩니다.

구현하려면 REQ가 필요합니다.\(MUST\)

REC 구현을 권장합니다.

구현하려면 선택사항입니다.\(MAY\)

```text
   MNI  MUST NOT implement
```

선택 사항인 NFSv4.1 기능의 경우 해당 기능을 지원하는 작업은 선택 사항이며 서버는 클라이언트의 해당 작업 사용에 대한 응답으로 NFS4ERR\_NOTSUPP를 반환합니다. 선택적 기능이 지원되는 경우 해당 기능과 관련된 일련의 작업을 구현하는 것이 필수가 될 수 있습니다. 표의 세 번째 열은 기능을 지정하고 해당 기능에 대한 지원이 있을 때 작업이 필수인지 선택인지 여부를 지정합니다.\(MAY, MUST, MUST\)

식별된 선택적 기능과 해당 약어는 다음과 같습니다.\(MAY\)

```text
   pNFS  Parallel NFS

   FDELG  File Delegations

   DDELG  Directory Delegations

    +======================+=============+============+===============+
    | Operation            | REQ, REC,   | Feature    | Definition    |
    |                      | OPT, or MNI | (REQ, REC, |               |
    |                      |             | or OPT)    |               |
    +======================+=============+============+===============+
    | ACCESS               | REQ         |            | Section 18.1  |
    +----------------------+-------------+------------+---------------+
    | BACKCHANNEL_CTL      | REQ         |            | Section 18.33 |
    +----------------------+-------------+------------+---------------+
    | BIND_CONN_TO_SESSION | REQ         |            | Section 18.34 |
    +----------------------+-------------+------------+---------------+
    | CLOSE                | REQ         |            | Section 18.2  |
    +----------------------+-------------+------------+---------------+
    | COMMIT               | REQ         |            | Section 18.3  |
    +----------------------+-------------+------------+---------------+
    | CREATE               | REQ         |            | Section 18.4  |
    +----------------------+-------------+------------+---------------+
    | CREATE_SESSION       | REQ         |            | Section 18.36 |
    +----------------------+-------------+------------+---------------+
    | DELEGPURGE           | OPT         | FDELG      | Section 18.5  |
    |                      |             | (REQ)      |               |
    +----------------------+-------------+------------+---------------+
    | DELEGRETURN          | OPT         | FDELG,     | Section 18.6  |
    |                      |             | DDELG,     |               |
    |                      |             | pNFS (REQ) |               |
    +----------------------+-------------+------------+---------------+
    | DESTROY_CLIENTID     | REQ         |            | Section 18.50 |
    +----------------------+-------------+------------+---------------+
    | DESTROY_SESSION      | REQ         |            | Section 18.37 |
    +----------------------+-------------+------------+---------------+
    | EXCHANGE_ID          | REQ         |            | Section 18.35 |
    +----------------------+-------------+------------+---------------+
    | FREE_STATEID         | REQ         |            | Section 18.38 |
    +----------------------+-------------+------------+---------------+
    | GETATTR              | REQ         |            | Section 18.7  |
    +----------------------+-------------+------------+---------------+
    | GETDEVICEINFO        | OPT         | pNFS (REQ) | Section 18.40 |
    +----------------------+-------------+------------+---------------+
    | GETDEVICELIST        | OPT         | pNFS (OPT) | Section 18.41 |
    +----------------------+-------------+------------+---------------+
    | GETFH                | REQ         |            | Section 18.8  |
    +----------------------+-------------+------------+---------------+
    | GET_DIR_DELEGATION   | OPT         | DDELG      | Section 18.39 |
    |                      |             | (REQ)      |               |
    +----------------------+-------------+------------+---------------+
    | LAYOUTCOMMIT         | OPT         | pNFS (REQ) | Section 18.42 |
    +----------------------+-------------+------------+---------------+
    | LAYOUTGET            | OPT         | pNFS (REQ) | Section 18.43 |
    +----------------------+-------------+------------+---------------+
    | LAYOUTRETURN         | OPT         | pNFS (REQ) | Section 18.44 |
    +----------------------+-------------+------------+---------------+
    | LINK                 | OPT         |            | Section 18.9  |
    +----------------------+-------------+------------+---------------+
    | LOCK                 | REQ         |            | Section 18.10 |
    +----------------------+-------------+------------+---------------+
    | LOCKT                | REQ         |            | Section 18.11 |
    +----------------------+-------------+------------+---------------+
    | LOCKU                | REQ         |            | Section 18.12 |
    +----------------------+-------------+------------+---------------+
    | LOOKUP               | REQ         |            | Section 18.13 |
    +----------------------+-------------+------------+---------------+
    | LOOKUPP              | REQ         |            | Section 18.14 |
    +----------------------+-------------+------------+---------------+
    | NVERIFY              | REQ         |            | Section 18.15 |
    +----------------------+-------------+------------+---------------+
    | OPEN                 | REQ         |            | Section 18.16 |
    +----------------------+-------------+------------+---------------+
    | OPENATTR             | OPT         |            | Section 18.17 |
    +----------------------+-------------+------------+---------------+
    | OPEN_CONFIRM         | MNI         |            | N/A           |
    +----------------------+-------------+------------+---------------+
    | OPEN_DOWNGRADE       | REQ         |            | Section 18.18 |
    +----------------------+-------------+------------+---------------+
    | PUTFH                | REQ         |            | Section 18.19 |
    +----------------------+-------------+------------+---------------+
    | PUTPUBFH             | REQ         |            | Section 18.20 |
    +----------------------+-------------+------------+---------------+
    | PUTROOTFH            | REQ         |            | Section 18.21 |
    +----------------------+-------------+------------+---------------+
    | READ                 | REQ         |            | Section 18.22 |
    +----------------------+-------------+------------+---------------+
    | READDIR              | REQ         |            | Section 18.23 |
    +----------------------+-------------+------------+---------------+
    | READLINK             | OPT         |            | Section 18.24 |
    +----------------------+-------------+------------+---------------+
    | RECLAIM_COMPLETE     | REQ         |            | Section 18.51 |
    +----------------------+-------------+------------+---------------+
    | RELEASE_LOCKOWNER    | MNI         |            | N/A           |
    +----------------------+-------------+------------+---------------+
    | REMOVE               | REQ         |            | Section 18.25 |
    +----------------------+-------------+------------+---------------+
    | RENAME               | REQ         |            | Section 18.26 |
    +----------------------+-------------+------------+---------------+
    | RENEW                | MNI         |            | N/A           |
    +----------------------+-------------+------------+---------------+
    | RESTOREFH            | REQ         |            | Section 18.27 |
    +----------------------+-------------+------------+---------------+
    | SAVEFH               | REQ         |            | Section 18.28 |
    +----------------------+-------------+------------+---------------+
    | SECINFO              | REQ         |            | Section 18.29 |
    +----------------------+-------------+------------+---------------+
    | SECINFO_NO_NAME      | REC         | pNFS file  | Section       |
    |                      |             | layout     | 18.45,        |
    |                      |             | (REQ)      | Section 13.12 |
    +----------------------+-------------+------------+---------------+
    | SEQUENCE             | REQ         |            | Section 18.46 |
    +----------------------+-------------+------------+---------------+
    | SETATTR              | REQ         |            | Section 18.30 |
    +----------------------+-------------+------------+---------------+
    | SETCLIENTID          | MNI         |            | N/A           |
    +----------------------+-------------+------------+---------------+
    | SETCLIENTID_CONFIRM  | MNI         |            | N/A           |
    +----------------------+-------------+------------+---------------+
    | SET_SSV              | REQ         |            | Section 18.47 |
    +----------------------+-------------+------------+---------------+
    | TEST_STATEID         | REQ         |            | Section 18.48 |
    +----------------------+-------------+------------+---------------+
    | VERIFY               | REQ         |            | Section 18.31 |
    +----------------------+-------------+------------+---------------+
    | WANT_DELEGATION      | OPT         | FDELG      | Section 18.49 |
    |                      |             | (OPT)      |               |
    +----------------------+-------------+------------+---------------+
    | WRITE                | REQ         |            | Section 18.32 |
    +----------------------+-------------+------------+---------------+

                            Table 16: Operations

    +=========================+=============+============+============+
    | Operation               | REQ, REC,   | Feature    | Definition |
    |                         | OPT, or MNI | (REQ, REC, |            |
    |                         |             | or OPT)    |            |
    +=========================+=============+============+============+
    | CB_GETATTR              | OPT         | FDELG      | Section    |
    |                         |             | (REQ)      | 20.1       |
    +-------------------------+-------------+------------+------------+
    | CB_LAYOUTRECALL         | OPT         | pNFS (REQ) | Section    |
    |                         |             |            | 20.3       |
    +-------------------------+-------------+------------+------------+
    | CB_NOTIFY               | OPT         | DDELG      | Section    |
    |                         |             | (REQ)      | 20.4       |
    +-------------------------+-------------+------------+------------+
    | CB_NOTIFY_DEVICEID      | OPT         | pNFS (OPT) | Section    |
    |                         |             |            | 20.12      |
    +-------------------------+-------------+------------+------------+
    | CB_NOTIFY_LOCK          | OPT         |            | Section    |
    |                         |             |            | 20.11      |
    +-------------------------+-------------+------------+------------+
    | CB_PUSH_DELEG           | OPT         | FDELG      | Section    |
    |                         |             | (OPT)      | 20.5       |
    +-------------------------+-------------+------------+------------+
    | CB_RECALL               | OPT         | FDELG,     | Section    |
    |                         |             | DDELG,     | 20.2       |
    |                         |             | pNFS (REQ) |            |
    +-------------------------+-------------+------------+------------+
    | CB_RECALL_ANY           | OPT         | FDELG,     | Section    |
    |                         |             | DDELG,     | 20.6       |
    |                         |             | pNFS (REQ) |            |
    +-------------------------+-------------+------------+------------+
    | CB_RECALL_SLOT          | REQ         |            | Section    |
    |                         |             |            | 20.8       |
    +-------------------------+-------------+------------+------------+
    | CB_RECALLABLE_OBJ_AVAIL | OPT         | DDELG,     | Section    |
    |                         |             | pNFS (REQ) | 20.7       |
    +-------------------------+-------------+------------+------------+
    | CB_SEQUENCE             | OPT         | FDELG,     | Section    |
    |                         |             | DDELG,     | 20.9       |
    |                         |             | pNFS (REQ) |            |
    +-------------------------+-------------+------------+------------+
    | CB_WANTS_CANCELLED      | OPT         | FDELG,     | Section    |
    |                         |             | DDELG,     | 20.10      |
    |                         |             | pNFS (REQ) |            |
    +-------------------------+-------------+------------+------------+

                       Table 17: Callback Operations
```

---
## **18.  NFSv4.1 Operations**
---
### **18.1.  Operation 3: ACCESS - Check Access Rights**
---
#### **18.1.1.  ARGUMENTS**

```text
   const ACCESS4_READ      = 0x00000001;
   const ACCESS4_LOOKUP    = 0x00000002;
   const ACCESS4_MODIFY    = 0x00000004;
   const ACCESS4_EXTEND    = 0x00000008;
   const ACCESS4_DELETE    = 0x00000010;
   const ACCESS4_EXECUTE   = 0x00000020;

   struct ACCESS4args {
           /* CURRENT_FH: object */
           uint32_t        access;
   };
```

---
#### **18.1.2.  RESULTS**

```text
   struct ACCESS4resok {
           uint32_t        supported;
           uint32_t        access;
   };

   union ACCESS4res switch (nfsstat4 status) {
    case NFS4_OK:
            ACCESS4resok   resok4;
    default:
            void;
   };
```

---
#### **18.1.3.  DESCRIPTION**

ACCESS는 RPC 요청의 자격 증명으로 식별된 사용자가 현재 파일 핸들에 지정된 파일 시스템 개체에 대해 갖는 액세스 권한을 결정합니다. 클라이언트는 비트 마스크 "액세스"에서 확인할 액세스 권한 집합을 인코딩합니다. 서버는 비트 마스크에 인코딩된 권한을 확인합니다. NFS4\_OK 상태가 반환되면 두 개의 비트 마스크가 응답에 포함됩니다. 첫 번째 "지원됨"은 서버가 안정적으로 확인할 수 있는 액세스 권한을 나타냅니다. 두 번째 "액세스"는 제공된 파일 핸들에 대해 사용자가 사용할 수 있는 액세스 권한을 나타냅니다. 성공하면 현재 파일 핸들이 해당 값을 유지합니다.

응답의 지원 및 액세스 필드에는 요청의 액세스 필드에 원래 설정된 것보다 더 많은 값이 포함되어서는 안 됩니다. 예를 들어 클라이언트가 ACCESS4\_READ 값만 설정된 ACCESS 작업을 보내고 서버가 이 값을 지원하는 경우 서버는 다른 값을 안정적으로 확인할 수 있었더라도 지원되는 필드에 ACCESS4\_READ 이상을 설정해서는 안 됩니다.\(MUST NOT, MUST NOT\)

응답의 액세스 필드에는 지원되는 필드보다 많은 값이 포함되어서는 안 됩니다.\(MUST NOT\)

이 작업의 결과는 본질적으로 권고 사항입니다. NFS4\_OK의 반환 상태와 비트 마스크에 설정된 적절한 비트는 향후 파일 시스템 개체에 대한 액세스가 허용된다는 의미는 아닙니다. 접근 권한은 언제든지 서버에 의해 철회될 수 있기 때문입니다.

다음과 같은 접근 권한을 요청할 수 있습니다.

ACCESS4\_READ 파일에서 데이터를 읽거나 디렉터리를 읽습니다.

ACCESS4\_LOOKUP 디렉토리에서 이름을 찾습니다\(디렉토리가 아닌 객체에는 의미 없음\).

ACCESS4\_MODIFY 기존 파일 데이터를 다시 쓰거나 기존 디렉터리 항목을 수정합니다.

ACCESS4\_EXTEND 새 데이터를 쓰거나 디렉터리 항목을 추가합니다.

ACCESS4\_DELETE 기존 디렉토리 항목을 삭제합니다.

ACCESS4\_EXECUTE 일반 파일을 실행합니다\(디렉토리에는 의미 없음\).

성공하면 현재 파일 핸들이 해당 값을 유지합니다.

ACCESS4\_EXECUTE는 NFS가 원격 실행이 아닌 원격 파일 액세스를 제공하기 때문에 구현하기 어려운 의미 체계입니다. 이로 인해 다음이 발생합니다.

\* 일반 파일의 실행 가능 여부는 서버가 아닌 NFS 클라이언트의 책임입니다. 그러나 ACCESS 작업은 겉보기에 서버가 해당 책임을 소유하도록 요구하도록 지정됩니다.

\* 클라이언트가 일반 파일을 실행할 때 서버에서 파일을 읽어야 합니다. 엄밀히 말하면 서버는 사용자에게 파일에 대한 읽기 권한이 없는 한 클라이언트가 실행 중인 파일을 읽는 것을 허용해서는 안 됩니다. NFS를 통해 실행 파일에 액세스하기 위해 실행 파일에 대한 명시적인 읽기 권한을 요구하는 것은 일부 사용자 및 스토리지 관리자에게 허용되지 않습니다. 역사적으로 NFS 서버는 사용자가 파일에 대한 실행 액세스 권한을 가지고 있는 경우 사용자가 파일을 읽을 수 있도록 허용했습니다.

실제적인 예로서, UNIX 사양 \[60\]에서는 UNIX 준수를 주장하는 구현이 일반 파일의 속성에 실행 권한 비트가 설정되지 않은 경우에도 권한이 있는 사용자가 실행 권한을 가지고 있음을 access\(\) 프로그래밍 인터페이스의 결과에 나타낼 수 있다고 명시합니다. . UNIX 사양에 대한 적합성을 주장하는 대신 해당 상황에서 실행 권한을 표시하지 않는 것이 가능하며 이는 일부 운영 환경에 해당됩니다. 클라이언트와 서버의 운영 환경이 권한 있는 사용자에 대한 access\(\) 의미 체계를 다르게 구현하고 클라이언트와 서버의 ACCESS 작업 구현이 각각의 access\(\) 의미 체계를 따른다고 가정합니다. 이로 인해 바람직하지 않은 동작이 발생할 수 있습니다.

\* 사용자에게 권한이 있고 일반 파일 속성에 실행 권한 비트가 설정되지 않은 경우 클라이언트의 access\(\) 인터페이스가 X\_OK를 반환하고 서버의 access\(\) 인터페이스가 이 상황에서 X\_OK를 반환하지 않는다고 가정합니다. 그러면 클라이언트는 비NFS 파일 시스템에 저장된 경우 실행될 수 있는 NFS 서버에 저장된 파일을 실행할 수 없게 됩니다.

\* 사용자에게 권한이 있고 일반 파일 속성에 실행 권한 비트가 설정되지 않은 경우 클라이언트의 access\(\) 인터페이스가 X\_OK를 반환하지 않고 서버의 access\(\) 인터페이스가 해당 상황에서 X\_OK를 반환한다고 가정합니다. 그 다음에:

- - 클라이언트의 실행 하위 시스템이 실행 권한 비트도 확인하지 않는 한 클라이언트는 비 NFS 파일 시스템에 저장된 경우 실행될 수 있는 NFS 서버에 저장된 파일을 실행할 수 있습니다.

- - 실행 하위 시스템이 실행 권한 비트를 확인하는 경우에도 잠재적인 문제가 더 많이 있습니다. 예를 들어, 클라이언트가 사용자의 "검색 경로"에 있는 모든 실행 파일의 "경로 검색 테이블"을 작성하기 위해 access\(\)를 호출한다고 가정합니다. 여기서 경로는 각각 실행 파일을 포함하는 디렉터리 목록입니다. 검색 경로의 별도 디렉터리에 각각 두 개의 파일이 있고 파일의 구성 요소 이름이 동일하다고 가정합니다. 첫 번째 디렉터리의 파일에는 실행 권한 비트가 설정되어 있지 않으며 두 번째 디렉터리의 파일에는 실행 비트가 설정되어 있습니다. 경로 검색 테이블은 첫 번째 디렉터리에 실행 파일이 있음을 나타내지만 실행 하위 시스템은 이를 실행하지 못합니다. 명령 셸이 두 번째 디렉터리의 두 번째 파일을 시도하지 못할 수 있습니다. 설사 그랬더라도 이는 잠재적인 성능 문제입니다. 분명히 클라이언트가 원하는 결과는 경로 검색 테이블에 첫 번째 파일이 포함되지 않는 것입니다.

위에서 설명한 문제를 해결하기 위해 "스마트 클라이언트, 바보 서버" 원칙이 사용됩니다. 클라이언트는 실행 액세스를 결정하는 전반적인 책임을 갖고 서버에 의존하여 파일의 모드, acl 및 dacl 속성 내에서 실행 권한을 구문 분석합니다. 클라이언트와 서버에 대한 규칙은 다음과 같습니다.

\* 클라이언트가 사용자가 파일을 읽을 수 있는지 확인하기 위해 ACCESS를 보내는 경우 클라이언트는 요청의 액세스 필드에 ACCESS4\_READ를 설정해야 합니다.\(SHOULD\)

\* 클라이언트의 운영 환경이 mode, acl 및 dacl 속성의 실행 권한에 따라 사용자에게 실행 액세스 권한이 있는 경우에만 사용자에게 실행을 허용하는 경우, 클라이언트가 실행 액세스 권한을 결정하려면 클라이언트는 ACCESS 요청을 보내야 합니다. 요청의 액세스 필드에 ACCESS4\_EXECUTE 비트가 설정되어 있습니다.\(SHOULD\)

\* 클라이언트의 운영 환경이 mode, acl, dacl 속성의 실행 권한에 따라 사용자에게 실행 액세스 권한이 없더라도 사용자에게 실행을 허용하는 경우, 클라이언트가 실행 액세스 권한을 결정하려면 ACCESS를 보내야 합니다. 요청의 액세스 필드에 ACCESS4\_EXECUTE 및 ACCESS4\_READ 비트가 모두 설정된 요청입니다. 이런 방식으로, 응답의 액세스 필드에 ACCESS4\_EXECUTE 및/또는 ACCESS4\_READ가 있는 것으로 표시된 대로 읽기 또는 실행 권한이 사용자에게 읽기 또는 실행 액세스를 부여하는 경우\(또는 서버가 사용자에게 권한이 있는 것으로 해석하는 경우\) 클라이언트는 다음을 수행할 수 있습니다. 사용자에게 파일에 대한 실행 액세스 권한을 부여합니다.\(SHOULD\)

\* 서버가 실행 권한 비트 또는 실행 가능성을 표시하기 위한 다른 방법\(예: 파일 이름의 접미사가 실행을 나타낼 수 있음\)을 지원하는 경우 응답 여부를 결정할 때 읽기 권한이 아닌 실행 권한만 확인해야 합니다. 액세스 필드에 ACCESS4\_EXECUTE가 설정되어 있습니다. 서버는 응답의 액세스 필드에 ACCESS4\_EXECUTE가 설정되어 있는지 여부를 결정할 때 읽기 권한 비트도 검사해서는 안 됩니다. 서버의 운영 환경이 사용자에게 실행 액세스 권한을 부여하더라도\(예: 사용자에게 권한이 있음\), 모드에 실행 권한 비트가 하나 이상 설정된 경우를 제외하고 서버는 응답 액세스 필드에 ACCESS4\_EXECUTE 세트로 응답해서는 안 됩니다\(MUST NOT\). 또는 dacl 속성. acl 및 dacl의 경우 "1개의 실행 권한 비트"는 ALLOW ACE에 설정된 ACE4\_EXECUTE 비트여야 합니다.\(MUST, MUST NOT, MUST NOT, MUST\)

\* 서버가 실행 권한 비트 또는 실행 가능성을 표시하기 위한 다른 방법을 지원하지 않는 경우 응답의 지원 및 액세스 필드에 ACCESS4\_EXECUTE를 설정해서는 안 됩니다. 클라이언트가 ACCESS 요청의 액세스 필드에 ACCESS4\_EXECUTE를 설정하고 ACCESS4\_EXECUTE가 응답의 지원 필드에 설정되지 않은 경우 클라이언트는 요청의 액세스 필드에 ACCESS4\_READ 비트가 설정된 ACCESS 요청을 보내야 합니다.\(MUST NOT\)

\* 서버가 읽기 권한 비트를 지원하는 경우 액세스 필드에 ACCESS4\_READ가 설정된 ACCESS 요청을 수신할 때 모드, acl 및 dacl 속성의 읽기 권한만 확인해야 합니다. 서버는 또한 응답의 액세스 필드에 ACCESS4\_READ가 설정되어 있는지 여부를 결정할 때 실행 권한 비트를 검사해서는 안 됩니다.\(MUST, MUST NOT\)

ACCESS 응답에 ACCESS4\_READ 또는 ACCESS\_EXECUTE가 설정된 경우 사용자는 파일을 OPEN\(섹션 18.16\) 또는 READ\(섹션 18.22\)할 수 있는 권한도 갖습니다. 즉, 클라이언트가 액세스 필드에 ACCESS4\_READ 및 ACCESS\_EXECUTE가 설정된 ACCESS 요청\(또는 두 개의 별도 요청, ACCESS4\_READ가 설정된 요청과 ACCESS4\_EXECUTE가 설정된 요청\)을 보내고 응답의 액세스 필드에 ACCESS4\_EXECUTE가 설정된 경우 \(또는 단 하나의 응답에 ACCESS4\_EXECUTE가 설정되어 있는 경우\) 사용자는 파일을 열거나 읽을 수 있는 권한을 갖습니다.

---
#### **18.1.4.  IMPLEMENTATION**

일반적으로 클라이언트가 파일 속성의 uid, gid 및 mode 필드를 검사하거나 ACL 속성의 내용을 해석하여 액세스 권한을 추론하는 것만으로는 충분하지 않습니다. 이는 서버가 uid 또는 gid 매핑을 수행하거나 추가 액세스 제어 제한을 시행할 수 있기 때문입니다. 서버가 클라이언트와 동일한 ID 공간에 있지 않을 수도 있습니다. 이러한 경우\(및 기타 경우\) 클라이언트는 현재 파일 속성만으로는 액세스 확인을 안정적으로 수행할 수 없습니다.

NFSv2 프로토콜에서 작업 허용 여부를 확인하는 신뢰할 수 있는 유일한 방법은 작업을 시도하여 성공했는지 실패했는지 확인하는 것이었습니다. NFSv4.1 프로토콜의 ACCESS 작업을 사용하여 클라이언트는 하나 이상의 작업 클래스가 허용되는지 여부를 나타내도록 서버에 요청할 수 있습니다. ACCESS 작업은 클라이언트가 액세스 실패를 초래하는 일련의 작업을 수행하기 전에 확인할 수 있도록 제공됩니다. OPEN 작업은 서버가 파일 개체에 대한 액세스를 확인할 수 있는 지점과 해당 정보를 클라이언트에 반환하는 방법을 제공합니다. ACCESS 작업은 디렉토리 작업이나 UNIX 인터페이스 access\(\)가 클라이언트에서 사용되는 경우에 여전히 유용합니다.

ACCESS 호출에 대한 응답으로 서버가 반환한 정보는 영구적이지 않습니다. 서버가 검사를 수행한 정확한 시간에는 정확했지만 이후에는 반드시 그런 것은 아닙니다. 서버는 언제든지 접근권한을 철회할 수 있습니다.

클라이언트는 액세스 권한을 결정하는 데 사용되는 ACCESS 요청에 인증 정보를 구축하기 위해 사용자의 유효한 자격 증명을 사용해야 합니다. 후속 읽기 및 쓰기 작업에 사용되는 유효 사용자 및 그룹 자격 증명입니다.

많은 구현에서는 ACCESS4\_DELETE 권한을 직접 지원하지 않습니다. UNIX와 같은 운영 체제는 디렉터리가 아닌 개체에 대한 액세스 요청에 설정된 경우 ACCESS4\_DELETE 비트를 무시합니다. 이러한 시스템에서 파일에 대한 삭제 권한은 파일 자체의 권한에 의해 결정되는 대신 파일이 있는 디렉터리에 대한 액세스 권한에 따라 결정됩니다. 따라서 확인할 수 있는 액세스 권한을 열거하는 반환된 마스크의 ACCESS4\_DELETE 값은 0으로 설정됩니다. 이는 서버가 해당 특정 액세스 권한을 확인할 수 없음을 클라이언트에 나타냅니다. 반환된 액세스 마스크의 ACCESS4\_DELETE 비트는 클라이언트에서 무시됩니다.

---
### **18.2.  Operation 4: CLOSE - Close File**
---
#### **18.2.1.  ARGUMENTS**

```text
   struct CLOSE4args {
           /* CURRENT_FH: object */
           seqid4          seqid;
           stateid4        open_stateid;
   };
```

---
#### **18.2.2.  RESULTS**

```text
   union CLOSE4res switch (nfsstat4 status) {
    case NFS4_OK:
            stateid4       open_stateid;
    default:
            void;
   };
```

---
#### **18.2.3.  DESCRIPTION**

CLOSE 작업은 현재 파일 핸들에 지정된 대로 일반 또는 명명된 속성 파일에 대한 공유 예약을 해제합니다. 이 CLOSE의 결과로 서버에 공개된 공유 예약 및 기타 상태 정보는 제공된 stateid와 관련된 정보뿐입니다. 다른 OPEN과 연관된 상태는 영향을 받지 않습니다.

바이트 범위 잠금이 유지되면 클라이언트는 CLOSE를 보내기 전에 모든 잠금을 해제해야 합니다. 서버는 CLOSE 시 미해결 잠금을 모두 해제할 수 있지만 일부 서버는 여전히 바이트 범위 잠금이 유지된 파일의 CLOSE를 지원하지 않을 수 있습니다. CLOSE 이후 잠금이 존재하는 경우 서버는 실패를 반환해야 합니다.\(SHOULD, MAY, MUST\)

seqid 인수는 임의의 값을 가질 수 있으며 서버는 seqid를 무시해야 합니다\(MUST\).\(MUST\)

성공하면 현재 파일 핸들이 해당 값을 유지합니다.

서버는 주체, 보안 특성 및 적용 가능한 경우 OPEN 요청을 보낸 GSS 메커니즘의 조합이 파일을 닫는 것이기도 하도록 요구할 수 있습니다. 주체에 대한 자격 증명을 더 이상 사용할 수 없는 경우 이는 불가능할 수 있습니다. 서버는 CLOSE를 전송하기 위해 컴퓨터 자격 증명 또는 SSV 자격 증명\(섹션 18.35 참조\)을 허용할 수 있습니다.\(MAY, MAY\)

---
#### **18.2.4.  IMPLEMENTATION**

CLOSE가 stateid를 반환하더라도 이 stateid는 클라이언트에 유용하지 않으며 더 이상 사용되지 않는 것으로 처리되어야 합니다. CLOSE는 단일 개방 소유자에 의한 파일의 모든 OPEN과 연관된 상태를 "종료"합니다. 위에서 언급한 것처럼 CLOSE는 모든 파일 잠금 상태를 해제하거나 오류를 반환합니다. 따라서 CLOSE에서 반환된 stateid는 후속 작업에 유용하지 않습니다. 클라이언트가 이 stateid를 사용하는 것을 찾는 데 도움을 주기 위해 서버는 유효하지 않은 특수 stateid를 반환해야 합니다\("other" 값은 0이고 "seqid" 필드는 NFS4\_UINT32\_MAX입니다. 섹션 8.2.3 참조\).\(SHOULD\)

CLOSE 작업을 통해 이전에는 허용되지 않았던 위임을 허용할 수 있습니다. 서버는 보류 중인 위임 요청이 있는 경우 즉시 응답하도록 선택하거나 나중에 상황에 응답할 수 있습니다.

---
### **18.3.  Operation 5: COMMIT - Commit Cached Data**
---
#### **18.3.1.  ARGUMENTS**

```text
   struct COMMIT4args {
           /* CURRENT_FH: file */
           offset4         offset;
           count4          count;
   };
```

---
#### **18.3.2.  RESULTS**

```text
   struct COMMIT4resok {
           verifier4       writeverf;
   };

   union COMMIT4res switch (nfsstat4 status) {
    case NFS4_OK:
            COMMIT4resok   resok4;
    default:
            void;
   };
```

---
#### **18.3.3.  DESCRIPTION**

COMMIT 작업은 커밋되지 않은 수정된 데이터를 현재 파일 핸들에 지정된 파일에 대한 안정적인 저장소로 강제 실행하거나 플러시합니다. 플러시된 데이터는 결과 필드의 "커밋된" 필드가 UNSTABLE4로 설정된 하나 이상의 WRITE 작업을 통해 이전에 작성된 데이터입니다.

오프셋은 플러시가 시작될 파일 내의 위치를 ​​지정합니다. 오프셋 값 0은 파일 시작 부분부터 데이터를 플러시한다는 의미입니다. 개수는 플러시할 데이터의 바이트 수를 지정합니다. 개수가 0이면 오프셋에서 파일 끝까지 플러시가 수행됩니다.

서버는 COMMIT가 성공적으로 완료되면 쓰기 검증자를 반환합니다. 쓰기 검증자는 클라이언트가 초기 WRITE 작업과 COMMIT 사이에 서버가 다시 시작되었는지 확인하는 데 사용됩니다. 클라이언트는 초기 WRITE 작업에서 반환된 쓰기 검증자와 COMMIT 작업에서 반환된 검증자를 비교하여 이를 수행합니다. 서버는 커밋되지 않은 데이터의 손실을 초래할 수 있는 각 서버 이벤트 또는 인스턴스화에서 쓰기 검증자의 값을 변경해야 합니다. 가장 일반적으로 이는 서버가 다시 시작될 때 발생합니다. 그러나 서버의 다른 이벤트로 인해 커밋되지 않은 데이터가 손실될 수도 있습니다.

성공하면 현재 파일 핸들이 해당 값을 유지합니다.

---
#### **18.3.4.  IMPLEMENTATION**

COMMIT 작업은 파일 상태를 디스크와 동기화하는 POSIX fsync\(\) \[22\] 시스템 인터페이스와 작업 및 의미가 유사합니다\(파일 데이터 및 메타데이터가 디스크 또는 안정적인 저장소에 플러시됩니다\). COMMIT는 클라이언트에 대해 동일한 작업을 수행하여 서버의 동기화되지 않은 데이터와 메타데이터를 서버의 디스크나 지정된 파일에 대한 안정적인 저장소로 플러시합니다. fsync\(\)와 마찬가지로 일부 수정된 데이터가 있거나 동기화할 수정된 데이터가 없을 수 있습니다. 데이터는 서버의 일반적인 주기적인 버퍼 동기화 활동에 의해 동기화되었을 수 있습니다. COMMIT는 예상치 못한 오류가 발생하지 않는 한 NFS4\_OK를 반환해야 합니다.

COMMIT는 클라이언트가 파일 범위를 플러시할 수 있다는 점에서 fsync\(\)와 다릅니다\(대개 파일이 완전히 기록되기 전에 클라이언트의 버퍼 재확보 방식에 의해 트리거될 가능성이 높습니다\).

COMMIT의 서버 구현은 비교적 간단합니다. 서버가 전체 파일 COMMIT 요청을 수신하는 경우, 즉 오프셋 0에서 시작하여 개수 0인 경우 전체 파일에 fsync\(\)를 적용하는 것과 동일한 작업을 수행해야 합니다. 그렇지 않은 경우 오프셋 및 개수로 지정된 범위의 수정된 데이터가 안정적인 저장소로 플러시되도록 준비해야 합니다. 두 경우 모두 파일과 관련된 모든 메타데이터를 반환하기 전에 안정적인 저장소로 플러시해야 합니다. 서버에 플러시할 항목이 없는 것은 오류가 아닙니다. 이는 플러시해야 하는 데이터와 메타데이터가 마지막 서버 오류 중에 이미 플러시되었거나 손실되었음을 의미합니다.

COMMIT의 클라이언트 구현은 좀 더 복잡합니다. 클라이언트 버퍼를 안정적인 저장소에 커밋하려는 데에는 두 가지 이유가 있습니다. 첫 번째는 클라이언트가 버퍼를 재사용하기를 원한다는 것입니다. 이 경우 COMMIT 요청을 통해 버퍼의 오프셋과 개수가 서버로 전송됩니다. 그런 다음 서버는 오프셋 및 개수를 기반으로 수정된 데이터를 플러시하고 파일과 관련된 수정된 메타데이터를 플러시합니다. 그런 다음 플러시 및 쓰기 확인자의 상태를 반환합니다. 클라이언트가 COMMIT를 생성하는 두 번째 이유는 닫을 때 수행될 수 있는 전체 파일 플러시를 위한 것입니다. 이 경우 클라이언트는 커밋되지 않은 데이터가 포함된 이 파일에 대한 모든 버퍼를 수집하고 오프셋 0과 개수 0으로 COMMIT 작업을 수행한 다음 해당 버퍼를 모두 해제합니다. 다른 더티 버퍼는 일반적인 방식으로 서버로 전송됩니다.

WRITE 결과에서 UNSTABLE4로 설정된 "committed" 필드를 사용하여 클라이언트가 버퍼를 쓴 후\(WRITE 작업을 통해\) 해당 버퍼는 COMMIT 작업을 통해 플러시될 때까지 클라이언트에 의해 수정된 것으로 간주되어야 합니다. 또는 결과의 "커밋된" 필드가 FILE\_SYNC4 또는 DATA\_SYNC4로 설정된 WRITE 작업을 통해 작성됩니다. 이는 데이터가 서버의 안정적인 저장소로 플러시되기 전에 버퍼가 해제되어 재사용되는 것을 방지하기 위해 수행됩니다.

WRITE 또는 COMMIT 작업에서 응답이 반환되고 서버에서 이전에 반환한 것과 다른 쓰기 검증자가 포함된 경우 클라이언트는 커밋되지 않은 데이터가 포함된 모든 버퍼를 서버에 다시 전송해야 합니다. 이를 수행하는 방법은 구현자에게 달려 있습니다. 관심 있는 버퍼가 하나만 있는 경우 FILE\_SYNC4 안정적인 매개변수를 사용하여 WRITE 요청으로 전송해야 합니다. 버퍼가 두 개 이상인 경우 stable 매개변수를 UNSTABLE4로 설정하여 WRITE 작업에서 모든 버퍼를 재전송한 다음 COMMIT 작업을 재전송하여 서버의 모든 데이터를 안정적인 저장소로 플러시하는 것이 좋습니다. 그러나 서버가 WRITE에서 반환된 것과 다른 검증기를 COMMIT에서 반복적으로 반환하는 경우 진행을 ​​보장하는 유일한 방법은 FILE\_SYNC4 안정적인 매개변수를 사용하여 WRITE 요청으로 모든 버퍼를 재전송하는 것입니다.

위의 설명은 버퍼 캐시 기반 시스템뿐만 아니라 페이지 캐시 기반 시스템에도 적용됩니다. 이전 시스템에서는 버퍼 캐시 대신 가상 메모리 시스템을 수정해야 합니다.

---
### **18.4.  Operation 6: CREATE - Create a Non-Regular File Object**
---
#### **18.4.1.  ARGUMENTS**

```text
   union createtype4 switch (nfs_ftype4 type) {
    case NF4LNK:
            linktext4 linkdata;
    case NF4BLK:
    case NF4CHR:
            specdata4 devdata;
    case NF4SOCK:
    case NF4FIFO:
    case NF4DIR:
            void;
    default:
            void;  /* server should return NFS4ERR_BADTYPE */
   };

   struct CREATE4args {
           /* CURRENT_FH: directory for creation */
           createtype4     objtype;
           component4      objname;
           fattr4          createattrs;
   };
```

---
#### **18.4.2.  RESULTS**

```text
   struct CREATE4resok {
           change_info4    cinfo;
           bitmap4         attrset;        /* attributes set */
   };

   union CREATE4res switch (nfsstat4 status) {
    case NFS4_OK:
            /* new CURRENTFH: created object */
            CREATE4resok resok4;
    default:
            void;
   };
```

---
#### **18.4.3.  DESCRIPTION**

CREATE 작업은 지정된 이름을 가진 디렉터리에 일반 파일이 아닌 파일 개체를 생성합니다. OPEN 작업은 일반 파일이나 명명된 속성을 생성하는 데 사용해야 합니다.\(MUST\)

현재 파일 핸들은 디렉토리\(NF4DIR 유형의 객체\)여야 합니다. 현재 파일 핸들이 속성 디렉터리\(NF4ATTRDIR 유형\)인 경우 NFS4ERR\_WRONG\_TYPE 오류가 반환됩니다. 현재 파일 핸들이 다른 유형의 객체를 지정하면 NFS4ERR\_NOTDIR 오류가 발생합니다.

objname은 새 개체의 이름을 지정합니다. objtype은 생성될 객체의 유형\(디렉토리, 심볼릭 링크 등\)을 결정합니다. 지정된 객체 유형이 일반 파일, 명명된 속성 또는 명명된 속성 디렉토리인 경우 NFS4ERR\_BADTYPE 오류가 발생합니다.

동일한 이름의 개체가 디렉터리에 이미 존재하는 경우 서버는 NFS4ERR\_EXIST 오류를 반환합니다.

새 파일 객체가 생성된 디렉터리에 대해 서버는 cinfo에change\_info4 정보를 반환합니다. Change\_info4 데이터 유형의 원자 필드를 사용하면 서버는 파일 객체 생성과 관련하여 변경 전후 속성이 원자적으로 획득되었는지 여부를 나타냅니다.

objname의 길이가 0이거나 objname이 UTF-8 정의를 따르지 않는 경우 NFS4ERR\_INVAL 오류가 반환됩니다.

현재 파일 핸들이 새 객체의 파일 핸들로 대체됩니다.

createattrs는 객체의 초기 속성 세트를 지정합니다. 속성 세트에는 객체 유형에 유효한 쓰기 가능한 속성이 포함될 수 있습니다. 작업이 성공하면 서버는 객체에 대해 어떤 속성이 성공적으로 설정되었는지 나타내는 속성 마스크를 클라이언트에 반환합니다.

createattrs에 소유자 속성이나 소유자에 대한 ACE가 있는 ACL이 포함되어 있지 않고 서버의 파일 시스템이 소유자 속성\(또는 소유자 ACE\)을 지원하고 요구하는 경우 서버는 소유자\(또는 소유자 ACE\)를 파생해야 합니다. . 이는 일반적으로 호출의 RPC 자격 증명에 표시된 주체에서 나오지만 서버의 운영 환경이나 파일 시스템 의미에 따라 다른 파생 방법이 필요할 수 있습니다. 마찬가지로 createattrs에 그룹 속성이나 그룹 ACE가 모두 포함되지 않고 서버의 파일 시스템이 그룹 속성\(또는 그룹 ACE\)의 개념을 지원하고 요구하는 경우 서버는 그룹 속성\(또는 해당 소유자 ACE\)을 파생해야 합니다. 파일을 위해. 이는 자격 증명에 포함된 경우 그룹 주체\(예: AUTH\_SYS\)와 같은 RPC 호출의 자격 증명, 자격 증명의 주체와 연결된 그룹 식별자\(예: POSIX 시스템에는 다음과 같은 사용자 데이터베이스가 있습니다\[23\]\). 모든 사용자 식별자에 대한 그룹 식별자를 가집니다. 개체가 생성된 디렉터리나 서버의 운영 환경이나 파일 시스템 의미에 따라 지정되는 모든 항목에서 상속됩니다. 이는 OPEN 작업에도 적용됩니다.\(MUST, MUST\)

반대로 클라이언트가 RPC 호출의 자격 증명에 파일을 생성할 권한이 없음을 나타내는 주체가 소유자 속성, 그룹 속성 또는 ACL을 createattrs에 지정할 가능성이 있습니다. 이 인스턴스에서 반환되는 오류는 NFS4ERR\_PERM입니다. 이는 OPEN 작업에도 적용됩니다.

현재 파일 핸들이 다른 클라이언트가 디렉터리 위임을 보유한 디렉터리를 지정하는 경우 알림을 보내 상황을 해결할 수 있는 위임이 아닌 한 위임을 반드시 회수해야 하며 CREATE 작업은 위임이 완료될 때까지 진행해서는 안 됩니다. 반환되거나 취소됩니다. 매우 빠르게 발생하는 경우를 제외하고 위임이 미해결 상태로 유지되는 동안 요청에 하나 이상의 NFS4ERR\_DELAY 오류가 반환됩니다.\(MUST NOT\)

현재 파일 핸들이 하나 이상의 디렉터리 위임이 존재하는 디렉터리를 지정하면 해당 위임이 그러한 알림을 요청할 때 이 작업의 결과로 NOTIFY4\_ADD\_ENTRY가 생성됩니다.

FSCHARSET\_CAP4\_ALLOWS\_ONLY\_UTF8 기능이 설정되고\(14.4절\) 심볼릭 링크가 생성되는 경우 심볼릭 링크의 내용은 UTF-8 인코딩이어야 합니다.\(MUST\)

---
#### **18.4.4.  IMPLEMENTATION**

클라이언트가 생성 후에 속성 값을 설정하려는 경우 적절한 속성이 설정되도록 SETATTR 작업을 COMPOUND 요청에 추가할 수 있습니다.

---
### **18.5.  Operation 7: DELEGPURGE - Purge Delegations Awaiting Recovery**
---
#### **18.5.1.  ARGUMENTS**

```text
   struct DELEGPURGE4args {
           clientid4       clientid;
   };
```

---
#### **18.5.2.  RESULTS**

```text
   struct DELEGPURGE4res {
           nfsstat4        status;
   };
```

---
#### **18.5.3.  DESCRIPTION**

이 작업은 특정 클라이언트에 대한 복구를 기다리는 모든 위임을 제거합니다. 이는 위임 정보 복구를 기다리는 서버에서 충돌하는 요청을 지연시킬 필요가 없음을 나타내기 위해 위임 정보를 안정적인 저장소에 커밋하지 않는 클라이언트에 유용합니다.

클라이언트는 요청의 clientid 필드로 지정되지 않습니다. 클라이언트는 client 필드를 0으로 설정해야 하며, 서버는 clientid 필드를 무시해야 합니다. 대신, 서버는 COMPOUND 요청에서 DELEGPURGE 앞에 오는 SEQUENCE 작업 인수의 세션 ID 값에서 클라이언트 ID를 파생해야 합니다.\(MUST, MUST\)

DELEGPURGE 작업은 클라이언트의 안정적인 저장소에 위임 정보를 기록하는 클라이언트에서 사용해야 합니다. 이 경우 클라이언트는 알고 있는 모든 위임을 복구한 후 즉시 DELEGPURGE 작업을 보내야 합니다. 이렇게 하면 클라이언트에 대한 추가 위임이 복구되지 않음을 서버에 알리므로 리소스를 확보할 수 있으며, 복구되지 않은 위임과 충돌하는 요청을 만드는 다른 클라이언트의 지연을 방지할 수 있습니다. 서버와 클라이언트에 알려진 위임 세트는 다를 수 있습니다. 그 이유는 위임이 발생한 요청을 보낸 후 클라이언트가 위임을 수신하고 클라이언트의 안정적인 저장소에 위임을 커밋하기 전에 오류가 발생할 수 있기 때문입니다.

서버는 DELEGPURGE를 지원할 수 있지만 그렇지 않은 경우 CLAIM\_DELEGATE\_PREV를 지원해서는 안 되며 CLAIM\_DELEG\_PREV\_FH를 지원해서는 안 됩니다.\(MUST NOT\)

---
### **18.6.  Operation 8: DELEGRETURN - Return Delegation**
---
#### **18.6.1.  ARGUMENTS**

```text
   struct DELEGRETURN4args {
           /* CURRENT_FH: delegated object */
           stateid4        deleg_stateid;
   };
```

---
#### **18.6.2.  RESULTS**

```text
   struct DELEGRETURN4res {
           nfsstat4        status;
   };
```

---
#### **18.6.3.  DESCRIPTION**

DELEGRETURN 작업은 현재 파일 핸들 및 stateid로 표시되는 위임을 반환합니다.

위임은 자발적으로\(즉, 서버가 이를 회수하기 전\) 또는 회수될 때 반환될 수 있습니다. 두 경우 모두 클라이언트는 위임을 반환하기 전에 위임 컨텍스트에 따라 변경된 상태를 서버에 올바르게 전파해야 합니다.

서버는 위임을 획득한 주체, 보안 특성 및 적용 가능한 경우 GSS 메커니즘 조합이 파일에 DELEGRETURN을 보내는 것일 것을 요구할 수 있습니다. 주체에 대한 자격 증명을 더 이상 사용할 수 없는 경우 이는 불가능할 수 있습니다. 서버는 DELEGRETURN을 전송하기 위해 기계 자격 증명 또는 SSV 자격 증명\(섹션 18.35 참조\)을 허용할 수 있습니다.\(MAY, MAY\)

---
### **18.7.  Operation 9: GETATTR - Get Attributes**
---
#### **18.7.1.  ARGUMENTS**

```text
   struct GETATTR4args {
           /* CURRENT_FH: object */
           bitmap4         attr_request;
   };
```

---
#### **18.7.2.  RESULTS**

```text
   struct GETATTR4resok {
           fattr4          obj_attributes;
   };

   union GETATTR4res switch (nfsstat4 status) {
    case NFS4_OK:
            GETATTR4resok  resok4;
    default:
            void;
   };
```

---
#### **18.7.3.  DESCRIPTION**

GETATTR 작업은 현재 파일 핸들에 지정된 파일 시스템 개체에 대한 속성을 가져옵니다. 클라이언트는 서버가 반환할 각 속성 값에 대해 비트맵 인수에 비트를 설정합니다. 서버는 반환할 수 있었던 속성 값을 나타내는 속성 비트맵을 반환합니다. 여기에는 대상 파일 시스템에 대해 서버가 지원하는 속성인 클라이언트가 요청한 모든 속성이 포함됩니다. 이 비트맵 뒤에는 가장 낮은 속성 번호부터 속성 값이 순서대로 옵니다.

서버는 대상 파일 시스템에 대해 서버에서 속성을 지원하는 경우 클라이언트가 요청하는 각 속성에 대한 값을 반환해야 합니다\(MUST\). 서버가 대상 파일 시스템의 특정 속성을 지원하지 않는 경우에는 속성 값을 반환해서는 안 되며 결과 비트맵에 속성 비트를 설정해서는 안 됩니다. 서버는 대상의 속성을 지원하지만 해당 값을 얻을 수 없는 경우 오류를 반환해야 합니다. 이 경우 속성 값이 반환되지 않습니다.\(MUST, MUST NOT, MUST\)

이전에 파일 시스템이 있었을 때 더 많은 속성이 지원되었더라도 없는 파일 시스템은 섹션 11.4.1에 설명된 대로 매우 작은 속성 집합을 지원하는 것으로 처리되어야 합니다.

모든 서버는 존재하지 않는 파일 시스템을 제외하고 모든 파일 시스템에 대해 섹션 5.6에 지정된 대로 REQUIRED 속성을 지원해야 합니다.\(MUST\)

성공하면 현재 파일 핸들이 해당 값을 유지합니다.

---
#### **18.7.4.  IMPLEMENTATION**

문제의 파일에 대해 다른 클라이언트가 보유한 OPEN\_DELEGATE\_WRITE 위임이 있고 크기 및/또는 변경 사항이 조사되는 속성 집합에 있다고 가정합니다. 서버에는 두 가지 선택이 있습니다. 첫째, 서버는 CB\_GETATTR 콜백을 사용하여 위임을 보유한 클라이언트로부터 이러한 속성의 실제 현재 값을 얻을 수 있습니다. 둘째, 서버는 특히 위임된 클라이언트가 응답하지 않을 때 문제의 위임을 회수할 수 있습니다. GETATTR은 다음 중 하나가 발생할 때까지 진행되어서는 안 됩니다.\(MUST NOT\)

\* 요청된 속성 값은 CB\_GETATTR에 대한 응답으로 반환됩니다.

\* OPEN\_DELEGATE\_WRITE 위임이 반환됩니다.

\* OPEN\_DELEGATE\_WRITE 위임이 취소됩니다.

위 중 하나가 매우 빠르게 발생하지 않는 한 위임이 처리되지 않는 동안 하나 이상의 NFS4ERR\_DELAY 오류가 반환됩니다.

---
### **18.8.  Operation 10: GETFH - Get Current Filehandle**
---
#### **18.8.1.  ARGUMENTS**

```text
   /* CURRENT_FH: */
   void;
```

---
#### **18.8.2.  RESULTS**

```text
   struct GETFH4resok {
           nfs_fh4         object;
   };

   union GETFH4res switch (nfsstat4 status) {
    case NFS4_OK:
           GETFH4resok     resok4;
    default:
           void;
   };
```

---
#### **18.8.3.  DESCRIPTION**

이 작업은 현재 파일 핸들 값을 반환합니다.

성공하면 현재 파일 핸들이 해당 값을 유지합니다.

섹션 2.10.6.4에 설명된 대로 GETFH는 특정 작업을 즉시 따르도록 요구되거나 권장되며, 클라이언트가 요청에 RECOMMENDED로 GETFH를 삽입하지 못한 경우 서버는 그러한 작업을 자유롭게 거부할 수 있습니다. 섹션 18.16.4.1은 왜 GETFH가 OPEN을 따라야 하는지에 대한 추가적인 정당성을 제공합니다.\(MUST, MUST\)

---
#### **18.8.4.  IMPLEMENTATION**

LOOKUP 또는 CREATE와 같이 현재 파일 핸들을 변경하는 작업은 결과적으로 새 파일 핸들을 자동으로 반환하지 않습니다. 예를 들어 클라이언트가 디렉터리 항목을 조회하고 해당 파일 핸들을 가져와야 하는 경우 다음 요청이 필요합니다.

```text
      PUTFH (directory filehandle)

      LOOKUP (entry name)

      GETFH
```

---
### **18.9.  Operation 11: LINK - Create Link to a File**
---
#### **18.9.1.  ARGUMENTS**

```text
   struct LINK4args {
           /* SAVED_FH: source object */
           /* CURRENT_FH: target directory */
           component4      newname;
   };
```

---
#### **18.9.2.  RESULTS**

```text
   struct LINK4resok {
           change_info4    cinfo;
   };

   union LINK4res switch (nfsstat4 status) {
    case NFS4_OK:
            LINK4resok resok4;
    default:
            void;
   };
```

---
#### **18.9.3.  DESCRIPTION**

LINK 작업은 SAVEFH 작업에 의해 설정된 대로 현재 파일 핸들이 나타내는 디렉터리에 저장된 파일 핸들이 나타내는 파일에 대한 추가 새 이름을 생성합니다. 기존 파일과 대상 디렉터리는 서버의 동일한 파일 시스템 내에 있어야 합니다. 성공하면 현재 파일 핸들이 계속 대상 디렉터리가 됩니다. newname과 동일한 이름을 가진 개체가 대상 디렉터리에 존재하는 경우 서버는 NFS4ERR\_EXIST를 반환해야 합니다.

대상 디렉터리의 경우 서버는 cinfo에change\_info4 정보를 반환합니다. Change\_info4 데이터 유형의 원자 필드를 사용하면 서버는 링크 생성과 관련하여 변경 전후 속성이 원자적으로 획득되었는지 여부를 나타냅니다.

newname의 길이가 0이거나 newname이 UTF-8 정의를 따르지 않는 경우 NFS4ERR\_INVAL 오류가 반환됩니다.

---
#### **18.9.4.  IMPLEMENTATION**

서버는 파일이 열려 있거나 해당 열기가 특정 프로토콜이나 특정 옵션 또는 액세스 모드에 의해 수행될 때 LINK가 수행되지 않도록 LINK 작업에 제한을 가할 수 있습니다. 이러한 제한으로 인해 LINK가 거부되면 NFS4ERR\_FILE\_OPEN 오류가 반환됩니다.\(MAY\)

서버가 그러한 제한 사항을 구현하고 해당 제한 사항에 링크의 성공적인 실행을 방해하는 NFSv4 열기 사례가 포함되는 경우, 서버는 해당 결정과 관련된 열기의 존재를 숨길 수 있는 모든 위임을 회수해야 합니다. 그 이유는 클라이언트가 위임을 보유할 때 클라이언트가 로컬에서 OPEN 및 CLOSE를 실행할 수 있기 때문에 서버가 해당 클라이언트에 대한 열기에 대한 정확한 계정을 갖고 있지 않을 수 있기 때문입니다. LINK 작업은 최종 결과를 얻을 수 있을 때까지만 지연되어야 합니다. 예를 들어 여러 위임이 있고 그 중 하나가 링크를 차단하는 공개를 설정한다고 가정합니다. 서버의 의미를 고려할 때 NFS4ERR\_FILE\_OPEN은 다른 위임이 반환될 때까지 기다리지 않고 해당 위임이 반환되는 즉시 호출자에게 반환될 수 있습니다. 마찬가지로, 이러한 열기가 위임과 연결되지 않은 경우 위임 회수가 수행되지 않고 NFS4ERR\_FILE\_OPEN이 즉시 반환될 수 있습니다.

현재 파일 핸들이 다른 클라이언트가 디렉터리 위임을 보유한 디렉터리를 지정하는 경우 알림을 보내 상황을 해결할 수 있는 위임이 아닌 이상 위임을 반드시 회수해야 하며 위임이 완료될 때까지 작업을 성공적으로 수행할 수 없습니다. 반환되거나 취소됩니다. 매우 빠르게 발생하는 경우를 제외하고 위임이 미해결 상태로 유지되는 동안 요청에 하나 이상의 NFS4ERR\_DELAY 오류가 반환됩니다.\(MUST\)

현재 파일 핸들이 하나 이상의 디렉터리 위임이 존재하는 디렉터리를 지정하는 경우 해당 위임이 해당 알림을 요청하면 회수 대신 NOTIFY4\_ADD\_ENTRY가 LINK 작업의 결과로 생성됩니다.

현재 파일 시스템이 numlinks 속성을 지원하고 다른 클라이언트가 링크 중인 파일에 대한 위임을 갖고 있는 경우 해당 위임을 반드시 회수해야 하며 모든 위임이 반환되거나 취소될 때까지 LINK 작업을 진행해서는 안 됩니다. 매우 빠르게 발생하는 경우를 제외하고 위임이 미해결 상태로 유지되는 동안 요청에 하나 이상의 NFS4ERR\_DELAY 오류가 반환됩니다.\(MUST NOT\)

"하드" 링크된 파일의 속성에 대한 변경 사항은 링크된 모든 파일에 반영됩니다. 파일에 대한 링크가 만들어지면 파일 속성의 numlinks 값은 LINK 작업 이전의 값보다 1 커야 합니다.

"파일과 대상 디렉터리는 서버의 동일한 파일 시스템 내에 있어야 합니다"라는 문은 개체 속성의 fsid 필드가 동일함을 의미합니다. 서로 다른 파일 시스템에 상주하는 경우 NFS4ERR\_XDEV 오류가 반환됩니다. LINK 작업이 위반하는 파일 시스템의 내부 분할이 있는 경우 일부 서버에서 이 오류가 반환될 수 있습니다.

일부 서버에서는 "." 및 ".."은 newname에 대한 잘못된 값이며 이를 지정하면 NFS4ERR\_BADNAME 오류가 반환됩니다.

현재 파일 핸들이 명명된 속성 디렉터리를 지정하고 링크할 객체\(저장된 파일 핸들\)가 동일한 객체에 대한 명명된 속성이 아닌 경우 NFS4ERR\_XDEV 오류가 반환되어야 합니다. 저장된 파일 핸들이 명명된 속성을 지정하고 현재 파일 핸들이 적절한 명명된 속성 디렉터리가 아닌 경우 NFS4ERR\_XDEV 오류도 반환되어야 합니다.\(MUST, MUST\)

현재 파일 핸들이 명명된 속성 디렉터리를 지정하고 링크할 개체\(저장된 파일 핸들\)가 해당 디렉터리 내의 명명된 속성인 경우 서버는 NFS4ERR\_NOTSUPP 오류를 반환할 수 있습니다.

newname이 저장된 파일 핸들이 나타내는 파일에 이미 링크되어 있는 경우 서버는 NFS4ERR\_EXIST를 반환합니다.

CREATE 작업을 통해 심볼릭 링크가 생성된다는 점에 유의하세요.

---
### **18.10.  Operation 12: LOCK - Create Lock**
---
#### **18.10.1.  ARGUMENTS**

```text
   /*
    * For LOCK, transition from open_stateid and lock_owner
    * to a lock stateid.
    */
   struct open_to_lock_owner4 {
           seqid4          open_seqid;
           stateid4        open_stateid;
           seqid4          lock_seqid;
           lock_owner4     lock_owner;
   };

   /*
    * For LOCK, existing lock stateid continues to request new
    * file lock for the same lock_owner and open_stateid.
    */
   struct exist_lock_owner4 {
           stateid4        lock_stateid;
           seqid4          lock_seqid;
   };

   union locker4 switch (bool new_lock_owner) {
    case TRUE:
           open_to_lock_owner4     open_owner;
    case FALSE:
           exist_lock_owner4       lock_owner;
   };

   /*
    * LOCK/LOCKT/LOCKU: Record lock management
    */
   struct LOCK4args {
           /* CURRENT_FH: file */
           nfs_lock_type4  locktype;
           bool            reclaim;
           offset4         offset;
           length4         length;
           locker4         locker;
   };
```

---
#### **18.10.2.  RESULTS**

```text
   struct LOCK4denied {
           offset4         offset;
           length4         length;
           nfs_lock_type4  locktype;
           lock_owner4     owner;
   };

   struct LOCK4resok {
           stateid4        lock_stateid;
   };

   union LOCK4res switch (nfsstat4 status) {
    case NFS4_OK:
            LOCK4resok     resok4;
    case NFS4ERR_DENIED:
            LOCK4denied    denied;
    default:
            void;
   };
```

---
#### **18.10.3.  DESCRIPTION**

LOCK 작업은 offset 및 length 매개변수에 지정된 바이트 범위와 locktype 매개변수에 지정된 잠금 유형에 대한 바이트 범위 잠금을 요청합니다. 회수 요청인 경우 회수 매개변수는 TRUE입니다.

해당 바이트가 현재 파일에 할당되지 않은 경우에도 파일의 바이트가 잠길 수 있습니다. 파일 끝을 통해 특정 오프셋에서 파일을 잠그려면\(파일의 실제 길이에 관계없이\) NFS4\_UINT64\_MAX와 동일한 길이 필드를 사용하십시오. 서버는 다음과 같은 길이와 오프셋 조합으로 NFS4ERR\_INVAL을 반환해야 합니다.\(MUST\)

\* 길이는 0과 같습니다.

\* 길이가 NFS4\_UINT64\_MAX와 동일하지 않으며, 길이와 오프셋의 합이 NFS4\_UINT64\_MAX를 초과합니다.

32비트 서버는 32비트 내에 맞는\(즉, NFS4\_UINT32\_MAX 이하\) 바이트 오프셋에 대한 잠금을 지원하는 서버입니다. 클라이언트가 NFS4\_UINT32\_MAX 오프셋을 넘어 하나 이상의 바이트와 겹치는 범위를 지정하지만 NFS4\_UINT64\_MAX 오프셋에서 끝나지 않는 경우 이러한 32비트 서버는 NFS4ERR\_BAD\_RANGE 오류를 반환해야 합니다.\(MUST\)

서버가 NFS4ERR\_DENIED를 반환하면 충돌하는 잠금의 소유자, 오프셋 및 길이가 반환됩니다.

locker 인수는 LOCK 작업과 관련된 잠금 소유자를 지정합니다. locker4 구조는 클라이언트가 현재 열려 있는 파일 및 잠금 소유자와 관련된 바이트 범위 잠금 상태를 이미 생성했는지 여부를 나타내는 전환된 공용체입니다. 이 경우 인수는 열려 있는 파일 및 잠금 소유자와 관련된 잠금 세트를 나타내는 stateid일 뿐이며, 임의의 값일 수 있고 서버에서 무시해야 하는 lock\_seqid 값도 포함됩니다. 바이트 범위 잠금 상태가 설정되지 않았거나 클라이언트에 사용 가능한 상태 ID가 없는 경우 인수에는 잠금 소유자와 함께 이 잠금과 연관될 열린 파일의 상태 ID가 포함됩니다. 잠금이 연결됩니다. open\_to\_lock\_owner 사례는 지정된 열린 파일에 대해 잠금 소유자가 수행한 첫 번째 잠금을 다루고 open\_stateid의 설정된 상태를 사용하여 잠금 상태 ID 사용으로 전환하는 방법을 제공합니다.\(MUST\)

locker 매개변수의 다음 필드는 클라이언트에 의해 임의의 값으로 설정될 수 있으며 서버에 의해 무시되어야 합니다.\(MUST\)

\* open\_owner 필드\(locker.open\_owner.lock\_owner.clientid\)의 lock\_owner 필드 중 clientid 필드입니다. 서버가 clientid 필드를 무시해야 하는 이유는 서버가 COMPOUND 요청의 SEQUENCE 작업의 세션 ID에서 클라이언트 ID를 파생해야 하기 때문입니다.\(MUST\)

\* open\_owner 필드의 open\_seqid 및 lock\_seqid 필드\(locker.open\_owner.open\_seqid 및 locker.open\_owner.lock\_seqid\).

\* lock\_owner 필드의 lock\_seqid 필드

- \(locker.lock\_owner.lock\_seqid\).

LOCK4denied 구조에 나타나는 클라이언트 ID는 현재 세션과 연결된 클라이언트 ID이든 다른 클라이언트 ID이든 관계없이 충돌하는 잠금과 연결된 실제 클라이언트입니다. 따라서 서버가 NFS4ERR\_DENIED를 반환하는 경우 거부된 필드의 소유자 필드의 클라이언트 ID 필드를 설정해야 합니다.\(MUST\)

현재 파일 핸들이 일반 파일이 아닌 경우 클라이언트에 오류가 반환됩니다. 현재 파일 핸들이 NF4DIR 유형의 객체를 나타내는 경우 NFS4ERR\_ISDIR이 반환됩니다. 현재 파일 핸들이 심볼릭 링크를 지정하면 NFS4ERR\_SYMLINK가 반환됩니다. 다른 모든 경우에는 NFS4ERR\_WRONG\_TYPE이 반환됩니다.

성공하면 현재 파일 핸들이 해당 값을 유지합니다.

---
#### **18.10.4.  IMPLEMENTATION**

서버가 충돌하는 바이트 범위 잠금의 정확한 오프셋과 길이를 확인할 수 없는 경우 인수에 제공된 것과 동일한 오프셋과 길이가 거부된 결과에 반환되어야 합니다.

LOCK 작업은 권한 확인 및 관련 파일의 액세스 유형에 대한 확인을 따릅니다. 그러나 다양한 유형의 잠금에 필요한 특정 권한과 모드는 서버에서 내보낸 파일 시스템의 의미를 반영하며 프로토콜에 의해 지정되지 않습니다. 예를 들어, Windows 2000에서는 읽기 액세스를 위해 열린 파일에 대한 쓰기 잠금을 허용하지만 POSIX 호환 시스템에서는 허용하지 않습니다.

클라이언트가 잠금 소유자가 이미 잠근 범위\(동일하거나 다른 잠금 유형 사용\), 해당 범위의 하위 범위 또는 여러 바이트 범위를 포함하는 LOCK 작업을 보내는 경우 해당 잠금 소유자에게 전체 또는 부분적으로 잠금이 이미 부여되어 있고 서버가 이러한 잠금 작업을 지원하지 않는 경우\(즉, POSIX 잠금 의미 체계를 지원하지 않는 경우\) 서버는 NFS4ERR\_LOCK\_RANGE 오류를 반환합니다. 이 경우 클라이언트는 해당 잠금 소유자가 이미 잠근 바이트를 포함하지 않는 범위에 대해 LOCK만 사용하고 해당 잠금 소유자가 보유한 잠금의 LOCKU를 사용하여 오류를 반환하거나 필요한 작업을 에뮬레이트할 수 있습니다\( 정확히 일치하는 범위 및 유형\). 마찬가지로 클라이언트가 기존 바이트 범위 잠금을 업그레이드\(READ\_LT 잠금에서 WRITE\_LT 잠금으로 변경\) 또는 다운그레이드\(WRITE\_LT 잠금에서 READ\_LT 잠금으로 변경\)하는 LOCK 작업을 보내고 서버가 이러한 잠금을 지원하지 않는 경우 잠금이 발생하면 서버는 NFS4ERR\_LOCK\_NOTSUPP를 반환합니다. 이러한 작업은 다른 클라이언트의 LOCK 작업이 충돌하는 경우 필요한 의미를 완벽하게 반영하지 못할 수 있습니다.

클라이언트가 OPEN\_DELEGATE\_WRITE 위임을 보유한 경우 해당 위임을 보유한 클라이언트는 다른 클라이언트가 열 수 없음을 보장합니다. 따라서 해당 클라이언트에서는 충돌하는 LOCK 작업이 있을 수 없습니다. 따라서 클라이언트는 서버에서 LOCK 작업을 수행하지 않고 로컬로 잠금 요청을 처리할 수 있습니다. 그렇게 하는 경우 위임을 반환하기 전에 적절한 LOCK 및 LOCKU 작업을 전송하여 서버의 잠금 상태를 업데이트할 준비를 해야 합니다.

하나 이상의 클라이언트가 OPEN\_DELEGATE\_READ 위임을 보유하는 경우 서버가 필수 잠금 의미를 구현하는 모든 LOCK 작업은 그러한 모든 위임을 회수해야 합니다. 모든 위임이 반환되거나 취소될 때까지 LOCK 작업이 승인되지 않을 수 있습니다. 매우 빠르게 발생하는 경우를 제외하고 위임이 미해결 상태로 유지되는 동안 요청에 하나 이상의 NFS4ERR\_DELAY 오류가 반환됩니다.\(MUST\)

---
### **18.11.  Operation 13: LOCKT - Test for Lock**
---
#### **18.11.1.  ARGUMENTS**

```text
   struct LOCKT4args {
           /* CURRENT_FH: file */
           nfs_lock_type4  locktype;
           offset4         offset;
           length4         length;
           lock_owner4     owner;
   };
```

---
#### **18.11.2.  RESULTS**

```text
   union LOCKT4res switch (nfsstat4 status) {
    case NFS4ERR_DENIED:
            LOCK4denied    denied;
    case NFS4_OK:
            void;
    default:
            void;
   };
```

---
#### **18.11.3.  DESCRIPTION**

LOCKT 작업은 인수에 지정된 대로 잠금을 테스트합니다. 충돌하는 잠금이 있는 경우 충돌하는 잠금의 소유자, 오프셋, 길이 및 유형이 반환됩니다. 결과의 소유자 필드에는 현재 세션과 연결된 클라이언트 ID인지 아니면 다른 클라이언트 ID인지에 관계없이 충돌하는 잠금 소유자의 클라이언트 ID가 포함됩니다. 잠금이 유지되지 않으면 NFS4\_OK 외에는 아무것도 반환되지 않습니다. 잠금 유형 READ\_LT 및 READW\_LT는 차단 또는 비차단에 관계없이 충돌하는 잠금 테스트가 수행된다는 점에서 동일한 방식으로 처리됩니다. WRITE\_LT 및 WRITEW\_LT의 경우에도 마찬가지입니다.

범위는 LOCK과 같이 지정됩니다. NFS4ERR\_INVAL 및 NFS4ERR\_BAD\_RANGE 오류는 LOCK과 동일한 상황에서 반환됩니다.

소유자의 clientid 필드는 클라이언트에 의해 임의의 값으로 설정될 수 있으며 서버에서는 무시되어야 합니다. 서버가 clientid 필드를 무시해야 하는 이유는 서버가 COMPOUND 요청의 SEQUENCE 작업의 세션 ID에서 클라이언트 ID를 파생해야 하기 때문입니다.\(MUST, MUST\)

현재 파일 핸들이 일반 파일이 아닌 경우 클라이언트에 오류가 반환됩니다. 현재 파일 핸들이 NF4DIR 유형의 객체를 나타내는 경우 NFS4ERR\_ISDIR이 반환됩니다. 현재 파일 핸들이 심볼릭 링크를 지정하면 NFS4ERR\_SYMLINK가 반환됩니다. 다른 모든 경우에는 NFS4ERR\_WRONG\_TYPE이 반환됩니다.

성공하면 현재 파일 핸들이 해당 값을 유지합니다.

---
#### **18.11.4.  IMPLEMENTATION**

서버가 충돌하는 잠금의 정확한 오프셋과 길이를 확인할 수 없는 경우 인수에 제공된 동일한 오프셋과 길이가 거부된 결과에 반환되어야 합니다.

LOCKT는 소유자를 식별하기 위해 LOCK에서 사용되는 것처럼 stateid4 대신 lock\_owner4를 사용합니다. 이는 클라이언트가 잠금 존재 여부를 테스트하기 위해 파일을 열 필요가 없으므로 상태 ID를 사용하지 못할 수도 있기 때문입니다.

섹션 18.10.4에 언급된 대로 일부 서버는 현재 잠금 소유자에게 이미 부여된 범위와 겹치는 특정\(그렇지 않으면 충돌하지 않는\) LOCK 작업에 NFS4ERR\_LOCK\_RANGE를 반환할 수 있습니다.

잠금 충돌에 대한 LOCKT 작업 테스트는 현재 잠금 소유자에 대한 잠금을 제외해야 하며, 따라서 그러한 경우 NFS4\_OK를 반환해야 합니다. 이는 동일한 범위 및 잠금 소유자에 대한 LOCK 작업이 NFS4ERR\_LOCK\_RANGE로 인해 실패하더라도 서버가 LOCKT 요청에 NFS4\_OK를 반환할 수 있음을 의미합니다.\(SHOULD\)

클라이언트가 OPEN\_DELEGATE\_WRITE 위임을 보유하면 로컬에서 LOCK 요청을 처리하도록 선택할 수 있습니다\(섹션 18.10.4 참조\). 이러한 경우 LOCKT 요청은 유사하게 로컬로 처리됩니다.

---
### **18.12.  Operation 14: LOCKU - Unlock File**
---
#### **18.12.1.  ARGUMENTS**

```text
   struct LOCKU4args {
           /* CURRENT_FH: file */
           nfs_lock_type4  locktype;
           seqid4          seqid;
           stateid4        lock_stateid;
           offset4         offset;
           length4         length;
   };
```

---
#### **18.12.2.  RESULTS**

```text
   union LOCKU4res switch (nfsstat4 status) {
    case   NFS4_OK:
            stateid4       lock_stateid;
    default:
            void;
   };
```

---
#### **18.12.3.  DESCRIPTION**

LOCKU 연산은 매개변수에 지정된 바이트 범위 잠금을 해제합니다. 클라이언트는 nfs\_lock\_type4 열거 유형에 대해 유효한 값으로 locktype 필드를 설정할 수 있으며, 서버는 locktype에 대한 모든 유효한 값을 수락해야 합니다. locktype의 적법한 값은 LOCKU 작업의 성공이나 실패에 영향을 주지 않습니다.\(MUST\)

범위는 LOCK과 같이 지정됩니다. NFS4ERR\_INVAL 및 NFS4ERR\_BAD\_RANGE 오류는 LOCK과 동일한 상황에서 반환됩니다.

seqid 매개변수는 임의의 값일 수 있으며 서버는 이를 무시해야 합니다.\(MUST\)

현재 파일 핸들이 일반 파일이 아닌 경우 클라이언트에 오류가 반환됩니다. 현재 파일 핸들이 NF4DIR 유형의 객체를 나타내는 경우 NFS4ERR\_ISDIR이 반환됩니다. 현재 파일 핸들이 심볼릭 링크를 지정하면 NFS4ERR\_SYMLINK가 반환됩니다. 다른 모든 경우에는 NFS4ERR\_WRONG\_TYPE이 반환됩니다.

성공하면 현재 파일 핸들이 해당 값을 유지합니다.

서버는 주체, 보안 특성 및 적용 가능한 경우 GSS 메커니즘, LOCK 작업을 보낸 조합도 파일에 LOCKU를 보내는 조합이 되도록 요구할 수 있습니다. 주체에 대한 자격 증명을 더 이상 사용할 수 없는 경우 이는 불가능할 수 있습니다. 서버는 기계 자격 증명 또는 SSV 자격 증명\(섹션 18.35 참조\)이 LOCKU를 보내는 것을 허용할 수 있습니다.\(MAY, MAY\)

---
#### **18.12.4.  IMPLEMENTATION**

잠금을 해제할 영역이 잠금 소유자가 실제로 보유한 잠금과 정확하게 일치하지 않는 경우 서버는 NFS4ERR\_LOCK\_RANGE 오류를 반환할 수 있습니다. 여기에는 영역이 잠겨 있지 않은 경우, 영역이 잠긴 영역의 하위 범위인 경우, 정확히 일치하지 않고 잠긴 영역과 겹치는 경우 또는 지정된 영역에 잠금 소유자가 보유한 여러 잠금이 포함된 경우가 포함됩니다. POSIX 잠금 \[21\] 의미론에 의해 허용되는 이러한 모든 경우에 이 오류를 수신하는 클라이언트는 해당 작업에 대한 지원을 원하는 경우 실제로 보유하고 있는 잠금에 해당하는 범위에서 LOCKU를 사용하여 작업을 시뮬레이션해야 하며, 가능하면 다음에 대한 LOCK 작업이 뒤따라야 합니다. 하위 범위가 잠금 해제되지 않습니다.

클라이언트가 OPEN\_DELEGATE\_WRITE 위임을 보유하면 로컬에서 LOCK 요청을 처리하도록 선택할 수 있습니다\(섹션 18.10.4 참조\). 이러한 경우 LOCKU 작업은 유사하게 로컬로 처리됩니다.

---
### **18.13.  Operation 15: LOOKUP - Lookup Filename**
---
#### **18.13.1.  ARGUMENTS**

```text
   struct LOOKUP4args {
           /* CURRENT_FH: directory */
           component4      objname;
   };
```

---
#### **18.13.2.  RESULTS**

```text
   struct LOOKUP4res {
           /* New CURRENT_FH: object */
           nfsstat4        status;
   };
```

---
#### **18.13.3.  DESCRIPTION**

LOOKUP 작업은 현재 파일 핸들에 지정된 디렉터리를 사용하여 파일 시스템 개체를 조회하거나 찾습니다. LOOKUP은 구성 요소를 평가하고 개체가 존재하는 경우 현재 파일 핸들이 구성 요소의 파일 핸들로 대체됩니다.

구성 요소가 존재하지 않거나 클라이언트에 구성 요소를 평가할 수 있는 권한이 없기 때문에 구성 요소를 평가할 수 없는 경우 오류가 반환되고 현재 파일 핸들은 변경되지 않습니다.

구성 요소가 길이가 0인 문자열이거나 구성 요소가 UTF-8 정의를 따르지 않는 경우 NFS4ERR\_INVAL 오류가 반환됩니다.

---
#### **18.13.4.  IMPLEMENTATION**

클라이언트가 다중 구성 요소 조회 효과를 얻으려는 경우 다음과 같은 COMPOUND 요청을 구성하고 각 파일 핸들을 얻을 수 있습니다.

```text
         PUTFH  (directory filehandle)
         LOOKUP "pub"
         GETFH
         LOOKUP "foo"
         GETFH
         LOOKUP "bar"
         GETFH
```

NFSv3과 달리 NFSv4.1에서는 LOOKUP 요청이 서버의 마운트 지점을 통과할 수 있습니다. 클라이언트는 디렉토리의 fsid 속성을 조회된 디렉토리의 fsid 속성과 비교하여 마운트 지점 교차를 감지할 수 있습니다. fsid가 다른 경우 새 디렉토리는 서버 마운트 지점입니다. 마운트 지점 교차를 감지하는 UNIX 클라이언트는 서버의 파일 시스템을 마운트해야 합니다. UNIX 클라이언트에 공통적인 파일 개체 ID 확인 메커니즘을 유지하려면 이 작업을 수행해야 합니다.

NFS 액세스를 "공유" 또는 "내보낸" 파일 시스템으로 제한하는 서버는 클라이언트가 서버의 네임스페이스를 탐색할 수 있도록 내보낸 파일 시스템을 통합할 수 있는 의사 파일 시스템을 제공해야 합니다. 의사 파일 시스템의 클라이언트 보기는 내보낸 파일 시스템으로 연결되는 경로로 제한됩니다.

참고: 이전 버전의 프로토콜에서는 이름 "."에 특별한 의미가 할당되었습니다. 그리고 "..". NFSv4.1은 이러한 이름에 특별한 의미를 할당하지 않습니다. 상위 디렉터리를 조회하려면 LOOKUPP 연산자를 사용해야 합니다.

이 작업은 기호 링크를 따르지 않습니다. 클라이언트는 조회 프로세스 중에 발견된 기호 링크에 의해 수정된 파일 이름을 포함하여 모든 파일 이름 구문 분석을 담당합니다.

제공된 현재 파일 핸들이 디렉토리가 아니라 심볼릭 링크인 경우 NFS4ERR\_SYMLINK 오류가 오류로 반환됩니다. 디렉터리가 아닌 다른 모든 파일 형식의 경우 NFS4ERR\_NOTDIR 오류가 반환됩니다.

---
### **18.14.  Operation 16: LOOKUPP - Lookup Parent Directory**
---
#### **18.14.1.  ARGUMENTS**

```text
   /* CURRENT_FH: object */
   void;
```

---
#### **18.14.2.  RESULTS**

```text
   struct LOOKUPP4res {
           /* new CURRENT_FH: parent directory */
           nfsstat4        status;
   };
```

---
#### **18.14.3.  DESCRIPTION**

현재 파일 핸들은 일반 디렉토리 또는 명명된 속성 디렉토리를 참조하는 것으로 가정됩니다. LOOKUPP은 상위 디렉터리의 파일 핸들을 현재 파일 핸들로 할당합니다. 상위 디렉토리가 없으면 NFS4ERR\_NOENT 오류가 반환되어야 합니다. 따라서 현재 파일 핸들이 서버 파일 트리의 루트 또는 최상위에 있을 때 서버는 NFS4ERR\_NOENT를 반환합니다.

LOOKUP의 경우와 마찬가지로 LOOKUPP도 마운트 지점을 교차합니다.

현재 파일 핸들이 디렉토리나 명명된 속성 디렉토리가 아닌 경우 NFS4ERR\_NOTDIR 오류가 반환됩니다.

요청자의 보안 특성이 상위 디렉터리에 대해 구성된 보안 특성과 일치하지 않으면 서버는 LOOKUPP 응답에서 NFS4ERR\_WRONGSEC\(NFSv4의 향후 마이너 개정판에서는 이를 MUST로 업그레이드할 수 있음\)를 반환해야 합니다. 그러나 서버가 그렇게 하는 경우 클라이언트가 올바른 보안 유형을 적절하게 결정할 수 있도록 SECINFO\_NO\_NAME 작업\(18.45절\)을 지원해야 합니다.\(MUST, MUST\)

현재 파일 핸들이 OPENATTR을 통해 파일 시스템 개체와 연결된 명명된 특성 디렉터리\(즉, 명명된 특성 디렉터리의 하위 디렉터리가 아님\)인 경우 LOOKUPP은 관련 파일 시스템 개체의 파일 핸들을 반환해야 합니다.\(SHOULD\)

---
#### **18.14.4.  IMPLEMENTATION**

주목해야 할 문제는 명명된 특성 디렉터리에서 위쪽으로 탐색하는 것입니다. 명명된 특성 디렉터리는 기본적으로 네임스페이스에서 분리되며 이 속성은 클라이언트 운영 환경에서 안전하게 표시되어야 합니다. 명명된 속성 디렉터리의 LOOKUPP은 관련 파일의 파일 핸들을 반환할 수 있으며, 이를 응용 프로그램에 전달하는 것은 많은 응용 프로그램이 개체의 부모가 항상 디렉터리일 것으로 기대하므로 안전하지 않을 수 있습니다. 따라서 클라이언트는 명명된 특성 디렉터리의 상위 디렉터리\(UNIX에서 ".."로 표시됨\)를 숨기거나 명명된 특성 디렉터리를 자신의 상위 디렉터리로 표시하려고 할 수 있습니다\(일반적으로 UNIX에서 파일 시스템 루트 디렉터리에 대해 수행되는 것처럼\).

---
### **18.15.  Operation 17: NVERIFY - Verify Difference in Attributes**
---
#### **18.15.1.  ARGUMENTS**

```text
   struct NVERIFY4args {
           /* CURRENT_FH: object */
           fattr4          obj_attributes;
   };
```

---
#### **18.15.2.  RESULTS**

```text
   struct NVERIFY4res {
           nfsstat4        status;
   };
```

---
#### **18.15.3.  DESCRIPTION**

이 작업은 일부 파일 시스템 개체에서 하나 이상의 속성이 변경된 경우 수행될 작업 시퀀스의 접두사로 사용됩니다. 모든 속성이 일치하면 NFS4ERR\_SAME 오류가 반환되어야 합니다.\(MUST\)

성공하면 현재 파일 핸들이 해당 값을 유지합니다.

---
#### **18.15.4.  IMPLEMENTATION**

이 작업은 캐시 유효성 검사 연산자로 유용합니다. 속성이 속한 개체가 변경된 경우 다음 작업을 통해 해당 개체와 관련된 새 데이터를 얻을 수 있습니다. 예를 들어 파일이 변경되었는지 확인하고 변경된 경우 새 데이터를 얻을 수 있습니다.

```text
         SEQUENCE
         PUTFH fh
         NVERIFY attrbits attrs
         READ 0 32767
```

이를 NFSv3과 대조해 보세요. NFSv3는 먼저 한 번의 요청/응답 왕복에서 GETATTR을 보낸 다음 속성에서 클라이언트 캐시가 오래되었음을 나타내는 경우 다른 요청/응답 왕복에서 READ를 보냅니다.

NVERIFY 작업에 RECOMMENDED 속성이 지정되어 있고 서버가 파일 시스템 개체에 대해 해당 속성을 지원하지 않는 경우 NFS4ERR\_ATTRNOTSUPP 오류가 클라이언트에 반환됩니다.\(SHOULD\)

rdattr\_error 속성이나 설정 전용 속성\(예: time\_modify\_set\)이 지정되면 NFS4ERR\_INVAL 오류가 클라이언트에 반환됩니다.

---
### **18.16.  Operation 18: OPEN - Open a Regular File**
---
#### **18.16.1.  ARGUMENTS**

```text
   /*
    * Various definitions for OPEN
    */
   enum createmode4 {
           UNCHECKED4      = 0,
           GUARDED4        = 1,
           /* Deprecated in NFSv4.1. */
           EXCLUSIVE4      = 2,
           /*
            * New to NFSv4.1. If session is persistent,
            * GUARDED4 MUST be used.  Otherwise, use
            * EXCLUSIVE4_1 instead of EXCLUSIVE4.
            */
           EXCLUSIVE4_1    = 3
   };

   struct creatverfattr {
            verifier4      cva_verf;
            fattr4         cva_attrs;
   };

   union createhow4 switch (createmode4 mode) {
    case UNCHECKED4:
    case GUARDED4:
            fattr4         createattrs;
    case EXCLUSIVE4:
            verifier4      createverf;
    case EXCLUSIVE4_1:
            creatverfattr  ch_createboth;
   };

   enum opentype4 {
           OPEN4_NOCREATE  = 0,
           OPEN4_CREATE    = 1
   };

   union openflag4 switch (opentype4 opentype) {
    case OPEN4_CREATE:
            createhow4     how;
    default:
            void;
   };

   /* Next definitions used for OPEN delegation */
   enum limit_by4 {
           NFS_LIMIT_SIZE          = 1,
           NFS_LIMIT_BLOCKS        = 2
           /* others as needed */
   };

   struct nfs_modified_limit4 {
           uint32_t        num_blocks;
           uint32_t        bytes_per_block;
   };

   union nfs_space_limit4 switch (limit_by4 limitby) {
    /* limit specified as file size */
    case NFS_LIMIT_SIZE:
            uint64_t               filesize;
    /* limit specified by number of blocks */
    case NFS_LIMIT_BLOCKS:
            nfs_modified_limit4    mod_blocks;
   } ;

   /*
    * Share Access and Deny constants for open argument
    */
   const OPEN4_SHARE_ACCESS_READ   = 0x00000001;
   const OPEN4_SHARE_ACCESS_WRITE  = 0x00000002;
   const OPEN4_SHARE_ACCESS_BOTH   = 0x00000003;

   const OPEN4_SHARE_DENY_NONE     = 0x00000000;
   const OPEN4_SHARE_DENY_READ     = 0x00000001;
   const OPEN4_SHARE_DENY_WRITE    = 0x00000002;
   const OPEN4_SHARE_DENY_BOTH     = 0x00000003;

   /* new flags for share_access field of OPEN4args */
   const OPEN4_SHARE_ACCESS_WANT_DELEG_MASK        = 0xFF00;
   const OPEN4_SHARE_ACCESS_WANT_NO_PREFERENCE     = 0x0000;
   const OPEN4_SHARE_ACCESS_WANT_READ_DELEG        = 0x0100;
   const OPEN4_SHARE_ACCESS_WANT_WRITE_DELEG       = 0x0200;
   const OPEN4_SHARE_ACCESS_WANT_ANY_DELEG         = 0x0300;
   const OPEN4_SHARE_ACCESS_WANT_NO_DELEG          = 0x0400;
   const OPEN4_SHARE_ACCESS_WANT_CANCEL            = 0x0500;

   const
    OPEN4_SHARE_ACCESS_WANT_SIGNAL_DELEG_WHEN_RESRC_AVAIL
    = 0x10000;

   const
    OPEN4_SHARE_ACCESS_WANT_PUSH_DELEG_WHEN_UNCONTENDED
    = 0x20000;

   enum open_delegation_type4 {
           OPEN_DELEGATE_NONE      = 0,
           OPEN_DELEGATE_READ      = 1,
           OPEN_DELEGATE_WRITE     = 2,
           OPEN_DELEGATE_NONE_EXT  = 3 /* new to v4.1 */
   };

   enum open_claim_type4 {
           /*
            * Not a reclaim.
            */
           CLAIM_NULL              = 0,

           CLAIM_PREVIOUS          = 1,
           CLAIM_DELEGATE_CUR      = 2,
           CLAIM_DELEGATE_PREV     = 3,

           /*
            * Not a reclaim.
            *
            * Like CLAIM_NULL, but object identified
            * by the current filehandle.
            */
           CLAIM_FH                = 4, /* new to v4.1 */

           /*
            * Like CLAIM_DELEGATE_CUR, but object identified
            * by current filehandle.
            */
           CLAIM_DELEG_CUR_FH      = 5, /* new to v4.1 */

           /*
            * Like CLAIM_DELEGATE_PREV, but object identified
            * by current filehandle.
            */
           CLAIM_DELEG_PREV_FH     = 6 /* new to v4.1 */
   };

   struct open_claim_delegate_cur4 {
           stateid4        delegate_stateid;
           component4      file;
   };

   union open_claim4 switch (open_claim_type4 claim) {
    /*
     * No special rights to file.
     * Ordinary OPEN of the specified file.
     */
    case CLAIM_NULL:
           /* CURRENT_FH: directory */
           component4      file;
    /*
     * Right to the file established by an
     * open previous to server reboot.  File
     * identified by filehandle obtained at
     * that time rather than by name.
     */
    case CLAIM_PREVIOUS:
           /* CURRENT_FH: file being reclaimed */
           open_delegation_type4   delegate_type;

    /*
     * Right to file based on a delegation
     * granted by the server.  File is
     * specified by name.
     */
    case CLAIM_DELEGATE_CUR:
           /* CURRENT_FH: directory */
           open_claim_delegate_cur4        delegate_cur_info;

    /*
     * Right to file based on a delegation
     * granted to a previous boot instance
     * of the client.  File is specified by name.
     */
    case CLAIM_DELEGATE_PREV:
            /* CURRENT_FH: directory */
           component4      file_delegate_prev;

    /*
     * Like CLAIM_NULL.  No special rights
     * to file.  Ordinary OPEN of the
     * specified file by current filehandle.
     */
    case CLAIM_FH: /* new to v4.1 */
           /* CURRENT_FH: regular file to open */
           void;

    /*
     * Like CLAIM_DELEGATE_PREV.  Right to file based on a
     * delegation granted to a previous boot
     * instance of the client.  File is identified
     * by filehandle.
     */
    case CLAIM_DELEG_PREV_FH: /* new to v4.1 */
           /* CURRENT_FH: file being opened */
           void;

    /*
     * Like CLAIM_DELEGATE_CUR.  Right to file based on
     * a delegation granted by the server.
     * File is identified by filehandle.
     */
    case CLAIM_DELEG_CUR_FH: /* new to v4.1 */
            /* CURRENT_FH: file being opened */
            stateid4       oc_delegate_stateid;

   };

   /*
    * OPEN: Open a file, potentially receiving an OPEN delegation
    */
   struct OPEN4args {
           seqid4          seqid;
           uint32_t        share_access;
           uint32_t        share_deny;
           open_owner4     owner;
           openflag4       openhow;
           open_claim4     claim;
   };
```

---
#### **18.16.2.  RESULTS**

```text
   struct open_read_delegation4 {
    stateid4 stateid;    /* Stateid for delegation*/
    bool     recall;     /* Pre-recalled flag for
                            delegations obtained
                            by reclaim (CLAIM_PREVIOUS) */

    nfsace4 permissions; /* Defines users who don't
                            need an ACCESS call to
                            open for read */
   };

   struct open_write_delegation4 {
    stateid4 stateid;      /* Stateid for delegation */
    bool     recall;       /* Pre-recalled flag for
                              delegations obtained
                              by reclaim
                              (CLAIM_PREVIOUS) */

    nfs_space_limit4
              space_limit; /* Defines condition that
                              the client must check to
                              determine whether the
                              file needs to be flushed
                              to the server on close.  */

    nfsace4   permissions; /* Defines users who don't
                              need an ACCESS call as
                              part of a delegated
                              open. */
   };

   enum why_no_delegation4 { /* new to v4.1 */
           WND4_NOT_WANTED         = 0,
           WND4_CONTENTION         = 1,
           WND4_RESOURCE           = 2,
           WND4_NOT_SUPP_FTYPE     = 3,
           WND4_WRITE_DELEG_NOT_SUPP_FTYPE = 4,
           WND4_NOT_SUPP_UPGRADE   = 5,
           WND4_NOT_SUPP_DOWNGRADE = 6,
           WND4_CANCELLED          = 7,
           WND4_IS_DIR             = 8
   };

   union open_none_delegation4 /* new to v4.1 */
   switch (why_no_delegation4 ond_why) {
           case WND4_CONTENTION:
                   bool ond_server_will_push_deleg;
           case WND4_RESOURCE:
                   bool ond_server_will_signal_avail;
           default:
                   void;
   };

   union open_delegation4
   switch (open_delegation_type4 delegation_type) {
           case OPEN_DELEGATE_NONE:
                   void;
           case OPEN_DELEGATE_READ:
                   open_read_delegation4 read;
           case OPEN_DELEGATE_WRITE:
                   open_write_delegation4 write;
           case OPEN_DELEGATE_NONE_EXT: /* new to v4.1 */
                   open_none_delegation4 od_whynone;
   };

   /*
    * Result flags
    */

   /* Client must confirm open */
   const OPEN4_RESULT_CONFIRM      = 0x00000002;
   /* Type of file locking behavior at the server */
   const OPEN4_RESULT_LOCKTYPE_POSIX = 0x00000004;
   /* Server will preserve file if removed while open */
   const OPEN4_RESULT_PRESERVE_UNLINKED = 0x00000008;

   /*
    * Server may use CB_NOTIFY_LOCK on locks
    * derived from this open
    */
   const OPEN4_RESULT_MAY_NOTIFY_LOCK = 0x00000020;

   struct OPEN4resok {
    stateid4       stateid;      /* Stateid for open */
    change_info4   cinfo;        /* Directory Change Info */
    uint32_t       rflags;       /* Result flags */
    bitmap4        attrset;      /* attribute set for create*/
    open_delegation4 delegation; /* Info on any open
                                    delegation */
   };

   union OPEN4res switch (nfsstat4 status) {
    case NFS4_OK:
           /* New CURRENT_FH: opened file */
           OPEN4resok      resok4;
    default:
           void;
   };
```

---
#### **18.16.3.  DESCRIPTION**

OPEN 작업은 제공된 이름이나 파일 핸들을 사용하여 디렉터리에서 일반 파일을 엽니다. OPEN은 이름이 제공되고 클라이언트가 파일 생성을 지정하는 경우 파일을 생성할 수도 있습니다. 파일 생성 여부와 생성 방법은 openhow 매개변수를 통해 지정됩니다. openhow 매개변수는 opentype\(OPEN4\_NOCREATE 또는 OPEN4\_CREATE\)의 값을 켜는 스위치 유니온\(데이터 유형 opengflag4\)으로 구성됩니다. OPEN4\_CREATE가 지정되면 UNCHECKED4, GUARDED4, EXCLUSIVE4 또는 EXCLUSIVE4\_1의 네 가지 생성 방법 사례를 지원하는 또 다른 전환 통합\(데이터 유형 createhow4\)이 생성됩니다. opentype이 OPEN4\_CREATE인 경우 클레임 필드의 클레임 필드는 CLAIM\_NULL, CLAIM\_DELEGATE\_CUR 또는 CLAIM\_DELEGATE\_PREV 중 하나여야 합니다. 왜냐하면 이러한 클레임 메서드에는 파일 이름의 구성 요소가 포함되어 있기 때문입니다.\(MUST\)

성공하면\(새 파일 생성이 수반될 수 있음\) 현재 파일 핸들이 생성된 개체 또는 기존 개체의 파일 핸들로 대체됩니다.

현재 파일 핸들이 명명된 속성 디렉터리인 경우 OPEN은 명명된 속성 파일을 생성하거나 엽니다. 명명된 속성의 단독 생성은 지원되지 않습니다. createmode가 EXCLUSIVE4 또는 EXCLUSIVE4\_1이고 현재 파일 핸들이 명명된 속성 디렉터리인 경우 서버는 EINVAL을 반환합니다.

UNCHECKED4는 해당 이름의 파일이 존재하지 않고 해당 이름의 기존 일반 파일이 발생하는 것이 오류가 아닌 경우 파일을 생성해야 함을 의미합니다. 이러한 유형의 생성에 대해 createattrs는 파일의 초기 속성 세트를 지정합니다. 속성 세트에는 일반 파일에 유효한 쓰기 가능한 속성이 포함될 수 있습니다. UNCHECKED4 생성이 기존 파일을 발견하면 createattrs가 지정한 속성은 사용되지 않습니다. 단, createattrs가 크기 속성을 0으로 지정하면 기존 파일이 잘립니다.

GUARDED4가 지정된 경우 서버는 생성을 수행하기 전에 이름으로 중복 개체가 있는지 확인합니다. 중복이 있으면 NFS4ERR\_EXIST가 반환됩니다. 개체가 존재하지 않으면 UNCHECKED4에 설명된 대로 요청이 수행됩니다.

작업이 성공한 UNCHECKED4 및 GUARDED4 사례의 경우 서버는 객체에 대해 어떤 속성이 성공적으로 설정되었는지 나타내는 속성 마스크를 클라이언트에 반환합니다.

EXCLUSIVE4\_1 및 EXCLUSIVE4는 서버가 대상의 독점 생성을 보장하기 위해 검증자를 사용하여 독점 생성 의미 체계를 따르도록 지정합니다. 서버는 이름으로 중복 개체가 있는지 확인해야 합니다. 객체가 존재하지 않으면 서버는 객체를 생성하고 객체와 함께 검증자를 저장합니다. 객체가 존재하고 저장된 검증자가 클라이언트가 제공한 검증자와 일치하는 경우 서버는 기존 객체를 새로 생성된 객체로 사용합니다. 저장된 검증자가 일치하지 않으면 NFS4ERR\_EXIST 오류가 반환됩니다.

EXCLUSIVE4를 사용하고 서버가 속성을 사용하여 단독 생성 검증자를 저장하는 경우 서버는 결과에 반환되는 속성 마스크에 적절한 비트를 설정하여 사용한 속성을 나타냅니다. UNCHECKED4, GUARDED4 및 EXCLUSIVE4\_1과 달리 EXCLUSIVE4는 파일 생성 시 속성 설정을 지원하지 않으며 EXCLUSIVE4를 통해 OPEN에 성공한 후 클라이언트는 속성을 알려진 상태로 설정하기 위해 SETATTR을 보내야 합니다.\(MUST\)

NFSv4.1에서는 EXCLUSIVE4가 더 이상 사용되지 않고 EXCLUSIVE4\_1이 사용됩니다. EXCLUSIVE4와 달리 EXCLUSIVE4\_1의 경우에도 속성을 제공할 수 있지만, 서버가 검증자를 저장하기 위해 대상 객체의 속성을 사용할 수 있기 때문에 허용되는 속성 집합이 SETATTR에서 허용하는 속성 집합보다 적을 수 있습니다. EXCLUSIVE4\_1에 허용되는 속성은 suppattr\_exclcreat\(섹션 5.8.1.14\) 속성에 표시됩니다. 클라이언트가 cva\_attrs에 suppattr\_exclcreat에 없는 속성을 설정하려고 시도하는 경우 서버는 NFS4ERR\_INVAL을 반환해야 합니다. 응답 필드 attrset는 서버가 cva\_attrs에서 설정한 속성과 서버가 검증자를 저장하는 데 사용한 속성을 모두 나타냅니다. 섹션 18.16.4에 설명된 대로 클라이언트는 cva\_attrs.attrmask를 attrset와 비교하여 검증자를 저장하는 데 사용된 속성을 결정할 수 있습니다.\(MUST\)

영구 세션 및 pNFS를 추가하면 일부 조건에서는 EXCLUSIVE4를 클라이언트에서 사용하거나 서버에서 지원하면 안 됩니다. 다음 표에는 NFSv4.1 구현을 위한 적절하고 의무적인 배타적 생성 방법이 요약되어 있습니다.\(MUST NOT\)

```text
     +=============+==========+==============+=======================+
     | Persistent  | Server   | Server       | Client Allowed        |
     | Reply Cache | Supports | REQUIRED     |                       |
     | Enabled     | pNFS     |              |                       |
     +=============+==========+==============+=======================+
     | no          | no       | EXCLUSIVE4_1 | EXCLUSIVE4_1 (SHOULD) |
     |             |          | and          | or EXCLUSIVE4 (SHOULD |
     |             |          | EXCLUSIVE4   | NOT)                  |
     +-------------+----------+--------------+-----------------------+
     | no          | yes      | EXCLUSIVE4_1 | EXCLUSIVE4_1          |
     +-------------+----------+--------------+-----------------------+
     | yes         | no       | GUARDED4     | GUARDED4              |
     +-------------+----------+--------------+-----------------------+
     | yes         | yes      | GUARDED4     | GUARDED4              |
     +-------------+----------+--------------+-----------------------+

              Table 18: Required Methods for Exclusive Create
```

CREATE\_SESSION4\_FLAG\_PERSIST가 CREATE\_SESSION 결과에 설정된 경우 응답 캐시는 지속됩니다\(섹션 18.36 참조\). EXCHGID4\_FLAG\_USE\_PNFS\_MDS 플래그가 EXCHANGE\_ID의 결과에 설정된 경우 서버는 pNFS 서버입니다\(섹션 18.35 참조\). 클라이언트가 영구 세션 또는 EXCHGID4\_FLAG\_USE\_PNFS\_MDS 클라이언트 ID에서 파생된 세션에서 EXCLUSIVE4를 사용하려고 시도하는 경우 서버는 NFS4ERR\_INVAL을 반환해야 합니다.\(MUST\)

영구 세션의 경우 배타적 생성 의미 체계는 GUARDED4를 통해 완전히 달성 가능하므로 EXCLUSIVE4 또는 EXCLUSIVE4\_1을 사용하면 안 됩니다. pNFS를 사용하는 경우 파일이 생성된 후layout\_hint 속성이 지원되지 않을 수 있습니다. 독점 파일 생성의 EXCLUSIVE4\_1 및 GUARDED 방법만 속성의 원자 설정을 허용합니다.\(MUST NOT\)

대상 디렉터리의 경우 서버는 cinfo에change\_info4 정보를 반환합니다. Change\_info4 데이터 유형의 원자 필드를 사용하면 서버는 링크 생성과 관련하여 변경 전후 속성이 원자적으로 획득되었는지 여부를 나타냅니다.

OPEN 작업은 OPEN 인수의 share\_access 및 share\_deny 필드를 사용하여 Windows 공유 예약 기능을 제공합니다. 클라이언트는 OPEN에서 필요한 share\_access 및 share\_deny 모드를 지정합니다. SHARE를 직접 지원하지 않는 클라이언트\(예: UNIX\)의 경우 예상되는 거부 값은 OPEN4\_SHARE\_DENY\_NONE입니다. OPEN 요청과 충돌하는 기존 SHARE 예약이 있는 경우 서버는 NFS4ERR\_SHARE\_DENIED 오류를 반환합니다. SHARE 의미론에 대한 추가 논의는 섹션 9.7을 참조하십시오.

각 OPEN에 대해 클라이언트는 OPEN 인수의 소유자 필드에 대한 값을 제공합니다. 소유자 필드는 open\_owner4 데이터 유형이며 clientid라는 필드와 owner라는 필드를 포함합니다. 클라이언트는 clientid 필드를 임의의 값으로 설정할 수 있으며 서버는 이를 무시해야 합니다. 대신, 서버는 COMPOUND 요청의 SEQUENCE 작업의 세션 ID에서 클라이언트 ID를 파생해야 합니다.\(MUST, MUST\)

요청의 "seqid" 필드는 NFSv4.1에서 사용되지 않지만 임의의 값일 수 있으며 서버는 이를 무시해야 합니다.\(MUST\)

클라이언트가 서버 오류로부터 상태를 복구하는 경우 OPEN 인수의 클레임 필드는 요청이 이전에 보유된 상태를 복구하려는 것임을 나타내는 데 사용됩니다.

OPEN 인수의 "클레임" 필드는 열려는 파일과 클라이언트가 소유한다고 주장하는 상태 정보를 지정하는 데 사용됩니다. 클레임 유형은 다음과 같이 7가지가 있습니다.

```text
   +======================+============================================+
   | open type            | description                                |
   +======================+============================================+
   | CLAIM_NULL, CLAIM_FH | For the client, this is a new OPEN         |
   |                      | request and there is no previous state     |
   |                      | associated with the file for the           |
   |                      | client.  With CLAIM_NULL, the file is      |
   |                      | identified by the current filehandle       |
   |                      | and the specified component name.          |
   |                      | With CLAIM_FH (new to NFSv4.1), the        |
   |                      | file is identified by just the current     |
   |                      | filehandle.                                |
   +----------------------+--------------------------------------------+
   | CLAIM_PREVIOUS       | The client is claiming basic OPEN          |
   |                      | state for a file that was held             |
   |                      | previous to a server restart.              |
   |                      | Generally used when a server is            |
   |                      | returning persistent filehandles; the      |
   |                      | client may not have the file name to       |
   |                      | reclaim the OPEN.                          |
   +----------------------+--------------------------------------------+
   | CLAIM_DELEGATE_CUR,  | The client is claiming a delegation        |
   | CLAIM_DELEG_CUR_FH   | for OPEN as granted by the server.         |
   |                      | Generally, this is done as part of         |
   |                      | recalling a delegation.  With              |
   |                      | CLAIM_DELEGATE_CUR, the file is            |
   |                      | identified by the current filehandle       |
   |                      | and the specified component name.          |
   |                      | With CLAIM_DELEG_CUR_FH (new to            |
   |                      | NFSv4.1), the file is identified by        |
   |                      | just the current filehandle.               |
   +----------------------+--------------------------------------------+
   | CLAIM_DELEGATE_PREV, | The client is claiming a delegation        |
   | CLAIM_DELEG_PREV_FH  | granted to a previous client instance;     |
   |                      | used after the client restarts.  The       |
   |                      | server MAY support CLAIM_DELEGATE_PREV     |
   |                      | and/or CLAIM_DELEG_PREV_FH (new to         |
   |                      | NFSv4.1).  If it does support either       |
   |                      | claim type, CREATE_SESSION MUST NOT        |
   |                      | remove the client's delegation state,      |
   |                      | and the server MUST support the            |
   |                      | DELEGPURGE operation.                      |
   +----------------------+--------------------------------------------+

                                  Table 19
```

유예 기간 동안 서버에 도달하는 OPEN 요청의 경우 서버는 NFS4ERR\_GRACE 오류를 반환합니다. 다음 클레임 유형은 예외입니다.

\* 클레임 유형 CLAIM\_PREVIOUS를 지정하는 OPEN 요청은 서버를 다시 시작한 후 열린 항목을 회수하는 데 사용되며 일반적으로 유예 기간 동안에만 유효합니다.

\* 클레임 유형 CLAIM\_DELEGATE\_CUR 및 CLAIM\_DELEG\_CUR\_FH를 지정하는 OPEN 요청은 유예 기간 동안과 이후에도 유효합니다. 종속된 위임을 부여하면 다른 클라이언트가 회수할 잠금과 충돌이 없음을 보장하므로 서버는 유예 기간 동안 이러한 잠금을 수신할 때 NFS4ERR\_GRACE를 반환할 필요가 없습니다.

모든 OPEN 요청에 대해 서버는 OPEN 위임을 반환할 수 있으며, 이를 통해 섹션 10.4에 설명된 대로 클라이언트에서 로컬로 추가 열기 및 닫기를 처리할 수 있습니다. 위임은 서버가 결정한다는 점에 유의하세요. 클라이언트는 특정 인스턴스에서 위임이 승인되거나 승인되지 않을 것이라고 가정해서는 안 됩니다. 두 경우 모두에 대해 항상 준비해야 합니다. 부분적인 예외는 위임 유형이 청구되는 회수\(CLAIM\_PREVIOUS\) 사례입니다. 이 경우 서버가 위임 구조에서 즉시 회수를 지정할 수 있더라도 위임은 항상 허용됩니다.

성공적인 OPEN에 의해 ​​반환된 rflags를 통해 서버는 열린 파일을 처리하는 방법을 제어하는 ​​정보를 반환할 수 있습니다.

\* OPEN4\_RESULT\_CONFIRM은 더 이상 사용되지 않으며 NFSv4.1 서버에서 반환하면 안 됩니다.\(MUST NOT\)

\* OPEN4\_RESULT\_LOCKTYPE\_POSIX는 서버의 바이트 범위 잠금 동작이 POSIX 잠금 기술의 전체 세트를 지원함을 나타냅니다\[21\]. 이를 통해 클라이언트는 바이트 범위 잠금 관리의 불일치를 처리하는 방식으로 바이트 범위 잠금 상태를 관리하도록 선택할 수 있습니다.

\* OPEN4\_RESULT\_PRESERVE\_UNLINKED는 클라이언트\(또는 다른 클라이언트\)가 파일이 열려 있는 동안 파일을 제거하는 경우 서버가 열린 파일을 보존함을 나타냅니다. 또한 서버는 서버를 다시 시작한 후 유예 기간 동안 파일을 보존할 것을 약속하여 클라이언트에게 열린 파일을 회수할 수 있는 기회를 제공합니다.

\* OPEN4\_RESULT\_MAY\_NOTIFY\_LOCK은 서버가 이 파일에 대한 잠금을 위해 CB\_NOTIFY\_LOCK 콜백을 시도할 수 있음을 나타냅니다. 이 플래그는 힌트일 뿐이며 클라이언트에서는 안전하게 무시할 수 있습니다.\(MAY\)

구성요소의 길이가 0인 경우 NFS4ERR\_INVAL이 반환됩니다. 구성 요소에는 일반 UTF-8, 문자 지원 및 이름 확인도 적용됩니다. 자세한 내용은 섹션 14.5를 참조하세요.

OPEN이 완료되고 지정된 열기 소유자가 이미 결과 파일 핸들을 열었을 때 결과는 기존 상태와 함께 새 공유 및 거부 상태를 함께 "OR"하는 것입니다. 이 경우 여러 OPEN이 완료되었더라도 CLOSE는 한 번만 수행하면 됩니다. 이러한 OPEN이 완료되면 동일한 OPEN 소유자가 보유하고 있는 기존 OPEN에 대한 예외 없이 새로운 OPEN에 대한 지분 예약 확인이 정상적으로 진행됩니다. 이 경우 stateid는 이전 열기와 일치하는 "other" 필드로 반환되는 반면 "seqid" 필드는 새 열기로 인한 변경 상태를 반영하기 위해 증가됩니다.

서버의 기본 파일 시스템이 읽기 전용 모드에서만 액세스 가능하고 OPEN 요청이 ACCESS\_WRITE 또는 ACCESS\_BOTH를 지정한 경우 서버는 NFS4ERR\_ROFS를 반환하여 읽기 전용 파일 시스템을 나타냅니다.

CREATE 작업과 마찬가지로 서버는 네 가지 속성 중 하나라도 필요하고 서버의 파일 시스템에서 지원하는 경우 소유자, 소유자 ACE, 그룹 또는 그룹 ACE를 파생해야 합니다. EXCLUSIVE4 createmode를 사용하는 OPEN의 경우 이러한 OPEN 호출에는 createattrs 필드가 포함되지 않으므로 서버에는 선택의 여지가 없습니다. 반대로, createattrs\(UNCHECKED4 또는 GUARDED4\) 또는 cva\_attrs\(EXCLUSIVE4\_1\)가 지정되고 RPC 호출 자격 증명의 주체가 파일을 생성할 권한이 없는 소유자, owner\_group 또는 ACE를 포함하는 경우 서버는 NFS4ERR\_PERM을 반환할 수 있습니다.\(MUST\)

크기를 0\(예: 잘림\)으로 지정하고 파일에 명명된 속성이 있는 OPEN의 경우 명명된 속성은 그대로 유지되며 제거되지 않습니다.

NFSv4.1은 OPEN4args의 share\_access 필드에 대한 다음과 같은 새로운 플래그를 통해 위임 획득에 대해 클라이언트에게 보다 정확한 제어를 제공합니다.

```text
   OPEN4_SHARE_ACCESS_WANT_READ_DELEG

   OPEN4_SHARE_ACCESS_WANT_WRITE_DELEG

   OPEN4_SHARE_ACCESS_WANT_ANY_DELEG

   OPEN4_SHARE_ACCESS_WANT_NO_DELEG

   OPEN4_SHARE_ACCESS_WANT_CANCEL

   OPEN4_SHARE_ACCESS_WANT_SIGNAL_DELEG_WHEN_RESRC_AVAIL

   OPEN4_SHARE_ACCESS_WANT_PUSH_DELEG_WHEN_UNCONTENDED
```

\(share\_access & OPEN4\_SHARE\_ACCESS\_WANT\_DELEG\_MASK\)가 0이 아닌 경우 클라이언트는 다음 중 하나만 지정하게 됩니다.

```text
   OPEN4_SHARE_ACCESS_WANT_READ_DELEG

   OPEN4_SHARE_ACCESS_WANT_WRITE_DELEG

   OPEN4_SHARE_ACCESS_WANT_ANY_DELEG

   OPEN4_SHARE_ACCESS_WANT_NO_DELEG

   OPEN4_SHARE_ACCESS_WANT_CANCEL
```

그렇지 않은 경우 클라이언트는 위임에 대한 희망 여부를 나타내지 않으며 서버는 OPEN 응답에서 위임을 반환할 수도 있고 반환하지 않을 수도 있습니다.\(MAY\)

서버가 새로운 \_WANT\_ 플래그를 지원하고 클라이언트가 하나 이상의 새 플래그를 보내는 경우 서버가 위임을 반환하지 않는 경우 OPEN\_DELEGATE\_NONE\_EXT 위임 유형을 반환해야 합니다. 응답의 ond\_why 필드는 위임이 반환되지 않은 이유를 나타내며 다음 중 하나입니다.\(MUST\)

WND4\_NOT\_WANTED

- 클라이언트가 OPEN4\_SHARE\_ACCESS\_WANT\_NO\_DELEG를 지정했습니다.

WND4\_CONTENTION

- 충돌하는 위임이 있거나 파일이 열려 있습니다.

WND4\_RESOURCE

- 리소스 제한으로 인해 서버가 위임을 허용할 수 없습니다.

WND4\_NOT\_SUPP\_FTYPE

- 서버는 이 파일 형식에 대한 위임을 지원하지 않습니다.

WND4\_WRITE\_DELEG\_NOT\_SUPP\_FTYPE

- 서버는 이 파일 형식에 대한 OPEN\_DELEGATE\_WRITE 위임을 지원하지 않습니다.

WND4\_NOT\_SUPP\_UPGRADE

- 서버는 OPEN\_DELEGATE\_READ 위임에서 OPEN\_DELEGATE\_WRITE 위임으로의 원자성 업그레이드를 지원하지 않습니다.

WND4\_NOT\_SUPP\_DOWNGRADE

- 서버는 OPEN\_DELEGATE\_WRITE 위임에서 OPEN\_DELEGATE\_READ 위임으로의 원자적 다운그레이드를 지원하지 않습니다.

WND4\_취소됨

- 클라이언트가 OPEN4\_SHARE\_ACCESS\_WANT\_CANCEL을 지정했으며 이제 이 파일 개체에 대한 "원하는" 항목이 취소되었습니다.

WND4\_IS\_DIR

- 지정된 파일 객체가 디렉터리이고 작업이 OPEN 또는 WANT\_DELEGATION이므로 디렉터리에 대한 위임을 지원하지 않습니다.

OPEN4\_SHARE\_ACCESS\_WANT\_READ\_DELEG, OPEN\_SHARE\_ACCESS\_WANT\_WRITE\_DELEG 또는 OPEN\_SHARE\_ACCESS\_WANT\_ANY\_DELEG는 각각 클라이언트가 OPEN\_DELEGATE\_READ, OPEN\_DELEGATE\_WRITE 또는 OPEN4\_SHARE\_ACCESS\_READ, OPEN4\_SHARE\_ACCESS\_WR 중 어느 것에 관계없이 위임을 원한다는 것을 의미합니다. ITE 또는 OPEN4\_SHARE\_ACCESS\_BOTH가 설정되었습니다. 클라이언트가 파일에 OPEN\_DELEGATE\_READ 위임을 갖고 있고 OPEN\_DELEGATE\_WRITE 위임을 요청하는 경우 클라이언트는 OPEN\_DELEGATE\_READ 위임을 OPEN\_DELEGATE\_WRITE 위임으로 원자성 업그레이드를 요청하는 것입니다. 클라이언트의 파일에 OPEN\_DELEGATE\_WRITE 위임이 있고 OPEN\_DELEGATE\_READ 위임을 요청하는 경우 클라이언트는 OPEN\_DELEGATE\_READ 위임으로의 원자적 다운그레이드를 요청하는 것입니다. 서버는 원자적 업그레이드 또는 다운그레이드를 지원할 수 있습니다. 그렇다면 클라이언트가 현재 가지고 있는 위임 유형과 다른 OPEN\_DELEGATE\_READ 또는 OPEN\_DELEGATE\_WRITE의 반환된 delegation\_type은 성공적인 업그레이드 또는 다운그레이드를 나타냅니다. 서버가 원자 위임 업그레이드 또는 다운그레이드를 지원하지 않는 경우 ond\_why는 WND4\_NOT\_SUPP\_UPGRADE 또는 WND4\_NOT\_SUPP\_DOWNGRADE로 설정됩니다.\(MAY\)

OPEN4\_SHARE\_ACCESS\_WANT\_NO\_DELEG는 클라이언트가 위임을 원하지 않음을 의미합니다.

OPEN4\_SHARE\_ACCESS\_WANT\_CANCEL은 클라이언트가 위임을 원하지 않으며 이전에 등록된 위임에 대해 "원함"을 취소하려고 함을 의미합니다.

클라이언트는 OPEN4\_SHARE\_ACCESS\_WANT\_SIGNAL\_DELEG\_WHEN\_RESRC\_AVAIL 및 OPEN4\_SHARE\_ACCESS\_WANT\_PUSH\_DELEG\_WHEN\_UNCONTENDED 중 하나 또는 둘 다를 설정할 수 있습니다. 그러나 다음 중 하나가 설정되지 않으면 아무런 효과가 없습니다.

```text
   *  OPEN4_SHARE_ACCESS_WANT_READ_DELEG

   *  OPEN4_SHARE_ACCESS_WANT_WRITE_DELEG

   *  OPEN4_SHARE_ACCESS_WANT_ANY_DELEG
```

클라이언트가 OPEN4\_SHARE\_ACCESS\_WANT\_SIGNAL\_DELEG\_WHEN\_RESRC\_AVAIL을 지정하는 경우 OPEN 결과에 위임이 포함되지 않은 경우 위임에 대한 "원함"을 등록하려고 합니다. 그렇다면 서버는 리소스 부족으로 인해 위임을 거부하고 나중에 CB\_RECALLABLE\_OBJ\_AVAIL 작업을 통해 리소스 제한 조건이 완화되었음을 클라이언트에 알릴 수 있습니다. 서버는 결과의 delegation\_type을 OPEN\_DELEGATE\_NONE\_EXT로, ond\_why를 WND4\_RESOURCE로, ond\_server\_will\_signal\_avail을 TRUE로 설정하여 향후 CB\_RECALLABLE\_OBJ\_AVAIL 작업을 보내려고 한다고 클라이언트에 알립니다. ond\_server\_will\_signal\_avail이 TRUE로 설정된 경우 서버는 나중에 CB\_RECALLABLE\_OBJ\_AVAIL 작업을 보내야 합니다.\(MAY, MUST\)

클라이언트가 OPEN4\_SHARE\_ACCESS\_WANT\_SIGNAL\_DELEG\_WHEN\_UNCONTENDED를 지정하는 경우 OPEN 결과에 위임이 포함되지 않은 경우 위임에 대한 "원함"을 등록하려고 합니다. 그렇다면 서버는 경합으로 인해 위임을 거부하고 나중에 CB\_PUSH\_DELEG 작업을 통해 경합 조건이 완화되었음을 클라이언트에 알릴 수 있습니다. 서버는 결과의 delegation\_type을 OPEN\_DELEGATE\_NONE\_EXT로, ond\_why를 WND4\_CONTENTION으로, ond\_server\_will\_push\_deleg를 TRUE로 설정하여 향후 CB\_PUSH\_DELEG 작업을 보내겠다고 클라이언트에 알립니다. ond\_server\_will\_push\_deleg가 TRUE이면 서버는 나중에 CB\_PUSH\_DELEG 작업을 보내야 합니다.\(MAY, MUST\)

클라이언트가 이전에 파일에 대한 위임 원하는 항목을 등록한 다음 동일한 파일에 대한 위임 원하는 항목을 등록하라는 요청을 보내는 경우 서버는 반드시 새로운 오류 NFS4ERR\_DELEG\_ALREADY\_WANTED를 반환해야 합니다. 클라이언트가 동일한 파일에 대해 다른 유형의 위임을 등록하려는 경우 기존 위임 WANT를 취소해야 합니다.\(MUST, MUST\)

---
#### **18.16.4.  IMPLEMENTATION**

영구 세션이 없는 경우 클라이언트는 How 매개 변수를 EXCLUSIVE4 또는 EXCLUSIVE4\_1로 설정하여 단독 생성을 호출합니다. 이러한 경우 클라이언트는 고유하다고 합리적으로 예상할 수 있는 검증자를 제공합니다. 클라이언트 식별자\(아마도 클라이언트 네트워크 주소\)와 클라이언트에 의해 생성된 고유 번호\(아마도 RPC 트랜잭션 식별자\)의 조합이 적절할 수 있습니다.

객체가 존재하지 않으면 서버는 객체를 생성하고 검증자를 안정적인 저장소에 저장합니다. 임의의 파일 속성을 저장하기 위한 메커니즘을 제공하지 않는 파일 시스템의 경우 서버는 객체 메타데이터의 하나 이상의 요소를 사용하여 검증자를 저장할 수 있습니다. 요청 재전송 시 오류가 발생하는 것을 방지하기 위해 검증자는 안정적인 저장소에 저장되어야 합니다. 배타적 의미 체계가 애플리케이션에 중요하기 때문에 배타적 생성이 수행되고 있다고 가정합니다. 예상되는 사용법으로 인해 배타적 CREATE는 검증자 저장을 위해 서버의 응답 캐시에만 의존하지 않습니다. 비지속적 응답 캐시는 충돌 후에도 유지되지 않으며, 네트워크 파티션이 임대 시간을 초과하면 세션 및 응답 캐시가 삭제되어 실패 창이 열릴 수 있습니다.\(MUST\)

NFSv4.1 서버는 파일의 RECOMMENDED 또는 REQUIRED 속성에 검증자를 저장해서는 안 됩니다. 그렇다면 서버는 검증자를 저장하기 위해 time\_modify\_set 또는 time\_access\_set를 사용해야 합니다. 서버는 다음 속성에 검증자를 저장해서는 안 됩니다.\(MUST, SHOULD, SHOULD NOT\)

```text
      acl (it is desirable for access control to be established at
      creation),

      dacl (ditto),

      mode (ditto),

      owner (ditto),

      owner_group (ditto),

      retentevt_set (it may be desired to establish retention at
      creation)

      retention_hold (ditto),

      retention_set (ditto),

      sacl (it is desirable for auditing control to be established at
      creation),

      size (on some servers, size may have a limited range of values),

      mode_set_masked (as with mode),

         and
```

- time\_creation\(파일 생성 시 의미 있는 파일 생성을 설정해야 함\).

서버의 또 다른 대안은 명명된 속성을 사용하여 검증자를 저장하는 것입니다.

EXCLUSIVE4 생성 메소드는 EXCLUSIVE4 생성을 처리할 때 초기 속성을 지정하지 않기 때문에 서버는

\* 파일 소유자를 요청 RPC 헤더의 자격 증명에 해당하는 소유자로 설정해야 합니다.\(SHOULD\)

\* 파일 소유자가 아닌 다른 사람에게 파일 액세스 제어를 맡겨서는 안 됩니다.\(SHOULD NOT\)

검증자를 안정적인 저장소에 커밋해야 한다는 요구 사항 때문에 서버가 배타적 생성 의미 체계를 지원할 수 없는 경우 NFS4ERR\_NOTSUPP 오류와 함께 OPEN 요청이 실패해야 합니다.

배타적 CREATE 요청 중에 객체가 이미 존재하는 경우 서버는 객체의 검증자를 재구성하고 이를 요청의 검증자와 비교합니다. 일치하면 서버는 요청을 성공으로 처리합니다. 요청은 응답이 손실되고 서버 중복 요청 캐시 메커니즘이 감지하지 못한 이전의 성공적인 요청의 중복인 것으로 추정됩니다. 검증자가 일치하지 않으면 NFS4ERR\_EXIST 상태로 요청이 거부됩니다.

클라이언트가 성공적인 배타적 생성을 수행한 후 attrset 응답은 검증자를 저장하는 데 사용된 속성을 나타냅니다. EXCLUSIVE4를 사용한 경우 attrset에 설정된 속성이 검증자에 사용되었습니다. EXCLUSIVE4\_1이 사용된 경우 클라이언트는 attrset을 cva\_attrs.attrmask와 비교하여 검증자에 사용되는 속성을 결정합니다. 전자에 설정되었지만 후자에 설정되지 않은 모든 비트는 검증자를 저장하는 데 사용되는 속성을 식별합니다. 클라이언트는 검증자를 저장하는 데 사용되는 속성을 설정하기 위해 즉시 SETATTR을 보내야 합니다. 그렇게 하기 전까지는 검증자를 저장하는 데 사용된 속성을 신뢰할 수 없습니다. 후속 SETATTR은 OPEN과 동일한 COMPOUND 요청에서 발생해서는 안 됩니다.\(MUST, MUST NOT\)

영구 세션을 사용하지 않는 한 GUARDED4 속성을 사용하면 정확히 한 번 의미 체계가 제공되지 않습니다. 특히 응답이 손실되고 서버가 요청의 재전송을 감지하지 못하는 경우 생성이 성공적으로 수행되었더라도 NFS4ERR\_EXIST로 인해 작업이 실패할 수 있습니다. 클라이언트는 응용 프로그램이 단독 생성을 요청하지 않았지만 파일이 열릴 때 파일을 자르도록 요청한 경우 이 동작을 사용합니다. 클라이언트가 시간 초과되어 생성 요청을 재전송하는 경우 클라이언트는 GUARDED4를 사용하여 생성, 쓰기, 생성\(재전송\)과 같은 시퀀스가 ​​발생하지 않도록 방지할 수 있습니다.

SHARE 예약의 경우 표현식 값\(share\_access & \~OPEN4\_SHARE\_ACCESS\_WANT\_DELEG\_MASK\)은 OPEN4\_SHARE\_ACCESS\_READ, OPEN4\_SHARE\_ACCESS\_WRITE 또는 OPEN4\_SHARE\_ACCESS\_BOTH 중 하나여야 합니다. 그렇지 않은 경우 서버는 NFS4ERR\_INVAL을 반환해야 합니다. share\_deny 값은 OPEN4\_SHARE\_DENY\_NONE, OPEN4\_SHARE\_DENY\_READ, OPEN4\_SHARE\_DENY\_WRITE 또는 OPEN4\_SHARE\_DENY\_BOTH 중 하나여야 합니다. 그렇지 않은 경우 서버는 NFS4ERR\_INVAL을 반환해야 합니다.\(MUST, MUST, MUST, MUST\)

클라이언트는 share\_access 값\(OPEN4\_SHARE\_ACCESS\_READ, OPEN4\_SHARE\_ACCESS\_WRITE 또는 OPEN4\_SHARE\_ACCESS\_BOTH\)을 기반으로 요청자가 지정된 작업을 수행할 수 있는 적절한 액세스 권한을 가지고 있는지 확인해야 합니다. 이는 일반적으로 현재 요청자의 파일에 ACL 액세스 규칙을 적용한 결과입니다. 그러나 ACCESS 작업과 마찬가지로 클라이언트는 서버의 결정을 추측하려고 시도해서는 안 됩니다. 액세스 권한이 변경될 수 있고 ACL 프레임워크 외부에서 서버 관리 제어가 적용될 수 있기 때문입니다. 요청자의 READ 또는 WRITE 작업이 승인되지 않은 경우\(share\_access 값에 따라\) 서버는 NFS4ERR\_ACCESS를 반환해야 합니다.\(MUST\)

클라이언트 ID가 EXCHANGE\_ID에 대한 응답에 설정된 EXCHGID4\_FLAG\_BIND\_PRINC\_STATEID 기능으로 생성되지 않은 경우 서버는 열린 파일에 대해 전송된 READ 및 WRITE가 OPEN 자체와 동일한 자격 증명을 가지며 서버가 다음과 같은 요구 사항을 부과해서는 안 됩니다. 읽기 및 쓰기 자체에 대한 액세스 검사를 수행해야 합니다. 그렇지 않고 EXCHANGE\_ID에 대한 응답에 EXCHGID4\_FLAG\_BIND\_PRINC\_STATEID가 설정된 경우 한 가지 예외를 제외하고 OPEN 요청에 사용된 자격 증명은 READ 및 WRITE에 사용된 자격 증명과 일치해야 하며 READ 및 WRITE의 상태 ID는 일치하거나 다음에서 파생되어야 합니다. OPEN에 대한 답변의 stateid입니다. SP4\_SSV 또는 SP4\_MACH\_CRED 상태 보호가 사용되고 EXCHANGE\_ID의 spo\_must\_allow 결과에 READ 및/또는 WRITE 작업이 포함되는 경우는 예외입니다. 이 경우 머신 또는 SSV 자격 증명은 READ 및/또는 WRITE를 보낼 수 있습니다. 섹션 18.35를 참조하십시오.\(MUST NOT, MUST\)

OPEN에 제공된 구성 요소가 심볼릭 링크인 경우 NFS4ERR\_SYMLINK 오류가 클라이언트에 반환되고 디렉터리인 경우 NFS4ERR\_ISDIR 오류가 반환됩니다. 구성 요소가 둘 중 하나가 아니고 일반 파일이 아닌 경우 NFS4ERR\_WRONG\_TYPE 오류가 반환됩니다. 현재 파일 핸들이 디렉터리가 아니면 NFS4ERR\_NOTDIR 오류가 반환됩니다.

OPEN4\_RESULT\_PRESERVE\_UNLINKED 결과 플래그를 사용하면 클라이언트가 파일을 제거한 후 열린 파일의 이름을 ".nfs<고유 값\>"으로 바꾸는 일반적인 구현 관행을 피할 수 있습니다. 서버가 OPEN4\_RESULT\_PRESERVE\_UNLINKED를 반환한 후 클라이언트가 파일의 링크 수를 0으로 줄이는 REMOVE 작업을 보내는 경우 서버는 파일의 numlinks 속성에 대해 0 값을 보고해야 합니다.\(SHOULD\)

다른 클라이언트가 열기 수행과 충돌하는 파일 열기 위임을 갖고 있는 경우\(때때로 지정된 share\_access 또는 share\_deny 값에 따라\) 위임을 반드시 회수해야 하며 해당 위임이 반환될 때까지 작업을 진행할 수 없습니다. 취소되었습니다. 매우 빠르게 발생하는 경우를 제외하고 위임이 미해결 상태로 유지되는 동안 요청에 하나 이상의 NFS4ERR\_DELAY 오류가 반환됩니다. OPEN\_DELEGATE\_WRITE 위임의 경우 다른 클라이언트에 의한 모든 열기가 충돌하는 반면, OPEN\_DELEGATE\_READ 위임의 경우 다음 특성 중 하나를 사용하는 열기만 충돌하는 것으로 간주됩니다.\(MUST\)

\* share\_access 값에는 비트가 포함됩니다.

- OPEN4\_SHARE\_ACCESS\_WRITE.

\* share\_deny 값은 OPEN4\_SHARE\_DENY\_READ 또는 OPEN4\_SHARE\_DENY\_BOTH를 지정합니다.

\* OPEN4\_CREATE는 UNCHECKED4와 함께 지정되고, 크기 속성은 0\(잘림용\)으로 지정되며, 기존 파일이 잘립니다.

OPEN4\_CREATE가 지정되고 파일이 존재하지 않으며 현재 파일 핸들이 다른 클라이언트가 디렉터리 위임을 보유한 디렉터리를 지정하는 경우 알림을 보내 상황을 해결할 수 있는 위임이 아닌 이상 위임을 회수해야 합니다. 위임이 반환되거나 취소될 때까지 작업을 진행할 수 없습니다. 매우 빠르게 발생하는 경우를 제외하고 위임이 미해결 상태로 유지되는 동안 요청에 하나 이상의 NFS4ERR\_DELAY 오류가 반환됩니다.\(MUST\)

OPEN4\_CREATE가 지정되고 파일이 존재하지 않으며 현재 파일 핸들이 하나 이상의 디렉터리 위임이 존재하는 디렉터리를 지정하는 경우 해당 위임이 그러한 알림을 요청할 때 이 작업의 결과로 NOTIFY4\_ADD\_ENTRY가 생성됩니다.

---
##### **18.16.4.1.  Warning to Client Implementors**

OPEN은 클라이언트가 사용할 파일 핸들을 생성한다는 점에서 LOOKUP과 유사합니다. 그러나 LOOKUP과 달리 OPEN은 파일 핸들에 서버 상태를 생성합니다. 일반적인 상황에서 클라이언트는 CLOSE 작업을 통해서만 이 상태를 해제할 수 있습니다. CLOSE는 현재 파일 핸들을 사용하여 닫을 파일을 결정합니다. 따라서 클라이언트는 동일한 COMPOUND 프로시저에서 GETFH 작업이 포함된 모든 OPEN 작업을 따라야 합니다. 그러면 CLOSE를 적절하게 사용할 수 있도록 클라이언트에 파일 핸들이 제공됩니다.\(MUST\)

다른 클라이언트가 동일한 파일에 대해 충돌하는 액세스를 시도하지 않는 한 서버는 무기한으로 상태를 유지할 수 있으므로 단순히 파일 임대가 만료될 때까지 기다리는 것만으로는 충분하지 않습니다.

```text
   See also Section 2.10.6.4.
```

---
### **18.17.  Operation 19: OPENATTR - Open Named Attribute Directory**
---
#### **18.17.1.  ARGUMENTS**

```text
   struct OPENATTR4args {
           /* CURRENT_FH: object */
           bool    createdir;
   };
```

---
#### **18.17.2.  RESULTS**

```text
   struct OPENATTR4res {
           /*
            * If status is NFS4_OK,
            *   new CURRENT_FH: named attribute
            *                   directory
            */
           nfsstat4        status;
   };
```

---
#### **18.17.3.  DESCRIPTION**

OPENATTR 작업은 현재 파일 핸들과 연관된 명명된 속성 디렉터리의 파일 핸들을 얻는 데 사용됩니다. OPENATTR의 결과는 NF4ATTRDIR 유형의 객체에 대한 파일 핸들이 됩니다. 이 파일 핸들에서 READDIR 및 LOOKUP 작업을 사용하여 원래 파일 시스템 개체와 관련된 다양한 명명된 속성에 대한 파일 핸들을 얻을 수 있습니다. 명명된 속성 디렉터리 내에서 반환된 파일 핸들은 NF4NAMEDATTR 유형의 개체를 지정합니다.

Createdir 인수를 사용하면 클라이언트는 명명된 속성 디렉터리가 OPENATTR 작업의 결과로 생성되어야 하는지 여부를 나타낼 수 있습니다. 일부 클라이언트는 객체에 명명된 속성이 존재하는지 확인하기 위해 createir에 대해 FALSE 값과 함께 OPENATTR 작업을 사용할 수 있습니다. 존재하지 않는 경우 NFS4ERR\_NOENT가 반환됩니다. Createdir의 값이 TRUE이고 명명된 속성 디렉터리가 없으면 하나가 생성되고 해당 파일 핸들이 현재 파일 핸들이 됩니다. 반면에createir의 값이 TRUE이고 명명된 속성 디렉터리가 이미 존재하는 경우 오류가 발생하지 않으며 기존 디렉터리의 파일 핸들이 현재 파일 핸들이 됩니다. 명명된 속성 디렉토리의 생성은 서버가 이러한 방식으로 명명된 속성 지원을 구현했으며 이 정의에 따라 그렇게 할 필요가 없다고 가정합니다.

현재 파일 핸들이 NF4NAMEDATTR\(명명된 속성\) 또는 NF4ATTRDIR\(명명된 속성 디렉터리\) 유형의 객체를 지정하는 경우 NFS4ERR\_WRONG\_TYPE 오류가 클라이언트에 반환됩니다. 명명된 속성 또는 명명된 속성 디렉터리는 자체 명명된 속성을 가져서는 안 됩니다.\(MUST NOT\)

---
#### **18.17.4.  IMPLEMENTATION**

서버가 현재 파일 핸들에 대해 명명된 속성을 지원하지 않으면 NFS4ERR\_NOTSUPP 오류가 클라이언트에 반환됩니다.

---
### **18.18.  Operation 21: OPEN_DOWNGRADE - Reduce Open File Access**
---
#### **18.18.1.  ARGUMENTS**

```text
   struct OPEN_DOWNGRADE4args {
           /* CURRENT_FH: opened file */
           stateid4        open_stateid;
           seqid4          seqid;
           uint32_t        share_access;
           uint32_t        share_deny;
   };
```

---
#### **18.18.2.  RESULTS**

```text
   struct OPEN_DOWNGRADE4resok {
           stateid4        open_stateid;
   };

   union OPEN_DOWNGRADE4res switch(nfsstat4 status) {
    case NFS4_OK:
           OPEN_DOWNGRADE4resok    resok4;
    default:
            void;
   };
```

---
#### **18.18.3.  DESCRIPTION**

이 작업은 지정된 열기에 대한 액세스 및 거부 상태를 조정하는 데 사용됩니다. 이는 특정 공개 소유자가 서로 다른 액세스 및 거부 값을 사용하여 동일한 파일을 여러 번 열 때 필요합니다. 이 상황에서 열기 중 하나를 닫으면 더 이상 유효하지 않은 열기와 관련된 비트를 제거하기 위해 적절한 share\_access 및 share\_deny 플래그가 변경될 수 있습니다.

표현식\(share\_access & \~OPEN4\_SHARE\_ACCESS\_WANT\_DELEG\_MASK\)의 유효한 값은 OPEN4\_SHARE\_ACCESS\_READ, OPEN4\_SHARE\_ACCESS\_WRITE 또는 OPEN4\_SHARE\_ACCESS\_BOTH입니다. 클라이언트가 다른 값을 지정하면 서버는 NFS4ERR\_INVAL로 응답해야 합니다.\(MUST\)

share\_deny 필드의 유효한 값은 OPEN4\_SHARE\_DENY\_NONE, OPEN4\_SHARE\_DENY\_READ, OPEN4\_SHARE\_DENY\_WRITE 또는 OPEN4\_SHARE\_DENY\_BOTH입니다. 클라이언트가 다른 값을 지정하면 서버는 NFS4ERR\_INVAL로 응답해야 합니다.\(MUST\)

share\_access 및 share\_deny의 유효한 값을 확인한 후 서버는 파일의 현재 액세스 및 거부 모드를 다음 제약 조건에 따라 share\_access 및 share\_deny로 바꿉니다.

\* share\_access의 비트는 다음의 합집합과 같아야 합니다.

- 현재 파일의 현재 오픈 소유자에 대해 유효한 OPEN의 일부 하위 집합에 대해 지정된 share\_access 비트\(OPEN4\_SHARE\_WANT\_\* 비트는 포함하지 않음\).\(SHOULD\)

\* share\_deny의 비트는 현재 파일의 현재 오픈 소유자에 대해 유효한 OPEN의 일부 하위 집합에 대해 지정된 share\_deny 비트의 합집합과 동일해야 합니다.\(SHOULD\)

위의 제약 조건이 준수되지 않으면 서버는 NFS4ERR\_INVAL 오류를 반환해야 합니다. share\_access 및 share\_deny 비트는 클라이언트 또는 서버 구현에 결함이 없으면 이미 부여된 비트의 하위 집합이어야 하므로 공유 예약 충돌로 인해 OPEN\_DOWNGRADE 요청이 거부될 수 없습니다.\(SHOULD\)

seqid 인수는 NFSv4.1에서 사용되지 않으며 임의의 값일 수 있으며 서버에서 무시되어야 합니다.\(MUST\)

성공하면 현재 파일 핸들이 해당 값을 유지합니다.

---
#### **18.18.4.  IMPLEMENTATION**

OPEN\_DOWNGRADE 작업을 통해 이전에는 허용되지 않았던 OPEN\_DELEGATE\_READ 위임을 허용할 수 있습니다. 서버는 보류 중인 위임 요청이 있는 경우 즉시 응답하도록 선택하거나 나중에 상황에 응답할 수 있습니다.

---
### **18.19.  Operation 22: PUTFH - Set Current Filehandle**
---
#### **18.19.1.  ARGUMENTS**

```text
   struct PUTFH4args {
           nfs_fh4         object;
   };
```

---
#### **18.19.2.  RESULTS**

```text
   struct PUTFH4res {
           /*
            * If status is NFS4_OK,
            *    new CURRENT_FH: argument to PUTFH
            */
           nfsstat4        status;
   };
```

---
#### **18.19.3.  DESCRIPTION**

이 작업은 현재 파일 핸들을 인수로 제공된 파일 핸들로 바꿉니다. 현재 stateid를 지웁니다.

요청자가 사용하는 보안 메커니즘이 이 작업에 제공된 파일 핸들의 요구 사항을 충족하지 않는 경우 서버는 NFS4ERR\_WRONGSEC를 반환해야 합니다.\(MUST\)

현재 파일 핸들에 대한 자세한 내용은 섹션 16.2.3.1.1을 참조하세요.

현재 stateid에 대한 자세한 내용은 섹션 16.2.3.1.2를 참조하세요.

---
#### **18.19.4.  IMPLEMENTATION**

이 작업은 NFS 요청에서 동일한 COMPOUND 요청에 따르는 파일 액세스 작업에 대한 컨텍스트를 설정하는 데 사용됩니다.

---
### **18.20.  Operation 23: PUTPUBFH - Set Public Filehandle**
---
#### **18.20.1.  ARGUMENT**

```text
   void;
```

---
#### **18.20.2.  RESULT**

```text
   struct PUTPUBFH4res {
           /*
            * If status is NFS4_OK,
            *   new CURRENT_FH: public fh
            */
           nfsstat4        status;
   };
```

---
#### **18.20.3.  DESCRIPTION**

이 작업은 현재 파일 핸들을 서버 네임스페이스의 공용 파일 핸들을 나타내는 파일 핸들로 바꿉니다. 이 파일 핸들은 서버의 다른 디렉터리와 연결될 수 있는 "루트" 파일 핸들과 다를 수 있습니다.

PUTPUBFH는 현재 상태 ID도 지웁니다.

공개 파일 핸들은 RFC 2054 \[49\], RFC 2055 \[50\] 및 RFC 2224 \[61\]에 구현된 개념을 나타냅니다. NFSv4.1의 목적은 공개 파일 핸들\(PUTPUBFH 작업으로 표시\)을 NFSv3과의 WebNFS 서버 호환성을 제공하는 방법으로 사용하는 것입니다.

공용 파일 핸들과 루트 파일 핸들\(PUTROOTFH 작업으로 표시됨\)은 동일해야 합니다. 공용 파일 핸들과 루트 파일 핸들이 동일하지 않으면 공용 파일 핸들에 해당하는 디렉터리는 루트 파일 핸들에 해당하는 디렉터리의 하위 항목이어야 합니다.\(SHOULD, MUST\)

현재 파일 핸들에 대한 자세한 내용은 섹션 16.2.3.1.1을 참조하세요.

현재 stateid에 대한 자세한 내용은 섹션 16.2.3.1.2를 참조하세요.

---
#### **18.20.4.  IMPLEMENTATION**

이 작업은 NFS 요청에서 동일한 COMPOUND 요청에 따르는 파일 액세스 작업에 대한 컨텍스트를 설정하는 데 사용됩니다.

NFSv3 공용 파일 핸들을 사용하면 클라이언트는 LOOKUP에 제공된 경로 이름을 서버 루트에 대한 절대 경로 또는 공용 파일 핸들에 대한 상대 경로로 평가해야 하는지 여부를 지정할 수 있습니다. RFC 2224 \[61\]에는 기능에 대한 추가 논의가 포함되어 있습니다. NFSv4.1에서는 해당 유형의 사양을 LOOKUP 작업에서 직접 사용할 수 없습니다. 그 이유는 절대 대 상대를 지정하는 데 필요한 구성 요소 구분 기호가 NFSv4에서 허용되지 않기 때문입니다. 따라서 클라이언트는 PUTROOTFH 또는 PUTPUBFH의 사용이 각각 NFS URL의 절대 또는 상대 평가를 나타내도록 요청을 구성할 책임이 있습니다.

RFC 2224 \[61\]에는 절대 평가의 사용과 사용 가능한 네임스페이스의 양과 관련하여 서버가 해당 평가에 적용할 수 있는 제한과 관련하여 언급된 경고가 있습니다. 이와 동일한 경고가 NFSv4.1에도 적용됩니다. 따라서 서버 구현 세부 사항으로 인해 NFSv3 절대 공용 파일 핸들 조회는 NFSv4.1 절대 확인과 다르게 동작할 수 있습니다.

공용 파일 핸들과 경로 이름의 오버로드를 사용하는 RFC 2755 \[62\]에 설명된 보안 협상 형식이 있습니다. 파일 핸들은 특별한 의미로 오버로드되지 않고 따라서 NFSv3과 동일한 프레임워크를 제공하지 않으므로 NFSv4.1에서는 이 방법을 사용할 수 없습니다. 따라서 클라이언트는 섹션 2.6에 설명된 보안 협상 메커니즘을 사용해야 합니다.

---
### **18.21.  Operation 24: PUTROOTFH - Set Root Filehandle**
---
#### **18.21.1.  ARGUMENTS**

```text
   void;
```

---
#### **18.21.2.  RESULTS**

```text
   struct PUTROOTFH4res {
           /*
            * If status is NFS4_OK,
            *   new CURRENT_FH: root fh
            */
           nfsstat4        status;
   };
```

---
#### **18.21.3.  DESCRIPTION**

이 작업은 현재 파일 핸들을 서버 네임스페이스의 루트를 나타내는 파일 핸들로 바꿉니다. 이 파일 핸들에서 LOOKUP 작업은 서버의 다른 파일 핸들을 찾을 수 있습니다. 이 파일 핸들은 서버의 다른 디렉터리와 연결될 수 있는 "공용" 파일 핸들과 다를 수 있습니다.

PUTROOTFH는 현재 stateid도 지웁니다.

현재 파일 핸들에 대한 자세한 내용은 섹션 16.2.3.1.1을 참조하세요.

현재 stateid에 대한 자세한 내용은 섹션 16.2.3.1.2를 참조하세요.

---
#### **18.21.4.  IMPLEMENTATION**

이 작업은 NFS 요청에서 동일한 COMPOUND 요청에 따르는 파일 액세스 작업에 대한 컨텍스트를 설정하는 데 사용됩니다.

---
### **18.22.  Operation 25: READ - Read from File**
---
#### **18.22.1.  ARGUMENTS**

```text
   struct READ4args {
           /* CURRENT_FH: file */
           stateid4        stateid;
           offset4         offset;
           count4          count;
   };
```

---
#### **18.22.2.  RESULTS**

```text
   struct READ4resok {
           bool            eof;
           opaque          data<>;
   };

   union READ4res switch (nfsstat4 status) {
    case NFS4_OK:
            READ4resok     resok4;
    default:
            void;
   };
```

---
#### **18.22.3.  DESCRIPTION**

READ 작업은 현재 파일 핸들로 식별되는 일반 파일에서 데이터를 읽습니다.

클라이언트는 READ가 시작될 위치의 오프셋과 읽을 바이트 수를 제공합니다. 오프셋 0은 파일 시작 부분부터 데이터를 읽는다는 의미입니다. 오프셋이 파일 크기보다 크거나 같으면 데이터 길이가 0으로 설정되고 eof가 TRUE로 설정된 NFS4\_OK 상태가 반환됩니다. READ에는 액세스 권한 검사가 적용됩니다.

클라이언트가 카운트 값을 0으로 지정하면 READ가 성공하고 액세스 권한 확인에 따라 0바이트의 데이터를 다시 반환합니다. 서버는 클라이언트가 지정한 것보다 적은 바이트를 반환하도록 선택할 수 있습니다. 클라이언트는 이 조건을 확인하고 적절하게 처리해야 합니다.

특수 stateid가 사용되는 경우를 제외하고 READ 요청의 stateid 값은 이전 바이트 범위 잠금 또는 공유 예약 요청에서 반환된 값이나 위임과 관련된 stateid를 나타냅니다. stateid는 연결된 소유자가 있는 경우 이를 식별하고 서버에서 연결된 잠금이 여전히 유효한지\(예: 취소되지 않았는지\) 확인하는 데 사용됩니다.

파일 끝에서 읽기가 종료되거나\(공식적으로 올바른 형식의 READ 작업에서 오프셋 + 개수가 파일 크기와 같은 경우\) READ 작업이 파일 크기를 초과하는 경우\(오프셋 + 개수가 count가 파일 크기보다 큰 경우\) eof는 TRUE로 반환됩니다. 그렇지 않으면 FALSE입니다. 빈 파일을 성공적으로 읽으면 eof가 항상 TRUE로 반환됩니다.

현재 파일 핸들이 일반 파일이 아닌 경우 클라이언트에 오류가 반환됩니다. 현재 파일 핸들이 NF4DIR 유형의 객체를 나타내는 경우 NFS4ERR\_ISDIR이 반환됩니다. 현재 파일 핸들이 심볼릭 링크를 지정하면 NFS4ERR\_SYMLINK가 반환됩니다. 다른 모든 경우에는 NFS4ERR\_WRONG\_TYPE이 반환됩니다.

모든 비트의 stateid 값이 0인 READ의 경우, 서버는 해당 파일에 대한 필수 바이트 범위 잠금 또는 현재 공유 거부 모드에 따라 READ가 서비스되도록 허용할 수 있습니다. 모든 비트의 stateid 값이 1인 READ의 경우 서버는 READ 작업이 서버에서 잠금 검사를 우회하도록 허용할 수 있습니다.\(MAY, MAY\)

성공하면 현재 파일 핸들이 해당 값을 유지합니다.

---
#### **18.22.4.  IMPLEMENTATION**

서버가 "짧은 읽기"\(즉, 요청한 것보다 적은 데이터와 FALSE로 설정된 데이터\)를 반환하는 경우 클라이언트는 나머지 데이터를 가져오기 위해 또 다른 READ를 보내야 합니다. 서버는 여러 상황에서 요청한 것보다 적은 양의 데이터를 반환할 수 있습니다. 다른 클라이언트나 서버 자체에서 파일이 잘려서 요청 클라이언트가 생각하는 파일 크기가 변경되었을 수 있습니다. 이렇게 하면 클라이언트가 사용할 수 있는 실제 데이터 양이 줄어듭니다. 서버가 전송 크기를 줄여 짧은 읽기 결과를 반환할 수도 있습니다. 짧은 읽기에서도 서버 리소스 고갈이 발생할 수 있습니다.

파일에 필수 바이트 범위 잠금이 적용되고 파일에서 읽을 데이터에 해당하는 바이트 범위가 stateid와 연결되지 않은 소유자에 의해 WRITE\_LT 잠긴 경우 서버는 NFS4ERR\_LOCKED 오류를 반환합니다. 클라이언트는 READ를 다시 시도하기 전에 LOCK 작업을 통해 적절한 READ\_LT를 얻으려고 시도해야 합니다. READ가 완료되면 클라이언트는 LOCKU를 통해 바이트 범위 잠금을 해제해야 합니다.

다른 클라이언트가 읽고 있는 파일에 대해 OPEN\_DELEGATE\_WRITE 위임을 갖고 있는 경우 위임을 회수해야 하며 해당 위임이 반환되거나 취소될 때까지 작업을 진행할 수 없습니다. 매우 빠르게 발생하는 경우를 제외하고 위임이 미해결 상태로 유지되는 동안 요청에 하나 이상의 NFS4ERR\_DELAY 오류가 반환됩니다. 일반적으로 이전 OPEN의 결과로 회수가 발생하므로 READ 작업의 결과로 위임이 회수되지 않습니다. 그러나 특수한 stateid를 사용하여 READ를 수행할 수 있으므로 클라이언트가 이전에 OPEN을 수행했어야 하더라도 서버는 이 경우를 확인해야 합니다.

---
### **18.23.  Operation 26: READDIR - Read Directory**
---
#### **18.23.1.  ARGUMENTS**

```text
   struct READDIR4args {
           /* CURRENT_FH: directory */
           nfs_cookie4     cookie;
           verifier4       cookieverf;
           count4          dircount;
           count4          maxcount;
           bitmap4         attr_request;
   };
```

---
#### **18.23.2.  RESULTS**

```text
   struct entry4 {
           nfs_cookie4     cookie;
           component4      name;
           fattr4          attrs;
           entry4          *nextentry;
   };

   struct dirlist4 {
           entry4          *entries;
           bool            eof;
   };

   struct READDIR4resok {
           verifier4       cookieverf;
           dirlist4        reply;
   };

   union READDIR4res switch (nfsstat4 status) {
    case NFS4_OK:
            READDIR4resok  resok4;
    default:
            void;
   };
```

---
#### **18.23.3.  DESCRIPTION**

READDIR 작업은 파일 시스템 디렉터리에서 가변 개수의 항목을 검색하고 클라이언트가 후속 READDIR에서 추가 디렉터리 항목을 요청할 수 있도록 정보와 함께 각 항목에 대해 클라이언트가 요청한 속성을 반환합니다.

인수에는 디렉터리 내에서 READDIR이 시작되어야 하는 위치를 나타내는 쿠키 값이 포함되어 있습니다. 쿠키 값 0은 디렉터리 시작 부분에서 읽기를 시작하는 데 사용됩니다. 후속 READDIR 요청의 경우 클라이언트는 이전 READDIR 요청에서 서버가 제공한 쿠키 값을 지정합니다.

요청의 쿠키 필드가 0\(디렉터리의 첫 번째 읽기\)인 경우 요청의 cookieverf 필드는 0\(영\)으로 설정되어야 합니다. 후속 요청에서 cookieverf 필드는 쿠키를 획득한 READDIR에서 반환한 cookieverf와 일치해야 합니다. 서버가 cookieverf가 더 이상 해당 디렉터리에 유효하지 않다고 판단하면 NFS4ERR\_NOT\_SAME 오류가 반환되어야 합니다.

요청의 dircount 필드는 반환되어야 하는 디렉터리 정보의 최대 바이트 수에 대한 힌트입니다. 이 값은 디렉터리 항목 이름의 총 길이와 해당 항목에 대한 쿠키 값을 나타냅니다. 이 길이는 서버의 기본 형식의 길이가 아니라 데이터\(이름 및 쿠키\)의 XDR 인코딩을 나타냅니다.

요청의 maxcount 필드는 READDIR4resok 구조 내에서 반환되는 모든 데이터의 최대 총 크기를 나타내며 XDR 오버헤드를 포함합니다. 서버는 더 적은 양의 데이터를 반환할 수 있습니다. 서버가 maxcount 제한 내에서 단일 디렉토리 항목을 반환할 수 없는 경우 NFS4ERR\_TOOSMALL 오류가 클라이언트에 반환되어야 합니다.\(MAY, MUST\)

마지막으로 요청의 attr\_request 필드는 서버가 제공하는 각 디렉토리 항목에 대해 반환될 속성 목록을 나타냅니다.

성공적인 응답은 디렉터리 항목 목록으로 구성됩니다. 이러한 각 항목에는 디렉터리 항목의 이름, 해당 항목의 쿠키 값 및 요청된 관련 속성이 포함되어 있습니다. 디렉토리에 더 이상 항목이 없으면 "eof" 플래그는 TRUE 값을 갖습니다.

쿠키 값은 서버에만 의미가 있으며 디렉터리 항목에 대한 커서로 사용됩니다. 언급한 대로 이 쿠키는 클라이언트가 후속 READDIR 작업에 사용하여 디렉터리를 계속 읽을 수 있습니다. 쿠키는 개념상 READ 오프셋과 유사하지만 클라이언트가 그렇게 해석해서는 안 됩니다. 이상적으로는 클라이언트가 이러한 값을 캐싱할 수 있으므로 디렉터리가 수정된 경우 쿠키 값이 변경되어서는 안 됩니다.\(MUST NOT, SHOULD NOT\)

어떤 경우에는 서버가 디렉토리 항목의 속성을 가져오는 동안 오류가 발생할 수 있습니다. 전체 READDIR 작업에 대해 오류를 반환하는 대신 서버는 대신 rdattr\_error 속성을 반환할 수 있습니다\(섹션 5.8.1.12\). 이를 통해 서버는 클라이언트에 오류를 전달할 수 있으며 일시적 오류가 발생할 수 있는 경우 전체 작업이 실패하지 않도록 할 수 있습니다. 분명히 이 메서드가 제대로 작동하려면 클라이언트가 fattr4\_rdattr\_error 속성을 요청해야 합니다. 클라이언트가 속성을 요청하지 않으면 서버는 전체 READDIR 작업에 대해 실패를 반환할 수밖에 없습니다.

일부 파일 시스템 환경의 경우 디렉터리 항목 "." 및 ".."은 특별한 의미를 가지며, 다른 환경에서는 그렇지 않습니다. 서버가 디렉토리 내에서 이러한 특수 항목을 지원하는 경우 READDIR 응답의 일부로 클라이언트에 반환되어서는 안 됩니다. 일부 클라이언트 환경을 활성화하려면 쿠키 값 0, 1, 2가 예약된 것으로 간주됩니다. UNIX 클라이언트는 서버의 응답과 로컬 표현을 결합하여 응용 프로그램에 대해 완전히 구성된 UNIX 디렉터리 표현을 활성화할 때 이러한 값을 사용합니다.\(SHOULD NOT\)

READDIR 인수의 경우 쿠키 값 1과 2를 사용해서는 안 되며, READDIR 결과의 경우 쿠키 값 0, 1, 2를 반환하면 안 됩니다.\(SHOULD NOT\)

성공하면 현재 파일 핸들이 해당 값을 유지합니다.

---
#### **18.23.4.  IMPLEMENTATION**

서버의 파일 시스템 디렉토리 표현은 크게 다를 수 있습니다. 클라이언트의 프로그래밍 인터페이스는 NFS 프로토콜로 제대로 변환되지 않는 방식으로 로컬 운영 환경에 바인딩될 수도 있습니다. 따라서 클라이언트가 서버에 힌트를 제공할 수 있도록 dircount 및 maxcount 필드의 사용이 제공됩니다. 클라이언트가 READDIR 중에 속성 수집에 적극적이라면 서버는 인코딩된 응답을 제한하는 방법에 대한 아이디어를 가지고 있습니다.

dircount가 0이면 서버는 요청의 maxcount 필드를 기반으로 응답 크기를 제한합니다.

cookieverf는 오래될 수 있는 쿠키 값을 관리하는 데 도움을 주기 위해 서버에서 사용될 수 있습니다. 서버가 제공된 쿠키/쿠키버프 쌍을 사용하여 디렉터리를 계속해서 올바르게 읽을 수 없는 경우는 거의 발생하지 않습니다. 클라이언트의 애플리케이션이 이러한 유형의 실패를 적절하게 처리하지 못할 수 있으므로 서버는 이 조건을 피하기 위해 모든 노력을 기울여야 합니다.\(SHOULD\)

cookieverf를 사용하면 클라이언트가 오래되었을 수 있는 READDIR 쿠키 값을 사용하지 못하도록 보호할 수도 있습니다. 예를 들어 파일 시스템이 마이그레이션된 경우 서버는 이전 서버에서 사용한 것과 동일한 쿠키 값을 사용하여 READDIR을 서비스할 수도 있고 그렇지 않을 수도 있습니다. 클라이언트가 cookieverf를 제공하면 서버는 클라이언트에 적절한 응답을 제공할 수 있습니다. 이렇게 하면 서버가 쿠키 값을 허용하지만 기본 디렉터리가 변경되어 이전 READDIR의 클라이언트 컨텍스트에서 응답이 유효하지 않은 경우가 방지됩니다.

일부 서버는 "."을 반환하지 않기 때문에 및 ".." 항목은 이전 버전의 NFS 프로토콜에서 수행된 것처럼 READDIR 응답에 이러한 항목이 있어야 하는 클라이언트가 해당 항목을 조작해야 합니다.

---
### **18.24.  Operation 27: READLINK - Read Symbolic Link**
---
#### **18.24.1.  ARGUMENTS**

```text
   /* CURRENT_FH: symlink */
   void;
```

---
#### **18.24.2.  RESULTS**

```text
   struct READLINK4resok {
           linktext4       link;
   };

   union READLINK4res switch (nfsstat4 status) {
    case NFS4_OK:
            READLINK4resok resok4;
    default:
            void;
   };
```

---
#### **18.24.3.  DESCRIPTION**

READLINK는 심볼릭 링크와 관련된 데이터를 읽습니다. UTF-8 기능 속성\(섹션 14.4\)의 값에 따라 데이터는 UTF-8로 인코딩됩니다. NFS 클라이언트에 의해 생성되었거나 서버에서 로컬로 생성된 경우 기호 링크의 데이터는 생성 시 해석되지 않고\(적절한 UTF-8 인코딩을 확인하는 경우 제외\) 단순히 저장됩니다.

성공하면 현재 파일 핸들이 해당 값을 유지합니다.

---
#### **18.24.4.  IMPLEMENTATION**

심볼릭 링크는 명목상 다른 파일에 대한 포인터입니다. 데이터는 반드시 서버에 의해 해석되는 것은 아니며 단지 파일에 저장됩니다. 클라이언트 구현에서는 서버 운영 체제에 의미가 없는 경로 이름을 기호 링크에 저장할 수 있습니다. READLINK 작업은 해석을 위해 데이터를 클라이언트에 반환합니다. 서로 다른 구현이 기호 링크에 대한 액세스를 공유하려는 경우 기호 링크의 데이터 해석에 동의해야 합니다.

READLINK 작업은 NF4LNK 유형의 개체에만 허용됩니다. 개체가 NF4LNK 유형이 아닌 경우 서버는 NFS4ERR\_WRONG\_TYPE 오류를 반환해야 합니다.

---
### **18.25.  Operation 28: REMOVE - Remove File System Object**
---
#### **18.25.1.  ARGUMENTS**

```text
   struct REMOVE4args {
           /* CURRENT_FH: directory */
           component4      target;
   };
```

---
#### **18.25.2.  RESULTS**

```text
   struct REMOVE4resok {
           change_info4    cinfo;
   };

   union REMOVE4res switch (nfsstat4 status) {
    case NFS4_OK:
            REMOVE4resok   resok4;
    default:
            void;
   };
```

---
#### **18.25.3.  DESCRIPTION**

REMOVE 작업은 현재 파일 핸들에 해당하는 디렉터리에서 filename이라는 디렉터리 항목을 제거\(삭제\)합니다. 디렉토리의 항목이 해당 파일 시스템 개체에 대한 마지막 참조인 경우 개체가 삭제될 수 있습니다. 디렉토리는 NF4DIR 또는 NF4ATTRDIR 유형일 수 있습니다.

파일 이름이 제거된 디렉터리에 대해 서버는 cinfo에change\_info4 정보를 반환합니다. Change\_info4 데이터 유형의 원자 필드를 사용하면 서버는 제거와 관련하여 변경 전후 속성이 원자적으로 획득되었는지 여부를 나타냅니다.

대상의 길이가 0이거나 대상이 UTF-8 정의를 따르지 않는 경우\(그리고 서버가 UTF-8 인코딩을 적용하는 경우, 섹션 14.4 참조\) NFS4ERR\_INVAL 오류가 반환됩니다.

성공하면 현재 파일 핸들이 해당 값을 유지합니다.

---
#### **18.25.4.  IMPLEMENTATION**

NFSv3에는 디렉터리 제거를 위한 다른 연산자 RMDIR과 디렉터리가 아닌 제거를 위한 REMOVE가 필요했습니다. 이를 통해 클라이언트는 디렉터리를 제거하기 위해 디렉터리가 아닌 삭제 시스템 호출\(예: POSIX의 unlink\(\) \[24\]\)이 전달될 때 파일 형식 확인을 건너뛸 수 있을 뿐만 아니라 그 반대의 경우\(예: POSIX의 rmdir\(\)\) 디렉터리가 아닌\) 서버가 파일 형식을 확인할 것이라는 것을 알았기 때문입니다. NFSv4.1 REMOVE를 사용하면 파일 유형에 관계없이 모든 디렉터리 항목을 삭제할 수 있습니다. unlink\(\) 및 rmdir\(\) 시스템 호출의 NFSv4.1 클라이언트 진입점 구현자는 REMOVE 작업을 보내기 전에 시스템 호출이 제거할 수 있는 유형에 대해 먼저 파일 유형을 확인해야 합니다. 또는 구현자는 동일한 COMPOUND 호출에서 REMOVE 작업 전에 파일 형식을 확인하기 위한 LOOKUP/VERIFY 작업 시퀀스를 포함하는 COMPOUND 호출을 생성할 수 있습니다.

마지막 참조의 개념은 서버별로 다릅니다. 그러나 객체의 이전 속성에 있는 numlinks 필드의 값이 1인 경우 클라이언트는 파일 핸들을 통해 객체를 참조하는 데 의존해서는 안 됩니다. 마찬가지로 클라이언트는 즉시 사용할 수 있게 되는 개체와 이전에 연결되었던 리소스\(디스크 공간, 디렉터리 항목 등\)에 의존해서는 안 됩니다. 따라서 클라이언트가 REMOVE를 사용하여 파일을 제거한 후에도 파일에 계속 액세스할 수 있어야 하는 경우 클라이언트는 파일에 계속 액세스할 수 있는지 확인하기 위한 조치를 취해야 합니다. 사용되는 전통적인 메커니즘은 파일의 이름을 이전 이름에서 새로운 숨겨진 이름으로 바꾸는 것이지만 NFSv4.1 OPEN 작업은 결과 플래그 OPEN4\_RESULT\_PRESERVE\_UNLINKED를 반환할 수 있습니다. 이는 파일에 미개척 상태입니다\(섹션 18.16 참조\).\(MAY\)

REMOVE 명령이 도착했을 때 서버에서 파일이 아직 열려 있는 것을 발견한 경우:

\* 파일이 OPEN4\_SHARE\_DENY\_WRITE 또는 OPEN4\_SHARE\_DENY\_BOTH로 열린 경우 서버는 파일의 디렉터리 항목을 삭제해서는 안 됩니다.\(SHOULD NOT\)

\* 파일이 OPEN4\_SHARE\_DENY\_WRITE로 열리지 않은 경우 또는

- OPEN4\_SHARE\_DENY\_BOTH, 서버는 파일의 디렉터리 항목을 삭제해야 합니다. 그러나 파일의 마지막 CLOSE까지 서버는 파일 핸들을 통해 파일에 대한 액세스를 계속 허용할 수 있습니다.\(SHOULD, MAY\)

\* OPEN의 응답에 OPEN4\_RESULT\_PRESERVE\_UNLINKED 플래그가 설정된 경우 서버는 디렉터리 항목을 삭제해서는 안 됩니다.\(MUST NOT\)

서버는 파일이 열려 있는 동안 파일 제거에 대한 자체 제한을 구현할 수 있습니다. 서버는 이러한 REMOVE\(또는 RENAME의 일부로 발생하는 제거\)를 허용하지 않을 수 있습니다. 파일이 열려 있는 동안 파일 제거 제한에 영향을 미치는 조건은 다음과 같습니다.\(MAY\)

\* 특정 액세스 프로토콜\(예: NFS뿐만 아니라\)이 파일을 열어두고 있는지 여부.

\* 서버의 특정 옵션, 액세스 모드 또는 정책이 활성화되어 있는지 여부.

파일에 미해결 OPEN이 있고 이로 인해 파일의 디렉터리 항목이 제거되지 않는 경우 NFS4ERR\_FILE\_OPEN 오류가 반환됩니다.

위임이 보류 중이기 때문에 위의 결정을 확실하게 내릴 수 없는 경우 REMOVE 처리를 계속하려면 위임을 회수해야 합니다. 위임이 보류되면 서버는 해당 클라이언트의 OPEN 상태에 대해 신뢰할 수 있는 지식이 없으므로 위임 없이 클라이언트가 특정 거부 모드로 파일을 열지 않는 한 위임이 회수될 때까지 결정을 내릴 수 없습니다. 서버가 올바른 결정을 내릴 수 있도록 각각의 충분한 위임이 반환되거나 취소될 때까지 진행할 수 없습니다.\(MUST\)

위임이 회수되는 모든 경우에 서버는 위임이 미해결 상태로 유지되는 동안 하나 이상의 NFS4ERR\_DELAY 오류를 반환할 가능성이 높습니다.

현재 파일 핸들이 다른 클라이언트가 디렉터리 위임을 보유한 디렉터리를 지정하는 경우 상황이 알림을 전송하여 해결될 수 없다면 디렉터리 위임을 회수해야 하며 위임이 반환되거나 취소될 때까지 작업을 진행해서는 안 됩니다. 매우 빠르게 발생하는 경우를 제외하고 위임이 미해결 상태로 유지되는 동안 요청에 하나 이상의 NFS4ERR\_DELAY 오류가 반환됩니다.\(MUST NOT\)

현재 파일 핸들이 하나 이상의 디렉터리 위임이 존재하는 디렉터리를 지정하면 해당 위임이 그러한 알림을 요청할 때 이 작업의 결과로 NOTIFY4\_REMOVE\_ENTRY가 생성됩니다.

RENAME의 결과로 제거가 발생하면 NOTIFY4\_REMOVE\_ENTRY는 제거가 별도의 작업으로 발생하는 경우에만 생성됩니다. 제거가 RENAME과 통합되고 원자적인 경우 제거 알림은 RENAME에 대한 알림과 통합됩니다. 섹션 20.4의 NOTIFY4\_RENAME\_ENTRY 알림에 대한 설명을 참조하세요.

---
### **18.26.  Operation 29: RENAME - Rename Directory Entry**
---
#### **18.26.1.  ARGUMENTS**

```text
   struct RENAME4args {
           /* SAVED_FH: source directory */
           component4      oldname;
           /* CURRENT_FH: target directory */
           component4      newname;
   };
```

---
#### **18.26.2.  RESULTS**

```text
   struct RENAME4resok {
           change_info4    source_cinfo;
           change_info4    target_cinfo;
   };

   union RENAME4res switch (nfsstat4 status) {
    case NFS4_OK:
           RENAME4resok    resok4;
    default:
           void;
   };
```

---
#### **18.26.3.  DESCRIPTION**

RENAME 작업은 SAVEFH 작업에 의해 설정된 저장된 파일 핸들에 해당하는 소스 디렉터리에서 oldname으로 식별된 개체의 이름을 현재 파일 핸들에 해당하는 대상 디렉터리의 newname으로 바꿉니다. 작업은 클라이언트에 대해 원자적이어야 합니다. 소스 및 대상 디렉터리는 서버의 동일한 파일 시스템에 있어야 합니다. 성공하면 현재 파일 핸들이 계속 대상 디렉터리가 됩니다.\(MUST\)

대상 디렉터리에 newname이라는 이름의 항목이 이미 포함되어 있는 경우 소스 개체는 대상과 호환되어야 합니다. 둘 다 디렉터리가 아니거나 둘 다 디렉터리이고 대상은 비어 있어야 합니다. 호환되는 경우 이름 바꾸기가 발생하기 전에 기존 대상이 제거되거나 이름 바꾸기의 일부로 대상이 원자적으로 제거되는 것이 좋습니다. 대상이 제거될 때마다 클라이언트 및 서버 작업에 대해서는 섹션 18.25.4를 참조하세요. 그러나 이름 바꾸기를 통해 제거가 원자적으로 수행되면 거기에 설명된 제거의 특정 부분이 이름 바꾸기와 통합됩니다. 예를 들어 제거 알림은 NOTIFY4\_REMOVE\_ENTRY를 통하지 않고 이름 변경으로 생성된 NOTIFY4\_ADD\_ENTRY 또는 NOTIFY4\_RENAME\_ENTRY의 일부로 표시됩니다.\(MUST\)

소스 객체와 대상이 호환되지 않거나 대상이 디렉터리이지만 비어 있지 않은 경우 서버는 NFS4ERR\_EXIST 오류를 반환합니다.

oldname과 newname이 모두 동일한 파일을 참조하는 경우\(예: 서로의 하드 링크일 수 있음\) 파일이 열려 있지 않으면\(섹션 18.26.4 참조\) RENAME은 아무 작업도 수행하지 않고 NFS4\_OK를 반환해야 합니다.\(MUST\)

RENAME과 관련된 두 디렉터리 모두에 대해 서버는change\_info4 정보를 반환합니다. Change\_info4 데이터 유형의 원자 필드를 사용하면 서버는 이름 바꾸기와 관련하여 변경 전후 속성이 원자적으로 획득되었는지 여부를 나타냅니다.

oldname이 명명된 속성을 참조하고 저장된 파일 핸들과 현재 파일 핸들이 다른 파일 시스템 개체를 참조하는 경우 서버는 마치 저장된 파일 핸들과 현재 파일 핸들이 다른 파일 시스템의 디렉터리를 나타내는 것처럼 NFS4ERR\_XDEV를 반환합니다.

oldname 또는 newname의 길이가 0이거나 oldname 또는 newname이 UTF-8 정의를 따르지 않는 경우 NFS4ERR\_INVAL 오류가 반환됩니다.

---
#### **18.26.4.  IMPLEMENTATION**

서버는 이름이 바뀌는 파일이 열려 있거나 해당 열기가 특정 프로토콜이나 특정 옵션이나 액세스 모드로 수행될 때 RENAME이 수행되지 않도록 RENAME 작업에 제한을 가할 수 있습니다. 대상 이름을 가진 파일이 존재하고 열려 있는 경우 유사한 제한이 적용될 수 있습니다. 이러한 제한으로 인해 RENAME이 거부되면 NFS4ERR\_FILE\_OPEN 오류가 반환됩니다.\(MAY\)

oldname과 rename이 동일한 파일을 참조하고 해당 파일이 oldname과 newname이 다른 파일인 경우 RENAME이 일반적으로 NFS4ERR\_FILE\_OPEN으로 거부되는 방식으로 열려 있는 경우 RENAME은 NFS4ERR\_FILE\_OPEN으로 거부되어야 합니다.\(SHOULD\)

서버가 이러한 제한 사항을 구현하고 이러한 제한 사항에 이름 바꾸기의 성공적인 실행을 방해하는 NFSv4 열기 사례가 포함되는 경우 서버는 해당 결정과 관련된 열기의 존재를 숨길 수 있는 모든 위임을 회수해야 합니다. 이는 클라이언트가 위임을 보유할 때 클라이언트가 로컬에서 OPEN 및 CLOSE를 실행할 수 있기 때문에 서버가 해당 클라이언트에 대한 열기에 대한 정확한 계정을 갖고 있지 않을 수 있기 때문입니다. RENAME 작업은 최종 결과를 얻을 수 있을 때까지만 지연하면 됩니다. 예를 들어, 여러 위임이 있고 그 중 하나가 이름 변경을 방지하는 열기를 설정하는 경우 서버의 의미를 고려할 때 다른 위임이 반환될 때까지 기다리지 않고 해당 위임이 반환되는 즉시 NFS4ERR\_FILE\_OPEN이 호출자에게 반환될 수 있습니다. 마찬가지로, 이러한 열기가 위임과 연결되지 않은 경우 위임 회수가 수행되지 않고 NFS4ERR\_FILE\_OPEN이 즉시 반환될 수 있습니다.

현재 파일 핸들 또는 저장된 파일 핸들이 다른 클라이언트가 디렉토리 위임을 보유하고 있는 디렉토리를 지정하는 경우 알림을 전송하여 상황을 해결할 수 없으면 위임을 반드시 회수해야 하며 위임이 반환되거나 위임될 때까지 작업을 진행할 수 없습니다. 취소되었습니다. 매우 빠르게 발생하는 경우를 제외하고 위임이 미해결 상태로 유지되는 동안 요청에 하나 이상의 NFS4ERR\_DELAY 오류가 반환됩니다.\(MUST\)

현재 파일 핸들과 저장된 파일 핸들이 동일하고 하나 이상의 디렉터리 위임이 존재하는 디렉터리를 지정하는 경우 해당 위임이 해당 알림을 요청할 때 이 작업의 결과로 NOTIFY4\_RENAME\_ENTRY 유형의 알림이 생성됩니다. oldname과 rename이 동일한 파일을 참조하는 경우 알림이 생성되지 않습니다\(섹션 18.26.3에 명시된 대로 서버는 아무 조치도 취하지 않아야 하기 때문입니다\). 파일이 대상과 이름이 동일하여 제거될 때 이름 바꾸기를 통해 제거가 원자적으로 수행되면 NOTIFY4\_REMOVE\_ENTRY 알림이 생성되지 않습니다. 대신 파일 삭제가 NOTIFY4\_RENAME\_ENTRY 알림의 일부로 보고됩니다.\(MUST\)

현재 파일 핸들과 저장된 파일 핸들이 동일하지 않은 경우:

\* 현재 파일 핸들이 하나 이상의 디렉터리 위임이 존재하는 디렉터리를 지정하는 경우 해당 위임이 그러한 알림을 요청할 때 이 작업의 결과로 NOTIFY4\_ADD\_ENTRY가 생성됩니다. 파일이 대상과 이름이 동일하여 제거될 때 이름 바꾸기를 통해 제거가 원자적으로 수행되면 NOTIFY4\_REMOVE\_ENTRY 알림이 생성되지 않습니다. 대신 파일 삭제는 NOTIFY4\_ADD\_ENTRY 알림의 일부로 보고됩니다.

\* 저장된 파일 핸들이 하나 이상의 디렉터리 위임이 존재하는 디렉터리를 지정하는 경우 해당 위임이 그러한 알림을 요청할 때 이 작업의 결과로 NOTIFY4\_REMOVE\_ENTRY가 생성됩니다.

이름이 변경되는 객체에 RENAME을 수행하는 클라이언트가 아닌 다른 클라이언트가 보유한 파일 위임이 있는 경우 위임을 회수해야 하며 각 위임이 반환되거나 취소될 때까지 작업을 진행할 수 없습니다. 다중 링크 파일의 경우 이름이 변경된 이름과 다른 이름을 통해 위임을 얻은 경우에도 위임 회수 요구 사항이 적용됩니다. 위임이 회수되는 모든 경우에 서버는 위임이 미해결 상태로 유지되는 동안 하나 이상의 NFS4ERR\_DELAY 오류를 반환할 가능성이 높지만 위임이 빠르게 반환되는 경우에는 그렇게 하지 않을 수도 있습니다.\(MUST\)

RENAME 작업은 클라이언트에 대해 원자적이어야 합니다. "소스 및 대상 디렉토리는 서버의 동일한 파일 시스템에 있어야 합니다"라는 설명은 디렉토리 속성의 fsid 필드가 동일함을 의미합니다. 서로 다른 파일 시스템에 상주하는 경우 NFS4ERR\_XDEV 오류가 반환됩니다.\(MUST\)

객체의 fh\_expire\_type 속성 값에 따라 파일 핸들은 RENAME 시 만료되거나 만료되지 않을 수 있습니다. 그러나 서버 구현자는 이러한 방식으로 파일 핸들이 만료되지 않도록 시도하는 것이 좋습니다.

일부 서버에서는 파일 이름이 "." 및 ".."는 oldname이나 newname에 적합하지 않으며 NFS4ERR\_BADNAME 오류가 발생합니다. 또한 많은 서버에서 oldname 또는 newname이 소스 디렉토리의 별칭인 경우가 확인됩니다. 이러한 경우 이러한 서버는 NFS4ERR\_INVAL 오류를 반환합니다.

소스 또는 대상 파일 핸들 중 하나가 디렉터리가 아닌 경우 서버는 NFS4ERR\_NOTDIR을 반환합니다.

---
### **18.27.  Operation 31: RESTOREFH - Restore Saved Filehandle**
---
#### **18.27.1.  ARGUMENTS**

```text
   /* SAVED_FH: */
   void;
```

---
#### **18.27.2.  RESULTS**

```text
   struct RESTOREFH4res {
           /*
            * If status is NFS4_OK,
            *     new CURRENT_FH: value of saved fh
            */
           nfsstat4        status;
   };
```

---
#### **18.27.3.  DESCRIPTION**

RESTOREFH 작업은 현재 파일 핸들 및 stateid를 저장된 파일 핸들 및 stateid의 값으로 설정합니다. 저장된 파일 핸들이 없으면 서버는 NFS4ERR\_NOFILEHANDLE 오류를 반환합니다.

현재 파일 핸들에 대한 자세한 내용은 섹션 16.2.3.1.1을 참조하세요.

현재 stateid에 대한 자세한 내용은 섹션 16.2.3.1.2를 참조하세요.

---
#### **18.27.4.  IMPLEMENTATION**

OPEN 및 LOOKUP과 같은 작업은 현재 파일 핸들을 사용하여 디렉터리를 나타내고 이를 새 파일 핸들로 바꿉니다. 이전 파일 핸들이 SAVEFH 연산자로 저장되었다고 가정하면 이전 파일 핸들을 현재 파일 핸들로 복원할 수 있습니다. 이는 일반적으로 디렉토리에 대한 사후 작업 속성을 얻는 데 사용됩니다.

```text
         PUTFH (directory filehandle)
         SAVEFH
         GETATTR attrbits     (pre-op dir attrs)
         CREATE optbits "foo" attrs
         GETATTR attrbits     (file attributes)
         RESTOREFH
         GETATTR attrbits     (post-op dir attrs)
```

---
### **18.28.  Operation 32: SAVEFH - Save Current Filehandle**
---
#### **18.28.1.  ARGUMENTS**

```text
   /* CURRENT_FH: */
   void;
```

---
#### **18.28.2.  RESULTS**

```text
   struct SAVEFH4res {
           /*
            * If status is NFS4_OK,
            *    new SAVED_FH: value of current fh
            */
           nfsstat4        status;
   };
```

---
#### **18.28.3.  DESCRIPTION**

SAVEFH 작업은 현재 파일 핸들과 상태 ID를 저장합니다. 이전 파일 핸들이 저장된 경우 더 이상 액세스할 수 없습니다. 저장된 파일 핸들은 RESTOREFH 연산자를 사용하여 현재 파일 핸들로 복원할 수 있습니다.

성공하면 현재 파일 핸들이 해당 값을 유지합니다.

현재 파일 핸들에 대한 자세한 내용은 섹션 16.2.3.1.1을 참조하세요.

현재 stateid에 대한 자세한 내용은 섹션 16.2.3.1.2를 참조하세요.

---
#### **18.28.4.  IMPLEMENTATION**
---
### **18.29.  Operation 33: SECINFO - Obtain Available Security**
---
#### **18.29.1.  ARGUMENTS**

```text
   struct SECINFO4args {
           /* CURRENT_FH: directory */
           component4      name;
   };
```

---
#### **18.29.2.  RESULTS**

```text
   /*
    * From RFC 2203
    */
   enum rpc_gss_svc_t {
           RPC_GSS_SVC_NONE        = 1,
           RPC_GSS_SVC_INTEGRITY   = 2,
           RPC_GSS_SVC_PRIVACY     = 3
   };

   struct rpcsec_gss_info {
           sec_oid4        oid;
           qop4            qop;
           rpc_gss_svc_t   service;
   };

   /* RPCSEC_GSS has a value of '6' - See RFC 2203 */
   union secinfo4 switch (uint32_t flavor) {
    case RPCSEC_GSS:
            rpcsec_gss_info        flavor_info;
    default:
            void;
   };

   typedef secinfo4 SECINFO4resok<>;

   union SECINFO4res switch (nfsstat4 status) {
    case NFS4_OK:
           /* CURRENTFH: consumed */
            SECINFO4resok resok4;
    default:
            void;
   };
```

---
#### **18.29.3.  DESCRIPTION**

SECINFO 작업은 클라이언트가 특정 디렉터리 파일 핸들, 파일 이름 쌍에 대한 유효한 RPC 인증 특성 목록을 얻는 데 사용됩니다. SECINFO는 이름을 평가할 때 LOOKUP에 사용되는 것과 동일한 액세스 방법을 적용해야 합니다. 따라서 요청자가 이름 LOOKUP에 대한 적절한 액세스 권한이 없는 경우 SECINFO는 동일한 방식으로 작동하고 NFS4ERR\_ACCESS를 반환해야 합니다.\(MUST\)

결과에는 서버의 기본 설정에 해당하는 순서와 함께 사용 가능한 보안 메커니즘을 나타내는 배열이 포함됩니다. 가장 선호되는 항목은 배열의 첫 번째 항목입니다. 클라이언트는 원하고 지원하는 보안 메커니즘을 자유롭게 선택하거나 서버가 지원하는 첫 번째 기본 설정 순서를 선택할 수 있습니다. 배열 항목은 secinfo4 구조로 표시됩니다. 'flavor' 필드에는 AUTH\_NONE, AUTH\_SYS\(RFC 5531 \[3\]에 정의됨\) 또는 RPCSEC\_GSS\(RFC 2203 \[4\]에 정의됨\) 값이 포함됩니다. 필드 버전은 IANA에 등록된 다른 보안 버전일 수도 있습니다.

AUTH\_NONE 및 AUTH\_SYS 버전의 경우 추가 보안 정보가 반환되지 않습니다. AUTH\_DH를 포함한 많은\(대부분은 아니지만\) 다른 보안 유형에서도 마찬가지입니다. RPCSEC\_GSS 반환 값의 경우 메커니즘 객체 식별자\(OID, RFC 2743 \[7\]에 정의됨\), 보호 품질\(RFC 2743 \[7\]에 정의됨\) 및 서비스 유형을 포함하는 보안 트리플이 반환됩니다. \(RFC 2203 \[4\]에 정의됨\). SECINFO는 서로 다른 보안 트리플 값을 사용하여 RPCSEC\_GSS와 동일한 특징을 가진 여러 항목을 반환할 수 있습니다.

성공하면 현재 파일 핸들이 소비되고\(섹션 2.6.3.1.1.8 참조\), SECINFO 이후의 다음 작업이 현재 파일 핸들을 사용하려고 하면 해당 작업은 NFS4ERR\_NOFILEHANDLE 상태로 실패합니다.

이름의 길이가 0이거나 이름이 UTF-8 정의를 따르지 않는 경우\(UTF-8 기능이 활성화되어 있다고 가정, 섹션 14.4 참조\) NFS4ERR\_INVAL 오류가 반환됩니다.

SECINFO 사용에 대한 추가 정보는 섹션 2.6을 참조하세요.

---
#### **18.29.4.  IMPLEMENTATION**

SECINFO 작업은 NFS4ERR\_WRONGSEC의 오류 값이 다른 NFS 작업에서 반환될 때 NFS 클라이언트에서 사용될 것으로 예상됩니다. 이는 서버의 보안 정책이 클라이언트가 현재 사용하고 있는 것과 다르다는 것을 클라이언트에게 나타냅니다. 이 시점에서 클라이언트는 가능한 보안 종류 목록을 얻고 해당 정책에 가장 적합한 것을 선택해야 합니다.

언급한 대로 서버의 보안 정책은 클라이언트 요청이 NFS4ERR\_WRONGSEC를 수신하는 시기를 결정합니다. NFS4ERR\_WRONGSEC를 반환할 수 있는 작업 목록은 표 14를 참조하십시오. 또한 READDIR이 속성을 반환하면 rdattr\_error\(섹션 5.8.1.12\)에 NFS4ERR\_WRONGSEC가 포함될 수 있습니다. CREATE 및 REMOVE는 NFS4ERR\_WRONGSEC를 반환해서는 안 됩니다. CREATE의 이론적 근거는 대상 이름이 존재하지 않는 한 상위 디렉터리와 별도의 보안 정책을 가질 수 없으며 해당 파일 핸들이 COMPOUND 요청의 작업 스트림에 주입될 때 상위 디렉터리의 보안 정책을 확인한다는 것입니다\(비슷한 이유로 대상을 생성하는 OPEN 작업은 NFS4ERR\_WRONGSEC를 반환해서는 안 됩니다. 대상 이름이 존재하는 경우 별도의 보안 정책이 있을 수 있지만 CREATE는 NFS4ERR\_EXIST를 반환해야 하므로 이는 관련이 없습니다. REMOVE의 이론적 근거는 해당 대상이 별도의 보안 정책을 가질 수 있지만 대상은 제거될 것이므로 부모의 보안 정책이 제거되는 객체의 보안 정책보다 우선한다는 것입니다. RENAME 및 LINK는 NFS4ERR\_WRONGSEC를 반환할 수 있지만 NFS4ERR\_WRONGSEC 오류는 저장된 파일 핸들에만 적용됩니다\(섹션 2.6.3.1.2 참조\). LINK 및 RENAME에서 사용하는 현재 파일 핸들의 모든 NFS4ERR\_WRONGSEC 오류는 현재 파일 핸들을 주입한 PUTFH, PUTPUBFH, PUTROOTFH 또는 RESTOREFH 작업에 의해 반환되어야 합니다.\(MUST NOT, MUST NOT, MUST, MAY, MUST\)

LINK 및 RENAME을 제외하고 NFS4ERR\_WRONGSEC를 반환할 수 있는 작업 집합은 클라이언트가 서버의 "현재 파일 핸들"에 파일 핸들을 삽입할 수 있는 지점을 나타냅니다. 파일 핸들은 클라이언트\(PUTFH, PUTPUBFH, PUTROOTFH\)에 의해 제공되거나, 이름에서 파일 핸들로의 변환\(LOOKUP 및 OPEN\) 결과로 생성되거나, RESTOREFH를 통해 저장된 파일 핸들에서 생성됩니다. 섹션 2.6.3.1.1.1에 명시되어 있듯이 SAVEFH가 뒤따르는 파일 핸들 넣기 작업은 NFS4ERR\_WRONGSEC를 반환해서는 안 됩니다. 따라서 특정 조건\(섹션 2.6.3.1.1 참조\)에서 RESTOREFH 작업은 보안 정책을 준수할 수 있도록 NFS4ERR\_WRONGSEC를 반환하는 것이 허용됩니다.\(MUST NOT\)

READDIR 작업은 NFS4ERR\_WRONGSEC 오류를 직접 반환하지 않습니다. 그러나 READDIR 요청에 속성에 대한 요청이 포함된 경우 READDIR 요청의 보안 트리플이 디렉터리 항목의 보안 트리플과 일치하지 않을 수 있습니다. 이런 경우이고 클라이언트가 rdattr\_error 속성을 요청한 경우 서버는 항목에 대한 rdattr\_error에 NFS4ERR\_WRONGSEC 오류를 반환합니다.

NFS4ERR\_WRONGSEC의 오류 반환을 해결하기 위해 클라이언트는 다음을 수행합니다.

\* LOOKUP 및 OPEN의 경우 클라이언트는 원래 LOOKUP 또는 OPEN에 제공된 것과 동일한 현재 파일 핸들 및 이름으로 SECINFO를 사용하여 사용 가능한 보안 트리플을 열거합니다.

\* rdattr\_error의 경우 클라이언트는 원본 READDIR에 제공된 것과 동일한 현재 파일 핸들과 함께 SECINFO를 사용합니다. SECINFO에 전달된 이름은 rdattr\_error 속성에 NFS4ERR\_WRONGSEC 오류가 있는 디렉터리 항목\(READDIR에서 반환됨\)의 이름이 됩니다.

\* PUTFH, PUTROOTFH, PUTPUBFH, RESTOREFH, LINK 및 RENAME의 경우 클라이언트는 SECINFO\_NO\_NAME { 스타일 = SECINFO\_STYLE4\_CURRENT\_FH }를 사용합니다. 클라이언트는 원래 PUTFH, PUTPUBFH, PUTROOTFH 또는 RESTOREFH 작업에서 제공한 파일 핸들을 제공하는 적절한 PUTFH, PUTPUBFH 또는 PUTROOTFH 작업을 SECINFO\_NO\_NAME 작업 앞에 붙입니다.

- 참고: NFSv4.0에서는 클라이언트가 SECINFO를 사용해야 했으며 원본 파일 핸들의 상위 항목과 원본 파일 핸들의 구성 요소 이름을 재구성해야 했습니다. SECINFO\_NO\_NAME의 NFSv4.1 도입으로 재구성이 필요하지 않습니다.

\* LOOKUPP의 경우 클라이언트는 SECINFO\_NO\_NAME { style = SECINFO\_STYLE4\_PARENT }를 사용하고 원래 LOOKUPP에 제공된 파일 핸들과 동일한 파일 핸들을 제공합니다.

SECINFO 및 SECINFO\_NO\_NAME에서 사용하는 보안 유형에 대한 권장 사항에 대한 논의는 섹션 21을 참조하세요.

---
### **18.30.  Operation 34: SETATTR - Set Attributes**
---
#### **18.30.1.  ARGUMENTS**

```text
   struct SETATTR4args {
           /* CURRENT_FH: target object */
           stateid4        stateid;
           fattr4          obj_attributes;
   };
```

---
#### **18.30.2.  RESULTS**

```text
   struct SETATTR4res {
           nfsstat4        status;
           bitmap4         attrsset;
   };
```

---
#### **18.30.3.  DESCRIPTION**

SETATTR 작업은 파일 시스템 개체의 속성 중 하나 이상을 변경합니다. 새 속성은 비트맵과 비트순으로 비트맵 뒤에 오는 속성으로 지정됩니다.

SETATTR의 stateid 인수는 크기 속성을 설정하는 SETATTR 요청에 필요한 바이트 범위 잠금 컨텍스트를 제공하는 데 사용됩니다. 크기 속성을 설정하면 파일의 데이터가 수정되므로 해당 WRITE와 동일한 잠금 요구 사항이 있습니다. 크기 속성을 설정하는 SETATTR은 OPEN4\_SHARE\_DENY\_WRITE를 지정하는 공유 예약과 호환되지 않습니다. 이전 파일 끝과 새 파일 끝 사이의 영역은 해당 영역이 WRITE 대상으로 지정된 경우와 마찬가지로 수정된 것으로 간주됩니다. 서버가 필수 바이트 범위 잠금 동작을 구현하는 경우 바이트 범위 잠금. 유효한 stateid는 항상 지정되어야 합니다. 파일 크기 속성이 설정되지 않은 경우 모든 비트가 0으로 구성된 특수 stateid가 전달될 수 있습니다.\(SHOULD, MAY\)

작업이 성공하거나 실패하면 서버는 attrsset 비트마스크를 반환하여 성공적으로 설정된 속성\(있는 경우\)을 나타냅니다. 응답의 attrsset는 인수에 있는 obj\_attributes 필드의 attrmask 필드의 하위 집합입니다.

성공하면 현재 파일 핸들이 해당 값을 유지합니다.

---
#### **18.30.4.  IMPLEMENTATION**

요청이 설정할 소유자 속성을 지정하는 경우 서버는 개체의 현재 소유자가 요청에 지정된 값과 일치하는 경우 작업이 성공하도록 허용해야 합니다. 일부 서버는 요청자에게 권한이 없는 한 소유자 속성 설정을 금지하는 방식으로 구현될 수 있습니다. 소유자 값이 일치하는 이 경우에 서버가 관대하다면 객체 생성\(예: OPEN을 통한 단독 생성\)과 SETATTR의 경우 클라이언트 구현이 단순화될 수 있습니다.\(SHOULD\)

파일 크기 속성은 파일 크기 변경을 요청하는 데 사용됩니다. 값이 0이면 파일이 잘리고, 파일의 현재 크기보다 작은 값을 사용하면 새 크기부터 파일 끝까지의 데이터가 삭제되며, 파일의 현재 크기보다 큰 경우 논리적으로 0이 됩니다. 파일 끝에 추가할 데이터 바이트입니다. 서버는 할당되지 않은 바이트\(홀\) 또는 0으로 설정된 할당된 데이터 바이트를 사용하여 이를 자유롭게 구현할 수 있습니다. 클라이언트는 READ에서 반환된 영향을 받는 바이트 범위의 바이트가 0이 될 것이라는 점 외에는 서버의 이 기능 구현과 관련하여 어떠한 가정도 해서는 안 됩니다. 서버는 SETATTR을 통해 파일 크기 확장을 지원해야 합니다.\(MUST\)

SETATTR은 원자성이 보장되지 않습니다. 실패한 SETATTR은 파일의 속성을 부분적으로 변경할 수 있으므로 응답에는 항상 설정된 속성 목록과 상태가 포함됩니다.

속성이 변경되는 객체에 SETATTR을 수행하는 클라이언트가 아닌 다른 클라이언트가 보유한 파일 위임이 있는 경우 위임을 회수해야 하며 각 위임이 완료될 때까지 작업은 실제로 속성 변경을 진행할 수 없습니다. 반환 또는 취소됩니다. 위임이 회수되는 모든 경우에 서버는 위임이 미해결 상태로 유지되는 동안 하나 이상의 NFS4ERR\_DELAY 오류를 반환할 가능성이 높지만 위임이 빠르게 반환되는 경우에는 그렇게 하지 않을 수도 있습니다.

속성이 설정되는 개체가 디렉터리이고 다른 클라이언트가 해당 디렉터리에 대한 디렉터리 위임을 보유한 경우, 활성화된 경우 변경된 속성 집합이 해당 디렉터리에 대한 속성 집합과 null이 아닌 교차점을 가질 때 비동기 알림이 생성됩니다. 알림이 요청됩니다. NOTIFY4\_CHANGE\_DIR\_ATTRS 유형의 알림은 해당 클라이언트로 전송되지만 SETATTR은 이러한 알림이 전송될 때까지 기다리지 않습니다.

속성이 설정되는 객체가 다른 클라이언트가 디렉터리 위임을 보유한 디렉터리의 구성원인 경우 변경된 속성 집합이 알림이 설정된 속성 집합과 null이 아닌 교차점을 가질 때 비동기 알림이 생성됩니다. 요청했습니다. NOTIFY4\_CHANGE\_CHILD\_ATTRS 유형의 알림은 해당 클라이언트로 전송되지만 SETATTR은 이러한 알림이 전송될 때까지 기다리지 않습니다.

SETATTR을 사용하여 파일 크기를 변경하면 time\_modify 및 변경 속성이 간접적으로 변경됩니다. 크기 변경으로 인해 데이터가 삭제될 수 있으므로 클라이언트는 이를 고려해야 합니다.

time\_access\_set 및 time\_modify\_set 속성은 전환 통합으로 구성된 쓰기 전용 속성이므로 클라이언트가 서버에 시간 값 설정을 지시할 수 있습니다. Switched Union이 SET\_TO\_CLIENT\_TIME4를 지정하는 경우 클라이언트는 작업에 사용할 nfstime4를 제공한 것입니다. 스위치 통합이 SET\_TO\_CLIENT\_TIME4를 지정하지 않으면 서버는 SETATTR 작업에 현재 시간을 사용합니다.

서버 시간과 클라이언트 시간이 다른 경우 클라이언트 시간을 파일 시간과 비교하는 프로그램이 중단될 수 있습니다. 클라이언트/서버 시간 차이를 제한하려면 시간 동기화 프로토콜을 사용해야 합니다.

변경 속성만 지정하고 바로 뒤에 SETATTR이 오는 VERIFY 작업이 포함된 COMPOUND를 사용하면 클라이언트가 NFSv3의 SETATTR 가드 메커니즘의 기능을 에뮬레이트하는 요청을 지정할 수 있는 수단을 제공합니다. 가드 메커니즘의 기능은 오래된 정보를 기반으로 파일 속성의 변경을 방지하는 것이므로 가드 조건 확인과 속성 설정 사이의 지연으로 인해 NFSv4 에뮬레이션의 해당 지연과 마찬가지로 이 기능이 손상될 가능성이 있습니다. . 따라서 NFSv4.1 서버는 이러한 요청을 실행할 때 가능한 한 이러한 지연을 방지하도록 주의해야 합니다.\(SHOULD\)

서버가 클라이언트가 요청한 속성을 지원하지 않는 경우 서버는 NFS4ERR\_ATTRNOTSUPP를 반환해야 합니다.\(SHOULD\)

실제로 설정된 속성의 마스크는 모든 경우에 SETATTR에 의해 반환됩니다. 해당 마스크에는 클라이언트가 설정하도록 요청하지 않은 속성 비트가 포함되어서는 안 됩니다. 요청과 응답의 속성 마스크가 동일한 경우 응답의 상태 필드는 NFS4\_OK여야 합니다.\(MUST NOT, MUST\)

---
### **18.31.  Operation 37: VERIFY - Verify Same Attributes**
---
#### **18.31.1.  ARGUMENTS**

```text
   struct VERIFY4args {
           /* CURRENT_FH: object */
           fattr4          obj_attributes;
   };
```

---
#### **18.31.2.  RESULTS**

```text
   struct VERIFY4res {
           nfsstat4        status;
   };
```

---
#### **18.31.3.  DESCRIPTION**

VERIFY 작업은 COMPOUND 요청에서 다음 작업을 진행하기 전에 속성에 클라이언트가 가정한 값이 있는지 확인하는 데 사용됩니다. 속성 중 하나라도 일치하지 않으면 NFS4ERR\_NOT\_SAME 오류가 반환되어야 합니다. 현재 파일 핸들은 작업이 성공적으로 완료된 후에도 해당 값을 유지합니다.

---
#### **18.31.4.  IMPLEMENTATION**

VERIFY 작업의 한 가지 가능한 용도는 다음과 같은 일련의 작업입니다. 이를 통해 클라이언트는 제거되는 파일이 클라이언트가 제거할 것으로 예상하는 파일과 일치하는지 확인하려고 시도합니다. 이 시리즈는 의도하지 않은 파일 삭제를 방지하는 데 도움이 될 수 있습니다.

```text
         PUTFH (directory filehandle)
         LOOKUP (file name)
         VERIFY (filehandle == fh)
         PUTFH (directory filehandle)
         REMOVE (file name)
```

이 시리즈는 두 번째 클라이언트가 이 시퀀스 중간에 새 파일을 제거하고 생성하는 것을 방지하지는 않지만 의도하지 않은 결과를 피하는 데 도움이 됩니다.

VERIFY 작업에 RECOMMENDED 속성이 지정되어 있고 서버가 파일 시스템 개체에 대해 해당 속성을 지원하지 않는 경우 NFS4ERR\_ATTRNOTSUPP 오류가 클라이언트에 반환됩니다.\(SHOULD\)

rdattr\_error 속성이나 설정 전용 속성\(예: time\_modify\_set\)이 지정되면 NFS4ERR\_INVAL 오류가 클라이언트에 반환됩니다.

---
### **18.32.  Operation 38: WRITE - Write to File**
---
#### **18.32.1.  ARGUMENTS**

```text
   enum stable_how4 {
           UNSTABLE4       = 0,
           DATA_SYNC4      = 1,
           FILE_SYNC4      = 2
   };

   struct WRITE4args {
           /* CURRENT_FH: file */
           stateid4        stateid;
           offset4         offset;
           stable_how4     stable;
           opaque          data<>;
   };
```

---
#### **18.32.2.  RESULTS**

```text
   struct WRITE4resok {
           count4          count;
           stable_how4     committed;
           verifier4       writeverf;
   };

   union WRITE4res switch (nfsstat4 status) {
    case NFS4_OK:
            WRITE4resok    resok4;
    default:
            void;
   };
```

---
#### **18.32.3.  DESCRIPTION**

WRITE 작업은 일반 파일에 데이터를 쓰는 데 사용됩니다. 대상 파일은 현재 파일 핸들로 지정됩니다. 오프셋은 데이터가 기록되어야 하는 오프셋을 지정합니다. 오프셋 0은 쓰기가 파일 시작 부분에서 시작되어야 함을 지정합니다. 불투명 데이터 매개변수의 일부로 인코딩된 개수는 기록될 데이터의 바이트 수를 나타냅니다. 개수가 0이면 WRITE가 성공하고 권한 확인에 따라 0의 개수를 반환합니다. 서버는 클라이언트가 요청한 것보다 적은 바이트를 쓸 수 있습니다.\(MAY\)

클라이언트는 stable 매개변수를 사용하여 서버에서 데이터를 처리하는 방법을 지정합니다. stable이 FILE\_SYNC4인 경우 서버는 결과를 반환하기 전에 기록된 데이터와 모든 파일 시스템 메타데이터를 안정적인 저장소에 커밋해야 합니다. 이는 NFSv2 프로토콜 의미 체계에 해당합니다. 다른 모든 행동은 프로토콜 위반으로 간주됩니다. stable이 DATA\_SYNC4인 경우 서버는 모든 데이터를 안정적인 저장소에 커밋해야 하며 반환하기 전에 데이터를 검색할 만큼 충분한 메타데이터를 커밋해야 합니다. 서버 구현자는 FILE\_SYNC4와 동일한 방식으로 DATA\_SYNC4를 자유롭게 구현할 수 있지만 성능이 저하될 수 있습니다. stable이 UNSTABLE4인 경우 서버는 클라이언트에 응답을 반환하기 전에 데이터와 메타데이터의 일부\(모두 또는 전혀 포함하지 않음\)를 stable 저장소에 자유롭게 커밋할 수 있습니다. 커밋되지 않은 데이터가 이후에 안정적인 저장소에 커밋되는지 여부와 시기가 보장되지 않습니다. 서버가 보장하는 유일한 것은 writeverf 값을 변경하지 않고 데이터를 삭제하지 않으며 클라이언트가 요청한 수준보다 낮은 수준에서 데이터와 메타데이터를 커밋하지 않는다는 것입니다.\(MUST, MUST\)

특수 stateid가 사용되는 경우를 제외하고 WRITE 요청의 stateid 값은 이전 바이트 범위 LOCK 또는 OPEN 요청에서 반환된 값이나 위임과 관련된 stateid를 나타냅니다. stateid는 연결된 소유자가 있는 경우 이를 식별하고 서버에서 연결된 잠금이 여전히 유효한지\(예: 취소되지 않았는지\) 확인하는 데 사용됩니다.

성공적으로 완료되면 다음 결과가 반환됩니다. 계산 결과는 파일에 기록된 데이터의 바이트 수입니다. 서버는 요청한 것보다 적은 바이트를 쓸 수 있습니다. 그렇다면 오프셋 위치에서 시작하여 쓰여진 실제 바이트 수가 반환됩니다.

서버는 또한 커밋을 통해 데이터 및 메타데이터의 커밋 수준 표시를 반환합니다. 표 20에 따르면,

\* 서버는 요청된 것보다 더 강력한 수준으로 데이터를 커밋할 수 있습니다.\(MAY\)

\* 서버는 최소한 커밋된 수준 이상으로 데이터를 커밋해야 합니다.\(MUST\)

```text
            +============+===================================+
            | stable     | committed                         |
            +============+===================================+
            | UNSTABLE4  | FILE_SYNC4, DATA_SYNC4, UNSTABLE4 |
            +------------+-----------------------------------+
            | DATA_SYNC4 | FILE_SYNC4, DATA_SYNC4            |
            +------------+-----------------------------------+
            | FILE_SYNC4 | FILE_SYNC4                        |
            +------------+-----------------------------------+

                Table 20: Valid Combinations of the Fields
                Stable in the Request and Committed in the
                                  Reply
```

결과의 마지막 부분은 writeverf 필드입니다. 이 필드는 쓰기 검증자이며 클라이언트가 WRITE 호출과 후속 WRITE 또는 COMMIT 호출 사이에 서버가 인스턴스 상태\(예: 서버 재시작\)를 변경했는지 여부를 확인하는 데 사용할 수 있는 쿠키입니다. 이 쿠키는 NFSv4.1 서버의 단일 인스턴스 동안 변경되지 않아야 하며 NFSv4.1 서버의 인스턴스 간에 고유해야 합니다. 쿠키가 변경되면 클라이언트는 커밋된 UNSTABLE4 값과 응답의 이전 writeverf로 작성된 모든 데이터가 손실되어 복구해야 한다고 가정해야 합니다.\(MUST, MUST\)

클라이언트가 UNSTABLE4로 설정된 안정적인 인수를 사용하여 서버에 데이터를 쓰고 응답이 DATA\_SYNC4 또는 UNSTABLE4의 커밋된 응답을 생성하는 경우 클라이언트는 나중에 COMMIT 작업을 수행하여 미해결 비동기 데이터와 메타데이터를 동기화합니다. 클라이언트 오류를 ​​제외하고 서버의 안정적인 저장 공간입니다. 클라이언트 충돌이나 기타 오류로 인해 후속 COMMIT가 서버에서 수신되지 않을 수도 있습니다.

모든 비트의 stateid 값이 0인 WRITE의 경우, 서버는 필수 바이트 범위 잠금 또는 파일에 대한 현재 공유 거부 모드에 따라 WRITE가 서비스되도록 허용할 수 있습니다. 모든 비트의 stateid 값이 1인 WRITE의 경우 서버는 WRITE 작업이 서버의 잠금 검사를 우회하도록 허용해서는 안 되며, 그렇지 않은 경우 모든 비트의 stateid가 0인 것처럼 처리됩니다.\(MAY, MUST NOT\)

성공하면 현재 파일 핸들이 해당 값을 유지합니다.

---
#### **18.32.4.  IMPLEMENTATION**

서버가 클라이언트가 요청한 것보다 적은 바이트의 데이터를 쓰는 것이 가능합니다. 이 경우 데이터가 전혀 기록되지 않는 한 서버는 오류를 반환해서는 안 됩니다. 서버가 지정된 바이트 수보다 적게 쓰는 경우 클라이언트는 나머지 데이터를 쓰기 위해 또 다른 WRITE를 보내야 합니다.\(SHOULD NOT\)

파일에 데이터를 쓰는 행위로 인해 파일의 time\_modified 및 변경 속성이 업데이트되는 것으로 가정됩니다. 그러나 파일의 내용이 변경되지 않는 한 이러한 속성은 변경되어서는 안 됩니다. 따라서 개수가 0으로 설정된 WRITE 요청으로 인해 파일의 time\_modified 및 변경 속성이 업데이트되어서는 안 됩니다.\(SHOULD NOT, SHOULD NOT\)

안정적인 스토리지는 다음과 같이 지속되는 영구 스토리지입니다.

```text
   1.  Repeated power failures.

   2.  Hardware failures (of any board, power supply, etc.).
```

3. 소프트웨어가 충돌하고 다시 시작되는 일이 반복됩니다.

이 정의는 안정적인 저장소 모듈 자체의 오류를 다루지 않습니다.

검증자는 캐시된 커밋되지 않은 데이터가 손실될 수 있는 NFSv4.1 프로토콜 서버의 다양한 인스턴스를 클라이언트가 감지할 수 있도록 정의됩니다. 대부분의 경우 검증자는 클라이언트가 서버 다시 시작을 감지하도록 허용합니다. 이 정보는 클라이언트가 서버에서 캐시된 데이터가 손실되었는지 여부를 안전하게 판단할 수 있도록 하는 데 필요합니다. 서버가 예기치 않게 실패하고 클라이언트에 이전 WRITE 요청에서 커밋되지 않은 데이터가 있는 경우\(안정적인 인수가 UNSTABLE4로 설정되어 수행되고 커밋된 결과도 UNSTABLE4로 반환됨\) 서버가 캐시된 데이터를 안정적인 저장소로 플러시하지 않았을 수 있습니다. 복구 부담은 클라이언트에 있으며 클라이언트는 데이터를 서버로 재전송해야 합니다.

제안된 검증 도구는 서버가 마지막으로 시작된 시간을 사용하는 것입니다\(서버를 다시 시작하면 버퍼가 손실되는 경우\).

응답의 커밋된 필드를 통해 클라이언트는 보다 효과적인 캐싱을 수행할 수 있습니다. 서버가 모든 WRITE 요청을 안정적인 저장소에 커밋하는 경우 인수의 stable 필드 값에 관계없이 커밋된 설정을 FILE\_SYNC4로 반환해야 합니다. NVRAM 가속기를 사용하는 서버는 이 정책을 구현하도록 선택할 수 있습니다. 클라이언트는 이를 사용하여 서버에 이미 커밋된 캐시된 데이터를 삭제하여 캐시의 효율성을 높일 수 있습니다.\(SHOULD\)

일부 구현에서는 사용자 할당량이 초과되면 NFS4ERR\_DQUOT 대신 NFS4ERR\_NOSPC를 반환할 수 있습니다.

현재 파일 핸들이 NF4DIR 유형인 경우 서버는 NFS4ERR\_ISDIR을 반환합니다. 현재 파일이 심볼릭 링크이면 NFS4ERR\_SYMLINK 오류가 반환됩니다. 그렇지 않고 현재 파일 핸들이 일반 파일을 지정하지 않으면 서버는 NFS4ERR\_WRONG\_TYPE을 반환합니다.

파일에 대해 필수 바이트 범위 잠금이 적용되고 파일에 기록될 데이터의 해당 바이트 범위가 stateid와 연결되지 않은 소유자에 의해 READ\_LT 또는 WRITE\_LT 잠긴 경우 서버는 NFS4ERR\_LOCKED를 반환해야 합니다. 그렇다면 클라이언트는 WRITE 작업에 사용된 stateid에 해당하는 소유자가 기록될 바이트 범위와 겹치는 충돌하는 READ\_LT 잠금을 가지고 있는지 확인해야 합니다. stateid의 소유자에게 충돌하는 READ\_LT 잠금이 없으면 클라이언트는 WRITE를 다시 시도하기 전에 LOCK 작업을 통해 적절한 쓰기 바이트 범위 잠금을 얻으려고 시도해야 합니다. WRITE가 완료되면 클라이언트는 LOCKU를 통해 바이트 범위 잠금을 해제해야 합니다.\(MUST, MUST, SHOULD, SHOULD\)

stateid의 소유자가 충돌하는 READ\_LT 잠금을 갖고 있는 경우 클라이언트는 WRITE를 시도한 애플리케이션에 오류를 반환할 수밖에 없습니다. 그 이유는 stateid의 소유자가 READ\_LT 잠금을 갖고 있었기 때문에 서버가 일시적으로 이 READ\_LT 잠금을 WRITE\_LT 잠금으로 효과적으로 업그레이드하려고 시도했거나 서버에 업그레이드 기능이 없기 때문입니다. 서버가 READ\_LT 잠금 업그레이드를 시도했지만 실패한 경우 클라이언트가 LOCK 작업을 통해 업그레이드를 다시 시도하는 것은 의미가 없습니다. 왜냐하면 업그레이드를 시도하는 다른 클라이언트도 있을 수 있기 때문입니다. 동일한 잠금을 업그레이드하려고 두 클라이언트가 차단되면 클라이언트가 교착 상태가 됩니다. 서버에 업그레이드 기능이 없으면 업그레이드를 위해 LOCK 작업을 시도하는 것은 의미가 없습니다.

하나 이상의 다른 클라이언트가 작성 중인 파일에 대한 위임을 갖고 있는 경우 해당 위임을 회수해야 하며 해당 위임이 반환되거나 취소될 때까지 작업을 진행할 수 없습니다. 매우 빠르게 발생하는 경우를 제외하고 위임이 미해결 상태로 유지되는 동안 요청에 하나 이상의 NFS4ERR\_DELAY 오류가 반환됩니다. 일반적으로 위임은 이전 OPEN의 결과로 호출이 발생하므로 WRITE 작업의 결과로 호출되지 않습니다. 그러나 특수한 stateid를 사용하여 WRITE를 수행하는 것이 가능하므로 클라이언트가 이전에 OPEN을 수행했어야 하더라도 서버는 이 경우를 확인해야 합니다.\(MUST\)

---
### **18.33.  Operation 40: BACKCHANNEL_CTL - Backchannel Control**
---
#### **18.33.1.  ARGUMENT**

```text
   typedef opaque gsshandle4_t<>;

   struct gss_cb_handles4 {
           rpc_gss_svc_t           gcbp_service; /* RFC 2203 */
           gsshandle4_t            gcbp_handle_from_server;
           gsshandle4_t            gcbp_handle_from_client;
   };

   union callback_sec_parms4 switch (uint32_t cb_secflavor) {
   case AUTH_NONE:
           void;
   case AUTH_SYS:
           authsys_parms   cbsp_sys_cred; /* RFC 5531 */
   case RPCSEC_GSS:
           gss_cb_handles4 cbsp_gss_handles;
   };

   struct BACKCHANNEL_CTL4args {
           uint32_t                bca_cb_program;
           callback_sec_parms4     bca_sec_parms<>;
   };
```

---
#### **18.33.2.  RESULT**

```text
   struct BACKCHANNEL_CTL4res {
           nfsstat4                bcr_status;
   };
```

---
#### **18.33.3.  DESCRIPTION**

BACKCHANNEL\_CTL 작업은 백채널의 콜백 프로그램 번호를 대체하고 백채널에서 사용할 RPCSEC\_GSS 핸들을 추가합니다\(대체 아님\).

BACKCHANNEL\_CTL 호출의 인수는 CREATE\_SESSION 매개변수의 하위 집합입니다. BACKCHANNEL\_CTL 인수에서 bca\_cb\_program 필드와 bca\_sec\_parms 필드는 각각 CREATE\_SESSION 인수의 csa\_cb\_program 및 csa\_sec\_parms 필드에 해당합니다\(18.36절\).

BACKCHANNEL\_CTL은 SEQUENCE로 시작하는 COMPOUND에 나타나야 합니다.\(MUST\)

gcbp\_handle\_from\_server로 식별된 RPCSEC\_GSS 핸들이 서버에 없으면 서버는 NFS4ERR\_NOENT를 반환해야 합니다.\(MUST\)

RPCSEC\_GSS 핸들이 SSV 컨텍스트\(섹션 2.10.9 참조\)를 사용하는 경우 각 SSV RPCSEC\_GSS 핸들이 공통 SSV GSS 컨텍스트를 공유하기 때문에 섹션 2.10.10에서 논의된 이 상황과 관련된 보안 고려 사항이 있습니다.

18.34. 작업 41: BIND\_CONN\_TO\_SESSION - 세션과 연결 연결

---
#### **18.34.1.  ARGUMENT**

```text
   enum channel_dir_from_client4 {
    CDFC4_FORE             = 0x1,
    CDFC4_BACK             = 0x2,
    CDFC4_FORE_OR_BOTH     = 0x3,
    CDFC4_BACK_OR_BOTH     = 0x7
   };

   struct BIND_CONN_TO_SESSION4args {
    sessionid4     bctsa_sessid;

    channel_dir_from_client4
                   bctsa_dir;

    bool           bctsa_use_conn_in_rdma_mode;
   };
```

---
#### **18.34.2.  RESULT**

```text
   enum channel_dir_from_server4 {
    CDFS4_FORE     = 0x1,
    CDFS4_BACK     = 0x2,
    CDFS4_BOTH     = 0x3
   };

   struct BIND_CONN_TO_SESSION4resok {
    sessionid4     bctsr_sessid;

    channel_dir_from_server4
                   bctsr_dir;

    bool           bctsr_use_conn_in_rdma_mode;
   };

   union BIND_CONN_TO_SESSION4res
    switch (nfsstat4 bctsr_status) {

    case NFS4_OK:
     BIND_CONN_TO_SESSION4resok
                   bctsr_resok4;

    default:       void;
   };
```

---
#### **18.34.3.  DESCRIPTION**

BIND\_CONN\_TO\_SESSION은 추가 연결을 세션과 연결하는 데 사용됩니다. 세션과 연관된 연결에서 사용해야 합니다. 이는 COMPOUND 프로시저의 유일한 작업이어야 합니다. SP4\_NONE\(18.35절\) 상태 보호가 사용되는 경우 모든 주체, 보안 특성 또는 RPCSEC\_GSS 컨텍스트를 사용하여 작업을 호출할 수 있습니다. SP4\_MACH\_CRED를 사용하는 경우 RPCSEC\_GSS는 클라이언트 ID를 생성한 주체를 사용하여 무결성 또는 개인 정보 보호 서비스와 함께 사용해야 합니다. SP4\_SSV가 사용되는 경우 SSV GSS 메커니즘\(섹션 2.10.9\) 및 무결성 또는 개인 정보 보호 기능이 있는 RPCSEC\_GSS를 사용해야 합니다.\(MUST, MUST, MAY, MUST, MUST\)

클라이언트 ID가 생성되었을 때 클라이언트가 SP4\_NONE 상태 보호를 선택한 경우 클라이언트가 연결을 백채널과 연결하려고 하지 않는 한 클라이언트는 연결을 세션과 연결하기 위해 BIND\_CONN\_TO\_SESSION을 사용할 필요가 없습니다. SP4\_NONE 보호가 사용되는 경우 SEQUENCE 작업과 함께 COMPOUND 요청을 보내는 것만으로도 SEQUENCE에 지정된 세션과 연결을 연결하는 데 충분합니다.

bctsa\_dir 필드는 클라이언트가 연결을 전방 채널, 백채널 또는 두 채널 모두와 연결하기를 원하는지 여부를 나타냅니다. CDFC4\_FORE\_OR\_BOTH 값은 클라이언트가 연결을 포어 채널 및 백채널 모두와 연결하려고 하지만 포어 채널에만 연결된 연결을 허용함을 나타냅니다. CDFC4\_BACK\_OR\_BOTH 값은 클라이언트가 전방 채널과 백채널 모두와 연결하기를 원하지만 백채널과만 연결된 연결을 수락함을 나타냅니다. 서버는 연결이 연결된 채널을 bctsr\_dir에 응답합니다. 클라이언트가 CDFC4\_FORE를 지정한 경우 서버는 CDFS4\_FORE를 반환해야 합니다. 클라이언트가 CDFC4\_BACK을 지정한 경우 서버는 CDFS4\_BACK을 반환해야 합니다. 클라이언트가 CDFC4\_FORE\_OR\_BOTH를 지정한 경우 서버는 CDFS4\_FORE 또는 CDFS4\_BOTH를 반환해야 합니다. 클라이언트가 CDFC4\_BACK\_OR\_BOTH를 지정한 경우 서버는 CDFS4\_BACK 또는 CDFS4\_BOTH를 반환해야 합니다.\(MUST, MUST, MUST, MUST\)

CREATE\_SESSION 작업\(18.36절\)을 참조하고, bctsa\_use\_conn\_in\_rdma\_mode를 이해하려면 csa\_use\_conn\_in\_rdma\_mode 인수에 대한 설명을, bctsr\_use\_conn\_in\_rdma\_mode를 이해하려면 csr\_use\_conn\_in\_rdma\_mode에 대한 설명을 참조하세요.

지정된 세션과 이미 연결된 연결에서 BIND\_CONN\_TO\_SESSION을 호출하면 아무런 효과가 없으며 클라이언트가 연결과 연결된 채널 집합에 대한 변경을 요구하지 않는 한 서버는 NFS4\_OK로 응답해야 합니다. 그렇다면 서버는 NFS4ERR\_INVAL을 반환해야 합니다.\(MUST, MUST\)

---
#### **18.34.4.  IMPLEMENTATION**

세션 채널의 모든 연결이 끊어지면 클라이언트 ID의 상태 보호 및 채널 유형에 따라 클라이언트는 BIND\_CONN\_TO\_SESSION을 사용하여 새 연결을 연결해야 할 수도 있습니다. 서버가 다시 시작되고 응답 캐시를 안정적인 저장소에 보관하지 않으면 서버는 세션 ID를 인식하지 못합니다. 클라이언트는 궁극적으로 EXCHANGE\_ID를 호출하여 새 클라이언트 ID와 세션을 생성해야 합니다.

SP4\_SSV 상태 보호가 사용되고 있고 BIND\_CONN\_TO\_SESSION이 클라이언트 ID가 생성될 때 spo\_must\_enforce 세트에 포함된 작업 중 하나라고 가정합니다\(18.35절\). 그렇다면 SET\_SSV가 전송되고 응답이 반환되지 않으며 클라이언트 ID와 연결된 마지막 연결이 끊어지면 문제가 있는 것입니다. 클라이언트는 세션 모델에 따라 SET\_SSV를 다시 시도해야 합니다. 하지만 그렇게 하려면 새로운 연결이 필요하며 SSV GSS 메커니즘으로 인증된 BIND\_CONN\_TO\_SESSION을 통해 해당 연결을 세션과 연결해야 합니다. 문제는 RPCSEC\_GSS 메시지 무결성 코드가 SSV에서 파생된 하위 키를 키로 사용하고 SSV가 변경되었을 수 있다는 것입니다. 여러 가지 복구 전략이 있지만 여기서는 일반적인 단일 전략을 설명합니다.\(MUST, MUST\)

\* 클라이언트가 다시 연결됩니다.

\* 클라이언트는 SET\_SSV가 실행되었다고 가정하고 RPCSEC\_GSS 자격 증명 메시지 무결성 코드의 키로 사용되는 하위 키\(새 SSV에서 파생됨, 즉 SET\_SSV가 SSV를 설정한 키\)와 함께 BIND\_CONN\_TO\_SESSION을 보냅니다.

\* 요청이 성공하면 원래 시도된 SET\_SSV가 성공적으로 실행되었음을 의미합니다. 클라이언트는 서버가 응답 캐시를 통해 응답할 원본 SET\_SSV를 다시 보냅니다.

\* 서버가 RPC 인증 오류를 반환하는 경우 이는 서버의 현재 SSV가 변경되지 않았음을 의미합니다\(그리고 SET\_SSV가 실행되지 않았을 가능성이 높습니다\). 그런 다음 클라이언트는 이전 SSV에서 파생된 하위 키를 RPCSEC\_GSS 메시지 무결성 코드의 키로 사용하여 BIND\_CONN\_TO\_SESSION을 시도합니다.

\* 이전 SSV를 사용한 BIND\_CONN\_TO\_SESSION 시도는 성공해야 합니다. 그렇다면 클라이언트는 원래 SET\_SSV를 다시 보냅니다. 원래 SET\_SSV가 실행되지 않은 경우 서버가 이를 실행합니다. 원래 SET\_SSV가 실행되었지만 실패한 경우 서버는 응답 캐시에서 SET\_SSV를 반환합니다.

---
### **18.35.  Operation 42: EXCHANGE_ID - Instantiate Client ID**

EXCHANGE\_ID 작업은 긴 클라이언트 및 서버 식별자\(소유자\)를 교환하고 필요한 경우 클라이언트 ID를 생성하여 클라이언트 ID에 대한 액세스를 제공합니다. 이 클라이언트 ID는 작업이 수행되는 연결과 연결되므로 CREATE\_SESSION이 완료되거나 연결이 현재 클라이언트와 연결된 기존 세션에 대한 요청을 발행하는 데 사용될 때 사용할 수 있습니다.

---
#### **18.35.1.  ARGUMENT**

```text
   const EXCHGID4_FLAG_SUPP_MOVED_REFER    = 0x00000001;
   const EXCHGID4_FLAG_SUPP_MOVED_MIGR     = 0x00000002;

   const EXCHGID4_FLAG_BIND_PRINC_STATEID  = 0x00000100;

   const EXCHGID4_FLAG_USE_NON_PNFS        = 0x00010000;
   const EXCHGID4_FLAG_USE_PNFS_MDS        = 0x00020000;
   const EXCHGID4_FLAG_USE_PNFS_DS         = 0x00040000;

   const EXCHGID4_FLAG_MASK_PNFS           = 0x00070000;

   const EXCHGID4_FLAG_UPD_CONFIRMED_REC_A = 0x40000000;
   const EXCHGID4_FLAG_CONFIRMED_R         = 0x80000000;

   struct state_protect_ops4 {
           bitmap4 spo_must_enforce;
           bitmap4 spo_must_allow;
   };

   struct ssv_sp_parms4 {
           state_protect_ops4      ssp_ops;
           sec_oid4                ssp_hash_algs<>;
           sec_oid4                ssp_encr_algs<>;
           uint32_t                ssp_window;
           uint32_t                ssp_num_gss_handles;
   };

   enum state_protect_how4 {
           SP4_NONE = 0,
           SP4_MACH_CRED = 1,
           SP4_SSV = 2
   };

   union state_protect4_a switch(state_protect_how4 spa_how) {
           case SP4_NONE:
                   void;
           case SP4_MACH_CRED:
                   state_protect_ops4      spa_mach_ops;
           case SP4_SSV:
                   ssv_sp_parms4           spa_ssv_parms;
   };

   struct EXCHANGE_ID4args {
           client_owner4           eia_clientowner;
           uint32_t                eia_flags;
           state_protect4_a        eia_state_protect;
           nfs_impl_id4            eia_client_impl_id<1>;
   };
```

---
#### **18.35.2.  RESULT**

```text
   struct ssv_prot_info4 {
    state_protect_ops4     spi_ops;
    uint32_t               spi_hash_alg;
    uint32_t               spi_encr_alg;
    uint32_t               spi_ssv_len;
    uint32_t               spi_window;
    gsshandle4_t           spi_handles<>;
   };

   union state_protect4_r switch(state_protect_how4 spr_how) {
    case SP4_NONE:
            void;
    case SP4_MACH_CRED:
            state_protect_ops4     spr_mach_ops;
    case SP4_SSV:
            ssv_prot_info4         spr_ssv_info;
   };

   struct EXCHANGE_ID4resok {
    clientid4        eir_clientid;
    sequenceid4      eir_sequenceid;
    uint32_t         eir_flags;
    state_protect4_r eir_state_protect;
    server_owner4    eir_server_owner;
    opaque           eir_server_scope<NFS4_OPAQUE_LIMIT>;
    nfs_impl_id4     eir_server_impl_id<1>;
   };

   union EXCHANGE_ID4res switch (nfsstat4 eir_status) {
   case NFS4_OK:
    EXCHANGE_ID4resok      eir_resok4;

   default:
    void;
   };
```

---
#### **18.35.3.  DESCRIPTION**

클라이언트는 EXCHANGE\_ID 작업을 사용하여 client\_owner4가 나타내는 대로 해당 클라이언트의 특정 인스턴스를 서버에 등록합니다. 그러나 client\_owner4가 이미 다른 수단\(예: Transparent State Migration\)을 통해 등록된 경우 클라이언트는 여전히 EXCHANGE\_ID를 사용하여 이전에 할당된 클라이언트 ID를 얻을 수 있습니다.

이 작업에서 반환된 클라이언트 ID는 EXCHANGE\_ID가 수신된 연결과 연결되며 이 연결에서 클라이언트가 생성했거나 연결이 바인딩된 세션의 상위 개체 역할을 합니다. 해당 세션을 사용하여 상태 생성과 관련된 요청을 수행한 결과 해당 상태는 반환된 클라이언트 ID와 연결됩니다.

이전에 client\_owner 등록이 발생하지 않은 상황에서는 CREATE\_SESSION을 사용하여 연결된 세션을 생성할 때 반환된 eir\_sequenceid와 함께 클라이언트 ID를 먼저 사용해야 합니다.

EXCHGID4\_FLAG\_CONFIRMED\_R 플래그가 eir\_flags 결과에 설정된 경우 이는 client\_owner 등록이 이미 발생했으며 이를 확인하기 위해 추가 CREATE\_SESSION이 필요하지 않음을 나타냅니다. 물론 다른 이유로 인해 후속 CREATE\_SESSION 작업이 필요할 수도 있습니다.

eir\_sequenceid 값은 반환된 클라이언트 ID와 관련된 초기 시퀀스 값을 설정하는 데 사용됩니다. CREATE\_SESSION이 이미 완료된 경우 해당 요청의 순서가 이미 설정되어 있으므로 이 값이 필요하지 않으며 클라이언트는 이 값이 필요하지 않으며 이를 무시합니다.

EXCHANGE\_ID는 SEQUENCE로 시작하는 COMPOUND 프로시저에서 전송될 수 있습니다. 그러나 클라이언트가 처음으로 서버와 통신할 때는 세션이 없으므로 SEQUENCE를 사용할 수 없습니다. EXCHANGE\_ID가 선행 SEQUENCE 없이 전송되면 이는 COMPOUND 프로시저 요청의 유일한 작업이어야 합니다. 그렇지 않은 경우 서버는 NFS4ERR\_NOT\_ONLY\_OP를 반환해야 합니다.\(MAY, MUST, MUST\)

eia\_clientowner 필드는 co\_verifier 필드와 co\_ownerid 문자열로 구성됩니다. 섹션 2.4에서 설명한 대로 co\_ownerid는 클라이언트를 식별하고 co\_verifier는 해당 클라이언트의 특정 구현을 지정합니다. 클라이언트의 새로운 구현과 함께 전송된 EXCHANGE\_ID는 서버가 이전 구현의 잠금 상태를 제거하도록 유도합니다. 반면, 현재 구현 및 co\_ownerid와 함께 전송된 EXCHANGE\_ID가 관련 없는 오류를 발생시키지 않으면 잠재적으로 기존 클라이언트 ID의 속성을 업데이트하거나 단순히 기존 client\_id에 대한 정보를 반환합니다. 후자는 트렁크 연결 생성의 일부로 다른 네트워크 주소를 사용하여 동일한 서버에 대해 이 작업을 수행할 때 발생합니다.

서버는 eia\_clientowner의 서로 다른 두 가지 구현에 동일한 클라이언트 ID를 제공해서는 안 됩니다.\(MUST NOT\)

클라이언트 ID 및 시퀀스 ID 외에도 서버는 서버 소유자\(eir\_server\_owner\) 및 서버 범위\(eir\_server\_scope\)를 반환합니다. 전자 필드는 섹션 2.10.5에 설명된 대로 네트워크 트렁킹과 관련하여 사용됩니다. 후자 필드는 파일 시스템 마이그레이션 시 한 서버에서 보낸 클라이언트 ID를 다른 서버에서 인식할 수 있는 시기를 클라이언트가 결정할 수 있도록 하는 데 사용됩니다\(현재 문서의 섹션 11.11.9 참조\).

EXCHANGE\_ID에서 반환된 클라이언트 ID는 eir\_server\_owner.so\_major\_id 및 eir\_server\_scope의 조합에 대해서만 고유합니다. 따라서 두 서버가 동일한 클라이언트 ID를 반환하는 경우 eir\_server\_owner.so\_major\_id 및 eir\_server\_scope를 기반으로 클라이언트 ID를 구별할 책임은 클라이언트에 있습니다. 두 개의 다른 서버가 server\_owner.so\_major\_id 및 eir\_server\_scope와 일치한다고 주장하는 경우 클라이언트는 섹션 2.10.5.1에 ​​설명된 확인 기술을 사용하여 서버가 서로 다른지 확인할 수 있습니다. 서로 다른 경우 클라이언트는 각 서버에 사용되는 연결의 대상 네트워크 주소를 기록하고 네트워크 주소를 최종 판별자로 사용해야 합니다.

서버 소유자의 so\_major\_id 및 서버 범위에 표현된 고유 ID로 정의된 서버는 전달하는 각 클라이언트 ID의 여러 속성을 추적해야 합니다. 속성은 클라이언트 ID 및 클라이언트 ID와 연결된 모든 세션에 적용됩니다. 속성은 EXCHANGE\_ID의 인수와 결과에서 파생됩니다. 클라이언트 ID 속성에는 다음이 포함됩니다.

\* EXCHANGE\_ID의 결과에서 나오는 다음 비트로 표현되는 기능:

```text
      -  EXCHGID4_FLAG_SUPP_MOVED_REFER

      -  EXCHGID4_FLAG_SUPP_MOVED_MIGR

      -  EXCHGID4_FLAG_BIND_PRINC_STATEID

      -  EXCHGID4_FLAG_USE_NON_PNFS

      -  EXCHGID4_FLAG_USE_PNFS_MDS

      -  EXCHGID4_FLAG_USE_PNFS_DS
```

이러한 속성은 후속 EXCHANGE\_ID에 의해 업데이트될 수 있습니다.

- 확인된 클라이언트 ID에 대한 작업은 서버가 변경을 거부할 수도 있습니다.\(MAY\)

\* EXCHANGE\_ID에 대한 인수의 spa\_how 필드에 의해 설정된 SP4\_NONE, SP4\_MACH\_CRED 또는 SP4\_SSV 중 하나인 사용된 상태 보호 방법입니다. 클라이언트 ID가 확인되면 후속 EXCHANGE\_ID 작업으로 이 속성을 업데이트할 수 없습니다.

\* SP4\_MACH\_CRED 또는 SP4\_SSV 상태 보호의 경우:

- - 지정된 상태 보호를 사용해야 하는 작업 목록\(spo\_must\_enforce\)입니다. 이 목록은 EXCHANGE\_ID의 결과에서 제공됩니다.\(MUST\)

- - 지정된 상태 보호를 사용할 수 있는 작업 목록\(spo\_must\_allow\)입니다. 이 목록은 EXCHANGE\_ID의 결과에서 제공됩니다.\(MAY\)

- 클라이언트 ID가 확인되면 후속 EXCHANGE\_ID 요청으로 이러한 속성을 업데이트할 수 없습니다.

\* SP4\_SSV 보호의 경우:

- - 해시 알고리즘의 OID입니다. 이 속성은 EXCHANGE\_ID 인수의 ssp\_hash\_algs 필드에 있는 알고리즘 중 하나로 표시됩니다. 클라이언트 ID가 확인되면 후속 EXCHANGE\_ID 요청으로 이 속성을 업데이트할 수 없습니다.

- 암호화 알고리즘의 OID입니다. 이 속성은

- EXCHANGE\_ID 인수의 ssp\_encr\_algs 필드에 있는 알고리즘 중 하나로 표시됩니다. 클라이언트 ID가 확인되면 후속 EXCHANGE\_ID 요청으로 이 속성을 업데이트할 수 없습니다.

- - SSV의 길이입니다. 이 속성은 EXCHANGE\_ID 결과의 spi\_ssv\_len 필드로 표시됩니다. 클라이언트 ID가 확인되면 후속 EXCHANGE\_ID 작업으로 이 속성을 업데이트할 수 없습니다.

- 암호화 알고리즘의 키 길이\("키 길이"\), 해시 알고리즘의 출력 길이\("해시 길이"\), SSV 길이\("SSV 길이"\) 사이에는 필수 및 권장 관계가 있습니다. \).\(MUST\)

- o 키 길이는 <= 해시 ​​길이여야 합니다. 이는 암호화 알고리즘에 사용되는 키가 실제로 SSV에서 파생된 하위 키이고 파생이 해시 알고리즘을 통해 이루어지기 때문입니다. 해시 알고리즘의 출력 길이를 초과하는 키 길이를 가진 암호화 알고리즘을 선택하려면 패딩이 필요하므로 암호화 알고리즘의 사용이 약화됩니다.\(MUST\)

- o 해시 길이는 <= SSV 길이여야 합니다. 이는 SSV가 HMAC를 통해 하위 키를 파생하는 데 사용되는 키이기 때문이며, HMAC에 대한 입력으로 사용되는 키는 적어도 HMAC의 해시 알고리즘 출력 길이만큼 길도록 권장됩니다\(\[52의 3절 참조\). \]\).\(SHOULD\)

- o 키 길이는 <= SSV 길이여야 합니다. 이는 위의 두 불변값의 전이적 결과입니다.\(SHOULD\)

- o 키 길이는 \>= 해시 길이 / 2여야 합니다. 이는 하위 키 파생이 HMAC를 통해 이루어지기 때문이며 HMAC를 잘라야 하는 경우 해시 길이의 절반 미만으로 자르지 않는 것이 좋습니다\(참조 RFC 2104 \[52\]의 섹션 4\).\(SHOULD\)

- - 클라이언트와 서버가 지원할 SSV의 동시 버전 수\(섹션 2.10.9 참조\). 이 속성은 EXCHANGE\_ID 결과에서 spi\_window로 표시됩니다. 후속 EXCHANGE\_ID 작업을 통해 속성이 업데이트될 수 있습니다.

\* 클라이언트의 구현 ID는 다음과 같습니다.

- 인수의 eia\_client\_impl\_id 필드입니다. 후속 EXCHANGE\_ID 요청으로 속성이 업데이트될 수 있습니다.

\* 서버의 구현 ID는 다음과 같습니다.

- 응답의 eir\_server\_impl\_id 필드입니다. 후속 EXCHANGE\_ID 요청에 대한 응답으로 속성이 업데이트될 수 있습니다.

인수의 일부로 전달된 eia\_flags와 eir\_flags 결과를 통해 클라이언트와 서버는 서로의 기능을 알리고 클라이언트 ID가 사용되는 방법을 나타낼 수 있습니다. 인수 플래그에서 비트가 설정되거나 지워지는지 여부는 서버가 결과 측에서 동일한 비트를 설정하거나 지우도록 강제하지 않습니다. 위에서 정의되지 않은 비트는 eia\_flags 필드에 설정할 수 없습니다. 그렇다면 서버는 NFS4ERR\_INVAL을 사용한 작업을 거부해야 합니다.\(MUST\)

EXCHGID4\_FLAG\_UPD\_CONFIRMED\_REC\_A 비트는 eia\_flags에서만 설정할 수 있습니다. eir\_flags에서는 항상 꺼져 있습니다. EXCHGID4\_FLAG\_CONFIRMED\_R 비트는 eir\_flags에서만 설정할 수 있습니다. eia\_flags에서는 항상 꺼져 있습니다. 서버가 co\_ownerid와 co\_verifier가 확인된 클라이언트 ID에 매핑된 것으로 인식하면 eir\_flags에 EXCHGID4\_FLAG\_CONFIRMED\_R을 설정합니다. EXCHGID4\_FLAG\_CONFIRMED\_R 플래그를 사용하면 클라이언트는 생성하려는 클라이언트 ID가 이미 존재하고 확인되었는지 알 수 있습니다.

EXCHGID4\_FLAG\_UPD\_CONFIRMED\_REC\_A가 eia\_flags에 설정된 경우 이는 클라이언트가 기존 확인된 클라이언트 ID의 속성을 업데이트하려고 시도하고 있음을 의미합니다\(클라이언트가 확인되지 않은 클라이언트 ID의 속성을 업데이트하려는 경우 EXCHGID4\_FLAG\_UPD\_CONFIRMED\_REC\_A를 설정하면 안 됩니다\). 그렇다면 클라이언트가 EXCHANGE\_ID가 정확히 한 번 실행되도록 SEQUENCE와 동일한 COMPOUND에서 업데이트 EXCHANGE\_ID 작업을 보내는 것이 좋습니다. 클라이언트가 클라이언트 ID의 속성을 업데이트할 수 있는지 여부는 클라이언트 ID가 생성될 때 선택한 상태 보호와 EXCHANGE\_ID 작업을 보낼 때 사용한 보안 유형에 따라 달라집니다. 아래 섹션 18.35.4의 두 번째 목록의 항목 6, 7, 8 또는 9에 설명된 상황이 적용됩니다. 작업이 성공하고 이미 확인된 클라이언트 ID를 반환하는 경우 서버는 eir\_flags에 EXCHGID4\_FLAG\_CONFIRMED\_R 비트를 설정해야 합니다.\(MUST NOT, SHOULD, MUST\)

EXCHGID4\_FLAG\_UPD\_CONFIRMED\_REC\_A가 eia\_flags에 설정되지 않은 경우 이는 클라이언트가 새 클라이언트 ID를 설정하려고 시도하고 있음을 의미합니다. 서버와의 트렁크 데이터 통신을 시도하고 있습니다\(섹션 2.10.5 참조\). 또는 확인되지 않은 클라이언트 ID의 속성을 업데이트하려고 시도하고 있습니다. 아래 섹션 18.35.4의 두 번째 목록의 항목 1, 2, 3, 4 또는 5에 설명된 상황이 적용됩니다. 작업이 성공하고 이전에 확인된 클라이언트 ID를 반환하는 경우 서버는 eir\_flags에 EXCHGID4\_FLAG\_CONFIRMED\_R 비트를 설정해야 합니다.\(MUST\)

EXCHGID4\_FLAG\_SUPP\_MOVED\_REFER 플래그 비트가 설정되면 클라이언트는 참조 시퀀스의 일부로 NFS4ERR\_MOVED 오류를 처리할 수 있음을 나타냅니다. 이 비트가 설정되지 않은 경우에도 서버가 조회 시퀀스를 수행하는 것은 여전히 ​​유효합니다. 그러나 서버는 특정 클라이언트에 대해 참조를 회피함으로써 클라이언트가 참조에 올바르게 응답할 수 없다는 사실을 이용할 수 있습니다. 예를 들어, 반드시 그렇게 해야 하는 것은 아니지만 어느 정도 성능 저하를 감수하면서 특정 파일 시스템에 대한 프록시 역할을 할 수 있습니다. 서버가 잠재적으로 조회를 수행할 경우 eir\_flags에 EXCHGID4\_FLAG\_SUPP\_MOVED\_REFER를 설정해야 합니다.\(MUST\)

EXCHGID4\_FLAG\_SUPP\_MOVED\_MIGR이 설정되면 클라이언트는 파일 시스템 마이그레이션 시퀀스의 일부로 NFS4ERR\_MOVED 오류를 처리할 수 있음을 나타냅니다. 이 비트가 설정되지 않은 경우 실제로 이러한 일이 발생했을 때 서버가 파일 시스템이 이동되었음을 나타내는 것은 여전히 ​​유효합니다. 그러나 서버는 적극적으로 사용되는 파일 시스템의 마이그레이션을 피하기 위해 마이그레이션할 파일 시스템을 예약할 때 클라이언트가 마이그레이션에 올바르게 응답할 수 없다는 사실을 이용할 수 있습니다. 또한 반드시 그렇게 해야 하는 것은 아니지만 특정 클라이언트에 대해 마이그레이션된 파일 시스템에 대한 프록시 역할을 하여 처리할 수 없는 클라이언트로부터 실제 마이그레이션을 숨길 수도 있습니다. 하지만 그렇게 해야 할 의무는 없습니다. 서버가 잠재적으로 마이그레이션을 수행할 경우 eir\_flags에 EXCHGID4\_FLAG\_SUPP\_MOVED\_MIGR을 설정해야 합니다.\(MUST\)

EXCHGID4\_FLAG\_BIND\_PRINC\_STATEID가 설정되면 클라이언트는 서버가 stateid를 주체에 바인딩하기를 원함을 나타냅니다. 이는 주체가 stateid를 생성할 때 해당 주체가 stateid를 사용해야 함을 의미합니다. 서버가 바인딩을 수행하면 EXCHGID4\_FLAG\_BIND\_PRINC\_STATEID를 반환합니다. 클라이언트가 요청하지 않더라도 서버는 EXCHGID4\_FLAG\_BIND\_PRINC\_STATEID를 반환할 수 있습니다. 클라이언트 ID 업데이트로 인해 EXCHGID4\_FLAG\_BIND\_PRINC\_STATEID의 클라이언트 ID 속성 값이 변경되면 해당 효과는 새 stateid에만 적용됩니다. 주 바인딩에 대한 stateid를 사용하여 생성된 기존 stateid\(및 동일한 "기타" 필드가 있는 모든 stateid\)는 계속해서 바인딩됩니다. 실행되지 않는 주체에 대한 stateid를 사용하여 생성된 기존 stateid\(및 동일한 "기타" 필드가 있는 모든 stateid\)는 계속해서 실행되지 않는 구속력을 갖습니다.\(MAY\)

EXCHGID4\_FLAG\_USE\_NON\_PNFS, EXCHGID4\_FLAG\_USE\_PNFS\_MDS 및 EXCHGID4\_FLAG\_USE\_PNFS\_DS 비트는 섹션 13.1에 설명되어 있으며 pNFS 환경에서 클라이언트 ID가 사용되는 역할을 전달합니다. 서버는 해당 섹션에 지정된 대로 eir\_flags에서 이러한 비트\(역할\)의 허용 가능한 조합 중 하나를 설정해야 합니다. 동일한 클라이언트 소유자/서버 소유자 쌍이 여러 역할을 가질 수 있습니다. 여러 역할이 동일한 클라이언트 ID 또는 다른 클라이언트 ID와 연결될 수 있습니다. 따라서 클라이언트가 동일한 클라이언트 소유자의 EXCHANGE\_ID를 동일한 서버 소유자에게 여러 번 전송하지만 매번 다른 pNFS 역할을 지정하는 경우 서버는 다른 클라이언트 ID를 반환할 수 있습니다. 서로 다른 pNFS 역할이 서로 다른 클라이언트 ID를 가질 수 있다는 점을 고려하면 클라이언트는 각 역할/클라이언트 ID에 대해 서로 다른 속성을 요청할 수 있습니다.\(MUST\)

eia\_state\_protect 필드의 spa\_how 필드는 클라이언트가 무단 변경으로부터 클라이언트, 잠금 및 세션 상태를 보호하려는 방법을 지정합니다\(섹션 2.10.8.3\).

\* SP4\_NONE. 클라이언트는 NFSv4.1 서버에 상태 보호를 적용하도록 요청하지 않습니다. NFSv4.1 서버는 반환된 클라이언트 ID에 대해 상태 보호를 시행해서는 안 됩니다.\(MUST NOT\)

\* SP4\_MACH\_CRED. spa\_how가 SP4\_MACH\_CRED인 경우 클라이언트는 RPCSEC\_GSS를 보안 특성으로 사용하고 RPC\_GSS\_SVC\_INTEGRITY 또는 RPC\_GSS\_SVC\_PRIVACY 서비스를 사용하여 EXCHANGE\_ID 작업을 보내야 합니다. SP4\_MACH\_CRED가 지정되면 클라이언트는 RPCSEC\_GSS 기반 시스템 자격 증명을 사용하여 상태를 보호하려고 합니다. 서버는 EXCHANGE\_ID 작업이 전송된 주체와 사용된 GSS 메커니즘을 기록해야 합니다. 이러한 메모는 집합적으로 머신 자격 증명을 구성합니다.\(MUST, MUST\)

- 클라이언트 ID가 확인된 후 클라이언트 ID와 연결된 임대가 만료되지 않는 한 첫 번째 EXCHANGE\_ID와 동일한 eia\_clientowner.co\_owner를 사용하는 후속 EXCHANGE\_ID 작업도 첫 번째 EXCHANGE\_ID와 동일한 머신 자격 증명을 사용해야 합니다. 서버는 첫 번째 EXCHANGE\_ID에서 반환된 것과 동일한 클라이언트 ID를 후속 EXCHANGE\_ID에 반환합니다.\(MUST\)

\* SP4\_SSV. spa\_how가 SP4\_SSV인 경우 클라이언트는 RPCSEC\_GSS를 보안 특성으로 사용하고 RPC\_GSS\_SVC\_INTEGRITY 또는 RPC\_GSS\_SVC\_PRIVACY 서비스를 사용하여 EXCHANGE\_ID 작업을 보내야 합니다. SP4\_SSV가 지정되면 클라이언트는 SSV를 사용하여 상태를 보호하려고 합니다. 서버는 요청에 사용된 자격 증명을 eia\_clientowner.co\_owner에 대한 컴퓨터 자격 증명\(위에 정의된 대로\)으로 기록합니다. 클라이언트 ID를 확인하는 CREATE\_SESSION 작업은 동일한 컴퓨터 자격 증명을 사용해야 합니다.\(MUST, MUST\)

클라이언트가 SP4\_MACH\_CRED 또는 SP4\_SSV를 지정하면 두 가지 작업 목록도 제공됩니다\(각각 비트맵으로 표시됨\). 첫 번째 목록은 spo\_must\_enforce이며 클라이언트가 시스템 자격 증명\(SP4\_MACH\_CRED 보호가 지정된 경우\) 또는 SSV 기반 자격 증명\(SP4\_SSV의 경우\)을 사용하여 보내야 하는 작업\(EXCHANGE\_ID 결과에서 작업 목록을 확인하는 서버에 따라 다름\)으로 구성됩니다. 보호가 사용됩니다\). 클라이언트는 RPC\_GSS\_SVC\_INTEGRITY 또는 RPC\_GSS\_SVC\_PRIVACY 보안 서비스를 지정하는 RPCSEC\_GSS 자격 증명과 함께 작업을 보내야 합니다. 일반적으로 첫 번째 작업 목록에는 EXCHANGE\_ID, CREATE\_SESSION, DELEGPURGE, DESTROY\_SESSION, BIND\_CONN\_TO\_SESSION 및 DESTROY\_CLIENTID가 포함됩니다. 클라이언트는 파일 핸들이 필요한 모든 작업을 이 목록에 지정해서는 안 됩니다. 서버의 액세스 정책이 클라이언트의 선택과 충돌할 수 있으므로 클라이언트는 서버 네임스페이스의 하위 집합에 액세스할 수 없게 되기 때문입니다.\(MUST, MUST, SHOULD NOT\)

SP4\_SSV 보호가 지정되고 클라이언트가 CREATE\_SESSION을 SP4\_SSV로 보호해야 함을 나타내는 경우 확인된 클라이언트 ID 없이 SSV가 존재할 수 없기 때문에 첫 번째 CREATE\_SESSION은 대신 머신 자격 증명을 사용하여 전송되어야 하며 서버는 머신을 수락해야 합니다. 신임장.\(MUST\)

서버에 SP4\_MACH\_CRED 또는 SP4\_SSV 보호가 필요한 작업에는 spo\_must\_enforce라고도 하는 해당 결과가 있습니다. 일반적으로 서버의 결과는 클라이언트의 인수와 동일하지만 결과는 다를 수 있습니다. 클라이언트가 집합 { EXCHANGE\_ID, CREATE\_SESSION, DELEGPURGE, DESTROY\_SESSION, BIND\_CONN\_TO\_SESSION, DESTROY\_CLIENTID }에서 하나 이상의 작업을 요청하는 경우 결과 spo\_must\_enforce에는 클라이언트가 해당 집합에서 요청한 작업이 포함되어야 합니다.\(MAY, MUST\)

결과의 spo\_must\_enforce에 BIND\_CONN\_TO\_SESSION이 설정된 경우 연결 바인딩 적용이 활성화되고 클라이언트는 BIND\_CONN\_TO\_SESSION 호출 시 머신\(SP4\_MACH\_CRED 보호가 사용되는 경우\) 또는 SSV\(SP4\_SSV 보호가 사용되는 경우\) 자격 증명을 사용해야 합니다.\(MUST\)

두 번째 목록은 spo\_must\_allow이며 작업이 수행되는 개체가 컴퓨터 또는 SSV 자격 증명의 소유가 아닌 경우에도 클라이언트가 컴퓨터 자격 증명 또는 SSV 기반 자격 증명과 함께 전송하는 옵션을 가지기를 원하는 작업으로 구성됩니다.

spo\_must\_allow라고도 하는 해당 결과는 클라이언트가 SP4\_SSV 또는 SP4\_MACH\_CRED 자격 증명을 사용할 수 있도록 서버에서 허용하는 작업으로 구성됩니다. 일반적으로 서버의 결과는 클라이언트의 인수와 동일하지만 결과는 다를 수 있습니다.\(MAY\)

spo\_must\_allow의 목적은 클라이언트가 다음 난제를 해결할 수 있도록 하는 것입니다. 클라이언트 ID가 EXCHGID4\_FLAG\_BIND\_PRINC\_STATEID로 확인되고 일반 사용자의 RPCSEC\_GSS 자격 증명으로 OPEN을 호출한다고 가정합니다. 이제 사용자의 자격 증명이 만료되어 갱신할 수 없다고 가정합니다\(예: Kerberos 티켓 부여 티켓이 만료되고 사용자가 로그오프했으며 새 티켓 부여 티켓을 얻지 못할 것입니다\). 클라이언트는 사용자의 자격 증명 없이는 CLOSE를 보낼 수 없습니다. 즉, 클라이언트가 서버에 상태를 남겨두거나 모든 상태를 지우기 위해 새로운 검증자와 함께 EXCHANGE\_ID를 다시 보내야 합니다. 즉, 클라이언트가 CLOSE를 포함하지 않는 한 spo\_must\_allow의 작업 목록에 있고 서버가 동의합니다.

SP4\_SSV 보호 매개변수에는 다음도 포함됩니다.

ssp\_hash\_algs:

- 내부 SSV GSS 메커니즘과 SET\_SSV 작업에 필요한 다이제스트를 계산하기 위해 클라이언트가 지원하는 알고리즘 세트입니다. 각 알고리즘은 OID\(객체 식별자\)로 지정됩니다. 서버에 필요한 알고리즘은 id-sha1, id-sha224, id-sha256, id-sha384 및 id-sha512\[25\]입니다.\(MUST\)

- id-sha1의 알려진 약점으로 인해 클라이언트는 id-sha1 이외의 ssp\_hash\_algs 내에서 최소한 하나의 알고리즘을 지정하는 것이 좋습니다.\(SHOULD\)

- 서버가 세트 중에서 선택하는 알고리즘은 spr\_ssv\_prot\_info의 필드인 spi\_hash\_alg에 표시됩니다. spi\_hash\_alg 필드는 ssp\_hash\_algs 배열에 대한 인덱스입니다. id-sha1의 알려진 약점으로 인해 ssp\_hash\_algs에 지원되는 다른 알고리즘이 포함되어 있는 한 서버에서 이를 선택하지 않는 것이 좋습니다.\(SHOULD\)

- 서버가 제공된 알고리즘을 지원하지 않는 경우 NFS4ERR\_HASH\_ALG\_UNSUPP를 반환합니다. ssp\_hash\_algs가 비어 있으면 서버는 NFS4ERR\_INVAL을 반환해야 합니다.\(MUST\)

ssp\_encr\_algs:

- 내부 SSV GSS 메커니즘에 대한 개인 정보 보호 제공을 목적으로 클라이언트가 지원하는 알고리즘 집합입니다. 각 알고리즘은 OID로 지정됩니다. 서버의 필수 알고리즘은 id-aes256-CBC입니다. 권장되는 알고리즘은 id-aes192-CBC 및 id-aes128-CBC\[26\]입니다. 선택한 알고리즘은 ssp\_encr\_algs의 인덱스인 spi\_encr\_alg에 반환됩니다. 서버가 제공된 알고리즘을 지원하지 않는 경우 NFS4ERR\_ENCR\_ALG\_UNSUPP를 반환합니다. ssp\_encr\_algs가 비어 있으면 서버는 NFS4ERR\_INVAL을 반환해야 합니다. 키 길이와 해시 길이 사이의 관계에 대해 앞서 언급한 요구 사항 및 권장 사항으로 인해 RECOMMENDED 및 REQUIRED 암호화 알고리즘과 해시 알고리즘의 일부 조합을 사용해서는 안 되거나 사용해서는 안 됩니다. 표 21에는 불법적인 조합과 권장되지 않는 조합이 요약되어 있습니다.\(MUST, SHOULD, MUST, MUST NOT\)

ssp\_window:

- 클라이언트가 서버에서 유지 관리하기를 원하는 SSV 버전 수입니다. 즉, SET\_SSV에 대한 호출이 성공할 때마다 SSV의 새 버전이 생성됩니다. ssp\_window가 0이면 서버는 NFS4ERR\_INVAL을 반환해야 합니다. 서버는 ssp\_window를 초과해서는 안 되며 적어도 하나 이상이어야 하는 spi\_window로 응답합니다. 기간 외부에 있는 SSV 버전을 사용하는 백채널 또는 포어 채널에 대한 모든 요청은 ONC RPC 인증 오류로 인해 실패하며 요청자는 동일한 슬롯 ID 및 시퀀스 ID를 사용하여 요청을 재시도해야 합니다.\(MUST, MUST NOT\)

ssp\_num\_gss\_handles:

- 이는 서버가 GSS SSV 메커니즘을 기반으로 생성해야 하는 RPCSEC\_GSS 핸들 수입니다\(섹션 2.10.9 참조\). 클라이언트 ID에 대한 총 RPCSEC\_GSS 핸들 수가 아닙니다. 실제로 EXCHANGE\_ID에 대한 후속 호출은 RPCSEC\_GSS 핸들을 추가합니다. 서버는 spi\_handles의 핸들 목록으로 응답합니다. 클라이언트가 최소한 하나의 핸들을 요청했지만 서버가 핸들을 생성할 수 없는 경우 서버는 오류를 반환해야 합니다. spi\_handles의 핸들은 클라이언트 ID가 확인될 때까지 사용할 수 없습니다. EXCHANGE\_ID가 EXCHGID4\_FLAG\_CONFIRMED\_R을 반환하는 경우 즉시 확인되거나 CREATE\_SESSION에서 확인이 성공한 경우 가능합니다.\(MUST\)

- 클라이언트 ID는 동일한 eir\_server\_owner.so\_major\_id를 공유하는 서버에 연결된 모든 연결에 걸쳐 있을 수 있지만 spi\_handles에 반환된 RPCSEC\_GSS 핸들은 동일한 eir\_server\_owner.so\_major\_id 및 eir\_server\_owner를 반환하는 서버에 연결된 연결에서만 사용할 수 있습니다. 각 연결의 so\_minor\_id입니다. 클라이언트가 ssp\_num\_gss\_handles를 0으로 설정하는 것은 허용됩니다. 클라이언트는 또 다른 EXCHANGE\_ID 호출을 통해 더 많은 핸들을 생성할 수 있습니다.

- 각 SSV RPCSEC\_GSS 핸들은 공통 SSV GSS 컨텍스트를 공유하므로 섹션 2.10.10에서 논의된 이 상황과 관련된 보안 고려 사항이 있습니다.

- spi\_handle에 있는 각 RPCSEC\_GSS 핸들의 seq\_window\(RFC 2203 \[4\]의 섹션 5.2.3.1 참조\)는 EXCHANGE\_ID 작업이 전송된 RPC 요청의 자격 증명에 사용되는 RPCSEC\_GSS 핸들의 seq\_window와 동일해야 합니다. 부분.\(MUST\)

```text
   +======================+===========================+===============+
   | Encryption Algorithm | MUST NOT be combined with | SHOULD NOT be |
   |                      |                           | combined with |
   +======================+===========================+===============+
   | id-aes128-CBC        |                           | id-sha384,    |
   |                      |                           | id-sha512     |
   +----------------------+---------------------------+---------------+
   | id-aes192-CBC        | id-sha1                   | id-sha512     |
   +----------------------+---------------------------+---------------+
   | id-aes256-CBC        | id-sha1, id-sha224        |               |
   +----------------------+---------------------------+---------------+

                                 Table 21
```

인수에는 eia\_client\_impl\_id라는 최대 하나의 요소 길이 배열이 포함됩니다. eia\_client\_impl\_id가 있는 경우 클라이언트 구현을 식별하는 정보가 포함됩니다. 마찬가지로 결과에는 서버 구현을 식별하는 eir\_server\_impl\_id라는 최대 하나의 요소 길이 배열이 포함됩니다. 서버는 길이가 0인 eia\_client\_impl\_id 배열을 허용해야 하며, 클라이언트는 길이가 0인 eir\_server\_impl\_id 배열을 허용해야 합니다\(MUST\).\(MUST\)

구현 식별자는 상호 운용성 문제, 성능 작업 부하 동작 또는 일반 사용 통계를 식별하기 위해 이 정보를 추출하는 진단 소프트웨어에 사용할 수 있습니다. 이 정보에 액세스하려는 의도는 계획이나 일반 진단만을 위한 것이기 때문에 클라이언트와 서버는 구현이 피어와 상호 작용하는 방식에 영향을 미치는 방식으로 이 구현 ID 정보를 해석해서는 안 됩니다. 클라이언트와 서버는 구현 식별자를 기반으로 피어가 특정 허용 동작을 나타내는 것에 의존할 수 없지만 프로토콜 사양의 다른 부분에 지정된 대로 상호 운용되어야 합니다.\(MUST NOT\)

일부 구현이 프로토콜 사양을 위반하고 ID 정보를 해석할 수 있기 때문에 구현은 NFSv4 클라이언트와 서버가 지정된 값으로 전송된 nfs\_impl\_id 구조의 내용을 설정하도록 구성할 수 있는 기능을 제공해야 합니다.\(MUST\)

---
#### **18.35.4.  IMPLEMENTATION**

서버의 클라이언트 레코드는 5-튜플입니다.

```text
   1.  co_ownerid:
```

- EXCHANGE\_ID4args 구조의 eia\_clientowner 구조에서 가져온 클라이언트 식별자 문자열입니다.

```text
   2.  co_verifier:
```

- EXCHANGE\_ID4args 구조의 eia\_clientowner 구조에서 구현\(클라이언트 다시 시작이 새 구현을 나타냄\)을 나타내는 데 사용되는 클라이언트별 값입니다.

```text
   3.  principal:
```

- 클라이언트 레코드가 설정될 때 RPC 헤더의 자격 증명 및/또는 검증자에 정의된 주체입니다.

```text
   4.  client ID:
```

- 서버에 의해 생성되고 EXCHANGE\_ID4resok 구조의 eir\_clientid 필드를 통해 반환되는 단축 클라이언트 식별자입니다.

```text
   5.  confirmed:
```

- 클라이언트 기록이 확인되었는지 여부를 나타내는 서버의 비공개 필드입니다. CREATE\_SESSION 작업이 성공하면 클라이언트 레코드가 확인됩니다. 그렇지 않으면 확인되지 않습니다. 확인되지 않은 레코드는 EXCHANGE\_ID 호출로 설정됩니다. 임대 기간 내에 확인되지 않은 확인되지 않은 기록은 모두 삭제해야 합니다.\(SHOULD\)

다음 식별자는 레코드의 필드에 대한 특수 값을 나타냅니다.

ownerid\_arg:

- 현재 요청의 EXCHANGE\_ID4args 구조에 대한 eia\_clientowner.co\_ownerid 하위 필드의 값입니다.

verifier\_arg:

- 현재 요청의 EXCHANGE\_ID4args 구조에 대한 eia\_clientowner.co\_verifier 하위 필드의 값입니다.

old\_verifier\_arg:

- 이전 요청에서 수신된 클라이언트 레코드의 eia\_clientowner.co\_verifier 필드 값 이는 verifier\_arg와 다릅니다.

Principal\_arg:

- 현재 요청에 대한 RPCSEC\_GSS 주체의 값입니다.

old\_principal\_arg:

- RPC 헤더의 자격 증명 또는 이전 요청의 검증자에 의해 정의된 클라이언트 레코드의 주체 값입니다. 이는 Principal\_arg와 다릅니다.

클라이언트ID\_ret:

- 서버가 현재 요청에 대해 EXCHANGE\_ID4resok 구조로 반환할 eir\_clientid 필드의 값입니다.

old\_clientid\_ret:

- 이전 요청에 대해 서버가 EXCHANGE\_ID4resok 구조에서 반환한 eir\_clientid 필드의 값입니다. 이는 clientid\_ret과 다릅니다.

확인됨:

- 클라이언트 ID가 확인되었습니다.

확인되지 않은:

- 클라이언트 ID가 확인되지 않았습니다.

EXCHANGE\_ID는 비멱등성 작업이므로 클라이언트 재시작, 네트워크 파티션, 라우터 오작동 등의 결과로 재시도가 발생할 가능성을 고려해야 합니다. 재시도는 EXCHANGE\_ID4args의 eia\_clientowner 필드 값과 방법으로 식별됩니다. 이를 처리하는 방법은 아래 시나리오에 설명되어 있습니다.

시나리오는 주어진 co\_ownerid에 대해 서버가 갖고 있는 클라이언트 레코드 측면에서 설명됩니다. SP4\_SSV 상태 보호 및 EXCHANGE\_ID를 spo\_must\_allow의 작업 중 하나로 지정하여 클라이언트 ID가 생성된 경우 서버는 클라이언트 ID를 생성한 주체 외에 SSV 주체를 사용하여 EXCHANGE\_ID에 권한을 부여해야 합니다.\(MUST\)

```text
   1.  New Owner ID
```

서버에 클라이언트 기록이 없는 경우

- eia\_clientowner.co\_ownerid 일치 ownerid\_arg 및 EXCHGID4\_FLAG\_UPD\_CONFIRMED\_REC\_A가 EXCHANGE\_ID에 설정되지 않은 경우 새로운 단축 클라이언트 ID\(clientid\_ret이라고 함\)가 생성되고 다음과 같은 확인되지 않은 레코드가 서버 상태에 추가됩니다.

```text
       { ownerid_arg, verifier_arg, principal_arg, clientid_ret,
       unconfirmed }
```

- 이후 서버는 clientid\_ret을 반환합니다.

2. 기존 클라이언트 ID 업데이트 불가

- 서버에 다음과 같은 확인된 기록이 있고 요청에 EXCHGID4\_FLAG\_UPD\_CONFIRMED\_REC\_A가 설정되어 있지 않은 경우 해당 요청은 라우터 결함이나 연결 끊김으로 인해 재시도된 요청의 결과이거나 클라이언트가 트렁킹을 수행할 수 있는지 확인하려는 중입니다. .

```text
       { ownerid_arg, verifier_arg, principal_arg, clientid_ret,
       confirmed }
```

- 기록이 확인되었으므로 클라이언트는 초기 EXCHANGE\_ID 요청으로부터 서버의 응답을 받아야 합니다. 서버에 확인된 기록이 있고 EXCHGID4\_FLAG\_UPD\_CONFIRMED\_REC\_A가 설정되지 않았기 때문에 eir\_server\_owner.so\_minor\_id를 제외하고 서버는 클라이언트 ID의 속성이 마지막으로 업데이트되었을 때와 동일한 결과를 반환합니다. 클라이언트 ID가 생성되었습니다\). 확인된 기록은 변경되지 않습니다.

```text
   3.  Client Collision
```

- EXCHGID4\_FLAG\_UPD\_CONFIRMED\_REC\_A가 설정되지 않았고 서버에 다음과 같은 확인된 레코드가 있는 경우 이 요청은 서로 다른 두 클라이언트에 대한 EXCHANGE\_ID4args의 eia\_clientowner.co\_ownerid 하위 필드 값 간의 충돌로 인한 결과일 가능성이 높습니다.

```text
       { ownerid_arg, *, old_principal_arg, old_clientid_ret, confirmed
       }
```

- 현재 old\_clientid\_ret과 연관된 상태가 없거나 상태는 있지만 임대가 만료된 경우 이 사례는 18.35.4절 7항 1항의 New Owner ID 사례와 사실상 동일합니다. 확인된 레코드는 다음과 같습니다. 삭제되면 old\_clientid\_ret 및 해당 잠금 상태가 삭제되고 새로운 단축 클라이언트 ID가 생성되며 다음과 같은 확인되지 않은 레코드가 서버 상태에 추가됩니다.

```text
       { ownerid_arg, verifier_arg, principal_arg, clientid_ret,
       unconfirmed }
```

- 이후 서버는 clientid\_ret을 반환합니다.

- old\_clientid\_ret에 상태가 만료되지 않은 임대가 있는 경우 old\_clientid\_ret의 상태는 변경되거나 삭제되지 않습니다. 서버는 NFS4ERR\_CLID\_INUSE를 반환하여 클라이언트가 EXCHANGE\_ID4args의 eia\_clientowner.co\_ownerid 하위 필드에 대해 다른 값을 사용하여 재시도해야 함을 나타냅니다. 클라이언트 레코드는 변경되지 않습니다.

4. 확인되지 않은 기록의 대체

- EXCHGID4\_FLAG\_UPD\_CONFIRMED\_REC\_A 플래그가 설정되지 않고 서버에 다음과 같은 확인되지 않은 레코드가 있는 경우 클라이언트는 확인되지 않은 클라이언트 ID에서 EXCHANGE\_ID를 다시 시도합니다. 아마도 재시도로 인해 클라이언트 ID 확인 전에\(즉, CREATE\_SESSION이 시작되기 전에\) 클라이언트가 다시 시작됩니다. 호출됨\) 또는 다른 이유가 있습니다.

```text
       { ownerid_arg, *, *, old_clientid_ret, unconfirmed }
```

- old\_clientid\_ret의 속성이 현재 EXCHANGE\_ID에 지정된 속성과 다를 수 있습니다. 속성이 업데이트되는지 여부에 관계없이 모호성을 없애기 위해 서버는 확인되지 않은 레코드를 삭제하고 새 클라이언트 ID\(clientid\_ret\)를 생성하며 다음과 같은 확인되지 않은 레코드를 설정합니다.

```text
       { ownerid_arg, verifier_arg, principal_arg, clientid_ret,
       unconfirmed }

   5.  Client Restart
```

- EXCHGID4\_FLAG\_UPD\_CONFIRMED\_REC\_A가 설정되지 않았고 서버에 다음과 같이 확인된 클라이언트 레코드가 있는 경우 이 요청은 이전에 다시 시작된 확인된 클라이언트에서 발생한 것일 가능성이 높습니다.

```text
       { ownerid_arg, old_verifier_arg, principal_arg, old_clientid_ret,
       confirmed }
```

- 동일한 클라이언트의 이전 구현은 더 이상 요청을 하지 않으므로 새 클라이언트 ID가 CREATE\_SESSION에 의해 ​​확인되면 바이트 범위 잠금 및 공유 예약은 새 구현이 임대 시간을 기다리도록 강제하는 대신 즉시 해제되어야 합니다. 이전 화신이 만료됩니다. 또한 클라이언트가 다시 시작하는 동안 해당 정보를 유지했다면 이 요청이 전송되지 않았을 것이므로 세션 상태를 제거해야 합니다. 서버가 CLAIM\_DELEGATE\_PREV 또는 CLAIM\_DELEG\_PREV\_FH 클레임 유형을 모두 지원하지 않는 경우 연결된 위임도 제거되어야 합니다. 그렇지 않으면 위임이 유지되고 섹션 10.2.1에 따라 복구가 진행됩니다.

- 처리 후 clientid\_ret이 클라이언트에 반환되고 다음 클라이언트 레코드가 추가됩니다.

```text
       { ownerid_arg, verifier_arg, principal_arg, clientid_ret,
       unconfirmed }
```

- 앞서 설명한 확인된 기록이 계속 존재하므로, 동일한 ownerid\_arg가 확인된 상태와 미확인된 상태로 동시에 존재하게 됩니다. 서버가 적용 가능한 CREATE\_SESSION 또는 EXCHANGE\_ID를 수신하면 상태 수는 하나로 축소될 수 있습니다.

\* 서버가 이후에 성공적인 수신을 받은 경우

- clientid\_ret을 확인하는 CREATE\_SESSION, 그러면 서버는 확인된 레코드를 원자적으로 파기하고 섹션 18.36.3에 설명된 대로 확인되지 않은 레코드를 확인합니다.

- \* 서버가 이후에 클라이언트 소유자가 ownerid\_arg인 EXCHANGE\_ID를 수신하는 경우 한 가지 전략은 확인되지 않은 레코드를 삭제하고 섹션 18.35.4 전체에 설명된 대로 EXCHANGE\_ID를 처리하는 것입니다.

```text
   6.  Update
```

- EXCHGID4\_FLAG\_UPD\_CONFIRMED\_REC\_A가 설정되어 있고 서버에 다음과 같은 확인된 기록이 있는 경우 이 요청은 업데이트 시도입니다.

```text
       { ownerid_arg, verifier_arg, principal_arg, clientid_ret,
       confirmed }
```

- 기록이 확인되었으므로 클라이언트는 초기 EXCHANGE\_ID 요청으로부터 서버의 응답을 받아야 합니다. 서버는 업데이트를 허용하고 클라이언트 기록은 그대로 유지됩니다.

7. 업데이트가 되었지만 확인된 기록이 없습니다.

- EXCHGID4\_FLAG\_UPD\_CONFIRMED\_REC\_A가 설정되고 서버에 ownerid\_arg에 해당하는 확인된 레코드가 없으면 서버는 NFS4ERR\_NOENT를 반환하고 확인되지 않은 레코드는 그대로 둡니다.

8. 업데이트했지만 잘못된 검증자

- EXCHGID4\_FLAG\_UPD\_CONFIRMED\_REC\_A가 설정되어 있고 서버에 다음과 같은 확인된 기록이 있는 경우 이 요청은 잘못된 업데이트 시도입니다. 아마도 이전 클라이언트 구현의 재시도 때문일 수 있습니다.

```text
       { ownerid_arg, old_verifier_arg, *, clientid_ret, confirmed }
```

- 서버는 NFS4ERR\_NOT\_SAME을 반환하고 클라이언트 기록은 그대로 둡니다.

9. 업데이트했지만 주체가 잘못됨

- EXCHGID4\_FLAG\_UPD\_CONFIRMED\_REC\_A가 설정되고 서버에 다음과 같은 확인된 기록이 있는 경우 이 요청은 승인되지 않은 주체에 의한 불법적인 업데이트 시도입니다.

```text
       { ownerid_arg, verifier_arg, old_principal_arg, clientid_ret,
       confirmed }
```

- 서버는 NFS4ERR\_PERM을 반환하고 클라이언트 기록은 그대로 둡니다.

18.36. 작업 43: CREATE\_SESSION - 새 세션 생성 및 클라이언트 ID 확인

---
#### **18.36.1.  ARGUMENT**

```text
   struct channel_attrs4 {
           count4                  ca_headerpadsize;
           count4                  ca_maxrequestsize;
           count4                  ca_maxresponsesize;
           count4                  ca_maxresponsesize_cached;
           count4                  ca_maxoperations;
           count4                  ca_maxrequests;
           uint32_t                ca_rdma_ird<1>;
   };

   const CREATE_SESSION4_FLAG_PERSIST              = 0x00000001;
   const CREATE_SESSION4_FLAG_CONN_BACK_CHAN       = 0x00000002;
   const CREATE_SESSION4_FLAG_CONN_RDMA            = 0x00000004;

   struct CREATE_SESSION4args {
           clientid4               csa_clientid;
           sequenceid4             csa_sequence;

           uint32_t                csa_flags;

           channel_attrs4          csa_fore_chan_attrs;
           channel_attrs4          csa_back_chan_attrs;

           uint32_t                csa_cb_program;
           callback_sec_parms4     csa_sec_parms<>;
   };
```

---
#### **18.36.2.  RESULT**

```text
   struct CREATE_SESSION4resok {
           sessionid4              csr_sessionid;
           sequenceid4             csr_sequence;

           uint32_t                csr_flags;

           channel_attrs4          csr_fore_chan_attrs;
           channel_attrs4          csr_back_chan_attrs;
   };

   union CREATE_SESSION4res switch (nfsstat4 csr_status) {
   case NFS4_OK:
           CREATE_SESSION4resok    csr_resok4;
   default:
           void;
   };
```

---
#### **18.36.3.  DESCRIPTION**

이 작업은 클라이언트가 서버에 새 세션 개체를 만드는 데 사용됩니다.

CREATE\_SESSION은 동일한 COMPOUND 프로시저에서 선행 SEQUENCE 작업을 사용하거나 사용하지 않고 보낼 수 있습니다. CREATE\_SESSION이 이전 SEQUENCE 작업과 함께 전송되는 경우 CREATE\_SESSION에 의해 ​​생성된 모든 세션은 SEQUENCE 작업에 지정된 세션과 직접적인 관계가 없습니다. 단 두 세션은 동일한 클라이언트 ID와 연결될 수 있습니다. CREATE\_SESSION이 선행 SEQUENCE 없이 전송되면 이는 COMPOUND 프로시저 요청의 유일한 작업이어야 합니다. 그렇지 않은 경우 서버는 NFS4ERR\_NOT\_ONLY\_OP를 반환해야 합니다.\(MUST, MUST\)

세션을 생성하는 것 외에도 CREATE\_SESSION은 다음과 같은 효과를 갖습니다.

\* 새 클라이언트 ID로 생성된 첫 번째 세션은 서버에서 해당 클라이언트 상태 생성을 확인하는 역할을 합니다. 서버는 새 세션에 대한 매개변수 값을 반환합니다.

\* 전송된 CREATE\_SESSION 연결은 세션의 전면 채널과 연결됩니다.

CREATE\_SESSION의 인수와 결과는 다음과 같습니다.

csa\_clientid: 새 세션이 연결될 클라이언트 ID입니다. 해당 결과는 새 세션의 세션 ID인 csr\_sessionid입니다.

csa\_sequence: 각 클라이언트 ID는 클라이언트별 ID 시퀀스 번호를 통해 CREATE\_SESSION을 직렬화합니다\(섹션 18.36.4 참조\). 해당 결과는 csr\_sequence이며 이는 csa\_sequence와 동일해야 합니다.\(MUST\)

다음 세 인수에서 클라이언트는 세션의 속성이 될 값을 제공합니다. 달리 명시된 경우를 제외하고 서버가 값을 승인하는 것이 좋습니다. 허용되지 않는 경우 서버는 다른 값을 사용할 수 있습니다. 그럼에도 불구하고 서버는 세션이 사용할 값\(클라이언트가 제공한 값 또는 서버가 주장하는 값\)을 클라이언트에 반환해야 합니다.\(SHOULD, MAY, MUST\)

csa\_flags: csa\_flags 필드에는 다음 플래그 비트 목록이 포함됩니다.

CREATE\_SESSION4\_FLAG\_PERSIST:

- CREATE\_SESSION4\_FLAG\_PERSIST가 설정된 경우 클라이언트는 서버가 지속적인 응답 캐시를 제공하기를 원합니다. 멱등성 작업만 사용되는 세션\(예: 읽기 전용 세션\)의 경우 클라이언트는 CREATE\_SESSION4\_FLAG\_PERSIST를 설정해서는 안 됩니다. 서버가 지속적인 응답 캐시를 제공하지 않거나 제공할 수 없는 경우 서버는 csr\_flags 필드에 CREATE\_SESSION4\_FLAG\_PERSIST를 설정해서는 안 됩니다.\(SHOULD NOT, MUST NOT\)

- 서버가 pNFS 메타데이터 서버인 경우 섹션 12.5.2에 설명된 이유로 인해 레이아웃\_힌트\(섹션 5.12.4\) 속성을 지원하는 경우 CREATE\_SESSION4\_FLAG\_PERSIST를 지원해야 합니다.\(SHOULD\)

CREATE\_SESSION4\_FLAG\_CONN\_BACK\_CHAN:

- CREATE\_SESSION4\_FLAG\_CONN\_BACK\_CHAN이 csa\_flags에 설정된 경우 클라이언트는 CREATE\_SESSION 작업이 도착한 연결이 포어 채널 외에도 세션의 백채널과 연결되도록 요청합니다. 서버가 동의하면 결과 필드 csr\_flags에 CREATE\_SESSION4\_FLAG\_CONN\_BACK\_CHAN을 설정합니다. CREATE\_SESSION4\_FLAG\_CONN\_BACK\_CHAN이 csa\_flags에 설정되지 않은 경우 CREATE\_SESSION4\_FLAG\_CONN\_BACK\_CHAN을 csr\_flags에 설정하면 안 됩니다.\(MUST NOT\)

CREATE\_SESSION4\_FLAG\_CONN\_RDMA:

- CREATE\_SESSION4\_FLAG\_CONN\_RDMA가 csa\_flags에 설정되어 있고 CREATE\_SESSION 작업이 도착한 연결이 현재 비RDMA 모드에 있지만 RDMA 모드에서 작동할 수 있는 기능이 있는 경우 클라이언트는 서버가 RDMA 모드로 "단계화"하도록 요청하는 것입니다. 연결에. 서버가 동의하면 결과 필드 csr\_flags에 CREATE\_SESSION4\_FLAG\_CONN\_RDMA를 설정합니다. CREATE\_SESSION4\_FLAG\_CONN\_RDMA가 csa\_flags에 설정되지 않은 경우 CREATE\_SESSION4\_FLAG\_CONN\_RDMA는 csr\_flags에 설정되어서는 안 됩니다. 서버가 한 단계 더 나아가는 데 동의하면 서버와 클라이언트는 레코드 표시\(\[32\]\)가 아닌 RPC RDMA 프레이밍을 사용하여 연결의 모든 향후 트래픽을 교환해야 합니다.\(MUST NOT, MUST\)

csa\_fore\_chan\_attrs, csa\_back\_chan\_attrs: csa\_fore\_chan\_attrs 및 csa\_back\_chan\_attrs 필드는 각각 fore 채널\(클라이언트에서 발생한 요청을 서버로 전달\) 및 backchannel\(서버에서 발생한 콜백 요청을 클라이언트로 전달하는 채널\)의 속성에 적용됩니다. 결과는 csr\_fore\_chan\_attrs 및 csr\_back\_chan\_attrs라는 해당 구조에 있습니다. 결과는 각 채널에 대한 속성과 세션의 각 채널에 대한 모든 후속 사용에 대한 속성을 설정합니다. 각 구조에는 다음과 같은 필드가 있습니다.

ca\_headerpadsize:

- 쓰기 페이로드가 응답자의 일부 경계에 정렬되도록 요청자가 적용할 의향이 있는 최대 패딩 양입니다. 각 채널마다 서버

- \*는 선호하는 값으로 ca\_headerpadsize에 응답하거나 패딩을 사용하지 않는 경우 0으로 응답합니다.

- \* 이 값을 줄일 수 있지만 늘리면 안 됩니다.\(MUST NOT\)

ca\_max요청 크기:

- 전송될 COMPOUND 또는 CB\_COMPOUND 요청의 최대 크기입니다. 이 크기는 RPC 헤더\(보안 유형 자격 증명 및 검증자 포함\)를 포함하여 요청의 XDR 인코딩 크기를 나타내지만 RPC 전송 프레이밍 헤더는 제외됩니다. 비RDMA TCP/IP 연결을 통해 들어오는 요청과 그 앞에 단일 레코드 표시 헤더가 있다고 상상해 보십시오. 헤더에 인코딩된 최대 허용 개수는 ca\_maxrequestsize입니다. 요청자가 ca\_maxrequestsize를 초과하는 요청을 보내는 경우 섹션 2.10.6.4의 설명에 따라 NFS4ERR\_REQ\_TOO\_BIG 오류가 반환됩니다. 각 채널에 대해 서버는 이 값을 줄일 수 있지만 늘리면 안 됩니다.\(MUST NOT\)

ca\_max응답 크기:

- RPC 헤더를 포함하여 요청자가 응답자로부터 수락할 COMPOUND 또는 CB\_COMPOUND 응답의 최대 크기입니다\(ca\_maxrequestsize 정의 참조\). 각 채널에 대해 서버는 이 값을 줄일 수 있지만 늘릴 수는 없습니다. 그러나 클라이언트가 채널의 응답자가 응답을 보낼 수 없도록 ca\_maxresponsesize 값을 선택하는 경우 서버는 CREATE\_SESSION 응답에서 NFS4ERR\_TOOSMALL을 반환해야 합니다. 세션이 생성된 후 요청자가 응답 크기가 이 값을 초과하는 요청을 보내는 경우 응답자는 섹션 2.10.6.4의 설명에 따라 NFS4ERR\_REP\_TOO\_BIG를 반환합니다.\(MUST NOT, SHOULD\)

ca\_maxresponsesize\_cached:

- ca\_maxresponsesize와 비슷하지만 응답 캐시에 저장될 응답의 최대 크기입니다\(섹션 2.10.6.1\). 각 채널에 대해 서버는 이 값을 줄일 수 있지만 늘릴 수는 없습니다. CREATE\_SESSION에 대한 응답에서 채널의 ca\_maxresponsesize\_cached 값이 동일한 채널의 ca\_maxresponsesize 값보다 작은 경우 이는 응답자를 캐시로 보내는 응답을 선택해야 함을 요청자에게 표시합니다. ; 예를 들어, 멱등성이 아닌 작업\(예: READ 작업이 포함된 COMPOUND 요청\)의 대규모 응답은 캐시되어서는 안 됩니다. 요청자는 SEQUENCE\(sa\_cachethis 필드, 섹션 18.46 참조\) 또는 CB\_SEQUENCE\(csa\_cachethis 필드, 섹션 20.9 참조\) 작업에 대한 인수를 통해 캐시에 응답할 응답을 결정합니다. 세션이 생성된 후 요청자가 응답 크기가 ca\_maxresponsesize\_cached를 초과하는 요청을 보내는 경우 응답자는 섹션 2.10.6.4의 설명에 따라 NFS4ERR\_REP\_TOO\_BIG\_TO\_CACHE를 반환합니다.\(MUST NOT\)

ca\_max작업:

- 회신자가 COMPOUND 또는 CB\_COMPOUND에서 허용할 최대 작업 수입니다. 백채널의 경우 서버는 클라이언트가 제공하는 값을 변경해서는 안 됩니다. 전방 채널의 경우 서버는 요청된 값을 변경할 수 있습니다. 세션이 생성된 후 요청자가 ca\_maxOperations보다 더 많은 작업이 포함된 COMPOUND 또는 CB\_COMPOUND를 보내는 경우 응답자는 NFS4ERR\_TOO\_MANY\_OPS를 반환해야 합니다.\(MUST NOT, MAY, MUST\)

ca\_max요청:

- 요청자가 세션에서 보낼 동시 COMPOUND 또는 CB\_COMPOUND 요청의 최대 수입니다. 후속 요청에는 요청자가 0부터 ca\_maxrequests - 1까지의 범위 내에서 슬롯 식별자를 각각 할당합니다. 백채널의 경우 서버는 클라이언트가 제공하는 값을 변경해서는 안 됩니다. 전방 채널의 경우 서버는 요청된 값을 변경할 수 있습니다.\(MUST NOT, MAY\)

ca\_rdma\_ird:

- 이 배열에는 최대 1개의 요소가 있습니다. 이 배열에 하나의 요소가 있는 경우 해당 요소에는 인바운드 RDMA IRD\(읽기 대기열 깊이\)가 포함됩니다. 각 채널에 대해 서버는 이 값을 줄일 수 있지만 늘릴 수는 없습니다.\(MUST NOT\)

csa\_cb\_program 이것은 백채널을 통해 클라이언트로 전송되는 모든 콜백에서 서버가 반드시 사용해야 하는 ONC RPC 프로그램 번호입니다. 서버는 클라이언트에 전송되는 콜백에 csa\_cb\_program과 동일한 ONC RPC 프로그램 번호와 4와 동일한 ONC RPC 버전 번호를 지정해야 합니다. CB\_COMPOUND가 클라이언트로 전송되면 서버는 마이너 버전 번호 1을 사용해야 합니다. 해당 결과가 없습니다.\(MUST, MUST, MUST\)

csa\_sec\_parms csa\_sec\_parms 필드는 서버가 세션의 백채널에서 사용할 수 있는 허용 가능한 보안 자격 증명의 배열입니다. AUTH\_NONE, AUTH\_SYS 및 RPCSEC\_GSS의 세 가지 보안 유형이 지원됩니다. 자격 증명에 AUTH\_NONE이 지정된 경우 이는 클라이언트가 세션의 모든 콜백에서 AUTH\_NONE을 사용하도록 서버에 권한을 부여한다는 의미입니다. AUTH\_SYS가 지정되면 클라이언트는 지정된 cbsp\_sys\_cred 자격 증명을 사용하여 모든 콜백에서 AUTH\_SYS를 사용하도록 서버에 권한을 부여합니다. RPCSEC\_GSS가 지정되면 서버는 클라이언트에 대한 콜백의 RPC 헤더 자격 증명에서 RPCSEC\_GSS 컨텍스트로 cbsp\_gss\_parms에 지정된 RPCSEC\_GSS 컨텍스트를 사용할 수 있습니다. 해당하는 결과가 없습니다.

- 백채널에 대한 RPCSEC\_GSS 컨텍스트는 gsshandle4\_t 데이터 유형의 값 쌍을 통해 지정됩니다. gsshandle4\_t 데이터 유형은 RPCSEC\_GSS 핸들을 나타내며 \[4\]의 섹션 5.2.3.1 "컨텍스트 생성 응답 - 성공적인 수락"에 정의된 rpc\_gss\_init\_res 데이터 유형의 "handle" 필드의 데이터 유형과 정확히 동일합니다.

- 첫 번째 RPCSEC\_GSS 핸들인 gcbp\_handle\_from\_server는 RPCSEC\_GSS 컨텍스트가 다음과 같을 때 서버가 클라이언트에 반환한 앞 핸들입니다\(데이터 유형 rpc\_gss\_init\_res의 핸들 필드 또는 EXCHANGE\_ID에 대한 응답으로 반환된 spi\_handles 필드의 요소 중 하나\). 서버에 생성되었습니다. 두 번째 핸들인 gcbp\_handle\_from\_client는 클라이언트가 RPCSEC\_GSS 컨텍스트를 매핑할 백 핸들입니다. 서버는 콜백 RPC의 RPCSEC\_GSS 자격 증명에 있는 gcbp\_handle\_from\_client 값을 즉시 사용할 수 있습니다. 즉, gcbp\_handle\_from\_client의 값은 콜백 RPC에서 데이터 유형 rpc\_gss\_cred\_t\("RPCSEC\_GSS 보안 프로토콜의 요소", \[4\]의 섹션 5 참조\)의 "handle" 필드 값으로 사용될 수 있습니다. 서버는 gcbp\_service에 지정된 RPCSEC\_GSS 보안 서비스를 사용해야 합니다. 즉, RPCSEC\_GSS 자격 증명의 rpc\_gss\_cred\_t 데이터 유형의 "서비스" 필드를 gcbp\_service의 값으로 설정해야 합니다\(\[4의 "RPC 요청 헤더", 섹션 5.3.1 참조\). \]\).\(MUST\)

- gcbp\_handle\_from\_server로 식별된 RPCSEC\_GSS 핸들이 서버에 없으면 서버는 NFS4ERR\_NOENT를 반환합니다.

- csa\_sec\_parms의 각 요소 내에서 앞뒤 RPCSEC\_GSS 컨텍스트는 동일한 GSS 컨텍스트를 공유해야 하며 동일한 seq\_window를 가져야 합니다\(RFC 2203 \[4\]의 섹션 5.2.3.1 참조\). 앞과 뒤의 RPCSEC\_GSS 컨텍스트 상태는 RPCSEC\_GSS 시퀀스 번호만큼 서로 독립적입니다\(\[4\]의 섹션 5 및 5.3.1의 rpc\_gss\_cred\_t 데이터 유형의 seq\_num 필드 참조\).\(MUST\)

RPCSEC\_GSS 핸들이 SSV 컨텍스트를 사용하는 경우\(참조:

- 섹션 2.10.9\), 각 SSV RPCSEC\_GSS 핸들은 공통 SSV GSS 컨텍스트를 공유하므로 섹션 2.10.10에서 논의된 이 상황과 관련된 보안 고려 사항이 있습니다.

세션이 생성되면 슬롯에서 수신된 첫 번째 SEQUENCE 또는 CB\_SEQUENCE의 시퀀스 ID는 1이어야 합니다. 그렇지 않은 경우 응답자는 NFS4ERR\_SEQ\_MISORDERED를 반환해야 합니다.\(MUST\)

---
#### **18.36.4.  IMPLEMENTATION**

가능한 구현을 설명하기 위해 EXCHANGE\_ID 설명에 소개된 클라이언트 레코드에 대한 동일한 표기법이 다음 추가와 함께 사용됩니다.

clientid\_arg: csa\_clientid 필드의 값

- 현재 요청의 CREATE\_SESSION4args 구조입니다.

CREATE\_SESSION은 비멱등성 작업이므로 클라이언트 재시작, 네트워크 파티션, 라우터 오작동 등의 결과로 재시도가 발생할 가능성을 고려해야 합니다. EXCHANGE\_ID에 의해 생성된 각 클라이언트 ID에 대해 서버는 별도의 응답 캐시를 유지합니다. \(CREATE\_SESSION 응답 캐시라고 함\) SEQUENCE 작업에 사용되는 세션 응답 캐시와 유사하지만 두 가지 차이점이 있습니다.

\* 첫째, 주어진 클라이언트 ID에 대한 CREATE\_SESSION 요청을 감지하고 처리하기 위한 응답 캐시입니다.

\* 둘째, 클라이언트 ID 응답 캐시의 크기는 하나의 슬롯입니다\(따라서 CREATE\_SESSION 요청은 슬롯 번호를 전달하지 않습니다\). 이는 특정 클라이언트 ID에 대해 최대 하나의 CREATE\_SESSION 요청이 미해결 상태일 수 있음을 의미합니다.

이전에 설명한 대로 CREATE\_SESSION은 이전 SEQUENCE 작업과 함께 또는 없이 전송될 수 있습니다. SEQUENCE가 CREATE\_SESSION보다 앞에 있더라도 서버는 SEQUENCE와 연관된 세션에 대한 응답 캐시와 별도로 CREATE\_SESSION 응답 캐시를 유지해야 합니다. CREATE\_SESSION이 원래 자체적으로 전송된 경우 클라이언트는 SEQUENCE가 앞에 오는 COMPOUND 내에서 CREATE\_SESSION 작업의 재시도를 보낼 수 있습니다. CREATE\_SESSION이 원래 SEQUENCE로 시작된 COMPOUND에서 전송된 경우 클라이언트는 원래 요청의 SEQUENCE와 동일한 세션 ID를 가진 SEQUENCE로 시작하는 COMPOUND에서 재시도를 보내야 합니다. 그러나 클라이언트는 이전 SEQUENCE가 없거나 원래 CREATE\_SESSION과 다른 세션을 참조하는 이전 SEQUENCE가 있는 COMPOUND에서 재시도를 보낼 수 있습니다. 클라이언트가 세션 ID X가 있는 SEQUENCE가 앞에 오는 COMPOUND에서 CREATE\_SESSION을 보내고 세션 X가 더 이상 존재하지 않는 경우 필요할 수 있습니다. 그럼에도 불구하고 선행 SEQUENCE 유무에 관계없이 CREATE\_SESSION 재시도는 원본과 동일한 csa\_sequence 값을 사용해야 합니다.\(MUST, MAY, SHOULD, MAY, MUST\)

클라이언트가 확인되지 않은 새 클라이언트 ID가 포함된 EXCHANGE\_ID 작업에 대한 응답을 받은 후 서버는 클라이언트가 클라이언트 ID를 확인하기 위해 CREATE\_SESSION 작업을 수행할 것으로 예상합니다. 서버는 해당 CREATE\_SESSION에 대한 인수의 csa\_sequenceid 값이 확인되지 않은 클라이언트 ID를 반환한 EXCHANGE\_ID의 결과로 반환된 eir\_sequenceid 필드 값과 동일할 것으로 예상합니다. 서버가 해당 EXCHANGE\_ID 작업에 응답하기 전에 클라이언트 ID 슬롯을 eir\_sequenceid - 1\(언더플로 고려\)과 동일하도록 초기화하고 NFS4ERR\_SEQ\_MISORDERED의 "캐시된" 결과와 함께 인위적인 CREATE\_SESSION 결과를 기록합니다. 이렇게 초기화된 클라이언트 ID 슬롯을 사용하면 CREATE\_SESSION 작업 처리가 4단계로 나뉩니다.

1. 고객 기록을 조회합니다. 서버는 클라이언트 레코드 테이블에서 클라이언트 ID를 조회합니다. 서버에 클라이언트 ID가 clientid\_arg와 동일한 레코드가 없으면 연결 끊김으로 인해 비활성 기간 동안 클라이언트 상태가 제거되었을 가능성이 높습니다. NFS4ERR\_STALE\_CLIENTID가 반환되고 서버의 클라이언트 레코드는 변경되지 않습니다. 그렇지 않으면 서버는 2단계로 진행됩니다.

2. 서열 ID 처리. csa\_sequenceid가 클라이언트 ID 슬롯의 시퀀스 ID와 동일한 경우 이는 이전 CREATE\_SESSION 요청의 재생이며 서버는 캐시된 결과를 반환합니다. csa\_sequenceid가 슬롯의 시퀀스 ID와 동일하지 않고 하나 이상 큰 경우\(랩어라운드 고려\) 서버는 NFS4ERR\_SEQ\_MISORDERED 오류를 반환하고 슬롯을 변경하지 않습니다. csa\_sequenceid가 슬롯의 시퀀스 ID + 1\(랩어라운드 고려\)과 동일한 경우 슬롯의 시퀀스 ID는 csa\_sequenceid로 설정되고 CREATE\_SESSION 처리는 다음 단계로 이동합니다. 동일한 클라이언트 ID를 통한 후속 새 CREATE\_SESSION 호출은 슬롯의 시퀀스 ID보다 1 큰 csa\_sequenceid를 사용해야 합니다.\(MUST\)

3. 고객 ID 확인. 이것이 클라이언트 ID에 대한 첫 번째 세션인 경우 CREATE\_SESSION 작업은 클라이언트 ID를 확인하는 역할을 합니다. 그렇지 않으면 클라이언트 ID 확인 단계를 건너뛰고 세션 생성 단계만 발생합니다. 클라이언트 ID에 대해 동일한 값을 가진 레코드가 두 개 이상 있는 경우는 서버 구현 오류를 나타냅니다. 잠재적으로 유효한 경우의 동작은 다음과 같이 요약됩니다.

```text
       *  Successful Confirmation
```

- 서버에 다음과 같은 미확인 기록이 있는 경우 이는 미확인 기록에 대한 확인이 예상되는 것입니다.

```text
             { ownerid, verifier, principal_arg, clientid_arg,
             unconfirmed }
```

- 18.35.4항에 명시된 바와 같이 서버에는 다음과 같은 확인된 기록이 있을 수도 있습니다.

```text
             { ownerid, old_verifier, principal_arg, old_clientid,
             confirmed }
```

- 서버는 다음을 통해 두 기록의 교체를 예약합니다.

```text
             { ownerid, verifier, principal_arg, clientid_arg, confirmed
             }
```

- CREATE\_SESSION 처리는 세션 생성까지 계속됩니다. 세션이 성공적으로 생성되면 예약된 클라이언트 레코드 교체가 커밋됩니다. 세션이 성공적으로 생성되지 않으면 서버의 클라이언트 레코드가 변경되지 않습니다.

```text
       *  Unsuccessful Confirmation
```

- 서버에 다음 레코드가 있는 경우 클라이언트가 이전 EXCHANGE\_ID 요청 이후 주체를 변경했거나 단축 클라이언트 식별자 간에 충돌이 발생할 가능성이 있는 것입니다.

```text
             { *, *, old_principal_arg, clientid_arg, * }
```

- 두 경우 모두 허용되지 않습니다. 처리가 중지되고 NFS4ERR\_CLID\_INUSE가 클라이언트에 반환됩니다. 서버의 클라이언트 레코드는 변경되지 않습니다.

4. 세션 생성. 서버는 이 CREATE\_SESSION 작업이나 이전 CREATE\_SESSION 작업에서 클라이언트 ID를 확인했습니다. 서버는 인수의 나머지 필드를 검사합니다.

- 서버는 사용된 매개변수 값\(CREATE\_SESSION4\_FLAG\_PERSIST 플래그가 설정되어 있고 서버에서 승인되었는지 여부 포함\)을 기록하고 세션 응답 캐시에 공간을 할당하여 세션을 생성합니다\(공간이 충분하지 않으면 서버는 NFS4ERR\_NOSPC를 반환합니다\). 응답 캐시의 각 슬롯에 대해 서버는 시퀀스 ID를 0으로 설정하고 작업이 0인 COMPOUND 응답과 NFS4ERR\_SEQ\_MISORDERED 오류가 포함된 항목을 기록합니다. 이렇게 하면 전송된 첫 번째 SEQUENCE 요청의 시퀀스 ID가 0인 경우 서버는 응답 캐시에 있는 NFS4ERR\_SEQ\_MISORDERED를 간단히 반환할 수 있습니다. 클라이언트는 동일한 방식으로 콜백을 수신하기 위해 응답 캐시를 초기화하며, 마찬가지로 세션 생성 후 슬롯의 첫 번째 CB\_SEQUENCE 작업에는 시퀀스 ID 1이 있어야 합니다.\(MUST\)

세션 상태가 성공적으로 생성되면 서버는

- 클라이언트가 제공한 클라이언트 ID와 세션을 연결합니다.

- CREATE\_SESSION4\_FLAG\_CONN\_RDMA가 설정된 요청을 재시도해야 하는 경우 비RDMA 모드에 있는 새 연결에서 재시도를 수행해야 합니다. 새 연결의 속성이 CREATE\_SESSION에 대한 인수를 변경해야 할 정도로 다른 경우 비재시도를 전송해야 합니다. 서버는 결국 원래 연결에서 생성된 모든 세션을 삭제합니다.\(MUST, MUST\)

백채널에서 클라이언트와 서버는 네트워크 링크의 지연 시간이 길고 리콜에 대한 응답의 주요 병목 현상이 되는 상황을 처리하기 위해 많은 슬롯\(어떤 경우에는 포 채널보다 더 많은 슬롯\)을 원할 수 있습니다. 그렇다면 클라이언트가 백채널에 너무 적은 슬롯을 제공하는 경우 서버는 클라이언트에 제공하는 회수 가능한 개체의 수를 제한할 수 있습니다.

RPCSEC\_GSS 콜백 지원을 구현하려면 RPCSEC\_GSS의 클라이언트 및 서버 구현을 모두 변경해야 합니다. 가능한 변경 사항 중 하나는 다음과 같습니다.

\* 참조 횟수로 GSS-API 컨텍스트를 래핑하는 데이터 구조를 추가합니다.

\* 참조 카운트를 증가 및 감소시키는 새로운 기능. 참조 횟수가 0으로 감소하면 래퍼 데이터 구조와 이것이 참조하는 GSS-API 컨텍스트가 해제됩니다.

\* gss\_accept\_sec\_context\(\) 및 gss\_init\_sec\_context\(\)에서 GSS-API 컨텍스트를 수신하면 래퍼 데이터 구조를 생성하도록 RPCSEC\_GSS를 변경합니다. 참조 카운트는 1로 초기화됩니다.

\* 기존 RPCSEC\_GSS 핸들을 래퍼 데이터 구조에 대한 포인터에 매핑하는 함수를 추가합니다. 참조 횟수가 증가합니다.

\* 래퍼 데이터 구조에 대한 포인터에서 새 RPCSEC\_GSS 핸들을 생성하는 함수를 추가합니다. 참조 횟수가 증가합니다.

\* GSS-API 컨텍스트를 해제하는 RPCSEC\_GSS의 호출을 래퍼 데이터 구조의 참조 횟수를 줄이는 호출로 대체합니다.

---
### **18.37.  Operation 44: DESTROY_SESSION - Destroy a Session**
---
#### **18.37.1.  ARGUMENT**

```text
   struct DESTROY_SESSION4args {
           sessionid4      dsa_sessionid;
   };
```

---
#### **18.37.2.  RESULT**

```text
   struct DESTROY_SESSION4res {
           nfsstat4        dsr_status;
   };
```

---
#### **18.37.3.  DESCRIPTION**

DESTROY\_SESSION 작업은 세션을 닫고 세션의 응답 캐시\(있는 경우\)를 삭제합니다. 세션과 연결된 나머지 연결은 즉시 연결이 해제됩니다. 연결에 연결된 세션이 남아 있지 않으면 서버가 연결을 닫을 수 있습니다. 클라이언트 ID에 모두 연결된 잠금, 위임, 레이아웃, 원함 및 임대는 DESTROY\_SESSION의 영향을 받지 않습니다.\(MAY\)

DESTROY\_SESSION은 삭제되는 세션과 연결된 연결에서 호출되어야 합니다. 또한 클라이언트 ID가 생성될 때 SP4\_MACH\_CRED 상태 보호가 지정된 경우 세션을 생성한 RPCSEC\_GSS 주체는 RPCSEC\_GSS 개인 정보 보호 또는 무결성을 사용하여 세션을 삭제하는 주체여야 합니다. 클라이언트 ID가 생성될 때 SP4\_SSV 상태 보호가 지정된 경우 SSV 메커니즘\(섹션 2.10.9\)을 사용하는 RPCSEC\_GSS를 무결성 또는 개인 정보 보호와 함께 사용해야 합니다.\(MUST, MUST, MUST\)

COMPOUND 요청이 SEQUENCE로 시작하고 SEQUENCE와 DESTROY\_SESSION에 지정된 세션 ID가 동일한 경우

\* DESTROY\_SESSION은 COMPOUND 요청의 마지막 작업이어야 합니다.\(MUST\)

\* DESTROY\_SESSION이 응답 캐시를 파괴하므로 다른 상태 수정 작업과 함께 COMPOUND 요청에 DESTROY\_SESSION을 배치하지 않는 것이 좋습니다.

\* 세션과 해당 응답 캐시가 삭제되므로 요청을 재시도하는 클라이언트는 원래 요청이 성공했더라도 재시도에 대한 응답으로 오류를 수신할 수 있습니다.

COMPOUND 요청이 SEQUENCE로 시작하고 SEQUENCE와 DESTROY\_SESSION에 지정된 세션 ID가 다른 경우 DESTROY\_SESSION은 COMPOUND 요청의 모든 위치\(첫 번째 위치 제외\)에 나타날 수 있습니다. 두 개의 세션 ID는 서로 다른 클라이언트 ID에 속할 수 있습니다.

COMPOUND 요청이 SEQUENCE로 시작되지 않고 DESTROY\_SESSION이 유일한 작업이 아닌 경우 서버는 NFS4ERR\_NOT\_ONLY\_OP를 반환해야 합니다.\(MUST\)

세션에 백채널이 있고 서버에 응답되지 않은 세션에 대한 미해결 CB\_COMPOUND 작업이 있는 경우 서버는 세션 삭제를 거부하고 오류를 반환할 수 있습니다. 그렇다면 백채널이 다운된 경우 서버는 NFS4ERR\_CB\_PATH\_DOWN을 반환하여 서버가 세션 삭제를 허용하기 전에 백채널을 복구해야 함을 클라이언트에게 알려야 합니다. 그렇지 않으면 응답해야 하는 CB\_COMPOUND가 있음을 나타내기 위해 CB\_BACK\_CHAN\_BUSY 오류가 반환되어야 합니다. 클라이언트는 DESTROY\_SESSION을 다시 보내기 전에 모든 미해결 CB\_COMPOUND에 응답해야 합니다.\(MAY, SHOULD, SHOULD, SHOULD\)

---
### **18.38.  Operation 45: FREE_STATEID - Free Stateid with No Locks**
---
#### **18.38.1.  ARGUMENT**

```text
   struct FREE_STATEID4args {
           stateid4        fsa_stateid;
   };
```

---
#### **18.38.2.  RESULT**

```text
   struct FREE_STATEID4res {
           nfsstat4        fsr_status;
   };
```

---
#### **18.38.3.  DESCRIPTION**

FREE\_STATEID 작업은 더 이상 관련 잠금\(열기, 바이트 범위 잠금, 위임 및 레이아웃 포함\)이 없는 상태 ID를 해제하는 데 사용됩니다. 이는 클라이언트 LOCKU 작업 때문이거나 서버 취소 때문일 수 있습니다. 문제의 stateid와 연관된 유효한 잠금\(모든 종류\)이 있는 경우 NFS4ERR\_LOCKS\_HELD 오류가 반환되고 연관된 stateid는 해제되지 않습니다.

취소된 잠금과 연관된 상태 ID가 해제되면 FREE\_STATEID 작업을 전송하여 클라이언트는 해당 잠금의 손실을 승인합니다. 이를 통해 서버는 모든 취소된 상태가 확인되면 섹션 8.4.2에서 설명한 경계 조건에 직면하지 않고 해당 클라이언트가 다시 잠금을 회수할 수 있도록 허용합니다.

주어진 stateid에 대해 성공적인 FREE\_STATEID가 수행되면 이후에 해당 stateid를 사용하면 NFS4ERR\_BAD\_STATEID 오류가 발생합니다.

---
### **18.39.  Operation 46: GET_DIR_DELEGATION - Get a Directory Delegation**
---
#### **18.39.1.  ARGUMENT**

```text
   typedef nfstime4 attr_notice4;

   struct GET_DIR_DELEGATION4args {
           /* CURRENT_FH: delegated directory */
           bool            gdda_signal_deleg_avail;
           bitmap4         gdda_notification_types;
           attr_notice4    gdda_child_attr_delay;
           attr_notice4    gdda_dir_attr_delay;
           bitmap4         gdda_child_attributes;
           bitmap4         gdda_dir_attributes;
   };
```

---
#### **18.39.2.  RESULT**

```text
   struct GET_DIR_DELEGATION4resok {
           verifier4       gddr_cookieverf;
           /* Stateid for get_dir_delegation */
           stateid4        gddr_stateid;
           /* Which notifications can the server support */
           bitmap4         gddr_notification;
           bitmap4         gddr_child_attributes;
           bitmap4         gddr_dir_attributes;
   };

   enum gddrnf4_status {
           GDD4_OK         = 0,
           GDD4_UNAVAIL    = 1
   };

   union GET_DIR_DELEGATION4res_non_fatal
    switch (gddrnf4_status gddrnf_status) {
    case GDD4_OK:
     GET_DIR_DELEGATION4resok      gddrnf_resok4;
    case GDD4_UNAVAIL:
     bool                          gddrnf_will_signal_deleg_avail;
   };

   union GET_DIR_DELEGATION4res
    switch (nfsstat4 gddr_status) {
    case NFS4_OK:
     GET_DIR_DELEGATION4res_non_fatal      gddr_res_non_fatal4;
    default:
     void;
   };
```

---
#### **18.39.3.  DESCRIPTION**

GET\_DIR\_DELEGATION 작업은 클라이언트가 디렉터리 위임을 요청하는 데 사용됩니다. 디렉토리는 현재 파일 핸들로 표시됩니다. 또한 클라이언트는 비트맵에 하나 이상의 비트를 설정하여 디렉터리가 특정 방식으로 변경될 때 서버가 이를 알리도록 할지 여부도 지정합니다. 서버는 위임 승인을 거부할 수 있습니다. 이 경우 서버는 NFS4ERR\_DIRDELEG\_UNAVAIL을 반환합니다. 서버가 위임을 전달하기로 결정하면 해당 디렉터리에 대한 쿠키 확인 프로그램이 반환됩니다. 클라이언트가 위임을 보유하고 있는 동안 쿠키 검증자가 변경되면 클라이언트가 이 이벤트에 대한 알림을 요청하지 않는 한 위임이 회수됩니다.

서버는 또한 GET\_DIR\_DELEGATION 작업의 결과로 디렉터리 위임 상태 ID인 gddr\_stateid를 반환합니다. 이 상태 ID는 알림, 위임 회수 등 위임과 관련된 콜백 메시지에 표시됩니다. 클라이언트는 이 상태 ID를 사용하여 자발적으로 또는 회수 시 위임을 반환합니다. DELEGRETURN 작업을 호출하면 위임이 반환됩니다.

서버는 특정 이벤트에 대한 알림을 지원하지 못할 수도 있습니다. 클라이언트가 그러한 알림을 요청하는 경우 서버는 응답에 포함된 지원되는 알림 비트마스크 gddr\_notification에서 적절한 비트를 설정하지 않음으로써 GET\_DIR\_DELEGATION 응답의 일부로 이를 수행할 수 없음을 클라이언트에 알려야 합니다. 서버는 클라이언트가 요청하지 않은 gddr\_notification에 비트를 추가해서는 안 됩니다.\(MUST, MUST NOT\)

GET\_DIR\_DELEGATION 작업은 일반 및 명명된 속성 디렉터리 모두에 사용할 수 있습니다.

클라이언트가 gdda\_signal\_deleg\_avail을 TRUE로 설정하면 디렉터리 위임을 위해 클라이언트에 "원함"을 등록하는 것입니다. 위임을 사용할 수 없고 서버가 "원함"을 지원하고 존중하는 경우 결과는 gddrnf\_will\_signal\_deleg\_avail이 TRUE로 설정되고 반환 시 오류가 표시되지 않습니다. 그렇다면 클라이언트는 향후 CB\_RECALLABLE\_OBJ\_AVAIL 작업에서 디렉터리 위임이 사용 가능함을 나타낼 것으로 예상해야 합니다. 서버가 "원함"을 따르기를 원하지 않거나 그렇게 할 수 없는 경우 NFS4ERR\_DIRDELEG\_UNAVAIL 오류를 반환합니다. 위임을 즉시 사용할 수 있는 경우 서버는 콜백을 통하지 않고 작업에 대한 응답과 함께 위임을 반환해야 합니다.\(SHOULD\)

클라이언트가 해당 디렉터리에 대한 디렉터리 위임을 이미 보유하고 있는 동안 디렉터리 위임을 요청하는 경우\(이를 회수했지만 클라이언트가 아직 반환하지 않았거나 서버에서 취소한 경우 포함\) 서버는 다음 값으로 응답해야 합니다. gddr\_status의 값은 NFS4\_OK로 설정되고, gddrnf\_status의 값은 GDD4\_UNAVAIL로 설정되며, gddrnf\_will\_signal\_deleg\_avail의 값은 FALSE로 설정됩니다. 요청 전에 클라이언트가 보유한 위임은 그대로 유지되며 상태도 변경되지 않습니다. 현재 stateid는 변경되지 않습니다\(현재 stateid에 대한 설명은 섹션 16.2.3.1.2 참조\).\(MUST\)

---
#### **18.39.4.  IMPLEMENTATION**

디렉터리 위임은 네임스페이스 정보의 캐시 일관성을 향상시키는 이점을 제공합니다. 이는 동기식 콜백을 통해 수행됩니다. 디렉터리 위임을 지원하려면 서버가 동기 콜백을 지원해야 합니다. 또한 비동기식 알림은 네트워크 트래픽을 줄이고 특정 조건에서 클라이언트 성능을 향상시키는 방법을 제공합니다.

알림은 디렉터리에 대한 잠재적인 변경 사항을 기준으로 지정됩니다. 클라이언트는 gdda\_notification\_types에 하나 이상의 비트를 설정하여 이벤트 알림을 받도록 요청할 수 있습니다. 클라이언트는 디렉터리에 항목 추가\(gdda\_notification\_types에서 NOTIFY4\_ADD\_ENTRY 설정\), 항목 제거\(NOTIFY4\_REMOVE\_ENTRY\), 이름 변경\(NOTIFY4\_RENAME\_ENTRY\), 디렉터리 속성 변경\(NOTIFY4\_CHANGE\_DIR\_ATTRIBUTES\) 및 쿠키 확인 프로그램 변경\(NOTIFY4\_CHANGE\_COOKIE\_VERIFIER\)에 대한 알림을 요청할 수 있습니다. 에 의해 gdda\_notification\_types 필드에 하나 이상의 해당 비트를 설정합니다.

클라이언트는 속성 캐시를 최신 상태로 유지하기 위해 디렉토리 항목 속성\(NOTIFY4\_CHANGE\_CHILD\_ATTRIBUTES\)에 대한 변경 알림을 요청할 수도 있습니다. 그러나 하위 속성을 변경해도 위임이 회수되지는 않습니다. 클라이언트가 디렉터리 항목 캐싱이나 음수 이름 캐싱에 관심이 있는 경우 특정 요구 사항에 맞게 gdda\_notification\_types를 적절하게 설정할 수 있으며 서버는 이름 캐시를 무효화하는 모든 변경 사항을 클라이언트에 알립니다. 클라이언트가 요청하는 알림의 종류는 디렉터리 크기, 변경 속도, 해당 디렉터리에 액세스하는 데 사용되는 응용 프로그램에 따라 달라질 수 있습니다. 클라이언트가 알림을 요청할 수 있는 조건 열거는 이 사양의 범위를 벗어납니다.

속성 알림의 경우 클라이언트는 gdda\_dir\_attributes 비트맵에 비트를 설정하여 알림을 받고 싶은 속성을 나타냅니다. 서버가 특정 속성 변경에 대한 알림을 지원하지 않는 경우 응답\(gddr\_dir\_attributes\)에 지정된 지원 속성 비트맵에 해당 속성을 설정해서는 안 됩니다. 클라이언트는 또한 gdda\_child\_attributes 비트맵에 알림을 받고 싶은 디렉터리 항목의 속성을 설정하고, 서버는 클라이언트에 알릴 디렉터리 항목의 속성을 gddr\_child\_attributes에 표시합니다.\(SHOULD NOT\)

클라이언트는 또한 속성 변경이 발생하자마자 알림을 받고 싶은지 또는 지연 요소를 설정하여 특정 지연 후에 알림을 받고 싶은지 서버에 알립니다. gdda\_child\_attr\_delay는 디렉터리 항목의 속성 변경을 위한 것이고 gdda\_dir\_attr\_delay는 디렉터리의 속성 변경을 위한 것입니다. 이 지연 요소가 0으로 설정되면 이는 클라이언트가 속성 변경이 발생하는 즉시 알림을 받기를 원한다는 것을 서버에 나타냅니다. 지연 요소가 N초로 설정된 경우 서버는 속성 업데이트가 N초 내에 동기화되도록 최선을 다합니다. 클라이언트가 서버가 지원하지 않거나 서버가 많은 알림을 보내도록 하여 서버에서 상당한 리소스 소비를 초래할 수 있는 지연 요소를 요청하는 경우 서버는 속성에 대한 알림을 보내는 데 전념해서는 안 되며 따라서 그렇게 해서는 안 됩니다. 응답의 gddr\_child\_attributes 및 gddr\_dir\_attributes 비트맵에 적절한 비트를 설정하십시오.

클라이언트는 디렉터리 또는 해당 상위 항목\(섹션 2.6\)을 내보내는 데 사용되는 보안 튜플\(섹션 2.6.1\)을 사용해야 합니다. 그렇지 않은 경우 서버는 GET\_DIR\_DELEGATION 이전 작업에 NFS4ERR\_WRONGSEC를 반환하고 현재 파일 핸들을 설정해야 합니다\(섹션 2.6.3.1 참조\).\(MUST, MUST\)

디렉터리 위임에는 상위 항목을 제외한 디렉터리의 모든 항목이 포함됩니다. 즉, 디렉터리와 해당 상위 항목이 모두 디렉터리 위임을 보유하는 경우 하위 항목의 상위 항목이 상위 디렉터리를 가리키더라도 상위 항목에 대한 변경 사항으로 인해 하위 항목에 대한 알림이 전송되지 않습니다.

---
### **18.40.  Operation 47: GETDEVICEINFO - Get Device Information**
---
#### **18.40.1.  ARGUMENT**

```text
   struct GETDEVICEINFO4args {
           deviceid4       gdia_device_id;
           layouttype4     gdia_layout_type;
           count4          gdia_maxcount;
           bitmap4         gdia_notify_types;
   };
```

---
#### **18.40.2.  RESULT**

```text
   struct GETDEVICEINFO4resok {
           device_addr4    gdir_device_addr;
           bitmap4         gdir_notification;
   };

   union GETDEVICEINFO4res switch (nfsstat4 gdir_status) {
   case NFS4_OK:
           GETDEVICEINFO4resok     gdir_resok4;
   case NFS4ERR_TOOSMALL:
           count4                  gdir_mincount;
   default:
           void;
   };
```

---
#### **18.40.3.  DESCRIPTION**

GETDEVICEINFO 작업은 지정된 디바이스 ID에 대한 pNFS 스토리지 디바이스 주소 정보를 반환합니다. 클라이언트는 장치를 고유하게 식별하는 gdia\_device\_id 및 gdia\_layout\_type을 제공하여 반환될 장치 정보를 식별합니다. 클라이언트는 결과의 바이트 수를 제한하기 위해 gdia\_maxcount를 제공합니다. 이 최대 크기는 GEDEVICEINFO4resok 구조 내에서 반환되는 모든 데이터를 나타내며 XDR 오버헤드를 포함합니다. 서버가 더 적은 양의 데이터를 반환할 수 있습니다. 서버가 gdia\_maxcount 제한 내에서 정보를 반환할 수 없으면 NFS4ERR\_TOOSMALL 오류가 반환됩니다. 그러나 gdia\_maxcount가 0이면 NFS4ERR\_TOOSMALL이 반환되어서는 안 됩니다.\(MUST NOT\)

서버가 반환한 gdir\_device\_addr의 da\_layout\_type 필드는 클라이언트가 지정한 gdia\_layout\_type과 동일해야 합니다. 동일하지 않은 경우 클라이언트는 응답을 유효하지 않은 것으로 무시하고 클라이언트가 반환된 레이아웃 유형을 지원하더라도 서버가 오류를 반환한 것처럼 동작해야 합니다.\(MUST, SHOULD\)

클라이언트는 또한 수신에 관심이 있는 장치 ID 매핑 알림에 대해 알림 비트맵 gdia\_notify\_types를 제공합니다. 알림 요청이 적용되려면 서버가 장치 ID 알림을 지원해야 합니다. 알림 마스크는 파일 속성에 대한 비트맵과 동일한 방식으로 구성됩니다\(3.3.7절\). 비트 위치의 수는 inform\_device\_type4 열거 유형\(20.12절\)에 나열되어 있습니다. 현재 GEDEVICEINFO에는 NOTIFY\_DEVICEID4\_CHANGE 및 NOTIFY\_DEVICEID4\_DELETE의 두 가지 열거된 값인 inform\_device\_type4만 적용됩니다\(섹션 20.12 참조\).

알림 비트맵은 지정된 장치 ID에만 적용됩니다. 클라이언트가 deviceID에 대해 GEDEVICEINFO 작업을 여러 번 보내는 경우 서버는 후속 알림을 위해 마지막 알림 비트맵을 사용합니다. 비트맵이 0이거나 비어 있으면 장치 ID의 알림이 꺼집니다.

클라이언트가 알림을 업데이트하거나 끄고 싶다면 gdia\_maxcount를 0으로 설정하여 GEDEVICEINFO 작업을 보낼 수 있습니다. 이 경우 장치 ID가 유효하면 gdir\_device\_addr 필드의 응답 da\_addr\_body 필드 길이가 0이 됩니다.\(MAY\)

gdia\_device\_id에 알 수 없는 장치 ID가 제공되면 서버는 NFS4ERR\_NOENT를 반환합니다. 그렇지 않으면 장치 주소 정보가 gdir\_device\_addr에 반환됩니다. 마지막으로, 서버가 장치 ID 매핑에 대한 알림을 지원하는 경우 gdir\_notification 결과에는 실제로 클라이언트에 보낼 알림에 대한 비트맵이 포함됩니다\(CB\_NOTIFY\_DEVICEID를 통해, 섹션 20.12 참조\).

NFS4ERR\_TOOSMALL이 반환되면 결과에는 gdir\_mincount도 포함됩니다. gdir\_mincount 값은 장치 정보를 얻는 데 필요한 최소 크기를 나타냅니다.

---
#### **18.40.4.  IMPLEMENTATION**

알림을 업데이트하거나 끄는 것 외에도 gdia\_maxcount를 0으로 설정하는 또 다른 사용 사례는 장치 ID의 유효성을 검사하는 것입니다.

클라이언트는 보류 중인 I/O가 갑자기 실패하거나 장치 ID를 사용하는 레이아웃이 강제로 실행되지 않고 클라이언트가 새 매핑을 정상적으로 사용할 수 있도록 서버가 장치 주소 매핑에 대한 장치 ID의 변경 또는 삭제에 대한 알림을 요청해야 합니다\(SHOULD\). 리콜되거나 취소되었습니다.\(SHOULD\)

GEDEVICEINFO\(및 GEDEVICELIST\)가 CB\_NOTIFY\_DEVICEID와 경쟁할 가능성이 있습니다. 즉, 클라이언트가 GEDEVICEINFO 또는 GEDEVICELIST에 대한 응답을 가져와 처리하기 전에 CB\_NOTIFY\_DEVICEID가 도착합니다. 경주 분석은 서버가 클라이언트의 레이아웃에서 참조하는 장치 ID를 삭제해서는 안 된다는 사실을 활용합니다.\(MUST NOT\)

\* CB\_NOTIFY\_DEVICEID는 장치 ID를 삭제합니다. 클라이언트가 장치 ID를 참조하는 레이아웃이 있다고 생각하는 경우 삭제된 장치 ID를 참조하는 레이아웃이 취소되었을 수 있습니다. 클라이언트는 취소되었을 수 있는 각 레이아웃의 stateid를 사용하여 TEST\_STATEID 요청을 보내야 합니다. TEST\_STATEID가 레이아웃이 취소되었음을 나타내는 경우 클라이언트는 섹션 12.5.6에 설명된 대로 레이아웃 취소에서 복구해야 합니다. TEST\_STATEID가 하나 이상의 레이아웃이 취소되지 않았음을 나타내는 경우 클라이언트는 삭제된 것으로 추정되는 장치 ID에 대해 GEDEVICEINFO 작업을 보내 장치 ID가 삭제되었는지 확인해야 합니다.

- GEDEVICEINFO가 장치 ID가 존재하지 않음을 나타내는 경우 클라이언트는 서버에 결함이 있다고 가정하고 EXCHANGE\_ID 작업을 전송하여 복구합니다. GEDEVICEINFO가 장치 ID가 존재한다고 나타내는 경우 서버가 잘못된 장치 ID 삭제 알림을 보내는 데 결함이 있는 동안 결함이 있는 정도에 따라 클라이언트가 새 클라이언트 ID를 생성할 필요는 없습니다.

- 클라이언트에 장치 ID를 참조하는 레이아웃이 없으면 아무런 해가 없습니다. 클라이언트는 장치 ID를 삭제된 것으로 표시해야 하며 장치 ID가 실제로 삭제되었음을 나타내는 GEDEVICEINFO 또는 GEDEVICELIST 결과가 수신되면 클라이언트 캐시에서 장치 ID를 제거해야 합니다.

\* CB\_NOTIFY\_DEVICEID는 장치 ID의 장치 주소 지정 매핑이 변경되었음을 나타냅니다. 클라이언트는 진행 중인 GEDEVICEINFO의 결과가 일단 수신되면 장치 ID에 대해 유효하지 않을 것이라고 가정해야 하며, 따라서 장치 ID에 대한 또 다른 GEDEVICEINFO를 보내야 합니다.

18.41. 작업 48: GETDEVICELIST - 파일 시스템에 대한 모든 장치 매핑 가져오기

---
#### **18.41.1.  ARGUMENT**

```text
   struct GETDEVICELIST4args {
           /* CURRENT_FH: object belonging to the file system */
           layouttype4     gdla_layout_type;

           /* number of deviceIDs to return */
           count4          gdla_maxdevices;

           nfs_cookie4     gdla_cookie;
           verifier4       gdla_cookieverf;
   };
```

---
#### **18.41.2.  RESULT**

```text
   struct GETDEVICELIST4resok {
           nfs_cookie4             gdlr_cookie;
           verifier4               gdlr_cookieverf;
           deviceid4               gdlr_deviceid_list<>;
           bool                    gdlr_eof;
   };

   union GETDEVICELIST4res switch (nfsstat4 gdlr_status) {
   case NFS4_OK:
           GETDEVICELIST4resok     gdlr_resok4;
   default:
           void;
   };
```

---
#### **18.41.3.  DESCRIPTION**

이 작업은 클라이언트가 서버의 파일 시스템에서 사용하는 모든 장치 ID를 열거하는 데 사용됩니다.

클라이언트는 파일 시스템에 속하는 파일 객체\(즉, 현재 파일 핸들과 동일한 fsid를 공유하는 모든 파일 객체\)의 현재 파일 핸들과 gdia\_layout\_type의 레이아웃 유형을 제공합니다. 이 작업에는 모든 장치 ID를 열거하기 위해 여러 번의 호출이 필요할 수 있으므로\(따라서 READDIR\(섹션 18.23\) 작업과 유사\) 클라이언트는 목록에서 현재 커서 위치를 지정하기 위해 gdia\_cookie 및 gdia\_cookieverf도 제공합니다. 클라이언트가 파일 시스템의 장치 매핑 시작 부분부터 읽으려는 경우 gdla\_cookie를 0으로 설정합니다. gdla\_cookie가 0이면 서버는 gdla\_cookieverf 필드를 무시해야 합니다. 클라이언트는 결과의 장치 ID 수를 제한하기 위해 gdla\_maxdevices를 제공합니다. gdla\_maxdevices가 0이면 서버는 NFS4ERR\_INVAL을 반환해야 합니다. 서버는 더 적은 수의 장치 ID를 반환할 수 있습니다.\(MUST, MUST, MAY\)

작업에 대한 성공적인 응답에는 후속 GEDEVICELIST에서 사용되는 쿠키 gdlr\_cookie와 쿠키 검증 프로그램 gdlr\_cookieverf가 포함됩니다. TRUE의 gdlr\_eof 값은 서버의 장치 목록에 남은 항목이 없음을 나타냅니다. gdlr\_deviceid\_list의 각 요소에는 장치 ID가 포함되어 있습니다.

---
#### **18.41.4.  IMPLEMENTATION**

이 작업의 사용 예는 LAYOUT4\_BLOCK\_VOLUME 레이아웃을 사용하는 pNFS 클라이언트 및 서버에 대한 것입니다. 이러한 환경에서는 클라이언트가 첫 번째 파일 시스템 액세스 시 장치 접근성을 결정하는 것이 도움이 될 수 있습니다.

---
### **18.42.  Operation 49: LAYOUTCOMMIT - Commit Writes Made Using a Layout**
---
#### **18.42.1.  ARGUMENT**

```text
   union newtime4 switch (bool nt_timechanged) {
   case TRUE:
           nfstime4           nt_time;
   case FALSE:
           void;
   };

   union newoffset4 switch (bool no_newoffset) {
   case TRUE:
           offset4           no_offset;
   case FALSE:
           void;
   };

   struct LAYOUTCOMMIT4args {
           /* CURRENT_FH: file */
           offset4                 loca_offset;
           length4                 loca_length;
           bool                    loca_reclaim;
           stateid4                loca_stateid;
           newoffset4              loca_last_write_offset;
           newtime4                loca_time_modify;
           layoutupdate4           loca_layoutupdate;
   };
```

---
#### **18.42.2.  RESULT**

```text
   union newsize4 switch (bool ns_sizechanged) {
   case TRUE:
           length4         ns_size;
   case FALSE:
           void;
   };

   struct LAYOUTCOMMIT4resok {
           newsize4                locr_newsize;
   };

   union LAYOUTCOMMIT4res switch (nfsstat4 locr_status) {
   case NFS4_OK:
           LAYOUTCOMMIT4resok      locr_resok4;
   default:
           void;
   };
```

---
#### **18.42.3.  DESCRIPTION**

LAYOUTCOMMIT 작업은 현재 파일 핸들, 클라이언트 ID\(이전 SEQUENCE 작업의 세션 ID에서 파생됨\), 바이트 범위 및 상태 ID로 표시되는 레이아웃의 변경 사항을 커밋합니다. 레이아웃은 세분화 가능하므로 LAYOUTGET을 통해 검색된 레이아웃의 더 작은 부분을 커밋할 수 있습니다. 커밋되는 바이트 범위는 바이트 범위\(loca\_offset 및 loca\_length\)를 통해 지정됩니다. 이 바이트 범위는 각각 LAYOUTIOMODE4\_RW의 iomode를 갖는 LAYOUTGET\(섹션 18.43\)을 통해 이전에 부여된 하나 이상의 기존 레이아웃과 겹쳐야 합니다. 보유된 레이아웃 세그먼트의 iomode가 LAYOUTIOMODE4\_RW가 아닌 경우 서버는 NFS4ERR\_BAD\_IOMODE 오류를 반환해야 합니다. 클라이언트가 정의된 바이트 범위에 대해 일치하는 레이아웃 세그먼트를 보유하지 않는 경우 서버는 NFS4ERR\_BAD\_LAYOUT 오류를 반환해야 합니다.\(MUST\)

LAYOUTCOMMIT 작업은 클라이언트가 이전 LAYOUTGET에서 얻은 레이아웃을 사용하여 쓰기를 완료했음을 나타냅니다. 클라이언트가 이전에 요청한 데이터 범위의 하위 집합만 썼을 수도 있습니다. LAYOUTCOMMIT을 사용하면 임시로 할당된 공간을 커밋하거나 삭제하고 새로운 파일 끝으로 서버를 업데이트할 수 있습니다. LAYOUTCOMMIT에서 참조하는 레이아웃은 작업이 완료된 후에도 여전히 유효하며 클라이언트 ID, 파일 핸들, 바이트 범위, 레이아웃 유형 및 상태 ID로 계속 참조될 수 있습니다.

loca\_reclaim 필드가 TRUE로 설정된 경우 이는 메타데이터 서버의 복구 유예 기간 동안 클라이언트가 메타데이터 서버를 다시 시작한 후 레이아웃에 대한 변경 사항을 커밋하려고 시도하고 있음을 나타냅니다\(섹션 12.7.4 참조\). 이러한 유형의 요청은 클라이언트가 메타데이터 서버를 다시 시작하기 전에 저장 장치로 전송된 파일의 임시 할당된 바이트 범위에 대한 쓰기를 커밋하지 않은 경우 필요할 수 있습니다. 이 경우 클라이언트가 제공하는 레이아웃은 메타데이터 서버를 다시 시작하기 직전에 클라이언트가 보유한 쓰기 가능한 레이아웃의 하위 집합이어야 합니다. loca\_stateid 필드의 값은 메타데이터 서버가 다시 시작되기 전에 반환한 값이어야 합니다. 메타데이터 서버는 자체 내부 메타데이터 일관성 검사를 기반으로 이 요청을 자유롭게 수락하거나 거부할 수 있습니다. 메타데이터 서버가 클라이언트가 제공한 레이아웃이 일관성 검사를 통과하지 못했다는 사실을 발견하면 NFS4ERR\_RECLAIM\_BAD 상태의 요청을 거부해야 합니다. loca\_reclaim이 TRUE로 설정된 LAYOUTCOMMIT 요청이 성공적으로 완료되면 클라이언트에 파일 레이아웃이 제공되지 않습니다. 단순히 loca\_layoutupdate 필드에 지정된 레이아웃에 대한 변경 사항을 커밋합니다. 파일의 레이아웃을 얻으려면 클라이언트는 서버의 유예 기간이 만료된 후 서버에 LAYOUTGET 요청을 보내야 합니다. 메타데이터 서버가 복구 유예 기간에 있지 않을 때 loca\_reclaim이 TRUE로 설정된 LAYOUTCOMMIT 요청을 수신하는 경우 NFS4ERR\_NO\_GRACE 상태의 요청을 거부해야 합니다.\(MUST, MUST, MUST, MUST\)

메타데이터 서버를 다시 시작하기 전에 커밋된 레이아웃을 획득한 경우에만 loca\_reclaim 필드를 TRUE로 설정해야 합니다. 클라이언트가 메타데이터 서버의 유예 기간 동안 획득한 레이아웃을 커밋하는 경우 "reclaim" 필드를 FALSE로 설정해야 합니다.\(MUST\)

loca\_stateid는 이전에 성공한 레이아웃 작업에서 반환된 레이아웃 stateid 값입니다\(섹션 12.5.3 참조\).

loca\_last\_write\_offset 필드는 LAYOUTCOMMIT 이전에 클라이언트가 쓴 마지막 바이트의 오프셋을 지정합니다. 이 값은 파일 크기와 결코 같지 않으며\(최대 파일 크기보다 1바이트 작음\) NFS4\_MAXFILEOFF보다 작거나 같아야 합니다. 또한 loca\_last\_write\_offset은 loca\_offset 및 loca\_length에 설명된 범위와 겹쳐야 합니다. 메타데이터 서버는 이 정보를 사용하여 파일 크기를 업데이트해야 하는지 여부를 결정할 수 있습니다. 메타데이터 서버가 LAYOUTCOMMIT 작업의 결과로 파일 크기를 업데이트하는 경우 결과의 일부로 새 크기\(locr\_newsize.ns\_size\)를 반환해야 합니다.\(MUST, MUST\)

loca\_time\_modify 필드를 사용하면 클라이언트는 메타데이터 서버에서 설정하려는 수정 시간을 제안할 수 있습니다. 메타데이터 서버는 제안을 사용할 수도 있고 LAYOUTCOMMIT 작업 시간을 사용하여 수정 시간을 설정할 수도 있습니다. 메타데이터 서버가 클라이언트가 제공한 수정 시간을 사용하는 경우 시간이 거꾸로 흐르지 않도록 해야 합니다. 클라이언트가 메타데이터 서버가 정확한 시간을 설정하도록 강제하려는 경우 클라이언트는 LAYOUTCOMMIT 바로 다음에 COMPOUND에서 SETATTR 작업을 사용해야 합니다. 자세한 내용은 섹션 12.5.4를 참조하세요. 클라이언트가 결과 수정 시간을 원하는 경우 GETATTR이 LAYOUTCOMMIT를 따르도록 COMPOUND를 구성해야 합니다.

LAYOUTCOMMIT에 대한 loca\_layoutupdate 인수는 클라이언트가 메타데이터 서버에 레이아웃별 업데이트를 제공하는 메커니즘을 제공합니다. 예를 들어, 레이아웃 업데이트는 원래 레이아웃의 어떤 바이트 범위가 사용되었는지, 어떤 바이트 범위가 할당 취소될 수 있는지 설명할 수 있습니다. NFSv4.1 파일 레이아웃별layoutupdate4 구조는 없습니다.

객체 및 파일보다 블록 장치에 대한 레이아웃 정보가 더 장황합니다. 후자의 두 장치는 저장 프로토콜 뒤에 블록 할당 세부 정보를 숨기기 때문입니다. 최소한 클라이언트는 파일 끝 위치에 대한 변경 사항을 서버에 다시 전달해야 하며, 원하는 경우 파일 수정 시간에 대한 보기도 제공해야 합니다. 블록/볼륨 레이아웃의 경우 어떤 블록이 사용되었는지 정확하게 지정해야 합니다.

인수에서 식별된 레이아웃이 존재하지 않으면 NFS4ERR\_BADLAYOUT 오류가 반환됩니다. 커밋되는 레이아웃은 iomode가 LAYOUTIOMODE4\_RW인 기존 레이아웃과 일치하지 않는 경우에도 거부될 수 있습니다.

성공하면 현재 파일 핸들은 해당 값을 유지하고 현재 stateid는 해당 값을 유지합니다.

---
#### **18.42.4.  IMPLEMENTATION**

클라이언트는 수정된 파일 속성에 대한 힌트를 전달하거나 일반적으로 일반 작업 중에 수행되는 것처럼 객체 기반 저장소 레이아웃에 대한 I/O 오류와 같은 레이아웃 유형 특정 정보를 보고하기 위해 loca\_reclaim 필드를 TRUE로 설정한 LAYOUTCOMMIT를 사용할 수도 있습니다. 이렇게 하면 메타데이터 서버가 다시 시작한 후 파일을 보다 효율적으로 복구하는 데 도움이 될 수 있습니다. 예를 들어, 일부 파일 시스템 구현에서는 메타데이터 서버가 LAYOUTIOMODE4\_RW 레이아웃을 보유한 모든 클라이언트로부터 모든 쓰기를 성공적으로 완료했다는 긍정적인 표시를 얻지 못하는 경우 파일 시스템 개체의 광범위한 복구가 필요할 수 있습니다. LAYOUTCOMMIT\(필요한 경우\)를 보낸 다음 LAYOUTRETURN을 사용하면 이러한 표시를 제공하고 우아하고 효율적인 복구가 가능합니다.\(MAY\)

loca\_reclaim이 TRUE이면 메타데이터 서버는 loca\_stateid 필드의 값을 자유롭게 검사하거나 무시할 수 있습니다. 메타데이터 서버 구현은 메타데이터 서버가 LAYOUTCOMMIT 요청에 대한 일관성 검사를 수행할 수 있도록 하는 레이아웃 stateid 정보를 인코딩할 수도 있고 인코딩하지 않을 수도 있습니다.

---
### **18.43.  Operation 50: LAYOUTGET - Get Layout Information**
---
#### **18.43.1.  ARGUMENT**

```text
   struct LAYOUTGET4args {
           /* CURRENT_FH: file */
           bool                    loga_signal_layout_avail;
           layouttype4             loga_layout_type;
           layoutiomode4           loga_iomode;
           offset4                 loga_offset;
           length4                 loga_length;
           length4                 loga_minlength;
           stateid4                loga_stateid;
           count4                  loga_maxcount;
   };
```

---
#### **18.43.2.  RESULT**

```text
   struct LAYOUTGET4resok {
           bool               logr_return_on_close;
           stateid4           logr_stateid;
           layout4            logr_layout<>;
   };

   union LAYOUTGET4res switch (nfsstat4 logr_status) {
   case NFS4_OK:
           LAYOUTGET4resok     logr_resok4;
   case NFS4ERR_LAYOUTTRYLATER:
           bool                logr_will_signal_layout_avail;
   default:
           void;
   };
```

---
#### **18.43.3.  DESCRIPTION**

LAYOUTGET 작업은 오프셋과 길이로 지정된 바이트 범위에서 파일 핸들이 제공하는 파일을 읽거나 쓰기 위해 메타데이터 서버의 레이아웃을 요청합니다. 레이아웃은 클라이언트 ID\(이전 SEQUENCE 작업의 세션 ID에서 파생됨\), 현재 파일 핸들, 레이아웃 유형\(loga\_layout\_type\) 및 레이아웃 상태 ID\(loga\_stateid\)로 식별됩니다. loga\_iomode 필드의 사용은 레이아웃 유형에 따라 다르지만 클라이언트의 데이터 액세스 의도를 반영해야 합니다.

메타데이터 서버가 유예 기간에 있고 레이아웃과 장치 ID 대 장치 주소 매핑을 유지하지 않는 경우 NFS4ERR\_GRACE를 반환해야 합니다\(섹션 8.4.2.1 참조\).\(MUST\)

LAYOUTGET 작업은 지정된 바이트 범위에 대한 레이아웃 정보\(레이아웃\)를 반환합니다. 클라이언트는 실제로 loga\_offset 필드의 오프셋에서 시작하는 두 가지 범위를 지정합니다. 첫 번째 범위는 loga\_offset과 loga\_offset + loga\_length - 1 사이입니다. 이 범위는 클라이언트가 레이아웃에서 다루기를 원하는 범위를 나타냅니다. 두 번째 범위는 loga\_offset과 loga\_offset + loga\_minlength - 1 사이입니다. 이 범위는 클라이언트가 레이아웃에서 처리해야 하는 필수 범위를 나타냅니다. 따라서 loga\_minlength는 loga\_length보다 작거나 같아야 합니다.\(MUST\)

길이 필드가 NFS4\_UINT64\_MAX로 설정된 경우 이는 파일 길이에 관계없이 loga\_offset에서 파일 끝까지 레이아웃을 가져오려는 요구\(loga\_length가 NFS4\_UINT64\_MAX인 경우\) 또는 요구 사항\(loga\_minlength가 NFS4\_UINT64\_MAX인 경우\)을 나타냅니다.

다음 규칙은 loga\_length, loga\_minlength 및 loga\_offset 간의 관계와 최소값을 제어합니다.

\* loga\_length가 loga\_minlength보다 작은 경우 메타데이터 서버는 NFS4ERR\_INVAL을 반환해야 합니다.\(MUST\)

\* loga\_minlength가 0인 경우 이는 클라이언트가 메타데이터 서버가 "쉽게 사용할 수 있는" 오프셋 loga\_offset 이하의 레이아웃을 원한다는 것을 메타데이터 서버에 표시합니다. Readily는 주관적이며 레이아웃 유형 및 pNFS 서버 구현에 따라 다릅니다. 예를 들어, 일부 메타데이터 서버는 파일의 현재 길이를 초과하는 파일 범위에 대한 요청을 받을 때 안정적인 저장소를 사전 할당해야 할 수 있습니다. loga\_minlength가 0이고 loga\_length가 0보다 큰 경우 이는 클라이언트가 선호하는 레이아웃 범위를 메타데이터 서버에 알려줍니다. loga\_length와 loga\_minlength가 모두 0이면 클라이언트는 지정된 값 loga\_offset보다 작지 않은 범위의 끝 오프셋과 loga\_offset 이하의 시작 오프셋을 사용하여 모든 길이의 레이아웃을 원한다는 것을 나타냅니다. 메타데이터 서버에 즉시 사용 가능한 레이아웃이 없으면 NFS4ERR\_LAYOUTTRYLATER를 반환해야 합니다.\(MUST\)

\* loga\_offset과 loga\_minlength의 합이 1을 초과하는 경우

- NFS4\_UINT64\_MAX, loga\_minlength가 NFS4\_UINT64\_MAX가 아닌 경우 NFS4ERR\_INVAL 오류가 발생해야 합니다.\(MUST\)

\* loga\_offset과 loga\_length의 합이 NFS4\_UINT64\_MAX를 초과하고 loga\_length가 NFS4\_UINT64\_MAX가 아닌 경우 NFS4ERR\_INVAL 오류가 발생해야 합니다.\(MUST\)

메타데이터 서버는 loga\_offset, loga\_minlength 및 loga\_offset에 대해 위의 확인을 수행한 후 표 22의 규칙에 따라 레이아웃을 반환해야 합니다.\(MUST\)

loga\_minlength를 기반으로 허용되는 레이아웃입니다. 참고: u64m = NFS4\_UINT64\_MAX; a\_off = loga\_offset; a\_minlen = loga\_minlength.

```text
   +===========+============+==========+==========+===================+
   | Layout    | Layout     | Layout   | Layout   | Layout length of  |
   | iomode of | a_minlen   | iomode   | offset   | reply             |
   | request   | of request | of reply | of reply |                   |
   +===========+============+==========+==========+===================+
   | _READ     | u64m       | MAY be   | MUST be  | MUST be >= file   |
   |           |            | _READ    | <= a_off | length - layout   |
   |           |            |          |          | offset            |
   +-----------+------------+----------+----------+-------------------+
   | _READ     | u64m       | MAY be   | MUST be  | MUST be u64m      |
   |           |            | _RW      | <= a_off |                   |
   +-----------+------------+----------+----------+-------------------+
   | _READ     | > 0 and <  | MAY be   | MUST be  | MUST be >=        |
   |           | u64m       | _READ    | <= a_off | MIN(file length,  |
   |           |            |          |          | a_minlen + a_off) |
   |           |            |          |          | - layout offset   |
   +-----------+------------+----------+----------+-------------------+
   | _READ     | > 0 and <  | MAY be   | MUST be  | MUST be >= a_off  |
   |           | u64m       | _RW      | <= a_off | - layout offset + |
   |           |            |          |          | a_minlen          |
   +-----------+------------+----------+----------+-------------------+
   | _READ     | 0          | MAY be   | MUST be  | MUST be > 0       |
   |           |            | _READ    | <= a_off |                   |
   +-----------+------------+----------+----------+-------------------+
   | _READ     | 0          | MAY be   | MUST be  | MUST be > 0       |
   |           |            | _RW      | <= a_off |                   |
   +-----------+------------+----------+----------+-------------------+
   | _RW       | u64m       | MUST be  | MUST be  | MUST be u64m      |
   |           |            | _RW      | <= a_off |                   |
   +-----------+------------+----------+----------+-------------------+
   | _RW       | > 0 and <  | MUST be  | MUST be  | MUST be >= a_off  |
   |           | u64m       | _RW      | <= a_off | - layout offset + |
   |           |            |          |          | a_minlen          |
   +-----------+------------+----------+----------+-------------------+
   | _RW       | 0          | MUST be  | MUST be  | MUST be > 0       |
   |           |            | _RW      | <= a_off |                   |
   +-----------+------------+----------+----------+-------------------+

                                 Table 22
```

loga\_minlength가 0이 아니고 메타데이터 서버가 표 22의 규칙에 따라 레이아웃을 반환할 수 없는 경우 메타데이터 서버는 NFS4ERR\_BADLAYOUT 오류를 반환해야 합니다. loga\_minlength가 0이고 메타데이터 서버가 표 22의 규칙에 따라 레이아웃을 반환할 수 없거나 반환하지 않을 경우 메타데이터 서버는 NFS4ERR\_LAYOUTTRYLATER 오류를 반환해야 합니다. loga\_length가 loga\_minlength보다 크거나 0과 같다고 가정하면 메타데이터 서버는 표 23의 규칙에 따라 레이아웃을 반환해야 합니다.\(MUST, MUST, SHOULD\)

loga\_length를 기반으로 한 원하는 레이아웃입니다. 표 22의 규칙을 먼저 적용해야 합니다. 참고: u64m = NFS4\_UINT64\_MAX; a\_off = loga\_offset; a\_len = loga\_length.\(MUST\)

```text
    +===============+==========+==========+==========+================+
    | Layout iomode | Layout   | Layout   | Layout   | Layout length  |
    | of request    | a_len of | iomode   | offset   | of reply       |
    |               | request  | of reply | of reply |                |
    +===============+==========+==========+==========+================+
    | _READ         | u64m     | MAY be   | MUST be  | SHOULD be u64m |
    |               |          | _READ    | <= a_off |                |
    +---------------+----------+----------+----------+----------------+
    | _READ         | u64m     | MAY be   | MUST be  | SHOULD be u64m |
    |               |          | _RW      | <= a_off |                |
    +---------------+----------+----------+----------+----------------+
    | _READ         | > 0 and  | MAY be   | MUST be  | SHOULD be >=   |
    |               | < u64m   | _READ    | <= a_off | a_off - layout |
    |               |          |          |          | offset + a_len |
    +---------------+----------+----------+----------+----------------+
    | _READ         | > 0 and  | MAY be   | MUST be  | SHOULD be >=   |
    |               | < u64m   | _RW      | <= a_off | a_off - layout |
    |               |          |          |          | offset + a_len |
    +---------------+----------+----------+----------+----------------+
    | _READ         | 0        | MAY be   | MUST be  | SHOULD be >    |
    |               |          | _READ    | <= a_off | a_off - layout |
    |               |          |          |          | offset         |
    +---------------+----------+----------+----------+----------------+
    | _READ         | 0        | MAY be   | MUST be  | SHOULD be >    |
    |               |          | _READ    | <= a_off | a_off - layout |
    |               |          |          |          | offset         |
    +---------------+----------+----------+----------+----------------+
    | _RW           | u64m     | MUST be  | MUST be  | SHOULD be u64m |
    |               |          | _RW      | <= a_off |                |
    +---------------+----------+----------+----------+----------------+
    | _RW           | > 0 and  | MUST be  | MUST be  | SHOULD be >=   |
    |               | < u64m   | _RW      | <= a_off | a_off - layout |
    |               |          |          |          | offset + a_len |
    +---------------+----------+----------+----------+----------------+
    | _RW           | 0        | MUST be  | MUST be  | SHOULD be >    |
    |               |          | _RW      | <= a_off | a_off - layout |
    |               |          |          |          | offset         |
    +---------------+----------+----------+----------+----------------+

                                  Table 23
```

loga\_stateid 필드는 유효한 stateid를 지정합니다. 클라이언트가 현재 레이아웃을 보유하고 있지 않은 경우 loga\_stateid 필드는 해당하는 유효한 열기, 바이트 범위 잠금 또는 위임 상태 ID를 반영하는 상태 ID를 나타냅니다. 클라이언트가 파일에 레이아웃을 보관하면 loga\_stateid 필드는 이전 LAYOUTGET 또는 LAYOUTRETURN 작업에서 반환되거나 CB\_LAYOUTRECALL 작업에서 제공되는 상태 ID여야 합니다\(섹션 12.5.3 참조\).\(MUST\)

loga\_maxcount 필드는 클라이언트가 처리할 수 있는 최대 레이아웃 크기\(바이트\)를 지정합니다. 레이아웃 구조의 크기가 maxcount에 지정된 크기를 초과하는 경우 메타데이터 서버는 NFS4ERR\_TOOSMALL 오류를 반환합니다.

반환된 레이아웃은 각 요소가 레이아웃4 유형인 배열 logr\_layout으로 표현됩니다. 파일에 단일 스트라이프 패턴이 있는 경우 logr\_layout에는 항목이 하나만 포함되어야 합니다. 그렇지 않고 요청된 범위가 둘 이상의 스트라이프 패턴과 겹치는 경우 logr\_layout에는 필요한 수의 항목이 포함됩니다. logr\_layout의 요소는 각 요소의 lo\_offset 필드 값의 오름차순으로 정렬되어야 합니다. logr\_layout의 두 연속 요소 사이의 범위에는 간격이나 겹침이 없어야 합니다\(MUST\). logr\_layout의 각 요소에 있는 lo\_iomode 필드는 동일해야 합니다.\(SHOULD, MUST, MUST, MUST\)

표 22와 표 23은 모두 반환된 레이아웃 iomode, 오프셋 및 길이를 참조합니다. 반환된 레이아웃은 logr\_layout 배열에 인코딩되어 있으므로 추가 설명이 필요합니다.

iomode 표 22 및 표 23에 나열된 반환된 레이아웃 iomode의 값은 logr\_layout의 각 요소에 있는 lo\_iomode 필드의 값과 동일합니다. 표 22 및 표 23에 표시된 것처럼 메타데이터 서버는 요청된 iomode\(요청의 loga\_iomode 필드\)와 다른 lo\_iomode의 레이아웃을 반환할 수 있습니다. 그렇게 하는 경우 lo\_iomode가 요청된 loga\_iomode보다 더 허용적인지 확인해야 합니다. 예를 들어, 이 동작을 통해 구현은 레이아웃 유형별 프로토콜의 제한 내에서 재량에 따라 LAYOUTIOMODE4\_READ 요청을 LAYOUTIOMODE4\_RW 요청으로 업그레이드할 수 있습니다. LAYOUTIOMODE4\_READ 또는 LAYOUTIOMODE4\_RW의 lo\_iomode가 반환되어야 합니다.\(MAY, MUST, MUST\)

offset 표 22 및 표 23에 나열된 반환된 레이아웃 오프셋 값은 항상 첫 번째 요소 logr\_layout의 lo\_offset 필드와 같습니다.

length 반환된 레이아웃 길이 값을 설정할 때 특수 레이아웃 길이 값 NFS4\_UINT64\_MAX가 포함될 가능성으로 인해 상황이 복잡해집니다. N 요소의 logr\_layout 배열의 경우 첫 번째 N-1 요소의 lo\_length 필드는 NFS4\_UINT64\_MAX가 되어서는 안 됩니다. logr\_layout의 마지막 요소의 lo\_length 필드는 다음 목록에 설명된 대로 일부 조건에서 NFS4\_UINT64\_MAX일 수 있습니다.\(MUST NOT\)

- \* 표 22의 적용 가능한 규칙에 따라 메타데이터 서버가 NFS4\_UINT64\_MAX 길이의 레이아웃을 반환해야 한다고 명시되어 있는 경우 logr\_layout의 마지막 요소의 lo\_length 필드는 NFS4\_UINT64\_MAX여야 합니다.\(MUST\)

- \* 표 22의 적용 가능한 규칙에 메타데이터 서버가 NFS4\_UINT64\_MAX 길이의 레이아웃을 반환해서는 안 된다고 명시된 경우 logr\_layout의 마지막 요소의 lo\_length 필드는 NFS4\_UINT64\_MAX가 되어서는 안 됩니다.\(MUST NOT\)

- \* 표 23의 적용 가능한 규칙에 따라 메타데이터 서버가 NFS4\_UINT64\_MAX 길이의 레이아웃을 반환해야 한다고 명시되어 있는 경우 logr\_layout의 마지막 요소의 lo\_length 필드는 NFS4\_UINT64\_MAX여야 합니다.\(SHOULD\)

- \* 표 22 및 표 23의 반환된 레이아웃 길이 값이 NFS4\_UINT64\_MAX가 아닌 경우 반환된 레이아웃 길이는 logr\_layout의 각 요소의 lo\_length 필드의 합과 같습니다.

logr\_return\_on\_close 결과 필드는 파일을 닫기 전에 레이아웃을 반환하라는 지시문입니다. 메타데이터 서버가 이 반환 값을 TRUE로 설정하면 클라이언트가 닫기 전에 레이아웃을 반환하지 못하는 경우 레이아웃을 회수할 준비를 해야 합니다. 파일을 닫기 전에 레이아웃을 반환해야 하는 메타데이터 서버의 경우 이 반환 값을 사용하여 원하는 동작을 클라이언트에 전달할 수 있으므로 클라이언트와 메타데이터 서버의 상호 작용에서 추가 단계를 한 단계 제거할 수 있습니다.\(MUST\)

logr\_stateid stateid는 후속 레이아웃 관련 작업에 사용하기 위해 클라이언트에 반환됩니다. 추가 논의 및 요구 사항은 섹션 8.2, 12.5.3 및 12.5.5.2를 참조하십시오.

반환된 레이아웃\(lo\_content\)의 형식은 레이아웃 유형에 따라 다릅니다. 메타데이터 서버\(logr\_layout\)가 반환한 레이아웃 배열의 각 요소에 대한 레이아웃 유형\(lo\_content.loc\_type\)의 값은 클라이언트가 지정한 loga\_layout\_type과 같아야 합니다. 동일하지 않은 경우 클라이언트는 응답을 유효하지 않은 것으로 무시하고 클라이언트가 반환된 레이아웃 유형을 지원하더라도 메타데이터 서버가 오류를 반환한 것처럼 동작해야 합니다.\(MUST, SHOULD\)

요청된 파일이나 포함된 파일 시스템 모두 레이아웃을 지원하지 않는 경우 메타데이터 서버는 NFS4ERR\_LAYOUTUNAVAILABLE을 반환해야 합니다. 레이아웃 유형이 지원되지 않는 경우 메타데이터 서버는 NFS4ERR\_UNKNOWN\_LAYOUTTYPE을 반환해야 합니다. 레이아웃이 지원되지만 클라이언트가 제공한 레이아웃 ID와 일치하는 레이아웃이 없는 경우 메타데이터 서버는 NFS4ERR\_BADLAYOUT을 반환해야 합니다. 잘못된 loga\_iomode가 지정되거나 LAYOUTIOMODE4\_ANY의 loga\_iomode가 지정된 경우 메타데이터 서버는 NFS4ERR\_BADIOMODE를 반환해야 합니다.\(MUST, MUST, MUST, MUST\)

일시적인 조건\(예: 파일 공유로 인해 레이아웃이 금지됨\)으로 인해 파일의 레이아웃을 사용할 수 없는 경우 메타데이터 서버는 NFS4ERR\_LAYOUTTRYLATER를 반환해야 합니다.\(MUST\)

중복되는 레이아웃 호출로 인해 레이아웃 요청이 거부되는 경우 메타데이터 서버는 NFS4ERR\_RECALLCONFLICT를 반환해야 합니다. 자세한 내용은 섹션 12.5.5.2를 참조하세요.\(MUST\)

레이아웃이 파일에 유지된 필수 바이트 범위 잠금과 충돌하고 저장 장치에 레이아웃 제한을 통하는 것 외에 필수 잠금을 시행하는 방법이 없는 경우 메타데이터 서버는 NFS4ERR\_LOCKED를 반환해야 합니다.\(SHOULD\)

클라이언트가 loga\_signal\_layout\_avail을 TRUE로 설정하면 리소스 소진으로 인해 레이아웃을 얻을 수 없는 경우 레이아웃에 대한 "원함"을 클라이언트에 등록합니다. 메타데이터 서버가 "원함"을 지원하고 이를 존중하는 경우 결과는 logr\_will\_signal\_layout\_avail이 TRUE로 설정됩니다. 그렇다면 클라이언트는 CB\_RECALLABLE\_OBJ\_AVAIL 작업이 레이아웃을 사용할 수 있음을 나타낼 것으로 예상해야 합니다.

성공하면 현재 파일 핸들은 해당 값을 유지하고 현재 stateid는 결과에 반환된 값과 일치하도록 업데이트됩니다.

---
#### **18.43.4.  IMPLEMENTATION**

일반적으로 LAYOUTGET은 OPEN 작업 후 COMPOUND 요청의 일부로 호출되며 클라이언트가 파일에 대한 위치 정보를 갖게 됩니다. 이를 위해서는 OPEN에 의해 ​​설정된 현재 stateid를 사용하도록 메타데이터 서버에 지시하는 특별한 stateid로 loga\_stateid를 설정해야 합니다\(섹션 16.2.3.1.2 참조\). 클라이언트는 여러 OPEN에 걸쳐 레이아웃을 보유할 수도 있습니다. 클라이언트는 메타데이터 서버가 반환할 레이아웃 종류를 제한하는 레이아웃 유형을 지정합니다. 이렇게 하면 메타데이터 서버가 클라이언트에서 사용할 수 없는 레이아웃을 부여하는 것을 방지할 수 있습니다.

표 22 및 표 23에서 알 수 있듯이 LAYOUTGET 사양은 pNFS 클라이언트와 서버에 상당한 유연성을 허용합니다. pNFS 클라이언트는 LAYOUTGET을 보내기 위해 여러 가지 전략을 사용할 수 있습니다. 몇 가지 예는 다음과 같습니다.

\* 동일한 COMPOUND 요청에서 LAYOUTGET 앞에 OPEN이 있고 OPEN이 OPEN4\_SHARE\_ACCESS\_READ 액세스를 요청하는 경우 클라이언트는 loga\_offset이 0으로 설정되고 loga\_minlength가 0으로 설정되고 loga\_length가 NFS4\_UINT64\_MAX로 설정된 \_READ 레이아웃을 요청하도록 선택할 수 있습니다. 파일에 공간이 할당되어 있고 해당 공간이 하나 이상의 저장 장치에 스트라이프되어 있고 충돌하는 레이아웃이 없거나 충돌하는 레이아웃의 개념이 pNFS 서버의 레이아웃 유형이나 구현에 적용되지 않는 경우 메타데이터 서버는 NFS4\_UINT64\_MAX가 아닌 경우 시작 오프셋이 0이고 길이가 파일 길이와 동일한 레이아웃을 반환할 수 있습니다. 파일 길이가 pNFS 서버 스트라이프 너비의 배수가 아닌 경우\(정식 정의는 섹션 13.2 참조\) 메타데이터 서버는 반환된 레이아웃 길이를 반올림할 수 있습니다.

\* 동일한 COMPOUND 요청에서 LAYOUTGET 앞에 OPEN이 있고 OPEN이 OPEN4\_SHARE\_ACCESS\_WRITE 액세스를 요청하고 파일을 자르지 않는 경우 클라이언트는 loga\_offset이 0으로 설정되고 loga\_minlength가 0으로 설정되고 loga\_length가 0으로 설정된 \_RW 레이아웃을 요청할 수 있습니다. 파일의 현재 길이\(알려진 경우\) 또는 NFS4\_UINT64\_MAX. 이전 사례와 마찬가지로 일부 조건에서는 메타데이터 서버가 파일의 전체 길이 이상을 포괄하는 레이아웃을 반환할 수 있습니다.

\* 이 전략은 위와 같지만 OPEN 시 파일이 잘립니다. 이 경우 클라이언트는 오프셋 0에서 파일에 쓸 것이라고 예상할 수 있으므로 loga\_offset 및 loga\_minlength는 0으로 설정되고 loga\_length는 Threshold4\_write\_iosize 값으로 설정됩니다. 메타데이터 서버는 길이가 최소한 Threshold4\_write\_iosize만큼인 오프셋 0에서 레이아웃을 반환할 수 있습니다.

\* 클라이언트의 프로세스는 오프셋 10000에서 길이 50000을 읽는 요청을 호출합니다. 클라이언트는 버퍼링된 I/O를 사용하고 있으며 버퍼 크기는 4096바이트입니다. 클라이언트는 프로세스의 요청을 오프셋 8192에서 시작하는 일련의 READ 요청으로 매핑하려고 합니다. 끝 오프셋은 10000 + 50000 = 60000보다 높아야 하며 4096의 배수인 다음 오프셋은 61440입니다. 차이점 61440과 레이아웃의 시작 오프셋 사이는 53248\(4096과 15의 곱\)입니다. Threshold4\_read\_iosize의 값이 53248보다 작으므로 클라이언트는 loga\_offset을 8192로 설정하고 loga\_minlength를 53248로 설정하고 loga\_length를 파일 길이\(알려진 경우\)에서 8192를 뺀 값 또는 NFS4\_UINT64\_MAX\(파일 길이를 알 수 없는 경우\)로 설정하여 LAYOUTGET 요청을 보냅니다. \). 이 LAYOUTGET 요청은 메타데이터 서버의 임계값을 초과하므로 초기 오프셋이 0이고 끝 오프셋이 최소 8192 + 53248 - 1 = 61439인 레이아웃을 허용하지만 스트라이프 너비에 정렬된 오프셋이 있는 레이아웃을 허용하는 것이 좋습니다. 및 스트라이프 너비의 배수인 길이.

\* 이 전략은 위와 같지만 클라이언트는 버퍼링된 I/O를 사용하지 않고 대신 모든 내부 I/O 요청이 서버로 직접 전송됩니다. LAYOUTGET 요청에는 loga\_offset이 10000이고 loga\_minlength가 50000으로 설정되어 있습니다. loga\_length 값은 파일 길이로 설정됩니다. 메타데이터 서버는 요청된 범위와 완전히 겹치는 레이아웃을 자유롭게 반환할 수 있으며, 시작 오프셋과 길이는 스트라이프 너비에 맞춰 정렬됩니다.

\* 다시 클라이언트의 프로세스가 오프셋 10000에서 길이 50000\(즉, 시작 오프셋이 10000이고 끝 오프셋이 69999인 범위\)에 대한 읽기 요청을 호출하고 버퍼링된 I/O가 사용 중입니다. 클라이언트는 서버가 전체 I/O 범위에 대한 레이아웃을 반환하지 못할 수도 있다고 예상합니다. 클라이언트는 프로세스의 요청을 오프셋 8192에서 시작하는 일련의 13개 READ 요청으로 매핑하려고 합니다. 각 요청의 길이는 4096이고 총 길이는 53248\(13 \* 4096과 동일\)입니다. 이 요청에는 클라이언트 프로세스가 원하는 범위가 완전히 포함됩니다. 읽다. Threshold4\_read\_iosize의 값은 4096이므로 클라이언트가 여러 LAYOUTGET 작업을 사용하여 일련의 READ를 완료하는 것이 실용적이고 합리적입니다. 클라이언트는 loga\_offset을 8192로 설정하고 loga\_minlength를 4096으로 설정하고 loga\_length를 53248 이상으로 설정하여 LAYOUTGET 요청을 보냅니다. 서버는 초기 오프셋이 0이고 끝 오프셋이 최소 8192 + 4096 - 1 = 12287인 레이아웃을 허용하지만 바람직하게는 스트라이프 너비에 정렬된 오프셋과 길이의 배수인 레이아웃을 사용하는 것이 좋습니다. 줄무늬 너비. 이를 통해 클라이언트는 앞으로 진행할 수 있으며 나머지 범위에 대해 더 많은 LAYOUTGET 작업을 보낼 수 있습니다.

\* NFS 클라이언트는 순차 읽기 패턴을 감지하여 현재 또는 보류 중인 읽기 요청보다 훨씬 뛰어난 LAYOUTGET 작업을 서버에 보냅니다. 서버도 마찬가지로 이 패턴을 감지하고 LAYOUTGET 요청을 승인할 수 있습니다. 클라이언트가 수신한 마지막 레이아웃 범위의 50%를 나타내는 파일의 오프셋에서 읽으면 레이아웃을 기다리는 I/O 지연을 방지하기 위해 클라이언트는 오프셋에서 더 많은 작업을 보냅니다. 수신된 마지막 레이아웃의 50%를 나타내는 파일입니다. 클라이언트는 클라이언트에서 실행 중인 프로세스의 최근 요청 및/또는 읽기 요청의 바이트 범위보다 훨씬 앞선 바이트 범위의 레이아웃을 계속 요청합니다.

\* 이 전략은 위와 같지만, 클라이언트는 패턴 감지에 실패하지만 서버는 감지합니다. 다음에 메타데이터 서버가 LAYOUTGET을 가져올 때 loga\_minlength를 훨씬 초과하는 길이의 레이아웃을 반환합니다.

\* 클라이언트는 버퍼링된 I/O를 사용하고 있으며 처리할 뒷쓰기 대기열이 길고 순차 쓰기 패턴도 감지합니다. 대기 중인 write-behind의 범위와 파일러의 현재 길이를 초과하는 범위를 포함하여 훨씬 더 넓은 레이아웃에 대해 LAYOUTGET을 보냅니다. write-behind 큐가 최대 큐 길이의 50%에 도달하면 클라이언트는 계속해서 LAYOUTGET 작업을 보냅니다.

클라이언트가 특정 장치 ID를 참조하는 레이아웃을 획득하면 메타데이터 서버는 레이아웃이 반환되거나 취소될 때까지 장치 ID를 삭제해서는 안 됩니다.\(MUST NOT\)

CB\_NOTIFY\_DEVICEID는 LAYOUTGET과 경쟁할 수 있습니다. 한 가지 경합 시나리오는 LAYOUTGET이 클라이언트에 장치 주소 매핑이 없는 장치 ID를 반환하고 메타데이터 서버가 CB\_NOTIFY\_DEVICEID를 보내 장치 ID를 클라이언트 인식에 추가하는 동시에 클라이언트가 장치 ID에 대한 GEDEVICEINFO를 보내는 것입니다. 이 시나리오는 섹션 18.40.4에서 논의됩니다. 또 다른 시나리오는 클라이언트가 LAYOUTGET의 결과를 처리하기 전에 CB\_NOTIFY\_DEVICEID를 처리하는 것입니다. 클라이언트는 장치 ID에 대한 GEDEVICEINFO를 보냅니다. 클라이언트가 LAYOUTGET에서 결과를 받기 전에 GETDEVICEINFO의 결과가 수신되면 더 이상 경합이 발생하지 않습니다. LAYOUTGET의 결과가 GEDEVICEINFO의 결과보다 먼저 수신되면 클라이언트는 GEDEVICEINFO의 결과를 기다리거나 다른 결과를 보내 장치 ID에 대한 최신 장치 주소 매핑을 얻을 수 있습니다.

---
### **18.44.  Operation 51: LAYOUTRETURN - Release Layout Information**
---
#### **18.44.1.  ARGUMENT**

```text
   /* Constants used for LAYOUTRETURN and CB_LAYOUTRECALL */
   const LAYOUT4_RET_REC_FILE      = 1;
   const LAYOUT4_RET_REC_FSID      = 2;
   const LAYOUT4_RET_REC_ALL       = 3;

   enum layoutreturn_type4 {
           LAYOUTRETURN4_FILE = LAYOUT4_RET_REC_FILE,
           LAYOUTRETURN4_FSID = LAYOUT4_RET_REC_FSID,
           LAYOUTRETURN4_ALL  = LAYOUT4_RET_REC_ALL
   };

   struct layoutreturn_file4 {
           offset4         lrf_offset;
           length4         lrf_length;
           stateid4        lrf_stateid;
           /* layouttype4 specific data */
           opaque          lrf_body<>;
   };

   union layoutreturn4 switch(layoutreturn_type4 lr_returntype) {
           case LAYOUTRETURN4_FILE:
                   layoutreturn_file4      lr_layout;
           default:
                   void;
   };

   struct LAYOUTRETURN4args {
           /* CURRENT_FH: file */
           bool                    lora_reclaim;
           layouttype4             lora_layout_type;
           layoutiomode4           lora_iomode;
           layoutreturn4           lora_layoutreturn;
   };
```

---
#### **18.44.2.  RESULT**

```text
   union layoutreturn_stateid switch (bool lrs_present) {
   case TRUE:
           stateid4                lrs_stateid;
   case FALSE:
           void;
   };

   union LAYOUTRETURN4res switch (nfsstat4 lorr_status) {
   case NFS4_OK:
           layoutreturn_stateid    lorr_stateid;
   default:
           void;
   };
```

---
#### **18.44.3.  DESCRIPTION**

이 작업은 클라이언트 ID\(이전 SEQUENCE 작업의 세션 ID에서 파생됨\), lora\_layout\_type 및 lora\_iomode로 표시되는 하나 이상의 레이아웃을 클라이언트에서 서버로 반환합니다. lr\_returntype이 LAYOUTRETURN4\_FILE인 경우 반환된 레이아웃은 현재 파일 핸들, lrf\_offset, lrf\_length 및 lrf\_stateid로 추가로 식별됩니다. lrf\_length 필드가 NFS4\_UINT64\_MAX인 경우 lrf\_offset에서 시작하는 레이아웃의 모든 바이트가 반환됩니다. lr\_returntype이 LAYOUTRETURN4\_FSID인 경우 현재 파일 핸들을 사용하여 파일 시스템을 식별하고 클라이언트 ID와 일치하는 모든 레이아웃, 파일 시스템의 fsid, lora\_layout\_type 및 lora\_iomode가 반환됩니다. lr\_returntype이 LAYOUTRETURN4\_ALL이면 클라이언트 ID, lora\_layout\_type 및 lora\_iomode와 일치하는 모든 레이아웃이 반환되고 현재 파일 핸들은 사용되지 않습니다. 이 호출 후에 클라이언트는 반환된 레이아웃 및 관련 저장 프로토콜을 사용하여 파일 데이터에 액세스해서는 안 됩니다.\(MUST NOT\)

LAYOUTRETURN4\_FSID 또는 LAYOUTRETURN4\_ALL의 경우 지정된 레이아웃 세트가 비어 있으면 오류가 발생하지 않습니다. LAYOUTRETURN4\_FILE의 경우 이전에 LAYOUTGET으로 얻은 레이아웃의 하위 분할이거나 이전에 LAYOUTGET으로 얻은 여러 레이아웃의 조합이거나 이전에 LAYOUTGET으로 얻은 일부 레이아웃을 포함하는 조합인 경우에도 지정된 바이트 범위가 반환됩니다. 또는 그러한 레이아웃의 더 많은 하위 구분. 바이트 범위가 지정된 파일, 클라이언트 ID, 레이아웃 유형 및 모드에 대해 레이아웃이 유지되는 바이트를 지정하지 않으면 오류가 발생하지 않습니다. 레이아웃의 "대량" 반환에 대한 고려 사항은 섹션 12.5.5.2.1.5를 참조하세요.

반환되는 레이아웃은 CB\_LAYOUTRECALL에 지정된 레이아웃의 하위 집합 또는 상위 집합일 수 있습니다. 그러나 하위 집합인 경우 전체 회수 범위가 반환될 때까지 회수가 완료되지 않습니다. 호출 범위는 LAYOUTRETURN4\_FILE의 경우, LAYOUTRETURN4\_FSID 사용 또는 LAYOUTRETURN4\_ALL 사용의 경우 바이트 범위를 나타냅니다. 모든 현재 레이아웃 범위가 이전에 개별적으로 반환된 경우에도 반환을 완료하려면 일치하는 범위가 있는 LAYOUTRETURN이 있어야 합니다.

모든 lr\_returntype 값에 대해 LAYOUTIOMODE4\_ANY의 iomode는 LAYOUTRETURN에 대한 다른 인수\(예: 클라이언트 ID, lora\_layout\_type, 현재 파일 핸들 및 범위 중 하나, 현재 파일 핸들에서 파생된 fsid 또는 LAYOUTRETURN4\_ALL\)와 일치하는 모든 레이아웃이 반환되도록 지정합니다.

lr\_returntype이 LAYOUTRETURN4\_FILE인 경우 클라이언트가 제공하는 lrf\_stateid는 이전 레이아웃 작업에서 반환된 레이아웃 상태 ID입니다. lrf\_stateid의 "seqid" 필드는 0이 되어서는 안 됩니다. 추가 논의 및 요구 사항은 섹션 8.2, 12.5.3 및 12.5.5.2를 참조하십시오.\(MUST NOT\)

레이아웃 또는 모든 레이아웃을 반환하더라도 저장 장치 ID와 저장 장치 주소의 매핑이 무효화되지는 않습니다. 매핑은 장치 ID 알림 콜백을 통해 특별히 변경되거나 삭제될 때까지 계속 적용됩니다. 물론 이전에 사용된 장치 ID를 참조하는 레이아웃이 남아 있지 않은 경우 서버는 알림 콜백 없이 장치 ID를 삭제할 수 있습니다. 이는 알림이 적용되지 않는 경우입니다.

lora\_reclaim 필드가 TRUE로 설정된 경우 클라이언트는 메타데이터 서버의 유예 기간 동안 메타데이터 서버를 다시 시작하기 전에 획득한 레이아웃을 반환하려고 시도합니다. 메타데이터 서버의 유예 기간 동안 획득한 레이아웃을 반환할 때 클라이언트는 lora\_reclaim 필드를 FALSE로 설정해야 합니다. lora\_reclaim 필드는 lr\_layoutreturn이 LAYOUTRETURN4\_FSID 또는 LAYOUTRETURN4\_ALL인 경우에도 FALSE로 설정되어야 합니다. 자세한 내용은 LAYOUTCOMMIT\(섹션 18.42\)을 참조하세요.\(MUST, MUST\)

레이아웃은 호출될 때 또는 자발적으로\(즉, 서버가 레이아웃을 호출하기 전\) 반환될 수 있습니다. 두 경우 모두 클라이언트는 레이아웃을 반환하기 전에 레이아웃 컨텍스트에서 변경된 상태를 저장 장치 또는 메타데이터 서버에 적절하게 전파해야 합니다.

클라이언트가 clora\_recall 필드의 lor\_recalltype 필드가 LAYOUTRECALL4\_FILE인 CB\_LAYOUTRECALL에 대한 응답으로 레이아웃을 반환하는 경우 클라이언트는 CB\_LAYOUTRECALL의 lor\_stateid 값을 lrf\_stateid 값으로 사용해야 합니다. 그렇지 않으면 logr\_stateid\(이전 LAYOUTGET 결과\) 또는 lorr\_stateid\(이전 LAYRETURN 결과\)를 사용해야 합니다. 이는 리콜이 전송된 시점\(레이아웃 상태 ID 전환 측면에서\)을 나타내기 위해 수행됩니다. 클라이언트는 정확한 lora\_recallstateid 값을 사용하고 stateid의 seqid를 0으로 설정해서는 안 됩니다. 그렇지 않으면 NFS4ERR\_BAD\_STATEID를 반환해야 합니다. 클라이언트가 이전 seqid를 사용하고 있고 서버가 클라이언트가 이전 seqid를 사용해서는 안 된다는 것을 알고 있는 경우 NFS4ERR\_OLD\_STATEID가 반환될 수 있습니다. 예를 들어, 클라이언트는 세션의 슬롯 1에서 seqid를 사용하고, 새 seqid로 응답을 받고, 슬롯을 사용하여 이전 seqid로 다른 요청을 보냅니다.\(MUST NOT\)

클라이언트가 적시에 레이아웃을 반환하지 못하는 경우 메타데이터 서버는 클라이언트가 레이아웃에서 참조하는 데이터에 액세스하지 못하도록 저장 장치와 함께 제어 프로토콜을 사용해야 합니다. 자세한 내용은 섹션 12.5.5를 참조하세요.\(SHOULD\)

메타데이터 서버의 유예 기간 이후 LAYOUTRETURN 요청이 lora\_reclaim 필드를 TRUE로 설정하면 NFS4ERR\_NO\_GRACE가 반환됩니다.

LAYOUTRETURN 요청이 lora\_reclaim 필드를 TRUE로 설정하고 lr\_returntype이 LAYOUTRETURN4\_FSID 또는 LAYOUTRETURN4\_ALL로 설정된 경우 NFS4ERR\_INVAL이 반환됩니다.

클라이언트가 lr\_returntype 필드를 LAYOUTRETURN4\_FILE로 설정하면 lrs\_stateid 필드는 이 작업 처리를 위해 업데이트된 레이아웃 상태 ID를 나타냅니다. 현재 stateid도 반환된 값과 일치하도록 업데이트됩니다. 현재 파일, 클라이언트 ID 및 레이아웃 유형에 대한 레이아웃의 마지막 바이트가 반환되고 LAYOUTRETURN 작업을 수행해야 하는 보류 중인 CB\_LAYOUTRECALL 작업이 남아 있지 않은 경우 lrs\_present는 FALSE여야 하며 stateid가 반환되지 않습니다. 또한 COMPOUND 요청의 현재 stateid는 모두 0인 특수 stateid로 설정됩니다\(섹션 16.2.3.1.2 참조\). 서버는 이후의 stateid 반환 작업에 의해 현재 stateid가 다시 설정될 때까지 해당 COMPOUND에서 현재 stateid의 추가 사용을 NFS4ERR\_BAD\_STATEID로 거부해야 합니다.\(MUST, MUST\)

성공하면 현재 파일 핸들이 해당 값을 유지합니다.

EXCHGID4\_FLAG\_BIND\_PRINC\_STATEID 기능이 클라이언트 ID에 설정된 경우\(18.35절 참조\), 서버는 주체, 보안 특성 및 적용 가능한 경우 레이아웃을 획득한 GSS 메커니즘 조합도 LAYOUTRETURN을 보내는 것일 것을 요구합니다. 주체에 대한 자격 증명을 더 이상 사용할 수 없는 경우 이는 불가능할 수 있습니다. LAYOUTRETURN의 작업 코드가 EXCHANGE\_ID의 spo\_must\_allow 결과에 설정된 경우 서버는 머신 자격 증명 또는 SSV 자격 증명\(섹션 18.35 참조\)이 LAYOUTRETURN을 보내는 것을 허용합니다.

---
#### **18.44.4.  IMPLEMENTATION**

CB\_LAYOUTRECALL 콜백에 대한 응답으로 최종 LAYOUTRETURN 작업은 교차하는 모든 미해결 LAYOUTRETURN 작업과 함께 직렬화되어야 합니다. 클라이언트가 일부 호출된 범위에 대한 레이아웃을 반환하는 동안 서버는 해당 범위의 상위 집합\(예: LAYOUTRECALL4\_ALL\)을 호출할 수 있습니다. 후자에 대한 최종 반환 작업은 이전 레이아웃 호출이 완료될 때까지 차단되어야 합니다.\(MUST\)

LAYOUTRETURN4\_FSID를 사용하여 파일 시스템의 모든 레이아웃을 반환하는 것은 일반적으로 해당 파일 시스템에 대한 CB\_LAYOUTRECALL에 대한 응답으로 최종 반환 작업으로 수행됩니다. 마찬가지로 LAYOUTRETURN4\_ALL은 모든 레이아웃에 대한 호출 콜백에 대한 응답으로 사용됩니다. 클라이언트가 이미 개별 LAYOUTRETURN 호출을 통해 일부 뛰어난 레이아웃을 반환했으며 LAYOUTRETURN4\_FSID 또는 LAYOUTRETURN4\_ALL에 대한 호출이 LAYOUTRETURN 시퀀스의 끝을 표시했을 가능성이 있습니다. 자세한 내용은 섹션 12.5.5.1을 참조하세요.

클라이언트가 특정 장치 ID를 참조하는 모든 레이아웃을 반환하면 서버는 장치 ID를 삭제할 수 있습니다.\(MAY\)

---
### **18.45.  Operation 52: SECINFO_NO_NAME - Get Security on Unnamed Object**
---
#### **18.45.1.  ARGUMENT**

```text
   enum secinfo_style4 {
           SECINFO_STYLE4_CURRENT_FH       = 0,
           SECINFO_STYLE4_PARENT           = 1
   };

   /* CURRENT_FH: object or child directory */
   typedef secinfo_style4 SECINFO_NO_NAME4args;
```

---
#### **18.45.2.  RESULT**

```text
   /* CURRENTFH: consumed if status is NFS4_OK */
   typedef SECINFO4res SECINFO_NO_NAME4res;
```

---
#### **18.45.3.  DESCRIPTION**

SECINFO 작업과 마찬가지로 SECINFO\_NO\_NAME은 클라이언트가 특정 파일 개체에 대한 유효한 RPC 인증 유형 목록을 얻는 데 사용됩니다. SECINFO와 달리 SECINFO\_NO\_NAME은 파일 핸들로 액세스하는 개체에만 작동합니다.

secinfo\_style4 열거형의 값에 따라 결정되는 SECINFO\_NO\_NAME에는 두 가지 스타일이 있습니다. SECINFO\_STYLE4\_CURRENT\_FH가 전달되면 SECINFO\_NO\_NAME은 현재 파일 핸들에 필요한 보안을 쿼리합니다. SECINFO\_STYLE4\_PARENT가 전달되면 SECINFO\_NO\_NAME은 현재 파일 핸들 상위 항목의 필수 보안을 쿼리합니다. 선택한 스타일이 SECINFO\_STYLE4\_PARENT인 경우 SECINFO는 상위 디렉터리에 대한 순회를 평가할 때 LOOKUPP에 사용되는 것과 동일한 액세스 방법을 적용해야 합니다. 따라서 요청자가 상위 LOOKUPP에 대한 적절한 액세스 권한이 없는 경우 SECINFO\_NO\_NAME은 동일한 방식으로 작동하고 NFS4ERR\_ACCESS를 반환해야 합니다.

PUTFH, PUTPUBFH, PUTROOTFH 또는 RESTOREFH가 NFS4ERR\_WRONGSEC를 반환하는 경우 클라이언트는 PUTFH, PUTPUBFH 또는 PUTROOTFH 바로 뒤에 SECINFO\_NO\_NAME, 스타일 SECINFO\_STYLE4\_CURRENT\_FH로 구성된 COMPOUND 요청을 보내 상황을 해결합니다. PUTFH, PUTROOTFH, PUTPUBFH 또는 RESTOREFH에서 반환되는 NFS4ERR\_WRONGSEC 오류 처리에 대한 지침은 섹션 2.6을 참조하세요.

SECINFO\_STYLE4\_PARENT가 지정되고 상위 디렉터리가 없는 경우 SECINFO\_NO\_NAME은 NFS4ERR\_NOENT를 반환해야 합니다.\(MUST\)

성공하면 현재 파일 핸들이 소비되고\(섹션 2.6.3.1.1.8 참조\), SECINFO\_NO\_NAME 이후의 다음 작업이 현재 파일 핸들을 사용하려고 하면 해당 작업은 NFS4ERR\_NOFILEHANDLE 상태로 실패합니다.

SECINFO\_NO\_NAME에 대한 다른 모든 내용은 SECINFO와 동일합니다. SECINFO\(섹션 18.29.3\)에 대한 토론을 참조하세요.

---
#### **18.45.4.  IMPLEMENTATION**

SECINFO\(섹션 18.29.4\)에 대한 토론을 참조하세요.

18.46. 작업 53: SEQUENCE - 프로시저별 순서 지정 및 제어 제공

---
#### **18.46.1.  ARGUMENT**

```text
   struct SEQUENCE4args {
           sessionid4     sa_sessionid;
           sequenceid4    sa_sequenceid;
           slotid4        sa_slotid;
           slotid4        sa_highest_slotid;
           bool           sa_cachethis;
   };
```

---
#### **18.46.2.  RESULT**

```text
   const SEQ4_STATUS_CB_PATH_DOWN                  = 0x00000001;
   const SEQ4_STATUS_CB_GSS_CONTEXTS_EXPIRING      = 0x00000002;
   const SEQ4_STATUS_CB_GSS_CONTEXTS_EXPIRED       = 0x00000004;
   const SEQ4_STATUS_EXPIRED_ALL_STATE_REVOKED     = 0x00000008;
   const SEQ4_STATUS_EXPIRED_SOME_STATE_REVOKED    = 0x00000010;
   const SEQ4_STATUS_ADMIN_STATE_REVOKED           = 0x00000020;
   const SEQ4_STATUS_RECALLABLE_STATE_REVOKED      = 0x00000040;
   const SEQ4_STATUS_LEASE_MOVED                   = 0x00000080;
   const SEQ4_STATUS_RESTART_RECLAIM_NEEDED        = 0x00000100;
   const SEQ4_STATUS_CB_PATH_DOWN_SESSION          = 0x00000200;
   const SEQ4_STATUS_BACKCHANNEL_FAULT             = 0x00000400;
   const SEQ4_STATUS_DEVID_CHANGED                 = 0x00000800;
   const SEQ4_STATUS_DEVID_DELETED                 = 0x00001000;

   struct SEQUENCE4resok {
           sessionid4      sr_sessionid;
           sequenceid4     sr_sequenceid;
           slotid4         sr_slotid;
           slotid4         sr_highest_slotid;
           slotid4         sr_target_highest_slotid;
           uint32_t        sr_status_flags;
   };

   union SEQUENCE4res switch (nfsstat4 sr_status) {
   case NFS4_OK:
           SEQUENCE4resok  sr_resok4;
   default:
           void;
   };
```

---
#### **18.46.3.  DESCRIPTION**

SEQUENCE 작업은 서버에서 세션 요청 제어 및 응답 캐시 의미를 구현하는 데 사용됩니다.

SEQUENCE는 그것이 나타나는 COMPOUND의 첫 번째 작업으로 나타나야 합니다. NFS4ERR\_SEQUENCE\_POS 오류는 COMPOUND의 첫 번째 위치를 벗어난 위치에서 발견되면 반환됩니다. SEQUENCE, BIND\_CONN\_TO\_SESSION, EXCHANGE\_ID, CREATE\_SESSION 및 DESTROY\_SESSION 이외의 작업은 COMPOUND의 첫 번째 작업으로 나타나서는 안 됩니다. 이러한 작업은 COMPOUND 시작 부분에 나타나는 경우 NFS4ERR\_OP\_NOT\_IN\_SESSION 오류를 발생시켜야 합니다.\(MUST, MUST NOT, MUST\)

CREATE\_SESSION 또는 BIND\_CONN\_TO\_SESSION을 통해 세션과 연결되지 않은 연결에서 SEQUENCE가 수신되고 연결 연결 적용이 활성화된 경우\(섹션 18.35 참조\) 서버는 NFS4ERR\_CONN\_NOT\_BOUND\_TO\_SESSION을 반환합니다.

sa\_sessionid 인수는 이 요청이 적용되는 세션을 식별합니다. sr\_sessionid 결과는 sa\_sessionid와 동일해야 합니다.\(MUST\)

sa\_slotid 인수는 요청에 대한 응답 캐시의 인덱스입니다. sa\_sequenceid 필드는 응답 캐시 항목\(슬롯\)에 대한 요청의 시퀀스 번호입니다. sr\_slotid 결과는 sa\_slotid와 동일해야 합니다. sr\_sequenceid 결과는 sa\_sequenceid와 동일해야 합니다.\(MUST, MUST\)

sa\_highest\_slotid 인수는 클라이언트에 미해결 요청이 있는 가장 높은 슬롯 ID입니다. 이는 sa\_slotid와 같을 수 있습니다. 서버는 두 개의 "highest\_slotid" 값\(sr\_highest\_slotid 및 sr\_target\_highest\_slotid\)을 반환합니다. 전자는 서버가 향후 SEQUENCE 작업에서 허용할 가장 높은 슬롯 ID이며 sa\_highest\_slotid 값보다 작아서는 안 됩니다\(단, 예외는 섹션 2.10.6.1 참조\). 후자는 서버가 향후 SEQUENCE 작업에서 클라이언트 사용을 선호하는 가장 높은 슬롯 ID입니다.\(SHOULD NOT\)

sa\_cachethis가 TRUE이면 클라이언트는 서버가 서버의 응답 캐시에 전체 응답을 캐시하도록 요청하는 것입니다. 따라서 서버는 응답을 캐시해야 합니다\(섹션 2.10.6.1.3 참조\). sa\_cachethis가 FALSE인 경우 서버는 응답을 캐시할 수 있습니다. 서버가 전체 응답을 캐시하지 않는 경우에도 지정된 슬롯 및 시퀀스 ID에서 요청을 실행했음을 기록해야 합니다.\(MUST, MAY, MUST\)

SEQUENCE 작업에 대한 응답에는 클라이언트의 잠금 상태 및 통신 경로와 관련된 정보를 클라이언트에 제공할 수 있는 상태 플래그\(sr\_status\_flags\) 단어가 포함되어 있습니다. 잠금 상태와 관련된 모든 상태 비트는 서버 재시작으로 인해 잠금 상태가 손실될 때\(세션이 재시작 후에도 지속되는 경우에도, 세션 지속성은 잠금 상태 지속성을 의미하지 않음\) 또는 새 클라이언트 인스턴스의 설정으로 인해 재설정될 수 있습니다.\(MAY\)

SEQ4\_STATUS\_CB\_PATH\_DOWN

- 설정된 경우 클라이언트에 클라이언트 ID와 연결된 세션에 대해 작동 가능한 백채널 경로가 없으므로 클라이언트가 경로를 다시 설정해야 함을 나타냅니다. 이 비트는 클라이언트 ID와 연결된 모든 세션에서 하나 이상의 백채널을 사용할 수 있을 때까지 클라이언트 ID와 연결된 모든 세션의 모든 SEQUENCE 응답에 설정된 상태로 유지됩니다. 클라이언트가 클라이언트 ID에 대한 백채널을 다시 설정하지 못하면 회수 가능한 상태가 취소됩니다.

SEQ4\_STATUS\_CB\_PATH\_DOWN\_SESSION

- 설정되면 세션에 작동 가능한 백채널이 없음을 나타냅니다. SEQ4\_STATUS\_CB\_PATH\_DOWN\_SESSION이 설정되고 SEQ4\_STATUS\_CB\_PATH\_DOWN이 설정되지 않는 데에는 두 가지 이유가 있습니다. 첫 번째는 세션에 특별히 적용되는 콜백 작업\(예: CB\_RECALL\_SLOT, 섹션 20.8 참조\)을 전송해야 한다는 것입니다. 두 번째는 서버가 콜백 작업을 보냈지만 응답하기 전에 연결이 끊어졌다는 것입니다. 서버는 클라이언트가 콜백 작업을 수신했는지 여부를 확신할 수 없으므로 요청 재시도 규칙에 따라 서버는 동일한 세션에서 콜백 작업을 재시도해야 합니다. SEQ4\_STATUS\_CB\_PATH\_DOWN\_SESSION 비트는 세션의 백채널에 대한 연결을 연결해야 함을 클라이언트에 표시합니다. 이 비트는 연결이 세션의 백채널과 연결될 때까지 세션의 모든 SEQUENCE 응답에 설정된 상태로 유지됩니다. 클라이언트가 세션에 대한 백채널을 다시 설정하지 못하면 회수 가능한 상태가 취소됩니다.\(MUST\)

SEQ4\_STATUS\_CB\_GSS\_CONTEXTS\_EXPIRING

- 설정된 경우 세션의 백채널에 할당된 모든 GSS 컨텍스트 또는 RPCSEC\_GSS 핸들이 임대 시간과 동일한 기간 내에 만료됨을 나타냅니다. 이 비트는 다음 중 하나 이상이 참일 때까지 모든 SEQUENCE 응답에 설정된 상태로 유지됩니다.

- \* 세션 백채널의 모든 SSV RPCSEC\_GSS 핸들이 삭제되었으며 SSV가 아닌 모든 GSS 컨텍스트가 만료되었습니다.

- \* 하나 이상의 SSV RPCSEC\_GSS 핸들이 백채널에 추가되었습니다.

```text
      *  The expiration time of at least one non-SSV GSS context of an
         RPCSEC_GSS handle is beyond the lease period from the current
         time (relative to the time of when a SEQUENCE response was
         sent)
```

SEQ4\_STATUS\_CB\_GSS\_CONTEXTS\_EXPIRED

- 설정된 경우 SSV가 아닌 모든 GSS 컨텍스트와 세션의 백채널에 할당된 모든 SSV RPCSEC\_GSS 핸들이 만료되었거나 삭제되었음을 나타냅니다. 이 비트는 세션의 백채널에 대해 만료되지 않은 SSV가 아닌 GSS 컨텍스트가 하나 이상 설정되거나 하나 이상의 SSV RPCSEC\_GSS 핸들이 백채널에 할당될 때까지 모든 SEQUENCE 응답에 설정된 상태로 유지됩니다.

SEQ4\_STATUS\_EXPIRED\_ALL\_STATE\_REVOKED

- 설정되면 임대가 만료되어 서버가 클라이언트의 모든 잠금 상태를 해제했음을 나타냅니다. 이 상태 비트는 FREE\_STATEID\(섹션 18.38 참조\)를 사용하거나 모든 세션을 삭제하여\(DESTROY\_SESSION을 통해\) 새 클라이언트 인스턴스를 설정함으로써 이러한 모든 잠금의 손실이 확인될 때까지 모든 SEQUENCE 응답에 대해 설정된 상태로 유지됩니다. DESTROY\_CLIENTID\), EXCHANGE\_ID 및 CREATE\_SESSION을 호출하여 새 클라이언트 ID를 설정합니다.

SEQ4\_STATUS\_EXPIRED\_SOME\_STATE\_REVOKED

- 설정된 경우 임대 기간 만료 후 다른 클라이언트의 LOCK 작업 충돌로 인해 클라이언트 잠금의 일부 하위 집합이 취소되었음을 나타냅니다. 이 상태 비트는 모든 잠금 손실이 FREE\_STATEID를 사용하여 확인될 때까지 모든 SEQUENCE 응답에 설정된 상태로 유지됩니다.

SEQ4\_STATUS\_ADMIN\_STATE\_REVOKED

- 설정된 경우 관리 조치로 인해 임대 기간이 만료되지 않은 채 하나 이상의 잠금이 취소되었음을 나타냅니다. 이 상태 비트는 모든 잠금 손실이 FREE\_STATEID를 사용하여 확인될 때까지 모든 SEQUENCE 응답에 설정된 상태로 유지됩니다.

SEQ4\_STATUS\_RECALLABLE\_STATE\_REVOKED

- 설정된 경우 클라이언트가 회수 시 해당 객체를 반환하지 못하여 임대 기간 만료 없이 하나 이상의 회수 가능 객체가 취소되었음을 나타냅니다. 이는 작동 중인 백채널이 없고 클라이언트가 다시 회수하지 못한 결과일 수 있습니다. SEQ4\_STATUS\_CB\_PATH\_DOWN, SEQ4\_STATUS\_CB\_PATH\_DOWN\_SESSION 또는 SEQ4\_STATUS\_CB\_GSS\_CONTEXTS\_EXPIRED 상태 플래그별로 백채널을 설정합니다. 이 상태 비트는 모든 잠금 손실이 FREE\_STATEID를 사용하여 확인될 때까지 모든 SEQUENCE 응답에 설정된 상태로 유지됩니다.

SEQ4\_STATUS\_LEASE\_MOVED

- 설정되면 임대 갱신 책임이 하나 이상의 새 서버로 이전되었음을 나타냅니다. 이 조건은 클라이언트가 NFS4ERR\_MOVED 오류를 수신하고 서버가 임대가 새 서버로 이동된 각 파일 시스템에 대한 액세스에 대한 fs\_locations 또는 fs\_locations\_info 속성에 대한 후속 GETATTR을 수신할 때까지 계속됩니다. 섹션 11.11.9.2를 참조하십시오.

SEQ4\_STATUS\_RESTART\_RECLAIM\_NEEDED

- 설정되면 서버 다시 시작으로 인해 클라이언트가 잠금 상태를 회복해야 함을 나타냅니다. 클라이언트가 전역 RECLAIM\_COMPLETE\(섹션 18.51\)를 보낼 때까지 모든 SEQUENCE 작업은 SEQ4\_STATUS\_RESTART\_RECLAIM\_NEEDED를 반환합니다.

SEQ4\_STATUS\_BACKCHANNEL\_FAULT

- 서버에 백채널에서 복구할 수 없는 오류가 발생했습니다\(예: 백채널에 있는 슬롯의 시퀀스 ID 추적이 손실됨\). 클라이언트는 세션의 전면 채널에서 추가 요청 전송을 중지하고 모든 미해결 요청이 전면 및 후면 채널에서 완료될 때까지 기다린 다음 세션을 삭제해야 합니다.\(MUST\)

SEQ4\_STATUS\_DEVID\_CHANGED

- 클라이언트가 장치 ID 알림을 사용하고 있으며 서버가 클라이언트가 보유한 장치 ID 매핑을 변경했습니다. 이 플래그는 클라이언트가 GEDEVICEINFO를 사용하여 새 매핑을 얻을 때까지 계속 유지됩니다.

SEQ4\_STATUS\_DEVID\_DELETED

- 클라이언트가 장치 ID 알림을 사용하고 있으며 서버가 클라이언트가 보유한 장치 ID 매핑을 삭제했습니다. 이 플래그는 클라이언트가 gdia\_notify\_types 인수에 null 값이 있는 장치 ID에 GEDEVICEINFO를 보낼 때까지 유효합니다.

슬롯의 캐시된 시퀀스 ID와 관련된 sa\_sequenceid 인수 값은 세 가지 경우 중 하나에 속합니다.

\* 슬롯 ID에서 sa\_sequenceid와 서버의 캐시된 시퀀스 ID 간의 차이가 2 이상이거나 sa\_sequenceid가 캐시된 시퀀스 ID\(서명되지 않은 시퀀스 ID 값의 랩어라운드 고려\)보다 작은 경우 서버는 다음을 수행해야 합니다. NFS4ERR\_SEQ\_MISORDERED를 반환합니다.\(MUST\)

\* sa\_sequenceid와 캐시된 시퀀스 ID가 동일할 경우 재시도하며 서버는 응답 캐시에 기록된 내용으로 응답합니다. 임대는 아래 설명된 대로 갱신될 수 있습니다.

\* sa\_sequenceid가 캐시된 시퀀스 ID보다 하나 더 큰 경우\(랩어라운드 고려\) 이는 새 요청이며 슬롯의 시퀀스 ID가 증가됩니다. SEQUENCE 이후의 작업이 있는 경우 처리됩니다. 다른 작업이 없는 경우 유일한 다른 효과는 슬롯에 SEQUENCE 응답을 캐시하고 세션 활동을 유지하며 임대를 갱신하는 것입니다.

클라이언트가 완전히 다른 요청에 대해 슬롯 ID와 시퀀스 ID를 재사용하는 경우 서버는 해당 요청을 이미 실행한 작업을 재시도하는 것처럼 처리할 수 있습니다. 그러나 서버는 클라이언트의 불법 재사용을 감지하고 NFS4ERR\_SEQ\_FALSE\_RETRY를 반환할 수 있습니다.\(MAY, MAY\)

SEQUENCE가 오류를 반환하는 경우 슬롯 상태\(시퀀스 ID, 캐시된 응답\)는 변경되어서는 안 되며 관련 임대는 갱신되어서도 안 됩니다.\(MUST NOT\)

SEQUENCE가 NFS4\_OK를 반환하면 SEQ4\_STATUS\_EXPIRED\_ALL\_STATE\_REVOKED가 sr\_status\_flags에 반환되는 경우를 제외하고 관련 임대를 갱신해야 합니다\(섹션 8.3 참조\).\(MUST\)

---
#### **18.46.4.  IMPLEMENTATION**

서버는 stateid를 인수 및/또는 결과로 사용하는 SEQUENCE를 따르는 모든 작업의 ​​유효성을 검사하기 위해 세션 ID와 클라이언트 ID의 매핑을 유지해야 합니다.\(MUST\)

클라이언트가 지속적 세션을 설정하면 서버를 다시 시작한 후 수신된 SEQUENCE에서 서버를 다시 시작하기 전에 지속적 응답 캐시에 수행되고 기록된 요청이 발생할 수 있습니다. 이 경우 SEQUENCE는 성공적으로 처리되지만 이전에 수행 및 기록되지 않은 요청은 NFS4ERR\_DEADSESSION으로 거부됩니다.

서버를 다시 시작하기 전에 COMPOUND 내에서 어떤 작업이 성공적으로 수행되었는지에 따라 이러한 작업에도 서버 응답 캐시에서 응답이 전송됩니다. 이러한 작업이 잠금 상태를 설정하면 논리적으로 이러한 작업 후에 발생한 서버 재시작으로 인해 해당 상태가 제거되었더라도 이전 서버 인스턴스와 이전 클라이언트 ID에 잠금 상태가 적용됩니다. 부분적으로 실행된 COMPOUND의 경우, 처리가 이전 서버 인스턴스에서 처리되지 않은 작업에 도달하여 이 작업이 새로운 작업이 되어 기존 세션에서는 수행할 수 없게 될 수 있습니다. 이 경우 해당 작업에서 NFS4ERR\_DEADSESSION이 반환됩니다.

---
### **18.47.  Operation 54: SET_SSV - Update SSV for a Client ID**
---
#### **18.47.1.  ARGUMENT**

```text
   struct ssa_digest_input4 {
           SEQUENCE4args sdi_seqargs;
   };

   struct SET_SSV4args {
           opaque          ssa_ssv<>;
           opaque          ssa_digest<>;
   };
```

---
#### **18.47.2.  RESULT**

```text
   struct ssr_digest_input4 {
           SEQUENCE4res sdi_seqres;
   };

   struct SET_SSV4resok {
           opaque          ssr_digest<>;
   };

   union SET_SSV4res switch (nfsstat4 ssr_status) {
   case NFS4_OK:
           SET_SSV4resok   ssr_resok4;
   default:
           void;
   };
```

---
#### **18.47.3.  DESCRIPTION**

```text
   This operation is used to update the SSV for a client ID.  Before
   SET_SSV is called the first time on a client ID, the SSV is zero.
   The SSV is the key used for the SSV GSS mechanism (Section 2.10.9)
```

SET\_SSV 앞에는 동일한 COMPOUND의 SEQUENCE 작업이 와야 합니다. 클라이언트 ID가 생성될 때 클라이언트가 SP4\_SSV 상태 보호를 선택하지 않은 경우에는 사용하면 안 됩니다\(섹션 18.35 참조\). 이 경우 서버는 NFS4ERR\_INVAL을 반환합니다.\(MUST, MUST NOT\)

ssa\_digest 필드는 SSV4\_SUBKEY\_MIC\_I2T에서 파생된 하위 키와 현재 SSV를 키로 사용하여 HMAC\(RFC 2104 \[52\]\)의 출력으로 계산됩니다\(하위 키에 대한 설명은 섹션 2.10.9 참조\). 데이터 유형 ssa\_digest\_input4. sdi\_seqargs 필드는 SET\_SSV가 포함된 COMPOUND 프로시저에 대한 SEQUENCE 작업의 인수와 동일합니다.

ssa\_ssv 인수는 현재 SSV와 XOR되어 새 SSV를 생성합니다. ssa\_ssv 인수는 무작위로 생성되어야 합니다.\(SHOULD\)

응답에서 ssr\_digest는 SSV4\_SUBKEY\_MIC\_T2I에서 파생된 하위 키와 새 SSV를 키로 사용하고 데이터 유형 ssr\_digest\_input4의 XDR 인코딩 값을 사용하는 HMAC의 출력입니다. sdi\_seqres 필드는 SET\_SSV가 포함된 COMPOUND 프로시저에 대한 SEQUENCE 연산의 결과와 동일합니다.

섹션 18.35에 명시된 대로 클라이언트와 서버는 SSV의 여러 동시 버전을 유지할 수 있습니다. 클라이언트와 서버는 각각 내부 SSV 버전 번호를 유지해야 합니다. 이 버전 번호는 SET\_SSV가 서버에서 처음 실행되고 클라이언트가 첫 번째 SET\_SSV 응답을 받을 때 1로 설정됩니다. 이후의 각 SET\_SSV는 내부 SSV 버전 번호를 1씩 증가시킵니다. 이 버전 번호의 값은 SSV GSS 메커니즘 토큰의 smpt\_ssv\_seq, smt\_ssv\_seq, sspt\_ssv\_seq 및 ssct\_ssv\_seq 필드에 해당합니다\(섹션 2.10.9 참조\).\(MUST\)

---
#### **18.47.4.  IMPLEMENTATION**

서버가 ssa\_digest를 수신하면 클라이언트와 동일한 방식으로 다이제스트를 계산하고 이를 ssa\_digest와 비교하여 다이제스트를 확인해야 합니다. 서버가 다른 결과를 얻는 경우 이는 NFS4ERR\_BAD\_SESSION\_DIGEST 오류입니다. 이 오류는 SSV를 변경하는 동일한 클라이언트 ID의 다른 SET\_SSV로 인해 발생할 수 있습니다. 그렇다면 클라이언트는 새 SSV의 하위 키를 기반으로 다시 계산된 다이제스트와 함께 SET\_SSV 작업을 다시 전송하여 복구합니다. SET\_SSV 요청이 전송된 후 SET\_SSV 응답이 수신되기 전에 전송 연결이 삭제된 경우 클라이언트에 SSV의 클라이언트 ID와 연결된 세션과 연결된 연결이 더 이상 없는 경우 복구를 위해 특별히 고려해야 할 사항이 있습니다. 섹션 18.34.4를 참조하십시오.\(MUST\)

클라이언트는 이전 ssa\_ssv와 동일하거나 이전 또는 현재 SSV\(클라이언트 ID가 생성될 때 SSV가 0으로 초기화되므로 0과 동일한 ssa\_ssv 포함\)와 동일하지 않은 ssa\_ssv를 전송해서는 안 됩니다.\(SHOULD NOT\)

클라이언트는 RPCSEC\_GSS 개인 정보 보호와 함께 SET\_SSV를 보내야 합니다. 서버는 { SEQUENCE, SET\_SSV }가 있는 모든 COMPOUND에 대해 개인정보 보호와 함께 RPCSEC\_GSS를 지원해야 합니다.\(SHOULD, MUST\)

SET\_SSV의 목적은 비SSV 자격 증명에서 SSV를 시드하는 것이기 때문에 클라이언트는 SSV GSS 메커니즘의 자격 증명과 함께 SET\_SSV를 전송해서는 안 됩니다. 대신, SET\_SSV는 처음으로 클라이언트 ID에 액세스하는 사용자의 자격 증명과 함께 전송되어야 합니다\(섹션 2.10.8.3\). 그러나 클라이언트가 SSV 자격 증명과 함께 SET\_SSV를 보내는 경우 인수를 보호하는 다이제스트는 ssa\_ssv가 XOR되기 전 SSV 값을 사용하고 결과를 보호하는 다이제스트는 ssa\_ssv가 XOR된 후 SSV 값을 사용합니다.\(SHOULD NOT, SHOULD\)

---
### **18.48.  Operation 55: TEST_STATEID - Test Stateids for Validity**
---
#### **18.48.1.  ARGUMENT**

```text
   struct TEST_STATEID4args {
           stateid4        ts_stateids<>;
   };
```

---
#### **18.48.2.  RESULT**

```text
   struct TEST_STATEID4resok {
           nfsstat4        tsr_status_codes<>;
   };

   union TEST_STATEID4res switch (nfsstat4 tsr_status) {
       case NFS4_OK:
           TEST_STATEID4resok tsr_resok4;
       default:
           void;
   };
```

---
#### **18.48.3.  DESCRIPTION**

TEST\_STATEID 작업은 stateid 집합의 유효성을 확인하는 데 사용됩니다. 언제든지 사용할 수 있지만 클라이언트는 잠금 취소로 인해 하나 이상의 stateid가 무효화되었다는 표시를 받은 경우 반드시 이를 사용해야 합니다. 이는 SEQUENCE 작업이 다음 sr\_status\_flags 세트 중 하나와 함께 반환될 때 발생합니다.

```text
   *  SEQ4_STATUS_EXPIRED_SOME_STATE_REVOKED

   *  SEQ4_STATUS_EXPIRED_ADMIN_STATE_REVOKED

   *  SEQ4_STATUS_EXPIRED_RECALLABLE_STATE_REVOKED
```

클라이언트는 TEST\_STATEID를 한 번 이상 사용하여 상태 ID의 유효성을 테스트할 수 있습니다. TEST\_STATEID를 사용할 때마다 그러한 stateid의 큰 집합을 테스트할 수 있으며 COMPOUND 요청의 이전 stateid 문제가 후속 stateid 확인을 방해하는 것을 방지합니다. 복합 요청.

각 stateid에 대해 서버는 해당 stateid가 일반 작업에서 사용되는 경우 반환되는 상태 코드를 반환합니다. 이러한 상태 표시를 반환하는 것은 오류가 아니며 COMPOUND 처리가 종료되는 원인이 되지 않습니다. 여러 가지 예외를 제외하고 일반 작업과 마찬가지로 stateid의 유효성을 확인합니다.

\* stateid의 일반적인 사용과 마찬가지로 stateid 객체의 유형에 대한 확인은 없습니다.

\* 현재 파일핸들에 대한 참조가 없습니다.

\* 특수 상태 ID는 항상 유효하지 않은 것으로 간주됩니다\(오류 코드 NFS4ERR\_BAD\_STATEID가 발생함\).

모든 stateid는 현재 세션의 클라이언트와 연결된 것으로 해석됩니다. 클라이언트의 이전 인스턴스\(부실 상태 ID\)와의 가능한 연결은 고려되지 않습니다.

반환된 status\_code 배열의 유효한 상태 값은 NFS4ERR\_OK, NFS4ERR\_BAD\_STATEID, NFS4ERR\_OLD\_STATEID, NFS4ERR\_EXPIRED, NFS4ERR\_ADMIN\_REVOKED 및 NFS4ERR\_DELEG\_REVOKED입니다.

---
#### **18.48.4.  IMPLEMENTATION**

stateid 구조, 수명 및 유효성 검사에 대한 설명은 섹션 8.2.2 및 8.2.4를 참조하세요.

---
### **18.49.  Operation 56: WANT_DELEGATION - Request Delegation**
---
#### **18.49.1.  ARGUMENT**

```text
   union deleg_claim4 switch (open_claim_type4 dc_claim) {
   /*
    * No special rights to object.  Ordinary delegation
    * request of the specified object.  Object identified
    * by filehandle.
    */
   case CLAIM_FH: /* new to v4.1 */
           /* CURRENT_FH: object being delegated */
           void;

   /*
    * Right to file based on a delegation granted
    * to a previous boot instance of the client.
    * File is specified by filehandle.
    */
   case CLAIM_DELEG_PREV_FH: /* new to v4.1 */
           /* CURRENT_FH: object being delegated */
           void;

   /*
    * Right to the file established by an open previous
    * to server reboot.  File identified by filehandle.
    * Used during server reclaim grace period.
    */
   case CLAIM_PREVIOUS:
           /* CURRENT_FH: object being reclaimed */
           open_delegation_type4   dc_delegate_type;
   };

   struct WANT_DELEGATION4args {
           uint32_t        wda_want;
           deleg_claim4    wda_claim;
   };
```

---
#### **18.49.2.  RESULT**

```text
   union WANT_DELEGATION4res switch (nfsstat4 wdr_status) {
   case NFS4_OK:
           open_delegation4 wdr_resok4;
   default:
           void;
   };
```

---
#### **18.49.3.  DESCRIPTION**

이 설명이 특정 조건에 대한 특정 오류 코드의 반환을 요구하고 여러 조건이 적용되는 경우 서버는 필수 오류 코드 중 하나를 반환할 수 있습니다.\(MAY\)

이 작업을 통해 클라이언트는 다음을 수행할 수 있습니다.

\* 디렉토리를 제외한 모든 유형의 파일에 대한 위임을 받으세요.

\* 지정된 파일 객체에 대한 위임을 위해 "원함"을 등록하고 위임이 가능할 때 콜백을 통해 알림을 받습니다. 서버는 콜백을 통한 가용성 알림을 지원할 수 있습니다. 서버가 원하는 등록을 지원하지 않는 경우 이를 나타내는 오류를 반환해서는 안 되며, 대신 ond\_why를 WND4\_CONTENTION 또는 WND4\_RESOURCE로 설정하고 ond\_server\_will\_push\_deleg 또는 ond\_server\_will\_signal\_avail을 FALSE로 설정하여 반환해야 합니다. 서버가 콜백을 통해 클라이언트에 알릴 것이라고 표시하면 CB\_PUSH\_DELEG 작업을 사용하여 위임을 제공하거나 CB\_WANTS\_CANCELLED 작업을 보내 약속을 취소합니다.\(MAY, MUST NOT\)

\* 위임 희망을 취소합니다.

클라이언트는 wda\_want에서 OPEN4\_SHARE\_ACCESS\_READ를 설정해서는 안 되며 OPEN4\_SHARE\_ACCESS\_WRITE를 설정해서는 안 됩니다. 그렇다면 서버는 이를 무시해야 합니다.\(SHOULD NOT, MUST\)

wda\_want에 있는 다음 플래그의 의미는 아래에 설명된 사항을 제외하고 OPEN에 있는 것과 동일합니다.

```text
   *  OPEN4_SHARE_ACCESS_WANT_READ_DELEG

   *  OPEN4_SHARE_ACCESS_WANT_WRITE_DELEG

   *  OPEN4_SHARE_ACCESS_WANT_ANY_DELEG
```

\* OPEN4\_SHARE\_ACCESS\_WANT\_NO\_DELEG. OPEN 작업과 달리 이 플래그는 WANT\_DELEGATION에 대한 인수에서 클라이언트에 의해 설정되어서는 안 되며 서버에서는 무시되어야 합니다.\(MUST\)

```text
   *  OPEN4_SHARE_ACCESS_WANT_CANCEL

   *  OPEN4_SHARE_ACCESS_WANT_SIGNAL_DELEG_WHEN_RESRC_AVAIL

   *  OPEN4_SHARE_ACCESS_WANT_PUSH_DELEG_WHEN_UNCONTENDED
```

WANT\_DELEGATION에서 위 플래그의 처리는 OPEN과 동일합니다. 위임 및/또는 향후 콜백에 관해 서버가 하는 약속에 대한 정보는 open\_delegation4 구조에 설명된 것과 동일합니다.

WANT\_DELEGATION의 성공적인 결과는 OPEN 작업 결과의 "위임" 필드와 동일한 데이터 유형인 open\_delegation4 데이터 유형입니다\(섹션 18.16.3 참조\). 서버는 OPEN의 "위임"을 구성하는 것과 동일한 방식으로 wdr\_resok4를 구성하지만 한 가지 차이점이 있습니다. WANT\_DELEGATION은 OPEN\_DELEGATE\_NONE 위임 유형을 반환하면 안 됩니다.\(MUST NOT\)

\(\(wda\_want & OPEN4\_SHARE\_ACCESS\_WANT\_DELEG\_MASK\) & \~OPEN4\_SHARE\_ACCESS\_WANT\_NO\_DELEG\)가 0이면 클라이언트는 위임을 명시적으로 원하지 않거나 원하지 않음을 나타내는 것이며 서버는 NFS4ERR\_INVAL을 반환해야 합니다.\(MUST\)

클라이언트는 WANT\_DELEGATION 작업에서 OPEN4\_SHARE\_ACCESS\_WANT\_CANCEL 플래그를 사용하여 이전에 요청한 위임 요청을 취소합니다. 클라이언트가 원하는 취소를 보낼 때 서버가 \(CB\_PUSH\_DELEG를 통해\) 위임을 보내는 중이라면 위임은 여전히 ​​클라이언트에 푸시될 수 있습니다.

WANT\_DELEGATION이 위임 반환에 실패하고 서버가 NFS4\_OK를 반환하는 경우 서버는 섹션 18.16에 설명된 대로 위임 유형을 OPEN4\_DELEGATE\_NONE\_EXT로 설정하고 od\_whynone을 설정해야 합니다. 쓰기가 불가능한 파일 형식에는 쓰기 위임을 사용할 수 없습니다. 여기에는 NF4BLK, NF4CHR, NF4LNK, NF4SOCK 및 NF4FIFO 유형의 파일 개체가 포함됩니다. 클라이언트가 앞서 언급한 파일 형식 중 하나를 사용하는 개체에 대해 OPEN4\_SHARE\_ACCESS\_WANT\_READ\_DELEG 없이 OPEN4\_SHARE\_ACCESS\_WANT\_WRITE\_DELEG를 요청하는 경우 서버는 wdr\_resok4.od\_whynone.ond\_why를 WND4\_WRITE\_DELEG\_NOT\_SUPP\_FTYPE으로 설정해야 합니다.\(MUST\)

---
#### **18.49.4.  IMPLEMENTATION**

상충되는 위임에 대한 요청은 일반적으로 기존 위임의 회수를 촉발하기 위한 것이 아닙니다. 서버는 일부 클라이언트를 더 높은 우선순위로 처리하여 클라이언트의 요구가 기존 위임의 회수를 촉발하도록 선택할 수 있지만 이는 특이한 상황이 될 것으로 예상됩니다.

서버는 일반적으로 OPEN에 의해 ​​할당된 위임과 동일한 기준으로 WANT\_DELEGATION에 의해 ​​할당된 위임을 회수합니다. CB\_RECALL은 일반적으로 다른 클라이언트가 위임에 맞지 않는 작업을 수행하는 경우에만 수행됩니다. 위임의 노화에 대한 일반적인 대응은 클라이언트의 관점에서 가장 유용한 위임을 유지할 수 있는 기회를 클라이언트에게 제공하기 위해 CB\_RECALL\_ANY를 사용하는 것입니다.

---
### **18.50.  Operation 57: DESTROY_CLIENTID - Destroy a Client ID**
---
#### **18.50.1.  ARGUMENT**

```text
   struct DESTROY_CLIENTID4args {
           clientid4       dca_clientid;
   };
```

---
#### **18.50.2.  RESULT**

```text
   struct DESTROY_CLIENTID4res {
           nfsstat4        dcr_status;
   };
```

---
#### **18.50.3.  DESCRIPTION**

DESTROY\_CLIENTID 작업은 클라이언트 ID를 삭제합니다. 클라이언트 ID의 만료되지 않은 임대와 관련된 세션\(유휴 및 비유휴 모두\), 열기, 잠금, 위임, 레이아웃 및/또는 요구\(18.49절\)가 있는 경우 서버는 NFS4ERR\_CLIENTID\_BUSY를 반환해야 합니다. DESTROY\_CLIENTID는 SEQUENCE의 세션 ID에서 파생된 클라이언트 ID가 파기될 클라이언트 ID와 동일하지 않은 한 SEQUENCE 작업 앞에 올 수 있습니다. 클라이언트 ID가 동일하면 서버는 NFS4ERR\_CLIENTID\_BUSY를 반환해야 합니다.\(MUST, MAY, MUST\)

DESTROY\_CLIENTID 앞에 SEQUENCE가 붙지 않은 경우 이는 COMPOUND 요청의 유일한 작업이어야 합니다\(그렇지 않으면 서버는 NFS4ERR\_NOT\_ONLY\_OP를 반환해야 합니다\). 작업이 앞에 SEQUENCE 없이 전송되면 요청을 재전송하는 클라이언트는 원래 요청이 성공적으로 실행되었을 수 있으므로 이에 대한 응답으로 오류를 수신할 수 있습니다.\(MUST\)

---
#### **18.50.4.  IMPLEMENTATION**

DESTROY\_CLIENTID를 사용하면 서버는 사용되지 않은 클라이언트 ID가 소비한 리소스를 즉시 회수하고 클라이언트 ID를 생성한 사실을 잊을 수 있습니다. 서버는 클라이언트 ID를 생성했다는 사실을 잊어버리면 향후 EXCHANGE\_ID 작업에서 클라이언트 ID를 안전하게 재사용할 수 있습니다.

---
### **18.51.  Operation 58: RECLAIM_COMPLETE - Indicates Reclaims Finished**
---
#### **18.51.1.  ARGUMENT**

```text
   struct RECLAIM_COMPLETE4args {
           /*
            * If rca_one_fs TRUE,
            *
            *    CURRENT_FH: object in
            *    file system reclaim is
            *    complete for.
            */
           bool            rca_one_fs;
   };
```

---
#### **18.51.2.  RESULTS**

```text
   struct RECLAIM_COMPLETE4res {
           nfsstat4        rcr_status;
   };
```

---
#### **18.51.3.  DESCRIPTION**

RECLAIM\_COMPLETE 작업은 클라이언트가 서버를 다시 시작하거나 파일 시스템을 다른 서버로 마이그레이션하여 상태를 복구하는 중일 때 재생을 사용하여 복구할 모든 잠금 상태를 클라이언트가 회수했음을 나타내는 데 사용됩니다. RECLAIM\_COMPLETE 작업에는 두 가지 유형이 있습니다.

\* rca\_one\_fs가 FALSE이면 전역 RECLAIM\_COMPLETE가 수행되는 것입니다. 이는 클라이언트가 이전 서버 인스턴스에 보유하고 있던 모든 잠금의 복구가 완료되었음을 나타냅니다. 이 경우 현재 파일 핸들을 설정할 필요가 없습니다.

\* rca\_one\_fs가 TRUE이면 파일 시스템별 RECLAIM\_COMPLETE가 수행됩니다. 이는 파일 시스템 마이그레이션으로 인해 단일 fs\(현재 파일 핸들이 지정한 파일\)에 대한 잠금 복구가 완료되었음을 나타냅니다. rca\_one\_fs가 TRUE로 설정된 경우 현재 파일 핸들이 있어야 합니다. 현재 파일 핸들이 마이그레이션 과정에 있지 않은 파일 시스템의 파일 핸들을 지정하면 해당 작업은 NFS4\_OK를 반환하고 그렇지 않으면 무시됩니다.

RECLAIM\_COMPLETE가 완료되면 범위가 복구가 완료된 것으로 정의된 잠금에 대해 더 이상 회수 작업을 수행할 수 없습니다. 클라이언트가 RECLAIM\_COMPLETE를 전송하면 서버는 클라이언트가 해당 범위에 대한 잠금 상태의 후속 회수를 수행하는 것을 허용하지 않으며, 이러한 시도가 있을 경우 NFS4ERR\_NO\_GRACE를 반환합니다.

클라이언트가 새 클라이언트 ID를 설정할 때마다 그리고 잠금을 획득하는 첫 번째 비재확보 작업을 수행하기 전에, 재확보할 잠금이 없더라도 rca\_one\_fs가 FALSE로 설정된 RECLAIM\_COMPLETE를 보내야 합니다. RECLAIM\_COMPLETE 이전에 비재확보 잠금 작업이 수행되면 NFS4ERR\_GRACE 오류가 반환됩니다.\(MUST\)

마찬가지로 클라이언트가 새 서버에서 마이그레이션된 파일 시스템에 액세스할 때 이 새 서버에서 잠금을 획득하는 첫 번째 비재확보 작업을 보내기 전에 rca\_one\_fs가 TRUE로 설정된 RECLAIM\_COMPLETE와 해당 파일 시스템 내의 현재 파일 핸들을 보내야 합니다. , 회수할 잠금이 없는 경우에도 마찬가지입니다. RECLAIM\_COMPLETE 이전에 해당 파일 시스템에서 비재확보 잠금 작업이 수행되면 NFS4ERR\_GRACE 오류가 반환됩니다.\(MUST\)

클라이언트가 RECLAIM\_COMPLETE의 두 가지 형식을 모두 발행해야 하는 상황이 있다는 점에 유의해야 합니다. 클라이언트에 클라이언트 ID가 없는 서버로 파일 시스템이 마이그레이션되는 파일 시스템 마이그레이션 인스턴스를 예로 들 수 있습니다. 결과적으로 클라이언트는 파일 시스템 마이그레이션과 관련된 fs별 유예 기간을 완료하기 위해 서버에서 클라이언트 ID를 가져와야 하며\(rca\_one\_fs를 FALSE로 설정한 상태에서 RECLAIM\_COMPLETE를 수행할 책임이 있음\), rca\_one\_fs를 TRUE로 설정한 RECLAIM\_COMPLETE를 가져와야 합니다. . 이 두 가지 작업 중 하나를 실행하기 전에 필요한 모든 잠금 회수가 완료되면 순서에 상관없이 수행할 수 있습니다.

RECLAIM\_COMPLETE가 완료된 시점에 회수되지 않은 잠금은 회수 불가능하게 됩니다. 클라이언트는 현재 서버 인스턴스나 후속 서버 인스턴스 또는 해당 파일 시스템에 대한 책임이 이전되는 다른 서버에서 이를 회수하려고 시도해서는 안 됩니다. 클라이언트가 그렇게 하면 자신이 소유하지 않은 잠금을 소유하고 있으므로 회수할 권리가 없다고 표현하여 프로토콜을 위반하게 됩니다. 잠금 회수와 관련된 에지 조건에 대한 논의는 \[66\]의 섹션 8.4.3을 참조하십시오.\(MUST NOT\)

RECLAIM\_COMPLETE를 전송함으로써 클라이언트는 일반적인 비재확보 잠금 작업을 진행할 준비가 되었음을 나타냅니다. 클라이언트는 서버가 유예 기간을 종료할 준비가 될 때까지 이러한 작업으로 인해 일시적으로 NFS4ERR\_GRACE 오류가 발생할 수 있다는 점을 알고 있어야 합니다.

---
#### **18.51.4.  IMPLEMENTATION**

서버는 일반적으로 유예 기간을 줄이기 위해 회수 활동이 완료되는 시점에 대한 정보를 사용합니다. 서버가 잠금이 있을 수 있는 클라이언트 목록을 영구 저장소에 유지 관리할 때 모든 클라이언트가 RECLAIM\_COMPLETE를 수행하여 유예 기간을 종료하고 정상적인 작업\(예: 새 잠금에 대한 요청 승인\)을 시작했다는 사실을 사용할 수 있습니다. 그렇지 않은 경우보다 더 빨리.

마지막 잠금 회수 작업이 수행되는 COMPOUND 요청의 일부로 RECLAIM\_COMPLETE를 수행하면 대기 시간을 최소화할 수 있습니다. 수행할 회수가 없는 경우 유예 기간이 최대한 빨리 종료되도록 RECLAIM\_COMPLETE를 즉시 수행해야 합니다.

RECLAIM\_COMPLETE는 각 서버 인스턴스 또는 파일 시스템 전환에 대해 한 번만 수행되어야 합니다. 두 번째로 수행하면 NFS4ERR\_COMPLETE\_ALREADY 오류가 발생합니다. 세션 기능의 재시도 보호로 인해 RECLAIM\_COMPLETE 작업이 포함된 COMPOUND 요청을 재시도해도 이 오류가 발생하지 않습니다.

RECLAIM\_COMPLETE가 전송되면 클라이언트는 아직 복구되지 않은 모든 잠금을 손실된 것으로 효과적으로 승인합니다. 이를 통해 섹션 8.4.3에 설명된 대로 경계 조건이 발생하여 서버가 클라이언트의 잠금 복구 기능을 비활성화한 경우 서버가 클라이언트의 잠금 복구 기능을 다시 활성화할 수 있습니다.

RECLAIM\_COMPLETE에 대한 이전 설명은 rca\_one\_fs를 TRUE로 설정한 상태에서 RECLAIM\_COMPLETE를 사용하는 것이 적절한 상황에 대해 충분히 명시적이지 않았기 때문에 rca\_one\_fs를 TRUE로 설정한 상태에서 RECLAIM\_COMPLETE를 발행한 클라이언트가 이를 오용한 경우가 있었습니다. 그렇지 않았습니다. 위에서 설명한 대로 rca\_one\_fs 설정을 무시하거나\(작업을 전역 RECLAIM\_COMPLETE로 처리\) 전체 작업을 무시하는 등 서버가 다양한 방식으로 이러한 오용에 응답하지 않는 경우도 있었습니다.

클라이언트는 이 기능을 오용해서는 안 되며 서버는 위에 설명된 대로 이러한 오용에 응답해야 하지만 구현자는 기존 구현과의 상호 운용성과 잠금 복구를 허용하는 시설에 대한 적절한 지원 간에 필요한 절충안을 만들 때 다음 고려 사항을 인식해야 합니다. 파일 시스템 마이그레이션 이벤트.\(SHOULD NOT\)

\* 서버가 마이그레이션 대상 파일 시스템의 대상 서버가 되는 것을 지원하지 않는 경우 per-fs RECLAIM\_COMPLETE가 합법적으로 수행될 가능성이 없으며 이러한 발생은 무시되어야 합니다. 그러나 필요한 모든 회수가 완료되기 전에 고객이 이를 발행하지 않는 한 그러한 잘못된 사용을 수락함으로써 발생하는 부정적인 결과는 매우 제한적입니다.\(SHOULD\)

\* 서버가 마이그레이션되는 파일 시스템의 대상이 될 수 있는 경우 per-fs RECLAIM\_COMPLETE를 부적절하게 사용하는 것이 더 문제입니다. 지정된 파일 시스템이 fs별 유예 기간 내에 있지 않은 경우, fs별 RECLAIM\_COMPLETE는 무시되어야 하며, 마이그레이션이 지원되지 않는 경우와 같이 이를 수락하면 부정적인 결과가 제한됩니다. 그러나 서버가 마이그레이션 중인 파일 시스템을 발견하는 경우 의도된 용도를 무효화하지 않고는 마치 전역 RECLAIM\_COMPLETE인 것처럼 작업을 수락할 수 없습니다.\(SHOULD\)

---
### **18.52.  Operation 10044: ILLEGAL - Illegal Operation**
---
#### **18.52.1.  ARGUMENTS**

```text
   void;
```

---
#### **18.52.2.  RESULTS**

```text
   struct ILLEGAL4res {
           nfsstat4        status;
   };
```

---
#### **18.52.3.  DESCRIPTION**

이 작업은 클라이언트가 지원되지 않는 COMPOUND 내에서 작업 코드를 보내는 경우를 처리하기 위해 결과를 인코딩하기 위한 자리 표시자입니다. 자세한 내용은 COMPOUND 프로시저 설명을 참조하세요.

ILLEGAL4res의 상태 필드는 NFS4ERR\_OP\_ILLEGAL로 설정되어야 합니다.\(MUST\)

---
#### **18.52.4.  IMPLEMENTATION**

클라이언트는 아마도 OP\_ILLEGAL 코드가 포함된 작업을 보내지 않을 것입니다. 그러나 보내는 경우 다른 유효하지 않은 작업 코드와 마찬가지로 응답은 ILLEGAL4res가 됩니다. 서버가 OP\_ILLEGAL이 아닌 잘못된 연산 코드를 받고 서버가 XDR 디코드 단계 중에 적법한 연산 코드를 확인하는 경우 ILLEGAL4res가 반환되지 않습니다.

---
## **19.  NFSv4.1 Callback Procedures**

콜백에 사용되는 절차는 다음 섹션에 정의되어 있습니다. 명확성을 위해 "클라이언트"와 "서버"라는 용어는 NFS 클라이언트와 서버를 의미합니다. 그러나 개별 콜백 RPC의 경우 이러한 용어의 의미는 정반대입니다.

CB\_NULL 및 CB\_COMPOUND 두 프로시저를 모두 구현해야 합니다.\(MUST\)

---
### **19.1.  Procedure 0: CB_NULL - No Operation**
---
#### **19.1.1.  ARGUMENTS**

```text
   void;
```

---
#### **19.1.2.  RESULTS**

```text
   void;
```

---
#### **19.1.3.  DESCRIPTION**

CB\_NULL은 표준 void 인수와 void 응답을 포함하는 표준 ONC RPC NULL 프로시저입니다. 이 프로시저와 관련된 직접적인 기능이 없더라도 서버는 CB\_NULL을 사용하여 서버에서 클라이언트로의 RPC 경로가 있는지 확인합니다.

---
#### **19.1.4.  ERRORS**

```text
   None.
```

---
### **19.2.  Procedure 1: CB_COMPOUND - Compound Operations**
---
#### **19.2.1.  ARGUMENTS**

```text
   enum nfs_cb_opnum4 {
           OP_CB_GETATTR           = 3,
           OP_CB_RECALL            = 4,
   /* Callback operations new to NFSv4.1 */
           OP_CB_LAYOUTRECALL      = 5,
           OP_CB_NOTIFY            = 6,
           OP_CB_PUSH_DELEG        = 7,
           OP_CB_RECALL_ANY        = 8,
           OP_CB_RECALLABLE_OBJ_AVAIL = 9,
           OP_CB_RECALL_SLOT       = 10,
           OP_CB_SEQUENCE          = 11,
           OP_CB_WANTS_CANCELLED   = 12,
           OP_CB_NOTIFY_LOCK       = 13,
           OP_CB_NOTIFY_DEVICEID   = 14,

           OP_CB_ILLEGAL           = 10044
   };

   union nfs_cb_argop4 switch (unsigned argop) {
    case OP_CB_GETATTR:
         CB_GETATTR4args           opcbgetattr;
    case OP_CB_RECALL:
         CB_RECALL4args            opcbrecall;
    case OP_CB_LAYOUTRECALL:
         CB_LAYOUTRECALL4args      opcblayoutrecall;
    case OP_CB_NOTIFY:
         CB_NOTIFY4args            opcbnotify;
    case OP_CB_PUSH_DELEG:
         CB_PUSH_DELEG4args        opcbpush_deleg;
    case OP_CB_RECALL_ANY:
         CB_RECALL_ANY4args        opcbrecall_any;
    case OP_CB_RECALLABLE_OBJ_AVAIL:
         CB_RECALLABLE_OBJ_AVAIL4args opcbrecallable_obj_avail;
    case OP_CB_RECALL_SLOT:
         CB_RECALL_SLOT4args       opcbrecall_slot;
    case OP_CB_SEQUENCE:
         CB_SEQUENCE4args          opcbsequence;
    case OP_CB_WANTS_CANCELLED:
         CB_WANTS_CANCELLED4args   opcbwants_cancelled;
    case OP_CB_NOTIFY_LOCK:
         CB_NOTIFY_LOCK4args       opcbnotify_lock;
    case OP_CB_NOTIFY_DEVICEID:
         CB_NOTIFY_DEVICEID4args   opcbnotify_deviceid;
    case OP_CB_ILLEGAL:            void;
   };

   struct CB_COMPOUND4args {
           utf8str_cs      tag;
           uint32_t        minorversion;
           uint32_t        callback_ident;
           nfs_cb_argop4   argarray<>;
   };
```

---
#### **19.2.2.  RESULTS**

```text
   union nfs_cb_resop4 switch (unsigned resop) {
    case OP_CB_GETATTR:    CB_GETATTR4res  opcbgetattr;
    case OP_CB_RECALL:     CB_RECALL4res   opcbrecall;

    /* new NFSv4.1 operations */
    case OP_CB_LAYOUTRECALL:
                           CB_LAYOUTRECALL4res
                                           opcblayoutrecall;

    case OP_CB_NOTIFY:     CB_NOTIFY4res   opcbnotify;

    case OP_CB_PUSH_DELEG: CB_PUSH_DELEG4res
                                           opcbpush_deleg;

    case OP_CB_RECALL_ANY: CB_RECALL_ANY4res
                                           opcbrecall_any;

    case OP_CB_RECALLABLE_OBJ_AVAIL:
                           CB_RECALLABLE_OBJ_AVAIL4res
                                   opcbrecallable_obj_avail;

    case OP_CB_RECALL_SLOT:
                           CB_RECALL_SLOT4res
                                           opcbrecall_slot;

    case OP_CB_SEQUENCE:   CB_SEQUENCE4res opcbsequence;

    case OP_CB_WANTS_CANCELLED:
                           CB_WANTS_CANCELLED4res
                                   opcbwants_cancelled;

    case OP_CB_NOTIFY_LOCK:
                           CB_NOTIFY_LOCK4res
                                           opcbnotify_lock;

    case OP_CB_NOTIFY_DEVICEID:
                           CB_NOTIFY_DEVICEID4res
                                           opcbnotify_deviceid;

    /* Not new operation */
    case OP_CB_ILLEGAL:    CB_ILLEGAL4res  opcbillegal;
   };

   struct CB_COMPOUND4res {
           nfsstat4 status;
           utf8str_cs      tag;
           nfs_cb_resop4   resarray<>;
   };
```

---
#### **19.2.3.  DESCRIPTION**

CB\_COMPOUND 프로시저는 하나 이상의 콜백 프로시저를 단일 RPC 요청으로 결합하는 데 사용됩니다. 기본 콜백 RPC 프로그램에는 CB\_NULL 및 CB\_COMPOUND라는 두 가지 기본 프로시저가 있습니다. 다른 모든 작업은 CB\_COMPOUND 프로시저를 래퍼로 사용합니다.

CB\_COMPOUND 프로시저를 처리하는 동안 클라이언트는 CB\_COMPOUND 시퀀스 내의 작업 중 일부 또는 전부를 실행하는 데 사용할 수 있는 리소스가 없다는 것을 알 수 있습니다. 자세한 내용은 섹션 2.10.6.4를 참조하세요.

인수의 Minorversion 필드는 클라이언트 ID 및 세션을 생성하는 데 사용되는 COMPOUND 프로시저의 Minorversion과 동일해야 합니다. NFSv4.1의 경우 Minorversion을 1로 설정해야 합니다.\(MUST, MUST\)

CB\_COMPOUND 결과에는 "상태" 필드가 포함되어 있습니다. 이 상태는 CB\_COMPOUND 프로시저 내에서 실행된 마지막 작업의 상태와 같아야 합니다. 따라서 작업에 오류가 발생한 경우 "상태" 값은 실패한 작업에 대해 반환되는 오류 값과 동일합니다.\(MUST\)

"태그" 필드는 COMPOUND 프로시저와 동일한 방식으로 처리됩니다\(섹션 16.2.3 참조\).

잘못된 연산 코드는 COMPOUND 프로시저에서 처리되는 것과 동일한 방식으로 처리됩니다.

---
#### **19.2.4.  IMPLEMENTATION**

CB\_COMPOUND 프로시저는 개별 작업을 단일 RPC 요청으로 결합하는 데 사용됩니다. 클라이언트는 각 작업을 차례로 해석합니다. 클라이언트에 의해 작업이 실행되고 해당 작업의 상태가 NFS4\_OK이면 CB\_COMPOUND 프로시저의 다음 작업이 실행됩니다. 클라이언트는 더 이상 실행할 작업이 없거나 작업 중 하나가 NFS4\_OK 이외의 상태 값을 가질 때까지 이 프로세스를 계속합니다.

---
#### **19.2.5.  ERRORS**

물론 CB\_COMPOUND는 백채널의 각 작업이 반환할 수 있는 모든 오류를 반환합니다\(표 13 참조\). 그러나 CB\_COMPOUND가 0 작업을 반환하는 경우 COMPOUND에서 반환된 오류는 작업에서 반환된 오류와 아무 관련이 없습니다. 0 작업을 처리하는 경우 CB\_COMPOUND가 반환하는 오류 목록에는 다음이 포함됩니다.

```text
    +==============================+==================================+
    | Error                        | Notes                            |
    +==============================+==================================+
    | NFS4ERR_BADCHAR              | The tag argument has a character |
    |                              | the replier does not support.    |
    +------------------------------+----------------------------------+
    | NFS4ERR_BADXDR               |                                  |
    +------------------------------+----------------------------------+
    | NFS4ERR_DELAY                |                                  |
    +------------------------------+----------------------------------+
    | NFS4ERR_INVAL                | The tag argument is not in UTF-8 |
    |                              | encoding.                        |
    +------------------------------+----------------------------------+
    | NFS4ERR_MINOR_VERS_MISMATCH  |                                  |
    +------------------------------+----------------------------------+
    | NFS4ERR_SERVERFAULT          |                                  |
    +------------------------------+----------------------------------+
    | NFS4ERR_TOO_MANY_OPS         |                                  |
    +------------------------------+----------------------------------+
    | NFS4ERR_REP_TOO_BIG          |                                  |
    +------------------------------+----------------------------------+
    | NFS4ERR_REP_TOO_BIG_TO_CACHE |                                  |
    +------------------------------+----------------------------------+
    | NFS4ERR_REQ_TOO_BIG          |                                  |
    +------------------------------+----------------------------------+

                    Table 24: CB_COMPOUND Error Returns
```

---
## **20.  NFSv4.1 Callback Operations**
---
### **20.1.  Operation 3: CB_GETATTR - Get Attributes**
---
#### **20.1.1.  ARGUMENT**

```text
   struct CB_GETATTR4args {
           nfs_fh4 fh;
           bitmap4 attr_request;
   };
```

---
#### **20.1.2.  RESULT**

```text
   struct CB_GETATTR4resok {
           fattr4  obj_attributes;
   };

   union CB_GETATTR4res switch (nfsstat4 status) {
    case NFS4_OK:
            CB_GETATTR4resok       resok4;
    default:
            void;
   };
```

---
#### **20.1.3.  DESCRIPTION**

CB\_GETATTR 작업은 OPEN\_DELEGATE\_WRITE 위임된 파일의 현재 수정된 상태를 얻기 위해 서버에서 사용됩니다. 크기 및 변경 속성은 클라이언트가 서비스하도록 보장되는 유일한 속성입니다. 클라이언트와 서버가 CB\_GETATTR 사용과 상호 작용하는 방법에 대한 전체 설명은 섹션 10.4.3을 참조하세요.

지정된 파일 핸들이 클라이언트가 OPEN\_DELEGATE\_WRITE 위임을 보유한 파일 핸들이 아닌 경우 NFS4ERR\_BADHANDLE 오류가 반환됩니다.

---
#### **20.1.4.  IMPLEMENTATION**

클라이언트는 변경 속성 및 변경할 수 있는 속성\(time\_modify 및 크기\)에 대해서만 attmask 비트 및 관련 속성 값을 반환합니다.

---
### **20.2.  Operation 4: CB_RECALL - Recall a Delegation**
---
#### **20.2.1.  ARGUMENT**

```text
   struct CB_RECALL4args {
           stateid4        stateid;
           bool            truncate;
           nfs_fh4         fh;
   };
```

---
#### **20.2.2.  RESULT**

```text
   struct CB_RECALL4res {
           nfsstat4        status;
   };
```

---
#### **20.2.3.  DESCRIPTION**

CB\_RECALL 작업은 위임을 회수하고 이를 서버에 반환하는 프로세스를 시작하는 데 사용됩니다.

truncate 플래그는 일반 파일이고 곧 0으로 잘릴 파일 객체에 대한 회수를 최적화하는 데 사용됩니다. TRUE인 경우 클라이언트는 파일에 대해 수정된 데이터를 서버에 전파할 의무가 없습니다. 이 데이터는 관련이 없기 때문입니다.

지정된 핸들이 클라이언트가 위임한 핸들이 아닌 경우 NFS4ERR\_BADHANDLE 오류가 반환됩니다.

지정된 상태 ID가 파일 핸들에 의해 지정된 파일에 대한 OPEN 위임에 해당하는 상태가 아닌 경우 NFS4ERR\_BAD\_STATEID가 반환됩니다.

---
#### **20.2.4.  IMPLEMENTATION**

클라이언트는 콜백에 즉시 응답해야 합니다. 응답의 상태 필드 값이 NFS4ERR\_DELAY 또는 NFS4\_OK가 아닌 경우를 제외하고 응답은 회수를 완료하지 않습니다. DELEGRETURN 작업을 사용하여 위임이 반환될 때까지 회수는 완료되지 않습니다.\(SHOULD\)

---
### **20.3.  Operation 5: CB_LAYOUTRECALL - Recall Layout from Client**
---
#### **20.3.1.  ARGUMENT**

```text
   /*
    * NFSv4.1 callback arguments and results
    */

   enum layoutrecall_type4 {
           LAYOUTRECALL4_FILE = LAYOUT4_RET_REC_FILE,
           LAYOUTRECALL4_FSID = LAYOUT4_RET_REC_FSID,
           LAYOUTRECALL4_ALL  = LAYOUT4_RET_REC_ALL
   };

   struct layoutrecall_file4 {
           nfs_fh4         lor_fh;
           offset4         lor_offset;
           length4         lor_length;
           stateid4        lor_stateid;
   };

   union layoutrecall4 switch(layoutrecall_type4 lor_recalltype) {
   case LAYOUTRECALL4_FILE:
           layoutrecall_file4 lor_layout;
   case LAYOUTRECALL4_FSID:
           fsid4              lor_fsid;
   case LAYOUTRECALL4_ALL:
           void;
   };

   struct CB_LAYOUTRECALL4args {
           layouttype4             clora_type;
           layoutiomode4           clora_iomode;
           bool                    clora_changed;
           layoutrecall4           clora_recall;
   };
```

---
#### **20.3.2.  RESULT**

```text
   struct CB_LAYOUTRECALL4res {
           nfsstat4        clorr_status;
   };
```

---
#### **20.3.3.  DESCRIPTION**

CB\_LAYOUTRECALL 작업은 서버가 클라이언트에서 레이아웃을 호출하는 데 사용됩니다. 결과적으로 클라이언트는 LAYOUTRETURN을 통해 레이아웃을 반환하는 프로세스를 시작합니다. CB\_LAYOUTRECALL 작업은layoutrecall\_type4 값을 사용하여 세 가지 형태의 호출 처리 중 하나를 지정합니다. 리콜은 특정 파일의 특정 레이아웃\(LAYOUTRECALL4\_FILE\), 전체 파일 시스템 ID\(LAYOUTRECALL4\_FSID\) 또는 모든 파일 시스템\(LAYOUTRECALL4\_ALL\) 중 하나에 대한 것입니다.

작업 동작은layoutrecall\_type4의 값에 따라 다릅니다. 값과 동작은 다음과 같습니다.

LAYOUTRECALL4\_FILE

- 레이아웃이 리콜 요청과 일치하려면 clora\_type, clora\_iomode, lor\_fh 및 lor\_offset 및 lor\_length로 지정된 바이트 범위 필드의 값이 레이아웃의 값과 일치해야 합니다. clora\_iomode 필드는 LAYOUTIOMODE4\_ANY라는 특별한 값을 가질 수 있습니다. 특수 값 LAYOUTIOMODE4\_ANY는 원래 레이아웃에 반환된 모든 iomode와 일치합니다. 따라서 와일드카드 역할을 합니다. 사용된 다른 특수 값은 lor\_length에 대한 것입니다. lor\_length의 값이 NFS4\_UINT64\_MAX인 경우 lor\_length 필드는 가능한 최대 파일 크기를 의미합니다. 일치하는 레이아웃이 발견되면 반드시 LAYOUTRETURN 연산을 사용하여 반환해야 합니다\(섹션 18.44 참조\). 필드의 특수 값 사용의 예는 clora\_iomode가 LAYOUTIOMODE4\_ANY이고 lor\_offset이 0이고 lor\_length가 NFS4\_UINT64\_MAX인 경우 전체 레이아웃이 반환되는 것입니다.\(MUST\)

- NFS4ERR\_NOMATCHING\_LAYOUT 오류는 클라이언트가 파일에 대한 레이아웃을 보유하지 않거나 클라이언트가 레이아웃 리콜의 사양에 대해 겹치는 레이아웃을 갖지 않는 경우에만 반환됩니다.

LAYOUTRECALL4\_FSID 및 LAYOUTRECALL4\_ALL

- LAYOUTRECALL4\_FSID가 지정된 경우 fsid는 미해결 레이아웃이 반드시 반환되어야 하는 파일 시스템을 지정합니다. LAYOUTRECALL4\_ALL이 지정되면 모든 미해결 레이아웃이 반환되어야 합니다. 또한 LAYOUTRECALL4\_FSID 및 LAYOUTRECALL4\_ALL은 영향을 받는 파일 시스템의 저장 장치 주소 매핑에 대한 모든 저장 장치 ID도 회수되도록 지정합니다. LAYOUTRETURN4\_FSID 또는 LAYOUTRETURN4\_ALL을 사용하는 해당 LAYOUTRETURN은 클라이언트가 해당 장치 매핑을 무효화했음을 서버에 승인합니다. 레이아웃의 "대량" 리콜에 대한 고려사항은 섹션 12.5.5.2.1.5를 참조하십시오.\(MUST, MUST\)

- NFS4ERR\_NOMATCHING\_LAYOUT 오류는 클라이언트가 레이아웃을 보유하지 않고 유효한 장치 ID 매핑이 없는 경우에만 반환됩니다.

레이아웃 호출 요청을 처리할 때 클라이언트는 clora\_changed 필드 값에 따라 동작도 달라집니다. 이 필드는 레이아웃이 호출되는 이유에 대한 추가 컨텍스트를 제공하기 위해 서버에서 사용됩니다. clora\_changed의 FALSE 값은 레이아웃 변경이 예상되지 않으며 클라이언트가 수정된 데이터를 관련 저장 장치에 쓸 수 있음을 나타냅니다. 이는 LAYOUTRETURN을 통해 레이아웃을 반환하기 전에 수행되어야 합니다. clora\_changed의 TRUE 값은 서버가 레이아웃을 변경하고 있음을 나타냅니다. 레이아웃 변경의 예와 TRUE 표시 이유는 다음과 같습니다. 메타데이터 서버가 파일을 다시 스트라이프하는 중이거나 저장 장치에 영구 오류가 발생하여 메타데이터 서버가 파일에 대한 새 레이아웃을 제공하려고 합니다. 따라서 TRUE의 clora\_changed 값은 레이아웃에 대한 일정 수준의 변경을 나타내며 클라이언트는 수정된 데이터를 저장 장치에 기록하거나 커밋해서는 안 됩니다. 이 경우 클라이언트는 메타데이터 서버를 통해 데이터를 쓰고 커밋합니다.\(SHOULD NOT\)

인수의 lor\_stateid 필드를 구성하는 방법에 대한 설명은 섹션 12.5.3을 참조하세요. lor\_stateid의 "seqid" 필드는 0이 되어서는 안 됩니다. 추가 논의 및 요구 사항은 섹션 8.2, 12.5.3 및 12.5.5.2를 참조하십시오.\(MUST NOT\)

---
#### **20.3.4.  IMPLEMENTATION**

CB\_LAYOUTRECALL에 대한 클라이언트 처리는 클라이언트가 실제로 LAYOUTRETURN 작업을 통해 레이아웃을 반환하기 전에 요청에 응답한다는 점에서 CB\_RECALL\(파일 위임 회수\)과 유사합니다. 클라이언트가 CB\_LAYOUTRECALL에 즉시 응답하는 동안 영향을 받은 모든 레이아웃이 LAYOUTRETURN 작업을 통해 서버에 반환될 때까지 작업은 완료된 것으로 간주되지 않습니다\(예: 보류 중인 것으로 간주됩니다\).

LAYOUTRETURN을 통해 서버에 레이아웃을 반환하기 전에 클라이언트는 호출된 레이아웃을 사용하는 진행 중 또는 진행 중인 READ, WRITE 또는 COMMIT 작업의 응답을 기다려야 합니다.

클라이언트가 호출된 레이아웃의 영향을 받는 수정된 데이터를 보유하고 있는 경우 클라이언트에는 서버에 데이터를 쓰기 위한 다양한 옵션이 있습니다. 항상 그렇듯이 클라이언트는 메타데이터 서버를 통해 데이터를 쓸 수 있습니다. 실제로 clora\_changed 인수가 TRUE이고 서버에서 새 레이아웃을 사용할 수 없는 경우 클라이언트는 메타데이터 서버에 쓰는 것 외에 다른 선택권이 없을 수 있습니다. 그러나 clora\_changed 인수가 FALSE인 경우 클라이언트는 수정된 데이터를 저장 장치에 쓸 수 있습니다. 이 작업은 LAYOUTRETURN을 통해 레이아웃을 반환하기 전에 수행되어야 합니다. 클라이언트가 수정된 데이터의 바이트 범위를 포함하는 새로운 레이아웃을 얻으려면 저장 장치에 쓰는 것이 대안입니다. 새 레이아웃을 얻기 전에 클라이언트는 먼저 원본 레이아웃을 반환해야 합니다.

레이아웃이 유지되는 동안 수정된 데이터가 기록되는 경우 클라이언트는 적절한 시간에 LAYOUTCOMMIT 작업을 사용해야 합니다. 필요에 따라 LAYOUTCOMMIT는 LAYOUTRETURN 전에 수행되어야 합니다. 많은 양의 수정된 데이터가 처리되지 않은 경우 클라이언트는 호출된 레이아웃의 일부에 대해 LAYOUTRETURN을 보낼 수 있습니다. 이를 통해 서버는 클라이언트의 진행 상황과 원본 회수 요청 준수 여부를 모니터링할 수 있습니다. 그러나 일련의 반환에서 마지막 LAYOUTRETURN은 호출되는 전체 범위를 지정해야 합니다\(자세한 내용은 섹션 12.5.5.1 참조\).\(MUST\)

서버가 장치 ID를 삭제해야 하고 장치 ID를 참조하는 레이아웃이 있는 경우 CB\_LAYOUTRECALL을 호출하여 서버가 장치 ID를 삭제하기 전에 클라이언트가 장치 ID를 참조하는 모든 레이아웃을 반환하도록 해야 합니다. 클라이언트가 영향을 받은 레이아웃을 반환하지 않으면 서버는 해당 레이아웃을 취소할 수 있습니다.\(MUST, MAY\)

---
### **20.4.  Operation 6: CB_NOTIFY - Notify Client of Directory Changes**
---
#### **20.4.1.  ARGUMENT**

```text
   /*
    * Directory notification types.
    */
   enum notify_type4 {
           NOTIFY4_CHANGE_CHILD_ATTRS = 0,
           NOTIFY4_CHANGE_DIR_ATTRS = 1,
           NOTIFY4_REMOVE_ENTRY = 2,
           NOTIFY4_ADD_ENTRY = 3,
           NOTIFY4_RENAME_ENTRY = 4,
           NOTIFY4_CHANGE_COOKIE_VERIFIER = 5
   };

   /* Changed entry information.  */
   struct notify_entry4 {
           component4      ne_file;
           fattr4          ne_attrs;
   };

   /* Previous entry information */
   struct prev_entry4 {
           notify_entry4   pe_prev_entry;
           /* what READDIR returned for this entry */
           nfs_cookie4     pe_prev_entry_cookie;
   };

   struct notify_remove4 {
           notify_entry4   nrm_old_entry;
           nfs_cookie4     nrm_old_entry_cookie;
   };

   struct notify_add4 {
           /*
            * Information on object
            * possibly renamed over.
            */
           notify_remove4      nad_old_entry<1>;
           notify_entry4       nad_new_entry;
           /* what READDIR would have returned for this entry */
           nfs_cookie4         nad_new_entry_cookie<1>;
           prev_entry4         nad_prev_entry<1>;
           bool                nad_last_entry;
   };

   struct notify_attr4 {
           notify_entry4   na_changed_entry;
   };

   struct notify_rename4 {
           notify_remove4  nrn_old_entry;
           notify_add4     nrn_new_entry;
   };

   struct notify_verifier4 {
           verifier4       nv_old_cookieverf;
           verifier4       nv_new_cookieverf;
   };

   /*
    * Objects of type notify_<>4 and
    * notify_device_<>4 are encoded in this.
    */
   typedef opaque notifylist4<>;

   struct notify4 {
           /* composed from notify_type4 or notify_deviceid_type4 */
           bitmap4         notify_mask;
           notifylist4     notify_vals;
   };

   struct CB_NOTIFY4args {
           stateid4    cna_stateid;
           nfs_fh4     cna_fh;
           notify4     cna_changes<>;
   };
```

---
#### **20.4.2.  RESULT**

```text
   struct CB_NOTIFY4res {
           nfsstat4    cnr_status;
   };
```

---
#### **20.4.3.  DESCRIPTION**

CB\_NOTIFY 작업은 서버에서 위임된 디렉터리의 변경 사항에 대한 알림을 클라이언트에 보내는 데 사용됩니다. 디렉터리에 대한 알림 등록은 GET\_DIR\_DELEGATION을 사용하여 위임이 설정될 때 발생합니다. 이러한 알림은 백채널을 통해 전송됩니다. 원래 요청이 서버에서 처리되면 알림이 전송됩니다. 서버는 디렉터리에서 발생한 변경 사항에 대해 일련의 알림을 보냅니다. 알림은 비트맵과 값 쌍의 목록으로 전송됩니다. NFSv4.1 비트맵 작동 방식에 대한 설명은 섹션 3.3.7을 참조하세요.

서버에 CB\_COMPOUND 요청에 들어갈 수 있는 것보다 더 많은 알림이 있는 경우 클라이언트의 디렉터리 보기가 혼동되지 않도록 일련의 직렬 CB\_COMPOUND 요청을 보내야 합니다. 예를 들어, 서버가 "foo"라는 파일이 추가되고 "foo" 파일이 제거되었음을 나타내는 경우 클라이언트가 이러한 알림을 받는 순서는 서버에서 해당 작업이 발생한 순서와 동일해야 합니다. 서버.\(SHOULD\)

위임을 보유한 클라이언트가 파일이나 하위 디렉터리를 추가하거나 제거하도록 디렉터리를 변경하는 경우 서버는 해당 클라이언트에게 결과 변경 사항을 알립니다. 위임을 보유한 클라이언트가 속성 또는 쿠키 검증 프로그램만 변경하는 경우 서버는 해당 클라이언트에 알림을 보낼 필요가 없습니다. 서버는 각 작업에 대해 다음 정보를 보냅니다.

NOTIFY4\_ADD\_ENTRY

- 서버는 해당 항목에 대한 쿠키와 함께 생성되는 새 디렉토리 항목에 대한 정보를 보냅니다. 항목 정보\(데이터 유형 inform\_add4\)에는 항목의 구성요소 이름과 속성이 포함됩니다. 파일이 실제로 생성될 때, 디렉터리 전체의 이름 변경으로 인해 디렉터리에 항목이 추가될 때\(아래 참조\), 기존 파일에 대한 하드 링크가 생성될 때 서버는 이 유형의 항목을 보냅니다. . 이 항목이 디렉토리 끝에 추가되면 서버는 nad\_last\_entry 플래그를 TRUE로 설정합니다. 파일이 추가되어 파일 앞에 항목이 하나 이상 있으면 서버는 이전 항목 정보\(nad\_prev\_entry, 최대 1개 요소의 가변 길이 배열\)도 반환합니다. 배열 길이가 0인 경우에는 항목이 없습니다. 이전 항목\)과 해당 쿠키를 포함합니다. 이는 클라이언트가 파일 이름 캐시와 디렉터리 캐시에서 이 항목을 캐시해야 하는 올바른 위치를 찾는 데 도움이 됩니다. 새 항목의 쿠키를 사용할 수 있는 경우 nad\_new\_entry\_cookie\(최대 1개의 요소로 구성된 또 다른 가변 길이 배열\) 필드에 있습니다. 항목을 추가하면 추가 항목과 함께 다른 항목이 자동으로 삭제되는 경우\(이름 바꾸기 경우에만 발생할 수 있음\) 이 항목에 대한 정보가 nad\_old\_entry에 보고됩니다.

NOTIFY4\_REMOVE\_ENTRY

- 서버는 삭제되는 디렉토리 항목에 대한 정보를 보냅니다. 또한 서버는 클라이언트가 이 항목에 대해 캐시된 정보를 얻을 수 있도록 삭제된 항목에 대한 쿠키 값을 보냅니다.

NOTIFY4\_RENAME\_ENTRY

- 서버는 이전 항목과 새 항목 모두에 대한 정보를 보냅니다. 여기에는 각 항목의 이름과 속성이 포함됩니다. 또한 이름 변경으로 인해 항목이 삭제되는 경우\(예: 파일 이름이 변경된 경우\) nrn\_new\_new\_entry.nad\_old\_entry에 보고됩니다. 이 알림은 두 항목이 모두 동일한 디렉터리에 있는 경우에만 전송됩니다. 이름 바꾸기가 여러 디렉터리에 걸쳐 수행되는 경우 서버는 두 디렉터리 모두 디렉터리 위임을 가지고 있다고 가정하여 한 디렉터리에는 제거 알림을 보내고 다른 디렉터리에는 추가 알림을 보냅니다.

NOTIFY4\_CHANGE\_CHILD\_ATTRS/NOTIFY4\_CHANGE\_DIR\_ATTRS

- 클라이언트는 속성 마스크를 사용하여 알림을 받고 싶은 속성을 서버에 알립니다. 이 변경 알림은 두 개의 개별 속성 마스크를 사용하여 디렉터리 속성 변경은 물론 디렉터리에 있는 모든 파일 속성 변경에 대해 요청할 수 있습니다. 클라이언트는 특정 파일에 대한 변경 속성 알림을 요청할 수 없습니다. 하나의 속성 마스크가 디렉토리의 모든 파일을 덮습니다. 속성이 변경되면 서버는 변경된 속성 값을 다시 보냅니다. 일부 파일 시스템 전체 속성에 대해서는 알림이 의미가 없을 수 있으며 지원할 하위 집합을 결정하는 것은 서버에 달려 있습니다. 클라이언트는 속성 변경에 대해 얼마나 자주 알림을 받고 싶은지 서버에 알려줌으로써 속성 알림 빈도를 협상할 수 있습니다. 서버는 각각 dir\_notif\_delay 및 dir\_entry\_notif\_delay 속성을 설정하여 지원되는 알림 빈도 또는 디렉터리 또는 하위 속성에 대해 알림이 허용되지 않는다는 표시를 반환합니다.

NOTIFY4\_CHANGE\_COOKIE\_VERIFIER

- 클라이언트가 위임을 보유하는 동안 쿠키 검증 프로그램이 변경되면 서버는 클라이언트에게 쿠키를 무효화하고 READDIR을 다시 보내 새로운 쿠키 세트를 얻을 수 있도록 알립니다.

20.5. 작업 7: CB\_PUSH\_DELEG - 이전에 요청한 위임을 클라이언트에 제공

---
#### **20.5.1.  ARGUMENT**

```text
   struct CB_PUSH_DELEG4args {
           nfs_fh4          cpda_fh;
           open_delegation4 cpda_delegation;

   };
```

---
#### **20.5.2.  RESULT**

```text
   struct CB_PUSH_DELEG4res {
           nfsstat4 cpdr_status;
   };
```

---
#### **20.5.3.  DESCRIPTION**

CB\_PUSH\_DELEG는 서버가 원하는 위임\(이전에 OPEN 또는 WANT\_DELEGATION 작업에서 설정된 원하는 것을 통해 표시됨\)이 사용 가능함을 클라이언트에 알리는 동시에 클라이언트에 위임을 제공하는 데 사용됩니다. 클라이언트는 NFS4\_OK를 서버에 반환하여 위임을 수락하거나, NFS4ERR\_DELAY를 반환하여 제안된 위임 수락 결정을 지연하거나, NFS4ERR\_REJECT\_DELEG를 반환하여 위임 제안을 영구적으로 거부할 수 있습니다. 이러한 방식으로 위임이 거부되면 이전에 확립된 요구 사항은 영구적으로 삭제되고 해당 위임은 다른 클라이언트에 의해 인수될 수 있습니다.

---
#### **20.5.4.  IMPLEMENTATION**

클라이언트가 NFS4ERR\_DELAY를 반환하고 충돌하는 위임 요청이 있는 경우 서버는 NFS4ERR\_DELAY를 반환한 클라이언트를 희생하여 이를 처리할 수 있습니다. 고객의 요청은 취소되지 않지만 다른 위임 요청이나 등록된 요청 뒤에 처리될 수 있습니다.\(MAY, MAY\)

클라이언트가 NFS4\_OK, NFS4ERR\_DELAY 또는 NFS4ERR\_REJECT\_DELAY 이외의 상태를 반환하면 서버가 CB\_WANTS\_CANCELLED를 전송하여 원하는 것을 취소하기로 결정할 수도 있지만 원하는 것은 보류 상태로 유지됩니다.

---
### **20.6.  Operation 8: CB_RECALL_ANY - Keep Any N Recallable Objects**
---
#### **20.6.1.  ARGUMENT**

```text
   const RCA4_TYPE_MASK_RDATA_DLG          = 0;
   const RCA4_TYPE_MASK_WDATA_DLG          = 1;
   const RCA4_TYPE_MASK_DIR_DLG            = 2;
   const RCA4_TYPE_MASK_FILE_LAYOUT        = 3;
   const RCA4_TYPE_MASK_BLK_LAYOUT         = 4;
   const RCA4_TYPE_MASK_OBJ_LAYOUT_MIN     = 8;
   const RCA4_TYPE_MASK_OBJ_LAYOUT_MAX     = 9;
   const RCA4_TYPE_MASK_OTHER_LAYOUT_MIN   = 12;
   const RCA4_TYPE_MASK_OTHER_LAYOUT_MAX   = 15;

   struct  CB_RECALL_ANY4args      {
           uint32_t        craa_objects_to_keep;
           bitmap4         craa_type_mask;
   };
```

---
#### **20.6.2.  RESULT**

```text
   struct CB_RECALL_ANY4res {
           nfsstat4        crar_status;
   };
```

---
#### **20.6.3.  DESCRIPTION**

서버는 리소스가 부족하지 않으면 위임 및 레이아웃과 같은 회수 가능한 개체에 대한 모든 상태를 보유할 수 없다고 결정할 수 있습니다. 이러한 경우 최적은 아니지만 서버는 로드를 줄이기 위해 개별 개체를 자유롭게 호출할 수 있습니다.

위임과 같은 회수 가능한 개체의 일반적인 목적은 서버와의 클라이언트 상호 작용을 제거하는 것이기 때문에 서버는 최근 사용 부족을 해당 개체가 더 이상 유용하지 않음을 나타내는 것으로 해석할 수 없습니다. 눈에 보이는 사용이 없다는 것은 잠재적인 작업이 서버로 전송되지 않도록 하는 위임과 일치합니다. 레이아웃의 경우 저장 장치가 I/O 요청을 받을 때 레이아웃을 사용하면 레이아웃의 유용성이 표시되는 것이 사실이지만 저장 장치가 메타데이터 서버에 과거 또는 현재 레이아웃을 사용하는 경우 메타데이터 서버는 리소스 부족에 대응하여 어떤 레이아웃이 호출하기에 적합한지 알 수 없습니다.

이러한 개체에 대한 효과적인 회수 계획을 구현하려면 사용 가능한 리소스에 대한 서버의 지식을 사용하여 클라이언트가 반환할 실제 개체를 선택하면서 개체를 회수해야 하는 시기를 결정해야 합니다.

서버 구현은 리소스 할당 요구 사항이 다를 수 있습니다. 예를 들어, 한 서버는 호출 가능한 객체의 모든 클래스 간에 리소스를 공유할 수 있는 반면, 다른 서버는 레이아웃 및 위임을 위해 별도의 리소스 풀을 사용하거나 위임 유형별로 리소스를 추가로 분리할 수 있습니다.

주어진 리소스 풀이 과도하게 사용되면 서버는 관련된 유형의 회수 가능한 개체를 보유하는 클라이언트에 CB\_RECALL\_ANY를 보내 해당 개체의 특정 수를 유지하고 초과분을 반환할 수 있습니다. 마스크는 제한할 객체 유형을 지정합니다. 클라이언트는 현재 유용성에 대한 자체 지식을 기반으로 해당 클래스의 개체 중 어떤 개체를 반환해야 하는지 선택합니다.

비트 수가 정의됩니다. 이들 중 일부의 경우 범위가 정의되어 있으며 이를 사용하는 방법을 지정하는 것은 저장소 프로토콜의 정의에 달려 있습니다. 개체 기반 저장소 프로토콜 및 기타 실험적 저장소 프로토콜용으로 예약된 범위가 있습니다. 이러한 저장 프로토콜을 정의하는 RFC는 해당 범위 내의 특정 비트가 사용되는 방법을 지정해야 합니다. 예를 들어 레이아웃 속성\(읽기 대 쓰기, 영역 크기\)과 사용할 비트 간의 매핑을 지정하거나 서버에서 관련 비트 위치를 사용할 수 있는 레이아웃의 필드를 정의할 수 있습니다. 클라이언트에게.

RCA4\_TYPE\_MASK\_RDATA\_DLG

- 클라이언트는 디렉터리가 아닌 파일 개체에 대해 OPEN\_DELEGATE\_READ 위임을 반환합니다.

RCA4\_TYPE\_MASK\_WDATA\_DLG

- 클라이언트는 일반 파일 객체에 대해 OPEN\_DELEGATE\_WRITE 위임을 반환합니다.

RCA4\_TYPE\_MASK\_DIR\_DLG

- 클라이언트는 디렉터리 위임을 반환합니다.

RCA4\_TYPE\_MASK\_FILE\_LAYOUT

- 클라이언트는 LAYOUT4\_NFSV4\_1\_FILES 유형의 레이아웃을 반환합니다.

RCA4\_TYPE\_MASK\_BLK\_LAYOUT

- 설명은 \[48\]을 참고하세요.

RCA4\_TYPE\_MASK\_OBJ\_LAYOUT\_MIN에서 RCA4\_TYPE\_MASK\_OBJ\_LAYOUT\_MAX에 대한 설명은 \[47\]을 참조하세요.

RCA4\_TYPE\_MASK\_OTHER\_LAYOUT\_MIN \~ RCA4\_TYPE\_MASK\_OTHER\_LAYOUT\_MAX 이 범위는 클라이언트에게 실험적 또는 사이트별 레이아웃 유형의 레이아웃을 호출하도록 지시하기 위해 예약되어 있습니다\(섹션 3.3.13 참조\).

정의되지 않은 유형의 호출 가능한 객체에 해당하는 유형 마스크에 비트가 설정되면 NFS4ERR\_INVAL이 반환되어야 합니다. 정의된 유형의 객체에 해당하는 비트가 설정되었지만 클라이언트가 해당 유형의 객체를 지원하지 않는 경우 NFS4ERR\_INVAL이 반환되어서는 안 됩니다. NFSv4의 향후 마이너 버전은 유효한 유형 마스크 비트 세트를 확장할 수 있습니다.\(MUST, MUST NOT\)

CB\_RECALL\_ANY는 클라이언트가 반환해야 하는 개체 수와 반대로 클라이언트가 유지할 수 있는 개체 수를 지정합니다. 이는 레이아웃이나 위임을 반환하기 위해 클라이언트에서 시작된 작업 집합을 사용하여 해제할 개체 수가 있는 CB\_RECALL\_ANY 간의 잠재적 경합을 방지하기 위한 것입니다. 경쟁의 결과로 클라이언트와 서버는 반환할 개체 수에 대해 서로 다른 생각을 갖게 됩니다. 따라서 클라이언트가 실수로 너무 많은 항목을 해제할 수 있습니다.

리소스 요구로 인해 서버가 더 낮은 개수의 다른 CB\_RECALL\_ANY를 보낼 수 있습니다. 이는 동일한 유형 마스크를 사용하는 이전 CB\_RECALL\_ANY에 대해 클라이언트로부터 아직 승인을 받지 못한 경우에도 마찬가지입니다. 클라이언트가 전송된 순서와 다른 순서로 이를 수신할 가능성이 있지만 콜백 스트림의 이러한 순열은 해롭지 않습니다. 수신된 각 CB\_RECALL\_ANY에 맞춰 회수 가능한 객체 세트의 크기를 줄이는 것이 클라이언트의 임무이며, 해당 의무가 충족될 때까지 동일한 유형 마스크에 대한 후속 CB\_RECALL\_ANY에 의해 취소되거나 수정될 수 없습니다. 따라서 서버가 두 개의 CB\_RECALL\_ANY를 보내는 경우 리콜 수신 순서에 관계없이 낮은 개수를 보낸 것과 동일한 효과가 발생합니다. 이는 서버가 더 높은 횟수의 또 다른 리콜을 전송하여 CB\_RECALL\_ANY의 효과를 취소할 수 없음을 의미합니다. CB\_RECALL\_ANY가 수신되고 개수가 이미 설정된 제한 내에 있거나 클라이언트가 도달하려고 하는 제한을 초과하는 경우 해당 콜백은 효과가 없습니다.

서버는 일반적으로 사용 가능한 리소스가 부족할 때 회수 가능한 개체를 자유롭게 거부할 수 있습니다. 이러한 정책의 효과는 암묵적으로 요청된 개체에 비해 기존 개체에 우선 순위를 부여하는 것이며, 그 결과 리소스가 최적으로 사용되지 않을 수 있다는 점에 유의하십시오. 이를 방지하기 위해 서버는 CB\_RECALL\_ANY 콜백 전송을 시작하는 지점을 새로운 위임 및 레이아웃 제공을 중단하는 지점보다 약간 낮게 설정하는 것이 좋습니다. 이를 통해 클라이언트는 적절할 때마다 덜 사용되는 개체를 제거할 수 있으므로 개체 반환으로 확보된 새 리소스에 대해 후속 요청을 계속할 수 있습니다.

---
#### **20.6.4.  IMPLEMENTATION**

클라이언트는 마스크로 지정된 모든 유형의 객체를 반환하도록 선택할 수 있습니다. 서버가 특정 유형의 객체 사용을 제한하려는 경우 전송하는 마스크에 해당 유형만 지정해야 합니다. 클라이언트가 요청한 개체를 반환하지 못하는 경우 일반적으로 리소스 사용을 적절하게 제한하기 위해 특정 리콜\(예: CB\_RECALL 작업 전송\)을 전송하여 이 상황을 처리하는 것은 서버에 달려 있습니다. 서버는 특정 회수를 진행하기 전에 클라이언트에게 개체를 반환할 수 있는 충분한 시간을 주어야 합니다. 이 시간은 임대 기간보다 짧아서는 안 됩니다.

20.7. 작업 9: CB\_RECALLABLE\_OBJ\_AVAIL - 회수 가능한 객체에 대한 신호 리소스

---
#### **20.7.1.  ARGUMENT**

```text
   typedef CB_RECALL_ANY4args CB_RECALLABLE_OBJ_AVAIL4args;
```

---
#### **20.7.2.  RESULT**

```text
   struct CB_RECALLABLE_OBJ_AVAIL4res {
           nfsstat4        croa_status;
   };
```

---
#### **20.7.3.  DESCRIPTION**

CB\_RECALLABLE\_OBJ\_AVAIL은 이전에 OPEN, WANT\_DELEGATION, GET\_DIR\_DELEG 또는 LAYOUTGET에 의해 거부되었을 수 있는 회수 가능한 개체를 부여할 리소스가 서버에 있음을 클라이언트에 알리기 위해 서버에서 사용됩니다.

craa\_objects\_to\_keep 인수는 클라이언트가 이미 가지고 있는 객체의 수를 포함하여 서버가 클라이언트가 가질 수 있다고 믿는 인수 type\_mask에 표시된 유형의 호출 가능한 객체의 총 수를 의미합니다. 서버가 알려주는 것보다 더 많은 회수 가능한 개체를 얻으려고 시도하는 클라이언트는 개체를 회수할 위험이 있습니다.

서버는 클라이언트가 현재 가지고 있는 개체 수와 craa\_objects\_to\_keep 값 간의 차이를 예약할 의무가 없으며 CB\_RECALLABLE\_OBJ\_AVAIL에 대한 응답을 지연해도 서버가 다른 목적으로 호출 가능한 개체의 리소스를 사용하는 것을 방지하지 못합니다. 실제로 클라이언트가 CB\_RECALLABLE\_OBJ\_AVAIL에 느리게 응답하는 경우 서버는 클라이언트의 회수 가능한 개체 관리 능력이 저하된 것으로 해석하여 클라이언트를 대신하여 유지 관리하는 모든 예약을 취소하거나 줄일 수 있습니다. 따라서 클라이언트가 더 많은 회수 가능한 객체를 얻으려면 CB\_RECALLABLE\_OBJ\_AVAIL에 신속하게 응답한 다음 회수 가능한 객체를 획득하기 위한 적절한 작업을 보내야 합니다.

---
### **20.8.  Operation 10: CB_RECALL_SLOT - Change Flow Control Limits**
---
#### **20.8.1.  ARGUMENT**

```text
   struct CB_RECALL_SLOT4args {
           slotid4       rsa_target_highest_slotid;
   };
```

---
#### **20.8.2.  RESULT**

```text
   struct CB_RECALL_SLOT4res {
           nfsstat4   rsr_status;
   };
```

---
#### **20.8.3.  DESCRIPTION**

CB\_RECALL\_SLOT 작업은 클라이언트에게 세션 슬롯을 반환하고, 해당하는 경우 세션 전면 채널의 전송 크레딧\(예: 작업 채널과 연결된 연결에 대한 RDMA 크레딧\)을 반환하도록 요청합니다. CB\_RECALL\_SLOT은 서버가 세션에 대해 원하는 대상 최고 슬롯 ID의 값인 rsa\_target\_highest\_slotid를 지정합니다. 그런 다음 클라이언트는 세션의 가장 높은 슬롯 ID를 대상 값으로 줄이는 방향으로 진행해야 합니다.\(MUST\)

세션에 작업 채널과 연결된 비RDMA 연결만 있는 경우 클라이언트는 슬롯 ID \> rsa\_target\_highest\_slotid인 모든 미해결 요청이 완료될 때까지 기다린 다음 sa\_highestslot 필드와 함께 단일 SEQUENCE 작업으로 구성된 단일 COMPOUND를 보내면 됩니다. rsa\_target\_highest\_slotid로 설정합니다. 작업 채널과 연결된 RDMA 기반 연결이 있는 경우 클라이언트는 총 RDMA 크레딧 수를 rsa\_target\_highest\_slotid + 1 이하로 가져오기 위해 길이가 0인 "RDMA 보내기" 메시지도 충분히 보내야 합니다.

---
#### **20.8.4.  IMPLEMENTATION**

클라이언트가 포 채널에 있는 가장 높은 슬롯을 서버가 요청한 대로 줄이는 데 실패하면 서버는 포 채널에 바인딩된 모든 연결의 수신 측에서 흐름 제어를 주장하여 문제를 강제로 발생시킨 다음 모든 미해결 요청 서비스를 완료할 수 있습니다. rsa\_target\_highest\_slotid보다 큰 슬롯에 있습니다. 이 작업이 완료되면 서버는 흐름 제어를 열 수 있으며 클라이언트가 rsa\_target\_highest\_slotid보다 큰 슬롯에 새 요청을 보낼 때마다 서버는 NFS4ERR\_BADSLOT을 반환할 수 있습니다.

20.9. 작업 11: CB\_SEQUENCE - 백채널 시퀀싱 및 제어 공급

---
#### **20.9.1.  ARGUMENT**

```text
   struct referring_call4 {
           sequenceid4     rc_sequenceid;
           slotid4         rc_slotid;
   };

   struct referring_call_list4 {
           sessionid4      rcl_sessionid;
           referring_call4 rcl_referring_calls<>;
   };

   struct CB_SEQUENCE4args {
           sessionid4           csa_sessionid;
           sequenceid4          csa_sequenceid;
           slotid4              csa_slotid;
           slotid4              csa_highest_slotid;
           bool                 csa_cachethis;
           referring_call_list4 csa_referring_call_lists<>;
   };
```

---
#### **20.9.2.  RESULT**

```text
   struct CB_SEQUENCE4resok {
           sessionid4         csr_sessionid;
           sequenceid4        csr_sequenceid;
           slotid4            csr_slotid;
           slotid4            csr_highest_slotid;
           slotid4            csr_target_highest_slotid;
   };

   union CB_SEQUENCE4res switch (nfsstat4 csr_status) {
   case NFS4_OK:
           CB_SEQUENCE4resok   csr_resok4;
   default:
           void;
   };
```

---
#### **20.9.3.  DESCRIPTION**

CB\_SEQUENCE 작업은 요청이 전송되는 세션의 백채널에 대한 운영 계정을 관리하는 데 사용됩니다. 내용에는 이 요청이 속한 세션 ID, 세션 요청 제어 및 정확히 한 번 의미 체계를 구현하기 위해 서버에서 사용하는 슬롯 ID 및 시퀀스 ID, 응답 캐시의 크기를 조정하는 데 사용되는 교환된 슬롯 ID 최대값이 포함됩니다. 각 CB\_COMPOUND 요청에서 CB\_SEQUENCE는 한 번 나타나야 하며 첫 번째 작업이어야 합니다. CB\_SEQUENCE가 첫 번째 이후의 CB\_COMPOUND 위치에서 발견되면 NFS4ERR\_SEQUENCE\_POS 오류가 반환되어야 합니다. 다른 작업이 CB\_COMPOUND의 첫 번째 위치에 있으면 NFS4ERR\_OP\_NOT\_IN\_SESSION을 반환해야 합니다.\(MUST, MUST, MUST\)

슬롯 처리 방법에 대한 설명은 섹션 18.46.3을 참조하세요.

csa\_cachethis가 TRUE이면 서버는 클라이언트가 콜백 응답 캐시에 응답을 캐시하도록 요청하는 것입니다. 클라이언트는 응답을 캐시해야 합니다\(섹션 2.10.6.1.3 참조\).\(MUST\)

csa\_referring\_call\_lists 배열은 세션 ID, 슬롯 ID 및 시퀀스 ID로 식별되는 COMPOUND 요청 목록입니다. 이는 클라이언트가 이전에 서버에 보낸 요청입니다. 이러한 이전 요청은 csa\_referring\_call\_lists와 동일한 CB\_COMPOUND의 일부 작업이 식별되는 상태를 생성했습니다. 임대 상태는 클라이언트 ID에 연결되어 있고 클라이언트 ID는 여러 세션을 가질 수 있으므로 세션 ID가 포함됩니다. 섹션 2.10.6.3을 참조하십시오.

슬롯의 캐시된 시퀀스 ID와 관련된 csa\_sequenceid 인수 값은 세 가지 경우 중 하나에 속합니다.

\* csa\_sequenceid와 슬롯 ID에 있는 클라이언트의 캐시된 시퀀스 ID 간의 차이가 2 이상이거나 csa\_sequenceid가 캐시된 시퀀스 ID보다 작은 경우\(서명되지 않은 시퀀스 ID 값의 랩어라운드 고려\) 클라이언트는 다음을 수행해야 합니다. NFS4ERR\_SEQ\_MISORDERED를 반환합니다.\(MUST\)

\* csa\_sequenceid와 캐시된 시퀀스 ID가 동일한 경우 재시도이며 클라이언트는 CB\_COMPOUND 요청의 캐시된 응답을 반환합니다.

\* csa\_sequenceid가 캐시된 시퀀스 ID보다 하나 더 큰 경우\(랩어라운드 고려\) 이는 새 요청이며 슬롯의 시퀀스 ID가 증가됩니다. CB\_SEQUENCE 이후의 작업이 있는 경우 처리됩니다. 다른 작업이 없는 경우 유일한 다른 효과는 슬롯에 CB\_SEQUENCE 응답을 캐시하고 세션 활동을 유지하며 서버가 CB\_SEQUENCE 응답을 받으면 클라이언트 ID와 관련된 상태 임대를 갱신하는 것입니다.

서버가 완전히 다른 요청에 대해 슬롯 ID와 시퀀스 ID를 재사용하는 경우 클라이언트는 해당 요청을 마치 이미 실행한 작업을 재시도하는 것처럼 처리할 수 있습니다. 그러나 클라이언트는 서버의 불법 재사용을 감지하고 NFS4ERR\_SEQ\_FALSE\_RETRY를 반환할 수 있습니다.\(MAY, MAY\)

CB\_SEQUENCE가 오류를 반환하는 경우 슬롯 상태\(시퀀스 ID, 캐시된 응답\)는 변경되어서는 안 됩니다. NFS4ERR\_RETRY\_UNCACHED\_REP 오류가 반환될 수 있는 조건은 섹션 2.10.6.1.3을 참조하세요.\(MUST NOT\)

클라이언트는 두 개의 "highest\_slotid" 값인 csr\_highest\_slotid 및 csr\_target\_highest\_slotid를 반환합니다. 전자는 클라이언트가 향후 CB\_SEQUENCE 작업에서 허용할 가장 높은 슬롯 ID이며 csa\_highest\_slotid 값보다 작아서는 안 됩니다\(그러나 예외는 섹션 2.10.6.1 참조\). 후자는 클라이언트가 향후 CB\_SEQUENCE 작업에서 서버 사용을 선호하는 가장 높은 슬롯 ID입니다.\(SHOULD NOT\)

```text
20.10.  Operation 12: CB_WANTS_CANCELLED - Cancel Pending Delegation
        Wants
```

---
#### **20.10.1.  ARGUMENT**

```text
   struct CB_WANTS_CANCELLED4args {
           bool cwca_contended_wants_cancelled;
           bool cwca_resourced_wants_cancelled;
   };
```

---
#### **20.10.2.  RESULT**

```text
   struct CB_WANTS_CANCELLED4res {
           nfsstat4        cwcr_status;
   };
```

---
#### **20.10.3.  DESCRIPTION**

CB\_WANTS\_CANCELLED 작업은 회수 가능한 위임 및 레이아웃에 대해 등록된 요청 중 일부 또는 전부가 취소되었음을 클라이언트에 알리는 데 사용됩니다.

cwca\_contended\_wants\_cancelled가 TRUE인 경우 이는 서버가 경합 통과 후 사용 가능한 위임을 클라이언트에 푸시하지 않음을 나타냅니다.

cwca\_resourced\_wants\_cancelled가 TRUE인 경우 이는 서버에 위임 또는 레이아웃을 부여할 리소스가 있을 때 서버가 클라이언트에 알리지 않음을 나타냅니다.

CB\_WANTS\_CANCELLED 작업을 받은 후 클라이언트는 기다리고 있던 위임이나 레이아웃을 자유롭게 획득하려고 시도하고 원하는 것을 다시 등록할 수도 있습니다.

---
#### **20.10.4.  IMPLEMENTATION**

클라이언트에 OPEN, WANT\_DELEGATION 또는 GET\_DIR\_DELEGATION 요청이 처리되지 않은 경우 CB\_WANTS\_CANCELLED가 전송되면 서버는 위임 가용성 신호 약속이 CB\_WANTS\_CANCELLED 이전에 발생하여 이에 의해 처리되는지 아니면 이후에 클라이언트에게 명확하게 알려야 할 수 있습니다. CB\_WANTS\_CANCELLED 이 경우에는 적용되지 않습니다. 서버는 연관된 CB\_SEQUENCE의 참조 호출 목록에 적절한 요청을 넣어 이를 구별할 수 있습니다.

20.11. 작업 13: CB\_NOTIFY\_LOCK - 가능한 잠금 가용성을 클라이언트에 알립니다.

---
#### **20.11.1.  ARGUMENT**

```text
   struct CB_NOTIFY_LOCK4args {
       nfs_fh4     cnla_fh;
       lock_owner4 cnla_lock_owner;
   };
```

---
#### **20.11.2.  RESULT**

```text
   struct CB_NOTIFY_LOCK4res {
           nfsstat4        cnlr_status;
   };
```

---
#### **20.11.3.  DESCRIPTION**

서버는 이 작업을 사용하여 클라이언트가 이전에 실패한 LOCK 작업을 통해 요청한 지정된 파일 및 잠금 소유자에 대한 바이트 범위 잠금을 사용할 수 있음을 나타낼 수 있습니다.

이 콜백은 차단 바이트 범위 잠금을 위해 폴링한 클라이언트가 이제 잠금을 획득할 수 있음을 인식하는 경우 차단 잠금의 대기 시간을 줄이는 데 도움이 되도록 서버에서 사용하기 위한 것입니다. 서버가 특정 파일에 대해 이 콜백을 지원하는 경우 해당 파일에 대한 성공적인 열기에 응답할 때 OPEN4\_RESULT\_MAY\_NOTIFY\_LOCK 플래그를 설정해야 합니다. 이는 서버가 CB\_NOTIFY\_LOCK을 사용하도록 커밋하지 않지만 클라이언트는 이를 힌트로 사용하여 해당 열린 항목에서 파생된 잠금을 폴링하는 빈도를 결정할 수 있습니다.\(MUST\)

OPEN 작업으로 인해 반환된 stateid에 이미 할당된 stateid와 일치하는 "other" 값이 있고 표시되는 잠금의 변경을 나타내는 새로운 "seqid"가 있는 업그레이드가 발생하는 경우 OPEN4\_RESULT\_MAY\_NOTIFY\_LOCK 플래그의 값 앞으로 해당 시점부터 처리되는 새로운 OPEN 컨트롤에 응답할 때. 동일한 파일 및 오픈 소유자에 대해 병렬 OPEN이 수행되면 반환된 stateid의 "seqid" 필드 순서\(랩어라운드 적용\)를 사용하여 OPEN4\_RESULT\_MAY\_NOTIFY\_LOCK 플래그의 제어 값을 선택합니다.\(MAY, MAY\)

---
#### **20.11.4.  IMPLEMENTATION**

서버는 클라이언트로부터 LOCK 작업을 수신하지 않는 한 클라이언트에 바이트 범위 잠금을 부여해서는 안 됩니다. 마찬가지로, 이 콜백을 수신하는 클라이언트는 이제 잠금이 설정되어 있거나 잠금에 대한 후속 LOCK 작업이 성공할 것이라고 가정할 수 없습니다.\(MUST NOT\)

서버는 이 콜백을 구현할 필요가 없으며 구현하더라도 특별한 경우에는 사용할 필요가 없습니다. 따라서 클라이언트는 섹션 9.6에 설명된 대로 잠금 차단을 위해 여전히 폴링에 의존해야 합니다.

마찬가지로 클라이언트는 이 콜백을 구현할 필요가 없으며 구현하더라도 여전히 무시할 수 있습니다. 따라서 서버는 클라이언트가 콜백을 기반으로 작동할 것이라고 가정해서는 안 됩니다.\(MUST NOT\)

20.12. 작업 14: CB\_NOTIFY\_DEVICEID - 장치 ID 변경 사항을 클라이언트에 알립니다.

---
#### **20.12.1.  ARGUMENT**

```text
   /*
    * Device notification types.
    */
   enum notify_deviceid_type4 {
           NOTIFY_DEVICEID4_CHANGE = 1,
           NOTIFY_DEVICEID4_DELETE = 2
   };

   /* For NOTIFY4_DEVICEID4_DELETE */
   struct notify_deviceid_delete4 {
           layouttype4     ndd_layouttype;
           deviceid4       ndd_deviceid;
   };

   /* For NOTIFY4_DEVICEID4_CHANGE */
   struct notify_deviceid_change4 {
           layouttype4     ndc_layouttype;
           deviceid4       ndc_deviceid;
           bool            ndc_immediate;
   };

   struct CB_NOTIFY_DEVICEID4args {
           notify4 cnda_changes<>;
   };
```

---
#### **20.12.2.  RESULT**

```text
   struct CB_NOTIFY_DEVICEID4res {
           nfsstat4        cndr_status;
   };
```

---
#### **20.12.3.  DESCRIPTION**

CB\_NOTIFY\_DEVICEID 작업은 서버에서 pNFS 장치 ID 변경 사항에 대한 알림을 클라이언트에 보내는 데 사용됩니다. 장치 ID 알림 등록은 선택 사항이며 GEDEVICEINFO를 통해 수행됩니다. 이러한 알림은 원래 요청이 서버에서 처리되면 백채널을 통해 전송됩니다. 서버는 비트맵과 값 쌍의 목록으로 알림 배열인 cnda\_changes를 보냅니다. NFSv4.1 비트맵 작동 방식에 대한 설명은 섹션 3.3.7을 참조하세요.

CB\_NOTIFY\(섹션 20.4.3\)와 마찬가지로 서버에 CB\_COMPOUND에 들어갈 수 있는 것보다 더 많은 알림이 있을 수 있으므로 여러 CB\_COMPOUND가 필요할 수 있습니다. CB\_NOTIFY와 달리 디렉터리 항목과 달리 장치 ID는 삭제된 후 재사용할 수 없기 때문에 직렬화는 문제가 되지 않습니다\(12.2.10절\).

모든 장치 ID 알림에는 장치 ID와 레이아웃 유형이 포함됩니다. 두 가지 다른 레이아웃 유형이 동일한 장치 ID를 공유할 수 있고 공통 장치 ID가 각 레이아웃 유형에 대해 완전히 다른 매핑을 가질 수 있으므로 레이아웃 유형이 필요합니다.

서버는 다음 알림을 보냅니다.

NOTIFY\_DEVICEID4\_CHANGE

- 이전에 제공된 장치 ID-장치 주소 매핑이 변경되었으며 클라이언트는 GEDEVICEINFO를 사용하여 업데이트된 매핑을 얻습니다. 알림은 inform\_deviceid\_change4 데이터 유형의 값으로 인코딩됩니다. 이 데이터 유형에는 부울 필드인 ndc\_immediate도 포함되어 있습니다. 이 필드가 TRUE이면 변경 사항이 즉시 적용되므로 클라이언트가 장치 ID에 대해 보류 중인 I/O를 완료하지 못할 수도 있음을 나타냅니다. ndc\_immediate가 FALSE이면 클라이언트는 무기한으로 보류 중인 I/O를 완료할 수 있습니다. 보류 중인 I/O가 완료된 후 클라이언트는 장치 ID로 주소가 지정된 저장 장치에 새 I/O 요청을 보내기 전에 새로운 장치 ID-장치 주소 매핑을 가져와야 합니다.\(SHOULD\)

NOTIFY4\_DEVICEID\_DELETE

- 매핑에서 장치 ID를 삭제합니다. 클라이언트에 장치 ID를 참조하는 레이아웃이 있는 경우 이 알림을 보내면 안 됩니다. 즉, 서버가 장치 ID 삭제 알림을 보내는 경우 레이아웃 유형과 연결된 레이아웃에 대해 다음 중 하나가 적용됩니다.\(MUST NOT\)

- \* 클라이언트에는 해당 장치 ID를 참조하는 레이아웃이 없습니다.

- \* 클라이언트가 해당 장치 ID를 참조하는 모든 레이아웃을 반환했습니다.

- \* 서버가 해당 장치 ID를 참조하는 모든 레이아웃을 취소했습니다.

알림은 데이터 유형의 값으로 인코딩됩니다.

-notify\_deviceid\_delete4. 서버가 장치 ID를 삭제한 후에는 클라이언트 ID가 삭제될 때까지 동일한 레이아웃 유형에 대해 해당 장치 ID를 재사용해서는 안 됩니다.\(MUST NOT\)

---
### **20.13.  Operation 10044: CB_ILLEGAL - Illegal Callback Operation**
---
#### **20.13.1.  ARGUMENT**

```text
           void;
```

---
#### **20.13.2.  RESULT**

```text
   /*
    * CB_ILLEGAL: Response for illegal operation numbers
    */
   struct CB_ILLEGAL4res {
           nfsstat4        status;
   };
```

---
#### **20.13.3.  DESCRIPTION**

이 작업은 NFSv4.1 사양에 정의되지 않은 CB\_COMPOUND 내에서 서버가 작업 코드를 보내는 경우를 처리하기 위해 결과를 인코딩하기 위한 자리 표시자입니다. 자세한 내용은 섹션 19.2.3을 참조하세요.

CB\_ILLEGAL4res의 상태 필드는 NFS4ERR\_OP\_ILLEGAL로 설정되어야 합니다.\(MUST\)

---
#### **20.13.4.  IMPLEMENTATION**

서버는 아마도 OP\_CB\_ILLEGAL 코드가 포함된 작업을 보내지 않을 것입니다. 그러나 만약 그렇다면 다른 유효하지 않은 작업 코드와 마찬가지로 응답은 CB\_ILLEGAL4res가 됩니다. 클라이언트가 OP\_ILLEGAL이 아닌 잘못된 연산 코드를 받고 클라이언트가 XDR 디코드 단계 중에 적법한 연산 코드를 확인하는 경우 데이터 유형 CB\_ILLEGAL4res의 인스턴스가 반환되지 않습니다.

---
## **21.  Security Considerations**

역사적으로 NFS의 인증 모델은 최종 사용자를 인증하기 위해 NFS 서버가 NFS 클라이언트를 신뢰하는 NFS 클라이언트인 전체 시스템을 기반으로 했습니다. NFS 서버는 클라이언트의 소스 네트워크 주소로 식별되는 특정 클라이언트에만 파일을 공유했습니다. 이 모델에서 AUTH\_SYS RPC 보안 특성은 NFS 서버에 대한 클라이언트를 사용하는 최종 사용자를 간단히 식별했습니다. NFS 응답을 처리할 때 클라이언트는 요청이 전송된 동일한 네트워크 주소 및 포트 번호에서 응답이 오는지 확인했습니다. 이러한 모델은 구현하기 쉽고 배포 및 사용이 간단하지만 안전하지 않습니다. 따라서 NFSv4.1 구현은 엔드투엔드 인증을 사용하는 보안 모델을 지원해야 합니다. 여기서 클라이언트의 최종 사용자는 \(네트워크에서 암호나 키를 공개하지 않는 암호화 체계를 통해\) 상호 인증합니다. NFS 서버의 주체에. NFS 요청 및 응답의 무결성과 개인 정보 보호도 고려됩니다. 종단 간 상호 인증, 무결성 및 개인 정보 보호 문제는 섹션 2.2.1.1.1에서 논의됩니다. 섹션 2.2.1.1.1.2.1.1에 설명된 대로 Kerberos V5를 사용할 때 특정 고려 사항이 있습니다.\(MUST\)

구현이 필수라는 것이 반드시 사용해야 한다는 의미는 아닙니다. AUTH\_SYS는 NFSv4.1 클라이언트 및 서버에서 사용할 수 있습니다. 그러나 AUTH\_SYS는 NFSv4.1의 선택적 보안 유형일 뿐이므로 AUTH\_SYS를 통한 상호 운용성은 보장되지 않습니다.\(MUST, MAY\)

관리 오버헤드 감소, 성능 향상 및/또는 CPU 사용률 감소로 인해 NFSv4.1 구현 사용자는 각 원격 프로시저 호출 및 응답에서 무결성 보호를 활성화하는 보안 메커니즘 사용을 거부할 수 있습니다. 무결성이 없는 메커니즘을 사용하면 사용자는 RPC 요청 및/또는 응답을 수정하는 NFS 클라이언트 및 서버의 중간자 공격에 취약해집니다. 구현 시 더 약한 보안 메커니즘을 사용하는 옵션을 자유롭게 제공할 수 있지만, 특히 사용자 선택을 무시하는 구현을 보장하는 세 가지 작업이 있습니다.

\* 처음 두 가지 작업은 SECINFO 및 SECINFO\_NO\_NAME입니다. 클라이언트는 rpc\_gss\_svc\_integrity 또는 rpc\_gss\_svc\_privacy 서비스를 사용하여 RPCSEC\_GSS와 같이 무결성 보호 기능이 있는 보안 방식으로 보호되도록 두 작업을 모두 보내는 것이 좋습니다. SECINFO 및 SECINFO\_NO\_NAME과 그 결과를 캡슐화하는 무결성 보호가 없으면 중간자\(man-in-the-middle\)가 결과를 수정하여 클라이언트가 서버에서 허용하는 집합에서 더 약한 알고리즘을 선택할 수 있으므로 클라이언트 및/또는 서버가 추가 공격에 취약해질 수 있습니다. .\(SHOULD\)

\* 무결성 보호를 사용해야 하는 세 번째 작업은 중간자 공격의 심각도를 완화하기 위해 fs\_locations 및 fs\_locations\_info 속성에 대한 GETATTR입니다. 공격에는 두 단계가 있습니다. 먼저 공격자는 NFS4ERR\_MOVED를 반환하도록 일부 작업의 보호되지 않은 결과를 수정합니다. 둘째, 클라이언트가 fs\_locations 또는 fs\_locations\_info 속성에 대한 GETATTR을 추적할 때 공격자는 결과를 수정하여 클라이언트가 공격자가 제어하는 ​​서버로 트래픽을 마이그레이션하도록 합니다. 무결성 보호를 사용하면 이 공격이 완화됩니다.\(SHOULD\)

이전 NFS 버전과 비교하여 NFSv4.1에는 pNFS\(섹션 12.9 및 13.12 참조\), 잠금 및 세션 상태\(섹션 2.10.8.3 참조\) 및 유예 기간 동안의 상태 복구\(섹션 8.4.2.1.1 참조\)에 대한 추가 보안 고려 사항이 있습니다. . 잠금 및 세션 상태와 관련하여 SP4\_SSV 상태 보호가 사용되는 경우 섹션 2.10.10에는 NFSv4.1 클라이언트 및 서버에 대한 특정 보안 고려 사항이 있습니다.

잠금 회수에 대한 보안 고려 사항은 상태 회수가 수행되는 두 가지 상황에 따라 다릅니다. 서버 장애 상황은 섹션 8.4.2.1.1에서 논의되고, 마이그레이션/복제를 지원하기 위해 수행된 per-fs 상태 회수는 섹션 11.11.9.1에서 논의됩니다.

섹션 11에 설명된 다중 서버 네임스페이스 기능을 사용하면 특정 서버에 해당하는 네트워크 주소 집합을 결정하라는 요청이 방해를 받거나 비행 중에 응답이 수정될 가능성이 높아집니다. 이러한 가능성을 고려하여 다음 사항을 고려해야 합니다.

\* DNS를 사용하여 서버 이름을 주소로 변환하고 DNSSEC\[29\]를 사용할 수 없는 경우 일반적으로 반환된 네트워크 주소의 유효성을 신뢰할 수 없습니다. 그러나 신뢰할 수 있는 확인자와 결합하면 TLS를 통한 DNS\[30\] 및 HTTPS를 통한 DNS\[34\]를 사용하여 유효한 주소 확인을 제공할 수 있습니다.

- 제공된 주소의 유효성을 신뢰할 수 없고 클라이언트가 RPCSEC\_GSS를 사용하여 지정된 서버에 액세스하는 상황에서 사용된 RPCSEC\_GSS 구현이 안전하지 않은 DNS 쿼리를 사용하지 않는 한 상호 인증을 통해 잘못된 서버 주소를 검색할 수 있습니다. \[28\]에 설명된 대로 서비스 주체 이름의 호스트 이름 구성 요소를 정규화합니다.

\* 파일 시스템 위치 정보가 포함된 속성 가져오기는 무결성 보호를 사용하여 수행되어야 합니다. 여기서는 무결성 보호를 사용하지 않고 이런 종류의 요청을 하는 클라이언트는 그렇게 할 경우 잘못된 호스트 이름이나 네트워크 주소가 반환될 수 있는 부정적인 결과를 알고 있어야 한다는 점을 기억하는 것이 중요합니다. 여기에는 클라이언트가 공격자의 제어 하에 있는 서버로 연결되는 경우가 포함됩니다. 공격자는 작성된 데이터에 액세스하거나 읽은 데이터에 대해 잘못된 값을 제공할 수 있습니다. 이에 비추어, 클라이언트는 RPCSEC\_GSS를 사용하지 않고\(즉, AUTH\_SYS를 사용하여\) NFSv4 서버에 액세스하기 위해 반환된 위치 정보를 사용하는 것은 클라이언트가 없이 공격자가 제어하는 ​​서버와 상호 작용할 수 있으므로 위험을 초래한다는 점을 인식해야 합니다. 서버의 신원을 확인하기 위한 인증 기능.\(SHOULD\)

\* 구현 시 RPCSEC\_GSS 사용에 대한 "지원"을 제공하는 것이 요구 사항이라는 사실에도 불구하고 특정 클라이언트-서버 쌍 간에 RPCSEC\_GSS 사용이 항상 가능하다고 가정할 수는 없습니다.

\* 클라이언트가 서버의 네트워크 주소를 가지고 있지만 연관된 호스트 이름이 없는 경우 RPCSEC\_GSS를 사용하는 기능을 방해할 수 있습니다.

위의 관점에서 서버는 호스트 이름을 사용하여 다른 서버의 파일 시스템에 해당하는 파일 시스템 위치 항목을 제시해야 합니다. 이를 통해 클라이언트는 무결성 보호를 사용하여 트렁킹 정보\(복제본 정보도 포함\)를 얻기 위해 대상 서버의 fs\_locations를 조사하여 응답이 비행 중에 수정되지 않았는지 확인하면서 제공된 이름의 유효성을 검사할 수 있습니다.\(SHOULD\)

서버에서 RPCSEC\_GSS를 사용할 수 없는 경우 클라이언트는 위치 항목이 비행 중에 수정될 수 있으므로 신뢰할 수 없다는 사실을 인식해야 합니다. NFS4ERR\_MOVED 이후 클라이언트가 다른 서버로 연결되는 경우 지정된 대상 서버에서 RPCSEC\_GSS를 사용하여 제공되는 인증이 무효화될 수 있습니다. 대상에서 RPCSEC\_GSS 인증을 사용할 수 있는 경우에도 서버는 클라이언트가 잘못 지정된 서버로 계속 올바르게 인증될 수 있습니다. 서버가 유효한지 여부를 결정할 수 있는 방법이 없으면 클라이언트는 RPCSEC\_GSS를 사용하여 서버가 제공된 이름에 해당하는지만 확인할 수 있으며 해당 서버를 신뢰할 수 있는 근거는 없습니다. 결과적으로 클라이언트는 대상에서 RPCSEC\_GSS를 사용할 수 있더라도 마이그레이션의 기초로 확인되지 않은 위치 항목을 사용해서는 안 됩니다.\(SHOULD NOT\)

NFS 서버에 연결할 때 파일 시스템 위치 속성을 가져오면 위에서 설명한 대로 무결성 보호를 수행해야 합니다. 이것이 불가능할 경우 일반적으로 클라이언트가 트렁킹 및 복제 정보를 무시하거나 이러한 목적으로 위치 정보를 가져오지 않는 것이 가장 좋습니다.\(SHOULD\)

위치 정보를 확인할 수 없는 경우, 고객에게 부적절한 안내가 발생하는 것을 방지하기 위해 추가 필터링을 실시할 수 있습니다. 예를 들어, AUTH\_SYS를 사용하는 서버와 클라이언트가 적절한 제약 조건\(예: 물리적 네트워크 격리, 사용되는 운영 체제에 대한 관리 제어\)을 따르도록 네트워크 주소 범위를 결정할 수 있는 경우 적절한 범위는 AUTH\_SYS 사용 시 폐기되거나 제한되는 다른 범위와 함께 사용될 수 있습니다.

위치 정보를 가져올 때 RPCSEC\_GSS를 사용하는 것과 관련된 고려 사항을 요약하려면 별도로 도착하는 참조 서버와 대상 서버에 대한 질의 접근 방식을 사용하여 위치 정보를 질의하는 요청에 대해 다음과 같은 가능성을 고려해야 합니다.

\* 무결성 보호가 없으면 클라이언트가 전송 중에 결과가 수정될 가능성에 노출되므로 모든 경우에 무결성 보호를 사용하는 것이 좋습니다.\(SHOULD\)

\* RPCSEC\_GSS 없이 발행된 요청\(즉, 이동 중 데이터 수정을 방지할 수 있는 조항이 없는 AUTH\_SYS 사용\)을 사용하는 것은 바람직하지 않고 잠재적인 보안 노출을 피할 수 없는 경우도 있습니다. 반환된 정보의 사용을 피할 수 없는 경우 클라이언트가 잘못된 주소를 NFSv4 서버인 것처럼 처리할 가능성을 제거하기 위해 위에서 설명한 대로 필터링을 적용합니다. 구체적인 내용은 네트워크 격리 정도와 요청이 참조 서버에 대한 것인지 대상 서버에 대한 것인지에 따라 달라집니다.

이러한 요청이 비행 중에 방해를 받지 않더라도 손상된 서버가 클라이언트에게 공격자가 제어하는 ​​서버와 같은 부적절한 서버를 사용하도록 지시할 수 있습니다. 이러한 서버로 연결되는 것이 손상된 서버 자체로 인해 발생할 수 있는 피해보다 클라이언트에 대한 더 큰 위협인지는 확실하지 않습니다. 그러나 클라이언트를 장기간에 걸쳐 더 큰 피해를 입힐 수 있는 서버로 연결하기 위해 일종의 일시적인 서버 손상이 악용될 수 있습니다. 이러한 가능성을 방지하는 유용한 단계 중 하나는 RPCSEC\_GSS 주체에 대한 매핑을 사용할 수 없더라도 RPCSEC\_GSS를 사용하여 위치 데이터를 가져오는 요청을 보내는 것입니다. 이 경우 RPCSEC\_GSS는 일반적으로 서버에 대한 클라이언트 주체를 식별하는 데 사용되는 것이 아니라 \(RPCSEC\_GSS 상호 인증을 통해\) 접속 중인 서버가 의도한 서버인지 확인하는 데 사용됩니다.

피해야 할 위협이 클라이언트 트래픽을 부적절한\(즉, 성능이 낮은\) 서버로 리디렉션하는 경우에도 비슷한 고려 사항이 적용됩니다. 두 경우 모두 반환된 정보가 이를 요청하는 클라이언트 주체의 신원에 따라 달라질 이유가 없지만 모든 클라이언트 주체에 영향을 미칠 수 있는 서버 정보의 유효성은 상당히 중요합니다.

---
## **22.  IANA Considerations**

이 섹션에서는 \[63\]에 정의된 용어를 사용합니다.

---
### **22.1.  IANA Actions**

이 업데이트에는 NFSv4.1과 관련된 레지스트리 항목 또는 레지스트리 규칙에 대한 수정이나 추가가 필요하지 않습니다. 그러나 이 문서는 RFC 5661을 폐기했기 때문에 IANA는 대신 이 문서를 가리키도록 RFC 5661을 가리키는 모든 레지스트리 항목과 레지스트리 규칙 참조를 업데이트했습니다.

NFSv4.1과 관련된 IANA의 이전 조치는 섹션 22의 나머지 하위 섹션에 나열되어 있습니다.

---
### **22.2.  Named Attribute Definitions**

IANA는 "NFSv4 명명된 속성 정의 레지스트리"라는 레지스트리를 만들었습니다.

NFSv4.1 프로토콜은 0개 이상의 명명된 속성과 파일의 연결을 지원합니다. 이러한 속성의 네임스페이스 식별자는 문자열 이름으로 정의됩니다. 프로토콜은 이러한 파일 속성에 대한 특정 네임스페이스 할당을 정의하지 않습니다. IANA 레지스트리는 공통 이익이 존재하는 곳에서 상호 운용성을 촉진합니다. 애플리케이션 개발자는 필요에 따라 속성을 정의하고 사용할 수 있지만 IANA에 속성을 등록하는 것이 좋습니다.

이렇게 등록된 명명된 속성은 등록 이후에 정의된 버전을 포함하여 NFSv4의 모든 마이너 버전에 적용되는 것으로 추정됩니다. 명명된 속성이 특정 부 버전으로 제한되도록 의도된 경우 이는 레지스트리 할당에 명확하게 명시됩니다.

등록부에 대한 모든 할당은 \[63\]의 섹션 4.4에 따라 선착순으로 이루어집니다. 각 할당에 대한 정책은 \[63\]의 섹션 4.6에 따라 필수 사양입니다.

NFSv4.1 사양에서 명명된 속성의 이름은 이론적으로 최대 2^\(32\) - 1바이트 길이일 수 있지만 실제로 NFSv4.1 클라이언트와 서버는 그렇게 긴 문자열을 처리할 수 없습니다. IANA는 UTF-8 문자 128자를 초과하는 명명된 속성이 있는 할당 요청을 거부해야 합니다. IESG가 실험적 사용 및 표준 조치 할당 기반을 설정할 수 있는 유연성을 제공하기 위해 접두사 "EXPE" 및 "STDS"는 예약되어 있습니다. 길이가 0인 이름이 지정된 속성은 예약되어 있습니다.

접두사 "PRIV"는 개인용으로 지정됩니다. IANA 레지스트리의 할당과 충돌할 위험 없이 등록되지 않은 명명된 속성을 사용하려는 사이트는 모든 명명된 속성에 접두사 "PRIV"를 사용해야 합니다.

일부 NFSv4.1 클라이언트 및 서버에는 대소문자를 구분하지 않는 의미 체계가 있으므로 "EXPE", "PRIV" 및 "STDS" 각각의 추가 소문자 및 대소문자 혼합 순열 15개가 예약되어 있습니다\(예: "expe", "expE" , "exPe" 등은 예약되어 있습니다. 마찬가지로 IANA는 명명된 두 속성이 공통 사례로 변환된 경우 충돌할 수 있는 두 할당을 허용해서는 안 됩니다.

명명된 속성의 레지스트리는 각 할당에 대한 세 개의 필드를 포함하는 할당 목록입니다.

1. 속성의 실제 이름인 US-ASCII 문자열 이름. 이 이름은 고유해야 합니다. 이 문자열 이름의 길이는 1\~128자의 UTF-8 문자일 수 있습니다.

2. 명명된 속성의 사양에 대한 참조. 참조는 최대 256바이트\(또는 IANA에서 허용하는 경우 그 이상\)를 사용할 수 있습니다.

3. 등록자의 연락처. 연락 지점은 최대 256바이트\(또는 IANA에서 허용하는 경우 그 이상\)를 사용할 수 있습니다.

---
#### **22.2.1.  Initial Registry**

초기 레지스트리가 없습니다.

---
#### **22.2.2.  Updating Registrations**

등록자는 항상 연락처 필드를 업데이트할 수 있습니다. 다른 변경 사항에는 전문가 검토 또는 IESG 승인이 필요합니다.

---
### **22.3.  Device ID Notifications**

IANA는 "NFSv4 장치 ID 알림 레지스트리"라는 레지스트리를 만들었습니다.

CB\_NOTIFY\_DEVICEID 작업에 새로운 알림 유형을 추가할 가능성이 있습니다\(섹션 20.12 참조\). 이는 알림을 등록하는 작업을 변경하거나 NFSv4에 새 작업을 추가하여 수행할 수 있습니다. 이를 위해서는 NFSv4의 새로운 마이너 버전이 필요하며 IETF의 표준 트랙 문서가 필요합니다. 알림을 추가하는 또 다른 방법은 새 레이아웃 유형을 지정하는 것입니다\(섹션 22.5 참조\).

따라서 등록소에 대한 모든 할당은 \[63\]의 섹션 4.6에 따라 표준 조치에 따라 이루어지며 전문가 검토가 필요합니다.

레지스트리는 과제 목록으로, 각 과제에는 5개의 필드가 포함되어 있습니다.

1. 통지 유형의 이름. 이 이름에는 "NOTIFY\_DEVICEID4\_" 접두사가 있어야 합니다. 이 이름은 고유해야 합니다.

2. 통지의 가치. IANA는 이 번호를 할당하며 등록자의 요청에는 실제 값 대신 TBD1이 사용됩니다. IANA는 2^\(32\)-1보다 높을 수 없는 정수를 사용해야 하며 다음으로 사용 가능한 값이어야 합니다. 할당된 값은 고유해야 합니다. 알림 유형의 이름과 해당 값이 NFSv4.1 XDR 설명\[10\]의 NFSv4.1 inform\_deviceid\_type4 열거 데이터 유형에 추가될 때 결과가 계속해서 유효한 XDR 설명인지 확인하기 위해 지정 전문가를 사용해야 합니다. .\(MUST\)

3. 통지를 설명하는 표준 추적 RFC입니다. RFC가 아직 게시되지 않은 경우 등록자는 실제 RFC 번호 대신 RFCTBD2, RFCTBD3 등을 사용합니다.

4. RFC가 알림을 소개하는 방법. 이는 단일 US-ASCII 값으로 표시됩니다. 값이 N이면 NFSv4 프로토콜의 사소한 개정을 의미합니다. 값이 L이면 새로운 pNFS 레이아웃 유형을 의미합니다. IESG 승인과 함께 다른 값을 사용할 수 있습니다.

5. 사용이 허용된 NFSv4의 마이너 버전

- 알림. 이는 숫자 값이지만 IANA는 이를 할당하거나 지정하지 않습니다. IESG 승인을 받은 관련 RFC의 작성자가 이 번호를 할당합니다. NFSv4의 새로운 부 버전이 승인될 때마다 지정 전문가는 레지스트리를 검토하여 필요에 따라 권장 업데이트를 작성해야 합니다.

---
#### **22.3.1.  Initial Registry**

초기 레지스트리는 표 25에 있습니다. 사용 가능한 다음 값은 0입니다.

```text
   +=========================+=======+==========+=====+================+
   | Notification Name       | Value | RFC      | How | Minor Versions |
   +=========================+=======+==========+=====+================+
   | NOTIFY_DEVICEID4_CHANGE | 1     | RFC      | N   | 1              |
   |                         |       | 8881     |     |                |
   +-------------------------+-------+----------+-----+----------------+
   | NOTIFY_DEVICEID4_DELETE | 2     | RFC      | N   | 1              |
   |                         |       | 8881     |     |                |
   +-------------------------+-------+----------+-----+----------------+

            Table 25: Initial Device ID Notification Assignments
```

---
#### **22.3.2.  Updating Registrations**

등록을 업데이트하려면 지정 전문가의 조언에 따라 IESG 승인이 필요합니다.

---
### **22.4.  Object Recall Types**

IANA는 "NFSv4 Recallable Object Types Registry"라는 레지스트리를 만들었습니다.

CB\_RECALL\_ANY 작업에 새로운 객체 유형을 추가할 가능성이 있습니다\(섹션 20.6 참조\). 이는 회수 가능한 유형을 추가하는 작업을 변경하거나 NFSv4에 새 작업을 추가하여 수행할 수 있습니다. 이를 위해서는 NFSv4의 새로운 마이너 버전과 IETF의 표준 트랙 문서가 필요합니다. 새로운 호출 가능한 객체를 추가하는 또 다른 방법은 새로운 레이아웃 유형을 지정하는 것입니다\(섹션 22.5 참조\).

레지스트리에 대한 모든 할당은 \[63\]의 섹션 4.9에 따라 표준 조치에 따라 이루어지며 전문가 검토가 필요합니다.

호출 가능한 객체 유형은 32비트 부호 없는 숫자입니다. 예약된 값이 없습니다. 12\~15 범위의 값은 개인용으로 지정됩니다.

레지스트리는 과제 목록으로, 각 과제에는 5개의 필드가 포함되어 있습니다.

1. 회수 가능한 객체 유형의 이름. 이 이름에는 "RCA4\_TYPE\_MASK\_" 접두사가 있어야 합니다. 이름은 고유해야 합니다.

2. 회수 가능한 객체 유형의 값. IANA는 이 번호를 할당하며 등록자의 요청에는 실제 값 대신 TBD1이 사용됩니다. IANA는 2^\(32\)-1보다 높을 수 없는 정수를 사용해야 하며 다음으로 사용 가능한 값이어야 합니다. 값은 고유해야 합니다. 호출 가능한 유형의 이름과 해당 값이 NFSv4 XDR 설명\[10\]에 추가될 때 결과가 계속해서 유효한 XDR 설명이 되도록 지정 전문가를 사용해야 합니다.\(MUST\)

3. 회수 가능한 객체 유형을 설명하는 표준 트랙 RFC. RFC가 아직 게시되지 않은 경우 등록자는 실제 RFC 번호 대신 RFCTBD2, RFCTBD3 등을 사용합니다.

4. RFC가 호출 가능한 객체 유형을 도입하는 방법. 이는 단일 US-ASCII 값으로 표시됩니다. 값이 N이면 NFSv4 프로토콜의 사소한 개정을 의미합니다. 값이 L이면 새로운 pNFS 레이아웃 유형을 의미합니다. IESG 승인과 함께 다른 값을 사용할 수 있습니다.

5. 사용이 허용된 NFSv4의 마이너 버전

- 회수 가능한 객체 유형. 이는 숫자 값이지만 IANA는 이를 할당하거나 할당하지 않습니다. IESG 승인을 받은 관련 RFC의 작성자가 이 번호를 할당합니다. NFSv4의 새로운 부 버전이 승인될 때마다 지정 전문가는 레지스트리를 검토하여 필요에 따라 권장 업데이트를 작성해야 합니다.

---
#### **22.4.1.  Initial Registry**

초기 레지스트리는 표 26에 있습니다. 사용 가능한 다음 값은 5입니다.

```text
     +===============================+=======+======+=====+==========+
     | Recallable Object Type Name   | Value | RFC  | How | Minor    |
     |                               |       |      |     | Versions |
     +===============================+=======+======+=====+==========+
     | RCA4_TYPE_MASK_RDATA_DLG      | 0     | RFC  | N   | 1        |
     |                               |       | 8881 |     |          |
     +-------------------------------+-------+------+-----+----------+
     | RCA4_TYPE_MASK_WDATA_DLG      | 1     | RFC  | N   | 1        |
     |                               |       | 8881 |     |          |
     +-------------------------------+-------+------+-----+----------+
     | RCA4_TYPE_MASK_DIR_DLG        | 2     | RFC  | N   | 1        |
     |                               |       | 8881 |     |          |
     +-------------------------------+-------+------+-----+----------+
     | RCA4_TYPE_MASK_FILE_LAYOUT    | 3     | RFC  | N   | 1        |
     |                               |       | 8881 |     |          |
     +-------------------------------+-------+------+-----+----------+
     | RCA4_TYPE_MASK_BLK_LAYOUT     | 4     | RFC  | L   | 1        |
     |                               |       | 8881 |     |          |
     +-------------------------------+-------+------+-----+----------+
     | RCA4_TYPE_MASK_OBJ_LAYOUT_MIN | 8     | RFC  | L   | 1        |
     |                               |       | 8881 |     |          |
     +-------------------------------+-------+------+-----+----------+
     | RCA4_TYPE_MASK_OBJ_LAYOUT_MAX | 9     | RFC  | L   | 1        |
     |                               |       | 8881 |     |          |
     +-------------------------------+-------+------+-----+----------+

            Table 26: Initial Recallable Object Type Assignments
```

---
#### **22.4.2.  Updating Registrations**

등록을 업데이트하려면 지정 전문가의 조언에 따라 IESG 승인이 필요합니다.

---
### **22.5.  Layout Types**

IANA는 "pNFS 레이아웃 유형 레지스트리"라는 레지스트리를 만들었습니다.

등록소에 대한 모든 할당은 전문가 검토가 필요한 표준 조치에 따라 이루어집니다.

레이아웃 유형은 32비트 숫자입니다. 값 0은 예약되어 있습니다. 0x80000000 \~ 0xFFFFFFFF 범위의 값은 개인용으로 지정됩니다. IANA는 0x00000001부터 0x7FFFFFFFF 범위의 숫자를 할당합니다.

레지스트리는 각각 5개의 필드를 포함하는 할당 목록입니다.

1. 레이아웃 유형의 이름입니다. 이 이름에는 접두사 "LAYOUT4\_"가 있어야 합니다. 이름은 고유해야 합니다.

2. 레이아웃 유형의 값. IANA는 이 번호를 할당하며 등록자의 요청에는 실제 값 대신 TBD1이 사용됩니다. 할당된 값은 고유해야 합니다. 레이아웃 유형의 이름과 해당 값이 NFSv4.1 XDR 설명\[10\]의 NFSv4.1layouttype4 열거 데이터 유형에 추가될 때 결과가 계속해서 유효한 XDR 설명이 되도록 지정 전문가를 사용해야 합니다. .

3. 통지를 설명하는 표준 추적 RFC입니다. RFC가 아직 게시되지 않은 경우 등록자는 실제 RFC 번호 대신 RFCTBD2, RFCTBD3 등을 사용합니다. 전체적으로 RFC는 섹션 22.5.3에 나열된 지침을 준수해야 합니다.

4. RFC가 레이아웃 유형을 도입하는 방법. 이는 단일 US-ASCII 값으로 표시됩니다. 값이 N이면 NFSv4 프로토콜의 사소한 개정을 의미합니다. 값이 L이면 새로운 pNFS 레이아웃 유형을 의미합니다. IESG 승인과 함께 다른 값을 사용할 수 있습니다.

5. 사용이 허용된 NFSv4의 마이너 버전

- 알림. 이는 숫자 값이지만 IANA는 이를 할당하거나 지정하지 않습니다. IESG 승인을 받은 관련 RFC의 작성자가 이 번호를 할당합니다. NFSv4의 새로운 부 버전이 승인될 때마다 지정 전문가는 레지스트리를 검토하여 필요에 따라 권장 업데이트를 작성해야 합니다.

---
#### **22.5.1.  Initial Registry**

초기 레지스트리는 표 27에 있습니다.

```text
    +=======================+=======+==========+=====+================+
    | Layout Type Name      | Value | RFC      | How | Minor Versions |
    +=======================+=======+==========+=====+================+
    | LAYOUT4_NFSV4_1_FILES | 0x1   | RFC 8881 | N   | 1              |
    +-----------------------+-------+----------+-----+----------------+
    | LAYOUT4_OSD2_OBJECTS  | 0x2   | RFC 5664 | L   | 1              |
    +-----------------------+-------+----------+-----+----------------+
    | LAYOUT4_BLOCK_VOLUME  | 0x3   | RFC 5663 | L   | 1              |
    +-----------------------+-------+----------+-----+----------------+

                 Table 27: Initial Layout Type Assignments
```

---
#### **22.5.2.  Updating Registrations**

등록을 업데이트하려면 지정 전문가의 조언에 따라 IESG 승인이 필요합니다.

---
#### **22.5.3.  Guidelines for Writing Layout Type Specifications**

새로운 pNFS 레이아웃 사양 작성자는 레이아웃 유형을 표준 트랙 RFC로 승인하려면 다음 단계를 따라야 합니다.

1. 저자는 새로운 레이아웃 사양을 고안합니다.

2. 새로운 레이아웃 유형 사양은 최소한 다음을 충족해야 합니다.\(MUST\)

- \* 다음 데이터 유형의 레이아웃 유형별 필드 내용을 정의합니다.

```text
          -  the da_addr_body field of the device_addr4 data type;

          -  the loh_body field of the layouthint4 data type;

          -  the loc_body field of layout_content4 data type (which in
             turn is the lo_content field of the layout4 data type);

          -  the lou_body field of the layoutupdate4 data type;
```

- \* 저장 장치에 액세스하는 데 사용되는 저장소 액세스 프로토콜을 설명하거나 정의합니다.

- \* 레이아웃 철회 지원 여부를 기술합니다.

- \* 최소한 다음으로부터 복구 방법을 설명하십시오.

- 1. 클라이언트, 서버, 저장 장치에 장애가 발생하고 다시 시작됩니다.

- 2. 활성 클라이언트, 서버, 저장 장치의 관점에서 임대 만료.

- 3. 저장 장치에 대한 클라이언트 액세스를 차단하는 레이아웃 상태 손실\(예: 섹션 12.7.3 참조\)

- \* 다음을 포함하는 IANA 고려 사항 섹션을 포함합니다.

- - 섹션 22.5에 따라 새로운 레이아웃 유형을 IANA에 요청합니다.

- - CB\_RECALL\_ANY에 대한 새로운 회수 가능한 객체 유형에 대해 IANA에 요청한 목록입니다. 각 항목은 섹션 22.4에 설명된 형식으로 표시됩니다.

- - CB\_NOTIFY\_DEVICEID에 대한 새로운 알림 값을 IANA에 요청하는 목록입니다. 각 항목은 섹션 22.3에 설명된 형식으로 표시됩니다.

- \* 보안 고려 사항 섹션을 포함합니다. 이 섹션에서는 NFSv4.1 인증, 권한 부여 및 액세스 제어 모델이 보존되는 방법을 설명해야 합니다. 즉, 메타데이터 서버가 읽기 또는 쓰기 작업을 제한하는 경우 레이아웃을 통해 pNFS는 어떻게 해당 입력 또는 출력 작업을 유사하게 제한합니까?\(MUST\)

3. 저자는 새로운 레이아웃 사양을 인터넷 초안으로 문서화합니다.

4. 저자는 "인터넷 표준 프로세스 - 개정 3"\(BCP 9 \[35\]\)에 정의된 대로 IETF 표준 프로세스를 통해 검토를 위해 인터넷 초안을 제출합니다. 새로운 레이아웃 사양은 최종 출판을 위해 표준 트랙 RFC로 제출됩니다.

5. 레이아웃 사양은 IETF 표준 프로세스를 통해 진행됩니다.

---
### **22.6.  Path Variable Definitions**

이 섹션에서는 섹션 11.17.3에 설명된 대로 위치 이름에 대한 변수 대체 기능과 관련된 IANA 고려 사항을 다룹니다. 거기에 설명된 대로 대체 대상 변수는 도메인 이름과 해당 도메인 내의 특정 이름으로 구성되며, 두 이름은 콜론으로 구분됩니다. 여기에는 두 가지 IANA 고려 사항이 있습니다.

1. 변수 이름 목록입니다.

2. 각 변수 이름에 대해 가능한 값 목록입니다.

따라서 변수 이름 목록을 위한 하나의 레지스트리와 각 변수 이름의 값을 나열하기 위한 하나의 레지스트리가 있을 수 있습니다.

---
#### **22.6.1.  Path Variables Registry**

IANA는 "NFSv4 경로 변수 레지스트리"라는 레지스트리를 만들었습니다.

---
##### **22.6.1.1.  Path Variable Values**

변수 이름의 형식은 "${", 도메인 이름, 콜론\(":"\), 변수 이름의 도메인별 부분, "}" 형식입니다. 도메인 이름이 "ietf.org"인 경우 모든 변수 이름은 표준 조치에 따라 IANA에 등록되어야 하며 전문가 검토가 필요합니다. ietf.org의 일부도 아니고 같지도 않은 등록된 도메인 이름을 가진 경로 변수는 계층적 할당 기반\(도메인 소유자에게 위임\)으로 할당되므로 도메인 소유자가 자신의 도메인에서 변수 이름을 등록하기로 선택하지 않는 한 IANA와 관련이 없습니다. . 도메인 소유자가 그렇게 하기로 선택한 경우 IANA는 선착순으로 그렇게 합니다. 자신의 도메인이 없는 등록자를 수용하기 위해 IANA는 선착순으로 "${FCFS.ietf.org:" 접두사가 있는 변수를 등록하라는 요청을 수락합니다. 선착순 할당에는 등록자가 IANA가 등록된 변수 값에 대한 레지스트리를 설정하기를 원하지 않는 한 전문가 검토가 필요하지 않습니다.

레지스트리는 각각 세 개의 필드를 포함하는 할당 목록입니다.

1. 변수의 이름. 이 변수의 이름은 "${"로 시작하고 그 뒤에 등록된 도메인 이름, ":"이 와야 합니다. 또는 "${FCFS.ietf.org"로 시작해야 합니다. 이름은 UTF-8 문자 64자 이하여야 합니다. 이름은 고유해야 합니다.

2. 표준 조치 기반으로 이루어진 할당의 경우 변수를 설명하는 표준 추적 RFC입니다. RFC가 아직 게시되지 않은 경우 등록자는 실제 RFC 번호 대신 RFCTBD1, RFCTBD2 등을 사용합니다. RFC는 NFS 부 버전의 일부일 필요는 없습니다. 선착순으로 수행된 할당의 경우 변수의 목적에 대한 설명\(1024바이트 이하 또는 IANA가 허용하는 경우 그 이상 사용\). 설명을 참조하여 대체할 수 있습니다.

3. 이메일 주소를 포함한 연락처. 연락 지점은 최대 256바이트\(또는 IANA에서 허용하는 경우 그 이상\)를 사용할 수 있습니다. 표준 조치에 따라 수행된 과제의 경우 연락 지점은 항상 IESG입니다.

---
###### **22.6.1.1.1.  Initial Registry**

초기 레지스트리는 표 28에 있습니다.

```text
         +========================+==========+==================+
         | Variable Name          | RFC      | Point of Contact |
         +========================+==========+==================+
         | ${ietf.org:CPU_ARCH}   | RFC 8881 | IESG             |
         +------------------------+----------+------------------+
         | ${ietf.org:OS_TYPE}    | RFC 8881 | IESG             |
         +------------------------+----------+------------------+
         | ${ietf.org:OS_VERSION} | RFC 8881 | IESG             |
         +------------------------+----------+------------------+

                 Table 28: Initial List of Path Variables
```

IANA는 변수 이름 ${ietf.org:CPU\_ARCH} 및 ${ietf.org:OS\_TYPE}의 값에 대한 레지스트리를 생성했습니다. 섹션 22.6.2 및 22.6.3을 참조하십시오.

${ietf.org:OS\_VERSION} 변수 값의 경우 변수 값의 세부 사항이 ${ietf.org:OS\_TYPE} 값에 따라 달라지므로 레지스트리가 필요하지 않습니다. 따라서 ${ietf.org:OS\_VERSION}의 값은 계층적 할당을 기반으로 하며 IANA와 관련이 없습니다.

---
###### **22.6.1.1.2.  Updating Registrations**

표준 조치에 따라 수행된 과제를 업데이트하려면 지정 전문가의 조언에 따라 IESG 승인이 필요합니다.

등록자는 선착순으로 이루어진 과제의 연락처를 언제든지 업데이트할 수 있습니다. 다른 업데이트에는 전문가 검토가 필요합니다.

---
#### **22.6.2.  Values for the ${ietf.org:CPU_ARCH} Variable**

IANA는 "NFSv4 ${ietf.org:CPU\_ARCH} 값 레지스트리"라는 레지스트리를 만들었습니다.

레지스트리에 대한 할당은 선착순으로 이루어집니다. ${ietf.org:CPU\_ARCH}의 길이가 0인 값은 예약되어 있습니다. 접두사 "PRIV"가 붙은 값은 개인용으로 지정됩니다.

레지스트리는 각각 세 개의 필드를 포함하는 할당 목록입니다.

1. ${ietf.org:CPU\_ARCH} 변수의 값. 값은 1\~32자의 UTF-8 문자여야 합니다. 값은 고유해야 합니다.

2. 값이 나타내는 CPU 아키텍처에 대한 설명\(1024바이트 이하 또는 IANA가 허용하는 경우 그 이상을 소비하지 않음\). 설명을 참조하여 대체할 수 있습니다.

3. 이메일 주소를 포함한 연락처. 연락 지점은 최대 256바이트\(또는 IANA에서 허용하는 경우 그 이상\)를 사용할 수 있습니다.

---
##### **22.6.2.1.  Initial Registry**

초기 레지스트리가 없습니다.

---
##### **22.6.2.2.  Updating Registrations**

등록자는 과제를 자유롭게 업데이트할 수 있습니다. 즉, 설명 및/또는 연락처 필드를 변경할 수 있습니다.

---
#### **22.6.3.  Values for the ${ietf.org:OS_TYPE} Variable**

IANA는 "NFSv4 ${ietf.org:OS\_TYPE} 값 레지스트리"라는 레지스트리를 만들었습니다.

레지스트리에 대한 할당은 선착순으로 이루어집니다. ${ietf.org:OS\_TYPE}의 길이가 0인 값은 예약되어 있습니다. 접두사 "PRIV"가 붙은 값은 개인용으로 지정됩니다.

레지스트리는 각각 세 개의 필드를 포함하는 할당 목록입니다.

1. ${ietf.org:OS\_TYPE} 변수의 값. 값은 1\~32자의 UTF-8 문자여야 합니다. 값은 고유해야 합니다.

2. 값이 나타내는 CPU 아키텍처에 대한 설명\(1024바이트 이하 또는 IANA가 허용하는 경우 그 이상을 소비하지 않음\). 설명을 참조하여 대체할 수 있습니다.

3. 이메일 주소를 포함한 연락처. 연락 지점은 최대 256바이트\(또는 IANA에서 허용하는 경우 그 이상\)를 사용할 수 있습니다.

---
##### **22.6.3.1.  Initial Registry**

초기 레지스트리가 없습니다.

---
##### **22.6.3.2.  Updating Registrations**

등록자는 과제를 자유롭게 업데이트할 수 있습니다. 즉, 설명 및/또는 연락처 필드를 변경할 수 있습니다.

---
## **23.  References**
---
### **23.1.  Normative References**

```text
   [1]        Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", BCP 14, RFC 2119,
              DOI 10.17487/RFC2119, March 1997,
              <https://www.rfc-editor.org/info/rfc2119>.

   [2]        Eisler, M., Ed., "XDR: External Data Representation
              Standard", STD 67, RFC 4506, DOI 10.17487/RFC4506, May
              2006, <https://www.rfc-editor.org/info/rfc4506>.

   [3]        Thurlow, R., "RPC: Remote Procedure Call Protocol
              Specification Version 2", RFC 5531, DOI 10.17487/RFC5531,
              May 2009, <https://www.rfc-editor.org/info/rfc5531>.

   [4]        Eisler, M., Chiu, A., and L. Ling, "RPCSEC_GSS Protocol
              Specification", RFC 2203, DOI 10.17487/RFC2203, September
              1997, <https://www.rfc-editor.org/info/rfc2203>.

   [5]        Zhu, L., Jaganathan, K., and S. Hartman, "The Kerberos
              Version 5 Generic Security Service Application Program
              Interface (GSS-API) Mechanism: Version 2", RFC 4121,
              DOI 10.17487/RFC4121, July 2005,
              <https://www.rfc-editor.org/info/rfc4121>.

   [6]        The Open Group, "Section 3.191 of Chapter 3 of Base
              Definitions of The Open Group Base Specifications Issue 6
              IEEE Std 1003.1, 2004 Edition, HTML Version",
              ISBN 1931624232, 2004, <https://www.opengroup.org>.

   [7]        Linn, J., "Generic Security Service Application Program
              Interface Version 2, Update 1", RFC 2743,
              DOI 10.17487/RFC2743, January 2000,
              <https://www.rfc-editor.org/info/rfc2743>.

   [8]        Recio, R., Metzler, B., Culley, P., Hilland, J., and D.
              Garcia, "A Remote Direct Memory Access Protocol
              Specification", RFC 5040, DOI 10.17487/RFC5040, October
              2007, <https://www.rfc-editor.org/info/rfc5040>.

   [9]        Eisler, M., "RPCSEC_GSS Version 2", RFC 5403,
              DOI 10.17487/RFC5403, February 2009,
              <https://www.rfc-editor.org/info/rfc5403>.

   [10]       Shepler, S., Ed., Eisler, M., Ed., and D. Noveck, Ed.,
              "Network File System (NFS) Version 4 Minor Version 1
              External Data Representation Standard (XDR) Description",
              RFC 5662, DOI 10.17487/RFC5662, January 2010,
              <https://www.rfc-editor.org/info/rfc5662>.

   [11]       The Open Group, "Section 3.372 of Chapter 3 of Base
              Definitions of The Open Group Base Specifications Issue 6
              IEEE Std 1003.1, 2004 Edition, HTML Version",
              ISBN 1931624232, 2004, <https://www.opengroup.org>.

   [12]       Eisler, M., "IANA Considerations for Remote Procedure Call
              (RPC) Network Identifiers and Universal Address Formats",
              RFC 5665, DOI 10.17487/RFC5665, January 2010,
              <https://www.rfc-editor.org/info/rfc5665>.

   [13]       The Open Group, "Section 'read()' of System Interfaces of
              The Open Group Base Specifications Issue 6 IEEE Std
              1003.1, 2004 Edition, HTML Version", ISBN 1931624232,
              2004, <https://www.opengroup.org>.

   [14]       The Open Group, "Section 'readdir()' of System Interfaces
              of The Open Group Base Specifications Issue 6 IEEE Std
              1003.1, 2004 Edition, HTML Version", ISBN 1931624232,
              2004, <https://www.opengroup.org>.

   [15]       The Open Group, "Section 'write()' of System Interfaces of
              The Open Group Base Specifications Issue 6 IEEE Std
              1003.1, 2004 Edition, HTML Version", ISBN 1931624232,
              2004, <https://www.opengroup.org>.

   [16]       Hoffman, P. and M. Blanchet, "Preparation of
              Internationalized Strings ("stringprep")", RFC 3454,
              DOI 10.17487/RFC3454, December 2002,
              <https://www.rfc-editor.org/info/rfc3454>.

   [17]       The Open Group, "Section 'chmod()' of System Interfaces of
              The Open Group Base Specifications Issue 6 IEEE Std
              1003.1, 2004 Edition, HTML Version", ISBN 1931624232,
              2004, <https://www.opengroup.org>.
```

\[18\] 국제표준화기구,

- "정보 기술 - 범용 다중 옥텟 코드 문자 집합\(UCS\) - 1부: 아키텍처 및 기본 다국어 평면", ISO 표준 10646-1, 1993년 5월.

```text
   [19]       Alvestrand, H., "IETF Policy on Character Sets and
              Languages", BCP 18, RFC 2277, DOI 10.17487/RFC2277,
              January 1998, <https://www.rfc-editor.org/info/rfc2277>.

   [20]       Hoffman, P. and M. Blanchet, "Nameprep: A Stringprep
              Profile for Internationalized Domain Names (IDN)",
              RFC 3491, DOI 10.17487/RFC3491, March 2003,
              <https://www.rfc-editor.org/info/rfc3491>.

   [21]       The Open Group, "Section 'fcntl()' of System Interfaces of
              The Open Group Base Specifications Issue 6 IEEE Std
              1003.1, 2004 Edition, HTML Version", ISBN 1931624232,
              2004, <https://www.opengroup.org>.

   [22]       The Open Group, "Section 'fsync()' of System Interfaces of
              The Open Group Base Specifications Issue 6 IEEE Std
              1003.1, 2004 Edition, HTML Version", ISBN 1931624232,
              2004, <https://www.opengroup.org>.

   [23]       The Open Group, "Section 'getpwnam()' of System Interfaces
              of The Open Group Base Specifications Issue 6 IEEE Std
              1003.1, 2004 Edition, HTML Version", ISBN 1931624232,
              2004, <https://www.opengroup.org>.

   [24]       The Open Group, "Section 'unlink()' of System Interfaces
              of The Open Group Base Specifications Issue 6 IEEE Std
              1003.1, 2004 Edition, HTML Version", ISBN 1931624232,
              2004, <https://www.opengroup.org>.

   [25]       Schaad, J., Kaliski, B., and R. Housley, "Additional
              Algorithms and Identifiers for RSA Cryptography for use in
              the Internet X.509 Public Key Infrastructure Certificate
              and Certificate Revocation List (CRL) Profile", RFC 4055,
              DOI 10.17487/RFC4055, June 2005,
              <https://www.rfc-editor.org/info/rfc4055>.

   [26]       National Institute of Standards and Technology, "Computer
              Security Objects Register", May 2016,
              <https://csrc.nist.gov/projects/computer-security-objects-
              register/algorithm-registration>.

   [27]       Adamson, A. and N. Williams, "Remote Procedure Call (RPC)
              Security Version 3", RFC 7861, DOI 10.17487/RFC7861,
              November 2016, <https://www.rfc-editor.org/info/rfc7861>.

   [28]       Neuman, C., Yu, T., Hartman, S., and K. Raeburn, "The
              Kerberos Network Authentication Service (V5)", RFC 4120,
              DOI 10.17487/RFC4120, July 2005,
              <https://www.rfc-editor.org/info/rfc4120>.

   [29]       Arends, R., Austein, R., Larson, M., Massey, D., and S.
              Rose, "DNS Security Introduction and Requirements",
              RFC 4033, DOI 10.17487/RFC4033, March 2005,
              <https://www.rfc-editor.org/info/rfc4033>.

   [30]       Hu, Z., Zhu, L., Heidemann, J., Mankin, A., Wessels, D.,
              and P. Hoffman, "Specification for DNS over Transport
              Layer Security (TLS)", RFC 7858, DOI 10.17487/RFC7858, May
              2016, <https://www.rfc-editor.org/info/rfc7858>.

   [31]       Adamson, A. and N. Williams, "Requirements for NFSv4
              Multi-Domain Namespace Deployment", RFC 8000,
              DOI 10.17487/RFC8000, November 2016,
              <https://www.rfc-editor.org/info/rfc8000>.

   [32]       Lever, C., Ed., Simpson, W., and T. Talpey, "Remote Direct
              Memory Access Transport for Remote Procedure Call Version
              1", RFC 8166, DOI 10.17487/RFC8166, June 2017,
              <https://www.rfc-editor.org/info/rfc8166>.

   [33]       Lever, C., "Network File System (NFS) Upper-Layer Binding
              to RPC-over-RDMA Version 1", RFC 8267,
              DOI 10.17487/RFC8267, October 2017,
              <https://www.rfc-editor.org/info/rfc8267>.

   [34]       Hoffman, P. and P. McManus, "DNS Queries over HTTPS
              (DoH)", RFC 8484, DOI 10.17487/RFC8484, October 2018,
              <https://www.rfc-editor.org/info/rfc8484>.

   [35]       Bradner, S., "The Internet Standards Process -- Revision
              3", BCP 9, RFC 2026, October 1996.
```

- Kolkman, O., Bradner, S. 및 S. Turner, "제안된 표준의 특성화", BCP 9, RFC 7127, 2014년 1월.

- Dusseault, L. 및 R. Sparks, "초안 표준으로의 발전을 위한 상호 운용 및 구현 보고서에 대한 지침", BCP 9, RFC 5657, 2009년 9월.

- Housley, R., Crocker, D. 및 E. Burger, "표준 트랙을 두 가지 성숙도 수준으로 축소", BCP 9, RFC 6410, 2011년 10월.

- Resnick, P., ""인터넷 공식 프로토콜 표준" 요약 문서 폐기", BCP 9, RFC 7100, 2013년 12월.

- Dawkins, S., "IETF 영역에서 지역 이사 수 늘리기", BCP 9, RFC 7475, 2015년 3월.

```text
              <https://www.rfc-editor.org/info/bcp9>
```

---
### **23.2.  Informative References**

```text
   [36]       Roach, A., "Process for Handling Non-Major Revisions to
              Existing RFCs", Work in Progress, Internet-Draft, draft-
              roach-bis-documents-00, 7 May 2019,
              <https://tools.ietf.org/html/draft-roach-bis-documents-
              00>.

   [37]       Shepler, S., Callaghan, B., Robinson, D., Thurlow, R.,
              Beame, C., Eisler, M., and D. Noveck, "Network File System
              (NFS) version 4 Protocol", RFC 3530, DOI 10.17487/RFC3530,
              April 2003, <https://www.rfc-editor.org/info/rfc3530>.

   [38]       Callaghan, B., Pawlowski, B., and P. Staubach, "NFS
              Version 3 Protocol Specification", RFC 1813,
              DOI 10.17487/RFC1813, June 1995,
              <https://www.rfc-editor.org/info/rfc1813>.

   [39]       Eisler, M., "LIPKEY - A Low Infrastructure Public Key
              Mechanism Using SPKM", RFC 2847, DOI 10.17487/RFC2847,
              June 2000, <https://www.rfc-editor.org/info/rfc2847>.

   [40]       Eisler, M., "NFS Version 2 and Version 3 Security Issues
              and the NFS Protocol's Use of RPCSEC_GSS and Kerberos V5",
              RFC 2623, DOI 10.17487/RFC2623, June 1999,
              <https://www.rfc-editor.org/info/rfc2623>.
```

\[41\] Juszczak, C., "NFS 서버의 성능 및 정확성 향상", USENIX 회의 논문집, 1990년 6월.

```text
   [42]       Reynolds, J., Ed., "Assigned Numbers: RFC 1700 is Replaced
              by an On-line Database", RFC 3232, DOI 10.17487/RFC3232,
              January 2002, <https://www.rfc-editor.org/info/rfc3232>.

   [43]       Srinivasan, R., "Binding Protocols for ONC RPC Version 2",
              RFC 1833, DOI 10.17487/RFC1833, August 1995,
              <https://www.rfc-editor.org/info/rfc1833>.

   [44]       Werme, R., "RPC XID Issues", USENIX Conference
              Proceedings, February 1996.

   [45]       Nowicki, B., "NFS: Network File System Protocol
              specification", RFC 1094, DOI 10.17487/RFC1094, March
              1989, <https://www.rfc-editor.org/info/rfc1094>.
```

\[46\] Bhide, A., Elnozahy, E. N. 및 S. P. Morgan, "고가용성 네트워크 서버", USENIX Conference Proceedings, 1991년 1월.

```text
   [47]       Halevy, B., Welch, B., and J. Zelenka, "Object-Based
              Parallel NFS (pNFS) Operations", RFC 5664,
              DOI 10.17487/RFC5664, January 2010,
              <https://www.rfc-editor.org/info/rfc5664>.

   [48]       Black, D., Fridella, S., and J. Glasgow, "Parallel NFS
              (pNFS) Block/Volume Layout", RFC 5663,
              DOI 10.17487/RFC5663, January 2010,
              <https://www.rfc-editor.org/info/rfc5663>.

   [49]       Callaghan, B., "WebNFS Client Specification", RFC 2054,
              DOI 10.17487/RFC2054, October 1996,
              <https://www.rfc-editor.org/info/rfc2054>.

   [50]       Callaghan, B., "WebNFS Server Specification", RFC 2055,
              DOI 10.17487/RFC2055, October 1996,
              <https://www.rfc-editor.org/info/rfc2055>.

   [51]       IESG, "IESG Processing of RFC Errata for the IETF Stream",
              July 2008,
              <https://www.ietf.org/about/groups/iesg/statements/
              processing-rfc-errata/>.

   [52]       Krawczyk, H., Bellare, M., and R. Canetti, "HMAC: Keyed-
              Hashing for Message Authentication", RFC 2104,
              DOI 10.17487/RFC2104, February 1997,
              <https://www.rfc-editor.org/info/rfc2104>.

   [53]       Shepler, S., "NFS Version 4 Design Considerations",
              RFC 2624, DOI 10.17487/RFC2624, June 1999,
              <https://www.rfc-editor.org/info/rfc2624>.
```

\[54\] The Open Group, "상호 작업을 위한 프로토콜: XNFS, 버전 3W", ISBN 1-85912-184-5, 1998년 2월.

\[55\] Floyd, S. 및 V. Jacobson, "주기적인 라우팅 메시지의 동기화", 네트워킹의 IEEE/ACM 트랜잭션, 2\(2\), pp. 122-136, 1994년 4월.

```text
   [56]       Chadalapaka, M., Satran, J., Meth, K., and D. Black,
              "Internet Small Computer System Interface (iSCSI) Protocol
              (Consolidated)", RFC 7143, DOI 10.17487/RFC7143, April
              2014, <https://www.rfc-editor.org/info/rfc7143>.
```

\[57\] Snively, R., "SCSI용 파이버 채널 프로토콜, 2차 버전\(FCP-2\)", ANSI/INCITS, 350-2003, 2003년 10월.

```text
   [58]       Weber, R.O., "Object-Based Storage Device Commands (OSD)",
              ANSI/INCITS, 400-2004, July 2004,
              <https://www.t10.org/drafts.htm>.
```

\[59\] Carns, P. H., Ligon III, W. B., Ross, R. B. 및 R. Thakur, "PVFS: Linux 클러스터용 병렬 파일 시스템.", 제4회 연례 Linux 쇼케이스 및 컨퍼런스 진행, 2000.

```text
   [60]       The Open Group, "The Open Group Base Specifications Issue
              6, IEEE Std 1003.1, 2004 Edition", 2004,
              <https://www.opengroup.org>.

   [61]       Callaghan, B., "NFS URL Scheme", RFC 2224,
              DOI 10.17487/RFC2224, October 1997,
              <https://www.rfc-editor.org/info/rfc2224>.

   [62]       Chiu, A., Eisler, M., and B. Callaghan, "Security
              Negotiation for WebNFS", RFC 2755, DOI 10.17487/RFC2755,
              January 2000, <https://www.rfc-editor.org/info/rfc2755>.

   [63]       Cotton, M., Leiba, B., and T. Narten, "Guidelines for
              Writing an IANA Considerations Section in RFCs", BCP 26,
              RFC 8126, DOI 10.17487/RFC8126, June 2017,
              <https://www.rfc-editor.org/info/rfc8126>.

   [64]       RFC Errata, Erratum ID 2006, RFC 5661,
              <https://www.rfc-editor.org/errata/eid2006>.

   [65]       Spasojevic, M. and M. Satayanarayanan, "An Empirical Study
              of a Wide-Area Distributed File System", ACM Transactions
              on Computer Systems, Vol. 14, No. 2, pp. 200-222,
              DOI 10.1145/227695.227698, May 1996,
              <https://doi.org/10.1145/227695.227698>.

   [66]       Shepler, S., Ed., Eisler, M., Ed., and D. Noveck, Ed.,
              "Network File System (NFS) Version 4 Minor Version 1
              Protocol", RFC 5661, DOI 10.17487/RFC5661, January 2010,
              <https://www.rfc-editor.org/info/rfc5661>.

   [67]       Noveck, D., "Rules for NFSv4 Extensions and Minor
              Versions", RFC 8178, DOI 10.17487/RFC8178, July 2017,
              <https://www.rfc-editor.org/info/rfc8178>.

   [68]       Haynes, T., Ed. and D. Noveck, Ed., "Network File System
              (NFS) Version 4 Protocol", RFC 7530, DOI 10.17487/RFC7530,
              March 2015, <https://www.rfc-editor.org/info/rfc7530>.

   [69]       Noveck, D., Ed., Shivam, P., Lever, C., and B. Baker,
              "NFSv4.0 Migration: Specification Update", RFC 7931,
              DOI 10.17487/RFC7931, July 2016,
              <https://www.rfc-editor.org/info/rfc7931>.

   [70]       Haynes, T., "Requirements for Parallel NFS (pNFS) Layout
              Types", RFC 8434, DOI 10.17487/RFC8434, August 2018,
              <https://www.rfc-editor.org/info/rfc8434>.

   [71]       Farrell, S. and H. Tschofenig, "Pervasive Monitoring Is an
              Attack", BCP 188, RFC 7258, DOI 10.17487/RFC7258, May
              2014, <https://www.rfc-editor.org/info/rfc7258>.

   [72]       Rescorla, E. and B. Korver, "Guidelines for Writing RFC
              Text on Security Considerations", BCP 72, RFC 3552,
              DOI 10.17487/RFC3552, July 2003,
              <https://www.rfc-editor.org/info/rfc3552>.
```

---
# **Appendix A.  The Need for This Update**

이 문서에는 클라이언트와 서버가 파일 시스템에 액세스하는 데 사용할 특정 네트워크 액세스 경로를 결정하는 방법에 대한 설명이 포함되어 있습니다. 여기에는 사용할 특정 복제본이나 이에 액세스하는 데 사용할 주소 집합의 변경 사항을 처리하는 방법과 필요한 책임 이전을 투명하게 처리하는 방법에 대한 설명이 포함됩니다. 여기에는 하나의 복제본과 다른 복제본 간에 이동이 있는 경우와 동일한 복제본에 액세스하기 위해 서로 다른 네트워크 액세스 경로가 사용되는 경우가 포함됩니다.

RFC 5661 \[66\]의 다음 문제로 인해 이 문서에 포함된 특정 업데이트를 제공해야 했습니다. 이러한 업데이트는 부록 B에 설명되어 있습니다.

\* RFC 5661 \[66\]은 다양한 형태의 클러스터링을 통해 협력 서버가 할당한 상태 조정을 허용하는 상황을 다루었지만 Transparent State Migration에 대한 조항은 제시하지 않았습니다. NFSv4.0 내에서 Transparent State Migration은 RFC 7530 \[68\]에서 처음으로 명확하게 설명되었고 RFC 7931 \[69\]에서 수정되고 명확해졌습니다. NFSv4.1에 대한 해당 설명은 제공되지 않았습니다.

\* NFSv4.1은 트렁킹 검색이 수행되는 방법에 대한 명확한 정의를 제공했지만, 이 정보가 파일을 통해 제공될 수 있다는 사양이 명확하게 표시되었음에도 불구하고 트렁킹 검색이 수행되는 방법에 대한 명확한 사양은 없었습니다. 시스템 위치 속성.

\* 동일한 파일 시스템에 대한 네트워크 접근 경로가 여러 개 존재하는 것을 마치 여러 개의 복제본이 있는 것처럼 다루었기 때문에, 복제본 간 전환과 관련된 문제는 특정 파일 시스템에 접속하는 데 사용된 주소 간의 트렁킹 관련 전환과 명확하게 구분할 수 없습니다. 사례. 결과적으로 마이그레이션과 트렁킹 구성 변경이 모두 관련된 상황에서는 둘 중 어느 것도 명확하게 처리될 수 없었고, 이 두 기능 간의 관계도 심각하게 다루어지지 않았습니다.

\* 동일한 파일 시스템 인스턴스\(예: 트렁킹\)에 대한 두 개의 네트워크 액세스 경로를 사용하는 것은 두 개의 복제본이 관련된 것처럼 처리되는 경우가 많았기 때문에 두 개의 복제본이 동시에 사용되는 것으로 간주되었습니다. 결과적으로 RFC 5661 \[66\]에서 동시에 사용되는 복제본의 처리는 명확하지 않았습니다. 이는 단일 파일 시스템 인스턴스가 두 개의 다른 네트워크 액세스 경로에 의해 액세스되고 두 개의 복제본이 동시에 액세스되는 두 가지 별개의 경우를 다루었기 때문입니다. 후자의 경우에는 한계가 명확하게 제시되어 있지 않습니다.

이러한 문제로 인한 결과의 대부분은 RFC 5661 \[66\]의 섹션 11을 대체하는 섹션 11을 제시하여 처리됩니다. 이 교체는 해당 섹션 내의 기존 하위 섹션을 수정하고 부록 B.1에 설명된 대로 새 하위 섹션을 추가합니다. 또한 일부 기존 섹션이 삭제되었습니다. 이러한 변경은 다음을 수행하기 위해 이루어졌습니다.

\* 동일한 파일 시스템 인스턴스에 대한 두 개의 네트워크 액세스 경로가 있는 경우와 두 개의 다른 복제본이 있는 경우가 명확하게 구별되도록 설명을 재구성합니다. 전자의 경우 잠금 상태가 공유되고 세션 상태도 공유될 수 있기 때문입니다.

\* 바람직하다는 점에 대해 명확한 설명을 제공합니다.

- 투명한 전송 또는 단일 fs 유예 기간이 제공되는 권장 사항과 함께 복제본 간의 투명한 상태 전송.

\* NFSv4.1의 주요 프로토콜 변경으로 인해 필요한 \[69\] 처리와의 차이점을 고려하여 클라이언트가 이러한 전송을 처리하는 방법을 구체적으로 설명합니다.

\* 투명한 상태 전송과 병렬 NFS\(pNFS\) 간의 관계를 논의합니다.

\* 제공된 정보 중 어느 부분이 특정 네트워크 액세스 경로에 적용되고 어느 부분이 해당 경로를 사용하여 액세스하는 복제본에 적용되는지 지정하려면 fs\_locations\_info 속성을 명확히 하십시오.

또한 다중 서버 네임스페이스 문제 처리에 깔려 있는 잘못된 가정의 결과를 수정하기 위해 RFC 5661\[66\]의 다른 섹션이 업데이트되었습니다. 이에 대해서는 부록 B.2부터 B.4까지 설명되어 있습니다.

\* 다중 서버 네임스페이스 기능에 대한 개정된 소개 섹션이 제공됩니다.

\* 서버 범위에 대한 보다 현실적인 처리가 제공됩니다. 이 처리는 실제로 공통 서버 범위를 공유하는 서버가 채택한 잠금 상태의 보다 제한된 조정을 반영합니다.

\* server\_owner 변경과 관련된 일부 혼란스러운 텍스트가 명확해졌습니다.

\* 일부 기존 오류에 대한 설명은 트렁킹의 존재와 fs 관련 유예 기간의 사용 가능성을 반영하여 특정 오류 상황을 더 명확하게 설명하도록 수정되었습니다. 자세한 내용은 부록 B.3을 참조하세요.

\* 기존 처리가 Transparent State Migration을 처리할 때 발생할 수 있는 상황을 설명하지 못했거나 일부 유형의 회수 문제가 fs 관련 은혜의 맥락에서 적절하게 처리되지 않았기 때문에 특정 기존 작업에 대한 새로운 설명이 제공됩니다. 미문. 자세한 내용은 부록 B.2를 참조하세요.

---
# **Appendix B.  Changes in This Update**
---
### **B.1.  Revisions Made to Section 11 of RFC 5661**

많은 영역이 수정되거나 확장되었으며, 많은 경우 RFC 5661 \[66\]의 섹션 11 내의 하위 섹션을 대체했습니다.

\* 용어 섹션을 포함한 새로운 소개 자료는 원본 섹션 11의 시작 부분부터 섹션 11.1까지에 걸쳐 RFC 5661 \[66\]의 자료를 대체합니다. 새로운 자료는 섹션 11의 시작 부분에서 시작하여 11.2까지 계속됩니다.

\* RFC 5661 \[66\]의 섹션 11.4 및 11.5에 있는 자료를 대폭 재구성해야 했습니다. 이러한 섹션을 여러 하위 섹션이 포함된 단일 섹션으로 재구성한 이유는 아래 부록 B.1.1에서 설명합니다. 이 대체 항목은 섹션 11.5로 나타납니다.

- 파일 시스템 위치 속성 처리와 관련된 새로운 자료는 섹션 11.5.1 및 11.5.7에 포함되어 있습니다.

\* 다중 서버 네임스페이스 내에서 사용자 및 그룹 처리에 대한 요구 사항을 설명하는 새로운 섹션이 섹션 11.7로 추가되었습니다.

\* "Effecting File System Transitions"라는 제목의 RFC 5661 \[66\] 섹션 11.7의 주요 대체 항목은 섹션 11.9부터 11.14까지로 나타납니다. 이 섹션을 여러 섹션으로 재구성한 이유는 부록 B.1.2에서 설명합니다.

\* "속성 fs\_locations\_info"라는 제목의 RFC 5661 \[66\] 섹션 11.10에 대한 대체 내용은 섹션 11.17로 표시되며 부록 B.1.3에는 새 섹션과 \[66\] 내의 처리 간의 차이점이 설명되어 있습니다. 원래 처리에서는 추가된 속성 정보가 동일한 복제본에 대한 트렁크 경로의 경우와 어떻게 관련되는지 명확하지 않았기 때문에 수정된 처리가 필요했습니다. 이러한 문제는 복제본의 개념과 복제본에 액세스하는 데 사용되는 네트워크 경로가 명확하게 구분되지 않은 RFC 5661 \[66\]에서는 해결되지 않았습니다.

---
#### **B.1.1.  Reorganization of Sections 11.4 and 11.5 of RFC 5661**

이전에는 여러 위치 항목이 클라이언트를 동일한 파일 시스템 인스턴스로 연결했다는 사실과 관련된 문제가 RFC 5661 \[66\]의 섹션 11.5에서 다루어졌습니다. 트렁킹의 새로운 처리로 인해 이러한 문제는 이제 섹션 11.5에 속합니다.

이 새로운 섹션에서는 섹션 11.5.3부터 11.5.6까지 설명된 파일 시스템 위치 정보의 다른 사용과 함께 섹션 11.5.2에서 트렁킹을 다룹니다.

결과적으로 RFC 5661 \[66\]의 섹션 11.4를 대체하는 섹션 11.5는 일부 원래 섹션이 아래 설명된 대로 해당 섹션으로 대체되고 새로운 섹션이 추가되었다는 점에서 대체하는 섹션과 상당히 다릅니다.

\* 하위 섹션을 제외한 섹션 11.5의 자료는 하위 섹션을 제외한 RFC 5661 \[66\]의 섹션 11.4의 자료를 대체합니다.

\* 섹션 11.5.1은 전체 섹션의 새로운 첫 번째 하위 섹션입니다.

\* 섹션 11.5.2는 전체 섹션의 새로운 두 번째 하위 섹션입니다.

\* 각 섹션 11.5.4, 11.5.5 및 11.5.6은 RFC 5661 \[66\]의 해당 섹션 11.4.1, 11.4.2 및 11.4.3 중 하나를 순서대로 대체합니다.

\* 섹션 11.5.7은 전체 섹션의 새로운 마지막 하위 섹션입니다.

---
#### **B.1.2.  Reorganization of Material Dealing with File System Transitions**

이전에 RFC 5661 \[66\]의 섹션 11.7에 포함되었던 파일 시스템 전환과 관련된 자료는 아래 설명과 같이 재구성 및 확장되었습니다.

\* 복제본 간 이동 없이 파일 시스템 인스턴스에 액세스하는 데 사용되는 네트워크 액세스 경로의 이동이 있을 수 있으므로 새로운 섹션 11.9에서는 개별 복제본 간의 이동이 있는 경우와 네트워크 액세스의 이동과 관련된 경우를 구분합니다. 복제본 간에 이동이 없는 경로입니다.

- 결과적으로 새로운 섹션 11.10은 네트워크 주소 전환을 다루는 반면, RFC 5661 \[66\]의 원래 섹션 11.7의 대부분은 섹션 11.11에 반영된 것처럼 광범위하게 수정되었습니다. 두 개의 서로 다른 복제본 세트 사이를 이동합니다.

\* 추가 섹션 11.12에서는 클라이언트가 새 서버에 누적된 잠금 상태에 계속 액세스할 수 있도록 다른 복제본으로의 전환이 이루어지고 상태가 전송되는 경우에 대해 설명합니다.

\* 추가 섹션 11.13에서는 액세스 전환에 대한 클라이언트의 응답, 마이그레이션이 발생했는지 확인하는 방법, 전송된 잠금 및 세션 상태에 액세스하는 방법에 대해 설명합니다.

\* 추가 섹션 11.14에서는 잠금 및 세션 상태를 전송할 때 원본 및 대상 서버의 책임에 대해 설명합니다.

이러한 재구성으로 인해 아래 설명된 대로 \[66\]의 섹션 11 내 섹션의 번호가 다시 매겨졌습니다.

\* 새로운 섹션 11.9 및 11.10으로 인해 기존 섹션의 번호가 이 번호로 다시 지정되었습니다.

\* \[66\]의 섹션 11.7이 크게 수정되어 섹션 11.11로 나타납니다. 필요한 수정은 이 섹션이 복제본 간의 전환만 다루고 네트워크 주소 간의 전환은 다른 섹션에서 다룬다는 사실을 반영합니다. 재구성에 대한 자세한 내용은 이 섹션의 뒷부분에서 설명됩니다.

\* 11.12, 11.13, 11.14항이 추가되었습니다.

\* 결과적으로 \[66\]의 섹션 11.8, 11.9, 11.10 및 11.11은 이제 각각 섹션 11.15, 11.16, 11.17 및 11.18로 표시됩니다.

이 일반적인 재구성의 일환으로 RFC 5661 \[66\]의 섹션 11.7이 다음과 같이 수정되었습니다.

\* RFC 5661 \[66\]의 섹션 11.7 및 11.7.1이 각각 섹션 11.11 및 11.11.1로 대체되었습니다.

\* RFC 5661의 섹션 11.7.2\(및 포함된 하위 섹션\)가 삭제되었습니다.

\* RFC 5661 \[66\]의 섹션 11.7.3, 11.7.4, 11.7.5, 11.7.5.1 및 11.7.6은 섹션 11.11.2, 11.11.3, 11.11.4, 11.11.4.1 및 이 문서에서는 각각 11.11.5를 따릅니다.

\* RFC 5661 \[66\]의 섹션 11.7.7이 다음으로 대체되었습니다.

- 섹션 11.11.9. 이 하위 섹션은 파일 시스템 전환을 다루는 섹션의 끝으로 이동되었습니다.

\* RFC 5661 \[66\]의 섹션 11.7.8, 11.7.9 및 11.7.10은 이 문서에서 각각 섹션 11.11.6, 11.11.7 및 11.11.8로 대체되었습니다.

---
#### **B.1.3.  Updates to the Treatment of fs_locations_info**

fs\_locations\_info 속성의 다양한 요소에는 특정 파일 시스템 복제본이나 그러한 복제본에 액세스하는 데 사용되는 네트워크 경로나 네트워크 경로 세트에 적용되는 정보가 포함되어 있습니다. fs\_locations\_info의 원래 처리\(RFC 5661 \[66\]의 섹션 11.10\)에서는 이러한 경우를 명확하게 구분하지 못했습니다. 부분적으로는 문서가 복제본에 액세스하는 데 사용된 경로와 복제본을 명확하게 구분하지 않았기 때문입니다.

또한 다음 분야에 대해 특별한 설명이 제공되었습니다.

\* FSLI4GF\_GOING 처리와 관련하여, 레플리카에 접근하는 경로가 아닌 레플리카를 사용할 수 없는 경우에만 적용됨을 명확히 했습니다.

\* fli\_valid\_for에 사용할 서버의 적절한 값을 설명하면서 클라이언트가 트렁킹 패턴의 변화에 ​​대비하기 위해 fs\_locations\_info 값을 자주 가져올 필요가 없음을 명확히 했습니다.

\* fls\_info 확장 규칙에 대한 설명이 제공되었습니다. 원래 처리는 RFC 5661 \[66\] 작성 당시 유효했던 확장 모델을 반영했지만 RFC 8178 \[67\]에 설명된 확장 모델에 따라 업데이트되었습니다.

---
### **B.2.  Revisions Made to Operations in RFC 5661**

다중 서버 네임스페이스 기능에 필요한 변경 사항을 적용할 때 발생한 문제를 해결하기 위해 설명이 수정되었습니다.

\* EXCHANGE\_ID 처리\(RFC 5661 \[66\]의 섹션 18.35\)에서는 EXCHANGE\_ID 및 CREATE\_SESSION 작업 외에는 클라이언트 ID를 생성/확인할 수 없다고 가정했습니다. 또한 마이그레이션 및 관련 상황 복구에 필요한 EXCHANGE\_ID 사용이 명확하게 설명되지 않았습니다. EXCHANGE\_ID의 수정된 처리가 필요했으며 이는 섹션 18.35에 나타나며, 이 처리와 \[66\] 내의 처리 간의 구체적인 차이점은 아래 부록 B.2.1에 설명되어 있습니다.

\* RFC 5661 \[66\] 섹션 18.51의 RECLAIM\_COMPLETE 처리는 rca\_one\_fs의 목적과 사용, 그리고 서버가 이 인수의 부적절한 값을 처리하는 방법에 대해 충분히 명확하지 않았습니다. 결과적인 혼란으로 인해 상호 운용성 문제가 발생했기 때문에 RECLAIM\_COMPLETE의 새로운 처리가 필요했으며 이는 섹션 18.51에 나와 있으며 RFC 5661 \[66\] 내 처리 간의 구체적인 차이점은 아래 부록 B.2.2에서 논의됩니다. 또한 잠금 교정 작업에 대한 여러 컨텍스트가 있다는 사실을 반영하기 위해 교정 관련 오류 정의가 섹션 15.1.9에서 업데이트된 처리를 받았습니다.

---
#### **B.2.1.  Revision of Treatment of EXCHANGE_ID**

RFC 5661 \[66\]의 EXCHANGE\_ID 원래 처리에는 투명한 상태 마이그레이션 및 동일한 파일 시스템 인스턴스에 대한 서로 다른 네트워크 액세스 경로 간의 액세스 전송에 문제를 일으키는 여러 가지 문제가 있었습니다.

이러한 문제는 이 처리가 작성되었다는 사실에서 발생했습니다.

\* 클라이언트 ID는 EXCHANGE\_ID를 실행하여 생성되어야만 서버에 알려질 수 있다고 가정하고, ID 확인은 CREATE\_SESSION을 실행해야만 가능합니다.

\* 단일 네트워크 주소에서만 발생하는 클라이언트와 서버 간의 상호 작용을 고려합니다.

투명한 상태 마이그레이션 및 트렁킹의 적극적인 사용과 관련하여 이러한 가정이 유효하지 않게 되었기 때문에 처리 방식이 여러 측면에서 수정되었습니다.

\* 주어진 클라이언트 인스턴스가 관련 매개변수\(예: 콜백과 관련하여\)를 업데이트하거나 재전송을 통해 이전에 손실된 응답을 처리하고 있음을 서버가 이미 알고 있을 때 EXCHANGE\_ID가 실행되는 것으로 가정되었습니다. 결과적으로 해당 작업에서 반환된 슬롯 시퀀스는 아무 소용이 없습니다. 원래 치료법은 이 사용법이 \[1\]과 일치하지 않더라도 "사용해서는 안 된다"고 말하기까지 했습니다. 이로 인해 투명 상태 마이그레이션 후에 EXCHANGE\_ID가 완료될 때 해당 슬롯 시퀀스를 후속 CREATE\_SESSION에서 사용해야 하기 때문에 어려움이 발생했습니다.\(MUST NOT\)

- 업데이트된 처리에서 CREATE\_SESSION은 클라이언트 ID를 확인하는 방법이지만 다른 방법도 가능한 것으로 이해됩니다. 슬롯 순서는 필요에 따라 사용할 수 있으며, 쓸모가 없는 경우는 적절하게 표시됩니다.

\* EXCHANGE\_ID의 유일한 기능은 서버에 클라이언트를 알리고 클라이언트 ID를 생성하여 클라이언트에 전달하는 것이라고 가정했습니다. 트렁킹에서 자주 발생하는 것처럼 여러 동시 연결이 관련된 경우 클라이언트 ID를 연결된 연결과 연결하는 EXCHANGE\_ID의 역할을 무시하여 후속 CREATE\_SESSION에서 사용할 수 있다는 점에서 해당 처리가 부적절했습니다. 매개변수에는 명시적인 클라이언트 ID가 포함되지 않습니다.

- 새로운 처리에서는 CREATE\_SESSION에서 사용할 수 있도록 클라이언트 ID를 연결과 연결하고 연결을 기존 세션과 연결하는 데 있어 EXCHANGE\_ID의 역할을 명시적으로 설명합니다.

새로운 치료법은 위의 섹션 18.35에서 확인할 수 있습니다. 이는 RFC 5661\[66\]의 섹션 18.35의 처리를 대체합니다.

---
#### **B.2.2.  Revision of Treatment of RECLAIM_COMPLETE**

섹션 18.51의 처리에 도달하기 위해 RFC 5661 \[66\]의 RECLAIM\_COMPLETE 처리에 다음 변경 사항이 적용되었습니다.

\* 여러 위치에서 rca\_one\_fs의 목적과 파일 시스템 마이그레이션과의 연결에 대해 텍스트가 더 명확해졌습니다.

\* RECLAIM\_COMPLETE의 특정 형태를 수행해야 하는 상황에 대한 논의가 있습니다.

\* 상호 운용성 문제에 대한 논의가 있습니다.

- RECLAIM\_COMPLETE의 이전 처리가 명확하지 않아 발생할 수 있는 구현입니다.

---
### **B.3.  Revisions Made to Error Definitions in RFC 5661**

다양한 상황을 새롭게 처리하려면 기존 오류 정의 중 일부를 수정해야 했습니다.

\* 트렁킹 관련 문제를 적절하게 해결해야 할 필요성으로 인해 RFC 5661 \[66\]에서 "복제본"이라는 용어의 일부 사용은 네트워크 액세스 경로의 이동이 다른 복제본으로의 이동으로 간주되어 문제가 되었습니다. 결과적으로 NFS4ERR\_MOVED의 원래 정의\(RFC 5661 \[66\]의 섹션 15.1.2.4\)가 업데이트되어 특정 네트워크 주소를 통한 특정 fs의 가용성에 대한 다양한 처리를 반영했습니다.

- 이러한 상황은 더 이상 파일 시스템 인스턴스를 사용할 수 없는 것으로 간주되지 않으므로 반환되는 상황 세트는 동일하더라도 설명이 변경되었습니다. 새 단락에서는 다른 네트워크 주소가 사용될 수 있음을 명시적으로 인식하는 반면, 이전 설명에서는 이를 단일 파일 시스템 인스턴스만 포함될 수 있는 두 복제본 간의 이동으로 잘못 처리했습니다. 업데이트된 설명은 섹션 15.1.2.4에 나와 있습니다.

\* fs 특정 유예 기간의 사용을 수용해야 하기 때문에 텍스트가 모든 유형의 회수에 적절하게 적용되도록 RFC 5661 \[66\]의 섹션 15에서 회수 관련 오류의 일부 정의를 명확히 할 필요가 있었습니다. 유예 기간. 업데이트된 설명은 섹션 15.1.9에 나타납니다.

\* 정오표 보고서 2006\[64\]에 설명을 제공하고 NFS4ERR\_DELAY와 응답 캐시의 상호 작용을 적절하게 설명하기 위해 이를 적용해야 하기 때문에 NFS4ERR\_DELAY에 대한 수정된 설명이 섹션 15.1.1.3에 나타납니다. 이 정오표 보고서는 다른 많은 RFC 5661 정오표 보고서와 달리 상태 마이그레이션 및 세션 마이그레이션과 관련하여 NFS4ERR\_DELAY를 광범위하게 사용하기 때문에 이 문서에서 다룹니다.

---
### **B.4.  Other Revisions Made to RFC 5661**

RFC 5661 \[66\] 섹션 11의 주요 재작업과 기존 작업 및 오류에 대한 관련 개정 외에도 필요한 관련 변경 사항이 많이 있었습니다.

\* RFC 5661 \[66\] 섹션 1.7.3.3의 요약은 위 섹션 11의 변경 사항을 반영하여 수정되었습니다. 업데이트된 요약은 위의 섹션 1.8.3.3에 표시됩니다.

\* RFC 5661 \[66\]의 섹션 2.10.4의 서버 범위에 대한 논의는 server\_owner 값을 할당하는 전역적으로 균일한 수단의 필요성을 피하는 기본 기능과 호환되지 않는 서버 간 조정 수준을 요구하는 것으로 나타났기 때문에 대체되었습니다. 개정된 치료법은 섹션 2.10.4에 나와 있습니다.

\* RFC 5661 \[66\]의 섹션 2.10.5의 트렁킹에 대한 논의는 다양한 유형의 트렁킹 지원과 클라이언트가 기존 트렁킹 구성을 인식할 수 있는 방법을 보다 명확하게 설명하기 위해 개정되었습니다. 또한 server\_owner 변경 사항을 다루는 해당 섹션의 마지막 단락\(하위 섹션 제외\)은 문자 그대로 사실이지만 혼란의 원인이었습니다. 원래 단락은 그러한 변경 사항이 중단 없이 처리되어야 한다고 제안하는 것으로 읽을 수 있으므로 개정된 섹션 2.10.5에서 문제가 명확해졌습니다.

---
# **Appendix C.  Security Issues That Need to Be Addressed**

NFSv4.1 사양 내에서 보안을 처리할 때 다음 문제를 해결해야 합니다.

\* RFC 5661 \[66\]의 보안 고려 사항 섹션은 RFC 3552 \(BCP 72\) \[72\]에 따라 작성되지 않았습니다. 특히 우려되는 점은 해당 섹션에 위협 분석이 포함되어 있지 않다는 사실이었습니다.

\* NFSv4.1의 기존 보안 문제에 대한 초기 분석 결과 기존 프로토콜\(위협 분석이 포함된 섹션\)에 대한 개정된 보안 고려 사항 섹션에서 NFSv4.1이 보안 사용 목표를 충족하지 못한다는 결론을 내릴 가능성이 높습니다. 인터넷에서.

이 문서의 보안 고려 사항 섹션\(섹션 21\)은 위에 언급된 문제를 해결하기 위해 완전히 개정되지 않았습니다. 대신 11장에서 논의한 다중 서버 네임스페이스 기능과 관련된 문제를 적절히 고려하도록 수정하여 불완전한 논의와 보안 취약점을 그대로 남겨두었습니다.

업데이트된 보안 고려 사항 섹션을 NFSv4.1용 bis 문서의 일부로 게시하기 전에 다음과 같은 주요 보안 문제를 만족스러운 방식으로 해결해야 합니다.

\* AUTH\_SYS의 지속적인 사용과 이로 인해 발생하는 보안 노출을 해결해야 합니다. 이 문제를 해결하는 것은 이것을 OPTIONAL로 지정하는 것이 정당했는지, 변경해야 하는지에 대한 질문에만 국한되어서는 안 됩니다.\(MAY\)

- 어떠한 경우에도 단순히 이 지정을 수정하는 것만으로는 AUTH\_SYS의 지속적인 사용으로 인해 발생하는 보안 문제를 현재 시점에서 수정하는 것이 불가능할 수 있습니다.

\* RFC 7258 \[71\] \(또한 BCP 188\)에 설명된 것과 같은 광범위한 모니터링 공격의 가능성에 대한 프로토콜 내 주의 부족.

- 이와 관련하여 개인 정보 보호 없이 CREATE\_SESSION을 사용하면 공격자가 볼 수 있도록 세션 ID가 노출되므로 이를 해결해야 합니다. 이는 RFC 7258에서 암시된 프로토콜 아티팩트 유형과 정확히 같아서 걱정스럽습니다. 이는 일반적으로 낮은 단일 공격만으로 효과적으로 실행될 수 있는 서비스 거부 공격을 가능하게 하므로 공격자 측에서 추가적인 장난을 가할 수 있습니다. -값, 자격 증명, RPCSEC\_GSS 인증이 사용 중인 경우에도 마찬가지입니다.

\* RPCSEC\_GSS 사용을 지원하는 인프라가 있는 경우에도 개인 정보 보호 및 무결성의 효과적인 사용 부족 문제를 해결해야 합니다.

- 이러한 상황으로 인해 발생하는 보안 노출을 고려하면, 충분한 자원을 제공하여 이 문제를 해결할 수 있는 프로토콜을 정의하는 것만으로는 충분하지 않습니다. 대신, 필요한 것은 매우 제한된 성능 비용으로 그리고 많은 클라이언트와 서버가 제공하기 어려운 보안 인프라 없이 필요한 보안을 제공하는 방법입니다.

NFSv4.1과 같이 배포된 프로토콜에 대한 주요 보안 업그레이드를 제공하려고 할 때 작업 그룹과 인터넷 커뮤니티는 다음과 같은 여러 가지 고려 사항을 처리하게 될 가능성이 높습니다.

\* 기존 프로토콜 배포를 수용할 필요성

- 기존 제안 표준에서 이전에 지정되었습니다.

\* 기존 상호 운용 구현에 변경 사항을 적용하는 것이 어렵습니다.

\* OPTIONAL 확장 형식 이외의 NFSv4 프로토콜을 변경하는 데 어려움이 있습니다.\(MAY\)

\* 기존 NFSv4 배포를 담당하는 사람들은 네트워크 격리 자체가 모든 잠재적인 공격자로부터 격리된다는 잘못된 인식을 갖고 근거리 통신망의 보안 결함을 무시하는 경향이 있습니다.

위에서 언급한 어려움이 마이너 버전 0에도 적용된다는 점을 고려하면 모든 NFSv4 마이너 버전에 적용되는 공통 문서에서 이러한 보안 문제를 처리하는 것이 합리적일 수 있습니다. 해당 접근 방식을 취하면 최종 NFv4.1 bis 문서의 보안 고려 사항 섹션에서 해당 공통 문서를 참조하고 다른 부 버전에 대한 정의 RFC도 그렇게 할 수 있습니다.

---
# **Acknowledgments**
---
# **Acknowledgments for This Update**

저자는 트렁킹 검색 기능의 필요성을 명확히 하고 필요한 지원을 제공하는 데 있어 파일 시스템 위치 속성의 역할을 탐색하는 데 있어 Netapp의 Andy Adamson의 중요한 역할을 인정하고 싶습니다.

저자는 국제화 및 보안이 모든 NFSv4 부 버전에 적용되는 프로토콜 문제를 다루는 문서에서 가장 잘 처리될 수 있다는 사실에 주의를 환기시킨 Hammerspace의 Tom Haynes에게 감사를 표하고 싶습니다.

저자는 또한 Transparent State Migration 기능의 NFSv4.1 클라이언트 및 서버 프로토타입을 사용한 Oracle의 Xuan Qi의 작업에 감사를 표하고 싶습니다.

저자들은 중요한 문제에 관심을 가져준 다른 사람들에게 감사를 표하고 싶습니다. 트렁킹과 관련된 Primary Data의 Trond Myklebust의 의견은 트렁킹 검색에서 DNS의 역할을 명확히 하는 데 도움이 되었습니다. Rick Macklem의 의견은 RECLAIM\_COMPLETE의 per-fs 버전 처리 문제에 대한 관심을 불러일으켰습니다.

저자들은 유용한 리뷰 의견을 주신 Netapp의 Olga Kornievskaia에게 감사의 말씀을 전하고 싶습니다.

---
# **Acknowledgments for RFC 5661**

SECINFO 확장의 초기 텍스트는 Peng Dai, Sergey Klyushin 및 Carl Burnett의 도움을 받아 Mike Eisler가 편집했습니다.

SESSIONS 확장의 초기 텍스트는 Charles Antonelli, Brent Callaghan, Mike Eisler, John Howard, Chet Juszczak, Trond Myklebust, Dave Noveck, John Scott, Mike Stolarchuk 및 Mark의 기여로 Tom Talpey, Spencer Shepler, Jon Bauman이 편집했습니다. 위틀.

추천 개념을 포함하여 다중 서버 네임스페이스 기능과 관련된 초기 텍스트는 Dave Noveck, Carl Burnett 및 Charles Fan이 기고했으며 Ted Anderson, Neil Brown 및 Jon Haswell도 기고했습니다.

디렉토리 위임 지원에 대한 초기 텍스트는 Saadia Khan이 Dave Noveck, Mike Eisler, Carl Burnett, Ted Anderson 및 Tom Talpey의 의견을 바탕으로 작성했습니다.

ACL 설명의 초기 텍스트는 Sam Falkner와 Lisa Week가 제공했습니다.

pNFS 작업은 Garth Gibson이 수행한 NASD 및 OSD 작업에서 영감을 받았습니다. Gary Grider는 고성능 병렬 I/O의 챔피언이기도 합니다. Garth Gibson과 Peter Corbett는 NFSv4.1에서 pNFS 작업의 기초를 형성한 IETF용 문제 설명 문서로 pNFS 작업을 시작했습니다.

병렬 NFS 지원에 대한 초기 텍스트는 Brent Welch와 Garth Goodson이 편집했습니다. 해당 문서의 추가 작성자는 Benny Halevy, David Black 및 Andy Adamson입니다. 초기 pNFS 초안 작성에 기여한 비공식 그룹에서 추가 의견이 나왔습니다. 구체적인 감사의 말은 Gary Grider, Peter Corbett, Dave Noveck, Peter Honeyman 및 Stephen Fridella에게 있습니다.

Fredric Isaman은 NFSv4.1 프로토콜의 ONC RPC XDR 설명 초안 버전에서 몇 가지 오류를 발견했습니다.

Audrey Van Belleghem은 다양한 방법으로 사양 문서 편집 프로세스의 필수적인 조정 및 관리를 제공했습니다.

Richard Jernigan은 파일 레이아웃의 줄무늬 패턴 디자인에 대한 피드백을 제공했습니다.

프로토콜의 다양한 영역을 검토하기 위해 여러 공식 검사 팀이 구성되었습니다. 모든 검사에서 심각한 오류와 개선의 여지가 발견되었습니다. NFSv4.1의 검사 팀은 다음과 같습니다.

\* 다음 검사관이 포함된 ACL: Sam Falkner, Bruce Fields, Rahul Iyer, Saadia Khan, Dave Noveck, Lisa Week, Mario Wurzl 및 Alan Yoder.

\* 세션: William Brown, Tom Doeppner, Robert Gordon, Benny Halevy, Fredric Isaman, Rick Macklem, Trond Myklebust, Dave Noveck, Karen Rochford, John Scott 및 Peter Shah.

\* 초기 pNFS 검사: Andy Adamson, David Black, Mike Eisler, Marc Eshel, Sam Falkner, Garth Goodson, Benny Halevy, Rahul Iyer, Trond Myklebust, Spencer Shepler 및 Lisa Week 검사관이 참여합니다.

\* 글로벌 네임스페이스, 다음 조사관 포함: Mike Eisler, Dan Ellard, Craig Everhart, Fredric Isaman, Trond Myklebust, Dave Noveck, Theresa Raj, Spencer Shepler, Renu Tewari 및 Robert Thurlow.

\* NFSv4.1 파일 레이아웃 유형, 검사관: Andy Adamson, Marc Eshel, Sam Falkner, Garth Goodson, Rahul Iyer, Trond Myklebust 및 Lisa Week.

\* 다음 조사관이 포함된 NFSv4.1 잠금 및 디렉터리 위임: Mike Eisler, Pranoop Erasani, Robert Gordon, Saadia Khan, Eric Kustarz, Dave Noveck, Spencer Shepler 및 Amy Weaver.

\* EXCHANGE\_ID 및 DESTROY\_CLIENTID, 검사관: Mike Eisler, Pranoop Erasani, Robert Gordon, Benny Halevy, Fredric Isaman, Saadia Khan, Ricardo Labiaga, Rick Macklem, Trond Myklebust, Spencer Shepler 및 Brent Welch.

\* 다음 조사관이 참여하는 최종 pNFS 조사: Andy Adamson, Mike Eisler, Mark Eshel, Sam Falkner, Jason Glasgow, Garth Goodson, Robert Gordon, Benny Halevy, Dean Hildebrand, Rahul Iyer, Suchit Kaura, Trond Myklebust, Anatoly Pinchuk, Spencer 셰플러, 레누 테와리, 리사 위크, 브렌트 웰치.

검토 팀은 함께 작업하여 작업에 대한 오류 세트 할당 테이블을 생성하고 각 할당에 두 명 이상의 사람이 이를 검증하는지 확인했습니다. 이 과정에는 Andy Adamson, Mike Eisler, Sam Falkner, Garth Goodson, Robert Gordon, Trond Myklebust, Dave Noveck, Spencer Shepler, Tom Talpey, Amy Weaver 및 Lisa Week가 참여했습니다.

Jari Arkko, David Black, Scott Bradner, Lisa Dusseault, Lars Eggert, Chris Newman 및 Tim Polk는 귀중한 검토와 지침을 제공했습니다.

Olga Kornievskaia는 SSV 사양에서 몇 가지 오류를 발견했습니다.

Ricardo Labiaga는 RPCSEC\_GSS 사용이 제대로 지정되지 않은 여러 곳을 발견했습니다.

기타 의견을 제공한 사람은 다음과 같습니다: Andy Adamson, Sunil Bhargo, Alex Burlyga, Pranoop Erasani, Bruce Fields, Vadim Finkelstein, Jason Goldschmidt, Vijay K. Gurbani, Sergey Klyushin, Ricardo Labiaga, James Lentini, Anshul Madan, Daniel Muntz, Daniel Picken , Archana Ramani, Jim Rees, Mahesh Siddheshwar, Tom Talpey 및 Peter Varga.

---
# **Authors' Addresses**

David Noveck\(편집자\) NetApp 1601 Trapelo Road, Suite 16 Waltham, MA 02451 미국

```text
   Phone: +1-781-768-5347
   Email: dnoveck@netapp.com
```

Charles Lever Oracle Corporation 1015 Granger Avenue 앤아버, MI 48104 미국

```text
   Phone: +1-248-614-5091
   Email: chuck.lever@oracle.com
```
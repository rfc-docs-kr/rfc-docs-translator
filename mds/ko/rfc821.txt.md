

```text
                                                                        

   RFC 821
                                    
                                    
                                    
                                    
                                    
                     SIMPLE MAIL TRANSFER PROTOCOL
                                    
                                    
                                    
                           Jonathan B. Postel
```

1982년 8월

- 정보 과학 연구소 University of Southern California 4676 Admiralty Way Marina del Rey, California 90291

```text
                             (213) 822-1511

                                                                        
RFC 821                                                      August 1982
                                           Simple Mail Transfer Protocol
```

- 목차

```text
   1.  INTRODUCTION .................................................. 1
   2.  THE SMTP MODEL ................................................ 2
   3.  THE SMTP PROCEDURE ............................................ 4
      3.1.  Mail ..................................................... 4
      3.2.  Forwarding ............................................... 7
      3.3.  Verifying and Expanding .................................. 8
      3.4.  Sending and Mailing ..................................... 11
      3.5.  Opening and Closing ..................................... 13
      3.6.  Relaying ................................................ 14
      3.7.  Domains ................................................. 17
      3.8.  Changing Roles .......................................... 18
   4.  THE SMTP SPECIFICATIONS ...................................... 19
      4.1.  SMTP Commands ........................................... 19
      4.1.1.  Command Semantics ..................................... 19
      4.1.2.  Command Syntax ........................................ 27
      4.2.  SMTP Replies ............................................ 34
      4.2.1.  Reply Codes by Function Group ......................... 35
      4.2.2.  Reply Codes in Numeric Order .......................... 36
      4.3.  Sequencing of Commands and Replies ...................... 37
      4.4.  State Diagrams .......................................... 39
      4.5.  Details ................................................. 41
      4.5.1.  Minimum Implementation ................................ 41
      4.5.2.  Transparency .......................................... 41
      4.5.3.  Sizes ................................................. 42
   APPENDIX A:  TCP ................................................. 44
   APPENDIX B:  NCP ................................................. 45
   APPENDIX C:  NITS ................................................ 46
   APPENDIX D:  X.25 ................................................ 47
   APPENDIX E:  Theory of Reply Codes ............................... 48
   APPENDIX F:  Scenarios ........................................... 51
   GLOSSARY ......................................................... 64
   REFERENCES ....................................................... 67

```

```text
Network Working Group                                          J. Postel
Request for Comments: DRAFT                                          ISI
Replaces: RFC 788, 780, 772                                  August 1982

                     SIMPLE MAIL TRANSFER PROTOCOL
```

---
## **1.  INTRODUCTION**

SMTP\(Simple Mail Transfer Protocol\)의 목적은 메일을 안정적이고 효율적으로 전송하는 것입니다.

SMTP는 특정 전송 하위 시스템과 독립적이며 안정적으로 정렬된 데이터 스트림 채널만 필요합니다. 부록 A, B, C, D에서는 다양한 전송 서비스와 함께 SMTP를 사용하는 방법을 설명합니다. 용어집은 이 문서에 사용된 용어의 정의를 제공합니다.

SMTP의 중요한 기능은 전송 서비스 환경 전반에 걸쳐 메일을 릴레이하는 기능입니다. 전송 서비스는 IPCE\(프로세스 간 통신 환경\)를 제공합니다. IPCE는 하나의 네트워크, 여러 네트워크 또는 네트워크의 하위 집합을 다룰 수 있습니다. 전송 시스템\(또는 IPCE\)이 네트워크와 일대일로 연결되지 않는다는 점을 인식하는 것이 중요합니다. 프로세스는 상호 알려진 IPCE를 통해 다른 프로세스와 직접 통신할 수 있습니다. 메일은 프로세스 간 통신의 응용 프로그램 또는 사용입니다. 메일은 두 개\(또는 그 이상\)의 IPCE에 연결된 프로세스를 통해 중계함으로써 서로 다른 IPCE의 프로세스 간에 통신할 수 있습니다. 보다 구체적으로 말하면 메일은 두 전송 시스템의 호스트에 의해 서로 다른 전송 시스템의 호스트 간에 중계될 수 있습니다.

---
## **2.  THE SMTP MODEL**

SMTP 설계는 다음과 같은 통신 모델을 기반으로 합니다. 즉, 사용자 메일 요청의 결과로 보낸 사람-SMTP가 받는 사람-SMTP에 대한 양방향 전송 채널을 설정합니다. Receiver-SMTP는 최종 목적지이거나 중간 목적지일 수 있습니다. SMTP 명령은 sender-SMTP에 의해 생성되어 Receiver-SMTP로 전송됩니다. SMTP 응답은 명령에 대한 응답으로 Receiver-SMTP에서 sender-SMTP로 전송됩니다.

전송 채널이 설정되면 SMTP 발신자는 메일 발신자를 나타내는 MAIL 명령을 보냅니다. SMTP 수신자가 메일을 수락할 수 있으면 OK 응답으로 응답합니다. 그런 다음 SMTP 발신자는 메일 수신자를 식별하는 RCPT 명령을 보냅니다. SMTP 수신자가 해당 수신자에 대한 메일을 수락할 수 있으면 OK 응답으로 응답합니다. 그렇지 않은 경우 해당 수신자를 거부하는 응답으로 응답합니다\(그러나 전체 메일 트랜잭션은 아님\). SMTP 발신자와 SMTP 수신자는 여러 수신자를 협상할 수 있습니다. 수신자가 협상되면 SMTP 발신자는 메일 데이터를 보내고 특별한 순서로 종료합니다. SMTP 수신자가 메일 데이터를 성공적으로 처리하면 OK 응답으로 응답합니다. 대화 상자는 의도적으로 한 번에 하나씩 잠금 단계로 이루어졌습니다.

```text
     -------------------------------------------------------------

   
               +----------+                +----------+
   +------+    |          |                |          |
   | User |<-->|          |      SMTP      |          |
   +------+    |  Sender- |Commands/Replies| Receiver-|
   +------+    |   SMTP   |<-------------->|    SMTP  |    +------+
   | File |<-->|          |    and Mail    |          |<-->| File |
   |System|    |          |                |          |    |System|
   +------+    +----------+                +----------+    +------+
   

                Sender-SMTP                Receiver-SMTP
```

- SMTP용 모델

```text
                                Figure 1

     -------------------------------------------------------------
```

SMTP는 메일 전송을 위한 메커니즘을 제공합니다. 송신 사용자의 호스트에서 수신 사용자의 호스트로 직접

두 호스트가 동일한 전송 서비스에 연결되거나 소스 및 대상 호스트가 동일한 전송 서비스에 연결되지 않은 경우 하나 이상의 릴레이 SMTP 서버를 통해 연결됩니다.

중계 기능을 제공하려면 SMTP 서버에 최종 대상 호스트의 이름과 대상 사서함 이름이 제공되어야 합니다.

MAIL 명령의 인수는 메일을 보낸 사람을 지정하는 역방향 경로입니다. RCPT 명령의 인수는 메일을 받을 사람을 지정하는 전달 경로입니다. 정방향 경로는 소스 경로이고 역방향 경로는 반환 경로입니다\(릴레이된 메시지에 오류가 발생할 때 보낸 사람에게 메시지를 반환하는 데 사용될 수 있음\).

동일한 메시지가 여러 수신자에게 전송되면 SMTP는 동일한 대상 호스트에 있는 모든 수신자에 대해 하나의 데이터 복사본만 전송하도록 권장합니다.

메일 명령과 응답에는 엄격한 구문이 있습니다. 답글에도 숫자 코드가 있습니다. 다음에는 실제 명령과 응답을 사용한 예가 나와 있습니다. 전체 명령 및 응답 목록은 사양에 대한 섹션 4에 나와 있습니다.

명령과 응답은 대소문자를 구분하지 않습니다. 즉, 명령이나 응답 단어는 대문자, 소문자 또는 대문자와 소문자의 혼합일 수 있습니다. 사서함 사용자 이름에는 해당되지 않습니다. 일부 호스트의 경우 사용자 이름은 대소문자를 구분하며 SMTP 구현에서는 사서함 인수에 나타나는 사용자 이름의 대소문자를 유지하기 위해 대소문자를 구분해야 합니다. 호스트 이름은 대소문자를 구분하지 않습니다.

명령과 응답은 ASCII 문자 세트 \[1\]의 문자로 구성됩니다. 전송 서비스가 8비트 바이트\(옥텟\) 전송 채널을 제공하는 경우 각 7비트 문자는 상위 비트가 0으로 지워진 옥텟에서 오른쪽 정렬되어 전송됩니다.

명령이나 응답의 일반 형식을 지정할 때 인수\(또는 특수 기호\)는 메타 언어 변수\(또는 상수\)로 표시됩니다\(예: "<string\>" 또는 "<reverse-path\>"\). 여기서 꺾쇠 괄호는 이것이 메타 언어 변수임을 나타냅니다. 그러나 일부 인수에서는 문자 그대로 꺾쇠 괄호를 사용합니다. 예를 들어, 실제 역방향 경로는 꺾쇠괄호로 묶여 있습니다. 즉, "<John.Smith@USC-ISI.ARPA\>"는 <reverse-path\>의 인스턴스입니다\(꺾쇠괄호는 실제로 명령이나 응답에서 전송됩니다\). \).

---
## **3.  THE SMTP PROCEDURES**

이 섹션에서는 SMTP에서 사용되는 절차를 여러 부분으로 나누어 설명합니다. 먼저 메일 트랜잭션으로 정의된 기본 메일 절차가 나옵니다. 다음은 메일 전달, 메일함 이름 확인 및 메일링 목록 확장, 메일함 대신 또는 메일함과 함께 터미널로 보내기, 교환 열기 및 닫기에 대한 설명입니다. 이 섹션의 끝에는 릴레이에 대한 설명, 메일 도메인에 대한 참고 사항 및 역할 변경에 대한 설명이 있습니다. 이 섹션 전체에는 부분 명령 및 응답 시퀀스의 예가 나와 있으며 몇 가지 전체 시나리오가 부록 F에 나와 있습니다.

```text
   3.1.  MAIL
```

- SMTP 메일 거래에는 세 단계가 있습니다. 트랜잭션은 보낸 사람 식별 정보를 제공하는 MAIL 명령으로 시작됩니다. 일련의 하나 이상의 RCPT 명령이 수신자에게 정보를 제공합니다. 그런 다음 DATA 명령이 메일 데이터를 제공합니다. 그리고 마지막으로 메일 데이터 표시의 끝이 거래를 확인합니다.

- 절차의 첫 번째 단계는 MAIL 명령입니다. <reverse-path\>에는 원본 사서함이 포함됩니다.

```text
            MAIL <SP> FROM:<reverse-path> <CRLF>
```

이 명령은 SMTP 수신자에게 새 메일이 도착했음을 알려줍니다.

- 트랜잭션이 시작되고 수신자 또는 메일 데이터를 포함하여 모든 상태 테이블과 버퍼를 재설정합니다. 오류를 보고하는 데 사용할 수 있는 역방향 경로를 제공합니다. 수락되면 수신자-SMTP는 250 OK 응답을 반환합니다.

- <reverse-path\>에는 사서함 이상의 내용이 포함될 수 있습니다. <reverse-path\>는 호스트 및 원본 사서함의 역방향 원본 라우팅 목록입니다. <reverse-path\>의 첫 번째 호스트는 이 명령을 보내는 호스트여야 합니다.

- 절차의 두 번째 단계는 RCPT 명령입니다.

```text
            RCPT <SP> TO:<forward-path> <CRLF>
```

- 이 명령은 수신자 한 명을 식별하는 전달 경로를 제공합니다. 수락되면 수신자-SMTP는 250 OK 응답을 반환하고 전달 경로를 저장합니다. 수신자를 알 수 없는 경우 수신자-SMTP는 550 실패 응답을 반환합니다. 절차의 두 번째 단계는 여러 번 반복할 수 있습니다.

- <forward-path\>에는 사서함 이상의 내용이 포함될 수 있습니다. <forward-path\>는 호스트 및 대상 사서함의 소스 라우팅 목록입니다. <forward-path\>의 첫 번째 호스트는 이 명령을 받는 호스트여야 합니다.

- 절차의 세 번째 단계는 DATA 명령입니다.

```text
            DATA <CRLF>
```

- 수락되면 수신자-SMTP는 354 중간 응답을 반환하고 이후의 모든 줄을 메시지 텍스트로 간주합니다. 텍스트의 끝이 수신되어 저장되면 SMTP 수신자는 250 OK 응답을 보냅니다.

- 메일 데이터는 전송 채널을 통해 전송되므로 명령 및 응답 대화 상자를 다시 시작할 수 있도록 메일 데이터의 끝을 표시해야 합니다. SMTP는 마침표만 포함된 행을 전송하여 메일 데이터의 끝을 나타냅니다. 이것이 사용자의 텍스트를 방해하는 것을 방지하기 위해 투명성 절차가 사용됩니다\(섹션 4.5.2 참조\).

- 메일 데이터에는 날짜, 제목, 받는 사람, 참조, 보낸 사람 등의 메모 헤더 항목이 포함되어 있으므로 주의하세요.

메일 데이터의 끝 표시도 메일을 확인합니다.

- 트랜잭션을 수행하고 수신자-SMTP에게 이제 저장된 수신자와 메일 데이터를 처리하도록 지시합니다. 수락되면 수신자-SMTP는 250 OK 응답을 반환합니다. DATA 명령은 메일 트랜잭션이 불완전한 경우\(예: 수신자가 없는 경우\) 또는 리소스를 사용할 수 없는 경우에만 실패해야 합니다.

- 위 절차는 메일 거래의 예시입니다. 이러한 명령은 위에 설명된 순서로만 사용해야 합니다. 예제 1\(아래\)에서는 메일 트랜잭션에서 이러한 명령을 사용하는 방법을 보여줍니다.

```text
      -------------------------------------------------------------
```

- SMTP 절차의 예

- 이 SMTP 예는 호스트 Alpha.ARPA의 Smith가 호스트 Beta.ARPA의 Jones, Green 및 Brown에게 보낸 메일을 보여줍니다. 여기서는 호스트 Alpha가 호스트 Beta에 직접 연락한다고 가정합니다.

```text
            S: MAIL FROM:<Smith@Alpha.ARPA>
            R: 250 OK

            S: RCPT TO:<Jones@Beta.ARPA>
            R: 250 OK

            S: RCPT TO:<Green@Beta.ARPA>
            R: 550 No such user here

            S: RCPT TO:<Brown@Beta.ARPA>
            R: 250 OK
```

에스: 데이터

- R: 354 메일 입력 시작; <CRLF\>로 끝납니다.<CRLF\> S: 어쩌고저쩌고... S: ...etc. S: <CRLF\>.<CRLF\> R: 250 OK

- 이제 Jones와 Brown의 메일이 승인되었습니다. Green은 호스트 Beta에 사서함이 없었습니다.

```text
                               Example 1

      -------------------------------------------------------------

   3.2.  FORWARDING
```

- <forward-path\>의 목적지 정보가 잘못된 경우도 있는데, Receiver-SMTP는 올바른 목적지를 알고 있습니다. 그러한 경우, 발신자가 올바른 목적지에 연락할 수 있도록 다음 응답 중 하나를 사용해야 합니다.

- 251 사용자가 로컬이 아닙니다. <forward-path\>로 전달됩니다.

- 이 응답은 수신자-SMTP가 사용자의 사서함이 다른 호스트에 있다는 것을 알고 향후 사용할 올바른 전달 경로를 나타냄을 나타냅니다. 호스트나 사용자 또는 둘 다 다를 수 있습니다. 수신자는 메시지 전달에 대한 책임을 집니다.

```text
         551 User not local; please try <forward-path>
```

- 이 응답은 수신자-SMTP가 사용자의 메일함이 다른 호스트에 있다는 것을 알고 사용할 올바른 전달 경로를 나타냄을 나타냅니다. 호스트나 사용자 또는 둘 다 다를 수 있습니다. 수신자는 이 사용자에 대한 메일 수신을 거부하고 발신자는 제공된 정보에 따라 메일을 리디렉션하거나 원래 사용자에게 오류 응답을 반환해야 합니다.

- 예제 2에서는 이러한 응답의 사용을 보여줍니다.

```text
      -------------------------------------------------------------

                         Example of Forwarding

      Either
```

S: RCPT 수신:<Postel@USC-ISI.ARPA\>

- R: 251 사용자가 로컬이 아닙니다. <Postel@USC-ISIF.ARPA\>로 전달됩니다.

```text
      Or

      S: RCPT TO:<Paul@USC-ISIB.ARPA>
      R: 551 User not local; please try <Mockapetris@USC-ISIF.ARPA>

                               Example 2

      -------------------------------------------------------------
```

3.3. 검증 및 확장

- SMTP는 사용자 이름을 확인하거나 메일링 리스트를 확장하는 명령을 추가 기능으로 제공합니다. 이는 문자열 인수가 있는 VRFY 및 EXPN 명령을 사용하여 수행됩니다. VRFY 명령의 경우 문자열은 사용자 이름이고 응답에는 사용자의 전체 이름이 포함될 수 있으며 사용자의 사서함이 포함되어야 합니다. EXPN 명령의 경우 문자열은 메일링 목록을 식별하며 여러 줄 응답에는 사용자의 전체 이름이 포함될 수 있으며 메일링 목록에 있는 사서함을 제공해야 합니다.

- "사용자 이름"은 모호한 용어이며 의도적으로 사용됩니다. 호스트가 VRFY 또는 EXPN 명령을 구현하는 경우 최소한 로컬 사서함이 "사용자 이름"으로 인식되어야 합니다. 호스트가 다른 문자열을 "사용자 이름"으로 인식하도록 선택한 경우 허용됩니다.

- 일부 호스트에서는 메일링 리스트와 단일 메일함의 별칭 간의 구분이 약간 모호합니다. 왜냐하면 공통 데이터 구조가 두 가지 유형의 항목을 모두 포함할 수 있고 하나의 메일함의 메일링 목록을 가질 수 있기 때문입니다. 메일링 리스트를 확인하라는 요청이 있을 경우, 주소가 지정된 메시지를 받았을 때 리스트에 있는 모든 사람에게 전달된다면 긍정적인 응답을 받을 수 있습니다. 그렇지 않으면 오류가 보고되어야 합니다\(예: "550 That is a mailing list" , 사용자 아님'\). 사용자 이름을 확장하라는 요청이 있는 경우 하나의 이름이 포함된 목록을 반환하여 긍정적인 응답을 받거나 오류가 보고될 수 있습니다\(예: "550 메일링 목록이 아닌 사용자 이름입니다."\).

- 여러 줄로 된 응답\(EXPN의 경우 일반\)의 경우 응답의 각 줄에 정확히 하나의 사서함이 지정됩니다. 모호한 요청\(예: "VRFY Smith"\)의 경우 Smith가 두 개 있는 경우 응답은 "553 User ambiguous"여야 합니다.

- 사용자 이름을 확인하는 경우는 예시 3과 같이 간단하다.

```text
      -------------------------------------------------------------

                    Example of Verifying a User Name

         Either

            S: VRFY Smith
            R: 250 Fred Smith <Smith@USC-ISIF.ARPA>

         Or
```

S: VRFY 스미스

- R: 251 사용자가 로컬이 아닙니다. <Smith@USC-ISIQ.ARPA\>로 전달됩니다.

```text
         Or

            S: VRFY Jones
            R: 550 String does not match anything.

         Or

            S: VRFY Jones
            R: 551 User not local; please try <Jones@USC-ISIQ.ARPA>

         Or

            S: VRFY Gourzenkyinplatz
            R: 553 User ambiguous.

                               Example 3

      -------------------------------------------------------------
```

- 사서함 목록을 확장하는 경우 예제 4와 같이 여러 줄의 응답이 필요합니다.

```text
      -------------------------------------------------------------
```

- 메일링 리스트 확장 예시

```text
         Either

            S: EXPN Example-People
            R: 250-Jon Postel <Postel@USC-ISIF.ARPA>
            R: 250-Fred Fonebone <Fonebone@USC-ISIQ.ARPA>
            R: 250-Sam Q. Smith <SQSmith@USC-ISIQ.ARPA>
            R: 250-Quincy Smith <@USC-ISIF.ARPA:Q-Smith@ISI-VAXA.ARPA>
            R: 250-<joe@foo-unix.ARPA>
            R: 250 <xyz@bar-unix.ARPA>

         Or
```

S: EXPN Executive-Washroom-List

- R: 550 액세스가 거부되었습니다.

```text
                               Example 4

      -------------------------------------------------------------
```

- VRFY 및 EXPN 명령의 문자열 인수는 사용자 이름 및 메일함 목록 개념의 다양한 구현으로 인해 더 이상 제한될 수 없습니다. 일부 시스템에서는 EXPN 명령의 인수가 메일링 목록을 포함하는 파일의 파일 이름이 되는 것이 적절할 수 있지만 인터넷에는 다양한 파일 명명 규칙이 있습니다.

- VRFY 및 EXPN 명령은 최소 구현\(섹션 4.5.1\)에 포함되지 않으며 구현 시 릴레이 간에 작동할 필요가 없습니다.

3.4. 발송 및 우편 발송

SMTP의 주요 목적은 사용자에게 메시지를 전달하는 것입니다.

- 사서함. 일부 호스트에서 제공하는 매우 유사한 서비스는 사용자의 터미널에 메시지를 전달하는 것입니다\(사용자가 호스트에서 활성 상태인 경우\). 사용자의 메일함으로 전달되는 것을 "메일링"이라 하고, 사용자의 단말기로 전달되는 것을 "보내기"라고 합니다. 많은 호스트에서 전송 구현은 메일링 구현과 거의 동일하기 때문에 이 두 기능이 SMTP에 결합됩니다. 그러나 전송 명령은 필수 최소 구현\(섹션 4.5.1\)에 포함되지 않습니다. 사용자는 자신의 터미널에서 메시지 쓰기를 제어할 수 있어야 합니다. 대부분의 호스트는 사용자가 그러한 메시지를 수락하거나 거부하도록 허용합니다.

- 전송 옵션을 지원하기 위해 다음 세 가지 명령이 정의됩니다. 이는 MAIL 명령 대신 메일 트랜잭션에서 사용되며 수신자-SMTP에 이 트랜잭션의 특별한 의미를 알립니다.

```text
         SEND <SP> FROM:<reverse-path> <CRLF>
```

- SEND 명령을 사용하려면 메일 데이터가 사용자의 터미널로 전달되어야 합니다. 사용자가 호스트에서 활성 상태가 아니거나 터미널 메시지를 수락하지 않는 경우 RCPT 명령에 450 응답이 반환될 수 있습니다. 메시지가 단말기로 전달되면 메일 거래가 성공한 것입니다.

```text
         SOML <SP> FROM:<reverse-path> <CRLF>
```

- Send Or MaiL 명령을 사용하려면 사용자가 호스트에서 활성화되어 있고 터미널 메시지를 수락하는 경우 메일 데이터가 사용자의 터미널로 배달되어야 합니다. 사용자가 활성 상태가 아니면\(또는 터미널 메시지를 수락하지 않는 경우\) 메일 데이터가 사용자의 메일함에 입력됩니다. 메시지가 단말기나 우편함으로 전달되면 메일 거래가 성공한 것입니다.

```text
         SAML <SP> FROM:<reverse-path> <CRLF>
```

- Send And MaiL 명령을 사용하려면 사용자가 호스트에서 활성 상태이고 터미널 메시지를 수락하는 경우 메일 데이터가 사용자의 터미널로 배달되어야 합니다. 어떤 경우에도 메일 데이터는 사용자의 메일함에 입력됩니다. 메시지가 메일함으로 전달되면 메일 거래가 성공한 것입니다.

- MAIL 명령에 사용된 것과 동일한 응답 코드가 이러한 명령에 사용됩니다.

3.5. 열기 및 닫기

- 전송 채널이 열릴 때 호스트가 자신이 생각하는 호스트와 통신하고 있는지 확인하기 위한 교환이 있습니다.

- 전송 채널 열기 및 닫기에는 다음 두 가지 명령이 사용됩니다.

```text
         HELO <SP> <domain> <CRLF>

         QUIT <CRLF>
```

- HELO 명령에서 명령을 보내는 호스트는 자신을 식별합니다. 이 명령은 "안녕하세요, 저는 <도메인\>입니다"라고 해석될 수 있습니다.

```text
      -------------------------------------------------------------
```

- 연결 개방의 예

```text
         R: 220 BBN-UNIX.ARPA Simple Mail Transfer Service Ready
         S: HELO USC-ISIF.ARPA
         R: 250 BBN-UNIX.ARPA

                               Example 5

      -------------------------------------------------------------

      -------------------------------------------------------------
```

- 연결 종료의 예

```text
         S: QUIT
         R: 221 BBN-UNIX.ARPA Service closing transmission channel

                               Example 6

      -------------------------------------------------------------

   3.6.  RELAYING
```

전달 경로는 다음 형식의 소스 경로일 수 있습니다.

- "@ONE,@TWO:JOE@THREE", 여기서 ONE, TWO, THREE는 호스트입니다. 이 형식은 주소와 경로의 구별을 강조하는 데 사용됩니다. 우편함은 절대 주소이고, 경로는 그곳으로 가는 방법에 대한 정보입니다. 두 개념을 혼동해서는 안 됩니다.

- 개념적으로 메시지가 한 서버\(SMTP\)에서 다른 서버로 릴레이될 때 정방향 경로의 요소가 역방향 경로로 이동됩니다. 역방향 경로는 역방향 소스 경로\(즉, 메시지의 현재 위치에서 메시지 발신자까지의 소스 경로\)입니다. 서버-SMTP가 정방향 경로에서 해당 식별자를 삭제하고 역방향 경로에 삽입할 때 메일이 온 환경이 아닌 보내는 환경에서 알려진 이름을 사용해야 합니다. server-SMTP는 환경에 따라 다른 이름으로 알려져 있습니다.

- 메시지가 SMTP에 도착할 때 전달 경로의 첫 번째 요소가 해당 SMTP의 식별자가 아닌 경우 해당 요소는 전달 경로에서 삭제되지 않으며 메시지를 보낼 다음 SMTP를 결정하는 데 사용됩니다. 어떤 경우든 SMTP는 역방향 경로에 자체 식별자를 추가합니다.

- 소스 라우팅을 사용하여 수신자-SMTP는 다른 서버-SMTP로 중계될 메일을 수신합니다. 수신자-SMTP는 로컬 사용자에 대한 메일을 수락하거나 거부하는 것과 동일한 방식으로 메일 중계 작업을 수락하거나 거부할 수 있습니다. Receiver-SMTP는 자체 식별자를 정방향 경로에서 역방향 경로의 시작 부분으로 이동하여 명령 인수를 변환합니다. 그러면 Receiver-SMTP는 Sender-SMTP가 되어 Forward-Path의 다음 SMTP로 전송 채널을 설정하고 메일을 보냅니다.

- reverse-path의 첫 번째 호스트는 SMTP 명령을 보내는 호스트여야 하며, Forward-path의 첫 번째 호스트는 SMTP 명령을 받는 호스트여야 합니다.

- 정방향 경로와 역방향 경로는 SMTP 명령과 응답에 나타나지만 반드시 메시지에는 나타나지는 않습니다. 즉, 이러한 경로, 특히 이 구문이 메시지 헤더의 "To:", "From:", "CC:" 등 필드에 나타날 필요가 없습니다.

- 서버-SMTP가 메일 중계 작업을 수락한 경우

- 나중에 전달 경로가 올바르지 않거나 어떤 이유로든 메일을 배달할 수 없다는 사실을 발견하면 "배달할 수 없는 메일" 알림 메시지를 구성하여 배달할 수 없는 메일의 발신자에게 보내야 합니다\(reverse-path에 표시된 대로\). \).

- 이 알림 메시지는 이 호스트의 서버-SMTP에서 전송되어야 합니다. 물론 서버-SMTP는 알림 메시지 문제에 대한 알림 메시지를 보내서는 안 됩니다. 오류 보고에서 루프를 방지하는 한 가지 방법은 알림 메시지의 MAIL 명령에 null 역방향 경로를 지정하는 것입니다. 그러한 메시지가 전달될 때 역방향 경로를 null로 남겨 두는 것이 허용됩니다. null 역방향 경로가 있는 MAIL 명령은 다음과 같이 나타납니다.

```text
         MAIL FROM:<>
```

- 배달할 수 없는 메일 알림 메시지는 예제 7에 나와 있습니다. 이 알림은 HOSTW에서 JOE가 보낸 메시지에 대한 응답으로 HOSTZ로 전달하라는 지시와 함께 HOSTX를 통해 HOSTY로 전송됩니다. 예제에서 볼 수 있는 것은 알림 메시지 반환의 첫 번째 단계인 HOSTY와 HOSTX 간의 트랜잭션입니다.

```text
      -------------------------------------------------------------

            Example Undeliverable Mail Notification Message
```

S: 메일 보낸 사람:<\>

- R: 250 ok S: RCPT TO:<@HOSTX.ARPA:JOE@HOSTW.ARPA\> R: 250 ok S: DATA R: 354 메일 데이터를 보내고 . S: 날짜: 81년 10월 23일 11:22:33 S: 보낸 사람: SMTP@HOSTY.ARPA S: 받는 사람: JOE@HOSTW.ARPA S: 제목: 메일 시스템 문제 S: S: 죄송합니다. JOE, 메시지는 SAM@HOSTZ로 보내주세요. .ARPA가 손실되었습니다. S: HOSTZ.ARPA가 다음과 같이 말했습니다: S: "550 해당 사용자 없음" S: . 답: 250 그렇군요

```text
                               Example 7

      -------------------------------------------------------------

   3.7.  DOMAINS
```

- 도메인은 ARPA 인터넷 메일 시스템에 최근 도입된 개념입니다. 도메인을 사용하면 주소 공간이 단순한 문자열 호스트 이름의 평면 전역 공간에서 계층적으로 구조화된 전역 주소의 루트 트리로 변경됩니다. 호스트 이름은 도메인 요소가 가장 구체적인 것부터 가장 일반적인 것 순으로 정렬된다는 점을 이해하면서 마침표로 구분된 일련의 도메인 요소 문자열인 도메인 및 호스트 지정자로 대체됩니다.

예를 들어 "USC-ISIF.ARPA", "Fred.Cambridge.UK" 및

- "PC7.LCS.MIT.ARPA"는 호스트 및 도메인 식별자일 수 있습니다.

- SMTP에서 도메인 이름을 사용할 때마다 공식 이름만 사용하며 별명이나 별칭은 사용할 수 없습니다.

```text
   3.8.  CHANGING ROLES
```

- TURN 명령은 전송 채널을 통해 통신하는 두 프로그램의 역할을 바꾸는 데 사용될 수 있습니다.

- 프로그램 A가 현재 sender-SMTP이고 TURN 명령을 보내고 ok 응답\(250\)을 받으면 프로그램 A가 receive-SMTP가 됩니다.

- 프로그램 B가 현재 수신자-SMTP이고 TURN 명령을 수신하고 ok 응답\(250\)을 보내는 경우 프로그램-B는 송신자-SMTP가 됩니다.

- 역할 변경을 거부하려면 수신자는 502 응답을 보냅니다.

- 이 명령은 선택사항이라는 점에 유의하세요. 전송 채널이 TCP인 상황에서는 일반적으로 사용되지 않습니다. 그러나 전송 채널을 설정하는 데 드는 비용이 높을 경우 이 명령은 매우 유용할 수 있습니다. 예를 들어, 이 명령은 특히 일부 호스트가 메일 교환을 위해 다른 호스트를 폴링하는 경우 공중 전화 교환 시스템을 전송 채널로 사용하여 메일 교환을 지원하는 데 유용할 수 있습니다.

---
## **4.  THE SMTP SPECIFICATIONS**

```text
   4.1.  SMTP COMMANDS

      4.1.1.  COMMAND SEMANTICS
```

- SMTP 명령은 사용자가 요청한 메일 전송이나 메일 시스템 기능을 정의합니다. SMTP 명령은 <CRLF\>로 끝나는 문자열입니다. 명령 코드 자체는 매개변수가 뒤따르면 <SP\>로 끝나고 그렇지 않으면 <CRLF\>로 끝나는 알파벳 문자입니다. 사서함 구문은 수신자 사이트 규칙을 따라야 합니다. SMTP 명령은 아래에 설명되어 있습니다. SMTP 응답은 섹션 4.2에서 논의됩니다.

- 메일 트랜잭션에는 다양한 명령에 대한 인수로 전달되는 여러 데이터 개체가 포함됩니다. reverse-path는 MAIL 명령의 인수이고,ward-path는 RCPT 명령의 인수이며, 메일 데이터는 DATA 명령의 인수입니다. 이러한 인수 또는 데이터 개체는 트랜잭션을 완료하는 메일 데이터 종료 표시에 의해 전달된 확인이 있을 때까지 전송 및 보관되어야 합니다. 이에 대한 모델은 데이터 개체 유형을 보유하기 위해 고유한 버퍼가 제공된다는 것입니다. 즉, 역방향 경로 버퍼, 정방향 경로 버퍼 및 메일 데이터 버퍼가 있습니다. 특정 명령을 사용하면 정보가 특정 버퍼에 추가되거나 하나 이상의 버퍼가 지워집니다.

```text
         HELLO (HELO)
```

- 이 명령은 sender-SMTP를 Receiver-SMTP로 식별하는 데 사용됩니다. 인수 필드에는 sender-SMTP의 호스트 이름이 포함됩니다.

- Receiver-SMTP는 연결 인사말 응답과 이 명령에 대한 응답에서 sender-SMTP에 대해 자신을 식별합니다.

- 이 명령과 이에 대한 OK 응답은 sender-SMTP와 Receiver-SMTP가 모두 초기 상태, 즉 진행 중인 트랜잭션이 없고 모든 상태 테이블과 버퍼가 지워졌음을 확인합니다.

```text
         MAIL (MAIL)
```

- 이 명령은 메일 데이터가 하나 이상의 사서함으로 전달되는 메일 트랜잭션을 시작하는 데 사용됩니다. 인수 필드에 역방향 경로가 포함되어 있습니다.

- 역방향 경로는 선택적 호스트 목록과 보낸 사람 사서함으로 구성됩니다. 호스트 목록이 있는 경우 이는 "역방향" 소스 경로이며 메일이 목록의 각 호스트를 통해 중계되었음을 나타냅니다\(목록의 첫 번째 호스트가 가장 최근 중계였습니다\). 이 목록은 보낸 사람에게 배달 못 함 알림을 반환하기 위한 소스 경로로 사용됩니다. 각 릴레이 호스트는 목록의 시작 부분에 자신을 추가하므로 메일이 온 IPCE\(다른 경우\)가 아닌 메일을 릴레이하는 IPCE에 알려진 이름을 사용해야 합니다. 일부 유형의 오류 보고 메시지\(예: 배달할 수 없는 메일 알림\)에서는 역방향 경로가 null일 수 있습니다\(예 7 참조\).

이 명령은 역방향 경로 버퍼를 지웁니다.

- 전달 경로 버퍼 및 메일 데이터 버퍼 이 명령의 역방향 경로 정보를 역방향 경로 버퍼에 삽입합니다.

```text
         RECIPIENT (RCPT)
```

- 이 명령은 메일 데이터의 개별 수신자를 식별하는 데 사용됩니다. 이 명령을 여러 번 사용하면 여러 수신자가 지정됩니다.

- 전달 경로는 선택적 호스트 목록과 필수 대상 사서함으로 구성됩니다. 호스트 목록이 있으면 이는 소스 경로이며 메일이 목록의 다음 호스트로 중계되어야 함을 나타냅니다. Receiver-SMTP가 중계 기능을 구현하지 않는 경우 알 수 없는 로컬 사용자\(550\)에 대한 것과 동일한 응답을 사용할 수 있습니다.

- 메일이 중계될 때 중계 호스트는 시작 정방향 경로에서 자신을 제거하고 역방향 경로의 시작 부분에 위치해야 합니다. 메일이 최종 목적지에 도달하면\(forward-path에는 대상 메일함만 포함됨\), receive-SMTP는 호스트 메일 규칙에 따라 메일을 대상 메일함에 삽입합니다.

- 예를 들어 릴레이 호스트 A에서 인수를 사용하여 수신된 메일

```text
                  FROM:<USERX@HOSTY.ARPA>
                  TO:<@HOSTA.ARPA,@HOSTB.ARPA:USERC@HOSTD.ARPA>
```

- 인수와 함께 호스트 B로 전달됩니다.

```text
                  FROM:<@HOSTA.ARPA:USERX@HOSTY.ARPA>
                  TO:<@HOSTB.ARPA:USERC@HOSTD.ARPA>.
```

- 이 명령은 전달 경로 인수가 전달 경로 버퍼에 추가되도록 합니다.

```text
         DATA (DATA)
```

- 수신자는 명령 다음의 행을 발신자의 메일 데이터로 처리합니다. 이 명령을 사용하면 이 명령의 메일 데이터가 메일 데이터 버퍼에 추가됩니다. 메일 데이터에는 128개의 ASCII 문자 코드가 포함될 수 있습니다.

- 메일 데이터는 마침표만 포함하는 줄, 즉 "<CRLF\>.<CRLF\>" 문자 시퀀스로 종료됩니다\(투명성에 대한 섹션 4.5.2 참조\). 메일 데이터 표시의 끝입니다.

- 메일 데이터 종료 표시는 수신자가 이제 저장된 메일 거래 정보를 처리해야 함을 요구합니다. 이 처리에서는 역방향 경로 버퍼, 전달 경로 버퍼 및 메일 데이터 버퍼의 정보를 소비하며 이 명령이 완료되면 이러한 버퍼가 지워집니다. 처리가 성공하면 수신자는 OK 응답을 보내야 합니다. 처리가 완전히 실패하면 수신자는 실패 응답을 보내야 합니다.

- Receiver-SMTP가 중계 또는 최종 전달을 위해 메시지를 수락하면 메일 데이터 시작 부분에 타임스탬프 줄을 삽입합니다. 타임스탬프 줄은 메시지를 보낸 호스트의 ID, 메시지를 받은\(그리고 이 타임스탬프를 삽입하는\) 호스트의 ID, 메시지를 받은 날짜와 시간을 나타냅니다. 릴레이된 메시지에는 여러 개의 타임스탬프 줄이 있습니다.

- 수신자-SMTP가 메일 데이터의 시작 부분에 삽입하는 메시지의 "최종 전달"을 수행할 때

- 복귀 경로 라인. 반환 경로 줄은 MAIL 명령의 <reverse-path\> 정보를 유지합니다. 여기서 최종 전달은 메시지가 SMTP 세계를 떠난다는 의미입니다. 일반적으로 이는 대상 사용자에게 전달되었음을 의미하지만 경우에 따라 다른 메일 시스템에서 추가 처리 및 전송될 수 있습니다.

- 반환 경로의 사서함이 실제 보낸 사람의 사서함과 다를 수 있습니다. 예를 들어 오류 응답이 메시지 보낸 사람이 아닌 특수 오류 처리 사서함으로 전달되는 경우입니다.

- 앞의 두 단락은 최종 메일 데이터가 반환 경로 줄로 시작하고 그 뒤에 하나 이상의 타임스탬프 줄이 따른다는 것을 의미합니다. 이 줄 다음에는 메일 데이터 헤더와 본문\[2\]이 옵니다. 예시 8을 참조하세요.

- 메일 데이터 표시 종료 후 처리가 부분적으로 성공한 경우 필요한 응답 및 추가 조치에 대해 특별히 언급할 필요가 있습니다. 이는 여러 수신자와 메일 데이터를 수락한 후 수신자-SMTP가 메일 데이터가 일부 수신자에게는 성공적으로 전달될 수 있지만 다른 수신자에게는 전달될 수 없음을 발견한 경우\(예: 메일박스 공간 ​​할당 문제로 인해\) 발생할 수 있습니다. 이러한 상황에서는 DATA 명령에 대한 응답이 OK 응답이어야 합니다. 그러나 수신자-SMTP는 "배달할 수 없는 메일" 알림 메시지를 작성하여 메시지 발신자에게 보내야 합니다. 메시지를 가져오지 못한 모든 수신자를 나열하는 단일 알림 또는 실패한 각 수신자에 대해 별도의 알림 메시지를 보내야 합니다\(예 7 참조\). 배달할 수 없는 모든 메일 알림 메시지는 MAIL 명령을 사용하여 전송됩니다\(SEND, SOML 또는 SAML 명령을 처리한 결과인 경우에도 마찬가지\).

```text
     -------------------------------------------------------------
```

- 반환 경로 및 수신된 타임 스탬프의 예

```text
      Return-Path: <@GHI.ARPA,@DEF.ARPA,@ABC.ARPA:JOE@ABC.ARPA>   
      Received: from GHI.ARPA by JKL.ARPA ; 27 Oct 81 15:27:39 PST
      Received: from DEF.ARPA by GHI.ARPA ; 27 Oct 81 15:15:13 PST
      Received: from ABC.ARPA by DEF.ARPA ; 27 Oct 81 15:01:59 PST
      Date: 27 Oct 81 15:01:01 PST                                
      From: JOE@ABC.ARPA                                          
      Subject: Improved Mailing System Installed                  
      To: SAM@JKL.ARPA                                            
                                    
      This is to inform you that ...                              

                               Example 8

     -------------------------------------------------------------

         SEND (SEND)
```

- 이 명령은 메일 데이터가 하나 이상의 터미널에 전달되는 메일 트랜잭션을 시작하는 데 사용됩니다. 인수 필드에 역방향 경로가 포함되어 있습니다. 메시지가 터미널에 전달되면 이 명령은 성공한 것입니다.

- 역방향 경로는 선택적 호스트 목록과 보낸 사람 사서함으로 구성됩니다. 호스트 목록이 있는 경우 이는 "역방향" 소스 경로이며 메일이 목록의 각 호스트를 통해 중계되었음을 나타냅니다\(목록의 첫 번째 호스트가 가장 최근 중계였습니다\). 이 목록은 보낸 사람에게 배달 못 함 알림을 반환하기 위한 소스 경로로 사용됩니다. 각 릴레이 호스트는 목록의 시작 부분에 자신을 추가하므로 메일이 온 IPCE\(다른 경우\)가 아닌 메일을 릴레이하는 IPCE에 알려진 이름을 사용해야 합니다.

이 명령은 역방향 경로 버퍼를 지웁니다.

- 전달 경로 버퍼 및 메일 데이터 버퍼 이 명령의 역방향 경로 정보를 역방향 경로 버퍼에 삽입합니다.

```text
         SEND OR MAIL (SOML)
```

- 이 명령은 메일 데이터가 하나 이상의 터미널로 전달되는 메일 트랜잭션을 시작하는 데 사용됩니다.

- 사서함. 각 수신자에 대해 메일 데이터는 수신자가 호스트에서 활성 상태이고 터미널 메시지를 수락하는 경우 수신자의 터미널로 전달되고, 그렇지 않으면 수신자의 사서함으로 전달됩니다. 인수 필드에 역방향 경로가 포함되어 있습니다. 메시지가 터미널이나 사서함으로 전달되면 이 명령은 성공한 것입니다.

- 역방향 경로는 선택적 호스트 목록과 보낸 사람 사서함으로 구성됩니다. 호스트 목록이 있는 경우 이는 "역방향" 소스 경로이며 메일이 목록의 각 호스트를 통해 중계되었음을 나타냅니다\(목록의 첫 번째 호스트가 가장 최근 중계였습니다\). 이 목록은 보낸 사람에게 배달 못 함 알림을 반환하기 위한 소스 경로로 사용됩니다. 각 릴레이 호스트는 목록의 시작 부분에 자신을 추가하므로 메일이 온 IPCE\(다른 경우\)가 아닌 메일을 릴레이하는 IPCE에 알려진 이름을 사용해야 합니다.

이 명령은 역방향 경로 버퍼를 지웁니다.

- 전달 경로 버퍼 및 메일 데이터 버퍼 이 명령의 역방향 경로 정보를 역방향 경로 버퍼에 삽입합니다.

```text
         SEND AND MAIL (SAML)
```

- 이 명령은 메일 데이터가 하나 이상의 터미널과 사서함으로 전달되는 메일 트랜잭션을 시작하는 데 사용됩니다. 각 수신자에 대해 메일 데이터는 수신자가 호스트에서 활성 상태이고 터미널 메시지를 수락하는 경우 수신자의 터미널로 전달되고 모든 수신자에 대한 메일 데이터는 수신자의 사서함으로 전달됩니다. 인수 필드에 역방향 경로가 포함되어 있습니다. 메시지가 사서함으로 배달되면 이 명령은 성공한 것입니다.

- 역방향 경로는 선택적 호스트 목록과 보낸 사람 사서함으로 구성됩니다. 호스트 목록이 있는 경우 이는 "역방향" 소스 경로이며 메일이 목록의 각 호스트를 통해 중계되었음을 나타냅니다\(목록의 첫 번째 호스트가 가장 최근 중계였습니다\). 이 목록은 보낸 사람에게 배달 못 함 알림을 반환하기 위한 소스 경로로 사용됩니다. 각 릴레이 호스트는 목록의 시작 부분에 자신을 추가하므로 메일이 온 IPCE\(다른 경우\)가 아닌 메일을 릴레이하는 IPCE에 알려진 이름을 사용해야 합니다.

- 이 명령은 역방향 경로 버퍼를 지웁니다.

- 전달 경로 버퍼 및 메일 데이터 버퍼 이 명령의 역방향 경로 정보를 역방향 경로 버퍼에 삽입합니다.

```text
         RESET (RSET)
```

- 이 명령은 현재 메일 트랜잭션을 중단하도록 지정합니다. 저장된 보낸 사람, 받는 사람, 메일 데이터를 모두 삭제하고 모든 버퍼와 상태 테이블을 지워야 합니다. 수신자는 OK 응답을 보내야 합니다.

```text
         VERIFY (VRFY)
```

- 이 명령은 수신자에게 인수가 사용자를 식별하는지 확인하도록 요청합니다. 사용자 이름인 경우 사용자의 전체 이름\(알려진 경우\)과 완전히 지정된 사서함이 반환됩니다.

- 이 명령은 역방향 경로 버퍼, 정방향 경로 버퍼 또는 메일 데이터 버퍼에 영향을 주지 않습니다.

```text
         EXPAND (EXPN)
```

- 이 명령은 수신자에게 인수가 메일링 목록을 식별하는지 확인하고, 그렇다면 해당 목록의 멤버십을 반환하도록 요청합니다. 사용자의 전체 이름\(알고 있는 경우\)과 완전히 지정된 사서함이 여러 줄의 응답으로 반환됩니다.

- 이 명령은 역방향 경로 버퍼, 정방향 경로 버퍼 또는 메일 데이터 버퍼에 영향을 주지 않습니다.

```text
         HELP (HELP)
```

- 이 명령은 수신자가 HELP 명령 발신자에게 유용한 정보를 보내도록 합니다. 명령은 인수\(예: 명령 이름\)를 취하고 보다 구체적인 정보를 응답으로 반환할 수 있습니다.

- 이 명령은 역방향 경로 버퍼, 정방향 경로 버퍼 또는 메일 데이터 버퍼에 영향을 주지 않습니다.

```text
         NOOP (NOOP)
```

- 이 명령은 매개 변수나 이전에 입력한 명령에 영향을 주지 않습니다. 수신자가 OK 응답을 보내는 것 외에는 어떤 작업도 지정하지 않습니다.

- 이 명령은 역방향 경로 버퍼, 정방향 경로 버퍼 또는 메일 데이터 버퍼에 영향을 주지 않습니다.

```text
         QUIT (QUIT)
```

- 이 명령은 수신자가 OK 응답을 보낸 다음 전송 채널을 닫아야 함을 지정합니다.

- 수신자는 QUIT 명령을 수신하고 응답할 때까지 전송 채널을 닫아서는 안 됩니다\(오류가 있더라도\). 발신자는 QUIT 명령을 보내고 응답을 받을 때까지 전송 채널을 닫아서는 안 됩니다\(이전 명령에 대한 오류 응답이 있더라도\). 연결이 조기에 닫히면 수신자는 RSET 명령이 수신된 것처럼 작동해야 합니다\(보류 중인 트랜잭션은 취소하지만 이전에 완료된 트랜잭션은 취소하지 않음\). 송신자는 진행 중인 명령이나 트랜잭션이 일시적인 오류를 수신한 것처럼 작동해야 합니다. \(4xx\).

```text
         TURN (TURN)
```

- 이 명령은 수신자가 \(1\) OK 응답을 보낸 다음 sender-SMTP의 역할을 맡거나 \(2\) 거부 응답을 보내고 수신자-SMTP의 역할을 유지해야 함을 지정합니다.

- 프로그램 A가 현재 sender-SMTP이고 TURN 명령을 보내고 OK 응답\(250\)을 받으면 프로그램 A가 receive-SMTP가 됩니다. 프로그램 A는 전송 채널이 막 열린 것처럼 초기 상태에 있으며 220 서비스 준비 인사말을 보냅니다.

- 프로그램 B가 현재 수신자-SMTP이고 TURN 명령을 수신하고 OK 응답\(250\)을 보내는 경우 프로그램-B는 송신자-SMTP가 됩니다. Program-B는 마치 전송 채널이 방금 열린 것처럼 초기 상태에 있으며 220 서비스 준비 인사말을 수신할 것으로 예상합니다.

- 역할 변경을 거부하려면 수신자는 502 응답을 보냅니다.

- 이 명령을 사용하는 순서에는 제한이 있습니다.

- 세션의 첫 번째 명령은 HELO 명령이어야 합니다. HELO 명령은 나중에 세션에서도 사용될 수 있습니다. HELO 명령 인수가 허용되지 않으면 501 실패 응답이 반환되어야 하며 수신자-SMTP는 동일한 상태를 유지해야 합니다.

- NOOP, HELP, EXPN 및 VRFY 명령은 세션 중 언제든지 사용할 수 있습니다.

MAIL, SEND, SOML 또는 SAML 명령은 메일을 시작합니다.

-        거래. 일단 시작된 메일 트랜잭션은 트랜잭션 시작 명령 중 하나, 하나 이상의 RCPT 명령, DATA 명령 순으로 구성됩니다. 메일 트랜잭션은 RSET 명령에 의해 중단될 수 있습니다. 세션에는 0개 이상의 트랜잭션이 있을 수 있습니다.

- 트랜잭션 시작 명령 인수가 허용되지 않으면 501 실패 응답이 반환되어야 하며 수신자-SMTP는 동일한 상태를 유지해야 합니다. 트랜잭션의 명령이 잘못된 경우 503 실패 응답이 반환되어야 하며 수신자-SMTP는 동일한 상태를 유지해야 합니다.

- 세션의 마지막 명령은 QUIT 명령이어야 합니다. QUIT 명령은 세션의 다른 시간에는 사용할 수 없습니다.

```text
      4.1.2.  COMMAND SYNTAX
```

- 명령은 명령 코드와 인수 필드로 구성됩니다. 명령 코드는 4개의 알파벳 문자입니다. 영문 대문자와 소문자는 동일하게 취급됩니다. 따라서 다음 중 하나가 mail 명령을 나타낼 수 있습니다.

```text
            MAIL    Mail    mail    MaIl    mAIl
```

- 이는 전달 경로에 대한 "TO" 또는 "to"와 같은 매개변수 값을 나타내는 모든 기호에도 적용됩니다. 명령 코드와 인수 필드는 하나 이상의 공백으로 구분됩니다. 그러나 역방향 경로 및 정방향 경로 인수 내에서는 대소문자가 중요합니다. 특히 일부 호스트에서는 사용자 "smith"가 사용자 "Smith"와 다릅니다.

- 인수 필드는 문자 시퀀스 <CRLF\>로 끝나는 가변 길이 문자열로 구성됩니다. 수신자는 이 시퀀스를 수신할 때까지 아무런 조치도 취하지 않아야 합니다.

- 대괄호는 선택적 인수 필드를 나타냅니다. 옵션을 선택하지 않으면 적절한 기본값이 암시됩니다.

- 다음은 SMTP 명령입니다.

```text
            HELO <SP> <domain> <CRLF>

            MAIL <SP> FROM:<reverse-path> <CRLF>

            RCPT <SP> TO:<forward-path> <CRLF>

            DATA <CRLF>

            RSET <CRLF>

            SEND <SP> FROM:<reverse-path> <CRLF>

            SOML <SP> FROM:<reverse-path> <CRLF>

            SAML <SP> FROM:<reverse-path> <CRLF>

            VRFY <SP> <string> <CRLF>

            EXPN <SP> <string> <CRLF>

            HELP [<SP> <string>] <CRLF>

            NOOP <CRLF>

            QUIT <CRLF>

            TURN <CRLF>
```

- 위 인수 필드의 구문\(해당되는 경우 BNF 표기법 사용\)은 다음과 같습니다. "..." 표기법은 필드가 한 번 이상 반복될 수 있음을 나타냅니다.

```text
            <reverse-path> ::= <path>

            <forward-path> ::= <path>

            <path> ::= "<" [ <a-d-l> ":" ] <mailbox> ">"

            <a-d-l> ::= <at-domain> | <at-domain> "," <a-d-l>

            <at-domain> ::= "@" <domain>

            <domain> ::=  <element> | <element> "." <domain>

            <element> ::= <name> | "#" <number> | "[" <dotnum> "]"

            <mailbox> ::= <local-part> "@" <domain>

            <local-part> ::= <dot-string> | <quoted-string>

            <name> ::= <a> <ldh-str> <let-dig>

            <ldh-str> ::= <let-dig-hyp> | <let-dig-hyp> <ldh-str>

            <let-dig> ::= <a> | <d>

            <let-dig-hyp> ::= <a> | <d> | "-"

            <dot-string> ::= <string> | <string> "." <dot-string>

            <string> ::= <char> | <char> <string>

            <quoted-string> ::=  """ <qtext> """

            <qtext> ::=  "\" <x> | "\" <x> <qtext> | <q> | <q> <qtext>

            <char> ::= <c> | "\" <x>

            <dotnum> ::= <snum> "." <snum> "." <snum> "." <snum>

            <number> ::= <d> | <d> <number>

            <CRLF> ::= <CR> <LF>

            <CR> ::= the carriage return character (ASCII code 13)

            <LF> ::= the line feed character (ASCII code 10)

            <SP> ::= the space character (ASCII code 32)
```

- <snum\> ::= 0\~255 범위의 10진수 값을 나타내는 1자리, 2자리 또는 3자리 숫자

- <a\> ::= 대문자 A\~Z, 소문자 a\~z 중 52개의 영문자 중 하나

- <c\> ::= 128개의 ASCII 문자 중 하나\(<특수\> 또는 <SP\>는 제외\)

- <d\> ::= 0부터 9까지의 10자리 숫자 중 하나

```text
            <q> ::= any one of the 128 ASCII characters except <CR>,
                      <LF>, quote ("), or backslash (\)

            <x> ::= any one of the 128 ASCII characters (no exceptions)

            <special> ::= "<" | ">" | "(" | ")" | "[" | "]" | "\" | "."
                      | "," | ";" | ":" | "@"  """ | the control
                      characters (ASCII codes 0 through 31 inclusive and
                      127)
```

- 백슬래시 "\"는 다음 문자가 문자 그대로\(일반적인 해석 대신\) 사용됨을 나타내는 데 사용되는 따옴표 문자입니다. 예를 들어, "Joe\,Smith"는 필드의 네 번째 문자가 쉼표인 단일 9자 사용자 필드를 나타내는 데 사용할 수 있습니다.

- 호스트는 일반적으로 각 호스트의 주소로 변환되는 이름으로 알려져 있습니다. 도메인의 이름 요소는 공식 이름이므로 별명이나 별칭을 사용할 수 없습니다.

- 때로는 번역 기능에 호스트가 알려지지 않아 통신이 차단되는 경우가 있습니다. 이 장벽을 우회하기 위해 호스트 "이름"에 두 가지 숫자 형식도 허용됩니다. 한 가지 형식은 숫자가 호스트의 주소임을 나타내는 파운드 기호 "#"이 앞에 붙는 10진수 정수입니다. 또 다른 형식은 점으로 구분되고 대괄호로 묶인 네 개의 작은 십진 정수입니다\(예: "\[123.255.37.2\]"\). 이는 네 개의 8비트 필드에 32비트 ARPA 인터넷 주소를 나타냅니다.

- 타임스탬프 줄과 반환 경로 줄은 공식적으로 다음과 같이 정의됩니다.

```text
         <return-path-line> ::= "Return-Path:" <SP><reverse-path><CRLF>

         <time-stamp-line> ::= "Received:" <SP> <stamp> <CRLF>

            <stamp> ::= <from-domain> <by-domain> <opt-info> ";"
                      <daytime>

            <from-domain> ::= "FROM" <SP> <domain> <SP>

            <by-domain> ::= "BY" <SP> <domain> <SP>

            <opt-info> ::= [<via>] [<with>] [<id>] [<for>]

            <via> ::= "VIA" <SP> <link> <SP>

            <with> ::= "WITH" <SP> <protocol> <SP>

            <id> ::= "ID" <SP> <string> <SP>

            <for> ::= "FOR" <SP> <path> <SP>
```

- <link\> ::= 링크의 표준 이름은 네트워크 정보 센터에 등록되어 있습니다.

<protocol\> ::= 프로토콜의 표준 이름은 다음과 같습니다.

- 네트워크정보센터에 등록되어 있습니다.

```text
            <daytime> ::= <SP> <date> <SP> <time>

            <date> ::= <dd> <SP> <mon> <SP> <yy>

            <time> ::= <hh> ":" <mm> ":" <ss> <SP> <zone>
```

- <dd\> ::= 1\~31 범위의 월 중 한 자리 또는 두 자리의 십진수 날짜입니다.

```text
            <mon> ::= "JAN" | "FEB" | "MAR" | "APR" | "MAY" | "JUN" |
                      "JUL" | "AUG" | "SEP" | "OCT" | "NOV" | "DEC"
```

- <yy\> ::= 00\~99 범위의 세기를 나타내는 두 개의 십진수 연도입니다.

- <hh\> ::= 00\~24 범위의 하루 중 두 개의 십진수 시간입니다.

- <mm\> ::= 00\~59 범위의 시간을 나타내는 두 개의 십진수 분입니다.

- <ss\> ::= 00\~59 범위의 분을 나타내는 두 개의 십진수 정수 초입니다.

- <zone\> ::= "UT"는 세계시\(기본값\) 또는 기타 시간대 지정자\(\[2\]에서와 같이\)를 의미합니다.

```text
            

     -------------------------------------------------------------

                          Return Path Example

         Return-Path: <@CHARLIE.ARPA,@BAKER.ARPA:JOE@ABLE.ARPA>

                               Example 9

     -------------------------------------------------------------

     -------------------------------------------------------------

                        Time Stamp Line Example
```

- 수신: ABC.ARPA에서 XYZ.ARPA로; 81년 10월 22일 09:23:59 PDT

- 수신: Smith@PDQ.ARPA에 대해 X25 ID M12345를 사용하여 TELENET을 통해 XYZ.ARPA에 의해 ABC.ARPA에서; 81년 10월 22일 09:23:59 PDT

```text
                               Example 10

      -------------------------------------------------------------

   4.2.  SMTP REPLIES
```

- SMTP 명령에 대한 응답은 메일 전송 과정에서 요청과 작업의 동기화를 보장하고 보낸 사람-SMTP가 항상 받는 사람-SMTP의 상태를 알 수 있도록 고안되었습니다. 모든 명령은 정확히 하나의 응답을 생성해야 합니다.

- 명령-응답 시퀀스의 세부 사항은 시퀀싱 섹션 5.3 및 섹션 5.4 상태 다이어그램에 명시되어 있습니다.

- SMTP 응답은 세 자리 숫자\(세 개의 영숫자 문자로 전송됨\)와 일부 텍스트로 구성됩니다. 이 숫자는 오토마타가 다음에 어떤 상태로 들어갈지 결정하는 데 사용됩니다. 텍스트는 인간 사용자를 위한 것입니다. 세 자리 숫자에는 송신자-SMTP가 텍스트를 검사할 필요가 없고 적절하게 이를 폐기하거나 사용자에게 전달할 수 있을 만큼 충분한 인코딩된 정보가 포함되어 있습니다. 특히, 텍스트는 수신자 및 상황에 따라 달라질 수 있으므로 각 응답 코드에 대해 다양한 텍스트가 있을 수 있습니다. 응답 코드 이론에 대한 논의는 부록 E에 나와 있습니다. 공식적으로 응답은 세 자리 코드, <SP\>, 한 줄의 텍스트, <CRLF\> 또는 여러 줄의 응답\( 부록 E에 정의된 대로\). EXPN 및 HELP 명령만 일반적인 상황에서 여러 줄로 응답할 것으로 예상되지만 모든 명령에 대해 여러 줄로 응답할 수 있습니다.

- 4.2.1. 기능 그룹별 응답 코드

```text
         500 Syntax error, command unrecognized
            [This may include errors such as command line too long]
         501 Syntax error in parameters or arguments
         502 Command not implemented
         503 Bad sequence of commands
         504 Command parameter not implemented
          
         211 System status, or system help reply
         214 Help message
            [Information on how to use the receiver or the meaning of a
            particular non-standard command; this reply is useful only
            to the human user]
          
         220 <domain> Service ready
         221 <domain> Service closing transmission channel
         421 <domain> Service not available,
             closing transmission channel
            [This may be a reply to any command if the service knows it
            must shut down]
          
         250 Requested mail action okay, completed
         251 User not local; will forward to <forward-path>
         450 Requested mail action not taken: mailbox unavailable
            [E.g., mailbox busy]
         550 Requested action not taken: mailbox unavailable
            [E.g., mailbox not found, no access]
         451 Requested action aborted: error in processing
         551 User not local; please try <forward-path>
         452 Requested action not taken: insufficient system storage
         552 Requested mail action aborted: exceeded storage allocation
         553 Requested action not taken: mailbox name not allowed
            [E.g., mailbox syntax incorrect]
         354 Start mail input; end with <CRLF>.<CRLF>
         554 Transaction failed
         
```

- 4.2.2. 응답 코드의 숫자 순서 목록

```text
         211 System status, or system help reply
         214 Help message
            [Information on how to use the receiver or the meaning of a
            particular non-standard command; this reply is useful only
            to the human user]
         220 <domain> Service ready
         221 <domain> Service closing transmission channel
         250 Requested mail action okay, completed
         251 User not local; will forward to <forward-path>
          
         354 Start mail input; end with <CRLF>.<CRLF>
          
         421 <domain> Service not available,
             closing transmission channel
            [This may be a reply to any command if the service knows it
            must shut down]
         450 Requested mail action not taken: mailbox unavailable
            [E.g., mailbox busy]
         451 Requested action aborted: local error in processing
         452 Requested action not taken: insufficient system storage
          
         500 Syntax error, command unrecognized
            [This may include errors such as command line too long]
         501 Syntax error in parameters or arguments
         502 Command not implemented
         503 Bad sequence of commands
         504 Command parameter not implemented
         550 Requested action not taken: mailbox unavailable
            [E.g., mailbox not found, no access]
         551 User not local; please try <forward-path>
         552 Requested mail action aborted: exceeded storage allocation
         553 Requested action not taken: mailbox name not allowed
            [E.g., mailbox syntax incorrect]
         554 Transaction failed
         
```

4.3. 명령과 응답의 순서

- 발신자와 수신자 간의 통신은 발신자가 제어하는 ​​교대 대화로 이루어집니다. 따라서 송신자는 명령을 내리고 수신자는 응답으로 응답합니다. 발신자는 추가 명령을 보내기 전에 이 응답을 기다려야 합니다.

- 중요한 답변 중 하나는 연결 인사말입니다. 일반적으로 수신자는 연결이 완료되면 220 "서비스 준비" 응답을 보냅니다. 발신자는 명령을 보내기 전에 이 인사말 메시지를 기다려야 합니다.

- 참고: 모든 인사말 유형 응답에는 응답 코드 다음의 첫 번째 단어로 서버 호스트의 공식 이름이 포함됩니다.

-        예를 들어,

```text
               220 <SP> USC-ISIF.ARPA <SP> Service ready <CRLF>
```

- 아래 표에는 각 명령에 대한 대체 성공 및 실패 응답이 나열되어 있습니다. 이는 엄격하게 준수되어야 합니다. 수신자는 응답의 텍스트를 대체할 수 있지만 코드 번호와 특정 명령 응답 순서가 암시하는 의미와 동작은 변경할 수 없습니다.

```text
      COMMAND-REPLY SEQUENCES
```

- 각 명령은 가능한 응답과 함께 나열됩니다. 가능한 응답 앞에 사용되는 접두사는 예비\(SMTP에서는 사용되지 않음\)의 경우 "P", 중간의 경우 "I", 성공의 경우 "S", 실패의 경우 "F", 오류의 경우 "E"입니다. 421 응답\(서비스를 사용할 수 없음, 전송 채널 닫음\)은 SMTP 수신자가 종료해야 한다는 것을 알고 있는 경우 모든 명령에 제공될 수 있습니다. 이 목록은 섹션 4.4의 상태 다이어그램의 기초를 형성합니다.

```text
            CONNECTION ESTABLISHMENT
               S: 220
               F: 421
            HELO
               S: 250
               E: 500, 501, 504, 421
            MAIL
               S: 250
               F: 552, 451, 452
               E: 500, 501, 421

            RCPT
               S: 250, 251
               F: 550, 551, 552, 553, 450, 451, 452
               E: 500, 501, 503, 421
            DATA
               I: 354 -> data -> S: 250
                                 F: 552, 554, 451, 452
               F: 451, 554
               E: 500, 501, 503, 421
            RSET
               S: 250
               E: 500, 501, 504, 421
            SEND
               S: 250
               F: 552, 451, 452
               E: 500, 501, 502, 421
            SOML
               S: 250
               F: 552, 451, 452
               E: 500, 501, 502, 421
            SAML
               S: 250
               F: 552, 451, 452
               E: 500, 501, 502, 421
            VRFY
               S: 250, 251
               F: 550, 551, 553
               E: 500, 501, 502, 504, 421
            EXPN
               S: 250
               F: 550
               E: 500, 501, 502, 504, 421
            HELP
               S: 211, 214
               E: 500, 501, 502, 504, 421
            NOOP
               S: 250
               E: 500, 421
            QUIT
               S: 221
               E: 500
            TURN
               S: 250
               F: 502
               E: 500, 503

   4.4.  STATE DIAGRAMS
```

다음은 단순한 SMTP에 대한 상태 다이어그램입니다.

-  구현. 응답 코드의 첫 번째 숫자만 사용됩니다. 각 SMTP 명령 그룹에 대해 하나의 상태 다이어그램이 있습니다. 명령 그룹화는 각 명령에 대한 모델을 구성한 다음 구조적으로 동일한 모델로 명령을 함께 수집하여 결정되었습니다.

- 각 명령에는 "성공"\(S\), "실패"\(F\) 및 "오류"\(E\)의 세 가지 가능한 결과가 있습니다. 아래 상태 다이어그램에서는 "시작"을 나타내는 기호 B를 사용하고 "응답 대기"를 나타내는 기호 W를 사용합니다.

- 먼저 대부분의 SMTP 명령을 나타내는 다이어그램은 다음과 같습니다.

```text
         
                                  1,3    +---+
                             ----------->| E |
                            |            +---+
                            |
         +---+    cmd    +---+    2      +---+
         | B |---------->| W |---------->| S |
         +---+           +---+           +---+
                            |
                            |     4,5    +---+
                             ----------->| F |
                                         +---+
         
```

- 이 다이어그램은 다음 명령을 모델링합니다.

```text
            HELO, MAIL, RCPT, RSET, SEND, SOML, SAML, VRFY, EXPN, HELP,
            NOOP, QUIT, TURN.
```

- 보다 복잡한 다이어그램은 DATA 명령을 모델링합니다.

```text
         
         +---+   DATA    +---+ 1,2                 +---+
         | B |---------->| W |-------------------->| E |
         +---+           +---+        ------------>+---+
                         3| |4,5     |
                          | |        |
            --------------   -----   |
           |                      |  |             +---+
           |               ----------     -------->| S |
           |              |       |      |         +---+
           |              |  ------------
           |              | |     |
           V           1,3| |2    |
         +---+   data    +---+     --------------->+---+
         |   |---------->| W |                     | F |
         +---+           +---+-------------------->+---+
                              4,5
```

- 여기서 "데이터"는 발신자에서 수신자로 전송되는 일련의 라인이며 마지막 라인이 전송될 때까지 응답이 예상되지 않습니다.

```text
   4.5.  DETAILS

      4.5.1.  MINIMUM IMPLEMENTATION
```

SMTP를 실행 가능하게 하려면 다음과 같은 최소값이 필요합니다.

- 모든 수신기에 구현이 필요합니다.

```text
            COMMANDS -- HELO
                        MAIL
                        RCPT
                        DATA
                        RSET
                        NOOP
                        QUIT

      4.5.2.  TRANSPARENCY
```

- 데이터 투명성을 위한 규정이 없으면 문자 시퀀스 "<CRLF\>.<CRLF\>"는 메일 텍스트를 끝내고 사용자가 보낼 수 없습니다. 일반적으로 사용자는 이러한 "금지된" 시퀀스를 인식하지 못합니다. 사용자가 작성한 모든 텍스트를 투명하게 전송하려면 다음 절차를 따르십시오.

- 1. 메일 텍스트 한 줄을 보내기 전에 sender-SMTP는 줄의 첫 번째 문자를 확인합니다. 마침표인 경우 줄 시작 부분에 마침표가 하나 더 삽입됩니다.

- 2. 수신자-SMTP가 메일 텍스트 한 줄을 받으면 해당 줄을 확인합니다. 줄이 단일 마침표로 구성되어 있으면 메일이 끝납니다. 첫 번째 문자가 마침표이고 줄에 다른 문자가 있으면 첫 번째 문자가 삭제됩니다.

- 메일 데이터에는 128개의 ASCII 문자가 포함될 수 있습니다. 포맷 이펙터 및 기타 제어 문자를 포함한 모든 문자는 수신자의 사서함으로 전달됩니다. 전송 채널이 8비트 바이트\(옥텟\) 데이터 스트림을 제공하는 경우 7비트 ASCII 코드는 상위 비트가 0으로 지워진 상태로 옥텟에서 오른쪽 정렬되어 전송됩니다.

- 일부 시스템에서는 데이터가 수신되고 저장될 때 데이터를 변환해야 할 수도 있습니다. 이는 로컬 문자 집합으로 ASCII가 아닌 다른 문자 집합을 사용하거나 ASCII가 아닌 레코드에 데이터를 저장하는 호스트에 필요할 수 있습니다.

- 문자열. 그러한 변환이 필요한 경우에는 되돌릴 수 있어야 합니다. 특히 그러한 변환이 중계되는 메일에 적용되는 경우에는 더욱 그렇습니다.

```text
      4.5.3.  SIZES
```

- 최소 최대 크기가 필요한 개체가 여러 개 있습니다. 즉, 모든 구현은 최소한 이 크기의 개체를 수신할 수 있어야 하지만 이 크기보다 큰 개체를 보내서는 안 됩니다.

```text
                                    
          ****************************************************
          *                                                  *
          *  TO THE MAXIMUM EXTENT POSSIBLE, IMPLEMENTATION  *
          *  TECHNIQUES WHICH IMPOSE NO LIMITS ON THE LENGTH *
          *  OF THESE OBJECTS SHOULD BE USED.                *
          *                                                  *
          ****************************************************

            user
```

- 사용자 이름의 최대 총 길이는 64자입니다.

```text
            domain
```

- 도메인 이름 또는 번호의 최대 총 길이는 64자입니다.

```text
            path
```

역방향 경로의 최대 총 길이 또는

- 정방향 경로는 256자입니다\(구두점 및 요소 구분 기호 포함\).

```text
            command line
```

- 명령어와 <CRLF\>를 포함한 명령줄의 최대 총 길이는 512자입니다.

```text
            reply line
```

- 응답 코드와 <CRLF\>를 포함한 응답 줄의 최대 총 길이는 512자입니다.

```text
            text line
```

- <CRLF\>를 포함한 텍스트 줄의 최대 총 길이는 1000자입니다. \(단, 투명도를 위해 중복된 앞 점은 포함하지 않습니다.\)

```text
            recipients buffer
```

- 버퍼링해야 하는 최대 총 수신자 수는 100명입니다.

```text
                                    
          ****************************************************
          *                                                  *
          *  TO THE MAXIMUM EXTENT POSSIBLE, IMPLEMENTATION  *
          *  TECHNIQUES WHICH IMPOSE NO LIMITS ON THE LENGTH *
          *  OF THESE OBJECTS SHOULD BE USED.                *
          *                                                  *
          ****************************************************
```

- 이러한 제한 초과로 인한 오류는 다음과 같은 응답 코드를 사용하여 보고될 수 있습니다.

```text
            500 Line too long.

            501 Path too long

            552 Too many recipients.

            552 Too much mail data.
```

---
# **APPENDIX A**

```text
   TCP Transport service
```

ARPA에서는 전송 제어 프로토콜 \[3\]이 사용됩니다.

- 인터넷 및 인터네트워크 프로토콜에 대한 미국 DoD 표준을 따르는 모든 네트워크.

```text
      Connection Establishment
```

- SMTP 전송 채널은 송신자 프로세스 포트 U와 수신자 프로세스 포트 L 사이에 설정된 TCP 연결입니다. 이 단일 전이중 연결이 전송 채널로 사용됩니다. 이 프로토콜에는 서비스 포트 25\(8진수 31\), 즉 L=25가 할당됩니다.

```text
      Data Transfer
```

- TCP 연결은 8비트 바이트 전송을 지원합니다. SMTP 데이터는 7비트 ASCII 문자입니다. 각 문자는 상위 비트가 0으로 지워진 8비트 바이트로 전송됩니다.

---
# **APPENDIX B**

```text
   NCP Transport service
```

- ARPANET 호스트-호스트 프로토콜\[4\]\(네트워크 제어 프로그램에 의해 구현됨\)이 ARPANET에서 사용될 수 있습니다.

```text
      Connection Establishment
```

- SMTP 전송 채널은 송신자 프로세스 소켓 U와 수신자 프로세스 소켓 L 사이에 NCP를 통해 설정됩니다. 초기 연결 프로토콜 \[5\]을 따르면 한 쌍의 단순 연결이 생성됩니다. 이 연결 쌍은 전송 채널로 사용됩니다. 이 프로토콜에는 접점 소켓 25\(31 옥탈\), 즉 L=25가 할당됩니다.

```text
      Data Transfer
```

- NCP 데이터 연결은 8비트 바이트 모드로 설정됩니다. SMTP 데이터는 7비트 ASCII 문자입니다. 각 문자는 상위 비트가 0으로 지워진 8비트 바이트로 전송됩니다.

---
# **APPENDIX C**

```text
   NITS
```

- 네트워크 독립 전송 서비스\[6\]를 사용할 수 있다.

```text
      Connection Establishment
```

- SMTP 전송 채널은 송신자 프로세스와 수신자 프로세스 사이에 NITS를 통해 설정됩니다. 송신자 프로세스는 CONNECT 프리미티브를 실행하고, 대기 중인 수신자 프로세스는 ACCEPT 프리미티브를 실행합니다.

```text
      Data Transfer
```

- NITS 연결은 8비트 바이트 전송을 지원합니다. SMTP 데이터는 7비트 ASCII 문자입니다. 각 문자는 상위 비트가 0으로 지워진 8비트 바이트로 전송됩니다.

---
# **APPENDIX D**

```text
   X.25 Transport service
```

- 공공 데이터 네트워크\(Public Data Networks\)에서 직접 제공하는 X.25 서비스\[7\]를 사용할 수도 있지만, X.25 연결 위에 TCP와 같은 신뢰할 수 있는 종단 간 프로토콜을 사용하는 것이 좋습니다. .

---
# **APPENDIX E**

응답 코드 이론

- 답변의 세 자리 숫자는 각각 특별한 의미를 갖습니다. 첫 번째 숫자는 응답이 좋은지, 나쁜지, 불완전한지를 나타냅니다. 정교하지 않은 발신자-SMTP는 이 첫 번째 숫자를 간단히 검사하여 다음 작업\(계획대로 진행, 다시 실행, 축소 등\)을 결정할 수 있습니다. 어떤 종류의 오류가 발생했는지\(예: 메일 시스템 오류, 명령 구문 오류\) 대략 알고 싶어하는 sender-SMTP는 두 번째 숫자를 검사하고 가장 미세한 정보 그라데이션을 위해 세 번째 숫자를 예약할 수 있습니다.

- 응답 코드의 첫 번째 숫자에는 5개의 값이 있습니다.

```text
            1yz   Positive Preliminary reply
```

- 명령이 수락되었지만 요청한 작업은 보류 중이며 이 응답의 정보가 확인될 때까지 보류됩니다. sender-SMTP는 작업을 계속할지 아니면 중단할지 지정하는 다른 명령을 보내야 합니다.

- \[참고: SMTP에는 이러한 유형의 응답을 허용하는 명령이 없으므로 계속 또는 중단 명령도 없습니다.\]

```text
            2yz   Positive Completion reply
```

- 요청한 작업이 성공적으로 완료되었습니다. 새로운 요청이 시작될 수 있습니다.

```text
            3yz   Positive Intermediate reply
```

- 명령이 수락되었지만 요청한 작업은 추가 정보 수신을 기다리는 동안 보류 중입니다. sender-SMTP는 이 정보를 지정하는 다른 명령을 보내야 합니다. 이 응답은 명령 시퀀스 그룹에서 사용됩니다.

```text
            4yz   Transient Negative Completion reply
```

- 명령이 승인되지 않았으며 요청한 작업이 발생하지 않았습니다. 그러나 오류 상태는 일시적이므로 작업이 다시 요청될 수 있습니다. 발신인이 해야 할 일

- 명령 시퀀스의 시작 부분으로 돌아갑니다\(있는 경우\). 서로 다른 두 사이트\(수신자 및 발신자 SMTP\)가 해석에 동의해야 하는 경우 "일시적"이라는 의미를 할당하기가 어렵습니다. 이 카테고리의 각 응답은 서로 다른 시간 값을 가질 수 있지만 보낸 사람-SMTP는 다시 시도하는 것이 좋습니다. 응답이 4yz 또는 5yz 범주\(아래 참조\)에 적합한지 결정하는 경험적 규칙은 응답이 명령 형식이나 발신자 또는 수신자의 속성을 변경하지 않고 반복될 수 있는 경우 응답이 4yz라는 것입니다. \(예를 들어, 명령이 동일하게 반복되고 수신자는 새로운 구현을 제시하지 않습니다.\)

```text
            5yz   Permanent Negative Completion reply
```

- 명령이 승인되지 않았으며 요청한 작업이 발생하지 않았습니다. sender-SMTP는 동일한 요청을 동일한 순서로 반복하지 않는 것이 좋습니다. 일부 "영구적인" 오류 조건도 수정될 수 있으므로 인간 사용자는 미래의 특정 시점\(예: 철자가 변경된 후 또는 사용자가 직접 작업을 수행하여 명령 시퀀스를 다시 시작하도록 sender-SMTP에 지시할 수 있음\)을 원할 수 있습니다. 계정 상태가 변경되었습니다\).

- 두 번째 숫자는 특정 카테고리의 응답을 인코딩합니다.

- x0z 구문 -- 이 응답은 구문 오류, 기능 범주에 맞지 않는 구문적으로 올바른 명령, 구현되지 않거나 불필요한 명령을 나타냅니다.

- x1z 정보 -- 상태나 도움말과 같은 정보 요청에 대한 응답입니다.

- x2z 연결 - 전송 채널을 참조하는 응답입니다.

- x3z 아직 지정되지 않았습니다.

- x4z 아직 지정되지 않았습니다.

- x5z 메일 시스템 -- 이 응답은 요청된 전송 또는 기타 메일 시스템 작업에 대한 수신자 메일 시스템의 상태를 나타냅니다.

- 세 번째 숫자는 두 번째 숫자로 지정된 각 범주에서 더 미세한 의미 등급을 제공합니다. 답글 목록

- 이를 예시합니다. 각 응답 텍스트는 필수가 아닌 권장 사항이며 연결된 명령에 따라 변경될 수도 있습니다. 반면에 응답 코드는 이 섹션의 사양을 엄격하게 따라야 합니다. 수신기 구현은 여기에 설명된 것과 약간 다른 상황에 대한 새로운 코드를 생성해서는 안 되며, 오히려 이미 정의된 코드를 적용해야 합니다.

- 예를 들어 성공적으로 실행되어 sender-SMTP에 새로운 정보를 제공하지 않는 NOOP와 같은 명령은 250 응답을 반환합니다. 명령이 구현되지 않은 비사이트 특정 작업을 요청하면 응답은 502입니다. 이에 대한 개선은 구현되었지만 구현되지 않은 매개변수를 요청하는 명령에 대한 504 응답입니다.

- 답글 텍스트는 한 줄보다 길 수 있습니다. 이러한 경우 송신자-SMTP가 언제 응답 읽기를 중지할 수 있는지 알 수 있도록 전체 텍스트를 표시해야 합니다. 여러 줄의 응답을 나타내려면 특별한 형식이 필요합니다.

```text
         The format for multiline replies requires that every line,
         except the last, begin with the reply code, followed
         immediately by a hyphen, "-" (also known as minus), followed by
         text.  The last line will begin with the reply code, followed
         immediately by <SP>, optionally some text, and <CRLF>.
```

예를 들어:

- 123-첫 번째 줄 123-두 번째 줄 123-234 숫자 123으로 시작하는 텍스트 마지막 줄

- 많은 경우에 sender-SMTP는 줄 시작 부분에 <SP\>가 뒤에 오는 응답 코드를 검색하고 이전 줄을 모두 무시하면 됩니다. 어떤 경우에는 답장 "텍스트"에 보낸 사람에 대한 중요한 데이터가 있습니다. 발신자는 현재 상황에서 이러한 사례를 알게 됩니다.

---
# **APPENDIX F**

```text
   Scenarios
```

- 이 섹션에서는 여러 유형의 SMTP 세션에 대한 전체 시나리오를 제공합니다.

일반적인 SMTP 트랜잭션 시나리오

- 이 SMTP 예는 호스트 USC-ISIF의 Smith가 호스트 BBN-UNIX의 Jones, Green 및 Brown에게 보낸 메일을 보여줍니다. 여기서는 호스트 USC-ISIF가 호스트 BBN-UNIX에 직접 접속한다고 가정합니다. Jones와 Brown의 우편물이 허용됩니다. Green에는 호스트 BBN-UNIX에 사서함이 없습니다.

```text
      -------------------------------------------------------------

         R: 220 BBN-UNIX.ARPA Simple Mail Transfer Service Ready
         S: HELO USC-ISIF.ARPA
         R: 250 BBN-UNIX.ARPA

         S: MAIL FROM:<Smith@USC-ISIF.ARPA>
         R: 250 OK

         S: RCPT TO:<Jones@BBN-UNIX.ARPA>
         R: 250 OK

         S: RCPT TO:<Green@BBN-UNIX.ARPA>
         R: 550 No such user here

         S: RCPT TO:<Brown@BBN-UNIX.ARPA>
         R: 250 OK
```

에스: 데이터

- R: 354 메일 입력 시작; <CRLF\>로 끝납니다.<CRLF\> S: 어쩌고저쩌고... S: ...etc. 등등 등등. S: . 답: 250 OK

```text
         S: QUIT
         R: 221 BBN-UNIX.ARPA Service closing transmission channel

                               Scenario 1

      -------------------------------------------------------------

   Aborted SMTP Transaction Scenario

      -------------------------------------------------------------

         R: 220 MIT-Multics.ARPA Simple Mail Transfer Service Ready
         S: HELO ISI-VAXA.ARPA
         R: 250 MIT-Multics.ARPA

         S: MAIL FROM:<Smith@ISI-VAXA.ARPA>
         R: 250 OK

         S: RCPT TO:<Jones@MIT-Multics.ARPA>
         R: 250 OK

         S: RCPT TO:<Green@MIT-Multics.ARPA>
         R: 550 No such user here

         S: RSET
         R: 250 OK

         S: QUIT
         R: 221 MIT-Multics.ARPA Service closing transmission channel

                               Scenario 2

      -------------------------------------------------------------

   Relayed Mail Scenario

      -------------------------------------------------------------
```

- 1단계 - 소스 호스트에서 릴레이 호스트로

```text
            R: 220 USC-ISIE.ARPA Simple Mail Transfer Service Ready
            S: HELO MIT-AI.ARPA
            R: 250 USC-ISIE.ARPA

            S: MAIL FROM:<JQP@MIT-AI.ARPA>
            R: 250 OK

            S: RCPT TO:<@USC-ISIE.ARPA:Jones@BBN-VAX.ARPA>
            R: 250 OK
```

에스: 데이터

- R: 354 메일 입력 시작; <CRLF\>로 끝납니다.<CRLF\> S: 날짜: 81년 11월 2일 22:33:44 S: 보낸 사람: John Q. Public <JQP@MIT-AI.ARPA\> S: 제목: 이사회의 다음 회의 S: 받는 사람: Jones@BBN-Vax.ARPA S: S: Bill: S: 다음 이사회 회의는 화요일 S:입니다. 남: 존. 스: . 답: 250 OK

```text
            S: QUIT
            R: 221 USC-ISIE.ARPA Service closing transmission channel
```

- 2단계 - 호스트를 대상 호스트로 릴레이

```text
            R: 220 BBN-VAX.ARPA Simple Mail Transfer Service Ready
            S: HELO USC-ISIE.ARPA
            R: 250 BBN-VAX.ARPA

            S: MAIL FROM:<@USC-ISIE.ARPA:JQP@MIT-AI.ARPA>
            R: 250 OK

            S: RCPT TO:<Jones@BBN-VAX.ARPA>
            R: 250 OK
```

에스: 데이터

- R: 354 메일 입력 시작; <CRLF\>.<CRLF\>로 끝납니다. S: 수신: MIT-AI.ARPA에서 USC-ISIE.ARPA로 ; 81년 11월 2일 22:40:10 UT S: 날짜: 81년 11월 2일 22:33:44 S: 보낸 사람: John Q. 공개 <JQP@MIT-AI.ARPA\> S: 제목: 다음 이사회 회의 S: 받는 사람: Jones@BBN-Vax.ARPA S: S: Bill: S: 다음 이사회 회의는 화요일 S:입니다. 남: 존. 스: . 답: 250 OK

```text
            S: QUIT
            R: 221 USC-ISIE.ARPA Service closing transmission channel

                               Scenario 3

      -------------------------------------------------------------
```

시나리오 검증 및 전송

```text
      -------------------------------------------------------------

         R: 220 SU-SCORE.ARPA Simple Mail Transfer Service Ready
         S: HELO MIT-MC.ARPA
         R: 250 SU-SCORE.ARPA

         S: VRFY Crispin
         R: 250 Mark Crispin <Admin.MRC@SU-SCORE.ARPA>

         S: SEND FROM:<EAK@MIT-MC.ARPA>
         R: 250 OK

         S: RCPT TO:<Admin.MRC@SU-SCORE.ARPA>
         R: 250 OK
```

에스: 데이터

- R: 354 메일 입력 시작; <CRLF\>로 끝납니다.<CRLF\> S: 어쩌고저쩌고... S: ...etc. 등등 등등. S: . 답: 250 OK

```text
         S: QUIT
         R: 221 SU-SCORE.ARPA Service closing transmission channel

                               Scenario 4

      -------------------------------------------------------------
```

전송 및 메일링 시나리오

- 먼저 사용자 이름을 확인한 후 사용자의 단말기로 전송을 시도합니다. 실패하면 메시지가 사용자의 사서함으로 전송됩니다.

```text
      -------------------------------------------------------------

         R: 220 SU-SCORE.ARPA Simple Mail Transfer Service Ready
         S: HELO MIT-MC.ARPA
         R: 250 SU-SCORE.ARPA

         S: VRFY Crispin
         R: 250 Mark Crispin <Admin.MRC@SU-SCORE.ARPA>

         S: SEND FROM:<EAK@MIT-MC.ARPA>
         R: 250 OK

         S: RCPT TO:<Admin.MRC@SU-SCORE.ARPA>
         R: 450 User not active now

         S: RSET
         R: 250 OK

         S: MAIL FROM:<EAK@MIT-MC.ARPA>
         R: 250 OK

         S: RCPT TO:<Admin.MRC@SU-SCORE.ARPA>
         R: 250 OK
```

에스: 데이터

- R: 354 메일 입력 시작; <CRLF\>로 끝납니다.<CRLF\> S: 어쩌고저쩌고... S: ...etc. 등등 등등. S: . 답: 250 OK

```text
         S: QUIT
         R: 221 SU-SCORE.ARPA Service closing transmission channel

                               Scenario 5

      -------------------------------------------------------------
```

- 이전 시나리오를 보다 효율적으로 수행합니다.

```text
      -------------------------------------------------------------

         R: 220 SU-SCORE.ARPA Simple Mail Transfer Service Ready
         S: HELO MIT-MC.ARPA
         R: 250 SU-SCORE.ARPA

         S: VRFY Crispin
         R: 250 Mark Crispin <Admin.MRC@SU-SCORE.ARPA>

         S: SOML FROM:<EAK@MIT-MC.ARPA>
         R: 250 OK
```

S: RCPT 수신자:<Admin.MRC@SU-SCORE.ARPA\>

- R: 250 사용자는 현재 활성 상태가 아니므로 메일을 사용합니다.

에스: 데이터

- R: 354 메일 입력 시작; <CRLF\>로 끝납니다.<CRLF\> S: 어쩌고저쩌고... S: ...etc. 등등 등등. S: . 답: 250 OK

```text
         S: QUIT
         R: 221 SU-SCORE.ARPA Service closing transmission channel

                               Scenario 6

      -------------------------------------------------------------

   Mailing List Scenario
```

- 먼저 두 개의 메일링 리스트가 각각 다른 호스트와 별도의 세션으로 확장됩니다. 그런 다음 메시지는 중계 호스트를 통해 두 목록 중 하나에 나타난 모든 사람\(중복 항목 없음\)에게 전송됩니다.

```text
      -------------------------------------------------------------
```

- 1단계 - 첫 번째 목록 확장

```text
            R: 220 MIT-AI.ARPA Simple Mail Transfer Service Ready
            S: HELO SU-SCORE.ARPA
            R: 250 MIT-AI.ARPA

            S: EXPN Example-People
            R: 250-<ABC@MIT-MC.ARPA>
            R: 250-Fred Fonebone <Fonebone@USC-ISIQ.ARPA>
            R: 250-Xenon Y. Zither <XYZ@MIT-AI.ARPA>
            R: 250-Quincy Smith <@USC-ISIF.ARPA:Q-Smith@ISI-VAXA.ARPA>
            R: 250-<joe@foo-unix.ARPA>
            R: 250 <xyz@bar-unix.ARPA>

            S: QUIT
            R: 221 MIT-AI.ARPA Service closing transmission channel
```

- 2단계 - 두 번째 목록 확장

```text
            R: 220 MIT-MC.ARPA Simple Mail Transfer Service Ready
            S: HELO SU-SCORE.ARPA
            R: 250 MIT-MC.ARPA

            S: EXPN Interested-Parties
            R: 250-Al Calico <ABC@MIT-MC.ARPA>
            R: 250-<XYZ@MIT-AI.ARPA>
            R: 250-Quincy Smith <@USC-ISIF.ARPA:Q-Smith@ISI-VAXA.ARPA>
            R: 250-<fred@BBN-UNIX.ARPA>
            R: 250 <xyz@bar-unix.ARPA>

            S: QUIT
            R: 221 MIT-MC.ARPA Service closing transmission channel
```

- 3단계 - 릴레이 호스트를 통해 모든 사람에게 메일 보내기

```text
            R: 220 USC-ISIE.ARPA Simple Mail Transfer Service Ready
            S: HELO SU-SCORE.ARPA
            R: 250 USC-ISIE.ARPA

            S: MAIL FROM:<Account.Person@SU-SCORE.ARPA>
            R: 250 OK
            S: RCPT TO:<@USC-ISIE.ARPA:ABC@MIT-MC.ARPA>
            R: 250 OK
            S: RCPT TO:<@USC-ISIE.ARPA:Fonebone@USC-ISIQA.ARPA>
            R: 250 OK
            S: RCPT TO:<@USC-ISIE.ARPA:XYZ@MIT-AI.ARPA>
            R: 250 OK
            S: RCPT
                TO:<@USC-ISIE.ARPA,@USC-ISIF.ARPA:Q-Smith@ISI-VAXA.ARPA>
            R: 250 OK
            S: RCPT TO:<@USC-ISIE.ARPA:joe@FOO-UNIX.ARPA>
            R: 250 OK
            S: RCPT TO:<@USC-ISIE.ARPA:xyz@BAR-UNIX.ARPA>
            R: 250 OK
            S: RCPT TO:<@USC-ISIE.ARPA:fred@BBN-UNIX.ARPA>
            R: 250 OK
```

에스: 데이터

- R: 354 메일 입력 시작; <CRLF\>로 끝납니다.<CRLF\> S: 어쩌고저쩌고... S: ...etc. 등등 등등. S: . 답: 250 OK

```text
            S: QUIT
            R: 221 USC-ISIE.ARPA Service closing transmission channel

                               Scenario 7

      -------------------------------------------------------------

   Forwarding Scenarios

      -------------------------------------------------------------

         R: 220 USC-ISIF.ARPA Simple Mail Transfer Service Ready
         S: HELO LBL-UNIX.ARPA
         R: 250 USC-ISIF.ARPA

         S: MAIL FROM:<mo@LBL-UNIX.ARPA>
         R: 250 OK
```

S: RCPT 수신:<fred@USC-ISIF.ARPA\>

- R: 251 사용자가 로컬이 아닙니다. <Jones@USC-ISI.ARPA\>로 전달됩니다.

에스: 데이터

- R: 354 메일 입력 시작; <CRLF\>로 끝납니다.<CRLF\> S: 어쩌고저쩌고... S: ...etc. 등등 등등. S: . 답: 250 OK

```text
         S: QUIT
         R: 221 USC-ISIF.ARPA Service closing transmission channel

                               Scenario 8

      -------------------------------------------------------------

      -------------------------------------------------------------
```

- 1단계 - 첫 번째 호스트에서 메일박스 시도

```text
            R: 220 USC-ISIF.ARPA Simple Mail Transfer Service Ready
            S: HELO LBL-UNIX.ARPA
            R: 250 USC-ISIF.ARPA

            S: MAIL FROM:<mo@LBL-UNIX.ARPA>
            R: 250 OK
```

S: RCPT 수신:<fred@USC-ISIF.ARPA\>

- R: 251 사용자가 로컬이 아닙니다. <Jones@USC-ISI.ARPA\>로 전달됩니다.

```text
            S: RSET
            R: 250 OK

            S: QUIT
            R: 221 USC-ISIF.ARPA Service closing transmission channel
```

- 2단계 -- 두 번째 호스트에서 메일 배달

```text
            R: 220 USC-ISI.ARPA Simple Mail Transfer Service Ready
            S: HELO LBL-UNIX.ARPA
            R: 250 USC-ISI.ARPA

            S: MAIL FROM:<mo@LBL-UNIX.ARPA>
            R: 250 OK

            S: RCPT TO:<Jones@USC-ISI.ARPA>
            R: OK
```

에스: 데이터

- R: 354 메일 입력 시작; <CRLF\>로 끝납니다.<CRLF\> S: 어쩌고저쩌고... S: ...etc. 등등 등등. S: . 답: 250 OK

```text
            S: QUIT
            R: 221 USC-ISI.ARPA Service closing transmission channel

                               Scenario 9

      -------------------------------------------------------------

   Too Many Recipients Scenario

      -------------------------------------------------------------

         R: 220 BERKELEY.ARPA Simple Mail Transfer Service Ready
         S: HELO USC-ISIF.ARPA
         R: 250 BERKELEY.ARPA

         S: MAIL FROM:<Postel@USC-ISIF.ARPA>
         R: 250 OK

         S: RCPT TO:<fabry@BERKELEY.ARPA>
         R: 250 OK
```

S: RCPT 수신자:<eric@BERKELEY.ARPA\>

- R: 552 수신자 저장 공간이 가득 찼습니다. 다른 트랜잭션에서 다시 시도하세요.

에스: 데이터

- R: 354 메일 입력 시작; <CRLF\>로 끝납니다.<CRLF\> S: 어쩌고저쩌고... S: ...etc. 등등 등등. S: . 답: 250 OK

```text
         S: MAIL FROM:<Postel@USC-ISIF.ARPA>
         R: 250 OK

         S: RCPT TO:<eric@BERKELEY.ARPA>
         R: 250 OK
```

에스: 데이터

- R: 354 메일 입력 시작; <CRLF\>로 끝납니다.<CRLF\> S: 어쩌고저쩌고... S: ...etc. 등등 등등. S: . 답: 250 OK

```text
         S: QUIT
         R: 221 BERKELEY.ARPA Service closing transmission channel

                              Scenario 10

      -------------------------------------------------------------
```

- 실제 구현에서는 섹션 4.5.3에 지정된 대로 많은 수신자를 처리해야 합니다.

---
# **GLOSSARY**

```text
   ASCII
```

- 정보 교환을 위한 미국 표준 코드 \[1\].

```text
   command
```

- sender-SMTP가 receive-SMTP로 보낸 메일 서비스 작업에 대한 요청입니다.

```text
   domain
```

- 메일 시스템에 있는 호스트 컴퓨터의 계층적으로 구조화된 전역 문자열 주소입니다.

메일 데이터 표시의 끝

- 메일 데이터의 끝을 나타내는 특수 문자 시퀀스입니다. 특히 5자리 문자는 캐리지 리턴, 줄 바꿈, 마침표, 캐리지 리턴, 줄 바꿈 순으로 사용됩니다.

```text
   host
```

- 사서함이나 SMTP 프로세스가 상주하는 인터네트워크 환경의 컴퓨터입니다.

```text
   line

      A a sequence of ASCII characters ending with a <CRLF>.

   mail data
```

- ARPA 인터넷 텍스트 메시지 형식 표준\(RFC 822 \[2\]\)에 설정된 표준을 준수하는 임의 길이의 ASCII 문자 시퀀스입니다.

```text
   mailbox
```

- 메일을 보낼 사용자를 식별하는 문자열\(주소\)입니다. 메일박스는 일반적으로 호스트와 사용자 사양으로 구성됩니다. 표준 사서함 명명 규칙은 "user@domain"으로 정의됩니다. 또한 메일이 저장되는 "컨테이너"입니다.

```text
   receiver-SMTP process
```

- sender-SMTP 프로세스와 협력하여 메일을 전송하는 프로세스. 전송 서비스를 통해 연결이 설정될 때까지 기다립니다. sender-SMTP로부터 SMTP 명령을 수신하고, 응답을 보내고, 지정된 작업을 수행합니다.

```text
   reply
```

- 응답은 명령에 대한 응답으로 전송 채널을 통해 수신자에서 발신자에게 전송되는 승인\(긍정적 또는 부정\)입니다. 일반적인 응답 형식은 완료 코드\(오류 코드 포함\)와 그 뒤에 오는 텍스트 문자열입니다. 코드는 프로그램에서 사용하기 위한 것이며 텍스트는 일반적으로 인간 사용자를 위한 것입니다.

```text
   sender-SMTP process
```

- Receiver-SMTP 프로세스와 협력하여 메일을 전송하는 프로세스. 사용자 인터페이스 명령/응답 대화 상자에는 현지 언어가 사용될 수 있습니다. sender-SMTP는 전송 서비스 연결을 시작합니다. 이는 SMTP 명령을 시작하고, 응답을 받고, 메일 전송을 관리합니다.

```text
   session
```

- 전송 채널이 열려 있는 동안 발생하는 교환 집합입니다.

```text
   transaction
```

- 한 명 이상의 수신자에게 하나의 메시지를 전송하는 데 필요한 교환 집합입니다.

```text
   transmission channel
```

- 명령, 응답 및 메일 텍스트 교환을 위한 송신자-SMTP와 수신자-SMTP 간의 전이중 통신 경로입니다.

```text
   transport service
```

- 신뢰할 수 있는 스트림 지향 데이터 통신 서비스입니다. 예를 들어 NCP, TCP, NITS입니다.

```text
   user
```

- 메일 전송 서비스를 받고자 하는 사람\(또는 사람을 대신하는 프로세스\). 또한 컴퓨터 메일의 수신자입니다.

```text
   word
```

- 일련의 인쇄 문자입니다.

```text
   <CRLF>
```

- 문자 캐리지 리턴 및 줄 바꿈\(순서대로\).

```text
   <SP>
```

- 공백 문자.

---
# **REFERENCES**

```text
   [1]  ASCII
```

- ASCII, "정보 교환을 위한 미국 코드", 미국 표준 협회, X3.4, 1968. 또한 다음 항목에 포함되어 있습니다: Feinler, E. 및 J. Postel, eds., "ARPANET 프로토콜 핸드북", NIC 7104 SRI International의 국방통신국\(Defense Communications Agency\), 캘리포니아주 멘로파크, 1978년 1월 개정.

```text
   [2]  RFC 822
```

- Crocker, D., "ARPA 인터넷 문자 메시지 형식의 표준", RFC 822, University of Delaware, 1982년 8월.

```text
   [3]  TCP
```

- Postel, J., ed., "전송 제어 프로토콜 - DARPA 인터넷 프로그램 프로토콜 사양", RFC 793, USC/정보 과학 연구소, NTIS AD 번호 A111091, 1981년 9월. 추가 자료: Feinler, E. 및 J. Postel, eds., "인터넷 프로토콜 전환 워크북", SRI International, Menlo Park, California, 1982년 3월.

```text
   [4]  NCP
```

- McKenzie,A., "ARPA 네트워크용 호스트/호스트 프로토콜", NIC 8246, 1972년 1월. 또한 참조: Feinler, E. 및 J. Postel, eds., "ARPANET 프로토콜 핸드북", NIC 7104, 국방용 SRI International의 커뮤니케이션 에이전시\(캘리포니아주 멘로파크\), 1978년 1월 개정.

```text
   [5]  Initial Connection Protocol
```

- Postel, J., "공식 초기 연결 프로토콜", NIC 7101, 1971년 6월 11일. 또한 참조: Feinler, E. 및 J. Postel, eds., "ARPANET 프로토콜 핸드북", NIC 7104, 국방 통신국용 SRI International, 캘리포니아주 멘로파크, 1978년 1월 개정.

```text
   [6]  NITS
```

- PSS/SG3, "네트워크 독립 전송 서비스", 연구 그룹 3, 우체국 PSS 사용자 그룹, 1980년 2월. 영국 테딩턴 국립물리연구소 DCPU에서 이용 가능.

```text
   [7]  X.25
```

- CCITT, "권고사항 X.25 - 공용 데이터 네트워크의 패킷 모드에서 작동하는 터미널에 대한 데이터 터미널 장비\(DTE\)와 데이터 회선 종단 장비\(DCE\) 간의 인터페이스", CCITT Orange Book, Vol. VIII.2, 국제 전화 및 전신 자문위원회, 제네바, 1976.

```text
         
```
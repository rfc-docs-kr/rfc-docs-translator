

```text
Internet Engineering Task Force (IETF)                     P. Quinn, Ed.
Request for Comments: 8300                                         Cisco
Category: Standards Track                                  U. Elzur, Ed.
ISSN: 2070-1721                                                    Intel
                                                       C. Pignataro, Ed.
                                                                   Cisco
                                                            January 2018

                      Network Service Header (NSH)
```

---
# **Abstract**

이 문서에서는 SFP\(서비스 기능 경로\)를 실현하기 위해 패킷이나 프레임에 적용되는 NSH\(네트워크 서비스 헤더\)에 대해 설명합니다. NSH는 또한 인스턴스화된 서비스 경로를 따라 메타데이터를 교환하기 위한 메커니즘을 제공합니다. NSH는 SFC 아키텍처\(RFC 7665에 정의됨\)를 지원하는 데 필요한 SFC\(Service Function Chaining\) 캡슐화입니다.

---
# **Status of This Memo**

이것은 인터넷 표준 추적 문서입니다.

이 문서는 IETF\(Internet Engineering Task Force\)의 제품입니다. 이는 IETF 커뮤니티의 합의를 나타냅니다. 공개 검토를 받았으며 IESG\(Internet Engineering Steering Group\)의 출판 승인을 받았습니다. 인터넷 표준에 대한 자세한 내용은 RFC 7841의 섹션 2에서 확인할 수 있습니다.

이 문서의 현재 상태, 정오표, 피드백 제공 방법에 대한 정보는 https://www.rfc-editor.org/info/rfc8300에서 얻을 수 있습니다.

---
# **Copyright Notice**

Copyright \(c\) 2018 IETF Trust 및 문서 작성자로 확인된 사람. 판권 소유.

이 문서는 이 문서의 발행일에 유효한 BCP 78 및 IETF 문서에 관한 IETF 트러스트의 법적 조항\(https://trustee.ietf.org/license-info\)의 적용을 받습니다. 이 문서와 관련된 귀하의 권리 및 제한 사항을 설명하므로 이 문서를 주의 깊게 검토하십시오. 이 문서에서 추출한 코드 구성 요소는 Trust Legal Provisions의 섹션 4.e에 설명된 대로 Simplified BSD License 텍스트를 포함해야 하며 Simplified BSD License에 설명된 대로 보증 없이 제공됩니다.

---
# **Table of Contents**

```text
   1. Introduction ....................................................3
      1.1. Applicability ..............................................4
      1.2. Requirements Language ......................................4
      1.3. Definition of Terms ........................................4
      1.4. Problem Space ..............................................6
      1.5. NSH-Based Service Chaining .................................6
   2. Network Service Header ..........................................7
      2.1. Network Service Header Format ..............................7
      2.2. NSH Base Header ............................................8
      2.3. Service Path Header .......................................11
      2.4. NSH MD Type 1 .............................................12
      2.5. NSH MD Type 2 .............................................13
           2.5.1. Optional Variable-Length Metadata ..................13
   3. NSH Actions ....................................................15
   4. NSH Transport Encapsulation ....................................16
   5. Fragmentation Considerations ...................................17
   6. Service Path Forwarding with NSH ...............................18
      6.1. SFFs and Overlay Selection ................................18
      6.2. Mapping the NSH to Network Topology .......................21
      6.3. Service Plane Visibility ..................................21
      6.4. Service Graphs ............................................22
   7. Policy Enforcement with NSH ....................................22
      7.1. NSH Metadata and Policy Enforcement .......................22
      7.2. Updating/Augmenting Metadata ..............................24
      7.3. Service Path Identifier and Metadata ......................25
   8. Security Considerations ........................................26
      8.1. NSH Security Considerations from Operators' Environments ..27
      8.2. NSH Security Considerations from the SFC Architecture .....28
           8.2.1. Integrity ..........................................29
           8.2.2. Confidentiality ....................................31
   9. IANA Considerations ............................................32
      9.1. NSH Parameters ............................................32
           9.1.1. NSH Base Header Bits ...............................32
           9.1.2. NSH Version ........................................32
           9.1.3. NSH MD Types .......................................33
           9.1.4. NSH MD Class .......................................33
           9.1.5. NSH IETF-Assigned Optional Variable-Length
                  Metadata Types .....................................34
           9.1.6. NSH Next Protocol ..................................35
   10. NSH-Related Codepoints ........................................35
      10.1. NSH Ethertype ............................................35
   11. References ....................................................36
   Acknowledgments ...................................................38
   Contributors ......................................................39
   Authors' Addresses ................................................40
```

---
## **1.  Introduction**

서비스 기능은 많은 네트워크에서 광범위하게 배포되고 필수적입니다. 이러한 서비스 기능은 보안, WAN 가속, 서버 로드 밸런싱과 같은 다양한 기능을 제공합니다. 서비스 기능은 WAN, 데이터 센터 등과 같은 네트워크 인프라의 다양한 지점에서 인스턴스화될 수 있습니다.

SFC 아키텍처 \[RFC7665\] 및 이 문서에 지정된 프로토콜을 개발하기 전에 현재 서비스 기능 배포 모델은 상대적으로 정적이고 삽입 및 정책 선택을 위해 토폴로지에 바인딩되었습니다. 게다가 가상화로 구현된 탄력적인 서비스 환경에는 잘 적응하지 못합니다.

새로운 데이터 센터 네트워크 및 클라우드 아키텍처에는 보다 유연한 서비스 기능 배포 모델이 필요합니다. 또한, 가상 플랫폼으로의 전환에는 동적이고 탄력적인 서비스 제공을 지원하는 민첩한 서비스 삽입 모델이 필요합니다. 구체적으로 다음과 같은 기능이 필요합니다.

1. 네트워크에서 서비스 기능 및 애플리케이션 워크로드의 이동.

2. 서비스 정책을 세분화하여 쉽게 바인딩하는 기능

- 구독자별 상태와 같은 정보.

3. 필요한 서비스로 트래픽을 조종하는 능력

- 기능.

NSH\(네트워크 서비스 헤더\) 사양인 이 문서는 SFC에 대한 캡슐화인 새로운 데이터 플레인 프로토콜을 정의합니다. NSH는 그림 1과 같이 원본 패킷 또는 프레임을 캡슐화하고 외부 전송 캡슐화\(NSH를 NSH 인식 네트워크 요소에 전달하는 데 사용됨\)에 의해 캡슐화되도록 설계되었습니다.

```text
                     +------------------------------+
                     |    Transport Encapsulation   |
                     +------------------------------+
                     | Network Service Header (NSH) |
                     +------------------------------+
                     |    Original Packet / Frame   |
                     +------------------------------+

              Figure 1: Network Service Header Encapsulation
```

NSH는 다음 요소로 구성됩니다.

```text
   1.  Service Function Path identification.
```

2. 서비스 기능 경로 내 위치 표시.

3. 선택 사항, 패킷별 메타데이터\(고정 길이 또는 가변\).

\[RFC7665\]는 다양한 요소의 역할과 SFC 캡슐화 범위를 명확하게 정의하는 서비스 체인 아키텍처의 개요를 제공합니다. \[RFC7665\]의 그림 3은 분류 후 SFC 아키텍처 구성 요소를 보여줍니다. NSH는 \[RFC7665\]에서 참조된 SFC 캡슐화입니다.

---
### **1.1.  Applicability**

NSH는 하드웨어 플랫폼을 포함하여 물리적 장치와 가상 장치 모두에서 쉽게 구현할 수 있도록 설계되었습니다.

NSH의 의도된 범위는 단일 공급자의 운영 도메인 내에서 사용하는 것입니다. 이 배포 범위는 \[RFC7665\]에 설명된 대로 의도적으로 제한되며 단일 네트워크 관리 도메인으로 제한됩니다. 이러한 맥락에서 "도메인"은 단일 관리 내의 네트워크 엔터티 집합입니다. 예를 들어, 네트워크 관리 도메인에는 단일 데이터 센터가 포함될 수도 있고 가상 연결 및 터널을 사용하는 오버레이 도메인이 포함될 수도 있습니다. 결과적으로 네트워크 관리 도메인에는 잘 정의된 경계가 있습니다.

NSH 인식 제어 평면은 이 문서의 범위를 벗어납니다.

---
### **1.2.  Requirements Language**

키워드 "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY" 및 "OPTIONAL" "는 BCP 14 \[RFC2119\] \[RFC8174\]에 설명된 대로 여기에 표시된 것처럼 모두 대문자로 표시되는 경우에만 해석됩니다.\(MUST NOT\)

---
### **1.3.  Definition of Terms**

바이트: 이 문서에서 "바이트"에 대한 모든 참조는 8비트 바이트 또는 옥텟을 나타냅니다.

분류: \[RFC7665\]에 정의되어 있습니다.

분류자: \[RFC7665\]에 정의되어 있습니다.

메타데이터\(MD\): \[RFC7665\]에 정의되어 있습니다. 분류자와 SF 사이, SF 간에 공유되는 메타데이터 또는 컨텍스트 정보는 NSH의 컨텍스트 헤더를 통해 전달됩니다. 이를 통해 패킷 자체에 분류 결과를 요약하여 후속 재분류를 피할 수 있습니다. 메타데이터의 예로는 정책 시행에 사용되는 분류 정보와 서비스 전달 후 전달을 위한 네트워크 컨텍스트가 있습니다.

네트워크 로케이터: 네트워크 트래픽을 보내고 받는 데 사용되는 데이터 평면 주소\(일반적으로 IPv4 또는 IPv6\)입니다.

네트워크 노드/요소: 외부 헤더\(예: 전송 캡슐화\) 정보를 기반으로 패킷이나 프레임을 전달하는 장치입니다.

네트워크 오버레이: 기존 네트워크\(언더레이\) 위에 구축된 논리적 네트워크입니다. 패킷은 캡슐화되거나 터널링되어 오버레이 네트워크 토폴로지를 생성합니다.

NSH 인식: NSH 인식은 SFC 캡슐화 인식을 의미하며, 여기서 NSH는 SFC 캡슐화를 제공합니다. 이 사양에서는 NSH 인식을 보다 일반적인 용어인 "SFC 인식"\[RFC7665\]보다 구체적인 용어로 사용합니다.

서비스 분류자: 분류를 제공하는 논리적 개체

-  기능. 논리적이기 때문에 분류자는 SF 또는 SFF와 같은 SFC 요소와 공동 상주할 수 있습니다. 서비스 분류자는 분류를 수행하고 NSH를 부과합니다. 초기 분류자는 초기 NSH를 적용하고 NSH 패킷을 경로의 첫 번째 SFF로 보냅니다. 비초기\(즉, 후속\) 분류는 필요에 따라 발생할 수 있으며 새로운 서비스 경로를 변경하거나 생성할 수 있습니다.

서비스 기능\(SF\): \[RFC7665\]에 정의되어 있습니다.

서비스 기능 체인\(SFC\): \[RFC7665\]에 정의되어 있습니다.

서비스 기능 전달자\(SFF\): \[RFC7665\]에 정의되어 있습니다.

서비스 기능 경로\(SFP\): \[RFC7665\]에 정의되어 있습니다.

서비스 평면: SFF 및 관련 SF의 컬렉션은 모든 SF 및 SFC 프록시가 상주하는 서비스 평면 오버레이를 생성합니다\[RFC7665\].

SFC 프록시: \[RFC7665\]에 정의되어 있습니다.

---
### **1.4.  Problem Space**

NSH는 서비스 기능 배포와 관련된 몇 가지 제한 사항을 해결합니다. \[RFC7498\]은 이러한 문제에 대한 포괄적인 검토를 제공합니다.

---
### **1.5.  NSH-Based Service Chaining**

NSH는 전용 서비스 플레인을 생성합니다. 보다 구체적으로 NSH는 다음을 가능하게 합니다.

1. 토폴로지 독립성: 서비스 전달은 서비스 평면 내에서 발생하므로 기본 네트워크 토폴로지를 수정할 필요가 없습니다. NSH는 네트워크 전달을 위한 네트워크 오버레이를 선택하는 데 사용되는 식별자를 제공합니다.

2. 서비스 체인: NSH는 \[RFC7665\]에 따라 서비스 체인을 활성화합니다. NSH에는 서비스 경로를 구현하는 데 필요한 경로 식별 정보가 포함되어 있습니다. 또한 NSH는 서비스별 OAM\(운영, 관리 및 유지 관리\) 메시지를 통해 엔드투엔드 서비스 체인을 모니터링하고 문제를 해결하는 기능을 제공합니다. NSH 필드는 관리자가\(예: 트래픽 분석기를 통해\) 서비스 경로를 따라 전달되는 패킷의 경로 세부 사항\(예: 계정 관리, 올바른 연결 보장, 보고서 제공 등\)을 확인하는 데 사용될 수 있습니다.

3. NSH는 참여 엔터티와 서비스 기능 간에 공유 메타데이터를 전달하는 메커니즘을 제공합니다. 공유 메타데이터의 의미는 제어 평면\(이 문서의 범위를 벗어남\)을 통해 참여 노드로 전달됩니다. \[SFC-제어-평면\]의 섹션 3.3에 이에 대한 예가 나와 있습니다. 메타데이터의 예로는 정책 시행에 사용되는 분류 정보와 사후 서비스 전달을 전달하기 위한 네트워크 컨텍스트가 있습니다. 메타데이터를 공유하면 서비스 기능이 충분한 정보가 포함된 재분류를 저장하는 다운스트림 서비스 기능과 초기 및 중간 분류 결과를 공유할 수 있습니다.

4. NSH는 모든 네트워크 및 서비스 노드에 대한 서비스 체인을 위한 공통 및 표준 기반 헤더를 제공합니다.

5. 전송 캡슐화 불가지론: NSH는 전송입니다.

- 캡슐화 독립적: 다양한 캡슐화 프로토콜에 의해 전송될 수 있음을 의미합니다. 특정 배포에 대해 적절한 캡슐화 프로토콜을 사용하여 NSH 캡슐화 트래픽을 전달할 수 있습니다. 이 전송 캡슐화는

- 오버레이 네트워크; 기존 오버레이 토폴로지가 필요한 서비스 경로 연결을 제공하는 경우 해당 기존 오버레이를 사용할 수 있습니다.

---
## **2.  Network Service Header**

NSH는 원본 패킷/프레임에 적용됩니다. 이 NSH에는 서비스 경로 정보가 포함되어 있으며, 선택적으로 패킷이나 프레임에 추가되고 서비스 플레인을 생성하는 데 사용되는 메타데이터도 포함됩니다. 그 후, 네트워크 전달에 사용되는 NSH에 외부 전송 캡슐화가 적용됩니다.

서비스 분류자는 NSH를 추가합니다. NSH는 서비스 체인의 마지막 SFF 또는 패킷을 소비하는 SF에 의해 제거됩니다.

---
### **2.1.  Network Service Header Format**

NSH는 그림 2와 같이 4바이트 기본 헤더, 4바이트 서비스 경로 헤더 및 선택적 컨텍스트 헤더로 구성됩니다.

```text
      0                   1                   2                   3
      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |                Base Header                                    |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |                Service Path Header                            |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |                                                               |
     ~                Context Header(s)                              ~
     |                                                               |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                     Figure 2: Network Service Header
```

기본 헤더: 서비스 헤더 및 페이로드 프로토콜에 대한 정보를 제공합니다.

서비스 경로 헤더: 서비스 경로 내의 경로 식별 및 위치를 제공합니다.

컨텍스트 헤더: 서비스 경로를 따라 메타데이터\(즉, 컨텍스트 데이터\)를 전달합니다.

---
### **2.2.  NSH Base Header**

그림 3은 NSH 기본 헤더를 보여줍니다.

```text
      0                   1                   2                   3
      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |Ver|O|U|    TTL    |   Length  |U|U|U|U|MD Type| Next Protocol |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                         Figure 3: NSH Base Header
```

필드 설명은 다음과 같습니다.

버전: 버전 필드는 향후 NSH 사양 업데이트와 함께 이전 버전과의 호환성을 보장하는 데 사용됩니다. NSH의 첫 번째 개정판에서는 발신자가 0x0으로 설정해야 합니다. NSH 헤더를 전달하는 것으로 추정되는 패킷이 SFF에서 수신되고 SFF가 기본 헤더에 표시된 프로토콜 버전을 이해하지 못하는 경우 해당 패킷은 폐기되어야 하며 이벤트는 기록되어야 합니다. ECMP\(Equal-Cost Multipath\) 결정 처리를 위해 MPLS 레이블 스택 이후 첫 번째 니블을 사용하는 기존 하드웨어의 광범위한 구현을 고려하여 이 문서에서는 버전 01b를 예약합니다. 이 값은 프로토콜의 향후 버전에서 사용되어서는 안 됩니다. MPLS 관련 전달 요구 사항에 대한 자세한 내용은 \[RFC7325\]를 참조하세요.\(MUST, MUST, MUST NOT\)

O 비트: 이 비트를 설정하면 OAM 패킷을 나타냅니다\(\[RFC6291\] 참조\). SFC OAM 패킷의 실제 형식과 처리는 이 사양의 범위를 벗어납니다\(예를 들어 한 가지 접근 방식은 \[SFC-OAM-FRAMEWORK\] 참조\).

- OAM 패킷에 대해 O 비트를 설정해야 하며, OAM이 아닌 패킷에 대해 설정하면 안 됩니다. O 비트는 SFP를 따라 수정되어서는 안 됩니다.\(MUST NOT, MUST NOT\)

- SFC OAM 절차를 지원하지 않는 SF/SFF/SFC 프록시/분류자 구현은 O 비트가 설정된 패킷을 폐기해야 하지만 수정되지 않은 수신된 SFC OAM 패킷을 체인의 다음 요소로 전달할 수 있도록 구성 가능한 매개변수를 지원할 수 있습니다. SFC OAM 절차를 지원하지 않는 SFC 요소에 의해 수정되지 않은 OAM 패킷을 전달하는 것은 OAM 기능의 하위 집합에 대해 허용될 수 있지만 다른 기능에 대해서는 예상치 못한 결과를 초래할 수 있습니다. 따라서 이 동작을 활성화하기 전에 모든 OAM 기능에 대한 OAM 패킷 전달의 영향을 분석하는 것이 좋습니다. 구성 가능한 매개변수는 기본적으로 비활성화되어야 합니다.\(SHOULD, MUST\)

TTL: SFP의 최대 SFF 홉을 나타냅니다. 이 필드는 서비스 평면 루프 감지에 사용됩니다. 초기 TTL 값은 제어 평면을 통해 구성 가능해야 합니다. 구성된 초기 값은 하나 이상의 SFP에 특정할 수 있습니다. 초기 값이 명시적으로 제공되지 않으면 기본 초기 TTL 값인 63을 사용해야 합니다. NSH 패킷 전달과 관련된 각 SFF는 NSH 전달 조회 이전에 TTL 값을 1씩 줄여야 합니다. 수신 값 0에서 1씩 감소하면 TTL 값은 63이 됩니다. 감소 후 TTL이 0이면 패킷을 전달해서는 안 됩니다.\(SHOULD, MUST, MUST, MUST NOT\)

- 이 TTL 필드는 기본 루프 방지 메커니즘입니다. 이 TTL 메커니즘은 TTL이 각 SFF에 의해 감소하므로 서비스 지수\(섹션 2.3 참조\)에 대한 강력한 보완을 나타냅니다. 들어오는 0 TTL을 처리하면 완벽하지는 않지만 이 TTL 필드를 지원하지 않는 사전 표준 구현과 더 나은 상호 운용이 가능합니다.

길이: 기본 헤더, 서비스 경로 헤더, 고정 길이 컨텍스트 헤더 또는 가변 길이 컨텍스트 헤더를 포함하는 NSH의 총 길이\(4바이트 단어\)입니다. 길이는 MD 유형 0x1의 경우 0x6이어야 하고, MD 유형 0x2의 경우 길이는 0x2 이상이어야 합니다. 네트워크 서비스 헤더의 길이는 4바이트의 정수배여야 합니다. 따라서 가변 길이 메타데이터는 항상 4바이트의 배수로 채워집니다.\(MUST, MUST\)

할당되지 않은 비트: U로 표시된 다른 모든 플래그 필드는 할당되지 않았으며 나중에 사용할 수 있습니다. 섹션 9.1.1을 참조하십시오. 할당되지 않은 비트는 생성 시 0으로 설정되어야 하며 다른 NSH 지원 요소에 의해 무시되고 수정되지 않은 상태로 보존되어야 합니다. 수신 시 모든 요소는 이러한 알 수 없는 비트를 기반으로 해당 작업을 수정해서는 안 됩니다.\(MUST, MUST NOT\)

메타데이터\(MD\) 유형: 필수 NSH 기본 헤더 및 서비스 경로 헤더 이외의 NSH 형식을 나타냅니다. MD 유형은 전달되는 메타데이터의 형식을 정의합니다. 섹션 9.1.3의 IANA 고려 사항을 참조하세요.

- 이 문서에서는 다음 네 가지 MD 유형 값을 지정합니다.

- 0x0: 예약된 값입니다. 구현은 MD 유형 0x0의 패킷을 자동으로 삭제해야 합니다\(SHOULD\).\(SHOULD\)

- 0x1: 헤더 형식에 고정 길이 컨텍스트 헤더가 포함되어 있음을 나타냅니다\(아래 그림 5 참조\).

- 0x2: 기본 헤더 및 서비스 경로 헤더 이외의 헤더를 요구하지 않지만 선택적 가변 길이 컨텍스트 헤더를 포함할 수 있습니다. MD 유형 0x2의 경우 길이 0x2는 컨텍스트 헤더가 없음을 의미합니다. 가변 길이 컨텍스트 헤더의 의미는 이 문서에 정의되어 있지 않습니다. 선택적 가변 길이 컨텍스트 헤더의 형식은 섹션 2.5.1에 ​​제공됩니다.

- 0xF: 이 값은 \[RFC3692\]에 따라 실험 및 테스트용으로 예약되어 있습니다. 실험의 일부로 명시적으로 구성되지 않은 구현은 MD 유형 0xF의 패킷을 자동으로 삭제해야 합니다\(SHOULD\).\(SHOULD\)

- Base Header와 Service Path Header의 포맷은 변하지 않으며, MD Type에 영향을 받지 않습니다.

- NSH MD 유형 1과 MD 유형 2는 각각 2.4절과 2.5절에서 자세히 설명됩니다. NSH 구현은 MD 유형 0x1 및 0x2\(길이가 0x2임\)를 지원해야 합니다. NSH 구현은 길이가 0x2보다 큰 MD 유형 0x2를 지원해야 합니다\(SHOULD\). 0x2보다 긴 길이의 MD 유형 0x2를 지원하지 않는 장치는 선택적 컨텍스트 헤더를 무시하고 헤더 없이 패킷을 처리해야 합니다. 기본 헤더 길이 필드는 원래 패킷/프레임에 대한 액세스가 필요한 경우 원래 페이로드 오프셋을 결정하는 데 사용될 수 있습니다. 이 사양은 MD 유형 값이 SFP에 따라 변경되는 것을 허용하지 않습니다. 그러나 MD 유형이 SFP에 따라 변경되도록 허용하는 데 필요한 메커니즘의 사양은 이 문서의 범위를 벗어나며 해당 기능을 사용하려면 정의해야 합니다. 구현에서 지원되지 않는 MD 유형 값을 가진 패킷은 자동으로 삭제되어야 합니다.\(MUST, SHOULD, MUST, MUST\)

다음 프로토콜: 캡슐화된 데이터의 프로토콜 유형을 나타냅니다. NSH는 내부 페이로드를 변경하지 않으며 NSH SFC로 인해 내부 프로토콜의 의미는 변경되지 않습니다. 섹션 9.1.6의 IANA 고려 사항을 참조하세요.

- 이 문서에서는 다음과 같은 Next Protocol 값을 정의합니다.

```text
      0x1: IPv4
      0x2: IPv6
      0x3: Ethernet
      0x4: NSH
      0x5: MPLS
      0xFE: Experiment 1
      0xFF: Experiment 2
```

- 0x4\(NSH\)의 Next Protocol 값을 사용하는 계층적 NSH의 기능은 이 사양의 범위를 벗어납니다. 지원되지 않는 다음 프로토콜 값을 가진 패킷은 기본적으로 자동으로 삭제되어야 하지만 구현에서는 이를 전달하기 위한 구성 매개변수를 제공할 수 있습니다. 또한 특정 실험 \[RFC3692\]에 대해 명시적으로 구성되지 않은 구현은 다음 프로토콜 값이 0xFE 및 0xFF인 패킷을 자동으로 삭제해야 합니다\(SHOULD\).\(SHOULD, SHOULD\)

---
### **2.3.  Service Path Header**

그림 4는 서비스 경로 헤더의 형식을 보여줍니다.

```text
      0                   1                   2                   3
      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |          Service Path Identifier (SPI)        | Service Index |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

     Service Path Identifier (SPI): 24 bits
     Service Index (SI): 8 bits

                     Figure 4: NSH Service Path Header
```

이러한 필드의 의미는 다음과 같습니다.

SPI\(서비스 경로 식별자\): SFP\(서비스 기능 경로\)를 고유하게 식별합니다. 참여 노드는 SFP 선택을 위해 이 식별자를 사용해야 합니다. 초기 분류자는 주어진 분류 결과에 대해 적절한 SPI를 설정해야 합니다.\(MUST, MUST\)

서비스 인덱스\(SI\): SFP 내 위치를 제공합니다. 주어진 SFP에 대한 초기 분류자는 SI를 255로 설정해야 합니다. 그러나 제어 평면은 SI의 초기 값을 적절하게 구성할 수 있습니다\(즉, SFP의 길이를 고려\). 서비스 인덱스는 필요한 서비스를 수행한 후 서비스 기능 또는 SFC 프록시 노드에 의해 값 1만큼 감소되어야 합니다. 새로 감소된 SI 값은 송신 패킷의 NSH에서 사용해야 합니다. 초기 분류자는 SFP를 따라 전달하기 위해 식별된 SFP의 첫 번째 SFF로 패킷을 보내야 합니다. 재분류가 발생하고 해당 재분류로 인해 새로운 SPI가 생성되는 경우 \(재\)분류자는 사실상 결과 SPI에 대한 초기 분류자가 됩니다.\(SHOULD, MUST, MUST\)

SI는 SFP 선택과 경로의 다음 SFF/SF 결정을 위해 서비스 경로 식별자와 함께 사용됩니다. SI는 서비스 경로 문제를 해결하거나 보고할 때도 유용합니다. TTL은 이 메커니즘에 대한 기본 SFF 기반 루프 방지 기능을 제공하지만 SF에 의한 SI 감소는 제한된 루프 방지 역할을 합니다.

기구. 위에서 설명한 대로 NSH 패킷은 SFF가 TTL을 0으로 감소시키면 폐기됩니다. 또한 SFP에 대한 터미널 SFF가 아닌 SFF는 SI가 0인 모든 NSH 패킷을 폐기합니다. SF정보입니다.

---
### **2.4.  NSH MD Type 1**

기본 헤더가 MD 유형 0x1을 지정하는 경우 고정 길이 컨텍스트 헤더\(16바이트\)는 그림 5와 같이 서비스 경로 헤더 바로 뒤에 있어야 합니다. 메타데이터를 전달하지 않는 고정 길이 컨텍스트 헤더의 값은 반드시 0으로 설정합니다.\(MUST, MUST\)

```text
      0                   1                   2                   3
      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |Ver|O|U|    TTL    |   Length  |U|U|U|U|MD Type| Next Protocol |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |          Service Path Identifier              | Service Index |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |                                                               |
     |                 Fixed-Length Context Header                   |
     |                                                               |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                         Figure 5: NSH MD Type 0x1
```

본 사양에서는 MD Type 필드가 1로 설정된 경우 반드시 존재해야 하는 16바이트 Context Header의 내용에 대해 어떠한 가정도 하지 않으며, 포함된 메타데이터의 구조나 의미에 대해서도 설명하지 않습니다.

SFC 인식 SF 또는 SFC 프록시는 필수 컨텍스트 필드에 있는 데이터를 처리하기 위해 먼저 데이터 구조와 의미를 수신해야 합니다. 데이터 구조와 의미에는 할당 스키마와 순서뿐 아니라 포함된 데이터의 의미도 포함됩니다. SFC 인식 SF 또는 SFC 프록시가 데이터 구조와 의미를 얻는 방법은 이 사양의 범위를 벗어납니다.

MD 유형 1을 사용하는 NSH에 대한 컨텍스트 헤더의 형식이나 의미를 모르는 SF 또는 SFC 프록시는 그러한 NSH가 포함된 모든 패킷을 폐기해야 하며\(즉, 처리할 수 없는 메타데이터를 무시해서는 안 됩니다\), 이벤트가 발생하는 SPI당 최소 한 번 이벤트를 발생시킵니다\(임계값 적용\).\(MUST NOT\)

\[NSH-DC-ALLOCATION\] 및 \[NSH-BROADBAND-ALLOCATION\]은 메타데이터를 할당할 수 있는 방법에 대한 구체적인 예를 제공합니다.

---
### **2.5.  NSH MD Type 2**

기본 헤더가 MD 유형 0x2를 지정하면 0개 이상의 가변 길이 컨텍스트 헤더가 서비스 경로 헤더 바로 뒤에 추가될 수 있습니다\(그림 6 참조\). 따라서 길이 = 0x2는 기본 헤더와 서비스 경로 헤더만 해당 순서로 존재함을 나타냅니다. 선택적 가변 길이 컨텍스트 헤더는 4바이트의 정수여야 합니다. 기본 헤더 길이 필드는 해당 정보에 대한 액세스가 필요한 SFC 노드에 대한 원본 패킷 또는 프레임을 찾기 위한 오프셋을 결정하는 데 사용해야 합니다.\(MAY, MUST, MUST\)

```text
      0                   1                   2                   3
      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |Ver|O|U|    TTL    |   Length  |U|U|U|U|MD Type| Next Protocol |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |          Service Path Identifier              | Service Index |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |                                                               |
     ~              Variable-Length Context Headers  (opt.)          ~
     |                                                               |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                         Figure 6: NSH MD Type 0x2
```

---
#### **2.5.1.  Optional Variable-Length Metadata**

선택적 가변 길이 컨텍스트 헤더의 형식은 그림 7에 설명되어 있습니다.

```text
      0                   1                   2                   3
      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |          Metadata Class       |      Type     |U|    Length   |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |                   Variable-Length Metadata                    |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                 Figure 7: Variable-Length Context Headers
```

메타데이터 클래스\(MD 클래스\): 계층적 네임스페이스를 제공하기 위해 유형 필드의 범위를 정의합니다. 섹션 9.1.4에서는 MD 클래스 값을 표준 기관, 공급업체 및 기타 업체에 할당하는 방법을 정의합니다.

유형: 전달되는 메타데이터의 명시적인 유형을 나타냅니다. 유형 정의는 MD 클래스 소유자의 책임입니다.

할당되지 않은 비트: 할당되지 않은 비트 하나는 나중에 사용할 수 있습니다. 이 비트는 설정되어서는 안 되며, 수신 시 무시되어야 합니다.\(MUST NOT\)

길이: 가변 길이 메타데이터의 길이\(바이트\)를 나타냅니다. 메타데이터 길이가 4바이트 단어의 정수가 아닌 경우 발신자는 마지막 메타데이터 바이트 바로 뒤에 패드 바이트를 추가하여 메타데이터를 4바이트 단어의 정수로 확장해야 합니다. 수신기는 패킷에서 다음 필드를 찾아 처리하기 위해 길이 필드를 가장 가까운 4바이트 단어 경계로 반올림해야 합니다. 수신자는 길이 필드\(즉, 실제 바이트 수\)로 표시된 메타데이터의 해당 바이트에만 액세스해야 하며 가장 가까운 4바이트 단어 경계까지 나머지 바이트를 무시해야 합니다. 길이는 0 이상일 수 있습니다.\(MUST, MUST, MUST\)

- 값 0은 가변 길이 메타데이터 필드가 없는 컨텍스트 헤더를 나타냅니다.

이 사양은 구현이 필수이거나 처리가 필수인 컨텍스트 헤더에 대해 어떠한 가정도 하지 않습니다. 이러한 고려 사항은 배포에 따라 다릅니다. 그러나 제어 평면은 범위 지정과 함께 컨텍스트 헤더의 데이터 구조를 SFC 인식 SF에 지시할 수 있는 권한이 있습니다\(예: \[SFC-제어-PLANE\]의 섹션 3.3.3 참조\).

주어진 SFP에 속하는 패킷을 수신할 때 해당 패킷에 처리 필수 ​​컨텍스트 헤더가 누락된 경우 SFC 인식 SF는 패킷을 처리해서는 안 되며 SPI당 적어도 한 번 오류를 기록해야 합니다. 필수 메타데이터가 누락되었습니다.\(MUST NOT\)

주어진 SFP에 대해 여러 개의 필수 처리 컨텍스트 헤더가 필요한 경우 제어 평면은 SFC 인식 SF에 이러한 컨텍스트 헤더를 소비하라는 명령을 지시할 수 있습니다. 지침이 제공되지 않고 SFC 인식 SF가 특정 컨텍스트 헤더를 사용하거나 수정하는 경우 SFC 인식 SF는 이러한 컨텍스트 헤더를 NSH 패킷에 나타나는 순서대로 처리해야 합니다.\(MAY, MUST\)

동일한 메타데이터의 여러 인스턴스가 NSH 패킷에 포함되어 있지만 해당 컨텍스트 헤더의 정의가 이를 허용하지 않는 경우 SFC 인식 SF는 첫 번째 인스턴스를 처리하고 후속 인스턴스를 무시해야 합니다. SFC 인식 SF는 이 이벤트에 대한 카운터를 기록하거나 늘릴 수 있습니다.\(MUST, MAY\)

---
## **3.  NSH Actions**

NSH 인식 노드\(서비스 분류자, SFF, SF 및 SFC 프록시 포함\)는 NSH 헤더의 내용을 변경할 수 있습니다. 이러한 노드에는 NSH 관련 작업이 가능합니다.

1. NSH 삽입 또는 제거: 이러한 작업은 각각 서비스 경로의 시작과 끝에서 발생할 수 있습니다. 패킷은 분류되며, 서비스가 필요한 것으로 판단되면 NSH가 부과됩니다. ㅏ

- 서비스 분류자는 SFP 시작 시 NSH를 삽입해야 합니다. 부과된 NSH에는 유효한 기본 헤더와 서비스 경로 헤더가 모두 포함되어야 합니다. SFP 끝에서 SFF는 캡슐화되지 않은 패킷을 전달하거나 전달하기 전에 NSH를 제거해야 합니다. 따라서 서비스 헤더에서 작동하는 마지막 노드입니다.\(MUST, MUST, MUST\)

- 주어진 서비스 경로 내에 여러 논리적 분류자가 존재할 수 있습니다. 초기가 아닌 분류자는 데이터를 재분류할 수 있으며, 재분류로 인해 다른 SFP가 선택될 수 있습니다. 논리적 분류자는 서비스 경로 변경을 초래하는 재분류를 수행할 때 기존 NSH를 새로운 서비스 경로 정보를 반영한 ​​기본 헤더와 서비스 경로 헤더를 포함하는 새로운 NSH로 교체해야 하며 초기 SI를 설정해야 합니다. O 비트, TTL 필드 및 할당되지 않은 플래그는 이전 NSH에서 새 NSH로 투명하게 복사되어야 합니다. 메타데이터는 새로운 NSH에 보존될 수 있습니다.\(MAY, MUST, MUST, MAY\)

2. 서비스 경로 선택: 서비스 경로 헤더는 서비스 경로 정보를 제공하며 SFF가 올바른 서비스 경로 선택을 결정하는 데 사용됩니다. SFF는 서비스 경로에서 다음 SF 또는 SFF를 선택하기 위해 서비스 경로 헤더를 사용해야 합니다.\(MUST\)

3. NSH 업데이트: SF는 서비스 인덱스를 1씩 줄여야 합니다. SFF가 유효한 SFP의 유효한 다음 홉에 해당하지 않는 SPI 및 SI가 포함된 패킷을 수신하는 경우 해당 패킷은 SFF에 의해 삭제되어야 합니다.\(MUST, MUST\)

- 새로운/업데이트된 컨텍스트가 사용 가능한 경우 분류자는 컨텍스트 헤더를 업데이트할 수 있습니다.\(MAY\)

- SFC 프록시가 사용 중인 경우\(NSH 작업을 위해 NSH를 인식하지 못하는 서비스 기능을 대신하여 작동\) 프록시는 서비스 색인을 업데이트해야 하며 컨텍스트를 업데이트할 수 있습니다. SFC 프록시가 NSH 캡슐화된 패킷을 수신하면 NSH를 인식하지 못하는 SF로 전달하기 전에 NSH를 제거해야 합니다. SFC 프록시가 NSH를 인식하지 못하는 SF로부터 패킷을 다시 수신하면 이를 올바른 NSH로 다시 캡슐화해야 하며 서비스 인덱스를 1씩 줄여야 합니다.\(MUST, MUST, MUST\)

4. 서비스 정책 선택: 서비스 기능은 NSH에서 정책\(즉, 허용 또는 거부와 같은 서비스 작업\) 선택 및 시행을 도출합니다. NSH에서 공유되는 메타데이터는 트래픽 분류와 같은 다양한 서비스 관련 정보를 제공할 수 있습니다.

그림 8은 위의 네 가지 작업 각각을 이를 수행할 수 있는 SFC 아키텍처의 구성 요소에 매핑합니다.

```text
   +-----------+-----------------------+-------+---------------+-------+
   |           | Insert, remove, or    |Forward| Update        |Service|
   |           | replace the NSH       |the NSH| the NSH       |policy |
   |           |                       |packets|               |sel.   |
   |Component  +-------+-------+-------+       +-------+-------+       |
   |           |       |       |       |       |Dec.   |Update |       |
   |           |Insert |Remove |Replace|       |Service|Context|       |
   |           |       |       |       |       |Index  |Header |       |
   +-----------+-------+-------+-------+-------+-------+-------+-------+
   |           |  +    |       |   +   |       |       |   +   |       |
   |Classifier |       |       |       |       |       |       |       |
   +-----------+-------+-------+-------+-------+-------+-------+-------+
   |Service    |       |   +   |       |   +   |       |       |       |
   |Function   |       |       |       |       |       |       |       |
   |Forwarder  |       |       |       |       |       |       |       |
   |(SFF)      |       |       |       |       |       |       |       |
   +-----------+-------+-------+-------+-------+-------+-------+-------+
   |Service    |       |       |       |       |   +   |   +   |   +   |
   |Function   |       |       |       |       |       |       |       |
   |(SF)       |       |       |       |       |       |       |       |
   +-----------+-------+-------+-------+-------+-------+-------+-------+
   |           |  +    |   +   |       |       |   +   |   +   |       |
   |SFC Proxy  |       |       |       |       |       |       |       |
   +-----------+-------+-------+-------+-------+-------+-------+-------+

                   Figure 8: NSH Action and Role Mapping
```

---
## **4.  NSH Transport Encapsulation**

NSH가 패킷에 추가되면 외부 전송 캡슐화를 사용하여 원본 패킷과 관련 메타데이터를 서비스 체인의 시작 부분으로 전달합니다. 캡슐화는 두 가지 목적으로 사용됩니다.

1. 토폴로지적으로 독립적인 서비스 평면을 생성합니다. 패킷은 기본 네트워크 토폴로지를 변경하지 않고 필요한 서비스로 전달됩니다.

2. 전송 네트워크 노드는 수정 없이 캡슐화된 패킷을 전달하기만 합니다.

서비스 헤더는 사용된 전송 캡슐화와 독립적입니다. 기존 전송 캡슐화를 사용할 수 있습니다. NSH의 존재는 프로토콜 유형이나 외부 전송 캡슐화의 다른 표시기를 통해 표시됩니다.

---
## **5.  Fragmentation Considerations**

NSH 및 관련 전송 캡슐화 헤더는 캡슐화된 패킷/프레임에 "추가"됩니다. 이 추가 정보로 인해 패킷 크기가 늘어납니다.

관리되는 관리 도메인 내에서 운영자는 언더레이 MTU가 조각화 없이 SFC 트래픽을 전달하기에 충분한지 확인할 수 있습니다. NSH의 의도된 범위가 단일 공급자의 운영 도메인 내에 있다는 점을 고려하면 이러한 접근 방식으로 충분합니다.

그러나 명시적으로 이 사양의 범위를 벗어나더라도 언더레이 MTU가 NSH 트래픽을 전달할 만큼 크지 않은 경우가 있을 수 있습니다. NSH는 서비스 평면에서 조각화 지원을 제공하지 않으므로 전송 캡슐화 프로토콜은 필요한 조각화 처리를 제공해야 합니다. 예를 들어, \[RTG-ENCAP\]의 섹션 9는 이러한 시나리오에 대한 예시적인 접근 방식과 지침을 제공합니다.

전송 캡슐화 프로토콜이 조각화를 지원하고 조각화 절차를 사용해야 하는 경우 이러한 조각화는 전송 캡슐화 논리의 일부입니다. 일반적으로 전송 캡슐화의 끝점에서 조각화가 수행되는 경우 전송 캡슐화의 일부로 조각화 절차가 전송 NSH 엔터티에서 수행되고 전송 역캡슐화 중에 수신 NSH 엔터티에서 리어셈블리 절차가 수행됩니다. 처리 논리. 어떠한 경우에도 이러한 조각화로 인해 NSH 헤더가 중복되지는 않습니다.

예를 들어 NSH가 IP에 캡슐화되면 PMTUD\(Path MTU Discovery\)\(예: \[RFC8201\]\)와 결합된 IP 수준 조각화가 사용됩니다. PMTUD는 ICMP 메시지에 의존하므로 운영자는 ICMP 패킷이 차단되지 않았는지 확인해야 합니다. 반면에 언더레이가 조각화 절차를 지원하지 않는 경우 너무 큰 패킷을 삭제할 때 오류 메시지가 기록되어야 합니다. 마지막으로 NSH 관련 단편화 및 재조립 방법도 정의할 수 있지만 이러한 방법은 이 문서의 범위를 벗어나며 향후 작업의 주제입니다.\(SHOULD\)

---
## **6.  Service Path Forwarding with NSH**
---
### **6.1.  SFFs and Overlay Selection**

위에서 설명한 것처럼 NSH에는 SPI\(Service Path Identifier\)와 SI\(Service Index\)가 포함되어 있습니다. SPI는 이름 그대로 식별자입니다. SPI만으로는 서비스 경로를 따라 패킷을 전달하는 데 사용할 수 없습니다. 오히려 SPI는 서비스 경로/토폴로지와 네트워크 전송 캡슐화 간의 간접 수준을 제공합니다. 또한 SPI가 미리 결정된 또는 정적 네트워크 경로에 바인딩되어야 한다는 요구 사항이나 기대도 없습니다.

서비스 인덱스는 서비스 경로 내의 위치를 ​​나타냅니다. SPI와 SI의 조합은 논리적 SF의 식별과 서비스 평면 내에서의 순서를 제공합니다. 이 조합은 오버레이 전달에 적합한 네트워크 로케이터를 선택하는 데 사용됩니다. 논리적 SF는 단일 SF이거나 동등한 적격 SF 세트일 수 있습니다. 후자의 경우 SFF는 필요에 따라 SF 컬렉션 간에 로드 분산을 제공합니다.

SI는 유효하지 않은 SFP를 감지하는 메커니즘 역할을 합니다. 특히 SI 값이 0이면 전달이 올바르지 않으며 패킷을 삭제해야 함을 나타냅니다.

이 간접 참조\(오버레이할 SPI\)는 진정한 서비스 플레인을 생성합니다. 즉, SFF/SF 토폴로지는 네트워크 토폴로지에 영향을 주지 않고 구성되지만, 더 중요한 것은 서비스 평면 전용 참가자\(즉, 대부분의 SF\)가 네트워크 오버레이 토폴로지 및 관련 인프라\(예: 제어\)의 일부일 필요가 없다는 것입니다. 평면, 라우팅 테이블 등\). SF는 서비스 처리가 완료되면 패킷을 적절한 SFF\(즉, 필수 NSH 정보가 있음\)로 반환할 수 있어야 합니다. 이는 오버레이 또는 언더레이를 통해 이루어질 수 있으며 경우에 따라 SF에 추가 구성이 필요할 수 있습니다. 위에서 언급한 것처럼 필요한 연결을 제공하는 경우 기존 오버레이 토폴로지를 사용할 수 있습니다.

전송 캡슐화에 대한 SPI의 매핑은 SFF에서 발생합니다\(위에서 설명한 대로 경로의 첫 번째 SFF는 분류자로부터 NSH 캡슐화 패킷을 가져옵니다\). SFF는 SPI/ID 값을 참조하여 적절한 오버레이 전송 캡슐화 프로토콜\(여러 개가 특정 네트워크 내에서 사용될 수 있음\)과 필수 SF에 대한 다음 홉을 결정합니다. 표 1은 단일 다음 홉 SPI/SI-네트워크 오버레이 네트워크 로케이터 매핑의 예를 보여줍니다.

```text
      +------+------+---------------------+-------------------------+
      | SPI  | SI   | Next Hop(s)         | Transport Encapsulation |
      +------+------+---------------------+-------------------------+
      | 10   | 255  | 192.0.2.1           | VXLAN-gpe               |
      |      |      |                     |                         |
      | 10   | 254  | 198.51.100.10       | GRE                     |
      |      |      |                     |                         |
      | 10   | 251  | 198.51.100.15       | GRE                     |
      |      |      |                     |                         |
      | 40   | 251  | 198.51.100.15       | GRE                     |
      |      |      |                     |                         |
      | 50   | 200  | 01:23:45:67:89:ab   | Ethernet                |
      |      |      |                     |                         |
      | 15   | 212  | Null (end of path)  | None                    |
      +------+------+---------------------+-------------------------+

                     Table 1: SFF NSH Mapping Example
```

또한 추가 간접 지정도 가능합니다. 필요한 SF 네트워크 로케이터의 확인은 표 2 및 3에 따라 SFC 제어 플레인 책임이 아닌 SFF의 지역화된 확인일 수 있습니다.

참고: 위 표의 VXLAN-gpe 및 GRE는 각각 \[VXLAN-GPE\] 및 \[RFC2784\] \[RFC7676\]를 참조합니다.

```text
                      +------+-----+----------------+
                      | SPI  | SI  | Next Hop(s)    |
                      +------+-----+----------------+
                      | 10   | 3   | SF2            |
                      |      |     |                |
                      | 245  | 12  | SF34           |
                      |      |     |                |
                      | 40   | 9   | SF9            |
                      +------+-----+----------------+

                    Table 2: NSH-to-SF Mapping Example

          +------+-------------------+-------------------------+
          | SF   | Next Hop(s)       | Transport Encapsulation |
          +------+-------------------+-------------------------+
          | SF2  | 192.0.2.2         | VXLAN-gpe               |
          |      |                   |                         |
          | SF34 | 198.51.100.34     | UDP                     |
          |      |                   |                         |
          | SF9  | 2001:db8::1       | GRE                     |
          +------+-------------------+-------------------------+

                    Table 3: SF Locator Mapping Example
```

SPI는 서비스 경로를 나타내기 때문에 조회는 주어진 SF에 대한 서비스 경로 내에서 하나 이상의 가능한 다음 홉을 반환할 수 있습니다. 이는 기본적으로 부하 분산, 중복성을 위해 사용될 가중치가 부여된\(동등하거나 다른 방식으로\) 일련의 경로입니다. 또는 정책\); 표 4를 참조하십시오. 표 4에 묘사된 측정항목은 SF의 가중치를 설명하는 데 도움이 되는 예입니다. 실제 네트워크에서 메트릭은 단순한 기본 설정\(다음 홉 라우팅과 유사\)부터 서비스 기능 상태\(로드, 세션 상태, 용량 등 포함\)를 기반으로 하는 진정한 동적 복합 메트릭까지 다양합니다.

```text
                  +------+-----+--------------+---------+
                  | SPI  | SI  | NH           | Metric  |
                  +------+-----+--------------+---------+
                  | 10   | 3   | 203.0.113.1  | 1       |
                  |      |     |              |         |
                  |      |     | 203.0.113.2  | 1       |
                  |      |     |              |         |
                  | 20   | 12  | 192.0.2.1    | 1       |
                  |      |     |              |         |
                  |      |     | 203.0.113.4  | 1       |
                  |      |     |              |         |
                  | 30   | 7   | 192.0.2.10   | 10      |
                  |      |     |              |         |
                  |      |     | 198.51.100.1 | 5       |
                  +------+-----+--------------+---------+

                (encapsulation type omitted for formatting)

                    Table 4: NSH Weighted Service Path
```

표 1-4에 포함된 정보는 제어 평면에서 수신될 수 있지만 정확한 메커니즘은 이 문서의 범위를 벗어납니다.

---
### **6.2.  Mapping the NSH to Network Topology**

위에서 설명한 대로 SPI를 네트워크 토폴로지로 매핑하면 단일 경로가 생성되거나 더 복잡한 토폴로지가 생성될 수 있습니다. 또한 SPI-오버레이 매핑은 각 SFF에서 독립적으로 발생합니다. 토폴로지 선택의 모든 조합이 가능합니다. 적합한 오버레이 토폴로지가 이미 존재하는 경우 새 오버레이 토폴로지를 생성할 필요가 없습니다. NSH 패킷은 필수 연결 요구 사항이 충족되면 모든\(신규 또는 기존\) 오버레이를 사용할 수 있습니다.

토폴로지 매핑의 예:

```text
   1.  Next SF is located at SFFb with locator 2001:db8::1
       SFFa mapping: SPI=10 --> VXLAN-gpe, dst-ip: 2001:db8::1

   2.  Next SF is located at SFFc with multiple network locators for
       load-distribution purposes:
       SFFb mapping: SPI=10 --> VXLAN-gpe, dst_ip:203.0.113.1,
       203.0.113.2, 203.0.113.3, equal cost

   3.  Next SF is located at SFFd with two paths from SFFc, one for
       redundancy:
       SFFc mapping: SPI=10 --> VXLAN-gpe, dst_ip:192.0.2.10 cost=10,
       203.0.113.10, cost=20
```

위의 예에서 각 SFF는 네트워크 오버레이 경로와 해당 경로에 대한 정책에 대해 독립적인 결정을 내립니다. 즉, 네트워크에서 패킷을 전달하는 방법에 대한 선험적 명령은 없습니다\(트래버스해야 하는 서비스의 순서만\).

네트워크 운영자는 필요에 따라 네트워크 경로를 엔지니어링할 수 있는 능력을 보유합니다. 예를 들어, SFF 간의 오버레이 경로는 서비스 경로로 명시적으로 확장하기 위한 복잡한 구성 및 네트워크 프로토콜 지원을 요구하지 않고도 트래픽 엔지니어링, QoS 마킹 또는 ECMP를 활용할 수 있습니다. 즉, 네트워크는 예상대로 작동하고 서비스 평면과 마찬가지로 필요에 따라 발전합니다.

---
### **6.3.  Service Plane Visibility**

SPI와 SI는 서비스 토폴로지에 대한 가시성을 제공하는 중요한 기능을 제공합니다. 운영자는 NSH 정보\(패킷 캡처, IPFIX\(IP 흐름 정보 내보내기\) 등\)를 확인하여 패킷이 "있는" 서비스 경로와 해당 경로 내 위치를 확인할 수 있습니다. 이 정보는 서비스 일정 및 배치 결정, 문제 해결 및 규정 준수 확인에 사용될 수 있습니다.

---
### **6.4.  Service Graphs**

주어진 실현 SFP는 특정 서비스 기능 시퀀스인 반면, 사용자가 보는 서비스는 분류자\(서비스 내 경로, 비초기 재분류\)가 제공하는 상호 연결을 통해 실제로 SFP의 모음일 수 있습니다. 이러한 내부 재분류자는 네트워크의 관련 지점에서 패킷을 검사하고 필요한 경우 SPI 및 SI를 업데이트합니다\(이 업데이트가 재작성인지 또는 새 값을 가진 새 NSH의 부과가 구현에 따라 다름\). 분류의 "결과"를 반영합니다. 물론 이러한 분류자는 패킷과 관련된 메타데이터를 수정할 수도 있습니다. \[RFC7665\]의 섹션 2.1에서는 서비스 그래프에 대해 자세히 설명합니다.

---
## **7.  Policy Enforcement with NSH**
---
### **7.1.  NSH Metadata and Policy Enforcement**

섹션 2에서 설명한 것처럼 NSH는 서비스 경로를 따라 메타데이터를 전달하는 기능을 제공합니다. 이 메타데이터는 여러 소스에서 파생될 수 있습니다. 일반적인 예는 다음과 같습니다.

- 네트워크 노드/장치: 네트워크 노드에서 제공하는 정보는 서비스 기능에서 사용하거나 서비스 경로 송신 후 다른 네트워크 노드로 전달될 수 있는 네트워크 중심 정보\(예: VRF\(VPN 라우팅 및 전달\) 또는 테넌트\)를 나타낼 수 있습니다.

- 외부\(네트워크에 대한\) 시스템: 오케스트레이션 시스템과 같은 외부 시스템에는 서비스 기능 정책 결정에 중요한 정보가 포함되는 경우가 많습니다. 대부분의 경우 이 정보는 네트워크 노드에서 추론할 수 없습니다. 예를 들어, 워크로드를 배치하는 클라우드 오케스트레이션 플랫폼은 어떤 애플리케이션이 인스턴스화되고 있는지 "알고" 컨텍스트 헤더에 포함된 메타데이터를 통해 이 정보를 모든 NSH 노드에 전달할 수 있습니다.

- 서비스 기능: 서비스 기능과 공동 상주하는 분류자는 종종 매우 상세하고 가치 있는 분류를 수행합니다.

소스에 관계없이 메타데이터는 분류의 "결과"를 반영합니다. 분류의 세분성은 다를 수 있습니다. 예를 들어, 분류자 역할을 하는 네트워크 스위치는 2-튜플 또는 5-튜플을 기반으로만 분류할 수 있는 반면 서비스 기능은 애플리케이션 정보를 검사할 수 있습니다. 입도에 관계없이 분류 정보는 NSH에서 표현될 수 있습니다.

데이터가 NSH에 추가되면 서비스 경로를 따라 전달됩니다. NSH 인식 SF는 메타데이터를 수신하고 해당 메타데이터를 로컬 결정 및 정책 시행에 사용할 수 있습니다. 그림 9와 10은 메타데이터와 정책 간의 관계를 강조합니다.

```text
                +-------+        +-------+        +-------+
                |  SFF  )------->(  SFF  |------->|  SFF  |
                +---+---+        +---+---+        +---+---+
                    ^                |                |
                  ,-|-.            ,-|-.            ,-|-.
                 /     \          /     \          /     \
                ( Class )        (  SF1  )        (  SF2  )
                 \ ify /          \     /          \     /
                  `---'            `---'            `---'
                 5-tuple:        Permit             Inspect
                 Tenant A        Tenant A           AppY
                 AppY

                       Figure 9: Metadata and Policy

               +-----+           +-----+            +-----+
               | SFF |---------> | SFF |----------> | SFF |
               +--+--+           +--+--+            +--+--+
                  ^                 |                  |
                ,-+-.             ,-+-.              ,-+-.
               /     \           /     \            /     \
              ( Class )         (  SF1  )          (  SF2  )
               \ ify /           \     /            \     /
                `-+-'             `---'              `---'
                  |              Permit            Deny AppZ
              +---+---+          employees
              |       |
              +-------+
              External
              system:
              Employee
              AppZ
```

- 그림 10: 외부 메타데이터 및 정책

위의 두 가지 예에서 서비스 기능은 초기 분류 결과에 따라 정책 결정을 수행합니다. SF는 재분류를 수행할 필요가 없었습니다. 대신, 그들은 지역 정책 시행을 위해 선행 분류에 의존합니다.

메타데이터에 포함된 정보에 따라 데이터 개인정보 보호에 미치는 영향을 고려해야 합니다. 예를 들어 메타데이터가 테넌트 정보를 전달하는 경우 해당 정보를 인증해야 할 수 있습니다.

및/또는 발신자와 의도된 수신자\(의도된 SF만 포함될 수 있음\) 사이에서 암호화됩니다. 이를 수행하는 선택적 기능에 대한 한 가지 접근 방식은 \[NSH-ENCRYPT\]에서 살펴봅니다. NSH 자체는 개인 정보 보호 기능을 제공하지 않고 전송 캡슐화/오버레이에 의존합니다. 운영자는 기밀성\(및 기타 보안\) 고려 사항이 충족되도록 적절한 전송 캡슐화 프로토콜 세트를 선택할 수 있습니다. 메타데이터 개인 정보 보호 및 보안 고려 사항은 메타데이터 형식을 정의하는 문서에 대한 문제입니다.

---
### **7.2.  Updating/Augmenting Metadata**

초기 메타데이터 부과\(일반적으로 초기 서비스 경로 결정 중에 수행됨\) 후 메타데이터가 추가되거나 업데이트될 수 있습니다.

1. 메타데이터 확대: 그림 11에 설명된 대로 NSH의 기존 메타데이터에 정보가 추가될 수 있습니다. 예를 들어 초기 분류가 테넌트 정보를 반환하는 경우 2차 분류\(아마도 심층 패킷 검사\(DPI\) 또는 서버와 공동 상주\) 로드 밸런싱\(SLB\)\)은 애플리케이션 정보로 테넌트 분류를 강화하고 NSH 메타데이터에 해당 새 정보를 적용할 수 있습니다. 테넌트 분류는 여전히 유효하고 존재하지만 추가 정보가 추가되었습니다.

2. 메타데이터 업데이트: 후속 분류자는 초기 분류가 부정확하거나 설명이 충분하지 않은 것으로 판단되면 이를 업데이트할 수 있습니다. 예를 들어 초기 분류자는 트래픽을 "인터넷"으로 설명하는 메타데이터를 추가하지만 보안 서비스 기능은 트래픽이 실제로 "공격"이라고 판단합니다. 그림 12에서는 메타데이터 업데이트의 예를 보여줍니다.

```text
               +-----+           +-----+            +-----+
               | SFF |---------> | SFF |----------> | SFF |
               +--+--+           +--+--+            +--+--+
                  ^                 |                  |
                ,---.             ,---.              ,---.
               /     \           /     \            /     \
              ( Class )         (  SF1  )          (  SF2  )
               \     /           \     /            \     /
                `-+-'             `---'              `---'
                  |              Inspect           Deny
              +---+---+          employees         employee+
              |       |          Class=AppZ        appZ
              +-------+
              External
              system:
              Employee

                     Figure 11: Metadata Augmentation

                +-----+           +-----+            +-----+
                | SFF |---------> | SFF |----------> | SFF |
                +--+--+           +--+--+            +--+--+
                   ^                 |                  |
                 ,---.             ,---.              ,---.
                /     \           /     \            /     \
               ( Class )         (  SF1  )          (  SF2  )
                \     /           \     /            \     /
                 `---'             `---'              `---'
              5-tuple:            Inspect             Deny
              Tenant A            Tenant A            attack
                                   --> attack

                        Figure 12: Metadata Update
```

---
### **7.3.  Service Path Identifier and Metadata**

서비스 경로 식별자 값은 분류 결과를 나타낼 수 있으므로 메타데이터 정보는 서비스 경로 선택에 영향을 미칠 수 있습니다. 특정 SPI는 분류 결과\(메타데이터 분류 포함\)를 기반으로 정의될 수 있습니다. SPI 및 SI를 적용하면 패킷이 부과된 SPI 및 SI에 의해 표시된 위치의 새로 지정된 SFP에 배치됩니다.

이 관계는 각 노드가 그러한 분류를 수행할 수 있도록 요구하거나 네트워크 토폴로지에 대한 결합을 요구하지 않고도 복잡한 분류를 기반으로 동적 서비스 평면을 생성할 수 있는 기능을 제공합니다. 이를 통해 서비스 그래프 기능이 다음과 같이 생성됩니다.

섹션 6.4에 설명되어 있습니다. 그림 13에서는 이 동작의 예를 보여줍니다.

```text
               +-----+           +-----+            +-----+
               | SFF |---------> | SFF |------+---> | SFF |
               +--+--+           +--+--+      |     +--+--+
                  |                 |         |        |
                ,---.             ,---.       |      ,---.
               /     \           / SF1 \      |     /     \
              (  SCL  )         (   +   )     |    (  SF2  )
               \     /           \SCL2 /      |     \     /
                `---'             `---'    +-----+   `---'
             5-tuple:            Inspect   | SFF |    Original
             Tenant A            Tenant A  +--+--+    next SF
                                  --> DoS     |
                                              V
                                            ,-+-.
                                           /     \
                                          (  SF10 )
                                           \     /
                                            `---'
                                             DoS
                                          "Scrubber"

             Legend:
             SCL = Service Classifier

                      Figure 13: Path ID and Metadata
```

메타데이터를 SPI에 매핑하기 위한 특정 알고리즘은 이 문서의 범위를 벗어납니다.

---
## **8.  Security Considerations**

NSH 보안은 SFC 아키텍처 및 운영자 환경의 맥락에서 고려해야 합니다. NSH의 중요한 특징 중 하나는 엔드투엔드 프로토콜이 아니라는 것입니다. 호스트에서 "시작"하고 서버나 다른 호스트에서 "종료"하는 프로토콜과 달리 NSH는 일반적으로 SFC 도메인으로 들어갈 때 네트워크 장치에 의해 적용되고 SFC 도메인으로 나갈 때 제거됩니다. 따라서 다른 네트워크 중심 프로토콜\(예: IP 터널링, 트래픽 엔지니어링, MPLS 또는 공급자 프로비저닝 가상 사설망\)과 마찬가지로, 부과, 제거 및 조치를 담당하는 네트워크 장치에 대한 기본 신뢰가 있습니다. NSH 정보입니다.

다음 섹션에서는 분석을 자세히 설명하고 이 두 영역에 대한 일련의 요구 사항 및 권장 사항을 제시합니다.

---
### **8.1.  NSH Security Considerations from Operators' Environments**

```text
   Trusted Devices
```

- 운영자 환경 내의 모든 분류자, SFF 및 SF\(이하 "SFC 장치"라고 함\)는 선택되고, 조사되고, 적극적으로 유지 관리되는 것으로 가정됩니다. 따라서 해당 운영자는 이를 신뢰합니다. 이 가정은 종종 "제로 트러스트 모델"이라고 불리는 장치를 신뢰할 수 없다는 견해와 다릅니다. 운영자는 규정 준수 동작을 보장하기 위해 이러한 장치를 정기적으로 모니터링\(즉, 지속적으로 감사\)해야 합니다. 따라서 이러한 신뢰는 NSH 작업으로 확장됩니다. SFC 장치 자체는 공격 벡터로 간주되지 않습니다. 이 가정과 그에 따른 결론은 운전자 자세의 기초이기 때문에 합리적입니다. 운영자는 이러한 현실에 의존하여 기능합니다. 이러한 장치를 신뢰할 수 없고 실제로 손상되면 운영자의 표준 기반 IP 및 MPLS 프로토콜 제품군 전체가 취약해집니다. 따라서 전체 네트워크의 작동이 손상됩니다. 손상을 감지하기 위한 모니터링 기반 방법이 잘 문서화되어 있지만\(예: 지속적인 모니터링, 감사 및 로그 검토 포함\) 완전히 손상된 요소로 인한 손상을 억제하는 데 충분하지 않을 수 있습니다.\(SHOULD\)

- 장치를 보호하는 방법과 모범 사례도 널리 문서화되어 있으며 이 문서의 범위를 벗어납니다.

```text
   Single Domain Boundary
```

\[RFC7665\]에 따라 NSH는 단일 내에서 사용하도록 설계되었습니다.

- 관리 도메인. 이 범위 지정은 두 가지 중요한 특성을 제공합니다.

```text
      i) Clear NSH boundaries
```

- NSH 송신 장치는 사용자의 패킷이나 프레임을 NSH 도메인 밖으로 보내기 전에 NSH 헤더를 제거해야 합니다.\(MUST\)

- 서비스 경로의 마지막 SFF가 서비스 경로를 나가는 패킷을 전달하기 전에 NSH 캡슐화를 체계적으로 제거한다는 점을 고려하면 관리 도메인 외부로 개인정보 관련 정보 유출을 방지하는 수단은 NSH에서 기본적으로 지원됩니다.

- 이러한 예방의 두 번째 단계는 도메인 가장자리에서 NSH가 사용하는 전송 캡슐화 프로토콜을 필터링하는 것입니다. 전송 캡슐화 프로토콜은 필터링되어야 하며 도메인 가장자리를 떠나서는 안 됩니다.\(MUST NOT\)

- NSH에 사용되는 전송 캡슐화 프로토콜에 따라 이는 전송 캡슐화를 완전히 차단하거나\(예: MPLS가 선택된 NSH 전송 캡슐화 프로토콜인 경우 도메인을 떠나는 것이 절대 허용되지 않음\) 수행될 수 있습니다. 전송 캡슐화가 포함된 프로토콜\(예: VXLAN-gpe가 NSH 전송 캡슐화 프로토콜로 사용되는 경우 모든 도메인 에지는 VXLAN-gpe에서 전달되는 프로토콜을 기반으로 필터링해야 합니다.\)

- 이 경계의 또 다른 결과는 공격자가 서비스 경로 식별 및 자신이 선택한 메타데이터를 사용하여 NSH 패킷을 보내는 것을 방지하기 위해 수신 패킷도 필터링해야 한다는 것입니다. SFC 장치의 NSH와 일반 에지 보호로서 전송 캡슐화 프로토콜에 대해 위에서 설명한 것과 동일한 필터를 수신 시 적용해야 합니다.\(MUST, MUST\)

- 요약하자면, SFC 지원 도메인 외부에서 발생하는 패킷은 NSH를 포함하는 경우 삭제되어야 합니다. 마찬가지로, SFC 지원 도메인에서 나가는 패킷에 NSH가 포함되어 있으면 반드시 삭제해야 합니다.\(MUST, MUST\)

- ii\) 외부 위협 완화

- 위에서 제기한 신뢰할 수 있는 SFC 장치 지점에 따라 NSH가 운영자 도메인 내에서 범위가 지정된다는 점을 고려하면 해당 운영자는 환경 및 전이 속성이 해당 운영자에게 필요한 보안 상태를 준수하는지 확인할 수 있습니다. 완전히 신뢰할 수 있는 환경에 의존하여 보증을 위한 지속적인 감사를 권장합니다. "지속적 감사"라는 용어는 일정 기간 동안 정기적으로 보안 제어 준수 여부를 확인하는 방법\(자동 또는 수동\)을 설명합니다.

---
### **8.2.  NSH Security Considerations from the SFC Architecture**

SFC 아키텍처는 기능적 역할\(예: SFF\)과 프로토콜 요소\(예: 메타데이터\)를 정의합니다. 이 섹션에서는 무결성 및 기밀성 영역에서 발생하는 위협의 맥락에서 각 역할과 요소를 고려합니다. 라우팅과 마찬가지로 분산 계산 모델은 분산 신뢰 모델을 가정합니다.

중요한 고려 사항은 NSH에 음소거 필수 필드가 포함되어 있으며 SFC 아키텍처는 NSH의 다른 필드가 모두 가능한 SFP 홉 단위로 변경되는 경우를 설명한다는 것입니다. 이는 모든 암호화 솔루션에는 복잡한 키 배포 및 수명주기 작업이 필요하다는 것을 의미합니다.

---
#### **8.2.1.  Integrity**

```text
   SFC devices
```

- SFC 장치는 예상 장치에서 NSH 패킷만 수락하고, 예상 장치에서 수신한 NSH SPI 및 SI 값이 예상 값과 일치하는지 확인하는 등 수신된 NSH 패킷에 대해 다양한 형태의 검증을 수행할 수 있습니다. 이러한 추가 확인을 구현하는 것은 지역적인 문제이므로 이 문서의 범위를 벗어납니다.\(MAY\)

NSH 기본 및 서비스 경로 헤더

- 사업자 네트워크 내에서 패킷을 수정할 수 있는 공격자는 SFP, 경로 위치 및/또는 패킷과 관련된 메타데이터를 수정할 수 있습니다.

한 가지 구체적인 우려 사항은 악의적인 공격입니다.

- SPI/SI를 수정하면 보안 장치를 피하기 위해 경로가 변경됩니다. 이 섹션에서 논의된 옵션은 해당 공격을 막는 데 도움이 되며 선택적 "전송 증명" 방법 \[PROOF-OF-TRANSIT\]을 사용하는 것도 마찬가지입니다.

- 위에서 설명한 대로 SFC 장치는 신뢰할 수 있습니다. SFC 장치가 손상된 경우 NSH 무결성 보호도 \(많은 경우\) 위조될 수 있습니다.

NSH 자체는 프로토콜별 무결성을 요구하지 않습니다.

-  보호. 그러나 운영자가 보호가 필요하다고 판단하는 경우 몇 가지 옵션이 실행 가능합니다.

```text
      1.  SFF/SF NSH verification
```

- 엄밀히 말하면 무결성 보호는 아니지만, 예상 SFC 장치로부터 수신된 예상 NSH 값을 확인하는 등 위에서 언급한 일부 기술은 본격적인 무결성에 대한 부담을 초래하지 않고 검증 형식을 제공할 수 있습니다. 보호 배포.

```text
      2.  Transport Security
```

- NSH는 이 사양의 섹션 4에 자세히 설명되어 있고 그림 1에 설명된 대로 항상 외부 전송 캡슐화로 캡슐화됩니다. 운영자가 위험 분석으로 인해 암호화 무결성 보호가 필요하다고 간주하는 경우 이러한 보호를 제공하는 외부 전송 캡슐화 IPsec과 같은 RFC6071\]을 사용해야 합니다.\(MUST\)

- BCP 72 \[RFC3552\] 섹션 5의 위협 모델 및 권장 사항은 일반적으로 헤더에 대한 암호화 데이터 출처 인증을 요구하지만, 이 문서는 배포의 운영 및 기술 현실을 반영하기 위해 그러한 메커니즘을 요구하지 않습니다.

- 위에서 언급한 것처럼 NSH가 전송 독립적이라는 점을 고려하면 IPsec과 같은 보안 전송을 NSH 전송에 사용할 수 있습니다. IPsec은 단독으로 사용하거나 다른 전송 캡슐화 프로토콜과 함께 사용하여 NSH를 캡슐화할 수 있습니다.

- 운영자는 선택한 전송 캡슐화 프로토콜이 서비스 경로의 SFF, SF 및 SFC 프록시뿐만 아니라 모든 관련 네트워크 세그먼트의 전송 캡슐화/하위에서 지원될 수 있는지 확인해야 합니다.\(MUST\)

- SFC 지원 장치 간의 연결이 공용 인터넷을 통과하는 경우 해당 연결은 전송 캡슐화 계층에서 보호되어야 합니다. IPsec은 이러한 전송의 한 예입니다.\(MUST\)

```text
      3.  NSH Variable Header-Based Integrity
```

- 마지막으로 NSH MD Type 2는 가변 길이 헤더를 통해 NSH 패킷에 암호화 무결성 보호를 추가하는 기능을 제공합니다. 이러한 체계의 구현은 이 문서의 범위를 벗어납니다.

```text
   NSH metadata
```

- 기본 및 서비스 경로 헤더와 마찬가지로 운영자가 암호화 무결성 보호가 필요하다고 판단하는 경우 무결성 보호가 캡슐화된 전체 NSH 패킷에 적용되므로 기존 표준 전송 프로토콜을 사용해야 합니다. 위에서 언급한 것처럼 데이터 평면 트래픽이 변조될 수 있다고 간주하는 위험 평가는 NSH뿐만 아니라 전송 정보에도 적용됩니다. 따라서 전체 스택을 보호하려면 이미 보안 전송을 사용해야 할 가능성이 높습니다.\(MUST\)

- MD 유형 2 가변 헤더 무결성 체계가 있는 경우 해당 메커니즘을 통해서도 메타데이터의 무결성을 보장할 수 있습니다.

---
#### **8.2.2.  Confidentiality**

```text
   SFC devices
```

- SFC 장치는 NSH 정보를 "볼" 수 있고 사용해야 합니다.

NSH 기본 및 서비스 경로 헤더

- SPI 및 기타 기본/서비스 경로 정보는 일반적으로 기밀성을 요구하지 않습니다. 그러나 운영자가 기밀성이 필요하다고 판단하는 경우 무결성과 마찬가지로 암호화를 제공하는 기존 전송 캡슐화를 활용해야 합니다.\(MUST\)

```text
   NSH metadata
```

- 운영자 네트워크의 트래픽에 액세스할 수 있는 공격자는 잠재적으로 NSH가 패킷과 함께 전달하는 메타데이터를 관찰하여 잠재적으로 개인 정보에 민감한 정보를 발견할 수 있습니다.

- NSH가 전달하는 메타데이터의 대부분은 민감하지 않습니다. 이는 기본 패킷이나 프레임에서 파생될 수 있는 정보를 반영하는 경우가 많습니다. 위험은 단순히 기본 패킷이나 프레임을 운반하는 위험이므로 그러한 정보를 직접 보호할 필요는 없습니다.

- 구현자와 운영자는 메타데이터가 개인 정보 보호에 영향을 미칠 수 있으며 이러한 영향은 때때로 예측하기 어렵다는 점을 인식해야 합니다. 따라서 첨부된 메타데이터는 SFP의 올바른 작동에 필요한 메타데이터로 제한되어야 합니다. 또한 \[RFC8165\]에서는 운영자가 NSH를 사용할 때 고려할 수 있는 메타데이터 고려 사항을 정의합니다.\(MUST\)

- 위에서 설명한 내용에 따라 적절한 보안 기능을 갖춘 전송 캡슐화 프로토콜을 사용하여 SFC 구성 요소 간의 NSH 메타데이터 정보를 보호할 수 있습니다. 보안 분석에서 이러한 보호가 필요하다고 판단되면 전송 캡슐화 프로토콜\(예: IPsec\)의 보안 기능을 사용해야 합니다.\(MUST\)

- 민감한 메타데이터에 대한 개인 정보 보호를 제공하는 유용한 요소 중 하나는 \[RFC7665\] 보안 고려 사항의 "SFC 캡슐화" 영역에 설명되어 있습니다. 운영자는 민감한 것으로 간주되는 메타데이터\(예: 개인 식별 정보\)에 대해 간접적인 식별을 사용할 수 있고 사용해야 하며, 이를 통해 개인정보 침해 위험을 크게 줄일 수 있습니다. 특히 가입자 식별 정보는 신중하게 처리해야 하며 일반적으로 난독화해야 합니다.\(SHOULD\)

- 난독화가 적용되지 않거나 불충분하다고 판단되는 상황에서는 운영자가 메타데이터를 암호화할 수도 있습니다. 이를 수행하기 위한 선택적 기능에 대한 접근 방식은 \[NSH-ENCRYPT\]에서 탐색되었습니다. 더 큰 보증이 필요한 다른 상황에서는 \[PROOF-OF-TRANSIT\]와 같은 선택적 메커니즘을 사용할 수 있습니다.

---
## **9.  IANA Considerations**
---
### **9.1.  NSH Parameters**

IANA는 새로운 "네트워크 서비스 헤더\(NSH\) 매개변수" 레지스트리를 만들었습니다. 다음 하위 섹션에서는 "NSH\(네트워크 서비스 헤더\) 매개변수" 레지스트리 내의 새 레지스트리에 대해 자세히 설명합니다.

---
#### **9.1.1.  NSH Base Header Bits**

NSH Base Header에는 5개의 할당되지 않은 비트\(U비트\)와 1개의 할당된 비트\(O비트\)가 있습니다. 새로운 비트는 Standards Action \[RFC8126\]을 통해 할당됩니다.

```text
   Bit 2 - O (OAM) bit
   Bit 3 - Unassigned
   Bits 16-19 - Unassigned
```

---
#### **9.1.2.  NSH Version**

IANA는 "NSH 버전" 레지스트리를 설정했습니다. 표준 조치 \[RFC8126\]를 통해 새로운 값이 할당됩니다.

```text
       +-------------+---------------------------------+-----------+
       | Version     | Description                     | Reference |
       +-------------+---------------------------------+-----------+
       | Version 00b | Protocol as defined by RFC 8300 | RFC 8300  |
       | Version 01b | Reserved                        | RFC 8300  |
       | Version 10b | Unassigned                      |           |
       | Version 11b | Unassigned                      |           |
       +-------------+---------------------------------+-----------+

                           Table 5: NSH Version
```

---
#### **9.1.3.  NSH MD Types**

IANA는 4비트 값을 포함하는 "NSH MD 유형" 레지스트리를 설정했습니다. MD 유형 값 0x0, 0x1, 0x2 및 0xF가 이 문서에 지정되어 있습니다. 표 6을 참조하세요. 레지스트리 항목은 RFC 8126 \[RFC8126\]에 정의된 "IETF 검토" 정책을 통해 할당됩니다.

```text
                +-----------+-----------------+-----------+
                | MD Type   | Description     | Reference |
                +-----------+-----------------+-----------+
                | 0x0       | Reserved        | RFC 8300  |
                |           |                 |           |
                | 0x1       | NSH MD Type 1   | RFC 8300  |
                |           |                 |           |
                | 0x2       | NSH MD Type 2   | RFC 8300  |
                |           |                 |           |
                | 0x3 - 0xE | Unassigned      |           |
                |           |                 |           |
                | 0xF       | Experimentation | RFC 8300  |
                +-----------+-----------------+-----------+

                          Table 6: MD Type Values
```

---
#### **9.1.4.  NSH MD Class**

IANA는 16비트 값을 포함하는 "NSH MD 클래스" 레지스트리를 설정했습니다. 다음 정책에 따라 새로운 할당이 이루어집니다.

0x0000\~0x01ff: IETF 검토 0x0200\~0xfff5: 전문가 검토

IANA는 다음과 같이 값을 할당했습니다.

```text
        +------------------+------------------------+------------+
        | Value            | Meaning                | Reference  |
        +------------------+------------------------+------------+
        | 0x0000           | IETF Base NSH MD Class | RFC 8300   |
        |                  |                        |            |
        | 0xfff6 to 0xfffe | Experimental           | RFC 8300   |
        |                  |                        |            |
        | 0xffff           | Reserved               | RFC 8300   |
        +------------------+------------------------+------------+

                           Table 7: NSH MD Class
```

MD 클래스 0x0000의 유형에 대한 레지스트리는 섹션 9.1.5에 정의되어 있습니다.

"전문가 검토" 범위에서 새로운 할당 요청을 평가하는 지정 전문가는 기존 클래스에 MD 유형을 추가하는 것과 비교하여 새로운 MD 클래스가 필요한지 여부를 원칙적으로 고려해야 합니다. 또한 지정 전문가는 관련되어 공개적으로 표시되는 MD 유형 레지스트리의 존재를 장려해야 합니다. 비록 이 레지스트리가 IANA에 의해 유지 관리될 필요는 없지만.

할당 요청을 평가할 때 전문가는 할당 계획에 이 클래스 내에 할당될 것으로 예상되는 개별 MD 유형과 관련된 개인 정보 보호 및 보안 문제를 처리하기 위한 고려 사항이 포함되어 있는지 확인해야 합니다. 이러한 계획에서는 적절한 경우 간접, 암호화 및 제한된 배포 시나리오와 같은 대안을 고려해야 합니다. 패킷 내용을 보면 직접적으로 파생될 수 없는 정보는 개인정보 보호 및 보안에 미치는 영향을 조사해야 합니다.

---
#### **9.1.5.  NSH IETF-Assigned Optional Variable-Length Metadata Types**

IETF Base NSH MD Class 내의 Type 값, 즉 MD Class가 0x0000으로 설정된 경우\(Section 9.1.4 참조\)는 IETF가 소유한 Type입니다. 이 문서에 따라 IANA는 섹션 2.5.1에 ​​지정된 대로 "NSH IETF 할당 선택적 가변 길이 메타데이터 유형" 레지스트리라고 하는 IETF 기본 NSH MD 클래스의 유형 값에 대한 레지스트리를 만들었습니다.

유형 값은 표준 조치 \[RFC8126\]를 통해 할당됩니다.

레지스트리 생성 시 초기 값이 할당되지 않습니다.

---
#### **9.1.6.  NSH Next Protocol**

IANA는 8비트 값을 포함하는 "NSH Next Protocol" 레지스트리를 설정했습니다. 다음 프로토콜 값 0, 1, 2, 3, 4, 5가 이 문서에 정의되어 있습니다\(표 8 참조\). \[RFC8126\]에 따라 "전문가 검토"를 통해 새로운 값이 할당됩니다.

```text
               +---------------+--------------+-----------+
               | Next Protocol | Description  | Reference |
               +---------------+--------------+-----------+
               | 0x00          | Unassigned   |           |
               |               |              |           |
               | 0x01          | IPv4         | RFC 8300  |
               |               |              |           |
               | 0x02          | IPv6         | RFC 8300  |
               |               |              |           |
               | 0x03          | Ethernet     | RFC 8300  |
               |               |              |           |
               | 0x04          | NSH          | RFC 8300  |
               |               |              |           |
               | 0x05          | MPLS         | RFC 8300  |
               |               |              |           |
               | 0x06 - 0xFD   | Unassigned   |           |
               |               |              |           |
               | 0xFE          | Experiment 1 | RFC 8300  |
               |               |              |           |
               | 0xFF          | Experiment 2 | RFC 8300  |
               +---------------+--------------+-----------+

               Table 8: NSH Base Header Next Protocol Values
```

전문가 검토 요청에는 요청당 단일 코드 포인트가 포함되어야 합니다. 이 레지스트리의 새로운 할당 요청을 평가하는 지정 전문가는 8비트 값에 대한 코드 포인트의 부족 가능성을 고려하고 중복 및 문서 가용성을 모두 확인해야 합니다. Next Protocol 필드 할당의 실제 할당이 범위의 절반에 도달하면\(즉, 할당되지 않은 값이 128개 있는 경우\) IANA는 IESG에 경고해야 합니다. 그 시점에서는 더욱 엄격한 새로운 할당 정책을 고려해야 합니다.\(MUST, SHOULD\)

---
## **10.  NSH-Related Codepoints**
---
### **10.1.  NSH Ethertype**

NSH에는 IEEE Ethertype, 0x894F가 할당되었습니다.

---
## **11.  References**
---
### **11.1.  Normative References**

```text
   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", BCP 14, RFC 2119,
              DOI 10.17487/RFC2119, March 1997,
              <https://www.rfc-editor.org/info/rfc2119>.

   [RFC7665]  Halpern, J., Ed. and C. Pignataro, Ed., "Service Function
              Chaining (SFC) Architecture", RFC 7665,
              DOI 10.17487/RFC7665, October 2015,
              <https://www.rfc-editor.org/info/rfc7665>.

   [RFC8126]  Cotton, M., Leiba, B., and T. Narten, "Guidelines for
              Writing an IANA Considerations Section in RFCs", BCP 26,
              RFC 8126, DOI 10.17487/RFC8126, June 2017,
              <https://www.rfc-editor.org/info/rfc8126>.

   [RFC8174]  Leiba, B., "Ambiguity of Uppercase vs Lowercase in RFC
              2119 Key Words", BCP 14, RFC 8174, DOI 10.17487/RFC8174,
              May 2017, <https://www.rfc-editor.org/info/rfc8174>.
```

---
### **11.2.  Informative References**

\[NSH-광대역-할당\]

- Napper, J., Kumar, S., Muley, P., Henderickx, W. 및 M. Boucadair, "NSH 컨텍스트 헤더 할당 - 광대역", 진행 중인 작업,draft-napper-sfc-nsh-broadband- 할당-04, 2017년 11월.

\[NSH-DC-할당\]

- Guichard, J., Smith, M., Kumar, S., Majee, S., Agarwal, P., Glavin, K., Laribi, Y. 및 T. Mizrahi, "네트워크 서비스 헤더\(NSH\) MD 유형 1: 컨텍스트 헤더 할당\(데이터 센터\)", 진행 중인 작업, 초안-guichard-sfc-nsh-dc-allocation-07, 2017년 8월.

\[NSH-암호화\]

- Reddy, T., Patil, P., Fluhrer, S. 및 P. Quinn, "인증 및 암호화된 NSH 서비스 체인", 진행 중인 작업, 초안-reddy-sfc-nsh-encrypt-00, 2015년 4월.

\[교통 증명서\]

- Brockners, F., Bhandari, S., Dara, S., Pignataro, C., Leddy, J., Youell, S., Mozes, D. 및 T. Mizrahi, "교통 증명", 진행 중인 작업 , Draft-Brockners-Proof-of-Transit-04, 2017년 10월.

```text
   [RFC2784]  Farinacci, D., Li, T., Hanks, S., Meyer, D., and P.
              Traina, "Generic Routing Encapsulation (GRE)", RFC 2784,
              DOI 10.17487/RFC2784, March 2000,
              <https://www.rfc-editor.org/info/rfc2784>.

   [RFC3552]  Rescorla, E. and B. Korver, "Guidelines for Writing RFC
              Text on Security Considerations", BCP 72, RFC 3552,
              DOI 10.17487/RFC3552, July 2003,
              <https://www.rfc-editor.org/info/rfc3552>.

   [RFC3692]  Narten, T., "Assigning Experimental and Testing Numbers
              Considered Useful", BCP 82, RFC 3692,
              DOI 10.17487/RFC3692, January 2004,
              <https://www.rfc-editor.org/info/rfc3692>.

   [RFC6071]  Frankel, S. and S. Krishnan, "IP Security (IPsec) and
              Internet Key Exchange (IKE) Document Roadmap", RFC 6071,
              DOI 10.17487/RFC6071, February 2011,
              <https://www.rfc-editor.org/info/rfc6071>.

   [RFC6291]  Andersson, L., van Helvoort, H., Bonica, R., Romascanu,
              D., and S. Mansfield, "Guidelines for the Use of the "OAM"
              Acronym in the IETF", BCP 161, RFC 6291,
              DOI 10.17487/RFC6291, June 2011,
              <https://www.rfc-editor.org/info/rfc6291>.

   [RFC7325]  Villamizar, C., Ed., Kompella, K., Amante, S., Malis, A.,
              and C. Pignataro, "MPLS Forwarding Compliance and
              Performance Requirements", RFC 7325, DOI 10.17487/RFC7325,
              August 2014, <https://www.rfc-editor.org/info/rfc7325>.

   [RFC7498]  Quinn, P., Ed. and T. Nadeau, Ed., "Problem Statement for
              Service Function Chaining", RFC 7498,
              DOI 10.17487/RFC7498, April 2015,
              <https://www.rfc-editor.org/info/rfc7498>.

   [RFC7676]  Pignataro, C., Bonica, R., and S. Krishnan, "IPv6 Support
              for Generic Routing Encapsulation (GRE)", RFC 7676,
              DOI 10.17487/RFC7676, October 2015,
              <https://www.rfc-editor.org/info/rfc7676>.

   [RFC8165]  Hardie, T., "Design Considerations for Metadata
              Insertion", RFC 8165, DOI 10.17487/RFC8165, May 2017,
              <https://www.rfc-editor.org/info/rfc8165>.

   [RFC8201]  McCann, J., Deering, S., Mogul, J., and R. Hinden, Ed.,
              "Path MTU Discovery for IP version 6", STD 87, RFC 8201,
              DOI 10.17487/RFC8201, July 2017,
              <https://www.rfc-editor.org/info/rfc8201>.
```

\[RTG-ENCAP\]

- Nordmark, E., Tian, ​​A., Gross, J., Hudson, J., Kreeger, L., Garg, P., Thaler, P. 및 T. Herbert, "캡슐화 고려 사항", 진행 중인 작업, 초안-ietf-rtgwg-dt-encap-02, 2016년 10월.

\[SFC-제어판\]

- Boucadair, M., "SFC\(서비스 기능 체인\) 제어 플레인 구성 요소 및 요구 사항", 진행 중인 작업, 초안-ietf-sfc-control-plane-08, 2016년 10월.

\[SFC-OAM-프레임워크\]

- Aldrin, S., Pignataro, C., Kumar, N., Akiya, N., Krishnan, R. 및 A. Ghanwani, "서비스 기능 체인\(SFC\) 운영, 관리 및 유지 관리\(OAM\) 프레임워크", 작업 진행 중,draft-ietf-sfc-oam-framework-03, 2017년 9월.

\[VXLAN-GPE\]

- Maino, F., Kreeger, L. 및 U. Elzur, "VXLAN을 위한 일반 프로토콜 확장", 진행 중인 작업, 초안-ietf-nvo3-vxlan-gpe-05, 2017년 10월.

---
# **Acknowledgments**

저자들은 자세한 리뷰, 의견 및 기여에 대해 Sunil Vallamkonda, Nagaraj Bagepalli, Abhijit Patra, Peter Bosch, Darrel Lewis, Pritesh Kothari, Tal Mizrahi 및 Ken Gray에게 감사의 말씀을 전하고 싶습니다.

지도와 피드백을 주신 David Ward와 Tom Edsall에게 특별히 감사드립니다.

또한 저자는 이 문서 전체에 반영된 귀중한 아이디어와 기여에 대해 Larry Kreeger에게 감사를 표하고 싶습니다.

Loa Andersson은 철저한 검토와 귀중한 의견을 제공했습니다. 우리는 그에게 감사드립니다.

Reinaldo Penno는 프로토콜 개념과 설계를 안내하는 데 도움이 된 아키텍처 및 구현 작업에 대해 특별한 감사를 받을 자격이 있습니다.

편집자들은 또한 Med Boucadair, Adrian Farrel, Juergen Schoenwaelder, Acee Lindem 및 Kathleen Moriarty의 포괄적인 리뷰와 각각의 유용한 제안을 인정합니다.

마지막으로 David Dolson은 이 문서의 발전 과정 전반에 걸쳐 중요한 검토, 피드백 및 제안을 제공했습니다. 그의 기여는 매우 높이 평가됩니다.

---
# **Contributors**

이 WG 문서는draft-quinn-sfc-nsh로 작성되었습니다. 다음은 WG 채택 당시 공동저자와 기여자 및 각자의 소속입니다. 이 문서의 편집자들은 그들과 그들의 기여에 감사하고 표창하고 싶습니다. 이러한 공동저자와 기여자들은 이 문서 작성에 귀중한 개념과 내용을 제공했습니다.

```text
   o  Jim Guichard, Cisco Systems, Inc.
   o  Surendra Kumar, Cisco Systems, Inc.
   o  Michael Smith, Cisco Systems, Inc.
   o  Wim Henderickx, Alcatel-Lucent
   o  Tom Nadeau, Brocade
   o  Puneet Agarwal
   o  Rajeev Manur, Broadcom
   o  Abhishek Chauhan, Citrix
   o  Joel Halpern, Ericsson
   o  Sumandra Majee, F5
   o  David Melman, Marvell
   o  Pankaj Garg, Microsoft
   o  Brad McConnell, Rackspace
   o  Chris Wright, Red Hat, Inc.
   o  Kevin Glavin, Riverbed
   o  Hong (Cathy) Zhang, Huawei US R&D
   o  Louis Fourie, Huawei US R&D
   o  Ron Parker, Affirmed Networks
   o  Myo Zarny, Goldman Sachs
   o  Andrew Dolganow, Alcatel-Lucent
   o  Rex Fernando, Cisco Systems, Inc.
   o  Praveen Muley, Alcatel-Lucent
   o  Navindra Yadav, Cisco Systems, Inc.
```

---
# **Authors' Addresses**

```text
   Paul Quinn (editor)
   Cisco Systems, Inc.

   Email: paulq@cisco.com

   Uri Elzur (editor)
   Intel

   Email: uri.elzur@intel.com

   Carlos Pignataro (editor)
   Cisco Systems, Inc.

   Email: cpignata@cisco.com
```


```text
Network Working Group                                         S. Shepler
Request for Comments: 3530                                  B. Callaghan
Obsoletes: 3010                                              D. Robinson
Category: Standards Track                                     R. Thurlow
                                                  Sun Microsystems, Inc.
                                                                C. Beame
                                                        Hummingbird Ltd.
                                                               M. Eisler
                                                               D. Noveck
                                                 Network Appliance, Inc.
                                                              April 2003

              Network File System (NFS) version 4 Protocol
```

---
# **Status of this Memo**

이 문서는 인터넷 커뮤니티를 위한 인터넷 표준 추적 프로토콜을 지정하고 개선을 위한 토론 및 제안을 요청합니다. 이 프로토콜의 표준화 상태 및 상태에 대해서는 "Internet Official Protocol Standards"\(STD 1\) 최신판을 참조하십시오. 이 메모의 배포는 무제한입니다.

---
# **Copyright Notice**

저작권\(C\)인터넷학회\(2003\). 판권 소유.

---
# **Abstract**

NFS\(네트워크 파일 시스템\) 버전 4는 NFS 프로토콜 버전 2\(RFC 1094\) 및 버전 3\(RFC 1813\)을 계승한 분산 파일 시스템 프로토콜입니다. 이전 버전과 달리 NFS 버전 4 프로토콜은 다음을 통합하는 동시에 기존 파일 액세스를 지원합니다. 파일 잠금 및 마운트 프로토콜. 또한 강력한 보안\(및 협상\), 복합 작업, 클라이언트 캐싱 및 국제화에 대한 지원이 추가되었습니다. 물론 NFS 버전 4가 인터넷 환경에서 잘 동작하도록 하는 데에도 관심이 쏠렸다.

이 문서는 NFS 버전 4 프로토콜의 정의로 RFC 3010을 대체합니다.

---
# **Key Words**

이 문서에서 키워드 "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY" 및 "OPTIONAL"은 다음과 같습니다. \[RFC2119\]에 설명된 대로 해석됩니다.\(MUST NOT\)

---
# **Table of Contents**

```text
   1.   Introduction . . . . . . . . . . . . . . . . . . . . . . .    8
        1.1.  Changes since RFC 3010 . . . . . . . . . . . . . . .    8
        1.2.  NFS version 4 Goals. . . . . . . . . . . . . . . . .    9
        1.3.  Inconsistencies of this Document with Section 18 . .    9
        1.4.  Overview of NFS version 4 Features . . . . . . . . .   10
              1.4.1.  RPC and Security . . . . . . . . . . . . . .   10
              1.4.2.  Procedure and Operation Structure. . . . . .   10
              1.4.3.  Filesystem Mode. . . . . . . . . . . . . . .   11
                      1.4.3.1.  Filehandle Types . . . . . . . . .   11
                      1.4.3.2.  Attribute Types. . . . . . . . . .   12
                      1.4.3.3.  Filesystem Replication and
                                Migration. . . . . . . . . . . . .   13
              1.4.4.  OPEN and CLOSE . . . . . . . . . . . . . . .   13
              1.4.5.  File locking . . . . . . . . . . . . . . . .   13
              1.4.6.  Client Caching and Delegation. . . . . . . .   13
        1.5.  General Definitions. . . . . . . . . . . . . . . . .   14
   2.   Protocol Data Types. . . . . . . . . . . . . . . . . . . .   16
        2.1.  Basic Data Types . . . . . . . . . . . . . . . . . .   16
        2.2.  Structured Data Types. . . . . . . . . . . . . . . .   18
   3.   RPC and Security Flavor. . . . . . . . . . . . . . . . . .   23
        3.1.  Ports and Transports . . . . . . . . . . . . . . . .   23
              3.1.1.  Client Retransmission Behavior . . . . . . .   24
        3.2.  Security Flavors . . . . . . . . . . . . . . . . . .   25
              3.2.1.  Security mechanisms for NFS version 4. . . .   25
                      3.2.1.1.  Kerberos V5 as a security triple .   25
                      3.2.1.2.  LIPKEY as a security triple. . . .   26
                      3.2.1.3.  SPKM-3 as a security triple. . . .   27
        3.3.  Security Negotiation . . . . . . . . . . . . . . . .   27
              3.3.1.  SECINFO. . . . . . . . . . . . . . . . . . .   28
              3.3.2.  Security Error . . . . . . . . . . . . . . .   28
        3.4.  Callback RPC Authentication. . . . . . . . . . . . .   28
   4.  Filehandles . . . . . . . . . . . . . . . . . . . . . . . .   30
        4.1.  Obtaining the First Filehandle . . . . . . . . . . .   30
              4.1.1.  Root Filehandle. . . . . . . . . . . . . . .   31
              4.1.2.  Public Filehandle. . . . . . . . . . . . . .   31
        4.2.  Filehandle Types . . . . . . . . . . . . . . . . . .   31
              4.2.1.  General Properties of a Filehandle . . . . .   32
              4.2.2.  Persistent Filehandle. . . . . . . . . . . .   32
              4.2.3.  Volatile Filehandle. . . . . . . . . . . . .   33
              4.2.4.  One Method of Constructing a
                      Volatile Filehandle. . . . . . . . . . . . .   34
        4.3.  Client Recovery from Filehandle Expiration . . . . .   35
   5.   File Attributes. . . . . . . . . . . . . . . . . . . . . .   35
        5.1.  Mandatory Attributes . . . . . . . . . . . . . . . .   37
        5.2.  Recommended Attributes . . . . . . . . . . . . . . .   37
        5.3.  Named Attributes . . . . . . . . . . . . . . . . . .   37
        5.4.  Classification of Attributes . . . . . . . . . . . .   38
        5.5.  Mandatory Attributes - Definitions . . . . . . . . .   39
        5.6.  Recommended Attributes - Definitions . . . . . . . .   41
        5.7.  Time Access. . . . . . . . . . . . . . . . . . . . .   46
        5.8.  Interpreting owner and owner_group . . . . . . . . .   47
        5.9.  Character Case Attributes. . . . . . . . . . . . . .   49
        5.10. Quota Attributes . . . . . . . . . . . . . . . . . .   49
        5.11. Access Control Lists . . . . . . . . . . . . . . . .   50
               5.11.1.  ACE type . . . . . . . . . . . . . . . . .   51
               5.11.2.  ACE Access Mask. . . . . . . . . . . . . .   52
               5.11.3.  ACE flag . . . . . . . . . . . . . . . . .   54
               5.11.4.  ACE who  . . . . . . . . . . . . . . . . .   55
               5.11.5.  Mode Attribute . . . . . . . . . . . . . .   56
               5.11.6.  Mode and ACL Attribute . . . . . . . . . .   57
               5.11.7.  mounted_on_fileid. . . . . . . . . . . . .   57
   6.  Filesystem Migration and Replication  . . . . . . . . . . .   58
        6.1.  Replication. . . . . . . . . . . . . . . . . . . . .   58
        6.2.  Migration. . . . . . . . . . . . . . . . . . . . . .   59
        6.3.  Interpretation of the fs_locations Attribute . . . .   60
        6.4.  Filehandle Recovery for Migration or Replication . .   61
   7.  NFS Server Name Space . . . . . . . . . . . . . . . . . . .   61
        7.1.  Server Exports . . . . . . . . . . . . . . . . . . .   61
        7.2.  Browsing Exports . . . . . . . . . . . . . . . . . .   62
        7.3.  Server Pseudo Filesystem . . . . . . . . . . . . . .   62
        7.4.  Multiple Roots . . . . . . . . . . . . . . . . . . .   63
        7.5.  Filehandle Volatility. . . . . . . . . . . . . . . .   63
        7.6.  Exported Root. . . . . . . . . . . . . . . . . . . .   63
        7.7.  Mount Point Crossing . . . . . . . . . . . . . . . .   63
        7.8.  Security Policy and Name Space Presentation. . . . .   64
   8.   File Locking and Share Reservations. . . . . . . . . . . .   65
        8.1.  Locking. . . . . . . . . . . . . . . . . . . . . . .   65
              8.1.1.    Client ID. . . . . . . . . . . . . . . . .   66
              8.1.2.    Server Release of Clientid . . . . . . . .   69
              8.1.3.    lock_owner and stateid Definition. . . . .   69
              8.1.4.    Use of the stateid and Locking . . . . . .   71
              8.1.5.    Sequencing of Lock Requests. . . . . . . .   73
              8.1.6.    Recovery from Replayed Requests. . . . . .   74
              8.1.7.    Releasing lock_owner State . . . . . . . .   74
              8.1.8.    Use of Open Confirmation . . . . . . . . .   75
        8.2.  Lock Ranges. . . . . . . . . . . . . . . . . . . . .   76
        8.3.  Upgrading and Downgrading Locks. . . . . . . . . . .   76
        8.4.  Blocking Locks . . . . . . . . . . . . . . . . . . .   77
        8.5.  Lease Renewal. . . . . . . . . . . . . . . . . . . .   77
        8.6.  Crash Recovery . . . . . . . . . . . . . . . . . . .   78
               8.6.1.   Client Failure and Recovery. . . . . . . .   79
               8.6.2.   Server Failure and Recovery. . . . . . . .   79
               8.6.3.   Network Partitions and Recovery. . . . . .   81
        8.7.   Recovery from a Lock Request Timeout or Abort . . .   85
        8.8.   Server Revocation of Locks. . . . . . . . . . . . .   85
        8.9.   Share Reservations. . . . . . . . . . . . . . . . .   86
        8.10.  OPEN/CLOSE Operations . . . . . . . . . . . . . . .   87
               8.10.1.  Close and Retention of State
                        Information. . . . . . . . . . . . . . . .   88
        8.11.  Open Upgrade and Downgrade. . . . . . . . . . . . .   88
        8.12.  Short and Long Leases . . . . . . . . . . . . . . .   89
        8.13.  Clocks, Propagation Delay, and Calculating Lease
               Expiration. . . . . . . . . . . . . . . . . . . . .   89
        8.14.  Migration, Replication and State. . . . . . . . . .   90
               8.14.1.  Migration and State. . . . . . . . . . . .   90
               8.14.2.  Replication and State. . . . . . . . . . .   91
               8.14.3.  Notification of Migrated Lease . . . . . .   92
               8.14.4.  Migration and the Lease_time Attribute . .   92
   9.  Client-Side Caching . . . . . . . . . . . . . . . . . . . .   93
        9.1.   Performance Challenges for Client-Side Caching. . .   93
        9.2.   Delegation and Callbacks. . . . . . . . . . . . . .   94
               9.2.1.  Delegation Recovery . . . . . . . . . . . .   96
        9.3.   Data Caching. . . . . . . . . . . . . . . . . . . .   98
               9.3.1.   Data Caching and OPENs . . . . . . . . . .   98
               9.3.2.   Data Caching and File Locking. . . . . . .   99
               9.3.3.   Data Caching and Mandatory File Locking. .  101
               9.3.4.   Data Caching and File Identity . . . . . .  101
        9.4.   Open Delegation . . . . . . . . . . . . . . . . . .  102
               9.4.1.   Open Delegation and Data Caching . . . . .  104
               9.4.2.   Open Delegation and File Locks . . . . . .  106
               9.4.3.   Handling of CB_GETATTR . . . . . . . . . .  106
               9.4.4.   Recall of Open Delegation. . . . . . . . .  109
               9.4.5.   Clients that Fail to Honor
                        Delegation Recalls . . . . . . . . . . . .  111
               9.4.6.   Delegation Revocation. . . . . . . . . . .  112
        9.5.   Data Caching and Revocation . . . . . . . . . . . .  112
               9.5.1.   Revocation Recovery for Write Open
                        Delegation . . . . . . . . . . . . . . . .  113
        9.6.   Attribute Caching . . . . . . . . . . . . . . . . .  113
        9.7.   Data and Metadata Caching and Memory Mapped Files .  115
        9.8.   Name Caching  . . . . . . . . . . . . . . . . . . .  118
        9.9.   Directory Caching . . . . . . . . . . . . . . . . .  119
   10.  Minor Versioning . . . . . . . . . . . . . . . . . . . . .  120
   11.  Internationalization . . . . . . . . . . . . . . . . . . .  122
        11.1.  Stringprep profile for the utf8str_cs type. . . . .  123
               11.1.1.  Intended applicability of the
                        nfs4_cs_prep profile . . . . . . . . . . .  123
               11.1.2.  Character repertoire of nfs4_cs_prep . . .  124
               11.1.3.  Mapping used by nfs4_cs_prep . . . . . . .  124
               11.1.4.  Normalization used by nfs4_cs_prep . . . .  124
               11.1.5.  Prohibited output for nfs4_cs_prep . . . .  125
               11.1.6.  Bidirectional output for nfs4_cs_prep. . .  125
        11.2.  Stringprep profile for the utf8str_cis type . . . .  125
               11.2.1.  Intended applicability of the
                        nfs4_cis_prep profile. . . . . . . . . . .  125
               11.2.2.  Character repertoire of nfs4_cis_prep  . .  125
               11.2.3.  Mapping used by nfs4_cis_prep  . . . . . .  125
               11.2.4.  Normalization used by nfs4_cis_prep  . . .  125
               11.2.5.  Prohibited output for nfs4_cis_prep  . . .  126
               11.2.6.  Bidirectional output for nfs4_cis_prep . .  126
        11.3.  Stringprep profile for the utf8str_mixed type . . .  126
               11.3.1.  Intended applicability of the
                        nfs4_mixed_prep profile. . . . . . . . . .  126
               11.3.2.  Character repertoire of nfs4_mixed_prep  .  126
               11.3.3.  Mapping used by nfs4_cis_prep  . . . . . .  126
               11.3.4.  Normalization used by nfs4_mixed_prep  . .  127
               11.3.5.  Prohibited output for nfs4_mixed_prep  . .  127
               11.3.6.  Bidirectional output for nfs4_mixed_prep .  127
        11.4.  UTF-8 Related Errors. . . . . . . . . . . . . . . .  127
   12.  Error Definitions  . . . . . . . . . . . . . . . . . . . .  128
   13.  NFS version 4 Requests . . . . . . . . . . . . . . . . . .  134
        13.1.  Compound Procedure. . . . . . . . . . . . . . . . .  134
        13.2.  Evaluation of a Compound Request. . . . . . . . . .  135
        13.3.  Synchronous Modifying Operations. . . . . . . . . .  136
        13.4.  Operation Values. . . . . . . . . . . . . . . . . .  136
   14.  NFS version 4 Procedures . . . . . . . . . . . . . . . . .  136
        14.1.  Procedure 0: NULL - No Operation. . . . . . . . . .  136
        14.2.  Procedure 1: COMPOUND - Compound Operations . . . .  137
               14.2.1.   Operation 3: ACCESS - Check Access
                         Rights. . . . . . . . . . . . . . . . . .  140
               14.2.2.   Operation 4: CLOSE - Close File . . . . .  142
               14.2.3.   Operation 5: COMMIT - Commit
                         Cached Data . . . . . . . . . . . . . . .  144
               14.2.4.   Operation 6: CREATE - Create a
                         Non-Regular File Object . . . . . . . . .  147
               14.2.5.   Operation 7: DELEGPURGE -
                         Purge Delegations Awaiting Recovery . . .  150
               14.2.6.   Operation 8: DELEGRETURN - Return
                         Delegation. . . . . . . . . . . . . . . .  151
               14.2.7.   Operation 9: GETATTR - Get Attributes . .  152
               14.2.8.   Operation 10: GETFH - Get Current
                         Filehandle. . . . . . . . . . . . . . . .  153
               14.2.9.   Operation 11: LINK - Create Link to a
                         File. . . . . . . . . . . . . . . . . . .  154
               14.2.10.  Operation 12: LOCK - Create Lock  . . . .  156
               14.2.11.  Operation 13: LOCKT - Test For Lock . . .  160
               14.2.12.  Operation 14: LOCKU - Unlock File . . . .  162
               14.2.13.  Operation 15: LOOKUP - Lookup Filename. .  163
               14.2.14.  Operation 16: LOOKUPP - Lookup
                         Parent Directory. . . . . . . . . . . . .  165
               14.2.15.  Operation 17: NVERIFY - Verify
                         Difference in Attributes  . . . . . . . .  166
               14.2.16.  Operation 18: OPEN - Open a Regular
                         File. . . . . . . . . . . . . . . . . . .  168
               14.2.17.  Operation 19: OPENATTR - Open Named
                         Attribute Directory . . . . . . . . . . .  178
               14.2.18.  Operation 20: OPEN_CONFIRM -
                         Confirm Open . . . . . . . . . . . . . .   180
               14.2.19.  Operation 21: OPEN_DOWNGRADE -
                         Reduce Open File Access . . . . . . . . .  182
               14.2.20.  Operation 22: PUTFH - Set
                         Current Filehandle. . . . . . . . . . . .  184
               14.2.21.  Operation 23: PUTPUBFH -
                         Set Public Filehandle . . . . . . . . . .  185
               14.2.22.  Operation 24: PUTROOTFH -
                         Set Root Filehandle . . . . . . . . . . .  186
               14.2.23.  Operation 25: READ - Read from File . . .  187
               14.2.24.  Operation 26: READDIR -
                         Read Directory. . . . . . . . . . . . . .  190
               14.2.25.  Operation 27: READLINK -
                         Read Symbolic Link. . . . . . . . . . . .  193
               14.2.26.  Operation 28: REMOVE -
                         Remove Filesystem Object. . . . . . . . .  195
               14.2.27.  Operation 29: RENAME -
                         Rename Directory Entry. . . . . . . . . .  197
               14.2.28.  Operation 30: RENEW - Renew a Lease . . .  200
               14.2.29.  Operation 31: RESTOREFH -
                         Restore Saved Filehandle. . . . . . . . .  201
               14.2.30.  Operation 32: SAVEFH - Save
                         Current Filehandle. . . . . . . . . . . .  202
               14.2.31.  Operation 33: SECINFO - Obtain
                         Available Security. . . . . . . . . . . .  203
               14.2.32.  Operation 34: SETATTR - Set Attributes. .  206
               14.2.33.  Operation 35: SETCLIENTID -
                         Negotiate Clientid. . . . . . . . . . . .  209
               14.2.34.  Operation 36: SETCLIENTID_CONFIRM -
                         Confirm Clientid. . . . . . . . . . . . .  213
               14.2.35.  Operation 37: VERIFY -
                         Verify Same Attributes. . . . . . . . . .  217
               14.2.36.  Operation 38: WRITE - Write to File . . .  218
               14.2.37.  Operation 39: RELEASE_LOCKOWNER -
                         Release Lockowner State . . . . . . . . .  223
               14.2.38.  Operation 10044: ILLEGAL -
                         Illegal operation . . . . . . . . . . . .  224
   15.  NFS version 4 Callback Procedures  . . . . . . . . . . . .  225
        15.1.  Procedure 0: CB_NULL - No Operation . . . . . . . .  225
        15.2.  Procedure 1: CB_COMPOUND - Compound
               Operations. . . . . . . . . . . . . . . . . . . . .  226
               15.2.1.  Operation 3: CB_GETATTR - Get
                        Attributes . . . . . . . . . . . . . . . .  228
               15.2.2.  Operation 4: CB_RECALL -
                        Recall an Open Delegation. . . . . . . . .  229
               15.2.3.  Operation 10044: CB_ILLEGAL -
                        Illegal Callback Operation . . . . . . . .  230
   16.  Security Considerations  . . . . . . . . . . . . . . . . .  231
   17.  IANA Considerations  . . . . . . . . . . . . . . . . . . .  232
        17.1.  Named Attribute Definition. . . . . . . . . . . . .  232
        17.2.  ONC RPC Network Identifiers (netids). . . . . . . .  232
   18.  RPC definition file  . . . . . . . . . . . . . . . . . . .  234
   19.  Acknowledgements . . . . . . . . . . . . . . . . . . . . .  268
   20.  Normative References . . . . . . . . . . . . . . . . . . .  268
   21.  Informative References . . . . . . . . . . . . . . . . . .  270
   22.  Authors' Information . . . . . . . . . . . . . . . . . . .  273
        22.1.  Editor's Address. . . . . . . . . . . . . . . . . .  273
        22.2.  Authors' Addresses. . . . . . . . . . . . . . . . .  274
   23.  Full Copyright Statement . . . . . . . . . . . . . . . . .  275
```

---
## **1.  Introduction**
---
### **1.1.  Changes since RFC 3010**

NFS 버전 4 프로토콜의 이 정의는 \[RFC3010\]에 있는 정의를 대체하거나 폐기합니다. 두 문서의 일부는 동일하게 유지되었지만 다른 문서에는 실질적인 변경이 있었습니다. \[RFC3010\]과 이 문서 사이의 변경 사항은 구현 경험과 프로토콜에 대한 추가 검토를 나타냅니다. 구현이나 설명을 쉽게 하기 위해 일부 수정이 이루어졌지만 대부분의 업데이트는 \[RFC3010\] 정의를 유지할 수 없는 오류나 상황을 나타냅니다.

다음 목록은 모든 변경 사항을 모두 포함하지는 않지만 가장 주목할만한 변경 사항이나 추가 사항 중 일부를 제시합니다.

o 상태 모델에 open\_owner4 식별자가 추가되었습니다. 이는 Posix 기반 클라이언트와 파일 잠금에 사용하는 모델을 수용하기 위해 수행되었습니다. Posix 클라이언트의 경우 open\_owner4는 프로세스 집합 간에 잠재적으로 공유되는 파일 설명자에 해당하고 lock\_owner4 식별자는 파일을 잠그는 프로세스에 해당합니다.

o 소유자 및 그룹 속성 처리에 대한 설명 및 오류 조건이 추가되었습니다. 이러한 속성은 문자열 기반이므로\(이전 NFS 버전의 숫자 uid/gid와 반대\) 번역이 불가능할 수 있으므로 변경이 이루어집니다.

o ACL 및 모드 속성에 대한 설명

- 평가 및 부분 지원.

o XDR 불투명으로 정의된 식별자의 경우 크기 제한이 설정되었습니다.

o Posix 클라이언트가 로컬 마운트를 올바르게 구성할 수 있도록 Mounted\_on\_filed 속성을 추가했습니다.

o 새 클라이언트 콜백 정보를 지정하는 기능을 추가하는 동시에 확인 세부 정보를 올바르게 처리하도록 SETCLIENTID/SETCLIENTID\_CONFIRM 작업을 수정했습니다. 또한 콜백 정보 자체에 대한 설명도 추가되었습니다.

o 클라이언트가 lock\_owner4를 더 이상 사용하지 않을 것임을 서버에 알릴 수 있는 새로운 작업 LOCKOWNER\_RELEASE를 추가했습니다.

o RENEW 작업은 클라이언트를 올바르게 식별하고 추가 오류 반환을 허용하도록 변경됩니다.

o 모든 작업에 대한 오류 반환 가능성을 확인합니다.

o 동일한 효과를 얻기 위해 클라이언트가 일련의 LOOKUP 작업을 구성하도록 하기 위해 LOOKUP 및 OPEN에서 pathname4 데이터 유형의 사용을 제거합니다.

o 국제화 문제를 명확히 하고 새로운 stringprep 프로필 프레임워크를 채택했습니다.

---
### **1.2.  NFS Version 4 Goals**

NFS 버전 4 프로토콜은 버전 2 \[RFC1094\] 및 3 \[RFC1813\]에서 이미 정의된 NFS 프로토콜의 추가 개정판입니다. 이는 이전 버전의 필수 특성\(손쉬운 복구를 위한 설계, 전송 프로토콜, 운영 체제 및 파일 시스템에 무관함, 단순성 및 우수한 성능\)을 유지합니다. NFS 버전 4 개정판의 목표는 다음과 같습니다.

o 인터넷 접속이 향상되고 성능이 향상됩니다.

- 이 프로토콜은 방화벽을 쉽게 통과하고 대기 시간이 길고 대역폭이 낮은 곳에서 잘 작동하며 서버당 매우 많은 수의 클라이언트로 확장되도록 설계되었습니다.

o 프로토콜에 내장된 협상을 통해 강력한 보안을 제공합니다.

- 이 프로토콜은 RPCSEC\_GSS 프로토콜을 지원하는 ONCRPC 작업 그룹의 작업을 기반으로 구축되었습니다. 또한 NFS 버전 4 프로토콜은 클라이언트와 서버가 보안을 협상할 수 있도록 하고 클라이언트와 서버가 최소한의 보안 체계 집합을 지원하도록 요구하는 메커니즘을 제공합니다.

```text
   o  Good cross-platform interoperability.
```

- 프로토콜은 하나의 파일 시스템이나 운영 체제를 다른 파일 시스템이나 운영 체제보다 과도하게 선호하지 않는 유용하고 공통된 기능 세트를 제공하는 파일 시스템 모델을 특징으로 합니다.

o 프로토콜 확장을 위해 설계되었습니다.

- 프로토콜은 이전 버전과의 호환성을 손상시키지 않는 표준 확장을 허용하도록 설계되었습니다.

---
### **1.3.  Inconsistencies of this Document with Section 18**

섹션 18, RPC 정의 파일에는 프로토콜에서 사용되는 구성의 XDR 설명 언어 정의가 포함되어 있습니다. 섹션 18 이전에는 여러 가지 구성이 목적을 위해 재현되었습니다.

설명의. 독자는 섹션 18 외부에서 재현된 구성에 오류가 있을 수 있다는 경고를 받습니다. 섹션 18, 섹션 18과 일치하지 않는 문서의 모든 부분은 권위 있는 것으로 간주됩니다.

---
### **1.4.  Overview of NFS version 4 Features**

독자에게 합리적인 맥락을 제공하기 위해 NFS 버전 4 프로토콜의 주요 기능을 간략하게 검토합니다. 이는 이전 버전의 NFS 프로토콜에 익숙한 독자와 NFS 프로토콜을 처음 접하는 독자 모두에게 적절한 컨텍스트를 제공하기 위해 수행됩니다. NFS 프로토콜을 처음 접하는 독자에게는 여전히 기본적인 지식이 필요합니다. 독자는 \[RFC1831\] 및 \[RFC1832\]에 설명된 XDR 및 RPC 프로토콜에 익숙해야 합니다. 파일 시스템과 분산 파일 시스템에 대한 기본 지식도 필요합니다.

---
#### **1.4.1.  RPC and Security**

이전 버전의 NFS와 마찬가지로 NFS 버전 4 프로토콜에 사용되는 XDR\(External Data Representation\) 및 RPC\(Remote Procedure Call\) 메커니즘은 \[RFC1831\] 및 \[RFC1832\]에 정의되어 있습니다. 종단 간 보안 요구 사항을 충족하기 위해 RPCSEC\_GSS 프레임워크 \[RFC2203\]를 사용하여 기본 RPC 보안을 확장합니다. RPCSEC\_GSS를 사용하면 NFS 버전 4 프로토콜에 인증, 무결성 및 개인정보 보호를 제공하기 위한 다양한 메커니즘이 제공될 수 있습니다. Kerberos V5는 \[RFC1964\]에 설명된 대로 사용되어 하나의 보안 프레임워크를 제공합니다. \[RFC2847\]에 설명된 LIPKEY GSS-API 메커니즘은 NFS 버전 4 프로토콜에 의해 사용자 비밀번호 및 서버 공개 키의 사용을 제공하는 데 사용됩니다. RPCSEC\_GSS를 사용하면 NFS 버전 4 보안을 위해 다른 메커니즘을 지정하고 사용할 수도 있습니다.

대역 내 보안 협상을 활성화하기 위해 NFS 버전 4 프로토콜은 서버의 파일 시스템 리소스에 액세스하기 위해 사용해야 하는 보안 메커니즘과 관련된 정책에 대해 서버에 쿼리하는 방법을 클라이언트에 제공하는 새로운 작업을 추가했습니다. 이를 통해 클라이언트는 클라이언트와 서버 모두에 지정된 정책을 충족하는 보안 메커니즘을 안전하게 일치시킬 수 있습니다.

---
#### **1.4.2.  Procedure and Operation Structure**

NFS 프로토콜의 이전 버전과 크게 다른 점은 COMPOUND 프로시저의 도입입니다. NFS 버전 4 프로토콜의 경우 NULL과 COMPOUND라는 두 가지 RPC 프로시저가 있습니다. COMPOUND 프로시저는 작업 측면에서 정의되며 이러한 작업은 기존 NFS 프로시저에 더 가깝습니다.

COMPOUND 프로시저를 사용하면 클라이언트는 단순하거나 복잡한 요청을 작성할 수 있습니다. 이러한 COMPOUND 요청을 사용하면 논리적 파일 시스템 작업에 필요한 RPC 수를 줄일 수 있습니다. 예를 들어, 클라이언트는 이전에 서버에 접속하지 않고도 단일 COMPOUND RPC에서 LOOKUP, OPEN 및 READ 작업을 결합하여 한 번의 요청으로 파일에서 데이터를 읽을 수 있습니다. 이전 버전의 NFS 프로토콜에서는 이러한 유형의 단일 요청이 불가능했습니다.

COMPOUND에 사용되는 모델은 매우 간단합니다. 논리적 OR 또는 AND 연산은 없습니다. COMPOUND 요청 내에 결합된 작업은 서버에서 순서대로 평가됩니다. 작업이 실패한 결과를 반환하면 평가가 종료되고 평가된 모든 작업의 ​​결과가 클라이언트에 반환됩니다.

NFS 버전 4 프로토콜은 계속해서 클라이언트가 "파일 핸들"을 통해 서버의 파일이나 디렉터리를 참조하도록 합니다. COMPOUND 프로시저에는 작업 시퀀스 내에서 한 작업에서 다른 작업으로 파일 핸들을 전달하는 방법이 있습니다. "현재 파일 핸들"과 "저장된 파일 핸들"이라는 개념이 있습니다. 대부분의 작업은 작업할 파일 시스템 개체로 "현재 파일 핸들"을 사용합니다. "저장된 파일 핸들"은 COMPOUND 프로시저 내의 임시 파일 핸들 저장소뿐만 아니라 특정 작업을 위한 추가 피연산자로 사용됩니다.

---
#### **1.4.3.  Filesystem Model**

NFS 버전 4 프로토콜에 사용되는 일반 파일 시스템 모델은 이전 버전과 동일합니다. 서버 파일 시스템은 불투명한 바이트 스트림으로 처리되는 일반 파일이 포함된 계층 구조입니다. 약간 다른 점은 파일 및 디렉터리 이름이 국제화의 기본 사항을 처리하기 위해 UTF-8로 인코딩된다는 점입니다.

NFS 버전 4 프로토콜에는 경로 이름과 파일 핸들 간의 초기 매핑을 제공하기 위해 별도의 프로토콜이 필요하지 않습니다. 이 매핑에 이전 MOUNT 프로토콜을 사용하는 대신 서버는 서버에서 제공하는 파일 시스템 트리의 논리적 루트 또는 최상위를 나타내는 ROOT 파일 핸들을 제공합니다. 서버는 의사 파일 시스템과 함께 결합하여 여러 파일 시스템을 제공합니다. 이러한 의사 파일 시스템은 실제 파일 시스템 간의 경로 이름에 잠재적인 차이를 제공합니다.

---
##### **1.4.3.1.  Filehandle Types**

이전 버전의 NFS 프로토콜에서는 서버가 제공하는 파일 핸들이 참조하는 파일 시스템 객체의 수명 동안 유효하거나 지속되는 것으로 보장되었습니다. 일부 서버 구현의 경우 이러한 지속성 요구 사항이 적용되기 어려웠습니다.

만나다. NFS 버전 4 프로토콜의 경우 다른 유형의 파일 핸들인 휘발성을 도입하여 이 요구 사항을 완화했습니다. 지속적이고 일시적인 파일 핸들 유형을 사용하면 서버 구현이 운영 환경과 함께 서버의 파일 시스템 기능과 일치할 수 있습니다. 클라이언트는 서버가 제공하는 파일 핸들 유형에 대한 지식을 갖게 되며 각각의 의미를 처리할 준비를 할 수 있습니다.

---
##### **1.4.3.2.  Attribute Types**

NFS 버전 4 프로토콜에는 세 가지 클래스의 파일 시스템 또는 파일 속성이 도입되었습니다. 추가 파일 핸들 유형과 마찬가지로 NFS 프로토콜의 전체 기능 확장과 함께 서버 구현을 쉽게 하기 위해 파일 속성 분류가 수행되었습니다. 이 속성 모델은 상당한 재작업 없이도 프로토콜의 사소한 개정에 새로운 속성을 도입할 수 있도록 확장 가능하도록 구성되어 있습니다.

세 가지 분류는 필수, 권장 및 명명된 속성입니다. 이는 NFS 프로토콜에 사용된 이전 속성 모델과 크게 다릅니다. 이전에는 파일 시스템 및 파일 객체의 속성이 주로 UNIX 속성의 고정 세트였습니다. 서버나 클라이언트가 특정 속성을 지원하지 않는 경우 해당 속성을 최대한 시뮬레이션해야 합니다.

필수 속성은 서버에서 제공해야 하고 서버에서 적절하게 표시해야 하는 최소 파일 또는 파일 시스템 속성 집합입니다. 권장 속성은 다양한 파일 시스템 유형과 운영 환경을 나타냅니다. 권장되는 속성을 사용하면 상호 운용성이 향상되고 더 많은 운영 환경을 포함할 수 있습니다. 필수 및 권장 속성 세트는 기존 파일 또는 파일 시스템 속성입니다. 세 번째 유형의 속성은 명명된 속성입니다. 명명된 속성은 디렉터리나 파일과 연결되고 문자열 이름으로 참조되는 불투명 바이트 스트림입니다. 명명된 속성은 클라이언트 응용 프로그램에서 응용 프로그램별 데이터를 일반 파일 또는 디렉터리와 연결하는 방법으로 사용하기 위한 것입니다.

권장되는 파일 속성 세트에 추가된 중요한 추가 기능 중 하나는 ACL\(액세스 제어 목록\) 속성입니다. 이 속성은 이전 버전의 NFS 프로토콜에서 사용된 모델 이상의 디렉터리 및 파일 액세스 제어를 제공합니다. ACL 정의를 통해 사용자 및 그룹 수준 액세스 제어를 지정할 수 있습니다.

---
##### **1.4.3.3.  Filesystem Replication and Migration**

특별한 파일 속성을 사용하면 프로토콜 내에서 서버 파일 시스템을 마이그레이션하거나 복제하는 기능이 활성화됩니다. 파일 시스템 위치 속성은 클라이언트가 파일 시스템의 위치에 대해 서버를 조사하는 방법을 제공합니다. 파일 시스템을 마이그레이션하는 경우 클라이언트는 파일 시스템에서 작동할 때 오류를 수신한 다음 새 파일 시스템 위치에 대해 쿼리할 수 있습니다. 복제에도 유사한 단계가 사용되며, 클라이언트는 특정 파일 시스템의 사용 가능한 여러 위치에 대해 서버에 쿼리할 수 있습니다. 이 정보를 통해 클라이언트는 자체 정책을 사용하여 적절한 파일 시스템 위치에 액세스할 수 있습니다.

---
#### **1.4.4.  OPEN and CLOSE**

NFS 버전 4 프로토콜에는 OPEN 및 CLOSE 작업이 도입되었습니다. OPEN 작업은 파일 조회, 생성 및 공유 의미 체계를 결합할 수 있는 단일 지점을 제공합니다. CLOSE 작업은 OPEN에 의해 ​​누적된 상태의 해제도 제공합니다.

---
#### **1.4.5.  File locking**

NFS 버전 4 프로토콜의 경우 바이트 범위 파일 잠금 지원은 NFS 프로토콜의 일부입니다. 파일 잠금 지원은 RPC 콜백 메커니즘이 필요하지 않도록 구성되어 있습니다. 이는 NFS 파일 잠금 프로토콜인 NLM\(Network Lock Manager\)의 이전 버전과 다릅니다. 파일 잠금과 관련된 상태는 임대 기반 모델에 따라 서버에서 유지됩니다. 서버는 NFS 클라이언트가 보유한 모든 상태에 대해 단일 임대 기간을 정의합니다. 클라이언트가 정의된 기간 내에 임대를 갱신하지 않으면 클라이언트의 임대와 관련된 모든 상태가 서버에 의해 해제될 수 있습니다. 클라이언트는 RENEW 작업을 사용하거나 다른 작업\(주로 READ\)을 사용하여 암시적으로 임대를 갱신할 수 있습니다.

---
#### **1.4.6.  Client Caching and Delegation**

NFS 버전 4 프로토콜의 파일, 속성 및 디렉터리 캐싱은 이전 버전과 유사합니다. 속성과 디렉터리 정보는 클라이언트가 결정한 기간 동안 캐시됩니다. 미리 정의된 시간 초과가 끝나면 클라이언트는 서버에 쿼리하여 관련 파일 시스템 개체가 업데이트되었는지 확인합니다.

파일 데이터의 경우 클라이언트는 파일이 열릴 때 캐시 유효성을 확인합니다. 파일이 변경되었는지 확인하기 위해 쿼리가 서버로 전송됩니다. 이 정보를 기반으로 클라이언트는 파일에 대한 데이터 캐시를 보관해야 할지 아니면 해제해야 할지 결정합니다. 또한 파일이 닫히면 수정된 데이터가 서버에 기록됩니다.

애플리케이션이 파일 데이터에 대한 액세스를 직렬화하려는 경우 문제의 파일 데이터 범위에 대한 파일 잠금을 사용해야 합니다.

캐싱 영역에서 NFS 버전 4에 추가된 주요 기능은 서버가 특정 책임을 클라이언트에 위임하는 기능입니다. 서버가 클라이언트에게 파일에 대한 위임을 부여하면 클라이언트는 해당 파일을 다른 클라이언트와 공유하는 것과 관련하여 특정 의미를 보장받습니다. OPEN 시 서버는 클라이언트에게 파일에 대한 읽기 또는 쓰기 위임을 제공할 수 있습니다. 클라이언트에게 읽기 위임이 부여되면 위임 기간 동안 다른 클라이언트가 파일에 쓸 수 있는 권한이 없음이 보장됩니다. 클라이언트에게 쓰기 위임이 부여되면 클라이언트는 다른 클라이언트가 파일에 대한 읽기 또는 쓰기 액세스 권한을 갖고 있지 않음을 확신합니다.

위임은 서버에서 회수될 수 있습니다. 다른 클라이언트가 부여된 위임과 액세스가 충돌하는 방식으로 파일에 대한 액세스를 요청하는 경우 서버는 초기 클라이언트에게 알리고 위임을 회수할 수 있습니다. 이를 위해서는 서버와 클라이언트 사이에 콜백 경로가 존재해야 합니다. 이 콜백 경로가 존재하지 않으면 위임을 부여할 수 없습니다. 위임의 본질은 클라이언트가 서버와의 즉각적인 상호 작용 없이 OPEN, CLOSE, LOCK, LOCKU, READ, WRITE와 같은 작업을 로컬에서 서비스할 수 있도록 하는 것입니다.

---
### **1.5.  General Definitions**

다음 정의는 독자에게 적절한 맥락을 제공할 목적으로 제공됩니다.

클라이언트 "클라이언트"는 NFS 서버의 리소스에 액세스하는 엔터티입니다. 클라이언트는 NFS 서버에 직접 액세스하는 논리를 포함하는 애플리케이션일 수 있습니다. 클라이언트는 일련의 애플리케이션에 대한 기존 운영 체제 클라이언트 원격 파일 시스템 서비스일 수도 있습니다.

- 파일 잠금의 경우 클라이언트는 하나 이상의 애플리케이션을 대신하여 잠금 세트를 유지 관리하는 엔터티입니다. 이 클라이언트는 자신이 관리하는 잠금에 대한 충돌 또는 오류 복구를 담당합니다.

- 여러 클라이언트가 동일한 전송을 공유할 수 있으며 여러 클라이언트가 동일한 네트워크 노드에 존재할 수 있습니다.

클라이언트 ID 클라이언트가 제공한 검증 도구 및 ID에 대한 고유한 간략한 참조로 사용되는 64비트 수량입니다. 서버는 클라이언트 ID 제공을 담당합니다.

임대 클라이언트에 취소할 수 없는 잠금이 부여되는 서버에서 정의한 시간 간격입니다. 임대 기간 종료 시 임대 기간이 연장되지 않은 경우 잠금이 취소될 수 있습니다. 임대 간격 이후 충돌하는 잠금이 부여된 경우 잠금을 취소해야 합니다.

서버에서 부여한 모든 임대에는 동일한 고정 값이 있습니다.

-         간격. 고정 간격은 서버 장애 시 가변 길이 임대에 대한 상태를 유지하는 데 드는 비용을 줄이기 위해 선택되었습니다.

잠금 "잠금"이라는 용어는 별도로 명시하지 않는 한 레코드\(바이트 범위\) 잠금과 공유 예약을 모두 지칭하는 데 사용됩니다.

서버 "서버"는 파일 시스템 집합에 대한 클라이언트 액세스를 조정하는 일을 담당하는 개체입니다.

안정적인 저장

- NFS 버전 4 서버는 다중 정전\(연속 정전, 즉 빠르게 연속되는 여러 정전 포함\), 운영 체제 장애, 저장 매체 자체 이외의 구성 요소의 하드웨어 장애로부터 데이터 손실 없이 복구할 수 있어야 합니다\( 예를 들어 디스크, 비휘발성 RAM\).

- NFS 서버에 허용되는 안정적인 저장소의 몇 가지 예는 다음과 같습니다.

- 1. 데이터의 미디어 커밋, 즉 수정된 데이터가 디스크 미디어\(예: 디스크 플래터\)에 성공적으로 기록되었습니다.

- 2. 배터리 지원 온드라이브 중간 스토리지 또는 무정전 전원 시스템\(UPS\)을 갖춘 즉시 응답 디스크 드라이브.

- 3. 배터리 지원 중간 저장 및 복구 소프트웨어를 사용하여 서버에서 데이터를 커밋합니다.

- 4. 무정전 전원 시스템\(UPS\) 및 복구 소프트웨어를 사용한 캐시 커밋.

Stateid 특정 파일에 대한 특정 열기 또는 잠금 소유자에 대해 서버에서 제공하는 열기 및 잠금 상태를 고유하게 정의하는 서버에서 반환된 128비트 수량입니다.

- 모든 비트 0 또는 모든 비트 1로 구성된 Stateid는 특별한 의미를 가지며 예약된 값입니다.

검증자 클라이언트가 다시 시작되었고 이전 잠금 상태가 모두 손실되었는지 확인하는 데 서버가 사용할 수 있는 클라이언트가 생성한 64비트 수량입니다.

---
## **2.  Protocol Data Types**

NFS 버전 4 프로토콜의 데이터 유형을 설명하는 구문과 의미는 XDR \[RFC1832\] 및 RPC \[RFC1831\] 문서에 정의되어 있습니다. 다음 섹션에서는 XDR 데이터 유형을 기반으로 이 프로토콜에 특정한 유형과 구조를 정의합니다.

---
### **2.1.  Basic Data Types**

```text
   Data Type       Definition
   ____________________________________________________________________
   int32_t         typedef int             int32_t;

   uint32_t        typedef unsigned int    uint32_t;

   int64_t         typedef hyper           int64_t;

   uint64_t        typedef unsigned hyper  uint64_t;

   attrlist4       typedef opaque        attrlist4<>;
                   Used for file/directory attributes
```

bitmap4 typedef uint32\_t bitmap4<\>;

- 속성 배열 인코딩에 사용됩니다.

```text
   changeid4       typedef       uint64_t        changeid4;
                   Used in definition of change_info

   clientid4       typedef uint64_t        clientid4;
                   Shorthand reference to client identification

   component4      typedef utf8str_cs      component4;
                   Represents path name components

   count4          typedef uint32_t        count4;
                   Various count parameters (READ, WRITE, COMMIT)

   length4         typedef uint64_t        length4;
                   Describes LOCK lengths

   linktext4       typedef utf8str_cs      linktext4;
                   Symbolic link contents

   mode4           typedef uint32_t        mode4;
                   Mode attribute data type

   nfs_cookie4     typedef uint64_t        nfs_cookie4;
                   Opaque cookie value for READDIR

   nfs_fh4         typedef opaque          nfs_fh4<NFS4_FHSIZE>;
                   Filehandle definition; NFS4_FHSIZE is defined as 128

   nfs_ftype4      enum nfs_ftype4;
                   Various defined file types

   nfsstat4        enum nfsstat4;
                   Return value for operations

   offset4         typedef uint64_t        offset4;
                   Various offset designations (READ, WRITE,
                   LOCK, COMMIT)

   pathname4       typedef component4      pathname4<>;
                   Represents path name for LOOKUP, OPEN and others

   qop4            typedef uint32_t        qop4;
                   Quality of protection designation in SECINFO
```

sec\_oid4 typedef 불투명 sec\_oid4<\>;

- 보안 개체 식별자 sec\_oid4 데이터 유형은 실제로 불투명하지 않습니다. 대신 GSS\_Init\_sec\_context에 대한 mech\_type 인수에 GSS-API가 사용하는 ASN.1 OBJECT IDENTIFIER가 포함되어 있습니다. 자세한 내용은 \[RFC2743\]을 참조하세요.

```text
   seqid4          typedef uint32_t        seqid4;
                   Sequence identifier used for file locking

   utf8string      typedef opaque          utf8string<>;
                   UTF-8 encoding for strings

   utf8str_cis     typedef opaque          utf8str_cis;
                   Case-insensitive UTF-8 string

   utf8str_cs      typedef opaque          utf8str_cs;
                   Case-sensitive UTF-8 string
```

utf8str\_mixed typedef 불투명 utf8str\_mixed;

- 대소문자를 구분하는 접두사와 대소문자를 구분하지 않는 접미사가 있는 UTF-8 문자열입니다.

verifier4 typedef 불투명 verifier4\[NFS4\_VERIFIER\_SIZE\]; 다양한 작업\(COMMIT, CREATE, OPEN, READDIR, SETCLIENTID, SETCLIENTID\_CONFIRM, WRITE\)에 사용되는 검증자 NFS4\_VERIFIER\_SIZE는 8로 정의됩니다.

---
### **2.2.  Structured Data Types**

```text
   nfstime4
                  struct nfstime4 {
                          int64_t seconds;
                          uint32_t nseconds;
                  }
```

nfstime4 구조는 1970년 1월 1일 협정 세계시\(UTC\) 자정 또는 0시 이후의 초 및 나노초 수를 제공합니다. 초 필드의 0보다 큰 값은 1970년 1월 1일 0시 이후의 날짜를 나타냅니다. 초 필드의 0보다 작은 값은 1970년 1월 1일 0시 이전의 날짜를 나타냅니다. 두 경우 모두 nseconds 필드가 추가됩니다. 최종 시간 표현을 위한 초 필드입니다. 예를 들어, 표시할 시간이 1970년 1월 1일 0시 이전 0.5초인 경우 초 필드의 값은 음수 1\(-1\)이고 nseconds 필드의 값은 0.5초\( 500000000\). n초 동안 999,999,999보다 큰 값은 유효하지 않은 것으로 간주됩니다.

이 데이터 유형은 시간 및 날짜 정보를 전달하는 데 사용됩니다. 서버는 시간 값을 처리할 때 로컬 시간 표현으로 변환하고 가능한 한 많은 정확도를 유지합니다. 파일 시스템 객체에 대해 저장된 타임스탬프의 정밀도가 정의된 것보다 낮으면 정밀도 손실이 발생할 수 있습니다. 클라이언트 및 서버 시간 차이를 줄이려면 보조 시간 유지 관리 프로토콜이 권장됩니다.

```text
   time_how4

                  enum time_how4 {
                          SET_TO_SERVER_TIME4 = 0,
                          SET_TO_CLIENT_TIME4 = 1
                  };

   settime4

                  union settime4 switch (time_how4 set_it) {
                   case SET_TO_CLIENT_TIME4:
                           nfstime4       time;
                   default:
                           void;
                  };
```

위의 정의는 시간 값을 설정하기 위한 속성 정의로 사용됩니다. set\_it가 SET\_TO\_SERVER\_TIME4이면 서버는 시간 값에 대한 로컬 시간 표현을 사용합니다.

```text
   specdata4

                  struct specdata4 {
                          uint32_t specdata1; /* major device number */
                          uint32_t specdata2; /* minor device number */
                  };
```

이 데이터 유형은 장치 파일 유형 NF4CHR 및 NF4BLK에 대한 추가 정보를 나타냅니다.

```text
   fsid4

                  struct fsid4 {
                    uint64_t        major;
                    uint64_t        minor;
                  };
```

이 유형은 필수 속성으로 사용되는 파일 시스템 식별자입니다.

```text
   fs_location4

                  struct fs_location4 {
                          utf8str_cis    server<>;
                          pathname4     rootpath;
                  };

   fs_locations4

                  struct fs_locations4 {
                          pathname4     fs_root;
                          fs_location4  locations<>;
                  };
```

fs\_location4 및 fs\_locations4 데이터 유형은 마이그레이션 및 복제 지원에 사용되는 fs\_locations 권장 속성에 사용됩니다.

```text
   fattr4

                  struct fattr4 {
                          bitmap4       attrmask;
                          attrlist4     attr_vals;
                  };
```

fattr4 구조는 파일 및 디렉터리 속성을 나타내는 데 사용됩니다.

비트맵은 비트 값을 포함하는 데 사용되는 32비트 정수의 계산된 배열입니다. 비트 n을 포함하는 배열의 정수 위치는 \(n / 32\) 표현식으로 계산할 수 있으며 해당 정수 내의 비트는 \(n mod 32\)입니다.

```text
                           0            1
         +-----------+-----------+-----------+--
         |  count    | 31  ..  0 | 63  .. 32 |
         +-----------+-----------+-----------+--

   change_info4

                  struct change_info4 {
                          bool          atomic;
                          changeid4     before;
                          changeid4     after;
                  };
```

이 구조는 CREATE, LINK, REMOVE, RENAME 작업과 함께 사용되어 클라이언트가 대상 파일 시스템 개체가 있는 디렉터리에 대한 변경 속성 값을 알 수 있도록 합니다.

```text
   clientaddr4

                  struct clientaddr4 {
                          /* see struct rpcb in RFC 1833 */
                          string r_netid<>;    /* network id */
                          string r_addr<>;     /* universal address */
                  };
```

clientaddr4 구조는 clientid를 사용하는 클라이언트의 주소를 지정하거나 콜백 등록의 일부로 SETCLIENTID 작업의 일부로 사용됩니다. 그만큼

r\_netid 및 r\_addr 필드는 \[RFC1833\]에 지정되어 있지만 특정 프로토콜에 대해 어떻게 표시되어야 하는지에 대해서는 \[RFC1833\]에 과소 지정되어 있습니다.

IPv4를 통한 TCP 및 IPv4를 통한 UDP의 경우 r\_addr의 형식은 US-ASCII 문자열입니다.

```text
      h1.h2.h3.h4.p1.p2
```

접두사 "h1.h2.h3.h4"는 IPv4 주소를 나타내는 표준 텍스트 형식으로 길이는 항상 4옥텟입니다. 빅엔디안 순서로 가정하면 h1, h2, h3, h4는 각각 첫 번째부터 네 번째 옥텟까지 ASCII 십진수로 변환됩니다. 빅엔디안 순서를 가정하면 p1과 p2는 각각 ASCII 십진수로 변환된 첫 번째와 두 번째 옥텟입니다. 예를 들어, 빅엔디안 순서의 호스트 주소가 0x0A010307이고 빅엔디안 순서의 포트 0x020F\(10진수 527\)를 수신 대기하는 서비스가 있는 경우 전체 범용 주소는 "10.1.3.7.2.15입니다. ".

IPv4를 통한 TCP의 경우 r\_netid 값은 "tcp" 문자열입니다. IPv4를 통한 UDP의 경우 r\_netid 값은 "udp" 문자열입니다.

IPv6을 통한 TCP 및 IPv6을 통한 UDP의 경우 r\_addr의 형식은 US-ASCII 문자열입니다.

```text
         x1:x2:x3:x4:x5:x6:x7:x8.p1.p2
```

접미사 "p1.p2"는 서비스 포트이며 IPv4를 통한 TCP 및 UDP의 범용 주소와 동일한 방식으로 계산됩니다. 접두사 "x1:x2:x3:x4:x5:x6:x7:x8"은 \[RFC2373\]의 섹션 2.2에 정의된 대로 IPv6 주소를 나타내는 표준 텍스트 형식입니다. 또한 \[RFC2373\]의 섹션 2.2에 지정된 두 가지 대체 형식도 허용됩니다.

IPv6을 통한 TCP의 경우 r\_netid 값은 "tcp6" 문자열입니다. IPv6을 통한 UDP의 경우 r\_netid 값은 "udp6" 문자열입니다.

```text
   cb_client4

                  struct cb_client4 {
                          unsigned int  cb_program;
                          clientaddr4   cb_location;
                  };
```

이 구조는 클라이언트가 서버에 콜백 주소를 알리는 데 사용됩니다. 프로그램 번호와 클라이언트 주소가 포함됩니다.

```text
   nfs_client_id4

                  struct nfs_client_id4 {
                          verifier4     verifier;
                          opaque        id<NFS4_OPAQUE_LIMIT>;
                  };
```

이 구조는 SETCLIENTID 작업에 대한 인수의 일부입니다. NFS4\_OPAQUE\_LIMIT는 1024로 정의됩니다.

```text
   open_owner4

                  struct open_owner4 {
                          clientid4     clientid;
                          opaque        owner<NFS4_OPAQUE_LIMIT>;
                  };
```

이 구조는 열린 상태의 소유자를 식별하는 데 사용됩니다. NFS4\_OPAQUE\_LIMIT는 1024로 정의됩니다.

```text
   lock_owner4

                  struct lock_owner4 {
                          clientid4     clientid;
                          opaque        owner<NFS4_OPAQUE_LIMIT>;
                  };
```

이 구조는 파일 잠금 상태의 소유자를 식별하는 데 사용됩니다. NFS4\_OPAQUE\_LIMIT는 1024로 정의됩니다.

```text
   open_to_lock_owner4

                  struct open_to_lock_owner4 {
                          seqid4          open_seqid;
                          stateid4        open_stateid;
                          seqid4          lock_seqid;
                          lock_owner4     lock_owner;
                  };
```

이 구조는 open\_owner4에 대해 수행된 첫 번째 LOCK 작업에 사용됩니다. 유효한 open\_stateid 시퀀스에서 새로운 lock\_stateid 시퀀스로 전환이 이루어지도록 open\_stateid와 lock\_owner를 모두 제공합니다. 이 메커니즘을 사용하면 open\_stateid/open\_seqid 형식으로 설정된 상태에 연결되어 있으므로 lock\_owner/lock\_seqid 쌍의 확인을 피할 수 있습니다.

```text
   stateid4

                  struct stateid4 {
                    uint32_t        seqid;
                    opaque          other[12];
                  };
```

이 구조는 클라이언트와 서버 간의 다양한 상태 공유 메커니즘에 사용됩니다. 클라이언트의 경우 이 데이터 구조는 읽기 전용입니다. seqid 필드의 시작 값이 정의되지 않았습니다. 서버는 stateid가 전환될 때마다 seqid 필드를 단조롭게 증가시켜야 합니다. 클라이언트는 OPEN stateid의 seqid를 검사하여 서버에서 수행되는 OPEN 처리 순서를 결정하므로 이는 중요합니다.

---
## **3.  RPC and Security Flavor**

NFS 버전 4 프로토콜은 \[RFC1831\] 및 \[RFC1832\]에 정의된 대로 RPC 버전 2와 해당 XDR\(eXternal Data Representation\)을 사용하는 RPC\(원격 프로시저 호출\) 애플리케이션입니다. \[RFC2203\]에 정의된 RPCSEC\_GSS 보안 특성은 NFS 버전 4 프로토콜에 대해 더 강력한 보안을 제공하는 메커니즘으로 사용해야 합니다.\(MUST\)

---
### **3.1.  Ports and Transports**

역사적으로 NFS 버전 2 및 버전 3 서버는 포트 2049에 상주했습니다. NFS 프로토콜에 대해 등록된 포트 2049 \[RFC3232\]가 기본 구성이어야 합니다. NFS 서비스에 등록된 포트를 사용한다는 것은 NFS 클라이언트가 \[RFC1833\]에 설명된 대로 RPC 바인딩 프로토콜을 사용할 필요가 없음을 의미합니다. 이렇게 하면 NFS가 방화벽을 통과할 수 있습니다.

NFS 버전 4 구현이 IP 네트워크 프로토콜을 통한 작업을 지원하는 경우 NFS와 IP 간에 지원되는 전송은 TCP 및 SCTP를 포함하는 IETF 승인 혼잡 제어 전송 프로토콜 중 하나여야 합니다. 상호 운용성의 가능성을 높이기 위해 NFS 버전 4 구현은 적어도 표준 트랙 RFC가 다른 IETF 승인 혼잡 제어 전송 프로토콜을 사용하도록 이 요구 사항을 개정할 때까지 TCP 전송 프로토콜을 통한 작업을 지원해야 합니다.\(MUST, MUST\)

TCP가 전송 수단으로 사용되는 경우 클라이언트와 서버는 영구 연결을 사용해야 합니다. 이는 단기간 연결을 통해 TCP의 혼잡 제어가 약화되는 것을 방지하고 SYN 핸드셰이크의 필요성을 제거하여 WAN 환경의 성능을 향상시킵니다.\(SHOULD\)

보안 고려 사항 섹션에서 설명한 대로 NFS 버전 4의 인증 모델은 시스템 기반에서 주체 기반으로 이동했습니다. 그러나 인증 모델의 이러한 수정은 TCP 연결 관리 모델을 전체 시스템 기반에서 사용자별 모델 기반으로 이동하기 위한 기술적 요구 사항을 의미하지 않습니다. 특히 TCP를 통한 NFS 클라이언트 구현은 전통적으로 NFS 클라이언트와 서버 간의 공통 TCP 연결을 통해 여러 사용자에 대한 트래픽을 다중화했습니다. NFS 클라이언트가 AUTH\_SYS, AUTH\_DH, RPCSEC\_GSS 또는 다른 유형을 사용하는지 여부에 관계없이 이는 사실입니다. 마찬가지로 TCP를 통한 NFS 서버 구현에서는 이러한 모델을 가정하고 예상되는 클라이언트 시스템 수에 비례하여 TCP 연결 관리 구현을 확장합니다. NFS 버전 4는 이 연결 관리 모델을 수정하지 않도록 의도되었습니다. 이 가정을 위반하는 NFS 버전 4 클라이언트는 서버에서 확장 문제가 발생하여 서비스가 감소할 수 있습니다.

다양한 타이머의 경우 클라이언트와 서버는 해당 타이머의 부주의한 동기화를 방지해야 합니다. 일반적인 문제에 대한 자세한 논의는 \[Floyd\]를 참조하세요.

---
#### **3.1.1.  Client Retransmission Behavior**

TCP와 같은 신뢰할 수 있는 전송을 통해 수신된 요청을 처리할 때 NFS 버전 4 서버는 전송 연결이 끊어진 경우를 제외하고 요청을 자동으로 삭제해서는 안 됩니다. NFS 버전 4 클라이언트와 서버 간의 계약이 주어지면 클라이언트는 다음 중 하나 또는 둘 모두가 참이 아닌 한 요청을 재시도해서는 안 됩니다.\(MUST NOT, MUST NOT\)

o 전송 연결이 끊어졌습니다.

o 재시도 중인 프로시저가 NULL 프로시저입니다.

TCP와 같은 신뢰할 수 있는 전송은 다른 피어가 연결을 끊었을 때\(예: NFS 서버가 재부팅되는 경우\) 피어에게 항상 동기적으로 알리지 않으므로 NFS 버전 4 클라이언트는 연결을 적극적으로 "탐색"하여 확인하려고 할 수 있습니다. 깨진 경우. NULL 프로시저를 사용하는 것이 권장되는 방법 중 하나입니다. 따라서 클라이언트가 원격 프로시저 호출 시간 초과\(임의의 구현 특정 양\)를 경험하는 경우 원격 프로시저 호출을 다시 시도하는 대신 서버에 NULL 프로시저 호출을 실행할 수 있습니다. 서버가 중단된 경우 전송 연결 중단은 결국 NFS 버전 4 클라이언트에 표시됩니다. 그런 다음 클라이언트는 다시 연결한 다음 원래 요청을 다시 시도할 수 있습니다. NULL 프로시저 호출이 응답을 받으면 연결이 끊어지지 않은 것입니다. 클라이언트는 원래 요청의 응답을 더 오래 기다리기로 결정할 수도 있고, 원래 요청을 다시 보내기 전에 전송 연결을 끊고 다시 연결할 수도 있습니다.

서버에서 클라이언트로의 콜백에도 동일한 규칙이 적용되지만 콜백을 수행하는 서버가 클라이언트가 되고 콜백을 받는 클라이언트가 서버가 됩니다.

---
### **3.2.  Security Flavors**

기존 RPC 구현에는 보안 특성으로 AUTH\_NONE, AUTH\_SYS, AUTH\_DH 및 AUTH\_KRB4가 포함되었습니다. \[RFC2203\]에서는 GSS-API \[RFC2743\]의 기능을 사용하는 RPCSEC\_GSS의 추가 보안 기능이 도입되었습니다. 이를 통해 RPC 보안 기능을 추가하는 추가 구현 오버헤드 없이 RPC 계층에서 다양한 보안 메커니즘을 사용할 수 있습니다. NFS 버전 4의 경우 필수 보안 메커니즘을 활성화하려면 RPCSEC\_GSS 보안 특성을 사용해야 합니다. AUTH\_NONE, AUTH\_SYS 및 AUTH\_DH와 같은 다른 특징도 구현될 수 있습니다.\(MUST, MAY\)

---
#### **3.2.1.  Security mechanisms for NFS version 4**

RPCSEC\_GSS를 사용하려면 메커니즘, 보호 품질 및 서비스\(인증, 무결성, 개인 정보 보호\)를 선택해야 합니다. 이 문서의 나머지 부분에서는 RPCSEC\_GSS 보안의 세 가지 매개변수를 보안 트리플로 참조합니다.

---
##### **3.2.1.1.  Kerberos V5 as a security triple**

\[RFC1964\]에 설명된 Kerberos V5 GSS-API 메커니즘은 반드시 구현되어야 하며 다음 보안 트리플을 제공해야 합니다.\(MUST\)

```text
   column descriptions:
```

1 == 유사 플레이버의 수 2 == 유사 플레이버의 이름 3 == 메커니즘의 OID 4 == 메커니즘의 알고리즘 5 == RPCSEC\_GSS 서비스

```text
   1      2     3                    4             5
   --------------------------------------------------------------------
   390003 krb5  1.2.840.113554.1.2.2 DES MAC MD5   rpc_gss_svc_none
   390004 krb5i 1.2.840.113554.1.2.2 DES MAC MD5   rpc_gss_svc_integrity
   390005 krb5p 1.2.840.113554.1.2.2 DES MAC MD5   rpc_gss_svc_privacy
                                     for integrity,
                                     and 56 bit DES
                                     for privacy.
```

여기에서는 의사 풍미가 구현자에 대한 매핑 지원으로 제공됩니다. 이 NFS 프로토콜에는 보안 협상 방법이 포함되어 있고 GSS-API 메커니즘을 이해하고 있기 때문에

의사 맛은 필요하지 않습니다. 보안 협상이 MOUNT 프로토콜을 통해 수행되므로 NFS 버전 3에는 의사 플레이버가 필요합니다.

NFS의 RPCSEC\_GSS 및 Kerberos V5 사용에 대한 논의는 \[RFC2623\]을 참조하세요.

사용자와 구현자는 56비트 DES가 무차별 대입 공격에 대한 저항 측면에서 더 이상 최첨단 기술로 간주되지 않는다는 경고를 받습니다. AES에 대한 지원을 추가하는 \[RFC1964\] 개정판이 제공되면 구현자는 Kerberos V5 프로토콜 스택을 통해 NFSv4에 AES를 통합해야 하며 사용자는 마찬가지로 AES 사용으로 마이그레이션해야 합니다.

---
##### **3.2.1.2.  LIPKEY as a security triple**

```text
   The LIPKEY GSS-API mechanism as described in [RFC2847] MUST be
   implemented and provide the following security triples.  The
   definition of the columns matches the previous subsection "Kerberos
   V5 as security triple"

   1      2        3                   4              5
   --------------------------------------------------------------------
   390006 lipkey   1.3.6.1.5.5.9       negotiated  rpc_gss_svc_none
   390007 lipkey-i 1.3.6.1.5.5.9       negotiated  rpc_gss_svc_integrity
   390008 lipkey-p 1.3.6.1.5.5.9       negotiated  rpc_gss_svc_privacy
```

메커니즘 알고리즘은 "협상됨"으로 나열됩니다. 이는 LIPKEY가 SPKM-3에 계층화되어 있고 SPKM-3 \[RFC2847\]에서 기밀성 및 무결성 알고리즘이 협상되기 때문입니다. SPKM-3은 무결성을 위한 HMAC-MD5를 MANDATORY로 지정하고, 개인 정보 보호를 위한 128비트 Cast5CBC를 MANDATORY로 지정하고, HMAC-MD5 및 Cast5CBC가 더 약한 알고리즘보다 먼저 나열되어야 함을 추가로 지정하므로 열 4에 "협상됨"을 지정해도 손상되지 않습니다. 상호 운용성. SPKM-3 피어가 필수 알고리즘을 지원하지 않는 경우 다른 피어는 GSS-API 컨텍스트 생성을 자유롭게 수락하거나 거부할 수 있습니다.\(MUST\)

SPKM-3이 알고리즘을 협상하기 때문에 RPCSEC\_GSS에 의한 LIPKEY의 GSS\_Wrap\(\) 및 GSS\_GetMIC\(\)에 대한 후속 호출에서는 보호 품질 값 0\(영\)을 사용합니다. 설명은 \[RFC2025\]의 섹션 5.2를 참조하세요.

LIPKEY는 SPKM-3을 사용하여 클라이언트에서 서버로 사용자 이름과 비밀번호를 전달하는 보안 채널을 만듭니다. 사용자 이름과 비밀번호가 서버에서 승인되면 LIPKEY 컨텍스트에 대한 호출이 SPKM-3 컨텍스트로 리디렉션됩니다. 자세한 내용은 \[RFC2847\]을 참조하세요.

---
##### **3.2.1.3.  SPKM-3 as a security triple**

\[RFC2847\]에 설명된 SPKM-3 GSS-API 메커니즘은 반드시 구현되어야 하며 다음과 같은 보안 트리플을 제공해야 합니다. 열의 정의는 이전 하위 섹션인 "Kerberos V5 보안 삼중"과 일치합니다.\(MUST\)

```text
   1      2        3                   4              5
   --------------------------------------------------------------------
   390009 spkm3    1.3.6.1.5.5.1.3     negotiated  rpc_gss_svc_none
   390010 spkm3i   1.3.6.1.5.5.1.3     negotiated  rpc_gss_svc_integrity
   390011 spkm3p   1.3.6.1.5.5.1.3     negotiated  rpc_gss_svc_privacy

   For a discussion as to why the mechanism algorithm is listed as
   "negotiated", see the previous section "LIPKEY as a security triple."
```

SPKM-3이 알고리즘을 협상하기 때문에 RPCSEC\_GSS에 의한 SPKM-3의 GSS\_Wrap\(\) 및 GSS\_GetMIC\(\)에 대한 후속 호출에서는 보호 품질 값 0\(영\)을 사용합니다. 설명은 \[RFC2025\]의 섹션 5.2를 참조하세요.

LIPKEY가 SPKM-3 위에 계층화되어 있더라도 SPKM-3은 개시자\(클라이언트\)가 익명이거나 개시자가 자체 인증서를 가지고 있는 상황을 처리하기 위해 필수 트리플 세트로 지정됩니다. 개시자가 익명인 경우 대상\(서버\)으로 보낼 사용자 이름과 비밀번호가 없습니다. 개시자에게 자체 인증서가 있는 경우 암호를 사용하는 것은 불필요합니다.

---
### **3.3.  Security Negotiation**

NFS 버전 4 서버는 잠재적으로 여러 보안 메커니즘을 제공하므로 클라이언트는 서버와의 통신에 사용할 메커니즘을 결정하거나 협상하는 방법이 필요합니다. NFS 서버에는 NFS 클라이언트가 사용할 수 있는 파일 시스템 이름 공간 내에 여러 지점이 있을 수 있습니다. 차례로 NFS 서버는 이러한 진입점 각각이 서로 다르거나 여러 보안 메커니즘을 사용할 수 있도록 구성될 수 있습니다.

클라이언트와 서버 간의 보안 협상은 제3자가 협상 순서를 가로채서 클라이언트와 서버가 필요하거나 원하는 것보다 낮은 보안 수준을 선택하도록 강요할 가능성을 제거하기 위해 보안 채널을 사용하여 수행되어야 합니다. 자세한 내용은 "보안 고려 사항" 섹션을 참조하세요.

---
#### **3.3.1.  SECINFO**

새로운 SECINFO 작업을 통해 클라이언트는 파일 핸들별로 서버 액세스에 사용할 보안 트리플을 결정할 수 있습니다. 일반적으로 클라이언트는 서버와의 초기 통신 중이나 클라이언트가 서버에서 정책 경계를 넘을 때를 제외하고는 SECINFO 작업을 사용할 필요가 없습니다. 클라이언트의 상호 작용 중에 서버의 정책이 변경되어 클라이언트가 새로운 보안 삼중을 협상하도록 강요할 수 있습니다.

---
#### **3.3.2.  Security Error**

각 NFS 버전 4 클라이언트와 서버가 최소한의 보안 세트\(예: RPCSEC\_GSS 아래의 LIPKEY, SPKM-3 및 Kerberos-V5\)를 지원해야 한다는 가정에 따라 NFS 클라이언트는 다음 중 하나를 사용하여 서버와의 통신을 시작합니다. 최소한의 보안은 3배입니다. 서버와 통신하는 동안 클라이언트는 NFS4ERR\_WRONGSEC의 NFS 오류를 수신할 수 있습니다. 이 오류를 통해 서버는 현재 사용 중인 보안 트리플이 서버의 파일 시스템 리소스에 액세스하는 데 적합하지 않음을 클라이언트에 알릴 수 있습니다. 그런 다음 클라이언트는 서버에서 사용할 수 있는 보안 트리플을 결정하고 클라이언트에 적합한 보안 트리플을 선택해야 합니다. 클라이언트가 NFS4ERR\_WRONGSEC 오류에 응답하고 SECINFO를 사용하는 방법에 대한 자세한 내용은 "SECINFO" 작업 섹션을 참조하세요.

---
### **3.4.  Callback RPC Authentication**

이 섹션의 다른 부분에 언급된 경우를 제외하고 콜백 RPC\(나중에 설명\)는 원래 SETCLIENTID 작업에 사용된 보안 방식을 사용하여 클라이언트 ID\(나중에 설명\)를 획득한 주체에 대해 NFS 서버를 상호 인증해야 합니다.\(MUST\)

AUTH\_NONE의 경우 주체가 없으므로 이는 문제가 되지 않습니다.

AUTH\_SYS에는 상호 인증이나 서버 주체에 대한 개념이 없으므로 서버의 콜백은 사용자가 위임을 설정할 때 사용한 AUTH\_SYS 자격 증명을 사용합니다.

AUTH\_DH의 경우 일반적으로 사용되는 규칙 중 하나는 서버가 이 AUTH\_DH 주체에 해당하는 자격 증명을 사용한다는 것입니다.

```text
         unix.host@domain
```

여기서 호스트와 도메인은 서버 호스트의 이름과 네트워크 정보 시스템\(Network Information System\) 도메인 또는 DNS 도메인과 같이 해당 호스트가 존재하는 디렉터리 서비스 도메인에 해당하는 변수입니다.

LIPKEY는 SPKM-3 위에 계층화되어 있으므로 클라이언트가 SETCLIENTID에 LIPKEY를 사용한 경우에도 서버가 콜백에 LIPKEY가 아닌 SPKM-3을 사용하는 것이 허용됩니다.

RPCSEC\_GSS에서 사용되는 보안 메커니즘에 관계없이 NFS 서버는 GSS\_C\_NT\_HOSTBASED\_SERVICE 이름 유형을 통해 GSS-API에서 자신을 식별해야 합니다. GSS\_C\_NT\_HOSTBASED\_SERVICE 이름의 형식은 다음과 같습니다.\(MUST\)

```text
         service@hostname
```

NFS의 경우 "service" 요소는 다음과 같습니다.

```text
         nfs
```

보안 메커니즘을 구현하면 nfs@hostname을 다양한 형식으로 변환합니다. Kerberos V5 및 LIPKEY의 경우 다음 형식을 권장합니다.\(SHOULD\)

```text
         nfs/hostname
```

Kerberos V5의 경우 nfs/hostname은 Kerberos 키 배포 센터 데이터베이스의 서버 주체가 됩니다. 이는 클라이언트가 SETCLIENTID 작업을 실행할 때 GSS-API 컨텍스트를 획득한 것과 동일한 주체이므로 서버 주체의 영역 이름은 SETCLIENTID와 마찬가지로 콜백에서도 동일해야 합니다.

LIPKEY의 경우 이는 대상\(콜백을 수신하는 NFS 버전 4 클라이언트\)에 전달된 사용자 이름입니다.

LIPKEY 클라이언트는 사용자 ID/비밀번호를 사용하므로 LIPKEY는 콜백에 대해 작동하지 않을 수 있습니다. 콜백을 수신하는 NFS 클라이언트가 NFS 서버의 사용자 이름/비밀번호 쌍을 인증할 수 있고 NFS 서버가 인증하는 사용자가 공개 키 인증서를 가지고 있으면 작동합니다.

NFS 클라이언트가 LIPKEY를 사용하고 SETCLIENTID 작업에 호스트별 주체를 사용하는 경우에는 SETCLIENTID에 LIPKEY를 사용하는 대신 상호 인증이 포함된 SPKM-3을 사용하는 것이 좋습니다. 이는 클라이언트가 인증서를 사용하여 NFS 서버의 대상에 대한 개시자를 인증하고 식별한다는 것을 의미합니다. LIPKEY가 아닌 SPKM-3을 사용하면 다음과 같은 장점이 있습니다.\(SHOULD\)

o 서버가 콜백을 수행할 때 SETCLIENTID에 사용된 주체를 인증해야 합니다. LIPKEY를 사용하더라도 LIPKEY는 SPKM-3 위에 계층화되어 있으므로 NFS 클라이언트는

- SETCLIENTID 작업에 사용되는 주체에 해당하는 인증서가 있습니다. 관리 관점에서 볼 때 클라이언트와 서버 모두에 대한 사용자 이름, 비밀번호 및 인증서를 갖는 것은 중복됩니다.

o LIPKEY는 추가 인프라를 최소화하기 위한 것이었습니다.

- 대상에 대한 인증서 이상의 요구 사항이 있으며 기존 암호 인프라를 개시자에 활용할 수 있을 것으로 기대됩니다. 일부 환경에서는 호스트별 비밀번호가 아직 존재하지 않습니다. 호스트별 주체에 인증서를 사용하는 경우 추가 암호 인프라가 필요하지 않습니다.

o 호스트가 NFS 클라이언트이자 서버인 경우 동일한 호스트별 인증서를 공유할 수 있습니다.

---
## **4.  Filehandles**

NFS 프로토콜의 파일 핸들은 파일 시스템 개체에 대한 서버별 고유 식별자입니다. 파일 핸들의 내용은 클라이언트에게 불투명합니다. 따라서 서버는 파일 핸들을 파일 시스템 객체의 내부 표현으로 변환하는 일을 담당합니다.

---
### **4.1.  Obtaining the First Filehandle**

NFS 프로토콜의 작업은 하나 이상의 파일 핸들 측면에서 정의됩니다. 따라서 클라이언트는 서버와의 통신을 시작하기 위해 파일 핸들이 필요합니다. NFS 버전 2 프로토콜 \[RFC1094\] 및 NFS 버전 3 프로토콜 \[RFC1813\]에는 이 첫 번째 파일 핸들을 얻기 위한 보조 프로토콜이 존재합니다. MOUNT 프로토콜\(RPC 프로그램 번호 100005\)은 문자열 기반 파일 시스템 경로 이름을 NFS 프로토콜에서 사용할 수 있는 파일 핸들로 변환하는 메커니즘을 제공합니다.

MOUNT 프로토콜은 보안 및 방화벽을 통한 사용 측면에서 결함이 있습니다. 이것이 \[RFC2054\] 및 \[RFC2055\]에서 공개 파일 핸들의 사용이 도입된 이유 중 하나입니다. NFS 버전 2 및 3 프로토콜의 LOOKUP 작업과 함께 공용 파일 핸들을 사용하면 NFS 클라이언트와 서버 간의 실행 가능한 상호 작용에 MOUNT 프로토콜이 필요하지 않다는 것이 입증되었습니다.

따라서 NFS 버전 4 프로토콜은 문자열 기반 경로 이름을 파일 핸들로 변환하기 위해 보조 프로토콜을 사용하지 않습니다. 두 개의 특수 파일 핸들이 NFS 클라이언트의 시작점으로 사용됩니다.

---
#### **4.1.1.  Root Filehandle**

특수 파일 핸들 중 첫 번째는 ROOT 파일 핸들입니다. ROOT 파일핸들은 NFS 서버에 있는 파일 시스템 네임스페이스의 "개념적" 루트입니다. 클라이언트는 PUTROOTFH 작업을 사용하여 ROOT 파일 핸들을 사용하거나 시작합니다. PUTROOTFH 작업은 "현재" 파일 핸들을 서버 파일 트리의 ROOT로 설정하도록 서버에 지시합니다. 이 PUTROOTFH 작업이 사용되면 클라이언트는 LOOKUP 작업을 통해 서버의 파일 트리 전체를 탐색할 수 있습니다. 서버 네임스페이스에 대한 전체 설명은 "NFS 서버 네임스페이스" 섹션에 있습니다.

---
#### **4.1.2.  Public Filehandle**

두 번째 특수 파일 핸들은 PUBLIC 파일 핸들입니다. ROOT 파일 핸들과 달리 PUBLIC 파일 핸들은 서버에서 임의의 파일 시스템 개체를 바인딩하거나 나타낼 수 있습니다. 서버는 이 바인딩을 담당합니다. PUBLIC 파일 핸들과 ROOT 파일 핸들이 동일한 파일 시스템 개체를 참조할 수 있습니다. 그러나 PUBLIC 파일 핸들과 서버 파일 시스템 개체의 바인딩을 정의하는 것은 서버의 관리 소프트웨어와 서버 관리자의 정책에 달려 있습니다. 클라이언트는 이 바인딩에 대해 어떤 가정도 하지 않을 수 있습니다. 클라이언트는 PUTPUBFH 작업을 통해 PUBLIC 파일 핸들을 사용합니다.

---
### **4.2.  Filehandle Types**

NFS 버전 2 및 3 프로토콜에는 단일 의미 집합을 가진 한 가지 유형의 파일 핸들이 있었습니다. NFS 버전 4에서는 이러한 유형의 파일 핸들을 "지속적"이라고 합니다. 영구 파일 핸들의 의미는 이전과 동일하게 유지됩니다. NFS 버전 4에 도입된 새로운 유형의 파일 핸들은 특정 서버 환경을 수용하려고 시도하는 "휘발성" 파일 핸들입니다.

휘발성 파일 핸들 유형은 영구 파일 핸들의 올바른 구현을 불가능하게 만드는 서버 기능 또는 구현 문제를 해결하기 위해 도입되었습니다. 일부 서버 환경에서는 영구 파일 핸들을 구성하는 데 사용할 수 있는 파일 시스템 수준 불변성을 제공하지 않습니다. 기본 서버 파일 시스템이 불변성을 제공하지 않거나 서버의 파일 시스템 프로그래밍 인터페이스가 필요한 불변성에 대한 액세스를 제공하지 않을 수 있습니다. 휘발성 파일 핸들은 계층적 스토리지 관리, 파일 시스템 재구성 또는 마이그레이션과 같은 서버 기능의 구현을 용이하게 할 수 있습니다. 그러나 휘발성 파일 핸들은 클라이언트의 구현 부담을 증가시킵니다.

클라이언트는 영구 파일 핸들과 휘발성 파일 핸들을 다르게 처리해야 하므로 클라이언트가 서버에서 반환하는 파일 핸들 유형을 결정하는 데 사용할 수 있는 파일 속성이 정의됩니다.

---
#### **4.2.1.  General Properties of a Filehandle**

파일 핸들에는 서버가 개별 파일을 구별하는 데 필요한 모든 정보가 포함되어 있습니다. 클라이언트에게는 파일 핸들이 불투명합니다. 클라이언트는 이후 요청에 사용할 파일 핸들을 저장하고 바이트 단위 비교를 수행하여 동일한 서버의 두 파일 핸들이 동일한지 비교할 수 있습니다. 그러나 클라이언트는 파일 핸들의 내용을 달리 해석해서는 안 됩니다. 동일한 서버의 두 파일 핸들이 동일한 경우 동일한 파일을 참조해야 합니다. 서버는 파일 핸들과 파일 간의 일대일 대응을 유지하려고 노력해야 하지만 이것이 필수는 아닙니다. 클라이언트는 올바른 동작이 아닌 성능 향상을 위해서만 파일 핸들 비교를 사용해야 합니다. 모든 클라이언트는 두 파일 핸들이 동일한 개체를 나타내는지 여부를 확인할 수 없는 상황에 대비해야 하며, 이러한 경우 잘못된 동작을 유발할 수 있는 잘못된 가정을 피해야 합니다. 데이터 캐싱과 관련된 파일 핸들 및 속성 비교에 대한 자세한 내용은 "데이터 캐싱 및 파일 ID" 섹션에 나와 있습니다.\(MUST NOT, MUST, SHOULD, MUST\)

예를 들어, 서버에서 탐색할 때 두 개의 서로 다른 경로 이름이 동일한 파일 시스템 객체에서 종료되는 경우 서버는 각 경로에 대해 동일한 파일 핸들을 반환해야 합니다\(SHOULD\). 이는 동일한 기본 파일 객체 및 관련 데이터를 참조하는 두 개의 파일 이름을 생성하기 위해 하드 링크를 사용하는 경우 발생할 수 있습니다. 예를 들어, 경로 /a/b/c와 /a/d/c가 동일한 파일을 참조하는 경우 서버는 두 경로 이름 순회에 대해 동일한 파일 핸들을 반환해야 합니다.\(SHOULD, SHOULD\)

---
#### **4.2.2.  Persistent Filehandle**

영구 파일 핸들은 참조하는 파일 시스템 개체의 수명 동안 고정된 값을 갖는 것으로 정의됩니다. 서버가 파일 시스템 개체에 대한 파일 핸들을 생성하면 서버는 개체의 수명 동안 해당 개체에 대해 동일한 파일 핸들을 수락해야 합니다. 서버가 다시 시작되거나 재부팅되면 NFS 서버는 서버의 이전 인스턴스화에서와 동일한 파일 핸들 값을 적용해야 합니다. 마찬가지로, 파일 시스템이 마이그레이션되면 새 NFS 서버는 이전 NFS 서버와 동일한 파일 핸들을 사용해야 합니다.\(MUST\)

파일 시스템 개체가 제거되면 영구 파일 핸들은 오래되거나 유효하지 않게 됩니다. 서버에 삭제된 객체를 참조하는 영구 파일 핸들이 표시되면 NFS4ERR\_STALE 오류를 반환해야 합니다. 객체를 포함하는 파일 시스템을 더 이상 사용할 수 없으면 파일 핸들이 오래될 수 있습니다. 파일\(MUST\)

시스템이 이동식 미디어에 존재하고 해당 미디어를 서버에서 더 이상 사용할 수 없거나 파일 시스템 전체가 파괴되었거나 파일 시스템이 단순히 서버의 이름 공간에서 제거된 경우\(예: UNIX 환경에서 마운트 해제된 경우\) 시스템을 사용할 수 없게 될 수 있습니다.

---
#### **4.2.3.  Volatile Filehandle**

휘발성 파일 핸들은 영구 파일 핸들과 동일한 수명 특성을 공유하지 않습니다. 서버는 여러 시점에서 휘발성 파일 핸들이 더 이상 유효하지 않다고 판단할 수 있습니다. 서버가 휘발성 파일 핸들이 제거된 객체를 참조한다는 것을 확실히 확인할 수 있는 경우 서버는 NFS4ERR\_STALE을 클라이언트에 반환해야 합니다\(영구 파일 핸들의 경우와 마찬가지로\). 서버가 휘발성 파일 핸들을 더 이상 사용할 수 없다고 판단하는 다른 모든 경우에는 NFS4ERR\_FHEXPIRED 오류를 반환해야 합니다.

필수 속성 "fh\_expire\_type"은 클라이언트가 서버가 특정 파일 시스템에 제공하는 파일 핸들 유형을 결정하는 데 사용됩니다. 이 속성은 다음 값을 가진 비트마스크입니다.

FH4\_PERSISTENT

- FH4\_PERSISTENT 값은 객체가 파일 시스템에서 제거될 때까지 유효한 영구 파일 핸들을 나타내는 데 사용됩니다. 서버는 이 파일 핸들에 대해 NFS4ERR\_FHEXPIRED를 반환하지 않습니다. FH4\_PERSISTENT는 아래에 명시된 비트가 하나도 설정되지 않은 값으로 정의됩니다.

FH4\_VOLATILE\_ANY

- 파일 핸들은 특별히 제외된 경우\(예: FH4\_NO\_EXPIRE\_WITH\_OPEN\)를 제외하고 언제든지 만료될 수 있습니다.

FH4\_NOEXPIRE\_WITH\_OPEN

- FH4\_VOLATILE\_ANY가 설정된 경우에만 설정할 수 있습니다. 이 비트가 설정되면 FH4\_VOLATILE\_ANY의 의미는 파일 핸들이 열려 있을 때 파일 핸들의 만료를 제외하도록 규정됩니다.

FH4\_VOL\_MIGRATION

- 마이그레이션으로 인해 파일 핸들이 만료됩니다. FH4\_VOL\_ANY가 설정된 경우 FH4\_VOL\_MIGRATION은 중복됩니다.

FH4\_VOL\_RENAME

- 이름을 바꾸는 동안 파일 핸들이 만료됩니다. 여기에는 요청 클라이언트에 의한 이름 바꾸기 또는 다른 클라이언트에 의한 이름 바꾸기가 포함됩니다. FH4\_VOL\_ANY가 설정된 경우 FH4\_VOL\_RENAME은 중복됩니다.

열려 있는 동안 만료될 수 있는 휘발성 파일 핸들을 제공하는 서버\(예: FH4\_VOL\_MIGRATION 또는 FH4\_VOL\_RENAME이 설정되거나 FH4\_VOLATILE\_ANY가 설정되고 FH4\_NOEXPIRE\_WITH\_OPEN이 설정되지 않은 경우\)는 다음으로 이어지는 구성 요소의 OPEN 파일에 영향을 줄 수 있는 RENAME 또는 REMOVE를 거부해야 합니다. 파일을 엽니다. 또한 서버는 서버 재시작 시 유예 기간 동안 모든 RENAME 또는 REMOVE 요청을 거부해야 합니다.

FH4\_VOL\_MIGRATION 및 FH4\_VOL\_RENAME 비트를 사용하면 서버에서 명시적인 파일 핸들 만료 오류 없이 특정 이벤트가 발생할 때마다 클라이언트가 만료가 발생했음을 확인할 수 있습니다. FH4\_VOL\_ANY는 이러한 형태의 정보를 제공하지 않습니다. 서버가 마이그레이션 시 모든 파일 핸들이 아닌 많은 파일 핸들을 만료시키는 상황에서는\(예: 열려 있는 파일 핸들을 제외한 모든 파일 핸들\) FH4\_VOLATILE\_ANY\(이 경우 FH4\_NOEXPIRE\_WITH\_OPEN 포함\)가 더 나은 선택입니다. 마이그레이션이 발생하고 마이그레이션 이벤트 자체와 시간적으로 분리되어 추가 만료가 발생할 가능성이 있습니다\(파일 CLOSE의 결과\).

---
#### **4.2.4.  One Method of Constructing a Volatile Filehandle**

클라이언트에는 불투명하지만 휘발성 파일 핸들에는 다음이 포함될 수 있습니다.

```text
   [volatile bit = 1 | server boot time | slot | generation number]
```

o 슬롯은 서버 휘발성 파일 핸들 테이블의 인덱스입니다.

o 세대 번호는 테이블의 세대 번호입니다.

- 입장/슬롯

클라이언트가 휘발성 파일 핸들을 제시하면 서버는 휘발성 비트에 대한 검사가 통과되었다고 가정하여 다음 검사를 수행합니다. 서버 부팅 시간이 현재 서버 부팅 시간보다 짧으면 NFS4ERR\_FHEXPIRED를 반환합니다. 슬롯이 범위를 벗어나면 NFS4ERR\_BADHANDLE을 반환합니다. 세대 번호가 일치하지 않으면 NFS4ERR\_FHEXPIRED를 반환합니다.

서버가 재부팅되면 테이블이 사라집니다\(휘발성임\).

휘발성 비트가 0이면 그 뒤에 다른 구조가 있는 영구 파일 핸들입니다.

---
### **4.3.  Client Recovery from Filehandle Expiration**

가능하다면 클라이언트는 NFS4ERR\_FHEXPIRED 오류 수신으로부터 복구해야 합니다. 클라이언트는 휘발성 파일 핸들의 만료로부터 복구할 준비를 할 수 있도록 추가 책임을 져야 합니다. 서버가 영구 파일 핸들을 반환하는 경우 클라이언트에는 이러한 추가 단계가 필요하지 않습니다.\(SHOULD\)

휘발성 파일 핸들의 경우 가장 일반적으로 클라이언트는 문제의 파일 시스템 개체를 포함하여 이어지는 구성 요소 이름을 저장해야 합니다. 이러한 이름을 사용하면 클라이언트는 아직 사용 가능한 이름 공간에서 파일 핸들을 찾거나 서버 파일 시스템 이름 공간의 루트에서 시작하여 복구할 수 있어야 합니다.

만료된 파일 핸들이 파일 시스템에서 제거된 개체를 참조하는 경우 클라이언트는 만료된 파일 핸들에서 복구할 수 없습니다.

만료된 파일 핸들이 이름이 변경된 파일을 참조할 수도 있습니다. 다른 클라이언트가 파일 이름을 바꾼 경우 원래 클라이언트가 복구하지 못할 수도 있습니다. 그러나 클라이언트 자체가 파일 이름을 바꾸는 중이고 파일이 열려 있는 경우에는 클라이언트가 복구할 수도 있습니다. 클라이언트는 이름 바꾸기 요청 처리를 기반으로 새 경로 이름을 결정할 수 있습니다. 그런 다음 클라이언트는 새 경로 이름을 기반으로 새 파일 핸들을 다시 생성할 수 있습니다. 클라이언트는 RENAME A B LOOKUP B GETFH와 같은 일련의 작업을 구성하기 위해 복합 작업 메커니즘을 사용할 수도 있습니다.

COMPOUND 프로시저는 원자성을 제공하지 않습니다. 이 예는 만료된 파일 핸들에서 복구하는 오버헤드만 줄입니다.

---
## **5.  File Attributes**

확장성 및 비 UNIX 플랫폼과의 상호 운용성 향상 요구 사항을 충족하려면 속성을 유연한 방식으로 처리해야 합니다. NFS 버전 3 fattr3 구조에는 모든 클라이언트와 서버가 지원하거나 관심을 가질 수 없는 고정된 속성 목록이 포함되어 있습니다. fattr3 구조는 새로운 요구 사항이 발생하면 확장할 수 없으며 지원되지 않음을 나타낼 방법도 제공하지 않습니다. NFS 버전 4 프로토콜을 사용하면 클라이언트는 서버가 지원하는 속성을 쿼리하고 지원되는 속성\(또는 그 하위 집합\)만으로 요청을 구성할 수 있습니다.

이를 위해 속성은 필수, 권장, 명명의 세 그룹으로 나뉩니다. 필수 속성과 권장 속성 모두 NFS 버전 4 프로토콜에서 구체적이고 잘 정의된 인코딩을 통해 지원되며 숫자로 식별됩니다. GETATTR 요청에서 전송된 비트 벡터에 비트를 설정하여 요청됩니다. 서버 응답에는 응답에 반환된 속성을 나열하는 비트 벡터가 포함되어 있습니다. 새로운 속성 번호 값을 할당하고 속성에 대한 인코딩을 정의하는 표준 추적 RFC를 게시하여 주요 개정 사이에 새로운 필수 또는 권장 속성을 NFS 프로토콜에 추가할 수 있습니다. 자세한 내용은 "부 버전 관리" 섹션을 참조하세요.

명명된 속성은 파일 시스템 객체와 연관된 속성의 숨겨진 디렉터리에 액세스하는 새로운 OPENATTR 작업을 통해 액세스됩니다. OPENATTR은 객체에 대한 파일 핸들을 취하고 속성 계층에 대한 파일 핸들을 반환합니다. 명명된 속성에 대한 파일 핸들은 LOOKUP 또는 READDIR로 액세스할 수 있는 디렉터리 개체이며 이름이 명명된 속성을 나타내고 데이터 바이트가 속성의 값인 파일을 포함합니다. 예를 들어:

```text
      LOOKUP     "foo"       ; look up file
      GETATTR    attrbits
      OPENATTR               ; access foo's named attributes
      LOOKUP     "x11icon"   ; look up specific attribute
      READ       0,4096      ; read stream of bytes
```

명명된 속성은 NFS 클라이언트 구현이 아닌 애플리케이션에 필요한 데이터를 위한 것입니다. NFS 구현자는 새로운 속성을 IETF 표준 추적 프로세스에 적용하여 권장 속성으로 정의하는 것이 좋습니다.

필수로 분류된 속성 세트는 서버가 이를 지원하기 위해 필요한 모든 작업을 수행해야 하기 때문에 의도적으로 작습니다. 서버는 가능한 한 많은 권장 속성을 지원해야 하지만 정의에 따르면 서버는 모든 속성을 지원할 필요는 없습니다. 데이터가 다수의 클라이언트에 의해 필요하고 서버에서 지원이 제공되지 않을 때 클라이언트가 합리적으로 계산할 수 없는 경우 속성은 필수로 간주됩니다.

OPENATTR에 의해 반환된 숨겨진 디렉터리는 프로토콜 처리의 편의를 위한 것입니다. 클라이언트는 서버의 명명된 속성 구현과 서버의 기본 파일 시스템에 명명된 속성 디렉터리가 있는지 여부에 대해 어떤 가정도 해서는 안 됩니다. 따라서 명명된 특성 디렉터리에 대한 SETATTR 및 GETATTR과 같은 작업은 정의되지 않습니다.

---
### **5.1.  Mandatory Attributes**

최소 수준의 상호 운용성을 보장하려면 모든 NFS 버전 4 클라이언트 및 서버에서 이를 지원해야 합니다. 서버는 이러한 속성을 저장하고 반환해야 하며 클라이언트는 이러한 속성으로 제한된 속성 세트로 작동할 수 있어야 합니다. 필수 속성만 사용하면 일부 클라이언트 기능이 어떤 방식으로든 손상되거나 제한될 수 있습니다. 클라이언트는 GETATTR 요청에 비트를 설정하여 이러한 속성이 반환되도록 요청할 수 있으며 서버는 해당 값을 반환해야 합니다.\(MUST\)

---
### **5.2.  Recommended Attributes**

이러한 속성은 NFS 버전 4 프로토콜의 지원을 보장할 만큼 충분히 이해됩니다. 그러나 일부 클라이언트 및 서버에서는 지원되지 않을 수 있습니다. 클라이언트는 GETATTR 요청에 비트를 설정하여 이러한 속성이 반환되도록 요청할 수 있지만 서버가 해당 속성을 반환하지 않는 경우를 처리해야 합니다. 클라이언트는 서버가 지원하는 속성 세트를 요청할 수 있으며 서버가 지원하지 않는 속성은 요청해서는 안 됩니다. 서버는 지원되지 않는 속성에 대한 요청을 허용해야 하며 요청을 오류로 간주하기보다는 단순히 해당 속성을 반환하지 않아야 합니다. 서버는 편안하게 할 수 있는 모든 속성을 지원하고 운영 환경에서 지원하기 어려운 속성만 지원하지 못할 것으로 예상됩니다. 서버는 클라이언트에게 "거짓말"을 할 필요가 없을 때마다 속성을 제공해야 합니다. 예를 들어, 파일 수정 시간은 정확한 시간이어야 하며 서버에서 지원하지 않아야 합니다. 이것이 항상 내담자에게 편안한 것은 아니지만 내담자는 속성을 제작하거나 구성할지 여부와 방법 또는 속성 없이 수행할지 여부를 결정하는 데 더 나은 위치에 있습니다.

---
### **5.3.  Named Attributes**

이러한 속성은 NFS 버전 4 프로토콜의 직접 인코딩에서는 지원되지 않지만 숫자가 아닌 문자열 이름으로 액세스되며 파일 시스템 개체와 함께 저장되는 해석되지 않은 바이트 스트림에 해당합니다. 이러한 속성의 네임스페이스는 OPENATTR 작업을 사용하여 액세스할 수 있습니다. OPENATTR 작업은 가상 "속성 디렉터리"에 대한 파일 핸들을 반환하고 이 파일 핸들에 대한 READDIR 및 LOOKUP 작업을 사용하여 네임스페이스를 자세히 살펴볼 수 있습니다. 명명된 속성은 READDIR 및 LOOKUP에서 반환된 파일 핸들에 대한 일반적인 READ, WRITE 및 CREATE 작업을 통해 검사하거나 변경할 수 있습니다. 명명된 속성에는 속성이 있을 수 있습니다.

서버는 임의의 명명된 속성을 지원하는 것이 좋습니다. 클라이언트는 서버의 파일 시스템에 명명된 속성을 저장하는 기능에 의존해서는 안 됩니다. 서버가 명명된 속성을 지원하는 경우 이를 처리할 수 있는 클라이언트는 파일의 데이터와 메타데이터를 한 위치에서 다른 위치로 완전히 투명하게 복사할 수 있어야 합니다. 이는 일반 디렉토리 항목에 허용되는 이름이 명명된 속성 이름에도 유효함을 의미합니다.

속성 이름은 이 문서나 다른 IETF 표준 추적 문서에 의해 제어되지 않습니다. 자세한 내용은 "IANA 고려 사항" 섹션을 참조하세요.

---
### **5.4.  Classification of Attributes**

필수 및 권장 속성은 각각 서버별, 파일 시스템별 또는 파일 시스템 개체별 세 가지 범주 중 하나로 분류될 수 있습니다. 파일 시스템별 속성 중 일부는 파일 시스템 내에서 다를 수 있습니다. 해당 정의는 "동종" 속성을 참조하세요. time\_access\_set 및 time\_modify\_set 속성은 time\_access 및 time\_modify에 해당하는 쓰기 전용 속성이고 SETATTR의 특수 인스턴스에서 사용되기 때문에 이 섹션에 나열되지 않습니다.

o 서버별 속성은 다음과 같습니다.

```text
         lease_time
```

o 파일 시스템별 속성은 다음과 같습니다.

```text
      supp_attr, fh_expire_type, link_support, symlink_support,
      unique_handles, aclsupport, cansettime, case_insensitive,
      case_preserving, chown_restricted, files_avail, files_free,
      files_total, fs_locations, homogeneous, maxfilesize, maxname,
      maxread, maxwrite, no_trunc, space_avail, space_free, space_total,
      time_delta
```

o 파일 시스템별 개체 속성은 다음과 같습니다.

```text
      type, change, size, named_attr, fsid, rdattr_error, filehandle,
      ACL, archive, fileid, hidden, maxlink, mimetype, mode, numlinks,
      owner, owner_group, rawdev, space_used, system, time_access,
      time_backup, time_create, time_metadata, time_modify,
      mounted_on_fileid
```

quota\_avail\_hard, quota\_avail\_soft 및 quota\_used의 경우 적절한 분류에 대해서는 아래 정의를 참조하세요.

---
### **5.5.  Mandatory Attributes - Definitions**

이름 # 데이터 유형 액세스 설명 \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_ supp\_attr 0 비트맵 READ 이 객체에 대해 지원되는 모든 필수 및 권장 속성을 검색하는 비트 벡터입니다. 이 속성의 범위는 일치하는 fsid가 있는 모든 개체에 적용됩니다.

```text
   type              1    nfs4_ftype   READ     The type of the object
                                                (file, directory,
                                                symlink, etc.)
```

fh\_expire\_type 2 uint32 READ 서버는 이를 사용하여 클라이언트에 대한 파일 핸들 만료 동작을 지정합니다. 추가 설명은 "파일 핸들" 섹션을 참조하세요.

변경 3 uint64 READ 클라이언트가 객체의 파일 데이터, 디렉터리 내용 또는 속성이 수정되었는지 확인하는 데 사용할 수 있는 서버에서 생성된 값입니다. 서버는 이 속성 값에 대해 객체의 time\_metadata 속성을 반환할 수 있지만 파일 시스템 객체가 time\_metadata의 확인보다 더 자주 업데이트될 수 없는 경우에만 해당됩니다.

size 4 uint64 R/W 객체의 크기\(바이트\)입니다.

link\_support 5 bool READ 객체의 파일 시스템이 하드 링크를 지원하는 경우 True입니다.

Symlink\_support 6 bool READ 객체의 파일 시스템이 심볼릭 링크를 지원하는 경우 True입니다.

명명된\_attr 7 bool READ 이 객체에 명명된 속성이 있는 경우 True입니다. 즉, 개체에 비어 있지 않은 명명된 속성 디렉터리가 있습니다.

fsid 8 fsid4 READ 이 객체를 보유하는 파일 시스템의 고유한 파일 시스템 식별자입니다. fsid에는 각각 uint64인 주요 구성 요소와 보조 구성 요소가 포함되어 있습니다.

Unique\_handles 9 bool READ 두 개의 서로 다른 파일 핸들이 두 개의 서로 다른 파일 시스템 개체를 참조하는 것이 보장되는 경우 True입니다.

Lease\_time 10 nfs\_lease4 READ 서버에서의 임대 기간\(초\)입니다.

rdattr\_error 11 enum READ readdir 중 getattr에서 오류가 반환되었습니다.

filehandle 19 nfs\_fh4 READ 이 객체의 파일 핸들입니다\(주로 readdir 요청용\).

---
### **5.6.  Recommended Attributes - Definitions**

이름 # 데이터 유형 액세스 설명 \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_ ACL 12 nfsace4<\> R/W 객체에 대한 액세스 제어 목록입니다.

aclsupport 13 uint32 READ 현재 파일 시스템에서 지원되는 ACL 유형을 나타냅니다.

archive 14 bool R/W 이 파일이 마지막 수정 이후 아카이브된 경우 참입니다\(time\_backup을 위해 더 이상 사용되지 않음\).

cansettime 15 bool READ 서버가 SETATTR 작업에 지정된 대로 파일 시스템 개체의 시간을 변경할 수 있는 경우 True입니다.

case\_insensitive 16 bool READ 이 파일 시스템의 파일 이름 비교가 대소문자를 구분하지 않는 경우 True입니다.

case\_preserving 17 bool READ 이 파일 시스템의 파일 이름 대소문자가 보존되면 True입니다.

```text
   chown_restricted    18   bool           READ     If TRUE, the server
                                                    will reject any
                                                    request to change
                                                    either the owner or
                                                    the group associated
                                                    with a file if the
                                                    caller is not a
                                                    privileged user (for
                                                    example, "root" in
                                                    UNIX operating
                                                    environments or in
                                                    Windows 2000 the

                                                    "Take Ownership"
                                                    privilege).
```

fileid 20 uint64 READ 파일 시스템 내에서 파일을 고유하게 식별하는 번호입니다.

files\_avail 21 uint64 READ 이 객체를 포함하는 파일 시스템에서 이 사용자가 사용할 수 있는 파일 슬롯 - 관련 최소 한도여야 합니다.

files\_free 22 uint64 READ 이 객체를 포함하는 파일 시스템의 여유 파일 슬롯 - 관련 최소 한도여야 합니다.

files\_total 23 uint64 READ 이 객체를 포함하는 파일 시스템의 총 파일 슬롯입니다.

fs\_locations 24 fs\_locations READ 이 파일 시스템을 찾을 수 있는 위치입니다. 서버가 NFS4ERR\_MOVED를 오류로 반환하는 경우 이 속성을 지원해야 합니다.\(MUST\)

Hidden 25 bool R/W Windows API와 관련하여 파일이 숨겨진 것으로 간주되는 경우 True입니다.

```text
   homogeneous         26   bool           READ     True, if this
                                                    object's filesystem
                                                    is homogeneous,
                                                    i.e., are per
                                                    filesystem
                                                    attributes the same

                                                    for all filesystem's
                                                    objects?
```

maxfilesize 27 uint64 READ 이 객체의 파일 시스템에 대해 지원되는 최대 파일 크기입니다.

maxlink 28 uint32 READ 이 객체에 대한 최대 링크 수입니다.

maxname 29 uint32 READ 이 객체에 지원되는 최대 파일 이름 크기입니다.

maxread 30 uint64 READ 이 객체에 지원되는 최대 읽기 크기입니다.

maxwrite 31 uint64 READ 이 객체에 지원되는 최대 쓰기 크기입니다. 파일이 쓰기 가능한 경우 이 속성을 지원해야 합니다. 이 속성이 부족하면 클라이언트가 대역폭을 낭비하거나 최상의 성능을 얻지 못할 수 있습니다.\(SHOULD\)

mimetype 32 utf8<\> R/W MIME 본문

- 이 개체의 유형/하위 유형입니다.

모드 33 모드4 R/W 이 개체에 대한 UNIX 스타일 모드 및 권한 비트입니다.

no\_trunc 34 bool READ True, name\_max보다 긴 이름을 사용하면 오류가 반환되고 이름이 잘리지 않습니다.

numlinks 35 uint32 READ 이 객체에 대한 하드 링크 수입니다.

owner 36 utf8<\> R/W 이 객체 소유자의 문자열 이름입니다.

owner\_group 37 utf8<\> R/W 이 객체의 그룹 소유권에 대한 문자열 이름입니다.

quota\_avail\_hard 38 uint64 READ 정의는 아래 "할당량 속성" 섹션을 참조하세요.

quota\_avail\_soft 39 uint64 READ 정의는 아래 "할당량 속성" 섹션을 참조하세요.

quota\_used 40 uint64 READ 정의는 아래 "할당량 속성" 섹션을 참조하세요.

rawdev 41 specdata4 READ 원시 장치

- 식별자. UNIX 장치 주/부 노드 정보입니다. 유형의 값이 NF4BLK 또는 NF4CHR이 아닌 경우 반환 값은 유용한 것으로 간주되어서는 안 됩니다.\(SHOULD NOT\)

space\_avail 42 uint64 READ 이 객체를 포함하는 파일 시스템에서 이 사용자가 사용할 수 있는 디스크 공간\(바이트\) - 관련 최소 한도여야 합니다.

```text
   space_free          43   uint64         READ     Free disk space in
                                                    bytes on the
                                                    filesystem
                                                    containing this
                                                    object - this should
```

- 관련된 가장 작은 한계여야 합니다.

space\_total 44 uint64 READ 이 객체를 포함하는 파일 시스템의 총 디스크 공간\(바이트\)입니다.

space\_used 45 uint64 READ 이 객체에 할당된 파일 시스템 바이트 수입니다.

system 46 bool R/W 이 파일이 Windows API와 관련된 "시스템" 파일인 경우 참입니다.

time\_access 47 nfstime4 READ 서버에서 만족한 읽기를 통해 객체에 마지막으로 액세스한 시간입니다.

time\_access\_set 48 settime4 WRITE 객체에 대한 마지막 액세스 시간을 설정합니다. SETATTR만 사용하세요.

time\_backup 49 nfstime4 R/W 객체의 마지막 백업 시간입니다.

time\_create 50 nfstime4 R/W 객체 생성 시간입니다. 이 속성은 기존 UNIX 파일 속성 "ctime" 또는 "change time"과 아무런 관련이 없습니다.

```text
   time_delta          51   nfstime4       READ     Smallest useful
                                                    server time
                                                    granularity.
```

time\_metadata 52 nfstime4 READ 객체의 마지막 메타데이터 수정 시간입니다.

time\_modify 53 nfstime4 READ 객체를 마지막으로 수정한 시간입니다.

time\_modify\_set 54 settime4 WRITE 객체의 마지막 수정 시간을 설정합니다. SETATTR만 사용하세요.

Mounted\_on\_fileid 55 uint64 READ fileid와 비슷하지만 대상 파일 핸들이 파일 시스템의 루트인 경우 기본 디렉터리의 fileid를 반환합니다.

---
### **5.7.  Time Access**

위에서 정의한 대로 time\_access 속성은 서버에서 만족한 읽기를 통해 객체에 마지막으로 액세스한 시간을 나타냅니다. "액세스"라는 개념은 서버의 운영 환경 및/또는 서버의 파일 시스템 의미에 따라 달라집니다. 예를 들어, POSIX 의미 체계를 따르는 서버의 경우 time\_access는 READLINK, READ 및 READDIR 작업에 의해서만 업데이트되며 객체의 내용을 수정하는 작업에는 업데이트되지 않습니다. 물론 해당 time\_access\_set 속성을 설정하는 것은 time\_access 속성을 수정하는 또 다른 방법입니다.

파일 객체가 쓰기 가능한 파일 시스템에 있을 때마다 서버는 time\_access를 안정적인 저장소에 기록하기 위해 최선을 다해야 합니다. 그러나 이렇게 하면 성능에 미치는 영향을 완화하기 위해, 특히 서버가 캐시에서 개체 콘텐츠 읽기를 만족할 때마다 서버는 액세스 시간 업데이트를 캐시하고 안정적인 저장소에 느리게 쓸 수 있습니다. 서버 관리자에게 time\_access 업데이트를 비활성화하는 옵션을 제공하는 것도 허용됩니다.\(MAY\)

---
### **5.8.  Interpreting owner and owner_group**

권장 속성 "owner" 및 "owner\_group"\(또한 "acl" 속성 내의 사용자 및 그룹\)은 UTF-8 문자열로 표시됩니다. 클라이언트나 서버의 특정 기본 구현과 관련된 표현을 피하기 위해 UTF-8 문자열의 사용이 선택되었습니다. \[RFC2624\]의 섹션 6.1은 추가적인 근거를 제공합니다. 클라이언트와 서버는 로컬 저장이나 최종 사용자에게 표시하는 데 사용되는 owner 및 owner\_group에 대한 고유한 로컬 표현을 갖게 될 것으로 예상됩니다. 따라서 이러한 속성이 클라이언트와 서버 간에 전송될 때 로컬 표현이 "user@dns\_domain" 형식의 구문으로 변환될 것으로 예상됩니다. 이렇게 하면 동일한 로컬 표현을 사용하지 않는 클라이언트와 서버가 둘 다 해석할 수 있는 공통 구문으로 변환할 수 있습니다.

마찬가지로 보안 주체는 다양한 보안 메커니즘에 따라 다양한 방식으로 표현될 수 있습니다. 서버는 일반적으로 이러한 표현을 일반적으로 로컬 저장소에서 사용되는 공통 형식으로 변환하여 이러한 보안 주체에 해당하는 사용자를 식별하는 수단으로 사용됩니다. 이러한 로컬 식별자가 해당 보안 주체에 의해 생성된 파일과 연결된 소유자 특성의 형태로 변환되면 공통 형식으로 각 해당 보안 주체 집합과 연결된 사용자를 식별합니다.

소유자 및 그룹 문자열을 해석하는 데 사용되는 번역은 프로토콜의 일부로 지정되지 않습니다. 이를 통해 다양한 솔루션을 사용할 수 있습니다. 예를 들어 숫자 ID와 user@dns\_domain 구문을 매핑하는 로컬 변환 테이블을 참조할 수 있습니다. 번역을 완료하기 위해 이름 서비스를 사용할 수도 있습니다. 서버는 소유자 및 owner\_group 속성을 번역 없이 로컬 저장소에 저장하여 특정 번역\(가능한 문자열의 제한된 집합만 번역\)에 제한되지 않고 보다 일반적인 서비스를 제공할 수 있습니다. 번역이 가능한 경우 로컬 표현을 사용하는 동안 번역이 불가능한 속성에 대한 전체 문자열입니다.

owner 및 owner\_group 속성의 가능한 모든 값에 대한 지원을 제공하지 않는 서버는 번역이 없는 문자열이 표시될 때 소유자, owner\_group 또는 소유자의 SETATTR에 대해 설정할 값으로 오류\(NFS4ERR\_BADOWNER\)를 반환해야 합니다. acl 속성. 서버가 owner 또는 owner\_group 값을 SETATTR에서 유효한 것으로 승인하면\(그리고 acl의 소유자 및 그룹 문자열에 대해서도 유사하게\) 해당 GETATTR이 완료되면 동일한 문자열을 반환할 것을 약속합니다. 구성 변경 및 잘못 구성된 이름 번역\(다음을 포함하는 번역\)

별칭\)으로 인해 해당 약속을 이행할 수 없게 될 수 있습니다. 서버는 소유권에 대한 실제 변경이 발생하지 않은 경우 이러한 속성의 값이 변경되는 상황을 피하기 위해 적절한 노력을 기울여야 합니다.

소유자 문자열의 "dns\_domain" 부분은 DNS 도메인 이름을 의미합니다. 예를 들어 user@ietf.org입니다. 서버는 하나 이상의 도메인에 대해 유효한 사용자 집합을 허용해야 합니다. 서버는 다른 도메인을 유효한 번역이 없는 것으로 처리할 수 있습니다. 서버가 보안 제약에 따라 여러 도메인 또는 모든 도메인에 대한 사용자를 수락할 수 있는 경우 보다 일반적인 서비스가 제공됩니다.

클라이언트나 서버에서 사용할 수 있는 번역이 없는 경우 속성 값은 "@" 없이 구성되어야 합니다. 따라서 owner 또는 owner\_group 속성에 @가 없으면 보낸 사람이 번역할 수 없으며 속성을 받는 사람이 해당 문자열을 자체 내부 형식으로 번역하기 위한 기초로 사용해서는 안 된다는 것을 의미합니다. 속성 값을 번역할 수 없더라도 여전히 유용할 수 있습니다. 클라이언트의 경우 속성 문자열은 소유권의 로컬 표시에 사용될 수 있습니다.

32비트 부호 없는 uid 및 gid로 사용자와 그룹을 식별하는 이전 버전의 NFS\(예: v2 및 v3\)와의 호환성을 높이기 위해 앞에 0이 없는 10진수 값으로 구성된 소유자 및 그룹 문자열을 사용할 수 있습니다. 그러한 지원을 제공하기로 선택한 클라이언트와 서버의 특별한 해석이 제공됩니다. 수신기는 그러한 사용자 또는 그룹 문자열을 해당 숫자 값을 갖는 v2/v3 uid 또는 gid로 표시되는 것과 동일한 사용자를 나타내는 것으로 처리할 수 있습니다. 서버는 이러한 문자열을 받아들일 의무가 없지만 대신 NFS4ERR\_BADOWNER를 반환할 수 있습니다. 이 메커니즘이 사용자 및 그룹 변환을 파괴하는 데 사용되는 것을 방지하여 클라이언트가 모든 소유자 및 그룹을 숫자 형식으로 전달할 수 있도록 서버는 이 항목에 지정된 사용자 또는 소유자에 대한 유효한 변환이 있을 때 NFS4ERR\_BADOWNER 오류를 반환해야 합니다. 방법. 이 경우 클라이언트는 호환성을 위해 특수 형식이 아닌 적절한 name@domain 문자열을 사용해야 합니다.\(SHOULD\)

소유자 문자열 "nobody"는 익명 사용자를 지정하는 데 사용될 수 있으며, 이는 일반적인 방법을 통해 소유자 특성에 매핑될 수 없는 보안 주체에 의해 생성된 파일과 연결됩니다.

---
### **5.9.  Character Case Attributes**

대소 문자 구분 및 대소 문자 보존 속성과 관련하여 각 UCS-4 문자\(UTF-8로 인코딩됨\)에는 "CAPITAL" 또는 "SMALL"이라는 단어가 포함될 수도 있고 포함되지 않을 수도 있는 "긴 설명 이름"\[RFC1345\]이 있습니다. SMALL 또는 CAPITAL이 있으면 NFS 서버가 대소문자를 구분하지 않는 비교 및 ​​대소문자를 보존하지 않는 저장을 위해 명확하고 효율적인 테이블 기반 매핑을 구현할 수 있습니다. 일반적인 문자 처리 및 국제화 문제에 대해서는 "국제화" 섹션을 참조하세요.

---
### **5.10.  Quota Attributes**

파일 시스템 할당량과 관련된 속성의 경우 다음 정의가 적용됩니다.

quota\_avail\_soft

- 사용자에게 합리적으로 경고하기 전에 이 파일이나 디렉터리에 할당할 수 있는 추가 디스크 공간의 양을 나타내는 바이트 단위의 값입니다. 다른 파일이나 디렉터리에 대한 규칙이 있지만 이 공간은 다른 파일이나 디렉터리에 할당하여 소비될 수 있는 것으로 이해됩니다.

quota\_avail\_hard

- 추가 할당이 거부되기 전에 이 파일이나 디렉터리에 할당할 수 있는 현재 할당을 초과하는 추가 디스크 공간의 양을 나타내는 바이트 단위의 값입니다. 이 공간은 다른 파일이나 디렉터리에 대한 할당으로 인해 소모될 수 있는 것으로 이해됩니다.

할당량\_사용됨

- 이 파일이나 디렉터리 및 기타 유사한 파일이나 디렉터리에서 사용하는 디스크 공간의 양을 나타내는 바이트 단위의 값입니다. 여기서 "유사" 집합은 최소한 모든 파일이나 디렉터리에 공간을 할당하는 기준을 충족합니다. 세트는 세트에 있는 다른 모든 파일이나 디렉토리의 "quota\_avail\_hard"를 줄입니다.

- quota\_used 값이 유지되는 고유하지만 겹치는 파일 또는 디렉터리 집합이 여러 개 있을 수 있습니다\(예: "주어진 소유자가 있는 모든 파일", "주어진 그룹 소유자가 있는 모든 파일" 등\).

- 서버는 해당 세트 중 하나를 자유롭게 선택할 수 있지만 반복 가능한 방식으로 선택해야 합니다. 규칙은 파일 시스템별로 구성되거나 "가장 작은 할당량을 가진 세트를 선택"할 수 있습니다.

---
### **5.11.  Access Control Lists**

NFS 버전 4 ACL 속성은 ACE\(액세스 제어 항목\)의 배열입니다. 클라이언트는 ACL 속성을 읽고 쓸 수 있지만 NFSv4 모델에서는 서버가 ACL에 대한 서버의 해석을 기반으로 모든 액세스 제어를 수행합니다. 어느 시점에서든 클라이언트가 데이터나 메타데이터를 수정하거나 읽는 작업을 실행하지 않고 액세스를 확인하려는 경우 클라이언트는 OPEN 및 ACCESS 작업을 사용하여 이를 수행할 수 있습니다. "ACE 유형" 섹션에 정의된 대로 다양한 액세스 제어 항목 유형이 있습니다. 서버는 aclsupport 속성 내에서 적절한 값을 반환하여 지원되는 ACE 유형을 전달할 수 있습니다. 각 ACE는 "ACE 액세스 마스크" 섹션에 설명된 대로 파일 또는 디렉터리에 대한 하나 이상의 작업을 다룹니다. 또한 "ACE 플래그" 섹션에 정의된 대로 ACE의 의미를 수정하는 하나 이상의 플래그가 포함될 수도 있습니다.

NFS ACE 속성은 다음과 같이 정의됩니다.

```text
         typedef uint32_t        acetype4;
         typedef uint32_t        aceflag4;
         typedef uint32_t        acemask4;

         struct nfsace4 {
                 acetype4        type;
                 aceflag4        flag;
                 acemask4        access_mask;
                 utf8str_mixed   who;
         };
```

요청이 성공했는지 확인하기 위해 각 nfsace4 항목이 서버에서 순서대로 처리됩니다. 요청자와 일치하는 "누구"가 있는 ACE만 고려됩니다. 각 ACE는 요청자의 액세스 비트가 모두 허용될 때까지 처리됩니다. ACCESS\_ALLOWED\_ACE에 의해 비트\(아래 참조\)가 허용되면 이후 ACE 처리에서 더 이상 고려되지 않습니다. 요청자의 액세스에 ACE의 "access\_mask"와 공통된 허용되지 않은 비트가 여전히 있는 ACCESS\_DENIED\_ACE가 발생하면 요청이 거부됩니다. 그러나 ALLOWED 및 DENIED ACE 유형과 달리 ALARM 및 AUDIT ACE 유형은 요청자의 액세스에 영향을 주지 않으며 대신 요청자의 액세스 시도의 결과로 이벤트를 트리거하는 데 사용됩니다.

따라서 모든 AUDIT 및 ALARM ACE는 ACL이 끝날 때까지 처리됩니다. ACL이 완전히 처리되었을 때 요청자의 마스크에 서버의 액세스 허용 또는 거부 여부를 고려하지 않은 비트가 있으면 정의되지 않습니다. 파일에 모드 속성이 있는 경우 모드의 MODE4\_\*OTH 비트가 요청자의 액세스를 명확하게 지정하는 EVERYONE@ ACE에 매핑되므로 이런 일이 발생할 수 없습니다.

NFS 버전 4 ACL 모델은 매우 풍부합니다. 일부 서버 플랫폼은 UNIX 스타일 모드 속성을 넘어서는 액세스 제어 기능을 제공할 수 있지만 NFS ACL 모델만큼 풍부하지는 않습니다. 사용자가 이 보다 제한된 기능을 활용할 수 있도록 서버는 ACL 모델과 NFS 버전 4 ACL 모델 간의 매핑 지침을 따르는 한 ACL을 지원한다고 표시할 수 있습니다.

서버에 ACL을 적용하는 여러 모듈이 있을 수 있다는 사실로 인해 상황이 복잡해집니다. 예를 들어 NFS 버전 4 액세스에 대한 적용은 로컬 액세스에 대한 적용과 다를 수 있으며, 둘 다 SMB와 같은 다른 프로토콜을 통한 액세스에 대한 적용과 다를 수 있습니다. 따라서 모든 모듈이 ACL을 지원할 수 없더라도 서버가 ACL을 수락하는 것이 유용할 수 있습니다.

모든 경우의 기본 원칙은 파일을 실제보다 더 안전하게 만드는 것처럼 보이는 ACL을 서버가 허용해서는 안 된다는 것입니다.

---
#### **5.11.1.  ACE type**

유형 설명 \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_ ALLOW acemask4에 정의된 액세스 권한을 파일 또는 디렉터리에 명시적으로 부여합니다.

DENY는 다음에 정의된 액세스를 명시적으로 거부합니다.

- 파일이나 디렉터리에 acemask4를 추가합니다.

감사 로그\(시스템에 따라 다름\) 모든 액세스

- acemask4에 지정된 액세스 방법을 사용하는 파일이나 디렉터리에 시도합니다.

ALARM 시스템 ALARM 생성\(시스템

- 종속\) acemask4에 지정된 액세스 방법으로 파일이나 디렉터리에 액세스를 시도하는 경우.

서버는 위의 ACE 유형을 모두 지원할 필요는 없습니다. 위의 정의를 나타내는 데 사용되는 비트마스크 상수는

aclsupport 속성은 다음과 같습니다.

```text
      const ACL4_SUPPORT_ALLOW_ACL    = 0x00000001;
      const ACL4_SUPPORT_DENY_ACL     = 0x00000002;
      const ACL4_SUPPORT_AUDIT_ACL    = 0x00000004;
      const ACL4_SUPPORT_ALARM_ACL    = 0x00000008;
```

"유형" 필드의 의미는 위에 제공된 설명을 따릅니다.

유형 필드\(acetype4\)에 사용되는 상수는 다음과 같습니다.

```text
      const ACE4_ACCESS_ALLOWED_ACE_TYPE      = 0x00000000;
      const ACE4_ACCESS_DENIED_ACE_TYPE       = 0x00000001;
      const ACE4_SYSTEM_AUDIT_ACE_TYPE        = 0x00000002;
      const ACE4_SYSTEM_ALARM_ACE_TYPE        = 0x00000003;
```

서버가 해당 ACE 유형에 대한 지원을 요청하지 않는 한 클라이언트는 ACE 설정을 시도해서는 안 됩니다. 서버가 저장할 수 없는 ACE를 설정하라는 요청을 받으면 NFS4ERR\_ATTRNOTSUPP를 사용하여 요청을 거부해야 합니다. 서버가 저장할 수는 있지만 시행할 수 없는 ACE를 설정하라는 요청을 수신하는 경우 서버는 NFS4ERR\_ATTRNOTSUPP를 사용하여 요청을 거부해야 합니다.\(MUST, SHOULD\)

예: 서버가 NFS 액세스에 대해 NFS ACL을 적용할 수 있지만 로컬 액세스에 대해서는 ACL을 적용할 수 없다고 가정합니다. 임의의 프로세스가 서버에서 실행될 수 있는 경우 서버는 ACL 지원을 표시해서는 안 됩니다. 반면에 신뢰할 수 있는 관리 프로그램만 로컬로 실행되는 경우 서버는 ACL 지원을 나타낼 수 있습니다.\(SHOULD NOT\)

---
#### **5.11.2.  ACE Access Mask**

access\_mask 필드에는 다음을 기반으로 하는 값이 포함됩니다.

```text
   Access                 Description
   _______________________________________________________________
   READ_DATA              Permission to read the data of the file
   LIST_DIRECTORY         Permission to list the contents of a
                          directory
   WRITE_DATA             Permission to modify the file's data
   ADD_FILE               Permission to add a new file to a
                          directory
   APPEND_DATA            Permission to append data to a file
   ADD_SUBDIRECTORY       Permission to create a subdirectory to a
                          directory
   READ_NAMED_ATTRS       Permission to read the named attributes
                          of a file
   WRITE_NAMED_ATTRS      Permission to write the named attributes
                          of a file
   EXECUTE                Permission to execute a file
   DELETE_CHILD           Permission to delete a file or directory
                          within a directory
   READ_ATTRIBUTES        The ability to read basic attributes
                          (non-acls) of a file
   WRITE_ATTRIBUTES       Permission to change basic attributes

                          (non-acls) of a file
   DELETE                 Permission to Delete the file
   READ_ACL               Permission to Read the ACL
   WRITE_ACL              Permission to Write the ACL
   WRITE_OWNER            Permission to change the owner
   SYNCHRONIZE            Permission to access file locally at the
                          server with synchronous reads and writes
```

액세스 마스크 필드에 사용되는 비트마스크 상수는 다음과 같습니다.

```text
   const ACE4_READ_DATA            = 0x00000001;
   const ACE4_LIST_DIRECTORY       = 0x00000001;
   const ACE4_WRITE_DATA           = 0x00000002;
   const ACE4_ADD_FILE             = 0x00000002;
   const ACE4_APPEND_DATA          = 0x00000004;
   const ACE4_ADD_SUBDIRECTORY     = 0x00000004;
   const ACE4_READ_NAMED_ATTRS     = 0x00000008;
   const ACE4_WRITE_NAMED_ATTRS    = 0x00000010;
   const ACE4_EXECUTE              = 0x00000020;
   const ACE4_DELETE_CHILD         = 0x00000040;
   const ACE4_READ_ATTRIBUTES      = 0x00000080;
   const ACE4_WRITE_ATTRIBUTES     = 0x00000100;
   const ACE4_DELETE               = 0x00010000;
   const ACE4_READ_ACL             = 0x00020000;
   const ACE4_WRITE_ACL            = 0x00040000;
   const ACE4_WRITE_OWNER          = 0x00080000;
   const ACE4_SYNCHRONIZE          = 0x00100000;
```

서버 구현에서는 이 마스크 목록이 암시하는 제어 세분성을 제공할 필요가 없습니다. 예를 들어 POSIX 기반 시스템은 APPEND\_DATA\(파일에 추가하는 기능\)와 WRITE\_DATA\(기존 내용을 수정하는 기능\)를 구별하지 못할 수 있습니다. 두 마스크 모두 단일 "쓰기" 권한에 연결됩니다. 이러한 서버가 클라이언트에 속성을 반환하면 쓰기 권한이 활성화된 경우에만 APPEND\_DATA와 WRITE\_DATA가 모두 표시됩니다.

서버가 정확하게 구현할 수 없는 SETATTR 요청을 받으면 더 제한된 액세스 방향으로 오류가 발생해야 합니다. 예를 들어, 이전 단락에서 설명한 대로 서버가 데이터 덮어쓰기와 새 데이터 추가를 구별할 수 없다고 가정합니다. 클라이언트가 APPEND\_DATA가 설정되었지만 WRITE\_DATA가 설정되지 않은 ACE를 제출하는 경우\(또는 그 반대\) 서버는 NFS4ERR\_ATTRNOTSUPP를 사용하여 요청을 거부해야 합니다. 그럼에도 불구하고 ACE 유형이 DENY인 경우 서버는 자동으로 다른 비트를 켤 수 있으므로 APPEND\_DATA 및 WRITE\_DATA가 모두 거부됩니다.

---
#### **5.11.3.  ACE flag**

"플래그" 필드에는 다음 설명에 따른 값이 포함됩니다.

ACE4\_FILE\_INHERIT\_ACE

- 디렉터리에 배치할 수 있으며 디렉터리가 아닌 새 파일이 생성될 때마다 이 ACE를 추가해야 함을 나타냅니다.

ACE4\_DIRECTORY\_INHERIT\_ACE

- 디렉터리에 배치할 수 있으며 생성된 각 새 디렉터리에 이 ACE를 추가해야 함을 나타냅니다.

ACE4\_INHERIT\_ONLY\_ACE

- 디렉터리에 배치할 수 있지만 디렉터리에는 적용되지 않으며 위의 두 플래그에 지정된 대로 새로 생성된 파일/디렉터리에만 적용됩니다.

ACE4\_NO\_PROPAGATE\_INHERIT\_ACE

- 디렉토리에 배치할 수 있습니다. 일반적으로 새 디렉터리가 생성되고 ACL4\_DIRECTORY\_INHERIT\_ACE로 표시된 상위 디렉터리에 ACE가 존재하면 두 개의 ACE가 새 디렉터리에 배치됩니다. 하나는 디렉터리 자체용이고 다른 하나는 새로 생성된 디렉터리에 대해 상속 가능한 ACE입니다. 이 플래그는 생성된 디렉터리의 하위 디렉터리에서 상속할 수 있는 새로 생성된 디렉터리에 ACE를 배치하지 않도록 서버에 지시합니다.

```text
   ACE4_SUCCESSFUL_ACCESS_ACE_FLAG
```

ACL4\_FAILED\_ACCESS\_ACE\_FLAG

- ACE4\_SUCCESSFUL\_ACCESS\_ACE\_FLAG\(SUCCESS\) 및 ACE4\_FAILED\_ACCESS\_ACE\_FLAG\(FAILED\) 플래그 비트는 ACE4\_SYSTEM\_AUDIT\_ACE\_TYPE\(AUDIT\) 및 ACE4\_SYSTEM\_ALARM\_ACE\_TYPE\(ALARM\) ACE 유형에만 관련됩니다. 파일의 ACL을 처리하는 동안 서버가 OPEN을 시도하는 주체와 일치하는 AUDIT 또는 ALARM ACE를 발견하면 서버는 해당 사실과 AUDIT 또는 ALARM에서 발견된 SUCCESS 및 FAILED 플래그의 존재 여부를 기록합니다. 에이스. 서버가 ACL 처리, 공유 예약 처리 및 OPEN 호출을 완료하면 OPEN의 성공 또는 실패 여부를 기록합니다. OPEN이 성공하고 일치하는 AUDIT 또는 ALARM에 대해 SUCCESS 플래그가 설정된 경우 적절한 AUDIT 또는 ALARM 이벤트가 발생합니다. OPEN이 실패하고 일치하는 AUDIT 또는 ALARM에 대해 FAILED 플래그가 설정된 경우 적절한 AUDIT 또는 ALARM 이벤트가 발생합니다. SUCCESS 또는 FAILED 중 하나 또는 둘 다를 설정할 수 있지만 둘 중 어느 것도 설정하지 않은 경우 AUDIT 또는 ALARM ACE는 유용하지 않습니다.

- 앞에서 설명한 처리는 ACCESS 작업에도 적용됩니다. "성공" 또는 "실패"라는 차이점은 ACCESS가 NFS4\_OK를 반환하는지 여부를 의미하지 않습니다. 성공은 ACCESS가 요청 및 지원되는 모든 비트를 반환하는지 여부를 의미합니다. 실패는 ACCESS가 요청하고 지원한 비트를 반환하지 못했는지 여부를 의미합니다.

ACE4\_IDENTIFIER\_GROUP

- "누구"가 UNIX에서 정의된 GROUP을 나타냄을 나타냅니다.

플래그 필드에 사용되는 비트마스크 상수는 다음과 같습니다.

```text
   const ACE4_FILE_INHERIT_ACE             = 0x00000001;
   const ACE4_DIRECTORY_INHERIT_ACE        = 0x00000002;
   const ACE4_NO_PROPAGATE_INHERIT_ACE     = 0x00000004;
   const ACE4_INHERIT_ONLY_ACE             = 0x00000008;
   const ACE4_SUCCESSFUL_ACCESS_ACE_FLAG   = 0x00000010;
   const ACE4_FAILED_ACCESS_ACE_FLAG       = 0x00000020;
   const ACE4_IDENTIFIER_GROUP             = 0x00000040;
```

서버는 이러한 플래그를 지원할 필요가 없습니다. 서버가 이러한 플래그와 유사하지만 정확히 동일하지는 않은 플래그를 지원하는 경우 구현에서는 프로토콜 정의 플래그와 구현 정의 플래그 간의 매핑을 정의할 수 있습니다. 다시 말하지만, 기본 원칙은 파일이 실제보다 더 안전해 보이지는 않는다는 것입니다.

예를 들어, 클라이언트가 ACE4\_FILE\_INHERIT\_ACE가 설정된 ACE를 설정하려고 하지만 ACE4\_DIRECTORY\_INHERIT\_ACE는 설정하지 않는다고 가정해 보겠습니다. 서버가 어떤 형태의 ACL 상속도 지원하지 않는 경우 서버는 NFS4ERR\_ATTRNOTSUPP를 사용하여 요청을 거부해야 합니다. 서버가 파일과 디렉터리 모두에 적용되는 단일 "ACE 상속" 플래그를 지원하는 경우 서버는 요청을 거부할 수 있습니다\(즉, 클라이언트가 파일 및 디렉터리 상속 플래그를 모두 설정하도록 요구함\). 서버는 요청을 수락하고 ACE4\_DIRECTORY\_INHERIT\_ACE 플래그를 자동으로 켤 수도 있습니다.

---
#### **5.11.4.  ACE who**

특정 DNS 도메인의 맥락이 아닌 보편적으로 이해해야 하는 몇 가지 특수 식별자\("누구"\)가 있습니다. 이러한 식별자 중 일부는 NFS 클라이언트가 서버에 액세스할 때 이해할 수 없지만 로컬 프로세스가 파일에 액세스할 때는 의미가 있습니다. 이러한 권한을 표시하고 수정하는 기능은 서버의 액세스 방법 중 어느 것도 식별자를 이해하지 못하는 경우에도 NFS를 통해 허용됩니다.

누구 설명 \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_ "소유자" 파일의 소유자입니다. "GROUP" 파일과 관련된 그룹입니다. "모두" 세상. "INTERACTIVE" 대화형 터미널에서 액세스됩니다. "NETWORK" 네트워크를 통해 액세스됩니다. "DIALUP" 서버에 대한 전화 접속 사용자로 액세스됩니다. "BATCH" 일괄 작업에서 액세스됩니다. "ANONYMOUS" 인증 없이 액세스되었습니다. "AUTHENTICATED" 인증된 사용자\(ANONYMOUS의 반대\) "SERVICE" 시스템 서비스에서 액세스합니다.

```text
   To avoid conflict, these special identifiers are distinguish by an
   appended "@" and should appear in the form "xxxx@" (note: no domain
   name after the "@").  For example: ANONYMOUS@.
```

---
#### **5.11.5.  Mode Attribute**

NFS 버전 4 모드 속성은 UNIX 모드 비트를 기반으로 합니다. 다음 비트가 정의됩니다:

```text
      const MODE4_SUID = 0x800;  /* set user id on execution */
      const MODE4_SGID = 0x400;  /* set group id on execution */
      const MODE4_SVTX = 0x200;  /* save text even after use */
      const MODE4_RUSR = 0x100;  /* read permission: owner */
      const MODE4_WUSR = 0x080;  /* write permission: owner */
      const MODE4_XUSR = 0x040;  /* execute permission: owner */
      const MODE4_RGRP = 0x020;  /* read permission: group */
      const MODE4_WGRP = 0x010;  /* write permission: group */
      const MODE4_XGRP = 0x008;  /* execute permission: group */
      const MODE4_ROTH = 0x004;  /* read permission: other */
      const MODE4_WOTH = 0x002;  /* write permission: other */
      const MODE4_XOTH = 0x001;  /* execute permission: other */
```

비트 MODE4\_RUSR, MODE4\_WUSR 및 MODE4\_XUSR은 소유자 속성에서 식별된 주체에 적용됩니다. 비트 MODE4\_RGRP, MODE4\_WGRP 및

MODE4\_XGRP는 owner\_group 속성에서 식별된 주체에 적용됩니다. 비트 MODE4\_ROTH, MODE4\_WOTH, MODE4\_XOTH는 소유자 그룹의 주체와 일치하지 않고 owner\_group 속성과 일치하는 그룹이 없는 모든 주체에 적용됩니다.

나머지 비트는 이 프로토콜에 의해 정의되지 않으며 사용되어서는 안 됩니다. 추가 비트 사용을 정의하려면 마이너 버전 메커니즘을 사용해야 합니다.\(MUST NOT\)

UNIX에서 파일에 MODE4\_SGID 비트가 설정되어 있고 MODE4\_XGRP 비트가 설정되지 않은 경우 읽기 및 쓰기는 필수 파일 잠금을 사용해야 합니다.

---
#### **5.11.6.  Mode and ACL Attribute**

모드와 ACL을 모두 지원하는 서버는 MODE4\_\*USR, MODE4\_\*GRP 및 MODE4\_\*OTH 비트를 "OWNER@", "GROUP@" 및 "EVERYONE@"의 각 who 필드가 있는 ACE와 동기화하도록 주의해야 합니다. " 클라이언트가 소유자, 소유자 그룹 및 모드 속성을 요청하든지 ACL만 요청하든 의미상 동일한 액세스 권한이 존재함을 클라이언트가 볼 수 있도록 합니다.

모드 속성에는 ACL 의미 체계와 관련이 없는 비트\(예: MODE4\_SVTX\)가 포함되어 있으므로 클라이언트가 동일한 SETATTR 작업에서 ACL 속성과 모드를 모두 지정하는 것이 허용됩니다. 그러나 SETATTR의 속성 처리에 대해 규정된 순서가 없기 때문에 클라이언트는 모드 없이 지정된 경우 ACL 속성이 원하는 모드 비트를 생성하고 반대로 ACL 없이 지정된 경우 모드 속성이 원하는 모드 비트를 생성하는지 확인해야 합니다. 원하는 "OWNER@", "GROUP@" 및 "EVERYONE@" ACE.

---
#### **5.11.7.  mounted_on_fileid**

UNIX 기반 운영 환경은 기존 파일 시스템의 기존 파일 개체\(마운트 지점, 일반적으로 디렉터리\)에 파일 시스템을 연결\(마운트\)하여 파일 시스템을 네임스페이스에 연결합니다. readdir\(\)과 같은 API를 통해 마운트 지점의 상위 디렉터리를 읽으면 반환 결과는 각각 구성 요소 이름과 파일 ID가 포함된 디렉터리 항목입니다. 마운트 지점 디렉토리 항목의 파일 ID는 stat\(\) 시스템 호출이 반환하는 파일 ID와 다릅니다. stat\(\) 시스템 호출은 마운트된 파일 시스템 루트의 파일 ID를 반환하는 반면, readdir\(\)은 파일 시스템이 마운트 지점에 마운트되기 전에 stat\(\)이 반환했을 파일 ID를 반환합니다.

NFS 버전 3과 달리 NFS 버전 4에서는 클라이언트의 LOOKUP 요청이 다른 파일 시스템을 통과할 수 있습니다. 클라이언트는 LOOKUP의 파일 핸들 인수에 LOOKUP이 반환한 파일 핸들의 fsid 속성과 다른 fsid 속성이 있을 때마다 파일 시스템 교차를 감지합니다. UNIX 기반 클라이언트는 이를 "마운트 지점 교차"로 간주합니다. UNIX에는 프로세스가 현재 작업 디렉토리를 결정할 수 있도록 하는 레거시 체계가 있습니다. 이는 앞서 설명한 대로 마운트 지점 상위의 readdir\(\)과 파일 ID를 반환하는 마운트 지점의 stat\(\)에 의존합니다. Mounted\_on\_fileid 속성은 앞에서 설명한 대로 readdir\(\)이 반환한 파일 ID에 해당합니다.

NFS 버전 4 클라이언트는 Mounted\_on\_fileid가 제공하는 것과 일치하는 파일 ID를 간단하게 조작할 수 있지만\(서버가 Mounted\_on\_fileid를 지원하지 않는 경우 클라이언트는 선택의 여지가 없음\) 클라이언트가 다음과 충돌하는 파일 ID를 생성할 위험이 있습니다. 파일 시스템의 다른 개체에 이미 할당되었습니다. 대신, 서버가 Mounted\_on\_fileid를 제공할 수 있으면 이 영역에서 클라이언트 작동 문제가 발생할 가능성이 제거됩니다.

서버가 대상 파일 객체에 탑재 지점이 없음을 감지하면 반환되는 Mounted\_on\_fileid 값은 fileid 속성의 값과 동일합니다.

Mounted\_on\_fileid 속성은 RECOMMENDED이므로 서버는 가능하면 이를 제공해야 하며 UNIX 기반 서버의 경우 이는 간단합니다. 일반적으로 Mounted\_on\_fileid는 READDIR 작업 중에 요청되며, 이 경우에 mount\_on\_fileid가 readdir\(\)에 의해 반환된 디렉터리 항목의 fileid와 동일하기 때문에 이를 반환하는 것은 쉽지 않습니다\(적어도 UNIX 기반 서버의 경우\). GETATTR 작업에서 Mounted\_on\_fileid가 요청되면 서버는 개체의 부모 디렉터리에 있는 파일 개체 항목과 동일한 값, 즉 readdir\(\)이 반환한 값을 반환하는 불변성을 따라야 합니다. 일부 운영 환경에서는 일련의 두 개 이상의 파일 시스템을 단일 마운트 지점에 마운트할 수 있습니다. 이 경우 서버가 앞서 언급한 불변성을 따르려면 중간 마운트 지점이 아닌 기본 마운트 지점을 찾아야 합니다.\(SHOULD\)

---
## **6.  Filesystem Migration and Replication**

NFS 버전 4 서버는 권장 속성 "fs\_locations"를 사용하여 파일 시스템 마이그레이션 또는 복제 서비스를 제공하는 방법을 갖습니다. 마이그레이션 및 복제를 위해 파일 시스템은 지정된 fsid를 공유하는 모든 파일로 정의됩니다\(주 값과 부 값이 모두 동일함\).

fs\_locations 속성은 파일 시스템 위치 목록을 제공합니다. 이러한 위치는 서버 이름\(DNS 도메인 또는 IP 주소\)과 파일 시스템의 루트를 나타내는 경로 이름을 제공하여 지정됩니다. 제공되는 서비스 유형에 따라 목록은 파일 시스템에 대한 새 위치 또는 대체 위치 집합을 제공합니다. 클라이언트는 이 정보를 사용하여 요청을 새 서버로 리디렉션합니다.

---
### **6.1.  Replication**

읽기 전용 데이터의 경우 파일 시스템 복제가 사용될 것으로 예상됩니다. 일반적으로 파일 시스템은 두 개 이상의 서버에 복제됩니다. fs\_locations 속성은 다음을 제공합니다.

클라이언트에게 이러한 위치 목록을 보냅니다. 파일 시스템에 처음 액세스할 때 클라이언트는 fs\_locations 속성 값을 얻어야 합니다. 나중에 클라이언트가 서버가 응답하지 않는 것을 발견하면 클라이언트는 fs\_locations에 지정된 다른 서버를 사용하려고 시도할 수 있습니다.

해당되는 경우 클라이언트는 적절한 단계를 수행하여 새 서버에서 유효한 파일 핸들을 복구해야 합니다. 이에 대해서는 다음 섹션에서 자세히 설명합니다.

---
### **6.2.  Migration**

파일 시스템 마이그레이션은 파일 시스템을 한 서버에서 다른 서버로 이동하는 데 사용됩니다. 마이그레이션은 일반적으로 쓰기 가능하고 단일 복사본이 있는 파일 시스템에 사용됩니다. 예상되는 마이그레이션 용도는 로드 밸런싱 또는 일반 리소스 재할당입니다. 프로토콜은 파일 시스템이 서버 간에 이동되는 방법을 지정하지 않습니다. 이 서버 간 전송 메커니즘은 서버 구현자에게 맡겨집니다. 그러나 클라이언트와 서버 간에 마이그레이션 이벤트를 전달하는 데 사용되는 방법은 여기에서 지정됩니다.

마이그레이션에 참여하는 서버가 파일 시스템 이동을 완료하면 원래 서버가 받은 후속 요청에 대해 NFS4ERR\_MOVED 오류가 반환됩니다. PUTFH 및 GETATTR을 제외한 모든 작업에 대해 NFS4ERR\_MOVED 오류가 반환됩니다. NFS4ERR\_MOVED 오류를 수신하면 클라이언트는 fs\_locations 속성의 값을 얻습니다. 그런 다음 클라이언트는 속성의 내용을 사용하여 해당 요청을 지정된 서버로 리디렉션합니다. GETATTR을 쉽게 사용하려면 마이그레이션된 파일 시스템의 파일 핸들에 대해 서버에서 PUTFH와 같은 작업도 허용해야 합니다. 서버가 NFS4ERR\_MOVED를 반환하는 경우 서버는 fs\_locations 속성을 지원해야 합니다.\(MUST\)

클라이언트가 fs\_locations보다 더 많은 속성을 요청하는 경우 서버는 fs\_locations만 반환할 수 있습니다. 이는 서버가 파일 시스템을 마이그레이션했으며 추가 속성 데이터를 얻을 수 있는 방법이 없을 수 있기 때문에 예상되는 현상입니다.

서버 구현자는 마이그레이션 솔루션을 개발할 때 주의해야 합니다. 서버는 클라이언트가 서버에 남아 있을 수 있는 모든 상태 정보를 고려해야 합니다. 여기에는 잠금/공유 상태, 위임 상태, WRITE 및 COMMIT 검증자로 표시되는 비동기 파일 쓰기가 포함되지만 이에 국한되지는 않습니다. 서버는 마이그레이션 프로세스 도중과 이후에 클라이언트에 미치는 영향을 최소화하기 위해 노력해야 합니다.

---
### **6.3.  Interpretation of the fs_locations Attribute**

fs\_location 속성은 다음과 같은 방식으로 구성됩니다.

```text
   struct fs_location {
           utf8str_cis     server<>;
           pathname4       rootpath;
   };

   struct fs_locations {
           pathname4       fs_root;
           fs_location     locations<>;
   };
```

fs\_location 구조체는 서버 이름과 파일 시스템 루트 경로를 제공하여 파일 시스템의 위치를 ​​나타내는 데 사용됩니다. 멀티홈 서버 또는 동일한 루트 경로를 사용하는 서버 집합의 경우 서버 이름 배열이 제공될 수 있습니다. 서버 배열의 항목은 UTF8 문자열이며 기존 DNS 호스트 이름, IPv4 주소 또는 IPv6 주소 중 하나를 나타냅니다. 동일한 루트 경로를 공유하는 모든 서버가 하나의 fs\_location 구조체에 나열될 필요는 없습니다. 편의를 위해 서버 이름 배열이 제공됩니다. 동일한 루트 경로를 공유하는 서버는 fs\_locations 속성의 별도 fs\_location 항목에 나열될 수도 있습니다.

fs\_locations 구조체와 속성에는 위치 배열이 포함됩니다. 각 서버의 네임스페이스는 다르게 구성될 수 있으므로 "fs\_root" 필드를 제공한다. fs\_root로 표시되는 경로는 서버의 이름 공간에 있는 파일 시스템의 위치를 ​​나타냅니다. 따라서 fs\_root 경로는 fs\_locations 속성을 얻은 서버에만 연결됩니다. fs\_root 경로는 클라이언트가 나열된 다양한 서버에서 파일 시스템을 찾는 데 도움을 주기 위한 것입니다.

예를 들어, 두 서버\(servA 및 servB\)에 복제된 파일 시스템이 있습니다. servA에서 파일 시스템은 "/a/b/c" 경로에 있습니다. servB에서 파일 시스템은 "/x/y/z" 경로에 있습니다. 이 예에서 클라이언트는 다중 구성 요소 조회 경로 "/a/b/c/d"를 사용하여 servA에서 먼저 파일 시스템에 액세스합니다. 클라이언트는 "/a/b/c/d"에서 파일 핸들을 얻기 위해 다중 구성 요소 조회를 사용했기 때문에 파일 시스템의 루트가 servA의 이름 공간 "/a/b/c"에 있다는 사실을 인식하지 못합니다. 클라이언트가 servB로 전환할 때 servA에서 처음 참조한 디렉토리가 이제 servB의 "/x/y/z/d" 경로로 표시되는지 확인해야 합니다. 이를 용이하게 하기 위해 servA가 제공하는 fs\_locations 속성에는 "/a/b/c"의 fs\_root 값과 fs\_location에 두 개의 항목이 있습니다. fs\_location의 한 항목은 자체\(servA\)에 대한 것이고 다른 항목은 servB에 대한 것입니다.

"/x/y/z" 경로입니다. 이 정보를 사용하여 클라이언트는 액세스 경로 시작 부분에서 "/a/b/c"를 "/x/y/z"로 대체하고 "/x/y/z/d"를 구성하여 사용할 수 있습니다. 새로운 서버.

"fs\_locations" 속성을 요청하는 GETATTR 작업에서 사용할 보안 유형에 대한 권장 사항에 대한 논의는 "보안 고려 사항" 섹션을 참조하세요.

---
### **6.4.  Filehandle Recovery for Migration or Replication**

복제 또는 마이그레이션된 파일 시스템의 파일 핸들은 일반적으로 복제 또는 마이그레이션되지 않은 파일 시스템과 동일한 의미를 갖습니다. 예를 들어, 파일 시스템에 영구 파일 핸들이 있고 다른 서버로 마이그레이션된 경우 파일 시스템의 파일 핸들 값은 새 서버에서 유효합니다.

휘발성 파일 핸들의 경우 관련 서버에는 파일 핸들 형식과 콘텐츠를 서로 간에 전송하는 메커니즘이 없을 가능성이 높습니다. 따라서 서버는 이전 서버의 휘발성 파일 핸들이 NFS4ERR\_FHEXPIRED 오류를 반환해야 하는지 결정하는 데 어려움을 겪을 수 있습니다. 따라서 fh\_expire\_type 속성을 사용하여 휘발성 파일 핸들이 마이그레이션 또는 복제 이벤트에서 만료되는지 여부를 클라이언트에 알립니다. fh\_expire\_type 속성에 FH4\_VOL\_MIGRATION 비트가 설정된 경우 클라이언트는 서버가 NFS4ERR\_FHEXPIRED 오류를 반환한 것처럼 휘발성 파일 핸들을 처리해야 합니다. FH4\_VOL\_MIGRATION 비트가 있는 마이그레이션 또는 복제 이벤트에서 클라이언트는 원본 또는 이전 휘발성 파일 핸들을 새 서버에 제공하지 않습니다. 클라이언트는 저장된 파일 이름을 사용하여 파일 핸들을 복구하여 새 서버와의 통신을 시작합니다.

---
## **7.  NFS Server Name Space**
---
### **7.1.  Server Exports**

UNIX 서버에서 네임스페이스는 루트 디렉토리 또는 "/" 아래의 경로 이름으로 접근할 수 있는 모든 파일을 설명합니다. Windows NT 서버에서 이름 공간은 매핑된 디스크 문자로 명명된 디스크의 모든 파일을 구성합니다. NFS 서버 관리자는 NFS 클라이언트가 전체 서버의 파일 시스템 이름 공간을 사용할 수 있도록 하는 경우가 거의 없습니다. 이름 공간의 일부는 "내보내기" 기능을 통해 사용 가능한 경우가 더 많습니다. 이전 버전의 NFS 프로토콜에서는 각 내보내기에 대한 루트 파일 핸들이 MOUNT 프로토콜을 통해 획득되었습니다. 클라이언트는 네임스페이스 내보내기를 식별하는 문자열을 보내고 서버는 이에 대한 루트 파일 핸들을 반환합니다. MOUNT 프로토콜은 서버의 내보내기를 열거하는 EXPORTS 프로시저를 지원합니다.

---
### **7.2.  Browsing Exports**

NFS 버전 4 프로토콜은 클라이언트가 다중 구성 요소 LOOKUP을 통해 이러한 내보내기에 대한 파일 핸들을 얻는 데 사용할 수 있는 루트 파일 핸들을 제공합니다. 일반적인 사용자 경험은 그래픽 사용자 인터페이스\(예: 파일 "열기" 대화 상자 창\)를 사용하여 디렉터리 트리를 통한 점진적인 탐색을 통해 파일을 찾는 것입니다. 클라이언트는 단일 구성 요소의 점진적인 LOOKUP 작업을 통해 한 내보내기에서 다른 내보내기로 이동할 수 있어야 합니다.

이러한 검색 스타일은 NFS 버전 2 및 3 프로토콜에서 잘 지원되지 않습니다. 클라이언트는 모든 LOOKUP 작업이 단일 서버 파일 시스템 내에 유지되기를 기대합니다. 예를 들어 장치 속성은 변경되지 않습니다. 이렇게 하면 클라이언트가 내보내기에 걸쳐 있는 네임스페이스 경로를 사용하지 못하게 됩니다.

클라이언트의 자동 마운트는 MOUNT 프로토콜의 EXPORTS 프로시저를 사용하여 서버 이름 공간의 스냅샷을 얻을 수 있습니다. 서버의 경로 이름 구문을 이해하면 클라이언트에 서버 이름 공간의 이미지를 생성할 수 있습니다. 서버가 내보내지 않는 네임스페이스 부분은 사용자가 마운트된 파일 시스템에서 다른 파일 시스템으로 탐색할 수 있도록 하는 "의사 파일 시스템"으로 채워집니다. 클라이언트의 서버 이름 공간 표현에는 단점이 있습니다. 즉, 정적이라는 것입니다. 서버 관리자가 새 내보내기를 추가하면 클라이언트는 이를 인식하지 못합니다.

---
### **7.3.  Server Pseudo Filesystem**

NFS 버전 4 서버는 단일 서버 네임스페이스 프레임워크 내에서 모든 내보내기를 제공하여 이러한 네임스페이스 불일치를 방지합니다. NFS 버전 4 클라이언트는 LOOKUP 및 READDIR 작업을 사용하여 한 내보내기에서 다른 내보내기로 원활하게 찾아봅니다. 내보내지지 않은 서버 네임스페이스 부분은 내보낸 디렉터리 보기만 제공하는 "의사 파일 시스템"을 통해 연결됩니다. 의사 파일 시스템은 고유한 fsid를 가지며 일반적인 읽기 전용 파일 시스템처럼 동작합니다.

서버의 이름 공간 구성에 따라 여러 의사 파일 시스템이 존재할 수 있습니다. 예를 들어,

```text
   /a         pseudo filesystem
   /a/b       real filesystem
   /a/b/c     pseudo filesystem
   /a/b/c/d   real filesystem
```

각 의사 파일 시스템은 별도의 엔터티로 간주되므로 고유한 fsid를 갖습니다.

---
### **7.4.  Multiple Roots**

DOS 및 Windows 운영 환경은 때때로 "다중 루트"를 갖는 것으로 설명됩니다. 파일 시스템은 일반적으로 디스크 문자로 표시됩니다. MacOS는 파일 시스템을 최상위 이름으로 나타냅니다. 이러한 플랫폼용 NFS 버전 4 서버는 디스크 문자나 볼륨 이름이 단순히 의사 루트의 디렉터리 이름이 되도록 이러한 루트 이름 위에 의사 파일 시스템을 구성할 수 있습니다.

---
### **7.5.  Filehandle Volatility**

서버 의사 파일 시스템의 특성은 서버에서 사용할 수 있는 파일 시스템을 논리적으로 표현한 것입니다. 따라서 의사 파일 시스템은 서버가 처음 인스턴스화될 때 동적으로 구성될 가능성이 높습니다. 의사 파일 시스템에는 영구 파일 핸들을 구성할 수 있는 디스크 대응 부분이 없을 것으로 예상됩니다. 서버가 의사 파일 시스템에 영구 파일 핸들을 제공하는 것이 바람직하더라도 NFS 클라이언트는 의사 파일 시스템 파일 핸들이 일시적이라는 것을 예상해야 합니다. 이는 문제의 파일 핸들과 관련된 "fh\_expire\_type" 속성을 확인하여 확인할 수 있습니다. 파일 핸들이 일시적인 경우 NFS4ERR\_FHEXPIRED 오류를 수신할 때 NFS 클라이언트는 파일 핸들 값\(예: 다중 구성 요소 LOOKUP 사용\)을 복구할 준비를 해야 합니다.

---
### **7.6.  Exported Root**

서버의 루트 파일 시스템을 내보내면 의사 파일 시스템이 필요하지 않다고 결론을 내릴 수도 있습니다. 이것은 잘못된 것입니다. 서버에 다음 파일 시스템이 있다고 가정합니다.

```text
         /       disk1  (exported)
         /a      disk2  (not exported)
         /a/b    disk3  (exported)
```

disk2는 내보내지지 않기 때문에 간단한 LOOKUP으로 disk3에 접근할 수 없습니다. 서버는 의사 파일 시스템을 사용하여 격차를 해소해야 합니다.

---
### **7.7.  Mount Point Crossing**

서버 파일 시스템 환경은 하나의 파일 시스템이 두 번째 파일 시스템에 의해 '덮이거나' 마운트되는 디렉토리를 포함하는 방식으로 구성될 수 있습니다. 예를 들어:

```text
         /a/b            (filesystem 1)
         /a/b/c/d        (filesystem 2)
```

이 서버의 의사 파일 시스템은 다음과 같이 구성될 수 있습니다.

```text
         /               (place holder/not exported)
         /a/b            (filesystem 1)
         /a/b/c/d        (filesystem 2)
```

완전한 의사 파일 시스템을 클라이언트에 제공하는 것은 서버의 책임입니다. 클라이언트가 "/a/b/c/d" 경로에 대한 조회 요청을 보내는 경우 서버의 응답은 파일 시스템 "/a/b/c/d"의 파일 핸들입니다. 이전 버전의 NFS 프로토콜에서 서버는 파일 시스템 "/a/b" 내의 "/a/b/c/d" 디렉터리의 파일 핸들로 응답했습니다.

NFS 클라이언트는 "fsid" 속성 값의 변경을 통해 서버 마운트 지점을 통과하는지 확인할 수 있습니다.

---
### **7.8.  Security Policy and Name Space Presentation**

서버의 보안 정책 적용은 구현자가 신중하게 고려해야 합니다. 클라이언트가 자신을 적절하게 인증할 수 있다는 서버의 인식을 기반으로 의사 파일 시스템 일부의 표시 가능성을 제한하도록 선택할 수 있습니다. 그러나 여러 보안 메커니즘의 지원과 이러한 메커니즘의 적절한 사용을 협상하는 기능으로 인해 서버는 클라이언트가 자신을 인증할 수 있는지 여부를 적절하게 결정할 수 없습니다. 정책에 따라 서버가 의사 파일 시스템의 내용을 제한하기로 선택한 경우 서버는 합법적인 액세스 권한을 가질 수 있는 클라이언트로부터 파일 시스템을 효과적으로 숨길 수 있습니다.

제안된 방식에 따라 서버는 서버 네임스페이스에 있는 공유 리소스의 보안 정책을 리소스 상위 구성 요소에 적용해야 합니다. 예를 들어:

```text
         /
         /a/b
         /a/b/c
```

/a/b/c 디렉토리는 실제 파일 시스템이며 공유 리소스입니다. /a/b/c에 대한 보안 정책은 무결성을 갖춘 Kerberos입니다. 서버는 /, /a, /a/b에 동일한 보안 정책을 적용해야 합니다. 이를 통해 서버의 네임스페이스 보호를 실제 공유 리소스의 상위 항목까지 확장할 수 있습니다.

서버 리소스에서 서로 분리된 여러 보안 메커니즘을 사용하는 경우 서버 이름 공간의 특정 개체에 대한 보안은 모든 직계 자손의 모든 보안 메커니즘을 통합해야 합니다.

---
## **8.  File Locking and Share Reservations**

NFS 프로토콜에 잠금을 통합하면 반드시 상태 저장이 가능해집니다. 공유 예약을 포함하면 프로토콜은 NFS와 NLM \[XNFS\]의 전통적인 조합보다 상태에 훨씬 더 의존하게 됩니다. 이 상태를 관리 가능하게 만드는 데는 세 가지 구성 요소가 있습니다.

o 클라이언트와 서버 간의 명확한 구분

o 클라이언트와 서버 간의 상태 불일치를 안정적으로 감지하는 능력

o 간단하고 강력한 복구 메커니즘

이 모델에서는 서버가 상태 정보를 소유합니다. 클라이언트는 필요에 따라 이 상태에 대한 보기를 서버에 전달합니다. 클라이언트는 파일을 수정하기 전에 일관성 없는 상태를 감지할 수도 있습니다.

Win32 공유 예약을 지원하려면 파일을 원자적으로 OPEN하거나 CREATE해야 합니다. 별도의 공유/공유 해제 작업을 사용하면 Win32 OpenFile API를 올바르게 구현할 수 없습니다. 공유 의미 체계를 올바르게 구현하려면 파일을 열거나 생성할 때 사용된 이전 NFS 프로토콜 메커니즘\(LOOKUP, CREATE, ACCESS\)을 교체해야 합니다. NFS 버전 4 프로토콜에는 LOOKUP, CREATE 및 ACCESS의 NFS 버전 3 방법론을 포함하는 OPEN 작업이 있습니다. 그러나 많은 작업에 파일 핸들이 필요하기 때문에 서버에 상태를 설정하지 않고 파일 이름을 파일 핸들에 매핑하도록 기존 LOOKUP이 유지됩니다. 접근 권한을 부여하거나 파일을 수정하는 정책은 클라이언트의 상태에 따라 서버에서 관리됩니다. 이러한 메커니즘은 권고 전용 잠금부터 전체 강제 잠금까지 정책을 구현할 수 있습니다.

---
### **8.1.  Locking**

READ 및 WRITE 작업과 비교할 때 잠금 조작은 드물다고 가정됩니다. 또한 충돌과 네트워크 분할은 상대적으로 드물다고 가정됩니다. 따라서 READ 및 WRITE 작업이 잠금을 보유하고 있는지 여부를 나타내는 경량 메커니즘을 갖는 것이 중요합니다. 잠금 요청에는 잠금을 설정하고 잠금 소유자를 고유하게 정의하는 데 필요한 중요 정보가 포함되어 있습니다.

다음 섹션에서는 중량 정보에서 대부분의 클라이언트 및 서버 잠금 및 임대 상호 작용에 사용되는 최종 상태 ID로의 전환에 대해 설명합니다.

---
#### **8.1.1.  Client ID**

각 LOCK 요청에 대해 클라이언트는 서버에 자신을 식별해야 합니다.

이는 올바른 잠금 식별 및 충돌 복구를 허용하는 방식으로 수행됩니다. 서버에 대한 ID를 설정하려면 SETCLIENTID 작업과 SETCLIENTID\_CONFIRM 작업 순서가 필요합니다. 클라이언트의 새로운 구현에 의한 식별 설정은 새로운 클라이언트 구현이 임대가 만료될 때까지 기다리게 하는 것과는 반대로 클라이언트의 이전 구현이 서버에 가졌을 수 있는 임대 상태를 즉시 중단하는 효과도 있습니다. 임대 상태를 깨면 서버는 모든 잠금, 공유 예약을 제거하고 서버가 CLAIM\_DELEGATE\_PREV 클레임 유형을 지원하지 않는 경우 동일한 ID를 가진 동일한 클라이언트와 연결된 모든 위임 상태를 제거합니다. 위임 상태 복구에 대한 논의는 "위임 복구" 섹션을 참조하세요.

클라이언트 식별은 다음 구조로 캡슐화됩니다.

```text
         struct nfs_client_id4 {
                 verifier4     verifier;
                 opaque        id<NFS4_OPAQUE_LIMIT>;
         };
```

첫 번째 필드인 verifier는 클라이언트 재부팅을 감지하는 데 사용되는 클라이언트 구현 검증자입니다. 검증자가 서버가 이전에 클라이언트를 기록한 것과 다른 경우에만\(구조의 두 번째 필드인 id로 식별됨\) 서버는 클라이언트의 임대 상태를 취소하는 프로세스를 시작합니다.

두 번째 필드인 id는 클라이언트를 고유하게 정의하는 가변 길이 문자열입니다.

클라이언트가 ID 문자열을 생성하는 방법에 대한 몇 가지 고려 사항이 있습니다.

o 여러 클라이언트가 동일한 문자열을 제공하지 않도록 문자열은 고유해야 합니다. 동일한 문자열 범위를 제공하는 두 클라이언트의 결과는 한 클라이언트에서 오류가 발생하고 임대 상태가 갑자기 취소된 한 클라이언트까지 발생합니다.

o 동일한 클라이언트의 후속 구현\(예: 재부팅\) 시 클라이언트가 동일한 문자열을 제공하도록 문자열을 선택해야 합니다. 구현자는 로컬 파일에 문자열을 기록해야 하는 접근 방식에 대해 주의해야 합니다. 이는 로컬 디스크가 없고 모든 파일 액세스가 NFS 버전 4 서버에서 이루어지는 환경에서 구현을 사용할 수 없기 때문입니다.

o 문자열은 모든 서버 네트워크 주소에 공통되는 것이 아니라 클라이언트가 액세스하는 각 서버 네트워크 주소마다 달라야 합니다. 그 이유는 동일한 서버가 여러 네트워크 주소를 수신하고 있는지 클라이언트가 알 수 없기 때문입니다. 클라이언트가 해당 서버의 각 네트워크 주소에 동일한 ID 문자열을 사용하여 SETCLIENTID를 발행하는 경우 서버는 해당 클라이언트가 동일한 클라이언트라고 생각하고 연속되는 각 SETCLIENTID로 인해 서버는 클라이언트의 이전 임대 상태를 제거하는 프로세스를 시작하게 됩니다.

o 문자열을 생성하는 알고리즘은 클라이언트의 네트워크 주소가 변경되지 않을 것이라고 가정해서는 안 됩니다. 여기에는 클라이언트 구현 간의 변경 사항과 클라이언트가 현재 구현에서 계속 실행되는 동안의 변경 사항도 포함됩니다. 이는 클라이언트가 id 문자열에 클라이언트와 서버의 네트워크 주소만 포함하는 경우 클라이언트가 네트워크 주소를 포기한 후 id 문자열을 생성하기 위해 유사한 알고리즘을 사용하는 다른 클라이언트가 네트워크 주소를 생성할 실제 위험이 있음을 의미합니다. 충돌하는 ID 문자열.

위의 고려 사항을 고려하여 잘 생성된 ID 문자열의 예는 다음을 포함합니다.

o 서버의 네트워크 주소.

o 클라이언트의 네트워크 주소.

o 사용자 수준 NFS 버전 4 클라이언트의 경우 다음을 포함해야 합니다.

- 프로세스 ID 또는 기타 고유 시퀀스와 같이 동일한 호스트에서 실행되는 다른 사용자 수준 클라이언트와 클라이언트를 구별하기 위한 추가 정보입니다.

o 다음 중 하나 이상과 같이 고유한 경향이 있는 추가 정보:

- - 클라이언트 시스템의 일련 번호\(개인 정보 보호를 위해 일련 번호에 대해 단방향 기능을 수행하는 것이 가장 좋습니다\).

- - MAC 주소.

- - NFS 버전 4 소프트웨어가 클라이언트에 처음 설치되었을 때의 타임스탬프\(단, 파일은 NFS 버전 4를 통해서만 액세스할 수 있으므로 파일에 저장된 정보 사용에 대해 앞서 언급한 주의 사항이 적용됩니다\).

- - 실제 난수입니다. 그러나 이 숫자는 클라이언트 구현 간에 동일해야 하기 때문에 이는 소프트웨어 설치의 타임스탬프를 사용하는 것과 동일한 문제를 공유합니다.

보안 조치로서, 주어진 ID 문자열에 대해 주체가 설정한 상태가 SETCLIENTID를 발행하는 주체와 동일하지 않은 경우 서버는 클라이언트의 임대 상태를 취소해서는 안 됩니다.\(MUST NOT\)

SETCLIENTID 및 SETCLIENTID\_CONFIRM에는 서버가 위임 지원을 위해 클라이언트에 콜백하는 데 필요한 정보를 설정하는 두 번째 목적이 있습니다. 클라이언트의 임대 상태를 제거하지 않고 클라이언트의 동일한 구현 내에서 SETCLIENTID 및 SETCLIENTID\_CONFIRM을 통해 이 정보를 변경할 수 있습니다.

SETCLIENTID 및 SETCLIENTID\_CONFIRM 시퀀스가 ​​성공적으로 완료되면 클라이언트는 더 길고 덜 컴팩트한 nfs\_client\_id4 구조 대신 clientid4 유형의 단축 클라이언트 식별자를 사용합니다. 이 단축 클라이언트 식별자\(clientid\)는 서버에서 할당되며 이전에 서버에서 할당한 클라이언트 ID와 충돌하지 않도록 선택해야 합니다. 이는 서버를 다시 시작하거나 재부팅할 때마다 적용됩니다. 서버 재부팅 후 클라이언트 ID가 서버에 제공되고 해당 클라이언트 ID가 인식되지 않으면 서버는 NFS4ERR\_STALE\_CLIENTID 오류와 함께 요청을 거부합니다. 이 경우 클라이언트는 SETCLIENTID 작업을 사용하여 새 클라이언트 ID를 얻은 다음 서버 재부팅 사례에 필요한 기타 복구를 진행해야 합니다\("서버 오류 및 복구" 섹션 참조\).

또한 클라이언트는 현재 클라이언트 ID에서 파생된 상태 ID를 사용하여 NFS4ERR\_STALE\_STATEID 오류를 수신할 때 SETCLIENTID 작업을 사용해야 합니다. 이는 기존 클라이언트 ID를 무효화한 서버 재부팅을 나타내기 때문입니다\(자세한 내용은 다음 섹션 "lock\_owner 및 stateid 정의" 참조\). .

작업의 전체 사양은 SETCLIENTID 및 SETCLIENTID\_CONFIRM의 자세한 설명을 참조하세요.

---
#### **8.1.2.  Server Release of Clientid**

서버가 클라이언트가 해당 clientid와 관련된 상태를 보유하지 않는다고 판단하면 서버는 clientid를 해제하도록 선택할 수 있습니다. 서버는 간헐적으로 활성인 클라이언트가 자원을 소비하지 않도록 비활성 클라이언트에 대해 이 선택을 할 수 있습니다. 이 릴리스 이후에 클라이언트가 서버에 연결하는 경우 서버는 클라이언트가 적절한 오류를 수신하여 SETCLIENTID/SETCLIENTID\_CONFIRM 시퀀스를 사용하여 새 ID를 설정하도록 해야 합니다. 이러한 이벤트로부터 클라이언트를 복구하기 위한 결과 작업은 서버가 실패하고 다시 시작된 것과 동일한 부담이 되기 때문에 서버는 클라이언트 ID 해제를 매우 주저해야 한다는 점은 분명합니다. 일반적으로 서버는 해당 클라이언트에서 몇 분 동안 활동이 없으면 클라이언트 ID를 해제하지 않습니다.

SETCLIENTID 요청의 ID 문자열이 올바르게 구성되고 클라이언트가 SETCLIENTID를 연속적으로 사용할 때마다 동일한 주체를 사용하도록 주의를 기울이면 활성 서비스 거부 공격을 제외하고 NFS4ERR\_CLID\_INUSE가 반환되지 않아야 합니다.

그러나 클라이언트 버그, 서버 버그 또는 ID 문자열의 주요 소유자가 의도적으로 변경된 경우\(예: 보안 버전을 변경하는 클라이언트의 경우, 새 버전에서는 이전 소유자에 대한 매핑이 없음\) 드문 경우지만 NFS4ERR\_CLID\_INUSE가 발생합니다.

해당 이벤트에서 서버가 현재 상태가 없거나 상태가 있지만 임대가 만료된 클라이언트 ID에 대해 SETCLIENTID를 가져오는 경우 NFS4ERR\_CLID\_INUSE를 반환하는 대신 서버는 SETCLIENTID를 허용해야 하며 후속하는 경우 새 클라이언트 ID를 확인해야 합니다. 적절한 SETCLIENTID\_CONFIRM으로.\(MUST\)

---
#### **8.1.3.  lock_owner and stateid Definition**

잠금을 요청할 때 클라이언트는 클라이언트 ID와 요청된 잠금 소유자의 식별자를 서버에 제공해야 합니다. 이 두 필드는 lock\_owner라고 하며 해당 필드의 정의는 다음과 같습니다.

o 클라이언트의 SETCLIENTID 작업 사용의 일부로 서버에서 반환된 클라이언트 ID입니다.

o 클라이언트가 관리하는 잠금의 소유자를 고유하게 정의하는 데 사용되는 가변 길이 불투명 배열입니다.

- 스레드 ID, 프로세스 ID 또는 기타 고유 값일 수 있습니다.

서버가 잠금을 허용하면 고유한 stateid로 응답합니다. stateid는 서버가 둘 사이의 통신을 유지하므로 lock\_owner에 대한 간략한 참조로 사용됩니다.

서버는 유효하지 않고 오래된 stateid를 인식할 수 있는 한 원하는 방식으로 stateid를 자유롭게 구성할 수 있습니다. 이 요구 사항에는 서버의 이전 인스턴스에서 생성된 상태 ID가 포함됩니다. 이를 통해 클라이언트는 서버 다시 시작에 대한 적절한 알림을 받을 수 있습니다. 이 알림은 클라이언트가 이전 인스턴스화에서 서버에 stateid를 제공할 때 발생합니다.

서버는 다음 상황을 구별하고 지정된 대로 오류를 반환할 수 있어야 합니다.

o stateid는 이전 서버 인스턴스\(예: 서버 재부팅 전\)에 의해 생성되었습니다. NFS4ERR\_STALE\_STATEID 오류가 반환되어야 합니다.

o stateid는 현재 서버 인스턴스에 의해 생성되었지만 stateid는 더 이상 문제의 잠금 소유자-파일 쌍에 대한 현재 잠금 상태를 지정하지 않습니다\(즉, 하나 이상의 잠금 작업이 발생했습니다\). NFS4ERR\_OLD\_STATEID 오류가 반환되어야 합니다.

- 이 오류 조건은 해당 stateid를 사용하는 I/O 요청이 처리되지 않은 동안 클라이언트가 stateid를 변경하는 잠금 요청을 발행하는 경우에만 발생합니다.

o stateid는 현재 서버 인스턴스에 의해 생성되었지만 stateid는 활성 잠금 소유자-파일 쌍에 대한 잠금 상태를 지정하지 않습니다. NFS4ERR\_BAD\_STATEID 오류가 반환되어야 합니다.

- 이 오류 조건은 클라이언트 또는 서버 측에서 논리 오류가 발생한 경우 발생합니다. 이런 일이 일어나서는 안 됩니다.

이러한 요구 사항을 충족하는 데 사용할 수 있는 한 가지 메커니즘은 서버가 다음을 수행하는 것입니다.

o 각 stateid의 "other" 필드를 두 개의 필드로 나눕니다.

- - 특정 서버 인스턴스화를 고유하게 지정하는 서버 검증자입니다.

- - 잠금 상태 구조 테이블에 대한 인덱스입니다.

o 각 stateid의 "seqid" 필드를 활용하여 잠금 상태 테이블에 대한 동일한 인덱스와 연관된 각 stateid에 대해 seqid가 단조롭게 증가하도록 합니다.

들어오는 stateid와 해당 필드 값을 서버에 보관된 상태와 일치시킴으로써 서버는 stateid가 현재 인스턴스화 및 상태에 유효한지 쉽게 결정할 수 있습니다. stateid가 유효하지 않은 경우 클라이언트에 적절한 오류가 제공될 수 있습니다.

---
#### **8.1.4.  Use of the stateid and Locking**

모든 READ, WRITE 및 SETATTR 작업에는 stateid가 포함됩니다. 이 섹션의 목적에 따라 파일의 크기 속성을 변경하는 SETATTR 작업은 이전 크기와 새 크기 사이의 영역\(예: SETATTR을 통해 잘리거나 파일에 추가된 범위\)을 쓰는 것처럼 처리됩니다. SETATTR이 텍스트에 명시적으로 언급되지 않은 경우에도 마찬가지입니다.

lock\_owner가 서버에 잠금 또는 공유 예약을 설정한 상황에서 READ 또는 WRITE를 수행하는 경우\(모든 OPEN은 공유 예약을 구성함\) stateid\(이전에 서버에서 반환한\)를 사용하여 잠금을 포함하여 어떤 잠금을 표시해야 하는지 확인해야 합니다. 기록 잠금과 공유 예약은 모두 잠금 소유자가 보유합니다. 레코드 잠금이나 공유 예약 등 클라이언트가 상태를 설정하지 않은 경우 모든 비트가 0인 stateid가 사용됩니다. 모든 비트가 0인 stateid 또는 서버에서 반환된 stateid가 사용되는지 여부에 관계없이 파일에 충돌하는 공유 예약 또는 필수 레코드 잠금이 있는 경우 서버는 READ 또는 WRITE 작업 서비스를 거부해야 합니다.\(MUST\)

공유 예약은 OPEN 작업에 의해 설정되며 OPEN이 READ 또는 WRITE 작업을 거부하면 해당 작업이 NFS4ERR\_LOCKED 오류와 함께 거부된다는 점에서 본질적으로 필수입니다. 레코드 잠금은 서버에 의해 필수 또는 권고로 구현될 수 있으며, 필수 또는 권고 동작의 선택은 액세스되는 파일을 기반으로 서버에 의해 결정될 수 있습니다\(예를 들어 일부 UNIX 기반 서버는 "필수 잠금"을 지원합니다\) 모드 속성에 "bit"를 설정하면 I/O가 가능하기 전에 파일에 대한 레코드 잠금이 필요합니다. 레코드 잠금이 권장되는 경우 충돌하는 잠금 요청의 승인만 방지하고 읽기 또는 쓰기에는 영향을 미치지 않습니다. 그러나 필수 레코드 잠금은 I/O 작업 충돌을 방지합니다. 시도되면 NFS4ERR\_LOCKED로 거부됩니다. 클라이언트가 적절한 공유 예약이 있음을 알고 있는 파일에서 NFS4ERR\_LOCKED를 받으면 해당 지역에 대해 LOCK 요청을 발행해야 합니다.

I/O가 수행될 영역을 포함하는 파일의 적절한 잠금 유형\(예: READ 작업의 경우 READ\*\_LT, WRITE 작업의 경우 WRITE\*\_LT\).

NFS 버전 3에는 stateid 개념이 없었기 때문에 READ 또는 WRITE 작업을 보내는 클라이언트의 애플리케이션 프로세스가 파일에 대한 적절한 레코드 잠금도 획득했는지 알 수 있는 방법이 없었습니다. 따라서 강제 잠금을 구현할 방법이 없었습니다. stateid 구조를 사용하면 이 장벽이 제거되었습니다.

필수 파일 잠금을 지원하는 UNIX 환경의 경우 권고 잠금과 필수 잠금 간의 차이가 미묘합니다. 실제로 권고 및 필수 레코드 잠금은 API 및 구현 요구 사항과 완전히 동일합니다. 파일에 필수 잠금 속성이 설정된 경우 서버는 잠금 소유자가 읽거나 쓰려는 영역에 대해 적절한 공유\(읽기\) 또는 배타적\(쓰기\) 레코드 잠금을 가지고 있는지 확인합니다. 적절한 잠금이 없으면 서버는 충돌하는 잠금이 있는지 확인합니다\(잠금 소유자를 대신하여 충돌하는 잠금을 획득하려고 시도하고 성공하면 읽기 또는 쓰기가 완료된 후 잠금을 해제합니다\). , 존재하는 경우 서버는 NFS4ERR\_LOCKED를 반환합니다.

Windows 환경의 경우 권고 레코드 잠금이 없으므로 서버는 I/O 요청 중에 항상 레코드 잠금을 확인합니다.

따라서 NFS 버전 4 LOCK 작업에서는 권고 레코드 잠금과 필수 레코드 잠금을 구분할 필요가 없습니다. NFS 버전 4 서버의 READ 및 WRITE 작업 처리로 인해 구별이 이루어집니다.

OPEN 유형 작업\(예: OPEN, OPEN\_DOWNGRADE\) 또는 LOCK 유형 작업\(예: LOCK 또는 LOCKU\)에 의해 반환되는지 여부에 관계없이 이 섹션에 언급된 특수 stateid 값을 제외한 모든 stateid는 해당 항목에 대한 액세스 모드를 정의합니다. stateid 시퀀스를 시작한 원래 OPEN에 의해 ​​설정되고 해당 stateid 시퀀스 내의 후속 OPEN 및 OPEN\_DOWNGRADE에 의해 수정된 파일\(예: READ, WRITE 또는 READ-WRITE\)입니다. 크기 속성을 지정하는 READ, WRITE 또는 SETATTR이 완료되면 해당 작업은 해당 작업과 연관된 OPEN이 주어지면 해당 작업이 적절한지 확인하기 위해 액세스 모드를 검사하게 됩니다.

WRITE 유형 작업\(예: 크기를 설정하는 WRITE 및 SETATTR\)의 경우 서버는 액세스 모드가 쓰기를 허용하는지 확인하고 그렇지 않은 경우 NFS4ERR\_OPENMODE 오류를 반환해야 합니다. READ의 경우, 서버는 액세스 모드에서 해당 검사를 수행하거나 쓰기 구현이 불가피하게 수행될 수 있는 클라이언트를 수용하기 위해 쓰기 전용 열기에 대해 읽기를 허용하도록 선택할 수 있습니다.

읽기\(예: 버퍼 캐시 제약으로 인해\) 그러나 이러한 상황에서 READ가 허용되더라도 서버는 READ와 충돌하는 잠금\(예: READ에 대한 또 다른 공개 지정 거부\)을 계속 확인해야 합니다. 읽기 액세스에 대한 OPEN이 존재하면 충돌하는 공유 예약이 존재할 수 없음을 보장하므로 READ에 대한 액세스 모드 확인을 시행하는 서버는 충돌하는 공유 예약을 명시적으로 확인할 필요가 없습니다.\(MUST\)

모든 비트가 1인 stateid는 READ 작업이 서버의 잠금 검사를 우회하도록 허용할 수 있습니다. 그러나 비트가 모두 1인 stateid를 사용한 WRITE 작업은 잠금 검사를 우회해서는 안 되며 모든 비트가 0인 stateid가 사용된 것과 정확히 동일하게 처리됩니다.\(MAY, MUST NOT\)

특수 상태 ID 중 하나를 사용하는 READ 또는 WRITE 작업이 수행되고 잠금 요청 범위가 READ 또는 WRITE 작업 범위와 충돌하는 동안 잠금이 부여되지 않을 수 있습니다. 이 단락의 목적에 따라 공유 잠금이 요청되고 WRITE 작업이 수행되는 경우 또는 배타적 잠금이 요청되고 READ 또는 WRITE 작업이 수행되는 경우 충돌이 발생합니다. 크기를 설정하는 SETATTR은 위에서 설명한 WRITE와 유사하게 처리됩니다.

---
#### **8.1.5.  Sequencing of Lock Requests**

잠금에는 ONCRPC에서 제공하지 않는 "최대 1개" 의미 체계가 필요하므로 대부분의 NFS 작업과 다릅니다. 일련의 잠금 요청이 여러 TCP 연결에 걸쳐 있을 수 있으므로 안정적인 전송을 통한 ONCRPC는 충분하지 않습니다. 재전송 또는 재정렬 시 잠금 또는 잠금 해제 요청은 잘 정의되고 일관된 동작을 가져야 합니다. 이를 달성하기 위해 각 잠금 요청에는 연속적으로 증가하는 정수인 시퀀스 번호가 포함됩니다. lock\_owner마다 순서가 다릅니다. 서버는 수신된 마지막 시퀀스 번호\(L\)와 반환된 응답을 유지합니다. 지정된 lock\_owner에 대해 발행된 첫 번째 요청은 시퀀스 번호 0으로 발행됩니다.

시퀀스 번호가 포함된 요청의 경우 각 lock\_owner에 대해 미해결 요청이 1개 이하여야 합니다.

이전 시퀀스 번호\(r < L\)가 있는 요청\(r\)이 수신되면 NFS4ERR\_BAD\_SEQID 오류가 반환되면서 거부됩니다. 클라이언트가 올바르게 작동하는 경우 마지막 요청\(L\)이 전송되기 전에 \(r\)에 대한 응답이 수신되어야 합니다. 마지막 요청의 중복\(r == L\)이 수신되면 저장된 응답이 반환됩니다. 다음 시퀀스\(r == L + 2\)를 넘어서는 요청이 수신되면 NFS4ERR\_BAD\_SEQID 오류가 반환되면서 거부됩니다. SETCLIENTID/SETCLIENTID\_CONFIRM 시퀀스가 ​​클라이언트 검증자를 변경할 때마다 시퀀스 기록이 다시 초기화됩니다.

시퀀스 번호는 부호 없는 32비트 정수로 표시되므로 시퀀스 번호와 관련된 산술은 mod 2^32입니다. 시퀀스 번호와 관련된 모듈로 연산의 예는 \[RFC793\]을 참조하세요.

\[Juszczak\]에 설명된 기존 캐시보다 중복된 비멱등성 요청에 대한 보다 안정적인 캐시를 제공하기 위해 서버가 클라이언트에 전송된 마지막 응답을 유지하는 것이 중요합니다. 기존 중복 요청 캐시는 불필요한 요청을 제거하기 위해 가장 최근에 사용된 알고리즘을 사용합니다. 그러나 지정된 lock\_owner에 대한 마지막 잠금 요청 및 응답은 서버에 잠금 상태가 존재하는 한 캐시되어야 합니다.

클라이언트는 CLOSE, LOCK, LOCKU, OPEN, OPEN\_CONFIRM 및 OPEN\_DOWNGRADE 작업에 대한 시퀀스 번호를 단조롭게 증가시켜야 합니다. 이는 해당 시퀀스 번호를 사용한 이전 작업에서 오류가 발생한 경우에도 마찬가지입니다. 이 규칙의 유일한 예외는 이전 작업에서 NFS4ERR\_STALE\_CLIENTID, NFS4ERR\_STALE\_STATEID, NFS4ERR\_BAD\_STATEID, NFS4ERR\_BAD\_SEQID, NFS4ERR\_BADXDR, NFS4ERR\_RESOURCE, NFS4ERR\_NOFILEHANDLE 오류 중 하나를 받은 경우입니다.\(MUST\)

---
#### **8.1.6.  Recovery from Replayed Requests**

위에서 설명한 대로 시퀀스 번호는 lock\_owner별로 지정됩니다. 서버가 수신된 마지막 시퀀스 번호를 유지하고 위에서 설명한 방법을 따르는 한, 비잔틴 라우터가 오래된 요청을 다시 보낼 위험은 없습니다. 서버는 열려 있는 파일이나 잠금이 처리되지 않은 닫힌 파일이 있는 한 \(lock\_owner, 시퀀스 번호\) 상태만 유지하면 됩니다.

LOCK, LOCKU, OPEN, OPEN\_DOWNGRADE 및 CLOSE에는 각각 시퀀스 번호가 포함되어 있으므로 서버가 lock\_owner 상태를 유지하는 동안에는 이러한 작업이 재생되어 원하지 않는 결과를 초래할 위험이 존재하지 않습니다.

---
#### **8.1.7.  Releasing lock_owner State**

특정 lock\_owner가 더 이상 서버에서 열린 상태 또는 파일 잠금 상태를 유지하지 않으면 서버는 lock\_owner와 관련된 시퀀스 번호 상태를 해제하도록 선택할 수 있습니다. 서버는 임대 만료, 서버 메모리 회수 또는 기타 구현 관련 세부 사항을 기반으로 이 선택을 할 수 있습니다. 어떤 경우든 클라이언트가 lock\_owner를 더 이상 사용하지 않는 경우에만 서버는 이 작업을 안전하게 수행할 수 있습니다. 서버는 재전송된 요청이 수신되는 경우 lock\_owner 상태를 유지하도록 선택할 수 있습니다. 그러나 이 상태를 유지하는 기간은 구현에 따라 다릅니다.

서버가 이전에 lock\_owner 상태를 해제한 후 LOCK, LOCKU, OPEN\_DOWNGRADE 또는 CLOSE가 재전송되는 경우 서버는 lock\_owner에 열려 있는 파일이 없음을 확인하고 클라이언트에 오류가 반환됩니다. lock\_owner에 파일이 열려 있으면 stateid가 일치하지 않으며 클라이언트에 다시 오류가 반환됩니다.

---
#### **8.1.8.  Use of Open Confirmation**

OPEN이 재전송되고 lock\_owner가 처음으로 사용되거나 lock\_owner 상태가 서버에 의해 이전에 해제된 경우 OPEN\_CONFIRM 작업을 사용하면 잘못된 동작을 방지할 수 있습니다. 서버가 처음으로 lock\_owner의 사용을 관찰하면 해당 OPEN에 대해 OPEN\_CONFIRM을 수행하도록 클라이언트에 지시합니다. 이 시퀀스는 lock\_owner 및 관련 시퀀스 번호의 사용을 설정합니다. OPEN\_CONFIRM 시퀀스는 서버의 새 open\_owner를 클라이언트의 기존 open\_owner와 연결하므로 시퀀스 번호는 어떤 값이라도 가질 수 있습니다. OPEN\_CONFIRM 단계는 수신된 값이 올바른지 서버에 확인합니다. 자세한 내용은 "OPEN\_CONFIRM - 열기 확인" 섹션을 참조하세요.

OPEN을 확인하라는 요구 사항이 클라이언트와 서버에 어려움을 초래할 수 있는 상황이 많이 있습니다. 즉, 수신된 정보에 대해 적시에 조치를 취하지 못하게 될 수 있습니다. 왜냐하면 해당 정보는 잠정적이며 즉시 삭제될 수 있기 때문입니다. 비확인. 다행스럽게도 이러한 상황에서는 서버가 열기 요청에 응답할 때 확인이 필요하지 않습니다. 두 가지 제약 조건은 다음과 같습니다.

o 서버는 확인이 필요한 공개에 대해 위임을 부여해서는 안 됩니다.

o 서버는 회수 유형 열기\(즉, CLAIM\_PREVIOUS 또는 CLAIM\_DELEGATE\_PREV 클레임 유형을 지정하는 열기\)에 대한 확인을 요구해서는 안 됩니다.\(MUST NOT\)

이러한 제약 조건은 서버가 위임을 보내야 할 수 있는 유일한 재개 유형 열기와 관련되어 있습니다. CLAIM\_NULL의 경우 위임 보내기는 선택 사항이지만 CLAIM\_DELEGATE\_CUR의 경우 위임이 전송되지 않습니다.

확인이 필요한 공개와 함께 전송되는 위임은 비확인에서 복구하면 프로토콜에 과도한 복잡성을 추가하는 반면, 재생 유형 공개에 대한 확인을 요구하면 해결이 불가능하다는 점에서 어려움을 겪기 때문에 문제가 됩니다.

임대 만료까지의 회수 상태로 인해 회수되는 잠금 세트를 적시에 결정하는 것이 어려울 수 있습니다\(유예 기간이 만료될 수 있으므로\).

회수 유형 열기에 대한 열기 확인을 요구하는 것은 그러한 열기가 수행되는 환경의 특성으로 인해 피할 수 있습니다. CLAIM\_PREVIOUS 열기의 경우 이는 서버 재부팅 직후이므로 잠금 소유자가 생성되고, 사용되지 않은 것으로 확인되어 재활용될 시간이 없어야 합니다. CLAIM\_DELEGATE\_PREV가 열리면 클라이언트 재부팅 상황을 처리하고 있습니다. 위임을 지원하는 서버는 클라이언트 초기화 이후 해당 클라이언트에 대한 잠금 소유자가 재활용되지 않았음을 확인할 수 있으므로 확인이 필요하지 않음을 보장할 수 있습니다.

---
### **8.2.  Lock Ranges**

이 프로토콜을 사용하면 잠금 소유자가 바이트 범위의 잠금을 요청한 다음 초기 잠금의 하위 범위를 업그레이드하거나 잠금 해제할 수 있습니다. 이는 흔하지 않은 유형의 요청이 될 것으로 예상됩니다. 어떤 경우에도 서버 또는 서버 파일 시스템은 하위 범위 잠금 의미를 지원하지 못할 수 있습니다. 서버가 잠금 소유자에 대한 현재 잠금 상태의 하위 범위를 나타내는 잠금 요청을 수신하는 경우 서버는 하위 범위 잠금 작업을 지원하지 않음을 나타내기 위해 NFS4ERR\_LOCK\_RANGE 오류를 반환할 수 있습니다. 따라서 클라이언트는 이 오류를 받을 준비가 되어 있어야 하며, 적절한 경우 요청 응용 프로그램에 오류를 보고해야 합니다.

서버가 하위 범위 요청을 지원하지 않을 수 있고 서버 장애 시 파일 잠금 상태 복구와 관련된 이유로 인해 클라이언트는 단일 요청에 인접해 있는 여러 개의 독립적인 잠금 범위를 결합하는 것을 권장하지 않습니다. 아래 "서버 오류 및 복구" 섹션에서 설명한 대로 서버는 잠금 복구 중 클라이언트의 동작이 서버 오류 이전 클라이언트의 잠금 동작과 유사한 경우에만 효과적으로 작동하는 복구 중 특정 최적화를 사용할 수 있습니다.

---
### **8.3.  Upgrading and Downgrading Locks**

클라이언트가 레코드에 쓰기 잠금을 설정한 경우 유형을 READ\_LT로 설정하여 LOCK 요청을 통해 잠금을 읽기 잠금으로 원자적으로 다운그레이드하도록 요청할 수 있습니다. 서버가 원자성 다운그레이드를 지원하면 요청이 성공합니다. 그렇지 않은 경우 NFS4ERR\_LOCK\_NOTSUPP를 반환합니다. 클라이언트는 이 오류를 받을 준비가 되어 있어야 하며, 적절한 경우 요청 응용 프로그램에 오류를 보고해야 합니다.

클라이언트가 레코드에 대해 읽기 잠금을 설정한 경우 유형을 WRITE\_LT 또는 WRITEW\_LT로 설정하여 LOCK 요청을 통해 잠금을 쓰기 잠금으로 원자적으로 업그레이드하도록 요청할 수 있습니다. 서버가 원자성 업그레이드를 지원하지 않으면 NFS4ERR\_LOCK\_NOTSUPP를 반환합니다. 기존 충돌 없이 업그레이드를 수행할 수 있으면 요청이 성공합니다. 그렇지 않으면 서버는 NFS4ERR\_DENIED 또는 NFS4ERR\_DEADLOCK을 반환합니다. 클라이언트가 WRITEW\_LT로 설정된 유형으로 LOCK 요청을 발행하고 서버가 교착 상태를 감지한 경우 NFS4ERR\_DEADLOCK 오류가 반환됩니다. 클라이언트는 이러한 오류를 수신할 준비가 되어 있어야 하며 해당하는 경우 요청 응용 프로그램에 오류를 보고해야 합니다.

---
### **8.4.  Blocking Locks**

일부 클라이언트에는 차단 잠금 지원이 필요합니다. NFS 버전 4 프로토콜은 콜백 메커니즘에 의존해서는 안 되므로 이전에 거부된 잠금이 부여된 경우 클라이언트에 알릴 수 없습니다. 클라이언트는 계속해서 잠금을 폴링하는 것 외에는 선택의 여지가 없습니다. 이는 공정성 문제를 야기합니다. 두 가지 새로운 잠금 유형인 READW 및 WRITEW가 추가되었으며 이는 클라이언트가 차단 잠금을 요청하고 있음을 서버에 나타내는 데 사용됩니다. 서버는 보류 중인 차단 잠금의 정렬된 목록을 유지해야 합니다. 충돌하는 잠금이 해제되면 서버는 첫 번째 대기 클라이언트가 잠금을 다시 요청할 때까지 임대 기간을 기다릴 수 있습니다. 임대 기간이 만료된 후 다음 대기 클라이언트 요청에 잠금이 허용됩니다. 클라이언트는 적시에 잠금을 획득할 수 있도록 충분히 작은 간격으로 폴링해야 합니다. 서버는 공정성을 높이고 올바른 작업이 아닌 보류 중인 차단 잠금 목록을 유지 관리할 필요가 없습니다. 크래시 복구의 순서가 지정되지 않은 특성으로 인해 잠금 상태를 안정적인 저장소에 저장해야 차단 잠금의 순서가 부여되는 것을 보장할 수 있습니다.

또한 서버는 잠금 유형을 기록하고 요청 거부 반환을 지연하여 충돌하는 잠금이 해제될 때까지 추가 시간을 허용하여 성공적인 반환을 허용할 수 있습니다. 이러한 방식으로 클라이언트는 잠금 차단을 위해 불필요하게 자주 폴링하는 부담을 피할 수 있습니다. 서버는 클라이언트가 요청을 재전송하는 경우 지연 시간에 주의해야 합니다.

---
### **8.5.  Lease Renewal**

임대의 목적은 충돌했거나 연결할 수 없는 클라이언트가 보유하고 있는 오래된 잠금을 서버가 제거할 수 있도록 하는 것입니다. 이는 캐시 일관성을 위한 메커니즘이 아니며 임대 간격이 만료되지 않은 경우 임대 갱신이 거부되지 않을 수 있습니다.

다음 이벤트는 지정된 클라이언트\(즉, 지정된 클라이언트 ID를 공유하는 모든 클라이언트\)에 대한 모든 임대의 암시적 갱신을 유발합니다. 이들 각각은 클라이언트가 여전히 활성 상태이고 클라이언트에 대해 서버에서 유지되는 관련 상태가 여전히 유효하다는 긍정적인 표시입니다.

o 유효한 클라이언트 ID가 있는 OPEN.

o 유효한 상태 ID\(CLOSE, DELEGPURGE, DELEGRETURN, LOCK, LOCKU, OPEN, OPEN\_CONFIRM, OPEN\_DOWNGRADE, READ, RENEW, SETATTR, WRITE\)로 수행된 모든 작업. 여기에는 모든 비트 0 또는 모든 비트 1의 특수 상태 ID가 포함되지 않습니다.

- 클라이언트가 다시 시작되거나 재부팅된 경우 클라이언트는 SETCLIENTID/SETCLIENTID\_CONFIRM 시퀀스를 실행하지 않으면 이러한 요청을 수행하지 않습니다. SETCLIENTID/SETCLIENTID\_CONFIRM 시퀀스\(클라이언트 검증자를 변경하는 시퀀스\)를 사용하면 클라이언트와 관련된 잠금 상태를 삭제하도록 서버에 알립니다. SETCLIENTID/SETCLIENTID\_CONFIRM은 임대를 갱신하지 않습니다.

- 서버가 재부팅된 경우 상태 ID\(NFS4ERR\_STALE\_STATEID 오류\) 또는 클라이언트 ID\(NFS4ERR\_STALE\_CLIENTID 오류\)가 유효하지 않으므로 허위 갱신을 방지할 수 있습니다.

이 접근 방식을 사용하면 확장성이 뛰어난 낮은 간접비 임대 갱신이 가능합니다. 일반적인 경우 임대 갱신을 위해 추가 RPC 호출이 필요하지 않으며 최악의 경우 임대 기간마다 하나의 RPC가 필요합니다\(예: RENEW 작업\). 클라이언트의 모든 상태가 임대 갱신 작업과 관련되어 있으므로 클라이언트가 보유한 잠금 수는 요인이 아닙니다.

새 임대를 생성하는 모든 작업은 기존 임대도 갱신하므로 서버는 지정된 클라이언트에 대한 모든 유효한 임대에 대해 공통 임대 만료 시간을 유지해야 합니다. 이 임대 시간은 암시적 임대 갱신 작업 시 쉽게 업데이트될 수 있습니다.

---
### **8.6.  Crash Recovery**

충돌 복구의 중요한 요구 사항은 클라이언트와 서버 모두 상대방이 언제 실패했는지 알 수 있어야 한다는 것입니다. 또한 클라이언트는 서버가 다시 시작되거나 재부팅되는 동안 일관된 데이터 보기를 볼 수 있어야 합니다. 클라이언트 또는 네트워크 버퍼 내에서 대기열에 있을 수 있는 모든 읽기 및 쓰기 작업은 클라이언트가 읽기 및 쓰기 작업을 보호하는 잠금을 성공적으로 복구할 때까지 기다려야 합니다.

---
#### **8.6.1.  Client Failure and Recovery**

클라이언트에 오류가 발생하는 경우 관련 임대가 만료되면 서버는 클라이언트의 잠금을 복구할 수 있습니다. 다른 클라이언트의 잠금 충돌은 이 임대 만료 후에만 부여될 수 있습니다. 클라이언트가 임대 기간 내에 다시 시작하거나 다시 초기화할 수 있는 경우 클라이언트는 새 잠금을 얻기 전에 남은 임대 기간 동안 기다려야 할 수 있습니다.

다시 시작 시 클라이언트 지연을 최소화하기 위해 잠금 요청은 클라이언트 제공 검증자에 의해 클라이언트 인스턴스와 연결됩니다. 이 검증자는 클라이언트가 수행한 초기 SETCLIENTID 호출의 일부입니다. 서버는 SETCLIENTID 작업의 결과로 clientid를 반환합니다. 그런 다음 클라이언트는 SETCLIENTID\_CONFIRM을 사용하여 clientid 사용을 확인합니다. 클라이언트는 불투명 소유자 필드와 결합된 clientid를 사용하여 OPEN에 대한 잠금 소유자를 식별합니다. 그런 다음 이 연관 체인은 특정 클라이언트에 대한 모든 잠금을 식별하는 데 사용됩니다.

검증자는 초기화할 때마다 클라이언트에 의해 변경되므로 서버는 새 검증자를 현재 보유된 잠금과 관련된 검증자와 비교하여 일치하지 않는지 결정할 수 있습니다. 이는 클라이언트의 새로운 인스턴스화 및 그에 따른 잠금 상태 손실을 나타냅니다. 결과적으로 서버는 이전 검증자에서 파생된 이전 클라이언트 ID와 관련된 모든 잠금을 자유롭게 해제할 수 있습니다.

검증자는 COMMIT 작업에 대해 검증자와 동일한 고유성 속성을 가지고 있어야 합니다.

---
#### **8.6.2.  Server Failure and Recovery**

서버가 잠금 상태를 잃으면\(일반적으로 다시 시작 또는 재부팅의 결과로\) 클라이언트가 이 사실을 발견하고 손실된 잠금 상태를 다시 설정할 시간을 허용해야 합니다. 서버가 다른 클라이언트에 충돌하는 액세스 권한을 부여했기 때문에 서버가 유효한 요청을 거부하지 않고도 클라이언트는 잠금 상태를 다시 설정할 수 있어야 합니다. 마찬가지로 클라이언트가 아직 파일에 대한 잠금 상태를 다시 설정하지 않았을 가능성이 있는 경우 서버는 해당 파일에 대한 읽기 및 쓰기 작업을 허용하지 않아야 합니다. 이 복구 기간은 임대 기간과 동일합니다.

클라이언트는 두 가지 오류 중 하나를 수신하면 서버 오류\(따라서 잠금 상태 손실\)가 발생했음을 확인할 수 있습니다. NFS4ERR\_STALE\_STATEID 오류는 재부팅 또는 재시작으로 인해 무효화된 상태 ID를 나타냅니다. NFS4ERR\_STALE\_CLIENTID 오류는

재부팅 또는 다시 시작으로 인해 클라이언트 ID가 무효화되었습니다. 이들 중 하나가 수신되면 클라이언트는 새 클라이언트 ID\("클라이언트 ID" 섹션 참조\)를 설정하고 아래 설명된 대로 잠금 상태를 다시 설정해야 합니다.

임대 기간과 동일한 잠금, 읽기 및 쓰기의 특별 처리 기간을 "유예 기간"이라고 합니다. 유예 기간 동안 클라이언트는 회수 유형 잠금 요청\(즉, 회수가 true로 설정된 LOCK 요청 및 클레임 유형이 CLAIM\_PREVIOUS인 OPEN 작업\)을 통해 잠금 및 관련 상태를 복구합니다. 유예 기간 동안 서버는 NFS4ERR\_GRACE 오류와 함께 READ 및 WRITE 작업과 비재확보 잠금 요청\(예: 기타 LOCK 및 OPEN 작업\)을 거부해야 합니다.

비재확보 요청을 승인하는 것이 다른 클라이언트의 잠금 재확보와 충돌하지 않는다는 것을 서버가 안정적으로 결정할 수 있는 경우 NFS4ERR\_GRACE 오류가 반환될 필요가 없으며 비재확보 클라이언트 요청을 처리할 수 있습니다. 서버가 유예 기간 동안 읽기 및 쓰기 작업을 서비스할 수 있으려면 임박한 회수 잠금 요청과 읽기 또는 쓰기 작업 간에 충돌이 발생할 수 없음을 다시 보장할 수 있어야 합니다. 서버가 해당 보증을 제공할 수 없는 경우 NFS4ERR\_GRACE 오류가 클라이언트에 반환되어야 합니다.

서버가 유예 기간 동안 간단하고 유효한 처리를 제공하는 가장 쉬운 방법은 NFS4ERR\_GRACE 오류를 반환하여 모든 비재확보 잠금 요청과 READ 및 WRITE 작업을 거부하는 것입니다. 그러나 서버는 부여된 잠금에 대한 정보를 안정적인 저장소에 보관할 수 있습니다. 이 정보를 사용하여 서버는 일반 잠금이나 READ 또는 WRITE 작업을 안전하게 처리할 수 있는지 확인할 수 있습니다.

예를 들어, 특정 파일에 대한 잠금 수를 안정적인 저장소에서 사용할 수 있는 경우 서버는 파일에 대해 회수된 잠금을 추적할 수 있으며 모든 회수가 처리되면 회수되지 않은 잠금 요청이 처리될 수 있습니다. 이런 방식으로 서버는 비재확보 잠금 요청이 잠재적인 재확보 요청과 충돌하지 않도록 보장할 수 있습니다. I/O 요청과 관련하여 서버가 안정적인 저장소 또는 다른 유사한 메커니즘의 정보를 통해 파일에 대해 처리되지 않은 회수 요청이 없음을 확인할 수 있는 경우 해당 파일에 대해 I/O 요청 처리가 정상적으로 진행될 수 있습니다.

다시 말하면, 유예 기간 동안 비재확보 잠금 및 I/O 요청 처리를 허용하는 서버의 경우, 이후에 재확보된 잠금이 거부되지 않고 이후에 재확보된 잠금이 I/O 작업을 방해하지 않았는지 결정해야 합니다. 유예기간 동안 처리됩니다.\(MUST\)

클라이언트는 비재확보 잠금 및 I/O 요청에 대한 NFS4ERR\_GRACE 오류 반환에 대비해야 합니다. 이 경우 클라이언트는 요청에 대한 재시도 메커니즘을 사용해야 합니다. 서버에 부담을 주지 않으려면 재시도 사이에 몇 초 정도의 지연 시간을 두어야 합니다. 일반적인 문제에 대한 추가 논의는 \[Floyd\]에 포함되어 있습니다. 클라이언트는 유예 기간 내에 I/O 및 비재확보 잠금 요청을 수행할 수 있는 서버와 그렇게 할 수 없는 서버를 모두 고려해야 합니다.

서버의 유예 기간 이외의 회수 유형 잠금 요청은 서버가 재부팅 또는 재시작 이후 충돌하는 잠금이나 I/O 요청이 승인되지 않았음을 보장할 수 있는 경우에만 성공할 수 있습니다.

서버는 재시작 시 임대 기간에 대한 새로운 값을 설정할 수 있습니다. 따라서 클라이언트는 새 clientid가 설정되면 Lease\_time 속성을 다시 가져와 해당 서버와 관련된 임대에 대한 임대 갱신의 기초로 사용해야 합니다. 그러나 서버는 이 다시 시작 이벤트에 대해 최소한 이전 서버 인스턴스화에 대한 임대 기간만큼 긴 유예 기간을 설정해야 합니다. 이를 통해 이전 서버 인스턴스에서 얻은 클라이언트 상태를 안정적으로 다시 설정할 수 있습니다.

---
#### **8.6.3.  Network Partitions and Recovery**

네트워크 파티션 기간이 서버에서 제공한 임대 기간보다 길면 서버는 클라이언트로부터 임대 갱신을 받지 못한 것입니다. 이런 일이 발생하면 서버는 클라이언트에 대해 보유된 모든 잠금을 해제할 수 있습니다. 결과적으로 클라이언트가 보유한 모든 stateid는 유효하지 않거나 유효하지 않게 됩니다. 이러한 네트워크 분할 후 클라이언트가 서버에 도달할 수 있게 되면 클라이언트가 현재 유효하지 않은 상태 ID로 제출한 모든 I/O는 실패하고 서버는 NFS4ERR\_EXPIRED 오류를 반환합니다. 이 오류가 수신되면 클라이언트는 잠금을 보유한 응용 프로그램에 적절하게 알립니다.

클라이언트에 대한 배려 또는 최적화의 일환으로 서버는 최근 통신이 임대 기간을 초과하여 연장된 클라이언트를 대신하여 계속 잠금을 보유할 수 있습니다. 서버가 이러한 무료 잠금 중 하나와 충돌하는 잠금 또는 I/O 요청을 받으면 서버는 무료 잠금을 해제하고 새 요청을 승인해야 합니다.

네트워크 파티션이 서버 재부팅과 결합되면 서버 재부팅 후 자동 데이터 손상을 방지하기 위해 서버에 요구 사항을 적용하는 엣지 조건이 있습니다. 이러한 에지 조건 중 두 가지는 알려져 있으며 아래에서 설명합니다.

첫 번째 경계 조건에는 다음과 같은 시나리오가 있습니다.

- 1. 클라이언트 A가 잠금을 획득합니다.

- 2. 클라이언트 A와 서버는 상호 네트워크 분할을 경험하므로 클라이언트 A는 임대를 갱신할 수 없습니다.

- 3. 클라이언트 A의 임대가 만료되어 서버가 잠금을 해제합니다.

- 4. 클라이언트 B는 클라이언트 A의 잠금과 충돌할 수 있는 잠금을 획득합니다.

- 5. 클라이언트 B가 잠금을 해제합니다.

```text
      6. Server reboots
```

- 7. 클라이언트 A와 서버 간의 네트워크 파티션이 복구됩니다.

8. 클라이언트 A는 RENEW 작업을 실행하고

- NFS4ERR\_STALE\_CLIENTID.

- 9. 클라이언트 A는 서버의 유예 기간 내에 잠금을 회수합니다.

따라서 마지막 단계에서 서버는 클라이언트 A의 잠금 회수를 잘못 허용했습니다. 클라이언트 B가 잠금으로 보호하는 개체를 수정한 경우 클라이언트 A는 개체 손상을 경험하게 됩니다.

두 번째로 알려진 경계 조건은 다음과 같습니다.

- 1. 클라이언트 A가 잠금을 획득합니다.

```text
      2. Server reboots.
```

- 3. 클라이언트 A와 서버는 상호 네트워크 분할을 경험하므로 클라이언트 A는 유예 기간 내에 잠금을 회수할 수 없습니다.

- 4. 서버의 회수 유예 기간이 종료됩니다. 클라이언트 A에는 서버에 기록된 잠금이 없습니다.

- 5. 클라이언트 B는 클라이언트 A의 잠금과 충돌할 수 있는 잠금을 획득합니다.

- 6. 클라이언트 B가 잠금을 해제합니다.

- 7. 서버가 두 번째로 재부팅됩니다.

- 8. 클라이언트 A와 서버 간의 네트워크 파티션이 복구됩니다.

9. 클라이언트 A는 RENEW 작업을 실행하고

- NFS4ERR\_STALE\_CLIENTID.

10. 클라이언트 A는 서버의 유예 기간 내에 잠금을 회수합니다.

첫 번째 경계 조건과 마찬가지로 두 번째 경계 조건 시나리오의 마지막 단계에서는 서버가 클라이언트 A의 잠금 회수를 잘못 승인했습니다.

첫 번째 및 두 번째 엣지 조건을 해결하려면 서버가 재부팅 후 엣지 조건이 발생했다고 가정하여 모든 회수 시도에 대해 NFS4ERR\_NO\_GRACE를 반환하거나 서버가 일부 정보를 안정적인 저장소에 기록해야 합니다. 서버가 안정적인 저장소에 기록하는 정보의 양은 엣지 조건이 발생할 때마다 서버가 원하는 정도에 반비례합니다. 모든 에지 조건을 완벽하게 허용하는 서버는 획득된 모든 잠금을 안정적인 저장소에 기록합니다. 클라이언트가 잠금을 해제하고 잠금의 잠금 소유자가 잠금 해제를 위해 시퀀스 번호를 앞당기는 경우에만 안정적인 저장소에서 잠금 기록을 제거합니다. 잠금 소유자 시퀀스에 대한 마지막 상태 저장 이벤트가 아닙니다. 앞서 언급한 두 가지 엣지 조건의 경우 서버가 가장 가혹할 수 있고 여전히 회수 유예 기간을 지원하려면 서버가 안정적인 저장 정보에 최소한의 정보를 기록해야 합니다. 예를 들어, 서버 구현은 각 클라이언트에 대해 다음을 포함하는 레코드를 안정적인 저장소에 저장할 수 있습니다.

o 클라이언트의 ID 문자열

o 클라이언트의 임대가 만료되었는지 또는 레코드 잠금, 공유 예약 또는 위임을 취소하기 위한 관리 개입\(서버 잠금 취소 섹션 참조\)이 있었는지 여부를 나타내는 부울

o 서버 부팅 또는 재부팅 후 처음으로 업데이트되는 타임스탬프 클라이언트는 서버에서 레코드 잠금, 공유 예약 또는 위임 상태를 획득합니다. 서버가 재부팅될 때까지 후속 잠금 요청 시 타임스탬프를 업데이트할 필요가 없습니다.

서버 구현은 또한 최근 두 번의 서버 재부팅의 타임스탬프를 안정적인 저장소에 기록합니다.

위의 기록 유지를 가정하면 첫 번째 엣지 조건의 경우 서버 재부팅 후 클라이언트 A의 임대가 만료되었다는 기록은 다른 클라이언트가 충돌하는 기록 잠금, 공유 예약 또는 위임을 획득했을 수 있음을 의미합니다. 따라서 서버는 NFS4ERR\_NO\_GRACE 오류와 함께 클라이언트 A의 회수를 거부해야 합니다.

두 번째 경계 조건의 경우 서버가 두 번째로 재부팅된 후 클라이언트가 만료되지 않은 레코드 잠금, 공유 예약 또는 서버의 이전 구현 이전에 설정된 위임을 가지고 있다는 기록은 서버가 클라이언트 A의 회수를 거부해야 함을 의미합니다. 오류 NFS4ERR\_NO\_GRACE.

기록 보관 수준 및 접근 방식에 관계없이 서버는 다음 전략 중 하나를 구현해야 합니다\(공유 예약 회수, 기록 잠금 및 위임에 적용됨\).\(MUST\)

- 1. NFS4ERR\_NO\_GRACE로 모든 회수를 거부합니다. 이는 매우 가혹한 방법이지만 서버가 안정적인 저장소에 잠금 상태를 기록하지 않으려는 경우 필요합니다.

- 2. 이 섹션에 언급된 두 가지를 포함하여 서버 재부팅과 관련된 모든 알려진 엣지 조건이 감지되도록 안정적인 저장소에 충분한 상태를 기록합니다. 거짓 긍정은 허용됩니다. 현재로서는 다른 엣지 조건이 있는지는 알 수 없습니다.

- 서버 재부팅 후 서버는 안정적인 저장소에 복구할 수 없는 손상이나 손상이 있다고 판단한 경우 영향을 받은 모든 클라이언트 및/또는 잠금에 대해 서버는 NFS4ERR\_NO\_GRACE를 반환해야 합니다.\(MUST\)

클라이언트의 NFS4ERR\_NO\_GRACE 오류 처리에 대한 명령은 이 사양의 범위를 벗어납니다. 이러한 처리 전략은 클라이언트의 운영 환경에 따라 크게 달라지기 때문입니다. 그러나 한 가지 잠재적인 접근 방식이 아래에 설명되어 있습니다.

클라이언트가 NFS4ERR\_NO\_GRACE를 수신하면 클라이언트가 상태를 회수하려고 하는 객체의 변경 속성을 검사하고 이를 사용하여 일반 OPEN 또는 LOCK 요청을 통해 상태를 다시 설정할지 여부를 결정할 수 있습니다. 이는 클라이언트의 운영 환경이 허용하는 경우 허용됩니다. 즉, 클라이언트 구현자는 사용자를 위해 동작을 문서화하는 것이 좋습니다. 클라이언트는 UNIX 신호, GUI 팝업 창 등을 통해 레코드 잠금 또는 공유 예약\(위임 여부에 관계 없이\)이 손실되었음을 애플리케이션에 알릴 수도 있습니다. "데이터 캐싱 및 데이터 캐싱" 섹션을 참조하세요. 클라이언트 상태에서 회수되지 않은 위임을 처리하기 위해 클라이언트가 수행해야 하는 작업에 대한 논의는 취소'를 참조하세요.

잠금 취소에 대한 자세한 내용은 "서버 잠금 취소" 섹션을 참조하세요.

---
### **8.7.  Recovery from a Lock Request Timeout or Abort**

잠금 요청 시간이 초과되는 경우 클라이언트는 요청을 재시도하지 않기로 결정할 수 있습니다. 클라이언트는 요청이 발행된 프로세스가 종료될 때\(예: UNIX에서 신호로 인해\) 요청을 중단할 수도 있습니다. 서버가 요청을 수신하고 이에 따라 조치를 취했을 수도 있습니다. 이렇게 하면 클라이언트가 변경 사항을 인식하지 못한 채 서버의 상태가 변경됩니다. 클라이언트가 동일한 lock\_owner를 사용하여 seqid 및/또는 stateid를 사용하는 다른 작업을 시도하기 전에 상태를 서버와 다시 동기화하는 것이 가장 중요합니다. 이는 특별한 재동기화 작업 없이도 간단하게 수행할 수 있습니다.

서버는 lock\_owner에서 받은 마지막 잠금 요청과 응답을 유지 관리하므로 각 lock\_owner에 대해 클라이언트는 잠금 요청이 응답을 받지 않도록 보낸 마지막 잠금 요청을 캐시해야 합니다. 이로부터 다음에 클라이언트가 lock\_owner에 대한 잠금 작업을 수행할 때 캐시된 요청을 보낼 수 있습니다\(있는 경우\). 요청이 설정된 상태\(예: LOCK 또는 OPEN 작업\)인 경우 서버는 캐시된 결과를 반환하거나, 요청을 본 적이 없다면 이를 수행하세요. 클라이언트는 상태 제거 요청\(예: LOCKU 또는 CLOSE 작업\)을 수행할 수 있습니다. 이 접근 방식을 사용하면 지정된 lock\_owner에 대한 클라이언트와 서버의 순서 및 상태 ID 정보가 다시 동기화되고 잠금 상태도 다시 동기화됩니다.

---
### **8.8.  Server Revocation of Locks**

언제든지 서버는 클라이언트가 보유한 잠금을 취소할 수 있으며 클라이언트는 이 이벤트에 대비해야 합니다. 클라이언트가 잠금이 취소되었거나 취소되었을 수 있음을 감지하면 클라이언트는 자신과 서버 간의 상태 정보를 검증해야 합니다. 클라이언트의 잠금 상태를 검증한다는 것은 클라이언트가 현재 보유하고 있는 각 잠금의 상태를 확인하거나 회수해야 함을 의미합니다.

잠금 해제의 첫 번째 인스턴스는 서버 재부팅 또는 재초기화 시 발생합니다. 이 경우 클라이언트는 오류\(NFS4ERR\_STALE\_STATEID 또는 NFS4ERR\_STALE\_CLIENTID\)를 수신하고 클라이언트는 이전 섹션에서 설명한 대로 일반적인 충돌 복구를 진행합니다.

두 번째 잠금 취소 이벤트는 만료 전에 임대를 갱신할 수 없는 것입니다. 이는 드물거나 특이한 사건으로 간주되지만 고객은 회복할 준비가 되어 있어야 합니다. 서버와 클라이언트 모두 임대 갱신 실패를 감지하고 데이터 손상 없이 복구할 수 있습니다. 서버의 경우 클라이언트에 대해 서비스된 마지막 갱신 이벤트를 추적하고 임대가 만료되는 시기를 알고 있습니다. 마찬가지로 클라이언트는 다음 작업을 추적해야 합니다.

임대 기간을 갱신합니다. 각 요청이 전송된 시간과 해당 응답이 수신된 시간을 사용하여 클라이언트는 해당 갱신이 서버에서 발생할 수 있는 시간을 제한하여 임대 기간 만료가 발생할 수 있는지 확인해야 합니다. .

세 번째 잠금 해제 이벤트는 임대 기간 내에 관리자 개입의 결과로 발생할 수 있습니다. 이는 드문 사건으로 간주되지만 서버 관리자가 클라이언트가 보유한 특정 잠금을 해제하거나 취소하기로 결정했을 수도 있습니다. 취소의 결과로 클라이언트는 NFS4ERR\_ADMIN\_REVOKED 오류를 수신하게 됩니다. 이 경우 클라이언트는 lock\_owner의 잠금만 손실되었다고 가정할 수 있습니다. 클라이언트는 잠금 보유자에게 적절하게 알립니다. 클라이언트는 작업 실패로 인해 임대 기간이 갱신되었다고 가정할 수 없습니다.

클라이언트가 임대 기간이 만료되었다고 판단하면 클라이언트는 관련 임대에 대해 보유된 모든 잠금을 "유효하지 않음"으로 표시해야 합니다. 이는 클라이언트가 서버에 대한 적절한 잠금 상태를 다시 설정하거나 확인할 수 없음을 의미합니다. 충돌 복구에 대한 이전 섹션에서 설명한 대로 클라이언트에 대한 임대 기간이 만료된 후 서버가 충돌하는 잠금을 부여할 수 있는 시나리오가 있습니다. 임대 기간이 만료되었을 가능성이 있는 경우 클라이언트는 현재 보유하고 있는 각 잠금의 유효성을 검사하여 충돌하는 잠금이 부여되지 않았는지 확인해야 합니다. 클라이언트는 문제의 잠금과 관련된 stateid를 지정하여 보류 중인 I/O 또는 길이가 0인 읽기인 I/O 요청을 발행하여 이 작업을 수행할 수 있습니다. 요청에 대한 응답이 성공하면 클라이언트는 해당 stateid에 의해 관리되는 모든 잠금의 유효성을 검사하고 자체와 서버 간의 적절한 상태를 다시 설정합니다.

I/O 요청이 성공하지 못한 경우 stateid와 관련된 잠금 중 하나 이상이 서버에 의해 취소되었으며 클라이언트는 소유자에게 이를 알려야 합니다.

---
### **8.9.  Share Reservations**

공유 예약은 파일에 대한 액세스를 제어하는 ​​메커니즘입니다. 이는 레코드 잠금과 별개의 독립된 메커니즘입니다. 클라이언트가 파일을 열면 필요한 액세스 유형\(READ, WRITE 또는 BOTH\)과 다른 액세스 유형을 거부하는 액세스 유형\(NONE, READ, WRITE 또는 BOTH 거부\)을 지정하여 서버에 OPEN 작업을 실행합니다. OPEN이 실패하면 클라이언트는 애플리케이션의 열기 요청에 실패합니다.

의미론의 의사 코드 정의:

```text
   if (request.access == 0)
      return (NFS4ERR_INVAL)

   else
      if ((request.access & file_state.deny)) ||
            (request.deny & file_state.access))
                    return (NFS4ERR_DENIED)
```

OPEN에 대한 공유 예약 확인은 동일한 open\_owner에 대한 기존 OPEN에 대해 예외 없이 수행됩니다.

액세스 및 거부 필드에 대한 OPEN 및 OPEN\_DOWNGRADE 작업에 사용되는 상수는 다음과 같습니다.

```text
   const OPEN4_SHARE_ACCESS_READ   = 0x00000001;
   const OPEN4_SHARE_ACCESS_WRITE  = 0x00000002;
   const OPEN4_SHARE_ACCESS_BOTH   = 0x00000003;

   const OPEN4_SHARE_DENY_NONE     = 0x00000000;
   const OPEN4_SHARE_DENY_READ     = 0x00000001;
   const OPEN4_SHARE_DENY_WRITE    = 0x00000002;
   const OPEN4_SHARE_DENY_BOTH     = 0x00000003;
```

---
### **8.10.  OPEN/CLOSE Operations**

올바른 공유 의미를 제공하려면 클라이언트는 OPEN 작업을 사용하여 초기 파일 핸들을 얻고 원하는 액세스와 거부할 액세스를 표시해야 합니다. 클라이언트가 모두 0 또는 모두 1인 상태 ID를 사용하려는 경우에도 적절한 공유 의미가 적용될 수 있도록 OPEN 작업을 통해 일반 파일에 대한 파일 핸들을 얻어야 합니다. 개방형 프로그래밍 인터페이스에 기본 거부 모드가 없는 클라이언트의 경우 NONE과 동일한 거부를 사용해야 합니다.\(MUST\)

CREATE 플래그를 사용한 OPEN 작업은 이전 버전의 NFS 프로토콜에서 사용된 일반 파일에 대한 CREATE 작업도 포함합니다. 이를 통해 공유를 통한 생성이 원자적으로 수행될 수 있습니다.

CLOSE 작업은 해당 파일에 대해 lock\_owner가 보유한 모든 공유 예약을 제거합니다. 레코드 잠금이 유지되면 클라이언트는 CLOSE를 발행하기 전에 모든 잠금을 해제해야 합니다. 서버는 CLOSE 시 모든 미해결 잠금을 해제할 수 있지만 일부 서버는 여전히 레코드 잠금이 유지된 파일의 CLOSE를 지원하지 않을 수 있습니다. CLOSE 이후 잠금이 존재하는 경우 서버는 실패 NFS4ERR\_LOCKS\_HELD를 반환해야 합니다.\(SHOULD, MAY, MUST\)

LOOKUP 작업은 서버에 잠금 상태를 설정하지 않고 파일 핸들을 반환합니다. 유효한 stateid가 없으면 서버는 클라이언트의 액세스 권한이 가장 적다고 가정합니다. 예를 들어, 파일

READ/WRITE 거부로 열린 파일 핸들은 유효한 stateid가 없기 때문에 LOOKUP을 통해 얻은 파일 핸들을 사용하여 액세스할 수 없습니다\(즉, 모든 비트가 0이거나 모든 비트가 1인 stateid를 사용함\).

---
#### **8.10.1.  Close and Retention of State Information**

CLOSE 작업은 stateid 할당 해제를 요청하고 CLOSE 재전송을 처리하는 데 특별한 어려움을 초래할 수 있습니다. 일반적으로 지정되는 열린 파일의 상태를 결정하는 데 사용되는 상태 정보가 할당 해제되어 다음과 같은 결과가 발생할 수 있기 때문입니다. NFS4ERR\_BAD\_STATEID 오류.

서버는 다양한 방법으로 이 문제를 처리할 수 있습니다. 프로토콜이 적절하게 사용되고 있다는 최대한의 보증을 제공하기 위해 서버는 stateid를 할당 해제하는 대신 이를 마감 보류로 표시하고 나중에 할당 해제될 때까지 이 상태로 stateid를 유지해야 합니다. 이런 방식으로 재전송된 CLOSE를 stateid가 이러한 고유한 상태의 상태 정보를 가리키므로 인식할 수 있어 오류 없이 처리할 수 있습니다.

이 전략을 채택할 때 서버는 다음 중 가장 빠른 시점까지 상태 정보를 유지해야 합니다.

o 동일한 잠금 소유자에 대해 유효하게 순서가 지정된 또 다른 요청으로, 이는 재전송이 아닙니다.

o 활동이 없는 기간으로 인해 잠금 소유자가 서버에 의해 해제된 시간입니다.

o SETCLIENTID의 결과로 클라이언트에 대한 모든 잠금이 해제됩니다.

서버는 이 경우가 재전송된 종료로 인해 발생해야 한다는 가정 하에 할당 취소된 stateid에 대한 CLOSE 이벤트에서 단순히 NFS4\_OK에 응답함으로써 덜 완전한 프로토콜 오류 검사를 수행함으로써 이러한 복잡성을 피할 수 있습니다. 이 접근 방식을 채택할 때 이 상황에서 오류 없음 표시를 반환할 때 최소한 오류를 기록하는 것이 바람직합니다. 서버가 응답 캐시 메커니즘을 유지하는 경우 CLOSE가 실제로 재전송인지 확인하고 대부분의 경우 오류 로깅을 방지할 수 있습니다.

---
### **8.11.  Open Upgrade and Downgrade**

파일에 대해 OPEN이 수행되고 열기가 수행되는 잠금 소유자가 이미 파일을 연 경우 결과는 새 OPEN에 지정된 액세스 및 거부 비트를 포함하도록 서버에서 유지 관리되는 열린 파일 상태를 업그레이드하는 것입니다. 기존 OPEN도 마찬가지다. 결과적으로 프로토콜에 관한 한 하나의 열린 파일이 있으며 여기에는 액세스 및 액세스의 통합이 포함됩니다.

완료된 모든 OPEN 요청에 대한 거부 비트입니다. 두 OPEN의 효과를 재설정하기 위해 단 한 번의 CLOSE만 수행됩니다. OPEN을 실행할 때 클라이언트는 동일한 파일이 실제로 열려 있다는 사실을 알지 못할 수도 있습니다. 위의 내용은 두 OPEN으로 인해 OPENed 개체가 동일한 파일 핸들로 지정되는 경우에만 적용됩니다.

서버가 동일한 파일 객체에 해당하는 여러 파일 핸들을 내보내도록 선택하고 동일한 파일 객체의 두 개의 다른 OPEN에서 서로 다른 파일 핸들을 반환하는 경우 서버는 액세스 비트와 거부 비트를 함께 "OR"하여 열려 있는 두 파일을 통합해서는 안 됩니다. 대신 서버는 별도의 stateid를 사용하여 별도의 OPEN을 유지해야 하며 이를 해제하려면 별도의 CLOSE가 필요합니다.\(MUST NOT\)

클라이언트에 있는 여러 개의 열린 파일이 서버에 있는 단일 열린 파일 개체로 병합된 경우 클라이언트에 있는 열린 파일 중 하나를 닫으면 서버에 있는 열린 파일의 액세스 및 거부 상태가 변경되어야 할 수 있습니다. 이는 나머지 열기에 대한 액세스 및 거부 비트의 결합이 이전보다 더 작을 수 있기 때문입니다\(즉, 적절한 하위 집합\). OPEN\_DOWNGRADE 작업은 필요한 변경을 수행하는 데 사용되며 클라이언트는 이를 사용하여 다른 클라이언트의 공유 예약 요청이 올바르게 처리되도록 서버를 업데이트해야 합니다.

---
### **8.12.  Short and Long Leases**

서버 임대 기간을 결정할 때 일반적인 임대 절충안이 적용됩니다. 짧은 임대는 RENEW 또는 READ\(길이가 0인\) 요청을 늘리는 대신 빠른 서버 복구에 적합합니다. 임대 기간이 길어질수록 매우 많은 수의 클라이언트를 처리하려는 서버에 확실히 더 친절하고 온화해집니다. RENEW 요청 횟수는 임대 시간에 비례하여 감소합니다. 장기 임대의 단점은 서버 오류 후 복구 속도가 느리고\(서버는 새 잠금 요청을 승인하기 전에 임대가 만료되고 유예 기간이 경과할 때까지 기다려야 함\) 파일 경합이 증가한다는 것\(클라이언트가 잠금 해제 요청 전송에 실패하면 서버가 기다려야 함\) 새 잠금을 부여하기 전에 임대 만료를 위해\).

서버가 비휘발성 메모리에 임대 상태를 저장할 수 있는 경우 장기 임대를 사용할 수 있습니다. 복구 시 서버는 비휘발성 메모리에서 임대 상태를 재구성하고 클라이언트와의 작업을 계속할 수 있으므로 장기 임대는 문제가 되지 않습니다.

---
### **8.13.  Clocks, Propagation Delay, and Calculating Lease Expiration**

동기화된 시계의 필요성을 피하기 위해 임대 시간은 서버에서 시간 델타로 부여됩니다. 그러나 클라이언트와 서버 시계가 잠금 기간 동안 과도하게 드리프트하지 않아야 한다는 요구 사항이 있습니다. 또한, 전파 지연 문제도 있습니다.

수백 밀리초가 걸릴 수 있는 네트워크뿐 아니라 요청이 손실되어 재전송해야 할 가능성도 있습니다.

전파 지연을 고려하려면 클라이언트는 이를 임대 시간에서 빼야 합니다\(예를 들어 클라이언트가 단방향 전파 지연을 200msec로 추정하는 경우 임대를 얻을 때 이미 200msec가 지났다고 가정할 수 있습니다\). 또한 서버에 응답을 다시 받는 데 200msec가 더 걸립니다. 따라서 클라이언트는 임대가 만료되기 400msec 전에 잠금 갱신을 보내거나 데이터를 서버에 다시 써야 합니다.

서버의 임대 기간 구성은 서버의 리소스에 액세스할 클라이언트의 네트워크 거리를 고려해야 합니다. 임대 기간은 클라이언트 집단에 대한 네트워크 전파 지연 및 기타 네트워크 지연 요인을 고려할 것으로 예상됩니다. 프로토콜은 적절한 임대 기간을 결정하는 자동 방법을 허용하지 않으므로 서버 관리자는 임대 기간을 조정해야 할 수도 있습니다.

---
### **8.14.  Migration, Replication and State**

특정 파일 시스템 처리에 대한 책임이 새 서버로 이전되거나\(이전\) 클라이언트가 파일 시스템 복제 환경에서 대체 서버를 사용하기로 선택한 경우\(예: 서버 응답 없음에 대한 응답\) 클라이언트와 서버\(예: 잠금, 임대, 상태 ID 및 클라이언트 ID\)는 아래에 설명되어 있습니다. 마이그레이션과 복제의 처리 방법은 다릅니다. 파일 서버 상태 및 복구에 대한 관련 논의는 "파일 잠금 및 공유 예약" 섹션을 참조하세요.

서버 복제본 또는 파일 시스템을 마이그레이션하는 서버가 다른 서버에서 시작된 클라이언트의 불투명 값을 수락하는 데 동의하거나 수락할 것으로 예상되는 경우 서버가 "불투명" 값을 네트워크 바이트 순서로 인코딩하는 것이 현명한 구현 방식입니다. . 이렇게 하면 복제본 역할을 하거나 파일 시스템을 마이그레이션하는 서버는 기본 바이트 순서가 파일 시스템의 복제 및 마이그레이션에 협력하는 다른 서버와 다르더라도 상태 ID, 디렉터리 쿠키, 파일 핸들 등과 같은 값을 구문 분석할 수 있습니다.

---
#### **8.14.1.  Migration and State**

마이그레이션의 경우 파일 시스템 마이그레이션과 관련된 서버는 모든 서버 상태를 원본 서버에서 새 서버로 전송해야 합니다. 이는 클라이언트에게 투명한 방식으로 수행되어야 합니다. 이 상태 전송은 다음과 같은 경우 클라이언트의 전환을 쉽게 해줍니다.\(SHOULD\)

파일 시스템 마이그레이션이 발생합니다. 서버가 모든 상태를 성공적으로 전송하면 클라이언트는 원래 서버에서 할당한 상태 ID를 계속 사용합니다. 따라서 새 서버는 이러한 상태 ID를 유효한 것으로 인식해야 합니다. 이는 클라이언트 ID에도 적용됩니다. 마이그레이션 이벤트를 통해 전체 파일 시스템에 대한 책임이 이전되므로 잠금 이전으로 인해 새 서버에서 충돌이 발생할 가능성이 없습니다.

서버 간 정보 전송의 일부로 임대도 전송됩니다. 새 서버로 전송되는 임대는 일반적으로 이전 서버에 있던 동일한 클라이언트의 만료 시간과 다릅니다. 특정 클라이언트에 대한 특정 서버의 모든 임대가 동시에 만료되는 속성을 유지하려면 서버는 만료 시간을 전송 중인 임대 또는 이미 존재하는 임대 중 나중에 만료되는 시간으로 앞당겨야 합니다. 이를 통해 고객은 특별한 노력 없이도 두 클래스의 임대 갱신을 유지할 수 있습니다.

서버는 마이그레이션 시 상태 정보를 전송하지 않도록 선택할 수 있습니다. 그러나 이 선택은 권장되지 않습니다. 이 경우 클라이언트가 원래 서버의 상태 정보를 제공할 때 클라이언트는 새 서버로부터 NFS4ERR\_STALE\_CLIENTID 또는 NFS4ERR\_STALE\_STATEID를 수신할 준비가 되어 있어야 합니다. 그런 다음 클라이언트는 서버 오류에 대한 응답으로 일반적으로 하는 것처럼 상태 정보를 복구해야 합니다. 새 서버는 서버가 다시 시작되는 경우와 마찬가지로 상태 정보를 복구할 수 있도록 주의를 기울여야 합니다.

---
#### **8.14.2.  Replication and State**

복제 시 클라이언트 전환은 서버 제어 하에 있지 않으므로 상태 처리가 다릅니다. 이 경우 임대, 상태 ID 및 클라이언트 ID는 한 서버에서 다른 서버로 전환하는 동안 유효성을 갖지 않습니다. 클라이언트는 새 서버에서 잠금을 다시 설정해야 합니다. 이는 서버 재부팅 후 회수 유형 요청을 통해 잠금을 다시 설정하는 것과 비교할 수 있습니다. 차이점은 서버에 잠금 회수 요청과 새 잠금 획득 요청을 구별하거나 후자를 연기하는 규정이 없다는 것입니다. 따라서 클라이언트가 새 서버에 잠금을 다시 설정하면\(LOCK 또는 OPEN 요청을 통해\) 잠금 충돌로 인해 요청이 거부될 수 있습니다. 복제는 파일 시스템의 읽기 전용 사용을 위한 것이므로 이러한 잠금 거부는 실제로 큰 어려움을 초래하지 않습니다. 새 서버에 대한 잠금을 다시 설정하려는 시도가 거부되면 클라이언트는 원래 잠금이 취소된 것처럼 상황을 처리해야 합니다.

---
#### **8.14.3.  Notification of Migrated Lease**

임대 갱신의 경우 클라이언트가 다른 서버로 마이그레이션된 파일 시스템에 대한 요청을 제출하지 않을 수 있습니다. 이는 암시적 임대 갱신 메커니즘으로 인해 발생할 수 있습니다. 클라이언트는 서버의 한 파일 시스템에 요청을 제출할 때 모든 파일 시스템에 대한 임대를 갱신합니다.

클라이언트가 새 서버로 재배치되었을 수 있는 임대 갱신을 예약하려면 클라이언트는 해당 임대가 만료되기 전에 임대 재배치에 대해 알아내야 합니다. 이를 달성하기 위해 클라이언트에 대한 임대를 암시적으로 갱신하는 모든 작업\(예: OPEN, CLOSE, READ, WRITE, RENEW, LOCK, LOCKT, LOCKU\)은 갱신할 임대에 대한 책임이 있는 경우 NFS4ERR\_LEASE\_MOVED 오류를 반환합니다. 새로운 서버로 이전되었습니다. 이 조건은 클라이언트가 NFS4ERR\_MOVED 오류를 수신하고 서버가 임대가 새 서버로 이동된 각 파일 시스템에 대한 액세스에 대한 후속 GETATTR\(fs\_locations\)을 수신할 때까지 계속됩니다.

클라이언트가 NFS4ERR\_LEASE\_MOVED 오류를 수신하면 해당 서버와 연결된 각 파일 시스템에서 작업을 수행해야 합니다. 클라이언트가 NFS4ERR\_MOVED 오류를 수신하면 클라이언트는 일반 프로세스에 따라 fs\_locations 속성을 통해 새 서버 정보를 얻고 새 서버에서 해당 임대 갱신을 수행할 수 있습니다. 서버의 상태가 투명하게 전송되지 않은 경우 클라이언트는 위에서 설명한 대로 새 서버로부터 NFS4ERR\_STALE\_CLIENTID 또는 NFS4ERR\_STALE\_STATEID를 수신하며, 클라이언트는 서버 오류 발생 시와 마찬가지로 상태 정보를 복구할 수 있습니다.

---
#### **8.14.4.  Migration and the Lease_time Attribute**

마이그레이션 시 클라이언트가 임대를 적절하게 관리할 수 있도록 대상 서버는 Lease\_time 속성에 대한 적절한 값을 설정해야 합니다.

상태가 투명하게 전송되면 해당 상태에는 Lease\_time 속성의 올바른 값이 포함되어야 합니다. 대상 서버의 Lease\_time 속성은 원본의 임대 시간 속성보다 작아서는 안 됩니다. 이렇게 하면 원본 서버에서 부여한 임대가 조기 만료될 수 있기 때문입니다. 상태가 투명하게 전송되는 마이그레이션 시 클라이언트는 rent\_time 속성을 다시 가져올 의무가 없으며 \(소스 서버에서\) 이전에 가져온 값을 계속 사용할 수 있습니다.

상태가 투명하게 전송되지 않은 경우\(즉, 클라이언트가 실제 또는 시뮬레이션된 서버 재부팅을 확인하는 경우\) 클라이언트는 새\(즉, 대상\) 서버에서 Lease\_time 값을 가져와서 사용해야 합니다.

후속 잠금 요청을 위해. 그러나 서버는 잠재적으로 충돌할 수 있는 비재확보 잠금이 부여되기 전에 클라이언트가 잠금을 재확보할 수 있는 충분한 시간을 갖도록 보장하기 위해 적어도 원본 서버의 rent\_time만큼 긴 유예 기간을 준수해야 합니다. 새 서버가 이전 서버에서 Lease\_time 값을 얻는 방법은 서버 구현에 달려 있습니다. NFS 버전 4 프로토콜에서는 지정되지 않습니다.

---
## **9.  Client-Side Caching**

NFS 프로토콜로 우수한 성능을 제공하려면 클라이언트측 데이터, 파일 속성 및 파일 이름 캐싱이 필수적입니다. 분산 캐시 일관성을 제공하는 것은 어려운 문제이며 이전 버전의 NFS 프로토콜에서는 이를 시도하지 않았습니다. 대신 일관성 부족으로 인해 사용자에게 발생하는 문제를 줄이기 위해 여러 NFS 클라이언트 구현 기술이 사용되었습니다. 이러한 기술은 이전 프로토콜 사양에 의해 명확하게 정의되지 않았으며 클라이언트 동작이 유효한지 또는 유효하지 않은지 불분명한 경우가 많습니다.

NFS 버전 4 프로토콜은 이전 프로토콜 버전에서 사용된 것과 유사한 많은 기술을 사용합니다. NFS 버전 4 프로토콜은 분산 캐시 일관성을 제공하지 않습니다. 그러나 클라이언트 측 캐싱의 파괴적인 간섭 없이 잠금 및 공유 예약을 사용할 수 있도록 보다 제한된 캐싱 보장 세트를 정의합니다.

또한 NFS 버전 4 프로토콜에는 일반적으로 서버에서 내리는 많은 결정을 클라이언트가 로컬로 내릴 수 있도록 하는 위임 메커니즘이 도입되었습니다. 이 메커니즘은 공유가 자주 발생하지 않거나 공유가 읽기 전용인 일반적인 경우를 효율적으로 지원합니다.

---
### **9.1.  Performance Challenges for Client-Side Caching**

NFS 프로토콜의 이전 버전에서 사용된 캐싱 기술은 우수한 성능을 제공하는 데 성공했습니다. 그러나 이러한 기술을 매우 많은 수의 클라이언트에서 사용할 경우 몇 가지 확장성 문제가 발생할 수 있습니다. 이는 클라이언트가 지리적으로 분산되어 캐시 재검증 요청에 대한 대기 시간이 일반적으로 증가하는 경우 특히 그렇습니다.

이전 버전의 NFS 프로토콜은 파일이 열릴 때 파일 데이터 캐시 유효성 검사 요청을 반복합니다. 이 동작은 심각한 성능 문제를 일으킬 수 있습니다. 일반적인 경우는 단일 클라이언트에서만 파일에 액세스하는 경우입니다. 따라서 공유가 자주 발생하지 않습니다.

이 경우 충돌이 없는지 확인하기 위해 서버를 반복적으로 참조하는 것은 비용이 많이 듭니다. 성능과 관련하여 더 나은 옵션은 서버를 참조하지 않고 반복적으로 파일을 여는 클라이언트를 허용하는 것입니다. 이는 다른 클라이언트의 잠재적인 충돌 작업이 실제로 발생할 때까지 수행됩니다.

파일 잠금과 관련하여 유사한 상황이 발생합니다. 서버에 파일 잠금 및 잠금 해제 요청을 보내고 데이터 캐싱을 잠금 의미 체계와 일치시키는 데 필요한 읽기 및 쓰기 요청\("데이터 캐싱 및 파일 잠금" 섹션 참조\)을 보내면 성능이 심각하게 제한될 수 있습니다. 자주 발생하지 않는 충돌로부터 보호하기 위해 잠금을 사용하면 큰 페널티가 발생합니다. 이 페널티는 응용 프로그램의 파일 잠금 사용을 방해할 수 있습니다.

NFS 버전 4 프로토콜은 다음 설계 목표에 따라 보다 공격적인 캐싱 전략을 제공합니다.

o 광범위한 서버 의미론과의 호환성.

o 보다 공격적인 모델을 제공할 수 없는 경우 이전 버전의 NFS 프로토콜과 동일한 캐싱 이점을 제공합니다.

o 공격적 캐싱에 대한 요구 사항은 모든 요구 사항을 충족하지 못하는 경우에도 많은 이점을 얻을 수 있도록 구성됩니다.

서버에 대한 적절한 요구 사항은 특정 형태의 캐싱을 다루는 이후 섹션에서 논의됩니다. \("공개 위임" 섹션 참조\)

---
### **9.2.  Delegation and Callbacks**

파일에 대한 서버 책임을 클라이언트에 다시 위임하면 클라이언트 간 충돌이 없을 때 서버에 대한 반복 요청을 방지하여 성능이 향상됩니다. 서버에서 클라이언트로의 "콜백" RPC를 사용하면 다른 클라이언트가 위임된 파일 공유에 참여할 때 서버는 위임된 책임을 회수합니다.

위임 대상과 위임 유형을 지정하여 위임이 서버에서 클라이언트로 전달됩니다. 다양한 유형의 위임이 있지만 각 유형에는 위임에 의존하는 작업을 수행할 때 위임을 나타내는 데 사용되는 상태 ID가 포함되어 있습니다. 이 상태 ID는 잠금 및 공유 예약과 관련된 상태 ID와 유사하지만 위임에 대한 상태 ID가 클라이언트 ID와 연결되어 있고

해당 클라이언트의 모든 open\_owners를 대신하여 사용됩니다. 위임은 클라이언트 내부의 특정 프로세스나 제어 스레드가 아닌 클라이언트 전체에 대해 이루어집니다.

콜백 RPC는 모든 환경에서 작동하지 않을 수 있으므로\(예: 방화벽으로 인해\) 올바른 프로토콜 작동은 이에 의존하지 않습니다. CB\_NULL 프로시저를 통한 콜백 기능의 예비 테스트를 통해 콜백 지원 여부가 결정됩니다. CB\_NULL 프로시저는 콜백 경로의 연속성을 확인합니다. 서버는 특정 클라이언트에 대한 콜백 가용성을 예비 평가하고 콜백이 지원된다는 것을 확인할 때까지 책임 위임을 방지합니다. 위임 승인은 항상 액세스 충돌이 없을 때 조건부로 이루어지기 때문에 클라이언트는 위임이 승인될 것이라고 가정해서는 안 되며 위임이 승인되지 않은 채 OPEN이 처리될 수 있도록 항상 준비해야 합니다.

일단 승인되면 위임은 대부분의 방식으로 잠금처럼 작동합니다. 해당 고객이 보유한 다른 모든 임대와 함께 갱신 대상인 관련 임대가 있습니다.

잠금과 달리 위임된 파일에 대한 두 번째 클라이언트의 작업으로 인해 서버는 콜백을 통해 위임을 회수하게 됩니다.

회수 시 위임을 보유한 클라이언트는 수정된 상태\(예: 수정된 데이터\)를 서버에 플러시하고 위임을 반환해야 합니다. 충돌하는 요청은 회수가 완료될 때까지 응답을 받지 못합니다. 클라이언트가 위임을 반환하거나 서버가 회수 시간을 초과하고 시간 초과로 인해 위임을 취소하면 회수가 완료된 것으로 간주됩니다. 회수 해결 후 서버는 두 번째 클라이언트의 요청을 승인하거나 거부하는 데 필요한 정보를 갖게 됩니다.

클라이언트가 위임 회수를 수신할 때 서버에 플러시해야 하는 실질적인 상태가 있을 수 있습니다. 따라서 서버에 대한 수많은 RPC가 포함될 수 있으므로 서버는 위임이 반환될 때까지 충분한 시간을 허용해야 합니다. 클라이언트가 회수 결과에 따라 상태를 서버에 부지런히 플러시하고 있음을 서버에서 확인할 수 있는 경우 서버는 회수에 허용되는 일반적인 시간을 연장할 수 있습니다. 그러나 회수 완료에 허용되는 시간은 제한이 없어야 합니다.

이에 대한 예는 특정 파일에 대한 열기를 중재하는 책임이 클라이언트에 위임되는 경우입니다\("공개 위임" 섹션 참조\). 서버는 클라이언트에 어떤 열기가 적용되는지 알 수 없습니다. 이러한 지식이 없으면 서버는 파일에 대한 위임이 반환될 때까지 파일에 대한 액세스 및 거부 상태가 특정 열기를 허용하는지 여부를 확인할 수 없습니다.

클라이언트 오류 또는 네트워크 파티션으로 인해 회수 콜백에 응답하지 못할 수 있습니다. 이 경우 서버는 위임을 취소하여 클라이언트에 여전히 수정된 상태를 쓸모 없게 만듭니다.

---
#### **9.2.1.  Delegation Recovery**

위임 복구에서 처리해야 하는 세 가지 상황은 다음과 같습니다.

o 클라이언트 재부팅 또는 다시 시작

o 서버 재부팅 또는 다시 시작

```text
   o   Network partition (full or callback-only)
```

클라이언트가 재부팅되거나 다시 시작되는 경우 임대 갱신에 실패하면 레코드 잠금 및 공유 예약이 취소됩니다. 그러나 위임은 약간 다르게 처리될 수 있습니다.

클라이언트가 재부팅되거나 다시 시작된 후 위임을 다시 설정해야 하는 상황이 있습니다. 그 이유는 클라이언트가 로컬에 저장된 파일 데이터를 가지고 있을 수 있고 이 데이터가 이전에 보유한 위임과 연관되어 있기 때문입니다. 클라이언트는 서버에서 적절한 파일 상태를 다시 설정해야 합니다.

이러한 유형의 클라이언트 복구를 허용하기 위해 서버는 위임 복구 기간을 일반적인 임대 만료 기간 이상으로 연장할 수 있습니다. 이는 이러한 위임과 충돌하는 다른 클라이언트의 요청이 기다려야 함을 의미합니다. 일반적인 회수 프로세스에서는 클라이언트가 변경된 상태를 서버에 플러시하는 데 상당한 시간이 필요할 수 있으므로 다른 클라이언트는 위임 충돌로 인해 발생하는 지연에 대비해야 합니다. 간격이 길어지면 클라이언트가 재부팅하고 안정적인 저장소를 참조하여 위임을 회수할 수 있는 기간이 늘어납니다. 공개 위임의 경우 이러한 위임은 클레임 유형 CLAIM\_DELEGATE\_PREV와 함께 OPEN을 사용하여 회수됩니다. \(공개 위임에 대한 논의와 OPEN의 세부 사항에 대해서는 각각 "데이터 캐싱 및 취소" 및 "작업 18: OPEN" 섹션을 참조하십시오.\)\(MAY\)

서버는 CLAIM\_DELEGATE\_PREV의 클레임 유형을 지원할 수 있지만, 지원하는 경우 SETCLIENTID\_CONFIRM 시 위임을 제거해서는 안 되며, 대신 Lease\_time 속성 값보다 적지 않은 기간 동안 클라이언트의 위임을 유지해야 합니다. 클라이언트가 CLAIM\_DELEGATE\_PREV 요청을 발행하는 데 걸리는 시간입니다. CLAIM\_DELEGATE\_PREV를 지원하는 서버는 DELEGPURGE 작업을 지원해야 합니다.\(MUST NOT, MUST\)

서버가 재부팅되거나 다시 시작되면 잠금을 기록하고 예약을 공유하는 것과 유사한 방식으로 위임이 회수됩니다\(CLAIM\_PREVIOUS와 함께 OPEN 작업 사용\). 그러나 의미상 약간의 차이가 있습니다. 일반적인 경우 서버가 위임을 허용하지 않아야 한다고 결정하면 위임을 허용하지 않고 요청된 작업\(예: OPEN\)을 수행합니다. 회수의 경우 서버는 위임을 승인하지만 클라이언트는 위임이 서버에 의해 회수되었지만 위임이 회수된 것으로 처리하도록 특별한 지정이 적용됩니다. 이 때문에 클라이언트는 수정된 모든 상태를 서버에 쓴 다음 위임을 반환해야 할 의무가 있습니다. 위임 회수를 처리하는 이 프로세스는 NFS 버전 4 프로토콜의 세 가지 원칙을 조정합니다.

o 회수 시 이전 서버 인스턴스에 의해 할당된 클라이언트 보고 리소스에는 해당 리소스가 부여되어야 합니다.

o 서버는 위임이 승인되어야 하는지 여부와 일단 승인되면 위임이 계속되어야 하는지 여부를 결정할 수 있는 의심할 여지 없는 권한을 가지고 있습니다.

o 클라이언트가 콜백을 수신할 수 있는 능력이 입증될 때까지 콜백 사용에 의존해서는 안 됩니다.

네트워크 분할이 발생하면 임대 갱신 기간이 만료되면 서버에서 위임을 해제할 수 있습니다. 이는 잠금 및 공유 예약의 동작과 유사합니다. 그러나 위임의 경우 서버는 충돌하는 요청이 보류되는 기간을 연장할 수 있습니다. 결국 다른 클라이언트로부터 충돌하는 요청이 발생하면 위임이 취소됩니다. 콜백 경로가 손실되면\(예: 나중에 네트워크 구성 변경으로 인해\) 동일한 효과가 나타납니다. 회수 요청이 실패하고 위임이 취소됩니다.

클라이언트는 일반적으로 위임과 연결된 stateid를 사용하고 NFS4ERR\_EXPIRED 오류를 수신할 때 위임 취소에 대해 알아냅니다. 또한 클라이언트 재부팅 후 위임 회수를 시도하고 동일한 오류가 수신되면 위임 취소에 대해 알아낼 수도 있습니다. 취소된 쓰기 공개 위임의 경우 위임이 취소된 클라이언트와 다른 클라이언트가 별도로 데이터를 수정했을 수 있으므로 문제가 있습니다. 이러한 문제에 대한 논의는 "쓰기 공개 위임을 위한 해지 복구" 섹션을 참조하세요. 또한 위임이 취소되면 취소된 위임에 대한 정보가 서버에 의해 안정적인 저장소에 기록됩니다\("충돌 복구" 섹션에 설명된 대로\). 이는 위임을 취소한 후 취소된 위임을 보유한 클라이언트에 취소 사실이 통보되기 전에 서버가 재부팅되는 경우를 처리하기 위해 수행됩니다.

---
### **9.3.  Data Caching**

응용 프로그램이 파일 집합에 대한 액세스를 공유하는 경우 다른 응용 프로그램의 액세스 충돌 가능성을 고려하여 구현해야 합니다. 이는 문제의 응용 프로그램이 다른 클라이언트에서 실행되거나 동일한 클라이언트에 상주하는지 여부에 관계없이 적용됩니다.

공유 예약 및 레코드 잠금은 상호 배제 기능을 제공하여 애플리케이션이 액세스를 조정할 수 있도록 NFS 버전 4 프로토콜에서 제공하는 기능입니다. NFS 버전 4 프로토콜의 데이터 캐싱은 이러한 기능을 사용하는 사람들이 의존하는 가정을 무효화하지 않도록 구현되어야 합니다.

---
#### **9.3.1.  Data Caching and OPENs**

애플리케이션이 의존하는 공유 가정이 무효화되는 것을 방지하기 위해 NFS 버전 4 클라이언트는 READ 또는 WRITE를 통해 동일한 데이터를 얻거나 수정하는 것이 유효하지 않은 경우 캐시된 데이터를 애플리케이션에 제공하거나 애플리케이션을 대신하여 수정해서는 안 됩니다. 작업.

또한 공개 위임이 없는 경우\("공개 위임" 섹션 참조\) 두 가지 추가 규칙이 적용됩니다. 이러한 규칙은 실제로 많은 NFS 버전 2 및 버전 3 클라이언트에서 준수됩니다.

o 먼저 OPEN을 수행한 후 클라이언트에 있는 캐시된 데이터를 다시 검증해야 합니다. 재검증이란 클라이언트가 서버에서 변경 속성을 가져와 캐시된 변경 속성과 비교하고, 다를 경우 캐시된 데이터\(및 캐시된 속성\)를 유효하지 않은 것으로 선언하는 것을 의미합니다. 이는 OPEN된 파일의 데이터가 여전히 클라이언트 캐시에 올바르게 반영되도록 하기 위한 것입니다. 이 유효성 검사는 최소한 클라이언트의 OPEN 작업에 DENY=WRITE 또는 BOTH가 포함되어 다른 클라이언트가 WRITE 액세스로 파일을 열 수 있는 기간이 종료되는 경우 수행되어야 합니다. 클라이언트는 이 수준의 캐시 재검증을 가정하는 사용자의 이익을 위해 NFS 버전 3 프로토콜의 실행과 병행하기 위해 재검증을 더 자주 수행하도록 선택할 수 있습니다\(즉, OPEN에서 DENY=NONE을 지정함\).

- 데이터 및 메타데이터 수정을 위해 변경 속성이 업데이트되므로 일부 클라이언트 구현자는 캐시된 데이터의 유효성을 검사하기 위해 time\_modify 속성을 사용하고 변경하지 않으려는 유혹을 받을 수 있습니다. 그러면 메타데이터 변경으로 인해 순수 데이터가 무효화되지 않습니다. 구현자는 이 접근 방식에 대해 주의를 받습니다. 변경 속성은 파일이 업데이트될 때마다 변경되도록 보장됩니다.

반면 time\_modify는 다음 시점에만 변경되도록 보장됩니다.

- time\_delta 속성의 세분성. 클라이언트의 데이터 캐시 검증 로직인 time\_modify를 변경하지 않고 사용하면 클라이언트가 오래된 데이터를 유효한 것으로 잘못 표시할 위험이 있습니다.

o 둘째, 수정된 데이터는 쓰기 위해 열린 파일을 닫기 전에 서버로 플러시되어야 합니다. 이는 첫 번째 규칙을 보완합니다. CLOSE 시 데이터가 플러시되지 않으면 클라이언트가 파일로 OPEN한 후 수행된 재검증이 해당 목적을 달성할 수 없습니다. 닫기 전에 데이터를 플러시하는 또 다른 측면은 클라이언트가 CLOSE 작업을 요청하기 전에 데이터를 서버의 안정적인 저장소에 커밋해야 한다는 것입니다. 서버 재부팅이나 재시작 및 CLOSE된 파일의 경우 파일에 기록할 데이터를 재전송하지 못할 수 있습니다. 따라서 이 요구 사항은 다음과 같습니다.

---
#### **9.3.2.  Data Caching and File Locking**

일관되지 않은 파일 액세스를 제외하기 위해 공유 예약 대신 파일 잠금을 사용하도록 선택한 응용 프로그램의 경우 클라이언트 측 데이터 캐싱에 적용되는 유사한 제약 조건 집합이 있습니다. 이러한 규칙은 실행된 실제 READ 및 WRITE 작업과 동일한 방식으로 파일 잠금이 사용되는 경우에만 유효합니다. 이는 순수한 규칙을 기반으로 하는 파일 잠금과 반대됩니다. 예를 들어, 파일을 두 개의 1MB 영역으로 나누고 바이트 0과 1에 대한 파일 잠금을 통해 두 영역에 대한 액세스를 보호함으로써 2MB 파일을 조작할 수 있습니다. 파일의 0바이트 쓰기에 대한 잠금은 첫 번째 영역에서 읽기 및 쓰기 작업을 수행할 수 있는 권한을 나타냅니다. 파일의 첫 번째 바이트에 대한 쓰기 잠금은 두 번째 영역에서 읽기 및 쓰기 작업을 수행할 수 있는 권한을 나타냅니다. 파일을 조작하는 모든 응용 프로그램이 이 규칙을 준수하는 한 로컬 파일 시스템에서 작동합니다. 그러나 클라이언트가 데이터 캐싱을 삼가하지 않는 한 NFS 버전 4 프로토콜에서는 작동하지 않을 수 있습니다.

파일 잠금 환경의 데이터 캐싱 규칙은 다음과 같습니다.

o 먼저 클라이언트가 특정 지역에 대한 파일 잠금을 획득하면 해당 지역에 해당하는 데이터 캐시\(캐시된 데이터가 있는 경우\)를 재검증해야 합니다. 변경 속성이 캐시된 데이터를 얻은 이후 파일이 업데이트되었을 수 있음을 나타내는 경우 클라이언트는 새로 잠긴 영역에 대해 캐시된 데이터를 플러시하거나 무효화해야 합니다. 클라이언트는 파일에 대해 가지고 있는 수정되지 않은 캐시된 데이터를 모두 무효화하도록 선택할 수 있지만 올바른 작업을 위한 유일한 요구 사항은 새로 잠긴 영역의 모든 데이터를 무효화하는 것입니다.

o 둘째, 지역에 대한 쓰기 잠금을 해제하기 전에 해당 지역에 대해 수정된 모든 데이터를 서버로 플러시해야 합니다. 수정된 데이터는 안정적인 저장소에도 기록되어야 합니다.

데이터를 서버로 플러시하고 캐시된 데이터를 무효화하려면 잠기거나 잠금 해제된 실제 바이트 범위가 반영되어야 합니다. 클라이언트 캐시 블록 경계를 반영하기 위해 이를 반올림하거나 내림하면 주의 깊게 수행하지 않으면 문제가 발생할 수 있습니다. 예를 들어, 해당 블록의 절반만 잠금 해제된 영역 내에 있을 때 수정된 블록을 쓰면 잠금 해제된 영역 외부 영역에 잘못된 수정이 발생할 수 있습니다. 이는 결국 다른 클라이언트에 의해 잠긴 지역의 일부일 수 있습니다. 클라이언트는 전체 블록이 아닌 부분\(초기 또는 최종\)과 겹치는 쓰기 작업 부분을 동기적으로 수행하여 이러한 상황을 피할 수 있습니다. 마찬가지로, 전체 버퍼 블록의 정수가 아닌 잠긴 영역을 무효화하려면 클라이언트가 소유한 데이터가 유효하지 않을 수 있다는 재검증 절차를 통해 클라이언트가 서버에서 하나 또는 두 개의 부분 블록을 읽어야 합니다.

지역 잠금 해제의 전제 조건으로 서버에 기록되는 데이터는 서버에서 안정적인 저장소에 기록되어야 합니다. 클라이언트는 동기 쓰기를 사용하거나 COMMIT 작업을 통한 비동기 쓰기를 수행하여 이를 수행할 수 있습니다. 이는 서버 재부팅 후 수정된 데이터를 재전송하면 다른 클라이언트가 보유한 잠금과 충돌할 수 있기 때문에 필요합니다.

클라이언트 구현은 LOCKU 시 잠긴 범위에 포함된 것보다 더 많은 데이터를 서버에 플러시하여 비표준 방식\(예: 레코드 잠금을 전역 세마포로 사용\)으로 레코드 잠금을 사용하는 애플리케이션을 수용하도록 선택할 수 있습니다. 여기에는 잠금 해제가 수행되는 파일이 아닌 다른 파일 내의 수정된 데이터가 포함될 수 있습니다. 이러한 경우 클라이언트는 애플리케이션이 보유한 레코드 잠금 범위 내에서만 읽기 및 쓰기가 수행되는 애플리케이션을 방해해서는 안 됩니다. 예를 들어, 애플리케이션은 파일의 단일 바이트를 잠그고 계속해서 해당 단일 바이트를 씁니다. 수정된 모든 데이터를 서버에 플러시하여 LOCKU를 처리하기로 선택한 클라이언트는 관련 없는 잠금 해제에 대한 응답으로 해당 단일 바이트를 유효하게 쓸 수 있습니다. 그러나 기록된 단일 바이트가 위치한 전체 블록을 기록하는 것은 유효하지 않습니다. 왜냐하면 여기에는 잠겨 있지 않고 다른 클라이언트에 의해 잠겨 있을 수 있는 영역이 포함되어 있기 때문입니다. 클라이언트 구현은 수정된 데이터가 있는 파일을 적절한 레코드 잠금이 적용되는 영역에 대해 모든 수정이 수행되는 파일과 레코드 잠금이 적용되지 않는 수정이 있는 파일로 나누어 이 문제를 피할 수 있습니다. 이전 파일 클래스에 대해 수행된 모든 쓰기에는 잠기지 않아 클라이언트에서 수정되지 않은 영역이 포함되어서는 안 됩니다.

---
#### **9.3.3.  Data Caching and Mandatory File Locking**

클라이언트 측 데이터 캐싱은 적용될 때 필수 파일 잠금을 준수해야 합니다. 지정된 파일에 대한 필수 파일 잠금이 있음은 클라이언트가 적절한 공유 예약이 있는 파일에 대한 READ 또는 WRITE에서 NFS4ERR\_LOCKED를 다시 얻을 때 표시됩니다. 파일에 필수 잠금이 적용되면 클라이언트는 읽거나 쓰는 데이터에 대해 적절한 파일 잠금이 있는지 확인해야 합니다. 읽거나 쓰는 범위에 대한 잠금이 존재하는 경우 클라이언트는 클라이언트의 검증된 캐시를 사용하여 요청을 충족할 수 있습니다. 읽기 또는 쓰기 범위에 대해 적절한 파일 잠금이 유지되지 않으면 읽기 또는 쓰기 요청이 클라이언트 캐시에 의해 충족되지 않아야 하며 요청을 처리하기 위해 서버로 보내야 합니다. 읽기 또는 쓰기 요청이 잠긴 영역과 부분적으로 겹치는 경우 요청은 각 영역\(잠금 여부와 관계없이\)이 적절하게 처리되도록 여러 부분으로 나누어야 합니다.

---
#### **9.3.4.  Data Caching and File Identity**

클라이언트가 데이터를 캐시할 때 파일 데이터는 해당 데이터가 속한 파일 시스템 개체에 따라 구성되어야 합니다. NFS 버전 3 클라이언트의 경우 캐싱을 위해 고유한 파일 핸들이 고유한 파일 시스템 개체를 나타낸다고 가정하는 것이 일반적인 관행이었습니다. 그러면 클라이언트는 이를 기반으로 데이터 캐시를 구성하고 유지 관리할 수 있습니다.

NFS 버전 4 프로토콜에서는 파일 핸들이 객체의 경로 이름을 기반으로 구성될 수 있기 때문에 "객체당 하나의 파일 핸들" 모델과 상당한 차이가 있을 가능성이 있습니다. 따라서 클라이언트에는 두 파일 핸들이 동일한 파일 시스템 개체를 지정하는지 확인하는 안정적인 방법이 필요합니다. 클라이언트가 단순히 모든 고유한 파일 핸들이 고유한 개체를 나타낸다고 가정하고 이를 기반으로 데이터 캐싱을 진행하면 동일한 서버측 개체에 매핑된 고유한 클라이언트측 개체 간에 캐싱 불일치가 발생할 수 있습니다.

NFS 버전 4 프로토콜은 파일 핸들을 구별하는 방법을 제공함으로써 NFS 버전 3 프로토콜과 비교하여 잠재적인 기능 회귀를 완화합니다. 이 방법이 없으면 동일한 클라이언트 내에서 캐싱 불일치가 발생할 수 있으며 이는 이전 버전의 NFS 프로토콜에서는 발생하지 않았습니다. 여러 클라이언트에서 실행되는 응용 프로그램에서 이러한 불일치가 발생할 수 있지만 여기서는 이 문제를 다루지 않습니다.

데이터 캐싱을 위해 다음 단계를 통해 NFS 버전 4 클라이언트는 두 개의 서로 다른 파일 핸들이 동일한 서버 측 개체를 나타내는지 여부를 확인할 수 있습니다.

o 두 개의 파일 핸들로 지정된 GETATTR이 fsid 속성의 서로 다른 값을 반환하는 경우 파일 핸들은 고유한 개체를 나타냅니다.

o 문제의 두 파일 핸들의 fsid와 일치하는 fsid가 있는 파일에 대한 GETATTR이 값이 TRUE인 Unique\_handles 속성을 반환하는 경우 두 개체는 서로 다릅니다.

o 두 파일 핸들에 대한 GETATTR이 두 핸들 모두에 대한 fileid 속성을 반환하지 않으면 두 개체가 동일한지 여부를 확인할 수 없습니다. 따라서 해당 지식\(예: 클라이언트 측 데이터 캐싱\)에 의존하는 작업을 안정적으로 수행할 수 없습니다.

o 두 개의 파일 핸들로 전달된 GETATTR이 fileid 속성에 대해 서로 다른 값을 반환하는 경우 해당 두 파일 핸들은 별개의 개체입니다.

o 그렇지 않으면 동일한 객체입니다.

---
### **9.4.  Open Delegation**

파일이 열려 있는 동안 서버는 해당 파일에 대한 열기 및 닫기의 추가 처리를 열기 클라이언트에 위임할 수 있습니다. 위임이 허용된 상황은 변경될 수 있으므로 그러한 위임은 모두 취소 가능합니다. 특히, 서버는 다른 클라이언트로부터 충돌하는 OPEN을 수신할 수 있으며, 서버는 다른 클라이언트의 OPEN이 승인될 수 있는지 여부를 결정하기 전에 위임을 회수해야 합니다. 위임을 하는 것은 서버에 달려 있으며 클라이언트는 특정 OPEN이 공개 위임으로 이어질지 여부를 가정해서는 안 됩니다. 다음은 OPEN을 위임해야 하는지 여부를 결정할 때 서버가 사용할 수 있는 일반적인 조건 집합입니다.

o 클라이언트는 서버의 콜백 요청에 응답할 수 있어야 합니다. 서버는 콜백 기능 테스트를 위해 CB\_NULL 프로시저를 사용합니다.

o 고객은 이전 회상에 적절하게 응답해야 합니다.

o 요청된 위임과 충돌하는 현재 공개 상태가 없어야 합니다.

o 요청된 위임과 충돌하는 현재 위임이 없어야 합니다.

o 파일의 최근 기록을 기준으로 향후 열기 요청 충돌 가능성이 낮아야 합니다.

o 필요한 처리가 위임된 클라이언트가 적용할 규정된 처리와 호환되지 않게 만드는 OPEN/CLOSE의 서버별 의미 체계가 존재합니다\(아래 참조\).

공개 위임에는 읽기와 쓰기의 두 가지 유형이 있습니다. 읽기 열기 위임을 사용하면 클라이언트가 다른 사람의 읽기 액세스를 거부하지 않는 읽기용 파일 열기 요청을 자체적으로 처리할 수 있습니다. 여러 개의 읽기 열기 위임이 동시에 처리될 수 있으며 충돌하지 않습니다. 쓰기 열기 위임을 사용하면 클라이언트가 모든 열기를 자체적으로 처리할 수 있습니다. 특정 시간에 특정 파일에 대해 하나의 쓰기 개방 위임만 존재할 수 있으며 이는 읽기 개방 위임과 일치하지 않습니다.

클라이언트가 읽기/열기 위임을 받은 경우 파일의 내용이나 속성을 변경할 수 없지만 다른 클라이언트는 변경할 수 없습니다. 클라이언트에 쓰기 열기 위임이 있으면 다른 클라이언트가 파일 데이터에 액세스하지 않으므로 파일 데이터를 수정할 수 있습니다. 쓰기 위임을 보유한 클라이언트는 파일 데이터와 밀접하게 연결된 파일 속성\(크기, 시간 수정, 변경\)에만 영향을 미칠 수 있습니다.

클라이언트에 공개 위임이 있는 경우 OPEN 또는 CLOSE를 서버에 보내지 않고 내부적으로 적절한 상태를 업데이트합니다. 읽기 열기 위임의 경우 로컬로 처리할 수 없는 열기\(쓰기를 위해 열거나 읽기 액세스를 거부하는 열기\)를 서버로 보내야 합니다.

공개 위임이 이루어지면 OPEN에 대한 응답에는 다음을 지정하는 공개 위임 구조가 포함됩니다.

```text
   o  the type of delegation (read or write)

   o  space limitation information to control flushing of data on close
      (write open delegation only, see the section "Open Delegation and
      Data Caching")
```

o 읽기 및 쓰기 권한을 지정하는 nfsace4

o READ 및 WRITE 위임을 나타내는 stateid

위임 stateid는 OPEN 고유의 stateid와는 별개입니다. 위임 stateid와 달리 표준 stateid는 특정 lock\_owner와 연결되어 있으며 위임이 회수되고 파일이 열린 후에도 계속 유효합니다.

클라이언트 내부에서 파일 열기 요청이 이루어지고 공개 위임이 유효한 경우 다음 조건에 따라서만 수락 또는 거부됩니다. 대리인이 다른 검사를 수행해야 한다는 요구 사항이 있으면 공개 위임이 거부되어 서버 자체에서 검사를 수행할 수 있어야 합니다.

o "공유 예약" 섹션에 설명된 대로 요청 및 파일에 대한 액세스 및 거부 비트입니다.

o 아래에 결정된 읽기 및 쓰기 권한.

위임과 함께 전달된 nfsace4를 사용하면 빈번한 ACCESS 호출을 피할 수 있습니다. 권한 확인은 다음과 같아야 합니다.

o nfsace4가 열기가 완료될 수 있음을 나타내는 경우 서버를 참조하지 않고 승인되어야 합니다.

o nfsace4가 열기가 수행되지 않을 수 있음을 나타내는 경우 최종 응답을 얻기 위해 ACCESS 요청을 서버로 보내야 합니다.

서버는 파일의 실제 ACL보다 더 제한적인 nfsace4를 반환할 수 있습니다. 여기에는 모든 액세스 거부를 지정하는 nfsace4가 포함됩니다. 기존 사용자 "root"를 사용자 "nobody"로 매핑하는 것과 같은 일부 일반적인 관행으로 인해 위임 응답에서 파일의 실제 ACL을 반환하는 것이 잘못될 수 있습니다.

다양한 다른 형태의 캐싱과 함께 위임을 사용하면 사용자의 모든 요청이 로컬에서 충족될 수 있으므로 해당 사용자에 대해 서버 인증이 수행되지 않을 가능성이 있습니다. 클라이언트가 인증을 위해 서버에 의존하는 경우 클라이언트는 ACCESS 작업을 사용하여 각 사용자에 대해 인증이 발생하는지 확인해야 합니다. 그렇지 않으면 ACCESS 작업이 필요하지 않은 경우에도 마찬가지입니다. 앞에서 언급했듯이 서버는 공개 위임이 있을 때마다 모든 액세스를 거부하는 nfsace4를 반환하여 빈번한 인증을 시행할 수 있습니다.

---
#### **9.4.1.  Open Delegation and Data Caching**

OPEN 위임을 사용하면 파일 열기 및 닫기와 관련된 메시지 오버헤드의 대부분을 제거할 수 있습니다. 공개 위임이 적용될 때 공개를 수행하려면 유효성 검사 메시지를 서버로 보낼 필요가 없습니다. "읽기 공개 위임"의 지속적인 지속은 쓰기를 위한 OPEN이 없으므로 쓰기가 발생하지 않음을 보장합니다. 마찬가지로 쓰기 위해 열린 파일을 닫을 때 쓰기 열기 위임이 적용되는 경우에는 열기 위임이 완료될 때까지 기록된 데이터를 서버로 플러시할 필요가 없습니다.

회상했다. 공개 위임이 계속 지속되면 다른 클라이언트가 열거나 읽거나 쓸 수 없다는 것을 보장할 수 있습니다.

공개 위임의 경우 OPEN 없이 수행된 읽기 및 쓰기는 해당 유형의 OPEN과 기능적으로 동등한 것으로 처리됩니다. 이는 모두 0비트 또는 모두 1비트로 구성된 특수 상태 ID를 사용하는 읽기 및 쓰기를 나타냅니다. 따라서 다른 클라이언트가 특수한 상태 ID를 사용하여 읽기 또는 쓰기를 수행하면 서버가 쓰기 열기 위임을 회수하게 됩니다. 다른 클라이언트가 특별한 상태 ID를 사용하여 WRITE를 수행하면 읽기 공개 위임이 강제로 회수됩니다.

위임을 사용하면 클라이언트는 파일 CLOSE가 서비스될 때 서버에 데이터를 쓰는 것을 피할 수 있습니다. 파일 닫기 시스템 호출은 애플리케이션에서 생성된 수정된 파일 데이터에 대한 안정적인 저장소가 부족하다는 알림을 클라이언트에 알리는 일반적인 지점입니다. 마지막에 파일 데이터가 서버에 기록되고 일반 계정을 통해 서버는 데이터에 사용 가능한 파일 시스템 공간이 초과되었는지 확인할 수 있습니다\(예: 서버가 NFS4ERR\_NOSPC 또는 NFS4ERR\_DQUOT를 반환함\). 이 회계에는 할당량이 포함됩니다. 위임을 도입하려면 클라이언트와 서버 간에 동일한 유형의 통신이 발생하도록 대체 방법을 마련해야 합니다.

위임 응답에서 서버는 파일 크기 제한이나 수정된 ​​블록 수 및 관련 블록 크기를 제공합니다. 서버는 클라이언트가 원래 위임에 제공된 것과 동일한 크기의 데이터를 서버에 플러시할 수 있는지 확인해야 합니다. 서버는 모든 미결 위임에 대해 이러한 보증을 해야 합니다. 따라서 서버는 사용 가능한 파일 시스템 공간과 적용 가능한 할당량을 고려하여 새 데이터나 수정된 ​​데이터에 사용 가능한 공간을 관리할 때 주의해야 합니다. 서버는 사용 가능한 파일 시스템 공간을 관리한 결과 위임을 회수할 수 있습니다. 클라이언트는 위임을 위한 서버의 상태 공간 제한을 준수해야 합니다. 클라이언트가 위임에 대해 명시된 제한을 초과하는 경우 서버의 동작은 정의되지 않습니다.

서버 조건, 할당량 또는 사용 가능한 파일 시스템 공간에 따라 서버는 매우 제한적인 공간 제한을 통해 쓰기 공개 위임을 부여할 수 있습니다. 수정된 데이터가 서버를 닫을 때 항상 강제로 플러시되는 방식으로 제한 사항을 정의할 수 있습니다.

인증과 관련하여 CLOSE가 발생한 후 수정된 데이터를 서버에 플러시하는 것은 문제가 될 수 있습니다. 예를 들어, 응용 프로그램 사용자가 클라이언트에서 로그오프했고 만료되지 않은 인증 자격 증명이 없을 수 있습니다. 이 경우, 고객은 로컬이 만료되지 않았는지 확인하기 위해 특별한 주의를 기울여야 할 수도 있습니다.

실제로 자격 증명을 사용할 수 있습니다. 이는 자격 증명의 만료 시간을 추적하고 만료되기 훨씬 전에 데이터를 플러시하거나 필요할 때 가용성을 보장하기 위해 자격 증명의 개인 복사본을 만들어 수행할 수 있습니다.

---
#### **9.4.2.  Open Delegation and File Locks**

클라이언트가 쓰기 열기 위임을 보유하면 잠금 작업이 로컬로 수행될 수 있습니다. 여기에는 필수 파일 잠금에 필요한 항목이 포함됩니다. 위임은 충돌하는 잠금이 있을 수 없음을 암시하므로 이는 수행될 수 있습니다. 마찬가지로 일반적으로 잠금 획득 및 잠금 해제와 관련된 데이터 플러시와 관련된 모든 재검증을 수행할 필요가 없습니다.

클라이언트가 읽기 열기 위임을 보유하면 잠금 작업이 로컬로 수행되지 않습니다. 비독점 잠금 요청을 포함한 모든 잠금 작업은 해결을 위해 서버로 전송됩니다.

---
#### **9.4.3.  Handling of CB_GETATTR**

서버는 대상이 쓰기 열기 위임이 유효한 파일인 GETATTR에 대해 특수 처리를 사용해야 합니다. 그 이유는 쓰기 위임을 보유한 클라이언트가 데이터를 수정했을 수 있으며 서버는 이 변경 사항을 GETATTR을 제출한 두 번째 클라이언트에 반영해야 하기 때문입니다. 따라서 쓰기 위임을 보유한 클라이언트를 조사해야 합니다. 서버는 CB\_GETATTR 작업을 사용합니다. 서버가 CB\_GETATTR을 통해 안정적으로 쿼리할 수 있는 유일한 속성은 크기와 변경입니다.

CB\_GETATTR은 다른 클라이언트의 GETATTR 요청을 충족하는 데 사용되므로 서버는 위임을 보유한 클라이언트가 파일의 수정된 버전을 가지고 있는지만 알면 됩니다. 클라이언트의 위임된 파일 복사본이 수정되지 않은 경우\(데이터 또는 크기\) 서버는 서버에 로컬로 저장된 속성을 사용하여 두 번째 클라이언트의 GETATTR 요청을 충족할 수 있습니다. 파일이 수정되면 서버는 이 수정된 상태에 대해서만 알면 됩니다. 서버가 파일이 현재 수정되었다고 판단하면 파일이 서버에서 로컬로 수정된 것처럼 두 번째 클라이언트의 GETATTR에 응답합니다.

변경 속성의 형식은 서버에 의해 결정되고 클라이언트에게는 불투명하므로 클라이언트와 서버는 파일의 수정된 상태를 전달하는 방법에 동의해야 합니다. 크기 속성의 경우 클라이언트는 파일 크기의 현재 보기를 보고합니다.

변경 속성의 경우 처리가 더 복잡합니다.

클라이언트의 경우 쓰기 위임을 받을 때 다음 단계가 수행됩니다.

o 변경 속성의 값은 서버에서 가져와 캐시됩니다. 이 값을 c로 표현하겠습니다.

o 클라이언트는 클라이언트에 보관된 수정된 데이터를 전달하는 데 사용되는 c보다 큰 값을 생성합니다. 이 값을 d로 표현하겠습니다.

o 클라이언트가 CB\_GETATTR을 통해 변경 사항을 쿼리하는 경우

- 속성은 수정된 데이터를 보유하고 있는지 확인합니다. 파일이 수정되면 변경 속성 값으로 d 값이 반환됩니다. 이 파일이 현재 수정되지 않은 경우 클라이언트는 변경 속성에 대해 c 값을 반환합니다.

구현을 단순화하기 위해 클라이언트는 각 CB\_GETATTR에 대해 동일한 값 d를 반환할 수 있습니다. 이는 연속적인 CB\_GETATTR 작업 사이에 클라이언트가 캐시의 파일 데이터나 메타데이터를 다시 수정하는 경우에도 마찬가지입니다. 유일한 요구 사항은 클라이언트가 수정된 데이터를 보유하고 있음을 서버에 표시할 수 있어야 하기 때문에 클라이언트는 동일한 값을 반환할 수 있습니다. 따라서 d의 값은 항상 c + 1일 수 있습니다.\(MAY\)

서버가 변경 사항을 계산하는 시간 단위가 무엇인지 알 수 없다는 점에서 변경 속성은 클라이언트에게 불투명하지만, 클라이언트가 이를 부호 없는 정수로 처리해야 한다는 점에서는 불투명하지 않습니다. 서버는 해당 정수에 대한 클라이언트의 변경 결과를 볼 수 있어야 합니다. 따라서 서버는 변경 속성을 클라이언트에 전송할 때 네트워크 순서대로 인코딩해야 합니다. 클라이언트는 이를 수신할 때 네트워크 순서에서 기본 순서로 디코딩해야 하며 클라이언트는 서버에 보낼 때 네트워크 순서를 인코딩해야 합니다. 이러한 이유로 변경은 불투명한 옥텟 배열이 아닌 부호 없는 정수로 정의됩니다.\(MUST, MUST\)

서버의 경우 쓰기 위임을 제공할 때 다음 단계가 수행됩니다.

o 쓰기 위임을 제공하면 서버는 위임을 기록하는 데 사용하는 데이터 구조에 변경 속성의 복사본을 캐시합니다. 이 값을 sc로 표현하겠습니다.

o 두 번째 클라이언트가 동일한 파일에 대한 GETATTR 작업을 서버로 보내면 서버는 첫 번째 클라이언트로부터 변경 속성을 얻습니다. 이 값을 cc로 둡니다.

o cc 값이 sc와 같으면 파일은 수정되지 않으며 서버는 변경 사항, time\_metadata 및 time\_modify\(예:\)에 대한 현재 값을 두 번째 클라이언트에 반환합니다.

o cc 값이 sc와 같지 않으면 파일은 현재 첫 번째 클라이언트에서 수정되었으며 나중에 서버에서도 수정될 가능성이 높습니다. 그런 다음 서버는 현재 시간을 사용하여 time\_metadata 및 time\_modify에 대한 속성 값을 구성합니다. nsc라고 부르는 새로운 sc 값은 nsc \>= sc + 1과 같이 서버에 의해 계산됩니다. 그런 다음 서버는 구성된 time\_metadata, time\_modify 및 nsc 값을 요청자에게 반환합니다. 서버는 위임 레코드의 sc를 nsc로 바꿉니다. time\_modify, time\_metadata 및 변경 사항이 뒤로 이동하는 것처럼 보일 가능성을 방지하려면\(위임이 취소되거나 반환되기 전에 위임을 보유한 클라이언트가 수정된 데이터를 서버에 기록하지 못한 경우 발생\) 서버는 파일의 구성된 속성 값이 있는 메타데이터 레코드입니다. 합리적인 성능을 위해 구성된 속성 값을 안정적인 저장소에 커밋하는 것은 선택 사항입니다.\(SHOULD, MAY\)

- 이 섹션 앞부분에서 설명한 것처럼 클라이언트는 후속 CB\_GETATTR 호출에서 동일한 cc 값을 반환할 수 있습니다. 이는 연속적인 CB\_GETATTR 호출 사이에 클라이언트 캐시에서 파일이 다시 수정된 경우에도 마찬가지입니다. 따라서 서버는 파일이 다시 수정되었다고 가정해야 하며, 구성하고 반환하는 새 nsc가 반환한 이전 nsc보다 큰지 확인해야 합니다. 예제 구현의 위임 레코드는 위임이 승인될 때 false로 설정되는 부울 필드\("수정"이라고 함\)와 변경 속성 값에 대한 승인 시 설정된 sc 값을 포함하여 이 명령을 충족합니다. 수정된 필드는 처음 cc != sc일 때 true로 설정되고 위임이 반환되거나 취소될 때까지 true로 유지됩니다. nsc, time\_modify 및 time\_metadata 구성 처리에서는 다음 의사 코드를 사용합니다.\(MAY, MUST\)

```text
      if (!modified) {
          do CB_GETATTR for change and size;

             if (cc != sc)
                 modified = TRUE;
         } else {
                 do CB_GETATTR for size;
         }

         if (modified) {
             sc = sc + 1;
          time_modify = time_metadata = current_time;

          update sc, time_modify, time_metadata into file's metadata;
      }
```

GETATTR을 보낸 클라이언트에게 속성을 반환합니다.

- 요청했지만 크기가 CB\_GETATTR이 반환한 것에서 나온 것인지 확인하세요. 클라이언트가 수정한 크기로 파일의 메타데이터를 업데이트하지 마세요.

o 파일 속성 크기가 서버의 현재 값과 다른 경우, 서버는 CB\_GETATTR을 통해 검색된 변경 속성의 값과 관계없이 이를 수정으로 처리하고 마지막 단계와 마찬가지로 두 번째 클라이언트에 응답합니다.

이 방법론은 클라이언트와 서버 간의 클럭 차이 문제와 CB\_GETATTR 사용이 중단되는 기타 시나리오를 해결합니다.

서버는 CB\_GETATTR을 사용할 의무가 없으므로 서버는 위임의 사용을 피하기 위해 단순히 위임을 회수할 수도 있습니다.\(MAY\)

---
#### **9.4.4.  Recall of Open Delegation**

다음과 같은 경우에는 공개 위임을 회수해야 합니다.

```text
   o  Potentially conflicting OPEN request (or READ/WRITE done with
      "special" stateid)
```

o 다른 클라이언트가 발행한 SETATTR

o 파일에 대한 REMOVE 요청

o RENAME의 소스 또는 대상으로 파일에 대한 RENAME 요청

파일로 이어지는 경로에 있는 디렉터리의 RENAME으로 인해 공개 위임이 회수되는지 여부는 서버 파일 시스템의 의미에 따라 달라집니다. 파일이 열려 있을 때 해당 파일 시스템이 이러한 RENAME을 거부하는 경우 문제의 파일이 실제로 열려 있는지 확인하기 위해 호출을 수행해야 합니다.

위의 상황 외에도 서버는 자원 제약으로 인해 그렇게 하는 것이 바람직할 경우 언제든지 공개 위임을 회수하도록 선택할 수 있습니다. 고객은 항상 리콜 가능성에 대비해야 합니다.

클라이언트가 공개 위임에 대한 회수를 받으면 위임을 반환하기 전에 서버의 상태를 업데이트해야 합니다. 클라이언트가 자발적으로 위임을 반환하기로 선택할 때마다 이와 동일한 업데이트를 수행해야 합니다. 다음과 같은 상태 항목을 처리해야 합니다.

o 위임과 관련된 파일이 더 이상 열려 있지 않고 이전 CLOSE 작업이 서버로 전송되지 않은 경우 CLOSE 작업을 서버로 전송해야 합니다.

o 파일에 클라이언트에 다른 열린 참조가 있는 경우 OPEN 작업을 서버로 보내야 합니다. 위임 stateid가 더 이상 유효하지 않으므로 클라이언트가 나중에 사용할 수 있도록 서버에서 적절한 stateid를 제공합니다. 이러한 OPEN 요청은 CLAIM\_DELEGATE\_CUR의 클레임 유형으로 수행됩니다. 이를 통해 클라이언트가 OPEN을 수행하기 위한 적절한 권한을 설정할 수 있도록 위임 stateid를 표시할 수 있습니다. \(자세한 내용은 "작업 18: OPEN" 섹션을 참조하세요.\)

o 파일 잠금이 부여된 경우 해당 LOCK 작업을 수행해야 합니다. 이는 쓰기 공개 위임의 경우에만 적용됩니다.

o 쓰기 열기 위임의 경우 회수 시 파일이 쓰기용으로 열려 있지 않은 경우 파일에 대해 수정된 모든 데이터를 서버로 플러시해야 합니다. 위임이 존재하지 않았다면 클라이언트는 CLOSE 작업 전에 이 데이터 플러시를 수행했을 것입니다.

o 회수 시점에 파일이 아직 열려 있는 경우 쓰기 열기 위임의 경우 해당 파일에 대해 수정된 모든 데이터를 서버로 플러시해야 합니다.

o 쓰기 열기 위임이 적용되면 위임 기간 동안 파일이 잘릴 수 있습니다. 예를 들어 크기 속성 값이 0인 OPEN UNCHECKED의 결과로 잘림이 발생할 수 있습니다. 따라서 파일 잘림이 발생했지만 이 작업이 서버에 전파되지 않은 경우 수정된 데이터가 서버에 기록되기 전에 잘림이 발생해야 합니다.

쓰기 공개 위임의 경우 파일 잠금에는 몇 가지 추가 요구 사항이 적용됩니다. 연관된 불변성을 정확하게 유지하려면 쓰기 위임이 유효한 동안 쓰기 잠금이 해제된 모든 영역에서 수정된 데이터를 플러시해야 합니다. 그러나 쓰기 열기 위임은 다른 클라이언트에 의한 다른 잠금을 의미하지 않기 때문에 쓰기 열기 위임이 적용되는 동안 쓰기 잠금이 해제된 경우 파일에 대해 수정된 모든 데이터를 플러시하는 것이 더 간단한 구현입니다\(위에서 설명한 대로\).

구현 고려 사항\(예: 리소스 가용성 제약\)으로 인해 위의 작업을 수행하는 것이 바람직할 경우 구현에서는 위임이 회수될 때까지\(또는 위임을 자발적으로 반환하기로 결정할 때까지\) 기다릴 필요가 없습니다. 그러나 일반적으로 파일의 실제 열린 상태가 계속 변경될 수 있다는 사실로 인해 위임 반환의 일부를 제외하고 열기 및 닫기에 대한 정보를 서버에 보내는 것은 가치가 없습니다. 위임을 획득한 개시를 마감하는 경우에만 고객이 이를 조기에 수행할 가능성이 높습니다. 이 경우 일단 완료된 마감은 취소되지 않기 때문입니다. 이러한 작업 예약에 대한 클라이언트의 선택에 관계없이 위임을 초래한 개시에 해당하는 마감을 포함하여 \(해당되는 경우\) 위임이 반환되기 전에 모든 작업을 수행해야 합니다. 이러한 작업은 이전 요청이나 동일한 COMPOUND 요청의 이전 작업에서 수행될 수 있습니다.

---
#### **9.4.5.  Clients that Fail to Honor Delegation Recalls**

서버에서 클라이언트로의 콜백 경로 실패 등 다양한 이유로 클라이언트가 회수에 응답하지 못할 수 있습니다. 클라이언트는 콜백 경로의 오류를 인식하지 못할 수 있습니다. 이러한 인식 부족으로 인해 클라이언트는 위임이 취소된 후 오랜 시간이 지나서 클라이언트가 위임한 데이터를 다른 클라이언트가 수정했다는 사실을 알게 될 수 있습니다. 이는 쓰기 위임을 보유한 클라이언트의 경우 특히 문제가 됩니다.

또한 서버에는 회수에 응답하지 않는 클라이언트가 임대가 만료되기 전에 임대를 갱신하는 요청을 포함하여 다른 NFS 요청을 보낼 수도 있다는 딜레마가 있습니다. 임대 갱신 작업에 대해 오류를 반환하지 않고 서버는 클라이언트가 위임이 유효하다고 믿도록 유도합니다.

이 어려움은 다음 규칙에 따라 해결됩니다.

o 콜백 경로가 다운되었을 때 다음 중 하나가 발생하면 서버는 위임을 취소해서는 안 됩니다.\(MUST NOT\)

- - 클라이언트가 RENEW 작업을 실행했고 서버가 NFS4ERR\_CB\_PATH\_DOWN 오류를 반환했습니다. 서버는 서버가 알고 있는 클라이언트의 레코드 잠금 및 공유 예약에 대한 임대를 갱신해야 합니다\(클라이언트가 설정했지만 위임으로 인해 아직 서버에 전송되지 않은 잠금 및 공유 예약과 반대\). 서버는 클라이언트의 위임을 취소하기 전에 클라이언트에게 서버에 위임을 반환할 수 있는 합리적인 시간을 제공해야 합니다.\(MUST, SHOULD\)

- - 서버가 위임 회수를 시도한 후 클라이언트가 일정 기간 동안 RENEW 작업을 실행하지 않았습니다. 이 기간은 Lease\_time 속성 값보다 작아서는 안 됩니다.\(MUST NOT\)

o 클라이언트가 위임을 보유한 경우 콜백 경로 실패 시 위임 임대를 갱신하기 위해 stateid를 사용하는 RENEW를 제외한 작업에 의존할 수 없습니다. 콜백 경로 실패 시에도 위임을 유지하려는 클라이언트는 이를 위해 RENEW를 사용해야 합니다.

---
#### **9.4.6.  Delegation Revocation**

위임이 취소되는 시점에 클라이언트에 연결된 열기가 있는 경우 이러한 열기를 보유하는 애플리케이션에 알려야 합니다. 이 알림은 일반적으로 읽기/쓰기 작업에 대한 오류를 반환하거나 열린 파일에 대해 닫기를 시도할 때 발생합니다.

위임이 취소된 시점에 파일에 대한 열기가 없으면 취소 알림이 필요하지 않습니다. 그러나 클라이언트에 파일에 대한 수정된 데이터가 있는 경우 애플리케이션 사용자에게 알려야 합니다. 안타깝게도 활성 애플리케이션이 클라이언트에 없을 수 있으므로 사용자에게 알리는 것이 불가능할 수 있습니다. 자세한 내용은 "쓰기 공개 위임을 위한 해지 복구" 섹션을 참조하세요.

---
### **9.5.  Data Caching and Revocation**

잠금 및 위임이 취소되면 성공적인 캐싱에 대한 가정이 더 이상 보장되지 않습니다. 잠금 또는 공유 예약이 취소된 경우 해당 소유자에게 알려야 합니다. 이 알림에는 취소된 해당 위임이 있는 파일이 열려 있는 애플리케이션이 포함됩니다. 취소와 관련된 캐시된 데이터는 클라이언트에서 제거되어야 합니다. 클라이언트 캐시에 수정된 데이터가 있는 경우 해당 데이터는 서버에 기록되지 않고 클라이언트에서 제거되어야 합니다. 언급한 대로 클라이언트가 가정한 가정은 잠금이나 위임이 취소된 시점에는 더 이상 유효하지 않습니다. 예를 들어, 첫 번째 클라이언트에서 잠금이 취소된 후 다른 클라이언트에 충돌하는 잠금이 부여되었을 수 있습니다. 따라서 잠금 범위 내의 데이터가 다른 클라이언트에 의해 수정되었을 수 있습니다. 분명히 첫 번째 클라이언트는 해지 시 파일에 어떤 일이 발생했는지 애플리케이션에 보장할 수 없습니다.

잠금 소유자에 대한 알림은 대부분의 경우 열린 파일에 대한 다음 및 모든 후속 읽기/쓰기 또는 닫기 시 오류를 반환하는 것으로 구성됩니다. 특정 오류로 인해 고객이 사용할 수 있는 방법으로 인해 그러한 통지가 불가능해지는 경우

작업이 반환되지 않을 수 있으므로 신호나 프로세스 종료와 같은 보다 과감한 조치가 적절할 수 있습니다. 이에 대한 정당성은 애플리케이션이 의존하는 불변성이 위반될 수 있다는 것입니다. 클라이언트 운영 환경에서 오류가 일반적으로 처리되는 방식에 따라 로깅, 콘솔 메시지 및 GUI 팝업을 포함한 추가 알림 수준이 적절할 수 있습니다.

---
#### **9.5.1.  Revocation Recovery for Write Open Delegation**

쓰기 열기 위임에 대한 해지 복구는 파일이 열려 있지 않은 동안 클라이언트 캐시의 데이터가 수정되는 특수 문제를 발생시킵니다. 이 상황에서 각 닫을 때 수정된 데이터를 서버에 플러시하지 않는 클라이언트는 사용자가 해지 결과로 발생한 실패에 대한 적절한 알림을 받도록 해야 합니다. 이러한 상황에서는 문제를 해결하기 위해 사람의 조치가 필요할 수 있으므로 해당 사용자나 관리자에게 알리는 알림 체계가 필요할 수 있습니다. 로깅 및 콘솔 메시지가 일반적인 예입니다.

클라이언트에 수정된 데이터가 있는 경우 서버에 정상적으로 플러시되어서는 안 됩니다. 클라이언트는 복구를 용이하게 하기 위해 파일 시스템 이름 공간에서 다른 이름으로 위임 중에 수정된 파일 데이터의 복사본을 제공하려고 시도할 수 있습니다. 파일이 다른 클라이언트에 의해 수정되지 않았음을 클라이언트가 확인할 수 있거나 클라이언트가 문제의 파일에 대해 완전히 캐시된 복사본을 가지고 있는 경우, 클라이언트의 파일 보기에 대한 저장된 복사본은 다음과 같은 경우에 특별한 가치가 있을 수 있습니다. 회복. 다른 경우에는 부분적으로는 클라이언트의 캐시된 데이터를 기반으로 하고 부분적으로는 다른 클라이언트가 수정한 서버 복사본을 기반으로 하는 파일 복사본을 사용하여 복구하는 것은 결코 간단하지 않으므로 클라이언트는 이러한 상황에서 파일 내용 저장을 피하거나 결과를 표시할 수 있습니다. 특히 사용자에게 발생할 수 있는 문제를 경고합니다.

위임 철회 상황에서 수정된 데이터를 저장하는 것은 특정 크기의 파일로 제한되거나 대상 파일 시스템 내에서 충분한 디스크 공간을 사용할 수 있는 경우에만 사용될 수 있습니다. 이러한 저장은 캐시된 복사본이 대상 파일 시스템에 적절하게 저장될 때까지 캐시된 복사본을 계속 사용할 수 있을 만큼 클라이언트에 충분한 버퍼링 리소스가 있는 상황으로 제한될 수도 있습니다.

---
### **9.6.  Attribute Caching**

이 섹션에서 설명하는 속성에는 명명된 속성이 포함되지 않습니다. 개별 명명된 속성은 파일과 유사하며 이에 대한 데이터 캐싱은 데이터와 마찬가지로 처리되어야 합니다.

캐싱은 일반 파일용입니다. 마찬가지로 OPENATTR 디렉터리의 LOOKUP 결과는 다른 경로 이름과 동일한 기준으로 캐시되며 디렉터리 내용도 유사합니다.

클라이언트는 서버에서 얻은 파일 속성을 캐시하고 이를 사용하여 후속 GETATTR 요청을 피할 수 있습니다. 이러한 캐싱은 파일 속성에 대한 수정이 항상 서버에 대한 요청을 통해 수행되고 로컬에서 수행되거나 캐시되어서는 안 된다는 점에서 연속 쓰기입니다. 이에 대한 예외는 데이터 캐싱과 밀접하게 연결된 속성에 대한 수정입니다. 따라서 로컬 데이터 캐시에 데이터를 써서 파일을 확장하면 이러한 변경 사항이 서버에 즉시 반영되지 않고 클라이언트에 표시되는 크기에 즉시 반영됩니다. 일반적으로 이러한 변경 사항은 서버에 직접 전파되지 않지만 수정된 데이터가 서버로 플러시되면 서버에서도 유사한 속성 변경이 이루어집니다. 공개 위임이 적용되면 수정된 속성이 CB\_RECALL 호출에 대한 응답으로 서버에 반환될 수 있습니다.

속성의 로컬 캐싱으로 인해 개별 클라이언트에서 유지 관리되는 속성 캐시가 일관되지 않게 됩니다. 서버에서 한 순서로 변경된 사항은 한 클라이언트에서는 다른 순서로, 다른 클라이언트에서는 세 번째 순서로 나타날 수 있습니다.

일반적인 파일 시스템 애플리케이션 프로그래밍 인터페이스는 동시에 여러 파일의 속성을 원자적으로 수정하거나 조사하는 수단을 제공하지 않습니다. 다음 규칙은 위에 언급된 잠재적 불일치를 합리적으로 관리할 수 있는 환경을 제공합니다. 이러한 규칙은 이전 NFS 프로토콜의 관행에서 파생되었습니다.

o 특정 파일의 모든 속성\(fsid별 속성 제외\)은 단일 파일의 컨텍스트 내에서 비직렬화가 발생할 수 없도록 클라이언트에서 하나의 단위로 캐시됩니다.

o 클라이언트 캐시 항목이 서버에서 새로 고쳐지지 않고 유지될 수 있는 기간에 대한 상한 시간 경계가 유지됩니다.

o 서버에서 속성을 변경하는 작업이 수행되면 업데이트된 속성 세트가 포함된 RPC의 일부로 요청됩니다. 여기에는 속성을 간접적으로 업데이트하는 디렉터리 작업이 포함됩니다. 이는 GETATTR 작업으로 수정 작업을 수행한 다음 GETATTR의 결과를 사용하여 클라이언트의 캐시된 속성을 업데이트함으로써 수행됩니다.

캐시할 속성의 전체 집합이 READDIR에 의해 요청되면 클라이언트는 GETATTR을 통해 얻은 속성과 동일한 기반으로 결과를 캐시할 수 있습니다.

클라이언트는 변경 속성과 time\_access 속성을 모두 가져오고 변경 속성이 속성이 캐시되었을 때와 동일한 값을 갖는 경우 time\_access 이외의 속성은 변경되지 않았다고 가정하여 파일에 대한 캐시된 속성 버전의 유효성을 검사할 수 있습니다. time\_access도 가져오는 이유는 변경 내용을 업데이트하는 작업이 time\_access를 업데이트하지 않는 환경에서 운영되는 서버가 많기 때문입니다. 예를 들어 POSIX 파일 의미 체계는 쓰기 시스템 호출로 파일이 수정될 때 액세스 시간을 업데이트하지 않습니다. 따라서 현재 time\_access 값을 원하는 클라이언트는 속성 캐시 검증 처리 중에 변경된 값을 가져와서 캐시된 time\_access를 업데이트해야 합니다.

클라이언트는 수정된 일반 파일의 데이터\(크기, 시간\_수정 및 변경\)와 밀접하게 연결된 속성에 대한 수정된 속성의 캐시를 유지할 수 있습니다. 이 세 가지 속성 외에 클라이언트는 수정된 속성의 캐시를 유지해서는 안 됩니다. 대신 속성 변경 사항이 즉시 서버로 전송됩니다.\(MUST NOT\)

일부 운영 환경에서는 파일 객체의 내용을 읽을 때마다 time\_access에 해당하는 내용이 암시적으로 업데이트될 것으로 예상됩니다. NFS 클라이언트가 일반 파일, 디렉터리, 심볼릭 링크 등 파일 객체의 콘텐츠를 캐싱하는 경우 클라이언트는 각 항목으로 서버의 time\_access 속성\(SETATTR 또는 작은 READ 또는 READDIR 요청을 통해\)을 업데이트해서는 안 됩니다. 캐시에서 만족된 읽기입니다. 그 이유는 특히 time\_access의 명시적인 SETATTR이 서버의 변경 속성을 변경할 수 있기 때문에 콘텐츠 캐싱의 성능 이점을 상실할 수 있기 때문입니다. 변경 속성이 변경되면 콘텐츠를 캐싱하는 클라이언트는 콘텐츠가 변경되었다고 생각하고 서버에서 수정되지 않은 데이터를 다시 읽습니다. 또한 클라이언트는 수정된 버전의 time\_access를 캐시에 유지하도록 권장되지 않습니다. 이는 클라이언트가 결국 나쁜 성능 영향으로 서버에 액세스 시간을 기록해야 하거나 서버의 time\_access를 업데이트하지 않음을 의미하기 때문입니다. 결과적으로 동일한 파일의 닫힘과 열기 사이의 액세스 시간을 캐시하는 응용 프로그램이 과거와 현재 사이를 오가는 액세스 시간을 관찰하는 상황이 발생합니다. time\_access 속성은 항상 서버에서 만족한 읽기를 통해 파일에 마지막으로 액세스한 시간을 의미합니다. 이런 식으로 클라이언트는 앞으로 진행되는 time\_access 변경 사항만 보는 경향이 있습니다.\(SHOULD NOT\)

---
### **9.7.  Data and Metadata Caching and Memory Mapped Files**

일부 운영 환경에는 응용 프로그램이 파일 내용을 응용 프로그램의 주소 공간에 매핑하는 기능이 포함되어 있습니다. 응용 프로그램이 주소 공간에 로드되지 않은 블록에 해당하는 메모리 위치에 액세스할 때마다 페이지 폴트가 발생하고 파일을 읽습니다.

파일에 블록이 할당된 다음 애플리케이션의 주소 공간에 인스턴스화됩니다.

파일에 대한 각 메모리 매핑 액세스에 페이지 오류가 필요한 한 액세스 및 수정을 감지하는 데 사용되는 파일의 관련 속성\(time\_access, time\_metadata, time\_modify 및 변경\)이 업데이트됩니다. 그러나 많은 운영 환경에서 페이지 폴트가 필요하지 않은 경우 이러한 속성은 메모리 액세스를 통해 파일을 읽거나 업데이트할 때 업데이트되지 않습니다\(파일이 로컬 파일인지 또는 원격으로 액세스되는지 여부에 관계 없음\). 클라이언트나 서버는 메모리 매핑 I/O를 통해 액세스되는 파일의 속성을 업데이트하지 못할 수 있습니다. 이는 다음과 같은 몇 가지 의미를 갖습니다.\(MAY\)

o 클라이언트도 액세스하고 있는 파일에 메모리 매핑된 응용 프로그램이 서버에 있는 경우 클라이언트는 캐시가 오래되었는지 여부를 확인하기 위해 변경 속성의 일관된 값을 얻지 못할 수 있습니다. 파일이 메모리 매핑되어 있음을 알고 있는 서버는 항상 변경 사항에 대해 업데이트된 값을 비관적으로 반환하여 응용 프로그램이 항상 파일에 대한 최신 데이터와 메타데이터를 가져오도록 할 수 있습니다. 그러나 이는 성능에 부정적인 영향을 미치므로 이러한 동작은 선택 사항입니다.\(MAY\)

o 메모리 매핑된 파일이 서버에서 수정되지 않고 대신 메모리 매핑된 인터페이스를 통해 애플리케이션에서 읽는 중이라면 클라이언트는 업데이트된 time\_access 속성을 볼 수 없습니다. 그러나 많은 운영 환경에서는 서버에서 프로세스가 실행되지 않습니다. 따라서 NFS 클라이언트는 로컬 프로세스와 관련하여 불이익을 받지 않습니다.

o 파일을 메모리 매핑하는 다른 클라이언트가 있고 해당 클라이언트가 쓰기 위임을 보유하고 있는 경우 이전 두 글머리 기호 항목에서 설명한 것과 동일한 문제 세트가 적용됩니다. 따라서 서버가 클라이언트가 캐시에서 수정한 파일에 대해 CB\_GETATTR을 수행하면 CB\_GETATTR의 응답이 반드시 정확하지는 않습니다. 앞에서 설명한 것처럼 클라이언트의 의무는 연속적인 CB\_GETATTR 호출 사이에 파일이 다시 수정되었는지 여부가 아니라 위임이 허용된 이후 파일이 수정되었음을 보고하는 것이며 서버는 클라이언트가 캐시에서 수정한 모든 파일이 수정되었다고 가정해야 합니다. 연속적인 CB\_GETATTR 호출 사이에서 다시 수정되었습니다. 클라이언트의 메모리 관리 시스템의 특성에 따라 이러한 약한 의무는 불가능할 수도 있습니다. 클라이언트는 파일이 메모리 매핑될 때마다 CB\_GETATTR에 오래된 정보를 반환할 수 있습니다.\(MUST, MAY\)

o 동일한 파일에 대한 메모리 매핑과 파일 잠금의 혼합은 문제가 있습니다. 각 클라이언트의 페이지 크기가 8192바이트인 다음 시나리오를 고려해 보세요.

- - 클라이언트 A 메모리는 파일 X의 첫 번째 페이지\(8192바이트\)를 매핑합니다.

- - 클라이언트 B 메모리는 파일 X의 첫 번째 페이지\(8192바이트\)를 매핑합니다.

- - 클라이언트 A 쓰기는 처음 4096바이트를 잠급니다.

```text
      -  Client B write locks second 4096 bytes
```

- - 클라이언트 A는 STORE 명령을 통해 잠긴 영역의 일부를 수정합니다.

- - 클라이언트 A와 동시에 클라이언트 B는 잠긴 영역의 일부에 STORE를 발행합니다.

여기서 과제는 첫 번째 페이지의 올바른 보기를 얻기 위해 각 클라이언트가 재동기화하는 것입니다. 많은 운영 환경에서 각 클라이언트의 가상 메모리 관리 시스템은 페이지가 수정되었다는 사실만 알고 각 잠금 영역에 해당하는 페이지의 하위 집합이 수정되었다는 사실은 알지 못합니다. 따라서 각 클라이언트가 올바른 작업, 즉 잠긴 페이지 부분만 서버에 쓰는 것은 불가능합니다. 예를 들어 클라이언트 A가 단순히 페이지를 작성한 다음 클라이언트 B가 페이지를 작성한 경우 클라이언트 A의 데이터가 손실됩니다.

게다가 파일에 필수 잠금이 활성화되어 있으면 다른 문제가 발생합니다. 클라이언트 A와 B가 STORE 명령을 실행하면 결과 페이지 오류로 인해 전체 페이지에 대한 레코드 잠금이 필요합니다. 그런 다음 각 클라이언트는 잠긴 범위를 전체 페이지로 확장하려고 시도하며 이로 인해 교착 상태가 발생합니다.

NFS4ERR\_DEADLOCK 오류를 STORE 명령에 전달하는 것은 기껏해야 어렵습니다.

클라이언트가 전체 메모리 매핑된 파일을 잠그는 경우 적어도 클라이언트가 파일 중간에 있는 영역을 잠금 해제할 때까지는 권고 또는 필수 레코드 잠금에 문제가 없습니다.

위의 문제를 고려하면 다음이 허용됩니다.

- 클라이언트와 서버는 레코드 잠금이 있는 파일에 대한 메모리 매핑을 거부할 수 있습니다.\(MAY\)

- 클라이언트와 서버는 메모리 매핑된 파일에 대한 레코드 잠금을 거부할 수 있습니다.\(MAY\)

- 클라이언트는 I/O에 대한 필수 잠금이 필요한 파일에 대한 메모리 매핑을 거부할 수 있습니다. 파일이 열리고 매핑된 후 필수 잠금이 활성화되면 클라이언트는 매핑된 파일에 대한 응용 프로그램의 추가 액세스를 거부할 수 있습니다.\(MAY, MAY\)

---
### **9.8.  Name Caching**

LOOKUP 및 READDIR 작업의 결과는 후속 LOOKUP 작업 비용을 피하기 위해 캐시될 수 있습니다. 속성 캐싱의 경우와 마찬가지로 다양한 클라이언트 캐시 간에 불일치가 발생할 수 있습니다. 이러한 불일치의 영향을 완화하고 일반적인 파일 시스템 API의 컨텍스트를 고려하여 클라이언트 이름 캐시 항목이 수행된 디렉터리 변경 작업에 의해 항목이 유효하지 않게 만들어지지 않았는지 확인하지 않고 클라이언트 이름 캐시 항목을 유지할 수 있는 기간에 대한 상한 시간 경계가 유지됩니다. 다른 클라이언트.

클라이언트가 이름 캐시 항목이 있는 디렉터리를 변경하지 않는 경우 클라이언트는 해당 디렉터리가 수정되지 않도록 정기적으로 해당 디렉터리의 속성을 가져와야 합니다. 수정 사항이 발생하지 않았음을 확인한 후 관련 이름 캐시 항목의 만료 시간은 현재 시간에 이름 캐시 유효 기간 제한을 더한 값으로 업데이트될 수 있습니다.

클라이언트가 특정 디렉터리를 변경할 때 다른 클라이언트가 해당 디렉터리를 변경했는지 여부를 확인해야 합니다. 이는 작업에 대해 반환된 관련change\_info4 값에서 디렉터리 작업 전후에 보고된 변경 속성을 사용하여 수행됩니다. 서버는 디렉토리 작업과 관련하여 Change\_info4 데이터가 원자적으로 제공되는지 여부를 클라이언트와 통신할 수 있습니다. 변경 값이 원자적으로 제공되면 클라이언트는 작업 전 변경 값을 클라이언트 이름 캐시의 변경 값과 비교할 수 있습니다. 비교 결과 디렉터리가 다른 클라이언트에 의해 업데이트되었음을 ​​나타내는 경우 수정된 디렉터리와 관련된 이름 캐시가 클라이언트에서 제거됩니다. 비교 결과 수정 사항이 없는 것으로 나타나면 클라이언트에서 이름 캐시를 업데이트하여 디렉터리 작업 및 관련 제한 시간 연장을 반영할 수 있습니다. 작업 후 변경 값은 향후change\_info4 비교를 위한 기초로 저장되어야 합니다.

위 시나리오에서 설명한 것처럼 이름 캐싱을 위해서는 클라이언트가 이름 캐시 항목이 캐시된 시점에 디렉터리의 변경 특성을 검사하여 이름 캐시 데이터의 유효성을 다시 검사해야 합니다. 이를 위해서는 해당 디렉토리의 내용이 수정될 때 서버가 디렉토리의 변경 속성을 업데이트해야 합니다. 클라이언트가 Change\_info4 정보를 적절하고 정확하게 사용하기 위해서는 서버가 작업 전후의 변경 속성 값을 원자적으로 보고해야 합니다. 서버가 있을 때

디렉터리 작업과 관련하여 이전 및 이후 값을 원자적으로 보고할 수 없으면 서버는change\_info4 반환 값에 해당 사실을 표시해야 합니다. 정보가 원자적으로 보고되지 않는 경우 클라이언트는 다른 클라이언트가 디렉터리를 변경하지 않았다고 가정해서는 안 됩니다.

---
### **9.9.  Directory Caching**

READDIR 작업의 결과는 후속 READDIR 작업을 방지하는 데 사용될 수 있습니다. 속성 및 이름 캐싱의 경우와 마찬가지로 다양한 클라이언트 캐시 간에 불일치가 발생할 수 있습니다. 이러한 불일치의 영향을 완화하고 일반적인 파일 시스템 API의 컨텍스트를 고려하여 다음 규칙을 따라야 합니다.

o 단일 READDIR 작업에서 얻지 못한 디렉터리에 대한 캐시된 READDIR 정보는 항상 디렉터리 내용의 일관된 스냅샷이어야 합니다. 이는 첫 번째 READDIR 이전과 캐시에 기여하는 마지막 READDIR 이후에 GETATTR을 사용하여 결정됩니다.

o 클라이언트가 캐시된 정보를 재검증해야 하기 전에 디렉터리 캐시 항목이 유효한 것으로 간주되는 기간을 나타내기 위해 상한 시간 경계가 유지됩니다.

유효성 재검사 기술은 이름 캐싱의 경우에서 설명한 것과 유사합니다. 클라이언트가 문제의 디렉터리를 변경하지 않는 경우 GETATTR을 사용하여 디렉터리의 변경 속성을 확인하는 것이 적절합니다. 캐시 항목의 수명은 이러한 검사점에서 연장될 수 있습니다. 클라이언트가 디렉터리를 수정할 때 클라이언트는change\_info4 데이터를 사용하여 디렉터리를 수정하는 다른 클라이언트가 있는지 확인해야 합니다. 다른 클라이언트 수정이 발생하지 않는 것으로 확인되면 클라이언트는 자체 변경 사항을 반영하도록 디렉터리 캐시를 업데이트할 수 있습니다.

이전에 설명했듯이 디렉터리 캐싱에서는 클라이언트가 디렉터리가 캐시된 시점에서 디렉터리의 변경 특성을 검사하여 디렉터리 캐시 데이터의 유효성을 다시 검사해야 합니다. 이를 위해서는 해당 디렉토리의 내용이 수정될 때 서버가 디렉토리의 변경 속성을 업데이트해야 합니다. 클라이언트가 Change\_info4 정보를 적절하고 정확하게 사용하기 위해서는 서버가 작업 전후의 변경 속성 값을 원자적으로 보고해야 합니다. 서버가 디렉터리 작업과 관련하여 이전 및 이후 값을 원자적으로 보고할 수 없는 경우 서버는 Change\_info4 반환 값에 해당 사실을 표시해야 합니다. 정보가 원자적으로 보고되지 않는 경우 클라이언트는 다른 클라이언트가 디렉터리를 변경하지 않았다고 가정해서는 안 됩니다.

---
## **10.  Minor Versioning**

필요에 따라 발전할 수 있는 NFS 프로토콜의 요구 사항을 해결하기 위해 NFS 버전 4 프로토콜에는 향후 사소한 변경이나 버전 관리를 허용하는 규칙과 프레임워크가 포함되어 있습니다.

부 버전 관리와 관련된 기본 가정은 향후 승인되는 모든 부 버전이 IETF 프로세스를 따르고 표준 트랙 RFC에 문서화되어야 한다는 것입니다. 따라서 각 부 버전 번호는 RFC에 해당합니다. NFS 버전 4 프로토콜의 부 버전 0은 이 RFC로 표시됩니다. COMPOUND 프로시저는 클라이언트가 요청하는 부 버전의 인코딩을 지원합니다.

다음 항목은 마이너 버전 개발을 위한 기본 규칙을 나타냅니다. 향후 부 버전에서는 부 버전 정의의 일부로 다음 규칙을 수정하거나 추가하기로 결정할 수 있습니다.

1. 절차가 추가되거나 삭제되지 않습니다.

- 일반 RPC 모델을 유지하기 위해 NFS 버전 4 마이너 버전은 NFS 프로그램에서 프로시저를 추가하거나 삭제하지 않습니다.

2. 마이너 버전은 COMPOUND에 작업을 추가할 수 있으며

- CB\_COMPOUND 프로시저.

- COMPOUND 및 CB\_COMPOUND 프로시저에 작업을 추가해도 RPC 모델에는 영향을 미치지 않습니다.

2.1 부 버전은 GETATTR4args, bitmap4 및 GETATTR4res에 특성을 추가할 수 있습니다.

- 이는 미래의 성장이나 적응을 허용하기 위해 속성 모델의 확장을 허용합니다.

2.2 부 버전 X는 마지막으로 문서화된 속성 뒤에 새 속성을 추가해야 합니다.

- 속성 결과는 속성별 XDR 인코딩 결과의 불투명한 배열로 지정되므로 현재 정의 중에 새 속성을 추가하는 복잡성이 너무 부담스러울 것입니다.

3. 마이너 버전은 기존 작업의 인수 또는 결과 구조를 수정해서는 안 됩니다.

- 단일 작업에 대해 여러 구조 정의를 처리하는 복잡성이 너무 부담스럽습니다. 부 버전의 기존 구조를 수정하는 대신 새로운 작업을 추가해야 합니다.

- 이 규칙은 부 버전에서 다음 각색을 배제하지 않습니다.

- o GETATTR의 bitmap4 데이터 유형에 대한 새로운 속성과 같은 플래그 필드에 비트를 추가합니다.

- o 플래그 단어가 있는 ACL과 같은 기존 속성에 비트를 추가합니다.

- o 열거된 유형\(NFS4ERR\_\* 포함\)을 새로운 값으로 확장

4. 마이너 버전은 기존의 구조를 수정할 수 없습니다.

- 속성.

```text
    5.  Minor versions may not delete operations.
```

- 이는 향후 마이너 버전에서 특정 작업 "슬롯"의 잠재적인 재사용을 방지합니다.

```text
    6.  Minor versions may not delete attributes.
```

7. 마이너 버전에서는 플래그 비트나 열거형 값을 삭제할 수 없습니다.

8. 부 버전에서는 작업을 구현하지 않는 것이 필수라고 선언할 수 있습니다.

- 작업을 "구현하지 않도록 필수"로 지정하는 것은 작업을 폐기하는 것과 같습니다. 클라이언트의 경우 이는 작업이 서버로 전송되어서는 안 된다는 의미입니다. 서버의 경우 XDR 디코드 오류로 요청을 "삭제"하는 것과 반대로 NFS 오류가 반환될 수 있습니다. 이 접근 방식을 사용하면 향후 부 버전에서 해당 작업을 다시 도입할 수 있도록 구조를 유지하면서 작업을 폐기할 수 있습니다.

8.1 부 버전에서는 NOT에 필수 속성을 선언할 수 있습니다.

-    구현하다.

8.2 부 버전에서는 플래그 비트 또는 열거형 값을 구현하지 않는 것이 필수 사항으로 선언될 수 있습니다.

9. 부 버전에서는 기능을 필수에서 필수로 다운그레이드할 수 있습니다.

- 추천, 또는 선택사항으로 추천합니다.

10. 마이너 버전에서는 기능을 선택 사항에서 권장 사항으로, 권장 사항에서 필수 사항으로 업그레이드할 수 있습니다.

11. 부 버전 X를 지원하는 클라이언트와 서버는 부 버전 0\(영\)부터 X-1까지도 지원해야 합니다.

12. 부 버전에서는 새로운 기능이 필수로 도입될 수 없습니다.

- 이 규칙은 새로운 기능의 도입을 허용하고 기능을 필수로 지정하기 전에 구현 경험을 강제로 사용하도록 합니다.

13. 클라이언트는 마이너 버전 Y가 있는 다른 COMPOUND 프로시저에 대해 마이너 버전 X가 있는 COMPOUND 프로시저에서 stateid, 파일 핸들 또는 유사한 반환 개체를 사용하려고 시도해서는 안 됩니다\(여기서 X != Y\).\(MUST NOT\)

---
## **11.  Internationalization**

NFS 버전 4가 국제화\(I18N\)를 처리해야 하는 주요 문제는 프로토콜 내에서 사용되는 파일 이름 및 기타 문자열과 관련됩니다. 문자열 표현의 선택은 다양한 언어를 사용하는 클라이언트에 대한 합리적인 이름/문자열 액세스를 허용해야 합니다. \[ISO10646\]에 정의된 UCS의 UTF-8 인코딩은 이러한 유형의 액세스를 허용하며 "문자 집합 및 언어에 대한 IETF 정책", \[RFC2277\]에 설명된 정책을 따릅니다.

"stringprep"이라고도 알려진 \[RFC3454\]는 네트워킹 프로토콜에서 유니코드/UTF-8을 사용하기 위한 프레임워크를 문서화하여 "문자열 입력 및 문자열 비교가 전 세계 일반 사용자에게 적합한 방식으로 작동할 가능성을 높이기 위해"입니다. ." 프로토콜은 "처리 옵션을 완전히 지정하기 위해" stringprep의 프로필을 정의해야 합니다. 이 국제화 섹션의 나머지 부분에서는 NFS 버전 4 stringprep 프로필을 정의합니다. 이 섹션의 나머지 부분에 사용된 용어의 대부분은 stringprep에서 나온 것입니다.

NFS 버전 4에는 utf8str\_cs, utf8str\_cis 및 utf8str\_mixed의 세 가지 UTF-8 문자열 유형이 정의되어 있습니다. 각각에 대해 별도의 프로필이 정의됩니다. 각 프로필은 stringprep의 요구에 따라 다음을 정의합니다.

o 프로파일의 의도된 적용 가능성

```text
   o  The character repertoire that is the input and output to
      stringprep (which is Unicode 3.2 for referenced version of
      stringprep)

   o  The mapping tables from stringprep used (as described in section 3
      of stringprep)
```

o 프로필과 관련된 추가 매핑 테이블

```text
   o  The Unicode normalization used, if any (as described in section 4
      of stringprep)

   o  The tables from stringprep listing of characters that are
      prohibited as output (as described in section 5 of stringprep)

   o  The bidirectional string testing used, if any (as described in
      section 6 of stringprep)
```

o 프로필과 관련된 출력으로 금지된 추가 문자

Stringprep은 유니코드 문자를 설명하는 반면 NFS 버전 4는 UTF-8 문자를 렌더링합니다. UTF-8에서 유니코드로의 일대일 매핑이 있으므로 이 문서의 나머지 부분에서는 유니코드를 참조하므로 독자는 UTF-8을 가정해야 합니다.

프로필 텍스트의 대부분은 \[RFC3454\]에서 나옵니다.

---
### **11.1.  Stringprep profile for the utf8str_cs type**

NFS 버전 4 프로토콜 사양에서 utf8str\_cs 유형 정의를 사용할 때마다 nfs4\_cs\_prep라는 프로필을 따릅니다.

---
#### **11.1.1.  Intended applicability of the nfs4_cs_prep profile**

utf8str\_cs 유형은 대소문자를 구분하는 UTF-8 문자 문자열입니다. NFS 버전 4의 주요 용도는 구성 요소 및 경로 이름을 지정하는 것입니다. 구성 요소와 경로 이름은 서버의 파일 시스템에 저장됩니다. utf8str\_cs 프로필을 통해 처리한 후 두 개의 유효한 고유 UTF-8 문자열이 동일할 수 있습니다. 문자열이 디렉터리 내의 두 이름인 경우 NFS 버전 4 서버는 다음 중 하나를 수행해야 합니다.

o 사후 처리된 형식이 기존 이름과 충돌하는 경우 두 번째 이름 생성을 허용하지 않습니다.

o 두 번째 이름의 생성을 허용하지만 사후 처리 후 두 번째 이름이 첫 번째 이름의 사후 처리된 형식과 다르도록 정렬합니다.

---
#### **11.1.2.  Character repertoire of nfs4_cs_prep**

nfs4\_cs\_prep 프로필은 stringprep의 부록 A.1에 정의된 대로 유니코드 3.2를 사용합니다.

---
#### **11.1.3.  Mapping used by nfs4_cs_prep**

nfs4\_cs\_prep 프로필은 stringprep의 다음 테이블을 사용하여 매핑을 지정합니다.

```text
      Table B.1
```

표 B.2는 주로 대소문자를 구분하지 않는 비교를 처리하기 위한 것이므로 일반적으로 nfs4\_cs\_prep 프로필의 일부가 아닙니다. 그러나 NFS 버전 4 파일 서버가 case\_insensitive 파일 시스템 속성을 지원하고 case\_insensitive가 true인 경우 NFS 버전 4 서버는 utf8str\_cs 문자열을 처리할 때 표 B.2\(표 B1 외에도\)를 사용해야 하며 NFS 버전 4 클라이언트는 \(표 B.1 외에\) 표 B.2가 사용되고 있다고 가정해야 합니다\(MUST\).\(MUST\)

case\_preserving 속성이 존재하고 false로 설정된 경우 NFS 버전 4 서버는 utf8str\_cs 문자열을 처리할 때 대소문자를 매핑하기 위해 표 B.2를 사용해야 합니다. 서버가 소문자에서 대문자로 매핑되는지 아니면 대문자에서 소문자로 매핑되는지 여부는 구현 종속성입니다.\(MUST\)

---
#### **11.1.4.  Normalization used by nfs4_cs_prep**

nfs4\_cs\_prep 프로필은 정규화 형식을 지정하지 않습니다. 이 사양의 이후 개정판에서는 특정 정규화 형식을 지정할 수 있습니다. 따라서 서버와 클라이언트는 프로토콜 요청 및 응답 내에서 정규화되지 않은 문자를 받을 수 있다고 예상할 수 있습니다. 운영 환경에 정규화가 필요한 경우 구현 시 애플리케이션\(클라이언트\) 또는 로컬 파일 시스템\(서버\)에 정보를 제공하기 전에 프로토콜 내에서 utf8str\_cs 문자열을 정규화해야 합니다.

---
#### **11.1.5.  Prohibited output for nfs4_cs_prep**

nfs4\_cs\_prep 프로필은 stringprep에서 다음 테이블을 사용하는 것을 금지하도록 지정합니다.

```text
      Table C.3
      Table C.4
      Table C.5
      Table C.6
      Table C.7
      Table C.8
      Table C.9
```

---
#### **11.1.6.  Bidirectional output for nfs4_cs_prep**

nfs4\_cs\_prep 프로필은 양방향 문자열 검사를 지정하지 않습니다.

---
### **11.2.  Stringprep profile for the utf8str_cis type**

NFS 버전 4 프로토콜 사양에서 utf8str\_cis 유형 정의를 사용할 때마다 nfs4\_cis\_prep이라는 프로필을 따릅니다.

---
#### **11.2.1.  Intended applicability of the nfs4_cis_prep profile**

utf8str\_cis 유형은 대소문자를 구분하지 않는 UTF-8 문자 문자열입니다. NFS 버전 4의 주요 용도는 NFS 서버 이름을 지정하는 것입니다.

---
#### **11.2.2.  Character repertoire of nfs4_cis_prep**

nfs4\_cis\_prep 프로필은 stringprep의 부록 A.1에 정의된 대로 유니코드 3.2를 사용합니다.

---
#### **11.2.3.  Mapping used by nfs4_cis_prep**

nfs4\_cis\_prep 프로필은 stringprep의 다음 테이블을 사용하여 매핑을 지정합니다.

```text
      Table B.1
      Table B.2
```

---
#### **11.2.4.  Normalization used by nfs4_cis_prep**

nfs4\_cis\_prep 프로필은 stringprep에 설명된 대로 유니코드 정규화 형식 KC를 사용하도록 지정합니다.

---
#### **11.2.5.  Prohibited output for nfs4_cis_prep**

nfs4\_cis\_prep 프로필은 stringprep에서 다음 테이블을 사용하는 것을 금지하도록 지정합니다.

```text
      Table C.1.2
      Table C.2.2
      Table C.3
      Table C.4
      Table C.5
      Table C.6
      Table C.7
      Table C.8
      Table C.9
```

---
#### **11.2.6.  Bidirectional output for nfs4_cis_prep**

nfs4\_cis\_prep 프로필은 stringprep의 섹션 6에 설명된 대로 양방향 문자열 검사를 지정합니다.

---
### **11.3.  Stringprep profile for the utf8str_mixed type**

NFS 버전 4 프로토콜 사양에서 utf8str\_mixed 유형 정의를 사용할 때마다 nfs4\_mixed\_prep이라는 프로필을 따릅니다.

---
#### **11.3.1.  Intended applicability of the nfs4_mixed_prep profile**

utf8str\_mixed 유형은 대소문자를 구분하는 접두사, '@'과 동일한 구분 기호 및 정규화된 도메인 이름을 나타내는 접미사가 포함된 UTF-8 문자의 문자열입니다. NFS 버전 4의 기본 용도는 액세스 제어 항목에서 식별된 주체의 이름을 지정하는 것입니다.

---
#### **11.3.2.  Character repertoire of nfs4_mixed_prep**

nfs4\_mixed\_prep 프로필은 stringprep의 부록 A.1에 정의된 대로 유니코드 3.2를 사용합니다.

---
#### **11.3.3.  Mapping used by nfs4_cis_prep**

utf8str\_mixed 문자열의 접두사 및 구분 기호의 경우 nfs4\_mixed\_prep 프로필은 stringprep의 다음 테이블을 사용하여 매핑을 지정합니다.

```text
      Table B.1
```

utf8str\_mixed 문자열의 접미사에 대해 nfs4\_mixed\_prep 프로필은 stringprep의 다음 테이블을 사용하여 매핑을 지정합니다.

```text
      Table B.1
      Table B.2
```

---
#### **11.3.4.  Normalization used by nfs4_mixed_prep**

nfs4\_mixed\_prep 프로필은 stringprep에 설명된 대로 유니코드 정규화 형식 KC를 사용하도록 지정합니다.

---
#### **11.3.5.  Prohibited output for nfs4_mixed_prep**

nfs4\_mixed\_prep 프로필은 stringprep에서 다음 테이블을 사용하는 것을 금지하도록 지정합니다.

```text
      Table C.1.2
      Table C.2.2
      Table C.3
      Table C.4
      Table C.5
      Table C.6
      Table C.7
      Table C.8
      Table C.9
```

---
#### **11.3.6.  Bidirectional output for nfs4_mixed_prep**

nfs4\_mixed\_prep 프로필은 stringprep의 섹션 6에 설명된 대로 양방향 문자열 검사를 지정합니다.

---
### **11.4.  UTF-8 Related Errors**

클라이언트가 잘못된 UTF-8 문자열을 보내는 경우 서버는 NFS4ERR\_INVAL 오류를 반환해야 합니다. 여기에는 부적절한 접두사가 감지되는 경우와 전체 UCS 문자를 구성하지 않는 후행 바이트가 개수에 포함되는 경우가 포함됩니다.

클라이언트가 제공한 문자열이 유효한 UTF-8이지만 서버에서 해당 문자열의 값으로 지원하지 않는 문자를 포함하는 경우\(예: 유니코드 문자만 지원하는 파일 시스템에서 2개 이상의 옥텟이 있는 문자가 포함된 이름\), 서버는 NFS4ERR\_BADCHAR 오류를 반환해야 합니다.

UTF-8 문자열이 파일 이름으로 사용되고 파일 시스템이 이름 내의 모든 문자를 지원하지만 해당 특정 이름의 사용을 허용하지 않는 경우 서버는 NFS4ERR\_BADNAME 오류를 반환해야 합니다. 여기에는 서버 파일 시스템이 이름 문자열에 정규화 제약 조건을 부과하는 상황이 포함되지만,

"."의 파일 시스템 금지와 같은 상황도 포함됩니다. 및 ".."는 특정 작업의 파일 이름 및 기타 제약 조건입니다.

---
## **12.  Error Definitions**

NFS 오류 번호는 복합 요청 내에서 실패한 작업에 할당됩니다. 복합 요청에는 결과가 복합 응답에 순서대로 인코딩된 여러 NFS 작업이 포함되어 있습니다. 성공적인 작업의 결과는 NFS4\_OK 상태와 그 뒤에 인코딩된 작업 결과로 구성됩니다. NFS 작업이 실패하면 응답에 오류 상태가 입력되고 복합 요청이 종료됩니다.

정의된 각 오류에 대한 설명은 다음과 같습니다.

NFS4\_OK 작업이 성공적으로 완료되었음을 나타냅니다.

NFS4ERR\_ACCESS 권한이 거부되었습니다. 호출자에게 요청된 작업을 수행할 수 있는 올바른 권한이 없습니다. 이는 소유자 또는 권한 있는 사용자 권한 실패로 제한되는 NFS4ERR\_PERM과 대조됩니다.

NFS4ERR\_ATTRNOTSUPP 지정된 속성은 서버에서 지원되지 않습니다. GETATTR 작업에는 적용되지 않습니다.

NFS4ERR\_ADMIN\_REVOKED 관리자 개입으로 인해

- 잠금 소유자의 기록 잠금, 공유 예약 및 위임이 서버에 의해 취소되었습니다.

NFS4ERR\_BADCHAR UTF-8 문자열에는 서버가 사용 중인 컨텍스트에서 지원하지 않는 문자가 포함되어 있습니다.

NFS4ERR\_BAD\_COOKIE READDIR 쿠키가 오래되었습니다.

NFS4ERR\_BADHANDLE 잘못된 NFS 파일 핸들입니다. 파일 핸들이 내부 일관성 검사에 실패했습니다.

NFS4ERR\_BADNAME 요청의 이름 문자열은 서버에서 지원하는 유효한 UTF-8 문자로 구성되지만 해당 이름은 서버에서 현재 작업에 대한 유효한 이름으로 지원되지 않습니다.

NFS4ERR\_BADOWNER 소유자, owner\_group 또는 ACL 속성 값은 로컬 표현으로 변환될 수 없습니다.

NFS4ERR\_BADTYPE 서버에서 지원하지 않는 유형의 개체를 생성하려고 시도했습니다.

NFS4ERR\_BAD\_RANGE LOCK, LOCKT, LOCKU 연산의 범위가 서버에 허용되는 오프셋 범위에 맞지 않습니다.

NFS4ERR\_BAD\_SEQID 잠금 요청의 시퀀스 번호는 다음 예상 번호도 아니고 처리된 마지막 번호도 아닙니다.

NFS4ERR\_BAD\_STATEID 현재 서버 인스턴스에서 생성되었지만 현재 잠금 소유자-파일 쌍에 대한 잠금 상태\(현재 또는 대체됨\)를 지정하지 않는 상태 ID가 사용되었습니다.

NFS4ERR\_BADXDR 작업을 처리하는 동안 서버에서 XDR 디코딩 오류가 발생했습니다.

NFS4ERR\_CLID\_INUSE SETCLIENTID 작업에서 클라이언트 ID가 이미 다른 클라이언트에서 사용 중임을 발견했습니다.

NFS4ERR\_DEADLOCK 서버는 차단 잠금 요청에 대한 파일 잠금 교착 상태 조건을 확인할 수 있었습니다.

NFS4ERR\_DELAY 서버가 요청을 시작했지만 적시에 완료하지 못했습니다. 클라이언트는 기다렸다가 새 RPC 트랜잭션 ID로 요청을 시도해야 합니다. 예를 들어 이 오류는 계층적 저장소를 지원하고 마이그레이션된 파일을 처리하라는 요청을 받는 서버에서 반환되어야 합니다. 이 경우 서버는 이민 프로세스를 시작하고 클라이언트에 이 오류로 응답해야 합니다. 이 오류는 필요한 위임 회수로 인해 적시에 요청을 처리할 수 없는 경우에도 발생할 수 있습니다.

NFS4ERR\_DENIED 파일 잠금 시도가 거부되었습니다. 이는 일시적인 조건일 수 있으므로 클라이언트는 잠금이 승인될 때까지 잠금 요청을 재시도하는 것이 좋습니다.

NFS4ERR\_DQUOT 리소스\(할당량\) 하드 제한을 초과했습니다. 서버의 사용자 리소스 제한이 초과되었습니다.

NFS4ERR\_EXIST 파일이 존재합니다. 지정한 파일이 이미 존재합니다.

NFS4ERR\_EXPIRED 현재 작업에서 사용 중인 임대가 만료되었습니다.

NFS4ERR\_FBIG 파일이 너무 큽니다. 이 작업으로 인해 파일이 서버 제한을 ​​초과하게 되었을 수 있습니다.

NFS4ERR\_FHEXPIRED 제공된 파일 핸들은 휘발성이며 서버에서 만료되었습니다.

NFS4ERR\_FILE\_OPEN 작업에 관련된 파일이 현재 열려 있어 작업을 성공적으로 처리할 수 없습니다.

NFS4ERR\_GRACE 서버가 서버의 임대 기간과 일치해야 하는 복구 또는 유예 기간에 있습니다.

NFS4ERR\_INVAL 작업에 대해 잘못된 인수 또는 지원되지 않는 인수입니다. 두 가지 예는 기호 링크가 아닌 객체에 대해 READLINK를 시도하거나 프로토콜에 정의되지 않은 열거형 필드에 값을 지정하는 것\(예: nfs\_ftype4\)입니다.

NFS4ERR\_IO I/O 오류입니다. 요청한 작업을 처리하는 동안 하드 오류\(예: 디스크 오류\)가 발생했습니다.

NFS4ERR\_ISDIR은 디렉터리입니다. 발신자가 다음을 지정했습니다.

- 디렉터리가 아닌 작업의 디렉터리입니다.

NFS4ERR\_LEASE\_MOVED 갱신되는 임대는 새 서버로 마이그레이션된 파일 시스템과 연결됩니다.

NFS4ERR\_LOCKED 잠긴 파일에서 읽기 또는 쓰기 작업이 시도되었습니다.

NFS4ERR\_LOCK\_NOTSUPP 서버는 원자성 업그레이드 또는 잠금 다운그레이드를 지원하지 않습니다.

NFS4ERR\_LOCK\_RANGE 잠금 요청은 잠금 소유자에 대한 현재 잠금의 하위 범위에서 작동 중이며 서버는 이러한 유형의 요청을 지원하지 않습니다.

NFS4ERR\_LOCKS\_HELD CLOSE가 시도되었으며 CLOSE 이후에 파일 잠금이 존재합니다.

NFS4ERR\_MINOR\_VERS\_MISMATCH

- 서버가 지원되지 않는 부 버전을 지정하는 요청을 받았습니다. 서버는 길이가 0인 작업 결과 배열과 함께 COMPOUND4res를 반환해야 합니다.

```text
   NFS4ERR_MLINK         Too many hard links.
```

NFS4ERR\_MOVED 현재 파일 핸들 객체를 포함하는 파일 시스템이 다른 서버로 재배치되거나 마이그레이션되었습니다. 클라이언트는 현재 파일 핸들에 대한 "fs\_locations" 속성을 획득하여 새 파일 시스템 위치를 획득할 수 있습니다. 자세한 내용은 "파일 시스템 마이그레이션 또는 재배치" 섹션을 참조하세요.

NFS4ERR\_NAMETOOLONG 작업의 파일 이름이 너무 깁니다.

NFS4ERR\_NOENT 해당 파일이나 디렉터리가 없습니다. 파일 또는

- 지정된 디렉토리 이름이 존재하지 않습니다.

NFS4ERR\_NOFILEHANDLE 논리적인 현재 파일 핸들 값\(또는 RESTOREFH의 경우 저장된 파일 핸들 값\)이 제대로 설정되지 않았습니다. 이는 잘못된 COMPOUND 작업의 결과일 수 있습니다\(즉, 현재 파일 핸들을 설정해야 하는 작업 앞에 PUTFH 또는 PUTROOTFH가 설정되지 않음\).

NFS4ERR\_NO\_GRACE 클라이언트 상태 회수가 서버의 유예 기간을 벗어났습니다. 결과적으로 서버는 충돌하는 상태가 다른 클라이언트에 제공되지 않았음을 보장할 수 없습니다.

NFS4ERR\_NOSPC 장치에 남은 공간이 없습니다. 이 작업으로 인해 서버의 파일 시스템이 해당 제한을 초과했을 수 있습니다.

NFS4ERR\_NOTDIR 디렉토리가 아닙니다. 호출자가 디렉터리 작업에서 디렉터리가 아닌 항목을 지정했습니다.

NFS4ERR\_NOTEMPTY 비어 있지 않은 디렉토리를 제거하려고 시도했습니다.

NFS4ERR\_NOTSUPP 작업은 지원되지 않습니다.

NFS4ERR\_NOT\_SAME 이 오류는 비교된 속성이 클라이언트 요청에 제공된 것과 동일하지 않음을 나타내기 위해 VERIFY 작업에 의해 반환됩니다.

NFS4ERR\_NXIO I/O 오류입니다. 해당 장치나 주소가 없습니다.

NFS4ERR\_OLD\_STATEID 이전에 lockowner-file에 대한 잠금 상태를 지정하는 stateid가 사용되었습니다.

NFS4ERR\_OPENMODE 클라이언트가 전달된 stateid에 의해 승인되지 않은 READ, WRITE, LOCK 또는 SETATTR 작업을 시도했습니다\(예: 읽기 전용으로 열린 파일에 쓰기\).

NFS4ERR\_OP\_ILLEGAL COMPOUND 또는 CB\_COMPOUND 프로시저의 argop 필드에 잘못된 연산 값이 지정되었습니다.

NFS4ERR\_PERM 소유자가 아닙니다. 호출자가 권한 있는 사용자\(루트\)가 아니거나 작업 대상의 소유자가 아니기 때문에 작업이 허용되지 않았습니다.

NFS4ERR\_RECLAIM\_BAD 클라이언트가 제공한 회수가 서버의 상태 일관성 검사와 일치하지 않으며 잘못되었습니다.

NFS4ERR\_RECLAIM\_CONFLICT

- 고객이 제공한 회수권이 충돌하여 제공할 수 없습니다. 클라이언트가 잘못 동작하고 있음을 나타낼 수 있습니다.

NFS4ERR\_RESOURCE COMPOUND 프로시저를 처리하는 동안 서버는 사용 가능한 리소스를 모두 소모할 수 있으며 COMPOUND 프로시저 내에서 처리 작업을 계속할 수 없습니다. 이 오류는 COMPOUND 프로시저 처리와 관련된 리소스 소진 인스턴스의 서버에서 반환됩니다.

NFS4ERR\_RESTOREFH RESTOREFH 작업에 작업할 저장된 파일 핸들\(SAVEFH로 식별됨\)이 없습니다.

NFS4ERR\_ROFS 읽기 전용 파일 시스템. 읽기 전용 파일 시스템에서 수정 작업이 시도되었습니다.

NFS4ERR\_SAME 이 오류는 비교된 속성이 클라이언트 요청에 제공된 것과 동일했음을 나타내기 위해 NVERIFY 작업에 의해 반환됩니다.

NFS4ERR\_SERVERFAULT 적법한 NFS 버전 4 프로토콜 오류 값에 매핑되지 않는 오류가 서버에서 발생했습니다. 클라이언트는 이를 적절한 오류로 변환해야 합니다. UNIX 클라이언트는 이를 EIO로 변환하도록 선택할 수 있습니다.

NFS4ERR\_SHARE\_DENIED 공유가 있는 파일을 열려고 시도했습니다.

- 공유 충돌로 인해 예약이 실패했습니다.

NFS4ERR\_STALE 잘못된 파일 핸들입니다. 인수에 제공된 파일 핸들이 잘못되었습니다. 해당 파일 핸들이 참조하는 파일이 더 이상 존재하지 않거나 해당 파일에 대한 액세스가 취소되었습니다.

NFS4ERR\_STALE\_CLIENTID 서버가 인식하지 못하는 클라이언트 ID가 잠금 또는 SETCLIENTID\_CONFIRM 요청에 사용되었습니다.

NFS4ERR\_STALE\_STATEID 이전 서버 인스턴스에서 생성된 stateid가 사용되었습니다.

NFS4ERR\_SYMLINK LOOKUP에 제공되는 현재 파일 핸들은 디렉터리가 아니라 기호 링크입니다. OPEN 경로의 최종 구성요소가 심볼릭 링크인 경우에도 사용됩니다.

NFS4ERR\_TOOSMALL READDIR 요청에 대한 인코딩된 응답이 초기 요청에 설정된 크기 제한을 초과합니다.

NFS4ERR\_WRONGSEC 클라이언트가 작업에 사용하는 보안 메커니즘이 서버의 보안 정책과 일치하지 않습니다. 클라이언트는 사용 중인 보안 메커니즘을 변경하고 작업을 다시 시도해야 합니다.

NFS4ERR\_XDEV 서로 다른 fsid 간에 작업을 수행하려고 시도합니다.

---
## **13.  NFS version 4 Requests**

NFS 버전 4 RPC 프로그램의 경우 NULL과 COMPOUND라는 두 가지 기존 RPC 프로시저가 있습니다. 다른 모든 기능은 일련의 작업으로 정의되며 이러한 작업은 일반 XDR/RPC 구문 및 의미 체계로 정의됩니다. 그러나 이러한 작업은 COMPOUND 프로시저 내에 캡슐화됩니다. 이를 위해서는 클라이언트가 하나 이상의 NFS 버전 4 작업을 단일 요청으로 결합해야 합니다.

NFS4\_CALLBACK 프로그램은 서버-클라이언트 신호 전달에 사용되며 NFS 버전 4 프로그램과 유사한 방식으로 구성됩니다. CB\_NULL 및 CB\_COMPOUND 프로시저는 NFS 프로그램 내에 NULL 및 COMPOUND가 있는 것과 동일한 방식으로 정의됩니다. CB\_COMPOUND 요청은 NFS4\_CALLBACK 프로그램의 나머지 작업도 캡슐화합니다. NFS4\_CALLBACK 프로그램에는 미리 정의된 RPC 프로그램 번호가 없습니다. "일시적" 프로그램 범위에서 프로그램 번호를 지정하는 것은 클라이언트의 몫입니다. NFS4\_CALLBACK 프로그램의 프로그램 및 포트 번호는 클라이언트가 SETCLIENTID/SETCLIENTID\_CONFIRM 시퀀스의 일부로 제공합니다. 프로그램 및 포트는 다른 SETCLIENTID/SETCLIENTID\_CONFIRM 시퀀스에 의해 변경될 수 있으며, 해당 시퀀스를 사용하여 관련 임대 클라이언트 상태를 제거하지 않고도 클라이언트 구현 내에서 이를 변경할 수 있습니다.

---
### **13.1.  Compound Procedure**

COMPOUND 프로시저는 대기 시간이 긴 네트워크에서 더 나은 성능을 얻을 수 있는 기회를 제공합니다. 클라이언트는 여러 종속 작업을 단일 COMPOUND 프로시저로 결합하여 여러 RPC의 누적 대기 시간을 방지할 수 있습니다. 복합 작업은 클라이언트가 기본 절차를 클라이언트 환경에 맞게 사용자 정의된 단일 요청으로 결합할 수 있도록 하여 프로토콜 단순화를 제공할 수 있습니다.

CB\_COMPOUND 프로시저는 위에서 설명한 COMPOUND의 기능과 정확하게 유사합니다.

COMPOUND 프로시저의 기본 구조는 다음과 같습니다.

```text
   +-----+--------------+--------+-----------+-----------+-----------+--
   | tag | minorversion | numops | op + args | op + args | op + args |
   +-----+--------------+--------+-----------+-----------+-----------+--
```

응답의 구조는 다음과 같습니다.

```text
      +------------+-----+--------+-----------------------+--
      |last status | tag | numres | status + op + results |
      +------------+-----+--------+-----------------------+--
```

위 설명에 사용된 numops 및 numres 필드는 요청 및 응답에 인코딩된 인수 또는 결과의 수를 나타내는 데 사용되는 계산된 배열 인코딩의 수를 나타냅니다. XDR 인코딩에 따라 이러한 개수는 인코딩된 작업 인수 또는 결과의 수와 정확히 일치해야 합니다.

---
### **13.2.  Evaluation of a Compound Request**

서버는 COMPOUND 프로시저 내의 각 작업을 순서대로 평가하여 COMPOUND 프로시저를 처리합니다. 각 구성 요소 연산은 32비트 연산 코드와 연산 유형에 따라 결정되는 길이 인수로 구성됩니다. 각 작업의 결과는 응답 버퍼에 순차적으로 인코딩됩니다. 각 작업의 결과 앞에는 opcode와 상태 코드\(일반적으로 0\)가 옵니다. 작업으로 인해 0이 아닌 상태 코드가 발생하면 상태가 인코딩되고 복합 시퀀스의 평가가 중단되고 응답이 반환됩니다. NFS4ERR\_SAME과 같은 "오류가 아닌" 조건이 발생하는 경우에도 평가가 중지됩니다.

COMPOUND 프로시저 내에 포함된 작업에 대한 원자성 요구 사항은 없습니다. COMPOUND 요청의 일부로 평가되는 작업은 서버가 수신하는 다른 COMPOUND 요청과 동시에 평가될 수 있습니다.

부분적으로 완료된 COMPOUND 프로시저를 복구하는 것은 클라이언트의 책임입니다. 부분적으로 완료된 COMPOUND 프로시저는 NFS4ERR\_RESOURCE 및 NFS4ERR\_DELAY와 같은 오류로 인해 언제든지 발생할 수 있습니다. 이는 유효한 작업 문자열이 있는 경우에도 발생할 수 있습니다. 또한, COMPOUND 프로시저를 처리하는 중에 발생하는 서버 재부팅으로 인해 클라이언트는 COMPOUND 처리가 얼마나 진행되었는지 확인해야 하는 어려운 작업을 맡게 될 수 있습니다. 따라서 클라이언트는 프로시저 내에서 작업이 실패하는 경우 지나치게 복잡한 COMPOUND 프로시저를 피해야 합니다.

각 작업은 복합 요청의 실행 컨텍스트의 일부로 사용 가능한 "현재" 및 "저장된" 파일 핸들을 가정합니다. 작업은 현재 파일 핸들을 설정, 변경 또는 반환할 수 있습니다. "저장된" 파일 핸들은 파일 핸들 값의 임시 저장과 RENAME 및 LINK 작업의 피연산자로 사용됩니다.

---
### **13.3.  Synchronous Modifying Operations**

파일 시스템을 수정하는 NFS 버전 4 작업은 동기식입니다. 서버에서 작업이 성공적으로 완료되면 클라이언트는 요청과 관련된 모든 데이터가 이제 안정적인 저장소에 있는지 확인할 수 있습니다\(한 가지 예외는 UNSTABLE 옵션이 지정된 WRITE 작업의 파일 데이터인 경우입니다\).

이는 동일한 복합 요청 내의 모든 이전 작업도 안정적인 저장소에 반영됨을 의미합니다. 이 동작을 통해 클라이언트는 서버 오류로 인해 부분적으로 실행된 복합 요청을 복구할 수 있습니다. 예를 들어 복합 요청에 작업 A와 B가 포함되어 있고 서버가 클라이언트에 응답을 보낼 수 없는 경우 서버가 요청을 처리하는 과정에 따라 두 작업의 결과가 안정적인 저장소에 반영되거나 단순한 작업에 반영될 수 있습니다. A가 반영될 수 있습니다. 서버는 B 작업의 결과만을 안정적인 저장소에 저장해서는 안 됩니다.

---
### **13.4.  Operation Values**

COMPOUND 프로시저에 인코딩된 작업은 작업 값으로 식별됩니다. RPC 프로시저 번호와의 중복을 피하기 위해 작업 0\(영\)과 1은 정의되지 않습니다. 작업 2는 정의되지 않았지만 나중에 부 버전 관리에 사용하도록 예약되어 있습니다.

---
## **14.  NFS version 4 Procedures**
---
### **14.1.  Procedure 0: NULL - No Operation**

```text
   SYNOPSIS

      <null>

   ARGUMENT

      void;

   RESULT

      void;

   DESCRIPTION
```

- 표준 NULL 프로시저. 무효 논쟁, 무효 응답. 이 절차에는 관련된 기능이 없습니다. 이 때문에 때때로 서비스 요청 처리 오버헤드를 측정하는 데 사용됩니다. 따라서 서버는 이 절차를 서비스하는 데 불필요한 작업이 수행되지 않도록 해야 합니다.

```text
   ERRORS

      None.
```

---
### **14.2.  Procedure 1: COMPOUND - Compound Operations**

```text
   SYNOPSIS

     compoundargs -> compoundres

   ARGUMENT

     union nfs_argop4 switch (nfs_opnum4 argop) {
             case <OPCODE>: <argument>;
             ...
     };

     struct COMPOUND4args {
             utf8str_cs      tag;
             uint32_t        minorversion;
             nfs_argop4      argarray<>;
     };

   RESULT

     union nfs_resop4 switch (nfs_opnum4 resop){
             case <OPCODE>: <result>;
             ...
     };

     struct COMPOUND4res {
             nfsstat4        status;
             utf8str_cs      tag;
             nfs_resop4      resarray<>;
     };

   DESCRIPTION
```

COMPOUND 프로시저는 하나 이상의 NFS 작업을 단일 RPC 요청으로 결합하는 데 사용됩니다. 기본 NFS RPC 프로그램에는 NULL과 COMPOUND라는 두 가지 주요 프로시저가 있습니다. 다른 모든 작업에서는 COMPOUND 프로시저를 래퍼로 사용합니다.

COMPOUND 프로시저는 개별 작업을 단일 RPC 요청으로 결합하는 데 사용됩니다. 서버는 각 작업을 차례로 해석합니다. 서버에서 작업이 실행되고 해당 작업의 상태가 NFS4\_OK인 경우 COMPOUND 프로시저의 다음 작업이 실행됩니다. 서버는 더 이상 실행할 작업이 없거나 작업 중 하나가 NFS4\_OK 이외의 상태 값을 가질 때까지 이 프로세스를 계속합니다.

COMPOUND 프로시저를 처리하는 동안 서버는 COMPOUND 시퀀스 내의 작업 중 일부 또는 전부를 실행하는 데 사용할 수 있는 리소스가 없다는 것을 알 수 있습니다. 이 경우 리소스 소진이 발생한 COMPOUND 프로시저 내의 특정 작업에 대해 NFS4ERR\_RESOURCE 오류가 반환됩니다. 이는 COMPOUND 시퀀스 내의 모든 이전 작업이 성공적으로 평가되었다고 가정합니다. 평가된 모든 작업의 ​​결과는 클라이언트에 반환되어야 합니다.

서버는 일반적으로 클라이언트 요청을 디코딩하는 두 가지 방법 중에서 선택합니다. 첫 번째는 전체 COMPOUND의 디코딩이 그 안의 모든 작업 실행보다 앞서는 전통적인 원패스 XDR 디코드입니다. 이 경우 XDR 디코딩 오류가 있으면 RPC XDR 디코딩 오류가 반환됩니다. 두 번째 방법은 기본 COMPOUND 요청을 디코딩하기 위한 초기 패스를 만든 다음 서버가 실행할 준비가 되면 각 개별 작업을 XDR 디코딩하는 것입니다. 이 경우, COMPOUND 내의 이전 작업이 실행된 후 서버는 이러한 작업 디코딩 중에 XDR 디코딩 오류가 발생할 수 있습니다. 이 경우 서버는 NFS4ERR\_BADXDR 오류를 반환하여 디코딩 오류를 나타냅니다.

COMPOUND 인수에는 "minorversion" 필드가 포함되어 있습니다. 이 필드의 초기 값과 기본값은 0입니다. 이 필드는 클라이언트가 어떤 부 버전이 요청되는지 서버와 통신할 수 있도록 향후 부 버전에서 사용됩니다. 서버가 지원하지 않는 Minorversion 필드 값이 있는 COMPOUND 프로시저를 수신하는 경우 서버는 NFS4ERR\_MINOR\_VERS\_MISMATCH 오류와 길이가 0인 resultdata 배열을 반환해야 합니다.\(MUST\)

COMPOUND 결과에는 "상태" 필드가 포함되어 있습니다. 결과 배열 길이가 0이 아닌 경우 이 상태는 해당 배열 내에서 실행된 마지막 작업의 상태와 동일해야 합니다.

복합 절차. 따라서 작업에서 오류가 발생한 경우 "상태" 값은 실패한 작업에 대해 반환되는 오류 값과 동일합니다.

COMPOUND 프로시저에는 연산 0\(영\)과 1\(일\)이 정의되어 있지 않습니다. 작업 2는 정의되지 않았지만 향후 정의 및 부 버전 관리와 함께 사용하기 위해 예약되어 있습니다. 서버가 작업 2가 포함된 작업 배열을 수신하고 majorversion 필드의 값이 0\(영\)인 경우 다음 단락에 설명된 대로 NFS4ERR\_OP\_ILLEGAL 오류가 클라이언트에 반환됩니다. 작업 배열에 작업 2가 포함되어 있고 Minorversion 필드가 0이 아니고 서버가 마이너 버전을 지원하지 않는 경우 서버는 NFS4ERR\_MINOR\_VERS\_MISMATCH 오류를 반환합니다. 따라서 NFS4ERR\_MINOR\_VERS\_MISMATCH 오류는 다른 모든 오류보다 우선합니다.

서버는 첫 번째 적법한 작업\(OP\_ACCESS\)보다 작거나 마지막 적법한 작업\(OP\_RELEASE\_LOCKOWNER\)보다 큰 작업이 포함된 요청을 받을 수 있습니다.

이 경우 서버의 응답은 요청의 잘못된 opcode가 아닌 opcode OP\_ILLEGAL을 인코딩합니다. ILLEGAL 반환 결과의 상태 필드는 NFS4ERR\_OP\_ILLEGAL로 설정됩니다. COMPOUND 프로시저의 반환 결과도 NFS4ERR\_OP\_ILLEGAL입니다.

요청의 "태그" 정의는 구현자에게 달려 있습니다. 이는 패킷 스니퍼 및 엔지니어 디버깅 구현의 이점을 위해 복합 요청의 내용을 요약하는 데 사용될 수 있습니다. 그러나 응답의 "태그" 값은 요청에 제공된 값과 동일해야 합니다. 이는 CB\_COMPOUND 프로시저의 태그 필드에도 적용됩니다.\(SHOULD\)

```text
   IMPLEMENTATION
```

작업의 일부만 평가된 후에 모든 유형의 오류가 발생할 수 있으므로 클라이언트는 오류로부터 복구할 준비를 해야 합니다. NFS4ERR\_RESOURCE 오류의 원인이 복잡하거나 긴 작업 세트인 경우 작업 수가 줄어들면 서버가 해당 작업을 성공적으로 평가할 수 있을 가능성이 높습니다. 따라서 클라이언트는 복구 시 이러한 유형의 복잡성을 처리할 책임이 있습니다.

```text
   ERRORS
```

프로토콜에 정의된 모든 오류

---
#### **14.2.1.  Operation 3: ACCESS - Check Access Rights**

```text
   SYNOPSIS

     (cfh), accessreq -> supported, accessrights

   ARGUMENT

     const ACCESS4_READ      = 0x00000001;
     const ACCESS4_LOOKUP    = 0x00000002;
     const ACCESS4_MODIFY    = 0x00000004;
     const ACCESS4_EXTEND    = 0x00000008;
     const ACCESS4_DELETE    = 0x00000010;
     const ACCESS4_EXECUTE   = 0x00000020;

     struct ACCESS4args {
             /* CURRENT_FH: object */
             uint32_t        access;
     };

   RESULT

     struct ACCESS4resok {
             uint32_t        supported;
             uint32_t        access;
     };

     union ACCESS4res switch (nfsstat4 status) {
      case NFS4_OK:
              ACCESS4resok   resok4;
      default:
              void;
     };

   DESCRIPTION
```

ACCESS는 RPC 요청의 자격 증명으로 식별된 사용자가 현재 파일 핸들에 지정된 파일 시스템 개체에 대해 갖는 액세스 권한을 결정합니다. 클라이언트는 비트 마스크 "액세스"에서 확인할 액세스 권한 집합을 인코딩합니다. 서버는 비트 마스크에 인코딩된 권한을 확인합니다. NFS4\_OK 상태가 반환되면 두 개의 비트 마스크가 응답에 포함됩니다. 첫 번째 "지원됨"은 서버가 안정적으로 확인할 수 있는 액세스 권한을 나타냅니다. 두 번째 "액세스"는 제공된 파일 핸들에 대해 사용자가 사용할 수 있는 액세스 권한을 나타냅니다. 성공하면 현재 파일 핸들이 해당 값을 유지합니다.

지원되는 필드에는 원래 인수로 전송된 값만큼만 포함됩니다. 예를 들어 클라이언트가 ACCESS4\_READ 값만 설정된 ACCESS 작업을 보내고 서버가 이 값을 지원하는 경우 서버는 다른 값을 안정적으로 확인할 수 있었더라도 ACCESS4\_READ만 반환합니다.

이 작업의 결과는 본질적으로 권고 사항입니다. NFS4\_OK의 반환 상태와 비트 마스크에 설정된 적절한 비트는 향후 파일 시스템 개체에 대한 액세스가 허용된다는 의미는 아닙니다. 접근 권한은 언제든지 서버에 의해 철회될 수 있기 때문입니다.

다음과 같은 접근 권한을 요청할 수 있습니다.

ACCESS4\_READ 파일에서 데이터를 읽거나 디렉터리를 읽습니다.

ACCESS4\_LOOKUP 디렉토리에서 이름을 찾습니다\(디렉토리가 아닌 객체에는 의미 없음\).

ACCESS4\_MODIFY 기존 파일 데이터를 다시 쓰거나 기존 디렉터리 항목을 수정합니다.

ACCESS4\_EXTEND 새 데이터를 쓰거나 디렉터리 항목을 추가합니다.

ACCESS4\_DELETE 기존 디렉토리 항목을 삭제합니다.

ACCESS4\_EXECUTE 파일을 실행합니다\(디렉토리에는 의미 없음\).

성공하면 현재 파일 핸들이 해당 값을 유지합니다.

```text
   IMPLEMENTATION
```

일반적으로 클라이언트가 파일 속성의 uid, gid 및 mode 필드를 검사하거나 ACL 속성의 내용을 해석하여 액세스 권한을 추론하는 것만으로는 충분하지 않습니다. 이는 서버가 uid 또는 gid 매핑을 수행하거나 추가 액세스 제어 제한을 시행할 수 있기 때문입니다. 서버가 클라이언트와 동일한 ID 공간에 있지 않을 수도 있습니다. 이러한 경우\(및 기타 경우\) 클라이언트는 현재 파일 속성만으로는 액세스 확인을 안정적으로 수행할 수 없습니다.

NFS 버전 2 프로토콜에서 작업 허용 여부를 확인하는 신뢰할 수 있는 유일한 방법은 작업을 시도하여 성공했는지 실패했는지 확인하는 것이었습니다. NFS 버전 4 프로토콜의 ACCESS 작업을 사용하여 클라이언트는 하나 이상의 작업 클래스가 허용되는지 여부를 나타내도록 서버에 요청할 수 있습니다. ACCESS 작업은 클라이언트가 액세스 실패를 초래하는 일련의 작업을 수행하기 전에 확인할 수 있도록 제공됩니다. 오픈

작업은 서버가 파일 개체에 대한 액세스를 확인할 수 있는 지점과 해당 정보를 클라이언트에 반환하는 방법을 제공합니다. ACCESS 작업은 디렉터리 작업이나 클라이언트에서 UNIX API "액세스"가 사용되는 경우에 여전히 유용합니다.

ACCESS 호출에 대한 응답으로 서버가 반환한 정보는 영구적이지 않습니다. 서버가 검사를 수행한 정확한 시간에는 정확했지만 이후에는 반드시 그런 것은 아닙니다. 서버는 언제든지 접근권한을 철회할 수 있습니다.

클라이언트는 액세스 권한을 결정하는 데 사용되는 ACCESS 요청에 인증 정보를 구축하기 위해 사용자의 유효한 자격 증명을 사용해야 합니다. 후속 읽기 및 쓰기 작업에 사용되는 유효 사용자 및 그룹 자격 증명입니다.

많은 구현에서는 ACCESS4\_DELETE 권한을 직접 지원하지 않습니다. UNIX와 같은 운영 체제는 디렉터리가 아닌 개체에 대한 액세스 요청에 설정된 경우 ACCESS4\_DELETE 비트를 무시합니다. 이러한 시스템에서 파일에 대한 삭제 권한은 파일 자체의 권한에 의해 결정되는 대신 파일이 있는 디렉터리에 대한 액세스 권한에 따라 결정됩니다. 따라서 확인할 수 있는 액세스 권한을 열거하는 반환된 마스크의 ACCESS4\_DELETE 값은 0으로 설정됩니다. 이는 서버가 해당 특정 액세스 권한을 확인할 수 없음을 클라이언트에 나타냅니다. 반환된 액세스 마스크의 ACCESS4\_DELETE 비트는 클라이언트에서 무시됩니다.

```text
   ERRORS

      NFS4ERR_ACCESS
      NFS4ERR_BADHANDLE
      NFS4ERR_BADXDR
      NFS4ERR_DELAY
      NFS4ERR_FHEXPIRED
      NFS4ERR_INVAL
      NFS4ERR_IO
      NFS4ERR_MOVED
      NFS4ERR_NOFILEHANDLE
      NFS4ERR_RESOURCE
      NFS4ERR_SERVERFAULT
      NFS4ERR_STALE
```

---
#### **14.2.2.  Operation 4: CLOSE - Close File**

```text
   SYNOPSIS

     (cfh), seqid, open_stateid -> open_stateid

   ARGUMENT

     struct CLOSE4args {
             /* CURRENT_FH: object */
             seqid4          seqid
             stateid4        open_stateid;
     };

   RESULT

     union CLOSE4res switch (nfsstat4 status) {
      case NFS4_OK:
              stateid4       open_stateid;
      default:
              void;
     };

   DESCRIPTION
```

CLOSE 작업은 현재 파일 핸들에 지정된 대로 일반 또는 명명된 속성 파일에 대한 공유 예약을 해제합니다. 이 CLOSE의 결과로 서버에 공개된 공유 예약 및 기타 상태 정보는 제공된 stateid와만 연관됩니다. 시퀀스 ID는 올바른 순서를 제공합니다. 다른 OPEN과 연관된 상태는 영향을 받지 않습니다.

레코드 잠금이 유지되면 클라이언트는 CLOSE를 발행하기 전에 모든 잠금을 해제해야 합니다. 서버는 CLOSE 시 모든 미해결 잠금을 해제할 수 있지만 일부 서버는 여전히 레코드 잠금이 유지된 파일의 CLOSE를 지원하지 않을 수 있습니다. CLOSE 이후 잠금이 존재하는 경우 서버는 실패를 반환해야 합니다.\(SHOULD, MAY, MUST\)

성공하면 현재 파일 핸들이 해당 값을 유지합니다.

```text
   IMPLEMENTATION
```

CLOSE가 stateid를 반환하더라도 이 stateid는 클라이언트에 유용하지 않으며 더 이상 사용되지 않는 것으로 처리되어야 합니다. CLOSE는 단일 open\_owner에 의한 파일의 모든 OPEN과 연관된 상태를 "종료"합니다. 위에서 언급한 대로 CLOSE는 모든 파일 잠금 상태를 해제하거나 오류를 반환합니다. 따라서 CLOSE에서 반환된 stateid는 후속 작업에 유용하지 않습니다.

```text
   ERRORS

      NFS4ERR_ADMIN_REVOKED
      NFS4ERR_BADHANDLE
      NFS4ERR_BAD_SEQID

      NFS4ERR_BAD_STATEID
      NFS4ERR_BADXDR
      NFS4ERR_DELAY
      NFS4ERR_EXPIRED
      NFS4ERR_FHEXPIRED
      NFS4ERR_INVAL
      NFS4ERR_ISDIR
      NFS4ERR_LEASE_MOVED
      NFS4ERR_LOCKS_HELD
      NFS4ERR_MOVED
      NFS4ERR_NOFILEHANDLE
      NFS4ERR_OLD_STATEID
      NFS4ERR_RESOURCE
      NFS4ERR_SERVERFAULT
      NFS4ERR_STALE
      NFS4ERR_STALE_STATEID
```

---
#### **14.2.3.  Operation 5: COMMIT - Commit Cached Data**

```text
   SYNOPSIS

     (cfh), offset, count -> verifier

   ARGUMENT

     struct COMMIT4args {
             /* CURRENT_FH: file */
             offset4         offset;
             count4          count;
     };

   RESULT

     struct COMMIT4resok {
             verifier4       writeverf;
     };

     union COMMIT4res switch (nfsstat4 status) {
      case NFS4_OK:
              COMMIT4resok   resok4;
      default:
              void;
     };

   DESCRIPTION
```

COMMIT 작업은 현재 파일 핸들에 지정된 파일에 대한 안정적인 저장소로 데이터를 강제로 삭제하거나 플러시합니다. 플러시된 데이터는 이전에 UNSTABLE4로 설정된 stable 필드가 있는 WRITE 작업으로 작성된 데이터입니다.

오프셋은 플러시가 시작될 파일 내의 위치를 ​​지정합니다. 오프셋 값 0\(영\)은 파일 시작 부분부터 데이터를 플러시한다는 의미입니다. 개수는 플러시할 데이터의 바이트 수를 지정합니다. 개수가 0\(영\)이면 오프셋에서 파일 끝까지 플러시가 수행됩니다.

서버는 COMMIT가 성공적으로 완료되면 쓰기 검증자를 반환합니다. 쓰기 검증자는 클라이언트가 초기 WRITE와 COMMIT 사이에 서버가 다시 시작되었는지 또는 재부팅되었는지 확인하는 데 사용됩니다. 클라이언트는 초기 쓰기에서 반환된 쓰기 검증자와 COMMIT 작업에서 반환된 검증자를 비교하여 이를 수행합니다. 서버는 커밋되지 않은 데이터의 손실을 초래할 수 있는 각 서버 이벤트 또는 인스턴스화에서 쓰기 검증자의 값을 변경해야 합니다. 가장 일반적으로 이는 서버를 재부팅할 때 발생합니다. 그러나 서버의 다른 이벤트로 인해 커밋되지 않은 데이터가 손실될 수도 있습니다.

성공하면 현재 파일 핸들이 해당 값을 유지합니다.

```text
   IMPLEMENTATION
```

COMMIT 작업은 파일 상태를 디스크와 동기화하는 POSIX fsync\(2\) 시스템 호출과 작업 및 의미가 유사합니다\(파일 데이터 및 메타데이터가 디스크 또는 안정적인 저장소에 플러시됩니다\). COMMIT는 클라이언트에 대해 동일한 작업을 수행하여 서버의 동기화되지 않은 데이터와 메타데이터를 서버의 디스크나 지정된 파일에 대한 안정적인 저장소로 플러시합니다. fsync\(2\)와 마찬가지로 일부 수정된 데이터가 있거나 동기화할 수정된 데이터가 없을 수 있습니다. 데이터는 서버의 일반적인 주기적인 버퍼 동기화 활동에 의해 동기화되었을 수 있습니다. COMMIT는 예상치 못한 오류가 발생하지 않는 한 NFS4\_OK를 반환해야 합니다.

COMMIT는 클라이언트가 파일 범위를 비울 수 있다는 점에서 fsync\(2\)와 다릅니다\(대개 파일이 완전히 기록되기 전에 클라이언트의 버퍼 재확보 방식에 의해 트리거될 가능성이 높습니다\).

COMMIT의 서버 구현은 비교적 간단합니다. 서버가 오프셋 0과 개수 0에서 시작하는 전체 파일 COMMIT 요청을 받으면 파일을 fsync\(\)하는 것과 동등한 작업을 수행해야 합니다. 그렇지 않으면 캐시된 데이터를

안정적인 저장소로 플러시될 오프셋 및 개수로 지정된 범위입니다. 두 경우 모두 파일과 관련된 모든 메타데이터를 반환하기 전에 안정적인 저장소로 플러시해야 합니다. 서버에 플러시할 항목이 없는 것은 오류가 아닙니다. 이는 플러시해야 하는 데이터와 메타데이터가 마지막 서버 오류 중에 이미 플러시되었거나 손실되었음을 의미합니다.

COMMIT의 클라이언트 구현은 좀 더 복잡합니다. 클라이언트 버퍼를 안정적인 저장소에 커밋하려는 데는 두 가지 이유가 있습니다. 첫 번째는 클라이언트가 버퍼를 재사용하기를 원한다는 것입니다. 이 경우 COMMIT 요청을 통해 버퍼의 오프셋과 개수가 서버로 전송됩니다. 그런 다음 서버는 오프셋 및 개수를 기반으로 캐시된 데이터를 플러시하고 파일과 관련된 모든 메타데이터를 플러시합니다. 그런 다음 플러시 및 쓰기 확인자의 상태를 반환합니다. 클라이언트가 COMMIT를 생성하는 또 다른 이유는 닫을 때 수행될 수 있는 전체 파일 플러시를 위한 것입니다. 이 경우 클라이언트는 커밋되지 않은 데이터가 포함된 이 파일에 대한 모든 버퍼를 수집하고 오프셋 0과 개수 0으로 COMMIT 작업을 수행한 다음 해당 버퍼를 모두 해제합니다. 다른 더티 버퍼는 일반적인 방식으로 서버로 전송됩니다.

UNSTABLE4로 설정된 안정적인 매개변수를 사용하여 클라이언트에서 버퍼를 작성한 후 버퍼가 COMMIT 작업을 통해 플러시되거나 안정적인 매개변수가 FILE\_SYNC4로 설정된 WRITE 작업을 통해 기록될 때까지 버퍼는 클라이언트에 의해 수정된 것으로 간주되어야 합니다. DATA\_SYNC4. 이는 데이터가 서버의 안정적인 저장소로 플러시되기 전에 버퍼가 해제되어 재사용되는 것을 방지하기 위해 수행됩니다.

WRITE 또는 COMMIT 작업에서 응답이 반환되고 서버에서 이전에 반환한 것과 다른 쓰기 검증자가 포함된 경우 클라이언트는 커밋되지 않은 캐시된 데이터가 포함된 모든 버퍼를 서버에 다시 전송해야 합니다. 이를 수행하는 방법은 구현자에게 달려 있습니다. 관심 있는 버퍼가 하나만 있는 경우 적절한 안정적인 매개변수를 사용하여 WRITE 요청으로 다시 전송해야 할 것입니다. 버퍼가 두 개 이상인 경우 stable 매개변수를 UNSTABLE4로 설정하여 WRITE 요청의 모든 버퍼를 재전송한 다음 COMMIT 작업을 재전송하여 서버의 모든 데이터를 안정적인 저장소로 플러시하는 것이 좋습니다. 이러한 재전송 시기는 구현자에게 달려 있습니다.

위의 설명은 버퍼 캐시 기반 시스템뿐만 아니라 페이지 캐시 기반 시스템에도 적용됩니다. 이러한 시스템에서는 버퍼 캐시 대신 가상 메모리 시스템을 수정해야 합니다.

```text
   ERRORS

      NFS4ERR_ACCESS
      NFS4ERR_BADHANDLE
      NFS4ERR_BADXDR
      NFS4ERR_FHEXPIRED
      NFS4ERR_INVAL
      NFS4ERR_IO
      NFS4ERR_ISDIR
      NFS4ERR_MOVED
      NFS4ERR_NOFILEHANDLE
      NFS4ERR_RESOURCE
      NFS4ERR_ROFS
      NFS4ERR_SERVERFAULT
      NFS4ERR_STALE
```

---
#### **14.2.4.  Operation 6: CREATE - Create a Non-Regular File Object**

```text
   SYNOPSIS

     (cfh), name, type, attrs -> (cfh), change_info, attrs_set

   ARGUMENT

     union createtype4 switch (nfs_ftype4 type) {
      case NF4LNK:
              linktext4      linkdata;
      case NF4BLK:
      case NF4CHR:
              specdata4      devdata;
      case NF4SOCK:
      case NF4FIFO:
      case NF4DIR:
              void;
     };

     struct CREATE4args {
             /* CURRENT_FH: directory for creation */
             createtype4     objtype;
             component4      objname;
             fattr4          createattrs;
     };

   RESULT

     struct CREATE4resok {
             change_info4    cinfo;
             bitmap4         attrset;        /* attributes set */

     };

     union CREATE4res switch (nfsstat4 status) {
      case NFS4_OK:
              CREATE4resok resok4;
      default:
              void;
     };

   DESCRIPTION
```

CREATE 작업은 지정된 이름을 가진 디렉터리에 비정규 파일 객체를 생성합니다. 일반 파일을 생성하려면 OPEN 작업을 사용해야 합니다.\(MUST\)

objname은 새 개체의 이름을 지정합니다. objtype은 생성될 객체의 유형\(디렉토리, 심볼릭 링크 등\)을 결정합니다.

동일한 이름의 개체가 디렉터리에 이미 존재하는 경우 서버는 NFS4ERR\_EXIST 오류를 반환합니다.

새 파일 객체가 생성된 디렉터리에 대해 서버는 cinfo에change\_info4 정보를 반환합니다. Change\_info4 구조체의 원자 필드를 사용하면 서버는 파일 객체 생성과 관련하여 변경 전후 속성이 원자적으로 획득되었는지 여부를 나타냅니다.

objname의 길이가 0\(영\)이거나 objname이 UTF-8 정의를 따르지 않는 경우 NFS4ERR\_INVAL 오류가 반환됩니다.

현재 파일 핸들이 새 객체의 파일 핸들로 대체됩니다.

createattrs는 객체의 초기 속성 세트를 지정합니다. 속성 세트에는 객체 유형에 유효한 쓰기 가능한 속성이 포함될 수 있습니다. 작업이 성공하면 서버는 객체에 대해 어떤 속성이 성공적으로 설정되었는지 나타내는 속성 마스크를 클라이언트에 반환합니다.

createattrs에 소유자 속성이나 소유자에 대한 ACE가 있는 ACL이 포함되어 있지 않고 서버의 파일 시스템이 소유자 속성\(또는 소유자 ACE\)을 지원하고 요구하는 경우 서버는 소유자\(또는 소유자 ACE\)를 파생해야 합니다. 이는 일반적으로 호출의 RPC 자격 증명에 표시된 주체에서 나오지만 서버의 운영 환경이나 파일 시스템 의미에 따라 다른 파생 방법이 필요할 수 있습니다. 마찬가지로 createattrs에 그룹 속성이나 그룹 ACE가 모두 포함되지 않고 서버의 파일 시스템이 그룹 속성\(또는 그룹 ACE\) 개념을 지원하고 요구하는 경우 서버는 그룹 속성을 파생해야 합니다.\(MUST, MUST\)

\(또는 해당 소유자 ACE\)입니다. 이는 RPC 호출의 자격 증명\(예: 자격 증명에 AUTH\_SYS 등\)이 포함된 경우 그룹 주체, 자격 증명의 주체와 연결된 그룹 식별자\(예: POSIX 시스템에는 다음과 같은 암호 데이터베이스가 있음\)에서 나올 수 있습니다. 모든 사용자 식별자에 대한 그룹 식별자\), 개체가 생성된 디렉터리에서 상속되거나 서버의 운영 환경이나 파일 시스템 의미가 지시하는 모든 것에서 상속됩니다. 이는 OPEN 작업에도 적용됩니다.

반대로 클라이언트가 RPC 호출의 자격 증명에 파일 생성 권한이 없음을 나타내는 주체가 소유자 속성, 그룹 속성 또는 ACL을 createattrs에 지정할 수도 있습니다. 이 인스턴스에서 반환되는 오류는 NFS4ERR\_PERM입니다. 이는 OPEN 작업에도 적용됩니다.

```text
   IMPLEMENTATION
```

클라이언트가 생성 후에 속성 값을 설정하려는 경우 적절한 속성이 설정되도록 SETATTR 작업을 COMPOUND 요청에 추가할 수 있습니다.

```text
   ERRORS

      NFS4ERR_ACCESS
      NFS4ERR_ATTRNOTSUPP
      NFS4ERR_BADCHAR
      NFS4ERR_BADHANDLE
      NFS4ERR_BADNAME
      NFS4ERR_BADOWNER
      NFS4ERR_BADTYPE
      NFS4ERR_BADXDR
      NFS4ERR_DELAY
      NFS4ERR_DQUOT
      NFS4ERR_EXIST
      NFS4ERR_FHEXPIRED
      NFS4ERR_INVAL
      NFS4ERR_IO
      NFS4ERR_MOVED
      NFS4ERR_NAMETOOLONG
      NFS4ERR_NOFILEHANDLE
      NFS4ERR_NOSPC
      NFS4ERR_NOTDIR
      NFS4ERR_PERM
      NFS4ERR_RESOURCE
      NFS4ERR_ROFS
      NFS4ERR_SERVERFAULT
      NFS4ERR_STALE
```

---
#### **14.2.5.  Operation 7: DELEGPURGE - Purge Delegations Awaiting Recovery**

```text
   SYNOPSIS

     clientid ->

   ARGUMENT

     struct DELEGPURGE4args {
             clientid4       clientid;
     };

   RESULT

     struct DELEGPURGE4res {
             nfsstat4        status;
     };

   DESCRIPTION
```

특정 클라이언트에 대한 복구를 기다리는 모든 위임을 제거합니다. 이는 위임 정보 복구를 기다리는 서버에서 충돌하는 요청을 지연시킬 필요가 없음을 나타내기 위해 위임 정보를 안정적인 저장소에 커밋하지 않는 클라이언트에 유용합니다.

이 작업은 클라이언트의 안정적인 저장소에 위임 정보를 기록하는 클라이언트에서 사용해야 합니다. 이 경우 클라이언트에 알려진 모든 위임에 대해 위임 복구를 수행한 후 즉시 DELEGPURGE를 실행해야 합니다. 이렇게 하면 클라이언트에 대한 추가 위임이 복구되지 않음을 서버에 알리므로 리소스를 확보할 수 있으며, 복구되지 않은 위임과 충돌하는 요청을 하는 다른 클라이언트의 지연을 방지할 수 있습니다. 서버와 클라이언트에 알려진 위임 세트는 다를 수 있습니다. 그 이유는 클라이언트가 위임을 초래하는 요청을 한 후 결과를 수신하여 클라이언트의 안정적인 저장소에 커밋하기 전에 실패할 수 있기 때문입니다.

서버는 DELEGPURGE를 지원할 수 있지만 그렇지 않은 경우 CLAIM\_DELEGATE\_PREV를 지원해서는 안 됩니다.\(MUST NOT\)

```text
   ERRORS

      NFS4ERR_BADXDR
      NFS4ERR_NOTSUPP
      NFS4ERR_LEASE_MOVED
      NFS4ERR_MOVED
      NFS4ERR_RESOURCE

      NFS4ERR_SERVERFAULT
      NFS4ERR_STALE_CLIENTID
```

---
#### **14.2.6.  Operation 8: DELEGRETURN - Return Delegation**

```text
   SYNOPSIS

     (cfh), stateid ->

   ARGUMENT

     struct DELEGRETURN4args {
             /* CURRENT_FH: delegated file */
             stateid4        stateid;
     };

   RESULT

     struct DELEGRETURN4res {
             nfsstat4        status;
     };

   DESCRIPTION
```

현재 파일 핸들과 stateid가 나타내는 위임을 반환합니다.

위임은 회수되거나 자발적으로\(즉, 서버가 위임을 회수하기 전\) 반환될 수 있습니다. 두 경우 모두 클라이언트는 위임을 반환하기 전에 위임 컨텍스트에 따라 변경된 상태를 서버에 올바르게 전파해야 합니다.

```text
   ERRORS

      NFS4ERR_ADMIN_REVOKED
      NFS4ERR_BAD_STATEID
      NFS4ERR_BADXDR
      NFS4ERR_EXPIRED
      NFS4ERR_INVAL
      NFS4ERR_LEASE_MOVED
      NFS4ERR_MOVED
      NFS4ERR_NOFILEHANDLE
      NFS4ERR_NOTSUPP
      NFS4ERR_OLD_STATEID
      NFS4ERR_RESOURCE
      NFS4ERR_SERVERFAULT
      NFS4ERR_STALE
      NFS4ERR_STALE_STATEID
```

---
#### **14.2.7.  Operation 9: GETATTR - Get Attributes**

```text
   SYNOPSIS

     (cfh), attrbits -> attrbits, attrvals

   ARGUMENT

     struct GETATTR4args {
             /* CURRENT_FH: directory or file */
             bitmap4         attr_request;
     };

   RESULT

     struct GETATTR4resok {
             fattr4          obj_attributes;
     };

     union GETATTR4res switch (nfsstat4 status) {
      case NFS4_OK:
              GETATTR4resok  resok4;
      default:
              void;
     };

   DESCRIPTION
```

GETATTR 작업은 현재 파일 핸들에 지정된 파일 시스템 개체에 대한 속성을 가져옵니다. 클라이언트는 서버가 반환할 각 속성 값에 대해 비트맵 인수에 비트를 설정합니다. 서버는 반환할 수 있었던 속성 값을 나타내는 속성 비트맵을 반환하고 그 뒤에 가장 낮은 속성 번호부터 정렬된 속성 값을 반환합니다.

서버는 속성이 서버에서 지원되는 경우 클라이언트가 요청하는 각 속성에 대한 값을 반환해야 합니다. 서버가 속성을 지원하지 않거나 유용한 값을 근사화할 수 없는 경우 속성 값을 반환해서는 안 되며 결과 비트맵에 속성 비트를 설정해서는 안 됩니다. 서버는 속성을 지원하지만 해당 값을 얻을 수 없는 경우 오류를 반환해야 합니다. 이 경우 속성 값이 반환되지 않습니다.

모든 서버는 "파일 속성" 섹션에 지정된 필수 속성을 지원해야 합니다.

성공하면 현재 파일 핸들이 해당 값을 유지합니다.

```text
   IMPLEMENTATION

   ERRORS

      NFS4ERR_ACCESS
      NFS4ERR_BADHANDLE
      NFS4ERR_BADXDR
      NFS4ERR_DELAY
      NFS4ERR_FHEXPIRED
      NFS4ERR_INVAL
      NFS4ERR_IO
      NFS4ERR_MOVED
      NFS4ERR_NOFILEHANDLE
      NFS4ERR_RESOURCE
      NFS4ERR_SERVERFAULT
      NFS4ERR_STALE
```

---
#### **14.2.8.  Operation 10: GETFH - Get Current Filehandle**

```text
   SYNOPSIS

     (cfh) -> filehandle

   ARGUMENT

     /* CURRENT_FH: */
     void;

   RESULT

     struct GETFH4resok {
             nfs_fh4         object;
     };

     union GETFH4res switch (nfsstat4 status) {
      case NFS4_OK:
             GETFH4resok     resok4;
      default:
             void;
     };

   DESCRIPTION
```

이 작업은 현재 파일 핸들 값을 반환합니다.

성공하면 현재 파일 핸들이 해당 값을 유지합니다.

```text
   IMPLEMENTATION
```

LOOKUP 또는 CREATE와 같이 현재 파일 핸들을 변경하는 작업은 결과적으로 새 파일 핸들을 자동으로 반환하지 않습니다. 예를 들어 클라이언트가 디렉터리 항목을 조회하고 해당 파일 핸들을 가져와야 하는 경우 다음 요청이 필요합니다.

```text
      PUTFH  (directory filehandle)
      LOOKUP (entry name)
      GETFH

   ERRORS

      NFS4ERR_BADHANDLE
      NFS4ERR_FHEXPIRED
      NFS4ERR_MOVED
      NFS4ERR_NOFILEHANDLE
      NFS4ERR_RESOURCE
      NFS4ERR_SERVERFAULT
      NFS4ERR_STALE
```

---
#### **14.2.9.  Operation 11: LINK - Create Link to a File**

```text
   SYNOPSIS

     (sfh), (cfh), newname -> (cfh), change_info

   ARGUMENT

     struct LINK4args {
             /* SAVED_FH: source object */
             /* CURRENT_FH: target directory */
             component4      newname;
     };

   RESULT

     struct LINK4resok {
             change_info4    cinfo;
     };

     union LINK4res switch (nfsstat4 status) {
      case NFS4_OK:
              LINK4resok resok4;
      default:
              void;
     };

   DESCRIPTION
```

LINK 작업은 SAVEFH 작업에 의해 설정된 대로 현재 파일 핸들이 나타내는 디렉터리에 저장된 파일 핸들이 나타내는 파일에 대한 추가 새 이름을 생성합니다. 기존 파일과 대상 디렉터리는 서버의 동일한 파일 시스템 내에 있어야 합니다. 성공하면 현재 파일 핸들이 계속 대상 디렉터리가 됩니다. newname과 동일한 이름을 가진 개체가 대상 디렉터리에 존재하는 경우 서버는 NFS4ERR\_EXIST를 반환해야 합니다.

대상 디렉터리의 경우 서버는 cinfo에change\_info4 정보를 반환합니다. Change\_info4 구조체의 원자 필드를 사용하면 서버는 링크 생성과 관련하여 변경 전후 속성이 원자적으로 획득되었는지 여부를 나타냅니다.

newname의 길이가 0\(영\)이거나 newname이 UTF-8 정의를 따르지 않는 경우 NFS4ERR\_INVAL 오류가 반환됩니다.

```text
   IMPLEMENTATION
```

"하드" 링크된 파일의 속성에 대한 변경 사항은 링크된 모든 파일에 반영됩니다. 파일에 대한 링크가 만들어지면 파일 속성의 numlinks 값은 LINK 작업 이전의 값보다 1 커야 합니다.

"파일과 대상 디렉터리는 서버의 동일한 파일 시스템 내에 있어야 합니다"라는 설명은 개체 속성의 fsid 필드가 동일함을 의미합니다. 서로 다른 파일 시스템에 있는 경우 NFS4ERR\_XDEV 오류가 반환됩니다. 일부 서버에서는 파일 이름 "." 및 ".."은 새 이름으로 불법입니다.

newname이 저장된 파일 핸들이 나타내는 파일에 이미 링크되어 있는 경우 서버는 NFS4ERR\_EXIST를 반환합니다.

CREATE 작업을 통해 심볼릭 링크가 생성된다는 점에 유의하세요.

```text
   ERRORS

      NFS4ERR_ACCESS
      NFS4ERR_BADCHAR
      NFS4ERR_BADHANDLE
      NFS4ERR_BADNAME
      NFS4ERR_BADXDR
      NFS4ERR_DELAY
      NFS4ERR_DQUOT
      NFS4ERR_EXIST
      NFS4ERR_FHEXPIRED
      NFS4ERR_FILE_OPEN

      NFS4ERR_INVAL
      NFS4ERR_IO
      NFS4ERR_ISDIR
      NFS4ERR_MLINK
      NFS4ERR_MOVED
      NFS4ERR_NAMETOOLONG
      NFS4ERR_NOENT
      NFS4ERR_NOFILEHANDLE
      NFS4ERR_NOSPC
      NFS4ERR_NOTDIR
      NFS4ERR_NOTSUPP
      NFS4ERR_RESOURCE
      NFS4ERR_ROFS
      NFS4ERR_SERVERFAULT
      NFS4ERR_STALE
      NFS4ERR_WRONGSEC
      NFS4ERR_XDEV
```

---
#### **14.2.10.  Operation 12: LOCK - Create Lock**

```text
   SYNOPSIS

     (cfh) locktype, reclaim, offset, length, locker -> stateid

   ARGUMENT

     struct open_to_lock_owner4 {
             seqid4          open_seqid;
             stateid4        open_stateid;
             seqid4          lock_seqid;
             lock_owner4     lock_owner;
     };

     struct exist_lock_owner4 {
             stateid4        lock_stateid;
             seqid4          lock_seqid;
     };

     union locker4 switch (bool new_lock_owner) {
      case TRUE:
             open_to_lock_owner4     open_owner;
      case FALSE:
             exist_lock_owner4       lock_owner;
     };

     enum nfs_lock_type4 {
             READ_LT         = 1,
             WRITE_LT        = 2,

             READW_LT        = 3,    /* blocking read */
             WRITEW_LT       = 4     /* blocking write */
     };

     struct LOCK4args {
             /* CURRENT_FH: file */
             nfs_lock_type4  locktype;
             bool            reclaim;
             offset4         offset;
             length4         length;
             locker4         locker;
     };

   RESULT

     struct LOCK4denied {
             offset4         offset;
             length4         length;
             nfs_lock_type4  locktype;
             lock_owner4     owner;
     };

     struct LOCK4resok {
             stateid4        lock_stateid;
     };

     union LOCK4res switch (nfsstat4 status) {
      case NFS4_OK:
              LOCK4resok     resok4;
      case NFS4ERR_DENIED:
              LOCK4denied    denied;
      default:
              void;
     };

   DESCRIPTION

   The LOCK operation requests a record lock for the byte range
   specified by the offset and length parameters.  The lock type is also
   specified to be one of the nfs_lock_type4s.  If this is a reclaim
   request, the reclaim parameter will be TRUE;
```

해당 바이트가 현재 파일에 할당되지 않은 경우에도 파일의 바이트가 잠길 수 있습니다. 파일 끝을 통해 특정 오프셋에서 파일을 잠그려면\(파일의 실제 길이에 상관없이\) 모든 비트가 1로 설정된 길이 필드를 사용하십시오. 길이가 0인 경우,

또는 모든 비트가 1로 설정되지 않은 길이가 지정되고 오프셋에 추가된 길이가 최대 64비트 부호 없는 정수 값을 초과하는 경우 NFS4ERR\_INVAL 오류가 발생합니다.

일부 서버는 32비트 내에 맞는 바이트 오프셋에 대한 잠금만 지원할 수 있습니다. 클라이언트가 32비트 범위의 마지막 바이트 오프셋 이후의 바이트를 포함하는 범위를 지정하지만, 32비트의 마지막 바이트 오프셋과 그 이후의 모든 바이트 오프셋은 포함하지 않는 경우, 유효한 64비트 범위, 이러한 32비트 서버는 NFS4ERR\_BAD\_RANGE 오류를 반환해야 합니다.\(MUST\)

잠금이 거부된 경우 충돌하는 잠금의 소유자, 오프셋 및 길이가 반환됩니다.

성공하면 현재 파일 핸들이 해당 값을 유지합니다.

```text
   IMPLEMENTATION
```

서버가 충돌하는 잠금의 정확한 오프셋과 길이를 확인할 수 없는 경우 인수에 제공된 동일한 오프셋과 길이가 거부된 결과에 반환되어야 합니다. 파일 잠금 섹션에는 이에 대한 전체 설명과 기타 파일 잠금 작업이 포함되어 있습니다.

LOCK 작업은 권한 확인 및 관련 파일의 액세스 유형에 대한 확인을 따릅니다. 그러나 다양한 유형의 잠금에 필요한 특정 권한과 모드는 서버에서 내보낸 파일 시스템의 의미를 반영하며 프로토콜에 의해 지정되지 않습니다. 예를 들어 Windows 2000에서는 READ용으로 열린 파일에 대한 쓰기 잠금을 허용하지만 POSIX 호환 시스템에서는 허용하지 않습니다.

클라이언트가 잠금 소유자가 이미 잠근 범위\(동일하거나 다른 잠금 유형 사용\), 해당 범위의 하위 영역 또는 이미 부여된 여러 잠금을 포함하는 영역에 해당하는 잠금 요청을 하는 경우 해당 잠금 소유자가 전체 또는 일부이고 서버가 이러한 잠금 작업을 지원하지 않는 경우\(즉, POSIX 잠금 의미 체계를 지원하지 않는 경우\) 서버는 NFS4ERR\_LOCK\_RANGE 오류를 반환합니다. 이 경우 클라이언트는 해당 lock\_owner에 의해 이미 잠긴 바이트를 포함하지 않는 범위에 대해 LOCK만 사용하고 해당 lock\_owner가 보유한 잠금의 LOCKU\(정확히 일치하는 범위 지정\)를 사용하여 오류를 반환하거나 필요한 작업을 에뮬레이트할 수 있습니다. 및 유형\). 마찬가지로, 클라이언트가 기존 레코드 잠금을 업그레이드\(읽기 잠금에서 쓰기 잠금으로 변경\) 또는 다운그레이드\(쓰기 잠금에서 읽기 잠금으로 변경\)하는 잠금 요청을 하고 서버가 이를 수행하지 않는 경우

이러한 잠금을 지원하면 서버는 NFS4ERR\_LOCK\_NOTSUPP를 반환합니다. 이러한 작업은 다른 클라이언트의 잠금 요청이 충돌하는 경우 필요한 의미를 완벽하게 반영하지 못할 수 있습니다.

locker 인수는 LOCK 요청과 연관된 lock\_owner를 지정합니다. locker4 구조는 lock\_owner가 서버에 알려져 있는지 또는 lock\_owner가 서버에 새로운지 여부를 나타내는 전환된 공용체입니다. lock\_owner가 서버에 알려져 있고 설정된 lock\_seqid가 있는 경우 인수는 lock\_owner 및 lock\_seqid입니다. lock\_owner가 서버에 알려지지 않은 경우 인수에는 lock\_owner 및 lock\_seqid뿐만 아니라 open\_stateid 및 open\_seqid도 포함됩니다. 새로운 lock\_owner 사례는 lock\_owner가 수행한 첫 번째 잠금을 다루고 open\_stateid의 설정된 상태를 사용하여 lock\_owner 사용으로 전환하는 방법을 제공합니다.

```text
   ERRORS

      NFS4ERR_ACCESS
      NFS4ERR_ADMIN_REVOKED
      NFS4ERR_BADHANDLE
      NFS4ERR_BAD_RANGE
      NFS4ERR_BAD_SEQID
      NFS4ERR_BAD_STATEID
      NFS4ERR_BADXDR
      NFS4ERR_DEADLOCK
      NFS4ERR_DELAY
      NFS4ERR_DENIED
      NFS4ERR_EXPIRED
      NFS4ERR_FHEXPIRED
      NFS4ERR_GRACE
      NFS4ERR_INVAL
      NFS4ERR_ISDIR
      NFS4ERR_LEASE_MOVED
      NFS4ERR_LOCK_NOTSUPP
      NFS4ERR_LOCK_RANGE
      NFS4ERR_MOVED
      NFS4ERR_NOFILEHANDLE
      NFS4ERR_NO_GRACE
      NFS4ERR_OLD_STATEID
      NFS4ERR_OPENMODE
      NFS4ERR_RECLAIM_BAD
      NFS4ERR_RECLAIM_CONFLICT
      NFS4ERR_RESOURCE
      NFS4ERR_SERVERFAULT
      NFS4ERR_STALE
      NFS4ERR_STALE_CLIENTID
      NFS4ERR_STALE_STATEID
```

---
#### **14.2.11.  Operation 13: LOCKT - Test For Lock**

```text
   SYNOPSIS

     (cfh) locktype, offset, length owner -> {void, NFS4ERR_DENIED ->
     owner}

   ARGUMENT

     struct LOCKT4args {
             /* CURRENT_FH: file */
             nfs_lock_type4  locktype;
             offset4         offset;
             length4         length;
             lock_owner4     owner;
     };

   RESULT

     struct LOCK4denied {
             offset4         offset;
             length4         length;
             nfs_lock_type4  locktype;
             lock_owner4     owner;
     };

     union LOCKT4res switch (nfsstat4 status) {
      case NFS4ERR_DENIED:
              LOCK4denied    denied;
      case NFS4_OK:
              void;
      default:
              void;
     };

   DESCRIPTION
```

LOCKT 작업은 인수에 지정된 대로 잠금을 테스트합니다. 충돌하는 잠금이 존재하는 경우 충돌하는 잠금의 소유자, 오프셋, 길이 및 유형이 반환됩니다. 잠금이 유지되지 않으면 NFS4\_OK 외에는 아무것도 반환되지 않습니다. 잠금 유형 READ\_LT 및 READW\_LT는 차단 또는 비차단에 관계없이 충돌하는 잠금 테스트가 수행된다는 점에서 동일한 방식으로 처리됩니다. WRITE\_LT 및 WRITEW\_LT의 경우에도 마찬가지입니다.

범위는 LOCK과 같이 지정됩니다. NFS4ERR\_INVAL 및 NFS4ERR\_BAD\_RANGE 오류는 LOCK과 동일한 상황에서 반환됩니다.

성공하면 현재 파일 핸들이 해당 값을 유지합니다.

```text
   IMPLEMENTATION
```

서버가 충돌하는 잠금의 정확한 오프셋과 길이를 확인할 수 없는 경우 인수에 제공된 동일한 오프셋과 길이가 거부된 결과에 반환되어야 합니다. 파일 잠금 섹션에는 파일 잠금 메커니즘에 대한 추가 설명이 포함되어 있습니다.

LOCKT는 소유자를 식별하기 위해 LOCK에서 사용되는 것처럼 stateid4 대신 lock\_owner4를 사용합니다. 이는 클라이언트가 잠금 존재 여부를 테스트하기 위해 파일을 열 필요가 없기 때문에 상태 ID를 사용하지 못할 수 있기 때문입니다.

충돌하는 잠금에 대한 테스트에서는 현재 잠금 소유자에 대한 잠금을 제외해야 합니다. 이러한 잠금은 검사되지 않으므로 범위가 중복될 가능성이 있어도 LOCKT의 결과에 영향을 미치지 않을 수 있습니다. 서버가 범위 확인을 위해 잠금 소유자와 일치하는 잠금을 검사하는 경우 NFS4ERR\_LOCK\_RANGE가 반환될 수 있습니다. NFS4\_OK를 반환하는 경우 클라이언트는 LOCK을 수행하고 LOCK 요청에 대해 NFS4ERR\_LOCK\_RANGE를 수신할 수 있습니다. 섬기는 사람.

```text
   ERRORS

      NFS4ERR_ACCESS
      NFS4ERR_BADHANDLE
      NFS4ERR_BAD_RANGE
      NFS4ERR_BADXDR
      NFS4ERR_DELAY
      NFS4ERR_DENIED
      NFS4ERR_FHEXPIRED
      NFS4ERR_GRACE
      NFS4ERR_INVAL
      NFS4ERR_ISDIR
      NFS4ERR_LEASE_MOVED
      NFS4ERR_LOCK_RANGE
      NFS4ERR_MOVED
      NFS4ERR_NOFILEHANDLE
      NFS4ERR_RESOURCE
      NFS4ERR_SERVERFAULT
      NFS4ERR_STALE
      NFS4ERR_STALE_CLIENTID
```

---
#### **14.2.12.  Operation 14: LOCKU - Unlock File**

```text
   SYNOPSIS

     (cfh) type, seqid, stateid, offset, length -> stateid

   ARGUMENT

     struct LOCKU4args {
             /* CURRENT_FH: file */
             nfs_lock_type4  locktype;
             seqid4          seqid;
             stateid4        stateid;
             offset4         offset;
             length4         length;
     };

   RESULT

     union LOCKU4res switch (nfsstat4 status) {
      case   NFS4_OK:
              stateid4       stateid;
      default:
              void;
     };

   DESCRIPTION
```

LOCKU 연산은 매개변수에 지정된 레코드 잠금을 해제합니다. 클라이언트는 nfs\_lock\_type4 열거 유형에 대해 유효한 값으로 locktype 필드를 설정할 수 있으며, 서버는 locktype에 대한 모든 유효한 값을 수락해야 합니다. locktype의 적법한 값은 LOCKU 작업의 성공이나 실패에 영향을 주지 않습니다.\(MUST\)

범위는 LOCK과 같이 지정됩니다. NFS4ERR\_INVAL 및 NFS4ERR\_BAD\_RANGE 오류는 LOCK과 동일한 상황에서 반환됩니다.

성공하면 현재 파일 핸들이 해당 값을 유지합니다.

```text
   IMPLEMENTATION
```

잠금 해제할 영역이 잠금 소유자가 실제로 보유한 잠금과 정확하게 일치하지 않는 경우 서버는 NFS4ERR\_LOCK\_RANGE 오류를 반환할 수 있습니다. 여기에는 영역이 잠겨 있지 않은 경우, 영역이 잠긴 영역의 하위 범위인 경우, 정확히 일치하지 않고 잠긴 영역과 겹치는 경우 또는 지정된 영역에 잠금 소유자가 보유한 여러 잠금이 포함된 경우가 포함됩니다. 모두에서

POSIX 잠금 의미론에 의해 허용되는 이러한 경우, 이 오류를 수신하는 클라이언트는 그러한 작업에 대한 지원을 원하는 경우 실제로 보유하고 있는 잠금에 해당하는 범위에서 LOCKU를 사용하여 작업을 시뮬레이션해야 하며, 가능하지 않은 하위 범위에 대한 LOCK 요청이 뒤따라야 합니다. 잠금 해제되었습니다.

```text
   ERRORS

      NFS4ERR_ACCESS
      NFS4ERR_ADMIN_REVOKED
      NFS4ERR_BADHANDLE
      NFS4ERR_BAD_RANGE
      NFS4ERR_BAD_SEQID
      NFS4ERR_BAD_STATEID
      NFS4ERR_BADXDR
      NFS4ERR_EXPIRED
      NFS4ERR_FHEXPIRED
      NFS4ERR_GRACE
      NFS4ERR_INVAL
      NFS4ERR_ISDIR
      NFS4ERR_LEASE_MOVED
      NFS4ERR_LOCK_RANGE
      NFS4ERR_MOVED
      NFS4ERR_NOFILEHANDLE
      NFS4ERR_OLD_STATEID
      NFS4ERR_RESOURCE
      NFS4ERR_SERVERFAULT
      NFS4ERR_STALE
      NFS4ERR_STALE_STATEID
```

---
#### **14.2.13.  Operation 15: LOOKUP - Lookup Filename**

```text
   SYNOPSIS

     (cfh), component -> (cfh)

   ARGUMENT

     struct LOOKUP4args {
             /* CURRENT_FH: directory */
             component4      objname;
     };

   RESULT

     struct LOOKUP4res {
             /* CURRENT_FH: object */
             nfsstat4        status;
     };

   DESCRIPTION
```

이 작업은 현재 파일 핸들에 지정된 디렉터리를 사용하여 파일 시스템 개체를 LOOKUP하거나 ​​찾습니다. LOOKUP은 구성 요소를 평가하고 개체가 존재하는 경우 현재 파일 핸들이 구성 요소의 파일 핸들로 대체됩니다.

구성 요소가 존재하지 않거나 클라이언트에 구성 요소를 평가할 수 있는 권한이 없기 때문에 구성 요소를 평가할 수 없는 경우 오류가 반환되고 현재 파일 핸들은 변경되지 않습니다.

구성 요소의 길이가 0인 문자열이거나 구성 요소가 UTF-8 정의를 따르지 않는 경우 NFS4ERR\_INVAL 오류가 반환됩니다.

```text
   IMPLEMENTATION
```

클라이언트가 다중 구성 요소 조회 효과를 얻으려는 경우 다음과 같은 COMPOUND 요청을 구성하고 각 파일 핸들을 얻을 수 있습니다.

```text
      PUTFH  (directory filehandle)
      LOOKUP "pub"
      GETFH
      LOOKUP "foo"
      GETFH
      LOOKUP "bar"
      GETFH
```

NFS 버전 4 서버는 LOOKUP 요청이 서버의 마운트 지점을 통과하도록 허용한다는 점에서 이전 NFS 버전의 의미와 다릅니다. 클라이언트는 디렉토리의 fsid 속성을 조회된 디렉토리의 fsid 속성과 비교하여 마운트 지점 교차를 감지할 수 있습니다. fsid가 다르면 새 디렉토리는 서버 마운트 지점이 됩니다. 마운트 지점 교차를 감지하는 UNIX 클라이언트는 서버의 파일 시스템을 마운트해야 합니다. UNIX 클라이언트에 공통적인 파일 개체 ID 확인 메커니즘을 유지하려면 이 작업을 수행해야 합니다.

NFS 액세스를 "공유" 또는 "내보낸" 파일 시스템으로 제한하는 서버는 클라이언트가 서버의 이름 공간을 탐색할 수 있도록 내보낸 파일 시스템을 통합할 수 있는 의사 파일 시스템을 제공해야 합니다. 의사 파일 시스템에 대한 클라이언트의 보기는 내보낸 파일 시스템으로 연결되는 경로로 제한됩니다.

참고: 이전 버전의 프로토콜에서는 이름 "."에 특별한 의미가 할당되었습니다. 그리고 "..". NFS 버전 4에서는 이러한 이름에 특별한 의미를 할당하지 않습니다. 상위 디렉터리를 조회하려면 LOOKUPP 연산자를 사용해야 합니다.

이 작업은 기호 링크를 따르지 않습니다. 클라이언트는 조회 프로세스 중에 발견된 기호 링크에 의해 수정된 파일 이름을 포함하여 모든 파일 이름 구문 분석을 담당합니다.

제공된 현재 파일 핸들이 디렉토리가 아니라 심볼릭 링크인 경우 NFS4ERR\_SYMLINK 오류가 오류로 반환됩니다. 디렉터리가 아닌 다른 모든 파일 형식의 경우 NFS4ERR\_NOTDIR 오류가 반환됩니다.

```text
   ERRORS

      NFS4ERR_ACCESS
      NFS4ERR_BADCHAR
      NFS4ERR_BADHANDLE
      NFS4ERR_BADNAME
      NFS4ERR_BADXDR
      NFS4ERR_FHEXPIRED
      NFS4ERR_INVAL
      NFS4ERR_IO
      NFS4ERR_MOVED
      NFS4ERR_NAMETOOLONG
      NFS4ERR_NOENT
      NFS4ERR_NOFILEHANDLE
      NFS4ERR_NOTDIR
      NFS4ERR_RESOURCE
      NFS4ERR_SERVERFAULT
      NFS4ERR_STALE
      NFS4ERR_SYMLINK
      NFS4ERR_WRONGSEC
```

---
#### **14.2.14.  Operation 16: LOOKUPP - Lookup Parent Directory**

```text
   SYNOPSIS

     (cfh) -> (cfh)

   ARGUMENT

     /* CURRENT_FH: object */
     void;

   RESULT

     struct LOOKUPP4res {
             /* CURRENT_FH: directory */
             nfsstat4        status;
     };

   DESCRIPTION
```

현재 파일 핸들은 일반 디렉토리 또는 명명된 속성 디렉토리를 참조하는 것으로 가정됩니다. LOOKUPP은 상위 디렉터리의 파일 핸들을 현재 파일 핸들로 할당합니다. 상위 디렉토리가 없으면 NFS4ERR\_NOENT 오류가 반환되어야 합니다. 따라서 현재 파일 핸들이 서버 파일 트리의 루트 또는 최상위에 있을 때 서버는 NFS4ERR\_NOENT를 반환합니다.

```text
   IMPLEMENTATION
```

LOOKUP의 경우 LOOKUPP도 마운트 지점을 교차합니다.

현재 파일 핸들이 디렉토리나 명명된 속성 디렉토리가 아닌 경우 NFS4ERR\_NOTDIR 오류가 반환됩니다.

```text
   ERRORS

      NFS4ERR_ACCESS
      NFS4ERR_BADHANDLE
      NFS4ERR_FHEXPIRED
      NFS4ERR_IO
      NFS4ERR_MOVED
      NFS4ERR_NOENT
      NFS4ERR_NOFILEHANDLE
      NFS4ERR_NOTDIR
      NFS4ERR_RESOURCE
      NFS4ERR_SERVERFAULT
      NFS4ERR_STALE
```

---
#### **14.2.15.  Operation 17: NVERIFY - Verify Difference in Attributes**

```text
   SYNOPSIS

     (cfh), fattr -> -

   ARGUMENT

     struct NVERIFY4args {
             /* CURRENT_FH: object */
             fattr4          obj_attributes;
     };

   RESULT

     struct NVERIFY4res {
             nfsstat4        status;
     };

   DESCRIPTION
```

이 작업은 일부 파일 시스템 객체에서 하나 이상의 속성이 변경된 경우 수행될 작업 시퀀스의 접두사로 사용됩니다. 모든 속성이 일치하면 NFS4ERR\_SAME 오류가 반환되어야 합니다.

성공하면 현재 파일 핸들이 해당 값을 유지합니다.

```text
   IMPLEMENTATION
```

이 작업은 캐시 유효성 검사 연산자로 유용합니다. 속성이 속한 개체가 변경된 경우 다음 작업을 통해 해당 개체와 관련된 새 데이터를 얻을 수 있습니다. 예를 들어, 파일이 변경되었는지 확인하고 다음과 같은 경우 새 데이터를 얻으려면:

```text
      PUTFH  (public)
      LOOKUP "foobar"
      NVERIFY attrbits attrs
      READ 0 32767
```

NVERIFY 작업에 권장 속성이 지정되어 있고 서버가 파일 시스템 개체에 대해 해당 속성을 지원하지 않는 경우 NFS4ERR\_ATTRNOTSUPP 오류가 클라이언트에 반환됩니다.

rdattr\_error 속성이나 쓰기 전용 속성\(예: time\_modify\_set\)이 지정되면 NFS4ERR\_INVAL 오류가 클라이언트에 반환됩니다.

```text
   ERRORS

      NFS4ERR_ACCESS
      NFS4ERR_ATTRNOTSUPP
      NFS4ERR_BADCHAR
      NFS4ERR_BADHANDLE
      NFS4ERR_BADXDR
      NFS4ERR_DELAY
      NFS4ERR_FHEXPIRED
      NFS4ERR_INVAL
      NFS4ERR_IO
      NFS4ERR_MOVED
      NFS4ERR_NOFILEHANDLE
      NFS4ERR_RESOURCE
      NFS4ERR_SAME
      NFS4ERR_SERVERFAULT
      NFS4ERR_STALE
```

---
#### **14.2.16.  Operation 18: OPEN - Open a Regular File**

```text
   SYNOPSIS

     (cfh), seqid, share_access, share_deny, owner, openhow, claim ->
     (cfh), stateid, cinfo, rflags, open_confirm, attrset delegation

   ARGUMENT

     struct OPEN4args {
             seqid4          seqid;
             uint32_t        share_access;
             uint32_t        share_deny;
             open_owner4     owner;
             openflag4       openhow;
             open_claim4     claim;
     };

     enum createmode4 {
             UNCHECKED4      = 0,
             GUARDED4        = 1,
             EXCLUSIVE4      = 2
     };

     union createhow4 switch (createmode4 mode) {
      case UNCHECKED4:
      case GUARDED4:
              fattr4         createattrs;
      case EXCLUSIVE4:
              verifier4      createverf;

     };

     enum opentype4 {
             OPEN4_NOCREATE  = 0,
             OPEN4_CREATE    = 1
     };

     union openflag4 switch (opentype4 opentype) {
      case OPEN4_CREATE:
              createhow4     how;
      default:
              void;
     };

     /* Next definitions used for OPEN delegation */
     enum limit_by4 {
             NFS_LIMIT_SIZE          = 1,
             NFS_LIMIT_BLOCKS        = 2
             /* others as needed */
     };

     struct nfs_modified_limit4 {
             uint32_t        num_blocks;
             uint32_t        bytes_per_block;
     };

     union nfs_space_limit4 switch (limit_by4 limitby) {
      /* limit specified as file size */
      case NFS_LIMIT_SIZE:
              uint64_t               filesize;
      /* limit specified by number of blocks */
      case NFS_LIMIT_BLOCKS:
              nfs_modified_limit4    mod_blocks;
     } ;

     enum open_delegation_type4 {
             OPEN_DELEGATE_NONE      = 0,
             OPEN_DELEGATE_READ      = 1,
             OPEN_DELEGATE_WRITE     = 2
     };

     enum open_claim_type4 {
             CLAIM_NULL              = 0,
             CLAIM_PREVIOUS          = 1,
             CLAIM_DELEGATE_CUR      = 2,
             CLAIM_DELEGATE_PREV     = 3
     };

     struct open_claim_delegate_cur4 {
             stateid4        delegate_stateid;
             component4      file;
     };

     union open_claim4 switch (open_claim_type4 claim) {
      /*
       * No special rights to file. Ordinary OPEN of the specified file.
       */
      case CLAIM_NULL:
              /* CURRENT_FH: directory */
              component4     file;

      /*
       * Right to the file established by an open previous to server
       * reboot.  File identified by filehandle obtained at that time
       * rather than by name.
       */
      case CLAIM_PREVIOUS:
              /* CURRENT_FH: file being reclaimed */
              open_delegation_type4   delegate_type;

      /*
       * Right to file based on a delegation granted by the server.
       * File is specified by name.
       */
      case CLAIM_DELEGATE_CUR:
              /* CURRENT_FH: directory */
              open_claim_delegate_cur4       delegate_cur_info;

      /* Right to file based on a delegation granted to a previous boot
       * instance of the client.  File is specified by name.
       */
      case CLAIM_DELEGATE_PREV:
              /* CURRENT_FH: directory */
              component4     file_delegate_prev;
     };

   RESULT

   struct open_read_delegation4 {
           stateid4        stateid;        /* Stateid for delegation*/
           bool            recall;         /* Pre-recalled flag for
                                              delegations obtained
                                              by reclaim
                                              (CLAIM_PREVIOUS) */
           nfsace4         permissions;    /* Defines users who don't
                                              need an ACCESS call to

                                              open for read */
   };

   struct open_write_delegation4 {
           stateid4        stateid;        /* Stateid for delegation*/
           bool            recall;         /* Pre-recalled flag for
                                              delegations obtained
                                              by reclaim
                                              (CLAIM_PREVIOUS) */
           nfs_space_limit4 space_limit;   /* Defines condition that
                                              the client must check to
                                              determine whether the
                                              file needs to be flushed
                                              to the server on close.
                                              */
           nfsace4         permissions;    /* Defines users who don't
                                              need an ACCESS call as
                                              part of a delegated
                                              open. */
   };

   union open_delegation4
   switch (open_delegation_type4 delegation_type) {
           case OPEN_DELEGATE_NONE:
                   void;
           case OPEN_DELEGATE_READ:
                   open_read_delegation4 read;
           case OPEN_DELEGATE_WRITE:
                   open_write_delegation4 write;
   };

   const OPEN4_RESULT_CONFIRM      = 0x00000002;
   const OPEN4_RESULT_LOCKTYPE_POSIX = 0x00000004;

   struct OPEN4resok {
           stateid4        stateid;        /* Stateid for open */
           change_info4    cinfo;          /* Directory Change Info */
           uint32_t        rflags;         /* Result flags */
           bitmap4         attrset;        /* attributes on create */
           open_delegation4 delegation;    /* Info on any open
                                              delegation */
   };

   union OPEN4res switch (nfsstat4 status) {
    case NFS4_OK:
           /* CURRENT_FH: opened file */
           OPEN4resok      resok4;
    default:

           void;
   };
```

클라이언트 구현자에 대한 경고

OPEN은 클라이언트가 사용할 파일 핸들을 생성한다는 점에서 LOOKUP과 유사합니다. 그러나 LOOKUP과 달리 OPEN은 파일 핸들에 서버 상태를 생성합니다. 일반적인 상황에서 클라이언트는 CLOSE 작업을 통해서만 이 상태를 해제할 수 있습니다. CLOSE는 현재 파일 핸들을 사용하여 닫을 파일을 결정합니다. 따라서 클라이언트는 동일한 COMPOUND 프로시저에서 GETFH 작업이 포함된 모든 OPEN 작업을 따라야 합니다. 그러면 CLOSE를 적절하게 사용할 수 있도록 클라이언트에 파일 핸들이 제공됩니다.\(MUST\)

다른 클라이언트가 동일한 파일에 대해 충돌하는 액세스를 시도하지 않는 한 서버는 무기한으로 상태를 유지할 수 있으므로 단순히 파일 임대가 만료될 때까지 기다리는 것만으로는 충분하지 않습니다.

```text
   DESCRIPTION
```

OPEN 작업은 제공된 이름을 가진 디렉터리에 일반 파일을 생성 및/또는 엽니다. 서버에 파일이 없고 생성을 원할 경우 openhow 매개변수로 생성 방법을 지정합니다. 클라이언트는 UNCHECKED, GUARDED 또는 EXCLUSIVE의 세 가지 생성 방법 중에서 선택할 수 있습니다.

현재 파일 핸들이 명명된 속성 디렉터리인 경우 OPEN은 명명된 속성 파일을 생성하거나 엽니다. 명명된 속성의 단독 생성은 지원되지 않습니다. createmode가 EXCLUSIVE4이고 현재 파일 핸들이 명명된 속성 디렉터리인 경우 서버는 EINVAL을 반환합니다.

UNCHECKED는 해당 이름의 파일이 존재하지 않고 해당 이름의 기존 일반 파일이 발생하는 것이 오류가 아닌 경우 파일을 생성해야 함을 의미합니다. 이러한 유형의 생성에 대해 createattrs는 파일의 초기 속성 세트를 지정합니다. 속성 세트에는 일반 파일에 유효한 쓰기 가능한 속성이 포함될 수 있습니다. UNCHECKED 생성이 기존 파일을 발견하면 createattrs에 지정된 속성은 사용되지 않습니다. 단, 크기가 0으로 지정되면 기존 파일이 잘립니다. GUARDED가 지정되면 서버는 생성을 수행하기 전에 이름으로 중복 개체가 있는지 확인합니다. 중복된 것이 있으면 NFS4ERR\_EXIST 오류를 상태로 반환합니다. 객체가 존재하지 않으면 UNCHECKED에 설명된 대로 요청이 수행됩니다. 을 위한

작업이 성공한 각각의 경우\(UNCHECKED 및 GUARDED\), 서버는 객체에 대해 어떤 속성이 성공적으로 설정되었는지 나타내는 속성 마스크를 클라이언트에 반환합니다.

EXCLUSIVE는 서버가 대상의 독점 생성을 보장하기 위해 검증자를 사용하여 독점 생성 의미 체계를 따르도록 지정합니다. 서버는 이름으로 중복 개체가 있는지 확인해야 합니다. 객체가 존재하지 않으면 서버는 객체를 생성하고 객체와 함께 검증자를 저장합니다. 객체가 존재하고 저장된 검증자가 클라이언트가 제공한 검증자와 일치하는 경우 서버는 기존 객체를 새로 생성된 객체로 사용합니다. 저장된 검증자가 일치하지 않으면 NFS4ERR\_EXIST 오류가 반환됩니다. 이 경우에는 서버가 대상 개체의 속성을 사용하여 검증자를 저장할 수 있으므로 속성이 제공되지 않을 수 있습니다. 서버가 독점 생성 검증자를 저장하기 위해 속성을 사용하는 경우 결과에 반환되는 속성 마스크에 적절한 비트를 설정하여 어떤 속성을 나타냅니다.

대상 디렉터리의 경우 서버는 cinfo에change\_info4 정보를 반환합니다. Change\_info4 구조체의 원자 필드를 사용하면 서버는 링크 생성과 관련하여 변경 전후 속성이 원자적으로 획득되었는지 여부를 나타냅니다.

성공적으로 생성되면 현재 파일 핸들이 새 객체의 파일 핸들로 대체됩니다.

```text
   The OPEN operation provides for Windows share reservation capability
   with the use of the share_access and share_deny fields of the OPEN
   arguments.  The client specifies at OPEN the required share_access
   and share_deny modes.  For clients that do not directly support
   SHAREs (i.e., UNIX), the expected deny value is DENY_NONE.  In the
   case that there is a existing SHARE reservation that conflicts with
   the OPEN request, the server returns the error NFS4ERR_SHARE_DENIED.
   For a complete SHARE request, the client must provide values for the
   owner and seqid fields for the OPEN argument.  For additional
   discussion of SHARE semantics see the section on 'Share
   Reservations'.
```

클라이언트가 서버 오류로부터 상태를 복구하는 경우 OPEN 인수의 클레임 필드는 요청이 이전에 보유된 상태를 복구하려는 것임을 나타내는 데 사용됩니다.

OPEN 인수의 "클레임" 필드는 열려는 파일과 클라이언트가 소유한다고 주장하는 상태 정보를 지정하는 데 사용됩니다. OPEN에 대한 다양한 상황을 다루는 네 가지 기본 청구 유형이 있습니다. 그것들은 다음과 같습니다:

CLAIM\_NULL

- 클라이언트의 경우 이는 새로운 OPEN 요청이며 클라이언트의 파일과 관련된 이전 상태가 없습니다.

CLAIM\_이전

- 클라이언트가 서버 재부팅 이전에 보관되었던 파일에 대해 기본 OPEN 상태를 요구하고 있습니다. 일반적으로 서버가 영구 파일 핸들을 반환할 때 사용됩니다. 클라이언트에 OPEN을 회수할 파일 이름이 없을 수 있습니다.

CLAIM\_DELEGATE\_CUR

- 클라이언트는 서버가 부여한 OPEN 위임을 요청합니다. 일반적으로 이는 대표단을 소환하는 과정의 일부로 수행됩니다.

CLAIM\_DELEGATE\_PREV

- 클라이언트가 이전 클라이언트 인스턴스에 부여된 위임을 요청하고 있습니다. 클라이언트 재부팅 후에 사용됩니다. 서버는 CLAIM\_DELEGATE\_PREV를 지원할 수 있습니다. CLAIM\_DELEGATE\_PREV를 지원하는 경우 SETCLIENTID\_CONFIRM은 클라이언트의 위임 상태를 제거해서는 안 되며 서버는 DELEGPURGE 작업을 지원해야 합니다.\(MAY, MUST NOT\)

유예 기간 또는 임대 만료 기간 동안 서버에 도달하는 클레임 ​​유형이 CLAIM\_PREVIOUS가 아닌 OPEN 요청\(즉, 서버 재부팅 후 오픈 회수에 할당된 요청이 아닌 요청\)의 경우 서버는 NFS4ERR\_GRACE 오류를 반환합니다.

모든 OPEN 요청에 대해 서버는 공개 위임 섹션에 설명된 대로 추가 열기 및 닫기를 클라이언트에서 로컬로 처리할 수 있는 공개 위임을 반환할 수 있습니다. 위임은 서버가 결정한다는 점에 유의하세요. 클라이언트는 특정 인스턴스에서 위임이 승인되거나 승인되지 않을 것이라고 가정해서는 안 됩니다. 두 경우 모두에 대해 항상 준비해야 합니다. 부분적인 예외는 위임 유형이 청구되는 회수\(CLAIM\_PREVIOUS\) 사례입니다. 이 경우 서버가 위임 구조에서 즉시 회수를 지정할 수 있더라도 위임은 항상 허용됩니다.

성공적인 OPEN에 의해 ​​반환된 rflags를 통해 서버는 열린 파일을 처리하는 방법을 제어하는 ​​정보를 반환할 수 있습니다.

OPEN4\_RESULT\_CONFIRM은 클라이언트가 열린 파일을 사용하기 전에 OPEN\_CONFIRM 작업을 실행해야 함을 나타냅니다. OPEN4\_RESULT\_LOCKTYPE\_POSIX는 서버의 파일 잠금 동작이 전체 Posix 잠금 기술 세트를 지원함을 나타냅니다. 여기에서 클라이언트는 파일 잠금 관리 불일치를 처리하는 방식으로 파일 잠금 상태를 관리하도록 선택할 수 있습니다.\(MUST\)

구성요소의 길이가 0인 경우 NFS4ERR\_INVAL이 반환됩니다. 구성 요소에는 일반 UTF-8, 문자 지원 및 이름 확인도 적용됩니다. 자세한 내용은 "UTF-8 관련 오류" 섹션을 참조하세요.

OPEN이 완료되고 지정된 잠금 소유자가 이미 결과 파일 핸들을 열었을 때 결과는 기존 상태와 함께 새 공유 및 거부 상태를 함께 "OR"하는 것입니다. 이 경우 여러 OPEN이 완료되었더라도 CLOSE는 한 번만 수행하면 됩니다. 이러한 OPEN이 완료되면 동일한 잠금 소유자가 보유한 기존 OPEN에 대한 예외 없이 새 OPEN에 대한 공유 예약 확인이 정상적으로 진행됩니다.

서버의 기본 파일 시스템이 읽기 전용 모드에서만 액세스 가능하고 OPEN 요청이 ACCESS\_WRITE 또는 ACCESS\_BOTH를 지정한 경우 서버는 NFS4ERR\_ROFS를 반환하여 읽기 전용 파일 시스템을 나타냅니다.

CREATE 작업과 마찬가지로 서버는 네 가지 속성 중 하나라도 필요하고 서버의 파일 시스템에서 지원하는 경우 소유자, 소유자 ACE, 그룹 또는 그룹 ACE를 파생해야 합니다. EXCLUSIVE4 createmode를 사용하는 OPEN의 경우 이러한 OPEN 호출에는 createattrs 필드가 포함되지 않으므로 서버에는 선택의 여지가 없습니다. 반대로, createattrs가 지정되고 RPC 호출 자격 증명의 주체가 파일을 생성할 권한이 없는 소유자나 그룹\(또는 해당 ACE\)을 포함하는 경우 서버는 NFS4ERR\_PERM을 반환할 수 있습니다.\(MUST\)

크기를 0\(예: 잘림\)으로 지정하고 파일에 명명된 속성이 있는 OPEN의 경우 명명된 속성은 그대로 유지됩니다. 제거되지 않습니다.

```text
   IMPLEMENTATION
```

OPEN 작업에는 EXCLUSIVE 생성에 대한 지원이 포함됩니다. 메커니즘은 NFS 버전 3\[RFC1813\]의 지원과 유사합니다. NFS 버전 3에서와 마찬가지로 이 메커니즘은 안정적인 배타적 생성을 제공합니다. How 매개변수가 EXCLUSIVE인 경우 단독 생성이 호출됩니다. 이 경우 클라이언트는 고유하다고 합리적으로 예상할 수 있는 검증자를 제공합니다. 클라이언트의 조합

식별자\(아마도 클라이언트 네트워크 주소\), 클라이언트가 생성한 고유 번호\(아마도 RPC 트랜잭션 식별자\)가 적절할 수 있습니다.

객체가 존재하지 않으면 서버는 객체를 생성하고 검증자를 안정적인 저장소에 저장합니다. 임의의 파일 속성 저장을 위한 메커니즘을 제공하지 않는 파일 시스템의 경우 서버는 객체 메타데이터의 하나 이상의 요소를 사용하여 검증자를 저장할 수 있습니다. 요청 재전송 시 오류가 발생하는 것을 방지하려면 검증자를 안정적인 저장소에 저장해야 합니다. 배타적 의미 체계가 애플리케이션에 중요하기 때문에 배타적 생성이 수행되고 있다고 가정합니다. 예상되는 사용법으로 인해 배타적 CREATE는 검증기 저장을 위해 일반적으로 휘발성인 중복 요청 캐시에만 의존하지 않습니다. 휘발성 저장소의 중복 요청 캐시는 충돌 후에도 유지되지 않으며 실제로 긴 네트워크 파티션에서 플러시되어 실패 창이 열릴 수 있습니다. UNIX 로컬 파일 시스템 환경에서 생성 시 검증자의 예상 저장 위치는 객체의 메타데이터\(타임스탬프\)입니다. 이러한 이유로 독점 객체 생성에는 서버가 검증자를 저장할 곳이 없기 때문에 초기 속성이 포함되지 않을 수 있습니다.

검증자를 안정적인 저장소에 커밋해야 한다는 요구 사항으로 인해 서버가 이러한 배타적 생성 의미 체계를 지원할 수 없는 경우 NFS4ERR\_NOTSUPP 오류와 함께 OPEN 요청이 실패해야 합니다.

배타적 CREATE 요청 중에 객체가 이미 존재하는 경우 서버는 객체의 검증자를 재구성하고 이를 요청의 검증자와 비교합니다. 일치하면 서버는 요청을 성공으로 처리합니다. 요청은 응답이 손실되고 서버 중복 요청 캐시 메커니즘이 감지하지 못한 이전의 성공적인 요청의 중복인 것으로 추정됩니다. 검증자가 일치하지 않으면 NFS4ERR\_EXIST 상태로 요청이 거부됩니다.

클라이언트가 성공적인 독점 생성을 수행한 후에는 SETATTR을 실행하여 올바른 개체 속성을 설정해야 합니다. 그렇게 하기 전까지는 서버 구현이 검증자를 저장하기 위해 객체 메타데이터를 오버로드해야 할 수 있으므로 객체 속성에 의존해서는 안 됩니다. 후속 SETATTR은 OPEN과 동일한 COMPOUND 요청에서 발생해서는 안 됩니다. 이러한 분리는 요청 재전송 시에도 배타적 생성 메커니즘이 계속해서 제대로 작동하도록 보장합니다.

GUARDED 속성을 사용하면 정확히 한 번 의미 체계가 제공되지 않습니다. 특히, 응답이 손실되고 서버가 요청의 재전송을 감지하지 못하는 경우 작업이 실패할 수 있습니다.

NFS4ERR\_EXIST, 생성이 성공적으로 수행되었음에도 불구하고. 클라이언트는 응용 프로그램이 단독 생성을 요청하지 않았지만 파일이 열릴 때 파일을 자르도록 요청한 경우 이 동작을 사용합니다. 클라이언트가 시간 초과되어 생성 요청을 재전송하는 경우 클라이언트는 GUARDED를 사용하여 생성, 쓰기, 생성\(재전송\)과 같은 시퀀스가 ​​발생하지 않도록 방지할 수 있습니다.

SHARE 예약의 경우 클라이언트는 READ, WRITE 또는 BOTH 중 하나인 share\_access 값을 지정해야 합니다. share\_deny의 경우 클라이언트는 NONE, READ, WRITE 또는 BOTH 중 하나를 지정해야 합니다. 클라이언트가 이를 수행하지 못하면 서버는 NFS4ERR\_INVAL을 반환해야 합니다.

share\_access 값\(READ, WRITE 또는 BOTH\)을 기반으로 클라이언트는 요청자가 지정된 작업을 수행할 수 있는 적절한 액세스 권한을 가지고 있는지 확인해야 합니다. 이는 일반적으로 현재 요청자의 파일에 ACL 액세스 규칙을 적용한 결과입니다. 그러나 ACCESS 작업과 마찬가지로 클라이언트는 액세스 권한이 변경될 수 있고 ACL 프레임워크 외부에서 서버 관리 제어의 대상이 될 수 있으므로 서버의 결정을 추측하려고 시도해서는 안 됩니다. 요청자에게 읽기 또는 쓰기 권한이 없는 경우\(share\_access 값에 따라\) 서버는 NFS4ERR\_ACCESS를 반환해야 합니다. NFS 버전 4 프로토콜은 열린 파일에 대해 실행된 READ 및 WRITE가 OPEN 자체와 동일한 자격 증명을 가져야 한다는 요구 사항을 부과하지 않으므로 서버는 여전히 READ 및 WRITE 자체에 대해 적절한 액세스 검사를 수행해야 합니다.

OPEN에 제공된 구성 요소가 심볼릭 링크인 경우 NFS4ERR\_SYMLINK 오류가 클라이언트에 반환됩니다. 현재 파일 핸들이 디렉터리가 아니면 NFS4ERR\_NOTDIR 오류가 반환됩니다.

```text
   ERRORS

      NFS4ERR_ACCESS
      NFS4ERR_ADMIN_REVOKED
      NFS4ERR_ATTRNOTSUPP
      NFS4ERR_BADCHAR
      NFS4ERR_BADHANDLE
      NFS4ERR_BADNAME
      NFS4ERR_BADOWNER
      NFS4ERR_BAD_SEQID
      NFS4ERR_BADXDR
      NFS4ERR_DELAY
      NFS4ERR_DQUOT
      NFS4ERR_EXIST
      NFS4ERR_EXPIRED

      NFS4ERR_FHEXPIRED
      NFS4ERR_GRACE
      NFS4ERR_IO
      NFS4ERR_INVAL
      NFS4ERR_ISDIR
      NFS4ERR_LEASE_MOVED
      NFS4ERR_MOVED
      NFS4ERR_NAMETOOLONG
      NFS4ERR_NOENT
      NFS4ERR_NOFILEHANDLE
      NFS4ERR_NOSPC
      NFS4ERR_NOTDIR
      NFS4ERR_NOTSUPP
      NFS4ERR_NO_GRACE
      NFS4ERR_PERM
      NFS4ERR_RECLAIM_BAD
      NFS4ERR_RECLAIM_CONFLICT
      NFS4ERR_RESOURCE
      NFS4ERR_ROFS
      NFS4ERR_SERVERFAULT
      NFS4ERR_SHARE_DENIED
      NFS4ERR_STALE
      NFS4ERR_STALE_CLIENTID
      NFS4ERR_SYMLINK
      NFS4ERR_WRONGSEC
```

---
#### **14.2.17.  Operation 19: OPENATTR - Open Named Attribute Directory**

```text
   SYNOPSIS

     (cfh) createdir -> (cfh)

   ARGUMENT

     struct OPENATTR4args {
             /* CURRENT_FH: object */
             bool    createdir;
     };

   RESULT

     struct OPENATTR4res {
             /* CURRENT_FH: named attr directory*/
             nfsstat4        status;
     };

   DESCRIPTION
```

OPENATTR 작업은 현재 파일 핸들과 연관된 명명된 속성 디렉터리의 파일 핸들을 얻는 데 사용됩니다. OPENATTR의 결과는 NF4ATTRDIR 유형의 객체에 대한 파일 핸들이 됩니다. 이 파일 핸들에서 READDIR 및 LOOKUP 작업을 사용하여 원래 파일 시스템 개체와 관련된 다양한 명명된 속성에 대한 파일 핸들을 얻을 수 있습니다. 명명된 속성 디렉터리 내에서 반환된 파일 핸들은 NF4NAMEDATTR 유형을 갖습니다.

Createdir 인수를 사용하면 클라이언트는 명명된 속성 디렉터리가 OPENATTR 작업의 결과로 생성되어야 하는지 여부를 나타낼 수 있습니다. 일부 클라이언트는 객체에 명명된 속성이 존재하는지 확인하기 위해 createir에 대해 FALSE 값과 함께 OPENATTR 작업을 사용할 수 있습니다. 존재하지 않는 경우 NFS4ERR\_NOENT가 반환됩니다. Createdir의 값이 TRUE이고 명명된 속성 디렉터리가 없으면 디렉터리가 생성됩니다. 명명된 속성 디렉토리의 생성은 서버가 이러한 방식으로 명명된 속성 지원을 구현했으며 이 정의에 따라 그렇게 할 필요가 없다고 가정합니다.

```text
   IMPLEMENTATION
```

서버가 현재 파일 핸들에 대해 명명된 속성을 지원하지 않으면 NFS4ERR\_NOTSUPP 오류가 클라이언트에 반환됩니다.

```text
   ERRORS

      NFS4ERR_ACCESS
      NFS4ERR_BADHANDLE
      NFS4ERR_BADXDR
      NFS4ERR_DELAY
      NFS4ERR_DQUOT
      NFS4ERR_FHEXPIRED
      NFS4ERR_IO
      NFS4ERR_MOVED
      NFS4ERR_NOENT
      NFS4ERR_NOFILEHANDLE
      NFS4ERR_NOSPC
      NFS4ERR_NOTSUPP
      NFS4ERR_RESOURCE
      NFS4ERR_ROFS
      NFS4ERR_SERVERFAULT
      NFS4ERR_STALE
```

---
#### **14.2.18.  Operation 20: OPEN_CONFIRM - Confirm Open**

```text
   SYNOPSIS

     (cfh), seqid, stateid-> stateid

   ARGUMENT

     struct OPEN_CONFIRM4args {
             /* CURRENT_FH: opened file */
             stateid4        open_stateid;
             seqid4          seqid;
     };

   RESULT

     struct OPEN_CONFIRM4resok {
             stateid4        open_stateid;
     };

     union OPEN_CONFIRM4res switch (nfsstat4 status) {
      case NFS4_OK:
              OPEN_CONFIRM4resok     resok4;
      default:
              void;
     };

   DESCRIPTION
```

이 작업은 클라이언트가 open\_owner를 처음 사용하는 경우 시퀀스 ID 사용을 확인하는 데 사용됩니다. OPEN 작업에서 반환된 stateid는 open\_owner의 다음 시퀀스 ID와 함께 이 작업의 인수로 사용됩니다. OPEN\_CONFIRM에 전달된 시퀀스 ID는 open\_confirm 값을 얻은 OPEN 작업에 전달된 seqid보다 1 커야 합니다. 서버가 원래 열기와 관련하여 예상치 못한 시퀀스 ID를 수신하면 서버는 클라이언트가 원래 OPEN을 확인하지 않고 원래 OPEN과 관련된 모든 상태가 서버에 의해 해제된다고 가정합니다.

성공하면 현재 파일 핸들이 해당 값을 유지합니다.

```text
   IMPLEMENTATION
```

특정 클라이언트는 특정 clientid에 대해 많은 open\_owner4 데이터 구조를 생성할 수 있습니다. 클라이언트는 주기적으로 open\_owner4를 폐기하거나 무기한 사용을 중지합니다. 후자의 상황은 NFS 버전 4 프로토콜에

open\_owner4를 종료하는 명시적 작업: 이러한 작업은 해당 상황에서는 쓸모가 없습니다. 대신, 무제한 메모리 사용을 방지하기 위해 서버는 파일에 대한 현재 잠금, 열기 또는 위임 상태가 없고 최근에 사용되지 않은 open\_owner4s를 처리하기 위한 전략을 구현해야 합니다. open\_owner4s를 폐기할 시기를 결정하는 데 사용되는 기간은 구현 선택 사항입니다. 기간은 임대 시간에 서버가 임대 시간 이후에 구현하려는 유예 기간을 더한 것 이상이어야 합니다. OPEN\_CONFIRM 작업을 통해 서버는 사용되지 않는 open\_owner4 데이터 구조를 안전하게 삭제할 수 있습니다.

클라이언트가 OPEN 작업을 실행하고 서버에 더 이상 open\_owner4 기록이 없는 경우 서버는 이것이 재생이나 재전송이 아닌 새로운 OPEN인지 확인해야 합니다.

서버는 위임을 부여하거나 회수 작업을 수행하는 OPEN에 대한 확인을 요구해서는 안 됩니다. 자세한 내용은 "공개 확인 사용" 섹션을 참조하세요. 서버는 주어진 클라이언트 ID에 대해 하나의 open\_owner4를 처리했는지 여부를 확인하여 이를 쉽게 피할 수 있습니다. 서버가 위임을 지원하지 않는 경우 open\_owner4\(모든 클라이언트에 대해\)가 삭제되었는지 여부를 나타내는 단일 비트만 유지 관리할 수 있습니다.

서버는 세 가지 이벤트 중 하나가 발생할 때까지 확인되지 않은 OPEN 상태를 유지해야 합니다. 먼저 클라이언트는 임대 기간 내에 적절한 시퀀스 ID 및 상태 ID와 함께 OPEN\_CONFIRM 요청을 보냅니다. 이 경우 서버의 OPEN 상태는 확인됨으로 전환되고 서버의 open\_owner4는 완전히 설정됩니다.

둘째, 클라이언트는 open\_owner4에 대해 잘못된 시퀀스 ID\(순서가 아님\)를 사용하여 또 다른 OPEN 요청을 보냅니다. 이 경우 서버는 두 번째 OPEN 요청이 유효하고 첫 번째 OPEN 요청이 재생이라고 가정합니다. 서버는 첫 번째 OPEN 요청의 OPEN 상태를 취소하고 두 번째 OPEN 요청에 대해 확인되지 않은 OPEN 상태를 설정한 다음 OPEN\_CONFIRM이 필요하다는 표시로 두 번째 OPEN 요청에 응답합니다. 그런 다음 프로세스가 반복됩니다. 클라이언트에 대한 서비스 거부 공격의 가능성이 있지만 클라이언트와 서버가 Kerberos V5, LIPKEY 또는 암호화를 사용하는 다른 특성을 기반으로 하는 보안 특성을 사용해야 하는 경우 완화됩니다.

서버가 특정 open\_owner4에 대해 확인되지 않은 OPEN 상태이고 stateid가 있지만 해당 작업이 OPEN이 아니거나 OPEN\_CONFIRM이지만 잘못된 stateid가 있는 open\_owner4에서 작업을 수신하면 어떻게 되나요? 그러면 seqid가 정확하더라도

서버는 작업이 재생이라고 가정하기 때문에 NFS4ERR\_BAD\_STATEID를 반환합니다. 서버에 설정된 OPEN 상태가 없으면 LOCK 작업이 유효할 수 있는 방법이 없습니다.

셋째, 임대 기간 내에 open\_owner4에 대해서는 앞서 언급한 두 가지 이벤트 중 어느 것도 발생하지 않습니다. 이 경우 OPEN 상태가 취소되고 open\_owner4의 폐기가 발생할 수 있습니다.

```text
   ERRORS

      NFS4ERR_ADMIN_REVOKED
      NFS4ERR_BADHANDLE
      NFS4ERR_BAD_SEQID
      NFS4ERR_BAD_STATEID
      NFS4ERR_BADXDR
      NFS4ERR_EXPIRED
      NFS4ERR_FHEXPIRED
      NFS4ERR_INVAL
      NFS4ERR_ISDIR
      NFS4ERR_MOVED
      NFS4ERR_NOFILEHANDLE
      NFS4ERR_OLD_STATEID
      NFS4ERR_RESOURCE
      NFS4ERR_SERVERFAULT
      NFS4ERR_STALE
      NFS4ERR_STALE_STATEID
```

---
#### **14.2.19.  Operation 21: OPEN_DOWNGRADE - Reduce Open File Access**

```text
   SYNOPSIS

     (cfh), stateid, seqid, access, deny -> stateid

   ARGUMENT

     struct OPEN_DOWNGRADE4args {
             /* CURRENT_FH: opened file */
             stateid4        open_stateid;
             seqid4          seqid;
             uint32_t        share_access;
             uint32_t        share_deny;
     };

   RESULT

     struct OPEN_DOWNGRADE4resok {
             stateid4        open_stateid;
     };

     union OPEN_DOWNGRADE4res switch(nfsstat4 status) {
      case NFS4_OK:
             OPEN_DOWNGRADE4resok    resok4;
      default:
             void;
     };

   DESCRIPTION
```

이 작업은 주어진 열기에 대한 share\_access 및 share\_deny 비트를 조정하는 데 사용됩니다. 이는 특정 openowner가 서로 다른 share\_access 및 share\_deny 플래그를 사용하여 동일한 파일을 여러 번 열 때 필요합니다. 이 상황에서 열기 중 하나를 닫으면 더 이상 유효하지 않은 열기와 관련된 비트를 제거하기 위해 적절한 share\_access 및 share\_deny 플래그가 변경될 수 있습니다.

이 작업에 지정된 share\_access 및 share\_deny 비트는 지정된 열린 파일에 대한 현재 비트를 대체합니다. 지정된 share\_access 및 share\_deny 비트는 현재 파일의 현재 openowner에 대해 유효한 OPEN의 일부 하위 집합에 대해 지정된 share\_access 및 share\_deny 비트의 합집합과 정확히 동일해야 합니다. 해당 제약 조건이 준수되지 않으면 NFS4ERR\_INVAL 오류가 반환되어야 합니다. share\_access 및 share\_deny 비트는 이미 부여된 비트의 하위 집합이므로 공유 예약 충돌로 인해 이 요청이 거부될 수 없습니다.

성공하면 현재 파일 핸들이 해당 값을 유지합니다.

```text
   ERRORS

      NFS4ERR_ADMIN_REVOKED
      NFS4ERR_BADHANDLE
      NFS4ERR_BAD_SEQID
      NFS4ERR_BAD_STATEID
      NFS4ERR_BADXDR
      NFS4ERR_EXPIRED
      NFS4ERR_FHEXPIRED
      NFS4ERR_INVAL
      NFS4ERR_MOVED
      NFS4ERR_NOFILEHANDLE
      NFS4ERR_OLD_STATEID
      NFS4ERR_RESOURCE
      NFS4ERR_SERVERFAULT
      NFS4ERR_STALE
      NFS4ERR_STALE_STATEID
```

---
#### **14.2.20.  Operation 22: PUTFH - Set Current Filehandle**

```text
   SYNOPSIS

     filehandle -> (cfh)

   ARGUMENT

     struct PUTFH4args {
             nfs_fh4         object;
     };

   RESULT

     struct PUTFH4res {
             /* CURRENT_FH: */
             nfsstat4        status;
     };

   DESCRIPTION
```

현재 파일 핸들을 인수로 제공된 파일 핸들로 바꿉니다.

요청자가 사용하는 보안 메커니즘이 이 작업에 제공된 파일 핸들의 요구 사항을 충족하지 않는 경우 서버는 NFS4ERR\_WRONGSEC를 반환해야 합니다.\(MUST\)

```text
   IMPLEMENTATION
```

일반적으로 다음 작업에 대한 컨텍스트를 설정하기 위해 NFS 요청의 첫 번째 연산자로 사용됩니다.

```text
   ERRORS

      NFS4ERR_BADHANDLE
      NFS4ERR_BADXDR
      NFS4ERR_FHEXPIRED
      NFS4ERR_MOVED
      NFS4ERR_RESOURCE
      NFS4ERR_SERVERFAULT
      NFS4ERR_STALE
      NFS4ERR_WRONGSEC
```

---
#### **14.2.21.  Operation 23: PUTPUBFH - Set Public Filehandle**

```text
   SYNOPSIS

     - -> (cfh)

   ARGUMENT

     void;

   RESULT

     struct PUTPUBFH4res {
             /* CURRENT_FH: public fh */
             nfsstat4        status;
     };

   DESCRIPTION
```

현재 파일 핸들을 서버 네임스페이스의 공용 파일 핸들을 나타내는 파일 핸들로 바꿉니다. 이 파일 핸들은 서버의 다른 디렉터리와 연결될 수 있는 "루트" 파일 핸들과 다를 수 있습니다.

공개 파일 핸들은 \[RFC2054\], \[RFC2055\], \[RFC2224\]에 구현된 개념을 나타냅니다. NFS 버전 4의 목적은 공용 파일 핸들\(PUTPUBFH 작업으로 표시됨\)을 NFS 버전 2 및 3과 WebNFS 서버 호환성을 제공하는 방법으로 사용하는 것입니다.

공용 파일 핸들과 루트 파일 핸들\(PUTROOTFH 작업으로 표시됨\)은 동일해야 합니다. 공용 파일 핸들과 루트 파일 핸들이 동일하지 않으면 공용 파일 핸들은 루트 파일 핸들의 자손이어야 합니다.\(MUST\)

```text
   IMPLEMENTATION
```

다음 작업에 대한 컨텍스트를 설정하기 위해 NFS 요청의 첫 번째 연산자로 사용됩니다.

NFS 버전 2 및 3 공용 파일 핸들을 사용하면 클라이언트는 LOOKUP에 제공된 경로 이름을 서버 루트에 대한 절대 경로 또는 공용 파일 핸들에 대한 상대 경로로 평가해야 하는지 여부를 지정할 수 있습니다. \[RFC2224\]에는 기능에 대한 추가 논의가 포함되어 있습니다. NFS 버전 4에서는 해당 유형의 사양을 LOOKUP 작업에서 직접 사용할 수 없습니다. 그 이유는 NFS 버전 4에서는 절대 대 상대를 지정하는 데 필요한 구성 요소 구분 기호가 허용되지 않기 때문입니다.

클라이언트는 PUTROOTFH 또는 PUTPUBFH를 사용하여 각각 NFS URL의 절대 또는 상대 평가를 나타내도록 요청을 구성할 책임이 있습니다.

\[RFC2224\]에는 절대 평가 사용과 사용 가능한 네임스페이스의 양과 관련하여 서버가 해당 평가에 적용할 수 있는 제한과 관련하여 언급된 경고가 있습니다. 이와 동일한 경고가 NFS 버전 4에도 적용됩니다. 따라서 서버 구현 세부 사항으로 인해 NFS 버전 3 절대 공용 파일 핸들 조회가 NFS 버전 4 절대 확인과 다르게 동작할 수 있습니다.

SNEGO를 사용하는 방법으로 공용 파일 핸들을 사용하는 \[RFC2755\]에 설명된 보안 협상 형식이 있습니다. 파일 핸들은 특별한 의미로 오버로드되지 않고 따라서 NFS 버전 2 및 3과 동일한 프레임워크를 제공하지 않으므로 NFS 버전 4에서는 이 방법을 사용할 수 없습니다. 따라서 클라이언트는 이 RFC에 설명된 보안 협상 메커니즘을 사용해야 합니다.

```text
   ERRORS

      NFS4ERR_RESOURCE
      NFS4ERR_SERVERFAULT
      NFS4ERR_WRONGSEC
```

---
#### **14.2.22.  Operation 24: PUTROOTFH - Set Root Filehandle**

```text
   SYNOPSIS

     - -> (cfh)

   ARGUMENT

     void;

   RESULT

     struct PUTROOTFH4res {
             /* CURRENT_FH: root fh */
             nfsstat4        status;
     };

   DESCRIPTION
```

현재 파일 핸들을 서버 네임스페이스의 루트를 나타내는 파일 핸들로 바꿉니다. 이 파일 핸들에서 LOOKUP 작업은 서버의 다른 파일 핸들을 찾을 수 있습니다. 이 파일 핸들은 서버의 다른 디렉토리와 연결될 수 있는 "공용" 파일 핸들과 다를 수 있습니다.

```text
   IMPLEMENTATION
```

일반적으로 다음 작업에 대한 컨텍스트를 설정하기 위해 NFS 요청의 첫 번째 연산자로 사용됩니다.

```text
   ERRORS

      NFS4ERR_RESOURCE
      NFS4ERR_SERVERFAULT
      NFS4ERR_WRONGSEC
```

---
#### **14.2.23.  Operation 25: READ - Read from File**

```text
   SYNOPSIS

     (cfh), stateid, offset, count -> eof, data

   ARGUMENT

     struct READ4args {
             /* CURRENT_FH: file */
             stateid4        stateid;
             offset4         offset;
             count4          count;
     };

   RESULT

     struct READ4resok {
             bool            eof;
             opaque          data<>;
     };

     union READ4res switch (nfsstat4 status) {
      case NFS4_OK:
              READ4resok     resok4;
      default:
              void;
     };

   DESCRIPTION
```

READ 작업은 현재 파일 핸들로 식별되는 일반 파일에서 데이터를 읽습니다.

클라이언트는 READ가 시작될 위치의 오프셋과 읽을 바이트 수를 제공합니다. 오프셋 0\(영\)은 파일의 시작 부분부터 데이터를 읽는다는 의미입니다. 오프셋이 파일 크기보다 크거나 같은 경우 상태 NFS4\_OK는 데이터 길이가 0\(영\)으로 설정되고 eof가 TRUE로 설정되어 반환됩니다. READ에는 액세스 권한 검사가 적용됩니다.

클라이언트가 카운트 값을 0\(영\)으로 지정하면 READ가 성공하고 액세스 권한 검사에 따라 0\(영\) 바이트의 데이터를 다시 반환합니다. 서버는 클라이언트가 지정한 것보다 적은 바이트를 반환하도록 선택할 수 있습니다. 클라이언트는 이 조건을 확인하고 적절하게 처리해야 합니다.

READ 요청의 stateid 값은 이전 레코드 잠금 또는 공유 예약 요청에서 반환된 값을 나타냅니다. stateid는 서버에서 관련 공유 예약 및 레코드 잠금이 여전히 유효한지 확인하고 클라이언트에 대한 임대 시간 제한을 업데이트하는 데 사용됩니다.

파일 끝에서 읽기가 종료되거나\(공식적으로 올바른 형식의 READ 요청에서 오프셋 + 개수가 파일 크기와 같은 경우\) 읽기 요청이 파일 크기를 초과하는 경우\(오프셋 + 개수가 있는 경우\) count가 파일 크기보다 큰 경우\) eof는 TRUE로 반환됩니다. 그렇지 않으면 FALSE입니다. 빈 파일을 성공적으로 읽으면 eof가 항상 TRUE로 반환됩니다.

현재 파일 핸들이 일반 파일이 아닌 경우 클라이언트에 오류가 반환됩니다. 현재 파일 핸들이 디렉터리를 나타내는 경우 NFS4ERR\_ISDIR이 반환됩니다. 그렇지 않으면 NFS4ERR\_INVAL이 반환됩니다.

stateid 값이 모두 0인 READ의 경우, 서버는 파일에 대한 필수 파일 잠금 또는 현재 공유 거부 모드에 따라 READ가 서비스되도록 허용할 수 있습니다. stateid 값이 모두 1인 READ의 경우, 서버는 READ 작업이 서버의 잠금 검사를 우회하도록 허용할 수 있습니다.\(MAY, MAY\)

성공하면 현재 파일 핸들이 해당 값을 유지합니다.

```text
   IMPLEMENTATION
```

서버가 count 바이트보다 적은 데이터를 반환할 수도 있습니다. 서버가 요청한 개수보다 적은 수를 반환하고 eof가 FALSE로 설정된 경우 클라이언트는 나머지 데이터를 가져오기 위해 또 다른 READ를 실행해야 합니다. 서버는 여러 상황에서 요청한 것보다 적은 양의 데이터를 반환할 수 있습니다. 다른 클라이언트나 서버 자체에서 파일이 잘려서 요청 클라이언트가 생각하는 파일 크기가 변경되었을 수 있습니다. 이렇게 하면 클라이언트가 사용할 수 있는 실제 데이터 양이 줄어듭니다. 서버가 전송 크기를 줄이고 읽기 요청 반환을 줄일 수도 있습니다. 더 작은 읽기 반환이 필요한 서버 리소스 고갈이 발생할 수도 있습니다.

파일에 대해 필수 파일 잠금이 켜져 있고 파일에서 읽을 데이터에 해당하는 영역이 stateid와 연결되지 않은 소유자에 의해 쓰기 잠긴 경우 서버는 NFS4ERR\_LOCKED 오류를 반환합니다. 클라이언트는 READ를 다시 시도하기 전에 LOCK 작업을 통해 적절한 읽기 레코드 잠금을 얻으려고 시도해야 합니다. READ가 완료되면 클라이언트는 LOCKU를 통해 레코드 잠금을 해제해야 합니다.

```text
   ERRORS

      NFS4ERR_ACCESS
      NFS4ERR_ADMIN_REVOKED
      NFS4ERR_BADHANDLE
      NFS4ERR_BAD_STATEID
      NFS4ERR_BADXDR
      NFS4ERR_DELAY
      NFS4ERR_EXPIRED
      NFS4ERR_FHEXPIRED
      NFS4ERR_GRACE
      NFS4ERR_IO
      NFS4ERR_INVAL
      NFS4ERR_ISDIR
      NFS4ERR_LEASE_MOVED
      NFS4ERR_LOCKED
      NFS4ERR_MOVED
      NFS4ERR_NOFILEHANDLE
      NFS4ERR_NXIO
      NFS4ERR_OLD_STATEID
      NFS4ERR_OPENMODE
      NFS4ERR_RESOURCE
      NFS4ERR_SERVERFAULT
      NFS4ERR_STALE
      NFS4ERR_STALE_STATEID
```

---
#### **14.2.24.  Operation 26: READDIR - Read Directory**

```text
   SYNOPSIS
      (cfh), cookie, cookieverf, dircount, maxcount, attr_request ->
      cookieverf { cookie, name, attrs }

   ARGUMENT

     struct READDIR4args {
             /* CURRENT_FH: directory */
             nfs_cookie4     cookie;
             verifier4       cookieverf;
             count4          dircount;
             count4          maxcount;
             bitmap4         attr_request;
     };

   RESULT

     struct entry4 {
             nfs_cookie4     cookie;
             component4      name;
             fattr4          attrs;
             entry4          *nextentry;
     };

     struct dirlist4 {
             entry4          *entries;
             bool            eof;
     };

     struct READDIR4resok {
             verifier4       cookieverf;
             dirlist4        reply;
     };

     union READDIR4res switch (nfsstat4 status) {
      case NFS4_OK:
              READDIR4resok  resok4;
      default:
              void;
     };

   DESCRIPTION
```

READDIR 작업은 파일 시스템 디렉터리에서 다양한 수의 항목을 검색하고 클라이언트가 후속 READDIR에서 추가 디렉터리 항목을 요청할 수 있도록 정보와 함께 각 항목에 대해 클라이언트가 요청한 속성을 반환합니다.

인수에는 디렉터리 내에서 READDIR이 시작되어야 하는 위치를 나타내는 쿠키 값이 포함되어 있습니다. 쿠키 값 0\(영\)은 디렉터리 시작 부분에서 읽기를 시작하는 데 사용됩니다. 후속 READDIR 요청의 경우 클라이언트는 이전 READDIR 요청에서 서버가 제공한 쿠키 값을 지정합니다.

cookieverf 값은 쿠키 값이 0\(영\)\(첫 번째 디렉터리 읽기\)인 경우 0\(영\)으로 설정되어야 합니다. 후속 요청에서는 서버가 반환한 cookieverf여야 합니다. cookieverf는 쿠키를 획득한 READDIR에서 반환한 것과 일치해야 합니다. 서버가 cookieverf가 더 이상 해당 디렉터리에 유효하지 않다고 판단하면 NFS4ERR\_NOT\_SAME 오류가 반환되어야 합니다.

인수의 dircount 부분은 반환되어야 하는 디렉터리 정보의 최대 바이트 수에 대한 힌트입니다. 이 값은 디렉터리 항목 이름의 길이와 해당 항목의 쿠키 값을 나타냅니다. 이 길이는 서버의 기본 형식의 길이가 아니라 데이터\(이름 및 쿠키\)의 XDR 인코딩을 나타냅니다.

인수의 maxcount 값은 결과의 최대 바이트 수입니다. 이 최대 크기는 READDIR4resok 구조 내에서 반환되는 모든 데이터를 나타내며 XDR 오버헤드를 포함합니다. 서버가 더 적은 양의 데이터를 반환할 수 있습니다. 서버가 최대 개수 제한 내에서 단일 디렉터리 항목을 반환할 수 없는 경우 NFS4ERR\_TOOSMALL 오류가 클라이언트에 반환됩니다.

마지막으로 attr\_request는 서버가 제공하는 각 디렉토리 항목에 대해 반환될 속성 목록을 나타냅니다.

성공적으로 반환되면 서버의 응답은 디렉터리 항목 목록을 제공합니다. 이러한 각 항목에는 디렉터리 항목의 이름, 해당 항목의 쿠키 값 및 요청된 관련 속성이 포함되어 있습니다. 디렉토리에 더 이상 항목이 없으면 "eof" 플래그는 TRUE 값을 갖습니다.

쿠키 값은 서버에만 의미가 있으며 디렉터리 항목에 대한 "책갈피"로 사용됩니다. 언급한 대로 이 쿠키는 클라이언트가 후속 READDIR 작업에 사용하여 디렉터리를 계속 읽을 수 있습니다. 쿠키는 개념상 쿠키와 유사합니다.

READ 오프셋이지만 클라이언트가 그렇게 해석하면 안 됩니다. 이상적으로는 클라이언트가 이러한 값을 캐싱할 수 있으므로 디렉터리가 수정되는 경우 쿠키 값이 변경되어서는 안 됩니다.

어떤 경우에는 서버가 디렉토리 항목의 속성을 가져오는 동안 오류가 발생할 수 있습니다. 전체 READDIR 작업에 대해 오류를 반환하는 대신 서버는 'fattr4\_rdattr\_error' 속성을 반환할 수 있습니다. 이를 통해 서버는 클라이언트에 오류를 전달할 수 있으며 일시적 오류가 발생할 수 있는 경우 전체 작업이 실패하지 않도록 할 수 있습니다. 분명히 이 메서드가 제대로 작동하려면 클라이언트가 fattr4\_rdattr\_error 속성을 요청해야 합니다. 클라이언트가 속성을 요청하지 않으면 서버는 전체 READDIR 작업에 대해 실패를 반환할 수밖에 없습니다.

일부 파일 시스템 환경의 경우 디렉토리 항목 "." 및 ".."은 특별한 의미를 가지며 다른 환경에서는 그렇지 않을 수도 있습니다. 서버가 디렉터리 내에서 이러한 특수 항목을 지원하는 경우 해당 항목이 READDIR 응답의 일부로 클라이언트에 반환되어서는 안 됩니다. 일부 클라이언트 환경을 활성화하려면 쿠키 값 0, 1, 2가 예약된 것으로 간주됩니다. UNIX 클라이언트는 서버의 응답과 로컬 표현을 결합하여 응용 프로그램에 대한 완전한 형식의 UNIX 디렉터리 표현을 활성화할 때 이러한 값을 사용합니다.

READDIR 인수의 경우 쿠키 값 1과 2를 사용하면 안 되며, READDIR 결과의 경우 쿠키 값 0, 1, 2가 반환되어서는 안 됩니다.

성공하면 현재 파일 핸들이 해당 값을 유지합니다.

```text
   IMPLEMENTATION
```

서버의 파일 시스템 디렉토리 표현은 크게 다를 수 있습니다. 클라이언트의 프로그래밍 인터페이스는 NFS 프로토콜로 제대로 변환되지 않는 방식으로 로컬 운영 환경에 바인딩될 수도 있습니다. 따라서 클라이언트가 서버에 지침을 제공할 수 있도록 dircount 및 maxcount 필드의 사용이 제공됩니다. 클라이언트가 READDIR 중에 속성 수집에 적극적이라면 서버는 인코딩된 응답을 제한하는 방법에 대한 아이디어를 가지고 있습니다. dircount 필드는 디렉토리 항목 이름만을 기준으로 항목 수에 대한 힌트를 제공합니다. 힌트이므로 dircount 값이 0일 수도 있습니다. 이 경우 서버는 dircount 값을 무시하고 지정된 maxcount 값을 기반으로 디렉터리 정보를 반환할 수 있습니다.

cookieverf는 오래될 수 있는 쿠키 값을 관리하는 데 도움을 주기 위해 서버에서 사용될 수 있습니다. 서버가 제공된 쿠키/쿠키버프 쌍을 사용하여 디렉터리를 계속해서 올바르게 읽을 수 없는 경우는 거의 발생하지 않습니다. 클라이언트의 애플리케이션이 이러한 유형의 오류를 적절하게 처리하지 못할 수 있으므로 서버는 이 상황을 피하기 위해 모든 노력을 기울여야 합니다.

cookieverf를 사용하면 클라이언트가 오래되었을 수 있는 READDIR 쿠키 값을 사용하지 못하도록 보호할 수도 있습니다. 예를 들어 파일 시스템이 마이그레이션된 경우 서버는 이전 서버에서 사용했던 것과 동일한 쿠키 값을 사용하여 READDIR을 서비스할 수도 있고 그렇지 않을 수도 있습니다. 클라이언트가 cookieverf를 제공하면 서버는 클라이언트에 적절한 응답을 제공할 수 있습니다. 이렇게 하면 서버가 쿠키 값을 수락할 수 있지만 기본 디렉터리가 변경되어 이전 READDIR의 클라이언트 컨텍스트에서 응답이 유효하지 않은 경우가 방지됩니다.

일부 서버는 "."을 반환하지 않기 때문에 및 ".." 항목은 이전 버전의 NFS 프로토콜에서 수행된 것처럼 READDIR 응답에 이러한 항목이 있어야 하는 클라이언트가 해당 항목을 조작해야 합니다.

```text
   ERRORS

      NFS4ERR_ACCESS
      NFS4ERR_BADHANDLE
      NFS4ERR_BAD_COOKIE
      NFS4ERR_BADXDR
      NFS4ERR_DELAY
      NFS4ERR_FHEXPIRED
      NFS4ERR_INVAL
      NFS4ERR_IO
      NFS4ERR_MOVED
      NFS4ERR_NOFILEHANDLE
      NFS4ERR_NOTDIR
      NFS4ERR_RESOURCE
      NFS4ERR_SERVERFAULT
      NFS4ERR_STALE
      NFS4ERR_TOOSMALL
```

---
#### **14.2.25.  Operation 27: READLINK - Read Symbolic Link**

```text
   SYNOPSIS

     (cfh) -> linktext

   ARGUMENT

     /* CURRENT_FH: symlink */
     void;

   RESULT

     struct READLINK4resok {
             linktext4       link;
     };

     union READLINK4res switch (nfsstat4 status) {
      case NFS4_OK:
              READLINK4resok resok4;
      default:
              void;
     };

   DESCRIPTION
```

READLINK는 심볼릭 링크와 관련된 데이터를 읽습니다. 데이터는 서버에 불투명한 UTF-8 문자열입니다. 즉, NFS 클라이언트에 의해 생성되거나 서버에서 로컬로 생성되는 경우 기호 링크의 데이터는 생성 시 해석되지 않고 단순히 저장됩니다.

성공하면 현재 파일 핸들이 해당 값을 유지합니다.

```text
   IMPLEMENTATION
```

심볼릭 링크는 명목상 다른 파일에 대한 포인터입니다. 데이터는 반드시 서버에 의해 해석되는 것은 아니며 단지 파일에 저장됩니다. 클라이언트 구현에서는 서버 운영 체제에 의미가 없는 경로 이름을 기호 링크에 저장할 수 있습니다. READLINK 작업은 해석을 위해 데이터를 클라이언트에 반환합니다. 서로 다른 구현이 기호 링크에 대한 액세스를 공유하려는 경우 기호 링크의 데이터 해석에 동의해야 합니다.

READLINK 작업은 NF4LNK 유형의 개체에만 허용됩니다. 개체가 NF4LNK 유형이 아닌 경우 서버는 NFS4ERR\_INVAL 오류를 반환해야 합니다.

```text
   ERRORS

      NFS4ERR_ACCESS
      NFS4ERR_BADHANDLE
      NFS4ERR_DELAY

      NFS4ERR_FHEXPIRED
      NFS4ERR_INVAL
      NFS4ERR_IO
      NFS4ERR_ISDIR
      NFS4ERR_MOVED
      NFS4ERR_NOFILEHANDLE
      NFS4ERR_NOTSUPP
      NFS4ERR_RESOURCE
      NFS4ERR_SERVERFAULT
      NFS4ERR_STALE
```

---
#### **14.2.26.  Operation 28: REMOVE - Remove Filesystem Object**

```text
   SYNOPSIS

     (cfh), filename -> change_info

   ARGUMENT

     struct REMOVE4args {
             /* CURRENT_FH: directory */
             component4       target;
     };

   RESULT

     struct REMOVE4resok {
             change_info4    cinfo;
     }

     union REMOVE4res switch (nfsstat4 status) {
      case NFS4_OK:
              REMOVE4resok   resok4;
      default:
              void;
     }

   DESCRIPTION
```

REMOVE 작업은 현재 파일 핸들에 해당하는 디렉터리에서 filename이라는 디렉터리 항목을 제거\(삭제\)합니다. 디렉토리의 항목이 해당 파일 시스템 개체에 대한 마지막 참조인 경우 개체가 삭제될 수 있습니다.

파일 이름이 제거된 디렉터리에 대해 서버는 cinfo에change\_info4 정보를 반환합니다. Change\_info4 구조체의 원자 필드를 사용하면 서버는 제거와 관련하여 변경 전후 속성이 원자적으로 획득되었는지 여부를 나타냅니다.

대상의 길이가 0\(영\)이거나 대상이 UTF-8 정의를 따르지 않는 경우 NFS4ERR\_INVAL 오류가 반환됩니다.

성공하면 현재 파일 핸들이 해당 값을 유지합니다.

```text
   IMPLEMENTATION
```

NFS 버전 2와 3에서는 디렉터리 제거를 위해 다른 연산자 RMDIR이 필요하고 디렉터리가 아닌 제거를 위해 REMOVE가 필요했습니다. 이를 통해 클라이언트는 디렉토리를 제거하기 위해 디렉토리가 아닌 삭제 시스템 호출\(예: POSIX의 unlink\(\)\)이 전달될 때 파일 형식 확인을 건너뛸 수 있을 뿐만 아니라 그 반대의 경우\(예: 디렉토리가 없는 시스템의 rmdir\(\)\) 확인을 건너뛸 수 있습니다. \) 서버가 파일 형식을 확인할 것이라는 것을 알았기 때문입니다. NFS 버전 4 REMOVE는 파일 유형에 관계없이 모든 디렉토리 항목을 삭제하는 데 사용할 수 있습니다. unlink\(\) 및 rmdir\(\) 시스템 호출의 NFS 버전 4 클라이언트 진입점 구현자는 먼저 REMOVE를 실행하기 전에 시스템 호출이 제거할 수 있는 유형에 대해 파일 유형을 확인해야 합니다. 또는 구현자는 동일한 COMPOUND 호출에서 REMOVE 작업 전에 파일 형식을 확인하기 위해 LOOKUP/VERIFY 시퀀스를 포함하는 COMPOUND 호출을 생성할 수 있습니다.

마지막 참조의 개념은 서버마다 다릅니다. 그러나 객체의 이전 속성에 있는 numlinks 필드의 값이 1인 경우 클라이언트는 파일 핸들을 통해 객체를 참조하는 데 의존해서는 안 됩니다. 마찬가지로 클라이언트는 즉시 사용할 수 있게 되는 개체와 이전에 연결되었던 리소스\(디스크 공간, 디렉터리 항목 등\)에 의존해서는 안 됩니다. 따라서 클라이언트가 REMOVE를 사용하여 파일을 제거한 후에도 파일에 계속 액세스할 수 있어야 하는 경우 클라이언트는 파일에 계속 액세스할 수 있는지 확인하기 위한 조치를 취해야 합니다. 사용되는 일반적인 메커니즘은 파일의 이름을 이전 이름에서 새로운 숨겨진 이름으로 바꾸는 것입니다.

REMOVE 명령이 도착했을 때 서버에서 파일이 아직 열려 있는 것을 발견한 경우:

o 파일이 OPEN4\_SHARE\_DENY\_WRITE 또는 OPEN4\_SHARE\_DENY\_BOTH로 열린 경우 서버는 파일의 디렉터리 항목을 삭제해서는 안 됩니다.\(SHOULD NOT\)

o 파일이 OPEN4\_SHARE\_DENY\_WRITE로 열리지 않았거나

- OPEN4\_SHARE\_DENY\_BOTH, 서버는 파일의 디렉터리 항목을 삭제해야 합니다. 그러나 파일의 마지막 CLOSE까지 서버는 파일 핸들을 통해 파일에 대한 액세스를 계속 허용할 수 있습니다.\(SHOULD, MAY\)

```text
   ERRORS

      NFS4ERR_ACCESS
      NFS4ERR_BADCHAR
      NFS4ERR_BADHANDLE
      NFS4ERR_BADNAME
      NFS4ERR_BADXDR
      NFS4ERR_DELAY
      NFS4ERR_FHEXPIRED
      NFS4ERR_FILE_OPEN
      NFS4ERR_INVAL
      NFS4ERR_IO
      NFS4ERR_MOVED
      NFS4ERR_NAMETOOLONG
      NFS4ERR_NOENT
      NFS4ERR_NOFILEHANDLE
      NFS4ERR_NOTDIR
      NFS4ERR_NOTEMPTY
      NFS4ERR_RESOURCE
      NFS4ERR_ROFS
      NFS4ERR_SERVERFAULT
      NFS4ERR_STALE
```

---
#### **14.2.27.  Operation 29: RENAME - Rename Directory Entry**

```text
   SYNOPSIS

     (sfh), oldname, (cfh), newname -> source_change_info,
     target_change_info

   ARGUMENT

     struct RENAME4args {
             /* SAVED_FH: source directory */
             component4      oldname;
             /* CURRENT_FH: target directory */
             component4      newname;
     };

   RESULT

     struct RENAME4resok {
             change_info4    source_cinfo;
             change_info4    target_cinfo;
     };

     union RENAME4res switch (nfsstat4 status) {
      case NFS4_OK:
              RENAME4resok   resok4;
      default:
              void;
     };

   DESCRIPTION
```

RENAME 작업은 SAVEFH 작업에 의해 설정된 저장된 파일 핸들에 해당하는 소스 디렉터리에서 oldname으로 식별된 개체의 이름을 현재 파일 핸들에 해당하는 대상 디렉터리의 newname으로 바꿉니다. 작업은 클라이언트에 대해 원자적이어야 합니다. 소스 및 대상 디렉터리는 서버의 동일한 파일 시스템에 있어야 합니다. 성공하면 현재 파일 핸들이 계속 대상 디렉터리가 됩니다.

대상 디렉터리에 newname이라는 이름의 항목이 이미 포함되어 있는 경우 소스 객체는 대상과 호환되어야 합니다. 둘 다 디렉터리가 아니거나 둘 다 디렉터리이고 대상은 비어 있어야 합니다. 호환되는 경우 이름 바꾸기가 발생하기 전에 기존 대상이 제거됩니다\(대상이 제거될 때마다 클라이언트 및 서버 작업에 대해서는 "작업 28: REMOVE - 파일 시스템 개체 제거" 섹션의 IMPLEMENTATION 하위 섹션을 참조하세요\). 호환되지 않거나 대상이 디렉터리이지만 비어 있지 않은 경우 서버는 NFS4ERR\_EXIST 오류를 반환합니다.

oldname과 newname이 모두 동일한 파일을 참조하는 경우\(서로의 하드 링크일 수 있음\) RENAME은 아무 작업도 수행하지 않고 성공을 반환해야 합니다.

RENAME과 관련된 두 디렉터리 모두에 대해 서버는change\_info4 정보를 반환합니다. Change\_info4 구조체의 원자 필드를 사용하면 서버는 이름 바꾸기와 관련하여 변경 전후 속성이 원자적으로 획득되었는지 여부를 나타냅니다.

이전 이름이 명명된 속성을 참조하고 저장된 파일 핸들과 현재 파일 핸들이 다른 파일 시스템 개체를 참조하는 경우 서버는 마치 저장된 파일 핸들과 현재 파일 핸들이 다른 파일 시스템의 디렉터리를 나타내는 것처럼 NFS4ERR\_XDEV를 반환합니다.

oldname 또는 newname의 길이가 0\(영\)이거나 oldname 또는 newname이 UTF-8 정의를 따르지 않는 경우 NFS4ERR\_INVAL 오류가 반환됩니다.

```text
   IMPLEMENTATION
```

RENAME 작업은 클라이언트에 대해 원자적이어야 합니다. "소스 및 대상 디렉토리는 서버의 동일한 파일 시스템에 있어야 합니다"라는 설명은 디렉토리 속성의 fsid 필드가 동일함을 의미합니다. 서로 다른 파일 시스템에 있는 경우 NFS4ERR\_XDEV 오류가 반환됩니다.

객체의 fh\_expire\_type 속성 값에 따라 파일 핸들은 RENAME 시 만료되거나 만료되지 않을 수 있습니다. 그러나 서버 구현자는 이러한 방식으로 파일 핸들이 만료되지 않도록 시도하는 것이 좋습니다.

일부 서버에서는 파일 이름이 "." 및 ".."는 oldname이나 newname에 적합하지 않으며 NFS4ERR\_BADNAME 오류가 발생합니다. 또한 많은 서버에서 oldname 또는 newname이 소스 디렉토리의 별칭인 경우가 확인됩니다. 이러한 경우 이러한 서버는 NFS4ERR\_INVAL 오류를 반환합니다.

소스 또는 대상 파일 핸들 중 하나가 디렉터리가 아닌 경우 서버는 NFS4ERR\_NOTDIR을 반환합니다.

```text
   ERRORS

      NFS4ERR_ACCESS
      NFS4ERR_BADCHAR
      NFS4ERR_BADHANDLE
      NFS4ERR_BADNAME
      NFS4ERR_BADXDR
      NFS4ERR_DELAY
      NFS4ERR_DQUOT
      NFS4ERR_EXIST
      NFS4ERR_FHEXPIRED
      NFS4ERR_FILE_OPEN
      NFS4ERR_INVAL
      NFS4ERR_IO
      NFS4ERR_MOVED
      NFS4ERR_NAMETOOLONG
      NFS4ERR_NOENT
      NFS4ERR_NOFILEHANDLE
      NFS4ERR_NOSPC
      NFS4ERR_NOTDIR
      NFS4ERR_NOTEMPTY
      NFS4ERR_RESOURCE

      NFS4ERR_ROFS
      NFS4ERR_SERVERFAULT
      NFS4ERR_STALE
      NFS4ERR_WRONGSEC
      NFS4ERR_XDEV
```

---
#### **14.2.28.  Operation 30: RENEW - Renew a Lease**

```text
   SYNOPSIS

     clientid -> ()

   ARGUMENT

     struct RENEW4args {
             clientid4       clientid;
     };

   RESULT

     struct RENEW4res {
             nfsstat4        status;
     };

   DESCRIPTION
```

RENEW 작업은 클라이언트가 현재 서버에 보유하고 있는 임대를 갱신하는 데 사용됩니다. RENEW 요청을 처리할 때 서버는 클라이언트와 관련된 모든 임대를 갱신합니다. 연관된 임대는 SETCLIENTID 작업을 통해 제공된 clientid에 의해 결정됩니다.

```text
   IMPLEMENTATION
```

클라이언트가 위임을 보유한 경우 RENEW를 사용하여 서버가 콜백 경로가 다운되었다고 판단한 시기를 감지해야 합니다. 서버가 그러한 결정을 내리면 RENEW 작업만 위임에 대한 임대를 갱신합니다. 서버는 콜백 경로가 다운되었다고 판단하면 NFS4ERR\_CB\_PATH\_DOWN을 반환합니다. NFS4ERR\_CB\_PATH\_DOWN을 반환하더라도 서버는 클라이언트가 서버에 설정한 레코드 잠금 및 공유 예약에 대한 임대를 갱신해야 합니다. 어떤 이유로 잠금 및 공유 예약 임대를 갱신할 수 없는 경우 콜백 경로도 다운된 경우에도 서버는 NFS4ERR\_CB\_PATH\_DOWN 이외의 오류를 반환해야 합니다.\(MUST, MUST\)

RENEW를 발행하는 클라이언트는 주체, RPC 보안 특성, 그리고 해당되는 경우 다음 알고리즘 중 하나를 통해 GSS-API 메커니즘 및 서비스를 선택해야 합니다.\(MUST\)

o 클라이언트는 동일한 주체인 RPC 보안 특성을 사용합니다. 그리고 특성이 RPCSEC\_GSS인 경우 클라이언트 ID가 SETCLIENTID\_CONFIRM을 통해 설정될 때 사용된 것과 동일한 메커니즘 및 서비스를 사용합니다.

o 클라이언트는 현재 서버에 OPEN 파일이 있는 모든 주체, RPC 보안 방식 메커니즘 및 서비스 조합을 사용합니다. 즉, 동일한 주체가 성공적인 OPEN 작업을 수행했고 파일은 해당 주체에 의해 여전히 열려 있으며 RENEW의 특징, 메커니즘 및 서비스는 이전 OPEN과 일치합니다.

서버는 앞서 언급한 알고리즘 중 하나를 사용하지 않는 RENEW를 NFS4ERR\_ACCESS 오류와 함께 거부해야 합니다.\(MUST\)

```text
   ERRORS

      NFS4ERR_ACCESS
      NFS4ERR_ADMIN_REVOKED
      NFS4ERR_BADXDR
      NFS4ERR_CB_PATH_DOWN
      NFS4ERR_EXPIRED
      NFS4ERR_LEASE_MOVED
      NFS4ERR_RESOURCE
      NFS4ERR_SERVERFAULT
      NFS4ERR_STALE_CLIENTID
```

---
#### **14.2.29.  Operation 31: RESTOREFH - Restore Saved Filehandle**

```text
   SYNOPSIS

     (sfh) -> (cfh)

   ARGUMENT

     /* SAVED_FH: */
     void;

   RESULT

     struct RESTOREFH4res {
             /* CURRENT_FH: value of saved fh */
             nfsstat4        status;
     };

   DESCRIPTION
```

현재 파일 핸들을 저장된 파일 핸들의 값으로 설정합니다. 저장된 파일 핸들이 없으면 NFS4ERR\_RESTOREFH 오류를 반환합니다.

```text
   IMPLEMENTATION
```

OPEN 및 LOOKUP과 같은 작업은 현재 파일 핸들을 사용하여 디렉터리를 나타내고 이를 새 파일 핸들로 바꿉니다. 이전 파일 핸들이 SAVEFH 연산자로 저장되었다고 가정하면 이전 파일 핸들을 현재 파일 핸들로 복원할 수 있습니다. 이는 일반적으로 디렉토리에 대한 사후 작업 속성을 얻는 데 사용됩니다.

```text
         PUTFH (directory filehandle)
         SAVEFH
         GETATTR attrbits     (pre-op dir attrs)
         CREATE optbits "foo" attrs
         GETATTR attrbits     (file attributes)
         RESTOREFH
         GETATTR attrbits     (post-op dir attrs)

   ERRORS

      NFS4ERR_BADHANDLE
      NFS4ERR_FHEXPIRED
      NFS4ERR_MOVED
      NFS4ERR_RESOURCE
      NFS4ERR_RESTOREFH
      NFS4ERR_SERVERFAULT
      NFS4ERR_STALE
      NFS4ERR_WRONGSEC
```

---
#### **14.2.30.  Operation 32: SAVEFH - Save Current Filehandle**

```text
   SYNOPSIS

     (cfh) -> (sfh)

   ARGUMENT

     /* CURRENT_FH: */
     void;

   RESULT

     struct SAVEFH4res {
             /* SAVED_FH: value of current fh */
             nfsstat4        status;
     };

   DESCRIPTION
```

현재 파일 핸들을 저장합니다. 이전 파일 핸들이 저장된 경우 더 이상 액세스할 수 없습니다. 저장된 파일 핸들은 RESTOREFH 연산자를 사용하여 현재 파일 핸들로 복원할 수 있습니다.

성공하면 현재 파일 핸들이 해당 값을 유지합니다.

```text
   IMPLEMENTATION

   ERRORS

      NFS4ERR_BADHANDLE
      NFS4ERR_FHEXPIRED
      NFS4ERR_MOVED
      NFS4ERR_NOFILEHANDLE
      NFS4ERR_RESOURCE
      NFS4ERR_SERVERFAULT
      NFS4ERR_STALE
```

---
#### **14.2.31.  Operation 33: SECINFO - Obtain Available Security**

```text
   SYNOPSIS

     (cfh), name -> { secinfo }

   ARGUMENT

     struct SECINFO4args {
             /* CURRENT_FH: directory */
             component4     name;
     };

   RESULT

     enum rpc_gss_svc_t {/* From RFC 2203 */
             RPC_GSS_SVC_NONE        = 1,
             RPC_GSS_SVC_INTEGRITY   = 2,
             RPC_GSS_SVC_PRIVACY     = 3
     };

     struct rpcsec_gss_info {
             sec_oid4        oid;
             qop4            qop;
             rpc_gss_svc_t   service;
     };

     union secinfo4 switch (uint32_t flavor) {
      case RPCSEC_GSS:
              rpcsec_gss_info        flavor_info;
      default:
              void;
     };

     typedef secinfo4 SECINFO4resok<>;

     union SECINFO4res switch (nfsstat4 status) {
      case NFS4_OK:
              SECINFO4resok resok4;
      default:
              void;
     };

   DESCRIPTION
```

SECINFO 작업은 클라이언트가 특정 디렉터리 파일 핸들, 파일 이름 쌍에 대한 유효한 RPC 인증 특성 목록을 얻는 데 사용됩니다. SECINFO는 이름을 평가할 때 LOOKUP에 사용되는 것과 동일한 액세스 방법을 적용해야 합니다. 따라서 요청자가 이름 LOOKUP에 대한 적절한 액세스 권한이 없는 경우 SECINFO는 동일한 방식으로 작동하고 NFS4ERR\_ACCESS를 반환해야 합니다.

결과에는 서버의 기본 설정에 해당하는 순서와 함께 사용 가능한 보안 메커니즘을 나타내는 배열이 포함됩니다. 가장 선호되는 항목은 배열의 첫 번째 항목입니다. 클라이언트는 원하고 지원하는 보안 메커니즘을 자유롭게 선택하거나 서버가 지원하는 첫 번째 기본 설정 순서를 선택할 수 있습니다. 배열 항목은 secinfo4 구조로 표시됩니다. 'flavor' 필드에는 AUTH\_NONE, AUTH\_SYS\(\[RFC1831\]에 정의됨\) 또는 RPCSEC\_GSS\(\[RFC2203\]에 정의됨\) 값이 포함됩니다.

AUTH\_NONE 및 AUTH\_SYS 버전의 경우 추가 보안 정보가 반환되지 않습니다. RPCSEC\_GSS 반환 값의 경우 메커니즘 객체 ID\(\[RFC2743\]에 정의됨\), 보호 품질\(\[RFC2743\]에 정의됨\) 및 서비스 유형\(\[RFC2203\]에 정의됨\)을 포함하는 보안 트리플이 반환됩니다. \). SECINFO는 서로 다른 보안 트리플 값을 사용하여 RPCSEC\_GSS와 동일한 특징을 가진 여러 항목을 반환할 수 있습니다.

성공하면 현재 파일 핸들이 해당 값을 유지합니다.

이름의 길이가 0\(영\)이거나 이름이 UTF-8 정의를 따르지 않으면 NFS4ERR\_INVAL 오류가 반환됩니다.

```text
   IMPLEMENTATION
```

SECINFO 작업은 NFS4ERR\_WRONGSEC의 오류 값이 다른 NFS 작업에서 반환될 때 NFS 클라이언트에서 사용될 것으로 예상됩니다. 이는 서버의 보안 정책이 클라이언트가 현재 사용하고 있는 것과 다르다는 것을 클라이언트에게 나타냅니다. 이 시점에서 클라이언트는 가능한 보안 종류 목록을 얻고 해당 정책에 가장 적합한 것을 선택해야 합니다.

언급한 대로 서버의 보안 정책은 클라이언트 요청이 NFS4ERR\_WRONGSEC를 수신하는 시기를 결정합니다. 이 오류를 수신할 수 있는 작업은 LINK, LOOKUP, OPEN, PUTFH, PUTPUBFH, PUTROOTFH, RESTOREFH, RENAME 및 간접적인 READDIR입니다. LINK 및 RENAME은 작업에 사용된 보안이 저장된 파일 핸들에 적합하지 않은 경우에만 이 오류를 수신합니다. READDIR을 제외하고 이러한 작업은 클라이언트가 파일 핸들을 서버의 "현재 파일 핸들"로 인스턴스화할 수 있는 지점을 나타냅니다. 파일 핸들은 클라이언트에 의해 제공되거나\(PUTFH, PUTPUBFH, PUTROOTFH\) 이름을 파일 핸들로 변환\(LOOKUP 및 OPEN\)한 결과로 생성됩니다. 파일 핸들이 이전 SAVEFH의 결과이기 때문에 RESTOREFH는 다릅니다. RESTOREFH에 대한 파일 핸들이 이전에 서버의 보안 일치 검사를 통과했더라도 서버는 보안 정책이 변경되지 않았는지 확인하기 위해 RESTOREFH에서 이를 다시 확인합니다.

클라이언트가 NFS4ERR\_WRONGSEC의 오류 반환을 해결하려는 경우 다음이 발생합니다.

o LOOKUP 및 OPEN의 경우 클라이언트는 원래 LOOKUP 또는 OPEN에 제공된 것과 동일한 현재 파일 핸들 및 이름으로 SECINFO를 사용하여 사용 가능한 보안 트리플을 열거합니다.

o LINK, PUTFH, RENAME 및 RESTOREFH의 경우 클라이언트는 SECINFO를 사용하고 원래 PUTFH RESTOREFH에서 제공한 파일 핸들 또는 LINK 및 RENAME의 경우 SAVEFH에 해당하는 상위 디렉터리 파일 핸들 및 개체 이름을 제공합니다.

o PUTROOTFH 및 PUTPUBFH의 경우 SECINFO에는 현재 파일 핸들이 필요하고 이 두 작업에 대한 파일 핸들이 없기 때문에 클라이언트는 SECINFO 작업을 사용할 수 없습니다. 따라서 클라이언트는 클라이언트에서 사용 가능한 보안 트리플을 반복하고 PUTROOTFH 또는 PUTPUBFH 작업을 다시 시도해야 합니다. 불행하게도 MANDATORY 보안 트리플 중 어느 것도 지원되지 않습니다.

- 클라이언트와 서버, 클라이언트는 무결성을 지원하는 다른 것을 사용해 봐야 합니다. 실패하면 클라이언트는 AUTH\_NONE을 사용해 볼 수 있지만 이러한 양식에는 무결성 검사가 부족하기 때문에 클라이언트가 위험해질 수 있습니다. 그럼에도 불구하고 서버는 클라이언트가 요청하고 서버가 지원하는 모든 보안 형식을 클라이언트가 사용할 수 있도록 허용해야 합니다. 그렇게 하는 데 따른 위험은 클라이언트에 있기 때문입니다.\(SHOULD, SHOULD\)

READDIR 작업은 NFS4ERR\_WRONGSEC 오류를 직접 반환하지 않습니다. 그러나 READDIR 요청에 속성에 대한 요청이 포함된 경우 READDIR 요청의 보안 트리플이 디렉터리 항목의 보안 트리플과 일치하지 않을 수 있습니다. 이런 경우이고 클라이언트가 rdattr\_error 속성을 요청한 경우 서버는 항목에 대한 rdattr\_error에 NFS4ERR\_WRONGSEC 오류를 반환합니다.

SECINFO에서 사용하는 보안 유형에 대한 권장 사항에 대한 논의는 "보안 고려 사항" 섹션을 참조하세요.

```text
   ERRORS

      NFS4ERR_ACCESS
      NFS4ERR_BADCHAR
      NFS4ERR_BADHANDLE
      NFS4ERR_BADNAME
      NFS4ERR_BADXDR
      NFS4ERR_FHEXPIRED
      NFS4ERR_INVAL
      NFS4ERR_MOVED
      NFS4ERR_NAMETOOLONG
      NFS4ERR_NOENT
      NFS4ERR_NOFILEHANDLE
      NFS4ERR_NOTDIR
      NFS4ERR_RESOURCE
      NFS4ERR_SERVERFAULT
      NFS4ERR_STALE
```

---
#### **14.2.32.  Operation 34: SETATTR - Set Attributes**

```text
   SYNOPSIS

     (cfh), stateid, attrmask, attr_vals -> attrsset

   ARGUMENT

     struct SETATTR4args {
             /* CURRENT_FH: target object */
             stateid4        stateid;
             fattr4          obj_attributes;
     };

   RESULT

     struct SETATTR4res {
             nfsstat4        status;
             bitmap4         attrsset;
     };

   DESCRIPTION
```

SETATTR 작업은 파일 시스템 객체의 속성 중 하나 이상을 변경합니다. 새 속성은 비트맵과 비트순으로 비트맵 뒤에 오는 속성으로 지정됩니다.

SETATTR의 stateid 인수는 크기 속성을 설정하는 SETATTR 요청에 필요한 파일 잠금 컨텍스트를 제공하는 데 사용됩니다. 크기 속성을 설정하면 파일의 데이터가 수정되므로 해당 WRITE와 동일한 잠금 요구 사항이 있습니다. 크기 속성을 설정하는 SETATTR은 DENY\_WRITE를 지정하는 공유 예약과 호환되지 않습니다. 이전 파일 끝과 새 파일 끝 사이의 영역은 해당 영역이 WRITE 대상으로 지정된 경우와 마찬가지로 수정된 것으로 간주됩니다. 서버가 필수 레코드 잠금 동작을 구현하는 경우 레코드 잠금. 항상 유효한 stateid를 지정해야 합니다. 파일 크기 속성이 설정되지 않은 경우 모든 비트가 0으로 구성된 특수 stateid가 전달되어야 합니다.

작업이 성공하거나 실패하면 서버는 attrsset 비트마스크를 반환하여 성공적으로 설정된 속성\(있는 경우\)을 나타냅니다. 응답의 attrsset는 인수의 obj\_attributes의 일부인 bitmap4의 하위 집합입니다.

성공하면 현재 파일 핸들이 해당 값을 유지합니다.

```text
   IMPLEMENTATION
```

요청이 설정할 소유자 속성을 지정하는 경우 서버는 개체의 현재 소유자가 요청에 지정된 값과 일치하는 경우 작업이 성공하도록 허용해야 합니다. 일부 서버는 요청자에게 권한이 없는 한 소유자 속성 설정을 금지하는 방식으로 구현될 수 있습니다. 소유자 값을 일치시키는 이 경우에 서버가 관대하다면, SETATTR이 뒤따르는 객체 생성의 경우 클라이언트 구현이 단순화될 수 있습니다.

파일 크기 속성은 파일 크기 변경을 요청하는 데 사용됩니다. 값이 0\(영\)이면 파일이 잘리고, 값이 현재 파일 크기보다 작으면 데이터가 새 크기에서

파일의 끝이 삭제되고 파일의 현재 크기보다 크기가 크면 논리적으로 0인 데이터 바이트가 파일 끝에 추가됩니다. 서버는 구멍이나 실제 제로 데이터 바이트를 사용하여 이를 자유롭게 구현할 수 있습니다. 클라이언트는 서버의 이 기능 구현과 관련하여 반환된 바이트가 0이 될 것이라는 가정을 해서는 안 됩니다. 서버는 SETATTR을 통해 파일 크기 확장을 지원해야 합니다.

SETATTR은 원자성을 보장하지 않습니다. 실패한 SETATTR은 파일 속성을 부분적으로 변경할 수 있습니다.

SETATTR을 사용하여 파일 크기를 변경하면 time\_modify가 간접적으로 변경됩니다. 크기 변경으로 인해 데이터가 삭제될 수 있으므로 클라이언트는 이를 고려해야 합니다.

time\_access\_set 및 time\_modify\_set 속성은 전환 통합으로 구성된 쓰기 전용 속성이므로 클라이언트가 서버에 시간 값 설정을 지시할 수 있습니다. Switched Union이 SET\_TO\_CLIENT\_TIME4를 지정하는 경우 클라이언트는 작업에 사용할 nfstime4를 제공한 것입니다. 스위치 통합이 SET\_TO\_CLIENT\_TIME4를 지정하지 않으면 서버는 SETATTR 작업에 현재 시간을 사용합니다.

서버 시간과 클라이언트 시간이 다른 경우 클라이언트 시간을 파일 시간과 비교하는 프로그램이 중단될 수 있습니다. 클라이언트/서버 시간 차이를 제한하려면 시간 유지 프로토콜을 사용해야 합니다.

변경 속성만 지정하는 VERIFY 작업이 포함된 COMPOUND를 사용하고 바로 뒤에 SETATTR이 오면 클라이언트가 NFS 버전 3의 SETATTR 가드 메커니즘의 기능을 에뮬레이트하는 요청을 지정할 수 있는 수단을 제공합니다. 메커니즘은 오래된 정보를 기반으로 파일 속성이 변경되는 것을 방지하는 것입니다. 가드 조건 확인과 속성 설정 사이의 지연으로 인해 NFS 버전 4 에뮬레이션의 해당 지연과 마찬가지로 이 기능이 손상될 가능성이 있습니다. 따라서 NFS 버전 4 서버는 이러한 요청을 실행할 때 가능한 한 이러한 지연을 방지하도록 주의해야 합니다.

서버가 클라이언트가 요청한 속성을 지원하지 않는 경우 서버는 NFS4ERR\_ATTRNOTSUPP를 반환해야 합니다.

실제로 설정된 속성의 마스크는 모든 경우에 SETATTR에 의해 반환됩니다. 해당 마스크에는 클라이언트가 설정하도록 요청하지 않은 속성 비트가 포함되어서는 안 되며, SETATTR이 오류 없이 완료되는 경우에만 설정되도록 요청된 속성의 마스크와 동일해야 합니다.

```text
   ERRORS

      NFS4ERR_ACCESS
      NFS4ERR_ADMIN_REVOKED
      NFS4ERR_ATTRNOTSUPP
      NFS4ERR_BADCHAR
      NFS4ERR_BADHANDLE
      NFS4ERR_BADOWNER
      NFS4ERR_BAD_STATEID
      NFS4ERR_BADXDR
      NFS4ERR_DELAY
      NFS4ERR_DQUOT
      NFS4ERR_EXPIRED
      NFS4ERR_FBIG
      NFS4ERR_FHEXPIRED
      NFS4ERR_GRACE
      NFS4ERR_INVAL
      NFS4ERR_IO
      NFS4ERR_ISDIR
      NFS4ERR_LOCKED
      NFS4ERR_MOVED
      NFS4ERR_NOFILEHANDLE
      NFS4ERR_NOSPC
      NFS4ERR_OLD_STATEID
      NFS4ERR_OPENMODE
      NFS4ERR_PERM
      NFS4ERR_RESOURCE
      NFS4ERR_ROFS
      NFS4ERR_SERVERFAULT
      NFS4ERR_STALE
      NFS4ERR_STALE_STATEID
```

---
#### **14.2.33.  Operation 35: SETCLIENTID - Negotiate Clientid**

```text
   SYNOPSIS

     client, callback, callback_ident -> clientid, setclientid_confirm

   ARGUMENT

     struct SETCLIENTID4args {
             nfs_client_id4  client;
             cb_client4      callback;
             uint32_t        callback_ident;
     };

   RESULT

     struct SETCLIENTID4resok {
             clientid4       clientid;
             verifier4       setclientid_confirm;
     };

     union SETCLIENTID4res switch (nfsstat4 status) {
      case NFS4_OK:
              SETCLIENTID4resok      resok4;
      case NFS4ERR_CLID_INUSE:
              clientaddr4    client_using;
      default:
              void;
     };

   DESCRIPTION
```

클라이언트는 SETCLIENTID 작업을 사용하여 서버에 잠금 생성, 공유 예약 및 위임 상태를 수반하는 후속 요청에 대해 특정 클라이언트 식별자, 콜백 및 callback\_ident를 사용하려는 의도를 서버에 알립니다. 성공적으로 완료되면 서버는 별도의 단계를 통해 확인되면 후속 파일 잠금 및 파일 열기 요청에 사용되는 단축 클라이언트 ID를 반환합니다. 클라이언트 ID 확인은 SETCLIENTID\_CONFIRM 작업을 통해 수행되어 클라이언트 ID 및 setclientid\_confirm 값을 검증자로 서버에 반환해야 합니다. 두 개의 검증자가 필요한 이유는 SETCLIENTID 및 SETCLIENTID\_CONFIRM을 사용하여 콜백 및 callback\_ident 정보를 수정할 수 있지만 단축 클라이언트 ID는 수정할 수 없기 때문입니다. 이 경우 setclientid\_confirm 값이 사실상 유일한 검증자입니다.

이 작업에서 제공되는 콜백 정보는 향후 클라이언트에게 공개 위임이 제공되는 경우 사용됩니다. 따라서 클라이언트는 SETCLIENTID가 사용될 때 콜백 프로그램에 대한 프로그램 및 포트 번호를 올바르게 반영해야 합니다.

callback\_ident 값은 콜백 시 서버에서 사용됩니다. 클라이언트는 callback\_ident를 활용하여 둘 이상의 콜백 RPC 프로그램 번호가 필요하지 않도록 하면서 어느 서버가 콜백을 시작하는지 계속 확인할 수 있습니다.

```text
   IMPLEMENTATION
```

SETCLIENTID를 구현하는 방법을 이해하려면 다음 표기법을 사용하세요. 허락하다:

x는 SETCLIENTID4args 구조의 client.id 하위 필드 값입니다.

v SETCLIENTID4args 구조의 client.verifier 하위 필드 값이어야 합니다.

c는 SETCLIENTID4resok 구조에 반환된 clientid 필드의 값입니다.

k는 SETCLIENTID4args 구조의 callback 및 callback\_ident 필드의 값 조합을 나타냅니다.

SETCLIENTID4resok 구조에 반환된 setclientid\_confirm 값입니다.

{ v, x, c, k, s }는 클라이언트 레코드의 5배입니다. 클라이언트 레코드를 확인하기 위한 SETCLIENTID\_CONFIRM 작업이 있는 경우 클라이언트 레코드가 확인됩니다. 그렇지 않으면 확인되지 않습니다. 확인되지 않은 레코드는 SETCLIENTID 호출에 의해 설정됩니다.

SETCLIENTID는 비멱등성 작업이므로 서버가 DRC\(중복 요청 캐시\)를 구현하고 있다고 가정해 보겠습니다.

서버가 SETCLIENTID { v, x, k } 요청을 받으면 다음과 같은 방식으로 처리합니다.

o 먼저 DRC에서 요청을 조회합니다. 적중이 있으면 DRC에 캐시된 결과를 반환합니다. 서버는 클라이언트 상태\(잠금, 공유, 위임\)를 제거하지 않으며 클라이언트 { x }에 대해 기록된 콜백 및 callback\_ident 정보를 수정하지 않습니다.

- DRC가 누락된 경우 서버는 클라이언트 ID 문자열 x를 사용하고 서버가 이전 SETCLIENTID 호출에서 기록했을 수 있는 x에 대한 클라이언트 레코드를 검색합니다. 동일한 ID 문자열 x를 가진 확인된 레코드에 대해 기록된 주체가 SETCLIENTID 호출의 주체와 일치하지 않으면 서버는 NFS4ERR\_CLID\_INUSE 오류를 반환합니다.

- 논의를 간결하게 하기 위해 처리에 대한 나머지 설명에서는 DRC 누락이 있었고 서버가 이전에 클라이언트 x에 대해 확인된 기록을 기록한 경우 앞서 언급한 주체 확인이 성공적으로 통과했다고 가정합니다.

o 서버는 {v, x, c, l, s }에 대해 확인된 레코드를 기록했는지 확인합니다. 여기서 l은 k와 같을 수도 있고 같지 않을 수도 있습니다. 그렇다면 요청의 ID 검증자 v가 확인 및 기록된 것과 일치하므로 서버는 이를 가능한 콜백 정보 업데이트로 간주하고 확인되지 않은 { v, x, c, k, t }를 기록하고 확인된 {를 남깁니다. v, x, c, l, s }가 t != s가 되도록 배치합니다. k가 l과 같은지 여부는 중요하지 않습니다. 기존에 확인되지 않은 { v, x, c, \*, \* }는 제거됩니다.

- 서버는 { c, t }를 반환합니다. 실제로 클라이언트는 콜백 값 k를 값 l로 업데이트하기를 원하기 때문에 이전 clientid4 값 c를 반환합니다. 이 요청은 오래된 콜백 정보가 있는 비잔틴 라우터의 요청일 가능성이 있지만 이는 문제가 되지 않습니다. 콜백 정보 업데이트는 SETCLIENTID\_CONFIRM { c, t }가 뒤따르는 경우에만 확인됩니다.

서버는 다음을 통해 k의 확인을 기다립니다.

- SETCLIENTID\_CONFIRM { c, t }.

- 서버는 x에 대한 클라이언트\(잠금/공유/위임\) 상태를 제거하지 않습니다.

o 서버는 이전에 v != u, l이 k와 같거나 같지 않을 수 있는 확인된 { u, x, c, l, s } 레코드를 기록했으며 확인되지 않은 { \*, x, \*, \*, \* } x에 대한 기록입니다. 서버는 확인되지 않은 { v, x, d, k, t } \(d != c, t != s\)를 기록합니다.

- 서버는 { d, t }를 반환합니다.

- 서버는 SETCLIENTID\_CONFIRM { d, t }를 통해 { d, k }의 확인을 기다립니다.

- 서버는 x에 대한 클라이언트\(잠금/공유/위임\) 상태를 제거하지 않습니다.

o 서버는 이전에 v != u, l이 k와 같거나 같지 않을 수 있는 확인된 { u, x, c, l, s } 레코드를 기록했으며 확인되지 않은 { w, x, d, m, t }를 기록했습니다. c != d, t != s, m은 k와 같거나 같지 않을 수 있고, m은 l과 같거나 같지 않을 수 있으며, k는 l과 같거나 같지 않을 수 있도록 기록합니다. w == v인지 w != v인지는 아무런 차이가 없습니다. 서버는 확인되지 않은 { w, x, d, m, t } 레코드를 제거하고 확인되지 않은 { v, x, e, k, r } 레코드로 대체합니다. 즉, e != d, e != c, r이 됩니다. !=t, r !=s.

- 서버는 { e, r }을 반환합니다.

서버는 다음을 통해 { e, k }의 확인을 기다립니다.

- SETCLIENTID\_CONFIRM { e, r }.

- 서버는 x에 대한 클라이언트\(잠금/공유/위임\) 상태를 제거하지 않습니다.

o 서버에는 x에 대해 확인된 { \*, x, \*, \*, \* }가 없습니다. 확인되지 않은 { u, x, c, l, s }를 기록했을 수도 있고 기록하지 않았을 수도 있습니다. 여기서 l은 k와 같을 수도 있고 같지 않을 수도 있고, v와 같을 수도 있고 같지 않을 수도 있습니다. 확인되지 않은 모든 기록 { u, x, c, l , \* }는 u == v 또는 l == k인지에 관계없이 확인되지 않은 레코드 { v, x, d, k, t }로 대체됩니다. 여기서 d != c, t != s입니다.

- 서버는 { d, t }를 반환합니다.

- 서버는 SETCLIENTID\_CONFIRM { d, t }를 통해 { d, k }의 확인을 기다립니다. 서버는 x에 대한 클라이언트\(잠금/공유/위임\) 상태를 제거하지 않습니다.

서버는 clientid 및 setclientid\_confirm 값을 생성하며 이러한 값이 다시 생성될 가능성이 거의 없도록 주의해야 합니다.

```text
   ERRORS

      NFS4ERR_BADXDR
      NFS4ERR_CLID_INUSE
      NFS4ERR_INVAL
      NFS4ERR_RESOURCE
      NFS4ERR_SERVERFAULT
```

---
#### **14.2.34.  Operation 36: SETCLIENTID_CONFIRM - Confirm Clientid**

```text
   SYNOPSIS

     clientid, verifier -> -

   ARGUMENT

     struct SETCLIENTID_CONFIRM4args {
             clientid4       clientid;
             verifier4       setclientid_confirm;
     };

   RESULT

     struct SETCLIENTID_CONFIRM4res {
             nfsstat4        status;
     };

   DESCRIPTION
```

이 작업은 클라이언트가 SETCLIENTID에 대한 이전 호출의 결과를 확인하는 데 사용됩니다. 클라이언트는 \(SETCLIENTID 응답에서\) 제공된 서버 clientid를 제공합니다. 서버는 성공 또는 실패라는 간단한 상태로 응답합니다.

```text
   IMPLEMENTATION
```

클라이언트는 SETCLIENTID\_CONFIRM 작업을 사용하여 다음 두 가지 사례를 확인해야 합니다.

o 클라이언트는 새로운 단축 클라이언트 식별자\(SETCLIENTID에 대한 응답으로 서버에서 반환됨\), 새 콜백 값\(SETCLIENTID에 대한 인수에 지정됨\) 및 새 callback\_ident\(SETCLIENTID에 대한 인수에 지정됨\) 값을 사용합니다. . 이 경우 클라이언트가 SETCLIENTID\_CONFIRM을 사용하면 클라이언트의 이전 관련 임대 상태가 모두 제거되었음을 확인합니다. 관련 임대 클라이언트 상태에는 레코드 잠금, 공유 예약 및 서버가 CLAIM\_DELEGATE\_PREV 클레임 유형을 지원하지 않는 경우 위임이 포함됩니다. 서버가 CLAIM\_DELEGATE\_PREV를 지원하는 경우 SETCLIENTID\_CONFIRM은 이 클라이언트에 대한 위임을 제거해서는 안 됩니다. 관련 임대 클라이언트 상태에는 레코드 잠금 및 공유 예약만 포함됩니다.\(MUST NOT\)

```text
   o  The client's re-use of an old, previously confirmed, shorthand
      client identifier, a new callback value, and a new callback_ident
      value.  The client's use of SETCLIENTID_CONFIRM in this case MUST
      NOT result in the removal of any previous leased state (locks,
      share reservations, and delegations)
```

SETCLIENTID 작업 설명에 소개된 대로 v, x, c, k, s 및 확인되지 않은 클라이언트 레코드와 확인된 클라이언트 레코드에 대해 동일한 표기법과 정의를 사용합니다. SETCLIENTID\_CONFIRM에 대한 인수는 { c, s } 표기법으로 표시됩니다. 여기서 c는 clientid4 유형의 값이고 s는 setclientid\_confirm 필드에 해당하는 verifier4 유형의 값입니다.

SETCLIENTID와 마찬가지로 SETCLIENTID\_CONFIRM은 비멱등성 작업이며 서버가 DRC\(중복 요청 캐시\)를 구현하고 있다고 가정합니다.

서버가 SETCLIENTID\_CONFIRM { c, s } 요청을 받으면 다음과 같은 방식으로 처리합니다.

o 먼저 DRC에서 요청을 조회합니다. 적중이 있으면 DRC에 캐시된 결과를 반환합니다. 서버는 관련 임대 클라이언트 상태를 제거하지 않으며 약식 값 c로 표시되는 클라이언트 { x }에 대해 기록된 콜백 및 callback\_ident 정보를 수정하지 않습니다.

DRC 누락의 경우 서버는 단축 값 c와 일치하는 클라이언트 레코드를 확인합니다. 처리사례는 다음과 같습니다.

o 서버가 확인되지 않은 { v, x, c, k, s } 레코드와 확인된 { v, x, c, l, t } 레코드를 기록했습니다\(예: s != t\). 레코드의 주체가 SETCLIENTID\_CONFIRM의 주체와 일치하지 않으면 서버는 NFS4ERR\_CLID\_INUSE를 반환하고 관련 임대 클라이언트 상태는 제거되지 않으며 클라이언트 { x }에 대해 기록된 콜백 및 callback\_ident 정보가 변경되지 않습니다. 그렇지 않으면 확인된 { v, x, c, l, t } 레코드는 제거되고 확인되지 않은 { v, x, c, k, s }는 확인으로 표시되어 클라이언트 { x에 대한 녹음 및 확인된 콜백 및 callback\_ident 정보가 수정됩니다. }.

- 서버는 관련 임대 클라이언트 상태를 제거하지 않습니다.

- 서버가 NFS4\_OK를 반환합니다.

o 서버는 확인되지 않은 {v, x, c, \*, \* }를 기록하지 않았고 확인된 {v, x, c, \*, s }를 기록했습니다. 레코드와 SETCLIENTID\_CONFIRM의 주체가 일치하지 않는 경우 서버는 관련 임대 클라이언트 상태를 제거하지 않고 클라이언트 { x }에 대해 기록된 콜백 및 callback\_ident 값을 변경하지 않고 NFS4ERR\_CLID\_INUSE를 반환합니다.

- 주체가 일치하면 클라이언트가 SETCLIENTID\_CONFIRM으로부터 응답을 받지 못했고 DRC 항목이 제거되었을 가능성이 높습니다. 어떤 시나리오에서든 보안 주체가 일치하고 { c, s }가 확인된 레코드와 일치하므로 서버는 클라이언트 x의 관련 임대 클라이언트 상태를 그대로 유지하고 콜백 및 callback\_ident 값을 수정하지 않은 상태로 두고 NFS4\_OK를 반환합니다.

o 서버는 확인된 { \*, \*, c, \*, \* }를 기록하지 않았고, 확인되지 않은 { \*, x, c, k, s }를 기록했습니다. 클라이언트의 재시도인 경우에도 클라이언트의 첫 번째 SETCLIENTID\_CONFIRM 시도가 서버에서 수신되지 않았습니다. 재시도 여부는 서버가 알지 못하지만 처음 시도한 것처럼 처리합니다. 확인되지 않은 { \*, x, c, k, s } 레코드의 주체가 SETCLIENTID\_CONFIRM 요청의 주체와 일치하지 않으면 서버는 관련 임대 클라이언트 상태를 제거하지 않고 NFS4ERR\_CLID\_INUSE를 반환합니다.

- 그렇지 않으면 서버는 확인된 { \*, x, c, k, s }를 기록합니다. 확인된 { \*, x, d, \*, t }도 있는 경우 서버는 클라이언트 x의 관련 임대 클라이언트 상태를 제거하고 콜백 상태를 k로 덮어써야 합니다. 확인된 레코드 { \*, x, d, \*, t }가 제거됩니다.\(MUST\)

```text
      Server returns NFS4_OK.
```

o 서버에는 확인되거나 확인되지 않은 { \*, \*, c, \*, s }에 대한 기록이 없습니다. 서버는 NFS4ERR\_STALE\_CLIENTID를 반환합니다. 서버는 관련된 임대 클라이언트 상태를 제거하지 않으며 클라이언트에 대해 기록된 콜백 및 callback\_ident 정보를 수정하지 않습니다.

서버는 확인되지 않은 { v, x, c, k, s } 클라이언트 레코드를 캐시하고 잠시 동안 확인을 기다려야 합니다. SETCLIENTID 및 SETCLIENTID\_CONFIRM에 대한 레코드 처리 논의에서 분명히 알 수 있듯이 서버가 확인되지 않은 클라이언트 레코드를 결정적으로 제거하지 않는 경우가 있습니다. 리소스 부족을 방지하기 위해 서버는 확인되지 않은 기록을 무기한 보관할 필요가 없습니다. 서버가 사용할 수 있는 한 가지 전략은 확인되지 않은 클라이언트 레코드 수에 대한 제한을 설정하고 제한이 초과되면 가장 오래된 레코드를 제거하는 것입니다. 또 다른 전략은 일정 시간이 경과한 후 확인되지 않은 기록을 제거하는 것입니다. 시간의 선택은 상당히 임의적이지만 서버의 임대 기간보다 높지는 않습니다. 임대 시간이 만료되기 전에 클라이언트의 작업을 통해 임대를 갱신해야 한다는 점을 고려하세요. 클라이언트가 임대 기간과 동일한 기간이 만료되기 전에 SETCLIENTID 이후 SETCLIENTID\_CONFIRM을 실행할 수 없는 경우 클라이언트는 안정된 상태 작업 중에 서버에서 상태를 유지할 수 없을 것입니다.

클라이언트가 서버가 이미 삭제한 확인되지 않은 레코드에 대해 SETCLIENTID\_CONFIRM을 보내는 경우 클라이언트는 NFS4ERR\_STALE\_CLIENTID를 다시 받게 됩니다. 그렇다면 클라이언트는 다시 시작하고 SETCLIENTID를 보내 확인되지 않은 클라이언트 레코드를 다시 설정하고 확인되지 않은 clientid 및 setclientid\_confirm 검증자를 다시 가져와야 합니다. 그런 다음 클라이언트는 SETCLIENTID\_CONFIRM을 보내 clientid를 확인해야 합니다.

SETCLIENTID\_CONFIRM은 임대를 설정하거나 갱신하지 않습니다. 그러나 SETCLIENTID\_CONFIRM이 관련 임대 클라이언트 상태를 제거하고 해당 상태에 기존 위임이 포함되어 있지 않은 경우 서버는 OPEN의 CLAIM\_DELEGATE\_PREV 클레임 유형을 통해 클라이언트에게 Lease\_time 속성 값 이상의 기간을 허용해야 합니다. 작업\) 회수되지 않은 위임을 제거하기 전에 해당 위임을 제거합니다.\(MUST\)

```text
   ERRORS

      NFS4ERR_BADXDR
      NFS4ERR_CLID_INUSE
      NFS4ERR_RESOURCE
      NFS4ERR_SERVERFAULT
      NFS4ERR_STALE_CLIENTID
```

---
#### **14.2.35.  Operation 37: VERIFY - Verify Same Attributes**

```text
   SYNOPSIS

     (cfh), fattr -> -

   ARGUMENT

     struct VERIFY4args {
             /* CURRENT_FH: object */
             fattr4          obj_attributes;
     };

   RESULT

     struct VERIFY4res {
             nfsstat4        status;
     };

   DESCRIPTION
```

VERIFY 작업은 복합 요청에서 다음 작업을 진행하기 전에 속성에 클라이언트가 가정한 값이 있는지 확인하는 데 사용됩니다. 속성 중 하나라도 일치하지 않으면 NFS4ERR\_NOT\_SAME 오류가 반환되어야 합니다. 현재 파일 핸들은 작업이 성공적으로 완료된 후에도 해당 값을 유지합니다.

```text
   IMPLEMENTATION
```

VERIFY 연산의 한 가지 가능한 용도는 다음과 같은 복합 시퀀스입니다. 이를 통해 클라이언트는 제거되는 파일이 클라이언트가 제거할 것으로 예상하는 파일과 일치하는지 확인하려고 시도합니다. 이 순서는 의도하지 않은 파일 삭제를 방지하는 데 도움이 됩니다.

```text
         PUTFH (directory filehandle)
         LOOKUP (file name)
         VERIFY (filehandle == fh)
         PUTFH (directory filehandle)
         REMOVE (file name)
```

이 시퀀스는 두 번째 클라이언트가 이 시퀀스 중간에 새 파일을 제거하고 생성하는 것을 방지하지는 않지만 의도하지 않은 결과를 방지하는 데 도움이 됩니다.

VERIFY 작업에 권장 속성이 지정되어 있고 서버가 파일 시스템 개체에 대해 해당 속성을 지원하지 않는 경우 NFS4ERR\_ATTRNOTSUPP 오류가 클라이언트에 반환됩니다.

rdattr\_error 속성이나 쓰기 전용 속성\(예: time\_modify\_set\)이 지정되면 NFS4ERR\_INVAL 오류가 클라이언트에 반환됩니다.

```text
   ERRORS

      NFS4ERR_ACCESS
      NFS4ERR_ATTRNOTSUPP
      NFS4ERR_BADCHAR
      NFS4ERR_BADHANDLE
      NFS4ERR_BADXDR
      NFS4ERR_DELAY
      NFS4ERR_FHEXPIRED
      NFS4ERR_INVAL
      NFS4ERR_MOVED
      NFS4ERR_NOFILEHANDLE
      NFS4ERR_NOT_SAME
      NFS4ERR_RESOURCE
      NFS4ERR_SERVERFAULT
      NFS4ERR_STALE
```

---
#### **14.2.36.  Operation 38: WRITE - Write to File**

```text
   SYNOPSIS

     (cfh), stateid, offset, stable, data -> count, committed, writeverf

   ARGUMENT

     enum stable_how4 {
             UNSTABLE4       = 0,
             DATA_SYNC4      = 1,
             FILE_SYNC4      = 2
     };

     struct WRITE4args {
             /* CURRENT_FH: file */
             stateid4        stateid;
             offset4         offset;

             stable_how4     stable;
             opaque          data<>;
     };

   RESULT

     struct WRITE4resok {
             count4          count;
             stable_how4     committed;
             verifier4       writeverf;
     };

     union WRITE4res switch (nfsstat4 status) {
      case NFS4_OK:
              WRITE4resok    resok4;
      default:
              void;
     };

   DESCRIPTION
```

WRITE 작업은 일반 파일에 데이터를 쓰는 데 사용됩니다. 대상 파일은 현재 파일 핸들로 지정됩니다. 오프셋은 데이터가 기록되어야 하는 오프셋을 지정합니다. 오프셋 0\(영\)은 쓰기가 파일 시작 부분에서 시작되어야 함을 지정합니다. 불투명 데이터 매개변수의 일부로 인코딩된 개수는 기록될 데이터의 바이트 수를 나타냅니다. 개수가 0\(영\)이면 WRITE가 성공하고 권한 확인에 따라 개수 0\(영\)을 반환합니다. 서버는 클라이언트가 요청한 것보다 적은 바이트를 쓰도록 선택할 수 있습니다.

쓰기 요청의 일부는 쓰기 수행 방법에 대한 사양입니다. 클라이언트는 stable 매개변수를 사용하여 서버에서 데이터를 처리하는 방법을 지정합니다. stable이 FILE\_SYNC4인 경우 서버는 결과를 반환하기 전에 작성된 데이터와 모든 파일 시스템 메타데이터를 안정적인 저장소에 커밋해야 합니다. 이는 NFS 버전 2 프로토콜 의미 체계에 해당합니다. 다른 모든 행동은 프로토콜 위반으로 간주됩니다. stable이 DATA\_SYNC4인 경우 서버는 모든 데이터를 안정적인 저장소에 커밋해야 하며 반환하기 전에 데이터를 검색할 만큼 충분한 메타데이터를 커밋해야 합니다. 서버 구현자는 FILE\_SYNC4와 동일한 방식으로 DATA\_SYNC4를 자유롭게 구현할 수 있지만 성능이 저하될 수 있습니다. stable이 UNSTABLE4인 경우 서버는 클라이언트에 응답을 반환하기 전에 데이터와 메타데이터의 일부\(모두 또는 전혀 포함하지 않음\)를 stable 저장소에 자유롭게 커밋할 수 있습니다. 커밋되지 않은 데이터가 이후에 안정적인 저장소에 커밋되는지 여부와 시기가 보장되지 않습니다. 서버가 보장하는 유일한 것은 다음과 같습니다.

verf 값을 변경하지 않고 모든 데이터를 삭제하고 클라이언트가 요청한 수준보다 낮은 수준으로 데이터와 메타데이터를 커밋하지 않습니다.

WRITE 요청의 stateid 값은 이전 레코드 잠금 또는 공유 예약 요청에서 반환된 값을 나타냅니다. stateid는 서버에서 관련 공유 예약 및 레코드 잠금이 여전히 유효한지 확인하고 클라이언트에 대한 임대 시간 제한을 업데이트하는 데 사용됩니다.

성공적으로 완료되면 다음 결과가 반환됩니다. 계산 결과는 파일에 기록된 데이터의 바이트 수입니다. 서버는 요청한 것보다 적은 바이트를 쓸 수 있습니다. 그렇다면 오프셋 위치에서 시작하여 쓰여진 실제 바이트 수가 반환됩니다.

서버는 또한 커밋을 통해 데이터 및 메타데이터의 커밋 수준 표시를 반환합니다. 서버가 모든 데이터와 메타데이터를 안정적인 저장소에 커밋한 경우 커밋을 FILE\_SYNC4로 설정해야 합니다. 커밋 수준이 최소한 DATA\_SYNC4만큼 강력했다면 커밋을 DATA\_SYNC4로 설정해야 합니다. 그렇지 않으면 커밋된 값이 UNSTABLE4로 반환되어야 합니다. 안정이 FILE4\_SYNC인 경우 커밋도 FILE\_SYNC4여야 합니다. 다른 모든 것은 프로토콜 위반을 구성합니다. 안정적인 것이 DATA\_SYNC4인 경우 커밋된 것은 FILE\_SYNC4 또는 DATA\_SYNC4일 수 있습니다. 다른 모든 것은 프로토콜 위반을 구성합니다. stable이 UNSTABLE4인 경우 커밋된 항목은 FILE\_SYNC4, DATA\_SYNC4 또는 UNSTABLE4일 수 있습니다.

결과의 마지막 부분은 쓰기 검증자입니다. 쓰기 검증자는 WRITE 호출과 후속 WRITE 또는 COMMIT 호출 사이에 서버가 인스턴스\(부팅\) 상태를 변경했는지 여부를 확인하는 데 클라이언트가 사용할 수 있는 쿠키입니다. 이 쿠키는 NFS 버전 4 프로토콜 서비스의 단일 인스턴스 동안 일관성을 유지해야 하며 커밋되지 않은 데이터가 손실될 수 있는 NFS 버전 4 프로토콜 서버 인스턴스 간에 고유해야 합니다.

클라이언트가 UNSTABLE4로 설정된 안정적인 인수를 사용하여 서버에 데이터를 쓰고 응답이 DATA\_SYNC4 또는 UNSTABLE4의 커밋된 응답을 생성하는 경우 클라이언트는 나중에 COMMIT 작업을 수행하여 미해결 비동기 데이터와 메타데이터를 동기화합니다. 클라이언트 오류를 ​​제외하고 서버의 안정적인 저장 공간입니다. 클라이언트 충돌이나 기타 오류로 인해 후속 COMMIT가 서버에서 수신되지 않을 수도 있습니다.

모든 비트가 0인 stateid 값을 갖는 WRITE의 경우, 서버는 필수 파일 잠금 또는 파일에 대한 현재 공유 거부 모드에 따라 WRITE가 서비스되도록 허용할 수 있습니다. stateid를 사용한 WRITE의 경우\(MAY\)

모든 비트 값이 1인 경우 서버는 WRITE 작업이 서버의 잠금 검사를 우회하도록 허용해서는 안 되며 모든 비트 0의 stateid가 사용된 것과 정확히 동일하게 처리됩니다.\(MUST NOT\)

성공하면 현재 파일 핸들이 해당 값을 유지합니다.

```text
   IMPLEMENTATION
```

서버가 클라이언트가 요청한 것보다 더 적은 바이트의 데이터를 쓰는 것이 가능합니다. 이 경우 데이터가 전혀 기록되지 않는 한 서버는 오류를 반환해서는 안 됩니다. 서버가 지정된 바이트 수보다 적게 쓰는 경우 클라이언트는 나머지 데이터를 쓰기 위해 또 다른 WRITE를 실행해야 합니다.

파일에 데이터를 쓰는 행위로 인해 파일의 time\_modified가 업데이트된다고 가정합니다. 그러나 파일의 내용이 변경되지 않는 한 파일의 time\_modified는 변경되어서는 안 됩니다. 따라서 개수가 0으로 설정된 WRITE 요청으로 인해 파일의 time\_modified가 업데이트되어서는 안 됩니다.

안정적인 스토리지의 정의는 역사적으로 논쟁의 여지가 있었습니다. 안정적인 저장소의 다음과 같은 예상 속성은 구현 시 설계 문제를 해결하는 데 도움이 될 수 있습니다. 안정적인 스토리지는 다음과 같이 지속되는 영구 스토리지입니다.

```text
      1. Repeated power failures.
      2. Hardware failures (of any board, power supply, etc.).
      3. Repeated software crashes, including reboot cycle.
```

이 정의는 안정적인 저장소 모듈 자체의 오류를 다루지 않습니다.

검증자는 클라이언트가 캐시된 커밋되지 않은 데이터가 손실될 수 있는 NFS 버전 4 프로토콜 서버의 다양한 인스턴스를 감지할 수 있도록 정의됩니다. 대부분의 경우 검증자는 클라이언트가 서버 재부팅을 감지하도록 허용합니다. 이 정보는 클라이언트가 서버에서 캐시된 데이터가 손실되었는지 여부를 안전하게 판단할 수 있도록 하는 데 필요합니다. 서버가 예기치 않게 실패하고 클라이언트에 이전 WRITE 요청에서 커밋되지 않은 데이터가 있는 경우\(안정적인 인수를 UNSTABLE4로 설정하고 커밋된 결과도 UNSTABLE4로 반환됨\) 캐시된 데이터를 안정적인 저장소로 플러시하지 않았을 수 있습니다. 복구 부담은 클라이언트에 있으며 클라이언트는 데이터를 서버로 재전송해야 합니다.

제안된 검증 도구는 서버가 부팅된 시간이나 서버가 마지막으로 시작된 시간을 사용하는 것입니다\(재부팅하지 않고 서버를 다시 시작하면 버퍼가 손실되는 경우\).

결과의 커밋된 필드를 통해 클라이언트는 보다 효과적인 캐싱을 수행할 수 있습니다. 서버가 모든 WRITE 요청을 안정적인 저장소에 커밋하는 경우 인수의 stable 필드 값에 관계없이 FILE\_SYNC4로 설정된 커밋을 반환해야 합니다. NVRAM 가속기를 사용하는 서버는 이 정책을 구현하도록 선택할 수 있습니다. 클라이언트는 이를 사용하여 서버에 이미 커밋된 캐시된 데이터를 삭제하여 캐시의 효율성을 높일 수 있습니다.

일부 구현에서는 사용자 할당량이 초과되면 NFS4ERR\_DQUOT 대신 NFS4ERR\_NOSPC를 반환할 수 있습니다. 현재 파일 핸들이 디렉터리인 경우 서버는 NFS4ERR\_ISDIR을 반환합니다. 현재 파일 핸들이 일반 파일이나 디렉터리가 아닌 경우 서버는 NFS4ERR\_INVAL을 반환합니다.

파일에 대해 필수 파일 잠금이 켜져 있고 해당 파일에 기록될 데이터의 해당 레코드가 stateid와 연결되지 않은 소유자에 의해 읽혀지거나 쓰기가 잠긴 경우 서버는 NFS4ERR\_LOCKED를 반환합니다. 그렇다면 클라이언트는 WRITE 작업에 사용된 stateid에 해당하는 소유자가 쓰기 대상 영역과 겹치는 충돌하는 읽기 잠금을 가지고 있는지 확인해야 합니다. stateid의 소유자에게 충돌하는 읽기 잠금이 없으면 클라이언트는 쓰기를 다시 시도하기 전에 LOCK 작업을 통해 적절한 쓰기 레코드 잠금을 얻으려고 시도해야 합니다. WRITE가 완료되면 클라이언트는 LOCKU를 통해 레코드 잠금을 해제해야 합니다.

stateid의 소유자가 충돌하는 읽기 잠금을 갖고 있는 경우 클라이언트는 쓰기를 시도한 애플리케이션에 오류를 반환할 수밖에 없습니다. 그 이유는 stateid의 소유자가 읽기 잠금을 갖고 있었기 때문에 서버가 일시적으로 이 읽기 잠금을 쓰기 잠금으로 효과적으로 업그레이드하려고 시도했거나 서버에 업그레이드 기능이 없기 때문입니다. 서버가 읽기 잠금 업그레이드를 시도했지만 실패한 경우 다른 클라이언트도 업그레이드를 시도할 수 있으므로 클라이언트가 LOCK 작업을 통해 업그레이드를 다시 시도하는 것은 의미가 없습니다. 두 클라이언트가 동일한 잠금을 업그레이드하려고 차단되면 클라이언트가 교착 상태가 됩니다. 서버에 업그레이드 기능이 없으면 업그레이드를 위해 LOCK 작업을 시도하는 것은 의미가 없습니다.

```text
   ERRORS

      NFS4ERR_ACCESS
      NFS4ERR_ADMIN_REVOKED
      NFS4ERR_BADHANDLE
      NFS4ERR_BAD_STATEID
      NFS4ERR_BADXDR
      NFS4ERR_DELAY
      NFS4ERR_DQUOT
      NFS4ERR_EXPIRED

      NFS4ERR_FBIG
      NFS4ERR_FHEXPIRED
      NFS4ERR_GRACE
      NFS4ERR_INVAL
      NFS4ERR_IO
      NFS4ERR_ISDIR
      NFS4ERR_LEASE_MOVED
      NFS4ERR_LOCKED
      NFS4ERR_MOVED
      NFS4ERR_NOFILEHANDLE
      NFS4ERR_NOSPC
      NFS4ERR_NXIO
      NFS4ERR_OLD_STATEID
      NFS4ERR_OPENMODE
      NFS4ERR_RESOURCE
      NFS4ERR_ROFS
      NFS4ERR_SERVERFAULT
      NFS4ERR_STALE
      NFS4ERR_STALE_STATEID
```

---
#### **14.2.37.  Operation 39: RELEASE_LOCKOWNER - Release Lockowner State**

```text
   SYNOPSIS

     lockowner -> ()

   ARGUMENT

     struct RELEASE_LOCKOWNER4args {
             lock_owner4     lock_owner;
     };

   RESULT

     struct RELEASE_LOCKOWNER4res {
             nfsstat4        status;
     };

   DESCRIPTION
```

이 작업은 클라이언트가 lock\_owner를 더 이상 사용하지 않는다는 것을 서버에 알리는 데 사용됩니다. 이를 통해 서버는 지정된 lock\_owner와 관련된 캐시된 상태를 해제할 수 있습니다. lock\_owner와 관련된 파일 잠금이 서버에 유지되면 NFS4ERR\_LOCKS\_HELD 오류가 반환되고 추가 조치가 수행되지 않습니다.

```text
   IMPLEMENTATION
```

클라이언트는 유지되는 서버 상태의 양을 완화하기 위해 이 작업을 사용하도록 선택할 수 있습니다. 클라이언트의 애플리케이션 동작에 따라 서버는 관련 파일이 열려 있는 동안 lock\_owner에 대한 참조를 보유하는 것과 관련하여 특정 의무를 갖기 때문에 클라이언트가 이 작업을 사용하는 것이 중요할 수 있습니다. 따라서 클라이언트가 lock\_owner가 연결된 open\_owner4의 컨텍스트에서 더 이상 사용되지 않는다는 것을 확실히 알고 있는 경우 RELEASE\_LOCKOWNER를 사용해야 합니다.

```text
   ERRORS

      NFS4ERR_ADMIN_REVOKED
      NFS4ERR_BADXDR
      NFS4ERR_EXPIRED
      NFS4ERR_LEASE_MOVED
      NFS4ERR_LOCKS_HELD
      NFS4ERR_RESOURCE
      NFS4ERR_SERVERFAULT
      NFS4ERR_STALE_CLIENTID
```

---
#### **14.2.38.  Operation 10044: ILLEGAL - Illegal operation**

```text
   SYNOPSIS

     <null> -> ()

   ARGUMENT

             void;

   RESULT

             struct ILLEGAL4res {
                     nfsstat4        status;
             };

   DESCRIPTION
```

이 작업은 클라이언트가 지원되지 않는 COMPOUND 내에서 작업 코드를 보내는 경우를 처리하기 위해 결과를 인코딩하기 위한 자리 표시자입니다. 자세한 내용은 COMPOUND 프로시저 설명을 참조하세요.

ILLEGAL4res의 상태 필드는 NFS4ERR\_OP\_ILLEGAL로 설정되어야 합니다.\(MUST\)

```text
   IMPLEMENTATION
```

클라이언트는 아마도 OP\_ILLEGAL 코드가 포함된 작업을 보내지 않을 것입니다. 그러나 보내는 경우 다른 유효하지 않은 작업 코드와 마찬가지로 응답은 ILLEGAL4res가 됩니다. 서버가 OP\_ILLEGAL이 아닌 잘못된 연산 코드를 받고 서버가 XDR 디코드 단계 중에 적법한 연산 코드를 확인하는 경우 ILLEGAL4res가 반환되지 않습니다.

```text
   ERRORS

   NFS4ERR_OP_ILLEGAL
```

---
## **15.  NFS version 4 Callback Procedures**

콜백에 사용되는 절차는 다음 섹션에 정의되어 있습니다. 명확성을 위해 "클라이언트"와 "서버"라는 용어는 NFS 클라이언트와 서버를 의미합니다. 그러나 개별 콜백 RPC의 경우 이러한 용어의 의미는 정반대입니다.

---
### **15.1.  Procedure 0: CB_NULL - No Operation**

```text
   SYNOPSIS

     <null>

   ARGUMENT

     void;

   RESULT

     void;

   DESCRIPTION
```

표준 NULL 프로시저. 무효 논쟁, 무효 응답. 이 프로시저와 관련된 직접적인 기능이 없더라도 서버는 CB\_NULL을 사용하여 서버에서 클라이언트로의 RPC 경로가 있는지 확인합니다.

```text
   ERRORS

   None.
```

---
### **15.2.  Procedure 1: CB_COMPOUND - Compound Operations**

```text
   SYNOPSIS

     compoundargs -> compoundres

   ARGUMENT

     enum nfs_cb_opnum4 {
             OP_CB_GETATTR           = 3,
             OP_CB_RECALL            = 4,
             OP_CB_ILLEGAL           = 10044
     };

     union nfs_cb_argop4 switch (unsigned argop) {
      case OP_CB_GETATTR:    CB_GETATTR4args opcbgetattr;
      case OP_CB_RECALL:     CB_RECALL4args  opcbrecall;
      case OP_CB_ILLEGAL:    void            opcbillegal;
     };

     struct CB_COMPOUND4args {
             utf8str_cs      tag;
             uint32_t        minorversion;
             uint32_t        callback_ident;
             nfs_cb_argop4   argarray<>;
     };

   RESULT

     union nfs_cb_resop4 switch (unsigned resop){
      case OP_CB_GETATTR:    CB_GETATTR4res  opcbgetattr;
      case OP_CB_RECALL:     CB_RECALL4res   opcbrecall;
     };

     struct CB_COMPOUND4res {
             nfsstat4 status;
             utf8str_cs      tag;
             nfs_cb_resop4   resarray<>;
     };

   DESCRIPTION
```

CB\_COMPOUND 프로시저는 하나 이상의 콜백 프로시저를 단일 RPC 요청으로 결합하는 데 사용됩니다. 기본 콜백 RPC 프로그램에는 CB\_NULL 및 CB\_COMPOUND라는 두 가지 기본 프로시저가 있습니다. 다른 모든 작업은 CB\_COMPOUND 프로시저를 래퍼로 사용합니다.

CB\_COMPOUND 프로시저를 처리하는 동안 클라이언트는 CB\_COMPOUND 시퀀스 내의 작업 중 일부 또는 전부를 실행하는 데 사용할 수 있는 리소스가 없다는 것을 알 수 있습니다. 이 경우 리소스 소진이 발생한 CB\_COMPOUND 프로시저 내의 특정 작업에 대해 NFS4ERR\_RESOURCE 오류가 반환됩니다. 이는 CB\_COMPOUND 시퀀스 내의 모든 이전 작업이 성공적으로 평가되었다고 가정합니다.

CB\_COMPOUND 결과에는 '상태' 필드가 포함되어 있습니다. 이 상태는 CB\_COMPOUND 프로시저 내에서 실행된 마지막 작업의 상태와 동일해야 합니다. 따라서 작업에서 오류가 발생한 경우 'status' 값은 실패한 작업에 대해 반환되는 오류 값과 동일합니다.

"태그" 필드의 정의는 "절차 1: COMPOUND - 복합 연산" 섹션을 참조하세요.

callback\_ident 값은 SETCLIENTID 중에 클라이언트에 의해 제공됩니다. 서버는 클라이언트가 서버를 적절하게 식별할 수 있도록 CB\_COMPOUND 중에 클라이언트가 제공한 callback\_ident를 사용해야 합니다.

잘못된 연산 코드는 COMPOUND 프로시저에서 처리되는 것과 동일한 방식으로 처리됩니다.

```text
   IMPLEMENTATION
```

CB\_COMPOUND 프로시저는 개별 작업을 단일 RPC 요청으로 결합하는 데 사용됩니다. 클라이언트는 각 작업을 차례로 해석합니다. 클라이언트에 의해 작업이 실행되고 해당 작업의 상태가 NFS4\_OK이면 CB\_COMPOUND 프로시저의 다음 작업이 실행됩니다. 클라이언트는 더 이상 실행할 작업이 없거나 작업 중 하나가 NFS4\_OK 이외의 상태 값을 가질 때까지 이 프로세스를 계속합니다.

```text
   ERRORS

      NFS4ERR_BADHANDLE
      NFS4ERR_BAD_STATEID
      NFS4ERR_BADXDR
      NFS4ERR_OP_ILLEGAL
      NFS4ERR_RESOURCE
      NFS4ERR_SERVERFAULT
```

---
#### **15.2.1.  Operation 3: CB_GETATTR - Get Attributes**

```text
   SYNOPSIS

     fh, attr_request -> attrmask, attr_vals

   ARGUMENT

     struct CB_GETATTR4args {
             nfs_fh4 fh;
             bitmap4 attr_request;
     };

   RESULT

     struct CB_GETATTR4resok {
             fattr4  obj_attributes;
     };

     union CB_GETATTR4res switch (nfsstat4 status) {
      case NFS4_OK:
              CB_GETATTR4resok       resok4;
      default:
              void;
     };
```

---
# **DESCRIPTION**

CB\_GETATTR 작업은 쓰기 위임된 파일의 현재 수정된 상태를 얻기 위해 서버에서 사용됩니다. 속성 크기와 변경 사항은 클라이언트가 서비스하도록 보장되는 유일한 속성입니다. 클라이언트와 서버가 CB\_GETATTR 사용과 상호 작용하는 방법에 대한 자세한 설명은 "CB\_GETATTR 처리" 섹션을 참조하세요.

지정된 파일 핸들이 클라이언트가 쓰기 열기 위임을 보유한 파일 핸들이 아닌 경우 NFS4ERR\_BADHANDLE 오류가 반환됩니다.

```text
   IMPLEMENTATION
```

클라이언트는 변경 속성 및 변경할 수 있는 속성\(time\_modify 및 크기\)에 대해서만 attmask 비트 및 관련 속성 값을 반환합니다.

```text
   ERRORS

      NFS4ERR_BADHANDLE
      NFS4ERR_BADXDR
      NFS4ERR_RESOURCE
      NFS4ERR_SERVERFAULT
```

---
#### **15.2.2.  Operation 4: CB_RECALL - Recall an Open Delegation**

```text
   SYNOPSIS

     stateid, truncate, fh -> ()

   ARGUMENT

     struct CB_RECALL4args {
             stateid4        stateid;
             bool            truncate;
             nfs_fh4         fh;
     };

   RESULT

     struct CB_RECALL4res {
             nfsstat4        status;
     };

   DESCRIPTION
```

CB\_RECALL 작업은 공개 위임을 회수하고 이를 서버에 반환하는 프로세스를 시작하는 데 사용됩니다.

절단 플래그는 0으로 절단될 파일에 대한 회수를 최적화하는 데 사용됩니다. 이 값이 설정되면 클라이언트는 파일에 대해 수정된 데이터를 서버에 전파할 의무가 없습니다. 이 데이터는 관련이 없기 때문입니다.

지정된 핸들이 클라이언트가 공개 위임을 보유한 핸들이 아닌 경우 NFS4ERR\_BADHANDLE 오류가 반환됩니다.

지정된 상태 ID가 파일 핸들에 의해 지정된 파일에 대한 공개 위임에 해당하는 상태가 아닌 경우 NFS4ERR\_BAD\_STATEID가 반환됩니다.

```text
   IMPLEMENTATION
```

클라이언트는 콜백에 즉시 응답해야 합니다. 오류가 반환된 경우를 제외하고 회신하면 회수가 완료되지 않습니다. DELEGRETURN을 사용하여 위임이 반환될 때까지 회수는 완료되지 않습니다.

```text
   ERRORS

      NFS4ERR_BADHANDLE
      NFS4ERR_BAD_STATEID
      NFS4ERR_BADXDR
      NFS4ERR_RESOURCE
      NFS4ERR_SERVERFAULT
```

---
#### **15.2.3.  Operation 10044: CB_ILLEGAL - Illegal Callback Operation**

```text
   SYNOPSIS

     <null> -> ()

   ARGUMENT

       void;

   RESULT

             struct CB_ILLEGAL4res {
                     nfsstat4        status;
             };

   DESCRIPTION
```

이 작업은 클라이언트가 지원되지 않는 COMPOUND 내에서 작업 코드를 보내는 경우를 처리하기 위해 결과를 인코딩하기 위한 자리 표시자입니다. 자세한 내용은 COMPOUND 프로시저 설명을 참조하세요.

CB\_ILLEGAL4res의 상태 필드는 NFS4ERR\_OP\_ILLEGAL로 설정되어야 합니다.\(MUST\)

```text
   IMPLEMENTATION
```

서버는 아마도 OP\_CB\_ILLEGAL 코드가 포함된 작업을 보내지 않을 것입니다. 그러나 만약 그렇다면 다른 유효하지 않은 작업 코드와 마찬가지로 응답은 CB\_ILLEGAL4res가 됩니다. 참고로 클라이언트라면

OP\_ILLEGAL이 아닌 잘못된 연산 코드를 가져오고 클라이언트가 XDR 디코드 단계 중에 적법한 연산 코드를 확인하면 CB\_ILLEGAL4res가 반환되지 않습니다.

```text
   ERRORS

   NFS4ERR_OP_ILLEGAL
```

---
## **16.  Security Considerations**

NFS는 인증 관점에서 볼 때 클라이언트가 전체 시스템이거나 적어도 시스템의 소스 IP 주소인 모델을 역사적으로 사용해 왔습니다. NFS 서버는 NFS 클라이언트를 사용하여 최종 사용자를 적절하게 인증했습니다. NFS 서버는 클라이언트의 소스 IP 주소로 식별되는 특정 클라이언트에만 파일을 공유했습니다. 이 모델에서 AUTH\_SYS RPC 보안 특성은 NFS 서버에 대한 클라이언트를 사용하는 최종 사용자를 간단히 식별했습니다. NFS 응답을 처리할 때 클라이언트는 요청이 전송된 것과 동일한 IP 주소 및 포트 번호에서 응답이 오는지 확인했습니다. 이러한 모델은 구현하기 쉽고 배포 및 사용이 간단하지만 확실히 안전한 모델은 아닙니다. 따라서 NFSv4에서는 클라이언트의 최종 사용자가 네트워크의 보안 주체에 대해 암호나 키를 공개하지 않는 암호화 방식을 통해 상호 인증하는 종단 간 인증을 사용하는 보안 모델을 구현에서 지원할 것을 요구합니다. NFS 서버. NFS 요청 및 응답의 무결성과 개인 정보 보호도 고려해야 합니다. 종단 간 상호 인증, 무결성 및 개인 정보 보호 문제는 "RPC 및 보안 방식" 섹션의 일부로 논의됩니다.

NFSv4는 엔드투엔드 상호 인증 모델을 요구하지만, IP 주소 확인 및 AUTH\_SYS 식별을 통한 "클래식" 시스템 인증 모델은 이 사양에서 AUTH\_SYS 플레이버가 필수도 아니고 권장도 아니라는 경고와 함께 계속 지원될 수 있습니다. AUTH\_SYS를 통한 상호 운용성은 보장되지 않습니다.\(SHOULD\)

관리 오버헤드 감소, 성능 향상 및/또는 CPU 사용률 감소로 인해 NFS 버전 4 구현 사용자는 각 원격 프로시저 호출 및 응답에서 무결성 보호를 활성화하는 보안 메커니즘을 사용하지 않도록 선택할 수 있습니다. 무결성이 없는 메커니즘을 사용하면 고객은 RPC 요청 및/또는 응답을 수정하는 NFS 클라이언트와 서버 사이의 공격자에게 취약해집니다. 구현 시 더 약한 보안 메커니즘을 사용하는 옵션을 자유롭게 제공할 수 있지만, 특히 사용자 선택을 무시하는 구현을 보장하는 두 가지 작업이 있습니다.

첫 번째 작업은 SECINFO입니다. 클라이언트는 rpc\_gss\_svc\_integrity 또는 rpc\_gss\_svc\_privacy\(rpc\_gss\_svc\_privacy에 무결성 보호가 포함됨\) 서비스를 사용하는 보안 트리플이 포함된 RPCSEC\_GSS와 같이 무결성 보호 기능이 있는 보안 방식으로 보호되도록 SECINFO 호출을 실행하는 것이 좋습니다. SECINFO 및 그 결과를 캡슐화하는 무결성 보호가 없으면 중간에 있는 공격자가 결과를 수정하여 클라이언트가 서버에서 허용하는 집합에서 더 약한 알고리즘을 선택할 수 있으므로 클라이언트 및/또는 서버가 추가 공격에 취약해질 수 있습니다.

무결성 보호를 확실히 사용해야 하는 두 번째 작업은 fs\_locations 속성에 대한 GETATTR입니다. 공격에는 두 단계가 있습니다. 먼저 공격자는 NFS4ERR\_MOVED를 반환하도록 일부 작업의 보호되지 않은 결과를 수정합니다. 둘째, 클라이언트가 fs\_locations 속성에 대한 GETATTR을 추적할 때 공격자는 결과를 수정하여 클라이언트가 공격자가 제어하는 ​​서버로 트래픽을 마이그레이션하도록 합니다.

SETCLIENTID/SETCLIENTID\_CONFIRM 작업은 클라이언트 상태 해제를 담당하므로 이러한 작업에 사용된 주체를 확인하고 이러한 작업의 이전 사용과 일치시키는 것이 중요합니다. 자세한 내용은 "클라이언트 ID" 섹션을 참조하세요.

---
## **17.  IANA Considerations**
---
### **17.1.  Named Attribute Definition**

NFS 버전 4 프로토콜은 명명된 속성을 파일에 연결하는 기능을 제공합니다. 이러한 속성의 네임스페이스 식별자는 문자열 이름으로 정의됩니다. 프로토콜은 이러한 파일 속성에 대한 이름 공간의 특정 할당을 정의하지 않습니다. 충돌을 방지하기 위해 네임스페이스가 특별히 제어되지 않더라도 NFS 버전 4 명명된 속성 등록을 위해 IANA 레지스트리가 생성되었습니다. 등록은 정보용 RFC의 공개를 통해 이루어지며 속성 이름뿐만 아니라 명명된 속성 내용의 구문 및 의미도 필요합니다. 공동의 이익이 존재하는 곳에서 상호 운용성을 촉진하려는 의도입니다. 애플리케이션 개발자는 필요에 따라 속성을 정의하고 사용할 수 있지만 IANA에 속성을 등록하는 것이 좋습니다.

---
### **17.2.  ONC RPC Network Identifiers (netids)**

"구조화된 데이터 유형" 섹션에서는 r\_netid 필드와 clientaddr4 구조의 해당 r\_addr 필드에 대해 논의했습니다. NFS 버전 4 프로토콜은 이러한 프로토콜의 구문과 의미에 따라 달라집니다.

클라이언트와 서버 간에 콜백 정보를 효과적으로 전달하기 위한 필드입니다. 따라서 이 문서에 정의된 값을 포함하고 전송 사용량/가용성을 기반으로 향후 확장을 허용하기 위해 IANA 레지스트리가 생성되었습니다. 이 ONC RPC 네트워크 식별자 레지스트리에 대한 추가는 RFC 게시와 함께 수행되어야 합니다.

이 레지스트리의 초기 값은 다음과 같습니다\(명확성을 위해 이 텍스트 중 일부는 섹션 2.2에서 복제되었습니다\).

네트워크 식별자\(또는 줄여서 r\_netid\)는 전송 프로토콜 및 관련 범용 주소\(또는 줄여서 r\_addr\)를 지정하는 데 사용됩니다. 네트워크 식별자의 구문은 US-ASCII 문자열입니다. r\_netid의 초기 정의는 다음과 같습니다.

- "tcp" - IP 버전 4를 통한 TCP

- "udp" - IP 버전 4를 통한 UDP

- "tcp6" - IP 버전 6을 통한 TCP

- "udp6" - IP 버전 6을 통한 UDP

참고: '"' 표시는 이 문서의 문자열을 구분하는 데 사용되며 네트워크 식별자 문자열의 일부가 아닙니다.

"tcp" 및 "udp" 네트워크 식별자의 경우 범용 주소 또는 r\_addr\(IPv4용\)은 US-ASCII 문자열이며 형식은 다음과 같습니다.

```text
   h1.h2.h3.h4.p1.p2
```

접두사 "h1.h2.h3.h4"는 IPv4 주소를 나타내는 표준 텍스트 형식으로 길이는 항상 4옥텟입니다. 빅엔디안 순서로 가정하면 h1, h2, h3, h4는 각각 첫 번째부터 네 번째 옥텟까지 ASCII 십진수로 변환됩니다. 빅엔디안 순서를 가정하면 p1과 p2는 각각 ASCII 십진수로 변환된 첫 번째와 두 번째 옥텟입니다. 예를 들어, 빅엔디안 순서의 호스트 주소가 0x0A010307이고 빅엔디안 순서의 포트 0x020F\(10진수 527\)를 수신 대기하는 서비스가 있는 경우 완전한 범용 주소는 "10.1.3.7.2.15"입니다. .

"tcp6" 및 "udp6" 네트워크 식별자의 경우 범용 주소 또는 r\_addr\(IPv6용\)은 US-ASCII 문자열이며 형식은 다음과 같습니다.

```text
      x1:x2:x3:x4:x5:x6:x7:x8.p1.p2
```

접미사 "p1.p2"는 서비스 포트이며 "tcp" 및 "udp"에 대한 범용 주소와 동일한 방식으로 계산됩니다. 접두사 "x1:x2:x3:x4:x5:x6:x7:x8"은 \[RFC2373\]의 섹션 2.2에 정의된 대로 IPv6 주소를 나타내는 표준 텍스트 형식입니다. 또한 \[RFC2373\]의 섹션 2.2에 지정된 두 가지 대체 형식도 허용됩니다.

언급한 대로, 새로운 네트워크 식별자를 등록하려면 네트워크 식별자 자체 및 해당 범용 주소에 대해 위에 나열된 것과 유사한 세부 정보가 포함된 정보 RFC를 게시해야 합니다.

---
## **18.  RPC definition file**

```text
   /*
    *  Copyright (C) The Internet Society (1998,1999,2000,2001,2002).
    *  All Rights Reserved.
    */

   /*
    *      nfs4_prot.x
    *
    */

   %#pragma ident  "%W%"

   /*
    * Basic typedefs for RFC 1832 data type definitions
    */
   typedef int             int32_t;
   typedef unsigned int    uint32_t;
   typedef hyper           int64_t;
   typedef unsigned hyper  uint64_t;

   /*
    * Sizes
    */
   const NFS4_FHSIZE               = 128;
   const NFS4_VERIFIER_SIZE        = 8;
   const NFS4_OPAQUE_LIMIT         = 1024;

   /*
    * File types
    */
   enum nfs_ftype4 {
           NF4REG          = 1,    /* Regular File */
           NF4DIR          = 2,    /* Directory */
           NF4BLK          = 3,    /* Special File - block device */

           NF4CHR          = 4,    /* Special File - character device */
           NF4LNK          = 5,    /* Symbolic Link */
           NF4SOCK         = 6,    /* Special File - socket */
           NF4FIFO         = 7,    /* Special File - fifo */
           NF4ATTRDIR      = 8,    /* Attribute Directory */
           NF4NAMEDATTR    = 9     /* Named Attribute */
   };

   /*
    * Error status
    */
   enum nfsstat4 {
           NFS4_OK                 = 0,    /* everything is okay      */
           NFS4ERR_PERM            = 1,    /* caller not privileged   */
           NFS4ERR_NOENT           = 2,    /* no such file/directory  */
           NFS4ERR_IO              = 5,    /* hard I/O error          */
           NFS4ERR_NXIO            = 6,    /* no such device          */
           NFS4ERR_ACCESS          = 13,   /* access denied           */
           NFS4ERR_EXIST           = 17,   /* file already exists     */
           NFS4ERR_XDEV            = 18,   /* different filesystems   */
           /* Unused/reserved        19 */
           NFS4ERR_NOTDIR          = 20,   /* should be a directory   */
           NFS4ERR_ISDIR           = 21,   /* should not be directory */
           NFS4ERR_INVAL           = 22,   /* invalid argument        */
           NFS4ERR_FBIG            = 27,   /* file exceeds server max */
           NFS4ERR_NOSPC           = 28,   /* no space on filesystem  */
           NFS4ERR_ROFS            = 30,   /* read-only filesystem    */
           NFS4ERR_MLINK           = 31,   /* too many hard links     */
           NFS4ERR_NAMETOOLONG     = 63,   /* name exceeds server max */
           NFS4ERR_NOTEMPTY        = 66,   /* directory not empty     */
           NFS4ERR_DQUOT           = 69,   /* hard quota limit reached*/
           NFS4ERR_STALE           = 70,   /* file no longer exists   */
           NFS4ERR_BADHANDLE       = 10001,/* Illegal filehandle      */
           NFS4ERR_BAD_COOKIE      = 10003,/* READDIR cookie is stale */
           NFS4ERR_NOTSUPP         = 10004,/* operation not supported */
           NFS4ERR_TOOSMALL        = 10005,/* response limit exceeded */
           NFS4ERR_SERVERFAULT     = 10006,/* undefined server error  */
           NFS4ERR_BADTYPE         = 10007,/* type invalid for CREATE */
           NFS4ERR_DELAY           = 10008,/* file "busy" - retry     */
           NFS4ERR_SAME            = 10009,/* nverify says attrs same */
           NFS4ERR_DENIED          = 10010,/* lock unavailable        */
           NFS4ERR_EXPIRED         = 10011,/* lock lease expired      */
           NFS4ERR_LOCKED          = 10012,/* I/O failed due to lock  */
           NFS4ERR_GRACE           = 10013,/* in grace period         */
           NFS4ERR_FHEXPIRED       = 10014,/* filehandle expired      */
           NFS4ERR_SHARE_DENIED    = 10015,/* share reserve denied    */
           NFS4ERR_WRONGSEC        = 10016,/* wrong security flavor   */
           NFS4ERR_CLID_INUSE      = 10017,/* clientid in use         */

           NFS4ERR_RESOURCE        = 10018,/* resource exhaustion     */
           NFS4ERR_MOVED           = 10019,/* filesystem relocated    */
           NFS4ERR_NOFILEHANDLE    = 10020,/* current FH is not set   */
           NFS4ERR_MINOR_VERS_MISMATCH = 10021,/* minor vers not supp */
           NFS4ERR_STALE_CLIENTID  = 10022,/* server has rebooted     */
           NFS4ERR_STALE_STATEID   = 10023,/* server has rebooted     */
           NFS4ERR_OLD_STATEID     = 10024,/* state is out of sync    */
           NFS4ERR_BAD_STATEID     = 10025,/* incorrect stateid       */
           NFS4ERR_BAD_SEQID       = 10026,/* request is out of seq.  */
           NFS4ERR_NOT_SAME        = 10027,/* verify - attrs not same */
           NFS4ERR_LOCK_RANGE      = 10028,/* lock range not supported*/
           NFS4ERR_SYMLINK         = 10029,/* should be file/directory*/
           NFS4ERR_RESTOREFH       = 10030,/* no saved filehandle     */
           NFS4ERR_LEASE_MOVED     = 10031,/* some filesystem moved   */
           NFS4ERR_ATTRNOTSUPP     = 10032,/* recommended attr not sup*/
           NFS4ERR_NO_GRACE        = 10033,/* reclaim outside of grace*/
           NFS4ERR_RECLAIM_BAD     = 10034,/* reclaim error at server */
           NFS4ERR_RECLAIM_CONFLICT = 10035,/* conflict on reclaim    */
           NFS4ERR_BADXDR          = 10036,/* XDR decode failed       */
           NFS4ERR_LOCKS_HELD      = 10037,/* file locks held at CLOSE*/
           NFS4ERR_OPENMODE        = 10038,/* conflict in OPEN and I/O*/
           NFS4ERR_BADOWNER        = 10039,/* owner translation bad   */
           NFS4ERR_BADCHAR         = 10040,/* utf-8 char not supported*/
           NFS4ERR_BADNAME         = 10041,/* name not supported      */
           NFS4ERR_BAD_RANGE       = 10042,/* lock range not supported*/
           NFS4ERR_LOCK_NOTSUPP    = 10043,/* no atomic up/downgrade  */
           NFS4ERR_OP_ILLEGAL      = 10044,/* undefined operation     */
           NFS4ERR_DEADLOCK        = 10045,/* file locking deadlock   */
           NFS4ERR_FILE_OPEN       = 10046,/* open file blocks op.    */
           NFS4ERR_ADMIN_REVOKED   = 10047,/* lockowner state revoked */
           NFS4ERR_CB_PATH_DOWN    = 10048 /* callback path down      */
   };

   /*
    * Basic data types
    */
   typedef uint32_t        bitmap4<>;
   typedef uint64_t        offset4;
   typedef uint32_t        count4;
   typedef uint64_t        length4;
   typedef uint64_t        clientid4;
   typedef uint32_t        seqid4;
   typedef opaque          utf8string<>;
   typedef utf8string      utf8str_cis;
   typedef utf8string      utf8str_cs;
   typedef utf8string      utf8str_mixed;
   typedef utf8str_cs      component4;
   typedef component4      pathname4<>;

   typedef uint64_t        nfs_lockid4;
   typedef uint64_t        nfs_cookie4;
   typedef utf8str_cs      linktext4;
   typedef opaque          sec_oid4<>;
   typedef uint32_t        qop4;
   typedef uint32_t        mode4;
   typedef uint64_t        changeid4;
   typedef opaque          verifier4[NFS4_VERIFIER_SIZE];

   /*
    * Timeval
    */
   struct nfstime4 {
           int64_t         seconds;
           uint32_t        nseconds;
   };

   enum time_how4 {
           SET_TO_SERVER_TIME4 = 0,
           SET_TO_CLIENT_TIME4 = 1
   };

   union settime4 switch (time_how4 set_it) {
    case SET_TO_CLIENT_TIME4:
            nfstime4       time;
    default:
            void;
   };

   /*
    * File access handle
    */
   typedef opaque  nfs_fh4<NFS4_FHSIZE>;

   /*
    * File attribute definitions
    */

   /*
    * FSID structure for major/minor
    */
   struct fsid4 {
           uint64_t        major;
           uint64_t        minor;
   };

   /*

    * Filesystem locations attribute for relocation/migration
    */
   struct fs_location4 {
           utf8str_cis     server<>;
           pathname4       rootpath;
   };

   struct fs_locations4 {
           pathname4       fs_root;
           fs_location4    locations<>;
   };

   /*
    * Various Access Control Entry definitions
    */

   /*
    * Mask that indicates which Access Control Entries are supported.
    * Values for the fattr4_aclsupport attribute.
    */
   const ACL4_SUPPORT_ALLOW_ACL    = 0x00000001;
   const ACL4_SUPPORT_DENY_ACL     = 0x00000002;
   const ACL4_SUPPORT_AUDIT_ACL    = 0x00000004;
   const ACL4_SUPPORT_ALARM_ACL    = 0x00000008;

   typedef uint32_t        acetype4;
   /*
    * acetype4 values, others can be added as needed.
    */
   const ACE4_ACCESS_ALLOWED_ACE_TYPE      = 0x00000000;
   const ACE4_ACCESS_DENIED_ACE_TYPE       = 0x00000001;
   const ACE4_SYSTEM_AUDIT_ACE_TYPE        = 0x00000002;
   const ACE4_SYSTEM_ALARM_ACE_TYPE        = 0x00000003;

   /*
    * ACE flag
    */
   typedef uint32_t aceflag4;

   /*
    * ACE flag values
    */
   const ACE4_FILE_INHERIT_ACE             = 0x00000001;
   const ACE4_DIRECTORY_INHERIT_ACE        = 0x00000002;
   const ACE4_NO_PROPAGATE_INHERIT_ACE     = 0x00000004;
   const ACE4_INHERIT_ONLY_ACE             = 0x00000008;

   const ACE4_SUCCESSFUL_ACCESS_ACE_FLAG   = 0x00000010;
   const ACE4_FAILED_ACCESS_ACE_FLAG       = 0x00000020;
   const ACE4_IDENTIFIER_GROUP             = 0x00000040;

   /*
    * ACE mask
    */
   typedef uint32_t        acemask4;

   /*
    * ACE mask values
    */
   const ACE4_READ_DATA            = 0x00000001;
   const ACE4_LIST_DIRECTORY       = 0x00000001;
   const ACE4_WRITE_DATA           = 0x00000002;
   const ACE4_ADD_FILE             = 0x00000002;
   const ACE4_APPEND_DATA          = 0x00000004;
   const ACE4_ADD_SUBDIRECTORY     = 0x00000004;
   const ACE4_READ_NAMED_ATTRS     = 0x00000008;
   const ACE4_WRITE_NAMED_ATTRS    = 0x00000010;
   const ACE4_EXECUTE              = 0x00000020;
   const ACE4_DELETE_CHILD         = 0x00000040;
   const ACE4_READ_ATTRIBUTES      = 0x00000080;
   const ACE4_WRITE_ATTRIBUTES     = 0x00000100;

   const ACE4_DELETE               = 0x00010000;
   const ACE4_READ_ACL             = 0x00020000;
   const ACE4_WRITE_ACL            = 0x00040000;
   const ACE4_WRITE_OWNER          = 0x00080000;
   const ACE4_SYNCHRONIZE          = 0x00100000;

   /*
    * ACE4_GENERIC_READ -- defined as combination of
    *      ACE4_READ_ACL |
    *      ACE4_READ_DATA |
    *      ACE4_READ_ATTRIBUTES |
    *      ACE4_SYNCHRONIZE
    */

   const ACE4_GENERIC_READ = 0x00120081;

   /*
    * ACE4_GENERIC_WRITE -- defined as combination of
    *      ACE4_READ_ACL |
    *      ACE4_WRITE_DATA |
    *      ACE4_WRITE_ATTRIBUTES |
    *      ACE4_WRITE_ACL |

    *      ACE4_APPEND_DATA |
    *      ACE4_SYNCHRONIZE
    */
   const ACE4_GENERIC_WRITE = 0x00160106;

   /*
    * ACE4_GENERIC_EXECUTE -- defined as combination of
    *      ACE4_READ_ACL
    *      ACE4_READ_ATTRIBUTES
    *      ACE4_EXECUTE
    *      ACE4_SYNCHRONIZE
    */
   const ACE4_GENERIC_EXECUTE = 0x001200A0;

   /*
    * Access Control Entry definition
    */
   struct nfsace4 {
           acetype4        type;
           aceflag4        flag;
           acemask4        access_mask;
           utf8str_mixed   who;
   };

   /*
    * Field definitions for the fattr4_mode attribute
    */
   const MODE4_SUID = 0x800;  /* set user id on execution */
   const MODE4_SGID = 0x400;  /* set group id on execution */
   const MODE4_SVTX = 0x200;  /* save text even after use */
   const MODE4_RUSR = 0x100;  /* read permission: owner */
   const MODE4_WUSR = 0x080;  /* write permission: owner */
   const MODE4_XUSR = 0x040;  /* execute permission: owner */
   const MODE4_RGRP = 0x020;  /* read permission: group */
   const MODE4_WGRP = 0x010;  /* write permission: group */
   const MODE4_XGRP = 0x008;  /* execute permission: group */
   const MODE4_ROTH = 0x004;  /* read permission: other */
   const MODE4_WOTH = 0x002;  /* write permission: other */
   const MODE4_XOTH = 0x001;  /* execute permission: other */

   /*
    * Special data/attribute associated with
    * file types NF4BLK and NF4CHR.
    */
   struct specdata4 {
           uint32_t        specdata1;      /* major device number */

           uint32_t        specdata2;      /* minor device number */
   };

   /*
    * Values for fattr4_fh_expire_type
    */
   const   FH4_PERSISTENT          = 0x00000000;
   const   FH4_NOEXPIRE_WITH_OPEN  = 0x00000001;
   const   FH4_VOLATILE_ANY        = 0x00000002;
   const   FH4_VOL_MIGRATION       = 0x00000004;
   const   FH4_VOL_RENAME          = 0x00000008;

   typedef bitmap4         fattr4_supported_attrs;
   typedef nfs_ftype4      fattr4_type;
   typedef uint32_t        fattr4_fh_expire_type;
   typedef changeid4       fattr4_change;
   typedef uint64_t        fattr4_size;
   typedef bool            fattr4_link_support;
   typedef bool            fattr4_symlink_support;
   typedef bool            fattr4_named_attr;
   typedef fsid4           fattr4_fsid;
   typedef bool            fattr4_unique_handles;
   typedef uint32_t        fattr4_lease_time;
   typedef nfsstat4        fattr4_rdattr_error;

   typedef nfsace4         fattr4_acl<>;
   typedef uint32_t        fattr4_aclsupport;
   typedef bool            fattr4_archive;
   typedef bool            fattr4_cansettime;
   typedef bool            fattr4_case_insensitive;
   typedef bool            fattr4_case_preserving;
   typedef bool            fattr4_chown_restricted;
   typedef uint64_t        fattr4_fileid;
   typedef uint64_t        fattr4_files_avail;
   typedef nfs_fh4         fattr4_filehandle;
   typedef uint64_t        fattr4_files_free;
   typedef uint64_t        fattr4_files_total;
   typedef fs_locations4   fattr4_fs_locations;
   typedef bool            fattr4_hidden;
   typedef bool            fattr4_homogeneous;
   typedef uint64_t        fattr4_maxfilesize;
   typedef uint32_t        fattr4_maxlink;
   typedef uint32_t        fattr4_maxname;
   typedef uint64_t        fattr4_maxread;
   typedef uint64_t        fattr4_maxwrite;
   typedef utf8str_cs      fattr4_mimetype;
   typedef mode4           fattr4_mode;

   typedef uint64_t        fattr4_mounted_on_fileid;
   typedef bool            fattr4_no_trunc;
   typedef uint32_t        fattr4_numlinks;
   typedef utf8str_mixed   fattr4_owner;
   typedef utf8str_mixed   fattr4_owner_group;
   typedef uint64_t        fattr4_quota_avail_hard;
   typedef uint64_t        fattr4_quota_avail_soft;
   typedef uint64_t        fattr4_quota_used;
   typedef specdata4       fattr4_rawdev;
   typedef uint64_t        fattr4_space_avail;
   typedef uint64_t        fattr4_space_free;
   typedef uint64_t        fattr4_space_total;
   typedef uint64_t        fattr4_space_used;
   typedef bool            fattr4_system;
   typedef nfstime4        fattr4_time_access;
   typedef settime4        fattr4_time_access_set;
   typedef nfstime4        fattr4_time_backup;
   typedef nfstime4        fattr4_time_create;
   typedef nfstime4        fattr4_time_delta;
   typedef nfstime4        fattr4_time_metadata;
   typedef nfstime4        fattr4_time_modify;
   typedef settime4        fattr4_time_modify_set;

   /*
    * Mandatory Attributes
    */
   const FATTR4_SUPPORTED_ATTRS    = 0;
   const FATTR4_TYPE               = 1;
   const FATTR4_FH_EXPIRE_TYPE     = 2;
   const FATTR4_CHANGE             = 3;
   const FATTR4_SIZE               = 4;
   const FATTR4_LINK_SUPPORT       = 5;
   const FATTR4_SYMLINK_SUPPORT    = 6;
   const FATTR4_NAMED_ATTR         = 7;
   const FATTR4_FSID               = 8;
   const FATTR4_UNIQUE_HANDLES     = 9;
   const FATTR4_LEASE_TIME         = 10;
   const FATTR4_RDATTR_ERROR       = 11;
   const FATTR4_FILEHANDLE         = 19;

   /*
    * Recommended Attributes
    */
   const FATTR4_ACL                = 12;
   const FATTR4_ACLSUPPORT         = 13;
   const FATTR4_ARCHIVE            = 14;
   const FATTR4_CANSETTIME         = 15;

   const FATTR4_CASE_INSENSITIVE   = 16;
   const FATTR4_CASE_PRESERVING    = 17;
   const FATTR4_CHOWN_RESTRICTED   = 18;
   const FATTR4_FILEID             = 20;
   const FATTR4_FILES_AVAIL        = 21;
   const FATTR4_FILES_FREE         = 22;
   const FATTR4_FILES_TOTAL        = 23;
   const FATTR4_FS_LOCATIONS       = 24;
   const FATTR4_HIDDEN             = 25;
   const FATTR4_HOMOGENEOUS        = 26;
   const FATTR4_MAXFILESIZE        = 27;
   const FATTR4_MAXLINK            = 28;
   const FATTR4_MAXNAME            = 29;
   const FATTR4_MAXREAD            = 30;
   const FATTR4_MAXWRITE           = 31;
   const FATTR4_MIMETYPE           = 32;
   const FATTR4_MODE               = 33;
   const FATTR4_NO_TRUNC           = 34;
   const FATTR4_NUMLINKS           = 35;
   const FATTR4_OWNER              = 36;
   const FATTR4_OWNER_GROUP        = 37;
   const FATTR4_QUOTA_AVAIL_HARD   = 38;
   const FATTR4_QUOTA_AVAIL_SOFT   = 39;
   const FATTR4_QUOTA_USED         = 40;
   const FATTR4_RAWDEV             = 41;
   const FATTR4_SPACE_AVAIL        = 42;
   const FATTR4_SPACE_FREE         = 43;
   const FATTR4_SPACE_TOTAL        = 44;
   const FATTR4_SPACE_USED         = 45;
   const FATTR4_SYSTEM             = 46;
   const FATTR4_TIME_ACCESS        = 47;
   const FATTR4_TIME_ACCESS_SET    = 48;
   const FATTR4_TIME_BACKUP        = 49;
   const FATTR4_TIME_CREATE        = 50;
   const FATTR4_TIME_DELTA         = 51;
   const FATTR4_TIME_METADATA      = 52;
   const FATTR4_TIME_MODIFY        = 53;
   const FATTR4_TIME_MODIFY_SET    = 54;
   const FATTR4_MOUNTED_ON_FILEID  = 55;

   typedef opaque  attrlist4<>;

   /*
    * File attribute container
    */
   struct fattr4 {
           bitmap4         attrmask;
           attrlist4       attr_vals;

   };

   /*
    * Change info for the client
    */
   struct change_info4 {
           bool            atomic;
           changeid4       before;
           changeid4       after;
   };

   struct clientaddr4 {
           /* see struct rpcb in RFC 1833 */
           string r_netid<>;               /* network id */
           string r_addr<>;                /* universal address */
   };

   /*
    * Callback program info as provided by the client
    */
   struct cb_client4 {
           uint32_t        cb_program;
           clientaddr4     cb_location;
   };

   /*
    * Stateid
    */
   struct stateid4 {
           uint32_t        seqid;
           opaque          other[12];
   };

   /*
    * Client ID
    */
   struct nfs_client_id4 {
           verifier4       verifier;
           opaque          id<NFS4_OPAQUE_LIMIT>;
   };

   struct open_owner4 {
           clientid4       clientid;
           opaque          owner<NFS4_OPAQUE_LIMIT>;
   };

   struct lock_owner4 {
           clientid4       clientid;

           opaque          owner<NFS4_OPAQUE_LIMIT>;
   };

   enum nfs_lock_type4 {
           READ_LT         = 1,
           WRITE_LT        = 2,
           READW_LT        = 3,    /* blocking read */
           WRITEW_LT       = 4     /* blocking write */
   };

   /*
    * ACCESS: Check access permission
    */
   const ACCESS4_READ      = 0x00000001;
   const ACCESS4_LOOKUP    = 0x00000002;
   const ACCESS4_MODIFY    = 0x00000004;
   const ACCESS4_EXTEND    = 0x00000008;
   const ACCESS4_DELETE    = 0x00000010;
   const ACCESS4_EXECUTE   = 0x00000020;

   struct ACCESS4args {
           /* CURRENT_FH: object */
           uint32_t        access;
   };

   struct ACCESS4resok {
           uint32_t        supported;
           uint32_t        access;
   };

   union ACCESS4res switch (nfsstat4 status) {
    case NFS4_OK:
            ACCESS4resok   resok4;
    default:
            void;
   };

   /*
    * CLOSE: Close a file and release share reservations
    */
   struct CLOSE4args {
           /* CURRENT_FH: object */
           seqid4          seqid;
           stateid4        open_stateid;
   };

   union CLOSE4res switch (nfsstat4 status) {
    case NFS4_OK:

            stateid4       open_stateid;
    default:
            void;
   };

   /*
    * COMMIT: Commit cached data on server to stable storage
    */
   struct COMMIT4args {
           /* CURRENT_FH: file */
           offset4         offset;
           count4          count;
   };

   struct COMMIT4resok {
           verifier4       writeverf;
   };

   union COMMIT4res switch (nfsstat4 status) {
    case NFS4_OK:
            COMMIT4resok   resok4;
    default:
            void;
   };

   /*
    * CREATE: Create a non-regular file
    */
   union createtype4 switch (nfs_ftype4 type) {
    case NF4LNK:
            linktext4      linkdata;
    case NF4BLK:
    case NF4CHR:
            specdata4      devdata;
    case NF4SOCK:
    case NF4FIFO:
    case NF4DIR:
            void;
    default:
            void;          /* server should return NFS4ERR_BADTYPE */
   };

   struct CREATE4args {
           /* CURRENT_FH: directory for creation */
           createtype4     objtype;
           component4      objname;
           fattr4          createattrs;

   };

   struct CREATE4resok {
           change_info4    cinfo;
           bitmap4         attrset;        /* attributes set */
   };

   union CREATE4res switch (nfsstat4 status) {
    case NFS4_OK:
            CREATE4resok resok4;
    default:
            void;
   };

   /*
    * DELEGPURGE: Purge Delegations Awaiting Recovery
    */
   struct DELEGPURGE4args {
           clientid4       clientid;
   };

   struct DELEGPURGE4res {
           nfsstat4        status;
   };

   /*
    * DELEGRETURN: Return a delegation
    */
   struct DELEGRETURN4args {
           /* CURRENT_FH: delegated file */
           stateid4        deleg_stateid;
   };

   struct DELEGRETURN4res {
           nfsstat4        status;
   };

   /*
    * GETATTR: Get file attributes
    */
   struct GETATTR4args {
           /* CURRENT_FH: directory or file */
           bitmap4         attr_request;
   };

   struct GETATTR4resok {
           fattr4          obj_attributes;
   };

   union GETATTR4res switch (nfsstat4 status) {
    case NFS4_OK:
            GETATTR4resok  resok4;
    default:
            void;
   };

   /*
    * GETFH: Get current filehandle
    */
   struct GETFH4resok {
           nfs_fh4         object;
   };

   union GETFH4res switch (nfsstat4 status) {
    case NFS4_OK:
           GETFH4resok     resok4;
    default:
           void;
   };

   /*
    * LINK: Create link to an object
    */
   struct LINK4args {
           /* SAVED_FH: source object */
           /* CURRENT_FH: target directory */
           component4      newname;
   };

   struct LINK4resok {
           change_info4    cinfo;
   };

   union LINK4res switch (nfsstat4 status) {
    case NFS4_OK:
            LINK4resok resok4;
    default:
            void;
   };

   /*
    * For LOCK, transition from open_owner to new lock_owner
    */
   struct open_to_lock_owner4 {
           seqid4          open_seqid;
           stateid4        open_stateid;
           seqid4          lock_seqid;

           lock_owner4     lock_owner;
   };

   /*
    * For LOCK, existing lock_owner continues to request file locks
    */
   struct exist_lock_owner4 {
           stateid4        lock_stateid;
           seqid4          lock_seqid;
   };

   union locker4 switch (bool new_lock_owner) {
    case TRUE:
           open_to_lock_owner4     open_owner;
    case FALSE:
           exist_lock_owner4       lock_owner;
   };

   /*
    * LOCK/LOCKT/LOCKU: Record lock management
    */
   struct LOCK4args {
           /* CURRENT_FH: file */
           nfs_lock_type4  locktype;
           bool            reclaim;
           offset4         offset;
           length4         length;
           locker4         locker;
   };

   struct LOCK4denied {
           offset4         offset;
           length4         length;
           nfs_lock_type4  locktype;
           lock_owner4     owner;
   };

   struct LOCK4resok {
           stateid4        lock_stateid;
   };

   union LOCK4res switch (nfsstat4 status) {
    case NFS4_OK:
            LOCK4resok     resok4;
    case NFS4ERR_DENIED:
            LOCK4denied    denied;
    default:
            void;

   };

   struct LOCKT4args {
           /* CURRENT_FH: file */
           nfs_lock_type4  locktype;
           offset4         offset;
           length4         length;
           lock_owner4     owner;
   };

   union LOCKT4res switch (nfsstat4 status) {
    case NFS4ERR_DENIED:
            LOCK4denied    denied;
    case NFS4_OK:
            void;
    default:
            void;
   };

   struct LOCKU4args {
           /* CURRENT_FH: file */
           nfs_lock_type4  locktype;
           seqid4          seqid;
           stateid4        lock_stateid;
           offset4         offset;
           length4         length;
   };

   union LOCKU4res switch (nfsstat4 status) {
    case   NFS4_OK:
            stateid4       lock_stateid;
    default:
            void;
   };

   /*
    * LOOKUP: Lookup filename
    */
   struct LOOKUP4args {
           /* CURRENT_FH: directory */
           component4      objname;
   };

   struct LOOKUP4res {
           /* CURRENT_FH: object */
           nfsstat4        status;
   };

   /*
    * LOOKUPP: Lookup parent directory
    */
   struct LOOKUPP4res {
           /* CURRENT_FH: directory */
           nfsstat4        status;
   };

   /*
    * NVERIFY: Verify attributes different
    */
   struct NVERIFY4args {
           /* CURRENT_FH: object */
           fattr4          obj_attributes;
   };

   struct NVERIFY4res {
           nfsstat4        status;
   };

   /*
    * Various definitions for OPEN
    */
   enum createmode4 {
           UNCHECKED4      = 0,
           GUARDED4        = 1,
           EXCLUSIVE4      = 2
   };

   union createhow4 switch (createmode4 mode) {
    case UNCHECKED4:
    case GUARDED4:
            fattr4         createattrs;
    case EXCLUSIVE4:
            verifier4      createverf;
   };

   enum opentype4 {
           OPEN4_NOCREATE  = 0,
           OPEN4_CREATE    = 1
   };

   union openflag4 switch (opentype4 opentype) {
    case OPEN4_CREATE:
            createhow4     how;
    default:
            void;
   };

   /* Next definitions used for OPEN delegation */
   enum limit_by4 {
           NFS_LIMIT_SIZE          = 1,
           NFS_LIMIT_BLOCKS        = 2
           /* others as needed */
   };

   struct nfs_modified_limit4 {
           uint32_t        num_blocks;
           uint32_t        bytes_per_block;
   };

   union nfs_space_limit4 switch (limit_by4 limitby) {
    /* limit specified as file size */
    case NFS_LIMIT_SIZE:
            uint64_t               filesize;
    /* limit specified by number of blocks */
    case NFS_LIMIT_BLOCKS:
            nfs_modified_limit4    mod_blocks;
   } ;

   /*
    * Share Access and Deny constants for open argument
    */
   const OPEN4_SHARE_ACCESS_READ   = 0x00000001;
   const OPEN4_SHARE_ACCESS_WRITE  = 0x00000002;
   const OPEN4_SHARE_ACCESS_BOTH   = 0x00000003;

   const OPEN4_SHARE_DENY_NONE     = 0x00000000;
   const OPEN4_SHARE_DENY_READ     = 0x00000001;
   const OPEN4_SHARE_DENY_WRITE    = 0x00000002;
   const OPEN4_SHARE_DENY_BOTH     = 0x00000003;

   enum open_delegation_type4 {
           OPEN_DELEGATE_NONE      = 0,
           OPEN_DELEGATE_READ      = 1,
           OPEN_DELEGATE_WRITE     = 2
   };

   enum open_claim_type4 {
           CLAIM_NULL              = 0,
           CLAIM_PREVIOUS          = 1,
           CLAIM_DELEGATE_CUR      = 2,
           CLAIM_DELEGATE_PREV     = 3
   };

   struct open_claim_delegate_cur4 {
           stateid4        delegate_stateid;

           component4      file;
   };

   union open_claim4 switch (open_claim_type4 claim) {
    /*
     * No special rights to file. Ordinary OPEN of the specified file.
     */
    case CLAIM_NULL:
           /* CURRENT_FH: directory */
           component4      file;

    /*
     * Right to the file established by an open previous to server
     * reboot.  File identified by filehandle obtained at that time
     * rather than by name.
     */
    case CLAIM_PREVIOUS:
           /* CURRENT_FH: file being reclaimed */
           open_delegation_type4   delegate_type;

    /*
     * Right to file based on a delegation granted by the server.
     * File is specified by name.
     */
    case CLAIM_DELEGATE_CUR:
           /* CURRENT_FH: directory */
           open_claim_delegate_cur4        delegate_cur_info;

    /* Right to file based on a delegation granted to a previous boot
     * instance of the client.  File is specified by name.
     */
    case CLAIM_DELEGATE_PREV:
            /* CURRENT_FH: directory */
           component4      file_delegate_prev;
   };

   /*
    * OPEN: Open a file, potentially receiving an open delegation
    */
   struct OPEN4args {
           seqid4          seqid;
           uint32_t        share_access;
           uint32_t        share_deny;
           open_owner4     owner;
           openflag4       openhow;
           open_claim4     claim;
   };

   struct open_read_delegation4 {
           stateid4        stateid;        /* Stateid for delegation*/
           bool            recall;         /* Pre-recalled flag for
                                              delegations obtained
                                              by reclaim
                                              (CLAIM_PREVIOUS) */
           nfsace4         permissions;    /* Defines users who don't
                                              need an ACCESS call to
                                              open for read */
   };

   struct open_write_delegation4 {
           stateid4        stateid;        /* Stateid for delegation */
           bool            recall;         /* Pre-recalled flag for
                                              delegations obtained
                                              by reclaim
                                              (CLAIM_PREVIOUS) */
           nfs_space_limit4 space_limit;   /* Defines condition that
                                              the client must check to
                                              determine whether the
                                              file needs to be flushed
                                              to the server on close.
                                              */
           nfsace4         permissions;    /* Defines users who don't
                                              need an ACCESS call as
                                              part of a delegated
                                              open. */
   };

   union open_delegation4
   switch (open_delegation_type4 delegation_type) {
           case OPEN_DELEGATE_NONE:
                   void;
           case OPEN_DELEGATE_READ:
                   open_read_delegation4 read;
           case OPEN_DELEGATE_WRITE:
                   open_write_delegation4 write;
   };
   /*
    * Result flags
    */
   /* Client must confirm open */
   const OPEN4_RESULT_CONFIRM      = 0x00000002;
   /* Type of file locking behavior at the server */
   const OPEN4_RESULT_LOCKTYPE_POSIX = 0x00000004;

   struct OPEN4resok {
           stateid4        stateid;        /* Stateid for open */

           change_info4    cinfo;          /* Directory Change Info */
           uint32_t        rflags;         /* Result flags */
           bitmap4         attrset;        /* attribute set for create*/
           open_delegation4 delegation;    /* Info on any open
                                              delegation */
   };

   union OPEN4res switch (nfsstat4 status) {
    case NFS4_OK:
           /* CURRENT_FH: opened file */
           OPEN4resok      resok4;
    default:
           void;
   };

   /*
    * OPENATTR: open named attributes directory
    */
   struct OPENATTR4args {
           /* CURRENT_FH: object */
           bool    createdir;
   };

   struct OPENATTR4res {
           /* CURRENT_FH: named attr directory */
           nfsstat4        status;
   };

   /*
    * OPEN_CONFIRM: confirm the open
    */
   struct OPEN_CONFIRM4args {
           /* CURRENT_FH: opened file */
           stateid4        open_stateid;
           seqid4          seqid;
   };

   struct OPEN_CONFIRM4resok {
           stateid4        open_stateid;
   };

   union OPEN_CONFIRM4res switch (nfsstat4 status) {
       case NFS4_OK:
               OPEN_CONFIRM4resok     resok4;
    default:
            void;
   };

   /*
    * OPEN_DOWNGRADE: downgrade the access/deny for a file
    */
   struct OPEN_DOWNGRADE4args {
           /* CURRENT_FH: opened file */
           stateid4        open_stateid;
           seqid4          seqid;
           uint32_t        share_access;
           uint32_t        share_deny;
   };

   struct OPEN_DOWNGRADE4resok {
           stateid4        open_stateid;
   };

   union OPEN_DOWNGRADE4res switch(nfsstat4 status) {
    case NFS4_OK:
           OPEN_DOWNGRADE4resok    resok4;
    default:
            void;
   };

   /*
    * PUTFH: Set current filehandle
    */
   struct PUTFH4args {
           nfs_fh4         object;
   };

   struct PUTFH4res {
           /* CURRENT_FH: */
           nfsstat4        status;
   };

   /*
    * PUTPUBFH: Set public filehandle
    */
   struct PUTPUBFH4res {
           /* CURRENT_FH: public fh */
           nfsstat4        status;
   };

   /*
    * PUTROOTFH: Set root filehandle
    */
   struct PUTROOTFH4res {

           /* CURRENT_FH: root fh */

           nfsstat4        status;
   };

   /*
    * READ: Read from file
    */
   struct READ4args {
           /* CURRENT_FH: file */
           stateid4        stateid;
           offset4         offset;
           count4          count;
   };

   struct READ4resok {
           bool            eof;
           opaque          data<>;
   };

   union READ4res switch (nfsstat4 status) {
    case NFS4_OK:
            READ4resok     resok4;
    default:
            void;
   };

   /*
    * READDIR: Read directory
    */
   struct READDIR4args {
           /* CURRENT_FH: directory */
           nfs_cookie4     cookie;
           verifier4       cookieverf;
           count4          dircount;
           count4          maxcount;
           bitmap4         attr_request;
   };

   struct entry4 {
           nfs_cookie4     cookie;
           component4      name;
           fattr4          attrs;
           entry4          *nextentry;
   };

   struct dirlist4 {
           entry4          *entries;
           bool            eof;
   };

   struct READDIR4resok {
           verifier4       cookieverf;
           dirlist4        reply;
   };

   union READDIR4res switch (nfsstat4 status) {
    case NFS4_OK:
            READDIR4resok  resok4;
    default:
            void;
   };

   /*
    * READLINK: Read symbolic link
    */
   struct READLINK4resok {
           linktext4       link;
   };

   union READLINK4res switch (nfsstat4 status) {
    case NFS4_OK:
            READLINK4resok resok4;
    default:
            void;
   };

   /*
    * REMOVE: Remove filesystem object
    */
   struct REMOVE4args {
           /* CURRENT_FH: directory */
           component4      target;
   };

   struct REMOVE4resok {
           change_info4    cinfo;
   };

   union REMOVE4res switch (nfsstat4 status) {
    case NFS4_OK:
            REMOVE4resok   resok4;
    default:
            void;
   };

   /*

    * RENAME: Rename directory entry
    */
   struct RENAME4args {
           /* SAVED_FH: source directory */
           component4      oldname;
           /* CURRENT_FH: target directory */

           component4      newname;
   };

   struct RENAME4resok {
           change_info4    source_cinfo;
           change_info4    target_cinfo;
   };

   union RENAME4res switch (nfsstat4 status) {
    case NFS4_OK:
           RENAME4resok    resok4;
    default:
           void;
   };

   /*
    * RENEW: Renew a Lease
    */
   struct RENEW4args {
           clientid4       clientid;
   };

   struct RENEW4res {
           nfsstat4        status;
   };

   /*
    * RESTOREFH: Restore saved filehandle
    */

   struct RESTOREFH4res {
           /* CURRENT_FH: value of saved fh */
           nfsstat4        status;
   };

   /*
    * SAVEFH: Save current filehandle
    */
   struct SAVEFH4res {
           /* SAVED_FH: value of current fh */
           nfsstat4        status;

   };

   /*
    * SECINFO: Obtain Available Security Mechanisms
    */
   struct SECINFO4args {
           /* CURRENT_FH: directory */
           component4      name;
   };

   /*

    * From RFC 2203
    */
   enum rpc_gss_svc_t {
           RPC_GSS_SVC_NONE        = 1,
           RPC_GSS_SVC_INTEGRITY   = 2,
           RPC_GSS_SVC_PRIVACY     = 3
   };

   struct rpcsec_gss_info {
           sec_oid4        oid;
           qop4            qop;
           rpc_gss_svc_t   service;
   };

   /* RPCSEC_GSS has a value of '6' - See RFC 2203 */
   union secinfo4 switch (uint32_t flavor) {
    case RPCSEC_GSS:
            rpcsec_gss_info        flavor_info;
    default:
            void;
   };

   typedef secinfo4 SECINFO4resok<>;

   union SECINFO4res switch (nfsstat4 status) {
    case NFS4_OK:
            SECINFO4resok resok4;
    default:
            void;
   };

   /*
    * SETATTR: Set attributes
    */
   struct SETATTR4args {
           /* CURRENT_FH: target object */

           stateid4        stateid;
           fattr4          obj_attributes;
   };

   struct SETATTR4res {
           nfsstat4        status;
           bitmap4         attrsset;
   };

   /*
    * SETCLIENTID
    */
   struct SETCLIENTID4args {
           nfs_client_id4  client;
           cb_client4      callback;
           uint32_t        callback_ident;

   };

   struct SETCLIENTID4resok {
           clientid4       clientid;
           verifier4       setclientid_confirm;
   };

   union SETCLIENTID4res switch (nfsstat4 status) {
    case NFS4_OK:
            SETCLIENTID4resok      resok4;
    case NFS4ERR_CLID_INUSE:
            clientaddr4    client_using;
    default:
            void;
   };

   struct SETCLIENTID_CONFIRM4args {
           clientid4       clientid;
           verifier4       setclientid_confirm;
   };

   struct SETCLIENTID_CONFIRM4res {
           nfsstat4        status;
   };

   /*
    * VERIFY: Verify attributes same
    */
   struct VERIFY4args {
           /* CURRENT_FH: object */
           fattr4          obj_attributes;

   };

   struct VERIFY4res {
           nfsstat4        status;
   };

   /*
    * WRITE: Write to file
    */
   enum stable_how4 {
           UNSTABLE4       = 0,
           DATA_SYNC4      = 1,
           FILE_SYNC4      = 2
   };

   struct WRITE4args {
           /* CURRENT_FH: file */
           stateid4        stateid;
           offset4         offset;
           stable_how4     stable;
           opaque          data<>;
   };

   struct WRITE4resok {
           count4          count;
           stable_how4     committed;
           verifier4       writeverf;
   };

   union WRITE4res switch (nfsstat4 status) {
    case NFS4_OK:
            WRITE4resok    resok4;
    default:
            void;
   };

   /*
    * RELEASE_LOCKOWNER: Notify server to release lockowner
    */
   struct RELEASE_LOCKOWNER4args {
           lock_owner4     lock_owner;
   };

   struct RELEASE_LOCKOWNER4res {
           nfsstat4        status;
   };

   /*

    * ILLEGAL: Response for illegal operation numbers
    */
   struct ILLEGAL4res {
           nfsstat4        status;
   };

   /*
    * Operation arrays
    */

   enum nfs_opnum4 {
           OP_ACCESS               = 3,
           OP_CLOSE                = 4,
           OP_COMMIT               = 5,
           OP_CREATE               = 6,
           OP_DELEGPURGE           = 7,
           OP_DELEGRETURN          = 8,
           OP_GETATTR              = 9,
           OP_GETFH                = 10,
           OP_LINK                 = 11,
           OP_LOCK                 = 12,
           OP_LOCKT                = 13,
           OP_LOCKU                = 14,
           OP_LOOKUP               = 15,
           OP_LOOKUPP              = 16,
           OP_NVERIFY              = 17,
           OP_OPEN                 = 18,
           OP_OPENATTR             = 19,
           OP_OPEN_CONFIRM         = 20,
           OP_OPEN_DOWNGRADE       = 21,
           OP_PUTFH                = 22,
           OP_PUTPUBFH             = 23,
           OP_PUTROOTFH            = 24,
           OP_READ                 = 25,
           OP_READDIR              = 26,
           OP_READLINK             = 27,
           OP_REMOVE               = 28,
           OP_RENAME               = 29,
           OP_RENEW                = 30,
           OP_RESTOREFH            = 31,
           OP_SAVEFH               = 32,
           OP_SECINFO              = 33,
           OP_SETATTR              = 34,
           OP_SETCLIENTID          = 35,
           OP_SETCLIENTID_CONFIRM  = 36,
           OP_VERIFY               = 37,
           OP_WRITE                = 38,
           OP_RELEASE_LOCKOWNER    = 39,

           OP_ILLEGAL              = 10044
   };

   union nfs_argop4 switch (nfs_opnum4 argop) {
    case OP_ACCESS:        ACCESS4args opaccess;
    case OP_CLOSE:         CLOSE4args opclose;
    case OP_COMMIT:        COMMIT4args opcommit;
    case OP_CREATE:        CREATE4args opcreate;
    case OP_DELEGPURGE:    DELEGPURGE4args opdelegpurge;
    case OP_DELEGRETURN:   DELEGRETURN4args opdelegreturn;
    case OP_GETATTR:       GETATTR4args opgetattr;
    case OP_GETFH:         void;
    case OP_LINK:          LINK4args oplink;
    case OP_LOCK:          LOCK4args oplock;
    case OP_LOCKT:         LOCKT4args oplockt;
    case OP_LOCKU:         LOCKU4args oplocku;
    case OP_LOOKUP:        LOOKUP4args oplookup;
    case OP_LOOKUPP:       void;
    case OP_NVERIFY:       NVERIFY4args opnverify;
    case OP_OPEN:          OPEN4args opopen;
    case OP_OPENATTR:      OPENATTR4args opopenattr;
    case OP_OPEN_CONFIRM:  OPEN_CONFIRM4args opopen_confirm;
    case OP_OPEN_DOWNGRADE:        OPEN_DOWNGRADE4args opopen_downgrade;
    case OP_PUTFH:         PUTFH4args opputfh;
    case OP_PUTPUBFH:      void;
    case OP_PUTROOTFH:     void;
    case OP_READ:          READ4args opread;
    case OP_READDIR:       READDIR4args opreaddir;
    case OP_READLINK:      void;
    case OP_REMOVE:        REMOVE4args opremove;
    case OP_RENAME:        RENAME4args oprename;
    case OP_RENEW:         RENEW4args oprenew;
    case OP_RESTOREFH:     void;
    case OP_SAVEFH:        void;
    case OP_SECINFO:       SECINFO4args opsecinfo;
    case OP_SETATTR:       SETATTR4args opsetattr;
    case OP_SETCLIENTID:   SETCLIENTID4args opsetclientid;
    case OP_SETCLIENTID_CONFIRM:   SETCLIENTID_CONFIRM4args
                                           opsetclientid_confirm;
    case OP_VERIFY:        VERIFY4args opverify;
    case OP_WRITE:         WRITE4args opwrite;
    case OP_RELEASE_LOCKOWNER:     RELEASE_LOCKOWNER4args
                                       oprelease_lockowner;
    case OP_ILLEGAL:       void;
   };

   union nfs_resop4 switch (nfs_opnum4 resop){
    case OP_ACCESS:        ACCESS4res opaccess;

    case OP_CLOSE:         CLOSE4res opclose;
    case OP_COMMIT:        COMMIT4res opcommit;
    case OP_CREATE:        CREATE4res opcreate;
    case OP_DELEGPURGE:    DELEGPURGE4res opdelegpurge;
    case OP_DELEGRETURN:   DELEGRETURN4res opdelegreturn;
    case OP_GETATTR:       GETATTR4res opgetattr;
    case OP_GETFH:         GETFH4res opgetfh;
    case OP_LINK:          LINK4res oplink;
    case OP_LOCK:          LOCK4res oplock;
    case OP_LOCKT:         LOCKT4res oplockt;
    case OP_LOCKU:         LOCKU4res oplocku;
    case OP_LOOKUP:        LOOKUP4res oplookup;
    case OP_LOOKUPP:       LOOKUPP4res oplookupp;
    case OP_NVERIFY:       NVERIFY4res opnverify;
    case OP_OPEN:          OPEN4res opopen;
    case OP_OPENATTR:      OPENATTR4res opopenattr;
    case OP_OPEN_CONFIRM:  OPEN_CONFIRM4res opopen_confirm;
    case OP_OPEN_DOWNGRADE:        OPEN_DOWNGRADE4res opopen_downgrade;
    case OP_PUTFH:         PUTFH4res opputfh;
    case OP_PUTPUBFH:      PUTPUBFH4res opputpubfh;
    case OP_PUTROOTFH:     PUTROOTFH4res opputrootfh;
    case OP_READ:          READ4res opread;
    case OP_READDIR:       READDIR4res opreaddir;
    case OP_READLINK:      READLINK4res opreadlink;
    case OP_REMOVE:        REMOVE4res opremove;
    case OP_RENAME:        RENAME4res oprename;
    case OP_RENEW:         RENEW4res oprenew;
    case OP_RESTOREFH:     RESTOREFH4res oprestorefh;
    case OP_SAVEFH:        SAVEFH4res opsavefh;
    case OP_SECINFO:       SECINFO4res opsecinfo;
    case OP_SETATTR:       SETATTR4res opsetattr;
    case OP_SETCLIENTID:   SETCLIENTID4res opsetclientid;
    case OP_SETCLIENTID_CONFIRM:   SETCLIENTID_CONFIRM4res
                                           opsetclientid_confirm;
    case OP_VERIFY:        VERIFY4res opverify;
    case OP_WRITE:         WRITE4res opwrite;
    case OP_RELEASE_LOCKOWNER:     RELEASE_LOCKOWNER4res
                                       oprelease_lockowner;
    case OP_ILLEGAL:       ILLEGAL4res opillegal;
   };

   struct COMPOUND4args {
           utf8str_cs      tag;
           uint32_t        minorversion;
           nfs_argop4      argarray<>;
   };

   struct COMPOUND4res {

           nfsstat4 status;
           utf8str_cs      tag;
           nfs_resop4      resarray<>;
   };

   /*
    * Remote file service routines
    */
   program NFS4_PROGRAM {
           version NFS_V4 {
                   void
                           NFSPROC4_NULL(void) = 0;

                   COMPOUND4res
                           NFSPROC4_COMPOUND(COMPOUND4args) = 1;

           } = 4;
   } = 100003;

   /*
    * NFS4 Callback Procedure Definitions and Program
    */

   /*
    * CB_GETATTR: Get Current Attributes
    */
   struct CB_GETATTR4args {
           nfs_fh4 fh;
           bitmap4 attr_request;
   };

   struct CB_GETATTR4resok {
           fattr4  obj_attributes;
   };

   union CB_GETATTR4res switch (nfsstat4 status) {
    case NFS4_OK:
            CB_GETATTR4resok       resok4;
    default:
            void;
   };

   /*
    * CB_RECALL: Recall an Open Delegation
    */
   struct CB_RECALL4args {

           stateid4        stateid;
           bool            truncate;
           nfs_fh4         fh;
   };

   struct CB_RECALL4res {
           nfsstat4        status;
   };

   /*
    * CB_ILLEGAL: Response for illegal operation numbers
    */
   struct CB_ILLEGAL4res {
           nfsstat4        status;
   };

   /*
    * Various definitions for CB_COMPOUND
    */
   enum nfs_cb_opnum4 {
           OP_CB_GETATTR           = 3,
           OP_CB_RECALL            = 4,
           OP_CB_ILLEGAL           = 10044
   };

   union nfs_cb_argop4 switch (unsigned argop) {
    case OP_CB_GETATTR:    CB_GETATTR4args opcbgetattr;
    case OP_CB_RECALL:     CB_RECALL4args  opcbrecall;
    case OP_CB_ILLEGAL:    void;
   };

   union nfs_cb_resop4 switch (unsigned resop){
    case OP_CB_GETATTR:    CB_GETATTR4res  opcbgetattr;
    case OP_CB_RECALL:     CB_RECALL4res   opcbrecall;
    case OP_CB_ILLEGAL:    CB_ILLEGAL4res  opcbillegal;
   };

   struct CB_COMPOUND4args {
           utf8str_cs      tag;
           uint32_t        minorversion;
           uint32_t        callback_ident;
           nfs_cb_argop4   argarray<>;
   };

   struct CB_COMPOUND4res {
           nfsstat4 status;
           utf8str_cs      tag;
           nfs_cb_resop4   resarray<>;

   };

   /*
    * Program number is in the transient range since the client
    * will assign the exact transient program number and provide
    * that to the server via the SETCLIENTID operation.
    */
   program NFS4_CALLBACK {
           version NFS_CB {
                   void
                           CB_NULL(void) = 0;
                   CB_COMPOUND4res
                           CB_COMPOUND(CB_COMPOUND4args) = 1;
           } = 1;
   } = 0x40000000;
```

---
## **19.  Acknowledgements**

저자는 다음 사항에 감사하고 인정합니다.

Neil Brown은 다양한 문서를 광범위하게 검토하고 의견을 제시했습니다. Guelph 대학의 Rick Macklem, Hummingbird Ltd.의 Mike Frisch, Sergey Klyushin 및 Dan Trufasiu, University of Michigan CITI 조직의 Andy Adamson, Bruce Fields, Jim Rees 및 Kendrick Smith의 구현 노력과 프로토콜 사양에 대한 피드백. 파일 잠금 및 ACL 메커니즘을 검토한 Mike Kupfer ACL 메커니즘에 대한 의견을 주신 Alan Yoder. 프로토콜 사양을 자세히 검토한 Peter Astrand. Ran Atkinson은 사용자가 중요하다는 점을 끊임없이 상기시켜주었습니다.

---
## **20.  Normative References**

```text
   [ISO10646]                "ISO/IEC 10646-1:1993. International
                             Standard -- Information technology --
                             Universal Multiple-Octet Coded Character
                             Set (UCS) -- Part 1: Architecture and Basic
                             Multilingual Plane."

   [RFC793]                  Postel, J., "Transmission Control
                             Protocol", STD 7, RFC 793, September 1981.

   [RFC1831]                 Srinivasan, R., "RPC: Remote Procedure Call
                             Protocol Specification Version 2", RFC
                             1831, August 1995.

   [RFC1832]                 Srinivasan, R., "XDR: External Data
                             Representation Standard", RFC 1832, August
                             1995.
```

\[RFC2373\] Hinden, R. 및 S. Deering, "IP 버전 6 주소 지정 아키텍처", RFC 2373, 1998년 7월.

```text
   [RFC1964]                 Linn, J., "The Kerberos Version 5 GSS-API
                             Mechanism", RFC 1964, June 1996.

   [RFC2025]                 Adams, C., "The Simple Public-Key GSS-API
                             Mechanism (SPKM)", RFC 2025, October 1996.
```

\[RFC2119\] Bradner, S., "요구 사항 수준을 나타 내기 위해 RFC에 사용되는 핵심 단어", BCP 14, RFC 2119, 1997년 3월.

\[RFC2203\] Eisler, M., Chiu, A. 및 L. Ling,

- "RPCSEC\_GSS 프로토콜 사양", RFC 2203, 1997년 9월.

\[RFC2277\] Alvestrand, H., "문자 집합 및 언어에 대한 IETF 정책", BCP 19, RFC 2277, 1998년 1월.

\[RFC2279\] Yergeau, F., "UTF-8, ISO 10646의 변환 형식", RFC 2279, 1998년 1월.

\[RFC2623\] Eisler, M., "NFS 버전 2 및 버전 3 보안 문제와 NFS 프로토콜의 RPCSEC\_GSS 및 Kerberos V5 사용", RFC 2623, 1999년 6월.

```text
   [RFC2743]                 Linn, J., "Generic Security Service
                             Application Program Interface, Version 2,
                             Update 1", RFC 2743, January 2000.
```

\[RFC2847\] Eisler, M., "LIPKEY - SPKM을 사용하는 낮은 인프라 공개 키 메커니즘", RFC 2847, 2000년 6월.

\[RFC3010\] Shepler, S., Callaghan, B., Robinson, D., Thurlow, R., Beame, C., Eisler, M. 및 D. Noveck, "NFS 버전 4 프로토콜", RFC 3010, 2000년 12월.

\[RFC3454\] Hoffman, P. 및 P. Blanchet, "국제화된 문자열 준비\("stringprep"\)", RFC 3454, 2002년 12월.

\[유니코드1\] 유니코드 컨소시엄, "유니코드 표준, 버전 3.0", Addison-Wesley Developers Press, Reading, MA, 2000. ISBN 0-201-61633-5.

```text
                             More information available at:
                             http://www.unicode.org/
```

\[유니코드2\] "지원되지 않는 스크립트" Unicode, Inc., The Unicode Consortium, P.O. Box 700519, San Jose, CA 95710-0519 USA, 1999년 9월. http://www.unicode.org/unicode/standard/unsupported.html

---
## **21.  Informative References**

\[Floyd\] S. Floyd, V. Jacobson, "주기적인 라우팅 메시지의 동기화", 네트워킹에 대한 IEEE/ACM 트랜잭션, 2\(2\), pp. 122-136, 1994년 4월.

\[회색\] C. Gray, D. Cheriton, "임대: 분산 파일 캐시 일관성을 위한 효율적인 내결함성 메커니즘", 운영 체제 원리에 관한 제12회 심포지엄 진행, p. 202-210, 1989년 12월.

\[Juszczak\] Juszczak, Chet, "NFS 서버의 성능 및 정확성 향상", USENIX Conference Proceedings, USENIX Association, Berkeley, CA, 1990년 6월, 페이지 53-63. 중복 요청을 처리하여 서버에서의 작업을 방지하는 응답 캐시 구현에 대해 설명합니다. 더 중요한 점은 비록 부작용으로 나열되어 있지만 응답 캐시가 파괴적인 비멱등성 작업 재적용을 방지하여 정확성을 향상시키는 데 도움이 된다는 것입니다.

\[Kazar\] Kazar, Michael Leon, "Andrew 파일 시스템의 동기화 및 캐싱 문제", USENIX Conference Proceedings, USENIX Association, Berkeley, CA, Dallas Winter 1988, 페이지 27-36. AFS의 캐시 일관성 체계에 대한 설명입니다. 다른 분산 파일 시스템과 대조됩니다.

\[Macklem\] Macklem, Rick, "NFS 프로토콜의 4.3BSD Reno 구현 조정에 대한 교훈", Winter USENIX Conference Proceedings, USENIX Association, Berkeley, CA, 1991년 1월. 4.3BSD Reno NFS 구현 조정에 대한 성능 작업에 대해 설명합니다. 데이터 복사본 제거를 통한 성능 향상\(CPU 부하 감소\)에 대해 설명합니다.

\[Mogul\] Mogul, Jeffrey C., "A Recovery Protocol for Spritely NFS," USENIX File System Workshop Proceedings, Ann Arbor, MI, USENIX Association, Berkeley, CA, 1992년 5월. Spritely NFS에 대한 두 번째 문서는 임대 기반 체계를 제안합니다. 일관성 프로토콜 상태를 복구하기 위한 것입니다.

\[Nowicki\] Nowicki, Bill, "네트워크 파일 시스템의 전송 문제", ACM SIGCOMM 뉴스레터 컴퓨터 통신 검토, 1989년 4월. 동적 재전송 작업의 기초에 대한 간략한 설명입니다.

\[Pawlowski\] Pawlowski, Brian, Ron Hixon, Mark Stein, Joseph Tumminaro, "UNIX 및 IBM 메인프레임 환경의 네트워크 컴퓨팅", Uniforum \`89 Conf. Proc., \(1989\) IBM의 MVS 운영 체제용 NFS 서버 구현에 대한 설명입니다.

```text
   [RFC1094]                 Sun Microsystems, Inc., "NFS: Network File
                             System Protocol Specification", RFC 1094,
                             March 1989.

   [RFC1345]                 Simonsen, K., "Character Mnemonics &
                             Character Sets", RFC 1345, June 1992.
```

\[RFC1813\] Callaghan, B., Pawlowski, B. 및 P. Staubach, "NFS 버전 3 프로토콜 사양", RFC 1813, 1995년 6월.

\[RFC3232\] Reynolds, J., 편집자, "할당된 번호: RFC 1700이 온라인 데이터베이스로 대체됨", RFC 3232, 2002년 1월.

\[RFC1833\] Srinivasan, R., "ONC RPC 버전 2에 대한 바인딩 프로토콜", RFC 1833, 1995년 8월.

```text
   [RFC2054]                 Callaghan, B., "WebNFS Client
                             Specification", RFC 2054, October 1996.

   [RFC2055]                 Callaghan, B., "WebNFS Server
                             Specification", RFC 2055,  October 1996.
```

\[RFC2152\] Goldsmith, D. 및 M. Davis, "UTF-7 유니코드의 메일 안전 변환 형식", RFC 2152, 1997년 5월.

```text
   [RFC2224]                 Callaghan, B., "NFS URL Scheme", RFC 2224,
                             October 1997.

   [RFC2624]                 Shepler, S., "NFS Version 4 Design
                             Considerations", RFC 2624, June 1999.
```

\[RFC2755\] Chiu, A., Eisler, M. 및 B. Callaghan, "WebNFS에 대한 보안 협상", RFC 2755, 2000년 6월.

\[Sandberg\] Sandberg, R., D. Goldberg, S. Kleiman, D. Walsh, B. Lyon, "Sun 네트워크 파일 시스템의 설계 및 구현", USENIX Conference Proceedings, USENIX Association, Berkeley, CA, Summer 1985. NFS 버전 2 프로토콜의 SunOS 구현을 설명하는 기본 문서이며 목표, 프로토콜 사양 및 장단점을 논의합니다.

\[Srinivasan\] Srinivasan, V., Jeffrey C. Mogul, "Spritely NFS: 캐시 일관성 프로토콜의 구현 및 성능", WRL 연구 보고서 89/5, Digital Equipment Corporation Western Research Laboratory, 100 Hamilton Ave., Palo Alto, CA, 94301, 1989년 5월. 이 문서에서는 표준 NFS에 적용된 Sprite와 유사한 일관성 프로토콜을 적용한 효과를 분석합니다. 상태 저장 환경의 복구 문제는 \[Mogul\]에서 다룹니다.

\[XNFS\] The Open Group, 상호 작업 프로토콜: XNFS, 버전 3W, The Open Group, 1010 El Camino Real Suite 380, Menlo Park, CA 94025, ISBN 1-85912-184-5, 1998년 2월.

```text
                             HTML version available:
                             http://www.opengroup.org
```

---
## **22.  Authors' Information**
---
### **22.1.  Editor's Address**

```text
   Spencer Shepler
   Sun Microsystems, Inc.
   7808 Moonflower Drive
   Austin, Texas  78750

   Phone: +1 512-349-9376
   EMail: spencer.shepler@sun.com
```

---
### **22.2.  Authors' Addresses**

```text
   Carl Beame
   Hummingbird Ltd.

   EMail: beame@bws.com

   Brent Callaghan
   Sun Microsystems, Inc.
   17 Network Circle
   Menlo Park, CA  94025

   Phone: +1 650-786-5067
   EMail: brent.callaghan@sun.com

   Mike Eisler
   5765 Chase Point Circle
   Colorado Springs, CO  80919

   Phone: +1 719-599-9026
   EMail: mike@eisler.com

   David Noveck
   Network Appliance
   375 Totten Pond Road
   Waltham, MA  02451

   Phone: +1 781-768-5347
   EMail: dnoveck@netapp.com

   David Robinson
   Sun Microsystems, Inc.
   5300 Riata Park Court
   Austin, TX  78727

   Phone: +1 650-786-5088
   EMail: david.robinson@sun.com

   Robert Thurlow
   Sun Microsystems, Inc.
   500 Eldorado Blvd.
   Broomfield, CO  80021

   Phone: +1 650-786-5096
   EMail: robert.thurlow@sun.com
```

---
## **23.  Full Copyright Statement**

저작권\(C\)인터넷학회\(2003\). 판권 소유.

이 문서와 그 번역본은 복사되어 타인에게 제공될 수 있으며, 이에 대해 설명하거나 설명하거나 구현을 지원하는 파생물은 어떤 종류의 제한 없이 전체적으로 또는 부분적으로 준비, 복사, 출판 및 배포될 수 있습니다. , 단, 위의 저작권 표시와 이 단락은 그러한 모든 사본 및 파생물에 포함됩니다. 그러나 이 문서 자체는 인터넷 표준 개발 목적으로 필요한 경우를 제외하고는 저작권 표시를 제거하거나 Internet Society 또는 기타 인터넷 조직에 대한 참조를 제거하는 등 어떤 식으로든 수정할 수 없습니다. 인터넷 표준 프로세스를 따르거나 영어 이외의 언어로 번역하는 데 필요한 대로 따라야 합니다.

위에서 부여된 제한된 권한은 영구적이며 Internet Society 또는 그 승계자 또는 양수인에 의해 취소되지 않습니다.

이 문서와 여기에 포함된 정보는 "있는 그대로" 제공되며 인터넷 사회 및 인터넷 공학 태스크포스는 여기에 포함된 정보의 사용이 상품성 또는 특정 목적에의 적합성에 대한 권리 또는 묵시적 보증을 침해하는 행위.

---
# **Acknowledgement**

RFC 편집기 기능에 대한 자금은 현재 Internet Society에서 제공하고 있습니다.


```text
Network Working Group                    Internet Engineering Task Force
Request for Comments: 1122                             R. Braden, Editor
                                                            October 1989

        Requirements for Internet Hosts -- Communication Layers
```

---
# **Status of This Memo**

이 RFC는 인터넷 커뮤니티의 공식 사양입니다. 호스트와 관련된 기본 프로토콜 표준 문서를 참조로 통합하고 수정, 수정 및 보완합니다. 이 문서의 배포에는 제한이 없습니다.

---
# **Summary**

이는 인터넷 호스트 소프트웨어에 대한 요구 사항을 정의하고 논의하는 한 쌍의 RFC입니다. 이 RFC는 통신 프로토콜 계층\(링크 계층, IP 계층 및 전송 계층\)을 다룹니다. 그 짝인 RFC-1123은 애플리케이션 및 지원 프로토콜을 다루고 있습니다.

- 목차

```text
   1.  INTRODUCTION ...............................................    5
      1.1  The Internet Architecture ..............................    6
         1.1.1  Internet Hosts ....................................    6
         1.1.2  Architectural Assumptions .........................    7
         1.1.3  Internet Protocol Suite ...........................    8
         1.1.4  Embedded Gateway Code .............................   10
      1.2  General Considerations .................................   12
         1.2.1  Continuing Internet Evolution .....................   12
         1.2.2  Robustness Principle ..............................   12
         1.2.3  Error Logging .....................................   13
         1.2.4  Configuration .....................................   14
      1.3  Reading this Document ..................................   15
         1.3.1  Organization ......................................   15
         1.3.2  Requirements ......................................   16
         1.3.3  Terminology .......................................   17
      1.4  Acknowledgments ........................................   20
   2. LINK LAYER ..................................................   21
      2.1  INTRODUCTION ...........................................   21
```

---
# **RFC1122                       INTRODUCTION                  October 1989**

```text
      2.2  PROTOCOL WALK-THROUGH ..................................   21
      2.3  SPECIFIC ISSUES ........................................   21
         2.3.1  Trailer Protocol Negotiation ......................   21
         2.3.2  Address Resolution Protocol -- ARP ................   22
            2.3.2.1  ARP Cache Validation .........................   22
            2.3.2.2  ARP Packet Queue .............................   24
         2.3.3  Ethernet and IEEE 802 Encapsulation ...............   24
      2.4  LINK/INTERNET LAYER INTERFACE ..........................   25
      2.5  LINK LAYER REQUIREMENTS SUMMARY ........................   26
   3. INTERNET LAYER PROTOCOLS ....................................   27
      3.1 INTRODUCTION ............................................   27
      3.2  PROTOCOL WALK-THROUGH ..................................   29
         3.2.1 Internet Protocol -- IP ............................   29
            3.2.1.1  Version Number ...............................   29
            3.2.1.2  Checksum .....................................   29
            3.2.1.3  Addressing ...................................   29
            3.2.1.4  Fragmentation and Reassembly .................   32
            3.2.1.5  Identification ...............................   32
            3.2.1.6  Type-of-Service ..............................   33
            3.2.1.7  Time-to-Live .................................   34
            3.2.1.8  Options ......................................   35
         3.2.2 Internet Control Message Protocol -- ICMP ..........   38
            3.2.2.1  Destination Unreachable ......................   39
            3.2.2.2  Redirect .....................................   40
            3.2.2.3  Source Quench ................................   41
            3.2.2.4  Time Exceeded ................................   41
            3.2.2.5  Parameter Problem ............................   42
            3.2.2.6  Echo Request/Reply ...........................   42
            3.2.2.7  Information Request/Reply ....................   43
            3.2.2.8  Timestamp and Timestamp Reply ................   43
            3.2.2.9  Address Mask Request/Reply ...................   45
         3.2.3  Internet Group Management Protocol IGMP ...........   47
      3.3  SPECIFIC ISSUES ........................................   47
         3.3.1  Routing Outbound Datagrams ........................   47
            3.3.1.1  Local/Remote Decision ........................   47
            3.3.1.2  Gateway Selection ............................   48
            3.3.1.3  Route Cache ..................................   49
            3.3.1.4  Dead Gateway Detection .......................   51
            3.3.1.5  New Gateway Selection ........................   55
            3.3.1.6  Initialization ...............................   56
         3.3.2  Reassembly ........................................   56
         3.3.3  Fragmentation .....................................   58
         3.3.4  Local Multihoming .................................   60
            3.3.4.1  Introduction .................................   60
            3.3.4.2  Multihoming Requirements .....................   61
            3.3.4.3  Choosing a Source Address ....................   64
         3.3.5  Source Route Forwarding ...........................   65
```

---
# **RFC1122                       INTRODUCTION                  October 1989**

```text
         3.3.6  Broadcasts ........................................   66
         3.3.7  IP Multicasting ...................................   67
         3.3.8  Error Reporting ...................................   69
      3.4  INTERNET/TRANSPORT LAYER INTERFACE .....................   69
      3.5  INTERNET LAYER REQUIREMENTS SUMMARY ....................   72
   4. TRANSPORT PROTOCOLS .........................................   77
      4.1  USER DATAGRAM PROTOCOL -- UDP ..........................   77
         4.1.1  INTRODUCTION ......................................   77
         4.1.2  PROTOCOL WALK-THROUGH .............................   77
         4.1.3  SPECIFIC ISSUES ...................................   77
            4.1.3.1  Ports ........................................   77
            4.1.3.2  IP Options ...................................   77
            4.1.3.3  ICMP Messages ................................   78
            4.1.3.4  UDP Checksums ................................   78
            4.1.3.5  UDP Multihoming ..............................   79
            4.1.3.6  Invalid Addresses ............................   79
         4.1.4  UDP/APPLICATION LAYER INTERFACE ...................   79
         4.1.5  UDP REQUIREMENTS SUMMARY ..........................   80
      4.2  TRANSMISSION CONTROL PROTOCOL -- TCP ...................   82
         4.2.1  INTRODUCTION ......................................   82
         4.2.2  PROTOCOL WALK-THROUGH .............................   82
            4.2.2.1  Well-Known Ports .............................   82
            4.2.2.2  Use of Push ..................................   82
            4.2.2.3  Window Size ..................................   83
            4.2.2.4  Urgent Pointer ...............................   84
            4.2.2.5  TCP Options ..................................   85
            4.2.2.6  Maximum Segment Size Option ..................   85
            4.2.2.7  TCP Checksum .................................   86
            4.2.2.8  TCP Connection State Diagram .................   86
            4.2.2.9  Initial Sequence Number Selection ............   87
            4.2.2.10  Simultaneous Open Attempts ..................   87
            4.2.2.11  Recovery from Old Duplicate SYN .............   87
            4.2.2.12  RST Segment .................................   87
            4.2.2.13  Closing a Connection ........................   87
            4.2.2.14  Data Communication ..........................   89
            4.2.2.15  Retransmission Timeout ......................   90
            4.2.2.16  Managing the Window .........................   91
            4.2.2.17  Probing Zero Windows ........................   92
            4.2.2.18  Passive OPEN Calls ..........................   92
            4.2.2.19  Time to Live ................................   93
            4.2.2.20  Event Processing ............................   93
            4.2.2.21  Acknowledging Queued Segments ...............   94
         4.2.3  SPECIFIC ISSUES ...................................   95
            4.2.3.1  Retransmission Timeout Calculation ...........   95
            4.2.3.2  When to Send an ACK Segment ..................   96
            4.2.3.3  When to Send a Window Update .................   97
            4.2.3.4  When to Send Data ............................   98
```

---
# **RFC1122                       INTRODUCTION                  October 1989**

```text
            4.2.3.5  TCP Connection Failures ......................  100
            4.2.3.6  TCP Keep-Alives ..............................  101
            4.2.3.7  TCP Multihoming ..............................  103
            4.2.3.8  IP Options ...................................  103
            4.2.3.9  ICMP Messages ................................  103
            4.2.3.10  Remote Address Validation ...................  104
            4.2.3.11  TCP Traffic Patterns ........................  104
            4.2.3.12  Efficiency ..................................  105
         4.2.4  TCP/APPLICATION LAYER INTERFACE ...................  106
            4.2.4.1  Asynchronous Reports .........................  106
            4.2.4.2  Type-of-Service ..............................  107
            4.2.4.3  Flush Call ...................................  107
            4.2.4.4  Multihoming ..................................  108
         4.2.5  TCP REQUIREMENT SUMMARY ...........................  108
   5.  REFERENCES .................................................  112
```

---
# **RFC1122                       INTRODUCTION                  October 1989**
---
## **1.  INTRODUCTION**

이 문서는 인터넷 프로토콜 제품군의 호스트 시스템 구현에 대한 요구 사항을 정의하고 논의하는 문서 중 하나입니다. 이 RFC는 통신 프로토콜 계층인 링크 계층, IP 계층 및 전송 계층을 다룹니다. 함께 제공되는 RFC인 "인터넷 호스트에 대한 요구 사항 - 응용 프로그램 및 지원"\[소개:1\]은 응용 프로그램 계층 프로토콜을 다루고 있습니다. 이 문서는 "인터넷 게이트웨이 요구 사항"\[소개:2\]과 함께 읽어야 합니다.

이 문서는 인터넷 통신 소프트웨어 공급업체, 구현업체 및 사용자에게 지침을 제공하기 위한 것입니다. 이는 인터넷 연구 및 공급업체 커뮤니티 구성원이 기여한 대규모 기술 경험과 ​​지혜의 합의를 나타냅니다.

이 RFC는 인터넷에 연결된 호스트가 사용해야 하는 표준 프로토콜을 열거하고, 이러한 프로토콜의 현재 사양을 설명하는 RFC 및 기타 문서를 참조로 통합합니다. 참조 문서의 오류를 수정하고 구현자를 위한 추가적인 논의와 지침을 추가합니다.

각 프로토콜에 대해 이 문서에는 명시적인 요구 사항, 권장 사항 및 옵션 집합도 포함되어 있습니다. 독자는 이 문서의 요구 사항 목록 자체가 불완전하다는 점을 이해해야 합니다. 인터넷 호스트에 대한 전체 요구 사항 세트는 기본적으로 이 RFC에 포함된 수정, 개정 및 보충 사항과 함께 표준 프로토콜 사양 문서에 정의되어 있습니다.

RFC를 주의 깊게 읽고 인터넷 기술 커뮤니티와의 일부 상호 작용을 통해 생성되었으며 올바른 통신 소프트웨어 엔지니어링 관행을 따른 프로토콜의 선의의 구현은 이 문서의 요구 사항과 약간만 다를 수 있습니다. 따라서 많은 경우에 이 RFC의 "요구 사항"은 이미 표준 프로토콜 문서에 명시되거나 암시되어 있으므로 여기에 포함시키는 것은 어떤 의미에서는 중복됩니다. 그러나 과거의 일부 구현이 잘못된 선택을 하여 상호 운용성, 성능 및/또는 견고성에 문제를 일으켰기 때문에 포함되었습니다.

이 문서에는 다양한 요구 사항 및 권장 사항에 대한 논의와 설명이 포함되어 있습니다. 간단한 요구 사항 목록은 다음과 같은 이유로 위험합니다.

- 일부 필수 기능은 다른 기능보다 중요하며 일부 기능은 선택 사항입니다.

---
# **RFC1122                       INTRODUCTION                  October 1989**

- 제한된 상황에 맞게 설계된 특정 공급업체 제품이 다른 사양을 사용하도록 선택할 수 있는 타당한 이유가 있을 수 있습니다.

그러나 인터넷 시스템의 다양성과 복잡성 전반에 걸쳐 임의의 호스트 상호 운용이라는 일반적인 목표를 충족하려면 이 문서의 사양을 따라야 합니다. 대부분의 현재 구현은 일부 사소하고 일부 주요한 다양한 방식으로 이러한 요구 사항을 충족하지 못하지만 이 사양은 우리가 나아가야 할 이상적인 사양입니다.

이러한 요구 사항은 현재 인터넷 아키텍처 수준을 기반으로 합니다. 이 문서는 추가 설명을 제공하거나 사양이 계속 발전하는 영역에 대한 추가 정보를 포함하기 위해 필요에 따라 업데이트됩니다.

이 소개 섹션은 호스트와 관련된 인터넷 아키텍처에 대한 간략한 개요로 시작한 다음 호스트 소프트웨어 공급업체에 대한 몇 가지 일반적인 조언을 제공합니다. 마지막으로, 문서의 나머지 부분과 일부 용어를 읽는 데 대한 몇 가지 지침이 있습니다.

1.1 인터넷 아키텍처

- 인터넷 아키텍처 및 지원 프로토콜 제품군에 대한 일반적인 배경 및 논의는 DDN 프로토콜 핸드북 \[소개:3\]에서 찾을 수 있습니다. 배경 정보는 \[INTRO:9\], \[INTRO:10\] 및 \[INTRO:11\]을 참조하세요. 참조 \[INTRO:5\]에는 인터넷 프로토콜 문서를 얻는 절차가 설명되어 있으며, \[INTRO:6\]에는 인터넷 프로토콜 내에 할당된 번호 목록이 포함되어 있습니다.

```text
      1.1.1  Internet Hosts
```

- 호스트 컴퓨터 또는 간단히 "호스트"는 통신 서비스의 최종 소비자입니다. 호스트는 일반적으로 이 기능을 지원하기 위해 네트워크 및/또는 인터넷 통신 서비스를 사용하여 사용자를 대신하여 응용 프로그램을 실행합니다. 인터넷 호스트는 OSI 프로토콜 모음 \[INTRO:13\]에서 사용되는 "최종 시스템" 개념에 해당합니다.

- 인터넷 통신 시스템은 인터넷 프로토콜을 사용하여 호스트 컴퓨터 간의 통신을 지원하는 상호 연결된 패킷 네트워크로 구성됩니다. 네트워크는 인터넷 커뮤니티에서 "게이트웨이" 또는 "IP 라우터"라고 하는 패킷 교환 컴퓨터와 OSI 세계에서 "중간 시스템"이라고 부르는 패킷 교환 컴퓨터를 사용하여 상호 연결됩니다\[소개:13\]. RFC "인터넷 게이트웨이 요구 사항"\[INTRO:2\]에는 인터넷 게이트웨이에 대한 공식 사양이 포함되어 있습니다. 그 RFC는

---
# **RFC1122                       INTRODUCTION                  October 1989**

- 본 문서와 그 부속물 \[소개:1\]은 인터넷 아키텍처의 현재 실현을 위한 규칙을 정의합니다.

- 인터넷 호스트는 크기, 속도 및 기능이 다양합니다. 크기는 소형 마이크로프로세서부터 워크스테이션, 메인프레임, 슈퍼컴퓨터까지 다양합니다. 기능적으로는 단일 목적 호스트\(예: 터미널 서버\)부터 일반적으로 원격 로그인, 파일 전송, 전자 메일을 비롯한 다양한 온라인 네트워크 서비스를 지원하는 풀 서비스 호스트까지 다양합니다.

- 호스트가 동일하거나 다른 네트워크에 대해 둘 이상의 인터페이스를 갖고 있는 경우 일반적으로 호스트를 멀티홈이라고 합니다. "용어"의 섹션 1.1.3을 참조하세요.

```text
      1.1.2  Architectural Assumptions
```

- 현재 인터넷 아키텍처는 통신 시스템에 대한 일련의 가정을 기반으로 합니다. 호스트와 가장 관련된 가정은 다음과 같습니다.

- \(a\) 인터넷은 네트워크의 네트워크입니다.

```text
              Each host is directly connected to some particular
              network(s); its connection to the Internet is only
              conceptual.  Two hosts on the same network communicate
              with each other using the same set of protocols that they
              would use to communicate with hosts on distant networks.

         (b)  Gateways don't keep connection state information.

              To improve robustness of the communication system,
              gateways are designed to be stateless, forwarding each IP
              datagram independently of other datagrams.  As a result,
              redundant paths can be exploited to provide robust service
              in spite of failures of intervening gateways and networks.

              All state information required for end-to-end flow control
              and reliability is implemented in the hosts, in the
              transport layer or in application programs.  All
              connection control information is thus co-located with the
              end points of the communication, so it will be lost only
              if an end point fails.
```

- \(c\) 라우팅 복잡성은 게이트웨이에 있어야 합니다.

```text
              Routing is a complex and difficult problem, and ought to
              be performed by the gateways, not the hosts.  An important
```

---
# **RFC1122                       INTRODUCTION                  October 1989**

```text
              objective is to insulate host software from changes caused
              by the inevitable evolution of the Internet routing
              architecture.
```

- \(d\) 시스템은 광범위한 네트워크 변화를 허용해야 합니다.

```text
              A basic objective of the Internet design is to tolerate a
              wide range of network characteristics -- e.g., bandwidth,
              delay, packet loss, packet reordering, and maximum packet
              size.  Another objective is robustness against failure of
              individual networks, gateways, and hosts, using whatever
              bandwidth is still available.  Finally, the goal is full
              "open system interconnection": an Internet host must be
              able to interoperate robustly and effectively with any
              other Internet host, across diverse Internet paths.

              Sometimes host implementors have designed for less
              ambitious goals.  For example, the LAN environment is
              typically much more benign than the Internet as a whole;
              LANs have low packet loss and delay and do not reorder
              packets.  Some vendors have fielded host implementations
              that are adequate for a simple LAN environment, but work
              badly for general interoperation.  The vendor justifies
              such a product as being economical within the restricted
              LAN market.  However, isolated LANs seldom stay isolated
              for long; they are soon gatewayed to each other, to
              organization-wide internets, and eventually to the global
              Internet system.  In the end, neither the customer nor the
              vendor is served by incomplete or substandard Internet
              host software.

              The requirements spelled out in this document are designed
              for a full-function Internet host, capable of full
              interoperation over an arbitrary Internet path.

      1.1.3  Internet Protocol Suite
```

- 인터넷 시스템을 사용하여 통신하려면 호스트는 인터넷 프로토콜 제품군을 구성하는 계층화된 프로토콜 집합을 구현해야 합니다. 호스트는 일반적으로 각 계층에서 최소한 하나의 프로토콜을 구현해야 합니다.

- 인터넷 아키텍처에 사용되는 프로토콜 계층은 다음과 같습니다 \[소개:4\]:

```text
         o  Application Layer
```

---
# **RFC1122                       INTRODUCTION                  October 1989**

```text
              The application layer is the top layer of the Internet
              protocol suite.  The Internet suite does not further
              subdivide the application layer, although some of the
              Internet application layer protocols do contain some
              internal sub-layering.  The application layer of the
              Internet suite essentially combines the functions of the
              top two layers -- Presentation and Application -- of the
              OSI reference model.

              We distinguish two categories of application layer
              protocols:  user protocols that provide service directly
              to users, and support protocols that provide common system
              functions.  Requirements for user and support protocols
              will be found in the companion RFC [INTRO:1].
```

- 가장 일반적인 인터넷 사용자 프로토콜은 다음과 같습니다.

```text
                o  Telnet (remote login)
                o  FTP    (file transfer)
                o  SMTP   (electronic mail delivery)

              There are a number of other standardized user protocols
              [INTRO:4] and many private user protocols.

              Support protocols, used for host name mapping, booting,
              and management, include SNMP, BOOTP, RARP, and the Domain
              Name System (DNS) protocols.

         o  Transport Layer

              The transport layer provides end-to-end communication
              services for applications.  There are two primary
              transport layer protocols at present:

                o Transmission Control Protocol (TCP)
                o User Datagram Protocol (UDP)

              TCP is a reliable connection-oriented transport service
              that provides end-to-end reliability, resequencing, and
              flow control.  UDP is a connectionless ("datagram")
              transport service.

              Other transport protocols have been developed by the
              research community, and the set of official Internet
              transport protocols may be expanded in the future.
```

- 전송 계층 프로토콜은 4장에서 논의됩니다.

---
# **RFC1122                       INTRODUCTION                  October 1989**

```text
         o  Internet Layer

              All Internet transport protocols use the Internet Protocol
              (IP) to carry data from source host to destination host.
              IP is a connectionless or datagram internetwork service,
              providing no end-to-end delivery guarantees. Thus, IP
              datagrams may arrive at the destination host damaged,
              duplicated, out of order, or not at all.  The layers above
              IP are responsible for reliable delivery service when it
              is required.  The IP protocol includes provision for
              addressing, type-of-service specification, fragmentation
              and reassembly, and security information.

              The datagram or connectionless nature of the IP protocol
              is a fundamental and characteristic feature of the
              Internet architecture.  Internet IP was the model for the
              OSI Connectionless Network Protocol [INTRO:12].

              ICMP is a control protocol that is considered to be an
              integral part of IP, although it is architecturally
              layered upon IP, i.e., it uses IP to carry its data end-
              to-end just as a transport protocol like TCP or UDP does.
              ICMP provides error reporting, congestion reporting, and
              first-hop gateway redirection.

              IGMP is an Internet layer protocol used for establishing
              dynamic host groups for IP multicasting.

              The Internet layer protocols IP, ICMP, and IGMP are
              discussed in Chapter 3.

         o  Link Layer

              To communicate on its directly-connected network, a host
              must implement the communication protocol used to
              interface to that network.  We call this a link layer or
              media-access layer protocol.

              There is a wide variety of link layer protocols,
              corresponding to the many different types of networks.
              See Chapter 2.

      1.1.4  Embedded Gateway Code
```

- 일부 인터넷 호스트 소프트웨어에는 내장된 게이트웨이 기능이 포함되어 있어 이러한 호스트는 패킷을 다음과 같이 전달할 수 있습니다.

---
# **RFC1122                       INTRODUCTION                  October 1989**

- 게이트웨이는 여전히 호스트의 애플리케이션 계층 기능을 수행합니다.

- 이러한 이중 목적 시스템은 게이트웨이 기능과 관련하여 게이트웨이 요구 사항 RFC \[INTRO:2\]를 따라야 하며 호스트 기능과 관련하여 현재 문서를 따라야 합니다. 모든 중복되는 경우에는 두 사양이 일치해야 합니다.

- 내장된 게이트웨이 기능에 대해 인터넷 커뮤니티에서는 다양한 의견이 있습니다. 주요 주장은 다음과 같습니다.

```text
         o    Pro: in a local network environment where networking is
              informal, or in isolated internets, it may be convenient
              and economical to use existing host systems as gateways.

              There is also an architectural argument for embedded
              gateway functionality: multihoming is much more common
              than originally foreseen, and multihoming forces a host to
              make routing decisions as if it were a gateway.  If the
              multihomed  host contains an embedded gateway, it will
              have full routing knowledge and as a result will be able
              to make more optimal routing decisions.

         o    Con: Gateway algorithms and protocols are still changing,
              and they will continue to change as the Internet system
              grows larger.  Attempting to include a general gateway
              function within the host IP layer will force host system
              maintainers to track these (more frequent) changes.  Also,
              a larger pool of gateway implementations will make
              coordinating the changes more difficult.  Finally, the
              complexity of a gateway IP layer is somewhat greater than
              that of a host, making the implementation and operation
              tasks more complex.

              In addition, the style of operation of some hosts is not
              appropriate for providing stable and robust gateway
              service.
```

- 두 가지 관점 모두 상당한 장점이 있습니다. 한 가지 결론을 내릴 수 있습니다. 호스트 관리자는 특정 호스트가 게이트웨이 역할을 하는지 여부를 의식적으로 제어할 수 있어야 합니다. 자세한 요구 사항은 섹션 3.1을 참조하세요.

---
# **RFC1122                       INTRODUCTION                  October 1989**

```text
   1.2  General Considerations
```

- 인터넷 호스트 소프트웨어 공급업체가 배웠고 새로운 공급업체가 진지하게 고려해야 하는 두 가지 중요한 교훈이 있습니다.

```text
      1.2.1  Continuing Internet Evolution
```

- 인터넷의 엄청난 성장으로 인해 대용량 데이터그램 기반의 패킷 통신 시스템에서는 관리 및 확장의 문제점이 드러났다. 이러한 문제는 해결되고 있으며 결과적으로 이 문서에 설명된 사양이 계속해서 발전할 것입니다. 이러한 변경 사항은 공급업체와 네트워크 운영을 담당하는 조직이 이 계획에 광범위하게 참여하기 때문에 신중하게 계획되고 제어됩니다.

- 개발, 진화, 수정은 오늘날 컴퓨터 네트워크 프로토콜의 특징이며 이러한 상황은 수년간 지속될 것입니다. 인터넷 프로토콜 제품군\(또는 기타 프로토콜 제품군!\)을 위한 컴퓨터 통신 소프트웨어를 개발한 후 사양 변경을 위한 소프트웨어를 유지 관리 및 업데이트하지 못하는 공급업체는 고객에게 불만족스러운 흔적을 남길 것입니다. 인터넷은 대규모 통신 네트워크이며, 사용자들은 이를 통해 지속적으로 접촉하고 있습니다. 경험에 따르면 공급업체 소프트웨어의 결함에 대한 지식은 인터넷 기술 커뮤니티를 통해 빠르게 전파됩니다.

```text
      1.2.2  Robustness Principle
```

- 프로토콜의 모든 계층에는 견고성과 상호 운용성 측면에서 엄청난 이점을 가져올 수 있는 일반 규칙이 있습니다\[IP:1\]:

```text
                "Be liberal in what you accept, and
                 conservative in what you send"
```

- 소프트웨어는 아무리 가능성이 낮더라도 발생할 수 있는 모든 오류를 처리하도록 작성되어야 합니다. 조만간 특정 오류와 속성의 조합이 포함된 패킷이 수신될 것이며, 소프트웨어가 준비되지 않으면 혼란이 뒤따를 수 있습니다. 일반적으로 네트워크는 최악의 영향을 미치도록 설계된 패킷을 보내는 악의적인 개체로 가득 차 있다고 가정하는 것이 가장 좋습니다. 이러한 가정은 적절한 보호 설계로 이어질 것입니다. 그러나 인터넷에서 가장 심각한 문제는 확률이 낮은 이벤트로 인해 발생하는 예상치 못한 메커니즘으로 인해 발생했습니다.

---
# **RFC1122                       INTRODUCTION                  October 1989**

- 단순한 인간의 악의로는 결코 그렇게 사악한 길을 택하지 않았을 것입니다!

- 변화에 대한 적응성은 모든 수준의 인터넷 호스트 소프트웨어에 설계되어야 합니다. 간단한 예로, 특정 헤더 필드\(예: 유형 필드, 포트 번호 또는 오류 코드\)에 대한 값의 열거를 포함하는 프로토콜 사양을 고려해보세요. 이 열거는 불완전한 것으로 가정해야 합니다. 따라서 프로토콜 사양이 4개의 가능한 오류 코드를 정의하는 경우 다섯 번째 코드가 나타날 때 소프트웨어가 중단되어서는 안 됩니다. 정의되지 않은 코드가 기록될 수 있지만\(아래 참조\) 오류가 발생해서는 안 됩니다.

- 원칙의 두 번째 부분도 마찬가지로 중요합니다. 다른 호스트의 소프트웨어에는 합법적이지만 모호한 프로토콜 기능을 활용하는 것을 현명하지 못하게 만드는 결함이 포함될 수 있습니다. 명백하고 단순한 것에서 멀리 벗어나는 것은 다른 곳에서 바람직하지 않은 결과를 초래하지 않도록 하는 것은 현명하지 않습니다. 이에 대한 결과는 "잘못 행동하는 호스트를 조심하십시오"입니다. 호스트 소프트웨어는 오작동하는 다른 호스트에서 살아남을 뿐만 아니라 해당 호스트가 공유 통신 시설에 초래할 수 있는 중단의 양을 제한하기 위해 협력할 수 있도록 준비되어야 합니다.

```text
      1.2.3  Error Logging
```

- 인터넷에는 각각 많은 프로토콜과 프로토콜 계층을 구현하는 매우 다양한 호스트 및 게이트웨이 시스템이 포함되어 있으며 이들 중 일부에는 인터넷 프로토콜 소프트웨어에 버그와 잘못된 기능이 포함되어 있습니다. 복잡성, 다양성 및 기능 분포로 인해 인터넷 문제를 진단하는 것이 매우 어려운 경우가 많습니다.

- 호스트 구현에 오류가 있거나 "이상한" 프로토콜 이벤트를 기록하기 위해 세심하게 설계된 기능이 포함되어 있으면 문제 진단에 도움이 됩니다. 오류가 기록될 때 가능한 한 많은 진단 정보를 포함하는 것이 중요합니다. 특히, 오류를 일으킨 패킷의 헤더를 기록해 두는 것이 유용한 경우가 많습니다. 그러나 오류 로깅이 엄청난 양의 리소스를 소비하거나 호스트 작동을 방해하지 않도록 주의해야 합니다.

- 비정상적이지만 무해한 프로토콜 이벤트로 인해 오류 로깅 파일이 오버플로되는 경향이 있습니다. 이는 "순환" 로그를 사용하거나 알려진 오류를 진단하는 동안에만 로깅을 활성화하여 방지할 수 있습니다. 중복된 연속 메시지를 필터링하고 계산하는 것이 유용할 수 있습니다. 잘 작동하는 것으로 보이는 한 가지 전략은 다음과 같습니다. \(1\) 항상 이상을 계산하고 관리 프로토콜을 통해 이러한 계산에 액세스할 수 있도록 합니다\(\[소개:1\] 참조\). \(2\) 허용

---
# **RFC1122                       INTRODUCTION                  October 1989**

- 매우 다양한 이벤트 로깅이 선택적으로 활성화됩니다. 예를 들어, "모든 것을 기록"하거나 "호스트 X에 대한 모든 것을 기록"하는 것이 유용할 수 있습니다.

- 관리마다 호스트에서 일반적으로 활성화하려는 오류 로깅의 양에 대해 서로 다른 정책이 있을 수 있습니다. 어떤 사람들은 "나에게 해를 끼치지 않는다면 그것에 대해 알고 싶지 않습니다"라고 말할 것이고, 다른 사람들은 프로토콜 이상을 탐지하고 제거하는 데 더 조심스럽고 공격적인 태도를 취하고 싶어할 것입니다.

```text
      1.2.4  Configuration
```

- 인터넷 프로토콜 제품군의 호스트 구현이 완전히 자체 구성될 수 있다면 이상적입니다. 이를 통해 전체 제품군을 ROM에서 구현하거나 실리콘으로 캐스팅할 수 있고, 디스크 없는 워크스테이션을 단순화할 수 있으며, 시스템 공급업체는 물론 LAN 관리자에게도 엄청난 이점이 될 것입니다. 우리는 이 이상에 도달하지 못했습니다. 사실 우리는 가깝지도 않아요.

- 이 문서의 여러 지점에서 매개변수가 구성 가능한 옵션이어야 한다는 요구 사항을 찾을 수 있습니다. 이러한 요구 사항에는 여러 가지 이유가 있습니다. 일부 경우에는 현재 최고 값에 대한 불확실성이나 불일치가 있으며 향후 권장 값을 업데이트해야 할 수도 있습니다. 다른 경우에는 값이 외부 요인\(예: 호스트 크기 및 통신 부하 분산, 근처 네트워크의 속도 및 토폴로지\)에 따라 달라지며 자체 조정 알고리즘을 사용할 수 없거나 충분하지 않을 수 있습니다. 어떤 경우에는 관리 요구 사항으로 인해 구성 가능성이 필요합니다.

- 마지막으로, 소스 없이 배포되고 불행히도 인터넷의 많은 부분에서 지속되는 오래되거나 잘못된 프로토콜 구현과 통신하려면 일부 구성 옵션이 필요합니다. 이러한 결함이 있는 시스템과 올바른 시스템이 공존하도록 하려면 관리자가 올바른 시스템을 "잘못 구성"해야 하는 경우가 많습니다. 이 문제는 결함이 있는 시스템이 폐기됨에 따라 점차적으로 해결되지만 공급업체에서는 이를 무시할 수 없습니다.

- 매개변수를 구성 가능해야 한다고 말할 때 부팅할 때마다 해당 값을 구성 파일에서 명시적으로 읽어오도록 요구하지는 않습니다. 구현자는 각 매개변수에 대한 기본값을 설정하는 것이 좋습니다. 따라서 구성 파일은 해당 기본값을 재정의하는 데에만 필요합니다.

---
# **RFC1122                       INTRODUCTION                  October 1989**

- 특정 설치에는 부적절합니다. 따라서 구성 가능성 요구 사항은 바이너리 전용 또는 ROM 기반 제품에서도 필요할 때 기본값을 재정의할 수 있다는 보장입니다.

- 이 문서에서는 경우에 따라 기본값에 대한 특정 값을 요구합니다. 기본값 선택은 구성 항목이 기존 결함이 있는 시스템에 대한 수용을 제어할 때 민감한 문제입니다. 인터넷이 성공적으로 통합되어 상호 운용성을 완성하려면 구현에 내장된 기본값은 잘못된 구현을 수용하기 위한 "잘못된 구성"이 아닌 공식 프로토콜을 구현해야 합니다. 마케팅 고려 사항으로 인해 일부 공급업체가 잘못된 구성 기본값을 선택하게 되었지만 표준을 준수하는 기본값을 선택하도록 공급업체에 권장합니다.

- 마지막으로, 공급업체는 모든 구성 매개변수, 그 한계 및 효과에 대한 적절한 문서를 제공해야 합니다.

1.3 이 문서 읽기

```text
      1.3.1  Organization
```

- 본 문서는 네트워크 소프트웨어 구현 시 구성 원칙으로 일반적으로 사용되는 프로토콜 레이어링\(Protocol Layering\)을 활용하여 구성하였습니다. 규칙을 설명할 때 우리는 구현이 프로토콜의 계층화를 엄격하게 반영한다고 가정합니다. 따라서 다음 세 가지 주요 섹션에서는 각각 링크 계층, 인터넷 계층 및 전송 계층에 대한 요구 사항을 지정합니다. 동반 RFC \[INTRO:1\]에서는 애플리케이션 수준 소프트웨어를 다루고 있습니다. 이 레이어주의 조직은 단순성과 명확성을 위해 선택되었습니다.

- 그러나 엄격한 계층화는 프로토콜 제품군과 권장되는 구현 접근 방식 모두에 대해 불완전한 모델입니다. 서로 다른 계층의 프로토콜은 복잡하고 때로는 미묘한 방식으로 상호 작용하며 특정 기능에는 종종 여러 계층이 포함됩니다. 구현에는 다양한 디자인 선택이 있으며 그 중 다수는 엄격한 계층화를 창의적으로 "파괴"하는 것과 관련됩니다. 모든 구현자는 참조 \[INTRO:7\] 및 \[INTRO:8\]을 읽어야 합니다.

- 이 문서는 TCP 사양 \[TCP:1\]에서 사용되는 것과 같은 기능적\("프로시저 호출"\) 표기법을 사용하여 계층 간의 개념적 서비스 인터페이스를 설명합니다. 호스트 구현은 논리적 정보 흐름을 지원해야 합니다.

---
# **RFC1122                       INTRODUCTION                  October 1989**

- 이러한 호출이 암시하지만 문자 그대로 호출 자체를 구현할 필요는 없습니다. 예를 들어, 많은 구현에서는 공통 데이터 구조에 대한 공유 액세스를 제공함으로써 전송 계층과 IP 계층 간의 결합을 반영합니다. 명시적인 프로시저 호출이 아닌 이러한 데이터 구조는 필요한 많은 정보를 전달하는 기관입니다.

- 일반적으로 이 문서의 각 주요 섹션은 다음과 같은 하위 섹션으로 구성됩니다.

```text
         (1)  Introduction

         (2)  Protocol Walk-Through -- considers the protocol
              specification documents section-by-section, correcting
              errors, stating requirements that may be ambiguous or
              ill-defined, and providing further clarification or
              explanation.

         (3)  Specific Issues -- discusses protocol design and
              implementation issues that were not included in the walk-
              through.

         (4)  Interfaces -- discusses the service interface to the next
              higher layer.

         (5)  Summary -- contains a summary of the requirements of the
              section.
```

- 이 문서의 많은 개별 주제 아래에는 "토론" 또는 "구현"이라는 라벨이 붙은 괄호 자료가 있습니다. 이 자료는 이전 요구 사항 텍스트에 대한 설명과 설명을 제공하기 위한 것입니다. 또한 가능한 향후 방향이나 개발에 대한 몇 가지 제안도 포함되어 있습니다. 구현 자료에는 구현자가 고려할 수 있는 제안된 접근 방식이 포함되어 있습니다.

- 요약 섹션은 텍스트에 대한 안내와 색인을 제공하기 위한 것이지만 필연적으로 난해하고 불완전합니다. 요약은 전체 RFC와 별도로 사용되거나 참조되어서는 안 됩니다.

```text
      1.3.2  Requirements
```

- 본 문서에서 각 특정 요구사항의 의미를 정의하는 데 사용되는 단어는 대문자로 표시됩니다.

---
# **RFC1122                       INTRODUCTION                  October 1989**

```text
         These words are:

         *    "MUST"

              This word or the adjective "REQUIRED" means that the item
              is an absolute requirement of the specification.

         *    "SHOULD"

              This word or the adjective "RECOMMENDED" means that there
              may exist valid reasons in particular circumstances to
              ignore this item, but the full implications should be
              understood and the case carefully weighed before choosing
              a different course.

         *    "MAY"

              This word or the adjective "OPTIONAL" means that this item
              is truly optional.  One vendor may choose to include the
              item because a particular marketplace requires it or
              because it enhances the product, for example; another
              vendor may omit the same item.
```

- 구현하는 프로토콜에 대한 MUST 요구 사항 중 하나 이상을 충족하지 못하는 경우 구현은 규격을 준수하지 않습니다. 해당 프로토콜에 대한 모든 MUST 및 모든 SHOULD 요구 사항을 충족하는 구현을 "무조건 준수"라고 합니다. 모든 MUST 요구 사항을 충족하지만 해당 프로토콜에 대한 모든 SHOULD 요구 사항을 충족하지 않는 프로토콜을 "조건부 준수"라고 합니다.

```text
      1.3.3  Terminology
```

- 이 문서에서는 다음과 같은 기술 용어를 사용합니다.

```text
         Segment
              A segment is the unit of end-to-end transmission in the
              TCP protocol.  A segment consists of a TCP header followed
              by application data.  A segment is transmitted by
              encapsulation inside an IP datagram.

         Message
              In this description of the lower-layer protocols, a
              message is the unit of transmission in a transport layer
              protocol.  In particular, a TCP segment is a message.  A
              message consists of a transport protocol header followed
              by application protocol data.  To be transmitted end-to-
```

---
# **RFC1122                       INTRODUCTION                  October 1989**

```text
              end through the Internet, a message must be encapsulated
              inside a datagram.

         IP Datagram
              An IP datagram is the unit of end-to-end transmission in
              the IP protocol.  An IP datagram consists of an IP header
              followed by transport layer data, i.e., of an IP header
              followed by a message.

              In the description of the internet layer (Section 3), the
              unqualified term "datagram" should be understood to refer
              to an IP datagram.

         Packet
              A packet is the unit of data passed across the interface
              between the internet layer and the link layer.  It
              includes an IP header and data.  A packet may be a
              complete IP datagram or a fragment of an IP datagram.

         Frame
              A frame is the unit of transmission in a link layer
              protocol, and consists of a link-layer header followed by
              a packet.

         Connected Network
              A network to which a host is interfaced is often known as
              the "local network" or the "subnetwork" relative to that
              host.  However, these terms can cause confusion, and
              therefore we use the term "connected network" in this
              document.

         Multihomed
              A host is said to be multihomed if it has multiple IP
              addresses.  For a discussion of multihoming, see Section
              3.3.4 below.

         Physical network interface
              This is a physical interface to a connected network and
              has a (possibly unique) link-layer address.  Multiple
              physical network interfaces on a single host may share the
              same link-layer address, but the address must be unique
              for different hosts on the same physical network.

         Logical [network] interface
              We define a logical [network] interface to be a logical
              path, distinguished by a unique IP address, to a connected
              network.  See Section 3.3.4.
```

---
# **RFC1122                       INTRODUCTION                  October 1989**

```text
         Specific-destination address
              This is the effective destination address of a datagram,
              even if it is broadcast or multicast; see Section 3.2.1.3.

         Path
              At a given moment, all the IP datagrams from a particular
              source host to a particular destination host will
              typically traverse the same sequence of gateways.  We use
              the term "path" for this sequence.  Note that a path is
              uni-directional; it is not unusual to have different paths
              in the two directions between a given host pair.

         MTU
              The maximum transmission unit, i.e., the size of the
              largest packet that can be transmitted.
```

- 프레임, 패킷, 데이터그램, 메시지 및 세그먼트라는 용어는 다음 도식 다이어그램으로 설명됩니다.

```text
         A. Transmission on connected network:
           _______________________________________________
          | LL hdr | IP hdr |         (data)              |
          |________|________|_____________________________|

           <---------- Frame ----------------------------->
                    <----------Packet -------------------->

         B. Before IP fragmentation or after IP reassembly:
                    ______________________________________
                   | IP hdr | transport| Application Data |
                   |________|____hdr___|__________________|

                    <--------  Datagram ------------------>
                             <-------- Message ----------->
           or, for TCP:
                    ______________________________________
                   | IP hdr |  TCP hdr | Application Data |
                   |________|__________|__________________|

                    <--------  Datagram ------------------>
                             <-------- Segment ----------->
```

---
# **RFC1122                       INTRODUCTION                  October 1989**

```text
   1.4  Acknowledgments
```

- 이 문서에는 대학 및 연구소 대표, 공급업체 및 정부 기관을 포함한 대규모 인터넷 프로토콜 전문가 그룹의 기고문과 의견이 포함되어 있습니다. 이는 주로 IETF\(Internet Engineering Task Force\)의 호스트 요구 사항 작업 그룹에 의해 구성되었습니다.

- 편집자는 특히 이 문서를 작성하기 위해 지난 18개월 동안 많은 긴 회의에 참석하고 300만 바이트의 전자 메일을 생성한 다음 사람들의 지칠 줄 모르는 헌신에 감사를 표하고 싶습니다. Philip Almquist, Dave Borman\(Cray Research\), 노엘 치아파, 데이브 크로커\(DEC\), 스티브 디어링\(스탠포드\), 마이크 카렐스\(버클리\), 필 칸\(벨코어\), 존 레카슈만\(NASA\), 찰스 린\(BBN\), 키스 맥로그리\(TWG\), 폴 모카페트리스\(ISI\) , Thomas Narten\(퍼듀\), Craig Partridge\(BBN\), Drew Perkins\(CMU\) 및 James Van Bokkelen\(FTP 소프트웨어\).

- 또한 이 노력에 크게 기여한 사람들은 다음과 같습니다: Bill Barns\(Mitre\), Steve Bellovin\(AT&T\), Mike Brescia\(BBN\), Ed Cain\(DCA\), Annette DeSchon\(ISI\), Martin Gross\(DCA\), Phill Gross\(NRI\), Charles Hedrick\(Rutgers\), Van Jacobson\(LBL\), John Klensin\(MIT\), Mark Lottor\(SRI\), Milo Medin\(NASA\), Bill Melohn\(Sun Microsystems\), Greg Minshall\(Kinetics\), Jeff Mogul\(DEC\), John Mullen\(CMC\), Jon Postel\(ISI\), John Romkey\(Epilogue Technology\) 및 Mike StJohns\(DCA\). 다음은 또한 특정 영역에 상당한 기여를 했습니다: Eric Allman\(Berkeley\), Rob Austein\(MIT\), Art Berggreen\(ACC\), Keith Bostic\(Berkeley\), Vint Cerf\(NRI\), Wayne Hathaway\(NASA\), Matt Korn\(IBM\) \), Erik Naggum\(노르웨이 Naggum Software\), Robert Ullmann\(프라임 컴퓨터\), David Waitzman\(BBN\), Frank Wancho\(미국\), Arun Welch\(오하이오 주립\), Bill Westfield\(Cisco\) 및 Rayan Zachariassen\(토론토\).

- 본 목록에서 실수로 누락된 기여자를 포함한 모든 분들께 감사드립니다.

---
# **RFC1122                        LINK LAYER                   October 1989**
---
## **2. LINK LAYER**

```text
   2.1  INTRODUCTION
```

- 호스트와 게이트웨이 등 모든 인터넷 시스템은 링크 계층 프로토콜에 대해 동일한 요구 사항을 갖습니다. 이러한 요구 사항은 "인터넷 게이트웨이 요구 사항"\[소개:2\]의 3장에 나와 있으며 이 섹션의 자료로 보완됩니다.

```text
   2.2  PROTOCOL WALK-THROUGH

      None.

   2.3  SPECIFIC ISSUES

      2.3.1  Trailer Protocol Negotiation
```

- 링크 계층 캡슐화를 위한 트레일러 프로토콜 \[LINK:1\]을 사용할 수 있지만 링크 계층 통신에 관련된 두 시스템\(호스트 또는 게이트웨이\) 모두 트레일러를 구현하는 것이 확인된 경우에만 사용할 수 있습니다. 시스템이 대상별로 트레일러 프로토콜 사용을 동적으로 협상하지 않는 경우 기본 구성은 프로토콜을 비활성화해야 합니다.

```text
         DISCUSSION:
              The trailer protocol is a link-layer encapsulation
              technique that rearranges the data contents of packets
              sent on the physical network.  In some cases, trailers
              improve the throughput of higher layer protocols by
              reducing the amount of data copying within the operating
              system.  Higher layer protocols are unaware of trailer
              use, but both the sending and receiving host MUST
              understand the protocol if it is used.

              Improper use of trailers can result in very confusing
              symptoms.  Only packets with specific size attributes are
              encapsulated using trailers, and typically only a small
              fraction of the packets being exchanged have these
              attributes.  Thus, if a system using trailers exchanges
              packets with a system that does not, some packets
              disappear into a black hole while others are delivered
              successfully.

         IMPLEMENTATION:
              On an Ethernet, packets encapsulated with trailers use a
              distinct Ethernet type [LINK:1], and trailer negotiation
              is performed at the time that ARP is used to discover the
              link-layer address of a destination system.
```

---
# **RFC1122                        LINK LAYER                   October 1989**

```text
              Specifically, the ARP exchange is completed in the usual
              manner using the normal IP protocol type, but a host that
              wants to speak trailers will send an additional "trailer
              ARP reply" packet, i.e., an ARP reply that specifies the
              trailer encapsulation protocol type but otherwise has the
              format of a normal ARP reply.  If a host configured to use
              trailers receives a trailer ARP reply message from a
              remote machine, it can add that machine to the list of
              machines that understand trailers, e.g., by marking the
              corresponding entry in the ARP cache.

              Hosts wishing to receive trailer encapsulations send
              trailer ARP replies whenever they complete exchanges of
              normal ARP messages for IP.  Thus, a host that received an
              ARP request for its IP protocol address would send a
              trailer ARP reply in addition to the normal IP ARP reply;
              a host that sent the IP ARP request would send a trailer
              ARP reply when it received the corresponding IP ARP reply.
              In this way, either the requesting or responding host in
              an IP ARP exchange may request that it receive trailer
              encapsulations.

              This scheme, using extra trailer ARP reply packets rather
              than sending an ARP request for the trailer protocol type,
              was designed to avoid a continuous exchange of ARP packets
              with a misbehaving host that, contrary to any
              specification or common sense, responded to an ARP reply
              for trailers with another ARP reply for IP.  This problem
              is avoided by sending a trailer ARP reply in response to
              an IP ARP reply only when the IP ARP reply answers an
              outstanding request; this is true when the hardware
              address for the host is still unknown when the IP ARP
              reply is received.  A trailer ARP reply may always be sent
              along with an IP ARP reply responding to an IP ARP
              request.

      2.3.2  Address Resolution Protocol -- ARP

         2.3.2.1  ARP Cache Validation

            An implementation of the Address Resolution Protocol (ARP)
            [LINK:2] MUST provide a mechanism to flush out-of-date cache
            entries.  If this mechanism involves a timeout, it SHOULD be
            possible to configure the timeout value.

            A mechanism to prevent ARP flooding (repeatedly sending an
            ARP Request for the same IP address, at a high rate) MUST be
            included.  The recommended maximum rate is 1 per second per
```

---
# **RFC1122                        LINK LAYER                   October 1989**

```text
            destination.

            DISCUSSION:
                 The ARP specification [LINK:2] suggests but does not
                 require a timeout mechanism to invalidate cache entries
                 when hosts change their Ethernet addresses.  The
                 prevalence of proxy ARP (see Section 2.4 of [INTRO:2])
                 has significantly increased the likelihood that cache
                 entries in hosts will become invalid, and therefore
                 some ARP-cache invalidation mechanism is now required
                 for hosts.  Even in the absence of proxy ARP, a long-
                 period cache timeout is useful in order to
                 automatically correct any bad ARP data that might have
                 been cached.

            IMPLEMENTATION:
                 Four mechanisms have been used, sometimes in
                 combination, to flush out-of-date cache entries.

                 (1)  Timeout -- Periodically time out cache entries,
                      even if they are in use.  Note that this timeout
                      should be restarted when the cache entry is
                      "refreshed" (by observing the source fields,
                      regardless of target address, of an ARP broadcast
                      from the system in question).  For proxy ARP
                      situations, the timeout needs to be on the order
                      of a minute.

                 (2)  Unicast Poll -- Actively poll the remote host by
                      periodically sending a point-to-point ARP Request
                      to it, and delete the entry if no ARP Reply is
                      received from N successive polls.  Again, the
                      timeout should be on the order of a minute, and
                      typically N is 2.

                 (3)  Link-Layer Advice -- If the link-layer driver
                      detects a delivery problem, flush the
                      corresponding ARP cache entry.

                 (4)  Higher-layer Advice -- Provide a call from the
                      Internet layer to the link layer to indicate a
                      delivery problem.  The effect of this call would
                      be to invalidate the corresponding cache entry.
                      This call would be analogous to the
                      "ADVISE_DELIVPROB()" call from the transport layer
                      to the Internet layer (see Section 3.4), and in
                      fact the ADVISE_DELIVPROB routine might in turn
                      call the link-layer advice routine to invalidate
```

---
# **RFC1122                        LINK LAYER                   October 1989**

- ARP 캐시 항목.

```text
                 Approaches (1) and (2) involve ARP cache timeouts on
                 the order of a minute or less.  In the absence of proxy
                 ARP, a timeout this short could create noticeable
                 overhead traffic on a very large Ethernet.  Therefore,
                 it may be necessary to configure a host to lengthen the
                 ARP cache timeout.

         2.3.2.2  ARP Packet Queue

            The link layer SHOULD save (rather than discard) at least
            one (the latest) packet of each set of packets destined to
            the same unresolved IP address, and transmit the saved
            packet when the address has been resolved.

            DISCUSSION:
                 Failure to follow this recommendation causes the first
                 packet of every exchange to be lost.  Although higher-
                 layer protocols can generally cope with packet loss by
                 retransmission, packet loss does impact performance.
                 For example, loss of a TCP open request causes the
                 initial round-trip time estimate to be inflated.  UDP-
                 based applications such as the Domain Name System are
                 more seriously affected.
```

- 2.3.3 이더넷 및 IEEE 802 캡슐화

- 이더넷에 대한 IP 캡슐화는 RFC-894 \[LINK:3\]에 설명되어 있는 반면, RFC-1042 \[LINK:4\]는 IEEE 802 네트워크에 대한 IP 캡슐화에 대해 설명합니다. RFC-1042는 \[INTRO:2\] 섹션 3.4의 논의를 자세히 설명하고 대체합니다.

- 10Mbps 이더넷 케이블에 연결된 모든 인터넷 호스트:

```text
         o    MUST be able to send and receive packets using RFC-894
              encapsulation;

         o    SHOULD be able to receive RFC-1042 packets, intermixed
              with RFC-894 packets; and
```

- o RFC-1042 캡슐화를 사용하여 패킷을 보낼 수 있습니다.

- RFC-894 및 RFC-1042 캡슐화 전송을 모두 구현하는 인터넷 호스트는 전송되는 것을 선택하는 구성 스위치를 제공해야 하며 이 스위치는 기본적으로 RFC-894로 설정되어야 합니다.

---
# **RFC1122                        LINK LAYER                   October 1989**

- RFC-1042의 표준 IP 캡슐화는 IEEE가 IP용으로 예약한 프로토콜 ID 값\(K1=6\)을 사용하지 않습니다. 대신 Ether-Type 필드를 보유하는 데 사용할 수 있는 확장\("SNAP"\)을 의미하는 값\(K1=170\)을 사용합니다. 인터넷 시스템은 K1=6을 사용하여 802 패킷을 보내면 안 됩니다.

- 인터넷 주소에서 이더넷 및 IEEE 802 네트워크의 링크 계층 주소로의 주소 변환은 ARP\(주소 확인 프로토콜\)에 의해 관리되어야 합니다.

- 이더넷의 MTU는 1500이고 802.3의 MTU는 1492입니다.

```text
         DISCUSSION:
              The IEEE 802.3 specification provides for operation over a
              10Mbps Ethernet cable, in which case Ethernet and IEEE
              802.3 frames can be physically intermixed.  A receiver can
              distinguish Ethernet and 802.3 frames by the value of the
              802.3 Length field; this two-octet field coincides in the
              header with the Ether-Type field of an Ethernet frame.  In
              particular, the 802.3 Length field must be less than or
              equal to 1500, while all valid Ether-Type values are
              greater than 1500.

              Another compatibility problem arises with link-layer
              broadcasts.  A broadcast sent with one framing will not be
              seen by hosts that can receive only the other framing.

              The provisions of this section were designed to provide
              direct interoperation between 894-capable and 1042-capable
              systems on the same cable, to the maximum extent possible.
              It is intended to support the present situation where
              894-only systems predominate, while providing an easy
              transition to a possible future in which 1042-capable
              systems become common.

              Note that 894-only systems cannot interoperate directly
              with 1042-only systems.  If the two system types are set
              up as two different logical networks on the same cable,
              they can communicate only through an IP gateway.
              Furthermore, it is not useful or even possible for a
              dual-format host to discover automatically which format to
              send, because of the problem of link-layer broadcasts.

   2.4  LINK/INTERNET LAYER INTERFACE
```

- IP 계층과 링크 계층 사이의 패킷 수신 인터페이스에는 들어오는 패킷이 링크 계층 브로드캐스트 주소로 지정되었는지 여부를 나타내는 플래그가 포함되어야 합니다.

---
# **RFC1122                        LINK LAYER                   October 1989**

```text
      DISCUSSION
           Although the IP layer does not generally know link layer
           addresses (since every different network medium typically has
           a different address format), the broadcast address on a
           broadcast-capable medium is an important special case.  See
           Section 3.2.2, especially the DISCUSSION concerning broadcast
           storms.
```

- IP와 링크 계층 사이의 패킷 전송 인터페이스는 5비트 TOS 필드를 포함해야 합니다\(섹션 3.2.1.6 참조\).

- 링크 계층은 목적지에 대한 ARP 캐시 항목이 없다는 이유만으로 목적지 도달 불가능 오류를 IP에 보고해서는 안 됩니다.

```text
   2.5  LINK LAYER REQUIREMENTS SUMMARY

                                                  |       | | | |S| |
                                                  |       | | | |H| |F
                                                  |       | | | |O|M|o
                                                  |       | |S| |U|U|o
                                                  |       | |H| |L|S|t
                                                  |       |M|O| |D|T|n
                                                  |       |U|U|M| | |o
                                                  |       |S|L|A|N|N|t
                                                  |       |T|D|Y|O|O|t
FEATURE                                           |SECTION| | | |T|T|e
--------------------------------------------------|-------|-|-|-|-|-|--
                                                  |       | | | | | |
Trailer encapsulation                             |2.3.1  | | |x| | |
Send Trailers by default without negotiation      |2.3.1  | | | | |x|
ARP                                               |2.3.2  | | | | | |
  Flush out-of-date ARP cache entries             |2.3.2.1|x| | | | |
  Prevent ARP floods                              |2.3.2.1|x| | | | |
  Cache timeout configurable                      |2.3.2.1| |x| | | |
  Save at least one (latest) unresolved pkt       |2.3.2.2| |x| | | |
Ethernet and IEEE 802 Encapsulation               |2.3.3  | | | | | |
  Host able to:                                   |2.3.3  | | | | | |
    Send & receive RFC-894 encapsulation          |2.3.3  |x| | | | |
    Receive RFC-1042 encapsulation                |2.3.3  | |x| | | |
    Send RFC-1042 encapsulation                   |2.3.3  | | |x| | |
      Then config. sw. to select, RFC-894 dflt    |2.3.3  |x| | | | |
  Send K1=6 encapsulation                         |2.3.3  | | | | |x|
  Use ARP on Ethernet and IEEE 802 nets           |2.3.3  |x| | | | |
Link layer report b'casts to IP layer             |2.4    |x| | | | |
IP layer pass TOS to link layer                   |2.4    |x| | | | |
No ARP cache entry treated as Dest. Unreach.      |2.4    | | | | |x|
```

---
# **RFC1122                      INTERNET LAYER                 October 1989**
---
## **3. INTERNET LAYER PROTOCOLS**

```text
   3.1 INTRODUCTION
```

- 견고성 원칙: "받아들이는 것에 자유로워지고 보내는 것에 보수적이어야 합니다."는 한 명의 잘못된 호스트가 다른 많은 호스트에 대한 인터넷 서비스를 거부할 수 있는 인터넷 계층에서 특히 중요합니다.

- 인터넷 계층에서 사용되는 프로토콜 표준은 다음과 같습니다.

```text
      o    RFC-791 [IP:1] defines the IP protocol and gives an
           introduction to the architecture of the Internet.

      o    RFC-792 [IP:2] defines ICMP, which provides routing,
           diagnostic and error functionality for IP.  Although ICMP
           messages are encapsulated within IP datagrams, ICMP
           processing is considered to be (and is typically implemented
           as) part of the IP layer.  See Section 3.2.2.

      o    RFC-950 [IP:3] defines the mandatory subnet extension to the
           addressing architecture.

      o    RFC-1112 [IP:4] defines the Internet Group Management
           Protocol IGMP, as part of a recommended extension to hosts
           and to the host-gateway interface to support Internet-wide
           multicasting at the IP level.  See Section 3.2.3.

           The target of an IP multicast may be an arbitrary group of
           Internet hosts.  IP multicasting is designed as a natural
           extension of the link-layer multicasting facilities of some
           networks, and it provides a standard means for local access
           to such link-layer multicasting facilities.
```

- 기타 중요한 참고 자료는 이 문서의 섹션 5에 나열되어 있습니다.

- 호스트 소프트웨어의 인터넷 계층은 IP와 ICMP를 모두 구현해야 합니다. IGMP 지원에 대한 요구 사항은 섹션 3.3.7을 참조하세요.

- 호스트 IP 계층에는 두 가지 기본 기능이 있습니다. \(1\) 나가는 IP 데이터그램에 대한 "다음 홉" 게이트웨이 또는 호스트를 선택하고 \(2\) 들어오는 IP 데이터그램을 재조립합니다. IP 계층은 \(3\) 나가는 데이터그램의 의도적인 조각화를 구현할 수도 있습니다. 마지막으로 IP 계층은 \(4\) 진단 및 오류 기능을 제공해야 합니다. 우리는 인터넷 제어 및 관리 시설이 추가로 개발됨에 따라 IP 계층 기능이 향후 다소 증가할 것으로 예상합니다.

---
# **RFC1122                      INTERNET LAYER                 October 1989**

- 일반 데이터그램의 경우 처리가 간단합니다. 들어오는 데이터그램의 경우 IP 계층은 다음을 수행합니다.

- \(1\) 데이터그램의 형식이 올바른지 확인합니다.

- \(2\) 로컬 호스트를 대상으로 하는지 확인합니다.

```text
      (3)  processes options;
```

- \(4\) 필요한 경우 데이터그램을 재조립합니다. 그리고

```text
      (5)  passes the encapsulated message to the appropriate
           transport-layer protocol module.
```

- 나가는 데이터그램의 경우 IP 계층은 다음을 수행합니다.

- \(1\) 전송 계층에 의해 설정되지 않은 필드를 설정합니다.

```text
      (2)  selects the correct first hop on the connected network (a
           process called "routing");

      (3)  fragments the datagram if necessary and if intentional
           fragmentation is implemented (see Section 3.3.3); and
```

- \(4\) 패킷을 적절한 링크 계층 드라이버로 전달합니다.

- 호스트에 IP 주소가 여러 개 있으면 멀티홈이라고 합니다. 멀티호밍은 프로토콜 제품군에 상당한 혼란과 복잡성을 가져오며 인터넷 아키텍처가 모든 문제를 해결하기에는 심각하게 부족한 영역입니다. 멀티호밍에는 두 가지 뚜렷한 문제 영역이 있습니다.

- \(1\) 로컬 멀티홈 - 호스트 자체가 멀티홈입니다. 또는

```text
      (2)  Remote multihoming -- the local host needs to communicate
           with a remote multihomed host.
```

- 현재, 원격 멀티호밍은 RFC \[INTRO:1\]에서 논의된 것처럼 애플리케이션 계층에서 처리되어야 합니다. 호스트는 이 문서, 특히 섹션 3.3.4에서 논의되는 로컬 멀티호밍을 지원할 수 있습니다.

- 다른 호스트에 의해 생성된 데이터그램을 전달하는 모든 호스트는 게이트웨이 역할을 하며 게이트웨이 요구 사항 RFC \[INTRO:2\]에 명시된 사양도 충족해야 합니다. 내장된 게이트웨이 코드를 포함하는 인터넷 호스트에는 게이트웨이 기능을 비활성화하는 구성 스위치가 있어야 하며 이 스위치는 기본적으로

---
# **RFC1122                      INTERNET LAYER                 October 1989**

- 비게이트웨이 모드. 이 모드에서는 호스트가 단일 홈인지 멀티홈인지에 관계없이 하나의 인터페이스를 통해 도착하는 데이터그램이 다른 호스트나 게이트웨이로 전달되지 않습니다\(소스 라우팅이 아닌 경우\). 호스트에 둘 이상의 인터페이스가 있는 경우 호스트 소프트웨어는 자동으로 게이트웨이 모드로 전환되어서는 안 됩니다. 머신의 운영자는 해당 서비스를 제공하기를 원하지 않거나 그렇게 할 능력이 없을 수 있기 때문입니다.

- 다음에서 특정 경우에 지정된 작업은 수신된 데이터그램을 "자동으로 삭제"하는 것입니다. 이는 데이터그램이 추가 처리 없이 폐기되고 결과적으로 호스트가 ICMP 오류 메시지\(섹션 3.2.2 참조\)를 보내지 않음을 의미합니다. 그러나 문제 진단을 위해 호스트는 자동으로 폐기된 데이터그램의 내용을 포함하여 오류를 기록하는 기능\(섹션 1.2.3 참조\)을 제공해야 하며 통계 카운터에 이벤트를 기록해야 합니다.

```text
      DISCUSSION:
           Silent discard of erroneous datagrams is generally intended
           to prevent "broadcast storms".

   3.2  PROTOCOL WALK-THROUGH

      3.2.1 Internet Protocol -- IP

         3.2.1.1  Version Number: RFC-791 Section 3.1

            A datagram whose version number is not 4 MUST be silently
            discarded.

         3.2.1.2  Checksum: RFC-791 Section 3.1

            A host MUST verify the IP header checksum on every received
            datagram and silently discard every datagram that has a bad
            checksum.

         3.2.1.3  Addressing: RFC-791 Section 3.2

            There are now five classes of IP addresses: Class A through
            Class E.  Class D addresses are used for IP multicasting
            [IP:4], while Class E addresses are reserved for
            experimental use.

            A multicast (Class D) address is a 28-bit logical address
            that stands for a group of hosts, and may be either
            permanent or transient.  Permanent multicast addresses are
            allocated by the Internet Assigned Number Authority
            [INTRO:6], while transient addresses may be allocated
```

---
# **RFC1122                      INTERNET LAYER                 October 1989**

```text
            dynamically to transient groups.  Group membership is
            determined dynamically using IGMP [IP:4].

            We now summarize the important special cases for Class A, B,
            and C IP addresses, using the following notation for an IP
            address:

                { <Network-number>, <Host-number> }

            or
                { <Network-number>, <Subnet-number>, <Host-number> }

            and the notation "-1" for a field that contains all 1 bits.
            This notation is not intended to imply that the 1-bits in an
            address mask need be contiguous.

            (a)  { 0, 0 }

                 This host on this network.  MUST NOT be sent, except as
                 a source address as part of an initialization procedure
                 by which the host learns its own IP address.
```

- {0,0}의 비표준 사용에 대해서는 섹션 3.3.6을 참조하세요.

```text
            (b)  { 0, <Host-number> }

                 Specified host on this network.  It MUST NOT be sent,
                 except as a source address as part of an initialization
                 procedure by which the host learns its full IP address.

            (c)  { -1, -1 }

                 Limited broadcast.  It MUST NOT be used as a source
                 address.

                 A datagram with this destination address will be
                 received by every host on the connected physical
                 network but will not be forwarded outside that network.

            (d)  { <Network-number>, -1 }

                 Directed broadcast to the specified network.  It MUST
                 NOT be used as a source address.

            (e)  { <Network-number>, <Subnet-number>, -1 }

                 Directed broadcast to the specified subnet.  It MUST
                 NOT be used as a source address.
```

---
# **RFC1122                      INTERNET LAYER                 October 1989**

```text
            (f)  { <Network-number>, -1, -1 }

                 Directed broadcast to all subnets of the specified
                 subnetted network.  It MUST NOT be used as a source
                 address.

            (g)  { 127, <any> }

                 Internal host loopback address.  Addresses of this form
                 MUST NOT appear outside a host.

            The <Network-number> is administratively assigned so that
            its value will be unique in the entire world.

            IP addresses are not permitted to have the value 0 or -1 for
            any of the <Host-number>, <Network-number>, or <Subnet-
            number> fields (except in the special cases listed above).
            This implies that each of these fields will be at least two
            bits long.

            For further discussion of broadcast addresses, see Section
            3.3.6.

            A host MUST support the subnet extensions to IP [IP:3].  As
            a result, there will be an address mask of the form:
            {-1, -1, 0} associated with each of the host's local IP
            addresses; see Sections 3.2.2.9 and 3.3.1.1.

            When a host sends any datagram, the IP source address MUST
            be one of its own IP addresses (but not a broadcast or
            multicast address).

            A host MUST silently discard an incoming datagram that is
            not destined for the host.  An incoming datagram is destined
            for the host if the datagram's destination address field is:
```

- \(1\) 호스트의 IP 주소 중 하나; 또는

```text
            (2)  an IP broadcast address valid for the connected
                 network; or

            (3)  the address for a multicast group of which the host is
                 a member on the incoming physical interface.

            For most purposes, a datagram addressed to a broadcast or
            multicast destination is processed as if it had been
            addressed to one of the host's IP addresses; we use the term
            "specific-destination address" for the equivalent local IP
```

---
# **RFC1122                      INTERNET LAYER                 October 1989**

```text
            address of the host.  The specific-destination address is
            defined to be the destination address in the IP header
            unless the header contains a broadcast or multicast address,
            in which case the specific-destination is an IP address
            assigned to the physical interface on which the datagram
            arrived.

            A host MUST silently discard an incoming datagram containing
            an IP source address that is invalid by the rules of this
            section.  This validation could be done in either the IP
            layer or by each protocol in the transport layer.

            DISCUSSION:
                 A mis-addressed datagram might be caused by a link-
                 layer broadcast of a unicast datagram or by a gateway
                 or host that is confused or mis-configured.

                 An architectural goal for Internet hosts was to allow
                 IP addresses to be featureless 32-bit numbers, avoiding
                 algorithms that required a knowledge of the IP address
                 format.  Otherwise, any future change in the format or
                 interpretation of IP addresses will require host
                 software changes.  However, validation of broadcast and
                 multicast addresses violates this goal; a few other
                 violations are described elsewhere in this document.

                 Implementers should be aware that applications
                 depending upon the all-subnets directed broadcast
                 address (f) may be unusable on some networks.  All-
                 subnets broadcast is not widely implemented in vendor
                 gateways at present, and even when it is implemented, a
                 particular network administration may disable it in the
                 gateway configuration.
```

- 3.2.1.4 조각화 및 재조립: RFC-791 섹션 3.2

```text
            The Internet model requires that every host support
            reassembly.  See Sections 3.3.2 and 3.3.3 for the
            requirements on fragmentation and reassembly.

         3.2.1.5  Identification: RFC-791 Section 3.2

            When sending an identical copy of an earlier datagram, a
            host MAY optionally retain the same Identification field in
            the copy.
```

---
# **RFC1122                      INTERNET LAYER                 October 1989**

```text
            DISCUSSION:
                 Some Internet protocol experts have maintained that
                 when a host sends an identical copy of an earlier
                 datagram, the new copy should contain the same
                 Identification value as the original.  There are two
                 suggested advantages:  (1) if the datagrams are
                 fragmented and some of the fragments are lost, the
                 receiver may be able to reconstruct a complete datagram
                 from fragments of the original and the copies; (2) a
                 congested gateway might use the IP Identification field
                 (and Fragment Offset) to discard duplicate datagrams
                 from the queue.

                 However, the observed patterns of datagram loss in the
                 Internet do not favor the probability of retransmitted
                 fragments filling reassembly gaps, while other
                 mechanisms (e.g., TCP repacketizing upon
                 retransmission) tend to prevent retransmission of an
                 identical datagram [IP:9].  Therefore, we believe that
                 retransmitting the same Identification field is not
                 useful.  Also, a connectionless transport protocol like
                 UDP would require the cooperation of the application
                 programs to retain the same Identification value in
                 identical datagrams.

         3.2.1.6  Type-of-Service: RFC-791 Section 3.2

            The "Type-of-Service" byte in the IP header is divided into
            two sections:  the Precedence field (high-order 3 bits), and
            a field that is customarily called "Type-of-Service" or
            "TOS" (low-order 5 bits).  In this document, all references
            to "TOS" or the "TOS field" refer to the low-order 5 bits
            only.

            The Precedence field is intended for Department of Defense
            applications of the Internet protocols.  The use of non-zero
            values in this field is outside the scope of this document
            and the IP standard specification.  Vendors should consult
            the Defense Communication Agency (DCA) for guidance on the
            IP Precedence field and its implications for other protocol
            layers.  However, vendors should note that the use of
            precedence will most likely require that its value be passed
            between protocol layers in just the same way as the TOS
            field is passed.

            The IP layer MUST provide a means for the transport layer to
            set the TOS field of every datagram that is sent; the
            default is all zero bits.  The IP layer SHOULD pass received
```

---
# **RFC1122                      INTERNET LAYER                 October 1989**

- 전송 계층까지의 TOS 값.

```text
            The particular link-layer mappings of TOS contained in RFC-
            795 SHOULD NOT be implemented.

            DISCUSSION:
                 While the TOS field has been little used in the past,
                 it is expected to play an increasing role in the near
                 future.  The TOS field is expected to be used to
                 control two aspects of gateway operations: routing and
                 queueing algorithms.  See Section 2 of [INTRO:1] for
                 the requirements on application programs to specify TOS
                 values.

                 The TOS field may also be mapped into link-layer
                 service selectors.  This has been applied to provide
                 effective sharing of serial lines by different classes
                 of TCP traffic, for example.  However, the mappings
                 suggested in RFC-795 for networks that were included in
                 the Internet as of 1981 are now obsolete.

         3.2.1.7  Time-to-Live: RFC-791 Section 3.2

            A host MUST NOT send a datagram with a Time-to-Live (TTL)
            value of zero.

            A host MUST NOT discard a datagram just because it was
            received with TTL less than 2.

            The IP layer MUST provide a means for the transport layer to
            set the TTL field of every datagram that is sent.  When a
            fixed TTL value is used, it MUST be configurable.  The
            current suggested value will be published in the "Assigned
            Numbers" RFC.

            DISCUSSION:
                 The TTL field has two functions: limit the lifetime of
                 TCP segments (see RFC-793 [TCP:1], p. 28), and
                 terminate Internet routing loops.  Although TTL is a
                 time in seconds, it also has some attributes of a hop-
                 count, since each gateway is required to reduce the TTL
                 field by at least one.

                 The intent is that TTL expiration will cause a datagram
                 to be discarded by a gateway but not by the destination
                 host; however, hosts that act as gateways by forwarding
                 datagrams must follow the gateway rules for TTL.
```

---
# **RFC1122                      INTERNET LAYER                 October 1989**

```text
                 A higher-layer protocol may want to set the TTL in
                 order to implement an "expanding scope" search for some
                 Internet resource.  This is used by some diagnostic
                 tools, and is expected to be useful for locating the
                 "nearest" server of a given class using IP
                 multicasting, for example.  A particular transport
                 protocol may also want to specify its own TTL bound on
                 maximum datagram lifetime.

                 A fixed value must be at least big enough for the
                 Internet "diameter," i.e., the longest possible path.
                 A reasonable value is about twice the diameter, to
                 allow for continued Internet growth.

         3.2.1.8  Options: RFC-791 Section 3.2

            There MUST be a means for the transport layer to specify IP
            options to be included in transmitted IP datagrams (see
            Section 3.4).

            All IP options (except NOP or END-OF-LIST) received in
            datagrams MUST be passed to the transport layer (or to ICMP
            processing when the datagram is an ICMP message).  The IP
            and transport layer MUST each interpret those IP options
            that they understand and silently ignore the others.

            Later sections of this document discuss specific IP option
            support required by each of ICMP, TCP, and UDP.

            DISCUSSION:
                 Passing all received IP options to the transport layer
                 is a deliberate "violation of strict layering" that is
                 designed to ease the introduction of new transport-
                 relevant IP options in the future.  Each layer must
                 pick out any options that are relevant to its own
                 processing and ignore the rest.  For this purpose,
                 every IP option except NOP and END-OF-LIST will include
                 a specification of its own length.

                 This document does not define the order in which a
                 receiver must process multiple options in the same IP
                 header.  Hosts sending multiple options must be aware
                 that this introduces an ambiguity in the meaning of
                 certain options when combined with a source-route
                 option.

            IMPLEMENTATION:
                 The IP layer must not crash as the result of an option
```

---
# **RFC1122                      INTERNET LAYER                 October 1989**

```text
                 length that is outside the possible range.  For
                 example, erroneous option lengths have been observed to
                 put some IP implementations into infinite loops.
```

- 특정 IP 옵션에 대한 요구 사항은 다음과 같습니다.

```text
            (a)  Security Option

                 Some environments require the Security option in every
                 datagram; such a requirement is outside the scope of
                 this document and the IP standard specification.  Note,
                 however, that the security options described in RFC-791
                 and RFC-1038 are obsolete.  For DoD applications,
                 vendors should consult [IP:8] for guidance.

            (b)  Stream Identifier Option

                 This option is obsolete; it SHOULD NOT be sent, and it
                 MUST be silently ignored if received.

            (c)  Source Route Options

                 A host MUST support originating a source route and MUST
                 be able to act as the final destination of a source
                 route.

                 If host receives a datagram containing a completed
                 source route (i.e., the pointer points beyond the last
                 field), the datagram has reached its final destination;
                 the option as received (the recorded route) MUST be
                 passed up to the transport layer (or to ICMP message
                 processing).  This recorded route will be reversed and
                 used to form a return source route for reply datagrams
                 (see discussion of IP Options in Section 4).  When a
                 return source route is built, it MUST be correctly
                 formed even if the recorded route included the source
                 host (see case (B) in the discussion below).

                 An IP header containing more than one Source Route
                 option MUST NOT be sent; the effect on routing of
                 multiple Source Route options is implementation-
                 specific.

                 Section 3.3.5 presents the rules for a host acting as
                 an intermediate hop in a source route, i.e., forwarding
```

---
# **RFC1122                      INTERNET LAYER                 October 1989**

- 소스 라우팅 데이터그램.

```text
                 DISCUSSION:
                      If a source-routed datagram is fragmented, each
                      fragment will contain a copy of the source route.
                      Since the processing of IP options (including a
                      source route) must precede reassembly, the
                      original datagram will not be reassembled until
                      the final destination is reached.

                      Suppose a source routed datagram is to be routed
                      from host S to host D via gateways G1, G2, ... Gn.
                      There was an ambiguity in the specification over
                      whether the source route option in a datagram sent
                      out by S should be (A) or (B):

                          (A):  {>>G2, G3, ... Gn, D}     <--- CORRECT

                          (B):  {S, >>G2, G3, ... Gn, D}  <---- WRONG

                      (where >> represents the pointer).  If (A) is
                      sent, the datagram received at D will contain the
                      option: {G1, G2, ... Gn >>}, with S and D as the
                      IP source and destination addresses.  If (B) were
                      sent, the datagram received at D would again
                      contain S and D as the same IP source and
                      destination addresses, but the option would be:
                      {S, G1, ...Gn >>}; i.e., the originating host
                      would be the first hop in the route.

            (d)  Record Route Option

                 Implementation of originating and processing the Record
                 Route option is OPTIONAL.

            (e)  Timestamp Option

                 Implementation of originating and processing the
                 Timestamp option is OPTIONAL.  If it is implemented,
                 the following rules apply:

                 o    The originating host MUST record a timestamp in a
                      Timestamp option whose Internet address fields are
                      not pre-specified or whose first pre-specified
                      address is the host's interface address.
```

---
# **RFC1122                      INTERNET LAYER                 October 1989**

```text
                 o    The destination host MUST (if possible) add the
                      current timestamp to a Timestamp option before
                      passing the option to the transport layer or to
                      ICMP for processing.

                 o    A timestamp value MUST follow the rules given in
                      Section 3.2.2.8 for the ICMP Timestamp message.

      3.2.2 Internet Control Message Protocol -- ICMP
```

- ICMP 메시지는 두 가지 클래스로 그룹화됩니다.

```text
         *
              ICMP error messages:

               Destination Unreachable   (see Section 3.2.2.1)
               Redirect                  (see Section 3.2.2.2)
               Source Quench             (see Section 3.2.2.3)
               Time Exceeded             (see Section 3.2.2.4)
               Parameter Problem         (see Section 3.2.2.5)

         *
              ICMP query messages:

                Echo                     (see Section 3.2.2.6)
                Information              (see Section 3.2.2.7)
                Timestamp                (see Section 3.2.2.8)
                Address Mask             (see Section 3.2.2.9)
```

- 알 수 없는 유형의 ICMP 메시지가 수신되면 자동으로 폐기되어야 합니다.

- 모든 ICMP 오류 메시지에는 인터넷 헤더와 오류를 발생시킨 데이터그램의 최소 처음 8개 데이터 옥텟이 포함됩니다. 8옥텟 이상이 전송될 수 있습니다. 이 헤더와 데이터는 수신된 데이터그램에서 변경되지 않아야 합니다.

- 인터넷 계층이 ICMP 오류 메시지를 전송 계층으로 전달해야 하는 경우 IP 프로토콜 번호는 원래 헤더에서 추출되어야 하며 오류를 처리하기 위한 적절한 전송 프로토콜 엔터티를 선택하는 데 사용되어야 합니다.

- ICMP 오류 메시지는 일반\(즉, 0\) TOS 비트와 함께 전송되어야 합니다.

---
# **RFC1122                      INTERNET LAYER                 October 1989**

- ICMP 오류 메시지는 다음 수신의 결과로 전송되어서는 안 됩니다.

- \* ICMP 오류 메시지 또는

```text
         *    a datagram destined to an IP broadcast or IP multicast
              address, or
```

- \* 링크 계층 브로드캐스트로 전송된 데이터그램, 또는

- \* 초기가 아닌 조각, 또는

```text
         *    a datagram whose source address does not define a single
              host -- e.g., a zero address, a loopback address, a
              broadcast address, a multicast address, or a Class E
              address.
```

- 참고: 이러한 제한 사항은 ICMP 오류 메시지 전송에 대한 이 문서의 다른 요구 사항보다 우선합니다.

```text
         DISCUSSION:
              These rules will prevent the "broadcast storms" that have
              resulted from hosts returning ICMP error messages in
              response to broadcast datagrams.  For example, a broadcast
              UDP segment to a non-existent port could trigger a flood
              of ICMP Destination Unreachable datagrams from all
              machines that do not have a client for that destination
              port.  On a large Ethernet, the resulting collisions can
              render the network useless for a second or more.

              Every datagram that is broadcast on the connected network
              should have a valid IP broadcast address as its IP
              destination (see Section 3.3.6).  However, some hosts
              violate this rule.  To be certain to detect broadcast
              datagrams, therefore, hosts are required to check for a
              link-layer broadcast as well as an IP-layer broadcast
              address.

         IMPLEMENTATION:
              This requires that the link layer inform the IP layer when
              a link-layer broadcast datagram has been received; see
              Section 2.4.

         3.2.2.1  Destination Unreachable: RFC-792
```

- 이에 따라 다음과 같은 추가 코드가 정의됩니다.

```text
                    6 = destination network unknown
```

---
# **RFC1122                      INTERNET LAYER                 October 1989**

```text
                    7 = destination host unknown

                    8 = source host isolated

                    9 = communication with destination network
                            administratively prohibited

                   10 = communication with destination host
                            administratively prohibited
```

- 11 = 서비스 유형에 대해 네트워크에 연결할 수 없음

- 12 = 서비스 유형에 대해 호스트에 연결할 수 없음

```text
            A host SHOULD generate Destination Unreachable messages with
            code:

            2    (Protocol Unreachable), when the designated transport
                 protocol is not supported; or

            3    (Port Unreachable), when the designated transport
                 protocol (e.g., UDP) is unable to demultiplex the
                 datagram but has no protocol mechanism to inform the
                 sender.

            A Destination Unreachable message that is received MUST be
            reported to the transport layer.  The transport layer SHOULD
            use the information appropriately; for example, see Sections
            4.1.3.3, 4.2.3.9, and 4.2.4 below.  A transport protocol
            that has its own mechanism for notifying the sender that a
            port is unreachable (e.g., TCP, which sends RST segments)
            MUST nevertheless accept an ICMP Port Unreachable for the
            same purpose.

            A Destination Unreachable message that is received with code
            0 (Net), 1 (Host), or 5 (Bad Source Route) may result from a
            routing transient and MUST therefore be interpreted as only
            a hint, not proof, that the specified destination is
            unreachable [IP:11].  For example, it MUST NOT be used as
            proof of a dead gateway (see Section 3.3.1).

         3.2.2.2  Redirect: RFC-792

            A host SHOULD NOT send an ICMP Redirect message; Redirects
            are to be sent only by gateways.

            A host receiving a Redirect message MUST update its routing
            information accordingly.  Every host MUST be prepared to
```

---
# **RFC1122                      INTERNET LAYER                 October 1989**

```text
            accept both Host and Network Redirects and to process them
            as described in Section 3.3.1.2 below.

            A Redirect message SHOULD be silently discarded if the new
            gateway address it specifies is not on the same connected
            (sub-) net through which the Redirect arrived [INTRO:2,
            Appendix A], or if the source of the Redirect is not the
            current first-hop gateway for the specified destination (see
            Section 3.3.1).

         3.2.2.3  Source Quench: RFC-792

            A host MAY send a Source Quench message if it is
            approaching, or has reached, the point at which it is forced
            to discard incoming datagrams due to a shortage of
            reassembly buffers or other resources.  See Section 2.2.3 of
            [INTRO:2] for suggestions on when to send Source Quench.

            If a Source Quench message is received, the IP layer MUST
            report it to the transport layer (or ICMP processing). In
            general, the transport or application layer SHOULD implement
            a mechanism to respond to Source Quench for any protocol
            that can send a sequence of datagrams to the same
            destination and which can reasonably be expected to maintain
            enough state information to make this feasible.  See Section
            4 for the handling of Source Quench by TCP and UDP.

            DISCUSSION:
                 A Source Quench may be generated by the target host or
                 by some gateway in the path of a datagram.  The host
                 receiving a Source Quench should throttle itself back
                 for a period of time, then gradually increase the
                 transmission rate again.  The mechanism to respond to
                 Source Quench may be in the transport layer (for
                 connection-oriented protocols like TCP) or in the
                 application layer (for protocols that are built on top
                 of UDP).

                 A mechanism has been proposed [IP:14] to make the IP
                 layer respond directly to Source Quench by controlling
                 the rate at which datagrams are sent, however, this
                 proposal is currently experimental and not currently
                 recommended.

         3.2.2.4  Time Exceeded: RFC-792

            An incoming Time Exceeded message MUST be passed to the
            transport layer.
```

---
# **RFC1122                      INTERNET LAYER                 October 1989**

```text
            DISCUSSION:
                 A gateway will send a Time Exceeded Code 0 (In Transit)
                 message when it discards a datagram due to an expired
                 TTL field.  This indicates either a gateway routing
                 loop or too small an initial TTL value.

                 A host may receive a Time Exceeded Code 1 (Reassembly
                 Timeout) message from a destination host that has timed
                 out and discarded an incomplete datagram; see Section
                 3.3.2 below.  In the future, receipt of this message
                 might be part of some "MTU discovery" procedure, to
                 discover the maximum datagram size that can be sent on
                 the path without fragmentation.

         3.2.2.5  Parameter Problem: RFC-792

            A host SHOULD generate Parameter Problem messages.  An
            incoming Parameter Problem message MUST be passed to the
            transport layer, and it MAY be reported to the user.

            DISCUSSION:
                 The ICMP Parameter Problem message is sent to the
                 source host for any problem not specifically covered by
                 another ICMP message.  Receipt of a Parameter Problem
                 message generally indicates some local or remote
                 implementation error.

            A new variant on the Parameter Problem message is hereby
            defined:
              Code 1 = required option is missing.

            DISCUSSION:
                 This variant is currently in use in the military
                 community for a missing security option.

         3.2.2.6  Echo Request/Reply: RFC-792

            Every host MUST implement an ICMP Echo server function that
            receives Echo Requests and sends corresponding Echo Replies.
            A host SHOULD also implement an application-layer interface
            for sending an Echo Request and receiving an Echo Reply, for
            diagnostic purposes.

            An ICMP Echo Request destined to an IP broadcast or IP
            multicast address MAY be silently discarded.
```

---
# **RFC1122                      INTERNET LAYER                 October 1989**

```text
            DISCUSSION:
                 This neutral provision results from a passionate debate
                 between those who feel that ICMP Echo to a broadcast
                 address provides a valuable diagnostic capability and
                 those who feel that misuse of this feature can too
                 easily create packet storms.

            The IP source address in an ICMP Echo Reply MUST be the same
            as the specific-destination address (defined in Section
            3.2.1.3) of the corresponding ICMP Echo Request message.

            Data received in an ICMP Echo Request MUST be entirely
            included in the resulting Echo Reply.  However, if sending
            the Echo Reply requires intentional fragmentation that is
            not implemented, the datagram MUST be truncated to maximum
            transmission size (see Section 3.3.3) and sent.

            Echo Reply messages MUST be passed to the ICMP user
            interface, unless the corresponding Echo Request originated
            in the IP layer.

            If a Record Route and/or Time Stamp option is received in an
            ICMP Echo Request, this option (these options) SHOULD be
            updated to include the current host and included in the IP
            header of the Echo Reply message, without "truncation".
            Thus, the recorded route will be for the entire round trip.

            If a Source Route option is received in an ICMP Echo
            Request, the return route MUST be reversed and used as a
            Source Route option for the Echo Reply message.

         3.2.2.7  Information Request/Reply: RFC-792
```

- 호스트는 이러한 메시지를 구현해서는 안 됩니다.

```text
            DISCUSSION:
                 The Information Request/Reply pair was intended to
                 support self-configuring systems such as diskless
                 workstations, to allow them to discover their IP
                 network numbers at boot time.  However, the RARP and
                 BOOTP protocols provide better mechanisms for a host to
                 discover its own IP address.
```

- 3.2.2.8 타임스탬프 및 타임스탬프 응답: RFC-792

```text
            A host MAY implement Timestamp and Timestamp Reply.  If they
            are implemented, the following rules MUST be followed.
```

---
# **RFC1122                      INTERNET LAYER                 October 1989**

```text
            o    The ICMP Timestamp server function returns a Timestamp
                 Reply to every Timestamp message that is received.  If
                 this function is implemented, it SHOULD be designed for
                 minimum variability in delay (e.g., implemented in the
                 kernel to avoid delay in scheduling a user process).

            The following cases for Timestamp are to be handled
            according to the corresponding rules for ICMP Echo:

            o    An ICMP Timestamp Request message to an IP broadcast or
                 IP multicast address MAY be silently discarded.

            o    The IP source address in an ICMP Timestamp Reply MUST
                 be the same as the specific-destination address of the
                 corresponding Timestamp Request message.

            o    If a Source-route option is received in an ICMP Echo
                 Request, the return route MUST be reversed and used as
                 a Source Route option for the Timestamp Reply message.

            o    If a Record Route and/or Timestamp option is received
                 in a Timestamp Request, this (these) option(s) SHOULD
                 be updated to include the current host and included in
                 the IP header of the Timestamp Reply message.

            o    Incoming Timestamp Reply messages MUST be passed up to
                 the ICMP user interface.

            The preferred form for a timestamp value (the "standard
            value") is in units of milliseconds since midnight Universal
            Time.  However, it may be difficult to provide this value
            with millisecond resolution.  For example, many systems use
            clocks that update only at line frequency, 50 or 60 times
            per second.  Therefore, some latitude is allowed in a
            "standard value":

            (a)  A "standard value" MUST be updated at least 15 times
                 per second (i.e., at most the six low-order bits of the
                 value may be undefined).

            (b)  The accuracy of a "standard value" MUST approximate
                 that of operator-set CPU clocks, i.e., correct within a
                 few minutes.
```

---
# **RFC1122                      INTERNET LAYER                 October 1989**

```text
         3.2.2.9  Address Mask Request/Reply: RFC-950

            A host MUST support the first, and MAY implement all three,
            of the following methods for determining the address mask(s)
            corresponding to its IP address(es):

            (1)  static configuration information;

            (2)  obtaining the address mask(s) dynamically as a side-
                 effect of the system initialization process (see
                 [INTRO:1]); and

            (3)  sending ICMP Address Mask Request(s) and receiving ICMP
                 Address Mask Reply(s).

            The choice of method to be used in a particular host MUST be
            configurable.

            When method (3), the use of Address Mask messages, is
            enabled, then:

            (a)  When it initializes, the host MUST broadcast an Address
                 Mask Request message on the connected network
                 corresponding to the IP address.  It MUST retransmit
                 this message a small number of times if it does not
                 receive an immediate Address Mask Reply.

            (b)  Until it has received an Address Mask Reply, the host
                 SHOULD assume a mask appropriate for the address class
                 of the IP address, i.e., assume that the connected
                 network is not subnetted.

            (c)  The first Address Mask Reply message received MUST be
                 used to set the address mask corresponding to the
                 particular local IP address.  This is true even if the
                 first Address Mask Reply message is "unsolicited", in
                 which case it will have been broadcast and may arrive
                 after the host has ceased to retransmit Address Mask
                 Requests.  Once the mask has been set by an Address
                 Mask Reply, later Address Mask Reply messages MUST be
                 (silently) ignored.

            Conversely, if Address Mask messages are disabled, then no
            ICMP Address Mask Requests will be sent, and any ICMP
            Address Mask Replies received for that local IP address MUST
            be (silently) ignored.
```

- 호스트는 모든 주소에 대해 합리성을 확인해야 합니다.

---
# **RFC1122                      INTERNET LAYER                 October 1989**

```text
            mask it installs; see IMPLEMENTATION section below.

            A system MUST NOT send an Address Mask Reply unless it is an
            authoritative agent for address masks.  An authoritative
            agent may be a host or a gateway, but it MUST be explicitly
            configured as a address mask agent.  Receiving an address
            mask via an Address Mask Reply does not give the receiver
            authority and MUST NOT be used as the basis for issuing
            Address Mask Replies.

            With a statically configured address mask, there SHOULD be
            an additional configuration flag that determines whether the
            host is to act as an authoritative agent for this mask,
            i.e., whether it will answer Address Mask Request messages
            using this mask.

            If it is configured as an agent, the host MUST broadcast an
            Address Mask Reply for the mask on the appropriate interface
            when it initializes.

            See "System Initialization" in [INTRO:1] for more
            information about the use of Address Mask Request/Reply
            messages.

            DISCUSSION
                 Hosts that casually send Address Mask Replies with
                 invalid address masks have often been a serious
                 nuisance.  To prevent this, Address Mask Replies ought
                 to be sent only by authoritative agents that have been
                 selected by explicit administrative action.

                 When an authoritative agent receives an Address Mask
                 Request message, it will send a unicast Address Mask
                 Reply to the source IP address.  If the network part of
                 this address is zero (see (a) and (b) in 3.2.1.3), the
                 Reply will be broadcast.

                 Getting no reply to its Address Mask Request messages,
                 a host will assume there is no agent and use an
                 unsubnetted mask, but the agent may be only temporarily
                 unreachable.  An agent will broadcast an unsolicited
                 Address Mask Reply whenever it initializes, in order to
                 update the masks of all hosts that have initialized in
                 the meantime.

            IMPLEMENTATION:
                 The following reasonableness check on an address mask
                 is suggested: the mask is not all 1 bits, and it is
```

---
# **RFC1122                      INTERNET LAYER                 October 1989**

- 0이거나 그렇지 않으면 8개의 최상위 비트가 켜져 있습니다.

```text
      3.2.3  Internet Group Management Protocol IGMP
```

- IGMP \[IP:4\]는 특정 멀티캐스트 그룹에서 호스트의 멤버십을 설정하기 위해 단일 네트워크의 호스트와 게이트웨이 간에 사용되는 프로토콜입니다. 게이트웨이는 멀티캐스트 라우팅 프로토콜과 함께 이 정보를 사용하여 인터넷을 통한 IP 멀티캐스팅을 지원합니다.

- 현재 IGMP 구현은 선택 사항입니다. 자세한 내용은 섹션 3.3.7을 참조하세요. IGMP가 없으면 호스트는 연결된 네트워크에 대한 로컬 멀티캐스팅에 계속 참여할 수 있습니다.

```text
   3.3  SPECIFIC ISSUES

      3.3.1  Routing Outbound Datagrams
```

- IP 계층은 전송하는 각 데이터그램에 대해 올바른 다음 홉을 선택합니다. 대상이 연결된 네트워크에 있는 경우 데이터그램은 대상 호스트로 직접 전송됩니다. 그렇지 않으면 연결된 네트워크의 게이트웨이로 라우팅되어야 합니다.

```text
         3.3.1.1  Local/Remote Decision

            To decide if the destination is on a connected network, the
            following algorithm MUST be used [see IP:3]:

            (a)  The address mask (particular to a local IP address for
                 a multihomed host) is a 32-bit mask that selects the
                 network number and subnet number fields of the
                 corresponding IP address.

            (b)  If the IP destination address bits extracted by the
                 address mask match the IP source address bits extracted
                 by the same mask, then the destination is on the
                 corresponding connected network, and the datagram is to
                 be transmitted directly to the destination host.

            (c)  If not, then the destination is accessible only through
                 a gateway.  Selection of a gateway is described below
                 (3.3.1.2).
```

- 특수한 경우의 대상 주소는 다음과 같이 처리됩니다.

```text
            *    For a limited broadcast or a multicast address, simply
                 pass the datagram to the link layer for the appropriate
                 interface.
```

---
# **RFC1122                      INTERNET LAYER                 October 1989**

```text
            *    For a (network or subnet) directed broadcast, the
                 datagram can use the standard routing algorithms.

            The host IP layer MUST operate correctly in a minimal
            network environment, and in particular, when there are no
            gateways.  For example, if the IP layer of a host insists on
            finding at least one gateway to initialize, the host will be
            unable to operate on a single isolated broadcast net.

         3.3.1.2  Gateway Selection

            To efficiently route a series of datagrams to the same
            destination, the source host MUST keep a "route cache" of
            mappings to next-hop gateways.  A host uses the following
            basic algorithm on this cache to route a datagram; this
            algorithm is designed to put the primary routing burden on
            the gateways [IP:11].

            (a)  If the route cache contains no information for a
                 particular destination, the host chooses a "default"
                 gateway and sends the datagram to it.  It also builds a
                 corresponding Route Cache entry.

            (b)  If that gateway is not the best next hop to the
                 destination, the gateway will forward the datagram to
                 the best next-hop gateway and return an ICMP Redirect
                 message to the source host.

            (c)  When it receives a Redirect, the host updates the
                 next-hop gateway in the appropriate route cache entry,
                 so later datagrams to the same destination will go
                 directly to the best gateway.

            Since the subnet mask appropriate to the destination address
            is generally not known, a Network Redirect message SHOULD be
            treated identically to a Host Redirect message; i.e., the
            cache entry for the destination host (only) would be updated
            (or created, if an entry for that host did not exist) for
            the new gateway.

            DISCUSSION:
                 This recommendation is to protect against gateways that
                 erroneously send Network Redirects for a subnetted
                 network, in violation of the gateway requirements
                 [INTRO:2].

            When there is no route cache entry for the destination host
            address (and the destination is not on the connected
```

---
# **RFC1122                      INTERNET LAYER                 October 1989**

```text
            network), the IP layer MUST pick a gateway from its list of
            "default" gateways.  The IP layer MUST support multiple
            default gateways.

            As an extra feature, a host IP layer MAY implement a table
            of "static routes".  Each such static route MAY include a
            flag specifying whether it may be overridden by ICMP
            Redirects.

            DISCUSSION:
                 A host generally needs to know at least one default
                 gateway to get started.  This information can be
                 obtained from a configuration file or else from the
                 host startup sequence, e.g., the BOOTP protocol (see
                 [INTRO:1]).

                 It has been suggested that a host can augment its list
                 of default gateways by recording any new gateways it
                 learns about.  For example, it can record every gateway
                 to which it is ever redirected.  Such a feature, while
                 possibly useful in some circumstances, may cause
                 problems in other cases (e.g., gateways are not all
                 equal), and it is not recommended.

                 A static route is typically a particular preset mapping
                 from destination host or network into a particular
                 next-hop gateway; it might also depend on the Type-of-
                 Service (see next section).  Static routes would be set
                 up by system administrators to override the normal
                 automatic routing mechanism, to handle exceptional
                 situations.  However, any static routing information is
                 a potential source of failure as configurations change
                 or equipment fails.

         3.3.1.3  Route Cache

            Each route cache entry needs to include the following
            fields:
```

- \(1\) 로컬 IP 주소\(멀티홈 호스트의 경우\)

```text
            (2)  Destination IP address

            (3)  Type(s)-of-Service

            (4)  Next-hop gateway IP address
```

- 필드 \(2\)는 대상의 전체 IP 주소일 수 있습니다.

---
# **RFC1122                      INTERNET LAYER                 October 1989**

```text
            host, or only the destination network number.  Field (3),
            the TOS, SHOULD be included.

            See Section 3.3.4.2 for a discussion of the implications of
            multihoming for the lookup procedure in this cache.

            DISCUSSION:
                 Including the Type-of-Service field in the route cache
                 and considering it in the host route algorithm will
                 provide the necessary mechanism for the future when
                 Type-of-Service routing is commonly used in the
                 Internet.  See Section 3.2.1.6.

                 Each route cache entry defines the endpoints of an
                 Internet path.  Although the connecting path may change
                 dynamically in an arbitrary way, the transmission
                 characteristics of the path tend to remain
                 approximately constant over a time period longer than a
                 single typical host-host transport connection.
                 Therefore, a route cache entry is a natural place to
                 cache data on the properties of the path.  Examples of
                 such properties might be the maximum unfragmented
                 datagram size (see Section 3.3.3), or the average
                 round-trip delay measured by a transport protocol.
                 This data will generally be both gathered and used by a
                 higher layer protocol, e.g., by TCP, or by an
                 application using UDP.  Experiments are currently in
                 progress on caching path properties in this manner.

                 There is no consensus on whether the route cache should
                 be keyed on destination host addresses alone, or allow
                 both host and network addresses.  Those who favor the
                 use of only host addresses argue that:

                 (1)  As required in Section 3.3.1.2, Redirect messages
                      will generally result in entries keyed on
                      destination host addresses; the simplest and most
                      general scheme would be to use host addresses
                      always.

                 (2)  The IP layer may not always know the address mask
                      for a network address in a complex subnetted
                      environment.

                 (3)  The use of only host addresses allows the
                      destination address to be used as a pure 32-bit
                      number, which may allow the Internet architecture
                      to be more easily extended in the future without
```

---
# **RFC1122                      INTERNET LAYER                 October 1989**

- 호스트에 대한 모든 변경 사항.

```text
                 The opposing view is that allowing a mixture of
                 destination hosts and networks in the route cache:

                 (1)  Saves memory space.

                 (2)  Leads to a simpler data structure, easily
                      combining the cache with the tables of default and
                      static routes (see below).

                 (3)  Provides a more useful place to cache path
                      properties, as discussed earlier.

            IMPLEMENTATION:
                 The cache needs to be large enough to include entries
                 for the maximum number of destination hosts that may be
                 in use at one time.

                 A route cache entry may also include control
                 information used to choose an entry for replacement.
                 This might take the form of a "recently used" bit, a
                 use count, or a last-used timestamp, for example.  It
                 is recommended that it include the time of last
                 modification of the entry, for diagnostic purposes.

                 An implementation may wish to reduce the overhead of
                 scanning the route cache for every datagram to be
                 transmitted.  This may be accomplished with a hash
                 table to speed the lookup, or by giving a connection-
                 oriented transport protocol a "hint" or temporary
                 handle on the appropriate cache entry, to be passed to
                 the IP layer with each subsequent datagram.

                 Although we have described the route cache, the lists
                 of default gateways, and a table of static routes as
                 conceptually distinct, in practice they may be combined
                 into a single "routing table" data structure.

         3.3.1.4  Dead Gateway Detection

            The IP layer MUST be able to detect the failure of a "next-
            hop" gateway that is listed in its route cache and to choose
            an alternate gateway (see Section 3.3.1.5).

            Dead gateway detection is covered in some detail in RFC-816
            [IP:11]. Experience to date has not produced a complete
```

---
# **RFC1122                      INTERNET LAYER                 October 1989**

```text
            algorithm which is totally satisfactory, though it has
            identified several forbidden paths and promising techniques.

            *    A particular gateway SHOULD NOT be used indefinitely in
                 the absence of positive indications that it is
                 functioning.

            *    Active probes such as "pinging" (i.e., using an ICMP
                 Echo Request/Reply exchange) are expensive and scale
                 poorly.  In particular, hosts MUST NOT actively check
                 the status of a first-hop gateway by simply pinging the
                 gateway continuously.

            *    Even when it is the only effective way to verify a
                 gateway's status, pinging MUST be used only when
                 traffic is being sent to the gateway and when there is
                 no other positive indication to suggest that the
                 gateway is functioning.

            *    To avoid pinging, the layers above and/or below the
                 Internet layer SHOULD be able to give "advice" on the
                 status of route cache entries when either positive
                 (gateway OK) or negative (gateway dead) information is
                 available.

            DISCUSSION:
                 If an implementation does not include an adequate
                 mechanism for detecting a dead gateway and re-routing,
                 a gateway failure may cause datagrams to apparently
                 vanish into a "black hole".  This failure can be
                 extremely confusing for users and difficult for network
                 personnel to debug.

                 The dead-gateway detection mechanism must not cause
                 unacceptable load on the host, on connected networks,
                 or on first-hop gateway(s).  The exact constraints on
                 the timeliness of dead gateway detection and on
                 acceptable load may vary somewhat depending on the
                 nature of the host's mission, but a host generally
                 needs to detect a failed first-hop gateway quickly
                 enough that transport-layer connections will not break
                 before an alternate gateway can be selected.

                 Passing advice from other layers of the protocol stack
                 complicates the interfaces between the layers, but it
                 is the preferred approach to dead gateway detection.
                 Advice can come from almost any part of the IP/TCP
```

---
# **RFC1122                      INTERNET LAYER                 October 1989**

```text
                 architecture, but it is expected to come primarily from
                 the transport and link layers.  Here are some possible
                 sources for gateway advice:

                 o    TCP or any connection-oriented transport protocol
                      should be able to give negative advice, e.g.,
                      triggered by excessive retransmissions.

                 o    TCP may give positive advice when (new) data is
                      acknowledged.  Even though the route may be
                      asymmetric, an ACK for new data proves that the
                      acknowleged data must have been transmitted
                      successfully.

                 o    An ICMP Redirect message from a particular gateway
                      should be used as positive advice about that
                      gateway.

                 o    Link-layer information that reliably detects and
                      reports host failures (e.g., ARPANET Destination
                      Dead messages) should be used as negative advice.

                 o    Failure to ARP or to re-validate ARP mappings may
                      be used as negative advice for the corresponding
                      IP address.

                 o    Packets arriving from a particular link-layer
                      address are evidence that the system at this
                      address is alive.  However, turning this
                      information into advice about gateways requires
                      mapping the link-layer address into an IP address,
                      and then checking that IP address against the
                      gateways pointed to by the route cache.  This is
                      probably prohibitively inefficient.

                 Note that positive advice that is given for every
                 datagram received may cause unacceptable overhead in
                 the implementation.

                 While advice might be passed using required arguments
                 in all interfaces to the IP layer, some transport and
                 application layer protocols cannot deduce the correct
                 advice.  These interfaces must therefore allow a
                 neutral value for advice, since either always-positive
                 or always-negative advice leads to incorrect behavior.

                 There is another technique for dead gateway detection
                 that has been commonly used but is not recommended.
```

---
# **RFC1122                      INTERNET LAYER                 October 1989**

```text
                 This technique depends upon the host passively
                 receiving ("wiretapping") the Interior Gateway Protocol
                 (IGP) datagrams that the gateways are broadcasting to
                 each other.  This approach has the drawback that a host
                 needs to recognize all the interior gateway protocols
                 that gateways may use (see [INTRO:2]).  In addition, it
                 only works on a broadcast network.

                 At present, pinging (i.e., using ICMP Echo messages) is
                 the mechanism for gateway probing when absolutely
                 required.  A successful ping guarantees that the
                 addressed interface and its associated machine are up,
                 but it does not guarantee that the machine is a gateway
                 as opposed to a host.  The normal inference is that if
                 a Redirect or other evidence indicates that a machine
                 was a gateway, successful pings will indicate that the
                 machine is still up and hence still a gateway.
                 However, since a host silently discards packets that a
                 gateway would forward or redirect, this assumption
                 could sometimes fail.  To avoid this problem, a new
                 ICMP message under development will ask "are you a
                 gateway?"

            IMPLEMENTATION:
                 The following specific algorithm has been suggested:

                 o    Associate a "reroute timer" with each gateway
                      pointed to by the route cache.  Initialize the
                      timer to a value Tr, which must be small enough to
                      allow detection of a dead gateway before transport
                      connections time out.

                 o    Positive advice would reset the reroute timer to
                      Tr.  Negative advice would reduce or zero the
                      reroute timer.

                 o    Whenever the IP layer used a particular gateway to
                      route a datagram, it would check the corresponding
                      reroute timer.  If the timer had expired (reached
                      zero), the IP layer would send a ping to the
                      gateway, followed immediately by the datagram.

                 o    The ping (ICMP Echo) would be sent again if
                      necessary, up to N times.  If no ping reply was
                      received in N tries, the gateway would be assumed
                      to have failed, and a new first-hop gateway would
                      be chosen for all cache entries pointing to the
                      failed gateway.
```

---
# **RFC1122                      INTERNET LAYER                 October 1989**

```text
                 Note that the size of Tr is inversely related to the
                 amount of advice available.  Tr should be large enough
                 to insure that:

                 *    Any pinging will be at a low level (e.g., <10%) of
                      all packets sent to a gateway from the host, AND
```

- \* 핑이 자주 발생하지 않습니다\(예: 3분마다\).

```text
                 Since the recommended algorithm is concerned with the
                 gateways pointed to by route cache entries, rather than
                 the cache entries themselves, a two level data
                 structure (perhaps coordinated with ARP or similar
                 caches) may be desirable for implementing a route
                 cache.

         3.3.1.5  New Gateway Selection

            If the failed gateway is not the current default, the IP
            layer can immediately switch to a default gateway.  If it is
            the current default that failed, the IP layer MUST select a
            different default gateway (assuming more than one default is
            known) for the failed route and for establishing new routes.

            DISCUSSION:
                 When a gateway does fail, the other gateways on the
                 connected network will learn of the failure through
                 some inter-gateway routing protocol.  However, this
                 will not happen instantaneously, since gateway routing
                 protocols typically have a settling time of 30-60
                 seconds.  If the host switches to an alternative
                 gateway before the gateways have agreed on the failure,
                 the new target gateway will probably forward the
                 datagram to the failed gateway and send a Redirect back
                 to the host pointing to the failed gateway (!).  The
                 result is likely to be a rapid oscillation in the
                 contents of the host's route cache during the gateway
                 settling period.  It has been proposed that the dead-
                 gateway logic should include some hysteresis mechanism
                 to prevent such oscillations.  However, experience has
                 not shown any harm from such oscillations, since
                 service cannot be restored to the host until the
                 gateways' routing information does settle down.

            IMPLEMENTATION:
                 One implementation technique for choosing a new default
                 gateway is to simply round-robin among the default
                 gateways in the host's list.  Another is to rank the
```

---
# **RFC1122                      INTERNET LAYER                 October 1989**

```text
                 gateways in priority order, and when the current
                 default gateway is not the highest priority one, to
                 "ping" the higher-priority gateways slowly to detect
                 when they return to service.  This pinging can be at a
                 very low rate, e.g., 0.005 per second.

         3.3.1.6  Initialization
```

- 다음 정보는 구성 가능해야 합니다.

```text
            (1)  IP address(es).

            (2)  Address mask(s).
```

- \(3\) 기본 게이트웨이 목록과 기본 설정 수준입니다.

```text
            A manual method of entering this configuration data MUST be
            provided.  In addition, a variety of methods can be used to
            determine this information dynamically; see the section on
            "Host Initialization" in [INTRO:1].

            DISCUSSION:
                 Some host implementations use "wiretapping" of gateway
                 protocols on a broadcast network to learn what gateways
                 exist.  A standard method for default gateway discovery
                 is under development.

      3.3.2  Reassembly
```

- IP 계층은 IP 데이터그램의 재조립을 구현해야 합니다.

- EMTU\_R\("수신할 유효 MTU"\)에 의해 재조립될 수 있는 가장 큰 데이터그램 크기를 지정합니다. 이를 "재조립 버퍼 크기"라고도 합니다. EMTU\_R은 576보다 크거나 같아야 하고, 구성 가능하거나 무한해야 하며, 연결된 네트워크의 MTU보다 크거나 같아야 합니다.

```text
         DISCUSSION:
              A fixed EMTU_R limit should not be built into the code
              because some application layer protocols require EMTU_R
              values larger than 576.

         IMPLEMENTATION:
              An implementation may use a contiguous reassembly buffer
              for each datagram, or it may use a more complex data
              structure that places no definite limit on the reassembled
              datagram size; in the latter case, EMTU_R is said to be
```

---
# **RFC1122                      INTERNET LAYER                 October 1989**

```text
              "indefinite".

              Logically, reassembly is performed by simply copying each
              fragment into the packet buffer at the proper offset.
              Note that fragments may overlap if successive
              retransmissions use different packetizing but the same
              reassembly Id.

              The tricky part of reassembly is the bookkeeping to
              determine when all bytes of the datagram have been
              reassembled.  We recommend Clark's algorithm [IP:10] that
              requires no additional data space for the bookkeeping.
              However, note that, contrary to [IP:10], the first
              fragment header needs to be saved for inclusion in a
              possible ICMP Time Exceeded (Reassembly Timeout) message.
```

- 전송 계층이 IP 데이터그램에서 수신 및 재조립될 수 있는 최대 메시지 크기인 MMS\_R을 학습할 수 있는 메커니즘이 있어야 합니다\(섹션 3.4의 GET\_MAXSIZES 호출 참조\). EMTU\_R이 무한정이 아닌 경우 MMS\_R 값은 다음과 같이 지정됩니다.

```text
            MMS_R = EMTU_R - 20
```

- 20이 IP 헤더의 최소 크기이기 때문입니다.

- 재조립 시간 초과가 있어야 합니다. 리어셈블리 시간 초과 값은 고정된 값이어야 하며 나머지 TTL에서 설정되어서는 안 됩니다. 값은 60초에서 120초 사이에 있는 것이 좋습니다. 이 시간 초과가 만료되면 부분적으로 재조립된 데이터그램을 폐기해야 하며 ICMP 시간 초과 메시지가 소스 호스트로 전송되어야 합니다\(조각 0이 수신된 경우\).

```text
         DISCUSSION:
              The IP specification says that the reassembly timeout
              should be the remaining TTL from the IP header, but this
              does not work well because gateways generally treat TTL as
              a simple hop count rather than an elapsed time.  If the
              reassembly timeout is too small, datagrams will be
              discarded unnecessarily, and communication may fail.  The
              timeout needs to be at least as large as the typical
              maximum delay across the Internet.  A realistic minimum
              reassembly timeout would be 60 seconds.

              It has been suggested that a cache might be kept of
              round-trip times measured by transport protocols for
              various destinations, and that these values might be used
              to dynamically determine a reasonable reassembly timeout
```

---
# **RFC1122                      INTERNET LAYER                 October 1989**

```text
              value.  Further investigation of this approach is
              required.

              If the reassembly timeout is set too high, buffer
              resources in the receiving host will be tied up too long,
              and the MSL (Maximum Segment Lifetime) [TCP:1] will be
              larger than necessary.  The MSL controls the maximum rate
              at which fragmented datagrams can be sent using distinct
              values of the 16-bit Ident field; a larger MSL lowers the
              maximum rate.  The TCP specification [TCP:1] arbitrarily
              assumes a value of 2 minutes for MSL.  This sets an upper
              limit on a reasonable reassembly timeout value.

      3.3.3  Fragmentation
```

- 선택적으로 IP 계층은 의도적으로 나가는 데이터그램을 조각화하는 메커니즘을 구현할 수도 있습니다.

- IP 소스와 대상 주소의 특정 조합 및 TOS에 대해 전송될 수 있는 최대 IP 데이터그램 크기를 EMTU\_S\("전송을 위한 유효 MTU"\)로 지정합니다.

- 호스트는 전송 계층이 주어진 {소스, 대상, TOS} 트리플렛에 대해 전송될 수 있는 최대 전송 계층 메시지 크기인 MMS\_S를 학습할 수 있도록 하는 메커니즘을 구현해야 합니다\(섹션 3.4의 GET\_MAXSIZES 호출 참조\). 로컬 조각화가 수행되지 않으면 MMS\_S 값은 다음과 같습니다.

```text
            MMS_S = EMTU_S - <IP header size>
```

- EMTU\_S는 데이터그램의 소스 주소에 해당하는 네트워크 인터페이스의 MTU보다 작거나 같아야 합니다. 이 방정식에서 <IP 헤더 크기\>는 IP가 전송 계층에서 삽입한 옵션 외에 자체 목적으로 IP 옵션을 삽입할 공간을 확보하지 않는 한 20이 됩니다.

- 로컬 단편화를 구현하지 않는 호스트는 전송 계층\(TCP의 경우\) 또는 애플리케이션 계층\(UDP의 경우\)이 IP 계층에서 MMS\_S를 획득하고 크기가 MMS\_S를 초과하는 데이터그램을 보내지 않도록 해야 합니다.

- 일반적으로 로컬 조각화를 피하고 경로를 따라 모든 게이트웨이에서 조각화를 피할 수 있을 만큼 낮은 EMTU\_S를 선택하는 것이 바람직합니다. 경로에 따른 최소 MTU에 대한 실제 지식이 없는 경우 IP 계층은 대상 주소가 연결된 네트워크에 없을 때마다 EMTU\_S <= 576을 사용해야 하고, 그렇지 않으면 연결된 네트워크의

---
# **RFC1122                      INTERNET LAYER                 October 1989**

```text
         MTU.
```

- 각 물리적 인터페이스의 MTU는 구성 가능해야 합니다.

- 호스트 IP 계층 구현에는 연결된 네트워크의 MTU가 동일한 네트워크 내의 다른 서브넷에 있는 대상에 사용되지만 다른 네트워크에는 사용되지 않음을 나타내는 구성 플래그 "All-Subnets-MTU"가 있을 수 있습니다. 따라서 이 플래그를 사용하면 서브넷 주소 마스크가 아닌 네트워크 클래스 마스크가 EMTU\_S를 선택하는 데 사용됩니다. 멀티홈 호스트의 경우 각 네트워크 인터페이스에 "All-Subnets-MTU" 플래그가 필요합니다.

```text
         DISCUSSION:
              Picking the correct datagram size to use when sending data
              is a complex topic [IP:9].

              (a)  In general, no host is required to accept an IP
                   datagram larger than 576 bytes (including header and
                   data), so a host must not send a larger datagram
                   without explicit knowledge or prior arrangement with
                   the destination host.  Thus, MMS_S is only an upper
                   bound on the datagram size that a transport protocol
                   may send; even when MMS_S exceeds 556, the transport
                   layer must limit its messages to 556 bytes in the
                   absence of other knowledge about the destination
                   host.

              (b)  Some transport protocols (e.g., TCP) provide a way to
                   explicitly inform the sender about the largest
                   datagram the other end can receive and reassemble
                   [IP:7].  There is no corresponding mechanism in the
                   IP layer.

                   A transport protocol that assumes an EMTU_R larger
                   than 576 (see Section 3.3.2), can send a datagram of
                   this larger size to another host that implements the
                   same protocol.

              (c)  Hosts should ideally limit their EMTU_S for a given
                   destination to the minimum MTU of all the networks
                   along the path, to avoid any fragmentation.  IP
                   fragmentation, while formally correct, can create a
                   serious transport protocol performance problem,
                   because loss of a single fragment means all the
                   fragments in the segment must be retransmitted
                   [IP:9].
```

---
# **RFC1122                      INTERNET LAYER                 October 1989**

```text
              Since nearly all networks in the Internet currently
              support an MTU of 576 or greater, we strongly recommend
              the use of 576 for datagrams sent to non-local networks.

              It has been suggested that a host could determine the MTU
              over a given path by sending a zero-offset datagram
              fragment and waiting for the receiver to time out the
              reassembly (which cannot complete!) and return an ICMP
              Time Exceeded message.  This message would include the
              largest remaining fragment header in its body.  More
              direct mechanisms are being experimented with, but have
              not yet been adopted (see e.g., RFC-1063).

      3.3.4  Local Multihoming

         3.3.4.1  Introduction

            A multihomed host has multiple IP addresses, which we may
            think of as "logical interfaces".  These logical interfaces
            may be associated with one or more physical interfaces, and
            these physical interfaces may be connected to the same or
            different networks.
```

- 멀티호밍의 중요한 사례는 다음과 같습니다.

```text
            (a)  Multiple Logical Networks

                 The Internet architects envisioned that each physical
                 network would have a single unique IP network (or
                 subnet) number.  However, LAN administrators have
                 sometimes found it useful to violate this assumption,
                 operating a LAN with multiple logical networks per
                 physical connected network.

                 If a host connected to such a physical network is
                 configured to handle traffic for each of N different
                 logical networks, then the host will have N logical
                 interfaces.  These could share a single physical
                 interface, or might use N physical interfaces to the
                 same network.

            (b)  Multiple Logical Hosts

                 When a host has multiple IP addresses that all have the
                 same <Network-number> part (and the same <Subnet-
                 number> part, if any), the logical interfaces are known
                 as "logical hosts".  These logical interfaces might
                 share a single physical interface or might use separate
```

---
# **RFC1122                      INTERNET LAYER                 October 1989**

- 동일한 물리적 네트워크에 대한 물리적 인터페이스.

```text
            (c)  Simple Multihoming

                 In this case, each logical interface is mapped into a
                 separate physical interface and each physical interface
                 is connected to a different physical network.  The term
                 "multihoming" was originally applied only to this case,
                 but it is now applied more generally.

                 A host with embedded gateway functionality will
                 typically fall into the simple multihoming case.  Note,
                 however, that a host may be simply multihomed without
                 containing an embedded gateway, i.e., without
                 forwarding datagrams from one connected network to
                 another.

                 This case presents the most difficult routing problems.
                 The choice of interface (i.e., the choice of first-hop
                 network) may significantly affect performance or even
                 reachability of remote parts of the Internet.

            Finally, we note another possibility that is NOT
            multihoming:  one logical interface may be bound to multiple
            physical interfaces, in order to increase the reliability or
            throughput between directly connected machines by providing
            alternative physical paths between them.  For instance, two
            systems might be connected by multiple point-to-point links.
            We call this "link-layer multiplexing".  With link-layer
            multiplexing, the protocols above the link layer are unaware
            that multiple physical interfaces are present; the link-
            layer device driver is responsible for multiplexing and
            routing packets across the physical interfaces.

            In the Internet protocol architecture, a transport protocol
            instance ("entity") has no address of its own, but instead
            uses a single Internet Protocol (IP) address.  This has
            implications for the IP, transport, and application layers,
            and for the interfaces between them.  In particular, the
            application software may have to be aware of the multiple IP
            addresses of a multihomed host; in other cases, the choice
            can be made within the network software.

         3.3.4.2  Multihoming Requirements

            The following general rules apply to the selection of an IP
            source address for sending a datagram from a multihomed
```

---
# **RFC1122                      INTERNET LAYER                 October 1989**

```text
            host.

            (1)  If the datagram is sent in response to a received
                 datagram, the source address for the response SHOULD be
                 the specific-destination address of the request.  See
                 Sections 4.1.3.5 and 4.2.3.7 and the "General Issues"
                 section of [INTRO:1] for more specific requirements on
                 higher layers.
```

- 그렇지 않은 경우 소스 주소를 선택해야 합니다.

```text
            (2)  An application MUST be able to explicitly specify the
                 source address for initiating a connection or a
                 request.

            (3)  In the absence of such a specification, the networking
                 software MUST choose a source address.  Rules for this
                 choice are described below.
```

- 멀티호밍과 관련된 두 가지 주요 요구 사항 문제가 있습니다.

```text
            (A)  A host MAY silently discard an incoming datagram whose
                 destination address does not correspond to the physical
                 interface through which it is received.

            (B)  A host MAY restrict itself to sending (non-source-
                 routed) IP datagrams only through the physical
                 interface that corresponds to the IP source address of
                 the datagrams.

            DISCUSSION:
                 Internet host implementors have used two different
                 conceptual models for multihoming, briefly summarized
                 in the following discussion.  This document takes no
                 stand on which model is preferred; each seems to have a
                 place.  This ambivalence is reflected in the issues (A)
                 and (B) being optional.

                 o    Strong ES Model

                      The Strong ES (End System, i.e., host) model
                      emphasizes the host/gateway (ES/IS) distinction,
                      and would therefore substitute MUST for MAY in
                      issues (A) and (B) above.  It tends to model a
                      multihomed host as a set of logical hosts within
                      the same physical host.
```

---
# **RFC1122                      INTERNET LAYER                 October 1989**

```text
                      With respect to (A), proponents of the Strong ES
                      model note that automatic Internet routing
                      mechanisms could not route a datagram to a
                      physical interface that did not correspond to the
                      destination address.

                      Under the Strong ES model, the route computation
                      for an outgoing datagram is the mapping:

                         route(src IP addr, dest IP addr, TOS)
                                                        -> gateway

                      Here the source address is included as a parameter
                      in order to select a gateway that is directly
                      reachable on the corresponding physical interface.
                      Note that this model logically requires that in
                      general there be at least one default gateway, and
                      preferably multiple defaults, for each IP source
                      address.

                 o    Weak ES Model

                      This view de-emphasizes the ES/IS distinction, and
                      would therefore substitute MUST NOT for MAY in
                      issues (A) and (B).  This model may be the more
                      natural one for hosts that wiretap gateway routing
                      protocols, and is necessary for hosts that have
                      embedded gateway functionality.

                      The Weak ES Model may cause the Redirect mechanism
                      to fail.  If a datagram is sent out a physical
                      interface that does not correspond to the
                      destination address, the first-hop gateway will
                      not realize when it needs to send a Redirect.  On
                      the other hand, if the host has embedded gateway
                      functionality, then it has routing information
                      without listening to Redirects.

                      In the Weak ES model, the route computation for an
                      outgoing datagram is the mapping:

                         route(dest IP addr, TOS) -> gateway, interface
```

---
# **RFC1122                      INTERNET LAYER                 October 1989**

- 3.3.4.3 소스 주소 선택

```text
            DISCUSSION:
                 When it sends an initial connection request (e.g., a
                 TCP "SYN" segment) or a datagram service request (e.g.,
                 a UDP-based query), the transport layer on a multihomed
                 host needs to know which source address to use.  If the
                 application does not specify it, the transport layer
                 must ask the IP layer to perform the conceptual
                 mapping:

                     GET_SRCADDR(remote IP addr, TOS)
                                               -> local IP address

                 Here TOS is the Type-of-Service value (see Section
                 3.2.1.6), and the result is the desired source address.
                 The following rules are suggested for implementing this
                 mapping:

                 (a)  If the remote Internet address lies on one of the
                      (sub-) nets to which the host is directly
                      connected, a corresponding source address may be
                      chosen, unless the corresponding interface is
                      known to be down.

                 (b)  The route cache may be consulted, to see if there
                      is an active route to the specified destination
                      network through any network interface; if so, a
                      local IP address corresponding to that interface
                      may be chosen.

                 (c)  The table of static routes, if any (see Section
                      3.3.1.2) may be similarly consulted.

                 (d)  The default gateways may be consulted.  If these
                      gateways are assigned to different interfaces, the
                      interface corresponding to the gateway with the
                      highest preference may be chosen.

                 In the future, there may be a defined way for a
                 multihomed host to ask the gateways on all connected
                 networks for advice about the best network to use for a
                 given destination.

            IMPLEMENTATION:
                 It will be noted that this process is essentially the
                 same as datagram routing (see Section 3.3.1), and
                 therefore hosts may be able to combine the
```

---
# **RFC1122                      INTERNET LAYER                 October 1989**

- 두 가지 기능의 구현.

```text
      3.3.5  Source Route Forwarding
```

- 아래에 주어진 제한에 따라 호스트는 소스 경로의 데이터그램을 다음 지정된 홉으로 전달하여 소스 경로에서 중간 홉 역할을 할 수 있습니다.

- 그러나 이 게이트웨이와 유사한 기능을 수행할 때 호스트는 소스 라우팅된 데이터그램을 전달하는 게이트웨이에 대한 모든 관련 규칙을 준수해야 합니다\[INTRO:2\]. 여기에는 이 문서의 앞부분에 제공된 해당 호스트 조항을 재정의하는 다음과 같은 특정 조항이 포함됩니다.

```text
         (A)  TTL (ref. Section 3.2.1.7)

              The TTL field MUST be decremented and the datagram perhaps
              discarded as specified for a gateway in [INTRO:2].

         (B)  ICMP Destination Unreachable (ref. Section 3.2.2.1)

              A host MUST be able to generate Destination Unreachable
              messages with the following codes:

              4    (Fragmentation Required but DF Set) when a source-
                   routed datagram cannot be fragmented to fit into the
                   target network;

              5    (Source Route Failed) when a source-routed datagram
                   cannot be forwarded, e.g., because of a routing
                   problem or because the next hop of a strict source
                   route is not on a connected network.

         (C)  IP Source Address (ref. Section 3.2.1.3)

              A source-routed datagram being forwarded MAY (and normally
              will) have a source address that is not one of the IP
              addresses of the forwarding host.

         (D)  Record Route Option (ref. Section 3.2.1.8d)

              A host that is forwarding a source-routed datagram
              containing a Record Route option MUST update that option,
              if it has room.

         (E)  Timestamp Option (ref. Section 3.2.1.8e)

              A host that is forwarding a source-routed datagram
```

---
# **RFC1122                      INTERNET LAYER                 October 1989**

```text
              containing a Timestamp Option MUST add the current
              timestamp to that option, according to the rules for this
              option.
```

- 소스 라우팅된 데이터그램의 호스트 전달을 제한하는 규칙을 정의하기 위해 다음 홉이 데이터그램이 도착한 것과 동일한 물리적 인터페이스를 통과하는 경우 "로컬 소스 라우팅"이라는 용어를 사용합니다. 그렇지 않으면 "비로컬 소스 라우팅"입니다.

```text
         o    A host is permitted to perform local source-routing
              without restriction.

         o    A host that supports non-local source-routing MUST have a
              configurable switch to disable forwarding, and this switch
              MUST default to disabled.

         o    The host MUST satisfy all gateway requirements for
              configurable policy filters [INTRO:2] restricting non-
              local forwarding.
```

- 호스트가 불완전한 소스 경로가 있는 데이터그램을 수신했지만 어떤 이유로 이를 전달하지 않는 경우, 호스트는 데이터그램 자체가 ICMP 오류 메시지가 아닌 한 ICMP 목적지 도달 불가능\(코드 5, 소스 경로 실패\) 메시지를 반환해야 합니다.

```text
      3.3.6  Broadcasts
```

- 섹션 3.2.1.3에서는 네 가지 표준 IP 브로드캐스트 주소 형식을 정의했습니다.

```text
           Limited Broadcast:  {-1, -1}

           Directed Broadcast:  {<Network-number>,-1}

           Subnet Directed Broadcast:
                              {<Network-number>,<Subnet-number>,-1}

           All-Subnets Directed Broadcast: {<Network-number>,-1,-1}
```

- 호스트는 들어오는 데이터그램의 대상 주소에서 이러한 형식 중 하나를 인식해야 합니다.

- -1을 0으로 대체하여 비표준 브로드캐스트 주소 형식을 사용하는 호스트\* 클래스가 있습니다. 모든 호스트는 다음을 수행해야 합니다.
\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
\*4.2BSD Unix 및 그 파생 제품\(4.3BSD는 제외\)

---
# **RFC1122                      INTERNET LAYER                 October 1989**

- 이러한 비표준 브로드캐스트 주소를 수신 데이터그램의 대상 주소로 인식하고 수락합니다. 호스트는 각 물리적 인터페이스에 대해 브로드캐스트 주소의 0 또는 -1 형식을 선택하는 구성 옵션을 선택적으로 가질 수 있지만 이 옵션은 기본적으로 표준\(-1\) 형식으로 설정되어야 합니다.

- 호스트가 링크 계층 브로드캐스트 주소로 데이터그램을 보낼 때 IP 대상 주소는 합법적인 IP 브로드캐스트 또는 IP 멀티캐스트 주소여야 합니다.

- 호스트는 링크 계층 브로드캐스트\(섹션 2.4 참조\)를 통해 수신되었지만 IP 멀티캐스트 또는 브로드캐스트 대상 주소를 지정하지 않은 데이터그램을 자동으로 폐기해야 합니다.

- 호스트는 연결된 네트워크에 브로드캐스트하기 위해 제한된 브로드캐스트 주소를 사용해야 합니다.

```text
         DISCUSSION:
              Using the Limited Broadcast address instead of a Directed
              Broadcast address may improve system robustness.  Problems
              are often caused by machines that do not understand the
              plethora of broadcast addresses (see Section 3.2.1.3), or
              that may have different ideas about which broadcast
              addresses are in use.  The prime example of the latter is
              machines that do not understand subnetting but are
              attached to a subnetted net.  Sending a Subnet Broadcast
              for the connected network will confuse those machines,
              which will see it as a message to some other host.

              There has been discussion on whether a datagram addressed
              to the Limited Broadcast address ought to be sent from all
              the interfaces of a multihomed host.  This specification
              takes no stand on the issue.

      3.3.7  IP Multicasting
```

- 호스트는 클래스 D IP 주소에서 링크 계층 주소로의 매핑이 지정된 모든 연결된 네트워크에서 로컬 IP 멀티캐스팅을 지원해야 합니다\(아래 참조\). 로컬 IP 멀티캐스팅 지원에는 멀티캐스트 데이터그램 전송, 멀티캐스트 그룹 가입, 멀티캐스트 데이터그램 수신, 멀티캐스트 그룹 탈퇴가 포함됩니다. 이는 선택 사항인 IGMP 프로토콜 자체를 제외한 모든 \[IP:4\]에 대한 지원을 의미합니다.

---
# **RFC1122                      INTERNET LAYER                 October 1989**

```text
         DISCUSSION:
              IGMP provides gateways that are capable of multicast
              routing with the information required to support IP
              multicasting across multiple networks.  At this time,
              multicast-routing gateways are in the experimental stage
              and are not widely available.  For hosts that are not
              connected to networks with multicast-routing gateways or
              that do not need to receive multicast datagrams
              originating on other networks, IGMP serves no purpose and
              is therefore optional for now.  However, the rest of
              [IP:4] is currently recommended for the purpose of
              providing IP-layer access to local network multicast
              addressing, as a preferable alternative to local broadcast
              addressing.  It is expected that IGMP will become
              recommended at some future date, when multicast-routing
              gateways have become more widely available.
```

- IGMP가 구현되지 않은 경우 호스트는 IP 계층이 초기화될 때 "all-hosts" 그룹\(224.0.0.1\)에 계속 가입해야 하며 IP 계층이 활성화되어 있는 동안 구성원으로 남아 있어야 합니다.

```text
         DISCUSSION:
              Joining the "all-hosts" group will support strictly local
              uses of multicasting, e.g., a gateway discovery protocol,
              even if IGMP is not implemented.
```

- IP 클래스 D 주소를 로컬 주소로 매핑하는 것은 현재 다음 유형의 네트워크에 대해 지정됩니다.

- o \[IP:4\]에 정의된 이더넷/IEEE 802.3.

```text
         o    Any network that supports broadcast but not multicast,
              addressing: all IP Class D addresses map to the local
              broadcast address.

         o    Any type of point-to-point link (e.g., SLIP or HDLC
              links): no mapping required.  All IP multicast datagrams
              are sent as-is, inside the local framing.
```

- 다른 유형의 네트워크에 대한 매핑은 향후 지정될 예정입니다.

- 호스트는 IP 멀티캐스트 주소 지정을 지원하는 호스트의 연결된 네트워크를 결정할 수 있는 상위 계층 프로토콜 또는 애플리케이션을 위한 방법을 제공해야 합니다.

---
# **RFC1122                      INTERNET LAYER                 October 1989**

```text
      3.3.8  Error Reporting
```

- 실행 가능한 경우 호스트는 ICMP 오류 메시지 반환이 특별히 금지된 경우를 제외하고 오류 감지 시 ICMP 오류 데이터그램을 반환해야 합니다.

```text
         DISCUSSION:
              A common phenomenon in datagram networks is the "black
              hole disease": datagrams are sent out, but nothing comes
              back.  Without any error datagrams, it is difficult for
              the user to figure out what the problem is.

   3.4  INTERNET/TRANSPORT LAYER INTERFACE
```

- IP 계층과 전송 계층 사이의 인터페이스는 옵션, 서비스 유형, TTL\(Time-to-Live\)을 포함하여 IP 계층의 모든 메커니즘에 대한 완전한 액세스를 제공해야 합니다. 전송 계층에는 이러한 인터페이스 매개변수를 설정하는 메커니즘이 있거나 애플리케이션에서 매개변수를 전달하는 경로를 제공해야 합니다. 또는 두 가지 모두가 필요합니다.

```text
      DISCUSSION:
           Applications are urged to make use of these mechanisms where
           applicable, even when the mechanisms are not currently
           effective in the Internet (e.g., TOS).  This will allow these
           mechanisms to be immediately useful when they do become
           effective, without a large amount of retrofitting of host
           software.
```

- 이제 전송 계층과 IP 계층 간의 개념적 인터페이스를 일련의 프로시저 호출로 설명합니다. 이는 RFC-791 \[IP:1\]의 섹션 3.3에 있는 정보의 확장입니다.

```text
      *    Send Datagram

                SEND(src, dst, prot, TOS, TTL, BufPTR, len, Id, DF, opt
                     => result )

           where the parameters are defined in RFC-791.  Passing an Id
           parameter is optional; see Section 3.2.1.5.

      *    Receive Datagram

                RECV(BufPTR, prot
                     => result, src, dst, SpecDest, TOS, len, opt)
```

---
# **RFC1122                      INTERNET LAYER                 October 1989**

- 다음을 제외한 모든 매개변수는 RFC-791에 정의되어 있습니다.

```text
                SpecDest = specific-destination address of datagram
                            (defined in Section 3.2.1.3)

           The result parameter dst contains the datagram's destination
           address.  Since this may be a broadcast or multicast address,
           the SpecDest parameter (not shown in RFC-791) MUST be passed.
           The parameter opt contains all the IP options received in the
           datagram; these MUST also be passed to the transport layer.

      *    Select Source Address

                GET_SRCADDR(remote, TOS)  -> local

                remote = remote IP address
                TOS = Type-of-Service
                local = local IP address

           See Section 3.3.4.3.

      *    Find Maximum Datagram Sizes

                GET_MAXSIZES(local, remote, TOS) -> MMS_R, MMS_S

                MMS_R = maximum receive transport-message size.
                MMS_S = maximum send transport-message size.
               (local, remote, TOS defined above)
```

- 섹션 3.3.2 및 3.3.3을 참조하세요.

- \* 배송 성공에 대한 조언

```text
                ADVISE_DELIVPROB(sense, local, remote, TOS)

           Here the parameter sense is a 1-bit flag indicating whether
           positive or negative advice is being given; see the
           discussion in Section 3.3.1.4. The other parameters were
           defined earlier.

      *    Send ICMP Message

                SEND_ICMP(src, dst, TOS, TTL, BufPTR, len, Id, DF, opt)
                     -> result
```

---
# **RFC1122                      INTERNET LAYER                 October 1989**

- \(RFC-791에 정의된 매개변수\)

```text
           Passing an Id parameter is optional; see Section 3.2.1.5.
           The transport layer MUST be able to send certain ICMP
           messages:  Port Unreachable or any of the query-type
           messages.  This function could be considered to be a special
           case of the SEND() call, of course; we describe it separately
           for clarity.

      *    Receive ICMP Message

                RECV_ICMP(BufPTR ) -> result, src, dst, len, opt
```

- \(RFC-791에 정의된 매개변수\)

```text
           The IP layer MUST pass certain ICMP messages up to the
           appropriate transport-layer routine.  This function could be
           considered to be a special case of the RECV() call, of
           course; we describe it separately for clarity.

           For an ICMP error message, the data that is passed up MUST
           include the original Internet header plus all the octets of
           the original message that are included in the ICMP message.
           This data will be used by the transport layer to locate the
           connection state information, if any.

           In particular, the following ICMP messages are to be passed
           up:

           o    Destination Unreachable

           o    Source Quench

           o    Echo Reply (to ICMP user interface, unless the Echo
                Request originated in the IP layer)

           o    Timestamp Reply (to ICMP user interface)

           o    Time Exceeded

      DISCUSSION:
           In the future, there may be additions to this interface to
           pass path data (see Section 3.3.1.3) between the IP and
           transport layers.
```

---
# **RFC1122                      INTERNET LAYER                 October 1989**

```text
   3.5  INTERNET LAYER REQUIREMENTS SUMMARY

                                                 |        | | | |S| |
                                                 |        | | | |H| |F
                                                 |        | | | |O|M|o
                                                 |        | |S| |U|U|o
                                                 |        | |H| |L|S|t
                                                 |        |M|O| |D|T|n
                                                 |        |U|U|M| | |o
                                                 |        |S|L|A|N|N|t
                                                 |        |T|D|Y|O|O|t
FEATURE                                          |SECTION | | | |T|T|e
-------------------------------------------------|--------|-|-|-|-|-|--
                                                 |        | | | | | |
Implement IP and ICMP                            |3.1     |x| | | | |
Handle remote multihoming in application layer   |3.1     |x| | | | |
Support local multihoming                        |3.1     | | |x| | |
Meet gateway specs if forward datagrams          |3.1     |x| | | | |
Configuration switch for embedded gateway        |3.1     |x| | | | |1
   Config switch default to non-gateway          |3.1     |x| | | | |1
   Auto-config based on number of interfaces     |3.1     | | | | |x|1
Able to log discarded datagrams                  |3.1     | |x| | | |
   Record in counter                             |3.1     | |x| | | |
                                                 |        | | | | | |
Silently discard Version != 4                    |3.2.1.1 |x| | | | |
Verify IP checksum, silently discard bad dgram   |3.2.1.2 |x| | | | |
Addressing:                                      |        | | | | | |
  Subnet addressing (RFC-950)                    |3.2.1.3 |x| | | | |
  Src address must be host's own IP address      |3.2.1.3 |x| | | | |
  Silently discard datagram with bad dest addr   |3.2.1.3 |x| | | | |
  Silently discard datagram with bad src addr    |3.2.1.3 |x| | | | |
Support reassembly                               |3.2.1.4 |x| | | | |
Retain same Id field in identical datagram       |3.2.1.5 | | |x| | |
                                                 |        | | | | | |
TOS:                                             |        | | | | | |
  Allow transport layer to set TOS               |3.2.1.6 |x| | | | |
  Pass received TOS up to transport layer        |3.2.1.6 | |x| | | |
  Use RFC-795 link-layer mappings for TOS        |3.2.1.6 | | | |x| |
TTL:                                             |        | | | | | |
  Send packet with TTL of 0                      |3.2.1.7 | | | | |x|
  Discard received packets with TTL < 2          |3.2.1.7 | | | | |x|
  Allow transport layer to set TTL               |3.2.1.7 |x| | | | |
  Fixed TTL is configurable                      |3.2.1.7 |x| | | | |
                                                 |        | | | | | |
IP Options:                                      |        | | | | | |
  Allow transport layer to send IP options       |3.2.1.8 |x| | | | |
  Pass all IP options rcvd to higher layer       |3.2.1.8 |x| | | | |
```

---
# **RFC1122                      INTERNET LAYER                 October 1989**

```text
  IP layer silently ignore unknown options       |3.2.1.8 |x| | | | |
  Security option                                |3.2.1.8a| | |x| | |
  Send Stream Identifier option                  |3.2.1.8b| | | |x| |
  Silently ignore Stream Identifer option        |3.2.1.8b|x| | | | |
  Record Route option                            |3.2.1.8d| | |x| | |
  Timestamp option                               |3.2.1.8e| | |x| | |
Source Route Option:                             |        | | | | | |
  Originate & terminate Source Route options     |3.2.1.8c|x| | | | |
  Datagram with completed SR passed up to TL     |3.2.1.8c|x| | | | |
  Build correct (non-redundant) return route     |3.2.1.8c|x| | | | |
  Send multiple SR options in one header         |3.2.1.8c| | | | |x|
                                                 |        | | | | | |
ICMP:                                            |        | | | | | |
  Silently discard ICMP msg with unknown type    |3.2.2   |x| | | | |
  Include more than 8 octets of orig datagram    |3.2.2   | | |x| | |
      Included octets same as received           |3.2.2   |x| | | | |
  Demux ICMP Error to transport protocol         |3.2.2   |x| | | | |
  Send ICMP error message with TOS=0             |3.2.2   | |x| | | |
  Send ICMP error message for:                   |        | | | | | |
   - ICMP error msg                              |3.2.2   | | | | |x|
   - IP b'cast or IP m'cast                      |3.2.2   | | | | |x|
   - Link-layer b'cast                           |3.2.2   | | | | |x|
   - Non-initial fragment                        |3.2.2   | | | | |x|
   - Datagram with non-unique src address        |3.2.2   | | | | |x|
  Return ICMP error msgs (when not prohibited)   |3.3.8   |x| | | | |
                                                 |        | | | | | |
  Dest Unreachable:                              |        | | | | | |
    Generate Dest Unreachable (code 2/3)         |3.2.2.1 | |x| | | |
    Pass ICMP Dest Unreachable to higher layer   |3.2.2.1 |x| | | | |
    Higher layer act on Dest Unreach             |3.2.2.1 | |x| | | |
      Interpret Dest Unreach as only hint        |3.2.2.1 |x| | | | |
  Redirect:                                      |        | | | | | |
    Host send Redirect                           |3.2.2.2 | | | |x| |
    Update route cache when recv Redirect        |3.2.2.2 |x| | | | |
    Handle both Host and Net Redirects           |3.2.2.2 |x| | | | |
    Discard illegal Redirect                     |3.2.2.2 | |x| | | |
  Source Quench:                                 |        | | | | | |
    Send Source Quench if buffering exceeded     |3.2.2.3 | | |x| | |
    Pass Source Quench to higher layer           |3.2.2.3 |x| | | | |
    Higher layer act on Source Quench            |3.2.2.3 | |x| | | |
  Time Exceeded: pass to higher layer            |3.2.2.4 |x| | | | |
  Parameter Problem:                             |        | | | | | |
    Send Parameter Problem messages              |3.2.2.5 | |x| | | |
    Pass Parameter Problem to higher layer       |3.2.2.5 |x| | | | |
    Report Parameter Problem to user             |3.2.2.5 | | |x| | |
                                                 |        | | | | | |
  ICMP Echo Request or Reply:                    |        | | | | | |
    Echo server and Echo client                  |3.2.2.6 |x| | | | |
```

---
# **RFC1122                      INTERNET LAYER                 October 1989**

```text
    Echo client                                  |3.2.2.6 | |x| | | |
    Discard Echo Request to broadcast address    |3.2.2.6 | | |x| | |
    Discard Echo Request to multicast address    |3.2.2.6 | | |x| | |
    Use specific-dest addr as Echo Reply src     |3.2.2.6 |x| | | | |
    Send same data in Echo Reply                 |3.2.2.6 |x| | | | |
    Pass Echo Reply to higher layer              |3.2.2.6 |x| | | | |
    Reflect Record Route, Time Stamp options     |3.2.2.6 | |x| | | |
    Reverse and reflect Source Route option      |3.2.2.6 |x| | | | |
                                                 |        | | | | | |
  ICMP Information Request or Reply:             |3.2.2.7 | | | |x| |
  ICMP Timestamp and Timestamp Reply:            |3.2.2.8 | | |x| | |
    Minimize delay variability                   |3.2.2.8 | |x| | | |1
    Silently discard b'cast Timestamp            |3.2.2.8 | | |x| | |1
    Silently discard m'cast Timestamp            |3.2.2.8 | | |x| | |1
    Use specific-dest addr as TS Reply src       |3.2.2.8 |x| | | | |1
    Reflect Record Route, Time Stamp options     |3.2.2.6 | |x| | | |1
    Reverse and reflect Source Route option      |3.2.2.8 |x| | | | |1
    Pass Timestamp Reply to higher layer         |3.2.2.8 |x| | | | |1
    Obey rules for "standard value"              |3.2.2.8 |x| | | | |1
                                                 |        | | | | | |
  ICMP Address Mask Request and Reply:           |        | | | | | |
    Addr Mask source configurable                |3.2.2.9 |x| | | | |
    Support static configuration of addr mask    |3.2.2.9 |x| | | | |
    Get addr mask dynamically during booting     |3.2.2.9 | | |x| | |
    Get addr via ICMP Addr Mask Request/Reply    |3.2.2.9 | | |x| | |
      Retransmit Addr Mask Req if no Reply       |3.2.2.9 |x| | | | |3
      Assume default mask if no Reply            |3.2.2.9 | |x| | | |3
      Update address mask from first Reply only  |3.2.2.9 |x| | | | |3
    Reasonableness check on Addr Mask            |3.2.2.9 | |x| | | |
    Send unauthorized Addr Mask Reply msgs       |3.2.2.9 | | | | |x|
      Explicitly configured to be agent          |3.2.2.9 |x| | | | |
    Static config=> Addr-Mask-Authoritative flag |3.2.2.9 | |x| | | |
      Broadcast Addr Mask Reply when init.       |3.2.2.9 |x| | | | |3
                                                 |        | | | | | |
ROUTING OUTBOUND DATAGRAMS:                      |        | | | | | |
  Use address mask in local/remote decision      |3.3.1.1 |x| | | | |
  Operate with no gateways on conn network       |3.3.1.1 |x| | | | |
  Maintain "route cache" of next-hop gateways    |3.3.1.2 |x| | | | |
  Treat Host and Net Redirect the same           |3.3.1.2 | |x| | | |
  If no cache entry, use default gateway         |3.3.1.2 |x| | | | |
    Support multiple default gateways            |3.3.1.2 |x| | | | |
  Provide table of static routes                 |3.3.1.2 | | |x| | |
    Flag: route overridable by Redirects         |3.3.1.2 | | |x| | |
  Key route cache on host, not net address       |3.3.1.3 | | |x| | |
  Include TOS in route cache                     |3.3.1.3 | |x| | | |
                                                 |        | | | | | |
  Able to detect failure of next-hop gateway     |3.3.1.4 |x| | | | |
  Assume route is good forever                   |3.3.1.4 | | | |x| |
```

---
# **RFC1122                      INTERNET LAYER                 October 1989**

```text
  Ping gateways continuously                     |3.3.1.4 | | | | |x|
  Ping only when traffic being sent              |3.3.1.4 |x| | | | |
  Ping only when no positive indication          |3.3.1.4 |x| | | | |
  Higher and lower layers give advice            |3.3.1.4 | |x| | | |
  Switch from failed default g'way to another    |3.3.1.5 |x| | | | |
  Manual method of entering config info          |3.3.1.6 |x| | | | |
                                                 |        | | | | | |
REASSEMBLY and FRAGMENTATION:                    |        | | | | | |
  Able to reassemble incoming datagrams          |3.3.2   |x| | | | |
    At least 576 byte datagrams                  |3.3.2   |x| | | | |
    EMTU_R configurable or indefinite            |3.3.2   | |x| | | |
  Transport layer able to learn MMS_R            |3.3.2   |x| | | | |
  Send ICMP Time Exceeded on reassembly timeout  |3.3.2   |x| | | | |
    Fixed reassembly timeout value               |3.3.2   | |x| | | |
                                                 |        | | | | | |
  Pass MMS_S to higher layers                    |3.3.3   |x| | | | |
  Local fragmentation of outgoing packets        |3.3.3   | | |x| | |
     Else don't send bigger than MMS_S           |3.3.3   |x| | | | |
  Send max 576 to off-net destination            |3.3.3   | |x| | | |
  All-Subnets-MTU configuration flag             |3.3.3   | | |x| | |
                                                 |        | | | | | |
MULTIHOMING:                                     |        | | | | | |
  Reply with same addr as spec-dest addr         |3.3.4.2 | |x| | | |
  Allow application to choose local IP addr      |3.3.4.2 |x| | | | |
  Silently discard d'gram in "wrong" interface   |3.3.4.2 | | |x| | |
  Only send d'gram through "right" interface     |3.3.4.2 | | |x| | |4
                                                 |        | | | | | |
SOURCE-ROUTE FORWARDING:                         |        | | | | | |
  Forward datagram with Source Route option      |3.3.5   | | |x| | |1
    Obey corresponding gateway rules             |3.3.5   |x| | | | |1
      Update TTL by gateway rules                |3.3.5   |x| | | | |1
      Able to generate ICMP err code 4, 5        |3.3.5   |x| | | | |1
      IP src addr not local host                 |3.3.5   | | |x| | |1
      Update Timestamp, Record Route options     |3.3.5   |x| | | | |1
    Configurable switch for non-local SRing      |3.3.5   |x| | | | |1
      Defaults to OFF                            |3.3.5   |x| | | | |1
    Satisfy gwy access rules for non-local SRing |3.3.5   |x| | | | |1
    If not forward, send Dest Unreach (cd 5)     |3.3.5   | |x| | | |2
                                                 |        | | | | | |
BROADCAST:                                       |        | | | | | |
  Broadcast addr as IP source addr               |3.2.1.3 | | | | |x|
  Receive 0 or -1 broadcast formats OK           |3.3.6   | |x| | | |
  Config'ble option to send 0 or -1 b'cast       |3.3.6   | | |x| | |
    Default to -1 broadcast                      |3.3.6   | |x| | | |
  Recognize all broadcast address formats        |3.3.6   |x| | | | |
  Use IP b'cast/m'cast addr in link-layer b'cast |3.3.6   |x| | | | |
  Silently discard link-layer-only b'cast dg's   |3.3.6   | |x| | | |
  Use Limited Broadcast addr for connected net   |3.3.6   | |x| | | |
```

---
# **RFC1122                      INTERNET LAYER                 October 1989**

```text
                                                 |        | | | | | |
MULTICAST:                                       |        | | | | | |
  Support local IP multicasting (RFC-1112)       |3.3.7   | |x| | | |
  Support IGMP (RFC-1112)                        |3.3.7   | | |x| | |
  Join all-hosts group at startup                |3.3.7   | |x| | | |
  Higher layers learn i'face m'cast capability   |3.3.7   | |x| | | |
                                                 |        | | | | | |
INTERFACE:                                       |        | | | | | |
  Allow transport layer to use all IP mechanisms |3.4     |x| | | | |
  Pass interface ident up to transport layer     |3.4     |x| | | | |
  Pass all IP options up to transport layer      |3.4     |x| | | | |
  Transport layer can send certain ICMP messages |3.4     |x| | | | |
  Pass spec'd ICMP messages up to transp. layer  |3.4     |x| | | | |
     Include IP hdr+8 octets or more from orig.  |3.4     |x| | | | |
  Able to leap tall buildings at a single bound  |3.5     | |x| | | |
```

---
# **Footnotes:**

\(1\) 기능이 구현된 경우에만 해당됩니다.

\(2\) 데이터그램이 ICMP 오류 메시지인 경우 이 요구 사항은 무효화됩니다.

\(3\) 기능이 구현되고 "켜짐"으로 구성된 경우에만 해당됩니다.

\(4\) 게이트웨이 기능이 내장되어 있거나 소스가 라우팅되지 않은 경우.

---
# **RFC1122                  TRANSPORT LAYER -- UDP             October 1989**
---
## **4. TRANSPORT PROTOCOLS**

```text
   4.1  USER DATAGRAM PROTOCOL -- UDP

      4.1.1  INTRODUCTION
```

- 사용자 데이터그램 프로토콜 UDP\[UDP:1\]는 최소한의 전송 서비스\(보증되지 않는 데이터그램 전달\)만 제공하며 응용 프로그램이 IP 계층의 데이터그램 서비스에 직접 액세스할 수 있도록 합니다. UDP는 TCP 서비스 수준이 필요하지 않거나 TCP에서 사용할 수 없는 통신 서비스\(예: 멀티캐스트 또는 브로드캐스트 전달\)를 사용하려는 응용 프로그램에서 사용됩니다.

- UDP는 거의 널\(null\) 프로토콜입니다. IP를 통해 제공되는 유일한 서비스는 데이터 체크섬과 포트 번호별 다중화입니다. 따라서 UDP를 통해 실행되는 응용 프로그램은 연결 지향 프로토콜이 처리했을 엔드투엔드 통신 문제\(예: 안정적인 전달을 위한 재전송, 패킷화 및 재조립, 흐름 제어, 혼잡 회피 등\)를 직접 처리해야 합니다. 이것이 필요할 때. IP와 TCP 간의 상당히 복잡한 결합은 UDP와 UDP를 사용하는 많은 애플리케이션 간의 결합에 반영됩니다.

```text
      4.1.2  PROTOCOL WALK-THROUGH
```

- UDP 사양에는 알려진 오류가 없습니다.

```text
      4.1.3  SPECIFIC ISSUES

         4.1.3.1  Ports

            UDP well-known ports follow the same rules as TCP well-known
            ports; see Section 4.2.2.1 below.

            If a datagram arrives addressed to a UDP port for which
            there is no pending LISTEN call, UDP SHOULD send an ICMP
            Port Unreachable message.

         4.1.3.2  IP Options

            UDP MUST pass any IP option that it receives from the IP
            layer transparently to the application layer.

            An application MUST be able to specify IP options to be sent
            in its UDP datagrams, and UDP MUST pass these options to the
            IP layer.
```

---
# **RFC1122                  TRANSPORT LAYER -- UDP             October 1989**

```text
            DISCUSSION:
                 At present, the only options that need be passed
                 through UDP are Source Route, Record Route, and Time
                 Stamp.  However, new options may be defined in the
                 future, and UDP need not and should not make any
                 assumptions about the format or content of options it
                 passes to or from the application; an exception to this
                 might be an IP-layer security option.

                 An application based on UDP will need to obtain a
                 source route from a request datagram and supply a
                 reversed route for sending the corresponding reply.

         4.1.3.3  ICMP Messages

            UDP MUST pass to the application layer all ICMP error
            messages that it receives from the IP layer.  Conceptually
            at least, this may be accomplished with an upcall to the
            ERROR_REPORT routine (see Section 4.2.4.1).

            DISCUSSION:
                 Note that ICMP error messages resulting from sending a
                 UDP datagram are received asynchronously.  A UDP-based
                 application that wants to receive ICMP error messages
                 is responsible for maintaining the state necessary to
                 demultiplex these messages when they arrive; for
                 example, the application may keep a pending receive
                 operation for this purpose.  The application is also
                 responsible to avoid confusion from a delayed ICMP
                 error message resulting from an earlier use of the same
                 port(s).

         4.1.3.4  UDP Checksums

            A host MUST implement the facility to generate and validate
            UDP checksums.  An application MAY optionally be able to
            control whether a UDP checksum will be generated, but it
            MUST default to checksumming on.

            If a UDP datagram is received with a checksum that is non-
            zero and invalid, UDP MUST silently discard the datagram.
            An application MAY optionally be able to control whether UDP
            datagrams without checksums should be discarded or passed to
            the application.

            DISCUSSION:
                 Some applications that normally run only across local
                 area networks have chosen to turn off UDP checksums for
```

---
# **RFC1122                  TRANSPORT LAYER -- UDP             October 1989**

```text
                 efficiency.  As a result, numerous cases of undetected
                 errors have been reported.  The advisability of ever
                 turning off UDP checksumming is very controversial.

            IMPLEMENTATION:
                 There is a common implementation error in UDP
                 checksums.  Unlike the TCP checksum, the UDP checksum
                 is optional; the value zero is transmitted in the
                 checksum field of a UDP header to indicate the absence
                 of a checksum.  If the transmitter really calculates a
                 UDP checksum of zero, it must transmit the checksum as
                 all 1's (65535).  No special action is required at the
                 receiver, since zero and 65535 are equivalent in 1's
                 complement arithmetic.

         4.1.3.5  UDP Multihoming

            When a UDP datagram is received, its specific-destination
            address MUST be passed up to the application layer.

            An application program MUST be able to specify the IP source
            address to be used for sending a UDP datagram or to leave it
            unspecified (in which case the networking software will
            choose an appropriate source address).  There SHOULD be a
            way to communicate the chosen source address up to the
            application layer (e.g, so that the application can later
            receive a reply datagram only from the corresponding
            interface).

            DISCUSSION:
                 A request/response application that uses UDP should use
                 a source address for the response that is the same as
                 the specific destination address of the request.  See
                 the "General Issues" section of [INTRO:1].

         4.1.3.6  Invalid Addresses

            A UDP datagram received with an invalid IP source address
            (e.g., a broadcast or multicast address) must be discarded
            by UDP or by the IP layer (see Section 3.2.1.3).

            When a host sends a UDP datagram, the source address MUST be
            (one of) the IP address(es) of the host.

      4.1.4  UDP/APPLICATION LAYER INTERFACE
```

- UDP에 대한 애플리케이션 인터페이스는 본 섹션 3.4에 설명된 IP/전송 인터페이스의 전체 서비스를 제공해야 합니다.

---
# **RFC1122                  TRANSPORT LAYER -- UDP             October 1989**

- 문서. 따라서 UDP를 사용하는 애플리케이션에는 섹션 3.4에 설명된 GET\_SRCADDR\(\), GET\_MAXSIZES\(\), ADVISE\_DELIVPROB\(\) 및 RECV\_ICMP\(\) 호출 기능이 필요합니다. 예를 들어, GET\_MAXSIZES\(\)를 사용하면 특정 {인터페이스, 원격 호스트, TOS} 삼중항에 대한 효과적인 최대 UDP 최대 데이터그램 크기를 알아볼 수 있습니다.

- 애플리케이션 계층 프로그램은 UDP 데이터그램 전송을 위한 IP 옵션뿐만 아니라 TTL 및 TOS 값을 설정할 수 있어야 하며 이러한 값은 IP 계층에 투명하게 전달되어야 합니다. UDP는 수신된 TOS를 애플리케이션 계층까지 전달할 수 있습니다.

```text
      4.1.5  UDP REQUIREMENTS SUMMARY

                                                 |        | | | |S| |
                                                 |        | | | |H| |F
                                                 |        | | | |O|M|o
                                                 |        | |S| |U|U|o
                                                 |        | |H| |L|S|t
                                                 |        |M|O| |D|T|n
                                                 |        |U|U|M| | |o
                                                 |        |S|L|A|N|N|t
                                                 |        |T|D|Y|O|O|t
FEATURE                                          |SECTION | | | |T|T|e
-------------------------------------------------|--------|-|-|-|-|-|--
                                                 |        | | | | | |
    UDP                                          |        | | | | | |
-------------------------------------------------|--------|-|-|-|-|-|--
                                                 |        | | | | | |
UDP send Port Unreachable                        |4.1.3.1 | |x| | | |
                                                 |        | | | | | |
IP Options in UDP                                |        | | | | | |
 - Pass rcv'd IP options to applic layer         |4.1.3.2 |x| | | | |
 - Applic layer can specify IP options in Send   |4.1.3.2 |x| | | | |
 - UDP passes IP options down to IP layer        |4.1.3.2 |x| | | | |
                                                 |        | | | | | |
Pass ICMP msgs up to applic layer                |4.1.3.3 |x| | | | |
                                                 |        | | | | | |
UDP checksums:                                   |        | | | | | |
 - Able to generate/check checksum               |4.1.3.4 |x| | | | |
 - Silently discard bad checksum                 |4.1.3.4 |x| | | | |
 - Sender Option to not generate checksum        |4.1.3.4 | | |x| | |
   - Default is to checksum                      |4.1.3.4 |x| | | | |
 - Receiver Option to require checksum           |4.1.3.4 | | |x| | |
                                                 |        | | | | | |
UDP Multihoming                                  |        | | | | | |
 - Pass spec-dest addr to application            |4.1.3.5 |x| | | | |
```

---
# **RFC1122                  TRANSPORT LAYER -- UDP             October 1989**

```text
 - Applic layer can specify Local IP addr        |4.1.3.5 |x| | | | |
 - Applic layer specify wild Local IP addr       |4.1.3.5 |x| | | | |
 - Applic layer notified of Local IP addr used   |4.1.3.5 | |x| | | |
                                                 |        | | | | | |
Bad IP src addr silently discarded by UDP/IP     |4.1.3.6 |x| | | | |
Only send valid IP source address                |4.1.3.6 |x| | | | |
UDP Application Interface Services               |        | | | | | |
Full IP interface of 3.4 for application         |4.1.4   |x| | | | |
 - Able to spec TTL, TOS, IP opts when send dg   |4.1.4   |x| | | | |
 - Pass received TOS up to applic layer          |4.1.4   | | |x| | |
```

---
# **RFC1122                  TRANSPORT LAYER -- TCP             October 1989**

```text
   4.2  TRANSMISSION CONTROL PROTOCOL -- TCP

      4.2.1  INTRODUCTION
```

- 전송 제어 프로토콜 TCP\[TCP:1\]는 인터넷 제품군의 기본 가상 회로 전송 프로토콜입니다. TCP는 옥텟\(8비트 바이트\)의 전이중 스트림을 안정적이고 순차적으로 전달합니다. TCP는 메일\(SMTP\), 파일 전송\(FTP\) 및 가상 터미널 서비스\(Telnet\)와 같이 안정적인 연결 지향 전송 서비스가 필요한 애플리케이션에서 사용됩니다. 이러한 애플리케이션 계층 프로토콜에 대한 요구 사항은 \[소개:1\]에 설명되어 있습니다.

```text
      4.2.2  PROTOCOL WALK-THROUGH

         4.2.2.1  Well-Known Ports: RFC-793 Section 2.7

            DISCUSSION:
                 TCP reserves port numbers in the range 0-255 for
                 "well-known" ports, used to access services that are
                 standardized across the Internet.  The remainder of the
                 port space can be freely allocated to application
                 processes.  Current well-known port definitions are
                 listed in the RFC entitled "Assigned Numbers"
                 [INTRO:6].  A prerequisite for defining a new well-
                 known port is an RFC documenting the proposed service
                 in enough detail to allow new implementations.

                 Some systems extend this notion by adding a third
                 subdivision of the TCP port space: reserved ports,
                 which are generally used for operating-system-specific
                 services.  For example, reserved ports might fall
                 between 256 and some system-dependent upper limit.
                 Some systems further choose to protect well-known and
                 reserved ports by permitting only privileged users to
                 open TCP connections with those port values.  This is
                 perfectly reasonable as long as the host does not
                 assume that all hosts protect their low-numbered ports
                 in this manner.
```

- 4.2.2.2 푸시 사용: RFC-793 섹션 2.8

```text
            When an application issues a series of SEND calls without
            setting the PUSH flag, the TCP MAY aggregate the data
            internally without sending it.  Similarly, when a series of
            segments is received without the PSH bit, a TCP MAY queue
            the data internally without passing it to the receiving
            application.
```

---
# **RFC1122                  TRANSPORT LAYER -- TCP             October 1989**

```text
            The PSH bit is not a record marker and is independent of
            segment boundaries.  The transmitter SHOULD collapse
            successive PSH bits when it packetizes data, to send the
            largest possible segment.

            A TCP MAY implement PUSH flags on SEND calls.  If PUSH flags
            are not implemented, then the sending TCP: (1) must not
            buffer data indefinitely, and (2) MUST set the PSH bit in
            the last buffered segment (i.e., when there is no more
            queued data to be sent).

            The discussion in RFC-793 on pages 48, 50, and 74
            erroneously implies that a received PSH flag must be passed
            to the application layer.  Passing a received PSH flag to
            the application layer is now OPTIONAL.

            An application program is logically required to set the PUSH
            flag in a SEND call whenever it needs to force delivery of
            the data to avoid a communication deadlock.  However, a TCP
            SHOULD send a maximum-sized segment whenever possible, to
            improve performance (see Section 4.2.3.4).

            DISCUSSION:
                 When the PUSH flag is not implemented on SEND calls,
                 i.e., when the application/TCP interface uses a pure
                 streaming model, responsibility for aggregating any
                 tiny data fragments to form reasonable sized segments
                 is partially borne by the application layer.

                 Generally, an interactive application protocol must set
                 the PUSH flag at least in the last SEND call in each
                 command or response sequence.  A bulk transfer protocol
                 like FTP should set the PUSH flag on the last segment
                 of a file or when necessary to prevent buffer deadlock.

                 At the receiver, the PSH bit forces buffered data to be
                 delivered to the application (even if less than a full
                 buffer has been received). Conversely, the lack of a
                 PSH bit can be used to avoid unnecessary wakeup calls
                 to the application process; this can be an important
                 performance optimization for large timesharing hosts.
                 Passing the PSH bit to the receiving application allows
                 an analogous optimization within the application.

         4.2.2.3  Window Size: RFC-793 Section 3.1

            The window size MUST be treated as an unsigned number, or
            else large window sizes will appear like negative windows
```

---
# **RFC1122                  TRANSPORT LAYER -- TCP             October 1989**

```text
            and TCP will not work.  It is RECOMMENDED that
            implementations reserve 32-bit fields for the send and
            receive window sizes in the connection record and do all
            window computations with 32 bits.

            DISCUSSION:
                 It is known that the window field in the TCP header is
                 too small for high-speed, long-delay paths.
                 Experimental TCP options have been defined to extend
                 the window size; see for example [TCP:11].  In
                 anticipation of the adoption of such an extension, TCP
                 implementors should treat windows as 32 bits.

         4.2.2.4  Urgent Pointer: RFC-793 Section 3.1

            The second sentence is in error: the urgent pointer points
            to the sequence number of the LAST octet (not LAST+1) in a
            sequence of urgent data.  The description on page 56 (last
            sentence) is correct.
```

- TCP는 모든 길이의 긴급 데이터 시퀀스를 지원해야 합니다.

```text
            A TCP MUST inform the application layer asynchronously
            whenever it receives an Urgent pointer and there was
            previously no pending urgent data, or whenever the Urgent
            pointer advances in the data stream.  There MUST be a way
            for the application to learn how much urgent data remains to
            be read from the connection, or at least to determine
            whether or not more urgent data remains to be read.

            DISCUSSION:
                 Although the Urgent mechanism may be used for any
                 application, it is normally used to send "interrupt"-
                 type commands to a Telnet program (see "Using Telnet
                 Synch Sequence" section in [INTRO:1]).

                 The asynchronous or "out-of-band" notification will
                 allow the application to go into "urgent mode", reading
                 data from the TCP connection.  This allows control
                 commands to be sent to an application whose normal
                 input buffers are full of unprocessed data.

            IMPLEMENTATION:
                 The generic ERROR-REPORT() upcall described in Section
                 4.2.4.1 is a possible mechanism for informing the
                 application of the arrival of urgent data.
```

---
# **RFC1122                  TRANSPORT LAYER -- TCP             October 1989**

```text
         4.2.2.5  TCP Options: RFC-793 Section 3.1

            A TCP MUST be able to receive a TCP option in any segment.
            A TCP MUST ignore without error any TCP option it does not
            implement, assuming that the option has a length field (all
            TCP options defined in the future will have length fields).
            TCP MUST be prepared to handle an illegal option length
            (e.g., zero) without crashing; a suggested procedure is to
            reset the connection and log the reason.

         4.2.2.6  Maximum Segment Size Option: RFC-793 Section 3.1

            TCP MUST implement both sending and receiving the Maximum
            Segment Size option [TCP:4].

            TCP SHOULD send an MSS (Maximum Segment Size) option in
            every SYN segment when its receive MSS differs from the
            default 536, and MAY send it always.

            If an MSS option is not received at connection setup, TCP
            MUST assume a default send MSS of 536 (576-40) [TCP:4].

            The maximum size of a segment that TCP really sends, the
            "effective send MSS," MUST be the smaller of the send MSS
            (which reflects the available reassembly buffer size at the
            remote host) and the largest size permitted by the IP layer:

               Eff.snd.MSS =

                  min(SendMSS+20, MMS_S) - TCPhdrsize - IPoptionsize

            where:

            *    SendMSS is the MSS value received from the remote host,
                 or the default 536 if no MSS option is received.

            *    MMS_S is the maximum size for a transport-layer message
                 that TCP may send.

            *    TCPhdrsize is the size of the TCP header; this is
                 normally 20, but may be larger if TCP options are to be
                 sent.

            *    IPoptionsize is the size of any IP options that TCP
                 will pass to the IP layer with the current message.
```

- MSS 옵션으로 전송할 MSS 값은 다음 값보다 작아야 합니다.

---
# **RFC1122                  TRANSPORT LAYER -- TCP             October 1989**

- 또는 다음과 같음:

```text
               MMS_R - 20

            where MMS_R is the maximum size for a transport-layer
            message that can be received (and reassembled).  TCP obtains
            MMS_R and MMS_S from the IP layer; see the generic call
            GET_MAXSIZES in Section 3.4.

            DISCUSSION:
                 The choice of TCP segment size has a strong effect on
                 performance.  Larger segments increase throughput by
                 amortizing header size and per-datagram processing
                 overhead over more data bytes; however, if the packet
                 is so large that it causes IP fragmentation, efficiency
                 drops sharply if any fragments are lost [IP:9].

                 Some TCP implementations send an MSS option only if the
                 destination host is on a non-connected network.
                 However, in general the TCP layer may not have the
                 appropriate information to make this decision, so it is
                 preferable to leave to the IP layer the task of
                 determining a suitable MTU for the Internet path.  We
                 therefore recommend that TCP always send the option (if
                 not 536) and that the IP layer determine MMS_R as
                 specified in 3.3.3 and 3.4.  A proposed IP-layer
                 mechanism to measure the MTU would then modify the IP
                 layer without changing TCP.

         4.2.2.7  TCP Checksum: RFC-793 Section 3.1

            Unlike the UDP checksum (see Section 4.1.3.4), the TCP
            checksum is never optional.  The sender MUST generate it and
            the receiver MUST check it.

         4.2.2.8  TCP Connection State Diagram: RFC-793 Section 3.2,
            page 23
```

- 이 다이어그램에는 몇 가지 문제가 있습니다.

```text
            (a)  The arrow from SYN-SENT to SYN-RCVD should be labeled
                 with "snd SYN,ACK", to agree with the text on page 68
                 and with Figure 8.

            (b)  There could be an arrow from SYN-RCVD state to LISTEN
                 state, conditioned on receiving a RST after a passive
                 open (see text page 70).
```

---
# **RFC1122                  TRANSPORT LAYER -- TCP             October 1989**

```text
            (c)  It is possible to go directly from FIN-WAIT-1 to the
                 TIME-WAIT state (see page 75 of the spec).

         4.2.2.9  Initial Sequence Number Selection: RFC-793 Section
            3.3, page 27

            A TCP MUST use the specified clock-driven selection of
            initial sequence numbers.

         4.2.2.10  Simultaneous Open Attempts: RFC-793 Section 3.4, page
            32

            There is an error in Figure 8: the packet on line 7 should
            be identical to the packet on line 5.
```

- TCP는 동시 열기 시도를 지원해야 합니다.

```text
            DISCUSSION:
                 It sometimes surprises implementors that if two
                 applications attempt to simultaneously connect to each
                 other, only one connection is generated instead of two.
                 This was an intentional design decision; don't try to
                 "fix" it.

         4.2.2.11  Recovery from Old Duplicate SYN: RFC-793 Section 3.4,
            page 33

            Note that a TCP implementation MUST keep track of whether a
            connection has reached SYN_RCVD state as the result of a
            passive OPEN or an active OPEN.

         4.2.2.12  RST Segment: RFC-793 Section 3.4
```

- TCP는 수신된 RST 세그먼트가 데이터를 포함하도록 허용해야 합니다.

```text
            DISCUSSION
                 It has been suggested that a RST segment could contain
                 ASCII text that encoded and explained the cause of the
                 RST.  No standard has yet been established for such
                 data.
```

- 4.2.2.13 연결 닫기: RFC-793 섹션 3.5

```text
            A TCP connection may terminate in two ways: (1) the normal
            TCP close sequence using a FIN handshake, and (2) an "abort"
            in which one or more RST segments are sent and the
            connection state is immediately discarded.  If a TCP
```

---
# **RFC1122                  TRANSPORT LAYER -- TCP             October 1989**

```text
            connection is closed by the remote site, the local
            application MUST be informed whether it closed normally or
            was aborted.

            The normal TCP close sequence delivers buffered data
            reliably in both directions.  Since the two directions of a
            TCP connection are closed independently, it is possible for
            a connection to be "half closed," i.e., closed in only one
            direction, and a host is permitted to continue sending data
            in the open direction on a half-closed connection.

            A host MAY implement a "half-duplex" TCP close sequence, so
            that an application that has called CLOSE cannot continue to
            read data from the connection.  If such a host issues a
            CLOSE call while received data is still pending in TCP, or
            if new data is received after CLOSE is called, its TCP
            SHOULD send a RST to show that data was lost.

            When a connection is closed actively, it MUST linger in
            TIME-WAIT state for a time 2xMSL (Maximum Segment Lifetime).
            However, it MAY accept a new SYN from the remote TCP to
            reopen the connection directly from TIME-WAIT state, if it:

            (1)  assigns its initial sequence number for the new
                 connection to be larger than the largest sequence
                 number it used on the previous connection incarnation,
                 and

            (2)  returns to TIME-WAIT state if the SYN turns out to be
                 an old duplicate.

            DISCUSSION:
                 TCP's full-duplex data-preserving close is a feature
                 that is not included in the analogous ISO transport
                 protocol TP4.

                 Some systems have not implemented half-closed
                 connections, presumably because they do not fit into
                 the I/O model of their particular operating system.  On
                 these systems, once an application has called CLOSE, it
                 can no longer read input data from the connection; this
                 is referred to as a "half-duplex" TCP close sequence.

                 The graceful close algorithm of TCP requires that the
                 connection state remain defined on (at least)  one end
                 of the connection, for a timeout period of 2xMSL, i.e.,
                 4 minutes.  During this period, the (remote socket,
```

---
# **RFC1122                  TRANSPORT LAYER -- TCP             October 1989**

```text
                 local socket) pair that defines the connection is busy
                 and cannot be reused.  To shorten the time that a given
                 port pair is tied up, some TCPs allow a new SYN to be
                 accepted in TIME-WAIT state.

         4.2.2.14  Data Communication: RFC-793 Section 3.7, page 40

            Since RFC-793 was written, there has been extensive work on
            TCP algorithms to achieve efficient data communication.
            Later sections of the present document describe required and
            recommended TCP algorithms to determine when to send data
            (Section 4.2.3.4), when to send an acknowledgment (Section
            4.2.3.2), and when to update the window (Section 4.2.3.3).

            DISCUSSION:
                 One important performance issue is "Silly Window
                 Syndrome" or "SWS" [TCP:5], a stable pattern of small
                 incremental window movements resulting in extremely
                 poor TCP performance.  Algorithms to avoid SWS are
                 described below for both the sending side (Section
                 4.2.3.4) and the receiving side (Section 4.2.3.3).

                 In brief, SWS is caused by the receiver advancing the
                 right window edge whenever it has any new buffer space
                 available to receive data and by the sender using any
                 incremental window, no matter how small, to send more
                 data [TCP:5].  The result can be a stable pattern of
                 sending tiny data segments, even though both sender and
                 receiver have a large total buffer space for the
                 connection.  SWS can only occur during the transmission
                 of a large amount of data; if the connection goes
                 quiescent, the problem will disappear.  It is caused by
                 typical straightforward implementation of window
                 management, but the sender and receiver algorithms
                 given below will avoid it.

                 Another important TCP performance issue is that some
                 applications, especially remote login to character-at-
                 a-time hosts, tend to send streams of one-octet data
                 segments.  To avoid deadlocks, every TCP SEND call from
                 such applications must be "pushed", either explicitly
                 by the application or else implicitly by TCP.  The
                 result may be a stream of TCP segments that contain one
                 data octet each, which makes very inefficient use of
                 the Internet and contributes to Internet congestion.
                 The Nagle Algorithm described in Section 4.2.3.4
                 provides a simple and effective solution to this
                 problem.  It does have the effect of clumping
```

---
# **RFC1122                  TRANSPORT LAYER -- TCP             October 1989**

```text
                 characters over Telnet connections; this may initially
                 surprise users accustomed to single-character echo, but
                 user acceptance has not been a problem.

                 Note that the Nagle algorithm and the send SWS
                 avoidance algorithm play complementary roles in
                 improving performance.  The Nagle algorithm discourages
                 sending tiny segments when the data to be sent
                 increases in small increments, while the SWS avoidance
                 algorithm discourages small segments resulting from the
                 right window edge advancing in small increments.

                 A careless implementation can send two or more
                 acknowledgment segments per data segment received.  For
                 example, suppose the receiver acknowledges every data
                 segment immediately.  When the application program
                 subsequently consumes the data and increases the
                 available receive buffer space again, the receiver may
                 send a second acknowledgment segment to update the
                 window at the sender.  The extreme case occurs with
                 single-character segments on TCP connections using the
                 Telnet protocol for remote login service.  Some
                 implementations have been observed in which each
                 incoming 1-character segment generates three return
                 segments: (1) the acknowledgment, (2) a one byte
                 increase in the window, and (3) the echoed character,
                 respectively.

         4.2.2.15  Retransmission Timeout: RFC-793 Section 3.7, page 41

            The algorithm suggested in RFC-793 for calculating the
            retransmission timeout is now known to be inadequate; see
            Section 4.2.3.1 below.

            Recent work by Jacobson [TCP:7] on Internet congestion and
            TCP retransmission stability has produced a transmission
            algorithm combining "slow start" with "congestion
            avoidance".  A TCP MUST implement this algorithm.

            If a retransmitted packet is identical to the original
            packet (which implies not only that the data boundaries have
            not changed, but also that the window and acknowledgment
            fields of the header have not changed), then the same IP
            Identification field MAY be used (see Section 3.2.1.5).

            IMPLEMENTATION:
                 Some TCP implementors have chosen to "packetize" the
                 data stream, i.e., to pick segment boundaries when
```

---
# **RFC1122                  TRANSPORT LAYER -- TCP             October 1989**

```text
                 segments are originally sent and to queue these
                 segments in a "retransmission queue" until they are
                 acknowledged.  Another design (which may be simpler) is
                 to defer packetizing until each time data is
                 transmitted or retransmitted, so there will be no
                 segment retransmission queue.

                 In an implementation with a segment retransmission
                 queue, TCP performance may be enhanced by repacketizing
                 the segments awaiting acknowledgment when the first
                 retransmission timeout occurs.  That is, the
                 outstanding segments that fitted would be combined into
                 one maximum-sized segment, with a new IP Identification
                 value.  The TCP would then retain this combined segment
                 in the retransmit queue until it was acknowledged.
                 However, if the first two segments in the
                 retransmission queue totalled more than one maximum-
                 sized segment, the TCP would retransmit only the first
                 segment using the original IP Identification field.
```

- 4.2.2.16 창 관리: RFC-793 섹션 3.7, 페이지 41

```text
            A TCP receiver SHOULD NOT shrink the window, i.e., move the
            right window edge to the left.  However, a sending TCP MUST
            be robust against window shrinking, which may cause the
            "useable window" (see Section 4.2.3.4) to become negative.

            If this happens, the sender SHOULD NOT send new data, but
            SHOULD retransmit normally the old unacknowledged data
            between SND.UNA and SND.UNA+SND.WND.  The sender MAY also
            retransmit old data beyond SND.UNA+SND.WND, but SHOULD NOT
            time out the connection if data beyond the right window edge
            is not acknowledged.  If the window shrinks to zero, the TCP
            MUST probe it in the standard way (see next Section).

            DISCUSSION:
                 Many TCP implementations become confused if the window
                 shrinks from the right after data has been sent into a
                 larger window.  Note that TCP has a heuristic to select
                 the latest window update despite possible datagram
                 reordering; as a result, it may ignore a window update
                 with a smaller window than previously offered if
                 neither the sequence number nor the acknowledgment
                 number is increased.
```

---
# **RFC1122                  TRANSPORT LAYER -- TCP             October 1989**

```text
         4.2.2.17  Probing Zero Windows: RFC-793 Section 3.7, page 42
```

- 제로\(제공된\) 창 프로빙이 지원되어야 합니다.

```text
            A TCP MAY keep its offered receive window closed
            indefinitely.  As long as the receiving TCP continues to
            send acknowledgments in response to the probe segments, the
            sending TCP MUST allow the connection to stay open.

            DISCUSSION:
                 It is extremely important to remember that ACK
                 (acknowledgment) segments that contain no data are not
                 reliably transmitted by TCP.  If zero window probing is
                 not supported, a connection may hang forever when an
                 ACK segment that re-opens the window is lost.

                 The delay in opening a zero window generally occurs
                 when the receiving application stops taking data from
                 its TCP.  For example, consider a printer daemon
                 application, stopped because the printer ran out of
                 paper.

            The transmitting host SHOULD send the first zero-window
            probe when a zero window has existed for the retransmission
            timeout period (see Section 4.2.2.15), and SHOULD increase
            exponentially the interval between successive probes.

            DISCUSSION:
                 This procedure minimizes delay if the zero-window
                 condition is due to a lost ACK segment containing a
                 window-opening update.  Exponential backoff is
                 recommended, possibly with some maximum interval not
                 specified here.  This procedure is similar to that of
                 the retransmission algorithm, and it may be possible to
                 combine the two procedures in the implementation.

         4.2.2.18  Passive OPEN Calls:  RFC-793 Section 3.8

            Every passive OPEN call either creates a new connection
            record in LISTEN state, or it returns an error; it MUST NOT
            affect any previously created connection record.

            A TCP that supports multiple concurrent users MUST provide
            an OPEN call that will functionally allow an application to
            LISTEN on a port while a connection block with the same
            local port is in SYN-SENT or SYN-RECEIVED state.

            DISCUSSION:
```

---
# **RFC1122                  TRANSPORT LAYER -- TCP             October 1989**

```text
                 Some applications (e.g., SMTP servers) may need to
                 handle multiple connection attempts at about the same
                 time.  The probability of a connection attempt failing
                 is reduced by giving the application some means of
                 listening for a new connection at the same time that an
                 earlier connection attempt is going through the three-
                 way handshake.

            IMPLEMENTATION:
                 Acceptable implementations of concurrent opens may
                 permit multiple passive OPEN calls, or they may allow
                 "cloning" of LISTEN-state connections from a single
                 passive OPEN call.
```

- 4.2.2.19 TTL\(Time to Live\): RFC-793 섹션 3.9, 52페이지

```text
            RFC-793 specified that TCP was to request the IP layer to
            send TCP segments with TTL = 60.  This is obsolete; the TTL
            value used to send TCP segments MUST be configurable.  See
            Section 3.2.1.7 for discussion.

         4.2.2.20  Event Processing: RFC-793 Section 3.9

            While it is not strictly required, a TCP SHOULD be capable
            of queueing out-of-order TCP segments.  Change the "may" in
            the last sentence of the first paragraph on page 70 to
            "should".

            DISCUSSION:
                 Some small-host implementations have omitted segment
                 queueing because of limited buffer space.  This
                 omission may be expected to adversely affect TCP
                 throughput, since loss of a single segment causes all
                 later segments to appear to be "out of sequence".

            In general, the processing of received segments MUST be
            implemented to aggregate ACK segments whenever possible.
            For example, if the TCP is processing a series of queued
            segments, it MUST process them all before sending any ACK
            segments.

            Here are some detailed error corrections and notes on the
            Event Processing section of RFC-793.

            (a)  CLOSE Call, CLOSE-WAIT state, p. 61: enter LAST-ACK
                 state, not CLOSING.
```

- \(b\) LISTEN 상태, SYN 확인\(65, 66페이지\): SYN 사용

---
# **RFC1122                  TRANSPORT LAYER -- TCP             October 1989**

```text
                 bit, if the security/compartment or the precedence is
                 wrong for the segment, a reset is sent.  The wrong form
                 of reset is shown in the text; it should be:

                   <SEQ=0><ACK=SEG.SEQ+SEG.LEN><CTL=RST,ACK>

            (c)  SYN-SENT state, Check for SYN, p. 68: When the
                 connection enters ESTABLISHED state, the following
                 variables must be set:
                    SND.WND <- SEG.WND
                    SND.WL1 <- SEG.SEQ
                    SND.WL2 <- SEG.ACK

            (d)  Check security and precedence, p. 71: The first heading
                 "ESTABLISHED STATE" should really be a list of all
                 states other than SYN-RECEIVED: ESTABLISHED, FIN-WAIT-
                 1, FIN-WAIT-2, CLOSE-WAIT, CLOSING, LAST-ACK, and
                 TIME-WAIT.

            (e)  Check SYN bit, p. 71:  "In SYN-RECEIVED state and if
                 the connection was initiated with a passive OPEN, then
                 return this connection to the LISTEN state and return.
                 Otherwise...".

            (f)  Check ACK field, SYN-RECEIVED state, p. 72: When the
                 connection enters ESTABLISHED state, the variables
                 listed in (c) must be set.

            (g)  Check ACK field, ESTABLISHED state, p. 72: The ACK is a
                 duplicate if SEG.ACK =< SND.UNA (the = was omitted).
                 Similarly, the window should be updated if: SND.UNA =<
                 SEG.ACK =< SND.NXT.

            (h)  USER TIMEOUT, p. 77:

                 It would be better to notify the application of the
                 timeout rather than letting TCP force the connection
                 closed.  However, see also Section 4.2.3.5.

         4.2.2.21  Acknowledging Queued Segments: RFC-793 Section 3.9

            A TCP MAY send an ACK segment acknowledging RCV.NXT when a
            valid segment arrives that is in the window but not at the
            left window edge.
```

---
# **RFC1122                  TRANSPORT LAYER -- TCP             October 1989**

```text
            DISCUSSION:
                 RFC-793 (see page 74) was ambiguous about whether or
                 not an ACK segment should be sent when an out-of-order
                 segment was received, i.e., when SEG.SEQ was unequal to
                 RCV.NXT.

                 One reason for ACKing out-of-order segments might be to
                 support an experimental algorithm known as "fast
                 retransmit".   With this algorithm, the sender uses the
                 "redundant" ACK's to deduce that a segment has been
                 lost before the retransmission timer has expired.  It
                 counts the number of times an ACK has been received
                 with the same value of SEG.ACK and with the same right
                 window edge.  If more than a threshold number of such
                 ACK's is received, then the segment containing the
                 octets starting at SEG.ACK is assumed to have been lost
                 and is retransmitted, without awaiting a timeout.  The
                 threshold is chosen to compensate for the maximum
                 likely segment reordering in the Internet.  There is
                 not yet enough experience with the fast retransmit
                 algorithm to determine how useful it is.

      4.2.3  SPECIFIC ISSUES

         4.2.3.1  Retransmission Timeout Calculation

            A host TCP MUST implement Karn's algorithm and Jacobson's
            algorithm for computing the retransmission timeout ("RTO").

            o    Jacobson's algorithm for computing the smoothed round-
                 trip ("RTT") time incorporates a simple measure of the
                 variance [TCP:7].

            o    Karn's algorithm for selecting RTT measurements ensures
                 that ambiguous round-trip times will not corrupt the
                 calculation of the smoothed round-trip time [TCP:6].

            This implementation also MUST include "exponential backoff"
            for successive RTO values for the same segment.
            Retransmission of SYN segments SHOULD use the same algorithm
            as data segments.

            DISCUSSION:
                 There were two known problems with the RTO calculations
                 specified in RFC-793.  First, the accurate measurement
                 of RTTs is difficult when there are retransmissions.
                 Second, the algorithm to compute the smoothed round-
                 trip time is inadequate [TCP:7], because it incorrectly
```

---
# **RFC1122                  TRANSPORT LAYER -- TCP             October 1989**

```text
                 assumed that the variance in RTT values would be small
                 and constant.  These problems were solved by Karn's and
                 Jacobson's algorithm, respectively.

                 The performance increase resulting from the use of
                 these improvements varies from noticeable to dramatic.
                 Jacobson's algorithm for incorporating the measured RTT
                 variance is especially important on a low-speed link,
                 where the natural variation of packet sizes causes a
                 large variation in RTT.  One vendor found link
                 utilization on a 9.6kb line went from 10% to 90% as a
                 result of implementing Jacobson's variance algorithm in
                 TCP.

            The following values SHOULD be used to initialize the
            estimation parameters for a new connection:

            (a)  RTT = 0 seconds.

            (b)  RTO = 3 seconds.  (The smoothed variance is to be
                 initialized to the value that will result in this RTO).

            The recommended upper and lower bounds on the RTO are known
            to be inadequate on large internets.  The lower bound SHOULD
            be measured in fractions of a second (to accommodate high
            speed LANs) and the upper bound should be 2*MSL, i.e., 240
            seconds.

            DISCUSSION:
                 Experience has shown that these initialization values
                 are reasonable, and that in any case the Karn and
                 Jacobson algorithms make TCP behavior reasonably
                 insensitive to the initial parameter choices.
```

- 4.2.3.2 ACK 세그먼트를 보내는 시기

```text
            A host that is receiving a stream of TCP data segments can
            increase efficiency in both the Internet and the hosts by
            sending fewer than one ACK (acknowledgment) segment per data
            segment received; this is known as a "delayed ACK" [TCP:5].

            A TCP SHOULD implement a delayed ACK, but an ACK should not
            be excessively delayed; in particular, the delay MUST be
            less than 0.5 seconds, and in a stream of full-sized
            segments there SHOULD be an ACK for at least every second
            segment.

            DISCUSSION:
```

---
# **RFC1122                  TRANSPORT LAYER -- TCP             October 1989**

```text
                 A delayed ACK gives the application an opportunity to
                 update the window and perhaps to send an immediate
                 response.  In particular, in the case of character-mode
                 remote login, a delayed ACK can reduce the number of
                 segments sent by the server by a factor of 3 (ACK,
                 window update, and echo character all combined in one
                 segment).

                 In addition, on some large multi-user hosts, a delayed
                 ACK can substantially reduce protocol processing
                 overhead by reducing the total number of packets to be
                 processed [TCP:5].  However, excessive delays on ACK's
                 can disturb the round-trip timing and packet "clocking"
                 algorithms [TCP:7].
```

- 4.2.3.3 윈도우 업데이트를 보내는 시기

```text
            A TCP MUST include a SWS avoidance algorithm in the receiver
            [TCP:5].

            IMPLEMENTATION:
                 The receiver's SWS avoidance algorithm determines when
                 the right window edge may be advanced; this is
                 customarily known as "updating the window".  This
                 algorithm combines with the delayed ACK algorithm (see
                 Section 4.2.3.2) to determine when an ACK segment
                 containing the current window will really be sent to
                 the receiver.  We use the notation of RFC-793; see
                 Figures 4 and 5 in that document.

                 The solution to receiver SWS is to avoid advancing the
                 right window edge RCV.NXT+RCV.WND in small increments,
                 even if data is received from the network in small
                 segments.

                 Suppose the total receive buffer space is RCV.BUFF.  At
                 any given moment, RCV.USER octets of this total may be
                 tied up with data that has been received and
                 acknowledged but which the user process has not yet
                 consumed.  When the connection is quiescent, RCV.WND =
                 RCV.BUFF and RCV.USER = 0.

                 Keeping the right window edge fixed as data arrives and
                 is acknowledged requires that the receiver offer less
                 than its full buffer space, i.e., the receiver must
                 specify a RCV.WND that keeps RCV.NXT+RCV.WND constant
                 as RCV.NXT increases.  Thus, the total buffer space
                 RCV.BUFF is generally divided into three parts:
```

---
# **RFC1122                  TRANSPORT LAYER -- TCP             October 1989**

```text
                 |<------- RCV.BUFF ---------------->|
                      1             2            3
             ----|---------|------------------|------|----
                        RCV.NXT               ^
                                           (Fixed)

             1 - RCV.USER =  data received but not yet consumed;
             2 - RCV.WND =   space advertised to sender;
             3 - Reduction = space available but not yet
                             advertised.

                 The suggested SWS avoidance algorithm for the receiver
                 is to keep RCV.NXT+RCV.WND fixed until the reduction
                 satisfies:

                      RCV.BUFF - RCV.USER - RCV.WND  >=

                             min( Fr * RCV.BUFF, Eff.snd.MSS )

                 where Fr is a fraction whose recommended value is 1/2,
                 and Eff.snd.MSS is the effective send MSS for the
                 connection (see Section 4.2.2.6).  When the inequality
                 is satisfied, RCV.WND is set to RCV.BUFF-RCV.USER.

                 Note that the general effect of this algorithm is to
                 advance RCV.WND in increments of Eff.snd.MSS (for
                 realistic receive buffers:  Eff.snd.MSS < RCV.BUFF/2).
                 Note also that the receiver must use its own
                 Eff.snd.MSS, assuming it is the same as the sender's.
```

- 4.2.3.4 데이터 전송 시기

- TCP는 발신자에 SWS 회피 알고리즘을 포함해야 합니다.

```text
            A TCP SHOULD implement the Nagle Algorithm [TCP:9] to
            coalesce short segments.  However, there MUST be a way for
            an application to disable the Nagle algorithm on an
            individual connection.  In all cases, sending data is also
            subject to the limitation imposed by the Slow Start
            algorithm (Section 4.2.2.15).

            DISCUSSION:
                 The Nagle algorithm is generally as follows:

                      If there is unacknowledged data (i.e., SND.NXT >
                      SND.UNA), then the sending TCP buffers all user
```

---
# **RFC1122                  TRANSPORT LAYER -- TCP             October 1989**

```text
                      data (regardless of the PSH bit), until the
                      outstanding data has been acknowledged or until
                      the TCP can send a full-sized segment (Eff.snd.MSS
                      bytes; see Section 4.2.2.6).

                 Some applications (e.g., real-time display window
                 updates) require that the Nagle algorithm be turned
                 off, so small data segments can be streamed out at the
                 maximum rate.

            IMPLEMENTATION:
                 The sender's SWS avoidance algorithm is more difficult
                 than the receivers's, because the sender does not know
                 (directly) the receiver's total buffer space RCV.BUFF.
                 An approach which has been found to work well is for
                 the sender to calculate Max(SND.WND), the maximum send
                 window it has seen so far on the connection, and to use
                 this value as an estimate of RCV.BUFF.  Unfortunately,
                 this can only be an estimate; the receiver may at any
                 time reduce the size of RCV.BUFF.  To avoid a resulting
                 deadlock, it is necessary to have a timeout to force
                 transmission of data, overriding the SWS avoidance
                 algorithm.  In practice, this timeout should seldom
                 occur.
```

- "사용 가능한 창"\[TCP:5\]은 다음과 같습니다.

```text
                      U = SND.UNA + SND.WND - SND.NXT

                 i.e., the offered window less the amount of data sent
                 but not acknowledged.  If D is the amount of data
                 queued in the sending TCP but not yet sent, then the
                 following set of rules is recommended.

                 Send data:
```

- \(1\) 최대 크기의 세그먼트를 전송할 수 있는지, 즉 다음과 같은 경우

```text
                           min(D,U) >= Eff.snd.MSS;

                 (2)  or if the data is pushed and all queued data can
                      be sent now, i.e., if:
```

- \[SND.NXT = SND.UNA 및\] PUSHED 및 D <= U

```text
                      (the bracketed condition is imposed by the Nagle
                      algorithm);
```

---
# **RFC1122                  TRANSPORT LAYER -- TCP             October 1989**

```text
                 (3)  or if at least a fraction Fs of the maximum window
                      can be sent, i.e., if:

                          [SND.NXT = SND.UNA and]

                                  min(D.U) >= Fs * Max(SND.WND);

                 (4)  or if data is PUSHed and the override timeout
                      occurs.

                 Here Fs is a fraction whose recommended value is 1/2.
                 The override timeout should be in the range 0.1 - 1.0
                 seconds.  It may be convenient to combine this timer
                 with the timer used to probe zero windows (Section
                 4.2.2.17).

                 Finally, note that the SWS avoidance algorithm just
                 specified is to be used instead of the sender-side
                 algorithm contained in [TCP:5].

         4.2.3.5  TCP Connection Failures

            Excessive retransmission of the same segment by TCP
            indicates some failure of the remote host or the Internet
            path.  This failure may be of short or long duration.  The
            following procedure MUST be used to handle excessive
            retransmissions of data segments [IP:11]:

            (a)  There are two thresholds R1 and R2 measuring the amount
                 of retransmission that has occurred for the same
                 segment.  R1 and R2 might be measured in time units or
                 as a count of retransmissions.

            (b)  When the number of transmissions of the same segment
                 reaches or exceeds threshold R1, pass negative advice
                 (see Section 3.3.1.4) to the IP layer, to trigger
                 dead-gateway diagnosis.

            (c)  When the number of transmissions of the same segment
                 reaches a threshold R2 greater than R1, close the
                 connection.

            (d)  An application MUST be able to set the value for R2 for
                 a particular connection.  For example, an interactive
                 application might set R2 to "infinity," giving the user
                 control over when to disconnect.
```

---
# **RFC1122                  TRANSPORT LAYER -- TCP             October 1989**

```text
            (d)  TCP SHOULD inform the application of the delivery
                 problem (unless such information has been disabled by
                 the application; see Section 4.2.4.1), when R1 is
                 reached and before R2.  This will allow a remote login
                 (User Telnet) application program to inform the user,
                 for example.

            The value of R1 SHOULD correspond to at least 3
            retransmissions, at the current RTO.  The value of R2 SHOULD
            correspond to at least 100 seconds.

            An attempt to open a TCP connection could fail with
            excessive retransmissions of the SYN segment or by receipt
            of a RST segment or an ICMP Port Unreachable.  SYN
            retransmissions MUST be handled in the general way just
            described for data retransmissions, including notification
            of the application layer.

            However, the values of R1 and R2 may be different for SYN
            and data segments.  In particular, R2 for a SYN segment MUST
            be set large enough to provide retransmission of the segment
            for at least 3 minutes.  The application can close the
            connection (i.e., give up on the open attempt) sooner, of
            course.

            DISCUSSION:
                 Some Internet paths have significant setup times, and
                 the number of such paths is likely to increase in the
                 future.

         4.2.3.6  TCP Keep-Alives

            Implementors MAY include "keep-alives" in their TCP
            implementations, although this practice is not universally
            accepted.  If keep-alives are included, the application MUST
            be able to turn them on or off for each TCP connection, and
            they MUST default to off.

            Keep-alive packets MUST only be sent when no data or
            acknowledgement packets have been received for the
            connection within an interval.  This interval MUST be
            configurable and MUST default to no less than two hours.

            It is extremely important to remember that ACK segments that
            contain no data are not reliably transmitted by TCP.
            Consequently, if a keep-alive mechanism is implemented it
            MUST NOT interpret failure to respond to any specific probe
            as a dead connection.
```

---
# **RFC1122                  TRANSPORT LAYER -- TCP             October 1989**

```text
            An implementation SHOULD send a keep-alive segment with no
            data; however, it MAY be configurable to send a keep-alive
            segment containing one garbage octet, for compatibility with
            erroneous TCP implementations.

            DISCUSSION:
                 A "keep-alive" mechanism periodically probes the other
                 end of a connection when the connection is otherwise
                 idle, even when there is no data to be sent.  The TCP
                 specification does not include a keep-alive mechanism
                 because it could:  (1) cause perfectly good connections
                 to break during transient Internet failures; (2)
                 consume unnecessary bandwidth ("if no one is using the
                 connection, who cares if it is still good?"); and (3)
                 cost money for an Internet path that charges for
                 packets.

                 Some TCP implementations, however, have included a
                 keep-alive mechanism.  To confirm that an idle
                 connection is still active, these implementations send
                 a probe segment designed to elicit a response from the
                 peer TCP.  Such a segment generally contains SEG.SEQ =
                 SND.NXT-1 and may or may not contain one garbage octet
                 of data.  Note that on a quiet connection SND.NXT =
                 RCV.NXT, so that this SEG.SEQ will be outside the
                 window.  Therefore, the probe causes the receiver to
                 return an acknowledgment segment, confirming that the
                 connection is still live.  If the peer has dropped the
                 connection due to a network partition or a crash, it
                 will respond with a RST instead of an acknowledgment
                 segment.

                 Unfortunately, some misbehaved TCP implementations fail
                 to respond to a segment with SEG.SEQ = SND.NXT-1 unless
                 the segment contains data.  Alternatively, an
                 implementation could determine whether a peer responded
                 correctly to keep-alive packets with no garbage data
                 octet.

                 A TCP keep-alive mechanism should only be invoked in
                 server applications that might otherwise hang
                 indefinitely and consume resources unnecessarily if a
                 client crashes or aborts a connection during a network
                 failure.
```

---
# **RFC1122                  TRANSPORT LAYER -- TCP             October 1989**

```text
         4.2.3.7  TCP Multihoming

            If an application on a multihomed host does not specify the
            local IP address when actively opening a TCP connection,
            then the TCP MUST ask the IP layer to select a local IP
            address before sending the (first) SYN.  See the function
            GET_SRCADDR() in Section 3.4.

            At all other times, a previous segment has either been sent
            or received on this connection, and TCP MUST use the same
            local address is used that was used in those previous
            segments.

         4.2.3.8  IP Options

            When received options are passed up to TCP from the IP
            layer, TCP MUST ignore options that it does not understand.
```

- TCP는 타임 스탬프 및 레코드 경로 옵션을 지원할 수 있습니다.

```text
            An application MUST be able to specify a source route when
            it actively opens a TCP connection, and this MUST take
            precedence over a source route received in a datagram.

            When a TCP connection is OPENed passively and a packet
            arrives with a completed IP Source Route option (containing
            a return route), TCP MUST save the return route and use it
            for all segments sent on this connection.  If a different
            source route arrives in a later segment, the later
            definition SHOULD override the earlier one.

         4.2.3.9  ICMP Messages

            TCP MUST act on an ICMP error message passed up from the IP
            layer, directing it to the connection that created the
            error.  The necessary demultiplexing information can be
            found in the IP header contained within the ICMP message.

            o    Source Quench

                 TCP MUST react to a Source Quench by slowing
                 transmission on the connection.  The RECOMMENDED
                 procedure is for a Source Quench to trigger a "slow
                 start," as if a retransmission timeout had occurred.

            o    Destination Unreachable -- codes 0, 1, 5

                 Since these Unreachable messages indicate soft error
```

---
# **RFC1122                  TRANSPORT LAYER -- TCP             October 1989**

```text
                 conditions, TCP MUST NOT abort the connection, and it
                 SHOULD make the information available to the
                 application.

                 DISCUSSION:
                      TCP could report the soft error condition directly
                      to the application layer with an upcall to the
                      ERROR_REPORT routine, or it could merely note the
                      message and report it to the application only when
                      and if the TCP connection times out.

            o    Destination Unreachable -- codes 2-4

                 These are hard error conditions, so TCP SHOULD abort
                 the connection.

            o    Time Exceeded -- codes 0, 1

                 This should be handled the same way as Destination
                 Unreachable codes 0, 1, 5 (see above).

            o    Parameter Problem

                 This should be handled the same way as Destination
                 Unreachable codes 0, 1, 5 (see above).

         4.2.3.10  Remote Address Validation

            A TCP implementation MUST reject as an error a local OPEN
            call for an invalid remote IP address (e.g., a broadcast or
            multicast address).

            An incoming SYN with an invalid source address must be
            ignored either by TCP or by the IP layer (see Section
            3.2.1.3).

            A TCP implementation MUST silently discard an incoming SYN
            segment that is addressed to a broadcast or multicast
            address.

         4.2.3.11  TCP Traffic Patterns

            IMPLEMENTATION:
                 The TCP protocol specification [TCP:1] gives the
                 implementor much freedom in designing the algorithms
                 that control the message flow over the connection --
                 packetizing, managing the window, sending
```

---
# **RFC1122                  TRANSPORT LAYER -- TCP             October 1989**

```text
                 acknowledgments, etc.  These design decisions are
                 difficult because a TCP must adapt to a wide range of
                 traffic patterns.  Experience has shown that a TCP
                 implementor needs to verify the design on two extreme
                 traffic patterns:

                 o    Single-character Segments

                      Even if the sender is using the Nagle Algorithm,
                      when a TCP connection carries remote login traffic
                      across a low-delay LAN the receiver will generally
                      get a stream of single-character segments.  If
                      remote terminal echo mode is in effect, the
                      receiver's system will generally echo each
                      character as it is received.

                 o    Bulk Transfer

                      When TCP is used for bulk transfer, the data
                      stream should be made up (almost) entirely of
                      segments of the size of the effective MSS.
                      Although TCP uses a sequence number space with
                      byte (octet) granularity, in bulk-transfer mode
                      its operation should be as if TCP used a sequence
                      space that counted only segments.

                 Experience has furthermore shown that a single TCP can
                 effectively and efficiently handle these two extremes.

                 The most important tool for verifying a new TCP
                 implementation is a packet trace program.  There is a
                 large volume of experience showing the importance of
                 tracing a variety of traffic patterns with other TCP
                 implementations and studying the results carefully.

         4.2.3.12  Efficiency

            IMPLEMENTATION:
                 Extensive experience has led to the following
                 suggestions for efficient implementation of TCP:

                 (a)  Don't Copy Data

                      In bulk data transfer, the primary CPU-intensive
                      tasks are copying data from one place to another
                      and checksumming the data.  It is vital to
                      minimize the number of copies of TCP data.  Since
```

---
# **RFC1122                  TRANSPORT LAYER -- TCP             October 1989**

```text
                      the ultimate speed limitation may be fetching data
                      across the memory bus, it may be useful to combine
                      the copy with checksumming, doing both with a
                      single memory fetch.
```

- \(b\) 체크섬 루틴을 직접 작성

```text
                      A good TCP checksumming routine is typically two
                      to five times faster than a simple and direct
                      implementation of the definition.  Great care and
                      clever coding are often required and advisable to
                      make the checksumming code "blazing fast".  See
                      [TCP:10].
```

- \(c\) 일반 사례에 대한 코드

```text
                      TCP protocol processing can be complicated, but
                      for most segments there are only a few simple
                      decisions to be made.  Per-segment processing will
                      be greatly speeded up by coding the main line to
                      minimize the number of decisions in the most
                      common case.

      4.2.4  TCP/APPLICATION LAYER INTERFACE

         4.2.4.1  Asynchronous Reports

            There MUST be a mechanism for reporting soft TCP error
            conditions to the application.  Generically, we assume this
            takes the form of an application-supplied ERROR_REPORT
            routine that may be upcalled [INTRO:7] asynchronously from
            the transport layer:

               ERROR_REPORT(local connection name, reason, subreason)

            The precise encoding of the reason and subreason parameters
            is not specified here.  However, the conditions that are
            reported asynchronously to the application MUST include:

            *    ICMP error message arrived (see 4.2.3.9)

            *    Excessive retransmissions (see 4.2.3.5)

            *    Urgent pointer advance (see 4.2.2.4).

            However, an application program that does not want to
            receive such ERROR_REPORT calls SHOULD be able to
```

---
# **RFC1122                  TRANSPORT LAYER -- TCP             October 1989**

```text
            effectively disable these calls.

            DISCUSSION:
                 These error reports generally reflect soft errors that
                 can be ignored without harm by many applications.  It
                 has been suggested that these error report calls should
                 default to "disabled," but this is not required.

         4.2.4.2  Type-of-Service

            The application layer MUST be able to specify the Type-of-
            Service (TOS) for segments that are sent on a connection.
            It not required, but the application SHOULD be able to
            change the TOS during the connection lifetime.  TCP SHOULD
            pass the current TOS value without change to the IP layer,
            when it sends segments on the connection.

            The TOS will be specified independently in each direction on
            the connection, so that the receiver application will
            specify the TOS used for ACK segments.

            TCP MAY pass the most recently received TOS up to the
            application.

            DISCUSSION
                 Some applications (e.g., SMTP) change the nature of
                 their communication during the lifetime of a
                 connection, and therefore would like to change the TOS
                 specification.

                 Note also that the OPEN call specified in RFC-793
                 includes a parameter ("options") in which the caller
                 can specify IP options such as source route, record
                 route, or timestamp.

         4.2.4.3  Flush Call

            Some TCP implementations have included a FLUSH call, which
            will empty the TCP send queue of any data for which the user
            has issued SEND calls but which is still to the right of the
            current send window.  That is, it flushes as much queued
            send data as possible without losing sequence number
            synchronization.  This is useful for implementing the "abort
            output" function of Telnet.
```

---
# **RFC1122                  TRANSPORT LAYER -- TCP             October 1989**

```text
         4.2.4.4  Multihoming

            The user interface outlined in sections 2.7 and 3.8 of RFC-
            793 needs to be extended for multihoming.  The OPEN call
            MUST have an optional parameter:

                OPEN( ... [local IP address,] ... )
```

- 로컬 IP 주소 지정을 허용합니다.

```text
            DISCUSSION:
                 Some TCP-based applications need to specify the local
                 IP address to be used to open a particular connection;
                 FTP is an example.

            IMPLEMENTATION:
                 A passive OPEN call with a specified "local IP address"
                 parameter will await an incoming connection request to
                 that address.  If the parameter is unspecified, a
                 passive OPEN will await an incoming connection request
                 to any local IP address, and then bind the local IP
                 address of the connection to the particular address
                 that is used.

                 For an active OPEN call, a specified "local IP address"
                 parameter will be used for opening the connection.  If
                 the parameter is unspecified, the networking software
                 will choose an appropriate local IP address (see
                 Section 3.3.4.2) for the connection

      4.2.5  TCP REQUIREMENT SUMMARY

                                                 |        | | | |S| |
                                                 |        | | | |H| |F
                                                 |        | | | |O|M|o
                                                 |        | |S| |U|U|o
                                                 |        | |H| |L|S|t
                                                 |        |M|O| |D|T|n
                                                 |        |U|U|M| | |o
                                                 |        |S|L|A|N|N|t
                                                 |        |T|D|Y|O|O|t
FEATURE                                          |SECTION | | | |T|T|e
-------------------------------------------------|--------|-|-|-|-|-|--
                                                 |        | | | | | |
Push flag                                        |        | | | | | |
  Aggregate or queue un-pushed data              |4.2.2.2 | | |x| | |
  Sender collapse successive PSH flags           |4.2.2.2 | |x| | | |
  SEND call can specify PUSH                     |4.2.2.2 | | |x| | |
```

---
# **RFC1122                  TRANSPORT LAYER -- TCP             October 1989**

```text
    If cannot: sender buffer indefinitely        |4.2.2.2 | | | | |x|
    If cannot: PSH last segment                  |4.2.2.2 |x| | | | |
  Notify receiving ALP of PSH                    |4.2.2.2 | | |x| | |1
  Send max size segment when possible            |4.2.2.2 | |x| | | |
                                                 |        | | | | | |
Window                                           |        | | | | | |
  Treat as unsigned number                       |4.2.2.3 |x| | | | |
  Handle as 32-bit number                        |4.2.2.3 | |x| | | |
  Shrink window from right                       |4.2.2.16| | | |x| |
  Robust against shrinking window                |4.2.2.16|x| | | | |
  Receiver's window closed indefinitely          |4.2.2.17| | |x| | |
  Sender probe zero window                       |4.2.2.17|x| | | | |
    First probe after RTO                        |4.2.2.17| |x| | | |
    Exponential backoff                          |4.2.2.17| |x| | | |
  Allow window stay zero indefinitely            |4.2.2.17|x| | | | |
  Sender timeout OK conn with zero wind          |4.2.2.17| | | | |x|
                                                 |        | | | | | |
Urgent Data                                      |        | | | | | |
  Pointer points to last octet                   |4.2.2.4 |x| | | | |
  Arbitrary length urgent data sequence          |4.2.2.4 |x| | | | |
  Inform ALP asynchronously of urgent data       |4.2.2.4 |x| | | | |1
  ALP can learn if/how much urgent data Q'd      |4.2.2.4 |x| | | | |1
                                                 |        | | | | | |
TCP Options                                      |        | | | | | |
  Receive TCP option in any segment              |4.2.2.5 |x| | | | |
  Ignore unsupported options                     |4.2.2.5 |x| | | | |
  Cope with illegal option length                |4.2.2.5 |x| | | | |
  Implement sending & receiving MSS option       |4.2.2.6 |x| | | | |
  Send MSS option unless 536                     |4.2.2.6 | |x| | | |
  Send MSS option always                         |4.2.2.6 | | |x| | |
  Send-MSS default is 536                        |4.2.2.6 |x| | | | |
  Calculate effective send seg size              |4.2.2.6 |x| | | | |
                                                 |        | | | | | |
TCP Checksums                                    |        | | | | | |
  Sender compute checksum                        |4.2.2.7 |x| | | | |
  Receiver check checksum                        |4.2.2.7 |x| | | | |
                                                 |        | | | | | |
Use clock-driven ISN selection                   |4.2.2.9 |x| | | | |
                                                 |        | | | | | |
Opening Connections                              |        | | | | | |
  Support simultaneous open attempts             |4.2.2.10|x| | | | |
  SYN-RCVD remembers last state                  |4.2.2.11|x| | | | |
  Passive Open call interfere with others        |4.2.2.18| | | | |x|
  Function: simultan. LISTENs for same port      |4.2.2.18|x| | | | |
  Ask IP for src address for SYN if necc.        |4.2.3.7 |x| | | | |
    Otherwise, use local addr of conn.           |4.2.3.7 |x| | | | |
  OPEN to broadcast/multicast IP Address         |4.2.3.14| | | | |x|
  Silently discard seg to bcast/mcast addr       |4.2.3.14|x| | | | |
```

---
# **RFC1122                  TRANSPORT LAYER -- TCP             October 1989**

```text
                                                 |        | | | | | |
Closing Connections                              |        | | | | | |
  RST can contain data                           |4.2.2.12| |x| | | |
  Inform application of aborted conn             |4.2.2.13|x| | | | |
  Half-duplex close connections                  |4.2.2.13| | |x| | |
    Send RST to indicate data lost               |4.2.2.13| |x| | | |
  In TIME-WAIT state for 2xMSL seconds           |4.2.2.13|x| | | | |
    Accept SYN from TIME-WAIT state              |4.2.2.13| | |x| | |
                                                 |        | | | | | |
Retransmissions                                  |        | | | | | |
  Jacobson Slow Start algorithm                  |4.2.2.15|x| | | | |
  Jacobson Congestion-Avoidance algorithm        |4.2.2.15|x| | | | |
  Retransmit with same IP ident                  |4.2.2.15| | |x| | |
  Karn's algorithm                               |4.2.3.1 |x| | | | |
  Jacobson's RTO estimation alg.                 |4.2.3.1 |x| | | | |
  Exponential backoff                            |4.2.3.1 |x| | | | |
  SYN RTO calc same as data                      |4.2.3.1 | |x| | | |
  Recommended initial values and bounds          |4.2.3.1 | |x| | | |
                                                 |        | | | | | |
Generating ACK's:                                |        | | | | | |
  Queue out-of-order segments                    |4.2.2.20| |x| | | |
  Process all Q'd before send ACK                |4.2.2.20|x| | | | |
  Send ACK for out-of-order segment              |4.2.2.21| | |x| | |
  Delayed ACK's                                  |4.2.3.2 | |x| | | |
    Delay < 0.5 seconds                          |4.2.3.2 |x| | | | |
    Every 2nd full-sized segment ACK'd           |4.2.3.2 |x| | | | |
  Receiver SWS-Avoidance Algorithm               |4.2.3.3 |x| | | | |
                                                 |        | | | | | |
Sending data                                     |        | | | | | |
  Configurable TTL                               |4.2.2.19|x| | | | |
  Sender SWS-Avoidance Algorithm                 |4.2.3.4 |x| | | | |
  Nagle algorithm                                |4.2.3.4 | |x| | | |
    Application can disable Nagle algorithm      |4.2.3.4 |x| | | | |
                                                 |        | | | | | |
Connection Failures:                             |        | | | | | |
  Negative advice to IP on R1 retxs              |4.2.3.5 |x| | | | |
  Close connection on R2 retxs                   |4.2.3.5 |x| | | | |
  ALP can set R2                                 |4.2.3.5 |x| | | | |1
  Inform ALP of  R1<=retxs<R2                    |4.2.3.5 | |x| | | |1
  Recommended values for R1, R2                  |4.2.3.5 | |x| | | |
  Same mechanism for SYNs                        |4.2.3.5 |x| | | | |
    R2 at least 3 minutes for SYN                |4.2.3.5 |x| | | | |
                                                 |        | | | | | |
Send Keep-alive Packets:                         |4.2.3.6 | | |x| | |
  - Application can request                      |4.2.3.6 |x| | | | |
  - Default is "off"                             |4.2.3.6 |x| | | | |
  - Only send if idle for interval               |4.2.3.6 |x| | | | |
  - Interval configurable                        |4.2.3.6 |x| | | | |
```

---
# **RFC1122                  TRANSPORT LAYER -- TCP             October 1989**

```text
  - Default at least 2 hrs.                      |4.2.3.6 |x| | | | |
  - Tolerant of lost ACK's                       |4.2.3.6 |x| | | | |
                                                 |        | | | | | |
IP Options                                       |        | | | | | |
  Ignore options TCP doesn't understand          |4.2.3.8 |x| | | | |
  Time Stamp support                             |4.2.3.8 | | |x| | |
  Record Route support                           |4.2.3.8 | | |x| | |
  Source Route:                                  |        | | | | | |
    ALP can specify                              |4.2.3.8 |x| | | | |1
      Overrides src rt in datagram               |4.2.3.8 |x| | | | |
    Build return route from src rt               |4.2.3.8 |x| | | | |
    Later src route overrides                    |4.2.3.8 | |x| | | |
                                                 |        | | | | | |
Receiving ICMP Messages from IP                  |4.2.3.9 |x| | | | |
  Dest. Unreach (0,1,5) => inform ALP            |4.2.3.9 | |x| | | |
  Dest. Unreach (0,1,5) => abort conn            |4.2.3.9 | | | | |x|
  Dest. Unreach (2-4) => abort conn              |4.2.3.9 | |x| | | |
  Source Quench => slow start                    |4.2.3.9 | |x| | | |
  Time Exceeded => tell ALP, don't abort         |4.2.3.9 | |x| | | |
  Param Problem => tell ALP, don't abort         |4.2.3.9 | |x| | | |
                                                 |        | | | | | |
Address Validation                               |        | | | | | |
  Reject OPEN call to invalid IP address         |4.2.3.10|x| | | | |
  Reject SYN from invalid IP address             |4.2.3.10|x| | | | |
  Silently discard SYN to bcast/mcast addr       |4.2.3.10|x| | | | |
                                                 |        | | | | | |
TCP/ALP Interface Services                       |        | | | | | |
  Error Report mechanism                         |4.2.4.1 |x| | | | |
  ALP can disable Error Report Routine           |4.2.4.1 | |x| | | |
  ALP can specify TOS for sending                |4.2.4.2 |x| | | | |
    Passed unchanged to IP                       |4.2.4.2 | |x| | | |
  ALP can change TOS during connection           |4.2.4.2 | |x| | | |
  Pass received TOS up to ALP                    |4.2.4.2 | | |x| | |
  FLUSH call                                     |4.2.4.3 | | |x| | |
  Optional local IP addr parm. in OPEN           |4.2.4.4 |x| | | | |
-------------------------------------------------|--------|-|-|-|-|-|--
-------------------------------------------------|--------|-|-|-|-|-|--
```

---
# **FOOTNOTES:**

```text
(1)  "ALP" means Application-Layer program.
```

---
# **RFC1122                  TRANSPORT LAYER -- TCP             October 1989**
---
## **5.  REFERENCES**
---
# **INTRODUCTORY REFERENCES**

\[소개:1\] "인터넷 호스트에 대한 요구 사항 - 응용 프로그램 및 지원", IETF 호스트 요구 사항 작업 그룹, R. Braden, Ed., RFC-1123, 1989년 10월.

\[소개:2\] "인터넷 게이트웨이 요구 사항", R. Braden 및 J. Postel, RFC-1009, 1987년 6월.

```text
[INTRO:3]  "DDN Protocol Handbook," NIC-50004, NIC-50005, NIC-50006,
     (three volumes), SRI International, December 1985.
```

\[소개:4\] "공식 인터넷 프로토콜", J. Reynolds 및 J. Postel, RFC-1011, 1987년 5월.

이 문서는 새로운 RFC 번호로 정기적으로 다시 게시됩니다. 최신 버전을 사용해야 합니다.

\[소개:5\] "프로토콜 문서 주문 정보", O. Jacobsen 및 J. Postel, RFC-980, 1986년 3월.

\[소개:6\] "할당된 번호", J. Reynolds 및 J. Postel, RFC-1010, 1987년 5월.

이 문서는 새로운 RFC 번호로 정기적으로 다시 게시됩니다. 최신 버전을 사용해야 합니다.

\[소개:7\] "프로토콜 구현의 모듈화 및 효율성", D. Clark, RFC-817, 1982년 7월.

\[소개:8\] "업콜을 사용한 시스템 구조화", D. Clark, 10th ACM SOSP, Orcas Island, Washington, 1985년 12월.

---
# **Secondary References:**

\[소개:9\] "패킷 네트워크 상호 통신을 위한 프로토콜", V. Cerf 및 R. Kahn, IEEE Transactions on Communication, 1974년 5월.

\[소개:10\] "ARPA 인터넷 프로토콜", J. Postel, C. Sunshine 및 D. Cohen, Computer Networks, Vol. 1981년 7월 5일 4호.

\[소개:11\] "DARPA 인터넷 프로토콜 제품군" B. Leiner, J. Postel, R. Cole 및 D. Mills, Proceedings INFOCOM 85, IEEE, Washington DC,

---
# **RFC1122                  TRANSPORT LAYER -- TCP             October 1989**

1985년 3월. 추가 자료: IEEE Communications Magazine, 1985년 3월. ISI-RS-85-153으로도 사용 가능.

\[소개:12\] "DIS8473의 최종 텍스트, 비연결 모드 네트워크 서비스 제공을 위한 프로토콜" ANSI, 1986년 3월 RFC-994로 출판.

\[소개:13\] "최종 시스템 대 중간 시스템 라우팅 교환 프로토콜", ANSI X3S3.3, 1986년 4월 RFC-995로 게시.

---
# **LINK LAYER REFERENCES**

\[링크:1\] "예고편 캡슐화", S. Leffler 및 M. Karels, RFC-893, 1984년 4월.

```text
[LINK:2] "An Ethernet Address Resolution Protocol," D. Plummer, RFC-826,
     November 1982.
```

\[링크:3\] "이더넷 네트워크를 통한 IP 데이터그램 전송 표준", C. Hornig, RFC-894, 1984년 4월.

\[링크:4\] "IEEE 802 "네트워크"를 통한 IP 데이터그램 전송 표준, J. Postel 및 J. Reynolds, RFC-1042, 1988년 2월.

이 RFC에는 IEEE 802 네트워크를 사용하려는 인터넷 구현자에게 중요한 정보가 많이 포함되어 있습니다.

---
# **IP LAYER REFERENCES**

```text
[IP:1] "Internet Protocol (IP)," J. Postel, RFC-791, September 1981.

[IP:2] "Internet Control Message Protocol (ICMP)," J. Postel, RFC-792,
     September 1981.
```

\[IP:3\] "인터넷 표준 서브넷 절차", J. Mogul 및 J. Postel, RFC-950, 1985년 8월.

\[IP:4\] "IP 멀티캐스팅을 위한 호스트 확장", S. Deering, RFC-1112, 1989년 8월.

\[IP:5\] "군사 표준 인터넷 프로토콜", MIL-STD-1777, 국방부, 1983년 8월.

```text
     This specification, as amended by RFC-963, is intended to describe
```

---
# **RFC1122                  TRANSPORT LAYER -- TCP             October 1989**

인터넷 프로토콜이지만 몇 가지 심각한 누락이 있습니다\(예: 필수 서브넷 확장\[IP:3\] 및 선택적 멀티캐스팅 확장\[IP:4\]\). 또한 오래된 것입니다. 충돌이 있는 경우 RFC-791, RFC-792 및 RFC-950을 권위 있는 것으로 간주해야 하며, 현재 문서는 모두 권위가 있습니다.

\[IP:6\] "군사 표준 인터넷 프로토콜 사양의 일부 문제", D. Sidhu, RFC-963, 1985년 11월.

\[IP:7\] "TCP 최대 세그먼트 크기 및 관련 항목", J. Postel, RFC-879, 1983년 11월.

TCP 최대 세그먼트 크기 옵션과 IP 데이터그램 크기 간의 관계를 논의하고 명확하게 설명합니다.

```text
[IP:8] "Internet Protocol Security Options,"  B. Schofield, RFC-1108,
     October 1989.
```

\[IP:9\] "유해한 것으로 간주되는 조각화", C. Kent 및 J. Mogul, ACM SIGCOMM-87, 1987년 8월. ACM Comp Comm Review, Vol. 17, 아니. 5.

이 유용한 문서에서는 인터넷 단편화로 인해 발생하는 문제에 대해 논의하고 대체 솔루션을 제시합니다.

```text
[IP:10] "IP Datagram Reassembly Algorithms," D. Clark, RFC-815, July
     1982.
```

모든 구현자는 이 문서와 다음 문서를 읽어야 합니다.

\[IP:11\] "결함 격리 및 복구", D. Clark, RFC-816, 1982년 7월.

---
# **SECONDARY IP REFERENCES:**

\[IP:12\] "서브넷이 있는 상태에서 인터넷 데이터그램 브로드캐스팅", J. Mogul, RFC-922, 1984년 10월.

\[IP:13\] "이름, 주소, 항구 및 경로", D. Clark, RFC-814, 1982년 7월.

\[IP:14\] "호스트가 Source Quench로 수행할 수 있는 작업: Source Quench에서 SQUID\(Introduced Delay\)가 도입되었습니다." W. Prue 및 J. Postel, RFC-1016, 1987년 7월.

이 RFC에서는 직접 브로드캐스트 주소를 처음으로 설명했습니다. 그러나 RFC의 대부분은 호스트가 아닌 게이트웨이와 관련이 있습니다.

---
# **RFC1122                  TRANSPORT LAYER -- TCP             October 1989**
---
# **UDP REFERENCES:**

```text
[UDP:1] "User Datagram Protocol," J. Postel, RFC-768, August 1980.
```

---
# **TCP REFERENCES:**

```text
[TCP:1] "Transmission Control Protocol," J. Postel, RFC-793, September
     1981.
```

\[TCP:2\] "전송 제어 프로토콜", MIL-STD-1778, 미국 국방부, 1984년 8월.

RFC-964에 의해 개정된 이 사양은 RFC-793 \[TCP:1\]과 동일한 프로토콜을 설명하기 위한 것입니다. 충돌이 있는 경우 RFC-793이 우선하며 현재 문서가 두 가지 모두에 대해 권위를 갖습니다.

\[TCP:3\] "군사 표준 전송 제어 프로토콜 사양의 일부 문제", D. Sidhu 및 T. Blumer, RFC-964, 1985년 11월.

\[TCP:4\] "TCP 최대 세그먼트 크기 및 관련 항목", J. Postel, RFC-879, 1983년 11월.

\[TCP:5\] "TCP의 창 및 승인 전략", D. Clark, RFC-813, 1982년 7월.

```text
[TCP:6] "Round Trip Time Estimation," P. Karn & C. Partridge, ACM
     SIGCOMM-87, August 1987.
```

\[TCP:7\] "혼잡 방지 및 제어", V. Jacobson, ACM SIGCOMM-88, 1988년 8월.

---
# **SECONDARY TCP REFERENCES:**

\[TCP:8\] "프로토콜 구현의 모듈화 및 효율성", D. Clark, RFC-817, 1982년 7월.

---
# **RFC1122                  TRANSPORT LAYER -- TCP             October 1989**

\[TCP:9\] "IP/TCP의 혼잡 제어", J. Nagle, RFC-896, 1984년 1월.

\[TCP:10\] "인터넷 체크섬 계산", R. Braden, D. Borman 및 C. Partridge, RFC-1071, 1988년 9월.

\[TCP:11\] "장기 지연 경로를 위한 TCP 확장", V. Jacobson 및 R. Braden, RFC-1072, 1988년 10월.

---
# **Security Considerations**

호스트 소프트웨어의 통신 계층에는 많은 보안 문제가 있지만 전체 논의는 이 RFC의 범위를 벗어납니다.

인터넷 아키텍처는 일반적으로 IP 소스 주소 스푸핑에 대한 보호 기능을 거의 제공하지 않으므로 데이터그램의 IP 소스 주소 확인을 기반으로 하는 보안 메커니즘은 의심스럽게 다루어야 합니다. 그러나 제한된 환경에서는 일부 소스 주소 확인이 가능할 수 있습니다. 예를 들어, 나머지 인터넷으로의 게이트웨이가 LAN 주소를 스푸핑한 소스 주소를 사용하여 들어오는 데이터그램을 모두 폐기하는 보안 LAN이 있을 수 있습니다. 이 경우 LAN의 호스트는 소스 주소를 사용하여 로컬 소스와 원격 소스를 테스트할 수 있습니다. 이 문제는 소스 라우팅으로 인해 복잡해지고 일부에서는 호스트에 의한 소스 라우팅 데이터그램 전달\(섹션 3.3.5 참조\)이 보안상의 이유로 금지되어야 한다고 제안했습니다.

보안 관련 문제는 IP 보안 옵션\(섹션 3.2.1.8\), ICMP 매개 변수 문제 메시지\(섹션 3.2.2.5\), UDP 데이터그램의 IP 옵션\(섹션 4.1.3.2\) 및 예약된 TCP 포트\(섹션 4.1.3.2\)와 관련된 섹션에서 언급됩니다. 4.2.2.1\).

---
# **Author's Address**

```text
   Robert Braden
   USC/Information Sciences Institute
   4676 Admiralty Way
   Marina del Rey, CA 90292-6695

   Phone: (213) 822 1511

   EMail: Braden@ISI.EDU
```
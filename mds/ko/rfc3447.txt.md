

```text
Network Working Group                                         J. Jonsson
Request for Comments: 3447                                    B. Kaliski
Obsoletes: 2437                                         RSA Laboratories
Category: Informational                                    February 2003

     Public-Key Cryptography Standards (PKCS) #1: RSA Cryptography
                      Specifications Version 2.1
```

---
# **Status of this Memo**

이 메모는 인터넷 커뮤니티에 대한 정보를 제공합니다. 어떤 종류의 인터넷 표준도 지정하지 않습니다. 이 메모의 배포는 무제한입니다.

---
# **Copyright Notice**

저작권\(C\)인터넷학회\(2003\). 판권 소유.

---
# **Abstract**

이 메모는 RSA Laboratories의 PKCS\(공개 키 암호화 표준\) 시리즈에서 PKCS #1 v2.1의 재출판을 나타내며 변경 제어는 PKCS 프로세스 내에서 유지됩니다. 이 문서의 본문은 PKCS #1 v2.1 문서에서 직접 가져온 것이며 출판 과정에서 일부 수정이 이루어졌습니다.

---
# **Table of Contents**

```text
   1.       Introduction...............................................2
   2.       Notation...................................................3
   3.       Key types..................................................6
      3.1      RSA public key..........................................6
      3.2      RSA private key.........................................7
   4.       Data conversion primitives.................................8
      4.1      I2OSP...................................................9
      4.2      OS2IP...................................................9
   5.       Cryptographic primitives..................................10
      5.1      Encryption and decryption primitives...................10
      5.2      Signature and verification primitives..................12
   6.       Overview of schemes.......................................14
   7.       Encryption schemes........................................15
      7.1      RSAES-OAEP.............................................16
      7.2      RSAES-PKCS1-v1_5.......................................23
   8.       Signature schemes with appendix...........................27
      8.1      RSASSA-PSS.............................................29
      8.2      RSASSA-PKCS1-v1_5......................................32
   9.       Encoding methods for signatures with appendix.............35
      9.1      EMSA-PSS...............................................36
      9.2      EMSA-PKCS1-v1_5........................................41
   Appendix A. ASN.1 syntax...........................................44
      A.1      RSA key representation.................................44
      A.2      Scheme identification..................................46
   Appendix B. Supporting techniques..................................52
      B.1      Hash functions.........................................52
      B.2      Mask generation functions..............................54
   Appendix C. ASN.1 module...........................................56
   Appendix D. Intellectual Property Considerations...................63
   Appendix E. Revision history.......................................64
   Appendix F. References.............................................65
   Appendix G. About PKCS.............................................70
   Appendix H. Corrections Made During RFC Publication Process........70
   Security Considerations............................................70
   Acknowledgements...................................................71
   Authors' Addresses.................................................71
   Full Copyright Statement...........................................72
```

---
## **1. Introduction**

이 문서는 다음 측면을 다루는 RSA 알고리즘\[42\]을 기반으로 하는 공개 키 암호화 구현에 대한 권장 사항을 제공합니다.

```text
    * Cryptographic primitives

    * Encryption schemes
```

\* 부록이 포함된 서명 구성표

\* 키를 표현하고 체계를 식별하기 위한 ASN.1 구문

권장 사항은 컴퓨터 및 통신 시스템 내의 일반적인 적용을 위한 것이므로 상당한 유연성을 포함합니다. 이러한 사양을 기반으로 하는 응용 표준에는 추가적인 제약 사항이 포함될 수 있습니다. 권장 사항은 표준 IEEE-1363-2000\[26\] 및 ANSI X9F1\[1\] 및 IEEE P1363\[27\] 작업 그룹에서 현재 개발 중인 표준 초안과 호환되도록 고안되었습니다.

이 문서는 PKCS #1 버전 2.0 \[35\]\[44\]을 대체하지만 호환 가능한 기술을 포함합니다.

이 문서의 구성은 다음과 같습니다.

\* 1장은 소개입니다.

\* 섹션 2에서는 이 문서에 사용된 일부 표기법을 정의합니다.

\* 섹션 3에서는 RSA 공개 키와 개인 키 유형을 정의합니다.

\* 섹션 4와 5에서는 여러 기본 요소 또는 기본 수학 연산을 정의합니다. 데이터 변환 기본 요소는 섹션 4에 있고 암호화 기본 요소\(암호화-복호화, 서명-검증\)는 섹션 5에 있습니다.

\* 섹션 6, 7, 8에서는 이 문서의 암호화 및 서명 체계를 다룹니다. 섹션 6에서는 개요를 제공합니다. PKCS #1 v1.5에 있는 방법과 함께 섹션 7에서는 OAEP 기반 \[3\] 암호화 체계를 정의하고 섹션 8에서는 부록과 함께 PSS 기반 \[4\]\[5\] 서명 체계를 정의합니다.

\* 9절에서는 8절의 서명 체계에 대한 인코딩 방법을 정의합니다.

\* 부록 A에서는 섹션 3에 정의된 키에 대한 ASN.1 구문과 섹션 7 및 8의 구성표를 정의합니다.

\* 부록 B에서는 해당 기술에 대한 ASN.1 구문을 포함하여 본 문서에 사용된 해시 함수 및 마스크 생성 함수를 정의합니다.

\* 부록 C에는 ASN.1 모듈이 나와 있습니다.

\* 부록 D, E, F 및 G는 지적 재산권 문제를 다루고, PKCS #1의 개정 내역을 간략하게 설명하고, 다른 간행물 및 표준에 대한 참조를 제공하고, 공개 키 암호화 표준에 대한 일반 정보를 제공합니다.

---
## **2. Notation**

```text
   c              ciphertext representative, an integer between 0 and
                  n-1

   C              ciphertext, an octet string

   d              RSA private exponent

   d_i            additional factor r_i's CRT exponent, a positive
                  integer such that

                    e * d_i == 1 (mod (r_i-1)), i = 3, ..., u

   dP             p's CRT exponent, a positive integer such that

                    e * dP == 1 (mod (p-1))

   dQ             q's CRT exponent, a positive integer such that

                    e * dQ == 1 (mod (q-1))

   e              RSA public exponent

   EM             encoded message, an octet string

   emBits         (intended) length in bits of an encoded message EM

   emLen          (intended) length in octets of an encoded message EM
```

GCD\(. , .\) 음이 아닌 두 정수의 최대 공약수

```text
   Hash           hash function

   hLen           output length in octets of hash function Hash

   k              length in octets of the RSA modulus n

   K              RSA private key

   L              optional RSAES-OAEP label, an octet string
```

LCM\(., ..., .\) 음이 아닌 정수 목록의 최소 공배수

```text
   m              message representative, an integer between 0 and n-1

   M              message, an octet string

   mask           MGF output, an octet string

   maskLen        (intended) length of the octet string mask

   MGF            mask generation function

   mgfSeed        seed from which mask is generated, an octet string

   mLen           length in octets of a message M

   n              RSA modulus, n = r_1 * r_2 * ... * r_u , u >= 2

   (n, e)         RSA public key

   p, q           first two prime factors of the RSA modulus n

   qInv           CRT coefficient, a positive integer less than p such
                  that

                    q * qInv == 1 (mod p)

   r_i            prime factors of the RSA modulus n, including r_1 = p,
                  r_2 = q, and additional factors if any

   s              signature representative, an integer between 0 and n-1

   S              signature, an octet string

   sLen           length in octets of the EMSA-PSS salt

   t_i            additional prime factor r_i's CRT coefficient, a
                  positive integer less than r_i such that

                    r_1 * r_2 * ... * r_(i-1) * t_i == 1 (mod r_i) ,

                  i = 3, ... , u

   u              number of prime factors of the RSA modulus, u >= 2

   x              a nonnegative integer

   X              an octet string corresponding to x

   xLen           (intended) length of the octet string X

   0x             indicator of hexadecimal representation of an octet or
                  an octet string; "0x48" denotes the octet with
                  hexadecimal value 48; "(0x)48 09 0e" denotes the
                  string of three consecutive octets with hexadecimal
                  value 48, 09, and 0e, respectively

   \lambda(n)     LCM(r_1-1, r_2-1, ... , r_u-1)

   \xor           bit-wise exclusive-or of two octet strings
```

\ceil\(.\) 천장 함수; \ceil\(x\)는 실수 x보다 크거나 같은 가장 작은 정수입니다.

```text
   ||             concatenation operator
```

== 합동 기호; a == b \(mod n\)은 정수 n이 정수 a - b를 나눈다는 것을 의미합니다.

메모. CRT는 재귀적 방식뿐만 아니라 비재귀적 방식으로도 적용될 수 있습니다. 이 문서에서는 Garner의 알고리즘\[22\]을 따르는 재귀적 접근 방식이 사용됩니다. 섹션 3.2의 참고 1도 참조하세요.

---
## **3. Key types**

이 문서에 정의된 기본 요소와 체계에는 RSA 공개 키와 RSA 개인 키라는 두 가지 키 유형이 사용됩니다. RSA 공개 키와 RSA 개인 키가 함께 RSA 키 쌍을 형성합니다.

이 사양은 계수가 2개 이상의 소인수를 가질 수 있는 소위 "다중 소수" RSA를 지원합니다. 다중 소수 RSA의 이점은 CRT\(중국어 나머지 정리\)가 사용되는 경우 암호 해독 및 서명 프리미티브에 대한 계산 비용이 낮다는 것입니다. 단일 프로세서 플랫폼에서 더 나은 성능을 얻을 수 있지만, 관련된 모듈식 지수화가 병렬로 수행될 수 있는 다중 프로세서 플랫폼에서 더 나은 성능을 얻을 수 있습니다.

다중 소수가 RSA 암호 시스템의 보안에 어떤 영향을 미치는지에 대한 논의는 독자를 참조하십시오 \[49\].

---
## **3.1 RSA public key**

이 문서의 목적에 따라 RSA 공개 키는 두 가지 구성 요소로 구성됩니다.

```text
      n        the RSA modulus, a positive integer
      e        the RSA public exponent, a positive integer
```

유효한 RSA 공개 키에서 RSA 모듈러스 n은 u개의 고유한 홀수 소수 r\_i, i = 1, 2, ..., u의 곱입니다. 여기서 u \>= 2이고 RSA 공개 지수 e는 3 사이의 정수입니다. n - 1은 GCD\(e, \lambda\(n\)\) = 1을 만족하며, 여기서 \lambda\(n\) = LCM\(r\_1 - 1, ..., r\_u - 1\)입니다. 관례적으로, 처음 두 소수 r\_1과 r\_2는 각각 p와 q로 표시될 수도 있습니다.

구현 간 RSA 공개 키 교환에 권장되는 구문은 부록 A.1.1에 나와 있습니다. 구현의 내부 표현은 다를 수 있습니다.

---
## **3.2 RSA private key**

이 문서의 목적에 따라 RSA 개인 키는 두 가지 표현 중 하나를 가질 수 있습니다.

1. 첫 번째 표현은 \(n, d\) 쌍으로 구성되며, 여기서 구성 요소는 다음과 같은 의미를 갖습니다.

```text
         n        the RSA modulus, a positive integer
         d        the RSA private exponent, a positive integer
```

2. 두 번째 표현은 5중\(p, q, dP, dQ, qInv\)과 3중\(r\_i, d\_i, t\_i\)의 \(아마도 비어 있는\) 시퀀스로 구성됩니다. i = 3, ..., u, 각각 하나씩 소수는 5중이 아닙니다. 여기서 구성 요소는 다음과 같은 의미를 갖습니다.

```text
         p        the first factor, a positive integer
         q        the second factor, a positive integer
         dP       the first factor's CRT exponent, a positive integer
         dQ       the second factor's CRT exponent, a positive integer
         qInv     the (first) CRT coefficient, a positive integer
         r_i      the i-th factor, a positive integer
         d_i      the i-th factor's CRT exponent, a positive integer
         t_i      the i-th factor's CRT coefficient, a positive integer
```

첫 번째 표현이 있는 유효한 RSA 개인 키에서 RSA 모듈러스 n은 해당 RSA 공개 키와 동일하며 u개의 고유한 홀수 소수 r\_i, i = 1, 2, ..., u의 곱입니다. 여기서 u \>= 2. RSA 비공개 지수 d는 다음을 만족하는 n보다 작은 양의 정수입니다.

```text
      e * d == 1 (mod \lambda(n)),
```

여기서 e는 해당 RSA 공개 지수이고 \lambda\(n\)은 섹션 3.1에서와 같이 정의됩니다.

두 번째 표현을 사용하는 유효한 RSA 개인 키에서 두 요소 p와 q는 RSA 모듈러스 n의 처음 두 소인수\(즉, r\_1과 r\_2\)이고, CRT 지수 dP와 dQ는 p와 q보다 작은 양의 정수입니다. 각각 만족스럽다

```text
      e * dP == 1 (mod (p-1))
      e * dQ == 1 (mod (q-1)) ,
```

CRT 계수 qInv는 다음을 만족하는 p보다 작은 양의 정수입니다.

```text
      q * qInv == 1 (mod p).
```

u \> 2인 경우 표현에는 하나 이상의 삼중항\(r\_i, d\_i, t\_i\), i = 3, ..., u가 포함됩니다. r\_i 인자는 RSA 모듈러스 n의 추가 소인수입니다. 각 CRT 지수 d\_i \(i = 3, ..., u\)는 다음을 충족합니다.

```text
      e * d_i == 1 (mod (r_i - 1)).
```

각 CRT 계수 t\_i\(i = 3, ..., u\)는 다음을 만족하는 r\_i보다 작은 양의 정수입니다.

```text
      R_i * t_i == 1 (mod r_i) ,
```

여기서 R\_i = r\_1 \* r\_2 \* ... \* r\_\(i-1\)입니다.

두 표현의 구성 요소를 모두 포함하는 구현 간에 RSA 개인 키를 교환하기 위한 권장 구문은 부록 A.1.2에 나와 있습니다. 구현의 내부 표현은 다를 수 있습니다.

```text
   Notes.
```

1. 여기서 CRT 계수의 정의와 섹션 5의 기본 요소에서 이를 사용하는 공식은 일반적으로 Garner의 알고리즘 \[22\]을 따릅니다\(\[37\]의 알고리즘 14.71 참조\). 그러나 PKCS #1 v2.0 및 이전 버전의 RSA 개인 키 표현과의 호환성을 위해 p 및 q의 역할은 나머지 소수와 반대입니다. 따라서 첫 번째 CRT 계수 qInv는 R\_1 mod r\_2의 역, 즉 p mod q가 아니라 q mod p의 역으로 ​​정의됩니다.

2. Quisquater와 Couvreur \[40\]는 중국 나머지 정리를 RSA 연산에 적용하는 것의 이점을 관찰했습니다.

---
## **4. Data conversion primitives**

이 문서에 정의된 체계에는 두 가지 데이터 변환 기본 요소가 사용됩니다.

```text
      * I2OSP - Integer-to-Octet-String primitive

      * OS2IP - Octet-String-to-Integer primitive
```

이 문서의 목적과 ASN.1 구문에 따라 옥텟 문자열은 순서가 지정된 옥텟\(8비트 바이트\) 시퀀스입니다. 시퀀스는 처음\(일반적으로 가장 왼쪽\)부터 마지막\(가장 오른쪽\)까지 인덱싱됩니다. 정수와의 변환을 위해 첫 번째 옥텟은 다음 변환 프리미티브에서 가장 중요한 것으로 간주됩니다.

---
## **4.1 I2OSP**

I2OSP는 음이 아닌 정수를 지정된 길이의 옥텟 문자열로 변환합니다.

```text
   I2OSP (x, xLen)

   Input:
   x        nonnegative integer to be converted
   xLen     intended length of the resulting octet string

   Output:
   X        corresponding octet string of length xLen

   Error: "integer too large"

   Steps:
```

1. x \>= 256^xLen인 경우 "정수가 너무 큼"을 출력하고 중지합니다.

2. 정수 x를 256진수로 고유한 xLen 숫자 표현으로 작성합니다.

```text
         x = x_(xLen-1) 256^(xLen-1) + x_(xLen-2) 256^(xLen-2) + ...
         + x_1 256 + x_0,
```

- 여기서 0 <= x\_i < 256입니다\(x가 256^\(xLen-1\)보다 작으면 하나 이상의 선행 숫자가 0이 됩니다\).

3. 옥텟 X\_i가 1 <= i <= xLen에 대해 정수 값 x\_\(xLen-i\)을 갖도록 합니다. 옥텟 문자열 출력

```text
         X = X_1 X_2 ... X_xLen.
```

---
## **4.2 OS2IP**

OS2IP는 옥텟 문자열을 음수가 아닌 정수로 변환합니다.

```text
   OS2IP (X)

   Input:
   X        octet string to be converted

   Output:
   x        corresponding nonnegative integer

   Steps:
```

1. X\_1 X\_2 ... X\_xLen을 처음부터 마지막까지 X의 옥텟으로 하고 x\_\(xLen-i\)를 1 <= i <= xLen에 대한 옥텟 X\_i의 정수 값으로 둡니다.

```text
   2. Let x = x_(xLen-1) 256^(xLen-1) + x_(xLen-2) 256^(xLen-2) + ...
      + x_1 256 + x_0.

   3. Output x.
```

---
## **5. Cryptographic primitives**

암호화 기본 요소는 암호화 체계를 구축할 수 있는 기본적인 수학 연산입니다. 이는 하드웨어 또는 소프트웨어 모듈로 구현하기 위한 것이며 체계와 별개로 보안을 제공하기 위한 것이 아닙니다.

이 문서에는 네 가지 유형의 기본 요소가 쌍으로 구성되어 지정됩니다. 암호화 및 암호 해독; 서명 및 확인.

기본 요소의 사양에서는 입력이 특정 조건, 특히 RSA 공개 키와 개인 키가 유효하다고 가정합니다.

---
## **5.1 Encryption and decryption primitives**

암호화 프리미티브는 공개 키의 제어 하에 메시지 표현으로부터 암호문 표현을 생성하고, 복호화 프리미티브는 해당 개인 키의 제어 하에 암호문 표현으로부터 메시지 표현을 복구합니다.

한 쌍의 암호화 및 암호 해독 기본 요소는 이 문서에 정의된 암호화 체계에 사용되며 RSAEP/RSADP에 지정되어 있습니다. RSAEP와 RSADP는 입력 키가 서로 다르지만 동일한 수학 연산을 사용합니다.

여기에 정의된 기본 요소는 IEEE Std 1363-2000\[26\]의 IFEP-RSA/IFDP-RSA와 동일하며\(멀티 프라임 RSA에 대한 지원이 추가된 점 제외\) PKCS #1 v1.5와 호환됩니다.

각 프리미티브의 주요 수학 연산은 지수입니다.

---
### **5.1.1 RSAEP**

```text
   RSAEP ((n, e), m)

   Input:
   (n, e)   RSA public key
   m        message representative, an integer between 0 and n - 1

   Output:
   c        ciphertext representative, an integer between 0 and n - 1

   Error: "message representative out of range"
```

가정: RSA 공개 키\(n, e\)가 유효합니다.

```text
   Steps:
```

1. 메시지 대표 m이 0과 n - 1 사이에 있지 않으면 "메시지 대표가 범위를 벗어났습니다"를 출력하고 중지합니다.

```text
   2. Let c = m^e mod n.

   3. Output c.
```

---
### **5.1.2   RSADP**

```text
   RSADP (K, c)

   Input:
   K        RSA private key, where K has one of the following forms:
            - a pair (n, d)
            - a quintuple (p, q, dP, dQ, qInv) and a possibly empty
              sequence of triplets (r_i, d_i, t_i), i = 3, ..., u
   c        ciphertext representative, an integer between 0 and n - 1

   Output:
   m        message representative, an integer between 0 and n - 1

   Error: "ciphertext representative out of range"
```

가정: RSA 개인 키 K가 유효합니다.

```text
   Steps:
```

1. 암호문 대표 c가 0과 n - 1 사이에 없으면 "암호문 대표 범위를 벗어났습니다"를 출력하고 중지합니다.

2. 메시지 대표 m은 다음과 같이 계산됩니다.

-  ㅏ. K의 첫 번째 형식\(n, d\)이 사용되는 경우 m = c^d mod n으로 둡니다.

-ㄴ. K의 두 번째 형태\(p, q, dP, dQ, qInv\) 및 \(r\_i, d\_i, t\_i\)가 사용되는 경우 다음과 같이 진행합니다.

-     나. m\_1 = c^dP mod p 및 m\_2 = c^dQ mod q라고 합니다.

- ii. u \> 2이면 m\_i = c^\(d\_i\) mod r\_i, i = 3, ..., u로 둡니다.

```text
         iii.  Let h = (m_1 - m_2) * qInv mod p.

         iv.   Let m = m_2 + q * h.
```

- v. u \> 2이면 R = r\_1로 하고 i = 3이면 u는 다음을 수행합니다.

```text
                  1. Let R = R * r_(i-1).

                  2. Let h = (m_i - m) * t_i mod r_i.

                  3. Let m = m + R * h.

   3.   Output m.
```

메모. 2.b 단계는 p와 q의 순서가 반대라면 단일 루프로 다시 작성할 수 있습니다. 그러나 PKCS #1 v2.0과의 일관성을 위해 처음 두 소수 p와 q는 추가 소수와 별도로 처리됩니다.

---
## **5.2 Signature and verification primitives**

서명 프리미티브는 개인키의 제어를 받는 메시지 표현으로부터 서명 표현을 생성하고, 검증 프리미티브는 해당 공개키의 제어를 받는 서명 표현으로부터 메시지 표현을 복구합니다. 한 쌍의 서명 및 검증 기본 요소는 이 문서에 정의된 서명 체계에 사용되며 RSASP1/RSAVP1에 지정되어 있습니다.

여기에 정의된 프리미티브는 IEEE 1363-2000\[26\]의 IFSP-RSA1/IFVP-RSA1과 동일하며\(멀티 프라임 RSA에 대한 지원이 추가된 점 제외\) PKCS #1 v1.5와 호환됩니다.

각 기본 요소의 주요 수학적 연산은 섹션 5.1의 암호화 및 암호 해독 기본 요소에서와 같이 지수화입니다. RSASP1 및 RSAVP1은 입력 및 출력 인수의 이름을 제외하고 RSADP 및 RSAEP와 동일합니다. 그것들은 서로 다른 목적으로 사용되기 때문에 구별됩니다.

---
### **5.2.1 RSASP1**

```text
   RSASP1 (K, m)

   Input:
   K        RSA private key, where K has one of the following forms:
            - a pair (n, d)
            - a quintuple (p, q, dP, dQ, qInv) and a (possibly empty)
              sequence of triplets (r_i, d_i, t_i), i = 3, ..., u
   m        message representative, an integer between 0 and n - 1

   Output:
   s        signature representative, an integer between 0 and n - 1

   Error: "message representative out of range"
```

가정: RSA 개인 키 K가 유효합니다.

```text
   Steps:
```

1. 메시지 대표 m이 0과 n - 1 사이에 있지 않으면 "메시지 대표가 범위를 벗어났습니다"를 출력하고 중지합니다.

2. 서명 대표자 s는 다음과 같이 계산됩니다.

-  ㅏ. K의 첫 번째 형식\(n, d\)이 사용되는 경우 s = m^d mod n으로 둡니다.

-ㄴ. K의 두 번째 형태\(p, q, dP, dQ, qInv\) 및 \(r\_i, d\_i, t\_i\)가 사용되는 경우 다음과 같이 진행합니다.

-     나. s\_1 = m^dP mod p 및 s\_2 = m^dQ mod q로 설정합니다.

- ii. u \> 2이면 s\_i = m^\(d\_i\) mod r\_i, i = 3, ..., u로 둡니다.

```text
         iii.  Let h = (s_1 - s_2) * qInv mod p.

         iv.   Let s = s_2 + q * h.
```

- v. u \> 2이면 R = r\_1로 하고 i = 3이면 u는 다음을 수행합니다.

```text
                  1. Let R = R * r_(i-1).

                  2. Let h = (s_i - s) * t_i mod r_i.

                  3. Let s = s + R * h.

   3. Output s.
```

메모. 2.b 단계는 p와 q의 순서가 반대라면 단일 루프로 다시 작성할 수 있습니다. 그러나 PKCS #1 v2.0과의 일관성을 위해 처음 두 소수 p와 q는 추가 소수와 별도로 처리됩니다.

---
### **5.2.2 RSAVP1**

```text
   RSAVP1 ((n, e), s)

   Input:
   (n, e)   RSA public key
   s        signature representative, an integer between 0 and n - 1

   Output:
   m        message representative, an integer between 0 and n - 1

   Error: "signature representative out of range"
```

가정: RSA 공개 키\(n, e\)가 유효합니다.

```text
   Steps:
```

1. 서명 대표자 s가 0과 n-1 사이에 있지 않으면 "서명 대표자가 범위를 벗어났습니다"를 출력하고 중지합니다.

```text
   2. Let m = s^e mod n.

   3. Output m.
```

---
## **6. Overview of schemes**

체계는 특정 보안 목표를 달성하기 위해 암호화 기본 요소와 기타 기술을 결합합니다. 이 문서에는 암호화 체계와 부록이 포함된 서명 체계라는 두 가지 유형의 체계가 지정되어 있습니다.

이 문서에 지정된 체계는 해당 작업이 RSA 공개 또는 개인 키를 사용하여 데이터를 처리하는 단계로만 구성되고 키를 얻거나 검증하는 단계를 포함하지 않는다는 점에서 범위가 제한됩니다. 따라서 계획 운영 외에도 애플리케이션에는 일반적으로 다음과 같은 주요 관리 작업이 포함됩니다.

당사자는 계획 운영을 ​​위해 RSA 공개 및 개인 키를 선택할 수 있습니다. 특정 추가 작업 및 기타 세부 정보는 이 문서의 범위를 벗어납니다.

암호화 기본 요소\(섹션 5\)의 경우와 마찬가지로 체계 작업 사양에서는 입력이 특정 조건, 특히 RSA 공개 키와 개인 키가 유효하다고 가정합니다. 따라서 키가 유효하지 않은 경우 구현 동작이 지정되지 않습니다. 이러한 지정되지 않은 동작의 영향은 애플리케이션에 따라 다릅니다. 키 유효성 검사를 처리하는 가능한 방법에는 애플리케이션에 의한 명시적인 키 유효성 검사가 포함됩니다. 공개 키 인프라 내 키 검증 유효하지 않은 키로 수행된 작업에 대한 책임은 키를 생성한 당사자에게 할당됩니다.

일반적으로 좋은 암호화 방법은 주어진 RSA 키 쌍을 하나의 체계에서만 사용하는 것입니다. 이는 한 체계의 취약성이 다른 체계의 보안을 손상시킬 수 있는 위험을 방지하고 입증 가능한 보안을 유지하는 데 필수적일 수 있습니다. RSAES-PKCS1-v1\_5\(섹션 7.2\) 및 RSASSA-PKCS1-v1\_5\(섹션 8.2\)는 전통적으로 알려진 나쁜 상호 작용 없이 함께 사용되었지만\(실제로 이는 PKCS #1 v1.5에서 도입된 모델입니다\) 새로운 애플리케이션에는 RSA 키 쌍을 사용하지 않는 것이 좋습니다.

둘 이상의 체계에서 RSA 키 쌍 사용과 관련된 위험을 설명하기 위해 RSAES-OAEP\(섹션 7.1\) 및 RSAES-PKCS1-v1\_5 모두에서 RSA 키 쌍이 사용된다고 가정합니다. RSAES-OAEP 자체는 공격에 저항하지만 상대방은 RSAES-PKCS1-v1\_5 구현의 약점을 악용하여 두 체계 중 하나로 암호화된 메시지를 복구할 수 있습니다. 또 다른 예로, RSASSA-PSS\(섹션 8.1\)와 RSASSA-PKCS1-v1\_5 모두에 RSA 키 쌍이 사용된다고 가정해 보겠습니다. 그러면 RSASSA-PSS에 대한 보안 증명은 두 번째 체계로 서명이 생성될 가능성을 고려하지 않기 때문에 더 이상 충분하지 않습니다. RSA 키 쌍이 여기에 정의된 체계 중 하나와 다른 곳에 정의된 변형에 사용되는 경우 유사한 고려 사항이 적용될 수 있습니다.

---
## **7. Encryption schemes**

이 문서의 목적에 따라 암호화 체계는 암호화 작업과 암호 해독 작업으로 구성됩니다. 여기서 암호화 작업은 수신자의 RSA 공개 키가 있는 메시지에서 암호문을 생성하고 암호 해독 작업은 수신자의 RSA 공개 키가 있는 암호문에서 메시지를 복구합니다. 해당 RSA 개인 키.

암호화 체계는 다양한 애플리케이션에 사용될 수 있습니다. 일반적인 애플리케이션은 키 설정 프로토콜로, 메시지에는 한 당사자에서 다른 당사자에게 비밀리에 전달될 키 자료가 포함되어 있습니다. 예를 들어, PKCS #7\[45\]은 콘텐츠 암호화 키를 발신자로부터 수신자에게 전달하기 위해 이러한 프로토콜을 사용합니다. 여기에 정의된 암호화 체계는 해당 컨텍스트에 적합한 키 암호화 알고리즘입니다.

이 문서에는 RSAES-OAEP 및 RSAES-PKCS1-v1\_5라는 두 가지 암호화 체계가 지정되어 있습니다. RSAES-OAEP는 새로운 애플리케이션에 권장됩니다. RSAES-PKCS1-v1\_5는 기존 애플리케이션과의 호환성을 위해서만 포함되며 새 애플리케이션에는 권장되지 않습니다.

여기에 제시된 암호화 체계는 IEEE Std 1363-2000\[26\]에서 사용된 것과 유사한 일반 모델을 따르며, 암호화 및 암호 해독 기본 요소와 암호화를 위한 인코딩 방법을 결합합니다. 암호화 작업은 메시지 인코딩 작업을 메시지에 적용하여 인코딩된 메시지를 생성한 다음 정수 메시지 표현으로 변환합니다. 암호문을 생성하기 위해 암호화 프리미티브가 메시지 표현에 적용됩니다. 이를 반대로 해독 작업은 암호문에 해독 기본 요소를 적용하여 메시지 표현을 복구한 다음 옥텟 문자열로 인코딩된 메시지로 변환합니다. 메시지 디코딩 작업은 인코딩된 메시지에 적용되어 메시지를 복구하고 암호 해독의 정확성을 확인합니다.

디코딩 작업 내에서 오류가 처리되는 방식과 관련된 구현 약점을 피하기 위해\(\[6\] 및 \[36\] 참조\) RSAES-OAEP 및 RSAES-PKCS1-v1\_5에 대한 인코딩 및 디코딩 작업은 해당 암호화 사양에 포함됩니다. 별도의 사양으로 정의되지 않고 체계로 구성됩니다. 두 암호화 체계 모두 PKCS #1 v2.0의 해당 체계와 호환됩니다.

---
## **7.1 RSAES-OAEP**

RSAES-OAEP는 RSAEP 및 RSADP 프리미티브\(섹션 5.1.1 및 5.1.2\)를 EME-OAEP 인코딩 방법\(섹션 7.1.1의 1.b단계 및 섹션 7.1.2의 3단계\)과 결합합니다. EME-OAEP는 Bellare와 Rogaway의 최적 비대칭 암호화 체계\[3\]를 기반으로 합니다. \(OAEP는 "최적의 비대칭 암호화 패딩"을 나타냅니다.\) 이는 IEEE Std 1363-2000\[26\]에 정의된 IFES 방식과 호환되며, 암호화 및 복호화 기본 요소는 IFEP-RSA 및 IFDP-RSA이고 메시지 인코딩 방법은 EME-OAEP입니다. RSAES-OAEP는 최대 k - 2hLen - 2 옥텟 길이의 메시지에 대해 작동할 수 있습니다. 여기서 hLen은 기본 해시 함수의 출력 길이이고 k는 수신자의 RSA 모듈러스 옥텟 길이입니다.

e-th 루트 모듈로 n을 계산하는 것이 불가능하고 RSAES-OAEP의 마스크 생성 기능이 적절한 속성을 가지고 있다고 가정하면 RSAES-OAEP는 적응형 선택 암호문 공격에 대해 의미론적으로 안전합니다. 이 보증은 마스크 생성 기능이 블랙박스 또는 랜덤 오라클로 간주되는 경우 RSAES-OAEP를 깨는 어려움이 RSA 기능 반전의 어려움과 직접적으로 관련될 수 있다는 점에서 입증 가능합니다. 자세한 내용은 \[21\] 및 아래 참고 사항을 참조하세요.

RSAES-OAEP의 암호화 및 복호화 작업은 모두 레이블 L 값을 입력으로 사용합니다. 이 버전의 PKCS #1에서 L은 빈 문자열입니다. 라벨의 다른 용도는 이 문서의 범위를 벗어납니다. 관련 ASN.1 구문은 부록 A.2.1을 참조하세요.

RSAES-OAEP는 해시 함수와 마스크 생성 함수를 선택하여 매개변수화됩니다. 이 선택은 특정 RSA 키에 대해 수정되어야 합니다. 제안된 해시 및 마스크 생성 기능은 부록 B에 나와 있습니다.

메모. 최근 결과는 OAEP 인코딩 방법\[3\]\(대략 섹션 7.1.1의 1.b 단계에 설명된 절차\)의 보안 속성을 명확하게 설명하는 데 도움이 되었습니다. 배경은 다음과 같습니다. 1994년 Bellare와 Rogaway\[3\]는 일반 텍스트 인식\(PA94\)을 나타내는 보안 개념을 도입했습니다. 그들은 결정론적 공개 키 암호화 기본 요소\(예: RSAEP\)가 개인 키 없이 반전하기 어려운 경우 해당 OAEP 기반 암호화 체계가 일반 텍스트를 인식\(임의의 오라클 모델에서\)한다는 것을 증명했습니다. 기본 일반 텍스트를 실제로 "알지" 않고는 유효한 암호문을 생성할 수 없습니다. 암호화 체계에 대한 일반 텍스트 인식은 선택된 암호문 공격에 대한 체계의 저항과 밀접한 관련이 있습니다. 이러한 공격에서는 공격자에게 암호 해독 기본 요소를 시뮬레이션하는 오라클에 쿼리를 보낼 수 있는 기회가 제공됩니다. 공격자는 이러한 쿼리 결과를 사용하여 챌린지 암호문의 암호를 해독하려고 시도합니다.

그러나 선택 암호문 공격에는 두 가지 유형이 있으며 PA94는 그 중 하나만에 대한 보안을 의미합니다. 차이점은 공격자가 챌린지 암호문을 받은 후 무엇을 할 수 있는지에 따라 달라집니다. 무관심 공격 시나리오\(CCA1로 표시\)는 적에게 도전 암호문을 제공한 후 복호화 오라클에 대한 어떠한 쿼리도 허용하지 않는 반면, 적응형 시나리오\(CCA2로 표시\)는 허용합니다\(단, 복호화 오라클은 도전 암호문이 일단 해독되는 것을 거부합니다\) 출판\). 1998년에 Bellare와 Rogaway는 Desai 및 Pointcheval\[2\]과 함께 CCA2에 대한 보안을 암시하는 일반 텍스트 인식\(PA98\)에 대한 새롭고 강력한 개념을 내놓았습니다.

요약하자면, 오해의 원인이 될 수 있는 두 가지가 있습니다. 즉, PA94와 PA98은 동일한 개념이라는 것입니다. 또는 CCA1과 CCA2는 동일한 개념입니다. 어느 가정이든 Bellare-Rogaway 논문은 CCA2에 대한 OAEP의 보안을 암시한다는 결론으로 ​​이어지지만 그렇지 않습니다.

\(각주: PKCS #1 v2.0은 \[3\]을 인용하고 일반 텍스트 인식 종류를 지정하지 않고 "선택한 암호 텍스트 공격은 RSAES-OAEP와 같은 일반 텍스트 인식 암호화 체계에 대해 효과적이지 않습니다"라고 주장한다고 언급하는 것이 공정할 수 있습니다. 또는 선택한 암호문 공격이 고려됩니다.\)

OAEP는 CCA2에 대해 안전한 것으로 입증된 적이 없습니다. 실제로 Victor Shoup \[48\]는 일반적인 경우에는 그러한 증거가 존재하지 않음을 입증했습니다. 간단히 말해서 Shoup는 암호화 기본 요소를 부분적으로 반전시키는 방법을 알고 있지만 완전히 반전시키는 방법을 모르는 CCA2 시나리오의 공격자가 체계를 깨뜨릴 수 있음을 보여주었습니다. 예를 들어 공격자가 RSAEP로 암호화된 무작위 정수의 처음 20바이트를 제외한 모든 부분을 복구하는 방법을 안다면 RSAES-OAEP를 해독할 수 있다고 상상할 수 있습니다. 이러한 공격자는 공격에서 처음 20옥텟을 사용하지 않기 때문에 RSAEP를 완전히 반전시킬 수 있을 필요는 없습니다.

그럼에도 불구하고 RSAES-OAEP는 Shoup의 결과 발표 직후 Fujisaki, Okamoto, Pointcheval 및 Stern \[21\]에 의해 입증된 CCA2에 대해 안전합니다. 영리한 격자 감소 기술을 사용하여 사전 이미지의 충분히 큰 부분이 주어지면 RSAEP를 완전히 반전시키는 방법을 보여주었습니다. 이 관찰은 기본 암호화 기본 요소를 부분적으로 반전시키기 어려운 경우 OAEP가 CCA2에 대해 안전하다는 증거와 결합되어 Bellare와 Rogaway가 RSAES-OAEP에 대해 증명한 것과 일부 사람들이 증명했다고 믿었던 것 사이의 격차를 메워줍니다. 다소 역설적이게도 RSAEP의 표면적인 약점으로 인해 우리는 구원을 받습니다\(즉, 전체 역은 RSAEP의 일부에서 추론될 수 있습니다\).

그러나 불행하게도 보안 감소는 구체적인 매개변수에 대해서는 효율적이지 않습니다. 증명은 RSAES-OAEP의 CCA2 보안에 대한 적대자 Adv를 RSA를 반전하는 알고리즘 Inv와 성공적으로 연결했지만 Inv의 성공 확률은 대략 \epsilon^2 / 2^18에 불과합니다. 여기서 \epsilon은 다음의 성공 확률입니다. 고급

\(각주: \[21\]에서 인버터의 성공 확률은 \epsilon^2 / 4였습니다. 추가 요소 1 / 2^16은 인코딩된 메시지 EM의 시작 부분에 있는 8개의 고정 0 비트 때문입니다. \[21\]에서 고려된 OAEP의 변형에 존재합니다\(Inv는 RSA를 반전시키려면 Adv를 두 번 적용해야 하며 각 적용은 요소 1/2^8에 해당합니다\).

또한 Inv의 실행 시간은 대략 t^2이며, 여기서 t는 적의 실행 시간입니다. 결과적으로 RSAES-OAEP를 공격하는 것이 구체적인 매개변수에 대해 RSA를 반전시키는 것보다 훨씬 쉬울 가능성을 배제할 수 없습니다. 그럼에도 불구하고 보안 증명이 존재한다는 것은 RSAES-OAEP 구성이 RSAES-PKCS1-v1\_5와 같은 임시 구성보다 더 건전하다는 어느 정도 보증을 제공합니다.

RSA-KEM 키 캡슐화 패러다임을 기반으로 하는 하이브리드 암호화 체계는 구체적인 매개변수에 직접 적용할 수 있는 강력한 보안 증명을 제공합니다. 논의는 \[30\]을 참조하세요. PKCS #1의 향후 버전에서는 이 패러다임을 기반으로 하는 구성표를 지정할 수 있습니다.

---
### **7.1.1 Encryption operation**

```text
   RSAES-OAEP-ENCRYPT ((n, e), M, L)

   Options:
   Hash     hash function (hLen denotes the length in octets of the hash
            function output)
   MGF      mask generation function

   Input:
   (n, e)   recipient's RSA public key (k denotes the length in octets
            of the RSA modulus n)
   M        message to be encrypted, an octet string of length mLen,
            where mLen <= k - 2hLen - 2
   L        optional label to be associated with the message; the
            default value for L, if L is not provided, is the empty
            string

   Output:
   C        ciphertext, an octet string of length k

   Errors:  "message too long"; "label too long"
```

가정: RSA 공개 키\(n, e\)가 유효합니다.

```text
   Steps:

   1. Length checking:
```

-  ㅏ. L의 길이가 해시 함수의 입력 제한\(SHA-1의 경우 2^61 - 1 옥텟\)보다 큰 경우 "label too long"을 출력하고 중지합니다.

-ㄴ. mLen \> k - 2hLen - 2이면 "message too long"을 출력하고 중지합니다.

```text
   2. EME-OAEP encoding (see Figure 1 below):
```

-  ㅏ. 레이블 L이 제공되지 않으면 L을 빈 문자열로 둡니다. lHash = Hash\(L\), 길이가 hLen인 옥텟 문자열이라고 가정합니다\(아래 참고 참조\).

-ㄴ. k - mLen - 2hLen - 2개의 0 옥텟으로 구성된 옥텟 문자열 PS를 생성합니다. PS의 길이는 0일 수 있습니다.

-  씨. lHash, PS, 16진수 값 0x01을 갖는 단일 옥텟 및 메시지 M을 연결하여 길이 k - hLen - 1 옥텟의 데이터 블록 DB를 형성합니다.

```text
            DB = lHash || PS || 0x01 || M.
```

- 디. 길이가 hLen인 임의의 옥텟 문자열 시드를 생성합니다.

```text
      e. Let dbMask = MGF(seed, k - hLen - 1).

      f. Let maskedDB = DB \xor dbMask.

      g. Let seedMask = MGF(maskedDB, hLen).

      h. Let maskedSeed = seed \xor seedMask.
```

-  나. 16진수 값 0x00, MaskedSeed 및 MaskedDB를 사용하여 단일 옥텟을 연결하여 다음과 같이 길이 k 옥텟의 인코딩된 메시지 EM을 형성합니다.

```text
            EM = 0x00 || maskedSeed || maskedDB.

   3. RSA encryption:
```

ㅏ. 인코딩된 메시지 EM을 정수 메시지로 변환

- 대표 m\(섹션 4.2 참조\):

```text
            m = OS2IP (EM).
```

-ㄴ. RSAEP 암호화 프리미티브\(5.1.1절\)를 RSA 공개 키\(n, e\)와 메시지 표현 m에 적용하여 c를 표현하는 정수 암호문을 생성합니다.

```text
            c = RSAEP ((n, e), m).
```

-  씨. 암호문 대표 c를 길이 k 옥텟의 암호문 C로 변환합니다\(섹션 4.1 참조\).

```text
            C = I2OSP (c, k).
```

4. 암호문 C를 출력합니다.

메모. L이 빈 문자열인 경우 해당 해시 값 lHash는 다양한 해시 선택에 대해 다음과 같은 16진수 표현을 갖습니다.

```text
   SHA-1:   (0x)da39a3ee 5e6b4b0d 3255bfef 95601890 afd80709
   SHA-256: (0x)e3b0c442 98fc1c14 9afbf4c8 996fb924 27ae41e4 649b934c
                a495991b 7852b855
   SHA-384: (0x)38b060a7 51ac9638 4cd9327e b1b1e36a 21fdb711 14be0743
                4c0cc7bf 63f6e1da 274edebf e76f65fb d51ad2f1 4898b95b
   SHA-512: (0x)cf83e135 7eefb8bd f1542850 d66d8007 d620e405 0b5715dc
                83f4a921 d36ce9ce 47d0d13c 5d85f2b0 ff8318d2 877eec2f
                63b931bd 47417a81 a538327a f927da3e

   __________________________________________________________________

                             +----------+---------+-------+
                        DB = |  lHash   |    PS   |   M   |
                             +----------+---------+-------+
                                            |
                  +----------+              V
                  |   seed   |--> MGF ---> xor
                  +----------+              |
                        |                   |
               +--+     V                   |
               |00|    xor <----- MGF <-----|
               +--+     |                   |
                 |      |                   |
                 V      V                   V
               +--+----------+----------------------------+
         EM =  |00|maskedSeed|          maskedDB          |
               +--+----------+----------------------------+
   __________________________________________________________________
```

그림 1: EME-OAEP 인코딩 작업. lHash는 선택적 레이블 L의 해시입니다. 디코딩 작업은 역단계를 거쳐 M을 복구하고 lHash 및 PS를 확인합니다.

---
### **7.1.2 Decryption operation**

```text
   RSAES-OAEP-DECRYPT (K, C, L)

   Options:
   Hash     hash function (hLen denotes the length in octets of the hash
            function output)
   MGF      mask generation function

   Input:
   K        recipient's RSA private key (k denotes the length in octets
            of the RSA modulus n)
   C        ciphertext to be decrypted, an octet string of length k,
            where k = 2hLen + 2
   L        optional label whose association with the message is to be
            verified; the default value for L, if L is not provided, is
            the empty string

   Output:
   M        message, an octet string of length mLen, where mLen <= k -
            2hLen - 2

   Error: "decryption error"

   Steps:

   1. Length checking:
```

-  ㅏ. L의 길이가 해시 함수의 입력 제한\(SHA-1의 경우 2^61 - 1 옥텟\)보다 큰 경우 "암호 해독 오류"를 출력하고 중지합니다.

-ㄴ. 암호문 C의 길이가 k 옥텟이 아니면 "decryption error"를 출력하고 중지한다.

-  씨. k < 2hLen + 2이면 "decryption error"를 출력하고 중지합니다.

```text
   2.    RSA decryption:
```

ㅏ. 암호문 C를 정수 암호문으로 변환

- 대표 c\(섹션 4.2 참조\):

```text
            c = OS2IP (C).
```

-ㄴ. RSA 개인 키 K와 암호문 표현 c에 RSADP 복호화 프리미티브\(5.1.2절\)를 적용하여 m을 표현하는 정수 메시지를 생성합니다.

```text
            m = RSADP (K, c).
```

- RSADP가 "암호문 대표 범위를 벗어남"\(c \>= n을 의미\)을 출력하면 "암호 해독 오류"를 출력하고 중지합니다.

-  씨. 메시지 표현 m을 길이 k 옥텟의 인코딩된 메시지 EM으로 변환합니다\(섹션 4.1 참조\).

```text
            EM = I2OSP (m, k).

   3. EME-OAEP decoding:
```

-  ㅏ. 레이블 L이 제공되지 않으면 L을 빈 문자열로 둡니다. lHash = Hash\(L\), 길이가 hLen인 옥텟 문자열이라고 가정합니다\(섹션 7.1.1의 참고 참조\).

-ㄴ. 인코딩된 메시지 EM을 단일 옥텟 Y, 길이 hLen의 옥텟 문자열 마스크드Seed, 길이 k - hLen - 1의 옥텟 문자열 마스크드DB로 분리합니다.

```text
            EM = Y || maskedSeed || maskedDB.

      c. Let seedMask = MGF(maskedDB, hLen).

      d. Let seed = maskedSeed \xor seedMask.

      e. Let dbMask = MGF(seed, k - hLen - 1).

      f. Let DB = maskedDB \xor dbMask.
```

-  g. DB를 길이 hLen의 옥텟 문자열 lHash', 16진수 값 0x00의 옥텟으로 구성된 \(비어 있을 수도 있는\) 패딩 문자열 PS, 메시지 M으로 분리합니다.

```text
            DB = lHash' || PS || 0x01 || M.
```

- PS를 M과 분리하기 위한 16진수 값 0x01의 옥텟이 없는 경우, lHash가 lHash'와 같지 않거나, Y가 0이 아닌 경우 "decryption error"를 출력하고 중지합니다. \(아래 참고사항을 참조하세요.\)

4. M 메시지를 출력합니다.

메모. 상대방이 오류 메시지나 타이밍에 따라 3.g 단계에서 서로 다른 오류 조건을 구별할 수 없도록 주의해야 하며, 더 일반적으로는 인코딩된 메시지 EM에 대한 부분적인 정보를 배울 수 없습니다. 그렇지 않으면 상대는 암호문 C의 해독에 대한 유용한 정보를 얻을 수 있으며, 이는 Manger가 관찰한 것과 같은 선택 암호문 공격으로 이어질 수 있습니다\[36\].

---
## **7.2 RSAES-PKCS1-v1_5**

RSAES-PKCS1-v1\_5는 RSAEP 및 RSADP 기본 요소\(섹션 5.1.1 및 5.1.2\)를 EME-PKCS1-v1\_5 인코딩 방법\(섹션 7.2.1의 1단계 및 섹션 7.2.2의 3단계\)과 결합합니다. 이는 PKCS #1 v1.5의 암호화 체계와 수학적으로 동일합니다. RSAES-PKCS1-v1\_5는 최대 k - 11옥텟\(k는 RSA 모듈러스의 옥텟 길이\) 길이의 메시지에 대해 작동할 수 있습니다.

긴 메시지가 암호화될 때 Coppersmith, Franklin, Patarin 및 Reiter로 인한 낮은 지수 RSA에 대한 특정 공격을 방지합니다\(아래 참고 사항의 세 번째 글머리 기호 및 \[10\]; \[14\]에는 향상된 공격이 포함되어 있음\). 일반적으로 무작위로 생성된 키와 달리 임의의 메시지를 암호화하는 데 이 체계를 사용하는 것은 권장되지 않습니다.

합리적인 성공 확률로 해당 일반 텍스트를 모르더라도 유효한 RSAES-PKCS1-v1\_5 암호 텍스트를 생성할 수 있습니다. 이 능력은 \[6\]에 표시된 대로 선택된 암호문 공격에서 악용될 수 있습니다. 따라서 RSAES-PKCS1-v1\_5를 사용하려면 \[6\]에서 발견된 공격을 막기 위해 쉽게 구현 가능한 특정 대책을 취해야 합니다. 일반적인 예로는 인코딩할 데이터에 구조 추가, 해독된 메시지의 PKCS #1 v1.5 적합성\(및 기타 중복성\)에 대한 엄격한 검사, PKCS #1을 기반으로 하는 클라이언트-서버 프로토콜의 오류 메시지 통합 등이 있습니다. v1.5. 이는 모두 효과적인 대응책이 될 수 있으며 PKCS #1 v1.5 기반 프로토콜에 대한 변경을 포함하지 않습니다. 이러한 대책과 기타 대책에 대한 자세한 내용은 \[7\]을 참조하세요. RSAES-PKCS1-v1\_5 및 특정 대책을 사용하는 SSL/TLS 핸드셰이크 프로토콜\[17\]의 보안이 RSA 문제의 변형과 관련될 수 있다는 것이 최근 밝혀졌습니다. 논의는 \[32\]를 참조하세요.

메모. 다음 구절에서는 RSAES-PKCS1-v1\_5 사용과 관련된 몇 가지 보안 권장 사항을 설명합니다. 이 문서 버전 1.5의 권장 사항과 그 사이에 이루어진 암호화 분석의 발전에 따른 새로운 권장 사항이 포함되어 있습니다.

\* 특히 동일한 데이터가 둘 이상의 암호화 프로세스에 입력되는 경우 섹션 7.2.1의 2단계에서 의사 난수 옥텟을 각 암호화 프로세스마다 독립적으로 생성하는 것이 좋습니다. Haastad의 결과\[24\]는 이 권장 사항에 대한 하나의 동기입니다.

\* 섹션 7.2.1의 2단계에서 패딩 문자열 PS는 길이가 최소 8옥텟입니다. 이는 공격자가 가능한 모든 암호화 블록을 시도하여 데이터를 복구하기 어렵게 만드는 공개 키 작업에 대한 보안 조건입니다.

\* 의사 난수 옥텟은 Coppersmith 등의 연구로 인해 공격을 저지하는 데도 도움이 될 수 있습니다. \[10\] \(공격 개선 방법은 \[14\] 참조\) 암호화할 메시지의 크기를 작게 유지하는 경우. 이 공격은 유사한 메시지가 동일한 RSA 공개 키로 암호화된 경우 낮은 지수 RSA에서 작동합니다. 더 구체적으로 말하면 공격의 한 가지 유형에서 RSAEP에 대한 두 입력이 많은 비트\(8/9\)에 동의하고 낮은 지수 RSA\(e = 3\)가 사용되는 경우입니다.

- 둘 다 암호화하려면 공격으로 두 입력을 모두 복구하는 것이 가능할 수도 있습니다. 공격의 또 다른 특징은 RSAEP에 대한 입력의 큰 부분\(2/3\)이 이미 알려진 경우 단일 암호문을 성공적으로 해독하는 것입니다. 일반적인 애플리케이션의 경우 암호화할 메시지는 짧기 때문에\(예: 128비트 대칭 키\) 공격을 활성화할 만큼 두 메시지 간에 알려진 정보가 충분하지 않거나 공통되지 않습니다. 그러나 긴 메시지가 암호화되어 있거나 메시지의 일부가 알려진 경우에는 공격이 문제가 될 수 있습니다. 어쨌든 RSAES-OAEP 방식은 공격을 극복합니다.

---
### **7.2.1 Encryption operation**

```text
   RSAES-PKCS1-V1_5-ENCRYPT ((n, e), M)

   Input:
   (n, e)   recipient's RSA public key (k denotes the length in octets
            of the modulus n)
   M        message to be encrypted, an octet string of length mLen,
            where mLen <= k - 11

   Output:
   C        ciphertext, an octet string of length k

   Error: "message too long"

   Steps:
```

1. 길이 확인: mLen \> k - 11이면 "message too long"을 출력하고 중지합니다.

```text
   2. EME-PKCS1-v1_5 encoding:
```

-  ㅏ. 의사 무작위로 생성된 0이 아닌 옥텟으로 구성된 길이 k - mLen - 3의 옥텟 문자열 PS를 생성합니다. PS의 길이는 최소 8옥텟입니다.

-ㄴ. PS, 메시지 M 및 기타 패딩을 연결하여 길이 k 옥텟의 인코딩된 메시지 EM을 형성합니다.

```text
            EM = 0x00 || 0x02 || PS || 0x00 || M.

   3. RSA encryption:
```

ㅏ. 인코딩된 메시지 EM을 정수 메시지로 변환

- 대표 m\(섹션 4.2 참조\):

```text
            m = OS2IP (EM).
```

-ㄴ. RSAEP 암호화 프리미티브\(5.1.1절\)를 RSA 공개 키\(n, e\)와 메시지 표현 m에 적용하여 c를 표현하는 정수 암호문을 생성합니다.

```text
            c = RSAEP ((n, e), m).
```

-  씨. 암호문 대표 c를 길이 k 옥텟의 암호문 C로 변환합니다\(섹션 4.1 참조\).

```text
               C = I2OSP (c, k).
```

4. 암호문 C를 출력합니다.

---
### **7.2.2 Decryption operation**

```text
   RSAES-PKCS1-V1_5-DECRYPT (K, C)

   Input:
   K        recipient's RSA private key
   C        ciphertext to be decrypted, an octet string of length k,
            where k is the length in octets of the RSA modulus n

   Output:
   M        message, an octet string of length at most k - 11

   Error: "decryption error"

   Steps:
```

1. 길이 확인: 암호문 C의 길이가 k 옥텟이 아닌 경우\(또는 k < 11인 경우\) "복호화 오류"를 출력하고 중지합니다.

```text
   2. RSA decryption:
```

ㅏ. 암호문 C를 정수 암호문으로 변환

- 대표 c\(섹션 4.2 참조\):

```text
            c = OS2IP (C).
```

-ㄴ. RSA 개인 키\(n, d\)와 c를 나타내는 암호문에 RSADP 복호화 프리미티브\(5.1.2절\)를 적용하여 m을 나타내는 정수 메시지를 생성합니다.

```text
            m = RSADP ((n, d), c).
```

- RSADP가 "암호문 대표 범위를 벗어남"\(c \>= n을 의미\)을 출력하면 "암호 해독 오류"를 출력하고 중지합니다.

-  씨. 메시지 표현 m을 길이 k 옥텟의 인코딩된 메시지 EM으로 변환합니다\(섹션 4.1 참조\).

```text
            EM = I2OSP (m, k).
```

3. EME-PKCS1-v1\_5 디코딩: 인코딩된 메시지 EM을 0이 아닌 옥텟과 메시지 M으로 구성된 옥텟 문자열 PS로 분리합니다.

```text
         EM = 0x00 || 0x02 || PS || 0x00 || M.
```

- EM의 첫 번째 옥텟에 16진수 값 0x00이 없는 경우, EM의 두 번째 옥텟에 16진수 값 0x02가 없는 경우, PS를 M과 구분하는 16진수 값 0x00의 옥텟이 없거나 PS의 길이가 더 짧은 경우 8옥텟보다 크면 "decryption error"를 출력하고 중지합니다. \(아래 참고사항을 참조하세요.\)

```text
   4. Output M.
```

메모. 상대방이 오류 메시지나 타이밍으로 3단계의 다양한 오류 조건을 구별할 수 없도록 주의해야 합니다. 그렇지 않으면 상대방이 암호문 C의 해독에 대한 유용한 정보를 얻을 수 있어 Bleichenbacher 공격의 강화된 버전으로 이어질 수 있습니다\[6\]. Manger의 공격 \[36\]과 비교하십시오.

---
## **8. Signature schemes with appendix**

이 문서의 목적에 따라 부록이 있는 서명 체계는 서명 생성 작업과 서명 확인 작업으로 구성됩니다. 여기서 서명 생성 작업은 서명자의 RSA 개인 키가 있는 메시지에서 서명을 생성하고 서명 확인 작업은 서명을 확인합니다. 서명자의 해당 RSA 공개 키를 사용하여 메시지에 표시됩니다. 이러한 유형의 체계로 구성된 서명을 확인하려면 메시지 자체가 필요합니다. 이러한 방식으로 부록이 있는 서명 체계는 이 문서에서 지원되지 않는 메시지 복구가 있는 서명 체계와 구별됩니다.

부록이 포함된 서명 체계는 다양한 응용 프로그램에 사용될 수 있습니다. 예를 들어, 여기에 정의된 부록이 있는 서명 체계는 X.509 인증서에 적합한 서명 알고리즘이 될 것입니다\[28\]. 관련 서명 체계는 PKCS #7\[45\]에서 사용될 수 있지만 기술적인 이유로 현재 버전의 PKCS #7은 해시 함수를 서명 체계에서 분리하는데, 이는 여기에서 수행되는 것과 다릅니다. 자세한 내용은 부록 A.2.3의 참고 사항을 참조하세요.

이 문서에는 RSASSA-PSS 및 RSASSA-PKCS1-v1\_5라는 두 가지 서명 체계\(부록 포함\)가 지정되어 있습니다. RSASSA-PKCS1-v1\_5에 대한 공격은 알려져 있지 않지만 견고성을 높이기 위해 RSASSA-PSS는 새로운 응용 프로그램의 최종 채택에 권장됩니다. RSASSA-PKCS1-v1\_5는 기존 응용 프로그램과의 호환성을 위해 포함되었으며, 여전히 새로운 응용 프로그램에 적합하지만 RSASSA-PSS로의 점진적 전환이 권장됩니다.

여기에 제공된 부록이 있는 서명 체계는 IEEE Std 1363-2000\[26\]에서 사용된 것과 유사한 일반 모델을 따르며, 서명 및 검증 프리미티브를 서명에 대한 인코딩 방법과 결합합니다. 서명 생성 작업은 메시지 인코딩 작업을 메시지에 적용하여 인코딩된 메시지를 생성한 다음 정수 메시지 표현으로 변환합니다. 서명을 생성하기 위해 서명 프리미티브가 메시지 표현에 적용됩니다. 이를 반대로 하면 서명 확인 작업은 서명 확인 기본 요소를 서명에 적용하여 메시지 표현을 복구한 다음 옥텟 문자열로 인코딩된 메시지로 변환합니다. 일치 여부를 확인하기 위해 메시지와 인코딩된 메시지에 확인 작업이 적용됩니다.

인코딩 방법이 결정적\(예: EMSA-PKCS1-v1\_5\)인 경우 확인 작업은 메시지 인코딩 작업을 메시지에 적용하고 결과 인코딩 메시지를 이전에 파생된 인코딩 메시지와 비교할 수 있습니다. 일치하는 것이 있으면 서명이 유효한 것으로 간주됩니다. 방법이 무작위화된 경우\(예: EMSA-PSS\) 일반적으로 검증 작업이 더 복잡합니다. 예를 들어 EMSA-PSS의 검증 작업은 인코딩된 메시지에서 무작위 솔트와 해시 출력을 추출하고 해시 출력, 솔트 및 메시지가 일치하는지 확인합니다. 해시 출력은 메시지와 솔트 측면에서 결정적인 함수입니다.

이 문서에 정의된 부록이 있는 두 가지 서명 체계 모두 서명 생성 및 서명 확인 작업은 서명이 메시지 뒤에 배치되면 "단일 패스" 작업으로 쉽게 구현됩니다. RSASSA-PKCS1-v1\_5의 경우 형식 예는 PKCS #7\[45\]을 참조하세요.

---
## **8.1 RSASSA-PSS**

RSASSA-PSS는 RSASP1 및 RSAVP1 프리미티브를 EMSA-PSS 인코딩 방법과 결합합니다. 이는 IEEE P1363a 초안\[27\]에서 개정된 IFSSA 방식과 호환되며, 여기서 서명 및 검증 프리미티브는 IEEE Std 1363-2000\[26\]에 정의된 IFSP-RSA1 및 IFVP-RSA1이고 메시지 인코딩 방법은 EMSA4입니다. . EMSA4는 옥텟 문자열이 아닌 비트 문자열에서 작동하므로 EMSA-PSS보다 약간 더 일반적입니다. EMSA-PSS는 피연산자, 해시 및 솔트 값이 옥텟 문자열인 경우로 제한되는 EMSA4와 동일합니다.

RSASSA-PSS가 작동할 수 있는 메시지 길이는 EMSA-PSS 인코딩 방법의 기반이 되는 해시 함수에 따라 제한이 없거나 매우 큰 수로 제한됩니다.

e-th 루트 모듈론 계산이 불가능하고 EMSA-PSS의 해시 및 마스크 생성 기능에 적절한 속성이 있다고 가정하면 RSASSA-PSS는 보안 서명을 제공합니다. 이러한 보증은 해시 및 마스크 생성 기능을 블랙박스 또는 무작위 오라클로 간주하는 경우 서명 위조의 어려움이 RSA 기능 반전의 어려움과 직접적으로 관련될 수 있다는 점에서 입증 가능합니다. 보안 증명의 경계는 본질적으로 "엄격"합니다. 즉, RSASSA-PSS에 대한 최고의 위조자의 성공 확률과 실행 시간은 최고의 RSA 반전 알고리즘에 대한 해당 매개변수에 매우 가깝습니다. 자세한 내용은 \[4\]\[13\]\[31\]을 참조하세요.

RSASSA-PKCS1-v1\_5 서명 체계와 달리 해시 함수 식별자는 EMSA-PSS 인코딩된 메시지에 포함되어 있지 않으므로 이론적으로 공격자가 해시 함수와 다른\(잠재적으로 약한\) 해시 함수를 대체하는 것이 가능합니다. 서명자가 선택했습니다. 따라서 EMSA-PSS 마스크 생성 기능은 동일한 해시 함수를 기반으로 하는 것이 좋습니다. 이러한 방식으로 전체 인코딩된 메시지는 해시 함수에 따라 달라지며 상대방이 서명자가 의도한 것과 다른 해시 함수를 대체하기가 어려울 것입니다. 이러한 해시 함수 일치는 해시 함수 대체를 방지하기 위한 목적으로만 수행되며, 해시 함수 대체가 다른 수단으로 해결되는 경우\(예: 검증자가 지정된 해시 함수만 허용하는 경우\) 필요하지 않습니다. 이러한 점에 대한 추가 논의는 \[34\]를 참조하십시오. RSASSA-PSS의 입증 가능한 보안은 메시지에 적용되는 해시 함수와 동일한 마스크 생성 기능의 해시 함수에 의존하지 않습니다.

RSASSA-PSS는 무작위로 생성된 솔트 값을 통합하여 결정론적이기보다는 확률적이라는 점에서 다른 RSA 기반 서명 체계와 다릅니다. 소금 값은 보안을 강화합니다

FDH\(Full Domain Hashing\)와 같은 결정론적 대안보다 "더 엄격한" 보안 증명을 제공하여 계획을 수립합니다. 논의는 \[4\]를 참조하세요. 그러나 무작위성은 보안에 중요하지 않습니다. 무작위 생성이 불가능한 상황에서는 고정된 값이나 시퀀스 번호를 대신 사용할 수 있으며 결과적으로 FDH와 유사한 입증 가능한 보안을 얻을 수 있습니다\[12\].

---
### **8.1.1 Signature generation operation**

```text
   RSASSA-PSS-SIGN (K, M)

   Input:
   K        signer's RSA private key
   M        message to be signed, an octet string

   Output:
   S        signature, an octet string of length k, where k is the
            length in octets of the RSA modulus n

   Errors: "message too long;" "encoding error"

   Steps:
```

1. EMSA-PSS 인코딩: 메시지 M에 EMSA-PSS 인코딩 작업\(섹션 9.1.1\)을 적용하여 비트 길이가 정수 OS2IP\(EM\)\(섹션 4.2 참조\)은 최대 modBits - 1입니다. 여기서 modBits는 RSA 모듈러스 n의 비트 길이입니다.

```text
         EM = EMSA-PSS-ENCODE (M, modBits - 1).
```

- EM의 옥텟 길이는 modBits - 1이 8로 나누어지면 k보다 1 작고 그렇지 않으면 k와 같습니다. 인코딩 작업에서 "메시지가 너무 김"이 출력되면 "메시지가 너무 김"을 출력하고 중지합니다. 인코딩 작업이 "인코딩 오류"를 출력하면 "인코딩 오류"를 출력하고 중지합니다.

```text
   2. RSA signature:
```

ㅏ. 인코딩된 메시지 EM을 정수 메시지로 변환

- 대표 m\(섹션 4.2 참조\):

```text
            m = OS2IP (EM).
```

-ㄴ. RSASP1 서명 프리미티브\(Section 5.2.1\)를 RSA 개인 키 K와 메시지 표현 m에 적용하여 s를 나타내는 정수 서명을 생성합니다.

```text
            s = RSASP1 (K, m).
```

-  씨. 서명 대표 s를 길이 k 옥텟의 서명 S로 변환합니다\(섹션 4.1 참조\).

```text
            S = I2OSP (s, k).
```

3. 서명 S를 출력합니다.

---
### **8.1.2 Signature verification operation**

```text
   RSASSA-PSS-VERIFY ((n, e), M, S)

   Input:
   (n, e)   signer's RSA public key
   M        message whose signature is to be verified, an octet string
   S        signature to be verified, an octet string of length k, where
            k is the length in octets of the RSA modulus n

   Output:
   "valid signature" or "invalid signature"

   Steps:
```

1. 길이 확인: 서명 S의 길이가 k 옥텟이 아닌 경우 "잘못된 서명"을 출력하고 중지합니다.

```text
   2. RSA verification:
```

-  ㅏ. 서명 S를 정수 서명 대표 s로 변환합니다\(섹션 4.2 참조\).

```text
            s = OS2IP (S).
```

-ㄴ. RSAVP1 검증 프리미티브\(Section 5.2.2\)를 RSA 공개 키\(n, e\)와 서명 표현 s에 적용하여 m을 표현하는 정수 메시지를 생성합니다.

```text
            m = RSAVP1 ((n, e), s).
```

- RSAVP1이 "서명 대표가 범위를 벗어났습니다"를 출력하면 "잘못된 서명"을 출력하고 중지합니다.

-  씨. 메시지 표현 m을 길이가 emLen = \ceil \(\(modBits - 1\)/8\) 옥텟인 인코딩된 메시지 EM으로 변환합니다. 여기서 modBits는 RSA 모듈러스 n의 비트 길이입니다\(섹션 4.1 참조\).

```text
            EM = I2OSP (m, emLen).
```

- modBits - 1이 8로 나누어지면 emLen은 k보다 1 작고 그렇지 않으면 k와 같습니다. I2OSP가 "정수가 너무 큼"을 출력하면 "잘못된 서명"을 출력하고 중지합니다.

3. EMSA-PSS 검증: 메시지 M과 인코딩된 메시지 EM에 EMSA-PSS 검증 작업\(섹션 9.1.2\)을 적용하여 일관성이 있는지 확인합니다.

```text
         Result = EMSA-PSS-VERIFY (M, EM, modBits - 1).

   4. If Result = "consistent," output "valid signature." Otherwise,
      output "invalid signature."
```

---
### **8.2. RSASSA-PKCS1-v1_5**

RSASSA-PKCS1-v1\_5는 RSASP1 및 RSAVP1 프리미티브를 EMSA-PKCS1-v1\_5 인코딩 방법과 결합합니다. IEEE Std 1363-2000\[26\]에 정의된 IFSSA 방식과 호환되며 서명 및 검증 프리미티브는 IFSP-RSA1 및 IFVP-RSA1이고 메시지 인코딩 방법은 EMSA-PKCS1-v1\_5\(IEEE에서는 정의되지 않음\)입니다. Std 1363-2000이지만 IEEE P1363a 초안 \[27\]에 있습니다.

RSASSA-PKCS1-v1\_5가 작동할 수 있는 메시지 길이는 EMSA-PKCS1-v1\_5 방법의 기반이 되는 해시 함수에 따라 무제한이거나 매우 큰 수로 제한됩니다.

n번째 루트 계산이 불가능하고 EMSA-PKCS1-v1\_5의 해시 함수에 적절한 속성이 있다고 가정하면 RSASSA-PKCS1-v1\_5는 보안 서명을 제공하는 것으로 추측됩니다. 보다 정확하게는 RSA 개인 키를 모르고 서명을 위조하는 것은 계산상 불가능하다고 추측됩니다. 또한 EMSA-PKCS1-v1\_5 인코딩 방식에는 해시 함수 식별자가 인코딩에 내장되어 있습니다. 이 기능으로 인해 이전에 서명된 메시지와 동일한 서명이 있는 메시지를 찾으려는 공격자는 사용 중인 특정 해시 함수의 충돌을 찾아야 합니다. 서명자가 선택한 것과 다른 해시 함수를 공격하는 것은 적에게 유용하지 않습니다. 자세한 내용은 \[34\]를 참조하세요.

메모. PKCS #1 v1.5에서 설명한 대로 EMSA-PKCS1-v1\_5 인코딩 방법에는 정수 메시지 표현으로 변환된 인코딩된 메시지가 크고 적어도 어느 정도 "무작위"임을 보장하는 속성이 있습니다. 이는 다음과 같은 유형의 공격을 방지합니다.

Desmedt 및 Odlyzko \[16\]에서는 메시지 표현을 작은 값 세트\(예: 작은 소수 세트\)로 인수분해하여 메시지 표현 간의 곱셈 관계를 개발합니다. Coron, Naccache 및 Stern \[15\]은 이러한 유형의 공격의 더 강력한 형태가 ISO/IEC 9796-2 서명 체계의 일부 인스턴스에 대해 매우 효과적일 수 있음을 보여주었습니다. 또한 EMSA-PKCS1-v1\_5 인코딩 방법에 대한 이러한 유형의 공격의 복잡성을 분석하고 공격이 비실용적이며 기본 해시 함수에 대한 충돌 검색보다 더 많은 작업\(즉, 2^80개 이상의 작업\)이 필요하다는 결론을 내렸습니다. . Coppersmith, Halevi 및 Jutla \[11\]는 이후 Coron 등의 공격을 확장하여 메시지 복구를 통해 ISO/IEC 9796-1 서명 체계를 깨뜨렸습니다. 다양한 공격은 특히 메시지 복구 기능이 있는 서명 체계에서 RSA 서명 프리미티브에 대한 입력을 신중하게 구성하는 것의 중요성을 보여줍니다. 따라서 EMSA-PKCS-v1\_5 인코딩 방법은 해시 작업을 명시적으로 포함하며 메시지 복구가 포함된 서명 체계에는 적합하지 않습니다. 또한 EMSA-PKCS-v1\_5 인코딩 방법에 대한 공격은 알려져 있지 않지만 향후 개발에 대한 예방 조치로 EMSA-PSS로 점진적으로 전환하는 것이 좋습니다.

---
### **8.2.1 Signature generation operation**

```text
   RSASSA-PKCS1-V1_5-SIGN (K, M)

   Input:
   K        signer's RSA private key
   M        message to be signed, an octet string

   Output:
   S        signature, an octet string of length k, where k is the
            length in octets of the RSA modulus n

   Errors: "message too long"; "RSA modulus too short"

   Steps:
```

1. EMSA-PKCS1-v1\_5 인코딩: EMSA-PKCS1-v1\_5 인코딩 작업\(9.2절\)을 메시지 M에 적용하여 길이 k 옥텟의 인코딩된 메시지 EM을 생성합니다.

```text
         EM = EMSA-PKCS1-V1_5-ENCODE (M, k).
```

- 인코딩 작업에서 "message too long"이 출력되면 "message too long"을 출력하고 중지합니다. 인코딩 작업에서 "의도한 인코딩 메시지 길이가 너무 짧습니다"라고 출력되면 "RSA 모듈러스가 너무 짧습니다"를 출력하고 중지합니다.

```text
   2. RSA signature:
```

ㅏ. 인코딩된 메시지 EM을 정수 메시지로 변환

- 대표 m\(섹션 4.2 참조\):

```text
            m = OS2IP (EM).
```

-ㄴ. RSASP1 서명 프리미티브\(Section 5.2.1\)를 RSA 개인 키 K와 메시지 표현 m에 적용하여 s를 나타내는 정수 서명을 생성합니다.

```text
            s = RSASP1 (K, m).
```

-  씨. 서명 대표 s를 길이 k 옥텟의 서명 S로 변환합니다\(섹션 4.1 참조\).

```text
            S = I2OSP (s, k).
```

3. 서명 S를 출력합니다.

---
### **8.2.2 Signature verification operation**

```text
   RSASSA-PKCS1-V1_5-VERIFY ((n, e), M, S)

   Input:
   (n, e)   signer's RSA public key
   M        message whose signature is to be verified, an octet string
   S        signature to be verified, an octet string of length k, where
            k is the length in octets of the RSA modulus n

   Output:
   "valid signature" or "invalid signature"

   Errors: "message too long"; "RSA modulus too short"

   Steps:
```

1. 길이 확인: 서명 S의 길이가 k 옥텟이 아닌 경우 "잘못된 서명"을 출력하고 중지합니다.

```text
   2. RSA verification:
```

-  ㅏ. 서명 S를 정수 서명 대표 s로 변환합니다\(섹션 4.2 참조\).

```text
            s = OS2IP (S).
```

-ㄴ. RSAVP1 검증 프리미티브\(Section 5.2.2\)를 RSA 공개 키\(n, e\)와 서명 표현 s에 적용하여 m을 표현하는 정수 메시지를 생성합니다.

```text
            m = RSAVP1 ((n, e), s).
```

- RSAVP1이 "서명 대표가 범위를 벗어났습니다"를 출력하면 "잘못된 서명"을 출력하고 중지합니다.

-  씨. 메시지 표현 m을 길이 k 옥텟의 인코딩된 메시지 EM으로 변환합니다\(섹션 4.1 참조\).

```text
            EM' = I2OSP (m, k).
```

I2OSP가 "정수가 너무 큼"을 출력하는 경우 "invalid"를 출력합니다.

- 서명" 하고 중지하세요.

3. EMSA-PKCS1-v1\_5 인코딩: EMSA-PKCS1-v1\_5 인코딩 작업\(9.2절\)을 메시지 M에 적용하여 길이 k 옥텟의 두 번째 인코딩된 메시지 EM'을 생성합니다.

```text
            EM' = EMSA-PKCS1-V1_5-ENCODE (M, k).
```

- 인코딩 작업에서 "message too long"이 출력되면 "message too long"을 출력하고 중지합니다. 인코딩 작업에서 "의도한 인코딩 메시지 길이가 너무 짧습니다"라고 출력되면 "RSA 모듈러스가 너무 짧습니다"를 출력하고 중지합니다.

```text
   4. Compare the encoded message EM and the second encoded message EM'.
      If they are the same, output "valid signature"; otherwise, output
      "invalid signature."
```

메모. 서명 확인 작업을 구현하는 또 다른 방법은 인코딩된 메시지에 "디코딩" 작업\(이 문서에 지정되지 않음\)을 적용하여 기본 해시 값을 복구한 다음 이를 새로 계산된 해시 값과 비교하는 것입니다. 이는 중간 저장소\(2개의 인코딩된 메시지가 아닌 2개의 해시 값\)가 덜 필요하다는 장점이 있지만 추가 코드가 필요하다는 단점이 있습니다.

---
## **9. Encoding methods for signatures with appendix**

인코딩 방법은 옥텟 문자열 메시지와 옥텟 문자열 인코딩 메시지 사이를 매핑하는 작업으로 구성되며, 이 메시지는 구성표의 정수 메시지 표현으로 변환됩니다. 정수 메시지 표현은 기본 요소를 통해 처리됩니다. 따라서 인코딩 방법은 메시지를 처리하는 체계와 기본 요소 간의 연결을 제공합니다.

본 문서의 목적에 따라 부록이 포함된 서명의 인코딩 방법은 인코딩 작업과 선택적으로 확인 작업으로 구성됩니다. 인코딩 작업은 메시지 M을 지정된 길이의 인코딩된 메시지 EM에 매핑합니다. 검증 동작은 메시지 M과 인코딩된 메시지 EM이 일치하는지, 즉 인코딩된 메시지 EM이 메시지 M의 유효한 인코딩인지 여부를 결정한다.

인코딩 작업은 임의성을 도입할 수 있으므로 동일한 메시지에 대한 인코딩 작업의 서로 다른 적용이 서로 다른 인코딩된 메시지를 생성하게 되며 이는 입증 가능한 보안에 이점이 있습니다. 이러한 인코딩 방법의 경우 검증자가 무작위성을 재현할 수 없으면\(예: 서명자로부터 솔트 값을 얻음\) 인코딩과 검증 작업이 모두 필요합니다. 결정적 인코딩 방법의 경우 인코딩 작업만 필요합니다.

부록이 있는 서명에 대한 두 가지 인코딩 방법이 서명 체계에 사용되며 여기에서 지정됩니다: EMSA-PSS 및 EMSA-PKCS1-v1\_5.

---
## **9.1 EMSA-PSS**

이 인코딩 방법은 해시 함수, 마스크 생성 함수 및 솔트 길이를 선택하여 매개변수화됩니다. 이러한 옵션은 솔트 길이가 가변적일 수 있다는 점을 제외하고는 주어진 RSA 키에 대해 수정되어야 합니다\(논의는 \[31\] 참조\). 제안된 해시 및 마스크 생성 기능은 부록 B에 나와 있습니다. 인코딩 방법은 Bellare와 Rogaway의 PSS\(Probabilistic Signature Scheme\)\[4\]\[5\]를 기반으로 합니다. 무작위로 이루어지며 인코딩 작업과 검증 작업이 있습니다.

그림 2는 인코딩 작업을 보여줍니다.

```text
   __________________________________________________________________

                                  +-----------+
                                  |     M     |
                                  +-----------+
                                        |
                                        V
                                      Hash
                                        |
                                        V
                          +--------+----------+----------+
                     M' = |Padding1|  mHash   |   salt   |
                          +--------+----------+----------+
                                         |
               +--------+----------+     V
         DB =  |Padding2|maskedseed|   Hash
               +--------+----------+     |
                         |               |
                         V               |    +--+
                        xor <--- MGF <---|    |bc|
                         |               |    +--+
                         |               |      |
                         V               V      V
               +-------------------+----------+--+
         EM =  |    maskedDB       |maskedseed|bc|
               +-------------------+----------+--+
   __________________________________________________________________
```

그림 2: EMSA-PSS 인코딩 작업. 검증 작업은 역방향 단계를 거쳐 염을 회수한 다음 전단계를 거쳐 H를 다시 ​​계산하고 비교합니다.

```text
   Notes.
```

1. 여기에 정의된 인코딩 방법은 Bellare와 Rogaway가 IEEE P1363a \[5\]에 제출한 방법과 세 가지 측면에서 다릅니다.

- \* 메시지에 마스크 생성 기능이 아닌 해시 기능을 적용합니다. 마스크 생성 기능은 해시 함수를 기반으로 하지만 직접 해시 함수를 적용하는 것이 더 자연스러워 보입니다.

- \* 솔트 값과 함께 해시되는 값은 문자열 \(0x\)00 00 00 00 00 00 00 00 || 메시지 M 자체가 아닌 mHash입니다. 여기서 mHash는 M의 해시입니다.

- 해시 함수는 두 단계 모두 동일합니다. 자세한 내용은 아래 참고 3을 참조하세요. \(또한 "seed" 대신 "salt"라는 이름이 사용되는데, 이는 값의 역할을 더 잘 반영하기 때문입니다.\)

- \* EMSA-PSS의 인코딩된 메시지에는 9개의 고정 비트가 있습니다. 첫 번째 비트는 0이고 마지막 8비트는 "트레일러 필드"인 옥텟 0xbc를 형성합니다. 원래 방식에서는 첫 번째 비트만 고정됩니다. 트레일러 필드의 이론적 근거는 IEEE Std 1363-2000 \[26\]의 Rabin-Williams IFSP-RW 서명 프리미티브 및 초안 ISO/IEC 9796-2 \[29\]의 해당 프리미티브와의 호환성을 위한 것입니다.

2. 마스크 생성 기능이 해시 함수 기반이라고 가정할 때, 해시 함수는 메시지에 적용되는 것과 동일한 것을 권장한다. 자세한 내용은 섹션 8.1을 참조하세요.

3. RSASSA-PSS에 대한 보안 증명을 손상시키지 않으면서 나머지를 계산하는 모듈 외부에서 EMSA-PSS-ENCODE 및 EMSA-PSS-VERIFY\(메시지에 해시 함수 적용\)의 1단계와 2단계를 수행할 수 있습니다. 메시지 M 자체가 아닌 mHash가 모듈에 입력되도록 서명 작업을 수행합니다. 즉, 상대방이 mHash의 가치를 통제할 수 있더라도 RSASSA-PSS의 보안 증명은 여전히 ​​유효합니다. 이는 모듈\(예: 스마트 카드\)에 제한된 I/O 대역폭이 있는 경우 편리합니다. PSS \[4\]\[5\]의 이전 버전에는 이 속성이 없었습니다. 물론, 다른 보안상의 이유로 모듈이 전체 메시지를 처리하도록 하는 것이 바람직할 수도 있습니다. 예를 들어 모듈은 해시 값을 계산하는 구성 요소를 신뢰하지 않는 경우 서명 내용을 "확인"해야 할 수 있습니다.

4. 옥텟 단위의 일반적인 솔트 길이는 hLen\(해시 함수 Hash의 출력 길이\)과 0입니다. 두 경우 모두 RSASSA-PSS의 보안은 RSAVP1 반전의 경도와 밀접하게 관련될 수 있습니다. Bellare와 Rogaway \[4\]는 원래 RSA-PSS 체계의 보안에 대한 엄격한 하한을 제공하며 이는 대략 전자의 경우에 해당하며 Coron \[12\]은 관련 Full Domain Hashing 체계에 대해 대략적으로 해당하는 하한을 제공합니다. 후자의 경우. \[13\]에서 Coron은 0에서 hLen까지의 다양한 염 길이를 갖는 일반적인 처리를 제공합니다. 논의는 \[27\]을 참조하세요. 위의 참고 1에 나열된 RSA-PSS 원본 버전과 현재 버전 간의 차이점을 해결하기 위해 \[4\]\[13\]의 보안 증명을 조정하는 \[31\]도 참조하세요.

5. IEEE P1363a \[27\]에서 언급한 바와 같이,

- EMSA-PSS의 솔트 값과 같은 서명 체계는 서명되는 메시지 이외의 정보를 전송하기 위한 "비밀 채널"을 제공할 수 있습니다. 비밀 채널에 대한 자세한 내용은 \[50\]을 참조하세요.

---
### **9.1.1 Encoding operation**

```text
   EMSA-PSS-ENCODE (M, emBits)

   Options:

   Hash     hash function (hLen denotes the length in octets of the hash
            function output)
   MGF      mask generation function
   sLen     intended length in octets of the salt

   Input:
   M        message to be encoded, an octet string
   emBits   maximal bit length of the integer OS2IP (EM) (see Section
            4.2), at least 8hLen + 8sLen + 9

   Output:
   EM       encoded message, an octet string of length emLen = \ceil
            (emBits/8)

   Errors:  "encoding error"; "message too long"

   Steps:
```

1. M의 길이가 해시 함수의 입력 제한\(SHA-1의 경우 2^61 - 1 옥텟\)보다 큰 경우 "message too long"을 출력하고 중지합니다.

2. 길이가 hLen인 옥텟 문자열인 mHash = Hash\(M\)로 설정합니다.

3. emLen < hLen + sLen + 2이면 "encoding error"를 출력하고 중지합니다.

4. 길이가 sLen인 무작위 옥텟 스트링 솔트를 생성합니다. sLen = 0이면 salt는 빈 문자열입니다.

```text
   5.  Let
         M' = (0x)00 00 00 00 00 00 00 00 || mHash || salt;
```

- M'은 길이가 8 + hLen + sLen이고 초기 0 옥텟이 8개인 옥텟 문자열입니다.

6. 길이가 hLen인 옥텟 문자열인 H = Hash\(M'\)로 설정합니다.

7. emLen - sLen - hLen - 2개의 0 옥텟으로 구성된 옥텟 문자열 PS를 생성합니다. PS의 길이는 0일 수 있다.

8. DB = PS || 0x01 || 소금; DB는 길이가 emLen - hLen - 1인 옥텟 문자열입니다.

```text
   9.  Let dbMask = MGF(H, emLen - hLen - 1).

   10. Let maskedDB = DB \xor dbMask.
```

11. MaskedDB에서 가장 왼쪽 옥텟의 가장 왼쪽 8emLen - emBits 비트를 0으로 설정합니다.

```text
   12. Let EM = maskedDB || H || 0xbc.

   13. Output EM.
```

---
### **9.1.2 Verification operation**

```text
   EMSA-PSS-VERIFY (M, EM, emBits)

   Options:
   Hash     hash function (hLen denotes the length in octets of the hash
            function output)
   MGF      mask generation function
   sLen     intended length in octets of the salt

   Input:
   M        message to be verified, an octet string
   EM       encoded message, an octet string of length emLen = \ceil
            (emBits/8)
   emBits   maximal bit length of the integer OS2IP (EM) (see Section
            4.2), at least 8hLen + 8sLen + 9

   Output:
   "consistent" or "inconsistent"

   Steps:
```

1. M의 길이가 해시 함수의 입력 제한\(SHA-1의 경우 2^61 - 1 옥텟\)보다 큰 경우 "inconsible"을 출력하고 중지합니다.

2. 길이가 hLen인 옥텟 문자열인 mHash = Hash\(M\)로 설정합니다.

3. emLen < hLen + sLen + 2인 경우 "inconsilient"를 출력하고 중지합니다.

4. EM의 가장 오른쪽 옥텟에 16진수 값 0xbc가 없으면 "inconsistant"를 출력하고 중지합니다.

5. MaskedDB를 EM의 가장 왼쪽 emLen - hLen - 1 옥텟으로 두고 H를 다음 hLen 옥텟으로 둡니다.

6. MaskedDB에서 가장 왼쪽 8emLen - 가장 왼쪽 옥텟의 emBits 비트가 모두 0이 아닌 경우 "inconsible"을 출력하고 중지합니다.

```text
   7.  Let dbMask = MGF(H, emLen - hLen - 1).

   8.  Let DB = maskedDB \xor dbMask.
```

9. DB에서 가장 왼쪽 옥텟의 가장 왼쪽 8emLen - emBits 비트를 0으로 설정합니다.

10. DB의 emLen - hLen - sLen - 2 가장 왼쪽 옥텟이 0이 아니거나 emLen - hLen - sLen - 1 위치\(가장 왼쪽 위치가 "위치 1"\)의 옥텟에 16진수 값 0x01이 없는 경우 " 불일치"라고 말하고 중지합니다.

11. 솔트를 DB의 마지막 sLen 옥텟으로 둡니다.

```text
   12.  Let
            M' = (0x)00 00 00 00 00 00 00 00 || mHash || salt ;
```

- M'은 길이가 8 + hLen + sLen이고 초기 0 옥텟이 8개인 옥텟 문자열입니다.

13. 길이가 hLen인 옥텟 문자열인 H' = Hash\(M'\)라고 가정합니다.

```text
   14. If H = H', output "consistent." Otherwise, output "inconsistent."
```

---
## **9.2 EMSA-PKCS1-v1_5**

이 인코딩 방법은 결정적이며 인코딩 작업만 포함합니다.

```text
   EMSA-PKCS1-v1_5-ENCODE (M, emLen)

   Option:
   Hash     hash function (hLen denotes the length in octets of the hash
            function output)

   Input:
   M        message to be encoded
   emLen    intended length in octets of the encoded message, at least
            tLen + 11, where tLen is the octet length of the DER
            encoding T of a certain value computed during the encoding
            operation

   Output:
   EM       encoded message, an octet string of length emLen

   Errors:
   "message too long"; "intended encoded message length too short"

   Steps:
```

1. 메시지 M에 해시 함수를 적용하여 해시 값 H를 생성합니다.

```text
         H = Hash(M).
```

- 해시 함수가 "메시지가 너무 김"을 출력하는 경우 "메시지가 너무 김"을 출력하고 중지합니다.

2. 해시 함수에 대한 알고리즘 ID와 해시 값을 DER\(Distinguished Encoding Rules\)을 사용하여 DigestInfo 유형\(부록 A.2.4 참조\)의 ASN.1 값으로 인코딩합니다. 여기서 DigestInfo 유형은 다음 구문을 갖습니다.

```text
      DigestInfo ::= SEQUENCE {
          digestAlgorithm AlgorithmIdentifier,
          digest OCTET STRING
      }
```

- 첫 번째 필드는 해시 함수를 식별하고 두 번째 필드는 해시 값을 포함합니다. T를 DigestInfo 값의 DER 인코딩\(아래 참고 사항 참조\)으로 설정하고 tLen을 T의 옥텟 길이로 설정합니다.

3. emLen < tLen + 11인 경우 "의도된 인코딩된 메시지 길이가 너무 짧음"을 출력하고 중지합니다.

4. 16진수 값 0xff를 갖는 emLen - tLen - 3옥텟으로 구성된 옥텟 문자열 PS를 생성합니다. PS의 길이는 최소 8옥텟입니다.

5. PS, DER 인코딩 T 및 기타 패딩을 연결하여 인코딩된 메시지 EM을 다음과 같이 형성합니다.

```text
         EM = 0x00 || 0x01 || PS || 0x00 || T.

   6. Output EM.

   Notes.
```

1. 부록 B.1에 언급된 6가지 해시 함수의 경우 DigestInfo 값의 DER 인코딩 T는 다음과 같습니다.

```text
      MD2:     (0x)30 20 30 0c 06 08 2a 86 48 86 f7 0d 02 02 05 00 04
                   10 || H.
      MD5:     (0x)30 20 30 0c 06 08 2a 86 48 86 f7 0d 02 05 05 00 04
                   10 || H.
      SHA-1:   (0x)30 21 30 09 06 05 2b 0e 03 02 1a 05 00 04 14 || H.
      SHA-256: (0x)30 31 30 0d 06 09 60 86 48 01 65 03 04 02 01 05 00
                   04 20 || H.
      SHA-384: (0x)30 41 30 0d 06 09 60 86 48 01 65 03 04 02 02 05 00
                   04 30 || H.
      SHA-512: (0x)30 51 30 0d 06 09 60 86 48 01 65 03 04 02 03 05 00
                      04 40 || H.
```

2. 이 문서의 버전 1.5에서는 T가 BER로 정의되었습니다.

- DigestInfo 값의 DER 인코딩이 아닌 인코딩. 특히, 적어도 이론상으로는 이 문서\(및 버전 2.0\)에 정의된 확인 작업이 PKCS #1 v1.5에 제공된 사양과 관련하여 유효한 서명을 거부하는 것이 가능합니다. 이는 DER 이외의 다른 규칙이 DigestInfo\(예: 기본 SEQUENCE 유형의 무한 길이 인코딩\)에 적용되는 경우 발생합니다. 이것이 실제로 문제가 될 가능성은 없지만 신중한 구현자는 PKCS #1 v1.5에 지정된 대로 BER 디코딩 작업을 기반으로 검증 작업을 사용하도록 선택할 수 있습니다. 이러한 방식으로 PKCS #1 v1.5를 기반으로 하는 모든 유효한 구현과의 호환성이 확보됩니다. 이러한 검증 작업은 기본 BER 인코딩이 DER 인코딩인지 여부와 서명이 이 문서에 제공된 사양과 관련하여 유효한지 여부를 나타내야 합니다.

---
# **Appendix A. ASN.1 syntax**
---
## **A.1 RSA key representation**

이 섹션에서는 RSA 공개 및 개인 키에 대한 ASN.1 개체 식별자를 정의하고 RSAPublicKey 및 RSAPrivateKey 유형을 정의합니다. 이러한 정의의 의도된 적용에는 X.509 인증서, PKCS #8 \[46\] 및 PKCS #12 \[47\]가 포함됩니다.

객체 식별자 rsaEncryption은 부록 A.1.1 및 A.1.2에 정의된 대로 RSA 공개 키와 개인 키를 식별합니다. AlgorithmIdentifier 유형의 값에서 이 OID와 연관된 매개변수 필드는 NULL 유형의 값을 가져야 합니다.

```text
   rsaEncryption    OBJECT IDENTIFIER ::= { pkcs-1 1 }
```

이 섹션의 정의는 다중 프라임 RSA를 지원하도록 확장되었지만 이전 버전과도 호환됩니다.

---
### **A.1.1 RSA public key syntax**

RSA 공개 키는 ASN.1 유형 RSAPublicKey로 표시되어야 합니다.

```text
      RSAPublicKey ::= SEQUENCE {
          modulus           INTEGER,  -- n
          publicExponent    INTEGER   -- e
      }
```

RSAPublicKey 유형의 필드에는 다음과 같은 의미가 있습니다.

\* 모듈러스는 RSA 모듈러스 n입니다.

\* publicExComponent는 RSA 공개 지수 e입니다.

---
### **A.1.2 RSA private key syntax**

RSA 개인 키는 ASN.1 유형 RSAPrivateKey로 표시되어야 합니다.

```text
      RSAPrivateKey ::= SEQUENCE {
          version           Version,
          modulus           INTEGER,  -- n
          publicExponent    INTEGER,  -- e
          privateExponent   INTEGER,  -- d
          prime1            INTEGER,  -- p
          prime2            INTEGER,  -- q
          exponent1         INTEGER,  -- d mod (p-1)
          exponent2         INTEGER,  -- d mod (q-1)
          coefficient       INTEGER,  -- (inverse of q) mod p
          otherPrimeInfos   OtherPrimeInfos OPTIONAL
      }
```

RSAPrivateKey 유형의 필드는 다음과 같은 의미를 갖습니다.

\* 버전은 이 문서의 향후 개정판과의 호환성을 위한 버전 번호입니다. 이 버전의 문서에서는 0이 되어야 합니다. 단, 다중 소수가 사용되지 않는 경우에는 1이 됩니다.

```text
            Version ::= INTEGER { two-prime(0), multi(1) }
               (CONSTRAINED BY
               {-- version must be multi if otherPrimeInfos present --})
```

\* 모듈러스는 RSA 모듈러스 n입니다.

\* publicExComponent는 RSA 공개 지수 e입니다.

\* privateExComponent는 RSA 개인 지수입니다. d.

\* prime1은 n의 소인수 p입니다.

\* prime2는 n의 소인수 q입니다.

\* 지수1은 d mod\(p - 1\)입니다.

\* 지수2는 d mod\(q - 1\)입니다.

\* 계수는 CRT 계수 q^\(-1\) mod p입니다.

\* otherPrimeInfos에는 추가 소수 r\_3, ..., r\_u에 대한 정보가 순서대로 포함되어 있습니다. 버전이 0이면 생략되고 버전이 1이면 최소한 하나의 OtherPrimeInfo 인스턴스를 포함해야 합니다.

- OtherPrimeInfos ::= OtherPrimeInfo의 시퀀스 크기\(1..MAX\)

```text
         OtherPrimeInfo ::= SEQUENCE {
             prime             INTEGER,  -- ri
             exponent          INTEGER,  -- di
             coefficient       INTEGER   -- ti
         }
```

OtherPrimeInfo 유형의 필드에는 다음과 같은 의미가 있습니다.

\* 소수는 n의 소인수 r\_i입니다. 여기서 i \>= 3입니다.

\* 지수는 d\_i = d mod \(r\_i - 1\)입니다.

\* 계수는 CRT 계수입니다. t\_i = \(r\_1 \* r\_2 \* ... \* r\_\(i- 1\)\)^\(-1\) mod r\_i.

메모. 공개 및 수정으로부터 RSA 개인 키를 보호하는 것이 중요합니다. 이러한 보호 기술은 이 문서의 범위를 벗어납니다. 개인 키 및 기타 암호화 데이터를 저장하고 배포하는 방법은 PKCS #12 및 #15에 설명되어 있습니다.

---
## **A.2 Scheme identification**

이 섹션에서는 암호화 및 서명 체계에 대한 개체 식별자를 정의합니다. PKCS #1 v1.5와 호환되는 구성표는 PKCS #1 v1.5와 동일한 정의를 갖습니다. 이러한 정의의 의도된 적용에는 X.509 인증서 및 PKCS #7이 포함됩니다.

다음은 PKCS #1 OID에 대한 유형 식별자 정의입니다.

```text
      PKCS1Algorithms    ALGORITHM-IDENTIFIER ::= {
          { OID rsaEncryption              PARAMETERS NULL } |
          { OID md2WithRSAEncryption       PARAMETERS NULL } |
          { OID md5WithRSAEncryption       PARAMETERS NULL } |
          { OID sha1WithRSAEncryption      PARAMETERS NULL } |
          { OID sha256WithRSAEncryption    PARAMETERS NULL } |
          { OID sha384WithRSAEncryption    PARAMETERS NULL } |
          { OID sha512WithRSAEncryption    PARAMETERS NULL } |
          { OID id-RSAES-OAEP PARAMETERS RSAES-OAEP-params } |
          PKCS1PSourceAlgorithms                             |
          { OID id-RSASSA-PSS PARAMETERS RSASSA-PSS-params } ,
          ...  -- Allows for future expansion --
      }
```

---
### **A.2.1 RSAES-OAEP**

객체 식별자 id-RSAES-OAEP는 RSAES-OAEP 암호화 체계를 식별합니다.

```text
      id-RSAES-OAEP    OBJECT IDENTIFIER ::= { pkcs-1 7 }
```

AlgorithmIdentifier 유형의 값에서 이 OID와 연관된 매개변수 필드는 RSAES-OAEP-params 유형의 값을 가져야 합니다.

```text
      RSAES-OAEP-params ::= SEQUENCE {
          hashAlgorithm     [0] HashAlgorithm    DEFAULT sha1,
          maskGenAlgorithm  [1] MaskGenAlgorithm DEFAULT mgf1SHA1,
          pSourceAlgorithm  [2] PSourceAlgorithm DEFAULT pSpecifiedEmpty
      }
```

RSAES-OAEP-params 유형의 필드는 다음과 같은 의미를 갖습니다.

\* hashAlgorithm은 해시 함수를 식별합니다. 이는 OAEP-PSSDigestAlgorithms 세트에 OID가 있는 알고리즘 ID여야 합니다. 지원되는 해시 함수에 대한 설명은 부록 B.1을 참조하세요.

```text
         HashAlgorithm ::= AlgorithmIdentifier {
            {OAEP-PSSDigestAlgorithms}
         }

         OAEP-PSSDigestAlgorithms    ALGORITHM-IDENTIFIER ::= {
             { OID id-sha1 PARAMETERS NULL   }|
             { OID id-sha256 PARAMETERS NULL }|
             { OID id-sha384 PARAMETERS NULL }|
             { OID id-sha512 PARAMETERS NULL },
             ...  -- Allows for future expansion --
         }
```

- 기본 해시 함수는 SHA-1입니다.

```text
         sha1    HashAlgorithm ::= {
             algorithm   id-sha1,
             parameters  SHA1Parameters : NULL
         }

         SHA1Parameters ::= NULL
```

\* MaskGenAlgorithm은 마스크 생성 기능을 식별합니다. 이는 PKCS1MGFAlgorithms 세트의 OID를 갖는 알고리즘 ID여야 하며, 이 버전의 경우 MGF1 마스크 생성 기능을 식별하는 id-mgf1로 구성됩니다\(부록 B.2.1 참조\). id-mgf1과 연관된 매개변수 필드

집합에 OID가 있는 알고리즘 ID여야 합니다.

- OAEP-PSSDigestAlgorithms, MGF1의 기반이 되는 해시 함수를 식별합니다.

```text
         MaskGenAlgorithm ::= AlgorithmIdentifier {
            {PKCS1MGFAlgorithms}
         }
         PKCS1MGFAlgorithms    ALGORITHM-IDENTIFIER ::= {
             { OID id-mgf1 PARAMETERS HashAlgorithm },
             ...  -- Allows for future expansion --
         }
```

- 기본 마스크 생성 기능은 SHA-1이 포함된 MGF1입니다.

```text
         mgf1SHA1    MaskGenAlgorithm ::= {
             algorithm   id-mgf1,
             parameters  HashAlgorithm : sha1
         }
```

\* pSourceAlgorithm은 레이블 L의 소스\(및 값\)를 식별합니다. 이는 PKCS1PSourceAlgorithms 세트의 OID가 있는 알고리즘 ID여야 하며, 이 버전의 경우 레이블이 명시적으로 지정되었음을 나타내는 id-pSpecified로 구성됩니다. id-pSpecified와 연관된 매개변수 필드는 레이블을 포함하는 OCTET STRING 유형의 값을 가져야 합니다. 이 사양의 이전 버전에서는 "레이블" 대신 "인코딩 매개변수"라는 용어가 사용되었으므로 아래 유형의 이름이 사용되었습니다.

```text
         PSourceAlgorithm ::= AlgorithmIdentifier {
            {PKCS1PSourceAlgorithms}
         }

         PKCS1PSourceAlgorithms    ALGORITHM-IDENTIFIER ::= {
             { OID id-pSpecified PARAMETERS EncodingParameters },
             ...  -- Allows for future expansion --
         }

         id-pSpecified    OBJECT IDENTIFIER ::= { pkcs-1 9 }

         EncodingParameters ::= OCTET STRING(SIZE(0..MAX))
```

- 기본 레이블은 빈 문자열입니다\(따라서 lHash에는 빈 문자열의 해시가 포함됩니다\).

```text
         pSpecifiedEmpty    PSourceAlgorithm ::= {
             algorithm   id-pSpecified,
             parameters  EncodingParameters : emptyString
         }

         emptyString    EncodingParameters ::= ''H
```

- RSAES-OAEP-params에 있는 필드의 모든 기본값이 사용되는 경우 알고리즘 식별자는 다음 값을 갖습니다.

```text
         rSAES-OAEP-Default-Identifier  RSAES-AlgorithmIdentifier ::= {
             algorithm   id-RSAES-OAEP,
             parameters  RSAES-OAEP-params : {
                 hashAlgorithm       sha1,
                 maskGenAlgorithm    mgf1SHA1,
                 pSourceAlgorithm    pSpecifiedEmpty
             }
         }

         RSAES-AlgorithmIdentifier ::= AlgorithmIdentifier {
            {PKCS1Algorithms}
         }
```

---
### **A.2.2 RSAES-PKCS1-v1_5**

객체 식별자 rsaEncryption\(부록 A.1 참조\)은 RSAES-PKCS1-v1\_5 암호화 체계를 식별합니다. AlgorithmIdentifier 유형의 값에서 이 OID와 연관된 매개변수 필드는 NULL 유형의 값을 가져야 합니다. 이는 PKCS #1 v1.5와 동일합니다.

```text
      rsaEncryption    OBJECT IDENTIFIER ::= { pkcs-1 1 }
```

---
### **A.2.3 RSASSA-PSS**

개체 식별자 id-RSASSA-PSS는 RSASSA-PSS 암호화 체계를 식별합니다.

```text
      id-RSASSA-PSS    OBJECT IDENTIFIER ::= { pkcs-1 10 }
```

AlgorithmIdentifier 유형의 값에서 이 OID와 연관된 매개변수 필드는 RSASSA-PSS-params 유형의 값을 가져야 합니다.

```text
      RSASSA-PSS-params ::= SEQUENCE {
          hashAlgorithm      [0] HashAlgorithm    DEFAULT sha1,
          maskGenAlgorithm   [1] MaskGenAlgorithm DEFAULT mgf1SHA1,
          saltLength         [2] INTEGER          DEFAULT 20,
          trailerField       [3] TrailerField     DEFAULT trailerFieldBC
      }
```

RSASSA-PSS-params 유형의 필드는 다음과 같은 의미를 갖습니다.

\* hashAlgorithm은 해시 함수를 식별합니다. 이는 OAEP-PSSDigestAlgorithms 세트의 OID를 갖는 알고리즘 ID입니다\(부록 A.2.1 참조\). 기본 해시 함수는 SHA-1입니다.

\* MaskGenAlgorithm은 마스크 생성 기능을 식별합니다. 집합에 OID가 포함된 알고리즘 ID여야 합니다.

- PKCS1MGFAlgorithms\(부록 A.2.1 참조\) 기본 마스크 생성 기능은 SHA-1이 포함된 MGF1입니다. MGF1의 경우\(더 일반적으로는 해시 함수를 기반으로 하는 다른 마스크 생성 함수의 경우\) 기본 해시 함수가 hashAlgorithm으로 식별된 것과 동일한 것이 권장됩니다. 추가 설명은 섹션 9.1의 참고 2를 참조하십시오.

\* saltLength는 솔트의 옥텟 길이입니다. 정수이어야 한다. 지정된 hashAlgorithm의 경우 saltLength의 기본값은 해시 값의 옥텟 길이입니다. RSASSA-PSS-params 유형의 다른 필드와 달리 saltLength는 지정된 RSA 키 쌍에 대해 수정될 필요가 없습니다.

\* trailField는 IEEE P1363a 초안 \[27\]과의 호환성을 위한 트레일러 필드 번호입니다. 이 문서 버전에서는 16진수 값 0xbc를 갖는 트레일러 필드를 나타내는 1이 됩니다. 다른 트레일러 필드\(IEEE P1363a의 트레일러 필드 HashID || 0xcc 포함\)는 이 문서에서 지원되지 않습니다.

```text
         TrailerField ::= INTEGER { trailerFieldBC(1) }
```

- RSASSA-PSS-params의 hashAlgorithm, MaskGenAlgorithm 및 trailField 필드의 기본값이 사용되는 경우 알고리즘 식별자는 다음 값을 갖습니다.

```text
         rSASSA-PSS-Default-Identifier  RSASSA-AlgorithmIdentifier ::= {
             algorithm   id-RSASSA-PSS,
             parameters  RSASSA-PSS-params : {
                 hashAlgorithm       sha1,
                 maskGenAlgorithm    mgf1SHA1,
                 saltLength          20,
                 trailerField        trailerFieldBC
             }
         }

         RSASSA-AlgorithmIdentifier ::=
             AlgorithmIdentifier { {PKCS1Algorithms} }
```

메모. 일부 응용 프로그램에서는 서명 체계의 기본 해시 함수가 서명 체계의 나머지 작업과 별도로 식별됩니다. 예를 들어, PKCS #7\[45\]에서는 해시 함수 식별자가 메시지 앞에 배치되고 "다이제스트 암호화" 알고리즘 식별자\(나머지 작업을 나타냄\)가 서명과 함께 전달됩니다. PKCS #7이 RSASSA-PSS 서명 체계를 지원하려면 해시 함수 다음에 RSASSA-PSS의 작업에 대해 개체 식별자를 정의해야 합니다\(RSASSA-PKCS1-v1\_5 체계의 RSAEncryption OID와 유사\). S/MIME CMS\[25\]는 다른 접근 방식을 취합니다. 해시 함수 식별자가 메시지 앞에 배치되더라도 전체 서명 체계에 대한 알고리즘 식별자는 CMS 서명과 함께 전달될 수 있습니다\(DSA 서명의 경우 수행됨\). 이 규칙에 따라 id-RSASSA-PSS OID를 사용하여 CMS에서 RSASSA-PSS 서명을 식별할 수 있습니다. CMS는 PKCS #7의 후속 버전으로 간주되고 RSASSA-PSS에 대한 지원 추가와 같은 새로운 개발이 PKCS #7이 아닌 CMS에 대해 추진될 예정이므로 "나머지" RSASSA-PSS에 대한 OID는 정의되지 않습니다. 이 버전의 PKCS #1에서는.

---
### **A.2.4 RSASSA-PKCS1-v1_5**

RSASSA-PKCS1-v1\_5의 객체 식별자는 다음 중 하나입니다. OID 선택은 해시 알고리즘 선택\(MD2, MD5, SHA-1, SHA-256, SHA-384 또는 SHA-512\)에 따라 달라집니다. MD2 또는 MD5를 사용하는 경우 OID는 PKCS #1 v1.5와 동일합니다. 각 OID에 대해 AlgorithmIdentifier 유형의 값에서 이 OID와 연관된 매개변수 필드는 NULL 유형의 값을 가져야 합니다. OID는 다음 표에 따라 선택해야 합니다.

```text
      Hash algorithm   OID
      --------------------------------------------------------
      MD2              md2WithRSAEncryption    ::= {pkcs-1 2}
      MD5              md5WithRSAEncryption    ::= {pkcs-1 4}
      SHA-1            sha1WithRSAEncryption   ::= {pkcs-1 5}
      SHA-256          sha256WithRSAEncryption ::= {pkcs-1 11}

      SHA-384          sha384WithRSAEncryption ::= {pkcs-1 12}
      SHA-512          sha512WithRSAEncryption ::= {pkcs-1 13}
```

EMSA-PKCS1-v1\_5 인코딩 방법에는 DigestInfo 유형의 ASN.1 값이 포함되어 있습니다. 여기서 DigestInfo 유형에는 다음 구문이 있습니다.

```text
      DigestInfo ::= SEQUENCE {
          digestAlgorithm DigestAlgorithm,
          digest OCTET STRING
      }
```

DigestAlgorithm은 해시 함수를 식별하며 PKCS1-v1-5DigestAlgorithms 세트의 OID가 있는 알고리즘 ID여야 합니다. 지원되는 해시 함수에 대한 설명은 부록 B.1을 참조하세요.

```text
      DigestAlgorithm ::=
          AlgorithmIdentifier { {PKCS1-v1-5DigestAlgorithms} }

      PKCS1-v1-5DigestAlgorithms    ALGORITHM-IDENTIFIER ::= {
          { OID id-md2 PARAMETERS NULL    }|
          { OID id-md5 PARAMETERS NULL    }|
          { OID id-sha1 PARAMETERS NULL   }|
          { OID id-sha256 PARAMETERS NULL }|
          { OID id-sha384 PARAMETERS NULL }|
          { OID id-sha512 PARAMETERS NULL }
      }
```

---
# **Appendix B. Supporting techniques**

이 섹션에서는 섹션 7의 암호화 체계와 섹션 9의 인코딩 방법을 지원하는 기본 기능의 몇 가지 예를 제공합니다. 여기에는 기존 애플리케이션과의 호환성 및 새로운 기술로의 마이그레이션을 허용하는 다양한 기술이 제공됩니다. 이러한 지원 기술은 애플리케이션을 구현하는 데 적합하지만 어느 것도 구현해야 하는 것은 아닙니다. 특정 지원 기술을 지정하는 PKCS #1 v2.1용 프로필이 개발될 것으로 예상됩니다.

이 섹션에서는 지원 기술에 대한 개체 식별자도 제공합니다.

---
## **B.1 Hash functions**

해시 함수는 섹션 7과 9에 포함된 작업에 사용됩니다. 해시 함수는 결정적입니다. 즉, 출력이 입력에 의해 완전히 결정된다는 의미입니다. 해시 함수는 가변 길이의 옥텟 문자열을 사용하고 고정 길이 옥텟 문자열을 생성합니다.

섹션 7과 9에 포함된 작업에 사용되는 해시 함수는 일반적으로 충돌 방지 기능을 갖추어야 합니다. 이는 동일한 출력을 생성하는 해시 함수에 대한 두 개의 서로 다른 입력을 찾는 것이 불가능하다는 것을 의미합니다. 충돌 방지 해시 함수는 단방향이라는 바람직한 속성도 가지고 있습니다. 이는 출력이 주어지면 해시가 지정된 출력인 입력을 찾는 것이 불가능하다는 것을 의미합니다. 요구 사항 외에도 해시 함수는 의사 난수 출력이 있는 마스크 생성 함수\(부록 B.2\)를 생성해야 합니다.

본 문서에서는 인코딩 방법에 대한 예로 MD2 \[33\], MD5 \[41\], SHA-1 \[38\]과 제안된 알고리즘 SHA-256, SHA-384, SHA-512 \[39\] 등 6가지 해시 함수를 제시합니다. \]. RSAES-OAEP 암호화 방식 및 EMSA-PSS 인코딩 방법의 경우 SHA-1 및 SHA-256/384/512만 권장됩니다. EMSA-PKCS1-v1\_5 인코딩 방법의 경우 새로운 애플리케이션에는 SHA-1 또는 SHA-256/384/512가 권장됩니다. MD2 및 MD5는 PKCS #1 v1.5를 기반으로 하는 기존 응용 프로그램과의 호환성을 위해서만 권장됩니다.

객체 식별자 id-md2, id-md5, id-sha1, id-sha256, id-sha384 및 id-sha512는 각각의 해시 함수를 식별합니다.

```text
      id-md2      OBJECT IDENTIFIER ::= {
          iso(1) member-body(2) us(840) rsadsi(113549)
          digestAlgorithm(2) 2
      }

      id-md5      OBJECT IDENTIFIER ::= {
          iso(1) member-body(2) us(840) rsadsi(113549)
          digestAlgorithm(2) 5
      }

      id-sha1    OBJECT IDENTIFIER ::= {
          iso(1) identified-organization(3) oiw(14) secsig(3)
          algorithms(2) 26
      }

      id-sha256    OBJECT IDENTIFIER ::= {
          joint-iso-itu-t(2) country(16) us(840) organization(1)
          gov(101) csor(3) nistalgorithm(4) hashalgs(2) 1
      }

      id-sha384    OBJECT IDENTIFIER ::= {
          joint-iso-itu-t(2) country(16) us(840) organization(1)
          gov(101) csor(3) nistalgorithm(4) hashalgs(2) 2
      }

      id-sha512    OBJECT IDENTIFIER ::= {
          joint-iso-itu-t(2) country(16) us(840) organization(1)
          gov(101) csor(3) nistalgorithm(4) hashalgs(2) 3
      }
```

AlgorithmIdentifier 유형의 값에서 id-md2 및 id-md5와 연관된 매개변수 필드는 NULL 유형의 값을 가져야 합니다.

id-sha1, id-sha256, id-sha384 및 id-sha512와 관련된 매개변수 필드는 생략되어야 하지만, 있는 경우 NULL 유형의 값을 가져야 합니다.

메모. PKCS #1 버전 1.5에서는 서명 체계에 MD4를 사용할 수도 있습니다. MD4의 암호 분석은 그 사이에 크게 발전했습니다. 예를 들어 Dobbertin\[18\]은 MD4에 대한 충돌을 찾는 방법과 MD4의 처음 두 라운드가 단방향이 아니라는 것을 보여주었습니다\[20\]. 이러한 결과와 기타 결과\(예: \[8\]\)로 인해 MD4는 더 이상 권장되지 않습니다. MD2 및 MD5의 암호 분석도 발전했지만 기존 응용 프로그램에서 제거할 만큼 충분하지는 않습니다. Rogier와 Chauvaud \[43\]는 수정된 MD2 버전에서 충돌을 찾는 방법을 시연했습니다. 부분적인 결과가 발견되었지만\(예: \[9\]\[19\]\) 전체 MD5 알고리즘에 대한 충돌을 찾는 방법을 아무도 보여주지 않았습니다.

이러한 문제를 해결하기 위해 새로운 애플리케이션에는 SHA-1, SHA-256, SHA-384 또는 SHA-512가 권장됩니다. 현재 이러한 해시 함수에 대한 가장 잘 알려진 충돌 공격은 복잡도가 2^\(L/2\)인 일반 공격입니다. 여기서 L은 해시 출력의 비트 길이입니다. 이 문서의 서명 체계의 경우 충돌 공격은 서명 위조로 쉽게 변환됩니다. 따라서 L/2 값은 최소한 서명 체계의 비트 단위로 원하는 보안 수준과 같아야 합니다\(B 비트의 보안 수준은 최상의 공격이 2^B 복잡도를 갖는다는 것을 의미합니다\). RSAES-OAEP에도 동일한 경험 법칙을 적용할 수 있습니다. 시드의 비트 길이\(해시 출력의 비트 길이와 동일\)는 원하는 보안 수준\(비트\)의 두 배인 것이 좋습니다.

---
## **B.2 Mask generation functions**

마스크 생성 기능은 가변 길이의 옥텟 문자열과 원하는 출력 길이를 입력으로 받아 원하는 길이의 옥텟 문자열을 출력합니다. 입력 및 출력 옥텟 문자열의 길이에 제한이 있을 수 있지만 일반적으로 이러한 범위는 매우 큽니다. 마스크 생성 기능은 결정적입니다. 옥텟 문자열 출력은 입력 옥텟 문자열에 의해 완전히 결정됩니다. 마스크 생성 함수의 출력은 의사 난수여야 합니다. 입력이 아닌 출력의 한 부분이 주어지면 다음을 수행하는 것이 불가능해야 합니다.

출력의 다른 부분을 예측합니다. RSAES-OAEP 및 RSASSA-PSS의 입증 가능한 보안은 마스크 생성 기능 출력의 무작위 특성에 의존하며, 이는 다시 기본 해시의 무작위 특성에 의존합니다.

여기에 하나의 마스크 생성 함수가 제공됩니다: MGF1은 해시 함수를 기반으로 합니다. MGF1은 IEEE Std 1363-2000 \[26\] 및 ANSI X9.44 초안 \[1\]에 정의된 마스크 생성 기능과 일치합니다. 이 문서의 향후 버전에서는 다른 마스크 생성 기능을 정의할 수 있습니다.

---
### **B.2.1 MGF1**

MGF1은 해시 함수 기반의 마스크 생성 함수입니다.

```text
   MGF1 (mgfSeed, maskLen)

   Options:
   Hash     hash function (hLen denotes the length in octets of the hash
            function output)
```

입력: 마스크가 생성되는 mgfSeed 시드, 옥텟 문자열 마스크Len 의도된 마스크 옥텟 길이, 최대 2^32 hLen

```text
   Output:
   mask     mask, an octet string of length maskLen

   Error:   "mask too long"

   Steps:
```

1. MaskLen \> 2^32 hLen인 경우 "mask too long"을 출력하고 중지합니다.

2. T를 빈 옥텟 문자열로 둡니다.

3. 0에서 \ceil \(maskLen / hLen\) - 1까지의 카운터에 대해 다음을 수행합니다.

- 다음:

-  ㅏ. 카운터를 길이가 4옥텟인 옥텟 문자열 C로 변환합니다\(섹션 4.1 참조\).

```text
            C = I2OSP (counter, 4) .
```

-ㄴ. mgfSeed 시드의 해시와 C를 옥텟 문자열 T에 연결합니다.

```text
            T = T || Hash(mgfSeed || C) .
```

4. T의 선행 마스크 길이 옥텟을 옥텟 문자열 마스크로 출력합니다.

객체 식별자 id-mgf1은 MGF1 마스크 생성 기능을 식별합니다.

```text
   id-mgf1    OBJECT IDENTIFIER ::= { pkcs-1 8 }
```

AlgorithmIdentifier 유형의 값에서 이 OID와 연관된 매개변수 필드는 MGF1이 기반으로 하는 해시 함수를 식별하는 hashAlgorithm 유형의 값을 가져야 합니다.

---
# **Appendix C. ASN.1 module**

```text
PKCS-1 {
    iso(1) member-body(2) us(840) rsadsi(113549) pkcs(1) pkcs-1(1)
    modules(0) pkcs-1(1)
}

-- $ Revision: 2.1r1 $
```

-- 이 모듈은 ASN.1을 준수하는지 확인되었습니다.
-- OSS ASN.1 도구 표준

---
# **DEFINITIONS EXPLICIT TAGS ::=**
---
# **BEGIN**

-- 모두 수출
-- 이 모듈에 정의된 모든 유형과 값은 사용을 위해 내보내집니다.
-- 다른 ASN.1 모듈에서.

---
# **IMPORTS**

```text
id-sha256, id-sha384, id-sha512
    FROM NIST-SHA2 {
        joint-iso-itu-t(2) country(16) us(840) organization(1)
        gov(101) csor(3) nistalgorithm(4) modules(0) sha2(1)
    };

-- ============================
--   Basic object identifiers
-- ============================

-- The DER encoding of this in hexadecimal is:
-- (0x)06 08
--        2A 86 48 86 F7 0D 01 01
--
pkcs-1    OBJECT IDENTIFIER ::= {

    iso(1) member-body(2) us(840) rsadsi(113549) pkcs(1) 1
}

--
-- When rsaEncryption is used in an AlgorithmIdentifier the
-- parameters MUST be present and MUST be NULL.
--
rsaEncryption    OBJECT IDENTIFIER ::= { pkcs-1 1 }

--
-- When id-RSAES-OAEP is used in an AlgorithmIdentifier the
-- parameters MUST be present and MUST be RSAES-OAEP-params.
--
id-RSAES-OAEP    OBJECT IDENTIFIER ::= { pkcs-1 7 }

--
-- When id-pSpecified is used in an AlgorithmIdentifier the
-- parameters MUST be an OCTET STRING.
--
id-pSpecified    OBJECT IDENTIFIER ::= { pkcs-1 9 }

-- When id-RSASSA-PSS is used in an AlgorithmIdentifier the
-- parameters MUST be present and MUST be RSASSA-PSS-params.
--
id-RSASSA-PSS    OBJECT IDENTIFIER ::= { pkcs-1 10 }

--
-- When the following OIDs are used in an AlgorithmIdentifier the
-- parameters MUST be present and MUST be NULL.
--
md2WithRSAEncryption       OBJECT IDENTIFIER ::= { pkcs-1 2 }
md5WithRSAEncryption       OBJECT IDENTIFIER ::= { pkcs-1 4 }
sha1WithRSAEncryption      OBJECT IDENTIFIER ::= { pkcs-1 5 }
sha256WithRSAEncryption    OBJECT IDENTIFIER ::= { pkcs-1 11 }
sha384WithRSAEncryption    OBJECT IDENTIFIER ::= { pkcs-1 12 }
sha512WithRSAEncryption    OBJECT IDENTIFIER ::= { pkcs-1 13 }

--
-- This OID really belongs in a module with the secsig OIDs.
--
id-sha1    OBJECT IDENTIFIER ::= {
    iso(1) identified-organization(3) oiw(14) secsig(3)
    algorithms(2) 26
}

--
-- OIDs for MD2 and MD5, allowed only in EMSA-PKCS1-v1_5.
--

id-md2 OBJECT IDENTIFIER ::= {
    iso(1) member-body(2) us(840) rsadsi(113549) digestAlgorithm(2) 2
}

id-md5 OBJECT IDENTIFIER ::= {
    iso(1) member-body(2) us(840) rsadsi(113549) digestAlgorithm(2) 5
}

--
-- When id-mgf1 is used in an AlgorithmIdentifier the parameters MUST
-- be present and MUST be a HashAlgorithm, for example sha1.
--
id-mgf1    OBJECT IDENTIFIER ::= { pkcs-1 8 }

-- ================
--   Useful types
-- ================

ALGORITHM-IDENTIFIER ::= CLASS {
    &id    OBJECT IDENTIFIER  UNIQUE,
    &Type  OPTIONAL
}
    WITH SYNTAX { OID &id [PARAMETERS &Type] }

--
-- Note: the parameter InfoObjectSet in the following definitions
-- allows a distinct information object set to be specified for sets
-- of algorithms such as:
-- DigestAlgorithms    ALGORITHM-IDENTIFIER ::= {
--     { OID id-md2  PARAMETERS NULL }|
--     { OID id-md5  PARAMETERS NULL }|
--     { OID id-sha1 PARAMETERS NULL }
-- }
--

AlgorithmIdentifier { ALGORITHM-IDENTIFIER:InfoObjectSet } ::=
SEQUENCE {
    algorithm  ALGORITHM-IDENTIFIER.&id({InfoObjectSet}),
    parameters
        ALGORITHM-IDENTIFIER.&Type({InfoObjectSet}{@.algorithm})
            OPTIONAL
}

-- ==============
--   Algorithms
-- ==============

--

-- Allowed EME-OAEP and EMSA-PSS digest algorithms.
--
OAEP-PSSDigestAlgorithms    ALGORITHM-IDENTIFIER ::= {
    { OID id-sha1 PARAMETERS NULL   }|
    { OID id-sha256 PARAMETERS NULL }|
    { OID id-sha384 PARAMETERS NULL }|
    { OID id-sha512 PARAMETERS NULL },
    ...  -- Allows for future expansion --
}

--
-- Allowed EMSA-PKCS1-v1_5 digest algorithms.
--
PKCS1-v1-5DigestAlgorithms    ALGORITHM-IDENTIFIER ::= {
    { OID id-md2 PARAMETERS NULL    }|
    { OID id-md5 PARAMETERS NULL    }|
    { OID id-sha1 PARAMETERS NULL   }|
    { OID id-sha256 PARAMETERS NULL }|
    { OID id-sha384 PARAMETERS NULL }|
    { OID id-sha512 PARAMETERS NULL }
}
```

-- id-md2 및 id-md5가 AlgorithmIdentifier에서 사용되는 경우
-- 매개변수는 반드시 존재해야 하며 NULL이어야 합니다.\(MUST\)

-- id-sha1, id-sha256, id-sha384 및 id-sha512가
-- AlgorithmIdentifier 매개변수\(선택사항\)는 다음과 같습니다.
-- 생략합니다. 그러나 구현은 다음 사항도 수락해야 합니다.
-- 매개변수가 NULL인 AlgorithmIdentifier 값.\(SHOULD, MUST\)

```text
sha1    HashAlgorithm ::= {
    algorithm   id-sha1,
    parameters  SHA1Parameters : NULL  -- included for compatibility
                                       -- with existing implementations
}
```

---
# **HashAlgorithm ::= AlgorithmIdentifier { {OAEP-PSSDigestAlgorithms} }**
---
# **SHA1Parameters ::= NULL**

```text
--
-- Allowed mask generation function algorithms.
-- If the identifier is id-mgf1, the parameters are a HashAlgorithm.
--
PKCS1MGFAlgorithms    ALGORITHM-IDENTIFIER ::= {
    { OID id-mgf1 PARAMETERS HashAlgorithm },
    ...  -- Allows for future expansion --
}

--
-- Default AlgorithmIdentifier for id-RSAES-OAEP.maskGenAlgorithm and
-- id-RSASSA-PSS.maskGenAlgorithm.
--
mgf1SHA1    MaskGenAlgorithm ::= {
    algorithm   id-mgf1,
    parameters  HashAlgorithm : sha1
}
```

---
# **MaskGenAlgorithm ::= AlgorithmIdentifier { {PKCS1MGFAlgorithms} }**

```text
--
-- Allowed algorithms for pSourceAlgorithm.
--
PKCS1PSourceAlgorithms    ALGORITHM-IDENTIFIER ::= {
    { OID id-pSpecified PARAMETERS EncodingParameters },
    ...  -- Allows for future expansion --
}
```

---
# **EncodingParameters ::= OCTET STRING(SIZE(0..MAX))**

```text
--
-- This identifier means that the label L is an empty string, so the
-- digest of the empty string appears in the RSA block before
-- masking.
--
pSpecifiedEmpty    PSourceAlgorithm ::= {
    algorithm   id-pSpecified,
    parameters  EncodingParameters : emptyString
}
```

---
# **PSourceAlgorithm ::= AlgorithmIdentifier { {PKCS1PSourceAlgorithms} }**
---
# **emptyString    EncodingParameters ::= ''H**

```text
--
-- Type identifier definitions for the PKCS #1 OIDs.
--
PKCS1Algorithms    ALGORITHM-IDENTIFIER ::= {
    { OID rsaEncryption              PARAMETERS NULL } |
    { OID md2WithRSAEncryption       PARAMETERS NULL } |
    { OID md5WithRSAEncryption       PARAMETERS NULL } |
    { OID sha1WithRSAEncryption      PARAMETERS NULL } |
    { OID sha256WithRSAEncryption    PARAMETERS NULL } |
    { OID sha384WithRSAEncryption    PARAMETERS NULL } |
    { OID sha512WithRSAEncryption    PARAMETERS NULL } |
    { OID id-RSAES-OAEP PARAMETERS RSAES-OAEP-params } |
    PKCS1PSourceAlgorithms                             |

    { OID id-RSASSA-PSS PARAMETERS RSASSA-PSS-params } ,
    ...  -- Allows for future expansion --
}

-- ===================
--   Main structures
-- ===================

RSAPublicKey ::= SEQUENCE {
    modulus           INTEGER,  -- n
    publicExponent    INTEGER   -- e
}

--
-- Representation of RSA private key with information for the CRT
-- algorithm.
--
RSAPrivateKey ::= SEQUENCE {
    version           Version,
    modulus           INTEGER,  -- n
    publicExponent    INTEGER,  -- e
    privateExponent   INTEGER,  -- d
    prime1            INTEGER,  -- p
    prime2            INTEGER,  -- q
    exponent1         INTEGER,  -- d mod (p-1)
    exponent2         INTEGER,  -- d mod (q-1)
    coefficient       INTEGER,  -- (inverse of q) mod p
    otherPrimeInfos   OtherPrimeInfos OPTIONAL
}

Version ::= INTEGER { two-prime(0), multi(1) }
    (CONSTRAINED BY {
        -- version must be multi if otherPrimeInfos present --
    })
```

---
# **OtherPrimeInfos ::= SEQUENCE SIZE(1..MAX) OF OtherPrimeInfo**

```text
OtherPrimeInfo ::= SEQUENCE {
    prime             INTEGER,  -- ri
    exponent          INTEGER,  -- di
    coefficient       INTEGER   -- ti
}

--
-- AlgorithmIdentifier.parameters for id-RSAES-OAEP.
-- Note that the tags in this Sequence are explicit.
--
RSAES-OAEP-params ::= SEQUENCE {

    hashAlgorithm      [0] HashAlgorithm     DEFAULT sha1,
    maskGenAlgorithm   [1] MaskGenAlgorithm  DEFAULT mgf1SHA1,
    pSourceAlgorithm   [2] PSourceAlgorithm  DEFAULT pSpecifiedEmpty
}

--
-- Identifier for default RSAES-OAEP algorithm identifier.
-- The DER Encoding of this is in hexadecimal:
-- (0x)30 0D
--        06 09
--           2A 86 48 86 F7 0D 01 01 07
--        30 00
-- Notice that the DER encoding of default values is "empty".
--

rSAES-OAEP-Default-Identifier    RSAES-AlgorithmIdentifier ::= {
    algorithm   id-RSAES-OAEP,
    parameters  RSAES-OAEP-params : {
        hashAlgorithm       sha1,
        maskGenAlgorithm    mgf1SHA1,
        pSourceAlgorithm    pSpecifiedEmpty
    }
}

RSAES-AlgorithmIdentifier ::=
    AlgorithmIdentifier { {PKCS1Algorithms} }

--
-- AlgorithmIdentifier.parameters for id-RSASSA-PSS.
-- Note that the tags in this Sequence are explicit.
--
RSASSA-PSS-params ::= SEQUENCE {
    hashAlgorithm      [0] HashAlgorithm      DEFAULT sha1,
    maskGenAlgorithm   [1] MaskGenAlgorithm   DEFAULT mgf1SHA1,
    saltLength         [2] INTEGER            DEFAULT 20,
    trailerField       [3] TrailerField       DEFAULT trailerFieldBC
}
```

---
# **TrailerField ::= INTEGER { trailerFieldBC(1) }**

--
-- 기본 RSASSA-PSS 알고리즘 식별자에 대한 식별자입니다.
-- DER 인코딩은 16진수입니다.
-- \(0x\)30 0D
-- 06 09
-- 2A 86 48 86 F7 0D 01 01 0A
-- 30 00
-- 기본값의 DER 인코딩은 "비어 있음"입니다.

```text
--
rSASSA-PSS-Default-Identifier    RSASSA-AlgorithmIdentifier ::= {
    algorithm   id-RSASSA-PSS,
    parameters  RSASSA-PSS-params : {
        hashAlgorithm       sha1,
        maskGenAlgorithm    mgf1SHA1,
        saltLength          20,
        trailerField        trailerFieldBC
    }
}

RSASSA-AlgorithmIdentifier ::=
    AlgorithmIdentifier { {PKCS1Algorithms} }

--
-- Syntax for the EMSA-PKCS1-v1_5 hash identifier.
--
DigestInfo ::= SEQUENCE {
    digestAlgorithm DigestAlgorithm,
    digest OCTET STRING
}

DigestAlgorithm ::=
    AlgorithmIdentifier { {PKCS1-v1-5DigestAlgorithms} }
```

---
# **END  -- PKCS1Definitions**
---
# **Appendix D. Intellectual Property Considerations**

RSA 공개 키 암호화 시스템은 2000년 9월 20일에 만료된 미국 특허 4,405,829에 설명되어 있습니다. RSA Security Inc.는 특정 기본 기술이 적용될 수 있지만 이 문서에 설명된 구성에 대해 다른 특허권을 주장하지 않습니다.

멀티 프라임 RSA는 미국 특허 5,848,159에 설명되어 있습니다.

캘리포니아 대학교는 PSS 서명 방식에 대한 특허 출원 중임을 밝혔습니다\[5\]. 또한 IEEE P1363 작업 그룹에 PSS 서명 체계가 IEEE 표준에 포함되면 "캘리포니아 대학은 해당 표준이 채택되면 PSS의 구현을 위한 기술로 무료로 라이센스를 부여할 것"이라는 서신을 제공했습니다. 부록으로 디지털 서명 달성" \[23\]. PSS 서명 체계는 이 문서가 출판되었을 때 투표 결의안에 있었던 IEEE P1363a 초안\[27\]에 지정되어 있습니다.

이 문서를 언급하거나 참조하는 모든 자료에서 "RSA Security Inc. 공개 키 암호화 표준\(PKCS\)"으로 식별되는 경우 이 문서를 복사할 수 있는 라이센스가 부여됩니다.

RSA Security Inc.는 다른 당사자의 지적 재산권 청구와 관련하여 다른 진술을 하지 않습니다. 그러한 결정은 사용자의 책임입니다.

---
# **Appendix E. Revision history**

```text
   Versions 1.0 - 1.3
```

- 버전 1.0 - 1.3은 1991년 2월과 3월에 RSA Data Security, Inc.의 공개 키 암호화 표준 회의 참가자에게 배포되었습니다.

```text
   Version 1.4
```

- 버전 1.4는 1991년 6월 3일 PKCS 최초 공개 릴리스의 일부였습니다. 버전 1.4는 NIST/OSI 구현자 워크숍 문서 SEC-SIG-91-18로 게시되었습니다.

```text
   Version 1.5
```

- 버전 1.5에는 참조 업데이트 및 개정 내역 추가를 포함하여 몇 가지 편집 변경 사항이 통합되었습니다. 다음과 같은 실질적인 변경이 이루어졌습니다.

- - 섹션 10: "RSA가 포함된 MD4" 서명 및 확인 프로세스가 추가되었습니다. - 섹션 11: md4WithRSAEncryption 개체 식별자가 추가되었습니다.

- 버전 1.5가 IETF RFC 2313으로 다시 게시되었습니다.

```text
   Version 2.0
```

- 버전 2.0에서는 문서 구조 측면에서 주요 편집 변경 사항을 통합하고 RSAES-OAEP 암호화 체계를 도입했습니다. 이 버전은 버전 1.5의 암호화 및 서명 프로세스를 계속 지원했지만, 그 사이에 암호화 분석의 발전으로 인해 해시 알고리즘 MD4가 더 이상 허용되지 않았습니다. 버전 2.0은 IETF RFC 2437\[35\]로 다시 출판되었습니다.

```text
   Version 2.1
```

버전 2.1에는 다중 프라임 RSA 및 RSASSA-PSS가 도입되었습니다.

- 몇 가지 편집 개선과 함께 부록이 포함된 서명 체계. 이 버전은 버전 2.0의 구성표를 계속 지원합니다.

---
# **Appendix F: References**

```text
   [1]   ANSI X9F1 Working Group.  ANSI X9.44 Draft D2: Key
         Establishment Using Integer Factorization Cryptography.
         Working Draft, March 2002.
```

\[2\] M. Bellare, A. Desai, D. Pointcheval 및 P. Rogaway. 공개 키 암호화 체계에 대한 보안 개념 간의 관계. H. Krawczyk, 편집자, Advances in Cryptology - Crypto '98, 컴퓨터 과학 강의 노트 1462권, pp. 26 - 45. Springer Verlag, 1998.

\[3\] M. Bellare 및 P. Rogaway. 최적의 비대칭 암호화 - RSA로 암호화하는 방법. A. De Santis 편집자, Advances in Cryptology - Eurocrypt '94, 컴퓨터 과학 강의 노트 950권, 92 - 111페이지. Springer Verlag, 1995.

\[4\] M. Bellare 및 P. Rogaway. 디지털 서명의 정확한 보안 - RSA 및 Rabin으로 서명하는 방법 U. Maurer, 편집자, Advances in Cryptology - Eurocrypt '96, 컴퓨터 과학 강의 노트 1070권, pp. 399 - 416. Springer Verlag, 1996.

```text
   [5]   M. Bellare and P. Rogaway.  PSS: Provably Secure Encoding
         Method for Digital Signatures.  Submission to IEEE P1363
         working group, August 1998.  Available from
         http://grouper.ieee.org/groups/1363/.
```

\[6\] D. Bleichenbacher. RSA 암호화 표준 PKCS #1을 기반으로 하는 프로토콜에 대한 선택된 암호문 공격. H. Krawczyk, 편집자, Advances in Cryptology - Crypto '98, 컴퓨터 과학 강의 노트 1462권, 1 - 12페이지. Springer Verlag, 1998.

\[7\] D. Bleichenbacher, B. Kaliski 및 J. Staddon. PKCS #1에 대한 최근 결과: RSA 암호화 표준. RSA 연구소의 공지 번호 7, 1998년 6월.

\[8\] B. 덴 보어\(B. den Boer\)와 A. 보셀라어스\(A. Bosselaers\). MD4의 마지막 두 라운드에 대한 공격입니다. J. Feigenbaum 편집자, Advances in Cryptology - Crypto '91, 컴퓨터 과학 강의 노트 576권, 194 - 203페이지. Springer Verlag, 1992.

\[9\] B. 덴 보어\(B. den Boer\)와 A. 보셀라어스\(A. Bosselaers\). MD5의 압축 기능에 대한 충돌. T. Helleseth, 편집자, Advances in Cryptology - Eurocrypt '93, 컴퓨터 과학 강의 노트 765권, pp. 293 - 304. Springer Verlag, 1994.

\[10\] D. Coppersmith, M. Franklin, J. Patarin 및 M. Reiter. 관련 메시지가 포함된 낮은 지수 RSA. U. Maurer, 편집자, Advances in Cryptology - Eurocrypt '96, 컴퓨터 과학 강의 노트 1070권, pp. 1 - 9. Springer Verlag, 1996.

\[11\] D. Coppersmith, S. Halevi 및 C. Jutla. ISO 9796-1 및 새로운 위조 전략. 1999년 8월 Crypto '99의 엉덩이 세션에서 발표되었습니다.

\[12\] J.-S. 코론. 풀 도메인 해싱의 정확한 보안에 대해. M. Bellare 편집자, Advances in Cryptology - Crypto 2000, 컴퓨터 과학 강의 노트 1880권, pp. 229 - 235. Springer Verlag, 2000.

\[13\] J.-S. 코론. PSS 및 기타 서명 체계에 대한 최적의 보안 증명. L. Knudsen 편집자, Advances in Cryptology - Eurocrypt 2002, 컴퓨터 과학 강의 노트 2332권, pp. 272 ​​- 287. Springer Verlag, 2002.

\[14\] J.-S. 코론, M. Joye, D. Naccache 및 P. Paillier. PKCS #1 v1.5 암호화에 대한 새로운 공격. B. Preneel, 편집자, Advances in Cryptology - Eurocrypt 2000, 컴퓨터 과학 강의 노트 1807권, pp. 369 - 379. Springer Verlag, 2000.

\[15\] J.-S. Coron, D. Naccache 및 J. P. Stern. RSA 패딩의 보안에 대해. M. Wiener, 편집자, Advances in Cryptology - Crypto '99, 컴퓨터 과학 강의 노트 1666권, 1 - 18페이지. Springer Verlag, 1999.

\[16\] Y. Desmedt 및 A.M. Odlyzko. RSA 암호화 시스템 및 일부 이산 로그 체계에 대한 선택 텍스트 공격. H.C. Williams, 편집자, Advances in Cryptology - Crypto '85, 컴퓨터 과학 강의 노트 218권, 516 - 522페이지. Springer Verlag, 1986.

\[17\] Dierks, T. 및 C. Allen, "TLS 프로토콜, 버전 1.0", RFC 2246, 1999년 1월.

\[18\] H. 도베르틴. MD4의 암호분석. D. Gollmann, 편집자, Fast Software Encryption '96, 컴퓨터 과학 강의 노트 1039권, pp. 55 - 72. Springer Verlag, 1996.

\[19\] H. 도베르틴. MD5 압축의 암호 분석. 1996년 5월 Eurocrypt '96의 최고 세션에서 발표되었습니다.

\[20\] H. Dobbertin. MD4의 처음 두 라운드는 단방향이 아닙니다. S. Vaudenay, 편집자, Fast Software Encryption '98, 1372권, 컴퓨터 과학 강의 노트, pp. 284 - 292. Springer Verlag, 1998.

\[21\] E. Fujisaki, T. Okamoto, D. Pointcheval 및 J. Stern. RSA-OAEP는 RSA 가정에 따라 안전합니다. J. Kilian 편집자, Advances in Cryptology - Crypto 2001, 컴퓨터 과학 강의 노트 2139권, pp. 260 - 274. Springer Verlag, 2001.

\[22\] H. 가너. 잔여 번호 시스템. 전자 컴퓨터에 대한 IRE 거래, EC-8 \(6\), pp. 140 - 147, 1959년 6월.

\[23\] M.L. 그렐. Re: 인코딩 방법 PSS/PSS-R. 1999년 6월 15일 캘리포니아 대학의 IEEE P1363 작업 그룹에 보낸 서신. http://grouper.ieee.org/groups/1363/P1363/patents.html에서 확인 가능.

\[24\] J. Haastad. 낮은 차수의 동시 모듈 방정식 풀기. SIAM 컴퓨팅 저널, 17권, pp. 336 - 341, 1988.

```text
   [25]  Housley, R., "Cryptographic Message Syntax (CMS)", RFC 3369,
         August 2002.  Housley, R., "Cryptographic Message Syntax (CMS)
         Algorithms", RFC 3370, August 2002.
```

\[26\] IEEE Std 1363-2000: 공개 키 암호화에 대한 표준 사양. IEEE, 2000년 8월.

```text
   [27]  IEEE P1363 working group.  IEEE P1363a D11: Draft Standard
         Specifications for Public Key Cryptography -- Amendment 1:
         Additional Techniques. December 16, 2002.  Available from
         http://grouper.ieee.org/groups/1363/.
```

\[28\] ISO/IEC 9594-8:1997: 정보 기술 - 개방형 시스템 상호 연결 - 디렉토리: 인증 프레임워크. 1997.

```text
   [29]  ISO/IEC FDIS 9796-2: Information Technology - Security
         Techniques - Digital Signature Schemes Giving Message Recovery
         - Part 2: Integer Factorization Based Mechanisms.  Final Draft
         International Standard, December 2001.
```

\[30\] ISO/IEC 18033-2: 정보 기술 - 보안 기술 - 암호화 알고리즘 - 2부: 비대칭 암호. V. Shoup, 편집자, 2차 작업 초안 텍스트, 2002년 1월.

```text
   [31]  J. Jonsson.  Security Proof for the RSA-PSS Signature Scheme
         (extended abstract).  Second Open NESSIE Workshop.  September
         2001.  Full version available from
         http://eprint.iacr.org/2001/053/.
```

\[32\] J. Jonsson 및 B. Kaliski. TLS의 RSA 암호화 보안에 대해. M. Yung, 편집자, Advances in Cryptology - CRYPTO 2002, vol. 컴퓨터 과학 강의 노트 2442페이지, 127 - 142페이지. Springer Verlag, 2002.

```text
   [33]  Kaliski, B., "The MD2 Message-Digest Algorithm", RFC 1319,
         April 1992.
```

\[34\] B. 칼리스키. 서명 체계의 해시 함수 식별에 대해. B. Preneel, 편집자, RSA Conference 2002, Cryptographers' Track, 컴퓨터 과학 강의 노트 2271권, pp. 1 - 16. Springer Verlag, 2002.

\[35\] Kaliski, B. 및 J. Staddon, "PKCS #1: RSA 암호화

- 사양 버전 2.0", RFC 2437, 1998년 10월.

\[36\] J. Manger. RSA Optimal에 대한 선택된 암호문 공격

- OAEP\(Asymmetric Encryption Padding\)가 PKCS #1 v2.0에서 표준화되었습니다. J. Kilian 편집자, Advances in Cryptology - Crypto 2001, 컴퓨터 과학 강의 노트 2139권, pp. 260 - 274. Springer Verlag, 2001.

\[37\] A. Menezes, P. van Oorschot 및 S. Vanstone. 응용암호화 핸드북. CRC 출판사, 1996.

\[38\] 국립표준기술연구소\(NIST\). FIPS 출판물 180-1: 보안 해시 표준. 1994년 4월.

```text
   [39]  National Institute of Standards and Technology (NIST).  Draft
         FIPS 180-2: Secure Hash Standard.  Draft, May 2001.  Available
         from http://www.nist.gov/sha/.
```

\[40\] J.-J. Quisquater와 C. Couvreur. RSA 공개키 암호화 시스템을 위한 고속 해독 알고리즘. Electronics Letters, 18\(21\), pp. 905 - 907, 1982년 10월.

```text
   [41]  Rivest, R., "The MD5 Message-Digest Algorithm", RFC 1321, April
         1992.
```

\[42\] R. Rivest, A. Shamir 및 L. Adleman. 디지털 서명 및 공개 키 암호화 시스템을 획득하는 방법. ACM 커뮤니케이션, 21 \(2\), pp. 120-126, 1978년 2월.

\[43\] N. Rogier 및 P. Chauvaud. MD2의 압축 기능은 Collision Free가 아닙니다. Selected Areas of Cryptography '95에서 발표되었습니다. 캐나다 오타와 칼튼 대학교. 1995년 5월.

```text
   [44]  RSA Laboratories.  PKCS #1 v2.0: RSA Encryption Standard.
         October 1998.
```

\[45\] RSA 연구소. PKCS #7 v1.5: 암호화 메시지 구문 표준. 1993년 11월. \(IETF RFC 2315로 재발행됨.\)

```text
   [46]  RSA Laboratories.  PKCS #8 v1.2: Private-Key Information Syntax
         Standard.  November 1993.

   [47]  RSA Laboratories.  PKCS #12 v1.0: Personal Information Exchange
         Syntax Standard.  June 1999.
```

\[48\] ​​V. Shoup. OAEP가 재검토되었습니다. J. Kilian 편집자, Advances in Cryptology - Crypto 2001, 컴퓨터 과학 강의 노트 2139권, pp. 239 - 259. Springer Verlag, 2001.

```text
   [49]  R. D. Silverman.  A Cost-Based Security Analysis of Symmetric
         and Asymmetric Key Lengths.  RSA Laboratories Bulletin No. 13,
         April 2000.  Available from
         http://www.rsasecurity.com.rsalabs/bulletins/.
```

\[50\] G. J. 시몬스. DSA를 사용하면 잠재의식 의사소통이 쉽습니다. T. Helleseth, 편집자, Advances in Cryptology - Eurocrypt '93, 컴퓨터 과학 강의 노트 765권, pp. 218-232. Springer-Verlag, 1993.

---
# **Appendix G: About PKCS**

공개 키 암호화 표준은 공개 키 암호화 배포를 가속화할 목적으로 전 세계 보안 시스템 개발자와 협력하여 RSA 연구소에서 제작한 사양입니다. 공개 키 기술을 조기에 채택한 소규모 그룹과의 회의 결과로 1991년에 처음 출판된 PKCS 문서는 널리 참조되고 구현되었습니다. PKCS 시리즈의 기여는 ANSI X9 및 IEEE P1363 문서, PKIX, SET, S/MIME, SSL/TLS 및 WAP/WTLS를 포함하여 많은 공식 및 사실상 표준의 일부가 되었습니다.

PKCS의 추가 개발은 메일링 리스트 토론과 비정기 워크숍을 통해 이루어지며 개선을 위한 제안을 환영합니다. 자세한 내용은 다음 연락처로 문의하세요.

```text
      PKCS Editor
      RSA Laboratories
      174 Middlesex Turnpike
      Bedford, MA  01730 USA
      pkcs-editor@rsasecurity.com
      http://www.rsasecurity.com/rsalabs/pkcs
```

---
# **Appendix H: Corrections Made During RFC Publication Process**

PKCS #1 v2.1 문서를 이 RFC로 변환할 때 다음 사항이 수정되었습니다.

\* id-sha1, id-sha256, id-sha384 및 id-sha512에 대한 AlgorithmIdentifier 값의 매개변수가 NULL이어야 한다는 요구 사항이 매개변수를 생략하라는 권장 사항으로 변경되었습니다\(매개변수는 여전히 NULL이 되도록 허용함\). 이는 NIST가 원래 발표한 정의와 일치하기 위한 것입니다. 구현에서는 매개변수가 없는 경우와 NULL 매개변수가 있는 경우 모두 AlgorithmIdentifier 값을 허용해야 합니다.\(MUST\)

\* RSADP 및 RSASP1\(초 5.1.2 및 5.2.1\) 이후의 참고 사항은 2.a가 아닌 2.b단계를 참조하도록 수정되었습니다.

\* 참고문헌 \[25\], \[27\], \[32\]는 새로운 출판 데이터를 반영하여 업데이트되었습니다.

이러한 수정 사항은 PKCS #1 v2.1의 향후 버전에 반영될 예정입니다.

---
# **Security Considerations**

보안 문제는 이 메모 전체에서 논의됩니다.

---
# **Acknowledgements**

이 문서는 RSA Security Inc.의 연구 센터인 RSA Laboratories의 기여를 기반으로 합니다. 이 문서의 텍스트를 실질적으로 사용하려면 RSA Security Inc.를 인정해야 합니다. RSA Security Inc.는 이 문서를 언급하거나 참조하는 모든 자료에서 이 내용을 다음과 같이 식별할 것을 요청합니다. "RSA 보안 Inc. PKCS #1 v2.1".

---
# **Authors' Addresses**

```text
   Jakob Jonsson
   Philipps-Universitaet Marburg
   Fachbereich Mathematik und Informatik
   Hans Meerwein Strasse, Lahnberge
   DE-35032 Marburg
   Germany

   Phone: +49 6421 28 25672
   EMail: jonsson@mathematik.uni-marburg.de

   Burt Kaliski
   RSA Laboratories
   174 Middlesex Turnpike
   Bedford, MA 01730 USA

   Phone: +1 781 515 7073
   EMail: bkaliski@rsasecurity.com
```

---
# **Full Copyright Statement**

저작권 \(C\) 인터넷 소사이어티 2003. All Rights Reserved.

이 문서와 그 번역본은 위의 저작권 표시와 이 단락이 모든 사본에 포함되어 있는 경우 복사하여 다른 사람에게 제공할 수 있습니다. 그러나 본 문서 자체는 영어 이외의 언어로 번역해야 하는 경우를 제외하고는 저작권 표시나 인터넷 협회 또는 기타 인터넷 조직에 대한 참조를 제거하는 등 어떠한 방식으로도 수정할 수 없습니다.

위에서 부여된 제한된 권한은 영구적이며 Internet Society 또는 그 승계자 또는 양수인에 의해 취소되지 않습니다.

이 문서와 여기에 포함된 정보는 "있는 그대로" 제공되며 인터넷 사회 및 인터넷 공학 태스크포스는 여기에 포함된 정보의 사용이 상품성 또는 특정 목적에의 적합성에 대한 권리 또는 묵시적 보증을 침해하는 행위.

---
# **Acknowledgement**

RFC 편집기 기능에 대한 자금은 현재 Internet Society에서 제공하고 있습니다.


```text
Internet Engineering Task Force (IETF)                         A. Bakker
Request for Comments: 7574                  Vrije Universiteit Amsterdam
Category: Standards Track                                    R. Petrocco
ISSN: 2070-1721                                           V. Grishchenko
                                           Technische Universiteit Delft
                                                               July 2015

              Peer-to-Peer Streaming Peer Protocol (PPSPP)
```

---
# **Abstract**

PPSPP\(Peer-to-Peer Streaming Peer Protocol\)는 동일한 콘텐츠를 스트리밍 방식으로 이해 당사자 그룹에 전파하기 위한 프로토콜입니다. PPSPP는 사전 녹화된\(주문형\) 콘텐츠와 라이브 오디오/비디오 콘텐츠 모두의 스트리밍을 지원합니다. 이는 모든 사람이 잠재적으로 업로드 대역폭을 제공할 수 있는 시스템을 만들기 위해 콘텐츠를 소비하는 클라이언트가 처음에 콘텐츠를 제공하는 서버와 동등한 위치에 놓이는 P2P 패러다임을 기반으로 합니다. 이는 최종 사용자에게 짧은 재생 시간을 제공하고 악의적인 피어에 의한 스트림 중단을 방지하도록 설계되었습니다. PPSPP는 또한 유연하고 확장 가능하도록 설계되었습니다. 다양한 메커니즘을 사용하여 피어 업로드를 최적화하고, 무임승차를 방지하고, 다양한 피어 검색 체계\(중앙 집중식 추적기 또는 분산 해시 테이블\)와 함께 작동할 수 있습니다. 콘텐츠 무결성 보호 및 청크 주소 지정을 위한 다양한 방법을 지원합니다. 다양한 전송 프로토콜 위에서 실행될 수 있는 일반 프로토콜로 설계되었으며 현재 혼잡 제어를 위해 LEDBAT\(Low Extra Delay Background Transport\)를 사용하여 UDP 위에서 실행됩니다.

---
# **Status of This Memo**

이것은 인터넷 표준 추적 문서입니다.

이 문서는 IETF\(Internet Engineering Task Force\)의 산물입니다. 이는 IETF 커뮤니티의 합의를 나타냅니다. 공개 검토를 받았으며 IESG\(Internet Engineering Steering Group\)의 게시 승인을 받았습니다. 인터넷 표준에 대한 추가 정보는 RFC 5741의 섹션 2에서 확인할 수 있습니다.

이 문서의 현재 상태, 정오표, 피드백 제공 방법에 대한 정보는 http://www.rfc-editor.org/info/rfc7574에서 얻을 수 있습니다.

---
# **Copyright Notice**

Copyright \(c\) 2015 IETF Trust 및 문서 작성자로 식별된 사람. 판권 소유.

이 문서는 이 문서 발행일에 유효한 BCP 78 및 IETF 문서와 관련된 IETF Trust의 법적 조항\(http://trustee.ietf.org/license-info\)의 적용을 받습니다. 이 문서에 관한 귀하의 권리와 제한 사항이 설명되어 있으므로 이 문서를 주의 깊게 검토하십시오. 이 문서에서 추출된 코드 구성 요소는 신뢰 법률 조항의 섹션 4.e에 설명된 대로 단순화된 BSD 라이센스 텍스트를 포함해야 하며 단순화된 BSD 라이센스에 설명된 대로 보증 없이 제공됩니다.

---
# **Table of Contents**

```text
   1. Introduction ....................................................5
      1.1. Purpose ....................................................5
      1.2. Requirements Language ......................................6
      1.3. Terminology ................................................6
   2. Overall Operation ...............................................9
      2.1. Example: Joining a Swarm ...................................9
      2.2. Example: Exchanging Chunks ................................10
      2.3. Example: Leaving a Swarm ..................................10
   3. Messages .......................................................11
      3.1. HANDSHAKE .................................................11
           3.1.1. Handshake Procedure ................................12
      3.2. HAVE ......................................................14
      3.3. DATA ......................................................15
      3.4. ACK .......................................................15
      3.5. INTEGRITY .................................................15
      3.6. SIGNED_INTEGRITY ..........................................16
      3.7. REQUEST ...................................................16
      3.8. CANCEL ....................................................16
      3.9. CHOKE and UNCHOKE .........................................17
      3.10. Peer Address Exchange ....................................17
           3.10.1. PEX_REQ and PEX_RES Messages ......................17
      3.11. Channels .................................................19
      3.12. Keep Alive Signaling .....................................20
   4. Chunk Addressing Schemes .......................................21
      4.1. Start-End Ranges ..........................................21
           4.1.1. Chunk Ranges .......................................21
           4.1.2. Byte Ranges ........................................21
      4.2. Bin Numbers ...............................................22
      4.3. In Messages ...............................................23
           4.3.1. In HAVE Messages ...................................23
           4.3.2. In ACK Messages ....................................24
   5. Content Integrity Protection ...................................24
      5.1. Merkle Hash Tree Scheme ...................................25
      5.2. Content Integrity Verification ............................26
      5.3. The Atomic Datagram Principle .............................27
      5.4. INTEGRITY Messages ........................................28
      5.5. Discussion and Overhead ...................................28
      5.6. Automatic Detection of Content Size .......................29
           5.6.1. Peak Hashes ........................................29
           5.6.2. Procedure ..........................................31
   6. Live Streaming .................................................32
      6.1. Content Authentication ....................................32
           6.1.1. Sign All ...........................................33
           6.1.2. Unified Merkle Tree ................................33
                  6.1.2.1. Signed Munro Hashes .......................34
                  6.1.2.2. Munro Signature Calculation ...............36
                  6.1.2.3. Procedure .................................37
                  6.1.2.4. Secure Tune In ............................37
      6.2. Forgetting Chunks .........................................38
   7. Protocol Options ...............................................38
      7.1. End Option ................................................39
      7.2. Version ...................................................39
      7.3. Minimum Version ...........................................40
      7.4. Swarm Identifier ..........................................40
      7.5. Content Integrity Protection Method .......................41
      7.6. Merkle Tree Hash Function .................................41
      7.7. Live Signature Algorithm ..................................42
      7.8. Chunk Addressing Method ...................................42
      7.9. Live Discard Window .......................................43
      7.10. Supported Messages .......................................44
      7.11. Chunk Size ...............................................44
   8. UDP Encapsulation ..............................................45
      8.1. Chunk Size ................................................45
      8.2. Datagrams and Messages ....................................46
      8.3. Channels ..................................................47
      8.4. HANDSHAKE .................................................47
      8.5. HAVE ......................................................48
      8.6. DATA ......................................................48
      8.7. ACK .......................................................49
      8.8. INTEGRITY .................................................50
      8.9. SIGNED_INTEGRITY ..........................................51
      8.10. REQUEST ..................................................52
      8.11. CANCEL ...................................................52
      8.12. CHOKE and UNCHOKE ........................................53
      8.13. PEX_REQ, PEX_RESv4, PEX_RESv6, and PEX_REScert ...........53
      8.14. KEEPALIVE ................................................55
      8.15. Flow and Congestion Control ..............................56
      8.16. Example of Operation .....................................57
   9. Extensibility ..................................................61
      9.1. Chunk Picking Algorithms ..................................61
      9.2. Reciprocity Algorithms ....................................62
   10. IANA Considerations ...........................................62
      10.1. PPSPP Message Type Registry ..............................62
      10.2. PPSPP Option Registry ....................................62
      10.3. PPSPP Version Number Registry ............................62
      10.4. PPSPP Content Integrity Protection Method Registry .......62
      10.5. PPSPP Merkle Hash Tree Function Registry .................63
      10.6. PPSPP Chunk Addressing Method Registry ...................63
   11. Manageability Considerations ..................................63
      11.1. Operations ...............................................63
           11.1.1. Installation and Initial Setup ....................63
           11.1.2. Migration Path ....................................64
           11.1.3. Requirements on Other Protocols and
                   Functional Components .............................64
           11.1.4. Impact on Network Operation .......................64
           11.1.5. Verifying Correct Operation .......................65
           11.1.6. Configuration .....................................65
      11.2. Management Considerations ................................66
           11.2.1. Management Interoperability and Information .......67
           11.2.2. Fault Management ..................................67
           11.2.3. Configuration Management ..........................67
           11.2.4. Accounting Management .............................68
           11.2.5. Performance Management ............................68
           11.2.6. Security Management ...............................68
   12. Security Considerations .......................................68
      12.1. Security of the Handshake Procedure ......................68
           12.1.1. Protection against Attack 1 .......................69
           12.1.2. Protection against Attack 2 .......................70
           12.1.3. Protection against Attack 3 .......................70
      12.2. Secure Peer Address Exchange .............................71
           12.2.1. Protection against the Amplification Attack .......71
           12.2.2. Example: Tracker as Certification Authority .......72
           12.2.3. Protection against Eclipse Attacks ................73
      12.3. Support for Closed Swarms ................................73
      12.4. Confidentiality of Streamed Content ......................74
      12.5. Strength of the Hash Function for Merkle Hash Trees ......74
      12.6. Limit Potential Damage and Resource Exhaustion by
            Bad or Broken Peers ......................................74
           12.6.1. HANDSHAKE .........................................75
           12.6.2. HAVE ..............................................75
           12.6.3. DATA ..............................................75
           12.6.4. ACK ...............................................75
           12.6.5. INTEGRITY and SIGNED_INTEGRITY ....................76
           12.6.6. REQUEST ...........................................76
           12.6.7. CANCEL ............................................76
           12.6.8. CHOKE .............................................77
           12.6.9. UNCHOKE ...........................................77
           12.6.10. PEX_RES ..........................................77
           12.6.11. Unsolicited Messages in General ..................77
      12.7. Exclude Bad or Broken Peers ..............................77
   13. References ....................................................78
      13.1. Normative References .....................................78
      13.2. Informative References ...................................79
   Acknowledgements ..................................................84
   Authors' Addresses ................................................85
```

---
## **1.  Introduction**
---
### **1.1.  Purpose**

이 문서에서는 동일한 콘텐츠를 스트리밍 방식으로 이해 당사자 그룹에 배포하도록 설계된 PPSPP\(Peer-to-Peer Streaming Peer Protocol\)에 대해 설명합니다. PPSPP는 사전 녹화된\(주문형\) 콘텐츠와 라이브 오디오/비디오 콘텐츠 모두의 스트리밍을 지원합니다. 이는 모든 사람이 잠재적으로 업로드 대역폭을 제공할 수 있는 시스템을 만들기 위해 콘텐츠를 소비하는 클라이언트가 처음에 콘텐츠를 제공하는 서버와 동등한 위치에 놓이는 P2P 패러다임을 기반으로 합니다.

PPSPP는 최종 사용자에게 짧은 재생 시간을 제공하고 악의적인 피어에 의한 스트림 중단을 방지하도록 설계되었습니다. 이 디자인의 핵심은 자체 인증을 기반으로 콘텐츠를 식별하는 간단한 방법입니다. 특히 PPSPP의 콘텐츠는 콘텐츠 \[MERKLE\] \[ABMRKL\]에서 재귀적으로 계산된 Merkle 해시 트리의 루트 해시인 단일 암호화 해시로 식별됩니다. 이 자체 인증 해시 트리를 통해 모든 피어는 악의적인 피어가 가짜 콘텐츠를 배포하려고 시도할 때 직접 감지할 수 있습니다. 트리는 정적 콘텐츠와 라이브 콘텐츠 모두에 사용할 수 있습니다. 또한 다운로드를 시작하고 들어오는 콘텐츠 청크를 확인하는 데 필요한 정보의 양이 매우 적으므로 시작 시간이 단축됩니다.

PPSPP는 또한 다양한 전송 및 사용 사례에 맞게 확장 가능하도록 설계되었습니다. 따라서 PPSPP는 UDP, TCP 또는 기타 프로토콜 위에서 직접 실행될 수 있는 일반 프로토콜입니다. 따라서 PPSPP는 프로토콜을 구성하는 공통 메시지 세트를 정의합니다. 이 메시지는 사용되는 하위 수준 프로토콜에 따라 유선상에서 서로 다른 표현을 가질 수 있습니다. 하위 수준 전송이 허용되는 경우 PPSPP는 다른 혼잡 제어 알고리즘을 사용할 수도 있습니다.

현재 PPSPP는 혼잡 제어를 위해 LEDBAT를 사용하여 UDP 위에서 실행되도록 설정되어 있습니다\[RFC6817\]. LEDBAT를 사용하면 PPSPP가 네트워크 연결을 사용하는 다른 작업으로 이동했을 수 있는 사용자를 방해하지 않고 재생\(시드\) 후 콘텐츠를 제공할 수 있습니다.

PPSPP는 클라이언트 기여를 촉진하고 무임승차를 방지하는 데 사용하는 메커니즘, 즉 콘텐츠를 다운로드만 하고 다른 사람에게 업로드하지 않는 피어를 처리하는 방법에서도 유연하고 확장 가능합니다. 또한 기본값이 특정 사용 사례에 적합하지 않은 경우 청크 주소 지정 및 콘텐츠 무결성 보호를 위한 다양한 체계를 허용합니다. 또한 중앙 집중식 추적기 또는 빠른 분산 해시 테이블\[JIM11\]과 같은 다양한 피어 검색 체계와 함께 작동할 수 있습니다. 마지막으로 이 기본 설정에서 PPSPP는 피어당 소량의 상태만 유지합니다. UDP를 통한 PPSPP의 참조 구현을 사용할 수 있습니다 \[SWIFTIMPL\].

이 문서에 정의된 프로토콜은 피어가 중앙 추적기 \[PPSP-TP\] 등을 사용하여 \(초기\) 피어 목록을 이미 발견했다고 가정합니다. 피어가 이 피어 목록을 갖게 되면 PPSPP는 피어가 다른 피어에 연결하고, 콘텐츠 청크를 요청하고, 동일한 콘텐츠를 전파하는 다른 피어를 검색할 수 있도록 합니다.

PPSPP의 디자인은 BitTorrent \[BITTORRENT\]를 스트리밍 콘텐츠 \[P2PWIKI\]에 적합하게 만드는 연구를 기반으로 합니다. 대부분의 PPSPP 메시지에는 해당 BitTorrent 메시지가 있으며 그 반대도 마찬가지입니다. 그러나 PPSPP는 특히 오디오/비디오 콘텐츠 스트리밍을 목표로 하며 재생까지의 시간을 최적화합니다. 또한 보다 유연하고 확장 가능하도록 설계되었습니다.

---
### **1.2.  Requirements Language**

이 문서의 핵심 단어 "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY" 및 "OPTIONAL"은 다음과 같습니다. RFC 2119 \[RFC2119\]에 설명된 대로 해석됩니다.

---
### **1.3.  Terminology**

메시지 - PPSPP 통신의 기본 단위입니다. 메시지는 사용된 전송 프로토콜에 따라 회선에서 다르게 표현됩니다. 메시지는 일반적으로 전송을 위해 데이터그램으로 다중화됩니다.

데이터그램 - 기본 전송 프로토콜\(UDP 등\)에 하나의 단위로 제공되는 일련의 메시지입니다. 데이터그램은 PPSPP의 PDU\(Protocol Data Unit\)입니다.

콘텐츠 - 실시간 전송 또는 사전 녹음된 멀티미디어 파일입니다.

청크 - 콘텐츠를 나누는 기본 단위입니다. 예를 들어 N킬로바이트 블록입니다. 청크의 크기는 다양할 수 있습니다.

청크 ID - 콘텐츠 청크에 대한 고유 식별자\(예: 정수\)입니다. 해당 유형은 사용된 청크 주소 지정 체계에 따라 다릅니다.

청크 사양 - 하나 이상의 청크 ID를 나타내는 표현식입니다.

청크 주소 지정 체계 - 청크를 식별하고 피어의 청크 가용성 맵을 컴팩트한 방식으로 표현하기 위한 체계입니다.

청크 가용성 맵 - 피어가 성공적으로 다운로드하고 무결성을 확인한 청크 세트입니다.

bin - bin 번호 청크 주소 지정 체계에서 콘텐츠\(즉, 하나 이상의 연속 청크\)의 특정 바이너리 간격을 나타내는 숫자입니다\(섹션 4 참조\).

콘텐츠 무결성 보호 체계 - 콘텐츠가 P2P 네트워크를 통해 배포되는 동안 콘텐츠의 무결성을 보호하기 위한 체계입니다. 즉, 요청된 청크가 송신 피어에 의해 악의적으로 수정되었거나 전송 중에 실수로 수정되었는지 여부를 감지하기 위해 피어를 수신하는 방법입니다.

hash - 암호화 해시 함수, 특히 SHA-256 \[FIPS180-4\]와 같은 수정 감지 코드\(MDC\) \[HAC01\]를 데이터에 적용한 결과입니다.

머클 해시 트리\(Merkle hash tree\) - 콘텐츠 덩어리의 해시로 기반이 형성되고 상위 노드가 두 하위 해시를 연결한 해시를 재귀적으로 계산하여 계산되는 해시 트리입니다\(섹션 5.1 참조\).

루트 해시 - 콘텐츠에서 재귀적으로 계산된 Merkle 해시 트리의 루트입니다\(섹션 5.1 참조\).

munro hash - 라이브 스트리밍을 위한 통합 머클 트리 콘텐츠 인증 체계의 서명 단위인 하위 트리의 해시입니다\(섹션 6.1.2.1 참조\).

swarm - 동일한 콘텐츠 배포에 참여하는 피어 그룹입니다.

떼 ID\(swarm ID\) - 피어 떼에 대한 고유 식별자로, PPSPP에서는 바이트 시퀀스입니다. 콘텐츠 무결성 보호가 활성화된 주문형 비디오의 경우 식별자는 콘텐츠에 대한 Merkle 해시 트리의 루트 해시입니다. 라이브 스트리밍의 경우 떼 ID는 공개 키입니다.

추적기 - 일반적으로 떼 집합에 대해 떼에 참여하는 피어의 주소를 기록하고 요청 시 다른 피어가 이 멤버십 정보를 사용할 수 있도록 하는 엔터티입니다.

질식 - 피어 A가 피어 B를 질식시키는 경우 이는 A가 현재 B의 콘텐츠 요청을 수락할 의사가 없음을 의미합니다.

시드 - 피어 A는 A가 정적 콘텐츠 파일을 완전히 다운로드하고 이제 다른 사람이 다운로드할 수 있도록 제공할 때 시드 중이라고 합니다.

리칭\(leeching\) - 피어 A는 A가 아직 정적 콘텐츠 파일을 완전히 다운로드하지 않았거나 이를 다른 사람에게 업로드하겠다고 제안하지 않을 때 리칭 중이라고 합니다.

채널 - 두 피어 간의 논리적 연결입니다. 채널 개념을 통해 피어는 서로 다른 피어와 통신하기 위해 동일한 전송 주소를 사용할 수 있습니다.

채널 ID - 각 피어에 대해 로컬인 채널에 대해 무작위로 선택된 고유 식별자입니다. 따라서 채널로 논리적으로 연결된 두 피어는 각각 해당 채널에 대해 서로 다른 채널 ID를 갖습니다.

무거운 페이로드 - 데이터그램에 DATA 메시지, SIGNED\_INTEGRITY 메시지 또는 많은 수의 작은 메시지가 포함되어 있으면 무거운 페이로드가 있습니다.

이 문서에서 접두사 kilo-, mega- 등은 기본 1024를 나타냅니다.

---
## **2.  Overall Operation**

PPSPP의 기본 통신 단위는 메시지입니다. 여러 메시지가 전송을 위해 단일 데이터그램으로 다중화됩니다. 데이터그램\(및 그에 포함된 메시지\)은 사용된 전송 프로토콜에 따라 회선에서 서로 다른 표현을 갖습니다\(섹션 8 참조\).

PPSPP의 전반적인 작동은 다음 예에 설명되어 있습니다. 예제에서는 배포된 콘텐츠가 정적이고, UDP가 전송에 사용되고, 머클 해시 트리 체계가 콘텐츠 무결성 보호에 사용되고, 다운로드할 청크를 선택하는 데 특정 정책이 사용된다고 가정합니다.

---
### **2.1.  Example: Joining a Swarm**

비디오를 보고 싶어하는 사용자를 생각해 보십시오. 비디오를 재생하려면 사용자가 PPSPP 지원 브라우저에 표시된 HTML5 <video\> 요소의 재생 버튼을 클릭합니다. 이 요소에 비디오를 소스로 식별하는 PPSPP URL\(다른 곳에서 정의됨\)이 있다고 가정해 보세요. 브라우저는 이 URL을 P2P 스트리밍 프로토콜 처리기에 전달합니다. 이 프로토콜 핸들러를 피어 A라고 부르겠습니다. 피어 A는 URL을 구문 분석하여 P2P 스트리밍 프로토콜 추적기의 전송 주소와 콘텐츠의 떼 메타데이터를 검색합니다. 분산형 추적 메커니즘이 있는 경우 추적기 주소는 선택 사항일 수 있습니다. 피어를 추적하는 메커니즘은 이 문서의 범위를 벗어납니다.

이제 피어 A는 P2P 스트리밍 프로토콜 추적기 사양\[PPSP-TP\]에 따라 추적기에 등록하고 이미 떼에 있는 피어\(예: 피어 B, C, D\)의 IP 주소와 포트를 수신합니다. , PPSPP가 작동을 시작합니다. 이제 피어 A는 PPSPP HANDSHAKE 메시지가 포함된 데이터그램을 피어 B, C 및 D에 보냅니다. 이 메시지는 프로토콜 옵션을 전달합니다. 특히, 피어 A는 대상 피어가 동일한 전송 주소에서 여러 떼를 수신할 수 있기 때문에 떼의 ID\(군집 메타데이터의 일부\)를 프로토콜 옵션으로 포함합니다.

피어 B와 C는 PPSPP HANDSHAKE 메시지와 하나 이상의 HAVE 메시지를 포함하는 데이터그램으로 응답합니다. HAVE 메시지는 피어의 청크 가용성\(일부\)을 전달합니다. 따라서 피어 B와 C가 각각 가지고 있는 콘텐츠 청크를 나타내는 청크 사양을 포함합니다. 피어 D는 HANDSHAKE 및 HAVE 메시지뿐만 아니라 CHOKE 메시지도 포함하여 데이터그램을 보냅니다. 후자는 피어 D가 현재 피어 A에 청크를 업로드할 의향이 없음을 나타냅니다.

---
### **2.2.  Example: Exchanging Chunks**

피어 B와 C에 대한 응답으로 피어 A는 REQUEST 메시지가 포함된 새 데이터그램을 피어 B와 C에 보냅니다. REQUEST 메시지는 피어가 다운로드하려는 청크를 나타냅니다. 따라서 여기에는 청크 사양이 포함됩니다. 피어 B와 C에 대한 REQUEST 메시지는 분리된 청크 세트를 참조합니다. 피어 B와 C는 HAVE, DATA 및 이 예에서는 INTEGRITY 메시지를 포함하는 데이터그램으로 응답합니다. Merkle 해시 트리 콘텐츠 보호 체계\(섹션 5.1 참조\)에서 INTEGRITY 메시지에는 피어 A가 DATA 메시지로 전송된 콘텐츠 청크의 무결성을 확인하는 데 필요한 모든 암호화 해시가 포함되어 있습니다. 이러한 해시를 사용하여 피어 A는 피어 B와 C로부터 수신된 청크가 신뢰할 수 있는 떼 ID에 대해 올바른지 확인합니다. 또한 피어 A는 수신된 HAVE 메시지의 정보를 사용하여 피어 B와 C의 청크 가용성을 업데이트합니다. 또한 렌더링을 위해 비디오 청크를 사용자 브라우저에 전달합니다.

처리 후 피어 A는 방금 수신한 청크에 대한 HAVE 메시지가 포함된 데이터그램을 모든 피어에게 보냅니다. 피어 B와 C에 대한 데이터그램에는 청크 수신을 확인하는 ACK 메시지가 포함되고 새 청크에 대한 REQUEST 메시지가 추가됩니다. 신뢰할 수 있는 전송 프로토콜을 사용하는 경우에는 ACK 메시지가 사용되지 않습니다. 예를 들어, 피어 C가 피어 A가 피어 C가 아직 가지고 있지 않은 청크\(피어 B로부터\)를 얻었음을 발견하면 피어 C의 다음 데이터그램에는 해당 청크에 대한 REQUEST가 포함됩니다.

피어 D는 또한 다른 피어로부터 청크를 다운로드할 때 피어 A에 HAVE 메시지를 보냅니다. 피어 D가 피어 A의 요청을 기꺼이 수락하면 피어 D는 UNCHOKE 메시지와 함께 데이터그램을 보내 피어 A에게 알립니다. 피어 B 또는 C가 피어 A를 질식시키기로 결정하면 CHOKE 메시지를 보내고 피어 A는 다시 요청해야 합니다. 다른 동료로부터. 피어 B와 C는 피어 A가 HAVE 메시지를 계속 보내도록 HAVE, REQUEST 또는 주기적 연결 유지 메시지를 계속 보낼 수 있습니다.

피어 A가 모든 콘텐츠\(주문형 비디오 사용 사례\)를 수신하면 모든 콘텐츠가 있는 다른 모든 피어\(일명 시더\)에게 메시지 전송을 중지합니다. 피어 A는 더 많은 피어 주소를 얻기 위해 추적기 또는 다른 소스에 다시 연결할 수도 있습니다.

---
### **2.3.  Example: Leaving a Swarm**

무리를 우아하게 떠나기 위해 피어 A는 모든 피어에게 특정 HANDSHAKE 메시지를 보내고\(섹션 8.4 참조\) 추적기 사양 \[PPSP-TP\]에 따라 추적기에서 등록을 취소합니다. 데이터그램을 수신하는 피어는 현재 피어 목록에서 피어 A를 제거해야 합니다. 피어 A가 비정상적으로 충돌하는 경우 피어는 더 이상 메시지를 보내지 않는다는 것을 감지하면 피어 목록에서 피어 A를 제거해야 합니다\(섹션 3.12 참조\).

---
## **3.  Messages**

프로토콜에는 오류 코드나 응답이 사용되지 않습니다. 응답이 없으면 오류가 있음을 나타냅니다. 유효하지 않은 메시지는 폐기되며 피어와의 추가 통신은 중지되어야 합니다. 그 근거는 동료를 좋은지 나쁜지 분류하고 좋은 동료만 사용하는 것으로 충분하다는 것입니다. 좋은 피어는 덩어리로 응답하는 피어입니다. 응답하지 않거나 시간 내에 응답하지 않는 피어는 불량으로 분류됩니다. PPSPP에서는 콘텐츠가 HTTP와 달리 여러 소스에서 제공되므로 피어가 특정 소스에서 콘텐츠를 얻으려고 너무 많은 노력을 투자해서는 안 된다는 아이디어입니다. 좋음 또는 나쁨의 분류를 통해 피어는 느리고, 충돌하고, \(자동\) 악의적인 피어를 처리할 수 있습니다.

전송을 위해 여러 메시지를 단일 데이터그램으로 다중화해야 합니다. 단일 데이터그램의 메시지는 데이터그램에 나타나는 엄격한 순서에 따라 처리되어야 합니다. 데이터그램에서 유효하지 않은 메시지가 발견되면 나머지 메시지는 폐기되어야 합니다.

단순화를 위해 한 피어 집단은 하나의 콘텐츠 파일 또는 스트림만 처리합니다. 콘텐츠 게시자가 결정한 바에 따라 떼의 모든 피어가 준수하는 청크로 콘텐츠가 단일 분할됩니다. 파일 모음의 배포는 여러 떼를 사용하거나 프로토콜에 투명하게 단일 떼의 선형 바이트 공간에서 다른 파일로 매핑되는 외부 저장소를 사용하여 수행할 수 있습니다. 즉, 사용된 오디오/비디오 컨테이너 형식은 이 문서의 범위를 벗어납니다.

---
### **3.1.  HANDSHAKE**

Peer P가 Swarm S에서 Peer Q와 통신을 설정하려면 먼저 Peer가 핸드셰이크 절차를 통해 HANDSHAKE 메시지를 교환해야 합니다. 시작 피어 P는 다음으로 구성된 Swarm S의 메타데이터를 알아야 합니다.

\(a\) 콘텐츠의 군집 ID\(섹션 5.1 및 6 참조\),

\(b\) 사용된 청크 크기

\(c\) 사용된 청크 주소 지정 방법,

\(d\) 사용된 콘텐츠 무결성 보호 방법, 그리고

\(e\) 사용된 Merkle 해시 트리 함수\(해당되는 경우\).

\(f\) 자동 콘텐츠 크기 감지\(섹션 5.6 참조\)가 사용되지 않는 경우 콘텐츠 길이도 메타데이터\(정적 콘텐츠의 경우\)의 일부입니다.

이 문서에서는 Swarm 메타데이터가 신뢰할 수 있는 소스에서 얻은 것으로 가정합니다. 또한 피어 P는 피어 검색/추적 프로토콜에서 얻은 피어 Q의 전송 주소를 알아야 합니다.

HANDSHAKE 메시지의 페이로드에는 일련의 프로토콜 옵션이 포함되어 있습니다. 프로토콜 옵션은 방금 설명한 떼 메타데이터를 인코딩하여 피어가 올바른 떼에 있는지 확인하기 위한 엔드투엔드 검사를 활성화합니다. 또한 옵션은 피어별 구성 매개변수의 수를 인코딩합니다. 전체 프로토콜 옵션 세트는 섹션 7에 지정되어 있습니다. HANDSHAKE 메시지에는 다중화 통신 및 보안을 위한 채널 ID도 포함되어 있습니다\(섹션 3.11 및 12.1 참조\). HANDSHAKE 메시지는 항상 데이터그램의 첫 번째 메시지여야 합니다.

---
#### **3.1.1.  Handshake Procedure**

Swarm S에서 Peer P가 다른 Peer Q와 통신을 시작하기 위한 핸드셰이크 절차는 다음과 같습니다.

1. 시작하는 피어 P가 피어 Q로 보내는 첫 번째 데이터그램은 HANDSHAKE 메시지로 시작해야 합니다. 이 HANDSHAKE 메시지에는 다음이 포함되어야 합니다.

```text
       *  A channel ID, chanP, randomly chosen as specified in
          Section 12.1.

       *  The metadata of Swarm S, encoded as protocol options, as
          specified in Section 7.  In particular, the initiating Peer P
          MUST include the swarm ID.

       *  The capabilities of Peer P, in particular, its supported
          protocol versions, "Live Discard Window" (in case of a live
          swarm) and "Supported Messages", encoded as protocol options.

       This first datagram MUST be prefixed with the (destination)
       channel ID 0; see Section 3.11.  Hence, the datagram contains two
       channel IDs: the destination channel ID prefixed to the datagram
       and the channel ID chanP included in the HANDSHAKE message inside
       the datagram.  This datagram MAY also contain some minor
       additional payload, e.g., HAVE messages to indicate Peer P's
       current progress, but it MUST NOT include any heavy payload
       (defined in Section 1.3), such as a DATA message.  Allowing minor
```

- 페이로드는 초기화 왕복 횟수를 최소화하여 재생 시간을 향상시킵니다. 무거운 페이로드를 금지하면 증폭 공격이 방지됩니다\(섹션 12.1 참조\).

1. 수신 피어 Q는 피어 P로부터 HANDSHAKE 메시지를 확인합니다. 피어 Q의 확인이 실패하거나 피어 P와 Q가 동일한 떼에 없는 경우 피어 Q는 HANDSHAKE\(또는 기타\) 메시지를 다시 보내서는 안 됩니다. 피어 P의 메시지가 스푸핑되었을 수 있기 때문입니다\(섹션 12.1 참조\). 그렇지 않고 피어 Q가 피어 P와 통신하는 데 관심이 있는 경우 피어 Q는 HANDSHAKE 메시지로 시작하는 데이터그램을 피어 P에 보내야 합니다. 이 답글 HANDSHAKE에는 다음이 포함되어야 합니다.

```text
       *  A channel ID, chanQ, randomly chosen as specified in
          Section 12.1.

       *  The metadata of Swarm S, encoded as protocol options, as
          specified in Section 7.  In particular, the responding Peer Q
          MAY include the swarm ID.

       *  The capabilities of Peer Q, in particular, its supported
          protocol versions, its "Live Discard Window" (in case of a
          live swarm) and "Supported Messages", encoded as protocol
          options.
```

- 이 응답 데이터그램에는 첫 번째 HANDSHAKE 메시지에서 피어 P가 전송한 채널 ID chanP가 앞에 붙어야 합니다\(섹션 3.11 참조\). 이 응답 데이터그램에는 피어 Q의 현재 진행 상황을 나타내는 메시지가 있거나 REQUEST 메시지\(섹션 3.7 참조\)와 같은 일부 사소한 추가 페이로드가 포함될 수도 있지만 과도한 페이로드는 포함되어서는 안 됩니다.

1. 시작 피어 P는 피어 Q의 응답 데이터그램을 확인합니다. 응답 데이터그램에 \(대상\) 채널 ID chanP가 앞에 붙지 않은 경우 피어 P는 데이터그램을 폐기해야 합니다. 피어 P는 이 요구 사항을 충족하는 피어 Q의 데이터그램을 계속 처리해야 합니다. 이 검사는 스푸핑에 의한 간섭을 방지합니다. 섹션 12.1을 참조하세요. 피어 P의 채널 ID가 올바르게 에코되면 개시자 피어 P는 주소가 지정된 피어 Q가 실제로 응답한다는 것을 알게 됩니다.

1. 다음으로, 피어 P는 피어 Q의 데이터그램에서 HANDSHAKE 메시지를 확인합니다. 피어 P의 확인이 실패하거나 피어 P가 더 이상 피어 Q와의 통신에 관심이 없으면 피어 P는 HANDSHAKE 메시지를 보내 피어 Q에게 이를 알릴 수 있습니다. 통신을 중단하게 됩니다. 이 종료 HANDSHAKE 메시지는 모두 0인 채널 ID와 프로토콜 옵션 목록을 포함해야 합니다. 목록은 비어 있거나 \[RFC6709\], 섹션 4.1에 정의된 최소/최대 버전 관리 체계에 따라 피어 P가 지원하는 최대 버전 번호를 포함해야 합니다.

- 이 종료 HANDSHAKE 메시지를 포함하는 데이터그램에는 \(대상\) 채널 ID chanQ가 앞에 붙어야 합니다. 피어 P는 단순히 통신을 중단할 수도 있습니다.

1. 주소가 지정된 피어인 피어 Q가 피어 P의 첫 번째 데이터그램 시작에 응답하지 않는 경우 피어 P는 섹션 3.12에 지정된 규칙에 따라 피어 Q가 죽은 것으로 간주될 때까지 해당 데이터그램을 다시 보낼 수 있습니다.

1. 피어 Q의 응답 데이터그램이 피어 P의 검사를 통과하고 피어 P가 피어 Q와 계속 상호 작용하기를 원하는 경우 피어 P는 이제 REQUEST, PEX\_REQ 및 기타 메시지를 피어 Q에 보낼 수 있습니다. 이러한 메시지를 전달하는 데이터그램은 반드시 피어 Q가 보낸 채널 ID chanQ가 앞에 붙습니다. 보다 구체적으로 피어 P는 피어 Q가 실제로 응답한다는 것을 알고 있기 때문에 피어 P는 무거운 페이로드로 피어 Q 메시지를 보내기 시작할 수 있습니다. 이는 피어 P가 피어 Q가 DATA 메시지와 함께 첫 번째 응답 데이터그램에서 보낸 REQUEST 메시지에 응답하기 시작할 수 있음을 의미합니다. 따라서 PPSPP에서는 청크 전송이 곧 시작될 수 있습니다.

1. 피어 Q가 채널 ID chanQ를 포함하지 않는 피어 P로부터 \(분명히\) 데이터그램을 수신하는 경우 피어 Q는 데이터그램을 폐기해야 하지만 이 요구 사항을 충족하는 피어 P의 데이터그램을 계속 처리해야 합니다. 피어 Q가 채널 ID chanQ를 포함하는 피어 P로부터 데이터그램을 수신하면 피어 Q는 피어 P가 실제로 응답 데이터그램을 받았음을 알고 3방향 핸드셰이크 및 채널 설정이 완료됩니다. 피어 Q는 이제 피어 P에 페이로드가 많은 메시지를 보내기 시작할 수도 있습니다.

1. 피어 P가 더 이상 피어 Q와 통신하기를 원하지 않는다고 결정하거나 그 반대의 경우, 피어는 위에서 설명한 대로 상대방에게 종료 HANDSHAKE 메시지를 보내야 합니다.

---
### **3.2.  HAVE**

HAVE 메시지는 피어가 다운로드할 수 있는 청크를 전달하는 데 사용됩니다. 사용 가능한 청크 세트는 섹션 4에 설명된 다양한 청크 주소 지정 및 가용성 맵 압축 체계를 사용하여 표현될 수 있습니다. HAVE 메시지는 피어의 청크 가용성에 대한 전체 개요를 전송하고 해당 세트에 대한 업데이트를 위해 사용될 수 있습니다.

특히, 수신 피어 P가 청크의 무결성이나 청크 간격을 성공적으로 검사할 때마다 해당 청크를 다운로드하도록 허용하려는 모든 피어 Q1..Qn에게 HAVE 메시지를 보내야 합니다. 피어 P의 정책은 HAVE가 전송되는 시기를 결정합니다. 피어 P는 이를 직접 보낼 수도 있고, 피어 P는 피어 Qi로 보낼 다른 데이터가 있을 때까지 또는 여러 개를 수신하고 확인할 때까지 기다릴 수도 있습니다.

덩어리. 정책은 이 정보를 다른 동료에게 배포하는 것이 얼마나 긴급한지에 따라 달라집니다. 이 긴급성은 일반적으로 청크 선택 정책에 따라 결정됩니다\(섹션 9.1 참조\). 일반적으로 HAVE 메시지는 다른 메시지에 피기백될 수 있습니다. HAVE 메시지를 받지 않은 피어는 새로 사용 가능한 청크를 다운로드하는 것이 효과적으로 방지됩니다. 따라서 HAVE 메시지는 질식 방법으로 사용될 수 있습니다.

HAVE 메시지에는 수신되고 검증된 청크의 청크 사양이 포함되어야 합니다. 수신 피어는 핸드셰이크 절차가 아직 완료되지 않은 피어에게 HAVE 메시지를 보내서는 안 됩니다\(섹션 12.1 참조\). 피어는 이미 완전한 콘텐츠를 가지고 있는 피어에게 HAVE 메시지를 보내면 안 됩니다\(예: 주문형 비디오 시나리오\).

---
### **3.3.  DATA**

DATA 메시지는 콘텐츠 청크를 전송하는 데 사용됩니다. DATA 메시지에는 청크의 청크 ID와 청크 자체가 포함되어야 합니다. 피어는 동일한 데이터그램의 여러 청크에 대한 DATA 메시지를 보낼 수 있습니다. DATA 메시지에는 사용된 특정 혼잡 제어 메커니즘에 필요한 경우 추가 정보가 포함될 수 있습니다. 현재 PPSPP는 혼잡 제어를 위해 LEDBAT \[RFC6817\]을 사용하는데, 이를 위해서는 현재 시스템 시간이 DATA 메시지와 함께 전송되어야 하므로 현재 시스템 시간이 포함되어야 합니다.

---
### **3.4.  ACK**

PPSPP가 신뢰할 수 없는 전송 프로토콜을 통해 실행되는 경우 수신된 청크를 확인하기 위해 ACK 메시지를 보내야 합니다. 신뢰할 수 있는 전송 프로토콜이 사용되는 경우 ACK 메시지가 전송될 수 있습니다. 전자의 경우 청크의 무결성이나 청크 C의 간격을 성공적으로 확인한 수신 피어는 C에 대한 청크 사양이 포함된 ACK 메시지를 보내야 합니다. LEDBAT가 사용되므로 ACK 메시지에는 단방향 정보가 포함되어야 합니다. 지연은 DATA 메시지에서 수신된 피어의 현재 시스템 시간에서 계산됩니다. 피어는 LEDBAT 사양 \[RFC6817\]에 정의된 대로 ACK 메시지 전송을 지연할 수 있습니다.

---
### **3.5.  INTEGRITY**

INTEGRITY 메시지는 수신자가 청크의 무결성을 확인하는 데 필요한 정보를 전달합니다. 페이로드는 사용되는 콘텐츠 무결성 보호 체계에 따라 다릅니다. Merkle Hash Tree 체계가 사용되는 경우 INTEGRITY 메시지에는 Merkle 해시 트리의 하위 트리에 대한 암호화 해시와 하위 트리를 식별하는 청크 사양이 포함되어야 합니다.

일반적인 예로, 피어가 청크를 전송하려고 하고 Merkle 해시 트리가 사용되는 경우 수신자가 청크를 확인하는 데 필요한 해시와 DATA 메시지에 인코딩된 실제 청크 자체를 포함하는 여러 INTEGRITY 메시지로 구성된 데이터그램을 생성합니다. . 필요한 해시는 무엇이며 이를 데이터그램으로 인코딩하기 위한 정확한 규칙은 각각 섹션 5.3 및 5.4에 지정되어 있습니다.

---
### **3.6.  SIGNED_INTEGRITY**

SIGNED\_INTEGRITY 메시지는 수신자가 라이브 스트리밍에서 청크의 무결성을 확인하는 데 필요한 디지털 서명된 정보를 전달합니다. 여기에는 논리적으로 청크 사양, 타임스탬프 및 디지털 서명이 포함됩니다. 정확한 페이로드는 사용되는 라이브 콘텐츠 무결성 보호 체계에 따라 다릅니다. 섹션 6.1을 참조하세요.

---
### **3.7.  REQUEST**

대량 다운로드 프로토콜은 일반적으로 특정 범위의 데이터에 대해 명시적인 요청을 수행하는 반면\(예: BitTorrent \[BITTORRENT\]와 같은 풀 모델 사용\) 라이브 스트리밍 프로토콜은 왕복을 저장하기 위해 요청 없이 푸시 모델을 사용하는 경우가 많습니다. PPSPP는 두 가지 작동 모델을 모두 지원합니다.

REQUEST 메시지는 다른 피어로부터 하나 이상의 청크를 요청하는 데 사용됩니다. REQUEST 메시지에는 요청자가 다운로드하려는 청크의 사양이 포함되어야 합니다. REQUEST 메시지를 수신한 피어는 요청된 청크를 \(DATA 메시지를 통해\) 보낼 수 있습니다. 피어 Q가 동일한 피어 P로부터 여러 REQUEST를 수신하면 피어 Q는 수신된 순서대로 REQUEST를 처리해야 합니다. 예를 들어, 피어가 여러 희귀 청크를 동시에 요청하려는 경우 여러 REQUEST 메시지가 하나의 데이터그램으로 전송될 수 있습니다.

푸시 모델을 통해 라이브 스트리밍할 때 REQUEST를 수신하는 피어는 요청이 부족하거나 다른 이유로 인해 다른 청크를 보낼 수도 있습니다. 이 경우 REQUEST 메시지의 유일한 목적은 힌트를 제공하고 피어를 조정하여 불필요한 데이터 재전송을 방지하는 것입니다.

---
### **3.8.  CANCEL**

주문형 또는 라이브 스트리밍 콘텐츠를 다운로드할 때 피어는 여러 피어에게 긴급 데이터를 요청하여 시간에 맞춰 배달될 확률을 높일 수 있습니다. 특히, 특정 청크 선택 알고리즘\(섹션 9.1 참조\)이 긴급 데이터에 대한 요청이 제 시간에 제공되지 않을 수 있음을 감지하면 동일한 데이터에 대한 요청이 다른 피어로 전송될 수 있습니다. 피어 P가 피어 Q로부터 긴급 데이터를 요청하기로 결정하면 피어 P는 이전에 데이터를 요청한 모든 피어에게 취소 메시지를 보내야 합니다. 그만큼

CANCEL 메시지에는 피어 P가 더 이상 요청하지 않으려는 청크의 사양이 포함되어 있습니다. 또한 Peer Q가 Peer P로부터 긴급 데이터에 대한 HAVE 메시지를 수신하면 Peer Q는 Peer P의 이전 REQUEST도 취소해야 합니다. 즉, HAVE 메시지는 암시적인 CANCEL 역할을 합니다.

---
### **3.9.  CHOKE and UNCHOKE**

피어 A는 피어 B에 CHOKE 메시지를 보내 피어 B가 더 이상 REQUEST 메시지에 응답하지 않는다는 신호를 보낼 수 있습니다. 예를 들어 피어 A의 업로드 용량이 소진되었기 때문입니다. 피어 A는 피어 B의 새로운 요청에 다시 응답할 것이라는 신호를 보내기 위해 후속 UNCHOKE 메시지를 보낼 수 있습니다\(피어 A는 이전 요청을 폐기해야 합니다\). 피어 B가 피어 A로부터 CHOKE 메시지를 수신하면 새로운 REQUEST 메시지를 보내서는 안 되며 청크 전송이 차단되므로 미해결 메시지에 대한 응답을 기대할 수 없습니다. 피어 B가 차단되었지만 피어 A로부터 HAVE 메시지를 수신하면 자동으로 초크가 해제되지 않으며 새로운 REQUEST 메시지를 보내면 안 됩니다. CHOKE 및 UNCHOKE 메시지는 REQUEST에 대한 응답이 선택 사항이므로 정보 제공용입니다\(섹션 3.7 참조\).

---
### **3.10.  Peer Address Exchange**
---
#### **3.10.1.  PEX_REQ and PEX_RES Messages**

PEX\(Peer Exchange\) 메시지는 많은 피어 투 피어 프로토콜에서 일반적입니다. 이를 통해 피어는 현재 상호 작용 중인 피어의 전송 주소를 교환할 수 있으므로 새로운 피어를 발견하기 위해 중앙 추적기\(또는 분산 해시 테이블\)에 연결할 필요성이 줄어듭니다. 따라서 이 메커니즘의 강점은 분산된 피어 검색을 가능하게 한다는 것입니다. 초기 부트스트랩 후에는 중앙 추적기가 더 이상 필요하지 않습니다. 이 프로그램의 약점은 다수의 공격이 가능하다는 점이므로 추가 보안 조치가 마련되지 않는 한 인터넷에서 사용해서는 안 됩니다.

PPSPP는 특정 조건에서 선택적 기능\(구현 필수는 아님\)으로 인터넷 및 양성 개인 네트워크에서 피어 주소 교환을 지원합니다. 일반적인 메커니즘은 다음과 같이 작동합니다. 일부 피어 주소를 얻기 위해 피어 A는 피어 B에 PEX\_REQ 메시지를 보낼 수 있습니다. 피어 B는 하나 이상의 PEX\_REScert 메시지로 응답할 수 있습니다. 논리적으로 PEX\_REScert 응답 메시지에는 단일 피어 Ci의 주소가 포함됩니다. Peer B는 활성 상태를 보장하기 위해 지난 60초 동안 Peer Ci와 메시지를 교환해야 합니다. 수신 시 피어 A는 반환된 피어 Ci 중 일부에 연락하거나 전혀 연락하지 않을 수 있습니다. 또는 피어는 새 피어를 얻는 데 관심이 없거나 보안 고려 사항\(속도 제한\) 또는 기타 이유로 인해 PEX\_REQ 및 PEX\_REScert 메시지를 무시할 수 있습니다. PEX 메시지는 전용 추적기 피어를 구성하는 데 사용될 수 있습니다.

인터넷의 PPSPP에서 PEX를 사용하려면 두 가지 조건을 충족해야 합니다.

1. 피어 전송 주소는 비교적 안정적이어야 합니다.

1. 피어는 PEX를 통해 모든 피어 주소를 얻어서는 안됩니다.

PEX 메시지에 대한 전체 보안 분석은 섹션 12.2에서 확인할 수 있습니다. 물리적으로 PEX\_REScert 메시지는 IP 주소와 포트가 아닌 스웜 멤버십 인증서를 전달합니다. 피어 C의 멤버십 인증서에는 주소\(ipC,portC\)의 피어 C가 시간 T에 Swarm S의 일부이며 발급자에 의해 암호화된 서명이 있음이 명시되어 있습니다. 수신자 피어 A는 인증서에서 신뢰할 수 있는 발급자의 유효한 서명, 올바른 스웜 및 활성 여부를 확인한 후 C에 문의하는 것을 고려할 수 있습니다. 이러한 스웜 멤버쉽 인증서는 보안 분산 피어 샘플링 서비스\(SPS\)의 서명된 노드 설명자에 해당합니다.

이러한 회원증에 대한 보안 환경은 여러 가지 설계가 가능합니다. 즉, 회원 인증서에 서명하는 사람과 공개 키가 배포되는 방식에 대해 다양한 설계가 가능합니다. 섹션 12.2.2에서는 중앙 추적기가 인증 기관 역할을 하는 예를 설명합니다.

인터넷과 같은 적대적인 환경에서 피어는 피어-주소 교환 기능을 사용할 때 악의적인 피어와만 상호 작용하도록 종료되지 않도록 해야 합니다. 이 정도까지 피어는 연결의 일부가 신뢰할 수 있고 보안이 유지되는 추적기에서 나온 주소를 가진 피어에 대한 것인지 확인해야 합니다\(섹션 12.2.3 참조\).

PEX\_REScert 외에도 두 개의 다른 PEX 응답 메시지가 있습니다. PEX\_RESv4 메시지에는 단일 IPv4 주소와 포트가 포함됩니다. PEX\_RESv6 메시지에는 단일 IPv6 주소와 포트가 포함됩니다. 주소가 지정된 호스트가 실제로 PPSPP 떼에 참여한다는 보장을 제공하지 않으므로 개인 네트워크와 같은 온화한 환경에서만 사용해야 합니다.

PPSPP 구현이 PEX, 중앙 추적기 또는 DHT\(분산 해시 테이블\)를 통해 피어 목록을 얻은 후에는 실제로 연결할 피어를 결정해야 합니다. 이 프로세스에서 PPSPP 구현은 네트워크 또는 콘텐츠 공급자의 정보를 활용하여 네트워크 사용량을 개선하고 PPSPP 성능을 향상시킬 수 있습니다. PPSPP와 같은 P2P\(Peer-to-Peer\) 시스템이 ALTO\(Application-Layer Traffic Optimization\) 프로토콜을 사용하여 이러한 최적화를 수행할 수 있는 방법은 \[RFC7285\], 섹션 7에 자세히 설명되어 있습니다.

---
### **3.11.  Channels**

NAT와 방화벽으로 인해 피어 간 통신이 점점 더 복잡해지고 있습니다. 따라서 PPSPP는 채널이라는 다중화 방식을 사용하여 여러 떼가 동일한 전송 주소를 사용할 수 있도록 합니다. 그림 1에 표시된 것처럼 채널은 느슨하게 TCP 연결에 해당하며 각 채널은 단일 스웜에 속합니다. TCP 연결과 마찬가지로 채널은 연결의 각 끝에서 피어에 로컬인 고유 식별자로 식별됩니다\(TCP 포트 참조\). , 무작위로 선택되어야 합니다. 즉, 채널로 연결된 두 피어는 서로 다른 ID를 사용하여 동일한 채널을 나타냅니다. 보안상의 이유로 ID는 다르며 무작위입니다. 섹션 12.1을 참조하세요.

PPSP-over-UDP 캡슐화\(8.3절\)에서 피어 A와 피어 B 사이에 채널 C가 설정되면 피어 A에서 피어 B로의 메시지를 포함하는 데이터그램에는 피어 B가 할당한 4바이트 채널 ID가 앞에 붙습니다. , 피어 B에서 A로의 데이터그램의 경우 그 반대입니다. 사용된 채널 ID는 핸드셰이크 절차의 일부로 교환됩니다\(섹션 8.4 참조\). 해당 절차에서는 값이 0인 채널 ID가 핸드셰이크를 시작하는 데이터그램에 사용됩니다. PPSPP는 STUN\(Session Traversal Utilities for NAT\) \[RFC5389\]과 함께 사용할 수 있습니다.

```text
               _________    _________          _________
               |       |    |       |          |       |
               | Swarm |    | Swarm |          | Swarm |
               |  Mgr  |    |   A   |          |   B   |
               |_______|    |_______|          |_______|
                   |            |                /   \
                   |            |               /     \
               ____|____    ____|____    ______/__    _\_______
               |       |    |       |    |       |    |       |
               | Chan  |    | Chan  |    | Chan  |    | Chan  |
               |   0   |    |  481  |    |  836  |    |  372  |
               |_______|    |_______|    |_______|    |_______|
                   |            |            |            |
                   |            |            |            |
               ____|____________|____________|____________|____
               |                                              |
               |                      UDP                     |
               |                   port 6778                  |
               |______________________________________________|

   Network stack of a PPSPP peer that is reachable on UDP port 6778 and
   is connected via channel 481 to one peer in Swarm A and two peers in
     Swarm B via channels 836 and 372, respectively.  Channel ID 0 is
                   special and is used for handshaking.

                                 Figure 1
```

---
### **3.12.  Keep Alive Signaling**

피어는 관심 있는 각 피어에게 주기적으로 "연결 유지" 메시지를 보내야 하지만 현재는 보낼 다른 메시지가 없습니다. 연결 유지의 목표는 관심 있는 피어에게 신호 채널을 열어 두는 것입니다. 어떤 피어가 현재와 가까운 미래에 관심이 있는지 결정하는 정책에 따라 결정됩니다. 이 문서는 정책을 규정하지는 않지만 흥미로운 피어의 예로는 \(a\) 이 클라이언트에 필요한 청크가 제공되는 피어 또는 \(b\) 현재 제공되는 흥미로운 청크가 없는 피어\(아직 스스로 다운로드 중이기 때문에 또는 라이브 스트리밍\)이지만 과거에는 좋은 성적을 냈습니다. 이러한 피어에 제공할 새 청크가 있으면 신호 채널을 열어 둔 피어가 이를 다시 사용할 수 있습니다. "연결 유지" 메시지를 주기적으로 보내면 다른 피어가 해당 피어를 종료했다고 선언하는 것을 방지할 수 있습니다. UDP를 사용할 때 피어를 비활성 상태로 선언하는 지침은 마지막 패킷이 해당 피어로부터 수신된 후 3분의 지연과 동일한 기간 동안 해당 피어로 최소 3개의 데이터그램이 전송된 것으로 구성됩니다. 피어가 죽은 것으로 선언되면 해당 피어에 대한 채널이 닫히고 더 이상 해당 피어로 메시지가 전송되지 않으며

피어에 대한 로컬 관리는 삭제됩니다. 바쁜 서버는 연결 유지를 보내지 않음으로써 유휴 클라이언트의 연결을 강제로 끊을 수 있습니다. PPSPP는 "연결 유지" 메시지에 대한 명시적 메시지 유형을 정의하지 않습니다. PPSP-over-UDP 캡슐화에서는 4바이트 채널 ID로만 구성된 간단한 데이터그램으로 구현됩니다. 섹션 8.3 및 8.4를 참조하세요.

---
## **4.  Chunk Addressing Schemes**

PPSPP는 다양한 청크 주소 지정 방법을 사용할 수 있습니다. 즉, 청크를 식별하는 다양한 방법과 피어의 청크 가용성 맵을 간결한 방식으로 표현하는 다양한 방법을 지원합니다.

떼의 모든 피어는 동일한 청크 주소 지정 방법을 사용해야 합니다.

---
### **4.1.  Start-End Ranges**

청크 사양은 청크 범위\(끝 포함\)를 식별하는 단일\(시작 사양, 종료 사양\) 쌍으로 구성됩니다. 시작 및 끝 사양은 여러 주소 지정 체계 중 하나를 사용할 수 있습니다. 현재 청크 범위와 바이트 범위라는 두 가지 체계가 정의되어 있습니다.

---
#### **4.1.1.  Chunk Ranges**

시작 및 끝 사양은 모두 청크 식별자입니다. 청크 식별자는 32비트 또는 64비트 부호 없는 정수입니다. PPSPP 피어는 이 체계를 지원해야 합니다.

```text
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   ~                    Start chunk (32 or 64)                     ~
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   ~                    End chunk (32 or 64)                       ~
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

---
#### **4.1.2.  Byte Ranges**

시작 및 끝 사양은 콘텐츠의 64비트 바이트 오프셋입니다. 이 체계에 대한 지원은 선택 사항입니다.

```text
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                    Start byte offset (64)                     |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                    End byte offset (64)                       |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

---
### **4.2.  Bin Numbers**

PPSPP는 "빈 번호"\(또는 줄여서 "빈"\)라는 콘텐츠 덩어리를 처리하는 새로운 방법을 도입합니다. Bin 번호를 사용하면 단일 정수를 사용하여 데이터의 이진 간격 주소를 지정할 수 있습니다. 이는 피어당 기록해야 하는 상태의 양과 회선의 간격을 표시하는 데 필요한 공간을 줄여 프로토콜을 가볍게 만듭니다. 일반적으로 이 번호 지정 시스템을 사용하면 PPSPP가 이진 트리 대신 배열을 사용하는 등 더 간단한 데이터 구조로 작동하여 복잡성을 줄일 수 있습니다. 이 체계에 대한 지원은 선택 사항입니다.

Bin 주소 지정에서 가장 작은 바이너리 간격은 단일 청크\(예: 가변 크기일 수 있는 바이트 블록\)이고, 가장 큰 간격은 2\*\*63 청크의 전체 범위입니다. 고전적인 방식에 새로운 추가 기능을 추가하면 이러한 간격은 다음과 같이 빈 번호 매기기라고 불리는 벡터로 멋지게 배치되는 방식으로 번호가 매겨집니다. 너비 W의 청크 간격을 고려하십시오. 전체 간격과 하위 간격의 Bin 번호를 도출하기 위해 기본에서 최소 W 청크 너비의 최소 균형 이진 트리가 구축됩니다. 왼쪽에서 오른쪽으로의 잎은 간격의 청크 0..W-1에 해당하며, I는 청크의 인덱스인 bin 번호 I\*2를 갖습니다\(트리 균형을 맞추기 위해 W-1 이상으로 계산\). 트리에서 상위 노드 P의 Bin 번호는 다음과 같이 계산됩니다.

```text
       binP = (binL + binR) / 2
```

여기서 binL은 노드 P의 왼쪽 자식의 bin이고 binR은 노드 P의 오른쪽 자식의 bin입니다. 트리의 각 노드가 원래 간격의 하위 간격을 나타내는 경우 이제 이러한 각 하위 간격은 단일 정수인 Bin 번호로 주소를 지정할 수 있습니다. 너비 W=8 간격의 빈 번호 트리는 다음과 같습니다.

```text
                                   7
                                  / \
                                /     \
                              /         \
                            /             \
                           3                11
                          / \              / \
                         /   \            /   \
                        /     \          /     \
                       1       5        9       13
                      / \     / \      / \      / \
                     0   2   4   6    8   10  12   14

                     C0  C1  C2  C3   C4  C5  C6   C7

              The bin number tree of an interval of width W=8

                                 Figure 2
```

따라서 bin 7은 전체 간격을 나타내고, bin 3은 청크 C0..C3의 간격을 나타내고, bin 1은 청크 C0 및 C1의 간격을 나타내고, bin 2는 청크 C1을 나타냅니다. 특수 숫자 0xFFFFFFFF\(32비트\) 또는 0xFFFFFFFFFFFFFFFF\(64비트\)는 빈 간격을 나타내고 0x7FFF...FFF는 "모든 것"을 나타냅니다.

Bin 번호 지정이 사용되는 경우 청크의 ID는 트리의 해당\(리프\) Bin 번호이며, HAVE 및 ACK 메시지의 청크 사양은 다음과 같이 단일 Bin 번호\(32비트 또는 64비트\)와 같습니다. 다음과 같습니다.

```text
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   ~                    Bin number (32 or 64)                      ~
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

---
### **4.3.  In Messages**
---
#### **4.3.1.  In HAVE Messages**

수신 피어가 청크의 무결성 또는 청크 간격을 성공적으로 확인한 경우 해당 청크의 다운로드를 허용하려는 모든 피어에게 HAVE 메시지를 보내야 합니다. HAVE 메시지를 보류하는 기능을 통해 메시지를 질식시키는 방법으로 사용할 수 있습니다. HAVE 메시지에는 수신자가 방금 수신한 청크의 간격을 완전히 포함하여 지금까지 수신하고 확인한 모든 청크 중 가장 큰 전체 간격의 청크 사양이 포함되어야 합니다. 그래서

청크 사양은 최소한 수신된 간격을 나타내야 하지만 수신자는 가능한 경우 더 큰 간격을 집계하고 승인해야 합니다.

결과적으로 모든 단일 청크는 로그 횟수만큼 인식됩니다. 이는 승인에 필요한 일부 중복성을 제공하고 신뢰할 수 없는 전송 프로토콜을 충분히 보상합니다.

```text
   Implementation note:
```

- 구현이 각 피어에 대해 유지하는 상태에서 피어가 어떤 청크를 가지고 있는지 기록하기 위해 구현은 \[BINMAP\]에서 자세히 논의되는 비트맵과 이진 트리의 하이브리드인 효율적인 "binmap" 데이터 구조를 사용할 수 있습니다. .

---
#### **4.3.2.  In ACK Messages**

PPSPP 피어는 신뢰할 수 없는 전송 프로토콜이 사용되는 경우 수신된 청크를 확인하기 위해 ACK 메시지를 사용해야 합니다. 수신 피어가 청크 또는 청크 C의 간격의 무결성을 성공적으로 확인한 경우 C를 포함하는 가장 크고 완전한 간격의 청크 사양이 포함된 ACK 메시지를 송신 피어에게 보내야 합니다\(HAVE 참조\).

---
## **5.  Content Integrity Protection**

PPSPP는 P2P 네트워크를 통해 콘텐츠가 배포되는 동안 콘텐츠의 무결성을 보호하기 위해 다양한 방법을 사용할 수 있습니다. 보다 구체적으로 PPSPP는 수신 피어에 대해 다양한 방법을 사용하여 요청된 청크가 송신 피어에 의해 악의적으로 수정되었는지 여부를 감지할 수 있습니다. 정상적인 환경에서는 콘텐츠 무결성 보호를 비활성화할 수 있습니다.

정적 콘텐츠의 경우 PPSPP는 현재 Merkle Hash Tree 체계라고 하는 무결성 보호를 위한 한 가지 방법을 정의합니다. PPSPP가 인터넷을 통해 작동하는 경우 이 체계를 사용해야 합니다. PPSPP가 양호한 환경에서 작동하는 경우 이 방식을 사용할 수 있습니다. 따라서 IETF 프로토콜 \[RFC3365\]에 대한 강력한 보안 요구 사항을 충족하려면 이 체계를 구현해야 합니다. 아래 및 섹션 6.1에 설명된 대로 확장된 버전의 체계를 사용하여 동적으로 생성된 콘텐츠\(라이브 스트림\)를 효율적으로 보호합니다.

Merkle Hash Tree 체계는 다양한 청크 주소 지정 체계와 함께 작동할 수 있습니다. 필요한 것은 다양한 청크를 처리하는 능력뿐입니다. 다음 설명에서 추상 노드 ID는 트리의 노드를 식별하는 데 사용됩니다. 연결 시에는 선택한 청크 주소 지정 체계의 해당 청크 범위로 변환됩니다.

---
### **5.1.  Merkle Hash Tree Scheme**

PPSPP는 자체 인증을 기반으로 콘텐츠에 이름을 지정하는 방법을 사용합니다. 특히 PPSPP의 콘텐츠는 콘텐츠 \[ABMRKL\]에서 재귀적으로 계산된 Merkle 해시 트리의 루트 해시인 단일 암호화 해시로 식별됩니다. 이 자체 인증 해시 트리를 통해 모든 피어는 악의적인 피어가 가짜 콘텐츠를 배포하려고 시도할 때 직접 감지할 수 있습니다. 또한 다운로드를 시작하는 데 필요한 정보의 양\(루트 해시 및 일부 피어 주소\)이 최소화됩니다. 라이브 스트리밍의 경우 동적 트리와 공개 키가 사용됩니다. 아래를 참조하세요.

N개의 청크로 나누어진 콘텐츠 파일의 머클 해시 트리는 다음과 같이 구성된다. 구성에서는 콘텐츠 덩어리가 고정된 크기라고 가정하지 않습니다. 암호화 해시 함수, 보다 구체적으로 SHA-256과 같은 MDC \[HAC01\]가 주어지면 모든 콘텐츠 청크의 해시가 계산됩니다. 다음으로, 충분한 높이의 이진 트리가 생성됩니다. 충분한 높이란 빈 번호 매기기와 마찬가지로 트리의 가장 낮은 수준에 세트의 모든 청크 해시를 보유할 만큼 충분한 노드가 있음을 의미합니다. 아래 그림은 7개의 청크로 구성된 콘텐츠 파일의 트리를 보여줍니다. 콘텐츠 주소 지정 체계와 마찬가지로 트리의 잎은 청크에 해당하며 이 경우 가장 왼쪽 잎에서 시작하여 해당 청크의 해시가 할당됩니다. 트리의 베이스가 청크 수보다 넓을 수 있으므로 트리에 남아 있는 모든 리프에는 모두 0인 빈 해시 값이 할당됩니다. 마지막으로 두 하위 항목의 해시 값을 연결하고\(다시 왼쪽에서 오른쪽으로\) 해당 집계의 해시를 계산하여 트리에서 더 높은 수준의 해시 값이 계산됩니다. 두 하위 항목이 빈 해시이면 상위 항목도 모두 0으로 구성된 빈 해시입니다\(계산을 저장하기 위해\). 이 프로세스는 "루트 해시"라고 하는 루트 노드의 해시 값으로 끝납니다. 루트 해시는 콘텐츠에만 의존하며 콘텐츠를 수정하면 루트 해시가 달라집니다.

```text
                               7 = root hash
                              / \
                            /     \
                          /         \
                        /             \
                      3*               11
                     / \              / \
                    /   \            /   \
                   /     \          /     \
                  1       5        9       13* = uncle hash
                 / \     / \      / \      / \
                0   2   4   6    8   10* 12   14

                C0  C1  C2  C3   C4  C5  C6   E
                =chunk index     ^^           = empty hash
```

- N=7 청크로 구성된 콘텐츠 파일의 머클 해시 트리

```text
                                 Figure 3
```

---
### **5.2.  Content Integrity Verification**

피어가 신뢰할 수 있는 소스로부터 다운로드하려는 콘텐츠의 루트 해시를 수신한다고 가정하면 다음과 같이 수신하는 해당 콘텐츠 청크의 무결성을 확인할 수 있습니다. 먼저 수신한 청크의 해시를 계산합니다\(예: 이전 그림의 청크 C4\). 이 청크와 함께 해당 청크의 무결성을 확인하는 데 필요한 해시를 수신해야 합니다. 원칙적으로 이는 청크 형제\(C5\)의 해시와 해당 "삼촌"의 해시입니다. 청크의 삼촌은 루트에 도달할 때까지 재귀적으로 부모 X의 형제 Y이자 해당 Y의 삼촌입니다. 청크 C4의 경우 삼촌은 노드 13과 3이고 형제는 10입니다. 모두 그림에 \*로 표시되어 있습니다. 이 정보를 사용하여 피어는 트리의 루트 해시를 다시 계산하고 이를 신뢰할 수 있는 소스로부터 받은 루트 해시와 비교합니다. 일치하는 경우 콘텐츠 덩어리가 콘텐츠의 요청된 부분인 것으로 확실하게 확인된 것입니다. 그렇지 않으면 보내는 피어가 잘못된 콘텐츠나 잘못된 형제 또는 삼촌 해시를 보냈습니다. 단순화를 위해 형제 및 삼촌 해시 세트를 집합적으로 "삼촌 해시"라고 합니다.

라이브 스트리밍의 경우 청크 트리는 동적으로 커지며 루트 해시는 정의되지 않거나 더 정확하게는 라이브 소스에서 새 데이터가 생성되는 한 일시적입니다. 섹션 6.1.2에서는 이러한 동적 트리와 함께 작동하는 라이브 스트림에 대한 콘텐츠 무결성 확인 방법을 정의합니다. 트리는 동적이지만 콘텐츠 확인은 라이브 콘텐츠와 사전 정의된 콘텐츠 모두에 대해 동일하게 작동하므로 두 스트리밍 유형 모두에 대한 통합 방법이 생성됩니다.

---
### **5.3.  The Atomic Datagram Principle**

위에서 설명한 대로 데이터그램은 일련의 메시지로 구성됩니다. 이상적으로, 전송된 모든 데이터그램은 다른 데이터그램과 독립적이어야 합니다. 각 데이터그램은 별도로 처리되어야 하며, 하나의 데이터그램이 손실되어도 두 피어 간의 데이터그램 흐름이 중단되어서는 안 됩니다. 따라서 데이터그램은 0개 이상의 메시지를 전달하므로 메시지와 메시지 상호 종속성은 모두 여러 데이터그램에 걸쳐 있어서는 안 됩니다.

이 원칙은 모든 청크가 삼촌 해시를 사용하여 확인될 때 필요한 해시가 청크의 데이터와 동일한 데이터그램에 저장되어야 함을 의미합니다. 데이터그램 크기 제한으로 인해 이것이 가능하지 않은 경우 필요한 해시를 하나 이상의 데이터그램에서 먼저 전송해야 합니다. 일반적으로 데이터그램 내의 메시지를 처리하기 위해 일부 추가 데이터가 여전히 누락된 경우 메시지를 삭제해야 합니다.

청크를 검증하는 데 필요한 해시는 원칙적으로 형제 해시와 모든 삼촌 해시이지만 보낼 해시 세트는 최적화될 수 있습니다. 데이터 패킷을 수신자에게 보내기 전에 발신자는 수신자의 이전 승인\(HAVE 또는 ACK\)을 검사하여 수신자가 이미 확실히 갖고 있는 해시가 무엇인지 알아냅니다. 수신자가 청크 C0 및 C1\(파일의 처음 두 청크\)을 확인했다고 가정하면 이미 삼촌 해시 5, 11 등이 있어야 합니다. 이는 루트 해시와 비교하여 C0 및 C1을 확인하는 데 해당 해시가 필요하기 때문입니다. 그러면 해시 3, 7 등도 삼촌 해시 체인을 확인하는 과정에서 계산되기 때문에 알아야 한다. 따라서 청크 C7을 보내려면 발신자는 노드 14와 9에 대한 해시만 포함해야 하며, 이를 통해 수신자에게 이미 알려진 해시 11과 비교하여 데이터를 확인할 수 있습니다.

발신자는 아직 승인되지 않은 이전 데이터그램에서 전송된 해시를 낙관적으로 건너뛸 수 있습니다. 이는 일부 필수 해시가 네트워크에서 손실되어 일부 전달된 데이터를 확인할 수 없어 삭제되어야 하는 경우 중복 해시 전송과 부수적 데이터 손실 가능성 간의 최적화 균형입니다. 두 경우 모두 수신자는 루트 해시부터 시작하여 요청에 따라 Merkle 해시 트리를 점진적으로 구축하고 이를 데이터 검증에 사용합니다.

간단히 말해서, 발신자는 수신자가 청크를 확인하는 데 필요하다고 생각하는 해시를 데이터그램에 넣어야 합니다. 수신자는 여전히 다운로드하려는 누락된 청크를 확인하는 데 필요한 모든 해시를 기억해야 합니다. 후자는 하드웨어 제한이 있는 수신자가 이러한 청크의 소유를 다른 사람에게 알리지 않을 경우\(즉, HAVE 메시지를 보낼 계획이 없는 경우\) 일부 해시를 잊어버릴 수 있음을 의미합니다.

---
### **5.4.  INTEGRITY Messages**

구체적으로, 콘텐츠 덩어리를 전송하려는 피어는 INTEGRITY 메시지 목록과 DATA 메시지로 구성되어야 하는 데이터그램을 생성합니다. 데이터그램 크기 제한으로 인해 INTEGRITY 메시지와 DATA 메시지를 단일 데이터그램에 넣을 수 없는 경우 INTEGRITY 메시지를 하나 이상의 데이터그램에서 먼저 전송해야 합니다. 전송된 INTEGRITY 메시지 목록에는 수신자가 무결성 검사를 위해 놓친 각 해시에 대한 INTEGRITY 메시지가 포함되어야 합니다. 해시에 대한 INTEGRITY 메시지에는 해시의 노드 ID와 해시 데이터 자체에 해당하는 청크 사양이 포함되어야 합니다. 노드 ID에 해당하는 청크 사양은 해당 노드를 루트로 하는 하위 트리의 리프에 의해 형성된 청크의 범위로 정의됩니다. 예를 들어 그림 3의 노드 3은 청크 0, 2, 4, 6을 나타내므로 청크 사양은 해당 간격을 나타내야 합니다. INTEGRITY 메시지 목록은 노드의 트리 높이 순서대로 내림차순으로 정렬되어야 합니다\(리프는 높이 0에 있음\). DATA 메시지에는 청크의 청크 사양과 청크 자체가 포함되어야 합니다. 피어는 캡슐화에 따라 동일한 데이터그램의 여러 청크에 필요한 메시지를 보낼 수 있습니다.

---
### **5.5.  Discussion and Overhead**

BitTorrent \[BITTORRENT\]에서 콘텐츠 무결성을 보호하기 위한 현재 방법은 스트리밍에 적합하지 않습니다. 여기에는 다운로드가 시작되기 전에 메타데이터 파일\(BitTorrent에서는 .torrent 파일이라고 함\)을 통해 콘텐츠 청크의 해시를 클라이언트에 제공하는 작업이 포함됩니다. 그러나 현재 PPSPP의 UDP 캡슐화에서와 같이 청크가 작은 경우 다운로드해야 함을 의미합니다. 콘텐츠 다운로드가 시작되기 전에 많은 수의 해시가 필요합니다. 결과적으로 최종 사용자의 재생 시간이 늘어나 이 방법은 스트리밍에 적합하지 않게 됩니다.

Merkle 해시 트리를 사용하는 오버헤드는 제한되어 있습니다. 총 노드 수로 표현되는 해시 트리의 크기는 다음 공식에 따라 콘텐츠가 분할되는 청크 수\(따라서 청크의 크기\)에 따라 달라집니다.

```text
       nnodes = math.pow(2,math.log(nchunks,2)+1)
```

원칙적으로 모든 청크를 확인하려면 이러한 모든 노드의 해시 값을 피어에 한 번 전송해야 합니다. 따라서 최대 전송 오버헤드는 해시 크기 \* nnodes입니다. 그러나 전송된 해시의 실제 수는 섹션 5.3에 설명된 대로 최적화될 수 있습니다.

피어가 모든 해시를 수신하지 않으면서 모든 청크를 확인할 수 있는지 보려면 섹션 5.1의 예제 트리를 고려하십시오. 청크 0, 2, 4, 6 등의 단순 점진적 다운로드의 경우 송신 피어는 다음 해시를 보냅니다.

```text
          +-------+---------------------------------------------+
          | Chunk | Node IDs of hashes sent                     |
          +-------+---------------------------------------------+
          |   0   | 2,5,11                                      |
          |   2   | - (receiver already knows all)              |
          |   4   | 6                                           |
          |   6   | -                                           |
          |   8   | 10,13 (hash 3 can be calculated from 0,2,5) |
          |   10  | -                                           |
          |   12  | 14                                          |
          |   14  | -                                           |
          | Total | # hashes        7                           |
          +-------+---------------------------------------------+
```

- 표 1: 예제 트리의 오버헤드

따라서 전송된 총 해시 수\(7\)는 트리의 총 해시 수\(16\)보다 적습니다. 이는 피어가 이전 청크의 일부로 계산되고 확인된 해시를 보낼 필요가 없기 때문입니다.

---
### **5.6.  Automatic Detection of Content Size**

PPSPP에서는 고정 크기 청크를 사용할 때 비디오 파일과 같은 정적 콘텐츠 파일의 크기를 네트워크에서 수신한 정보로부터 안정적이고 자동으로 파생할 수 있습니다. 따라서 해당 파일에 대한 콘텐츠의 메타데이터로 콘텐츠 파일의 크기를 포함할 필요가 없습니다. PPSPP 구현에서는 이 자동 감지 기능을 사용할 수 있습니다. 이 기능은 고정 크기 청크를 사용해야 하는 PPSPP의 유일한 기능입니다. 이 기능은 다음과 같이 Merkle 해시 트리와 신뢰할 수 있는 루트 해시를 Swarm ID로 기반으로 구축됩니다.

---
#### **5.6.1.  Peak Hashes**

신규 피어가 콘텐츠의 크기를 감지하는 능력은 최대 해시 개념에 크게 좌우됩니다. 피크 해시의 개념은 채워진 노드와 불완전한 노드의 개념에 따라 달라집니다. 콘텐츠 확인을 위해 이진 트리를 구성하고 트리의 기본 주소를 지정할 때 콘텐츠의 청크 수보다 더 많은 리프가 있을 수 있다는 점을 기억하세요. Merkle 해시 트리에서 이러한 잎에는 상위 수준 해시를 계산할 수 있도록 모두 0인 빈 해시가 할당되었습니다. 채워진 노드는 이제 다음으로만 구성된 잎의 간격에 해당하는 노드로 정의됩니다.

빈 해시가 아닌 콘텐츠 청크의 해시입니다. 반대로, 불완전한\(채워지지 않은\) 노드는 빈 해시도 포함하는 간격, 일반적으로 파일 끝을 지나 확장되는 간격에 해당합니다. 다음 그림에서는 노드 7, 11, 13, 14가 불완전하고 나머지는 채워져 있습니다.

공식적으로 피크 해시는 형제가 불완전한 노드인 Merkle 해시 트리에서 채워진 노드의 해시입니다. 실제로 파일 길이가 7162바이트이고 청크가 1킬로바이트라고 가정합니다. 해당 파일은 7개의 청크로 구성되며, 꼬리 청크의 길이는 1018바이트입니다. 해당 파일의 Merkle 해시 트리는 그림 4에 나와 있습니다. 정의에 따라 이 파일의 최고 해시는 \*로 표시된 노드 3, 9 및 12에 있습니다. E는 빈 해시를 나타냅니다.

```text
                                  7
                                 / \
                               /     \
                             /         \
                           /             \
                         3*               11
                        / \              / \
                       /   \            /   \
                      /     \          /     \
                     1       5        9*      13
                    / \     / \      / \      / \
                   0   2   4   6    8   10  12*  14

                   C0  C1  C2  C3   C4  C5  C6   E
                                            = 1018 bytes
```

- Merkle 해시 트리의 피크 해시

```text
                                 Figure 4
```

최고 해시는 파일이 차지하는 청크 수의 이진 표현으로 설명할 수 있습니다. 7의 이진 표현은 111입니다. 파일 패킷 길이의 이진 표현에서 모든 "1"은 피크 해시에 해당합니다. 이 특정 파일에는 실제로 노드 3, 9, 12의 세 가지 피크가 있습니다. 따라서 파일의 피크 해시 수도 기껏해야 크기에 따른 대수적입니다.

따라서 파일의 최고 해시가 포함된 노드를 알고 있는 피어는 해당 파일로 구성된 청크 수를 계산할 수 있습니다. 따라서 파일 크기의 추정치를 얻습니다\(마지막 청크를 제외한 모든 청크가 고정된 크기인 경우\). 어떤 노드가 피크인지는 피어 A가 피크 해시와 해당 노드 ID를 피어에게 보내도록 함으로써 하나의 \(신뢰할 수 없는\) 피어인 피어 A에서 다른 피어인 피어 B로 안전하게 통신할 수 있습니다.

B. 피어 B가 신뢰할 수 있는 소스에서 얻은 루트 해시는 다음과 같이 이것이 실제로 올바른 피크 해시인지 확인하는 데 충분하다는 것을 알 수 있습니다.

기본정리: 루트 해시와 비교하여 피크 해시를 확인할 수 있습니다.

증명: \(a\) 모든 피크 해시는 항상 왼쪽 형제입니다. 그렇지 않고 오른쪽 형제인 경우 왼쪽 이웃/형제도 채워진 노드여야 합니다. 왜냐하면 청크가 리프에 배치되는 방식으로 인해 피크 해시의 정의와 모순되기 때문입니다. \(b\) 가장 오른쪽 피크 해시의 경우 오른쪽 형제는 0입니다. \(c\) 피크 해시의 경우 오른쪽 형제는 왼쪽의 피크 해시와 빈 노드의 0을 사용하여 계산될 수 있습니다. \(d\) 가장 왼쪽 피크 해시의 오른쪽 형제가 계산되면 해당 상위가 계산될 수 있습니다. \(e\) 해당 상위 항목이 계산되면 해시를 0으로 연결하고 반복적으로 해싱하여 루트 해시에 쉽게 접근할 수 있습니다.

비공식적으로, Lemma는 다음과 같이 표현될 수 있습니다. 최대 해시는 모든 데이터를 포괄하므로 나머지 해시는 사소한\(0\)이거나 최대 해시 및 0 해시에서 계산될 수 있습니다.

마지막으로 피어 B가 콘텐츠의 청크 수를 얻은 후에는 다음과 같이 정확한 파일 크기를 결정할 수 있습니다. 마지막 청크를 제외한 모든 청크의 크기가 고정되어 있으므로 피어 B는 마지막 청크의 크기만 알면 됩니다. 청크 수를 알면 피어 B는 마지막 청크의 노드 ID를 계산하여 다운로드할 수 있습니다. 항상 그렇듯이 피어 B는 신뢰할 수 있는 루트 해시에 대해 이 청크의 무결성을 확인합니다. 성공적인 검증으로 이어지는 데이터 청크는 하나뿐이므로 이 청크의 크기가 정확해야 합니다. 그러면 피어 B는 다음과 같이 정확한 파일 크기를 결정할 수 있습니다.

- \(청크 수 -1\) \* 고정된 청크 크기 + 마지막 청크 크기

---
#### **5.6.2.  Procedure**

자동 크기 감지를 사용하려는 PPSPP 구현은 다음과 같이 작동해야 합니다. 피어 A가 처음으로 피어 B에 DATA 메시지를 보낼 때 피어 B가 이미 청크를 확인하여 피크 해시를 알고 있다는 신호를 보내지 않는 한 피어 A는 먼저 콘텐츠에 대한 모든 피크 해시를 INTEGRITY 메시지로 보내야 합니다. 필요한 경우 피크 해시는 섹션 5.3에 설명된 대로 청크의 실제 삼촌 해시 목록 앞에 청크에 대한 추가 삼촌 해시 목록으로 전송되어야 합니다. 수신기인 피어 B는 대략적인 콘텐츠 크기를 결정하기 위해 루트 해시에 대해 피크 해시를 확인해야 합니다. 명확한 콘텐츠 크기를 얻으려면 피어 B는 이를 제공하는 피어로부터 콘텐츠의 마지막 청크를 다운로드해야 합니다.

예를 들어, 피어 A가 배포한 1KB의 7개 청크에 맞는 7162바이트 파일을 고려해 보겠습니다. 그림 4는 관련 Merkle 해시 트리를 보여줍니다. 피어 A에 성공적으로 연결된 후 파일의 루트 해시만 알고 있는 피어 B는 그림 4의 첫 번째 데이터 청크인 C0을 요청합니다. 피어 A는 다음 메시지를 이 특정 순서로 데이터그램에 포함하여 피어 B에 응답합니다. 첫째, 이 특정 파일의 세 가지 피크 해시, 즉 노드 3, 9, 12의 해시입니다. 둘째, 삼촌이 C0의 해시를 해시하고 그 뒤에 C0의 실제 내용이 포함된 DATA 메시지가 옵니다. 피크 해시를 수신하면 피어 B는 이를 루트 해시와 비교하여 파일 길이가 7청크인지 확인합니다. 파일의 정확한 크기를 설정하려면 피어 B는 데이터가 포함된 마지막 청크\(그림 4의 C6\)를 요청하고 검색해야 합니다. 마지막 청크가 검색되고 확인되면 피어 B는 길이가 1018바이트라고 결론을 내립니다. 파일의 길이는 정확히 7162바이트입니다.

---
## **6.  Live Streaming**

위에서 정의한 메시지 세트는 라이브 스트리밍에도 사용할 수 있습니다. 풀 기반 모델에서 라이브 스트리밍 인젝터는 HAVE 메시지를 통해 생성한 청크를 알릴 수 있으며 피어는 REQUEST 메시지를 통해 이를 검색할 수 있습니다. 특별한 주의가 필요한 영역은 콘텐츠 인증 및 청크 주소 지정\(무한한 청크 스트림 달성\)입니다.

---
### **6.1.  Content Authentication**

라이브 스트리밍의 경우 PPSPP는 "Sign All" 및 "Unified Merkle Tree"라는 두 가지 방법을 지원하여 피어가 다른 피어로부터 수신한 콘텐츠를 인증합니다.

"모두 서명" 방법에서 라이브 인젝터는 개인 키를 사용하여 각 콘텐츠 청크에 서명합니다. 청크를 수신하면 피어는 신뢰할 수 있는 소스에서 얻은 해당 공개 키를 사용하여 서명을 확인합니다. 이 방법에 대한 지원은 선택 사항입니다.

"통합 머클 트리" 방법에서 PPSPP는 정적 콘텐츠에 대한 머클 해시 트리 체계를 서명과 결합하여 주문형 비디오와 라이브 스트리밍 시나리오를 통합합니다. Merkle 해시 트리를 사용하면 서명 및 확인 작업 수가 줄어들므로 \[SIGMCAST\]에 설명된 접근 방식과 유사한 서명 상각이 제공됩니다. PPSPP가 인터넷을 통해 작동하는 경우 "통합 머클 트리" 방법을 사용해야 합니다. 프로토콜이 양호한 환경에서 작동하는 경우 "통합 머클 트리" 방법을 사용할 수 있습니다. 따라서 이 방법을 반드시 구현해야 합니다.

두 방법 모두에서 스웜 ID는 Base64 인코딩\[RFC4034\] 없이 DNSSEC DNSKEY 리소스 레코드에서와 같이 인코딩된 공개 키로 구성됩니다.

특히 Swarm ID는 공개 키의 암호화 알고리즘을 식별하고 뒤따르는 공개 키 필드의 형식을 결정하는 1바이트 알고리즘 필드로 구성됩니다. 이 알고리즘 필드의 값은 "DNSSEC\(도메인 이름 시스템 보안\) 알고리즘 번호" 레지스트리 \[IANADNSSECALGNUM\]의 값 중 하나입니다. RSASHA1 \[RFC4034\], RSASHA256 \[RFC5702\], ECDSAP256SHA256 및 ECDSAP384SHA384 \[RFC6605\] 알고리즘은 필수로 구현되어야 합니다.

```text
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   | Algo Number(8)|                                               ~
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   ~                DNSSEC Public Key (variable)                   ~
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

---
#### **6.1.1.  Sign All**

"Sign All" 방법에서 라이브 인젝터는 개인 키를 사용하여 각 콘텐츠 청크에 서명하고 피어는 청크를 수신하면 신뢰할 수 있는 소스에서 얻은 해당 공개 키를 사용하여 서명을 확인합니다. 특히 PPSPP에서는 라이브 스트림의 떼 ID가 해당 공개 키입니다.

콘텐츠 청크를 전송하려는 피어는 청크의 서명이 포함된 SIGNED\_INTEGRITY 메시지와 실제 청크가 포함된 DATA 메시지를 포함해야 하는 데이터그램을 생성합니다. SIGNED\_INTEGRITY 메시지와 DATA 메시지가 데이터그램 크기 제한으로 인해 단일 데이터그램에 포함될 수 없는 경우 SIGNED\_INTEGRITY 메시지는 먼저 별도의 데이터그램으로 전송되어야 합니다. SIGNED\_INTEGRITY 메시지는 청크 사양, 타임스탬프, 디지털 서명으로 구성됩니다.

사용되는 디지털 서명 알고리즘은 라이브 서명 알고리즘 프로토콜 옵션에 의해 결정됩니다\(섹션 7.7 참조\). 서명은 청크 사양의 전송 중 표현, NTP 타임스탬프 형식\[RFC5905\]의 64비트 타임스탬프 및 청크를 순서대로 연결하여 계산됩니다. 타임스탬프는 인젝터에서 UTC로 작성된 박자표입니다.

---
#### **6.1.2.  Unified Merkle Tree**

이 방법에서는 콘텐츠 덩어리가 정적 콘텐츠와 마찬가지로 Merkle 해시 트리의 기초로 사용됩니다. 그러나 청크가 지속적으로 생성되기 때문에 이 트리는 정적이지 않고 동적입니다. 결과적으로 트리에는 루트 해시가 없습니다. 더 정확하게는 임시 루트 해시가 있습니다. 따라서 공개 키는 떼 역할을 합니다.

콘텐츠의 ID입니다. 이는 피어가 다음 프로세스를 사용하여 신뢰할 수 있는 정보를 기반으로 트리를 확장할 수 있도록 트리 업데이트에 디지털 서명하는 데 사용됩니다.

---
##### **6.1.2.1.  Signed Munro Hashes**

라이브 인젝터는 고정 전력 2\(NCHUNKS\_PER\_SIG\>=2\)에 해당하는 NCHUNKS\_PER\_SIG로 표시된 여러 청크를 생성하며, 이는 기존 해시 트리에 새 리프로 추가됩니다. 이 확장의 결과로 해시 트리에는 기본에서 NCHUNKS\_PER\_SIG 청크 너비의 새로운 하위 트리가 포함됩니다. 이 새 하위 트리의 루트는 해당 하위 트리의 먼로라고 하며 해당 해시는 그림 5에 설명된 하위 트리의 먼로 해시라고 합니다. 이 그림에서 노드 5는 $ 기호로 레이블이 지정된 새 먼로입니다.

```text
                                     3
                                    / \
                                   /   \
                                  /     \
                                 1       5$
                                / \     / \
                               0   2   4   6
```

확장된 라이브 트리. NCHUNKS\_PER\_SIG=2인 경우 노드 5는 4와 6에 걸쳐 있는 새 하위 트리에 대한 먼로입니다. 노드 1은 이전 반복에서 생성된 청크 0과 2에 걸쳐 있는 하위 트리에 대한 먼로입니다.

```text
                                 Figure 5
```

비공식적으로 프로세스는 이제 다음과 같이 진행됩니다. 인젝터는 개인 키를 사용하여 새 하위 트리의 먼로 해시에만 서명합니다. 다음으로 인젝터는 HAVE 메시지를 사용하여 피어에게 새 하위 트리의 존재를 알립니다. 피어가 HAVE 메시지에 대한 응답으로 새 하위 트리에서 청크를 요청하면 인젝터는 먼저 요청된 청크에 해당하는 서명된 munro 해시를 보냅니다. 그 후, 정적 콘텐츠와 유사하게 인젝터는 섹션 5.1에서와 같이 해당 청크를 확인하는 데 필요한 삼촌 해시를 보냅니다. 특히, 인젝터는 먼로 해시에 대해 요청된 청크를 확인하는 데 필요한 삼촌 해시를 보냅니다. 이는 루트 해시에 대해 확인이 이루어지는 정적 콘텐츠와 다릅니다. 마지막으로 인젝터는 실제 청크를 보냅니다.

수신 피어는 Swarm ID\(공개 키\)를 사용하여 서명된 먼로의 서명을 확인하고 해시 트리를 업데이트합니다. 피어는 이제 먼로 해시가 신뢰할 수 있다는 것을 알기 때문에 섹션 5.1에서와 같이 동반되는 삼촌 해시를 사용하여 이 먼로 해시에 대해 하위 트리의 모든 청크를 확인할 수 있습니다.

이 절차를 설명하기 위해 프로세스의 다음 반복을 고려해 보겠습니다. 인젝터는 그림 5에 표시된 현재 트리를 생성했으며 현재 동일한 트리와 모든 소유 청크 0, 2, 4 및 6을 갖는 여러 피어에 연결됩니다. 인젝터가 두 개의 새로운 청크를 생성하면 NCHUNKS\_PER\_SIG=2, 해시 트리는 그림 6과 같이 확장됩니다. 두 개의 새로운 청크 8과 10은 오른쪽의 트리를 확장하고 이를 수용하기 위해 새로운 루트\(노드 7\)가 생성됩니다. 실제 청크 수에는 현재 두 개의 빈 리프가 있습니다. 새 하위 트리의 munro 노드는 9이며 $ 기호로 표시됩니다.

```text
                                     7
                                    / \
                                  /     \
                                /         \
                              /             \
                            3               11
                           / \              / \
                          /   \            /   \
                         /     \          /     \
                        1       5        9$      13
                       / \     / \      / \      / \
                      0   2   4   6    8   10   E   E

    Expanded live tree.  With NCHUNKS_PER_SIG=2, node 9 is the munro of
             the newly added subtree spanning chunks 8 and 10.

                                 Figure 6
```

이제 인젝터는 업데이트된 트리를 피어에게 알리고 새로운 먼로 해시 9의 추가를 전달해야 합니다. 따라서 노드 8 + 10에 대한 청크 사양이 포함된 HAVE 메시지를 피어에게 보냅니다. 이에 대한 응답으로 Peer P는 REQUEST 메시지를 전송하여 새로 생성된 청크\(예: 청크 8\)를 인젝터에 요청합니다. 이에 대한 응답으로 인젝터는 노드 9의 해시가 포함된 INTEGRITY 메시지와 노드 9의 해시 서명이 포함된 SIGNED\_INTEGRITY 메시지로 노드 9의 서명된 munro 해시를 보냅니다. 이 메시지 뒤에는 다음의 해시가 포함된 INTEGRITY 메시지가 옵니다. 노드 10과 청크 8이 있는 DATA 메시지.

수신 시 피어 P는 먼로의 서명을 확인하고 트리 보기를 확장합니다. 다음으로, 피어는 청크 8의 해시를 계산하고 이를 노드 10의 수신된 해시와 결합하여 노드 9의 예상 해시를 계산합니다. 그런 다음 노드 9의 계산된 해시를 먼로 해시와 비교하여 청크 8의 내용을 확인할 수 있습니다. 그가 방금 받은 동일한 노드의; 따라서 피어 P는 청크 8의 무결성을 성공적으로 확인했습니다.

이 절차에서는 생성된 모든 NCHUNKS\_PER\_SIG 청크에 대해 한 번의 서명 작업과 수신된 모든 NCHUNKS\_PER\_SIG에 대해 한 번의 확인 작업만 필요하므로 "모두 서명"보다 훨씬 저렴합니다. 수신 피어는 Merkle Hash Tree 체계를 통해 청크당 하나 이상의 해시를 추가로 확인해야 하지만 이는 모든 청크에 대한 서명 확인보다 하드웨어 요구 사항이 적습니다. 이 접근 방식은 Merkle Tree Chaining \[SIGMCAST\]을 통한 서명 상각과 유사합니다. 이 방식의 단점은 대기 시간이 길어진다는 것입니다. 피어는 인젝터가 서명을 계산하고 하위 트리를 발표할 때까지 새 청크를 다운로드할 수 없습니다. 피어는 청크를 다른 피어에게 전달하기 전에 서명을 확인해야 합니다\[POLLIVE\].

서명당 청크 수 NCHUNKS\_PER\_SIG는 단순화를 위해 고정된 2의 거듭제곱이어야 합니다. NCHUNKS\_PER\_SIG는 성능상의 이유로 1보다 커야 합니다. NCHUNKS\_PER\_SIG 값을 선택할 때 고려해야 할 두 가지 관련 요소가 있습니다. 첫째, 스트림의 예상 비트 전송률을 고려하여 서명 확인으로 인해 클라이언트에 허용되는 CPU 로드입니다. 높은 비트 전송률 스트림에서 낮은 CPU 로드를 달성하려면 NCHUNKS\_PER\_SIG가 높아야 합니다. 둘째, 방금 논의한 것처럼 NCHUNKS\_PER\_SIG가 높아질수록 지연 시간이 증가하는 효과입니다. 이 절차에서 가변 크기 청크의 사용이 어떻게 배제되지 않는지 확인하세요.

이 무결성 확인 방법은 추가적인 이점을 제공합니다. 시스템에 전체 방송을 저장한 일부 피어가 포함되어 있는 경우 방송이 끝나자마자 콘텐츠는 이제 안정화된 트리와 최종 루트 해시를 떼 식별자로 사용하여 주문형 비디오 다운로드로 사용할 수 있습니다. 모든 청크를 저장한 피어는 이제 추적 인프라에 루트 해시를 알리고 콘텐츠를 즉시 시드할 수 있습니다.

---
##### **6.1.2.2.  Munro Signature Calculation**

사용되는 디지털 서명 알고리즘은 라이브 서명 알고리즘 프로토콜 옵션에 따라 결정됩니다. 섹션 7.7을 참조하세요. 서명은 munro 노드의 청크 사양\(섹션 6.1.2.1 참조\)의 전송 중 표현, 64비트 NTP 타임스탬프 형식\[RFC5905\]의 타임스탬프 및 관련 해시의 연결을 통해 계산됩니다. 먼로 노드, 그 순서대로요. 타임스탬프는 인젝터에서 UTC로 작성된 박자표입니다.

---
##### **6.1.2.3.  Procedure**

공식적으로 인젝터는 해당 하위 트리에 대해 서명된 munro 해시를 계산할 때까지 새 하위 트리의 청크에 대한 HAVE 메시지를 보내서는 안 됩니다.

피어 B가 피어 A\(인젝터 또는 다른 피어\)로부터 청크 C를 요청하고 피어 A가 응답하기로 결정한 경우 다음과 같이 해야 합니다. 먼저, 피어 A는 청크 C의 먼로에 대한 청크 사양과 먼로의 해시가 포함된 INTEGRITY 메시지를 전송해야 하며, 피어 B가 그렇지 않은 경우 단일 데이터그램의 문로, 타임스탬프 및 서명에 대한 청크 사양이 포함된 SIGNED\_INTEGRITY 메시지를 보내야 합니다. \(HAVE 또는 ACK 메시지를 통해\) 동일한 해당 먼로가 있는 청크를 이미 소유하고 있음을 교환 초기에 표시했습니다. 이 두 메시지\(있는 경우\)에 이어 피어 A는 먼로 해시에 대해 청크를 확인하는 데 필요한 누락된 삼촌 해시를 전송해야 하며, 가능하다면 섹션 5.4에 설명된 대로 청크 자체를 공유해야 합니다.

---
##### **6.1.2.4.  Secure Tune In**

피어가 라이브 스트림을 시청할 때 인젝터가 생성한 마지막 청크가 무엇인지 확인해야 합니다. 통합 머클 트리 체계에서 이 프로세스를 촉진하기 위해 각 피어는 다음과 같이 최신 서명된 먼로 해시를 교환하여 인젝터의 청크에 대한 지식을 다른 피어와 공유합니다.

PPSPP에서 피어 A가 피어 B와 채널을 시작할 때 피어 A는 HANDSHAKE 메시지가 포함된 첫 번째 데이터그램을 보내고 피어 B는 HANDSHAKE 메시지도 포함된 두 번째 데이터그램으로 응답합니다\(섹션 3.1 참조\). 피어 A가 피어 B에 세 번째 데이터그램을 보내고 이를 피어 B가 수신하면 두 피어 모두 상대방이 명시된 전송 주소를 듣고 있다는 것을 알게 됩니다. 그런 다음 피어 B는 네 번째 데이터그램의 DATA 메시지와 같은 무거운 페이로드를 보낼 수 있습니다. 피어 A는 세 번째 데이터그램에서 이미 안전하게 해당 작업을 수행할 수 있습니다.

통합 머클 트리 방식에서 피어 A는 피어 B가 동일한 해당 먼로 또는 그 이상의 청크를 소유하고 있음을 나타낼 때까지 가장 오른쪽에 서명된 먼로 해시를 세 번째 데이터그램에서 피어 B에게 보내고 모든 후속 데이터그램에서 피어 B에게 보내야 합니다. 최근 먼로\(HAVE 또는 ACK 메시지를 통해\) 피어 B는 이미 두 번째 데이터그램의 HAVE 메시지를 통해 이 사실을 표시했을 수 있습니다. 반대로, 피어 B가 네 번째 데이터그램 또는 후속 데이터그램을 피어 A에 보낼 때 피어 A가 해당 정보 또는 더 최근의 먼로에 대한 지식을 표시하지 않는 한 피어 B는 가장 오른쪽에 서명된 먼로 해시를 보내야 합니다. 피어의 가장 오른쪽에 서명된 먼로 해시는 피어의 Merkle 해시 트리에서 너비 NCHUNKS\_PER\_SIG 청크의 가장 오른쪽 하위 트리의 인젝터에 의해 서명된 먼로 해시로 정의됩니다. 피어 A는 필수입니다.

HANDSHAKE 절차의 첫 번째 데이터그램에서 서명된 먼로 해시를 보내면 안 되며 피어 B는 무거운 페이로드로 간주되므로 두 번째 데이터그램에서 이를 보내면 안 됩니다.

피어가 서명된 munro 해시가 포함된 SIGNED\_INTEGRITY 메시지를 수신했지만 타임스탬프가 너무 오래된 경우 피어는 메시지를 삭제해야 합니다. 그렇지 않으면 서명된 먼로를 사용하여 해시 트리를 업데이트하고 라이브 스트림에서 튜닝을 선택해야 합니다. 피어는 튜닝 포인트를 선택하기 위해 여러 피어의 정보를 사용할 수 있습니다.

---
### **6.2.  Forgetting Chunks**

라이브 브로드캐스트가 진행됨에 따라 피어는 이미 재생된 청크를 삭제하려고 할 수 있습니다. 이상적으로는 다른 피어가 이 사실을 인지하여 이 피어로부터 이러한 청크를 요청하지 않도록 해야 합니다. 이는 시청자가 라이브 스트림을 일시 중지하거나 시청자가 라이브 방송을 늦게 시작할 수 있도록 허용하는 시나리오에서 발생할 수 있습니다\(예: 실제로 방송이 20:30에 시작했는데 방송 시청을 20:35에 시작\).

PPSPP는 피어가 폐기 피어의 청크 가용성을 최신 상태로 유지할 수 있는 간단한 솔루션을 제공합니다. 라이브 스트림의 폐기 피어는 사용 가능하다고 광고한 마지막 청크/바이트 이전에 캐시하는 청크/바이트 수를 지정하여 Live Discard Window 프로토콜 옵션을 활성화해야 합니다\(섹션 7.9 참조\). 피어는 HAVE 메시지를 통해 전달되는 피어의 청크 가용성에 대해 슬라이딩 창 필터로 이 숫자를 적용해야 합니다.

이 옵션에 대한 적절한 값을 결정할 때 세 가지 요소, 즉 피어에 대해 원하는 재생 버퍼 양, 스트림의 비트 전송률 및 피어의 사용 가능한 리소스가 중요합니다. 스트림에 합류한 새로운 피어의 경우를 생각해 보십시오. 연결하는 피어의 폐기 창 크기는 프리버퍼를 설정하기 위해 직접 다운로드할 수 있는 데이터의 양에 영향을 미칩니다. 창이 원하는 버퍼보다 ​​작은 경우 새 피어는 재생을 시작하기 전에 피어가 더 많은 스트림을 다운로드할 때까지 기다려야 합니다. 미디어 버퍼는 일반적으로 초 단위로 지정되므로 삭제 창의 크기도 스트림의 \(평균\) 비트 전송률과 관련이 있습니다. 마지막으로, 피어에 청크와 메타데이터를 저장할 리소스가 거의 없는 경우 작은 삭제 창을 선택해야 합니다.

---
## **7.  Protocol Options**

PPSPP의 HANDSHAKE 메시지에는 다음 프로토콜 옵션이 포함될 수 있습니다. 달리 명시하지 않는 한, 프로토콜 옵션은 8비트 코드와 8비트 값으로 구성됩니다. 더 큰 값은 모두 인코딩됩니다.

빅엔디안. 각 프로토콜 옵션은 다음 하위 섹션에서 설명됩니다. 프로토콜 옵션 목록은 HANDSHAKE 메시지의 코드 값\(오름차순\)으로 정렬되어야 합니다.

```text
             +--------+-------------------------------------+
             | Code   | Description                         |
             +--------+-------------------------------------+
             | 0      | Version                             |
             | 1      | Minimum Version                     |
             | 2      | Swarm Identifier                    |
             | 3      | Content Integrity Protection Method |
             | 4      | Merkle Hash Tree Function           |
             | 5      | Live Signature Algorithm            |
             | 6      | Chunk Addressing Method             |
             | 7      | Live Discard Window                 |
             | 8      | Supported Messages                  |
             | 9      | Chunk Size                          |
             | 10-254 | Unassigned                          |
             | 255    | End Option                          |
             +--------+-------------------------------------+

                          Table 2: PPSPP Options
```

---
### **7.1.  End Option**

피어는 반드시 end 옵션으로 프로토콜 옵션 목록을 마무리해야 합니다. 후속 옥텟은 프로토콜 메시지로 간주되어야 합니다. end 옵션의 코드는 255이고, 다른 것과 달리 옥텟 값이 없으므로 옵션 길이는 1 옥텟이다.

```text
    0 1 2 3 4 5 6 7
   +-+-+-+-+-+-+-+-+
   |1 1 1 1 1 1 1 1|
   +-+-+-+-+-+-+-+-+
```

---
### **7.2.  Version**

피어는 목록의 첫 번째 프로토콜 옵션으로 지원하는 PPSPP의 최대 버전을 포함해야 합니다. 이 옵션의 코드는 0입니다. 정의된 값은 표 3에 나열되어 있습니다.

```text
           +---------+----------------------------------------+
           | Version | Description                            |
           +---------+----------------------------------------+
           | 0       | Reserved                               |
           | 1       | Protocol as described in this document |
           | 2-255   | Unassigned                             |
           +---------+----------------------------------------+

                      Table 3: PPSPP Version Numbers

    0                   1
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0 0 0 0 0 0 0 0|  Version (8)  |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

---
### **7.3.  Minimum Version**

피어가 핸드셰이크를 시작할 때 \[RFC6709\], 섹션 4.1, 전략 5에 정의된 최소/최대 버전 관리 체계에 따라 프로토콜 옵션 목록에 지원하는 PPSPP의 최소 버전을 포함해야 합니다. 이 옵션의 코드는 다음과 같습니다. 1. 정의된 값은 표 3에 나열되어 있습니다.

```text
    0                   1
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0 0 0 0 0 0 0 1| Min. Ver. (8) |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

---
### **7.4.  Swarm Identifier**

피어가 핸드셰이크를 시작할 때 단일 떼 식별자 옵션을 포함해야 합니다. 피어가 개시자가 아닌 경우 종단 간 확인으로 떼 식별자 옵션을 포함할 수 있습니다. 이 옵션의 구조는 다음과 같습니다.

```text
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0 0 0 0 0 0 1 0|     Swarm ID Length (16)      |               ~
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   ~                       Swarm Identifier (variable)             ~
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

Swarm ID 길이 필드에는 뒤에 오는 단일 Swarm 식별자의 길이\(바이트\)가 포함됩니다. 길이 필드는 라이브 스트리밍에서 큰 공개 키를 식별자로 사용할 수 있도록 16비트 너비입니다.

각 PPSPP 피어는 자신이 참여하는 떼의 ID를 알고 있으므로 이 정보를 수신하는 즉시 확인할 수 있습니다.

---
### **7.5.  Content Integrity Protection Method**

피어는 떼에서 사용하는 콘텐츠 무결성 방법을 포함해야 합니다. 이 옵션의 코드는 3입니다. 정의된 값은 표 4에 나열되어 있습니다.

```text
                   +--------+-------------------------+
                   | Method | Description             |
                   +--------+-------------------------+
                   | 0      | No integrity protection |
                   | 1      | Merkle Hash Tree        |
                   | 2      | Sign All                |
                   | 3      | Unified Merkle Tree     |
                   | 4-255  | Unassigned              |
                   +--------+-------------------------+

            Table 4: PPSPP Content Integrity Protection Methods
```

"머클 해시 트리" 방법은 정적 콘텐츠의 기본값입니다. 섹션 5.1을 참조하세요. "모두 서명" 및 "통합 머클 트리"는 라이브 콘텐츠용입니다. 섹션 6.1을 참조하세요. "통합 머클 트리"가 기본값입니다.

```text
    0                   1
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0 0 0 0 0 0 1 1|   CIPM (8)    |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

---
### **7.6.  Merkle Tree Hash Function**

콘텐츠 무결성 보호 방법이 "Merkle Hash Tree"인 경우 트리에 사용되는 해시 함수를 정의하는 이 옵션이 포함되어야 합니다. 이 옵션의 코드는 4이다. 정의된 값은 표 5에 나열되어 있다\(함수 의미는 \[FIPS180-4\] 참조\).

```text
                        +----------+-------------+
                        | Function | Description |
                        +----------+-------------+
                        | 0        | SHA-1       |
                        | 1        | SHA-224     |
                        | 2        | SHA-256     |
                        | 3        | SHA-384     |
                        | 4        | SHA-512     |
                        | 5-255    | Unassigned  |
                        +----------+-------------+

                   Table 5: PPSPP Merkle Hash Functions
```

구현은 SHA-1\(섹션 12.5 참조\) 및 SHA-256을 지원해야 합니다. SHA-256이 기본값입니다.

```text
    0                   1
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0 0 0 0 0 1 0 0|    MHF (8)    |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

---
### **7.7.  Live Signature Algorithm**

콘텐츠 무결성 보호 방법이 "Sign All" 또는 "Unified Merkle Tree"인 경우 이 옵션을 정의해야 합니다. 이 옵션의 코드는 5입니다. 이 옵션의 8비트 값은 "DNSSEC\(도메인 이름 시스템 보안\) 알고리즘 번호" 레지스트리 \[IANADNSSECALGNUM\]에 나열된 값 중 하나입니다. RSASHA1 \[RFC4034\], RSASHA256 \[RFC5702\], ECDSAP256SHA256 및 ECDSAP384SHA384 \[RFC6605\] 알고리즘은 필수로 구현되어야 합니다. 기본값은 ECDSAP256SHA256입니다.

```text
    0                   1
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0 0 0 0 0 1 0 1|    LSA (8)    |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

---
### **7.8.  Chunk Addressing Method**

피어는 자신이 사용하는 청크 주소 지정 방법을 포함해야 합니다. 이 옵션의 코드는 6입니다. 정의된 값은 표 6에 나열되어 있습니다.

```text
                     +--------+---------------------+
                     | Method | Description         |
                     +--------+---------------------+
                     | 0      | 32-bit bins         |
                     | 1      | 64-bit byte ranges  |
                     | 2      | 32-bit chunk ranges |
                     | 3      | 64-bit bins         |
                     | 4      | 64-bit chunk ranges |
                     | 5-255  | Unassigned          |
                     +--------+---------------------+

                  Table 6: PPSPP Chunk Addressing Methods
```

구현은 "32비트 청크 범위" 및 "64비트 청크 범위"를 지원해야 합니다. 기본값은 "32비트 청크 범위"입니다.

```text
    0                   1
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0 0 0 0 0 1 1 0|    CAM (8)    |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

---
### **7.9.  Live Discard Window**

라이브 스웜의 피어는 반드시 사용하는 폐기 창을 포함해야 합니다. 이 옵션의 코드는 7입니다. 폐기 창의 단위는 사용된 청크 주소 지정 방법에 따라 다릅니다. 표 6을 참조하십시오. 빈 및 청크 범위의 경우 청크 수입니다. 바이트 범위의 경우 바이트 수입니다. 해당 데이터 유형은 빈 또는 범위 지정의 한 값과 동일합니다. 즉, 해당 값은 빅엔디안 형식의 32비트 또는 64비트 정수입니다. 이 옵션을 사용하는 경우 청크 주소 지정 방법은 목록에서 그 앞에 나타나야 합니다. 이 옵션의 구조는 다음과 같습니다.

```text
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0 0 0 0 0 1 1 1|       Live Discard Window (32 or 64)          ~
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   ~                                                               ~
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

정상적인 상황에서 청크를 삭제하지 않는 피어는 이 옵션을 특수 값 0xFFFFFFFF\(32비트\) 또는 0xFFFFFFFFFFFFFFFF\(64비트\)로 설정해야 합니다. 예를 들어, 전체 방송을 녹음하여 방송이 끝난 후 이를 정적 파일로 직접 제공하는 피어는 이 값을 사용합니다\(섹션 6.1.2 참조\). 섹션 6.2에서는 이 옵션의 값을 결정하는 방법을 설명합니다.

---
### **7.10.  Supported Messages**

피어는 PPSPP 메시지의 하위 집합만 지원할 수 있습니다. 예를 들어 TCP를 통해 실행되는 피어는 ACK 메시지를 수락하지 않거나 중앙 집중식 추적 인프라와 함께 사용되는 피어는 PEX 메시지를 수락하지 않을 수 있습니다. 이러한 이유로 PPSPP 메시지의 적절한 하위 집합만 지원하는 피어는 이 프로토콜 옵션을 통해 자신이 지원하는 하위 집합을 알려야 합니다. 이 옵션의 코드는 8입니다. 이 옵션의 값은 뒤에 오는 압축된 비트맵의 길이\(바이트\)를 나타내는 길이 옥텟\(SupMsgLen\)입니다.

지원되는 메시지 세트는 길이가 256비트가 될 때까지 값 0의 바이트를 채워서 압축된 비트맵에서 파생될 수 있습니다. 그런 다음 위치 X\(왼쪽에서 오른쪽으로 번호 지정\)에 있는 결과 비트맵의 1비트는 메시지 유형 X에 대한 지원에 해당합니다\(표 7 참조\). 즉, 압축된 비트맵을 구성하려면 각 메시지 유형에 대해 1을 사용하여 비트맵을 생성합니다. 지원되지 않는 메시지 유형의 경우 0을 바이트 배열로 저장하고 0이 아닌 마지막 바이트까지 자릅니다. ACK 및 PEX를 제외한 모든 메시지를 지원하는 피어에 대한 압축된 비트맵의 처음 16비트의 예는 11011001 11110000입니다.

```text
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0 0 0 0 1 0 0 0| SupMsgLen (8) |                               ~
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   ~            Supported Messages Bitmap (variable, max 256)      ~
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

---
### **7.11.  Chunk Size**

떼의 피어는 떼가 사용하는 청크 크기를 포함해야 합니다. 이 옵션의 코드는 9입니다. 해당 값은 빅엔디안 형식의 청크 크기\(바이트\)를 나타내는 32비트 정수입니다. 가변 청크 크기가 사용되는 경우 이 옵션은 특수 값 0xFFFFFFFF로 설정되어야 합니다. 섹션 8.1에서는 콘텐츠 게시자가 이 옵션의 값을 결정할 수 있는 방법을 설명합니다.

```text
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0 0 0 0 1 0 0 1|       Chunk Size (32)                         ~
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   ~               |
   +-+-+-+-+-+-+-+-+
```

---
## **8.  UDP Encapsulation**

PPSPP 구현은 UDP를 전송 프로토콜로 사용해야 하며 혼잡 제어를 위해 LEDBAT를 사용해야 합니다\[RFC6817\]. LEDBAT를 사용하면 PPSPP가 네트워크 연결을 사용하는 다른 작업으로 이동했을 수 있는 사용자를 방해하지 않고 재생\(시드\) 후 콘텐츠를 제공할 수 있습니다. 향후 PPSPP 버전은 다른 전송 프로토콜을 통해 실행되거나 다른 혼잡 제어 알고리즘을 사용할 수도 있습니다.

---
### **8.1.  Chunk Size**

일반적으로 PPSPP 메시지가 포함된 UDP 데이터그램은 단일 IP 패킷 안에 들어가야 하므로 최대 크기는 네트워크의 MTU에 따라 달라집니다. UDP 데이터그램이 맞지 않으면 데이터그램의 단일 조각이 손실되어 전체 데이터그램이 손실되므로 네트워크에서 손실될 가능성이 높아집니다.

PPSPP 데이터그램에서 가장 큰 메시지는 콘텐츠 덩어리를 전달하는 DATA 메시지입니다. 따라서 특정 떼에 대해 선택할 청크의 \(최대\) 크기는 주로 예상 MTU에 따라 달라집니다. 청크 크기는 원자 데이터그램 원칙\(섹션 5.3\)에 따라 청크와 필요한 INTEGRITY 메시지가 일반적으로 단일 데이터그램 내에서 전달될 수 있도록 선택해야 합니다. 다른 고려 사항은 피어의 하드웨어 기능입니다. 청크가 크므로 콘텐츠 메가바이트당 청크 수가 적으므로 처리 비용이 절감됩니다. 청크 주소 지정 체계는 모두 서로 다른 청크 크기에서 작동할 수 있습니다. 섹션 4를 참조하세요.

권장되는 접근 방식은 1024바이트의 고정 크기 청크를 사용하는 것입니다. 이 크기는 조각화 없이 인터넷을 통해 종단 간 이동할 가능성이 높기 때문입니다. 특히 이 크기를 사용하면 DATA 메시지가 포함된 UDP 데이터그램을 1500바이트 프레임의 이더넷 네트워크를 통해 단일 IP 패킷으로 전송할 수 있습니다.

PPSPP 구현은 발신자와 대상 간의 최적의 MTU를 검색하기 위해 \[RFC4821\]에 설명된 PPLPMTUD\(Packetization Layer Path MTU Discovery\)의 변형을 사용할 수 있습니다. PLPMTUD에서와 같이 점진적으로 더 큰 프로빙 패킷이 주어진 경로에 대한 최적의 MTU를 검색하는 데 사용됩니다. 그러나 PPSPP에서 프로브 패킷은 실제 메시지, 특히 여러 DATA 메시지를 포함해야 합니다. 실제 DATA 메시지를 프로브 패킷으로 사용함으로써 반환되는 ACK 메시지는 프로브 전달을 확인하여 링크의 양쪽 끝에서 MTU 추정치를 효과적으로 업데이트합니다. 적절한 증분으로 프로브 패킷을 확장할 수 있으려면 최소 청크 크기 512바이트를 사용해야 합니다. 청크 크기가 작을수록 프로토콜이 비효율적입니다. 이는 PPSPP가 576바이트 이상의 IPv4를 통한 데이터그램만 지원한다는 의미입니다. 이 변형은 반드시 구현해야 하는 것은 아닙니다.

특정 떼에 사용되는 청크 크기 또는 그것이 가변적이라는 사실은 떼 메타데이터의 일부여야 합니다\(이는 최소한 떼 ID와 청크 특성 및 크기로 구성됨\).

---
### **8.2.  Datagrams and Messages**

UDP를 사용할 때 위에서 설명한 추상 데이터그램은 UDP 데이터그램에 직접적으로 해당합니다. 데이터그램 내의 대부분의 메시지는 고정된 길이를 가지며 일반적으로 메시지 유형에 따라 달라집니다. 메시지의 첫 번째 바이트는 해당 유형을 나타냅니다. 현재 정의된 유형은 다음과 같습니다.

```text
                      +----------+------------------+
                      | Msg Type | Description      |
                      +----------+------------------+
                      | 0        | HANDSHAKE        |
                      | 1        | DATA             |
                      | 2        | ACK              |
                      | 3        | HAVE             |
                      | 4        | INTEGRITY        |
                      | 5        | PEX_RESv4        |
                      | 6        | PEX_REQ          |
                      | 7        | SIGNED_INTEGRITY |
                      | 8        | REQUEST          |
                      | 9        | CANCEL           |
                      | 10       | CHOKE            |
                      | 11       | UNCHOKE          |
                      | 12       | PEX_RESv6        |
                      | 13       | PEX_REScert      |
                      | 14-254   | Unassigned       |
                      | 255      | Reserved         |
                      +----------+------------------+

                       Table 7: PPSPP Message Types
```

또한 정수는 네트워크\(빅 엔디안\) 바이트 순서로 직렬화됩니다. 따라서 빈 청크 주소 지정을 사용하는 HAVE 메시지\(섹션 3.2\)의 예를 고려해 보세요. 메시지 유형은 0x03이고 페이로드는 Bin 번호, 즉 4바이트 정수\(예: 1\)입니다. 따라서 UDP에 대한 전송 중 표현은 16진수로 "0300000001"로 기록될 수 있습니다.

모든 메시지는 멱등성이 있거나 중복 메시지로 인식될 수 있습니다. 멱등성은 메시지를 두 번 이상 처리해도 메시지가 한 번만 처리된 경우와 다른 상태로 이어지지 않음을 의미합니다. 특히, 피어는 손실이 의심되는 경우 문제 없이 DATA, ACK, HAVE, INTEGRITY, PEX\_\*, SIGNED\_INTEGRITY, REQUEST, CANCEL, CHOKE 및 UNCHOKE 메시지를 다시 보낼 수 있습니다. 동료가 재전송할 때

HANDSHAKE 메시지는 이미 첫 번째 연결 시도를 기록했기 때문에 수신자에서는 중복으로 인식하여 처리할 수 있습니다.

---
### **8.3.  Channels**

섹션 3.11에 설명된 대로 PPSPP는 채널이라는 다중화 방식을 사용하여 여러 떼가 동일한 UDP 포트를 사용할 수 있도록 합니다. UDP 캡슐화에서 피어 A에서 피어 B로의 각 데이터그램에는 피어 B가 할당한 채널 ID가 앞에 붙습니다. 피어는 섹션 3.1.1에 설명된 대로 핸드셰이크 중에 서로의 채널 ID에 대해 알아봅니다. 채널 ID는 4바이트로 구성되며 \[RFC4960\]\(섹션 5.1.3\)의 요구 사항에 따라 생성되어야 합니다.

---
### **8.4.  HANDSHAKE**

핸드셰이크로 채널이 설정됩니다. 핸드셰이크를 시작하려면 시작 피어가 섹션 3.1에 정의된 스웜 메타데이터와 피어의 IP 주소 및 UDP 포트를 알아야 합니다. HANDSHAKE 메시지를 포함하는 데이터그램은 다음과 같습니다.

```text
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                  Destination Channel ID (32)                  |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0 0 0 0 0 0 0 0|            Source Channel ID (32)             |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |               |                                               ~
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                                                               |
   ~                     Protocol Options                          ~
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

   where:

      Destination Channel ID:
```

- 데이터그램이 시작 피어에 의해 전송된 경우에는 모두 0인 채널 ID여야 합니다.

- 데이터그램이 응답 피어에 의해 전송된 경우 보낸 사람의 HANDSHAKE 메시지의 소스 채널 ID로 구성되어야 합니다.

- 옥텟 0x00: HANDSHAKE 메시지 유형

- 소스 채널 ID: 로컬에서 사용되지 않는 채널 ID

- 프로토콜 옵션: 섹션 7에 정의된 대로 떼의 메타데이터를 인코딩하는 프로토콜 옵션 목록입니다.

피어는 모두 0인 소스 채널 ID와 프로토콜 옵션 목록을 포함해야 하는 HANDSHAKE 메시지를 전송하여 명시적으로 채널을 닫아야 합니다. 목록은 비어 있거나 \[RFC6709\], 섹션 4.1에 정의된 최소/최대 버전 관리 방식에 따라 발신자가 지원하는 최대 버전 번호를 포함해야 합니다.

---
### **8.5.  HAVE**

HAVE 메시지\(유형 0x03\)는 송신 피어가 해당 청크를 가지고 있으며 무결성을 성공적으로 확인했음을 나타내는 단일 청크 사양으로 구성됩니다. 단일 청크 사양은 검증된 청크의 연속 범위를 나타냅니다. Bin은 단일 정수, 그리고 청크 주소 지정 프로토콜 옵션에 의해 지정된 너비\(인코딩된 빅엔디안\)의 두 정수로 구성된 청크 또는 바이트 범위로 구성됩니다.

청크 주소 지정 방법으로 32비트 청크 범위를 사용하는 HAVE 메시지:

```text
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0 0 0 0 0 0 1 1|                 Start chunk (32)              |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |               |                  End chunk (32)               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |               |
   +-+-+-+-+-+-+-+-+
```

여기서 첫 번째 옥텟은 HAVE 메시지\(0x03\)이고 그 뒤에 시작 청크와 청크 범위를 설명하는 끝 청크가 옵니다. 이 다이어그램은 데이터그램이 아닌 메시지를 표시하므로 대상 채널 ID가 앞에 붙지 않습니다. 이는 모든 후속 메시지 다이어그램에 적용됩니다.

---
### **8.6.  DATA**

DATA 메시지\(유형 0x01\)는 청크 사양, 타임스탬프 및 실제 청크로 구성됩니다. 데이터그램에 하나의 DATA 메시지가 포함된 경우 송신자는 항상 데이터그램의 꼬리에 DATA 메시지를 넣어야 합니다. 데이터그램은 청크 크기가 고정되어 있고 마지막 청크가 청크 크기보다 작은 경우 DATA 메시지 중 어느 것도 전달하지 않는 경우 여러 DATA 메시지를 포함할 수 있습니다. LEDBAT 혼잡 제어가 사용되므로 발신자는 반드시 타임스탬프를 포함해야 합니다.

특히 현재 시스템 시간을 마이크로초 정확도로 나타내는 64비트 정수입니다. 타임스탬프는 청크 사양과 실제 청크 사이에 포함되어야 합니다.

청크 주소 지정 방법으로 32비트 청크 범위를 사용하는 DATA 메시지:

```text
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0 0 0 0 0 0 0 1|                 Start chunk (32)              |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |               |                  End chunk (32)               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |               |                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                       Timestamp (64)                          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |               |                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                                                               |
   ~                            Data                               ~
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

여기서 첫 번째 옥텟은 DATA 메시지\(0x01\)이고 그 뒤에 시작 청크와 단일 청크, 타임스탬프 및 실제 데이터를 설명하는 끝 청크가 옵니다.

---
### **8.7.  ACK**

ACK 메시지\(유형 0x02\)는 수신자로부터 수신된 데이터를 확인합니다. LEDBAT 지연 기반 혼잡 제어를 준수하기 위해 ACK 메시지는 청크 사양과 단방향 지연 샘플을 나타내는 타임스탬프로 구성됩니다. 단방향 지연 샘플은 마이크로초 정확도의 64비트 정수이며 LEDBAT 사양에 따라 승인되는 청크가 포함된 이전 DATA 메시지에서 수신된 타임스탬프에서 계산됩니다.

청크 주소 지정 방법으로 32비트 청크 범위를 사용하는 ACK 메시지:

```text
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0 0 0 0 0 0 1 0|                 Start chunk (32)              |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |               |                  End chunk (32)               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |               |                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                  One-way delay sample (64)                    |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |               |
   +-+-+-+-+-+-+-+-+
```

여기서 첫 번째 옥텟은 ACK 메시지\(0x02\)이고 그 뒤에는 시작 청크와 청크 범위 및 단방향 지연 샘플을 설명하는 끝 청크가 옵니다.

---
### **8.8.  INTEGRITY**

INTEGRITY 메시지\(유형 0x04\)는 지정된 청크 또는 노드에 대한 청크 사양과 암호화 해시로 구성됩니다. 해시의 유형과 형식은 프로토콜 옵션에 따라 다릅니다.

32비트 청크 범위를 청크 주소 지정 방법 및 SHA-256 해시로 사용하는 INTEGRITY 메시지:

```text
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0 0 0 0 0 1 0 0|                 Start chunk (32)              |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |               |                  End chunk (32)               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |               |                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                                                               |
   ~                            Hash (256)                         ~
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |               |
   +-+-+-+-+-+-+-+-+
```

여기서 첫 번째 옥텟은 INTEGRITY 메시지\(0x04\)이고 그 뒤에는 시작 청크와 청크 범위 및 해시를 설명하는 끝 청크가 옵니다.

---
### **8.9.  SIGNED_INTEGRITY**

SIGNED\_INTEGRITY 메시지\(유형 0x07\)는 청크 사양, NTP 타임스탬프 형식\[RFC5905\]의 64비트 타임스탬프로 구성되며 서명 필드로 인코딩된 디지털 서명은 Base64 인코딩\[RFC4034\] 없이 DNSSEC의 RRSIG 레코드에 있습니다. 서명 알고리즘은 라이브 서명 알고리즘 프로토콜 옵션에 의해 정의됩니다\(섹션 7.7 참조\). 서명이 사용되는 일반 텍스트는 사용된 콘텐츠 무결성 보호 방법에 따라 다릅니다. 섹션 6.1을 참조하세요.

청크 주소 지정 방법으로 32비트 청크 범위를 사용하는 SIGNED\_INTEGRITY 메시지:

```text
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0 0 0 0 0 1 1 1|                 Start chunk (32)              |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |               |                  End chunk (32)               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |               |                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                       Timestamp (64)                          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |               |                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                                                               |
   ~                       Signature                               ~
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

여기서 첫 번째 옥텟은 SIGNED\_INTEGRITY 메시지\(0x07\)이고 그 뒤에는 시작 청크와 청크 범위, 타임스탬프 및 서명을 설명하는 끝 청크가 옵니다.

디지털 서명의 길이는 Live Signature Algorithm 프로토콜 옵션과 Swarm ID를 통해 다음과 같이 도출할 수 있습니다. 첫 번째 필수 알고리즘은 RSASHA1 및 RSASHA256입니다. 이러한 알고리즘의 경우 떼 ID는 1바이트 알고리즘 필드와 튜플\(지수 길이, 지수, 모듈러스\) \[RFC3110\]로 저장된 RSA 공개 키로 구성됩니다. Swarm ID의 공개 키 튜플 길이와 지수 길이가 주어지면 모듈러스 길이\(바이트\)를 계산할 수 있습니다. 이는 다음의 길이를 산출합니다.

서명은 RSA에서와 같이 모듈러스 \[HAC01\]의 길이입니다. 다른 필수 알고리즘은 ECDSAP256SHA256 및 ECDSAP384SHA384 \[RFC6605\]입니다. 이러한 알고리즘의 경우 디지털 서명의 길이는 각각 64바이트와 96바이트입니다.

---
### **8.10.  REQUEST**

REQUEST 메시지\(유형 0x08\)는 요청자가 다운로드하려는 청크에 대한 청크 사양으로 구성됩니다.

32비트 청크 범위를 청크 주소 지정 방법으로 사용하는 REQUEST 메시지:

```text
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0 0 0 0 1 0 0 0|                 Start chunk (32)              |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |               |                  End chunk (32)               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |               |
   +-+-+-+-+-+-+-+-+
```

여기서 첫 번째 옥텟은 REQUEST 메시지\(0x08\)이고 그 뒤에는 시작 청크와 청크 범위를 설명하는 끝 청크가 옵니다.

---
### **8.11.  CANCEL**

CANCEL 메시지\(유형 0x09\)는 요청자가 더 이상 관심이 없는 청크에 대한 청크 사양으로 구성됩니다.

32비트 청크 범위를 청크 주소 지정 방법으로 사용하는 CANCEL 메시지:

```text
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0 0 0 0 1 0 0 1|                 Start chunk (32)              |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |               |                  End chunk (32)               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |               |
   +-+-+-+-+-+-+-+-+
```

여기서 첫 번째 옥텟은 CANCEL 메시지\(0x09\)이고 그 뒤에 시작 청크와 청크 범위를 설명하는 끝 청크가 옵니다.

---
### **8.12.  CHOKE and UNCHOKE**

CHOKE 및 UNCHOKE 메시지\(각각 0x0a 및 0x0b 유형\)는 페이로드를 전달하지 않습니다.

초크 메시지:

```text
    0
    0 1 2 3 4 5 6 7
   +-+-+-+-+-+-+-+-+
   |0 0 0 0 1 0 1 0|
   +-+-+-+-+-+-+-+-+
```

여기서 첫 번째 옥텟은 CHOKE 메시지\(0x0a\)입니다.

UNCHOKE 메시지:

```text
    0
    0 1 2 3 4 5 6 7
   +-+-+-+-+-+-+-+-+
   |0 0 0 0 1 0 1 1|
   +-+-+-+-+-+-+-+-+
```

여기서 첫 번째 옥텟은 UNCHOKE 메시지\(0x0b\)입니다.

---
### **8.13.  PEX_REQ, PEX_RESv4, PEX_RESv6, and PEX_REScert**

PEX\_REQ\(0x06\) 메시지에는 페이로드가 없습니다. PEX\_RESv4\(0x05\) 메시지는 빅엔디안 형식의 IPv4 주소와 빅엔디안 형식의 UDP 포트 번호로 구성됩니다. PEX\_RESv6\(0x0c\) 메시지에는 IPv4 주소 대신 128비트 IPv6 주소가 포함되어 있습니다. PEX\_REQ 메시지가 개인, 고유 로컬, 링크 로컬 또는 멀티캐스트 주소 \[RFC1918\] \[RFC4193\] \[RFC4291\]에서 시작되지 않은 경우 응답으로 전송된 PEX\_RES\* 메시지에는 그러한 주소가 포함되어서는 안 됩니다. 이는 내부 주소가 외부 피어에게 유출되는 것을 방지하기 위한 것입니다.

PEX\_REQ 메시지:

```text
    0
    0 1 2 3 4 5 6 7
   +-+-+-+-+-+-+-+-+
   |0 0 0 0 0 1 1 0|
   +-+-+-+-+-+-+-+-+
```

여기서 첫 번째 옥텟은 PEX\_REQ 메시지\(0x06\)입니다.

PEX\_RESv4 메시지:

```text
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0 0 0 0 0 1 0 1|              IPv4 Address (32)                |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |               |             Port (16)         |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

여기서 첫 번째 옥텟은 PEX\_RESv4 메시지\(0x05\)이고 그 뒤에 IPv4 주소와 포트 번호가 옵니다.

PEX\_RESv6 메시지:

```text
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0 0 0 0 1 1 0 0|                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                   IPv6 Address (128)                          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |               |             Port (16)         |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

여기서 첫 번째 옥텟은 PEX\_RESv6 메시지\(0x0c\)이고 그 뒤에 IPv6 주소와 포트 번호가 옵니다.

PEX\_REScert\(0x0d\) 메시지는 뒤에 오는 회원 인증서의 크기를 지정하는 빅엔디안의 16비트 정수로 구성됩니다. 섹션 12.2.1을 참조하세요. 이 회원 인증서는 시간 T의 피어 P가 Swarm S의 회원이고 ASN.1 고유 인코딩 규칙\(DER\)\[CCITT.X690.2002\]을 사용하여 인코딩된 X.509v3 인증서\[RFC5280\]임을 명시합니다. 인증서에는 중요로 표시된 "주체 대체 이름" 확장이 포함되어야 하며, 형식은uniformResourceIdentifier입니다.

PEX\_REScert 메시지:

```text
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0 0 0 0 1 1 0 1|   Size of Memb. Cert. (16)    |               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                                                               |
   ~                    Membership Certificate                     ~
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

여기서 첫 번째 옥텟은 PEX\_REScert 메시지\(0x0d\)이고 그 뒤에 회원 인증서와 회원 인증서의 크기가 옵니다.

이름 확장에 포함된 URL은 URL \[RFC3986\]에 대한 일반 구문을 따라야 합니다. 여기서 해당 체계 구성 요소는 "파일"이고 기관 구성 요소의 호스트는 기관 구성 요소의 포트인 피어 P의 DNS 이름 또는 IP 주소입니다. 은 Peer P의 포트이고 경로에는 Swarm S에 대한 Swarm 식별자가 16진수 형식으로 포함되어 있습니다. 특히, 떼 식별자의 선호되는 형식은 xxyyzz...입니다. 여기서 'x', 'y' 및 'z'는 식별자의 8비트 부분 중 2개의 16진수 숫자입니다. 인증서의 유효 시간은 notBefore UTCTime이 T로 설정되고 notAfter UTCTime이 T로 설정되고 발급자가 정의한 일부 만료 시간이 추가되어 설정됩니다. 예시 URL:

```text
       file://192.0.2.0:6778/e5a12c7ad2d8fab33c699d1e198d66f79fa610c3
```

---
### **8.14.  KEEPALIVE**

연결 유지에는 UDP에 대한 메시지 유형이 없습니다. 이는 대상의 4바이트 채널 ID로만 구성된 단순한 데이터그램입니다.

연결 유지 데이터그램:

```text
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                       Channel ID (32)                         |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

---
### **8.15.  Flow and Congestion Control**

UDP를 통한 PPSPP에는 명시적인 흐름 제어가 필요하지 않습니다. 주문형 비디오의 경우 수신자는 피어에게 콘텐츠를 명시적으로 요청하므로 해당 콘텐츠로 들어오는 데이터의 양을 제어할 수 있습니다. 푸시 모델을 사용할 수 있는 라이브 스트리밍의 경우 수신되는 데이터 양은 스트림 비트 전송률로 제한되며, 수신기는 연속 재생을 위해 이를 처리할 수 있어야 합니다. 어떤 이유로든 수신자가 데이터로 포화되면 발신자 측의 혼잡 제어가 상황을 감지하고 그에 따라 전송 속도를 조정합니다.

UDP를 통한 PPSPP는 다양한 혼잡 제어 알고리즘을 지원할 수 있습니다. 현재는 LEDBAT 혼잡제어 알고리즘 \[RFC6817\]을 사용하고 있다. LEDBAT는 BitTorrent \[LBT\] \[LCOMPL\]의 uTP 전송 프로토콜의 일부로 수백만 명의 사용자가 매일 사용하는 지연 기반 혼잡 제어 알고리즘으로 P2P 스트리밍 \[PPSPPERF\]에 적합합니다.

LEDBAT는 데이터 경로의 패킷 지연을 모니터링합니다. 이는 단방향 지연 변화를 사용하여 조기에 반응하고 스트림이 네트워크에서 유발할 수 있는 정체를 제한합니다\[RFC6817\]. LEDBAT를 사용하면 PPSPP가 재생이 완료된 후\(시드\) 사용자를 방해하지 않고 관심 있는 다른 피어에게 콘텐츠를 제공할 수 있습니다. 재생 후 사용자는 PPSPP 트래픽보다 우선순위가 높은 네트워크 링크를 사용하는 다른 작업으로 이동할 수 있습니다. 따라서 사용자는 백그라운드 PPSPP 트래픽을 알아차리지 못하며, 이는 결과적으로 더 오랜 기간 동안 콘텐츠를 시드할 가능성을 높입니다.

여러 소스가 콘텐츠를 제공하는 P2P 시스템에서는 조기에 반응하는 특성이 문제가 되지 않습니다. 발신자 근처의 정체 상황을 고려하면 LEDBAT의 초기 반응은 청크가 수신자에게 전송되는 데 영향을 미칩니다. 그러나 수신기의 경우 특정 소스의 전송이 영향을 받는다는 사실을 조기에 배우는 것이 실제로 유익합니다. 그러면 수신자는 청크 선택 단계에서 다른 소스로부터 시간이 중요한 청크를 다운로드하도록 선택할 수 있습니다.

병목 현상이 수신기 근처에 있는 경우 이 병목 현상을 통과하는 모든 소스의 전송이 LEDBAT로 인해 매우 빠르게 백오프되므로 수신기는 실제로 운이 좋지 않습니다. 그러나 나머지 네트워크\(및 네트워크 운영자\)에게는 비디오 스트리밍 시스템이 충분히 일찍 백오프되고 혼잡에 크게 기여하지 않으므로 이는 유익합니다.

LEDBAT의 장점은 동작을 구성할 수 있다는 것입니다. 라이브 스트리밍의 경우 PPSPP 배포자는 서비스 품질을 보장하기 위해 보다 공격적인 동작을 원할 수 있습니다. 이 경우 LEDBAT를 보다 적극적으로 구성할 수 있습니다. 특히, LEDBAT의 큐잉 대상 지연 값\(\[RFC6817\]의 TARGET\) 및 기타 매개변수는 TCP만큼\(또는 그 이상\) 공격적으로 작동하도록 조정될 수 있습니다. 따라서 LEDBAT는 P2P 컨텍스트의 다양한 시나리오에서 작동하는 알고리즘입니다.

---
### **8.16.  Example of Operation**

우리는 거머리와 파종자 사이의 의사소통에 대한 작은 예를 제시합니다. 이 예에서는 1024바이트 청크에 맞는 "Hello World!" 파일의 전송을 보여줍니다. 이해를 돕기 위해 실제 바이너리 값 대신 표 7에 나열된 메시지 설명 이름과 표 2에 나열된 프로토콜 옵션 이름을 사용합니다.

핸드셰이크를 수행하기 위해 시작 피어는 모두 0인 채널 ID\(0x00000000\)로 시작해야 하는 데이터그램을 보냅니다. 페이로드가 로컬에서 사용되지 않는 HANDSHAKE 메시지가 뒤따릅니다. 임의의 채널 ID\(이 경우 0x00000001\) 그리고 프로토콜 옵션 목록입니다. 채널 ID는 섹션 12.1에 설명된 대로 무작위로 선택되어야 합니다.

```text
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |   HANDSHAKE   |0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0 0 0 0 0 0 0 1|    Version    |0 0 0 0 0 0 0 1|  Min Version  |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0 0 0 0 0 0 0 1|   Swarm ID    |0 0 0 0 0 0 0 0 0 0 0 1 0 1 0 0|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0 1 0 0 0 1 1 1 1 0 1 0 0 0 0 0 0 0 0 1 0 0 1 1 1 1 1 0 0 1 1 0|
   ~                             .....                             ~
   |1 0 0 0 0 1 1 0 1 0 1 0 1 0 1 0 1 0 1 1 0 0 0 0 0 0 1 1 1 0 1 1|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |   Cont. Int.  |0 0 0 0 0 0 0 1| Mer.H.Tree F. |0 0 0 0 0 0 1 0|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |   Chunk Add.  |0 0 0 0 0 0 1 0|   Chunk Size  |0 0 0 0 0 0 0 0~
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   ~0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0|      End      |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

프로토콜 옵션은 다음과 같습니다.

```text
      Version: 1

      Minimum supported Version: 1
```

- Swarm Identifier: 콘텐츠를 식별하는 32바이트 루트 해시\(47a0...b03b\)

```text
      Content Integrity Protection Method: Merkle Hash Tree

      Merkle Tree Hash Function: SHA-256

      Chunk Addressing Method: 32-bit chunk ranges

      Chunk Size: 1024
```

수신 피어는 응답할 수 있으며, 이 경우 반환된 데이터그램은 보낸 사람의 HANDSHAKE 메시지\(0x00000001\)의 채널 ID로 구성되어야 합니다. 페이로드가 로컬에서 사용되지 않는 HANDSHAKE 메시지; 임의의 채널 ID\(0x00000008\); 프로토콜 옵션 목록; 그 뒤에 보내려는 다른 메시지가 옵니다.

```text
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |   HANDSHAKE   |0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0 0 0 0 1 0 0 0|    Version    |0 0 0 0 0 0 0 1|   Cont. Int.  |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0 0 0 0 0 0 0 1| Mer.H.Tree F. |0 0 0 0 0 0 1 0|   Chunk Add.  |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0 0 0 0 0 0 1 0|  Chunk Size   |0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0~
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   ~0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0|      End      |      HAVE     |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0|0 0 0 0 0 0 0 0|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0|0 0 0 0 0 0 0 0|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

프로토콜 옵션을 통해 수신 피어는 콘텐츠 무결성 보호 방법으로 머클 해시 트리, 머클 트리 해시 함수로 SHA-256 해시, 청크 주소 지정 방법으로 32비트 청크 범위를 사용하는 말하기 프로토콜 버전 1에 동의합니다. 그리고

청크 크기 1024. 또한 동일한 데이터그램 내에서 HAVE 메시지를 보내 첫 번째 콘텐츠 청크를 로컬에서 사용할 수 있음을 알립니다.

이 시점에서 개시자는 피어가 실제로 응답한다는 것을 알게 됩니다. 이를 위해 채널 ID는 쉽게 추측할 수 없을 만큼 무작위여야 합니다. 따라서 핸드셰이크의 세 번째 데이터그램에는 이미 무거운 페이로드가 포함되어 있을 수 있습니다. 초기화 왕복 횟수를 최소화하기 위해 처음 두 개의 데이터그램에는 HAVE 메시지와 같은 일부 사소한 페이로드도 포함될 수 있습니다.

시작 피어는 수신 피어에서 검색하려는 콘텐츠 청크\(예: 핸드셰이크 중에 발표된 첫 번째 청크\)에 대한 요청을 보낼 수 있습니다. 섹션 3.11에 설명된 대로 항상 통신 중인 피어의 채널 ID\(이 예에서는 0x00000008\)가 있는 메시지 앞에 옵니다. 또한 PEX\_REQ와 같은 추가 메시지를 추가할 수도 있습니다.

```text
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |    REQUEST    |0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0 0 0 0 0 0 0 0|0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0 0 0 0 0 0 0 0|    PEX_REQ    |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

세 번째 데이터그램을 수신하면 두 피어 모두 실제로 서로 대화하고 있다는 증거를 갖게 됩니다. 3방향 핸드셰이크가 완료되었습니다. 수신 피어는 요청된 콘텐츠가 포함된 DATA 메시지를 보내 요청에 응답합니다.

```text
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |     DATA      |0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0 0 0 0 0 0 0 0|0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0 0 0 0 0 0 0 0|0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 1 1 1 0 1 0 0 1|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0 1 0 0 0 0 0 1 1 0 0 0 0 0 0 0 1 0 1 1 0 1 1 1 1 1 0 1 1 0 1 1|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0 1 0 0 0 1 0 0|0 1 0 0 1 0 0 0 0 1 1 0 0 1 0 1 0 1 1 0 1 1 0 0|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   ~                           .....                               ~
   |0 1 1 0 1 1 0 0 0 1 1 0 0 1 0 0 0 0 1 0 0 0 0 1 0 0 0 0 1 0 1 0|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

DATA 메시지는 다음으로 구성됩니다.

- 32비트 청크 범위: 0,0\(첫 번째 청크\)

- 타임스탬프 값: 0004e94180b7db44

- 데이터: 48656c6c6f20776f726c6421 \("Hello world!" 파일\)

전체 내용이 단일 메시지에 들어갈 수 있으므로 위의 데이터그램에는 INTEGRITY 메시지가 포함되어 있지 않습니다. 따라서 시작 피어는 루트 해시에 대해 이를 확인할 수 있습니다. 또한 이 예에서 피어는 Swarm에 참여하는 세 번째 피어를 모르기 때문에 PEX\_REQ에 응답하지 않습니다.

요청된 데이터를 수신하면 시작 피어는 단방향 지연 샘플\(100ms\)이 포함된 첫 번째 청크에 대한 ACK 메시지로 응답합니다. 또한 청크에 대한 HAVE 메시지도 추가합니다.

```text
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |      ACK      |0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0 0 0 0 0 0 0 0|0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0 0 0 0 0 0 0 0|0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0 1 1 0 0 1 0 0|      HAVE     |0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0|0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

이 시점에서 시작 피어는 전체 파일을 성공적으로 검색했습니다. 그런 다음 모두 0인 소스 채널 ID가 포함된 HANDSHAKE 메시지를 보내 연결을 명시적으로 닫습니다.

```text
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |   HANDSHAKE   |0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0 0 0 0 0 0 0 0|      End      |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

---
## **9.  Extensibility**
---
### **9.1.  Chunk Picking Algorithms**

청크\(또는 조각\) 선택은 전적으로 수신 피어에 따라 다릅니다. 보내는 피어는 REQUEST 메시지를 통해 선호하는 청크를 인식하게 됩니다. 일부 \(라이브\) 시나리오에서는 발신자가 해당 힌트를 무시하고 요청되지 않은 데이터를 보내도록 허용하는 것이 도움이 될 수 있습니다.

청크 선택 알고리즘은 PPSPP 외부에 있으며 일반적으로 PPSPP에서 제공하는 메커니즘을 사용하는 플러그형 정책입니다. 알고리즘은 사용자가 선택한 사항을 처리합니다.

오디오 트랙이나 자막을 찾거나 전환하는 등 콘텐츠 소비. P2P 스트리밍에 대한 예시 정책은 \[BITOS\] 및 \[EPLIVEPERF\]에서 확인할 수 있습니다.

---
### **9.2.  Reciprocity Algorithms**

P2P 시스템에서 상호성 알고리즘의 역할은 고객 기여를 촉진하고 무임승차를 방지하는 것입니다. 피어가 콘텐츠를 다운로드만 하고 다른 사람에게 업로드하지 않는 경우 프리라이딩이라고 합니다. 상호성 알고리즘의 예로는 BitTorrent \[TIT4TAT\] 및 Give-to-Get \[GIVE2GET\]에서 사용되는 tit-for-tat가 있습니다. PPSPP에서 상호성 적용은 송신 피어의 전적인 책임입니다.

---
## **10.  IANA Considerations**

IANA는 프로토콜 확장성을 위해 아래에 정의된 6개의 새로운 하위 레지스트리를 호스팅하는 "PPSPP\(Peer-to-Peer Streaming Peer Protocol\)"라는 새로운 최상위 레지스트리를 만들었습니다. 모든 레지스트리의 경우 할당은 이름과 관련 값으로 구성됩니다. 또한 모든 레지스트리에 대해 지정된 "할당되지 않음" 범위는 \[RFC5226\]에 설명된 대로 "IETF 검토" 정책의 적용을 받습니다.

---
### **10.1.  PPSPP Message Type Registry**

레지스트리 이름은 "PPSPP 메시지 유형 레지스트리"입니다. 값은 0-255 범위의 정수이며 초기 할당 및 예약은 표 7에 나와 있습니다.

---
### **10.2.  PPSPP Option Registry**

레지스트리 이름은 "PPSPP 옵션 레지스트리"입니다. 값은 0-255 범위의 정수이며 초기 할당 및 예약은 표 2에 나와 있습니다.

---
### **10.3.  PPSPP Version Number Registry**

레지스트리 이름은 "PPSPP 버전 번호 레지스트리"입니다. 값은 0-255 범위의 정수이며 초기 할당 및 예약은 표 3에 나와 있습니다.

---
### **10.4.  PPSPP Content Integrity Protection Method Registry**

레지스트리 이름은 "PPSPP 콘텐츠 무결성 보호 방법 레지스트리"입니다. 값은 0-255 범위의 정수이며 초기 할당 및 예약은 표 4에 나와 있습니다.

---
### **10.5.  PPSPP Merkle Hash Tree Function Registry**

레지스트리 이름은 "PPSPP Merkle Hash Tree Function Registry"입니다. 값은 0-255 범위의 정수이며 초기 할당 및 예약은 표 5에 나와 있습니다.

---
### **10.6.  PPSPP Chunk Addressing Method Registry**

레지스트리 이름은 "PPSPP 청크 주소 지정 방법 레지스트리"입니다. 값은 0-255 범위의 정수이며 초기 할당 및 예약은 표 6에 나와 있습니다.

---
## **11.  Manageability Considerations**

이 섹션에서는 \[RFC5706\], 부록 A의 체크리스트에 따른 운영 및 관리 고려 사항을 제시합니다.

이 섹션에서 "PPSPP 클라이언트"는 아직 콘텐츠 복사본이 없을 수 있는 최종 사용자를 대신하여 작동하는 PPSPP 피어로 정의되고, "PPSPP 서버"는 콘텐츠의 초기 복사본을 최종 사용자에게 제공하는 PPSPP 피어로 정의됩니다. 콘텐츠 제공자를 대신하여 떼.

---
### **11.1.  Operations**
---
#### **11.1.1.  Installation and Initial Setup**

PPSPP를 사용하여 콘텐츠를 배포하려는 콘텐츠 제공자는 최소한 하나의 PPSPP 서버를 설정해야 합니다. PPSPP 서버는 일부 정적 콘텐츠나 일부 라이브 오디오/비디오 소스에 액세스할 수 있어야 합니다. 구현자에게 유연성을 제공하기 위해 이 구성 프로세스는 표준화되지 않았습니다. 이 프로세스의 출력은 각 떼에 대해 하나씩 메타데이터 레코드 목록이 됩니다. 메타데이터 레코드는 Swarm ID, 사용된 청크 크기, 사용된 청크 주소 지정 방법, 사용된 콘텐츠 무결성 보호 방법 및 사용된 Merkle 해시 트리 기능\(해당되는 경우\)으로 구성됩니다. 자동 콘텐츠 크기 감지\(섹션 5.6 참조\)가 사용되지 않으면 콘텐츠 길이도 정적 콘텐츠에 대한 메타데이터 레코드의 일부입니다. Swarm ID에는 라이브 스트림의 경우 사용되는 라이브 서명 알고리즘이 이미 포함되어 있습니다.

또한 콘텐츠 제공자는 P2P 스트리밍 프로토콜 추적기\(PPSP-TP\) 또는 분산 해시 테이블 등을 구성하여 콘텐츠에 대한 추적 시설을 설정해야 합니다. 후자 프로세스의 출력은 추적 기능에 대한 전송 주소 목록입니다.

사용 가능한 콘텐츠의 메타데이터 기록 목록과 추적 기능을 위한 전송 주소는 다양한 방법으로 사용자에게 배포될 수 있습니다. 일반적으로 웹사이트에 링크로 게시됩니다. 사용자가 이러한 링크를 클릭하면 섹션 2에 예시된 것처럼 PPSPP 클라이언트가 독립형 애플리케이션으로 또는 브라우저의 내부 PPSPP 프로토콜 핸들러를 호출하여 시작됩니다. 클라이언트는 추적 기능을 사용하여 PPSPP 서버의 전송 주소를 얻습니다. \(s\) 및 떼의 다른 피어는 피어 프로토콜을 실행하여 콘텐츠를 검색하고 재배포합니다. PPSPP URL의 형식은 확장 문서에서 정의되어야 합니다. URL을 작게 유지하려면 기본 프로토콜 옵션을 활용해야 합니다.

떼에 대한 피어 목록을 쿼리할 때 추적 시설이 반환해야 하는 최소 정보는 다음과 같습니다. 추적 시설과 요청자 간의 통신이 보호된다는 가정 하에 시설은 최소한 목록의 각 피어에 대해 IP 주소, 전송 프로토콜 식별자\(예: UDP\) 및 전송 프로토콜 포트 번호를 반환해야 합니다.

---
#### **11.1.2.  Migration Path**

유사한 기능을 제공하는 이전 표준 프로토콜이 없기 때문에 이 문서에서는 마이그레이션 경로를 자세히 설명하지 않습니다.

---
#### **11.1.3.  Requirements on Other Protocols and Functional Components**

P2P 스트리밍 프로토콜 추적기를 사용할 때 PPSPP는 섹션 12.2에 자세히 설명된 대로 보안상의 이유로 이 프로토콜의 특정 동작을 요구합니다.

---
#### **11.1.4.  Impact on Network Operation**

PPSPP는 견고성, 확장성 및 성능을 향상시키기 위해 여러 소스에서 콘텐츠를 사용할 수 있다는 점을 활용하는 P2P 프로토콜입니다. 동시에, 사용할 정확한 소스를 결정하는 데 있어 잘못된 선택은 최종 사용자의 경험을 저하시키고 네트워크 운영자에게 높은 비용을 초래할 수 있습니다. 따라서 PPSPP는 섹션 3.10.1에 설명된 대로 피어 선택을 조정하기 위해 ALTO 프로토콜의 이점을 누릴 수 있습니다.

---
#### **11.1.5.  Verifying Correct Operation**

모든 피어가 원하는 콘텐츠를 적시에 얻을 때 PPSPP가 올바르게 작동하는 것입니다. 따라서 PPSPP 클라이언트는 프로토콜의 올바른 작동을 확인하는 이상적인 위치입니다. 그러나 개인정보 보호 등의 이유로 모든 구현 및 배포에서 PPSPP 피어의 동작을 기록하도록 의무화하는 것은 불가능합니다. 두 가지 대체 옵션이 있습니다.

- 대역폭 사용량, 피어 연결 및 활동과 같은 표준 메트릭을 사용하여 초기에 콘텐츠를 제공하는 PPSPP 서버를 모니터링하면 문제를 식별하는 데 도움이 될 수 있습니다. 다음 섹션 및 \[RFC2564\]를 참조하세요.

- 추적기 프로토콜 \[PPSP-TP\]는 \[RFC6972\]의 PPSP.OAM.REQ-3에 따라 작업의 전체 보기를 얻기 위해 떼의 모든 피어에 대한 정보를 수집하는 데 사용될 수 있습니다.

PPSPP 다운로드를 시작하여 추적기와 떼 메타데이터를 알면 프로토콜의 기본 작동을 쉽게 확인할 수 있습니다. DATA 및 ACK 메시지에 대한 심층 패킷 검사는 실제 콘텐츠 전송이 일어나고 있는지, 청크 가용성 신호 및 무결성 검사가 작동하는지 확인하는 데 도움이 됩니다.

---
#### **11.1.6.  Configuration**

표 8은 PPSPP 매개변수, 해당 기본값, 매개변수가 정의된 위치를 보여줍니다. 기본값이 없는 매개변수의 경우 표 행에 "var"라는 단어가 포함되며 값을 선택할 때 고려해야 할 사항을 논의하는 섹션을 참조합니다.

```text
   +-------------------------+-----------------------+-----------------+
   | Name                    | Default               | Definition      |
   +-------------------------+-----------------------+-----------------+
   | Chunk Size              | var, 1024 bytes       | Section 8.1     |
   |                         | recommended           |                 |
   |                         |                       |                 |
   | Static Content          | 1 (Merkle Hash Tree)  | Section 7.5     |
   | Integrity Protection    |                       |                 |
   | Method                  |                       |                 |
   |                         |                       |                 |
   | Live Content Integrity  | 3 (Unified Merkle     | Section 7.5     |
   | Protection Method       | Tree)                 |                 |
   |                         |                       |                 |
   | Merkle Hash Tree        | 2 (SHA-256)           | Section 7.6     |
   | Function                |                       |                 |
   |                         |                       |                 |
   | Live Signature          | 13 (ECDSAP256SHA256)  | Section 7.7     |
   | Algorithm               |                       |                 |
   |                         |                       |                 |
   | Chunk Addressing Method | 2 (32-bit chunk       | Section 7.8     |
   |                         | ranges)               |                 |
   |                         |                       |                 |
   | Live Discard Window     | var                   | Section 6.2,    |
   |                         |                       | Section 7.9     |
   |                         |                       |                 |
   | NCHUNKS_PER_SIG         | var                   | Section 6.1.2.1 |
   |                         |                       |                 |
   | Dead peer detection     | No reply in 3 minutes | Section 3.12    |
   |                         | + 3 datagrams         |                 |
   +-------------------------+-----------------------+-----------------+

                          Table 8: PPSPP Defaults
```

---
### **11.2.  Management Considerations**

PPSPP에 대한 관리 고려 사항은 대규모 콘텐츠 배포에 사용되는 다른 프로토콜, 특히 HTTP와 매우 유사합니다. 많은 수의 서버를 어떻게 관리합니까? 새 콘텐츠를 서버 팜에 푸시하고 단계적 릴리스를 허용하려면 어떻게 해야 합니까? 오류는 어떻게 감지되며 서버와 최종 사용자 성능은 어떻게 측정됩니까? 이러한 문제에 대한 표준 솔루션이 아직 개발 중이므로 이 섹션에서는 PPSPP 관리 방법에 대한 확실한 권장 사항을 제공할 수 없습니다. 따라서 현재 사용 가능한 표준 솔루션을 설명하고 향후 확장 문서가 보다 완전한 지침을 제공할 것이라고 가정합니다.

---
#### **11.2.1.  Management Interoperability and Information**

방금 언급한 것처럼 콘텐츠의 초기 복사본을 제공하는 PPSPP 서버는 WWW 및 FTP 서버와 유사합니다. 또한 대량으로 배포할 수 있으므로 표준 관리 시설의 이점을 누릴 수 있습니다. 따라서 PPSPP 서버는 파일 개체를 사용하여 떼에 대해 보고할 수 있는 APPLICATION-MIB \[RFC2564\]를 기반으로 SNMP 관리 인터페이스를 구현할 수 있습니다.

누락된 것은 서버에서 특정 PPSPP 떼를 제거하거나 속도를 제한하는 기능입니다. 이는 웹 서버에서 특정 가상 서버를 제거하거나 제한하는 것에 해당합니다. 즉, 여러 콘텐츠\(군집, 가상 WWW 서버\)가 단일 서버 프로세스에 다중화되므로 해당 프로세스에 대한 보다 세분화된 관리가 필요합니다. 이 기능은 현재 없습니다.

로깅은 PPSPP 서버와 배포에 따라 PPSPP 클라이언트에 중요한 기능입니다. 로깅은 syslog \[RFC5424\]를 통해 수행되어야 합니다.

---
#### **11.2.2.  Fault Management**

올바른 작동 및 서버 관리\(방금 논의한\)를 확인하는 기능은 PPSPP 오류 모니터링에 충분한 것으로 보입니다. PPSPP 서버 오류는 일반적으로 호스트 또는 네트워크의 조건에 직접적으로 기인할 수 있으므로 이는 호스트 리소스\[RFC2790\] 및 UDP/IP 네트워크 모니터링\[RFC4113\]으로 보완될 수 있습니다.

PPSPP는 적대적인 환경에서 작동하도록 설계되었으므로 공격 관리에 사용되는 메커니즘을 통해 많은 양성 오류가 처리됩니다. 예를 들어, 오작동하는 피어가 잘못된 청크를 보내기 시작하면 콘텐츠 무결성 보호 메커니즘이 이를 감지하고 다른 소스를 찾습니다.

---
#### **11.2.3.  Configuration Management**

대규모 배포에서는 초기 PPSPP 서버 세트에 새로운 콘텐츠를 복제하는 표준 방법을 활용하는 것이 좋습니다. 이 기능에는 특정 시점\(예: 영화 예고편 출시\)에만 콘텐츠를 사용할 수 있도록 제어된 출시가 포함되어야 할 수도 있습니다. 이 기능은 NETCONF \[RFC6241\]를 통해 제공되어 서버 집합에 대한 원자 구성 업데이트를 활성화할 수 있습니다. 새 콘텐츠를 업로드하는 것은 구성 변경 중 하나일 수 있으며, 대중이 콘텐츠를 다운로드할 수 있도록 하는 것도 가능합니다.

---
#### **11.2.4.  Accounting Management**

콘텐츠 제공업체는 다양한 고객에게 PPSPP 호스팅을 제공할 수 있으며 예를 들어 대역폭 사용량을 기준으로 이러한 고객에게 요금을 청구할 수 있습니다. 이 상황은 웹 서버에 대한 가상 서버당 청구와 유사한 일반적인 회계 시나리오입니다. 따라서 PPSPP는 결실을 맺을 때 이 분야\[RFC2975\]의 일반적인 표준화 노력으로부터 이익을 얻을 수 있습니다.

---
#### **11.2.5.  Performance Management**

배포 시나리오에 따라 \[RFC3729\] 및 관련 \[RFC4150\]의 애플리케이션 성능 측정 기능을 PPSPP와 함께 사용할 수 있습니다.

또한 PPSPP 추적기 프로토콜을 사용하면 다양한 측정 항목에 대한 내장된 애플리케이션 수준 성능 측정 인프라를 제공합니다. \[RFC6972\]의 PPSP.OAM.REQ-3을 참조하세요.

---
#### **11.2.6.  Security Management**

악의적인 피어는 장기적으로 차단되는 것이 이상적입니다. 이는 프로토콜이 공격에 강력하기 때문에 주로 성능상의 이유입니다\(다음 섹션 참조\). 섹션 12.7에는 장기 배제 절차가 설명되어 있습니다.

---
## **12.  Security Considerations**

다른 네트워크 프로토콜과 마찬가지로 PPSPP는 공통적인 보안 문제에 직면해 있습니다. 구현에서는 버퍼 오버런, DoS 공격 및 조작\(예: 반사 공격\)의 가능성을 고려해야 합니다. 사용자가 자신의 IP 주소를 동료에게 노출하므로 개인 정보 보호가 보장될 가능성은 거의 없습니다. 가능한 예외는 사용자가 공용 NAT 또는 프록시 뒤에 숨어 있는 경우입니다. 이 섹션에서는 프로토콜의 보안 고려 사항을 자세히 설명합니다.

---
### **12.1.  Security of the Handshake Procedure**

\[RFC5971\]의 분석을 빌려 PPSPP는 세 가지 유형의 서비스 거부 공격으로 공격받을 수 있습니다.

1. DoS 증폭 공격: 공격자는 PPSPP 피어를 사용하여 피해자에게 더 많은 트래픽을 생성하려고 합니다.

1. DoS 플러드 공격: 공격자는 PPSPP 피어에 많은 상태를 할당하여 다른 피어에 대한 서비스를 거부하려고 합니다.

1. 개별 피어에 대한 서비스 중단: 공격자는 피해자 피어 A에서 해당 피어를 서비스하는 피어 B1..Bn으로 가짜 메시지\(예: REQUEST 및 HAVE 메시지\)를 보냅니다. 이로 인해 피어 A는 요청하지 않은 청크를 수신하거나 요청한 청크를 수신하지 못하게 됩니다.

이러한 공격으로부터 보호하기 위한 기본 체계는 보안 핸드셰이크 절차를 사용하는 것입니다. UDP 캡슐화에서 핸드셰이크 절차는 다음과 같이 무작위로 선택된 채널 ID를 사용하여 보호됩니다. 채널 ID는 \[RFC4960\]\(섹션 5.1.3\)의 요구 사항에 따라 생성되어야 합니다.

UDP가 사용되면 PPSPP 메시지를 전달하는 모든 데이터그램에는 4바이트 채널 ID가 앞에 붙습니다. 이러한 채널 ID는 다음과 같이 핸드셰이크 단계에서 설정된 임의의 숫자입니다. 피어 A는 모두 0으로 구성된 채널 ID가 앞에 붙은 HANDSHAKE 메시지가 포함된 데이터그램을 전송하여 피어 B와의 교환을 시작합니다. 피어 A의 HANDSHAKE에는 무작위로 선택된 채널 ID인 chanA가 포함됩니다.

```text
   A->B: chan0 + HANDSHAKE(chanA) + ...
```

피어 B가 이 데이터그램을 수신하면 최소한 채널 ID chanA를 포함하는 피어 A에 대한 일부 상태를 생성합니다. 다음으로 피어 B는 chanA 채널 ID가 앞에 붙은 HANDSHAKE 메시지를 포함하는 데이터그램으로 구성된 응답을 피어 A에 보냅니다. 피어 B의 HANDSHAKE에는 무작위로 선택된 채널 ID인 chanB가 포함됩니다.

```text
   B->A: chanA + HANDSHAKE(chanB) + ...
```

피어 A는 이제 피어 B가 chanA를 반영하여 실제로 응답한다는 것을 알고 있습니다. 따라서 피어 A가 보내는 다음 데이터그램에는 이미 무거운 페이로드, 즉 청크가 포함되어 있을 수 있습니다. 피어 B에 대한 다음 데이터그램에는 chanB 채널 ID가 접두어로 붙습니다. 피어 B가 이 데이터그램을 받으면 두 피어 모두 실제로 서로 대화하고 있다는 증거를 갖게 되며 3방향 핸드셰이크가 완료됩니다. 즉, 무작위로 선택된 채널 ID가 태그 역할을 합니다\(\[RFC4960\]\(섹션 5.1\) 참조\).

A-\>B: chanB + HAVE + DATA + ...

---
#### **12.1.1.  Protection against Attack 1**

간단히 말해서, PPSPP는 무거운 페이로드가 전송되기 전에 소위 반환 라우팅 가능성 검사를 수행합니다. 이는 공격 1이 방어된다는 것을 의미합니다. PPSPP는 실제 피어와 통신하고 있다는 것을 알지 않는 한 수신한 것보다 훨씬 많은 데이터를 다시 보내지 않습니다. 피어 A인 척하면서 피어 B에게 스푸핑된 HANDSHAKE를 보내는 공격자는 이제 메시지를 가로채야 합니다.

피어 B에서 피어 A로 피어 B가 무거운 페이로드를 보내도록 하고, 그 무거운 페이로드가 피해자에게 전달되도록 보장합니다. 이는 실제 공격이 되기에는 너무 어렵다고 가정됩니다.

세 번째 데이터그램이 나올 때까지는 무거운 페이로드를 보낼 수 없다는 규칙이 있습니다. 이는 장황한 청크 주소 지정 체계를 사용하는 PPSPP 구현에 영향을 미칩니다. PPSPP 구현이 청크 가용성을 전달하기 위해 큰 비트맵을 사용하는 경우 피어 B가 두 번째 데이터그램으로 이를 전송하지 않을 수 있습니다.

---
#### **12.1.2.  Protection against Attack 2**

첫 번째 데이터그램을 수신하면 피어 B는 피어 A에 대한 일부 상태를 기록합니다. 현재 이 상태는 chanA 채널 ID와 첫 번째 데이터그램의 다른 메시지 처리 결과로 구성됩니다. 특히 피어 A에 일부 HAVE 메시지가 포함된 경우 피어 B는 피어 A의 상태에 청크 가용성 맵을 추가할 수 있습니다. 또한 피어 B는 두 번째 데이터그램에서 피어 A로부터 일부 청크를 요청할 수 있으며 피어 B는 이러한 나가는 요청에 대한 상태를 유지합니다.

따라서 현재 PPSPP는 공격 2에 다소 취약합니다. 공격자는 HANDSHAKE 및 HAVE가 포함된 많은 데이터그램을 보낼 수 있으므로 PPSPP 피어에 상태를 할당할 수 있습니다. 따라서 피어 A는 여전히 피어 B에 관심이 있는 경우 두 번째 데이터그램에 즉시 응답해야 합니다.

SCTP\(Stream Control Transmission Protocol\) \[RFC4960\]\(섹션 5.1\)의 안전한 핸드셰이크 절차 대신 약간 취약한 이 3방향 핸드셰이크를 사용하는 이유는 사용자의 응답 시간이 더 빠르기 때문입니다. SCTP 절차에서 피어 A와 B는 제안된 절차의 데이터그램 2와 1과 달리 각각 데이터그램 3과 4까지 청크를 요청할 수 없습니다. 이는 사용자가 비디오 스트림을 시작하고 첫 번째 이미지를 보는 사이에 PPSPP에서 더 적은 시간을 기다려야 함을 의미합니다.

---
#### **12.1.3.  Protection against Attack 3**

일반적으로 채널 ID는 피어를 인증하는 데 사용됩니다. 따라서 공격하려면 악의적인 피어 T가 피해자 A와 양성 피어 B 사이의 대화를 도청하여 피어 A에 할당된 채널 ID 피어 B, chanB를 얻을 수 있어야 합니다. 또한 공격자 피어 T는 피어 A로부터 REQUEST 및 HAVE 메시지를 스푸핑하여 피어 B가 피어 A에 무거운 DATA 메시지를 보내도록 하거나 피어 B가 해당 메시지를 보내는 것을 방지할 수 있어야 합니다.

도청 기능은 일반적이지 않으므로 대부분의 경우 채널 ID로 제공되는 보호로 충분합니다. 그렇지 않은 경우 트래픽의 지점 간 암호화를 사용해야 합니다. 아래를 참조하세요.

---
### **12.2.  Secure Peer Address Exchange**

섹션 3.10에 설명된 대로 피어 A는 피어 B에 Peer-Exchange 메시지 PEX\_RES를 보낼 수 있습니다. 여기에는 현재 스웜에도 있는 것으로 추정되는 다른 피어의 IP 주소와 포트가 포함되어 있습니다. 이 메커니즘의 장점은 분산 추적이 가능하다는 것입니다. 즉, 초기 부트스트랩 후에는 중앙 추적기가 필요하지 않습니다. 이 메커니즘\(및 DHT\)의 취약점은 악의적인 피어가 증폭 공격에 이를 사용할 수 있다는 것입니다.

특히, 악의적인 피어 T는 피어 B1..Bn의 주소를 사용하여 선의로 행동하는 피어 A에게 PEX\_RES 메시지를 보낼 수 있습니다. 수신 시 피어 A는 이러한 모든 피어에게 HANDSHAKE를 보낼 수 있습니다. 따라서 최악의 경우 단일 데이터그램은 N개의 데이터그램이 됩니다. 실제 피해는 피어 A의 행동에 따라 달라집니다. 예를 들어, 피어 A가 이미 충분한 연결을 갖고 있는 경우 제공된 피어 A에 전혀 연결되지 않을 수 있습니다. 그러나 새로운 피어인 경우 모든 항목에 직접 연결할 수 있습니다.

또한 PEX는 악의적인 피어가 악의적인 피어하고만 상호 작용하도록 특정 피어를 격리하려는 Eclipse 공격\[ECLIPSE\]에 사용될 수 있습니다. 두 가지 특정 공격을 구별해 보겠습니다.

```text
      E1.   Malicious peers try to eclipse the single injector in live
            streaming.
```

-E2. 악의적인 피어는 특정 소비자 피어를 무력화하려고 합니다.

공격 E1은 모든 피어를 방해하므로 시스템에 가장 큰 영향을 미칩니다.

---
#### **12.2.1.  Protection against the Amplification Attack**

피어 주소가 상대적으로 안정적인 경우 공개 키 암호화 및 인증을 사용하여 공격에 대한 강력한 보호를 제공할 수 있습니다. 특히 PEX\_REScert 메시지는 IP 주소와 포트 대신 군집 구성원 인증서를 전달합니다. 피어 B의 멤버십 인증서에는 주소\(ipB,portB\)의 피어 B가 시간 T에 Swarm S의 일부이며 암호화되어 서명되어 있음이 나와 있습니다. 수신자 피어 A는 인증서에서 유효한 서명, 올바른 스웜 및 활성 상태를 확인한 후 피어 B와의 접촉을 고려할 수 있습니다. 이러한 스웜 멤버쉽 인증서는 보안 분산 피어 샘플링 서비스\(SPS\)의 서명된 노드 설명자에 해당합니다.

이러한 회원증에 대한 보안 환경은 여러 가지 설계가 가능합니다. 즉, 회원 인증서에 서명하는 사람과 공개 키가 배포되는 방식에 대해 다양한 설계가 가능합니다. 예를 들어 P2P 스트리밍 프로토콜 추적기가 인증 기관 역할을 하는 설계를 설명합니다.

---
#### **12.2.2.  Example: Tracker as Certification Authority**

Swarm S에 가입하기를 원하는 피어 A는 해당 Swarm에 대한 Tracker X에 인증서 요청 메시지를 보냅니다. 수신 시 추적기는 Swarm ID S, 타임스탬프 T, 메시지를 수신한 외부 IP 및 포트를 사용하여 요청으로부터 멤버십 인증서를 생성하고 추적기의 개인 키로 서명합니다. 이 인증서는 피어 A로 반환됩니다.

그런 다음 피어 A는 PEX\_REScert를 피어 B에 보낼 때 이 인증서를 포함합니다. 수신기 피어 B는 추적기 공개 키에 대해 이를 확인합니다. 이 추적기 공개 키는 피어 B가 신뢰할 수 있는 소스로부터 받은 떼의 메타데이터의 일부여야 합니다. 이후에 피어 B는 PEX\_REScert 메시지를 통해 피어 A의 구성원 인증서를 다른 피어에게 보낼 수 있습니다.

피어 A는 처음으로 추적기에 접속할 때 또는 나중에 인증 요청을 보낼 수 있습니다. 또한 추적기가 보내는 응답에는 일반 주소 대신 회원 인증서가 포함될 수 있으므로 안전하게 험담을 할 수도 있습니다.

우리는 추적기가 공격으로부터 보호되고 반환 라우팅 가능성 검사를 수행한다고 가정합니다. 후자는 악의적인 피어가 들어오는 트래픽을 도청할 수 있는 호스트에 대해서만 임의 호스트에 대한 인증서를 얻을 수 없도록 보장합니다.

추적기에서 생성된 부하는 이탈 및 인증서 수명에 따라 달라집니다. 멤버십 인증서의 주요 목표가 악의적인 피어 T가 좋은 피어 A가 \*무작위\* 호스트에 접속하도록 유도하는 것을 방지하는 것이라는 점을 고려하면 인증서는 상당히 오래 지속될 수 있습니다. 타임스탬프의 최신성은 해당 목표를 달성하는 것 외에도 추가 보호를 추가합니다. 이는 좋은 피어 A가 이전에 떼에 참여한 호스트에 연락하도록 하는 악의적인 호스트로부터 보호합니다.

멤버십 인증서 메커니즘 자체는 좋은 피어에 대한 일종의 증폭 공격에 사용될 수 있습니다. 악의적인 피어 T는 피어 A가 피어 T가 보내는 멤버십 인증서의 서명을 확인하기 위해 일부 CPU를 소비하게 할 수 있습니다. 이에 대응하려면 피어 A는 전송된 인증서 중 일부를 확인하고 결함이 있는 경우 나머지 인증서를 폐기해야 합니다.

위에서 설명한 것과 동일한 회원 인증서는 잘 알려진 DHT 특정 공격 \[SECDHTS\]으로부터 보호되는 분산 해시 테이블에 등록될 수 있습니다.

이 체계는 대칭 네트워크 주소 변환기 뒤의 피어에는 작동하지 않지만 일반 추적기 등록도 작동하지 않습니다.

---
#### **12.2.3.  Protection against Eclipse Attacks**

Eclipse 공격에 대해 논의하기 전에 먼저 중앙 추적기의 보안 속성을 설정해야 합니다. 추적기는 증폭 공격에도 취약합니다. 악의적인 피어 T는 피해자 피어 B를 추적기에 등록할 수 있으며, 떼에 합류하는 많은 피어는 피어 B에 연락하게 됩니다. 추적기는 Eclipse 공격에도 사용될 수 있습니다. 많은 악성 피어가 추적기에 등록되면 반환된 주소 목록에서 불량 피어의 비율이 높아질 수 있습니다. 추적기의 보호를 P2P 스트리밍 프로토콜 추적기 사양 \[PPSP-TP\]에 맡기고, 다음 논의에서는 실제 군집 구성원의 실제 무작위 샘플을 반환한다고 가정합니다\(Sybil 공격 보호를 통해 달성됨\). 이는 피어의 50%가 불량하더라도 추적기에서 여전히 50%의 좋은 주소를 얻을 수 있음을 의미합니다.

PEX에 대한 공격 E1은 라이브 인젝터가 PEX를 비활성화하도록 하여 방어할 수 있습니다. 또는 적어도 라이브 인젝터가 연결의 일부가 신뢰할 수 있는 추적기에서 주소를 가져온 피어에 대한 것인지 확인하도록 하여 방어할 수 있습니다.

동일한 조치로 PEX에 대한 공격 E2를 방어합니다. 또한 동적으로 사용할 수도 있습니다. 피어 A가 연결된 피어 B의 현재 집합이 좋은 서비스 품질을 제공하지 않는 경우 피어 A는 추적기에 연결하여 새 후보를 찾을 수 있습니다.

---
### **12.3.  Support for Closed Swarms**

\[RFC6972\]의 PPSP.SEC.REQ-1과 관련하여 Closed Swarms\[CLOSED\] 및 Enhanced Closed Swarms\[ECS\] 메커니즘은 Swarm 수준 액세스 제어를 제공합니다. 기본 아이디어는 피어가 액세스 증명을 표시하지 않는 한 다른 피어로부터 다운로드할 수 없다는 것입니다. Enhanced Closed Swarm은 중간자 공격에 대한 실시간 암호화와 보다 유연한 액세스 제어 규칙을 추가하여 원래 Closed Swarm을 개선합니다.

ECS와 PPSPP의 정확한 매핑은 \[ECS-protocol\]에 정의되어 있습니다.

---
### **12.4.  Confidentiality of Streamed Content**

\[RFC6972\]의 PPSP.SEC.REQ-1과 관련하여 PPSPP에서 기밀성을 지원하기 위해 추가 메커니즘이 필요하지 않습니다. 기밀성을 원하는 콘텐츠 게시자는 암호문 및/또는 디지털 권한 관리\(DRM\) 기술이 적용된 형식으로 콘텐츠를 배포하면 됩니다. 이 경우 상위 계층이 대역 외 키 관리를 처리한다고 가정합니다. 또는 제안된 Closed Swarms 액세스 제어 메커니즘, DTLS \[RFC6347\] 또는 IPsec \[RFC4301\]을 통해 콘텐츠 및 트래픽의 순수 지점 간 암호화를 제공할 수 있습니다.

DTLS를 통해 전송할 때 PPSPP는 조각화 없이 단일 데이터그램에 얼마나 많은 페이로드를 넣을 수 있는지 결정하기 위해 IP 계층에서 유지 관리하는 PMTU 추정치를 얻을 수 있습니다\(\[RFC6347\], 섹션 4.1.1.1\). PMTU가 변경되고 청크 크기가 너무 커서 단일 데이터그램에 맞지 않는 경우 PPSPP는 DF\(조각화 안 함\) 비트를 지워 조각화를 허용하도록 선택할 수 있습니다. 또는 콘텐츠 게시자는 MTU가 허용하는 경우 더 작은 청크를 사용하고 동일한 데이터그램으로 여러 개를 전송하기로 결정할 수 있습니다.

---
### **12.5.  Strength of the Hash Function for Merkle Hash Trees**

구현은 머클 해시 트리를 통한 콘텐츠 무결성 보호를 위한 해시 함수로 SHA-1을 지원해야 합니다. SHA-1은 전송 중 오버헤드를 줄이기 때문에 콘텐츠 공급자가 더 강력한 해시 기능보다 선호할 수 있습니다. 따라서 이는 성능과 보안 사이의 절충안을 제시합니다. SHA-1에 대한 보안 고려사항은 \[RFC6194\]에서 논의됩니다.

일반적으로 해시 함수는 해시 트리에서 사용되므로 충돌 생성이 더 복잡해집니다. 특히 공격자가 해시에 대한 충돌을 찾아낸 경우 하나의 청크만 교체할 수 있으므로 영향이 제한됩니다. 고정 크기 청크를 사용하는 경우 충돌은 원래 청크와 동일한 크기여야 합니다. 해시 트리에서 상위에 있는 해시의 경우 충돌은 두 해시의 연결이어야 합니다. 요약하자면, 해시 트리에 맞는 충돌을 찾는 것은 일반적으로 일반 충돌보다 찾기가 더 어렵습니다.

12.6. 불량하거나 손상된 피어에 의한 잠재적 피해 및 리소스 고갈을 제한하세요.

\[RFC6972\]의 PPSP.SEC.REQ-2와 관련하여 이 섹션에서는 악의적인 피어가 프로토콜의 각 메시지에 입힐 수 있는 잠재적 피해에 대한 분석과 프로토콜\(구현\)에 의해 이를 방지하는 방법을 제공합니다.

---
#### **12.6.1.  HANDSHAKE**

- 섹션 12.1에 설명된 대로 DoS 증폭 공격으로부터 보호됩니다.

- 위협 HS.1: 피어 T1..Tn이 피어 A에 대한 연결을 시작하여 피어 A의 모든 연결 슬롯을 채우는 Eclipse 공격입니다.

- 해결 방법: 피어 A는 다른 피어가 사용 가능한 모든 연결 슬롯을 채우도록 허용해서는 안 됩니다. 즉, 피어 A는 격리를 방지하기 위해 자체적으로 연결을 시작해야 합니다.

---
#### **12.6.2.  HAVE**

- 위협 HAVE.1: 악의적인 피어 T는 자신이 갖고 있지 않은 콘텐츠를 가지고 있다고 주장할 수 있습니다. 그 후 피어 T는 요청에 응답하지 않습니다.

- 해결책: 피어 A는 피어 T를 느린 피어로 간주하고 다시 요청하지 않습니다.

- 위협 HAVE.2: 악의적인 피어 T는 콘텐츠가 없다고 주장할 수 있습니다. 따라서 기여하지 않습니다.

- 솔루션: 프로토콜 외부의 피어 및 청크 선택 알고리즘은 공정성을 구현하고 공유 인센티브를 제공합니다.

---
#### **12.6.3.  DATA**

```text
   o  Threat DATA.1: Peer T sending bogus chunks.
```

- 해결 방법: 콘텐츠 무결성 보호 체계가 이를 방어합니다.

- 위협 DATA.2: 피어 T는 피어 A에게 요청되지 않은 청크를 보냅니다.

- 이 위협으로부터 보호하려면 네트워크 수준의 DoS 방지가 필요합니다.

---
#### **12.6.4.  ACK**

```text
   o  Threat ACK.1: Peer T acknowledges wrong chunks.
```

- 해결 방법: 피어 A는 피어 T에 전송된 데이터의 불일치를 감지합니다.

- 위협 ACK.2: 피어 T는 시간 기반 혼잡 제어에 사용되는 피어 A에 대한 ACK의 타임스탬프를 수정합니다.

- 해결 방법: 이론적으로 타임스탬프를 줄이면 피어 T는 실제로 정체가 있는데도 정체가 없는 것처럼 위장하여 피어 A가 필요한 것보다 더 많은 데이터를 보낼 수 있습니다. \[RFC6817\]에는 이를 보안 고려 사항으로 나열하지 않습니다. 아마도 이 공격은 왕복 시간과 측정된 단방향 지연 사이의 큰 비대칭성에 의해 탐지될 수 있습니다.

---
#### **12.6.5.  INTEGRITY and SIGNED_INTEGRITY**

- 위협 INTEGRITY.1: 피어 T가 가짜 INTEGRITY 또는 SIGNED\_INTEGRITY 메시지를 보내 피어 A가 해시 또는 서명을 확인하게 하여 불필요하게 CPU를 소비하게 하는 증폭 공격입니다.

- 해결 방법: 해시/서명이 체크아웃되지 않으면 피어 A는 원자 데이터그램 원칙과 콘텐츠 무결성 보호로 인해 피어 T에 대한 요청을 중단합니다. 피어 T의 후속 원치 않는 트래픽은 무시됩니다.

- 위협 INTEGRITY.2: 피어 T가 통합 머클 트리 방식으로 오래된 SIGNED\_INTEGRITY 메시지를 전송하여 피어 A가 라이브 스트림의 과거 지점에 동조하도록 만드는 공격입니다.

- 해결 방법: SIGNED\_INTEGRITY 메시지의 타임스탬프는 이러한 재생을 방지합니다. 피어 T의 후속 트래픽은 무시됩니다.

---
#### **12.6.6.  REQUEST**

- 위협 요청.1: 피어 T는 피어 A로부터 많은 것을 요청할 수 있으며, 피어 A는 다른 사람을 위한 자원이 없게 됩니다.

- 솔루션: 예를 들어 여러 피어의 필요성을 고려하는 업로드 대역폭 스케줄러를 사용하여 단일 피어가 소비할 수 있는 업로드 용량에 제한이 적용됩니다. 이 업로드 할당량의 자연적인 상한은 콘텐츠의 비트 전송률이며, 이는 가변적일 수 있다는 점을 고려합니다.

---
#### **12.6.7.  CANCEL**

- 위협 CANCEL.1: 피어 T는 피어 A에게 요청한 적이 없는 콘텐츠에 대해 CANCEL 메시지를 보냅니다.

- 해결 방법: 피어 A는 메시지의 불일치를 감지하고 무시합니다. REQUEST 메시지가 손실되거나 후속 CANCEL과 관련하여 재정렬될 수 있는 전송이 사용될 때 CANCEL 메시지가 예기치 않게 수신될 수 있습니다.

---
#### **12.6.8.  CHOKE**

- 위협 CHOKE.1: 피어 A가 피어 B에게 CHOKE 메시지를 보낸 후 피어 T는 REQUEST 메시지를 보냅니다.

- 해결 방법: 피어 A는 원치 않는 REQUEST를 삭제하고 CHOKE가 손실되었다고 가정하여 다시 보냅니다.

---
#### **12.6.9.  UNCHOKE**

- 위협 UNCHOKE.1: 피어 T는 이전에 CHOKE 메시지를 보낸 적이 없이 피어 A에게 UNCHOKE 메시지를 보냅니다.

- 해결 방법: 피어 A는 이러한 프로토콜 상태 위반을 쉽게 감지하고 무시할 수 있습니다. 이는 양성 피어가 보낸 CHOKE 메시지 손실로 인해 발생할 수도 있습니다.

- 위협 UNCHOKE.2: 피어 T는 피어 A에게 UNCHOKE 메시지를 보내지만 이후 해당 요청에 응답하지 않습니다.

- 해결책: 피어 A는 피어 T를 느린 피어로 간주하고 다시 요청하지 않습니다.

---
#### **12.6.10.  PEX_RES**

- 섹션 12.2에 설명된 대로 증폭 및 Eclipse 공격으로부터 보호됩니다.

---
#### **12.6.11.  Unsolicited Messages in General**

- 위협: 피어 T는 스푸핑된 PEX\_REQ 또는 REQUEST를 피어 B에서 피어 A로 보내 피어 A가 피어 B로 PEX\_RES/DATA를 보내도록 할 수 있습니다.

- 해결 방법: Peer T가 먼저 핸드셰이크를 하지 않는 한 Peer T의 메시지는 수락되지 않습니다. 이 경우 응답은 피해자 Peer B가 아닌 Peer T로 전달됩니다.

---
### **12.7.  Exclude Bad or Broken Peers**

이 섹션은 \[RFC6972\]의 PPSP.SEC.REQ-2에 관한 것입니다. 수신 피어는 방금 설명한 대로 악의적이거나 결함이 있는 보낸 사람을 감지한 다음 이를 무시할 수 있습니다. 그러나 이러한 불량 피어를 시스템에서 완전히 제외하는 것은 복잡합니다. \[DETMAL\]에 설명된 대로 불량 피어를 블랙리스트에 추가하는 신뢰할 수 있는 피어에 의한 무작위 모니터링은 하나의 옵션입니다. 이 메커니즘에는 일반 피어와 구별할 수 없는 신뢰할 수 있는 피어를 실행하기 위한 추가 용량이 필요하며 확장 가능한 방식으로 이 블랙리스트를 피어에 적시에 배포하기 위한 솔루션이 필요합니다.

---
## **13.  References**
---
### **13.1.  Normative References**

```text
   [CCITT.X690.2002]
              International Telephone and Telegraph Consultative
              Committee, "ASN.1 encoding rules: Specification of basic
              encoding Rules (BER), Canonical encoding rules (CER) and
              Distinguished encoding rules (DER)", CCITT Recommendation
              X.690, July 2002.

   [FIPS180-4]
              National Institute of Standards and Technology,
              Information Technology Laboratory, "Federal Information
              Processing Standards: Secure Hash Standard (SHS)", FIPS
              PUB 180-4, March 2012.

   [IANADNSSECALGNUM]
              IANA, "Domain Name System Security (DNSSEC) Algorithm
              Numbers", March 2014,
              <http://www.iana.org/assignments/dns-sec-alg-numbers>.

   [RFC1918]  Rekhter, Y., Moskowitz, B., Karrenberg, D., J. de Groot,
              G., and E. Lear, "Address Allocation for Private
              Internets", BCP 5, RFC 1918, DOI 10.17487/RFC1918,
              February 1996, <http://www.rfc-editor.org/info/rfc1918>.

   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", BCP 14, RFC 2119,
              DOI 10.17487/RFC2119, March 1997,
              <http://www.rfc-editor.org/info/rfc2119>.

   [RFC3110]  Eastlake 3rd, D., "RSA/SHA-1 SIGs and RSA KEYs in the
              Domain Name System (DNS)", RFC 3110, DOI 10.17487/RFC3110,
              May 2001, <http://www.rfc-editor.org/info/rfc3110>.

   [RFC3986]  Berners-Lee, T., Fielding, R., and L. Masinter, "Uniform
              Resource Identifier (URI): Generic Syntax", STD 66, RFC
              3986, DOI 10.17487/RFC3986, January 2005,
              <http://www.rfc-editor.org/info/rfc3986>.

   [RFC4034]  Arends, R., Austein, R., Larson, M., Massey, D., and S.
              Rose, "Resource Records for the DNS Security Extensions",
              RFC 4034, DOI 10.17487/RFC4034, March 2005,
              <http://www.rfc-editor.org/info/rfc4034>.

   [RFC4291]  Hinden, R. and S. Deering, "IP Version 6 Addressing
              Architecture", RFC 4291, DOI 10.17487/RFC4291, February
              2006, <http://www.rfc-editor.org/info/rfc4291>.

   [RFC5280]  Cooper, D., Santesson, S., Farrell, S., Boeyen, S.,
              Housley, R., and W. Polk, "Internet X.509 Public Key
              Infrastructure Certificate and Certificate Revocation List
              (CRL) Profile", RFC 5280, DOI 10.17487/RFC5280, May 2008,
              <http://www.rfc-editor.org/info/rfc5280>.

   [RFC5702]  Jansen, J., "Use of SHA-2 Algorithms with RSA in DNSKEY
              and RRSIG Resource Records for DNSSEC", RFC 5702,
              DOI 10.17487/RFC5702, October 2009,
              <http://www.rfc-editor.org/info/rfc5702>.

   [RFC5905]  Mills, D., Martin, J., Ed., Burbank, J., and W. Kasch,
              "Network Time Protocol Version 4: Protocol and Algorithms
              Specification", RFC 5905, DOI 10.17487/RFC5905, June 2010,
              <http://www.rfc-editor.org/info/rfc5905>.

   [RFC6605]  Hoffman, P. and W. Wijngaards, "Elliptic Curve Digital
              Signature Algorithm (DSA) for DNSSEC", RFC 6605,
              DOI 10.17487/RFC6605, April 2012,
              <http://www.rfc-editor.org/info/rfc6605>.

   [RFC6817]  Shalunov, S., Hazel, G., Iyengar, J., and M. Kuehlewind,
              "Low Extra Delay Background Transport (LEDBAT)", RFC 6817,
              DOI 10.17487/RFC6817, December 2012,
              <http://www.rfc-editor.org/info/rfc6817>.
```

---
### **13.2.  Informative References**

```text
   [ABMRKL]   Bakker, A., "Merkle hash torrent extension", BitTorrent
              Enhancement Proposal 30, March 2009,
              <http://bittorrent.org/beps/bep_0030.html>.

   [BINMAP]   Grishchenko, V. and J. Pouwelse, "Binmaps: Hybridizing
              Bitmaps and Binary Trees", Delft University of Technology
              Parallel and Distributed Systems Report Series, Report
              number PDS-2011-005, ISSN 1387-2109, April 2009.

   [BITOS]    Vlavianos, A., Iliofotou, M., Mathieu, F., and M.
              Faloutsos, "BiToS: Enhancing BitTorrent for Supporting
              Streaming Applications", IEEE INFOCOM Global Internet
              Symposium, Barcelona, Spain, April 2006.

   [BITTORRENT]
              Cohen, B., "The BitTorrent Protocol Specification",
              BitTorrent Enhancement Proposal 3, February 2008,
              <http://bittorrent.org/beps/bep_0003.html>.

   [CLOSED]   Borch, N., Mitchell, K., Arntzen, I., and D. Gabrijelcic,
              "Access Control to BitTorrent Swarms Using Closed Swarms",
              ACM workshop on Advanced Video Streaming Techniques for
              Peer-to-Peer Networks and Social Networking (AVSTP2P '10),
              Florence, Italy, October 2010,
              <http://doi.acm.org/10.1145/1877891.1877898>.

   [DETMAL]   Shetty, S., Galdames, P., Tavanapong, W., and Ying. Cai,
              "Detecting Malicious Peers in Overlay Multicast
              Streaming", IEEE Conference on Local Computer Networks,
              (LCN'06), Tampa, FL, USA, November 2006.

   [ECLIPSE]  Sit, E. and R. Morris, "Security Considerations for Peer-
              to-Peer Distributed Hash Tables", IPTPS '01: Revised
              Papers from the First International Workshop on Peer-to-
              Peer Systems, pp. 261-269, Springer-Verlag, 2002.

   [ECS]      Jovanovikj, V., Gabrijelcic, D., and T. Klobucar, "Access
              Control in BitTorrent P2P Networks Using the Enhanced
              Closed Swarms Protocol", International Conference on
              Emerging Security Information, Systems and Technologies
              (SECURWARE 2011), pp. 97-102, Nice, France, August 2011.

   [ECS-protocol]
              Gabrijelcic, D., "Enhanced Closed Swarm protocol", Work in
              Progress, draft-ppsp-gabrijelcic-ecs-01, June 2013.

   [EPLIVEPERF]
              Bonald, T., Massoulie, L., Mathieu, F., Perino, D., and A.
              Twigg, "Epidemic live streaming: optimal performance
              trade-offs", Proceedings of the 2008 ACM SIGMETRICS
              International Conference on Measurement and Modeling of
              Computer Systems, Annapolis, MD, USA, June 2008.

   [GIVE2GET] Mol, J., Pouwelse, J., Meulpolder, M., Epema, D., and H.
              Sips, "Give-to-Get: Free-riding-resilient Video-on-Demand
              in P2P Systems", Proceedings Multimedia Computing and
              Networking conference (Proceedings of SPIE, Vol. 6818),
              San Jose, CA, USA, January 2008.

   [HAC01]    Menezes, A., van Oorschot, P., and S. Vanstone, "Handbook
              of Applied Cryptography", CRC Press, (Fifth Printing,
              August 2001), October 1996.

   [JIM11]    Jimenez, R., Osmani, F., and B. Knutsson, "Sub-Second
              Lookups on a Large-Scale Kademlia-Based Overlay", IEEE
              International Conference on Peer-to-Peer Computing
              (P2P'11), Kyoto, Japan, August 2011.

   [LBT]      Rossi, D., Testa, C., Valenti, S., and L. Muscariello,
              "LEDBAT: the new BitTorrent congestion control protocol",
              Computer Communications and Networks (ICCCN), Zurich,
              Switzerland, August 2010.

   [LCOMPL]   Testa, C. and D. Rossi, "On the impact of uTP on
              BitTorrent completion time", IEEE International Conference
              on Peer-to-Peer Computing (P2P'11), Kyoto, Japan, August
              2011.

   [MERKLE]   Merkle, R., "Secrecy, Authentication, and Public Key
              Systems", Ph.D. thesis, Dept. of Electrical Engineering,
              Stanford University, CA, USA, pp 40-45, 1979.

   [P2PWIKI]  Bakker, A., Petrocco, R., Dale, M., Gerber, J.,
              Grishchenko, V., Rabaioli, D., and J. Pouwelse, "Online
              video using BitTorrent and HTML5 applied to Wikipedia",
              IEEE International Conference on Peer-to-Peer Computing
              (P2P'10), Delft, The Netherlands, August 2010.

   [POLLIVE]  Dhungel, P., Hei, Xiaojun., Ross, K., and N. Saxena,
              "Pollution in P2P Live Video Streaming", International
              Journal of Computer Networks & Communications (IJCNC) Vol.
              1, No. 2, Jul 2009.

   [PPSP-TP]  Cruz, R., Nunes, M., Yingjie, G., Xia, J., Huang, R.,
              Taveira, J., and D. Lingli, "PPSP Tracker Protocol-Base
              Protocol (PPSP-TP/1.0)", Work in Progress,
              draft-ietf-ppsp-base-tracker-protocol-09, March 2015.

   [PPSPPERF] Petrocco, R., Pouwelse, J., and D. Epema, "Performance
              Analysis of the Libswift P2P Streaming Protocol", IEEE
              International Conference on Peer-to-Peer Computing
              (P2P'12), Tarragona, Spain, September 2012.

   [RFC2564]  Kalbfleisch, C., Krupczak, C., Presuhn, R., and J.
              Saperia, "Application Management MIB", RFC 2564,
              DOI 10.17487/RFC2564, May 1999,
              <http://www.rfc-editor.org/info/rfc2564>.

   [RFC2790]  Waldbusser, S. and P. Grillo, "Host Resources MIB", RFC
              2790, DOI 10.17487/RFC2790, March 2000,
              <http://www.rfc-editor.org/info/rfc2790>.

   [RFC2975]  Aboba, B., Arkko, J., and D. Harrington, "Introduction to
              Accounting Management", RFC 2975, DOI 10.17487/RFC2975,
              October 2000, <http://www.rfc-editor.org/info/rfc2975>.

   [RFC3365]  Schiller, J., "Strong Security Requirements for Internet
              Engineering Task Force Standard Protocols", BCP 61, RFC
              3365, DOI 10.17487/RFC3365, August 2002,
              <http://www.rfc-editor.org/info/rfc3365>.

   [RFC3729]  Waldbusser, S., "Application Performance Measurement MIB",
              RFC 3729, DOI 10.17487/RFC3729, March 2004,
              <http://www.rfc-editor.org/info/rfc3729>.

   [RFC4113]  Fenner, B. and J. Flick, "Management Information Base for
              the User Datagram Protocol (UDP)", RFC 4113,
              DOI 10.17487/RFC4113, June 2005,
              <http://www.rfc-editor.org/info/rfc4113>.

   [RFC4150]  Dietz, R. and R. Cole, "Transport Performance Metrics
              MIB", RFC 4150, DOI 10.17487/RFC4150, August 2005,
              <http://www.rfc-editor.org/info/rfc4150>.

   [RFC4193]  Hinden, R. and B. Haberman, "Unique Local IPv6 Unicast
              Addresses", RFC 4193, DOI 10.17487/RFC4193, October 2005,
              <http://www.rfc-editor.org/info/rfc4193>.

   [RFC4301]  Kent, S. and K. Seo, "Security Architecture for the
              Internet Protocol", RFC 4301, DOI 10.17487/RFC4301,
              December 2005, <http://www.rfc-editor.org/info/rfc4301>.

   [RFC4821]  Mathis, M. and J. Heffner, "Packetization Layer Path MTU
              Discovery", RFC 4821, DOI 10.17487/RFC4821, March 2007,
              <http://www.rfc-editor.org/info/rfc4821>.

   [RFC4960]  Stewart, R., Ed., "Stream Control Transmission Protocol",
              RFC 4960, DOI 10.17487/RFC4960, September 2007,
              <http://www.rfc-editor.org/info/rfc4960>.

   [RFC5226]  Narten, T. and H. Alvestrand, "Guidelines for Writing an
              IANA Considerations Section in RFCs", BCP 26, RFC 5226,
              DOI 10.17487/RFC5226, May 2008,
              <http://www.rfc-editor.org/info/rfc5226>.

   [RFC5389]  Rosenberg, J., Mahy, R., Matthews, P., and D. Wing,
              "Session Traversal Utilities for NAT (STUN)", RFC 5389,
              DOI 10.17487/RFC5389, October 2008,
              <http://www.rfc-editor.org/info/rfc5389>.

   [RFC5424]  Gerhards, R., "The Syslog Protocol", RFC 5424,
              DOI 10.17487/RFC5424, March 2009,
              <http://www.rfc-editor.org/info/rfc5424>.

   [RFC5706]  Harrington, D., "Guidelines for Considering Operations and
              Management of New Protocols and Protocol Extensions", RFC
              5706, DOI 10.17487/RFC5706, November 2009,
              <http://www.rfc-editor.org/info/rfc5706>.

   [RFC5971]  Schulzrinne, H. and R. Hancock, "GIST: General Internet
              Signalling Transport", RFC 5971, DOI 10.17487/RFC5971,
              October 2010, <http://www.rfc-editor.org/info/rfc5971>.

   [RFC6194]  Polk, T., Chen, L., Turner, S., and P. Hoffman, "Security
              Considerations for the SHA-0 and SHA-1 Message-Digest
              Algorithms", RFC 6194, DOI 10.17487/RFC6194, March 2011,
              <http://www.rfc-editor.org/info/rfc6194>.

   [RFC6241]  Enns, R., Ed., Bjorklund, M., Ed., Schoenwaelder, J., Ed.,
              and A. Bierman, Ed., "Network Configuration Protocol
              (NETCONF)", RFC 6241, DOI 10.17487/RFC6241, June 2011,
              <http://www.rfc-editor.org/info/rfc6241>.

   [RFC6347]  Rescorla, E. and N. Modadugu, "Datagram Transport Layer
              Security Version 1.2", RFC 6347, DOI 10.17487/RFC6347,
              January 2012, <http://www.rfc-editor.org/info/rfc6347>.

   [RFC6709]  Carpenter, B., Aboba, B., Ed., and S. Cheshire, "Design
              Considerations for Protocol Extensions", RFC 6709,
              DOI 10.17487/RFC6709, September 2012,
              <http://www.rfc-editor.org/info/rfc6709>.

   [RFC6972]  Zhang, Y. and N. Zong, "Problem Statement and Requirements
              of the Peer-to-Peer Streaming Protocol (PPSP)", RFC 6972,
              DOI 10.17487/RFC6972, July 2013,
              <http://www.rfc-editor.org/info/rfc6972>.

   [RFC7285]  Alimi, R., Ed., Penno, R., Ed., Yang, Y., Ed., Kiesel, S.,
              Previdi, S., Roome, W., Shalunov, S., and R. Woundy,
              "Application-Layer Traffic Optimization (ALTO) Protocol",
              RFC 7285, DOI 10.17487/RFC7285, September 2014,
              <http://www.rfc-editor.org/info/rfc7285>.

   [SECDHTS]  Urdaneta, G., Pierre, G., and M. van Steen, "A Survey of
              DHT Security Techniques", ACM Computing Surveys,
              vol. 43(2), January 2011.

   [SIGMCAST]
              Wong, C. and S. Lam, "Digital Signatures for Flows and
              Multicasts", IEEE/ACM Transactions on Networking 7(4),
              pp. 502-513, August 1999.

   [SPS]      Jesi, G., Montresor, A., and M. van Steen, "Secure Peer
              Sampling", Computer Networks vol. 54(12), pp. 2086-2098,
              Elsevier, August 2010.

   [SWIFTIMPL]
              Grishchenko, V., Paananen, J., Pronchenkov, A., Bakker,
              A., and R. Petrocco, "Swift reference implementation",
              2015, <https://github.com/libswift/libswift>.

   [TIT4TAT]  Cohen, B., "Incentives Build Robustness in BitTorrent",
              1st Workshop on Economics of Peer-to-Peer Systems,
              Berkeley, CA, USA, May 2003.
```

---
# **Acknowledgements**

Arno Bakker, Riccardo Petrocco 및 Victor Grishchenko는 7차 프레임워크 프로그램에 따라 유럽 공동체가 지원하는 연구 프로젝트인 P2P-Next 프로젝트 <http://www.p2p-next.org/\>에서 부분적으로 지원됩니다\(부여 계약 없음 .216217\). 여기에 포함된 견해와 결론은 저자의 견해와 결론이며 반드시 P2P-Next 프로젝트 또는 유럽 위원회의 공식 정책이나 명시적 또는 묵시적 지지를 나타내는 것으로 해석되어서는 안 됩니다.

PPSPP는 Johan Pouwelse의 감독하에 Technische Universiteit Delft의 Victor Grishchenko에 의해 설계되었습니다. 저자는 이 문서에 기여해 주신 다음 분들께 감사의 말씀을 전합니다. 의장\(Martin Stiemerling, Yunfei Zhang, Stefano Previdi, Ning Zong\), IETF PPSP 실무 그룹 회원, Mihai Capota, Raul Jimenez, Flutra Osmani , 그리고 Raynor Vliegendhart.

---
# **Authors' Addresses**

Arno Bakker Vrije Universiteit Amsterdam De Boelelaan 1081 암스테르담 1081HV 네덜란드

```text
   Email: arno@cs.vu.nl
```

Riccardo Petrocco Technische Universiteit Delft Mekelweg 4 Delft 2628CD 네덜란드

```text
   Email: r.petrocco@gmail.com
```

Victor Grishchenko Technische Universiteit Delft Mekelweg 4 Delft 2628CD 네덜란드

```text
   Email: victor.grishchenko@gmail.com
```
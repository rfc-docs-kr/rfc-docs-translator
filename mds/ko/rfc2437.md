

```text
Network Working Group                                         B. Kaliski
Request for Comments: 2437                                    J. Staddon
Obsoletes: 2313                                         RSA Laboratories
Category: Informational                                     October 1998

                PKCS #1: RSA Cryptography Specifications
                              Version 2.0
```

---
# **Status of this Memo**

이 메모는 인터넷 커뮤니티에 대한 정보를 제공합니다. 어떤 종류의 인터넷 표준도 지정하지 않습니다. 이 메모의 배포는 무제한입니다.

---
# **Copyright Notice**

저작권\(C\)인터넷학회\(1998\). 판권 소유.

---
# **Table of Contents**

```text
   1.       Introduction.....................................2
   1.1      Overview.........................................3
   2.       Notation.........................................3
   3.       Key types........................................5
   3.1      RSA public key...................................5
   3.2      RSA private key..................................5
   4.       Data conversion primitives.......................6
   4.1      I2OSP............................................6
   4.2      OS2IP............................................7
   5.       Cryptographic primitives.........................8
   5.1      Encryption and decryption primitives.............8
   5.1.1    RSAEP............................................8
   5.1.2    RSADP............................................9
   5.2      Signature and verification primitives...........10
   5.2.1    RSASP1..........................................10
   5.2.2    RSAVP1..........................................11
   6.       Overview of schemes.............................11
   7.       Encryption schemes..............................12
   7.1      RSAES-OAEP......................................13
   7.1.1    Encryption operation............................13
   7.1.2    Decryption operation............................14
   7.2      RSAES-PKCS1-v1_5................................15
   7.2.1    Encryption operation............................17
   7.2.2    Decryption operation............................17
   8.       Signature schemes with appendix.................18
   8.1      RSASSA-PKCS1-v1_5...............................19
   8.1.1    Signature generation operation..................20
   8.1.2    Signature verification operation................21
   9.       Encoding methods................................22
   9.1      Encoding methods for encryption.................22
   9.1.1    EME-OAEP........................................22
   9.1.2    EME-PKCS1-v1_5..................................24
   9.2      Encoding methods for signatures with appendix...26
   9.2.1    EMSA-PKCS1-v1_5.................................26
   10.      Auxiliary Functions.............................27
   10.1     Hash Functions..................................27
   10.2     Mask Generation Functions.......................28
   10.2.1   MGF1............................................28
   11.      ASN.1 syntax....................................29
   11.1     Key representation..............................29
   11.1.1   Public-key syntax...............................30
   11.1.2   Private-key syntax..............................30
   11.2     Scheme identification...........................31
   11.2.1   Syntax for RSAES-OAEP...........................31
   11.2.2   Syntax for RSAES-PKCS1-v1_5.....................32
   11.2.3   Syntax for RSASSA-PKCS1-v1_5....................33
   12       Patent Statement................................33
   12.1     Patent statement for the RSA algorithm..........34
   13.      Revision history................................35
   14.      References......................................35
            Security Considerations.........................37
            Acknowledgements................................37
            Authors' Addresses..............................38
            Full Copyright Statement........................39
```

---
## **1. Introduction**

이 메모는 RFC 2313의 후속 문서입니다. 이 문서는 다음 측면을 다루는 RSA 알고리즘\[18\]을 기반으로 하는 공개 키 암호화 구현에 대한 권장 사항을 제공합니다.

- -암호화 기본 요소 -암호화 체계 -부록이 있는 서명 체계 -키를 표현하고 체계를 식별하기 위한 ASN.1 구문

권장 사항은 컴퓨터 및 통신 시스템 내의 일반적인 적용을 위한 것이므로 상당한 유연성을 포함합니다. 이러한 사양을 기반으로 한 응용 표준에는 추가적인 제약 사항이 포함될 것으로 예상됩니다. 권장 사항은 현재 ANSI X9F1\[1\] 및 IEEE P1363 작업 그룹\[14\]에서 개발 중인 표준 초안과 호환되도록 고안되었습니다. 이 문서는 PKCS #1 버전 1.5 \[20\]를 대체합니다.

편집자 주. PKCS #1의 후속 버전에서는 키 크기, 키 생성, 키 유효성 검사 및 메시지 복구를 통한 서명 체계와 같은 RSA 알고리즘의 다른 측면을 다룰 수 있을 것으로 예상됩니다.

---
## **1.1 Overview**

이 문서의 구성은 다음과 같습니다.

- -1장은 소개입니다. -섹션 2에서는 이 문서에 사용된 일부 표기법을 정의합니다. -섹션 3에서는 RSA 공개 및 개인 키 유형을 정의합니다. -섹션 4와 5에서는 여러 기본 요소 또는 기본 수학 연산을 정의합니다. 데이터 변환 프리미티브는 섹션 4에 있고 암호화 프리미티브\(암호화-복호화, 서명-검증\)는 섹션 5에 있습니다. - 섹션 6, 7, 8에서는 이 문서의 암호화 및 서명 체계를 다룹니다. 섹션 6에서는 개요를 제공합니다. 7절에서는 PKCS #1 v1.5에 있는 방법과 함께 OAEP 기반 \[2\] 암호화 방식을 정의합니다. 섹션 8은 부록과 함께 서명 체계를 정의합니다. 방법은 PKCS #1 v1.5의 방법과 동일합니다. - 9절에서는 7절과 8절의 암호화 및 서명 체계에 대한 인코딩 방법을 정의합니다. - 10절에서는 본 문서에서 사용되는 해시 함수 및 마스크 생성 기능을 정의합니다. -섹션 11은 섹션 3에 정의된 키에 대한 ASN.1 구문을 정의하고 섹션 7과 8에 제공된 구성표를 정의합니다. -섹션 12는 PKCS #1의 개정 내역을 간략하게 설명합니다. -섹션 13에는 다른 간행물 및 표준에 대한 참조가 포함되어 있습니다.

---
## **2. Notation**

```text
   (n, e)        RSA public key

   c             ciphertext representative, an integer between 0 and n-1

   C             ciphertext, an octet string

   d             private exponent

   dP            p's exponent, a positive integer such that:
                  e(dP)\equiv 1 (mod(p-1))

   dQ            q's exponent, a positive integer such that:
                  e(dQ)\equiv 1 (mod(q-1))

   e             public exponent

   EM            encoded message, an octet string

   emLen         intended length in octets of an encoded message

   H             hash value, an output of Hash

   Hash          hash function

   hLen          output length in octets of hash function Hash

   K             RSA private key

   k             length in octets of the modulus

   l             intended length of octet string

   lcm(.,.)      least common multiple of two
                 nonnegative integers

   m             message representative, an integer between
                 0 and n-1

   M             message, an octet string

   MGF           mask generation function

   n             modulus

   P             encoding parameters, an octet string

   p,q           prime factors of the modulus

   qInv          CRT coefficient, a positive integer less
                 than p such: q(qInv)\equiv 1 (mod p)

   s             signature representative, an integer
                 between 0 and n-1

   S             signature, an octet string

   x             a nonnegative integer

   X             an octet string corresponding to x

   \xor          bitwise exclusive-or of two octet strings
```

\lambda\(n\) lcm\(p-1, q-1\), 여기서 n = pq

```text
   ||            concatenation operator

   ||.||         octet length operator
```

---
## **3. Key types**

이 문서에 정의된 기본 요소와 체계에는 RSA 공개 키와 RSA 개인 키라는 두 가지 키 유형이 사용됩니다. RSA 공개 키와 RSA 개인 키가 함께 RSA 키 쌍을 형성합니다.

---
## **3.1 RSA public key**

이 문서의 목적에 따라 RSA 공개 키는 두 가지 구성 요소로 구성됩니다.

n, 모듈러스, 음이 아닌 정수 e, 공개 지수, 음이 아닌 정수

유효한 RSA 공개 키에서 모듈러스 n은 두 개의 홀수 소수 p와 q의 곱이고, 공개 지수 e는 gcd \(e, \lambda\(n\)\) = 1을 충족하는 3과 n-1 사이의 정수입니다. 여기서 \lambda\(n\) = lcm \(p- 1,q-1\). 구현 간 RSA 공개 키 교환에 권장되는 구문은 섹션 11.1.1에 나와 있습니다. 구현의 내부 표현은 다를 수 있습니다.

---
## **3.2 RSA private key**

이 문서의 목적에 따라 RSA 개인 키는 두 가지 표현 중 하나를 가질 수 있습니다.

1. 첫 번째 표현은 \(n, d\) 쌍으로 구성되며, 여기서 구성 요소는 다음과 같은 의미를 갖습니다.

n, 모듈러스, 음이 아닌 정수 d, 전용 지수, 음이 아닌 정수

1. 두 번째 표현은 5중\(p, q, dP, dQ, qInv\)으로 구성되며, 여기서 구성 요소는 다음과 같은 의미를 갖습니다.

p, 첫 번째 인자, 음이 아닌 정수 q, 두 번째 인자, 음이 아닌 정수 dP, 첫 번째 인자의 지수, 음이 아닌 정수 dQ, 두 번째 인자의 지수, 음이 아닌 정수 qInv, CRT 계수, 음이 아닌 정수

첫 번째 표현을 가진 유효한 RSA 개인 키에서 모듈러스 n은 해당 공개 키와 동일하고 두 개의 홀수 소수 p와 q의 곱이며 개인 지수 d는 양수입니다.

다음을 만족하는 n보다 작은 정수:

```text
   ed \equiv 1 (mod \lambda(n))
```

여기서 e는 해당 공개 지수이고 \lambda\(n\)은 위에 정의된 것과 같습니다.

두 번째 표현을 사용하는 유효한 RSA 개인 키에서 두 요소 p와 q는 모듈러스 n의 소인수이고 지수 dP와 dQ는 각각 다음을 만족하는 p와 q보다 작은 양의 정수입니다.

```text
   e(dP)\equiv 1(mod(p-1))
   e(dQ)\equiv 1(mod(q-1)),
```

CRT 계수 qInv는 다음을 만족하는 p보다 작은 양의 정수입니다.

```text
   q(qInv)\equiv 1 (mod p).
```

두 표현의 구성 요소를 모두 포함하는 구현 간에 RSA 개인 키를 교환하기 위한 권장 구문은 섹션 11.1.2에 나와 있습니다. 구현의 내부 표현은 다를 수 있습니다.

---
## **4. Data conversion primitives**

이 문서에 정의된 체계에는 두 가지 데이터 변환 기본 요소가 사용됩니다.

```text
   I2OSP: Integer-to-Octet-String primitive
   OS2IP: Octet-String-to-Integer primitive
```

이 문서의 목적과 ASN.1 구문에 따라 옥텟 문자열은 순서가 지정된 옥텟\(8비트 바이트\)의 시퀀스입니다. 시퀀스는 처음\(일반적으로 가장 왼쪽\)부터 마지막\(가장 오른쪽\)까지 인덱싱됩니다. 정수와의 변환을 위해 첫 번째 옥텟은 다음 변환 프리미티브에서 가장 중요한 것으로 간주됩니다.

---
## **4.1 I2OSP**

I2OSP는 음이 아닌 정수를 지정된 길이의 옥텟 문자열로 변환합니다.

```text
   I2OSP (x, l)

   Input:
   x         nonnegative integer to be converted
   l         intended length of the resulting octet string

   Output:
   X         corresponding octet string of length l; or
             "integer too large"

   Steps:
```

1. x\>=256^l인 경우 "정수가 너무 큽니다"를 출력하고 중지합니다.

1. 고유한 l-자리 표현 기수 256으로 정수 x를 작성합니다.

```text
   x = x_{l-1}256^{l-1} + x_{l-2}256^{l-2} +... + x_1 256 + x_0
```

여기서 0 <= x\_i < 256입니다\(x < 256^{l-1}인 경우 하나 이상의 선행 숫자가 0이 됩니다\).

1. 옥텟 X\_i가 1 <= i <= l에 대해 x\_{l-i} 값을 갖도록 합니다. 옥텟 문자열을 출력합니다:

```text
   X = X_1 X_2 ... X_l.
```

---
## **4.2 OS2IP**

OS2IP는 옥텟 문자열을 음수가 아닌 정수로 변환합니다.

```text
   OS2IP (X)

   Input:
   X         octet string to be converted

   Output:
   x         corresponding nonnegative integer

   Steps:
```

1. X\_1 X\_2 ... X\_l을 처음부터 끝까지 X의 옥텟으로 하고, x{l-i}가 1<= i <= l에 대해 X\_i 값을 갖도록 합니다.

```text
   2. Let x = x{l-1} 256^{l-1} + x_{l-2} 256^{l-2} +...+ x_1 256 + x_0.

   3. Output x.
```

---
## **5. Cryptographic primitives**

암호화 프리미티브는 암호화 체계를 구축할 수 있는 기본적인 수학 연산입니다. 이는 하드웨어 또는 소프트웨어 모듈로 구현하기 위한 것이며 체계와 별개로 보안을 제공하기 위한 것이 아닙니다.

이 문서에는 네 가지 유형의 기본 요소가 쌍으로 구성되어 지정됩니다. 암호화 및 암호 해독; 서명 및 확인.

기본 요소의 사양에서는 입력이 특정 조건을 충족한다고 가정합니다. 특히 공개 키와 개인 키가 유효하다고 가정합니다.

---
## **5.1 Encryption and decryption primitives**

암호화 프리미티브는 공개 키의 제어하에 메시지 표현으로부터 암호문 표현을 생성하고, 복호화 프리미티브는 해당 개인 키의 제어하에 암호문 표현으로부터 메시지 표현을 복구합니다.

한 쌍의 암호화 및 암호 해독 기본 요소는 이 문서에 정의된 암호화 체계에 사용되며 RSAEP/RSADP에 지정되어 있습니다. RSAEP와 RSADP는 입력 키가 서로 다르지만 동일한 수학 연산을 사용합니다.

여기에 정의된 기본 요소는 IEEE P1363 초안과 동일하며 PKCS #1 v1.5와 호환됩니다.

각 프리미티브의 주요 수학 연산은 지수입니다.

---
### **5.1.1 RSAEP**

```text
   RSAEP((n, e), m)

   Input:
   (n, e)    RSA public key
   m         message representative, an integer between 0 and n-1

   Output:
   c         ciphertext representative, an integer between 0 and n-1;
             or "message representative out of range"
```

가정: 공개 키\(n, e\)가 유효합니다.

```text
   Steps:
```

1. 메시지 표현 m이 0과 n-1 사이에 없으면 범위를 벗어난 메시지 표현을 출력하고 중지합니다.

```text
   2. Let c = m^e mod n.

   3. Output c.
```

---
### **5.1.2 RSADP**

```text
   RSADP (K, c)

   Input:

   K         RSA private key, where K has one of the following forms
                 -a pair (n, d)
                 -a quintuple (p, q, dP, dQ, qInv)
   c         ciphertext representative, an integer between 0 and n-1

   Output:
   m         message representative, an integer between 0 and n-1; or
             "ciphertext representative out of range"
```

가정: 개인 키 K가 유효합니다.

```text
   Steps:
```

1. 암호문 대표 c가 0과 n-1 사이가 아닌 경우 "암호문 대표 범위를 벗어났습니다"를 출력하고 중지합니다.

1. K의 첫 번째 형태\(n, d\)가 사용되는 경우:

2.1 m = c^d mod n이라고 하자. 그렇지 않고 K의 두 번째 형식\(p, q, dP, dQ, qInv\)이 사용되는 경우:

```text
   2.2 Let m_1 = c^dP mod p.

   2.3 Let m_2 = c^dQ mod q.

   2.4 Let h = qInv ( m_1 - m_2 ) mod p.

   2.5 Let m = m_2 + hq.

   3. Output m.
```

---
## **5.2 Signature and verification primitives**

서명 프리미티브는 개인키의 제어를 받는 메시지 표현으로부터 서명 표현을 생성하고, 검증 프리미티브는 해당 공개키의 제어를 받는 서명 표현으로부터 메시지 표현을 복구합니다. 한 쌍의 서명 및 검증 기본 요소는 이 문서에 정의된 서명 체계에 사용되며 RSASP1/RSAVP1에 지정되어 있습니다.

여기에 정의된 기본 요소는 IEEE P1363 초안과 동일하며 PKCS #1 v1.5와 호환됩니다.

각 기본 요소의 주요 수학적 연산은 섹션 5.1의 암호화 및 암호 해독 기본 요소에서와 같이 지수화입니다. RSASP1 및 RSAVP1은 입력 및 출력 인수의 이름을 제외하고 RSADP 및 RSAEP와 동일합니다. 그것들은 서로 다른 목적으로 사용되기 때문에 구별됩니다.

---
### **5.2.1 RSASP1**

```text
   RSASP1 (K, m)

   Input:
   K             RSA private key, where K has one of the following
                 forms:
                    -a pair (n, d)
                    -a quintuple (p, q, dP, dQ, qInv)

   m             message representative, an integer between 0 and n-1

   Output:
   s             signature representative, an integer between  0 and
                 n-1, or "message representative out of range"
```

가정: 개인 키 K가 유효합니다.

```text
   Steps:
```

1. 메시지 대표 m이 0과 n-1 사이에 있지 않으면 "메시지 대표가 범위를 벗어났습니다"를 출력하고 중지합니다.

1. K의 첫 번째 형태\(n, d\)가 사용되는 경우:

2.1 s = m^d mod n이라고 하자. 그렇지 않고 K의 두 번째 형식\(p, q, dP, dQ, qInv\)이 사용되는 경우:

```text
   2.2 Let s_1 = m^dP mod p.

   2.3 Let s_2 = m^dQ mod q.

   2.4 Let h = qInv ( s_1 - s_2 ) mod p.

   2.5 Let s = s_2 + hq.

   3. Output S.
```

---
### **5.2.2 RSAVP1**

```text
   RSAVP1 ((n, e), s)

   Input:
   (n, e)  RSA public key
   s       signature representative, an integer between 0 and n-1

   Output:
   m       message representative, an integer between 0 and n-1;
           or "invalid"
```

가정: 공개 키\(n, e\)가 유효합니다.

```text
   Steps:
```

1. 서명 대표자 s가 0과 n-1 사이에 있지 않으면 "invalid"를 출력하고 중지합니다.

```text
   2. Let m = s^e mod n.

   3. Output m.
```

---
## **6. Overview of schemes**

체계는 특정 보안 목표를 달성하기 위해 암호화 기본 요소와 기타 기술을 결합합니다. 이 문서에는 암호화 체계와 부록이 포함된 서명 체계라는 두 가지 유형의 체계가 지정되어 있습니다.

이 문서에 지정된 체계는 해당 작업이 키를 사용하여 데이터를 처리하는 단계로만 구성되고 키를 얻거나 유효성을 검사하는 단계를 포함하지 않는다는 점에서 범위가 제한됩니다. 따라서 계획 운영 외에도 애플리케이션에는 일반적으로 당사자가 계획 운영을 ​​위해 공개 및 개인 키를 선택할 수 있는 키 관리 작업이 포함됩니다. 특정 추가 작업 및 기타 세부 정보는 이 문서의 범위를 벗어납니다.

암호화 기본 요소\(섹션 5\)의 경우와 마찬가지로 체계 작업 사양에서는 입력이 특정 조건, 특히 공개 키와 개인 키가 유효하다고 가정합니다. 따라서 키가 유효하지 않은 경우 구현 동작이 지정되지 않습니다. 이러한 지정되지 않은 동작의 영향은 애플리케이션에 따라 다릅니다. 키 유효성 검사를 처리하는 가능한 방법에는 애플리케이션에 의한 명시적인 키 유효성 검사가 포함됩니다. 공개 키 인프라 내 키 검증 유효하지 않은 키로 수행된 작업에 대한 책임은 키를 생성한 당사자에게 할당됩니다.

---
## **7. Encryption schemes**

암호화 체계는 암호화 작업과 암호 해독 작업으로 구성됩니다. 여기서 암호화 작업은 수신자의 공개 키를 사용하여 메시지에서 암호문을 생성하고, 암호 해독 작업은 수신자의 해당 개인 키를 사용하여 암호문에서 메시지를 복구합니다.

암호화 방식은 다양한 애플리케이션에 사용될 수 있습니다. 일반적인 애플리케이션은 키 설정 프로토콜로, 메시지에는 한 당사자에서 다른 당사자에게 비밀리에 전달될 키 자료가 포함되어 있습니다. 예를 들어, PKCS #7\[21\]은 발신자로부터 수신자에게 콘텐츠 암호화 키를 전달하기 위해 이러한 프로토콜을 사용합니다. 여기에 정의된 암호화 체계는 해당 컨텍스트에 적합한 키 암호화 알고리즘입니다.

이 문서에는 RSAES-OAEP 및 RSAES-PKCS1-v1\_5라는 두 가지 암호화 체계가 지정되어 있습니다. RSAES-OAEP는 새로운 애플리케이션에 권장됩니다. RSAES-PKCS1-v1\_5는 기존 애플리케이션과의 호환성을 위해서만 포함되며 새 애플리케이션에는 권장되지 않습니다.

여기에 제공된 암호화 체계는 암호화 및 암호 해독 기본 요소와 암호화를 위한 인코딩 방법을 결합하여 IEEE P1363에서 사용된 것과 유사한 일반 모델을 따릅니다. 암호화 작업은 메시지 인코딩 작업을 메시지에 적용하여 인코딩된 메시지를 생성한 다음 정수 메시지 표현으로 변환합니다. 암호문을 생성하기 위해 암호화 프리미티브가 메시지 표현에 적용됩니다. 이를 반대로 해독 작업은 암호문에 해독 기본 요소를 적용하여 메시지 표현을 복구한 다음 옥텟 문자열로 인코딩된 메시지로 변환합니다. 메시지를 복구하고 암호 해독의 정확성을 확인하기 위해 메시지 디코딩 작업이 인코딩된 메시지에 적용됩니다.

---
## **7.1 RSAES-OAEP**

RSAES-OAEP는 RSAEP 및 RSADP 프리미티브\(섹션 5.1.1 및 5.1.2\)를 EME-OAEP 인코딩 방법\(섹션 9.1.1\)과 결합합니다. EME-OAEP는 \[2\]에 있는 방법을 기반으로 합니다. 이는 암호화 및 암호 해독 기본 요소가 IFEP-RSA 및 IFDP-RSA이고 메시지 인코딩 방법이 EME-OAEP인 초안 P1363에 정의된 IFES 체계와 호환됩니다. RSAES-OAEP는 최대 k-2-2hLen 옥텟 길이의 메시지에 대해 작동할 수 있습니다. 여기서 hLen은 EME-OAEP에 대한 해시 함수 출력의 길이이고 k는 수신자의 RSA 모듈러스 옥텟 길이입니다. EME-OAEP의 해시 함수에 적절한 속성이 있고 키 크기가 충분히 크다고 가정하면 RSAEP-OAEP는 "일반 텍스트 인식 암호화"를 제공합니다. 즉, 암호문에서 메시지에 대한 전체 또는 부분 정보를 얻는 것이 계산상 불가능하다는 의미입니다. , 해당 메시지를 알지 못한 채 유효한 암호문을 생성하는 것은 계산상 불가능합니다. 따라서 선택 암호문 공격은 RSAES-OAEP와 같은 일반 텍스트 인식 암호화 체계에 대해서는 효과적이지 않습니다.

RSAES-OAEP의 암호화 및 암호 해독 작업은 모두 매개변수 문자열 P의 값을 입력으로 사용합니다. 이 버전의 PKCS #1에서 P는 명시적으로 지정된 옥텟 문자열입니다. 관련 ASN.1 구문은 섹션 11.2.1을 참조하세요. RSAES-OAEP의 완전한 보안 이점을 얻으려면 RSAES-PKCS1-v1\_5와 관련된 프로토콜에서 사용해서는 안 된다는 점을 간략히 언급합니다. 두 암호화 체계가 모두 존재하는 프로토콜에서는 \[4\]와 같은 적응형 선택 암호문 공격이 유용할 수 있습니다.

RSAES-OAEP의 암호화 및 암호 해독 작업은 모두 매개변수 문자열 P의 값을 입력으로 사용합니다. 이 버전의 PKCS #1에서 P는 명시적으로 지정된 옥텟 문자열입니다. 관련 ASN.1 구문은 섹션 11.2.1을 참조하세요.

---
### **7.1.1 Encryption operation**

```text
   RSAES-OAEP-ENCRYPT ((n, e), M, P)

   Input:
   (n, e)    recipient's RSA public key

   M         message to be encrypted, an octet string of length at
             most k-2-2hLen, where k is the length in octets of the
             modulus n and hLen is the length in octets of the hash
             function output for EME-OAEP

   P         encoding parameters, an octet string that may be empty

   Output:
   C         ciphertext, an octet string of length k; or "message too
             long"
```

가정: 공개 키\(n, e\)가 유효합니다.

```text
   Steps:
```

1. 메시지 M과 인코딩 매개변수 P에 EME-OAEP 인코딩 작업\(9.1.1.2절\)을 적용하여 길이 k-1 옥텟의 인코딩된 메시지 EM을 생성합니다.

```text
   EM = EME-OAEP-ENCODE (M, P, k-1)
```

인코딩 작업에서 "메시지가 너무 김"이 출력되면 "메시지가 너무 김"을 출력하고 중지합니다.

1. 인코딩된 메시지 EM을 m을 나타내는 정수 메시지로 변환: m = OS2IP\(EM\)

1. 공개 키\(n, e\)와 메시지 표현 m에 RSAEP 암호화 프리미티브\(5.1.1절\)를 적용하여 c를 표현하는 정수 암호문을 생성합니다.

```text
   c = RSAEP ((n, e), m)
```

1. c를 표현하는 암호문을 길이 k 옥텟의 암호문 C로 변환: C = I2OSP \(c, k\)

1. 암호문 C를 출력합니다.

---
### **7.1.2 Decryption operation**

```text
   RSAES-OAEP-DECRYPT (K, C, P)

   Input:
   K          recipient's RSA private key
   C          ciphertext to be decrypted, an octet string of length
              k, where k is the length in octets of the modulus n
   P          encoding parameters, an octet string that may be empty

   Output:
   M          message, an octet string of length at most k-2-2hLen,
              where hLen is the length in octets of the hash
              function output for EME-OAEP; or "decryption error"

   Steps:
```

1. 암호문 C의 길이가 k 옥텟이 아니면 "decryption error"를 출력하고 중지한다.

1. 암호문 C를 c를 나타내는 정수 암호문으로 변환합니다: c = OS2IP \(C\).

1. RSADP 복호화 프리미티브\(5.1.2절\)를 개인 키 K와 암호문 표현 c에 적용하여 m을 표현하는 정수 메시지를 생성합니다.

```text
   m = RSADP (K, c)
```

RSADP가 "암호문 범위를 벗어났습니다"를 출력하면 "암호 해독 오류"를 출력하고 중지합니다.

1. m을 나타내는 메시지를 길이 k-1 옥텟의 인코딩된 메시지 EM으로 변환합니다. EM = I2OSP \(m, k-1\)

I2OSP가 "integer too big"을 출력하면 "decryption error"를 출력하고 중지합니다.

1. EME-OAEP 디코딩 작업을 인코딩된 메시지 EM 및 인코딩 매개변수 P에 적용하여 메시지 M을 복구합니다.

```text
   M = EME-OAEP-DECODE (EM, P)
```

디코딩 작업에서 "디코딩 오류"가 출력되면 "암호 해독 오류"를 출력하고 중지합니다.

1. M 메시지를 출력합니다.

메모. 4단계와 5단계에서 출력되는 오류 메시지는 동일해야 합니다. 그렇지 않으면 공격자가 수신된 오류 메시지 유형에서 유용한 정보를 추출할 수 있습니다. 오류 메시지 정보는 \[4\]의 PKCS #1 v1.5 암호화된 메시지에 대해 선택 암호문 공격을 수행하는 데 사용됩니다.

---
## **7.2 RSAES-PKCS1-v1_5**

RSAES-PKCS1-v1\_5는 RSAEP 및 RSADP 기본 요소를 EME-PKCS1-v1\_5 인코딩 방법과 결합합니다. PKCS #1 v1.5의 암호화 방식과 동일합니다. RSAES-PKCS1-v1\_5는 최대 k-11 옥텟 길이의 메시지에서 작동할 수 있지만 Coppersmith 등의 저지수 RSA에 대한 특정 공격을 피하기 위해 주의를 기울여야 합니다. 긴 메시지가 암호화된 경우\(아래 참고 사항과 \[7\]의 세 번째 글머리 기호 참조\)

RSAES-PKCS1-v1\_5는 "일반 텍스트 인식" 암호화를 제공하지 않습니다. 특히, 해당 평문을 모르더라도 합리적인 성공 확률로 유효한 암호문을 생성하는 것이 가능합니다. 이 능력은 \[4\]에 표시된 대로 선택된 암호문 공격에서 악용될 수 있습니다. 따라서 RSAES-PKCS1-v1\_5를 사용하려면 \[4\]에서 발견된 공격을 막기 위해 쉽게 구현 가능한 특정 대책을 취해야 합니다. 인코딩할 데이터에 구조를 추가하고, PKCS #1 v1.5 적합성에 대한 엄격한 검사와 해독된 메시지의 기타 중복성, 그리고 PKCS #1 v1.5를 기반으로 하는 클라이언트-서버 프로토콜의 오류 메시지 통합은 모두 가능합니다. 효과적인 대응책이 되며 PKCS #1 v1.5 기반 프로토콜에 대한 변경이 포함되지 않습니다. 이러한 대책과 기타 대책은 \[5\]에서 논의됩니다.

노트. 다음 구절에서는 RSAES-PKCS1-v1\_5 사용과 관련된 몇 가지 보안 권장 사항을 설명합니다. 이 문서 버전 1.5의 권장 사항과 그 사이에 이루어진 암호화 분석의 발전에 따른 새로운 권장 사항이 포함되어 있습니다.

- EME-PKCS1-v1\_5의 의사 난수 옥텟은 각 암호화 프로세스마다 독립적으로 생성하는 것이 좋습니다. 특히 동일한 데이터가 둘 이상의 암호화 프로세스에 입력되는 경우 더욱 그렇습니다. Hastad의 결과\[13\]는 이 권장 사항에 대한 동기 중 하나입니다.

- EME-PKCS1-v1\_5의 패딩 문자열 PS는 길이가 최소 8옥텟입니다. 이는 공격자가 가능한 모든 암호화 블록을 시도하여 데이터를 복구하는 것을 방지하는 공개 키 작업에 대한 보안 조건입니다.

- 의사 난수 옥텟은 Coppersmith et al.에 의한 공격을 저지하는 데 도움이 될 수도 있습니다. \[7\] 암호화할 메시지의 크기를 작게 유지하는 경우. 이 공격은 유사한 메시지가 동일한 공개 키로 암호화된 경우 낮은 지수 RSA에서 작동합니다. 보다 구체적으로 공격의 한 가지 유형에서 RSAEP에 대한 두 입력이 많은 비트\(8/9\)에 동의하고 낮은 지수 RSA\(e = 3\)가 두 입력을 모두 암호화하는 데 사용되는 경우 다음이 가능할 수 있습니다. 공격으로 두 입력을 모두 복구합니다. 공격의 또 다른 특징은 RSAEP에 대한 입력의 큰 부분\(2/3\)이 이미 알려진 경우 단일 암호문을 성공적으로 해독하는 것입니다. 일반적인 애플리케이션의 경우 암호화할 메시지는 짧기 때문에\(예: 128비트 대칭 키\) 공격을 활성화할 만큼 두 메시지 간에 알려진 정보가 충분하지 않거나 공통되지 않습니다. 그러나 긴 메시지가 암호화되어 있거나 메시지의 일부가 알려진 경우에는 공격이 문제가 될 수 있습니다. 어쨌든 RSAEP-OAEP 방식은 공격을 극복합니다.

---
### **7.2.1 Encryption operation**

```text
   RSAES-PKCS1-V1_5-ENCRYPT ((n, e), M)

   Input:
   (n, e)  recipient's RSA public key
   M       message to be encrypted, an octet string of length at
           most k-11 octets, where k is the length in octets of the
           modulus n

   Output:
   C       ciphertext, an octet string of length k; or "message too
           long"

   Steps:
```

1. 메시지 M에 EME-PKCS1-v1\_5 인코딩 작업\(섹션 9.1.2.1\)을 적용하여 길이 k-1 옥텟의 인코딩된 메시지 EM을 생성합니다.

```text
   EM = EME-PKCS1-V1_5-ENCODE (M, k-1)
```

인코딩 작업에서 "메시지가 너무 김"이 출력되면 "메시지가 너무 김"을 출력하고 중지합니다.

1. 인코딩된 메시지 EM을 m을 나타내는 정수 메시지로 변환: m = OS2IP\(EM\)

1. 공개 키\(n, e\)와 메시지 표현 m에 RSAEP 암호화 프리미티브\(5.1.1절\)를 적용하여 c를 표현하는 정수 암호문을 생성합니다. c = RSAEP\(\(n, e\), m\)

1. c를 표현하는 암호문을 길이 k 옥텟의 암호문 C로 변환: C = I2OSP \(c, k\)

1. 암호문 C를 출력합니다.

---
### **7.2.2 Decryption operation**

```text
   RSAES-PKCS1-V1_5-DECRYPT (K, C)

   Input:
   K       recipient's RSA private key
   C       ciphertext to be decrypted, an octet string of length k,
           where k is the length in octets of the modulus n

   Output:
   M       message, an octet string of length at most k-11; or
           "decryption error"

   Steps:
```

1. 암호문 C의 길이가 k 옥텟이 아니면 "decryption error"를 출력하고 중지한다.

1. 암호문 C를 c를 나타내는 정수 암호문으로 변환합니다: c = OS2IP \(C\).

1. RSADP 복호화 프리미티브를 개인 키\(n, d\)와 c를 나타내는 암호문에 적용하여 m을 나타내는 정수 메시지를 생성합니다. m = RSADP\(\(n, d\), c\).

RSADP가 "암호문 범위를 벗어났습니다"를 출력하면 "암호 해독 오류"를 출력하고 중지합니다.

1. m을 나타내는 메시지를 길이 k-1 옥텟의 인코딩된 메시지 EM으로 변환합니다. EM = I2OSP \(m, k-1\)

I2OSP가 "integer too big"을 출력하면 "decryption error"를 출력하고 중지합니다.

1. 메시지 M을 복구하기 위해 인코딩된 메시지 EM에 EME-PKCS1-v1\_5 디코딩 작업을 적용합니다. M = EME-PKCS1-V1\_5-DECODE\(EM\).

디코딩 작업에서 "디코딩 오류"가 출력되면 "암호 해독 오류"를 출력하고 중지합니다.

1. M 메시지를 출력합니다.

메모. 4단계와 5단계에서 보장된 대로 EME-PKCS1-v1\_5에서는 한 가지 유형의 오류 메시지만 출력하는 것이 중요합니다. 그렇지 않으면 공격자가 수신된 오류 메시지 유형에서 추출된 정보를 사용할 수 있습니다. \[4\]에서 발견된 것과 같은 선택 암호문 공격을 실행합니다.

---
## **8. Signature schemes with appendix**

부록이 있는 서명 체계는 서명 생성 작업과 서명 확인 작업으로 구성됩니다. 여기서 서명 생성 작업은 서명자의 개인 키를 사용하여 메시지에서 서명을 생성하고 서명 확인 작업은 서명자의 해당 공개 키를 사용하여 메시지의 서명을 확인합니다. 열쇠. 이러한 유형의 체계로 구성된 서명을 확인하려면 메시지 자체가 필요합니다. 이러한 방식으로 부록이 있는 서명 체계는 이 문서에서 지원되지 않는 메시지 복구가 있는 서명 체계와 구별됩니다.

부록이 포함된 서명 체계는 다양한 응용 프로그램에 사용될 수 있습니다. 예를 들어, X.509\[6\]는 인증서 내용을 인증하기 위해 이러한 체계를 사용합니다. 여기에 정의된 부록이 있는 서명 체계는 해당 맥락에서 적합한 서명 알고리즘이 될 것입니다. 관련 서명 체계가 PKCS #7\[21\]에서 사용될 수 있지만, 기술적인 이유로 현재 버전의 PKCS #7은 해시 함수를 서명 체계에서 분리하는데, 이는 여기에서 수행되는 것과 다릅니다.

이 문서에는 부록이 포함된 하나의 서명 체계\(RSASSA-PKCS1-v1\_5\)가 지정되어 있습니다.

여기에 제공된 부록이 있는 서명 체계는 서명 및 검증 기본 요소를 서명에 대한 인코딩 방법과 결합하여 IEEE P1363에서 사용된 것과 유사한 일반 모델을 따릅니다. 서명 생성 작업은 메시지 인코딩 작업을 메시지에 적용하여 인코딩된 메시지를 생성한 다음 정수 메시지 표현으로 변환합니다. 그런 다음 서명 기본 요소가 메시지 표현에 적용되어 서명을 생성합니다. 서명 확인 작업은 서명 확인 기본 요소를 서명에 적용하여 메시지 표현을 복구한 다음 옥텟 문자열로 변환합니다. 메시지 인코딩 작업이 메시지에 다시 적용되고 결과가 복구된 옥텟 문자열과 비교됩니다. 일치하는 것이 있으면 서명이 유효한 것으로 간주됩니다. \(이 접근 방식에서는 RSASP1/RSAVP1 및 EMSA-PKCS1-v1\_5의 경우처럼 서명 및 확인 기본 요소가 메시지 복구 형식을 갖고 인코딩 방법이 결정적이라고 가정합니다. 서명 생성 및 확인 작업의 형식은 다릅니다. 다른 프리미티브 및 인코딩 방법은 P1363에 있습니다.\)

편집자 주. RSA 연구소는 \[3\]에 지정된 PSS 인코딩 방법을 기반으로 하는 체계를 포함할 가능성을 조사하고 있으며 이는 새로운 애플리케이션에 권장됩니다.

---
## **8.1 RSASSA-PKCS1-v1_5**

RSASSA-PKCS1-v1\_5는 RSASP1 및 RSAVP1 프리미티브를 EME-PKCS1-v1\_5 인코딩 방법과 결합합니다. 이는 서명 및 검증 기본 요소가 IFSP-RSA1 및 IFVP-RSA1이고 메시지 인코딩 방법이 EMSA-PKCS1-v1\_5\(P1363에 정의되지 않음\)인 초안 P1363에 정의된 IFSSA 체계와 호환됩니다. RSASSA-PKCS1-v1\_5가 작동할 수 있는 메시지 길이는 메시지 인코딩 방법의 기반이 되는 해시 함수에 따라 제한이 없거나 매우 큰 수로 제한됩니다.

EMSA-PKCS1-v1\_5의 해시 함수에 적절한 속성이 있고 키 크기가 충분히 크다고 가정하면 RSASSA-PKCS1-v1\_5는 보안 서명을 제공합니다. 즉, 개인 키를 모르고 서명을 생성하는 것은 계산적으로 불가능하고 계산적으로도 불가능합니다. 특정 서명이 있는 메시지를 찾거나 동일한 서명이 있는 메시지 두 개를 찾습니다. 또한 EMSA-PKCS1-v1\_5 인코딩 방식에는 해시 함수 식별자가 인코딩에 내장되어 있습니다. 이 기능으로 인해 공격자는 사용 중인 특정 해시 함수의 충돌을 반전시키거나 찾아야 합니다. 서명자가 선택한 것과 다른 해시 함수를 공격하는 것은 적에게 유용하지 않습니다.

---
### **8.1.1 Signature generation operation**

```text
   RSASSA-PKCS1-V1_5-SIGN (K, M)
   Input:
   K         signer's RSA private ke
   M         message to be signed, an octet string

   Output:
   S         signature, an octet string of length k, where k is the
             length in octets of the modulus n; "message too long" or
             "modulus too short"
   Steps:
```

1. 메시지 M에 EMSA-PKCS1-v1\_5 인코딩 작업\(9.2.1절\)을 적용하여 길이 k-1 옥텟의 인코딩된 메시지 EM을 생성합니다.

```text
   EM = EMSA-PKCS1-V1_5-ENCODE (M, k-1)
```

인코딩 작업에서 "메시지가 너무 김"이 출력되면 "메시지가 너무 김"을 출력하고 중지합니다. 인코딩 작업에서 "의도된 인코딩된 메시지 길이가 너무 짧음"이 출력되면 "모듈러스가 너무 짧음"이 출력됩니다.

1. 인코딩된 메시지 EM을 m을 나타내는 정수 메시지로 변환: m = OS2IP\(EM\)

1. RSASP1 서명 프리미티브\(Section 5.2.1\)를 개인 키 K 및 메시지 표현 m에 적용하여 s를 나타내는 정수 서명을 생성합니다. s = RSASP1\(K, m\)

1. 서명 대표 s를 길이 k 옥텟의 서명 S로 변환: S = I2OSP\(s, k\)

1. 서명 S를 출력합니다.

---
### **8.1.2 Signature verification operation**

```text
   RSASSA-PKCS1-V1_5-VERIFY ((n, e), M, S)

   Input:
   (n, e)    signer's RSA public key
   M         message whose signature is to be verified, an octet string
   S         signature to be verified, an octet string of length k,
             where k is the length in octets of the modulus n
```

출력: "유효한 서명", "잘못된 서명", "메시지가 너무 김" 또는 "모듈러스가 너무 짧음"

```text
   Steps:
```

1. 시그니처 S의 길이가 k 옥텟이 아닌 경우 "잘못된 서명"을 출력하고 중지합니다.

1. 서명 S를 정수 서명 대표 s로 변환합니다.

```text
   s = OS2IP (S)
```

1. RSAVP1 검증 프리미티브\(Section 5.2.2\)를 공개 키\(n, e\)와 서명 표현 s에 적용하여 m을 표현하는 정수 메시지를 생성합니다.

m = RSAVP1 \(\(n, e\), s\) RSAVP1이 "잘못된"을 출력하면 "잘못된 서명"을 출력하고 중지합니다.

1. m을 나타내는 메시지를 길이 k-1 옥텟의 인코딩된 메시지 EM으로 변환합니다. EM = I2OSP \(m, k-1\)

I2OSP가 "정수가 너무 큼"을 출력하면 "잘못된 서명"을 출력하고 중지합니다.

1. 메시지 M에 EMSA-PKCS1-v1\_5 인코딩 작업\(섹션 9.2.1\)을 적용하여 길이 k-1 옥텟의 두 번째 인코딩된 메시지 EM'을 생성합니다.

```text
   EM' = EMSA-PKCS1-V1_5-ENCODE (M, k-1)
```

인코딩 작업에서 "메시지가 너무 김"이 출력되면 "메시지가 너무 김"을 출력하고 중지합니다. 인코딩 작업에서 "의도된 인코딩된 메시지 길이가 너무 짧음"이 출력되면 "모듈러스가 너무 짧음"이 출력됩니다.

1. 인코딩된 메시지 EM과 두 번째 인코딩된 메시지 EM'을 비교한다. 동일하면 "유효한 서명"을 출력합니다. 그렇지 않으면 "잘못된 서명"을 출력합니다.

---
## **9. Encoding methods**

인코딩 방법은 옥텟 문자열 메시지와 정수 메시지 표현 사이를 매핑하는 작업으로 구성됩니다.

이 문서에서는 암호화를 위한 인코딩 방법과 부록이 있는 서명을 위한 인코딩 방법이라는 두 가지 유형의 인코딩 방법을 고려합니다.

---
## **9.1 Encoding methods for encryption**

암호화를 위한 인코딩 방법은 인코딩 동작과 디코딩 동작으로 구성된다. 인코딩 작업은 메시지 M을 지정된 길이의 메시지 대표 EM에 매핑합니다. 디코딩 작업은 EM을 나타내는 메시지를 다시 메시지에 매핑합니다. 인코딩 및 디코딩 작업은 반대입니다.

메시지 표현 EM은 일반적으로 디코딩 작업에 의해 검증될 수 있는 일부 구조를 갖습니다. 구조가 존재하지 않으면 디코딩 작업은 "디코딩 오류"를 출력합니다. 인코딩 작업은 임의성을 도입할 수도 있으므로 동일한 메시지에 대한 인코딩 작업을 다르게 적용하면 다른 대표자가 생성됩니다.

암호화를 위한 두 가지 인코딩 방법이 암호화 체계에 사용되며 여기에 지정됩니다: EME-OAEP 및 EME-PKCS1-v1\_5.

---
### **9.1.1 EME-OAEP**

이 인코딩 방법은 해시 함수와 마스크 생성 함수를 선택하여 매개변수화됩니다. 제안된 해시 및 마스크 생성 함수는 섹션 10에 나와 있습니다. 이 인코딩 방법은 \[2\]에 있는 방법을 기반으로 합니다.

---
#### **9.1.1.1 Encoding operation**

```text
   EME-OAEP-ENCODE (M, P, emLen)

   Options:
   Hash      hash function (hLen denotes the length in octet of the
             hash function output)
   MGF       mask generation function

   Input:
   M         message to be encoded, an octet string of length at most
             emLen-1-2hLen
   P         encoding parameters, an octet string
   emLen     intended length in octets of the encoded message, at least
             2hLen+1

   Output:
   EM        encoded message, an octet string of length emLen;
             "message too long" or "parameter string too long"

   Steps:
```

1. P의 길이가 해시 함수의 입력 제한\(SHA-1의 경우 2^61-1 옥텟\)보다 큰 경우 "매개변수 문자열이 너무 깁니다"를 출력하고 중지합니다.

1. 만약 ||M|| \> emLen-2hLen-1 그런 다음 "메시지가 너무 깁니다"를 출력하고 중지합니다.

1. emLen-||M||-2hLen-1 0 옥텟으로 구성된 옥텟 문자열 PS를 생성합니다. PS의 길이는 0일 수 있다.

1. pHash = Hash\(P\), 길이가 hLen인 옥텟 문자열이라고 가정합니다.

1. pHash, PS, 메시지 M, 기타 패딩을 연결하여 다음과 같이 데이터 블록 DB를 형성합니다. DB = pHash || PS || 01 || 중

1. 길이가 hLen인 임의의 옥텟 문자열 시드를 생성합니다.

```text
   7. Let dbMask = MGF(seed, emLen-hLen).

   8. Let maskedDB = DB \xor dbMask.

   9. Let seedMask = MGF(maskedDB, hLen).

   10. Let maskedSeed = seed \xor seedMask.

   11. Let EM = maskedSeed || maskedDB.

   12. Output EM.
```

---
#### **9.1.1.2 Decoding operation EME-OAEP-DECODE (EM, P)**

```text
   Options:
   Hash      hash function (hLen denotes the length in octet of the hash
             function output)

   MGF       mask generation function

   Input:

   EM        encoded message, an octet string of length at least 2hLen+1
   P         encoding parameters, an octet string

   Output:
   M         recovered message, an octet string of length at most
             ||EM||-1-2hLen; or "decoding error"

   Steps:
```

1. P의 길이가 해시 함수의 입력 제한\(SHA-1의 경우 2^61-1 옥텟\)보다 큰 경우 "매개변수 문자열이 너무 깁니다"를 출력하고 중지합니다.

1. 만약 ||EM|| < 2hLen+1이면 "디코딩 오류"를 출력하고 중지합니다.

1. MaskedSeed를 EM의 첫 번째 hLen 옥텟으로 두고 MaskedDB를 나머지 ||EM||로 둡니다. - hLen 옥텟.

```text
   4. Let seedMask = MGF(maskedDB, hLen).

   5. Let seed = maskedSeed \xor seedMask.

   6. Let dbMask = MGF(seed, ||EM|| - hLen).

   7. Let DB = maskedDB \xor dbMask.
```

1. pHash = Hash\(P\), 길이가 hLen인 옥텟 문자열이라고 가정합니다.

1. DB를 DB의 첫 번째 hLen 옥텟으로 구성된 옥텟 문자열 pHash', pHash' 다음의 연속적인 0 옥텟으로 구성된 \(아마도 비어 있는\) 옥텟 문자열 PS, 메시지 M으로 다음과 같이 분리합니다.

```text
   DB = pHash' || PS || 01 || M
```

M과 PS를 분리하는 01옥텟이 없으면 "decoding error"를 출력하고 정지한다.

1. pHash'가 pHash와 같지 않으면 "디코딩 오류"를 출력하고 중지합니다.

```text
   11. Output M.
```

---
### **9.1.2 EME-PKCS1-v1_5**

이 인코딩 방법은 PKCS #1 v1.5, 섹션 8: 암호화 프로세스와 동일합니다.

---
#### **9.1.2.1 Encoding operation**

```text
   EME-PKCS1-V1_5-ENCODE (M, emLen)

   Input:
   M         message to be encoded, an octet string of length at most
             emLen-10
   emLen     intended length in octets of the encoded message

   Output:
   EM        encoded message, an octet string of length emLen; or
             "message too long"

   Steps:
```

1. 메시지 M의 길이가 emLen - 10옥텟보다 길면 "message too long"을 출력하고 중지합니다.

1. 의사 무작위로 생성된 0이 아닌 옥텟으로 구성된 emLen-||M||-2 길이의 옥텟 문자열 PS를 생성합니다. PS의 길이는 최소 8옥텟입니다.

1. PS, 메시지 M 및 기타 패딩을 연결하여 인코딩된 메시지 EM을 다음과 같이 구성합니다.

```text
   EM = 02 || PS || 00 || M

   4. Output EM.
```

---
#### **9.1.2.2 Decoding operation**

```text
   EME-PKCS1-V1_5-DECODE (EM)

   Input:
   EM      encoded message, an octet string of length at least 10

   Output:
   M       recovered message, an octet string of length at most
           ||EM||-10; or "decoding error"

   Steps:
```

1. 인코딩된 메시지 EM의 길이가 10보다 작으면 "decoding error"를 출력하고 중지합니다.

1. 인코딩된 메시지 EM을 0이 아닌 옥텟과 메시지 M으로 구성된 옥텟 문자열 PS로 분리합니다. EM = 02 || PS || 00 || 중.

EM의 첫 번째 옥텟이 02가 아니거나, PS를 M과 분리할 00 옥텟이 없으면 "decoding error"를 출력하고 정지한다.

1. PS의 길이가 8옥텟 미만이면 "decoding error"를 출력하고 중지합니다.

```text
   4. Output M.
```

---
## **9.2 Encoding methods for signatures with appendix**

본 문서의 목적에 따라 부록이 포함된 서명의 인코딩 방법은 인코딩 작업으로 구성됩니다. 인코딩 작업은 메시지 M을 지정된 길이의 메시지 대표 EM에 매핑합니다. \(이 문서의 향후 버전에서는 디코딩 작업도 포함하는 인코딩 방법이 추가될 수 있습니다.\)

부록이 있는 서명에 대한 한 가지 인코딩 방법은 암호화 체계에 사용되며 여기에 지정됩니다: EMSA-PKCS1-v1\_5.

---
### **9.2.1 EMSA-PKCS1-v1_5**

이 인코딩 방법에는 인코딩 작업만 있습니다.

```text
   EMSA-PKCS1-v1_5-ENCODE (M, emLen)

   Option:
   Hash      hash function (hLen denotes the length in octet of the hash
             function output)

   Input:
   M         message to be encoded
   emLen     intended length in octets of the encoded message, at least
             ||T|| + 10, where T is the DER encoding of a certain value
             computed during the encoding operation

   Output:
   EM        encoded message, an octet string of length emLen; or "message
             too long" or "intended encoded message length too short"

   Steps:
```

1. 메시지 M에 해시 함수를 적용하여 해시 값 H를 생성합니다.

```text
   H = Hash(M).
```

해시 함수가 "메시지가 너무 김"을 출력하면 "메시지가 너무 김"을 출력합니다.

1. 해시 함수에 대한 알고리즘 ID와 해시 값을 DER\(Distinguished Encoding Rules\)을 사용하여 DigestInfo 유형\(섹션 11 참조\)의 ASN.1 값으로 인코딩합니다. 여기서 DigestInfo 유형은 다음 구문을 갖습니다.

```text
   DigestInfo::=SEQUENCE{
     digestAlgorithm  AlgorithmIdentifier,
     digest OCTET STRING }
```

첫 번째 필드는 해시 함수를 식별하고 두 번째 필드는 해시 값을 포함합니다. T를 DER 인코딩으로 둡니다.

1. emLen이 ||T||보다 작은 경우 + 10은 "의도된 인코딩된 메시지 길이가 너무 짧습니다"를 출력합니다.

1. 값 FF\(16진수\)를 갖는 emLen-||T||-2 옥텟으로 구성된 옥텟 문자열 PS를 생성합니다. PS의 길이는 최소 8옥텟입니다.

1. PS, DER 인코딩 T 및 기타 패딩을 연결하여 인코딩된 메시지 EM을 다음과 같이 구성합니다. EM = 01 || PS || 00 || 티

```text
   6. Output EM.
```

---
## **10. Auxiliary Functions**

이 섹션에서는 인코딩 방법\(9장\)에서 언급된 해시 함수와 마스크 생성 함수를 지정합니다.

---
## **10.1 Hash Functions**

해시 함수는 섹션 7, 8, 9에 포함된 작업에 사용됩니다. 해시 함수는 결정론적입니다. 즉, 출력이 입력에 의해 완전히 결정된다는 의미입니다. 해시 함수는 가변 길이의 옥텟 문자열을 사용하고 고정 길이 옥텟 문자열을 생성합니다. 섹션 7, 8, 9에 포함된 작업에 사용되는 해시 함수는 충돌 방지 기능을 갖추어야 합니다. 이는 동일한 출력을 생성하는 해시 함수에 대한 두 개의 서로 다른 입력을 찾는 것이 불가능하다는 것을 의미합니다. 충돌 방지 해시 함수는 단방향이라는 바람직한 특성도 가지고 있습니다. 이는 출력이 주어지면 해시가 지정된 출력인 입력을 찾는 것이 불가능하다는 것을 의미합니다. RSASSA-PKCS1-v1\_5의 경우 충돌 방지 특성이 특히 바람직합니다. 이는 서명을 위조하는 것을 불가능하게 만들기 때문입니다. 요구 사항 외에도 해시 함수는 의사 난수 출력이 있는 마스크 생성 함수\(10.2절\)를 생성해야 합니다.

이 문서의 인코딩 방법에는 MD2 \[15\], MD5 \[17\] 및 SHA-1 \[16\]의 세 가지 해시 함수가 권장됩니다. EME-OAEP 인코딩 방법의 경우 SHA-1만 권장됩니다. EMSA-PKCS1-v1\_5 인코딩 방법의 경우 새로운 애플리케이션에는 SHA-1이 권장됩니다. MD2 및 MD5는 PKCS #1 v1.5를 기반으로 하는 기존 응용 프로그램과의 호환성을 위해서만 권장됩니다.

해시 함수 자체는 여기에 정의되어 있지 않습니다. 독자들은 적절한 참고 문헌\(\[15\], \[17\] 및 \[16\]\)을 참조하십시오.

메모. 이 문서의 버전 1.5에서는 서명 체계에 MD4를 사용할 수도 있습니다. MD4의 암호 분석은 그 사이에 크게 발전했습니다. 예를 들어, Dobbertin\[10\]은 MD4에 대한 충돌을 찾는 방법과 MD4의 처음 두 라운드가 단방향이 아니라는 것을 보여주었습니다\[11\]. 이러한 결과와 기타 결과\(예: \[9\]\)로 인해 MD4는 더 이상 권장되지 않습니다. MD2 및 MD5의 암호 분석도 발전했지만 기존 응용 프로그램에서 제거할 만큼 충분하지는 않습니다. Rogier와 Chauvaud \[19\]는 수정된 MD2 버전에서 충돌을 찾는 방법을 시연했습니다. 부분적인 결과가 발견되었지만\(예: \[8\]\) 전체 MD5 알고리즘에 대한 충돌을 찾는 방법을 아무도 보여주지 않았습니다. 새로운 애플리케이션의 경우 이러한 문제를 해결하기 위해 SHA-1이 선호됩니다.

---
## **10.2 Mask Generation Functions**

마스크 생성 기능은 가변 길이의 옥텟 문자열과 원하는 출력 길이를 입력으로 받아 원하는 길이의 옥텟 문자열을 출력합니다. 입력 및 출력 옥텟 문자열의 길이에 제한이 있을 수 있지만 일반적으로 이러한 범위는 매우 큽니다. 마스크 생성 기능은 결정적입니다. 옥텟 문자열 출력은 입력 옥텟 문자열에 의해 완전히 결정됩니다. 마스크 생성 함수의 출력은 의사 난수여야 합니다. 즉, 함수의 시드를 알 수 없는 경우 출력을 실제 무작위 문자열과 구별하는 것이 불가능해야 합니다. RSAES-OAEP의 일반 텍스트 인식은 마스크 생성 기능 출력의 무작위 특성에 의존하며, 이는 다시 기본 해시의 무작위 특성에 의존합니다.

이 문서의 인코딩 방법에는 하나의 마스크 생성 함수가 권장되며 여기에 정의되어 있습니다: 해시 함수를 기반으로 하는 MGF1. 이 문서의 향후 버전에서는 다른 마스크 생성 기능을 정의할 수 있습니다.

---
### **10.2.1 MGF1**

MGF1은 해시 함수 기반의 마스크 생성 함수입니다.

```text
   MGF1 (Z, l)

   Options:
   Hash    hash function (hLen denotes the length in octets of the hash
           function output)

   Input:
   Z       seed from which mask is generated, an octet string
   l       intended length in octets of the mask, at most 2^32(hLen)

   Output:
   mask    mask, an octet string of length l; or "mask too long"

   Steps:
```

1. l \> 2^32\(hLen\)이면 "mask too long"을 출력하고 중지합니다.

2. T를 빈 옥텟 문자열로 둡니다.

3. 0부터 \lceil{l / hLen}\rceil-1까지의 카운터에 대해 다음을 수행합니다.

a. 기본 I2OSP를 사용하여 카운터를 길이 4의 옥텟 문자열 C로 변환합니다. C = I2OSP\(카운터, 4\)

b.시드 Z와 C의 해시를 옥텟 문자열 T에 연결합니다. T = T || 해시\(Z || C\)

4. T의 선행 l 옥텟을 옥텟 문자열 마스크로 출력합니다.

---
## **11. ASN.1 syntax**
---
## **11.1 Key representation**

이 섹션에서는 RSA 공개 및 개인 키에 대한 ASN.1 개체 식별자를 정의하고 RSAPublicKey 및 RSAPrivateKey 유형을 정의합니다. 이러한 정의의 의도된 적용에는 X.509 인증서, PKCS #8 \[22\] 및 PKCS #12 \[23\]가 포함됩니다.

객체 식별자 rsaEncryption은 섹션 11.1.1 및 11.1.2에 정의된 대로 RSA 공개 키와 개인 키를 식별합니다. AlgorithmIdentifier에서 이 OID와 연관된 매개변수 필드는 NULL 유형을 가져야 합니다.

```text
   rsaEncryption OBJECT IDENTIFIER ::= {pkcs-1 1}
```

이 섹션의 모든 정의는 PKCS #1 v1.5의 정의와 동일합니다.

---
### **11.1.1 Public-key syntax**

RSA 공개 키는 ASN.1 유형 RSAPublicKey로 표시되어야 합니다.

```text
   RSAPublicKey::=SEQUENCE{
     modulus INTEGER, -- n
     publicExponent INTEGER -- e }
```

\(이 유형은 X.509에 지정되어 있으며 호환성을 위해 여기에 유지됩니다.\)

RSAPublicKey 유형의 필드는 다음과 같은 의미를 갖습니다. -modulus는 모듈러스 n입니다. -publicExComponent는 공개 지수 e입니다.

---
### **11.1.2 Private-key syntax**

RSA 개인 키는 ASN.1 유형 RSAPrivateKey로 표시되어야 합니다.

RSAPrivateKey ::= SEQUENCE { 버전 버전, 모듈러스 INTEGER, -- n publicExpont INTEGER, -- e privateExpont INTEGER, -- d prime1 INTEGER, -- p prime2 INTEGER, -- q expont1 INTEGER, -- d mod \(p-1 \) 지수2 INTEGER, -- d mod \(q-1\) 계수 INTEGER -- \(q의 역수\) mod p }

```text
   Version ::= INTEGER
```

RSAPrivateKey 유형의 필드는 다음과 같은 의미를 갖습니다.

-version은 이 문서의 향후 개정판과의 호환성을 위한 버전 번호입니다. 이 버전의 문서에서는 0이 됩니다. -모듈러스는 모듈러스 n입니다. -publicExComponent는 공개 지수 e입니다. -privateExComponent는 개인 지수입니다. d. -prime1은 n의 소인수 p입니다. -prime2는 n의 소인수 q입니다. -지수1은 d mod\(p-1\)입니다. -지수2는 d mod\(q-1\)입니다. -계수는 중국 나머지 정리 계수 q-1 mod p입니다.

---
## **11.2 Scheme identification**

이 섹션에서는 암호화 및 서명 체계에 대한 개체 식별자를 정의합니다. PKCS #1 v1.5와 호환되는 구성표는 PKCS #1 v1.5와 동일한 정의를 갖습니다. 이러한 정의의 의도된 적용에는 X.509 인증서와 PKCS #7이 포함됩니다.

---
### **11.2.1 Syntax for RSAES-OAEP**

객체 식별자 id-RSAES-OAEP는 RSAES-OAEP 암호화 체계를 식별합니다.

```text
   id-RSAES-OAEP OBJECT IDENTIFIER ::= {pkcs-1 7}
```

AlgorithmIdentifier에서 이 OID와 연관된 매개변수 필드는 RSAEP-OAEP-params 유형을 가져야 합니다.

```text
   RSAES-OAEP-params ::=  SEQUENCE {
     hashFunc [0] AlgorithmIdentifier {{oaepDigestAlgorithms}}
       DEFAULT sha1Identifier,
     maskGenFunc [1] AlgorithmIdentifier {{pkcs1MGFAlgorithms}}
       DEFAULT mgf1SHA1Identifier,
     pSourceFunc [2] AlgorithmIdentifier
       {{pkcs1pSourceAlgorithms}}
       DEFAULT pSpecifiedEmptyIdentifier }
```

RSAES-OAEP-params 유형의 필드는 다음과 같은 의미를 갖습니다.

-hashFunc는 해시 함수를 식별합니다. 이는 oaepDigestAlgorithms 세트에 OID가 있는 알고리즘 ID여야 하며, 이 버전의 경우 SHA-1 해시 함수를 식별하는 id-sha1로 구성됩니다. id-sha1의 매개변수 필드는 NULL 유형을 가져야 합니다.

oaepDigestAlgorithms ALGORITHM-IDENTIFIER ::= { {id-sha1에 의해 식별된 NULL} }

```text
   id-sha1 OBJECT IDENTIFIER ::=
     {iso(1) identified-organization(3) oiw(14) secsig(3)
       algorithms(2) 26}
```

기본 해시 함수는 SHA-1입니다: sha1Identifier ::= AlgorithmIdentifier {id-sha1, NULL}

-maskGenFunc는 마스크 생성 기능을 식별합니다. 이는 pkcs1MGFAlgorithms 세트에 OID가 있는 알고리즘 ID여야 하며, 이 버전의 경우 MGF1 마스크 생성 기능을 식별하는 id-mgf1로 구성됩니다\(섹션 10.2.1 참조\). 매개변수 필드

id-mgf1은 MGF1의 기반이 되는 해시 함수를 식별하는 AlgorithmIdentifier 유형을 가지며, 해시 함수에 대한 OID는 oaepDigestAlgorithms 세트에 있어야 합니다.

pkcs1MGFAlgorithms ALGORITHM-IDENTIFIER ::= { {AlgorithmIdentifier {{oaepDigestAlgorithms}} id-mgf1에 의해 식별됨} }

```text
   id-mgf1 OBJECT IDENTIFIER ::= {pkcs-1 8}
```

기본 마스크 생성 기능은 SHA-1이 포함된 MGF1입니다.

```text
   mgf1SHA1Identifier ::= AlgorithmIdentifier {
     id-mgf1, sha1Identifier }
```

-pSourceFunc는 인코딩 매개변수 P의 소스\(및 가능한 값\)를 식별합니다. 이는 pkcs1pSourceAlgorithms 세트의 OID가 있는 알고리즘 ID여야 하며, 이 버전의 경우 인코딩 매개변수가 명시적으로 지정됨을 나타내는 id-pSpecified로 구성됩니다. . id-pSpecified의 매개변수 필드는 인코딩 매개변수를 포함하는 OCTET STRING 유형을 가져야 합니다.

pkcs1pSourceAlgorithms 알고리즘-식별자 ::= { {id-pSpecified로 식별된 OCTET 문자열} }

```text
   id-pSpecified OBJECT IDENTIFIER ::= {pkcs-1 9}
```

기본 인코딩 매개변수는 빈 문자열입니다\(따라서 EME-OAEP의 pHash에는 빈 문자열의 해시가 포함됩니다\).

```text
   pSpecifiedEmptyIdentifier ::= AlgorithmIdentifier {
     id-pSpecified, OCTET STRING SIZE (0) }
```

RSAES-OAEP-params에 있는 필드의 모든 기본값이 사용되는 경우 알고리즘 식별자는 다음 값을 갖습니다.

```text
   RSAES-OAEP-Default-Identifier ::= AlgorithmIdentifier {
     id-RSAES-OAEP,
     {sha1Identifier,
      mgf1SHA1Identifier,
      pSpecifiedEmptyIdentifier } }
```

---
### **11.2.2 Syntax for RSAES-PKCS1-v1_5**

객체 식별자 rsaEncryption\(섹션 11.1\)은 RSAES-PKCS1-v1\_5 암호화 체계를 식별합니다. AlgorithmIdentifier에서 이 OID와 연관된 매개변수 필드는 NULL 유형을 가져야 합니다. 이는 PKCS #1 v1.5와 동일합니다.

```text
   RsaEncryption   OBJECT IDENTIFIER ::= {PKCS-1 1}
```

---
### **11.2.3 Syntax for RSASSA-PKCS1-v1_5**

RSASSA-PKCS1-v1\_5의 객체 식별자는 다음 중 하나입니다. OID 선택은 해시 알고리즘 선택\(MD2, MD5 또는 SHA-1\)에 따라 달라집니다. MD2 또는 MD5를 사용하는 경우 OID는 PKCS #1 v1.5와 동일합니다. 각 OID에 대해 AlgorithmIdentifier의 이 OID와 연관된 매개변수 필드는 NULL 유형을 가져야 합니다.

사용할 해시 함수가 MD2인 경우 OID는 다음과 같아야 합니다.

```text
   md2WithRSAEncryption ::= {PKCS-1 2}
```

사용할 해시 함수가 MD5인 경우 OID는 다음과 같아야 합니다.

```text
   md5WithRSAEncryption ::= {PKCS-1 4}
```

사용할 해시 함수가 SHA-1인 경우 OID는 다음과 같아야 합니다.

```text
   sha1WithRSAEncryption ::= {pkcs-1 5}
```

섹션 9.2.1에 언급된 DigestInfo 유형에서 다이제스트 알고리즘에 대한 OIDS는 다음과 같습니다.

```text
   id-SHA1 OBJECT IDENTIFIER ::=
           {iso(1) identified-organization(3) oiw(14) secsig(3)
            algorithms(2) 26 }

   md2 OBJECT IDENTIFIER ::=
           {iso(1) member-body(2) US(840) rsadsi(113549)
            digestAlgorithm(2) 2}

   md5 OBJECT IDENTIFIER ::=
           {iso(1) member-body(2) US(840) rsadsi(113549)
            digestAlgorithm(2) 5}
```

다이제스트 알고리즘의 매개변수 필드에는 이러한 OID에 대한 ASN.1 유형 NULL이 있습니다.

---
## **12. Patent statement**

RFC 1310에 정의된 인터넷 표준 프로세스에서는 사양을 제안, 초안 또는 인터넷 표준으로 승인하기 전에 합리적인 조건에 따라 신청자에게 라이센스가 제공된다는 특허 보유자의 서면 진술이 필요합니다.

Internet Society, Internet Architecture Board, Internet Engineering Steering Group 및 Corporation for National Research Initiatives는 다음 특허 및 특허 출원의 유효성이나 범위, 보증 조건의 적절성에 대해 어떠한 입장도 취하지 않습니다. 위에 언급된 Internet Society 및 기타 그룹은 이 표준의 실행에 적용될 수 있는 기타 지적 재산권에 대해 어떠한 결정도 내리지 않았습니다. 이러한 문제에 대한 추가 고려는 사용자의 책임입니다.

---
## **12.1 Patent statement for the RSA algorithm**

MIT\(Massachusetts Institute of Technology\)는 RSA Data Security, Inc.에 미국에서 발행된 다음 특허에 대한 독점 하위 라이센스 권한을 부여했습니다.

암호화 통신 시스템 및 방법\("RSA"\), No. 4,405,829

RSA Data Security, Inc.는 이 특허와 관련하여 다음과 같은 설명을 제공했습니다.

합리적이고 차별 없는 조건으로 특허 라이센스를 제공하는 것이 RSA의 비즈니스 관행입니다. 따라서 RSA는 요청 시 RSA의 지적 재산권을 존중하는 사람들에게 합리적이고 비차별적인 조건으로 해당 특허에 대한 비독점 라이센스를 부여하고 라이센스가 부여된 특허에 대해 RSA의 당시 로열티 요율을 적용할 의향이 있습니다. RSA 특허에 대한 로열티 비율은 현재 특허가 적용되는 각 제품에 대한 라이센스 사용자 판매 가격의 2%로 설정되어 있습니다. 라이센스 정보에 대한 요청은 다음 주소로 전달될 수 있습니다.

```text
            Director of Licensing
            RSA Data Security, Inc.
            2955 Campus Drive
            Suite 400
            San Mateo, CA 94403
```

RSA 특허에 따른 라이센스에는 노하우나 기타 기술 정보에 대한 권리 또는 기타 지적 재산권에 따른 라이센스가 포함되지 않습니다. 그러한 라이센스는 침해 또는 유도를 구성하는 활동까지 확장되지 않습니다. 라이센스 취득자는 타인의 특허에 따라 라이센스가 필요한지 여부를 스스로 결정해야 합니다.

---
## **13. Revision history**

```text
   Versions 1.0-1.3
```

버전 1.0-1.3은 1991년 2월과 3월에 RSA Data Security, Inc.의 공개 키 암호화 표준 회의 참가자에게 배포되었습니다.

```text
   Version 1.4
```

버전 1.4는 1991년 6월 3일 PKCS의 최초 공개 릴리스의 일부였습니다. 버전 1.4는 NIST/OSI 구현자 워크숍 문서 SEC-SIG-91-18로 게시되었습니다.

```text
   Version 1.5
```

버전 1.5에는 참조 업데이트 및 개정 내역 추가를 포함하여 여러 가지 편집 변경 사항이 포함되어 있습니다. 다음과 같은 실질적인 변경이 이루어졌습니다. - 섹션 10: "RSA가 포함된 MD4" 서명 및 확인 프로세스가 추가되었습니다.

-섹션 11: md4WithRSAEncryption 개체 식별자가 추가되었습니다.

```text
   Version 2.0 [DRAFT]
```

버전 2.0은 문서 구조 측면에서 주요 편집 변경 사항을 통합하고 RSAEP-OAEP 암호화 체계를 도입합니다. 이 버전은 버전 1.5의 암호화 및 서명 프로세스를 계속 지원하지만, 그 사이에 암호화 분석의 발전으로 인해 해시 알고리즘 MD4가 더 이상 허용되지 않습니다.

---
## **14. References**

\[1\] ANSI, ANSI X9.44: 가역 공개 키를 사용한 키 관리 - 금융 서비스 산업을 위한 암호화. 진행중인 작업.

\[2\] M. Bellare 및 P. Rogaway. 최적의 비대칭 암호화 - 방법 - RSA로 암호화합니다. In Advances in Cryptology-Eurocrypt '94, pp. 92-111, Springer-Verlag, 1994.

\[3\] M. Bellare 및 P. Rogaway. 디지털의 정확한 보안 - 서명 - RSA 및 Rabin으로 서명하는 방법. Cryptology-Eurocrypt '96의 발전, pp. 399-416, Springer-Verlag, 1996.

\[4\] D. Bleichenbacher. 프로토콜에 대한 선택된 암호문 공격 - RSA 암호화 표준 PKCS #1을 기반으로 합니다. Advances in Cryptology-Crypto '98에 출연합니다.

\[5\] D. Bleichenbacher, B. Kaliski 및 J. Staddon. 최근 결과 - PKCS #1: RSA 암호화 표준. RSA 연구소 공지, 7호, 1998년 6월 24일.

\[6\] CCITT. 권장사항 X.509: 디렉토리 인증 - 프레임워크. 1988.

\[7\] D. Coppersmith, M. Franklin, J. Patarin 및 M. Reiter. 낮은 - 관련 메시지가 포함된 지수 RSA. 암호학의 진보 - Eurocrypt '96, pp. 1-9, Springer-Verlag, 1996

\[8\] B. Den Boer와 Bosselaers. 압축을 위한 충돌 - MD5의 기능. Cryptology-Eurocrypt '93의 발전, pp 293-304, Springer-Verlag, 1994.

\[9\] B. 덴 보어, A. Bosselaers. MD4의 마지막 두 라운드에 대한 공격. 암호화의 발전 - 암호화 '91, pp.194-203, Springer-Verlag, 1992.

\[10\] H. 도베르틴. MD4의 암호분석. 빠른 소프트웨어 암호화. - 컴퓨터 과학 강의 노트, Springer-Verlag 1996, pp. 55-72.

\[11\] H. 도베르틴. MD5 압축의 암호 분석. 1996년 5월 14일 Eurocrypt \`96의 엉덩이 세션에서 발표됨

\[12\] H. Dobbertin. MD4의 처음 두 라운드는 단방향이 아닙니다. 빠른 - 소프트웨어 암호화. 컴퓨터 과학 강의 노트, Springer-Verlag 1998, pp. 284-292.

\[13\] J. Hastad. 낮은 차수의 동시 모듈 방정식 풀기. - SIAM 컴퓨팅 저널, 17, 1988, pp. 336-341.

\[14\] IEEE. IEEE P1363: 공개 키에 대한 표준 사양 - 암호화. 초안 버전 4.

```text
   [15] Kaliski, B., "The MD2 Message-Digest Algorithm", RFC 1319, April
        1992.
```

\[16\] 국립표준기술연구소\(NIST\). FIPS - 간행물 180-1: 보안 해시 표준. 1994년 4월.

```text
   [17] Rivest, R., "The MD5 Message-Digest Algorithm", RFC 1321, April
        1992.
```

\[18\] R. Rivest, A. Shamir 및 L. Adleman. 획득 방법 - 디지털 서명 및 공개 키 암호화 시스템. ACM 커뮤니케이션, 21\(2\), pp. 120-126, 1978년 2월.

\[19\] N. Rogier 및 P. Chauvaud. MD2의 압축 기능은 Collision Free가 아닙니다. Selected Areas of Cryptography \`95에서 발표. 캐나다 오타와 칼튼 대학교. 1995년 5월 18\~19일.

```text
   [20] RSA Laboratories. PKCS #1: RSA Encryption Standard. Version 1.5,
        November 1993.

   [21] RSA Laboratories. PKCS #7: Cryptographic Message Syntax
        Standard. Version 1.5, November 1993.

   [22] RSA  Laboratories. PKCS #8: Private-Key Information Syntax
        Standard. Version 1.2, November 1993.
```

\[23\] RSA 연구소. PKCS #12: 개인 정보 교환 구문 - 표준. 버전 1.0, 작업 진행 중, 1997년 4월.

---
# **Security Considerations**

보안 문제는 이 메모 전체에서 논의됩니다.

---
# **Acknowledgements**

이 문서는 RSA Data Security, Inc.의 사업부인 RSA Laboratories의 기여를 기반으로 합니다. 이 문서의 텍스트를 실질적으로 사용하려면 RSA Data Security, Inc.를 인정해야 합니다. RSA Data Security, Inc.는 언급되거나 참조된 모든 자료를 이 문서에서는 이를 "RSA Data Security, Inc. PKCS #1 v2.0"으로 식별합니다.

---
# **Authors' Addresses**

```text
   Burt Kaliski
   RSA Laboratories East
   20 Crosby Drive
   Bedford, MA  01730

   Phone: (617) 687-7000
   EMail: burt@rsa.com

   Jessica Staddon
   RSA Laboratories West
   2955 Campus Drive
   Suite 400
   San Mateo, CA 94403

   Phone: (650) 295-7600
   EMail: jstaddon@rsa.com
```

---
# **Full Copyright Statement**

저작권\(C\)인터넷학회\(1998\). 판권 소유.

본 문서와 그 번역본은 다른 사람에게 복사 및 제공될 수 있으며, 본 문서에 대해 논평하거나 설명하거나 구현을 지원하는 파생 저작물은 어떤 종류의 제한 없이 전체 또는 일부를 준비, 복사, 출판 및 배포할 수 있습니다. 단, 위의 저작권 표시와 이 단락은 모든 사본과 파생물에 포함되어 있어야 합니다. 그러나 이 문서 자체는 저작권 표시를 제거하거나 인터넷 협회 또는 기타 인터넷 조직에 대한 참조를 제거하는 등 어떠한 방식으로도 수정할 수 없습니다. 단, 인터넷 표준을 개발할 목적으로 필요한 경우는 제외됩니다. 이 경우 저작권에 대한 절차는 인터넷 표준 프로세스를 따라야 하거나 영어 이외의 언어로 번역하려면 필요한 대로 따라야 합니다.

위에 부여된 제한된 권한은 영구적이며 Internet Society 또는 그 승계자 또는 양수인에 의해 취소되지 않습니다.

이 문서와 여기에 포함된 정보는 "있는 그대로" 제공되며 인터넷 사회와 인터넷 엔지니어링 태스크 포스는 여기에 있는 정보의 사용으로 인해 발생하지 않는 모든 보증을 포함하되 이에 국한되지 않고 명시적이든 묵시적이든 모든 보증을 부인합니다. 특정 목적에 대한 상품성이나 적합성에 대한 권리나 묵시적인 보증을 침해하는 행위.


```text
Internet Engineering Task Force (IETF)                    J. Richer, Ed.
Request for Comments: 7591
Category: Standards Track                                       M. Jones
ISSN: 2070-1721                                                Microsoft
                                                              J. Bradley
                                                           Ping Identity
                                                             M. Machulak
                                                    Newcastle University
                                                                 P. Hunt
                                                      Oracle Corporation
                                                               July 2015

             OAuth 2.0 Dynamic Client Registration Protocol
```

---
# **Abstract**

이 사양은 OAuth 2.0 클라이언트를 인증 서버에 동적으로 등록하기 위한 메커니즘을 정의합니다. 등록 요청은 원하는 클라이언트 메타데이터 값 세트를 인증 서버로 보냅니다. 결과 등록 응답은 인증 서버에서 사용할 클라이언트 식별자와 클라이언트에 등록된 클라이언트 메타데이터 값을 반환합니다. 그런 다음 클라이언트는 이 등록 정보를 사용하여 OAuth 2.0 프로토콜을 사용하는 인증 서버와 통신할 수 있습니다. 또한 이 사양은 클라이언트가 등록 중에 사용할 공통 클라이언트 메타데이터 필드 및 값 집합을 정의합니다.

---
# **Status of This Memo**

이것은 인터넷 표준 추적 문서입니다.

이 문서는 IETF\(Internet Engineering Task Force\)의 제품입니다. 이는 IETF 커뮤니티의 합의를 나타냅니다. 공개 검토를 받았으며 IESG\(Internet Engineering Steering Group\)의 출판 승인을 받았습니다. 인터넷 표준에 대한 자세한 내용은 RFC 5741의 섹션 2에서 확인할 수 있습니다.

이 문서의 현재 상태, 정오표, 피드백 제공 방법에 대한 정보는 http://www.rfc-editor.org/info/rfc7591에서 얻을 수 있습니다.

---
# **Copyright Notice**

Copyright \(c\) 2015 IETF Trust 및 문서 작성자로 확인된 사람. 판권 소유.

이 문서는 이 문서의 발행일에 유효한 BCP 78 및 IETF 문서에 관한 IETF 트러스트의 법적 조항\(http://trustee.ietf.org/license-info\)의 적용을 받습니다. 이 문서와 관련된 귀하의 권리 및 제한 사항을 설명하므로 이 문서를 주의 깊게 검토하십시오. 이 문서에서 추출한 코드 구성 요소는 Trust Legal Provisions의 섹션 4.e에 설명된 대로 Simplified BSD License 텍스트를 포함해야 하며 Simplified BSD License에 설명된 대로 보증 없이 제공됩니다.

---
# **Table of Contents**

```text
   1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   4
     1.1.  Notational Conventions  . . . . . . . . . . . . . . . . .   4
     1.2.  Terminology . . . . . . . . . . . . . . . . . . . . . . .   4
     1.3.  Protocol Flow . . . . . . . . . . . . . . . . . . . . . .   7
   2.  Client Metadata . . . . . . . . . . . . . . . . . . . . . . .   8
     2.1.  Relationship between Grant Types and Response Types . . .  12
     2.2.  Human-Readable Client Metadata  . . . . . . . . . . . . .  13
     2.3.  Software Statement  . . . . . . . . . . . . . . . . . . .  14
   3.  Client Registration Endpoint  . . . . . . . . . . . . . . . .  15
     3.1.  Client Registration Request . . . . . . . . . . . . . . .  16
       3.1.1.  Client Registration Request Using a Software
               Statement . . . . . . . . . . . . . . . . . . . . . .  18
     3.2.  Responses . . . . . . . . . . . . . . . . . . . . . . . .  19
       3.2.1.  Client Information Response . . . . . . . . . . . . .  19
       3.2.2.  Client Registration Error Response  . . . . . . . . .  21
   4.  IANA Considerations . . . . . . . . . . . . . . . . . . . . .  23
     4.1.  OAuth Dynamic Client Registration Metadata Registry . . .  22
       4.1.1.  Registration Template . . . . . . . . . . . . . . . .  24
       4.1.2.  Initial Registry Contents . . . . . . . . . . . . . .  24
     4.2.  OAuth Token Endpoint Authentication Methods Registry  . .  27
       4.2.1.  Registration Template . . . . . . . . . . . . . . . .  28
       4.2.2.  Initial Registry Contents . . . . . . . . . . . . . .  28
   5.  Security Considerations . . . . . . . . . . . . . . . . . . .  28
   6.  Privacy Considerations  . . . . . . . . . . . . . . . . . . .  32
   7.  References  . . . . . . . . . . . . . . . . . . . . . . . . .  33
     7.1.  Normative References  . . . . . . . . . . . . . . . . . .  33
     7.2.  Informative References  . . . . . . . . . . . . . . . . .  35
   Appendix A.  Use Cases  . . . . . . . . . . . . . . . . . . . . .  33
     A.1.  Open versus Protected Dynamic Client Registration . . . .  34
       A.1.1.  Open Dynamic Client Registration  . . . . . . . . . .  34
       A.1.2.  Protected Dynamic Client Registration . . . . . . . .  34
     A.2.  Registration without or with Software Statements  . . . .  34
       A.2.1.  Registration without a Software Statement . . . . . .  34
       A.2.2.  Registration with a Software Statement  . . . . . . .  34
     A.3.  Registration by the Client or Developer . . . . . . . . .  34
       A.3.1.  Registration by the Client  . . . . . . . . . . . . .  35
       A.3.2.  Registration by the Developer . . . . . . . . . . . .  35
     A.4.  Client ID per Client Instance or per Client Software  . .  35
       A.4.1.  Client ID per Client Software Instance  . . . . . . .  35
       A.4.2.  Client ID Shared among All Instances of Client
               Software  . . . . . . . . . . . . . . . . . . . . . .  35
     A.5.  Stateful or Stateless Registration  . . . . . . . . . . .  35
       A.5.1.  Stateful Client Registration  . . . . . . . . . . . .  36
       A.5.2.  Stateless Client Registration . . . . . . . . . . . .  36
   Acknowledgments . . . . . . . . . . . . . . . . . . . . . . . . .  36
   Authors' Addresses  . . . . . . . . . . . . . . . . . . . . . . .  36
```

---
## **1.  Introduction**

OAuth 2.0 \[RFC6749\] 클라이언트가 OAuth 2.0 인증 서버를 활용하려면 클라이언트는 해당 서버에서 사용할 OAuth 2.0 클라이언트 식별자를 포함하여 서버와 상호 작용하기 위한 특정 정보가 필요합니다. 이 사양에서는 이 정보를 얻기 위해 OAuth 2.0 클라이언트를 인증 서버에 동적으로 등록하는 방법을 설명합니다.

등록 프로세스의 일부로 이 사양은 클라이언트가 유효한 리디렉션 URI 집합과 같은 메타데이터 집합을 인증 서버에 제공하는 메커니즘도 정의합니다. 이 메타데이터는 자체 주장 방식으로 전달되거나 소프트웨어 설명이라는 메타데이터 집합으로 전달될 수 있습니다. 이 메타데이터는 디지털 서명되거나 MAC\(메시지 인증 코드\)로 보호됩니다. 소프트웨어 명세서의 경우 발급자는 클라이언트에 대한 데이터의 유효성을 보증합니다.

전통적으로 인증 서버에 클라이언트를 등록하는 것은 수동으로 수행됩니다. 이 사양에 정의된 메커니즘은 클라이언트가 인증 서버에 동적으로 자신을 등록하거나 클라이언트 개발자가 프로그래밍 방식으로 클라이언트를 인증 서버에 등록하는 데 사용할 수 있습니다. OAuth 2.0을 사용하는 여러 애플리케이션은 이전에 이러한 등록을 수행하기 위한 메커니즘을 개발했습니다. 이 사양은 "OpenID Connect 동적 클라이언트 등록 1.0" \[OpenID.Registration\]에 의해 정의되고 "User Managed Access \(UMA\) Profile of OAuth 2.0" \[UMA-Core\]에 의해 사용되는 등록 메커니즘을 두 가지 모두와 호환되는 방식으로 일반화합니다. 더 광범위한 OAuth 2.0 사용 사례에 적용할 수 있습니다.

---
### **1.1.  Notational Conventions**

이 문서의 핵심 단어 'MUST', 'MUST NOT', 'REQUIRED', 'SHALL', 'SHALL NOT', 'SHOULD', 'SHOULD NOT', 'RECOMMENDED', 'MAY', 'OPTIONAL'은 다음과 같습니다. \[RFC2119\]에 설명된 대로 해석됩니다.\(MUST NOT\)

달리 명시하지 않는 한 모든 프로토콜 매개변수 이름과 값은 대소문자를 구분합니다.

---
### **1.2.  Terminology**

```text
   This specification uses the terms "access token", "authorization
   code", "authorization endpoint", "authorization grant",
   "authorization server", "client", "client identifier", "client
   secret", "grant type", "protected resource", "redirection URI",
```

OAuth 2.0 \[RFC6749\]에서 정의한 "새로 고침 토큰", "리소스 소유자", "리소스 서버", "응답 유형" 및 "토큰 엔드포인트"이며 JWT\(JSON Web Token\) \[RFC7519\]에서 정의한 "클레임"이라는 용어를 사용합니다. .

이 사양에서는 다음 용어를 정의합니다.

클라이언트 소프트웨어

- OAuth 2.0 클라이언트를 구현하는 소프트웨어.

클라이언트 인스턴스

- 클라이언트 소프트웨어의 배포된 인스턴스입니다.

클라이언트 개발자

- 클라이언트 소프트웨어 패키지를 구축하고 배포를 준비하는 사람 또는 조직입니다. 클라이언트가 구축될 때 개발자는 배포 서비스 공급자 조직이 누구인지 알지 못하는 경우가 많습니다. 클라이언트 개발자는 컴파일 시 배포 URL과 같은 소프트웨어 측면을 예측할 수 없는 경우 동적 등록을 사용해야 합니다. 예를 들어, 소프트웨어 API 게시자와 배포 조직이 동일하지 않을 때 이런 일이 발생할 수 있습니다.

클라이언트 등록 끝점

- 클라이언트가 인증 서버에 등록될 수 있는 OAuth 2.0 엔드포인트입니다. 이 끝점의 URL을 얻는 방법은 이 사양의 범위를 벗어납니다.

초기 액세스 토큰

- OAuth 2.0 액세스 토큰은 권한 부여 서버에서 선택적으로 개발자 또는 클라이언트에게 발행되고 클라이언트 등록 끝점에 대한 호출을 승인하는 데 사용됩니다. 이 토큰의 유형과 형식은 서비스별로 다를 수 있으며 이 사양의 범위를 벗어납니다. 인증 서버가 이 토큰을 발행하는 수단과 등록 엔드포인트가 이 토큰을 검증하는 수단은 이 사양의 범위를 벗어납니다. 인증 서버가 클라이언트를 등록할 수 있는 당사자를 제한하는 경우 초기 액세스 토큰을 사용해야 합니다.

배치 조직

- 소프트웨어 API\(서비스\)가 배포되고 OAuth 2.0 프레임워크에 의해 보호되는 관리 보안 도메인입니다. 일부 OAuth 시나리오에서는 배포 조직과 소프트웨어 API 게시자가 동일합니다. 이러한 경우 배포 조직은 클라이언트 소프트웨어 개발자와 긴밀한 관계를 갖는 경우가 많습니다. 다른 많은 경우에는 서비스 정의자가 독립적인 제3자 게시자 또는 표준 기관일 수 있습니다. 공개된 사양을 작업할 때

- API, 클라이언트 소프트웨어 개발자는 소프트웨어 API\(서비스\)를 배포하는 잠재적으로 많은 배포 조직과 사전 관계를 가질 수 없습니다.

소프트웨어 API 배포

- 특정 배포 조직 도메인에서 OAuth 2.0\(보호되는 리소스\)으로 보호되는 소프트웨어 API의 배포된 인스턴스입니다. 특정 소프트웨어 API의 경우 하나 이상의 배포가 있을 수 있습니다. 소프트웨어 API 배포에는 일반적으로 연결된 OAuth 2.0 인증 서버와 클라이언트 등록 엔드포인트가 있습니다. 엔드포인트를 얻는 방법은 이 사양의 범위를 벗어납니다.

소프트웨어 API 게시자

- 하나 이상의 배포 환경에 배포될 수 있는 특정 웹 액세스 가능 API를 정의하는 조직입니다. 게시자는 OAuth 2.0을 통해 보호될 수 있는 소프트웨어 및 API 사양을 게시하고 배포하는 일을 담당하는 표준 기관, 상업, 공공, 민간 또는 오픈 소스 조직일 수 있습니다. 어떤 경우에는 소프트웨어 API 게시자와 클라이언트 개발자가 동일한 조직일 수 있습니다. 웹 액세스 가능 API를 게시할 때 소프트웨어 게시자는 배포 조직과 사전 관계가 없는 경우가 많습니다.

소프트웨어 설명

- 클라이언트 소프트웨어에 대한 메타데이터 값을 주장하는 디지털 서명 또는 MAC JSON 웹 토큰\(JWT\) \[RFC7519\]입니다. 어떤 경우에는 클라이언트 개발자가 직접 소프트웨어 명세서를 발행합니다. 다른 경우에는 클라이언트 개발자가 사용할 수 있도록 타사 조직에서 소프트웨어 명세서를 발행합니다. 두 경우 모두 인증 서버와 소프트웨어 설명 발행자와의 신뢰 관계는 등록 요청이 수락되었는지 평가하는 입력으로 사용됩니다. 소프트웨어 설명은 클라이언트 등록 요청의 일부로 인증 서버에 제공될 수 있습니다.

---
### **1.3.  Protocol Flow**

```text
        +--------(A)- Initial Access Token (OPTIONAL)
        |
        |   +----(B)- Software Statement (OPTIONAL)
        |   |
        v   v
    +-----------+                                      +---------------+
    |           |--(C)- Client Registration Request -->|    Client     |
    | Client or |                                      | Registration  |
    | Developer |<-(D)- Client Information Response ---|   Endpoint    |
    |           |        or Client Error Response      +---------------+
    +-----------+

   Figure 1: Abstract Dynamic Client Registration Flow
```

그림 1에 설명된 추상 OAuth 2.0 클라이언트 동적 등록 흐름은 클라이언트 또는 개발자와 이 사양에 정의된 엔드포인트 간의 상호 작용을 설명합니다. 이 그림은 오류 조건을 보여주지 않습니다. 이 흐름에는 다음 단계가 포함됩니다.

\(A\) 선택적으로 클라이언트 등록 엔드포인트에 대한 액세스를 제공하는 초기 액세스 토큰이 클라이언트 또는 개발자에게 발급됩니다. 클라이언트 또는 개발자에게 초기 액세스 토큰을 발급하는 방법은 이 사양의 범위를 벗어납니다.

\(B\) 선택적으로 클라이언트 등록 끝점과 함께 사용할 소프트웨어 설명이 클라이언트 또는 개발자에게 발급됩니다. 소프트웨어 설명이 클라이언트나 개발자에게 발행되는 방법은 이 사양의 범위를 벗어납니다.

\(C\) 클라이언트 또는 개발자는 클라이언트가 원하는 등록 메타데이터를 사용하여 클라이언트 등록 엔드포인트를 호출합니다. 선택적으로 권한 부여 서버에서 요구하는 경우 \(A\)의 초기 액세스 토큰을 포함합니다.

\(D\) 인증 서버는 클라이언트를 등록하고 다음을 반환합니다.

- \* 클라이언트가 등록한 메타데이터,

- \* 서버에서 고유한 클라이언트 식별자, 그리고

- \* 이 클라이언트에 적용 가능한 경우 클라이언트 비밀과 같은 클라이언트 자격 증명 집합입니다.

다양한 구성 및 사용법의 예는 부록 A에 포함되어 있습니다.

---
## **2.  Client Metadata**

등록된 클라이언트에는 유효한 리디렉션 URI 목록 또는 표시 이름과 같은 인증 서버의 클라이언트 식별자와 연결된 메타데이터 값 세트가 있습니다.

이러한 클라이언트 메타데이터 값은 두 가지 방법으로 사용됩니다.

o 등록 요청에 대한 입력 값으로, 그리고

o 등록 응답의 출력 값으로.

다음 클라이언트 메타데이터 필드는 이 사양에 의해 정의됩니다. 달리 명시하지 않는 한 모든 클라이언트 메타데이터 필드의 구현 및 사용은 선택 사항입니다. 모든 데이터 멤버 유형\(문자열, 배열, 숫자\)은 JSON \[RFC7159\] 표현으로 정의됩니다.\(MAY\)

리디렉션\_uris

- 인증 코드 및 암시적 흐름과 같은 리디렉션 기반 흐름에 사용하기 위한 리디렉션 URI 문자열의 배열입니다. OAuth 2.0 \[RFC6749\]의 섹션 2에 따라 리디렉션이 포함된 흐름을 사용하는 클라이언트는 리디렉션 URI 값을 등록해야 합니다. 리디렉션 기반 흐름에 대한 동적 등록을 지원하는 인증 서버는 이 메타데이터 값에 대한 지원을 구현해야 합니다.\(MUST, MUST\)

token\_endpoint\_auth\_method

- 토큰 엔드포인트에 대해 요청된 인증 방법의 문자열 표시기입니다. 이 사양에서 정의한 값은 다음과 같습니다.

- \* "없음": 클라이언트는 OAuth 2.0, 섹션 2.1에 정의된 대로 공용 클라이언트이며 클라이언트 비밀번호가 없습니다.

- \* "client\_secret\_post": 클라이언트는 OAuth 2.0, 섹션 2.3.1에 정의된 대로 HTTP POST 매개변수를 사용합니다.

- \* "client\_secret\_basic": 클라이언트는 OAuth 2.0, 섹션 2.3.1에 정의된 대로 HTTP 기본을 사용합니다.

- 섹션 4.2에 설정된 IANA "OAuth 토큰 엔드포인트 인증 방법" 레지스트리를 통해 추가 값을 정의할 수 있습니다. 절대 URI를 등록하지 않고도 이 매개변수의 값으로 사용할 수도 있습니다. 지정하지 않거나 생략하는 경우 기본값은 OAuth 2.0의 섹션 2.3.1에 지정된 HTTP 기본 인증 체계를 나타내는 "client\_secret\_basic"입니다.

보조금 유형

- 클라이언트가 토큰 엔드포인트에서 사용할 수 있는 OAuth 2.0 부여 유형 문자열의 배열입니다. 이러한 보조금 유형은 다음과 같이 정의됩니다.

- \* "authorization\_code": OAuth 2.0, 섹션 4.1에 정의된 인증 코드 부여 유형입니다.

- \* "암시적": OAuth 2.0, 섹션 4.2에 정의된 암시적 부여 유형입니다.

- \* "password": OAuth 2.0, 섹션 4.3에 정의된 리소스 소유자 비밀번호 자격 증명 부여 유형입니다.

- \* "client\_credentials": OAuth 2.0, 섹션 4.4에 정의된 클라이언트 자격 증명 부여 유형입니다.

- \* "refresh\_token": OAuth 2.0, 섹션 6에 정의된 새로 고침 토큰 부여 유형입니다.

- \* "urn:ietf:params:oauth:grant-type:jwt-bearer": OAuth JWT 전달자 토큰 프로필 \[RFC7523\]에 정의된 JWT 전달자 토큰 부여 유형입니다.

- \* "urn:ietf:params:oauth:grant-type:saml2-bearer": OAuth SAML 2 전달자 토큰 프로필 \[RFC7522\]에 정의된 SAML 2.0 전달자 어설션 부여입니다.

- 토큰 엔드포인트가 부여 유형에 사용되는 경우 이 매개변수의 값은 부여 유형 정의에 정의된 토큰 엔드포인트에 전달된 "grant\_type" 매개변수의 값과 동일해야 합니다. 권한 부여 서버는 OAuth 2.0, 섹션 4.5에 설명된 승인 유형 확장 프로세스에 정의된 대로 다른 값을 허용할 수 있습니다. 생략하는 경우 기본 동작은 클라이언트가 "authorization\_code" 부여 유형만 사용하는 것입니다.\(MUST, MAY\)

response\_types

- 클라이언트가 인증 끝점에서 사용할 수 있는 OAuth 2.0 응답 유형 문자열의 배열입니다. 이러한 응답 유형은 다음과 같이 정의됩니다.

- \* "code": OAuth 2.0, 섹션 4.1에 정의된 인증 코드 응답 유형입니다.

- \* "토큰": OAuth 2.0, 섹션 4.2에 정의된 암시적 응답 유형입니다.

- 승인 엔드포인트가 승인 유형에 의해 사용되는 경우 이 매개변수의 값은 승인 유형 정의에 정의된 승인 엔드포인트에 전달된 "response\_type" 매개변수의 값과 동일해야 합니다. 권한 부여 서버는 OAuth 2.0, 섹션 4.5에 설명된 승인 유형 확장 프로세스에 정의된 대로 다른 값을 허용할 수 있습니다. 생략하는 경우 기본값은 클라이언트가 "코드" 응답 유형만 사용하는 것입니다.\(MUST, MAY\)

고객 이름

- 인증 중에 최종 사용자에게 표시될 클라이언트의 사람이 읽을 수 있는 문자열 이름입니다. 생략하면 인증 서버는 최종 사용자에게 원시 "client\_id" 값을 대신 표시할 수 있습니다. 클라이언트는 항상 이 필드를 보내는 것이 좋습니다. 이 필드의 값은 섹션 2.2에 설명된 대로 국제화될 수 있습니다.\(MAY, SHOULD, MAY\)

client\_uri

- 클라이언트에 대한 정보를 제공하는 웹페이지의 URL 문자열입니다. 존재하는 경우 서버는 이 URL을 클릭 가능한 방식으로 최종 사용자에게 표시해야 합니다. 클라이언트는 항상 이 필드를 보내는 것이 좋습니다. 이 필드의 값은 유효한 웹페이지를 가리켜야 합니다. 이 필드의 값은 섹션 2.2에 설명된 대로 국제화될 수 있습니다.\(SHOULD, SHOULD, MUST, MAY\)

logo\_uri

- 클라이언트의 로고를 참조하는 URL 문자열입니다. 존재하는 경우 서버는 승인 중에 이 이미지를 최종 사용자에게 표시해야 합니다. 이 필드의 값은 유효한 이미지 파일을 가리켜야 합니다. 이 필드의 값은 섹션 2.2에 설명된 대로 국제화될 수 있습니다.\(SHOULD, MUST, MAY\)

범위

- 클라이언트가 액세스 토큰을 요청할 때 사용할 수 있는 공백으로 구분된 범위 값 목록\(OAuth 2.0 \[RFC6749\]의 섹션 3.3에 설명된 대로\)을 포함하는 문자열입니다. 이 목록에 있는 값의 의미는 서비스마다 다릅니다. 생략되면 인증 서버는 기본 범위 세트로 클라이언트를 등록할 수 있습니다.\(MAY\)

콘택트 렌즈

- 이 클라이언트를 담당하는 사람에게 연락하는 방법을 나타내는 문자열 배열\(일반적으로 이메일 주소\)입니다. 인증 서버는 클라이언트에 대한 지원 요청을 위해 최종 사용자가 이러한 연락처 주소를 사용할 수 있도록 할 수 있습니다. 개인 정보 보호 고려 사항에 대한 자세한 내용은 섹션 6을 참조하십시오.\(MAY\)

tos\_uri

- 클라이언트에 권한을 부여할 때 최종 사용자가 수락하는 최종 사용자와 클라이언트 간의 계약 관계를 설명하는 사람이 읽을 수 있는 클라이언트 서비스 약관 문서를 가리키는 URL 문자열입니다. 인증 서버는 이 URL이 제공되는 경우 최종 사용자에게 이 URL을 표시해야 합니다. 이 필드의 값은 유효한 웹페이지를 가리켜야 합니다. 이 필드의 값은 섹션 2.2에 설명된 대로 국제화될 수 있습니다.\(SHOULD, MUST, MAY\)

정책\_우리

- 배포 조직이 개인 데이터를 수집, 사용, 유지 및 공개하는 방법을 설명하는 사람이 읽을 수 있는 개인 정보 보호 정책 문서를 가리키는 URL 문자열입니다. 인증 서버는 이 URL이 제공되는 경우 최종 사용자에게 이 URL을 표시해야 합니다. 이 필드의 값은 유효한 웹페이지를 가리켜야 합니다. 이 필드의 값은 섹션 2.2에 설명된 대로 국제화될 수 있습니다.\(SHOULD, MUST, MAY\)

jwks\_uri

- 클라이언트의 공개 키가 포함된 클라이언트의 JSON 웹 키\(JWK\) 세트 \[RFC7517\] 문서를 참조하는 URL 문자열입니다. 이 필드의 값은 유효한 JWK 세트 문서를 가리켜야 합니다. 이러한 키는 서명 또는 암호화를 사용하는 상위 수준 프로토콜에서 사용할 수 있습니다. 예를 들어 클라이언트 인증을 위해 JWT를 사용할 때 토큰 엔드포인트에 대한 서명된 요청을 검증하기 위해 일부 애플리케이션에서 이러한 키를 사용할 수 있습니다\[RFC7523\]. 이 매개변수를 사용하면 키 순환이 더 쉬워지므로 "jwks" 매개변수보다 선호됩니다. "jwks\_uri" 및 "jwks" 매개변수는 모두 동일한 요청 또는 응답에 있어서는 안 됩니다.\(MUST, MUST NOT\)

jwks

- 클라이언트의 공개 키가 포함된 클라이언트의 JSON 웹 키 세트 \[RFC7517\] 문서 값입니다. 이 필드의 값은 유효한 JWK 세트를 포함하는 JSON 객체여야 합니다. 이러한 키는 서명 또는 암호화를 사용하는 상위 수준 프로토콜에서 사용할 수 있습니다. 이 매개변수는 공용 URL을 호스팅할 수 없는 기본 클라이언트와 같이 "jwks\_uri" 매개변수를 사용할 수 없는 클라이언트에서 사용하기 위한 것입니다. "jwks\_uri" 및 "jwks" 매개변수는 모두 동일한 요청 또는 응답에 있어서는 안 됩니다.\(MUST, MUST NOT\)

소프트웨어\_ID

- 동적으로 등록할 클라이언트 소프트웨어를 식별하기 위해 등록 엔드포인트에서 사용하는 클라이언트 개발자 또는 소프트웨어 게시자가 할당한 고유 식별자 문자열\(예: UUID\(Universally Unique Identifier\)\)입니다. 인증 서버에서 발급되고 인스턴스마다 달라야 하는 "client\_id"와 달리 "software\_id"는 클라이언트 소프트웨어의 모든 인스턴스에 대해 동일하게 유지되어야 합니다. "software\_id"는 전체에서 동일하게 유지되어야 합니다.\(SHOULD, SHOULD\)

- 동일한 소프트웨어의 여러 업데이트 또는 버전. 이 필드의 값은 사람이 읽을 수 있도록 의도되지 않았으며 일반적으로 클라이언트 및 인증 서버에 불투명합니다.

소프트웨어 버전

- "software\_id"로 식별되는 클라이언트 소프트웨어의 버전 식별자 문자열입니다. "software\_version"의 값은 동일한 "software\_id"로 식별되는 클라이언트 소프트웨어에 대한 업데이트 시 변경되어야 합니다. 이 필드의 값은 문자열 동일성 일치를 사용하여 비교하기 위한 것이며 이 사양에서는 다른 비교 의미가 정의되지 않습니다. 이 필드의 값은 이 사양의 범위를 벗어나지만 사람이 읽을 수 있도록 의도되지 않았으며 일반적으로 클라이언트 및 인증 서버에 불투명합니다. 이 값에 대한 변경을 유발하는 클라이언트 소프트웨어 업데이트를 구성하는 요소에 대한 정의는 소프트웨어 자체에 특정하며 이 사양의 범위를 벗어납니다.\(SHOULD\)

이 사양의 확장 및 프로필은 이 문서 섹션 4의 IANA 고려 사항에 따라 등록된 메타데이터 이름 및 설명으로 이 목록을 확장할 수 있습니다. 인증 서버는 클라이언트가 전송한 클라이언트 메타데이터 중 이해하지 못하는 모든 클라이언트 메타데이터를 무시해야 합니다\(예: 처리 중에 클라이언트의 등록 기록에서 알 수 없는 메타데이터를 자동으로 제거하는 방식\). 인증 서버는 섹션 3.2.1에 설명된 대로 요청된 값을 적절한 기본값으로 바꾸거나 섹션 3.2.2에 설명된 대로 오류 응답을 반환하여 요청된 클라이언트 메타데이터 값을 거부할 수 있습니다.\(MUST, MAY\)

클라이언트 메타데이터 값은 섹션 3.1에 설명된 대로 등록 요청 본문에서 직접 전달되거나 섹션 2.3에 설명된 대로 소프트웨어 설명에 클레임으로 포함될 수 있습니다. 두 가지를 혼합하는 것도 가능합니다. 동일한 클라이언트 메타데이터 이름이 두 위치 모두에 존재하고 소프트웨어 문이 인증 서버에서 신뢰되는 경우 소프트웨어 문의 클레임 값이 우선적으로 적용되어야 합니다.\(MUST\)

---
### **2.1.  Relationship between Grant Types and Response Types**

위에 설명된 "grant\_types" 및 "response\_types" 값은 OAuth 프로토콜의 서로 다른 끝점에 전달된 인수를 참조하므로 부분적으로 직교합니다. 그러나 클라이언트가 사용할 수 있는 "grant\_types"가 클라이언트가 사용할 수 있는 "response\_types"에 영향을 미치고 그 반대의 경우도 마찬가지라는 점에서 관련이 있습니다. 예를 들어, "authorization\_code"를 포함하는 "grant\_types" 값은 "code"를 포함하는 "response\_types" 값을 의미합니다. 두 값 모두 OAuth 2.0 인증 코드 부여의 일부로 정의되기 때문입니다. 따라서 이러한 필드를 지원하는 서버는

예를 들어 일관되지 않은 등록 요청에 대해 'invalid\_client\_metadata' 오류 응답을 반환하는 등 클라이언트가 일관되지 않은 상태로 등록할 수 없도록 조치를 취해야 합니다\(SHOULD\).\(SHOULD\)

두 필드 간의 상관 관계는 아래 표에 나열되어 있습니다.

```text
   +-----------------------------------------------+-------------------+
   | grant_types value includes:                   | response_types    |
   |                                               | value includes:   |
   +-----------------------------------------------+-------------------+
   | authorization_code                            | code              |
   | implicit                                      | token             |
   | password                                      | (none)            |
   | client_credentials                            | (none)            |
   | refresh_token                                 | (none)            |
   | urn:ietf:params:oauth:grant-type:jwt-bearer   | (none)            |
   | urn:ietf:params:oauth:grant-type:saml2-bearer | (none)            |
   +-----------------------------------------------+-------------------+
```

"grant\_types" 또는 "response\_types" 매개변수에 새로운 값을 도입하는 이 문서의 확장 및 프로필은 이 두 매개변수 유형 간의 모든 대응을 문서화해야 합니다.\(MUST\)

---
### **2.2.  Human-Readable Client Metadata**

사람이 읽을 수 있는 클라이언트 메타데이터 값과 사람이 읽을 수 있는 값을 참조하는 클라이언트 메타데이터 값은 여러 언어와 스크립트로 표현될 수 있습니다. 예를 들어 "client\_name", "tos\_uri", "policy\_uri", "logo\_uri" 및 "client\_uri"와 같은 필드 값은 일부 클라이언트 등록에서 여러 로캘별 값을 가질 수 있어 다양한 위치에서 쉽게 사용할 수 있습니다.\(MAY\)

언어와 스크립트를 지정하기 위해 BCP 47 \[RFC5646\] 언어 태그가 "#" 문자로 구분된 클라이언트 메타데이터 멤버 이름에 추가됩니다. JSON \[RFC7159\] 구성원 이름은 대소문자를 구분하므로 청구 이름에 사용된 언어 태그 값은 "IANA 언어 하위 태그" 레지스트리 \[IANA.Language\]에 등록된 대소문자를 사용하여 철자를 사용하는 것이 좋습니다. 특히, 일반적으로 언어 이름은 소문자로, 지역 이름은 대문자로, 언어는 대소문자를 혼합하여 씁니다. 그러나 BCP 47 언어 태그 값은 대소문자를 구분하지 않으므로 구현에서는 제공된 언어 태그 값을 대소문자를 구분하지 않고 해석해야 합니다. BCP 47의 권장 사항에 따라 메타데이터 구성원 이름에 사용되는 언어 태그 값은 필요한 만큼만 구체적이어야 합니다. 예를 들어, 다양한 상황에서는 "fr-CA" 또는 "fr-FR"보다 "fr"을 사용하는 것만으로도 충분할 수 있습니다.\(SHOULD, SHOULD\)

예를 들어 클라이언트는 이름을 영어로 "client\_name#en": "My Client"로 표시하고 일본어로 이름을 "client\_name#ja-Jpan-JP": "\u30AF\u30E9\u30A4\u30A2\u30F3\로 표시할 수 있습니다. u30C8\u540D'를 동일한 등록 요청 내에서 확인하세요. 인증 서버는 시스템 구성, 사용자 기본 설정 또는 기타 요인에 따라 표시할 이름을 선택하여 인증 단계 동안 리소스 소유자에게 이러한 이름 중 일부 또는 전부를 표시할 수 있습니다.\(MAY\)

사람이 읽을 수 있는 필드가 언어 태그 없이 전송되는 경우 이를 사용하는 당사자는 문자열 값의 언어, 문자 집합 또는 스크립트에 대해 어떠한 가정도 해서는 안 되며 문자열 값은 문자열 값이 표시되는 모든 곳에서 있는 그대로 사용해야 합니다. 사용자 인터페이스. 상호 운용성을 용이하게 하기 위해 클라이언트와 서버는 언어별 필드 외에 언어 태그 없이 사람이 읽을 수 있는 필드를 사용하는 것이 권장됩니다. 언어 태그 없이 전송된 사람이 읽을 수 있는 필드에는 표시에 적합한 값이 포함되어 있는 것이 좋습니다. 다양한 시스템.\(MUST NOT, SHOULD\)

구현자 참고 사항: 많은 JSON 라이브러리를 사용하면 JSON 개체의 멤버를 라이브러리의 기본 프로그래밍 환경에서 개체 구성의 멤버로 참조할 수 있습니다. 그러나 "#" 문자는 JSON 개체의 멤버 이름 내부에서는 유효한 문자이지만 많은 프로그래밍 환경에서 개체 멤버 이름에 사용할 수 있는 유효한 문자는 아닙니다. 따라서 구현에서는 이러한 클레임에 대해 대체 액세스 형식을 사용해야 합니다. 예를 들어 JavaScript에서 "var j = JSON.parse\(json\);"과 같이 JSON을 구문 분석하는 경우 해결 방법으로 JavaScript 구문 "j\[를 사용하여 "client\_name#en-us" 멤버에 액세스할 수 있습니다. "클라이언트\_이름#en-us"\]".

---
### **2.3.  Software Statement**

소프트웨어 설명은 클라이언트 소프트웨어에 대한 메타데이터 값을 번들로 주장하는 JWT\(JSON 웹 토큰\) \[RFC7519\]입니다. 소프트웨어 설명에 사용할 수 있는 일련의 클레임은 섹션 2에 정의되어 있습니다. 클라이언트 등록 요청의 일부로 인증 서버에 제공되는 경우 소프트웨어 설명은 JWS\(JSON 웹 서명\) \[RFC7515를 사용하여 디지털 서명되거나 MAC 처리되어야 합니다. \] 소프트웨어 설명의 클레임을 증명하는 당사자를 나타내는 "iss"\(발급자\) 클레임을 포함해야 합니다. 특정 응용 프로그램이 다른 알고리즘의 사용을 지정할 수도 있지만 소프트웨어 설명은 "RS256" 서명 알고리즘을 사용하여 디지털 방식으로 서명하는 것이 좋습니다. 인증 서버가 동일한 소프트웨어 문을 사용하여 소프트웨어의 서로 다른 인스턴스를 연관시킬 수 있도록 소프트웨어 문에 "software\_id" 클레임을 포함하는 것이 권장됩니다.\(MUST, SHOULD, SHOULD\)

예를 들어 소프트웨어 설명에는 다음과 같은 클레임이 포함될 수 있습니다.

```text
     {
      "software_id": "4NRB1-0XZABZI9E6-5SM3R",
      "client_name": "Example Statement-based Client",
      "client_uri": "https://client.example.net/"
     }
```

다음 비표준 예제 JWT에는 이러한 클레임이 포함되어 있으며 "RS256"\(표시 목적으로만 줄바꿈 포함\)을 사용하여 비대칭적으로 서명되었습니다.

```text
     eyJhbGciOiJSUzI1NiJ9.
     eyJzb2Z0d2FyZV9pZCI6IjROUkIxLTBYWkFCWkk5RTYtNVNNM1IiLCJjbGll
     bnRfbmFtZSI6IkV4YW1wbGUgU3RhdGVtZW50LWJhc2VkIENsaWVudCIsImNs
     aWVudF91cmkiOiJodHRwczovL2NsaWVudC5leGFtcGxlLm5ldC8ifQ.
     GHfL4QNIrQwL18BSRdE595T9jbzqa06R9BT8w409x9oIcKaZo_mt15riEXHa
     zdISUvDIZhtiyNrSHQ8K4TvqWxH6uJgcmoodZdPwmWRIEYbQDLqPNxREtYn0
     5X3AR7ia4FRjQ2ojZjk5fJqJdQ-JcfxyhK-P8BAWBd6I2LLA77IG32xtbhxY
     fHX7VhuU5ProJO8uvu3Ayv4XRhLZJY4yKfmyjiiKiPNe-Ia4SMy_d_QSWxsk
     U5XIQl5Sa2YRPMbDRXttm2TfnZM1xx70DoYi8g6czz-CPGRi4SW_S2RKHIJf
     IjoI3zTJ0Y2oe0_EJAiXbL6OyF9S5tKxDXV8JIndSA
```

소프트웨어 설명은 일반적으로 클라이언트 응용 프로그램의 모든 인스턴스와 함께 배포됩니다. 클라이언트나 개발자가 소프트웨어 설명을 얻는 방법은 이 사양의 범위를 벗어납니다. 일부 일반적인 방법에는 클라이언트 클래스에 대한 소프트웨어 설명을 얻기 위해 소프트웨어 API 게시자에 등록하여 클라이언트별 JWT를 생성하는 클라이언트 개발자가 포함될 수 있습니다.

인증 서버가 소프트웨어 설명의 정보를 신뢰하고 활용할지 여부를 결정하는 기준은 이 사양의 범위를 벗어납니다.

어떤 경우에는 인증 서버가 사전 동적 클라이언트 등록이 수행되지 않은 상태에서 인증 요청의 클라이언트 식별자로 직접 소프트웨어 문 값을 수락하도록 선택할 수도 있습니다. 인증 서버가 이를 수행하는 상황과 이 경우에 필요한 특정 소프트웨어 설명 특성은 이 사양의 범위를 벗어납니다.\(MAY\)

---
## **3.  Client Registration Endpoint**

클라이언트 등록 끝점은 클라이언트가 권한 부여 서버에 등록될 수 있도록 설계된 이 문서에 정의된 OAuth 2.0 끝점입니다. 클라이언트 등록 끝점은 요청 매개변수가 인코딩된 HTTP POST 메시지를 수락해야 합니다.\(MUST\)

"application/json" 형식을 사용하는 엔터티 본문. 클라이언트 등록 끝점은 섹션 5에 설명된 대로 전송 계층 보안 메커니즘으로 보호되어야 합니다.\(MUST\)

클라이언트 등록 끝점은 OAuth 2.0 \[RFC6749\] 보호 리소스일 수 있으며 OAuth 2.0 액세스 토큰 형식의 초기 액세스 토큰을 수락하여 이전에 승인된 당사자로만 등록을 제한할 수 있습니다. 클라이언트나 개발자가 초기 액세스 토큰을 얻는 방법은 일반적으로 대역 외이며 이 사양의 범위를 벗어납니다. 클라이언트 등록 끝점에서 초기 액세스 토큰을 확인하고 검증하는 방법은 이 사양의 범위를 벗어납니다.\(MAY\)

공개 등록을 지원하고 더 넓은 상호 운용성을 촉진하기 위해 클라이언트 등록 끝점은 인증 없이\(즉, 요청에 초기 액세스 토큰이 없는\) 등록 요청을 허용해야 합니다. 이러한 요청은 클라이언트 등록 끝점에 대한 서비스 거부 공격을 방지하기 위해 속도가 제한되거나 제한될 수 있습니다.\(SHOULD, MAY\)

---
### **3.1.  Client Registration Request**

이 작업은 클라이언트를 인증 서버에 등록합니다. 인증 서버는 이 클라이언트에 고유한 클라이언트 식별자를 할당하고 선택적으로 클라이언트 비밀을 할당하며 요청에 제공된 메타데이터를 발급된 클라이언트 식별자와 연결합니다. 요청에는 등록 중에 클라이언트에 대해 지정되는 모든 클라이언트 메타데이터 매개변수가 포함됩니다. 인증 서버는 클라이언트 메타데이터에서 생략된 모든 항목에 대한 기본값을 제공할 수 있습니다.\(MAY\)

등록하기 위해 클라이언트 또는 개발자는 콘텐츠 유형이 "application/json"인 클라이언트 등록 끝점에 HTTP POST를 보냅니다. HTTP 엔터티 페이로드는 JSON 개체와 해당 JSON 개체의 최상위 멤버로 요청된 모든 클라이언트 메타데이터 값으로 구성된 JSON \[RFC7159\] 문서입니다.

예를 들어 서버가 초기 액세스 토큰 없이 개방형 등록을 지원하는 경우 클라이언트는 클라이언트 등록 끝점에 다음 등록 요청을 보낼 수 있습니다.

다음은 초기 액세스 토큰을 사용하지 않는 비표준적인 요청 예시입니다.

```text
     POST /register HTTP/1.1
     Content-Type: application/json
     Accept: application/json
     Host: server.example.com

     {
      "redirect_uris": [
        "https://client.example.org/callback",
        "https://client.example.org/callback2"],
      "client_name": "My Example Client",
      "client_name#ja-Jpan-JP":
         "\u30AF\u30E9\u30A4\u30A2\u30F3\u30C8\u540D",
      "token_endpoint_auth_method": "client_secret_basic",
      "logo_uri": "https://client.example.org/logo.png",
      "jwks_uri": "https://client.example.org/my_public_keys.jwks",
      "example_extension_parameter": "example_value"
     }
```

또는 서버가 인증된 등록을 지원하는 경우 개발자 또는 클라이언트에 초기 액세스 토큰이 제공됩니다. \(초기 액세스 토큰을 얻는 방법은 본 사양의 범위를 벗어납니다.\) 개발자 또는 클라이언트는 다음과 같은 승인된 등록 요청을 클라이언트 등록 엔드포인트로 보냅니다. 이 예에서 초기 액세스 토큰은 OAuth 2.0 Bearer 토큰 \[RFC6750\]으로 전송되었지만 모든 OAuth 2.0 토큰 유형은 인증 서버에서 사용될 수 있습니다.

다음은 초기 액세스 토큰을 사용하고 값으로 JWK 설정을 등록하는 비표준적인 예제 요청입니다\(표시 목적으로만 값 내에 줄 바꿈 사용\).

```text
     POST /register HTTP/1.1
     Content-Type: application/json
     Accept: application/json
     Authorization: Bearer ey23f2.adfj230.af32-developer321
     Host: server.example.com

     {
      "redirect_uris": ["https://client.example.org/callback",
         "https://client.example.org/callback2"],
      "client_name": "My Example Client",
      "client_name#ja-Jpan-JP":
         "\u30AF\u30E9\u30A4\u30A2\u30F3\u30C8\u540D",
      "token_endpoint_auth_method": "client_secret_basic",
      "policy_uri": "https://client.example.org/policy.html",
      "jwks": {"keys": [{
         "e": "AQAB",
         "n": "nj3YJwsLUFl9BmpAbkOswCNVx17Eh9wMO-_AReZwBqfaWFcfG
   HrZXsIV2VMCNVNU8Tpb4obUaSXcRcQ-VMsfQPJm9IzgtRdAY8NN8Xb7PEcYyk
   lBjvTtuPbpzIaqyiUepzUXNDFuAOOkrIol3WmflPUUgMKULBN0EUd1fpOD70p
   RM0rlp_gg_WNUKoW1V-3keYUJoXH9NztEDm_D2MQXj9eGOJJ8yPgGL8PAZMLe
   2R7jb9TxOCPDED7tY_TU4nFPlxptw59A42mldEmViXsKQt60s1SLboazxFKve
   qXC_jpLUt22OC6GUG63p-REw-ZOr3r845z50wMuzifQrMI9bQ",
         "kty": "RSA"
      }]},
      "example_extension_parameter": "example_value"
     }
```

---
#### **3.1.1.  Client Registration Request Using a Software Statement**

섹션 2.3에 설명된 대로 JSON 요소 외에도 클라이언트 메타데이터 값이 소프트웨어 설명에 제공될 수도 있습니다. 인증 서버는 이 기능을 지원하지 않는 경우 소프트웨어 설명을 무시할 수 있습니다. 서버가 소프트웨어 문을 지원하는 경우 소프트웨어 문에 전달된 클라이언트 메타데이터 값은 일반 JSON 요소를 사용하여 전달된 값보다 우선해야 합니다.\(MAY, MAY, MUST\)

소프트웨어 문은 이 OPTIONAL 멤버를 사용하여 요청 JSON 개체에 포함됩니다.\(MAY\)

소프트웨어\_문

- 클라이언트 소프트웨어에 대한 클라이언트 메타데이터 값을 클레임으로 포함하는 소프트웨어 설명입니다. 서명된 JWT 전체를 포함하는 문자열 값입니다.

다음 예에서 일부 등록 매개변수는 섹션 2.3의 예에 있는 소프트웨어 설명에서 클레임으로 전달되는 반면, 클라이언트 인스턴스에 특정한 일부 값은 일반 매개변수로 전달됩니다\(표시 목적으로만 값 내에 줄 바꿈 포함\).

```text
     POST /register HTTP/1.1
     Content-Type: application/json
     Accept: application/json
     Host: server.example.com

     {
       "redirect_uris": [
         "https://client.example.org/callback",
         "https://client.example.org/callback2"
       ],
       "software_statement": "eyJhbGciOiJSUzI1NiJ9.
   eyJzb2Z0d2FyZV9pZCI6IjROUkIxLTBYWkFCWkk5RTYtNVNNM1IiLCJjbGll
   bnRfbmFtZSI6IkV4YW1wbGUgU3RhdGVtZW50LWJhc2VkIENsaWVudCIsImNs
   aWVudF91cmkiOiJodHRwczovL2NsaWVudC5leGFtcGxlLm5ldC8ifQ.
   GHfL4QNIrQwL18BSRdE595T9jbzqa06R9BT8w409x9oIcKaZo_mt15riEXHa
   zdISUvDIZhtiyNrSHQ8K4TvqWxH6uJgcmoodZdPwmWRIEYbQDLqPNxREtYn0
   5X3AR7ia4FRjQ2ojZjk5fJqJdQ-JcfxyhK-P8BAWBd6I2LLA77IG32xtbhxY
   fHX7VhuU5ProJO8uvu3Ayv4XRhLZJY4yKfmyjiiKiPNe-Ia4SMy_d_QSWxsk
   U5XIQl5Sa2YRPMbDRXttm2TfnZM1xx70DoYi8g6czz-CPGRi4SW_S2RKHIJf
   IjoI3zTJ0Y2oe0_EJAiXbL6OyF9S5tKxDXV8JIndSA",
       "scope": "read write",
       "example_extension_parameter": "example_value"
     }
```

---
### **3.2.  Responses**

등록 요청이 성공하면 인증 서버는 클라이언트에 대한 클라이언트 식별자를 반환합니다. 서버는 섹션 3.2.1에 설명된 대로 HTTP 201 생성 상태 코드와 콘텐츠가 포함된 "application/json" 유형의 본문으로 응답합니다.

등록 요청이 실패하면 인증 서버는 섹션 3.2.2에 설명된 대로 오류로 응답합니다.

---
#### **3.2.1.  Client Information Response**

클라이언트가 기밀 클라이언트인 경우 응답에는 클라이언트 식별자와 클라이언트 암호가 포함됩니다. 응답에는 이 사양의 확장으로 지정된 추가 필드가 포함될 수 있습니다.\(MAY\)

클라이언트\_ID

-  필수의. OAuth 2.0 클라이언트 식별자 문자열입니다. 인증 서버는 재량에 따라 등록된 클라이언트의 여러 인스턴스에 동일한 클라이언트 식별자를 발급할 수 있지만 현재 다른 등록된 클라이언트에 대해 유효해서는 안 됩니다.\(MUST, SHOULD NOT\)

클라이언트\_비밀

- 선택 사항입니다. OAuth 2.0 클라이언트 비밀 문자열입니다. 발행된 경우 이는 각 "client\_id"에 대해 고유해야 하며\(MUST\) 동일한 "client\_id"를 사용하는 클라이언트의 여러 인스턴스에 대해 고유해야 합니다\(SHOULD\). 이 값은 OAuth 2.0 \[RFC6749\], 섹션 2.3.1에 설명된 대로 기밀 클라이언트가 토큰 엔드포인트를 인증하는 데 사용됩니다.\(MAY, MUST\)

client\_id\_issued\_at

- 선택 사항입니다. 클라이언트 식별자가 발급된 시간입니다. 시간은 1970-01-01T00:00:00Z부터 발행 날짜/시간까지 UTC로 측정된 초 수로 표시됩니다.\(MAY\)

클라이언트\_비밀\_만료\_at

- "client\_secret"이 발행된 경우 필수입니다. 클라이언트 암호가 만료되는 시간 또는 만료되지 않는 경우 0입니다. 시간은 1970-01-01T00:00:00Z부터 만료 날짜/시간까지 UTC로 측정된 초 수로 표시됩니다.\(MUST\)

또한 인증 서버는 인증 서버 자체에서 제공한 모든 필드를 포함하여 이 클라이언트에 대해 등록된 모든 메타데이터를 반환해야 합니다. 인증 서버는 등록 중에 제출된 클라이언트의 요청 메타데이터 값을 거부하거나 교체하고 이를 적절한 값으로 대체할 수 있습니다. 클라이언트 또는 개발자는 응답의 값을 확인하여 등록이 사용하기에 충분한지 확인하고\(예: 등록된 "token\_endpoint\_auth\_method"가 클라이언트 소프트웨어에서 지원됨\) 클라이언트 소프트웨어에 적합한 조치 과정을 결정할 수 있습니다. 그러한 상황에 대한 대응은 이 사양의 범위를 벗어나지만 응용 프로그램 개발자 또는 인증 서버 공급자에게 보고서를 제출하는 것, 다른 메타데이터 값을 사용하여 재등록을 시도하는 것 또는 기타 다양한 방법이 포함될 수 있습니다. 예를 들어 서버가 \[RFC7592\]에 정의된 것과 같은 등록 관리 메커니즘도 지원하는 경우 클라이언트나 개발자는 다른 메타데이터 값으로 등록을 업데이트하려고 시도할 수 있습니다. 이 프로세스는 서버의 기능을 나열할 수 있는 \[OpenID.Discovery\]와 같은 서비스 검색 프로토콜의 도움을 받을 수도 있으며, 이를 통해 클라이언트는 더 많은 정보를 바탕으로 등록 요청을 할 수 있습니다. 그러한 관리 또는 검색 시스템의 사용은 선택 사항이며 이 사양의 범위를 벗어납니다.\(MUST, MAY\)

성공적인 등록 응답은 객체의 최상위 멤버로서 모든 매개변수가 있는 단일 JSON 객체 \[RFC7159\]로 구성된 "application/json" 유형의 본문이 있는 HTTP 201 생성 상태 코드를 사용합니다.

소프트웨어 문이 등록의 일부로 사용된 경우 해당 값은 "software\_statement" 멤버 이름을 사용하는 다른 메타데이터와 함께 응답에서 수정되지 않은 상태로 반환되어야 합니다. 소프트웨어 설명에서 사용된 클라이언트 메타데이터 요소는 등록 응답의 최상위 클라이언트 메타데이터 값으로 직접 반환되어야 합니다\(요청된 값과 사용된 값이 다를 수 있으므로 다른 값을 가질 수도 있음\).\(MUST, MUST\)

다음은 성공적인 등록에 대한 비표준적인 응답 예시입니다.

```text
     HTTP/1.1 201 Created
     Content-Type: application/json
     Cache-Control: no-store
     Pragma: no-cache

     {
      "client_id": "s6BhdRkqt3",
      "client_secret": "cf136dc3c1fc93f31185e5885805d",
      "client_id_issued_at": 2893256800,
      "client_secret_expires_at": 2893276800,
      "redirect_uris": [
        "https://client.example.org/callback",
        "https://client.example.org/callback2"],
      "grant_types": ["authorization_code", "refresh_token"],
      "client_name": "My Example Client",
      "client_name#ja-Jpan-JP":
         "\u30AF\u30E9\u30A4\u30A2\u30F3\u30C8\u540D",
      "token_endpoint_auth_method": "client_secret_basic",
      "logo_uri": "https://client.example.org/logo.png",
      "jwks_uri": "https://client.example.org/my_public_keys.jwks",
      "example_extension_parameter": "example_value"
     }
```

---
#### **3.2.2.  Client Registration Error Response**

클라이언트가 잘못된 초기 액세스 토큰을 제시하는 등 OAuth 2.0 오류 조건이 발생하면 인증 서버는 OAuth 2.0 토큰 유형에 적합한 오류 응답을 반환합니다.

등록 오류 조건이 발생하면 권한 부여 서버는 응답 본문의 오류를 설명하는 JSON 개체 \[RFC7159\]로 구성된 콘텐츠 유형 "application/json"과 함께 HTTP 400 상태 코드\(달리 지정하지 않는 한\)를 반환합니다.

JSON 객체에 포함하기 위해 두 멤버가 정의됩니다.

```text
   error
      REQUIRED.  Single ASCII error code string.
```

오류\_설명

- 선택 사항입니다. 디버깅에 사용되는 오류에 대한 사람이 읽을 수 있는 ASCII 텍스트 설명입니다.\(MAY\)

다른 구성원도 포함될 수 있으며, 이해되지 않으면 무시해야 합니다.\(MUST\)

이 사양은 다음 오류 코드를 정의합니다.

유효하지 않은\_리디렉션\_uri

- 하나 이상의 리디렉션 URI 값이 잘못되었습니다.

잘못된\_클라이언트\_메타데이터

- 클라이언트 메타데이터 필드 중 하나의 값이 잘못되어 서버가 이 요청을 거부했습니다. 인증 서버는 클라이언트 메타데이터의 요청된 매개변수에 대해 유효한 값을 대체하도록 선택할 수 있습니다.\(MAY\)

잘못된\_소프트웨어\_진술

- 제시된 소프트웨어 설명이 유효하지 않습니다.

승인되지 않은\_소프트웨어\_진술

- 제시된 소프트웨어 설명은 이 인증 서버에서 사용하도록 승인되지 않았습니다.

다음은 권한 부여 서버에 의해 블랙리스트에 추가된 리디렉션 URI로 인해 발생하는 오류 응답의 비표준적인 예입니다\(표시 목적으로만 값 내에 줄 바꿈 사용\).

```text
     HTTP/1.1 400 Bad Request
     Content-Type: application/json
     Cache-Control: no-store
     Pragma: no-cache

     {
      "error": "invalid_redirect_uri",
      "error_description": "The redirection URI
        http://sketchy.example.com is not allowed by this server."
     }
```

다음은 "response\_types" 및 "grant\_types" 값의 일관되지 않은 조합으로 인해 발생하는 오류 응답의 비표준적인 예입니다\(표시 목적으로만 값 내에 줄 바꿈 사용\).

```text
     HTTP/1.1 400 Bad Request
     Content-Type: application/json
     Cache-Control: no-store
     Pragma: no-cache

     {
      "error": "invalid_client_metadata",
      "error_description": "The grant type 'authorization_code' must be
        registered along with the response type 'code' but found only
       'implicit' instead."
     }
```

---
## **4.  IANA Considerations**
---
### **4.1.  OAuth Dynamic Client Registration Metadata Registry**

이 사양은 "OAuth 동적 클라이언트 등록 메타데이터" 레지스트리를 설정합니다.

OAuth 등록 클라이언트 메타데이터 이름 및 설명은 한 명 이상의 지정 전문가의 조언에 따라 oauth-ext-review@ietf.org 메일링 리스트에서 2주간의 검토 기간을 거친 후 필수 사양\(\[RFC5226\]\)에 등록됩니다. 그러나 출판 전에 이름 할당을 허용하기 위해 지정 전문가는 \[RFC7120\]에 따라 해당 사양이 출판될 것이라는 확신이 들면 등록을 승인할 수 있습니다.

검토를 위해 메일링 리스트로 전송된 등록 요청은 적절한 제목을 사용해야 합니다\(예: "OAuth 동적 클라이언트 등록 메타데이터 이름 등록 요청: 예"\).

검토 기간 내에 지정 전문가는 등록 요청을 승인하거나 거부하고 이 결정을 검토 목록과 IANA에 전달합니다. 거부에는 요청을 성공적으로 수행하는 방법에 대한 설명과 제안\(해당되는 경우\)이 포함되어야 합니다.

IANA는 지정 전문가의 레지스트리 업데이트만 수락해야 하며 모든 등록 요청을 검토 메일링 목록으로 보내야 합니다.

---
#### **4.1.1.  Registration Template**

클라이언트 메타데이터 이름:

- 요청된 이름\(예: "예"\) 이 이름은 대소문자를 구분합니다. 대소문자를 구분하지 않고 다른 등록된 이름과 일치하는 이름은 허용되어서는 안 됩니다.\(SHOULD NOT\)

클라이언트 메타데이터 설명:

- 메타데이터 값에 대한 간략한 설명\(예: "예시 설명"\)

컨트롤러 변경:

- 표준 트랙 RFC의 경우 "IESG"를 나열합니다. 그 외의 경우에는 책임 있는 당사자의 이름을 기재해 주십시오. 기타 세부정보\(예: 우편 주소, 이메일 주소, 홈페이지 URI\)도 포함될 수 있습니다.

사양 문서:

- 문서의 사본을 검색하는 데 사용할 수 있는 URI를 포함하는 클라이언트 메타데이터 정의를 지정하는 문서에 대한 참조입니다. 관련 섹션의 표시도 포함될 수 있지만 필수는 아닙니다.

---
#### **4.1.2.  Initial Registry Contents**

"OAuth 동적 클라이언트 등록 메타데이터" 레지스트리의 초기 내용은 다음과 같습니다.

o 클라이언트 메타데이터 이름: "redirect\_uris" o 클라이언트 메타데이터 설명: 리디렉션 기반 흐름에 사용하기 위한 리디렉션 URI 배열 o 변경 컨트롤러: IESG o 사양 문서: RFC 7591

o 클라이언트 메타데이터 이름: "token\_endpoint\_auth\_method" o 클라이언트 메타데이터 설명: 토큰 끝점에 대해 요청된 인증 방법 o 변경 컨트롤러: IESG o 사양 문서: RFC 7591

o 클라이언트 메타데이터 이름: "grant\_types" o 클라이언트 메타데이터 설명: 클라이언트가 사용할 수 있는 OAuth 2.0 부여 유형의 배열 o 변경 컨트롤러: IESG o 사양 문서: RFC 7591

o 클라이언트 메타데이터 이름: "response\_types" o 클라이언트 메타데이터 설명: 클라이언트가 사용할 수 있는 OAuth 2.0 응답 유형의 배열 o 변경 컨트롤러: IESG o 사양 문서: RFC 7591

o 클라이언트 메타데이터 이름: "client\_name" o 클라이언트 메타데이터 설명: 사용자에게 표시될 클라이언트의 사람이 읽을 수 있는 이름 o 변경 컨트롤러: IESG o 사양 문서: RFC 7591

o 클라이언트 메타데이터 이름: "client\_uri" o 클라이언트 메타데이터 설명: 클라이언트에 대한 정보를 제공하는 웹 페이지의 URL o 변경 컨트롤러: IESG o 사양 문서: RFC 7591

o 클라이언트 메타데이터 이름: "logo\_uri" o 클라이언트 메타데이터 설명: 클라이언트의 로고를 참조하는 URL o 변경 컨트롤러: IESG o 사양 문서: RFC 7591

o 클라이언트 메타데이터 이름: "scope" o 클라이언트 메타데이터 설명: 공백으로 구분된 OAuth 2.0 범위 값 목록 o 변경 컨트롤러: IESG o 사양 문서: RFC 7591

o 클라이언트 메타데이터 이름: "연락처" o 클라이언트 메타데이터 설명: 이 클라이언트를 담당하는 사람에게 연락하는 방법을 나타내는 문자열 배열\(일반적으로 이메일 주소\) o 변경 컨트롤러: IESG o 사양 문서: RFC 7591

o 클라이언트 메타데이터 이름: "tos\_uri" o 클라이언트 메타데이터 설명: 사람이 읽을 수 있는 클라이언트 서비스 약관 문서를 가리키는 URL o 변경 컨트롤러: IESG o 사양 문서: RFC 7591

o 클라이언트 메타데이터 이름: "policy\_uri" o 클라이언트 메타데이터 설명: 사람이 읽을 수 있는 클라이언트 정책 문서를 가리키는 URL o 변경 컨트롤러: IESG o 사양 문서: RFC 7591

o 클라이언트 메타데이터 이름: "jwks\_uri" o 클라이언트 메타데이터 설명: 클라이언트의 공개 키를 나타내는 클라이언트의 JSON 웹 키 세트 \[RFC7517\] 문서를 참조하는 URL o 변경 컨트롤러: IESG o 사양 문서: RFC 7591

o 클라이언트 메타데이터 이름: "jwks" o 클라이언트 메타데이터 설명: 클라이언트의 공개 키를 나타내는 클라이언트의 JSON 웹 키 세트 \[RFC7517\] 문서 o 변경 컨트롤러: IESG o 사양 문서: RFC 7591

o 클라이언트 메타데이터 이름: "software\_id" o 클라이언트 메타데이터 설명: 클라이언트를 구성하는 소프트웨어의 식별자 o 변경 컨트롤러: IESG o 사양 문서: RFC 7591

o 클라이언트 메타데이터 이름: "software\_version" o 클라이언트 메타데이터 설명: 클라이언트를 구성하는 소프트웨어의 버전 식별자 o 변경 컨트롤러: IESG o 사양 문서: RFC 7591

```text
   o  Client Metadata Name: "client_id"
   o  Client Metadata Description: Client identifier
   o  Change Controller: IESG
   o  Specification Document(s): RFC 7591

   o  Client Metadata Name: "client_secret"
   o  Client Metadata Description: Client secret
   o  Change Controller: IESG
   o  Specification Document(s): RFC 7591
```

o 클라이언트 메타데이터 이름: "client\_id\_issued\_at" o 클라이언트 메타데이터 설명: 클라이언트 식별자가 발급된 시간 o 변경 컨트롤러: IESG o 사양 문서: RFC 7591

o 클라이언트 메타데이터 이름: "client\_secret\_expires\_at" o 클라이언트 메타데이터 설명: 클라이언트 암호가 만료되는 시간 o 변경 컨트롤러: IESG o 사양 문서: RFC 7591

---
### **4.2.  OAuth Token Endpoint Authentication Methods Registry**

이 사양은 "OAuth 토큰 끝점 인증 방법" 레지스트리를 설정합니다.

"token\_endpoint\_auth\_method" 값으로 사용할 추가 값은 한 명 이상의 지정 전문가의 조언에 따라 2주간의 검토 기간 후 oauth-ext-review@ietf.org 메일링 리스트에 필수 사양\(\[RFC5226\]\)에 등록됩니다. . 그러나 출판 전에 값을 할당할 수 있도록 지정 전문가는 \[RFC7120\]에 따라 해당 사양이 출판될 것이라는 확신이 들면 등록을 승인할 수 있습니다.

등록 요청은 검토 및 의견을 위해 적절한 제목\(예: "token\_endpoint\_auth\_method 값 등록 요청: 예"\)과 함께 oauth-ext-review@ietf.org 메일링 리스트로 보내야 합니다.

검토 기간 내에 지정 전문가는 등록 요청을 승인하거나 거부하고 이 결정을 검토 목록과 IANA에 전달합니다. 거부에는 요청을 성공적으로 수행하는 방법에 대한 설명과 제안\(해당되는 경우\)이 포함되어야 합니다.

IANA는 지정 전문가의 레지스트리 업데이트만 수락해야 하며 모든 등록 요청을 검토 메일링 목록으로 보내야 합니다.

---
#### **4.2.1.  Registration Template**

토큰 엔드포인트 인증 방법 이름:

- 요청된 이름\(예: "예"\) 이 이름은 대소문자를 구분합니다. 대소문자를 구분하지 않고 다른 등록된 이름과 일치하는 이름은 허용되어서는 안 됩니다.\(SHOULD NOT\)

컨트롤러 변경:

- 표준 트랙 RFC의 경우 "IESG"를 나열합니다. 그 외의 경우에는 책임 있는 당사자의 이름을 기재해 주십시오. 기타 세부정보\(예: 우편 주소, 이메일 주소, 홈페이지 URI\)도 포함될 수 있습니다.

사양 문서:

- 토큰 엔드포인트 인증 방법을 지정하는 문서에 대한 참조\(문서 사본을 검색하는 데 사용할 수 있는 URI를 포함하는 것이 바람직함\) 관련 섹션의 표시도 포함될 수 있지만 필수는 아닙니다.

---
#### **4.2.2.  Initial Registry Contents**

"OAuth 토큰 엔드포인트 인증 방법" 레지스트리의 초기 내용은 다음과 같습니다.

```text
   o  Token Endpoint Authentication Method Name: "none"
   o  Change Controller: IESG
   o  Specification Document(s): RFC 7591

   o  Token Endpoint Authentication Method Name: "client_secret_post"
   o  Change Controller: IESG
   o  Specification Document(s): RFC 7591

   o  Token Endpoint Authentication Method Name: "client_secret_basic"
   o  Change Controller: IESG
   o  Specification Document(s): RFC 7591
```

---
## **5.  Security Considerations**

클라이언트 등록 끝점에 대한 요청으로 인해 HTTP 요청 및 응답에서 일반 텍스트 자격 증명이 전송되므로 인증 서버는 등록 끝점에 요청을 보낼 때 전송 계층 보안 메커니즘을 사용해야 합니다. 서버는 TLS 1.2 \[RFC5246\]를 지원해야 하며 보안 요구 사항을 충족하는 추가 전송 계층 보안 메커니즘을 지원할 수 있습니다. TLS를 사용할 때 클라이언트는 RFC 6125 \[RFC6125\]에 따라 TLS/SSL 서버 인증서 확인을 수행해야 합니다. 구현 보안 고려 사항은 TLS 및 DTLS의 안전한 사용을 위한 권장 사항 \[BCP195\]에서 확인할 수 있습니다.\(MUST, MUST, MUST\)

"authorization\_code" 및 "암시적"과 같은 리디렉션 기반 권한 부여 유형을 사용하는 클라이언트의 경우 인증 서버는 클라이언트에게 리디렉션 URI 값을 등록하도록 요구해야 합니다\(MUST\). 이는 악의적 행위자가 유효하게 등록된 클라이언트를 삽입 및 가장하고 잘못된 리디렉션 URI 또는 ​​공개 리디렉터를 통해 해당 인증 코드 또는 토큰을 가로채는 공격을 완화하는 데 도움이 될 수 있습니다. 또한 리디렉션의 반환 값 하이재킹을 방지하려면 등록된 리디렉션 URI 값은 다음 중 하나여야 합니다.\(MUST, MUST\)

```text
   o  A remote web site protected by TLS
      (e.g., https://client.example.com/oauth_redirect)
   o  A web site hosted on the local machine using an HTTP URI
      (e.g., http://localhost:8080/oauth_redirect)
   o  A non-HTTP application-specific URL that is available only to the
      client application
      (e.g., exampleapp://oauth_redirect)
```

공용 클라이언트는 인증 서버의 정책이 허용하는 경우 이 프로토콜을 사용하여 인증 서버에 등록할 수 있습니다. 퍼블릭 클라이언트는 "token\_endpoint\_auth\_method" 메타데이터 필드에 "none" 값을 사용하며 일반적으로 "암시적" 부여 유형과 함께 사용됩니다. 이러한 클라이언트는 사용자의 리소스에 대한 액세스를 요청하는 단기 브라우저 내 애플리케이션인 경우가 많으며 액세스는 인증 서버에서 사용자의 활성 세션에 연결됩니다. 이러한 클라이언트에는 장기 저장 공간이 없는 경우가 많기 때문에 브라우저 애플리케이션이 로드될 때마다 해당 클라이언트를 다시 등록해야 할 수도 있습니다. 데드 클라이언트 식별자의 확산을 피하기 위해 인증 서버는 일정 기간이 경과한 후 특정 기준을 충족하는 기존 클라이언트에 대한 등록을 만료하기로 결정할 수 있습니다. 또는 이러한 클라이언트를 브라우저 내 응용 프로그램의 코드가 제공되는 서버에 등록하고 클라이언트 구성을 코드와 함께 브라우저에 푸시할 수 있습니다.\(MAY, MAY\)

다양한 OAuth 2.0 부여 유형에는 보안 및 사용 속성이 다르기 때문에 인증 서버는 여러 부여 유형을 지원하기 위해 소프트웨어에 대해 별도의 등록이 필요할 수 있습니다. 예를 들어, 권한 부여 서버는 "authorization\_code" 권한 부여 유형을 사용하는 모든 클라이언트가 "token\_endpoint\_auth\_method"에 대한 클라이언트 비밀을 사용하도록 요구할 수 있지만 "암시적" 권한 부여 유형을 사용하는 모든 클라이언트는 토큰 엔드포인트에서 어떠한 인증도 사용하지 않습니다. 이러한 상황에서 서버는 클라이언트가 "authorization\_code" 및 "암시적" 권한 부여 유형 모두에 동시에 등록하는 것을 허용하지 않을 수 있습니다. 마찬가지로 "authorization\_code" 권한 부여 유형은 최종 사용자를 대신한 액세스를 나타내는 데 사용되지만 "client\_credentials" 권한 부여 유형은 클라이언트 자체를 대신한 액세스를 나타냅니다. 보안상의 이유로 인증 서버는 이러한 다양한 용도에 대해 서로 다른 범위를 사용하도록 요구할 수 있습니다.\(MAY, MAY\)

경우에 따라 결과적으로 이 두 가지 승인 유형이 동일한 클라이언트에 의해 함께 등록되는 것을 허용하지 않을 수 있습니다. 이러한 모든 경우에 인증 서버는 "invalid\_client\_metadata" 오류 응답으로 응답합니다.\(MAY\)

소프트웨어 설명에서 클레임으로 사용되지 않는 한, 인증 서버는 모든 클라이언트 메타데이터를 자체 어설션된 것으로 처리해야 합니다. 예를 들어, 악성 클라이언트는 가장하려는 합법적인 클라이언트의 이름과 로고를 사용할 수 있습니다. 또한, 악성 클라이언트는 합법적인 클라이언트의 소프트웨어 식별자나 소프트웨어 버전을 사용하여 권한 부여 서버에서 자신을 합법적인 클라이언트의 인스턴스와 연결하려고 시도할 수 있습니다. 이에 대응하려면 인증 서버는 전체 등록 요청과 클라이언트 구성을 확인하여 이 위험을 완화하기 위한 적절한 조치를 취해야 합니다. 예를 들어, 인증 서버는 로고의 도메인/사이트가 리디렉션 URI의 도메인/사이트와 일치하지 않는 경우 경고를 발행할 수 있습니다. 인증 서버는 다른 리디렉션 URI 또는 ​​다른 클라이언트 URI를 요청하는 알려진 소프트웨어 식별자의 등록 요청을 거부할 수도 있습니다. 또한 인증 서버는 모든 경우에 동적으로 등록된 클라이언트에 대해 최종 사용자에게 경고 메시지를 표시할 수 있습니다. 특히 해당 클라이언트가 최근에 등록되었거나 이전에 인증 서버에서 어떤 사용자도 신뢰하지 않은 경우 더욱 그렇습니다.\(MUST, MUST\)

인증 서버가 공개 클라이언트 등록을 지원하는 상황에서는 사용자에게 표시될 클라이언트가 제공하는 모든 URL\(예: "logo\_uri", "tos\_uri", "client\_uri" 및 "policy\_uri\)에 매우 주의해야 합니다. "\). 예를 들어, 악성 클라이언트는 "policy\_uri"에서 드라이브 바이 다운로드에 대한 참조를 사용하여 등록 요청을 지정하여 인증 중에 사용자가 이를 클릭하도록 유도할 수 있습니다. 인증 서버는 "logo\_uri", "tos\_uri", "client\_uri" 및 "policy\_uri"가 "redirect\_uris" 배열에 정의된 것과 동일한 호스트 및 체계를 가지고 있는지, 그리고 이러한 모든 URI가 다음으로 해결되는지 확인해야 합니다. 유효한 웹페이지. 이러한 URI 값은 인증 페이지에서 사용자에게 표시되도록 되어 있으므로 인증 서버는 가능한 경우 URL에서 호스팅되는 악성 콘텐츠로부터 사용자를 보호해야 합니다. 예를 들어 인증 페이지에서 사용자에게 URL을 표시하기 전에 인증 서버는 URL에서 호스팅되는 콘텐츠를 다운로드하고, 악성 코드 스캐너 및 블랙리스트 필터와 비교하여 콘텐츠를 확인하고, 보안과 비보안이 혼합되어 있는지 여부를 판단할 수 있습니다. URL의 콘텐츠 및 기타 가능한 서버 측 완화. 이러한 URL의 콘텐츠는 언제든지 변경될 수 있으며 인증 서버는 URL의 안전성에 대해 완전한 확신을 제공할 수 없지만 이러한 관행이 도움이 될 수 있습니다. 이러한 종류의 위협을 더욱 완화하기 위해 인증 서버는 URL 링크가 제3자에 의해 제공되었으므로 사용자에게 경고할 수도 있습니다.\(SHOULD, SHOULD\)

주의해야 하며 인증 서버 자체에서 호스팅되지 않습니다. 예를 들어, HTML 앵커에 직접 링크를 제공하는 대신 인증 서버는 사용자가 대상 URL로 계속 이동할 수 있도록 허용하기 전에 사용자를 삽입 경고 페이지로 안내할 수 있습니다.

클라이언트는 등록 요청의 일부로 클라이언트 메타데이터를 인증 서버에 제공하기 위해 직접 JSON 개체와 JWT로 인코딩된 소프트웨어 설명을 모두 사용할 수 있습니다. 소프트웨어 문은 암호로 보호되며 문 발급자가 제기한 주장을 나타내는 반면, JSON 개체는 클라이언트나 개발자가 직접 주장한 자체 주장을 나타냅니다. 소프트웨어 문이 유효하고 허용 가능한 기관\(예: 소프트웨어 API 게시자\)에 의해 서명된 경우 소프트웨어 문 내의 클라이언트 메타데이터 값은 가로채서 차단될 수 있는 일반 JSON 개체에 표시된 메타데이터 값보다 우선해야 합니다. 수정되었습니다.\(MAY, MUST\)

모든 메타데이터 값과 마찬가지로 소프트웨어 명세서는 해당 내용이 소프트웨어 명세서 발행인에 의해 디지털 서명되거나 MAC 처리되었더라도 클라이언트가 자체적으로 주장하는 항목입니다. 따라서 소프트웨어 설명을 제시하는 것만으로는 대부분의 경우 클라이언트 소프트웨어를 완전히 식별하는 데 충분하지 않습니다. 이와 대조적으로 초기 액세스 토큰은 클라이언트 소프트웨어의 특정 부분에 대한 정보를 반드시 포함할 필요는 없지만 대신 등록 끝점을 사용할 수 있는 권한을 나타냅니다. 인증 서버는 주어진 등록 요청을 수락할지 여부를 결정할 때 소프트웨어 설명, 초기 액세스 토큰 및 JSON 클라이언트 메타데이터 값을 포함한 전체 등록 요청을 고려해야 합니다.\(MUST\)

인증 서버가 여러 인스턴스를 동시에 등록할 의도가 없는 클라이언트에 대한 등록 요청을 수신하고 인증 서버가 등록 중복을 추론할 수 있는 경우\(예: 다른 기존 클라이언트와 동일한 "software\_id" 및 "software\_version" 값을 사용함\) \), 서버는 새로운 등록을 의심스러운 것으로 처리하고 등록을 거부해야 합니다. 새 클라이언트가 사용자를 속여 인증하도록 속이기 위해 기존 클라이언트를 가장하려고 하거나 원래 등록이 더 이상 유효하지 않을 수 있습니다. 이 상황을 관리하는 세부 사항은 인증 서버 배포에만 해당되며 이 사양의 범위를 벗어납니다.\(SHOULD\)

클라이언트 식별자는 인증 끝점에서 클라이언트를 가장하는 데 사용할 수 있는 공개 값이므로 등록된 클라이언트의 여러 인스턴스에 동일한 클라이언트 식별자를 발급하기로 결정한 인증 서버는 이 작업이 수행되는 상황에 대해 매우 특별해야 합니다. 발생합니다. 예를 들어 인증 서버는 특정 클라이언트 식별자를 클라이언트로 제한할 수 있습니다.

동일한 리디렉션 기반 흐름과 동일한 리디렉션 URI를 사용합니다. 인증 서버는 동일한 클라이언트 식별자가 발급된 경우에도 등록된 클라이언트의 여러 인스턴스에 동일한 클라이언트 비밀번호를 발급해서는 안 됩니다. 그렇지 않으면 클라이언트 비밀번호가 유출되어 악의적인 사기꾼이 기밀 클라이언트를 가장할 수 있습니다.\(SHOULD NOT\)

---
## **6.  Privacy Considerations**

이 사양에 설명된 프로토콜은 사람이 아닌 소프트웨어에 대한 정보를 거의 독점적으로 다루기 때문에 사용 시 개인 정보 보호 문제가 거의 없습니다. 주목할 만한 예외는 섹션 2에 정의된 "연락처" 필드로, 클라이언트 소프트웨어를 담당하는 개발자나 기타 당사자의 연락처 정보가 포함되어 있습니다. 이 값은 최종 사용자에게 표시되도록 의도되었으며 인증 서버의 관리자가 사용할 수 있습니다. 따라서 개발자는 개인 주소나 직업 주소를 사용하는 대신 클라이언트 지원 목적으로 명시적으로 전용된 이메일 주소나 기타 연락처 정보를 제공하기를 원할 수 있습니다. 또는 개발자가 작업을 계속하고 다른 사람이 해당 책임을 맡은 후에도 클라이언트 소프트웨어에 대한 지속적인 연락 및 지원을 허용하기 위해 개발자는 클라이언트에 집합 이메일 주소를 제공할 수 있습니다.

일반적으로 클라이언트 이름 및 소프트웨어 식별자와 같은 클라이언트의 메타데이터는 클라이언트 소프트웨어의 모든 인스턴스에서 공통되므로 최종 사용자에게 개인 정보 보호 문제를 일으키지 않습니다. 반면에 클라이언트 식별자는 클라이언트의 특정 인스턴스에 대해 고유한 경우가 많습니다. 많은 사용자가 사용하는 웹 사이트와 같은 클라이언트의 경우 클라이언트 식별자와 관련하여 심각한 개인 정보 보호 문제가 없을 수 있지만 단일 최종 사용자의 장치에 설치된 기본 애플리케이션과 같은 클라이언트의 경우 클라이언트 식별자를 고유하게 추적할 수 있습니다. OAuth 2.0 트랜잭션 및 해당 단일 최종 사용자와 관련된 사용 중. 그러나 클라이언트 소프트웨어는 OAuth 2.0 권한 부여를 통해 리소스 소유자의 승인을 받아야 하기 때문에 인증된 리소스 소유자를 요청 클라이언트 식별자와 연관시켜 클라이언트 식별자가 고유한지 여부에 관계없이 이러한 유형의 추적이 발생할 수 있습니다.

이 사양에서는 클라이언트가 자신의 클라이언트 식별자를 생성하는 것을 금지합니다. 클라이언트가 그렇게 할 수 있는 경우 여러 공모 인증 서버에서 개별 클라이언트 인스턴스가 추적되어 개인 정보 보호 및 보안 문제가 발생할 수 있습니다. 또한 클라이언트 식별자는 일반적으로 동일한 소프트웨어 인스턴스에 대해서도 등록 요청마다 고유하게 발급됩니다. 이러한 방식으로 애플리케이션은 여러 번 등록하고 완전히 별개인 것처럼 보임으로써 개인 정보 보호를 약간 향상시킬 수 있습니다.

응용 프로그램. 그러나 이 기술은 리소스 소유자당 여러 권한을 요구하는 형태로 상당한 유용성 비용을 발생시키므로 실제로 사용되지 않을 것입니다.

---
## **7.  References**
---
### **7.1.  Normative References**

```text
   [BCP195]   Sheffer, Y., Holz, R., and P. Saint-Andre,
              "Recommendations for Secure Use of Transport Layer
              Security (TLS) and Datagram Transport Layer Security
              (DTLS)", BCP 195, RFC 7525, May 2015,
              <http://www.rfc-editor.org/info/bcp195>.

   [IANA.Language]
              IANA, "Language Subtag Registry",
              <http://www.iana.org/assignments/
              language-subtag-registry>.

   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", BCP 14, RFC 2119,
              DOI 10.17487/RFC2119, March 1997,
              <http://www.rfc-editor.org/info/rfc2119>.

   [RFC5226]  Narten, T. and H. Alvestrand, "Guidelines for Writing an
              IANA Considerations Section in RFCs", BCP 26, RFC 5226,
              DOI 10.17487/RFC5226, May 2008,
              <http://www.rfc-editor.org/info/rfc5226>.

   [RFC5246]  Dierks, T. and E. Rescorla, "The Transport Layer Security
              (TLS) Protocol Version 1.2", RFC 5246,
              DOI 10.17487/RFC5246, August 2008,
              <http://www.rfc-editor.org/info/rfc5246>.

   [RFC5646]  Phillips, A., Ed. and M. Davis, Ed., "Tags for Identifying
              Languages", BCP 47, RFC 5646, DOI 10.17487/RFC5646,
              September 2009, <http://www.rfc-editor.org/info/rfc5646>.

   [RFC6125]  Saint-Andre, P. and J. Hodges, "Representation and
              Verification of Domain-Based Application Service Identity
              within Internet Public Key Infrastructure Using X.509
              (PKIX) Certificates in the Context of Transport Layer
              Security (TLS)", RFC 6125, DOI 10.17487/RFC6125, March
              2011, <http://www.rfc-editor.org/info/rfc6125>.

   [RFC6749]  Hardt, D., Ed., "The OAuth 2.0 Authorization Framework",
              RFC 6749, DOI 10.17487/RFC6749, October 2012,
              <http://www.rfc-editor.org/info/rfc6749>.

   [RFC6750]  Jones, M. and D. Hardt, "The OAuth 2.0 Authorization
              Framework: Bearer Token Usage", RFC 6750,
              DOI 10.17487/RFC6750, October 2012,
              <http://www.rfc-editor.org/info/rfc6750>.

   [RFC7120]  Cotton, M., "Early IANA Allocation of Standards Track Code
              Points", BCP 100, RFC 7120, DOI 10.17487/RFC7120, January
              2014, <http://www.rfc-editor.org/info/rfc7120>.

   [RFC7159]  Bray, T., Ed., "The JavaScript Object Notation (JSON) Data
              Interchange Format", RFC 7159, DOI 10.17487/RFC7159, March
              2014, <http://www.rfc-editor.org/info/rfc7159>.

   [RFC7515]  Jones, M., Bradley, J., and N. Sakimura, "JSON Web
              Signature (JWS)", RFC 7515, DOI 10.17487/RFC7515, May
              2015, <http://www.rfc-editor.org/info/rfc7515>.

   [RFC7517]  Jones, M., "JSON Web Key (JWK)", RFC 7517,
              DOI 10.17487/RFC7517, May 2015,
              <http://www.rfc-editor.org/info/rfc7517>.

   [RFC7519]  Jones, M., Bradley, J., and N. Sakimura, "JSON Web Token
              (JWT)", RFC 7519, DOI 10.17487/RFC7519, May 2015,
              <http://www.rfc-editor.org/info/rfc7519>.

   [RFC7522]  Campbell, B., Mortimore, C., and M. Jones, "Security
              Assertion Markup Language (SAML) 2.0 Profile for OAuth 2.0
              Client Authentication and Authorization Grants", RFC 7522,
              DOI 10.17487/RFC7522, May 2015,
              <http://www.rfc-editor.org/info/rfc7522>.

   [RFC7523]  Jones, M., Campbell, B., and C. Mortimore, "JSON Web Token
              (JWT) Profile for OAuth 2.0 Client Authentication and
              Authorization Grants", RFC 7523, DOI 10.17487/RFC7523, May
              2015, <http://www.rfc-editor.org/info/rfc7523>.
```

---
### **7.2.  Informative References**

```text
   [OpenID.Discovery]
              Sakimura, N., Bradley, J., Jones, M., and E. Jay, "OpenID
              Connect Discovery 1.0", November 2014,
              <http://openid.net/specs/
              openid-connect-discovery-1_0.html>.

   [OpenID.Registration]
              Sakimura, N., Bradley, J., and M. Jones, "OpenID Connect
              Dynamic Client Registration 1.0", November 2014,
              <http://openid.net/specs/
              openid-connect-registration-1_0.html>.

   [RFC7592]  Richer, J., Jones, M., Bradley, J., and M. Machulak,
              "OAuth 2.0 Dynamic Client Registration Management
              Protocol", RFC 7592, DOI 10.17487/RFC7592, July 2015,
              <http://www.rfc-editor.org/info/rfc7592>.
```

\[UMA-코어\]

- Hardjono, T., Maler, E., Machulak, M. 및 D. Catalano, "OAuth 2.0의 사용자 관리 액세스\(UMA\) 프로필", 진행 중인 작업,draft-hardjono-oauth-umacore-13, 4월 2015.

---
# **Appendix A.  Use Cases**

이 부록에서는 선택해야 할 몇 가지 사항을 설명하는 것을 포함하여 이 사양을 활용할 수 있는 다양한 방법을 설명합니다. 일부 선택 사항은 독립적이어서 조합하여 사용할 수 있는 반면, 일부 선택 사항은 상호 연관되어 있습니다.

---
### **A.1.  Open versus Protected Dynamic Client Registration**
---
#### **A.1.1.  Open Dynamic Client Registration**

공개 등록을 지원하는 인증 서버에서는 초기 액세스 토큰 없이도 등록이 가능합니다. 이를 통해 모든 클라이언트 소프트웨어가 인증 서버에 등록될 수 있습니다.

---
#### **A.1.2.  Protected Dynamic Client Registration**

보호된 등록을 지원하는 인증 서버에서는 등록 요청 시 초기 액세스 토큰을 사용해야 합니다. 클라이언트나 개발자가 이 초기 액세스 토큰을 받는 방법과 권한 부여 서버가 이 초기 액세스 토큰을 검증하는 방법은 이 사양의 범위를 벗어나지만, 일반적인 접근 방식은 개발자가 수동 사전 등록 포털을 사용하는 것입니다. 개발자에게 초기 액세스 토큰을 발급하는 인증 서버입니다.

---
### **A.2.  Registration without or with Software Statements**
---
#### **A.2.1.  Registration without a Software Statement**

소프트웨어 설명이 등록 요청에 사용되지 않는 경우 인증 서버는 클라이언트 메타데이터 값을 어떤 기관의 디지털 서명이나 MAC 처리\(따라서 증명\) 없이 사용할 수 있어야 합니다. \(이 선택은 개방형 대 보호형 선택과 무관하며 초기 액세스 토큰은 또 다른 가능한 증명 형식이라는 점에 유의하세요.\)

---
#### **A.2.2.  Registration with a Software Statement**

클라이언트 메타데이터 값 세트에 대한 인증을 기관에서 제공하기 위해 등록 요청에 소프트웨어 설명을 사용할 수 있습니다. 이는 인증 서버가 일련의 인증을 받은 클라이언트 소프트웨어로 등록을 제한하려고 하거나 여러 등록 요청이 동일한 클라이언트 소프트웨어를 참조하는지 알고 싶을 때 유용할 수 있습니다.

---
### **A.3.  Registration by the Client or Developer**
---
#### **A.3.1.  Registration by the Client**

일부 사용 사례에서는 클라이언트 소프트웨어가 인증 서버에 동적으로 등록하여 인증 서버와 상호 작용하는 데 필요한 클라이언트 식별자 및 기타 정보를 얻습니다. 이 경우 인증 서버에 대한 클라이언트 식별자가 클라이언트 소프트웨어와 함께 패키지되어 있지 않습니다.

---
#### **A.3.2.  Registration by the Developer**

어떤 경우에는 개발자\(또는 개발자가 사용하는 개발 소프트웨어\)가 클라이언트 소프트웨어를 인증 서버 또는 인증 서버 세트에 사전 등록합니다. 이 경우 인증 서버에 대한 클라이언트 식별자 값은 클라이언트 소프트웨어와 함께 패키지될 수 있습니다.

---
### **A.4.  Client ID per Client Instance or per Client Software**
---
#### **A.4.1.  Client ID per Client Software Instance**

어떤 경우에는 클라이언트 소프트웨어의 배포된 각 인스턴스가 고유한 클라이언트 식별자 값을 동적으로 등록하고 얻습니다. 예를 들어 코드 흐름을 사용하는 경우 각 클라이언트 인스턴스가 고유한 클라이언트 암호를 가질 수 있으므로 이는 유리할 수 있습니다. 이는 소프트웨어와 함께 패키지된 클라이언트 비밀 값의 비밀을 유지할 수 없지만 인스턴스별 클라이언트 비밀의 비밀을 유지할 수 있는 기본 클라이언트에 유용할 수 있습니다.

---
#### **A.4.2.  Client ID Shared among All Instances of Client Software**

어떤 경우에는 클라이언트 소프트웨어의 배포된 각 인스턴스가 공통 클라이언트 식별자 값을 공유합니다. 예를 들어, 클라이언트 암호가 관련되지 않은 암시적 흐름을 사용하는 브라우저 내 클라이언트의 경우가 종종 그렇습니다. 예를 들어 특정 인증 서버는 소프트웨어 문 값과 클라이언트 식별자 값 간의 매핑을 유지하고 특정 소프트웨어에 대한 모든 등록 요청에 대해 동일한 클라이언트 식별자 값을 반환하도록 선택할 수 있습니다. 인증 서버가 이를 수행하는 상황과 이 경우에 필요한 특정 소프트웨어 설명 특성은 이 사양의 범위를 벗어납니다.

---
### **A.5.  Stateful or Stateless Registration**
---
#### **A.5.1.  Stateful Client Registration**

어떤 경우에는 인증 서버가 등록된 클라이언트에 대한 상태를 유지하며 일반적으로 클라이언트 식별자 값을 사용하여 이 상태를 색인화합니다. 이 상태에는 일반적으로 클라이언트 등록과 관련된 클라이언트 메타데이터 값과 권한 부여 서버 구현과 관련된 기타 상태가 포함될 수 있습니다. 상태 저장 등록이 사용되면 이 상태 검색 및/또는 업데이트를 지원하는 작업이 지원될 수 있습니다. 상태 저장 등록 시 가능한 작업 세트 중 하나가 \[RFC7592\]에 설명되어 있습니다.

---
#### **A.5.2.  Stateless Client Registration**

어떤 경우에는 인증 서버가 등록된 클라이언트에 대한 로컬 상태를 유지하지 않는 방식으로 구현됩니다. 이를 수행하는 한 가지 방법은 반환된 클라이언트 식별자 값에 모든 등록 상태를 인코딩하고 상태를 인증 서버에 암호화하여 상태의 기밀성과 무결성을 유지하는 것입니다.

---
# **Acknowledgments**

저자는 이 문서에 대한 의견을 주신 OAuth 작업 그룹, 사용자 관리 액세스 작업 그룹 및 OpenID Connect 작업 그룹 참가자에게 감사드립니다. 특히 다음 개인은 이 문서의 다양한 초안 버전을 검토하고 기여하는 데 중요한 역할을 했습니다. Amanda Anganes, Derek Atkins, Tim Bray, Domenico Catalano, Donald Coffin, Vladimir Dzhuvinov, George Fletcher, Thomas Hardjono, William Kim, Torsten Lodderstedt, Eve Maler, Josh Mandel, Nov Matake, Tony Nadalin, Nat Sakimura, Christian Scholz 및 Hannes Tschofenig.

---
# **Authors' Addresses**

```text
   Justin Richer (editor)

   Email: ietf@justin.richer.org

   Michael B. Jones
   Microsoft

   Email: mbj@microsoft.com
   URI:   http://self-issued.info/

   John Bradley
   Ping Identity

   Email: ve7jtb@ve7jtb.com

   Maciej Machulak
   Newcastle University

   Email: maciej.machulak@gmail.com

   Phil Hunt
   Oracle Corporation

   Email: phil.hunt@yahoo.com
```
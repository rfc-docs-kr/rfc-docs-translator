

```text
Network Working Group                                             S. Sun
Request for Comments: 3650                                     L. Lannom
Category: Informational                                        B. Boesch
                                                                    CNRI
                                                           November 2003

                        Handle System Overview
```

---
# **Status of this Memo**

이 메모는 인터넷 커뮤니티에 대한 정보를 제공합니다. 어떤 종류의 인터넷 표준도 지정하지 않습니다. 이 메모의 배포는 무제한입니다.

---
# **Copyright Notice**

저작권\(C\)인터넷학회\(2003\). 판권 소유.

---
# **IESG Note**

IETF 및 IRTF 내의 여러 그룹에서는 핸들 시스템과 기존 식별자 시스템과의 관계에 대해 논의했습니다. IESG는 이러한 논의가 설명된 핸들 시스템에 대한 IETF 합의로 이어지지 않았으며 식별자에 대한 IETF 아키텍처에 어떻게 적합한지 지적하고 싶습니다. URI 형태, 특히 URN으로서의 핸들에 대한 논의가 있었지만, 이 문서에서는 네임스페이스와 식별자가 인터넷에서 작동하는 방식에 대한 대체 관점을 설명하고 IETF 합의 관점과 일치하지 않을 수 있는 기존 시스템의 특성을 포함합니다.

---
# **Abstract**

이 문서는 네임스페이스 및 서비스 아키텍처 측면뿐만 아니라 DNS, LDAP/X.500 및 URN과 같은 다른 인터넷 서비스와의 관계 측면에서 핸들 시스템의 개요를 제공합니다. 핸들 시스템은 인터넷과 같은 네트워크를 통해 보안된 이름 확인 및 관리를 허용하는 범용 전역 이름 서비스입니다. 핸들 시스템은 디지털 개체 및 기타 인터넷 리소스의 고유 이름인 핸들을 관리합니다.

---
# **Table of Contents**

```text
   1.  Introduction . . . . . . . . . . . . . . . . . . . . . . . . .  2
   2.  Motivations. . . . . . . . . . . . . . . . . . . . . . . . . .  6
   3.  Handle Namespace . . . . . . . . . . . . . . . . . . . . . . .  7
   4.  Handle System Architecture . . . . . . . . . . . . . . . . . .  8
   5.  Handle System Security . . . . . . . . . . . . . . . . . . . . 11
   6.  The Handle System and other Internet Services. . . . . . . . . 12
       6.1.  Domain Name Service (DNS). . . . . . . . . . . . . . . . 13
       6.2.  Directory Services (X.500/LDAP). . . . . . . . . . . . . 13
       6.3.  Uniform Resource Identifier (URI)/Uniform Resource Name
             (URN). . . . . . . . . . . . . . . . . . . . . . . . . . 14
   7.  Security Considerations. . . . . . . . . . . . . . . . . . . . 15
       7.1.  General Security Practice. . . . . . . . . . . . . . . . 15
       7.2.  Privacy Protection . . . . . . . . . . . . . . . . . . . 16
       7.3.  Caching and Proxy Servers. . . . . . . . . . . . . . . . 16
       7.4.  Mirroring. . . . . . . . . . . . . . . . . . . . . . . . 17
       7.5.  Denial of Service (DoS). . . . . . . . . . . . . . . . . 17
   8.  History of the Handle System . . . . . . . . . . . . . . . . . 18
   9.  Acknowledgements . . . . . . . . . . . . . . . . . . . . . . . 18
   10. References and Bibliography. . . . . . . . . . . . . . . . . . 19
   11. Authors' Addresses . . . . . . . . . . . . . . . . . . . . . . 20
   12. Full Copyright Statement . . . . . . . . . . . . . . . . . . . 21
```

---
## **1.  Introduction**

이 문서에서는 인터넷과 같은 네트워크에서 사용할 수 있도록 효율적이고 확장 가능하며 안전한 글로벌 이름 서비스를 제공하도록 설계된 분산 정보 시스템인 핸들 시스템에 대한 개요를 제공합니다. 핸들 시스템에는 개방형 프로토콜, 네임스페이스 및 프로토콜의 참조 구현이 포함되어 있습니다. 프로토콜을 사용하면 분산 컴퓨터 시스템이 디지털 리소스의 이름이나 핸들을 저장하고 해당 핸들을 리소스를 찾고 액세스하고 사용하는 데 필요한 정보로 변환할 수 있습니다. 핸들을 변경하지 않고도 식별된 리소스의 현재 상태를 반영하기 위해 필요에 따라 이러한 연관된 ​​값을 변경할 수 있습니다. 이를 통해 위치 및 기타 현재 상태 정보가 변경되어도 항목 이름이 유지됩니다. 각 핸들에는 자체 관리자가 있을 수 있으며 관리는 분산 환경에서 수행될 수 있습니다. 핸들 시스템은 보안 핸들 확인을 지원합니다. 고객 요청 시 데이터 기밀성, 데이터 무결성, 부인 방지 등의 보안 서비스가 제공됩니다.

핸들 시스템은 고유한 핸들 시스템 명명 권한을 획득하여 기존 로컬 네임스페이스가 전역 핸들 네임스페이스에 합류할 수 있도록 하는 연합 이름 서비스를 제공합니다. 로컬 이름과 해당 값 바인딩은 핸들 시스템에 가입한 후에도 그대로 유지됩니다. 로컬 네임스페이스에 대한 모든 핸들 요청이 처리될 수 있습니다.

핸들 시스템 프로토콜을 말하는 서비스 인터페이스를 통해. 고유한 명명 권한과 결합되어 모든 로컬 이름은 전역 핸들 네임스페이스에서 고유함이 보장됩니다.

오늘날 인터넷 리소스에 대한 이름 서비스를 제공하는 데 사용되는 여러 서비스가 있습니다. 그 중 DNS\(Domain Name System\)\[2,3\]가 가장 널리 사용되고 있다. DNS는 "이름이 IP 주소에 매핑되고 다양한 호스트, 네트워크, 프로토콜 제품군, 인터넷 및 관리 조직에서 사용할 수 있는 방식으로 리소스에 이름을 지정하기 위한 메커니즘을 제공"하도록 설계되었습니다\[3\]. 인터넷의 성장으로 인해 DNS에 대한 다양한 확장에 대한 요구가 높아졌습니다. DNS를 범용 리소스 명명 시스템으로 사용하려는 시도도 있습니다. 그러나 기본 네트워크 라우팅에서 DNS의 중요성으로 인해 DNS 확장을 구현하거나 범용 리소스 이름 지정을 위해 DNS를 오버로드할 때 큰 주의가 필요했습니다. DNS를 범용 이름 지정 서비스로 사용하는 것을 반대하는 또 다른 요소는 DNS 관리 모델입니다. DNS 이름은 일반적으로 DNS 영역 수준에서 네트워크 관리자가 관리합니다. 이름별 관리 구조에 대한 규정은 없으며 네트워크 관리자 이외의 다른 사람이 DNS 이름을 생성하거나 관리할 수 있는 기능도 없습니다. 이는 도메인 이름 관리에는 적합하지만 범용 리소스 이름 지정에는 적합하지 않습니다.

핸들 시스템은 처음부터 범용 이름 지정 서비스 역할을 하도록 설계되었습니다. 이는 매우 많은 수의 엔터티를 수용하고 공용 인터넷을 통한 분산 관리를 허용하도록 설계되었습니다. 핸들 시스템 데이터 모델을 사용하면 주어진 핸들과 연관된 각 데이터 값의 수준에서 액세스 제어를 정의할 수 있습니다. 각 핸들은 네트워크 또는 호스트 관리자로부터 독립된 자체 관리자 집합을 추가로 정의할 수 있습니다.

전통적인 URL\(Uniform Resource Locator\)\[4\]을 사용하면 특정 인터넷 리소스의 이름을 DNS 이름과 로컬 이름의 조합으로 지정할 수 있습니다. 로컬 이름은 로컬 파일 경로이거나 일부 로컬 서비스\(예: cgi-bin 스크립트\)에 대한 참조일 수 있습니다. DNS 이름과 로컬 이름의 조합은 개별 인터넷 리소스의 이름을 지정하고 관리하기 위한 유연한 관리 모델을 제공합니다. 그러나 URL 관행에는 몇 가지 주요 제한 사항도 있습니다. 대부분의 URL 구성표\(예: http\)는 확인용으로만 정의됩니다. 모든 URL 관리는 로컬 호스트에서 수행되거나 NFS와 같은 다른 네트워크 서비스를 통해 수행되어야 합니다. URL을 이름으로 사용하면 일반적으로 인터넷 리소스가 현재 네트워크 위치에 연결됩니다. 예를 들어 파일 경로가 URL의 일부인 경우 URL은 로컬 파일 경로에 연결됩니다. 어떤 이유로든 리소스가 한 위치에서 다른 위치로 이동하면 URL이 끊어집니다. 특히 주변에서 일하는 것이 어렵습니다.

소유권은 일반적으로 도메인 이름에 반영되므로 위치 변경 이유가 자산 소유권 변경인 경우 이 문제가 발생합니다.

핸들 시스템은 이러한 한계를 극복하고 중요한 기능을 추가하도록 설계되었습니다. 특히 핸들 시스템은 다음과 같은 목적으로 설계되었습니다.

- - 고유성: 모든 핸들은 핸들 시스템 내에서 전역적으로 고유합니다.

- - 지속성: 핸들은 인터넷 리소스에 대한 영구 식별자로 사용될 수 있습니다. 핸들은 이름이 지정된 엔터티에서 파생될 필요가 없습니다. 편의를 위해 기존 이름이나 니모닉도 핸들에 포함될 수 있지만 핸들과 이름이 지정된 엔터티 간의 유일한 작동 연결은 핸들 시스템 내에서 유지됩니다. 물론 이것이 행정적 배려의 기능인 지속성을 보장하지는 않습니다. 그러나 위치, 소유권 및 기타 상태 조건이 변경되어도 동일한 이름이 지속될 수 있습니다. 예를 들어 명명된 리소스가 한 위치에서 다른 위치로 이동할 때 핸들 시스템의 값을 업데이트하여 새 위치를 반영함으로써 핸들이 유효한 상태로 유지될 수 있습니다.

- - 다중 인스턴스: 단일 핸들은 네트워크의 서로 다른 위치 및 변경 가능한 위치에 있는 리소스의 여러 인스턴스를 참조할 수 있습니다. 애플리케이션은 이를 활용하여 성능과 안정성을 높일 수 있습니다. 예를 들어, 네트워크 서비스는 서비스 로드를 분산시키기 위해 단일 핸들을 사용하여 해당 서비스에 대한 여러 진입점을 정의할 수 있습니다.

- - 다중 속성: 단일 핸들은 서로 다르고 변경 가능한 네트워크 위치에서 모든 방법을 통해 사용할 수 있는 관련 서비스를 포함하여 리소스의 여러 속성을 참조할 수 있습니다. 따라서 핸들은 식별된 리소스와 관련된 진화하는 서비스 세계에 대한 지속적인 진입점으로 사용될 수 있습니다.

- - 확장 가능한 네임스페이스: 기존 로컬 네임스페이스는 고유한 핸들 명명 권한을 획득하여 핸들 네임스페이스에 합류할 수 있습니다. 이를 통해 기존 네임스페이스와의 충돌을 피하면서 로컬 네임스페이스를 전역 컨텍스트에 도입할 수 있습니다. 명명 권한을 사용하면 해결 및 관리 서비스를 로컬 처리 서비스에 위임할 수도 있습니다.

- - 국제 지원: 핸들 네임스페이스는 현재 전 세계에서 사용되는 대부분의 문자를 포함하는 Unicode 3.0\[17\]을 기반으로 합니다. 이를 통해 모든 기본 환경에서 핸들을 사용할 수 있습니다. 핸들 프로토콜은 핸들에 사용되는 인코딩으로 UTF-8 \[5\]을 요구합니다.

- 분산 서비스 모델: 핸들 시스템은

- 임의의 로컬 핸들 네임스페이스가 해당 로컬 핸들 서비스, 글로벌 서비스 또는 둘 다에 의해 서비스될 수 있는 계층적 서비스 모델. 글로벌 핸들 레지스트리\(Global Handle Registry\)로 알려진 글로벌 서비스는 모든 핸들 서비스 요청을 책임 있는 로컬 핸들 서비스에 전달하는 데 사용될 수 있습니다. 분산 서비스 모델을 사용하면 특정 서비스를 여러 서비스 사이트로 복제할 수 있으며, 각 서비스 사이트는 해당 서비스를 개별 서버 클러스터에 추가로 배포할 수 있습니다. \(여기서 로컬은 네임스페이스 및 관리 문제만을 의미합니다. 로컬 핸들 서비스에는 실제로 인터넷을 통해 분산된 많은 서비스 사이트가 있을 수 있습니다.\)

- - 보안 이름 서비스: 핸들 시스템을 사용하면 공용 인터넷을 통한 보안 이름 확인 및 관리가 가능합니다. 핸들 시스템 프로토콜은 클라이언트와 서버 인증은 물론 서비스 인증을 위한 표준 메커니즘을 정의합니다. 또한 데이터 무결성과 기밀성을 보장하는 보안 옵션도 제공합니다.

- - 분산 관리 서비스: 각 핸들은 자체 관리자 또는 관리자 그룹을 정의할 수 있습니다. 각 핸들의 소유권은 관리자 또는 관리자 그룹 측면에서 정의됩니다. 이는 핸들 시스템 인증 프로토콜과 결합되어 모든 네트워크 위치에서 관리자가 공용 네트워크를 통해 모든 핸들을 안전하게 관리할 수 있습니다.

- - 효율적인 확인 서비스: 핸들 프로토콜은 매우 효율적인 이름 확인 성능을 허용하도록 설계되었습니다. 계산 비용이 많이 드는 관리 서비스로 인해 확인이 영향을 받는 것을 방지하기 위해 핸들 이름 확인 및 관리를 위한 별도의 서비스 인터페이스\(즉, 서버 프로세스 및 관련 통신 포트\)가 모든 핸들 서비스에 의해 정의될 수 있습니다.

이 문서에서는 핸들 네임스페이스와 서비스 아키텍처에 대한 개요를 제공합니다. 또한 핸들 시스템을 다른 기존 인터넷 서비스, 프로토콜 및 사양\(예: DNS \[2, 3\], URL \[4\], X.500/LDAP \[6,7,8\] 및 URN \[9,10\)과 비교합니다. \]\). 핸들 시스템 데이터, 서비스 모델, 통신 프로토콜에 대한 세부 사항은 별도의 문서에 명시되어 있습니다. 그들

핸들 시스템 웹사이트\(http://www.handle.net\)에서 찾을 수 있습니다.

---
## **2.  Motivations**

인터넷 커뮤니티에는 이름과 관련된 프로젝트가 많기 때문에 핸들 시스템이 어디에 적합하다고 생각하는지 정확하게 정의하는 것이 좋습니다. 불행하게도 다른 기본 명명 체계는 추상적인 서비스 접근 방식\(예: URI/URN\)을 취하거나 기본 데이터베이스의 안정적이면서도 분산된 관리를 위한 자체 포함 프레임워크가 없는 이름 확인 접근 방식\(예: , DNS\). 이로 인해 핸들 시스템을 분류하기가 어렵습니다.

핸들 시스템은 경계를 넘습니다. 이름 확인 시스템으로 보면 DNS와 비교할 수 있습니다. URI/URN 네임스페이스를 구현하는 데 사용되는 경우 모든 URI/URN 체계와 함께 사용할 수 있습니다. 분산된 정보 업데이트 및 관리에 사용된다면 분산 데이터베이스 시스템의 단순화된 버전으로 간주될 수 있습니다.

핸들 시스템을 분산 데이터베이스를 안전하게 생성, 업데이트, 유지 관리 및 액세스하기 위한 특정 프로토콜을 사용하는 이름 속성 바인딩 서비스로 보는 것이 가장 좋습니다. 이는 공용 인터넷과 같은 네트워크를 통해 보안 정보 및 리소스 공유를 가능하게 하는 서비스로 설계되었습니다. 핸들 시스템의 애플리케이션에는 디지털 출판물을 위한 메타데이터 서비스, 가상 ID를 위한 ID 관리 서비스 또는 전역적으로 고유한 식별자의 확인 및/또는 관리가 필요한 기타 애플리케이션이 포함될 수 있습니다.

탐구 정신으로 핸들 시스템은 이름 확인을 위한 고성능을 갖고 분산 액세스 제어 및 관리의 경계를 넓히도록 설계되었습니다. 광범위하게 권한을 부여받은 비교적 적은 수의 관리자를 갖도록 설계된 대부분의 기존 시스템\(분산 시스템 포함\)과 달리 핸들 시스템을 사용하면 매우 세밀하게 관리 제어를 제어할 수 있습니다. 여기에는 각 핸들의 소유권을 시스템 관리자로부터 분리하고 각 핸들 값에 대해 액세스 제어를 정의할 수 있는 고유한 독립형 관리 프레임워크가 있습니다.

모든 실제 시스템과 마찬가지로 핸들 시스템도 여러 기술적 문제와 실제 문제 사이의 절충안이라는 점에 유의해야 합니다. 핸들 시스템이 기존의 다른 인터넷 이름 서비스와 관련하여 어디에 적합한지에 대해 IETF 내에서도 다양한 의견이 있습니다. 이 RFC를 작성하는 것은 더 넓은 커뮤니티에 개념, 접근 방식, 특정 결정, 장단점 및 결과를 노출시키는 것을 목표로 합니다.

---
## **3.  Handle Namespace**

모든 핸들은 두 부분, 즉 접두사로 알려진 명명 권한과 접미사로 알려진 명명 권한 아래의 고유한 로컬 이름으로 구성됩니다.

```text
      <Handle> ::= <Handle Naming Authority> "/" <Handle Local Name>
```

명명 권한과 로컬 이름은 ASCII 문자 "/"로 구분됩니다. 명명 권한 아래의 로컬 이름 컬렉션은 해당 명명 권한에 대한 로컬 핸들 네임스페이스를 정의합니다. 모든 로컬 이름은 해당 로컬 네임스페이스에서 고유해야 합니다. 명명 기관의 고유성과 해당 기관에 따른 로컬 이름은 핸들 시스템의 컨텍스트 내에서 모든 핸들이 전역적으로 고유함을 보장합니다.

예를 들어, "10.1045/january99-bearman"은 D-Lib 매거진에 게재된 기사에 대한 핸들입니다\[12\]. 해당 명명 권한은 "10.1045"이고 로컬 이름은 "january99-bearman"입니다. 핸들 네임스페이스는 많은 로컬 네임스페이스의 상위 집합으로 간주될 수 있으며, 각 로컬 네임스페이스는 핸들 시스템 아래에서 고유한 명명 권한을 갖습니다. 명명 기관은 연관된 핸들의 관리 생성 단위를 식별합니다\(반드시 계속 관리할 필요는 없음\). 각 명명 권한은 핸들 시스템 내에서 전역적으로 고유함을 보장합니다. 기존 로컬 네임스페이스는 고유한 명명 권한을 획득하여 전역 핸들 네임스페이스에 참여할 수 있으므로 네임스페이스 아래의 모든 로컬 이름은 위에 표시된 대로 명명 권한과 로컬 이름의 조합으로 전역적으로 참조될 수 있습니다.

핸들 시스템의 명명 권한은 트리 구조와 유사한 계층적 방식으로 정의됩니다. 트리의 각 노드와 리프에는 명명 권한 세그먼트에 해당하는 레이블이 제공됩니다. 상위 노드는 하위 노드의 상위 명명 기관에 알립니다. DNS와 달리 핸들 명명 기관은 왼쪽에서 오른쪽으로 구성되어 트리 루트의 레이블을 명명 기관을 나타내는 노드에 연결합니다. 각 레이블은 ASCII 문자 "."에 사용되는 옥텟으로 구분됩니다. \(0x2E\). 예를 들어, 미국 의회 도서관\("loc"\)의 국립 디지털 도서관 프로그램\("ndlp"\)에 대한 명명 권한은 "loc.ndlp"로 정의됩니다.

각 명명 기관에는 아래에 등록된 여러 하위 명명 기관이 있을 수 있습니다. 모든 하위 명명 기관은 상위 명명 기관이 등록된 후에만 상위 명명 기관에 의해 등록될 수 있습니다. 그러나 상위 및 하위 명명 기관이 나타내는 네임스페이스 간에는 본질적인 관리 관계가 없습니다. 상위 네임스페이스와 해당 하위

네임스페이스는 다양한 핸들 서비스에서 제공될 수 있으며 관리 권한을 공유하거나 공유하지 않을 수 있습니다.

핸들은 유니코드 v3.0 \[17\]에 의해 정의된 정확한 문자 세트인 ISO/IEC 10646의 범용 문자 세트\(UCS-2\)에서 인쇄 가능한 문자로 구성될 수 있습니다. UCS-2 문자 세트는 오늘날 작성된 모든 주요 언어에 사용되는 대부분의 문자를 포함합니다. 대부분의 기존 시스템과의 호환성을 허용하고 다양한 인코딩 간의 모호성을 방지하기 위해 핸들 시스템 프로토콜은 UTF-8을 핸들에 사용되는 유일한 인코딩으로 지정합니다. UTF-8 인코딩은 이름 충돌을 일으키지 않고 기존 시스템과 최대의 호환성을 허용하기 위해 ASCII로 인코딩된 이름을 보존합니다. 전역 네임스페이스에 대한 일부 인코딩 문제와 UTF-8 인코딩 선택은 \[13\]에서 논의됩니다.

기본적으로 핸들은 대소문자를 구분합니다. 그러나 개별 핸들 서비스는 해당 네임스페이스 아래 핸들 내의 ASCII 문자가 대소문자를 구분하지 않도록 네임스페이스를 정의할 수 있습니다.

---
## **4.  Handle System Architecture**

핸들 시스템은 계층적 서비스 모델을 정의합니다. 최상위 수준은 GHR\(Global Handle Registry\)이라는 단일 핸들 서비스로 구성됩니다. 하위 수준은 일반적으로 LHS\(로컬 핸들 서비스\)로 알려진 다른 모든 핸들 서비스로 구성됩니다.

전역 핸들 레지스트리를 사용하여 모든 핸들 네임스페이스를 관리할 수 있습니다. 모두 핸들로 관리되는 명명 권한을 관리하는 데 사용되는 서비스를 제공한다는 점에서 핸들 서비스 중에서 유일합니다. 명명 권한 핸들은 클라이언트가 명명 권한 아래 핸들에 대한 로컬 핸들 서비스에 액세스하고 활용하는 데 사용할 수 있는 정보를 제공합니다.

로컬 핸들 서비스는 특정 명명 기관 하에서 핸들에 대한 관리 책임이 있는 조직에서 호스팅하기 위한 것입니다. 로컬 핸들 서비스는 각각 고유한 명명 권한으로 식별되는 여러 로컬 핸들 네임스페이스를 담당할 수 있습니다. 로컬 핸들 서비스와 담당 로컬 핸들 네임스페이스 세트는 전역 핸들 레지스트리에 등록되어야 합니다.

핸들 시스템의 중요한 측면 중 하나는 분산 아키텍처입니다. 핸들 시스템은 전체적으로 다수의 개별 핸들 서비스로 구성됩니다. 이러한 각 서비스는 하나 이상의 서비스 사이트로 구성될 수 있습니다. 각 서비스 사이트는 핸들 확인 측면에서 서비스의 다른 모든 사이트를 완전히 복제합니다. 각 서비스 사이트는 하나 이상의 핸들 서버로 구성될 수 있습니다. 지정된 서비스 사이트로 전달되는 모든 핸들과 그에 따른 모든 핸들 요청은 이러한 핸들 전체에 고르게 분산됩니다.

서버. 핸들 시스템 전체는 다양한 핸들 서비스로 구성될 수 있습니다. 핸들 서비스 수 또는 각 서비스를 구성하는 사이트 수에는 설계 제한이 없으며 각 사이트를 구성하는 서버 수에도 제한이 없습니다. 서비스 사이트 간의 복제에서는 각 사이트에 동일한 수의 서버가 포함될 필요가 없습니다. 즉, 각 사이트에는 동일한 복제된 핸들 세트가 있지만 각 사이트는 해당 핸들 세트를 다른 수의 서버에 할당할 수 있습니다. 이 분산 접근 방식은 확장성을 지원하고 대규모 작업을 수용하며 단일 지점 오류 문제를 완화하기 위한 것입니다.

그림 3.1은 두 개의 서비스 사이트로 구성된 잠재적인 핸들 서비스를 보여줍니다. 하나는 미국 동부 해안에 있고 다른 하나는 미국 서부 해안에 있습니다. 동해안 서비스 현장은 서버 컴퓨터 4대로 구성되어 있습니다. 더 강력한 컴퓨터를 배포한 서해안 서비스 사이트에서는 두 대의 서버로 충분하다고 결정했습니다. 모든 핸들 서비스에 대한 서비스 사이트 수와 서비스 사이트에서 사용되는 서버 수는 서비스 요구 사항에 따라 동적으로 추가되거나 제거될 수 있습니다.

```text
       -------------------------              ------------------
      |  ---------   ---------  |            |  -----    -----  |
      | |         | |         | |            | |  S  |  |  S  | |
      | | server1 | | server2 | |            | |  E  |  |  E  | |
      | |         | |         | |            | |  R  |  |  R  | |
      |  ---------   ---------  |            | |  V  |  |  V  | |
      |  ---------   ---------  |            | |  E  |  |  E  | |
      | |         | |         | |            | |  R  |  |  R  | |
      | | Server3 | | Server4 | |            | |     |  |     | |
      | |         | |         | |            | |  1  |  |  2  | |
      |  ---------   ---------  |            |  -----    -----  |
       -------------------------               ------------------

         Handle Service Site 1                Handle Service Site 2
            (US East Coast)                     (US West Coast)

       Figure 3.1: Handle service configured with two service sites
```

각 핸들 서비스는 핸들 시스템 아래에서 고유한 하위 네임스페이스를 관리합니다. 서로 다른 핸들 서비스의 네임스페이스는 중복될 수 없습니다. 하위 네임스페이스는 일반적으로 여러 명명 권한 아래의 핸들로 구성됩니다. 핸들 서비스는 이러한 명명 기관의 "홈" 서비스라고 하며 이러한 명명 기관에서 핸들에 대한 확인 및 관리 서비스를 제공하는 유일한 서비스입니다. 핸들을 확인하기 전에 클라이언트는 해당 핸들의 "홈" 서비스를 결정해야 합니다. 각 핸들의 "홈" 서비스는 해당 이름 지정 기관의 "홈" 서비스이며

Global Handle Registry에 등록되었습니다. 클라이언트는 전역 핸들 레지스트리에서 명명 기관 핸들을 쿼리하여 각 핸들에 대한 "홈" 서비스를 찾을 수 있습니다.

전역 핸들 레지스트리는 명명 권한 핸들을 유지 관리합니다. 각 명명 기관 핸들은 명명 기관의 "홈" 서비스를 설명하는 서비스 정보를 유지 관리합니다. 서비스 정보에는 해당 핸들 서비스의 서비스 사이트와 각 사이트 내의 각 핸들 서버에 대한 인터페이스가 나열됩니다. 임의의 핸들에 대한 "홈" 서비스를 찾기 위해 클라이언트는 해당 명명 권한 핸들과 연관된 서비스 정보에 대해 전역 핸들 레지스트리를 쿼리할 수 있습니다. 서비스 정보는 클라이언트가 "홈" 서비스와 통신하는 데 필요한 정보를 제공합니다.

그림 3.2는 일반적인 핸들 확인 프로세스의 예를 보여줍니다. 이 경우 "홈" 서비스는 로컬 핸들 서비스입니다. 클라이언트는 "10.1045/july95-arms" 핸들을 확인하려고 시도하고 있으며 전역 핸들 레지스트리에서 "홈" 서비스를 찾아야 합니다. "home" 서비스는 "10.1045"에 대한 명명 권한 핸들에 대한 쿼리를 전역 핸들 레지스트리에 보내면 찾을 수 있습니다. 전역 핸들 레지스트리는 이름 지정 권한 "10.1045"에서 핸들을 담당하는 로컬 핸들 서비스의 서비스 정보를 반환합니다. 서비스 정보를 통해 클라이언트는 로컬 핸들 서비스와 통신하여 "10.1045/july95-arms" 핸들을 확인할 수 있습니다.

```text
       ------------------------
      |                        |    4. Result of client request
      | Client with global     |  <-------------------------------.
      |  service information   |                                  |
      |                        |  ----------------------------.   |
       ------------------------     3. Request to responsible |   |
                 |   ^                 Local Handle Service   |   |
     1. Client   |   |                                        |   |
     query for   |   |                                        |   |
     naming      |   | 2. Service information                 |   |
     authority   |   |    for "10.1045"                       V   |
     "10.1045"   |   |                          ----------------------
                 |   |                         |                      |
                 V   |                         | Local Handle Service |
            ---------------                    | responsible for the  |
           |               |                   | naming authority     |
           | Global Handle |                   | "10.1045"            |
           |   Registry    |                   |                      |
           |               |                    ----------------------
            ---------------
```

- 그림 3.2: 전역으로 시작하는 처리 해결

해결 성능을 향상시키기 위해 모든 클라이언트는 전역 핸들 레지스트리에서 반환된 서비스 정보를 캐시하고 후속 쿼리에 사용하도록 선택할 수 있습니다. 독립형 또는 일반 캐싱 메커니즘의 일부로 별도의 핸들 캐싱 서버를 사용하여 로컬 커뮤니티 내에서 공유 캐싱을 제공할 수도 있습니다. 캐시된 확인 결과가 주어지면 동일한 핸들에 대한 후속 쿼리는 핸들 서비스에 연결하지 않고도 로컬로 응답될 수 있습니다. 캐시된 서비스 정보가 제공되면 클라이언트는 전역 핸들 레지스트리에 접속하지 않고도 올바른 로컬 핸들 서비스에 직접 요청을 보낼 수 있습니다.

---
## **5.  Handle System Security**

핸들 시스템은 공용 인터넷과 같은 네트워크를 통해 핸들 확인 및 관리 서비스를 제공합니다. 각 핸들에는 값 세트가 할당될 수 있습니다. 클라이언트는 핸들 확인 서비스를 사용하여 모든 핸들을 값 집합으로 확인합니다. 각 값에는 데이터 유형과 고유 값 인덱스가 있습니다. 클라이언트는 데이터 유형이나 값 인덱스를 기반으로 특정 핸들 값을 쿼리할 수 있습니다.

핸들 관리 서비스는 클라이언트의 핸들 관리 요청에 응답합니다. 여기에는 핸들 추가, 핸들 삭제 또는 해당 값 업데이트가 포함됩니다. 또한 명명 권한 핸들을 통해 명명 권한을 관리합니다. 각 핸들에는 자체 관리자가 있을 수 있으며 각 관리자에게는 특정 권한 집합이 부여될 수 있습니다.

핸들 시스템 인증 프로토콜은 관리 요청을 이행하기 전에 핸들 관리자를 인증합니다.

핸들 시스템은 클라이언트 및 서버 인증, 데이터 기밀성 및 무결성, 부인 방지 등의 보안 서비스를 제공합니다. 기본적으로 핸들 확인에는 클라이언트 인증이 필요하지 않습니다. 그러나 관리자가 핸들에 할당한 기밀 데이터에 대한 해결 요청과 관리 요청\(예: 핸들 값 추가 또는 삭제\)에는 적절한 권한 부여를 위해 클라이언트의 인증이 필요합니다. 서버는 권한 부여 프로세스 중에 클라이언트가 해당 기밀 핸들 값에 액세스할 수 있는 권한이 있는지 또는 핸들과 핸들 값을 추가하거나 업데이트할 수 있는 권한이 있는지 여부를 결정합니다. 인증이 필요한 경우 핸들 서버는 클라이언트의 요청을 수행하기 전에 요청하는 클라이언트에 챌린지를 발행합니다. 인증 요구 사항을 충족하려면 클라이언트는 자격을 갖춘 관리자임을 식별하는 올바른 응답을 다시 보내야 합니다. 핸들 서버는 클라이언트 인증이 성공한 후에만 초기 요청에 응답합니다. 핸들 클라이언트는 인증을 위해 비밀 키 또는 공개 키 암호화를 사용하도록 선택할 수 있습니다. 핸들 시스템 인증은 제3자 인증 서비스를 통해서도 수행될 수 있습니다. 데이터 무결성을 보장하기 위해 클라이언트는 모든 핸들 서버에서 디지털 서명된 응답을 요청할 수 있습니다. 또한 세션 키를 사용하여 교환된 모든 정보를 암호화할 수 있도록\(데이터 기밀 유지를 위해\) 핸들 서버와의 보안 통신 세션을 설정할 수도 있습니다. 핸들 서버는 핸들 데이터를 클라이언트에 보내기 전에 암호화하여 기밀성을 제공할 수도 있습니다.

핸들 시스템은 클라이언트와 서버 간의 안전한 정보 교환을 위한 서비스 옵션을 제공합니다. 물론 이것이 핸들 값의 진실성을 보장하지는 않습니다. 관리자가 핸들에 잘못된 값을 할당하면 클라이언트가 오해할 수 있습니다. 반면 핸들 값에는 추가 자격 증명을 제공하기 위해 다른 핸들 값에 대한 참조가 포함될 수 있습니다. 예를 들어 핸들 값 R\(예: 클레임\)에는 값 R에 대한 디지털 서명\(신뢰할 수 있는 소스의\)을 포함하는 다른 핸들 값에 대한 참조가 포함될 수 있습니다. 서명을 신뢰하는 클라이언트는 핸들 값 R을 신뢰할 수 있습니다. .

---
## **6.  The Handle System and other Internet Services**

설계 또는 의도에 따라 핸들 시스템에 대해 제안된 일부 기능을 다루는 기존 및 제안된 인터넷 식별자 서비스 또는 사양이 많이 있습니다. 이 섹션에서는 핸들 시스템과 관련하여 간략하게 검토합니다.

---
### **6.1.  Domain Name Service (DNS)**

도메인 이름 서비스\(DNS\)는 원래 설계되었으며 네트워크 라우팅 목적으로 도메인 이름을 IP 주소에 매핑하는 데 많이 사용됩니다. RFC 1034 \[2\] 및 RFC 1035 \[3\]은 설계 및 구현에 대한 자세한 설명을 제공합니다. 인터넷의 성장으로 인해 DNS에 대한 다양한 확장에 대한 요구가 증가했으며, 심지어는 범용 리소스 명명 시스템으로도 사용할 수 있게 되었습니다. 그러나 이러한 사용으로 인해 네트워크 주소 변환 속도가 느려지거나 네트워크 라우팅 효율성에 영향을 미칠 가능성이 있습니다. DNS 구현은 일반적으로 많은 양의 데이터가 특정 DNS 이름과 연결되어 있는 경우 확장이 잘 되지 않습니다. 따라서 일반적으로 DNS를 범용 이름 지정 서비스로 사용하는 것은 부적절한 것으로 간주됩니다.

DNS를 범용 이름 지정 서비스로 사용하는 것을 반대하는 또 다른 요소는 DNS 관리 모델입니다. DNS 이름은 일반적으로 DNS 영역 수준에서 네트워크 관리자가 관리합니다. 이름별 관리 구조에 대한 규정은 없습니다. 네트워크 관리자 이외의 다른 사람이 DNS 이름을 생성하거나 관리할 수 있는 기능은 제공되지 않습니다. 이는 도메인 이름 관리에는 적합하지만 범용 이름 관리에는 적합하지 않습니다.

핸들 시스템은 분산 관리, 서비스 모델, 보안 기능 측면에서 DNS와 다릅니다. 핸들 시스템 프로토콜에는 데이터 전송 중 기밀성과 무결성을 보장하는 보안 옵션이 포함되어 있습니다. 각 핸들에는 서버 관리자와는 별개로 자체 관리자가 있을 수 있습니다. 핸들 시스템 프로토콜을 사용하면 모든 핸들 관리자가 공용 네트워크를 통해 자신의 핸들을 안전하게 관리할 수 있습니다. 또한 핸들 시스템 서비스 모델을 사용하면 모든 서비스 사이트에서 증가된 서비스 요청을 수용하기 위해 서버 클러스터 간의 서비스 배포를 동적으로 구성할 수 있습니다. 또한 임의로 많은 수의 핸들을 지원하기 위해 성능이 떨어지는 컴퓨터를 함께 사용할 수도 있습니다.

---
### **6.2.  Directory Services (X.500/LDAP)**

X.500\[6\]은 ISO와 ITU에서 정의한 OSI 디렉토리 표준입니다. 이는 "사람의 전화번호나 X.400 O/R 주소를 반환하는 화이트 페이지 서비스를 제공"하도록 설계되었으며 "주로 OSI\(개방형 시스템 상호 연결\) ​​응용 프로그램에 대한 이름 서버 서비스 제공에 관심이 있습니다" \[ 7\]. X.500은 전역 이름 조회 및 검색을 허용하는 일련의 프로토콜을 사용하여 계층적 데이터 및 정보 모델을 정의합니다. 그러나 이 프로토콜은 구현하기 어려운 것으로 입증되었으며 "클라이언트 액세스를 기존 프로토콜에 통합하는 데 어려움이 있었습니다."

제품" \[14\]. LDAP\(Lightweight Directory Access Protocol\) \[8\]은 프로토콜을 더 간단하고 쉽게 구현할 수 있도록 하여 이러한 많은 어려움을 극복했습니다. 그러나 LDAP가 로컬 디렉토리 액세스 프로토콜\( LDAP v2\)를 분산 서비스 프로토콜\(LDAP v3\)로 변환하면 원래 설계에서 해결되지 않은 많은 문제에 직면하여 새로운 복잡성이 발생합니다.

핸들 시스템과 같은 이름 확인 서비스와 LDAP와 같은 디렉터리 서비스 간의 근본적인 차이점은 검색 기능입니다. 디렉토리 서비스를 검색할 수 있는 추가된 기능은 필연적으로 복잡성을 증가시켜 효율성에 영향을 미칩니다. 핸들 시스템과 같은 순수 이름 서비스는 불완전한 기준에 따라 알 수 없는 항목을 검색하는 데 필요한 기능 및 데이터 구조를 처리하지 않고 알려진 항목의 효율적인 해결을 중심으로만 설계될 수 있습니다.

역방향 조회 서비스를 제공하기 위해 LDAP 또는 WHOIS++\[15,16\]과 같은 디렉토리 서비스를 핸들 시스템과 함께 사용할 수 있습니다. 예를 들어 기존 기업 디렉토리 서비스는 두 서비스 모두에 대한 인터페이스를 제공할 수 있습니다. 핸들 시스템 인터페이스는 매우 효율적인 이름 확인 서비스를 제공합니다. 디렉토리 서비스 인터페이스는 확장된 검색 기능을 제공합니다. 핸들은 LDAP 서비스 조회에도 사용될 수 있습니다. 예를 들어, LDAP 서비스는 핸들로 참조될 수 있습니다. 그렇게 하면 위치 변경과 관계없이 참조가 초과 근무 시간 동안 지속됩니다.

---
### **6.3.  Uniform Resource Identifier (URI)/Uniform Resource Name(URN)**

URI\(Uniform Resource Identifier\) ​​\[23\]는 웹 애플리케이션에서 인터넷 리소스를 식별하기 위한 균일하면서도 확장 가능한 명명 메커니즘을 정의합니다. URI의 하위 집합인 URN\(Uniform Resource Name\) \[11\]은 URI 아래의 영구 네임스페이스에 대한 네임스페이스 등록 메커니즘을 정의합니다. URI/URN은 웹 애플리케이션에 사용되는 대부분의 인터넷 이름 서비스를 나타냅니다. 이 섹션에서는 핸들 시스템과 URI/URN의 관계 및 애플리케이션이 URI/URN 컨텍스트 내에서 핸들 시스템을 활용하는 방법에 대해 설명합니다.

핸들 시스템은 인터넷에 범용 이름 서비스를 제공합니다. DNS 또는 X.500 디렉터리 서비스와 마찬가지로 핸들 시스템은 URI/URN 네임스페이스 외부에 네임스페이스를 정의합니다. URI/URN 체계를 접두사로 사용하지 않고도 핸들을 직접 기록하고 확인할 수 있습니다. 예를 들어, 라이브러리 애플리케이션은 "10.1045/july95-arms" 핸들을 해당 핸들 값 세트로 직접 확인할 수 있습니다. 이 경우에는 URI/URN 체계가 필요하지 않습니다.

핸들 시스템은 영구 이름 서비스가 필요한 응용 프로그램에 사용될 수 있습니다. 핸들 시스템은 영구 이름을 핸들로 등록하는 데 필요한 메커니즘을 제공합니다.

지속되도록 설계된 핸들을 호스팅하기 위해 특정 명명 기관을 정의할 수 있습니다. 그러나 핸들의 지속성은 기술 자체보다는 관리 정책에 더 많이 좌우됩니다. 이러한 정책은 이 문서 세트에 설명된 핸들 시스템 서비스 범위를 벗어납니다.

반면에 핸들 시스템은 영구 이름이 필요하지 않은 응용 프로그램에도 사용할 수 있습니다. 이러한 핸들은 수명이 짧을 수 있으며 서로 다른 시간에 서로 다른 개체를 식별하는 데 사용될 수도 있습니다.

핸들 시스템을 기본 이름 서비스로 사용하여 다양한 웹 애플리케이션을 개발할 수 있습니다. 이러한 각 애플리케이션은 해당 애플리케이션 요구 사항에 맞게 고유한 URI/URN 네임스페이스를 정의할 수 있습니다. 예를 들어 애플리케이션 FOO에는 웹에서 FOO 서비스를 식별하기 위해 등록된 URI 네임스페이스 "foo:"가 있을 수 있습니다. 그 동안 애플리케이션 BAR에는 영구 이름이 필요한 BAR 개체를 식별하기 위해 등록된 URN 네임스페이스 "URN:BAR"이 있을 수 있습니다. FOO 및 BAR 애플리케이션 모두 서비스 및/또는 객체의 이름을 지정하고 해석하는 데 핸들\(해당 이름 지정 권한에 따라\)을 사용할 수 있습니다. 이는 DNS 서비스를 사용하는 다양한 응용 프로그램에 대해 정의된 다양한 URI 체계\(예: "telnet", "ftp", "mailto" 등\)가 있는 DNS에서도 비슷합니다.

IETF와 IRTF는 URI 관련 작업 영역에서 핸들 시스템에 대해 논의했습니다. 핸들 시스템이 특정 URI 또는 ​​URN 네임스페이스에 적합한지에 대해서는 다양한 의견이 있습니다. 인터넷의 다른 기존 이름 서비스와 관련하여 핸들 시스템이 어디에 적합한지에 대한 우려도 있습니다. 그러한 논의는 이 문서의 범위를 벗어납니다.

---
## **7.  Security Considerations**

이 섹션은 핸들 시스템의 보안 제한 사항과 애플리케이션 개발자, 서비스 제공자 및 핸들 시스템 클라이언트가 취해야 하는 예방 조치를 사람들에게 알리기 위한 것입니다. 핸들 시스템 프로토콜\[21\]과 해당 데이터 및 서비스 모델\[22\]에 관한 특정 보안 고려 사항은 별도의 문서에서 다룹니다.

---
### **7.1.  General Security Practice**

핸들 시스템의 보안은 트랜잭션의 모든 단계에서 클라이언트와 서버 호스트 보안에 따라 달라집니다. 이는 클라이언트 호스트가 변조되지 않았으며 클라이언트 소프트웨어가 수신된 데이터를 클라이언트에 안정적으로 전달할 것이라고 가정합니다. 모든 핸들 서비스의 클라이언트는 관련된 모든 핸들 서버가 손상되지 않았다고 가정해야 합니다. 전역 핸들 레지스트리를 신뢰하는 것은

글로벌 핸들 레지스트리가 클라이언트 요청을 책임 있는 로컬 핸들 서비스로 올바르게 전달할 것이라고 믿습니다. 로컬 핸들 서비스를 신뢰한다는 것은 로컬 핸들 서비스가 관리자가 핸들에 할당한 데이터를 올바르게 반환할 것이라고 믿는 것입니다. 로컬 핸들 서비스는 일반적으로 일련의 명명 권한을 지원합니다. 따라서 로컬 핸들 서비스를 신뢰한다는 것은 해당 명명 기관을 신뢰한다는 것을 의미합니다.

핸들 시스템의 무결성은 글로벌 서비스 정보의 무결성에 크게 좌우됩니다. 잘못된 글로벌 서비스 정보로 인해 클라이언트가 부적절한 로컬 핸들 서비스로 오해될 수 있습니다. 또한 공격자가 서버 서명을 위조할 수도 있습니다. 글로벌 핸들 레지스트리는 글로벌 서비스 정보와 글로벌 서비스 정보 서명에 사용되는 공개 키 쌍을 보호하는 데 극도의 주의를 기울여야 합니다. 클라이언트 애플리케이션은 전역 핸들 레지스트리의 전역 서비스 정보만 허용해야 합니다. 업데이트할 때마다 무결성을 확인해야 합니다.

효율성상의 이유로 핸들 서버는 클라이언트가 특별히 요청하지 않는 한 모든 서비스 응답에 대해 디지털 서명을 생성하거나 반환하지 않습니다. 데이터 무결성을 보장하려면 클라이언트는 서버에 디지털 서명을 반환하도록 명시적으로 요청해야 합니다. 민감한 데이터가 노출되지 않도록 보호하기 위해 클라이언트는 서버와의 통신 세션을 설정하고 세션 키를 사용하여 모든 데이터를 암호화하도록 서버에 요청할 수 있습니다.

---
### **7.2.  Privacy Protection**

기본적으로 핸들 시스템에 저장된 대부분의 핸들 데이터는 핸들 관리자가 달리 지정하지 않는 한 공개적으로 액세스할 수 있습니다. 핸들 관리자는 개인 정보가 포함된 핸들 값을 추가할 때 주의해야 합니다. 이러한 핸들 값은 핸들 관리자만 읽을 수 있도록 표시하거나 암호화된 핸들 값으로 저장하여 통제된 대상 내에서만 읽을 수 있도록 선택할 수 있습니다.

핸들 서버에서 생성된 로그 파일은 클라이언트 개인 정보가 공격을 받을 수 있는 또 다른 취약 지점입니다. 핸들 서버 운영자는 이러한 정보를 주의 깊게 보호해야 합니다.

---
### **7.3.  Caching and Proxy Servers**

성능 향상 및 기타 부가 가치 서비스 외에도 프록시 서버와 캐싱 서버는 모두 중간자 역할을 하므로 중간자 공격에 취약합니다. 프록시 및 캐싱 서버는 핸들 서비스의 일부가 아니라는 점을 아는 것이 중요합니다. 이들은 핸들 시스템의 클라이언트입니다. 프록시 및 캐싱 서버의 서비스 응답은 핸들을 통해 인증될 수 없습니다.

시스템 프로토콜. 클라이언트와 직접 프록시/캐싱 서버 간의 신뢰는 통신 경로 중간에 있는 프록시/캐싱 서버 수에 관계없이 독립적으로 설정되어야 합니다.

클라이언트는 프록시 및 캐싱 서버를 사용하여 서버가 콘텐츠를 잘못 처리하지 않고 요청을 제출하고 핸들 시스템의 응답을 중계할 것이라고 가정합니다. 또한 그들은 서버가 자신을 대신하여 민감한 정보를 보호할 것이라고 가정합니다.

프록시 및 캐싱 서버 운영자는 민감한 정보를 포함하거나 전송하는 시스템을 보호하는 것과 마찬가지로 해당 서버가 실행되는 시스템을 보호해야 합니다. 특히, 프록시에서 수집된 로그 정보에는 매우 민감한 개인정보나 조직에 대한 정보가 포함되어 있는 경우가 많습니다. 그러한 정보는 주의 깊게 보호되어야 하며, 그 사용에 대한 적절한 지침을 개발하고 따라야 합니다.

캐싱 서버는 캐시의 콘텐츠가 악의적인 악용의 대상이 되기 때문에 추가적인 잠재적 취약성을 제공합니다. 캐시에 대한 잠재적인 공격은 핸들 사용자의 개인 데이터 또는 사용자가 네트워크에서 제거되었다고 믿는 후에도 계속 유지되는 정보를 노출시킬 수 있습니다. 따라서 캐시 내용은 민감한 정보로 보호되어야 합니다.

---
### **7.4.  Mirroring**

핸들 시스템 클라이언트는 미러링 사이트 간의 콘텐츠 복제 시 발생할 수 있는 지연을 인식해야 합니다. 시간에 민감한 데이터에 대해서는 기본 서비스 사이트에 요청을 보내는 것을 고려해야 합니다. 서비스 관리자는 미러링 사이트를 신중하게 선택해야 합니다. 각 미러링 사이트는 데이터 무결성을 보장하기 위해 동일한 보안 절차를 따라야 합니다. 미러링 사이트 간의 데이터 일관성을 보장하기 위해 소프트웨어 도구가 적용될 수 있습니다.

---
### **7.5.  Denial of Service (DoS)**

모든 공공 서비스와 마찬가지로 핸들 시스템은 서비스 거부 공격을 받기 쉽습니다. 현재 기술에서는 이러한 공격으로부터 보호할 수 있는 일반적인 솔루션이 없습니다. 이러한 공격을 인식하고 공격이 발생하면 관리자에게 알리도록 서버 구현을 개발할 수 있습니다. 상태 비저장 쿠키\[19, 20\]는 인증, 무결성 및 암호화 서비스를 수행하는 호스트에 대한 DoS 공격의 일부 영향을 완화하는 수단 중 하나입니다. 섬기는 사람

더욱이, 구현 시 DoS 방지 기술을 포함한 새로운 보안 기술을 활용하려면 업그레이드가 가능해야 합니다.

---
## **8.  History of the Handle System**

핸들 시스템은 원래 CNRI에서 전체 디지털 객체 아키텍처의 일부로 구상 및 개발되었습니다. 최초의 공개 구현은 David Ely의 주도로 1994년 가을 CNRI에서 이루어졌습니다. 핸들 시스템을 포함한 전체 디지털 객체 아키텍처는 나중에 1995년 Robert Kahn과 Robert Wilensky의 논문에서 설명되었습니다. \[1\] 국방부가 자금을 지원하는 컴퓨터 과학 기술 보고서\(CSTR\) 프로젝트의 일환으로 CNRI에서 개발이 계속되었습니다. 승인 번호 MDA-972-92-J-1029 및 MDA-972-99-1-0018에 따른 Advanced Projects Agency\(DARPA\). NCSTRL\(Networked Computer Science Technical Reference Library\) \[18\] 및 관련 활동의 발전에 주요 요인이기도 한 이 초기 디지털 도서관 프로젝트의 한 측면은 디지털 도서관의 기본 인프라를 위한 프레임워크를 개발하는 것이었습니다.

핸들 시스템의 초기 채택자에는 미국 의회 도서관, DTIC\(국방 기술 정보 센터\) 및 IDF\(국제 DOI 재단\)가 포함되었습니다. 위에서 언급한 NCSTRL, 기타 디지털 도서관 프로젝트 및 관련 IETF 노력뿐만 아니라 이러한 조직의 피드백은 모두 핸들 시스템의 발전에 기여했습니다. 클라이언트와 서버 모두에 대한 현재 상태와 사용 가능한 소프트웨어는 http://www.handle.net에서 확인할 수 있습니다.

---
## **9.  Acknowledgements**

이 작업은 핸들 시스템 구현의 이전 버전에서 파생되었습니다. 디자인 아이디어는 David Ely, Charles Orth, Allison Yu, Sean Reilly, Jane Euler, Catherine Rey, Stephanie Nguyen, Jason Petrone 및 Helen She를 포함하여 핸들 시스템 개발 팀 내에서 논의된 내용을 기반으로 합니다. 이 작업에 대한 그들의 기여에 감사드립니다.

저자들은 또한 Russ Housley\(housley@vigilsec.com\), Ted Hardie\(hardie@qualcomm.com\) 및 Mark Baugher\(mbaugher@cisco.com\)에게 광범위한 검토와 의견은 물론 다른 회원으로부터 받은 추천에도 감사드립니다. IETF/IRTF 커뮤니티.

---
## **10.  References and Bibliography**

\[1\] Kahn, R. 및 R. Wilensky, "분산형 디지털 개체 서비스를 위한 프레임워크", D-Lib Magazine, 1995.

\[2\] Mockapetris, P., "도메인 이름 - 개념 및 시설", STD 13, RFC 1034, 1987년 11월.

\[3\] Mockapetris, P., "도메인 이름 - 구현 및

- 사양", STD 13, RFC 1035, 1987년 11월.

\[4\] Berners-Lee, T., Masinter, L. 및 M. McCahill, "Uniform Resource Locators\(URL\)", RFC 1738, 1994년 12월.

\[5\] Yergeau, F., "UTF-8, 유니코드 및 ISO 10646의 변환 형식", RFC 2044, 1996년 10월.

\[6\] ITU-T 권고. X.500, "디렉토리: 개념, 모델 및 서비스 개요", 1993.

\[7\] D. W. Chadwick, "X.500 이해 - 디렉토리", Chapman & Hall ISBN: 0-412-43020-7.

\[8\] Wahl, M., Howes, T. 및 S. Kille, "경량 디렉터리 액세스 프로토콜\(v3\)", RFC 2251, 1997년 12월.

\[9\] Sollins, K. 및 L. Masinter, "Uniform Resource Names에 대한 기능 요구 사항", RFC 1737, 1994년 12월.

\[10\] Sollins, K. "Uniform Resource Name Resolution의 아키텍처 원칙", RFC 2276, 1998년 1월.

```text
   [11] IETF Uniform Resource Names (URN) Working Group, April 1998.

   [12] D-Lib Magazine, http://www.dlib.org
```

\[13\] Sam X. Sun, "핸들 시스템의 국제화 - 지속적인 글로벌 이름 서비스", 제12회 국제 유니코드 컨퍼런스 진행, 1998년 4월.

```text
   [14] D. Goodman, C. Robbins, "Understanding LDAP & X.500", August
        1997.
```

\[15\] Deutsch P., Schoultz R., Faltstrom P. 및 C. Weider,

- "WHOIS++ 서비스 아키텍처", RFC 1835, 1995년 8월.

\[16\] Weider, C., Fullton, J. 및 S. Spero, "Whois++ 인덱스 서비스 아키텍처", RFC 1913, 1996년 2월.

\[17\] 유니코드 컨소시엄, "유니코드 표준 버전 v3.0", Addison-Wesley Pub Co; ISBN: 0201616335.

```text
   [18] The Networked Computer Science Technical Reports Library
        (NCSTRL), http://www.ncstrl.org/
```

\[19\] Karn, P. 및 W. Simpson, "Photuris: 세션 키 관리 프로토콜", RFC 2522, 1999년 3월.

\[20\] Harkins, D. 및 D. Carrel, "인터넷 키 교환\(IKE\)", RFC 2409, 1998년 11월.

\[21\] Sun, S., Reilly, S. 및 L. Lannom, "시스템 네임스페이스 및 서비스 정의 처리", RFC 3651, 2003년 11월.

\[22\] Sun, S., Reilly, S., Lannom, L. 및 J. Petrone, "핸들 시스템 프로토콜\(버전 2.1\) 사양", RFC 3652, 2003년 11월.

\[23\] Berners-Lee, T., Fielding, R. 및 L. Masinter, "URI\(Uniform Resource Identifier\): 일반 구문", RFC 2396, 1998년 8월.

---
## **11.  Authors' Addresses**

Sam X. Sun Corporation for National Research Initiatives\(CNRI\) 1895 Preston White Dr., Suite 100 Reston, VA 20191

```text
   Phone: 703-262-5316
   EMail: ssun@cnri.reston.va.us
```

CNRI\(국가 연구 계획을 위한 Larry Lannom Corporation\) 1895 Preston White Dr., Suite 100 Reston, VA 20191

```text
   Phone: 703-620-8990
   EMail: llannom@cnri.reston.va.us
```

CNRI\(National Research Initiatives\)를 위한 Brian Boesch Corporation 1895 Preston White Dr., Suite 100 Reston, VA 20191

```text
   Phone: 703-262-5316
   EMail: bboesch@cnri.reston.va.us
```

---
## **12.  Full Copyright Statement**

저작권\(C\)인터넷학회\(2003\). 판권 소유.

이 문서와 그 번역본은 복사되어 타인에게 제공될 수 있으며, 이에 대해 설명하거나 설명하거나 구현을 지원하는 파생물은 어떤 종류의 제한 없이 전체적으로 또는 부분적으로 준비, 복사, 출판 및 배포될 수 있습니다. , 단, 위의 저작권 표시와 이 단락은 그러한 모든 사본 및 파생물에 포함됩니다. 그러나 이 문서 자체는 인터넷 표준 개발 목적으로 필요한 경우를 제외하고는 저작권 표시를 제거하거나 Internet Society 또는 기타 인터넷 조직에 대한 참조를 제거하는 등 어떤 식으로든 수정할 수 없습니다. 인터넷 표준 프로세스를 따르거나 영어 이외의 언어로 번역하는 데 필요한 대로 따라야 합니다.

위에 부여된 제한된 권한은 영구적이며 Internet Society나 그 승계자 또는 양수인에 의해 취소되지 않습니다.

이 문서와 여기에 포함된 정보는 "있는 그대로" 제공되며 인터넷 사회 및 인터넷 공학 태스크포스는 여기에 포함된 정보의 사용이 상품성 또는 특정 목적에의 적합성에 대한 권리 또는 묵시적 보증을 침해하는 행위.

---
# **Acknowledgement**

RFC 편집기 기능에 대한 자금은 현재 Internet Society에서 제공하고 있습니다.
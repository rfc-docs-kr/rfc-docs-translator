

```text
﻿

Internet Engineering Task Force (IETF)                   J. Iyengar, Ed.
Request for Comments: 9002                                        Fastly
Category: Standards Track                                  I. Swett, Ed.
ISSN: 2070-1721                                                   Google
                                                                May 2021
```

- QUIC 손실 감지 및 혼잡 제어

---
# **Abstract**

이 문서에서는 QUIC의 손실 감지 및 혼잡 제어 메커니즘에 대해 설명합니다.

---
# **Status of This Memo**

이것은 인터넷 표준 추적 문서입니다.

이 문서는 IETF\(Internet Engineering Task Force\)의 제품입니다. 이는 IETF 커뮤니티의 합의를 나타냅니다. 공개 검토를 받았으며 IESG\(Internet Engineering Steering Group\)의 출판 승인을 받았습니다. 인터넷 표준에 대한 자세한 내용은 RFC 7841의 섹션 2에서 확인할 수 있습니다.

이 문서의 현재 상태, 정오표, 피드백 제공 방법에 대한 정보는 https://www.rfc-editor.org/info/rfc9002에서 얻을 수 있습니다.

---
# **Copyright Notice**

Copyright \(c\) 2021 IETF Trust 및 문서 작성자로 확인된 사람. 판권 소유.

이 문서는 이 문서의 발행일에 유효한 BCP 78 및 IETF 문서에 관한 IETF 트러스트의 법적 조항\(https://trustee.ietf.org/license-info\)의 적용을 받습니다. 이 문서와 관련된 귀하의 권리 및 제한 사항을 설명하므로 이 문서를 주의 깊게 검토하십시오. 이 문서에서 추출한 코드 구성 요소는 Trust Legal Provisions의 섹션 4.e에 설명된 대로 Simplified BSD License 텍스트를 포함해야 하며 Simplified BSD License에 설명된 대로 보증 없이 제공됩니다.

---
# **Table of Contents**

```text
   1.  Introduction
   2.  Conventions and Definitions
   3.  Design of the QUIC Transmission Machinery
   4.  Relevant Differences between QUIC and TCP
     4.1.  Separate Packet Number Spaces
     4.2.  Monotonically Increasing Packet Numbers
     4.3.  Clearer Loss Epoch
     4.4.  No Reneging
     4.5.  More ACK Ranges
     4.6.  Explicit Correction for Delayed Acknowledgments
     4.7.  Probe Timeout Replaces RTO and TLP
     4.8.  The Minimum Congestion Window Is Two Packets
     4.9.  Handshake Packets Are Not Special
   5.  Estimating the Round-Trip Time
     5.1.  Generating RTT Samples
     5.2.  Estimating min_rtt
     5.3.  Estimating smoothed_rtt and rttvar
   6.  Loss Detection
     6.1.  Acknowledgment-Based Detection
       6.1.1.  Packet Threshold
       6.1.2.  Time Threshold
     6.2.  Probe Timeout
       6.2.1.  Computing PTO
       6.2.2.  Handshakes and New Paths
       6.2.3.  Speeding up Handshake Completion
       6.2.4.  Sending Probe Packets
     6.3.  Handling Retry Packets
     6.4.  Discarding Keys and Packet State
   7.  Congestion Control
     7.1.  Explicit Congestion Notification
     7.2.  Initial and Minimum Congestion Window
     7.3.  Congestion Control States
       7.3.1.  Slow Start
       7.3.2.  Recovery
       7.3.3.  Congestion Avoidance
     7.4.  Ignoring Loss of Undecryptable Packets
     7.5.  Probe Timeout
     7.6.  Persistent Congestion
       7.6.1.  Duration
       7.6.2.  Establishing Persistent Congestion
       7.6.3.  Example
     7.7.  Pacing
     7.8.  Underutilizing the Congestion Window
   8.  Security Considerations
     8.1.  Loss and Congestion Signals
     8.2.  Traffic Analysis
     8.3.  Misreporting ECN Markings
   9.  References
     9.1.  Normative References
     9.2.  Informative References
   Appendix A.  Loss Recovery Pseudocode
     A.1.  Tracking Sent Packets
       A.1.1.  Sent Packet Fields
     A.2.  Constants of Interest
     A.3.  Variables of Interest
     A.4.  Initialization
     A.5.  On Sending a Packet
     A.6.  On Receiving a Datagram
     A.7.  On Receiving an Acknowledgment
     A.8.  Setting the Loss Detection Timer
     A.9.  On Timeout
     A.10. Detecting Lost Packets
     A.11. Upon Dropping Initial or Handshake Keys
   Appendix B.  Congestion Control Pseudocode
     B.1.  Constants of Interest
     B.2.  Variables of Interest
     B.3.  Initialization
     B.4.  On Packet Sent
     B.5.  On Packet Acknowledgment
     B.6.  On New Congestion Event
     B.7.  Process ECN Information
     B.8.  On Packets Lost
     B.9.  Removing Discarded Packets from Bytes in Flight
   Contributors
   Authors' Addresses
```

---
## **1.  Introduction**

QUIC은 \[QUIC-TRANSPORT\]에 설명된 안전한 범용 전송 프로토콜입니다. 이 문서에서는 QUIC의 손실 감지 및 혼잡 제어 메커니즘에 대해 설명합니다.

---
## **2.  Conventions and Definitions**

키워드 "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY" 및 "OPTIONAL" "는 BCP 14 \[RFC2119\] \[RFC8174\]에 설명된 대로 여기에 표시된 것처럼 모두 대문자로 표시되는 경우에만 해석됩니다.\(MUST NOT\)

이 문서에 사용된 용어의 정의:

Ack 유도 프레임: ACK, PADDING 및 CONNECTION\_CLOSE를 제외한 모든 프레임은 Ack 유도로 간주됩니다.

승인 유도 패킷: 승인 유도 프레임이 포함된 패킷은 최대 승인 지연 내에 수신기로부터 ACK를 유도하며 승인 유도 패킷이라고 합니다.

비행 중 패킷: 패킷이 승인을 유도하거나 PADDING 프레임을 포함하고 전송되었지만 승인되지 않거나 손실된 것으로 선언되거나 이전 키와 함께 폐기될 때 패킷이 비행 중인 것으로 간주됩니다.

---
## **3.  Design of the QUIC Transmission Machinery**

QUIC의 모든 전송은 암호화 수준을 나타내고 패킷 시퀀스 번호\(이하 패킷 번호라고 함\)를 포함하는 패킷 수준 헤더와 함께 전송됩니다. 암호화 수준은 \[QUIC-TRANSPORT\]의 12.3절에 설명된 대로 패킷 수 공간을 나타냅니다. 패킷 번호는 연결 수명 동안 패킷 번호 공간 내에서 반복되지 않습니다. 패킷 번호는 공간 내에서 단조롭게 증가하는 순서로 전송되므로 모호성을 방지합니다. 일부 패킷 번호는 절대 사용되지 않아 의도적인 공백이 남을 수 있습니다.

이 설계는 전송과 재전송을 명확하게 구분할 필요성을 제거합니다. 이는 QUIC의 TCP 손실 감지 메커니즘 해석에서 상당한 복잡성을 제거합니다.

QUIC 패킷에는 다양한 유형의 여러 프레임이 포함될 수 있습니다. 복구 메커니즘은 안정적인 전달이 필요한 데이터와 프레임이 손실되었음을 확인하거나 선언하고 필요에 따라 새 패킷으로 전송되도록 보장합니다. 패킷에 포함된 프레임 유형은 복구 및 정체 제어 논리에 영향을 미칩니다.

\* 모든 패킷이 승인되지만, 승인 프레임이 없는 패킷은 승인 패킷과 함께만 승인됩니다.

\* CRYPTO 프레임을 포함하는 긴 헤더 패킷은 QUIC 핸드셰이크 성능에 매우 중요하며 승인을 위해 더 짧은 타이머를 사용합니다.

\* ACK 또는 CONNECTION\_CLOSE 프레임 이외의 프레임을 포함하는 패킷은 혼잡 제어 제한에 포함되며 진행 중인 것으로 간주됩니다.

\* PADDING 프레임은 승인 전송을 직접 유발하지 않고 패킷이 전송 중인 바이트에 기여하도록 합니다.

---
## **4.  Relevant Differences between QUIC and TCP**

TCP의 손실 감지 및 혼잡 제어에 익숙한 독자라면 여기에서 잘 알려진 TCP 알고리즘과 유사한 알고리즘을 찾을 수 있습니다. 그러나 QUIC와 TCP 간의 프로토콜 차이로 인해 알고리즘 차이가 발생합니다. 이러한 프로토콜 차이점은 아래에 간략하게 설명되어 있습니다.

---
### **4.1.  Separate Packet Number Spaces**

QUIC은 0-RTT를 제외하고 각 암호화 수준에 대해 별도의 패킷 번호 공간을 사용하며 모든 세대의 1-RTT 키는 동일한 패킷 번호 공간을 사용합니다. 별도의 패킷 번호 공간을 사용하면 한 수준의 암호화로 전송된 패킷을 승인해도 다른 암호화 수준으로 전송된 패킷의 잘못된 재전송이 발생하지 않습니다. 혼잡 제어 및 RTT\(왕복 시간\) 측정은 패킷 번호 공간 전체에서 통합됩니다.

---
### **4.2.  Monotonically Increasing Packet Numbers**

TCP는 발신자의 전송 순서와 수신자의 배달 순서를 혼동하여 재전송 모호성 문제 \[RETRANSMISSION\]를 발생시킵니다. QUIC는 전송 순서와 전달 순서를 분리합니다. 패킷 번호는 전송 순서를 나타내며 전달 순서는 STREAM 프레임의 스트림 오프셋에 의해 결정됩니다.

QUIC의 패킷 번호는 패킷 번호 공간 내에서 엄격하게 증가하며 전송 순서를 직접 인코딩합니다. 패킷 번호가 높을수록 패킷이 나중에 전송되었음을 의미하고, 패킷 번호가 낮을수록 패킷이 먼저 전송되었음을 의미합니다. 확인을 유도하는 프레임이 포함된 패킷이 손실된 것으로 감지되면 QUIC는 새 패킷 번호와 함께 새 패킷에 필요한 프레임을 포함시켜 ACK가 수신될 때 어떤 패킷이 확인되는지에 대한 모호성을 제거합니다. 결과적으로 보다 정확한 RTT 측정이 가능하고, 가짜 재전송이 간단하게 감지되며, 빠른 재전송과 같은 메커니즘이 패킷 번호에만 기초하여 보편적으로 적용될 수 있습니다.

이 설계 포인트는 QUIC의 손실 감지 메커니즘을 크게 단순화합니다. 대부분의 TCP 메커니즘은 암시적으로 TCP 시퀀스 번호를 기반으로 전송 순서를 추론하려고 시도합니다. 이는 특히 TCP 타임스탬프를 사용할 수 없는 경우 중요한 작업입니다.

---
### **4.3.  Clearer Loss Epoch**

QUIC은 패킷이 손실되면 손실 시대를 시작합니다. 손실 에포크는 에포크 시작 이후 전송된 패킷이 확인되면 종료됩니다. TCP는 시퀀스 번호 공간의 공백이 채워질 때까지 기다리므로 세그먼트가 여러 번 연속으로 손실되면 여러 왕복 동안 손실 에포크가 끝나지 않을 수 있습니다. 둘 다 에포크당 한 번만 혼잡 창을 줄여야 하기 때문에 QUIC는 손실이 발생하는 모든 왕복 여행에 대해 한 번만 수행하지만 TCP는 여러 왕복 여행에 걸쳐 한 번만 수행할 수 있습니다.

---
### **4.4.  No Reneging**

QUIC ACK 프레임에는 TCP SACK\(Selective Acknowledgements\) \[RFC2018\]의 정보와 유사한 정보가 포함되어 있습니다. 그러나 QUIC는 패킷 승인 취소를 허용하지 않으므로 양쪽 구현을 크게 단순화하고 발신자에 대한 메모리 부담을 줄입니다.

---
### **4.5.  More ACK Ranges**

QUIC는 TCP의 세 가지 SACK 범위와 달리 많은 ACK 범위를 지원합니다. 손실이 큰 환경에서 이는 복구 속도를 높이고, 가짜 재전송을 줄이며, 시간 초과에 의존하지 않고 진행을 보장합니다.

---
### **4.6.  Explicit Correction for Delayed Acknowledgments**

QUIC 엔드포인트는 패킷이 수신되는 시점과 해당 승인이 전송되는 시점 사이에 발생하는 지연을 측정하여 피어가 보다 정확한 RTT 추정치를 유지할 수 있도록 합니다. \[QUIC-TRANSPORT\]의 섹션 13.2를 참조하세요.

---
### **4.7.  Probe Timeout Replaces RTO and TLP**

QUIC는 TCP의 RTO\(재전송 시간 초과\) 계산을 기반으로 하는 타이머와 함께 프로브 시간 초과\(PTO, 섹션 6.2 참조\)를 사용합니다. \[RFC6298\]을 참조하세요. QUIC의 PTO에는 고정된 최소 시간 초과를 사용하는 대신 피어의 최대 예상 승인 지연이 포함됩니다.

TCP에 대한 RACK-TLP 손실 감지 알고리즘 \[RFC8985\]과 유사하게, QUIC는 PTO가 만료될 때 정체 기간을 축소하지 않습니다. 왜냐하면 꼬리에서의 단일 패킷 손실은 지속적인 정체를 나타내지 않기 때문입니다. 대신, QUIC는 지속적인 혼잡이 선언될 때 혼잡 창을 축소합니다. 섹션 7.6을 참조하세요. 이를 통해 QUIC는 불필요한 혼잡 창 감소를 방지하여 F-RTO\(Forward RTO-Recovery\) \[RFC5682\]와 같은 메커니즘 수정의 필요성을 제거합니다. QUIC는 PTO 만료 시 혼잡 창을 축소하지 않으므로 QUIC 발신자는 여전히 사용 가능한 혼잡 창이 있는 경우 PTO 만료 후 더 많은 비행 중 패킷을 보내는 데 제한이 없습니다. 이는 발신자의 응용 프로그램이 제한되어 있고 PTO 타이머가 만료된 경우에 발생합니다. 이는 애플리케이션이 제한된 경우 TCP의 RTO 메커니즘보다 더 공격적이지만 애플리케이션이 제한되지 않은 경우에는 동일합니다.

QUIC를 사용하면 타이머가 만료될 때마다 프로브 패킷이 일시적으로 혼잡 창을 초과할 수 있습니다.

---
### **4.8.  The Minimum Congestion Window Is Two Packets**

TCP는 하나의 패킷의 최소 혼잡 창을 사용합니다. 그러나 해당 단일 패킷이 손실되면 보낸 사람은 PTO가 복구될 때까지 기다려야 하며\(6.2절\) 이는 RTT보다 훨씬 길어질 수 있습니다. 단일 승인 유도 패킷을 보내면 수신자가 승인을 지연할 때 추가 대기 시간이 발생할 가능성도 높아집니다.

따라서 QUIC에서는 최소 혼잡 창을 두 개의 패킷으로 권장합니다. 이로 인해 네트워크 부하가 증가하지만 발신자는 지속적인 정체 상황에서 전송 속도를 기하급수적으로 감소시키므로 안전한 것으로 간주됩니다\(섹션 6.2\).

---
### **4.9.  Handshake Packets Are Not Special**

TCP는 SYN 또는 SYN-ACK 패킷의 손실을 지속적인 정체로 처리하고 정체 기간을 하나의 패킷으로 줄입니다. \[RFC5681\]을 참조하세요. QUIC은 핸드셰이크 데이터가 포함된 패킷의 손실을 다른 손실과 동일하게 처리합니다.

---
## **5.  Estimating the Round-Trip Time**

높은 수준에서 엔드포인트는 패킷이 전송된 시점부터 RTT 샘플로 승인되는 시점까지의 시간을 측정합니다. 엔드포인트는 RTT 샘플과 피어 보고 호스트 지연\(\[QUIC-TRANSPORT\]의 섹션 13.2 참조\)을 사용하여 네트워크 경로의 RTT에 대한 통계적 설명을 생성합니다. 엔드포인트는 각 경로에 대해 일정 기간 동안의 최소값\(min\_rtt\), 지수 가중 이동 평균\(smoothed\_rtt\), 평균 편차\(이 문서의 나머지 부분에서는 "변이"라고 함\) 등 세 가지 값을 계산합니다. 관찰된 RTT 샘플\(rttvar\)에서.

---
### **5.1.  Generating RTT Samples**

엔드포인트는 다음 두 가지 조건을 충족하는 ACK 프레임을 수신하면 RTT 샘플을 생성합니다.

\* 가장 큰 승인된 패킷 번호가 새로 승인되며,

\* 새로 승인된 패킷 중 적어도 하나가 승인을 유도했습니다.

RTT 샘플인 late\_rtt는 가장 큰 승인 패킷이 전송된 이후 경과된 시간으로 생성됩니다.

```text
   latest_rtt = ack_time - send_time_of_largest_acked
```

RTT 샘플은 수신된 ACK 프레임에서 가장 큰 확인 패킷만을 사용하여 생성됩니다. 이는 피어가 ACK 프레임에서 가장 큰 승인 패킷에 대해서만 승인 지연을 보고하기 때문입니다. 보고된 승인 지연은 RTT 샘플 측정에 사용되지 않지만 smoothed\_rtt 및 rttvar의 후속 계산에서 RTT 샘플을 조정하는 데 사용됩니다\(섹션 5.3\).

단일 패킷에 대해 여러 RTT 샘플을 생성하는 것을 방지하려면 가장 큰 확인된 패킷을 새로 확인하지 않는 경우 ACK 프레임을 사용하여 RTT 추정치를 업데이트해서는 안 됩니다.\(SHOULD NOT\)

RTT 샘플은 적어도 하나의 승인 유도 패킷을 새로 승인하지 않는 ACK 프레임을 수신할 때 생성되어서는 안 됩니다. 일반적으로 피어는 승인을 유도하지 않은 패킷만 수신될 때 ACK 프레임을 보내지 않습니다. 따라서 승인을 유도하지 않은 패킷에 대한 승인만 포함하는 ACK 프레임에는 임의로 큰 ACK 지연 값이 포함될 수 있습니다. 이러한 ACK 프레임을 무시하면 이후의 smoothed\_rtt 및 rttvar 계산 시 복잡해지는 것을 방지할 수 있습니다.\(MUST NOT\)

RTT 내에서 여러 ACK 프레임이 수신되면 발신자는 RTT당 여러 RTT 샘플을 생성할 수 있습니다. \[RFC6298\]에서 제안한 대로 그렇게 하면 smoothed\_rtt 및 rttvar의 기록이 부적절해질 수 있습니다. RTT 추정치가 충분한 기록을 유지하는지 확인하는 것은 공개 연구 문제입니다.

---
### **5.2.  Estimating min_rtt**

min\_rtt는 일정 기간 동안 특정 네트워크 경로에서 관찰된 최소 RTT에 대한 발신자의 추정치입니다. 이 문서에서 min\_rtt는 손실 감지에 사용되어 믿을 수 없을 정도로 작은 RTT 샘플을 거부합니다.

min\_rtt는 첫 번째 RTT 샘플에서 최신\_rtt로 설정되어야 합니다. 다른 모든 샘플에서는 min\_rtt를 min\_rtt와 최신\_rtt\(섹션 5.1\) 중 더 작은 값으로 설정해야 합니다.\(MUST, MUST\)

엔드포인트는 min\_rtt를 계산할 때 로컬로 관찰된 시간만 사용하며 피어가 보고한 승인 지연을 조정하지 않습니다. 그렇게 하면 엔드포인트가 관찰한 내용\(섹션 5.3 참조\)을 기반으로 smoothed\_rtt의 하한을 설정할 수 있으며 피어가 잘못 보고한 지연으로 인한 잠재적인 과소평가를 제한할 수 있습니다.

네트워크 경로의 RTT는 시간이 지남에 따라 변경될 수 있습니다. 경로의 실제 RTT가 감소하면 min\_rtt는 첫 번째 낮은 샘플에서 즉시 조정됩니다. 그러나 경로의 실제 RTT가 증가하면 min\_rtt는 이에 적응하지 않으므로 새 RTT보다 작은 향후 RTT 샘플이 smoothed\_rtt에 포함될 수 있습니다.

엔드포인트는 지속적인 정체가 설정된 후 min\_rtt를 최신 RTT 샘플로 설정해야 합니다\(SHOULD\). 이렇게 하면 RTT가 증가할 때 지속적인 정체를 반복적으로 선언하는 것을 방지할 수 있습니다. 이는 또한 네트워크 중단 이벤트 후에 연결이 min\_rtt 및 smoothed\_rtt의 추정치를 재설정할 수 있도록 허용합니다. 섹션 5.3을 참조하세요.\(SHOULD\)

엔드포인트는 트래픽 볼륨이 낮고 승인 지연 시간이 짧은 승인이 수신되는 경우와 같이 연결의 다른 시점에 min\_rtt를 다시 설정할 수 있습니다. 경로의 실제 최소 RTT는 자주 관찰할 수 없으므로 구현 시 min\_rtt 값을 너무 자주 새로 고치면 안 됩니다.\(MAY, SHOULD NOT\)

---
### **5.3.  Estimating smoothed_rtt and rttvar**

smoothed\_rtt는 엔드포인트 RTT 샘플의 지수 가중 이동 평균이며, rttvar는 평균 변형을 사용하여 RTT 샘플의 변형을 추정합니다.

Smoothed\_rtt 계산에서는 승인 지연을 위해 RTT 샘플을 조정한 후 사용합니다. 이러한 지연은 \[QUIC-TRANSPORT\]의 섹션 19.3에 설명된 대로 ACK 프레임의 ACK 지연 필드에서 디코딩됩니다.

피어는 핸드셰이크 중에 피어의 max\_ack\_delay보다 큰 승인 지연을 보고할 수 있습니다\(\[QUIC-TRANSPORT\]의 섹션 13.2.1\). 이를 설명하기 위해 엔드포인트는 \[QUIC-TLS\]의 섹션 4.1.2에 정의된 대로 핸드셰이크가 확인될 때까지 max\_ack\_delay를 무시해야 합니다. 이러한 큰 승인 지연이 발생하면 반복되지 않고 핸드셰이크로 제한될 가능성이 높습니다. 따라서 엔드포인트는 이를 max\_ack\_delay로 제한하지 않고 사용할 수 있으므로 RTT 추정치의 불필요한 인플레이션을 피할 수 있습니다.\(SHOULD\)

확인 지연에 대한 피어의 보고 또는 엔드포인트의 min\_rtt 추정에 오류가 있는 경우 확인 지연이 크면 smoothed\_rtt가 상당히 부풀려질 수 있습니다. 따라서 승인 지연에 대한 RTT 샘플을 조정하면 샘플이 min\_rtt보다 작아지는 경우 핸드셰이크 확인 전에 엔드포인트는 RTT 샘플을 무시할 수 있습니다.\(MAY\)

핸드셰이크가 확인된 후 피어의 max\_ack\_delay보다 큰 피어에 의해 보고된 모든 승인 지연은 의도하지 않았지만 잠재적으로 반복되는 지연\(예: 피어의 스케줄러 대기 시간 또는 이전 승인 손실\)에 기인합니다. 과도한 지연은 비호환 수신기로 인해 발생할 수도 있습니다. 따라서 이러한 추가 지연은 사실상 경로 지연의 일부로 간주되어 RTT 추정에 통합됩니다.

따라서 피어 보고 승인 지연을 사용하여 RTT 샘플을 조정할 때 엔드포인트는 다음을 수행합니다.

```text
   *  MAY ignore the acknowledgment delay for Initial packets, since
      these acknowledgments are not delayed by the peer (Section 13.2.1
      of [QUIC-TRANSPORT]);

   *  SHOULD ignore the peer's max_ack_delay until the handshake is
      confirmed;
```

\* 핸드셰이크가 확인된 후 승인 지연과 피어의 max\_ack\_delay 중 더 작은 것을 사용해야 합니다. 그리고\(MUST\)

\* 결과 값이 min\_rtt보다 작은 경우 RTT 샘플에서 승인 지연을 빼서는 안 됩니다. 이는 잘못 보고된 피어로 인해 smoothed\_rtt가 과소평가되는 것을 제한합니다.\(MUST NOT\)

또한 해당 암호 해독 키를 즉시 사용할 수 없는 경우 엔드포인트는 승인 처리를 연기할 수 있습니다. 예를 들어, 클라이언트는 1-RTT 패킷 보호 키를 아직 사용할 수 없기 때문에 해독할 수 없는 0-RTT 패킷에 대한 승인을 받을 수 있습니다. 이러한 경우 엔드포인트는 핸드셰이크가 확인될 때까지 RTT 샘플에서 이러한 로컬 지연을 빼야 합니다\(SHOULD\).\(SHOULD\)

\[RFC6298\]과 유사하게 smoothed\_rtt 및 rttvar는 다음과 같이 계산됩니다.

엔드포인트는 연결 설정 중 그리고 연결 마이그레이션 중 추정기가 재설정될 때 RTT 추정기를 초기화합니다. \[QUIC-TRANSPORT\]의 섹션 9.4를 참조하세요. 새로운 경로에 대해 RTT 샘플을 사용할 수 있기 전이나 추정기가 재설정되면 추정기는 초기 RTT를 사용하여 초기화됩니다. 섹션 6.2.2를 참조하세요.

smoothed\_rtt 및 rttvar는 다음과 같이 초기화됩니다. 여기서 kInitialRtt에는 초기 RTT 값이 포함됩니다.

```text
   smoothed_rtt = kInitialRtt
   rttvar = kInitialRtt / 2
```

네트워크 경로에 대한 RTT 샘플은 최신\_rtt에 기록됩니다. 섹션 5.1을 참조하세요. 초기화 후 첫 번째 RTT 샘플에서 추정기는 해당 샘플을 사용하여 재설정됩니다. 이를 통해 추정자는 과거 샘플의 기록을 유지하지 않습니다. 다른 경로로 전송된 패킷은 \[QUIC-TRANSPORT\]의 섹션 9.4에 설명된 대로 현재 경로에 RTT 샘플을 제공하지 않습니다.

초기화 후 첫 번째 RTT 샘플에서 smoothed\_rtt 및 rttvar는 다음과 같이 설정됩니다.

```text
   smoothed_rtt = latest_rtt
   rttvar = latest_rtt / 2
```

후속 RTT 샘플에서 smoothed\_rtt 및 rttvar는 다음과 같이 발전합니다.

ack\_delay = ACK 프레임의 디코딩된 승인 지연 if\(핸드셰이크 확인\): ack\_delay = min\(ack\_delay, max\_ack\_delay\) adjust\_rtt =latest\_rtt if\(latest\_rtt \>= min\_rtt + ack\_delay\): adjust\_rtt = 최신\_rtt - ack\_delay smoothed\_rtt = 7/8 \* smoothed\_rtt + 1/ 8 \* 조정\_rtt rttvar\_sample = 절대\(smoothed\_rtt - 조정\_rtt\) rttvar = 3/4 \* rttvar + 1/4 \* rttvar\_sample

---
## **6.  Loss Detection**

QUIC 발신자는 확인을 사용하여 손실된 패킷을 감지하고 PTO를 사용하여 확인이 수신되었는지 확인합니다. 섹션 6.2를 참조하세요. 이 섹션에서는 이러한 알고리즘에 대해 설명합니다.

패킷이 손실된 경우 QUIC 전송은 데이터 재전송, 업데이트된 프레임 전송 또는 프레임 삭제 등을 통해 해당 손실을 복구해야 합니다. 자세한 내용은 \[QUIC-TRANSPORT\]의 섹션 13.3을 참조하세요.

손실 감지는 RTT 측정 및 정체 제어와 달리 패킷 번호 공간별로 구분됩니다. RTT 및 정체 제어는 경로의 속성인 반면 손실 감지도 키 가용성에 의존하기 때문입니다.

---
### **6.1.  Acknowledgment-Based Detection**

승인 기반 손실 감지는 TCP의 빠른 재전송 \[RFC5681\], 조기 재전송 \[RFC5827\], 전달 승인 \[FACK\], SACK 손실 복구 \[RFC6675\] 및 RACK-TLP \[RFC8985\]의 정신을 구현합니다. 이 섹션에서는 이러한 알고리즘이 QUIC에서 어떻게 구현되는지에 대한 개요를 제공합니다.

다음 조건을 모두 충족하는 경우 패킷이 손실된 것으로 선언됩니다.

\* 패킷이 확인되지 않고 전송 중이며 확인된 패킷보다 먼저 전송되었습니다.

\* 패킷은 kPacketThreshold 패킷 이전에 전송되었습니다.

- 승인된 패킷\(섹션 6.1.1\) 또는 과거에 충분히 오랫동안 전송되었습니다\(섹션 6.1.2\).

승인은 나중에 전송된 패킷이 전달되었음을 나타내며, 패킷 및 시간 임계값은 패킷 재정렬에 대해 어느 정도 허용치를 제공합니다.

패킷을 손실된 것으로 허위로 선언하면 불필요한 재전송이 발생하고 손실 감지 시 혼잡 컨트롤러의 동작으로 인해 성능이 저하될 수 있습니다. 구현에서는 허위 재전송을 감지하고 패킷 또는 시간 재정렬 임계값을 늘려 향후 허위 재전송 및 손실 이벤트를 줄일 수 있습니다. 적응형 시간 임계값을 사용하는 구현은 복구 대기 시간을 최소화하기 위해 더 작은 초기 재정렬 임계값으로 시작하도록 선택할 수 있습니다.\(MAY\)

---
#### **6.1.1.  Packet Threshold**

TCP 손실 감지 \[RFC5681\] \[RFC6675\]에 대한 모범 사례를 기반으로 패킷 재정렬 임계값\(kPacketThreshold\)의 권장 초기 값은 3입니다. TCP와 유사하게 유지하기 위해 구현에서는 3보다 작은 패킷 임계값을 사용해서는 안 됩니다. \[RFC5681\]을 참조하세요.\(SHOULD, SHOULD NOT\)

일부 네트워크에서는 더 높은 수준의 패킷 재정렬이 나타나 발신자가 잘못된 손실을 감지할 수 있습니다. 또한 TCP 패킷을 관찰하고 재정렬할 수 있는 네트워크 요소가 QUIC에 대해 이를 수행할 수 없고 QUIC 패킷 번호가 암호화되기 때문에 패킷 재정렬은 TCP보다 QUIC에서 더 일반적일 수 있습니다. RACK \[RFC8985\]와 같이 허위로 손실을 감지한 후 재정렬 임계값을 높이는 알고리즘은 TCP에서 유용한 것으로 입증되었으며 최소한 QUIC에서도 유용할 것으로 예상됩니다.

---
#### **6.1.2.  Time Threshold**

동일한 패킷 번호 공간 내의 이후 패킷이 승인되면 엔드포인트는 과거에 임계 시간 동안 전송된 경우 이전 패킷이 손실되었음을 선언해야 합니다. 패킷이 너무 일찍 손실된 것으로 선언하는 것을 방지하려면 이 시간 임계값을 kGranularity 상수에 표시된 대로 최소한 로컬 타이머 세분성으로 설정해야 합니다. 시간 임계값은 다음과 같습니다.\(SHOULD, MUST\)

```text
   max(kTimeThreshold * max(smoothed_rtt, latest_rtt), kGranularity)
```

가장 큰 승인 패킷 이전에 전송된 패킷이 아직 손실되었다고 선언할 수 없는 경우 남은 시간에 대해 타이머를 설정해야 합니다.\(SHOULD\)

max\(smoothed\_rtt,latest\_rtt\)를 사용하면 다음 두 가지 경우로부터 보호됩니다.

```text
   *  the latest RTT sample is lower than the smoothed RTT, perhaps due
      to reordering where the acknowledgment encountered a shorter path;
```

\* 최신 RTT 샘플은 평활화된 RTT보다 높습니다. 아마도 실제 RTT가 지속적으로 증가했기 때문일 수 있지만 평활화된 RTT는 아직 따라잡지 못했습니다.

RTT 승수로 표현되는 RECOMMENDED 시간 임계값\(kTimeThreshold\)은 9/8입니다. 타이머 세분성\(kGranularity\)의 권장 값은 1밀리초입니다.\(SHOULD, SHOULD\)

| 참고: TCP의 RACK \[RFC8985\]는 약간 더 큰 RACK을 지정합니다.

- | 비슷한 목적으로 5/4에 해당하는 임계값입니다. | QUIC 경험에 따르면 9/8이 잘 작동하는 것으로 나타났습니다.

구현에서는 절대 임계값, 이전 연결의 임계값, 적응형 임계값 또는 RTT 변형 포함을 실험할 수 있습니다. 임계값이 작을수록 재정렬 복원력이 감소하고 가짜 재전송이 증가하며, 임계값이 클수록 손실 감지 지연이 늘어납니다.\(MAY\)

---
### **6.2.  Probe Timeout**

PTO\(프로브 시간 초과\)는 승인 유도 패킷이 예상 시간 내에 승인되지 않거나 서버가 클라이언트 주소의 유효성을 검사하지 않은 경우 하나 또는 두 개의 프로브 데이터그램 전송을 트리거합니다. PTO를 사용하면 테일 패킷 또는 승인 손실로부터 연결을 복구할 수 있습니다.

손실 감지와 마찬가지로 PTO는 패킷 번호 공간당입니다. 즉, PTO 값은 패킷 수 공간별로 계산됩니다.

PTO 타이머 만료 이벤트는 패킷 손실을 나타내지 않으며 이전에 확인되지 않은 패킷이 손실된 것으로 표시되도록 해서는 안 됩니다. 패킷을 새로 승인하는 승인이 수신되면 패킷 및 시간 임계값 메커니즘에 따라 손실 감지가 진행됩니다. 섹션 6.1을 참조하세요.\(MUST NOT\)

QUIC에서 사용되는 PTO 알고리즘은 Tail Loss Probe \[RFC8985\], RTO \[RFC5681\], TCP용 F-RTO 알고리즘 \[RFC5682\]의 신뢰성 기능을 구현합니다. 타임아웃 계산은 TCP의 RTO 기간 \[RFC6298\]을 기반으로 합니다.

---
#### **6.2.1.  Computing PTO**

응답 유도 패킷이 전송되면 발신자는 다음과 같이 PTO 기간에 대한 타이머를 예약합니다.

```text
   PTO = smoothed_rtt + max(4*rttvar, kGranularity) + max_ack_delay
```

PTO 기간은 보낸 사람이 보낸 패킷의 승인을 기다려야 하는 시간입니다. 이 기간에는 수신자가 승인 전송을 지연할 수 있는 최대 시간을 설명하기 위해 추정된 네트워크 RTT\(smoothed\_rtt\), 추정의 변동\(4\*rttvar\) 및 max\_ack\_delay가 포함됩니다.

PTO가 초기 또는 핸드셰이크 패킷 번호 공간에 대해 무장된 경우 PTO 기간 계산의 max\_ack\_delay는 0으로 설정됩니다. 피어가 의도적으로 이러한 패킷을 지연시키지 않을 것으로 예상되기 때문입니다. \[QUIC-TRANSPORT\]의 섹션 13.2.1을 참조하세요.

타이머가 즉시 만료되는 것을 방지하려면 PTO 기간이 최소한 kGranularity 이상이어야 합니다.\(MUST\)

여러 패킷 번호 공간의 응답 유도 패킷이 비행 중일 때 타이머는 초기 및 핸드셰이크 패킷 번호 공간의 이전 값으로 설정되어야 합니다.\(MUST\)

엔드포인트는 핸드셰이크가 확인될 때까지 애플리케이션 데이터 패킷 번호 공간에 대한 PTO 타이머를 설정해서는 안 됩니다. 이렇게 하면 피어에 패킷을 처리할 키가 없거나 엔드포인트에 승인을 처리할 키가 아직 없는 경우 엔드포인트가 패킷의 정보를 재전송하는 것을 방지할 수 있습니다. 예를 들어, 클라이언트가 0-RTT 패킷을 서버에 보낼 때 이런 일이 발생할 수 있습니다. 서버가 이를 해독할 수 있는지 여부를 알지 못한 채 그렇게 합니다. 마찬가지로, 클라이언트가 서버의 인증서를 확인하여 이러한 1-RTT 패킷을 읽을 수 있는지 확인하기 전에 서버가 1-RTT 패킷을 보낼 때 이런 일이 발생할 수 있습니다.\(MUST NOT\)

발신자는 승인 유도 패킷이 전송되거나 승인될 때마다 또는 초기 또는 핸드셰이크 키가 폐기될 때 PTO 타이머를 다시 시작해야 합니다\(\[QUIC-TLS\]의 섹션 4.9\). 이렇게 하면 PTO가 항상 최신 RTT 추정을 기반으로 설정되고 패킷 번호 공간 전체에서 올바른 패킷에 대해 설정됩니다.\(SHOULD\)

PTO 타이머가 만료되면 PTO 백오프를 늘려야 하며, 그 결과 PTO 기간이 현재 값의 두 배로 설정됩니다. PTO 백오프 요소는 다음 경우를 제외하고 승인이 수신되면 재설정됩니다. 핸드셰이크 중에 서버가 패킷에 응답하는 데 다른 경우보다 시간이 더 오래 걸릴 수 있습니다. 반복되는 클라이언트 프로브로부터 이러한 서버를 보호하기 위해 서버가 클라이언트 주소 유효성 검사를 완료했는지 아직 확신할 수 없는 클라이언트에서는 PTO 백오프가 재설정되지 않습니다. 즉, 클라이언트는 초기 패킷에서 승인을 받을 때 PTO 백오프 요소를 재설정하지 않습니다.\(MUST\)

송신자 속도의 기하급수적인 감소는 심각한 혼잡으로 인한 패킷 손실 또는 승인으로 인해 연속적인 PTO가 발생할 수 있기 때문에 중요합니다. 여러 패킷 번호 공간에서 비행 중인 승인 패킷이 있는 경우에도 PTO의 기하급수적인 증가는 네트워크의 과도한 로드를 방지하기 위해 모든 공간에서 발생합니다. 예를 들어, 초기 패킷 번호 공간의 시간 초과는 핸드셰이크 패킷 번호 공간의 시간 초과 길이를 두 배로 늘립니다.

연속 PTO가 만료되는 총 시간은 유휴 시간 제한에 의해 제한됩니다.

시간 임계값 손실 감지를 위해 타이머가 설정된 경우 PTO 타이머를 설정하면 안 됩니다. 섹션 6.1.2를 참조하세요. 시간 임계값 손실 감지를 위해 설정된 타이머는 대부분의 경우 PTO 타이머보다 일찍 만료되며 데이터를 허위로 재전송할 가능성이 적습니다.\(MUST NOT\)

---
#### **6.2.2.  Handshakes and New Paths**

동일한 네트워크를 통한 재개된 연결은 이전 연결의 최종 평활화된 RTT 값을 재개된 연결의 초기 RTT로 사용할 수 있습니다. 이전 RTT를 사용할 수 없는 경우 초기 RTT는 333밀리초로 설정되어야 합니다. 이로 인해 TCP의 초기 RTO에 권장되는 대로 1초의 PTO로 시작하는 핸드셰이크가 발생합니다. \[RFC6298\]의 섹션 2를 참조하세요.\(MAY, SHOULD\)

연결은 새로운 경로에 대한 초기 RTT\(부록 A.2의 kInitialRtt 참조\)를 설정하기 위해 PATH\_CHALLENGE 전송과 PATH\_RESPONSE 수신 사이의 지연을 사용할 수 있지만 지연은 RTT 샘플로 간주되어서는 안 됩니다.\(SHOULD NOT\)

초기 키와 핸드셰이크 키가 폐기되면\(섹션 6.4 참조\) 모든 초기 패킷과 핸드셰이크 패킷은 더 이상 승인될 수 없으므로 이동 중인 바이트에서 제거됩니다. 초기 또는 핸드셰이크 키가 폐기되면 PTO 및 손실 감지 타이머를 재설정해야 합니다. 왜냐하면 폐기된 키는 진행 과정을 나타내고 손실 감지 타이머가 현재 폐기된 패킷 번호 공간에 대해 설정되었을 수 있기 때문입니다.\(MUST\)

---
##### **6.2.2.1.  Before Address Validation**

서버가 경로에서 클라이언트 주소의 유효성을 검사할 때까지 전송할 수 있는 데이터 양은 \[QUIC-TRANSPORT\]의 섹션 8.1에 지정된 대로 수신된 데이터 양의 3배로 제한됩니다. 추가 데이터를 전송할 수 없는 경우 PTO로 전송된 패킷은 증폭 방지 제한에 따라 계산되므로 클라이언트로부터 데이터그램을 수신할 때까지 서버의 PTO 타이머를 활성화해서는 안 됩니다.\(MUST NOT\)

서버가 클라이언트로부터 데이터그램을 수신하면 증폭 제한이 증가하고 서버는 PTO 타이머를 재설정합니다. PTO 타이머가 과거 시간으로 설정되면 즉시 실행됩니다. 이렇게 하면 핸드셰이크 완료에 중요한 패킷 이전에 새로운 1-RTT 패킷을 보내는 것을 방지할 수 있습니다. 특히, 이는 0-RTT가 허용되었지만 서버가 클라이언트 주소의 유효성을 검사하지 못한 경우 발생할 수 있습니다.

클라이언트로부터 더 많은 데이터그램이 수신될 때까지 서버가 차단될 수 있으므로 서버가 주소 검증을 완료했다는 것이 확실할 때까지 서버 차단을 해제하기 위해 패킷을 보내는 것은 클라이언트의 책임입니다\(\[QUIC-TRANSPORT\]의 섹션 8 참조\). . 즉, 클라이언트가 핸드셰이크 패킷에 대한 승인을 받지 못했고 핸드셰이크가 확인되지 않은 경우\(\[QUIC-TLS\]의 섹션 4.1.2 참조\), 패킷이 없더라도 클라이언트는 PTO 타이머를 설정해야 합니다. 비행 중. PTO가 실행될 때 클라이언트는 핸드셰이크 키가 있는 경우 핸드셰이크 패킷을 보내야 합니다. 그렇지 않으면 최소 1200바이트의 페이로드가 있는 UDP 데이터그램의 초기 패킷을 보내야 합니다.\(MUST, MUST\)

---
#### **6.2.3.  Speeding up Handshake Completion**

서버가 중복된 CRYPTO 데이터가 포함된 초기 패킷을 수신하면 클라이언트가 초기 패킷에서 전송된 서버의 CRYPTO 데이터 중 일부를 수신하지 않았거나 클라이언트의 예상 RTT가 너무 작다고 가정할 수 있습니다. 클라이언트가 핸드셰이크 키를 얻기 전에 핸드셰이크 또는 1-RTT 패킷을 수신하면 서버의 초기 패킷 중 일부 또는 전부가 손실되었다고 가정할 수 있습니다.

이러한 조건에서 핸드셰이크 완료 속도를 높이기 위해 엔드포인트는 연결당 제한된 횟수 동안 \[QUIC-TRANSPORT\] 섹션 8.1의 주소 유효성 검사 제한에 따라 PTO 만료 이전에 확인되지 않은 CRYPTO 데이터가 포함된 패킷을 보낼 수 있습니다. . 각 연결에 대해 최대 한 번만 수행하면 단일 패킷 손실을 신속하게 복구하는 데 적합합니다. 처리할 수 없는 패킷 수신에 대한 응답으로 항상 패킷을 재전송하는 엔드포인트는 무한한 패킷 교환이 발생할 위험이 있습니다.\(MAY\)

엔드포인트는 또한 각 데이터그램이 적어도 하나의 승인을 이끌어내도록 보장하기 위해 병합된 패킷\(\[QUIC-TRANSPORT\]의 섹션 12.2 참조\)을 사용할 수 있습니다. 예를 들어 클라이언트는 PING 및 PADDING 프레임이 포함된 초기 패킷을 0-RTT 데이터 패킷과 통합할 수 있고, 서버는 첫 번째 비행에서 PING 프레임이 포함된 초기 패킷과 하나 이상의 패킷을 통합할 수 있습니다.

---
#### **6.2.4.  Sending Probe Packets**

PTO 타이머가 만료되면 발신자는 패킷 번호 공간에서 적어도 하나의 확인 패킷을 프로브로 보내야 합니다. 엔드포인트는 단일 데이터그램 손실로 인한 비용이 많이 드는 연속 PTO 만료를 방지하거나 여러 패킷 번호 공간에서 데이터를 전송하기 위해 승인 유도 패킷을 포함하는 최대 2개의 전체 크기 데이터그램을 보낼 수 있습니다. PTO에서 전송된 모든 프로브 패킷은 반드시 승인을 받아야 합니다.\(MUST, MAY, MUST\)

타이머가 만료된 패킷 번호 공간에서 데이터를 보내는 것 외에도 발신자는 가능한 경우 패킷을 병합하여 비행 중인 데이터가 있는 다른 패킷 번호 공간에서 승인 유도 패킷을 보내야 합니다. 이는 서버에 초기 데이터와 핸드셰이크 데이터가 모두 전송 중인 경우 또는 클라이언트에 핸드셰이크와 애플리케이션 데이터가 모두 전송 중인 경우 특히 유용합니다. 피어가 두 패킷 번호 공간 중 하나에 대한 수신 키만 가질 수 있기 때문입니다.\(SHOULD\)

발신자가 PTO에서 더 빠른 승인을 유도하려는 경우 패킷 번호를 건너뛰어 승인 지연을 제거할 수 있습니다.

엔드포인트는 PTO 만료 시 전송되는 패킷에 새 데이터를 포함해야 합니다. 새 데이터를 보낼 수 없는 경우 이전에 보낸 데이터를 보낼 수 있습니다. 구현에서는 애플리케이션의 우선 순위에 따라 새 데이터 또는 재전송된 데이터를 보내는 것을 포함하여 프로브 패킷의 내용을 결정하기 위한 대체 전략을 사용할 수 있습니다.\(SHOULD, MAY, MAY\)

보낸 사람에게 보낼 새 데이터나 이전에 보낸 데이터가 없을 수도 있습니다. 예를 들어, 다음과 같은 일련의 이벤트를 고려하십시오. 새 애플리케이션 데이터가 STREAM 프레임으로 전송되고 손실된 것으로 간주된 다음 새 패킷으로 재전송되고 원래 전송이 승인됩니다. 보낼 데이터가 없을 때 발신자는 단일 패킷으로 PING 또는 기타 승인을 유도하는 프레임을 보내 PTO 타이머를 재설정해야 합니다.\(SHOULD\)

대안으로, 승인을 유도하는 패킷을 보내는 대신, 발신자는 아직 전송 중인 모든 패킷을 손실된 것으로 표시할 수 있습니다. 이렇게 하면 추가 패킷 전송을 방지할 수 있지만 손실이 너무 적극적으로 선언되어 혼잡 컨트롤러에 의해 불필요한 속도 감소가 발생할 위험이 증가합니다.\(MAY\)

연속 PTO 기간은 기하급수적으로 증가하며, 결과적으로 네트워크에서 패킷이 계속 삭제됨에 따라 연결 복구 대기 시간도 기하급수적으로 늘어납니다. PTO 만료 시 두 개의 패킷을 전송하면 패킷 삭제에 대한 복원력이 향상되어 연속적인 PTO 이벤트가 발생할 가능성이 줄어듭니다.

PTO 타이머가 여러 번 만료되어 새 데이터를 보낼 수 없는 경우 구현에서는 매번 동일한 페이로드를 보낼지 아니면 다른 페이로드를 보낼지 선택해야 합니다. 동일한 페이로드를 보내는 것이 더 간단할 수 있으며 우선 순위가 가장 높은 프레임이 먼저 도착하도록 보장합니다. 매번 다른 페이로드를 보내면 가짜 재전송 가능성이 줄어듭니다.

---
### **6.3.  Handling Retry Packets**

재시도 패킷을 사용하면 클라이언트가 다른 초기 패킷을 보내 연결 프로세스를 효과적으로 다시 시작할 수 있습니다. 재시도 패킷은 초기 패킷이 수신되었지만 처리되지 않았음을 나타냅니다. 재시도 패킷은 패킷이 처리되었음을 나타내지 않거나 패킷 번호를 지정하지 않기 때문에 승인으로 처리될 수 없습니다.

보류 중인 타이머 재설정을 포함하여 재시도 패킷 재설정 정체 제어 및 손실 복구 상태를 수신하는 클라이언트입니다. 다른 연결 상태, 특히 암호화 핸드셰이크 메시지는 유지됩니다. \[QUIC-TRANSPORT\]의 섹션 17.2.5를 참조하세요.

클라이언트는 첫 번째 초기 패킷이 전송된 시점부터 재시도 또는 버전 협상 패킷이 수신된 시점까지의 기간으로 서버에 대한 RTT 추정치를 계산할 수 있습니다. 클라이언트는 초기 RTT 추정에 대한 기본값 대신 이 값을 사용할 수 있습니다.\(MAY, MAY\)

---
### **6.4.  Discarding Keys and Packet State**

초기 및 핸드셰이크 패킷 보호 키가 폐기되면\(\[QUIC-TLS\]의 섹션 4.9 참조\) 해당 키와 함께 전송된 모든 패킷은 승인을 처리할 수 없기 때문에 더 이상 승인될 수 없습니다. 발신자는 해당 패킷과 관련된 모든 복구 상태를 폐기해야 하며 전송 중인 바이트 수에서 이를 제거해야 합니다.\(MUST\)

엔드포인트는 핸드셰이크 패킷 교환을 시작하면 초기 패킷 전송 및 수신을 중지합니다. \[QUIC-TRANSPORT\]의 섹션 17.2.2.1을 참조하세요. 이 시점에서 진행 중인 모든 초기 패킷에 대한 복구 상태는 삭제됩니다.

0-RTT가 거부되면 진행 중인 모든 0-RTT 패킷에 대한 복구 상태가 삭제됩니다.

서버가 0-RTT를 허용하지만 초기 패킷 이전에 도착하는 0-RTT 패킷을 버퍼링하지 않는 경우 초기 0-RTT 패킷은 손실된 것으로 선언되지만 빈도는 낮을 것으로 예상됩니다.

키로 암호화된 패킷이 확인되거나 손실된 것으로 선언된 후 어느 시점에 키가 폐기될 것으로 예상됩니다. 그러나 초기 및 핸드셰이크 비밀은 핸드셰이크 및 1-RTT 키가 클라이언트와 서버 모두에서 사용 가능한 것으로 입증되는 즉시 삭제됩니다. \[QUIC-TLS\]의 섹션 4.9.1을 참조하세요.

---
## **7.  Congestion Control**

이 문서는 TCP NewReno \[RFC6582\]와 유사한 QUIC용 송신측 혼잡 컨트롤러를 지정합니다.

혼잡 제어를 위해 QUIC가 제공하는 신호는 일반적이며 다양한 발신자 측 알고리즘을 지원하도록 설계되었습니다. 발신자는 CUBIC \[RFC8312\]와 같이 사용할 다른 알고리즘을 일방적으로 선택할 수 있습니다.

발신자가 이 문서에 지정된 것과 다른 컨트롤러를 사용하는 경우 선택한 컨트롤러는 \[RFC8085\]의 섹션 3.1에 지정된 혼잡 제어 지침을 준수해야 합니다.\(MUST\)

TCP와 마찬가지로 ACK 프레임만 포함된 패킷은 전송 중인 바이트에 포함되지 않으며 혼잡이 제어되지 않습니다. TCP와 달리 QUIC는 이러한 패킷의 손실을 감지하고 해당 정보를 사용하여 혼잡 컨트롤러 또는 전송되는 ACK 전용 패킷의 속도를 조정할 수 있지만 이 문서에서는 이를 수행하는 메커니즘을 설명하지 않습니다.\(MAY\)

혼잡 컨트롤러는 경로별로 있으므로 \[QUIC-TRANSPORT\]의 섹션 9.4에 설명된 대로 다른 경로로 전송된 패킷은 현재 경로의 혼잡 컨트롤러를 변경하지 않습니다.

이 문서의 알고리즘은 컨트롤러의 혼잡 창을 바이트 단위로 지정하고 사용합니다.

패킷이 PTO 타이머 만료\(섹션 6.2 참조\)에 전송되거나 복구에 들어갈 때\(섹션 7.3 참조\) 전송되지 않는 한, 엔드포인트는 bytes\_in\_flight\(부록 B.2 참조\)가 혼잡 창보다 커지게 하는 경우 패킷을 전송해서는 안 됩니다. .2\).\(MUST NOT\)

---
### **7.1.  Explicit Congestion Notification**

명시적 혼잡 알림\(ECN\) \[RFC3168\] \[RFC8311\]을 지원하도록 경로가 검증된 경우, QUIC는 IP 헤더의 CE\(혼잡 경험\) 코드 포인트를 혼잡 신호로 처리합니다. 이 문서에서는 피어 보고된 ECN-CE 수가 증가할 때 엔드포인트의 응답을 지정합니다. \[QUIC-TRANSPORT\]의 섹션 13.4.2를 참조하세요.

---
### **7.2.  Initial and Minimum Congestion Window**

QUIC은 혼잡 창을 초기 값으로 설정하여 느린 시작으로 모든 연결을 시작합니다. 엔드포인트는 최대 데이터그램 크기\(max\_datagram\_size\)의 10배인 초기 혼잡 창을 사용해야 하며, 동시에 창을 14,720바이트 또는 최대 데이터그램 크기의 두 배로 제한해야 합니다. 이는 \[RFC6928\]의 분석 및 권장 사항을 따르며 TCP의 20바이트 오버헤드에 비해 UDP의 더 작은 8바이트 오버헤드를 설명하기 위해 바이트 제한을 늘립니다.\(SHOULD\)

연결 중에 최대 데이터그램 크기가 변경되면 초기 혼잡 창은 새로운 크기로 다시 계산되어야 합니다. 핸드셰이크를 완료하기 위해 최대 데이터그램 크기가 줄어들면 혼잡 창은 새로운 초기 혼잡 창으로 설정되어야 합니다.\(SHOULD, SHOULD\)

클라이언트 주소를 검증하기 전에 서버는 \[QUIC-TRANSPORT\]의 섹션 8.1에 지정된 대로 증폭 방지 제한에 의해 추가로 제한될 수 있습니다. 증폭 방지 제한은 혼잡 창을 완전히 활용하는 것을 방지하여 혼잡 창의 증가를 늦출 수 있지만 혼잡 창에 직접적인 영향을 미치지는 않습니다.

최소 정체 창은 손실, 피어 보고 ECN-CE 수의 증가 또는 지속적인 정체에 대한 응답으로 정체 창이 얻을 수 있는 가장 작은 값입니다. 권장되는 값은 2 \* max\_datagram\_size입니다.\(SHOULD\)

---
### **7.3.  Congestion Control States**

이 문서에 설명된 NewReno 혼잡 컨트롤러에는 그림 1과 같이 세 가지 상태가 있습니다.

```text
                    New path or      +------------+
               persistent congestion |   Slow     |
           (O)---------------------->|   Start    |
                                     +------------+
                                           |
                                   Loss or |
                           ECN-CE increase |
                                           v
    +------------+     Loss or       +------------+
    | Congestion |  ECN-CE increase  |  Recovery  |
    | Avoidance  |------------------>|   Period   |
    +------------+                   +------------+
              ^                            |
              |                            |
              +----------------------------+
                 Acknowledgment of packet
                   sent during recovery
```

- 그림 1: 혼잡 제어 상태 및 전환

이러한 상태와 그 사이의 전환은 후속 섹션에서 설명됩니다.

---
#### **7.3.1.  Slow Start**

NewReno 발신자는 혼잡 창이 느린 시작 임계값보다 낮을 때마다 느린 시작 상태가 됩니다. 느린 시작 임계값이 무한 값으로 초기화되므로 보낸 사람은 느린 시작으로 시작됩니다.

보낸 사람이 느린 시작에 있는 동안 정체 창은 각 승인이 처리될 때 승인된 바이트 수만큼 증가합니다. 이로 인해 혼잡 창이 기하급수적으로 증가합니다.

송신자는 패킷이 손실되거나 피어가 보고한 ECN-CE 수가 증가할 때 느린 시작을 종료하고 복구 기간에 들어가야 합니다.\(MUST\)

정체 기간이 느린 시작 임계값보다 작을 때마다 발신자는 느린 시작을 다시 시작합니다. 이는 지속적인 정체가 선언된 후에만 발생합니다.

---
#### **7.3.2.  Recovery**

NewReno 발신자는 패킷 손실을 감지하거나 피어에서 보고한 ECN-CE 수가 증가하면 복구 기간에 들어갑니다. 이미 복구 기간에 들어간 발신자는 해당 기간에 머물며 재진입하지 않습니다.

복구 기간에 진입할 때 송신자는 손실이 감지될 때 느린 시작 임계값을 혼잡 창 값의 절반으로 설정해야 합니다. 혼잡 창은 복구 기간을 종료하기 전에 느린 시작 임계값의 감소된 값으로 설정되어야 합니다.\(MUST, MUST\)

구현에서는 복구 기간에 진입하자마자 혼잡 창을 즉시 줄이거나 PRR\(Proportional Rate Reduction\)과 같은 다른 메커니즘을 사용하여 혼잡 창을 보다 점진적으로 줄일 수 있습니다. 혼잡 윈도우가 즉시 감소되면 감소되기 전에 단일 패킷이 전송될 수 있습니다. 이는 손실된 패킷의 데이터가 재전송되는 경우 손실 복구 속도를 높이고 \[RFC6675\]의 섹션 5에 설명된 TCP와 유사합니다.\(MAY\)

복구 기간은 혼잡 창 감소를 왕복당 한 번으로 제한하는 것을 목표로 합니다. 따라서 복구 기간 동안 정체 기간은 ECN-CE 카운트의 새로운 손실이나 증가에 대응하여 변경되지 않습니다.

복구 기간 동안 전송된 패킷이 확인되면 복구 기간이 종료되고 송신자는 혼잡 회피 모드로 들어갑니다. 이는 복구를 시작한 손실된 세그먼트가 확인될 때 종료되는 TCP의 복구 정의와 약간 다릅니다\[RFC5681\].

---
#### **7.3.3.  Congestion Avoidance**

NewReno 발신자는 혼잡 창이 복구 기간이 아닌 느린 시작 임계값 이상일 때마다 혼잡 회피 상태에 있습니다.

혼잡 회피의 발신자는 혼잡 창의 증가를 승인된 각 혼잡 창에 대해 최대 하나의 최대 데이터그램 크기로 제한해야 하는 AIMD\(Additive Growth Multiplicative Decrease\) 접근 방식을 사용합니다.\(MUST\)

패킷이 손실되거나 피어가 보고한 ECN-CE 수가 증가하면 발신자는 혼잡 회피를 종료하고 복구 기간에 들어갑니다.

---
### **7.4.  Ignoring Loss of Undecryptable Packets**

핸드셰이크 중에 패킷이 도착할 때 일부 패킷 보호 키를 사용하지 못할 수 있으며 수신자는 패킷을 삭제하도록 선택할 수 있습니다. 특히 Handshake 및 0-RTT 패킷은 초기 패킷이 도착할 때까지 처리할 수 없으며, 1-RTT 패킷은 Handshake가 완료될 때까지 처리할 수 없습니다. 엔드포인트는 피어가 해당 패킷을 처리하기 위한 패킷 보호 키를 갖기 전에 도착했을 수 있는 핸드셰이크, 0-RTT 및 1-RTT 패킷의 손실을 무시할 수 있습니다. 엔드포인트는 주어진 패킷 번호 공간에서 가장 먼저 확인된 패킷 이후에 전송된 패킷의 손실을 무시해서는 안 됩니다.\(MAY, MUST NOT\)

---
### **7.5.  Probe Timeout**

프로브 패킷은 혼잡 컨트롤러에 의해 차단되어서는 안 됩니다. 그러나 발신자는 이러한 패킷을 추가로 전송 중인 것으로 계산해야 합니다. 이러한 패킷은 패킷 손실 없이 네트워크 부하를 추가하기 때문입니다. 프로브 패킷을 전송하면 패킷 손실 또는 전달을 확인하는 승인이 수신될 때까지 전송 중인 전송자의 바이트가 정체 창을 초과할 수 있습니다.\(MUST NOT, MUST\)

---
### **7.6.  Persistent Congestion**

발신자가 오랜 시간 동안 전송된 모든 패킷의 손실을 확인하면 네트워크에 지속적인 정체가 발생한 것으로 간주됩니다.

---
#### **7.6.1.  Duration**

지속적인 정체 기간은 다음과 같이 계산됩니다.

```text
   (smoothed_rtt + max(4*rttvar, kGranularity) + max_ack_delay) *
       kPersistentCongestionThreshold
```

섹션 6.2의 PTO 계산과 달리 이 기간에는 손실이 설정된 패킷 수 공간에 관계없이 max\_ack\_delay가 포함됩니다.

이 기간을 통해 송신자는 TCP가 Tail Loss Probes \[RFC8985\] 및 RTO \[RFC5681\]에서 수행하는 것처럼 PTO 만료에 대한 응답을 포함하여 지속적인 정체를 설정하기 전에 최대한 많은 패킷을 보낼 수 있습니다.

kPersistantCongestionThreshold 값이 클수록 발신자는 네트워크의 지속적인 정체에 덜 반응하게 되어 정체된 네트워크로 공격적인 전송을 하게 될 수 있습니다. 값이 너무 작으면 발신자가 불필요하게 지속적인 정체를 선언하게 되어 발신자의 처리량이 감소할 수 있습니다.

kPersistantCongestionThreshold의 RECOMMENDED 값은 3이며, 이는 두 개의 TLP 후에 RTO를 선언하는 TCP 발신자와 거의 동일한 동작을 발생시킵니다.\(SHOULD\)

이 설계에서는 애플리케이션 패턴이 PTO 만료에 영향을 미치기 때문에 지속적인 정체를 설정하기 위해 연속적인 PTO 이벤트를 사용하지 않습니다. 예를 들어, 침묵 기간을 두고 소량의 데이터를 전송하는 발신자는 전송할 때마다 PTO 타이머를 다시 시작하므로 승인이 수신되지 않는 경우에도 PTO 타이머가 오랫동안 만료되지 않을 가능성이 있습니다. 기간을 사용하면 발신자가 PTO 만료에 의존하지 않고 지속적인 혼잡을 설정할 수 있습니다.

---
#### **7.6.2.  Establishing Persistent Congestion**

확인을 유도하는 두 개의 패킷이 손실되었다고 선언된 경우 보낸 사람은 확인을 받은 후 지속적인 정체를 설정합니다.

```text
   *  across all packet number spaces, none of the packets sent between
      the send times of these two packets are acknowledged;
```

\* 이 두 패킷의 전송 시간 사이의 지속 시간이 지속적인 혼잡 지속 시간을 초과합니다\(섹션 7.6.1\). 그리고

\* 이 두 패킷이 전송될 때 이전 RTT 샘플이 존재했습니다.

수신기는 최대 승인 지연 내에서 승인을 유도하는 패킷만 승인해야 하므로 이 두 패킷은 반드시 승인을 받아야 합니다. \[QUIC-TRANSPORT\]의 섹션 13.2를 참조하세요.\(MUST\)

지속적인 혼잡 기간은 적어도 하나의 RTT 샘플이 있을 때까지 시작되어서는 안 됩니다. 첫 번째 RTT 샘플 이전에 발신자는 초기 RTT\(섹션 6.2.2\)를 기반으로 PTO 타이머를 활성화합니다. 이는 실제 RTT보다 상당히 클 수 있습니다. 이전 RTT 샘플을 요구하면 발신자가 잠재적으로 너무 적은 수의 프로브로 인해 지속적인 정체를 설정하는 것을 방지할 수 있습니다.\(SHOULD NOT\)

네트워크 정체는 패킷 번호 공간의 영향을 받지 않으므로 지속적인 정체는 패킷 번호 공간을 통해 전송된 패킷을 고려해야 합니다. 모든 패킷 번호 공간에 대한 상태가 없는 발신자 또는 패킷 번호 공간에 걸쳐 전송 시간을 비교할 수 없는 구현은 승인된 패킷 번호 공간에 대해서만 상태를 사용할 수 있습니다. 이로 인해 지속적인 정체가 잘못 선언될 수 있지만 지속적인 정체를 감지하는 데 실패하지는 않습니다.\(SHOULD, MAY\)

지속적인 혼잡이 선언되면 RTO에 대한 TCP 발신자의 응답과 유사하게 발신자의 혼잡 창을 최소 혼잡 창\(kMinimumWindow\)으로 줄여야 합니다\[RFC5681\].\(MUST\)

---
#### **7.6.3.  Example**

다음 예에서는 발신자가 지속적인 정체를 설정하는 방법을 보여줍니다. 추정하다:

```text
   smoothed_rtt + max(4*rttvar, kGranularity) + max_ack_delay = 2
   kPersistentCongestionThreshold = 3
```

다음과 같은 일련의 이벤트를 고려해보세요.

```text
              +========+===================================+
              | Time   | Action                            |
              +========+===================================+
              | t=0    | Send packet #1 (application data) |
              +--------+-----------------------------------+
              | t=1    | Send packet #2 (application data) |
              +--------+-----------------------------------+
              | t=1.2  | Receive acknowledgment of #1      |
              +--------+-----------------------------------+
              | t=2    | Send packet #3 (application data) |
              +--------+-----------------------------------+
              | t=3    | Send packet #4 (application data) |
              +--------+-----------------------------------+
              | t=4    | Send packet #5 (application data) |
              +--------+-----------------------------------+
              | t=5    | Send packet #6 (application data) |
              +--------+-----------------------------------+
              | t=6    | Send packet #7 (application data) |
              +--------+-----------------------------------+
              | t=8    | Send packet #8 (PTO 1)            |
              +--------+-----------------------------------+
              | t=12   | Send packet #9 (PTO 2)            |
              +--------+-----------------------------------+
              | t=12.2 | Receive acknowledgment of #9      |
              +--------+-----------------------------------+

                                 Table 1
```

패킷 2부터 8까지는 패킷 9에 대한 승인이 "t = 12.2"에 수신되면 손실된 것으로 선언됩니다.

정체 기간은 가장 오래되고 가장 최근에 손실된 패킷 사이의 시간\("8 - 1 = 7"\)으로 계산됩니다. 지속적인 혼잡 기간은 "2 \* 3 = 6"입니다. 임계값에 도달했고 가장 오래된 패킷과 가장 최근에 손실된 패킷 사이에 어떤 패킷도 확인되지 않았기 때문에 네트워크에 지속적인 정체가 발생한 것으로 간주됩니다.

이 예에서는 PTO 만료를 보여주지만 지속적인 정체를 설정하는 데에는 PTO 만료가 필요하지 않습니다.

---
### **7.7.  Pacing**

발신자는 혼잡 컨트롤러의 입력을 기반으로 모든 비행 중 패킷의 전송 속도를 조절해야 합니다.\(SHOULD\)

여러 패킷을 지연 없이 네트워크로 보내면 패킷 버스트가 발생하여 단기적인 혼잡과 손실이 발생할 수 있습니다. 발신자는 속도를 사용하거나 이러한 버스트를 제한해야 합니다. 발신자는 버스트를 초기 혼잡 창으로 제한해야 합니다. 섹션 7.2를 참조하세요. 수신자에 대한 네트워크 경로가 더 큰 버스트를 흡수할 수 있다는 것을 알고 있는 발신자는 더 높은 제한을 사용할 수 있습니다.\(MUST, SHOULD, MAY\)

구현에서는 혼잡 컨트롤러가 페이서와 잘 작동하도록 설계하는 데 주의를 기울여야 합니다. 예를 들어, 페이서가 혼잡 컨트롤러를 래핑하고 혼잡 창의 가용성을 제어하거나 페이서가 혼잡 컨트롤러가 전달하는 패킷의 속도를 늦출 수 있습니다.

효율적인 손실 복구를 위해서는 ACK 프레임을 적시에 전달하는 것이 중요합니다. 피어로의 전달 지연을 방지하려면 ACK 프레임만 포함하는 패킷의 속도를 조정해서는 안 됩니다.\(SHOULD\)

엔드포인트는 원하는 대로 속도를 구현할 수 있습니다. 완벽하게 진행되는 발신자는 시간이 지남에 따라 패킷을 정확히 균등하게 분산시킵니다. 이 문서에 있는 것과 같은 창 기반 혼잡 컨트롤러의 경우 해당 속도는 RTT에 대한 혼잡 창을 평균하여 계산할 수 있습니다. 시간당 바이트 단위의 속도로 표시됩니다. 여기서 혼잡 창은 바이트 단위입니다.

```text
   rate = N * congestion_window / smoothed_rtt
```

또는 시간 단위의 패킷 간 간격으로 표현됩니다.

```text
   interval = ( smoothed_rtt * packet_size / congestion_window ) / N
```

작지만 1\(예: 1.25\) 이상의 "N" 값을 사용하면 RTT의 변화로 인해 혼잡 창의 활용도가 낮아지는 일이 발생하지 않습니다.

패킷화, 스케줄링 지연 및 계산 효율성과 같은 실제적인 고려 사항으로 인해 발신자가 RTT보다 훨씬 짧은 기간 동안 이 속도에서 벗어날 수 있습니다.

페이싱을 위한 한 가지 가능한 구현 전략은 누출 버킷 알고리즘을 사용합니다. 여기서 "버킷"의 용량은 최대 버스트 크기로 제한되고 "버킷"이 채우는 속도는 위 함수에 의해 결정됩니다.

---
### **7.8.  Underutilizing the Congestion Window**

전송 중인 바이트가 혼잡 창보다 작고 전송 속도가 제한되지 않으면 혼잡 창이 제대로 활용되지 않습니다. 이는 애플리케이션 데이터가 부족하거나 흐름 제어 제한으로 인해 발생할 수 있습니다. 이런 일이 발생하면 느린 시작이나 혼잡 회피 시 혼잡 창을 늘려서는 안 됩니다.\(SHOULD NOT\)

패킷 속도를 조정하는 발신자\(섹션 7.7 참조\)는 패킷 전송을 지연할 수 있으며 이러한 지연으로 인해 혼잡 창을 완전히 활용하지 못할 수 있습니다. 발신자는 페이싱 지연 없이 혼잡 창을 완전히 활용했다면 자신을 애플리케이션 제한으로 간주해서는 안 됩니다.\(SHOULD NOT\)

발신자는 \[RFC7661\]에서 TCP에 대해 제안된 것과 같이 활용도가 낮은 기간 이후 혼잡 창을 업데이트하기 위한 대체 메커니즘을 구현할 수 있습니다.\(MAY\)

---
## **8.  Security Considerations**
---
### **8.1.  Loss and Congestion Signals**

손실 감지 및 혼잡 제어에는 기본적으로 인증되지 않은 엔터티의 지연, 손실 및 ECN 표시와 같은 신호 소비가 포함됩니다. 공격자는 이러한 신호를 조작하여\(패킷 삭제, 경로 지연을 전략적으로 변경 또는 ECN 코드 포인트 변경\) 엔드포인트의 전송 속도를 낮추도록 할 수 있습니다.

---
### **8.2.  Traffic Analysis**

ACK 프레임만 전달하는 패킷은 패킷 크기를 관찰하여 경험적으로 식별할 수 있습니다. 승인 패턴은 링크 특성이나 애플리케이션 동작에 대한 정보를 노출할 수 있습니다. 유출된 정보를 줄이기 위해 엔드포인트는 승인을 다른 프레임과 번들로 묶거나 잠재적인 성능 저하를 감수하면서 PADDING 프레임을 사용할 수 있습니다.

---
### **8.3.  Misreporting ECN Markings**

수신자는 송신자의 정체 응답을 변경하기 위해 ECN 표시를 잘못 보고할 수 있습니다. ECN-CE 표시 보고를 억제하면 발신자의 전송 속도가 높아질 수 있습니다. 이러한 증가는 혼잡과 손실을 초래할 수 있습니다.

발신자는 ECN-CE 표시와 함께 보내는 비정기적 패킷을 표시하여 보고서 억제를 감지할 수 있습니다. ECN-CE 표시와 함께 전송된 패킷이 패킷이 승인될 때 CE 표시가 표시된 것으로 보고되지 않으면 발신자는 해당 경로에서 전송되는 후속 패킷에서 ECT\(ECN-Capable Transport\) 코드 포인트를 설정하지 않음으로써 해당 경로에 대해 ECN을 비활성화할 수 있습니다. 경로 \[RFC3168\].

추가 ECN-CE 표시를 보고하면 발신자가 전송 속도를 낮추게 됩니다. 이는 감소된 연결 흐름 제어 제한을 광고하는 것과 유사하므로 그렇게 해도 이점이 없습니다.

엔드포인트는 사용하는 혼잡 컨트롤러를 선택합니다. 혼잡 컨트롤러는 속도를 줄여 ECN-CE 보고에 응답하지만 응답은 다를 수 있습니다. 표시는 손실 \[RFC3168\]과 동일하게 처리될 수 있지만 \[RFC8511\] 또는 \[RFC8311\]과 같은 다른 응답을 지정할 수도 있습니다.

---
## **9.  References**
---
### **9.1.  Normative References**

```text
   [QUIC-TLS] Thomson, M., Ed. and S. Turner, Ed., "Using TLS to Secure
              QUIC", RFC 9001, DOI 10.17487/RFC9001, May 2021,
              <https://www.rfc-editor.org/info/rfc9001>.

   [QUIC-TRANSPORT]
              Iyengar, J., Ed. and M. Thomson, Ed., "QUIC: A UDP-Based
              Multiplexed and Secure Transport", RFC 9000,
              DOI 10.17487/RFC9000, May 2021,
              <https://www.rfc-editor.org/info/rfc9000>.

   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", BCP 14, RFC 2119,
              DOI 10.17487/RFC2119, March 1997,
              <https://www.rfc-editor.org/info/rfc2119>.

   [RFC3168]  Ramakrishnan, K., Floyd, S., and D. Black, "The Addition
              of Explicit Congestion Notification (ECN) to IP",
              RFC 3168, DOI 10.17487/RFC3168, September 2001,
              <https://www.rfc-editor.org/info/rfc3168>.

   [RFC8085]  Eggert, L., Fairhurst, G., and G. Shepherd, "UDP Usage
              Guidelines", BCP 145, RFC 8085, DOI 10.17487/RFC8085,
              March 2017, <https://www.rfc-editor.org/info/rfc8085>.

   [RFC8174]  Leiba, B., "Ambiguity of Uppercase vs Lowercase in RFC
              2119 Key Words", BCP 14, RFC 8174, DOI 10.17487/RFC8174,
              May 2017, <https://www.rfc-editor.org/info/rfc8174>.
```

---
### **9.2.  Informative References**

```text
   [FACK]     Mathis, M. and J. Mahdavi, "Forward acknowledgement:
              Refining TCP Congestion Control", ACM SIGCOMM Computer
              Communication Review, DOI 10.1145/248157.248181, August
              1996, <https://doi.org/10.1145/248157.248181>.

   [PRR]      Mathis, M., Dukkipati, N., and Y. Cheng, "Proportional
              Rate Reduction for TCP", RFC 6937, DOI 10.17487/RFC6937,
              May 2013, <https://www.rfc-editor.org/info/rfc6937>.

   [RETRANSMISSION]
              Karn, P. and C. Partridge, "Improving Round-Trip Time
              Estimates in Reliable Transport Protocols", ACM
              Transactions on Computer Systems,
              DOI 10.1145/118544.118549, November 1991,
              <https://doi.org/10.1145/118544.118549>.

   [RFC2018]  Mathis, M., Mahdavi, J., Floyd, S., and A. Romanow, "TCP
              Selective Acknowledgment Options", RFC 2018,
              DOI 10.17487/RFC2018, October 1996,
              <https://www.rfc-editor.org/info/rfc2018>.

   [RFC3465]  Allman, M., "TCP Congestion Control with Appropriate Byte
              Counting (ABC)", RFC 3465, DOI 10.17487/RFC3465, February
              2003, <https://www.rfc-editor.org/info/rfc3465>.

   [RFC5681]  Allman, M., Paxson, V., and E. Blanton, "TCP Congestion
              Control", RFC 5681, DOI 10.17487/RFC5681, September 2009,
              <https://www.rfc-editor.org/info/rfc5681>.

   [RFC5682]  Sarolahti, P., Kojo, M., Yamamoto, K., and M. Hata,
              "Forward RTO-Recovery (F-RTO): An Algorithm for Detecting
              Spurious Retransmission Timeouts with TCP", RFC 5682,
              DOI 10.17487/RFC5682, September 2009,
              <https://www.rfc-editor.org/info/rfc5682>.

   [RFC5827]  Allman, M., Avrachenkov, K., Ayesta, U., Blanton, J., and
              P. Hurtig, "Early Retransmit for TCP and Stream Control
              Transmission Protocol (SCTP)", RFC 5827,
              DOI 10.17487/RFC5827, May 2010,
              <https://www.rfc-editor.org/info/rfc5827>.

   [RFC6298]  Paxson, V., Allman, M., Chu, J., and M. Sargent,
              "Computing TCP's Retransmission Timer", RFC 6298,
              DOI 10.17487/RFC6298, June 2011,
              <https://www.rfc-editor.org/info/rfc6298>.

   [RFC6582]  Henderson, T., Floyd, S., Gurtov, A., and Y. Nishida, "The
              NewReno Modification to TCP's Fast Recovery Algorithm",
              RFC 6582, DOI 10.17487/RFC6582, April 2012,
              <https://www.rfc-editor.org/info/rfc6582>.

   [RFC6675]  Blanton, E., Allman, M., Wang, L., Jarvinen, I., Kojo, M.,
              and Y. Nishida, "A Conservative Loss Recovery Algorithm
              Based on Selective Acknowledgment (SACK) for TCP",
              RFC 6675, DOI 10.17487/RFC6675, August 2012,
              <https://www.rfc-editor.org/info/rfc6675>.

   [RFC6928]  Chu, J., Dukkipati, N., Cheng, Y., and M. Mathis,
              "Increasing TCP's Initial Window", RFC 6928,
              DOI 10.17487/RFC6928, April 2013,
              <https://www.rfc-editor.org/info/rfc6928>.

   [RFC7661]  Fairhurst, G., Sathiaseelan, A., and R. Secchi, "Updating
              TCP to Support Rate-Limited Traffic", RFC 7661,
              DOI 10.17487/RFC7661, October 2015,
              <https://www.rfc-editor.org/info/rfc7661>.

   [RFC8311]  Black, D., "Relaxing Restrictions on Explicit Congestion
              Notification (ECN) Experimentation", RFC 8311,
              DOI 10.17487/RFC8311, January 2018,
              <https://www.rfc-editor.org/info/rfc8311>.

   [RFC8312]  Rhee, I., Xu, L., Ha, S., Zimmermann, A., Eggert, L., and
              R. Scheffenegger, "CUBIC for Fast Long-Distance Networks",
              RFC 8312, DOI 10.17487/RFC8312, February 2018,
              <https://www.rfc-editor.org/info/rfc8312>.

   [RFC8511]  Khademi, N., Welzl, M., Armitage, G., and G. Fairhurst,
              "TCP Alternative Backoff with ECN (ABE)", RFC 8511,
              DOI 10.17487/RFC8511, December 2018,
              <https://www.rfc-editor.org/info/rfc8511>.

   [RFC8985]  Cheng, Y., Cardwell, N., Dukkipati, N., and P. Jha, "The
              RACK-TLP Loss Detection Algorithm for TCP", RFC 8985,
              DOI 10.17487/RFC8985, February 2021,
              <https://www.rfc-editor.org/info/rfc8985>.
```

---
# **Appendix A.  Loss Recovery Pseudocode**

이제 섹션 6에 설명된 손실 감지 메커니즘의 구현 예를 설명합니다.

이 섹션의 의사코드 세그먼트는 코드 구성요소로 라이센스가 부여됩니다. 저작권 고지를 참조하세요.

---
### **A.1.  Tracking Sent Packets**

혼잡 제어를 올바르게 구현하기 위해 QUIC 발신자는 패킷이 승인되거나 손실될 때까지 모든 승인을 유도하는 패킷을 추적합니다. 구현 시 패킷 번호 및 암호화 컨텍스트를 통해 이 정보에 액세스하고 손실 복구 및 혼잡 제어를 위해 패킷별 필드\(부록 A.1.1\)를 저장할 수 있을 것으로 예상됩니다.

패킷이 손실되었다고 선언된 후에도 엔드포인트는 패킷 재정렬을 허용하는 시간 동안 해당 패킷의 상태를 계속 유지할 수 있습니다. \[QUIC-TRANSPORT\]의 섹션 13.3을 참조하세요. 이를 통해 보낸 사람은 가짜 재전송을 감지할 수 있습니다.

전송된 패킷은 각 패킷 번호 공간별로 추적되며 ACK 처리는 단일 공간에만 적용됩니다.

---
#### **A.1.1.  Sent Packet Fields**

packet\_number: 전송된 패킷의 패킷 번호입니다.

ack\_eliciting: 패킷이 승인을 받고 있는지 여부를 나타내는 부울입니다. true인 경우, 승인이 수신될 것으로 예상되지만 피어는 이를 포함하는 ACK 프레임 전송을 최대 max\_ack\_delay까지 지연할 수 있습니다.

in\_flight: 패킷이 전송 중인 바이트에 포함되는지 여부를 나타내는 부울입니다.

sent\_bytes: 패킷에 전송된 바이트 수. UDP 또는 IP 오버헤드는 포함되지 않지만 QUIC 프레이밍 오버헤드는 포함됩니다.

time\_sent: 패킷이 전송된 시간입니다.

---
### **A.2.  Constants of Interest**

손실 복구에 사용되는 상수는 RFC, 논문 및 일반적인 관행의 조합을 기반으로 합니다.

kPacketThreshold: 패킷 임계값 손실 감지가 패킷 손실로 간주하기 전 패킷의 최대 재정렬입니다. 섹션 6.1.1에서 권장되는 값은 3입니다.

kTimeThreshold: 시간 임계값 손실 감지가 패킷 손실로 간주하기 전 시간의 최대 재정렬입니다. RTT 승수로 지정됩니다. 섹션 6.1.2에서 권장되는 값은 9/8입니다.

kGranularity: 타이머 세분성. 이는 시스템에 따라 달라지는 값이며 섹션 6.1.2에서는 1ms 값을 권장합니다.

kInitialRtt: RTT 샘플을 채취하기 전에 사용되는 RTT입니다. 섹션 6.2.2에서 권장되는 값은 333ms입니다.

kPacketNumberSpace: 세 개의 패킷 번호 공간을 열거하는 열거형:

```text
   enum kPacketNumberSpace {
     Initial,
     Handshake,
     ApplicationData,
   }
```

---
### **A.3.  Variables of Interest**

이 절에서는 혼잡 제어 메커니즘을 구현하는 데 필요한 변수에 대해 설명합니다.

최신\_rtt: 이전에 확인되지 않은 패킷에 대한 확인을 수신할 때 수행된 가장 최근 RTT 측정입니다.

smoothed\_rtt: 섹션 5.3에 설명된 대로 계산된 연결의 평활화된 RTT입니다.

rttvar: 섹션 5.3에 설명된 대로 계산된 RTT 변형입니다.

min\_rtt: 섹션 5.2에 설명된 대로 승인 지연을 무시하고 일정 기간 동안 표시되는 최소 RTT입니다.

first\_rtt\_sample: 첫 번째 RTT 샘플을 얻은 시간입니다.

max\_ack\_delay: 시조 전송 매개변수\(\[QUIC-TRANSPORT\]의 섹션 18.2\)에 정의된 대로 수신기가 애플리케이션 데이터 패킷 번호 공간의 패킷에 대한 승인을 지연하려는 최대 시간입니다. 수신된 ACK 프레임의 실제 ack\_delay는 타이머 지연, 재정렬 또는 손실로 인해 더 커질 수 있습니다.

loss\_Detection\_timer: 손실 감지에 사용되는 다중 모드 타이머입니다.

pto\_count: 승인을 받지 않고 PTO가 전송된 횟수입니다.

time\_of\_last\_ack\_eliciting\_packet\[kPacketNumberSpace\]: 가장 최근의 승인 유도 패킷이 전송된 시간입니다.

maximum\_acked\_packet\[kPacketNumberSpace\]: 지금까지 패킷 번호 공간에서 확인된 가장 큰 패킷 번호입니다.

loss\_time\[kPacketNumberSpace\]: 해당 패킷 번호 공간의 다음 패킷이 시간상 재정렬 창을 초과하여 손실된 것으로 간주될 수 있는 시간입니다.

sent\_packets\[kPacketNumberSpace\]: 패킷 번호 공간의 패킷 번호와 이에 대한 정보의 연관입니다. 위의 부록 A.1에 자세히 설명되어 있습니다.

---
### **A.4.  Initialization**

연결 시작 시 다음과 같이 손실 감지 변수를 초기화합니다.

loss\_Detection\_timer.reset\(\) pto\_count = 0 late\_rtt = 0 smoothed\_rtt = kInitialRtt rttvar = kInitialRtt / 2 min\_rtt = 0 first\_rtt\_sample = 0 for pn\_space in \[ 초기, 핸드셰이크, ApplicationData \]: maximum\_acked\_packet\[pn\_space\] = 무한 time\_of\_last\_ack\_eliciting\_packet\[pn\_ 공간\] = 0 loss\_time\[ pn\_공간\] = 0

---
### **A.5.  On Sending a Packet**

패킷이 전송된 후 패킷에 대한 정보가 저장됩니다. OnPacketSent에 대한 매개변수는 위의 부록 A.1.1에 자세히 설명되어 있습니다.

OnPacketSent의 의사코드는 다음과 같습니다.

```text
   OnPacketSent(packet_number, pn_space, ack_eliciting,
                in_flight, sent_bytes):
     sent_packets[pn_space][packet_number].packet_number =
                                              packet_number
     sent_packets[pn_space][packet_number].time_sent = now()
     sent_packets[pn_space][packet_number].ack_eliciting =
                                              ack_eliciting
     sent_packets[pn_space][packet_number].in_flight = in_flight
     sent_packets[pn_space][packet_number].sent_bytes = sent_bytes
     if (in_flight):
       if (ack_eliciting):
         time_of_last_ack_eliciting_packet[pn_space] = now()
       OnPacketSentCC(sent_bytes)
       SetLossDetectionTimer()
```

---
### **A.6.  On Receiving a Datagram**

증폭 방지 제한으로 인해 서버가 차단된 경우 데이터그램의 패킷이 성공적으로 처리되지 않은 경우에도 데이터그램을 수신하면 차단이 해제됩니다. 이러한 경우 PTO 타이머를 재설정해야 합니다.

OnDatagramReceived의 의사코드는 다음과 같습니다.

```text
   OnDatagramReceived(datagram):
     // If this datagram unblocks the server, arm the
     // PTO timer to avoid deadlock.
     if (server was at anti-amplification limit):
       SetLossDetectionTimer()
       if loss_detection_timer.timeout < now():
         // Execute PTO if it would have expired
         // while the amplification limit applied.
         OnLossDetectionTimeout()
```

---
### **A.7.  On Receiving an Acknowledgment**

ACK 프레임이 수신되면 원하는 수의 패킷을 새로 승인할 수 있습니다.

OnAckReceived 및 UpdateRtt에 대한 의사 코드는 다음과 같습니다.

ContainsAckEliciting\(패킷\): 패킷 내 패킷의 경우: if\(packet.ack\_eliciting\): true 반환 false false

```text
   OnAckReceived(ack, pn_space):
     if (largest_acked_packet[pn_space] == infinite):
       largest_acked_packet[pn_space] = ack.largest_acked
     else:
       largest_acked_packet[pn_space] =
           max(largest_acked_packet[pn_space], ack.largest_acked)
```

// DetectAndRemoveAckedPackets는 새로 확인된 패킷을 찾아서 // sent\_packets에서 제거합니다. new\_acked\_packets = DetectAndRemoveAckedPackets\(ack, pn\_space\) // 새로 승인된 패킷이 없으면 아무 작업도 수행하지 않습니다. if \(newly\_acked\_packets.empty\(\)\): 반환

```text
     // Update the RTT if the largest acknowledged is newly acked
     // and at least one ack-eliciting was newly acked.
     if (newly_acked_packets.largest().packet_number ==
             ack.largest_acked &&
         IncludesAckEliciting(newly_acked_packets)):
       latest_rtt =
         now() - newly_acked_packets.largest().time_sent
       UpdateRtt(ack.ack_delay)

     // Process ECN information if present.
     if (ACK frame contains ECN information):
         ProcessECN(ack, pn_space)

     lost_packets = DetectAndRemoveLostPackets(pn_space)
     if (!lost_packets.empty()):
       OnPacketsLost(lost_packets)
     OnPacketsAcked(newly_acked_packets)

     // Reset pto_count unless the client is unsure if
     // the server has validated the client's address.
     if (PeerCompletedAddressValidation()):
       pto_count = 0
     SetLossDetectionTimer()
```

UpdateRtt\(ack\_delay\): if \(first\_rtt\_sample == 0\): min\_rtt = 최신\_rtt smoothed\_rtt = 최신\_rtt rttvar = 최신\_rtt / 2 first\_rtt\_sample = now\(\) return

```text
     // min_rtt ignores acknowledgment delay.
     min_rtt = min(min_rtt, latest_rtt)
     // Limit ack_delay by max_ack_delay after handshake
     // confirmation.
     if (handshake confirmed):
       ack_delay = min(ack_delay, max_ack_delay)
```

// 가능한 경우 승인 지연을 조정합니다. adjust\_rtt = 최신\_rtt if\(latest\_rtt \>= min\_rtt + ack\_delay\): adjust\_rtt = 최신\_rtt - ack\_delay

```text
     rttvar = 3/4 * rttvar + 1/4 * abs(smoothed_rtt - adjusted_rtt)
     smoothed_rtt = 7/8 * smoothed_rtt + 1/8 * adjusted_rtt
```

---
### **A.8.  Setting the Loss Detection Timer**

QUIC 손실 감지는 모든 타임아웃 손실 감지에 단일 타이머를 사용합니다. 타이머의 지속 시간은 타이머 모드에 따라 결정되며, 이는 아래의 패킷 및 타이머 이벤트에서 설정됩니다. 아래에 정의된 SetLossDetectionTimer 함수는 단일 타이머가 어떻게 설정되는지 보여줍니다.

이 알고리즘을 사용하면 특히 타이머가 늦게 깨어나는 경우 타이머가 과거에 설정될 수 있습니다. 과거에 설정된 타이머는 즉시 실행됩니다.

SetLossDetectionTimer의 의사 코드는 다음과 같습니다\(여기서 "^" 연산자는 지수를 나타냄\).

GetLossTimeAndSpace\(\): time = loss\_time\[Initial\] space = \[ Handshake, ApplicationData \]에서 pn\_space의 초기값: if \(time == 0 || loss\_time\[pn\_space\] < time\): time = loss\_time\[pn\_space\]; space = pn\_space 반환 시간, 공간

```text
   GetPtoTimeAndSpace():
     duration = (smoothed_rtt + max(4 * rttvar, kGranularity))
         * (2 ^ pto_count)
     // Anti-deadlock PTO starts from the current time
     if (no ack-eliciting packets in flight):
       assert(!PeerCompletedAddressValidation())
       if (has handshake keys):
         return (now() + duration), Handshake
       else:
         return (now() + duration), Initial
     pto_timeout = infinite
     pto_space = Initial
     for space in [ Initial, Handshake, ApplicationData ]:
       if (no ack-eliciting packets in flight in space):
           continue;
       if (space == ApplicationData):
         // Skip Application Data until handshake confirmed.
         if (handshake is not confirmed):
           return pto_timeout, pto_space
         // Include max_ack_delay and backoff for Application Data.
         duration += max_ack_delay * (2 ^ pto_count)

       t = time_of_last_ack_eliciting_packet[space] + duration
       if (t < pto_timeout):
         pto_timeout = t
         pto_space = space
     return pto_timeout, pto_space
```

PeerCompletedAddressValidation\(\): // 클라이언트가 서버 주소를 암시적으로 검증한다고 가정합니다. if \(endpoint is server\): return true // 보호된 패킷이 수신되면 서버는 // 주소 유효성 검사를 완료합니다. 반환이 Handshake ACK를 받았습니다 || 악수 확인됨

SetLossDetectionTimer\(\): early\_loss\_time, \_ = GetLossTimeAndSpace\(\) if \(earliest\_loss\_time != 0\): // 시간 임계값 손실 감지. loss\_Detection\_timer.update\(earliest\_loss\_time\) 반환

```text
     if (server is at anti-amplification limit):
       // The server's timer is not set if nothing can be sent.
       loss_detection_timer.cancel()
       return

     if (no ack-eliciting packets in flight &&
         PeerCompletedAddressValidation()):
       // There is nothing to detect lost, so no timer is set.
       // However, the client needs to arm the timer if the
       // server might be blocked by the anti-amplification limit.
       loss_detection_timer.cancel()
       return

     timeout, _ = GetPtoTimeAndSpace()
     loss_detection_timer.update(timeout)
```

---
### **A.9.  On Timeout**

손실 감지 타이머가 만료되면 타이머 모드에 따라 수행할 작업이 결정됩니다.

OnLossDetectionTimeout의 의사코드는 다음과 같습니다.

OnLossDetectionTimeout\(\): early\_loss\_time, pn\_space = GetLossTimeAndSpace\(\) if \(earliest\_loss\_time != 0\): // 시간 임계값 손실 감지 loss\_packets = DetectAndRemoveLostPackets\(pn\_space\)assert\(!lost\_packets.empty\(\)\) OnPacketsLost\(lost\_packets\) SetLossDetectionTimer\(\) return

```text
     if (no ack-eliciting packets in flight):
       assert(!PeerCompletedAddressValidation())
       // Client sends an anti-deadlock packet: Initial is padded
       // to earn more anti-amplification credit,
       // a Handshake packet proves address ownership.
       if (has Handshake keys):
         SendOneAckElicitingHandshakePacket()
       else:
         SendOneAckElicitingPaddedInitialPacket()
     else:
       // PTO. Send new data if available, else retransmit old data.
       // If neither is available, send a single PING frame.
       _, pn_space = GetPtoTimeAndSpace()
       SendOneOrTwoAckElicitingPackets(pn_space)

     pto_count++
     SetLossDetectionTimer()
```

---
### **A.10.  Detecting Lost Packets**

DetectAndRemoveLostPackets는 ACK가 수신되거나 시간 임계값 손실 감지 타이머가 만료될 때마다 호출됩니다. 이 함수는 해당 패킷 번호 공간에 대한 sent\_packets에서 작동하고 손실된 것으로 새로 감지된 패킷 목록을 반환합니다.

DetectAndRemoveLostPackets의 의사코드는 다음과 같습니다.

```text
   DetectAndRemoveLostPackets(pn_space):
     assert(largest_acked_packet[pn_space] != infinite)
     loss_time[pn_space] = 0
     lost_packets = []
     loss_delay = kTimeThreshold * max(latest_rtt, smoothed_rtt)

     // Minimum time of kGranularity before packets are deemed lost.
     loss_delay = max(loss_delay, kGranularity)
```

// 이 시간 이전에 전송된 패킷은 손실된 것으로 간주됩니다. Lost\_send\_time = 지금\(\) - loss\_delay

```text
     foreach unacked in sent_packets[pn_space]:
       if (unacked.packet_number > largest_acked_packet[pn_space]):
         continue
```

- // 패킷을 손실된 것으로 표시하거나 표시해야 하는 시간을 설정합니다. // 참고: 여기서 kPacketThreshold를 사용하려면 // 패킷 번호 공간에 발신자가 유발한 간격이 없다고 가정합니다. if \(unacked.time\_sent <= loss\_send\_time || maximum\_acked\_packet\[pn\_space\] \>= unacked.packet\_number + kPacketThreshold\): sent\_packets\[pn\_space\].remove\(unacked.packet\_number\) loss\_packets.insert\(unacked\) else: if \(loss\_time\[pn\_space\] == 0\): loss\_time\[pn\_space\] = unacked.time\_sent + loss\_delay else: loss\_time\[pn\_space\] = min\(loss\_time\[pn\_space\], unacked.time\_sent + loss\_delay\) loss\_packets 반환

---
### **A.11.  Upon Dropping Initial or Handshake Keys**

초기 또는 핸드셰이크 키가 삭제되면 해당 공간의 패킷이 삭제되고 손실 감지 상태가 업데이트됩니다.

OnPacketNumberSpaceDiscarded에 대한 의사 코드는 다음과 같습니다.

```text
   OnPacketNumberSpaceDiscarded(pn_space):
     assert(pn_space != ApplicationData)
     RemoveFromBytesInFlight(sent_packets[pn_space])
     sent_packets[pn_space].clear()
     // Reset the loss detection and PTO timer
     time_of_last_ack_eliciting_packet[pn_space] = 0
     loss_time[pn_space] = 0
     pto_count = 0
     SetLossDetectionTimer()
```

---
# **Appendix B.  Congestion Control Pseudocode**

이제 섹션 7에 설명된 혼잡 컨트롤러의 구현 예를 설명합니다.

이 섹션의 의사코드 세그먼트는 코드 구성요소로 라이센스가 부여됩니다. 저작권 고지를 참조하세요.

---
### **B.1.  Constants of Interest**

혼잡 제어에 사용되는 상수는 RFC, 논문 및 일반적인 관행의 조합을 기반으로 합니다.

kInitialWindow: 섹션 7.2에 설명된 대로 전송 중인 초기 바이트에 대한 기본 제한입니다.

kMinimumWindow: 섹션 7.2에 설명된 대로 바이트 단위의 최소 혼잡 창입니다.

kLossReductionFactor: 손실을 줄이기 위해 적용되는 스케일링 요소

- 새로운 손실 이벤트가 감지되는 혼잡 기간. 섹션 7에서는 0.5의 값을 권장합니다.

kPertantCongestionThreshold: 지속적인 정체가 설정되는 기간으로, PTO 승수로 지정됩니다. 섹션 7.6에서는 값 3을 권장합니다.

---
### **B.2.  Variables of Interest**

이 절에서는 혼잡 제어 메커니즘을 구현하는 데 필요한 변수에 대해 설명합니다.

max\_datagram\_size: 발신자의 현재 최대 페이로드 크기입니다. 여기에는 UDP 또는 IP 오버헤드가 포함되지 않습니다. 최대 데이터그램 크기는 혼잡 창 계산에 사용됩니다. 엔드포인트는 경로 최대 전송 단위\(PMTU; \[QUIC-TRANSPORT\]의 섹션 14.2 참조\)를 기반으로 이 변수의 값을 최소값 1200바이트로 설정합니다.

ecn\_ce\_counters\[kPacketNumberSpace\]: ACK 프레임에서 피어가 패킷 번호 공간에서 ECN-CE 카운터에 대해 보고한 가장 높은 값입니다. 이 값은 보고된 ECN-CE 카운터의 증가를 감지하는 데 사용됩니다.

bytes\_in\_flight: 최소한 하나의 승인 유도 또는 PADDING 프레임을 포함하고 승인되지 않았거나 손실되었다고 선언되지 않은 모든 전송된 패킷의 크기\(바이트\)의 합계입니다. 크기에는 IP 또는 UDP 오버헤드가 포함되지 않지만 QUIC 헤더 및 AEAD\(Authenticated Encryption with Associated Data\) 오버헤드는 포함됩니다. ACK 프레임만 포함하는 패킷은 혼잡 제어가 혼잡 피드백을 방해하지 않도록 하기 위해 bytes\_in\_flight에 포함되지 않습니다.

혼잡\_창: 비행 중에 허용되는 최대 바이트 수입니다.

혼잡\_복구\_시작\_시간: 손실 또는 ECN 감지로 인해 현재 복구 기간이 시작된 시간입니다. 이 시간 이후에 전송된 패킷이 확인되면 QUIC는 혼잡 복구를 종료합니다.

ssthresh: 느린 시작 임계값\(바이트\)입니다. 혼잡 창이 ssthresh 미만인 경우 모드는 느린 시작이고 창은 승인된 바이트 수만큼 커집니다.

혼잡 제어 의사코드는 손실 복구 의사코드의 일부 변수에도 액세스합니다.

---
### **B.3.  Initialization**

연결 시작 시 다음과 같이 혼잡 제어 변수를 초기화합니다.

혼잡\_창 = kInitialWindow bytes\_in\_flight = 0 혼잡\_recovery\_start\_time = 0 ssthresh = \[ 초기, 핸드셰이크, ApplicationData \]의 pn\_space에 대해 무한: ecn\_ce\_counters\[pn\_space\] = 0

---
### **B.4.  On Packet Sent**

패킷이 전송되고 여기에 비ACK 프레임이 포함되어 있을 때마다 패킷의 bytes\_in\_flight가 늘어납니다.

```text
   OnPacketSentCC(sent_bytes):
     bytes_in_flight += sent_bytes
```

---
### **B.5.  On Packet Acknowledgment**

이는 손실 감지의 OnAckReceived에서 호출되며 sent\_packets의 새로 acked\_packets와 함께 제공됩니다.

혼잡 회피에서 혼잡\_창에 정수 표현을 사용하는 구현자는 분할에 주의해야 하며 \[RFC3465\]의 섹션 2.1에 제안된 대체 접근 방식을 사용할 수 있습니다.

```text
   InCongestionRecovery(sent_time):
     return sent_time <= congestion_recovery_start_time

   OnPacketsAcked(acked_packets):
     for acked_packet in acked_packets:
       OnPacketAcked(acked_packet)
```

OnPacketAcked\(acked\_packet\): if \(!acked\_packet.in\_flight\): return; // bytes\_in\_flight에서 제거합니다. bytes\_in\_flight -= acked\_packet.sent\_bytes // 애플리케이션이 제한되거나 흐름 제어가 제한된 경우 혼잡\_창을 늘리지 마십시오. if \(IsAppOrFlowControlLimited\(\)\) return // 복구 기간 동안 정체 기간을 늘리지 않습니다. if \(InCongestionRecovery\(acked\_packet.time\_sent\)\): return if \(congestion\_window < ssthresh\): // 느린 시작. 혼잡\_window += acked\_packet.sent\_bytes else: // 혼잡 회피. 혼잡\_창 += max\_datagram\_size \* acked\_packet.sent\_bytes / 혼잡\_창

---
### **B.6.  On New Congestion Event**

이는 새로운 혼잡 이벤트가 감지되면 ProcessECN 및 OnPacketsLost에서 호출됩니다. 아직 복구 중이 아닌 경우 복구 기간이 시작되고 느린 시작 임계값과 정체 기간이 즉시 줄어듭니다.

OnCongestionEvent\(sent\_time\): // 이미 복구 기간에 있는 경우 반응이 없습니다. if\(InCongestionRecovery\(sent\_time\)\): 반환

```text
     // Enter recovery period.
     congestion_recovery_start_time = now()
     ssthresh = congestion_window * kLossReductionFactor
     congestion_window = max(ssthresh, kMinimumWindow)
     // A packet can be sent to speed up loss recovery.
     MaybeSendOnePacket()
```

---
### **B.7.  Process ECN Information**

이는 ECN 섹션이 있는 ACK 프레임이 피어로부터 수신될 때 호출됩니다.

```text
   ProcessECN(ack, pn_space):
     // If the ECN-CE counter reported by the peer has increased,
     // this could be a new congestion event.
     if (ack.ce_counter > ecn_ce_counters[pn_space]):
       ecn_ce_counters[pn_space] = ack.ce_counter
       sent_time = sent_packets[ack.largest_acked].time_sent
       OnCongestionEvent(sent_time)
```

---
### **B.8.  On Packets Lost**

이는 DetectAndRemoveLostPackets가 패킷이 손실된 것으로 간주할 때 호출됩니다.

```text
   OnPacketsLost(lost_packets):
     sent_time_of_last_loss = 0
     // Remove lost packets from bytes_in_flight.
     for lost_packet in lost_packets:
       if lost_packet.in_flight:
         bytes_in_flight -= lost_packet.sent_bytes
         sent_time_of_last_loss =
           max(sent_time_of_last_loss, lost_packet.time_sent)
     // Congestion event if in-flight packets were lost
     if (sent_time_of_last_loss != 0):
       OnCongestionEvent(sent_time_of_last_loss)
```

// 이러한 패킷의 손실이 지속적인 정체를 나타내는 경우 // 정체 창을 재설정합니다. // RTT 샘플을 얻은 후에 전송된 패킷만 고려합니다. if \(first\_rtt\_sample == 0\): loss\_packets에서 손실된 경우 pc\_lost = \[\]를 반환합니다. if loss.time\_sent \> first\_rtt\_sample: pc\_lost.insert\(lost\) if \(InPerciousCongestion\(pc\_lost\)\): 혼잡\_window = kMinimumWindow 혼잡\_복구\_start\_time = 0

---
### **B.9.  Removing Discarded Packets from Bytes in Flight**

초기 또는 핸드셰이크 키가 삭제되면 해당 공간으로 전송된 패킷은 더 이상 전송 중인 바이트에 포함되지 않습니다.

RemoveFromBytesInFlight의 의사 코드는 다음과 같습니다.

RemoveFromBytesInFlight\(discarded\_packets\): // 비행에서 확인되지 않은 패킷을 제거합니다. Discarded\_packets의 foreach 패킷: packet.in\_flight bytes\_in\_flight -= 크기인 경우

---
# **Contributors**

IETF QUIC 워킹 그룹은 많은 사람들로부터 엄청난 지원을 받았습니다. 다음 사람들은 이 문서에 상당한 기여를 했습니다.

```text
   *  Alessandro Ghedini
   *  Benjamin Saunders
   *  Gorry Fairhurst
   *  山本和彦 (Kazu Yamamoto)
   *  奥 一穂 (Kazuho Oku)
   *  Lars Eggert
   *  Magnus Westerlund
   *  Marten Seemann
   *  Martin Duke
   *  Martin Thomson
   *  Mirja Kühlewind
   *  Nick Banks
   *  Praveen Balasubramanian
```

---
# **Authors' Addresses**

```text
   Jana Iyengar (editor)
   Fastly

   Email: jri.ietf@gmail.com

   Ian Swett (editor)
   Google

   Email: ianswett@google.com
```
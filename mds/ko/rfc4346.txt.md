

```text
Network Working Group                                          T. Dierks
Request for Comments: 4346                                   Independent
Obsoletes: 2246                                              E. Rescorla
Category: Standards Track                                     RTFM, Inc.
                                                              April 2006

              The Transport Layer Security (TLS) Protocol
                              Version 1.1
```

---
# **Status of This Memo**

이 문서는 인터넷 커뮤니티를 위한 인터넷 표준 추적 프로토콜을 지정하고 개선을 위한 토론 및 제안을 요청합니다. 이 프로토콜의 표준화 상태 및 상태에 대해서는 "Internet Official Protocol Standards"\(STD 1\) 최신판을 참조하십시오. 이 메모의 배포는 무제한입니다.

---
# **Copyright Notice**

Copyright \(C\) The Internet Society \(2006\).

---
# **Abstract**

이 문서는 TLS\(Transport Layer Security\) 프로토콜의 버전 1.1을 지정합니다. TLS 프로토콜은 인터넷을 통한 통신 보안을 제공합니다. 이 프로토콜을 사용하면 클라이언트/서버 애플리케이션이 도청, 변조 또는 메시지 위조를 방지하도록 설계된 방식으로 통신할 수 있습니다.

---
# **Table of Contents**

```text
   1. Introduction ....................................................4
      1.1. Differences from TLS 1.0 ...................................5
      1.2. Requirements Terminology ...................................5
   2. Goals ...........................................................5
   3. Goals of This Document ..........................................6
   4. Presentation Language ...........................................6
      4.1. Basic Block Size ...........................................7
      4.2. Miscellaneous ..............................................7
      4.3. Vectors ....................................................7
      4.4. Numbers ....................................................8
      4.5. Enumerateds ................................................8
      4.6. Constructed Types ..........................................9
           4.6.1. Variants ...........................................10
      4.7. Cryptographic Attributes ..................................11
      4.8. Constants .................................................12
   5. HMAC and the Pseudorandom Function .............................12
   6. The TLS Record Protocol ........................................14
      6.1. Connection States .........................................15
      6.2. Record layer ..............................................17
           6.2.1. Fragmentation ......................................17
           6.2.2. Record Compression and Decompression ...............19
           6.2.3. Record Payload Protection ..........................19
                  6.2.3.1. Null or Standard Stream Cipher ............20
                  6.2.3.2. CBC Block Cipher ..........................21
      6.3. Key Calculation ...........................................24
   7. The TLS Handshaking Protocols ..................................24
      7.1. Change Cipher Spec Protocol ...............................25
      7.2. Alert Protocol ............................................26
           7.2.1. Closure Alerts .....................................27
           7.2.2. Error Alerts .......................................28
      7.3. Handshake Protocol Overview ...............................31
      7.4. Handshake Protocol ........................................34
           7.4.1. Hello Messages .....................................35
                  7.4.1.1. Hello request .............................35
                  7.4.1.2. Client Hello ..............................36
                  7.4.1.3. Server Hello ..............................39
           7.4.2. Server Certificate .................................40
           7.4.3. Server Key Exchange Message ........................42
           7.4.4. Certificate request ................................44
           7.4.5. Server Hello Done ..................................46
           7.4.6. Client certificate .................................46
           7.4.7. Client Key Exchange Message ........................47
                  7.4.7.1. RSA Encrypted Premaster Secret Message ....47
                  7.4.7.2. Client Diffie-Hellman Public Value ........50
           7.4.8. Certificate verify .................................50
           7.4.9. Finished ...........................................51
   8. Cryptographic Computations .....................................52
      8.1. Computing the Master Secret ...............................52
           8.1.1. RSA ................................................53
           8.1.2. Diffie-Hellman .....................................53
   9. Mandatory Cipher Suites ........................................53
   10. Application Data Protocol .....................................53
   11. Security Considerations .......................................53
   12. IANA Considerations ...........................................54
   A. Appendix - Protocol constant values ............................55
           A.1. Record layer .........................................55
           A.2. Change cipher specs message ..........................56
           A.3. Alert messages .......................................56
           A.4. Handshake protocol ...................................57
           A.4.1. Hello messages .....................................57
           A.4.2. Server authentication and key exchange messages ....58
           A.4.3. Client authentication and key exchange messages ....59
           A.4.4.Handshake finalization message ......................60
           A.5. The CipherSuite ......................................60
           A.6. The Security Parameters ..............................63
   B. Appendix - Glossary ............................................64
   C. Appendix - CipherSuite definitions .............................68
   D. Appendix - Implementation Notes ................................69
           D.1 Random Number Generation and Seeding ..................70
           D.2 Certificates and authentication .......................70
           D.3 CipherSuites ..........................................70
   E. Appendix - Backward Compatibility With SSL .....................71
           E.1. Version 2 client hello ...............................72
           E.2. Avoiding man-in-the-middle version rollback ..........74
   F. Appendix - Security analysis ...................................74
           F.1. Handshake protocol ...................................74
           F.1.1. Authentication and key exchange ....................74
           F.1.1.1. Anonymous key exchange ...........................75
           F.1.1.2. RSA key exchange and authentication ..............75
           F.1.1.3. Diffie-Hellman key exchange with authentication ..76
           F.1.2. Version rollback attacks ...........................77
           F.1.3. Detecting attacks against the handshake protocol ...77
           F.1.4. Resuming sessions ..................................78
           F.1.5. MD5 and SHA ........................................78
           F.2. Protecting application data ..........................78
           F.3. Explicit IVs .........................................79
           F.4  Security of Composite Cipher Modes ...................79
           F.5  Denial of Service ....................................80
           F.6. Final notes ..........................................80
   Normative References ..............................................81
   Informative References ............................................82
```

---
## **1. Introduction**

TLS 프로토콜의 주요 목표는 통신하는 두 응용 프로그램 간에 개인 정보 보호 및 데이터 무결성을 제공하는 것입니다. 프로토콜은 TLS 레코드 프로토콜과 TLS 핸드셰이크 프로토콜의 두 계층으로 구성됩니다. 신뢰할 수 있는 전송 프로토콜\(예: TCP\[TCP\]\) 위에 계층화된 가장 낮은 수준은 TLS 레코드 프로토콜입니다. TLS 레코드 프로토콜은 두 가지 기본 속성이 있는 연결 보안을 제공합니다.

- 연결은 비공개입니다. 대칭 암호화는 데이터 암호화에 사용됩니다\(예: DES\[DES\], RC4\[SCH\] 등\). 이 대칭 암호화의 키는 각 연결에 대해 고유하게 생성되며 다른 프로토콜\(예: TLS 핸드셰이크 프로토콜\)에서 협상한 비밀을 기반으로 합니다. 레코드 프로토콜은 암호화 없이도 사용할 수 있습니다.

- 연결이 안정적입니다. 메시지 전송에는 키가 있는 MAC을 사용하는 메시지 무결성 검사가 포함됩니다. 보안 해시 함수\(예: SHA, MD5 등\)는 MAC 계산에 사용됩니다. 레코드 프로토콜은 MAC 없이 작동할 수 있지만 일반적으로 다른 프로토콜이 보안 매개변수 협상을 위한 전송으로 레코드 프로토콜을 사용하는 동안 이 모드에서만 사용됩니다.

TLS 레코드 프로토콜은 다양한 상위 수준 프로토콜의 캡슐화에 사용됩니다. 이러한 캡슐화된 프로토콜 중 하나인 TLS 핸드셰이크 프로토콜을 사용하면 서버와 클라이언트가 서로를 인증하고 애플리케이션 프로토콜이 데이터의 첫 번째 바이트를 전송하거나 수신하기 전에 암호화 알고리즘과 암호화 키를 협상할 수 있습니다. TLS 핸드셰이크 프로토콜은 세 가지 기본 속성이 있는 연결 보안을 제공합니다.

- 피어의 신원은 비대칭 또는 공개 키, 암호화\(예: RSA\[RSA\], DSS\[DSS\] 등\)를 사용하여 인증될 수 있습니다. 이 인증은 선택 사항으로 만들 수 있지만 일반적으로 피어 중 하나 이상에 필요합니다.

- 공유 비밀의 협상은 안전합니다. 협상된 비밀은 도청자가 사용할 수 없으며 인증된 연결의 경우 연결 중간에 자신을 배치할 수 있는 공격자도 비밀을 얻을 수 없습니다.

- 협상이 신뢰할 수 있음: 공격자가 협상을 수정할 수 없음

- 통신 당사자가 감지하지 못하는 협상 통신.

TLS의 한 가지 장점은 응용 프로그램 프로토콜에 독립적이라는 것입니다. 더 높은 수준의 프로토콜은 TLS 프로토콜 위에 계층화될 수 있습니다.

투명하게. 그러나 TLS 표준은 프로토콜이 TLS로 보안을 추가하는 방법을 지정하지 않습니다. TLS 핸드셰이킹을 시작하는 방법과 교환된 인증 인증서를 해석하는 방법에 대한 결정은 TLS에서 실행되는 프로토콜의 설계자와 구현자의 판단에 맡겨집니다.

---
### **1.1. Differences from TLS 1.0**

이 문서는 TLS 1.0\[TLS1.0\] 프로토콜의 개정판이며 일부 작은 보안 개선 사항, 설명 및 편집 개선 사항이 포함되어 있습니다. 주요 변경 사항은 다음과 같습니다.

- 암시적 초기화 벡터\(IV\)는 CBC 공격\[CBCATT\]으로부터 보호하기 위해 명시적 IV로 대체됩니다.

- CBC 공격으로부터 보호하기 위해 decryption\_failed 경고 대신 bad\_record\_mac 경고를 사용하도록 패딩 오류 처리가 변경되었습니다.

- IANA 레지스트리는 프로토콜 매개변수에 대해 정의됩니다.

- 조기 종료로 인해 더 이상 세션을 재개할 수 없게 되지 않습니다.

- TLS에 대한 다양한 새로운 공격에 대한 추가 정보 노트가 추가되었습니다.

또한 여러 가지 사소한 설명과 편집상의 개선이 이루어졌습니다.

---
### **1.2. Requirements Terminology**

이 문서에서 키워드 "MUST", "MUST NOT", "REQUIRED", "SHOULD", "SHOULD NOT" 및 "MAY"는 RFC 2119 \[REQ\]에 설명된 대로 해석됩니다.\(MUST NOT\)

---
## **2. Goals**

TLS 프로토콜의 목표는 우선 순위에 따라 다음과 같습니다.

1. 암호화 보안: TLS를 사용하여 두 당사자 간의 보안 연결을 설정해야 합니다.

2. 상호 운용성: 독립적인 프로그래머는 서로의 코드를 몰라도 암호화 매개변수를 성공적으로 교환할 수 있는 TLS를 활용하는 애플리케이션을 개발할 수 있어야 합니다.

3. 확장성: TLS는 필요에 따라 새로운 공개 키 및 대량 암호화 방법을 통합할 수 있는 프레임워크를 제공하려고 합니다. 이것은 또한 두 가지 하위 목표를 달성할 것입니다. 새로운 프로토콜을 생성할 필요성을 방지하고\(및 가능한 새로운 약점의 도입 위험\) 완전히 새로운 보안 라이브러리를 구현해야 할 필요성을 방지합니다.

4. 상대적 효율성: 암호화 작업은 특히 공개 키 작업과 같이 CPU를 많이 사용하는 경향이 있습니다. 이러한 이유로 TLS 프로토콜은 선택적 세션 캐싱 체계를 통합하여 처음부터 설정해야 하는 연결 수를 줄입니다. 또한 네트워크 활동을 줄이기 위해 주의를 기울였습니다.

---
## **3. Goals of This Document**

이 문서와 TLS 프로토콜 자체는 Netscape에서 게시한 SSL 3.0 프로토콜 사양을 기반으로 합니다. 이 프로토콜과 SSL 3.0의 차이점은 극적이지는 않지만 TLS 1.1, TLS 1.0 및 SSL 3.0이 상호 운용되지 않을 만큼 충분히 중요합니다\(각 프로토콜에는 구현이 이전 버전을 되돌릴 수 있는 메커니즘이 통합되어 있지만\). 이 문서는 주로 프로토콜을 구현하려는 독자와 이에 대한 암호화 분석을 수행하는 독자를 대상으로 합니다. 사양은 이를 염두에 두고 작성되었으며 이 두 그룹의 요구 사항을 반영하기 위한 것입니다. 이러한 이유로 많은 알고리즘 종속 데이터 구조 및 규칙이 텍스트 본문에 포함되어\(부록과는 반대로\) 더 쉽게 액세스할 수 있습니다.

이 문서는 서비스 정의 또는 인터페이스 정의에 대한 세부 정보를 제공하기 위한 것이 아니지만 견고한 보안 유지에 필요한 정책의 일부 영역을 다루고 있습니다.

---
## **4. Presentation Language**

이 문서는 외부 표현의 데이터 형식을 다룹니다. 다음의 매우 기본적이고 다소 캐주얼하게 정의된 프레젠테이션 구문이 사용됩니다. 구문은 구조의 여러 소스에서 가져옵니다. 구문에서 프로그래밍 언어 "C"와 구문 및 의도에서 XDR\[XDR\]과 유사하지만 너무 많은 유사점을 그리는 것은 위험합니다. 이 표현 언어의 목적은 TLS만을 문서화하는 것입니다. 특정 목표를 넘어서는 일반적인 적용은 없습니다.

---
### **4.1. Basic Block Size**

모든 데이터 항목의 표현은 명시적으로 지정됩니다. 기본 데이터 블록 크기는 1바이트\(즉, 8비트\)입니다. 다중 바이트 데이터 항목은 왼쪽에서 오른쪽으로, 위에서 아래로 바이트를 연결한 것입니다. 바이트스트림에서 멀티바이트 항목\(예제에서는 숫자\)은 다음과 같이 구성됩니다\(C 표기법 사용\).

```text
       value = (byte[0] << 8*(n-1)) | (byte[1] << 8*(n-2)) |
               ... | byte[n-1];
```

멀티바이트 값에 대한 이 바이트 순서는 일반적인 네트워크 바이트 순서 또는 빅 엔디안 형식입니다.

---
### **4.2. Miscellaneous**

주석은 "/\*"로 시작하고 "\*/"로 끝납니다.

선택적 구성 요소는 "\[\[ \]\]" 이중 괄호로 묶어서 표시합니다.

해석되지 않은 데이터를 포함하는 1바이트 엔터티는 불투명한 유형입니다.

---
### **4.3. Vectors**

벡터\(단일 차원 배열\)는 동종 데이터 요소의 스트림입니다. 벡터의 크기는 문서화 시 지정되거나 런타임까지 지정되지 않은 상태로 남을 수 있습니다. 두 경우 모두 길이는 벡터의 요소 수가 아니라 바이트 수를 선언합니다. 유형 T의 고정 길이 벡터인 새 유형 T'를 지정하기 위한 구문은 다음과 같습니다.

```text
       T T'[n];
```

여기서 T'는 데이터 스트림에서 n바이트를 차지하며, 여기서 n은 T 크기의 배수입니다. 벡터의 길이는 인코딩된 스트림에 포함되지 않습니다.

다음 예에서 Datum은 프로토콜이 해석하지 않는 3개의 연속 바이트로 정의되는 반면 Data는 3개의 연속 Datum으로 총 9바이트를 소비합니다.

```text
       opaque Datum[3];      /* three uninterpreted bytes */
       Datum Data[9];        /* 3 consecutive 3 byte vectors */
```

가변 길이 벡터는 <floor..ceiling\> 표기법을 사용하여 법적 길이의 하위 범위를 지정하여 정의됩니다. 언제

이들은 인코딩되며 실제 길이는 바이트 스트림에서 벡터의 내용 앞에 옵니다. 길이는 벡터의 지정된 최대\(천장\) 길이를 유지하는 데 필요한 만큼의 바이트를 소비하는 숫자 형식입니다. 실제 길이 필드가 0인 가변 길이 벡터를 빈 벡터라고 합니다.

```text
       T T'<floor..ceiling>;
```

다음 예에서 필수는 불투명 유형의 300\~400바이트를 포함해야 하는 벡터입니다. 절대 비워둘 수 없습니다. 실제 길이 필드는 값 400을 나타내기에 충분한 uint16인 2바이트를 사용합니다\(섹션 4.4 참조\). 반면 long은 최대 800바이트의 데이터 또는 400개의 uint16 요소를 나타낼 수 있으며 비어 있을 수 있습니다. 해당 인코딩에는 벡터 앞에 추가된 2바이트 실제 길이 필드가 포함됩니다. 인코딩된 벡터의 길이는 단일 요소 길이의 짝수 배수여야 합니다\(예: uint16의 17바이트 벡터는 불법임\).

```text
       opaque mandatory<300..400>;
             /* length field is 2 bytes, cannot be empty */
       uint16 longer<0..800>;
             /* zero to 400 16-bit unsigned integers */
```

---
### **4.4. Numbers**

기본 숫자 데이터 유형은 부호 없는 바이트\(uint8\)입니다. 모든 더 큰 숫자 데이터 유형은 섹션 4.1에 설명된 대로 연결된 고정 길이 일련의 바이트로 구성되며 부호도 없습니다. 다음 숫자 유형은 미리 정의되어 있습니다.

```text
       uint8 uint16[2];
       uint8 uint24[3];
       uint8 uint32[4];
       uint8 uint64[8];
```

여기와 사양의 다른 곳에서 모든 값은 "네트워크" 또는 "big-endian" 순서로 저장됩니다. 16진수 바이트 01 02 03 04로 표시되는 uint32는 10진수 값 16909060과 동일합니다.

---
### **4.5. Enumerateds**

enum이라는 추가 희소 데이터 유형을 사용할 수 있습니다. enum 유형의 필드는 정의에서 선언된 값만 가정할 수 있습니다. 각 정의는 다른 유형입니다. 동일한 유형의 열거형만 할당하거나 비교할 수 있습니다. 열거형의 모든 요소에는 다음 예제와 같이 값이 할당되어야 합니다. 열거된 요소는 순서가 없기 때문에 순서에 관계없이 고유한 값을 할당할 수 있습니다.

```text
       enum { e1(v1), e2(v2), ... , en(vn) [[, (n)]] } Te;
```

열거형은 정의된 최대 서수 값만큼 바이트 스트림에서 많은 공간을 차지합니다. 다음 정의는 색상 유형의 필드를 전달하는 데 1바이트가 사용되도록 합니다.

```text
       enum { red(3), blue(5), white(7) } Color;
```

선택적으로 관련 태그 없이 값을 지정하여 불필요한 요소를 정의하지 않고 너비 정의를 강제할 수 있습니다. 다음 예에서 Taste는 데이터 스트림에서 2바이트를 소비하지만 값 1, 2 또는 4만 가정할 수 있습니다.

```text
       enum { sweet(1), sour(2), bitter(4), (32000) } Taste;
```

열거형 요소의 이름은 정의된 유형 내에서 범위가 지정됩니다. 첫 번째 예에서 열거형의 두 번째 요소에 대한 정규화된 참조는 Color.blue입니다. 과제의 대상이 잘 지정된 경우에는 이러한 자격이 필요하지 않습니다.

```text
       Color color = Color.blue;     /* overspecified, legal */
       Color color = blue;           /* correct, type implicit */
```

외부 표현으로 변환되지 않는 열거형의 경우 숫자 정보가 생략될 수 있습니다.

```text
       enum { low, medium, high } Amount;
```

---
### **4.6. Constructed Types**

편의상 기본 유형에서 구조 유형을 구성할 수 있습니다. 각 사양은 새롭고 고유한 유형을 선언합니다. 정의 구문은 C와 매우 유사합니다.

```text
       struct {
         T1 f1;
         T2 f2;
         ...
         Tn fn;
       } [[T]];
```

구조 내의 필드는 열거에 사용할 수 있는 것과 매우 유사한 구문으로 유형의 이름을 사용하여 한정될 수 있습니다. 예를 들어 T.f2는 이전 선언의 두 번째 필드를 나타냅니다. 구조 정의를 포함할 수 있습니다.

---
#### **4.6.1. Variants**

정의된 구조에는 환경 내에서 사용할 수 있는 일부 지식을 기반으로 하는 변형이 있을 수 있습니다. 선택자는 구조가 정의하는 가능한 변형을 정의하는 열거 유형이어야 합니다. select에서 선언된 열거형의 모든 요소에 대해 case arm이 있어야 합니다. 변형 구조의 본문에는 참조용 레이블이 지정될 수 있습니다. 런타임 시 변형이 선택되는 메커니즘은 프레젠테이션 언어로 규정되지 않습니다.

```text
       struct {
           T1 f1;
           T2 f2;
           ....
           Tn fn;
           select (E) {
               case e1: Te1;
               case e2: Te2;
               ....
               case en: Ten;
           } [[fv]];
       } [[Tv]];
```

예를 들어:

```text
       enum { apple, orange } VariantTag;
       struct {
           uint16 number;
           opaque string<0..10>; /* variable length */
       } V1;
       struct {
           uint32 number;
           opaque string[10];    /* fixed length */
       } V2;
       struct {
           select (VariantTag) { /* value of selector is implicit */
               case apple: V1;   /* VariantBody, tag = apple */
               case orange: V2;  /* VariantBody, tag = orange */
           } variant_body;       /* optional label on variant */
       } VariantRecord;
```

유형 이전에 선택자에 대한 값을 지정하여 변형 구조를 한정\(축소\)할 수 있습니다. 예를 들어,

```text
       orange VariantRecord
```

V2 유형의 variant\_body를 포함하는 VariantRecord의 제한된 유형입니다.

---
### **4.7. Cryptographic Attributes**

네 가지 암호화 작업 디지털 서명, 스트림 암호화, 블록 암호화 및 공개 키 암호화는 각각 디지털 서명, 스트림 암호화, 블록 암호화 및 공개 키 암호화로 지정됩니다. 필드의 암호화 처리는 필드 유형 사양 앞에 적절한 키워드 지정을 추가하여 지정됩니다. 암호화 키는 현재 세션 상태에 의해 암시됩니다\(섹션 6.1 참조\).

디지털 서명에서 단방향 해시 함수는 서명 알고리즘의 입력으로 사용됩니다. 디지털 서명된 요소는 불투명 벡터 <0..2^16-1\>로 인코딩되며 길이는 서명 알고리즘 및 키로 지정됩니다.

RSA 서명에서는 2개의 해시\(SHA 1개와 MD5 1개\)의 36바이트 구조가 서명됩니다\(개인 키로 암호화됨\). \[PKCS1A\]에 설명된 대로 PKCS #1 블록 유형 1로 인코딩됩니다.

참고: PKCS#1의 표준 참조는 이제 RFC 3447 \[PKCS1B\]입니다. 그러나 TLS 1.0 텍스트와의 차이점을 최소화하기 위해 RFC 2313 \[PKCS1A\]의 용어를 사용하고 있습니다.

DSS에서 SHA 해시의 20바이트는 추가 해시 없이 디지털 서명 알고리즘을 통해 직접 실행됩니다. 이것은 r과 s의 두 값을 생성합니다. DSS 서명은 위와 같이 불투명 벡터이며 그 내용은 다음의 DER 인코딩입니다.

```text
       Dss-Sig-Value  ::=  SEQUENCE  {
            r       INTEGER,
            s       INTEGER
       }
```

스트림 암호 암호화에서 일반 텍스트는 암호학적으로 안전한 키 의사 난수 생성기에서 생성된 동일한 양의 출력과 배타적 OR됩니다.

블록 암호 암호화에서는 평문의 모든 블록이 암호문 블록으로 암호화됩니다. 모든 블록 암호 암호화는 CBC\(Cipher Block Chaining\) 모드에서 이루어지며 블록 암호화된 모든 항목은 암호 블록 길이의 정확한 배수가 됩니다.

공개키 암호화에서는 일치하는 개인키로만 복호화할 수 있도록 데이터를 암호화하기 위해 공개키 알고리즘을 사용한다. 공개 키로 암호화된 요소는 불투명 벡터 <0..2^16-1\>로 인코딩되며 길이는 서명 알고리즘 및 키에 의해 지정됩니다.

RSA 암호화 값은 \[PKCS1A\]에 설명된 대로 PKCS #1 블록 유형 2로 인코딩됩니다.

다음 예에서

```text
       stream-ciphered struct {
           uint8 field1;
           uint8 field2;
           digitally-signed opaque hash[20];
       } UserType;
```

해시의 내용은 서명 알고리즘의 입력으로 사용되며 전체 구조는 스트림 암호로 암호화됩니다. 이 구조의 길이\(바이트\)는 field1 및 field2에 대한 2바이트에 서명 길이에 대한 2바이트에 서명 알고리즘의 출력 길이를 더한 것과 같습니다. 이는 서명에 사용되는 알고리즘과 키가 이 구조를 인코딩하거나 디코딩하기 전에 알려져 있기 때문에 알려져 있습니다.

---
### **4.8. Constants**

유형이 지정된 상수는 원하는 유형의 기호를 선언하고 여기에 값을 할당하여 지정 목적으로 정의할 수 있습니다. 과소 지정 유형\(불투명, 가변 길이 벡터 및 불투명을 포함하는 구조\)에는 값을 할당할 수 없습니다. 다중 요소 구조 또는 벡터의 필드는 생략할 수 없습니다.

예를 들어:

```text
       struct {
           uint8 f1;
           uint8 f2;
       } Example1;

       Example1 ex1 = {1, 4};  /* assigns f1 = 1, f2 = 4 */
```

---
## **5. HMAC and the Pseudorandom Function**

TLS 레코드 및 핸드셰이크 계층의 여러 작업에는 키 MAC이 필요합니다. 이것은 비밀로 보호되는 일부 데이터의 안전한 다이제스트입니다. MAC 비밀을 모르면 MAC 위조가 불가능합니다. 이 작업에 사용하는 구성은 HMAC로 알려져 있으며 \[HMAC\]에 설명되어 있습니다.

HMAC는 다양한 해시 알고리즘과 함께 사용할 수 있습니다. TLS는 이를 HMAC\_MD5\(비밀, 데이터\) 및 HMAC\_SHA\(비밀, 데이터\)로 표시하는 MD5 및 SHA-1의 두 가지 다른 알고리즘과 함께 핸드셰이크에서 사용합니다. 추가 해시 알고리즘은 암호 제품군으로 정의할 수 있습니다.

레코드 데이터를 보호하는 데 사용되지만 MD5 및 SHA-1은 이 버전의 프로토콜에 대한 핸드셰이킹 설명에 하드 코딩되어 있습니다.

또한 키 생성 또는 유효성 검사를 위해 비밀을 데이터 블록으로 확장하는 구성이 필요합니다. 이 PRF\(pseudo-random function\)는 암호, 시드 및 식별 레이블을 입력으로 사용하여 임의 길이의 출력을 생성합니다.

PRF를 가능한 한 안전하게 만들기 위해 두 알고리즘 중 하나가 보안을 유지하는 경우 보안을 보장하는 방식으로 두 개의 해시 알고리즘을 사용합니다.

먼저 단일 해시 함수를 사용하여 비밀을 확장하고 임의의 양의 출력으로 시드하는 데이터 확장 함수 P\_hash\(secret, data\)를 정의합니다.

```text
       P_hash(secret, seed) = HMAC_hash(secret, A(1) + seed) +
                              HMAC_hash(secret, A(2) + seed) +
                              HMAC_hash(secret, A(3) + seed) + ...
```

여기서 +는 연결을 나타냅니다.

A\(\)는 다음과 같이 정의됩니다.

```text
       A(0) = seed
       A(i) = HMAC_hash(secret, A(i-1))
```

P\_hash는 필요한 양의 데이터를 생성하는 데 필요한 만큼 반복할 수 있습니다. 예를 들어 P\_SHA-1을 사용하여 64바이트의 데이터를 생성하는 경우 A\(4\)를 통해 4번 반복해야 80바이트의 출력 데이터가 생성됩니다. 최종 반복의 마지막 16바이트는 버려지고 64바이트의 출력 데이터가 남습니다.

TLS의 PRF는 암호를 두 부분으로 나누고 절반은 P\_MD5로 데이터를 생성하고 나머지 절반은 P\_SHA-1로 데이터를 생성한 다음 이 두 확장 함수의 출력을 함께 배타적 OR 처리하여 생성됩니다.

S1과 S2는 비밀의 두 절반이며 각각 길이가 같습니다. S1은 비밀의 전반부에서, S2는 후반부에서 가져옵니다. 길이는 전체 비밀의 길이를 2로 나눈 값을 반올림하여 생성됩니다. 따라서 원래 비밀이 홀수 바이트 길이인 경우 S1의 마지막 바이트는 S2의 첫 번째 바이트와 동일합니다.

```text
       L_S = length in bytes of secret;
       L_S1 = L_S2 = ceil(L_S / 2);
```

비밀은 위에서 설명한 대로 두 개의 반쪽\(하나의 공유 바이트 가능성 포함\)으로 분할되며 S1은 첫 번째 L\_S1 바이트를 취하고 S2는 마지막 L\_S2 바이트를 차지합니다.

그런 다음 PRF는 두 의사 난수 스트림을 배타적 OR로 혼합한 결과로 정의됩니다.

```text
       PRF(secret, label, seed) = P_MD5(S1, label + seed) XOR
                                  P_SHA-1(S2, label + seed);
```

레이블은 ASCII 문자열입니다. 길이 바이트나 후행 null 문자 없이 제공된 정확한 형식으로 포함되어야 합니다. 예를 들어 "slithy toves" 레이블은 다음 바이트를 해싱하여 처리됩니다.

```text
       73 6C 69 74 68 79 20 74 6F 76 65 73
```

MD5는 16바이트 출력을 생성하고 SHA-1은 20바이트 출력을 생성하므로 내부 반복의 경계가 정렬되지 않습니다. 80바이트 출력을 생성하려면 P\_MD5가 A\(5\)를 반복해야 하는 반면 P\_SHA-1은 A\(4\)를 통해서만 반복해야 합니다.

---
## **6. The TLS Record Protocol**

TLS 레코드 프로토콜은 계층화된 프로토콜입니다. 각 계층에서 메시지에는 길이, 설명 및 콘텐츠에 대한 필드가 포함될 수 있습니다. 레코드 프로토콜은 전송할 메시지를 가져오고, 데이터를 관리 가능한 블록으로 분할하고, 선택적으로 데이터를 압축하고, MAC을 적용하고, 암호화하고, 결과를 전송합니다. 수신된 데이터는 복호화, 확인, 압축 해제, 재조립된 후 상위 클라이언트로 전달됩니다.

이 문서에서는 핸드셰이크 프로토콜, 경고 프로토콜, 암호 사양 변경 프로토콜 및 애플리케이션 데이터 프로토콜의 네 가지 레코드 프로토콜 클라이언트에 대해 설명합니다. TLS 프로토콜의 확장을 허용하기 위해 레코드 프로토콜에서 추가 레코드 유형을 지원할 수 있습니다. 모든 새 레코드 유형은 여기에 설명된 네 가지 레코드 유형에 대한 ContentType 값 바로 위에 유형 값을 할당해야 합니다\(부록 A.1 참조\). 이러한 모든 값은 RFC 2434 Standards Action에 의해 정의되어야 합니다. ContentType 값에 대한 IANA 고려 사항은 섹션 11을 참조하십시오.\(SHOULD\)

TLS 구현이 이해하지 못하는 레코드 유형을 수신하는 경우 무시해야 합니다\(SHOULD\). 사용하도록 설계된 모든 프로토콜\(SHOULD\)

over TLS는 이에 대한 모든 가능한 공격을 처리하도록 신중하게 설계되어야 합니다. 레코드의 유형과 길이는 암호화로 보호되지 않기 때문에 이러한 값의 트래픽 분석 값을 최소화하도록 주의를 기울여야 합니다.\(MUST, SHOULD\)

---
### **6.1. Connection States**

TLS 연결 상태는 TLS 레코드 프로토콜의 운영 환경입니다. 압축 알고리즘, 암호화 알고리즘 및 MAC 알고리즘을 지정합니다. 또한 이러한 알고리즘의 매개변수인 MAC 비밀과 읽기 및 쓰기 방향의 연결에 대한 대량 암호화 키가 알려져 있습니다. 논리적으로 현재 읽기 및 쓰기 상태와 보류 중인 읽기 및 쓰기 상태의 네 가지 미결 연결 상태가 항상 있습니다. 모든 레코드는 현재 읽기 및 쓰기 상태에서 처리됩니다. 보류 상태에 대한 보안 매개변수는 TLS 핸드셰이크 프로토콜에 의해 설정될 수 있으며 Change Cipher Spec은 보류 상태 중 하나를 선택적으로 현재 상태로 만들 수 있습니다. 이 경우 적절한 현재 상태가 폐기되고 보류 상태로 대체됩니다. 보류 상태는 빈 상태로 다시 초기화됩니다. 보안 매개변수로 초기화되지 않은 상태를 현재 상태로 만드는 것은 불법입니다. 초기 현재 상태는 항상 암호화, 압축 또는 MAC이 사용되지 않도록 지정합니다.

TLS 연결 읽기 및 쓰기 상태에 대한 보안 매개변수는 다음 값을 제공하여 설정됩니다.

연결 끝

- 이 엔티티가 이 연결에서 "클라이언트" 또는 "서버"로 간주되는지 여부.

대량 암호화 알고리즘

- 대량 암호화에 사용되는 알고리즘입니다. 이 사양에는 이 알고리즘의 키 크기, 비밀 키의 양, 블록 또는 스트림 암호인지 여부, 암호의 블록 크기\(적절한 경우\)가 포함됩니다.

MAC 알고리즘

- 메시지 인증에 사용되는 알고리즘입니다. 이 사양에는 MAC 알고리즘이 반환하는 해시의 크기가 포함됩니다.

압축 알고리즘

- 데이터 압축에 사용되는 알고리즘입니다. 이 사양에는 알고리즘에 압축이 필요한 모든 정보가 포함되어야 합니다.

마스터 시크릿

- 연결에서 두 피어 간에 공유되는 48바이트 비밀.

클라이언트 랜덤

- 클라이언트에서 제공하는 32바이트 값.

서버 랜덤

- 서버에서 제공하는 32바이트 값.

이러한 매개변수는 프리젠테이션 언어에서 다음과 같이 정의됩니다.

```text
       enum { server, client } ConnectionEnd;

       enum { null, rc4, rc2, des, 3des, des40, idea, aes }
       BulkCipherAlgorithm;

       enum { stream, block } CipherType;

       enum { null, md5, sha } MACAlgorithm;

       enum { null(0), (255) } CompressionMethod;

       /* The algorithms specified in CompressionMethod,
          BulkCipherAlgorithm, and MACAlgorithm may be added to. */

       struct {
           ConnectionEnd          entity;
           BulkCipherAlgorithm    bulk_cipher_algorithm;
           CipherType             cipher_type;
           uint8                  key_size;
           uint8                  key_material_length;
           MACAlgorithm           mac_algorithm;
           uint8                  hash_size;
           CompressionMethod      compression_algorithm;
           opaque                 master_secret[48];
           opaque                 client_random[32];
           opaque                 server_random[32];
       } SecurityParameters;
```

레코드 레이어는 보안 매개변수를 사용하여 다음 네 가지 항목을 생성합니다.

```text
       client write MAC secret
       server write MAC secret
       client write key
       server write key
```

클라이언트 쓰기 매개변수는 레코드를 수신하고 처리할 때 서버에서 사용되며 그 반대의 경우도 마찬가지입니다. 보안 매개변수에서 이러한 항목을 생성하는 데 사용되는 알고리즘은 섹션 6.3에 설명되어 있습니다.

보안 매개변수가 설정되고 키가 생성되면 연결 상태를 현재 상태로 만들어 인스턴스화할 수 있습니다. 이러한 현재 상태는 처리된 각 레코드에 대해 업데이트되어야 합니다. 각 연결 상태에는 다음 요소가 포함됩니다.\(MUST\)

압축 상태

- 압축 알고리즘의 현재 상태.

암호 상태

- 암호화 알고리즘의 현재 상태. 이는 해당 연결에 대해 예약된 키로 구성됩니다. 스트림 암호의 경우 여기에는 스트림이 데이터를 계속 암호화하거나 해독하는 데 필요한 모든 상태 정보도 포함됩니다.

MAC 비밀

- 위에서 생성된 이 연결에 대한 MAC 암호입니다.

시퀀스 번호

- 각 연결 상태에는 읽기 및 쓰기 상태에 대해 별도로 유지 관리되는 시퀀스 번호가 포함됩니다. 시퀀스 번호는 연결 상태가 활성 상태가 될 때마다 0으로 설정되어야 합니다. 시퀀스 번호는 uint64 유형이며 2^64-1을 초과할 수 없습니다. 시퀀스 번호는 래핑되지 않습니다. TLS 구현이 시퀀스 번호를 래핑해야 하는 경우 대신 재협상해야 합니다. 시퀀스 번호는 각 레코드 후에 증가합니다. 특히 특정 연결 상태에서 전송된 첫 번째 레코드는 시퀀스 번호 0을 사용해야 합니다.\(MUST, MUST\)

---
### **6.2. Record layer**

TLS 레코드 레이어는 임의 크기의 비어 있지 않은 블록으로 상위 레이어에서 해석되지 않은 데이터를 수신합니다.

---
#### **6.2.1. Fragmentation**

레코드 레이어는 정보 블록을 2^14바이트 이하의 청크로 데이터를 전달하는 TLSPplaintext 레코드로 분할합니다. 클라이언트 메시지 경계는 레코드 레이어에서 보존되지 않습니다\(즉, 동일한 ContentType의 여러 클라이언트 메시지가 단일 TLSPlaintext 레코드로 병합될 수 있거나 단일 메시지가 여러 레코드에 걸쳐 조각화될 수 있음\).\(MAY\)

```text
       struct {
           uint8 major, minor;
       } ProtocolVersion;

       enum {
           change_cipher_spec(20), alert(21), handshake(22),
           application_data(23), (255)
       } ContentType;

       struct {
           ContentType type;
           ProtocolVersion version;
           uint16 length;
           opaque fragment[TLSPlaintext.length];
       } TLSPlaintext;
```

유형

- 포함된 조각을 처리하는 데 사용되는 상위 수준 프로토콜입니다.

버전

- 사용 중인 프로토콜의 버전. 이 문서는 { 3, 2 } 버전을 사용하는 TLS 버전 1.1에 대해 설명합니다. 버전 값 3.2는 역사적입니다. TLS 버전 1.1은 TLS 1.0 프로토콜에 대한 약간의 수정이며, 이 프로토콜 자체는 버전 값 3.0을 포함하는 SSL 3.0 프로토콜에 대한 약간의 수정입니다. \(부록 A.1 참조\)

길이

- 다음 TLSPlaintext.fragment의 길이\(바이트\)입니다. 길이는 2^14를 초과하면 안 됩니다.

파편

- 애플리케이션 데이터. 이 데이터는 투명하며 유형 필드에 지정된 상위 수준 프로토콜에서 처리할 독립 블록으로 처리됩니다.

참고: 서로 다른 TLS 레코드 레이어 콘텐츠 유형의 데이터가 인터리브될 수 있습니다. 애플리케이션 데이터는 일반적으로 다른 콘텐츠 유형보다 전송 우선 순위가 낮습니다. 그러나 레코드는 레코드 레이어에 의해 보호되는 것과 동일한 순서로 네트워크에 전달되어야 합니다. 수신자는 연결에서 첫 번째 핸드셰이크 이후의 핸드셰이크 동안 인터리브된 애플리케이션 계층 트래픽을 수신하고 처리해야 합니다.\(MAY, MUST, MUST\)

---
#### **6.2.2. Record Compression and Decompression**

모든 레코드는 현재 세션 상태에 정의된 압축 알고리즘을 사용하여 압축됩니다. 항상 활성 압축 알고리즘이 있습니다. 그러나 처음에는 CompressionMethod.null로 정의됩니다. 압축 알고리즘은 TLSPlaintext 구조를 TLSCompressed 구조로 변환합니다. 압축 기능은 연결 상태가 활성화될 때마다 기본 상태 정보로 초기화됩니다.

압축은 무손실이어야 하며 콘텐츠 길이를 1024바이트 이상 늘릴 수 없습니다. 압축 해제 기능이 2^14바이트를 초과하는 길이로 압축을 해제하는 TLSCompressed.fragment를 발견하면 치명적인 압축 해제 실패 오류를 보고해야 합니다.

```text
       struct {
           ContentType type;       /* same as TLSPlaintext.type */
           ProtocolVersion version;/* same as TLSPlaintext.version */
           uint16 length;
           opaque fragment[TLSCompressed.length];
       } TLSCompressed;
```

길이

- 다음 TLSCompressed.fragment의 길이\(바이트\)입니다. 길이는 2^14 + 1024를 초과할 수 없습니다.

파편

- TLSPlaintext.fragment의 압축 형식입니다.

참고: CompressionMethod.null 작업은 ID 작업입니다. 어떤 필드도 변경되지 않습니다.

구현 참고 사항: 압축 해제 기능은 메시지가 내부 버퍼 오버플로를 일으키지 않도록 하는 역할을 합니다.

---
#### **6.2.3. Record Payload Protection**

암호화 및 MAC 기능은 TLSCompressed 구조를 TLSCiphertext로 변환합니다. 암호 해독 기능은 프로세스를 반대로 합니다. 레코드의 MAC에는 누락, 추가 또는 반복 메시지를 감지할 수 있도록 시퀀스 번호도 포함됩니다.

```text
       struct {
           ContentType type;
           ProtocolVersion version;
           uint16 length;
           select (CipherSpec.cipher_type) {
               case stream: GenericStreamCipher;
               case block: GenericBlockCipher;
           } fragment;
       } TLSCiphertext;
```

유형

- type 필드는 TLSCompressed.type과 동일합니다.

버전

- 버전 필드는 TLSCompressed.version과 동일합니다.

길이

- 다음 TLSCiphertext.fragment의 길이\(바이트\)입니다. 길이는 2^14 + 2048을 초과할 수 없습니다.

파편

- MAC을 포함하는 TLSCompressed.fragment의 암호화된 형식입니다.

---
##### **6.2.3.1. Null or Standard Stream Cipher**

스트림 암호\(BulkCipherAlgorithm.null 포함, 부록 A.6 참조\)는 TLSCompressed.fragment 구조와 스트림 TLSCiphertext.fragment 구조 간에 변환합니다.

```text
       stream-ciphered struct {
           opaque content[TLSCompressed.length];
           opaque MAC[CipherSpec.hash_size];
       } GenericStreamCipher;
```

MAC은 다음과 같이 생성됩니다.

```text
       HMAC_hash(MAC_write_secret, seq_num + TLSCompressed.type +
                     TLSCompressed.version + TLSCompressed.length +
                     TLSCompressed.fragment));
```

여기서 "+"는 연결을 나타냅니다.

seq\_num

- 이 레코드의 시퀀스 번호입니다.

해시시

- SecurityParameters.mac\_algorithm에서 지정한 해싱 알고리즘입니다.

MAC은 암호화 전에 계산됩니다. 스트림 암호는 MAC을 포함한 전체 블록을 암호화합니다. 동기화 벡터\(예: RC4\)를 사용하지 않는 스트림 암호의 경우 한 레코드 끝의 스트림 암호 상태가 후속 패킷에서 단순히 사용됩니다. CipherSuite가 TLS\_NULL\_WITH\_NULL\_NULL인 경우 암호화는 ID 작업으로 구성됩니다\(즉, 데이터가 암호화되지 않고 MAC 크기가 0이므로 MAC이 사용되지 않음을 나타냄\). TLSCiphertext.length는 TLSCompressed.length에 CipherSpec.hash\_size를 더한 것입니다.

---
##### **6.2.3.2. CBC Block Cipher**

블록 암호\(예: RC2, DES 또는 AES\)의 경우 암호화 및 MAC 함수는 TLSCompressed.fragment 구조와 블록 TLSCiphertext.fragment 구조 간에 변환합니다.

```text
       block-ciphered struct {
           opaque IV[CipherSpec.block_length];
           opaque content[TLSCompressed.length];
           opaque MAC[CipherSpec.hash_size];
           uint8 padding[GenericBlockCipher.padding_length];
           uint8 padding_length;
       } GenericBlockCipher;
```

MAC은 섹션 6.2.3.1에 설명된 대로 생성됩니다.

IV

- 이전 버전의 SSL 및 TLS와 달리 TLS 1.1은 \[CBCATT\]에서 설명한 공격을 방지하기 위해 명시적 IV를 사용합니다. 동등하게 강력한 다음 절차를 권장합니다. 명확성을 위해 다음 표기법을 사용합니다.

IV

- GenericBlockCipher 구조에서 IV 필드의 전송된 값입니다.

CBC 잔류물

- 이전 레코드의 마지막 암호문 블록.

마스크

- 레코드의 첫 번째 암호 블록을 암호화하기 전에 암호가 일반 텍스트와 XOR하는 실제 값입니다.

- 이전 버전의 TLS에서는 IV 필드가 없었고 CBC 잔류물과 마스크가 하나이고 동일했습니다. TLS 1.0 IV 처리에 대한 자세한 내용은 \[TLS1.0\]의 섹션 6.1, 6.2.3.2 및 6.3을 참조하십시오.

- 레코드당 IV를 생성하는 데 다음 두 알고리즘 중 하나를 사용해야 합니다.\(SHOULD\)

- \(1\) 길이가 CipherSpec.block\_length인 암호학적으로 강력한 무작위 문자열 R을 생성합니다. IV 필드에 R을 배치합니다. 마스크를 R로 설정합니다. 따라서 첫 번째 암호 블록은 E\(R XOR Data\)로 암호화됩니다.

- \(2\) CipherSpec.block\_length 길이의 암호학적으로 강력한 난수 R을 생성하고 암호화 전에 일반 텍스트 앞에 추가합니다. 이 경우:

\(a\) 암호는 0과 같은 고정 마스크를 사용할 수 있습니다.

- \(b\) 이전 레코드의 CBC 잔류물을 마스크로 사용할 수 있습니다. 이는 TLS 1.0 및 SSL 3과의 최대 코드 호환성을 유지합니다. 또한 일부 시스템에서 문제가 되는 것으로 알려진 IV를 빠르게 재설정하는 기능이 필요하지 않다는 장점도 있습니다.

- \(2\)\(a\) 또는 \(2\)\(b\)에서 데이터\(R || 데이터\)가 암호화 프로세스에 공급됩니다. 첫 번째 암호 블록\(E\(마스크 XOR R\) 포함\)은 IV 필드에 배치됩니다. 콘텐츠의 첫 번째 블록에는 E\(IV XOR 데이터\)가 포함됩니다.

- 다음 대체 절차를 사용할 수 있습니다. 그러나 위의 절차만큼 암호학적으로 강력한 것으로 입증되지는 않았습니다. 발신자는 고정 블록 F를 일반 텍스트\(또는 약한 PRNG로 생성된 블록\) 앞에 추가합니다. 그런 다음 그는 이전 블록의 CBC 잔류물을 앞에 추가된 블록의 마스크로 사용하여 위의 \(2\)와 같이 암호화합니다. 이 경우 응용 프로그램에서 전송한 첫 번째 레코드의 마스크\(종료\)는 강력한 암호화 PRNG를 사용하여 생성해야 합니다.\(MAY, MUST\)

- 세 대안 모두에 대한 복호화 작업은 동일합니다. 수신자는 전체 GenericBlockCipher 구조를 해독한 다음 IV 구성 요소에 해당하는 첫 번째 암호 블록을 버립니다.

심

- 일반 텍스트의 길이가 블록 암호의 블록 길이의 정수배가 되도록 강제하기 위해 추가되는 패딩입니다. 패딩은 TLSCiphertext.length가 블록 길이의 정수배가 되는 한 최대 255바이트의 길이일 수 있습니다\(MAY\). 교환된 메시지의 길이 분석을 기반으로 하는 프로토콜에 대한 공격을 좌절시키기 위해 필요한 것보다 긴 길이가 바람직할 수 있습니다. 패딩 데이터 벡터의 각 uint8은 패딩 길이 값으로 채워져야 합니다. 수신자\(MAY, MUST\)

- 이 패딩을 확인해야 하며 패딩 오류를 나타내기 위해 bad\_record\_mac 경고를 사용해야 합니다\(SHOULD\).\(MUST\)

padding\_length

- 패딩 길이는 GenericBlockCipher 구조의 총 크기가 암호 블록 길이의 배수가 되도록 해야 합니다. 유효한 값의 범위는 0에서 255까지입니다. 이 길이는 padding\_length 필드 자체를 제외한 패딩 필드의 길이를 지정합니다.\(MUST\)

암호화된 데이터 길이\(TLSCiphertext.length\)는 CipherSpec.block\_length, TLSCompressed.length, CipherSpec.hash\_size 및 padding\_length의 합보다 하나 더 큽니다.

예: 블록 길이가 8바이트인 경우 콘텐츠 길이

- \(TLSCompressed.length\)는 61바이트이고 MAC 길이는 20바이트이며 패딩 전의 길이는 82바이트입니다\(위에서 설명한 것처럼 암호화될 수도 있고 암호화되지 않을 수도 있는 IV는 포함되지 않음\). 따라서 총 길이가 8바이트\(블록 길이\)의 짝수배가 되려면 패딩 길이 모듈로 8이 6과 같아야 합니다. 패딩 길이는 6, 14, 22 등에서 254가 될 수 있습니다. 패딩 길이가 필요한 최소값인 6인 경우 패딩은 6바이트이며 각각 값 6을 포함합니다. 블록 암호화 이전의 GenericBlockCipher는 xx 06 06 06 06 06 06 06이며 여기서 xx는 MAC의 마지막 옥텟입니다.

참고: CBC 모드\(Cipher Block Chaining\)의 블록 암호를 사용하면 암호문이 전송되기 전에 레코드의 전체 일반 텍스트를 알아야 합니다. 그렇지 않으면 공격자가 \[CBCATT\]에 설명된 공격을 수행할 수 있습니다.

구현 참고 사항: Canvel et al. \[CBCTIME\]은 MAC을 계산하는 데 필요한 시간을 기반으로 CBC 패딩에 대한 타이밍 공격을 시연했습니다. 이 공격을 방어하기 위해 구현은 패딩이 올바른지 여부에 관계없이 레코드 처리 시간이 기본적으로 동일하도록 보장해야 합니다. 일반적으로 가장 좋은 방법은 패딩이 잘못된 경우에도 MAC을 계산한 다음 패킷을 거부하는 것입니다. 예를 들어 패드가 잘못된 것으로 보이면 구현에서 길이가 0인 패드를 가정한 다음 MAC을 계산할 수 있습니다. 이것은 MAC 성능이 데이터 조각의 크기에 어느 정도 의존하기 때문에 작은 타이밍 채널을 남깁니다.\(MUST\)

- 그러나 기존 MAC의 블록 크기가 크고 타이밍 신호의 크기가 작기 때문에 악용할 수 있을 만큼 크지 않다고 생각됩니다.

---
### **6.3. Key Calculation**

레코드 프로토콜에는 키를 생성하는 알고리즘과 핸드셰이크 프로토콜에서 제공하는 보안 매개변수의 MAC 비밀이 필요합니다.

마스터 비밀은 현재 연결 상태에 필요한 MAC 비밀 및 키에 할당되는 일련의 보안 바이트로 해시됩니다\(부록 A.6 참조\). CipherSpecs에는 클라이언트 쓰기 MAC 비밀, 서버 쓰기 MAC 비밀, 클라이언트 쓰기 키 및 서버 쓰기 키가 필요하며 각각 마스터 비밀에서 순서대로 생성됩니다. 사용되지 않은 값은 비어 있습니다.

키와 MAC 비밀이 생성되면 마스터 비밀이 엔트로피 소스로 사용됩니다.

키 자료를 생성하려면 다음을 계산하십시오.

```text
       key_block = PRF(SecurityParameters.master_secret,
                          "key expansion",
                          SecurityParameters.server_random +
             SecurityParameters.client_random);
```

충분한 출력이 생성될 때까지. 그러면 key\_block이 다음과 같이 분할됩니다.

```text
       client_write_MAC_secret[SecurityParameters.hash_size]
       server_write_MAC_secret[SecurityParameters.hash_size]
       client_write_key[SecurityParameters.key_material_length]
       server_write_key[SecurityParameters.key_material_length]
```

구현 참고 사항: 가장 많은 자료가 필요한 현재 정의된 암호화 제품군은 \[TLSAES\]에 정의된 AES\_256\_CBC\_SHA입니다. 총 136바이트의 키 자료에 대해 2 x 32바이트 키, 2 x 20바이트 MAC 암호 및 2 x 16바이트 초기화 벡터가 필요합니다.

---
## **7. The TLS Handshaking Protocols**

TLS에는 피어가 레코드 레이어에 대한 보안 매개변수에 동의하고, 자신을 인증하고, 협상된 보안 매개변수를 인스턴스화하고, 서로에게 오류 조건을 보고하는 데 사용되는 세 가지 하위 프로토콜이 있습니다.

핸드셰이크 프로토콜은 다음 항목으로 구성된 세션 협상을 담당합니다.

세션 식별자

- 활성 또는 재개 가능한 세션 상태를 식별하기 위해 서버에서 선택한 임의의 바이트 시퀀스입니다.

피어 인증서

- 피어의 X509v3 \[X509\] 인증서. 상태의 이 요소는 null일 수 있습니다.

압축 방식

- 암호화 전에 데이터를 압축하는 데 사용되는 알고리즘입니다.

암호 사양

- 대량 데이터 암호화 알고리즘\(예: null, DES 등\) 및 MAC 알고리즘\(예: MD5 또는 SHA\)을 지정합니다. 또한 hash\_size와 같은 암호화 속성을 정의합니다. \(정식 정의는 부록 A.6 참조\)

마스터 시크릿

- 클라이언트와 서버 간에 공유되는 48바이트 비밀.

재개 가능

- 세션을 사용하여 새 연결을 시작할 수 있는지 여부를 나타내는 플래그입니다.

그런 다음 이러한 항목은 애플리케이션 데이터를 보호할 때 레코드 레이어에서 사용할 보안 매개변수를 만드는 데 사용됩니다. TLS 핸드셰이크 프로토콜의 재개 ​​기능을 통해 동일한 세션을 사용하여 많은 연결을 인스턴스화할 수 있습니다.

---
### **7.1. Change Cipher Spec Protocol**

변경 암호 사양 프로토콜은 암호 전략의 전환을 알리기 위해 존재합니다. 프로토콜은 단일 메시지로 구성되며 현재\(대기 중 아님\) 연결 상태에서 암호화되고 압축됩니다. 메시지는 값 1의 단일 바이트로 구성됩니다.

```text
       struct {
           enum { change_cipher_spec(1), (255) } type;
       } ChangeCipherSpec;
```

Change Cipher Spec 메시지는 새로 협상된 CipherSpec 및 키에 따라 후속 레코드가 보호될 것임을 수신측에 알리기 위해 클라이언트와 서버 모두에서 전송됩니다. 이 메시지를 수신하면 수신자는 레코드 레이어에 읽기 보류 상태를 즉시 읽기 현재 상태로 복사하도록 지시합니다.

이 메시지를 보낸 직후에 발신자는 레코드 레이어에 쓰기 보류 상태를 쓰기 활성 상태로 만들도록 지시해야 합니다. \(섹션 6.1 참조\) 암호 사양 변경 메시지는 보안 매개변수가 합의된 후 핸드셰이크 중에 전송되지만 확인 완료 메시지가 전송되기 전에 전송됩니다\(섹션 7.4.9 참조\).\(MUST\)

참고: 데이터가 연결에서 흐르는 동안 리핸드셰이크가 발생하면 통신 당사자는 이전 CipherSpec을 사용하여 데이터를 계속 보낼 수 있습니다. 그러나 ChangeCipherSpec이 전송되면 새 CipherSpec을 사용해야 합니다. ChangeCipherSpec을 보내는 첫 번째 측은 다른 측이 새로운 키 자료의 계산을 마쳤다는 것을 알지 못합니다\(예: 시간이 많이 걸리는 공개 키 작업을 수행해야 하는 경우\). 따라서 수신자가 데이터를 버퍼링해야 하는 작은 시간 창이 존재할 수 있습니다. 실제로 최신 기계의 경우 이 간격이 상당히 짧을 수 있습니다.\(MUST, MAY\)

---
### **7.2. Alert Protocol**

- TLS 레코드 계층에서 지원하는 콘텐츠 유형 중 하나가 경고 유형입니다. 경보 메시지는 메시지의 심각도와 경보에 대한 설명을 전달합니다. 치명적인 수준의 경고 메시지는 연결을 즉시 종료합니다. 이 경우 해당 세션에 해당하는 다른 연결은 계속될 수 있지만 세션 식별자는 무효화되어 실패한 세션이 새 연결을 설정하는 데 사용되는 것을 방지해야 합니다. 다른 메시지와 마찬가지로 경고 메시지는 현재 연결 상태에 지정된 대로 암호화되고 압축됩니다.\(MUST\)

```text
             enum { warning(1), fatal(2), (255) } AlertLevel;

             enum {
                 close_notify(0),
                 unexpected_message(10),
                 bad_record_mac(20),
                 decryption_failed(21),
                 record_overflow(22),
                 decompression_failure(30),
                 handshake_failure(40),
                 no_certificate_RESERVED (41),
                 bad_certificate(42),
                 unsupported_certificate(43),
                 certificate_revoked(44),
                 certificate_expired(45),
                 certificate_unknown(46),
                 illegal_parameter(47),
                 unknown_ca(48),

                 access_denied(49),
                 decode_error(50),
                 decrypt_error(51),
                 export_restriction_RESERVED(60),
                 protocol_version(70),
                 insufficient_security(71),
                 internal_error(80),
                 user_canceled(90),
                 no_renegotiation(100),
                 (255)
             } AlertDescription;

             struct {
                 AlertLevel level;
                 AlertDescription description;
             } Alert;
```

---
#### **7.2.1. Closure Alerts**

클라이언트와 서버는 잘림 공격을 피하기 위해 연결이 종료된다는 정보를 공유해야 합니다. 어느 쪽이든 종료 메시지 교환을 시작할 수 있습니다.

close\_notify

- 이 메시지는 발신자가 이 연결에서 더 이상 메시지를 보내지 않을 것임을 수신자에게 알립니다. TLS 1.1부터는 연결을 제대로 닫지 못해도 더 이상 세션을 재개하지 않아도 됩니다. 이것은 광범위한 구현 관행을 준수하기 위해 TLS 1.0에서 변경된 것입니다.

각 당사자는 close\_notify 경고를 전송하여 청산을 시작할 수 있습니다. 종료 알림 이후 수신된 모든 데이터는 무시됩니다.

다른 치명적인 경고가 전송되지 않은 경우 각 당사자는 연결의 쓰기 쪽을 닫기 전에 close\_notify 경고를 보내야 합니다. 상대방은 반드시 자신의 close\_notify 경고로 응답하고 즉시 연결을 닫아 대기 중인 쓰기를 버려야 합니다. 연결의 읽기 쪽을 닫기 전에 닫기 시작자가 응답하는 close\_notify 경고를 기다릴 필요가 없습니다.\(MUST\)

TLS를 사용하는 애플리케이션 프로토콜이 TLS 연결이 닫힌 후 기본 전송을 통해 모든 데이터를 전달할 수 있다고 제공하는 경우 TLS 구현은 TLS 연결이 종료되었음을 애플리케이션 계층에 알리기 전에 응답하는 close\_notify 경고를 수신해야 합니다. 애플리케이션 프로토콜이 추가 ​​데이터를 전송하지 않고 기본 전송 연결만 닫는 경우 구현은 다음을 닫도록 선택할 수 있습니다.\(MAY\)

응답 close\_notify를 기다리지 않고 전송합니다. 이 표준의 어떤 부분도 연결이 열리거나 닫힐 때를 포함하여 TLS에 대한 사용 프로필이 데이터 전송을 관리하는 방식을 지시해서는 안 됩니다.

참고: 연결을 닫으면 전송이 중단되기 전에 보류 중인 데이터가 안정적으로 전달된다고 가정합니다.

---
#### **7.2.2. Error Alerts**

TLS Handshake 프로토콜의 오류 처리는 매우 간단합니다. 오류가 감지되면 감지한 당사자는 상대방에게 메시지를 보냅니다. 치명적인 경고 메시지를 전송하거나 수신하면 양 당사자는 즉시 연결을 닫습니다. 서버와 클라이언트는 실패한 연결과 관련된 모든 세션 식별자, 키 및 비밀을 잊어버려야 합니다. 따라서 치명적인 경고로 종료된 모든 연결은 재개되어서는 안 됩니다\(MUST NOT\). 다음 오류 경고가 정의됩니다.\(MUST, MUST NOT\)

unexpected\_message

- 부적절한 메시지가 수신되었습니다. 이 경고는 항상 치명적이며 적절한 구현 간의 통신에서 관찰되어서는 안 됩니다.

bad\_record\_mac

- MAC이 잘못된 레코드가 수신된 경우 이 경고가 반환됩니다. 이 경고는 TLSCiphertext가 유효하지 않은 방식으로 해독되었기 때문에 경고가 전송된 경우에도 반환되어야 합니다. 즉, 블록 길이의 짝수 배수가 아니거나 확인 시 패딩 값이 올바르지 않았습니다. 이 메시지는 항상 치명적입니다.\(MUST\)

복호화 실패

- 이 경고는 TLSCiphertext가 유효하지 않은 방식으로 해독된 경우 반환될 수 있습니다\(MAY\). 블록 길이의 짝수 배수가 아니거나 확인 시 패딩 값이 올바르지 않습니다. 이 메시지는 항상 치명적입니다.\(MAY\)

참고: bad\_record\_mac 및 decryption\_failed 경보를 구분하면 TLS\[CBCATT\]에서 사용되는 CBC 모드에 대한 특정 공격이 허용될 수 있습니다. 특정 유형의 오류를 숨기려면 bad\_record\_mac 경고를 균일하게 사용하는 것이 좋습니다.

record\_overflow

- 길이가 2^14+2048바이트를 초과하는 TLSCiphertext 레코드 또는 2^14+1024바이트를 초과하는 TLSCompressed 레코드로 해독된 레코드를 수신했습니다. 이 메시지는 항상 치명적입니다.

압축 해제\_실패

- 압축 해제 기능이 잘못된 입력을 받았습니다\(예: 과도한 길이로 확장되는 데이터\). 이 메시지는 항상 치명적입니다.

handshake\_failure

- handshake\_failure 경고 메시지의 수신은 발신자가 사용 가능한 옵션이 주어진 허용 가능한 보안 매개변수 집합을 협상할 수 없음을 나타냅니다. 이것은 치명적인 오류입니다.

no\_certificate\_RESERVED

- 이 경고는 SSLv3에서 사용되었지만 TLS에서는 사용되지 않았습니다. 호환 구현에서 보내서는 안 됩니다.

bad\_certificate

- 인증서가 손상되었거나 올바르게 확인되지 않은 서명이 포함된 경우 등

unsupported\_certificate

- 인증서가 지원되지 않는 유형입니다.

인증서\_취소됨

- 서명자가 인증서를 취소했습니다.

certificate\_expired

- 인증서가 만료되었거나 현재 유효하지 않습니다.

인증서\_알 수 없음

- 인증서를 처리하는 동안 다른\(지정되지 않은\) 문제가 발생하여 승인할 수 없게 되었습니다.

불법 매개변수

- 핸드셰이크의 필드가 범위를 벗어났거나 다른 필드와 일치하지 않습니다. 이것은 항상 치명적입니다.

unknown\_ca

- 유효한 인증서 체인 또는 부분 체인을 받았지만 CA 인증서를 찾을 수 없거나 알려지고 신뢰할 수 있는 CA와 일치시킬 수 없기 때문에 인증서가 수락되지 않았습니다. 이 메시지는 항상 치명적입니다.

access\_denied

- 유효한 인증서를 받았으나 접근제어를 적용했을 때 발신자가 협상을 진행하지 않기로 결정한 경우 이 메시지는 항상 치명적입니다.

decode\_error

- 일부 필드가 지정된 범위를 벗어났거나 메시지 길이가 잘못되어 메시지를 디코딩할 수 없습니다. 이 메시지는 항상 치명적입니다.

암호 해독 오류

- 서명을 올바르게 확인하거나 키 교환을 해독하거나 완료된 메시지의 유효성을 검사할 수 없는 등 핸드셰이크 암호화 작업이 실패했습니다.

export\_restriction\_RESERVED

- 이 경고는 TLS 1.0에서 사용되었지만 TLS 1.1에서는 사용되지 않았습니다.

protocol\_version

- 클라이언트가 협상을 시도한 프로토콜 버전이 인식되지만 지원되지 않습니다. \(예를 들어 보안상의 이유로 이전 프로토콜 버전은 사용하지 않을 수 있습니다.\) 이 메시지는 항상 치명적입니다.

불충분한 보안

- 특히 서버가 클라이언트가 지원하는 것보다 더 안전한 암호를 요구하기 때문에 협상이 실패한 경우 handshake\_failure 대신 반환됩니다. 이 메시지는 항상 치명적입니다.

내부 오류

- 피어와 관련 없는 내부 오류 또는 프로토콜의 정확성\(예: 메모리 할당 실패\)으로 인해 계속할 수 없습니다. 이 메시지는 항상 치명적입니다.

user\_canceled

- 이 핸드셰이크는 프로토콜 오류와 관련 없는 어떤 이유로 취소됩니다. 핸드셰이크가 완료된 후 사용자가 작업을 취소하는 경우 close\_notify를 전송하여 연결을 닫는 것이 더 적합합니다. 이 경고 뒤에는 close\_notify가 와야 합니다. 이 메시지는 일반적으로 경고입니다.

재협상 금지

- 초기 핸드셰이킹 후 클라이언트 Hello에 대한 응답으로 서버 또는 Hello 요청에 대한 응답으로 클라이언트에서 전송합니다. 이 중 하나는 일반적으로 재협상으로 이어집니다. 적절하지 않은 경우 수신자는 이 경고로 응답해야 합니다. 이때 원래 요청자는 연결을 계속할지 여부를 결정할 수 있습니다. 이것이 적절한 한 가지 경우는 서버가 요청을 만족시키기 위해 프로세스를 생성한 경우입니다. 프로세스는 시작 시 보안 매개변수\(키 길이, 인증 등\)를 수신할 수 있으며

- 해당 시점 이후에는 이러한 매개변수에 대한 변경 사항을 전달하기 어려울 수 있습니다. 이 메시지는 항상 경고입니다.

경고 수준이 명시적으로 지정되지 않은 모든 오류에 대해 보내는 당사자는 이것이 치명적인 오류인지 여부를 재량에 따라 결정할 수 있습니다. 경고 수준의 경고가 수신되면 수신 당사자는 이를 치명적인 오류로 처리할지 여부를 재량에 따라 결정할 수 있습니다. 그러나 치명적인 수준으로 전송되는 모든 메시지는 치명적인 메시지로 취급되어야 합니다.\(MAY, MUST\)

새로운 경고 값은 RFC 2434 표준 조치에 의해 정의되어야 합니다. 경고 값에 대한 IANA 고려 사항은 섹션 11을 참조하십시오.\(MUST\)

---
### **7.3. Handshake Protocol Overview**

세션 상태의 암호화 매개변수는 TLS 레코드 레이어 위에서 작동하는 TLS 핸드셰이크 프로토콜에 의해 생성됩니다. TLS 클라이언트와 서버가 처음 통신을 시작하면 프로토콜 버전에 동의하고, 암호화 알고리즘을 선택하고, 선택적으로 서로를 인증하고, 공개 키 암호화 기술을 사용하여 공유 비밀을 생성합니다.

TLS 핸드셰이크 프로토콜에는 다음 단계가 포함됩니다.

- Hello 메시지를 교환하여 알고리즘 동의, 랜덤 값 교환, 세션 재개 확인

- 클라이언트와 서버가 사전 마스터 비밀에 동의할 수 있도록 필요한 암호화 매개변수를 교환합니다.

- 클라이언트와 서버가 자신을 인증할 수 있도록 인증서와 암호화 정보를 교환합니다.

- premaster secret에서 master secret을 생성하고 임의의 값을 교환한다.

- 레코드 레이어에 보안 매개변수를 제공합니다.

- 클라이언트와 서버가 피어가 가지고 있는지 확인하도록 허용

- 동일한 보안 매개변수를 계산하고 공격자의 조작 없이 핸드셰이크가 발생했음을 확인했습니다.

상위 계층은 TLS가 항상 두 피어 간에 가능한 가장 강력한 연결을 협상하는지 여부에 지나치게 의존해서는 안 됩니다. 메시지 가로채기\(man-in-the-middle\) 공격자가 두 엔터티가 지원하는 가장 안전하지 않은 방법으로 드롭다운하도록 시도할 수 있는 여러 가지 방법이 있습니다. 프로토콜은 이러한 위험을 최소화하도록 설계되었지만 여전히 공격이 가능합니다. 을 위한

예를 들어 공격자는 보안 서비스가 실행되는 포트에 대한 액세스를 차단하거나 피어가 인증되지 않은 연결을 협상하도록 시도할 수 있습니다. 기본 규칙은 더 높은 수준에서 보안 요구 사항이 무엇인지 인식하고 필요한 것보다 덜 안전한 채널을 통해 정보를 전송하지 않아야 한다는 것입니다. TLS 프로토콜은 모든 암호화 제품군이 약속된 보안 수준을 제공한다는 점에서 안전합니다. 인증서를 확인한 호스트와 1024비트 RSA 키 교환으로 3DES를 협상하면 그만큼 안전할 것으로 기대할 수 있습니다.

그러나 데이터가 해당 암호화를 해제하는 데 필요한 노력보다 더 가치가 없다고 생각하지 않는 한 40비트 보안으로 암호화된 링크를 통해 데이터를 전송해서는 안 됩니다.\(SHOULD\)

이러한 목표는 다음과 같이 요약할 수 있는 핸드셰이크 프로토콜에 의해 달성됩니다. 클라이언트는 서버가 서버 Hello 메시지로 응답해야 하는 클라이언트 Hello 메시지를 보냅니다. 그렇지 않으면 치명적인 오류가 발생하고 연결이 실패합니다. client hello 및 server hello는 클라이언트와 서버 간의 보안 강화 기능을 설정하는 데 사용됩니다. 클라이언트 hello 및 server hello는 프로토콜 버전, 세션 ID, 암호 그룹 및 압축 방법과 같은 속성을 설정합니다. 또한 ClientHello.random 및 ServerHello.random이라는 두 개의 임의 값이 생성되고 교환됩니다.

실제 키 교환은 최대 4개의 메시지\(서버 인증서, 서버 키 교환, 클라이언트 인증서 및 클라이언트 키 교환\)를 사용합니다. 이러한 메시지의 형식을 지정하고 클라이언트와 서버가 공유 비밀에 동의할 수 있도록 메시지 사용을 정의하여 새로운 키 교환 방법을 만들 수 있습니다. 이 비밀은 꽤 길어야 합니다. 현재 정의된 키 교환 방법은 48\~128바이트 길이의 비밀을 교환합니다.\(MUST\)

```text
   Following the hello messages, the server will send its certificate,
   if it is to be authenticated.  Additionally, a server key exchange
   message may be sent, if it is required (e.g., if the server has no
   certificate, or if its certificate is for signing only).  If the
   server is authenticated, it may request a certificate from the
   client, if that is appropriate to the cipher suite selected.  Next,
   the server will send the server hello done message, indicating that
   the hello-message phase of the handshake is complete.  The server
   will then wait for a client response.  If the server has sent a
   certificate request message, the client must send the certificate
   message.  The client key exchange message is now sent, and the
   content of that message will depend on the public key algorithm
   selected between the client hello and the server hello.  If the
   client has sent a certificate with signing ability, a digitally-
```

서명된 인증서 확인 메시지는 인증서를 명시적으로 확인하기 위해 전송됩니다.

이 시점에서 클라이언트는 암호 사양 변경 메시지를 보내고 클라이언트는 보류 중인 암호 사양을 현재 암호 사양으로 복사합니다. 그런 다음 클라이언트는 새 알고리즘, 키 및 비밀에 따라 완성된 메시지를 즉시 보냅니다. 이에 대한 응답으로 서버는 자체 변경 암호 사양 메시지를 보내고 현재 암호 사양으로 보류를 전송하고 새로운 암호 사양에서 완료된 메시지를 보냅니다. 이 시점에서 핸드셰이크가 완료되고 클라이언트와 서버는 응용 프로그램 계층 데이터 교환을 시작할 수 있습니다. \(아래 흐름도 참조\) 애플리케이션 데이터는 첫 번째 핸드셰이크가 완료되기 전에 전송되어서는 안 됩니다\(암호화 제품군이 다른 TLS\_NULL\_WITH\_NULL\_NULL이 설정되기 전에\).\(MUST NOT\)

```text
      Client                                               Server

      ClientHello                  -------->
                                                      ServerHello
                                                     Certificate*
                                               ServerKeyExchange*
                                              CertificateRequest*
                                   <--------      ServerHelloDone
      Certificate*
      ClientKeyExchange
      CertificateVerify*
      [ChangeCipherSpec]
      Finished                     -------->
                                               [ChangeCipherSpec]
                                   <--------             Finished
      Application Data             <------->     Application Data

             Fig. 1. Message flow for a full handshake
```

- \* 항상 전송되지 않는 선택적 또는 상황에 따른 메시지를 나타냅니다.

참고: 파이프라인 중단을 방지하기 위해 ChangeCipherSpec은

- 독립적인 TLS 프로토콜 콘텐츠 유형이며 실제로는 TLS 핸드셰이크 메시지가 아닙니다.

클라이언트와 서버가 이전 세션을 재개하거나 기존 세션을 복제하기로 결정할 때\(새 보안 매개변수를 협상하는 대신\) 메시지 흐름은 다음과 같습니다.

클라이언트는 재개할 세션의 세션 ID를 사용하여 ClientHello를 보냅니다. 그런 다음 서버는 일치하는 세션 캐시를 확인합니다.

일치하는 항목이 있고 서버가 지정된 세션 상태에서 연결을 다시 설정하려는 경우 동일한 세션 ID 값으로 ServerHello를 보냅니다. 이 시점에서 클라이언트와 서버는 모두 변경 암호 사양 메시지를 보내고 완료된 메시지로 직접 진행해야 합니다. 재설정이 완료되면 클라이언트와 서버는 애플리케이션 계층 데이터 교환을 시작할 수 있습니다. \(아래 순서도 참조\) 일치하는 세션 ID가 없으면 서버는 새 세션 ID를 생성하고 TLS 클라이언트와 서버는 전체 핸드셰이크를 수행합니다.\(MUST, MAY\)

```text
      Client                                                Server

      ClientHello                   -------->
                                                       ServerHello
                                                [ChangeCipherSpec]
                                    <--------             Finished
      [ChangeCipherSpec]
      Finished                      -------->
      Application Data              <------->     Application Data

          Fig. 2. Message flow for an abbreviated handshake
```

각 메시지의 내용과 의미는 다음 섹션에서 자세히 설명합니다.

---
### **7.4. Handshake Protocol**

TLS 핸드셰이크 프로토콜은 TLS 레코드 프로토콜의 정의된 상위 수준 클라이언트 중 하나입니다. 이 프로토콜은 세션의 보안 속성을 협상하는 데 사용됩니다. 핸드셰이크 메시지는 TLS 레코드 레이어에 제공되며, 여기서 핸드셰이크 메시지는 현재 활성 세션 상태에 지정된 대로 처리되고 전송되는 하나 이상의 TLSPlaintext 구조 내에 캡슐화됩니다.

```text
      enum {
          hello_request(0), client_hello(1), server_hello(2),
          certificate(11), server_key_exchange (12),
          certificate_request(13), server_hello_done(14),
          certificate_verify(15), client_key_exchange(16),
          finished(20), (255)
      } HandshakeType;

      struct {
          HandshakeType msg_type;    /* handshake type */
          uint24 length;             /* bytes in message */
          select (HandshakeType) {
              case hello_request:       HelloRequest;
              case client_hello:        ClientHello;

              case server_hello:        ServerHello;
              case certificate:         Certificate;
              case server_key_exchange: ServerKeyExchange;
              case certificate_request: CertificateRequest;
              case server_hello_done:   ServerHelloDone;
              case certificate_verify:  CertificateVerify;
              case client_key_exchange: ClientKeyExchange;
              case finished:            Finished;
          } body;
      } Handshake;
```

핸드셰이크 프로토콜 메시지는 전송되어야 하는 순서대로 아래에 표시됩니다. 예기치 않은 순서로 핸드셰이크 메시지를 보내면 치명적인 오류가 발생합니다. 그러나 불필요한 핸드셰이크 메시지는 생략할 수 있습니다. 순서에 대한 한 가지 예외에 유의하십시오. 인증서 메시지는 핸드셰이크에서 두 번 사용되지만\(서버에서 클라이언트로, 그 다음 클라이언트에서 서버로\) 첫 번째 위치에서만 설명됩니다. 이러한 순서 지정 규칙에 구속되지 않는 한 가지 메시지는 언제든지 보낼 수 있지만 핸드셰이크 도중에 도착하면 클라이언트에서 무시해야 하는 Hello 요청 메시지입니다.\(MUST\)

새로운 Handshake 메시지 유형 값은 RFC 2434 Standards Action을 통해 정의되어야 합니다. 이러한 값에 대한 IANA 고려 사항은 섹션 11을 참조하십시오.\(MUST\)

---
#### **7.4.1. Hello Messages**

Hello 단계 메시지는 클라이언트와 서버 간에 보안 강화 기능을 교환하는 데 사용됩니다. 새 세션이 시작되면 Record Layer의 연결 상태 암호화, 해시 및 압축 알고리즘이 null로 초기화됩니다. 현재 연결 상태는 재협상 메시지에 사용됩니다.

---
##### **7.4.1.1. Hello request**

이 메시지가 전송되는 시기:

- Hello 요청 메시지는 서버에서 언제든지 보낼 수 있습니다.\(MAY\)

이 메시지의 의미:

- Hello 요청은 클라이언트가 편리할 때 클라이언트 Hello 메시지를 전송하여 클라이언트가 협상 프로세스를 새로 시작해야 한다는 간단한 알림입니다. 클라이언트가 현재 세션을 협상 중인 경우 이 메시지는 클라이언트에서 무시됩니다. 클라이언트가 세션 재협상을 원하지 않는 경우 이 메시지를 무시하거나 원하는 경우 응답할 수 있습니다.

- no\_renegotiation 경고 포함. 핸드셰이크 메시지는 애플리케이션 데이터보다 전송 우선순위를 가지도록 되어 있으므로 클라이언트로부터 몇 개의 레코드만 수신되기 전에 협상이 시작될 것으로 예상됩니다. 서버가 hello 요청을 보냈지만 응답으로 클라이언트 hello를 받지 못한 경우 치명적인 경고와 함께 연결을 닫을 수 있습니다.

- 서버는 Hello 요청을 보낸 후 후속 핸드셰이크 협상이 완료될 때까지 요청을 반복하지 않아야 합니다.\(SHOULD\)

- 이 메시지의 구조:

```text
             struct { } HelloRequest;
```

참고: 이 메시지는 핸드셰이크 전체에서 유지되고 완료된 메시지와 인증서 확인 메시지에 사용되는 메시지 해시에 포함되어서는 안 됩니다\(MUST NOT\).\(MUST NOT\)

---
##### **7.4.1.2. Client Hello**

이 메시지가 전송되는 시기:

- 클라이언트가 서버에 처음 연결할 때 첫 번째 메시지로 클라이언트 hello를 보내야 합니다. 또한 클라이언트는 기존 연결에서 보안 매개변수를 재협상하기 위해 Hello 요청에 대한 응답으로 또는 자체 이니셔티브에서 클라이언트 Hello를 보낼 수 있습니다.

이 메시지의 구조:

- 클라이언트 헬로 메시지는 나중에 프로토콜에서 사용되는 임의의 구조를 포함합니다.

```text
      struct {
         uint32 gmt_unix_time;
         opaque random_bytes[28];
      } Random;
```

gmt\_unix\_time 발신자의 내부 시계에 따른 표준 UNIX 32비트 형식\(1970년 1월 1일 자정 이후의 초\(GMT, 윤초 무시\)\)의 현재 시간 및 날짜입니다. 시계는 기본 TLS 프로토콜에 의해 올바르게 설정될 필요가 없습니다. 상위 수준 또는 응용 프로그램 프로토콜은 추가 요구 사항을 정의할 수 있습니다.

random\_bytes

- 안전한 난수 생성기에 의해 생성된 28바이트.

클라이언트 헬로 메시지에는 가변 길이 세션 식별자가 포함됩니다. 비어 있지 않은 경우 값은 클라이언트가 재사용하려는 보안 매개변수가 있는 동일한 클라이언트와 서버 간의 세션을 식별합니다. 세션 식별자는 이전 연결, 이 연결 또는 현재 활성화된 다른 연결에서 온 것일 수 있습니다. 두 번째 옵션은 클라이언트가 연결의 임의 구조 및 파생 값만 업데이트하려는 경우에 유용하며 세 번째 옵션을 사용하면 전체 핸드셰이크 프로토콜을 반복하지 않고 여러 개의 독립적인 보안 연결을 설정할 수 있습니다. 이러한 독립적인 연결은 순차적으로 또는 동시에 발생할 수 있습니다. SessionID는 Finished 메시지 교환으로 협상하는 핸드셰이크가 완료될 때 유효하게 되며, 에이징으로 인해 또는 세션과 연결된 연결에서 치명적인 오류가 발생하여 제거될 때까지 지속됩니다. SessionID의 실제 내용은 서버에서 정의합니다.\(MAY\)

```text
      opaque SessionID<0..32>;
```

경고: SessionID는 암호화 또는 즉각적인 MAC 보호 없이 전송되기 때문에 서버는 기밀 정보를 세션 식별자에 배치하거나 가짜 세션 식별자의 내용으로 인해 보안 위반이 발생하도록 해서는 안 됩니다. \(SessionID를 포함하여 전체 핸드셰이크의 내용은 핸드셰이크가 끝날 때 교환되는 Finished 메시지에 의해 보호됩니다.\)\(MUST\)

클라이언트 헬로 메시지에서 클라이언트에서 서버로 전달되는 CipherSuite 목록에는 클라이언트가 선호하는 순서대로\(선호하는 선택부터\) 클라이언트가 지원하는 암호화 알고리즘의 조합이 포함되어 있습니다. 각 CipherSuite는 키 교환 알고리즘, 대량 암호화 알고리즘\(비밀 키 길이 포함\) 및 MAC 알고리즘을 정의합니다. 서버는 암호 그룹을 선택하거나 허용 가능한 선택 항목이 없으면 핸드셰이크 실패 경고를 반환하고 연결을 닫습니다.

```text
      uint8 CipherSuite[2];    /* Cryptographic suite selector */
```

클라이언트 hello에는 클라이언트가 지원하는 압축 알고리즘 목록이 포함되어 있으며 클라이언트의 기본 설정에 따라 정렬됩니다.

```text
      enum { null(0), (255) } CompressionMethod;

      struct {
          ProtocolVersion client_version;
          Random random;
          SessionID session_id;
          CipherSuite cipher_suites<2..2^16-1>;
          CompressionMethod compression_methods<1..2^8-1>;
      } ClientHello;
```

클라이언트\_버전

- 클라이언트가 이 세션 동안 통신하고자 하는 TLS 프로토콜의 버전입니다. 이것은 클라이언트가 지원하는 최신\(가장 높은 값\) 버전이어야 합니다\(SHOULD\). 이 사양 버전의 경우 버전은 3.2입니다. \(이전 버전과의 호환성에 대한 자세한 내용은 부록 E를 참조하십시오.\)\(SHOULD\)

무작위의

- 클라이언트 생성 임의 구조.

session\_id

- 클라이언트가 이 연결에 사용하려는 세션의 ID입니다. 사용 가능한 session\_id가 없거나 클라이언트가 새 보안 매개변수를 생성하려는 경우 이 필드는 비어 있어야 합니다.

cipher\_suites

- 이것은 클라이언트가 지원하는 암호화 옵션 목록이며 클라이언트의 첫 번째 기본 설정이 먼저입니다. session\_id 필드가 비어 있지 않은 경우\(세션 재개 요청을 의미\) 이 벡터에는 적어도 해당 세션의 cipher\_suite가 포함되어야 합니다. 값은 부록 A.5에 정의되어 있습니다.\(MUST\)

압축 방법

- 클라이언트 기본 설정에 따라 정렬된 클라이언트에서 지원하는 압축 방법 목록입니다. session\_id 필드가 비어 있지 않으면\(세션 재개 요청을 의미\) 해당 세션의 compression\_method를 포함해야 합니다. 이 벡터는 CompressionMethod.null을 포함해야 하며 모든 구현이 지원해야 합니다. 따라서 클라이언트와 서버는 항상 압축 방법에 동의할 수 있습니다.\(MUST, MUST\)

클라이언트 Hello 메시지를 보낸 후 클라이언트는 서버 Hello 메시지를 기다립니다. hello 요청을 제외하고 서버에서 반환된 다른 모든 핸드셰이크 메시지는 치명적인 오류로 처리됩니다.

전방 호환성 참고: 전방 호환성을 위해 클라이언트 Hello 메시지에 압축 방법 이후에 추가 데이터를 포함하는 것이 허용됩니다. 이 데이터는 반드시 포함되어야 합니다\(MUST\)

핸드셰이크 해시에 있지만 그렇지 않으면 무시해야 합니다. 이것이 합법적인 유일한 핸드셰이크 메시지입니다. 다른 모든 메시지의 경우 메시지의 데이터 양이 메시지의 설명과 정확하게 일치해야 합니다.\(MUST\)

- 참고: ClientHello에서 후행 데이터의 의도된 사용에 대해서는 RFC 3546 \[TLSEXT\]를 참조하십시오.

---
##### **7.4.1.3. Server Hello**

서버는 허용 가능한 알고리즘 집합을 찾을 수 있을 때 클라이언트 hello 메시지에 대한 응답으로 이 메시지를 보냅니다. 일치하는 항목을 찾을 수 없으면 핸드셰이크 실패 경고로 응답합니다.

이 메시지의 구조:

```text
       struct {
           ProtocolVersion server_version;
           Random random;
           SessionID session_id;
           CipherSuite cipher_suite;
           CompressionMethod compression_method;
       } ServerHello;
```

서버 버전

- 이 필드는 클라이언트 hello에서 클라이언트가 제안한 것 중 낮은 값과 서버에서 지원하는 가장 높은 값을 포함합니다. 이 사양 버전의 경우 버전은 3.2입니다. \(이전 버전과의 호환성에 대한 자세한 내용은 부록 E를 참조하십시오.\)

무작위의

- 이 구조는 서버에서 생성되며 ClientHello.random과 독립적으로 생성되어야 합니다.\(MUST\)

session\_id

- 이 연결에 해당하는 세션의 ID입니다. ClientHello.session\_id가 비어 있지 않은 경우 서버는 세션 캐시에서 일치 항목을 찾습니다. 일치하는 항목이 있고 서버가 지정된 세션 상태를 사용하여 새 연결을 설정하려는 경우 서버는 클라이언트가 제공한 것과 동일한 값으로 응답합니다. 이는 재개된 세션을 나타내며 당사자가 완료된 메시지로 직접 진행해야 함을 나타냅니다. 그렇지 않으면 이 필드에 새 세션을 식별하는 다른 값이 포함됩니다. 서버는 세션이 캐시되지 않으므로 재개할 수 없음을 나타내기 위해 빈 session\_id를 반환할 수 있습니다. 세션이 재개되면 원래 협상했던 것과 동일한 암호 제품군을 사용하여 재개해야 합니다.

cipher\_suite

- ClientHello.cipher\_suites의 목록에서 서버가 선택한 단일 암호 그룹. 재개된 세션의 경우 이 필드는 재개 중인 세션 상태의 값입니다.

compression\_method ClientHello.compression\_methods의 목록에서 서버가 선택한 단일 압축 알고리즘입니다. 재개된 세션의 경우 이 필드는 재개된 세션 상태의 값입니다.

---
#### **7.4.2. Server Certificate**

이 메시지가 전송되는 시기:

- 서버는 합의된 키 교환 방법이 익명이 아닐 때마다 인증서를 보내야 합니다. 이 메시지는 항상 서버 안녕하세요 메시지 바로 뒤에 옵니다.\(MUST\)

이 메시지의 의미:

- 인증서 유형은 선택한 암호 그룹의 키 교환 알고리즘에 적합해야 하며 일반적으로 X.509v3 인증서입니다. 다음과 같이 키 교환 방법과 일치하는 키를 포함해야 합니다. 별도로 지정하지 않는 한 인증서의 서명 알고리즘은 인증서 키의 알고리즘과 동일해야 합니다. 달리 지정하지 않는 한 공개 키는 길이에 제한이 없습니다.\(MUST, MUST, MUST, MAY\)

```text
      Key Exchange Algorithm  Certificate Key Type
```

- RSA RSA 공개 키 인증서는 키가 암호화에 사용되도록 허용해야 합니다.\(MUST\)

```text
      DHE_DSS                 DSS public key.
```

- DHE\_RSA 서명에 사용할 수 있는 RSA 공개 키입니다.

- DH\_DSS Diffie-Hellman 키. 인증서 서명에 사용되는 알고리즘은 DSS여야 합니다.\(MUST\)

- DH\_RSA Diffie-Hellman 키. 인증서 서명에 사용되는 알고리즘은 RSA여야 합니다.\(MUST\)

모든 인증서 프로필과 키 및 암호화 형식은 IETF PKIX 워킹 그룹\[PKIX\]에서 정의합니다. 키 사용 확장이 있는 경우 위에서 설명한 대로 서명에 적합하도록 키에 대해 digitalSignature 비트를 설정해야 하며 위에서 설명한 것처럼 암호화를 허용하려면 keyEncipherment 비트가 있어야 합니다. keyAgreement 비트는 Diffie-Hellman 인증서에 설정되어야 합니다.\(MUST\)

새 키 교환 방법을 지정하는 CipherSuite는 TLS 프로토콜에 대해 지정되므로 인증서 형식과 필요한 인코딩된 키 정보를 의미합니다.

이 메시지의 구조:

```text
      opaque ASN.1Cert<1..2^24-1>;

      struct {
          ASN.1Cert certificate_list<0..2^24-1>;
      } Certificate;
```

인증서 목록

- 이것은 X.509v3 인증서의 시퀀스\(체인\)입니다. 보낸 사람의 인증서가 목록의 첫 번째에 와야 합니다. 다음 각 인증서는 이전 인증서를 직접 인증해야 합니다. 인증서 유효성 검사에는 루트 키가 독립적으로 배포되어야 하므로 루트 인증 기관을 지정하는 자체 서명된 인증서는 어떤 경우에도 유효성을 검사하기 위해 원격 끝이 이미 소유하고 있어야 한다는 가정하에 선택적으로 체인에서 생략될 수 있습니다.

동일한 메시지 유형 및 구조가 인증서 요청 메시지에 대한 클라이언트의 응답에 사용됩니다. 클라이언트는\(MAY\)

서버의 인증 요청에 대한 응답으로 보낼 적절한 인증서가 없으면 인증서를 보내지 않습니다.

참고: PKCS #7 \[PKCS7\]은

- PKCS #6 \[PKCS6\] 확장 인증서가 사용되지 않기 때문에 인증서 벡터. 또한 PKCS #7은 SEQUENCE가 아닌 SET를 정의하므로 목록 구문 분석 작업이 더 어려워집니다.

---
#### **7.4.3. Server Key Exchange Message**

이 메시지가 전송되는 시기:

- 이 메시지는 서버 인증서 메시지\(또는 익명 협상인 경우 서버 Hello 메시지\) 직후에 전송됩니다.

- 서버 인증서 메시지\(전송된 경우\)에 클라이언트가 premaster secret을 교환할 수 있는 충분한 데이터가 포함되어 있지 않은 경우에만 서버에서 서버 키 교환 메시지를 보냅니다. 이는 다음 키 교환 방법에 해당됩니다.

```text
           DHE_DSS
           DHE_RSA
           DH_anon
```

- 다음 키 교환 방법에 대해 서버 키 교환 메시지를 보내는 것은 합법적이지 않습니다.

```text
           RSA
           DH_DSS
           DH_RSA
```

이 메시지의 의미:

- 이 메시지는 클라이언트가 프리마스터 시크릿을 통신할 수 있도록 암호화 정보를 전달합니다. 프리마스터 시크릿을 암호화하는 데 사용하는 RSA 공개 키 또는 클라이언트가 키 교환을 완료할 수 있는 Diffie-Hellman 공개 키\(결과는 다음과 같음\) 프리마스터 시크릿\).

새로운 키 교환 알고리즘을 포함하는 TLS에 대해 추가 CipherSuite가 정의되므로 서버 키 교환 메시지는 키 교환 알고리즘과 연결된 인증서 유형이 클라이언트가 premaster secret을 교환하기에 충분한 정보를 제공하지 않는 경우에만 전송됩니다.

이 메시지의 구조:

```text
      enum { rsa, diffie_hellman } KeyExchangeAlgorithm;

      struct {
          opaque rsa_modulus<1..2^16-1>;
          opaque rsa_exponent<1..2^16-1>;
      } ServerRSAParams;
```

rsa\_modulus

- 서버의 임시 RSA 키 계수입니다.

rsa\_exponent

- 서버 임시 RSA 키의 공개 지수.

```text
      struct {
          opaque dh_p<1..2^16-1>;
          opaque dh_g<1..2^16-1>;
          opaque dh_Ys<1..2^16-1>;
      } ServerDHParams;     /* Ephemeral DH parameters */
```

dh\_p

- Diffie-Hellman 연산에 사용되는 프라임 계수입니다.

dh\_g

- Diffie-Hellman 작업에 사용되는 생성기.

dh\_Ys

- 서버의 Diffie-Hellman 공개 값\(g^X mod p\).

```text
      struct {
          select (KeyExchangeAlgorithm) {
              case diffie_hellman:
                  ServerDHParams params;
                  Signature signed_params;
              case rsa:
                  ServerRSAParams params;
                  Signature signed_params;
          };
      } ServerKeyExchange;

      struct {
          select (KeyExchangeAlgorithm) {
              case diffie_hellman:
                  ServerDHParams params;
              case rsa:
                  ServerRSAParams params;
          };
       } ServerParams;
```

매개변수

- 서버의 키 교환 매개변수.

signed\_params

- 비익명 키 교환의 경우 해당 해시에 적절한 서명이 적용된 해당 params 값의 해시.

```text
      md5_hash
          MD5(ClientHello.random + ServerHello.random + ServerParams);

      sha_hash
          SHA(ClientHello.random + ServerHello.random + ServerParams);

      enum { anonymous, rsa, dsa } SignatureAlgorithm;

      struct {
          select (SignatureAlgorithm) {
              case anonymous: struct { };
              case rsa:
                  digitally-signed struct {
                      opaque md5_hash[16];
                      opaque sha_hash[20];
                  };
              case dsa:
                  digitally-signed struct {
                      opaque sha_hash[20];
                  };
              };
          };
      } Signature;
```

---
#### **7.4.4. Certificate request**

이 메시지가 전송되는 시기:

- 비익명 서버는 선택한 암호 그룹에 적합한 경우 클라이언트에서 선택적으로 인증서를 요청할 수 있습니다.

- 이 메시지가 전송되면 서버 키 교환 메시지\(전송된 경우, 그렇지 않은 경우 서버 인증서 메시지\) 바로 뒤에 옵니다.

이 메시지의 구조:

```text
      enum {
          rsa_sign(1), dss_sign(2), rsa_fixed_dh(3), dss_fixed_dh(4),
       rsa_ephemeral_dh_RESERVED(5), dss_ephemeral_dh_RESERVED(6),
       fortezza_dms_RESERVED(20),
          (255)

      } ClientCertificateType;

      opaque DistinguishedName<1..2^16-1>;

      struct {
          ClientCertificateType certificate_types<1..2^8-1>;
          DistinguishedName certificate_authorities<0..2^16-1>;
      } CertificateRequest;
```

인증서 유형

- 이 필드는 서버의 기본 설정 순서대로 정렬된 요청된 인증서 유형 목록입니다.

인증 기관

- 허용되는 인증 기관의 고유 이름 목록입니다. 이러한 고유 이름은 루트 CA 또는 하위 CA에 대해 원하는 고유 이름을 지정할 수 있습니다. 따라서 이 메시지는 알려진 루트와 원하는 인증 공간을 모두 설명하는 데 사용할 수 있습니다. certificate\_authorities 목록이 비어 있으면 클라이언트는 반대되는 외부 배열이 없는 한 적절한 ClientCertificateType의 인증서를 보낼 수 있습니다\(MAY\).\(MAY\)

ClientCertificateType 값은 세 그룹으로 나뉩니다.

- 1. 0\(영\)에서 63진수\(0x3F\)까지의 값은 IETF Standards Track 프로토콜용으로 예약되어 있습니다.

- 2. 64진수\(0x40\)에서 223진수\(0xDF\)까지의 값은 비표준 추적 방법에 대한 할당을 위해 예약되어 있습니다.

- 3. 224 십진수\(0xE0\)에서 255 십진수\(0xFF\)까지의 값은 개인용으로 예약되어 있습니다.

ClientCertificateType 코드 포인트 할당에서 IANA의 역할을 설명하는 추가 정보는 섹션 11에 설명되어 있습니다.

참고: RESERVED로 나열된 값은 사용할 수 없습니다. 그것들은 SSLv3에서 사용되었습니다.

참고: DistinguishedName은 \[X501\]에서 파생됩니다. DistinguishedName은 DER 인코딩 형식으로 표시됩니다.

참고: 익명 서버가 클라이언트 인증을 요청하는 것은 치명적인 handshake\_failure 경고입니다.

---
#### **7.4.5. Server Hello Done**

이 메시지가 전송되는 시기:

- server hello done 메시지는 서버 hello 및 관련 메시지의 끝을 나타내기 위해 서버에서 전송됩니다. 이 메시지를 보낸 후 서버는 클라이언트 응답을 기다립니다.

이 메시지의 의미:

- 이 메시지는 서버가 키 교환을 지원하기 위한 메시지 전송을 완료했으며 클라이언트가 키 교환 단계를 진행할 수 있음을 의미합니다.

- 서버 헬로 완료 메시지를 수신하면 클라이언트는 필요한 경우 서버가 유효한 인증서를 제공했는지 확인하고 서버 헬로 매개변수가 허용 가능한지 확인해야 합니다.\(SHOULD\)

이 메시지의 구조:

```text
      struct { } ServerHelloDone;
```

---
#### **7.4.6. Client certificate**

이 메시지가 전송되는 시기:

- 클라이언트가 서버 헬로 완료 메시지를 수신한 후 보낼 수 있는 첫 번째 메시지입니다. 이 메시지는 서버가 인증서를 요청하는 경우에만 전송됩니다. 적합한 인증서가 없으면 클라이언트는 인증서가 포함되지 않은 인증서 메시지를 보내야 합니다\(SHOULD\). 즉, certificate\_list 구조의 길이는 0입니다. 핸드셰이크를 계속하기 위해 서버에서 클라이언트 인증이 필요한 경우 치명적인 핸드셰이크 실패 경고로 응답할 수 있습니다. 클라이언트 인증서는 섹션 7.4.2에 정의된 인증서 구조를 사용하여 전송됩니다.\(SHOULD\)

참고: 정적 Diffie-Hellman 기반 키 교환 방법\(DH\_DSS 또는 DH\_RSA\)을 사용할 때 클라이언트 인증이 요청되면 클라이언트의 인증서에 인코딩된 Diffie-Hellman 그룹 및 생성기는 클라이언트의 매개변수가 서버에서 지정한 Diffie-Hellman 매개변수와 일치해야 합니다. 키 교환에 사용됩니다.\(MUST\)

---
#### **7.4.7. Client Key Exchange Message**

이 메시지가 전송되는 시기:

- 이 메시지는 항상 클라이언트에서 전송됩니다. 클라이언트 인증서 메시지가 전송된 경우 바로 뒤에 와야 합니다\(MUST\). 그렇지 않으면 클라이언트가 서버 hello done 메시지를 수신한 후 클라이언트가 보내는 첫 번째 메시지여야 합니다.\(MUST, MUST\)

이 메시지의 의미:

- 이 메시지와 함께 RSA 암호화된 비밀의 직접 전송 또는 각 측에서 동일한 프리마스터 비밀에 동의할 수 있는 Diffie-Hellman 매개변수의 전송을 통해 프리마스터 비밀이 설정됩니다. 키 교환 방법이 DH\_RSA 또는 DH\_DSS인 경우 클라이언트 인증이 요청되었으며 클라이언트는 매개변수\(그룹 및 생성기\)가 인증서의 서버에서 지정한 것과 일치하는 Diffie-Hellman 공개 키가 포함된 인증서로 응답할 수 있었습니다. , 이 메시지에는 데이터가 포함되어서는 안 됩니다\(MUST\).\(MUST\)

이 메시지의 구조:

- 메시지 선택은 선택한 키 교환 방법에 따라 다릅니다. KeyExchangeAlgorithm 정의에 대해서는 섹션 7.4.3을 참조하십시오.

```text
      struct {
          select (KeyExchangeAlgorithm) {
              case rsa: EncryptedPreMasterSecret;
              case diffie_hellman: ClientDiffieHellmanPublic;
          } exchange_keys;
      } ClientKeyExchange;
```

---
##### **7.4.7.1. RSA Encrypted Premaster Secret Message**

이 메시지의 의미:

- 키 동의 및 인증에 RSA를 사용하는 경우 클라이언트는 48바이트의 premaster secret을 생성하고 서버 인증서의 공개 키 또는 임시 RSA 키를 사용하여 암호화합니다.

- 서버 키 교환 메시지로 제공되며, 결과는 암호화된 premaster secret 메시지로 전송됩니다. 이 구조는 클라이언트 키 교환 메시지의 변형이며 그 자체는 메시지가 아닙니다.

이 메시지의 구조:

```text
      struct {
          ProtocolVersion client_version;
          opaque random[46];
      } PreMasterSecret;
```

- client\_version 클라이언트에서 지원하는 최신\(최신\) 버전입니다. 이것은 버전 롤백 공격을 탐지하는 데 사용됩니다. premaster secret을 수신하면 서버는 이 값이 클라이언트 hello 메시지에서 클라이언트가 전송한 값과 일치하는지 확인해야 합니다\(SHOULD\).\(SHOULD\)

```text
      random
          46 securely-generated random bytes.

      struct {
          public-key-encrypted PreMasterSecret pre_master_secret;
      } EncryptedPreMasterSecret;
```

pre\_master\_secret

- 이 무작위 값은 클라이언트에 의해 생성되며 섹션 8.1에 지정된 대로 마스터 비밀을 생성하는 데 사용됩니다.

참고: Daniel Bleichenbacher\[BLEI\]가 발견한 공격은 PKCS#1 v 1.5로 인코딩된 RSA를 사용하는 TLS 서버를 공격하는 데 사용될 수 있습니다. 이 공격은 다양한 방식으로 실패함으로써 특정 메시지가 해독될 때 PKCS#1 v1.5 형식이 적절하게 지정되었는지 여부를 공개하도록 TLS 서버를 강요할 수 있다는 사실을 이용합니다.

- 이 공격에 대한 취약성을 피하는 가장 좋은 방법은 올바른 형식의 RSA 블록과 구별할 수 없는 방식으로 잘못된 형식의 메시지를 처리하는 것입니다. 따라서 서버가 잘못된 형식의 RSA 블록을 수신하면 임의의 48바이트 값을 생성하고 이를 premaster secret으로 사용하여 진행해야 합니다. 따라서 서버는 수신된 RSA 블록이 올바르게 인코딩되었는지 여부에 관계없이 동일하게 작동합니다.

- \[PKCS1B\]는 Bleichenbacher 공격에 대해 더 안전한 최신 버전의 PKCS#1 인코딩을 정의합니다. 그러나 TLS 1.0과의 최대 호환성을 위해 TLS 1.1은 원래 인코딩을 유지합니다. Bleichenbacher 공격의 변종 없음

- 위의 권장 사항을 따르는 경우 존재하는 것으로 알려져 있습니다.

구현 참고 사항: 공개 키로 암호화된 데이터는 불투명 벡터 <0..2^16-1\>로 표시됩니다\(섹션 4.7 참조\). 따라서 ClientKeyExchange의 RSA 암호화 PreMasterSecret 앞에는 2바이트 길이가 있습니다. EncryptedPreMasterSecret이 ClientKeyExchange의 유일한 데이터이므로 길이를 명확하게 결정할 수 있기 때문에 이러한 바이트는 RSA의 경우 중복됩니다. SSLv3 사양은 공개 키 암호화 데이터의 인코딩에 대해 명확하지 않았으므로 많은 SSLv3 구현에는 길이 바이트가 포함되지 않고 ClientKeyExchange 메시지에서 RSA 암호화 데이터를 직접 인코딩합니다.

- 이 사양에는 길이 바이트가 포함된 EncryptedPreMasterSecret의 올바른 인코딩이 필요합니다. 결과 PDU는 많은 SSLv3 구현과 호환되지 않습니다. SSLv3에서 업그레이드하는 구현자는 올바른 인코딩을 생성하고 수락하도록 구현을 수정해야 합니다. SSLv3 및 TLS 모두와 호환되길 원하는 구현자는 프로토콜 버전에 따라 구현 동작을 만들어야 합니다.

구현 참고 사항: 적어도 클라이언트와 서버가 동일한 LAN에 있을 때 SSL에 대한 원격 타이밍 기반 공격이 가능하다는 것이 이제 알려져 있습니다. 따라서 정적 RSA 키를 사용하는 구현은 \[타이밍\]에 설명된 대로 RSA 블라인드 또는 기타 안티 타이밍 기술을 사용해야 합니다\(SHOULD\).\(SHOULD\)

참고: PreMasterSecret의 버전 번호는 연결을 위해 협상된 버전이 아니라 ClientHello에서 클라이언트가 제공한 버전이어야 합니다. 이 기능은 롤백 공격을 방지하도록 설계되었습니다. 불행하게도 많은 구현에서는 협상된 버전을 대신 사용하므로 버전 번호를 확인하면 이러한 잘못된 클라이언트 구현과 상호 운용하지 못할 수 있습니다. 클라이언트 구현, MUST 및 서버 구현은 버전 번호를 확인할 수 있습니다\(MAY\). 실제로 TLS 핸드셰이크 MAC은 다운그레이드를 방지하고 이러한 MAC에 대한 좋은 공격이 알려져 있지 않기 때문에 모호성은 심각한 보안 위험으로 간주되지 않습니다. 서버가 버전 번호를 확인하기로 선택한 경우\(MUST, MUST\)

- Bleichenbacher 공격의 변종을 피하기 위해 오류 발생 시 경고를 생성하는 대신 PreMasterSecret. \[KPR03\]

---
##### **7.4.7.2. Client Diffie-Hellman Public Value**

이 메시지의 의미:

- 이 구조는 클라이언트의 인증서에 아직 포함되지 않은 경우 클라이언트의 Diffie-Hellman 공개 값\(Yc\)을 전달합니다. Yc에 사용되는 인코딩은 열거된 PublicValueEncoding에 의해 결정됩니다. 이 구조는 클라이언트 키 교환 메시지의 변형이며 자체 메시지가 아닙니다.

이 메시지의 구조:

```text
      enum { implicit, explicit } PublicValueEncoding;
```

절대적인

- 클라이언트 인증서에 이미 적합한 Diffie-Hellman 키가 포함된 경우 Yc는 암시적이며 다시 보낼 필요가 없습니다. 이 경우 클라이언트 키 교환 메시지가 전송되지만 비어 있어야 합니다.\(MUST\)

명백한

- Yc를 보내야 합니다.

```text
      struct {
          select (PublicValueEncoding) {
              case implicit: struct { };
              case explicit: opaque dh_Yc<1..2^16-1>;
          } dh_public;
      } ClientDiffieHellmanPublic;
```

dh\_Yc

- 클라이언트의 Diffie-Hellman 공개 값\(Yc\).

---
#### **7.4.8. Certificate verify**

이 메시지가 전송되는 시기:

- 이 메시지는 클라이언트 인증서의 명시적 확인을 제공하는 데 사용됩니다. 이 메시지는 서명 기능이 있는 클라이언트 인증서\(즉, 고정 Diffie-Hellman 매개변수를 포함하는 인증서를 제외한 모든 인증서\) 다음에만 전송됩니다. 전송되면 즉시 클라이언트 키 교환 메시지를 따라야 합니다.\(MUST\)

이 메시지의 구조:

```text
      struct {
           Signature signature;
      } CertificateVerify;
```

- 서명 유형은 7.4.3에 정의되어 있습니다.

```text
      CertificateVerify.signature.md5_hash
          MD5(handshake_messages);

      CertificateVerify.signature.sha_hash
          SHA(handshake_messages);
```

여기서 handshake\_messages는 핸드셰이크 메시지의 유형 및 길이 필드를 포함하여 이 메시지를 포함하지 않고 클라이언트 hello에서 시작하여 보내거나 받은 모든 핸드셰이크 메시지를 나타냅니다. 이것은 7.4에서 정의된 대로 지금까지 교환된 모든 Handshake 구조의 연결입니다.

---
#### **7.4.9. Finished**

이 메시지가 전송되는 시기:

- 완료된 메시지는 항상 키 교환 및 인증 프로세스가 성공적이었는지 확인하기 위해 변경 암호 사양 메시지 직후에 전송됩니다. 다른 Handshake 메시지와 Finished 메시지 사이에 Change cipher spec 메시지가 수신되어야 합니다.

이 메시지의 의미:

- 완료된 메시지는 방금 협상된 알고리즘, 키 및 비밀로 첫 번째로 보호됩니다. 완료된 메시지의 수신자는 내용이 올바른지 확인해야 합니다. 한 쪽이 Finished 메시지를 전송하고 해당 피어로부터 Finished 메시지를 수신 및 확인하면 연결을 통해 애플리케이션 데이터를 송수신하기 시작할 수 있습니다.\(MUST\)

```text
      struct {
          opaque verify_data[12];
      } Finished;

      verify_data
          PRF(master_secret, finished_label, MD5(handshake_messages) +
          SHA-1(handshake_messages)) [0..11];
```

완료\_라벨

- 클라이언트가 보낸 완료 메시지의 경우 문자열 "클라이언트 완료". 서버에서 보낸 Finished 메시지의 경우 "server finished" 문자열입니다.

handshake\_messages

- 이 핸드셰이크의 모든 메시지\(HelloRequest 메시지 제외\)에서 이 메시지까지의 모든 데이터. 이는 핸드셰이크 레이어에서만 볼 수 있는 데이터이며 레코드 레이어 헤더는 포함하지 않습니다. 이것은 7.4에서 정의된 대로 지금까지 교환된 모든 Handshake 구조의 연결입니다.

완료된 메시지 앞에 핸드셰이크의 적절한 지점에서 암호 사양 변경 메시지가 오지 않으면 치명적인 오류입니다.

handshake\_messages 값에는 클라이언트 hello에서 시작하여 이 완료된 메시지까지의 모든 핸드셰이크 메시지가 포함됩니다. 이는 인증서 확인 메시지\(전송된 경우\)를 포함하기 때문에 섹션 7.4.8의 handshake\_messages와 다를 수 있습니다. 또한 클라이언트에서 보낸 완료된 메시지의 handshake\_messages는 두 번째로 보낸 메시지에 이전 메시지가 포함되기 때문에 서버에서 보낸 완료된 메시지의 handshake\_messages와 다릅니다.

참고: 암호 사양 변경 메시지, 경고 및 기타 레코드 유형은 핸드셰이크 메시지가 아니며 해시 계산에 포함되지 않습니다. 또한 Hello 요청 메시지는 핸드셰이크 해시에서 생략됩니다.

---
## **8. Cryptographic Computations**

연결 보호를 시작하기 위해 TLS 레코드 프로토콜은 일련의 알고리즘, 마스터 암호, 클라이언트 및 서버 임의 값을 지정해야 합니다. 인증, 암호화 및 MAC 알고리즘은 서버에서 선택한 cipher\_suite에 의해 결정되며 서버 hello 메시지에 표시됩니다. 압축 알고리즘은 hello 메시지에서 협상되고 무작위 값은 hello 메시지에서 교환됩니다. 남은 것은 마스터 시크릿을 계산하는 것입니다.

---
### **8.1. Computing the Master Secret**

모든 키 교환 방법에 대해 pre\_master\_secret을 master\_secret으로 변환하는 데 동일한 알고리즘이 사용됩니다. pre\_master\_secret은 master\_secret이 계산되면 메모리에서 삭제되어야 합니다.

```text
       master_secret = PRF(pre_master_secret, "master secret",
                           ClientHello.random + ServerHello.random)
       [0..47];
```

마스터 비밀의 길이는 항상 정확히 48바이트입니다. 프리마스터 시크릿의 길이는 키 교환 방법에 따라 달라집니다.

---
#### **8.1.1. RSA**

서버 인증 및 키 교환에 RSA를 사용하는 경우 클라이언트에서 48바이트 pre\_master\_secret을 생성하고 서버의 공개 키로 암호화하여 서버로 보냅니다. 서버는 개인 키를 사용하여 pre\_master\_secret을 해독합니다. 그런 다음 양 당사자는 위에 지정된 대로 pre\_master\_secret을 master\_secret으로 변환합니다.

RSA 디지털 서명은 PKCS #1 \[PKCS1\] 블록 유형 1을 사용하여 수행됩니다. RSA 공개 키 암호화는 PKCS #1 블록 유형 2를 사용하여 수행됩니다.

---
#### **8.1.2. Diffie-Hellman**

기존의 Diffie-Hellman 계산이 수행됩니다. 협상된 키\(Z\)는 pre\_master\_secret으로 사용되며 위에서 지정한 대로 master\_secret으로 변환됩니다. 모두 0비트를 포함하는 Z의 선행 바이트는 pre\_master\_secret으로 사용되기 전에 제거됩니다.

참고: Diffie-Hellman 매개변수는 서버에서 지정하며 일시적이거나 서버의 인증서 내에 포함될 수 있습니다.

---
## **9. Mandatory Cipher Suites**

달리 지정하는 응용 프로그램 프로필 표준이 없는 경우 TLS 호환 응용 프로그램은 암호화 제품군 TLS\_RSA\_WITH\_3DES\_EDE\_CBC\_SHA를 구현해야 합니다.\(MUST\)

---
## **10. Application Data Protocol**

애플리케이션 데이터 메시지는 레코드 레이어에 의해 전달되며 현재 연결 상태에 따라 조각화, 압축 및 암호화됩니다. 메시지는 레코드 레이어에 투명한 데이터로 처리됩니다.

---
## **11. Security Considerations**

보안 문제는 이 메모 전체, 특히 부록 D, E 및 F에서 논의됩니다.

---
## **12. IANA Considerations**

이 문서는 IANA에서 생성한 여러 새 레지스트리에 대해 설명합니다. 공통 TLS 범주 아래에 개별 레지스트리 항목으로 배치하는 것이 좋습니다.

섹션 7.4.3은 IANA가 유지 관리할 TLS ClientCertificateType 레지스트리를 설명하며 이러한 코드 포인트 식별자의 수를 정의합니다. 값이 0-63\(10진수\) 범위에 있는 ClientCertificateType 식별자는 RFC 2434 Standards Action을 통해 할당됩니다. 64-223\(10진수\) 범위의 값은 \[RFC2434\] 사양 요구 사항을 통해 할당됩니다. 224-255\(십진수\) 범위의 식별자 값은 RFC 2434 개인용으로 예약되어 있습니다. 레지스트리는 처음에 이 문서 섹션 7.4.4의 값으로 채워집니다.

섹션 A.5는 IANA가 유지 관리할 TLS 암호 그룹 레지스트리를 설명하고 이러한 암호 그룹 식별자의 수를 정의합니다. 0-191\(10진수\) 범위의 첫 번째 바이트가 포함된 암호 그룹 값은 RFC 2434 Standards Action을 통해 할당됩니다. 192-254\(10진수\) 범위의 첫 번째 바이트가 있는 값은 RFC 2434 사양 요구 사항을 통해 할당됩니다. 첫 번째 바이트가 255\(십진수\)인 값은 RFC 2434 개인용으로 예약되어 있습니다. 레지스트리는 처음에 이 문서 \[TLSAES\]의 섹션 A.5와 \[TLSKRB\]의 섹션 3의 값으로 채워집니다.

섹션 6은 모든 ContentType 값이 RFC 2434 Standards Action에 의해 정의되도록 요구합니다. IANA는 처음에 이 문서의 섹션 6.2.1 값으로 채워진 TLS ContentType 레지스트리를 생성했습니다. \[RFC2434\]에 설명된 대로 표준 작업을 통해 미래 값을 할당해야 합니다.\(MUST\)

섹션 7.2.2에서는 모든 경고 값이 RFC 2434 표준 조치에 의해 정의되도록 요구합니다. IANA는 처음에 이 문서의 섹션 7.2와 \[TLSEXT\]의 섹션 4의 값으로 채워진 TLS 경보 레지스트리를 생성했습니다. \[RFC2434\]에 설명된 대로 표준 작업을 통해 미래 값을 할당해야 합니다.\(MUST\)

섹션 7.4에서는 모든 HandshakeType 값이 RFC 2434 Standards Action에 의해 정의되도록 요구합니다. IANA는 처음에 이 문서의 섹션 7.4와 \[TLSEXT\]의 섹션 2.4의 값으로 채워진 TLS HandshakeType 레지스트리를 생성했습니다. \[RFC2434\]에 설명된 대로 표준 작업을 통해 미래 값을 할당해야 합니다.\(MUST\)

---
# **Appendix A. Protocol Constant Values**

이 섹션에서는 프로토콜 유형 및 상수에 대해 설명합니다.

---
### **A.1. Record Layer**

```text
   struct {
       uint8 major, minor;
   } ProtocolVersion;

   ProtocolVersion version = { 3, 2 };     /* TLS v1.1 */

   enum {
       change_cipher_spec(20), alert(21), handshake(22),
       application_data(23), (255)
   } ContentType;

   struct {
       ContentType type;
       ProtocolVersion version;
       uint16 length;
       opaque fragment[TLSPlaintext.length];
   } TLSPlaintext;

   struct {
       ContentType type;
       ProtocolVersion version;
       uint16 length;
       opaque fragment[TLSCompressed.length];
   } TLSCompressed;

   struct {
       ContentType type;
       ProtocolVersion version;
       uint16 length;
       select (CipherSpec.cipher_type) {
           case stream: GenericStreamCipher;
           case block:  GenericBlockCipher;
       } fragment;
   } TLSCiphertext;

   stream-ciphered struct {
       opaque content[TLSCompressed.length];
       opaque MAC[CipherSpec.hash_size];
   } GenericStreamCipher;

   block-ciphered struct {
       opaque IV[CipherSpec.block_length];

       opaque content[TLSCompressed.length];
       opaque MAC[CipherSpec.hash_size];
       uint8 padding[GenericBlockCipher.padding_length];
       uint8 padding_length;
   } GenericBlockCipher;
```

---
### **A.2. Change Cipher Specs Message**

```text
   struct {
       enum { change_cipher_spec(1), (255) } type;
   } ChangeCipherSpec;
```

---
### **A.3. Alert Messages**

```text
   enum { warning(1), fatal(2), (255) } AlertLevel;

       enum {
           close_notify(0),
           unexpected_message(10),
           bad_record_mac(20),
           decryption_failed(21),
           record_overflow(22),
           decompression_failure(30),
           handshake_failure(40),
           no_certificate_RESERVED (41),
           bad_certificate(42),
           unsupported_certificate(43),
           certificate_revoked(44),
           certificate_expired(45),
           certificate_unknown(46),
           illegal_parameter(47),
           unknown_ca(48),
           access_denied(49),
           decode_error(50),
           decrypt_error(51),
           export_restriction_RESERVED(60),
           protocol_version(70),
           insufficient_security(71),
           internal_error(80),
           user_canceled(90),
           no_renegotiation(100),
           (255)
       } AlertDescription;

   struct {
       AlertLevel level;
       AlertDescription description;
   } Alert;
```

---
### **A.4. Handshake Protocol**

```text
   enum {
       hello_request(0), client_hello(1), server_hello(2),
       certificate(11), server_key_exchange (12),
       certificate_request(13), server_hello_done(14),
       certificate_verify(15), client_key_exchange(16),
       finished(20), (255)
   } HandshakeType;

   struct {
       HandshakeType msg_type;
       uint24 length;
       select (HandshakeType) {
           case hello_request:       HelloRequest;
           case client_hello:        ClientHello;
           case server_hello:        ServerHello;
           case certificate:         Certificate;
           case server_key_exchange: ServerKeyExchange;
           case certificate_request: CertificateRequest;
           case server_hello_done:   ServerHelloDone;
           case certificate_verify:  CertificateVerify;
           case client_key_exchange: ClientKeyExchange;
           case finished:            Finished;
       } body;
   } Handshake;
```

---
#### **A.4.1. Hello messages**

```text
   struct { } HelloRequest;

   struct {
       uint32 gmt_unix_time;
       opaque random_bytes[28];
   } Random;

   opaque SessionID<0..32>;

   uint8 CipherSuite[2];

   enum { null(0), (255) } CompressionMethod;

   struct {
       ProtocolVersion client_version;
       Random random;
       SessionID session_id;
       CipherSuite cipher_suites<2..2^16-1>;
       CompressionMethod compression_methods<1..2^8-1>;

   } ClientHello;

   struct {
       ProtocolVersion server_version;
       Random random;
       SessionID session_id;
       CipherSuite cipher_suite;
       CompressionMethod compression_method;
   } ServerHello;
```

---
#### **A.4.2. Server Authentication and Key Exchange Messages**

```text
   opaque ASN.1Cert<2^24-1>;

   struct {
       ASN.1Cert certificate_list<0..2^24-1>;
   } Certificate;

   enum { rsa, diffie_hellman } KeyExchangeAlgorithm;

   struct {
       opaque rsa_modulus<1..2^16-1>;
       opaque rsa_exponent<1..2^16-1>;
   } ServerRSAParams;

   struct {
       opaque dh_p<1..2^16-1>;
       opaque dh_g<1..2^16-1>;
       opaque dh_Ys<1..2^16-1>;
   } ServerDHParams;

   struct {
       select (KeyExchangeAlgorithm) {
           case diffie_hellman:
               ServerDHParams params;
               Signature signed_params;
           case rsa:
               ServerRSAParams params;
               Signature signed_params;
       };
   } ServerKeyExchange;

   enum { anonymous, rsa, dsa } SignatureAlgorithm;

   struct {
       select (KeyExchangeAlgorithm) {
           case diffie_hellman:
               ServerDHParams params;

           case rsa:
               ServerRSAParams params;
       };
   } ServerParams;

   struct {
       select (SignatureAlgorithm) {
           case anonymous: struct { };
           case rsa:
               digitally-signed struct {
                   opaque md5_hash[16];
                   opaque sha_hash[20];
               };
           case dsa:
               digitally-signed struct {
                   opaque sha_hash[20];
               };
           };
       };
   } Signature;

   enum {
       rsa_sign(1), dss_sign(2), rsa_fixed_dh(3), dss_fixed_dh(4),
    rsa_ephemeral_dh_RESERVED(5), dss_ephemeral_dh_RESERVED(6),
    fortezza_dms_RESERVED(20),
    (255)
   } ClientCertificateType;

   opaque DistinguishedName<1..2^16-1>;

   struct {
       ClientCertificateType certificate_types<1..2^8-1>;
       DistinguishedName certificate_authorities<0..2^16-1>;
   } CertificateRequest;

   struct { } ServerHelloDone;
```

---
#### **A.4.3. Client Authentication and Key Exchange Messages**

```text
   struct {
       select (KeyExchangeAlgorithm) {
           case rsa: EncryptedPreMasterSecret;
           case diffie_hellman: ClientDiffieHellmanPublic;
       } exchange_keys;
   } ClientKeyExchange;

   struct {
       ProtocolVersion client_version;
       opaque random[46];
   }
   PreMasterSecret;

   struct {
       public-key-encrypted PreMasterSecret pre_master_secret;
   } EncryptedPreMasterSecret;

   enum { implicit, explicit } PublicValueEncoding;

   struct {
       select (PublicValueEncoding) {
           case implicit: struct {};
           case explicit: opaque DH_Yc<1..2^16-1>;
       } dh_public;
   } ClientDiffieHellmanPublic;

   struct {
       Signature signature;
   } CertificateVerify;
```

---
#### **A.4.4. Handshake Finalization Message**

```text
   struct {
       opaque verify_data[12];
   } Finished;
```

---
### **A.5. The CipherSuite**

다음 값은 클라이언트 hello 및 server hello 메시지에 사용되는 CipherSuite 코드를 정의합니다.

CipherSuite는 TLS 버전 1.1에서 지원되는 암호 사양을 정의합니다.

TLS\_NULL\_WITH\_NULL\_NULL이 지정되고 해당 채널에서 첫 번째 핸드셰이크 동안 TLS 연결의 초기 상태이지만 비보안 연결보다 더 많은 보호를 제공하지 않으므로 협상해서는 안 됩니다.

```text
    CipherSuite TLS_NULL_WITH_NULL_NULL                = { 0x00,0x00 };
```

다음 CipherSuite 정의에서는 서버가 키 교환에 사용할 수 있는 RSA 인증서를 제공해야 합니다. 서버는 인증서 요청 메시지에서 RSA 또는 DSS 서명 가능 인증서를 요청할 수 있습니다.

```text
    CipherSuite TLS_RSA_WITH_NULL_MD5                  = { 0x00,0x01 };
    CipherSuite TLS_RSA_WITH_NULL_SHA                  = { 0x00,0x02 };
    CipherSuite TLS_RSA_WITH_RC4_128_MD5               = { 0x00,0x04 };
    CipherSuite TLS_RSA_WITH_RC4_128_SHA               = { 0x00,0x05 };
    CipherSuite TLS_RSA_WITH_IDEA_CBC_SHA              = { 0x00,0x07 };
    CipherSuite TLS_RSA_WITH_DES_CBC_SHA               = { 0x00,0x09 };
    CipherSuite TLS_RSA_WITH_3DES_EDE_CBC_SHA          = { 0x00,0x0A };
```

다음 CipherSuite 정의는 서버 인증\(및 선택적으로 클라이언트 인증\) Diffie-Hellman에 사용됩니다. DH는 서버의 인증서에 인증 기관\(CA\)에서 서명한 Diffie-Hellman 매개변수가 포함된 암호화 제품군을 나타냅니다. DHE는 임시 Diffie-Hellman을 나타내며 Diffie-Hellman 매개변수는 CA에서 서명한 DSS 또는 RSA 인증서로 서명됩니다. 사용된 서명 알고리즘은 DH 또는 DHE 매개변수 뒤에 지정됩니다. 서버는 클라이언트 인증을 위해 클라이언트로부터 RSA 또는 DSS 서명 가능 인증서를 요청하거나 Diffie-Hellman 인증서를 요청할 수 있습니다. 클라이언트에서 제공하는 모든 Diffie-Hellman 인증서는 서버에서 설명하는 매개변수\(그룹 및 생성기\)를 사용해야 합니다.

```text
    CipherSuite TLS_DH_DSS_WITH_DES_CBC_SHA            = { 0x00,0x0C };
    CipherSuite TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA       = { 0x00,0x0D };
    CipherSuite TLS_DH_RSA_WITH_DES_CBC_SHA            = { 0x00,0x0F };
    CipherSuite TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA       = { 0x00,0x10 };
    CipherSuite TLS_DHE_DSS_WITH_DES_CBC_SHA           = { 0x00,0x12 };
    CipherSuite TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA      = { 0x00,0x13 };
    CipherSuite TLS_DHE_RSA_WITH_DES_CBC_SHA           = { 0x00,0x15 };
    CipherSuite TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA      = { 0x00,0x16 };
```

다음 암호 제품군은 어느 쪽도 인증되지 않은 완전히 익명의 Diffie-Hellman 통신에 사용됩니다. 이 모드는 중간자 공격에 취약하므로 더 이상 사용되지 않습니다.

```text
    CipherSuite TLS_DH_anon_WITH_RC4_128_MD5           = { 0x00,0x18 };
    CipherSuite TLS_DH_anon_WITH_DES_CBC_SHA           = { 0x00,0x1A };
    CipherSuite TLS_DH_anon_WITH_3DES_EDE_CBC_SHA      = { 0x00,0x1B };
```

SSLv3 및 TLS 1.0이 설계되었을 때 미국은 특정 강력한 암호화 알고리즘을 포함하는 암호화 소프트웨어의 수출을 제한했습니다. 이러한 규정을 준수하기 위해 일련의 암호화 제품군이 축소된 키 길이에서 작동하도록 설계되었습니다. 컴퓨터 성능의 발전으로 인해 이러한 알고리즘은 이제 용납할 수 없을 정도로 약해졌으며 이후 수출 제한이 완화되었습니다. TLS 1.1 구현은 TLS 1.1 모드에서 이러한 암호화 제품군을 협상하면 안 됩니다\(MUST NOT\). 그러나 이전 버전과의 호환성을 위해 TLS와 함께 사용하기 위해 ClientHello에서 제공될 수 있습니다.\(MUST NOT\)

1.0 또는 SSLv3 전용 서버. TLS 1.1 클라이언트는 서버가 핸드셰이크 중에 이러한 암호 제품군 중 하나를 선택하지 않았는지 확인해야 합니다. 이러한 암호화 모음은 정보 제공 및 번호 예약을 위해 아래에 나열되어 있습니다.\(MUST\)

```text
    CipherSuite TLS_RSA_EXPORT_WITH_RC4_40_MD5         = { 0x00,0x03 };
    CipherSuite TLS_RSA_EXPORT_WITH_RC2_CBC_40_MD5     = { 0x00,0x06 };
    CipherSuite TLS_RSA_EXPORT_WITH_DES40_CBC_SHA      = { 0x00,0x08 };
    CipherSuite TLS_DH_DSS_EXPORT_WITH_DES40_CBC_SHA   = { 0x00,0x0B };
    CipherSuite TLS_DH_RSA_EXPORT_WITH_DES40_CBC_SHA   = { 0x00,0x0E };
    CipherSuite TLS_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA  = { 0x00,0x11 };
    CipherSuite TLS_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA  = { 0x00,0x14 };
    CipherSuite TLS_DH_anon_EXPORT_WITH_RC4_40_MD5     = { 0x00,0x17 };
    CipherSuite TLS_DH_anon_EXPORT_WITH_DES40_CBC_SHA  = { 0x00,0x19 };
```

다음 암호 그룹은 \[TLSKRB\]에서 정의되었으며 완전성을 위해 여기에 포함되었습니다. 자세한 내용은 \[TLSKRB\]를 참조하십시오.

```text
    CipherSuite    TLS_KRB5_WITH_DES_CBC_SHA           = { 0x00,0x1E }:
    CipherSuite    TLS_KRB5_WITH_3DES_EDE_CBC_SHA      = { 0x00,0x1F };
    CipherSuite    TLS_KRB5_WITH_RC4_128_SHA           = { 0x00,0x20 };
    CipherSuite    TLS_KRB5_WITH_IDEA_CBC_SHA          = { 0x00,0x21 };
    CipherSuite    TLS_KRB5_WITH_DES_CBC_MD5           = { 0x00,0x22 };
    CipherSuite    TLS_KRB5_WITH_3DES_EDE_CBC_MD5      = { 0x00,0x23 };
    CipherSuite    TLS_KRB5_WITH_RC4_128_MD5           = { 0x00,0x24 };
    CipherSuite    TLS_KRB5_WITH_IDEA_CBC_MD5          = { 0x00,0x25 };
```

다음 내보낼 수 있는 암호 그룹은 \[TLSKRB\]에서 정의되었으며 완전성을 위해 여기에 포함되었습니다. TLS 1.1 구현은 이러한 암호화 제품군을 협상하면 안 됩니다\(MUST NOT\).\(MUST NOT\)

```text
    CipherSuite  TLS_KRB5_EXPORT_WITH_DES_CBC_40_SHA    = { 0x00,0x26};
    CipherSuite  TLS_KRB5_EXPORT_WITH_RC2_CBC_40_SHA    = { 0x00,0x27};
    CipherSuite  TLS_KRB5_EXPORT_WITH_RC4_40_SHA        = { 0x00,0x28};
    CipherSuite  TLS_KRB5_EXPORT_WITH_DES_CBC_40_MD5    = { 0x00,0x29};
    CipherSuite  TLS_KRB5_EXPORT_WITH_RC2_CBC_40_MD5    = { 0x00,0x2A};
    CipherSuite  TLS_KRB5_EXPORT_WITH_RC4_40_MD5        = { 0x00,0x2B};
```

다음 암호 그룹은 \[TLSAES\]에서 정의되었으며 완전성을 위해 여기에 포함되었습니다. 자세한 내용은 \[TLSAES\]를 참조하십시오.

```text
         CipherSuite TLS_RSA_WITH_AES_128_CBC_SHA      = { 0x00, 0x2F };
         CipherSuite TLS_DH_DSS_WITH_AES_128_CBC_SHA   = { 0x00, 0x30 };
         CipherSuite TLS_DH_RSA_WITH_AES_128_CBC_SHA   = { 0x00, 0x31 };
         CipherSuite TLS_DHE_DSS_WITH_AES_128_CBC_SHA  = { 0x00, 0x32 };
         CipherSuite TLS_DHE_RSA_WITH_AES_128_CBC_SHA  = { 0x00, 0x33 };
         CipherSuite TLS_DH_anon_WITH_AES_128_CBC_SHA  = { 0x00, 0x34 };

         CipherSuite TLS_RSA_WITH_AES_256_CBC_SHA      = { 0x00, 0x35 };
         CipherSuite TLS_DH_DSS_WITH_AES_256_CBC_SHA   = { 0x00, 0x36 };
         CipherSuite TLS_DH_RSA_WITH_AES_256_CBC_SHA   = { 0x00, 0x37 };
         CipherSuite TLS_DHE_DSS_WITH_AES_256_CBC_SHA  = { 0x00, 0x38 };
         CipherSuite TLS_DHE_RSA_WITH_AES_256_CBC_SHA  = { 0x00, 0x39 };
         CipherSuite TLS_DH_anon_WITH_AES_256_CBC_SHA  = { 0x00, 0x3A };
```

암호 스위트 공간은 세 영역으로 나뉩니다.

- 1. 첫 번째 바이트 0x00\(영\)부터 10진수 191\(0xBF\)까지의 암호 제품군 값은 IETF 표준 트랙 프로토콜용으로 예약되어 있습니다.

- 2. 첫 번째 바이트 10진수 192\(0xC0\)에서 10진수 254\(0xFE\)까지의 암호 그룹 값은 비표준 추적 방법에 대한 할당을 위해 예약되어 있습니다.

- 3. 첫 번째 바이트가 0xFF인 암호 그룹 값은 개인용으로 예약되어 있습니다.

암호 스위트 코드 포인트 할당에서 IANA의 역할을 설명하는 추가 정보는 섹션 11에 설명되어 있습니다.

참고: 암호 그룹 값 { 0x00, 0x1C } 및 { 0x00, 0x1D }는 SSL 3의 Fortezza 기반 암호 그룹과의 충돌을 피하기 위해 예약되어 있습니다.

---
### **A.6. The Security Parameters**

- 이러한 보안 매개변수는 TLS Handshake Protocol에 의해 결정되며 연결 상태를 초기화하기 위해 TLS Record Layer에 매개변수로 제공됩니다. SecurityParameters에는 다음이 포함됩니다.

```text
            enum { null(0), (255) } CompressionMethod;

            enum { server, client } ConnectionEnd;

            enum { null, rc4, rc2, des, 3des, des40, aes, idea }
            BulkCipherAlgorithm;

            enum { stream, block } CipherType;

            enum { null, md5, sha } MACAlgorithm;

         /* The algorithms specified in CompressionMethod,
         BulkCipherAlgorithm, and MACAlgorithm may be added to. */

            struct {
                ConnectionEnd entity;
                BulkCipherAlgorithm bulk_cipher_algorithm;
                CipherType cipher_type;
                uint8 key_size;
                uint8 key_material_length;
                MACAlgorithm mac_algorithm;
                uint8 hash_size;
                CompressionMethod compression_algorithm;
                opaque master_secret[48];
                opaque client_random[32];
                opaque server_random[32];
            } SecurityParameters;
```

---
# **Appendix B. Glossary**

고급 암호화 표준\(AES\)

- AES는 널리 사용되는 대칭 암호화 알고리즘입니다. AES는 128, 192 또는 256비트 키와 16바이트 블록 크기를 가진 블록 암호입니다. \[AES\] TLS는 현재 128비트 및 256비트 키 크기만 지원합니다.

애플리케이션 프로토콜

- 애플리케이션 프로토콜은 일반적으로 전송 계층\(예: TCP/IP\) 바로 위에 직접 계층화되는 프로토콜입니다. HTTP, TELNET, FTP 및 SMTP를 예로 들 수 있습니다.

```text
   asymmetric cipher
      See public key cryptography.
```

입증

- 인증은 한 엔터티가 다른 엔터티의 신원을 확인할 수 있는 기능입니다.

블록 암호

- 블록 암호는 블록이라고 하는 비트 그룹의 일반 텍스트에서 작동하는 알고리즘입니다. 64비트는 일반적인 블록 크기입니다.

대량 암호

- 대량의 데이터를 암호화하는 데 사용되는 대칭 암호화 알고리즘입니다.

암호 블록 체인\(CBC\)

- CBC는 블록 암호로 암호화된 모든 평문 블록이 먼저 이전 암호문 블록\(또는 첫 번째 블록의 경우 초기화 벡터\)과 배타적 논리합을 하는 모드입니다. 복호화의 경우 모든 블록이 먼저 복호화된 다음 이전 암호문 블록\(또는 IV\)과 배타적 OR됩니다.

자격증

- X.509 프로토콜\(일명 ISO 인증 프레임워크\)의 일부인 인증서는 신뢰할 수 있는 인증 기관에서 할당하고 당사자의 신원 또는 기타 속성과 해당 공개 키 사이에 강력한 바인딩을 제공합니다.

고객

- 서버에 대한 TLS 연결을 시작하는 애플리케이션 엔터티입니다. 이는 클라이언트가 기본 전송 연결을 시작했음을 의미할 수도 있고 의미하지 않을 수도 있습니다. 서버와 클라이언트의 주요 작동 차이점은 서버는 일반적으로 인증되는 반면 클라이언트는 선택적으로만 인증된다는 것입니다.

클라이언트 쓰기 키

- 클라이언트가 작성한 데이터를 암호화하는 데 사용되는 키입니다.

클라이언트 쓰기 MAC 비밀

- 클라이언트가 작성한 데이터를 인증하는 데 사용되는 비밀 데이터.

연결

- 연결은 적합한 유형의 서비스를 제공하는 전송\(OSI 계층화 모델 정의에서\)입니다. TLS의 경우 이러한 연결은 피어 투 피어 관계입니다. 연결은 일시적입니다. 모든 연결은 하나의 세션과 연결됩니다.

데이터 암호화 표준

- DES는 매우 널리 사용되는 대칭 암호화 알고리즘입니다. DES는 56비트 키와 8바이트 블록 크기를 가진 블록 암호입니다. TLS에서 키 생성을 위해 DES는 8바이트 키 길이\(64비트\)를 갖는 것으로 취급되지만 여전히 56비트 보호만 제공합니다. \(각 키 바이트의 하위 비트는 해당 키 바이트에서 홀수 패리티를 생성하도록 설정되는 것으로 추정됩니다.\) DES는 각 데이터 블록에 대해 3개의 독립 키와 3개의 암호화가 사용되는 모드에서도 작동할 수 있습니다. 이는 168비트의 키\(TLS 키 생성 방법의 경우 24바이트\)를 사용하며 112비트의 보안에 해당합니다. \[DES\], \[3DES\]

디지털 서명 표준\(DSS\)

- 미국 상무부가 1994년 5월에 발표한 NIST FIPS PUB 186, "디지털 서명 표준"에 정의된 NIST\(National Institute of Standards and Technology\)에서 승인한 디지털 서명 알고리즘을 포함한 디지털 서명 표준입니다. \[DSS\]

디지털 서명

- 디지털 서명은 공개키 암호화와 단방향 해시함수를 활용하여 인증이 가능하고 위조나 부인이 어려운 데이터의 서명을 생성합니다.

악수

- 트랜잭션 매개변수를 설정하는 클라이언트와 서버 간의 초기 협상.

초기화 벡터\(IV\)

- CBC 모드에서 블록 암호를 사용하는 경우 초기화 벡터는 암호화 전에 첫 번째 평문 블록과 배타적 논리합을 합니다.

아이디어

- Xuejia Lai와 James Massey가 설계한 64비트 블록 암호입니다. \[아이디어\]

메시지 인증 코드\(MAC\)

- 메시지 인증 코드는 메시지와 일부 비밀 데이터에서 계산된 단방향 해시입니다. 비밀 데이터를 모르면 위조하기 어렵다. 그 목적은 메시지가 변경되었는지 감지하는 것입니다.

마스터 시크릿

- 암호화 키, MAC 비밀 및 IV 생성에 사용되는 보안 비밀 데이터.

MD5

- MD5는 임의의 긴 데이터 스트림을 고정 크기\(16바이트\)의 다이제스트로 변환하는 보안 해싱 기능입니다. \[MD5\]

공개 키 암호화

- 두 개의 키 암호를 사용하는 암호화 기술 클래스입니다. 공개 키로 암호화된 메시지는 연결된 개인 키로만 해독할 수 있습니다. 반대로 개인 키로 서명된 메시지는 공개 키로 확인할 수 있습니다.

단방향 해시 함수

- 임의의 양의 데이터를 고정 길이 해시로 변환하는 단방향 변환입니다. 변환을 되돌리거나 충돌을 찾는 것은 계산적으로 어렵습니다. MD5 및 SHA는 단방향 해시 함수의 예입니다.

RC2

- \[RC2\]에 설명된 RSA Data Security, Inc. \[RSADSI\]의 Ron Rivest가 개발한 블록 암호.

RC4

- Ron Rivest가 발명한 스트림 암호. 호환 암호는 \[SCH\]에 설명되어 있습니다.

RSA

- 매우 널리 사용되는 공개 키 알고리즘으로 암호화 또는 디지털 서명에 사용할 수 있습니다. \[RSA\]

섬기는 사람

- 서버는 클라이언트의 연결 요청에 응답하는 응용 프로그램 엔터티입니다. 클라이언트 아래도 참조하십시오.

세션

- TLS 세션은 클라이언트와 서버 간의 연결입니다. 세션은 핸드셰이크 프로토콜에 의해 생성됩니다. 세션은 여러 연결 간에 공유할 수 있는 암호화 보안 매개변수 세트를 정의합니다. 세션은 각 연결에 대한 새로운 보안 매개변수의 값비싼 협상을 피하기 위해 사용됩니다.

세션 식별자

- 세션 식별자는 특정 세션을 식별하기 위해 서버에서 생성되는 값입니다.

서버 쓰기 키

- 서버에서 작성한 데이터를 암호화하는 데 사용되는 키입니다.

서버 쓰기 MAC 비밀

- 서버에서 작성한 데이터를 인증하는 데 사용되는 비밀 데이터입니다.

샤

- 보안 해시 알고리즘은 FIPS PUB 180-2에 정의되어 있습니다. 20바이트 출력을 생성합니다. SHA에 대한 모든 참조는 실제로 수정된 SHA-1 알고리즘을 사용합니다. \[샤\]

SSL

- Netscape의 보안 소켓 계층 프로토콜\[SSL3\]. TLS는 SSL 버전 3.0을 기반으로 합니다.

스트림 암호

- 키를 암호학적으로 강력한 키스트림으로 변환한 다음 일반 텍스트와 배타적 OR로 변환하는 암호화 알고리즘입니다.

```text
   symmetric cipher
      See bulk cipher.
```

TLS\(전송 계층 보안\)

- 이 프로토콜; 또한 IETF\(Internet Engineering Task Force\)의 전송 계층 보안 작업 그룹입니다. 이 문서 끝에 있는 "설명"을 참조하십시오.

---
# **Appendix C. CipherSuite Definitions**
---
# **CipherSuite                           Key Exchange   Cipher      Hash**

```text
TLS_NULL_WITH_NULL_NULL               NULL           NULL        NULL
TLS_RSA_WITH_NULL_MD5                 RSA            NULL         MD5
TLS_RSA_WITH_NULL_SHA                 RSA            NULL         SHA
TLS_RSA_WITH_RC4_128_MD5              RSA            RC4_128      MD5
TLS_RSA_WITH_RC4_128_SHA              RSA            RC4_128      SHA
TLS_RSA_WITH_IDEA_CBC_SHA             RSA            IDEA_CBC     SHA
TLS_RSA_WITH_DES_CBC_SHA              RSA            DES_CBC      SHA
TLS_RSA_WITH_3DES_EDE_CBC_SHA         RSA            3DES_EDE_CBC SHA
TLS_DH_DSS_WITH_DES_CBC_SHA           DH_DSS         DES_CBC      SHA
TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA      DH_DSS         3DES_EDE_CBC SHA
TLS_DH_RSA_WITH_DES_CBC_SHA           DH_RSA         DES_CBC      SHA
TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA      DH_RSA         3DES_EDE_CBC SHA
TLS_DHE_DSS_WITH_DES_CBC_SHA          DHE_DSS        DES_CBC      SHA
TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA     DHE_DSS        3DES_EDE_CBC SHA
TLS_DHE_RSA_WITH_DES_CBC_SHA          DHE_RSA        DES_CBC      SHA
TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA     DHE_RSA        3DES_EDE_CBC SHA
TLS_DH_anon_WITH_RC4_128_MD5          DH_anon        RC4_128      MD5
TLS_DH_anon_WITH_DES_CBC_SHA          DH_anon        DES_CBC      SHA
TLS_DH_anon_WITH_3DES_EDE_CBC_SHA     DH_anon        3DES_EDE_CBC SHA

      Key
      Exchange
      Algorithm     Description                        Key size limit

      DHE_DSS       Ephemeral DH with DSS signatures   None
      DHE_RSA       Ephemeral DH with RSA signatures   None
      DH_anon       Anonymous DH, no signatures        None
      DH_DSS        DH with DSS-based certificates     None
      DH_RSA        DH with RSA-based certificates     None
                                                       RSA = none
      NULL          No key exchange                    N/A
      RSA           RSA key exchange                   None

                         Key      Expanded     IV    Block
    Cipher       Type  Material Key Material   Size   Size

    NULL         Stream   0          0         0     N/A
    IDEA_CBC     Block   16         16         8      8
    RC2_CBC_40   Block    5         16         8      8
    RC4_40       Stream   5         16         0     N/A
    RC4_128      Stream  16         16         0     N/A
    DES40_CBC    Block    5          8         8      8
    DES_CBC      Block    8          8         8      8
    3DES_EDE_CBC Block   24         24         8      8
```

유형

- CBC 모드에서 실행되는 스트림 암호인지 또는 블록 암호인지 나타냅니다.

주요 자료

- 쓰기 키를 생성하는 데 사용되는 key\_block의 바이트 수입니다.

확장된 키 자료

- 실제로 암호화 알고리즘에 입력된 바이트 수입니다.

IV 크기

- 초기화 벡터에 대해 생성해야 하는 데이터의 양. 스트림 암호의 경우 0입니다. 블록 암호의 블록 크기와 동일합니다.

블록 크기

- 블록 암호가 한 청크에 암호화하는 데이터의 양 CBC 모드에서 실행되는 블록 암호는 블록 크기의 짝수 배수만 암호화할 수 있습니다.

```text
         Hash      Hash      Padding
       function    Size       Size
         NULL       0          0
         MD5        16         48
         SHA        20         40
```

---
# **Appendix D. Implementation Notes**

TLS 프로토콜은 많은 일반적인 보안 실수를 방지할 수 없습니다. 이 섹션에서는 구현자를 지원하기 위한 몇 가지 권장 사항을 제공합니다.

---
### **D.1. Random Number Generation and Seeding**

TLS에는 암호화된 보안 의사 난수 생성기\(PRNG\)가 필요합니다. PRNG를 설계하고 시드할 때 주의를 기울여야 합니다. 보안 해시 작업, 특히 MD5 및/또는 SHA를 기반으로 하는 PRNG는 허용되지만 난수 생성기 상태의 크기보다 더 많은 보안을 제공할 수 없습니다. \(예를 들어, MD5 기반 PRNG는 일반적으로 128비트의 상태를 제공합니다.\)

생산되는 시드 물질의 양을 추정하려면 각 시드 바이트에 예측할 수 없는 정보의 비트 수를 추가하십시오. 예를 들어, 카운터 값의 총 크기가 16비트 이상인 경우에도 PC 호환 18.2Hz 타이머에서 가져온 키 입력 타이밍 값은 각각 1 또는 2개의 보안 비트를 제공합니다. 따라서 128비트 PRNG를 시딩하려면 이러한 타이머 값이 약 100개 필요합니다.

\[RANDOM\]은 임의 값 생성에 대한 지침을 제공합니다.

---
## **D.2 Certificates and Authentication**

구현은 인증서의 무결성을 확인할 책임이 있으며 일반적으로 인증서 해지 메시지를 지원해야 합니다. 신뢰할 수 있는 인증 기관\(CA\)의 적절한 서명을 보장하기 위해 인증서를 항상 확인해야 합니다. 신뢰할 수 있는 CA의 선택 및 추가는 매우 신중하게 수행해야 합니다. 사용자는 인증서 및 루트 CA에 대한 정보를 볼 수 있어야 합니다.

---
## **D.3 CipherSuites**

TLS는 보안을 전혀 제공하지 않거나 최소한으로 제공하는 일부를 포함하여 다양한 키 크기 및 보안 수준을 지원합니다. 적절한 구현은 아마도 많은 암호 제품군을 지원하지 않을 것입니다. 예를 들어 40비트 암호화는 쉽게 깨지므로 강력한 보안이 필요한 구현에서는 40비트 키를 허용하지 않아야 합니다. 마찬가지로 익명의 Diffie-Hellman은 중간자 공격을 방지할 수 없기 때문에 사용하지 않는 것이 좋습니다. 애플리케이션은 또한 최소 및 최대 키 크기를 적용해야 합니다. 예를 들어 512비트 RSA 키 또는 서명이 포함된 인증서 체인은 보안 수준이 높은 애플리케이션에 적합하지 않습니다.

---
# **Appendix E. Backward Compatibility with SSL**

역사적 이유와 예약된 포트 번호의 과도한 소비를 방지하기 위해 TLS 1.1, TLS 1.0, SSL 3.0 및 SSL 2.0으로 보호되는 애플리케이션 프로토콜은 모두 동일한 연결 포트를 자주 공유합니다. 예를 들어 https 프로토콜\(SSL 또는 TLS로 보호되는 HTTP\)은 사용 중인 보안 프로토콜에 관계없이 포트 443을 사용합니다. 따라서 다양한 프로토콜을 구별하고 협상하기 위해 어떤 메커니즘을 결정해야 합니다.

TLS 버전 1.1 및 1.0과 SSL 3.0은 매우 유사합니다. 따라서 둘 다 지원하기 쉽습니다. 이러한 이전 서버와 협상하려는 TLS 클라이언트는 SSL 3.0 레코드 형식과 클라이언트 안녕하세요 구조를 사용하여 클라이언트 안녕하세요 메시지를 보내야 합니다\(SHOULD\). 버전 필드에 대해 {3, 2}를 보내 TLS 1.1을 지원한다는 점을 알려야 합니다. 서버가 TLS 1.0 또는 SSL 3.0만 지원하는 경우 downrev 3.0 server hello로 응답합니다. TLS 1.1을 지원하는 경우 TLS 1.1 서버 hello로 응답합니다. 그런 다음 협상은 협상된 프로토콜에 따라 적절하게 진행됩니다.\(SHOULD\)

마찬가지로 TLS 1.0 또는 SSL 3.0 클라이언트와 상호 운용하려는 TLS 1.1 서버는 버전 필드가 {3, 0}인 SSL 3.0 클라이언트 hello가 수신되면 SSL 3.0 클라이언트 hello 메시지를 수락하고 SSL 3.0 server hello로 응답해야 합니다\(SHOULD\). , 이 클라이언트가 TLS를 지원하지 않음을 나타냅니다. 마찬가지로 버전 필드가 {3, 1}인 SSL 3.0 또는 TLS 1.0 hello가 수신되면 서버는 버전 필드가 {3, 1}인 TLS 1.0 hello로 응답해야 합니다\(SHOULD\).\(SHOULD, SHOULD\)

클라이언트가 이미 서버에 알려진 가장 높은 프로토콜을 알고 있을 때마다\(예: 세션을 재개할 때\) 해당 기본 프로토콜에서 연결을 시작해야 합니다.\(SHOULD\)

SSL 버전 2.0 서버를 지원하는 TLS 1.1 클라이언트는 반드시 SSL 버전 2.0 클라이언트 헬로 메시지\[SSL2\]를 보내야 합니다. TLS 서버는 동일한 연결 포트에서 SSL 2.0 클라이언트를 지원하려는 경우 클라이언트 hello 형식을 수락해야 합니다\(SHOULD\). 버전 2.0 사양의 유일한 차이점은 값이 3인 버전을 지정하는 기능과 CipherSpec에서 더 많은 암호화 유형에 대한 지원입니다.\(MUST, SHOULD\)

경고: 버전 2.0 클라이언트 Hello 메시지를 보내는 기능은 서둘러 단계적으로 중단됩니다. 구현자는 가능한 한 빨리 진행하기 위해 모든 노력을 기울여야 합니다. 버전 3.0은 최신 버전으로 이동하기 위한 더 나은 메커니즘을 제공합니다.\(SHOULD\)

- 다음 암호 사양은 SSL 버전 2.0에서 이월됩니다. 이들은 키 교환 및 인증에 RSA를 사용하는 것으로 가정합니다.

```text
        V2CipherSpec TLS_RC4_128_WITH_MD5          = { 0x01,0x00,0x80 };
        V2CipherSpec TLS_RC4_128_EXPORT40_WITH_MD5 = { 0x02,0x00,0x80 };
        V2CipherSpec TLS_RC2_CBC_128_CBC_WITH_MD5  = { 0x03,0x00,0x80 };
        V2CipherSpec TLS_RC2_CBC_128_CBC_EXPORT40_WITH_MD5
                                                   = { 0x04,0x00,0x80 };
        V2CipherSpec TLS_IDEA_128_CBC_WITH_MD5     = { 0x05,0x00,0x80 };
        V2CipherSpec TLS_DES_64_CBC_WITH_MD5       = { 0x06,0x00,0x40 };
        V2CipherSpec TLS_DES_192_EDE3_CBC_WITH_MD5 = { 0x07,0x00,0xC0 };
```

- TLS 고유의 암호 사양은 아래 구문을 사용하여 버전 2.0 클라이언트 Hello 메시지에 포함될 수 있습니다. 첫 번째 바이트가 0인 V2CipherSpec 요소는 버전 2.0 서버에서 무시됩니다. 위의 V2CipherSpecs 중 하나를 보내는 클라이언트는 TLS도 포함해야 합니다\(부록 A.5 참조\).\(SHOULD\)

```text
        V2CipherSpec (see TLS name) = { 0x00, CipherSuite };
```

참고: TLS 1.1 클라이언트는 이전 버전과의 호환성을 위해 핸드셰이크에서 SSLv2 EXPORT 암호화 제품군을 생성할 수 있지만 TLS 1.1 모드에서 협상해서는 안 됩니다\(MUST NOT\).\(MUST NOT\)

---
### **E.1. Version 2 Client Hello**

버전 2.0 클라이언트 hello 메시지는 이 문서의 표시 모델을 사용하여 아래에 표시됩니다. 진정한 정의는 여전히 SSL 버전 2.0 사양으로 간주됩니다. 이 메시지는 SSLv3 레코드로 래핑되지 않고 유선으로 직접 전송되어야 합니다.\(MUST\)

```text
     uint8 V2CipherSpec[3];

     struct {
         uint16 msg_length;
         uint8 msg_type;
         Version version;
         uint16 cipher_spec_length;
         uint16 session_id_length;
         uint16 challenge_length;
         V2CipherSpec cipher_specs[V2ClientHello.cipher_spec_length];
         opaque session_id[V2ClientHello.session_id_length];
         opaque challenge[V2ClientHello.challenge_length;
     } V2ClientHello;
```

msg\_length

- 이 필드는 다음 데이터의 길이\(바이트\)입니다. 상위 비트는 1이어야 하며 길이의 일부가 아닙니다.\(MUST\)

msg\_type

- 이 필드는 version 필드와 함께 버전 2 클라이언트 hello 메시지를 식별합니다. 값은 일\(1\)이어야 합니다.\(SHOULD\)

버전

- 클라이언트가 지원하는 프로토콜의 가장 높은 버전\(ProtocolVersion.version과 같음, 부록 A.1 참조\).

cipher\_spec\_length

- 이 필드는 cipher\_specs 필드의 총 길이입니다. 0일 수 없으며 V2CipherSpec 길이\(3\)의 배수여야 합니다.\(MUST\)

session\_id\_length

- 이 필드는 값이 0이어야 합니다.\(MUST\)

도전\_길이

- 자신을 인증하기 위해 서버에 대한 클라이언트의 요청 길이\(바이트\)입니다. SSLv2 이전 버전과 호환되는 핸드셰이크를 사용할 때 클라이언트는 32바이트 챌린지를 사용해야 합니다.\(MUST\)

cipher\_specs

- 이것은 클라이언트가 사용할 의향이 있고 사용할 수 있는 모든 CipherSpec의 목록입니다. 서버에 허용되는 최소 하나의 CipherSpec이 있어야 합니다.\(MUST\)

session\_id

- 이 필드는 비어 있어야 합니다.\(MUST\)

챌린지 서버가 자신을 식별하기 위해 서버에 대한 클라이언트 챌린지는 \(거의\) 임의 길이 임의입니다. TLS 서버는 이 프로토콜 사양에 지정된 대로 ClientHello.random 데이터\(필요한 경우 선행 0으로 채워짐\)가 되도록 챌린지 데이터를 올바르게 정당화합니다. 챌린지 길이가 32바이트보다 크면 마지막 32바이트만 사용됩니다. V3 서버가 챌린지 데이터가 16바이트 미만인 V2 ClientHello를 거부하는 것은 합법적이지만 필수는 아닙니다.

- 참고: TLS 세션 재개 요청은 TLS 클라이언트 hello를 사용해야 합니다.\(MUST\)

---
### **E.2. Avoiding Man-in-the-Middle Version Rollback**

TLS 클라이언트가 버전 2.0 호환성 모드로 돌아가는 경우 특수 PKCS #1 블록 형식을 사용해야 합니다\(SHOULD\). 이는 TLS 서버가 TLS 가능 클라이언트와의 버전 2.0 세션을 거부하도록 수행됩니다.\(SHOULD\)

TLS 클라이언트가 버전 2.0 호환 모드에 있을 때 TLS 클라이언트는 ENCRYPTED-KEY-DATA 필드의 RSA 암호화를 위해 PKCS 패딩의 오른쪽\(최하위\) 8 임의 바이트\(패딩의 터미널 null 제외\)를 설정합니다. CLIENT-MASTER-KEY를 0x03으로 설정합니다\(다른 패딩 바이트는 무작위임\). ENCRYPTED-KEY-DATA 필드를 해독한 후 TLS를 지원하는 서버는 이 8개의 패딩 바이트가 0x03인 경우 오류를 발행해야 합니다. 이렇게 채워진 블록을 수신하는 버전 2.0 서버는 정상적으로 진행됩니다.\(SHOULD\)

---
# **Appendix F. Security Analysis**

TLS 프로토콜은 비보안 채널을 통해 통신하는 클라이언트와 서버 간에 보안 연결을 설정하도록 설계되었습니다. 이 문서는 공격자가 상당한 계산 리소스를 가지고 있고 프로토콜 외부 소스에서 비밀 정보를 얻을 수 없다는 것을 포함하여 몇 가지 전통적인 가정을 합니다. 공격자는 통신 채널을 통해 전송된 메시지를 캡처, 수정, 삭제, 재생 및 변조할 수 있는 능력이 있다고 가정합니다. 이 부록에서는 다양한 공격에 저항하도록 TLS가 어떻게 설계되었는지 설명합니다.

---
### **F.1. Handshake Protocol**

핸드셰이크 프로토콜은 보안 세션과 관련된 기본 암호화 매개변수를 함께 구성하는 CipherSpec 선택 및 마스터 비밀 생성을 담당합니다. 핸드셰이크 프로토콜은 신뢰할 수 있는 인증 기관에서 서명한 인증서가 있는 당사자를 선택적으로 인증할 수도 있습니다.

---
#### **F.1.1. Authentication and Key Exchange**

TLS는 양 당사자 인증, 인증되지 않은 클라이언트를 사용한 서버 인증, 전체 익명성의 세 가지 인증 모드를 지원합니다. 서버가 인증될 때마다 채널은 중간자 공격으로부터 안전하지만 완전히 익명인 세션은 본질적으로 이러한 공격에 취약합니다. 익명 서버는 클라이언트를 인증할 수 없습니다. 서버가 인증되면 해당 인증서 메시지는 허용 가능한 인증 기관으로 이어지는 유효한 인증서 체인을 제공해야 합니다. 마찬가지로 인증된 클라이언트는 허용 가능한 인증서를

섬기는 사람. 각 당사자는 상대방의 인증서가 유효하고 만료되거나 취소되지 않았는지 확인할 책임이 있습니다.

키 교환 프로세스의 일반적인 목표는 공격자가 아닌 통신 당사자에게 알려진 pre\_master\_secret을 만드는 것입니다. pre\_master\_secret은 master\_secret을 생성하는 데 사용됩니다\(섹션 8.1 참조\). 완성된 메시지, 암호화 키 및 MAC 비밀을 생성하려면 master\_secret이 필요합니다\(섹션 7.4.8, 7.4.9 및 6.3 참조\). 올바른 완료 메시지를 보내면 당사자는 올바른 pre\_master\_secret을 알고 있음을 증명합니다.

---
##### **F.1.1.1. Anonymous Key Exchange**

키 교환을 위해 RSA 또는 Diffie-Hellman을 사용하여 완전한 익명 세션을 설정할 수 있습니다. 익명 RSA를 사용하면 클라이언트는 서버 키 교환 메시지에서 추출한 서버의 인증되지 않은 공개 키로 pre\_master\_secret을 암호화합니다. 결과는 클라이언트 키 교환 메시지로 전송됩니다. 도청자는 서버의 개인 키를 모르기 때문에 pre\_master\_secret을 해독하는 것은 불가능합니다.

참고: 이 문서에는 익명 RSA 암호 제품군이 정의되어 있지 않습니다.

Diffie-Hellman을 사용하면 서버의 공개 매개변수는 서버 키 교환 메시지에 포함되고 클라이언트의 공개 매개변수는 클라이언트 키 교환 메시지에 전송됩니다. 개인 값을 모르는 도청자는 Diffie-Hellman 결과\(즉, pre\_master\_secret\)를 찾을 수 없어야 합니다.

경고: 완전 익명 연결은 수동적 도청에 대한 보호만 제공합니다. 완성된 메시지가 공격자에 의해 대체되지 않았는지 확인하기 위해 독립적인 변조 방지 채널을 사용하지 않는 한 적극적인 중간자 공격이 우려되는 환경에서는 서버 인증이 필요합니다.

---
##### **F.1.1.2. RSA Key Exchange and Authentication**

RSA를 사용하면 키 교환과 서버 인증이 결합됩니다. 공개 키는 서버의 인증서에 포함되어 있거나 서버 키 교환 메시지로 전송된 임시 RSA 키일 수 있습니다. 임시 RSA 키가 사용되면 서버의 RSA 인증서로 서명됩니다. 서명에는 현재 ClientHello.random이 포함되어 있으므로 이전 서명과 임시 키를 재생할 수 없습니다. 서버는 여러 협상 세션에 단일 임시 RSA 키를 사용할 수 있습니다.

참고: 임시 RSA 키 옵션은 서버에 대량의 RSA 키가 필요한 경우에 유용합니다.

- 인증서이지만 키 교환에 사용되는 키에 대해 정부가 부과한 크기 제한을 준수해야 합니다.

임시 RSA를 사용하지 않는 경우 서버의 정적 RSA 키가 손상되면 해당 정적 키로 보호되는 모든 세션의 기밀성이 손실됩니다. Perfect Forward Secrecy를 원하는 TLS 사용자는 DHE 암호화 제품군을 사용해야 합니다. 개인 키 노출로 인한 피해는 개인 키\(및 인증서\)를 자주 변경하여 제한할 수 있습니다.

서버의 인증서를 확인한 후 클라이언트는 서버의 공개 키로 pre\_master\_secret을 암호화합니다. pre\_master\_secret을 성공적으로 디코딩하고 올바르게 완료된 메시지를 생성함으로써 서버는 서버 인증서에 해당하는 개인 키를 알고 있음을 보여줍니다.

RSA가 키 교환에 사용될 때 클라이언트는 인증서 확인 메시지를 사용하여 인증됩니다\(섹션 7.4.8 참조\). 클라이언트는 master\_secret 및 이전의 모든 핸드셰이크 메시지에서 파생된 값에 서명합니다. 이러한 핸드셰이크 메시지에는 서명을 서버에 바인딩하는 서버 인증서와 서명을 현재 핸드셰이크 프로세스에 바인딩하는 ServerHello.random이 포함됩니다.

---
##### **F.1.1.3. Diffie-Hellman Key Exchange with Authentication**

Diffie-Hellman 키 교환이 사용되는 경우 서버는 고정 Diffie-Hellman 매개변수가 포함된 인증서를 제공하거나 서버 키 교환 메시지를 사용하여 DSS 또는 RSA 인증서로 서명된 임시 Diffie-Hellman 매개변수 집합을 보낼 수 있습니다. 임시 매개변수는 공격자가 이전 매개변수를 재생하지 않도록 하기 위해 서명하기 전에 hello.random 값으로 해시됩니다. 두 경우 모두 클라이언트는 매개변수가 서버에 속하는지 확인하기 위해 인증서 또는 서명을 확인할 수 있습니다.

클라이언트에 고정된 Diffie-Hellman 매개변수가 포함된 인증서가 있는 경우 해당 인증서에는 키 교환을 완료하는 데 필요한 정보가 포함되어 있습니다. 이 경우 클라이언트와 서버는 통신할 때마다 동일한 Diffie-Hellman 결과\(예: pre\_master\_secret\)를 생성합니다. pre\_master\_secret이 필요 이상으로 메모리에 머무르는 것을 방지하려면 가능한 한 빨리 master\_secret으로 변환해야 합니다. 클라이언트 Diffie-Hellman 매개변수는 키 교환이 작동하려면 서버에서 제공하는 매개변수와 호환되어야 합니다.

클라이언트에 표준 DSS 또는 RSA 인증서가 있거나 인증되지 않은 경우 클라이언트 키 교환 메시지에서 서버에 임시 매개 변수 집합을 보낸 다음 선택적으로 인증서 확인 메시지를 사용하여 자신을 인증합니다.

클라이언트 또는 서버에 고정 DH 키 쌍이 포함된 인증서가 있거나 서버가 DH 키를 재사용하기 때문에 동일한 DH 키 쌍이 여러 핸드셰이크에 사용되는 경우 소규모 하위 그룹 공격을 방지하기 위해 주의를 기울여야 합니다. 구현은 \[SUBGROUP\]에 있는 지침을 따라야 합니다\(SHOULD\).\(SHOULD\)

작은 하위 그룹 공격은 DHE 암호 세트 중 하나를 사용하고 각 핸드셰이크에 대해 새로운 DH 개인 키\(X\)를 생성하여 가장 쉽게 피할 수 있습니다. 적절한 기준\(예: 2\)을 선택하면 g^X mod p를 매우 빠르게 계산할 수 있으므로 성능 비용이 최소화됩니다. 또한 각 핸드셰이크에 대해 새로운 키를 사용하여 Perfect Forward Secrecy를 제공합니다. 구현은 DHE 암호 그룹을 사용할 때 각 핸드셰이크에 대해 새 X를 생성해야 합니다\(SHOULD\).\(SHOULD\)

---
#### **F.1.2. Version Rollback Attacks**

TLS에는 SSL 버전 2.0에 비해 상당한 개선 사항이 포함되어 있으므로 공격자는 TLS 지원 클라이언트 및 서버를 버전 2.0으로 대체하려고 시도할 수 있습니다. 이 공격은 두 TLS 가능 당사자가 SSL 2.0 핸드셰이크를 사용하는 경우에만 발생할 수 있습니다.

비무작위 PKCS #1 블록 유형 2 메시지 패딩을 사용하는 솔루션은 정교하지 않지만 버전 3.0 서버가 공격을 감지할 수 있는 상당히 안전한 방법을 제공합니다. 이 솔루션은 응용 프로그램에서 지정한 대기 임계값이 만료되기 전에 키를 무차별 대입하고 동일한 키를 포함하는 새 ENCRYPTED-KEY-DATA 메시지로 대체할 수 있는 공격자에 대해 안전하지 않습니다. 이 규모의 공격을 우려하는 당사자는 40비트 암호화 키를 사용해서는 안 됩니다. PKCS 패딩의 최하위 8바이트 패딩을 변경해도 프로토콜에서 사용되는 서명된 해시 및 RSA 키 길이의 보안에 영향을 주지 않습니다. 이는 본질적으로 입력 블록 크기를 8바이트 늘리는 것과 동일하기 때문입니다.

---
#### **F.1.3. Detecting Attacks against the Handshake Protocol**

공격자는 당사자가 일반적으로 선택하는 것과 다른 암호화 알고리즘을 선택하도록 핸드셰이크 교환에 영향을 주려고 할 수 있습니다.

이 공격의 경우 공격자는 하나 이상의 핸드셰이크 메시지를 능동적으로 변경해야 합니다. 이 경우 클라이언트와 서버는 핸드셰이크 메시지 해시에 대해 서로 다른 값을 계산합니다. 결과적으로 당사자들은 서로의 완료된 메시지를 수락하지 않습니다. master\_secret이 없으면 공격자는 완료된 메시지를 복구할 수 없으므로 공격이 발견됩니다.

---
#### **F.1.4. Resuming Sessions**

세션을 재개하여 연결이 설정되면 새로운 ClientHello.random 및 ServerHello.random 값이 세션의 master\_secret으로 해시됩니다. master\_secret이 손상되지 않았고 암호화 키와 MAC 비밀을 생성하는 데 사용되는 보안 해시 작업이 안전하다면 연결은 안전해야 하며 이전 연결과 효과적으로 독립적이어야 합니다. 공격자는 알려진 암호화 키 또는 MAC 암호를 사용하여 보안 해시 작업\(SHA 및 MD5 모두 사용\)을 중단하지 않고 master\_secret을 손상시킬 수 없습니다.

클라이언트와 서버가 모두 동의하지 않으면 세션을 재개할 수 없습니다. 어느 쪽이든 세션이 손상되었거나 인증서가 만료 또는 해지되었다고 의심하는 경우 전체 핸드셰이크를 강제로 수행해야 합니다. master\_secret을 얻은 공격자는 해당 세션 ID가 만료될 때까지 손상된 당사자를 가장할 수 있으므로 세션 ID 수명에 대해 24시간의 상한이 제안됩니다. 상대적으로 안전하지 않은 환경에서 실행될 수 있는 애플리케이션은 세션 ID를 안정적인 저장소에 쓰지 않아야 합니다.

---
#### **F.1.5. MD5 and SHA**

TLS는 매우 보수적으로 해시 함수를 사용합니다. 가능한 경우 MD5와 SHA를 함께 사용하여 하나의 알고리즘에 치명적인 결함이 있어도 전체 프로토콜이 손상되지 않도록 합니다.

---
### **F.2. Protecting Application Data**

master\_secret은 ClientHello.random 및 ServerHello.random으로 해시되어 각 연결에 대해 고유한 데이터 암호화 키 및 MAC 비밀을 생성합니다.

나가는 데이터는 전송 전에 MAC으로 보호됩니다. 메시지 재생 또는 수정 공격을 방지하기 위해 MAC은 MAC 암호, 시퀀스 번호, 메시지 길이, 메시지 내용 및 두 개의 고정 문자열에서 계산됩니다. 메시지 유형 필드는 하나의 TLS 레코드 레이어 클라이언트를 위한 메시지가 다른 클라이언트로 리디렉션되지 않도록 하는 데 필요합니다. 시퀀스 번호는 메시지를 삭제하거나 재정렬하려는 시도가 감지되도록 합니다. 시퀀스 번호는 64비트 길이이므로 절대 오버플로되어서는 안 됩니다. 한 당사자의 메시지는 독립적인 MAC 비밀을 사용하기 때문에 상대방의 출력에 삽입될 수 없습니다. 마찬가지로 서버 쓰기 및 클라이언트 쓰기 키는 독립적이므로 스트림 암호 키는 한 번만 사용됩니다.

공격자가 암호화 키를 해독하면 암호화된 모든 메시지를 읽을 수 있습니다. 마찬가지로 MAC 키가 손상되면 메시지 수정 공격이 가능해질 수 있습니다. MAC도 암호화되기 때문에 메시지 변경 공격은 일반적으로 MAC뿐만 아니라 암호화 알고리즘도 깨뜨려야 합니다.

참고: MAC 암호는 암호화 키보다 클 수 있으므로 암호화 키가 손상되더라도 메시지가 변조되지 않도록 유지될 수 있습니다.

---
### **F.3. Explicit IVs**

\[CBCATT\]는 레코드의 IV를 아는 것에 의존하는 TLS에 대한 선택된 일반 텍스트 공격을 설명합니다. 이전 버전의 TLS\[TLS1.0\]는 이전 레코드의 CBC 잔류물을 IV로 사용했기 때문에 이 공격을 활성화했습니다. 이 버전은 이 공격으로부터 보호하기 위해 명시적 IV를 사용합니다.

---
### **F.4. Security of Composite Cipher Modes**

TLS는 협상된 암호 그룹에 정의된 대칭 암호화 및 인증 기능을 사용하여 전송된 애플리케이션 데이터를 보호합니다. 목표는 네트워크에서 능동적인 공격자의 악의적인 행동으로부터 전송된 데이터의 무결성과 기밀성을 모두 보호하는 것입니다. 암호화 및 인증 기능이 데이터에 적용되는 순서가 이 목표\[ENCAUTH\]를 달성하는 데 중요한 역할을 하는 것으로 나타났습니다.

encrypt-then-authenticate라고 하는 가장 강력한 방법은 먼저 데이터에 암호화를 적용한 다음 암호문에 MAC을 적용합니다. 이 방법은 전자가 선택된 일반 텍스트 공격에 대해 안전하고 MAC이 선택된 메시지 공격에 대해 안전하다면 모든 암호화 및 MAC 기능 쌍으로 무결성 및 기밀성 목표를 달성하도록 보장합니다. TLS는 인증 후 암호화라는 또 다른 방법을 사용합니다. 이 방법에서는 먼저 일반 텍스트에서 MAC을 계산한 다음 일반 텍스트와 MAC의 연결을 암호화합니다. 이 방법은 암호화 기능과 MAC 기능의 특정 조합에 대해 보안이 입증되었지만 일반적으로 보안이 보장되지는 않습니다. 특히, 능동적 공격에 대한 기밀성 목표를 제공하지 못하는 보안 MAC 기능과 결합된 완벽하게 안전한 암호화 기능\(정보 이론적 의미에서도 안전함\)이 존재하는 것으로 나타났습니다. 따라서 TLS에 채택된 새로운 암호화 방식과 작동 모드는 인증 후 암호화 방식으로 분석하여 명시된 무결성 및 기밀성 목표를 달성했는지 확인해야 합니다.

현재 인증 후 암호화 방법의 보안은 몇 가지 중요한 경우에 대해 입증되었습니다. 하나는 메시지 길이와 MAC 태그 길이의 계산상 예측할 수 없는 패드가 의사 난수 생성기를 사용하여 생성되고 이 패드가 일반 텍스트와 MAC의 연결로 xor-ed되는 스트림 암호의 경우입니다. 꼬리표. 다른 하나는 보안 블록 암호를 사용하는 CBC 모드의 경우입니다. 이 경우 일반 텍스트와 MAC의 연결에 하나의 CBC 암호화 패스를 적용하고 각각의 새로운 일반 텍스트와 MAC 쌍에 대해 새롭고 독립적이며 예측할 수 없는 IV를 사용하면 보안이 표시될 수 있습니다. 이전 버전의 SSL에서는 이전 암호문의 마지막 블록 형태로 예측 가능한 IV를 사용한 것을 제외하고는 CBC 모드가 제대로 사용되었습니다. 이로 인해 TLS는 선택된 일반 텍스트 공격에 개방되었습니다. 이 버전의 프로토콜은 이러한 공격에 영향을 받지 않습니다. 보안이 입증된 암호화 모드에 대한 정확한 세부 정보는 \[ENCAUTH\]를 참조하십시오.

---
### **F.5. Denial of Service**

TLS는 여러 서비스 거부\(DoS\) 공격에 취약합니다. 특히 많은 수의 TCP 연결을 시작하는 공격자는 서버가 RSA 암호 해독을 수행하는 데 많은 양의 CPU를 소비하도록 할 수 있습니다. 그러나 TLS는 일반적으로 TCP를 통해 사용되기 때문에 TCP 스택에서 적절한 TCP SYN 무작위화가 \[SEQNUM\] 사용되는 경우 공격자가 자신의 원점을 숨기기 어렵습니다.

TLS는 TCP를 통해 실행되기 때문에 개별 연결에 대한 수많은 서비스 거부 공격에도 취약합니다. 특히 공격자는 RST를 위조하여 연결을 종료하거나 부분 TLS 레코드를 위조하여 연결을 중단시킬 수 있습니다. 이러한 공격은 일반적으로 TCP 사용 프로토콜로 방어할 수 없습니다. 이 공격 클래스와 관련된 구현자 또는 사용자는 IPsec AH\[AH-ESP\] 또는 ESP\[AH-ESP\]를 사용해야 합니다.

---
### **F.6. Final Notes**

TLS가 보안 연결을 제공할 수 있으려면 클라이언트 및 서버 시스템, 키 및 응용 프로그램이 모두 안전해야 합니다. 또한 구현에 보안 오류가 없어야 합니다.

이 시스템은 지원되는 가장 약한 키 교환 및 인증 알고리즘만큼만 강력하며 신뢰할 수 있는 암호화 기능만 사용해야 합니다. 짧은 공개 키, 40비트 대량 암호화 키 및 익명 서버는 매우 주의해서 사용해야 합니다. 구현 및 사용자는 어떤 인증서 및 인증 기관이 허용되는지 결정할 때 주의해야 합니다. 부정직한 인증 기관은 엄청난 피해를 입힐 수 있습니다.

---
# **Normative References**

\[AES\] 국립표준기술원,

- "고급 암호화 표준\(AES\) 사양" FIPS 197. 2001년 11월 26일.

\[3DES\] W. Tuchman, "Hellman은 DES에 대한 지름길 솔루션을 제공하지 않습니다." IEEE Spectrum, v. 16, n. 1979년 7월 7일, 40-41쪽.

\[DES\] ANSI X3.106, "정보 시스템에 대한 미국 국가 표준 - 데이터 링크 암호화", 미국 표준 협회, 1983.

\[DSS\] NIST FIPS PUB 186-2, "디지털 서명 표준", 미국 상무부 국립 표준 기술 연구소, 2000.

\[HMAC\] Krawczyk, H., Bellare, M. 및 R. Canetti, "HMAC: 메시지 인증을 위한 키 입력-해싱", RFC 2104, 1997년 2월.

\[IDEA\] X. Lai, "On the Design and Security of Block Ciphers," ETH Series in Information Processing, v. 1, Konstanz: Hartung-Gorre Verlag, 1992.

```text
   [MD5]      Rivest, R., "The MD5 Message-Digest Algorithm ", RFC 1321,
              April 1992.

   [PKCS1A]   B. Kaliski, "Public-Key Cryptography Standards (PKCS) #1:
              RSA Cryptography Specifications Version 1.5", RFC 2313,
              March 1998.

   [PKCS1B]   J. Jonsson, B. Kaliski, "Public-Key Cryptography Standards
              (PKCS) #1: RSA Cryptography Specifications Version 2.1",
              RFC 3447, February 2003.
```

\[PKIX\] Housley, R., Polk, W., Ford, W. 및 D. Solo, "Internet X.509 공개 키 인프라 인증서 및 CRL\(Certificate Revocation List\) 프로필", RFC 3280, 2002년 4월.

\[RC2\] Rivest, R., "RC2\(r\) 암호화 알고리즘에 대한 설명", RFC 2268, 1998년 3월.

\[SCH\] B. 슈나이어. "Applied Cryptography: Protocols, Algorithms, and Source Code in C, 2ed", John Wiley & Sons, Inc. 발행 1996.

\[SHA\] NIST FIPS PUB 180-2, "Secure Hash Standard", 미국 상무부 국립 표준 기술 연구소, 2001년 8월.

\[요청\] Bradner, S., "요구 수준을 나타내기 위해 RFC에서 사용할 핵심 단어", BCP 14, RFC 2119, 1997년 3월.

\[RFC2434\] Narten, T. 및 H. Alvestrand, "RFC에서 IANA 고려 사항 섹션 작성 지침", BCP 26, RFC 2434, 1998년 10월.

\[TLSAES\] Chown, P., "고급 암호화 표준\(AES\)

- TLS\(Transport Layer Security\)를 위한 Ciphersuites", RFC 3268, 2002년 6월.

\[TLSEXT\] Blake-Wilson, S., Nystrom, M., Hopwood, D., Mikkelsen, J. 및 T. Wright, "TLS\(전송 계층 보안\) 확장", RFC 3546, 2003년 6월.

\[TLSKRB\] Medvinsky, A. 및 M. Hur, "TLS\(전송 계층 보안\)에 Kerberos 암호 제품군 추가", RFC 2712, 1999년 10월.

---
# **Informative References**

```text
   [AH-ESP]   Kent, S., "IP Authentication Header", RFC 4302, December
              2005.
```

- Eastlake 3rd, D., "보안 페이로드\(ESP\) 및 인증 헤더\(AH\) 캡슐화를 위한 암호화 알고리즘 구현 요구 사항", RFC 4305, 2005년 12월.

\[BLEI\] Bleichenbacher D., Advances in Cryptology -- CRYPTO'98, LNCS vol. 1462, 페이지: 1-12, 1998.

\[CBCATT\] Moeller, B., "SSL/TLS에서 CBC Ciphersuites의 보안: 문제 및 대책", http://www.openssl.org/\~bodo/tls-cbc.txt.

\[CBCTIME\] Canvel, B., "SSL/TLS 채널의 암호 가로채기", http://lasecwww.epfl.ch/memo\_ssl.shtml, 2003.

\[ENCAUTH\] Krawczyk, H., "통신 보호를 위한 암호화 및 인증 순서\(또는: SSL은 얼마나 안전한가?\)", Crypto 2001.

\[KPR03\] Klima, V., Pokorny, O., Rosa, T., "SSL/TLS에서 RSA 기반 세션 공격", http://eprint.iacr.org/2003/052/, 2003년 3월.

```text
   [PKCS6]    RSA Laboratories, "PKCS #6: RSA Extended Certificate
              Syntax Standard," version 1.5, November 1993.

   [PKCS7]    RSA Laboratories, "PKCS #7: RSA Cryptographic Message
              Syntax Standard," version 1.5, November 1993.
```

\[무작위\] Eastlake, D., 3rd, Schiller, J. 및 S. Crocker,

- "보안을 위한 임의성 요구 사항", BCP 106, RFC 4086, 2005년 6월.

\[RSA\] R. Rivest, A. Shamir 및 L. M. Adleman, "디지털 서명 및 공개 키 암호화 시스템 획득 방법", Communications of the ACM, v. 21, n. 1978년 2월 2일, 120-126면.

\[서열\] Bellovin, S., "시퀀스 번호 공격 방어", RFC 1948, 1996년 5월.

```text
   [SSL2]     Hickman, Kipp, "The SSL Protocol", Netscape Communications
              Corp., Feb 9, 1995.
```

\[SSL3\] A. Frier, P. Karlton 및 P. Kocher, "SSL 3.0

- 프로토콜", Netscape Communications Corp., 1996년 11월 18일.

\[SUBGROUP\] Zuccherato, R., "S/MIME에 대한 Diffie-Hellman 키 계약 방법에 대한 "소형 하위 그룹" 공격을 방지하기 위한 방법", RFC 2785, 2000년 3월.

\[TCP\] Hellstrom, G. 및 P. Jones, "텍스트용 RTP 페이로드

- 대화", RFC 4103, 2005년 6월.

\[타이밍\] Boneh, D., Brumley, D., "원격 타이밍 공격은 실용적입니다", USENIX 보안 심포지엄 2003.

\[TLS1.0\] Dierks, T. 및 C. Allen, "TLS 프로토콜 버전 1.0", RFC 2246, 1999년 1월.

\[X501\] ITU-T 권고 X.501: 정보 기술 - 개방형 시스템 상호 연결 - 디렉토리: 모델, 1993.

```text
   [X509]     ITU-T Recommendation X.509 (1997 E): Information
              Technology - Open Systems Interconnection - "The Directory
              - Authentication Framework". 1988.

   [XDR]      Srinivasan, R., "XDR: External Data Representation
              Standard", RFC 1832, August 1995.
```

---
# **Authors' Addresses**

```text
   Working Group Chairs

   Win Treese

   EMail: treese@acm.org

   Eric Rescorla

   EMail: ekr@rtfm.com
```

---
# **Editors**

```text
   Tim Dierks
   Independent

   EMail: tim@dierks.org

   Eric Rescorla
   RTFM, Inc.

   EMail: ekr@rtfm.com
```

---
# **Other Contributors**

Christopher Allen\(TLS 1.0의 공동 편집자\) Alacrity Ventures 이메일: ChristopherA@AlacrityManagement.com

Martin Abadi University of California, Santa Cruz 이메일: abadi@cs.ucsc.edu

```text
   Ran Canetti
   IBM
   EMail: canetti@watson.ibm.com

   Taher Elgamal
   Securify
   EMail: taher@securify.com

   Anil Gangolli
   EMail: anil@busybuddha.org

   Kipp Hickman

   Phil Karlton (co-author of SSLv3)
```

Paul Kocher\(SSLv3 공동 저자\) 암호화 연구 이메일: paul@cryptography.com

Hugo Krawczyk Technion Israel Institute of Technology 이메일: hugo@ee.technion.ac.il

```text
   Robert Relyea
   Netscape Communications
   EMail: relyea@netscape.com

   Jim Roskind
   Netscape Communications
   EMail: jar@netscape.com

   Michael Sabin

   Dan Simon
   Microsoft, Inc.
   EMail: dansimon@microsoft.com

   Tom Weinstein
```

---
# **Comments**

```text
   The discussion list for the IETF TLS working group is located at the
   e-mail address <ietf-tls@lists.consensus.com>. Information on the
   group and information on how to subscribe to the list is at
   <http://lists.consensus.com/>.
```

목록의 아카이브는 다음에서 찾을 수 있습니다.

- <http://www.imc.org/ietf-tls/mail-archive/\>

---
# **Full Copyright Statement**

Copyright \(C\) The Internet Society \(2006\).

이 문서는 BCP 78에 포함된 권리, 라이선스 및 제한 사항의 적용을 받으며 여기에 명시된 경우를 제외하고 작성자는 모든 권리를 보유합니다.

이 문서 및 여기에 포함된 정보는 "있는 그대로" 제공되며 기여자, 기여자가 대표하거나 후원하는 조직\(있는 경우\), 인터넷 사회 및 인터넷 공학 태스크포스는 모든 명시적 또는 묵시적 보증을 부인합니다. 여기에서 구성은 상품성 또는 특정 목적에의 적합성에 대한 권리 또는 묵시적 보증을 침해하지 않습니다.

---
# **Intellectual Property**

IETF는 이 문서에 설명된 기술의 구현 또는 사용과 관련이 있다고 주장할 수 있는 지적 재산권 또는 기타 권리의 유효성 또는 범위 또는 그러한 권리에 따른 라이센스의 범위에 대해 어떠한 입장도 취하지 않습니다. 는 가능하다; 또한 그러한 권리를 식별하기 위해 독립적인 노력을 기울였다는 것을 나타내지 않습니다. RFC 문서의 권리와 관련된 절차에 대한 정보는 BCP 78 및 BCP 79에서 찾을 수 있습니다.

IETF 사무국에 제출된 IPR 공개 사본 및 사용 가능한 라이선스에 대한 보증 또는 이 사양의 구현자 또는 사용자가 이러한 독점권 사용에 대한 일반 라이선스 또는 허가를 얻으려는 시도의 결과를 얻을 수 있습니다. http://www.ietf.org/ipr의 IETF 온라인 IPR 저장소에서.

IETF는 이 표준을 구현하는 데 필요할 수 있는 기술을 포함할 수 있는 저작권, 특허 또는 특허 출원 또는 기타 소유권에 관심을 갖도록 이해 당사자를 초대합니다. 정보를 IETF\(ietf-ipr@ietf.org\)로 보내주십시오.

---
# **Acknowledgement**

RFC 편집기 기능에 대한 자금은 IETF 행정 지원 활동\(IASA\)에서 제공합니다.
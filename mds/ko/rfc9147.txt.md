

```text
﻿

Internet Engineering Task Force (IETF)                       E. Rescorla
Request for Comments: 9147                                       Mozilla
Obsoletes: 6347                                            H. Tschofenig
Category: Standards Track                                    Arm Limited
ISSN: 2070-1721                                              N. Modadugu
                                                            Google, Inc.
                                                              April 2022
```

DTLS\(Datagram Transport Layer Security\) 프로토콜 버전 1.3

---
# **Abstract**

이 문서는 DTLS\(Datagram Transport Layer Security\) 프로토콜 버전 1.3을 지정합니다. DTLS 1.3을 사용하면 도청, 변조 및 메시지 위조를 방지하도록 설계된 방식으로 클라이언트/서버 응용 프로그램이 인터넷을 통해 통신할 수 있습니다.

DTLS 1.3 프로토콜은 TLS\(Transport Layer Security\) 1.3 프로토콜을 기반으로 하며 주문 보호/재생 불가를 제외하고 동등한 보안 보장을 제공합니다. 기본 전송의 데이터그램 의미 체계는 DTLS 프로토콜에 의해 보존됩니다.

이 문서는 RFC 6347을 폐기합니다.

---
# **Status of This Memo**

이것은 인터넷 표준 추적 문서입니다.

이 문서는 IETF\(Internet Engineering Task Force\)의 제품입니다. 이는 IETF 커뮤니티의 합의를 나타냅니다. 공개 검토를 받았으며 IESG\(Internet Engineering Steering Group\)의 출판 승인을 받았습니다. 인터넷 표준에 대한 자세한 내용은 RFC 7841의 섹션 2에서 확인할 수 있습니다.

이 문서의 현재 상태, 정오표 및 피드백 제공 방법에 대한 정보는 https://www.rfc-editor.org/info/rfc9147에서 얻을 수 있습니다.

---
# **Copyright Notice**

Copyright \(c\) 2022 IETF Trust 및 문서 작성자로 확인된 사람. 판권 소유.

이 문서는 이 문서의 발행일에 유효한 BCP 78 및 IETF 문서에 관한 IETF 트러스트의 법적 조항\(https://trustee.ietf.org/license-info\)의 적용을 받습니다. 이 문서와 관련된 귀하의 권리 및 제한 사항을 설명하므로 이 문서를 주의 깊게 검토하십시오. 이 문서에서 추출한 코드 구성요소는 Trust Legal Provisions의 섹션 4.e에 설명된 대로 개정된 BSD 라이센스 텍스트를 포함해야 하며 개정된 BSD 라이센스에 설명된 대로 보증 없이 제공됩니다.

이 문서에는 2008년 11월 10일 이전에 공개되거나 공개된 IETF 문서 또는 IETF 기고문의 자료가 포함될 수 있습니다. 이 자료의 일부에 대한 저작권을 제어하는 ​​사람은 해당 자료의 수정을 허용할 권리를 IETF 트러스트에 부여하지 않았을 수 있습니다. IETF 표준 프로세스 외부. 이러한 자료의 저작권을 관리하는 사람으로부터 적절한 라이센스를 얻지 않고 이 문서는 IETF 표준 프로세스 외부에서 수정할 수 없으며 IETF 표준 프로세스 외부에서 이 문서의 파생물을 생성할 수 없습니다. RFC로 게시하거나 영어 이외의 언어로 번역합니다.

---
# **Table of Contents**

```text
   1.  Introduction
   2.  Conventions and Terminology
   3.  DTLS Design Rationale and Overview
     3.1.  Packet Loss
     3.2.  Reordering
     3.3.  Fragmentation
     3.4.  Replay Detection
   4.  The DTLS Record Layer
     4.1.  Demultiplexing DTLS Records
     4.2.  Sequence Number and Epoch
       4.2.1.  Processing Guidelines
       4.2.2.  Reconstructing the Sequence Number and Epoch
       4.2.3.  Record Number Encryption
     4.3.  Transport Layer Mapping
     4.4.  PMTU Issues
     4.5.  Record Payload Protection
       4.5.1.  Anti-Replay
       4.5.2.  Handling Invalid Records
       4.5.3.  AEAD Limits
   5.  The DTLS Handshake Protocol
     5.1.  Denial-of-Service Countermeasures
     5.2.  DTLS Handshake Message Format
     5.3.  ClientHello Message
     5.4.  ServerHello Message
     5.5.  Handshake Message Fragmentation and Reassembly
     5.6.  EndOfEarlyData Message
     5.7.  DTLS Handshake Flights
     5.8.  Timeout and Retransmission
       5.8.1.  State Machine
       5.8.2.  Timer Values
       5.8.3.  Large Flight Sizes
       5.8.4.  State Machine Duplication for Post-Handshake Messages
     5.9.  Cryptographic Label Prefix
     5.10. Alert Messages
     5.11. Establishing New Associations with Existing Parameters
   6.  Example of Handshake with Timeout and Retransmission
     6.1.  Epoch Values and Rekeying
   7.  ACK Message
     7.1.  Sending ACKs
     7.2.  Receiving ACKs
     7.3.  Design Rationale
   8.  Key Updates
   9.  Connection ID Updates
     9.1.  Connection ID Example
   10. Application Data Protocol
   11. Security Considerations
   12. Changes since DTLS 1.2
   13. Updates Affecting DTLS 1.2
   14. IANA Considerations
   15. References
     15.1.  Normative References
     15.2.  Informative References
   Appendix A.  Protocol Data Structures and Constant Values
     A.1.  Record Layer
     A.2.  Handshake Protocol
     A.3.  ACKs
     A.4.  Connection ID Management
   Appendix B.  Analysis of Limits on CCM Usage
     B.1.  Confidentiality Limits
     B.2.  Integrity Limits
     B.3.  Limits for AEAD_AES_128_CCM_8
   Appendix C.  Implementation Pitfalls
   Contributors
   Authors' Addresses
```

---
## **1.  Introduction**

TLS 프로토콜의 주요 목표는 통신하는 두 피어 간에 인증, 기밀성 및 무결성 보호 채널을 설정하는 것입니다. TLS 프로토콜은 TLS 레코드 프로토콜과 TLS 핸드셰이크 프로토콜의 두 계층으로 구성됩니다. 그러나 TLS는 신뢰할 수 있는 전송 채널\(일반적으로 TCP\[RFC0793\]\)을 통해 실행되어야 합니다.

UDP\[RFC0768\]를 전송으로 사용하는 애플리케이션이 있으며 이러한 애플리케이션에 대한 통신 보안 보호를 제공하기 위해 DTLS\(Datagram Transport Layer Security\) 프로토콜이 개발되었습니다. DTLS는 새로운 보안 발명을 최소화하고 코드 및 인프라 재사용의 양을 최대화하기 위해 가능한 한 TLS와 유사하도록 의도적으로 설계되었습니다.

DTLS 1.0\[RFC4347\]은 원래 TLS 1.1\[RFC4346\]의 델타로 정의되었고 DTLS 1.2\[RFC6347\]는 TLS 1.2\[RFC5246\]에 대한 일련의 델타로 정의되었습니다. DTLS 1.1이 없습니다. 버전 번호를 TLS와 일치시키기 위해 해당 버전 번호를 건너뛰었습니다. 이 사양에서는 DTLS 프로토콜의 최신 버전을 TLS 1.3\[TLS13\]의 델타로 설명합니다. DTLS 1.2를 폐기합니다.

DTLS 1.2와 DTLS 1.3을 모두 말하는 구현은 TLS 1.3 구현이 TLS 1.2와 상호 운용할 수 있는 것처럼 DTLS 1.2만 말하는 구현과 상호 운용할 수 있습니다\(물론 DTLS 1.2 사용\)\(자세한 내용은 \[TLS13\]의 부록 D 참조\). DTLS 1.0과의 역호환이 가능하지만 \[RFC7525\]의 섹션 3.1.2에 설명된 대로 DTLS 1.0의 사용은 권장되지 않습니다. \[DEPRECATE\]는 DTLS 1.0의 사용을 금지합니다.

---
## **2.  Conventions and Terminology**

키워드 "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY" 및 "OPTIONAL" "는 BCP 14 \[RFC2119\] \[RFC8174\]에 설명된 대로 여기에 표시된 것처럼 모두 대문자로 표시되는 경우에만 해석됩니다.\(MUST NOT\)

다음 용어가 사용됩니다.

클라이언트: DTLS 연결을 시작하는 끝점입니다.

연관: DTLS 핸드셰이크로 설정된 두 끝점 간의 공유 상태입니다.

연결: 연결의 동의어입니다.

끝점: 연결의 클라이언트 또는 서버입니다.

epoch: 암호화 및 복호화에 사용되는 암호화 키 세트.

핸드셰이크: 연결 매개변수를 설정하는 클라이언트와 서버 간의 초기 협상입니다.

피어: 끝점입니다. 특정 엔드포인트를 논의할 때 "피어"는 논의의 기본 주제에 대해 원격인 엔드포인트를 나타냅니다.

수신자: 레코드를 수신하는 끝점입니다.

보낸 사람: 레코드를 전송하는 끝점입니다.

서버: DTLS 연결을 시작하지 않은 끝점입니다.

```text
   CID:  Connection ID.

   MSL:  Maximum Segment Lifetime.
```

독자는 \[TLS13\]에 익숙하다고 가정합니다. TLS 1.3에서와 같이 HelloRetryRequest는 ServerHello 메시지와 동일한 형식을 갖지만 편의상 이 문서 전체에서 마치 별개의 메시지인 것처럼 HelloRetryRequest라는 용어를 사용합니다.

DTLS 1.3은 \[TLS13\] 및 이전 \(D\)TLS 사양에 정의된 인코딩 형식을 기반으로 메시지를 인코딩하기 위해 네트워크 바이트 순서\(big-endian\) 형식을 사용합니다.

또한 이 문서는 DTLS 1.3에 CID 기능을 적용하므로 독자는 \[RFC9146\]에 익숙하다고 가정합니다.

이 문서의 그림은 DTLS 프로토콜 교환의 다양한 조합을 나타내며 기호는 다음과 같은 의미를 갖습니다.

'+'는 이전에 언급된 메시지에서 보낸 주목할만한 확장자를 나타냅니다.

'\*'는 선택 사항이거나 상황에 따라 달라지는 메시지/확장자가 항상 전송되지는 않음을 나타냅니다.

'{}'는 다음에서 파생된 키를 사용하여 보호되는 메시지를 나타냅니다.

- \[발신자\]\_handshake\_traffic\_secret.

'\[\]'는 다음에서 파생된 키를 사용하여 보호되는 메시지를 나타냅니다.

- 트래픽\_비밀\_N.

---
## **3.  DTLS Design Rationale and Overview**

DTLS의 기본 설계 철학은 "TLS over datagram transport"를 구성하는 것입니다. 데이터그램 전송은 안정적이거나 순서대로 데이터를 전달할 필요도 제공하지도 않습니다. DTLS 프로토콜은 응용 프로그램 데이터에 대해 이 속성을 유지합니다. 미디어 스트리밍, 인터넷 전화 통신 및 온라인 게임과 같은 응용 프로그램은 전송된 데이터의 지연에 민감한 특성으로 인해 통신을 위해 데이터그램 전송을 사용합니다. DTLS 프로토콜이 손실되거나 재정렬된 데이터 트래픽을 보상하지 않기 때문에 DTLS 프로토콜이 보안 통신에 사용될 때 이러한 애플리케이션의 동작은 변경되지 않습니다. 대기 시간이 짧은 스트리밍 및 게임에서는 DTLS를 사용하여 데이터를 보호하지만\(예: WebRTC 데이터 채널 보호를 위해\) 전화 ​​통신에서는 키 설정을 위해 DTLS를 사용하고 데이터 보호를 위해 SRTP\(Secure Real-time Transport Protocol\)를 사용합니다\[RFC5763\]. .

TLS는 다음 네 가지 이유로 데이터그램 전송을 통해 직접 사용할 수 없습니다.

1. TLS는 레코드의 암시적 시퀀스 번호에 의존합니다. 레코드를 받지 못한 경우 수신자는 후속 레코드에서 레코드 보호를 제거하려고 시도할 때 잘못된 시퀀스 번호를 사용하게 됩니다. DTLS는 레코드에 시퀀스 번호를 추가하여 이 문제를 해결합니다.

2. TLS 핸드셰이크는 잠금 단계 암호화 프로토콜입니다.

- 메시지는 정의된 순서에 따라 전송 및 수신되어야 합니다. 다른 주문은 오류입니다. DTLS 핸드셰이크에는 데이터그램이 손실되거나 재정렬된 경우 조각화된 메시지 재조립 및 순서대로 전달을 가능하게 하는 메시지 시퀀스 번호가 포함되어 있습니다.

3. 핸드셰이크 메시지는 잠재적으로 단일 데이터그램에 포함될 수 있는 것보다 큽니다. DTLS는 조각화 및 재조립을 지원하기 위해 핸드셰이크 메시지에 필드를 추가합니다.

4. 데이터그램 전송 프로토콜은 비참여자에 대한 서비스 거부\(DoS\) 공격에 영향을 미치는 남용 행위에 취약합니다. DTLS는 반환 라우팅 가능성 검사를 추가하고 DTLS 1.3은 TLS 1.3 HelloRetryRequest 메시지를 사용합니다\(자세한 내용은 섹션 5.1 참조\).

---
### **3.1.  Packet Loss**

DTLS는 간단한 재전송 타이머를 사용하여 패킷 손실을 처리합니다. 그림 1은 DTLS 핸드셰이크의 첫 번째 단계를 사용하여 기본 개념을 보여줍니다.

```text
            Client                                   Server
            ------                                   ------
            ClientHello           ------>

                                    X<-- HelloRetryRequest
                                                     (lost)

            [Timer Expires]

            ClientHello           ------>
            (retransmit)

                   Figure 1: DTLS Retransmission Example
```

클라이언트가 ClientHello 메시지를 전송하면 서버에서 HelloRetryRequest 또는 ServerHello를 볼 것으로 예상합니다. 그러나 타이머가 만료되면 클라이언트는 ClientHello 또는 서버의 응답이 손실되었음을 알게 되며 이로 인해 클라이언트는 ClientHello를 다시 전송하게 됩니다. 서버가 재전송을 수신하면 HelloRetryRequest 또는 ServerHello를 재전송해야 함을 알게 됩니다.

또한 서버는 보내는 메시지\(HelloRetryRequest 제외\)에 대한 재전송 타이머를 유지하고 해당 타이머가 만료되면 재전송합니다. HelloRetryRequest에 재전송을 적용하지 않으면 서버에서 상태를 생성할 필요가 없습니다. HelloRetryRequest는 충분히 작게 설계되어 자체적으로 조각화되지 않으므로 여러 HelloRetryRequest의 인터리빙에 대한 우려를 피할 수 있습니다.

시간 초과 및 재전송에 대한 자세한 내용은 섹션 5.8을 참조하십시오.

---
### **3.2.  Reordering**

DTLS에서 각 핸드셰이크 메시지에는 특정 시퀀스 번호가 할당됩니다. 피어가 핸드셰이크 메시지를 받으면 해당 메시지가 예상하는 다음 메시지인지 빠르게 확인할 수 있습니다. 그렇다면 처리합니다. 그렇지 않은 경우 이전 메시지를 모두 수신한 후 향후 처리를 위해 큐에 넣습니다.

---
### **3.3.  Fragmentation**

TLS 및 DTLS 핸드셰이크 메시지는 상당히 클 수 있습니다\(이론적으로 최대 2^24-1바이트, 실제로는 수 킬로바이트\). 대조적으로 UDP 데이터그램은 IP 단편화가 바람직하지 않은 경우 종종 1500바이트 미만으로 제한됩니다. 이 제한을 보완하기 위해 각 DTLS 핸드셰이크 메시지는 여러 DTLS 레코드로 분할될 수 있으며 각 레코드는 단일 UDP 데이터그램에 맞도록 되어 있습니다\(지침은 섹션 4.4 참조\). 각 DTLS 핸드셰이크 메시지에는 조각 오프셋과 조각 길이가 모두 포함됩니다. 따라서 핸드셰이크 메시지의 모든 바이트를 소유한 수신자는 조각난 원본 메시지를 다시 조립할 수 있습니다.

---
### **3.4.  Replay Detection**

DTLS는 선택적으로 레코드 재생 감지를 지원합니다. 사용된 기술은 수신된 레코드의 비트맵 창을 유지함으로써 IPsec AH/ESP에서와 동일합니다. 창에 다 담기에는 너무 오래된 레코드와 이전에 받은 레코드는 자동으로 폐기됩니다. 재생 감지 기능은 선택 사항입니다. 패킷 복제가 항상 악의적인 것은 아니지만 라우팅 오류로 인해 발생할 수도 있기 때문입니다. 응용 프로그램은 중복 패킷을 감지하고 그에 따라 데이터 전송 전략을 수정할 수 있습니다.

---
## **4.  The DTLS Record Layer**

DTLS 1.3 레코드 레이어는 TLS 1.3 레코드 레이어와 다르며 DTLS 1.2 레코드 레이어와도 다릅니다.

1. DTLSCiphertext 구조는 불필요한 버전 번호와 유형 필드를 생략합니다.

2. DTLS는 TLS 레코드 헤더에 에포크와 시퀀스 번호를 추가합니다. 이 시퀀스 번호를 통해 수신자는 DTLS 레코드를 올바르게 해독하고 확인할 수 있습니다. 그러나 DTLSCiphertext 구조의 에포크 및 시퀀스 번호 필드에 사용되는 비트 수가 이전 버전보다 줄었습니다.

3. DTLSPlaintext에서 직렬화된 DTLS 에포크는 DTLS 1.2와의 호환성을 위해 2 옥텟 길이입니다. 그러나 이 값은 모든 KeyUpdate에서 증가하는 8옥텟 카운터인 연결 epoch의 최하위 2옥텟으로 설정됩니다. 자세한 내용은 섹션 4.2를 참조하십시오. 시퀀스 번호는 64비트 시퀀스 번호의 하위 48비트로 설정됩니다. 일반 텍스트 레코드는 2^48-1을 초과하는 시퀀스 번호와 함께 전송되어서는 안 됩니다\(MUST NOT\). 따라서 상위 16비트는 항상 0입니다.\(MUST NOT\)

4. DTLSCiphertext 구조에는 가변 길이 헤더가 있습니다.

DTLSPlaintext 레코드는 보호되지 않은 레코드를 전송하는 데 사용되고 DTLSCiphertext 레코드는 보호된 레코드를 전송하는 데 사용됩니다.

DTLS 레코드 형식은 다음과 같습니다. 명시적으로 언급하지 않는 한 필드의 의미는 이전 TLS/DTLS 버전에서 변경되지 않습니다.

```text
       struct {
           ContentType type;
           ProtocolVersion legacy_record_version;
           uint16 epoch = 0
           uint48 sequence_number;
           uint16 length;
           opaque fragment[DTLSPlaintext.length];
       } DTLSPlaintext;

       struct {
            opaque content[DTLSPlaintext.length];
            ContentType type;
            uint8 zeros[length_of_padding];
       } DTLSInnerPlaintext;

       struct {
           opaque unified_hdr[variable];
           opaque encrypted_record[length];
       } DTLSCiphertext;

                     Figure 2: DTLS 1.3 Record Formats
```

legacy\_record\_version: 이 값은 초기 ClientHello\(즉, HelloRetryRequest 이후에 생성되지 않은 레코드\) 이외의 모든 레코드에 대해 {254, 253}으로 설정되어야 하며, 호환성을 위해 {254, 255}일 수도 있습니다. 모든 목적을 위해 무시해야 합니다. 이에 대한 근거는 \[TLS13\], 부록 D.1을 참조하십시오.\(MUST, MUST\)

epoch: 연결 epoch 값의 최하위 2바이트.

unified\_hdr: 통합 헤더\(unified\_hdr\)는 그림 3과 같이 가변 길이의 구조입니다.

crypto\_record: 직렬화된 레코드의 암호화된 형식

- DTLSInnerPlaintext 구조.

```text
       0 1 2 3 4 5 6 7
       +-+-+-+-+-+-+-+-+
       |0|0|1|C|S|L|E E|
       +-+-+-+-+-+-+-+-+
       | Connection ID |   Legend:
       | (if any,      |
       /  length as    /   C   - Connection ID (CID) present
       |  negotiated)  |   S   - Sequence number length
       +-+-+-+-+-+-+-+-+   L   - Length present
       |  8 or 16 bit  |   E   - Epoch
       |Sequence Number|
       +-+-+-+-+-+-+-+-+
       | 16 bit Length |
       | (if present)  |
       +-+-+-+-+-+-+-+-+

                     Figure 3: DTLS 1.3 Unified Header
```

고정 비트: 통합 헤더의 첫 번째 바이트의 상위 3개 비트는 001로 설정됩니다. 이렇게 하면 \[RFC7983\]에 설명된 대로 멀티플렉싱이 수행될 때 값이 DTLS 영역 내에 맞을 것입니다. 또한 암호화된 DTLS 1.3 레코드와 암호화된 DTLS 1.2 레코드를 동일한 호스트/포트 4중주에서 운반할 때 구별할 수 있습니다. 이러한 멀티플렉싱은 CID\[RFC9146\]가 사용 중인 경우에만 가능하며, 이 경우 DTLS 1.2 레코드의 콘텐츠 유형은 tls12\_cid\(25\)입니다.

C: 연결 ID가 있으면 C 비트\(0x10\)가 설정됩니다.

S: S 비트\(0x08\)는 시퀀스 번호의 크기를 나타냅니다. 0은 8비트 시퀀스 번호를 의미하고 1은 16비트를 의미합니다. 구현은 동일한 연결에서 길이가 다른 시퀀스 번호를 혼합할 수 있습니다\(MAY\).\(MAY\)

L: 길이가 있으면 L 비트\(0x04\)가 설정됩니다.

E: 하위 2비트\(0x03\)에는 에포크의 하위 2비트가 포함됩니다.

연결 ID: 가변 길이 CID. CID 기능은 \[RFC9146\]에 설명되어 있습니다. 예제는 섹션 9.1에서 찾을 수 있습니다.

시퀀스 번호: 레코드 시퀀스 번호의 하위 8 또는 16비트입니다. 이 값은 S 비트가 1로 설정된 경우 16비트이고 S 비트가 0이면 8비트입니다.

길이: TLS 1.3 레코드의 길이 필드와 동일합니다.

이전 버전의 DTLS와 마찬가지로 여러 DTLSPlaintext 및 DTLSCiphertext 레코드가 동일한 기본 전송 데이터그램에 포함될 수 있습니다.

```text
   Figure 4 illustrates different record headers.

    0 1 2 3 4 5 6 7       0 1 2 3 4 5 6 7       0 1 2 3 4 5 6 7
   +-+-+-+-+-+-+-+-+     +-+-+-+-+-+-+-+-+     +-+-+-+-+-+-+-+-+
   | Content Type  |     |0|0|1|1|1|1|E E|     |0|0|1|0|0|0|E E|
   +-+-+-+-+-+-+-+-+     +-+-+-+-+-+-+-+-+     +-+-+-+-+-+-+-+-+
   |   16 bit      |     |               |     |8 bit Seq. No. |
   |   Version     |     / Connection ID /     +-+-+-+-+-+-+-+-+
   +-+-+-+-+-+-+-+-+     |               |     |               |
   |   16 bit      |     +-+-+-+-+-+-+-+-+     |   Encrypted   |
   |    Epoch      |     |    16 bit     |     /   Record      /
   +-+-+-+-+-+-+-+-+     |Sequence Number|     |               |
   |               |     +-+-+-+-+-+-+-+-+     +-+-+-+-+-+-+-+-+
   |               |     |   16 bit      |
   |   48 bit      |     |   Length      |       DTLSCiphertext
   |Sequence Number|     +-+-+-+-+-+-+-+-+         Structure
   |               |     |               |         (minimal)
   |               |     |  Encrypted    |
   +-+-+-+-+-+-+-+-+     /  Record       /
   |    16 bit     |     |               |
   |    Length     |     +-+-+-+-+-+-+-+-+
   +-+-+-+-+-+-+-+-+
   |               |      DTLSCiphertext
   |               |        Structure
   /   Fragment    /          (full)
   |               |
   +-+-+-+-+-+-+-+-+

    DTLSPlaintext
      Structure

                     Figure 4: DTLS 1.3 Header Examples
```

길이 필드는 L 비트를 지우면 생략될 수 있습니다\(MAY\). 이는 레코드가 하위 수준 전송에서 데이터그램의 나머지 전체를 소비함을 의미합니다. 이 경우 동일한 데이터그램에서 길이 필드 없이 여러 DTLSCiphertext 형식 레코드를 가질 수 없습니다. 길이 필드 생략은 데이터그램의 마지막 레코드에만 사용해야 합니다. 구현은 동일한 연결에서 길이 필드가 있거나 없는 레코드를 혼합할 수 있습니다\(MAY\).\(MAY, MUST, MAY\)

연결 ID가 협상되면 모든 데이터그램에 포함되어야 합니다. 전송 구현은 동일한 데이터그램에서 여러 DTLS 연결의 레코드를 혼합해서는 안 됩니다\(MUST NOT\). 두 번째 또는 이후 레코드에 이전 레코드에 사용된 것과 동일한 연결에 해당하지 않는 연결 ID가 있는 경우 나머지 데이터그램은 폐기되어야 합니다.\(MUST, MUST NOT, MUST\)

확장되면 아래와 같이 에포크와 시퀀스 번호를 압축 해제된 RecordNumber 구조로 결합할 수 있습니다.

```text
       struct {
           uint64 epoch;
           uint64 sequence_number;
       } RecordNumber;
```

이 128비트 값은 AEAD\(Authenticated Encryption with Associated Data\) 기능에 대한 "record\_sequence\_number" 입력뿐만 아니라 ACK 메시지에서도 사용됩니다. 그림 4에 표시된 전체 헤더 값\(단, 레코드 번호 암호화 이전, 섹션 4.2.3 참조\)은 AEAD 기능의 추가 데이터 값으로 사용됩니다. 예를 들어 최소 변형이 사용되는 경우 연결된 데이터\(AD\)의 길이는 2옥텟입니다. 이 디자인은 DTLS 1.2 및 연결 ID가 있는 DTLS 1.2에 대한 추가 데이터 계산과 다릅니다. DTLS 1.3에서 64비트 sequence\_number는 AEAD 계산을 위한 시퀀스 번호로 사용됩니다. DTLS 1.2와 달리 에포크는 포함되지 않습니다.

---
### **4.1.  Demultiplexing DTLS Records**

DTLS 1.3의 헤더 형식은 항상 콘텐츠 유형을 첫 번째 바이트로 전달하는 DTLS 1.2보다 demux하기가 더 복잡합니다. 그림 5에 설명된 대로 첫 번째 바이트는 들어오는 DTLS 레코드가 역다중화되는 방식을 결정합니다. 첫 번째 바이트의 처음 3비트는 DTLS 1.3 암호화된 레코드를 이전 DTLS 버전 및 일반 텍스트 DTLS 1.3 레코드 유형에서 사용된 레코드 유형과 구별합니다. 따라서 32\(0b0010 0000\) \~ 63\(0b0011 1111\) 범위는 역다중화하는 동안 문제를 방지하기 위해 IANA의 향후 할당에서 제외되어야 합니다. 섹션 14를 참조하십시오. 구현은 다음과 같이 첫 번째 바이트를 검사하여 DTLS 1.3 레코드를 역다중화할 수 있습니다.

\* 첫 번째 바이트가 alert\(21\), handshake\(22\) 또는 ack\(proposed, 26\)인 경우 레코드는 DTLSPplaintext 레코드로 해석되어야 합니다.\(MUST\)

\* 첫 번째 바이트가 다른 값이면 수신자는 첫 번째 바이트의 선행 비트가 001인지 확인해야 합니다. 그렇다면 구현은 레코드를 DTLSCiphertext로 처리해야 합니다. 진정한 콘텐츠 유형은 보호된 부분 안에 있습니다.\(MUST, MUST\)

\* 그렇지 않으면 섹션 4.5.2에 설명된 대로 레코드가 보호 해제에 실패한 것처럼 레코드를 거부해야 합니다.\(MUST\)

그림 5는 DTLS 1.3 및 이전 버전의 DTLS를 고려하여 이 역다중화 절차를 그래픽으로 보여줍니다.

```text
                +----------------+
                | Outer Content  |
                |   Type (OCT)   |
                |                |
                |   OCT == 20   -+--> ChangeCipherSpec (DTLS <1.3)
                |   OCT == 21   -+--> Alert (Plaintext)
                |   OCT == 22   -+--> DTLSHandshake (Plaintext)
                |   OCT == 23   -+--> Application Data (DTLS <1.3)
                |   OCT == 24   -+--> Heartbeat (DTLS <1.3)
   packet  -->  |   OCT == 25   -+--> DTLSCiphertext with CID (DTLS 1.2)
                |   OCT == 26   -+--> ACK (DTLS 1.3, Plaintext)
                |                |
                |                |   /+----------------+\
                | 31 < OCT < 64 -+--> |DTLSCiphertext  |
                |                |    |(header bits    |
                |      else      |    | start with 001)|
                |       |        |   /+-------+--------+\
                +-------+--------+            |
                        |                     |
                        v          Decryption |
                  +---------+          +------+
                  |  Reject |          |
                  +---------+          v
                               +----------------+
                               | Decrypted      |
                               | Content Type   |
                               | (DCT)          |
                               |                |
                               |     DCT == 21 -+--> Alert
                               |     DCT == 22 -+--> DTLSHandshake
                               |     DCT == 23 -+--> Application Data
                               |     DCT == 24 -+--> Heartbeat
                               |     DCT == 26 -+--> ACK
                               |     else ------+--> Error
                               +----------------+

           Figure 5: Demultiplexing DTLS 1.2 and DTLS 1.3 Records
```

---
### **4.2.  Sequence Number and Epoch**

DTLS는 레코드의 sequence\_number 필드에 포함된 암시적 시퀀스 번호가 아니라 명시적이거나 부분적으로 명시적인 시퀀스 번호를 사용합니다. 시퀀스 번호는 각 epoch에 대해 별도로 유지되며 각 sequence\_number는 처음에 각 epoch에 대해 0입니다.

에포크 번호는 처음에는 0이며 키 자료가 변경되고 발신자가 키 재입력을 목표로 할 때마다 증가합니다. 자세한 내용은 섹션 6.1에 나와 있습니다.

---
#### **4.2.1.  Processing Guidelines**

DTLS 레코드는 재정렬될 수 있기 때문에 에포크 N\(N \> M\)이 시작된 후에 에포크 M의 레코드가 수신될 수 있습니다. 구현은 이전 시대의 레코드를 폐기해야 하지만 패킷 재정렬을 허용하기 위해 TCP\[RFC0793\]에 지정된 기본 MSL까지 이전 시대의 키 자료를 유지하도록 선택할 수 있습니다\(MAY\). \(여기서 구현자는 \[RFC0793\] 또는 후속 버전에 지정된 대로 MSL에 대한 IETF의 현재 지침을 사용하는 것이지 시스템 TCP 스택이 사용하는 MSL을 조사하려고 시도하는 것이 아닙니다.\)\(SHOULD\)

반대로 새 시대로 보호되는 레코드는 핸드셰이크가 완료되기 전에 수신될 수 있습니다. 예를 들어, 서버는 Finished 메시지를 보낸 다음 데이터 전송을 시작할 수 있습니다. DTLS가 신뢰할 수 있는 전송\(예: SCTP\[RFC4960\]\)을 통해 사용될 때 구현은 이러한 레코드를 버퍼링하거나 폐기할 수 있습니다\(MAY\). 핸드셰이크가 완료되면 버퍼링되고 처리되어야 합니다. 레코드를 보낼 수 있는 시기에 대한 TLS의 제한 사항은 여전히 ​​적용되며 수신자는 레코드를 올바른 순서로 보낸 것처럼 처리합니다.\(SHOULD\)

구현은 원래 전송과 동일한 에포크 및 키 자료를 사용하여 손실된 메시지의 재전송을 보내야 합니다.\(MUST\)

구현은 시퀀스 번호가 래핑되도록 허용하기 전에 연결을 포기하거나 키를 다시 입력해야 합니다.\(MUST\)

구현은 에포크가 래핑되는 것을 허용해서는 안 되며 대신 새로운 연결을 설정하고 이전 연결을 종료해야 합니다.\(MUST NOT\)

---
#### **4.2.2.  Reconstructing the Sequence Number and Epoch**

보호된 DTLS 레코드를 수신할 때 수신자는 레코드에 전체 에포크 또는 시퀀스 번호 값이 없으므로 모호할 가능성이 있습니다. 레코드당 난스를 계산하는 데 전체 시퀀스 번호가 사용되고 에포크가 키를 결정하기 때문에 이러한 값을 재구성하지 못하면 레코드 보호를 해제하지 못하므로 구현은 전체 값을 결정하기 위해 선택한 메커니즘을 사용할 수 있습니다\(MAY\). 이 섹션에서는 비교적 간단하고 따라야 할 구현이 권장되는 알고리즘을 제공합니다.\(MAY, SHOULD\)

에포크 비트가 현재 에포크의 비트와 일치하는 경우 구현은 현재 에포크에서 성공적으로 보호 해제된 가장 높은 레코드의 시퀀스 번호를 더한 1에 수치적으로 가장 가까운 전체 시퀀스 번호를 계산하여 시퀀스 번호를 재구성해야 합니다\(SHOULD\).\(SHOULD\)

핸드셰이크 단계에서 에포크 비트는 사용할 올바른 키를 명확하게 나타냅니다. 핸드셰이크가 완료된 후 에포크 비트가 현재 에포크의 비트와 일치하지 않으면 구현은 일치하는 비트가 있는 가장 최근 과거 에포크를 사용한 다음 위에서 설명한 대로 해당 에포크의 시퀀스 번호를 재구성해야 합니다.\(SHOULD\)

---
#### **4.2.3.  Record Number Encryption**

DTLS 1.3에서는 레코드가 암호화되면 레코드 시퀀스 번호도 암호화됩니다. 기본 패턴은 AEAD 알고리즘과 함께 사용되는 기본 암호화 알고리즘이 시퀀스 번호와 XOR되는 마스크를 생성하는 데 사용된다는 것입니다.

AEAD가 AES를 기반으로 하는 경우 마스크는 암호문의 처음 16바이트에서 AES-ECB를 계산하여 생성됩니다.

```text
     Mask = AES-ECB(sn_key, Ciphertext[0..15])
```

AEAD가 ChaCha20을 기반으로 할 때 마스크는 암호문의 처음 4바이트를 블록 카운터로 처리하고 다음 12바이트를 nonce로 처리하여 ChaCha20 블록 함수에 전달하여 생성됩니다\(\[CHACHA\]의 섹션 2.3\). :

```text
     Mask = ChaCha20(sn_key, Ciphertext[0..3], Ciphertext[4..15])
```

sn\_key는 다음과 같이 계산됩니다.

```text
     [sender]_sn_key = HKDF-Expand-Label(Secret, "sn", "", key_length)
```

\[송신자\]는 송신측을 나타냅니다. 사용할 epoch당 Secret 값은 \[TLS13\]의 7.3절에 설명되어 있습니다. 새 키가 각 에포크에 사용된다는 점에 유의하십시오. 에포크는 평문으로 전송되기 때문에 모호성이 발생하지 않습니다.

암호화된 시퀀스 번호는 마스크의 선행 바이트를 시퀀스 번호의 유선 표현과 XOR하여 계산됩니다. 암호 해독은 동일한 프로세스에 의해 수행됩니다.

이 절차에서는 암호문 길이가 16바이트 이상이어야 합니다. 수신자는 섹션 4.5.2에 설명된 대로 보호 해제에 실패한 것처럼 더 짧은 레코드를 거부해야 합니다\(MUST\). 발신자는 적절한 길이의 암호문을 만들기 위해 짧은 평문을 채워야 합니다\(기존 레코드 패딩 메커니즘 사용\). 대부분의 DTLS AEAD 알고리즘에는 16바이트 인증 태그가 있으며 패딩이 필요하지 않습니다. 그러나 TLS\_AES\_128\_CCM\_8\_SHA256과 같은 일부 알고리즘은 인증 태그가 더 짧고 짧은 입력에 패딩이 필요할 수 있습니다.\(MUST, MUST\)

AES 또는 ChaCha20을 기반으로 하지 않는 미래의 암호화 제품군은 DTLS와 함께 사용하기 위해 자체 레코드 시퀀스 번호 암호화를 정의해야 합니다.\(MUST\)

시퀀스 번호 암호화는 DTLSCiphertext 구조에만 적용되며 DTLSPlaintext 구조에는 시퀀스 번호도 포함되어 있더라도 적용되지 않습니다.

---
### **4.3.  Transport Layer Mapping**

DTLS 메시지는 여러 DTLS 레코드로 조각화될 수 있습니다. 각 DTLS 레코드는 단일 데이터그램 내에 맞아야 합니다. IP 조각화를 방지하기 위해 DTLS 레코드 계층의 클라이언트는 레코드 계층에서 얻은 경로 MTU\(PMTU\) 추정치에 맞도록 레코드의 크기를 조정해야 합니다\(SHOULD\). PMTU 문제에 대한 자세한 내용은 섹션 4.4를 참조하십시오.\(MAY, MUST, SHOULD\)

여러 DTLS 레코드가 단일 데이터그램에 배치될 수 있습니다. 레코드는 연속적으로 인코딩됩니다. 해당 필드를 포함하는 DTLS 레코드의 길이 필드는 레코드 간의 경계를 결정하는 데 사용할 수 있습니다. 데이터그램의 최종 레코드는 길이 필드를 생략할 수 있습니다. 데이터그램 페이로드의 첫 번째 바이트는 레코드의 시작이어야 합니다. 레코드는 데이터그램에 걸쳐서는 ​​안 됩니다\(MUST NOT\).\(MAY, MUST, MUST NOT\)

CID가 없는 DTLS 레코드에는 연결 식별자가 포함되어 있지 않으며 응용 프로그램은 연결 간에 다중화되도록 조정해야 합니다. UDP에서는 호스트/포트 번호를 사용하여 CID 없이 들어오는 레코드에 대한 적절한 보안 연결을 조회합니다.

DCCP \[RFC4340\]와 같은 일부 전송은 자체 시퀀스 번호를 제공합니다. 이러한 전송을 통해 전달되면 DTLS와 전송 시퀀스 번호가 모두 표시됩니다. 이로 인해 약간의 비효율이 발생하지만 전송 계층과 DTLS 시퀀스 번호는 다른 용도로 사용됩니다. 따라서 개념적 단순성을 위해 두 시퀀스 번호를 모두 사용하는 것이 좋습니다.

일부 전송은 전송되는 트래픽에 대해 혼잡 제어를 제공합니다. 혼잡 기간이 충분히 좁으면 DTLS 핸드셰이크 재전송이 즉시 전송되지 않고 보류되어 잠재적으로 시간 초과 및 가짜 재전송이 발생할 수 있습니다. 이러한 전송을 통해 DTLS를 사용하는 경우 가능한 혼잡 창을 초과하지 않도록 주의해야 합니다. \[RFC5238\]은 이러한 문제를 고려하는 DCCP에 대한 DTLS 매핑을 정의합니다.

---
### **4.4.  PMTU Issues**

일반적으로 DTLS의 철학은 PMTU 검색을 애플리케이션에 맡기는 것입니다. 그러나 DTLS는 다음 세 가지 이유로 PMTU를 완전히 무시할 수 없습니다.

\* DTLS 레코드 프레이밍은 데이터그램 크기를 확장하므로 애플리케이션의 관점에서 효과적인 PMTU를 낮춥니다.

\* 일부 구현에서 애플리케이션은 네트워크와 직접 통신하지 않을 수 있으며, 이 경우 DTLS 스택은 ICMP "데이터그램이 너무 큼" 표시 \[RFC1191\] 또는 ICMPv6 "패킷이 너무 큼" 표시 \[RFC4443\]를 흡수할 수 있습니다.

\* DTLS 핸드셰이크 메시지는 PMTU를 초과할 수 있습니다.

처음 두 가지 문제를 처리하기 위해 DTLS 레코드 레이어는 아래 설명된 대로 동작해야 합니다\(SHOULD\).\(SHOULD\)

기본 전송 프로토콜에서 PMTU 추정치를 사용할 수 있는 경우 상위 계층 프로토콜에서 사용할 수 있어야 합니다. 특히:

\* UDP를 통한 DTLS의 경우 상위 계층 프로토콜이 IP 계층에서 유지 관리되는 PMTU 추정치를 얻을 수 있도록 허용해야 합니다\(SHOULD\).\(SHOULD\)

\* DCCP를 통한 DTLS의 경우 상위 계층 프로토콜이 PMTU의 현재 추정치를 얻을 수 있도록 허용해야 합니다\(SHOULD\).\(SHOULD\)

\* 데이터그램을 자동으로 분할하고 재조립하는 TCP 또는 SCTP를 통한 DTLS의 경우 PMTU 제한이 없습니다. 그러나 상위 계층 프로토콜은 최대 레코드 크기인 2^14바이트를 초과하는 레코드를 쓰지 않아야 합니다\(MUST NOT\).\(MUST NOT\)

DTLS 레코드 계층은 또한 상위 계층 프로토콜이 DTLS 처리에 의해 예상되는 레코드 확장의 양을 발견하도록 허용해야 합니다\(SHOULD\). 또는 전송 계층 및 DTLS 레코드 프레이밍에서 추정된 확장을 뺀 PMTU 추정치를 보고할 수 있습니다\(MAY\).\(SHOULD\)

DTLS는 스푸핑된 ICMP 메시지를 방어하지 않습니다. 구현은 각각 IPv4 및 IPv6 최소값인 576 및 1280바이트 미만의 PMTU를 나타내는 메시지를 무시해야 합니다\(SHOULD\).\(SHOULD\)

PMTU가 초과되었다는 전송 프로토콜 표시가 있는 경우\(ICMP를 통해 또는 \[RFC4340\]의 섹션 14에서와 같이 데이터그램 전송 거부를 통해\) DTLS 레코드 계층은 상위 계층 프로토콜에 오류를 알려야 합니다\(MUST\).\(MUST\)

DTLS 레코드 계층은 IPv4의 경우 \[RFC1191\] 및 \[RFC4821\]을 통해든 IPv6의 경우 \[RFC8201\]를 통해든 PMTU 발견을 수행하는 상위 계층 프로토콜을 방해해서는 안 됩니다\(SHOULD NOT\). 특히:\(SHOULD NOT\)

\* 기본 전송 프로토콜에서 허용하는 경우 상위 계층 프로토콜은 DF\(조각화 안 함\) 비트\(IPv4에서\)의 상태를 설정하거나 로컬 조각화를 금지\(IPv6에서\)하도록 허용해야 합니다\(SHOULD\).\(SHOULD\)

\* 기본 전송 프로토콜이 애플리케이션이 PMTU 프로빙\(예: DCCP\)을 요청할 수 있도록 허용하는 경우 DTLS 레코드 레이어는 이 요청을 수락해야 합니다\(SHOULD\).\(SHOULD\)

마지막 문제는 DTLS 핸드셰이크 프로토콜입니다. DTLS 레코드 계층의 관점에서 이것은 또 다른 상위 계층 프로토콜일 뿐입니다. 그러나 DTLS 핸드셰이크는 드물게 발생하며 몇 번의 왕복만 포함합니다. 따라서 핸드셰이크 프로토콜 PMTU 처리는 정확한 PMTU 검색보다 빠른 완료에 프리미엄을 부여합니다. 이러한 상황에서 연결을 허용하기 위해 DTLS 구현은 다음 규칙을 따라야 합니다.\(SHOULD\)

\* DTLS 레코드 레이어가 DTLS 핸드셰이크 레이어에 메시지가 너무 크다고 알리면 핸드셰이크 레이어는 즉시 PMTU에 대한 기존 정보를 사용하여 메시지 조각화를 시도해야 합니다\(SHOULD\).\(SHOULD\)

\* 반복된 재전송이 응답으로 이어지지 않고 PMTU를 알 수 없는 경우 후속 재전송은 더 작은 레코드 크기로 백오프하여 핸드셰이크 메시지를 적절하게 조각화해야 합니다. 이 사양은 백오프하기 전에 시도할 정확한 재전송 횟수를 지정하지 않지만 2-3이 적절해 보입니다.\(SHOULD\)

---
### **4.5.  Record Payload Protection**

TLS와 마찬가지로 DTLS는 일련의 보호된 레코드로 데이터를 전송합니다. 이 섹션의 나머지 부분에서는 해당 형식에 대해 자세히 설명합니다.

---
#### **4.5.1.  Anti-Replay**

각 DTLS 레코드에는 재생 보호를 제공하는 시퀀스 번호가 포함되어 있습니다. 시퀀스 번호 확인은 \[RFC4303\]의 섹션 3.4.3에서 차용한 다음 슬라이딩 윈도우 절차를 사용하여 수행해야 합니다\(SHOULD\). 각 에포크는 시퀀스 번호 공간을 재설정하기 때문에 각 에포크마다 별도의 슬라이딩 윈도우가 필요합니다.\(SHOULD\)

에포크에 대한 수신된 레코드 카운터는 해당 에포크가 처음 사용될 때 0으로 초기화되어야 합니다. 수신된 각 레코드에 대해 수신기는 연결 수명 동안 해당 에포크에서 수신된 다른 레코드의 시퀀스 번호와 중복되지 않는 시퀀스 번호가 레코드에 포함되어 있는지 확인해야 합니다. 이 확인은 레코드의 보호를 해제한 후에 수행해야 합니다. 그렇지 않으면 레코드 폐기 자체가 레코드 번호에 대한 타이밍 채널 역할을 할 수 있습니다. 부분에서 전체 레코드 번호를 계산하는 것은 레코드가 보호 해제되었는지 여부보다 덜 강력하지만 여전히 레코드 번호에 대한 잠재적인 타이밍 채널입니다.\(MUST, MUST, SHOULD\)

중복 수신은 슬라이딩 수신 창을 사용하여 거부됩니다. \(윈도우 구현 방법은 로컬 문제이지만 다음 텍스트는 구현이 표시해야 하는 기능을 설명합니다.\) 수신자는 데이터 속도에 따라 그럴듯한 재정렬을 처리할 수 있을 만큼 충분히 큰 윈도우를 선택해야 합니다. \(수신자는 송신자에게 윈도우 크기를 알려주지 않는다.\)\(SHOULD\)

창의 "오른쪽" 가장자리는 에포크에서 수신된 가장 높은 검증된 시퀀스 번호 값을 나타냅니다. 창의 "왼쪽" 가장자리보다 낮은 시퀀스 번호를 포함하는 레코드는 거부됩니다. 창 내에 있는 레코드는 창 내에서 수신된 레코드 목록과 비교하여 확인됩니다. \[RFC4303\]의 섹션 3.4.3에 비트 마스크 사용을 기반으로 이 검사를 수행하는 효율적인 방법이 설명되어 있습니다. 수신된 레코드가 창 내에 있고 새 레코드이거나 레코드가 창 오른쪽에 있는 경우 레코드는 새 레코드입니다.

해당 레코드가 성공적으로 보호 해제될 때까지 수신된 레코드로 인해 창을 업데이트하면 안 됩니다\(MUST NOT\).\(MUST NOT\)

---
#### **4.5.2.  Handling Invalid Records**

TLS와 달리 DTLS는 유효하지 않은 레코드\(예: 유효하지 않은 형식, 길이, MAC 등\)에도 탄력적입니다. 일반적으로 유효하지 않은 레코드는 자동으로 폐기되어야 하므로 연결이 유지됩니다. 그러나 진단 목적으로 오류가 기록될 수 있습니다. 대신 경고를 생성하도록 선택한 구현은 공격자가 구현을 반복적으로 조사하여 다양한 유형의 오류에 어떻게 대응하는지 확인하는 공격을 피하기 위해 치명적인 경고를 생성해야 합니다. DTLS가 UDP를 통해 실행되는 경우 UDP 위조가 매우 쉽기 때문에 이를 수행하는 모든 구현은 DoS 공격에 매우 취약합니다. 따라서 DTLS 서비스의 안정성을 높이고 관련 없는 제3자에게 트래픽을 보내는 스푸핑 공격의 위험을 피하기 위해 이러한 전송에 치명적인 경고를 생성하는 것은 권장되지 않습니다.\(SHOULD, MUST, SHOULD NOT\)

DTLS가 위조에 강한 전송\(예: SCTP-AUTH가 있는 SCTP\)을 통해 전달되는 경우 공격자가 전송 계층에서 거부되지 않는 데이터그램을 위조하는 데 어려움을 겪기 때문에 경고를 보내는 것이 더 안전합니다.

잘못된 레코드는 핸드셰이크 상태 시스템보다 낮은 계층에서 거부되기 때문에 보류 중인 재전송 타이머에 영향을 미치지 않습니다.

---
#### **4.5.3.  AEAD Limits**

\[TLS13\]의 섹션 5.5는 동일한 키를 사용하여 보호할 수 있는 레코드 수에 대한 제한을 정의합니다. 이러한 제한은 AEAD 알고리즘에만 적용되며 DTLS에도 동일하게 적용됩니다. 구현은 협상된 AEAD에 대해 지정된 제한에서 허용하는 것보다 더 많은 레코드를 보호하면 안 됩니다\(SHOULD NOT\). 구현은 이 제한에 도달하기 전에 키 업데이트를 시작해야 합니다\(SHOULD\).\(SHOULD NOT, SHOULD\)

\[TLS13\]은 AEAD\_AES\_128\_CCM에 대한 제한을 지정하지 않지만 부록 B의 분석은 2^23 패킷의 제한을 사용하여 TLS에 지정된 제한과 동일한 기밀 보호를 얻을 수 있음을 보여줍니다.

TLS 1.3에 정의된 사용 제한은 기밀성 공격으로부터 보호하기 위해 존재하며 AEAD 보호의 성공적인 적용에 적용됩니다. 인증된 암호화의 무결성 보호는 패킷 위조 시도 횟수 제한에 따라 달라집니다. TLS는 레코드가 인증 확인에 실패한 후 연결을 닫음으로써 이를 달성합니다. 이에 비해 DTLS는 인증할 수 없는 패킷을 무시하므로 여러 번의 위조 시도가 허용됩니다.

구현은 각 키로 인증에 실패한 수신 패킷 수를 계산해야 합니다. 인증에 실패한 패킷 수가 사용 중인 AEAD에 특정한 제한을 초과하는 경우 구현은 즉시 연결을 닫아야 합니다\(SHOULD\). 구현은 이 제한에 도달하기 전에 update\_requested로 키 업데이트를 시작해야 합니다\(SHOULD\). 키 업데이트가 시작되면 제한에 도달하면 연결을 닫지 않고 이전 키를 삭제할 수 있습니다. 제한을 적용하면 공격자가 패킷을 성공적으로 위조할 수 있는 가능성이 줄어듭니다. \[AEBounds\] 및 \[ROBUST\]를 참조하십시오.\(MUST, SHOULD, SHOULD\)

AEAD\_AES\_128\_GCM, AEAD\_AES\_256\_GCM 및 AEAD\_CHACHA20\_POLY1305의 경우 인증에 실패한 레코드 수에 대한 제한은 2^36입니다. \[AEBounds\]의 분석은 AEAD\_AES\_128\_GCM 및 AEAAD\_AES\_256\_GCM에 대해 더 높은 제한을 지원하지만 이 사양에서는 더 낮은 제한을 권장합니다. AEAD\_AES\_128\_CCM의 경우 인증에 실패한 레코드 수의 제한은 2^23.5입니다. 부록 B를 참조하십시오.

TLS\_AES\_128\_CCM\_8\_SHA256에서 사용되는 AEAD\_AES\_128\_CCM\_8 AEAD는 인증에 실패한 레코드 수에 대한 제한이 없으므로 둘 다 위조 가능성을 동일한 양으로 제한하고 구현을 서비스 거부 위험에 노출시키지 않습니다. 부록 B.3 참조. 따라서 TLS\_AES\_128\_CCM\_8\_SHA256은 위조에 대한 추가 보호 장치 없이 DTLS에서 사용해서는 안 됩니다\(MUST NOT\). 구현은 사용되는 추가 위조 보호에 대한 이해를 기반으로 AEAD\_AES\_128\_CCM\_8에 대한 사용 제한을 설정해야 합니다\(MUST\).\(MUST NOT, MUST\)

DTLS와 함께 사용하도록 지정된 모든 TLS 암호화 제품군은 기밀성과 무결성 모두에 대한 여백을 보존하는 관련 AEAAD 기능의 사용에 대한 제한을 정의해야 합니다. 즉, 키 업데이트가 필요하기 전에 인증할 수 있는 패킷 수와 인증에 실패할 수 있는 패킷 수에 대한 제한을 지정해야 합니다. 값의 기반이 되는 모든 분석에 대한 참조와 해당 분석에 사용되는 모든 가정을 제공하면 다양한 사용 조건에 맞게 제한을 조정할 수 있습니다.\(MUST, MUST\)

---
## **5.  The DTLS Handshake Protocol**

DTLS 1.3은 다음 변경 사항과 함께 TLS 1.3 핸드셰이크 메시지 및 흐름을 재사용합니다.

1. 메시지 손실, 재정렬 및 ​​조각화를 처리하려면

- 핸드셰이크 헤더에 대한 수정이 필요합니다.

2. 메시지 손실을 처리하기 위해 재전송 타이머가 도입되었습니다.

3. Handshake 메시지의 안정적인 메시지 전달을 위해 새로운 ACK 콘텐츠 유형이 추가되었습니다.

또한 DTLS는 TLS 1.3의 "쿠키" 확장을 재사용하여 연결 설정의 일부로 반환 라우팅 가능성 검사를 제공합니다. 이는 TCP가 연결 설정의 일부로 반환 라우팅 가능성을 설정하는 TCP 기반 프로토콜과 달리 UDP 기반 프로토콜에 대한 중요한 DoS 방지 메커니즘입니다.

DTLS 구현은 \[TLS13\]의 부록 D.4에 설명된 TLS 1.3 "호환성 모드"를 사용하지 않습니다. DTLS 서버는 클라이언트의 "legacy\_session\_id" 값을 반영하면 안 되며 엔드포인트는 ChangeCipherSpec 메시지를 보내면 안 됩니다.\(MUST NOT\)

이러한 예외를 제외하고 DTLS 메시지 형식, 흐름 및 논리는 TLS 1.3과 동일합니다.

---
### **5.1.  Denial-of-Service Countermeasures**

데이터그램 보안 프로토콜은 다양한 DoS 공격에 매우 취약합니다. 두 가지 공격이 특히 우려됩니다.

1. 공격자는 일련의 핸드셰이크 시작 요청을 전송하여 서버에서 과도한 리소스를 소모하여 서버가 상태를 할당하고 잠재적으로 값비싼 암호화 작업을 수행하도록 할 수 있습니다.

2. 공격자는 피해자의 소스 주소를 위조하여 연결 초기화 메시지를 전송하여 서버를 증폭기로 사용할 수 있습니다. 그런 다음 서버는 피해 시스템에 응답을 전송하여 플러딩합니다. 선택한 매개변수에 따라 이 응답 메시지는 인증서 메시지의 경우와 같이 상당히 클 수 있습니다.

이 두 가지 공격에 대응하기 위해 DTLS는 Photuris\[RFC2522\] 및 IKE\[RFC7296\]에서 사용하는 상태 비저장 쿠키 기술을 차용합니다. 클라이언트가 ClientHello 메시지를 서버에 보낼 때 서버는 HelloRetryRequest 메시지로 응답할 수 있습니다. HelloRetryRequest 메시지와 "쿠키" 확장자는 TLS 1.3에 정의되어 있습니다. HelloRetryRequest 메시지에는 무상태 쿠키가 포함되어 있습니다\(\[TLS13\], 섹션 4.2.2 참조\). 클라이언트는 확장으로 추가된 쿠키와 함께 새로운 ClientHello를 보내야 합니다. 그런 다음 서버는 쿠키를 확인하고 유효한 경우에만 핸드셰이크를 진행합니다. 이 메커니즘은 공격자/클라이언트가 쿠키를 수신할 수 있도록 강제하므로 스푸핑된 IP 주소로 DoS 공격을 어렵게 만듭니다. 이 메커니즘은 유효한 IP 주소에서 마운트된 DoS 공격에 대한 방어를 제공하지 않습니다.\(MAY, MUST\)

DTLS 1.3 사양은 DTLS 1.2와 비교하여 쿠키 교환 방식을 변경합니다. DTLS 1.3은 HelloRetryRequest 메시지를 재사용하고 확장을 통해 클라이언트에 쿠키를 전달합니다. 쿠키를 수신하는 클라이언트는 동일한 확장을 사용하여 이후에 ClientHello 메시지에 쿠키를 배치합니다. 반면 DTLS 1.2는 HelloVerifyRequest라는 별도의 메시지를 사용하여 쿠키를 클라이언트에 전달했으며 확장 메커니즘을 사용하지 않았습니다. 이전 버전과의 호환성을 위해 ClientHello의 쿠키 필드는 DTLS 1.3에 있지만 DTLS 1.3 호환 서버 구현에서는 무시됩니다.

교환은 그림 6에 나와 있습니다. 그림은 쿠키 교환에 초점을 맞추고 있습니다. 다른 모든 확장자는 생략됩니다.

```text
         Client                                   Server
         ------                                   ------
         ClientHello           ------>

                               <----- HelloRetryRequest
                                       + cookie

         ClientHello           ------>
          + cookie
```

- \[나머지 악수\]

```text
       Figure 6: DTLS Exchange with HelloRetryRequest Containing the
                             "cookie" Extension
```

"쿠키" 확장자는 \[TLS13\]의 섹션 4.2.2에 정의되어 있습니다. 초기 ClientHello를 보낼 때 클라이언트에는 아직 쿠키가 없습니다. 이 경우 "cookie" 확장자는 생략되고 ClientHello 메시지의 legacy\_cookie 필드는 길이가 0인 벡터\(즉, 값이 0인 단일 바이트 길이 필드\)로 설정되어야 합니다.\(MUST\)

HelloRetryRequest에 응답할 때 클라이언트는 \[TLS13\]의 섹션 4.1.2의 설명에 따라 새로운 ClientHello 메시지를 생성해야 합니다.\(MUST\)

HelloRetryRequest 메시지가 사용되는 경우 초기 ClientHello 및 HelloRetryRequest가 트랜스크립트 해시 계산에 포함됩니다. HelloRetryRequest에 대한 메시지 해시 계산은 \[TLS13\]의 섹션 4.4.1의 설명에 따라 수행됩니다.

핸드셰이크 기록은 두 번째 ClientHello로 재설정되지 않으며 상태 비저장 서버 쿠키 구현에서는 초기 ClientHello\(및 HelloRetryRequest\)의 콘텐츠 또는 해시가 쿠키에 저장되어야 합니다. 초기 ClientHello는 핸드셰이크 대화 내용에 합성 "message\_hash" 메시지로 포함되어 있으므로 완전한 HelloRetryRequest 콘텐츠가 필요하지만 핸드셰이크를 완료하려면 해시 값만 필요합니다.

두 번째 ClientHello가 수신되면 서버는 쿠키가 유효한지, 클라이언트가 주어진 IP 주소에서 패킷을 수신할 수 있는지 확인할 수 있습니다. 클라이언트의 명백한 IP 주소가 쿠키에 내장되어 있으면 공격자가 다른 사용자로부터 허용 가능한 ClientHello를 생성하는 것을 방지합니다.

이 체계에 대한 잠재적인 공격 중 하나는 공격자가 엔드포인트를 제어하는 ​​여러 주소에서 여러 쿠키를 수집한 다음 이를 재사용하여 서버를 공격하는 것입니다. 서버는 비밀 값을 자주 변경하여 해당 쿠키를 무효화함으로써 이 공격을 방어할 수 있습니다. 서버가 합법적인 클라이언트가 전환을 통해 핸드셰이크하도록 허용하려는 경우\(예: 클라이언트가 Secret 1이 포함된 쿠키를 받은 다음 서버가 Secret 2로 변경된 후 두 번째 ClientHello를 전송함\) 서버는 제한된 창을 가질 수 있습니다. 두 비밀을 모두 받아들입니다. \[RFC7296\]은 이 사례를 감지하기 위해 쿠키에 키 식별자를 추가할 것을 제안합니다. 다른 접근 방식은 단순히 두 보안 비밀로 확인을 시도하는 것입니다. 서버가 수명이 겹치는 키를 관리할 수 있도록 하는 키 순환 체계를 구현하는 것이 좋습니다\(RECOMMENDED\).\(SHOULD\)

또는 서버는 쿠키에 타임스탬프를 저장하고 일정 시간 간격을 벗어나 생성된 쿠키를 거부할 수 있습니다.

DTLS 서버는 새로운 핸드셰이크가 수행될 때마다 쿠키 교환을 수행해야 합니다\(SHOULD\). 증폭이 문제가 되지 않는 환경\(예: ICE\[RFC8445\]를 사용하여 양방향 연결을 설정한 경우\)에서 서버를 운영하는 경우 쿠키 교환을 수행하지 않도록 서버를 구성할 수 있습니다\(MAY\). 그러나 기본값은 교환이 수행되는 것입니다\(SHOULD\). 또한 서버는 세션이 재개될 때 또는 보다 일반적으로 DTLS 핸드셰이크가 PSK 기반 키 교환을 사용하고 IP 주소가 PSK와 연결된 주소와 일치할 때 쿠키 교환을 수행하지 않도록 선택할 수 있습니다\(MAY\). 쿠키 교환 없이 0-RTT 요청을 처리하고 0.5-RTT 응답을 보내는 서버는 보내는 메시지의 크기가 수신 메시지의 크기를 크게 초과하는 경우 증폭 공격에 사용될 위험이 있습니다. 서버는 클라이언트가 해당 주소에서 데이터를 수신할 수 있는지 확인하기 전에 클라이언트 주소로 보내는 데이터 양을 클라이언트가 보낸 데이터 양의 3배로 제한해야 합니다\(SHOULD\). 클라이언트 주소는 쿠키 교환 또는 핸드셰이크 완료 후에 유효합니다. 클라이언트는 악수할 때마다 쿠키 교환을 수행할 준비가 되어 있어야 합니다. 쿠키는 기존 핸드셰이크에만 유효하며 향후 핸드셰이크를 위해 저장할 수 없습니다.\(SHOULD, MAY, SHOULD, MAY, SHOULD, MUST\)

서버가 유효하지 않은 쿠키가 포함된 ClientHello를 수신하는 경우 "illegal\_parameter" 경고와 함께 핸드셰이크를 종료해야 합니다. 이를 통해 클라이언트는 쿠키 없이 연결을 처음부터 다시 시작할 수 있습니다.\(MUST\)

\[TLS13\]의 섹션 4.1.4에 설명된 대로 클라이언트는 동일한 연결에서 전송된 두 번째 HelloRetryRequest에 대한 응답으로 "unexpected\_message" 경고와 함께 핸드셰이크를 중단해야 합니다. .\(MUST\)

연결 ID 수신을 원하지 않는 DTLS 클라이언트는 반대되는 애플리케이션 프로필이 없는 한 "connection\_id" 확장자\[RFC9146\]를 계속 제공해야 합니다\(SHOULD\). 이를 통해 CID를 수신하려는 서버가 이를 협상할 수 있습니다.\(SHOULD\)

---
### **5.2.  DTLS Handshake Message Format**

DTLS는 TLS 1.3과 동일한 핸드셰이크 메시지를 사용합니다. 그러나 전송 전에 메시지 손실, 재정렬 및 ​​메시지 조각화를 지원하는 데 필요한 추가 데이터가 포함된 DTLSHandshake 메시지로 변환됩니다.

```text
       enum {
           client_hello(1),
           server_hello(2),
           new_session_ticket(4),
           end_of_early_data(5),
           encrypted_extensions(8),
           request_connection_id(9),           /* New */
           new_connection_id(10),              /* New */
           certificate(11),
           certificate_request(13),
           certificate_verify(15),
           finished(20),
           key_update(24),
           message_hash(254),
           (255)
       } HandshakeType;

       struct {
           HandshakeType msg_type;    /* handshake type */
           uint24 length;             /* bytes in message */
           uint16 message_seq;        /* DTLS-required field */
           uint24 fragment_offset;    /* DTLS-required field */
           uint24 fragment_length;    /* DTLS-required field */
           select (msg_type) {
               case client_hello:          ClientHello;
               case server_hello:          ServerHello;
               case end_of_early_data:     EndOfEarlyData;
               case encrypted_extensions:  EncryptedExtensions;
               case certificate_request:   CertificateRequest;
               case certificate:           Certificate;
               case certificate_verify:    CertificateVerify;
               case finished:              Finished;
               case new_session_ticket:    NewSessionTicket;
               case key_update:            KeyUpdate;
               case request_connection_id: RequestConnectionId;
               case new_connection_id:     NewConnectionId;
           } body;
       } DTLSHandshake;
```

DTLS 1.3에서 메시지 기록은 message\_seq, fragment\_offset 및 fragment\_length 값 없이 원래 TLS 1.3 스타일 핸드셰이크 메시지에 대해 계산됩니다. 이는 해당 값이 성적표에 포함된 DTLS 1.2에서 변경된 사항입니다.

각 연결에서 각 측이 전송하는 첫 번째 메시지는 항상 message\_seq = 0입니다. 새 메시지가 생성될 때마다 message\_seq 값이 1씩 증가합니다. 메시지를 재전송할 때 이전 message\_seq 값을 다시 사용합니다. 즉, 증가하지 않습니다. DTLS 레코드 레이어의 관점에서 재전송은 새로운 레코드입니다. 이 레코드에는 새 DTLSPlaintext.sequence\_number 값이 있습니다.

- 참고: DTLS 1.2에서는 재핸드셰이크\(즉, 재협상\)의 경우 message\_seq가 0으로 재설정되었습니다. 표면적으로 DTLS 1.2의 재핸드셰이크는 DTLS 1.3의 핸드셰이크 후 메시지 교환과 유사점을 공유합니다. 그러나 DTLS 1.3에서는 이전에 전송된 핸드셰이크 후 메시지와 새로 전송된 핸드셰이크 메시지의 재전송을 구별할 수 있도록 message\_seq가 재설정되지 않습니다.

DTLS 구현은 \(적어도 개념적으로는\) next\_receive\_seq 카운터를 유지합니다. 이 카운터는 초기에 0으로 설정됩니다. 핸드셰이크 메시지 수신 시 message\_seq 값이 next\_receive\_seq와 일치하면 next\_receive\_seq가 증가하고 메시지가 처리됩니다. 시퀀스 번호가 next\_receive\_seq보다 작으면 메시지를 버려야 합니다. 시퀀스 번호가 next\_receive\_seq보다 큰 경우 구현은 메시지를 대기열에 넣어야 하지만 폐기할 수 있습니다\(MAY\). \(이것은 단순한 공간/대역폭 절충입니다\).\(MUST, SHOULD\)

TLS 1.3 사양에서 더 이상 사용되지 않는 핸드셰이크 메시지 외에도 DTLS 1.3은 DTLS 1.0에서 원래 정의된 HelloVerifyRequest 메시지를 더 이상 사용하지 않습니다. DTLS 1.3 호환 구현은 반환 라우팅 가능성 검사를 실행하기 위해 HelloVerifyRequest를 사용해서는 안 됩니다\(MUST NOT\). 그러나 이중 스택 DTLS 1.2/DTLS 1.3 클라이언트는 DTLS 1.2 서버와 상호 작용할 준비가 되어 있어야 합니다.\(MUST NOT, MUST\)

---
### **5.3.  ClientHello Message**

DTLS 1.3 클라이언트에서 사용하는 ClientHello 형식은 아래와 같이 TLS 1.3 ClientHello 형식과 다릅니다.

```text
       uint16 ProtocolVersion;
       opaque Random[32];

       uint8 CipherSuite[2];    /* Cryptographic suite selector */

       struct {
           ProtocolVersion legacy_version = { 254,253 }; // DTLSv1.2
           Random random;
           opaque legacy_session_id<0..32>;
           opaque legacy_cookie<0..2^8-1>;                  // DTLS
           CipherSuite cipher_suites<2..2^16-2>;
           opaque legacy_compression_methods<1..2^8-1>;
           Extension extensions<8..2^16-1>;
       } ClientHello;
```

legacy\_version: 이전 버전의 DTLS에서 이 필드는 버전 협상에 사용되었으며 클라이언트에서 지원하는 가장 높은 버전 번호를 나타냅니다. 경험에 따르면 많은 서버가 버전 협상을 제대로 구현하지 않아 서버가 지원하는 것보다 높은 버전 번호로 허용되는 ClientHello를 거부하는 "버전 불내성"이 발생합니다. DTLS 1.3에서 클라이언트는 "supported\_versions" 확장\(\[TLS13\]의 섹션 4.2.1 참조\)에 버전 기본 설정을 표시하고 legacy\_version 필드는 DTLS 1.2의 버전 번호인 {254, 253}로 설정해야 합니다\(MUST\). DTLS 1.0 및 DTLS 1.2에 대한 supported\_versions 항목은 0xfeff 및 0xfefd입니다\(와이어 버전 일치\). 값 0xfefc는 DTLS 1.3을 나타내는 데 사용됩니다.\(MUST\)

무작위: TLS 1.2 및 TLS 1.1 이하가 협상될 때 \[TLS13\]의 섹션 4.1.3에 설명된 다운그레이드 센티널이 각각 DTLS 1.2 및 DTLS 1.0에 적용된다는 점을 제외하면 TLS 1.3과 동일합니다.

legacy\_session\_id: 버전 1.3 이전의 TLS 및 DTLS 버전은 버전 1.3에서 사전 공유 키\(PSK\)와 병합된 "세션 재개" 기능을 지원했습니다. DTLS 1.3 이전 서버에 의해 설정된 캐시된 세션 ID가 있는 클라이언트는 이 필드를 해당 값으로 설정해야 합니다\(SHOULD\). 그렇지 않으면 길이가 0인 벡터\(즉, 값이 0인 단일 바이트 길이 필드\)로 설정되어야 합니다.\(SHOULD, MUST\)

legacy\_cookie: DTLS 1.3 전용 클라이언트는 반드시 legacy\_cookie 필드를 0 길이로 설정해야 합니다. 이 필드의 다른 값과 함께 DTLS 1.3 ClientHello가 수신되면 서버는 "illegal\_parameter" 경고와 함께 핸드셰이크를 중단해야 합니다.\(MUST, MUST\)

cipher\_suites: TLS 1.3과 동일; DTLS-OK=Y인 제품군만 사용할 수 있습니다.

legacy\_compression\_methods: TLS 1.3과 동일합니다.

확장: TLS 1.3과 동일합니다.

---
### **5.4.  ServerHello Message**

DTLS 1.3 ServerHello 메시지는 legacy\_version 필드가 DTLS 1.2를 나타내는 0xfefd로 설정된다는 점을 제외하면 TLS 1.3 ServerHello 메시지와 동일합니다.

---
### **5.5.  Handshake Message Fragmentation and Reassembly**

섹션 4.3에서 설명한 것처럼 하나 이상의 핸드셰이크 메시지가 단일 데이터그램으로 전달될 수 있습니다. 그러나 핸드셰이크 메시지는 잠재적으로 기본 데이터그램 전송에서 허용하는 크기보다 클 수 있습니다. DTLS는 여러 레코드에서 핸드셰이크 메시지를 조각화하는 메커니즘을 제공하며 각 레코드는 별도의 데이터그램으로 전송될 수 있으므로 IP 조각화를 방지합니다.

핸드셰이크 메시지를 전송할 때 발신자는 메시지를 일련의 N개의 연속 데이터 범위로 나눕니다. 범위는 겹치지 않아야 합니다. 그런 다음 발신자는 모두 원본 DTLSHandshake 메시지와 동일한 message\_seq 값을 사용하여 N개의 DTLSHandshake 메시지를 생성합니다. 각각의 새 메시지는 fragment\_offset\(이전 조각에 포함된 바이트 수\) 및 fragment\_length\(이 조각의 길이\)로 레이블이 지정됩니다. 모든 메시지의 길이 필드는 원본 메시지의 길이 필드와 동일합니다. 단편화되지 않은 메시지는 fragment\_offset=0 및 fragment\_length=length인 퇴화 사례입니다. 레코드에 배치된 각 핸드셰이크 메시지 조각은 단일 UDP 데이터그램으로 전달되어야 합니다.\(MUST NOT, MUST\)

DTLS 구현이 다음 예상 핸드셰이크 메시지 시퀀스 번호에 해당하는 핸드셰이크 메시지 조각을 수신하면 전체 핸드셰이크 메시지를 가질 때까지 버퍼링하거나 메시지의 순서 있는 부분을 처리하여 이를 처리해야 합니다. 기록은 완전한 TLS 핸드셰이크 메시지\(필요에 따라 재구성됨\)로 구성됩니다. Handshake 구조를 생성하려면 message\_seq, fragment\_offset 및 fragment\_length 필드를 제거해야 합니다.\(MUST\)

DTLS 구현은 겹치는 조각 범위를 처리할 수 있어야 합니다\(MUST\). 이를 통해 발신자는 PMTU 추정치가 변경될 경우 더 작은 조각 크기로 핸드셰이크 메시지를 재전송할 수 있습니다. 발신자는 재전송 시 핸드셰이크 메시지 바이트를 변경하면 안 됩니다\(MUST NOT\). 수신자는 재전송된 바이트가 동일한지 확인하고 바이트 값이 변경되면 "illegal\_parameter" 경고와 함께 핸드셰이크를 중단해야 합니다\(SHOULD\).\(MUST, MUST NOT, SHOULD\)

TLS와 마찬가지로 공간이 있고 동일한 항공편의 일부인 경우 여러 핸드셰이크 메시지가 동일한 DTLS 레코드에 배치될 수 있습니다. 따라서 두 개의 DTLS 핸드셰이크 메시지를 동일한 데이터그램에 압축하는 두 가지 허용 가능한 방법이 있습니다. 동일한 레코드 또는 별도의 레코드입니다.

---
### **5.6.  EndOfEarlyData Message**

DTLS 1.3 핸드셰이크에는 TLS 1.3 핸드셰이크와 한 가지 중요한 차이점이 있습니다. EndOfEarlyData 메시지가 회선과 핸드셰이크 기록에서 모두 생략됩니다. DTLS 레코드에는 에포크가 있기 때문에 조기 데이터가 완료되는 시기를 확인하는 데 EndOfEarlyData가 필요하지 않으며 DTLS가 손실되기 때문에 공격자는 EndOfEarlyData가 TLS에서 방지하는 삭제 공격을 사소하게 탑재할 수 있습니다. 서버는 일단 에포크 3의 레코드를 처리할 수 있게 되면 에포크 1의 레코드를 무기한 수락해서는 안 됩니다. 왕복 시간. 서버는 첫 번째 epoch 3 데이터가 도착한 후 epoch 1 키를 버리거나 짧은 기간 동안 epoch 1 데이터를 처리하기 위해 키를 유지할 수 있습니다. \(각 시대의 정의는 섹션 6.1을 참조하십시오.\)\(SHOULD NOT\)

---
### **5.7.  DTLS Handshake Flights**

DTLS 핸드셰이크 메시지는 일련의 메시지 플라이트로 그룹화됩니다. 비행은 한 피어의 핸드셰이크 메시지 전송으로 시작하여 다른 피어의 예상 응답으로 끝납니다. 표 1에는 항공편을 구성하는 메시지 조합의 전체 목록이 포함되어 있습니다.

```text
      +======+========+========+===================================+
      | Note | Client | Server | Handshake Messages                |
      +======+========+========+===================================+
      |      | x      |        | ClientHello                       |
      +------+--------+--------+-----------------------------------+
      |      |        | x      | HelloRetryRequest                 |
      +------+--------+--------+-----------------------------------+
      |      |        | x      | ServerHello, EncryptedExtensions, |
      |      |        |        | CertificateRequest, Certificate,  |
      |      |        |        | CertificateVerify, Finished       |
      +------+--------+--------+-----------------------------------+
      | 1    | x      |        | Certificate, CertificateVerify,   |
      |      |        |        | Finished                          |
      +------+--------+--------+-----------------------------------+
      | 1    |        | x      | NewSessionTicket                  |
      +------+--------+--------+-----------------------------------+

              Table 1: Flight Handshake Message Combinations

   Remarks:
```

\* 표 1은 선택적 메시지를 강조 표시하지 않습니다.

\* 참고 \(1\) 관련: 클라이언트의 최종 비행 또는 NewSessionTicket 메시지의 경우와 같이 예상되는 응답 없이 핸드셰이크 비행이 전송되면 ACK 메시지로 비행을 승인해야 합니다.

다음은 비행 개념을 설명하는 몇 가지 예시 메시지 교환입니다. \[TLS13\]의 표기 규칙이 사용됩니다.

```text
   Client                                            Server

                                                              +--------+
    ClientHello                                               | Flight |
                          -------->                           +--------+

                                                              +--------+
                          <--------        HelloRetryRequest  | Flight |
                                            + cookie          +--------+

                                                              +--------+
   ClientHello                                                | Flight |
    + cookie              -------->                           +--------+

                                                 ServerHello
                                       {EncryptedExtensions}  +--------+
                                       {CertificateRequest*}  | Flight |
                                              {Certificate*}  +--------+
                                        {CertificateVerify*}
                                                  {Finished}
                          <--------      [Application Data*]

    {Certificate*}                                            +--------+
    {CertificateVerify*}                                      | Flight |
    {Finished}            -------->                           +--------+
    [Application Data]
                                                              +--------+
                          <--------                    [ACK]  | Flight |
                                         [Application Data*]  +--------+

    [Application Data]    <------->      [Application Data]

      Figure 7: Message Flights for a Full DTLS Handshake (with Cookie
                                 Exchange)

    ClientHello                                              +--------+
     + pre_shared_key                                        | Flight |
     + psk_key_exchange_modes                                +--------+
     + key_share*         -------->

                                                ServerHello
                                           + pre_shared_key  +--------+
                                               + key_share*  | Flight |
                                      {EncryptedExtensions}  +--------+
                          <--------              {Finished}
                                        [Application Data*]
                                                             +--------+
    {Finished}            -------->                          | Flight |
    [Application Data*]                                      +--------+

                                                             +--------+
                          <--------                   [ACK]  | Flight |
                                        [Application Data*]  +--------+

    [Application Data]    <------->      [Application Data]

         Figure 8: Message Flights for Resumption and PSK Handshake
                         (without Cookie Exchange)

   Client                                            Server

    ClientHello
     + early_data
     + psk_key_exchange_modes                                +--------+
     + key_share*                                            | Flight |
     + pre_shared_key                                        +--------+
    (Application Data*)     -------->

                                                ServerHello
                                           + pre_shared_key
                                               + key_share*  +--------+
                                      {EncryptedExtensions}  | Flight |
                                                 {Finished}  +--------+
                          <--------     [Application Data*]

                                                             +--------+
    {Finished}            -------->                          | Flight |
    [Application Data*]                                      +--------+

                                                             +--------+
                          <--------                   [ACK]  | Flight |
                                        [Application Data*]  +--------+

    [Application Data]    <------->      [Application Data]
```

- 그림 9: Zero-RTT 핸드셰이크를 위한 메시지 플라이트

```text
   Client                                            Server

                                                             +--------+
                          <--------       [NewSessionTicket] | Flight |
                                                             +--------+

                                                             +--------+
   [ACK]                  -------->                          | Flight |
                                                             +--------+

        Figure 10: Message Flights for the NewSessionTicket Message
```

KeyUpdate, NewConnectionId 및 RequestConnectionId는 NewSessionTicket과 유사한 패턴을 따릅니다. 한 쪽에서 단일 메시지를 보내고 다른 쪽에서는 ACK를 보냅니다.

---
### **5.8.  Timeout and Retransmission**
---
#### **5.8.1.  State Machine**

DTLS는 그림 11에 표시된 상태 머신과 함께 간단한 시간 초과 및 재전송 체계를 사용합니다.

```text
                                +-----------+
                                | PREPARING |
                   +----------> |           |
                   |            |           |
                   |            +-----------+
                   |                  |
                   |                  | Buffer next flight
                   |                  |
                   |                 \|/
                   |            +-----------+
                   |            |           |
                   |            |  SENDING  |<------------------+
                   |            |           |                   |
                   |            +-----------+                   |
           Receive |                  |                         |
              next |                  | Send flight or partial  |
            flight |                  | flight                  |
                   |                  |                         |
                   |                  | Set retransmit timer    |
                   |                 \|/                        |
                   |            +-----------+                   |
                   |            |           |                   |
                   +------------|  WAITING  |-------------------+
                   |     +----->|           |   Timer expires   |
                   |     |      +-----------+                   |
                   |     |          |  |   |                    |
                   |     |          |  |   |                    |
                   |     +----------+  |   +--------------------+
                   |    Receive record |   Read retransmit or ACK
           Receive |  (Maybe Send ACK) |
              last |                   |
            flight |                   | Receive ACK
                   |                   | for last flight
                  \|/                  |
                                       |
               +-----------+           |
               |           | <---------+
               | FINISHED  |
               |           |
               +-----------+
                   |  /|\
                   |   |
                   |   |
                   +---+

             Server read retransmit
                 Retransmit ACK

          Figure 11: DTLS Timeout and Retransmission State Machine
```

상태 시스템에는 PREPARING, SENDING, WAITING 및 FINISHED의 네 가지 기본 상태가 있습니다.

PREPARING 상태에서 구현은 다음 메시지 비행을 준비하는 데 필요한 모든 계산을 수행합니다. 그런 다음 전송을 위해 버퍼링하고\(먼저 전송 버퍼 비우기\) SENDING 상태로 들어갑니다.

SENDING 상태에서 구현은 버퍼링된 메시지 플라이트를 전송합니다. 구현이 피어로부터 하나 이상의 ACK\(섹션 7 참조\)를 수신한 경우 이미 확인된 메시지 또는 메시지 조각을 생략해야 합니다\(SHOULD\). 메시지가 전송되면 구현은 재전송 타이머를 설정하고 WAITING 상태로 들어갑니다.\(SHOULD\)

WAITING 상태를 종료하는 네 가지 방법이 있습니다.

1. 재전송 타이머 만료: 구현이 SENDING 상태로 전환되고, 여기서 비행을 재전송하고, 재전송 타이머를 조정 및 재준비하고\(섹션 5.8.2 참조\), WAITING 상태로 돌아갑니다.

2. 구현은 피어로부터 ACK를 읽습니다. 부분 비행에 대한 ACK를 수신하면\(섹션 7.1에서 언급한 대로\) 구현은 SENDING 상태로 전환되어 비행의 승인되지 않은 부분을 재전송하고 조정하고 다시 준비합니다. 재전송 타이머를 종료하고 WAITING 상태로 돌아갑니다. 전체 비행에 대한 ACK를 수신하면 구현은 모든 재전송을 취소하고 WAITING 상태를 유지하거나 ACK가 최종 비행에 대한 것인 경우 FINISHED로 전환합니다.

3. 해당 플라이트에 대한 응답으로 보낸 메시지 중 어느 것도 확인되지 않은 경우 구현은 피어에서 재전송된 플라이트를 읽습니다. 구현은 SENDING 상태로 전환되고 플라이트를 재전송하고 재전송 타이머를 조정 및 재준비합니다. , WAITING 상태로 돌아갑니다. 여기서 근거는 중복 메시지 수신이 피어에서 타이머 만료의 결과일 가능성이 있으므로 이전 비행의 일부가 손실되었음을 시사한다는 것입니다.

4. 구현은 다음 메시지 플라이트의 일부 또는 전부를 수신합니다. 이것이 메시지의 최종 플라이트인 경우 구현은 FINISHED로 전환됩니다. 구현에서 새 항공편을 보내야 하는 경우 PREPARING 상태로 전환됩니다. 섹션 7.1에 설명된 대로 부분 읽기\(부분 메시지 또는 플라이트의 일부 메시지만\)는 ACK를 전송하도록 구현을 트리거할 수도 있습니다.

DTLS 클라이언트는 첫 번째 메시지\(ClientHello\)를 보내기 때문에 PREPARING 상태에서 시작합니다. DTLS 서버는 WAITING 상태에서 시작하지만 버퍼가 비어 있고 재전송 타이머가 없습니다.

또한 \[RFC0793\]에 대해 정의된 기본 MSL의 최소 2배에 대해 FINISHED 상태일 때 서버는 ACK 재전송으로 클라이언트의 최종 항공편 재전송에 응답해야 합니다.\(MUST\)

패킷 손실로 인해 다른 쪽에서 첫 번째 완료 메시지를 받지 못한 경우에도 한 쪽에서 응용 프로그램 데이터를 보낼 수 있습니다. 구현은 피어로부터 Finished 메시지를 수신할 때까지 Epoch 3 이상의 모든 애플리케이션 데이터 레코드를 버리거나 버퍼링해야 합니다. 구현은 재정렬 또는 패킷 손실의 증거로 해당 Finished 메시지를 수신하기 전에 새로운 에포크로 애플리케이션 데이터 수신을 처리하고 재전송 타이머를 단축하여 최종 비행을 즉시 재전송할 수 있습니다.\(MUST, MAY\)

---
#### **5.8.2.  Timer Values**

타이머 설정의 구성은 구현에 따라 다르며 특정 배포 환경에서는 타이머 값 조정이 필요합니다. 타이머를 잘못 처리하면 심각한 혼잡 문제가 발생할 수 있습니다. 예를 들어 DTLS의 많은 인스턴스가 일찍 시간 초과되어 혼잡한 링크에서 너무 빨리 재전송하는 경우입니다.

구현에 왕복 시간에 대한 배포 특정 및/또는 외부 정보가 없는 한 구현은 초기 타이머 값 1000ms를 사용하고 재전송할 때마다 값을 두 배로 최대 60초\(RFC 6298에 지정된 최대값\)까지 사용해야 합니다\(SHOULD\). \[RFC6298\]\). 응용 프로그램별 프로필은 더 짧거나 더 긴 타이머 값을 권장할 수 있습니다\(MAY\). 예를 들어:\(SHOULD, MAY\)

\* 일부 사물 인터넷\(IoT\) 네트워크에서 사용되는 저전력 다중 홉 메시 시나리오와 같은 특정 배포 환경에 대한 프로필은 더 긴 시간 제한을 지정할 수 있습니다\(MAY\). 이러한 DTLS 1.3 IoT 프로파일에 대한 자세한 내용은 \[IOT-PROFILE\]을 참조하십시오.\(MAY\)

\* 실시간 프로토콜은 더 짧은 시간 초과를 지정할 수 있습니다. 그것은

- DTLS-SRTP \[RFC5764\]의 경우 기본 시간 제한인 400ms를 사용할 것을 권장합니다. 단방향 대기 시간이 200ms를 초과하면 고객 경험이 저하되므로 실시간 배포에서는 대기 시간이 길어질 가능성이 적습니다.\(MAY, SHOULD\)

RTT에 대한 외부 정보\(예: ICE \[RFC8445\] 핸드셰이크 또는 동일한 서버에 대한 이전 연결\)가 있는 설정에서 구현은 RTT 추정치의 1.5배를 재전송 타이머로 사용해야 합니다\(SHOULD\).\(SHOULD\)

구현은 재전송할 필요 없이 메시지가 전송되고 확인될 때까지 현재 타이머 값을 유지해야 합니다\(SHOULD\). 이때 값은 해당 메시지에 대해 측정된 왕복 시간의 1.5배로 조정되어야 합니다\(SHOULD\). 현재 타이머 값의 10배 이상인 오랜 유휴 기간 후에 구현은 타이머를 초기 값으로 재설정할 수 있습니다\(MAY\).\(SHOULD, MAY\)

재전송은 데이터 흐름이 아닌 핸드셰이크를 위한 것이기 때문에 짧은 시간 제한의 혼잡에 대한 영향은 TCP 또는 QUIC와 같은 일반 프로토콜보다 적습니다. 보다 단순한 "시간 초과 시 모든 것을 재전송" 접근 방식을 사용하는 DTLS 1.2의 경험은 실제로 심각한 혼잡 문제를 나타내지 않았습니다.

---
#### **5.8.3.  Large Flight Sizes**

DTLS에는 내장된 혼잡 제어 또는 속도 제어가 없습니다. 일반적으로 이것은 메시지가 작은 경향이 있기 때문에 문제가 되지 않습니다. 그러나 원칙적으로 일부 메시지\(특히 인증서\)는 상당히 클 수 있습니다. 대규모 비행의 모든 ​​메시지가 한 번에 전송되면 네트워크 정체가 발생할 수 있습니다. 더 나은 전략은 비행의 일부만 내보내고 메시지가 확인되면 더 많이 보내는 것입니다. 인증서 메시지의 크기를 줄이기 위해 몇 가지 확장이 표준화되었습니다. 예를 들어 "cached\_info" 확장\[RFC7924\]; 인증서 압축 \[RFC8879\]; \[RFC6066\]은 DTLS 클라이언트가 클라이언트 인증서 대신 일련의 URL\(Uniform Resource Locator\)을 보낼 수 있도록 하는 "client\_certificate\_url" 확장을 정의합니다.

DTLS 스택은 단일 전송에서 10개 이상의 레코드를 보내면 안 됩니다\(SHOULD NOT\).\(SHOULD NOT\)

---
#### **5.8.4.  State Machine Duplication for Post-Handshake Messages**

DTLS 1.3은 다음 범주의 핸드셰이크 후 메시지를 사용합니다.

```text
   1.  NewSessionTicket

   2.  KeyUpdate

   3.  NewConnectionId

   4.  RequestConnectionId

   5.  Post-handshake client authentication
```

각 카테고리의 메시지는 독립적으로 전송될 수 있으며, 독립된 상태 머신을 통해 신뢰성이 확립되며, 각 머신은 섹션 5.8.1에 설명된 대로 동작합니다. 예를 들어 서버가 NewSessionTicket과 CertificateRequest 메시지를 보내면 두 개의 독립적인 상태 머신이 생성됩니다.

이전 전송을 완료하지 않고 지정된 범주의 메시지를 여러 번 보내는 것은 일부 범주에서는 허용되지만 다른 범주에서는 허용되지 않습니다. 특히, 서버는 먼저 이전 NewSessionTicket 메시지에 대한 ACK를 기다리지 않고 한 번에 여러 NewSessionTicket 메시지를 보낼 수 있습니다. 마찬가지로 서버는 이전 클라이언트 인증 요청을 완료하지 않고 한 번에 여러 CertificateRequest 메시지를 보낼 수 있습니다. 반대로 구현은 동일한 유형의 이전 메시지가 아직 확인되지 않은 경우 KeyUpdate, NewConnectionId 또는 RequestConnectionId 메시지를 보내면 안 됩니다\(MUST NOT\).\(MAY, MAY, MUST NOT\)

- 참고: 양방향 핸드셰이크 메시지를 포함하는 핸드셰이크 후 클라이언트 인증을 제외하고, 핸드셰이크 후 메시지는 단일 전달이며 보낸 사람 측의 해당 상태 시스템은 ACK를 기다리고 원본 메시지를 재전송하는 것으로 축소됩니다. 특히 RequestConnectionId 메시지는 수신자가 응답으로 NewConnectionId 메시지를 보내도록 강제하지 않으므로 두 메시지는 독립적으로 처리됩니다.

여러 상태 시스템을 생성하고 올바르게 업데이트하려면 핸드셰이크 논리에서 상태 시스템 계층으로의 피드백이 필요합니다. 즉, 어떤 메시지가 어떤 상태 시스템에 속하는지 나타냅니다. 예를 들어 서버가 여러 CertificateRequest 메시지를 보내고 응답으로 인증서 메시지를 받는 경우 해당 상태 시스템은 certificate\_request\_context 필드를 검사한 후에만 확인할 수 있습니다. 마찬가지로 단일 CertificateRequest를 보내고 응답으로 NewConnectionId 메시지를 받는 서버는 핸드셰이크 메시지 유형을 검사한 후에 NewConnectionId 메시지가 독립적인 상태 시스템을 통해 처리되어야 한다고 결정할 수 있습니다.

---
### **5.9.  Cryptographic Label Prefix**

\[TLS13\]의 섹션 7.1은 HKDF-Expand-Label이 "tls13"의 레이블 접두사를 사용한다고 지정합니다. DTLS 1.3의 경우 해당 레이블은 "dtls13"이어야 합니다. 이렇게 하면 DTLS 1.3과 TLS 1.3 간의 키 분리가 보장됩니다. 후행 공백이 없음에 유의하십시오. 이것은 "DTLS"가 "TLS"보다 한 문자 더 길기 때문에 하나의 해시 반복 내에서 전체 레이블 크기를 유지하기 위해 필요합니다.\(MUST\)

---
### **5.10.  Alert Messages**

경고 메시지는 핸드셰이크 컨텍스트에서 발생하는 경우에도 전혀 재전송되지 않습니다. 그러나 일반적으로 경고를 발행하는 DTLS 구현은 잘못된 레코드가 다시 수신되면\(예: 재전송된 핸드셰이크 메시지로\) 새 경고 메시지를 생성해야 합니다\(SHOULD\). 구현은 피어가 지속적으로 잘못된 메시지를 보내는 시기를 감지하고 그러한 오작동이 감지된 후 로컬 연결 상태를 종료해야 합니다. 경고는 안정적으로 전송되지 않습니다. 구현은 오류 또는 연결 종료를 알리기 위해 경고 수신에 의존해서는 안 됩니다\(SHOULD NOT\).\(SHOULD, SHOULD, SHOULD NOT\)

유효하게 수신된 종료 경고 이후의 에포크/시퀀스 번호 쌍으로 수신된 모든 데이터는 무시해야 합니다. 참고: 이는 에포크 및 시퀀스 번호가 아닌 수신 순서에 따라 달라지는 TLS 1.3의 변경 사항입니다.\(MUST\)

---
### **5.11.  Establishing New Associations with Existing Parameters**

DTLS 클라이언트-서버 쌍이 동일한 호스트/포트 4중주에서 반복되는 연결이 발생하는 방식으로 구성된 경우 클라이언트가 자동으로 하나의 연결을 포기한 다음 동일한 매개변수로 다른 연결을 시작할 수 있습니다\(예: 재부팅\). 이는 서버에 epoch=0인 새 핸드셰이크로 표시됩니다. 서버가 주어진 호스트/포트 4중주에 기존 연결이 있다고 믿고 epoch=0 ClientHello를 수신하는 경우 새로운 핸드셰이크를 진행해야 하지만 클라이언트가 완료를 통해 도달 가능성을 입증할 때까지 기존 연결을 파괴해서는 안 됩니다. 쿠키 교환 또는 확인 가능한 완료 메시지 전달을 포함하여 완전한 악수를 완료함으로써. 올바른 Finished 메시지를 수신한 후 서버는 에포크가 겹치는 두 개의 유효한 연결 간의 혼동을 피하기 위해 이전 연결을 포기해야 합니다. 도달 가능성 요구 사항은 오프 경로/맹인 공격자가 단순히 위조된 ClientHellos를 전송하여 연결을 파괴하는 것을 방지합니다.\(MUST NOT, MUST\)

- 참고: 주어진 기록이 어떤 연관성에 속해 있는지 구별하는 것이 항상 가능한 것은 아닙니다. 예를 들어 클라이언트가 핸드셰이크를 수행하고 연결을 포기한 다음 즉시 새 핸드셰이크를 시작하는 경우 지정된 보호 레코드가 어떤 연결에 대한 것인지 알 수 없습니다. 이러한 경우 구현에서는 5-튜플 기반 모호성을 피하기 위해 CID를 사용할 수 있지만 시험 암호 해독이 필요할 수 있습니다.

---
## **6.  Example of Handshake with Timeout and Retransmission**

다음은 손실된 패킷 및 재전송이 포함된 핸드셰이크의 예입니다. 레코드 2에서 찾은 메시지를 암호화하거나 해독하는 데 필요한 Epoch 2 키를 설정하는 데 필요한 레코드 0의 메시지를 처리한 후에만 서버에서 보낸 레코드 2를 확인할 수 있기 때문에 클라이언트는 빈 ACK 메시지를 보냅니다. 섹션 7 이 상호 작용에 필요한 배경 정보를 제공합니다. 참고: 간단히 하기 위해 이 다이어그램에서 레코드 번호를 재설정하지 않으므로 "레코드 1"은 실제로 "에포크 2, 레코드 0" 등입니다.

```text
   Client                                                Server
   ------                                                ------

    Record 0                  -------->
    ClientHello
    (message_seq=0)

                                X<-----                 Record 0
                                (lost)               ServerHello
                                                 (message_seq=0)
                                                        Record 1
                                             EncryptedExtensions
                                                 (message_seq=1)
                                                     Certificate
                                                 (message_seq=2)

                              <--------                 Record 2
                                               CertificateVerify
                                                 (message_seq=3)
                                                        Finished
                                                 (message_seq=4)

    Record 1                  -------->
    ACK []

                              <--------                 Record 3
                                                     ServerHello
                                                 (message_seq=0)
                                             EncryptedExtensions
                                                 (message_seq=1)
                                                     Certificate
                                                 (message_seq=2)

                              <--------                 Record 4
                                               CertificateVerify
                                                 (message_seq=3)
                                                        Finished
                                                 (message_seq=4)

    Record 2                  -------->
    Certificate
    (message_seq=1)
    CertificateVerify
    (message_seq=2)
    Finished
    (message_seq=3)

                              <--------               Record 5
                                                       ACK [2]

         Figure 12: Example DTLS Exchange Illustrating Message Loss
```

---
### **6.1.  Epoch Values and Rekeying**

DTLS 메시지 수신자는 들어오는 메시지를 처리하기 위해 올바른 키 자료를 선택해야 합니다. 메시지 손실 및 재정렬 가능성이 있으므로 레코드 페이로드를 보호하기 위해 어떤 암호 상태가 사용되었는지 확인하려면 식별자가 필요합니다. epoch 값은 DTLS에서 이 역할을 수행합니다. TLS 1.3 정의 키 파생 단계\(\[TLS13\]의 섹션 7 참조\) 외에도 발신자는 연결 수명 동안 언제든지 키를 다시 입력하기를 원할 수 있습니다. 따라서 보내는 암호화 키를 업데이트하고 있음을 나타내야 합니다.

이 버전의 DTLS는 올바른 암호 상태를 식별할 수 있도록 프로토콜 교환의 메시지에 전용 에포크 값을 할당합니다.

\* Epoch 값\(0\)은 암호화되지 않은 메시지에 사용됩니다. DTLS에는 ClientHello, ServerHello 및 HelloRetryRequest라는 세 가지 암호화되지 않은 메시지가 있습니다.

\* Epoch 값\(1\)은 client\_early\_traffic\_secret에서 파생된 키를 사용하여 보호되는 메시지에 사용됩니다. 클라이언트가 초기 데이터를 제공하지 않으면 이 에포크를 건너뜁니다.

\* Epoch 값\(2\)은 \[sender\]\_handshake\_traffic\_secret에서 파생된 키를 사용하여 보호되는 메시지에 사용됩니다. EncryptedExtensions, CertificateRequest, Certificate, CertificateVerify 및 Finished와 같은 초기 핸드셰이크 중에 전송된 메시지가 이 범주에 속합니다. 그러나 사후 핸드셰이크 메시지는 적절한 애플리케이션 트래픽 키로 보호되며 이 범주에 포함되지 않습니다.

\* Epoch 값\(3\)은 초기 \[sender\]\_application\_traffic\_secret\_0에서 파생된 키를 사용하여 보호되는 페이로드에 사용됩니다. 여기에는 핸드셰이크 후 메시지\(예: NewSessionTicket 메시지\)와 같은 핸드셰이크 메시지가 포함될 수 있습니다.

\* Epoch 값\(4 \~ 2^64-1\)은 \[sender\]\_application\_traffic\_secret\_N\(N\>0\)의 키를 사용하여 보호되는 페이로드에 사용됩니다.

이러한 예약된 에포크 값을 사용하여 수신자는 메시지를 암호화하고 무결성을 보호하는 데 사용된 암호 상태를 알 수 있습니다. 해당 암호 상태를 확인할 수 없는 epoch 값이 있는 레코드를 수신하는 구현은 이를 보호 해제에 실패한 레코드로 처리해야 합니다\(SHOULD\).\(SHOULD\)

epoch 값은 래핑되지 않습니다. DTLS 구현이 epoch 값을 래핑해야 하는 경우 연결을 종료해야 합니다.\(MUST\)

트래픽 키 계산은 \[TLS13\]의 섹션 7.3에 설명되어 있습니다.

그림 13은 예시 DTLS 핸드셰이크의 에포크 값을 보여줍니다.

```text
   Client                                             Server
   ------                                             ------

    Record 0
    ClientHello
    (epoch=0)
                               -------->
                                                        Record 0
                               <--------       HelloRetryRequest
                                                       (epoch=0)
    Record 1
    ClientHello                -------->
    (epoch=0)
                                                        Record 1
                               <--------             ServerHello
                                                       (epoch=0)
                                           {EncryptedExtensions}
                                                       (epoch=2)
                                                   {Certificate}
                                                       (epoch=2)
                                             {CertificateVerify}
                                                       (epoch=2)
                                                      {Finished}
                                                       (epoch=2)
    Record 2
    {Certificate}              -------->
    (epoch=2)
    {CertificateVerify}
    (epoch=2)
    {Finished}
    (epoch=2)
                                                        Record 2
                               <--------                   [ACK]
                                                       (epoch=3)
    Record 3
    [Application Data]         -------->
    (epoch=3)
                                                        Record 3
                               <--------      [Application Data]
                                                       (epoch=3)

                            Some time later ...
                    (Post-Handshake Message Exchange)
                                                        Record 4
                               <--------      [NewSessionTicket]
                                                       (epoch=3)
    Record 4
    [ACK]                      -------->
    (epoch=3)

                            Some time later ...
                              (Rekeying)
                                                        Record 5
                               <--------      [Application Data]
                                                       (epoch=4)
    Record 5
    [Application Data]         -------->
    (epoch=4)

          Figure 13: Example DTLS Exchange with Epoch Information
```

---
## **7.  ACK Message**

ACK 메시지는 엔드포인트에서 다른 쪽에서 수신하고 처리한 핸드셰이크 레코드를 나타내는 데 사용됩니다. ACK는 핸드셰이크 메시지가 아니라 코드 포인트가 26인 별도의 콘텐츠 유형입니다. 이렇게 하면 ACK가 핸드셰이크 기록에 추가되는 것을 방지할 수 있습니다. ACK는 여전히 핸드셰이크 레코드와 동일한 UDP 데이터그램으로 보낼 수 있습니다.

```text
       struct {
           RecordNumber record_numbers<0..2^16-1>;
       } ACK;
```

record\_numbers: 엔드포인트가 수신하고 처리하거나 버퍼링한 현재 항공편의 핸드셰이크 메시지를 포함하는 레코드 목록\(숫자 증가 순서\).

구현은 처리 또는 버퍼링되지 않은 핸드셰이크 메시지 또는 조각을 포함하는 레코드를 확인해서는 안 됩니다\(MUST NOT\). 그렇지 않으면 교착 상태가 발생할 수 있습니다. 예를 들어, 구현은 다음에 예상되는 메시지가 아니기 때문에 폐기하는 핸드셰이크 메시지에 대한 ACK를 보내면 안 됩니다\(MUST NOT\).\(MUST NOT, MUST NOT\)

핸드셰이크 동안 ACK는 현재 미해결 플라이트만 처리합니다\(DTLS는 일반적으로 잠금 단계 프로토콜이기 때문에 가능함\). 특히 핸드셰이크 비행에서 메시지를 수신하면 이전 비행의 모든 ​​메시지를 묵시적으로 확인합니다. 따라서 ClientHello와 클라이언트 인증서가 서로 다른 비행에 있기 때문에 서버의 ACK는 ClientHello와 클라이언트의 인증서 메시지를 모두 포함하지 않습니다. 구현은 다음 비행의 시작을 수신할 때 ACK 목록을 지워 이를 수행할 수 있습니다.

사후 핸드셰이크 메시지의 경우 ACK는 수신 및 처리된 각 핸드셰이크 레코드\(잠재적으로 약간의 지연이 있을 수 있음\)에 대해 한 번 전송되어야 하며 둘 이상의 비행을 포함할 수 있습니다\(MAY\). 여기에는 이전 사본을 받았기 때문에 폐기된 메시지가 포함된 레코드가 포함됩니다.\(SHOULD\)

핸드셰이크 동안 ACK 레코드는 확인 중인 레코드와 같거나 더 높은 에포크와 함께 전송되어야 합니다. 여러 에포크에 걸친 항공편을 처리할 때는 약간의 주의가 필요합니다. 예를 들어, 클라이언트가 ServerHello 및 인증서만 수신하고 단일 레코드에서 ACK를 원하는 경우 2보다 크거나 같은 epoch를 사용해야 하고 아직 아무 것도 보낼 수 없기 때문에 epoch 2에서 이를 수행해야 합니다. 더 큰 시대. 구현은 단순히 가장 높은 현재 전송 에포크를 사용해야 하며 일반적으로 사용 가능한 가장 높은 것입니다. 핸드셰이크 후 구현은 사용 가능한 가장 높은 전송 에포크를 사용해야 합니다.\(MUST, SHOULD, MUST\)

---
### **7.1.  Sending ACKs**

구현이 현재 들어오는 항공편의 수신 중단을 감지하면 지금까지 수신하고 처리한 해당 항공편의 메시지를 포함하는 ACK를 생성해야 합니다\(SHOULD\). 구현은 중단의 징후로 처리할 이벤트에 대해 약간의 재량권이 있지만 다음 두 가지 상황에서 ACK를 생성하는 것이 좋습니다.\(SHOULD, SHOULD\)

\* 다음 예상 메시지가 아니거나 현재 메시지의 다음 조각이 아니기 때문에 순서가 잘못된 메시지 또는 조각을 수신한 경우.

\* 비행의 일부를 수신하고 비행의 나머지 부분을 즉시 수신하지 않는 경우\(동일한 UDP 데이터그램에 있을 수 있음\). "즉시"는 정의하기 어렵습니다. 한 가지 방법은 비행 중 첫 번째 레코드가 수신될 때 현재 재전송 타이머 값의 1/4에 대한 타이머를 설정한 다음 해당 타이머가 만료되면 ACK를 보내는 것입니다. 참고: 여기서 1/4 값은 다소 임의적입니다. DTLS 핸드셰이크의 왕복 추정이 일반적으로 매우 대략적\(또는 기본값\)이라는 점을 감안할 때 모든 값은 근사치이며 과도한 ACK로 인한 재전송과 과도한 시간 초과로 인한 재전송 간의 경쟁으로 인해 본질적인 절충안이 있습니다. 기반 재전송. 비교 포인트로 QUIC의 손실 기반 복구 알고리즘\(\[RFC9002\], 섹션 6.1.2\)은 재전송 타이머의 약 1/3의 지연으로 작동합니다.

일반적으로 암시적으로 확인되지 않는 한 항공편은 반드시 확인되어야 합니다. 본 명세서에서, 다음 비행은 일반적으로 비행 직후에 다음 비행의 수신에 의해 암묵적으로 인정된다:\(MUST\)

1. 메인 핸드셰이크의 클라이언트 최종 플라이트 이외의 핸드셰이크 플라이트.

2. 서버의 포스트 핸드셰이크 CertificateRequest.

응답하는 항공편을 즉시 생성할 수 없는 경우가 아니면 이러한 항공편에 대해 ACK를 보내서는 안 됩니다\(SHOULD NOT\). 다른 모든 항공편은 확인되어야 합니다. 이 경우 구현은 응답 항공편을 통해 결국 암시적으로 승인되더라도 완전한 수신 항공편에 대한 명시적 ACK를 보낼 수 있습니다\(MAY\). 이것에 대한 주목할만한 예는 제한된 환경에서 클라이언트 인증의 경우입니다. 여기서 CertificateVerify 메시지를 생성하는 데 클라이언트에서 상당한 시간이 걸릴 수 있습니다. 구현은 각 항공편의 각 전송에 해당하는 기록을 승인하거나 가장 최근의 기록을 승인할 수 있습니다\(MAY\). 일반적으로 구현은 ACK 레코드에 들어갈 수 있는 만큼 수신된 패킷을 ACK해야 합니다. 이는 가장 완전한 정보를 제공하여 가짜 재전송 가능성을 줄이기 때문입니다. 공간이 제한된 경우 구현은 아직 승인되지 않은 레코드를 포함하는 것을 선호해야 합니다\(SHOULD\).\(SHOULD NOT, MUST, MAY, MAY, SHOULD\)

- 참고: 일부 핸드셰이크 후 메시지는 요청/응답 패턴을 따르지만 이것이 반드시 수신을 의미하는 것은 아닙니다. 예를 들어, request\_update가 "update\_requested"로 설정된 KeyUpdate에 대한 응답으로 전송된 KeyUpdate는 두 KeyUpdate 메시지가 이동 중에 교차했을 수 있기 때문에 이전 KeyUpdate 메시지를 암시적으로 승인하지 않습니다.

핸드셰이크 이외의 콘텐츠 유형 레코드 또는 보호 해제할 수 없는 레코드에 대해서는 ACK를 보내서는 안 됩니다.\(MUST NOT\)

경우에 따라 레코드 번호가 포함되지 않은 ACK를 보내야 할 수도 있습니다. 예를 들어 클라이언트는 ServerHello를 수신하기 전에 EncryptedExtensions 메시지를 수신할 수 있습니다. EncryptedExtensions를 해독할 수 없기 때문에 안전하게 확인할 수 없습니다\(손상될 수 있으므로\). 클라이언트가 ACK를 보내지 않으면 서버는 결국 첫 번째 비행을 재전송하지만 클라이언트와 서버 간의 실제 왕복 시간보다 훨씬 오래 걸릴 수 있습니다. 클라이언트가 빈 ACK를 보내도록 하면 이 프로세스가 단축됩니다.

---
### **7.2.  Receiving ACKs**

구현이 ACK를 수신하면 ACK되는 레코드에 전송된 메시지 또는 메시지 조각이 수신되었음을 기록하고 향후 재전송에서 생략해야 합니다. 확인된 항공편의 일부 메시지만 남기는 ACK를 수신하면 구현은 확인되지 않은 메시지 또는 조각을 재전송해야 합니다\(SHOULD\). 이를 위해서는 어떤 메시지가 어떤 레코드에 나타나는지 추적하기 위한 구현이 필요합니다. 플라이트의 모든 메시지가 승인되면 구현은 해당 플라이트의 모든 재전송을 취소해야 합니다. 구현은 레코드가 ACK에 나타나는 경우 확인된 것으로 레코드를 처리해야 합니다. 이것은 비행이 매우 크고 수신기가 이미 ACK된 레코드에 대한 확인을 생략해야 하는 경우에 가짜 재전송을 방지합니다. 위에서 언급한 바와 같이 주어진 항공편에 응답하는 모든 기록의 수신은 응답하는 전체 항공편에 대한 묵시적 승인으로 간주되어야 합니다.\(SHOULD, SHOULD, MUST, MUST, MUST\)

---
### **7.3.  Design Rationale**

ACK 메시지는 다음과 같은 두 가지 상황에서 사용됩니다.

\* 중단 또는 진행 부족의 징후가 있는 경우 그리고

\* 악수로 마지막 항공편을 완전히 수령했음을 나타냅니다.

첫 번째 경우 ACK 메시지의 사용은 선택 사항입니다. 피어가 어떤 경우에도 재전송하므로 ACK는 이전 버전의 DTLS에서 시간 초과 기반 전체 비행 재전송과 달리 선택적 또는 조기 재전송만 허용하기 때문입니다. DTLS 1.3이 저전력, 장거리 무선 네트워크 및 저전력 메시 네트워크와 같은 손실 네트워크가 있는 배포에 사용되는 경우 ACK를 사용하는 것이 좋습니다.

두 번째 경우에 대한 ACK 사용은 프로토콜의 적절한 기능을 위해 필수입니다. 예를 들어 그림 13에서 클라이언트가 보낸 ACK 메시지는 레코드 4\(NewSessionTicket 메시지 포함\)의 수신 및 처리를 확인하고 전송되지 않은 경우 서버는 최대 재전송 횟수에 도달할 때까지 무한정 NewSessionTicket의 재전송을 계속합니다. .

---
## **8.  Key Updates**

TLS 1.3과 마찬가지로 DTLS 1.3 구현은 KeyUpdate 메시지를 전송하여 전송 키를 업데이트하고 있음을 나타냅니다. 내장된 응답이 없는 다른 핸드셰이크 메시지와 마찬가지로 KeyUpdates는 승인되어야 합니다. 에포크 재구성\(섹션 4.2.2\)을 용이하게 하기 위해 구현은 이전 KeyUpdate가 확인될 때까지 새 키가 있는 레코드를 보내거나 새 KeyUpdate를 보내면 안 됩니다.\(MUST, MUST NOT\)

손실 및/또는 재정렬로 인해 DTLS 1.3 구현은 현재보다 오래된 에포크의 레코드를 수신할 수 있습니다\(위의 요구 사항은 최신 레코드 수신을 배제함\). 그들은 해당 epoch로 해당 레코드를 처리하려고 시도해야 하지만\(올바른 epoch 결정에 대한 정보는 섹션 4.2.2 참조\) 그러한 out-of-epoch 레코드를 폐기하도록 선택할 수 있습니다.\(SHOULD\)

KeyUpdate에 대한 ACK 메시지가 손실되어 KeyUpdate의 발신자가 키 자료를 업데이트하지 못할 가능성으로 인해 수신자는 새 키를 사용하여 메시지를 수신하고 성공적으로 해독할 때까지 사전 업데이트 키 자료를 유지해야 합니다.\(MUST\)

그림 14는 성공적인 ACK 처리가 epoch 값의 변경에 반영되는 KeyUpdate 메시지 발신자의 키를 업데이트함을 보여주는 교환 예를 보여줍니다.

```text
   Client                                             Server

         /-------------------------------------------\
        |                                             |
        |             Initial Handshake               |
         \-------------------------------------------/

    [Application Data]         -------->
    (epoch=3)

                               <--------      [Application Data]
                                                       (epoch=3)

         /-------------------------------------------\
        |                                             |
        |              Some time later ...            |
         \-------------------------------------------/

    [Application Data]         -------->
    (epoch=3)

    [KeyUpdate]
    (+ update_requested        -------->
    (epoch 3)

                               <--------      [Application Data]
                                                       (epoch=3)

                                                           [ACK]
                               <--------               (epoch=3)

    [Application Data]
    (epoch=4)                  -------->

                               <--------             [KeyUpdate]
                                                       (epoch=3)

    [ACK]                      -------->
    (epoch=4)

                               <--------      [Application Data]
                                                       (epoch=4)

                     Figure 14: Example DTLS Key Update
```

AES-128에서와 같이 128비트 키를 사용하면 2^64번 키를 다시 입력하면 주어진 연결 내에서 키를 재사용할 가능성이 높습니다. 키가 반복되더라도 IV도 독립적으로 생성됩니다. 추가 보안 마진을 제공하기 위해 전송 구현은 에포크가 2^48-1을 초과하도록 허용해서는 안 됩니다\(MUST NOT\). 나중에 이 값을 변경할 수 있도록 하려면 수신 구현에서 이 규칙을 적용하면 안 됩니다\(MUST NOT\). 전송 구현이 request\_update가 "update\_requested"로 설정된 KeyUpdate를 수신하는 경우, 이러한 제한을 초과하게 되는 경우 자체 KeyUpdate를 보내면 안 되며 대신 "update\_requested" 플래그를 무시해야 합니다\(SHOULD\). 참고: 이것은 "update\_requested"에 대한 응답으로 항상 KeyUpdate를 보내야 하는 TLS 1.3의 요구 사항을 재정의합니다.\(MUST NOT, MUST NOT, MUST NOT\)

---
## **9.  Connection ID Updates**

클라이언트와 서버가 "connection\_id" 확장\[RFC9146\]을 협상한 경우 어느 쪽이든 상대방이 NewConnectionId 메시지에서 사용하기를 원하는 새 CID를 보낼 수 있습니다.

```text
       enum {
           cid_immediate(0), cid_spare(1), (255)
       } ConnectionIdUsage;

       opaque ConnectionId<0..2^8-1>;

       struct {
           ConnectionId cids<0..2^16-1>;
           ConnectionIdUsage usage;
       } NewConnectionId;
```

cids: 보낸 사람이 피어에서 사용하기를 원하는 CID 집합을 나타냅니다.

사용법: 새 CID를 즉시 사용해야 하는지 아니면 예비인지를 나타냅니다. 사용이 "cid\_immediate"로 설정된 경우 새 CID 중 하나를 모든 향후 레코드에 즉시 사용해야 합니다. "cid\_spare"로 설정되면 기존 또는 새 CID를 사용할 수 있습니다.\(MUST, MAY\)

엔드포인트는 수신자 제공 CID를 제공된 순서대로 사용해야 합니다\(SHOULD\). 유지하려는 것보다 더 많은 여분의 CID를 수신하는 구현은 단순히 추가 CID를 버릴 수 있습니다\(MAY\). 끝점에는 하나 이상의 NewConnectionId 메시지 미해결이 있어서는 안 됩니다\(MUST NOT\).\(SHOULD, MAY, MUST NOT\)

"connection\_id" 확장을 협상하지 않았거나 빈 CID 수신을 협상한 구현은 NewConnectionId를 보내면 안 됩니다\(MUST NOT\). 구현은 빈 연결 ID를 보낼 때 RequestConnectionId를 보내면 안 됩니다\(MUST NOT\). 이러한 규칙의 위반을 감지하는 구현은 "unexpected\_message" 경고와 함께 연결을 종료해야 합니다.\(MUST NOT, MUST NOT, MUST\)

구현은 새 경로로 보낼 때마다 새 CID를 사용해야 하며 경로 변경이 예상되는 경우 이 목적을 위해 새 CID를 요청해야 합니다\(SHOULD\).\(SHOULD\)

```text
       struct {
         uint8 num_cids;
       } RequestConnectionId;
```

num\_cids: 원하는 CID의 수.

엔드포인트는 가능한 빨리 num\_cids CID를 포함하는 "cid\_spare" 사용과 함께 NewConnectionId를 전송하여 RequestConnectionId에 응답해야 합니다\(SHOULD\). 엔드포인트는 기존 요청이 아직 충족되지 않은 경우 RequestConnectionId 메시지를 보내면 안 됩니다\(MUST NOT\). 이는 엔드포인트가 사전에 새 CID를 요청해야 함을 의미합니다. 엔드포인트는 CID가 전혀 없는 경우를 포함하여 num\_cids 미만의 CID를 포함하는 NewConnectionId 메시지로 응답하여 과도하다고 생각하는 요청을 처리할 수 있습니다\(MAY\). 끝점은 "too\_many\_cids\_requested"\(경고 번호 52\) 경고를 사용하여 연결을 종료함으로써 과도한 수의 RequestConnectionId 메시지를 처리할 수 있습니다\(MAY\).\(SHOULD, MUST NOT, MAY, MAY\)

엔드포인트는 CID를 협상하지 않은 경우 이러한 메시지 중 하나를 보내면 안 됩니다\(MUST NOT\). 구현이 CID가 협상되지 않았을 때 이러한 메시지를 수신하는 경우 "unexpected\_message" 경고와 함께 연결을 중단해야 합니다.\(MUST NOT, MUST\)

---
### **9.1.  Connection ID Example**

아래는 각 방향에서 단일 CID를 사용하는 DTLS 1.3의 교환 예입니다.

- 참고: ClientHello 및 ServerHello 메시지에 사용되는 "connection\_id" 확장은 \[RFC9146\]에 정의되어 있습니다.

```text
   Client                                             Server
   ------                                             ------

   ClientHello
   (connection_id=5)
                               -------->

                               <--------       HelloRetryRequest
                                                        (cookie)

   ClientHello                 -------->
   (connection_id=5)
     + cookie

                               <--------             ServerHello
                                             (connection_id=100)
                                             EncryptedExtensions
                                                         (cid=5)
                                                     Certificate
                                                         (cid=5)
                                               CertificateVerify
                                                         (cid=5)
                                                        Finished
                                                         (cid=5)

   Certificate                -------->
   (cid=100)
   CertificateVerify
   (cid=100)
   Finished
   (cid=100)
                              <--------                      ACK
                                                         (cid=5)

   Application Data           ========>
   (cid=100)
                              <========         Application Data
                                                         (cid=5)
```

- 그림 15: CID를 사용한 DTLS 1.3 교환 예시

CID가 협상되지 않으면 수신자는 CID가 포함된 수신 레코드를 거부해야 합니다.\(MUST\)

---
## **10.  Application Data Protocol**

애플리케이션 데이터 메시지는 레코드 레이어에 의해 전달되며 레코드로 분할되고 현재 연결 상태에 따라 암호화됩니다. 메시지는 레코드 레이어에 투명한 데이터로 처리됩니다.

---
## **11.  Security Considerations**

보안 문제는 주로 \[TLS13\]에서 논의됩니다.

DTLS에 의해 제기되는 기본 추가 보안 고려 사항은 과도한 리소스 소비로 인한 서비스 거부입니다. DTLS에는 서비스 거부로부터 보호하도록 설계된 쿠키 교환이 포함되어 있습니다. 그러나 이 쿠키 교환을 사용하지 않는 구현은 여전히 ​​DoS에 취약합니다. 특히 쿠키 교환을 사용하지 않는 DTLS 서버는 DoS를 경험하지 않더라도 공격 증폭기로 사용될 수 있습니다. 따라서 DTLS 서버는 증폭이 해당 환경에서 위협이 되지 않는다고 믿을만한 합당한 이유가 없는 한 쿠키 교환을 사용해야 합니다. 클라이언트는 악수할 때마다 쿠키 교환을 수행할 준비가 되어 있어야 합니다.\(SHOULD, MUST\)

쿠키 교환 메커니즘이 작동하기 위해 쿠키에 필요한 몇 가지 주요 속성은 \[RFC2522\]의 섹션 3.3에 설명되어 있습니다.

\* 쿠키는 클라이언트의 주소에 따라야 합니다.\(MUST\)

\* 발급 기관이 아닌 다른 사람이 해당 기관에서 유효한 것으로 인정하는 쿠키를 생성하는 것은 불가능해야 합니다\(MUST NOT\). 여기에는 일반적으로 비밀 키를 기반으로 한 무결성 검사가 수반됩니다.\(MUST NOT\)

\* 쿠키 생성 및 확인은 다음에 의해 실행됩니다.

- 인증되지 않은 당사자이므로 쿠키 교환 메커니즘 자체가 DoS 벡터로 사용되는 것을 방지하기 위해 리소스 소비를 제한해야 합니다.

쿠키는 서버가 올바른 핸드셰이크 기록을 생성하도록 허용해야 하지만 쿠키에 대한 지식이 ClientHello 콘텐츠를 재생산하기에 불충분하도록 구성되어야 합니다. 그렇지 않으면 암호화된 클라이언트 Hello\[TLS-ECH\]와 같은 향후 확장에 문제가 발생할 수 있습니다.\(SHOULD\)

키 인증 메커니즘을 사용하여 쿠키를 생성하는 경우 연결된 비밀 키를 교체할 수 있어야 합니다. 그러면 키가 일시적으로 손상되더라도 쿠키 교환 메커니즘의 무결성이 영구적으로 손상되지 않습니다. 이 비밀은 예를 들어 세션 티켓 암호화 키만큼 가치가 높지는 않지만 유사한 시간 척도에서 쿠키 생성 키를 회전하면 키 회전 기능이 정기적으로 실행되어 제대로 작동하도록 보장할 수 있습니다.

쿠키 교환은 초기 핸드셰이크 동안 주소 유효성 검사를 제공합니다. 연결 ID가 있는 DTLS를 사용하면 연결 중에 끝점 주소를 변경할 수 있습니다. 이러한 업데이트된 주소는 핸드셰이크 동안 쿠키 교환에 포함되지 않습니다. DTLS 구현은 일부 도달 가능성 테스트를 먼저 수행하지 않는 한 다른 주소의 패킷에 대한 응답으로 보내는 주소를 업데이트해서는 안 됩니다\(MUST NOT\). 이 사양에는 그러한 테스트가 정의되어 있지 않으며 향후 사양에서는 주소를 업데이트하는 방법과 시기에 대한 완전한 절차를 지정해야 합니다. DTLS 피어는 실제 주소 업데이트 이벤트\(예: NAT 리바인딩으로 인해\)를 구별할 수 있는 수단이 없기 때문에 이러한 테스트를 통해서도 활성 경로에 있는 공격자는 트래픽을 블랙홀로 만들거나 제3자에 대한 반사 공격을 생성할 수 있습니다. 악의적 인 것에서. 이 공격은 요청/응답 메시지 크기의 비대칭성이 클 때 우려됩니다.\(MUST NOT\)

주문 보호 및 재생 불가를 제외하고 DTLS 1.3의 보안 보장은 TLS 1.3과 동일합니다. TLS는 항상 주문 보호 및 재생 불가를 제공하지만 DTLS는 주문 보호를 제공하지 않으며 재생 보호를 제공하지 않을 수 있습니다.

TLS 구현과 달리 DTLS 구현은 연결을 종료하여 유효하지 않은 레코드에 응답해서는 안 됩니다\(SHOULD NOT\).\(SHOULD NOT\)

TLS 1.3은 0-RTT 데이터\(또는 0-RTT 데이터를 사용하는 연결, \[TLS13\]의 섹션 8 참조\)에 대한 재생 보호가 필요합니다. DTLS는 데이터그램 프로토콜이 본질적으로 메시지 재정렬 및 ​​재생에 종속되기 때문에 선택적인 레코드별 재생 보호 메커니즘을 제공합니다. 이 두 가지 재생 방지 메커니즘은 직교하며 두 메커니즘 모두 서로의 요구 사항을 충족하지 않습니다.

DTLS 1.3의 핸드셰이크 기록에는 새로운 DTLS 필드가 포함되어 있지 않으므로 TLS 1.3과 동일한 형식을 갖게 됩니다. 그러나 DTLS 1.3 및 TLS 1.3 성적표는 서로 다른 버전 번호를 사용하기 때문에 분리되어 있습니다. 또한 DTLS 1.3 키 일정은 다른 레이블을 사용하므로 동일한 트랜스크립트에 대해 다른 키를 생성합니다.

DTLS 1.3에 대한 CID의 보안 및 개인 정보 보호 속성은 \[RFC9146\]의 DTLS 1.2에 대해 설명된 내용 위에 구축됩니다. 그러나 다음과 같은 몇 가지 차이점이 있습니다.

\* 두 버전의 DTLS 모두 CID 기능과 CID 값의 사용에 동의하기 위해 확장 협상을 사용합니다. 두 버전 모두에서 CID는 DTLS 레코드 헤더에 포함됩니다\(협상된 경우\). 그러나 CID가 레코드 헤더에 포함되는 방식은 두 버전 간에 다릅니다.

\* post-handshake 메시지를 사용하면 클라이언트와 서버가 CID를 업데이트할 수 있으며 해당 값은 기밀 보호와 함께 교환됩니다.

\* 여러 CID를 사용하는 기능을 통해 멀티홈 시나리오에서 개인 정보 보호 속성을 개선할 수 있습니다. 이러한 호스트의 여러 경로에서 단일 CID만 사용 중인 경우 공격자는 경로 전체에서 통신 상호 작용을 연관시킬 수 있으므로 개인 정보 보호 문제가 추가됩니다. 이를 방지하기 위해 구현은 로컬 주소나 포트를 변경할 때마다 새로운 CID를 사용하려고 시도해야 합니다\(항상 감지할 수 있는 것은 아님\). RequestConnectionId 메시지는 적합한 CID 풀이 사용 가능한지 확인하기 위해 새 CID를 요청하기 위해 피어에서 사용할 수 있습니다.\(SHOULD\)

\* 시퀀스 번호를 암호화하는 메커니즘\(섹션 4.2.3\)은 다른 경로에서 수신된 시퀀스 번호의 패턴을 연관시키려고 시도하는 온 경로 적의 사소한 추적을 방지합니다. 이러한 추적은 시퀀스 번호 암호화가 없는 경우 각 경로에 서로 다른 CID가 사용되는 경우에도 발생할 수 있습니다. 특정 이벤트를 기반으로 또는 정기적으로 CID를 전환하면 경로상의 적의 추적을 방지하는 데 도움이 됩니다. 시퀀스 번호 암호화는 CID 사용 여부에 관계없이 모든 암호화된 DTLS 1.3 레코드에 사용됩니다. 시퀀스 번호와 달리 epoch는 키 식별자 역할을 하므로 암호화되지 않습니다. 이는 서로 다른 네트워크 경로에서 단일 연결의 패킷 상관 관계를 개선할 수 있습니다.

\* DTLS 1.3은 이전 DTLS 버전보다 훨씬 일찍 핸드셰이크 메시지를 암호화합니다. 따라서 클라이언트 인증서와 같은 DTLS 클라이언트를 식별하는 정보는 온패스 공격자가 사용할 수 없습니다.

---
## **12.  Changes since DTLS 1.2**

TLS 1.3은 TLS 1.2와 관련하여 많은 변경 사항을 도입하므로 DTLS 1.2에서 DTLS 1.3으로의 변경 사항 목록도 동일하게 많습니다. 이러한 이유로 이 섹션에서는 가장 중요한 변경 사항에만 초점을 맞춥니다.

\* 짧은 메시지 교환으로 이어지는 새로운 핸드셰이크 패턴.

\* AEAD 암호만 지원됩니다. 추가 데이터 계산이 간소화되었습니다.

\* 더 약하고 오래된 암호화 알고리즘에 대한 지원이 제거되었습니다.

\* HelloVerifyRequest 대신 TLS 1.3의 HelloRetryRequest가 사용됨.

```text
   *  More flexible cipher suite negotiation.

   *  New session resumption mechanism.

   *  PSK authentication redefined.
```

\* 새로운 키 파생 구성을 활용하는 새로운 키 파생 계층.

```text
   *  Improved version negotiation.
```

\* 최적화된 레코드 레이어 인코딩 및 그에 따른 크기.

```text
   *  Added CID functionality.
```

\* 시퀀스 번호는 암호화됩니다.

---
## **13.  Updates Affecting DTLS 1.2**

이 문서는 DTLS 1.3을 지원하지 않는 변경 사항을 포함하여 DTLS 1.2 구현에 선택적으로 영향을 미치는 몇 가지 변경 사항을 정의합니다.

\* \[TLS13\], 섹션 4.1.3에 설명되고 섹션 5.3에 설명된 대로 DTLS에 적용되는 버전 다운그레이드 보호 메커니즘.

\* \[TLS13\], 섹션 1.3에 설명된 업데이트.

\* \[TLS13\], 섹션 9.3에 설명된 새로운 규정 준수 요구 사항.

---
## **14.  IANA Considerations**

IANA는 섹션 7에 정의된 ACK 메시지에 대한 "TLS ContentType" 레지스트리에서 콘텐츠 유형 값 26을 할당했습니다. "DTLS-OK" 열의 값은 "Y"입니다. IANA는 이 범위의 콘텐츠 유형이 할당되지 않도록 콘텐츠 유형 범위 32-63을 예약했습니다.

IANA는 "TLS 경고" 레지스트리에서 "too\_many\_cids\_requested" 경고에 값 52를 할당했습니다. "DTLS-OK" 열의 값은 "Y"입니다.

IANA는 이 문서에 정의된 대로 request\_connection\_id\(9\) 및 new\_connection\_id\(10\)에 대해 \[TLS13\]에 정의된 "TLS HandshakeType" 레지스트리에 두 개의 값을 할당했습니다. "DTLS-OK" 열의 값은 "Y"입니다.

IANA는 이 RFC를 다음 참고 사항과 함께 "TLS Cipher Suites" 레지스트리에 대한 참조로 추가했습니다.

| DTLS와 함께 사용하도록 지정된 모든 TLS 암호화 제품군은 반드시 | 관련된 AEAD 기능의 사용에 대한 제한을 정의합니다. 기밀성과 무결성을 위해 여백을 유지합니다. | RFC 9147의 섹션 4.5.3에 지정되어 있습니다.\(MUST\)

---
## **15.  References**
---
### **15.1.  Normative References**

```text
   [CHACHA]   Nir, Y. and A. Langley, "ChaCha20 and Poly1305 for IETF
              Protocols", RFC 8439, DOI 10.17487/RFC8439, June 2018,
              <https://www.rfc-editor.org/info/rfc8439>.

   [RFC0768]  Postel, J., "User Datagram Protocol", STD 6, RFC 768,
              DOI 10.17487/RFC0768, August 1980,
              <https://www.rfc-editor.org/info/rfc768>.

   [RFC0793]  Postel, J., "Transmission Control Protocol", STD 7,
              RFC 793, DOI 10.17487/RFC0793, September 1981,
              <https://www.rfc-editor.org/info/rfc793>.

   [RFC1191]  Mogul, J. and S. Deering, "Path MTU discovery", RFC 1191,
              DOI 10.17487/RFC1191, November 1990,
              <https://www.rfc-editor.org/info/rfc1191>.

   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", BCP 14, RFC 2119,
              DOI 10.17487/RFC2119, March 1997,
              <https://www.rfc-editor.org/info/rfc2119>.

   [RFC4443]  Conta, A., Deering, S., and M. Gupta, Ed., "Internet
              Control Message Protocol (ICMPv6) for the Internet
              Protocol Version 6 (IPv6) Specification", STD 89,
              RFC 4443, DOI 10.17487/RFC4443, March 2006,
              <https://www.rfc-editor.org/info/rfc4443>.

   [RFC4821]  Mathis, M. and J. Heffner, "Packetization Layer Path MTU
              Discovery", RFC 4821, DOI 10.17487/RFC4821, March 2007,
              <https://www.rfc-editor.org/info/rfc4821>.

   [RFC6298]  Paxson, V., Allman, M., Chu, J., and M. Sargent,
              "Computing TCP's Retransmission Timer", RFC 6298,
              DOI 10.17487/RFC6298, June 2011,
              <https://www.rfc-editor.org/info/rfc6298>.

   [RFC8174]  Leiba, B., "Ambiguity of Uppercase vs Lowercase in RFC
              2119 Key Words", BCP 14, RFC 8174, DOI 10.17487/RFC8174,
              May 2017, <https://www.rfc-editor.org/info/rfc8174>.

   [RFC9146]  Rescorla, E., Ed., Tschofenig, H., Ed., Fossati, T., and
              A. Kraus, "Connection Identifier for DTLS 1.2", RFC 9146,
              DOI 10.17487/RFC9146, March 2022,
              <https://www.rfc-editor.org/info/rfc9146>.

   [TLS13]    Rescorla, E., "The Transport Layer Security (TLS) Protocol
              Version 1.3", RFC 8446, DOI 10.17487/RFC8446, August 2018,
              <https://www.rfc-editor.org/info/rfc8446>.
```

---
### **15.2.  Informative References**

```text
   [AEAD-LIMITS]
              Günther, F., Thomson, M., and C. A. Wood, "Usage Limits on
              AEAD Algorithms", Work in Progress, Internet-Draft, draft-
              irtf-cfrg-aead-limits-04, 7 March 2022,
              <https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-
              aead-limits-04>.

   [AEBounds] Luykx, A. and K. Paterson, "Limits on Authenticated
              Encryption Use in TLS", 28 August 2017,
              <https://www.isg.rhul.ac.uk/~kp/TLS-AEbounds.pdf>.

   [CCM-ANALYSIS]
              Jonsson, J., "On the Security of CTR + CBC-MAC", Selected
              Areas in Cryptography pp. 76-93,
              DOI 10.1007/3-540-36492-7_7, February 2003,
              <https://doi.org/10.1007/3-540-36492-7_7>.

   [DEPRECATE]
              Moriarty, K. and S. Farrell, "Deprecating TLS 1.0 and TLS
              1.1", BCP 195, RFC 8996, DOI 10.17487/RFC8996, March 2021,
              <https://www.rfc-editor.org/info/rfc8996>.

   [IOT-PROFILE]
              Tschofenig, H. and T. Fossati, "TLS/DTLS 1.3 Profiles for
              the Internet of Things", Work in Progress, Internet-Draft,
              draft-ietf-uta-tls13-iot-profile-04, 7 March 2022,
              <https://datatracker.ietf.org/doc/html/draft-ietf-uta-
              tls13-iot-profile-04>.

   [RFC2522]  Karn, P. and W. Simpson, "Photuris: Session-Key Management
              Protocol", RFC 2522, DOI 10.17487/RFC2522, March 1999,
              <https://www.rfc-editor.org/info/rfc2522>.

   [RFC4303]  Kent, S., "IP Encapsulating Security Payload (ESP)",
              RFC 4303, DOI 10.17487/RFC4303, December 2005,
              <https://www.rfc-editor.org/info/rfc4303>.

   [RFC4340]  Kohler, E., Handley, M., and S. Floyd, "Datagram
              Congestion Control Protocol (DCCP)", RFC 4340,
              DOI 10.17487/RFC4340, March 2006,
              <https://www.rfc-editor.org/info/rfc4340>.

   [RFC4346]  Dierks, T. and E. Rescorla, "The Transport Layer Security
              (TLS) Protocol Version 1.1", RFC 4346,
              DOI 10.17487/RFC4346, April 2006,
              <https://www.rfc-editor.org/info/rfc4346>.

   [RFC4347]  Rescorla, E. and N. Modadugu, "Datagram Transport Layer
              Security", RFC 4347, DOI 10.17487/RFC4347, April 2006,
              <https://www.rfc-editor.org/info/rfc4347>.

   [RFC4960]  Stewart, R., Ed., "Stream Control Transmission Protocol",
              RFC 4960, DOI 10.17487/RFC4960, September 2007,
              <https://www.rfc-editor.org/info/rfc4960>.

   [RFC5238]  Phelan, T., "Datagram Transport Layer Security (DTLS) over
              the Datagram Congestion Control Protocol (DCCP)",
              RFC 5238, DOI 10.17487/RFC5238, May 2008,
              <https://www.rfc-editor.org/info/rfc5238>.

   [RFC5246]  Dierks, T. and E. Rescorla, "The Transport Layer Security
              (TLS) Protocol Version 1.2", RFC 5246,
              DOI 10.17487/RFC5246, August 2008,
              <https://www.rfc-editor.org/info/rfc5246>.

   [RFC5763]  Fischl, J., Tschofenig, H., and E. Rescorla, "Framework
              for Establishing a Secure Real-time Transport Protocol
              (SRTP) Security Context Using Datagram Transport Layer
              Security (DTLS)", RFC 5763, DOI 10.17487/RFC5763, May
              2010, <https://www.rfc-editor.org/info/rfc5763>.

   [RFC5764]  McGrew, D. and E. Rescorla, "Datagram Transport Layer
              Security (DTLS) Extension to Establish Keys for the Secure
              Real-time Transport Protocol (SRTP)", RFC 5764,
              DOI 10.17487/RFC5764, May 2010,
              <https://www.rfc-editor.org/info/rfc5764>.

   [RFC6066]  Eastlake 3rd, D., "Transport Layer Security (TLS)
              Extensions: Extension Definitions", RFC 6066,
              DOI 10.17487/RFC6066, January 2011,
              <https://www.rfc-editor.org/info/rfc6066>.

   [RFC6347]  Rescorla, E. and N. Modadugu, "Datagram Transport Layer
              Security Version 1.2", RFC 6347, DOI 10.17487/RFC6347,
              January 2012, <https://www.rfc-editor.org/info/rfc6347>.

   [RFC7296]  Kaufman, C., Hoffman, P., Nir, Y., Eronen, P., and T.
              Kivinen, "Internet Key Exchange Protocol Version 2
              (IKEv2)", STD 79, RFC 7296, DOI 10.17487/RFC7296, October
              2014, <https://www.rfc-editor.org/info/rfc7296>.

   [RFC7525]  Sheffer, Y., Holz, R., and P. Saint-Andre,
              "Recommendations for Secure Use of Transport Layer
              Security (TLS) and Datagram Transport Layer Security
              (DTLS)", BCP 195, RFC 7525, DOI 10.17487/RFC7525, May
              2015, <https://www.rfc-editor.org/info/rfc7525>.

   [RFC7924]  Santesson, S. and H. Tschofenig, "Transport Layer Security
              (TLS) Cached Information Extension", RFC 7924,
              DOI 10.17487/RFC7924, July 2016,
              <https://www.rfc-editor.org/info/rfc7924>.

   [RFC7983]  Petit-Huguenin, M. and G. Salgueiro, "Multiplexing Scheme
              Updates for Secure Real-time Transport Protocol (SRTP)
              Extension for Datagram Transport Layer Security (DTLS)",
              RFC 7983, DOI 10.17487/RFC7983, September 2016,
              <https://www.rfc-editor.org/info/rfc7983>.

   [RFC8201]  McCann, J., Deering, S., Mogul, J., and R. Hinden, Ed.,
              "Path MTU Discovery for IP version 6", STD 87, RFC 8201,
              DOI 10.17487/RFC8201, July 2017,
              <https://www.rfc-editor.org/info/rfc8201>.

   [RFC8445]  Keranen, A., Holmberg, C., and J. Rosenberg, "Interactive
              Connectivity Establishment (ICE): A Protocol for Network
              Address Translator (NAT) Traversal", RFC 8445,
              DOI 10.17487/RFC8445, July 2018,
              <https://www.rfc-editor.org/info/rfc8445>.

   [RFC8879]  Ghedini, A. and V. Vasiliev, "TLS Certificate
              Compression", RFC 8879, DOI 10.17487/RFC8879, December
              2020, <https://www.rfc-editor.org/info/rfc8879>.

   [RFC9000]  Iyengar, J., Ed. and M. Thomson, Ed., "QUIC: A UDP-Based
              Multiplexed and Secure Transport", RFC 9000,
              DOI 10.17487/RFC9000, May 2021,
              <https://www.rfc-editor.org/info/rfc9000>.

   [RFC9002]  Iyengar, J., Ed. and I. Swett, Ed., "QUIC Loss Detection
              and Congestion Control", RFC 9002, DOI 10.17487/RFC9002,
              May 2021, <https://www.rfc-editor.org/info/rfc9002>.

   [ROBUST]   Fischlin, M., Günther, F., and C. Janson, "Robust
              Channels: Handling Unreliable Networks in the Record
              Layers of QUIC and DTLS 1.3", received 15 June 2020, last
              revised 22 February 2021,
              <https://eprint.iacr.org/2020/718>.

   [TLS-ECH]  Rescorla, E., Oku, K., Sullivan, N., and C.A. Wood, "TLS
              Encrypted Client Hello", Work in Progress, Internet-Draft,
              draft-ietf-tls-esni-14, 13 February 2022,
              <https://datatracker.ietf.org/doc/html/draft-ietf-tls-
              esni-14>.
```

---
# **Appendix A.  Protocol Data Structures and Constant Values**

이 섹션에서는 표준 프로토콜 유형 및 상수 정의를 제공합니다.

---
### **A.1.  Record Layer**

```text
       struct {
           ContentType type;
           ProtocolVersion legacy_record_version;
           uint16 epoch = 0
           uint48 sequence_number;
           uint16 length;
           opaque fragment[DTLSPlaintext.length];
       } DTLSPlaintext;

       struct {
            opaque content[DTLSPlaintext.length];
            ContentType type;
            uint8 zeros[length_of_padding];
       } DTLSInnerPlaintext;

       struct {
           opaque unified_hdr[variable];
           opaque encrypted_record[length];
       } DTLSCiphertext;

       0 1 2 3 4 5 6 7
       +-+-+-+-+-+-+-+-+
       |0|0|1|C|S|L|E E|
       +-+-+-+-+-+-+-+-+
       | Connection ID |   Legend:
       | (if any,      |
       /  length as    /   C   - Connection ID (CID) present
       |  negotiated)  |   S   - Sequence number length
       +-+-+-+-+-+-+-+-+   L   - Length present
       |  8 or 16 bit  |   E   - Epoch
       |Sequence Number|
       +-+-+-+-+-+-+-+-+
       | 16 bit Length |
       | (if present)  |
       +-+-+-+-+-+-+-+-+

       struct {
           uint64 epoch;
           uint64 sequence_number;
       } RecordNumber;
```

---
### **A.2.  Handshake Protocol**

```text
       enum {
           hello_request_RESERVED(0),
           client_hello(1),
           server_hello(2),
           hello_verify_request_RESERVED(3),
           new_session_ticket(4),
           end_of_early_data(5),
           hello_retry_request_RESERVED(6),
           encrypted_extensions(8),
           request_connection_id(9),           /* New */
           new_connection_id(10),              /* New */
           certificate(11),
           server_key_exchange_RESERVED(12),
           certificate_request(13),
           server_hello_done_RESERVED(14),
           certificate_verify(15),
           client_key_exchange_RESERVED(16),
           finished(20),
           certificate_url_RESERVED(21),
           certificate_status_RESERVED(22),
           supplemental_data_RESERVED(23),
           key_update(24),
           message_hash(254),
           (255)
       } HandshakeType;

       struct {
           HandshakeType msg_type;    /* handshake type */
           uint24 length;             /* bytes in message */
           uint16 message_seq;        /* DTLS-required field */
           uint24 fragment_offset;    /* DTLS-required field */
           uint24 fragment_length;    /* DTLS-required field */
           select (msg_type) {
               case client_hello:          ClientHello;
               case server_hello:          ServerHello;
               case end_of_early_data:     EndOfEarlyData;
               case encrypted_extensions:  EncryptedExtensions;
               case certificate_request:   CertificateRequest;
               case certificate:           Certificate;
               case certificate_verify:    CertificateVerify;
               case finished:              Finished;
               case new_session_ticket:    NewSessionTicket;
               case key_update:            KeyUpdate;
               case request_connection_id: RequestConnectionId;
               case new_connection_id:     NewConnectionId;
           } body;
       } Handshake;

       uint16 ProtocolVersion;
       opaque Random[32];

       uint8 CipherSuite[2];    /* Cryptographic suite selector */

       struct {
           ProtocolVersion legacy_version = { 254,253 }; // DTLSv1.2
           Random random;
           opaque legacy_session_id<0..32>;
           opaque legacy_cookie<0..2^8-1>;                  // DTLS
           CipherSuite cipher_suites<2..2^16-2>;
           opaque legacy_compression_methods<1..2^8-1>;
           Extension extensions<8..2^16-1>;
       } ClientHello;
```

---
### **A.3.  ACKs**

```text
       struct {
           RecordNumber record_numbers<0..2^16-1>;
       } ACK;
```

---
### **A.4.  Connection ID Management**

```text
       enum {
           cid_immediate(0), cid_spare(1), (255)
       } ConnectionIdUsage;

       opaque ConnectionId<0..2^8-1>;

       struct {
           ConnectionId cids<0..2^16-1>;
           ConnectionIdUsage usage;
       } NewConnectionId;

       struct {
         uint8 num_cids;
       } RequestConnectionId;
```

---
# **Appendix B.  Analysis of Limits on CCM Usage**

TLS\[TLS13\] 및 \[AEBounds\]는 AEAD\_AES\_128\_CCM에 대한 키 사용에 대한 제한을 지정하지 않습니다. 그러나 DTLS와 함께 사용되는 모든 AEAD에는 기밀성과 무결성이 모두 유지되도록 사용에 대한 제한이 필요합니다. 이 섹션에서는 AEAD\_AES\_128\_CCM에 대한 분석을 문서화합니다.

\[CCM-ANALYSIS\]는 이 분석의 기초로 사용됩니다. 해당 분석 결과는 \[TLS13\]에서 선택한 항목을 기반으로 사용 제한을 도출하는 데 사용됩니다.

이 분석에서는 곱셈\(\*\), 나눗셈\(/\) 및 지수\(^\)에 대한 기호와 우선 순위 설정을 위한 괄호를 사용합니다. 다음 기호도 사용됩니다.

t: 인증 태그의 크기\(비트\). 이 암호의 경우 t는 128입니다.

n: 블록 함수의 비트 단위 크기. 이 암호의 경우 n은 128입니다.

l: 각 패킷의 블록 수\(아래 참조\).

q: 엔드포인트에서 생성되고 보호되는 정품 패킷의 수입니다. 이 값은 키를 업데이트하기 전에 보호할 수 있는 패킷 수에 대한 제한입니다.

v: 끝점이 수락할 위조된 패킷의 수입니다. 이 값은 엔드포인트가 키를 업데이트하기 전에 거부할 수 있는 위조된 패킷 수에 대한 제한입니다.

AEAD\_AES\_128\_CCM의 분석은 각 메시지 생성과 관련된 블록 작업 수에 의존합니다. 단순화를 위해 \[AEBounds\]의 다른 AEAD 기능 분석과 일치시키기 위해 이 분석에서는 패킷 길이가 2^10 블록이고 패킷 크기 제한이 2^14바이트라고 가정합니다.

AEAD\_AES\_128\_CCM의 경우 총 블록 암호화 작업 수는 블록의 관련 데이터 길이, 블록의 암호문 길이 및 블록의 일반 텍스트 길이에 1을 더한 값의 합계입니다. 이 분석에서 이것은 다음과 같습니다. 블록에서 레코드 최대 길이의 두 배 값으로 단순화됩니다\(즉, 2l = 2^11\). 이 단순화는 하나의 블록으로 제한되는 관련 데이터를 기반으로 합니다.

---
### **B.1.  Confidentiality Limits**

기밀성을 위해 \[CCM-ANALYSIS\]의 정리 2는 공격자가 다음 이하의 이상적인 의사 난수 순열\(PRP\)에 비해 뚜렷한 이점을 얻는다는 것을 설정합니다.

```text
   (2l * q)^2 / 2^n
```

\[AEAD-LIMITS\]에 요약된 대로 TLS 1.3에서 사용하는 것과 일치하는 2^-60의 단일 키 설정에서 대상 이점의 경우 다음과 같은 관계가 발생합니다.

```text
   q <= 2^23
```

즉, 엔드포인트는 공격자가 목표인 2^-60보다 더 큰 이점을 얻지 않고는 동일한 키 세트로 2^23개 이상의 패킷을 보호할 수 없습니다.

---
### **B.2.  Integrity Limits**

무결성을 위해 \[CCM-ANALYSIS\]의 정리 1은 공격자가 다음 이하의 이상적인 PRP보다 이점을 얻는다는 것을 설정합니다.

```text
   v / 2^t + (2l * (v + q))^2 / 2^n
```

목표는 \[AEAD-LIMITS\]에 요약된 대로 TLS 1.3의 목표와 일치하도록 이 이점을 2^-57로 제한하는 것입니다. t와 n이 모두 128이므로 첫 번째 항은 두 번째 항에 비해 무시할 수 있으므로 결과에 큰 영향을 미치지 않고 항을 제거할 수 있습니다. 이것은 다음과 같은 관계를 생성합니다.

```text
   v + q <= 2^24.5
```

q 및 반올림에 대해 이전에 설정된 값 2^23을 사용하면 v의 상한이 2^23.5가 됩니다. 즉, 엔드포인트는 공격자가 목표인 2^-57보다 더 큰 이점을 얻지 않고는 동일한 키 세트로 2^23.5개 이상의 패킷을 인증하려고 시도할 수 없습니다.

---
### **B.3.  Limits for AEAD_AES_128_CCM_8**

TLS\_AES\_128\_CCM\_8\_SHA256 암호화 제품군은 짧은 인증 태그\(즉, t=64\)를 사용하는 AEAD\_AES\_128\_CCM\_8 함수를 사용합니다.

AEAD\_AES\_128\_CCM\_8의 기밀성 제한은 태그 길이에 의존하지 않기 때문에 AEAD\_AES\_128\_CCM의 기밀성 제한과 동일합니다. 부록 B.1 참조.

64비트의 더 짧은 태그 길이는 부록 B.2에서 사용된 단순화가 AEAAD\_AES\_128\_CCM\_8에 적용되지 않음을 의미합니다. 목표가 다른 암호 제품군과 동일한 마진을 유지하는 것이라면 위조에 대한 제한은 주로 이점 공식의 첫 번째 항에 의해 결정됩니다.

```text
   v <= 2^7
```

이것은 인증에 실패한 시도를 나타내므로 일부 환경에서는 이 제한을 적용하는 것이 가능할 수 있습니다. 그러나 일반적인 사용을 위한 구현에 이 제한을 적용하면 저렴한 서비스 거부 공격에 대한 연결이 노출됩니다.

이 분석은 TLS\_AES\_128\_CCM\_8\_SHA256이 일반 용도에 적합하지 않다는 견해를 뒷받침합니다. 특히, TLS\_AES\_128\_CCM\_8\_SHA256은 기록의 위변조를 방지하거나 위변조의 영향을 완화하기 위한 추가 조치 없이는 사용할 수 없습니다. 이를 위해서는 특정 배포 또는 애플리케이션에 존재하는 제약 조건을 이해해야 할 수 있습니다. 예를 들어 공격자가 DTLS의 특정 사용에 부과된 제약 조건에 대한 이해를 바탕으로 이점에 대해 다른 목표를 설정하는 것이 가능할 수 있습니다.

---
# **Appendix C.  Implementation Pitfalls**

상호 운용성 및 보안 문제의 원인이 된 TLS 측면\(\[TLS13\]의 부록 C.3\) 외에도 DTLS는 여기에 언급된 몇 가지 새로운 잠재적 문제 원인을 제시합니다.

\* 키 전환 중에 여러 시대에서 받은 메시지를 올바르게 처리합니까? 여기에는 올바른 키 찾기와 재생 감지 수행\(활성화된 경우\)이 포함됩니다.

\* \(암시적 또는 명시적으로\) 승인되지 않은 핸드셰이크 메시지를 재전송합니까\(섹션 5.8\)?

\* 순서가 잘못된 경우를 포함하여 수신된 핸드셰이크 메시지 조각을 올바르게 처리합니까?

\* 잘못된 순서로 수신된 핸드셰이크 메시지를 올바르게 처리하고 있습니까? 여기에는 버퍼링 또는 폐기가 포함될 수 있습니다.

\* 주소가 확인되기 전에 피어에 보내는 데이터의 양을 제한합니까?

\* 명시적 레코드 길이가 포함된 데이터그램 내에 포함되어 있는지 확인합니까?

---
# **Contributors**

많은 사람들이 이전 DTLS 버전에 기여했으며 이전 버전의 DTLS 사양 또는 참조 사양에서 인정됩니다.

```text
   Hanno Becker
   Arm Limited
   Email: Hanno.Becker@arm.com

   David Benjamin
   Google
   Email: davidben@google.com

   Thomas Fossati
   Arm Limited
   Email: thomas.fossati@arm.com

   Tobias Gondrom
   Huawei
   Email: tobias.gondrom@gondrom.org

   Felix Günther
   ETH Zurich
   Email: mail@felixguenther.info

   Benjamin Kaduk
   Akamai Technologies
   Email: kaduk@mit.edu

   Ilari Liusvaara
   Independent
   Email: ilariliusvaara@welho.com

   Martin Thomson
   Mozilla
   Email: martin.thomson@gmail.com

   Christopher A. Wood
   Cloudflare
   Email: caw@heapingbits.net

   Yin Xinxing
   Huawei
   Email: yinxinxing@huawei.com
```

시퀀스 번호 암호화 개념은 QUIC \[RFC9000\]에서 가져왔습니다. RFC 9000 작성자의 작업에 감사드립니다. Felix Günther와 Martin Thomson은 부록 B의 분석에 기여했습니다. 검토 의견을 주신 Jonathan Hammell, Bernard Aboba 및 Andy Cunningham에게 감사드립니다.

또한 검토 의견을 주신 IESG 회원들에게도 감사드립니다. , 알바로 레타나.

---
# **Authors' Addresses**

```text
   Eric Rescorla
   Mozilla
   Email: ekr@rtfm.com

   Hannes Tschofenig
   Arm Limited
   Email: hannes.tschofenig@arm.com

   Nagendra Modadugu
   Google, Inc.
   Email: nagendra@cs.stanford.edu
```
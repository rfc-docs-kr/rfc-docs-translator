

```text
Internet Engineering Task Force (IETF)                       E. Rescorla
Request for Comments: 8446                                       Mozilla
Obsoletes: 5077, 5246, 6961                                  August 2018
Updates: 5705, 6066
Category: Standards Track
ISSN: 2070-1721

        The Transport Layer Security (TLS) Protocol Version 1.3
```

---
# **Abstract**

이 문서는 TLS\(Transport Layer Security\) 프로토콜 버전 1.3을 지정합니다. TLS를 사용하면 도청, 변조 및 메시지 위조를 방지하도록 설계된 방식으로 클라이언트/서버 응용 프로그램이 인터넷을 통해 통신할 수 있습니다.

이 문서는 RFC 5705 및 6066을 업데이트하고 RFC 5077, 5246 및 6961을 폐기합니다. 이 문서는 또한 TLS 1.2 구현에 대한 새로운 요구 사항을 지정합니다.

---
# **Status of This Memo**

이것은 인터넷 표준 추적 문서입니다.

이 문서는 IETF\(Internet Engineering Task Force\)의 제품입니다. 이는 IETF 커뮤니티의 합의를 나타냅니다. 공개 검토를 받았으며 IESG\(Internet Engineering Steering Group\)의 출판 승인을 받았습니다. 인터넷 표준에 대한 자세한 내용은 RFC 7841의 섹션 2에서 확인할 수 있습니다.

이 문서의 현재 상태, 오류 및 이에 대한 피드백 제공 방법에 대한 정보는 https://www.rfc-editor.org/info/rfc8446에서 얻을 수 있습니다.

---
# **Copyright Notice**

Copyright \(c\) 2018 IETF Trust 및 문서 작성자로 확인된 사람. 판권 소유.

이 문서는 이 문서의 발행일에 유효한 BCP 78 및 IETF 문서에 관한 IETF 트러스트의 법적 조항\(https://trustee.ietf.org/license-info\)의 적용을 받습니다. 이 문서와 관련된 귀하의 권리 및 제한 사항을 설명하므로 이 문서를 주의 깊게 검토하십시오. 이 문서에서 추출한 코드 구성 요소는 Trust Legal Provisions의 섹션 4.e에 설명된 대로 Simplified BSD License 텍스트를 포함해야 하며 Simplified BSD License에 설명된 대로 보증 없이 제공됩니다.

이 문서에는 2008년 11월 10일 이전에 공개되거나 공개된 IETF 문서 또는 IETF 기고문의 자료가 포함될 수 있습니다. 이 자료의 일부에 대한 저작권을 제어하는 ​​사람은 해당 자료의 수정을 허용할 권리를 IETF 트러스트에 부여하지 않았을 수 있습니다. IETF 표준 프로세스 외부. 이러한 자료의 저작권을 관리하는 사람으로부터 적절한 라이센스를 얻지 않고 이 문서는 IETF 표준 프로세스 외부에서 수정할 수 없으며 IETF 표준 프로세스 외부에서 이 문서의 파생물을 생성할 수 없습니다. RFC로 게시하거나 영어 이외의 언어로 번역합니다.

---
# **Table of Contents**

```text
   1. Introduction ....................................................6
      1.1. Conventions and Terminology ................................7
      1.2. Major Differences from TLS 1.2 .............................8
      1.3. Updates Affecting TLS 1.2 ..................................9
   2. Protocol Overview ..............................................10
      2.1. Incorrect DHE Share .......................................14
      2.2. Resumption and Pre-Shared Key (PSK) .......................15
      2.3. 0-RTT Data ................................................17
   3. Presentation Language ..........................................19
      3.1. Basic Block Size ..........................................19
      3.2. Miscellaneous .............................................20
      3.3. Numbers ...................................................20
      3.4. Vectors ...................................................20
      3.5. Enumerateds ...............................................21
      3.6. Constructed Types .........................................22
      3.7. Constants .................................................23
      3.8. Variants ..................................................23
   4. Handshake Protocol .............................................24
      4.1. Key Exchange Messages .....................................25
           4.1.1. Cryptographic Negotiation ..........................26
           4.1.2. Client Hello .......................................27
           4.1.3. Server Hello .......................................31
           4.1.4. Hello Retry Request ................................33
      4.2. Extensions ................................................35
           4.2.1. Supported Versions .................................39
           4.2.2. Cookie .............................................40
           4.2.3. Signature Algorithms ...............................41
           4.2.4. Certificate Authorities ............................45
           4.2.5. OID Filters ........................................45
           4.2.6. Post-Handshake Client Authentication ...............47
           4.2.7. Supported Groups ...................................47
           4.2.8. Key Share ..........................................48
           4.2.9. Pre-Shared Key Exchange Modes ......................51
           4.2.10. Early Data Indication .............................52
           4.2.11. Pre-Shared Key Extension ..........................55
      4.3. Server Parameters .........................................59
           4.3.1. Encrypted Extensions ...............................60
           4.3.2. Certificate Request ................................60
      4.4. Authentication Messages ...................................61
           4.4.1. The Transcript Hash ................................63
           4.4.2. Certificate ........................................64
           4.4.3. Certificate Verify .................................69
           4.4.4. Finished ...........................................71
      4.5. End of Early Data .........................................72
      4.6. Post-Handshake Messages ...................................73
           4.6.1. New Session Ticket Message .........................73
           4.6.2. Post-Handshake Authentication ......................75
           4.6.3. Key and Initialization Vector Update ...............76
   5. Record Protocol ................................................77
      5.1. Record Layer ..............................................78
      5.2. Record Payload Protection .................................80
      5.3. Per-Record Nonce ..........................................82
      5.4. Record Padding ............................................83
      5.5. Limits on Key Usage .......................................84
   6. Alert Protocol .................................................85
      6.1. Closure Alerts ............................................87
      6.2. Error Alerts ..............................................88
   7. Cryptographic Computations .....................................90
      7.1. Key Schedule ..............................................91
      7.2. Updating Traffic Secrets ..................................94
      7.3. Traffic Key Calculation ...................................95
      7.4. (EC)DHE Shared Secret Calculation .........................95
           7.4.1. Finite Field Diffie-Hellman ........................95
           7.4.2. Elliptic Curve Diffie-Hellman ......................96
      7.5. Exporters .................................................97
   8. 0-RTT and Anti-Replay ..........................................98
      8.1. Single-Use Tickets ........................................99
      8.2. Client Hello Recording ....................................99
      8.3. Freshness Checks .........................................101
   9. Compliance Requirements .......................................102
      9.1. Mandatory-to-Implement Cipher Suites .....................102
      9.2. Mandatory-to-Implement Extensions ........................103
      9.3. Protocol Invariants ......................................104
   10. Security Considerations ......................................106
   11. IANA Considerations ..........................................106
   12. References ...................................................109
      12.1. Normative References ....................................109
      12.2. Informative References ..................................112
   Appendix A. State Machine ........................................120
     A.1. Client ....................................................120
     A.2. Server ....................................................121
   Appendix B. Protocol Data Structures and Constant Values .........122
     B.1. Record Layer ..............................................122
     B.2. Alert Messages ............................................123
     B.3. Handshake Protocol ........................................124
       B.3.1. Key Exchange Messages .................................125
       B.3.2. Server Parameters Messages ............................131
       B.3.3. Authentication Messages ...............................132
       B.3.4. Ticket Establishment ..................................132
       B.3.5. Updating Keys .........................................133
     B.4. Cipher Suites .............................................133
   Appendix C. Implementation Notes .................................134
     C.1. Random Number Generation and Seeding ......................134
     C.2. Certificates and Authentication ...........................135
     C.3. Implementation Pitfalls ...................................135
     C.4. Client Tracking Prevention ................................137
     C.5. Unauthenticated Operation .................................137
   Appendix D. Backward Compatibility ...............................138
     D.1. Negotiating with an Older Server ..........................139
     D.2. Negotiating with an Older Client ..........................139
     D.3. 0-RTT Backward Compatibility ..............................140
     D.4. Middlebox Compatibility Mode ..............................140
     D.5. Security Restrictions Related to Backward Compatibility ...141
   Appendix E. Overview of Security Properties ......................142
     E.1. Handshake .................................................142
       E.1.1. Key Derivation and HKDF ...............................145
       E.1.2. Client Authentication .................................146
       E.1.3. 0-RTT .................................................146
       E.1.4. Exporter Independence .................................146
       E.1.5. Post-Compromise Security ..............................146
       E.1.6. External References ...................................147
     E.2. Record Layer ..............................................147
       E.2.1. External References ...................................148
     E.3. Traffic Analysis ..........................................148
     E.4. Side-Channel Attacks ......................................149
     E.5. Replay Attacks on 0-RTT ...................................150
       E.5.1. Replay and Exporters ..................................151
     E.6. PSK Identity Exposure .....................................152
     E.7. Sharing PSKs ..............................................152
     E.8. Attacks on Static RSA .....................................152
   Contributors .....................................................153
   Author's Address .................................................160
```

---
## **1.  Introduction**

TLS의 주요 목표는 통신하는 두 피어 간에 보안 채널을 제공하는 것입니다. 기본 전송의 유일한 요구 사항은 안정적이고 순서가 지정된 데이터 스트림입니다. 특히 보안 채널은 다음 속성을 제공해야 합니다.

- 인증: 채널의 서버 측이 항상 인증됩니다. 클라이언트 측은 선택적으로 인증됩니다. 인증은 비대칭 암호화\(예: RSA \[RSA\], 타원 곡선 디지털 서명 알고리즘\(ECDSA\) \[ECDSA\] 또는 Edwards-Curve 디지털 서명 알고리즘\(EdDSA\) \[RFC8032\]\) 또는 대칭 사전 공유 키\( PSK\).

- 기밀성: 설정 후 채널을 통해 전송된 데이터는 엔드포인트에서만 볼 수 있습니다. TLS는 전송하는 데이터의 길이를 숨기지 않습니다. 하지만 엔드포인트는 길이를 모호하게 하고 트래픽 분석 기술에 대한 보호를 강화하기 위해 TLS 레코드를 채울 수 있습니다.

- 무결성: 설정 후 채널을 통해 전송된 데이터는 탐지 없이 공격자에 의해 수정될 수 없습니다.

이러한 속성은 \[RFC3552\]에 설명된 대로 네트워크를 완전히 제어하는 ​​공격자의 입장에서도 사실이어야 합니다. 관련 보안 속성에 대한 보다 완전한 설명은 부록 E를 참조하십시오.

TLS는 두 가지 기본 구성 요소로 구성됩니다.

- 통신 당사자를 인증하고, 암호화 모드 및 매개변수를 협상하고, 공유 키 자료를 설정하는 핸드셰이크 프로토콜\(섹션 4\). 핸드셰이크 프로토콜은 변조를 방지하도록 설계되었습니다. 적극적인 공격자는 연결이 공격을 받지 않는 경우와 다른 매개변수를 협상하도록 피어에게 강요할 수 없어야 합니다.

- 통신 피어 간의 트래픽을 보호하기 위해 핸드셰이크 프로토콜에 의해 설정된 매개변수를 사용하는 기록 프로토콜\(섹션 5\). 레코드 프로토콜은 트래픽을 일련의 레코드로 나누고, 각 레코드는 트래픽 키를 사용하여 독립적으로 보호됩니다.

TLS는 애플리케이션 프로토콜에 독립적입니다. 더 높은 수준의 프로토콜은 TLS 위에 투명하게 계층화할 수 있습니다. 그러나 TLS 표준은 프로토콜이 TLS로 보안을 추가하는 방법을 지정하지 않습니다. TLS 핸드셰이킹을 시작하는 방법과 교환된 인증 인증서를 해석하는 방법은 TLS에서 실행되는 프로토콜의 설계자와 구현자의 판단에 맡겨져 있습니다.

이 문서는 TLS 버전 1.3을 정의합니다. TLS 1.3은 이전 버전과 직접 호환되지 않지만 TLS의 모든 버전은 클라이언트와 서버가 두 피어에서 지원하는 경우 공통 버전을 상호 운용 가능하게 협상할 수 있는 버전 관리 메커니즘을 통합합니다.

이 문서는 버전 1.2 \[RFC5246\]를 포함하여 TLS의 이전 버전을 대체하고 폐기합니다. 또한 \[RFC5077\]에 정의된 TLS 티켓 메커니즘을 폐기하고 섹션 2.2에 정의된 메커니즘으로 대체합니다. TLS 1.3은 키가 파생되는 방식을 변경하기 때문에 섹션 7.5에 설명된 대로 \[RFC5705\]를 업데이트합니다. 또한 OCSP\(Online Certificate Status Protocol\) 메시지가 전달되는 방식을 변경하므로 섹션 4.4.2.1에 설명된 대로 \[RFC6066\]을 업데이트하고 \[RFC6961\]을 폐기합니다.

---
### **1.1.  Conventions and Terminology**

키워드 "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY" 및 "OPTIONAL" "는 BCP 14 \[RFC2119\] \[RFC8174\]에 설명된 대로 여기에 표시된 것처럼 모두 대문자로 표시되는 경우에만 해석됩니다.\(MUST NOT\)

다음 용어가 사용됩니다.

클라이언트: TLS 연결을 시작하는 엔드포인트입니다.

연결: 두 끝점 간의 전송 계층 연결입니다.

끝점: 연결의 클라이언트 또는 서버입니다.

핸드셰이크: TLS 내에서 후속 상호 작용의 매개 변수를 설정하는 클라이언트와 서버 간의 초기 협상입니다.

피어: 끝점입니다. 특정 끝점을 논의할 때 "피어"는 논의의 기본 주제가 아닌 끝점을 나타냅니다.

수신자: 레코드를 수신하는 끝점입니다.

보낸 사람: 레코드를 전송하는 끝점입니다.

서버: TLS 연결을 시작하지 않은 엔드포인트입니다.

---
### **1.2.  Major Differences from TLS 1.2**

다음은 TLS 1.2와 TLS 1.3의 주요 기능 차이점 목록입니다. 완전하지 않으며 많은 사소한 차이점이 있습니다.

- 지원되는 대칭 암호화 알고리즘 목록에서 레거시로 간주되는 모든 알고리즘이 제거되었습니다. 남아 있는 것은 모두 AEAD\(Authenticated Encryption with Associated Data\) 알고리즘입니다. 인증 및 키 교환 메커니즘을 기록 보호 알고리즘\(비밀 키 길이 포함\)과 키 파생 기능 및 MAC\(핸드셰이크 메시지 인증 코드\) 모두와 함께 사용되는 해시에서 분리하도록 암호 제품군 개념이 변경되었습니다.

- 특정 보안 속성을 희생하면서 일부 애플리케이션 데이터에 대한 연결 설정 시 왕복 시간을 절약하는 제로 왕복 시간\(0-RTT\) 모드가 추가되었습니다.

- 정적 RSA 및 Diffie-Hellman 암호화 제품군이 제거되었습니다. 이제 모든 공개 키 기반 키 교환 메커니즘은 순방향 비밀성을 제공합니다.

- 이제 ServerHello 이후의 모든 핸드셰이크 메시지가 암호화됩니다. 새로 도입된 EncryptedExtensions 메시지를 사용하면 이전에 ServerHello에서 일반 형식으로 전송된 다양한 확장도 기밀 보호를 누릴 수 있습니다.

- 주요 파생 기능이 재설계되었습니다. 새로운 디자인을 사용하면 향상된 키 분리 속성으로 인해 암호 작성자가 더 쉽게 분석할 수 있습니다. HMAC 기반 HKDF\(추출 및 확장 키 파생 함수\)가 기본 기본 요소로 사용됩니다.

- 핸드셰이크 상태 머신은 보다 일관성을 유지하고 ChangeCipherSpec과 같은 불필요한 메시지를 제거하기 위해 크게 재구성되었습니다\(미들박스 호환성을 위해 필요한 경우 제외\).

- 이제 타원 곡선 알고리즘이 기본 사양에 포함되었으며 EdDSA와 같은 새로운 서명 알고리즘이 포함되었습니다. TLS 1.3에서는 각 곡선에 대한 단일 포인트 형식을 선호하여 포인트 형식 협상을 제거했습니다.

- RSASSA-PSS\(RSA 확률적 서명 체계\)를 사용하도록 RSA 패딩 변경, 압축 제거, DSA\(디지털 서명 알고리즘\) 및 사용자 정의 DHE\(임시 Diffie-Hellman\) 그룹을 포함하여 기타 암호화 개선이 이루어졌습니다.

- 확장의 버전 목록을 위해 TLS 1.2 버전 협상 메커니즘이 더 이상 사용되지 않습니다. 이를 통해 버전 협상을 잘못 구현한 기존 서버와의 호환성이 향상됩니다.

- 이전 TLS 버전의 PSK 기반 암호화 제품군뿐만 아니라 서버 측 상태 유무에 관계없이 세션 재개가 단일 새로운 PSK 교환으로 대체되었습니다.

- RFC의 업데이트된 버전을 적절하게 가리키도록 참조가 업데이트되었습니다\(예: RFC 3280이 아닌 RFC 5280\).

---
### **1.3.  Updates Affecting TLS 1.2**

이 문서는 TLS 1.3도 지원하지 않는 변경 사항을 포함하여 TLS 1.2의 구현에 선택적으로 영향을 미치는 몇 가지 변경 사항을 정의합니다.

- 버전 다운그레이드 보호 메커니즘은 섹션 4.1.3에 설명되어 있습니다.

- RSASSA-PSS 서명 체계는 섹션 4.2.3에 정의되어 있습니다.

- "supported\_versions" ClientHello 확장을 사용하면 ClientHello의 Legacy\_version 필드보다 사용할 TLS 버전을 협상할 수 있습니다.

- "signature\_algorithms\_cert" 확장을 사용하면 클라이언트가 X.509 인증서에서 유효성을 검사할 수 있는 서명 알고리즘을 나타낼 수 있습니다.

또한 이 문서는 이전 버전의 TLS에 대한 일부 규정 준수 요구 사항을 설명합니다. 섹션 9.3을 참조하십시오.

---
## **2.  Protocol Overview**

보안 채널에서 사용하는 암호화 매개변수는 TLS 핸드셰이크 프로토콜에서 생성됩니다. TLS의 이 하위 프로토콜은 처음 서로 통신할 때 클라이언트와 서버에서 사용됩니다. 핸드셰이크 프로토콜을 사용하면 피어가 프로토콜 버전을 협상하고, 암호화 알고리즘을 선택하고, 선택적으로 서로를 인증하고, 공유 비밀 키 자료를 설정할 수 있습니다. 핸드셰이크가 완료되면 피어는 설정된 키를 사용하여 애플리케이션 계층 트래픽을 보호합니다.

핸드셰이크 실패 또는 기타 프로토콜 오류는 연결 종료를 트리거하며 선택적으로 경고 메시지가 선행됩니다\(섹션 6\).

```text
   TLS supports three basic key exchange modes:
```

- \(EC\)DHE\(유한장 또는 타원 곡선에 대한 Diffie-Hellman\)

```text
   -  PSK-only
```

- \(EC\)DHE를 사용한 PSK

아래 그림 1은 기본 전체 TLS 핸드셰이크를 보여줍니다.

```text
       Client                                           Server

Key  ^ ClientHello
Exch | + key_share*
     | + signature_algorithms*
     | + psk_key_exchange_modes*
     v + pre_shared_key*       -------->
                                                  ServerHello  ^ Key
                                                 + key_share*  | Exch
                                            + pre_shared_key*  v
                                        {EncryptedExtensions}  ^  Server
                                        {CertificateRequest*}  v  Params
                                               {Certificate*}  ^
                                         {CertificateVerify*}  | Auth
                                                   {Finished}  v
                               <--------  [Application Data*]
     ^ {Certificate*}
Auth | {CertificateVerify*}
     v {Finished}              -------->
       [Application Data]      <------->  [Application Data]

              +  Indicates noteworthy extensions sent in the
                 previously noted message.

              *  Indicates optional or situation-dependent
                 messages/extensions that are not always sent.

              {} Indicates messages protected using keys
                 derived from a [sender]_handshake_traffic_secret.

              [] Indicates messages protected using keys
                 derived from [sender]_application_traffic_secret_N.

               Figure 1: Message Flow for Full TLS Handshake
```

핸드셰이크는 3단계로 생각할 수 있습니다\(위 다이어그램에 표시됨\).

- 키 교환: 공유 키 자료를 설정하고 암호화 매개변수를 선택합니다. 이 단계 이후의 모든 내용은 암호화됩니다.

- 서버 매개변수: 기타 핸드셰이크 매개변수\(클라이언트 인증 여부, 애플리케이션 계층 프로토콜 지원 등\)를 설정합니다.

- 인증: 서버\(및 선택적으로 클라이언트\)를 인증하고 키 확인 및 핸드셰이크 무결성을 제공합니다.

키 교환 단계에서 클라이언트는 임의의 nonce\(ClientHello.random\)를 포함하는 ClientHello\(섹션 4.1.2\) 메시지를 보냅니다. 제공되는 프로토콜 버전 대칭 암호/HKDF 해시 쌍 목록 Diffie-Hellman 키 공유 집합\("key\_share"\(섹션 4.2.8\) 확장\), 미리 공유된 키 레이블 집합\("pre\_shared\_key"\(섹션 4.2.11\) 확장\) 또는 둘 다. 잠재적으로 추가 확장. 추가 필드 및/또는 메시지는 미들박스 호환성을 위해 존재할 수도 있습니다.

서버는 ClientHello를 처리하고 연결에 적합한 암호화 매개변수를 결정합니다. 그런 다음 협상된 연결 매개변수를 나타내는 자체 ServerHello\(섹션 4.1.3\)로 응답합니다. ClientHello와 ServerHello의 조합이 공유 키를 결정합니다. \(EC\)DHE 키 설정이 사용 중인 경우 ServerHello에는 서버의 임시 Diffie-Hellman 공유와 함께 "key\_share" 확장이 포함됩니다. 서버의 공유는 클라이언트의 공유 중 하나와 동일한 그룹에 있어야 합니다. PSK 키 설정이 사용 중인 경우 ServerHello에는 클라이언트의 제공된 PSK 중 어느 것이 선택되었는지 나타내는 "pre\_shared\_key" 확장이 포함됩니다. 구현 시 \(EC\)DHE와 PSK를 함께 사용할 수 있으며, 이 경우 두 확장이 모두 제공됩니다.\(MUST\)

그런 다음 서버는 서버 매개변수를 설정하기 위해 두 개의 메시지를 보냅니다.

EncryptedExtensions: 개별 인증서에 특정한 것 외에 암호화 매개변수를 결정하는 데 필요하지 않은 ClientHello 확장에 대한 응답입니다. \[섹션 4.3.1\]

CertificateRequest: 인증서 기반 클라이언트 인증이 필요한 경우 해당 인증서에 대해 원하는 매개변수입니다. 클라이언트 인증을 원하지 않는 경우 이 메시지는 생략됩니다. \[섹션 4.3.2\]

마지막으로 클라이언트와 서버는 인증 메시지를 교환합니다. TLS는 인증서 기반 인증이 필요할 때마다 동일한 메시지 집합을 사용합니다. \(PSK 기반 인증은 키 교환의 부작용으로 발생합니다.\) 구체적으로:

인증서: 끝점의 인증서 및 인증서별 확장입니다. 이 메시지는 인증서로 인증하지 않은 경우 서버에서 생략하고 서버가 CertificateRequest를 보내지 않은 경우\(따라서 클라이언트가 인증서로 인증하지 않아야 함을 나타냄\) 클라이언트에서 생략합니다. 원시 공개 키\[RFC7250\] 또는 캐시된 정보 확장자\[RFC7924\]가 사용 중인 경우 이 메시지에는 인증서가 포함되지 않고 서버의 장기 키에 해당하는 다른 값이 포함됩니다. \[섹션 4.4.2\]

CertificateVerify: 인증서 메시지의 공개 키에 해당하는 개인 키를 사용하여 전체 핸드셰이크에 대한 서명입니다. 엔드포인트가 인증서를 통해 인증하지 않는 경우 이 메시지는 생략됩니다. \[섹션 4.4.3\]

Finished: 전체 핸드셰이크에 대한 MAC\(Message Authentication Code\). 이 메시지는 키 확인을 제공하고 엔드포인트의 ID를 교환된 키에 바인딩하며 PSK 모드에서도 핸드셰이크를 인증합니다. \[섹션 4.4.4\]

서버의 메시지를 수신하면 클라이언트는 인증 메시지, 즉 Certificate 및 CertificateVerify\(요청된 경우\) 및 Finished로 응답합니다.

이 시점에서 핸드셰이크가 완료되고 클라이언트와 서버는 인증된 암호화를 통해 보호되는 애플리케이션 계층 데이터를 교환하기 위해 레코드 계층에 필요한 키 자료를 도출합니다. 애플리케이션 데이터는 섹션 2.3에 지정된 경우를 제외하고 Finished 메시지를 보내기 전에 보내서는 안 됩니다\(MUST NOT\). 서버는 클라이언트의 인증 메시지를 수신하기 전에 애플리케이션 데이터를 보낼 수 있지만 해당 시점에 전송된 모든 데이터는 물론 인증되지 않은 피어로 전송됩니다.\(MUST NOT\)

---
### **2.1.  Incorrect DHE Share**

클라이언트가 충분한 "key\_share" 확장을 제공하지 않은 경우\(예: 서버에서 허용할 수 없거나 서버에서 지원하지 않는 DHE 또는 ECDHE 그룹만 포함\) 서버는 HelloRetryRequest로 불일치를 수정하고 클라이언트는 적절한 핸드셰이크를 다시 시작해야 합니다. 그림 2와 같이 "key\_share" 확장. 협상할 수 있는 공통 암호화 매개변수가 없으면 서버는 적절한 경고와 함께 핸드셰이크를 중단해야 합니다.\(MUST\)

```text
        Client                                               Server

        ClientHello
        + key_share             -------->
                                                  HelloRetryRequest
                                <--------               + key_share
        ClientHello
        + key_share             -------->
                                                        ServerHello
                                                        + key_share
                                              {EncryptedExtensions}
                                              {CertificateRequest*}
                                                     {Certificate*}
                                               {CertificateVerify*}
                                                         {Finished}
                                <--------       [Application Data*]
        {Certificate*}
        {CertificateVerify*}
        {Finished}              -------->
        [Application Data]      <------->        [Application Data]

             Figure 2: Message Flow for a Full Handshake with
                           Mismatched Parameters
```

참고: 핸드셰이크 기록은 초기 ClientHello/HelloRetryRequest 교환을 통합합니다. 새 ClientHello로 재설정되지 않습니다.

또한 TLS는 다음 섹션에 설명된 대로 기본 핸드셰이크의 여러 가지 최적화된 변형을 허용합니다.

---
### **2.2.  Resumption and Pre-Shared Key (PSK)**

대역외에서 TLS PSK를 설정할 수 있지만 이전 연결에서 PSK를 설정한 다음 새 연결을 설정하는 데 사용할 수도 있습니다\(PSK를 사용하여 "세션 재개" 또는 "재개"\). 핸드셰이크가 완료되면 서버는 초기 핸드셰이크에서 파생된 고유 키에 해당하는 PSK ID를 클라이언트에 보낼 수 있습니다\(섹션 4.6.1 참조\). 그런 다음 클라이언트는 연결된 PSK의 사용을 협상하기 위해 향후 핸드셰이크에서 해당 PSK ID를 사용할 수 있습니다. 서버가 PSK를 수락하면 새 연결의 보안 컨텍스트가 원래 연결에 암호화 방식으로 연결되고 초기 핸드셰이크에서 파생된 키가 전체 핸드셰이크 대신 암호화 상태를 부트스트랩하는 데 사용됩니다. TLS 1.2 이하에서 이 기능은 "세션 ID" 및 "세션 티켓" \[RFC5077\]에 의해 제공되었습니다. 두 메커니즘 모두 TLS 1.3에서 더 이상 사용되지 않습니다.

PSK는 \(EC\)DHE 키 교환과 함께 사용하여 공유 키와 함께 순방향 비밀성을 제공하거나 응용 프로그램 데이터에 대한 순방향 비밀성을 잃는 대가로 단독으로 사용할 수 있습니다.

그림 3은 첫 번째 핸드셰이크가 PSK를 설정하고 두 번째 핸드셰이크가 PSK를 사용하는 한 쌍의 핸드셰이크를 보여줍니다.

```text
          Client                                               Server

   Initial Handshake:
          ClientHello
          + key_share               -------->
                                                          ServerHello
                                                          + key_share
                                                {EncryptedExtensions}
                                                {CertificateRequest*}
                                                       {Certificate*}
                                                 {CertificateVerify*}
                                                           {Finished}
                                    <--------     [Application Data*]
          {Certificate*}
          {CertificateVerify*}
          {Finished}                -------->
                                    <--------      [NewSessionTicket]
          [Application Data]        <------->      [Application Data]

   Subsequent Handshake:
          ClientHello
          + key_share*
          + pre_shared_key          -------->
                                                          ServerHello
                                                     + pre_shared_key
                                                         + key_share*
                                                {EncryptedExtensions}
                                                           {Finished}
                                    <--------     [Application Data*]
          {Finished}                -------->
          [Application Data]        <------->      [Application Data]

               Figure 3: Message Flow for Resumption and PSK
```

서버는 PSK를 통해 인증하므로 Certificate 또는 CertificateVerify 메시지를 보내지 않습니다. 클라이언트가 PSK를 통해 재개를 제공할 때 서버가 재개를 거부하고 필요한 경우 전체 핸드셰이크로 폴백할 수 있도록 서버에 "key\_share" 확장도 제공해야 합니다\(SHOULD\). 서버는 "pre\_shared\_key" 확장으로 응답하여 PSK 키 설정 사용을 협상하고 \(여기에 표시된 대로\) "key\_share" 확장으로 응답하여 \(EC\)DHE 키 설정을 수행함으로써 순방향 보안을 제공할 수 있습니다.\(SHOULD\)

PSK가 대역 외 프로비저닝되면 PSK ID와 PSK와 함께 사용할 KDF 해시 알고리즘도 프로비저닝되어야 합니다.\(MUST\)

참고: 대역 외 프로비저닝된 사전 공유 암호를 사용할 때 중요한 고려 사항은 \[RFC4086\]에서 논의된 것처럼 키 생성 중에 충분한 엔트로피를 사용하는 것입니다. 암호 또는 다른 낮은 엔트로피 소스에서 공유 비밀을 파생시키는 것은 안전하지 않습니다. 엔트로피가 낮은 비밀 또는 암호는 PSK 바인더를 기반으로 하는 사전 공격의 대상이 됩니다. 지정된 PSK 인증은 Diffie-Hellman 키 설정과 함께 사용되는 경우에도 강력한 암호 기반 인증 키 교환이 아닙니다. 특히 핸드셰이크를 관찰할 수 있는 공격자가 암호/사전 공유 키에 대해 무차별 대입 공격을 수행하는 것을 방지하지 않습니다.

---
### **2.3.  0-RTT Data**

클라이언트와 서버가 PSK\(외부에서 얻거나 이전 핸드셰이크를 통해 획득\)를 공유할 때 TLS 1.3은 클라이언트가 첫 번째 비행\("초기 데이터"\)에서 데이터를 보낼 수 있도록 합니다. 클라이언트는 PSK를 사용하여 서버를 인증하고 초기 데이터를 암호화합니다.

그림 4에서 볼 수 있듯이 0-RTT 데이터는 첫 번째 비행에서 1-RTT 핸드셰이크에 추가됩니다. 나머지 핸드셰이크는 PSK 재개와 함께 1-RTT 핸드셰이크와 동일한 메시지를 사용합니다.

```text
         Client                                               Server

         ClientHello
         + early_data
         + key_share*
         + psk_key_exchange_modes
         + pre_shared_key
         (Application Data*)     -------->
                                                         ServerHello
                                                    + pre_shared_key
                                                        + key_share*
                                               {EncryptedExtensions}
                                                       + early_data*
                                                          {Finished}
                                 <--------       [Application Data*]
         (EndOfEarlyData)
         {Finished}              -------->
         [Application Data]      <------->        [Application Data]

               +  Indicates noteworthy extensions sent in the
                  previously noted message.

               *  Indicates optional or situation-dependent
                  messages/extensions that are not always sent.

               () Indicates messages protected using keys
                  derived from a client_early_traffic_secret.

               {} Indicates messages protected using keys
                  derived from a [sender]_handshake_traffic_secret.

               [] Indicates messages protected using keys
                  derived from [sender]_application_traffic_secret_N.

               Figure 4: Message Flow for a 0-RTT Handshake
```

중요 참고 사항: 0-RTT 데이터의 보안 속성은 다른 종류의 TLS 데이터의 보안 속성보다 약합니다. 구체적으로:

1. 이 데이터는 제공된 PSK를 사용하여 파생된 키로만 암호화되므로 순방향 비밀이 아닙니다.

2. 연결 사이에 재생되지 않는다는 보장은 없습니다. 일반 TLS 1.3 1-RTT 데이터에 대한 재생 방지는 서버의 Random 값을 통해 제공되지만 0-RTT 데이터는 ServerHello에 의존하지 않으므로 보장이 약합니다. 이는 데이터가 TLS 클라이언트 인증 또는 애플리케이션 프로토콜 내부에서 인증된 경우 특히 관련이 있습니다. early\_exporter\_master\_secret의 모든 사용에 동일한 경고가 적용됩니다.

0-RTT 데이터는 연결 내에서 복제될 수 없으며\(즉, 서버는 동일한 연결에 대해 동일한 데이터를 두 번 처리하지 않음\) 공격자는 0-RTT 데이터를 1-RTT 데이터로 보이게 할 수 없습니다\(왜냐하면 다른 키로 보호됩니다\). 부록 E.5에는 잠재적인 공격에 대한 설명이 포함되어 있으며 섹션 8에서는 서버가 재생의 영향을 제한하는 데 사용할 수 있는 메커니즘을 설명합니다.

---
## **3.  Presentation Language**

이 문서는 외부 표현의 데이터 형식을 다룹니다. 다음의 매우 기본적이고 다소 캐주얼하게 정의된 프레젠테이션 구문이 사용됩니다.

---
### **3.1.  Basic Block Size**

모든 데이터 항목의 표현은 명시적으로 지정됩니다. 기본 데이터 블록 크기는 1바이트\(즉, 8비트\)입니다. 다중 바이트 데이터 항목은 왼쪽에서 오른쪽으로, 위에서 아래로 바이트를 연결한 것입니다. 바이트 스트림에서 멀티바이트 항목\(다음 예제의 숫자\)은 다음과 같이 구성됩니다\(C 표기법 사용\).

```text
      value = (byte[0] << 8*(n-1)) | (byte[1] << 8*(n-2)) |
              ... | byte[n-1];
```

멀티바이트 값에 대한 이 바이트 순서는 일반적인 네트워크 바이트 순서 또는 빅 엔디안 형식입니다.

---
### **3.2.  Miscellaneous**

주석은 "/\*"로 시작하고 "\*/"로 끝납니다.

선택적 구성 요소는 "\[\[ \]\]"\(이중 괄호\)로 묶어 표시합니다.

해석되지 않은 데이터를 포함하는 1바이트 엔터티는 불투명한 유형입니다.

기존 유형 T에 대한 유형 별명 T'는 다음과 같이 정의됩니다.

```text
      T T';
```

---
### **3.3.  Numbers**

기본 숫자 데이터 유형은 부호 없는 바이트\(uint8\)입니다. 모든 더 큰 숫자 데이터 유형은 섹션 3.1에 설명된 대로 연결된 고정 길이 일련의 바이트로 구성되며 부호도 없습니다. 다음 숫자 유형은 미리 정의되어 있습니다.

```text
      uint8 uint16[2];
      uint8 uint24[3];
      uint8 uint32[4];
      uint8 uint64[8];
```

여기와 사양의 다른 모든 값은 네트워크 바이트\(빅 엔디안\) 순서로 전송됩니다. 16진수 바이트 01 02 03 04로 표시되는 uint32는 10진수 값 16909060과 동일합니다.

---
### **3.4.  Vectors**

벡터\(1차원 배열\)는 동종 데이터 요소의 스트림입니다. 벡터의 크기는 문서화 시 지정되거나 런타임까지 지정되지 않은 상태로 남을 수 있습니다. 두 경우 모두 길이는 벡터의 요소 수가 아니라 바이트 수를 선언합니다. 유형 T의 고정 길이 벡터인 새 유형 T'를 지정하기 위한 구문은 다음과 같습니다.

```text
      T T'[n];
```

여기서 T'는 데이터 스트림에서 n바이트를 차지하며, 여기서 n은 T 크기의 배수입니다. 벡터의 길이는 인코딩된 스트림에 포함되지 않습니다.

다음 예에서 Datum은 프로토콜이 해석하지 않는 3개의 연속 바이트로 정의되는 반면 Data는 3개의 연속 Datum으로 총 9바이트를 소비합니다.

```text
      opaque Datum[3];      /* three uninterpreted bytes */
      Datum Data[9];        /* three consecutive 3-byte vectors */
```

가변 길이 벡터는 <floor..ceiling\> 표기법을 사용하여 법적 길이의 하위 범위를 지정하여 정의됩니다. 이것이 인코딩될 때 실제 길이는 바이트 스트림에서 벡터의 내용 앞에 옵니다. 길이는 벡터의 지정된 최대\(천장\) 길이를 유지하는 데 필요한 만큼의 바이트를 소비하는 숫자 형식입니다. 실제 길이 필드가 0인 가변 길이 벡터를 빈 벡터라고 합니다.

```text
      T T'<floor..ceiling>;
```

다음 예에서 "mandatory"는 불투명 유형의 300\~400바이트를 포함해야 하는 벡터입니다. 절대 비워둘 수 없습니다. 실제 길이 필드는 값 400을 나타내기에 충분한 uint16이라는 2바이트를 사용합니다\(섹션 3.3 참조\). 마찬가지로 "longer"는 최대 800바이트의 데이터 또는 400개의 uint16 요소를 나타낼 수 있으며 비어 있을 수 있습니다. 해당 인코딩에는 벡터 앞에 추가된 2바이트 실제 길이 필드가 포함됩니다. 인코딩된 벡터의 길이는 단일 요소 길이의 정확한 배수여야 합니다\(예: uint16의 17바이트 벡터는 불법임\).

```text
      opaque mandatory<300..400>;
            /* length field is two bytes, cannot be empty */
      uint16 longer<0..800>;
            /* zero to 400 16-bit unsigned integers */
```

---
### **3.5.  Enumerateds**

"enum" 또는 "enumerated"라는 추가 희소 데이터 유형을 사용할 수 있습니다. 각 정의는 다른 유형입니다. 동일한 유형의 열거형만 할당하거나 비교할 수 있습니다. 열거형의 모든 요소에는 다음 예제와 같이 값이 할당되어야 합니다. 열거된 요소는 순서가 없기 때문에 순서에 관계없이 고유한 값을 할당할 수 있습니다.

```text
      enum { e1(v1), e2(v2), ... , en(vn) [[, (n)]] } Te;
```

프로토콜에 대한 향후 확장 또는 추가는 새로운 값을 정의할 수 있습니다. 구현은 필드 정의가 달리 명시하지 않는 한 알 수 없는 값을 구문 분석하고 무시할 수 있어야 합니다.

열거형은 정의된 최대 서수 값만큼 바이트 스트림에서 많은 공간을 차지합니다. 다음 정의는 색상 유형의 필드를 전달하는 데 1바이트가 사용되도록 합니다.

```text
      enum { red(3), blue(5), white(7) } Color;
```

불필요한 요소를 정의하지 않고 너비 정의를 강제하기 위해 관련 태그 없이 값을 선택적으로 지정할 수 있습니다.

다음 예에서 Taste는 데이터 스트림에서 2바이트를 사용하지만 현재 버전의 프로토콜에서는 값 1, 2 또는 4만 가정할 수 있습니다.

```text
      enum { sweet(1), sour(2), bitter(4), (32000) } Taste;
```

열거형 요소의 이름은 정의된 유형 내에서 범위가 지정됩니다. 첫 번째 예에서 열거형의 두 번째 요소에 대한 정규화된 참조는 Color.blue입니다. 과제의 대상이 잘 지정된 경우에는 이러한 자격이 필요하지 않습니다.

```text
      Color color = Color.blue;     /* overspecified, legal */
      Color color = blue;           /* correct, type implicit */
```

열거형에 할당된 이름은 고유하지 않아도 됩니다. 숫자 값은 동일한 이름이 적용되는 범위를 설명할 수 있습니다. 이 값에는 마침표 두 개로 구분된 해당 범위의 최소값과 최대값이 포함됩니다. 이것은 주로 공간의 영역을 예약하는 데 유용합니다.

```text
      enum { sad(0), meh(1..254), happy(255) } Mood;
```

---
### **3.6.  Constructed Types**

편의상 기본 유형에서 구조 유형을 구성할 수 있습니다. 각 사양은 새롭고 고유한 유형을 선언합니다. 정의에 사용되는 구문은 C의 구문과 매우 유사합니다.

```text
      struct {
          T1 f1;
          T2 f2;
          ...
          Tn fn;
      } T;
```

고정 및 가변 길이 벡터 필드는 표준 벡터 구문을 사용하여 허용됩니다. 변형 예제\(섹션 3.8\)의 구조 V1 및 V2는 이를 보여줍니다.

구조 내의 필드는 열거에 사용할 수 있는 것과 매우 유사한 구문으로 유형의 이름을 사용하여 한정될 수 있습니다. 예를 들어 T.f2는 이전 선언의 두 번째 필드를 나타냅니다.

---
### **3.7.  Constants**

다음과 같이 "="를 사용하여 필드와 변수에 고정 값을 할당할 수 있습니다.

```text
      struct {
          T1 f1 = 8;  /* T.f1 must always be 8 */
          T2 f2;
      } T;
```

---
### **3.8.  Variants**

정의된 구조에는 환경 내에서 사용할 수 있는 일부 지식을 기반으로 하는 변형이 있을 수 있습니다. 선택자는 구조가 정의하는 가능한 변형을 정의하는 열거 유형이어야 합니다. 선택 항목\(아래\)의 각 암은 해당 변형 필드의 유형과 선택적 필드 레이블을 지정합니다. 런타임 시 변형이 선택되는 메커니즘은 프레젠테이션 언어로 규정되지 않습니다.

```text
      struct {
          T1 f1;
          T2 f2;
          ....
          Tn fn;
          select (E) {
              case e1: Te1 [[fe1]];
              case e2: Te2 [[fe2]];
              ....
              case en: Ten [[fen]];
          };
      } Tv;
```

예를 들어:

```text
      enum { apple(0), orange(1) } VariantTag;

      struct {
          uint16 number;
          opaque string<0..10>; /* variable length */
      } V1;

      struct {
          uint32 number;
          opaque string[10];    /* fixed length */
      } V2;

      struct {
          VariantTag type;
          select (VariantRecord.type) {
              case apple:  V1;
              case orange: V2;
          };
      } VariantRecord;
```

---
## **4.  Handshake Protocol**

핸드셰이크 프로토콜은 연결의 보안 매개변수를 협상하는 데 사용됩니다. 핸드셰이크 메시지는 현재 활성 연결 상태에 지정된 대로 처리되고 전송되는 하나 이상의 TLSPlaintext 또는 TLSCiphertext 구조 내에서 캡슐화되는 TLS 레코드 레이어에 제공됩니다.

```text
      enum {
          client_hello(1),
          server_hello(2),
          new_session_ticket(4),
          end_of_early_data(5),
          encrypted_extensions(8),
          certificate(11),
          certificate_request(13),
          certificate_verify(15),
          finished(20),
          key_update(24),
          message_hash(254),
          (255)
      } HandshakeType;

      struct {
          HandshakeType msg_type;    /* handshake type */
          uint24 length;             /* remaining bytes in message */
          select (Handshake.msg_type) {
              case client_hello:          ClientHello;
              case server_hello:          ServerHello;
              case end_of_early_data:     EndOfEarlyData;
              case encrypted_extensions:  EncryptedExtensions;
              case certificate_request:   CertificateRequest;
              case certificate:           Certificate;
              case certificate_verify:    CertificateVerify;
              case finished:              Finished;
              case new_session_ticket:    NewSessionTicket;
              case key_update:            KeyUpdate;
          };
      } Handshake;
```

프로토콜 메시지는 섹션 4.4.1에 정의되고 섹션 2의 다이어그램에 표시된 순서대로 전송되어야 합니다. 예기치 않은 순서로 핸드셰이크 메시지를 수신하는 피어는 "unexpected\_message" 경고와 함께 핸드셰이크를 중단해야 합니다.\(MUST, MUST\)

새로운 핸드셰이크 메시지 유형은 섹션 11에 설명된 대로 IANA에 의해 할당됩니다.

---
### **4.1.  Key Exchange Messages**

키 교환 메시지는 클라이언트와 서버의 보안 기능을 결정하고 나머지 핸드셰이크와 데이터를 보호하는 데 사용되는 트래픽 키를 포함하여 공유 비밀을 설정하는 데 사용됩니다.

---
#### **4.1.1.  Cryptographic Negotiation**

TLS에서 암호화 협상은 ClientHello에서 다음 네 가지 옵션 세트를 제공하는 클라이언트에 의해 진행됩니다.

- 클라이언트가 지원하는 AEAD 알고리즘/HKDF 해시 쌍을 나타내는 암호 제품군 목록입니다.

- 클라이언트가 지원하는 \(EC\)DHE 그룹을 나타내는 "supported\_groups"\(섹션 4.2.7\) 확장 및 이러한 그룹 중 일부 또는 전부에 대한 \(EC\)DHE 공유를 포함하는 "key\_share"\(섹션 4.2.8\) 확장 .

- 클라이언트가 수락할 수 있는 서명 알고리즘을 나타내는 "signature\_algorithms"\(섹션 4.2.3\) 확장입니다. 인증서별 서명 알고리즘을 나타내기 위해 "signature\_algorithms\_cert" 확장\(섹션 4.2.3\)을 추가할 수도 있습니다.

- 클라이언트에 알려진 대칭 키 ID 목록을 포함하는 "pre\_shared\_key"\(섹션 4.2.11\) 확장과 PSK와 함께 사용할 수 있는 키 교환 모드를 나타내는 "psk\_key\_exchange\_modes"\(섹션 4.2.9\) 확장.

서버가 PSK를 선택하지 않으면 이러한 옵션 중 처음 세 개는 완전히 직교합니다. 즉, 서버는 암호 그룹, 키 설정을 위한 \(EC\)DHE 그룹 및 키 공유, 인증을 위한 서명 알고리즘/인증서 쌍을 독립적으로 선택합니다. 클라이언트에게. 수신된 "supported\_groups"와 서버에서 지원하는 그룹 사이에 겹치는 부분이 없으면 서버는 "handshake\_failure" 또는 "insufficient\_security" 경고와 함께 핸드셰이크를 중단해야 합니다.\(MUST\)

서버가 PSK를 선택하면 클라이언트의 "psk\_key\_exchange\_modes" 확장이 나타내는 세트에서 키 설정 모드도 선택해야 합니다\(현재 PSK 단독 또는 \(EC\)DHE 포함\). PSK를 \(EC\)DHE 없이 사용할 수 있는 경우 "supported\_groups" 매개변수의 비중첩이 치명적일 필요는 없습니다. 이는 이전 단락에서 논의된 PSK가 아닌 경우와 같습니다.\(MUST\)

서버가 \(EC\)DHE 그룹을 선택하고 클라이언트가 초기 ClientHello에서 호환되는 "key\_share" 확장을 제공하지 않은 경우 서버는 HelloRetryRequest\(섹션 4.1.4\) 메시지로 응답해야 합니다.\(MUST\)

서버가 매개변수를 성공적으로 선택하고 HelloRetryRequest가 필요하지 않은 경우 다음과 같이 ServerHello에서 선택된 매개변수를 나타냅니다.

- PSK를 사용하는 경우 서버는 선택한 키를 나타내는 "pre\_shared\_key" 확장을 보냅니다.

- \(EC\)DHE를 사용하는 경우 서버는 "key\_share" 확장도 제공합니다. PSK를 사용하지 않는 경우 \(EC\)DHE 및 인증서 기반 인증이 항상 사용됩니다.

- 인증서를 통해 인증할 때 서버는 인증서\(섹션 4.4.2\) 및 CertificateVerify\(섹션 4.4.3\) 메시지를 보냅니다. 이 문서에 정의된 대로 TLS 1.3에서는 PSK 또는 인증서 중 하나가 항상 사용되지만 둘 다 사용되지는 않습니다. 향후 문서에서는 이를 함께 사용하는 방법을 정의할 수 있습니다.

서버가 지원되는 매개변수 집합을 협상할 수 없는 경우\(즉, 클라이언트와 서버 매개변수 사이에 겹치는 부분이 없음\) "handshake\_failure" 또는 "insufficient\_security" 치명적 경고로 핸드셰이크를 중단해야 합니다\(섹션 6 참조\).\(MUST\)

---
#### **4.1.2.  Client Hello**

클라이언트가 처음 서버에 연결할 때 첫 번째 TLS 메시지로 ClientHello를 보내는 것이 필요합니다. 클라이언트는 또한 서버가 HelloRetryRequest로 ClientHello에 응답했을 때 ClientHello를 보냅니다. 이 경우 클라이언트는 다음을 제외하고 수정 없이 동일한 ClientHello를 보내야 합니다.\(MUST, MUST\)

- HelloRetryRequest에 "key\_share" 확장이 제공된 경우 공유 목록을 표시된 그룹의 단일 KeyShareEntry가 포함된 목록으로 바꿉니다.

- "early\_data" 확장\(섹션 4.2.10\)이 있는 경우 제거합니다. HelloRetryRequest 이후에는 초기 데이터가 허용되지 않습니다.

- HelloRetryRequest에 제공된 경우 "쿠키" 확장을 포함합니다.

- "obfuscated\_ticket\_age" 및 바인더 값을 다시 계산하고 \(선택적으로\) 서버에 표시된 암호화 제품군과 호환되지 않는 PSK를 제거하여 "pre\_shared\_key" 확장이 있는 경우 업데이트합니다.

- 선택적으로 "패딩" 확장 \[RFC7685\]의 길이를 추가, 제거 또는 변경합니다.

- 향후 정의되고 HelloRetryRequest에 있는 확장에 의해 허용될 수 있는 기타 수정.

TLS 1.3은 재협상을 금지하기 때문에 서버가 TLS 1.3을 협상하고 다른 시간에 ClientHello를 수신하는 경우 "unexpected\_message" 경고와 함께 연결을 종료해야 합니다.\(MUST\)

서버가 이전 버전의 TLS와 TLS 연결을 설정하고 재협상에서 TLS 1.3 ClientHello를 수신하는 경우 이전 프로토콜 버전을 유지해야 합니다. 특히 TLS 1.3을 협상하면 안 됩니다\(MUST NOT\).\(MUST, MUST NOT\)

이 메시지의 구조:

```text
      uint16 ProtocolVersion;
      opaque Random[32];

      uint8 CipherSuite[2];    /* Cryptographic suite selector */

      struct {
          ProtocolVersion legacy_version = 0x0303;    /* TLS v1.2 */
          Random random;
          opaque legacy_session_id<0..32>;
          CipherSuite cipher_suites<2..2^16-2>;
          opaque legacy_compression_methods<1..2^8-1>;
          Extension extensions<8..2^16-1>;
      } ClientHello;
```

legacy\_version: 이전 버전의 TLS에서 이 필드는 버전 협상에 사용되었으며 클라이언트에서 지원하는 가장 높은 버전 번호를 나타냅니다. 경험에 따르면 많은 서버가 버전 협상을 제대로 구현하지 않아 서버가 지원하는 것보다 높은 버전 번호로 허용되는 ClientHello를 거부하는 "버전 불내성"이 발생합니다. TLS 1.3에서 클라이언트는 "supported\_versions" 확장\(섹션 4.2.1\)에 버전 기본 설정을 표시하고 legacy\_version 필드는 TLS 1.2의 버전 번호인 0x0303으로 설정해야 합니다. TLS 1.3 ClientHellos는 0x0303의 legacy\_version 및 거기에 표시된 가장 높은 버전으로 0x0304와 함께 존재하는 supported\_versions 확장을 갖는 것으로 식별됩니다. \(이전 버전과의 호환성에 대한 자세한 내용은 부록 D를 참조하십시오.\)\(MUST\)

무작위: 보안 난수 생성기에 의해 생성된 32바이트. 추가 정보는 부록 C를 참조하십시오.

legacy\_session\_id: TLS 1.3 이전의 TLS 버전은 이 버전에서 사전 공유 키와 병합된 "세션 재개" 기능을 지원했습니다\(섹션 2.2 참조\). TLS 1.3 이전 서버에 의해 설정된 캐시된 세션 ID가 있는 클라이언트는 이 필드를 해당 값으로 설정해야 합니다\(SHOULD\). 호환성 모드\(부록 D.4 참조\)에서 이 필드는 비어 있지 않아야 하므로 TLS 1.3 이전 세션을 제공하지 않는 클라이언트는 새로운 32바이트 값을 생성해야 합니다. 이 값은 무작위일 필요는 없지만 구현이 특정 값에 고정되는 것을 방지하기 위해 예측할 수 없어야 합니다\(골화라고도 함\). 그렇지 않으면 길이가 0인 벡터\(즉, 값이 0인 단일 바이트 길이 필드\)로 설정되어야 합니다.\(SHOULD, MUST, SHOULD, MUST\)

cipher\_suites: 클라이언트가 지원하는 대칭 암호 옵션 목록, 특히 레코드 보호 알고리즘\(비밀 키 길이 포함\) 및 HKDF와 함께 사용할 해시\(클라이언트 기본 설정 내림차순\). 값은 부록 B.4에 정의되어 있습니다. 목록에 서버가 인식, 지원하지 않거나 사용을 원하지 않는 암호 그룹이 포함된 경우 서버는 해당 암호 그룹을 무시하고 평소와 같이 나머지 암호 그룹을 처리해야 합니다. 클라이언트가 PSK 키 설정을 시도하는 경우 PSK와 연결된 해시를 나타내는 하나 이상의 암호 제품군을 알려야 합니다\(SHOULD\).\(MUST, SHOULD\)

legacy\_compression\_methods: 1.3 이전의 TLS 버전은 이 필드에서 전송되는 지원되는 압축 방법 목록과 함께 압축을 지원했습니다. 모든 TLS 1.3 ClientHello에 대해 이 벡터는 0으로 설정된 정확히 1바이트를 포함해야 하며, 이는 TLS 이전 버전의 "null" 압축 방법에 해당합니다. TLS 1.3 ClientHello가 이 필드의 다른 값과 함께 수신되면 서버는 "illegal\_parameter" 경고와 함께 핸드셰이크를 중단해야 합니다. TLS 1.3 서버는 다른 압축 방법을 포함하는 TLS 1.2 또는 이전 ClientHello를 수신할 수 있으며 \(이러한 이전 버전을 협상하는 경우\) 적절한 이전 버전의 TLS에 대한 절차를 따라야 합니다.\(MUST, MUST, MUST\)

확장: 클라이언트는 확장 필드에 데이터를 전송하여 서버에서 확장된 기능을 요청합니다. 실제 "확장" 형식은 섹션 4.2에 정의되어 있습니다. TLS 1.3에서는 이전 버전의 TLS와의 ClientHello 호환성을 유지하기 위해 기능이 확장으로 이동했기 때문에 특정 확장의 사용이 필수입니다. 서버는 인식할 수 없는 확장자를 무시해야 합니다\(MUST\).\(MUST\)

TLS의 모든 버전에서는 extensions 필드가 선택적으로 compression\_methods 필드 뒤에 오는 것을 허용합니다. TLS 1.3 ClientHello 메시지는 항상 확장자를 포함합니다\(최소한 "supported\_versions", 그렇지 않으면 TLS 1.2 ClientHello 메시지로 해석됨\). 그러나 TLS 1.3 서버는 이전 버전의 TLS에서 확장 필드 없이 ClientHello 메시지를 수신할 수 있습니다. ClientHello 끝에 있는 compression\_methods 필드 다음에 오는 바이트가 있는지 여부를 확인하여 확장의 존재를 감지할 수 있습니다. 선택적 데이터를 감지하는 이 방법은 가변 길이 필드를 갖는 일반적인 TLS 방법과 다르지만 확장이 정의되기 전에 TLS와의 호환성을 위해 사용됩니다. TLS 1.3 서버는 이 검사를 먼저 수행해야 하며 "supported\_versions" 확장자가 있는 경우에만 TLS 1.3 협상을 시도해야 합니다. 1.3 이전의 TLS 버전을 협상하는 경우 서버는 메시지가 legacy\_compression\_methods 이후에 데이터를 포함하지 않는지 또는 데이터가 뒤따르지 않는 유효한 확장 블록을 포함하는지 확인해야 합니다. 그렇지 않은 경우 "decode\_error" 경고와 함께 핸드셰이크를 중단해야 합니다.\(MUST, MUST\)

클라이언트가 확장 기능을 사용하여 추가 기능을 요청하고 이 기능이 서버에서 제공되지 않는 경우 클라이언트는 핸드셰이크를 중단할 수 있습니다.\(MAY\)

ClientHello 메시지를 보낸 후 클라이언트는 ServerHello 또는 HelloRetryRequest 메시지를 기다립니다. early data가 사용 중인 경우 클라이언트는 다음 핸드셰이크 메시지를 기다리는 동안 early Application Data\(Section 2.3\)를 전송할 수 있습니다.

---
#### **4.1.3.  Server Hello**

서버는 ClientHello를 기반으로 허용 가능한 핸드셰이크 매개변수 집합을 협상할 수 있는 경우 핸드셰이크를 진행하기 위해 ClientHello 메시지에 대한 응답으로 이 메시지를 보냅니다.

이 메시지의 구조:

```text
      struct {
          ProtocolVersion legacy_version = 0x0303;    /* TLS v1.2 */
          Random random;
          opaque legacy_session_id_echo<0..32>;
          CipherSuite cipher_suite;
          uint8 legacy_compression_method = 0;
          Extension extensions<6..2^16-1>;
      } ServerHello;
```

legacy\_version: 이전 버전의 TLS에서 이 필드는 버전 협상에 사용되었으며 연결을 위해 선택한 버전 번호를 나타냅니다. 불행하게도 일부 미들박스는 새 값이 제시되면 실패합니다. TLS 1.3에서 TLS 서버는 "supported\_versions" 확장\(섹션 4.2.1\)을 사용하여 버전을 표시하고, legacy\_version 필드는 TLS 1.2의 버전 번호인 0x0303으로 설정해야 합니다\(MUST\). \(이전 버전과의 호환성에 대한 자세한 내용은 부록 D를 참조하십시오.\)\(MUST\)

무작위: 보안 난수 생성기에 의해 생성된 32바이트. 추가 정보는 부록 C를 참조하십시오. 마지막 8바이트는 TLS 1.2 또는 TLS 1.1을 협상하는 경우 아래 설명된 대로 덮어써야 하지만 나머지 바이트는 임의적이어야 합니다. 이 구조는 서버에 의해 생성되며 ClientHello.random과 독립적으로 생성되어야 합니다.\(MUST, MUST\)

legacy\_session\_id\_echo: 클라이언트의 legacy\_session\_id 필드 내용입니다. 클라이언트의 값이 서버가 재개하지 않도록 선택한 캐시된 TLS 1.3 이전 세션에 해당하는 경우에도 이 필드는 반향됩니다. ClientHello에서 보낸 것과 일치하지 않는 legacy\_session\_id\_echo 필드를 수신하는 클라이언트는 "illegal\_parameter" 경고와 함께 핸드셰이크를 중단해야 합니다.\(MUST\)

cipher\_suite: ClientHello.cipher\_suites의 목록에서 서버가 선택한 단일 암호 제품군입니다. 제공되지 않은 암호 그룹을 수신하는 클라이언트는 "illegal\_parameter" 경고와 함께 핸드셰이크를 중단해야 합니다.\(MUST\)

legacy\_compression\_method: 값이 0이어야 하는 단일 바이트입니다.\(MUST\)

extensions: 확장 목록입니다. ServerHello는 암호화 컨텍스트를 설정하고 프로토콜 버전을 협상하는 데 필요한 확장만 포함해야 합니다. 모든 TLS 1.3 ServerHello 메시지는 "supported\_versions" 확장자를 포함해야 합니다. 현재 ServerHello 메시지에는 "pre\_shared\_key" 확장 또는 "key\_share" 확장 또는 둘 다 포함됩니다\(\(EC\)DHE 키 설정과 함께 PSK를 사용하는 경우\). 다른 확장\(섹션 4.2 참조\)은 EncryptedExtensions 메시지에서 별도로 전송됩니다.\(MUST, MUST\)

미들박스와의 하위 호환성 때문에\(부록 D.4 참조\) HelloRetryRequest 메시지는 ServerHello와 동일한 구조를 사용하지만 Random은 "HelloRetryRequest"의 SHA-256 특수 값으로 설정됩니다.

```text
     CF 21 AD 74 E5 9A 61 11 BE 1D 8C 02 1E 65 B8 91
     C2 A2 11 16 7A BB 8C 5E 07 9E 09 E2 C8 A8 33 9C
```

server\_hello 유형의 메시지를 수신하면 구현은 먼저 Random 값을 검사하고 이 값과 일치하는 경우 섹션 4.1.4에 설명된 대로 처리해야 합니다.\(MUST\)

TLS 1.3에는 서버의 임의 값에 다운그레이드 보호 메커니즘이 내장되어 있습니다. ClientHello에 대한 응답으로 TLS 1.2 이하를 협상하는 TLS 1.3 서버는 ServerHello에서 특별히 Random 값의 마지막 8바이트를 설정해야 합니다.\(MUST\)

TLS 1.2를 협상하는 경우 TLS 1.3 서버는 Random 값의 마지막 8바이트를 바이트로 설정해야 합니다.\(MUST\)

```text
     44 4F 57 4E 47 52 44 01
```

TLS 1.1 이하를 협상하는 경우 TLS 1.3 서버는 MUST이고 TLS 1.2 서버는 해야 합니다. ServerHello.Random 값의 마지막 8바이트를 다음 바이트로 설정합니다.\(MUST\)

```text
     44 4F 57 4E 47 52 44 00
```

TLS 1.2 이하를 나타내는 ServerHello를 수신하는 TLS 1.3 클라이언트는 마지막 8바이트가 이러한 값 중 하나와 같지 않은지 확인해야 합니다. TLS 1.2 클라이언트는 또한 ServerHello가 TLS 1.1 이하를 나타내는 경우 마지막 8바이트가 두 번째 값과 같지 않은지 확인해야 합니다\(SHOULD\). 일치하는 항목이 발견되면 클라이언트는 "illegal\_parameter" 경고와 함께 핸드셰이크를 중단해야 합니다. 이 메커니즘은 Finished 교환에서 제공하는 것 이상으로 다운그레이드 공격에 대해 제한적인 보호를 제공합니다. TLS 1.2 이하에 있는 메시지인 ServerKeyExchange에는 두 임의 값에 대한 서명이 포함되어 있으므로 활성 공격자가 수정할 수 없습니다. 그만큼\(MUST, SHOULD, MUST\)

임시 암호가 사용되는 한 감지되지 않는 임의의 값입니다. 정적 RSA를 사용하는 경우 다운그레이드 보호를 제공하지 않습니다.

참고: 이것은 \[RFC5246\]에서 변경된 것이므로 실제로 많은 TLS 1.2 클라이언트 및 서버는 위에 지정된 대로 작동하지 않습니다.

TLS 1.2 또는 이전 버전으로 재협상을 수행하고 재협상 중에 TLS 1.3 ServerHello를 수신하는 레거시 TLS 클라이언트는 "protocol\_version" 경고와 함께 핸드셰이크를 중단해야 합니다\(MUST\). TLS 1.3이 협상된 경우 재협상이 불가능합니다.\(MUST\)

---
#### **4.1.4.  Hello Retry Request**

서버는 허용 가능한 매개변수 집합을 찾을 수 있지만 ClientHello에 핸드셰이크를 진행하기에 충분한 정보가 포함되어 있지 않은 경우 ClientHello 메시지에 대한 응답으로 이 메시지를 보냅니다. 4.1.3 절에서 설명한 바와 같이 HelloRetryRequest는 ServerHello 메시지와 동일한 형식을 가지며, legacy\_version, legacy\_session\_id\_echo, cipher\_suite 및 legacy\_compression\_method 필드는 동일한 의미를 갖습니다. 그러나 편의상 이 문서 전체에서 "HelloRetryRequest"가 별개의 메시지인 것처럼 논의합니다.

서버의 확장은 "supported\_versions"를 포함해야 합니다. 또한 클라이언트가 올바른 ClientHello 쌍을 생성하는 데 필요한 최소한의 확장 집합을 포함해야 합니다\(SHOULD\). ServerHello와 마찬가지로 HelloRetryRequest는 선택적으로 "cookie"\(섹션 4.2.2 참조\) 확장을 제외하고 ClientHello에서 클라이언트가 먼저 제공하지 않은 확장을 포함해서는 안 됩니다.\(MUST, SHOULD, MUST NOT\)

HelloRetryRequest를 수신하면 클라이언트는 섹션 4.1.3에 지정된 대로 legacy\_version, legacy\_session\_id\_echo, cipher\_suite 및 legacy\_compression\_method를 확인한 다음 "supported\_versions"를 사용하여 버전을 결정하는 것부터 시작하여 확장을 처리해야 합니다. HelloRetryRequest로 인해 ClientHello가 변경되지 않는 경우 클라이언트는 "illegal\_parameter" 경고와 함께 핸드셰이크를 중단해야 합니다. 클라이언트가 동일한 연결에서 두 번째 HelloRetryRequest를 수신하는 경우\(즉, ClientHello 자체가 HelloRetryRequest에 대한 응답인 경우\) "unexpected\_message" 경고와 함께 핸드셰이크를 중단해야 합니다.\(MUST, MUST, MUST\)

그렇지 않으면 클라이언트는 HelloRetryRequest의 모든 확장을 처리하고 두 번째 업데이트된 ClientHello를 보내야 합니다. 이 사양에 정의된 HelloRetryRequest 확장은 다음과 같습니다.\(MUST\)

```text
   -  supported_versions (see Section 4.2.1)

   -  cookie (see Section 4.2.2)

   -  key_share (see Section 4.2.8)
```

제공되지 않은 암호 그룹을 수신하는 클라이언트는 반드시 핸드셰이크를 중단해야 합니다. 서버는 일치하는 업데이트된 ClientHello를 수신할 때 동일한 암호 그룹을 협상해야 합니다\(서버가 협상의 첫 번째 단계로 암호 그룹을 선택하면 자동으로 수행됨\). ServerHello를 수신하면 클라이언트는 ServerHello에 제공된 암호화 제품군이 HelloRetryRequest의 암호 제품군과 동일한지 확인하고 그렇지 않으면 "illegal\_parameter" 경고와 함께 핸드셰이크를 중단해야 합니다.\(MUST, MUST, MUST\)

또한 업데이트된 ClientHello에서 클라이언트는 선택한 암호 그룹의 해시 이외의 해시와 연결된 사전 공유 키를 제공하면 안 됩니다\(SHOULD NOT\). 이를 통해 클라이언트는 두 번째 ClientHello에서 여러 해시에 대한 부분 해시 기록을 계산할 필요가 없습니다.\(SHOULD NOT\)

HelloRetryRequest "supported\_versions" 확장의 selected\_version 값은 ServerHello에서 유지되어야 하며 클라이언트는 값이 변경되면 "illegal\_parameter" 경고와 함께 핸드셰이크를 중단해야 합니다.\(MUST\)

---
### **4.2.  Extensions**

많은 TLS 메시지에는 태그 길이 값 인코딩 확장 구조가 포함되어 있습니다.

```text
    struct {
        ExtensionType extension_type;
        opaque extension_data<0..2^16-1>;
    } Extension;

    enum {
        server_name(0),                             /* RFC 6066 */
        max_fragment_length(1),                     /* RFC 6066 */
        status_request(5),                          /* RFC 6066 */
        supported_groups(10),                       /* RFC 8422, 7919 */
        signature_algorithms(13),                   /* RFC 8446 */
        use_srtp(14),                               /* RFC 5764 */
        heartbeat(15),                              /* RFC 6520 */
        application_layer_protocol_negotiation(16), /* RFC 7301 */
        signed_certificate_timestamp(18),           /* RFC 6962 */
        client_certificate_type(19),                /* RFC 7250 */
        server_certificate_type(20),                /* RFC 7250 */
        padding(21),                                /* RFC 7685 */
        pre_shared_key(41),                         /* RFC 8446 */
        early_data(42),                             /* RFC 8446 */
        supported_versions(43),                     /* RFC 8446 */
        cookie(44),                                 /* RFC 8446 */
        psk_key_exchange_modes(45),                 /* RFC 8446 */
        certificate_authorities(47),                /* RFC 8446 */
        oid_filters(48),                            /* RFC 8446 */
        post_handshake_auth(49),                    /* RFC 8446 */
        signature_algorithms_cert(50),              /* RFC 8446 */
        key_share(51),                              /* RFC 8446 */
        (65535)
    } ExtensionType;

   Here:
```

- "extension\_type"은 특정 확장 유형을 식별합니다.

- "extension\_data"에는 특정 확장 유형과 관련된 정보가 포함됩니다.

확장 유형 목록은 섹션 11에 설명된 대로 IANA에서 관리합니다.

확장은 일반적으로 요청/응답 방식으로 구성되지만 일부 확장은 해당 응답이 없는 표시일 뿐입니다. 클라이언트는 ClientHello 메시지에서 확장 요청을 보내고 서버는 ServerHello, EncryptedExtensions, HelloRetryRequest 및 인증서 메시지에서 확장 응답을 보냅니다. 서버는 클라이언트가 Certificate 메시지로 응답할 수 있는 CertificateRequest 메시지의 확장 요청을 보냅니다. 클라이언트가 이에 직접 응답하지 않더라도 서버는 NewSessionTicket에서 요청하지 않은 확장을 보낼 수도 있습니다\(MAY\).\(MAY, MAY\)

HelloRetryRequest의 "쿠키" 확장을 제외하고 원격 엔드포인트가 해당 확장 요청을 보내지 않은 경우 구현은 확장 응답을 보내면 안 됩니다\(MUST NOT\). 이러한 확장을 수신하면 엔드포인트는 "unsupported\_extension" 경고와 함께 핸드셰이크를 중단해야 합니다.\(MUST NOT, MUST\)

아래 표는 CH\(ClientHello\), SH\(ServerHello\), EE\(EncryptedExtensions\), CT\(Certificate\), CR\(CertificateRequest\), NST\(NewSessionTicket\) 및 HRR 표기법을 사용하여 지정된 확장이 나타날 수 있는 메시지를 나타냅니다. \(HelloRetryRequest\). 구현이 인식하고 표시되는 메시지에 대해 지정되지 않은 확장을 수신하는 경우 "illegal\_parameter" 경고와 함께 핸드셰이크를 중단해야 합니다.\(MUST\)

```text
   +--------------------------------------------------+-------------+
   | Extension                                        |     TLS 1.3 |
   +--------------------------------------------------+-------------+
   | server_name [RFC6066]                            |      CH, EE |
   |                                                  |             |
   | max_fragment_length [RFC6066]                    |      CH, EE |
   |                                                  |             |
   | status_request [RFC6066]                         |  CH, CR, CT |
   |                                                  |             |
   | supported_groups [RFC7919]                       |      CH, EE |
   |                                                  |             |
   | signature_algorithms (RFC 8446)                  |      CH, CR |
   |                                                  |             |
   | use_srtp [RFC5764]                               |      CH, EE |
   |                                                  |             |
   | heartbeat [RFC6520]                              |      CH, EE |
   |                                                  |             |
   | application_layer_protocol_negotiation [RFC7301] |      CH, EE |
   |                                                  |             |
   | signed_certificate_timestamp [RFC6962]           |  CH, CR, CT |
   |                                                  |             |
   | client_certificate_type [RFC7250]                |      CH, EE |
   |                                                  |             |
   | server_certificate_type [RFC7250]                |      CH, EE |
   |                                                  |             |
   | padding [RFC7685]                                |          CH |
   |                                                  |             |
   | key_share (RFC 8446)                             | CH, SH, HRR |
   |                                                  |             |
   | pre_shared_key (RFC 8446)                        |      CH, SH |
   |                                                  |             |
   | psk_key_exchange_modes (RFC 8446)                |          CH |
   |                                                  |             |
   | early_data (RFC 8446)                            | CH, EE, NST |
   |                                                  |             |
   | cookie (RFC 8446)                                |     CH, HRR |
   |                                                  |             |
   | supported_versions (RFC 8446)                    | CH, SH, HRR |
   |                                                  |             |
   | certificate_authorities (RFC 8446)               |      CH, CR |
   |                                                  |             |
   | oid_filters (RFC 8446)                           |          CR |
   |                                                  |             |
   | post_handshake_auth (RFC 8446)                   |          CH |
   |                                                  |             |
   | signature_algorithms_cert (RFC 8446)             |      CH, CR |
   +--------------------------------------------------+-------------+
```

서로 다른 유형의 여러 확장이 있는 경우 확장은 ClientHello의 마지막 확장이어야 하는 "pre\_shared\_key"\(섹션 4.2.11\)를 제외하고 임의의 순서로 나타날 수 있습니다\(그러나 ServerHello 확장 블록의 어디에나 나타날 수 있음\). . 주어진 확장 블록에 동일한 유형의 확장이 두 개 이상 있어서는 안 됩니다\(MUST NOT\).\(MUST, MUST NOT\)

TLS 1.3에서는 TLS 1.2와 달리 재개-PSK 모드에 있는 경우에도 각 핸드셰이크에 대해 확장이 협상됩니다. 그러나 0-RTT 매개변수는 이전 핸드셰이크에서 협상된 매개변수입니다. 불일치는 0-RTT를 거부해야 할 수 있습니다\(섹션 4.2.10 참조\).

새로운 기능과 기존 기능 사이에 이 프로토콜에서 발생할 수 있는 미묘한\(미묘하지 않은\) 상호 작용이 있어 전체 보안이 크게 감소할 수 있습니다. 새 확장을 설계할 때 다음 사항을 고려해야 합니다.

- 서버가 확장에 동의하지 않는 경우는 오류 조건\(예: 핸드셰이크를 계속할 수 없음\)이고 일부는 단순히 특정 기능 지원을 거부하는 경우입니다. 일반적으로 전자에는 오류 경고를 사용해야 하고 후자에는 서버 확장 응답의 필드를 사용해야 합니다.

- 확장은 가능한 한 핸드셰이크 메시지를 조작하여 특정 기능을 강제로 사용\(또는 사용하지 않음\)하는 공격을 방지하도록 설계되어야 합니다. 해당 기능이 보안 문제를 일으키는 것으로 판단되는지 여부에 관계없이 이 원칙을 따라야 합니다. 종료된 메시지 해시에 대한 입력에 확장 필드가 포함되어 있다는 사실만으로도 충분할 수 있지만 확장이 핸드셰이크 단계에서 전송된 메시지의 의미를 변경할 때는 각별한 주의가 필요합니다. 설계자와 구현자는 핸드셰이크가 인증될 때까지 적극적인 공격자가 메시지를 수정하고 확장을 삽입, 제거 또는 교체할 수 있다는 사실을 알고 있어야 합니다.

---
#### **4.2.1.  Supported Versions**

```text
      struct {
          select (Handshake.msg_type) {
              case client_hello:
                   ProtocolVersion versions<2..254>;

              case server_hello: /* and HelloRetryRequest */
                   ProtocolVersion selected_version;
          };
      } SupportedVersions;
```

"supported\_versions" 확장은 클라이언트가 지원하는 TLS 버전을 표시하고 서버가 사용 중인 버전을 표시하는 데 사용됩니다. 확장 프로그램에는 지원되는 버전 목록이 기본 설정 순서대로 포함되어 있으며 가장 선호하는 버전이 먼저입니다. 이 사양의 구현은 협상할 준비가 된 TLS의 모든 버전을 포함하는 ClientHello에서 이 확장을 보내야 합니다\(이 사양의 경우 최소 0x0304를 의미하지만 이전 버전의 TLS가 협상될 수 있는 경우 TLS도 있어야 함\) \).\(MUST\)

이 확장이 없으면 이 사양을 준수하고 TLS 1.2도 지원하는 서버는 ClientHello.legacy\_version이 0x0304 이상인 경우에도 \[RFC5246\]에 지정된 대로 TLS 1.2 이하를 협상해야 합니다. 서버는 legacy\_version 0x0304 이상으로 ClientHello를 수신하면 핸드셰이크를 중단할 수 있습니다\(MAY\).\(MUST, MAY\)

이 확장이 ClientHello에 있는 경우 서버는 버전 협상에 ClientHello.legacy\_version 값을 사용해서는 안 되며\(MUST NOT\) 클라이언트 기본 설정을 결정하기 위해 "supported\_versions" 확장만 사용해야 합니다. 서버는 해당 확장에 있는 TLS 버전만 선택해야 하며 해당 확장에 있는 알 수 없는 버전은 무시해야 합니다. 이 메커니즘을 사용하면 한쪽이 희소 범위를 지원하는 경우 TLS 1.2 이전 버전을 협상할 수 있습니다. 이전 버전의 TLS를 지원하도록 선택한 TLS 1.3 구현은 TLS 1.2를 지원해야 합니다. 서버는 이 확장을 포함하지만 버전 목록에 0x0304를 포함하지 않는 ClientHello를 수신할 준비가 되어 있어야 합니다.\(MUST NOT, MUST, SHOULD, MUST\)

TLS 1.3 이전의 TLS 버전을 협상하는 서버는 ServerHello.version을 설정해야 하며 "supported\_versions" 확장자를 전송하면 안 됩니다\(MUST NOT\). TLS 1.3을 협상하는 서버는 선택한 버전 값\(0x0304\)을 포함하는 "supported\_versions" 확장을 전송하여 응답해야 합니다. ServerHello.legacy\_version 필드를 0x0303\(TLS 1.2\)으로 설정해야 합니다. 클라이언트는 나머지 ServerHello를 처리하기 전에 이 확장을 확인해야 합니다.\(MUST NOT, MUST, MUST, MUST\)

확장을 읽기 위해 ServerHello를 구문 분석합니다\). 이 확장이 있는 경우 클라이언트는 ServerHello.legacy\_version 값을 무시하고 "supported\_versions" 확장만 사용하여 선택한 버전을 결정해야 합니다. ServerHello의 "supported\_versions" 확장이 클라이언트에서 제공하지 않는 버전을 포함하거나 TLS 1.3 이전 버전을 포함하는 경우 클라이언트는 "illegal\_parameter" 경고와 함께 핸드셰이크를 중단해야 합니다.\(MUST, MUST\)

---
#### **4.2.2.  Cookie**

```text
      struct {
          opaque cookie<1..2^16-1>;
      } Cookie;

   Cookies serve two primary purposes:
```

- 서버가 클라이언트가 명백한 네트워크 주소에서 연결 가능성을 입증하도록 허용합니다\(따라서 DoS 보호 수단 제공\). 이는 주로 비연결 지향 전송에 유용합니다\(이에 대한 예는 \[RFC6347\] 참조\).

- 서버가 상태를 클라이언트로 오프로드하여 상태를 저장하지 않고 HelloRetryRequest를 보낼 수 있도록 허용합니다. 서버는 HelloRetryRequest 쿠키\(적절한 무결성 보호 알고리즘으로 보호됨\)에 ClientHello의 해시를 저장하여 이를 수행할 수 있습니다.

HelloRetryRequest를 보낼 때 서버는 클라이언트에 "쿠키" 확장을 제공할 수 있습니다. 새 ClientHello를 보낼 때 클라이언트는 HelloRetryRequest에서 받은 확장의 내용을 새 ClientHello의 "쿠키" 확장으로 복사해야 합니다. 클라이언트는 후속 연결에서 초기 ClientHello에서 쿠키를 사용해서는 안 됩니다.\(MAY, MUST, MUST NOT\)

서버가 상태 없이 작동하는 경우 첫 번째와 두 번째 ClientHello 사이에서 change\_cipher\_spec 유형의 보호되지 않은 레코드를 수신할 수 있습니다\(섹션 5 참조\). 서버가 어떤 상태도 저장하지 않기 때문에 이것이 수신된 첫 번째 메시지인 것처럼 나타납니다. 상태 없이 작동하는 서버는 이러한 레코드를 무시해야 합니다.\(MUST\)

---
#### **4.2.3.  Signature Algorithms**

TLS 1.3은 디지털 서명에 사용할 수 있는 서명 알고리즘을 나타내는 두 가지 확장을 제공합니다. "signature\_algorithms\_cert" 확장은 인증서의 서명에 적용되며 원래 TLS 1.2에 등장한 "signature\_algorithms" 확장은 CertificateVerify 메시지의 서명에 적용됩니다. 인증서에 있는 키는 함께 사용되는 서명 알고리즘에 적합한 유형이어야 합니다. 이는 아래에 설명된 대로 RSA 키 및 PSS 서명에 대한 특정 문제입니다. "signature\_algorithms\_cert" 확장이 없으면 "signature\_algorithms" 확장도 인증서에 나타나는 서명에 적용됩니다. 서버가 인증서를 통해 자신을 인증하기를 원하는 클라이언트는 "signature\_algorithms" 확장자를 보내야 합니다. 서버가 인증서를 통해 인증 중이고 클라이언트가 "signature\_algorithms" 확장을 전송하지 않은 경우 서버는 "missing\_extension" 경고와 함께 핸드셰이크를 중단해야 합니다\(섹션 9.2 참조\).\(MUST, MUST, MUST\)

"signature\_algorithms\_cert" 확장이 추가되어 인증서 및 TLS 자체에 대한 다양한 알고리즘 세트를 지원하는 구현이 기능을 명확하게 신호할 수 있도록 했습니다. TLS 1.2 구현도 이 확장을 처리해야 합니다\(SHOULD\). 두 경우 모두 동일한 정책을 가진 구현은 "signature\_algorithms\_cert" 확장자를 생략할 수 있습니다\(MAY\).\(SHOULD, MAY\)

이러한 확장의 "extension\_data" 필드에는 SignatureSchemeList 값이 포함됩니다.

```text
      enum {
          /* RSASSA-PKCS1-v1_5 algorithms */
          rsa_pkcs1_sha256(0x0401),
          rsa_pkcs1_sha384(0x0501),
          rsa_pkcs1_sha512(0x0601),

          /* ECDSA algorithms */
          ecdsa_secp256r1_sha256(0x0403),
          ecdsa_secp384r1_sha384(0x0503),
          ecdsa_secp521r1_sha512(0x0603),

          /* RSASSA-PSS algorithms with public key OID rsaEncryption */
          rsa_pss_rsae_sha256(0x0804),
          rsa_pss_rsae_sha384(0x0805),
          rsa_pss_rsae_sha512(0x0806),

          /* EdDSA algorithms */
          ed25519(0x0807),
          ed448(0x0808),

          /* RSASSA-PSS algorithms with public key OID RSASSA-PSS */
          rsa_pss_pss_sha256(0x0809),
          rsa_pss_pss_sha384(0x080a),
          rsa_pss_pss_sha512(0x080b),

          /* Legacy algorithms */
          rsa_pkcs1_sha1(0x0201),
          ecdsa_sha1(0x0203),

          /* Reserved Code Points */
          private_use(0xFE00..0xFFFF),
          (0xFFFF)
      } SignatureScheme;

      struct {
          SignatureScheme supported_signature_algorithms<2..2^16-2>;
      } SignatureSchemeList;
```

참고: TLS 1.2에 "SignatureAlgorithm" 유형이 이미 있기 때문에 이 열거형의 이름은 "SignatureScheme"입니다. 본문 전체에서 "서명 알고리즘"이라는 용어를 사용합니다.

각 SignatureScheme 값은 클라이언트가 확인하려는 단일 서명 알고리즘을 나열합니다. 값은 기본 설정 내림차순으로 표시됩니다. 서명 알고리즘은 다이제스트가 아닌 임의 길이의 메시지를 입력으로 사용합니다. 전통적으로 다이제스트에 작용하는 알고리즘은 먼저 지정된 해시 알고리즘으로 입력을 해시한 다음 평소와 같이 진행하도록 TLS에서 정의되어야 합니다. 위에 나열된 코드 포인트 그룹의 의미는 다음과 같습니다.

RSASSA-PKCS1-v1\_5 알고리즘: \[SHS\]에 정의된 해당 해시 알고리즘과 함께 RSASSA-PKCS1-v1\_5 \[RFC8017\]를 사용하는 서명 알고리즘을 나타냅니다. 이러한 값은 TLS 1.2와의 하위 호환성을 위해 "signature\_algorithms" 및 "signature\_algorithms\_cert"에 나타날 수 있지만 인증서에 표시되는 서명만 참조하고\(섹션 4.4.2.2 참조\) 서명된 TLS 핸드셰이크 메시지에 사용하도록 정의되지 않았습니다.\(MAY\)

ECDSA 알고리즘: ECDSA\[ECDSA\], ANSI X9.62\[ECDSA\] 및 FIPS 186-4\[DSS\]에 정의된 해당 곡선, \[SHS\]에 정의된 해당 해시 알고리즘을 사용하는 서명 알고리즘을 나타냅니다. 서명은 DER로 인코딩된 \[X690\] ECDSA-Sig-Value 구조로 표현됩니다.

RSASSA-PSS RSAE 알고리즘: 마스크 생성 기능 1과 함께 RSASSA-PSS \[RFC8017\]를 사용하는 서명 알고리즘을 나타냅니다. 마스크 생성 기능에 사용되는 다이제스트와 서명되는 다이제스트는 모두 \[SHS\]에 정의된 해당 해시 알고리즘입니다. 솔트의 길이는 다이제스트 알고리즘의 출력 길이와 같아야 합니다. 공개 키가 X.509 인증서에 포함된 경우 rsaEncryption OID \[RFC5280\]를 사용해야 합니다.\(MUST, MUST\)

EdDSA 알고리즘: \[RFC8032\] 또는 그 후속 버전에 정의된 EdDSA를 사용하는 서명 알고리즘을 나타냅니다. 이들은 "prehash" 변형이 아니라 "PureEdDSA" 알고리즘에 해당합니다.

RSASSA-PSS PSS 알고리즘: 마스크 생성 기능 1과 함께 RSASSA-PSS \[RFC8017\]를 사용하는 서명 알고리즘을 나타냅니다. 마스크 생성 기능에 사용되는 다이제스트와 서명되는 다이제스트는 모두 \[SHS\]에 정의된 해당 해시 알고리즘입니다. 솔트의 길이는 다이제스트 알고리즘의 길이와 같아야 합니다. 공개 키가 X.509 인증서에 포함된 경우 RSASSA-PSS OID\[RFC5756\]를 사용해야 합니다. 인증서 서명에 사용될 때 알고리즘 매개변수는 DER로 인코딩되어야 합니다. 해당 공개 키의 매개 변수가 있는 경우 서명의 매개 변수는 공개 키의 매개 변수와 동일해야 합니다.\(MUST, MUST, MUST, MUST\)

레거시 알고리즘: 알려진 약점이 있는 알고리즘, 특히 \(1\) RSASSA-PKCS1-v1\_5를 사용하는 RSA 또는 \(2\) ECDSA와 함께 이 컨텍스트에서 사용되는 SHA-1을 사용하기 때문에 더 이상 사용되지 않는 알고리즘을 나타냅니다. 이러한 값은 TLS 1.2와의 하위 호환성을 위해 "signature\_algorithms" 및 "signature\_algorithms\_cert"에 나타날 수 있지만 인증서에 표시되는 서명만 참조하고\(섹션 4.4.2.2 참조\) 서명된 TLS 핸드셰이크 메시지에 사용하도록 정의되지 않았습니다. 엔드포인트는 이러한 알고리즘을 협상하면 안 되지만 이전 버전과의 호환성을 위해서만 그렇게 할 수 있습니다. 이러한 값을 제공하는 클라이언트는 이를 가장 낮은 우선 순위로 나열해야 합니다\(SignatureSchemeList의 다른 모든 알고리즘 다음에 나열됨\). TLS 1.3 서버는 SHA-1 서명 인증서 없이 유효한 인증서 체인을 생성할 수 없는 경우가 아니면 SHA-1 서명 인증서를 제공하면 안 됩니다\(MUST NOT\)\(섹션 4.4.2.2 참조\).\(MAY, SHOULD NOT, MUST, MUST NOT\)

자체 서명된 인증서 또는 트러스트 앵커인 인증서의 서명은 인증 경로를 시작하기 때문에 유효성이 검사되지 않습니다\(\[RFC5280\], 섹션 3.2 참조\). 인증 경로를 시작하는 인증서는 "signature\_algorithms" 확장에서 지원되는 것으로 광고되지 않는 서명 알고리즘을 사용할 수 있습니다\(MAY\).\(MAY\)

TLS 1.2는 이 확장을 다르게 정의합니다. TLS 1.2를 협상하려는 TLS 1.3 구현은 해당 버전을 협상할 때 \[RFC5246\]의 요구 사항에 따라 동작해야 합니다\(MUST\). 특히:\(MUST\)

- TLS 1.2 ClientHellos는 이 확장을 생략할 수 있습니다.\(MAY\)

- TLS 1.2에서는 확장에 해시/서명 쌍이 포함되었습니다. 쌍은 두 개의 옥텟으로 인코딩되므로 TLS 1.2의 인코딩에 맞춰 SignatureScheme 값이 할당되었습니다. 일부 레거시 쌍은 할당되지 않은 상태로 남아 있습니다. 이러한 알고리즘은 TLS 1.3부터 ​​더 이상 사용되지 않습니다. 어떠한 구현에서도 이를 제안하거나 협상해서는 안 됩니다. 특히 MD5 \[SLOTH\], SHA-224 및 DSA는 사용하면 안 됩니다.\(MUST NOT, MUST NOT\)

- ECDSA 서명 체계는 TLS 1.2의 ECDSA 해시/서명 쌍과 일치합니다. 그러나 이전 의미론은 서명 곡선을 제한하지 않았습니다. TLS 1.2가 협상되는 경우 구현은 "supported\_groups" 확장에서 광고한 모든 곡선을 사용하는 서명을 수락하도록 준비되어야 합니다.\(MUST\)

- RSASSA-PSS\(TLS 1.3에서 필수\)에 대한 지원을 광고하는 구현은 TLS 1.2가 협상되는 경우에도 해당 체계를 사용하여 서명을 수락할 준비를 해야 합니다. TLS 1.2에서는 RSASSA-PSS가 RSA 암호화 제품군과 함께 사용됩니다.\(MUST\)

---
#### **4.2.4.  Certificate Authorities**

"certificate\_authorities" 확장은 엔드포인트가 지원하고 인증서 선택을 안내하기 위해 수신 엔드포인트에서 사용해야 하는 인증 기관\(CA\)을 나타내는 데 사용됩니다.\(SHOULD\)

"certificate\_authorities" 확장의 본문은 CertificateAuthoritiesExtension 구조로 구성됩니다.

```text
      opaque DistinguishedName<1..2^16-1>;

      struct {
          DistinguishedName authorities<3..2^16-1>;
      } CertificateAuthoritiesExtension;
```

기관: DER로 인코딩된 \[X690\] 형식으로 표시되는 허용되는 인증 기관의 고유 이름 \[X501\] 목록입니다. 이러한 고유 이름은 트러스트 앵커 또는 하위 CA에 대해 원하는 고유 이름을 지정합니다. 따라서 이 메시지는 알려진 트러스트 앵커와 원하는 인증 공간을 설명하는 데 사용할 수 있습니다.

클라이언트는 ClientHello 메시지에서 "certificate\_authorities" 확장을 보낼 수 있습니다\(MAY\). 서버는 CertificateRequest 메시지로 보낼 수 있습니다.\(MAY, MAY\)

"trusted\_ca\_keys" 확장\[RFC6066\]은 비슷한 용도로 사용되지만 더 복잡하며 TLS 1.3에서는 사용되지 않습니다\(이전 버전의 TLS를 제공하는 클라이언트의 ClientHello 메시지에 나타날 수 있음\).

---
#### **4.2.5.  OID Filters**

"oid\_filters" 확장을 통해 서버는 클라이언트의 인증서와 일치시키려는 OID/값 쌍 세트를 제공할 수 있습니다. 이 확장은 서버에서 제공하는 경우 CertificateRequest 메시지에서만 전송되어야 합니다.\(MUST\)

```text
      struct {
          opaque certificate_extension_oid<1..2^8-1>;
          opaque certificate_extension_values<0..2^16-1>;
      } OIDFilter;

      struct {
          OIDFilter filters<0..2^16-1>;
      } OIDFilterExtension;
```

필터: 허용된 값을 포함하고 DER 인코딩된 \[X690\] 형식으로 표시되는 인증서 확장 OID\[RFC5280\] 목록입니다. 일부 인증서 확장 OID는 여러 값을 허용합니다\(예: 확장 키 사용\). 서버에 비어 있지 않은 필터 목록이 포함된 경우 응답에 포함된 클라이언트 인증서에는 클라이언트가 인식하는 지정된 모든 확장 OID가 포함되어야 합니다. 클라이언트가 인식하는 각 확장 OID에 대해 지정된 모든 값이 클라이언트 인증서에 있어야 합니다\(그러나 인증서는 다른 값도 가질 수 있습니다\). 그러나 클라이언트는 인식되지 않는 인증서 확장 OID를 무시하고 건너뛰어야 합니다. 클라이언트가 필요한 인증서 확장 OID 중 일부를 무시하고 요청을 충족하지 않는 인증서를 제공한 경우 서버는 재량에 따라 클라이언트 인증 없이 연결을 계속하거나 "unsupported\_certificate" 경고와 함께 핸드셰이크를 중단할 수 있습니다. 주어진 OID는 필터 목록에 두 번 이상 나타나지 않아야 합니다.\(MUST, MUST, MUST, MAY, MUST NOT\)

PKIX RFC는 다양한 인증서 확장 OID 및 해당 값 유형을 정의합니다. 유형에 따라 일치하는 인증서 확장 값이 반드시 비트 단위로 같지는 않습니다. TLS 구현은 인증서 확장 OID를 사용하여 인증서 선택을 수행하기 위해 PKI 라이브러리에 의존할 것으로 예상됩니다.

이 문서는 \[RFC5280\]에 정의된 두 가지 표준 인증서 확장에 대한 일치 규칙을 정의합니다.

- 요청에서 주장된 모든 키 사용 비트가 키 사용 인증서 확장에서도 주장될 때 인증서의 키 사용 확장은 요청과 일치합니다.

- 요청에 존재하는 모든 키 목적 OID가 확장 키 사용 인증서 확장에서도 발견되면 인증서의 확장 키 사용 확장이 요청과 일치합니다. 특별한 anyExtendedKeyUsage OID는 요청에 사용되어서는 안 됩니다.\(MUST NOT\)

별도의 사양은 다른 인증서 확장에 대한 일치 규칙을 정의할 수 있습니다.

---
#### **4.2.6.  Post-Handshake Client Authentication**

"post\_handshake\_auth" 확장은 클라이언트가 사후 핸드셰이크 인증을 수행할 의향이 있음을 나타내는 데 사용됩니다\(섹션 4.6.2\). 서버는 이 확장을 제공하지 않는 클라이언트에 포스트 핸드셰이크 CertificateRequest를 보내면 안 됩니다. 서버는 이 확장을 보내면 안 됩니다.\(MUST NOT, MUST NOT\)

```text
      struct {} PostHandshakeAuth;
```

"post\_handshake\_auth" 확장의 "extension\_data" 필드 길이가 0입니다.

---
#### **4.2.7.  Supported Groups**

클라이언트가 보낼 때 "supported\_groups" 확장자는 클라이언트가 키 교환을 지원하는 명명된 그룹을 가장 선호하는 것부터 가장 덜 선호하는 것까지 순서대로 나타냅니다.

참고: TLS 1.3 이전 버전의 TLS에서는 이 확장의 이름이 "elliptic\_curves"였으며 타원 곡선 그룹만 포함되었습니다. \[RFC8422\] 및 \[RFC7919\]를 참조하십시오. 이 확장은 ECDSA 곡선을 협상하는 데에도 사용되었습니다. 서명 알고리즘은 이제 독립적으로 협상됩니다\(섹션 4.2.3 참조\).

이 확장의 "extension\_data" 필드에는 "NamedGroupList" 값이 포함되어 있습니다.

```text
      enum {

          /* Elliptic Curve Groups (ECDHE) */
          secp256r1(0x0017), secp384r1(0x0018), secp521r1(0x0019),
          x25519(0x001D), x448(0x001E),

          /* Finite Field Groups (DHE) */
          ffdhe2048(0x0100), ffdhe3072(0x0101), ffdhe4096(0x0102),
          ffdhe6144(0x0103), ffdhe8192(0x0104),

          /* Reserved Code Points */
          ffdhe_private_use(0x01FC..0x01FF),
          ecdhe_private_use(0xFE00..0xFEFF),
          (0xFFFF)
      } NamedGroup;

      struct {
          NamedGroup named_group_list<2..2^16-1>;
      } NamedGroupList;
```

타원 곡선 그룹\(ECDHE\): FIPS 186-4 \[DSS\] 또는 \[RFC7748\]에 정의된 해당 명명된 곡선에 대한 지원을 나타냅니다. 0xFE00에서 0xFEFF까지의 값은 개인용으로 예약되어 있습니다\[RFC8126\].

유한 필드 그룹\(DHE\): \[RFC7919\]에 정의된 해당 유한 필드 그룹에 대한 지원을 나타냅니다. 0x01FC에서 0x01FF까지의 값은 개인용으로 예약되어 있습니다.

named\_group\_list의 항목은 보낸 사람의 기본 설정\(가장 선호하는 항목 먼저\)에 따라 정렬됩니다.

TLS 1.3부터 ​​서버는 클라이언트에 "supported\_groups" 확장을 보낼 수 있습니다. 클라이언트는 핸드셰이크를 성공적으로 완료하기 전에 "supported\_groups"에서 찾은 정보에 따라 행동해서는 안 되지만 성공적으로 완료된 핸드셰이크에서 배운 정보를 사용하여 후속 연결에서 "key\_share" 확장에서 사용하는 그룹을 변경할 수 있습니다\(MAY\). 서버에 그룹이 있는 경우 "key\_share" 확장에 있는 그룹보다 선호하지만 여전히 ClientHello를 수락할 의향이 있으면 "supported\_groups"를 전송하여 클라이언트의 기본 설정 보기를 업데이트해야 합니다. 이 확장은 클라이언트가 현재 지원하는지 여부에 관계없이 서버가 지원하는 모든 그룹을 포함해야 합니다\(SHOULD\).\(MUST NOT, SHOULD\)

---
#### **4.2.8.  Key Share**

"key\_share" 확장에는 엔드포인트의 암호화 매개변수가 포함됩니다.

클라이언트는 추가 왕복 비용으로 서버에서 그룹 선택을 요청하기 위해 빈 client\_shares 벡터를 보낼 수 있습니다\(4.1.4절 참조\).\(MAY\)

```text
      struct {
          NamedGroup group;
          opaque key_exchange<1..2^16-1>;
      } KeyShareEntry;
```

group: 교환되는 키에 대해 명명된 그룹입니다.

key\_exchange: 키 교환 정보. 이 필드의 내용은 지정된 그룹 및 해당 정의에 의해 결정됩니다. Finite Field Diffie-Hellman \[DH76\] 매개변수는 섹션 4.2.8.1에 설명되어 있습니다. Elliptic Curve Diffie-Hellman 매개변수는 섹션 4.2.8.2에 설명되어 있습니다.

ClientHello 메시지에서 이 확장의 "extension\_data" 필드에는 "KeyShareClientHello" 값이 포함됩니다.

```text
      struct {
          KeyShareEntry client_shares<0..2^16-1>;
      } KeyShareClientHello;
```

client\_shares: 클라이언트 기본 설정의 내림차순으로 제공된 KeyShareEntry 값 목록입니다.

클라이언트가 HelloRetryRequest를 요청하는 경우 이 벡터는 비어 있을 수 있습니다. 각 KeyShareEntry 값은 "supported\_groups" 확장에서 제공되는 그룹에 해당해야 하며 동일한 순서로 나타나야 합니다\(MUST\). 그러나 값은 "supported\_groups" 확장의 비연속 하위 집합일 수 있으며\(MAY\) 가장 선호하는 그룹을 생략할 수 있습니다\(MAY\). 이러한 상황은 가장 선호하는 그룹이 새롭고 이들을 위한 사전 생성 키 공유를 효율적으로 만들기에 충분한 위치에서 지원되지 않을 가능성이 있는 경우에 발생할 수 있습니다.\(MAY, MUST, MAY\)

클라이언트는 제공하는 지원되는 그룹 수만큼 KeyShareEntry 값을 제공할 수 있으며, 각각은 키 교환 매개변수의 단일 세트를 나타냅니다. 예를 들어 클라이언트는 여러 타원 곡선 또는 여러 FFDHE 그룹에 대한 주식을 제공할 수 있습니다. 각 KeyShareEntry에 대한 key\_exchange 값은 독립적으로 생성되어야 합니다. 클라이언트는 동일한 그룹에 대해 여러 KeyShareEntry 값을 제공하면 안 됩니다\(MUST NOT\). 클라이언트는 클라이언트의 "supported\_groups" 확장에 나열되지 않은 그룹에 대한 KeyShareEntry 값을 제공하면 안 됩니다\(MUST NOT\). 서버는 이러한 규칙의 위반 여부를 확인하고 위반할 경우 "illegal\_parameter" 경고와 함께 핸드셰이크를 중단할 수 있습니다\(MAY\).\(MUST, MUST NOT, MUST NOT, MAY\)

HelloRetryRequest 메시지에서 이 확장의 "extension\_data" 필드에는 KeyShareHelloRetryRequest 값이 포함됩니다.

```text
      struct {
          NamedGroup selected_group;
      } KeyShareHelloRetryRequest;
```

selected\_group: 서버가 협상하려고 하고 재시도된 ClientHello/KeyShare를 요청하는 상호 지원 그룹입니다.

HelloRetryRequest에서 이 확장을 수신하면 클라이언트는 \(1\) selected\_group 필드가 원래 ClientHello의 "supported\_groups" 확장에 제공된 그룹에 해당하고 \(2\) selected\_group 필드가 그룹에 해당하지 않는지 확인해야 합니다. 이는 원래 ClientHello의 "key\_share" 확장에서 제공되었습니다. 이러한 검사 중 하나라도 실패하면 클라이언트는 "illegal\_parameter" 경고와 함께 핸드셰이크를 중단해야 합니다. 그렇지 않으면 새 ClientHello를 보낼 때 클라이언트는 반드시\(MUST, MUST, MUST\)

원래 "key\_share" 확장을 트리거하는 HelloRetryRequest의 selected\_group 필드에 표시된 그룹에 대한 새 KeyShareEntry만 포함하는 확장으로 대체하십시오.

ServerHello 메시지에서 이 확장의 "extension\_data" 필드에는 KeyShareServerHello 값이 포함됩니다.

```text
      struct {
          KeyShareEntry server_share;
      } KeyShareServerHello;
```

server\_share: 클라이언트 공유 중 하나와 동일한 그룹에 있는 단일 KeyShareEntry 값입니다.

\(EC\)DHE 키 설정을 사용하는 경우 서버는 ServerHello에서 정확히 하나의 KeyShareEntry를 제공합니다. 이 값은 서버가 협상된 키 교환을 위해 선택한 클라이언트가 제공한 KeyShareEntry 값과 동일한 그룹에 있어야 합니다. 서버는 클라이언트의 "supported\_groups" 확장에 표시되지 않은 그룹에 대해 KeyShareEntry를 전송하면 안 되며\(MUST NOT\) "psk\_ke" PskKeyExchangeMode를 사용할 때 KeyShareEntry를 전송하면 안 됩니다\(MUST NOT\). \(EC\)DHE 키 설정을 사용하고 "key\_share" 확장자를 포함하는 HelloRetryRequest가 클라이언트에 의해 수신된 경우 클라이언트는 ServerHello에서 선택된 NamedGroup이 HelloRetryRequest에서와 동일한지 확인해야 합니다. 이 검사가 실패하면 클라이언트는 "illegal\_parameter" 경고와 함께 핸드셰이크를 중단해야 합니다.\(MUST, MUST NOT, MUST, MUST\)

---
##### **4.2.8.1.  Diffie-Hellman Parameters**

클라이언트와 서버 모두에 대한 Diffie-Hellman \[DH76\] 매개변수는 KeyShare 구조에서 KeyShareEntry의 불투명한 key\_exchange 필드에 인코딩됩니다. 불투명 값에는 빅엔디안 정수로 인코딩되고 크기가 p 바이트 단위.

참고: 지정된 Diffie-Hellman 그룹의 경우 패딩으로 인해 모든 공개 키의 길이가 동일해집니다.

피어는 1 < Y ​​< p-1을 확인하여 서로의 공개 키 Y를 확인해야 합니다. 이 검사는 원격 피어가 제대로 작동하고 로컬 시스템을 작은 하위 그룹으로 강제하지 않는지 확인합니다.\(MUST\)

---
##### **4.2.8.2.  ECDHE Parameters**

클라이언트와 서버 모두에 대한 ECDHE 매개변수는 KeyShare 구조에서 KeyShareEntry의 불투명한 key\_exchange 필드에 인코딩됩니다.

secp256r1, secp384r1 및 secp521r1의 경우 내용은 다음 구조체의 직렬화된 값입니다.

```text
      struct {
          uint8 legacy_form = 4;
          opaque X[coordinate_length];
          opaque Y[coordinate_length];
      } UncompressedPointRepresentation;
```

X와 Y는 각각 네트워크 바이트 순서로 된 x와 y 값의 이진 표현입니다. 내부 길이 마커가 없으므로 각 숫자 표현은 곡선 매개변수가 암시하는 만큼 많은 옥텟을 차지합니다. P-256의 경우 이는 X와 Y가 각각 32옥텟을 사용하고 필요한 경우 왼쪽에 0을 채움을 의미합니다. P-384의 경우 각각 48옥텟을 사용합니다. P-521의 경우 각각 66옥텟을 사용합니다.

곡선 secp256r1, secp384r1 및 secp521r1의 경우 피어는 지점이 타원 곡선의 유효한 지점인지 확인하여 서로의 공개 값 Q를 확인해야 합니다. 적절한 확인 절차는 \[ECDSA\]의 섹션 4.3.7과 \[KEYAGREEMENT\]의 섹션 5.6.2.3에 정의되어 있습니다. 이 프로세스는 세 단계로 구성됩니다. \(1\) Q가 무한대\(O\)에 있는 점이 아님을 확인합니다. \(2\) Q = \(x, y\)에 대해 정수 x와 y가 모두 올바른 간격에 있는지 확인합니다. \(3\) \) \(x, y\)가 타원 곡선 방정식에 대한 올바른 솔루션인지 확인하십시오. 이러한 곡선의 경우 구현자는 올바른 하위 그룹의 구성원 자격을 확인할 필요가 없습니다.\(MUST\)

X25519 및 X448의 경우 공개 값의 내용은 \[RFC7748\]에 정의된 해당 함수의 바이트 문자열 입력 및 출력입니다\(X25519의 경우 32바이트, X448의 경우 56바이트\).

참고: 1.3 이전의 TLS 버전은 포인트 형식 협상을 허용했습니다. TLS 1.3은 각 곡선에 대해 단일 포인트 형식을 위해 이 기능을 제거합니다.

---
#### **4.2.9.  Pre-Shared Key Exchange Modes**

PSK를 사용하려면 클라이언트는 "psk\_key\_exchange\_modes" 확장도 보내야 합니다. 이 확장의 의미는 클라이언트가 이러한 모드로 PSK의 사용만 지원한다는 것입니다. 이는 이 ClientHello에서 제공되는 PSK의 사용과 서버가 NewSessionTicket을 통해 제공할 수 있는 PSK의 사용을 모두 제한합니다.\(MUST\)

클라이언트는 "pre\_shared\_key" 확장을 제공하는 경우 "psk\_key\_exchange\_modes" 확장을 제공해야 합니다. 클라이언트가 "psk\_key\_exchange\_modes" 확장 없이 "pre\_shared\_key"를 제공하는 경우 서버는 핸드셰이크를 중단해야 합니다. 서버는 클라이언트가 나열하지 않은 키 교환 모드를 선택하면 안 됩니다\(MUST NOT\). 이 확장은 또한 PSK 재개와 함께 사용할 모드를 제한합니다. 서버는 광고된 모드와 호환되지 않는 티켓과 함께 NewSessionTicket을 보내면 안 됩니다\(SHOULD NOT\). 그러나 서버가 그렇게 하면 영향은 클라이언트의 재개 시도가 실패한다는 것입니다.\(MUST, MUST, MUST NOT, SHOULD NOT\)

서버는 "psk\_key\_exchange\_modes" 확장자를 전송하면 안 됩니다\(MUST NOT\).\(MUST NOT\)

```text
      enum { psk_ke(0), psk_dhe_ke(1), (255) } PskKeyExchangeMode;

      struct {
          PskKeyExchangeMode ke_modes<1..255>;
      } PskKeyExchangeModes;
```

psk\_ke: PSK 전용 키 설정. 이 모드에서 서버는 "key\_share" 값을 제공하면 안 됩니다.\(MUST NOT\)

psk\_dhe\_ke: \(EC\)DHE 키가 설정된 PSK. 이 모드에서 클라이언트와 서버는 섹션 4.2.8에 설명된 대로 "key\_share" 값을 제공해야 합니다.\(MUST\)

할당된 향후 값은 전송된 프로토콜 메시지가 서버에서 선택한 모드를 명확하게 식별하도록 해야 합니다. 현재 이것은 ServerHello에서 "key\_share"의 존재로 표시됩니다.

---
#### **4.2.10.  Early Data Indication**

PSK가 사용되고 해당 PSK에 대한 초기 데이터가 허용되면 클라이언트는 첫 번째 메시지 비행에서 응용 프로그램 데이터를 보낼 수 있습니다. 클라이언트가 이를 선택하면 "pre\_shared\_key" 및 "early\_data" 확장을 모두 제공해야 합니다.\(MUST\)

이 확장 프로그램의 "extension\_data" 필드에는 "EarlyDataIndication" 값이 포함되어 있습니다.

```text
      struct {} Empty;

      struct {
          select (Handshake.msg_type) {
              case new_session_ticket:   uint32 max_early_data_size;
              case client_hello:         Empty;
              case encrypted_extensions: Empty;
          };
      } EarlyDataIndication;
```

max\_early\_data\_size 필드 사용에 관한 자세한 내용은 섹션 4.6.1을 참조하십시오.

0-RTT 데이터의 매개변수\(버전, 대칭 암호화 제품군, ALPN\(Application-Layer Protocol Negotiation\) \[RFC7301\] 프로토콜 등\)는 사용 중인 PSK와 관련된 매개변수입니다. 외부에서 프로비저닝된 PSK의 경우 연결된 값은 키와 함께 프로비저닝된 값입니다. NewSessionTicket 메시지를 통해 설정된 PSK의 경우 연결된 값은 PSK를 설정한 연결에서 협상된 값입니다. 초기 데이터를 암호화하는 데 사용되는 PSK는 클라이언트의 "pre\_shared\_key" 확장에 나열된 첫 번째 PSK여야 합니다.\(MUST\)

NewSessionTicket을 통해 프로비저닝된 PSK의 경우 서버는 선택한 PSK ID의 티켓 수명\(PskIdentity.obfuscated\_ticket\_age 모듈로 2^32에서 ticket\_age\_add를 빼서 계산\)이 티켓이 발행된 이후 시간의 작은 허용 오차 내에 있는지 확인해야 합니다\(섹션 8 참조\). \). 그렇지 않은 경우 서버는 핸드셰이크를 진행해야 하지만 0-RTT를 거부하고 이 ClientHello가 신선하다고 가정하는 다른 조치를 취해서는 안 됩니다\(SHOULD NOT\).\(MUST, SHOULD NOT\)

첫 번째 비행에서 전송된 0-RTT 메시지는 다른 비행\(handshake 및 application\_data\)에서 전송된 동일한 유형의 메시지와 동일한\(암호화된\) 콘텐츠 유형을 갖지만 다른 키로 보호됩니다. 서버의 Finished 메시지를 수신한 후 서버가 초기 데이터를 수락한 경우 키 변경을 나타내기 위해 EndOfEarlyData 메시지가 전송됩니다. 이 메시지는 0-RTT 트래픽 키로 암호화됩니다.

"early\_data" 확장을 수신하는 서버는 다음 세 가지 방식 중 하나로 동작해야 합니다.\(MUST\)

- 확장명을 무시하고 일반 1-RTT 응답을 반환합니다. 그런 다음 서버는 핸드셰이크 트래픽 키를 사용하여 수신된 레코드의 보호 해제를 시도하고 보호 해제에 실패한 레코드를 삭제하여 이전 초기 데이터를 건너뜁니다\(구성된 max\_early\_data\_size까지\). 레코드의 보호가 성공적으로 해제되면 이는 클라이언트의 두 번째 비행이 시작된 것으로 간주되고 서버는 일반 1-RTT 핸드셰이크와 마찬가지로 진행됩니다.

- 클라이언트가 HelloRetryRequest로 응답하여 다른 ClientHello를 보내도록 요청합니다. 클라이언트는 후속 ClientHello에 "early\_data" 확장을 포함하면 안 됩니다. 그런 다음 서버는 구성된 max\_early\_data\_size까지 외부 콘텐츠 유형이 "application\_data"\(암호화되었음을 나타냄\)인 모든 레코드를 건너뛰어 초기 데이터를 무시합니다.\(MUST NOT\)

- EncryptedExtensions에 자체 "early\_data" 확장을 반환하여 초기 데이터를 처리할 것임을 나타냅니다. 서버가 초기 데이터 메시지의 하위 집합만 수락하는 것은 불가능합니다. 서버가 초기 데이터를 수락하는 메시지를 보내더라도 서버가 이 메시지를 생성할 때 실제 초기 데이터 자체가 이미 비행 중일 수 있습니다.

초기 데이터를 수락하기 위해 서버는 PSK 암호 제품군을 수락하고 클라이언트의 "pre\_shared\_key" 확장에서 제공되는 첫 번째 키를 선택해야 합니다. 또한 다음 값이 선택한 PSK와 연결된 값과 동일한지 확인해야 합니다.\(MUST, MUST\)

- TLS 버전 번호

- 선택한 암호 제품군

- 선택한 ALPN \[RFC7301\] 프로토콜\(있는 경우\)

이러한 요구 사항은 해당 PSK를 사용하여 1-RTT 핸드셰이크를 수행하는 데 필요한 요구 사항의 상위 집합입니다. 외부에서 설정된 PSK의 경우 연결된 값은 키와 함께 프로비저닝된 값입니다. NewSessionTicket 메시지를 통해 설정된 PSK의 경우 관련 값은 티켓이 설정된 연결에서 협상된 값입니다.

향후 확장은 0-RTT와의 상호 작용을 정의해야 합니다.\(MUST\)

이러한 검사 중 하나라도 실패하면 서버는 확장으로 응답해서는 안 되며 위에 나열된 처음 두 메커니즘 중 하나를 사용하여 모든 첫 비행 데이터를 폐기해야 합니다\(따라서 1-RTT 또는 2-RTT로 폴백\). 클라이언트가 0-RTT 핸드셰이크를 시도하지만 서버가 이를 거부하는 경우 서버는 일반적으로 0-RTT 레코드 보호 키를 가지지 않으며 대신 시험 암호 해독을 사용해야 합니다\(1-RTT 핸드셰이크 키를 사용하거나 일반 텍스트 ClientHello를 찾아서\). HelloRetryRequest의 경우\) 0-RTT가 아닌 첫 번째 메시지를 찾습니다.\(MUST NOT\)

서버가 "early\_data" 확장을 수락하기로 선택한 경우 초기 데이터 레코드를 처리할 때 모든 레코드에 대해 지정된 동일한 오류 처리 요구 사항을 준수해야 합니다. 특히, 서버가 허용된 "early\_data" 확장 이후 0-RTT 레코드를 해독하는 데 실패하면 섹션 5.2에 따라 "bad\_record\_mac" 경고와 함께 연결을 종료해야 합니다.\(MUST, MUST\)

서버가 "early\_data" 확장을 거부하는 경우 클라이언트 응용 프로그램은 핸드셰이크가 완료되면 이전에 초기 데이터로 전송된 응용 프로그램 데이터를 재전송하도록 선택할 수 있습니다\(MAY\). 초기 데이터의 자동 재전송으로 인해 연결 상태에 대한 잘못된 가정이 발생할 수 있습니다. 예를 들어 협상된 연결이 초기 데이터에 사용된 것과 다른 ALPN 프로토콜을 선택하는 경우 응용 프로그램은 다른 메시지를 구성해야 할 수 있습니다. 마찬가지로 초기 데이터가 연결 상태에 대해 가정하는 경우 핸드셰이크가 완료된 후 오류로 전송될 수 있습니다.\(MAY\)

TLS 구현은 초기 데이터를 자동으로 재전송하면 안 됩니다\(SHOULD NOT\). 응용 프로그램은 재전송이 적절한 시기를 결정하는 데 더 나은 위치에 있습니다. TLS 구현은 협상된 연결이 동일한 ALPN 프로토콜을 선택하지 않는 한 초기 데이터를 자동으로 재전송해서는 안 됩니다\(MUST NOT\).\(SHOULD NOT, MUST NOT\)

---
#### **4.2.11.  Pre-Shared Key Extension**

"pre\_shared\_key" 확장자는 PSK 키 설정과 관련하여 주어진 핸드셰이크와 함께 사용할 사전 공유 키의 ID를 협상하는 데 사용됩니다.

이 확장 프로그램의 "extension\_data" 필드에는 "PreSharedKeyExtension" 값이 포함되어 있습니다.

```text
      struct {
          opaque identity<1..2^16-1>;
          uint32 obfuscated_ticket_age;
      } PskIdentity;

      opaque PskBinderEntry<32..255>;

      struct {
          PskIdentity identities<7..2^16-1>;
          PskBinderEntry binders<33..2^16-1>;
      } OfferedPsks;

      struct {
          select (Handshake.msg_type) {
              case client_hello: OfferedPsks;
              case server_hello: uint16 selected_identity;
          };
      } PreSharedKeyExtension;
```

ID: 키의 레이블입니다. 예를 들어 티켓\(부록 B.3.4에 정의됨\) 또는 외부에서 설정된 사전 공유 키에 대한 레이블입니다.

obfuscated\_ticket\_age: 키 연령의 난독화된 버전입니다. 섹션 4.2.11.1은 NewSessionTicket 메시지를 통해 설정된 ID에 대해 이 값을 구성하는 방법을 설명합니다. 외부에서 설정된 ID의 경우 obfuscated\_ticket\_age 0을 사용해야 하며 서버는 이 값을 무시해야 합니다.\(MUST\)

ID: 클라이언트가 서버와 협상하려는 ID 목록입니다. "early\_data" 확장\(섹션 4.2.10 참조\)과 함께 전송되는 경우 첫 번째 ID는 0-RTT 데이터에 사용되는 ID입니다.

바인더: 일련의 HMAC 값, ID 목록의 각 값에 대해 하나씩, 동일한 순서로 아래 설명된 대로 계산됩니다.

selected\_identity: 클라이언트 목록의 ID에 대한 인덱스\(0 기반\)로 표현되는 서버의 선택된 ID입니다.

각 PSK는 단일 해시 알고리즘과 연결됩니다. 티켓 메커니즘\(섹션 4.6.1\)을 통해 설정된 PSK의 경우 이는 티켓이 설정된 연결의 KDF 해시 알고리즘입니다. 외부에서 설정된 PSK의 경우 해시 알고리즘은 다음과 같은 경우에 설정해야 합니다.\(MUST\)

해당 알고리즘이 정의되지 않은 경우 PSK가 설정되거나 기본적으로 SHA-256으로 설정됩니다. 서버는 호환 가능한 PSK\(있는 경우\) 및 암호화 제품군을 선택해야 합니다.\(MUST\)

TLS 1.3 이전의 TLS 버전에서 SNI\(Server Name Identification\) 값은 세션\(\[RFC6066\]의 섹션 3\)과 연결되도록 의도되었으며 서버는 세션과 연결된 SNI 값이 재개 핸드셰이크에 지정된 것입니다. 그러나 실제로 구현은 제공된 두 SNI 값 중 어떤 것을 사용할 것인지에 대해 일관성이 없었기 때문에 일관성 요구 사항이 사실상 클라이언트에 의해 시행되었습니다. TLS 1.3에서 SNI 값은 항상 재개 핸드셰이크에 명시적으로 지정되며 서버가 SNI 값을 티켓과 연결할 필요가 없습니다. 그러나 클라이언트는 섹션 4.6.1의 요구 사항을 충족하기 위해 PSK와 함께 SNI를 저장해야 합니다\(SHOULD\).\(SHOULD\)

구현자 참고 사항: 세션 재개가 PSK의 주요 사용 사례인 경우 PSK/암호화 모음 일치 요구 사항을 구현하는 가장 간단한 방법은 먼저 암호화 모음을 협상한 다음 호환되지 않는 PSK를 제외하는 것입니다. 알 수 없는 PSK\(예: PSK 데이터베이스에 없거나 알 수 없는 키로 암호화된 것\)는 무시해야 합니다\(SHOULD\). 허용 가능한 PSK가 없으면 서버는 가능하면 PSK가 아닌 핸드셰이크를 수행해야 합니다\(SHOULD\). 이전 버전과의 호환성이 중요한 경우 클라이언트가 제공하고 외부에서 설정한 PSK가 암호 그룹 선택에 영향을 미쳐야 합니다\(SHOULD\).\(SHOULD, SHOULD, SHOULD\)

PSK 키 설정을 수락하기 전에 서버는 해당 바인더 값을 확인해야 합니다\(아래 섹션 4.2.11.2 참조\). 이 값이 없거나 유효하지 않은 경우 서버는 핸드셰이크를 중단해야 합니다. 서버는 여러 바인더의 유효성을 검사해서는 안 됩니다. 오히려 단일 PSK를 선택하고 해당 PSK에 해당하는 바인더만 유효성을 검사해야 합니다. 이 요구 사항에 대한 보안 근거는 섹션 8.2 및 부록 E.6을 참조하십시오. PSK 키 설정을 수락하기 위해 서버는 선택한 ID를 나타내는 "pre\_shared\_key" 확장자를 보냅니다.\(MUST, MUST, SHOULD NOT\)

클라이언트는 서버의 selected\_identity가 클라이언트가 제공한 범위 내에 있는지, 서버가 PSK와 연결된 해시를 나타내는 암호화 제품군을 선택했는지, ClientHello "psk\_key\_exchange\_modes" 확장에서 요구하는 경우 서버 "key\_share" 확장이 존재하는지 확인해야 합니다. . 이러한 값이 일치하지 않으면 클라이언트는 "illegal\_parameter" 경고와 함께 핸드셰이크를 중단해야 합니다.\(MUST, MUST\)

서버가 "early\_data" 확장을 제공하는 경우 클라이언트는 서버의 selected\_identity가 0인지 확인해야 합니다. 다른 값이 반환되면 클라이언트는 "illegal\_parameter" 경고와 함께 핸드셰이크를 중단해야 합니다.\(MUST, MUST\)

"pre\_shared\_key" 확장은 ClientHello의 마지막 확장이어야 합니다\(이것은 아래에 설명된 대로 구현을 용이하게 합니다\). 서버는 이것이 마지막 확장인지 확인하고 그렇지 않으면 "illegal\_parameter" 경고와 함께 핸드셰이크에 실패해야 합니다.\(MUST, MUST\)

---
##### **4.2.11.1.  Ticket Age**

티켓의 나이에 대한 클라이언트의 보기는 NewSessionTicket 메시지를 받은 이후의 시간입니다. 고객은 티켓과 함께 제공된 "ticket\_lifetime" 값보다 오래된 티켓을 사용하려고 시도해서는 안 됩니다. 각 PskIdentity의 "obfuscated\_ticket\_age" 필드에는 나이를 밀리초 단위로 가져오고 티켓에 포함된 "ticket\_age\_add" 값\(섹션 4.6.1 참조\)을 모듈로 2^32로 추가하여 형성된 티켓 연령의 난독화된 버전이 포함됩니다. 이 추가는 티켓이 재사용되지 않는 한 수동 관찰자가 연결을 연관시키는 것을 방지합니다. NewSessionTicket 메시지의 "ticket\_lifetime" 필드는 초 단위이지만 "obfuscated\_ticket\_age"는 밀리초 단위입니다. 티켓 수명은 1주일로 제한되기 때문에 32비트는 밀리초 단위라도 그럴 듯한 나이를 나타내기에 충분합니다.\(MUST NOT\)

---
##### **4.2.11.2.  PSK Binder**

PSK 바인더 값은 PSK가 생성된 핸드셰이크\(NewSessionTicket 메시지를 통해\)와 현재 핸드셰이크 간의 바인딩뿐만 아니라 PSK와 현재 핸드셰이크 간의 바인딩을 형성합니다. 바인더 목록의 각 항목은 PreSharedKeyExtension.identities 필드까지 부분 ClientHello를 포함하는 트랜스크립트 해시\(섹션 4.4.1 참조\)에 대한 HMAC로 계산됩니다. 즉, ClientHello는 모두 포함하지만 바인더 목록 자체는 포함하지 않습니다. 메시지의 길이 필드\(전체 길이, 확장 블록의 길이 및 "pre\_shared\_key" 확장의 길이 포함\)는 모두 올바른 길이의 바인더가 있는 것처럼 설정됩니다.

PskBinderEntry는 Finished 메시지\(섹션 4.4.4\)와 동일한 방식으로 계산되지만 BaseKey는 제공되는 해당 PSK의 키 일정을 통해 파생된 binder\_key입니다\(섹션 7.1 참조\).

핸드셰이크에 HelloRetryRequest가 포함된 경우 초기 ClientHello 및 HelloRetryRequest가 새 ClientHello와 함께 트랜스크립트에 포함됩니다. 예를 들어 클라이언트가 ClientHello1을 보내면 해당 바인더가 계산됩니다.

```text
      Transcript-Hash(Truncate(ClientHello1))
```

여기서 Truncate\(\)는 ClientHello에서 바인더 목록을 제거합니다.

서버가 HelloRetryRequest로 응답하고 클라이언트가 ClientHello2를 전송하면 해당 바인더가 계산됩니다.

```text
      Transcript-Hash(ClientHello1,
                      HelloRetryRequest,
                      Truncate(ClientHello2))
```

전체 ClientHello1/ClientHello2는 다른 모든 핸드셰이크 해시 계산에 포함됩니다. 첫 번째 비행에서는 Truncate\(ClientHello1\)가 직접 해시되지만 두 번째 비행에서는 ClientHello1이 해시된 다음 섹션 4.4.1에 설명된 대로 "message\_hash" 메시지로 다시 주입됩니다.

---
##### **4.2.11.3.  Processing Order**

클라이언트는 서버의 Finished를 수신할 때까지 0-RTT 데이터를 "스트리밍"할 수 있으며, 그런 다음 EndOfEarlyData 메시지를 보내고 나머지 핸드셰이크가 이어집니다. 교착 상태를 피하기 위해 "early\_data"를 수락할 때 서버는 클라이언트의 ClientHello를 처리한 다음 ServerHello를 보내기 전에 클라이언트의 EndOfEarlyData 메시지를 기다리지 않고 즉시 메시지 비행을 보내야 합니다.\(MUST\)

---
### **4.3.  Server Parameters**

서버의 다음 두 메시지인 EncryptedExtensions 및 CertificateRequest에는 나머지 핸드셰이크를 결정하는 서버의 정보가 포함되어 있습니다. 이러한 메시지는 server\_handshake\_traffic\_secret에서 파생된 키로 암호화됩니다.

---
#### **4.3.1.  Encrypted Extensions**

모든 핸드셰이크에서 서버는 ServerHello 메시지 직후에 EncryptedExtensions 메시지를 보내야 합니다. 이것은 server\_handshake\_traffic\_secret에서 파생된 키로 암호화된 첫 번째 메시지입니다.\(MUST\)

EncryptedExtensions 메시지에는 보호할 수 있는 확장, 즉 암호화 컨텍스트를 설정하는 데 필요하지 않지만 개별 인증서와 연결되지 않은 확장이 포함됩니다. 클라이언트는 금지된 확장이 있는지 EncryptedExtensions를 확인해야 하며 발견되면 "illegal\_parameter" 경고와 함께 핸드셰이크를 중단해야 합니다.\(MUST\)

이 메시지의 구조:

```text
      struct {
          Extension extensions<0..2^16-1>;
      } EncryptedExtensions;
```

extensions: 확장 목록입니다. 자세한 내용은 섹션 4.2의 표를 참조하십시오.

---
#### **4.3.2.  Certificate Request**

인증서로 인증하는 서버는 선택적으로 클라이언트에서 인증서를 요청할 수 있습니다. 이 메시지는 전송된 경우 EncryptedExtensions를 따라야 합니다.\(MAY, MUST\)

이 메시지의 구조:

```text
      struct {
          opaque certificate_request_context<0..2^8-1>;
          Extension extensions<2..2^16-1>;
      } CertificateRequest;
```

certificate\_request\_context: 인증서 요청을 식별하고 클라이언트의 인증서 메시지에 에코될 불투명한 문자열입니다. certificate\_request\_context는 이 연결 범위 내에서 고유해야 합니다\(따라서 클라이언트 CertificateVerify 메시지 재생 방지\). 이 필드는 섹션 4.6.2에 설명된 사후 핸드셰이크 인증 교환에 사용되지 않는 한 길이가 0이어야 합니다. 사후 핸드셰이크 인증을 요청할 때 서버는 클라이언트의 개인 키에 임시로 액세스할 수 있는 공격자가 유효한 CertificateVerify 메시지를 미리 계산하지 못하도록 클라이언트가 컨텍스트를 예측할 수 없도록 만들어야 합니다\(예: 임의로 생성\).\(MUST, MUST, SHOULD\)

확장: 요청 중인 인증서의 매개변수를 설명하는 확장 집합입니다. "signature\_algorithms" 확장을 지정해야 하며 이 메시지에 대해 정의된 경우 다른 확장을 선택적으로 포함할 수 있습니다. 클라이언트는 인식할 수 없는 확장자를 무시해야 합니다.\(MUST, MUST\)

이전 버전의 TLS에서 CertificateRequest 메시지는 서버가 수락할 서명 알고리즘 및 인증 기관 목록을 전달했습니다. TLS 1.3에서 전자는 "signature\_algorithms" 및 선택적으로 "signature\_algorithms\_cert" 확장을 전송하여 표현됩니다. 후자는 "certificate\_authorities" 확장자를 전송하여 표현됩니다\(섹션 4.2.4 참조\).

PSK로 인증하는 서버는 클라이언트가 "post\_handshake\_auth" 확장자를 보낸 경우\(섹션 4.2 참조\) 사후 핸드셰이크 인증\(섹션 4.6.2 참조\)으로 보낼 수 있지만 기본 핸드셰이크에서 CertificateRequest 메시지를 보내서는 안 됩니다\(MUST NOT\). .6\).\(MUST NOT\)

---
### **4.4.  Authentication Messages**

섹션 2에서 설명한 것처럼 TLS는 일반적으로 인증, 키 확인 및 핸드셰이크 무결성을 위한 공통 메시지 집합인 Certificate, CertificateVerify 및 Finished를 사용합니다. \(PSK 바인더도 비슷한 방식으로 키 확인을 수행합니다.\) 이 세 메시지는 항상 핸드셰이크 플라이트의 마지막 메시지로 전송됩니다. Certificate 및 CertificateVerify 메시지는 아래에 정의된 특정 상황에서만 전송됩니다. Finished 메시지는 항상 인증 블록의 일부로 전송됩니다. 이러한 메시지는 \[sender\]\_handshake\_traffic\_secret에서 파생된 키로 암호화됩니다.

인증 메시지에 대한 계산은 모두 균일하게 다음 입력을 사용합니다.

- 사용할 인증서 및 서명 키입니다.

- 성적 해시에 포함될 메시지 세트로 구성된 핸드셰이크 컨텍스트.

- MAC 키를 계산하는 데 사용되는 기본 키입니다.

이러한 입력을 기반으로 메시지에는 다음이 포함됩니다.

인증서: 인증에 사용할 인증서 및 체인의 모든 지원 인증서입니다. PSK 핸드셰이크 흐름\(0-RTT 포함\)에서는 인증서 기반 클라이언트 인증을 사용할 수 없습니다.

CertificateVerify: Transcript-Hash\(Handshake Context, Certificate\) 값에 대한 서명입니다.

완료됨: 기본 키에서 파생된 MAC 키를 사용하여 Transcript-Hash\(Handshake Context, Certificate, CertificateVerify\) 값에 대한 MAC입니다.

다음 표는 각 시나리오에 대한 핸드셰이크 컨텍스트 및 MAC 기본 키를 정의합니다.

```text
   +-----------+-------------------------+-----------------------------+
   | Mode      | Handshake Context       | Base Key                    |
   +-----------+-------------------------+-----------------------------+
   | Server    | ClientHello ... later   | server_handshake_traffic_   |
   |           | of EncryptedExtensions/ | secret                      |
   |           | CertificateRequest      |                             |
   |           |                         |                             |
   | Client    | ClientHello ... later   | client_handshake_traffic_   |
   |           | of server               | secret                      |
   |           | Finished/EndOfEarlyData |                             |
   |           |                         |                             |
   | Post-     | ClientHello ... client  | client_application_traffic_ |
   | Handshake | Finished +              | secret_N                    |
   |           | CertificateRequest      |                             |
   +-----------+-------------------------+-----------------------------+
```

---
#### **4.4.1.  The Transcript Hash**

TLS의 많은 암호화 계산은 성적표 해시를 사용합니다. 이 값은 핸드셰이크 메시지 유형 및 길이 필드를 전달하지만 레코드 레이어 헤더는 포함하지 않는 핸드셰이크 메시지 헤더를 포함하여 포함된 각 핸드셰이크 메시지의 연결을 해싱하여 계산됩니다. 즉.,

```text
    Transcript-Hash(M1, M2, ... Mn) = Hash(M1 || M2 || ... || Mn)
```

이 일반 규칙에 대한 예외로 서버가 HelloRetryRequest로 ClientHello에 응답할 때 ClientHello1의 값은 Hash\(ClientHello1\)를 포함하는 핸드셰이크 유형 "message\_hash"의 특수 합성 핸드셰이크 메시지로 대체됩니다. 즉.,

```text
  Transcript-Hash(ClientHello1, HelloRetryRequest, ... Mn) =
      Hash(message_hash ||        /* Handshake type */
           00 00 Hash.length  ||  /* Handshake message length (bytes) */
           Hash(ClientHello1) ||  /* Hash of ClientHello1 */
           HelloRetryRequest  || ... || Mn)
```

이렇게 구성하는 이유는 서버가 전체 중간 해시 상태를 내보내도록 요구하지 않고 ClientHello1의 해시만 쿠키에 저장하여 상태 비저장 HelloRetryRequest를 수행할 수 있도록 하기 위함입니다\(섹션 4.2.2 참조\).

구체적으로 말하면, 성적표 해시는 항상 첫 번째 ClientHello에서 시작하여 ClientHello, HelloRetryRequest, ClientHello, ServerHello, EncryptedExtensions, 서버 CertificateRequest, 서버 인증서, 서버 CertificateVerify와 같이 전송된 메시지만 포함하는 핸드셰이크 메시지 시퀀스에서 가져옵니다. 서버 완료, EndOfEarlyData, 클라이언트 인증서, 클라이언트 CertificateVerify, 클라이언트 완료.

일반적으로 구현은 협상된 해시를 기반으로 실행 중인 성적표 해시 값을 유지하여 성적표를 구현할 수 있습니다. 그러나 후속 포스트 핸드셰이크 인증에는 서로가 포함되지 않으며 기본 핸드셰이크 종료를 통한 메시지만 포함됩니다.

---
#### **4.4.2.  Certificate**

이 메시지는 끝점의 인증서 체인을 피어에 전달합니다.

서버는 합의된 키 교환 방법이 인증을 위해 인증서를 사용할 때마다 인증서 메시지를 보내야 합니다\(여기에는 PSK를 제외하고 이 문서에 정의된 모든 키 교환 방법이 포함됨\).\(MUST\)

클라이언트는 서버가 CertificateRequest 메시지\(섹션 4.3.2\)를 통해 클라이언트 인증을 요청한 경우에만 인증서 메시지를 보내야 합니다. 서버가 클라이언트 인증을 요청했지만 적합한 인증서를 사용할 수 없는 경우 클라이언트는 인증서가 포함되지 않은 인증서 메시지를 보내야 합니다\(즉, 길이가 0인 "certificate\_list" 필드 포함\). 완료 메시지는 인증서 메시지가 비어 있는지 여부에 관계없이 전송되어야 합니다.\(MUST, MUST, MUST\)

이 메시지의 구조:

```text
      enum {
          X509(0),
          RawPublicKey(2),
          (255)
      } CertificateType;

      struct {
          select (certificate_type) {
              case RawPublicKey:
                /* From RFC 7250 ASN.1_subjectPublicKeyInfo */
                opaque ASN1_subjectPublicKeyInfo<1..2^24-1>;

              case X509:
                opaque cert_data<1..2^24-1>;
          };
          Extension extensions<0..2^16-1>;
      } CertificateEntry;

      struct {
          opaque certificate_request_context<0..2^8-1>;
          CertificateEntry certificate_list<0..2^24-1>;
      } Certificate;
```

certificate\_request\_context: 이 메시지가 CertificateRequest에 대한 응답인 경우 해당 메시지의 certificate\_request\_context 값입니다. 그렇지 않으면\(서버 인증의 경우\) 이 필드는 길이가 0이어야 합니다.\(MUST\)

certificate\_list: 각각 단일 인증서와 확장 집합을 포함하는 CertificateEntry 구조의 시퀀스\(체인\)입니다.

extensions: CertificateEntry에 대한 확장 값 집합입니다. "확장" 형식은 섹션 4.2에 정의되어 있습니다. 현재 유효한 서버 인증서 확장에는 OCSP 상태 확장\[RFC6066\] 및 SignedCertificateTimestamp 확장\[RFC6962\]이 포함됩니다. 이 메시지에 대한 향후 확장도 정의될 수 있습니다. 서버의 인증서 메시지에 있는 확장은 ClientHello 메시지의 확장과 일치해야 합니다. 클라이언트의 Certificate 메시지의 확장은 서버의 CertificateRequest 메시지의 확장과 일치해야 합니다. 확장이 전체 체인에 적용되는 경우 첫 번째 CertificateEntry에 포함되어야 합니다\(SHOULD\).\(MUST, MUST, SHOULD\)

해당 인증서 유형 확장\("server\_certificate\_type" 또는 "client\_certificate\_type"\)이 EncryptedExtensions에서 협상되지 않았거나 X.509 인증서 유형이 협상된 경우 각 CertificateEntry에는 DER로 인코딩된 X.509 인증서가 포함됩니다. 보낸 사람의 인증서는 목록의 첫 번째 CertificateEntry에 있어야 합니다. 다음 각 인증서는 바로 앞의 인증서를 직접 인증해야 합니다\(SHOULD\). 인증서 유효성 검사에는 트러스트 앵커가 독립적으로 배포되어야 하므로 지원되는 피어가 생략된 인증서를 소유하고 있는 것으로 알려진 경우 트러스트 앵커를 지정하는 인증서를 체인에서 생략할 수 있습니다\(MAY\).\(MUST, SHOULD, MAY\)

참고: TLS 1.3 이전에는 "certificate\_list" 주문 시 각 인증서가 바로 앞의 인증서를 인증해야 했습니다. 그러나 일부 구현에서는 약간의 유연성이 허용되었습니다. 서버는 때때로 전환 ​​목적으로 현재 및 더 이상 사용되지 않는 중간을 모두 보내고 다른 것들은 단순히 잘못 구성되었지만 이러한 경우에도 적절하게 유효성을 검사할 수 있습니다. 호환성을 최대화하기 위해 모든 구현은 반드시 첫 번째여야 하는 최종 엔터티 인증서를 제외하고 모든 TLS 버전에서 잠재적으로 관련 없는 인증서 및 임의 순서를 처리할 수 있도록 준비해야 합니다\(SHOULD\).\(MUST\)

RawPublicKey 인증서 유형이 협상된 경우 certificate\_list는 \[RFC7250\], 섹션 3에 정의된 ASN1\_subjectPublicKeyInfo 값을 포함하는 하나 이상의 CertificateEntry를 포함하지 않아야 합니다.\(MUST\)

OpenPGP 인증서 유형\[RFC6091\]은 TLS 1.3과 함께 사용하면 안 됩니다\(MUST NOT\).\(MUST NOT\)

서버의 certificate\_list는 항상 비어 있지 않아야 합니다. 클라이언트는 서버의 인증 요청에 대한 응답으로 보낼 적절한 인증서가 없는 경우 빈 certificate\_list를 보냅니다.\(MUST\)

---
##### **4.4.2.1.  OCSP Status and SCT Extensions**

\[RFC6066\] 및 \[RFC6961\]은 OCSP 응답을 클라이언트에 보내는 서버를 협상하기 위한 확장을 제공합니다. TLS 1.2 이하에서 서버는 이 확장의 협상을 나타내기 위해 빈 확장으로 응답하고 OCSP 정보는 CertificateStatus 메시지에 전달됩니다. TLS 1.3에서 서버의 OCSP 정보는 연결된 인증서를 포함하는 CertificateEntry의 확장으로 전달됩니다. 특히 서버의 "status\_request" 확장 본문은 \[RFC6066\]에 정의된 대로 CertificateStatus 구조여야 하며 \[RFC6960\]에 정의된 대로 해석됩니다.\(MUST\)

참고: status\_request\_v2 확장 \[RFC6961\]은 더 이상 사용되지 않습니다. TLS 1.3 서버는 ClientHello 메시지를 처리할 때 자신의 존재 또는 정보에 따라 행동해서는 안 됩니다. 특히 EncryptedExtensions, CertificateRequest 또는 Certificate 메시지에서 status\_request\_v2 확장을 전송하면 안 됩니다\(MUST NOT\). TLS 1.3 서버는 이를 포함하는 ClientHello 메시지를 처리할 수 있어야 합니다. 이전 프로토콜 버전에서 사용하려는 클라이언트가 보낼 수 있기 때문입니다.\(MUST NOT, MUST\)

서버는 클라이언트가 CertificateRequest 메시지에 빈 "status\_request" 확장을 전송하여 인증서와 함께 OCSP 응답을 제공하도록 요청할 수 있습니다\(MAY\). 클라이언트가 OCSP 응답을 보내기로 선택한 경우 "status\_request" 확장의 본문은 \[RFC6066\]에 정의된 CertificateStatus 구조여야 합니다.\(MAY, MUST\)

마찬가지로 \[RFC6962\]는 서버가 TLS 1.2 이하에서 ServerHello의 확장으로 SCT\(Signed Certificate Timestamp\)를 보내는 메커니즘을 제공합니다. TLS 1.3에서 서버의 SCT 정보는 CertificateEntry의 확장으로 전달됩니다.

---
##### **4.4.2.2.  Server Certificate Selection**

서버에서 보낸 인증서에는 다음 규칙이 적용됩니다.

- 달리 명시적으로 협상되지 않는 한\(예: \[RFC7250\]\) 인증서 유형은 X.509v3 \[RFC5280\]이어야 합니다.\(MUST\)

- 서버의 최종 엔터티 인증서의 공개 키\(및 관련 제한 사항\)는 클라이언트의 "signature\_algorithms" 확장\(현재 RSA, ECDSA 또는 EdDSA\)에서 선택한 인증 알고리즘과 호환되어야 합니다.\(MUST\)

- 인증서는 클라이언트의 "signature\_algorithms"/"signature\_algorithms\_cert" 확장에 표시된 서명 체계를 사용하여 서명에 키를 사용할 수 있도록 허용해야 합니다\(즉, 키 사용 확장이 있는 경우 digitalSignature 비트를 설정해야 함\)\(섹션 4.2. 삼\).\(MUST\)

- "server\_name" \[RFC6066\] 및 "certificate\_authorities" 확장은 인증서 선택을 안내하는 데 사용됩니다. 서버는 "server\_name" 확장의 존재를 요구할 수 있으므로 클라이언트는 해당되는 경우 이 확장을 보내야 합니다.\(SHOULD\)

서버가 제공하는 모든 인증서는 그러한 체인을 제공할 수 있는 경우 클라이언트가 광고하는 서명 알고리즘에 의해 서명되어야 합니다\(섹션 4.2.3 참조\). 자체 서명된 인증서 또는 트러스트 앵커가 될 것으로 예상되는 인증서는 체인의 일부로 검증되지 않으므로 모든 알고리즘으로 서명될 수 있습니다.\(MUST, MAY\)

서버가 표시된 지원 알고리즘을 통해서만 서명된 인증서 체인을 생성할 수 없는 경우 클라이언트가 지원하는 것으로 알려지지 않은 알고리즘을 포함할 수 있는 선택한 인증서 체인을 클라이언트에 전송하여 핸드셰이크를 계속해야 합니다\(SHOULD\). 이 폴백 체인은 일반적으로 더 이상 사용되지 않는 SHA-1 해시 알고리즘을 사용하지 않아야 하지만 클라이언트의 광고가 허용하는 경우 그렇게 할 수 있고 그렇지 않은 경우에는 그렇게 하면 안 됩니다\(MUST NOT\).\(SHOULD, MUST NOT\)

클라이언트가 제공된 인증서를 사용하여 허용 가능한 체인을 구성할 수 없고 핸드셰이크를 중단하기로 결정한 경우 적절한 인증서 관련 경고\(기본적으로 "unsupported\_certificate"; 자세한 내용은 섹션 6.2 참조\)와 함께 핸드셰이크를 중단해야 합니다.\(MUST\)

서버에 여러 인증서가 있는 경우 위에서 언급한 기준\(전송 계층 끝점, 로컬 구성 및 기본 설정과 같은 다른 기준 외에\)에 따라 인증서 중 하나를 선택합니다.

---
##### **4.4.2.3.  Client Certificate Selection**

다음 규칙은 클라이언트가 보낸 인증서에 적용됩니다.

- 달리 명시적으로 협상되지 않는 한\(예: \[RFC7250\]\) 인증서 유형은 X.509v3 \[RFC5280\]이어야 합니다.\(MUST\)

- CertificateRequest 메시지에 "certificate\_authorities" 확장이 있는 경우 인증서 체인에 있는 인증서 중 적어도 하나는 나열된 CA 중 하나에서 발급되어야 합니다.\(SHOULD\)

- 인증서는 섹션 4.3.2에 설명된 대로 허용 가능한 서명 알고리즘을 사용하여 서명되어야 합니다. 이는 이전 버전의 TLS에서 발견된 인증서 서명 알고리즘에 대한 제약을 완화합니다.\(MUST\)

- CertificateRequest 메시지에 비어 있지 않은 "oid\_filters" 확장이 포함된 경우 최종 엔터티 인증서는 섹션 4.2.5에 설명된 대로 클라이언트가 인식하는 확장 OID와 일치해야 합니다.\(MUST\)

---
##### **4.4.2.4.  Receiving a Certificate Message**

일반적으로 자세한 인증서 유효성 검사 절차는 TLS 범위를 벗어납니다\(\[RFC5280\] 참조\). 이 섹션에서는 TLS 관련 요구 사항을 제공합니다.

서버가 빈 인증서 메시지를 제공하는 경우 클라이언트는 "decode\_error" 경고와 함께 핸드셰이크를 중단해야 합니다.\(MUST\)

클라이언트가 인증서를 보내지 않는 경우\(즉, 빈 인증서 메시지를 보내는 경우\) 서버는 재량에 따라 클라이언트 인증 없이 핸드셰이크를 계속하거나 "certificate\_required" 경고와 함께 핸드셰이크를 중단할 수 있습니다. 또한 인증서 체인의 일부 측면이 허용되지 않는 경우\(예: 알려진 신뢰할 수 있는 CA에 의해 서명되지 않은 경우\) 서버는 재량에 따라 핸드셰이크를 계속하거나\(클라이언트가 인증되지 않은 것으로 간주\) 핸드셰이크를 중단할 수 있습니다.\(MAY, MAY\)

MD5 해시를 사용하는 서명 알고리즘을 사용하여 유효성을 검사해야 하는 인증서를 수신하는 엔드포인트는 "bad\_certificate" 경고와 함께 핸드셰이크를 중단해야 합니다. SHA-1은 더 이상 사용되지 않으며 SHA-1 해시를 사용하는 서명 알고리즘을 사용하여 유효성을 검사해야 하는 인증서를 수신하는 엔드포인트는 "bad\_certificate" 경고와 함께 핸드셰이크를 중단할 것을 권장합니다. 명확성을 위해 이는 엔드포인트가 자체 서명되었거나 트러스트 앵커인 인증서에 대해 이러한 알고리즘을 수락할 수 있음을 의미합니다.\(MUST, SHOULD\)

모든 엔드포인트는 현재 SHA-1 지원을 단계적으로 중단하는 과정에 있는 구현과의 상호 운용성을 유지하기 위해 가능한 한 빨리 SHA-256 이상으로 전환하는 것이 좋습니다\(RECOMMENDED\).\(SHOULD\)

하나의 서명 알고리즘에 대한 키를 포함하는 인증서는 다른 서명 알고리즘\(예: ECDSA 키로 서명된 RSA 키\)을 사용하여 서명될 수 있습니다.\(MAY\)

---
#### **4.4.3.  Certificate Verify**

이 메시지는 끝점이 해당 인증서에 해당하는 개인 키를 소유하고 있다는 명시적 증거를 제공하는 데 사용됩니다. CertificateVerify 메시지는 또한 이 시점까지의 핸드셰이크에 대한 무결성을 제공합니다. 서버는 인증서를 통해 인증할 때 이 메시지를 보내야 합니다. 클라이언트는 인증서를 통해 인증할 때마다\(즉, 인증서 메시지가 비어 있지 않을 때\) 이 메시지를 보내야 합니다. 전송될 때 이 메시지는 인증서 메시지 바로 뒤와 완료 메시지 바로 앞에 나타나야 합니다.\(MUST, MUST, MUST\)

이 메시지의 구조:

```text
      struct {
          SignatureScheme algorithm;
          opaque signature<0..2^16-1>;
      } CertificateVerify;
```

알고리즘 필드는 사용된 서명 알고리즘을 지정합니다\(이 유형의 정의는 섹션 4.2.3 참조\). 서명은 해당 알고리즘을 사용하는 디지털 서명입니다. 서명 아래에 포함되는 콘텐츠는 섹션 4.4.1에 설명된 해시 출력입니다. 즉,

```text
      Transcript-Hash(Handshake Context, Certificate)
```

그런 다음 디지털 서명은 다음을 연결하여 계산됩니다.

- 64번 반복되는 옥텟 32\(0x20\)로 구성된 문자열

- 컨텍스트 문자열

- 구분 기호로 사용되는 단일 0바이트

- 서명할 내용

이 구조는 ServerKeyExchange 형식이 공격자가 선택한 32바이트 접두사\(ClientHello.random\)가 있는 메시지의 서명을 얻을 수 있음을 의미했던 이전 버전의 TLS에 대한 공격을 방지하기 위한 것입니다. 초기 64바이트 패드는 서버 제어 ServerHello.random과 함께 해당 접두사를 지웁니다.

서버 서명의 컨텍스트 문자열은 "TLS 1.3, 서버 CertificateVerify"입니다. 클라이언트 서명의 컨텍스트 문자열은 "TLS 1.3, 클라이언트 CertificateVerify"입니다. 서로 다른 컨텍스트에서 만들어진 서명을 분리하여 잠재적인 교차 프로토콜 공격을 방지하는 데 사용됩니다.

예를 들어, 트랜스크립트 해시가 01의 32바이트인 경우\(이 길이는 SHA-256에 적합함\) 서버 CertificateVerify의 디지털 서명이 적용되는 콘텐츠는 다음과 같습니다.

```text
      2020202020202020202020202020202020202020202020202020202020202020
      2020202020202020202020202020202020202020202020202020202020202020
      544c5320312e332c207365727665722043657274696669636174655665726966
      79
      00
      0101010101010101010101010101010101010101010101010101010101010101
```

발신자 측에서 CertificateVerify 메시지의 서명 필드를 계산하는 프로세스는 입력으로 사용됩니다.

- 디지털 서명이 적용되는 내용

- 이전 메시지에서 보낸 인증서에 해당하는 개인 서명 키

CertificateVerify 메시지가 서버에 의해 전송되는 경우 서명 알고리즘은 지원되지 않는 알고리즘 없이 유효한 인증서 체인을 생성할 수 없는 한 클라이언트의 "signature\_algorithms" 확장에서 제공되는 것이어야 합니다\(섹션 4.2.3 참조\).\(MUST\)

클라이언트가 보낸 경우 서명에 사용된 서명 알고리즘은 CertificateRequest 메시지에 있는 "signature\_algorithms" 확장의 supported\_signature\_algorithms 필드에 있는 알고리즘 중 하나여야 합니다.\(MUST\)

또한 서명 알고리즘은 발신자의 최종 엔터티 인증서의 키와 호환되어야 합니다. RSA 서명은 RSASSA-PKCS1-v1\_5 알고리즘이 "signature\_algorithms"에 표시되는지 여부에 관계없이 RSASSA-PSS 알고리즘을 사용해야 합니다. SHA-1 알고리즘은 CertificateVerify 메시지의 서명에 사용되어서는 안 됩니다\(MUST NOT\).\(MUST, MUST, MUST NOT\)

이 사양의 모든 SHA-1 서명 알고리즘은 레거시 인증서에서만 사용하도록 정의되며 CertificateVerify 서명에는 유효하지 않습니다.

CertificateVerify 메시지의 수신자는 서명 필드를 확인해야 합니다. 확인 프로세스는 다음을 입력으로 사용합니다.\(MUST\)

- 디지털 서명이 적용되는 내용

- 관련 인증서 메시지에 있는 최종 엔터티 인증서에 포함된 공개 키

- CertificateVerify 메시지의 서명 필드에 수신된 디지털 서명

확인이 실패하면 수신자는 "decrypt\_error" 경고와 함께 핸드셰이크를 종료해야 합니다.\(MUST\)

---
#### **4.4.4.  Finished**

Finished 메시지는 인증 블록의 최종 메시지입니다. 핸드셰이크 및 계산된 키의 인증을 제공하는 데 필수적입니다.

완료된 메시지의 수신자는 내용이 올바른지 확인해야 하며 잘못된 경우 "decrypt\_error" 경고와 함께 연결을 종료해야 합니다.\(MUST\)

한쪽이 Finished 메시지를 전송하고 피어로부터 Finished 메시지를 수신 및 확인하면 연결을 통해 애플리케이션 데이터를 송수신하기 시작할 수 있습니다. 피어의 Finished를 수신하기 전에 데이터를 보낼 수 있는 두 가지 설정이 있습니다.

1. 섹션 4.2.10에 설명된 대로 0-RTT 데이터를 보내는 클라이언트.

2. 서버는 첫 비행을 보낸 후 데이터를 보낼 수 있지만 핸드셰이크가 아직 완료되지 않았기 때문에 피어의 신원이나 활성 상태에 대한 보장이 없습니다\(즉, ClientHello가 재생되었을 수 있음\).\(MAY\)

Finished 메시지를 계산하는 데 사용되는 키는 HKDF를 사용하여 섹션 4.4에 정의된 기본 키에서 계산됩니다\(섹션 7.1 참조\). 구체적으로:

```text
   finished_key =
       HKDF-Expand-Label(BaseKey, "finished", "", Hash.length)
```

이 메시지의 구조:

```text
      struct {
          opaque verify_data[Hash.length];
      } Finished;
```

verify\_data 값은 다음과 같이 계산됩니다.

```text
      verify_data =
          HMAC(finished_key,
               Transcript-Hash(Handshake Context,
                               Certificate*, CertificateVerify*))
```

- \* 있는 경우에만 포함됩니다.

HMAC\[RFC2104\]는 핸드셰이크에 해시 알고리즘을 사용합니다. 위에서 언급한 것처럼 HMAC 입력은 일반적으로 실행 중인 해시, 즉 이 시점에서 핸드셰이크 해시에 의해 구현될 수 있습니다.

이전 버전의 TLS에서 verify\_data는 항상 12옥텟 길이였습니다. TLS 1.3에서는 핸드셰이크에 사용되는 해시의 HMAC 출력 크기입니다.

참고: 경고 및 기타 비핸드셰이크 레코드 유형은 핸드셰이크 메시지가 아니며 해시 계산에 포함되지 않습니다.

완료 메시지 다음의 모든 레코드는 섹션 7.2에 설명된 대로 적절한 애플리케이션 트래픽 키로 암호화되어야 합니다. 특히 여기에는 클라이언트 인증서 및 CertificateVerify 메시지에 대한 응답으로 서버에서 보낸 모든 경고가 포함됩니다.\(MUST\)

---
### **4.5.  End of Early Data**

```text
      struct {} EndOfEarlyData;
```

서버가 EncryptedExtensions에서 "early\_data" 확장을 보낸 경우 클라이언트는 서버 완료를 수신한 후 EndOfEarlyData 메시지를 보내야 합니다. 서버가 EncryptedExtensions에서 "early\_data" 확장을 보내지 않으면 클라이언트는 EndOfEarlyData 메시지를 보내면 안 됩니다\(MUST NOT\). 이 메시지는 모든 0-RTT application\_data 메시지가 전송되었음을 나타냅니다.\(MUST, MUST NOT\)

다음 레코드는 핸드셰이크 트래픽 키로 보호됩니다. 서버는 이 메시지를 전송해서는 안 되며 이를 수신하는 클라이언트는 "unexpected\_message" 경고와 함께 연결을 종료해야 합니다. 이 메시지는 client\_early\_traffic\_secret에서 파생된 키로 암호화됩니다.\(MUST NOT\)

---
### **4.6.  Post-Handshake Messages**

TLS는 또한 기본 핸드셰이크 후에 다른 메시지를 보낼 수 있습니다. 이러한 메시지는 핸드셰이크 콘텐츠 유형을 사용하며 적절한 애플리케이션 트래픽 키로 암호화됩니다.

---
#### **4.6.1.  New Session Ticket Message**

서버가 클라이언트 Finished 메시지를 수신한 후 언제든지 NewSessionTicket 메시지를 보낼 수 있습니다. 이 메시지는 티켓 값과 재개 마스터 비밀에서 파생된 비밀 PSK 사이에 고유한 연결을 생성합니다\(섹션 7 참조\).\(MAY\)

클라이언트는 ClientHello\(섹션 4.2.11\)의 "pre\_shared\_key" 확장에 티켓 값을 포함하여 향후 핸드셰이크에 이 PSK를 사용할 수 있습니다\(MAY\). 서버는 서로의 직후 또는 특정 이벤트 이후에 단일 연결에서 여러 티켓을 보낼 수 있습니다\(부록 C.4 참조\). 예를 들어 서버는 추가 클라이언트 인증 상태를 캡슐화하기 위해 사후 핸드셰이크 인증 후에 새 티켓을 보낼 수 있습니다. 여러 티켓은 다음과 같은 다양한 목적으로 고객에게 유용합니다.\(MAY, MAY\)

```text
   -  Opening multiple parallel HTTP connections.
```

- \(예를 들어\) Happy Eyeballs \[RFC8305\] 또는 관련 기술을 통해 인터페이스 및 주소 계열 전반에 걸쳐 연결 레이싱을 수행합니다.

모든 티켓은 원래 연결을 설정하는 데 사용된 것과 동일한 KDF 해시 알고리즘을 가진 암호화 제품군으로만 재개되어야 합니다.\(MUST\)

클라이언트는 새 SNI 값이 원래 세션에 제공된 서버 인증서에 유효한 경우에만 재개해야 하며 SNI 값이 원래 세션에서 사용된 값과 일치하는 경우에만 재개해야 합니다\(SHOULD\). 후자는 성능 최적화입니다. 일반적으로 단일 인증서가 적용되는 서로 다른 서버가 서로의 티켓을 수락할 수 있다고 기대할 이유가 없습니다. 따라서 이 경우 재개를 시도하면 일회용 티켓이 낭비됩니다. 이러한 표시가 제공되는 경우\(외부적으로 또는 다른 방법으로\) 클라이언트는 다른 SNI 값으로 재개할 수 있습니다.\(MUST, MAY\)

재개 시 SNI 값을 호출 애플리케이션에 보고하는 경우 구현은 이전 세션에서 전송된 값이 아니라 재개 ClientHello에서 전송된 값을 사용해야 합니다. 서버 구현이 SNI 값이 다른 모든 PSK ID를 거부하는 경우 이 두 값은 항상 동일합니다.\(MUST\)

참고: 재개 마스터 시크릿은 클라이언트의 두 번째 비행에 따라 다르지만 클라이언트 인증을 요청하지 않는 서버는 트랜스크립트의 나머지 부분을 독립적으로 계산한 다음 클라이언트 완료를 기다리지 않고 완료를 보내는 즉시 NewSessionTicket을 보낼 수 있습니다. 이는 클라이언트가 여러 TLS 연결을 병렬로 열 것으로 예상되고 예를 들어 재개 핸드셰이크의 감소된 오버헤드로부터 이점을 얻을 수 있는 경우에 적절할 수 있습니다.\(MAY\)

```text
      struct {
          uint32 ticket_lifetime;
          uint32 ticket_age_add;
          opaque ticket_nonce<0..255>;
          opaque ticket<1..2^16-1>;
          Extension extensions<0..2^16-2>;
      } NewSessionTicket;
```

ticket\_lifetime: 티켓 발급 시점부터 네트워크 바이트 순서로 32비트 부호 없는 정수로 초 단위로 수명을 나타냅니다. 서버는 604800초\(7일\)보다 큰 값을 사용하면 안 됩니다. 0 값은 티켓을 즉시 폐기해야 함을 나타냅니다. 클라이언트는 ticket\_lifetime에 관계없이 7일 이상 티켓을 캐시하면 안 되며 로컬 정책에 따라 더 일찍 티켓을 삭제할 수 있습니다. 서버는 티켓을 ticket\_lifetime에 명시된 것보다 더 짧은 기간 동안 유효한 것으로 취급할 수 있습니다\(MAY\).\(MUST NOT, MUST NOT, MAY\)

ticket\_age\_add: 클라이언트가 "pre\_shared\_key" 확장에 포함하는 티켓의 수명을 가리는 데 사용되는 안전하게 생성된 임의의 32비트 값입니다. 클라이언트 쪽 티켓 수명은 이 값 모듈로 2^32에 추가되어 클라이언트가 전송하는 값을 얻습니다. 서버는 전송하는 각 티켓에 대해 새로운 값을 생성해야 합니다.\(MUST\)

ticket\_nonce: 이 연결에서 발급된 모든 티켓에서 고유한 티켓당 값입니다.

티켓: PSK ID로 사용할 티켓의 값입니다. 티켓 자체는 불투명 라벨입니다. 데이터베이스 조회 키이거나 자체 암호화 및 자체 인증 값일 수 있습니다.\(MAY\)

확장: 티켓의 확장 값 집합입니다. "확장" 형식은 섹션 4.2에 정의되어 있습니다. 클라이언트는 인식할 수 없는 확장자를 무시해야 합니다.\(MUST\)

현재 NewSessionTicket에 대해 정의된 유일한 확장자는 티켓이 0-RTT 데이터를 전송하는 데 사용될 수 있음을 나타내는 "early\_data"입니다\(섹션 4.2.10\). 다음 값을 포함합니다.

max\_early\_data\_size: 이 티켓을 사용할 때 클라이언트가 보낼 수 있는 0-RTT 데이터의 최대 양\(바이트\)입니다. 애플리케이션 데이터 페이로드\(즉, 패딩이나 내부 콘텐츠 유형 바이트가 아닌 일반 텍스트\)만 계산됩니다. 0-RTT 데이터의 max\_early\_data\_size 바이트 이상을 수신하는 서버는 "unexpected\_message" 경고와 함께 연결을 종료해야 합니다. 암호화 자료가 부족하여 초기 데이터를 거부하는 서버는 패딩을 콘텐츠와 구별할 수 없으므로 클라이언트는 초기 데이터 레코드에서 대량의 패딩을 보낼 수 있는 능력에 의존해서는 안 됩니다.\(SHOULD, SHOULD NOT\)

티켓과 관련된 PSK는 다음과 같이 계산됩니다.

```text
       HKDF-Expand-Label(resumption_master_secret,
                        "resumption", ticket_nonce, Hash.length)
```

ticket\_nonce 값은 각 NewSessionTicket 메시지에 대해 고유하므로 티켓마다 다른 PSK가 파생됩니다.

원칙적으로 초기 비 PSK 핸드셰이크\(피어의 인증서에 연결되었을 가능성이 높음\)에서 원래 파생된 키 관련 자료의 수명을 무기한 연장하는 새 티켓을 계속 발행할 수 있습니다. 구현 시 이러한 키 자료의 총 수명에 제한을 두는 것이 권장됩니다. 이러한 제한은 피어 인증서의 수명, 중재 개입 가능성 및 피어의 온라인 CertificateVerify 서명 이후 시간을 고려해야 합니다.\(SHOULD\)

---
#### **4.6.2.  Post-Handshake Authentication**

클라이언트가 "post\_handshake\_auth" 확장\(섹션 4.2.6 참조\)을 보낸 경우 서버는 인증서 요청 메시지를 보내 핸드셰이크가 완료된 후 언제든지 클라이언트 인증을 요청할 수 있습니다. 클라이언트는 적절한 인증 메시지로 응답해야 합니다\(섹션 4.4 참조\). 클라이언트가 인증을 선택하면 Certificate, CertificateVerify,\(MAY, MUST, MUST\)

완료. 거부하는 경우 인증서가 포함되지 않은 인증서 메시지를 보내야 합니다\(MUST\). 주어진 응답에 대한 클라이언트의 모든 메시지는 다른 유형의 중간 메시지 없이 유선상에 연속적으로 나타나야 합니다.\(MUST, MUST\)

"post\_handshake\_auth" 확장을 전송하지 않고 CertificateRequest 메시지를 수신하는 클라이언트는 "unexpected\_message" 치명적 경고를 전송해야 합니다.\(MUST\)

참고: 클라이언트 인증에는 사용자 프롬프트가 포함될 수 있으므로 서버는 CertificateRequest 전송과 응답 수신 사이에 임의의 수의 다른 메시지 수신을 포함하여 약간의 지연에 대비해야 합니다. 또한 연속적으로 여러 CertificateRequest를 수신하는 클라이언트는 수신한 것과 다른 순서로 응답할 수 있습니다\(certificate\_request\_context 값을 사용하면 서버가 응답을 명확하게 할 수 있습니다\).\(MUST, MAY\)

---
#### **4.6.3.  Key and Initialization Vector Update**

KeyUpdate 핸드셰이크 메시지는 보낸 사람이 보내는 암호화 키를 업데이트하고 있음을 나타내는 데 사용됩니다. 이 메시지는 Finished 메시지를 보낸 후 피어에서 보낼 수 있습니다. Finished 메시지를 수신하기 전에 KeyUpdate 메시지를 수신하는 구현은 "unexpected\_message" 경고와 함께 연결을 종료해야 합니다. KeyUpdate 메시지를 보낸 후 발신자는 섹션 7.2에 설명된 대로 계산된 차세대 키를 사용하여 모든 트래픽을 보내야 합니다. KeyUpdate를 수신하면 수신자는 수신 키를 업데이트해야 합니다.\(MUST, MUST, MUST\)

```text
      enum {
          update_not_requested(0), update_requested(1), (255)
      } KeyUpdateRequest;

      struct {
          KeyUpdateRequest request_update;
      } KeyUpdate;
```

request\_update: KeyUpdate 수신자가 자체 KeyUpdate로 응답해야 하는지 여부를 나타냅니다. 구현이 다른 값을 받으면 "illegal\_parameter" 경고와 함께 연결을 종료해야 합니다.\(MUST\)

request\_update 필드가 "update\_requested"로 설정된 경우 수신자는 다음 애플리케이션 데이터 레코드를 보내기 전에 request\_update가 "update\_not\_requested"로 설정된 자체 KeyUpdate를 보내야 합니다. 이 메커니즘을 사용하면 어느 쪽이든 전체 연결에 대한 업데이트를 강제할 수 있지만 수신되는 구현이 발생합니다.\(MUST\)

단일 업데이트로 응답하기 위해 침묵하는 동안 여러 KeyUpdate. 구현은 request\_update가 "update\_requested"로 설정된 KeyUpdate 전송과 피어의 KeyUpdate 수신 사이에 임의의 수의 메시지를 수신할 수 있습니다. 이러한 메시지는 이미 전송 중일 수 있기 때문입니다. 그러나 송신 및 수신 키는 독립적인 트래픽 암호에서 파생되므로 수신 트래픽 암호를 유지해도 발신자가 키를 변경하기 전에 전송된 데이터의 순방향 보안이 위협받지 않습니다.

구현이 request\_update가 "update\_requested"로 설정된 자체 KeyUpdate를 독립적으로 전송하고 진행 중인 경우 각 측면도 응답을 보내며 그 결과 각 측면이 2세대씩 증가합니다.

발신자와 수신자 모두 이전 키로 KeyUpdate 메시지를 암호화해야 합니다. 또한 양측은 새 키로 암호화된 메시지를 수락하기 전에 이전 키가 있는 KeyUpdate가 수신되도록 해야 합니다\(MUST\). 그렇게 하지 않으면 메시지 잘림 공격이 허용될 수 있습니다.\(MUST, MUST\)

---
## **5.  Record Protocol**

TLS 레코드 프로토콜은 전송할 메시지를 가져오고, 데이터를 관리 가능한 블록으로 분할하고, 레코드를 보호하고, 결과를 전송합니다. 수신된 데이터는 확인, 해독, 재조립된 후 상위 클라이언트로 전달됩니다.

TLS 레코드가 입력되어 여러 상위 수준 프로토콜이 동일한 레코드 레이어에서 다중화될 수 있습니다. 이 문서는 handshake, application\_data, alert 및 change\_cipher\_spec의 네 가지 콘텐츠 유형을 지정합니다. change\_cipher\_spec 레코드는 호환성 목적으로만 사용됩니다\(부록 D.4 참조\).

구현은 첫 번째 ClientHello 메시지가 전송되거나 수신된 후 피어의 Finished 메시지가 수신되기 전에 언제든지 단일 바이트 값 0x01로 구성된 change\_cipher\_spec 유형의 암호화되지 않은 레코드를 수신할 수 있으며 추가 처리 없이 단순히 삭제해야 합니다. 이 레코드는 구현이 보호된 레코드를 예상하는 핸드셰이크 지점에 나타날 수 있으므로 레코드 보호 해제를 시도하기 전에 이 조건을 감지해야 합니다. 다른 change\_cipher\_spec 값을 수신하거나 보호된 change\_cipher\_spec 레코드를 수신하는 구현은 "unexpected\_message" 경고와 함께 핸드셰이크를 중단해야 합니다. 구현이 첫 번째 ClientHello 메시지 이전 또는 피어의 Finished 메시지 이후에 수신된 change\_cipher\_spec 레코드를 감지하는 경우 예상치 못한 레코드 유형으로 처리되어야 합니다\(상태 비저장 서버가 이러한 경우를 허용된 경우와 구분할 수 없을 수도 있음\).\(MUST, MUST, MUST\)

구현은 일부 확장에 의해 협상되지 않는 한 이 문서에 정의되지 않은 레코드 유형을 보내면 안 됩니다\(MUST NOT\). TLS 구현이 예기치 않은 레코드 유형을 수신하는 경우 "unexpected\_message" 경고와 함께 연결을 종료해야 합니다. 새 레코드 콘텐츠 유형 값은 섹션 11에 설명된 대로 TLS ContentType 레지스트리에서 IANA에 의해 할당됩니다.\(MUST NOT, MUST\)

---
### **5.1.  Record Layer**

레코드 레이어는 정보 블록을 2^14바이트 이하의 청크로 데이터를 전달하는 TLSPplaintext 레코드로 분할합니다. 메시지 경계는 기본 ContentType에 따라 다르게 처리됩니다. 향후 콘텐츠 유형은 적절한 규칙을 지정해야 합니다. 이러한 규칙은 TLS 1.2에서 시행된 것보다 더 엄격합니다.\(MUST\)

핸드셰이크 메시지는 다음과 같은 경우 단일 TLSPlaintext 레코드로 통합되거나 여러 레코드에 걸쳐 조각화될 수 있습니다\(MAY\).\(MAY\)

- 핸드셰이크 메시지는 다른 레코드 유형과 인터리브되어서는 안 됩니다. 즉, 핸드셰이크 메시지가 두 개 이상의 레코드로 분할된 경우 그 사이에 다른 레코드가 있어서는 안 됩니다.\(MUST NOT, MUST NOT\)

- 핸드셰이크 메시지는 키 변경을 포괄해서는 안 됩니다. 구현에서는 키 변경 직전의 모든 메시지가 레코드 경계와 일치하는지 확인해야 합니다. 그렇지 않은 경우 "unexpected\_message" 경고와 함께 연결을 종료해야 합니다. ClientHello, EndOfEarlyData, ServerHello, Finished 및 KeyUpdate 메시지는 키 변경 바로 앞에 올 수 있으므로 구현에서는 레코드 경계에 맞춰 이러한 메시지를 보내야 합니다.\(MUST NOT, MUST, MUST\)

구현은 해당 조각에 패딩이 포함되어 있더라도 길이가 0인 핸드셰이크 유형의 조각을 보내면 안 됩니다\(MUST NOT\).\(MUST NOT\)

경고 메시지\(섹션 6\)는 레코드 전체에서 조각화되어서는 안 되며 여러 경고 메시지가 단일 TLSPlaintext 레코드로 통합되어서는 안 됩니다. 즉, 경고 유형이 있는 레코드는 정확히 하나의 메시지를 포함해야 합니다.\(MUST NOT, MUST\)

애플리케이션 데이터 메시지에는 TLS에 불투명한 데이터가 포함되어 있습니다. 애플리케이션 데이터 메시지는 항상 보호됩니다. 응용 프로그램 데이터의 길이가 0인 조각은 잠재적으로 트래픽 분석 대책으로 유용하므로 보낼 수 있습니다. 응용 프로그램 데이터 조각은 여러 레코드로 분할되거나 단일 레코드로 병합될 수 있습니다\(MAY\).\(MAY, MAY\)

```text
      enum {
          invalid(0),
          change_cipher_spec(20),
          alert(21),
          handshake(22),
          application_data(23),
          (255)
      } ContentType;

      struct {
          ContentType type;
          ProtocolVersion legacy_record_version;
          uint16 length;
          opaque fragment[TLSPlaintext.length];
      } TLSPlaintext;
```

유형: 동봉된 조각을 처리하는 데 사용되는 상위 수준 프로토콜입니다.

legacy\_record\_version: 초기 ClientHello\(즉, HelloRetryRequest 이후에 생성되지 않은 레코드\) 이외의 TLS 1.3 구현에 의해 생성된 모든 레코드에 대해 0x0303으로 설정되어야 합니다. 여기서 호환성을 위해 0x0301일 수도 있습니다. 이 필드는 더 이상 사용되지 않으며 모든 목적을 위해 무시되어야 합니다. 이전 버전의 TLS는 경우에 따라 이 필드에 다른 값을 사용합니다.\(MUST, MUST\)

길이: 다음 TLSPlaintext.fragment의 길이\(바이트\)입니다. 길이는 2^14바이트를 초과하면 안 됩니다. 이 길이를 초과하는 레코드를 수신하는 끝점은 "record\_overflow" 경고와 함께 연결을 종료해야 합니다.\(MUST NOT, MUST\)

조각: 전송 중인 데이터입니다. 이 값은 투명하며 type 필드에 지정된 상위 수준 프로토콜에서 처리할 독립 블록으로 처리됩니다.

이 문서는 버전 0x0304를 사용하는 TLS 1.3에 대해 설명합니다. 이 버전 값은 TLS 1.0의 경우 0x0301을, SSL 3.0의 경우 0x0300을 사용하여 파생된 과거 값입니다. 이전 버전과의 호환성을 최대화하기 위해 초기 ClientHello가 포함된 레코드는 버전 0x0301\(TLS 1.0 반영\)이어야 하고 두 번째 ClientHello 또는 ServerHello가 포함된 레코드는 버전 0x0303\(TLS 1.2 반영\)이어야 합니다. 이전 버전의 TLS를 협상할 때 끝점은 부록 D에 제공된 절차 및 요구 사항을 따릅니다.\(MUST\)

레코드 보호가 아직 적용되지 않은 경우 TLSPlaintext 구조가 연결에 직접 기록됩니다. 레코드 보호가 시작되면 다음 섹션에 설명된 대로 TLSPlaintext 레코드가 보호되고 전송됩니다. 애플리케이션 데이터 레코드는 보호되지 않은 회선에 기록되어서는 안 됩니다\(자세한 내용은 섹션 2 참조\).\(MUST NOT\)

---
### **5.2.  Record Payload Protection**

레코드 보호 기능은 TLSPlaintext 구조를 TLSCiphertext 구조로 변환합니다. 보호 해제 기능은 프로세스를 반대로 합니다. TLS 1.3에서는 이전 버전의 TLS와 달리 모든 암호가 "AEAD\(Authenticated Encryption with Associated Data\)"\[RFC5116\]로 모델링됩니다. AEAD 기능은 일반 텍스트를 인증된 암호문으로 변환하고 다시 되돌리는 통합 암호화 및 인증 작업을 제공합니다. 각 암호화된 레코드는 일반 텍스트 헤더와 그 자체로 유형 및 선택적 패딩을 포함하는 암호화된 본문으로 구성됩니다.

```text
      struct {
          opaque content[TLSPlaintext.length];
          ContentType type;
          uint8 zeros[length_of_padding];
      } TLSInnerPlaintext;

      struct {
          ContentType opaque_type = application_data; /* 23 */
          ProtocolVersion legacy_record_version = 0x0303; /* TLS v1.2 */
          uint16 length;
          opaque encrypted_record[TLSCiphertext.length];
      } TLSCiphertext;
```

내용: 핸드셰이크 또는 경고 메시지의 바이트 인코딩 또는 보낼 응용 프로그램 데이터의 원시 바이트를 포함하는 TLSPlaintext.fragment 값입니다.

유형: 레코드의 콘텐츠 유형을 포함하는 TLSPlaintext.type 값입니다.

0: 값이 0인 바이트의 임의 길이 실행이 일반 텍스트에서 유형 필드 다음에 나타날 수 있습니다. 이렇게 하면 총계가 레코드 크기 제한 내에 있는 한 발신자가 선택한 양만큼 TLS 레코드를 채울 수 있는 기회가 제공됩니다. 자세한 내용은 섹션 5.4를 참조하십시오.

opaque\_type: TLS Ciphertext 레코드의 외부 opaque\_type 필드는 이전 버전의 TLS를 구문 분석하는 데 익숙한 미들박스와의 외부 호환성을 위해 항상 값 23\(application\_data\)으로 설정됩니다. 레코드의 실제 콘텐츠 유형은 암호 해독 후 TLSInnerPlaintext.type에서 찾을 수 있습니다.

legacy\_record\_version: legacy\_record\_version 필드는 항상 0x0303입니다. TLS 1.3 TLS Ciphertext는 TLS 1.3이 협상될 때까지 생성되지 않으므로 다른 값을 수신할 수 있는 과거 호환성 문제는 없습니다. ClientHello 및 ServerHello 메시지를 포함한 핸드셰이크 프로토콜은 프로토콜 버전을 인증하므로 이 값은 중복됩니다.

length: 다음 TLSCiphertext.encrypted\_record의 길이\(바이트\)는 콘텐츠 및 패딩 길이의 합계에 내부 콘텐츠 유형에 대한 1을 더하고 AAEAD 알고리즘에 의해 추가된 모든 확장을 더한 값입니다. 길이는 2^14 + 256바이트를 초과하면 안 됩니다. 이 길이를 초과하는 레코드를 수신하는 끝점은 "record\_overflow" 경고와 함께 연결을 종료해야 합니다.\(MUST NOT, MUST\)

encryption\_record: 직렬화된 TLSInnerPlaintext 구조의 AEAD 암호화 형식입니다.

AEAD 알고리즘은 \[RFC5116\]의 섹션 2.1에 설명된 대로 인증 확인에 포함할 단일 키, nonce, 일반 텍스트 및 "추가 데이터"를 입력으로 사용합니다. 키는 client\_write\_key 또는 server\_write\_key이고 nonce는 시퀀스 번호와 client\_write\_iv 또는 server\_write\_iv\(섹션 5.3 참조\)에서 파생되며 추가 데이터 입력은 레코드 헤더입니다.

```text
   I.e.,

      additional_data = TLSCiphertext.opaque_type ||
                        TLSCiphertext.legacy_record_version ||
                        TLSCiphertext.length
```

AEAD 알고리즘에 대한 일반 텍스트 입력은 인코딩된 TLSInnerPlaintext 구조입니다. 트래픽 키 파생은 섹션 7.3에 정의되어 있습니다.

AEAD 출력은 AEAD 암호화 작업의 암호문 출력으로 구성됩니다. 일반 텍스트의 길이는 TLSInnerPlaintext.type 및 보낸 사람이 제공한 패딩이 포함되어 해당 TLSPlaintext.length보다 큽니다. AEAD 출력의 길이는 일반적으로 일반 텍스트보다 크지만 AEAD 알고리즘에 따라 그 길이가 달라집니다.

암호에 패딩이 포함될 수 있으므로 오버헤드의 양은 일반 텍스트 길이에 따라 다를 수 있습니다. 상징적으로,

```text
      AEADEncrypted =
          AEAD-Encrypt(write_key, nonce, additional_data, plaintext)
```

TLSCiphertext의 encryption\_record 필드는 AEAADEncrypted로 설정됩니다.

암호 해독 및 확인을 위해 암호는 키, nonce, 추가 데이터 및 AEADEncrypted 값을 입력으로 사용합니다. 출력은 일반 텍스트이거나 암호 해독에 실패했음을 나타내는 오류입니다. 별도의 무결성 검사는 없습니다. 상징적으로,

```text
      plaintext of encrypted_record =
          AEAD-Decrypt(peer_write_key, nonce,
                       additional_data, AEADEncrypted)
```

복호화에 실패하면 수신자는 "bad\_record\_mac" 경고와 함께 연결을 종료해야 합니다.\(MUST\)

TLS 1.3에서 사용되는 AEAD 알고리즘은 255 옥텟보다 큰 확장을 생성하면 안 됩니다\(MUST NOT\). TLSCiphertext.length가 2^14 + 256 옥텟보다 큰 레코드를 피어로부터 수신하는 엔드포인트는 "record\_overflow" 경고와 함께 연결을 종료해야 합니다. 이 제한은 2^14 옥텟의 최대 TLSInnerPlaintext 길이 + ContentType에 대한 1 옥텟 + 255 옥텟의 최대 AEAD 확장에서 파생됩니다.\(MUST NOT, MUST\)

---
### **5.3.  Per-Record Nonce**

레코드 읽기 및 쓰기를 위해 64비트 시퀀스 번호가 별도로 유지됩니다. 적절한 시퀀스 번호는 각 레코드를 읽거나 쓴 후 1씩 증가합니다. 각 시퀀스 번호는 연결 시작 시와 키가 변경될 때마다 0으로 설정됩니다. 특정 트래픽 키로 전송되는 첫 번째 레코드는 시퀀스 번호 0을 사용해야 합니다.\(MUST\)

시퀀스 번호의 크기는 64비트이므로 래핑하면 안 됩니다. TLS 구현이 시퀀스 번호를 래핑해야 하는 경우 키를 다시 입력하거나\(섹션 4.6.3\) 연결을 종료해야 합니다.\(MUST\)

각 AEAD 알고리즘은 입력 \[RFC5116\]의 N\_MIN 바이트에서 N\_MAX 바이트까지 레코드당 nonce에 대해 가능한 길이 범위를 지정합니다. 레코드당 TLS 논스\(iv\_length\)의 길이는 AEAD 알고리즘에 대해 8바이트와 N\_MIN 중 더 큰 값으로 설정됩니다\(\[RFC5116\], 섹션 4 참조\). N\_MAX가 8바이트 미만인 AEAD 알고리즘은 TLS와 함께 사용하면 안 됩니다\(MUST NOT\). AEAD 구성에 대한 레코드당 nonce는 다음과 같이 구성됩니다.\(MUST NOT\)

1. 64비트 레코드 시퀀스 번호는 네트워크 바이트 순서로 인코딩되고 iv\_length까지 왼쪽이 0으로 채워집니다.

2. 채워진 시퀀스 번호는 역할에 따라 정적 client\_write\_iv 또는 server\_write\_iv와 XOR됩니다.

결과 수량\(길이 iv\_length\)은 레코드당 nonce로 사용됩니다.

참고: 이는 부분적으로 명시적인 nonce를 지정하는 TLS 1.2의 구성과 다릅니다.

---
### **5.4.  Record Padding**

모든 암호화된 TLS 레코드는 TLSCiphertext의 크기를 늘리기 위해 채워질 수 있습니다. 이를 통해 발신자는 관찰자로부터 트래픽 크기를 숨길 수 있습니다.

TLSCiphertext 레코드를 생성할 때 구현은 패딩을 선택할 수 있습니다\(MAY\). 패딩되지 않은 레코드는 패딩 길이가 0인 레코드입니다. 패딩은 암호화 전에 ContentType 필드에 추가되는 값이 0인 바이트 문자열입니다. 구현은 암호화하기 전에 패딩 옥텟을 모두 0으로 설정해야 합니다.\(MAY, MUST\)

보낸 사람이 원하는 경우 응용 프로그램 데이터 레코드에는 길이가 0인 TLSInnerPlaintext.content가 포함될 수 있습니다. 이를 통해 활동의 유무가 민감할 수 있는 상황에서 그럴듯한 크기의 커버 트래픽을 생성할 수 있습니다. 구현은 길이가 0인 TLSInnerPlaintext.content가 있는 핸드셰이크 및 경고 레코드를 보내면 안 됩니다\(MUST NOT\). 그러한 메시지가 수신되면 수신 구현은 "unexpected\_message" 경고와 함께 연결을 종료해야 합니다.\(MUST NOT\)

전송된 패딩은 레코드 보호 메커니즘에 의해 자동으로 확인됩니다. TLSCiphertext.encrypted\_record의 성공적인 암호 해독 시 수신 구현은 0이 아닌 옥텟을 찾을 때까지 끝에서 처음으로 필드를 스캔합니다. 이 0이 아닌 옥텟은 메시지의 콘텐츠 유형입니다. 이 패딩 체계는 새로운 콘텐츠 유형을 도입하지 않고도 암호화된 TLS 레코드를 임의의 크기\(0에서 TLS 레코드 크기 제한까지\)로 패딩할 수 있기 때문에 선택되었습니다. 이 디자인은 또한 모두 0인 패딩 옥텟을 적용하여 패딩 오류를 빠르게 감지할 수 있습니다.

구현은 AEAD 복호화에서 반환된 일반 텍스트로 검색을 제한해야 합니다\(MUST\). 수신 구현이 일반 텍스트에서 0이 아닌 옥텟을 찾지 못하면 "unexpected\_message" 경고와 함께 연결을 종료해야 합니다.\(MUST, MUST\)

패딩이 있어도 전체 레코드 크기 제한이 변경되지 않습니다. 전체 인코딩된 TLSInnerPlaintext는 2^14 + 1 옥텟을 초과하면 안 됩니다. 예를 들어 \[RFC8449\]의 record\_size\_limit 확장에 의해 최대 조각 길이가 줄어들면 콘텐츠 유형 및 패딩을 포함하여 전체 일반 텍스트에 감소된 제한이 적용됩니다.\(MUST NOT\)

패딩할 시기와 양을 제안하는 패딩 정책을 선택하는 것은 복잡한 주제이며 이 사양의 범위를 벗어납니다. TLS 위에 있는 애플리케이션 계층 프로토콜에 자체 패딩이 있는 경우 애플리케이션 계층 내에서 애플리케이션 데이터 TLS 레코드를 패딩하는 것이 더 나을 수 있습니다. 그러나 암호화된 핸드셰이크 또는 경고 레코드에 대한 패딩은 여전히 ​​TLS 계층에서 처리되어야 합니다. 이후 문서에서는 패딩 선택 알고리즘을 정의하거나 TLS 확장 또는 기타 수단을 통해 패딩 정책 요청 메커니즘을 정의할 수 있습니다.

---
### **5.5.  Limits on Key Usage**

주어진 키 세트로 안전하게 암호화할 수 있는 일반 텍스트의 양에는 암호화 제한이 있습니다. \[AEAD-LIMITS\]는 기본 프리미티브\(AES 또는 ChaCha20\)에 약점이 없다는 가정하에 이러한 한계에 대한 분석을 제공합니다. 구현은 이러한 제한에 도달하기 전에 섹션 4.6.3에 설명된 대로 주요 업데이트를 수행해야 합니다\(SHOULD\).\(SHOULD\)

AES-GCM의 경우 AE\(Authenticated Encryption\) 보안을 위해 약 2^-57의 안전 여유를 유지하면서 지정된 연결에서 최대 2^24.5개의 전체 크기 레코드\(약 2400만 개\)를 암호화할 수 있습니다. ChaCha20/Poly1305의 경우 안전 제한에 도달하기 전에 레코드 시퀀스 번호가 래핑됩니다.

---
## **6.  Alert Protocol**

TLS는 종료 정보 및 오류를 나타내는 경고 콘텐츠 유형을 제공합니다. 다른 메시지와 마찬가지로 경고 메시지는 현재 연결 상태에 지정된 대로 암호화됩니다.

경고 메시지는 이전 버전의 TLS에서 메시지의 심각도 수준을 전달했던 경고 및 레거시 필드에 대한 설명을 전달합니다. 경고는 종료 경고와 오류 경고의 두 가지 클래스로 나뉩니다. TLS 1.3에서 심각도는 전송되는 경고 유형에 내포되어 있으며 "수준" 필드는 무시해도 됩니다. "close\_notify" 경고는 연결의 한 방향이 순서대로 닫혔음을 나타내는 데 사용됩니다. 이러한 경고를 수신하면 TLS 구현은 애플리케이션에 데이터 끝을 표시해야 합니다\(SHOULD\).\(SHOULD\)

오류 경고는 연결 종료 중단을 나타냅니다\(섹션 6.2 참조\). 오류 경고를 수신하면 TLS 구현은 응용 프로그램에 오류를 표시해야 하며 연결에서 추가 데이터를 보내거나 받는 것을 허용해서는 안 됩니다\(MUST NOT\). 서버와 클라이언트는 가능한 경우 폐기해야 하는 세션 티켓과 관련된 PSK를 제외하고 실패한 연결에서 설정된 비밀 값과 키를 잊어버려야 합니다.\(MUST NOT, MUST\)

섹션 6.2에 나열된 모든 경고는 AlertLevel=fatal과 함께 전송되어야 하며 메시지의 AlertLevel에 관계없이 수신될 때 오류 경고로 처리되어야 합니다. 알 수 없는 경고 유형은 오류 경고로 처리되어야 합니다.\(MUST, MUST\)

참고: TLS는 메시지 구문 분석 실패 시 사용할 두 가지 일반 경고\(섹션 6 참조\)를 정의합니다. 구문에 따라 구문 분석할 수 없는 메시지를 수신하는 피어\(예: 메시지 경계를 초과하는 길이 또는 범위를 벗어난 길이 포함\)는 "decode\_error" 경고와 함께 연결을 종료해야 합니다. 구문적으로는 올바르지만 의미적으로는 유효하지 않은 메시지\(예: p - 1의 DHE 공유 또는 유효하지 않은 열거형\)를 수신하는 피어는 "illegal\_parameter" 경고와 함께 연결을 종료해야 합니다.\(MUST, MUST\)

```text
      enum { warning(1), fatal(2), (255) } AlertLevel;

      enum {
          close_notify(0),
          unexpected_message(10),
          bad_record_mac(20),
          record_overflow(22),
          handshake_failure(40),
          bad_certificate(42),
          unsupported_certificate(43),
          certificate_revoked(44),
          certificate_expired(45),
          certificate_unknown(46),
          illegal_parameter(47),
          unknown_ca(48),
          access_denied(49),
          decode_error(50),
          decrypt_error(51),
          protocol_version(70),
          insufficient_security(71),
          internal_error(80),
          inappropriate_fallback(86),
          user_canceled(90),
          missing_extension(109),
          unsupported_extension(110),
          unrecognized_name(112),
          bad_certificate_status_response(113),
          unknown_psk_identity(115),
          certificate_required(116),
          no_application_protocol(120),
          (255)
      } AlertDescription;

      struct {
          AlertLevel level;
          AlertDescription description;
      } Alert;
```

---
### **6.1.  Closure Alerts**

클라이언트와 서버는 잘림 공격을 피하기 위해 연결이 종료된다는 정보를 공유해야 합니다.

close\_notify: 이 경고는 발신자가 이 연결에서 더 이상 메시지를 보내지 않을 것임을 수신자에게 알립니다. 종료 경고가 수신된 후 수신된 모든 데이터는 무시해야 합니다\(MUST\).\(MUST\)

user\_canceled: 이 경고는 발신자가 프로토콜 오류와 관련 없는 어떤 이유로 핸드셰이크를 취소하고 있음을 수신자에게 알립니다. 핸드셰이크가 완료된 후 사용자가 작업을 취소하는 경우 "close\_notify"를 전송하여 연결을 닫는 것이 더 적절합니다. 이 경고 뒤에는 "close\_notify"가 와야 합니다\(SHOULD\). 이 경고는 일반적으로 AlertLevel=warning입니다.\(SHOULD\)

각 당사자는 "close\_notify" 경고를 전송하여 연결의 쓰기 쪽 닫기를 시작할 수 있습니다. 종료 경고가 수신된 후 수신된 모든 데이터는 무시해야 합니다\(MUST\). "close\_notify" 이전에 전송 수준 닫기가 수신되면 수신자는 전송된 모든 데이터가 수신되었음을 알 수 없습니다.\(MAY, MUST\)

각 당사자는 이미 일부 오류 경고를 보낸 경우가 아니면 연결의 쓰기 쪽을 닫기 전에 "close\_notify" 경고를 보내야 합니다. 이는 연결의 읽기 측에 영향을 미치지 않습니다. 이는 구현이 보류 중인 쓰기를 삭제하고 자체 "close\_notify" 경고를 즉시 전송하여 "close\_notify"에 반응해야 했던 TLS 1.3 이전 버전의 TLS에서 변경된 것입니다. 이전 요구 사항은 읽기 측에서 잘림을 유발할 수 있습니다. 두 당사자 모두 연결의 읽기 쪽을 닫기 전에 "close\_notify" 경고를 받을 때까지 기다릴 필요가 없습니다. 그렇게 하면 잘릴 가능성이 있습니다.\(MUST\)

TLS를 사용하는 응용 프로그램 프로토콜이 TLS 연결이 닫힌 후 기본 전송을 통해 데이터를 전달할 수 있다고 제공하는 경우 TLS 구현은 응용 프로그램 계층에 데이터 끝을 나타내기 전에 "close\_notify" 경고를 받아야 합니다. 이 표준의 어떤 부분도 연결이 열리거나 닫힐 때를 포함하여 TLS에 대한 사용 프로필이 데이터 전송을 관리하는 방식을 지시해서는 안 됩니다.\(MUST\)

참고: 연결의 쓰기 쪽을 닫으면 전송이 중단되기 전에 보류 중인 데이터가 안정적으로 전달된다고 가정합니다.

---
### **6.2.  Error Alerts**

TLS의 오류 처리는 매우 간단합니다. 오류가 감지되면 감지 당사자는 피어에게 메시지를 보냅니다. 치명적인 경고 메시지를 전송하거나 수신하는 즉시 양 당사자는 연결을 즉시 종료해야 합니다.\(MUST\)

구현이 치명적인 오류 조건을 만날 때마다 적절한 치명적인 경고를 보내고 추가 데이터를 보내거나 받지 않고 연결을 닫아야 합니다\(MUST\). 이 사양의 나머지 부분에서 특정 경고 없이 "연결 종료" 및 "취소 핸드셰이크"라는 문구가 사용되면 구현이 아래 설명에 표시된 경고를 보내야 함을 의미합니다. "X 경고로 연결 종료" 및 "X 경고로 핸드셰이크 중단"이라는 문구는 구현이 경고를 보내는 경우 경고 X를 보내야 함을 의미합니다. 이 섹션 아래에 정의된 모든 경고와 알 수 없는 모든 경고는 TLS 1.3 기준으로 보편적으로 치명적인 것으로 간주됩니다\(섹션 6 참조\). 구현은 경고의 송수신에 대한 로깅을 용이하게 하는 방법을 제공해야 합니다\(SHOULD\).\(MUST, SHOULD, MUST, SHOULD\)

다음 오류 경고가 정의됩니다.

expected\_message: 부적절한 메시지\(예: 잘못된 핸드셰이크 메시지, 조기 애플리케이션 데이터 등\)가 수신되었습니다. 이 경고는 적절한 구현 간의 통신에서 관찰되어서는 안 됩니다.

bad\_record\_mac: 보호 해제할 수 없는 레코드가 수신되면 이 경고가 반환됩니다. AEAD 알고리즘은 암호 해독과 확인을 결합하고 부채널 공격을 방지하기 때문에 이 경고는 모든 보호 해제 실패에 사용됩니다. 이 경고는 메시지가 네트워크에서 손상된 경우를 제외하고 적절한 구현 간의 통신에서 관찰되어서는 안 됩니다.

record\_overflow: 길이가 2^14 + 256바이트보다 긴 TLSCiphertext 레코드가 수신되었거나 2^14바이트\(또는 다른 협상된 제한\)보다 긴 TLSPlaintext 레코드로 해독된 레코드가 수신되었습니다. 이 경고는 메시지가 네트워크에서 손상된 경우를 제외하고 적절한 구현 간의 통신에서 관찰되어서는 안 됩니다.

handshake\_failure: "handshake\_failure" 경고 메시지의 수신은 발신자가 사용 가능한 옵션이 주어진 허용 가능한 보안 매개변수 집합을 협상할 수 없음을 나타냅니다.

bad\_certificate: 인증서가 손상되었거나 올바르게 확인되지 않은 서명이 포함되어 있습니다.

unsupported\_certificate: 인증서가 지원되지 않는 유형입니다.

certificate\_revoked: 서명자가 인증서를 취소했습니다.

certificate\_expired: 인증서가 만료되었거나 현재 유효하지 않습니다.

certificate\_unknown: 인증서를 처리하는 동안 다른\(지정되지 않은\) 문제가 발생하여 허용되지 않습니다.

Illegal\_parameter: 핸드셰이크의 필드가 잘못되었거나 다른 필드와 일치하지 않습니다. 이 경고는 공식 프로토콜 구문을 준수하지만 그 외에는 올바르지 않은 오류에 사용됩니다.

unknown\_ca: 유효한 인증서 체인 또는 부분 체인을 받았지만 CA 인증서를 찾을 수 없거나 알려진 트러스트 앵커와 일치시킬 수 없기 때문에 인증서가 수락되지 않았습니다.

access\_denied: 유효한 인증서 또는 PSK를 수신했지만 액세스 제어가 적용될 때 발신자가 협상을 진행하지 않기로 결정했습니다.

decode\_error: 일부 필드가 지정된 범위를 벗어났거나 메시지 길이가 잘못되어 메시지를 디코딩할 수 없습니다. 이 경고는 메시지가 공식 프로토콜 구문을 준수하지 않는 오류에 사용됩니다. 이 경고는 메시지가 네트워크에서 손상된 경우를 제외하고 적절한 구현 간의 통신에서 관찰되어서는 안 됩니다.

decrypt\_error: 핸드셰이크\(레코드 레이어가 아님\) 암호화 작업이 실패했습니다. 여기에는 서명을 올바르게 확인할 수 없거나 완료된 메시지 또는 PSK 바인더의 유효성을 검사할 수 없는 경우가 포함됩니다.

protocol\_version: 피어가 협상을 시도한 프로토콜 버전은 인식되지만 지원되지 않습니다\(부록 D 참조\).

불충분한\_보안: 특히 서버가 클라이언트가 지원하는 것보다 더 안전한 매개변수를 요구하기 때문에 협상이 실패한 경우 "handshake\_failure" 대신 반환됩니다.

internal\_error: 피어와 관련 없는 내부 오류 또는 프로토콜의 정확성\(예: 메모리 할당 실패\)으로 인해 계속할 수 없습니다.

부적절한\_폴백: 클라이언트의 잘못된 연결 재시도 시도에 대한 응답으로 서버에서 전송합니다\(\[RFC7507\] 참조\).

missing\_extension: 제공된 TLS 버전 또는 기타 협상된 매개변수에 대해 전송해야 하는 확장이 포함되지 않은 핸드셰이크 메시지를 수신하는 엔드포인트에서 전송합니다.

unsupported\_extension: 지정된 핸드셰이크 메시지에 포함하는 것이 금지된 것으로 알려진 확장을 포함하거나 해당 ClientHello 또는 CertificateRequest에서 처음 제공되지 않은 ServerHello 또는 인증서의 확장을 포함하는 모든 핸드셰이크 메시지를 수신하는 엔드포인트에서 전송합니다.

unrecognized\_name: "server\_name" 확장자를 통해 클라이언트가 제공한 이름으로 식별되는 서버가 없을 때 서버에서 전송합니다\(\[RFC6066\] 참조\).

bad\_certificate\_status\_response: 서버가 "status\_request" 확장을 통해 유효하지 않거나 허용할 수 없는 OCSP 응답을 제공할 때 클라이언트가 보냅니다\(\[RFC6066\] 참조\).

unknown\_psk\_identity: PSK 키 설정이 필요하지만 허용 가능한 PSK ID가 클라이언트에서 제공되지 않은 경우 서버에서 전송합니다. 이 경고를 보내는 것은 선택 사항입니다. 대신 서버는 단순히 잘못된 PSK ID를 나타내기 위해 "decrypt\_error" 경고를 보내도록 선택할 수 있습니다.\(MAY\)

certificate\_required: 클라이언트 인증서가 필요하지만 클라이언트에서 제공한 인증서가 없을 때 서버에서 보냅니다.

no\_application\_protocol: 클라이언트 "application\_layer\_protocol\_negotiation" 확장이 서버가 지원하지 않는 프로토콜만 알릴 때 서버에서 보냅니다\(\[RFC7301\] 참조\).

새 경고 값은 섹션 11에 설명된 대로 IANA에서 할당합니다.

---
## **7.  Cryptographic Computations**

TLS 핸드셰이크는 아래에 설명된 대로 실제 작업 키 자료를 생성하기 위해 결합되는 하나 이상의 입력 암호를 ​​설정합니다. 키 파생 프로세스는 입력 암호와 핸드셰이크 기록을 모두 통합합니다. 핸드셰이크 기록에는 Hello 메시지의 임의 값이 포함되기 때문에 동일한 PSK가 여러 연결에 사용되는 경우와 같이 동일한 입력 암호가 사용되더라도 주어진 핸드셰이크는 다른 트래픽 암호를 갖게 됩니다.

---
### **7.1.  Key Schedule**

키 파생 프로세스는 HKDF \[RFC5869\]에 대해 정의된 HKDF-Extract 및 HKDF-Expand 함수와 아래에 정의된 함수를 사용합니다.

```text
       HKDF-Expand-Label(Secret, Label, Context, Length) =
            HKDF-Expand(Secret, HkdfLabel, Length)
```

- HkdfLabel은 다음과 같이 지정됩니다.

```text
       struct {
           uint16 length = Length;
           opaque label<7..255> = "tls13 " + Label;
           opaque context<0..255> = Context;
       } HkdfLabel;

       Derive-Secret(Secret, Label, Messages) =
            HKDF-Expand-Label(Secret, Label,
                              Transcript-Hash(Messages), Hash.length)
```

Transcript-Hash 및 HKDF에서 사용하는 해시 함수는 암호 그룹 해시 알고리즘입니다. Hash.length는 출력 길이\(바이트\)입니다. 메시지는 핸드셰이크 메시지 유형 및 길이 필드를 포함하지만 레코드 레이어 헤더는 포함하지 않는 표시된 핸드셰이크 메시지의 연결입니다. 경우에 따라 길이가 0인 컨텍스트\(""로 표시됨\)가 HKDF-Expand-Label에 전달됩니다. 이 문서에 지정된 레이블은 모두 ASCII 문자열이며 후행 NUL 바이트를 포함하지 않습니다.

참고: 일반적인 해시 함수를 사용하면 12자보다 긴 레이블을 계산하려면 해시 함수를 추가로 반복해야 합니다. 이 사양의 레이블은 모두 이 제한에 맞게 선택되었습니다.

키는 HKDF-Extract 및 Derive-Secret 기능을 사용하여 두 개의 입력 암호에서 파생됩니다. 새 암호를 추가하는 일반적인 패턴은 현재 암호 상태인 Salt와 추가할 새 암호인 IKM\(Input Keying Material\)과 함께 HKDF-Extract를 사용하는 것입니다. 이 버전의 TLS 1.3에서 두 개의 입력 암호는 다음과 같습니다.

- PSK\(외부적으로 설정되거나 이전 연결의 resumption\_master\_secret 값에서 파생된 사전 공유 키\)

```text
   -  (EC)DHE shared secret (Section 7.4)
```

이렇게 하면 아래 다이어그램에 표시된 전체 키 파생 일정이 생성됩니다. 이 다이어그램에서는 다음 형식 지정 규칙이 적용됩니다.

- HKDF-Extract는 상단에서 Salt 인수를, 왼쪽에서 IKM 인수를 취하여 출력을 하단으로, 출력 이름을 오른쪽으로 가져오는 방식으로 그려집니다.

- Derive-Secret의 Secret 인수는 들어오는 화살표로 표시됩니다. 예를 들어 Early Secret은 client\_early\_traffic\_secret을 생성하기 위한 Secret입니다.

- "0"은 0으로 설정된 Hash.length 바이트의 문자열을 나타냅니다.

```text
             0
             |
             v
   PSK ->  HKDF-Extract = Early Secret
             |
             +-----> Derive-Secret(., "ext binder" | "res binder", "")
             |                     = binder_key
             |
             +-----> Derive-Secret(., "c e traffic", ClientHello)
             |                     = client_early_traffic_secret
             |
             +-----> Derive-Secret(., "e exp master", ClientHello)
             |                     = early_exporter_master_secret
             v
       Derive-Secret(., "derived", "")
             |
             v
   (EC)DHE -> HKDF-Extract = Handshake Secret
             |
             +-----> Derive-Secret(., "c hs traffic",
             |                     ClientHello...ServerHello)
             |                     = client_handshake_traffic_secret
             |
             +-----> Derive-Secret(., "s hs traffic",
             |                     ClientHello...ServerHello)
             |                     = server_handshake_traffic_secret
             v
       Derive-Secret(., "derived", "")
             |
             v
   0 -> HKDF-Extract = Master Secret
             |
             +-----> Derive-Secret(., "c ap traffic",
             |                     ClientHello...server Finished)
             |                     = client_application_traffic_secret_0
             |
             +-----> Derive-Secret(., "s ap traffic",
             |                     ClientHello...server Finished)
             |                     = server_application_traffic_secret_0
             |
             +-----> Derive-Secret(., "exp master",
             |                     ClientHello...server Finished)
             |                     = exporter_master_secret
             |
             +-----> Derive-Secret(., "res master",
                                   ClientHello...client Finished)
                                   = resumption_master_secret
```

여기서 일반적인 패턴은 다이어그램의 왼쪽 아래에 표시된 비밀은 컨텍스트가 없는 원시 엔트로피인 반면 오른쪽 아래의 비밀은 핸드셰이크 컨텍스트를 포함하므로 추가 컨텍스트 없이 작업 키를 파생하는 데 사용할 수 있다는 것입니다. Derive-Secret에 대한 다른 호출은 동일한 비밀을 사용하더라도 다른 메시지 인수를 사용할 수 있습니다. 0-RTT 교환에서 Derive-Secret은 4개의 개별 트랜스크립트와 함께 호출됩니다. 1-RTT 전용 교환에서는 3개의 개별 트랜스크립트로 호출됩니다.

주어진 비밀을 사용할 수 없는 경우 0으로 설정된 Hash.length 바이트 문자열로 구성된 0-값이 사용됩니다. 이는 라운드 건너뛰기를 의미하지 않으므로 PSK를 사용하지 않는 경우 초기 비밀은 여전히 ​​HKDF-Extract\(0, 0\)입니다. binder\_key 계산의 경우 레이블은 외부 PSK\(TLS 외부에서 프로비저닝된 것\)의 경우 "ext 바인더"이고 재개 PSK\(이전 핸드셰이크의 재개 마스터 비밀로 프로비저닝된 것\)의 경우 "res 바인더"입니다. 서로 다른 레이블은 한 유형의 PSK가 다른 유형으로 대체되는 것을 방지합니다.

서버가 최종적으로 선택하는 PSK에 따라 잠재적인 조기 비밀 값이 여러 개 있습니다. 클라이언트는 각 잠재적 PSK에 대해 하나씩 계산해야 합니다. PSK가 선택되지 않으면 0 PSK에 해당하는 Early Secret을 계산해야 합니다.

주어진 비밀에서 파생될 모든 값이 계산되면 해당 비밀을 지워야 합니다\(SHOULD\).\(SHOULD\)

---
### **7.2.  Updating Traffic Secrets**

핸드셰이크가 완료되면 어느 쪽이든 섹션 4.6.3에 정의된 KeyUpdate 핸드셰이크 메시지를 사용하여 전송 트래픽 키를 업데이트할 수 있습니다. 차세대 트래픽 키는 이 섹션에 설명된 대로 client\_/server\_application\_traffic\_secret\_N에서 client\_/server\_application\_traffic\_secret\_N+1을 생성한 다음 섹션 7.3에 설명된 대로 트래픽 키를 다시 파생시켜 계산됩니다.

차세대 application\_traffic\_secret은 다음과 같이 계산됩니다.

```text
       application_traffic_secret_N+1 =
           HKDF-Expand-Label(application_traffic_secret_N,
                             "traffic upd", "", Hash.length)
```

client\_/server\_application\_traffic\_secret\_N+1 및 관련 트래픽 키가 계산되면 구현은 client\_/server\_application\_traffic\_secret\_N 및 관련 트래픽 키를 삭제해야 합니다\(SHOULD\).\(SHOULD\)

---
### **7.3.  Traffic Key Calculation**

트래픽 키 자료는 다음 입력 값에서 생성됩니다.

- 비밀 값

- 생성되는 특정 가치를 나타내는 목적 값

- 생성되는 키의 길이

트래픽 키 자료는 다음을 사용하여 입력 트래픽 암호 값에서 생성됩니다.

```text
   [sender]_write_key = HKDF-Expand-Label(Secret, "key", "", key_length)
   [sender]_write_iv  = HKDF-Expand-Label(Secret, "iv", "", iv_length)
```

\[송신자\]는 송신측을 나타냅니다. 각 레코드 유형에 대한 Secret 값은 아래 표와 같습니다.

```text
       +-------------------+---------------------------------------+
       | Record Type       | Secret                                |
       +-------------------+---------------------------------------+
       | 0-RTT Application | client_early_traffic_secret           |
       |                   |                                       |
       | Handshake         | [sender]_handshake_traffic_secret     |
       |                   |                                       |
       | Application Data  | [sender]_application_traffic_secret_N |
       +-------------------+---------------------------------------+
```

모든 트래픽 키 자료는 기본 비밀이 변경될 때마다\(예: 핸드셰이크에서 애플리케이션 데이터 키로 변경하거나 키 업데이트 시\) 다시 계산됩니다.

---
### **7.4.  (EC)DHE Shared Secret Calculation**
---
#### **7.4.1.  Finite Field Diffie-Hellman**

유한 필드 그룹의 경우 기존의 Diffie-Hellman \[DH76\] 계산이 수행됩니다. 협상된 키\(Z\)는 big-endian 형식으로 인코딩하여 바이트 문자열로 변환하고 프라임 크기까지 0으로 왼쪽을 채웁니다. 이 바이트 문자열은 위에 지정된 대로 키 일정에서 공유 비밀로 사용됩니다.

이 구성은 선행 0을 제거한 이전 버전의 TLS와 다릅니다.

---
#### **7.4.2.  Elliptic Curve Diffie-Hellman**

secp256r1, secp384r1 및 secp521r1의 경우, ECDH 계산\(파라미터 및 키 생성 및 공유 비밀 계산 포함\)은 ID 맵을 키 유도 함수\(KDF\)로 사용하여 ECKAS-DH1 방식을 사용하여 \[IEEE1363\]에 따라 수행됩니다. 따라서 공유 비밀은 옥텟 문자열로 표시되는 ECDH 공유 비밀 타원 곡선 점의 x 좌표입니다. FE2OSP\(Field Element to Octet String Conversion Primitive\)에 의해 출력되는 이 옥텟 문자열\(IEEE 1363 용어의 "Z"\)은 주어진 필드에 대해 일정한 길이를 가집니다. 이 옥텟 문자열에서 발견된 선행 0은 절단되어서는 안 됩니다\(MUST NOT\).\(MUST NOT\)

\(ID KDF의 이러한 사용은 기술적인 문제입니다. 전체 그림은 TLS가 다른 비밀을 계산하는 것 외에는 이 비밀을 직접 사용하지 않기 때문에 중요한 KDF와 함께 ECDH를 사용한다는 것입니다.\)

X25519 및 X448의 경우 ECDH 계산은 다음과 같습니다.

- KeyShareEntry.key\_exchange 구조에 넣을 공개키는 적절한 길이의 비밀키\(스칼라 입력\)와 표준 공개 기준점\(u-좌표점 입력\)에 ECDH 스칼라 곱셈 함수를 적용한 결과입니다.

- ECDH 공유 비밀은 비밀 키\(스칼라 입력\)와 피어의 공개 키\(u 좌표점 입력\)에 ECDH 스칼라 곱셈 함수를 적용한 결과입니다. 출력은 처리 없이 원시로 사용됩니다.

이러한 곡선의 경우 구현 시 \[RFC7748\]에 지정된 접근 방식을 사용하여 Diffie-Hellman 공유 비밀을 계산해야 합니다\(SHOULD\). 구현은 \[RFC7748\]의 섹션 6에 설명된 대로 계산된 Diffie-Hellman 공유 비밀이 모두 0인지 여부를 확인하고 그렇다면 중단해야 합니다. 구현자가 이러한 타원 곡선의 대체 구현을 사용하는 경우 \[RFC7748\]의 섹션 7에 지정된 추가 검사를 수행해야 합니다\(SHOULD\).\(SHOULD, MUST, SHOULD\)

---
### **7.5.  Exporters**

\[RFC5705\]는 TLS PRF\(pseudorandom function\) 측면에서 TLS에 대한 키 자료 내보내기를 정의합니다. 이 문서는 PRF를 HKDF로 대체하므로 새로운 구성이 필요합니다. 내보내기 인터페이스는 동일하게 유지됩니다.

내보내기 값은 다음과 같이 계산됩니다.

```text
   TLS-Exporter(label, context_value, key_length) =
       HKDF-Expand-Label(Derive-Secret(Secret, label, ""),
                         "exporter", Hash(context_value), key_length)
```

여기서 Secret은 early\_exporter\_master\_secret 또는 exporter\_master\_secret입니다. 구현은 애플리케이션에서 명시적으로 지정하지 않는 한 exporter\_master\_secret을 사용해야 합니다. early\_exporter\_master\_secret은 0-RTT 데이터에 내보내기가 필요한 설정에서 사용하도록 정의됩니다. 초기 내보내기를 위한 별도의 인터페이스가 권장됩니다. 이렇게 하면 일반 내보내기가 필요할 때 또는 그 반대의 경우 내보내기 사용자가 실수로 초기 내보내기를 사용하는 것을 방지할 수 있습니다.\(MUST, SHOULD\)

컨텍스트가 제공되지 않으면 context\_value의 길이는 0입니다. 따라서 컨텍스트를 제공하지 않는 것은 빈 컨텍스트를 제공하는 것과 동일한 값을 계산합니다. 이는 비어 있는 컨텍스트가 없는 컨텍스트와 다른 출력을 생성하는 이전 버전의 TLS에서 변경된 것입니다. 이 문서의 출판 시점에서 할당된 수출자 레이블은 컨텍스트 유무에 관계없이 사용되지 않습니다. 향후 사양은 빈 컨텍스트와 동일한 레이블이 있는 컨텍스트 없음을 모두 허용하는 내보내기의 사용을 정의하면 안 됩니다\(MUST NOT\). 내보내기의 새로운 사용은 값이 비어 있을 수 있지만 모든 내보내기 계산에서 컨텍스트를 제공해야 합니다\(SHOULD\).\(MUST NOT, SHOULD\)

수출자 레이블의 형식에 대한 요구 사항은 \[RFC5705\]의 섹션 4에 정의되어 있습니다.

---
## **8.  0-RTT and Anti-Replay**

섹션 2.3 및 부록 E.5에서 언급한 바와 같이 TLS는 0-RTT 데이터에 고유한 재생 보호 기능을 제공하지 않습니다. 다음과 같은 두 가지 잠재적인 위협이 있습니다.

- 단순히 0-RTT 데이터의 비행을 복제하여 재생 공격을 수행하는 네트워크 공격자.

- 클라이언트 재시도 동작을 이용하여 서버가 응용 프로그램 메시지의 여러 복사본을 받도록 준비하는 네트워크 공격자. 견고성을 중시하는 클라이언트가 요청을 재시도하여 네트워크 오류에 응답하기 때문에 이 위협은 이미 어느 정도 존재합니다. 그러나 0-RTT는 전역적으로 일관된 서버 상태를 유지하지 않는 모든 서버 시스템에 추가적인 차원을 추가합니다. 특히 서버 시스템에 영역 A의 티켓이 영역 B에서 허용되지 않는 여러 영역이 있는 경우 공격자는 A와 B 모두에 ClientHello 및 초기 데이터를 복제할 수 있습니다. A에서 데이터는 다음에서 허용됩니다. 0-RTT, 그러나 B에서는 서버가 0-RTT 데이터를 거부하고 대신 전체 핸드셰이크를 강제합니다. 공격자가 A에서 ServerHello를 차단하면 클라이언트는 B와의 핸드셰이크를 완료하고 아마도 요청을 다시 시도하여 서버 시스템 전체에서 중복이 발생하게 됩니다.

첫 번째 유형의 공격은 0-RTT 데이터가 최대 한 번만 허용되도록 상태를 공유하여 방지할 수 있습니다. 서버는 이 섹션에 설명된 방법 중 하나 또는 동등한 수단을 구현하여 해당 수준의 재생 안전을 제공해야 합니다\(SHOULD\). 그러나 운영상의 문제로 인해 모든 배포가 해당 수준에서 상태를 유지하지는 않는다는 점을 이해합니다. 따라서 정상적인 작동에서 클라이언트는 서버가 실제로 구현하는 이러한 메커니즘 중 어떤 것이 있는지 알 수 없으므로 재생하기에 안전하다고 판단되는 초기 데이터만 보내야 합니다.\(SHOULD, MUST\)

리플레이의 직접적인 영향 외에도 일반적으로 멱등성으로 간주되는 작업조차도 많은 수의 리플레이\(부록 E.5에 설명된 대로 타이밍 공격, 리소스 제한 고갈 및 기타\)에 의해 악용될 수 있는 공격 클래스가 있습니다. 모든 0-RTT 페이로드가 제한된 횟수만 재생될 수 있도록 함으로써 이러한 문제를 완화할 수 있습니다. 서버는 인스턴스\(머신, 스레드 또는 관련 서빙 인프라 내의 다른 엔터티\)가 동일한 0-RTT 핸드셰이크에 대해 최대 한 번만 0-RTT를 수락하도록 해야 합니다. 이렇게 하면 재생 횟수가 배포의 서버 인스턴스 수로 제한됩니다. 이러한 보장은 최근에 받은 ClientHellos에서 로컬로 데이터를 기록하고 반복을 거부하거나 다른 방법으로 수행할 수 있습니다.\(MUST\)

동일하거나 더 강력한 보증을 제공합니다. "서버 인스턴스당 최대 한 번" 보장은 최소 요구 사항입니다. 서버는 가능한 경우 0-RTT 재생을 추가로 제한해야 합니다\(SHOULD\).\(SHOULD\)

두 번째 공격 클래스는 TLS 계층에서 방지할 수 없으며 모든 애플리케이션에서 처리해야 합니다. 클라이언트가 모든 종류의 재시도 동작을 구현하는 모든 응용 프로그램은 이미 일종의 재생 방지 방어를 구현해야 합니다.\(MUST\)

---
### **8.1.  Single-Use Tickets**

재생 방지 방어의 가장 간단한 형태는 서버가 각 세션 티켓을 한 번만 사용하도록 허용하는 것입니다. 예를 들어, 서버는 사용 중인 각 티켓을 데이터베이스에서 삭제하여 모든 유효 티켓의 데이터베이스를 유지 관리할 수 있습니다. 알 수 없는 티켓이 제공되면 서버는 전체 핸드셰이크로 돌아갑니다.

티켓이 자체 포함되지 않고 데이터베이스 키이고 해당 PSK가 사용 시 삭제되는 경우 PSK를 사용하여 설정된 연결은 순방향 보안을 즐깁니다. 이는 PSK가 \(EC\)DHE 없이 사용될 때 모든 0-RTT 데이터 및 PSK 사용에 대한 보안을 향상시킵니다.

이 메커니즘은 여러 분산 서버가 있는 환경에서 서버 노드 간에 세션 데이터베이스를 공유해야 하므로 자체 암호화 티켓과 비교할 때 높은 성공률의 PSK 0-RTT 연결을 달성하기 어려울 수 있습니다. 세션 데이터베이스와 달리 세션 티켓은 일관된 스토리지 없이도 PSK 기반 세션 설정을 성공적으로 수행할 수 있지만, 0-RTT가 허용되는 경우 다음 섹션에서 자세히 설명하는 것처럼 0-RTT 데이터의 재생 방지를 위해 여전히 일관된 스토리지가 필요합니다.

---
### **8.2.  Client Hello Recording**

재생 방지의 다른 형태는 ClientHello에서 파생된 고유한 값\(일반적으로 무작위 값 또는 PSK 바인더\)을 기록하고 중복을 거부하는 것입니다. 모든 ClientHellos를 기록하면 상태가 제한 없이 증가하지만 서버는 대신 지정된 시간 창 내에서 ClientHellos를 기록하고 "obfuscated\_ticket\_age"를 사용하여 티켓이 해당 창 밖에서 재사용되지 않도록 할 수 있습니다.

이를 구현하기 위해 ClientHello를 수신하면 서버는 먼저 4.2.11절에서 설명한 것처럼 PSK 바인더를 확인한다. 그런 다음 다음 섹션에 설명된 대로 expected\_arrival\_time을 계산하고 기록 창 밖에 있는 경우 0-RTT를 거부하고 1-RTT 핸드셰이크로 돌아갑니다.

expected\_arrival\_time이 창에 있으면 서버는 일치하는 ClientHello를 기록했는지 확인합니다. 하나가 발견되면 "illegal\_parameter" 경고와 함께 핸드셰이크를 중단하거나 PSK를 수락하지만 0-RTT를 거부합니다. 일치하는 ClientHello가 없으면 0-RTT를 수락한 다음 expected\_arrival\_time이 창 안에 있는 동안 ClientHello를 저장합니다. 서버는 또한 0-RTT를 거부하여 명백한 재생에 응답해야 하지만 핸드셰이크를 중단해서는 안 되는 블룸 필터와 같은 오탐으로 데이터 저장소를 구현할 수도 있습니다\(MUST NOT\).\(MUST NOT\)

서버는 ClientHello의 검증된 섹션에서만 저장소 키를 파생해야 합니다. ClientHello가 여러 PSK ID를 포함하는 경우 공격자는 서버가 이를 확인하지 않는다는 가정하에 선호도가 낮은 ID에 대해 서로 다른 바인더 값을 사용하여 여러 ClientHello를 생성할 수 있습니다\(섹션 4.2.11에서 권장하는 대로\). 즉, 클라이언트가 PSK A와 B를 보내지만 서버가 A를 선호하는 경우 공격자는 A에 대한 바인더에 영향을 주지 않고 B에 대한 바인더를 변경할 수 있습니다. B에 대한 바인더가 스토리지 키의 일부인 경우 이 ClientHello는 나타나지 않습니다. ClientHello가 허용되도록 하고 재생 캐시 오염과 같은 부작용을 일으킬 수 있지만 0-RTT 데이터는 다른 키를 사용하기 때문에 해독할 수 없습니다. 검증된 바인더 또는 ClientHello.random이 스토리지 키로 사용되는 경우 이 공격이 불가능합니다.\(MUST\)

이 메커니즘은 미결 티켓을 모두 저장할 필요가 없기 때문에 재개율이 높고 RTT가 0인 분산 시스템에서 구현하기가 더 쉬울 수 있습니다. ClientHello 메시지를 받았습니다. 그러한 많은 시스템에서 수신된 모든 ClientHello의 전역적으로 일관된 스토리지를 갖는 것은 비실용적입니다. 이 경우 단일 저장 영역이 주어진 티켓에 대해 권한을 갖고 다른 모든 영역에서 해당 티켓에 대해 0-RTT를 거부함으로써 최상의 재생 방지 보호가 제공됩니다. 이 접근 방식은 하나의 영역만 0-RTT 데이터를 수락하기 때문에 공격자가 단순하게 재생하는 것을 방지합니다. 약한 설계는 각 영역에 대해 별도의 스토리지를 구현하지만 모든 영역에서 0-RTT를 허용하는 것입니다. 이 접근 방식은 재생 횟수를 영역당 한 번으로 제한합니다. 물론 응용 프로그램 메시지 복제는 두 디자인 모두 가능합니다.

구현이 새로 시작되면 기록 창의 일부가 시작 시간과 겹치는 한 0-RTT를 거부해야 합니다\(SHOULD\). 그렇지 않으면 해당 기간 동안 원래 전송된 재생을 수락할 위험이 있습니다.\(SHOULD\)

참고: 클라이언트의 시계가 서버의 시계보다 훨씬 빠르게 실행되는 경우 미래에 창 밖에 있는 ClientHello가 수신될 수 있습니다. 이 경우 1-RTT에 대해 수락되어 클라이언트 재시도를 야기한 다음 나중에 수락될 수 있습니다. 0-RTT의 경우. 이것은 섹션 8에서 설명한 두 번째 공격 형태의 또 다른 변형입니다.

---
### **8.3.  Freshness Checks**

ClientHello는 클라이언트가 보낸 시간을 나타내기 때문에 ClientHello가 합리적으로 최근에 전송되었는지 여부를 효율적으로 판단하고 이러한 ClientHello에 대해 0-RTT만 수락하거나 그렇지 않으면 1-RTT 핸드셰이크로 되돌아갈 수 있습니다. 이는 8.2절에 설명된 ClientHello 저장 메커니즘에 필요합니다. 그렇지 않으면 서버가 ClientHellos를 무제한으로 저장해야 하기 때문입니다. 0-RTT.

이 메커니즘을 구현하기 위해 서버는 서버가 세션 티켓을 생성한 시간을 클라이언트와 서버 간의 예상 왕복 시간으로 오프셋하여 저장해야 합니다. 즉.,

```text
       adjusted_creation_time = creation_time + estimated_RTT
```

이 값은 티켓에 인코딩될 수 있으므로 각 미결 티켓의 상태를 유지할 필요가 없습니다. 서버는 클라이언트의 "pre\_shared\_key" 확장에 있는 "obfuscated\_ticket\_age" 매개변수에서 티켓의 "ticket\_age\_add" 값을 빼서 티켓의 나이에 대한 클라이언트 보기를 결정할 수 있습니다. 서버는 ClientHello의 expected\_arrival\_time을 다음과 같이 결정할 수 있습니다.

```text
     expected_arrival_time = adjusted_creation_time + clients_ticket_age
```

새로운 ClientHello가 수신되면 expected\_arrival\_time이 현재 서버 벽시계 시간과 비교되고 일정량 이상 차이가 나면 0-RTT가 거부되지만 1-RTT 핸드셰이크는 완료될 수 있습니다.

expected\_arrival\_time과 측정된 시간 사이의 불일치를 유발할 수 있는 몇 가지 잠재적인 오류 원인이 있습니다. 잠재적으로 절대 시간이 큰 값으로 인해 차이가 날 수 있지만 클라이언트 및 서버 클록 속도의 변동은 최소화될 수 있습니다. 네트워크 전파 지연은 경과 시간에 대한 정당한 값의 불일치의 가장 큰 원인입니다. NewSessionTicket 및 ClientHello 메시지는 모두 재전송되어 지연될 수 있으며 이는 TCP에 의해 숨겨질 수 있습니다. 인터넷 클라이언트의 경우 이는 시계의 오류와 측정값의 변화를 설명하기 위해 10초 정도의 창을 의미합니다. 다른 배포 시나리오에는 다른 요구 사항이 있을 수 있습니다. 클록 왜곡 분포는 대칭이 아니므로 최적의 트레이드 오프에는 허용 가능한 불일치 값의 비대칭 범위가 포함될 수 있습니다.

대역폭 및 시스템 용량에 따라 실제 설정에서 수십억 개의 재생을 포함할 수 있는 오류 기간 동안 감지하지 못하기 때문에 신선도 검사만으로는 재생을 방지하기에 충분하지 않습니다. 또한 이 신선도 검사는 ClientHello가 수신될 때만 수행되며 후속 초기 애플리케이션 데이터 레코드가 수신될 때는 수행되지 않습니다. 초기 데이터가 승인된 후 더 오랜 기간 동안 레코드가 서버로 계속 스트리밍될 수 있습니다.

---
## **9.  Compliance Requirements**
---
### **9.1.  Mandatory-to-Implement Cipher Suites**

달리 지정하는 응용 프로그램 프로필 표준이 없는 경우:

TLS 호환 애플리케이션은 TLS\_AES\_128\_GCM\_SHA256\[GCM\] 암호군을 구현해야 하며 TLS\_AES\_256\_GCM\_SHA384\[GCM\] 및 TLS\_CHACHA20\_POLY1305\_SHA256\[RFC8439\] 암호군을 구현해야 합니다\(부록 B.4 참조\).\(MUST\)

TLS 호환 애플리케이션은 rsa\_pkcs1\_sha256\(인증서용\), rsa\_pss\_rsae\_sha256\(CertificateVerify 및 인증서용\) 및 ecdsa\_secp256r1\_sha256을 사용하여 디지털 서명을 지원해야 합니다\(MUST\). TLS 호환 애플리케이션은 secp256r1\(NIST P-256\)과의 키 교환을 지원해야 하며 X25519\[RFC7748\]와의 키 교환을 지원해야 합니다\(SHOULD\).\(MUST, MUST\)

---
### **9.2.  Mandatory-to-Implement Extensions**

달리 지정하는 애플리케이션 프로필 표준이 없는 경우 TLS 호환 애플리케이션은 다음 TLS 확장을 구현해야 합니다.\(MUST\)

```text
   -  Supported Versions ("supported_versions"; Section 4.2.1)

   -  Cookie ("cookie"; Section 4.2.2)

   -  Signature Algorithms ("signature_algorithms"; Section 4.2.3)

   -  Signature Algorithms Certificate ("signature_algorithms_cert";
      Section 4.2.3)

   -  Negotiated Groups ("supported_groups"; Section 4.2.7)

   -  Key Share ("key_share"; Section 4.2.8)
```

- 서버 이름 표시\("server\_name"; \[RFC6066\]의 섹션 3\)

모든 구현은 적용 가능한 기능을 제공할 때 이러한 확장을 전송하고 사용해야 합니다.\(MUST\)

- 모든 ClientHello, ServerHello 및 HelloRetryRequest 메시지에 대해 "supported\_versions"가 필수입니다.\(MUST\)

- 인증서 인증을 위해서는 "signature\_algorithms"가 필수입니다.\(MUST\)

- DHE 또는 ECDHE 키 교환을 사용하는 ClientHello 메시지에는 "supported\_groups"가 필수입니다.\(MUST\)

- DHE 또는 ECDHE 키 교환에는 "key\_share"가 필요합니다.\(MUST\)

- PSK 키 계약에는 "pre\_shared\_key"가 필수입니다.\(MUST\)

- PSK 키 계약에는 "psk\_key\_exchange\_modes"가 필수입니다.\(MUST\)

ClientHello가 본문에 0x0304가 포함된 "supported\_versions" 확장을 포함하는 경우 클라이언트는 이 사양을 사용하여 협상을 시도하는 것으로 간주됩니다. 이러한 ClientHello 메시지는 다음 요구 사항을 충족해야 합니다.\(MUST\)

- "pre\_shared\_key" 확장을 포함하지 않는 경우 "signature\_algorithms" 확장과 "supported\_groups" 확장을 모두 포함해야 합니다.\(MUST\)

- "supported\_groups" 확장을 포함하는 경우 "key\_share" 확장도 포함해야 하며 그 반대의 경우도 마찬가지입니다. 빈 KeyShare.client\_shares 벡터가 허용됩니다.\(MUST\)

이러한 요구 사항을 준수하지 않는 ClientHello를 수신하는 서버는 "missing\_extension" 경고와 함께 핸드셰이크를 중단해야 합니다.\(MUST\)

또한 모든 구현은 이를 사용할 수 있는 애플리케이션과 함께 "server\_name" 확장의 사용을 지원해야 합니다\(MUST\). 서버는 클라이언트가 유효한 "server\_name" 확장자를 보내도록 요구할 수 있습니다\(MAY\). 이 확장이 필요한 서버는 "missing\_extension" 경고로 연결을 종료하여 "server\_name" 확장이 없는 ClientHello에 응답해야 합니다\(SHOULD\).\(MUST, MAY, SHOULD\)

---
### **9.3.  Protocol Invariants**

이 섹션에서는 TLS 엔드포인트와 미들박스가 반드시 따라야 하는 불변성을 설명합니다. 이전 버전의 TLS에도 적용됩니다.\(MUST\)

TLS는 안전하고 호환 가능하도록 설계되었습니다. 새로운 클라이언트 또는 서버는 새로운 피어와 통신할 때 가장 선호하는 공통 매개변수를 협상해야 합니다. TLS 핸드셰이크는 다운그레이드 보호를 제공합니다. TLS를 종료하지 않고 최신 클라이언트와 최신 서버 간에 트래픽을 전달하는 미들박스는 핸드셰이크에 영향을 줄 수 없습니다\(부록 E.1 참조\). 동시에 배포는 서로 다른 속도로 업데이트되므로 최신 클라이언트 또는 서버는 이전 매개 변수를 계속 지원할 수 있으므로 이전 엔드포인트와 상호 운용할 수 있습니다.\(MAY\)

이것이 작동하려면 구현이 확장 가능한 필드를 올바르게 처리해야 합니다.\(MUST\)

- ClientHello를 보내는 클라이언트는 여기에 광고된 모든 매개변수를 지원해야 합니다. 그렇지 않으면 해당 매개변수 중 하나를 선택하여 서버가 상호 운용되지 않을 수 있습니다.\(MUST\)

- ClientHello를 수신하는 서버는 인식할 수 없는 모든 암호화 제품군, 확장 및 기타 매개변수를 올바르게 무시해야 합니다. 그렇지 않으면 최신 클라이언트와 상호 운용되지 않을 수 있습니다. TLS 1.3에서 CertificateRequest 또는 NewSessionTicket을 수신하는 클라이언트는 인식할 수 없는 모든 확장도 무시해야 합니다.\(MUST, MUST\)

- TLS 연결을 종료하는 미들박스는 클라이언트가 기꺼이 수락할 인증서를 갖는 것을 포함하여 \(원래 클라이언트에 대해\) 호환 TLS 서버로 작동해야 하며, 확인을 포함하여 \(원래 서버에 대해\) 호환 TLS 클라이언트로도 작동해야 합니다. 원본 서버의 인증서. 특히, 이해하는 매개변수만 포함하는 자체 ClientHello를 생성해야 하며, 엔드포인트의 값을 전달하는 대신 새로운 ServerHello 임의 값을 생성해야 합니다.\(MUST, MUST\)

- TLS의 프로토콜 요구 사항 및 보안 분석은 두 연결에만 별도로 적용됩니다. TLS 종결자를 안전하게 배포하려면 이 문서의 범위를 벗어나는 추가 보안 고려 사항이 필요합니다.

- 이해하지 못하는 ClientHello 매개변수를 전달하는 미들박스는 해당 ClientHello 이외의 메시지를 처리해서는 안 됩니다. 모든 후속 트래픽을 수정되지 않은 상태로 전달해야 합니다. 그렇지 않으면 최신 클라이언트 및 서버와 상호 운용되지 않을 수 있습니다.\(MUST NOT, MUST\)

- 전달된 ClientHellos에는 미들박스에서 지원하지 않는 기능에 대한 광고가 포함될 수 있으므로 응답에는 미들박스가 인식하지 못하는 향후 TLS 추가 사항이 포함될 수 있습니다. 이러한 추가 사항은 ClientHello 이외의 메시지를 임의로 변경할 수 있습니다. 특히, ServerHello에서 전송된 값이 변경될 수 있고, ServerHello 형식이 변경될 수 있으며, TLSCiphertext 형식이 변경될 수 있습니다.\(MAY\)

TLS 1.3의 설계는 널리 배포된 비준수 TLS 미들박스에 의해 제약을 받았습니다\(부록 D.4 참조\). 그러나 불변량을 완화하지는 않습니다. 이러한 미들박스는 계속해서 비준수 상태입니다.

---
## **10.  Security Considerations**

보안 문제는 이 메모 전체, 특히 부록 C, D 및 E에서 논의됩니다.

---
## **11.  IANA Considerations**

이 문서는 원래 \[RFC4346\]에서 생성되고 \[RFC8447\]에서 업데이트된 여러 레지스트리를 사용합니다. IANA는 이 문서를 참조하도록 업데이트했습니다. 레지스트리 및 해당 할당 정책은 다음과 같습니다.

- TLS Cipher Suites 레지스트리: 0-254\(십진수\) 범위의 첫 번째 바이트 값은 사양 필수 \[RFC8126\]를 통해 할당됩니다. 첫 번째 바이트 255\(10진수\)의 값은 개인용으로 예약되어 있습니다\[RFC8126\].

- IANA는 부록 B.4에 나열된 암호 제품군을 레지스트리에 추가했습니다. "값" 및 "설명" 열은 표에서 가져옵니다. 각각의 새로운 암호화 제품군에 대해 "DTLS-OK" 및 "권장" 열은 모두 "Y"로 표시됩니다.

- TLS ContentType 레지스트리: 표준 조치 \[RFC8126\]를 통해 미래 값이 할당됩니다.

- TLS 경고 레지스트리: 표준 조치 \[RFC8126\]를 통해 미래 값이 할당됩니다. IANA는 이 레지스트리를 부록 B.2의 값으로 채웠습니다. 이러한 모든 값에 대해 "DTLS-OK" 열은 "Y"로 표시됩니다. "\_RESERVED"로 표시된 값에는 이전 사용법을 설명하는 설명이 있습니다.

- TLS HandshakeType 레지스트리: 표준 작업 \[RFC8126\]을 통해 미래 값이 할당됩니다. IANA는 이 레지스트리를 업데이트하여 항목 4의 이름을 "NewSessionTicket"에서 "new\_session\_ticket"으로 바꾸고 이 레지스트리를 부록 B.3의 값으로 채웠습니다. 이러한 모든 값에 대해 "DTLS-OK" 열은 "Y"로 표시됩니다. "\_RESERVED"로 표시된 값에는 이전 또는 임시 사용법을 설명하는 설명이 있습니다.

이 문서는 원래 \[RFC4366\]에서 생성된 TLS ExtensionType 값 레지스트리도 사용합니다. IANA는 이 문서를 참조하도록 업데이트했습니다. 레지스트리 변경 사항은 다음과 같습니다.

- IANA는 등록 정책을 다음과 같이 업데이트했습니다.

- 0-254\(십진수\) 범위의 첫 번째 바이트 값은 사양 필수 \[RFC8126\]을 통해 할당됩니다. 첫 번째 바이트 255\(10진수\)의 값은 개인용으로 예약되어 있습니다\[RFC8126\].

- IANA는 "key\_share", "pre\_shared\_key", "psk\_key\_exchange\_modes", "early\_data", "cookie", "supported\_versions", "certificate\_authorities", "oid\_filters", "post\_handshake\_auth" 및 "signature\_algorithms\_cert" 확장을 포함하도록 이 레지스트리를 업데이트했습니다. 이 문서에 정의된 값과 "권장" 값 "Y"를 사용합니다.

- IANA는 확장이 나타날 수 있는 메시지를 나열하는 "TLS 1.3" 열을 포함하도록 이 레지스트리를 업데이트했습니다. 이 열은 처음에 섹션 4.2의 표에서 채워졌으며, 여기에 나열되지 않은 확장자는 TLS 1.3에서 사용되지 않음을 나타내기 위해 "-"로 표시되었습니다.

이 문서는 원래 \[RFC6091\]에서 생성되고 \[RFC8447\]에서 업데이트된 TLS 인증서 유형 레지스트리의 항목을 업데이트합니다. IANA는 값 1에 대한 항목을 업데이트하여 이름이 "OpenPGP\_RESERVED", "권장" 값 "N" 및 "1.3 이전 TLS 버전에서 사용됨"이라는 설명을 갖습니다.

이 문서는 원래 \[RFC6961\]에서 생성된 TLS 인증서 상태 유형 레지스트리의 항목을 업데이트합니다. IANA는 값 2에 대한 항목을 업데이트하여 "ocsp\_multi\_RESERVED"라는 이름과 "1.3 이전 TLS 버전에서 사용됨"이라는 설명을 추가했습니다.

이 문서는 TLS 지원 그룹 레지스트리\(\[RFC4492\]에 의해 다른 이름으로 생성되고 현재 \[RFC8422\]에 의해 유지 관리됨\)의 두 항목을 업데이트하고 \[RFC7919\] 및 \[RFC8447\]에 의해 업데이트됩니다. 값 29 및 30\(x25519 및 x448\)에 대한 항목도 이 문서를 참조하도록 업데이트되었습니다.

또한 이 문서는 IANA에서 유지 관리하는 두 가지 새로운 레지스트리를 정의합니다.

- TLS SignatureScheme 레지스트리: 0-253\(십진수\) 범위의 첫 번째 바이트 값은 사양 필수 \[RFC8126\]을 통해 할당됩니다. 첫 번째 바이트가 254 또는 255\(10진수\)인 값은 개인용으로 예약되어 있습니다\[RFC8126\]. 현재 할당되지 않은 0-6 범위의 첫 번째 바이트 또는 0-3 범위의 두 번째 바이트가 있는 값은 이전 버전과의 호환성을 위해 예약되어 있습니다. 이 레지스트리에는 "권장" 열이 있습니다. 레지스트리는 처음에 섹션 4.2.3에 설명된 값으로 채워졌습니다. 다음 값은 "권장"으로 표시됩니다: ecdsa\_secp256r1\_sha256, ecdsa\_secp384r1\_sha384, rsa\_pss\_rsae\_sha256, rsa\_pss\_rsae\_sha384, rsa\_pss\_rsae\_sha512, rsa\_pss\_pss\_sha256, rsa\_pss\_pss\_sha384, rsa\_pss \_pss\_sha512 및 ed25519. 명시적으로 요청하지 않는 한 "권장" 열에는 "N" 값이 할당되며 "권장" 값 "Y"가 있는 값을 추가하려면 표준 조치 \[RFC8126\]가 필요합니다. Y-\>N 전환에는 IESG 승인이 필요합니다.\(MUST\)

- TLS PskKeyExchangeMode 레지스트리: 0-253\(십진수\) 범위의 값은 사양 필수 \[RFC8126\]를 통해 할당됩니다. 값 254 및 255\(10진수\)는 개인용으로 예약되어 있습니다\[RFC8126\]. 이 레지스트리에는 "권장" 열이 있습니다. 레지스트리는 처음에 psk\_ke\(0\) 및 psk\_dhe\_ke\(1\)로 채워졌습니다. 둘 다 "권장"으로 표시되어 있습니다. 명시적으로 요청하지 않는 한 "권장" 열에는 "N" 값이 할당되며 "권장" 값 "Y"가 있는 값을 추가하려면 표준 조치 \[RFC8126\]가 필요합니다. Y-\>N 전환에는 IESG 승인이 필요합니다.\(MUST\)

---
## **12.  References**
---
### **12.1.  Normative References**

```text
   [DH76]     Diffie, W. and M. Hellman, "New directions in
              cryptography", IEEE Transactions on Information
              Theory, Vol. 22 No. 6, pp. 644-654,
              DOI 10.1109/TIT.1976.1055638, November 1976.

   [ECDSA]    American National Standards Institute, "Public Key
              Cryptography for the Financial Services Industry: The
              Elliptic Curve Digital Signature Algorithm (ECDSA)",
              ANSI ANS X9.62-2005, November 2005.

   [GCM]      Dworkin, M., "Recommendation for Block Cipher Modes of
              Operation: Galois/Counter Mode (GCM) and GMAC",
              NIST Special Publication 800-38D,
              DOI 10.6028/NIST.SP.800-38D, November 2007.

   [RFC2104]  Krawczyk, H., Bellare, M., and R. Canetti, "HMAC: Keyed-
              Hashing for Message Authentication", RFC 2104,
              DOI 10.17487/RFC2104, February 1997,
              <https://www.rfc-editor.org/info/rfc2104>.

   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", BCP 14, RFC 2119,
              DOI 10.17487/RFC2119, March 1997,
              <https://www.rfc-editor.org/info/rfc2119>.

   [RFC5116]  McGrew, D., "An Interface and Algorithms for Authenticated
              Encryption", RFC 5116, DOI 10.17487/RFC5116, January 2008,
              <https://www.rfc-editor.org/info/rfc5116>.

   [RFC5280]  Cooper, D., Santesson, S., Farrell, S., Boeyen, S.,
              Housley, R., and W. Polk, "Internet X.509 Public Key
              Infrastructure Certificate and Certificate Revocation List
              (CRL) Profile", RFC 5280, DOI 10.17487/RFC5280, May 2008,
              <https://www.rfc-editor.org/info/rfc5280>.

   [RFC5705]  Rescorla, E., "Keying Material Exporters for Transport
              Layer Security (TLS)", RFC 5705, DOI 10.17487/RFC5705,
              March 2010, <https://www.rfc-editor.org/info/rfc5705>.

   [RFC5756]  Turner, S., Brown, D., Yiu, K., Housley, R., and T. Polk,
              "Updates for RSAES-OAEP and RSASSA-PSS Algorithm
              Parameters", RFC 5756, DOI 10.17487/RFC5756, January 2010,
              <https://www.rfc-editor.org/info/rfc5756>.

   [RFC5869]  Krawczyk, H. and P. Eronen, "HMAC-based Extract-and-Expand
              Key Derivation Function (HKDF)", RFC 5869,
              DOI 10.17487/RFC5869, May 2010,
              <https://www.rfc-editor.org/info/rfc5869>.

   [RFC6066]  Eastlake 3rd, D., "Transport Layer Security (TLS)
              Extensions: Extension Definitions", RFC 6066,
              DOI 10.17487/RFC6066, January 2011,
              <https://www.rfc-editor.org/info/rfc6066>.

   [RFC6655]  McGrew, D. and D. Bailey, "AES-CCM Cipher Suites for
              Transport Layer Security (TLS)", RFC 6655,
              DOI 10.17487/RFC6655, July 2012,
              <https://www.rfc-editor.org/info/rfc6655>.

   [RFC6960]  Santesson, S., Myers, M., Ankney, R., Malpani, A.,
              Galperin, S., and C. Adams, "X.509 Internet Public Key
              Infrastructure Online Certificate Status Protocol - OCSP",
              RFC 6960, DOI 10.17487/RFC6960, June 2013,
              <https://www.rfc-editor.org/info/rfc6960>.

   [RFC6961]  Pettersen, Y., "The Transport Layer Security (TLS)
              Multiple Certificate Status Request Extension", RFC 6961,
              DOI 10.17487/RFC6961, June 2013,
              <https://www.rfc-editor.org/info/rfc6961>.

   [RFC6962]  Laurie, B., Langley, A., and E. Kasper, "Certificate
              Transparency", RFC 6962, DOI 10.17487/RFC6962, June 2013,
              <https://www.rfc-editor.org/info/rfc6962>.

   [RFC6979]  Pornin, T., "Deterministic Usage of the Digital Signature
              Algorithm (DSA) and Elliptic Curve Digital Signature
              Algorithm (ECDSA)", RFC 6979, DOI 10.17487/RFC6979,
              August 2013, <https://www.rfc-editor.org/info/rfc6979>.

   [RFC7301]  Friedl, S., Popov, A., Langley, A., and E. Stephan,
              "Transport Layer Security (TLS) Application-Layer Protocol
              Negotiation Extension", RFC 7301, DOI 10.17487/RFC7301,
              July 2014, <https://www.rfc-editor.org/info/rfc7301>.

   [RFC7507]  Moeller, B. and A. Langley, "TLS Fallback Signaling Cipher
              Suite Value (SCSV) for Preventing Protocol Downgrade
              Attacks", RFC 7507, DOI 10.17487/RFC7507, April 2015,
              <https://www.rfc-editor.org/info/rfc7507>.

   [RFC7748]  Langley, A., Hamburg, M., and S. Turner, "Elliptic Curves
              for Security", RFC 7748, DOI 10.17487/RFC7748,
              January 2016, <https://www.rfc-editor.org/info/rfc7748>.

   [RFC7919]  Gillmor, D., "Negotiated Finite Field Diffie-Hellman
              Ephemeral Parameters for Transport Layer Security (TLS)",
              RFC 7919, DOI 10.17487/RFC7919, August 2016,
              <https://www.rfc-editor.org/info/rfc7919>.

   [RFC8017]  Moriarty, K., Ed., Kaliski, B., Jonsson, J., and A. Rusch,
              "PKCS #1: RSA Cryptography Specifications Version 2.2",
              RFC 8017, DOI 10.17487/RFC8017, November 2016,
              <https://www.rfc-editor.org/info/rfc8017>.

   [RFC8032]  Josefsson, S. and I. Liusvaara, "Edwards-Curve Digital
              Signature Algorithm (EdDSA)", RFC 8032,
              DOI 10.17487/RFC8032, January 2017,
              <https://www.rfc-editor.org/info/rfc8032>.

   [RFC8126]  Cotton, M., Leiba, B., and T. Narten, "Guidelines for
              Writing an IANA Considerations Section in RFCs", BCP 26,
              RFC 8126, DOI 10.17487/RFC8126, June 2017,
              <https://www.rfc-editor.org/info/rfc8126>.

   [RFC8174]  Leiba, B., "Ambiguity of Uppercase vs Lowercase in
              RFC 2119 Key Words", BCP 14, RFC 8174,
              DOI 10.17487/RFC8174, May 2017,
              <https://www.rfc-editor.org/info/rfc8174>.

   [RFC8439]  Nir, Y. and A. Langley, "ChaCha20 and Poly1305 for IETF
              Protocols", RFC 8439, DOI 10.17487/RFC8439, June 2018,
              <https://www.rfc-editor.org/info/rfc8439>.

   [SHS]      Dang, Q., "Secure Hash Standard (SHS)", National Institute
              of Standards and Technology report,
              DOI 10.6028/NIST.FIPS.180-4, August 2015.

   [X690]     ITU-T, "Information technology -- ASN.1 encoding rules:
              Specification of Basic Encoding Rules (BER), Canonical
              Encoding Rules (CER) and Distinguished Encoding Rules
              (DER)", ISO/IEC 8825-1:2015, November 2015.
```

---
### **12.2.  Informative References**

```text
   [AEAD-LIMITS]
              Luykx, A. and K. Paterson, "Limits on Authenticated
              Encryption Use in TLS", August 2017,
              <http://www.isg.rhul.ac.uk/~kp/TLS-AEbounds.pdf>.

   [BBFGKZ16]
              Bhargavan, K., Brzuska, C., Fournet, C., Green, M.,
              Kohlweiss, M., and S. Zanella-Beguelin, "Downgrade
              Resilience in Key-Exchange Protocols", Proceedings of IEEE
              Symposium on Security and Privacy (San Jose),
              DOI 10.1109/SP.2016.37, May 2016.

   [BBK17]    Bhargavan, K., Blanchet, B., and N. Kobeissi, "Verified
              Models and Reference Implementations for the TLS 1.3
              Standard Candidate", Proceedings of IEEE Symposium on
              Security and Privacy (San Jose), DOI 10.1109/SP.2017.26,
              May 2017.

   [BDFKPPRSZZ16]
              Bhargavan, K., Delignat-Lavaud, A., Fournet, C.,
              Kohlweiss, M., Pan, J., Protzenko, J., Rastogi, A., Swamy,
              N., Zanella-Beguelin, S., and J. Zinzindohoue,
              "Implementing and Proving the TLS 1.3 Record Layer",
              Proceedings of IEEE Symposium on Security and Privacy (San
              Jose), May 2017, <https://eprint.iacr.org/2016/1178>.

   [Ben17a]   Benjamin, D., "Presentation before the TLS WG at
              IETF 100", November 2017,
              <https://datatracker.ietf.org/meeting/100/materials/
              slides-100-tls-sessa-tls13/>.

   [Ben17b]   Benjamin, D., "Additional TLS 1.3 results from Chrome",
              message to the TLS mailing list, 18 December 2017,
              <https://www.ietf.org/mail-archive/web/tls/current/
              msg25168.html>.

   [Blei98]   Bleichenbacher, D., "Chosen Ciphertext Attacks against
              Protocols Based on RSA Encryption Standard PKCS #1",
              Proceedings of CRYPTO '98, 1998.

   [BMMRT15]  Badertscher, C., Matt, C., Maurer, U., Rogaway, P., and B.
              Tackmann, "Augmented Secure Channels and the Goal of the
              TLS 1.3 Record Layer", ProvSec 2015, September 2015,
              <https://eprint.iacr.org/2015/394>.

   [BT16]     Bellare, M. and B. Tackmann, "The Multi-User Security of
              Authenticated Encryption: AES-GCM in TLS 1.3", Proceedings
              of CRYPTO 2016, July 2016,
              <https://eprint.iacr.org/2016/564>.

   [CCG16]    Cohn-Gordon, K., Cremers, C., and L. Garratt, "On
              Post-compromise Security", IEEE Computer Security
              Foundations Symposium, DOI 10.1109/CSF.2016.19, July 2015.

   [CHECKOWAY]
              Checkoway, S., Maskiewicz, J., Garman, C., Fried, J.,
              Cohney, S., Green, M., Heninger, N., Weinmann, R.,
              Rescorla, E., and H. Shacham, "A Systematic Analysis of
              the Juniper Dual EC Incident", Proceedings of the 2016 ACM
              SIGSAC Conference on Computer and Communications Security
              - CCS '16, DOI 10.1145/2976749.2978395, October 2016.

   [CHHSV17]  Cremers, C., Horvat, M., Hoyland, J., Scott, S., and T.
              van der Merwe, "Awkward Handshake: Possible mismatch of
              client/server view on client authentication in
              post-handshake mode in Revision 18", message to the TLS
              mailing list, 10 February 2017, <https://www.ietf.org/
              mail-archive/web/tls/current/msg22382.html>.

   [CHSV16]   Cremers, C., Horvat, M., Scott, S., and T. van der Merwe,
              "Automated Analysis and Verification of TLS 1.3: 0-RTT,
              Resumption and Delayed Authentication", Proceedings of
              IEEE Symposium on Security and Privacy (San Jose),
              DOI 10.1109/SP.2016.35, May 2016,
              <https://ieeexplore.ieee.org/document/7546518/>.

   [CK01]     Canetti, R. and H. Krawczyk, "Analysis of Key-Exchange
              Protocols and Their Use for Building Secure Channels",
              Proceedings of Eurocrypt 2001,
              DOI 10.1007/3-540-44987-6_28, April 2001.

   [CLINIC]   Miller, B., Huang, L., Joseph, A., and J. Tygar, "I Know
              Why You Went to the Clinic: Risks and Realization of HTTPS
              Traffic Analysis", Privacy Enhancing Technologies, pp.
              143-163, DOI 10.1007/978-3-319-08506-7_8, 2014.

   [DFGS15]   Dowling, B., Fischlin, M., Guenther, F., and D. Stebila,
              "A Cryptographic Analysis of the TLS 1.3 Handshake
              Protocol Candidates", Proceedings of ACM CCS 2015,
              October 2015, <https://eprint.iacr.org/2015/914>.

   [DFGS16]   Dowling, B., Fischlin, M., Guenther, F., and D. Stebila,
              "A Cryptographic Analysis of the TLS 1.3 Full and
              Pre-shared Key Handshake Protocol", TRON 2016,
              February 2016, <https://eprint.iacr.org/2016/081>.

   [DOW92]    Diffie, W., van Oorschot, P., and M. Wiener,
              "Authentication and authenticated key exchanges", Designs,
              Codes and Cryptography, DOI 10.1007/BF00124891, June 1992.

   [DSS]      National Institute of Standards and Technology, U.S.
              Department of Commerce, "Digital Signature Standard
              (DSS)", NIST FIPS PUB 186-4, DOI 10.6028/NIST.FIPS.186-4,
              July 2013.

   [FG17]     Fischlin, M. and F. Guenther, "Replay Attacks on Zero
              Round-Trip Time: The Case of the TLS 1.3 Handshake
              Candidates", Proceedings of EuroS&P 2017, April 2017,
              <https://eprint.iacr.org/2017/082>.

   [FGSW16]   Fischlin, M., Guenther, F., Schmidt, B., and B. Warinschi,
              "Key Confirmation in Key Exchange: A Formal Treatment and
              Implications for TLS 1.3", Proceedings of IEEE Symposium
              on Security and Privacy (San Jose),
              DOI 10.1109/SP.2016.34, May 2016,
              <https://ieeexplore.ieee.org/document/7546517/>.

   [FW15]     Weimer, F., "Factoring RSA Keys With TLS Perfect Forward
              Secrecy", September 2015.

   [HCJC16]   Husak, M., Cermak, M., Jirsik, T., and P. Celeda, "HTTPS
              traffic analysis and client identification using passive
              SSL/TLS fingerprinting", EURASIP Journal on Information
              Security, Vol. 2016, DOI 10.1186/s13635-016-0030-7,
              February 2016.

   [HGFS15]   Hlauschek, C., Gruber, M., Fankhauser, F., and C. Schanes,
              "Prying Open Pandora's Box: KCI Attacks against TLS",
              Proceedings of USENIX Workshop on Offensive Technologies,
              August 2015.

   [IEEE1363]
              IEEE, "IEEE Standard Specifications for Public Key
              Cryptography", IEEE Std. 1363-2000,
              DOI 10.1109/IEEESTD.2000.92292.

   [JSS15]    Jager, T., Schwenk, J., and J. Somorovsky, "On the
              Security of TLS 1.3 and QUIC Against Weaknesses in PKCS#1
              v1.5 Encryption", Proceedings of ACM CCS 2015,
              DOI 10.1145/2810103.2813657, October 2015,
              <https://www.nds.rub.de/media/nds/
              veroeffentlichungen/2015/08/21/Tls13QuicAttacks.pdf>.

   [KEYAGREEMENT]
              Barker, E., Chen, L., Roginsky, A., Vassilev, A., and R.
              Davis, "Recommendation for Pair-Wise Key Establishment
              Schemes Using Discrete Logarithm Cryptography", National
              Institute of Standards and Technology,
              DOI 10.6028/NIST.SP.800-56Ar3, April 2018.

   [Kraw10]   Krawczyk, H., "Cryptographic Extraction and Key
              Derivation: The HKDF Scheme", Proceedings of CRYPTO 2010,
              August 2010, <https://eprint.iacr.org/2010/264>.

   [Kraw16]   Krawczyk, H., "A Unilateral-to-Mutual Authentication
              Compiler for Key Exchange (with Applications to Client
              Authentication in TLS 1.3", Proceedings of ACM CCS 2016,
              October 2016, <https://eprint.iacr.org/2016/711>.

   [KW16]     Krawczyk, H. and H. Wee, "The OPTLS Protocol and TLS 1.3",
              Proceedings of EuroS&P 2016, March 2016,
              <https://eprint.iacr.org/2015/978>.

   [LXZFH16]  Li, X., Xu, J., Zhang, Z., Feng, D., and H. Hu, "Multiple
              Handshakes Security of TLS 1.3 Candidates", Proceedings of
              IEEE Symposium on Security and Privacy (San Jose),
              DOI 10.1109/SP.2016.36, May 2016,
              <https://ieeexplore.ieee.org/document/7546519/>.

   [Mac17]    MacCarthaigh, C., "Security Review of TLS1.3 0-RTT",
              March 2017, <https://github.com/tlswg/tls13-spec/
              issues/1001>.

   [PS18]     Patton, C. and T. Shrimpton, "Partially specified
              channels: The TLS 1.3 record layer without elision", 2018,
              <https://eprint.iacr.org/2018/634>.

   [PSK-FINISHED]
              Scott, S., Cremers, C., Horvat, M., and T. van der Merwe,
              "Revision 10: possible attack if client authentication is
              allowed during PSK", message to the TLS mailing list,
              31 October 2015, <https://www.ietf.org/
              mail-archive/web/tls/current/msg18215.html>.

   [REKEY]    Abdalla, M. and M. Bellare, "Increasing the Lifetime of a
              Key: A Comparative Analysis of the Security of Re-keying
              Techniques", ASIACRYPT 2000, DOI 10.1007/3-540-44448-3_42,
              October 2000.

   [Res17a]   Rescorla, E., "Preliminary data on Firefox TLS 1.3
              Middlebox experiment", message to the TLS mailing list,
              5 December 2017, <https://www.ietf.org/
              mail-archive/web/tls/current/msg25091.html>.

   [Res17b]   Rescorla, E., "More compatibility measurement results",
              message to the TLS mailing list, 22 December 2017,
              <https://www.ietf.org/mail-archive/web/tls/current/
              msg25179.html>.

   [RFC3552]  Rescorla, E. and B. Korver, "Guidelines for Writing RFC
              Text on Security Considerations", BCP 72, RFC 3552,
              DOI 10.17487/RFC3552, July 2003,
              <https://www.rfc-editor.org/info/rfc3552>.

   [RFC4086]  Eastlake 3rd, D., Schiller, J., and S. Crocker,
              "Randomness Requirements for Security", BCP 106, RFC 4086,
              DOI 10.17487/RFC4086, June 2005,
              <https://www.rfc-editor.org/info/rfc4086>.

   [RFC4346]  Dierks, T. and E. Rescorla, "The Transport Layer Security
              (TLS) Protocol Version 1.1", RFC 4346,
              DOI 10.17487/RFC4346, April 2006,
              <https://www.rfc-editor.org/info/rfc4346>.

   [RFC4366]  Blake-Wilson, S., Nystrom, M., Hopwood, D., Mikkelsen, J.,
              and T. Wright, "Transport Layer Security (TLS)
              Extensions", RFC 4366, DOI 10.17487/RFC4366, April 2006,
              <https://www.rfc-editor.org/info/rfc4366>.

   [RFC4492]  Blake-Wilson, S., Bolyard, N., Gupta, V., Hawk, C., and B.
              Moeller, "Elliptic Curve Cryptography (ECC) Cipher Suites
              for Transport Layer Security (TLS)", RFC 4492,
              DOI 10.17487/RFC4492, May 2006,
              <https://www.rfc-editor.org/info/rfc4492>.

   [RFC5077]  Salowey, J., Zhou, H., Eronen, P., and H. Tschofenig,
              "Transport Layer Security (TLS) Session Resumption without
              Server-Side State", RFC 5077, DOI 10.17487/RFC5077,
              January 2008, <https://www.rfc-editor.org/info/rfc5077>.

   [RFC5246]  Dierks, T. and E. Rescorla, "The Transport Layer Security
              (TLS) Protocol Version 1.2", RFC 5246,
              DOI 10.17487/RFC5246, August 2008,
              <https://www.rfc-editor.org/info/rfc5246>.

   [RFC5764]  McGrew, D. and E. Rescorla, "Datagram Transport Layer
              Security (DTLS) Extension to Establish Keys for the Secure
              Real-time Transport Protocol (SRTP)", RFC 5764,
              DOI 10.17487/RFC5764, May 2010,
              <https://www.rfc-editor.org/info/rfc5764>.

   [RFC5929]  Altman, J., Williams, N., and L. Zhu, "Channel Bindings
              for TLS", RFC 5929, DOI 10.17487/RFC5929, July 2010,
              <https://www.rfc-editor.org/info/rfc5929>.

   [RFC6091]  Mavrogiannopoulos, N. and D. Gillmor, "Using OpenPGP Keys
              for Transport Layer Security (TLS) Authentication",
              RFC 6091, DOI 10.17487/RFC6091, February 2011,
              <https://www.rfc-editor.org/info/rfc6091>.

   [RFC6101]  Freier, A., Karlton, P., and P. Kocher, "The Secure
              Sockets Layer (SSL) Protocol Version 3.0", RFC 6101,
              DOI 10.17487/RFC6101, August 2011,
              <https://www.rfc-editor.org/info/rfc6101>.

   [RFC6176]  Turner, S. and T. Polk, "Prohibiting Secure Sockets Layer
              (SSL) Version 2.0", RFC 6176, DOI 10.17487/RFC6176,
              March 2011, <https://www.rfc-editor.org/info/rfc6176>.

   [RFC6347]  Rescorla, E. and N. Modadugu, "Datagram Transport Layer
              Security Version 1.2", RFC 6347, DOI 10.17487/RFC6347,
              January 2012, <https://www.rfc-editor.org/info/rfc6347>.

   [RFC6520]  Seggelmann, R., Tuexen, M., and M. Williams, "Transport
              Layer Security (TLS) and Datagram Transport Layer Security
              (DTLS) Heartbeat Extension", RFC 6520,
              DOI 10.17487/RFC6520, February 2012,
              <https://www.rfc-editor.org/info/rfc6520>.

   [RFC7230]  Fielding, R., Ed. and J. Reschke, Ed., "Hypertext Transfer
              Protocol (HTTP/1.1): Message Syntax and Routing",
              RFC 7230, DOI 10.17487/RFC7230, June 2014,
              <https://www.rfc-editor.org/info/rfc7230>.

   [RFC7250]  Wouters, P., Ed., Tschofenig, H., Ed., Gilmore, J.,
              Weiler, S., and T. Kivinen, "Using Raw Public Keys in
              Transport Layer Security (TLS) and Datagram Transport
              Layer Security (DTLS)", RFC 7250, DOI 10.17487/RFC7250,
              June 2014, <https://www.rfc-editor.org/info/rfc7250>.

   [RFC7465]  Popov, A., "Prohibiting RC4 Cipher Suites", RFC 7465,
              DOI 10.17487/RFC7465, February 2015,
              <https://www.rfc-editor.org/info/rfc7465>.

   [RFC7568]  Barnes, R., Thomson, M., Pironti, A., and A. Langley,
              "Deprecating Secure Sockets Layer Version 3.0", RFC 7568,
              DOI 10.17487/RFC7568, June 2015,
              <https://www.rfc-editor.org/info/rfc7568>.

   [RFC7627]  Bhargavan, K., Ed., Delignat-Lavaud, A., Pironti, A.,
              Langley, A., and M. Ray, "Transport Layer Security (TLS)
              Session Hash and Extended Master Secret Extension",
              RFC 7627, DOI 10.17487/RFC7627, September 2015,
              <https://www.rfc-editor.org/info/rfc7627>.

   [RFC7685]  Langley, A., "A Transport Layer Security (TLS) ClientHello
              Padding Extension", RFC 7685, DOI 10.17487/RFC7685,
              October 2015, <https://www.rfc-editor.org/info/rfc7685>.

   [RFC7924]  Santesson, S. and H. Tschofenig, "Transport Layer Security
              (TLS) Cached Information Extension", RFC 7924,
              DOI 10.17487/RFC7924, July 2016,
              <https://www.rfc-editor.org/info/rfc7924>.

   [RFC8305]  Schinazi, D. and T. Pauly, "Happy Eyeballs Version 2:
              Better Connectivity Using Concurrency", RFC 8305,
              DOI 10.17487/RFC8305, December 2017,
              <https://www.rfc-editor.org/info/rfc8305>.

   [RFC8422]  Nir, Y., Josefsson, S., and M. Pegourie-Gonnard, "Elliptic
              Curve Cryptography (ECC) Cipher Suites for Transport Layer
              Security (TLS) Versions 1.2 and Earlier", RFC 8422,
              DOI 10.17487/RFC8422, August 2018,
              <https://www.rfc-editor.org/info/rfc8422>.

   [RFC8447]  Salowey, J. and S. Turner, "IANA Registry Updates for TLS
              and DTLS", RFC 8447, DOI 10.17487/RFC8447, August 2018,
              <https://www.rfc-editor.org/info/rfc8447>.

   [RFC8449]  Thomson, M., "Record Size Limit Extension for TLS",
              RFC 8449, DOI 10.17487/RFC8449, August 2018,
              <https://www.rfc-editor.org/info/rfc8449>.

   [RSA]      Rivest, R., Shamir, A., and L. Adleman, "A Method for
              Obtaining Digital Signatures and Public-Key
              Cryptosystems", Communications of the ACM, Vol. 21 No. 2,
              pp. 120-126, DOI 10.1145/359340.359342, February 1978.

   [SIGMA]    Krawczyk, H., "SIGMA: The 'SIGn-and-MAc' Approach to
              Authenticated Diffie-Hellman and its Use in the IKE
              Protocols", Proceedings of CRYPTO 2003,
              DOI 10.1007/978-3-540-45146-4_24, August 2003.

   [SLOTH]    Bhargavan, K. and G. Leurent, "Transcript Collision
              Attacks: Breaking Authentication in TLS, IKE, and SSH",
              Network and Distributed System Security
              Symposium (NDSS 2016), DOI 10.14722/ndss.2016.23418,
              February 2016.

   [SSL2]     Hickman, K., "The SSL Protocol", February 1995.

   [TIMING]   Boneh, D. and D. Brumley, "Remote Timing Attacks Are
              Practical", USENIX Security Symposium, August 2003.

   [TLS13-TRACES]
              Thomson, M., "Example Handshake Traces for TLS 1.3", Work
              in Progress, draft-ietf-tls-tls13-vectors-06, July 2018.

   [X501]     ITU-T, "Information Technology - Open Systems
              Interconnection - The Directory: Models", ITU-T X.501,
              October 2016, <https://www.itu.int/rec/T-REC-X.501/en>.
```

---
# **Appendix A.  State Machine**

이 부록에서는 클라이언트 및 서버 핸드셰이크에 대한 법적 상태 전환에 대한 요약을 제공합니다. 주 이름\(모두 대문자, 예: START\)은 공식적인 의미가 없지만 이해하기 쉽도록 제공됩니다. 특정 상황에서만 수행되는 조치는 \[\]로 표시됩니다. "K\_{send,recv} = foo" 표기는 "보내기/받기 키를 주어진 키로 설정"을 의미합니다.

---
### **A.1.  Client**

```text
                              START <----+
               Send ClientHello |        | Recv HelloRetryRequest
          [K_send = early data] |        |
                                v        |
           /                 WAIT_SH ----+
           |                    | Recv ServerHello
           |                    | K_recv = handshake
       Can |                    V
      send |                 WAIT_EE
     early |                    | Recv EncryptedExtensions
      data |           +--------+--------+
           |     Using |                 | Using certificate
           |       PSK |                 v
           |           |            WAIT_CERT_CR
           |           |        Recv |       | Recv CertificateRequest
           |           | Certificate |       v
           |           |             |    WAIT_CERT
           |           |             |       | Recv Certificate
           |           |             v       v
           |           |              WAIT_CV
           |           |                 | Recv CertificateVerify
           |           +> WAIT_FINISHED <+
           |                  | Recv Finished
           \                  | [Send EndOfEarlyData]
                              | K_send = handshake
                              | [Send Certificate [+ CertificateVerify]]
    Can send                  | Send Finished
    app data   -->            | K_send = K_recv = application
    after here                v
                          CONNECTED
```

위에 표시된 전환을 통해 클라이언트는 일반 형식 또는 초기 데이터 키를 사용하여 post-ServerHello 메시지에서 파생되는 경고를 보낼 수 있습니다. 클라이언트가 이러한 경고를 보내야 하는 경우 가능하면 먼저 핸드셰이크 키를 다시 입력해야 합니다.\(SHOULD\)

---
### **A.2.  Server**

```text
                              START <-----+
               Recv ClientHello |         | Send HelloRetryRequest
                                v         |
                             RECVD_CH ----+
                                | Select parameters
                                v
                             NEGOTIATED
                                | Send ServerHello
                                | K_send = handshake
                                | Send EncryptedExtensions
                                | [Send CertificateRequest]
 Can send                       | [Send Certificate + CertificateVerify]
 app data                       | Send Finished
 after   -->                    | K_send = application
 here                  +--------+--------+
              No 0-RTT |                 | 0-RTT
                       |                 |
   K_recv = handshake  |                 | K_recv = early data
 [Skip decrypt errors] |    +------> WAIT_EOED -+
                       |    |       Recv |      | Recv EndOfEarlyData
                       |    | early data |      | K_recv = handshake
                       |    +------------+      |
                       |                        |
                       +> WAIT_FLIGHT2 <--------+
                                |
                       +--------+--------+
               No auth |                 | Client auth
                       |                 |
                       |                 v
                       |             WAIT_CERT
                       |        Recv |       | Recv Certificate
                       |       empty |       v
                       | Certificate |    WAIT_CV
                       |             |       | Recv
                       |             v       | CertificateVerify
                       +-> WAIT_FINISHED <---+
                                | Recv Finished
                                | K_recv = application
                                v
                            CONNECTED
```

---
# **Appendix B.  Protocol Data Structures and Constant Values**

이 부록은 표준 프로토콜 유형과 상수에 대한 정의를 제공합니다. "\_RESERVED"로 나열된 값은 TLS의 이전 버전에서 사용되었으며 완전성을 위해 여기에 나열됩니다. TLS 1.3 구현은 이를 보내면 안 되며\(MUST NOT\) 이전 TLS 구현에서 수신할 수 있습니다.\(MUST NOT\)

---
### **B.1.  Record Layer**

```text
      enum {
          invalid(0),
          change_cipher_spec(20),
          alert(21),
          handshake(22),
          application_data(23),
          heartbeat(24),  /* RFC 6520 */
          (255)
      } ContentType;

      struct {
          ContentType type;
          ProtocolVersion legacy_record_version;
          uint16 length;
          opaque fragment[TLSPlaintext.length];
      } TLSPlaintext;

      struct {
          opaque content[TLSPlaintext.length];
          ContentType type;
          uint8 zeros[length_of_padding];
      } TLSInnerPlaintext;

      struct {
          ContentType opaque_type = application_data; /* 23 */
          ProtocolVersion legacy_record_version = 0x0303; /* TLS v1.2 */
          uint16 length;
          opaque encrypted_record[TLSCiphertext.length];
      } TLSCiphertext;
```

---
### **B.2.  Alert Messages**

```text
      enum { warning(1), fatal(2), (255) } AlertLevel;

      enum {
          close_notify(0),
          unexpected_message(10),
          bad_record_mac(20),
          decryption_failed_RESERVED(21),
          record_overflow(22),
          decompression_failure_RESERVED(30),
          handshake_failure(40),
          no_certificate_RESERVED(41),
          bad_certificate(42),
          unsupported_certificate(43),
          certificate_revoked(44),
          certificate_expired(45),
          certificate_unknown(46),
          illegal_parameter(47),
          unknown_ca(48),
          access_denied(49),
          decode_error(50),
          decrypt_error(51),
          export_restriction_RESERVED(60),
          protocol_version(70),
          insufficient_security(71),
          internal_error(80),
          inappropriate_fallback(86),
          user_canceled(90),
          no_renegotiation_RESERVED(100),
          missing_extension(109),
          unsupported_extension(110),
          certificate_unobtainable_RESERVED(111),
          unrecognized_name(112),
          bad_certificate_status_response(113),
          bad_certificate_hash_value_RESERVED(114),
          unknown_psk_identity(115),
          certificate_required(116),
          no_application_protocol(120),
          (255)
      } AlertDescription;

      struct {
          AlertLevel level;
          AlertDescription description;
      } Alert;
```

---
### **B.3.  Handshake Protocol**

```text
      enum {
          hello_request_RESERVED(0),
          client_hello(1),
          server_hello(2),
          hello_verify_request_RESERVED(3),
          new_session_ticket(4),
          end_of_early_data(5),
          hello_retry_request_RESERVED(6),
          encrypted_extensions(8),
          certificate(11),
          server_key_exchange_RESERVED(12),
          certificate_request(13),
          server_hello_done_RESERVED(14),
          certificate_verify(15),
          client_key_exchange_RESERVED(16),
          finished(20),
          certificate_url_RESERVED(21),
          certificate_status_RESERVED(22),
          supplemental_data_RESERVED(23),
          key_update(24),
          message_hash(254),
          (255)
      } HandshakeType;

      struct {
          HandshakeType msg_type;    /* handshake type */
          uint24 length;             /* bytes in message */
          select (Handshake.msg_type) {
              case client_hello:          ClientHello;
              case server_hello:          ServerHello;
              case end_of_early_data:     EndOfEarlyData;
              case encrypted_extensions:  EncryptedExtensions;
              case certificate_request:   CertificateRequest;
              case certificate:           Certificate;
              case certificate_verify:    CertificateVerify;
              case finished:              Finished;
              case new_session_ticket:    NewSessionTicket;
              case key_update:            KeyUpdate;
          };
      } Handshake;
```

---
#### **B.3.1.  Key Exchange Messages**

```text
    uint16 ProtocolVersion;
    opaque Random[32];

    uint8 CipherSuite[2];    /* Cryptographic suite selector */

    struct {
        ProtocolVersion legacy_version = 0x0303;    /* TLS v1.2 */
        Random random;
        opaque legacy_session_id<0..32>;
        CipherSuite cipher_suites<2..2^16-2>;
        opaque legacy_compression_methods<1..2^8-1>;
        Extension extensions<8..2^16-1>;
    } ClientHello;

    struct {
        ProtocolVersion legacy_version = 0x0303;    /* TLS v1.2 */
        Random random;
        opaque legacy_session_id_echo<0..32>;
        CipherSuite cipher_suite;
        uint8 legacy_compression_method = 0;
        Extension extensions<6..2^16-1>;
    } ServerHello;

    struct {
        ExtensionType extension_type;
        opaque extension_data<0..2^16-1>;
    } Extension;

    enum {
        server_name(0),                             /* RFC 6066 */
        max_fragment_length(1),                     /* RFC 6066 */
        status_request(5),                          /* RFC 6066 */
        supported_groups(10),                       /* RFC 8422, 7919 */
        signature_algorithms(13),                   /* RFC 8446 */
        use_srtp(14),                               /* RFC 5764 */
        heartbeat(15),                              /* RFC 6520 */
        application_layer_protocol_negotiation(16), /* RFC 7301 */
        signed_certificate_timestamp(18),           /* RFC 6962 */
        client_certificate_type(19),                /* RFC 7250 */
        server_certificate_type(20),                /* RFC 7250 */
        padding(21),                                /* RFC 7685 */
        RESERVED(40),                               /* Used but never
                                                       assigned */
        pre_shared_key(41),                         /* RFC 8446 */
        early_data(42),                             /* RFC 8446 */
        supported_versions(43),                     /* RFC 8446 */
        cookie(44),                                 /* RFC 8446 */
        psk_key_exchange_modes(45),                 /* RFC 8446 */
        RESERVED(46),                               /* Used but never
                                                       assigned */
        certificate_authorities(47),                /* RFC 8446 */
        oid_filters(48),                            /* RFC 8446 */
        post_handshake_auth(49),                    /* RFC 8446 */
        signature_algorithms_cert(50),              /* RFC 8446 */
        key_share(51),                              /* RFC 8446 */
        (65535)
    } ExtensionType;

    struct {
        NamedGroup group;
        opaque key_exchange<1..2^16-1>;
    } KeyShareEntry;

    struct {
        KeyShareEntry client_shares<0..2^16-1>;
    } KeyShareClientHello;

    struct {
        NamedGroup selected_group;
    } KeyShareHelloRetryRequest;

    struct {
        KeyShareEntry server_share;
    } KeyShareServerHello;

    struct {
        uint8 legacy_form = 4;
        opaque X[coordinate_length];
        opaque Y[coordinate_length];
    } UncompressedPointRepresentation;

    enum { psk_ke(0), psk_dhe_ke(1), (255) } PskKeyExchangeMode;

    struct {
        PskKeyExchangeMode ke_modes<1..255>;
    } PskKeyExchangeModes;

    struct {} Empty;

    struct {
        select (Handshake.msg_type) {
            case new_session_ticket:   uint32 max_early_data_size;
            case client_hello:         Empty;
            case encrypted_extensions: Empty;
        };
    } EarlyDataIndication;

    struct {
        opaque identity<1..2^16-1>;
        uint32 obfuscated_ticket_age;
    } PskIdentity;

    opaque PskBinderEntry<32..255>;

    struct {
        PskIdentity identities<7..2^16-1>;
        PskBinderEntry binders<33..2^16-1>;
    } OfferedPsks;

    struct {
        select (Handshake.msg_type) {
            case client_hello: OfferedPsks;
            case server_hello: uint16 selected_identity;
        };
    } PreSharedKeyExtension;
```

---
##### **B.3.1.1.  Version Extension**

```text
      struct {
          select (Handshake.msg_type) {
              case client_hello:
                   ProtocolVersion versions<2..254>;

              case server_hello: /* and HelloRetryRequest */
                   ProtocolVersion selected_version;
          };
      } SupportedVersions;
```

---
##### **B.3.1.2.  Cookie Extension**

```text
      struct {
          opaque cookie<1..2^16-1>;
      } Cookie;
```

---
##### **B.3.1.3.  Signature Algorithm Extension**

```text
      enum {
          /* RSASSA-PKCS1-v1_5 algorithms */
          rsa_pkcs1_sha256(0x0401),
          rsa_pkcs1_sha384(0x0501),
          rsa_pkcs1_sha512(0x0601),

          /* ECDSA algorithms */
          ecdsa_secp256r1_sha256(0x0403),
          ecdsa_secp384r1_sha384(0x0503),
          ecdsa_secp521r1_sha512(0x0603),

          /* RSASSA-PSS algorithms with public key OID rsaEncryption */
          rsa_pss_rsae_sha256(0x0804),
          rsa_pss_rsae_sha384(0x0805),
          rsa_pss_rsae_sha512(0x0806),

          /* EdDSA algorithms */
          ed25519(0x0807),
          ed448(0x0808),

          /* RSASSA-PSS algorithms with public key OID RSASSA-PSS */
          rsa_pss_pss_sha256(0x0809),
          rsa_pss_pss_sha384(0x080a),
          rsa_pss_pss_sha512(0x080b),

          /* Legacy algorithms */
          rsa_pkcs1_sha1(0x0201),
          ecdsa_sha1(0x0203),

          /* Reserved Code Points */
          obsolete_RESERVED(0x0000..0x0200),
          dsa_sha1_RESERVED(0x0202),
          obsolete_RESERVED(0x0204..0x0400),
          dsa_sha256_RESERVED(0x0402),
          obsolete_RESERVED(0x0404..0x0500),
          dsa_sha384_RESERVED(0x0502),
          obsolete_RESERVED(0x0504..0x0600),
          dsa_sha512_RESERVED(0x0602),
          obsolete_RESERVED(0x0604..0x06FF),
          private_use(0xFE00..0xFFFF),
          (0xFFFF)
      } SignatureScheme;

      struct {
          SignatureScheme supported_signature_algorithms<2..2^16-2>;
      } SignatureSchemeList;
```

---
##### **B.3.1.4.  Supported Groups Extension**

```text
      enum {
          unallocated_RESERVED(0x0000),

          /* Elliptic Curve Groups (ECDHE) */
          obsolete_RESERVED(0x0001..0x0016),
          secp256r1(0x0017), secp384r1(0x0018), secp521r1(0x0019),
          obsolete_RESERVED(0x001A..0x001C),
          x25519(0x001D), x448(0x001E),

          /* Finite Field Groups (DHE) */
          ffdhe2048(0x0100), ffdhe3072(0x0101), ffdhe4096(0x0102),
          ffdhe6144(0x0103), ffdhe8192(0x0104),

          /* Reserved Code Points */
          ffdhe_private_use(0x01FC..0x01FF),
          ecdhe_private_use(0xFE00..0xFEFF),
          obsolete_RESERVED(0xFF01..0xFF02),
          (0xFFFF)
      } NamedGroup;

      struct {
          NamedGroup named_group_list<2..2^16-1>;
      } NamedGroupList;
```

"obsolete\_RESERVED" 범위 내의 값은 TLS의 이전 버전에서 사용되며 TLS 1.3 구현에 의해 제공되거나 협상되어서는 안 됩니다\(MUST NOT\). 구식 곡선에는 다양한 알려진/이론적 약점이 있거나 의도하지 않은 서버 구성 문제로 인해 사용이 거의 없었습니다. 더 이상 일반적인 사용에 적합하지 않으며 잠재적으로 안전하지 않은 것으로 간주되어야 합니다. 여기에 지정된 곡선 집합은 현재 배포되고 적절하게 구성된 모든 TLS 구현과의 상호 운용성에 충분합니다.\(MUST NOT\)

---
#### **B.3.2.  Server Parameters Messages**

```text
      opaque DistinguishedName<1..2^16-1>;

      struct {
          DistinguishedName authorities<3..2^16-1>;
      } CertificateAuthoritiesExtension;

      struct {
          opaque certificate_extension_oid<1..2^8-1>;
          opaque certificate_extension_values<0..2^16-1>;
      } OIDFilter;

      struct {
          OIDFilter filters<0..2^16-1>;
      } OIDFilterExtension;

      struct {} PostHandshakeAuth;

      struct {
          Extension extensions<0..2^16-1>;
      } EncryptedExtensions;

      struct {
          opaque certificate_request_context<0..2^8-1>;
          Extension extensions<2..2^16-1>;
      } CertificateRequest;
```

---
#### **B.3.3.  Authentication Messages**

```text
      enum {
          X509(0),
          OpenPGP_RESERVED(1),
          RawPublicKey(2),
          (255)
      } CertificateType;

      struct {
          select (certificate_type) {
              case RawPublicKey:
                /* From RFC 7250 ASN.1_subjectPublicKeyInfo */
                opaque ASN1_subjectPublicKeyInfo<1..2^24-1>;

              case X509:
                opaque cert_data<1..2^24-1>;
          };
          Extension extensions<0..2^16-1>;
      } CertificateEntry;

      struct {
          opaque certificate_request_context<0..2^8-1>;
          CertificateEntry certificate_list<0..2^24-1>;
      } Certificate;

      struct {
          SignatureScheme algorithm;
          opaque signature<0..2^16-1>;
      } CertificateVerify;

      struct {
          opaque verify_data[Hash.length];
      } Finished;
```

---
#### **B.3.4.  Ticket Establishment**

```text
      struct {
          uint32 ticket_lifetime;
          uint32 ticket_age_add;
          opaque ticket_nonce<0..255>;
          opaque ticket<1..2^16-1>;
          Extension extensions<0..2^16-2>;
      } NewSessionTicket;
```

---
#### **B.3.5.  Updating Keys**

```text
      struct {} EndOfEarlyData;

      enum {
          update_not_requested(0), update_requested(1), (255)
      } KeyUpdateRequest;

      struct {
          KeyUpdateRequest request_update;
      } KeyUpdate;
```

---
### **B.4.  Cipher Suites**

대칭 암호 그룹은 HKDF와 함께 사용할 AEAD 알고리즘과 해시 알고리즘의 쌍을 정의합니다. 암호 그룹 이름은 명명 규칙을 따릅니다.

```text
      CipherSuite TLS_AEAD_HASH = VALUE;

      +-----------+------------------------------------------------+
      | Component | Contents                                       |
      +-----------+------------------------------------------------+
      | TLS       | The string "TLS"                               |
      |           |                                                |
      | AEAD      | The AEAD algorithm used for record protection  |
      |           |                                                |
      | HASH      | The hash algorithm used with HKDF              |
      |           |                                                |
      | VALUE     | The two-byte ID assigned for this cipher suite |
      +-----------+------------------------------------------------+
```

이 사양은 TLS 1.3과 함께 사용할 다음과 같은 암호 제품군을 정의합니다.

```text
              +------------------------------+-------------+
              | Description                  | Value       |
              +------------------------------+-------------+
              | TLS_AES_128_GCM_SHA256       | {0x13,0x01} |
              |                              |             |
              | TLS_AES_256_GCM_SHA384       | {0x13,0x02} |
              |                              |             |
              | TLS_CHACHA20_POLY1305_SHA256 | {0x13,0x03} |
              |                              |             |
              | TLS_AES_128_CCM_SHA256       | {0x13,0x04} |
              |                              |             |
              | TLS_AES_128_CCM_8_SHA256     | {0x13,0x05} |
              +------------------------------+-------------+
```

해당 AEAD 알고리즘 AEAD\_AES\_128\_GCM, AEAD\_AES\_256\_GCM 및 AEAD\_AES\_128\_CCM은 \[RFC5116\]에 정의되어 있습니다. AEAD\_CHACHA20\_POLY1305는 \[RFC8439\]에 정의되어 있습니다. AEAD\_AES\_128\_CCM\_8은 \[RFC6655\]에 정의되어 있습니다. 해당 해시 알고리즘은 \[SHS\]에 정의되어 있습니다.

TLS 1.3은 이전 버전의 TLS와 동일한 암호 그룹 공간을 사용하지만 TLS 1.3 암호 그룹은 대칭 암호만 지정하는 등 다르게 정의되며 TLS 1.2에는 사용할 수 없습니다. 마찬가지로 TLS 1.2 이하용 암호 제품군은 TLS 1.3과 함께 사용할 수 없습니다.

섹션 11에 설명된 대로 IANA에서 새 암호 그룹 값을 할당합니다.

---
# **Appendix C.  Implementation Notes**

TLS 프로토콜은 많은 일반적인 보안 실수를 방지할 수 없습니다. 이 부록은 구현자를 지원하기 위한 몇 가지 권장 사항을 제공합니다. \[TLS13-TRACES\]는 TLS 1.3 핸드셰이크에 대한 테스트 벡터를 제공합니다.

---
### **C.1.  Random Number Generation and Seeding**

TLS에는 암호화 보안 의사 난수 생성기\(CSPRNG\)가 필요합니다. 대부분의 경우 운영 체제는 /dev/urandom과 같은 적절한 기능을 제공하며 다른\(예: 성능\) 문제 없이 사용해야 합니다. 새 구현을 만드는 것보다 기존 CSPRNG 구현을 사용하는 것이 좋습니다. 많은 적절한 암호화 라이브러리가 유리한 라이선스 조건에 따라 이미 사용 가능합니다. 만족스럽지 않은 경우 \[RFC4086\]에서 무작위 값 생성에 대한 지침을 제공합니다.\(SHOULD\)

TLS는 \(1\) ClientHello 및 ServerHello의 공용 임의 값과 같은 공용 프로토콜 필드에서 임의 값을 사용하고 \(2\) 키 자료를 생성합니다. 제대로 작동하는 CSPRNG를 사용하면 출력에서 ​​CSPRNG 상태를 확인할 수 없으므로 보안 문제가 발생하지 않습니다. 그러나 손상된 CSPRNG를 사용하면 \[CHECKOWAY\]에 문서화된 것처럼 공격자가 공용 출력을 사용하여 CSPRNG 내부 상태를 결정하고 그에 따라 키 자료를 예측할 수 있습니다. 구현은 별도의 CSPRNG를 사용하여 공용 및 개인 값을 생성함으로써 이러한 형태의 공격에 대해 추가 보안을 제공할 수 있습니다.

---
### **C.2.  Certificates and Authentication**

구현은 인증서의 무결성을 확인할 책임이 있으며 일반적으로 인증서 해지 메시지를 지원해야 합니다. 응용 프로그램 프로필에 특정 표시가 없으면 신뢰할 수 있는 인증 기관\(CA\)에서 적절한 서명을 보장하기 위해 인증서를 항상 확인해야 합니다. 트러스트 앵커의 선택과 추가는 매우 신중해야 합니다. 사용자는 인증서 및 트러스트 앵커에 대한 정보를 볼 수 있어야 합니다. 애플리케이션은 최소 및 최대 키 크기도 적용해야 합니다\(SHOULD\). 예를 들어 2048비트 RSA 또는 224비트 ECDSA보다 약한 키 또는 서명을 포함하는 인증 경로는 보안 애플리케이션에 적합하지 않습니다.\(SHOULD\)

---
### **C.3.  Implementation Pitfalls**

구현 경험에 따르면 이전 TLS 사양의 특정 부분은 이해하기 쉽지 않고 상호 운용성 및 보안 문제의 원인이었습니다. 이러한 영역 중 많은 부분이 이 문서에서 명확해졌지만 이 부록에는 구현자의 특별한 주의가 필요한 가장 중요한 사항에 대한 간단한 목록이 포함되어 있습니다.

```text
   TLS protocol issues:
```

- 여러 TLS 레코드로 조각화된 핸드셰이크 메시지를 올바르게 처리합니까\(섹션 5.1 참조\)? 여러 개의 작은 조각으로 분할된 ClientHello와 같은 특수 사례를 올바르게 처리합니까? 최대 조각 크기를 초과하는 핸드셰이크 메시지를 조각화합니까? 특히, Certificate 및 CertificateRequest 핸드셰이크 메시지는 조각화가 필요할 만큼 커질 수 있습니다.

- 암호화되지 않은 모든 TLS 레코드에서 TLS 레코드 레이어 버전 번호를 무시합니까\(부록 D 참조\)?

- SSL, RC4, EXPORT 암호 및 MD5\("signature\_algorithms" 확장을 통해\)에 대한 모든 지원이 TLS 1.3 이상을 지원하는 가능한 모든 구성에서 완전히 제거되었는지, 그리고 이러한 사용되지 않는 기능을 사용하려는 시도가 올바르게 실패하는지 확인했습니까?\( 부록 D 참조\)?

- 알 수 없는 확장을 포함하여 ClientHellos에서 TLS 확장을 올바르게 처리합니까?

- 서버가 클라이언트 인증서를 요청했지만 적합한 인증서를 사용할 수 없는 경우 전체 메시지를 생략하는 대신 빈 인증서 메시지를 올바르게 보내나요\(섹션 4.4.2 참조\)?

- AEAD-Decrypt에서 생성된 일반 텍스트 조각을 처리하고 ContentType의 끝부터 스캔할 때 피어가 모두 0으로 구성된 잘못된 일반 텍스트를 보낸 경우 일반 텍스트의 시작 부분을 지나 스캔하는 것을 방지합니까?

- 인식할 수 없는 암호 제품군\(섹션 4.1.2\), hello 확장\(섹션 4.2\), 명명된 그룹\(섹션 4.2.7\), 키 공유\(섹션 4.2.8\), 지원되는 버전\(섹션 4.2.1\) 및 ClientHello?의 서명 알고리즘\(섹션 4.2.3\)

- 서버로서 호환되는 \(EC\)DHE 그룹을 지원하지만 "key\_share" 확장에서 이를 예측하지 않는 클라이언트에 HelloRetryRequest를 보내나요? 클라이언트로서 서버의 HelloRetryRequest를 올바르게 처리합니까?

```text
   Cryptographic details:
```

- 타이밍 공격 \[TIMING\]을 방지하기 위해 어떤 대응책을 사용합니까?

- Diffie-Hellman 키 교환을 사용할 때 협상된 키의 선행 0바이트를 올바르게 유지합니까\(섹션 7.4.1 참조\)?

- TLS 클라이언트는 서버에서 보낸 Diffie-Hellman 매개변수가 허용되는지 확인합니까\(섹션 4.2.8.1 참조\)?

- Diffie-Hellman 개인 값, ECDSA "k" 매개변수 및 기타 보안에 중요한 값을 생성할 때 강력하고 가장 중요하게 적절하게 시드된 난수 생성기\(부록 C.1 참조\)를 사용합니까? \[RFC6979\]에 지정된 대로 구현 시 "결정론적 ECDSA"를 구현하는 것이 권장됩니다.\(SHOULD\)

- 그룹 크기에 따라 Diffie-Hellman 공개 키 값과 공유 비밀을 제로 패드합니까\(섹션 4.2.8.1 및 섹션 7.4.1 참조\)?

- RSA-CRT 키 유출을 방지하기 위해 서명을 만든 후 확인합니까? \[FW15\]

---
### **C.4.  Client Tracking Prevention**

클라이언트는 여러 연결에 대한 티켓을 재사용해서는 안 됩니다. 티켓을 재사용하면 수동 관찰자가 서로 다른 연결을 연관시킬 수 있습니다. 티켓을 발행하는 서버는 최소한 클라이언트가 사용할 수 있는 연결 수만큼의 티켓을 제공해야 합니다. 예를 들어 HTTP/1.1\[RFC7230\]을 사용하는 웹 브라우저는 서버에 대한 6개의 연결을 열 수 있습니다. 서버는 연결될 때마다 새 티켓을 발급해야 합니다. 이렇게 하면 클라이언트가 새 연결을 만들 때 항상 새 티켓을 사용할 수 있습니다.\(SHOULD NOT, SHOULD, SHOULD\)

---
### **C.5.  Unauthenticated Operation**

이전 버전의 TLS는 익명의 Diffie-Hellman을 기반으로 명시적으로 인증되지 않은 암호화 제품군을 제공했습니다. 이러한 모드는 TLS 1.3에서 더 이상 사용되지 않습니다. 그러나 다음과 같은 여러 방법으로 검증 가능한 서버 인증을 제공하지 않는 매개변수를 협상하는 것은 여전히 ​​가능합니다.

```text
   -  Raw public keys [RFC7250].
```

- 인증서에 포함되어 있지만 인증서 체인이나 그 내용에 대한 유효성 검사 없이 공개 키를 사용합니다.

단독으로 사용되는 기술은 중간자 공격에 취약하므로 일반적인 사용에는 안전하지 않습니다. 그러나 서버 공개 키의 대역 외 유효성 검사, 처음 사용 시 신뢰 또는 채널 바인딩과 같은 메커니즘을 통해 이러한 연결을 외부 인증 메커니즘에 바인딩하는 것도 가능합니다\(\[RFC5929\]에 설명된 채널 바인딩에도 불구하고\). TLS 1.3에 대해 정의되지 않음\). 그러한 메커니즘이 사용되지 않으면 연결은 활성 중간자 공격에 대해 보호되지 않습니다. 애플리케이션은 명시적 구성이나 특정 애플리케이션 프로필이 없는 방식으로 TLS를 사용해서는 안 됩니다\(MUST NOT\).\(MUST NOT\)

---
# **Appendix D.  Backward Compatibility**

TLS 프로토콜은 잠재적으로 다른 버전의 TLS를 지원하는 엔드포인트 간의 버전 협상을 위한 기본 제공 메커니즘을 제공합니다.

TLS 1.x 및 SSL 3.0은 호환 가능한 ClientHello 메시지를 사용합니다. 또한 ClientHello 형식이 호환 가능하고 클라이언트와 서버 모두에서 지원하는 프로토콜 버전이 하나 이상 있는 한 서버는 향후 TLS 버전을 사용하려는 클라이언트를 처리할 수 있습니다.

이전 버전의 TLS는 다양한 용도로 레코드 레이어 버전 번호\(TLSPlaintext.legacy\_record\_version 및 TLSCiphertext.legacy\_record\_version\)를 사용했습니다. TLS 1.3부터 ​​이 필드는 더 이상 사용되지 않습니다. TLSPlaintext.legacy\_record\_version 값은 모든 구현에서 무시해야 합니다. TLSCiphertext.legacy\_record\_version의 값은 보호 해제를 위한 추가 데이터에 포함되지만 그렇지 않으면 무시되거나 고정 상수 값과 일치하도록 검증될 수 있습니다\(MAY\). 버전 협상은 핸드셰이크 버전\(ClientHello.legacy\_version 및 ServerHello.legacy\_version과 ClientHello, HelloRetryRequest 및 ServerHello "supported\_versions" 확장\)만 사용하여 수행됩니다. 이전 끝점과의 상호 운용성을 최대화하기 위해 TLS 1.0-1.2 사용을 협상하는 구현은 레코드 레이어 버전 번호를 ServerHello 및 그 이후의 모든 레코드에 대해 협상된 버전으로 설정해야 합니다\(SHOULD\).\(MUST, MAY, SHOULD\)

이전의 비표준 동작 및 잘못 구성된 배포와의 최대 호환성을 위해 모든 구현은 이전 TLS 버전의 핸드셰이크를 처리하는 경우에도 이 문서의 기대치를 기반으로 인증 경로의 유효성 검사를 지원해야 합니다\(섹션 4.4.2.2 참조\).\(SHOULD\)

TLS 1.2 및 이전 버전은 핸드셰이크 기록의 많은 부분을 마스터 비밀로 소화하는 "확장된 마스터 비밀" \[RFC7627\] 확장을 지원했습니다. TLS 1.3은 항상 기록에서 완료 서버까지 해시하기 때문에 TLS 1.3 및 이전 버전을 모두 지원하는 구현은 TLS 1.3이 사용될 때마다 API에서 확장 마스터 비밀 확장의 사용을 나타내야 합니다\(SHOULD\).\(SHOULD\)

---
### **D.1.  Negotiating with an Older Server**

TLS 1.3을 지원하지 않는 서버와 협상하려는 TLS 1.3 클라이언트는 ClientHello.legacy\_version에 0x0303\(TLS 1.2\)을 포함하지만 "supported\_versions" 확장에 올바른 버전을 포함하는 일반 TLS 1.3 ClientHello를 보냅니다. 서버가 TLS 1.3을 지원하지 않는 경우 이전 버전 번호가 포함된 ServerHello로 응답합니다. 클라이언트가 이 버전을 사용하는 데 동의하면 협상된 프로토콜에 따라 협상이 진행됩니다. 재개를 위해 티켓을 사용하는 클라이언트는 이전에 협상된 버전을 사용하여 연결을 시작해야 합니다\(SHOULD\).\(SHOULD\)

0-RTT 데이터는 이전 서버와 호환되지 않으며 서버가 TLS 1.3을 지원한다는 사실 없이 전송되어서는 안 됩니다. 부록 D.3을 참조하십시오.\(SHOULD NOT\)

서버에서 선택한 버전이 클라이언트에서 지원되지 않는 경우\(또는 허용되지 않는 경우\) 클라이언트는 "protocol\_version" 경고와 함께 핸드셰이크를 중단해야 합니다.\(MUST\)

일부 레거시 서버 구현은 TLS 사양을 제대로 구현하지 않는 것으로 알려져 있으며 알지 못하는 TLS 확장 또는 버전을 만나면 연결을 중단할 수 있습니다. 버그가 있는 서버와의 상호 운용성은 이 문서의 범위를 벗어나는 복잡한 주제입니다. 이전 버전과 호환되는 연결을 협상하려면 여러 연결 시도가 필요할 수 있습니다. 그러나 이 방법은 다운그레이드 공격에 취약하므로 권장되지 않습니다.\(SHOULD NOT\)

---
### **D.2.  Negotiating with an Older Client**

TLS 서버는 지원되는 가장 높은 버전보다 작은 버전 번호를 나타내는 ClientHello를 수신할 수도 있습니다. "supported\_versions" 확장자가 있는 경우 서버는 섹션 4.2.1에 설명된 대로 해당 확장자를 사용하여 협상해야 합니다. "supported\_versions" 확장자가 없으면 서버는 최소 ClientHello.legacy\_version 및 TLS 1.2를 협상해야 합니다. 예를 들어 서버가 TLS 1.0, 1.1, 1.2를 지원하고 legacy\_version이 TLS 1.0인 경우 서버는 TLS 1.0 ServerHello로 진행합니다. "supported\_versions" 확장이 없고 서버가 ClientHello.legacy\_version보다 높은 버전만 지원하는 경우 서버는 "protocol\_version" 경고와 함께 핸드셰이크를 중단해야 합니다.\(MUST, MUST, MUST\)

이전 버전의 TLS는 모든 경우에 레코드 레이어 버전 번호 값을 명확하게 지정하지 않았습니다\(TLSPlaintext.legacy\_record\_version\). 서버는 이 필드에서 다양한 TLS 1.x 버전을 수신하지만 해당 값은 항상 무시해야 합니다.\(MUST\)

---
### **D.3.  0-RTT Backward Compatibility**

0-RTT 데이터는 이전 서버와 호환되지 않습니다. 이전 서버는 이전 ServerHello로 ClientHello에 응답하지만 0-RTT 데이터를 올바르게 건너뛰지 않고 핸드셰이크를 완료하지 못합니다. 이로 인해 클라이언트가 특히 다중 서버 배포에 대해 0-RTT를 사용하려고 시도할 때 문제가 발생할 수 있습니다. 예를 들어 일부 서버는 TLS 1.3을 구현하고 일부는 TLS 1.2를 구현하는 배포에서 점진적으로 TLS 1.3을 배포하거나 TLS 1.3 배포를 TLS 1.2로 다운그레이드할 수 있습니다.

0-RTT 데이터 전송을 시도하는 클라이언트는 TLS 1.2 이하의 ServerHello를 수신하는 경우 연결에 실패해야 합니다. 그런 다음 비활성화된 0-RTT로 연결을 다시 시도할 수 있습니다. 다운그레이드 공격을 피하기 위해 클라이언트는 TLS 1.3을 비활성화하면 안 되며 0-RTT만 비활성화해야 합니다.\(MUST, SHOULD NOT\)

이 오류 조건을 피하기 위해 다중 서버 배포는 0-RTT를 활성화하기 전에 0-RTT 없이 TLS 1.3의 균일하고 안정적인 배포를 보장해야 합니다\(SHOULD\).\(SHOULD\)

---
### **D.4.  Middlebox Compatibility Mode**

현장 측정 \[Ben17a\] \[Ben17b\] \[Res17a\] \[Res17b\]는 TLS 클라이언트/서버 쌍이 TLS 1.3을 협상할 때 상당한 수의 미들박스가 오작동하는 것을 발견했습니다. 구현은 TLS 1.3 핸드셰이크를 TLS 1.2 핸드셰이크처럼 보이게 하여 미들박스를 통해 연결할 가능성을 높일 수 있습니다.

- 클라이언트는 섹션 4.1.2의 Legacy\_session\_id 섹션에 설명된 대로 항상 ClientHello에 비어 있지 않은 세션 ID를 제공합니다.

- 초기 데이터를 제공하지 않는 경우 클라이언트는 두 번째 비행 직전에 더미change\_cipher\_spec 기록\(섹션 5의 세 번째 단락 참조\)을 보냅니다. 이는 두 번째 ClientHello 이전이거나 암호화된 핸드셰이크 비행 이전일 수 있습니다. 초기 데이터를 제공하는 경우 첫 번째 ClientHello 바로 뒤에 레코드가 배치됩니다.

- 서버는 첫 번째 핸드셰이크 메시지 직후 더미change\_cipher\_spec 레코드를 보냅니다. 이는 ServerHello 또는 HelloRetryRequest 이후일 수 있습니다.

이러한 변경 사항을 종합하면 TLS 1.3 핸드셰이크가 TLS 1.2 세션 재개와 유사해 미들박스를 통해 성공적으로 연결할 가능성이 높아집니다. 이 "호환성 모드"는 부분적으로 협상됩니다. 클라이언트는 세션 ID 제공 여부를 선택할 수 있으며 서버는 이를 반영해야 합니다. 어느 쪽이든 보낼 수 있습니다

change\_cipher\_spec은 피어에서 무시해야 하므로 핸드셰이크 중 언제든지 change\_cipher\_spec을 무시해야 하지만 클라이언트가 비어 있지 않은 세션 ID를 보내는 경우 서버는 이 부록에 설명된 대로 change\_cipher\_spec을 보내야 합니다.\(MUST\)

---
### **D.5.  Security Restrictions Related to Backward Compatibility**

이전 버전의 TLS 사용을 협상하는 구현은 가능한 경우 순방향 비밀 및 AEAD 암호 제품군을 선호해야 합니다\(SHOULD\).\(SHOULD\)

RC4 암호 그룹의 보안은 \[RFC7465\]에 인용된 이유로 불충분한 것으로 간주됩니다. 구현은 어떤 이유로든 TLS의 모든 버전에 대해 RC4 암호화 제품군을 제안하거나 협상해서는 안 됩니다\(MUST NOT\).\(MUST NOT\)

이전 버전의 TLS에서는 강도가 매우 낮은 암호를 사용할 수 있었습니다. 강도가 112비트 미만인 암호는 어떤 이유로든 TLS의 모든 버전에 대해 제공되거나 협상되어서는 안 됩니다\(MUST NOT\).\(MUST NOT\)

SSL 3.0 \[RFC6101\]의 보안은 \[RFC7568\]에 열거된 이유로 불충분한 것으로 간주되며 어떤 이유로든 협상해서는 안 됩니다.\(MUST NOT\)

SSL 2.0\[SSL2\]의 보안은 \[RFC6176\]에 열거된 이유로 불충분한 것으로 간주되며 어떤 이유로든 협상해서는 안 됩니다.\(MUST NOT\)

구현은 SSL 버전 2.0 호환 CLIENT-HELLO를 보내면 안 됩니다\(MUST NOT\). 구현은 SSL 버전 2.0 호환 CLIENT-HELLO를 사용하여 TLS 1.3 이상을 협상하면 안 됩니다\(MUST NOT\). 이전 버전의 TLS를 협상하기 위해 SSL 버전 2.0 호환 CLIENT-HELLO를 수락하도록 구현을 권장하지 않습니다.\(MUST NOT, MUST NOT, SHOULD NOT\)

구현은 0x0300 이하로 설정된 ClientHello.legacy\_version 또는 ServerHello.legacy\_version을 보내면 안 됩니다\(MUST NOT\). ClientHello.legacy\_version 또는 ServerHello.legacy\_version이 0x0300으로 설정된 Hello 메시지를 수신하는 엔드포인트는 "protocol\_version" 경고와 함께 핸드셰이크를 중단해야 합니다.\(MUST NOT, MUST\)

구현은 버전이 0x0300 미만인 레코드를 보내면 안 됩니다\(MUST NOT\). 구현은 버전이 0x0300 미만인 레코드를 허용하면 안 됩니다\(하지만 레코드 버전 번호가 완전히 무시되는 경우 실수로 그렇게 할 수 있음\).\(MUST NOT, SHOULD NOT\)

구현은 AEAD 알고리즘에 적용할 수 없고 일부 시나리오에서 안전하지 않은 것으로 나타났기 때문에 \[RFC6066\]의 섹션 7에 정의된 잘린 HMAC 확장을 사용하면 안 됩니다\(MUST NOT\).\(MUST NOT\)

---
# **Appendix E.  Overview of Security Properties**

TLS의 완전한 보안 분석은 이 문서의 범위를 벗어납니다. 이 부록에서는 원하는 속성에 대한 비공식적 설명과 보다 공식적인 정의를 제공하는 연구 문헌의 보다 자세한 작업에 대한 참조를 제공합니다.

레코드 레이어의 속성과 별도로 핸드셰이크의 속성을 다룹니다.

---
### **E.1.  Handshake**

TLS 핸드셰이크는 단방향 인증\(서버 전용\) 및 상호 인증\(클라이언트 및 서버\) 기능을 모두 제공하기 위한 AKE\(Authenticated Key Exchange\) 프로토콜입니다. 핸드셰이크가 완료되면 각 측에서 다음 값의 보기를 출력합니다.

- 작업 키 세트를 파생할 수 있는 "세션 키" 세트\(마스터 비밀에서 파생된 다양한 비밀\).

- 암호화 매개변수 세트\(알고리즘 등\).

- 통신 당사자의 신원.

우리는 공격자가 활성 네트워크 공격자라고 가정합니다. 즉, 당사자 간 통신에 사용되는 네트워크를 완전히 제어할 수 있습니다\[RFC3552\]. 이러한 조건에서도 핸드셰이크는 아래 나열된 속성을 제공해야 합니다. 이러한 속성은 반드시 독립적일 필요는 없지만 프로토콜 소비자의 요구를 반영합니다.

동일한 세션 키 설정: 핸드셰이크는 각 엔드포인트에서 성공적으로 완료되는 경우 핸드셰이크 양쪽에서 동일한 세션 키 집합을 출력해야 합니다\(\[CK01\], 정의 1, 파트 1 참조\).

세션 키의 비밀성: 공유 세션 키는 공격자가 아닌 통신 당사자에게만 알려야 합니다\(\[CK01\], 정의 1, 파트 2 참조\). 일방적으로 인증된 연결에서 공격자는 서버와 자신의 세션 키를 설정할 수 있지만 이러한 세션 키는 클라이언트가 설정한 것과는 다릅니다.

피어 인증: 클라이언트의 피어 ID 보기는 서버의 ID를 반영해야 합니다. 클라이언트가 인증되면 서버의 피어 ID 보기가 클라이언트의 ID와 일치해야 합니다.

세션 키의 고유성: 두 개의 서로 다른 핸드셰이크는 별개의 관련 없는 세션 키를 생성해야 합니다. 핸드셰이크에 의해 생성된 개별 세션 키도 고유하고 독립적이어야 합니다.

다운그레이드 보호: 암호화 매개변수는 양쪽에서 동일해야 하며 피어가 공격이 없을 때 통신한 것과 동일해야 합니다\(\[BBFGKZ16\], 정의 8 및 9 참조\).

장기 키 관련 순방향 비밀: 장기 키 자료\(이 경우 인증서 기반 인증 모드의 서명 키 또는 \(EC\)DHE 모드가 있는 PSK의 외부/재개 PSK\)가 핸드셰이크 후 손상된 경우 완료되면 세션 키 자체가 삭제되는 한 세션 키의 보안이 손상되지 않습니다\(\[DOW92\] 참조\). "psk\_ke" PskKeyExchangeMode에서 PSK를 사용하는 경우 순방향 비밀성 속성이 충족되지 않습니다.

KCI\(Key Compromise Impersonation\) 저항: 인증서를 사용하여 상호 인증된 연결에서 한 행위자의 장기 비밀을 침해하더라도 주어진 연결에서 해당 행위자의 피어 인증이 중단되지 않아야 합니다\(\[HGFS15\] 참조\). 예를 들어 클라이언트의 서명 키가 손상된 경우 후속 핸드셰이크에서 임의의 서버를 해당 클라이언트로 가장할 수 없어야 합니다.

엔드포인트 ID 보호: 서버의 ID\(인증서\)는 수동적 공격자로부터 보호되어야 합니다. 클라이언트의 신원은 수동 및 능동 공격자 모두로부터 보호되어야 합니다.

비공식적으로 TLS 1.3의 서명 기반 모드는 \(EC\)DHE 키 교환에 의해 설정되고 핸드셰이크 트랜스크립트를 통해 서버의 서명으로 인증되고 서버의 ID에 연결된 고유한 비밀 공유 키의 설정을 제공합니다. MAC에 의해. 클라이언트가 인증서로 인증된 경우 핸드셰이크 기록에도 서명하고 두 ID에 연결된 MAC을 제공합니다. \[SIGMA\]는 이러한 유형의 키 교환 프로토콜의 설계 및 분석을 설명합니다. 새 \(EC\)DHE 키가 각 연결에 사용되는 경우 출력 키는 순방향 비밀입니다.

외부 PSK 및 재개 PSK는 장기 공유 비밀에서 고유한 연결별 단기 세션 키 세트로 부트스트랩됩니다. 이 비밀은 이전 핸드셰이크에서 설정되었을 수 있습니다. \(EC\)DHE 키 설정이 있는 PSK가 사용되는 경우 이러한 세션 키도 순방향 비밀이 됩니다. 재개 PSK는 연결 N에 의해 ​​계산되고 연결 N+1을 형성하는 데 필요한 재개 마스터 비밀이 다음에서 사용되는 트래픽 키와 분리되도록 설계되었습니다.

따라서 연결 사이에 순방향 비밀성을 제공합니다. 또한 동일한 연결에 여러 티켓이 설정되면 서로 다른 키와 연결되므로 하나의 티켓과 연결된 PSK가 손상되더라도 다른 티켓과 연결된 PSK로 설정된 연결이 손상되지 않습니다. 이 속성은 티켓이 자체 암호화된 경우가 아니라 데이터베이스에 저장된 경우\(그래서 삭제할 수 있음\) 가장 흥미롭습니다.

PSK 바인더 값은 PSK와 현재 핸드셰이크 간의 바인딩은 물론 PSK가 설정된 세션과 현재 세션 간의 바인딩을 형성합니다. 이 바인딩에는 원본 핸드셰이크 기록이 전이적으로 포함됩니다. 해당 기록이 재개 마스터 암호를 생성하는 값으로 소화되기 때문입니다. 이를 위해서는 재개 마스터 비밀을 생성하는 데 사용되는 KDF와 바인더를 계산하는 데 사용되는 MAC 모두 충돌 방지 기능이 있어야 합니다. 이에 대한 자세한 내용은 부록 E.1.1을 참조하십시오. 참고: 다른 PSK의 바인더 값은 Finished MAC에 포함되어 있지만 바인더는 포함하지 않습니다.

TLS는 현재 서버가 비인증서 기반 핸드셰이크\(예: PSK\)에서 certificate\_request 메시지를 보내는 것을 허용하지 않습니다. 이 제한이 나중에 완화되면 클라이언트의 서명은 서버의 인증서를 직접 포함하지 않습니다. 그러나 PSK가 NewSessionTicket을 통해 설정된 경우 클라이언트의 서명은 전이적으로 PSK 바인더를 통해 서버의 인증서를 포함합니다. \[PSK-FINISHED\]는 서버의 인증서에 바인딩되지 않는 구성에 대한 구체적인 공격을 설명합니다\(\[Kraw16\] 참조\). 클라이언트가 잠재적으로 두 개의 다른 끝점과 동일한 PSK/키-id 쌍을 공유할 수 있는 경우 인증서 기반 클라이언트 인증을 사용하는 것은 안전하지 않습니다. 구현은 일부 확장에 의해 협상되지 않는 한 클라이언트 또는 서버의 인증서 기반 인증과 외부 PSK를 결합해서는 안 됩니다\(MUST NOT\).\(MUST NOT\)

내보내기를 사용하면 고유하고 비밀스러운 값을 생성합니다\(고유한 세션 키에서 생성되기 때문\). 서로 다른 레이블 및 컨텍스트로 계산된 내보내기는 계산적으로 독립적이므로 서로 계산하거나 내보낸 값에서 세션 암호를 계산하는 것은 불가능합니다. 참고: 내보내기는 임의 길이 값을 생성할 수 있습니다. 내보내기가 채널 바인딩으로 사용되는 경우 내보낸 값은 충돌 저항을 제공할 만큼 충분히 커야 합니다. TLS 1.3에서 제공하는 내보내기는 각각 초기 트래픽 키와 애플리케이션 트래픽 키와 동일한 Handshake Context에서 파생되므로 유사한 보안 속성을 갖습니다. 여기에는 클라이언트의 인증서가 포함되어 있지 않습니다. 클라이언트의 인증서에 바인딩하려는 향후 응용 프로그램은 전체 핸드셰이크 기록을 포함하는 새 내보내기를 정의해야 할 수 있습니다.\(MUST\)

모든 핸드셰이크 모드에서 Finished MAC\(및 서명이 있는 경우\)은 다운그레이드 공격을 방지합니다. 또한 섹션 4.1.3에 설명된 대로 임의 논스의 특정 바이트를 사용하면 이전 TLS 버전으로의 다운그레이드를 감지할 수 있습니다. TLS 1.3 및 다운그레이드에 대한 자세한 내용은 \[BBFGKZ16\]을 참조하세요.

클라이언트와 서버가 공유 키를 설정하기에 충분한 정보를 교환하자마자 핸드셰이크의 나머지 부분이 암호화되므로 계산된 공유 키가 인증되지 않은 경우에도 수동적 공격자로부터 보호할 수 있습니다. 서버가 클라이언트보다 먼저 인증하기 때문에 클라이언트는 서버에 인증하는 경우 인증된 서버에만 자신의 ID를 공개하도록 보장할 수 있습니다. 길이로 인해 ID에 대한 정보가 누출되지 않도록 구현 시 핸드셰이크 중에 제공된 레코드 패딩 메커니즘을 사용해야 합니다. 클라이언트가 제안한 PSK ID는 암호화되지 않으며 서버가 선택한 것도 암호화되지 않습니다.

---
#### **E.1.1.  Key Derivation and HKDF**

TLS 1.3의 키 파생은 \[RFC5869\]에 정의된 HKDF와 두 구성 요소인 HKDF-Extract 및 HKDF-Expand를 사용합니다. HKDF 구성에 대한 전체 근거는 \[Kraw10\]에서, TLS 1.3에서 사용되는 방식에 대한 근거는 \[KW16\]에서 찾을 수 있습니다. 이 문서 전체에서 HKDF-Extract의 각 적용 뒤에는 HKDF-Expand가 한 번 이상 호출됩니다. 이 순서는 항상 따라야 합니다\(이 문서의 향후 개정 포함\). 특히, 중간에 HKDF-Expand 없이 HKDF-Extract의 다른 응용 프로그램에 대한 입력으로 HKDF-Extract의 출력을 사용해서는 안 됩니다\(SHOULD NOT\). 동일한 입력 중 일부에 대한 HKDF-Expand의 여러 적용은 키 및/또는 레이블을 통해 구별되는 한 허용됩니다.\(SHOULD NOT\)

HKDF-Expand는 가변 길이의 입력과 출력이 모두 포함된 유사 난수 함수\(PRF\)를 구현합니다. 이 문서에서 HKDF의 일부 사용\(예: 내보내기 및 resumption\_master\_secret 생성\)에서 HKDF-Expand의 적용은 충돌 방지가 필요합니다. 즉, 동일한 값을 출력하는 HKDF-Expand에 대한 두 개의 다른 입력을 찾는 것이 불가능해야 합니다. 이를 위해서는 기본 해시 함수가 충돌에 강하고 HKDF-Expand의 출력 길이가 최소 256비트\(또는 해시 함수가 충돌을 방지하는 데 필요한 만큼\)의 크기여야 합니다.

---
#### **E.1.2.  Client Authentication**

핸드셰이크 도중 또는 핸드셰이크 후 인증에서 서버에 인증 데이터를 보낸 클라이언트는 나중에 서버가 클라이언트를 인증된 것으로 간주하는지 여부를 확신할 수 없습니다. 서버가 연결을 일방적 또는 상호 인증으로 간주하는지 여부를 클라이언트가 결정해야 하는 경우 애플리케이션 계층에서 제공해야 합니다. 자세한 내용은 \[CHHSV17\]을 참조하십시오. 또한 \[Kraw16\]의 post-handshake 인증 분석 결과 post-handshake 단계에서 보낸 인증서로 식별되는 클라이언트가 트래픽 키를 소유하고 있음을 알 수 있습니다. 따라서 이 당사자는 원래 핸드셰이크에 참여한 클라이언트이거나 원래 클라이언트가 트래픽 키를 위임한 클라이언트입니다\(트래픽 키가 손상되지 않았다고 가정\).

---
#### **E.1.3.  0-RTT**

0-RTT 작동 모드는 일반적으로 1-RTT 데이터와 유사한 보안 속성을 제공합니다. 단, 0-RTT 암호화 키는 전체 순방향 비밀성을 제공하지 않으며 서버는 핸드셰이크의 고유성을 보장할 수 없습니다. \(재생 불가능\) 잠재적으로 과도한 양의 상태를 유지하지 않고. 재생에 대한 노출을 제한하는 메커니즘에 대해서는 섹션 8을 참조하십시오.

---
#### **E.1.4.  Exporter Independence**

exporter\_master\_secret 및 early\_exporter\_master\_secret은 트래픽 키와 독립적으로 파생되므로 해당 키로 암호화된 트래픽의 보안에 위협이 되지 않습니다. 그러나 이러한 비밀은 모든 내보내기 값을 계산하는 데 사용될 수 있으므로 가능한 한 빨리 지워야 합니다. 내보내기 레이블의 총 집합이 알려진 경우 구현은 모든 해당 레이블에 대한 내보내기 계산의 내부 Derive-Secret 단계를 미리 계산한 다음 \[early\_\]exporter\_master\_secret을 지우고 각 내부 값이 알려진 즉시 따라야 합니다\(SHOULD\). 다시는 필요하지 않을 것입니다.\(SHOULD, SHOULD\)

---
#### **E.1.5.  Post-Compromise Security**

TLS는 피어의 장기 비밀\(서명 키 또는 외부 PSK\)이 손상된 후에 발생하는 핸드셰이크에 대한 보안을 제공하지 않습니다. 따라서 때때로 역방향 또는 미래 비밀성이라고도 하는 타협 후 보안\[CCG16\]을 제공하지 않습니다. 이것은 당사자가 자신의 장기 비밀이 손상된 후 보유하는 보안 보장을 설명하는 KCI 저항과 대조됩니다.

---
#### **E.1.6.  External References**

독자는 TLS 핸드셰이크 분석을 위해 다음 참조를 참조해야 합니다. \].

---
### **E.2.  Record Layer**

레코드 레이어는 양방향 암호화 키 및 nonce를 파생하는 데 사용할 수 있는 강력한 트래픽 비밀을 생성하는 핸드셰이크에 따라 달라집니다. 이것이 사실이고 키가 섹션 5.5에 표시된 것보다 더 이상 데이터에 사용되지 않는다고 가정하면 레코드 레이어는 다음을 보장해야 합니다.

기밀성: 공격자는 주어진 레코드의 일반 텍스트 내용을 확인할 수 없어야 합니다.

무결성: 공격자는 수신자가 수락할 기존 레코드와 다른 새 레코드를 만들 수 없어야 합니다.

순서 보호/재생 불가: 공격자는 수신자가 이미 승인한 레코드를 승인하도록 하거나 수신자가 레코드 N을 먼저 처리하지 않고 레코드 N+1을 승인하도록 할 수 없어야 합니다.

길이 은폐: 주어진 외부 길이가 있는 레코드가 주어지면 공격자는 콘텐츠 대 패딩인 레코드의 양을 결정할 수 없어야 합니다.

키 변경 후 순방향 보안: 섹션 4.6.3에 설명된 트래픽 키 업데이트 메커니즘이 사용되고 이전 세대 키가 삭제된 경우 엔드포인트를 손상시키는 공격자는 이전 키로 암호화된 트래픽을 해독할 수 없어야 합니다.

비공식적으로 TLS 1.3은 강력한 키로 일반 텍스트를 AEAD로 보호하여 이러한 속성을 제공합니다. AEAD 암호화\[RFC5116\]는 데이터에 대한 기밀성과 무결성을 제공합니다. 재생 불가능성은 각 레코드에 대해 별도의 논스를 사용하여 제공되며, 논스는 레코드 시퀀스 번호\(섹션 5.3\)에서 파생되고 시퀀스 번호는 양쪽에서 독립적으로 유지됩니다. 따라서 잘못된 순서로 전달된 레코드는 AEAD 보호 해제 실패를 초래합니다. 동일한 평문이 동일한 키로 다른 사용자에 의해 반복적으로 암호화될 때 대량 암호 해독을 방지하기 위해\(일반적으로 HTTP의 경우와 같이\) 혼합하여 nonce를 형성합니다.

트래픽 키와 함께 파생된 비밀 연결별 초기화 벡터가 있는 시퀀스 번호. 이 구성에 대한 분석은 \[BT16\]을 참조하십시오.

TLS 1.3의 키 재생성 기술\(섹션 7.2 참조\)은 \[REKEY\]에서 설명한 대로 직렬 생성기의 구성을 따르며, 키를 재생하면 키를 재생하지 않는 경우보다 더 많은 암호화에 키를 사용할 수 있음을 보여줍니다. 이는 HKDF-Expand-Label 함수의 PRF\(pseudorandom function\)로서의 보안에 의존합니다. 또한 이 기능이 진정한 단방향인 한 키 변경 이전부터 트래픽 키를 계산할 수 없습니다\(순방향 비밀성\).

TLS는 해당 연결의 트래픽 암호가 손상된 후 연결에서 전달되는 데이터에 대한 보안을 제공하지 않습니다. 즉, TLS는 트래픽 비밀에 대해 사후 보안/미래 보안/역방향 보안을 제공하지 않습니다. 실제로 트래픽 비밀을 알게 된 공격자는 해당 연결에서 미래의 모든 트래픽 비밀을 계산할 수 있습니다. 이러한 보장을 원하는 시스템은 새로운 핸드셰이크를 수행하고 \(EC\)DHE 교환과 새로운 연결을 설정해야 합니다.

---
#### **E.2.1.  External References**

독자는 TLS 레코드 계층의 분석을 위해 다음 참조를 참조해야 합니다: \[BMMRT15\], \[BT16\], \[BDFKPPRSZZ16\], \[BBK17\] 및 \[PS18\].

---
### **E.3.  Traffic Analysis**

TLS는 암호화된 패킷의 길이와 타이밍 관찰을 기반으로 하는 다양한 트래픽 분석 공격에 취약합니다\[CLINIC\] \[HCJC16\]. 이는 고정된 콘텐츠 코퍼스를 호스팅하는 비디오 서버와 같이 구별할 수 있는 작은 메시지 세트가 있을 때 특히 쉽지만 더 복잡한 시나리오에서도 여전히 유용한 정보를 제공합니다.

TLS는 이러한 형태의 공격에 대한 특정 방어를 제공하지 않지만 응용 프로그램에서 사용하기 위한 패딩 메커니즘을 포함합니다. AEAD 기능으로 보호되는 일반 텍스트는 콘텐츠와 응용 프로그램이 임의 길이의 암호화된 레코드를 생성할 수 있는 가변 길이 패딩으로 구성됩니다. 뿐만 아니라 전송 기간과 묵음 기간 사이의 차이를 숨기기 위해 패딩 전용 커버 트래픽을 포함합니다. 패딩은 실제 콘텐츠와 함께 암호화되기 때문에 공격자는 패딩의 길이를 직접 결정할 수 없지만 레코드 처리 중에 노출된 타이밍 채널을 사용하여 간접적으로 패딩 길이를 측정할 수 있습니다\(즉, 레코드를 처리하는 데 걸리는 시간 확인\). 또는 보기 위해 기록에 조금씩

서버에서 응답을 이끌어내는 것\). 일반적으로 이러한 채널을 모두 제거하는 방법은 알려져 있지 않습니다. 일정한 시간의 패딩 제거 기능도 콘텐츠를 데이터 종속 기능에 공급할 가능성이 높기 때문입니다. 최소한 완전히 일정한 시간 서버 또는 클라이언트는 상위 수준 프로토콜을 일정한 시간으로 만드는 것을 포함하여 애플리케이션 계층 프로토콜 구현과 긴밀한 협력이 필요합니다.

참고: 강력한 트래픽 분석 방어는 패킷 전송 지연 및 트래픽 볼륨 증가로 인해 성능 저하로 이어질 수 있습니다.

---
### **E.4.  Side-Channel Attacks**

일반적으로 TLS에는 사이드 채널 공격\(즉, 타이밍과 같은 보조 채널을 통해 통신을 공격하는 공격\)에 대한 특정 방어 기능이 없으므로 관련 암호화 기본 요소의 구현에 맡깁니다. 그러나 TLS의 특정 기능은 사이드 채널 방지 코드를 더 쉽게 작성할 수 있도록 설계되었습니다.

- 복합 MAC 후 암호화 구조를 사용한 이전 버전의 TLS와 달리 TLS 1.3은 AEAD 알고리즘만 사용하므로 구현에서는 해당 기본 요소의 자체 포함 상수 시간 구현을 사용할 수 있습니다.

- TLS는 모든 암호 해독 오류에 대해 균일한 "bad\_record\_mac" 경고를 사용합니다. 이는 공격자가 메시지 부분에 대한 부분적인 통찰력을 얻는 것을 방지하기 위한 것입니다. 이러한 오류에 대한 연결을 종료하면 추가 저항이 제공됩니다. 새로운 연결에는 다양한 암호화 자료가 포함되어 여러 번의 시도가 필요한 암호화 기본 요소에 대한 공격을 방지합니다.

사이드 채널을 통한 정보 유출은 응용 프로그램 프로토콜 및 이를 사용하는 응용 프로그램에서 TLS 위의 계층에서 발생할 수 있습니다. 사이드 채널 공격에 대한 저항은 응용 프로그램 및 응용 프로그램 프로토콜에 따라 별도로 기밀 정보가 실수로 유출되지 않도록 보장합니다.

---
### **E.5.  Replay Attacks on 0-RTT**

재생 가능한 0-RTT 데이터는 해당 응용 프로그램이 재생 시 안전하도록 특별히 설계되지 않는 한 TLS를 사용하는 응용 프로그램에 여러 가지 보안 위협을 제공합니다\(최소한 이것은 멱등성을 의미하지만 많은 경우 상수 시간 응답\). 잠재적인 공격에는 다음이 포함됩니다.

- 아이템 구매, 송금 등 부작용을 일으키는 행위를 중복하여 사이트 또는 이용자에게 피해를 주는 행위

- 공격자는 다른 메시지와 관련하여 순서를 변경하기 위해 0-RTT 메시지를 저장하고 재생할 수 있습니다\(예: 삭제를 생성 후로 이동\).

- 캐시 타이밍 동작을 활용하여 0-RTT 메시지를 다른 캐시 노드에 재생한 다음 별도의 연결을 사용하여 요청 대기 시간을 측정하고 두 요청이 동일한 리소스를 처리하는지 확인함으로써 0-RTT 메시지의 내용을 검색합니다.

데이터를 여러 번 재생할 수 있는 경우 암호화 작업 속도를 반복 측정하는 것과 같은 추가 공격이 가능합니다. 또한 속도 제한 시스템에 과부하가 걸릴 수 있습니다. 이러한 공격에 대한 자세한 설명은 \[Mac17\]을 참조하십시오.

궁극적으로 서버는 0-RTT 데이터 복제를 사용하는 공격으로부터 스스로를 보호할 책임이 있습니다. 섹션 8에 설명된 메커니즘은 TLS 계층에서 재생을 방지하기 위한 것이지만 클라이언트 데이터의 여러 복사본 수신에 대해 완전한 보호를 제공하지는 않습니다. 예를 들어 서버가 상태를 공유하지 않는 다른 클러스터에 있거나 섹션 8.1에 설명된 대로 티켓이 삭제되었기 때문에 서버에 클라이언트에 대한 정보가 없을 때 TLS 1.3은 1-RTT 핸드셰이크로 대체됩니다. 응용 프로그램 계층 프로토콜이 이 설정에서 데이터를 재전송하는 경우 공격자는 ClientHello를 원래 클러스터\(데이터를 즉시 처리\)와 1-RTT로 폴백할 다른 클러스터 모두에 전송하여 메시지 복제를 유도할 수 있습니다. 응용 프로그램 계층 재생 시 데이터를 처리합니다. 이 공격의 규모는 트랜잭션을 재시도하려는 클라이언트의 의지에 따라 제한되므로 제한된 양의 복제만 허용되며 각 복사본은 서버에서 새로운 연결로 나타납니다.

올바르게 구현된 경우 섹션 8.1 및 8.2에 설명된 메커니즘은 재생된 ClientHello 및 관련 0-RTT 데이터가 일관된 상태의 클러스터에서 여러 번 수락되는 것을 방지합니다. 단일 티켓에 대해 하나의 클러스터로 0-RTT 사용을 제한하는 서버의 경우 지정된 ClientHello 및 관련 0-RTT 데이터는 한 번만 허용됩니다. 그러나 상태가 완전히 일치하지 않는 경우 공격자는 복제 기간 동안 여러 데이터 복사본을 허용할 수 있습니다. 클라이언트는 서버 동작의 정확한 세부 사항을 알지 못하기 때문에 재생하기에 안전하지 않고 여러 1-RTT 연결을 통해 재시도하지 않으려는 메시지를 초기 데이터로 보내면 안 됩니다\(MUST NOT\).\(MUST NOT\)

애플리케이션 프로토콜은 용도를 정의하는 프로필 없이 0-RTT 데이터를 사용해서는 안 됩니다\(MUST NOT\). 해당 프로필은 0-RTT와 함께 사용하기에 안전한 메시지 또는 상호 작용과 서버가 0-RTT를 거부하고 1-RTT로 폴백할 때 상황을 처리하는 방법을 식별해야 합니다.\(MUST NOT\)

또한 우발적인 오용을 방지하기 위해 TLS 구현은 애플리케이션에서 특별히 요청하지 않는 한 0-RTT\(전송 또는 수락\)를 활성화해서는 안 되며\(MUST NOT\) 애플리케이션에서 지시하지 않는 한 서버에서 거부된 경우 0-RTT 데이터를 자동으로 재전송해서는 안 됩니다\(MUST NOT\). 서버 측 응용 프로그램은 일부 종류의 응용 프로그램 트래픽에 대해 0-RTT 데이터에 대한 특수 처리를 구현하고자 할 수 있습니다\(예: 연결 중단, 응용 프로그램 계층에서 데이터 재전송 요청 또는 핸드셰이크가 완료될 때까지 처리 지연\). 애플리케이션이 이러한 종류의 처리를 구현하도록 허용하기 위해 TLS 구현은 애플리케이션이 핸드셰이크가 완료되었는지 확인할 수 있는 방법을 제공해야 합니다.\(MUST NOT, MUST\)

---
#### **E.5.1.  Replay and Exporters**

ClientHello의 재생은 동일한 초기 내보내기를 생성하므로 이러한 내보내기를 사용하는 애플리케이션에서 추가적인 주의가 필요합니다. 특히 이러한 내보내기가 인증 채널 바인딩으로 사용되는 경우\(예: 내보내기의 출력에 서명하여\) PSK를 손상시키는 공격자는 인증 키를 손상시키지 않고 연결 간에 인증자를 이식할 수 있습니다.

또한 서버에서 클라이언트로의 암호화 키를 생성하는 데 초기 내보내기를 사용하면 해당 키의 재사용이 수반될 수 있으므로 사용해서는 안 됩니다\(SHOULD NOT\). 이는 클라이언트에서 서버 방향으로만 초기 애플리케이션 트래픽 키를 사용하는 것과 유사합니다.\(SHOULD NOT\)

---
### **E.6.  PSK Identity Exposure**

구현은 핸드셰이크를 중단하여 잘못된 PSK 바인더에 응답하므로 공격자가 지정된 PSK ID가 유효한지 여부를 확인할 수 있습니다. 특히 서버가 외부 PSK 핸드셰이크와 인증서 기반 핸드셰이크를 모두 수락하는 경우 유효한 PSK ID는 핸드셰이크에 실패하는 반면 잘못된 ID는 건너뛰고 인증서 핸드셰이크에 성공합니다. PSK 핸드셰이크만 지원하는 서버는 유효한 PSK ID가 없는 경우와 ID는 있지만 잘못된 바인더가 있는 경우를 동일하게 처리하여 이러한 형태의 공격에 저항할 수 있습니다.

---
### **E.7.  Sharing PSKs**

TLS 1.3은 PSK를 특정 KDF에 바인딩하여 PSK에 대한 보수적인 접근 방식을 취합니다. 반대로 TLS 1.2에서는 PSK를 모든 해시 함수 및 TLS 1.2 PRF와 함께 사용할 수 있습니다. 따라서 TLS 1.2 및 TLS 1.3 모두와 함께 사용되는 모든 PSK는 TLS 1.3에서 하나의 해시만 사용해야 하며 이는 사용자가 단일 PSK를 프로비저닝하려는 경우 최적이 아닙니다. TLS 1.2와 TLS 1.3의 구조는 서로 다르지만 둘 다 HMAC를 기반으로 합니다. 동일한 PSK가 두 버전에서 관련 출력을 생성할 수 있는 알려진 방법은 없지만 제한된 분석만 수행되었습니다. 구현은 TLS 1.3과 TLS 1.2 사이에서 PSK를 재사용하지 않음으로써 교차 프로토콜 관련 출력으로부터 안전을 보장할 수 있습니다.

---
### **E.8.  Attacks on Static RSA**

TLS 1.3은 RSA 키 전송을 사용하지 않으므로 Bleichenbacher 유형의 공격\[Blei98\]에 직접적으로 취약하지 않지만 TLS 1.3 서버가 이전 버전의 TLS 컨텍스트에서 정적 RSA도 지원하는 경우 서버를 가장할 수 있습니다. TLS 1.3 연결용\[JSS15\]. TLS 1.3 구현은 TLS의 모든 버전에서 정적 RSA에 대한 지원을 비활성화하여 이 공격을 방지할 수 있습니다. 원칙적으로 구현은 정적 RSA 암호 해독 및 RSA 서명을 위해 서로 다른 keyUsage 비트를 사용하여 인증서를 분리할 수도 있지만 이 기술은 digitalSignature 비트가 설정되지 않은 인증서의 키를 사용하여 서명 수락을 거부하는 클라이언트에 의존하며 많은 클라이언트가 이 제한을 시행하지 마십시오.

---
# **Contributors**

Martin Abadi University of California, Santa Cruz abadi@cs.ucsc.edu

Christopher Allen\(TLS 1.0의 공동 편집자\) Alacrity Ventures ChristopherA@AlacrityManagement.com

```text
   Richard Barnes
   Cisco
   rlb@ipv.sx

   Steven M. Bellovin
   Columbia University
   smb@cs.columbia.edu

   David Benjamin
   Google
   davidben@google.com

   Benjamin Beurdouche
   INRIA & Microsoft Research
   benjamin.beurdouche@ens.fr
```

Karthikeyan Bhargavan\(\[RFC7627\]의 편집자\) INRIA karthikeyan.bhargavan@inria.fr

Simon Blake-Wilson\(\[RFC4492\]의 공동 저자\) BCI sblakewilson@bcisse.com

Nelson Bolyard\(\[RFC4492\]의 공동 저자\) Sun Microsystems, Inc. nelson@bolyard.com

```text
   Ran Canetti
   IBM
   canetti@watson.ibm.com

   Matt Caswell
   OpenSSL
   matt@openssl.org
```

Stephen Checkoway University of Illinois at Chicago sfc@uic.edu

```text
   Pete Chown
   Skygate Technology Ltd
   pc@skygate.co.uk
```

Katriel Cohn-Gordon University of Oxford me@katriel.co.uk

Cas Cremers 옥스퍼드 대학교 cas.cremers@cs.ox.ac.uk

Antoine Delignat-Lavaud\(\[RFC7627\]의 공동 저자\) INRIA antdl@microsoft.com

Tim Dierks\(TLS 1.0의 공동 저자, TLS 1.1 및 1.2의 공동 편집자\) 독립 tim@dierks.org

```text
   Roelof DuToit
   Symantec Corporation
   roelof_dutoit@symantec.com

   Taher Elgamal
   Securify
   taher@securify.com

   Pasi Eronen
   Nokia
   pasi.eronen@nokia.com

   Cedric Fournet
   Microsoft
   fournet@microsoft.com

   Anil Gangolli
   anil@busybuddha.org

   David M. Garrett
   dave@nulldereference.com

   Illya Gerasymchuk
   Independent
   illya@iluxonchik.me

   Alessandro Ghedini
   Cloudflare Inc.
   alessandro@cloudflare.com

   Daniel Kahn Gillmor
   ACLU
   dkg@fifthhorseman.net

   Matthew Green
   Johns Hopkins University
   mgreen@cs.jhu.edu

   Jens Guballa
   ETAS
   jens.guballa@etas.com

   Felix Guenther
   TU Darmstadt
   mail@felixguenther.info
```

Vipul Gupta\(\[RFC4492\]의 공동 저자\) Sun Microsystems Laboratories vipul.gupta@sun.com

Chris Hawk\(\[RFC4492\]의 공동 저자\) Corriente Networks LLC chris@corriente.net

```text
   Kipp Hickman

   Alfred Hoenes

   David Hopwood
   Independent Consultant
   david.hopwood@blueyonder.co.uk

   Marko Horvat
   MPI-SWS
   mhorvat@mpi-sws.org
```

Jonathan Hoyland Royal Holloway, 런던 대학교 jonathan.hoyland@gmail.com

```text
   Subodh Iyengar
   Facebook
   subodh@fb.com

   Benjamin Kaduk
   Akamai Technologies
   kaduk@mit.edu

   Hubert Kario
   Red Hat Inc.
   hkario@redhat.com
```

Phil Karlton\(SSL 3.0 공동 저자\)

```text
   Leon Klingele
   Independent
   mail@leonklingele.de
```

Paul Kocher\(SSL 3.0 공동 저자\) 암호화 연구 paul@cryptography.com

```text
   Hugo Krawczyk
   IBM
   hugokraw@us.ibm.com
```

Adam Langley\(\[RFC7627\]의 공동 저자\) Google agl@google.com

```text
   Olivier Levillain
   ANSSI
   olivier.levillain@ssi.gouv.fr
```

Chapel Hill에 있는 North Carolina의 Xiaoyin Liu 대학교 xiaoyin.l@outlook.com

```text
   Ilari Liusvaara
   Independent
   ilariliusvaara@welho.com

   Atul Luykx
   K.U. Leuven
   atul.luykx@kuleuven.be

   Colm MacCarthaigh
   Amazon Web Services
   colm@allcosts.net

   Carl Mehner
   USAA
   carl.mehner@usaa.com

   Jan Mikkelsen
   Transactionware
   janm@transactionware.com
```

Bodo Moeller\(\[RFC4492\]의 공동 저자\) Google bodo@acm.org

```text
   Kyle Nekritz
   Facebook
   knekritz@fb.com

   Erik Nygren
   Akamai Technologies
   erik+ietf@nygren.org

   Magnus Nystrom
   Microsoft
   mnystrom@microsoft.com

   Kazuho Oku
   DeNA Co., Ltd.
   kazuhooku@gmail.com
```

Kenny Paterson Royal Holloway, 런던 대학교 kenny.paterson@rhul.ac.uk

플로리다 크리스토퍼 패튼 대학교 cjpatton@ufl.edu

Alfredo Pironti\(\[RFC7627\]의 공동 저자\) INRIA alfredo.pironti@inria.fr

```text
   Andrei Popov
   Microsoft
   andrei.popov@microsoft.com
```

Marsh Ray\(\[RFC7627\]의 공동 저자\) Microsoft maray@microsoft.com

```text
   Robert Relyea
   Netscape Communications
   relyea@netscape.com

   Kyle Rose
   Akamai Technologies
   krose@krose.org

   Jim Roskind
   Amazon
   jroskind@amazon.com

   Michael Sabin

   Joe Salowey
   Tableau Software
   joe@salowey.net

   Rich Salz
   Akamai
   rsalz@akamai.com

   David Schinazi
   Apple Inc.
   dschinazi@apple.com
```

Sam Scott Royal Holloway, 런던 대학교 me@samjs.co.uk

Thomas Shrimpton University of Florida teshrim@ufl.edu

```text
   Dan Simon
   Microsoft, Inc.
   dansimon@microsoft.com

   Brian Smith
   Independent
   brian@briansmith.org

   Brian Sniffen
   Akamai Technologies
   ietf@bts.evenmere.org

   Nick Sullivan
   Cloudflare Inc.
   nick@cloudflare.com
```

Bjoern Tackmann University of California, San Diego btackmann@eng.ucsd.edu

```text
   Tim Taubert
   Mozilla
   ttaubert@mozilla.com

   Martin Thomson
   Mozilla
   mt@mozilla.com

   Hannes Tschofenig
   Arm Limited
   Hannes.Tschofenig@arm.com

   Sean Turner
   sn3rd
   sean@sn3rd.com

   Steven Valdez
   Google
   svaldez@google.com

   Filippo Valsorda
   Cloudflare Inc.
   filippo@cloudflare.com
```

Thyla van der Merwe Royal Holloway, 런던 대학교 tjvdmerwe@gmail.com

```text
   Victor Vasiliev
   Google
   vasilvv@google.com

   Hoeteck Wee
   Ecole Normale Superieure, Paris
   hoeteck@alum.mit.edu

   Tom Weinstein

   David Wong
   NCC Group
   david.wong@nccgroup.trust

   Christopher A. Wood
   Apple Inc.
   cawood@apple.com

   Tim Wright
   Vodafone
   timothy.wright@vodafone.com

   Peter Wu
   Independent
   peter@lekensteyn.nl

   Kazu Yamamoto
   Internet Initiative Japan Inc.
   kazu@iij.ad.jp
```

---
# **Author's Address**

```text
   Eric Rescorla
   Mozilla

   Email: ekr@rtfm.com
```


```text
Network Working Group                                         C. Hedrick
Request for Comments: 1058                            Rutgers University
                                                               June 1988

                      Routing Information Protocol
```

---
# **Status of this Memo**

이 RFC는 게이트웨이와 다른 호스트 간에 라우팅 정보를 교환하기 위한 기존 프로토콜을 설명합니다. 인터넷 커뮤니티에서 사용할 게이트웨이 소프트웨어를 개발하기 위한 기반으로 사용하기 위한 것입니다. 이 메모의 배포는 무제한입니다.

```text
                             Table of Contents
```

```text
   1. Introduction                                                     2
        1.1. Limitations of the protocol                               4
        1.2. Organization of this document                             4
   2. Distance Vector Algorithms                                       5
        2.1. Dealing with changes in topology                         11
        2.2. Preventing instability                                   12
             2.2.1. Split horizon                                     14
             2.2.2. Triggered updates                                 15
   3. Specifications for the protocol                                 16
        3.1. Message formats                                          18
        3.2. Addressing considerations                                20
        3.3. Timers                                                   23
        3.4. Input processing                                         24
             3.4.1. Request                                           25
             3.4.2. Response                                          26
        3.5. Output Processing                                        28
        3.6. Compatibility                                            31
   4. Control functions                                               31
```

---
# **Overview**

이 메모는 다음 작업을 수행하기 위한 것입니다.

- - 현재 라우팅에 널리 사용되지만 공식적으로 문서화된 적이 없는 프로토콜과 알고리즘을 문서화합니다.

- 알고리즘에 몇 가지 개선 사항을 지정합니다.

- 대규모 네트워크에서 경로의 안정성을 향상시킵니다. 이러한 개선으로 인해 기존 구현과의 비호환성은 발생하지 않습니다. 그들은 다음과 같이 통합될 예정입니다.

- 이 프로토콜의 모든 구현.

- 더 많은 것을 허용하기 위해 몇 가지 선택적 기능을 제안합니다.

- 구성 가능성 및 제어. 이러한 기능은 NSFnet 커뮤니티에서 실제로 사용되는 문제를 해결하기 위해 특별히 개발되었습니다. 그러나 보다 일반적인 유용성을 가져야 합니다.

여기에 설명된 RIP\(Routing Information Protocol\)는 4.3 Berkeley Software Distribution과 함께 배포되는 "routed" 프로그램을 대략적으로 기반으로 합니다. 그러나 동일한 프로토콜로 간주되는 여러 가지 다른 구현이 있습니다. 불행하게도 이러한 다양한 구현은 다양한 세부 사항에서 일치하지 않습니다. 여기의 사양은 다양한 구현에서 가져온 기능의 조합을 나타냅니다. 우리는 이 문서에 따라 설계된 프로그램이 라우팅 및 우리가 알고 있는 다른 모든 RIP 구현과 상호 운용될 것이라고 믿습니다.

이 설명은 메트릭을 증분해야 하는 시기에 대해 대부분의 기존 구현과 다른 관점을 채택합니다. 로컬 네트워크에 사용되는 메트릭을 해당 변경하여 다른 기존 구현과의 호환성을 유지했습니다. 이 문제에 대한 자세한 내용은 섹션 3.6을 참조하세요.

---
## **1. Introduction**

이 메모는 Bellman-Ford\(또는 거리 벡터\) 알고리즘을 기반으로 하는 일련의 라우팅 프로토콜 중 하나의 프로토콜을 설명합니다. 이 알고리즘은 ARPANET 초기부터 컴퓨터 네트워크의 라우팅 계산에 사용되었습니다. 여기에 설명된 특정 패킷 형식과 프로토콜은 Unix의 Berkeley 배포판에 포함된 "routed" 프로그램을 기반으로 합니다. 이는 게이트웨이와 호스트 간의 라우팅 정보 교환을 위한 사실상의 표준이 되었습니다. 이는 대부분의 상용 IP 게이트웨이 공급업체에서 이러한 목적으로 구현합니다. 그러나 이러한 공급업체 중 다수는 자체 게이트웨이에서 사용되는 자체 프로토콜을 보유하고 있습니다.

이 프로토콜은 "내부 게이트웨이 프로토콜"로 가장 유용합니다. 현재 인터넷과 같은 전국적인 네트워크에서는 단일 라우팅 프로토콜이 전체 네트워크에 사용될 가능성은 거의 없습니다. 오히려 네트워크는 "자율 시스템"의 집합체로 구성될 것입니다. 자율 시스템은 일반적으로 단일 엔터티에 의해 관리되거나 적어도 어느 정도 합리적인 수준의 기술 및 행정적 통제를 갖습니다. 각 자율 시스템에는 고유한 라우팅 기술이 있습니다. 이는 자율 시스템마다 다를 수 있습니다. 자율 시스템 내에서 사용되는 라우팅 프로토콜을 내부 게이트웨이 프로토콜 또는 "IGP"라고 합니다. 자율 노드 간 인터페이스에는 별도의 프로토콜이 사용됩니다.

시스템. 인터넷에서 여전히 사용되는 최초의 프로토콜은 "EGP"\(외부 게이트웨이 프로토콜\)입니다. 이러한 프로토콜은 이제 일반적으로 AS 간 라우팅 프로토콜이라고 합니다. RIP는 합리적으로 동질적인 기술을 사용하여 중간 규모의 네트워크에서 작동하도록 설계되었습니다. 따라서 속도가 크게 변하지 않는 직렬 회선을 사용하는 지역 네트워크와 많은 캠퍼스의 IGP로 적합합니다. 더 복잡한 환경에서는 사용할 수 없습니다. RIP가 적합할 것으로 예상되는 상황에 대한 자세한 내용은 Braden 및 Postel \[3\]을 참조하세요.

RIP는 "거리 벡터 알고리즘"으로 알려진 알고리즘 클래스 중 하나입니다. 저자에게 알려진 이러한 종류의 알고리즘에 대한 최초의 설명은 Ford와 Fulkerson \[6\]에 있습니다. 이 때문에 Ford-Fulkerson 알고리즘이라고도 합니다. Bellman-Ford라는 용어도 사용됩니다. 이는 공식이 "동적 프로그래밍"의 기초인 벨만 방정식을 기반으로 한다는 사실에서 비롯됩니다. \(이 영역에 대한 표준 소개는 \[1\]을 참조하십시오.\) 이 문서의 프레젠테이션은 \[2\]를 밀접하게 기반으로 합니다. 이 텍스트에는 라우팅 알고리즘의 수학에 대한 소개가 포함되어 있습니다. 여기에 제시된 알고리즘의 여러 변형과 기타 관련 알고리즘을 설명하고 정당화합니다. 이 프로토콜에 설명된 기본 알고리즘은 1969년 ARPANET에서 컴퓨터 라우팅에 사용되었습니다. 그러나 이 프로토콜의 특정 조상은 Xerox 네트워크 프로토콜 내에 있습니다. PUP 프로토콜\(\[4\] 참조\)은 라우팅 정보를 교환하기 위해 게이트웨이 정보 프로토콜을 사용했습니다. 이 프로토콜의 다소 업데이트된 버전이 XNS\(Xerox Network Systems\) 아키텍처에 Routing Information Protocol이라는 이름으로 채택되었습니다. \(\[7\] 참조\) Berkeley의 라우팅은 IP 및 기타 유형의 주소를 처리할 수 있는 보다 일반적인 주소 형식으로 XNS 주소가 대체되고 라우팅 업데이트가 30초마다 한 번으로 제한된다는 점에서 라우팅 정보 프로토콜과 거의 동일합니다. 이러한 유사성 때문에 라우팅 정보 프로토콜\(또는 간단히 RIP\)이라는 용어는 XNS 프로토콜과 라우팅에서 사용되는 프로토콜을 모두 지칭하는 데 사용됩니다.

RIP는 IP 기반 인터넷 내에서 사용하도록 고안되었습니다. 인터넷은 게이트웨이로 연결된 여러 네트워크로 구성됩니다. 네트워크는 지점 간 링크일 수도 있고 이더넷이나 ARPANET과 같은 더 복잡한 네트워크일 수도 있습니다. 호스트와 게이트웨이에는 일부 호스트로 주소가 지정된 IP 데이터그램이 제공됩니다. 라우팅은 호스트나 게이트웨이가 데이터그램을 보낼 위치를 결정하는 방법입니다. 대상이 호스트나 게이트웨이에 직접 연결된 네트워크 중 하나에 있는 경우 대상으로 직접 데이터그램을 보낼 수 있습니다. 그러나 흥미로운 경우는 목적지에 직접 도달할 수 없는 경우이다. 이 경우 호스트나 게이트웨이는 대상에 더 가까운 게이트웨이로 데이터그램을 보내려고 시도합니다. 라우팅 프로토콜의 목표는 매우 간단합니다.

라우팅을 수행하는 데 필요한 정보를 제공합니다.

---
### **1.1. Limitations of the protocol**

이 프로토콜은 가능한 모든 라우팅 문제를 해결하지는 않습니다. 위에서 언급한 바와 같이, 이는 적당한 크기의 합리적으로 동질적인 네트워크에서 IGP로 사용하기 위한 것입니다. 또한 다음과 같은 구체적인 제한 사항도 언급되어야 합니다.

- 프로토콜은 가장 긴 경로를 가진 네트워크로 제한됩니다.

- 15개의 홉이 필요합니다. 설계자들은 기본 프로토콜 설계가 대규모 네트워크에 적합하지 않다고 생각합니다. 이 제한 설명은 각 네트워크에 1의 비용이 사용된다고 가정합니다. 이는 RIP가 일반적으로 구성되는 방식입니다. 시스템 관리자가 더 많은 비용을 사용하기로 선택한 경우 상한인 15가 문제가 될 수 있습니다.

- - 프로토콜은 특정 비정상적인 상황을 해결하기 위해 "무한대 계산"에 의존합니다. \(이에 대해서는 다음 섹션에서 설명합니다.\) 네트워크 시스템에 수백 개의 네트워크가 있고 이들 모두를 포함하는 라우팅 루프가 형성되어 있는 경우 루프를 해결하려면 많은 시간이 필요합니다\(라우팅 업데이트 빈도가 다음과 같을 경우\). 제한됨\) 또는 대역폭\(변경 사항이 감지될 때마다 업데이트가 전송된 경우\). 이러한 루프는 루프가 수정되기 전에 많은 양의 네트워크 대역폭을 소비합니다. 우리는 현실적인 경우에는 느린 회선을 제외하고는 문제가 되지 않을 것이라고 믿습니다. 그럼에도 불구하고 대부분의 경우 이러한 문제를 방지하기 위해 다양한 예방 조치가 취해지기 때문에 문제는 매우 이례적입니다.

- - 이 프로토콜은 고정된 "메트릭"을 사용하여 대체 경로를 비교합니다. 측정된 지연, 신뢰성 또는 부하와 같은 실시간 매개변수를 기반으로 경로를 선택해야 하는 상황에는 적합하지 않습니다. 이러한 유형의 메트릭을 허용하는 명백한 확장은 프로토콜이 처리하도록 설계되지 않은 일종의 불안정성을 도입할 가능성이 높습니다.

---
### **1.2. Organization of this document**

이 문서의 본문은 두 부분으로 구성되어 있으며 다음 두 섹션을 차지합니다.

- 2 일반적인 거리 벡터 알고리즘의 개념적 개발 및 정당화.

- 3 실제 프로토콜 설명입니다.

이 두 섹션은 각각 독립적으로 작동할 수 있습니다. 섹션 2에서는 알고리즘의 수학적 토대를 비공식적으로 제시합니다. 프레젠테이션은 "나선형" 방법을 따릅니다. 초기의 매우 간단한 알고리즘이 설명됩니다. 그런 다음 연속적인 섹션에 개선 사항이 추가됩니다. 섹션 3은 실제 프로토콜 설명입니다. 섹션 2에 대한 특정 참조가 있는 경우를 제외하고 섹션 3에 제공된 사양에서 RIP를 완전히 구현하는 것이 가능해야 합니다.

---
## **2. Distance Vector Algorithms**

라우팅은 발신자로부터 원하는 목적지까지의 경로를 찾는 작업이다. IP "Catenet 모델"에서는 이는 주로 네트워크 간의 게이트웨이를 찾는 문제로 축소됩니다. 메시지가 단일 네트워크나 서브넷에 남아 있는 한 모든 라우팅 문제는 해당 네트워크에 특화된 기술로 해결됩니다. 예를 들어, 이더넷과 ARPANET은 각각 발신자가 하나의 네트워크 내에서 지정된 대상과 통신할 수 있는 방법을 정의합니다. IP 라우팅은 주로 메시지가 하나의 네트워크에 있는 발신자로부터 다른 네트워크에 있는 대상으로 전달되어야 할 때 사용됩니다. 이 경우 메시지는 네트워크를 연결하는 게이트웨이를 통과해야 합니다. 네트워크가 인접하지 않은 경우 메시지는 여러 개의 중간 네트워크와 이를 연결하는 게이트웨이를 통과할 수 있습니다. 메시지가 목적지와 동일한 네트워크에 있는 게이트웨이에 도달하면 해당 네트워크의 자체 기술을 사용하여 목적지에 도달합니다.

이 섹션 전체에서 "네트워크"라는 용어는 일반적으로 단일 방송 네트워크\(예: 이더넷\), 지점 간 회선 또는 ARPANET을 포괄하는 데 사용됩니다. 중요한 점은 네트워크가 IP에 의해 단일 개체로 취급된다는 것입니다. 라우팅이 필요하지 않거나\(점대점 회선과 같이\) 라우팅이 IP에 투명한 방식으로 수행되어 IP가 전체 네트워크를 완전히 연결된 단일 시스템\(이더넷 또는 ARPANET\). "네트워크"라는 용어는 IP 주소 지정을 논의할 때 다소 다른 방식으로 사용됩니다. 단일 IP 네트워크 번호는 네트워크 집합에 할당될 수 있으며, "서브넷" 주소 지정은 개별 네트워크를 설명하는 데 사용됩니다. 실제로 여기서는 서브넷 주소 지정이 사용되는 경우 서브넷을 지칭하기 위해 "네트워크"라는 용어를 사용하고 있습니다.

네트워크 간 경로를 찾는 다양한 접근 방식이 가능합니다. 이러한 접근 방식을 분류하는 유용한 방법 중 하나는 경로를 찾기 위해 게이트웨이가 교환해야 하는 정보 유형을 기반으로 하는 것입니다. 거리 벡터 알고리즘은 적은 양의 정보 교환을 기반으로 합니다. 각

라우팅 프로토콜에 참여하는 엔터티\(게이트웨이 또는 호스트\)는 시스템 내의 모든 대상에 대한 정보를 유지한다고 가정합니다. 일반적으로 하나의 네트워크에 연결된 모든 엔터티에 대한 정보는 해당 네트워크의 모든 대상에 대한 경로를 설명하는 단일 항목으로 요약됩니다. IP에 관한 한 네트워크 내 라우팅이 보이지 않기 때문에 이러한 요약이 가능합니다. 이 라우팅 데이터베이스의 각 항목에는 엔터티로 향하는 데이터그램이 전송되어야 하는 다음 게이트웨이가 포함되어 있습니다. 또한 엔터티까지의 총 거리를 측정하는 "미터법"도 포함됩니다. 거리는 다소 일반화된 개념으로, 엔터티에 메시지를 보내는 데 소요되는 시간 지연, 엔터티에 메시지를 보내는 데 소요되는 달러 비용 등을 포괄할 수 있습니다. 거리 벡터 알고리즘은 다음과 같은 경우 최적의 경로를 계산할 수 있다는 사실에서 그 이름을 얻었습니다. 교환되는 정보는 이러한 거리 목록뿐입니다. 또한 정보는 인접한 개체, 즉 공통 네트워크를 공유하는 개체 간에만 교환됩니다.

라우팅은 가장 일반적으로 네트워크에 대한 정보를 기반으로 하지만 개별 호스트에 대한 경로를 추적해야 하는 경우도 있습니다. RIP 프로토콜은 네트워크와 호스트를 공식적으로 구분하지 않습니다. 이는 단순히 네트워크나 호스트일 수 있는 대상에 대한 정보 교환을 설명합니다. \(그러나 구현자가 호스트 경로를 지원하지 않도록 선택하는 것이 가능하다는 점에 유의하십시오. 섹션 3.2를 참조하십시오.\) 실제로 수학적 발전은 한 호스트 또는 게이트웨이에서 다른 호스트 또는 게이트웨이로의 경로 측면에서 가장 편리하게 생각됩니다. 추상적인 용어로 알고리즘을 논의할 때 네트워크에 대한 라우팅 항목을 해당 네트워크에 연결된 모든 엔터티에 대한 라우팅 항목의 약어로 생각하는 것이 가장 좋습니다. 이러한 종류의 약어는 네트워크가 IP 수준에서 볼 수 있는 내부 구조가 없다고 생각하기 때문에 의미가 있습니다. 따라서 우리는 일반적으로 주어진 네트워크의 모든 엔터티에 동일한 거리를 할당합니다.

위에서 각 엔터티는 시스템의 가능한 모든 대상에 대해 하나의 항목이 포함된 라우팅 데이터베이스를 유지한다고 말했습니다. 실제 구현에서는 각 대상에 대해 다음 정보를 유지해야 할 수 있습니다.

- - 주소: 이러한 알고리즘의 IP 구현에서는 호스트 또는 네트워크의 IP 주소가 됩니다.

- 게이트웨이 : 경로를 따라 첫 번째 게이트웨이

-    목적지.

- - 인터페이스: 첫 번째 게이트웨이에 도달하는 데 사용해야 하는 물리적 네트워크입니다.

- - 미터법: 거리를 나타내는 숫자입니다.

```text
        destination.
```

- - 타이머: 항목이 마지막으로 업데이트된 이후 경과된 시간입니다.

또한 다양한 플래그 및 기타 내부 정보가 포함될 수 있습니다. 이 데이터베이스는 시스템에 직접 연결된 엔터티에 대한 설명으로 초기화됩니다. 인접 게이트웨이로부터 메시지로 수신된 정보에 따라 업데이트됩니다.

호스트와 게이트웨이가 교환하는 가장 중요한 정보는 업데이트 메시지에 포함된 정보입니다. 라우팅 체계에 참여하는 각 엔터티는 현재 해당 엔터티에 존재하는 라우팅 데이터베이스를 설명하는 업데이트 메시지를 보냅니다. 주변 엔터티로부터 얻은 정보만을 이용하여 전체 시스템에 대한 최적의 경로를 유지하는 것이 가능합니다. 이에 사용되는 알고리즘은 다음 섹션에서 설명합니다.

위에서 언급했듯이 라우팅의 목적은 데이터그램을 최종 목적지로 보내는 방법을 찾는 것입니다. 거리 벡터 알고리즘은 시스템의 모든 목적지까지 최적의 경로를 제공하는 테이블을 기반으로 합니다. 물론, 어떤 경로가 가장 좋은지 정의하기 위해서는 좋음을 측정할 수 있는 방법이 있어야 합니다. 이것을 "메트릭"이라고 합니다.

간단한 네트워크에서는 메시지가 통과해야 하는 게이트웨이 수를 단순히 계산하는 측정항목을 사용하는 것이 일반적입니다. 더 복잡한 네트워크에서는 메시지가 겪는 총 지연량, 메시지 전송 비용 또는 최소화할 수 있는 기타 수량을 나타내기 위해 메트릭이 선택됩니다. 주요 요구 사항은 메트릭을 개별 홉의 "비용" 합계로 표시할 수 있어야 한다는 것입니다.

공식적으로, 엔터티 i에서 엔터티 j로 직접 이동하는 것이 가능하다면\(즉, 다른 게이트웨이를 거치지 않고\), 비용 d\(i,j\)는 i와 j 사이의 홉과 연관됩니다. 주어진 네트워크의 모든 엔터티가 동일한 것으로 간주되는 일반적인 경우 d\(i,j\)는 주어진 네트워크의 모든 대상에 대해 동일하며 해당 네트워크 사용 비용을 나타냅니다. 전체 경로의 메트릭을 얻으려면 경로를 구성하는 개별 홉의 비용을 합산하면 됩니다. 이 메모의 목적상 비용은 양의 정수라고 가정합니다.

```text
   Let D(i,j) represent the metric of the best route from entity i to
   entity j.  It should be defined for every pair of entities.  d(i,j)
   represents the costs of the individual steps.  Formally, let d(i,j)
   represent the cost of going directly from entity i to entity j.  It
   is infinite if i and j are not immediate neighbors. (Note that d(i,i)
```

무한하다. 즉, 노드에서 노드 자체로의 직접적인 연결이 있다고 생각하지 않습니다.\) 비용은 추가되므로 최상의 측정항목은 다음과 같이 설명되어야 함을 쉽게 알 수 있습니다.

```text
             D(i,i) = 0,                      all i
             D(i,j) = min [d(i,k) + D(k,j)],  otherwise
                       k
```

그리고 최적의 경로는 i에서 d\(i,k\) + D\(k,j\)가 최소값을 갖는 이웃 k로 이동하는 것으로 시작됩니다. \(이러한 사항은 경로의 단계 수에 대한 귀납법으로 표시될 수 있습니다.\) 두 번째 방정식을 i의 바로 이웃인 k로 제한할 수 있습니다. 다른 것의 경우 d\(i,k\)는 무한하므로 이를 포함하는 항은 최소값이 될 수 없습니다.

이를 기반으로 한 간단한 알고리즘으로 메트릭을 계산할 수 있음이 밝혀졌습니다. 엔터티 i는 이웃 k에게 목적지 j까지의 거리 추정치를 보내도록 합니다. i가 k로부터 추정값을 얻으면 각 숫자에 d\(i,k\)가 추가됩니다. 이는 단순히 i와 k 사이의 네트워크를 통과하는 비용입니다. 때때로 나는 모든 이웃의 값을 비교하고 가장 작은 것을 선택합니다.

이 알고리즘은 토폴로지 변경이 없는 경우 유한 시간 내에 D\(i,j\)의 올바른 추정값으로 수렴된다는 증거가 \[2\]에 나와 있습니다. 저자는 엔터티가 서로에게 정보를 보내는 순서나 최소값이 다시 계산되는 시기에 대해 거의 가정하지 않습니다. 기본적으로 엔터티는 업데이트 전송이나 측정항목 재계산을 중단할 수 없으며 네트워크는 메시지를 영원히 지연시킬 수 없습니다. \(라우팅 엔터티의 충돌은 토폴로지 변경입니다.\) 또한 해당 증명은 D\(i,j\)의 초기 추정치에 대해 음수가 아니어야 한다는 점을 제외하고는 어떠한 가정도 하지 않습니다. 이러한 상당히 약한 가정이 충분히 좋다는 사실이 중요합니다. 업데이트가 언제 전송되는지 가정할 필요가 없으므로 알고리즘을 비동기적으로 실행하는 것이 안전합니다. 즉, 각 엔터티는 자체 시계에 따라 업데이트를 보낼 수 있습니다. 업데이트가 모두 삭제되지 않는 한 네트워크에서 업데이트를 삭제할 수 있습니다. 시작 조건에 대해 가정할 필요가 없기 때문에 알고리즘은 변경 사항을 처리할 수 있습니다. 시스템이 변경되면 라우팅 알고리즘은 이전 균형을 시작점으로 사용하여 새로운 균형으로 이동하기 시작합니다. 시작점이 무엇이든 상관없이 알고리즘이 유한한 시간 내에 수렴하는 것이 중요합니다. 그렇지 않으면 특정 종류의 변경으로 인해 수렴되지 않는 동작이 발생할 수 있습니다.

위에 제공된 알고리즘 설명\(및 증명\)은 각 엔터티가 각 이웃에서 나온 추정치의 복사본을 유지하고 때때로 모든 이웃에 대해 최소값을 수행한다고 가정합니다. 실제로 실제 구현에서는 반드시 그렇게 하는 것은 아닙니다. 그들은 단순히

지금까지 본 최고의 측정항목과 이를 보낸 이웃의 신원을 기억하세요. 그들은 더 나은\(더 작은\) 측정항목을 볼 때마다 이 정보를 대체합니다. 이를 통해 모든 이웃의 데이터를 저장하지 않고도 증분적으로 최소값을 계산할 수 있습니다.

텍스트에 설명된 알고리즘과 RIP와 같은 실제 프로토콜에 사용되는 알고리즘 사이에는 또 다른 차이점이 있습니다. 위의 설명에서는 각 엔터티가 자체 항목을 포함하여 거리가 0임을 표시합니다. 실제로 이것은 일반적으로 수행되지 않습니다. 네트워크의 모든 엔터티는 일반적으로 네트워크에 대한 단일 항목으로 요약됩니다. 네트워크 A에 연결된 호스트 또는 게이트웨이 G의 상황을 고려하십시오. C는 네트워크 A 사용 비용을 나타냅니다\(일반적으로 1의 메트릭\). \(네트워크의 내부 구조는 IP에 표시되지 않으므로 네트워크의 두 엔터티 간 이동 비용은 동일하다고 가정합니다.\) 원칙적으로 G는 다른 모든 엔터티 H로부터 메시지를 받아야 합니다. 네트워크 A는 해당 엔터티에서 자체로 이동하는 데 드는 비용이 0임을 보여줍니다. 그런 다음 G는 H까지의 거리로 C + 0을 계산합니다. G가 이러한 동일한 메시지를 모두 보도록 하는 대신 테이블에 네트워크 A에 대한 항목을 만들고 C의 메트릭을 할당하는 것으로 시작합니다. 이 항목은 네트워크 A의 경우 네트워크 A의 다른 모든 엔터티에 대한 항목을 요약하는 것으로 생각해야 합니다. 공통 항목으로 요약할 수 없는 A의 유일한 엔터티는 G 자체입니다. G에서 G로 이동하는 비용은 0이기 때문입니다. C는 아닙니다. 그러나 우리는 0 항목이 필요하지 않기 때문에 네트워크 A에 대한 단일 항목만으로 안전하게 작업할 수 있습니다. 이 전략의 또 다른 의미에 유의하십시오. 게이트웨이로 작동하지 않으며 업데이트 메시지를 보낼 필요가 없습니다. 분명히 게이트웨이로 기능하지 않는 호스트\(즉, 하나의 네트워크에만 연결된 호스트\)는 자신의 항목 D\(i,i\) = 0 외에 기여할 유용한 정보를 가질 수 없습니다. 인터페이스가 하나만 있기 때문에 이를 통해 다른 네트워크로의 경로가 해당 인터페이스로 들어갔다가 곧바로 다시 나오는 것을 쉽게 알 수 있습니다. 따라서 이러한 경로의 비용은 최소 C 만큼 최고 비용보다 커집니다. 0 항목이 필요하지 않기 때문에 게이트웨이가 아닌 사용자는 라우팅 프로토콜에 전혀 참여할 필요가 없습니다.

호스트 또는 게이트웨이 G가 수행하는 작업을 요약해 보겠습니다. 시스템의 각 목적지에 대해 G는 해당 목적지에 대한 메트릭\(즉, 목적지에 도달하는 데 드는 총 비용\)의 현재 추정치와 해당 메트릭이 기반으로 하는 데이터의 이웃 게이트웨이의 ID를 유지합니다. 목적지가 G에 직접 연결된 네트워크에 있는 경우 G는 단순히 네트워크 사용 비용과 목적지에 도달하는 데 게이트웨이가 필요하지 않다는 사실을 보여주는 항목을 사용합니다. 계산이 올바른 메트릭으로 수렴되면 이 기술로 기록된 이웃이 실제로 대상 경로의 첫 번째 게이트웨이임을 쉽게 알 수 있습니다. \(만일 거기에

여러 개의 똑같이 좋은 경로가 있으면 그 중 하나의 첫 번째 게이트웨이입니다.\) 대상, 메트릭 및 게이트웨이의 이러한 조합은 일반적으로 해당 게이트웨이를 사용하여 해당 메트릭이 있는 대상에 대한 경로라고 합니다.

지금까지의 방법에는 더 작은 메트릭이 나타날 때까지 기존 메트릭이 유지되므로 메트릭을 낮추는 방법만 있었습니다. 초기 추정치가 너무 낮을 수도 있습니다. 따라서 측정항목을 늘릴 수 있는 방법이 있어야 합니다. 다음 규칙을 사용하는 것으로 충분합니다. 대상에 대한 현재 경로에 메트릭 D가 있고 게이트웨이 G를 사용한다고 가정합니다. 새로운 정보 세트가 G 이외의 소스에서 도착한 경우 새 메트릭이 다음인 경우에만 경로를 업데이트합니다. D보다 낫습니다. 하지만 G 자체에서 새로운 정보 세트가 도착하면 항상 D를 새 값으로 업데이트하세요. 이 규칙을 사용하면 증분 업데이트 프로세스가 모든 이웃의 최신 정보를 기억하고 명시적인 최소값을 수행하는 계산과 동일한 경로를 생성한다는 것을 쉽게 알 수 있습니다. \(지금까지의 논의에서는 네트워크 구성이 정적이라고 가정했습니다. 시스템이 실패할 가능성은 허용되지 않습니다.\)

요약하자면, 지금까지 개발된 기본 거리 벡터 알고리즘은 다음과 같습니다. \(이것은 RIP 프로토콜에 대한 설명이 아닙니다. 아직 추가되어야 할 몇 가지 개선 사항이 있습니다.\) 다음 절차는 라우팅 프로토콜에 참여하는 모든 엔터티에 의해 수행됩니다. 여기에는 시스템의 모든 게이트웨이가 포함되어야 합니다. 게이트웨이가 아닌 호스트도 참여할 수 있습니다.

- - 시스템의 가능한 모든 대상에 대한 항목이 포함된 테이블을 유지합니다. 항목에는 목적지까지의 거리 D와 해당 네트워크로 가는 경로의 첫 번째 게이트웨이 G가 포함되어 있습니다. 개념적으로는 메트릭 0을 사용하여 엔터티 자체에 대한 항목이 있어야 하지만 실제로는 포함되지 않습니다.

- - 정기적으로 모든 이웃에게 라우팅 업데이트를 보냅니다. 업데이트는 라우팅 테이블의 모든 정보를 포함하는 메시지 집합입니다. 여기에는 각 목적지에 대한 항목이 포함되어 있으며 해당 목적지까지의 거리가 표시됩니다.

- - 이웃 G'로부터 라우팅 업데이트가 도착하면 G'와 공유되는 네트워크와 관련된 비용을 추가합니다. \(이것은 업데이트가 도착한 네트워크여야 합니다.\) 결과 거리 D'를 호출합니다. 결과 거리를 현재 라우팅 테이블 항목과 비교합니다. N의 새 거리 D'가 기존 값 D보다 작으면 새 경로를 채택합니다. 즉, 메트릭 D'와 게이트웨이 G'를 갖도록 N에 대한 테이블 항목을 변경합니다. G'가 게이트웨이인 경우

- 기존 경로가 나온 곳, 즉 G' = G, 이전 경로보다 크더라도 새 측정항목을 사용합니다.

---
### **2.1. Dealing with changes in topology**

위의 논의에서는 네트워크의 토폴로지가 고정되어 있다고 가정합니다. 실제로 게이트웨이와 회선이 실패하고 다시 작동하는 경우가 많습니다. 이러한 가능성을 처리하려면 알고리즘을 약간 수정해야 합니다. 알고리즘의 이론적 버전은 모든 인접 이웃에 대한 최소값을 포함합니다. 토폴로지가 변경되면 이웃 세트도 변경됩니다. 따라서 다음 번 계산이 완료되면 변경 사항이 반영됩니다. 그러나 위에서 언급한 것처럼 실제 구현에서는 최소화의 증분 버전을 사용합니다. 특정 목적지까지의 최적 경로만 기억됩니다. 해당 경로에 포함된 게이트웨이가 충돌하거나 이에 대한 네트워크 연결이 끊어지면 계산에 변경 사항이 반영되지 않을 수 있습니다. 지금까지 표시된 알고리즘은 메트릭이 변경되면 이웃에게 알리는 게이트웨이에 따라 달라집니다. 게이트웨이가 충돌하면 이웃에게 변경 사항을 알릴 방법이 없습니다.

이런 종류의 문제를 처리하려면 거리 벡터 프로토콜이 경로 시간 초과에 대한 규정을 마련해야 합니다. 세부 사항은 특정 프로토콜에 따라 다릅니다. 예를 들어, RIP에서는 라우팅에 참여하는 모든 게이트웨이가 30초마다 한 번씩 모든 이웃에게 업데이트 메시지를 보냅니다. 네트워크 N의 현재 경로가 게이트웨이 G를 사용한다고 가정합니다. 180초 동안 G로부터 응답이 없으면 게이트웨이가 충돌했거나 우리를 연결하는 네트워크를 사용할 수 없게 되었다고 가정할 수 있습니다. 따라서 경로를 유효하지 않은 것으로 표시합니다. N에 대한 유효한 경로가 있는 다른 이웃으로부터 소식을 들으면 유효한 경로가 유효하지 않은 경로를 대체합니다. 매 30초마다 각 이웃으로부터 소식을 듣기를 기대하더라도 경로 시간이 초과되기 전에 180초를 기다립니다. 불행하게도 메시지는 때때로 네트워크에 의해 손실됩니다. 따라서 하나의 누락된 메시지를 기반으로 경로를 무효화하는 것은 아마도 좋은 생각이 아닐 것입니다.

아래에서 볼 수 있듯이 현재 일부 네트워크에 대한 유효한 경로가 없다는 것을 이웃에게 알리는 방법이 있으면 유용합니다. RIP는 이 클래스의 다른 여러 프로토콜과 함께 해당 네트워크를 연결할 수 없는 것으로 표시하여 일반적인 업데이트 메시지를 통해 이를 수행합니다. 도달할 수 없는 대상을 나타내기 위해 특정 메트릭 값이 선택됩니다. 해당 측정항목 값은 우리가 볼 것으로 예상하는 가장 큰 유효한 측정항목보다 큽니다. 기존 RIP 구현에서는 16이 사용됩니다. 이 값은 유효한 가장 큰 측정항목보다 크기 때문에 일반적으로 "무한대"라고 합니다. 16은 놀라울 정도로 작은 숫자처럼 보일 수 있습니다. 우리가 곧 보게 될 이유로 이 작은 크기로 선택되었습니다. 대부분의 구현에서는 경로를 유효하지 않은 것으로 표시하기 위해 내부적으로 동일한 규칙이 사용됩니다.

---
### **2.2. Preventing instability**

지금까지 제시된 알고리즘을 사용하면 호스트나 게이트웨이가 항상 올바른 라우팅 테이블을 계산할 수 있습니다. 그러나 아직 실무에 활용하기에는 충분하지 않습니다. 위에 언급된 증명은 라우팅 테이블이 유한한 시간 내에 올바른 값으로 수렴된다는 것을 보여줍니다. 그들은 이 시간이 유용할 만큼 작을 것이라고 보장하지 않으며, 액세스할 수 없는 네트워크에 대한 메트릭이 어떻게 될 것인지도 말하지 않습니다.

접근할 수 없게 되는 경로를 처리하기 위해 수학을 확장하는 것은 충분히 쉽습니다. 위에서 제안한 규칙이 이를 수행합니다. "무한대"를 나타내기 위해 큰 메트릭 값을 선택합니다. 이 값은 실제 측정항목이 그렇게 커지지 않을 만큼 충분히 커야 합니다. 이 예에서는 값 16을 사용합니다. 네트워크에 액세스할 수 없게 되었다고 가정합니다. 바로 인접한 모든 게이트웨이가 시간 초과되고 해당 네트워크의 메트릭이 16으로 설정됩니다. 분석을 위해 모든 이웃 게이트웨이가 비용을 들여 사라진 네트워크에 직접 연결하는 새로운 하드웨어를 얻었다고 가정할 수 있습니다. of 16. 이것이 사라진 네트워크에 대한 유일한 연결이므로 시스템의 다른 모든 게이트웨이는 해당 게이트웨이 중 하나를 통과하는 새로운 경로로 수렴됩니다. 일단 수렴이 발생하면 모든 게이트웨이는 사라진 네트워크에 대해 최소 16의 메트릭을 갖게 된다는 것을 쉽게 알 수 있습니다. 원래 이웃에서 한 홉 떨어진 게이트웨이는 결국 최소 17의 메트릭을 갖게 됩니다. 두 홉 떨어진 게이트웨이는 최소 18이 됩니다. 이러한 메트릭은 최대 메트릭 값보다 크므로 모두 16으로 설정됩니다. 이제 시스템이 사라진 네트워크에 대해 메트릭 16으로 수렴할 것이 분명합니다. 모든 게이트웨이에서.

불행하게도 수렴에 얼마나 오랜 시간이 걸릴 것인지에 대한 질문은 아주 간단한 대답으로는 해결될 수 없습니다. 더 진행하기 전에 예제\(\[2\]에서 가져온\)를 살펴보는 것이 도움이 될 것입니다. 그런데 우리가 보여주려는 내용은 RIP를 올바르게 구현하면 발생하지 않습니다. 우리는 특정 기능이 왜 필요한지 보여주려고 노력하고 있습니다. 문자는 게이트웨이에 해당하고 줄은 네트워크에 해당합니다.

```text
            A-----B
             \   / \
              \ /  |
               C  /    all networks have cost 1, except
               | /     for the direct link from C to D, which
               |/      has cost 10
               D
               |<=== target network
```

각 게이트웨이에는 각 네트워크에 대한 경로를 보여주는 테이블이 있습니다.

그러나 이 그림에서는 각 게이트웨이에서 다이어그램 하단에 표시된 네트워크까지의 경로만 표시합니다.

D: 직접 연결, 미터법 1

- B: D를 통한 경로, 메트릭 2 C: B를 통한 경로, 메트릭 3 A: B를 통한 경로, 메트릭 3

이제 B에서 D로의 링크가 실패했다고 가정합니다. 이제 C에서 D로의 링크를 사용하도록 경로가 조정되어야 합니다. 불행하게도 이 작업이 수행되는 데는 시간이 걸립니다. 경로 변경은 B가 D로 가는 경로를 더 이상 사용할 수 없음을 알게 되면 시작됩니다. 단순화를 위해 아래 차트에서는 모든 게이트웨이가 동시에 업데이트를 전송한다고 가정합니다. 차트는 각 게이트웨이의 라우팅 테이블에 나타나는 대상 네트워크의 측정항목을 보여줍니다.

```text
        time ------>

        D: dir, 1   dir, 1   dir, 1   dir, 1  ...  dir, 1   dir, 1
        B: unreach  C,   4   C,   5   C,   6       C,  11   C,  12
        C: B,   3   A,   4   A,   5   A,   6       A,  11   D,  11
        A: B,   3   C,   4   C,   5   C,   6       C,  11   C,  12

        dir = directly connected
        unreach = unreachable
```

문제는 다음과 같습니다. B는 시간 초과 메커니즘을 사용하여 실패한 경로를 제거할 수 있습니다. 그러나 그 경로의 흔적은 오랫동안 시스템에 남아 있습니다. 처음에 A와 C는 여전히 B를 통해 D에 도달할 수 있다고 생각합니다. 따라서 그들은 메트릭 3을 나열하는 업데이트를 계속 보냅니다. 다음 반복에서 B는 A 또는 C를 통해 D에 접근할 수 있다고 주장합니다. 물론, 그럴 수 없습니다. A와 C가 주장한 경로는 이제 사라졌지만 아직은 이를 알 수 있는 방법이 없습니다. 그리고 B를 경유하는 경로가 사라진 것을 발견하더라도 그들은 서로 다른 경로를 통해 이용 가능한 경로가 있다고 생각합니다. 모든 수학이 주장하는 것처럼 결국 시스템은 수렴됩니다. 하지만 그렇게 하는 데는 시간이 좀 걸릴 수 있습니다. 최악의 경우는 시스템의 일부에서 네트워크에 완전히 액세스할 수 없게 되는 경우입니다. 이 경우 측정항목은 최종적으로 무한대에 도달할 때까지 위와 같은 패턴으로 천천히 증가할 수 있습니다. 이러한 이유로 이 문제를 "무한대 계산"이라고 합니다.

이제 "무한대"가 가능한 한 작게 선택된 이유를 알 수 있습니다. 네트워크에 완전히 액세스할 수 없게 되면 무한대로 계산하는 것이 가능한 한 빨리 중단되기를 원합니다. 무한대는 실제 경로가 그렇게 크지 않을 만큼 충분히 커야 합니다. 하지만 그것은

필요한 것보다 더 크면 안 됩니다. 따라서 무한대를 선택하는 것은 무한대로 계산되는 경우 네트워크 크기와 수렴 속도 간의 균형입니다. RIP 설계자들은 이 프로토콜이 직경이 15보다 큰 네트워크에서는 실용적이지 않을 것이라고 믿었습니다.

이와 같은 문제를 예방하기 위해 할 수 있는 일이 몇 가지 있습니다. RIP에서 사용하는 것은 "수평 분할\(Poisoned Reverse\)" 및 "트리거 업데이트"라고 합니다.

---
#### **2.2.1. Split horizon**

위의 문제 중 일부는 A와 C가 서로를 속이는 패턴에 연루되어 있다는 사실로 인해 발생합니다. 각각은 다른 것을 통해 D에 도달할 수 있다고 주장합니다. 이는 정보가 전송되는 위치에 좀 더 주의함으로써 예방할 수 있습니다. 특히, 경로를 학습한 이웃에게 대상 네트워크에 대한 연결 가능성을 주장하는 것은 결코 유용하지 않습니다. "수평 분할"은 경로를 학습한 게이트웨이로 전송된 업데이트에 경로를 포함함으로써 발생하는 문제를 방지하기 위한 구성표입니다. "단순 분할 지평선" 구성표는 해당 이웃으로 전송된 업데이트에서 한 이웃으로부터 학습된 경로를 생략합니다. "독이 있는 역방향 분할 지평선"에는 업데이트에 이러한 경로가 포함되지만 측정항목은 무한대로 설정됩니다.

A가 C를 통해 D에 도달할 수 있다고 생각하는 경우 C에 대한 메시지는 D에 도달할 수 없음을 나타내야 합니다. C를 통한 경로가 실제라면 C는 D에 직접 연결되거나 다른 게이트웨이를 통해 연결됩니다. C의 경로는 루프를 형성하기 때문에 A로 돌아갈 수 없습니다. C에게 D에 접근할 수 없다고 말함으로써 A는 C가 혼란스러워서 A를 통과하는 경로가 있다고 믿을 가능성을 단순히 방지합니다. 이는 점대점 선의 경우 명백합니다. 그러나 A와 C가 이더넷과 같은 브로드캐스트 네트워크로 연결되어 있고 해당 네트워크에 다른 게이트웨이가 있을 가능성을 생각해 보십시오. A가 C를 통한 경로를 가지고 있다면 해당 네트워크의 다른 게이트웨이와 통신할 때 D에 연결할 수 없다는 것을 나타내야 합니다. 네트워크의 다른 게이트웨이는 C에 직접 접근할 수 있습니다. A를 통해 C에 도달할 필요는 전혀 없습니다. A의 최적 경로가 실제로 C를 통과하는 경우 해당 네트워크의 다른 게이트웨이는 A가 D에 도달할 수 있다는 사실을 알 필요가 없습니다. 이는 다행스러운 일입니다. C의 경우 동일한 네트워크의 다른 모든 게이트웨이에 사용할 수 있습니다. 따라서 업데이트 메시지는 브로드캐스트로 전송될 수 있습니다.

일반적으로, 포이즌드 리버스\(Poisoned Reverse\)가 있는 분할 수평선이 단순 분할 수평선보다 안전합니다. 두 게이트웨이에 서로를 가리키는 경로가 있는 경우 메트릭이 16인 역방향 경로를 광고하면 루프가 즉시 중단됩니다. 역방향 경로가 단순히 공지되지 않으면 시간 초과를 기다려 잘못된 경로를 제거해야 합니다. 그러나 포이즌드 리버스에는 단점이 있습니다.

라우팅 메시지의 크기. 다양한 건물을 연결하는 캠퍼스 백본의 경우를 생각해 보십시오. 각 건물에는 백본을 로컬 네트워크에 연결하는 게이트웨이가 있습니다. 해당 게이트웨이가 백본 네트워크에 브로드캐스트해야 하는 라우팅 업데이트를 고려하십시오. 네트워크의 나머지 부분이 실제로 각 게이트웨이에 대해 알아야 할 것은 해당 게이트웨이가 연결된 로컬 네트워크입니다. 단순 분할 지평선을 사용하면 게이트웨이에서 백본 네트워크로 보낸 업데이트 메시지에 해당 경로만 표시됩니다. 포이즌드 역방향 분할 지평선이 사용되는 경우 게이트웨이는 메트릭 16을 사용하여 백본에서 학습한 모든 경로를 언급해야 합니다. 시스템이 큰 경우 이로 인해 대규모 업데이트 메시지가 발생할 수 있으며 그 항목은 거의 모두 도달할 수 없는 네트워크를 나타냅니다. .

정적 의미에서 메트릭이 16인 역방향 경로를 광고하면 추가 정보가 제공되지 않습니다. 하나의 브로드캐스트 네트워크에 게이트웨이가 많은 경우 이러한 추가 항목은 상당한 대역폭을 사용할 수 있습니다. 그 이유는 동적 동작을 개선하기 위해서입니다. 토폴로지가 변경되면 게이트웨이를 통과해서는 안되는 경로와 수렴 속도를 높일 수 있는 경로를 언급합니다. 그러나 어떤 상황에서는 네트워크 관리자가 라우팅 오버헤드를 최소화하기 위해 다소 느린 수렴을 허용하는 것을 선호할 수도 있습니다. 따라서 구현자는 자신의 선택에 따라 역방향 분할 수평선 대신 간단한 분할 수평선을 구현할 수도 있고, 네트워크 관리자가 사용할 동작을 선택할 수 있도록 하는 구성 옵션을 제공할 수도 있습니다. 또한 메트릭이 16인 일부 역방향 경로를 광고하고 다른 경로는 생략하는 하이브리드 방식을 구현하는 것도 허용됩니다. 이러한 방식의 예로는 관련 라우팅 변경 후 특정 기간 동안 역방향 경로에 대해 메트릭 16을 사용하고 그 후에는 업데이트에서 해당 경로를 생략하는 것입니다.

---
#### **2.2.2. Triggered updates**

포이즌드 리버스\(Poisoned Reverse\)가 포함된 분할 지평선은 두 개의 게이트웨이만 포함하는 라우팅 루프를 방지합니다. 그러나 3개의 게이트웨이가 서로를 속이는 패턴으로 끝날 가능성은 여전히 ​​있습니다. 예를 들어, A는 B, B를 통해 C, C를 통해 A를 통과하는 경로가 있다고 믿을 수 있습니다. 분할 수평선은 이러한 루프를 중지할 수 없습니다. 이 루프는 메트릭이 무한대에 도달하고 관련 네트워크가 도달 불가능으로 선언된 경우에만 해결됩니다. 트리거된 업데이트는 이러한 수렴 속도를 높이려는 시도입니다. 트리거된 업데이트를 받으려면 게이트웨이가 경로에 대한 지표를 변경할 때마다 아직 정기 업데이트 메시지를 보낼 시간이 아니더라도 거의 즉시 업데이트 메시지를 보내야 한다는 규칙을 추가하기만 하면 됩니다. \(타이밍 세부 사항은 프로토콜마다 다릅니다. RIP를 포함한 일부 거리 벡터 프로토콜은 트리거된 업데이트가 과도한 네트워크 트래픽을 생성하는 것을 방지하기 위해 작은 시간 지연을 지정합니다.\) 이것이 새로운 메트릭을 계산하기 위한 규칙과 어떻게 결합되는지 확인하십시오. 목적지 N에 대한 게이트웨이의 경로를 가정해보자

게이트웨이 G를 통과합니다. G 자체에서 업데이트가 도착하면 수신 게이트웨이는 새 메트릭이 이전 메트릭보다 높든 낮든 새 정보를 믿어야 합니다. 결과적으로 메트릭이 변경되면 수신 게이트웨이는 직접 연결된 모든 호스트 및 게이트웨이에 트리거된 업데이트를 보냅니다. 그러면 그들은 각각 이웃에게 업데이트를 보낼 수 있습니다. 결과적으로 트리거된 업데이트가 연속적으로 발생합니다. 캐스케이드에 어떤 게이트웨이와 호스트가 포함되어 있는지 쉽게 표시할 수 있습니다. 게이트웨이 G가 대상 N에 대한 경로를 시간 초과한다고 가정합니다. G는 트리거된 업데이트를 모든 이웃에게 보냅니다. 그러나 새로운 정보를 믿을 유일한 이웃은 N에 대한 경로가 G를 통과하는 사람들입니다. 다른 게이트웨이와 호스트는 이를 이미 사용하고 있는 경로보다 더 나쁜 새로운 경로에 대한 정보로 보고 무시할 것입니다. 경로가 G를 통과하는 이웃은 메트릭을 업데이트하고 모든 이웃에게 트리거된 업데이트를 보냅니다. 다시 말하지만, 경로를 통과하는 이웃만이 주의를 기울일 것입니다. 따라서 트리거된 업데이트는 게이트웨이 G로 이어지는 모든 경로를 따라 뒤로 전파되어 메트릭을 무한대로 업데이트합니다. 이 전파는 대상 N에 대한 경로가 다른 경로를 사용하는 네트워크의 일부에 도달하자마자 중지됩니다.

일련의 트리거된 업데이트가 발생하는 동안 시스템을 정지 상태로 유지할 수 있다면 무한대로 계산하는 일이 결코 발생하지 않는다는 것을 증명할 수 있습니다. 잘못된 경로는 항상 즉시 제거되므로 라우팅 루프가 형성될 수 없습니다.

불행히도 상황은 그다지 좋지 않습니다. 트리거된 업데이트가 전송되는 동안 정기적인 업데이트가 동시에 발생할 수 있습니다. 아직 트리거된 업데이트를 받지 못한 게이트웨이는 더 이상 존재하지 않는 경로를 기반으로 정보를 계속 전송합니다. 트리거된 업데이트가 게이트웨이를 통과한 후 아직 메시지를 받지 못한 게이트웨이 중 하나로부터 일반 업데이트를 받을 수도 있습니다. 이는 잘못된 경로의 분리된 나머지 부분을 다시 설정할 수 있습니다. 트리거된 업데이트가 충분히 빠르게 발생하는 경우 이는 거의 발생하지 않습니다. 그러나 무한대로 셀 수 있는 것은 여전히 ​​가능합니다.

---
## **3. Specifications for the protocol**

RIP는 호스트와 게이트웨이가 IP 기반 네트워크를 통해 경로 계산에 대한 정보를 교환할 수 있도록 하기 위한 것입니다. RIP는 거리 벡터 프로토콜입니다. 따라서 이는 섹션 2에 설명된 일반적인 기능을 갖습니다. RIP는 호스트와 게이트웨이 모두에 의해 구현될 수 있습니다. 대부분의 IP 문서에서와 마찬가지로 여기서는 "호스트"라는 용어를 사용하여 둘 중 하나를 포괄합니다. RIP는 개별 호스트, 네트워크 또는 기본 경로를 전달하는 데 사용되는 특수 대상일 수 있는 "대상"에 대한 경로 정보를 전달하는 데 사용됩니다.

RIP를 사용하는 모든 호스트에는 하나 이상의 네트워크에 대한 인터페이스가 있는 것으로 가정됩니다. 이를 "직접 연결된 네트워크"라고 합니다. 프로토콜은 이러한 각 네트워크에 대한 특정 정보에 대한 액세스에 의존합니다. 가장 중요한 것은 측정항목 또는 "비용"입니다. 네트워크의 측정항목은 1에서 15 사이의 정수입니다. 이 프로토콜에 지정되지 않은 방식으로 설정됩니다. 대부분의 기존 구현에서는 항상 메트릭 1을 사용합니다. 새로운 구현에서는 시스템 관리자가 각 네트워크의 비용을 설정할 수 있어야 합니다. 비용 외에도 각 네트워크에는 IP 네트워크 번호와 이와 관련된 서브넷 마스크가 있습니다. 이는 이 프로토콜에 지정되지 않은 방식으로 시스템 관리자가 설정합니다.

섹션 3.2에 지정된 규칙에서는 각 IP 네트워크에 적용되는 단일 서브넷 마스크가 있고 직접 연결된 네트워크의 서브넷 마스크만 알려져 있다고 가정합니다. 단일 네트워크 내에서 서로 다른 서브넷에 대해 서로 다른 서브넷 마스크를 사용하는 시스템이 있을 수 있습니다. 시스템이 멀리 떨어져 있는 네트워크의 서브넷 마스크를 아는 것이 바람직한 경우도 있을 수 있습니다. 그러나 이러한 상황에서는 서브넷 정보의 확산을 관리하는 규칙을 수정해야 합니다. 이러한 수정은 상호 운용성 문제를 일으키므로 프로토콜을 수정하는 것으로 보아야 합니다.

RIP를 구현하는 각 호스트에는 라우팅 테이블이 있다고 가정합니다. 이 테이블에는 RIP가 설명하는 시스템을 통해 도달할 수 있는 모든 대상에 대해 하나의 항목이 있습니다. 각 항목에는 최소한 다음 정보가 포함됩니다.

- - 대상의 IP 주소입니다.

- 목표를 달성하는 데 드는 총 비용을 나타내는 측정항목

- 호스트에서 해당 목적지까지의 데이터그램. 이 측정항목은 목적지에 도달하는 데 통과하는 네트워크와 관련된 비용의 합계입니다.

- - 목적지까지의 경로에 있는 다음 게이트웨이의 IP 주소입니다. 대상이 직접 연결된 네트워크 중 하나에 있는 경우 이 항목은 필요하지 않습니다.

```text
      - A flag to indicate that information about the route has
        changed recently.  This will be referred to as the "route
        change flag."
```

- - 경로와 관련된 다양한 타이머. 이에 대한 자세한 내용은 섹션 3.3을 참조하세요.

직접 연결된 네트워크에 대한 항목은 여기에 지정되지 않은 수단으로 수집된 정보를 사용하여 호스트에 의해 설정됩니다.

규약. 직접 연결된 네트워크의 측정항목은 해당 네트워크의 비용으로 설정됩니다. 기존 RIP 구현에서는 비용으로 항상 1이 사용됩니다. 이 경우 RIP 메트릭은 단순한 홉 수로 줄어듭니다. 예를 들어 대역폭이나 신뢰성의 차이로 인해 다른 네트워크보다 일부 네트워크에 대한 선호도를 표시하는 것이 바람직한 경우 더 복잡한 메트릭이 사용될 수 있습니다.

구현자는 시스템 관리자가 추가 경로를 입력하도록 허용하도록 선택할 수도 있습니다. 이는 라우팅 시스템 범위 밖의 호스트나 네트워크에 대한 경로일 가능성이 높습니다.

이러한 초기 항목 이외의 대상 항목은 다음 섹션에 설명된 알고리즘에 의해 추가되고 업데이트됩니다.

프로토콜이 라우팅에 대한 완전한 정보를 제공하려면 시스템의 모든 게이트웨이가 이에 참여해야 합니다. 게이트웨이가 아닌 호스트는 참여할 필요가 없지만 많은 구현에서는 라우팅 테이블을 유지 관리할 수 있도록 라우팅 정보를 수신하도록 규정합니다.

---
### **3.1. Message formats**

RIP는 UDP 기반 프로토콜입니다. RIP를 사용하는 각 호스트에는 UDP 포트 번호 520에서 데이터그램을 보내고 받는 라우팅 프로세스가 있습니다. 다른 호스트의 RIP 프로세서로 전달되는 모든 통신은 포트 520으로 전송됩니다. 모든 라우팅 업데이트 메시지는 포트 520에서 전송됩니다. 원치 않는 라우팅 업데이트 메시지에는 두 가지 모두가 있습니다. 원본 및 대상 포트는 520입니다. 요청에 대한 응답으로 전송된 포트는 요청이 발생한 포트로 전송됩니다. 특정 쿼리 및 디버깅 요청은 520 이외의 포트에서 전송될 수 있지만 대상 시스템의 포트 520으로 전달됩니다.

"자동" RIP 프로세스를 허용하는 규정이 프로토콜에 있습니다. 자동 프로세스는 일반적으로 메시지를 보내지 않는 프로세스입니다. 그러나 다른 사람이 보낸 메시지는 듣습니다. 자동 RIP는 게이트웨이 역할을 하지 않지만 로컬 게이트웨이를 모니터링하고 내부 라우팅 테이블을 최신 상태로 유지하기 위해 라우팅 업데이트를 수신하려는 호스트에 의해 사용될 수 있습니다. \(호스트가 네트워크 토폴로지를 추적할 수 있는 다양한 방법에 대한 설명은 \[5\]를 참조하십시오.\) 네트워크 중 하나를 제외한 모든 연결과의 연결이 끊어진 게이트웨이는 사실상 더 이상 게이트웨이가 아니므로 침묵을 선택할 수 있습니다.

그러나 이웃 게이트웨이가 해당 메시지에 의존하여 실패한 네트워크가 다시 작동했음을 감지할 가능성이 있는 경우에는 이 작업을 수행해서는 안 됩니다. \(4BSD 라우팅 프로그램은 라우팅 패킷을 사용하여 지점간 링크의 작동을 모니터링합니다.\)

패킷 형식은 그림 1에 나와 있습니다.

- 네트워크 정보를 포함하는 데이터그램 형식입니다. 필드 크기는 옥텟 단위로 제공됩니다. 달리 지정하지 않는 한 필드에는 가장 중요한 옥텟이 먼저 나오는 일반적인 인터넷 순서로 이진 정수가 포함됩니다. 각 눈금 표시는 1비트를 나타냅니다.

```text
       0                   1                   2                   3 3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      | command (1)   | version (1)   |      must be zero (2)         |
      +---------------+---------------+-------------------------------+
      | address family identifier (2) |      must be zero (2)         |
      +-------------------------------+-------------------------------+
      |                         IP address (4)                        |
      +---------------------------------------------------------------+
      |                        must be zero (4)                       |
      +---------------------------------------------------------------+
      |                        must be zero (4)                       |
      +---------------------------------------------------------------+
      |                          metric (4)                           |
      +---------------------------------------------------------------+
                                      .
                                      .
                                      .
      The portion of the datagram from address family identifier through
      metric may appear up to 25 times.  IP address is the usual 4-octet
      Internet address, in network order.

                          Figure 1.   Packet format
```

모든 데이터그램에는 명령, 버전 번호 및 가능한 인수가 포함되어 있습니다. 이 문서에서는 프로토콜 버전 1에 대해 설명합니다. 버전 번호 처리에 대한 자세한 내용은 섹션 3.4에 설명되어 있습니다. 명령 필드는 이 데이터그램의 목적을 지정하는 데 사용됩니다. 다음은 버전 1에 구현된 명령을 요약한 것입니다.

1 - 요청 응답 시스템이 라우팅 테이블의 전부 또는 일부를 보내도록 요청합니다.

2 - 응답 발신자의 라우팅 테이블 전체 또는 일부를 포함하는 메시지입니다. 이 메시지는 요청이나 폴링에 대한 응답으로 전송될 수도 있고 보낸 사람이 생성한 업데이트 메시지일 수도 있습니다.

3 - Traceon 더 이상 사용되지 않습니다. 이 명령이 포함된 메시지는 무시됩니다.

4 - 추적오프 더 이상 사용되지 않습니다. 이 명령이 포함된 메시지는 무시됩니다.

5 - 예약됨 이 값은 Sun Microsystems에서 자체 목적으로 사용됩니다. 후속 버전에 새 명령이 추가되면 6으로 시작해야 합니다. 이 명령이 포함된 메시지는 이에 응답하지 않는 구현에 의해 안전하게 무시될 수 있습니다.

요청 및 응답의 경우 데이터그램의 나머지 부분에는 각각에 대한 정보와 함께 대상 목록이 포함됩니다. 이 목록의 각 항목에는 대상 네트워크 또는 호스트와 이에 대한 메트릭이 포함되어 있습니다. 패킷 형식은 RIP가 여러 다른 프로토콜에 대한 라우팅 정보를 전달할 수 있도록 하기 위한 것입니다. 따라서 각 항목에는 해당 항목에 지정된 주소 유형을 나타내는 주소 계열 식별자가 있습니다. 이 문서에서는 인터넷 네트워크 라우팅에 대해서만 설명합니다. IP의 주소 계열 식별자는 2입니다. 작성자가 사용할 수 있는 RIP 구현 중 다른 유형의 주소를 구현하는 것은 없습니다. 그러나 향후 개발을 허용하려면 구현에서 지원되지 않는 주소 계열을 지정하는 항목을 건너뛰도록 구현해야 합니다. \(이러한 항목의 크기는 IP 주소를 지정하는 항목의 크기와 동일합니다.\) 지원되지 않는 항목을 건너뛴 후에도 메시지 처리는 정상적으로 계속됩니다. IP 주소는 일반적인 인터넷 주소로, 네트워크 순서대로 4옥텟으로 저장됩니다. 측정항목 필드에는 대상에 대한 현재 측정항목을 지정하는 1\~15 사이의 값 또는 대상에 연결할 수 없음을 나타내는 값 16이 포함되어야 합니다. 게이트웨이에서 보낸 각 경로는 동일한 게이트웨이에서 동일한 대상으로 향하는 이전 경로를 대체합니다.

최대 데이터그램 크기는 512옥텟입니다. 여기에는 위에서 설명한 데이터그램의 일부만 포함됩니다. IP 또는 UDP 헤더는 계산되지 않습니다. 네트워크 정보와 관련된 명령을 사용하면 정보를 여러 데이터그램으로 분할할 수 있습니다. 데이터그램이 개별적으로 처리되면 올바른 결과가 발생하므로 연속을 위해 특별한 규정이 필요하지 않습니다.

---
### **3.2. Addressing considerations**

섹션 2에 표시된 대로 거리 벡터 라우팅은 개별 호스트나 네트워크에 대한 경로를 설명하는 데 사용될 수 있습니다. RIP 프로토콜은 이러한 가능성 중 하나를 허용합니다. 요청 및 응답 메시지에 나타나는 대상은 네트워크, 호스트 또는 기본 주소를 나타내는 데 사용되는 특수 코드일 수 있습니다. 일반적으로 실제로 사용되는 경로의 종류는 특정 네트워크에 사용되는 라우팅 전략에 따라 달라집니다. 라우팅이 가능하도록 많은 네트워크가 설정되어 있습니다.

개별 호스트에 대한 정보는 필요하지 않습니다. 특정 네트워크나 서브넷의 모든 호스트가 동일한 게이트웨이를 통해 액세스할 수 있다면 라우팅 테이블에서 개별 호스트를 언급할 이유가 없습니다. 그러나 지점 간 회선을 포함하는 네트워크에는 특정 호스트에 대한 경로를 추적하기 위해 게이트웨이가 필요한 경우가 있습니다. 이 기능이 필요한지 여부는 시스템에서 사용되는 주소 지정 및 라우팅 접근 방식에 따라 다릅니다. 따라서 일부 구현에서는 호스트 경로를 지원하지 않도록 선택할 수도 있습니다. 호스트 경로가 지원되지 않으면 응답 메시지로 수신될 때 삭제됩니다. \(섹션 3.4.2 참조\)

RIP 패킷 형식은 다양한 유형의 주소를 구별하지 않습니다. "주소"라고 표시된 필드에는 다음이 포함될 수 있습니다.

호스트 주소

- 서브넷 번호 네트워크 번호 0, 기본 경로를 나타냄

RIP를 사용하는 엔터티는 데이터그램을 라우팅할 때 사용 가능한 가장 구체적인 정보를 사용하는 것으로 가정됩니다. 즉, 데이터그램을 라우팅할 때 먼저 호스트 주소 목록과 비교하여 대상 주소를 확인해야 합니다. 그런 다음 알려진 서브넷이나 네트워크 번호와 일치하는지 확인해야 합니다. 마지막으로, 이들 중 어느 것도 일치하지 않으면 기본 경로가 사용됩니다.

호스트가 RIP를 통해 수신한 정보를 평가할 때 주소 해석은 네트워크에 적용되는 서브넷 마스크를 알고 있는지 여부에 따라 달라집니다. 그렇다면 주소의 의미를 판단하는 것이 가능합니다. 예를 들어 net 128.6을 고려해보세요. 서브넷 마스크는 255.255.255.0입니다. 따라서 128.6.0.0은 네트워크 번호, 128.6.4.0은 서브넷 번호, 128.6.4.1은 호스트 주소입니다. 그러나 호스트가 서브넷 마스크를 모르면 주소 평가가 모호해질 수 있습니다. 0이 아닌 호스트 부분이 있는 경우 주소가 서브넷 번호를 나타내는지 아니면 호스트 주소를 나타내는지 여부를 확인할 수 있는 명확한 방법이 없습니다. 서브넷 마스크가 없으면 서브넷 번호는 쓸모가 없으므로 이 상황에서는 주소가 호스트를 나타내는 것으로 가정됩니다. 이러한 종류의 모호함을 피하기 위해 호스트는 적절한 서브넷 마스크를 알 것으로 예상할 수 없는 호스트에 서브넷 경로를 보내서는 안 됩니다. 일반적으로 호스트는 직접 연결된 네트워크의 서브넷 마스크만 알고 있습니다. 따라서 특별한 규정이 없는 한 서브넷으로의 경로는 서브넷이 속한 네트워크 외부로 전송되어서는 안 됩니다.

이 필터링은 서브넷 네트워크의 "경계"에 있는 게이트웨이에 의해 수행됩니다. 이는 해당 네트워크를 다른 네트워크와 연결하는 게이트웨이입니다. 서브넷 네트워크 내에서 각 서브넷은

개별 네트워크로 취급됩니다. 각 서브넷의 라우팅 항목은 RIP에 의해 순환됩니다. 그러나 경계 게이트웨이는 네트워크 전체에 대한 단일 항목만 다른 네트워크의 호스트로 보냅니다. 이는 국경 게이트웨이가 서로 다른 이웃에게 서로 다른 정보를 보낸다는 것을 의미합니다. 서브넷 네트워크에 연결된 이웃에 대해서는 서브넷 번호를 사용하여 직접 연결된 모든 서브넷 목록을 생성합니다. 다른 네트워크에 연결된 이웃의 경우 네트워크 전체에 대한 단일 항목을 만들어 해당 네트워크와 관련된 메트릭을 표시합니다. \(이 지표는 일반적으로 게이트웨이가 연결된 서브넷에 대한 가장 작은 지표입니다.\)

마찬가지로 경계 게이트웨이는 다른 네트워크에 보내는 메시지에서 직접 연결된 네트워크 중 하나 내의 호스트에 대한 호스트 경로를 언급해서는 안 됩니다. 이러한 경로는 네트워크 전체에 대한 단일 항목에 포함됩니다. "먼" 호스트\(즉, 직접 연결된 네트워크 중 하나에 속하지 않는 호스트\)에 대한 호스트 경로를 어떻게 처리할지 지정하지 않습니다. 일반적으로 이러한 경로는 호스트가 속한 네트워크에서 다른 호스트를 지원하지 않는 경로를 통해 도달할 수 있는 일부 호스트를 나타냅니다.

특수 주소 0.0.0.0은 기본 경로를 설명하는 데 사용됩니다. RIP 업데이트에 가능한 모든 네트워크를 나열하는 것이 편리하지 않을 때와 시스템에 밀접하게 연결된 하나 이상의 게이트웨이가 명시적으로 나열되지 않은 네트워크에 대한 트래픽을 처리할 준비가 되어 있을 때 기본 경로가 사용됩니다. 이러한 게이트웨이는 연결된 네트워크인 것처럼 주소 0.0.0.0에 대한 RIP 항목을 생성해야 합니다. 게이트웨이가 0.0.0.0에 대한 항목을 생성하는 방법에 대한 결정은 구현자에게 달려 있습니다. 가장 일반적으로 시스템 관리자에게는 0.0.0.0에 대한 항목을 생성해야 하는 게이트웨이를 지정하는 방법이 제공됩니다. 그러나 다른 메커니즘도 가능합니다. 예를 들어 구현자는 EGP를 사용하는 모든 게이트웨이를 기본 게이트웨이로 선언해야 한다고 결정할 수 있습니다. 네트워크 관리자가 이러한 항목에 사용할 측정항목을 선택하도록 허용하는 것이 유용할 수 있습니다. 기본 게이트웨이가 두 개 이상인 경우 이를 통해 다른 게이트웨이보다 선호하는 게이트웨이를 표현할 수 있습니다. 0.0.0.0에 대한 항목은 이 주소를 가진 실제 네트워크가 있는 것처럼 정확히 동일한 방식으로 RIP에 의해 처리됩니다. 그러나 해당 항목은 대상 주소가 테이블의 다른 네트워크와 일치하지 않는 데이터그램을 라우팅하는 데 사용됩니다. 이 규칙을 지원하기 위해 구현이 필요하지 않습니다. 그러나 강력히 권장됩니다. 0.0.0.0을 지원하지 않는 구현에서는 이 주소가 있는 항목을 무시해야 합니다. 이러한 경우 자체 RIP 업데이트에 항목을 전달하면 안 됩니다. 시스템 관리자는 0.0.0.0에 대한 경로가 의도한 것보다 더 많이 전파되지 않도록 주의해야 합니다. 일반적으로 각 자치 시스템에는 자체적으로 선호하는 기본 게이트웨이가 있습니다. 따라서 0.0.0.0과 관련된 경로는 일반적으로 떠나서는 안 됩니다.

자율 시스템의 경계. 이를 시행하는 메커니즘은 이 문서에 명시되어 있지 않습니다.

---
### **3.3. Timers**

이 섹션에서는 타이머에 의해 트리거되는 모든 이벤트에 대해 설명합니다.

30초마다 출력 프로세스에 모든 인접 게이트웨이에 대한 완전한 응답을 생성하도록 지시됩니다. 단일 네트워크에 많은 게이트웨이가 있는 경우, 모두 동시에 업데이트를 발행하도록 서로 동기화되는 경향이 있습니다. 이는 30초 타이머가 시스템의 처리 부하에 의해 영향을 받을 때마다 발생할 수 있습니다. 업데이트 메시지가 동기화되는 것은 브로드캐스트 네트워크에서 불필요한 충돌을 초래할 수 있으므로 바람직하지 않습니다. 따라서 구현에서는 두 가지 예방 조치 중 하나를 취해야 합니다.

- - 30초 업데이트는 시스템 부하나 이전 업데이트 타이머를 서비스하는 데 필요한 시간에 의해 속도가 영향을 받지 않는 시계에 의해 트리거됩니다.

- - 30초 타이머는 설정될 때마다 임의의 작은 시간이 추가되어 상쇄됩니다.

각 경로에는 "시간 초과"와 "가비지 수집 시간"이라는 두 개의 타이머가 연결되어 있습니다. 시간 초과가 만료되면 경로는 더 이상 유효하지 않습니다. 그러나 경로가 삭제되었음을 이웃에게 알릴 수 있도록 짧은 시간 동안 테이블에 유지됩니다. 가비지 수집 타이머가 만료되면 최종적으로 경로가 테이블에서 제거됩니다.

시간 초과는 경로가 설정되고 해당 경로에 대한 업데이트 메시지가 수신될 때마다 초기화됩니다. 마지막으로 타임아웃이 초기화된 시점으로부터 180초가 경과하면 해당 경로는 만료된 것으로 간주되며, 이에 대해 설명할 삭제 프로세스가 시작됩니다.

삭제는 두 가지 이유 중 하나로 인해 발생할 수 있습니다. \(1\) 제한 시간이 만료되거나 \(2\) 현재 게이트웨이에서 수신된 업데이트로 인해 지표가 16으로 설정됩니다. \(다른 게이트웨이의 업데이트 처리에 대한 논의는 섹션 3.4.2를 참조하십시오.\) 두 경우 모두 다음 이벤트가 발생합니다.

- - 가비지 수집 타이머는 120초로 설정됩니다.

- 경로의 메트릭은 16\(무한대\)으로 설정됩니다. 이것

- 경로가 서비스에서 제거됩니다.

- - 이 항목이 변경되었음을 알리는 플래그가 설정되고 출력 프로세스에 응답을 트리거하라는 신호가 전달됩니다.

가비지 수집 타이머가 만료될 때까지 경로는 이 호스트에서 보낸 모든 업데이트에 포함되며 메트릭은 16\(무한대\)입니다. 가비지 수집 타이머가 만료되면 경로가 테이블에서 삭제됩니다.

가비지 수집 타이머가 실행되는 동안 이 네트워크에 대한 새 경로가 설정되면 새 경로가 삭제될 경로를 대체합니다. 이 경우 가비지 수집 타이머를 지워야 합니다.

트리거된 업데이트를 수행하는 데 필요한 지연에 대한 설명은 섹션 3.5를 참조하세요. 해당 지연을 구현하려면 타이머가 필요하지만 여기보다 섹션 3.5에서 논의하는 것이 더 자연스럽습니다.

---
### **3.4. Input processing**

이 섹션에서는 UDP 포트 520에서 수신된 데이터그램의 처리에 대해 설명합니다. 데이터그램을 자세히 처리하기 전에 특정 일반 형식 검사를 수행해야 합니다. 이는 다음과 같이 데이터그램의 버전 번호 필드에 따라 달라집니다.

- 0 버전 번호가 0인 데이터그램은 무시됩니다. 이는 패킷 형식이 시스템별로 다른 이전 버전의 프로토콜에서 가져온 것입니다.

- 버전 번호가 1인 1개의 데이터그램은 이 사양의 나머지 부분에 설명된 대로 처리됩니다. 위에서 "0이어야 함"으로 설명된 모든 필드를 확인해야 합니다. 그러한 필드에 0이 아닌 값이 포함되어 있으면 전체 메시지가 무시됩니다.

- \>1 버전 번호가 1보다 큰 데이터그램은 이 사양의 나머지 부분에 설명된 대로 처리됩니다. 위에서 "0이어야 함"으로 설명된 모든 필드는 무시됩니다. 향후 버전의 프로토콜에서는 이러한 필드에 데이터를 넣을 수 있습니다. 버전 1 구현에서는 이 추가 데이터를 무시하고 이 문서에 지정된 필드만 처리합니다.

버전 번호를 확인하고 기타 사전 확인을 수행한 후 처리는 명령 필드의 값에 따라 달라집니다.

---
#### **3.4.1. Request**

요청은 호스트의 라우팅 테이블 전체 또는 일부를 포함하는 응답을 요청하는 데 사용됩니다. \[호스트라는 용어는 호스트 또는 게이트웨이에 사용되며 대부분의 경우 게이트웨이가 아닌 호스트가 RIP 메시지를 보내는 것은 이례적입니다.\] 일반적으로 요청은 UDP 소스 포트 520에서 브로드캐스트로 전송됩니다. 이 경우 자동 프로세스는 요청에 응답하지 않습니다. 자동 프로세스는 정의에 따라 일반적으로 라우팅 정보를 보고 싶지 않은 프로세스입니다. 그러나 자동 프로세스에 대해서도 라우팅 테이블을 확인해야 하는 게이트웨이 모니터링과 관련된 상황이 있을 수 있습니다. 이 경우 요청은 520이 아닌 UDP 포트 번호에서 전송되어야 합니다. 요청이 포트 520에서 오면 자동 프로세스는 응답하지 않습니다. 요청이 다른 포트에서 오는 경우 프로세스는 침묵하더라도 응답해야 합니다.

요청은 항목별로 처리됩니다. 항목이 없으면 응답이 제공되지 않습니다. 특별한 경우가 하나 있습니다. 요청에 정확히 하나의 항목이 있고 주소 계열 식별자가 0\(지정되지 않음을 의미\)과 무한대\(즉, 현재 구현의 경우 16\) 메트릭이 있는 경우 이는 전체 라우팅 테이블을 보내라는 요청입니다. 이 경우 출력 프로세스를 호출하여 라우팅 테이블을 요청 포트로 보냅니다.

이 특별한 경우를 제외하면 처리는 매우 간단합니다. 요청 항목 목록을 하나씩 아래로 이동합니다. 각 항목에 대해 호스트의 라우팅 데이터베이스에서 대상을 찾습니다. 경로가 있는 경우 해당 경로의 메트릭을 데이터그램의 메트릭 필드에 넣습니다. 지정된 목적지까지의 경로가 없으면 데이터그램의 메트릭 필드에 무한대\(예: 16\)를 입력합니다. 모든 항목이 채워지면 명령을 응답으로 설정하고 데이터그램을 원래 포트로 다시 보냅니다.

요청이 지정된 대상 집합에 대한 것인지 아니면 전체 라우팅 테이블에 대한 것인지에 따라 처리 방식에 차이가 있습니다. 전체 호스트 테이블에 대한 요청인 경우 정상적인 출력 처리가 수행됩니다. 여기에는 분할 수평선\(섹션 2.2.1 참조\) 및 서브넷 숨기기\(섹션 3.2\)가 포함되어 라우팅 테이블의 특정 항목이 표시되지 않습니다. 특정 항목에 대한 요청인 경우 호스트 테이블에서 해당 항목을 조회하고 정보가 반환됩니다. 분할 지평선 처리는 수행되지 않으며 요청 시 서브넷이 반환됩니다. 이러한 요청은 다양한 목적으로 사용될 것으로 예상됩니다. 호스트가 처음 나타나면 연결된 모든 네트워크에 완전한 라우팅 테이블을 요청하는 요청을 브로드캐스트합니다. 일반적으로 우리는 완전한 라우팅 테이블이 다른 호스트의 라우팅 테이블을 업데이트하는 데 사용될 가능성이 있다고 가정합니다. 이러한 이유로 분할 지평선 및 기타 모든 필터링을 사용해야 합니다. 특정 네트워크에 대한 요청은 진단 소프트웨어로만 이루어지며,

라우팅에는 사용되지 않습니다. 이 경우 요청자는 라우팅 데이터베이스의 정확한 내용을 알고 싶어하며 정보가 숨겨지는 것을 원하지 않습니다.

---
#### **3.4.2. Response**

다음과 같은 여러 가지 이유로 응답을 받을 수 있습니다.

특정 쿼리에 대한 응답

- 정기적인 업데이트가 지표 변경에 의해 트리거되는 업데이트를 트리거합니다.

응답이 생성된 방식에 관계없이 처리는 동일합니다.

응답을 처리하면 호스트의 라우팅 테이블이 업데이트될 수 있으므로 응답의 유효성을 주의 깊게 확인해야 합니다. 포트 520에서 나온 응답이 아닌 경우 응답을 무시해야 합니다. IP 소스 주소를 검사하여 데이터그램이 유효한 이웃에서 온 것인지 확인해야 합니다. 데이터그램의 소스는 직접 연결된 네트워크에 있어야 합니다. 또한 응답이 호스트 자체 주소 중 하나에서 오는지 확인하는 것도 가치가 있습니다. 브로드캐스트 네트워크의 인터페이스는 자체 브로드캐스트 복사본을 즉시 수신할 수 있습니다. 호스트가 자신의 출력을 새로운 입력으로 처리하는 경우 혼동이 발생할 수 있으므로 이러한 데이터그램은 무시해야 합니다\(다음 단락에서 설명하는 경우 제외\).

실제로 응답을 처리하기 전에 인터페이스 상태를 추적하기 위한 프로세스에 대한 입력으로 해당 응답의 존재를 사용하는 것이 유용할 수 있습니다. 위에서 언급했듯이 특정 시간 동안 게이트웨이로부터 소식을 듣지 못한 경우 경로가 시간 초과됩니다. 이는 다른 게이트웨이에서 오는 경로에 적합합니다. 또한 직접 연결된 네트워크 중 하나에 장애가 발생한 경우를 아는 것도 바람직합니다. 이 문서에서는 이를 수행하기 위한 특정 방법을 지정하지 않습니다. 이러한 방법은 네트워크의 특성과 이에 대한 하드웨어 인터페이스에 따라 달라지기 때문입니다. 그러나 이러한 방법에는 인터페이스에 도착하는 데이터그램을 수신하는 작업이 포함되는 경우가 많습니다. 도착하는 데이터그램은 인터페이스가 작동 중이라는 표시로 사용될 수 있습니다. 그러나 입력 데이터그램은 수신되지만 출력 데이터그램은 성공적으로 전송되지 않는 방식으로 인터페이스가 실패할 수 있으므로 주의해야 합니다.

이제 데이터그램 전체가 검증되었으므로 데이터그램의 항목을 하나씩 처리합니다. 다시 한 번 유효성 검사부터 시작하세요. 측정항목이 무한대보다 크면 항목을 무시하세요. \(다른 호스트가 올바르게 작동하는 경우 이는 불가능합니다. 잘못된 메트릭 및 기타 형식 오류로 인해 경고가 발생하거나 기록될 수 있습니다.\) 그런 다음 대상 주소를 확인합니다. 주소 계열 식별자를 확인하세요. 예상한 값이 아닌 경우\(예: 2

인터넷 주소의 경우\) 항목을 무시하십시오. 이제 주소 자체에서 다양한 종류의 부적절한 주소를 확인하세요. 주소가 클래스 D 또는 E이거나 net 0\(기본 경로를 허용하는 경우 0.0.0.0 제외\) 또는 net 127\(루프백 네트워크\)에 있는 경우 항목을 무시합니다. 또한 브로드캐스트 주소\(즉, 호스트 부분이 브로드캐스트를 지원하는 네트워크의 모든 주소인 항목\)를 테스트하고 해당 항목을 무시합니다. 구현자가 호스트 경로를 지원하지 않기로 선택한 경우\(섹션 3.2 참조\) 주소의 호스트 부분이 0이 아닌지 확인하세요. 그렇다면 항목을 무시하십시오.

주소 필드에는 사용되지 않은 옥텟 수가 포함되어 있다는 점을 기억하세요. 데이터그램의 버전 번호가 1인 경우에도 확인해야 합니다. 그 중 0이 아닌 항목이 있으면 해당 항목은 무시됩니다. \(이러한 사례 중 다수는 메시지가 제공된 호스트가 올바르게 작동하지 않음을 나타냅니다. 따라서 일부 형태의 오류 로깅 또는 경고가 트리거되어야 합니다.\)

메시지가 도착한 네트워크의 비용을 추가하여 지표를 업데이트합니다. 결과가 16보다 크면 16을 사용합니다. 즉,

```text
      metric = MIN (metric + cost, 16)
```

이제 주소를 찾아 이것이 이미 해당 경로인지 확인하십시오. 일반적으로 그렇지 않다면 하나를 추가하고 싶습니다. 그러나 다양한 예외가 있습니다. 측정항목이 무한한 경우 항목을 추가하지 마세요. \(기존 항목을 업데이트하지만 무한 메트릭을 사용하여 새 항목을 추가하지는 않습니다.\) 호스트가 최소한 좋은 경로가 있는 네트 또는 서브넷의 일부인 경우 호스트에 경로를 추가하지 않기를 원합니다. 이러한 예외 중 어느 것도 적용되지 않으면 라우팅 데이터베이스에 새 항목을 추가하십시오. 여기에는 다음 작업이 포함됩니다.

- - 데이터그램의 대상과 메트릭을 설정합니다.

- 게이트웨이를 데이터그램의 호스트로 설정

-    왔다.

- 경로에 대한 시간 초과를 초기화합니다. 쓰레기라면-

- 이 경로에 대해 수집 타이머가 실행 중입니다. 중지하세요. \(타이머에 대한 설명은 섹션 3.3을 참조하세요.\)

- - 경로 변경 플래그를 설정하고 업데이트를 트리거하도록 출력 프로세스에 신호를 보냅니다\(3.5 참조\).

기존 경로가 있는 경우 먼저 게이트웨이를 비교합니다. 이 데이터그램이 기존 경로와 동일한 게이트웨이에서 나온 경우 제한 시간을 다시 초기화하세요. 다음으로 측정항목을 비교하세요. 데이터그램이 기존 경로와 동일한 게이트웨이에서 왔으며 새 메트릭이 이전 메트릭과 다르거나 새 메트릭이 이전 메트릭보다 낮은 경우 다음을 수행합니다.

```text
   following actions:
```

- - 데이터그램에서 경로를 채택합니다. 즉, 새 메트릭을 입력하고 게이트웨이를 데이터그램이 나온 호스트로 설정합니다.

- - 경로에 대한 시간 초과를 초기화합니다.

- - 경로 변경 플래그를 설정하고 업데이트를 트리거하도록 출력 프로세스에 신호를 보냅니다\(3.5 참조\).

- - 새 메트릭이 16\(무한대\)이면 삭제 프로세스가 시작됩니다.

새 메트릭이 16\(무한대\)이면 경로 삭제 프로세스가 시작됩니다. 해당 경로는 더 이상 패킷 라우팅에 사용되지 않으며 삭제 타이머가 시작됩니다\(섹션 3.3 참조\). 메트릭이 처음 16으로 설정된 경우에만 삭제가 시작됩니다. 메트릭이 이미 16인 경우 새 삭제가 시작되지 않습니다. \(삭제를 시작하면 타이머가 설정됩니다. 새 메시지가 무한한 측정항목으로 도착하므로 30초마다 타이머를 재설정하고 싶지 않다는 점이 우려됩니다.\)

새 측정항목이 이전 측정항목과 동일한 경우 추가 작업을 수행하지 않는 것이 가장 간단합니다\(위에 지정된 대로 시간 초과를 다시 초기화하는 것 외에\). 그러나 라우팅된 4BSD는 여기서 추가적인 경험적 방법을 사용합니다. 일반적으로 기존 경로와 메트릭은 동일하지만 게이트웨이가 다른 경로로 변경하는 것은 의미가 없습니다. 그러나 기존 경로에 시간 초과 징후가 나타나면 시간 초과가 발생할 때까지 기다리는 것보다 즉시 동등한 대체 경로로 전환하는 것이 더 나을 수 있습니다. \(시간 초과에 대한 자세한 내용은 섹션 3.3을 참조하세요.\) 따라서 새 측정항목이 이전 측정항목과 동일하면 라우팅은 기존 경로에 대한 시간 초과를 확인합니다. 만료 지점의 절반 이상인 경우 라우팅된 스위치는 새 경로로 전환됩니다. 즉, 게이트웨이가 현재 메시지의 소스로 변경됩니다. 이 경험적 방법은 선택 사항입니다.

이 테스트에 실패한 모든 항목은 현재 경로보다 나을 것이 없으므로 무시됩니다.

---
### **3.5. Output Processing**

이 섹션에서는 라우팅 테이블의 전부 또는 일부를 포함하는 응답 메시지를 생성하는 데 사용되는 처리에 대해 설명합니다. 이 처리는 다음 방법 중 하나로 트리거될 수 있습니다.

- - 요청이 있을 때 입력 처리를 통해. 이 경우 결과 메시지는 하나의 대상으로만 전송됩니다.

- 정기적인 라우팅 업데이트를 통해. 30초마다

- 전체 라우팅 테이블을 포함하는 응답이 모든 인접 게이트웨이로 전송됩니다. \(섹션 3.3을 참조하세요.\)

- - 트리거된 업데이트를 기준으로 합니다. 경로의 지표가 변경될 때마다 업데이트가 트리거됩니다. \(업데이트가 지연될 수 있습니다. 아래를 참조하세요.\)

직접 연결된 각 네트워크에 대해 메시지가 생성되는 방식을 설명하기 전에 후자의 두 경우에 대해 대상을 선택하는 방법에 대해 설명하겠습니다. 일반적으로 모든 대상에 응답을 보내려고 할 때\(즉, 정기 업데이트 또는 트리거 업데이트를 준비하는 중\) 연결된 각 지점 간 링크의 반대쪽 끝에 있는 호스트로 응답을 보냅니다. 응답은 방송을 지원하는 연결된 모든 네트워크에서 방송됩니다. 따라서 직접 연결된 각 네트워크에 대해 하나의 응답이 준비되어 해당\(대상 또는 브로드캐스트\) 주소로 전송됩니다. 대부분의 경우 이는 모든 인접 게이트웨이에 도달합니다. 그러나 이것이 충분하지 않은 경우도 있습니다. 여기에는 브로드캐스트를 지원하지 않는 네트워크\(예: ARPANET\) 또는 멍청한 게이트웨이와 관련된 상황이 포함될 수 있습니다. 그러한 경우에는 이웃 호스트 및 게이트웨이의 실제 목록을 지정하고 명시적으로 각 호스트 및 게이트웨이에 데이터그램을 보내는 것이 필요할 수 있습니다. 그러한 메커니즘이 필요한지 여부를 결정하고 목록을 지정하는 방법을 정의하는 것은 구현자의 몫입니다.

트리거된 업데이트에는 두 가지 이유로 특별한 처리가 필요합니다. 첫째, 경험에 따르면 트리거된 업데이트는 용량이 제한되어 있거나 게이트웨이가 많은 네트워크에 과도한 로드를 유발할 수 있습니다. 따라서 프로토콜에서는 구현자가 트리거된 업데이트의 빈도를 제한하는 조항을 포함하도록 요구합니다. 트리거된 업데이트가 전송된 후 타이머는 1\~5초 사이의 임의 시간으로 설정되어야 합니다. 타이머가 만료되기 전에 업데이트를 트리거하는 다른 변경 사항이 발생하면 타이머가 만료될 때 단일 업데이트가 트리거되고 타이머는 1\~5초 사이의 다른 임의 값으로 설정됩니다. 트리거된 업데이트가 전송될 때까지 정기적인 업데이트가 예정되어 있는 경우 트리거된 업데이트가 표시되지 않을 수 있습니다.

둘째, 트리거된 업데이트에는 전체 라우팅 테이블이 포함될 필요가 없습니다. 원칙적으로 변경된 노선만 포함하면 됩니다. 따라서 트리거된 업데이트의 일부로 생성된 메시지에는 최소한 경로 변경 플래그가 설정된 경로가 포함되어야 합니다. 구현자의 재량에 따라 추가 경로 또는 모든 경로가 포함될 수 있습니다. 그러나 전체 라우팅 업데이트에 여러 패킷이 필요한 경우 모든 경로를 보내는 것은 권장되지 않습니다. 트리거된 업데이트가 처리되면 직접 연결된 모든 네트워크에 대해 메시지가 생성되어야 합니다. 분할 지평선 처리는 일반 업데이트뿐만 아니라 트리거된 업데이트를 생성할 때 수행됩니다\(아래 참조\).

분할 지평선 처리 후 변경된 경로가 이전과 마찬가지로 네트워크에서 동일하게 나타나는 경우 해당 경로를 보낼 필요가 없습니다. 결과적으로 경로를 보낼 필요가 없으면 해당 네트워크에서 업데이트가 생략될 수 있습니다. \(경로에 메트릭 변경만 있거나 이전 게이트웨이와 동일한 네트워크에 있는 새 게이트웨이를 사용하는 경우 경로는 변경 전후 모두 메트릭이 무한대인 이전 게이트웨이의 네트워크로 전송됩니다. \) 트리거된 업데이트가 모두 생성되면 경로 변경 플래그를 지워야 합니다.

출력이 생성되는 동안 입력 처리가 허용되면 적절한 연동이 이루어져야 합니다. 트리거된 업데이트 메시지가 생성되는 동안 입력 처리 결과로 경로 변경 플래그가 변경되어서는 안 됩니다.

트리거된 업데이트와 기타 업데이트 메시지 간의 유일한 차이점은 변경되지 않은 경로가 생략될 수 있다는 것입니다. 설명할 나머지 메커니즘은 모두 트리거된 업데이트에 적용되어야 합니다.

다음은 직접 연결된 특정 네트워크에 대한 응답 데이터그램이 생성되는 방법입니다.

IP 소스 주소는 해당 네트워크의 전송 호스트 주소여야 합니다. 이는 소스 주소가 다른 호스트의 라우팅 테이블에 저장되기 때문에 중요합니다. 잘못된 소스 주소가 사용되면 다른 호스트가 데이터그램을 라우팅하지 못할 수 있습니다. 때로는 게이트웨이가 단일 물리적 인터페이스에 여러 IP 주소로 설정되는 경우도 있습니다. 일반적으로 이는 여러 논리적 IP 네트워크가 하나의 물리적 매체를 통해 전달되고 있음을 의미합니다. 이러한 경우 해당 주소를 IP 소스 주소로 사용하여 각 주소에 대해 별도의 업데이트 메시지를 전송해야 합니다.

버전 번호를 현재 RIP 버전으로 설정합니다. \(본 문서에 설명된 버전은 1입니다.\) 명령을 응답으로 설정합니다. "0이어야 함"이라는 레이블이 붙은 바이트를 0으로 설정합니다. 이제 항목 작성을 시작하세요.

항목을 채우려면 내부 라우팅 테이블의 모든 경로로 이동하세요. 최대 데이터그램 크기는 512바이트라는 점을 기억하세요. 데이터그램에 더 이상 공간이 없으면 현재 메시지를 보내고 새 메시지를 시작합니다. 트리거된 업데이트가 생성되는 경우 경로 변경 플래그가 설정된 항목만 포함되어야 합니다.

서브넷 및 호스트 경로로 인해 발생하는 문제에 대한 논의는 섹션 3.2의 설명을 참조하세요. 서브넷으로의 경로는 네트워크 외부에서는 의미가 없으며 대상이 동일한 서브넷 네트워크에 있지 않은 경우 생략해야 합니다. 그들은 그래야 한다

서브넷이 포함된 네트워크에 대한 단일 경로로 대체됩니다. 마찬가지로, 섹션 3.2의 논의에 설명된 대로 호스트에 대한 경로가 네트워크 경로에 포함되는 경우 제거되어야 합니다.

경로가 이러한 테스트를 통과하면 대상과 메트릭이 출력 데이터그램의 항목에 입력됩니다. 메트릭이 무한하더라도 경로는 데이터그램에 포함되어야 합니다. 경로의 게이트웨이가 데이터그램이 준비되는 네트워크에 있는 경우 항목의 메트릭이 16으로 설정되거나 전체 항목이 생략됩니다. 항목을 생략하면 단순 분할 수평선이 됩니다. 메트릭 16이 포함된 항목을 포함하면 수평 방향이 반전되어 분할됩니다. 이러한 대안에 대한 보다 완전한 논의는 섹션 2.2를 참조하십시오.

---
### **3.6. Compatibility**

이 문서에 설명된 프로토콜은 라우팅된 RIP 구현 및 기타 기존 구현과 상호 운용되도록 고안되었습니다. 그러나 메트릭을 증가시키는 시점에 대해서는 대부분의 이전 구현에서 사용된 것과는 다른 관점이 채택되었습니다. 이전 관점을 사용하면 내부 라우팅 테이블의 메트릭은 모든 직접 연결된 네트워크에 대해 0입니다. 경로가 업데이트 메시지로 전송될 때 비용\(항상 1\)이 메트릭에 추가됩니다. 대조적으로, 이 문서에서 직접 연결된 네트워크는 비용과 동일한 측정항목을 사용하여 내부 라우팅 테이블에 나타납니다. 메트릭은 반드시 1일 필요는 없습니다. 이 문서에서는 업데이트 메시지에서 경로가 수신될 때 메트릭에 비용이 추가됩니다. 라우팅 테이블의 메트릭은 변경 없이\(지평 분할로 수정되지 않는 한\) 업데이트 메시지로 전송됩니다.

이 두 가지 관점에서는 동일한 업데이트 메시지가 전송됩니다. 라우팅 테이블의 메트릭은 두 설명의 상수에 따라 다릅니다. 따라서 효과에는 차이가 없습니다. 새로운 설명을 통해 직접 연결된 네트워크에서 다양한 메트릭이 사용되는 상황을 더 쉽게 처리할 수 있기 때문에 변경되었습니다.

하나의 네트워크 비용만 지원하는 구현은 새로운 표현 스타일에 맞게 변경할 필요가 없습니다. 그러나 다른 모든 방법에서는 이 문서에 제공된 설명을 따라야 합니다.

---
## **4. Control functions**

이 섹션에서는 관리 제어에 대해 설명합니다. 이는 프로토콜 자체의 일부가 아닙니다. 그러나 기존 네트워크에 대한 경험을 통해 이러한 네트워크가 중요하다는 것을 알 수 있습니다. 이는 프로토콜의 필수 부분이 아니기 때문에 선택 사항으로 간주됩니다. 그러나 최소한 그 중 일부는 모든 보고서에 포함될 것을 강력히 권장합니다.

```text
   implementation.
```

이러한 컨트롤은 주로 라우팅이 불안정하거나 오류가 발생할 수 있는 네트워크에 RIP를 연결할 수 있도록 하기 위한 것입니다. 여기 몇 가지 예가 있어요.

정보가 받아들여지는 호스트와 게이트웨이를 제한하는 것이 바람직한 경우도 있습니다. 때때로 호스트가 부적절한 정보를 보내기 시작하는 방식으로 잘못 구성되었습니다.

많은 사이트에서는 업데이트 메시지에서 허용하는 네트워크 집합을 제한합니다. 조직 A는 직접 통신에 사용하는 조직 B에 연결되어 있을 수 있습니다. 보안 또는 성능상의 이유로 A는 다른 조직에 해당 연결에 대한 액세스 권한을 부여하지 않을 수 있습니다. 이러한 경우 A는 A가 제3자에게 보내는 업데이트에 B의 네트워크를 포함해서는 안 됩니다.

다음은 몇 가지 일반적인 컨트롤입니다. 그러나 RIP 프로토콜에는 이러한 컨트롤이나 다른 컨트롤이 필요하지 않습니다.

- - 이웃 목록 - 네트워크 관리자는 각 호스트에 대한 이웃 목록을 정의할 수 있어야 합니다. 호스트는 이웃 목록에 있는 호스트의 응답 메시지만 수락합니다.

- - 특정 대상을 허용하거나 허용하지 않음 - 네트워크 관리자는 허용하거나 허용하지 않을 대상 주소 목록을 지정할 수 있어야 합니다. 목록은 들어오거나 나가는 방향의 특정 인터페이스와 연결됩니다. 나가는 응답 메시지에서는 허용된 네트워크만 언급되거나 들어오는 응답 메시지에서는 처리됩니다. 허용된 주소 목록이 지정되면 다른 모든 주소는 허용되지 않습니다. 허용되지 않는 주소 목록이 지정되면 다른 모든 주소가 허용됩니다.

---
# **REFERENCES and BIBLIOGRAPHY**

```text
   [1] Bellman, R. E., "Dynamic Programming", Princeton University
       Press, Princeton, N.J., 1957.
```

\[2\] Bertsekas, D. P. 및 Gallaher, R. G., "데이터 네트워크",

- 프렌티스 홀, 뉴저지 주 잉글우드 클리프스, 1987.

\[3\] Braden, R. 및 Postel, J., "인터넷 게이트웨이 요구 사항", USC/정보 과학 연구소, RFC-1009, 1987년 6월.

\[4\] Boggs, D. R., Shoch, J. F., Taft, E. A. 및 Metcalfe, R. M., "Pup: An Internetwork Architecture", IEEE Transactions on Communications, 1980년 4월.

\[5\] Clark, D. D., "오류 격리 및 복구", MIT-LCS, RFC-816, 1982년 7월.

\[6\] Ford, L. R. Jr. 및 Fulkerson, D. R., "Flows in Networks", Princeton University Press, Princeton, N.J., 1962.

```text
   [7] Xerox Corp., "Internet Transport Protocols", Xerox System
       Integration Standard XSIS 028112, December 1981.
```
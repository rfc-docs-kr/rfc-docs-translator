

```text
Network Working Group                                           C. Adams
Request for Comments: 4210                          University of Ottawa
Obsoletes: 2510                                               S. Farrell
Category: Standards Track                         Trinity College Dublin
                                                                T. Kause
                                                                     SSH
                                                              T. Mononen
                                                                 SafeNet
                                                          September 2005

               Internet X.509 Public Key Infrastructure
                 Certificate Management Protocol (CMP)
```

---
# **Status of This Memo**

이 문서는 인터넷 커뮤니티를 위한 인터넷 표준 추적 프로토콜을 지정하고 개선을 위한 토론 및 제안을 요청합니다. 이 프로토콜의 표준화 상태 및 상태에 대해서는 "Internet Official Protocol Standards"\(STD 1\) 최신판을 참조하십시오. 이 메모의 배포는 무제한입니다.

---
# **Copyright Notice**

Copyright \(C\) The Internet Society \(2005\).

---
# **Abstract**

이 문서에서는 인터넷 X.509 공개 키 인프라\(PKI\) 인증서 관리 프로토콜\(CMP\)에 대해 설명합니다. X.509v3 인증서 생성 및 관리를 위해 프로토콜 메시지가 정의됩니다. CMP는 CA\(인증 기관\)와 클라이언트 시스템 간의 교환을 포함하여 PKI 구성 요소 간의 온라인 상호 작용을 제공합니다.

---
# **Table of Contents**

```text
   1. Introduction ....................................................5
   2. Requirements ....................................................5
   3. PKI Management Overview .........................................5
      3.1. PKI Management Model .......................................6
           3.1.1. Definitions of PKI Entities .........................6
                  3.1.1.1. Subjects and End Entities ..................6
                  3.1.1.2. Certification Authority ....................7
                  3.1.1.3. Registration Authority .....................7
           3.1.2. PKI Management Requirements .........................8
           3.1.3. PKI Management Operations ..........................10
   4. Assumptions and Restrictions ...................................14
      4.1. End Entity Initialization .................................14
      4.2. Initial Registration/Certification ........................14
           4.2.1. Criteria Used ......................................15
                  4.2.1.1. Initiation of Registration/Certification ..15
                  4.2.1.2. End Entity Message Origin Authentication ..15
                  4.2.1.3. Location of Key Generation ................15
                  4.2.1.4. Confirmation of Successful Certification ..16
           4.2.2. Mandatory Schemes ..................................16
                  4.2.2.1. Centralized Scheme ........................16
                  4.2.2.2. Basic Authenticated Scheme ................17
      4.3. Proof-of-Possession (POP) of Private Key ..................17
           4.3.1. Signature Keys .....................................18
           4.3.2. Encryption Keys ....................................18
           4.3.3. Key Agreement Keys .................................19
      4.4. Root CA Key Update ........................................19
           4.4.1. CA Operator Actions ................................20
           4.4.2. Verifying Certificates .............................21
                  4.4.2.1. Verification in Cases 1, 4, 5, and 8 ......22
                  4.4.2.2. Verification in Case 2 ....................22
                  4.4.2.3. Verification in Case 3 ....................23
                  4.4.2.4. Failure of Verification in Case 6 .........23
                  4.4.2.5. Failure of Verification in Case 7 .........23
           4.4.3. Revocation - Change of CA Key ......................23
   5. Data Structures ................................................24
      5.1. Overall PKI Message .......................................24
           5.1.1. PKI Message Header .................................24
                  5.1.1.1. ImplicitConfirm ...........................27
                  5.1.1.2. ConfirmWaitTime ...........................27
           5.1.2. PKI Message Body ...................................27
           5.1.3. PKI Message Protection .............................28
                  5.1.3.1. Shared Secret Information .................29
                  5.1.3.2. DH Key Pairs ..............................30
                  5.1.3.3. Signature .................................30
                  5.1.3.4. Multiple Protection .......................30
      5.2. Common Data Structures ....................................31
           5.2.1. Requested Certificate Contents .....................31
           5.2.2. Encrypted Values ...................................31
           5.2.3. Status codes and Failure Information for
                  PKI Messages .......................................32
           5.2.4. Certificate Identification .........................33
           5.2.5. Out-of-band root CA Public Key .....................33
           5.2.6. Archive Options ....................................34
           5.2.7. Publication Information ............................34
           5.2.8. Proof-of-Possession Structures .....................34
                  5.2.8.1. Inclusion of the Private Key ..............35
                  5.2.8.2. Indirect Method ...........................35
                  5.2.8.3. Challenge-Response Protocol ...............35
                  5.2.8.4. Summary of PoP Options ....................37
      5.3. Operation-Specific Data Structures ........................38
           5.3.1. Initialization Request .............................38
           5.3.2. Initialization Response ............................39
           5.3.3. Certification Request ..............................39
           5.3.4. Certification Response .............................39
           5.3.5. Key Update Request Content .........................40
           5.3.6. Key Update Response Content ........................41
           5.3.7. Key Recovery Request Content .......................41
           5.3.8. Key Recovery Response Content ......................41
           5.3.9. Revocation Request Content .........................41
           5.3.10. Revocation Response Content .......................42
           5.3.11. Cross Certification Request Content ...............42
           5.3.12. Cross Certification Response Content ..............42
           5.3.13. CA Key Update Announcement Content ................42
           5.3.14. Certificate Announcement ..........................43
           5.3.15. Revocation Announcement ...........................43
           5.3.16. CRL Announcement ..................................43
           5.3.17. PKI Confirmation Content ..........................43
           5.3.18. Certificate Confirmation Content ..................44
           5.3.19. PKI General Message Content .......................44
                  5.3.19.1. CA Protocol Encryption Certificate .......44
                  5.3.19.2. Signing Key Pair Types ...................45
                  5.3.19.3. Encryption/Key Agreement Key Pair Types ..45
                  5.3.19.4. Preferred Symmetric Algorithm ............45
                  5.3.19.5. Updated CA Key Pair ......................45
                  5.3.19.6. CRL ......................................46
                  5.3.19.7. Unsupported Object Identifiers ...........46
                  5.3.19.8. Key Pair Parameters ......................46
                  5.3.19.9. Revocation Passphrase ....................46
                  5.3.19.10. ImplicitConfirm .........................46
                  5.3.19.11. ConfirmWaitTime .........................47
                  5.3.19.12. Original PKIMessage .....................47
                  5.3.19.13. Supported Language Tags .................47
           5.3.20. PKI General Response Content ......................47
           5.3.21. Error Message Content .............................47
           5.3.22. Polling Request and Response ......................48
   6. Mandatory PKI Management Functions .............................51
      6.1. Root CA Initialization ....................................51
      6.2. Root CA Key Update ........................................51
      6.3. Subordinate CA Initialization .............................51
      6.4. CRL production ............................................52
      6.5. PKI Information Request ...................................52
      6.6. Cross Certification .......................................52
           6.6.1. One-Way Request-Response Scheme: ...................52
      6.7. End Entity Initialization .................................54
           6.7.1. Acquisition of PKI Information .....................54
           6.7.2. Out-of-Band Verification of Root-CA Key ............55
      6.8. Certificate Request .......................................55
      6.9. Key Update ................................................55
   7. Version Negotiation ............................................56
      7.1. Supporting RFC 2510 Implementations .......................56
           7.1.1. Clients Talking to RFC 2510 Servers ................56
           7.1.2. Servers Receiving Version cmp1999 PKIMessages ......57
   8. Security Considerations ........................................57
      8.1. Proof-Of-Possession with a Decryption Key .................57
      8.2. Proof-Of-Possession by Exposing the Private Key ...........57
      8.3. Attack Against Diffie-Hellman Key Exchange ................57
   9. IANA Considerations ............................................58
   Normative References ..............................................58
   Informative References ............................................59
   A. Reasons for the Presence of RAs ................................61
   B. The Use of Revocation Passphrase ...............................61
   C. Request Message Behavioral Clarifications ......................63
   D. PKI Management Message Profiles (REQUIRED) .....................65
      D.1. General Rules for Interpretation of These Profiles ........65
      D.2. Algorithm Use Profile .....................................66
      D.3. Proof-of-Possession Profile ...............................68
      D.4. Initial Registration/Certification (Basic
           Authenticated Scheme) .....................................68
      D.5. Certificate Request .......................................74
      D.6. Key Update Request ........................................75
   E. PKI Management Message Profiles (OPTIONAL) .....................75
      E.1. General Rules for Interpretation of These Profiles ........76
      E.2. Algorithm Use Profile .....................................76
      E.3. Self-Signed Certificates ..................................76
      E.4. Root CA Key Update ........................................77
      E.5. PKI Information Request/Response ..........................77
      E.6. Cross Certification Request/Response (1-way) ..............79
      E.7. In-Band Initialization Using External Identity
           Certificate  ..............................................82
   F. Compilable ASN.1 Definitions ...................................83
   G. Acknowledgements ...............................................93
```

---
## **1.  Introduction**

이 문서에서는 인터넷 X.509 공개 키 인프라\(PKI\) 인증서 관리 프로토콜\(CMP\)에 대해 설명합니다. 인증서 생성 및 관리를 위해 프로토콜 메시지가 정의됩니다. 이 문서에서 "인증서"라는 용어는 \[X509\]에 정의된 X.509v3 인증서를 의미합니다.

이 사양은 RFC 2510을 폐기합니다. 이 사양은 다음 영역에서 RFC 2510과 다릅니다.

- PKI 관리 메시지 프로필 섹션은 필수 프로필과 선택 프로필의 두 가지 부록으로 나뉩니다. 이전 필수 기능 중 일부가 선택 프로필로 이동되었습니다.

- 메시지 확인 메커니즘이 크게 변경되었습니다.

- CMP 전송 수준에서 이전 폴링 방법을 더 이상 사용하지 않는 새로운 폴링 메커니즘이 도입되었습니다.

- CMP 전송 프로토콜 문제는 별도의 문서 \[CMPtrans\]에서 처리되므로 전송 섹션이 제거됩니다.

- 트랜잭션에서 교환되는 프로토콜 메시지 수를 줄이기 위해 새로운 암시적 확인 방법이 도입되었습니다.

- 새로운 사양에는 덜 눈에 띄는 프로토콜 개선 사항과 여러 문제에 대한 향상된 설명 텍스트가 포함되어 있습니다.

---
## **2.  Requirements**

이 문서의 핵심 단어 "MUST", "MUST NOT", "REQUIRED", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY" 및 "OPTIONAL"\(표시된 대로 대문자\)은 다음과 같습니다. \[RFC2119\]에 설명된 대로 해석됩니다.\(MUST NOT\)

---
## **3.  PKI Management Overview**

PKI는 이를 관리해야 하는 개인 유형에 맞게 구성되어야 합니다. 이러한 관리자에게 무한한 선택권을 제공하면 필요한 소프트웨어가 복잡해질 뿐만 아니라 관리자나 소프트웨어 개발자의 미묘한 실수로 인해 더 광범위한 손상이 발생할 가능성도 높아집니다. 마찬가지로, 번거로운 메커니즘으로 관리자를 제한하면 해당 관리자가 PKI를 사용하지 못하게 됩니다.

공개 키 인프라\(PKI\) 구성 요소 간의 온라인 상호 작용을 지원하려면 관리 프로토콜이 필요합니다. 예를 들어, CA\(인증 기관\)와 키 쌍이 연결된 클라이언트 시스템 간에 또는 서로에 대해 교차 인증서를 발급하는 두 CA 간에 관리 프로토콜이 사용될 수 있습니다.\(MUST\)

---
### **3.1.  PKI Management Model**

특정 메시지 형식과 절차를 지정하기 전에 먼저 PKI 관리 및 상호 작용\(필요한 PKI 관리 기능 측면에서\)과 관련된 엔터티를 정의합니다. 그런 다음 식별 가능한 다양한 유형의 최종 엔터티를 수용하기 위해 이러한 기능을 그룹화합니다.

---
#### **3.1.1.  Definitions of PKI Entities**

PKI 관리에 관련된 엔터티에는 최종 엔터티\(즉, 인증서가 발급되는 엔터티\)와 인증 기관\(즉, 인증서를 발급하는 엔터티\)이 포함됩니다. 등록 기관도 PKI 관리에 참여할 수 있습니다.\(MAY\)

---
##### **3.1.1.1.  Subjects and End Entities**

여기에서 "주체"라는 용어는 인증서가 발급된 엔터티를 지칭하는 데 사용되며 일반적으로 인증서의 주체 또는 subjectAltName 필드에 이름이 지정됩니다. 주체가 사용하는 도구 및/또는 소프트웨어\(예: 로컬 인증서 관리 모듈\)를 구별하려는 경우 "주체 장비"라는 용어를 사용합니다. 일반적으로 필드 이름과의 혼동을 피하기 위해 "주제"보다는 "최종 엔터티"\(EE\)라는 용어를 선호합니다. 여기서 최종 엔터티에는 애플리케이션의 인간 사용자뿐만 아니라 애플리케이션 자체\(예: IP 보안\)도 포함된다는 점에 유의하는 것이 중요합니다. 이 요소는 PKI 관리 작업에서 사용하는 프로토콜에 영향을 미칩니다. 예를 들어, 응용 프로그램 소프트웨어는 인간 사용자보다 어떤 인증서 확장이 필요한지 정확히 알 가능성이 훨씬 더 높습니다. PKI 관리 엔터티는 때때로 인증서나 교차 인증서의 제목이나 subjectAltName 필드에 이름이 지정된다는 점에서 최종 엔터티이기도 합니다. 적절한 경우 "최종 엔터티"라는 용어는 PKI 관리 엔터티가 아닌 최종 엔터티를 지칭하는 데 사용됩니다.

모든 최종 엔터티에는 최소한 자신의 이름과 개인 키, 이 엔터티가 직접 신뢰하는 CA의 이름, 해당 CA의 공개 키\(또는 공개 키의 지문\)에 대한 보안 로컬 액세스가 필요합니다. 자체 인증 버전은 다른 곳에서 구할 수 있습니다. 구현에서는 이 최소값 이상으로 보안 로컬 저장소를 사용할 수 있습니다\(예: 최종 엔터티의 자체 인증서 또는\(MAY\)

애플리케이션별 정보\). 저장 형태도 파일부터 변조 방지 암호화 토큰까지 다양합니다. 이러한 신뢰할 수 있는 로컬 저장소에 저장된 정보를 여기서는 최종 개체의 개인 보안 환경\(PSE\)이라고 합니다.

PSE 형식은 이 문서의 범위를 벗어나지만\(장비 등에 크게 의존함\) PSE에 대한 일반적인 교환 형식이 여기에 정의되어 있습니다. 즉, 인증 응답 메시지를 사용할 수 있습니다.\(MAY\)

---
##### **3.1.1.2.  Certification Authority**

CA\(인증 기관\)는 최종 개체의 관점에서 실제로 실제 "제3자"일 수도 있고 아닐 수도 있습니다. CA는 실제로 CA가 지원하는 최종 엔터티와 동일한 조직에 속하는 경우가 많습니다.

다시 한 번 "CA"라는 용어를 사용하여 인증서의 발급자 필드에 명명된 엔터티를 나타냅니다. CA가 사용하는 소프트웨어나 하드웨어 도구를 구별할 필요가 있는 경우에는 "CA 장비"라는 용어를 사용합니다.

CA 장비에는 "오프라인" 구성 요소와 "온라인" 구성 요소가 모두 포함되는 경우가 많으며 CA 개인 키는 "오프라인" 구성 요소에서만 사용할 수 있습니다. 그러나 이는 실행자의 문제입니다\(비록 정책 문제와도 관련이 있지만\).

우리는 "루트 CA"라는 용어를 사용하여 최종 엔터티가 직접 신뢰하는 CA를 나타냅니다. 즉, 루트 CA 공개 키의 값을 안전하게 획득하려면 일부 대역 외 단계가 필요합니다. 이 용어는 루트 CA가 반드시 계층 구조의 최상위에 있어야 한다는 의미가 아니라 단순히 해당 CA가 직접적으로 신뢰된다는 의미입니다.

"하위 CA"는 해당 최종 엔터티의 루트 CA가 아닌 CA입니다. 종종 하위 CA는 어떤 엔터티의 루트 CA도 아니지만 필수 사항은 아닙니다.

---
##### **3.1.1.3.  Registration Authority**

최종 엔터티 및 CA 외에도 많은 환경에서는 인증 기관과 별도로 RA\(등록 기관\)가 필요합니다. 등록 기관이 수행할 수 있는 기능은 경우에 따라 다르지만 개인 인증, 토큰 배포, 해지 보고, 이름 할당, 키 생성, 키 쌍 보관 등이 포함될 수 있습니다.\(MAY\)

이 문서에서는 RA를 선택적 구성 요소로 봅니다. CA가 존재하지 않는 경우 CA는 RA의 기능을 수행할 수 있는 것으로 가정하므로 PKI 관리 프로토콜은 최종 엔터티의 관점에서 동일합니다.\(MAY\)

다시 한 번, 필요한 경우 RA와 사용된 도구\("RA 장비"\)를 구분합니다.

RA 자체가 최종 개체라는 점에 유의하십시오. 또한 우리는 모든 RA가 실제로 인증된 최종 엔터티이고 RA가 서명에 사용할 수 있는 개인 키를 가지고 있다고 가정합니다. 특정 CA 장비가 일부 최종 개체를 RA로 식별하는 방법은 구현 문제입니다\(즉, 이 문서에서는 특별한 RA 인증 작업을 지정하지 않습니다\). 우리는 RA가 현재 상호 작용하고 있는 CA의 인증을 받도록 의무화하지 않습니다\(따라서 하나의 RA는 한 번만 인증을 받는 동안 하나 이상의 CA와 협력할 수 있습니다\).

어떤 상황에서는 RA가 있더라도 최종 엔터티가 CA와 직접 통신합니다. 예를 들어, 초기 등록 및/또는 인증을 위해 주체는 자신의 RA를 사용할 수 있지만 인증서를 새로 고치기 위해 CA와 직접 통신할 수 있습니다.

---
#### **3.1.2.  PKI Management Requirements**

여기에 제공된 프로토콜은 PKI 관리에 대한 다음 요구 사항을 충족합니다.

1. PKI 관리는 ISO/IEC 9594-8/ITU-T X.509 표준을 준수해야 합니다.

2. 다른 키 쌍에 영향을 주지 않고 키 쌍을 정기적으로 업데이트할 수 있어야 합니다.

3. 강력한 기밀성이 규제 문제를 일으킬 수 있는 환경에서 쉽게 수용될 수 있도록 PKI 관리 프로토콜의 기밀성 사용은 최소한으로 유지되어야 합니다.

4. PKI 관리 프로토콜은 다양한 업계 표준 암호화 알고리즘\(특히 RSA, DSA, MD5 및 SHA-1 포함\)의 사용을 허용해야 합니다. 이는 특정 CA, RA 또는 최종 엔터티가 원칙적으로 자체 키 쌍에 적합한 알고리즘을 사용할 수 있음을 의미합니다.

5. PKI 관리 프로토콜은 관련 최종 엔터티, RA 또는 CA에 의한 키 쌍 생성을 방해해서는 안 됩니다. 키 생성은 다른 곳에서도 발생할 수 있지만 PKI 관리의 목적에 따라 키가 최종 엔터티, RA 또는 CA에 처음 존재하는 모든 곳에서 키 생성이 발생하는 것으로 간주할 수 있습니다.

6. PKI 관리 프로토콜은 관련 최종 엔터티, RA 또는 CA에 의한 인증서 게시를 지원해야 합니다. 다양한 구현과 다양한 환경에서는 위의 접근 방식 중 하나를 선택할 수 있습니다.

7. PKI 관리 프로토콜은 다음의 생성을 지원해야 합니다.

- 인증된 최종 엔터티가 인증서 취소를 요청할 수 있도록 허용하는 인증서 취소 목록\(CRL\). 이는 가능한 서비스 거부 공격이 더 단순해지지 않도록 수행되어야 합니다.

8. PKI 관리 프로토콜은 특히 메일, http, TCP/IP 및 ftp를 포함한 다양한 "전송" 메커니즘을 통해 사용할 수 있어야 합니다.

9. 인증서 생성에 대한 최종 권한은 CA에 있습니다. 어떠한 RA나 최종 엔터티 장비도 CA가 발행한 인증서에 요청된 내용이 포함될 것이라고 가정할 수 없습니다. CA는 인증서 필드 값을 변경하거나 운영 정책에 따라 확장을 추가, 삭제 또는 변경할 수 있습니다. 즉, 모든 PKI 엔터티\(최종 엔터티, RA 및 CA\)는 실제 발급된 인증서가 요청한 인증서와 다른 인증서에 대한 요청에 대한 응답을 처리할 수 있어야 합니다. 예를 들어 CA는 요청한 유효 기간을 단축할 수 있습니다. \). 정책에 따라 요청 엔터티가 새로 생성된 인증서를 검토하고 수락할 때까지\(일반적으로 certConf 메시지 사용을 통해\) CA가 인증서를 게시하거나 배포해서는 안 됩니다.

10. 손상되지 않은 하나의 CA 키 쌍에서 다음\(CA 키 업데이트\)으로의 계획된 정상적인 전환이 지원되어야 합니다\(CA 키가 손상된 경우 도메인의 모든 엔터티에 대해 다시 초기화를 수행해야 합니다\). 해당 CA의\). PSE에 새 CA 공개 키\(CA 키 업데이트 이후\)가 포함된 최종 엔터티는 이전 공개 키를 사용하여 검증 가능한 인증서도 확인할 수 있어야 합니다. 이전 CA 키 쌍을 직접 신뢰하는 최종 엔터티는 새 CA 개인 키를 사용하여 서명된 인증서도 확인할 수 있어야 합니다\(이전 CA 공개 키가 최종 엔터티의 암호화 장비에 "하드와이어"되어 있는 상황에 필요함\).

11. RA의 기능은 일부 구현에서 또는

- 환경은 CA 자체에서 수행됩니다. 프로토콜은 통신이 RA 또는 CA와의 여부에 관계없이 최종 엔터티가 동일한 프로토콜을 사용하도록 설계되어야 합니다. 당연히 최종 개체는 통신을 보호하기 위해 CA 공개 키의 올바른 RA를 사용해야 합니다.

12. 최종 엔터티가 특정 공개 키 값이 포함된 인증서를 요청하는 경우 최종 엔터티는 해당 개인 키 값의 소유를 입증할 준비가 되어 있어야 합니다. 이는 인증 요청 유형에 따라 다양한 방법으로 수행될 수 있습니다. PKIX-CMP\(즉, 인증서 관리 프로토콜\) 메시지에 대해 정의된 대역 내 방법에 대한 자세한 내용은 섹션 4.3을 참조하세요.

---
#### **3.1.3.  PKI Management Operations**

다음 다이어그램은 PKI 관리 작업 측면에서 위에 정의된 엔터티 간의 관계를 보여줍니다. 다이어그램의 문자는 정의된 PKI 관리 메시지 세트가 각 문자 행을 따라 전송될 수 있다는 의미에서 "프로토콜"을 나타냅니다.

```text
     +---+     cert. publish        +------------+      j
     |   |  <---------------------  | End Entity | <-------
     | C |             g            +------------+      "out-of-band"
     | e |                            | ^                loading
     | r |                            | |      initial
     | t |                          a | | b     registration/
     |   |                            | |       certification
     | / |                            | |      key pair recovery
     |   |                            | |      key pair update
     | C |                            | |      certificate update
     | R |  PKI "USERS"               V |      revocation request
     | L | -------------------+-+-----+-+------+-+-------------------
     |   |  PKI MANAGEMENT    | ^              | ^
     |   |    ENTITIES      a | | b          a | | b
     | R |                    V |              | |
     | e |             g   +------+    d       | |
     | p |   <------------ | RA   | <-----+    | |
     | o |      cert.      |      | ----+ |    | |
     | s |       publish   +------+   c | |    | |
     | i |                              | |    | |
     | t |                              V |    V |
     | o |          g                 +------------+   i
     | r |   <------------------------|     CA     |------->
     | y |          h                 +------------+  "out-of-band"
     |   |      cert. publish              | ^         publication
     |   |      CRL publish                | |
     +---+                                 | |    cross-certification
                                         e | | f  cross-certificate
                                           | |       update
                                           | |
                                           V |
                                         +------+
                                         | CA-2 |
                                         +------+

   Figure 1 - PKI Entities
```

높은 수준에서 관리 메시지가 정의되는 작업 집합은 다음과 같이 그룹화될 수 있습니다.

1. CA 설정: 새로운 CA를 설정할 때 특정 단계\(예: 초기 CRL 생성, CA 공개 키 내보내기\)가 필요합니다.

2. 최종 엔터티 초기화: 여기에는 루트 CA 공개 키 가져오기 및 PKI 관리 엔터티에서 지원하는 옵션에 대한 정보 요청이 포함됩니다.

3. 인증: 다양한 작업을 통해 새로운 인증서가 생성됩니다.

- 1. 초기 등록/인증: 이는 CA가 해당 최종 개체에 대한 인증서를 발급하기 전에 최종 개체가 CA 또는 RA에 먼저 자신을 알리는 프로세스입니다. 이 프로세스의 최종 결과\(성공한 경우\)는 CA가 최종 엔터티의 공개 키에 대한 인증서를 발급하고 해당 인증서를 최종 엔터티에 반환하거나 해당 인증서를 공용 저장소에 게시하는 것입니다. 이 프로세스에는 일반적으로 최종 개체 장비의 초기화를 포함하여 여러 "단계"가 포함될 수 있습니다. 예를 들어, 최종 엔터티의 장비는 인증서 경로 검증에 사용되는 CA의 공개 키로 안전하게 초기화되어야 합니다. 또한 최종 엔터티는 일반적으로 자체 키 쌍으로 초기화되어야 합니다.

- 2. 키 쌍 업데이트: 모든 키 쌍은 정기적으로 업데이트\(즉, 새 키 쌍으로 교체\)되어야 하며 새 인증서가 발급되어야 합니다.

- 3. 인증서 업데이트: 인증서가 만료되면 환경과 관련된 내용이 변경되지 않은 경우 "새로 고침"될 수 있습니다.

- 4. CA 키 쌍 업데이트: 최종 엔터티와 마찬가지로 CA 키 쌍도 정기적으로 업데이트되어야 합니다. 그러나 다른 메커니즘이 필요합니다.

- 5. 교차인증 요청 : 한 CA가 다른 CA에게 교차인증서 발급을 요청합니다. 이 표준의 목적을 위해 다음 용어가 정의됩니다. "교차 인증서"는 주체 CA와 발급자 CA가 구별되고 SubjectPublicKeyInfo에 확인 키가 포함된 인증서입니다\(즉, 인증서가 주체 CA의 서명 키 쌍에 대해 발급되었습니다\). 좀 더 세밀하게 구분할 필요가 있는 경우에는 다음과 같은 용어를 사용할 수 있습니다. 주체 CA와 발급자 CA가 서로 다른 관리 도메인에 속하는 경우 교차 인증서를 "도메인 간 교차 인증서"라고 합니다. 그렇지 않으면 "도메인 내 교차 인증서"라고 합니다.

- 1. 참고 1. 위의 "교차 인증서" 정의는 X.509에 정의된 "CA 인증서"라는 용어와 일치합니다. 이 용어를 관련이 없는 X.500 "cACertificate" 속성 유형과 혼동하지 마십시오.

2. 참고 2. 많은 환경에서 "교차"라는 용어는

- 인증서"는 추가로 한정되지 않는 한 위에 정의된 "도메인 간 교차 인증서"와 동의어로 이해됩니다.

- 3. 참고 3. 교차 인증서 발급은 상호적일 수 있지만 반드시 그런 것은 아닙니다. 즉, 두 CA가 서로에 대해 교차 인증서를 발급할 수 있습니다.

- 6. 교차 인증서 업데이트: 일반 인증서 업데이트와 유사하지만 교차 인증서가 포함됩니다.

4. 인증서/CRL 검색 작업: 일부 PKI 관리 작업으로 인해 인증서 또는 CRL이 게시됩니다.

- 1. 인증서 발행 : 인증서를 제작하는 수고를 하였기 때문에 인증서를 발행하기 위한 어떤 수단이 필요하다. PKIX에 정의된 "수단"은 섹션 5.3.13 \~ 5.3.16에 지정된 메시지를 포함하거나 \[RFC2559\], \[RFC2585\]\("운영 프로토콜" 문서\)에 설명된 다른 방법\(예: LDAP\)을 포함할 수 있습니다. PKIX 시리즈 사양 중\).\(MAY\)

- 2. CRL 공개 : 인증서 공개와 같습니다.

5. 복구 작업: 일부 PKI 관리 작업은 최종 엔터티가 PSE를 "분실"했을 때 사용됩니다.

- 1. 키 쌍 복구: 선택적으로 사용자 클라이언트 키 자료\(예: 암호 해독 목적으로 사용되는 사용자의 개인 키\)는 CA, RA 또는 CA나 RA와 연결된 키 백업 시스템에 의해 백업될 수 있습니다. 기업이 백업된 키 자료를 복구해야 하는 경우\(예: 비밀번호를 잊어버렸거나 키 체인 파일을 분실한 결과\) 그러한 복구를 지원하기 위해 프로토콜 교환이 필요할 수 있습니다.\(MAY\)

6. 해지 작업: 일부 PKI 작업으로 인해 새 CRL 항목 및/또는 새 CRL이 생성됩니다.

- 1. 폐기요청 : 인가된 자가 인증서 폐기가 필요한 비정상적인 상황을 CA에 통보한다.

7. PSE 작업: PSE 작업\(예: PSE 이동, PIN 변경 등\)의 정의는 이 사양의 범위를 벗어나지만 이러한 작업의 기초를 형성할 수 있는 PKIMessage\(CertRepMessage\)를 정의합니다.

온라인 프로토콜이 위 작업을 구현하는 유일한 방법은 아닙니다. 모든 작업에 대해 동일한 결과를 얻는 오프라인 방법이 있으며 이 사양은 온라인 프로토콜의 사용을 요구하지 않습니다. 예를 들어, 하드웨어 토큰을 사용하는 경우 많은 작업이 물리적 토큰 전달의 일부로 수행될 수 있습니다.\(MAY\)

이후 섹션에서는 위 작업을 지원하는 표준 메시지 집합을 정의합니다. 다양한 환경\(파일 기반, 온라인, 전자 메일 및 WWW\)에서 이러한 교환을 전달하기 위한 전송 프로토콜은 이 문서의 범위를 벗어나며 별도로 지정됩니다.

---
## **4.  Assumptions and Restrictions**
---
### **4.1.  End Entity Initialization**

PKI 관리 엔터티를 처리하는 최종 엔터티의 첫 번째 단계는 지원되는 PKI 기능에 대한 정보를 요청하고 관련 루트 CA 공개 키의 복사본을 안전하게 획득하는 것입니다.

---
### **4.2.  Initial Registration/Certification**

최종 개체의 초기 등록 및 인증을 달성하는 데 사용할 수 있는 많은 체계가 있습니다. CA가 구현할 수 있는 정책의 범위와 발생할 수 있는 최종 엔터티 유형의 변화로 인해 하나의 방법이 모든 상황에 적합할 수는 없습니다.

그러나 이 사양에서 지원하는 초기 등록/인증 체계를 분류할 수 있습니다. 위에서 "초기"라는 단어가 중요합니다. 문제의 최종 엔터티가 이전에 PKI와 접촉한 적이 없는 상황을 다루고 있습니다. 최종 개체가 이미 인증된 키를 보유하고 있는 경우 일부 단순화/대안이 가능합니다.

이 사양에서 지원하는 체계를 분류한 후 일부는 필수로, 일부는 선택적으로 지정할 수 있습니다. 목표는 필수 계획이 실제 사용에서 발생할 수 있는 충분한 수의 사례를 다루는 반면, 선택적 계획은 덜 자주 발생하는 특별한 경우에 사용할 수 있다는 것입니다. 이러한 방식으로 우리는 유연성과 구현 용이성 사이의 균형을 달성합니다.

이제 초기 등록/인증 제도의 분류에 대해 설명하겠습니다.

---
#### **4.2.1.  Criteria Used**
---
##### **4.2.1.1.  Initiation of Registration/Certification**

생성된 PKI 메시지의 관점에서 최종 등록/인증 교환의 시작은 최종 엔터티와 관련된 첫 번째 PKI 메시지가 생성되는 곳마다 발생하는 것으로 간주할 수 있습니다. 등록/인증 절차의 실제 시작은 다른 곳에서 발생할 수 있습니다\(예: 인사 부서가 RA 교환원에게 전화할 수 있음\).

가능한 위치는 최종 엔터티, RA 또는 CA입니다.

---
##### **4.2.1.2.  End Entity Message Origin Authentication**

인증서를 요구하는 최종 개체가 생성한 온라인 메시지는 인증될 수도 있고 그렇지 않을 수도 있습니다. 여기서 요구 사항은 최종 엔터티에서 PKI\(CA/RA\)로 보내는 모든 메시지의 출처를 인증하는 것입니다.

본 사양에서 이러한 인증은 PKI\(CA/RA\)가 일부 대역 외 수단을 통해 비밀 값\(초기 인증 키\) 및 참조 값\(비밀 값을 식별하는 데 사용됨\)을 최종 엔터티에 발급함으로써 달성됩니다. 그런 다음 초기 인증 키를 사용하여 관련 PKI 메시지를 보호할 수 있습니다.

따라서 온라인 최종 개체 -\> PKI 메시지의 인증 여부에 따라 초기 등록/인증 방식을 분류할 수 있다.

참고 1: 여기서는 PKI -\> 최종 엔터티 메시지 인증에 대해 논의하지 않습니다. 이는 항상 필수 사항이기 때문입니다. 어떤 경우든 루트-CA 공개키가 최종 엔터티의 장비에 설치되면 간단히 달성할 수도 있고, 초기 인증 키를 기반으로 할 수도 있습니다.\(MUST\)

참고 2: 최종 개체의 메시지가 일부 대역 외 수단\(예: 후속 방문\)을 통해 인증되는 경우 초기 등록/인증 절차가 안전할 수 있습니다.

---
##### **4.2.1.3.  Location of Key Generation**

이 사양에서 "키 생성"은 PKIMessage에서 키 쌍의 공개 또는 비공개 구성 요소가 처음 발생할 때마다 발생하는 것으로 간주됩니다. 이는 중앙 집중식 키 생성 서비스를 배제하지 않는다는 점에 유의하세요. 실제 키 쌍은 다음과 같을 수 있습니다.\(MAY\)

다른 곳에서 생성되어 \(독점 또는 표준화된\) 키 생성 요청/응답 프로토콜을 사용하여 최종 엔터티, RA 또는 CA로 전송됩니다\(이 사양의 범위를 벗어남\).

따라서 "키 생성" 위치에는 최종 엔터티, RA 또는 CA의 세 가지 가능성이 있습니다.

---
##### **4.2.1.4.  Confirmation of Successful Certification**

최종 개체에 대한 초기 인증서를 생성한 후 최종 개체가 인증서를 포함하는\(또는 생성을 나타내는\) 메시지를 성공적으로 수신했음을 명시적으로 확인함으로써 추가 보증을 얻을 수 있습니다. 당연히 이 확인 메시지는 \(초기 인증키 또는 기타 수단을 통해\) 보호되어야 합니다.

이는 확인 여부라는 두 가지 추가 가능성을 제공합니다.

---
#### **4.2.2.  Mandatory Schemes**

위의 기준은 다양한 초기 등록/인증 체계를 허용합니다. 이 사양에서는 CA 장비, RA 장비 및 EE 장비가 아래 나열된 두 번째 방식을 지원해야 함을 요구합니다\(섹션 4.2.2.2\). 원하는 경우 모든 엔터티는 다른 체계를 추가로 지원할 수 있습니다.\(MUST, MAY\)

---
##### **4.2.2.1.  Centralized Scheme**

위의 분류 측면에서 이 체계는 어떤 면에서는 가장 간단합니다.

```text
   o  initiation occurs at the certifying CA;

   o  no on-line message authentication is required;

   o  "key generation" occurs at the certifying CA (see Section
      4.2.1.3);
```

o 확인 메시지가 필요하지 않습니다.

메시지 흐름 측면에서 이 방식은 필요한 메시지만 CA에서 최종 엔터티로 전송된다는 의미입니다. 메시지에는 최종 엔터티에 대한 전체 PSE가 포함되어야 합니다. 최종 엔터티가 수신된 메시지를 인증하고 암호화된 값을 해독할 수 있도록 일부 대역 외 수단을 제공해야 합니다.

---
##### **4.2.2.2.  Basic Authenticated Scheme**

위의 분류 측면에서 이 체계는 다음과 같습니다.

```text
   o  initiation occurs at the end entity;

   o  message authentication is REQUIRED;

   o  "key generation" occurs at the end entity (see Section 4.2.1.3);
```

o 확인 메시지가 필요합니다.\(MUST\)

메시지 흐름 측면에서 기본 인증 체계는 다음과 같습니다.

```text
     End entity                                          RA/CA
     ==========                                      =============
          out-of-band distribution of Initial Authentication
          Key (IAK) and reference value (RA/CA -> EE)
     Key generation
     Creation of certification request
     Protect request with IAK
                   -->>-- certification request -->>--
                                                    verify request
                                                    process request
                                                    create response
                   --<<-- certification response --<<--
     handle response
     create confirmation
                   -->>-- cert conf message      -->>--
                                                    verify confirmation
                                                    create response
                   --<<-- conf ack (optional)    --<<--
     handle response
```

\(인증서 확인 메시지 확인에 실패한 경우, RA/CA는 새로 발급된 인증서가 게시되었거나 다른 방법으로 사용 가능하게 된 경우 이를 취소해야 합니다.\)\(MUST\)

---
### **4.3.  Proof-of-Possession (POP) of Private Key**

특정 공격을 방지하고 CA/RA가 최종 엔터티와 키 쌍 간의 바인딩 유효성을 적절하게 확인할 수 있도록 하기 위해 여기에 지정된 PKI 관리 작업을 통해 최종 엔터티가 키 쌍을 소유하고 있음을 증명할 수 있습니다. \(즉, 사용할 수 있음\) 인증서를 요청한 공개 키에 해당하는 개인 키를 사용합니다. 특정 CA/RA는 POP를 시행하는 방법\(예: 대역 외 절차 수단 대 PKIX-CMP\)을 자유롭게 선택할 수 있습니다.

대역 내 메시지\)를 인증 교환에 포함합니다\(즉, 이는 정책 문제일 수 있음\). 그러나 CA/RA는 최종 엔터티와 개인 엔터티 간의 바인딩을 명시적으로 확인하지 않는 현재 사용 중인 PKIX가 아닌 운영 프로토콜\(다양한 전자 메일 프로토콜이 하나의 예\)이 많기 때문에 어떤 방법으로든 POP를 시행해야 합니다. 열쇠. 바인딩\(서명, 암호화 및 키 계약 키 쌍에 대한\)을 확인하는 운영 프로토콜이 존재하고 어디에나 있을 때까지 이 바인딩은 CA/RA에 의해 확인된 것으로만 가정할 수 있습니다. 따라서 CA/RA가 바인딩을 확인하지 않으면 인터넷 공개 키 기반 구조의 인증서는 다소 의미가 없게 됩니다.\(MUST\)

POP는 인증서가 요청되는 키 유형에 따라 다양한 방식으로 수행됩니다. 키를 여러 목적\(예: RSA 키\)으로 사용할 수 있는 경우 적절한 방법을 사용할 수 있습니다.\(MAY\)

사용되어야 합니다\(예: 서명 및 기타 목적에 사용될 수 있는 키는 소유권을 증명하기 위해 CA/RA에 전송되어서는 안 됩니다\).\(SHOULD NOT\)

이 사양은 최종 엔터티가 관련 증거를 RA에 제공하고 RA가 이후에 필요한 증거가 수신\(및 검증\)되었음을 CA에 증명하는 경우를 명시적으로 허용합니다. 예를 들어, 인증된 서명 키를 원하는 최종 개체는 적절한 서명을 RA에 보낼 수 있으며, 그러면 RA는 최종 개체가 필요한 증거를 제공했음을 관련 CA에 간단히 알릴 수 있습니다. 물론 이러한 상황은 일부 정책에 의해 허용되지 않을 수 있습니다\(예: CA는 인증 중에 POP를 확인하도록 허용된 유일한 엔터티일 수 있습니다\).

---
#### **4.3.1.  Signature Keys**

서명 키의 경우 최종 엔터티는 개인 키 소유를 증명하기 위해 값에 서명할 수 있습니다.

---
#### **4.3.2.  Encryption Keys**

암호화 키의 경우 최종 개체는 개인 키를 CA/RA에 제공하거나 개인 키 소유를 증명하기 위해 값을 해독하도록 요구받을 수 있습니다\(섹션 5.2.8 참조\). 값의 암호 해독은 직접 또는 간접적으로 이루어질 수 있습니다.

직접적인 방법은 RA/CA가 EE의 즉각적인 응답이 필요한 무작위 요청을 발행하는 것입니다.

간접적인 방법은 최종 엔터티를 위해 암호화된 인증서를 발급하는 것입니다\(그리고 최종 엔터티가 확인 메시지에서 이 인증서를 해독할 수 있는 능력을 보여주도록 하는 것입니다\). 이를 통해 CA는 의도한 최종 엔터티만 사용할 수 있는 형식으로 인증서를 발급할 수 있습니다.

이 사양은 추가 메시지를 보낼 필요가 없기 때문에 간접적인 방법의 사용을 권장합니다\(즉, 메시지의 {요청, 응답, 확인} 트리플을 사용하여 증명을 보여줄 수 있습니다\).

---
#### **4.3.3.  Key Agreement Keys**

키 계약 키의 경우 최종 엔터티와 PKI 관리 엔터티\(예: CA 또는 RA\)는 최종 엔터티가 개인 키를 소유하고 있음을 증명하기 위해 공유 비밀 키를 설정해야 합니다.

이는 특정 CA에서 인증할 수 있는 키에 제한을 가할 필요가 없다는 점에 유의하세요. 특히 Diffie-Hellman 키의 경우 CA가 필요할 때 적절한 매개변수를 사용하여 단기\(또는 일회성\) 키 쌍을 생성할 수 있다면 최종 엔터티는 알고리즘 매개변수를 자유롭게 선택할 수 있습니다.

---
### **4.4.  Root CA Key Update**

이 논의는 일부 최종 엔터티가 직접 신뢰하는 CA에만 적용됩니다. 자체 서명된 CA는 직접적으로 신뢰할 수 있는 CA로 간주됩니다. 자체 서명되지 않은 CA가 일부 최종 엔터티에 대해 직접적으로 신뢰되어야 하는지 여부를 인식하는 것은 CA 정책의 문제이므로 이 문서의 범위를 벗어납니다.\(MUST\)

여기에 설명된 절차의 기본은 CA가 이전 개인 키를 사용하여 새 공개 키를 보호하고 그 반대의 경우도 마찬가지라는 것입니다. 따라서 CA가 키 쌍을 업데이트할 때 X.500 디렉터리를 사용하여 인증서를 사용할 수 있게 되면 두 개의 추가 cACertificate 속성 값을 생성해야 합니다\(총 4개: OldWithOld, OldWithNew, NewWithOld 및 NewWithNew\).

CA가 키 쌍을 변경하면 "대역 외" 수단을 통해 이전 CA 공개 키를 획득한 엔터티가 가장 큰 영향을 받습니다. 이전 CA 개인 키로 보호되는 새 CA 공개 키에 액세스해야 하는 것은 바로 이러한 최종 엔터티입니다. 그러나 이는 제한된 기간 동안만 필요합니다\("대역 외" 메커니즘을 통해 새 CA 공개 키를 획득할 때까지\). 이는 일반적으로 최종 엔터티의 인증서가 만료되면 쉽게 달성됩니다.

신규 및 기존 CA 공개 키를 보호하는 데 사용되는 데이터 구조는 표준 인증서\(확장도 포함할 수 있음\)입니다. 새로운 데이터 구조가 필요하지 않습니다.

참고 1. 이 체계는 버전 1 인증서에서도 작동할 수 있어야 하므로 X.509 v3 확장을 사용하지 않습니다. KeyIdentifier 확장이 있으면 효율성이 향상됩니다.

참고 2. CA가 최종 엔터티 인증서 중 하나의 유효 기간 동안 키 쌍을 두 번 이상 업데이트하는 경우를 포함하도록 체계를 일반화할 수 있지만 이러한 일반화의 가치는 모호합니다. 이러한 일반화가 없다는 것은 단순히 이전 CA 키 쌍으로 발급된 인증서의 유효 기간이 OldWithNew 유효 기간의 끝을 초과할 수 없음을 의미합니다.

참고 3. 이 체계는 최종 엔터티가 늦어도 이전 CA 개인 키로 서명된 마지막 인증서가 만료될 때까지 최종 엔터티가 새 CA 공개 키를 획득하도록 보장합니다\("대역 외" 수단을 통해\). . 다른 시간에 발생하는 인증서 및/또는 키 업데이트 작업에는 반드시 이것이 필요하지는 않습니다\(최종 개체의 장비에 따라 다름\).

---
#### **4.4.1.  CA Operator Actions**

CA의 키를 변경하기 위해 CA 운영자는 다음을 수행합니다.

```text
   1.  Generate a new key pair;

   2.  Create a certificate containing the old CA public key signed with
       the new private key (the "old with new" certificate);

   3.  Create a certificate containing the new CA public key signed with
       the old private key (the "new with old" certificate);

   4.  Create a certificate containing the new CA public key signed with
       the new private key (the "new with new" certificate);

   5.  Publish these new certificates via the repository and/or other
       means (perhaps using a CAKeyUpdAnn message);
```

6. 최종 엔터티가 "대역 외" 메커니즘\(필요한 경우\)을 사용하여 이를 획득할 수 있도록 새 CA 공개 키를 내보냅니다.

그러면 이전 CA 개인 키가 더 이상 필요하지 않습니다. 그러나 이전 CA 공개 키는 한동안 계속 사용됩니다. 이 CA의 모든 최종 엔터티가 새 CA 공개 키를 안전하게 획득한 경우 이전 CA 공개 키는 더 이상 필요하지 않습니다\(부인 방지 제외\).

"기존 및 신규" 인증서의 유효 기간은 기존 키 쌍의 생성 시간부터 시작하여 기존 공개 키의 만료 날짜까지 끝나야 합니다.

"기존과 함께 새로운" 인증서는 새로운 키 쌍이 생성된 시간부터 시작하여 이 CA의 모든 최종 엔터티가 새로운 CA 공개 키를 안전하게 소유하는 시간까지\(늦어도 만료되는\) 유효 기간을 가져야 합니다. 이전 공개 키의 날짜\).

"새 항목 포함" 인증서의 유효 기간은 새 키 쌍이 생성된 시간부터 시작하여 CA가 다음에 키 쌍을 업데이트하는 시간이나 그 이전에 끝나야 합니다.

---
#### **4.4.2.  Verifying Certificates**

일반적으로 서명을 확인할 때 확인자는 서명자의 공개 키가 포함된 인증서를 확인합니다. 그러나 CA가 키를 업데이트하도록 허용되면 다양한 새로운 가능성이 있습니다. 이는 아래 표에 나와 있습니다.

```text
                Repository contains NEW     Repository contains only OLD
                  and OLD public keys        public key (due to, e.g.,
                                              delay in publication)

                   PSE      PSE Contains  PSE Contains    PSE Contains
                Contains     OLD public    NEW public      OLD public
               NEW public       key            key            key
                   key

    Signer's   Case 1:      Case 3:       Case 5:        Case 7:
    certifi-   This is      In this case  Although the   In this case
    cate is    the          the verifier  CA operator    the CA
    protected  standard     must access   has not        operator  has
    using NEW  case where   the           updated the    not updated
    public     the          repository in repository the the repository
    key        verifier     order to get  verifier can   and so the
               can          the value of  verify the     verification
               directly     the NEW       certificate    will FAIL
               verify the   public key    directly -
               certificate                this is thus
               without                    the same as
               using the                  case 1.
               repository
```

서명자의 사례 2: 사례 4: 사례 6: 사례 8: 인증서- 이 경우 검증자는 범주가 사례이지만 검증자는 이 CA 운영자 보호 검증자가 직접적으로 OLD를 사용하지 않고 업데이트된 상황을 검증해야 한다고 생각합니다. 공개적으로 인증서 케이스 2에 액세스하고 저장소 저장소를 가져오기 위해 확인을 사용하기 위해 액세스 검증자가 없이 키 저장소에 액세스할 수 있습니다. 그러나 인증서 값은 직접적으로 공개 키이므로 이전 확인은 사례 4와 동일하게 실패합니다.

---
##### **4.4.2.1.  Verification in Cases 1, 4, 5, and 8**

이러한 경우 검증자는 인증서를 직접 검증하는 데 사용할 수 있는 CA 공개 키의 로컬 복사본을 가지고 있습니다. 이는 키 변경이 발생하지 않은 상황과 동일합니다.

CA 운영자가 새 키 쌍을 생성한 시간과 CA 운영자가 업데이트된 속성을 저장소에 저장하는 시간 사이에 사례 8이 발생할 수 있습니다. 사례 5는 다음 경우에만 발생할 수 있습니다.

```text
   the CA operator has issued both the signer's and verifier's
   certificates during this "gap" (the CA operator SHOULD avoid this as
   it leads to the failure cases described below)
```

---
##### **4.4.2.2.  Verification in Case 2**

2의 경우, 검증자는 CA의 이전 공개 키에 액세스해야 합니다. 검증자는 다음을 수행합니다.

```text
   1.  Look up the caCertificate attribute in the repository and pick
       the OldWithNew certificate (determined based on validity periods;
       note that the subject and issuer fields must match);

   2.  Verify that this is correct using the new CA key (which the
       verifier has locally);
```

3. 정확하다면 이전 CA 키를 사용하여 서명자의 인증서를 확인하십시오.

사례 2는 CA 운영자가 서명자의 인증서를 발급한 다음 키를 변경하고 검증자의 인증서를 발급한 경우에 발생합니다. 그래서 그것은 아주 전형적인 경우입니다.

---
##### **4.4.2.3.  Verification in Case 3**

3번의 경우, 검증자는 CA의 새로운 공개 키에 액세스해야 합니다. 검증자는 다음을 수행합니다.

```text
   1.  Look up the CACertificate attribute in the repository and pick
       the NewWithOld certificate (determined based on validity periods;
       note that the subject and issuer fields must match);

   2.  Verify that this is correct using the old CA key (which the
       verifier has stored locally);
```

3. 올바른 경우 새 CA 키를 사용하여 서명자의 인증서를 확인합니다.

사례 3은 CA 운영자가 검증자의 인증서를 발급한 후 키를 변경하고 서명자의 인증서를 발급한 경우에 발생합니다. 그래서 그것은 또한 매우 전형적인 경우입니다.

---
##### **4.4.2.4.  Failure of Verification in Case 6**

이 경우 CA는 저장소 속성을 업데이트하지 않고 새 키가 포함된 검증자의 PSE를 발행했습니다. 이는 검증자가 신뢰할 수 있는 CA 이전 키 버전을 얻을 수 있는 수단이 없으므로 검증이 실패함을 의미합니다.

실패는 CA 운영자의 잘못입니다.

---
##### **4.4.2.5.  Failure of Verification in Case 7**

이 경우 CA는 저장소 속성을 업데이트하지 않고 새 키로 보호되는 서명자의 인증서를 발급했습니다. 이는 검증자가 신뢰할 수 있는 버전의 CA 새 키를 얻을 수 없으므로 검증이 실패함을 의미합니다.

실패는 다시 CA 운영자의 잘못이라는 점에 유의하십시오.

---
#### **4.4.3.  Revocation - Change of CA Key**

위에서 본 것처럼 CA가 키 변경을 허용하면 인증서 확인이 더욱 복잡해집니다. CA가 사용자의 PSE에 있는 개인 키보다 새로운 개인 키를 사용하여 CRL에 서명했을 수 있으므로 해지 확인의 경우에도 마찬가지입니다.

대안 분석은 인증서 검증과 동일합니다.

---
## **5.  Data Structures**

이 섹션에는 PKI 관리 메시지에 필요한 데이터 구조에 대한 설명이 포함되어 있습니다. 섹션 6에서는 다양한 PKI 관리 작업 각각에 대한 값과 이벤트 순서에 대한 제약 조건을 설명합니다.

---
### **5.1.  Overall PKI Message**

PKI 관리 목적으로 본 사양에서 사용되는 모든 메시지는 다음 구조를 사용합니다.

```text
      PKIMessage ::= SEQUENCE {
         header           PKIHeader,
         body             PKIBody,
         protection   [0] PKIProtection OPTIONAL,
         extraCerts   [1] SEQUENCE SIZE (1..MAX) OF CMPCertificate
                          OPTIONAL
     }
     PKIMessages ::= SEQUENCE SIZE (1..MAX) OF PKIMessage
```

PKIHeader에는 많은 PKI 메시지에 공통적인 정보가 포함되어 있습니다.

PKIBody에는 메시지별 정보가 포함되어 있습니다.

PKIProtection을 사용하면 PKI 메시지를 보호하는 비트가 포함됩니다.

extraCerts 필드에는 수신자에게 유용할 수 있는 인증서가 포함될 수 있습니다. 예를 들어 CA 또는 RA는 자신의 새 인증서를 확인하는 데 필요한 인증서를 최종 엔터티에 제시하기 위해 CA 또는 RA에서 사용할 수 있습니다\(예를 들어 최종 엔터티의 인증서를 발급한 CA가 최종 엔터티의 루트 CA가 아닌 경우\). 실재\). 이 필드에는 반드시 인증 경로가 포함될 필요는 없습니다. 수신자는 추가 인증서를 사용하기 위해 추가 인증서를 정렬, 선택 또는 처리해야 할 수도 있습니다.

---
#### **5.1.1.  PKI Message Header**

모든 PKI 메시지에는 주소 지정 및 트랜잭션 식별을 위한 일부 헤더 정보가 필요합니다. 이 정보 중 일부는 운송 관련 봉투에도 들어 있습니다. 그러나 PKI 메시지가 보호되면 이 정보도 보호됩니다\(즉, 보안 전송에 대해 가정하지 않습니다\).

이 정보를 포함하는 데 다음 데이터 구조가 사용됩니다.

```text
     PKIHeader ::= SEQUENCE {
         pvno                INTEGER     { cmp1999(1), cmp2000(2) },
         sender              GeneralName,
         recipient           GeneralName,
         messageTime     [0] GeneralizedTime         OPTIONAL,
         protectionAlg   [1] AlgorithmIdentifier     OPTIONAL,
         senderKID       [2] KeyIdentifier           OPTIONAL,
         recipKID        [3] KeyIdentifier           OPTIONAL,
         transactionID   [4] OCTET STRING            OPTIONAL,
         senderNonce     [5] OCTET STRING            OPTIONAL,
         recipNonce      [6] OCTET STRING            OPTIONAL,
         freeText        [7] PKIFreeText             OPTIONAL,
         generalInfo     [8] SEQUENCE SIZE (1..MAX) OF
                             InfoTypeAndValue     OPTIONAL
     }
     PKIFreeText ::= SEQUENCE SIZE (1..MAX) OF UTF8String
```

이 사양 버전에서는 pvno 필드가 2로 고정되어 있습니다.

보낸 사람 필드에는 PKIMessage의 보낸 사람 이름이 포함됩니다. 이 이름\(제공된 경우 senderKID와 함께\)은 메시지의 보호를 확인하는 데 사용할 키를 나타내기에 충분해야 합니다. 송신 엔터티가 발신자에 대해 아무것도 모르는 경우\(예: init.req. 메시지에서 최종 엔터티가 자신의 고유 이름\(DN\), 이메일 이름, IP 주소 등을 알 수 없음\) "발신자" 필드는 "NULL" 값을 포함해야 합니다. 즉, SEQUENCE OF 상대 고유 이름의 길이는 0입니다. 이러한 경우 senderKID 필드는 메시지를 확인하는 데 사용할 적절한 공유 비밀 정보를 수신자에게 나타내는 식별자\(즉, 참조 번호\)를 보유해야 합니다.\(MUST, MUST\)

수신자 필드에는 PKIMessage 수신자의 이름이 포함됩니다. 이 이름\(제공된 경우 recipKID와 함께\)은 메시지의 보호를 확인하는 데 사용할 수 있어야 합니다.

protectionAlg 필드는 메시지를 보호하는 데 사용되는 알고리즘을 지정합니다. 보호 비트가 제공되지 않은 경우\(PKIProtection은 선택 사항임\) 이 필드는 생략되어야 합니다. 보호 비트가 제공되면 이 필드를 제공해야 합니다.\(MUST\)

senderKID 및 recipKID는 메시지를 보호하는 데 사용된 키를 나타내는 데 사용할 수 있습니다\(recipKID는 일반적으로 메시지 보호가 DH\(Diffie-Hellman\) 키를 사용하는 경우에만 필요합니다\).

이러한 필드는 키를 고유하게 식별해야 하는 경우\(예: 둘 이상의 키가 지정된 발신자 이름과 연결된 경우\) 반드시 사용해야 하며 그렇지 않은 경우 생략해야 합니다.\(MUST\)

메시지 헤더 내의 transactionID 필드는 메시지 수신자가 이를 진행 중인 트랜잭션과 연관시킬 수 있도록 하는 데 사용됩니다. 이는 단일 요청/응답 쌍 이상으로 구성된 모든 트랜잭션에 필요합니다. 단일 요청/응답 쌍으로 구성된 트랜잭션의 경우 규칙은 다음과 같습니다. 클라이언트는 요청의 transactionID 필드를 채울 수 있습니다. 서버가 transactionID 필드가 설정된 요청을 수신하면 응답의 transactionID 필드를 동일한 값으로 설정해야 합니다. 서버가 transactionID 필드가 누락된 요청을 받으면 응답의 transactionID 필드를 설정할 수 있습니다.\(MAY, MUST, MAY\)

단일 요청/응답 쌍 이상으로 구성된 트랜잭션의 경우 규칙은 다음과 같습니다. 클라이언트는 첫 번째 요청에 대해 transactionID를 생성해야 합니다\(SHOULD\). 서버가 transactionID 필드가 설정된 요청을 수신하면 응답의 transactionID 필드를 동일한 값으로 설정해야 합니다. 서버가 transactionID 필드가 누락된 요청을 수신한 경우 서버는 응답의 transactionID 필드를 서버 생성 ID로 채워야 합니다. 후속 요청과 응답은 모두 transactionID 필드를 설정된 값으로 설정해야 합니다. transactionID가 사용되는 모든 경우에, 주어진 클라이언트는 주어진 서버에 대해 언제든지 동일한 transactionID를 가진 두 개 이상의 트랜잭션을 진행해서는 안 됩니다. 서버는 메시지를 해당 트랜잭션과 올바르게 연결할 수 있는 한 transactionID의 고유성을 요구할지 여부를 자유롭게 결정할 수 있습니다. 일반적으로 이는 서버가 전송 수준 정보를 기반으로 클라이언트를 구별할 수 없는 경우 {client, transactionID} 튜플이 고유해야 하거나 transactionID만 고유해야 함을 의미합니다. 위의 제약 조건을 충족하는 것을 허용하지 않는 transactionID를 포함하는 트랜잭션\(단일 요청/응답 쌍 이상 필요\)의 첫 번째 메시지를 수신하는 서버는\(일반적으로 transactionID가 이미 사용 중이기 때문에\) ErrorMsgContent를 다시 보내야 합니다. transactionIdInUse의 PKIFailureInfo를 사용합니다. 서버에서 transactionID가 사용될 확률을 줄이기 위해 클라이언트는 트랜잭션 시작 시 transactionID 필드를 128비트의 \(의사\) 무작위 데이터로 채우는 것이 좋습니다.\(SHOULD, MUST, MUST, MUST, MUST NOT, MUST, SHOULD\)

senderNonce 및 recipNonce 필드는 재생 공격으로부터 PKIMessage를 보호합니다. senderNonce는 일반적으로 발신자가 생성한 128비트의 \(의사\) 무작위 데이터인 반면, recipNonce는 트랜잭션에서 이전 메시지의 senderNonce에서 복사됩니다.

messageTime 필드에는 보낸 사람이 메시지를 생성한 시간이 포함됩니다. 이는 최종 엔터티가 중앙 시스템의 시간과 일관성을 유지하기 위해 현지 시간을 수정/확인할 수 있도록 하는 데 유용할 수 있습니다.

freeText 필드는 사람이 읽을 수 있는 메시지를 수신자에게\(여러 언어로\) 보내는 데 사용될 수 있습니다. 이 시퀀스에서 사용되는 첫 번째 언어는 원하는 응답 언어를 나타냅니다.

GeneralInfo 필드는 기계가 처리할 수 있는 추가 데이터를 수신자에게 보내는 데 사용될 수 있습니다. 다음 GeneralInfo 확장이 정의되고 지원될 수 있습니다.\(MAY\)

---
##### **5.1.1.1.  ImplicitConfirm**

이는 EE가 발급된 인증서에 대한 인증서 확인을 보내고 싶지 않음을 CA에 알리는 데 사용됩니다.

```text
         implicitConfirm OBJECT IDENTIFIER ::= {id-it 13}
         ImplicitConfirmValue ::= NULL
```

CA가 EE에 요청을 승인하는 경우 응답의 PKIHeader에 동일한 확장자를 넣어야 합니다. EE가 응답에서 확장을 찾지 못한 경우 인증서 확인을 보내야 합니다.\(MUST, MUST\)

---
##### **5.1.1.2.  ConfirmWaitTime**

이는 CA에서 인증서를 취소하고 트랜잭션을 삭제하기 전에 인증서 확인을 기다리는 시간을 EE에 알리는 데 사용됩니다.

```text
         confirmWaitTime OBJECT IDENTIFIER ::= {id-it 14}
         ConfirmWaitTimeValue ::= GeneralizedTime
```

---
#### **5.1.2.  PKI Message Body**

```text
        PKIBody ::= CHOICE {
          ir       [0]  CertReqMessages,       --Initialization Req
          ip       [1]  CertRepMessage,        --Initialization Resp
          cr       [2]  CertReqMessages,       --Certification Req
          cp       [3]  CertRepMessage,        --Certification Resp
          p10cr    [4]  CertificationRequest,  --PKCS #10 Cert.  Req.
          popdecc  [5]  POPODecKeyChallContent --pop Challenge
          popdecr  [6]  POPODecKeyRespContent, --pop Response
          kur      [7]  CertReqMessages,       --Key Update Request
          kup      [8]  CertRepMessage,        --Key Update Response
          krr      [9]  CertReqMessages,       --Key Recovery Req

          krp      [10] KeyRecRepContent,      --Key Recovery Resp
          rr       [11] RevReqContent,         --Revocation Request
          rp       [12] RevRepContent,         --Revocation Response
          ccr      [13] CertReqMessages,       --Cross-Cert.  Request
          ccp      [14] CertRepMessage,        --Cross-Cert.  Resp
          ckuann   [15] CAKeyUpdAnnContent,    --CA Key Update Ann.
          cann     [16] CertAnnContent,        --Certificate Ann.
          rann     [17] RevAnnContent,         --Revocation Ann.
          crlann   [18] CRLAnnContent,         --CRL Announcement
          pkiconf  [19] PKIConfirmContent,     --Confirmation
          nested   [20] NestedMessageContent,  --Nested Message
          genm     [21] GenMsgContent,         --General Message
          genp     [22] GenRepContent,         --General Response
          error    [23] ErrorMsgContent,       --Error Message
          certConf [24] CertConfirmContent,    --Certificate confirm
          pollReq  [25] PollReqContent,        --Polling request
          pollRep  [26] PollRepContent         --Polling response
          }
```

구체적인 유형은 아래 섹션 5.3에 설명되어 있습니다.

---
#### **5.1.3.  PKI Message Protection**

일부 PKI 메시지는 무결성을 위해 보호됩니다. \(메시지를 보호하기 위해 비대칭 알고리즘이 사용되고 관련 공개 구성 요소가 이미 인증된 경우 메시지의 원본도 인증될 수 있습니다. 반면, 공개 구성 요소가 인증되지 않은 경우 메시지 원본도 인증될 수 있습니다. 자동으로 인증할 수는 없지만 대역 외 수단을 통해 인증할 수는 있습니다.\)

보호가 적용되면 다음 구조가 사용됩니다.

```text
        PKIProtection ::= BIT STRING
```

PKIProtection 계산에 대한 입력은 다음 데이터 구조의 DER 인코딩입니다.

```text
        ProtectedPart ::= SEQUENCE {
            header    PKIHeader,
            body      PKIBody
        }
```

PKIX 외부의 다른 보호가 대신 적용되기 때문에 PKIProtection BIT STRING이 메시지를 보호하기 위해 의도적으로 사용되지 않는 경우가 있을 수 있습니다\(즉, 이 OPTIONAL 필드는 생략됨\). 이러한 선택은 이 사양에서 명시적으로 허용됩니다. 이러한 외부 보호의 예로는 PKCS #7이 있습니다.\(MAY\)

\[PKCS7\] 및 보안 멀티파트 \[RFC1847\] PKIMessage\(또는 관련 PKIHeader 정보가 외부 메커니즘에 안전하게 전달되는 경우 간단히 PKIBody\(CHOICE 태그 생략\)\) 캡슐화. 그러나 많은 외부 메커니즘에서는 최종 엔터티가 공개 키 인증서 및/또는 고유한 고유 이름 및/또는 기타 인프라 관련 정보를 이미 보유하고 있어야 한다는 점에 유의해야 합니다. 따라서 초기 등록, 키 복구 또는 "부트 스트래핑" 특성이 있는 기타 프로세스에는 적합하지 않을 수 있습니다. 이러한 경우 PKIProtection 매개변수를 사용해야 할 수도 있습니다. 앞으로 부트 스트랩 시나리오를 수용하기 위해 외부 메커니즘이 수정되면 PKIProtection의 사용이 드물어지거나 존재하지 않게 될 수 있습니다.

상황에 따라 PKIProtection 비트에는 MAC\(메시지 인증 코드\) 또는 서명이 포함될 수 있습니다. 다음과 같은 경우만 발생할 수 있습니다.

---
##### **5.1.3.1.  Shared Secret Information**

이 경우 발신자와 수신자는 비밀 정보\(대역 외 수단을 통해 또는 이전 PKI 관리 작업을 통해 설정됨\)를 공유합니다. PKIProtection에는 MAC 값이 포함되며 protectionAlg는 다음과 같습니다\(부록 D.2 참조\).

```text
     id-PasswordBasedMac OBJECT IDENTIFIER ::= {1 2 840 113533 7 66 13}
     PBMParameter ::= SEQUENCE {
       salt                OCTET STRING,
       owf                 AlgorithmIdentifier,
       iterationCount      INTEGER,
       mac                 AlgorithmIdentifier
     }
```

위의 protectionAlg에서는 솔트 값이 공유 비밀 입력에 추가됩니다. 그런 다음 OWF는 iterationCount 횟수만큼 적용됩니다. 여기서 솔트 처리된 비밀은 첫 번째 반복에 대한 입력이고 각 연속 반복에 대해 입력은 이전 반복의 출력으로 설정됩니다. 최종 반복의 출력\(참조의 편의를 위해 "BASEKEY"라고 하며 크기는 "H"임\)은 대칭 키를 형성하는 데 사용됩니다. MAC 알고리즘에 K 비트 키가 필요하고 K <= H인 경우 BASEKEY의 최상위 K 비트가 사용됩니다. K \> H이면 모든 BASEKEY가 키의 최상위 H 비트에 사용되고 OWF\("1" || BASEKEY\)는 키의 다음 최상위 H 비트에 사용되며 OWF\("2" || BASEKEY\)는 키의 다음으로 중요한 H 비트에 사용되며 모든 K 비트가 파생될 때까지 계속됩니다. \[여기서 "N"은 숫자 N과 "||"를 인코딩하는 ASCII 바이트입니다. 연결을 나타냅니다.\]

참고: PasswordBasedMac 계산과 관련된 오버헤드를 줄이기 위해 단일 트랜잭션\(예: ir/ip/certConf/pkiConf\)의 메시지 전체에서 PBMParameter 필드를 일정하게 유지하는 것이 좋습니다.\(SHOULD\)

---
##### **5.1.3.2.  DH Key Pairs**

발신자와 수신자가 호환되는 DH 매개변수가 있는 Diffie-Hellman 인증서를 소유한 경우, 메시지를 보호하기 위해 최종 엔터티는 개인 DH 키 값과 PKI 메시지 수신자의 DH 공개 키를 기반으로 대칭 키를 생성해야 합니다. PKIProtection에는 파생된 대칭 키로 입력된 MAC 값이 포함되며 protectionAlg는 다음과 같습니다.

```text
        id-DHBasedMac OBJECT IDENTIFIER ::= {1 2 840 113533 7 66 30}

        DHBMParameter ::= SEQUENCE {
            owf                 AlgorithmIdentifier,
            -- AlgId for a One-Way Function (SHA-1 recommended)
            mac                 AlgorithmIdentifier
            -- the MAC AlgId (e.g., DES-MAC, Triple-DES-MAC [PKCS11],
        }   -- or HMAC [RFC2104, RFC2202])
```

위의 protectionAlg에서는 Diffie-Hellman 계산 결과에 OWF가 적용됩니다. OWF 출력\(참조하기 쉽게 "BASEKEY"라고 하며 크기는 "H"임\)은 대칭 키를 형성하는 데 사용됩니다. MAC 알고리즘에 K 비트 키가 필요하고 K <= H인 경우 BASEKEY의 최상위 K 비트가 사용됩니다. K \> H이면 모든 BASEKEY가 키의 최상위 H 비트에 사용되고 OWF\("1" || BASEKEY\)는 키의 다음 최상위 H 비트에 사용되며 OWF\("2" || BASEKEY\)는 키의 다음으로 중요한 H 비트에 사용되며 모든 K 비트가 파생될 때까지 계속됩니다. \[여기서 "N"은 숫자 N과 "||"를 인코딩하는 ASCII 바이트입니다. 연결을 나타냅니다.\]

---
##### **5.1.3.3.  Signature**

이 경우 보낸 사람은 서명 키 쌍을 보유하고 있으며 단순히 PKI 메시지에 서명합니다. PKIProtection에는 서명 값이 포함되며 protectionAlg는 디지털 서명에 대한 AlgorithmIdentifier\(예: md5WithRSAEncryption 또는 dsaWithSha-1\)가 됩니다.

---
##### **5.1.3.4.  Multiple Protection**

최종 엔터티가 보호된 PKI 메시지를 RA에 보내는 경우, RA는 자체 보호\(RA와 RA 사이에 공유되는 정보 및 인증서에 따라 MAC 또는 서명일 수 있음\)를 첨부하여 해당 메시지를 CA에 전달할 수 있습니다. 캐나다\). 이것이 성취된다\(MAY\)

최종 엔터티가 보낸 전체 메시지를 새 PKI 메시지 내에 중첩합니다. 사용된 구조는 다음과 같습니다.

```text
          NestedMessageContent ::= PKIMessages
```

\(PKIMessage의 SEQUENCE인 PKIMessages를 사용하면 RA가 여러 EE의 요청을 단일 새 메시지로 일괄 처리할 수 있습니다. 단순화를 위해 일괄 처리의 모든 메시지는 동일한 유형\(예: ir\)이어야 합니다.\) 어떤 방식으로든\(예: 특정 필드 값 또는 새 확장 추가\) 메시지를 수정하려는 경우 원하는 PKIBody를 직접 생성할 수 있습니다. EE의 원본 PKIMessage는 PKIHeader의 GeneralInfo 필드에 포함될 수 있습니다\(예를 들어 CA가 원본 EE 메시지의 POP 또는 기타 정보를 확인하려는 경우를 수용하기 위해\). 이 상황에서 사용되는 infoType은 {id-it 15}\(id-it 값은 섹션 5.3.19 참조\)이고 infoValue는 PKIMessages입니다\(콘텐츠는 PKIBody의 요청과 동일한 순서여야 합니다\).\(MUST, MAY, MUST\)

---
### **5.2.  Common Data Structures**

PKIBody에 배치할 수 있는 특정 유형을 지정하기 전에 둘 이상의 경우에 사용되는 일부 데이터 구조를 정의합니다.

---
#### **5.2.1.  Requested Certificate Contents**

다양한 PKI 관리 메시지에서는 메시지 작성자가 인증서에 있어야 하는 일부 필드를 나타내도록 요구합니다. CertTemplate 구조를 사용하면 최종 엔터티 또는 RA가 필요한 인증서에 대해 원하는 만큼 지정할 수 있습니다. CertTemplate은 인증서와 동일하지만 모든 필드가 선택 사항입니다.

작성자가 필요한 인증서의 내용을 완전히 지정하더라도 CA는 실제로 발급된 인증서 내의 필드를 자유롭게 수정할 수 있습니다. 수정된 인증서가 요청자가 수락할 수 없는 경우 요청자는 이 인증서를 포함하지 않거나\(CertHash를 통해\) 이 인증서를 포함하는\(CertHash를 통해\) "거부됨" 상태와 함께 certConf 메시지를 다시 보내야 합니다. CertHash 및 certConf 메시지의 정의 및 사용에 대해서는 섹션 5.3.18을 참조하세요.\(MUST\)

CertTemplate 구문은 부록 C 및 \[CRMF\]를 참조하세요.

---
#### **5.2.2.  Encrypted Values**

암호화된 값\(이 사양에서는 개인 키 또는 인증서로 제한됨\)이 PKI 메시지로 전송되는 경우 EncryptedValue 데이터 구조가 사용됩니다.

EncryptedValue 구문은 \[CRMF\]를 참조하세요.

이 데이터 구조를 사용하려면 생성자와 의도된 수신자가 각각 암호화하고 해독할 수 있어야 합니다. 일반적으로 이는 보낸 사람과 받는 사람이 공유 비밀 키를 가지고 있거나 생성할 수 있음을 의미합니다.

PKIMessage의 수신자가 이미 복호화에 사용할 수 있는 개인 키를 소유하고 있는 경우 encSymmKey 필드에는 수신자의 공개 키를 사용하여 암호화된 세션 키가 포함될 수 있습니다.\(MAY\)

---
#### **5.2.3.  Status codes and Failure Information for PKI Messages**

모든 응답 메시지에는 일부 상태 정보가 포함됩니다. 다음 값이 정의됩니다.

```text
        PKIStatus ::= INTEGER {
            accepted               (0),
            grantedWithMods        (1),
            rejection              (2),
            waiting                (3),
            revocationWarning      (4),
            revocationNotification (5),
            keyUpdateWarning       (6)
        }
```

응답자는 다음 구문을 사용하여 실패 사례에 대한 추가 정보를 제공할 수 있습니다.

```text
        PKIFailureInfo ::= BIT STRING {
            badAlg              (0),
            badMessageCheck     (1),
            badRequest          (2),
            badTime             (3),
            badCertId           (4),
            badDataFormat       (5),
            wrongAuthority      (6),
            incorrectData       (7),
            missingTimeStamp    (8),
            badPOP              (9),
            certRevoked         (10),
            certConfirmed       (11),
            wrongIntegrity      (12),
            badRecipientNonce   (13),
            timeNotAvailable    (14),
            unacceptedPolicy    (15),
            unacceptedExtension (16),
            addInfoNotAvailable (17),

            badSenderNonce      (18),
            badCertTemplate     (19),
            signerNotTrusted    (20),
            transactionIdInUse  (21),
            unsupportedVersion  (22),
            notAuthorized       (23),
            systemUnavail       (24),
            systemFailure       (25),
            duplicateCertReq    (26)
        }

        PKIStatusInfo ::= SEQUENCE {
            status        PKIStatus,
            statusString  PKIFreeText     OPTIONAL,
            failInfo      PKIFailureInfo  OPTIONAL
        }
```

---
#### **5.2.4.  Certificate Identification**

특정 인증서를 식별하기 위해 CertId 데이터 구조가 사용됩니다.

CertId 구문은 \[CRMF\]를 참조하세요.

---
#### **5.2.5.  Out-of-band root CA Public Key**

각 루트 CA는 "대역 외" 수단을 통해 현재 공개 키를 게시할 수 있어야 합니다. 그러한 메커니즘은 이 문서의 범위를 벗어나지만 우리는 그러한 메커니즘을 지원할 수 있는 데이터 구조를 정의합니다.

일반적으로 두 가지 방법을 사용할 수 있습니다. 즉, CA가 자체 서명된 인증서를 직접 게시하거나 이 정보를 디렉터리\(또는 이에 상응하는 인증서\)를 통해 사용할 수 있고 CA는 사용하기 전에 무결성을 확인할 수 있도록 이 값의 해시를 게시합니다.

```text
        OOBCert ::= Certificate
```

이 인증서 내의 필드는 다음과 같이 제한됩니다.

```text
   o  The certificate MUST be self-signed (i.e., the signature must be
      verifiable using the SubjectPublicKeyInfo field);

   o  The subject and issuer fields MUST be identical;

   o  If the subject field is NULL, then both subjectAltNames and
      issuerAltNames extensions MUST be present and have exactly the
      same value;
```

o 다른 모든 확장의 값은 자체 서명된 인증서에 적합해야 합니다\(예: 주체와 발급자의 키 식별자가 동일해야 함\).

```text
        OOBCertHash ::= SEQUENCE {
            hashAlg     [0] AlgorithmIdentifier     OPTIONAL,
            certId      [1] CertId                  OPTIONAL,
            hashVal         BIT STRING
        }
```

해시 값의 목적은 해시 값을 안전하게 수신한 사람\(대역 외 수단을 통해\) 누구나 해당 CA에 대해 자체 서명된 인증서를 확인할 수 있도록 하는 것입니다.

---
#### **5.2.6.  Archive Options**

요청자는 PKIArchiveOptions 구조를 사용하여 PKI가 개인 키 값을 보관하기를 원한다고 나타낼 수 있습니다.

PKIArchiveOptions 구문은 \[CRMF\]를 참조하세요.

---
#### **5.2.7.  Publication Information**

요청자는 PKI가 PKIPublicationInfo 구조를 사용하여 인증서를 게시하기를 원한다고 나타낼 수 있습니다.

PKIPublicationInfo 구문은 \[CRMF\]를 참조하세요.

---
#### **5.2.8.  Proof-of-Possession Structures**

인증 요청이 서명 키 쌍에 대한 것인 경우\(예: 확인 인증서 요청\) 개인 서명 키의 소유 증명은 POPOSigningKey 구조를 사용하여 입증됩니다.

POPOSigningKey 구문은 부록 C와 \[CRMF\]를 참조하세요. 하지만 이 사양에서 POPOSigningKeyInput에는 다음과 같은 의미 규정이 있다는 점에 유의하세요.

```text
        POPOSigningKeyInput ::= SEQUENCE {
            authInfo            CHOICE {
                sender              [0] GeneralName,
                publicKeyMAC            PKMACValue
            },
            publicKey           SubjectPublicKeyInfo
        }
```

반면에, 인증 요청이 암호화 키 쌍에 대한 것인 경우\(즉, 암호화 인증서 요청\), 개인 복호화 키의 소유 증명은 세 가지 방법 중 하나로 입증될 수 있습니다.

---
##### **5.2.8.1.  Inclusion of the Private Key**

CertRequest\(POPOPrivKey의 thisMessage 필드\(부록 C 참조\) 또는 PKIArchiveOptions 제어 구조, 개인 키 보관도 원하는지 여부에 따라\)에 개인 키\(암호화됨\)를 포함합니다.

---
##### **5.2.8.2.  Indirect Method**

CA가 인증서가 아닌 암호화된 인증서\(즉, 무작위로 생성된 대칭 키로 암호화된 인증서와 인증 요청이 이루어지는 공개 키로 암호화된 대칭 키\)를 반환하도록 함으로써 이것이 가능합니다. 섹션 4.3.2에서 앞서 언급한 "간접" 방법. 최종 엔터티는 certConf 메시지에서 이 인증서에 대한 올바른 CertHash를 제공하여 CA에 개인 암호 해독 키에 대한 지식을 증명합니다. 이는 EE가 인증서를 복구할 수 있는 경우에만 올바른 CertHash를 계산할 수 있고 필요한 개인 키를 사용하여 대칭 키를 해독할 수 있는 경우에만 인증서를 복구할 수 있기 때문에 POP를 보여줍니다. 분명히 이것이 작동하려면 CA는 certConf 메시지가 도착할 때까지\(certHash가 POP를 보여주기 위해 사용될 때\) 인증서를 게시해서는 안 됩니다. 자세한 내용은 섹션 5.3.18을 참조하세요.\(MUST NOT\)

---
##### **5.2.8.3.  Challenge-Response Protocol**

최종 엔터티가 CertReqMessages와 CertRepMessage 사이의 시도-응답 프로토콜\(POPODecKeyChall 및 POPODecKeyResp 메시지 사용, 아래 참조\)에 참여하게 함으로써 -- 이것은 앞서 섹션 4.3.2에서 언급한 "직접" 방법입니다. \(이 방법은 일반적으로 RA가 POP를 확인한 후 최종 엔터티를 대신하여 CA에 인증 요청을 하는 환경에서 사용됩니다. 이러한 시나리오에서 CA는 RA가 RA 이전에 POP를 올바르게 수행했다고 신뢰합니다. 최종 엔터티에 대한 인증서를 요청합니다.\) 전체 프로토콜은 다음과 같습니다\(req'가 반드시 req를 중첩된 메시지로 캡슐화하는 것은 아닙니다\).

```text
                   EE            RA            CA
                    ---- req ---->
                    <--- chall ---
                    ---- resp --->
                                  ---- req' --->
                                  <--- rep -----
                                  ---- conf --->
                                  <--- ack -----
                    <--- rep -----
                    ---- conf --->
                    <--- ack -----
```

이 프로토콜은 분명히 위의 선택\(2\)에 제공된 3방향 교환보다 훨씬 길지만 지역 등록 기관이 참여할 수 있도록 허용하고 소유 증명이 완료될 때까지 인증서 자체가 실제로 생성되지 않는다는 속성을 가지고 있습니다. . 일부 환경에서는 다음과 같이 위 메시지의 다른 순서가 필요할 수 있습니다\(이는 정책에 따라 결정될 수 있음\).

```text
                   EE            RA            CA
                    ---- req ---->
                    <--- chall ---
                    ---- resp --->
                                  ---- req' --->
                                  <--- rep -----
                    <--- rep -----
                    ---- conf --->
                                  ---- conf --->
                                  <--- ack -----
                    <--- ack -----
```

인증서의 경우. 요청이 KAK\(키 계약 키\) 쌍에 대한 것인 경우 POP는 enc에 대해 위에 설명된 3가지 방법 중 하나를 사용할 수 있습니다. \(1\) 글머리 기호 2의 괄호 텍스트\)는 "\(즉, CA의 개인 KAK에서 파생된 대칭 키와 인증 요청이 이루어지는 공개 키로 암호화된 인증서\)로 대체됩니다. \)"; \(2\) 아래 "Challenge"의 챌린지 필드의 첫 번째 괄호 텍스트는 "\(PreferredSymmAlg\(섹션 5.3.19.4 및 부록 E.5 참조\) 사용\)와 CA의 개인 KAK에서 파생된 대칭 키 및 공개 키로 대체됩니다. 인증 요청이 이루어지고 있음\)'을 참조하세요. 대안으로, CA가 EE에 알려진 D-H 인증서를 이미 가지고 있는 경우 POP는 POP를 입증하기 위한 네 번째 대안으로 \[CRMF\]\(여기서 alg 필드는 DHBasedMAC이고 서명 필드는 MAC임\)에 제공된 POPOSigningKey 구조를 사용할 수 있습니다. .

개인 복호화 키 소유 증명을 위한 시도-응답 메시지는 다음과 같이 지정됩니다\(자세한 내용은 \[MvOV97\], p.404 참조\). 이 시도-응답 교환은 이전 인증서와 연결되어 있습니다. PKIHeader에 사용된 transactionID와 PKIMessage에 적용된 보호\(MACing 또는 서명\)에 의한 요청 메시지\(및 후속 인증서 응답 및 확인 메시지\).

```text
        POPODecKeyChallContent ::= SEQUENCE OF Challenge
        Challenge ::= SEQUENCE {
            owf                 AlgorithmIdentifier  OPTIONAL,
            witness             OCTET STRING,
            challenge           OCTET STRING
        }
```

Rand의 크기는 요청자의 공개 키에 따른 암호화에 적합해야 합니다. "int"가 일반적으로 64비트보다 길지 않다는 점을 고려하면 모듈러스가 1024비트일 때 "sender" 필드에 100바이트가 넘는 공간이 남습니다. 일부 환경에서 이름이 너무 길어서 들어갈 수 없는 경우\(예: 매우 긴 DN\), 들어갈 수 있는 부분은 무엇이든 사용해야 합니다\(적어도 일반 이름이 포함되어 있고 수신자가 가능한 한\). 약어를 의미있게 다루기 위해\).

```text
        POPODecKeyRespContent ::= SEQUENCE OF INTEGER
```

---
##### **5.2.8.4.  Summary of PoP Options**

이 섹션의 텍스트는 POP 기술과 관련된 몇 가지 옵션을 제공합니다. "서명 키"에 "SK"를, "암호화 키"에 "EK"를, "키 일치 키"에 "KAK"를 사용하는 기술은 다음과 같이 요약할 수 있습니다.

RA인증됨;

- SK팝; EKPOP이메시지; KAKPOP이메시지; KAKPOP이메시지DHMAC; EKPOP암호화된인증서; KAKPOP암호화된인증서; EKPOPChallengeResp; 및 KAKPOPChallengeResp.

이러한 옵션 배열이 주어지면 최종 개체가 CA/RA에서 지원하는 것\(즉, 인증서를 요청할 때 사용할 수 있는 옵션\)을 어떻게 알 수 있는지 묻는 것이 당연합니다. 다음 지침은 EE 구현자에게 이러한 상황을 명확히 해야 합니다.

RA인증됨. 이는 EE 결정이 아닙니다. RA는 요청을 CA에 전달하기 전에 POP를 확인한 경우에만 이를 사용하므로 EE가 이 기술을 선택하는 것은 불가능합니다.

SK팝. EE에 서명 키 쌍이 있는 경우 이는 해당 인증서 요청에 사용하도록 지정된 유일한 POP 방법입니다.

EKPOPThisMessage 및 KAKPOPThisMessage. CA/RA에 개인 키를 포기할지 여부는 EE의 결정입니다. EE가 키를 공개하기로 결정한 경우 이 사양에서 이를 달성하기 위해 사용할 수 있는 유일한 POP 방법은 다음과 같습니다. 키 쌍 유형에 따라 이 두 가지 방법 중 어떤 방법을 사용할지 결정됩니다.

KAKPOP이메시지DHMAC. EE는 \(1\) CA에 이 목적으로 사용할 수 있는 DH 인증서가 있고 \(2\) EE에 이미 이 인증서의 복사본이 있는 경우에만 이 방법을 사용할 수 있습니다. 이러한 조건이 모두 충족되면 이 기술은 명확하게 지원되며 원하는 경우 EE에서 사용할 수 있습니다.

EKPOPEncryptedCert, KAKPOPEncryptedCert, EKPOPChallengeResp, KAKPOPChallengeResp. EE는 기본 설정 및 키 쌍 유형에 따라 요청 메시지에서 이들 중 하나\(이후 메시지 필드에서\)를 선택합니다. EE는 현재 POP를 수행하지 않습니다. 이는 단순히 어떤 방법을 사용하고 싶은지 나타내는 것입니다. 따라서 CA/RA가 "badPOP" 오류로 응답하면 EE는 후속 메시지에서 선택한 다른 POP 방법을 사용하여 다시 요청할 수 있습니다. 그러나 이 사양에서는 EncryptedCert 선택의 사용을 권장하며 더 나아가 RA가 관련되어 POP 검증을 수행할 때 시도-응답이 일반적으로 사용된다고 말합니다. 따라서 EE는 요청 메시지에서 이러한 POP 방법 중 어떤 방법을 선택할지에 관해 지능적인 결정을 내릴 수 있어야 합니다.

---
### **5.3.  Operation-Specific Data Structures**
---
#### **5.3.1.  Initialization Request**

초기화 요청 메시지에는 요청된 인증서를 지정하는 CertReqMessages 데이터 구조가 PKIBody로 포함되어 있습니다. 일반적으로 SubjectPublicKeyInfo, KeyId 및 Validity는 요청된 각 인증서에 대해 제공될 수 있는 템플릿 필드입니다\(자세한 내용은 부록 D 프로필 참조\). 이 메시지는 PKI를 처음 초기화할 때 엔터티에 사용하기 위한 것입니다.

CertReqMessages 구문은 부록 C 및 \[CRMF\]를 참조하세요.

---
#### **5.3.2.  Initialization Response**

초기화 응답 메시지에는 요청된 각 인증서에 대해 PKIStatusInfo 필드, 주체 인증서 및 개인 키\(일반적으로 자체적으로는 프로토콜EncrKey로 암호화되는 세션 키로 암호화됨\)를 포함하는 CertRepMessage 데이터 구조가 PKIBody로 포함됩니다.

CertRepMessage 구문은 섹션 5.3.4를 참조하세요. PKI 메시지 보호가 "공유 비밀 정보"\(섹션 5.1.3 참조\)인 경우 caPubs 필드에서 전송된 모든 인증서는 개시자에 의해 루트 CA 인증서로 직접 신뢰될 수 있습니다.

---
#### **5.3.3.  Certification Request**

인증 요청 메시지에는 요청된 인증서를 지정하는 CertReqMessages 데이터 구조가 PKIBody로 포함되어 있습니다. 이 메시지는 추가 인증서를 얻으려는 기존 PKI 엔터티에 사용하기 위한 것입니다.

CertReqMessages 구문은 부록 C 및 \[CRMF\]를 참조하세요.

대안으로, PKIBody는 CertificationRequest일 수 있습니다\(이 구조는 \[PKCS10\]에 제공된 ASN.1 구조 CertificationRequest에 의해 완전히 지정됩니다\). 이 구조는 레거시 시스템과의 상호 운용이 필요할 때 키 쌍 서명을 위한 인증서 요청에 필요할 수 있지만 꼭 필요한 경우가 아니면 사용하지 않는 것이 좋습니다.\(MAY\)

---
#### **5.3.4.  Certification Response**

인증 응답 메시지에는 요청된 각 인증서에 대한 상태 값이 있고 선택적으로 CA 공개 키, 실패 정보, 주체 인증서 및 암호화된 개인 키가 있는 CertRepMessage 데이터 구조가 PKIBody로 포함됩니다.

```text
     CertRepMessage ::= SEQUENCE {
         caPubs          [1] SEQUENCE SIZE (1..MAX) OF Certificate
                             OPTIONAL,
         response            SEQUENCE OF CertResponse
     }

     CertResponse ::= SEQUENCE {
         certReqId           INTEGER,
         status              PKIStatusInfo,
         certifiedKeyPair    CertifiedKeyPair    OPTIONAL,
         rspInfo             OCTET STRING        OPTIONAL
         -- analogous to the id-regInfo-utf8Pairs string defined

         -- for regInfo in CertReqMsg [CRMF]
     }

     CertifiedKeyPair ::= SEQUENCE {
         certOrEncCert       CertOrEncCert,
         privateKey      [0] EncryptedValue      OPTIONAL,
         -- see [CRMF] for comment on encoding
         publicationInfo [1] PKIPublicationInfo  OPTIONAL
     }

     CertOrEncCert ::= CHOICE {
         certificate     [0] Certificate,
         encryptedCert   [1] EncryptedValue
     }
```

각 CertResponse에는 \(상태에 따라\) failureInfo\(PKIStatusInfo\) 및 인증서\(CertifiedKeyPair\) 필드 중 하나만 존재할 수 있습니다. 일부 상태 값\(예: 대기 중\)의 경우 선택 필드가 모두 표시되지 않습니다.

EncryptedCert와 관련 암호 해독 키가 주어지면 인증서를 얻을 수 있습니다. 이것의 목적은 CA가 인증서 값을 반환할 수 있도록 허용하는 것이지만, 의도한 수신자만 실제 인증서를 얻을 수 있다는 제약 조건이 있습니다. 이 접근 방식의 이점은 요청자가 관련 개인 키를 사용할 수 있는 최종 엔터티라는 증거가 없더라도 CA가 인증서로 응답할 수 있다는 것입니다. 캐나다\). 따라서 CA는 소유 증명에 문제가 있는 경우 해당 인증서를 취소할 필요가 없습니다\(그러나 정책에 따라 어쨌든 그렇게 할 수 있음\).\(MAY\)

---
#### **5.3.5.  Key Update Request Content**

키 업데이트 요청의 경우 CertReqMessages 구문이 사용됩니다. 일반적으로 SubjectPublicKeyInfo, KeyId 및 Validity는 업데이트할 각 키에 대해 제공될 수 있는 템플릿 필드입니다. 이 메시지는 기존\(해지되지 않고 만료되지 않은\) 인증서에 대한 업데이트를 요청하는 데 사용됩니다\(따라서 "인증서 업데이트" 작업이라고도 함\). 업데이트는 새로운 주체 공개 키 또는 현재 주체 공개 키\(후자의 방식이 일부 환경에는 적합하지 않을 수 있음\)를 포함하는 대체 인증서입니다.

CertReqMessages 구문은 부록 C 및 \[CRMF\]를 참조하세요.

---
#### **5.3.6.  Key Update Response Content**

키 업데이트 응답에는 CertRepMessage 구문이 사용됩니다. 응답은 초기화 응답과 동일합니다.

CertRepMessage 구문은 섹션 5.3.4를 참조하세요.

---
#### **5.3.7.  Key Recovery Request Content**

키 복구 요청의 경우 사용되는 구문은 초기화 요청 CertReqMessages와 동일합니다. 일반적으로 SubjectPublicKeyInfo 및 KeyId는 인증서가 필요한 서명 공개 키를 제공하는 데 사용할 수 있는 템플릿 필드입니다\(자세한 내용은 부록 D 프로필 참조\).

CertReqMessages 구문은 부록 C 및 \[CRMF\]를 참조하세요. 키 기록이 필요한 경우 요청자는 요청 메시지에 프로토콜 암호화 키 컨트롤을 제공해야 합니다.

---
#### **5.3.8.  Key Recovery Response Content**

키 복구 응답에는 다음 구문이 사용됩니다. 일부 상태 값\(예: 대기 중\)의 경우 선택 필드가 표시되지 않습니다.

```text
    KeyRecRepContent ::= SEQUENCE {
        status          PKIStatusInfo,
        newSigCert  [0] Certificate                   OPTIONAL,
        caCerts     [1] SEQUENCE SIZE (1..MAX) OF
                                     Certificate      OPTIONAL,
        keyPairHist [2] SEQUENCE SIZE (1..MAX) OF
                                     CertifiedKeyPair OPTIONAL
    }
```

---
#### **5.3.9.  Revocation Request Content**

하나의 인증서\(또는 여러 인증서\)의 폐지를 요청할 때 다음과 같은 데이터 구조가 사용됩니다. 요청자의 이름은 PKIHeader 구조에 있습니다.

```text
    RevReqContent ::= SEQUENCE OF RevDetails

    RevDetails ::= SEQUENCE {
        certDetails         CertTemplate,
        crlEntryDetails     Extensions       OPTIONAL
    }
```

---
#### **5.3.10.  Revocation Response Content**

철회 응답은 위 메시지에 대한 응답입니다. 생성된 경우 철회 요청자에게 전송됩니다. \(폐기가 요청된 인증서의 주체에게 별도의 폐기 알림 메시지가 전송될 수 있습니다.\)\(MAY\)

```text
     RevRepContent ::= SEQUENCE {
         status        SEQUENCE SIZE (1..MAX) OF PKIStatusInfo,
         revCerts  [0] SEQUENCE SIZE (1..MAX) OF CertId OPTIONAL,
         crls      [1] SEQUENCE SIZE (1..MAX) OF CertificateList
                       OPTIONAL
     }
```

---
#### **5.3.11.  Cross Certification Request Content**

교차 인증 요청은 일반 인증 요청과 동일한 구문\(CertReqMessages\)을 사용하며, 키 쌍은 요청 CA에 의해 생성되어야 하고 개인 키는 응답 CA로 전송되어서는 안 된다는 제한 사항이 있습니다. 이 요청은 하위 CA가 상위 CA의 서명을 받은 인증서를 얻기 위해 사용될 수도 있습니다.\(MUST NOT, MAY\)

CertReqMessages 구문은 부록 C 및 \[CRMF\]를 참조하세요.

---
#### **5.3.12.  Cross Certification Response Content**

교차 인증 응답은 일반 인증 응답과 동일한 구문\(CertRepMessage\)을 사용하며 암호화된 개인 키를 보낼 수 없다는 제한이 있습니다.

CertRepMessage 구문은 섹션 5.3.4를 참조하세요.

---
#### **5.3.13.  CA Key Update Announcement Content**

CA가 자체 키 쌍을 업데이트하면 다음 데이터 구조를 사용하여 이 이벤트를 알릴 수 있습니다.\(MAY\)

```text
    CAKeyUpdAnnContent ::= SEQUENCE {
       oldWithNew         Certificate,
       newWithOld         Certificate,
       newWithNew         Certificate
    }
```

---
#### **5.3.14.  Certificate Announcement**

이 구조는 인증서의 존재를 알리는 데 사용될 수 있습니다.\(MAY\)

이 메시지는 인증서 게시를 위한 기존 방법이 없는 경우\(있는 경우\)에 사용하기 위한 것입니다. 예를 들어 X.500이 인증서 게시 방법인 경우에는 사용할 수 없습니다.

```text
        CertAnnContent ::= Certificate
```

---
#### **5.3.15.  Revocation Announcement**

CA가 특정 인증서를 폐지했거나 폐지하려고 할 때 이\(아마도 다가오는\) 이벤트에 대한 공지를 발행할 수 있습니다.\(MAY\)

```text
        RevAnnContent ::= SEQUENCE {
            status              PKIStatus,
            certId              CertId,
            willBeRevokedAt     GeneralizedTime,
            badSinceDate        GeneralizedTime,
            crlDetails          Extensions  OPTIONAL
        }
```

CA는 인증서가 곧 취소될 예정\(또는 취소됨\)을 주체에게 경고\(또는 통지\)하기 위해 이러한 공지를 사용할 수 있습니다. 이는 일반적으로 취소 요청이 관련 주제에서 나오지 않은 경우에 사용됩니다.\(MAY\)

willBeRevokedAt 필드에는 관련 CRL에 새 항목이 추가되는 시간이 포함됩니다.

---
#### **5.3.16.  CRL Announcement**

CA가 새로운 CRL\(또는 CRL 세트\)을 발행할 때 이 이벤트를 알리기 위해 다음 데이터 구조를 사용할 수 있습니다.\(MAY\)

```text
        CRLAnnContent ::= SEQUENCE OF CertificateList
```

---
#### **5.3.17.  PKI Confirmation Content**

이 데이터 구조는 프로토콜 교환에서 최종 PKIMessage로 사용됩니다. 그 내용은 모든 경우에 동일합니다. PKIHeader가 필요한 모든 정보를 전달하므로 실제로는 내용이 없습니다.

```text
        PKIConfirmContent ::= NULL
```

인증서 확인을 위해 이 메시지를 사용하는 것은 권장되지 않습니다. 대신 certConf를 사용해야 합니다. 인증서 응답에 대한 PKIConfirm을 수신하면 수신자는 이를 모든 인증서가 승인된 certConf로 처리할 수 있습니다.\(SHOULD NOT, MAY\)

---
#### **5.3.18.  Certificate Confirmation Content**

이 데이터 구조는 클라이언트가 CA/RA에 인증서 수락 또는 거부 확인을 보내는 데 사용됩니다.

- CertConfirmContent ::= CertStatus의 순서

```text
         CertStatus ::= SEQUENCE {
            certHash    OCTET STRING,
            certReqId   INTEGER,
            statusInfo  PKIStatusInfo OPTIONAL
         }
```

특정 CertStatus의 경우 statusInfo 필드가 생략되면 지정된 인증서가 승인되었음을 나타냅니다. 또는 CA/RA의 감사 목적으로 명시적인 상태 세부 정보\(수락 또는 거부 관련\)가 statusInfo 필드에 제공될 수 있습니다.\(MAY\)

CertConfirmContent 내에서 이전 응답 메시지에 제공된 인증서에 해당하는 CertStatus 구조의 생략은 인증서 거부를 나타냅니다. 따라서 빈 CertConfirmContent\(길이가 0인 SEQUENCE\)를 사용하여 제공된 모든 인증서의 거부를 나타낼 수 있습니다. 소유 증명과 관련된 certHash 필드에 대한 논의는 섹션 5.2.8, 항목 \(2\)를 참조하십시오.\(MAY\)

---
#### **5.3.19.  PKI General Message Content**

```text
     InfoTypeAndValue ::= SEQUENCE {
         infoType               OBJECT IDENTIFIER,
         infoValue              ANY DEFINED BY infoType  OPTIONAL
     }
     -- where {id-it} = {id-pkix 4} = {1 3 6 1 5 5 7 4}
     GenMsgContent ::= SEQUENCE OF InfoTypeAndValue
```

---
##### **5.3.19.1.  CA Protocol Encryption Certificate**

이는 EE가 CA로부터 인증서를 받아 프로토콜 중에 민감한 정보를 보호하는 데 사용할 수 있습니다.\(MAY\)

```text
      GenMsg:    {id-it 1}, < absent >
      GenRep:    {id-it 1}, Certificate | < absent >
```

EE는 이러한 목적으로 올바른 인증서가 사용되는지 확인해야 합니다.\(MUST\)

---
##### **5.3.19.2.  Signing Key Pair Types**

```text
   This MAY be used by the EE to get the list of signature algorithms
   (e.g., RSA, DSA) whose subject public key values the CA is willing to
   certify.  Note that for the purposes of this exchange, rsaEncryption
   and rsaWithSHA1, for example, are considered to be equivalent; the
   question being asked is, "Is the CA willing to certify an RSA public
   key?"
```

GenMsg: {id-it 2}, < 없음 \>

- GenRep: {id-it 2}, AlgorithmIdentifier의 시퀀스 크기\(1..MAX\)

---
##### **5.3.19.3.  Encryption/Key Agreement Key Pair Types**

CA가 인증하려는 주체 공개 키 값이 있는 암호화/키 계약 알고리즘 목록을 얻기 위해 클라이언트가 이를 사용할 수 있습니다.\(MAY\)

GenMsg: {id-it 3}, < 없음 \>

- GenRep: {id-it 3}, AlgorithmIdentifier의 시퀀스 크기\(1..MAX\)

---
##### **5.3.19.4.  Preferred Symmetric Algorithm**

이는 클라이언트가 EE와 CA 간에 교환해야 하는 모든 기밀 정보에 대해 CA가 선호하는 대칭 암호화 알고리즘을 얻기 위해 사용될 수 있습니다\(예를 들어 EE가 보관을 위해 개인 암호 해독 키를 CA에 보내려는 경우\). 목적\).\(MAY\)

```text
      GenMsg:    {id-it 4}, < absent >
      GenRep:    {id-it 4}, AlgorithmIdentifier
```

---
##### **5.3.19.5.  Updated CA Key Pair**

이는 CA가 CA 키 업데이트 이벤트를 알리기 위해 사용될 수 있습니다.\(MAY\)

```text
      GenMsg:    {id-it 5}, CAKeyUpdAnnContent
```

---
##### **5.3.19.6.  CRL**

이는 클라이언트가 최신 CRL의 사본을 얻기 위해 사용될 수 있습니다.\(MAY\)

```text
      GenMsg:    {id-it 6}, < absent >
      GenRep:    {id-it 6}, CertificateList
```

---
##### **5.3.19.7.  Unsupported Object Identifiers**

이는 서버가 클라이언트가 제출한 목록에서 인식하지 못하거나 지원하지 않는 개체 식별자 목록을 반환하는 데 사용됩니다.

- GenRep: {id-it 7}, 개체 식별자의 시퀀스 크기\(1..MAX\)

---
##### **5.3.19.8.  Key Pair Parameters**

이는 EE가 특정 공개 키 알고리즘에 대한 키 쌍을 생성하는 데 사용할 도메인 매개변수를 요청하는 데 사용될 수 있습니다. 예를 들어, DH/DSA 키를 생성하기 위해 적절한 P, Q 및 G를 요청하거나 잘 알려진 타원 곡선 세트를 요청하는 데 사용할 수 있습니다.\(MAY\)

```text
      GenMsg:    {id-it 10}, OBJECT IDENTIFIER -- (Algorithm object-id)
      GenRep:    {id-it 11}, AlgorithmIdentifier | < absent >
```

GenRep에 infoValue가 없으면 GenMsg에 지정된 알고리즘이 지원되지 않음을 나타냅니다.

EE는 매개변수가 허용 가능하고 GenRep 메시지가 인증되었는지 확인해야 합니다\(대체 공격을 방지하기 위해\).\(MUST\)

---
##### **5.3.19.9.  Revocation Passphrase**

이는 EE가 나중에 취소 요청을 인증할 목적으로 CA/RA에 암호를 보내는 데 사용될 수 있습니다\(요청을 인증하는 데 더 이상 적절한 서명 개인 키를 사용할 수 없는 경우\). 이 메커니즘의 사용에 대한 자세한 내용은 부록 B를 참조하세요.\(MAY\)

```text
      GenMsg:    {id-it 12}, EncryptedValue
      GenRep:    {id-it 12}, < absent >
```

---
##### **5.3.19.10.  ImplicitConfirm**

{id-it 13}의 정의 및 사용에 대해서는 섹션 5.1.1.1을 참조하세요.

---
##### **5.3.19.11.  ConfirmWaitTime**

{id-it 14}의 정의 및 사용에 대해서는 섹션 5.1.1.2를 참조하세요.

---
#### **5.3.19.12 Original PKIMessage**

{id-it 15}의 정의와 사용에 대해서는 섹션 5.1.3을 참조하세요.

---
##### **5.3.19.13.  Supported Language Tags**

이는 후속 메시지에 사용할 적절한 언어 태그를 결정하는 데 사용될 수 있습니다. 발신자는 지원되는 언어 목록\(가장 선호하는 언어부터 가장 낮은 언어 순\)을 보냅니다. 수신자는 사용하려는 것을 반환합니다. \(참고: 각 UTF8String에는 언어 태그가 포함되어야 합니다.\) 제공된 태그 중 어느 것도 지원되지 않으면 오류가 반환되어야 합니다.\(MAY, MUST\)

- GenMsg: {id-it 16}, UTF8String의 시퀀스 크기\(1..MAX\) GenRep: {id-it 16}, UTF8String의 시퀀스 크기\(1\)

---
#### **5.3.20.  PKI General Response Content**

- GenRepContent ::= InfoTypeAndValue의 순서

지원될 수 있는 GenReps의 예에는 섹션 5.3.19의 하위 섹션에 나열된 것이 포함됩니다.\(MAY\)

---
#### **5.3.21.  Error Message Content**

이 데이터 구조는 EE, CA 또는 RA에서 오류 정보를 전달하는 데 사용될 수 있습니다.\(MAY\)

```text
    ErrorMsgContent ::= SEQUENCE {
        pKIStatusInfo          PKIStatusInfo,
        errorCode              INTEGER           OPTIONAL,
        errorDetails           PKIFreeText       OPTIONAL
    }
```

이 메시지는 PKI 트랜잭션 중 언제든지 생성될 수 있습니다. 클라이언트가 이 요청을 보내는 경우 서버는 PKIConfirm 응답으로 응답해야 하며, 헤더의 일부가 유효하지 않은 경우에는 다른 ErrorMsg로 응답해야 합니다. 양쪽 모두 이 메시지를 트랜잭션의 끝으로 처리해야 합니다\(트랜잭션이 진행 중인 경우\).\(MAY, MUST, MUST\)

메시지에 대한 보호가 필요한 경우 클라이언트는 트랜잭션 시작 메시지와 동일한 기술\(즉, 서명 또는 MAC\)을 사용하여 메시지를 보호해야 합니다. CA는 항상 서명 키로 서명해야 합니다.\(MUST, MUST\)

---
#### **5.3.22.  Polling Request and Response**

이 메시지 쌍은 미해결 ir, cr 또는 kur 트랜잭션의 상태를 확인하기 위해 클라이언트가 서버를 폴링해야 하는 시나리오\(예: "대기 중" PKIStatus가 수신된 경우\)를 처리하기 위한 것입니다.

```text
    PollReqContent ::= SEQUENCE OF SEQUENCE {
        certReqId    INTEGER }

    PollRepContent ::= SEQUENCE OF SEQUENCE {
        certReqId    INTEGER,
        checkAfter   INTEGER,  -- time in seconds
        reason       PKIFreeText OPTIONAL }
```

다음 절에서는 폴링 메시지가 사용되는 시기와 사용 방법을 설명합니다. 트랜잭션 중에 여러 certConf 메시지가 전송될 수 있다고 가정합니다. 발급된 인증서에 대한 CertStatus를 포함하는 각 ip, cp 또는 kup에 대한 응답으로 하나가 전송됩니다.

1. ip, cp 또는 kup 메시지에 대한 응답으로 EE는 발급된 모든 인증서에 대해 certConf를 보내고, 확인 후 보류 중인 모든 인증서에 대해 pollReq를 보냅니다.

2. 대기 중인 인증서 중 하나 이상이 준비된 경우 CA/RA는 pollReq에 대한 응답으로 ip, cp 또는 kup을 반환합니다. 그렇지 않으면 pollRep을 반환합니다.

3. EE가 pollRep를 수신하면 다른 pollReq를 보내기 전에 최소한 checkAfter 값만큼 기다립니다.

4. pollReq에 대한 응답으로 ip, cp 또는 kup이 수신되면 초기 응답과 동일한 방식으로 처리됩니다.

```text
                               START
                                 |
                                 v
                              Send ir
                                 | ip
                                 v
                            Check status
                            of returned <------------------------+
                               certs                             |
                                 |                               |
       +------------------------>|<------------------+           |
       |                         |                   |           |
       |        (issued)         v       (waiting)   |           |
     Add to <----------- Check CertResponse ------> Add to       |
    conf list           for each certificate      pending list   |
                                 /                               |
                                /                                |
                   (conf list) /     (empty conf list)           |
                              /                     ip           |
                             /                 +----------------+
      (empty pending list)  /                  |    pRep
        END <---- Send certConf         Send pReq------------>Wait
                         |                 ^   ^               |
                         |                 |   |               |
                         +-----------------+   +---------------+
                            (pending list)
```

다음 교환에서 최종 엔터티는 하나의 요청으로 두 개의 인증서를 등록합니다.

```text
    Step  End Entity                       PKI
    --------------------------------------------------------------------
    1   Format ir
    2                    -> ir      ->
    3                                    Handle ir
    4                                    Manual intervention is
                                         required for both certs.
    5                    <- ip      <-
    6   Process ip
    7   Format pReq
    8                    -> pReq     ->
    9                                    Check status of cert requests
    10                                   Certificates not ready
    11                                   Format pRep
    12                   <- pRep     <-
    13  Wait
    14  Format pReq
    15                   -> pReq     ->
    16                                   Check status of cert requests
    17                                   One certificate is ready
    18                                   Format ip
    19                   <- ip       <-
    20  Handle ip
    21  Format certConf
    22                   -> certConf ->
    23                                   Handle certConf
    24                                   Format ack
    25                   <- pkiConf   <-
    26  Format pReq
    27                   -> pReq     ->
    28                                   Check status of certificate
    29                                   Certificate is ready
    30                                   Format ip
    31                   <- ip       <-
    31  Handle ip
    32  Format certConf
    33                   -> certConf ->
    34                                   Handle certConf
    35                                   Format ack
    36                   <- pkiConf  <-
```

---
## **6.  Mandatory PKI Management Functions**

이 섹션에서는 위의 섹션 3.1에 설명된 PKI 관리 기능 중 일부를 설명합니다.

이 섹션에서는 모든 최종 엔터티와 CA/RA 구현이 설명된 기능을 제공할 수 있어야 한다는 의미에서 "필수"인 기능을 다룹니다. 이 부분은 사실상 지원해야 하는 PKI 관리 기능의 프로필입니다. 그러나 이 섹션에 설명된 관리 기능은 대체 수단이 주어진 환경에 적합한 경우 섹션 5에 정의된 PKI 메시지를 사용하여 수행될 필요가 없습니다\(지원해야 하는 PKI 메시지 프로필은 부록 D 참조\).\(MUST, MUST, MUST\)

---
### **6.1.  Root CA Initialization**

\[이 문서의 "루트 CA" 정의는 섹션 3.1.1.2를 참조하세요.\]

새로 생성된 루트 CA는 루트 CA 키 업데이트 후에 발급된 "newWithNew" 인증서에 대해 정의된 프로필이 있는 인증서 구조인 "자체 인증서"를 생성해야 합니다.

"대역 외" 수단을 통해 자체 인증서를 획득하지 못한 최종 엔터티에게 CA의 자체 인증서를 유용하게 만들기 위해 CA는 인증서에 대한 지문도 생성해야 합니다. 일부 "대역 외" 수단을 통해 이 지문을 안전하게 획득한 최종 엔터티는 CA의 자체 인증서와 그에 포함된 다른 속성을 확인할 수 있습니다.

지문을 전달하는 데 사용되는 데이터 구조는 OOBCertHash입니다.

---
### **6.2.  Root CA Key Update**

CA 키\(다른 모든 키와 마찬가지로\)의 수명은 한정되어 있으며 정기적으로 업데이트되어야 합니다. NewWithNew, NewWithOld 및 OldWithNew 인증서\(섹션 4.4.1 참조\)는 현재 자체 서명된 CA 인증서\(OldWithOld\)를 보유한 기존 최종 엔터티가 새로운 자체 서명된 CA 인증서로 안전하게 전환하는 데 도움을 주기 위해 CA에서 발행할 수 있습니다\(MAY\). NewWithNew\), NewWithNew를 보유할 새로운 최종 개체가 기존 데이터 확인을 위해 OldWithOld를 안전하게 획득하도록 지원합니다.\(MAY\)

---
### **6.3.  Subordinate CA Initialization**

\[이 문서의 "하위 CA" 정의는 섹션 3.1.1.2를 참조하세요.\]

PKI 관리 프로토콜의 관점에서 하위 CA의 초기화는 최종 엔터티의 초기화와 동일합니다. 유일한 차이점은 하위 CA도 초기 해지 목록을 생성해야 한다는 것입니다.

---
### **6.4.  CRL production**

인증서를 발급하기 전에 CRL을 발급하는 새로 설립된 CA는 주기적으로 생성될 각 CRL의 "빈" 버전을 생성해야 합니다.

---
### **6.5.  PKI Information Request**

PKI 엔터티\(CA, RA 또는 EE\)가 CA의 현재 상태에 대한 정보를 얻으려는 경우 해당 CA에 해당 정보에 대한 요청을 보낼 수 있습니다.\(MAY\)

CA는 요청자가 요청한 모든 정보를 \(적어도\) 제공하여 요청에 응답해야 합니다. 일부 정보를 제공할 수 없는 경우 요청자에게 오류가 전달되어야 합니다.\(MUST\)

PKIMessages를 사용하여 이 PKI 정보를 요청하고 제공하는 경우 요청은 GenMsg 메시지여야 하고 응답은 GenRep 메시지여야 하며 오류는 오류 메시지여야 합니다. 이러한 메시지는 공유 비밀 정보\(예: PasswordBasedMAC\)를 기반으로 하는 MAC을 사용하거나 기타 인증된 수단\(최종 엔터티에 기존 인증서가 있는 경우\)을 사용하여 보호됩니다.\(MUST\)

---
### **6.6.  Cross Certification**

요청자 CA는 교차 인증서의 주체가 될 CA입니다. 응답자 CA는 교차 인증서의 발급자가 됩니다.

교차 인증 작업을 시작하기 전에 요청자 CA가 "실행 중"이어야 합니다.

---
#### **6.6.1.  One-Way Request-Response Scheme:**

교차 인증 체계는 기본적으로 단방향 작업입니다. 즉, 성공하면 이 작업으로 인해 하나의 새로운 교차 인증서가 생성됩니다. 요구 사항이 교차 인증서를 "양방향"으로 생성해야 하는 경우 각 CA는 차례로 교차 인증 작업을 시작해야 합니다\(또는 다른 체계를 사용해야 합니다\).

이 체계는 문제의 두 CA가 이미 서로의 서명을 확인할 수 있거나\(공통 신뢰 지점이 있음\) 인증 요청의 출처에 대한 대역 외 확인이 있는 경우에 적합합니다.

```text
   Detailed Description:
```

교차 인증은 응답자로 알려진 하나의 CA에서 시작됩니다. 응답자의 CA 관리자는 교차 인증하려는 CA를 식별하고 응답자 CA 장비는 인증 코드를 생성합니다. 응답자 CA 관리자는 대역 외 수단을 통해 이 인증 코드를 요청자 CA 관리자에게 전달합니다. 요청자 CA 관리자는 온라인 교환을 시작하기 위해 요청자 CA에 인증 코드를 입력합니다.

인증 코드는 인증 및 무결성 목적으로 사용됩니다. 이는 인증 코드를 기반으로 대칭 키를 생성하고 교환된 모든 메시지에 대해 MAC\(메시지 인증 코드\)을 생성하기 위해 대칭 키를 사용하여 수행됩니다. \(CA가 대역 외 해시 비교와 같은 일부 수단을 통해 필요한 공개 키를 검색하고 유효성을 검사할 수 있는 경우 MAC 대신 서명을 사용하여 인증을 수행할 수도 있습니다.\)

요청자 CA는 새로운 난수\(요청자 난수\)로 상호 인증 요청\(ccr\)을 생성하여 교환을 시작합니다. 그런 다음 요청자 CA는 응답자 CA에 ccr 메시지를 보냅니다. 이 메시지의 필드는 인증 코드를 기반으로 하는 MAC 수정으로부터 보호됩니다.

ccr 메시지를 수신한 응답자 CA는 메시지와 MAC의 유효성을 검사하고 요청자 난수를 저장한 후 자체 난수\(응답자 난수\)를 생성합니다. 그런 다음 요청자 CA 공개 키를 포함하고 응답자 CA 서명 개인 키로 서명된 새 요청자 인증서를 생성\(원하는 경우 보관\)합니다. 응답자 CA는 교차 인증 응답\(ccp\) 메시지로 응답합니다. 이 메시지의 필드는 인증 코드를 기반으로 하는 MAC 수정으로부터 보호됩니다.

ccp 메시지를 수신하면 요청자 CA는 메시지\(수신된 난수 포함\)와 MAC의 유효성을 검사합니다. 요청자 CA는 certConf 메시지로 응답합니다. 이 메시지의 필드는 인증 코드를 기반으로 하는 MAC 수정으로부터 보호됩니다. 요청자 CA는 나중에 인증서 경로 구성을 지원하기 위해 요청자 인증서를 리포지토리에 쓸 수 있습니다.\(MAY\)

certConf 메시지를 수신하면 응답자 CA는 메시지와 MAC의 유효성을 검사하고 PKIConfirm 메시지를 사용하여 승인을 다시 보냅니다. 또한 이후 경로 구성을 돕기 위해 요청자 인증서를 게시할 수도 있습니다.\(MAY\)

```text
   Notes:
```

1. ccr 메시지에는 "완전한" 인증 요청이 포함되어야 합니다. 즉, 일련 번호\(예: BasicConstraints 확장 포함\)를 제외한 모든 필드는 요청자 CA에 의해 지정되어야 합니다.

2. ccp 메시지는 응답자 CA의 확인 인증서를 포함해야 합니다. 존재하는 경우 요청자 CA는 이 인증서를 확인해야 합니다\(예: "대역 외" 메커니즘을 통해\).\(SHOULD\)

\(간단하고 비대화형 교차 인증 모델도 구상할 수 있습니다. 여기서 발급 CA는 일부 저장소에서 대상 CA의 공개 키를 획득하고 일부 대역 외 메커니즘을 통해 이를 확인한 후 교차 인증을 생성 및 게시합니다. 주체 CA의 명시적인 개입 없이 인증서 이 모델은 많은 환경에서 완벽하게 합법적일 수 있지만 프로토콜 메시지 교환이 필요하지 않으므로 자세한 설명은 이 사양의 범위를 벗어납니다.\)

---
### **6.7.  End Entity Initialization**

CA와 마찬가지로 최종 엔터티도 초기화되어야 합니다. 최종 엔터티를 초기화하려면 최소한 두 단계가 필요합니다.

o PKI 정보 획득

o 하나의 루트 CA 공개 키에 대한 대역 외 검증

\(다른 가능한 단계에는 신뢰 조건 정보 검색 및/또는 다른 CA 공개 키의 대역 외 확인이 포함됩니다.\)

---
#### **6.7.1.  Acquisition of PKI Information**

필수 정보는 다음과 같습니다.\(MUST\)

o 현재 루트-CA 공개 키

o \(인증 CA가 루트 CA가 아닌 경우\) 적절한 해지 목록과 함께 루트 CA에서 인증 CA까지의 인증 경로

o 인증 CA가 각 관련 용도에 대해 지원하는 알고리즘 및 알고리즘 매개변수

성공적인 인증 요청을 생성하려면 추가 정보\(예: 지원되는 확장 또는 CA 정책 정보\)가 필요할 수 있습니다. 그러나 단순화를 위해 최종 엔터티가 PKI 메시지를 통해 이 정보를 획득하도록 요구하지는 않습니다. 최종 결과는 단순히 일부 인증 요청이 실패할 수 있다는 것입니다\(예: 최종 엔터티가 자체 암호화 키를 생성하려고 하지만 CA가 이를 허용하지 않는 경우\).

필수 정보는 섹션 6.5에 설명된 대로 획득할 수 있습니다.\(MAY\)

---
#### **6.7.2.  Out-of-Band Verification of Root-CA Key**

최종 엔터티는 루트 CA의 공개 키를 안전하게 소유해야 합니다. 이를 달성하는 한 가지 방법은 보안 "대역 외" 수단을 통해 최종 엔터티에 CA의 자체 인증서 지문을 제공하는 것입니다. 그러면 최종 엔터티는 CA의 자체 인증서를 안전하게 사용할 수 있습니다.

자세한 내용은 섹션 6.1을 참조하세요.

---
### **6.8.  Certificate Request**

초기화된 최종 엔터티는 언제든지\(어떤 목적으로든\) 추가 인증서를 요청할 수 있습니다. 이 요청은 인증 요청\(cr\) 메시지를 사용하여 이루어집니다. 최종 엔터티가 이미 서명 키 쌍\(해당 확인 인증서 포함\)을 보유하고 있는 경우 이 cr 메시지는 일반적으로 엔터티의 디지털 서명으로 보호됩니다. CA는 요청이 성공한 경우 CertRepMessage에 새 인증서를 반환합니다.\(MAY\)

---
### **6.9.  Key Update**

키 쌍이 만료될 예정인 경우 관련 최종 엔터티는 키 업데이트를 요청할 수 있습니다. 즉, CA가 새 키 쌍에 대한 새 인증서\(또는 특정 상황에서는 동일한 키 쌍에 대한 새 인증서\)를 발급하도록 요청할 수 있습니다. 요청은 키 업데이트 요청\(kur\) 메시지\(일부 환경에서는 "인증서 업데이트" 작업이라고도 함\)를 사용하여 이루어집니다. 최종 엔터티가 이미 서명 키 쌍\(해당 확인 인증서 포함\)을 보유하고 있는 경우 이 메시지는 일반적으로 엔터티의 디지털 서명으로 보호됩니다. CA는 CertRepMessage와 구문적으로 동일한 키 업데이트 응답\(kup\) 메시지로 새 인증서\(요청이 성공한 경우\)를 반환합니다.\(MAY\)

---
## **7.  Version Negotiation**

이 섹션에서는 클라이언트와 서버 간의 이전 프로토콜을 지원하는 데 사용되는 버전 협상을 정의합니다.

클라이언트가 서버가 지원하는 프로토콜 버전\(예: 이전 PKIMessage 교환 또는 일부 대역 외 수단을 통해\)을 알고 있는 경우 클라이언트와 서버 모두에서 지원하는 가장 높은 버전의 PKIMessage를 보내야 합니다. . 클라이언트가 서버가 지원하는 버전을 모르는 경우 지원하는 가장 높은 버전을 사용하여 PKIMessage를 보내야 합니다.\(MUST, MUST\)

서버가 지원하는 버전의 메시지를 수신하는 경우 응답 메시지의 버전은 수신된 버전과 동일해야 합니다. 서버가 지원하는 것보다 높거나 낮은 버전의 메시지를 수신하면 unsupportedVersion 비트가 설정된\(pKIStatusInfo의 failureInfo 필드에\) ErrorMsg를 다시 보내야 합니다. 수신된 버전이 지원되는 최고 버전보다 높은 경우 오류 메시지의 버전은 서버가 지원하는 최고 버전이어야 합니다. 수신된 버전이 지원되는 가장 낮은 버전보다 낮은 경우 오류 메시지의 버전은 서버가 지원하는 가장 낮은 버전이어야 합니다.\(MUST, MUST, MUST\)

클라이언트가 unsupportedVersion 비트가 설정된 ErrorMsgContent와 지원하는 버전을 받으면 해당 버전으로 요청을 재시도할 수 있습니다.\(MAY\)

---
### **7.1.  Supporting RFC 2510 Implementations**

RFC 2510은 버전이 하나만 존재했기 때문에 이해하지 못하는 버전을 수신하는 구현의 동작을 지정하지 않았습니다. 현재 사양 개정판이 도입됨에 따라 다음과 같은 버전 관리 동작이 권장됩니다.

---
#### **7.1.1.  Clients Talking to RFC 2510 Servers**

cmp2000 메시지를 보낸 후 클라이언트가 cmp1999 버전의 ErrorMsgContent를 수신하면 현재 트랜잭션을 중단해야 합니다. 이후 버전 cmp1999 메시지를 사용하여 트랜잭션을 재시도할 수 있습니다.\(MUST, MAY\)

클라이언트가 오류가 아닌 cmp1999 버전의 PKIMessage를 수신하면 RFC 2510 의미 체계를 사용하여 트랜잭션을 계속하기로 결정할 수 있습니다\(트랜잭션이 완료되지 않은 경우\). 그렇게 하기로 선택하지 않고 트랜잭션이 완료되지 않은 경우 트랜잭션을 중단하고 cmp1999 버전과 함께 ErrorMsgContent를 보내야 합니다.\(MAY, MUST\)

---
#### **7.1.2.  Servers Receiving Version cmp1999 PKIMessages**

서버가 cmp1999 버전 메시지를 수신하면 RFC 2510 동작으로 돌아가고 cmp1999 버전 메시지로 응답할 수 있습니다. 그렇게 하기로 선택하지 않은 경우 위의 섹션 7에 설명된 대로 ErrorMsgContent를 다시 보내야 합니다.\(MAY, MUST\)

---
## **8.  Security Considerations**
---
### **8.1.  Proof-Of-Possession with a Decryption Key**

일부 암호화 고려 사항은 명시적으로 설명할 가치가 있습니다. 위에 지정된 프로토콜에서 최종 엔터티가 암호 해독 키 소유를 증명해야 하는 경우 무언가\(자신의 인증서\)를 암호 해독하라는 요청을 효과적으로 받게 됩니다. 문제의 암호 해독 키 소유자가 속아서 임의의 문제를 암호 해독하고 공격자에게 일반 텍스트를 반환할 수 있는 경우 이 체계\(및 기타 여러 가지!\)가 공격에 취약할 수 있습니다. 이 사양에서는 이 공격이 성공하려면 여러 가지 다른 보안 오류가 필요하지만 일부 향후 서비스\(예: 공증인, 신뢰할 수 있는 시간\)가 잠재적으로 이러한 공격에 취약할 수 있다고 생각됩니다. 이러한 이유로 우리는 구현 시 임의의 "암호문"을 해독하고 복구된 "일반 텍스트"를 공개하는 데 매우 주의해야 한다는 일반 규칙을 반복합니다. 이러한 관행은 심각한 보안 취약성을 초래할 수 있기 때문입니다.

---
### **8.2.  Proof-Of-Possession by Exposing the Private Key**

또한 소유 증명 기술로 개인 키를 CA/RA에 노출하면 일부 보안 위험이 발생할 수 있습니다\(CA/RA가 해당 자료를 적절하게 처리할 수 있다고 신뢰할 수 있는지 여부에 따라 다름\). 구현자는 다음을 수행하는 것이 좋습니다.

- 이 특정 POP 메커니즘을 선택하고 사용할 때는 주의하세요.

- 적절한 경우, 애플리케이션 사용자가 개인 키 공개를 진행하기 전에 CA/RA가 개인 키 사본을 보유할 것이라고 신뢰할 의사가 있음을 명시적으로 명시하도록 합니다.

---
### **8.3.  Attack Against Diffie-Hellman Key Exchange**

Diffie-Hellman 키 교환 중 소규모 하위 그룹 공격은 다음과 같이 수행될 수 있습니다. 악의적인 최종 엔터티는 키 보관 또는 키 복구 작업 중에 CA의 D-H 개인 키\(상당한 수의 비트\)를 파생할 수 있도록 하는 D-H 매개 변수를 의도적으로 선택할 수 있습니다. 이러한 지식으로 무장한

그런 다음 EE는 EE2의 합법적인 키 보관 또는 해당 CA와의 키 복구 작업 중에 의심하지 않는 다른 최종 엔터티인 EE2의 암호 해독 개인 키를 검색할 수 있습니다. 이러한 공격 가능성을 방지하기 위해 두 가지 조치 방법을 사용할 수 있습니다. \(1\) CA는 자신이 사용하는 각 EE에 대한 프로토콜 암호화 키 쌍으로 사용될 새로운 D-H 키 쌍을 생성할 수 있습니다.

상호 작용합니다. \(2\) CA는 EE의 프로토콜 암호화 키 쌍이 이 공격을 용이하게 하지 않도록 보장하기 위해 각 요청 최종 엔터티와 함께 ​​키 검증 프로토콜\(이 문서에 지정되지 않음\)을 입력할 수 있습니다. 옵션 \(1\)은 확실히 더 간단하므로\(어느 쪽에서도 추가 프로토콜 교환이 필요하지 않음\) 따라서 권장됩니다.\(SHOULD\)

---
## **9.  IANA Considerations**

PKI 일반 메시지 유형은 OID\(객체 식별자\)로 식별됩니다. 이 문서에 정의된 PKI 일반 메시지 유형에 대한 OID는 IANA가 PKIX 작업 그룹에 위임한 아크에서 할당되었습니다.

이 문서에 언급된 암호화 알고리즘은 개체 식별자\(OID\)로 식별됩니다. 암호화 알고리즘의 OID는 RSA Security, Entrust Technologies, IANA 및 IETF를 포함하여 다양한 조직이 소유한 여러 아크에서 할당되었습니다.

추가 암호화 알고리즘이 도입되면 해당 알고리즘을 옹호하는 사람들은 자체 아크에서 필요한 OID를 할당할 것으로 예상됩니다.

이 문서나 예상되는 업데이트에 대해서는 IANA의 추가 조치가 필요하지 않습니다.

---
# **Normative References**

\[X509\] 국제 표준화 기구 및 국제 통신 연합, "정보 기술 - 개방형 시스템 상호 연결 - 디렉토리: 공개 키 및 속성 인증서 프레임워크", ISO 표준 9594-8:2001, ITU-T 권장 사항 X.509, 2000년 3월 .

\[MvOV97\] Menezes, A., van Oorschot, P. 및 S. Vanstone, "응용 암호화 핸드북", CRC Press ISBN 0-8493-8523-7, 1996.

\[RFC2104\] Krawczyk, H., Bellare, M. 및 R. Canetti, "HMAC: 메시지 인증을 위한 키 해싱", RFC 2104, 1997년 2월.

\[RFC2119\] Bradner, S., "요구 사항 수준을 나타 내기 위해 RFC에 사용되는 핵심 단어", BCP 14, RFC 2119, 1997년 3월.

\[RFC2202\] Cheng, P. 및 R. Glenn, "HMAC-MD5 및 HMAC-SHA-1에 대한 테스트 사례", RFC 2202, 1997년 9월.

\[RFC3629\] Yergeau, F., "UTF-8, ISO 10646의 변환 형식", STD 63, RFC 3629, 2003년 11월.

\[RFC2482\] Whistler, K. 및 G. Adams, "유니코드 일반 텍스트의 언어 태그 지정", RFC 2482, 1999년 1월.

```text
   [CRMF]       Schaad, J., "Internet X.509 Public Key Infrastructure
                Certificate Request Message Format (CRMF)", RFC 4211,
                September 2005.
```

\[RFC3066\] Alvestrand, H., "식별을 위한 태그

- 언어", BCP 47, RFC 3066, 2001년 1월.

---
# **Informative References**

\[CMPtrans\] Kapoor, A., Tschalar, R. 및 T. Kause, "인터넷 X.509 공개 키 인프라 - CMP용 전송 프로토콜", 작업 진행 중. 2004.

```text
   [PKCS7]      RSA Laboratories, "The Public-Key Cryptography Standards
                - Cryptographic Message Syntax Standard.  Version 1.5",
                PKCS 7, November 1993.
```

\[PKCS10\] Nystrom, M., B. Kaliski, "공개 키

- 암호화 표준 - 인증 요청 구문 표준, 버전 1.7", RFC 2986, 2000년 5월.

```text
   [PKCS11]     RSA Laboratories, "The Public-Key Cryptography Standards
                - Cryptographic Token Interface Standard.  Version
                2.10", PKCS 11, December 1999.
```

\[RFC1847\] Galvin, J., Murphy, S., Crocker, S. 및 N. Freed, "MIME용 보안 멀티파트: 멀티파트/서명 및 멀티파트/암호화", RFC 1847, 1995년 10월.

\[RFC2559\] Boeyen, S., Howes, T. 및 P. Richard, "인터넷 X.509 공개 키 인프라 운영 프로토콜 - LDAPv2", RFC 2559, 1999년 4월.

\[RFC2585\] Housley, R. 및 P. Hoffman, "인터넷 X.509 공개 키 인프라 운영 프로토콜: FTP 및 HTTP", RFC 2585, 1999년 5월.

\[FIPS-180\] 국립 표준 기술 연구소\(National Institute of Standards and Technology\), "보안 해시 표준", FIPS PUB 180-1, 1994년 5월.

\[FIPS-186\] 국립 표준 기술 연구소, "디지털 서명 표준", FIPS PUB 186, 1994년 5월.

\[ANSI-X9.42\] 미국 국립 표준 협회\(American National Standards Institute\), "금융 서비스 산업을 위한 공개 키 암호화: 이산 로그 암호화를 사용한 대칭 키 계약", ANSI X9.42, 2000년 2월.

---
# **Appendix A.  Reasons for the Presence of RAs**

RA의 존재를 정당화하는 이유는 기술적인 요인과 본질적으로 조직적인 요인으로 나눌 수 있습니다. 기술적인 이유는 다음과 같습니다.

o 하드웨어 토큰을 사용하는 경우 모든 최종 개체가 이를 초기화하는 데 필요한 장비를 갖추지는 않습니다. RA 장비에는 필요한 기능이 포함될 수 있습니다\(이는 정책의 문제일 수도 있음\).

o 일부 최종 개체에는 게시 기능이 없을 수 있습니다.

- 인증서; 다시 말하면 RA는 이를 위해 적절하게 배치될 수 있습니다.

o RA는 연관된 최종 개체를 대신하여 서명된 철회 요청을 발행할 수 있지만, 최종 개체는 이를 수행하지 못할 수도 있습니다\(키 쌍이 완전히 손실된 경우\).

RA의 존재를 주장하는 조직적 이유 중 일부는 다음과 같습니다.

o 모든 최종 엔터티에 기능을 제공하는 것보다 RA 장비에 기능을 집중시키는 것이 더 비용 효율적일 수 있습니다\(특히 특수 토큰 초기화 장비를 사용하는 경우\).

o 조직 내에 RA를 설정하면 필요한 CA 수를 줄일 수 있으며 이는 때로는 바람직할 때도 있습니다.

o RA는 자신의 정보를 통해 사람들을 식별하는 데 더 나은 위치에 있을 수 있습니다.

- "전자" 이름, 특히 CA가 최종 엔터티로부터 물리적으로 멀리 떨어져 있는 경우.

o 많은 응용 프로그램의 경우 RA 역할에 대한 후보자를 쉽게 찾을 수 있도록 일부 관리 구조가 이미 마련되어 있을 것입니다\(CA에는 해당되지 않을 수 있음\).

---
# **Appendix B.  The Use of Revocation Passphrase**

취소 요청에는 서비스 거부 공격이 성공할 가능성을 줄이기 위해 적절한 인증을 비롯한 적절한 보안 메커니즘이 통합되어야 합니다. 요청에 대한 디지털 서명\(폐기 요청이 지원되는 경우 이 사양 내에서 반드시 지원해야 함\)은 필요한 인증을 제공할 수 있지만 대체 메커니즘이 바람직할 수 있는 상황이 있습니다\(예: 개인 키에 더 이상 액세스할 수 없는 경우\). 엔터티는 다른 키 쌍을 재인증하기 전에 취소를 요청하기를 원합니다. 그러한 수용을 위해

상황에서는 취소 요청이 지원되고 공유 비밀 정보가 필요하기 전에 요청자와 응답자 사이에 설정될 수 있는 경우 요청에 대한 PasswordBasedMAC도 이 사양 내에서 지원해야 합니다\(주어진 환경에 대한 로컬 보안 정책에 따라 다름\). 폐지.

일부 환경에서 사용되는 메커니즘은 "폐기 암호문"입니다. 여기서는 충분한 엔트로피 값\(즉, 짧은 암호가 아닌 비교적 긴 암호문\)이 일부 환경에서 엔터티와 CA/RA 사이에서만 공유됩니다. 취소 전 시점 이 값은 나중에 취소 요청을 인증하는 데 사용됩니다.

이 사양에서는 공유 비밀 정보\(예: 폐기 암호 문구\)를 설정하는 다음 기술을 지원하는 것이 선택 사항입니다. CMP 메시지에서의 정확한 사용법은 다음과 같습니다.\(MAY\)

o 섹션 5.3.19.9에 지정된 OID 및 값은 언제든지 GenMsg 메시지로 전송되거나 PKIMessage의 PKIHeader에 있는 GeneralInfo 필드에서 전송될 수 있습니다. \(특히, EncryptedValue는 초기화 요청이나 인증서 요청 메시지에서 요청된 인증서의 수락을 확인하는 certConf 메시지의 헤더에 전송될 수 있습니다.\) 이는 엔터티가 선택한 폐기 암호 문구\(즉, encValue의 해독된 바이트\)를 전달합니다. 필드\) 관련 CA/RA에 전달합니다. 또한 전송은 적절한 기밀성 특성을 통해 수행됩니다\(암호 문구가 CA/RA의 프로토콜EncryptionKey에 따라 암호화되기 때문\).\(MAY\)

o CA/RA가 GenMsg에서 폐기 암호\(OID 및 섹션 5.3.19.9에 지정된 값\)를 수신하는 경우 섹션 5.3.19.9에 지정된 OID\(값 없음\)를 포함하는 GenRep 메시지를 구성하고 전송해야 합니다. CA/RA가 PKIMessage의 PKIHeader에 있는 GeneralInfo 필드에서 폐기 암호 문구를 수신하는 경우 해당 응답 PKIMessage의 PKIHeader에 있는 GeneralInfo 필드에 OID\(값 없음\)를 포함해야 합니다. CA/RA가 어떤 이유로든 적절한 응답 메시지를 반환할 수 없는 경우 "거부" 상태와 선택적으로 실패 정보 이유가 설정된 오류 메시지를 보내야 합니다.\(MUST, MUST, MUST\)

o EncryptedValue의 valueHint 필드에는 나중에 올바른 암호 문구를 검색하는 데 도움이 되는 키 식별자\(암호 문구 자체와 함께 엔터티가 선택한\)가 포함될 수 있습니다\(예: 철회 요청이 엔터티에 의해 구성되고 CA에 의해 수신될 때\). 라\).\(MAY\)

o 폐기 요청 메시지는 폐기 암호를 키로 사용하여 PasswordBasedMAC에 의해 보호됩니다. 적절한 경우 PKIHeader의 senderKID 필드에는 이전에 valueHint로 전송된 값이 포함될 수 있습니다.\(MAY\)

위에 지정된 기술을 사용하면 추가 메시지나 대역 외 교환 없이 언제든지 폐기 암호를 초기에 설정하고 업데이트할 수 있습니다. 예를 들어, 폐기 요청 메시지 자체\(폐기 암호를 키로 사용하는 MAC를 통해 보호되고 인증됨\)에는 PKIHeader에 엔터티의 다른 인증서에 대한 향후 폐기 요청을 인증하는 데 사용할 새로운 폐기 암호가 포함될 수 있습니다. . 일부 환경에서는 이는 취소 요청 메시지에서 암호를 공개하는 메커니즘보다 더 나을 수 있습니다. 이는 공개된 암호를 승인되지 않은 제3자가 사용하여 엔터티의 다른 개체에 대한 취소 요청을 인증하는 서비스 거부 공격을 허용할 수 있기 때문입니다. 인증서. 그러나 암호가 요청 메시지에 공개되지 않기 때문에 해지 요청이 이루어질 때 암호를 항상 업데이트해야 한다는 요구 사항은 없습니다. 즉, 엔터티가 다른 인증서에 대한 해지 요청을 인증하기 위해 동일한 암호를 사용할 수 있습니다. 다른 시간에\).\(MAY\)

또한, 위의 기술은 디지털 서명을 사용하지 않는 경우에도 철회 요청 메시지 전체에 대해 강력한 암호화 보호 기능을 제공할 수 있습니다. 단순히 해지 암호 문구를 공개하여 해지 요청을 인증하는 기술은 일반적으로 요청 메시지 필드에 대한 암호화 보호를 제공하지 않습니다\(따라서 하나의 인증서에 대한 해지 요청은 승인되지 않은 제3자에 의해 해지 요청으로 수정될 수 있음\). 해당 엔터티에 대한 다른 인증서\).

---
# **Appendix C.  Request Message Behavioral Clarifications**

해석이나 상호 운용성 문제를 일으키는 \[CRMF\] 업데이트의 경우 \[CRMF\]가 표준 문서가 되어야 합니다.\(MUST\)

다음 정의는 \[CRMF\]에서 나온 것입니다. 해당 요청 메시지에 대한 동작 설명을 체계화하기 위해 여기에 포함되었습니다. 그렇지 않으면 모든 구문과 의미는 \[CRMF\]와 동일합니다.

```text
   CertRequest ::= SEQUENCE {
       certReqId     INTEGER,
       certTemplate  CertTemplate,
       controls      Controls OPTIONAL }
```

-- certTemplate이 빈 SEQUENCE\(즉, 모든 필드 -- 생략됨\)인 경우 컨트롤은 다음을 포함할 수 있습니다.\(MAY\)

-- id-regCtrl-altCertTemplate 컨트롤, 템플릿 지정 -- X.509v3 공개 키 이외의 인증서에 대한 -- 인증서. 반대로 certTemplate이 비어 있지 않은 경우\(즉, 하나 이상의 필드가 존재하는 경우\) 컨트롤은 id-regCtrl-altCertTemplate을 포함해서는 안 됩니다. 새 컨트롤은 다음과 같이 정의됩니다.\(MUST\)

```text
   id-regCtrl-altCertTemplate OBJECT IDENTIFIER ::= {id-regCtrl 7}
   AltCertTemplate ::= AttributeTypeAndValue

   POPOSigningKey ::= SEQUENCE {
       poposkInput           [0] POPOSigningKeyInput OPTIONAL,
       algorithmIdentifier   AlgorithmIdentifier,
       signature             BIT STRING }

   -- **********
   -- * For the purposes of this specification, the ASN.1 comment
   -- * given in [CRMF] pertains not only to certTemplate, but
   -- * also to the altCertTemplate control.  That is,
   -- **********
   -- * The signature (using "algorithmIdentifier") is on the
   -- * DER-encoded value of poposkInput (i.e., the "value" OCTETs
   -- * of the POPOSigningKeyInput DER).  NOTE: If CertReqMsg
   -- * certReq certTemplate (or the altCertTemplate control)
   -- * contains the subject and publicKey values, then poposkInput
   -- * MUST be omitted and the signature MUST be computed on the
   -- * DER-encoded value of CertReqMsg certReq (or the DER-
   -- * encoded value of AltCertTemplate).  If
   -- * certTemplate/altCertTemplate does not contain both the
   -- * subject and public key values (i.e., if it contains only
   -- * one of these, or neither), then poposkInput MUST be present
   -- * and MUST be signed.
   -- **********

   POPOPrivKey ::= CHOICE {
       thisMessage       [0] BIT STRING,

   -- **********
   -- * the type of "thisMessage" is given as BIT STRING in
   -- * [CRMF]; it should be "EncryptedValue" (in accordance
   -- * with Section 5.2.2, "Encrypted Values", of this specification).
   -- * Therefore, this document makes the behavioral clarification
   -- * of specifying that the contents of "thisMessage" MUST be encoded
   -- * as an EncryptedValue and then wrapped in a BIT STRING.  This
   -- * allows the necessary conveyance and protection of the
   -- * private key while maintaining bits-on-the-wire compatibility
   -- * with [CRMF].
   -- **********

       subsequentMessage [1] SubsequentMessage,
       dhMAC             [2] BIT STRING }
```

---
# **Appendix D.  PKI Management Message Profiles (REQUIRED).**

이 부록에는 구현을 준수하여 지원해야 하는 PKIMessage에 대한 자세한 프로필이 포함되어 있습니다\(섹션 6 참조\).\(MUST\)

다음 PKI 관리 작업에 사용되는 PKIMessages에 대한 프로필이 제공됩니다.

```text
   o  initial registration/certification

   o  basic authenticated scheme

   o  certificate request

   o  key update
```

---
### **D.1.  General Rules for Interpretation of These Profiles.**

1. OPTIONAL 또는 DEFAULT 필드가 개별 프로필에 언급되지 않은 경우 해당 필드가 관련 메시지에 없어야 합니다\(즉, 수신자는 이러한 필드가 포함된 메시지를 구문이 올바르지 않은 것으로 간주하여 유효하게 거부할 수 있습니다\). 필수 필드는 명확한 값이 있는 경우 언급되지 않습니다\(예: 이 사양 버전에서 pvno는 항상 2입니다\).\(SHOULD\)

2. 둘 이상의 메시지에서 구조가 발생하는 경우 적절하게 별도로 프로파일링됩니다.

3. PKIMessage 구조의 알고리즘 식별자는 별도로 프로파일링됩니다.

4. "특수" X.500 DN을 "NULL-DN"이라고 합니다. 이는 길이가 0인 SEQUENCE OF RelativeDistinguishedNames를 포함하는 DN을 의미합니다\(해당 DER 인코딩은 '3000'H임\).

5. 필드에 GeneralName이 필요하지만 적절한 값을 사용할 수 없는 경우\(예: 최종 엔터티가 이름을 알기 전에 요청을 생성하는 경우\) GeneralName은 X.500 NULL-DN\(즉, Name CHOICE 필드에는 NULL-DN이 포함됩니다. 이 특수 값은 "NULL-GeneralName"이라고 불릴 수 있습니다.

6. 프로필에서 GeneralName 값 지정을 생략한 경우 관련 PKIMessage 필드에 NULL-GeneralName 값이 표시됩니다. 이는 일부 메시지에 대한 PKIHeader의 보낸 사람 필드에서 발생합니다.

7. 필드 이름 지정으로 인해 모호성이 발생하는 경우 프로필에서는 "점" 표기법을 사용하여 해당 필드 이름을 지정합니다\(예: "certTemplate.subject"는 certTemplate이라는 필드 내의 제목 필드를 의미함\).

8. "SEQUENCE OF 유형"이 메시지의 일부인 경우 0부터 시작하는 배열 표기법을 사용하여 SEQUENCE OF 내의 필드를 설명합니다\(예: crm\[0\].certReq.certTemplate.subject는 첫 번째 하위 필드를 나타냅니다. 요청 메시지에 포함된 CertReqMsg\).

9. 부록 D.4 \~ D.6의 모든 PKI 메시지 교환에서는 시작 엔터티가 certConf 메시지를 보내고 응답 엔터티가 PKIConfirm을 보내도록 요구합니다. PKIConfirm은 본문이 NULL이고 헤더 내용이 컨텍스트에서 명확하므로 제공된 일부 프로필에 포함되지 않습니다. protectionAlg에는 인증된 모든 수단\(예: 공유 비밀 정보가 알려진 경우 비밀번호 기반 MAC 또는 서명\)을 사용할 수 있습니다.

---
### **D.2.  Algorithm Use Profile**

다음 표에는 PKI 관리 프로토콜 내에서 사용되는 알고리즘에 대한 정의가 포함되어 있습니다. 테이블의 열은 다음과 같습니다.

이름: 메시지 프로필에 사용되는 식별자

사용: 알고리즘이 사용되는 위치와 용도에 대한 설명

필수: 반드시 지원해야 하는 AlgorithmIdentifier

- 구현을 준수\(MUST\)

기타: 필수 AlgorithmIdentifier에 대한 대안

```text
    Name         Use                      Mandatory        Others

    MSG_SIG_ALG  Protection of PKI        DSA/SHA-1        RSA/MD5,
                 messages using signature                  ECDSA, ...
    MSG_MAC_ALG  protection of PKI        PasswordBasedMac HMAC,
                 messages using MACing                     X9.9...
    SYM_PENC_ALG symmetric encryption of  3-DES (3-key-    AES,RC5,
                 an end entity's private  EDE, CBC mode)   CAST-128...
                 key where symmetric
                 key is distributed
                 out-of-band
    PROT_ENC_ALG asymmetric algorithm     D-H              RSA,
                 used for encryption of                    ECDH, ...
                 (symmetric keys for
                 encryption of) private
                 keys transported in

                 PKIMessages
    PROT_SYM_ALG symmetric encryption     3-DES (3-key-    AES,RC5,
                 algorithm used for       EDE, CBC mode)   CAST-128...
                 encryption of private
                 key bits (a key of this
                 type is encrypted using
                 PROT_ENC_ALG)
```

필수 알고리즘 식별자 및 사양:

```text
   DSA/SHA-1:
     AlgId: {1 2 840 10040 4 3};

   Digital Signature Standard [FIPS-186]

     Public Modulus size: 1024 bits.

   PasswordBasedMac:

     AlgId: {1 2 840 113533 7 66 13}, with SHA-1 {1 3 14 3 2 26} as the
            owf parameter and HMAC-SHA1 {1 3 6 1 5 5 8 1 2} as the mac
            parameter;
```

\(이 사양\)과 함께

보안 해시 표준 \[FIPS-180\] 및 \[RFC2104\]

```text
     HMAC key size:  160 bits (i.e., "K" = "H" in Section 5.1.3.1,
                               "Shared secret information")

   3-DES:
```

AlgId: {1 2 840 113549 3 7}; \(RSA의 BSAFE 및 S/MIME에 사용됨\)

```text
   D-H:

     AlgId:  {1 2 840 10046 2 1};

   [ANSI-X9.42]

     Public Modulus Size:  1024 bits.
     DomainParameters ::= SEQUENCE {
        p       INTEGER, -- odd prime, p=jq +1
        g       INTEGER, -- generator, g^q = 1 mod p
        q       INTEGER, -- prime factor of p-1
        j       INTEGER OPTIONAL, -- cofactor, j>=2
        validationParms  ValidationParms OPTIONAL

     }
     ValidationParms ::= SEQUENCE {
        seed          BIT STRING, -- seed for prime generation
        pGenCounter   INTEGER     -- parameter verification
     }
```

---
### **D.3.  Proof-of-Possession Profile**

인증서가 요청된 공개 확인 키에 해당하는 개인 서명 키의 소유를 증명할 때 사용되는 POP 필드\(ProofOfPossession 구조의 팝 필드의 서명 필드\).

```text
    Field               Value         Comment

    algorithmIdentifier MSG_SIG_ALG   only signature protection is
                                      allowed for this proof

    signature           present       bits calculated using MSG_SIG_ALG
```

인증서가 요청된 공개 암호화 키에 해당하는 개인 암호 해독 키의 소유 증명에서는 이 프로필을 사용하지 않습니다. 대신 certConf 메시지의 CertHash 필드가 사용됩니다.

모든 CA/RA가 PKIX-CMP 대역 내 인증 요청 프로토콜에서 소유 증명\(서명 키, 암호 해독 키 또는 키 계약 키\)을 수행하는 것은 아닙니다\(POP 수행 방법은 궁극적으로 정책 문제가 될 수 있음\). 공개된 정책 OID 및 인증 업무 선언문에서 특정 CA에 대해 명시적입니다. 그러나 이 사양에서는 CA/RA 엔터티가 인증 프로세스의 일부로 POP\(어떤 방법으로든\)를 수행해야 한다고 규정합니다. 모든 최종 엔터티는 POP를 제공하도록 준비되어야 합니다\(즉, PKIX-CMP 프로토콜의 이러한 구성 요소가 지원되어야 합니다\).\(MAY, MUST, MUST\)

---
### **D.4.  Initial Registration/Certification (Basic Authenticated Scheme)**

\(초기화되지 않은\) 최종 엔터티는 CA로부터 \(첫 번째\) 인증서를 요청합니다. CA가 인증서가 포함된 메시지로 응답하면 최종 엔터티는 인증서 확인으로 응답합니다. CA는 PKIConfirm을 다시 보내 트랜잭션을 종료합니다. 모든 메시지가 인증되었습니다.

이 방식을 사용하면 최종 개체가 로컬에서 생성된 공개 키\(일반적으로 서명 키\)의 인증을 요청할 수 있습니다. 최종 엔터티는 또한 다른 키 쌍\(일반적으로 암호화 키 쌍\)의 중앙 집중식 생성 및 인증을 요청하도록 선택할 수도 있습니다.\(MAY\)

인증은 로컬에서 생성된 하나의 공개 키에 대해서만 요청할 수 있습니다\(자세한 내용은 별도의 PKIMessages 사용\).

최종 엔터티는 로컬에서 생성된 공개 키와 관련된 개인 키의 소유 증명을 지원해야 합니다.\(MUST\)

```text
   Preconditions:
```

1. 최종 엔터티는 대역 외 수단을 기반으로 CA의 서명을 인증할 수 있습니다.

2. 최종 엔터티와 CA는 대칭 MACing 키를 공유합니다.

```text
   Message flow:

    Step# End entity                           PKI
      1   format ir
      2                      ->   ir      ->
      3                                        handle ir
      4                                        format ip
      5                      <-   ip      <-
      6   handle ip
      7   format certConf
      8                      ->   certConf ->
      9                                        handle certConf
     10                                        format PKIConf
     11                      <-   PKIConf  <-
     12   handle PKIConf
```

이 프로필에 대해 우리는 최종 엔터티가 단일 PKIMessage에 모든\(즉, 하나 또는 두 개\) CertReqMsg를 포함해야 하며 PKI\(CA\)가 완전한 응답\(즉, OPTIONAL 포함\)을 포함하는 단일 응답 PKIMessage를 생성해야 한다고 규정합니다. 두 번째 키 쌍\(요청된 경우 및 중앙 집중식 키 생성이 지원되는 경우\). 단순화를 위해 우리는 이 메시지가 최종 메시지여야 함을 요구합니다\(즉, "대기" 상태 값을 사용하지 않음\).\(MUST, MUST\)

최종 개체는 CA/RA와 대역 외 상호 작용을 합니다. 이 트랜잭션은 인증서 템플릿의 보낸 사람과 주체 이름 모두에 사용되는 공유 비밀, referenceNumber 및 선택적으로 고유 이름을 설정했습니다. 공유 비밀번호의 길이는 12자 이상인 것이 좋습니다.\(MAY, SHOULD\)

```text
   Initialization Request -- ir

   Field                Value

   recipient            CA name

     -- the name of the CA who is being asked to produce a certificate
   protectionAlg        MSG_MAC_ALG
     -- only MAC protection is allowed for this request, based
     -- on initial authentication key
   senderKID            referenceNum
     -- the reference number which the CA has previously issued
     -- to the end entity (together with the MACing key)
   transactionID        present
     -- implementation-specific value, meaningful to end
     -- entity.
     -- [If already in use at the CA, then a rejection message MUST
     -- be produced by the CA]

   senderNonce          present
     -- 128 (pseudo-)random bits
   freeText             any valid value
   body                 ir (CertReqMessages)
                        only one or two CertReqMsg
                        are allowed
     -- if more certificates are required, requests MUST be
     -- packaged in separate PKIMessages

   CertReqMsg           one or two present
     -- see below for details, note: crm[0] means the first
     -- (which MUST be present), crm[1] means the second (which
     -- is OPTIONAL, and used to ask for a centrally-generated key)

   crm[0].certReq.      fixed value of zero
      certReqId
     -- this is the index of the template within the message
   crm[0].certReq       present
      certTemplate
     -- MUST include subject public key value, otherwise unconstrained
   crm[0].pop...        optionally present if public key
      POPOSigningKey    from crm[0].certReq.certTemplate is
                        a signing key
     -- proof-of-possession MAY be required in this exchange
     -- (see Appendix D.3 for details)
   crm[0].certReq.      optionally present
      controls.archiveOptions
     -- the end entity MAY request that the locally-generated
     -- private key be archived
```

crm\[0\].certReq. 선택적으로 존재

-controls.publicationInfo - 최종 엔터티는 결과 인증서 게시를 요청할 수 있습니다.\(MAY\)

```text
   crm[1].certReq       fixed value of one
```

- certReqId - 메시지 내 템플릿의 인덱스 crm\[1\].certReq 현재 certTemplate - 실제 공개 키 비트를 포함해서는 안 됩니다. 그렇지 않으면 - 제약이 없습니다\(예: 이름은 -- crm\[ 0\]\). subjectPublicKeyInfo가 존재할 수 있으며 -- 알고리즘과 매개변수에 대해 CA/RA에 알리고 싶은 경우 -- 주제PublicKey에 대한 길이가 0인 BIT STRING이 뒤따르는 AlgorithmIdentifier를 포함할 수 있습니다. 생성된 키 쌍.\(MUST NOT, MAY\)

crm\[1\].certReq. 현재 \[객체 식별자는 PROT\_ENC\_ALG여야 합니다.\]\(MUST\)

- Controls.protocolEncrKey -- 이 CA에서 중앙 집중식 키 생성을 지원하는 경우 -- 이 단기 비대칭 암호화 키\(최종 엔터티에 의해 생성됨\)는 CA에서 암호화하는 데 사용됩니다\(- 암호화\) - 최종 엔터티를 대신하여 CA가 생성한 개인 키

```text
   crm[1].certReq.      optionally present
      controls.archiveOptions
   crm[1].certReq.      optionally present
      controls.publicationInfo
   protection           present
     -- bits calculated using MSG_MAC_ALG

   Initialization Response -- ip

   Field                Value

   sender               CA name
     -- the name of the CA who produced the message
   messageTime          present
     -- time at which CA produced message
   protectionAlg        MS_MAC_ALG
     -- only MAC protection is allowed for this response
   senderKID             referenceNum
     -- the reference number that the CA has previously issued to the
     -- end entity (together with the MACing key)
   transactionID        present
     -- value from corresponding ir message
   senderNonce          present
     -- 128 (pseudo-)random bits
   recipNonce           present
     -- value from senderNonce in corresponding ir message
   freeText             any valid value

   body                 ip (CertRepMessage)
                        contains exactly one response
                        for each request
```

-- PKI\(CA\)는 적절하게 하나 또는 두 개의 요청에 -- 응답합니다. crc\[0\]은 첫 번째\(항상 존재함\)를 나타냅니다. -- crc\[1\]은 두 번째를 나타냅니다\(ir 메시지에 두 개의 요청이 포함되어 있고 CA가 중앙 집중식 -- 키 생성을 지원하는 경우에만 존재함\). crc\[0\]. 0의 고정 값 certReqId -- 해당 ir 메시지의 첫 번째 요청에 대한 응답을 포함해야 합니다.\(MUST\)

```text
   crc[0].status.       present, positive values allowed:
      status               "accepted", "grantedWithMods"
                        negative values allowed:
                           "rejection"
   crc[0].status.       present if and only if
      failInfo          crc[0].status.status is "rejection"
   crc[0].              present if and only if
      certifiedKeyPair  crc[0].status.status is
                           "accepted" or "grantedWithMods"
   certificate          present unless end entity's public
                        key is an encryption key and POP
                        is done in this in-band exchange
   encryptedCert        present if and only if end entity's
                        public key is an encryption key and
                        POP done in this in-band exchange
   publicationInfo      optionally present

     -- indicates where certificate has been published (present
     -- at discretion of CA)

   crc[1].              fixed value of one
      certReqId
     -- MUST contain the response to the second request in the
     -- corresponding ir message
   crc[1].status.       present, positive values allowed:
      status               "accepted", "grantedWithMods"
                        negative values allowed:
                           "rejection"
   crc[1].status.       present if and only if
      failInfo          crc[0].status.status is "rejection"
   crc[1].              present if and only if
      certifiedKeyPair  crc[0].status.status is "accepted"
                        or "grantedWithMods"
   certificate          present

   privateKey           present
     -- see Appendix C, Request Message Behavioral Clarifications
   publicationInfo      optionally present
     -- indicates where certificate has been published (present
     -- at discretion of CA)

   protection           present
     -- bits calculated using MSG_MAC_ALG
   extraCerts           optionally present
     -- the CA MAY provide additional certificates to the end
     -- entity

   Certificate confirm; certConf

   Field                Value
```

sender 존재 -- ir 수신자와 동일 CA name -- 인증서 생성을 요청한 CA의 이름 transactionID 존재 -- 해당 ir 및 ip 메시지의 값 senderNonce 존재 -- 128\(의사\) 임의 비트 recipNonce 존재 - - 해당 IP 메시지 protectionAlg MSG\_MAC\_ALG의 senderNonce 값 - 이 메시지에는 MAC 보호만 허용됩니다. -- MAC는 EE와 CA 간에 공유되는 초기 인증 키를 기반으로 합니다.

```text
   senderKID            referenceNum
     -- the reference number which the CA has previously issued
     -- to the end entity (together with the MACing key)
```

body certConf -- certConf 필드의 -- 내용은 섹션 5.3.18, "PKI 확인 내용"을 참조하세요. -- 참고: 암호화와 서명 인증서가 모두 전송된 경우 두 개의 CertStatus 구조가 -- 필요합니다.

```text
   protection           present
     -- bits calculated using MSG_MAC_ALG

   Confirmation; PKIConf

   Field                Value

   sender               present
     -- same as in ip
   recipient            present
     -- sender name from certConf
   transactionID        present
     -- value from certConf message
   senderNonce          present
     -- 128 (pseudo-) random bits
   recipNonce           present
     -- value from senderNonce from certConf message
   protectionAlg        MSG_MAC_ALG
     -- only MAC protection is allowed for this message.
   senderKID            referenceNum
   body                 PKIConf
   protection           present
     -- bits calculated using MSG_MAC_ALG
```

---
### **D.5.  Certificate Request**

\(초기화된\) 최종 엔터티는 어떤 이유로든 CA로부터 인증서를 요청합니다. CA가 인증서가 포함된 메시지로 응답하면 최종 엔터티는 인증서 확인으로 응답합니다. CA는 PKIConfirm으로 응답하여 트랜잭션을 종료합니다. 모든 메시지가 인증되었습니다.

이 교환에 대한 프로필은 다음을 제외하고 부록 D.4에 제공된 프로필과 동일합니다.

o 발신자 이름이 있어야 합니다.\(SHOULD\)

```text
   o  protectionAlg of MSG_SIG_ALG MUST be supported (MSG_MAC_ALG MAY
      also be supported) in request, response, certConfirm, and
      PKIConfirm messages;

   o  senderKID and recipKID are only present if required for message
      verification;

   o  body is cr or cp;

   o  body may contain one or two CertReqMsg structures, but either
      CertReqMsg may be used to request certification of a locally-
      generated public key or a centrally-generated public key (i.e.,
      the position-dependence requirement of Appendix D.4 is removed);
```

o 보호 비트는 protectionAlg 필드에 따라 계산됩니다.

---
### **D.6.  Key Update Request**

\(초기화된\) 최종 엔터티는 CA로부터 인증서를 요청합니다\(이미 소유한 키 쌍 및/또는 해당 인증서를 업데이트하기 위해\). CA가 인증서가 포함된 메시지로 응답하면 최종 엔터티는 인증서 확인으로 응답합니다. CA는 PKIConfirm으로 응답하여 트랜잭션을 종료합니다. 모든 메시지가 인증되었습니다.

이 교환에 대한 프로필은 다음을 제외하고 부록 D.4에 제공된 프로필과 동일합니다.

1. 발신자 이름이 있어야 합니다.\(SHOULD\)

```text
   2.  protectionAlg of MSG_SIG_ALG MUST be supported (MSG_MAC_ALG MAY
       also be supported) in request, response, certConfirm, and
       PKIConfirm messages;

   3.  senderKID and recipKID are only present if required for message
       verification;

   4.  body is kur or kup;

   5.  body may contain one or two CertReqMsg structures, but either
       CertReqMsg may be used to request certification of a locally-
       generated public key or a centrally-generated public key (i.e.,
       the position-dependence requirement of Appendix D.4 is removed);

   6.  protection bits are calculated according to the protectionAlg
       field;
```

7. regCtrl OldCertId를 사용해야 합니다\(발신자와 수신자 모두에게 이 문서에 지정되지 않은 수단으로 필요하지 않다는 것이 명확하지 않은 한\).\(SHOULD\)

---
# **Appendix E.  PKI Management Message Profiles (OPTIONAL).**

이 부록에는 구현에서 지원할 수 있는 PKI 메시지에 대한 자세한 프로필이 포함되어 있습니다\(지원해야 하는 메시지 외에도 섹션 6 및 부록 D 참조\).\(MUST\)

다음 PKI 관리 작업에 사용되는 PKIMessages에 대한 프로필이 제공됩니다.

```text
   o  root CA key update

   o  information request/response

   o  cross-certification request/response (1-way)

   o  in-band initialization using external identity certificate
```

이 문서의 이후 버전에서는 아래 나열된 작업에 대한 프로필을 포함하도록 위의 내용을 확장할 수 있습니다\(원하는 경우 다른 작업과 함께\).

```text
   o  revocation request

   o  certificate publication

   o  CRL publication
```

---
### **E.1.  General Rules for Interpretation of These Profiles.**

부록 D.1과 동일합니다.

---
### **E.2.  Algorithm Use Profile**

부록 D.2와 동일합니다.

---
### **E.3.  Self-Signed Certificates**

인증서 구조가 "자체 서명"되는 방법에 대한 프로필입니다. 이러한 구조는 CA 공개 키 배포에 사용됩니다. 이는 세 가지 방법 중 하나로 발생할 수 있습니다\(이러한 구조의 사용에 대한 설명은 위의 섹션 4.4 참조\).

```text
   Type          Function
   -----------------------------------------------------------------
   newWithNew a true "self-signed" certificate; the contained
              public key MUST be usable to verify the signature
              (though this provides only integrity and no
              authentication whatsoever)
   oldWithNew previous root CA public key signed with new private key
   newWithOld new root CA public key signed with previous private key
```

이러한 인증서\(관련 확장 포함\)에는 모든 필드에 대해 "합리적인" 값이 포함되어야 합니다. 예를 들어, subjectAltName이 있는 경우 issuerAltName과 동일해야 하며, 있는 경우 keyIdentifiers는 적절한 값 등을 포함해야 합니다.\(MUST\)

---
### **E.4.  Root CA Key Update**

루트 CA는 키 쌍을 업데이트합니다. 그런 다음 \(일부 전송 메커니즘을 통해\) 관련 최종 엔터티에 제공될 수 있는 CA 키 업데이트 알림 메시지를 생성합니다. 최종 엔터티로부터 확인 메시지가 필요하지 않습니다.\(MUST\)

```text
   ckuann message:

    Field        Value                        Comment
   --------------------------------------------------------------
    sender       CA name CA name
    body         ckuann(CAKeyUpdAnnContent)
    oldWithNew   present                  see Appendix E.3 above
    newWithOld   present                  see Appendix E.3 above
    newWithNew   present                  see Appendix E.3 above
    extraCerts   optionally present       can be used to "publish"
                                          certificates (e.g.,
                                          certificates signed using
                                          the new private key)
```

---
### **E.5.  PKI Information Request/Response**

최종 엔터티는 이후 PKI 관리 작업에 필요한 세부 정보를 요청하는 일반 메시지를 PKI에 보냅니다. RA/CA는 일반적인 응답으로 응답합니다. RA가 응답을 생성하면 PKIMessage의 extraCerts 필드에 인증서를 추가하여 이전에 CA에서 받은 것과 동일한 메시지를 전달합니다. 최종 엔터티로부터 확인 메시지가 필요하지 않습니다.\(MUST\)

```text
   Message Flows:

   Step# End entity                        PKI

      1  format genm
      2                ->   genm   ->
      3                                    handle genm
      4                                    produce genp
      5                <-   genp   <-
      6  handle genp

   genM:

   Field               Value

   recipient           CA name
     -- the name of the CA as contained in issuerAltName

     -- extensions or issuer fields within certificates
   protectionAlg       MSG_MAC_ALG or MSG_SIG_ALG
     -- any authenticated protection alg.
   SenderKID           present if required
     -- must be present if required for verification of message
     -- protection
   freeText            any valid value
   body                genr (GenReqContent)
   GenMsgContent       empty SEQUENCE
     -- all relevant information requested
   protection          present
     -- bits calculated using MSG_MAC_ALG or MSG_SIG_ALG

   genP:

   Field                Value

   sender               CA name
     -- name of the CA which produced the message
   protectionAlg        MSG_MAC_ALG or MSG_SIG_ALG
     -- any authenticated protection alg.
   senderKID            present if required
     -- must be present if required for verification of message
     -- protection
   body                 genp (GenRepContent)
   CAProtEncCert        present (object identifier one
                        of PROT_ENC_ALG), with relevant
                        value
     -- to be used if end entity needs to encrypt information for
     -- the CA (e.g., private key for recovery purposes)

   SignKeyPairTypes     present, with relevant value
     -- the set of signature algorithm identifiers that this CA will
     -- certify for subject public keys
   EncKeyPairTypes      present, with relevant value
     -- the set of encryption/key agreement algorithm identifiers that
     -- this CA will certify for subject public keys
   PreferredSymmAlg     present (object identifier one
                        of PROT_SYM_ALG) , with relevant
                        value
     -- the symmetric algorithm that this CA expects to be used
     -- in later PKI messages (for encryption)
   CAKeyUpdateInfo      optionally present, with
                        relevant value
     -- the CA MAY provide information about a relevant root CA
     -- key pair using this field (note that this does not imply
     -- that the responding CA is the root CA in question)
   CurrentCRL           optionally present, with relevant value
```

-- CA는 완전한 CRL\(즉, -- 가능한 한 가장 완전한 것\)의 사본을 제공할 수 있습니다. 보호 존재 -- MSG\_MAC\_ALG 또는 MSG\_SIG\_ALG를 사용하여 계산된 비트 선택적으로 존재하는 extraCerts -- 일부 인증서를 최종 엔터티로 보내는 데 사용할 수 있습니다. RA는 여기에 인증서를 추가할 수 있습니다.\(MAY, MAY\)

---
### **E.6.  Cross Certification Request/Response (1-way)**

단일 교차 인증서 생성\(즉, 한 번에 두 개가 아님\) 요청 CA는 PKIPublicationInfo 컨트롤을 사용하여 응답 CA가 생성한 교차 인증서 게시를 담당할 사람을 선택할 수 있습니다.\(MAY\)

```text
   Preconditions:
```

1. 응답 CA는 요청을 처리하기 전에 요청의 출처를 확인할 수 있습니다\(대역 외 수단이 필요할 수 있음\).

2. 요청 CA는 응답을 처리하기 전에 응답 출처의 진위 여부를 인증할 수 있습니다\(대역 외 수단이 필요할 수도 있음\).

인증서 확인 및 해당 서버 확인의 사용은 PKIHeader의 GeneralInfo 필드에 의해 결정됩니다\(섹션 5.1.1 참조\). 다음 프로필은 확인에 대한 지원을 요구하지 않습니다.

```text
   Message Flows:

   Step# Requesting CA                       Responding CA
     1   format ccr
     2                   ->    ccr    ->
     3                                       handle ccr
     4                                       produce ccp
     5                   <-    ccp    <-
     6   handle ccp

   ccr:

   Field                 Value

   sender                Requesting CA name
     -- the name of the CA who produced the message
   recipient             Responding CA name
     -- the name of the CA who is being asked to produce a certificate
   messageTime           time of production of message

     -- current time at requesting CA
   protectionAlg         MSG_SIG_ALG
     -- only signature protection is allowed for this request
   senderKID             present if required
     -- must be present if required for verification of message
     -- protection
   recipKID             present if required
     -- must be present if required for verification of message
     -- protection
   transactionID         present
     -- implementation-specific value, meaningful to requesting CA.
     -- [If already in use at responding CA then a rejection message
     -- MUST be produced by responding CA]
   senderNonce           present
     -- 128 (pseudo-)random bits
   freeText              any valid value
   body                  ccr (CertReqMessages)
                         only one CertReqMsg
                         allowed
     -- if multiple cross certificates are required, they MUST be
     -- packaged in separate PKIMessages
   certTemplate          present
     -- details follow
   version               v1 or v3
     -- v3 STRONGLY RECOMMENDED
   signingAlg            present
     -- the requesting CA must know in advance with which algorithm it
     -- wishes the certificate to be signed

   subject               present
     -- may be NULL-DN only if subjectAltNames extension value proposed
   validity              present
     -- MUST be completely specified (i.e., both fields present)
   issuer                present
     -- may be NULL-DN only if issuerAltNames extension value proposed
   publicKey             present
     -- the key to be certified (which must be for a signing algorithm)
   extensions            optionally present
     -- a requesting CA must propose values for all extensions
     -- that it requires to be in the cross-certificate
   POPOSigningKey        present
     -- see Section D3: Proof-of-possession profile
   protection            present
     -- bits calculated using MSG_SIG_ALG
   extraCerts            optionally present
     -- MAY contain any additional certificates that requester wishes
     -- to include

   ccp:

   Field                 Value

   sender                Responding CA name
     -- the name of the CA who produced the message
   recipient             Requesting CA name
     -- the name of the CA who asked for production of a certificate
   messageTime           time of production of message
     -- current time at responding CA
   protectionAlg         MSG_SIG_ALG
     -- only signature protection is allowed for this message
   senderKID             present if required
     -- must be present if required for verification of message
     -- protection
   recipKID              present if required
   transactionID         present
     -- value from corresponding ccr message
   senderNonce           present
     -- 128 (pseudo-)random bits
   recipNonce            present
   -- senderNonce from corresponding ccr message
   freeText              any valid value
   body                  ccp (CertRepMessage)
                         only one CertResponse allowed
     -- if multiple cross certificates are required they MUST be
     -- packaged in separate PKIMessages
   response              present
   status                present
```

PKIStatusInfo.status 존재 -- PKIStatusInfo.status가 다음 중 하나인 경우 -- 승인 또는 -- grantWithMods, -- 그러면 CertifiedKeyPair가 반드시 존재해야 하고, failureInfo는 반드시 -- 없어야 합니다.\(MUST\)

```text
   failInfo              present depending on
                         PKIStatusInfo.status
     -- if PKIStatusInfo.status is:
     --   rejection
     -- then certifiedKeyPair MUST be absent and failInfo MUST be
     -- present and contain appropriate bit settings

   certifiedKeyPair      present depending on
                         PKIStatusInfo.status
   certificate           present depending on
                         certifiedKeyPair

     -- content of actual certificate must be examined by requesting CA
     -- before publication
   protection            present
     -- bits calculated using MSG_SIG_ALG
   extraCerts            optionally present
     -- MAY contain any additional certificates that responder wishes
     -- to include
```

---
### **E.7.  In-Band Initialization Using External Identity Certificate**

\(초기화되지 않은\) 최종 엔터티는 CA CA-1을 사용하여 PKI로 초기화하려고 합니다. 인증 목적으로 다른 \(외부\) CA인 CA-X에서 발급한 기존 ID 인증서를 사용합니다. CA-1이 CA-X에서 서명한 EE ID 인증서의 유효성을 검사할 수 있도록 CA-1과 CA-X 간에 신뢰 관계가 이미 설정되어 있어야 합니다. 또한 CA-1이 서명한 PKIMessage를 인증하고 확인할 수 있는 일부 메커니즘이 EE의 PSE\(개인 보안 환경\) 내에 이미 설정되어 있어야 합니다. 예를 들어 PSE에는 공개 키에 대해 발급된 인증서가 포함될 수 있습니다. 대역 외 인증 기술을 기반으로 EE가 신뢰하는 다른 CA에 의해 서명된 CA-1\).

EE는 트랜잭션을 시작하기 위해 초기화 요청을 보냅니다. CA-1이 새 인증서가 포함된 메시지로 응답하면 최종 엔터티는 인증서 확인으로 응답합니다. CA-1은 PKIConfirm으로 응답하여 거래를 종료합니다. 모든 메시지는 서명됩니다. EE 메시지는 외부 ID 인증서의 공개 키에 해당하는 개인 키를 사용하여 서명됩니다. CA-1 메시지는 인증서의 공개 키에 해당하는 개인 키를 사용하여 서명됩니다.

EE의 PSE에 있는 트러스트 앵커에 연결될 수 있는 인증서\).

이 교환에 대한 프로필은 다음을 제외하고 부록 D.4에 제공된 프로필과 동일합니다.

```text
   o  the EE and CA-1 do not share a symmetric MACing key (i.e., there
      is no out-of-band shared secret information between these
      entities);

   o  sender name in ir MUST be present (and identical to the subject
      name present in the external identity certificate);

   o  protectionAlg of MSG_SIG_ALG MUST be used in all messages;
```

o 외부 신원 증명서. ir extraCerts 필드에 포함되어야 합니다.\(MUST\)

```text
   o  senderKID and recipKID are not used;

   o  body is ir or ip;
```

o 보호 비트는 protectionAlg 필드에 따라 계산됩니다.

---
# **Appendix F.  Compilable ASN.1 Definitions**

```text
     PKIXCMP {iso(1) identified-organization(3)
           dod(6) internet(1) security(5) mechanisms(5) pkix(7)
           id-mod(0) id-mod-cmp2000(16)}

     DEFINITIONS EXPLICIT TAGS ::=

     BEGIN

     -- EXPORTS ALL --

     IMPORTS

         Certificate, CertificateList, Extensions, AlgorithmIdentifier,
         UTF8String -- if required; otherwise, comment out
                FROM PKIX1Explicit88 {iso(1) identified-organization(3)
                dod(6) internet(1) security(5) mechanisms(5) pkix(7)
                id-mod(0) id-pkix1-explicit-88(1)}

         GeneralName, KeyIdentifier
                FROM PKIX1Implicit88 {iso(1) identified-organization(3)
                dod(6) internet(1) security(5) mechanisms(5) pkix(7)
                id-mod(0) id-pkix1-implicit-88(2)}

         CertTemplate, PKIPublicationInfo, EncryptedValue, CertId,
         CertReqMessages
                FROM PKIXCRMF-2005 {iso(1) identified-organization(3)
                dod(6) internet(1) security(5) mechanisms(5) pkix(7)
                id-mod(0) id-mod-crmf2005(36)}
```

- -- 이 사양의 부록 C에 성문화된 CRMF에 대한 동작 설명도 참조하세요.

```text
         CertificationRequest
                FROM PKCS-10 {iso(1) member-body(2)
                              us(840) rsadsi(113549)
                              pkcs(1) pkcs-10(10) modules(1) pkcs-10(1)}
```

- --\(1993 ASN.1 구문 및 IMPLICIT -- 태그를 사용하여 RFC 2986에 지정됨\) 또는 구현자는 이 모듈에 \[PKCS10\] 구문을 직접 포함할 수 있습니다.

```text
         ;
```

-- 모듈의 나머지 부분에는 로컬로 정의된 OID와 -- 구성이 포함됩니다.

```text
      CMPCertificate ::= CHOICE {
         x509v3PKCert        Certificate
      }
   -- This syntax, while bits-on-the-wire compatible with the
   -- standard X.509 definition of "Certificate", allows the
   -- possibility of future certificate types (such as X.509
   -- attribute certificates, WAP WTLS certificates, or other kinds
   -- of certificates) within this certificate management protocol,
   -- should a need ever arise to support such generality.  Those
   -- implementations that do not foresee a need to ever support
   -- other certificate types MAY, if they wish, comment out the
   -- above structure and "un-comment" the following one prior to
   -- compiling this ASN.1 module.  (Note that interoperability
   -- with implementations that don't do this will be unaffected by
   -- this change.)

   -- CMPCertificate ::= Certificate

      PKIMessage ::= SEQUENCE {
         header           PKIHeader,
         body             PKIBody,
         protection   [0] PKIProtection OPTIONAL,
         extraCerts   [1] SEQUENCE SIZE (1..MAX) OF CMPCertificate
                          OPTIONAL
     }

     PKIMessages ::= SEQUENCE SIZE (1..MAX) OF PKIMessage

     PKIHeader ::= SEQUENCE {
         pvno                INTEGER     { cmp1999(1), cmp2000(2) },
         sender              GeneralName,
         -- identifies the sender
         recipient           GeneralName,
         -- identifies the intended recipient
         messageTime     [0] GeneralizedTime         OPTIONAL,
         -- time of production of this message (used when sender
         -- believes that the transport will be "suitable"; i.e.,
         -- that the time will still be meaningful upon receipt)
         protectionAlg   [1] AlgorithmIdentifier     OPTIONAL,
         -- algorithm used for calculation of protection bits
         senderKID       [2] KeyIdentifier           OPTIONAL,
         recipKID        [3] KeyIdentifier           OPTIONAL,
         -- to identify specific keys used for protection

         transactionID   [4] OCTET STRING            OPTIONAL,
         -- identifies the transaction; i.e., this will be the same in
         -- corresponding request, response, certConf, and PKIConf
         -- messages
         senderNonce     [5] OCTET STRING            OPTIONAL,
         recipNonce      [6] OCTET STRING            OPTIONAL,
         -- nonces used to provide replay protection, senderNonce
         -- is inserted by the creator of this message; recipNonce
         -- is a nonce previously inserted in a related message by
         -- the intended recipient of this message
         freeText        [7] PKIFreeText             OPTIONAL,
         -- this may be used to indicate context-specific instructions
         -- (this field is intended for human consumption)
         generalInfo     [8] SEQUENCE SIZE (1..MAX) OF
                                InfoTypeAndValue     OPTIONAL
         -- this may be used to convey context-specific information
         -- (this field not primarily intended for human consumption)
     }

     PKIFreeText ::= SEQUENCE SIZE (1..MAX) OF UTF8String
         -- text encoded as UTF-8 String [RFC3629] (note: each
         -- UTF8String MAY include an [RFC3066] language tag
         -- to indicate the language of the contained text
         -- see [RFC2482] for details)

     PKIBody ::= CHOICE {       -- message-specific body elements
         ir       [0]  CertReqMessages,        --Initialization Request
         ip       [1]  CertRepMessage,         --Initialization Response
         cr       [2]  CertReqMessages,        --Certification Request
         cp       [3]  CertRepMessage,         --Certification Response
         p10cr    [4]  CertificationRequest,   --imported from [PKCS10]
         popdecc  [5]  POPODecKeyChallContent, --pop Challenge
         popdecr  [6]  POPODecKeyRespContent,  --pop Response
         kur      [7]  CertReqMessages,        --Key Update Request
         kup      [8]  CertRepMessage,         --Key Update Response
         krr      [9]  CertReqMessages,        --Key Recovery Request
         krp      [10] KeyRecRepContent,       --Key Recovery Response
         rr       [11] RevReqContent,          --Revocation Request
         rp       [12] RevRepContent,          --Revocation Response
         ccr      [13] CertReqMessages,        --Cross-Cert. Request
         ccp      [14] CertRepMessage,         --Cross-Cert. Response
         ckuann   [15] CAKeyUpdAnnContent,     --CA Key Update Ann.
         cann     [16] CertAnnContent,         --Certificate Ann.
         rann     [17] RevAnnContent,          --Revocation Ann.
         crlann   [18] CRLAnnContent,          --CRL Announcement
         pkiconf  [19] PKIConfirmContent,      --Confirmation
         nested   [20] NestedMessageContent,   --Nested Message
         genm     [21] GenMsgContent,          --General Message

         genp     [22] GenRepContent,          --General Response
         error    [23] ErrorMsgContent,        --Error Message
         certConf [24] CertConfirmContent,     --Certificate confirm
         pollReq  [25] PollReqContent,         --Polling request
         pollRep  [26] PollRepContent          --Polling response
     }

     PKIProtection ::= BIT STRING

     ProtectedPart ::= SEQUENCE {
         header    PKIHeader,
         body      PKIBody
     }

     id-PasswordBasedMac OBJECT IDENTIFIER ::= {1 2 840 113533 7 66 13}
     PBMParameter ::= SEQUENCE {
         salt                OCTET STRING,
         -- note:  implementations MAY wish to limit acceptable sizes
         -- of this string to values appropriate for their environment
         -- in order to reduce the risk of denial-of-service attacks
         owf                 AlgorithmIdentifier,
         -- AlgId for a One-Way Function (SHA-1 recommended)
         iterationCount      INTEGER,
         -- number of times the OWF is applied
         -- note:  implementations MAY wish to limit acceptable sizes
         -- of this integer to values appropriate for their environment
         -- in order to reduce the risk of denial-of-service attacks
         mac                 AlgorithmIdentifier
         -- the MAC AlgId (e.g., DES-MAC, Triple-DES-MAC [PKCS11],
     }   -- or HMAC [RFC2104, RFC2202])

     id-DHBasedMac OBJECT IDENTIFIER ::= {1 2 840 113533 7 66 30}
     DHBMParameter ::= SEQUENCE {
         owf                 AlgorithmIdentifier,
         -- AlgId for a One-Way Function (SHA-1 recommended)
         mac                 AlgorithmIdentifier
         -- the MAC AlgId (e.g., DES-MAC, Triple-DES-MAC [PKCS11],
     }   -- or HMAC [RFC2104, RFC2202])

     NestedMessageContent ::= PKIMessages

     PKIStatus ::= INTEGER {
         accepted                (0),
         -- you got exactly what you asked for
         grantedWithMods        (1),
         -- you got something like what you asked for; the
         -- requester is responsible for ascertaining the differences

         rejection              (2),
         -- you don't get it, more information elsewhere in the message
         waiting                (3),
         -- the request body part has not yet been processed; expect to
         -- hear more later (note: proper handling of this status
         -- response MAY use the polling req/rep PKIMessages specified
         -- in Section 5.3.22; alternatively, polling in the underlying
         -- transport layer MAY have some utility in this regard)
         revocationWarning      (4),
         -- this message contains a warning that a revocation is
         -- imminent
         revocationNotification (5),
         -- notification that a revocation has occurred
         keyUpdateWarning       (6)
         -- update already done for the oldCertId specified in
         -- CertReqMsg
     }

     PKIFailureInfo ::= BIT STRING {
     -- since we can fail in more than one way!
     -- More codes may be added in the future if/when required.
         badAlg              (0),
         -- unrecognized or unsupported Algorithm Identifier
         badMessageCheck     (1),
         -- integrity check failed (e.g., signature did not verify)
         badRequest          (2),
         -- transaction not permitted or supported
         badTime             (3),
         -- messageTime was not sufficiently close to the system time,
         -- as defined by local policy
         badCertId           (4),
         -- no certificate could be found matching the provided criteria
         badDataFormat       (5),
         -- the data submitted has the wrong format
         wrongAuthority      (6),
         -- the authority indicated in the request is different from the
         -- one creating the response token
         incorrectData       (7),
         -- the requester's data is incorrect (for notary services)
         missingTimeStamp    (8),
         -- when the timestamp is missing but should be there
         -- (by policy)
         badPOP              (9),
         -- the proof-of-possession failed
         certRevoked         (10),
            -- the certificate has already been revoked
         certConfirmed       (11),
            -- the certificate has already been confirmed

         wrongIntegrity      (12),
            -- invalid integrity, password based instead of signature or
            -- vice versa
         badRecipientNonce   (13),
            -- invalid recipient nonce, either missing or wrong value
         timeNotAvailable    (14),
            -- the TSA's time source is not available
         unacceptedPolicy    (15),
            -- the requested TSA policy is not supported by the TSA.
         unacceptedExtension (16),
            -- the requested extension is not supported by the TSA.
         addInfoNotAvailable (17),
            -- the additional information requested could not be
            -- understood or is not available
         badSenderNonce      (18),
            -- invalid sender nonce, either missing or wrong size
         badCertTemplate     (19),
            -- invalid cert. template or missing mandatory information
         signerNotTrusted    (20),
            -- signer of the message unknown or not trusted
         transactionIdInUse  (21),
            -- the transaction identifier is already in use
         unsupportedVersion  (22),
            -- the version of the message is not supported
         notAuthorized       (23),
            -- the sender was not authorized to make the preceding
            -- request or perform the preceding action
         systemUnavail       (24),
         -- the request cannot be handled due to system unavailability
         systemFailure       (25),
         -- the request cannot be handled due to system failure
         duplicateCertReq    (26)
         -- certificate cannot be issued because a duplicate
         -- certificate already exists
     }

     PKIStatusInfo ::= SEQUENCE {
         status        PKIStatus,
         statusString  PKIFreeText     OPTIONAL,
         failInfo      PKIFailureInfo  OPTIONAL
     }

     OOBCert ::= CMPCertificate

     OOBCertHash ::= SEQUENCE {
         hashAlg     [0] AlgorithmIdentifier     OPTIONAL,
         certId      [1] CertId                  OPTIONAL,
         hashVal         BIT STRING

         -- hashVal is calculated over the DER encoding of the
         -- self-signed certificate with the identifier certID.
     }
```

POPODecKeyChallContent ::= 챌린지 순서 -- 암호화 키 인증 요청당 하나의 챌린지\(- CertReqMessages에 나타나는 요청과 동일한 순서\).

```text
     Challenge ::= SEQUENCE {
         owf                 AlgorithmIdentifier  OPTIONAL,
```

- -- 첫 번째 챌린지에 참여해야 합니다. POPODecKeyChallContent의 -- 후속 챌린지에서는 생략될 수 있습니다. -- 생략된 경우 바로 이전 -- 챌린지에 사용된 owf가 사용됩니다.\(MUST\)

```text
         witness             OCTET STRING,
         -- the result of applying the one-way function (owf) to a
         -- randomly-generated INTEGER, A.  [Note that a different
         -- INTEGER MUST be used for each Challenge.]
         challenge           OCTET STRING
         -- the encryption (under the public key for which the cert.
         -- request is being made) of Rand, where Rand is specified as
         --   Rand ::= SEQUENCE {
         --      int      INTEGER,
         --       - the randomly-generated INTEGER A (above)
         --      sender   GeneralName
         --       - the sender's name (as included in PKIHeader)
         --   }
     }
```

POPODecKeyRespContent ::= SEQUENCE OF INTEGER -- 암호화 키 인증 요청당 하나의 INTEGER\(- CertReqMessages에 나타나는 요청과 동일한 순서\). -- 검색된 INTEGER A\(위\)는 해당 Challenge의 발신자에게 -- 반환됩니다.

```text
     CertRepMessage ::= SEQUENCE {
         caPubs       [1] SEQUENCE SIZE (1..MAX) OF CMPCertificate
                          OPTIONAL,
         response         SEQUENCE OF CertResponse
     }

     CertResponse ::= SEQUENCE {
         certReqId           INTEGER,
         -- to match this response with corresponding request (a value
         -- of -1 is to be used if certReqId is not specified in the
         -- corresponding request)

         status              PKIStatusInfo,
         certifiedKeyPair    CertifiedKeyPair    OPTIONAL,
         rspInfo             OCTET STRING        OPTIONAL
         -- analogous to the id-regInfo-utf8Pairs string defined
         -- for regInfo in CertReqMsg [CRMF]
     }

     CertifiedKeyPair ::= SEQUENCE {
         certOrEncCert       CertOrEncCert,
         privateKey      [0] EncryptedValue      OPTIONAL,
         -- see [CRMF] for comment on encoding
         publicationInfo [1] PKIPublicationInfo  OPTIONAL
     }

     CertOrEncCert ::= CHOICE {
         certificate     [0] CMPCertificate,
         encryptedCert   [1] EncryptedValue
     }

     KeyRecRepContent ::= SEQUENCE {
         status                  PKIStatusInfo,
         newSigCert          [0] CMPCertificate OPTIONAL,
         caCerts             [1] SEQUENCE SIZE (1..MAX) OF
                                             CMPCertificate OPTIONAL,
         keyPairHist         [2] SEQUENCE SIZE (1..MAX) OF
                                             CertifiedKeyPair OPTIONAL
     }

     RevReqContent ::= SEQUENCE OF RevDetails

     RevDetails ::= SEQUENCE {
         certDetails         CertTemplate,
         -- allows requester to specify as much as they can about
         -- the cert. for which revocation is requested
         -- (e.g., for cases in which serialNumber is not available)
         crlEntryDetails     Extensions       OPTIONAL
         -- requested crlEntryExtensions
     }

     RevRepContent ::= SEQUENCE {
         status       SEQUENCE SIZE (1..MAX) OF PKIStatusInfo,
         -- in same order as was sent in RevReqContent
         revCerts [0] SEQUENCE SIZE (1..MAX) OF CertId
                                             OPTIONAL,
         -- IDs for which revocation was requested
         -- (same order as status)
         crls     [1] SEQUENCE SIZE (1..MAX) OF CertificateList
                                             OPTIONAL

         -- the resulting CRLs (there may be more than one)
     }

     CAKeyUpdAnnContent ::= SEQUENCE {
         oldWithNew   CMPCertificate, -- old pub signed with new priv
         newWithOld   CMPCertificate, -- new pub signed with old priv
         newWithNew   CMPCertificate  -- new pub signed with new priv
     }

     CertAnnContent ::= CMPCertificate

     RevAnnContent ::= SEQUENCE {
         status              PKIStatus,
         certId              CertId,
         willBeRevokedAt     GeneralizedTime,
         badSinceDate        GeneralizedTime,
         crlDetails          Extensions  OPTIONAL
         -- extra CRL details (e.g., crl number, reason, location, etc.)
     }

     CRLAnnContent ::= SEQUENCE OF CertificateList

     CertConfirmContent ::= SEQUENCE OF CertStatus

     CertStatus ::= SEQUENCE {
        certHash    OCTET STRING,
        -- the hash of the certificate, using the same hash algorithm
        -- as is used to create and verify the certificate signature
        certReqId   INTEGER,
        -- to match this confirmation with the corresponding req/rep
        statusInfo  PKIStatusInfo OPTIONAL
     }

     PKIConfirmContent ::= NULL

     InfoTypeAndValue ::= SEQUENCE {
         infoType               OBJECT IDENTIFIER,
         infoValue              ANY DEFINED BY infoType  OPTIONAL
     }
     -- Example InfoTypeAndValue contents include, but are not limited
     -- to, the following (un-comment in this ASN.1 module and use as
     -- appropriate for a given environment):
     --
     --   id-it-caProtEncCert    OBJECT IDENTIFIER ::= {id-it 1}
     --      CAProtEncCertValue      ::= CMPCertificate
     --   id-it-signKeyPairTypes OBJECT IDENTIFIER ::= {id-it 2}
     --      SignKeyPairTypesValue   ::= SEQUENCE OF AlgorithmIdentifier
     --   id-it-encKeyPairTypes  OBJECT IDENTIFIER ::= {id-it 3}
```

-- EncKeyPairTypesValue ::= AlgorithmIdentifier의 순서 -- id-it-preferredSymmAlg 객체 식별자 ::= {id-it 4} -- PreferredSymmAlgValue ::= AlgorithmIdentifier -- id-it-caKeyUpdateInfo 객체 ID ::= {id-it 5} -- CAKeyUpdateInfoValue ::= CAKeyUpdAnnContent -- id-it-currentCRL 객체 IDENTIFIER ::= {id-it 6} -- CurrentCRLValue ::= CertificateList -- id-it-unsupportedOIDs 객체 IDENTIFIER ::= {id-it 7} -- UnsupportedOIDsValue ::= 개체 식별자의 시퀀스 -- id-it-keyPairParamReq 개체 식별자 ::= {id-it 10} -- KeyPairParamReqValue ::= 개체 식별자 -- id-it-keyPairParamRep 개체 식별자 ::= {id-it 11} -- KeyPairParamRepValue ::= AlgorithmIdentifer -- id-it-revPassphrase 객체 IDENTIFIER ::= {id-it 12} -- RevPassphraseValue ::= EncryptedValue -- id-it-implicitConfirm 객체 ID ::= {id-it 13} -- ImplicitConfirmValue ::= NULL -- id-it-confirmWaitTime 개체 IDENTIFIER ::= {id-it 14} --ConfirmWaitTimeValue ::= GeneralizedTime -- id-it-origPKIMessage 개체 IDENTIFIER ::= {id-it 15} -- OrigPKIMessageValue ::= PKIMessages -- id-it-suppLangTags 객체 식별자 ::= {id-it 16} -- SuppLangTagsValue ::= UTF8String의 시퀀스 -- -- where -- -- id -pkix 개체 식별자 ::= { -- iso\(1\) 식별-조직\(3\) -- dod\(6\) 인터넷\(1\) 보안\(5\) 메커니즘\(5\) pkix\(7\)} -- 및 -- id- it OBJECT IDENTIFIER ::= {id-pkix 4} -- -- -- 이 구성은 새로운 PKIX 인증서 -- 관리 프로토콜 요청 및 응답 메시지 또는 일반 목적\(예: 공지\) 메시지를 정의하는 데에도 사용될 수 있습니다. 미래의 요구 사항 또는 특정 환경을 위해.\(MAY\)

```text
     GenMsgContent ::= SEQUENCE OF InfoTypeAndValue
```

-- EE, RA 또는 CA에서 전송될 수 있습니다\(메시지 내용에 따라 다름\). -- InfoTypeAndValue의 선택적 infoValue 매개변수는 -- 일반적으로 위에 제시된 일부 예에서는 생략됩니다. -- 수신자는 포함된 OBJ를 자유롭게 무시할 수 있습니다. 인식할 수 없는 ID입니다. EE에서 CA로 전송되는 경우 빈 세트는 CA가 원하는 모든 정보를 보낼 수 있음을 나타냅니다.\(MAY\)

GenRepContent ::= InfoTypeAndValue의 순서 - 수신자는 인식하지 못하는 포함된 OID를 모두 무시할 수 있습니다.\(MAY\)

```text
     ErrorMsgContent ::= SEQUENCE {
         pKIStatusInfo          PKIStatusInfo,
         errorCode              INTEGER           OPTIONAL,
         -- implementation-specific error codes
         errorDetails           PKIFreeText       OPTIONAL
         -- implementation-specific error details
     }

     PollReqContent ::= SEQUENCE OF SEQUENCE {
         certReqId              INTEGER
     }

     PollRepContent ::= SEQUENCE OF SEQUENCE {
         certReqId              INTEGER,
         checkAfter             INTEGER,  -- time in seconds
         reason                 PKIFreeText OPTIONAL
     }

     END -- of CMP module
```

---
# **Appendix G.  Acknowledgements**

저자들은 IETF PKIX 작업 그룹 및 ICSA CA-talk 메일링 목록\(CMP 상호 운용성 노력 논의에만 전념하는 목록\)의 다양한 구성원의 기여에 감사드립니다. 이러한 기여 중 다수는 이 사양의 유용성을 크게 명확하게 하고 개선했습니다. Tomi Kause는 검토와 의견을 주신 Vesa Suontama와 Toni Tammisalo에게 감사드립니다.

---
# **Authors' Addresses**

Carlisle Adams University of Ottawa 800 King Edward Avenue P.O.Box 450, Station A Ottawa, Ontario K1N 6N5 CA

```text
   Phone: (613) 562-5800 ext. 2345
   Fax:   (613) 562-5664
   EMail: cadams@site.uottawa.ca

   Stephen Farrell
   Trinity College Dublin
   Distributed Systems Group
   Computer Science Department
   Dublin
   IE

   Phone: +353-1-608-2945
   EMail: stephen.farrell@cs.tcd.ie

   Tomi Kause
   SSH Communications Security Corp
   Valimotie 17
   Helsinki  00380
   FI

   Phone: +358 20 500 7415
   EMail: toka@ssh.com

   Tero Mononen
   SafeNet, Inc.
   Fredrikinkatu 47
   Helsinki  00100
   FI

   Phone: +358 20 500 7814
   EMail: tmononen@safenet-inc.com
```

---
# **Full Copyright Statement**

Copyright \(C\) The Internet Society \(2005\).

이 문서는 BCP 78에 포함된 권리, 라이선스 및 제한 사항의 적용을 받으며 여기에 명시된 경우를 제외하고 작성자는 모든 권리를 보유합니다.

이 문서 및 여기에 포함된 정보는 "있는 그대로" 제공되며 기여자, 기여자가 대표하거나 후원하는 조직\(있는 경우\), 인터넷 사회 및 인터넷 공학 태스크포스는 모든 명시적 또는 묵시적 보증을 부인합니다. 여기에서 구성은 상품성 또는 특정 목적에의 적합성에 대한 권리 또는 묵시적 보증을 침해하지 않습니다.

---
# **Intellectual Property**

IETF는 이 문서에 설명된 기술의 구현 또는 사용과 관련이 있다고 주장할 수 있는 지적 재산권 또는 기타 권리의 유효성 또는 범위 또는 그러한 권리에 따른 라이센스의 범위에 대해 어떠한 입장도 취하지 않습니다. 는 가능하다; 또한 그러한 권리를 식별하기 위해 독립적인 노력을 기울였다는 것을 나타내지 않습니다. RFC 문서의 권리와 관련된 절차에 대한 정보는 BCP 78 및 BCP 79에서 찾을 수 있습니다.

IETF 사무국에 제출된 IPR 공개 사본 및 사용 가능한 라이선스에 대한 보증 또는 이 사양의 구현자 또는 사용자가 이러한 독점권 사용에 대한 일반 라이선스 또는 허가를 얻으려는 시도의 결과를 얻을 수 있습니다. http://www.ietf.org/ipr의 IETF 온라인 IPR 저장소에서.

IETF는 이 표준을 구현하는 데 필요할 수 있는 기술을 포함할 수 있는 저작권, 특허 또는 특허 출원 또는 기타 소유권에 관심을 갖도록 이해 당사자를 초대합니다. 정보를 IETF\(ietf-ipr@ietf.org\)로 보내주십시오.

---
# **Acknowledgement**

RFC 편집기 기능에 대한 자금은 현재 Internet Society에서 제공하고 있습니다.
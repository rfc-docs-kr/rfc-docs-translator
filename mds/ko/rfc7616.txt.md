

```text
Internet Engineering Task Force (IETF)               R. Shekh-Yusef, Ed.
Request for Comments: 7616                                         Avaya
Obsoletes: 2617                                                D. Ahrens
Category: Standards Track                                    Independent
ISSN: 2070-1721                                                S. Bremer
                                                             Netzkonform
                                                          September 2015

                   HTTP Digest Access Authentication
```

---
# **Abstract**

HTTP\(Hypertext Transfer Protocol\)는 서버가 클라이언트 요청에 도전하고 클라이언트가 인증 정보를 제공하는 데 사용할 수 있는 간단한 도전-응답 인증 메커니즘을 제공합니다. 이 문서는 HTTP 인증 메커니즘과 함께 사용할 수 있는 HTTP 다이제스트 인증 체계를 정의합니다.

---
# **Status of This Memo**

이것은 인터넷 표준 추적 문서입니다.

이 문서는 IETF\(Internet Engineering Task Force\)의 제품입니다. 이는 IETF 커뮤니티의 합의를 나타냅니다. 공개 검토를 받았으며 IESG\(Internet Engineering Steering Group\)의 출판 승인을 받았습니다. 인터넷 표준에 대한 자세한 내용은 RFC 5741의 섹션 2에서 확인할 수 있습니다.

이 문서의 현재 상태, 정오표, 피드백 제공 방법에 대한 정보는 http://www.rfc-editor.org/info/rfc7616에서 얻을 수 있습니다.

---
# **Copyright Notice**

Copyright \(c\) 2015 IETF Trust 및 문서 작성자로 확인된 사람. 판권 소유.

이 문서는 이 문서의 발행일에 유효한 BCP 78 및 IETF 문서에 관한 IETF 트러스트의 법적 조항\(http://trustee.ietf.org/license-info\)의 적용을 받습니다. 이 문서와 관련된 귀하의 권리 및 제한 사항을 설명하므로 이 문서를 주의 깊게 검토하십시오. 이 문서에서 추출한 코드 구성 요소는 Trust Legal Provisions의 섹션 4.e에 설명된 대로 Simplified BSD License 텍스트를 포함해야 하며 Simplified BSD License에 설명된 대로 보증 없이 제공됩니다.

이 문서에는 2008년 11월 10일 이전에 공개되거나 공개된 IETF 문서 또는 IETF 기고문의 자료가 포함될 수 있습니다. 이 자료의 일부에 대한 저작권을 제어하는 ​​사람은 해당 자료의 수정을 허용할 권리를 IETF 트러스트에 부여하지 않았을 수 있습니다. IETF 표준 프로세스 외부. 이러한 자료의 저작권을 관리하는 사람으로부터 적절한 라이센스를 얻지 않고 이 문서는 IETF 표준 프로세스 외부에서 수정할 수 없으며 IETF 표준 프로세스 외부에서 이 문서의 파생물을 생성할 수 없습니다. RFC로 게시하거나 영어 이외의 언어로 번역합니다.

---
# **Table of Contents**

```text
   1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   4
     1.1.  Terminology . . . . . . . . . . . . . . . . . . . . . . .   4
   2.  Syntax Convention . . . . . . . . . . . . . . . . . . . . . .   4
     2.1.  Examples  . . . . . . . . . . . . . . . . . . . . . . . .   4
     2.2.  ABNF  . . . . . . . . . . . . . . . . . . . . . . . . . .   4
   3.  Digest Access Authentication Scheme . . . . . . . . . . . . .   5
     3.1.  Overall Operation . . . . . . . . . . . . . . . . . . . .   5
     3.2.  Representation of Digest Values . . . . . . . . . . . . .   5
     3.3.  The WWW-Authenticate Response Header Field  . . . . . . .   5
     3.4.  The Authorization Header Field  . . . . . . . . . . . . .   9
       3.4.1.  Response  . . . . . . . . . . . . . . . . . . . . . .  11
       3.4.2.  A1  . . . . . . . . . . . . . . . . . . . . . . . . .  11
       3.4.3.  A2  . . . . . . . . . . . . . . . . . . . . . . . . .  12
       3.4.4.  Username Hashing  . . . . . . . . . . . . . . . . . .  12
       3.4.5.  Parameter Values and Quoted-String  . . . . . . . . .  12
       3.4.6.  Various Considerations  . . . . . . . . . . . . . . .  13
     3.5.  The Authentication-Info and Proxy-Authentication-Info
           Header Fields . . . . . . . . . . . . . . . . . . . . . .  14
     3.6.  Digest Operation  . . . . . . . . . . . . . . . . . . . .  15
     3.7.  Security Protocol Negotiation . . . . . . . . . . . . . .  16
     3.8.  Proxy-Authenticate and Proxy-Authorization  . . . . . . .  17
     3.9.  Examples  . . . . . . . . . . . . . . . . . . . . . . . .  18
       3.9.1.  Example with SHA-256 and MD5  . . . . . . . . . . . .  18
       3.9.2.  Example with SHA-512-256, Charset, and Userhash . . .  19
   4.  Internationalization Considerations . . . . . . . . . . . . .  20
   5.  Security Considerations . . . . . . . . . . . . . . . . . . .  21
     5.1.  Limitations . . . . . . . . . . . . . . . . . . . . . . .  21
     5.2.  Storing Passwords . . . . . . . . . . . . . . . . . . . .  21
     5.3.  Authentication of Clients Using Digest Authentication . .  22
     5.4.  Limited-Use Nonce Values  . . . . . . . . . . . . . . . .  23
     5.5.  Replay Attacks  . . . . . . . . . . . . . . . . . . . . .  23
     5.6.  Weakness Created by Multiple Authentication Schemes . . .  24
     5.7.  Online Dictionary Attacks . . . . . . . . . . . . . . . .  24
     5.8.  Man-in-the-Middle Attacks . . . . . . . . . . . . . . . .  25
     5.9.  Chosen Plaintext Attacks  . . . . . . . . . . . . . . . .  25
     5.10. Precomputed Dictionary Attacks  . . . . . . . . . . . . .  26
     5.11. Batch Brute-Force Attacks . . . . . . . . . . . . . . . .  26
     5.12. Parameter Randomness  . . . . . . . . . . . . . . . . . .  26
     5.13. Summary . . . . . . . . . . . . . . . . . . . . . . . . .  26
   6.  IANA Considerations . . . . . . . . . . . . . . . . . . . . .  27
     6.1.  Hash Algorithms for HTTP Digest Authentication  . . . . .  27
     6.2.  Digest Scheme Registration  . . . . . . . . . . . . . . .  28
   7.  References  . . . . . . . . . . . . . . . . . . . . . . . . .  28
     7.1.  Normative References  . . . . . . . . . . . . . . . . . .  28
     7.2.  Informative References  . . . . . . . . . . . . . . . . .  30
   Appendix A.  Changes from RFC 2617  . . . . . . . . . . . . . . .  31
   Acknowledgments . . . . . . . . . . . . . . . . . . . . . . . . .  31
   Authors' Addresses  . . . . . . . . . . . . . . . . . . . . . . .  32
```

---
## **1.  Introduction**

HTTP는 서버가 클라이언트 요청에 도전하고 클라이언트가 인증 정보를 제공하는 데 사용할 수 있는 간단한 도전-응답 인증 메커니즘을 제공합니다. 이 문서는 HTTP 인증 메커니즘과 함께 사용할 수 있는 HTTP 다이제스트 인증 체계를 정의합니다.

이 문서는 확장되지만 일반적으로 \[RFC2617\]과 역호환됩니다. 이 사양에 도입된 새로운 기능은 부록 A를 참조하세요.

시도-응답 인증 메커니즘의 세부 사항은 "Hypertext Transfer Protocol\(HTTP/1.1\): 인증" \[RFC7235\]에 지정되어 있습니다.

"기본" 인증 체계 \[RFC7617\], "HTTP 인증 정보 및 프록시 인증 정보 응답 헤더 필드" \[RFC7615\] 및 "하이퍼텍스트 전송 프로토콜\(HTTP/1.1\)의 정의와 이 문서의 조합: 인증 " \[RFC7235\] 더 이상 사용되지 않습니다. \[RFC2617\].

---
### **1.1.  Terminology**

키워드 "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY" 및 "OPTIONAL" "는 \[RFC2119\]에 설명된 대로 해석됩니다.\(MUST NOT\)

---
## **2.  Syntax Convention**
---
### **2.1.  Examples**

명확성과 가독성을 위해 이 문서의 예제에 있는 확장 매개변수 또는 헤더 필드와 매개변수는 여러 줄로 나누어질 수 있습니다. 이 문서에서 들여쓰기된 줄은 이전 줄의 연속입니다.

---
### **2.2.  ABNF**

이 사양은 \[RFC5234\]의 ABNF\(Augmented Backus-Naur Form\) 표기법과 \[RFC7230\]의 ABNF 목록 확장을 사용합니다.

---
## **3.  Digest Access Authentication Scheme**
---
### **3.1.  Overall Operation**

다이제스트 방식은 단순한 시도-응답 패러다임을 기반으로 합니다. 다이제스트 체계는 nonce 값을 사용하여 문제를 제기하며 사용자 이름 해싱이 지원된다는 것을 나타낼 수 있습니다. 유효한 응답에는 사용자 이름, 비밀번호, 주어진 nonce 값, HTTP 메소드 및 요청된 URI의 키가 지정되지 않은 다이제스트가 포함됩니다. 이런 방식으로 비밀번호는 절대 일반 텍스트로 전송되지 않으며 서버에서 받은 표시에 따라 사용자 이름이 해시될 수 있습니다. 사용자 이름과 비밀번호는 이 문서에서 다루지 않는 방식으로 미리 정렬되어야 합니다.

---
### **3.2.  Representation of Digest Values**

선택적 헤더 필드를 사용하면 서버는 키가 없는 다이제스트 또는 다이제스트를 생성하는 데 사용되는 알고리즘을 지정할 수 있습니다. 이 문서에는 SHA-256 및 SHA-512/256 알고리즘이 추가되어 있습니다. \[RFC2617\]과의 하위 호환성을 유지하기 위해 MD5 알고리즘이 계속 지원되지만 권장되지는 않습니다.\(SHOULD NOT\)

다이제스트의 크기는 사용된 알고리즘에 따라 다릅니다. 다이제스트의 비트는 다음과 같이 최상위 비트에서 최하위 비트로 한 번에 4비트씩 ASCII 표현으로 변환됩니다. 4비트의 각 시퀀스는 0123456789abcdef 문자의 친숙한 16진수 표기법으로 표시됩니다. 즉, 이진수 0000은 문자 '0'으로 표시되고, 0001은 '1'로 표시되는 식으로 1111은 'f'로 표시됩니다. MD5 알고리즘을 사용하여 다이제스트를 계산하는 경우 MD5 다이제스트는 32개의 16진수 문자로 표시되고 SHA-256 및 SHA-512/256은 64개의 16진수 문자로 표시됩니다.

---
### **3.3.  The WWW-Authenticate Response Header Field**

서버가 액세스 보호된 객체에 대한 요청을 받았지만 승인 가능한 Authorization 헤더 필드가 전송되지 않은 경우, 서버는 위에 정의된 프레임워크에 따라 Digest 체계를 사용하여 "401 Unauthorized" 상태 코드와 WWW-Authenticate 헤더 필드로 응답합니다. . 헤더 필드의 값에는 다음 목록의 매개변수가 포함될 수 있습니다.

```text
   realm
```

- 사용할 사용자 이름과 비밀번호를 알 수 있도록 사용자에게 표시되는 문자열입니다. 이 문자열에는 최소한 인증을 수행하는 호스트의 이름이 포함되어야 하며 추가적으로 액세스 권한이 있는 사용자 모음을 나타낼 수도 있습니다. 안

- 예는 "registered\_users@example.com"입니다. \(자세한 내용은 \[RFC7235\]의 섹션 2.2를 참조하세요.\)

```text
   domain
```

- 보호 공간을 정의하는 \[RFC3986\]에 지정된 대로 인용되고 공백으로 구분된 URI 목록입니다. URI가 경로 절대인 경우 이는 표준 루트 URL을 기준으로 합니다. \(\[RFC7235\]의 섹션 2.2를 참조하십시오.\) 이 목록의 절대 URI는 웹 원본 \[RFC6454\]과 다른 서버를 참조할 수 있습니다. 클라이언트는 이 목록을 사용하여 동일한 인증 정보가 전송될 수 있는 URI 집합을 결정할 수 있습니다. 이 목록에 접두사로 URI가 있는 모든 URI\(둘 다 절대화된 후\)는 동일한 것으로 간주될 수 있습니다. 보호 공간. 이 매개변수가 생략되거나 해당 값이 비어 있는 경우 클라이언트는 보호 공간이 웹 원본의 모든 URI로 구성되어 있다고 가정해야 합니다\(SHOULD\).\(MAY, SHOULD\)

- 이 매개변수는 보호 공간이 항상 전체 프록시인 Proxy-Authenticate 헤더 필드에서는 의미가 없습니다. 존재하는 경우 무시해야 합니다.\(MUST\)

```text
   nonce
```

- 401 응답이 이루어질 때마다 고유하게 생성되어야 하는 서버 지정 문자열입니다. 이 문자열은 Base64 또는 16진수 데이터인 것이 좋습니다. 특히, 문자열은 헤더 필드 행에 인용된 문자열로 전달되므로 적절하게 이스케이프하지 않는 한 큰따옴표 문자는 허용되지 않습니다.

- nonce의 내용은 구현에 따라 다릅니다. 구현의 품질은 올바른 선택에 달려 있습니다. 예를 들어 nonce는 다음의 Base64 인코딩으로 구성될 수 있습니다.

```text
            timestamp H(timestamp ":" ETag ":" secret-data)
```

- 타임스탬프는 서버에서 생성된 시간으로, 바람직하게는 마이크로초 또는 나노초 또는 기타 반복되지 않는 값을 포함합니다. ETag는 요청된 엔터티와 관련된 HTTP ETag 헤더 필드의 값입니다. 비밀 데이터는 서버에만 알려진 데이터입니다. 이 형식의 nonce를 사용하면 서버는 클라이언트 인증 헤더 필드를 수신한 후 해시 부분을 다시 계산하고 해당 헤더 필드의 nonce와 일치하지 않거나 타임스탬프 값이 충분히 최신이 아닌 경우 요청을 거부합니다. 이러한 방식으로 서버는 nonce의 유효 기간을 제한할 수 있습니다. ETag를 포함하면 업데이트된 리소스 버전에 대한 재생 요청이 방지됩니다. nonce에 클라이언트의 IP 주소를 포함하면 nonce의 재사용을 동일한 클라이언트로 제한하는 기능을 서버에 제공하는 것으로 보입니다.

- 원래는 그랬어요. 그러나 단일 사용자의 요청이 종종 다른 프록시를 통과하기 때문에 이는 중단될 수 있습니다. 또한 IP 주소 스푸핑은 그리 어렵지 않습니다.

- 구현에서는 재생 공격으로부터 보호하기 위해 이전에 사용된 nonce 또는 이전에 사용된 다이제스트를 허용하지 않도록 선택할 수 있습니다. 또는 구현 시 POST 또는 PUT 요청에 일회성 nonce 또는 다이제스트를 사용하고 GET 요청에 타임스탬프를 사용하도록 선택할 수 있습니다. 관련된 문제에 대한 자세한 내용은 이 문서의 섹션 5를 참조하세요.

- nonce는 클라이언트에게 불투명합니다.

```text
   opaque
```

- 서버에 의해 지정된 데이터 문자열은 동일한 보호 공간에 있는 URI를 사용하는 후속 요청의 Authorization 헤더 필드에서 변경되지 않고 클라이언트에 의해 반환되어야 합니다. 이 문자열은 Base64 또는 16진수 데이터인 것이 좋습니다.\(SHOULD, SHOULD\)

```text
   stale
```

- nonce 값이 오래되었기 때문에 클라이언트의 이전 요청이 거부되었음을 나타내는 대소문자를 구분하지 않는 플래그입니다. stale이 true인 경우 클라이언트는 사용자에게 새 사용자 이름과 비밀번호를 다시 묻는 메시지를 표시하지 않고 암호화된 새 응답으로 요청을 다시 시도할 수 있습니다. 서버는 nonce가 유효하지 않은 요청을 받은 경우에만 stale을 true로 설정해야 합니다. stale이 false이거나 true가 아닌 경우 또는 stale 매개변수가 존재하지 않는 경우 사용자 이름 및/또는 비밀번호는 유효하지 않으며 새 값을 얻어야 합니다.\(SHOULD, MUST\)

```text
   algorithm
```

- 다이제스트와 키가 없는 다이제스트를 생성하는 데 사용되는 알고리즘을 나타내는 문자열입니다. 이것이 없으면 "MD5"로 간주됩니다. 알고리즘이 이해되지 않으면 챌린지를 무시해야 합니다\(그리고 둘 이상이 있는 경우 다른 챌린지를 사용해야 합니다\).\(SHOULD\)

- 다이제스트 메커니즘과 함께 사용하면 각 알고리즘에는 세션 변형과 비세션 변형이라는 두 가지 변형이 있습니다. 비세션 변형은 "<알고리즘\>"\(예: "SHA-256"\)으로 표시되고 세션 변형은 "<알고리즘\>-sess"\(예: "SHA-256-sess"\)로 표시됩니다.

- 본 문서에서는 비밀이 "secret"인 데이터 "data"에 다이제스트 알고리즘을 적용하여 얻은 문자열을 KD\(secret, data\)로 표시하고,

- 데이터 "데이터"에 대한 키가 지정되지 않은 다이제스트 알고리즘은 H\(데이터\)로 표시됩니다. KD는 Keyed Digest를 의미하며, unq\(X\) 표기법은 주변 따옴표가 없고 따옴표 슬래시가 제거된 따옴표 붙은 문자열 X의 값을 의미합니다.

```text
        For "<algorithm>" and "<algorithm>-sess"

            H(data) = <algorithm>(data)

        and

            KD(secret, data) = H(concat(secret, ":", data))
```

-  예를 들어:

```text
        For the "SHA-256" and "SHA-256-sess" algorithms

            H(data) = SHA-256(data)
```

- 즉, 다이제스트는 데이터와 연결된 콜론과 연결된 비밀의 "<알고리즘\>"입니다. "<algorithm\>-sess"는 효율적인 타사 인증 서버를 허용하기 위한 것입니다. 사용법의 차이는 섹션 3.4.2의 설명을 참조하세요.

```text
   qop
```

- 이 매개변수는 모든 구현에서 사용되어야 합니다. 서버에서 지원하는 "보호 품질" 값을 나타내는 하나 이상의 토큰을 따옴표로 묶은 문자열입니다. "auth" 값은 인증을 나타냅니다. "auth-int" 값은 무결성 보호가 포함된 인증을 나타냅니다. 이 선택 사항을 적용하기 위한 응답 매개변수 값을 계산하려면 아래 설명을 참조하세요. 인식할 수 없는 옵션은 무시해야 합니다.\(MUST, MUST\)

```text
   charset
```

- 서버가 지원하는 인코딩 체계를 나타내기 위해 사용하는 선택적 매개변수입니다. 허용되는 유일한 값은 "UTF-8"입니다.\(MAY\)

```text
   userhash
```

- 이는 서버가 사용자 이름 해싱을 지원함을 나타내기 위해 사용하는 선택적 매개변수입니다. 유효한 값은 "true" 또는 "false"입니다. 기본값은 "거짓"입니다.\(MAY\)

역사적인 이유로 발신자는 영역, 도메인, nonce, 불투명 및 qop 매개변수에 대해 인용된 문자열 구문 값만 생성해야 합니다.\(MUST\)

역사적인 이유로 발신자는 stale 및 알고리즘 매개변수에 대해 인용된 문자열 구문 값을 생성해서는 안 됩니다.\(MUST NOT\)

---
### **3.4.  The Authorization Header Field**

클라이언트는 위의 프레임워크에 따라 정의된 다이제스트 체계를 사용하여 Authorization 헤더 필드 행을 전달하여 요청을 재시도해야 합니다. 불투명 및 알고리즘 필드의 값은 요청 중인 엔터티에 대한 WWW-Authenticate 응답 헤더 필드에 제공되는 값이어야 합니다.

요청에는 다음 목록의 매개변수가 포함될 수 있습니다.

```text
   response
```

- 아래에 정의된 대로 계산된 16진수 문자열입니다. 이는 사용자가 비밀번호를 알고 있음을 증명합니다.

```text
   username
```

- 지정된 영역의 사용자 이름입니다. 인용된 문자열에는 일반 텍스트의 이름이나 16진수 표기법의 해시 코드가 포함됩니다. 사용자 이름에 ABNF 인용 문자열 생성 내에서 허용되지 않는 문자가 포함된 경우 사용자 이름\* 매개변수를 사용할 수 있습니다. 동일한 헤더 옵션에 사용자 이름과 사용자 이름\*을 모두 보내는 것은 오류로 처리되어야 합니다.\(MUST\)

```text
   username*
```

- userhash 매개변수 값이 "false"로 설정되고 사용자 이름에 ABNF 인용 문자열 생성 내에서 허용되지 않는 문자가 포함된 경우 \[RFC5987\]에 정의된 확장 표기법을 사용하여 이 매개변수와 함께 사용자 이름을 보낼 수 있습니다.

```text
   realm
```

- 섹션 3.3의 "영역" 정의를 참조하세요.

```text
   uri
```

- HTTP 요청의 유효 요청 URI\(\[RFC7230\]의 섹션 5.5\) 프록시가 전송 중에 요청 대상\("request-target", \[RFC7230\]의 섹션 3.1.1\)을 변경할 수 있기 때문에 여기에 중복되었습니다.

```text
   qop
```

- 클라이언트가 메시지에 적용한 "보호 품질"을 나타냅니다. 해당 값은 서버가 WWW-Authenticate 헤더 필드에서 지원한다고 표시한 대안 중 하나여야 합니다. 이러한 값은 반응 계산에 영향을 미칩니다. 이는 WWW 인증에서와 같이 인용된 대안 목록이 아니라 단일 토큰이라는 점에 유의하십시오.\(MUST\)

```text
   cnonce
```

- 이 매개변수는 모든 구현에서 사용되어야 합니다. cnonce 값은 클라이언트가 제공하고 선택된 일반 텍스트 공격을 방지하고 상호 인증을 제공하며 일부 메시지 무결성 보호를 제공하기 위해 클라이언트와 서버 모두에서 사용되는 불투명하게 인용된 ASCII 전용 문자열 값입니다. rspauth 및 응답 값 계산에 대한 아래 설명을 참조하세요.\(MUST\)

```text
   nc
```

- 이 매개변수는 모든 구현에서 사용되어야 합니다. nc 매개변수는 "nonce count"를 나타냅니다. nc 값은 클라이언트가 이 요청에 nonce 값을 사용하여 보낸 요청\(현재 요청 포함\) 수를 16진수로 나타낸 것입니다. 예를 들어, 주어진 nonce 값에 대한 응답으로 전송된 첫 번째 요청에서 클라이언트는 "nc=00000001"을 전송합니다. 이 매개변수의 목적은 서버가 이 카운트의 자체 복사본을 유지하여 요청 재생을 감지할 수 있도록 하는 것입니다. 동일한 nc 값이 두 번 표시되면 요청은 재생입니다. 응답 값 구성에 대한 아래 설명을 참조하세요.\(MUST\)

```text
   userhash
```

- 이 선택사항 매개변수는 사용자 이름이 해시되었음을 나타내기 위해 클라이언트에서 사용됩니다. 유효한 값은 "true" 또는 "false"입니다. 기본값은 "거짓"입니다.\(MAY\)

역사적인 이유로 발신자는 사용자 이름, 영역, nonce, uri, 응답, cnonce 및 opaque 매개변수에 대해 인용된 문자열 구문만 생성해야 합니다.\(MUST\)

역사적인 이유로 발신자는 알고리즘, qop 및 nc 매개변수에 대해 인용된 문자열 구문을 생성해서는 안 됩니다.\(MUST NOT\)

매개변수 또는 해당 값이 부적절하거나 필수 매개변수가 누락된 경우 올바른 응답은 4xx 오류 코드입니다. 응답이 유효하지 않은 경우 로그인 실패를 기록해야 합니다. 단일 클라이언트에서 반복적으로 로그인이 실패하면 공격자가 다음을 시도하고 있음을 나타낼 수 있기 때문입니다.\(SHOULD\)

비밀번호를 추측해 보세요. 서버 구현에서는 로그에 일반 텍스트 비밀번호\(예: 사용자 이름 필드에 입력\)를 입력하지 않도록 기록되는 정보에 주의해야 합니다.\(SHOULD\)

위 응답의 정의는 해당 값의 인코딩을 나타냅니다. 다음 정의는 값이 계산되는 방법을 보여줍니다.

---
#### **3.4.1.  Response**

qop 값이 "auth" 또는 "auth-int"인 경우:

```text
         response = <"> < KD ( H(A1), unq(nonce)
                                      ":" nc
                                      ":" unq(cnonce)
                                      ":" unq(qop)
                                      ":" H(A2)
                             ) <">
```

A1과 A2에 대한 정의는 아래를 참조하세요.

---
#### **3.4.2.  A1**

알고리즘 매개변수의 값이 "<algorithm\>"\(예: "SHA-256"\)인 경우 A1은 다음과 같습니다.

```text
         A1       = unq(username) ":" unq(realm) ":" passwd

   where

         passwd   = < user's password >
```

알고리즘 매개변수의 값이 "<algorithm\>-sess"\(예: "SHA- 256-sess"\)인 경우 A1은 서버의 챌린지에서 제공된 nonce 값을 사용하여 계산되고 클라이언트의 요청에 따른 cnonce 값은 다음과 같습니다. 서버로부터 WWW 인증 요청을 받았습니다. 여기서는 nonce-prime이라고 하는 해당 챌린지의 서버 nonce와 응답의 클라이언트 nonce 값\(여기서는 cnonce-prime이라고 함\)을 사용하여 A1을 다음과 같이 구성합니다.

```text
         A1       = H( unq(username) ":" unq(realm) ":" passwd )
                        ":" unq(nonce-prime) ":" unq(cnonce-prime)
```

이는 각 "인증 세션"마다 다른 후속 요청 및 응답의 인증을 위한 "세션 키"를 생성하므로 하나의 키로 해시되는 자료의 양이 제한됩니다. \(참고: 섹션 3.6의 인증 세션에 대한 자세한 설명을 참조하십시오.\) 서버는 A1 값을 생성하기 위해 사용자 자격 증명의 해시만 사용하면 되므로 이 구성은 다음과 같습니다.

웹 서버에 실제 비밀번호 값이 필요하지 않도록 타사 인증 서비스와 함께 사용됩니다. 그러한 프로토콜의 사양은 이 사양의 범위를 벗어납니다.

---
#### **3.4.3.  A2**

qop 매개변수의 값이 "auth"이거나 지정되지 않은 경우 A2는 다음과 같습니다.

```text
         A2       = Method ":" request-uri
```

qop 값이 "auth-int"이면 A2는 다음과 같습니다.

```text
         A2       = Method ":" request-uri ":" H(entity-body)
```

---
#### **3.4.4.  Username Hashing**

클라이언트에서 서버로의 사용자 이름 전송을 보호하려면 서버는 WWW-Authentication 헤더 필드에 userhash 매개변수를 "true" 값으로 설정해야 합니다.\(SHOULD\)

클라이언트가 userhash 매개변수를 지원하고 WWW-Authentication 헤더 필드의 userhash 매개변수 값이 "true"로 설정된 경우 클라이언트는 다른 해시 계산 후에 사용자 이름의 해시를 계산하고 해당 값에 userhash 매개변수를 포함해야 합니다. Authorization 헤더 필드가 "true"입니다. 클라이언트가 사용자 이름을 해시 값으로 제공하지 않거나 userhash 매개변수 값이 "true"인 경우 서버는 요청을 거부할 수 있습니다.\(MUST, MAY\)

다음은 자격 증명을 해시하는 데 사용되는 것과 동일한 알고리즘을 사용하여 클라이언트가 사용자 이름을 해시하기 위해 수행하는 작업입니다.

```text
      username = H( unq(username) ":" unq(realm) )
```

---
#### **3.4.5.  Parameter Values and Quoted-String**

사용자 이름 값과 같은 많은 매개변수의 값은 "인용 문자열"로 정의됩니다. 그러나 "unq" 표기법은 문자열 A1을 형성할 때 주변 따옴표가 제거됨을 나타냅니다. 따라서 Authorization 헤더 필드에 다음 필드가 포함되어 있는 경우

```text
      username="Mufasa", realm="myhost@example.com"
```

사용자 Mufasa의 비밀번호가 "Circle Of Life"인 경우 H\(A1\)은 요약된 문자열에 따옴표 없이 H\(Mufasa:myhost@example.com:Circle Of Life\)가 됩니다.

다이제스트 함수 H\(\)가 적용되는 문자열에는 공백이 허용되지 않습니다. 단, 다이제스트할 문자열을 구성하는 내용이 포함된 인용 문자열이나 엔터티 본문에 공백이 있는 경우는 예외입니다. 예를 들어 위에 표시된 문자열 A1은 다음과 같아야 합니다.

- Mufasa:myhost@example.com:Circle Of Life

콜론 양쪽에 공백이 없지만 암호 값에 사용된 단어 사이에 공백이 있습니다. 마찬가지로, H\(\)에 의해 소화된 다른 문자열은 공백이 인용된 문자열이나 소화되는 엔터티 본문에 있지 않는 한 해당 필드를 구분하는 콜론 양쪽에 공백이 있어서는 안 됩니다.

또한 무결성 보호가 적용된 경우\(qop=auth-int\) H\(entity-body\)는 메시지 본문이 아니라 엔터티 본문의 해시입니다. 이는 보낸 사람이 전송 인코딩을 적용하기 전에 계산됩니다. 수신자가 삭제한 후. 여기에는 멀티파트 콘텐츠 유형의 각 부분에 멀티파트 경계와 포함된 헤더 필드가 포함됩니다.

---
#### **3.4.6.  Various Considerations**

"Method" 값은 \[RFC7230\]의 섹션 3.1.1에 지정된 대로 US-ASCII 문자로 된 HTTP 요청 방법입니다. "request-target" 값은 \[RFC7230\]의 섹션 3.1.1에 지정된 요청 라인의 요청 대상입니다. 이는 \[RFC7230\]의 섹션 2.7에 지정된 대로 "\*", "절대 URI" 또는 "절대 경로"일 수 있지만 요청 대상과 일치해야 합니다. 특히 요청 대상이 "절대 URI"인 경우 "절대 URI"여야 합니다. connonce 값은 선택한 일반 텍스트 공격을 저지하기 위해 클라이언트가 선택한 값입니다.\(MUST, MUST\)

인증 서버는 "uri" 매개변수로 지정된 리소스가 요청 라인에 지정된 리소스와 동일한지 확인해야 합니다. 그렇지 않은 경우 서버는 400 잘못된 요청 오류를 반환해야 합니다. \(이것은 공격의 증상일 수 있으므로 서버 구현자는 그러한 오류 기록을 고려할 수 있습니다.\) 이 필드의 요청 URL에서 정보를 복제하는 목적은 중간 프록시가 클라이언트의 요청을 변경할 수 있는 가능성을 처리하는 것입니다. 선. 이 변경된\(그러나 아마도 의미적으로는 동일한\) 요청은 클라이언트가 계산한 것과 동일한 다이제스트를 생성하지 않습니다.\(MUST\)

구현자는 인증된 트랜잭션이 공유 캐시와 상호 작용하는 방법을 알고 있어야 합니다\(\[RFC7234\] 참조\).

3.5. 인증 정보 및 프록시 인증 정보 헤더 필드

Authentication-Info 헤더 필드와 Proxy-Authentication-Info 헤더 필드\[RFC7615\]는 서버가 클라이언트 응답의 성공적인 인증에 관한 일부 정보를 전달하는 데 사용할 수 있는 일반 필드입니다.\(MAY\)

다이제스트 인증 체계는 확인 요청에 인증 정보 헤더 필드를 추가하고 다음 목록의 매개변수를 포함할 수 있습니다.\(MAY\)

```text
   nextnonce
```

- nextnonce 매개변수의 값은 서버가 클라이언트가 향후 인증 응답에 사용하기를 원하는 nonce입니다. 서버는 일회성 nonce를 구현하거나 nonce를 변경하는 수단으로 nextnonce 필드와 함께 Authentication-Info 헤더 필드를 보낼 수 있습니다. nextnonce 필드가 존재하는 경우 클라이언트는 다음 요청에 대한 Authorization 헤더 필드를 구성할 때 이를 사용해야 합니다. 클라이언트가 실패하면 "stale=true"를 사용하여 서버에서 재인증 요청이 발생할 수 있습니다.\(MAY, SHOULD, MAY\)

서버 구현은 다음 사항을 신중하게 고려해야 합니다.

- 이 메커니즘의 사용이 성능에 미치는 영향 모든 응답에 서버가 수신한 다음 요청에 사용해야 하는 nextnonce 매개변수가 포함되어 있으면 파이프라인 요청이 불가능합니다. 요청 파이프라인을 허용하기 위해 제한된 시간 동안 이전 nonce 값을 사용하도록 허용하는 성능 대 보안 절충점을 고려해야 합니다. nc 매개변수를 사용하면 파이프라인에 해로운 영향을 주지 않고 새 서버 nonce의 보안 이점을 대부분 유지할 수 있습니다.\(MUST, SHOULD\)

```text
   qop
```

- 서버의 응답에 적용되는 "보호 품질" 옵션을 나타냅니다. "auth" 값은 인증을 나타냅니다. "auth-int" 값은 무결성 보호가 포함된 인증을 나타냅니다. 서버는 해당 요청에서 클라이언트가 보낸 것과 동일한 응답의 qop 매개변수 값을 사용해야 합니다.\(SHOULD\)

```text
   rspauth
```

- rspauth 매개변수의 선택적 응답 다이제스트는 상호 인증을 지원합니다. 즉, 서버는 사용자의 비밀을 알고 있음을 증명하고 qop=auth-int를 사용하면 응답의 제한된 무결성 보호도 제공합니다. rspauth 값은 Authorization 헤더 필드의 응답에 대해 계산됩니다. 단, qop가 "auth"로 설정되거나 요청에 대한 Authorization 헤더 필드에 지정되지 않은 경우 A2는 다음과 같습니다.

```text
         A2       = ":" request-uri
```

- 그리고 "qop=auth-int"이면 A2는

```text
         A2       = ":" request-uri ":" H(entity-body)
```

코논스와 NC

- cnonce 값과 nc 값은 이 메시지가 응답인 클라이언트 요청에 대한 값이어야 합니다. "qop=auth" 또는 "qop=auth-int"가 지정된 경우 rspauth, cnonce 및 nc 매개변수가 있어야 합니다.\(MUST, MUST\)

인증 정보 헤더 필드는 청크 전송 코딩을 통해 전송되는 HTTP 메시지의 트레일러에서 허용됩니다.

역사적인 이유로 발신자는 nextnonce, rspauth 및 cnonce 매개변수에 대해 인용된 문자열 구문만 생성해야 합니다.\(MUST\)

역사적인 이유로 발신자는 qop 및 nc 매개변수에 대해 인용된 문자열 구문을 생성해서는 안 됩니다.\(MUST NOT\)

역사적 이유로 nc 값은 정확히 8자리 16진수여야 합니다.\(MUST\)

---
### **3.6.  Digest Operation**

Authorization 헤더 필드를 수신하면 서버는 제출된 사용자 이름에 해당하는 비밀번호를 검색하여 유효성을 확인할 수 있습니다. 그런 다음 서버는 클라이언트가 수행한 것과 동일한 다이제스트 작업\(예: MD5, SHA-256\)을 수행하고 결과를 주어진 응답 값과 비교해야 합니다.\(MAY, MUST\)

HTTP 서버는 실제로 사용자의 일반 텍스트 비밀번호를 알 필요가 없습니다. 서버에서 H\(A1\)을 사용할 수 있는 한 Authorization 헤더 필드의 유효성을 확인할 수 있습니다.

보호 공간에 대한 WWW 인증 챌린지에 대한 클라이언트 응답은 해당 보호 공간과의 인증 세션을 시작합니다. 인증 세션은 클라이언트가 보호 공간의 서버로부터 또 다른 WWW 인증 요청을 받을 때까지 지속됩니다. 클라이언트는 해당 보호 공간 내의 향후 요청에서 Authorization 헤더 필드를 구성하는 데 사용하기 위해 인증 세션과 관련된 사용자 이름, 비밀번호, nonce, nonce 개수 및 불투명 값을 기억해야 합니다. Authorization 헤더 필드는 선제적으로 포함될 수 있습니다. 그렇게 하면 서버 효율성이 향상되고 인증 문제로 인한 추가 왕복을 피할 수 있습니다. 포함된 Nonce 값이 최신이 아니더라도 서버는 이전 Authorization 헤더 필드 정보를 수락하도록 선택할 수 있습니다. 대안으로, 서버는 WWW-Authenticate 헤더 필드에 새로운 nonce 값이 포함된 401 응답을 반환하여 클라이언트가 요청을 재시도하도록 할 수 있습니다. 이 응답에 "stale=true"를 지정하면 서버는 새 사용자 이름과 비밀번호를 묻는 메시지를 표시하지 않고 새 nonce로 다시 시도하도록 클라이언트에 지시합니다.\(SHOULD, MAY, MAY, MAY\)

클라이언트는 세션 기간 동안 서버에서 제공한 불투명 매개 변수 값을 반환해야 하므로 불투명 데이터를 사용하여 인증 세션 상태 정보를 전송할 수 있습니다. \(이러한 사용은 nonce에 상태를 포함함으로써 더 쉽고 안전하게 수행될 수도 있습니다.\) 예를 들어, 서버는 실제로 다른 서버에 있는 콘텐츠를 인증하는 일을 담당할 수 있습니다. 첫 번째 401 응답에 값이 두 번째 서버의 URI를 포함하는 도메인 매개변수와 값이 상태 정보를 포함하는 불투명 매개변수를 포함하도록 함으로써 이를 달성할 수 있습니다. 클라이언트는 요청을 재시도하며, 이때 서버는 두 번째 서버의 URI를 가리키는 "HTTP 리디렉션"\(\[RFC7231\]의 섹션 6.4\)으로 응답할 수 있습니다. 클라이언트는 리디렉션을 따르고 <opaque\> 데이터를 포함하여 Authorization 헤더 필드를 전달합니다.

프록시는 다이제스트 액세스 인증 체계에서 완전히 투명해야 합니다. 즉, WWW-Authenticate, Authentication-Info 및 Authorization 헤더 필드를 그대로 전달해야 합니다. 요청이 서버로 전달되기 전에 프록시가 클라이언트를 인증하려는 경우 아래 섹션 3.8에 설명된 Proxy-Authenticate 및 Proxy-Authorization 헤더 필드를 사용하여 수행할 수 있습니다.\(MUST, MUST\)

---
### **3.7.  Security Protocol Negotiation**

클라이언트가 처리할 수 있는 보안 체계가 무엇인지 서버가 알 수 있으면 유용합니다.

서버가 인증 방법으로 다이제스트를 요구할 수도 있습니다.

클라이언트가 지원합니다. 서버가 처리할 수 없는 인증 체계만 지정하는 경우 클라이언트는 정상적으로 실패하도록 권장됩니다.

서버가 리소스 액세스 요청을 받으면 서버는 "401 Unauthorized" 응답으로 클라이언트에 요청하고 하나 이상의 WWW-Authenticate 헤더 필드를 포함할 수 있습니다. 서버가 여러 챌린지로 응답하는 경우 이러한 챌린지 각각은 서로 다른 다이제스트 알고리즘을 사용해야 합니다. 서버는 가장 선호하는 알고리즘부터 시작하여 선호도가 낮은 알고리즘 순으로 선호도 순서대로 응답에 이러한 챌린지를 추가해야 합니다.\(MUST, MUST\)

이 사양은 다음 알고리즘을 정의합니다.

```text
   o  SHA2-256 (mandatory to implement)

   o  SHA2-512/256 (as a backup algorithm)

   o  MD5 (for backward compatibility).
```

클라이언트가 첫 번째 챌린지를 수신하면 로컬 정책에서 달리 지정하지 않는 한 지원하는 첫 번째 챌린지를 사용해야 합니다.\(SHOULD\)

---
### **3.8.  Proxy-Authenticate and Proxy-Authorization**

다이제스트 인증 체계는 Proxy-Authenticate 및 Proxy-Authorization 헤더 필드를 사용하여 사용자를 프록시로, 프록시를 프록시로, 프록시를 원본 서버로 인증하는 데에도 사용할 수 있습니다. 이러한 헤더 필드는 HTTP/1.1 사양 \[RFC7235\]의 섹션 4.3 및 4.4에 지정된 Proxy-Authenticate 및 Proxy-Authorization 헤더 필드의 인스턴스이며 해당 동작은 여기에 설명된 제한 사항의 적용을 받습니다. 프록시 인증을 위한 트랜잭션은 이미 설명한 트랜잭션과 매우 유사합니다. 인증이 필요한 요청을 수신하면 프록시/서버는 "Proxy-Authenticate" 헤더 필드와 함께 "407 Proxy AuthenticationRequired" 응답을 발행해야 합니다. Proxy-Authenticate 헤더 필드에 사용되는 Digest-Challenge는 위의 섹션 3.3에서 정의된 WWW-Authenticate 헤더 필드의 것과 동일합니다.\(MUST\)

그런 다음 클라이언트/프록시는 위 섹션 3.4의 Authorization 헤더 필드에 대해 지정된 매개변수를 사용하여 Proxy-Authorization 헤더 필드로 요청을 재발행해야 합니다.\(MUST\)

후속 응답에서 서버는 Authentication-Info 헤더 필드와 동일한 매개변수와 함께 Proxy-Authentication-Info를 보냅니다.

원칙적으로 클라이언트는 프록시와 최종 서버 모두에 대해 자신을 인증하도록 요청받을 수 있지만 동일한 응답에서는 결코 인증되지 않습니다.

---
### **3.9.  Examples**
---
#### **3.9.1.  Example with SHA-256 and MD5**

다음 예에서는 액세스가 보호된 문서가 GET 요청을 통해 서버에서 요청되고 있다고 가정합니다. 문서의 URI는 "http://www.example.org/dir/index.html"입니다. 클라이언트와 서버 모두 이 문서의 사용자 이름이 "Mufasa"이고 비밀번호가 "Circle of Life"\(세 단어 사이에 공백이 하나씩 있음\)라는 것을 알고 있습니다.

클라이언트가 문서를 처음 요청할 때 Authorization 헤더 필드가 전송되지 않으므로 서버는 다음과 같이 응답합니다.

```text
   HTTP/1.1 401 Unauthorized
   WWW-Authenticate: Digest
       realm="http-auth@example.org",
       qop="auth, auth-int",
       algorithm=SHA-256,
       nonce="7ypf/xlj9XXwfDPEoM4URrv/xwf94BcCAzFZH4GiTo0v",
       opaque="FQhe/qaU925kfnzjCev0ciny7QMkPqMAFRtzCUYo5tdS"
   WWW-Authenticate: Digest
       realm="http-auth@example.org",
       qop="auth, auth-int",
       algorithm=MD5,
       nonce="7ypf/xlj9XXwfDPEoM4URrv/xwf94BcCAzFZH4GiTo0v",
       opaque="FQhe/qaU925kfnzjCev0ciny7QMkPqMAFRtzCUYo5tdS"
```

클라이언트는 사용자에게 사용자 이름과 비밀번호를 묻는 메시지를 표시한 후 클라이언트가 MD5 다이제스트를 선택한 경우 다음 Authorization 헤더 필드를 포함하여 새로운 요청으로 응답합니다.

```text
   Authorization: Digest username="Mufasa",
       realm="http-auth@example.org",
       uri="/dir/index.html",
       algorithm=MD5,
       nonce="7ypf/xlj9XXwfDPEoM4URrv/xwf94BcCAzFZH4GiTo0v",
       nc=00000001,
       cnonce="f2/wE4q74E6zIJEtWaHKaf5wv/H5QzzpXusqGemxURZJ",
       qop=auth,
       response="8ca523f5e9506fed4657c9700eebdbec",
       opaque="FQhe/qaU925kfnzjCev0ciny7QMkPqMAFRtzCUYo5tdS"
```

클라이언트가 응답 계산을 위해 SHA-256 알고리즘을 사용하기로 선택한 경우 클라이언트는 다음 Authorization 헤더 필드를 포함하는 새 요청으로 응답합니다.

```text
   Authorization: Digest username="Mufasa",
       realm="http-auth@example.org",
       uri="/dir/index.html",
       algorithm=SHA-256,
       nonce="7ypf/xlj9XXwfDPEoM4URrv/xwf94BcCAzFZH4GiTo0v",
       nc=00000001,
       cnonce="f2/wE4q74E6zIJEtWaHKaf5wv/H5QzzpXusqGemxURZJ",
       qop=auth,
       response="753927fa0e85d155564e2e272a28d1802ca10daf449
          6794697cf8db5856cb6c1",
       opaque="FQhe/qaU925kfnzjCev0ciny7QMkPqMAFRtzCUYo5tdS"
```

---
#### **3.9.2.  Example with SHA-512-256, Charset, and Userhash**

다음 예에서는 액세스가 보호된 문서가 GET 요청을 통해 서버에서 요청되고 있다고 가정합니다. 요청의 URI는 "http://api.example.org/doe.json"입니다. 클라이언트와 서버 모두 사용자 이름의 사용자 해시를 알고 있으며 UTF-8 문자 인코딩 체계를 지원하고 SHA-512-256 알고리즘을 사용합니다. 요청의 사용자 이름은 "Jason Doe"의 변형입니다. 여기서 'a'는 실제로 유니코드 코드 포인트 U+00E4\('LATIN SMALL LETTER A WITH DIAERESIS'\)이고 첫 번째 'o'는 유니코드 코드 포인트 U+입니다. 00F8\("LATIN SMALL LETTER O WITH STROKE"\), UTF-8 인코딩 체계를 사용하는 옥텟 시퀀스로 연결됩니다.

```text
      J  U+00E4 s  U+00F8 n      D  o  e
      4A C3A4   73 C3B8   6E 20 44  6F 65
```

비밀번호는 "비밀인가요, 아닌가요?"입니다.

클라이언트가 문서를 처음 요청할 때 Authorization 헤더 필드가 전송되지 않으므로 서버는 다음과 같이 응답합니다.

```text
   HTTP/1.1 401 Unauthorized
   WWW-Authenticate: Digest
       realm="api@example.org",
       qop="auth",
       algorithm=SHA-512-256,
       nonce="5TsQWLVdgBdmrQ0XsxbDODV+57QdFR34I9HAbC/RVvkK",
       opaque="HRPCssKJSGjCrkzDg8OhwpzCiGPChXYjwrI2QmXDnsOS",
       charset=UTF-8,
       userhash=true
```

클라이언트는 사용자에게 필수 자격 증명을 묻는 메시지를 표시하고 다음 Authorization 헤더 필드를 사용하여 새 요청을 보낼 수 있습니다.

```text
   Authorization: Digest
       username="488869477bf257147b804c45308cd62ac4e25eb717
          b12b298c79e62dcea254ec",
       realm="api@example.org",
       uri="/doe.json",
       algorithm=SHA-512-256,
       nonce="5TsQWLVdgBdmrQ0XsxbDODV+57QdFR34I9HAbC/RVvkK",
       nc=00000001,
       cnonce="NTg6RKcb9boFIAS3KrFK9BGeh+iDa/sm6jUMp2wds69v",
       qop=auth,
       response="ae66e67d6b427bd3f120414a82e4acff38e8ecd9101d
          6c861229025f607a79dd",
       opaque="HRPCssKJSGjCrkzDg8OhwpzCiGPChXYjwrI2QmXDnsOS",
       userhash=true
```

클라이언트가 어떤 이유로든 해시된 사용자 이름을 제공할 수 없는 경우 클라이언트는 다음 Authorization 헤더 필드를 사용하여 요청을 시도할 수 있습니다.

```text
   Authorization: Digest
       username*=UTF-8''J%C3%A4s%C3%B8n%20Doe,
       realm="api@example.org",
       uri="/doe.json",
       algorithm=SHA-512-256,
       nonce="5TsQWLVdgBdmrQ0XsxbDODV+57QdFR34I9HAbC/RVvkK",
       nc=00000001,
       cnonce="NTg6RKcb9boFIAS3KrFK9BGeh+iDa/sm6jUMp2wds69v",
       qop=auth,
       response="ae66e67d6b427bd3f120414a82e4acff38e8ecd9101d
          6c861229025f607a79dd",
       opaque="HRPCssKJSGjCrkzDg8OhwpzCiGPChXYjwrI2QmXDnsOS",
       userhash=false
```

---
## **4.  Internationalization Considerations**

챌린지에서 서버는 A1\(섹션 3.4.2 참조\) 및 사용자 이름 해싱\(섹션 3.4.4 참조\)을 생성할 때 사용자 에이전트가 사용할 것으로 예상되는 문자 인코딩을 표현하기 위해 "charset" 인증 매개변수\(대소문자 구분 안 함\)를 사용해야 합니다.\(SHOULD\)

허용되는 유일한 값은 "UTF-8"이며 대소문자를 구분하지 않고 일치합니다\(\[RFC2978\]의 섹션 2.3 참조\). 이는 서버가 사용자 이름과 비밀번호가 유니코드 정규화 형식 C\("NFC", \[RFC5198\]의 섹션 3 참조\)로 변환되고 UTF-8 문자 인코딩 체계\[RFC3629\]를 사용하여 옥텟으로 인코딩될 것으로 예상함을 나타냅니다.

사용자 이름의 경우 수신자는 콜론\(":"\) 문자를 제외하고 \[RFC7613\]의 섹션 3.3에 정의된 "UsernameCasePreserved" 프로필에 정의된 모든 문자를 지원해야 합니다.\(MUST\)

비밀번호의 경우 수신자는 \[RFC7613\]의 섹션 4.2에 정의된 "OpaqueString" 프로필에 정의된 모든 문자를 지원해야 합니다.\(MUST\)

사용자 에이전트가 서버가 지정한 인코딩을 지원하지 않으면 요청이 실패할 수 있습니다.

사용자 이름을 해시하여 전송할 수 없고 ASCII가 아닌 문자를 포함하는 경우 클라이언트는 대신 사용자 이름\* 매개변수를 포함할 수 있습니다\(\[RFC5987\]에 정의된 값 인코딩 사용\).

---
## **5.  Security Considerations**
---
### **5.1.  Limitations**

HTTP 다이제스트 인증은 사람이 기억할 수 있는 비밀번호와 함께 사용될 경우 사전 공격에 취약합니다. 이러한 공격은 더 이상 안전하지 않은 것으로 간주되는 알고리즘을 포함하여 널리 사용되는 알고리즘에 대한 암호화 공격보다 훨씬 쉽습니다. 즉, 알고리즘 민첩성은 이러한 사용을 더 이상 안전하게 만들지 않습니다.

결과적으로 다이제스트 인증은 합리적인 양의 엔트로피\(예: 128비트 이상\)를 갖는 비밀번호에만 사용해야 합니다. 이러한 비밀번호는 일반적으로 사람이 기억할 수 없지만 자동화된 웹 서비스에 사용될 수 있습니다.\(SHOULD\)

다이제스트 인증을 사용하는 경우 HTTPS \[RFC2818\]와 같은 보안 채널을 통해 이루어져야 합니다.\(SHOULD\)

---
### **5.2.  Storing Passwords**

다이제스트 인증에서는 인증 에이전트\(일반적으로 서버\)가 사용자 이름과 비밀번호에서 파생된 일부 데이터를 특정 영역과 연관된 "비밀번호 파일"에 저장해야 합니다. 일반적으로 여기에는 사용자 이름과 H\(A1\)로 구성된 쌍이 포함될 수 있습니다. 여기서 H\(A1\)은 위에 설명된 사용자 이름, 영역 및 비밀번호의 요약된 값입니다.

이것이 보안에 미치는 영향은 이 비밀번호 파일이 손상되면 공격자가 이 영역을 사용하여 서버에 있는 문서에 즉시 액세스할 수 있다는 것입니다. 표준 UNIX 비밀번호 파일과 달리 이 정보는 이 파일과 연관된 서버 영역의 문서에 액세스하기 위해 해독될 필요가 없습니다. 반면에 사용자의 비밀번호를 얻으려면 암호 해독이나 무차별 대입 공격이 필요할 수 있습니다. 이것이 바로 그 이유이다.

영역은 비밀번호 파일에 저장된 다이제스트 데이터의 일부입니다. 이는 하나의 다이제스트 인증 비밀번호 파일이 손상되더라도 동일한 사용자 이름과 비밀번호를 사용하는 다른 파일도 자동으로 손상시키지 않는다는 의미입니다\(무차별 대입 공격에 노출되기는 하지만\).

이로 인해 두 가지 중요한 보안 결과가 발생합니다. 첫째, 비밀번호 파일은 암호화되지 않은 비밀번호가 포함된 것처럼 보호되어야 합니다. 왜냐하면 해당 영역의 문서에 액세스할 목적으로 효과적으로 보호되기 때문입니다.

이에 대한 두 번째 결과는 영역 문자열이 단일 사용자가 사용할 가능성이 있는 모든 영역 중에서 고유해야 한다는 것입니다. 특히, 영역 문자열에는 인증을 수행하는 호스트의 이름이 포함되어야 합니다. 클라이언트가 서버를 인증할 수 없다는 점은 다이제스트 인증의 약점입니다.\(SHOULD, SHOULD\)

---
### **5.3.  Authentication of Clients Using Digest Authentication**

예를 들어 다이제스트 인증은 공개 키 기반 메커니즘과 비교할 때 강력한 인증 메커니즘을 제공하지 않습니다.

그러나 예를 들어 LDAP\(Lightweight Directory Access Protocol\) \[RFC4513\] 및 IMAP/POP\(\[RFC2195\] 참조\)과 함께 사용하도록 제안된 CRAM-MD5보다 훨씬 강력합니다. 이는 훨씬 더 약하고 훨씬 더 위험한 기본 메커니즘을 대체하기 위한 것이었습니다.

다이제스트 인증은 실제 사용자 이름과 비밀번호를 보호하는 것 이상의 기밀 보호 기능을 제공하지 않습니다. 나머지 요청과 응답은 모두 도청자가 사용할 수 있습니다.

다이제스트 인증은 어느 방향에서든 메시지에 대해 제한된 무결성 보호만 제공합니다. "qop=auth-int" 메커니즘이 사용되는 경우 WWW-Authenticate 및 Authorization 헤더 필드 응답 매개변수 값\(위의 섹션 3.2 참조\) 계산에 사용되는 메시지 부분이 보호됩니다. 대부분의 헤더 필드와 해당 값은 중간자 공격의 일부로 수정될 수 있습니다.

보안 HTTP 트랜잭션에 대한 많은 요구 사항은 다이제스트 인증으로 충족될 수 없습니다. 이러한 요구 사항에는 TLS가 더 적합한 프로토콜입니다. 특히 기밀 보호가 필요한 거래에는 다이제스트 인증을 사용할 수 없습니다. 그럼에도 불구하고 다이제스트 인증이 유용하고 적절한 기능은 많이 남아 있습니다.

---
### **5.4.  Limited-Use Nonce Values**

다이제스트 체계는 서버가 지정한 nonce를 사용하여 응답 값 생성을 시드합니다\(위의 섹션 3.4.1에 지정된 대로\). 섹션 3.3의 예시 nonce에 표시된 것처럼 서버는 특정 클라이언트, 특정 리소스, 제한된 기간 또는 사용 횟수 또는 기타 제한 사항에서만 사용할 수 있도록 nonce를 자유롭게 구성할 수 있습니다. . 이렇게 하면 재생 공격 등에 대한 보호 기능이 강화됩니다\(섹션 5.5 참조\). 그러나 Nonce를 생성하고 확인하기 위해 선택한 방법에는 성능 및 리소스 관련 영향도 있다는 점에 유의해야 합니다. 예를 들어, 서버는 최근 발행된 Nonce가 반환되었는지 여부에 대한 기록을 유지하고 모든 응답의 Authentication-Info 헤더 필드에 다음 Nonce 매개변수를 전송하여 각 Nonce 값이 한 번만 사용되도록 선택할 수 있습니다. 이는 즉각적인 재생 공격도 방지하지만 nonce 값을 확인해야 하기 때문에 비용이 많이 듭니다. 아마도 더 중요한 점은 파이프라인 요청에 대한 인증 실패가 발생할 수 있다는 점입니다\(아마도 오래된 nonce 표시 반환\). 마찬가지로, 리소스에 대한 ETag 값과 같은 요청별 요소를 통합하면 nonce 사용이 해당 리소스 버전으로 제한되고 파이프라인도 무효화됩니다. 따라서 부작용이 있는 방법에 대해 그렇게 하는 것이 유용할 수 있지만 그렇지 않은 방법에 대해서는 허용할 수 없는 성능을 갖습니다.\(MAY, MAY, MAY\)

---
### **5.5.  Replay Attacks**

다이제스트 인증에 대한 재생 공격은 일반적으로 간단한 GET 요청의 경우 의미가 없습니다. 도청자가 이미 재생을 통해 얻을 수 있는 유일한 문서를 봤기 때문입니다. 이는 요청된 문서의 URI가 클라이언트 요청에 다이제스트되어 서버가 해당 문서만 전달하기 때문입니다. 이와 대조적으로 기본 인증에서는 도청자가 사용자의 비밀번호를 알게 되면 해당 비밀번호로 보호되는 모든 문서가 그에게 공개됩니다.

따라서 어떤 목적에서는 재생 공격으로부터 보호하는 것이 필요합니다. 좋은 다이제스트 구현은 다양한 방법으로 이를 수행할 수 있습니다. 서버에서 생성된 "nonce" 값은 구현에 따라 다르지만 클라이언트 IP의 다이제스트, 타임스탬프, 리소스 ETag 및 개인 서버 키\(위에서 권장한 대로\)가 포함되어 있는 경우 재생 공격은 간단하지 않습니다. 공격자는 요청이 잘못된 IP 주소에서 온 것임을 서버에 확신시켜야 하며, 서버가 문서를 보내는 것으로 생각되는 주소와 다른 IP 주소로 문서를 전달하도록 해야 합니다. 공격은 타임스탬프가 만료되기 전의 기간에만 성공할 수 있습니다. Nonce에서 클라이언트 IP와 타임스탬프를 다이제스트하면 트랜잭션 간 상태를 유지하지 않는 구현이 허용됩니다.

재생 공격의 가능성이 허용되지 않는 애플리케이션의 경우 서버는 두 번째 사용에는 적용되지 않는 일회성 nonce 값을 사용할 수 있습니다. 이를 위해서는 Nonce 타임스탬프\(및 그에 따라 작성된 다이제스트\)가 만료될 때까지 어떤 Nonce 값이 사용되었는지 기억하는 서버의 오버헤드가 필요하지만 재생 공격으로부터 효과적으로 보호합니다.

구현에서는 POST 및 PUT 요청을 통한 재생 공격 가능성에 특별한 주의를 기울여야 합니다. 서버가 일회성 또는 제한된 사용 nonce를 사용하거나 "qop=auth-int"의 무결성 보호 사용을 주장하지 않는 한 공격자는 위조 데이터 또는 기타 메시지 본문을 사용하여 성공적인 요청에서 유효한 자격 증명을 재생할 수 있습니다. . 무결성 보호를 사용하더라도 헤더 필드의 대부분의 메타데이터는 보호되지 않습니다. 적절한 nonce 생성 및 검사는 이전에 사용된 유효한 자격 증명의 재생에 대해 어느 정도 보호 기능을 제공하지만 섹션 5.8을 참조하세요.

---
### **5.6.  Weakness Created by Multiple Authentication Schemes**

HTTP/1.1 서버는 401\(인증\) 응답으로 여러 개의 질문을 반환할 수 있으며 각 질문은 서로 다른 인증 체계를 사용할 수 있습니다. 사용자 에이전트는 자신이 이해하는 가장 강력한 인증 체계를 사용하도록 선택하고 해당 챌린지를 기반으로 사용자에게 자격 증명을 요청해야 합니다.\(MAY, MUST\)

서버가 WWW-Authenticate 헤더 필드를 사용하여 인증 체계 선택을 제공하는 경우 결과 인증의 강도는 가장 약한 인증 체계의 강도만큼만 좋습니다. 여러 인증 체계를 악용하는 특정 공격 시나리오에 대한 논의는 아래 섹션 5.7을 참조하세요.

---
### **5.7.  Online Dictionary Attacks**

공격자가 도청할 수 있으면 일반적인 단어 목록에 대해 우연히 들은 nonce/응답 쌍을 테스트할 수 있습니다. 이러한 목록은 일반적으로 가능한 비밀번호의 총 개수보다 훨씬 적습니다. 목록에 있는 각 비밀번호에 대한 응답을 계산하는 비용은 각 질문에 대해 한 번만 지불됩니다.

서버는 사용자가 사전에 있는 비밀번호를 선택하는 것을 허용하지 않음으로써 이 공격을 완화할 수 있습니다.

---
### **5.8.  Man-in-the-Middle Attacks**

다이제스트 인증은 적대적이거나 손상된 프록시 등의 중간자\(MITM\) 공격에 취약합니다. 분명히 이것은 도청의 모든 문제를 제시할 것입니다. 그러나 이는 공격자에게 추가적인 기회도 제공합니다.

가능한 중간자 공격은 클라이언트가 사용자의 자격 증명\(예: 비밀번호\)을 노출하는 인증 체계를 사용하기를 바라면서 선택 항목 집합에 약한 인증 체계를 추가하는 것입니다. 이러한 이유로 클라이언트는 항상 제공된 선택 사항에서 이해하는 가장 강력한 구성표를 사용해야 합니다.\(SHOULD\)

더 나은 MITM 공격은 제공된 모든 선택 사항을 제거하고 이를 기본 인증만 요청하는 문제로 대체한 다음 기본 인증의 일반 텍스트 자격 증명을 사용하여 요청한 더 강력한 체계를 사용하여 원본 서버에 인증하는 것입니다. 이러한 MITM 공격을 실행하는 특히 교활한 방법은 속기 쉬운 사용자에게 "무료" 프록시 캐싱 서비스를 제공하는 것입니다.

사용자 에이전트는 자격 증명 요청 시 사용할 인증 체계에 대한 시각적 표시를 제시하거나 서버에서 요청한 가장 강력한 인증 체계를 기억하고 더 약한 인증 체계를 사용하기 전에 경고 메시지를 생성하는 등의 조치를 고려해야 합니다. 일반적으로 또는 특정 사이트에서 다이제스트 인증을 요구하도록 사용자 에이전트를 구성하는 것도 좋은 생각일 수 있습니다.

또는 적대적인 프록시가 클라이언트를 스푸핑하여 클라이언트가 원하는 요청이 아닌 공격자가 원하는 요청을 할 수도 있습니다. 물론 이것은 기본 인증에 대한 유사한 공격보다 여전히 훨씬 어렵습니다.

---
### **5.9.  Chosen Plaintext Attacks**

다이제스트 인증을 사용하면 MITM 또는 악의적인 서버가 클라이언트가 응답을 계산하는 데 사용할 nonce를 임의로 선택할 수 있습니다. 이를 "선택된 일반 텍스트" 공격이라고 합니다. nonce를 선택하는 기능은 암호 분석을 훨씬 쉽게 만드는 것으로 알려져 있습니다.

그러나 선택된 평문을 이용하여 Digest가 사용하는 단방향 함수를 분석하는 방법은 현재 알려져 있지 않다.

이 공격에 대한 대응책은 클라이언트가 connonce 매개변수를 사용하는 것입니다. 이를 통해 클라이언트는 공격자가 선택하지 않은 방식으로 해시에 대한 입력을 변경할 수 있습니다.

---
### **5.10.  Precomputed Dictionary Attacks**

다이제스트 인증을 사용하면 공격자가 선택한 일반 텍스트 공격을 실행할 수 있는 경우 공격자는 여러 일반적인 단어에 대한 응답을 선택한 임시 값으로 미리 계산하고 응답/암호 쌍의 사전을 저장할 수 있습니다. 이러한 사전 계산은 많은 시스템에서 병렬로 수행되는 경우가 많습니다. 그런 다음 선택한 일반 텍스트 공격을 사용하여 해당 챌린지에 해당하는 응답을 얻고 사전에서 비밀번호를 조회할 수 있습니다. 대부분의 비밀번호가 사전에 없더라도 일부 비밀번호는 그럴 수도 있습니다. 공격자가 챌린지를 선택하게 되므로 목록에 있는 각 비밀번호에 대한 응답을 계산하는 비용은 많은 비밀번호를 찾는 것보다 상각될 수 있습니다. 1억 개의 비밀번호/응답 쌍이 있는 사전은 약 3.2GB의 디스크 저장 공간을 차지합니다.

이 공격에 대한 대응책은 클라이언트가 connonce 매개변수를 사용하는 것입니다.

---
### **5.11.  Batch Brute-Force Attacks**

다이제스트 인증을 사용하면 MITM은 선택한 일반 텍스트 공격을 실행할 수 있으며 동일한 nonce에 대한 많은 사용자의 응답을 수집할 수 있습니다. 그런 다음 해당 공간에 대한 단일 패스에서 nonce/응답 쌍 중 하나를 생성하는 비밀번호 공간의 하위 집합 내에서 모든 비밀번호를 찾을 수 있습니다. 또한 수집된 nonce/response 쌍의 수와 동일한 요소로 첫 번째 비밀번호를 찾는 시간을 줄입니다. 비밀번호 공간에 대한 이러한 검색은 종종 많은 시스템에서 병렬로 수행될 수 있으며 단일 시스템에서도 비밀번호 공간의 대규모 하위 집합을 매우 빠르게 검색할 수 있습니다. 몇 시간 안에 6자 이하의 문자로 모든 비밀번호를 검색한다는 보고가 있습니다.

이 공격에 대한 대응책은 클라이언트가 connonce 매개변수를 사용하는 것입니다.

---
### **5.12.  Parameter Randomness**

이 프로토콜의 보안은 클라이언트 및 서버 nonce와 같이 무작위로 선택된 매개변수의 무작위성에 크게 좌우됩니다. 이는 강력한 무작위 또는 적절하게 시드된 의사 난수 소스에 의해 생성되어야 합니다\(\[RFC4086\] 참조\).

---
### **5.13.  Summary**

최신 암호화 표준에 따르면 다이제스트 인증은 약합니다. 그러나 다양한 목적의 경우 기본 인증을 대체하는 데 유용합니다. 이는 기본 인증의 약점을 전부는 아니지만 일부 해결합니다. 그 강도는 구현에 따라 달라질 수 있습니다. 특히 nonce의 구조\(

서버 구현에 따라 다름\)은 재생 공격 탑재의 용이성에 영향을 미칠 수 있습니다. 예를 들어, 일부 구현에서는 재생 가능성을 제거하기 위해 일회성 논스 또는 다이제스트의 서버 오버헤드를 기꺼이 수용할 수 있으므로 다양한 서버 옵션이 적합합니다. 다른 사람들은 위에서 권장하는 것과 같은 nonce, 즉 단일 IP 주소와 단일 ETag로 제한되거나 제한된 수명으로 만족할 수 있습니다.

결론은 \*모든\* 호환 구현은 암호화 표준에 비해 상대적으로 약하지만 \*모든\* 호환 구현은 기본 인증보다 훨씬 우수하다는 것입니다.

---
## **6.  IANA Considerations**
---
### **6.1.  Hash Algorithms for HTTP Digest Authentication**

이 사양은 기존 "HTTP\(Hypertext Transfer Protocol\) 다이제스트 알고리즘 값" 범주 아래에 "HTTP 다이제스트 인증을 위한 해시 알고리즘"이라는 새 IANA 레지스트리를 생성합니다. 이 레지스트리에는 HTTP 다이제스트 인증에 사용할 수 있는 해시 알고리즘이 나열되어 있습니다.

새로운 해시 알고리즘을 등록할 때 다음 정보를 제공해야 합니다.\(MUST\)

```text
   Hash Algorithm
```

- 해시 알고리즘의 텍스트 이름입니다.

```text
   Digest Size
```

- 알고리즘 출력의 크기\(비트\)입니다.

```text
   Reference
```

- 이 레지스트리에 알고리즘을 추가하는 사양에 대한 참조입니다.

이 레지스트리에 대한 업데이트 정책은 사양 필수 \[RFC5226\]입니다.

초기 레지스트리에는 다음 항목이 포함되어 있습니다.

```text
               +----------------+-------------+-----------+
               | Hash Algorithm | Digest Size | Reference |
               +----------------+-------------+-----------+
               | "MD5"          | 128         | RFC 7616  |
               | "SHA-512-256"  | 256         | RFC 7616  |
               | "SHA-256"      | 256         | RFC 7616  |
               +----------------+-------------+-----------+
```

레지스트리에 정의된 각 알고리즘에는 "-sess" 변형\(예: MD5-sess, SHA-256-sess 등\)이 있을 수 있습니다.

기존 "HTTP 다이제스트 알고리즘 값" 레지스트리의 목적을 명확히 하고 두 레지스트리 간의 혼동을 피하기 위해 IANA는 기존 "HTTP 다이제스트 알고리즘 값" 레지스트리에 다음 설명을 추가했습니다.

- 이 레지스트리에는 RFC 3230에 지정된 대로 HTTP 메시지 본문의 다이제스트를 생성할 때 사용할 수 있는 알고리즘이 나열되어 있습니다.

---
### **6.2.  Digest Scheme Registration**

이 사양은 "HTTP\(Hypertext Transfer Protocol\) 인증 체계 레지스트리"에 있는 다이제스트 체계의 기존 항목을 업데이트하고 이 사양에 대한 새 참조를 추가합니다.

```text
      Authentication Scheme Name: Digest
```

- 사양 텍스트에 대한 포인터: RFC 7616

---
## **7.  References**
---
### **7.1.  Normative References**

```text
   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", BCP 14, RFC 2119,
              DOI 10.17487/RFC2119, March 1997,
              <http://www.rfc-editor.org/info/rfc2119>.

   [RFC2978]  Freed, N. and J. Postel, "IANA Charset Registration
              Procedures", BCP 19, RFC 2978, DOI 10.17487/RFC2978,
              October 2000, <http://www.rfc-editor.org/info/rfc2978>.

   [RFC3629]  Yergeau, F., "UTF-8, a transformation format of ISO
              10646", STD 63, RFC 3629, DOI 10.17487/RFC3629, November
              2003, <http://www.rfc-editor.org/info/rfc3629>.

   [RFC3986]  Berners-Lee, T., Fielding, R., and L. Masinter, "Uniform
              Resource Identifier (URI): Generic Syntax", STD 66,
              RFC 3986, DOI 10.17487/RFC3986, January 2005,
              <http://www.rfc-editor.org/info/rfc3986>.

   [RFC4086]  Eastlake 3rd, D., Schiller, J., and S. Crocker,
              "Randomness Requirements for Security", BCP 106, RFC 4086,
              DOI 10.17487/RFC4086, June 2005,
              <http://www.rfc-editor.org/info/rfc4086>.

   [RFC5198]  Klensin, J. and M. Padlipsky, "Unicode Format for Network
              Interchange", RFC 5198, DOI 10.17487/RFC5198, March 2008,
              <http://www.rfc-editor.org/info/rfc5198>.

   [RFC5234]  Crocker, D., Ed. and P. Overell, "Augmented BNF for Syntax
              Specifications: ABNF", STD 68, RFC 5234,
              DOI 10.17487/RFC5234, January 2008,
              <http://www.rfc-editor.org/info/rfc5234>.

   [RFC5987]  Reschke, J., "Character Set and Language Encoding for
              Hypertext Transfer Protocol (HTTP) Header Field
              Parameters", RFC 5987, DOI 10.17487/RFC5987, August 2010,
              <http://www.rfc-editor.org/info/rfc5987>.

   [RFC6454]  Barth, A., "The Web Origin Concept", RFC 6454,
              DOI 10.17487/RFC6454, December 2011,
              <http://www.rfc-editor.org/info/rfc6454>.

   [RFC7230]  Fielding, R., Ed. and J. Reschke, Ed., "Hypertext Transfer
              Protocol (HTTP/1.1): Message Syntax and Routing",
              RFC 7230, DOI 10.17487/RFC7230, June 2014,
              <http://www.rfc-editor.org/info/rfc7230>.

   [RFC7231]  Fielding, R., Ed. and J. Reschke, Ed., "Hypertext Transfer
              Protocol (HTTP/1.1): Semantics and Content", RFC 7231,
              DOI 10.17487/RFC7231, June 2014,
              <http://www.rfc-editor.org/info/rfc7231>.

   [RFC7234]  Fielding, R., Ed., Nottingham, M., Ed., and J. Reschke,
              Ed., "Hypertext Transfer Protocol (HTTP/1.1): Caching",
              RFC 7234, DOI 10.17487/RFC7234, June 2014,
              <http://www.rfc-editor.org/info/rfc7234>.

   [RFC7235]  Fielding, R., Ed. and J. Reschke, Ed., "Hypertext Transfer
              Protocol (HTTP/1.1): Authentication", RFC 7235,
              DOI 10.17487/RFC7235, June 2014,
              <http://www.rfc-editor.org/info/rfc7235>.

   [RFC7613]  Saint-Andre, P. and A. Melnikov, "Preparation,
              Enforcement, and Comparison of Internationalized Strings
              Representing Usernames and Passwords", RFC 7613,
              DOI 10.17487/RFC7613, August 2015,
              <http://www.rfc-editor.org/info/rfc7613>.

   [RFC7615]  Reschke, J., "HTTP Authentication-Info and Proxy-
              Authentication-Info Response Header Fields", RFC 7615,
              DOI 10.17487/RFC7615, September 2015,
              <http://www.rfc-editor.org/info/rfc7615>.
```

---
### **7.2.  Informative References**

```text
   [RFC2195]  Klensin, J., Catoe, R., and P. Krumviede, "IMAP/POP
              AUTHorize Extension for Simple Challenge/Response",
              RFC 2195, DOI 10.17487/RFC2195, September 1997,
              <http://www.rfc-editor.org/info/rfc2195>.

   [RFC2617]  Franks, J., Hallam-Baker, P., Hostetler, J., Lawrence, S.,
              Leach, P., Luotonen, A., and L. Stewart, "HTTP
              Authentication: Basic and Digest Access Authentication",
              RFC 2617, DOI 10.17487/RFC2617, June 1999,
              <http://www.rfc-editor.org/info/rfc2617>.

   [RFC2818]  Rescorla, E., "HTTP Over TLS", RFC 2818,
              DOI 10.17487/RFC2818, May 2000,
              <http://www.rfc-editor.org/info/rfc2818>.

   [RFC4513]  Harrison, R., Ed., "Lightweight Directory Access Protocol
              (LDAP): Authentication Methods and Security Mechanisms",
              RFC 4513, DOI 10.17487/RFC4513, June 2006,
              <http://www.rfc-editor.org/info/rfc4513>.

   [RFC5226]  Narten, T. and H. Alvestrand, "Guidelines for Writing an
              IANA Considerations Section in RFCs", BCP 26, RFC 5226,
              DOI 10.17487/RFC5226, May 2008,
              <http://www.rfc-editor.org/info/rfc5226>.

   [RFC7617]  Reschke, J., "The 'Basic' HTTP Authentication Scheme",
              RFC 7617, DOI 10.17487/RFC7617, September 2015,
              <http://www.rfc-editor.org/info/rfc7617>.
```

---
# **Appendix A.  Changes from RFC 2617**

이 문서에서는 다음과 같은 변경 사항을 소개합니다.

o 두 가지 새로운 알고리즘인 SHA2-256을 필수로, SHA2-512/256을 백업으로 추가하고 적절한 알고리즘 협상을 정의합니다. 이 문서는 MD5 알고리즘 지원을 유지하지만 이전 버전과의 호환성을 위해서만 지원됩니다.

o 주로 개인정보 보호를 위해 사용자 이름 해싱 기능 및 이와 관련된 매개변수를 소개합니다.

o A1 계산과 사용자 이름 및 비밀번호 인코딩에 영향을 미치는 다양한 국제화 고려 사항을 추가합니다.

o HTTP 다이제스트 인증에 사용할 수 있는 해시 알고리즘을 나열하는 새로운 IANA 레지스트리인 "HTTP 다이제스트 인증을 위한 해시 알고리즘"을 도입합니다.

o RFC 2069와의 하위 호환성을 더 이상 사용하지 않습니다.

---
# **Acknowledgments**

다이제스트 메커니즘과 그 작동에 대한 완전한 설명을 제공하기 위해 이 문서는 \[RFC2617\]에서 텍스트를 많이 차용했습니다. 이 문서의 저자는 해당 사양에 대한 작업에 대해 John Franks, Phillip M. Hallam-Baker, Jeffery L. Hostetler, Scott D. Lawrence, Paul J. Leach, Ari Luotonen 및 Lawrence C. Stewart에게 감사를 표하고 싶습니다.

이 문서의 다양한 영역에 대한 많은 리뷰, 의견, 제안 및 텍스트를 제공해 주신 Julian Reschke에게 특별히 감사드립니다.

저자들은 Stephen Farrell, Yoav Nir, Phillip Hallam-Baker, Manu Sporny, Paul Hoffman, Yaron Sheffer, Sean Turner, Geoff Baskwill, Eric Cooper, Bjoern Hoehrmann, Martin Durst, Peter Saint-Andre, Michael Sweet, Daniel에게 감사의 말씀을 전합니다. Stenberg, Brett Tate, Paul Leach, Ilari Liusvaara, Gary Mort, Alexey Melnikov, Benjamin Kaduk, Kathleen Moriarty, Francis Dupont, Hilarie Orman 및 Ben Campbell의 세심한 검토와 의견에 감사드립니다.

저자들은 이 문서의 다양한 측면을 논의할 때 메일링 리스트에 의견을 주신 Jonathan Stoke, Nico Williams, Harry Halpin 및 Phil Hunt에게 감사의 말씀을 전하고 싶습니다.

저자는 이 문서의 일부 측면에 대해 세심한 검토와 피드백을 주신 Paul Kyzivat와 Dale Worley에게 감사의 말씀을 전하고 싶습니다.

저자는 등록에 도움을 준 Barry Leiba에게 감사를 표하고 싶습니다.

---
# **Authors' Addresses**

```text
   Rifaat Shekh-Yusef (editor)
   Avaya
   250 Sidney Street
   Belleville, Ontario
   Canada

   Phone: +1-613-967-5267
   Email: rifaat.ietf@gmail.com

   David Ahrens
   Independent
   California
   United States

   Email: ahrensdc@gmail.com

   Sophie Bremer
   Netzkonform
   Germany

   Email: sophie.bremer@netzkonform.de
```
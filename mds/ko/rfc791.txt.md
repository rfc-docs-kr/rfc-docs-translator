

```text
RFC:  791
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                           INTERNET PROTOCOL
                                    
                                    
                         DARPA INTERNET PROGRAM
                                    
                         PROTOCOL SPECIFICATION
                                    
                                    
                                    
                             September 1981

                              prepared for

               Defense Advanced Research Projects Agency
                Information Processing Techniques Office
                         1400 Wilson Boulevard
                       Arlington, Virginia  22209

                                   by

                     Information Sciences Institute
                   University of Southern California
                           4676 Admiralty Way
                   Marina del Rey, California  90291

September 1981                                                          
                                                       Internet Protocol
```

- 목차

```text
    PREFACE ........................................................ iii
```

```text
1.  INTRODUCTION ..................................................... 1
  1.1  Motivation .................................................... 1
  1.2  Scope ......................................................... 1
  1.3  Interfaces .................................................... 1
  1.4  Operation ..................................................... 2
2.  OVERVIEW ......................................................... 5
  2.1  Relation to Other Protocols ................................... 9
  2.2  Model of Operation ............................................ 5
  2.3  Function Description .......................................... 7
  2.4  Gateways ...................................................... 9
3.  SPECIFICATION ................................................... 11
  3.1  Internet Header Format ....................................... 11
  3.2  Discussion ................................................... 23
  3.3  Interfaces ................................................... 31
APPENDIX A:  Examples & Scenarios ................................... 34
APPENDIX B:  Data Transmission Order ................................ 39
GLOSSARY ............................................................ 41
REFERENCES .......................................................... 45
```

```text
                                                                [Page i]

                                                          September 1981
Internet Protocol

[Page ii]                                                               

September 1981                                                          
                                                       Internet Protocol

                                PREFACE
```

이 문서는 DoD 표준 인터넷 프로토콜을 지정합니다. 이것
문서는 ARPA 인터넷 프로토콜의 6개 이전 버전을 기반으로 합니다.
명세, 그리고 현재의 텍스트는 그들로부터 많이 끌어옵니다. 있다
개념과 측면 모두에서 이 작업에 많은 기여를 했습니다.
텍스트 용어. 이 버전은 주소 지정, 오류의 측면을 수정합니다.
처리, 옵션 코드 및 보안, 우선 순위, 구획 및
인터넷 프로토콜의 제한 기능을 처리합니다.

```text
                                                           Jon Postel

                                                           Editor

                                                              [Page iii]

                                                          September 1981

RFC:  791
Replaces:  RFC 760
IENs 128, 123, 111,
80, 54, 44, 41, 28, 26

                           INTERNET PROTOCOL

                         DARPA INTERNET PROGRAM
                         PROTOCOL SPECIFICATION

                            1.  INTRODUCTION
```

---
### **1.1.  Motivation**

인터넷 프로토콜은 패킷 교환 컴퓨터 통신 네트워크의 상호 연결된 시스템에서 사용하도록 설계되었습니다. 이러한 시스템을 "catenet"\[1\]이라고 합니다. 인터넷 프로토콜은 데이터그램이라고 하는 데이터 블록을 소스에서 목적지로 전송하는 기능을 제공합니다. 여기서 소스와 목적지는 고정 길이 주소로 식별되는 호스트입니다. 인터넷 프로토콜은 또한 필요한 경우 "작은 패킷" 네트워크를 통해 전송하기 위해 긴 데이터그램의 단편화 및 재조립을 제공합니다.

---
### **1.2.  Scope**

인터넷 프로토콜은 상호 연결된 네트워크 시스템을 통해 소스에서 대상으로 비트 패키지\(인터넷 데이터그램\)를 전달하는 데 필요한 기능을 제공하기 위해 범위가 특히 제한됩니다. 종단 간 데이터 신뢰성, 흐름 제어, 시퀀싱 또는 호스트 간 프로토콜에서 일반적으로 발견되는 기타 서비스를 강화하는 메커니즘이 없습니다. 인터넷 프로토콜은 지원 네트워크의 서비스를 활용하여 다양한 유형과 품질의 서비스를 제공할 수 있습니다.

---
### **1.3.  Interfaces**

이 프로토콜은 인터넷 환경에서 호스트 간 프로토콜에 의해 호출됩니다. 이 프로토콜은 로컬 네트워크 프로토콜을 호출하여 인터넷 데이터그램을 다음 게이트웨이 또는 대상 호스트로 전달합니다.

예를 들어, TCP 모듈은 인터넷 모듈에서 TCP 세그먼트\(TCP 헤더 및 사용자 데이터 포함\)를 인터넷 데이터그램의 데이터 부분으로 사용하도록 호출합니다. TCP 모듈은 인터넷 헤더의 주소 및 기타 매개변수를 호출의 인수로 인터넷 모듈에 제공합니다. 그런 다음 인터넷 모듈은 인터넷 데이터그램을 만들고 로컬 네트워크 인터페이스를 호출하여 인터넷 데이터그램을 전송합니다.

```text
  In the ARPANET case, for example, the internet module would call on a
```

IMP로 전송할 ARPANET 메시지를 생성하는 인터넷 데이터그램에 1822 리더\[2\]를 추가하는 로컬 네트워크 모듈. ARPANET 주소는 로컬 네트워크 인터페이스에 의해 인터넷 주소에서 파생되며 ARPANET의 일부 호스트 주소가 되며 해당 호스트는 다른 네트워크에 대한 게이트웨이가 될 수 있습니다.

---
### **1.4.  Operation**

인터넷 프로토콜은 주소 지정과 조각화라는 두 가지 기본 기능을 구현합니다.

인터넷 모듈은 인터넷 헤더에 있는 주소를 사용하여 인터넷 데이터그램을 목적지로 전송합니다. 전송 경로를 선택하는 것을 라우팅이라고 합니다.

인터넷 모듈은 인터넷 헤더의 필드를 사용하여 "작은 패킷" 네트워크를 통한 전송에 필요할 때 인터넷 데이터그램을 조각화하고 재조립합니다.

작동 모델은 인터넷 모듈이 인터넷 통신에 관여하는 각 호스트와 네트워크를 상호 연결하는 각 게이트웨이에 상주한다는 것입니다. 이러한 모듈은 주소 필드를 해석하고 인터넷 데이터그램을 단편화하고 조합하기 위한 공통 규칙을 공유합니다. 또한 이러한 모듈\(특히 게이트웨이\)에는 라우팅 결정 및 기타 기능을 수행하기 위한 절차가 있습니다.

인터넷 프로토콜은 각 인터넷 데이터그램을 다른 인터넷 데이터그램과 관련 없는 독립된 엔터티로 취급합니다. 연결이나 논리 회로\(가상 또는 기타\)가 없습니다.

인터넷 프로토콜은 서비스를 제공할 때 서비스 유형, TTL\(Time to Live\), 옵션 및 헤더 체크섬의 네 가지 주요 메커니즘을 사용합니다.

서비스 유형은 원하는 서비스의 품질을 나타내는 데 사용됩니다. 서비스 유형은 인터넷을 구성하는 네트워크에서 제공되는 서비스 선택을 특징짓는 추상 또는 일반화된 매개변수 집합입니다. 이 유형의 서비스 표시는 인터넷 데이터그램을 라우팅할 때 특정 네트워크, 다음 홉에 사용할 네트워크 또는 다음 게이트웨이에 대한 실제 전송 매개변수를 선택하기 위해 게이트웨이에서 사용됩니다.

TTL\(Time to Live\)은 인터넷 데이터그램 수명의 상한선을 나타냅니다. 데이터그램의 송신자에 의해 설정되고 처리되는 경로를 따라 지점에서 감소합니다. 인터넷 데이터그램이 목적지에 도달하기 전에 수명이 0에 도달하면 인터넷 데이터그램이 파괴됩니다. 생존 시간은 자폭 시간 제한으로 생각할 수 있습니다.

옵션은 일부 상황에서 필요하거나 유용하지만 가장 일반적인 통신에는 필요하지 않은 제어 기능을 제공합니다. 옵션에는 타임스탬프, 보안 및 특수 라우팅에 대한 조항이 포함됩니다.

헤더 체크섬은 인터넷 데이터그램 처리에 사용된 정보가 올바르게 전송되었는지 확인합니다. 데이터에 오류가 있을 수 있습니다. 헤더 체크섬이 실패하면 오류를 감지한 엔터티가 인터넷 데이터그램을 한 번에 폐기합니다.

인터넷 프로토콜은 신뢰할 수 있는 통신 기능을 제공하지 않습니다. 종단 간 또는 홉 간 승인이 없습니다. 데이터에 대한 오류 제어는 없으며 헤더 체크섬만 있습니다. 재전송이 없습니다. 흐름 제어가 없습니다.

감지된 오류는 인터넷 프로토콜 모듈에 구현된 ICMP\(Internet Control Message Protocol\)\[3\]를 통해 보고될 수 있습니다.

```text
  

                              2.  OVERVIEW
```

---
### **2.1.  Relation to Other Protocols**

다음 다이어그램은 프로토콜 계층에서 인터넷 프로토콜의 위치를 ​​보여줍니다.

```text
                                    
                 +------+ +-----+ +-----+     +-----+  
                 |Telnet| | FTP | | TFTP| ... | ... |  
                 +------+ +-----+ +-----+     +-----+  
                       |   |         |           |     
                      +-----+     +-----+     +-----+  
                      | TCP |     | UDP | ... | ... |  
                      +-----+     +-----+     +-----+  
                         |           |           |     
                      +--------------------------+----+
                      |    Internet Protocol & ICMP   |
                      +--------------------------+----+
                                     |                 
                        +---------------------------+  
                        |   Local Network Protocol  |  
                        +---------------------------+  

                         Protocol Relationships

                               Figure 1.
```

한 쪽은 더 높은 수준의 호스트 간 프로토콜로, 다른 쪽은 로컬 네트워크 프로토콜로 인터넷 프로토콜 인터페이스. 이 맥락에서 "로컬 네트워크"는 건물의 소규모 네트워크이거나 ARPANET과 같은 대규모 네트워크일 수 있습니다.

---
### **2.2.  Model of Operation**

한 응용 프로그램에서 다른 응용 프로그램으로 데이터그램을 전송하는 작업 모델은 다음 시나리오로 설명됩니다.

이 전송에는 하나의 중간 게이트웨이가 포함된다고 가정합니다.

보내는 응용 프로그램은 데이터를 준비하고 로컬 인터넷 모듈을 호출하여 해당 데이터를 데이터그램으로 보내고 대상 주소 및 기타 매개 변수를 호출 인수로 전달합니다.

인터넷 모듈은 데이터그램 헤더를 준비하고 여기에 데이터를 첨부합니다. 인터넷 모듈은 이 인터넷 주소에 대한 로컬 네트워크 주소를 결정합니다. 이 경우 게이트웨이 주소입니다.

이 데이터그램과 로컬 네트워크 주소를 로컬 네트워크 인터페이스로 보냅니다.

로컬 네트워크 인터페이스는 로컬 네트워크 헤더를 생성하고 여기에 데이터그램을 첨부한 다음 로컬 네트워크를 통해 결과를 보냅니다.

데이터그램은 로컬 네트워크 헤더에 싸여 있는 게이트웨이 호스트에 도착하고, 로컬 네트워크 인터페이스는 이 헤더를 제거하고 데이터그램을 인터넷 모듈로 넘깁니다. 인터넷 모듈은 데이터그램이 두 번째 네트워크의 다른 호스트로 전달될 인터넷 주소로부터 결정합니다. 인터넷 모듈은 대상 호스트의 로컬 네트 주소를 결정합니다. 데이터그램을 전송하기 위해 해당 네트워크에 대한 로컬 네트워크 인터페이스를 호출합니다.

이 로컬 네트워크 인터페이스는 로컬 네트워크 헤더를 만들고 결과를 대상 호스트로 보내는 데이터그램을 첨부합니다.

이 대상 호스트에서 데이터그램은 로컬 네트워크 인터페이스에 의해 로컬 네트 헤더가 제거되고 인터넷 모듈로 전달됩니다.

인터넷 모듈은 데이터그램이 이 호스트의 응용 프로그램에 대한 것임을 결정합니다. 시스템 호출에 대한 응답으로 응용 프로그램에 데이터를 전달하고 소스 주소 및 기타 매개변수를 호출 결과로 전달합니다.

```text
                                    
   Application                                           Application
   Program                                                   Program
         \                                                   /      
       Internet Module      Internet Module      Internet Module    
             \                 /       \                /           
             LNI-1          LNI-1      LNI-2         LNI-2          
                \           /             \          /              
               Local Network 1           Local Network 2            

                            Transmission Path

                                Figure 2
```

---
### **2.3.  Function Description**

인터넷 프로토콜의 기능 또는 목적은 상호 연결된 네트워크 집합을 통해 데이터그램을 이동하는 것입니다. 이것은 목적지에 도달할 때까지 하나의 인터넷 모듈에서 다른 모듈로 데이터그램을 전달함으로써 이루어집니다. 인터넷 모듈은 인터넷 시스템의 호스트와 게이트웨이에 상주합니다. 데이터그램은 인터넷 주소 해석에 따라 개별 네트워크를 통해 한 인터넷 모듈에서 다른 인터넷 모듈로 라우팅됩니다. 따라서 인터넷 프로토콜의 중요한 메커니즘 중 하나는 인터넷 주소입니다.

한 인터넷 모듈에서 다른 인터넷 모듈로 메시지를 라우팅할 때 데이터그램은 최대 패킷 크기가 데이터그램 크기보다 작은 네트워크를 통과해야 할 수 있습니다. 이러한 어려움을 극복하기 위해 인터넷 프로토콜에 조각화 메커니즘이 제공됩니다.

```text
  Addressing
```

이름, 주소 및 경로가 구분됩니다\[4\]. 이름은 우리가 찾는 것을 나타냅니다. 주소는 그것이 있는 곳을 나타냅니다. 경로는 거기에 도착하는 방법을 나타냅니다. 인터넷 프로토콜은 주로 주소를 다룹니다. 이름에서 주소로 매핑하는 것은 상위 수준\(즉, 호스트-호스트 또는 응용 프로그램\) 프로토콜의 작업입니다. 인터넷 모듈은 인터넷 주소를 로컬 네트워크 주소에 매핑합니다. 로컬 네트 주소에서 경로로 매핑하는 것은 하위 수준\(즉, 로컬 네트 또는 게이트웨이\) 절차의 작업입니다.

주소는 4옥텟\(32비트\)의 고정 길이입니다. 주소는 네트워크 번호로 시작하고 그 뒤에 로컬 주소\("rest" 필드라고 함\)가 옵니다. 인터넷 주소에는 세 가지 형식 또는 클래스가 있습니다. 클래스 a에서 상위 비트는 0이고 다음 7비트는 네트워크이고 마지막 24비트는 로컬 주소입니다. 클래스 b에서 상위 2비트는 1-0이고 다음 14비트는 네트워크이고 마지막 16비트는 로컬 주소입니다. 클래스 c에서 상위 3비트는 1-1-0이고 다음 21비트는 네트워크이고 마지막 8비트는 로컬 주소입니다.

인터넷 주소를 로컬 넷 주소에 매핑할 때는 주의를 기울여야 합니다. 단일 물리적 호스트는 여러 개별 인터넷 주소를 사용하는 정도까지 여러 개별 호스트인 것처럼 작동할 수 있어야 합니다. 일부 호스트에는 여러 물리적 인터페이스\(멀티호밍\)도 있습니다.

즉, 호스트가 각각 여러 논리적 인터넷 주소를 가진 네트워크에 대한 여러 물리적 인터페이스를 갖도록 준비해야 합니다.

주소 매핑의 예는 "주소 매핑"\[5\]에서 찾을 수 있습니다.

```text
  Fragmentation
```

인터넷 데이터그램의 조각화는 큰 패킷 크기를 허용하는 로컬 네트워크에서 시작되고 목적지에 도달하기 위해 패킷을 더 작은 크기로 제한하는 로컬 네트워크를 통과해야 하는 경우 필요합니다.

인터넷 데이터그램은 "조각화 안 함"으로 표시될 수 있습니다. 이렇게 표시된 모든 인터넷 데이터그램은 어떤 상황에서도 인터넷 조각화되지 않습니다. don't fragment로 표시된 인터넷 데이터그램을 조각화하지 않고 목적지로 전달할 수 없으면 대신 폐기합니다.

인터넷 프로토콜 모듈에 보이지 않는 로컬 네트워크를 통한 조각화, 전송 및 재조립을 인트라넷 조각화라고 하며 사용할 수 있습니다\[6\].

인터넷 단편화 및 재조립 절차는 데이터그램을 나중에 재조립할 수 있는 거의 임의의 수의 조각으로 나눌 수 있어야 합니다. 조각의 수신자는 식별 필드를 사용하여 다른 데이터그램의 조각이 섞이지 않도록 합니다. 단편 오프셋 필드는 원래 데이터그램에서 단편의 위치를 ​​수신자에게 알려줍니다. 단편 오프셋과 길이는 이 단편이 다루는 원래 데이터그램의 부분을 결정합니다. more-fragments 플래그는 \(재설정됨으로써\) 마지막 조각을 나타냅니다. 이러한 필드는 데이터그램을 재조립하기에 충분한 정보를 제공합니다.

식별 필드는 한 데이터그램의 조각을 다른 데이터그램 조각과 구별하는 데 사용됩니다. 인터넷 데이터그램의 원래 프로토콜 모듈은 데이터그램이 인터넷 시스템에서 활성화되는 시간 동안 해당 소스-목적지 쌍 및 프로토콜에 대해 고유해야 하는 값으로 식별 필드를 설정합니다. 완전한 데이터그램의 원래 프로토콜 모듈은 more-fragments 플래그를 0으로 설정하고 조각 오프셋을 0으로 설정합니다.

```text
    To fragment a long internet datagram, an internet protocol module
    (for example, in a gateway), creates two new internet datagrams and
    copies the contents of the internet header fields from the long
    datagram into both new internet headers.  The data of the long
    datagram is divided into two portions on a 8 octet (64 bit) boundary
    (the second portion might not be an integral multiple of 8 octets,
    but the first must be).  Call the number of 8 octet blocks in the
    first portion NFB (for Number of Fragment Blocks).  The first
    portion of the data is placed in the first new internet datagram,
    and the total length field is set to the length of the first
```

데이터그램. more-fragments 플래그는 1로 설정됩니다. 데이터의 두 번째 부분은 두 번째 새로운 인터넷 데이터그램에 배치되고 전체 길이 필드는 두 번째 데이터그램의 길이로 설정됩니다. more-fragments 플래그는 긴 데이터그램과 동일한 값을 전달합니다. 두 번째 새 인터넷 데이터그램의 조각 오프셋 필드는 긴 데이터그램에 NFB를 더한 해당 필드의 값으로 설정됩니다.

이 절차는 설명된 양방향 분할이 아니라 n방향 분할에 대해 일반화될 수 있습니다.

인터넷 데이터그램의 조각을 조립하기 위해 인터넷 프로토콜 모듈\(예: 대상 호스트\)은 식별, 소스, 대상 및 프로토콜의 4개 필드에 대해 모두 동일한 값을 갖는 인터넷 데이터그램을 결합합니다. 조합은 해당 조각의 인터넷 헤더에서 조각 오프셋으로 표시된 상대 위치에 각 조각의 데이터 부분을 배치하여 수행됩니다. 첫 번째 프래그먼트는 프래그먼트 오프셋이 0이고 마지막 프래그먼트는 더 많은 프래그먼트 플래그가 0으로 재설정됩니다.

---
### **2.4.  Gateways**

게이트웨이는 네트워크 간에 데이터그램을 전달하기 위해 인터넷 프로토콜을 구현합니다. 게이트웨이는 또한 라우팅 및 기타 인터넷 제어 정보를 조정하기 위해 GGP\(Gateway to Gateway Protocol\) \[7\]를 구현합니다.

게이트웨이에서는 더 높은 수준의 프로토콜을 구현할 필요가 없으며 GGP 기능이 IP 모듈에 추가됩니다.

```text
                                    
                   +-------------------------------+   
                   | Internet Protocol & ICMP & GGP|   
                   +-------------------------------+   
                           |                 |         
                 +---------------+   +---------------+ 
                 |   Local Net   |   |   Local Net   | 
                 +---------------+   +---------------+ 

                           Gateway Protocols

                               Figure 3.

  

                           3.  SPECIFICATION
```

---
### **3.1.  Internet Header Format**

인터넷 헤더의 내용 요약은 다음과 같습니다.

```text
                                    
    0                   1                   2                   3   
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |Version|  IHL  |Type of Service|          Total Length         |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |         Identification        |Flags|      Fragment Offset    |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |  Time to Live |    Protocol   |         Header Checksum       |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                       Source Address                          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                    Destination Address                        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                    Options                    |    Padding    |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                    Example Internet Datagram Header

                               Figure 4.
```

각 눈금 표시는 1비트 위치를 나타냅니다.

```text
  Version:  4 bits
```

버전 필드는 인터넷 헤더의 형식을 나타냅니다. 이 문서는 버전 4에 대해 설명합니다.

```text
  IHL:  4 bits
```

인터넷 헤더 길이는 32비트 워드로 된 인터넷 헤더의 길이이므로 데이터의 시작 부분을 가리킵니다. 올바른 헤더의 최소값은 5입니다.

```text
  Type of Service:  8 bits
```

서비스 유형은 원하는 서비스 품질의 추상 매개변수 표시를 제공합니다. 이러한 매개변수는 특정 네트워크를 통해 데이터그램을 전송할 때 실제 서비스 매개변수의 선택을 안내하는 데 사용됩니다. 여러 네트워크는 우선 순위가 높은 트래픽을 다른 트래픽보다 더 중요하게 취급하는 서비스 우선 순위를 제공합니다\(일반적으로 부하가 높을 때 특정 우선 순위 이상의 트래픽만 수락함\). 주요 선택은 저지연, 고신뢰성, 고처리량 사이의 세 가지 절충안입니다.

비트 0-2: 우선 순위.

- 비트 3: 0 = 일반 지연, 1 = 낮은 지연. 비트 4: 0 = 일반 처리량, 1 = 높은 처리량. 비트 5: 0 = 정상 신뢰도, 1 = 높은 신뢰도. 비트 6-7: 향후 사용을 위해 예약됨.

```text
         0     1     2     3     4     5     6     7
      +-----+-----+-----+-----+-----+-----+-----+-----+
      |                 |     |     |     |     |     |
      |   PRECEDENCE    |  D  |  T  |  R  |  0  |  0  |
      |                 |     |     |     |     |     |
      +-----+-----+-----+-----+-----+-----+-----+-----+

        Precedence

          111 - Network Control
          110 - Internetwork Control
          101 - CRITIC/ECP
          100 - Flash Override
          011 - Flash
          010 - Immediate
          001 - Priority
          000 - Routine
```

지연, 처리량 및 안정성 표시를 사용하면 서비스 비용\(어떤 의미에서\)이 증가할 수 있습니다. 많은 네트워크에서 이러한 매개변수 중 하나의 성능 향상은 다른 매개변수의 성능 저하와 결합됩니다. 매우 특이한 경우를 제외하고 이 세 가지 표시 중 최대 두 개를 설정해야 합니다.

서비스 유형은 인터넷 시스템을 통해 데이터그램을 전송하는 동안 데이터그램 처리를 지정하는 데 사용됩니다. AUTODIN II, ARPANET, SATNET 및 PRNET과 같은 네트워크에서 제공되는 실제 서비스에 대한 인터넷 서비스 유형의 매핑 예는 "서비스 매핑"\[8\]에 나와 있습니다.

네트워크 제어 우선 순위 지정은 네트워크 내에서만 사용하기 위한 것입니다. 해당 지정의 실제 사용 및 제어는 각 네트워크에 달려 있습니다. 인터네트워크 제어 지정은 게이트웨이 제어 생성자만 사용하기 위한 것입니다. 이러한 우선순위 지정의 실제 사용이 특정 네트워크와 관련된 경우 해당 우선순위 지정에 대한 액세스 및 사용을 제어하는 ​​것은 해당 네트워크의 책임입니다.

```text
  Total Length:  16 bits
```

총 길이는 인터넷 헤더 및 데이터를 포함하여 옥텟 단위로 측정된 데이터그램의 길이입니다. 이 필드를 사용하면 데이터그램의 길이가 최대 65,535옥텟이 될 수 있습니다. 이러한 긴 데이터그램은 대부분의 호스트와 네트워크에서 비실용적입니다. 모든 호스트는 최대 576옥텟의 데이터그램\(전체 또는 조각으로 도착\)을 수락할 준비가 되어 있어야 합니다. 목적지가 더 큰 데이터그램을 받아들일 준비가 되었다는 보장이 있는 경우에만 호스트가 576 옥텟보다 큰 데이터그램을 보내는 것이 좋습니다.

숫자 576은 필요한 헤더 정보에 추가하여 합리적인 크기의 데이터 블록을 전송할 수 있도록 선택됩니다. 예를 들어, 이 크기는 512옥텟과 64헤더 옥텟의 데이터 블록이 데이터그램에 맞도록 허용합니다. 최대 인터넷 헤더는 60옥텟이고 일반적인 인터넷 헤더는 20옥텟이므로 더 높은 수준의 프로토콜 헤더에 여유가 있습니다.

```text
  Identification:  16 bits
```

데이터그램 조각을 조립하는 데 도움이 되도록 발신자가 할당한 식별 값입니다.

```text
  Flags:  3 bits

    Various Control Flags.
```

비트 0: 예약됨, 0이어야 함

- 비트 1: \(DF\) 0 = 조각화 가능, 1 = 조각화 안 함. 비트 2: \(MF\) 0 = 마지막 조각, 1 = 추가 조각.

```text
          0   1   2
        +---+---+---+
        |   | D | M |
        | 0 | F | F |
        +---+---+---+

  Fragment Offset:  13 bits
```

이 필드는 데이터그램에서 이 조각이 속한 위치를 나타냅니다.

프래그먼트 오프셋은 8 옥텟\(64비트\) 단위로 측정됩니다. 첫 번째 조각의 오프셋은 0입니다.

```text
  Time to Live:  8 bits
```

이 필드는 데이터그램이 인터넷 시스템에 남아 있도록 허용되는 최대 시간을 나타냅니다. 이 필드에 값 0이 있으면 데이터그램을 삭제해야 합니다. 이 필드는 인터넷 헤더 처리에서 수정됩니다. 시간은 초 단위로 측정되지만, 데이터그램을 처리하는 모든 모듈은 1초 이내에 데이터그램을 처리하더라도 최소한 TTL을 1씩 줄여야 하므로 TTL은 데이터그램이 존재할 수 있는 시간의 상한 정도로만 생각해야 합니다. 의도는 배달할 수 없는 데이터그램을 폐기하고 최대 데이터그램 수명을 제한하는 것입니다.

```text
  Protocol:  8 bits
```

이 필드는 인터넷 데이터그램의 데이터 부분에서 사용되는 다음 수준 프로토콜을 나타냅니다. 다양한 프로토콜에 대한 값은 "할당된 번호"\[9\]에 지정되어 있습니다.

```text
  Header Checksum:  16 bits
```

헤더에만 있는 체크섬. 일부 헤더 필드가 변경되기 때문에\(예: TTL\) 인터넷 헤더가 처리되는 각 지점에서 다시 계산되고 확인됩니다.

체크섬 알고리즘은 다음과 같습니다.

- 체크섬 필드는 헤더에 있는 모든 16비트 단어의 1의 보수 합계에 대한 16비트 1의 보수입니다. 체크섬을 계산하기 위해 체크섬 필드의 값은 0입니다.

이는 체크섬 계산이 간단하고 실험적 증거에 따르면 적절하지만 잠정적이며 추가 경험에 따라 CRC 절차로 대체될 수 있습니다.

```text
  Source Address:  32 bits
```

소스 주소입니다. 섹션 3.2를 참조하십시오.

```text
  Destination Address:  32 bits
```

목적지 주소. 섹션 3.2를 참조하십시오.

```text
  Options:  variable
```

옵션은 데이터그램에 나타나거나 나타나지 않을 수 있습니다. 모든 IP 모듈\(호스트 및 게이트웨이\)에서 구현해야 합니다. 선택 사항은 구현이 아니라 특정 데이터그램에서 전송하는 것입니다.

일부 환경에서는 모든 데이터그램에서 보안 옵션이 필요할 수 있습니다.

옵션 필드는 길이가 가변적입니다. 0개 이상의 옵션이 있을 수 있습니다. 옵션 형식에는 두 가지 경우가 있습니다.

- 사례 1: 옵션 유형의 단일 옥텟.

- 사례 2: 옵션 유형 옥텟, 옵션 길이 옥텟 및 실제 옵션 데이터 옥텟.

옵션 길이 옥텟은 옵션 데이터 옥텟뿐만 아니라 옵션 유형 옥텟과 옵션 길이 옥텟을 센다.

옵션 유형 옥텟에는 3개의 필드가 있는 것으로 간주됩니다.

```text
      1 bit   copied flag,
      2 bits  option class,
      5 bits  option number.
```

복사된 플래그는 이 옵션이 조각화 시 모든 조각에 복사됨을 나타냅니다.

```text
      0 = not copied
      1 = copied
```

옵션 클래스는 다음과 같습니다.

0 = 제어

- 1 = 향후 사용을 위해 예약됨 2 = 디버깅 및 측정 3 = 향후 사용을 위해 예약됨

다음 인터넷 옵션이 정의됩니다.

```text
      CLASS NUMBER LENGTH DESCRIPTION
      ----- ------ ------ -----------
        0     0      -    End of Option list.  This option occupies only
                          1 octet; it has no length octet.
        0     1      -    No Operation.  This option occupies only 1
                          octet; it has no length octet.
        0     2     11    Security.  Used to carry Security,
                          Compartmentation, User Group (TCC), and
                          Handling Restriction Codes compatible with DOD
                          requirements.
        0     3     var.  Loose Source Routing.  Used to route the
                          internet datagram based on information
                          supplied by the source.
        0     9     var.  Strict Source Routing.  Used to route the
                          internet datagram based on information
                          supplied by the source.
        0     7     var.  Record Route.  Used to trace the route an
                          internet datagram takes.
        0     8      4    Stream ID.  Used to carry the stream
                          identifier.
        2     4     var.  Internet Timestamp.

      

    Specific Option Definitions
```

- 옵션 목록 끝

```text
        +--------+
        |00000000|
        +--------+
          Type=0
```

- 이 옵션은 옵션 목록의 끝을 나타냅니다. 이것은 인터넷 헤더 길이에 따라 인터넷 헤더의 끝과 일치하지 않을 수 있습니다. 이것은 각 옵션의 끝이 아니라 모든 옵션의 끝에서 사용되며 옵션의 끝이 인터넷 헤더의 끝과 일치하지 않는 경우에만 사용해야 합니다.

- 단편화 또는 기타 이유로 인해 복사, 소개 또는 삭제될 수 있습니다.

```text
      No Operation

        +--------+
        |00000001|
        +--------+
          Type=1
```

- 이 옵션은 예를 들어 후속 옵션의 시작 부분을 32비트 경계에 맞추기 위해 옵션 사이에 사용할 수 있습니다.

- 단편화 또는 기타 이유로 인해 복사, 소개 또는 삭제될 수 있습니다.

```text
      Security
```

이 옵션은 호스트가 보안을 보내는 방법을 제공합니다.

- 구획, 취급 제한 및 TCC\(폐쇄 사용자 그룹\) 매개변수. 이 옵션의 형식은 다음과 같습니다.

```text
          +--------+--------+---//---+---//---+---//---+---//---+
          |10000010|00001011|SSS  SSS|CCC  CCC|HHH  HHH|  TCC   |
          +--------+--------+---//---+---//---+---//---+---//---+
           Type=130 Length=11

        Security (S field):  16 bits
```

- 16개 보안 수준 중 하나를 지정합니다\(이 중 8개는 향후 사용을 위해 예약됨\).

```text
            00000000 00000000 - Unclassified
            11110001 00110101 - Confidential
            01111000 10011010 - EFTO
            10111100 01001101 - MMMM
            01011110 00100110 - PROG
            10101111 00010011 - Restricted
            11010111 10001000 - Secret
            01101011 11000101 - Top Secret
            00110101 11100010 - (Reserved for future use)
            10011010 11110001 - (Reserved for future use)
            01001101 01111000 - (Reserved for future use)
            00100100 10111101 - (Reserved for future use)
            00010011 01011110 - (Reserved for future use)
            10001001 10101111 - (Reserved for future use)
            11000100 11010110 - (Reserved for future use)
            11100010 01101011 - (Reserved for future use)

        Compartments (C field):  16 bits
```

- 전송된 정보가 구분되지 않은 경우 모두 0 값을 사용합니다. 구획 필드의 다른 값은 국방 정보국에서 얻을 수 있습니다.

```text
        Handling Restrictions (H field):  16 bits
```

제어 및 릴리스 표시 값은 다음과 같습니다.

- 영숫자 이중 그래프이며 국방 정보국 매뉴얼 DIAM 65-19, "표준 보안 표시"에 정의되어 있습니다.

```text
        Transmission Control Code (TCC field):  24 bits
```

- 트래픽을 분리하고 가입자 간에 통제된 관심 커뮤니티를 정의하는 수단을 제공합니다. TCC 값은 삼중 그래프이며 HQ DCA 코드 530에서 사용할 수 있습니다.

- 조각화 시 복사해야 합니다. 이 옵션은 데이터그램에서 최대 한 번 나타납니다.

- 느슨한 소스 및 레코드 경로

```text
        +--------+--------+--------+---------//--------+
        |10000011| length | pointer|     route data    |
        +--------+--------+--------+---------//--------+
         Type=131
```

- LSRR\(Loose Source and Record Route\) 옵션은 인터넷 데이터그램의 소스가 데이터그램을 목적지로 전달할 때 게이트웨이가 사용할 라우팅 정보를 제공하고 경로 정보를 기록하는 수단을 제공합니다.

- 옵션은 옵션 유형 코드로 시작합니다. 두 번째 옥텟은 옵션 유형 코드와 길이 옥텟, 포인터 옥텟, 경로 데이터의 길이-3 옥텟을 포함하는 옵션 길이입니다. 세 번째 옥텟은 처리할 다음 소스 주소를 시작하는 옥텟을 나타내는 경로 데이터에 대한 포인터입니다. 포인터는 이 옵션에 상대적이며 포인터에 대한 가장 작은 법적 값은 4입니다.

- 경로 데이터는 일련의 인터넷 주소로 구성됩니다. 각 인터넷 주소는 32비트 또는 4옥텟입니다. 포인터가 길이보다 크면 소스 경로는 비어 있고\(기록된 경로는 가득 차 있음\) 라우팅은 대상 주소 필드를 기반으로 합니다.

- 목적지 주소 필드의 주소에 도달했고 포인터가 길이보다 크지 않으면 소스 경로의 다음 주소가 목적지 주소 필드의 주소를 대체하고 기록된 경로 주소는 방금 사용한 소스 주소를 대체하며 포인터는 4씩 증가합니다.

- 기록된 경로 주소는 이 데이터그램이 전달되는 환경에서 알려진 인터넷 모듈의 자체 인터넷 주소입니다.

- 소스 경로를 기록된 경로로 교체하는 이 절차\(소스 경로로 사용하기 위해 반드시 있어야 하는 순서의 역순이지만\)는 옵션\(및 IP 헤더 전체\)이 인터넷을 통해 데이터그램이 진행됨에 따라 일정한 길이로 유지됨을 의미합니다.

- 이 옵션은 게이트웨이 또는 호스트 IP가 경로의 다음 주소에 도달하기 위해 다른 중간 게이트웨이의 모든 경로를 사용할 수 있기 때문에 느슨한 소스 경로입니다.

- 조각화 시 복사해야 합니다. 데이터그램에서 최대 한 번 나타납니다.

- 엄격한 소스 및 레코드 경로

```text
        +--------+--------+--------+---------//--------+
        |10001001| length | pointer|     route data    |
        +--------+--------+--------+---------//--------+
         Type=137
```

- 엄격한 소스 및 레코드 경로\(SSRR\) 옵션은 인터넷 데이터그램의 소스가 게이트웨이가 데이터그램을 대상으로 전달할 때 사용할 라우팅 정보를 제공하고 경로 정보를 기록하는 수단을 제공합니다.

- 옵션은 옵션 유형 코드로 시작합니다. 두 번째 옥텟은 옵션 유형 코드와 길이 옥텟, 포인터 옥텟, 경로 데이터의 길이-3 옥텟을 포함하는 옵션 길이입니다. 세 번째 옥텟은 처리할 다음 소스 주소를 시작하는 옥텟을 나타내는 경로 데이터에 대한 포인터입니다. 포인터는 이 옵션에 상대적이며 포인터에 대한 가장 작은 법적 값은 4입니다.

```text
        A route data is composed of a series of internet addresses.
        Each internet address is 32 bits or 4 octets.  If the pointer is
        greater than the length, the source route is empty (and the
```

- 기록된 경로 전체\) 및 라우팅은 목적지 주소 필드를 기반으로 합니다.

- 목적지 주소 필드의 주소에 도달했고 포인터가 길이보다 크지 않으면 소스 경로의 다음 주소가 목적지 주소 필드의 주소를 대체하고 기록된 경로 주소는 방금 사용한 소스 주소를 대체하며 포인터는 4씩 증가합니다.

- 기록된 경로 주소는 이 데이터그램이 전달되는 환경에서 알려진 인터넷 모듈의 자체 인터넷 주소입니다.

- 소스 경로를 기록된 경로로 교체하는 이 절차\(소스 경로로 사용하기 위해 반드시 있어야 하는 순서의 역순이지만\)는 옵션\(및 IP 헤더 전체\)이 인터넷을 통해 데이터그램이 진행됨에 따라 일정한 길이로 유지됨을 의미합니다.

- 이 옵션은 경로에 지정된 다음 게이트웨이 또는 호스트에 도달하기 위해 게이트웨이 또는 호스트 IP가 다음 주소에 표시된 직접 연결된 네트워크를 통해서만 소스 경로의 다음 주소로 데이터그램을 직접 보내야 하기 때문에 엄격한 소스 경로입니다.

- 조각화 시 복사해야 합니다. 데이터그램에서 최대 한 번 나타납니다.

```text
      Record Route

        +--------+--------+--------+---------//--------+
        |00000111| length | pointer|     route data    |
        +--------+--------+--------+---------//--------+
          Type=7
```

- Record route 옵션은 인터넷 데이터그램의 경로를 기록하는 수단을 제공합니다.

- 옵션은 옵션 유형 코드로 시작합니다. 두 번째 옥텟은 옵션 유형 코드와 길이 옥텟, 포인터 옥텟, 경로 데이터의 길이-3 옥텟을 포함하는 옵션 길이입니다. 세 번째 옥텟은 경로 주소를 저장하기 위해 다음 영역을 시작하는 옥텟을 나타내는 경로 데이터에 대한 포인터입니다. 포인터는 이 옵션에 상대적이며 포인터에 대한 가장 작은 법적 값은 4입니다.

```text
        A recorded route is composed of a series of internet addresses.
        Each internet address is 32 bits or 4 octets.  If the pointer is
```

- 길이보다 크면 기록된 경로 데이터 영역이 가득 찼습니다. 원래 호스트는 예상되는 모든 주소를 보유할 수 있을 만큼 충분히 큰 경로 데이터 영역으로 이 옵션을 구성해야 합니다. 옵션의 크기는 주소 추가로 인해 변경되지 않습니다. 경로 데이터 영역의 초기 내용은 0이어야 합니다.

- 인터넷 모듈이 데이터그램을 라우팅할 때 레코드 경로 옵션이 있는지 확인합니다. 그렇다면 포인터가 나타내는 옥텟에서 시작하여 기록된 경로로 이 데이터그램이 전달되는 환경에서 알려진 자체 인터넷 주소를 삽입하고 포인터를 4씩 증가시킵니다.

- 경로 데이터 영역이 이미 가득 찬 경우\(포인터가 길이를 초과하는 경우\) 기록된 경로에 주소를 삽입하지 않고 데이터그램을 전달합니다. 공간이 있지만 전체 주소를 삽입할 공간이 충분하지 않은 경우 원래 데이터그램은 오류가 있는 것으로 간주되어 폐기됩니다. 두 경우 모두 ICMP 매개변수 문제 메시지가 소스 호스트로 전송될 수 있습니다\[3\].

- 조각화 시 복사되지 않고 첫 번째 조각에만 들어갑니다. 데이터그램에서 최대 한 번 나타납니다.

```text
      Stream Identifier

        +--------+--------+--------+--------+
        |10001000|00000010|    Stream ID    |
        +--------+--------+--------+--------+
         Type=136 Length=4
```

이 옵션은 16비트 SATNET 스트림을 위한 방법을 제공합니다.

- 스트림 개념을 지원하지 않는 네트워크를 통해 전달되는 식별자.

- 조각화 시 복사해야 합니다. 데이터그램에서 최대 한 번 나타납니다.

```text
      Internet Timestamp

        +--------+--------+--------+--------+
        |01000100| length | pointer|oflw|flg|
        +--------+--------+--------+--------+
        |         internet address          |
        +--------+--------+--------+--------+
        |             timestamp             |
        +--------+--------+--------+--------+
        |                 .                 |
                          .
                          .
        Type = 68
```

- 옵션 길이는 유형, 길이, 포인터 및 오버플로/플래그 옥텟을 계산하는 옵션의 옥텟 수입니다\(최대 길이 40\).

- 포인터는 이 옵션의 시작부터 타임스탬프 끝까지의 옥텟 수에 1을 더한 것입니다\(즉, 다음 타임스탬프를 위한 공간을 시작하는 옥텟을 가리킴\). 가장 작은 법적 값은 5입니다. 포인터가 길이보다 크면 타임스탬프 영역이 가득 찹니다.

- Overflow\(oflw\)\[4비트\]는 공간 부족으로 타임스탬프를 등록할 수 없는 IP 모듈의 개수입니다.

```text
        The Flag (flg) [4 bits] values are
```

- 0 -- 연속 32비트 단어로 저장되는 타임스탬프만,

- 1 -- 각 타임스탬프 앞에 등록 엔티티의 인터넷 주소가 옵니다.

- 3 -- 인터넷 주소 필드가 미리 지정되어 있습니다. IP 모듈은 자체 주소가 다음에 지정된 인터넷 주소와 일치하는 경우에만 타임스탬프를 등록합니다.

타임스탬프는 오른쪽 정렬된 32비트 타임스탬프입니다.

- UT 자정 이후 밀리초. 시간을 밀리초 단위로 사용할 수 없거나 자정 UT와 관련하여 제공할 수 없는 경우 타임스탬프 필드의 상위 비트가 비표준 값의 사용을 나타내기 위해 1로 설정되어 있는 경우 시간을 타임스탬프로 삽입할 수 있습니다.

```text
        The originating host must compose this option with a large
        enough timestamp data area to hold all the timestamp information
        expected.  The size of the option does not change due to adding
```

- 타임스탬프. 타임스탬프 데이터 영역의 초기 내용은 0 또는 인터넷 주소/0 쌍이어야 합니다.

- 타임스탬프 데이터 영역이 이미 가득 찬 경우\(포인터가 길이를 초과하는 경우\) 타임스탬프를 삽입하지 않고 데이터그램을 전달하지만 오버플로 횟수는 1씩 증가합니다.

- 일부 여유 공간이 있지만 전체 타임스탬프를 삽입할 공간이 부족하거나 오버플로 카운트 자체가 오버플로되면 원래 데이터그램은 오류가 있는 것으로 간주되어 폐기됩니다. 두 경우 모두 ICMP 매개변수 문제 메시지가 소스 호스트로 전송될 수 있습니다\[3\].

- 조각화 시 타임스탬프 옵션이 복사되지 않습니다. 그것은 첫 번째 조각에서 수행됩니다. 데이터그램에서 최대 한 번 나타납니다.

```text
  Padding:  variable
```

인터넷 헤더 패딩은 인터넷 헤더가 32비트 경계에서 끝나도록 하는 데 사용됩니다. 패딩은 0입니다.

---
### **3.2.  Discussion**

프로토콜의 구현은 견고해야 합니다. 각 구현은 다른 개인이 만든 다른 구현과 상호 운용될 것으로 예상해야 합니다. 이 사양의 목표는 프로토콜에 대해 명시하는 것이지만 다른 해석의 가능성이 있습니다. 일반적으로 구현은 전송 동작은 보수적이어야 하고 수신 동작은 자유로워야 합니다. 즉, 올바른 형식의 데이터그램을 보내는 데 주의해야 하지만 해석할 수 있는 모든 데이터그램을 수락해야 합니다\(예: 의미가 여전히 명확한 기술적 오류에 반대하지 않음\).

기본 인터넷 서비스는 데이터그램 지향적이며 게이트웨이에서 데이터그램 조각화를 제공하며 대상 호스트의 대상 인터넷 프로토콜 모듈에서 재조립이 이루어집니다. 물론, 네트워크 내에서 또는 네트워크 게이트웨이 간의 사적 합의에 의한 데이터그램의 조각화 및 재조립도 인터넷 프로토콜과 상위 수준 프로토콜에 투명하기 때문에 허용됩니다. 이러한 투명한 유형의 조각화 및 재조립을 "네트워크 종속"\(또는 인트라넷\) 조각화라고 하며 여기서는 더 이상 설명하지 않습니다.

인터넷 주소는 소스와 대상을 호스트 수준으로 구분하고 프로토콜 필드도 제공합니다. 각 프로토콜은 호스트 내에서 필요한 모든 다중화를 제공한다고 가정합니다.

```text
  Addressing
```

네트워크에 주소를 할당하는 유연성을 제공하고 다수의 중소형 네트워크를 허용하기 위해 주소 필드의 해석은 많은 수의 호스트가 있는 적은 수의 네트워크, 적당한 수의 호스트가 있는 적당한 수의 네트워크 및 적은 수의 호스트가 있는 많은 수의 네트워크를 지정하도록 코딩됩니다. 또한 확장 주소 지정 모드에 대한 이스케이프 코드가 있습니다.

```text
    Address Formats:
```

```text
      High Order Bits   Format                           Class
      ---------------   -------------------------------  -----
            0            7 bits of net, 24 bits of host    a
            10          14 bits of net, 16 bits of host    b
            110         21 bits of net,  8 bits of host    c
            111         escape to extended addressing mode
```

- 네트워크 필드의 값이 0이면 이 네트워크를 의미합니다. 특정 ICMP 메시지에서만 사용됩니다. 확장 주소 지정 모드는 정의되지 않았습니다. 이 두 기능은 모두 향후 사용을 위해 예약되어 있습니다.

네트워크 주소에 할당된 실제 값은 "할당된 번호"\[9\]에 나와 있습니다.

로컬 네트워크에서 할당한 로컬 주소는 단일 물리적 호스트가 여러 개별 인터넷 호스트로 작동하도록 허용해야 합니다. 즉, 인터넷 호스트 주소와 네트워크/호스트 인터페이스 사이에 여러 인터넷 주소가 하나의 인터페이스에 대응되도록 하는 매핑이 있어야 합니다. 또한 호스트가 여러 물리적 인터페이스를 갖고 그 중 여러 데이터그램을 단일 호스트로 주소가 지정된 것처럼 처리할 수 있어야 합니다.

ARPANET, SATNET, PRNET 및 기타 네트워크에 대한 인터넷 주소와 주소 간의 주소 매핑은 "주소 매핑"\[5\]에 설명되어 있습니다.

조각화 및 재조립.

인터넷 식별 필드\(ID\)는 재조립할 데이터그램 조각을 식별하기 위해 소스 및 대상 주소, 프로토콜 필드와 함께 사용됩니다.

```text
    The More Fragments flag bit (MF) is set if the datagram is not the
    last fragment.  The Fragment Offset field identifies the fragment
    location, relative to the beginning of the original unfragmented
    datagram.  Fragments are counted in units of 8 octets.  The
```

조각화 전략은 조각화되지 않은 데이터그램이 조각화 정보가 모두 0\(MF = 0, 조각 오프셋 = 0\)이 되도록 설계되었습니다. 인터넷 데이터그램이 단편화되면 데이터 부분이 8옥텟 경계에서 끊어져야 합니다.

이 형식은 총 65,536 옥텟에 대해 각각 8 옥텟의 2\*\*13 = 8192 조각을 허용합니다. 이것은 데이터그램 총 길이 필드와 일치합니다\(물론 헤더는 조각이 아닌 총 길이로 계산됨\).

조각화가 발생하면 일부 옵션이 복사되지만 다른 옵션은 첫 번째 조각만 남습니다.

모든 인터넷 모듈은 추가 조각화 없이 68옥텟의 데이터그램을 전달할 수 있어야 합니다. 인터넷 헤더는 최대 60옥텟이고 최소 조각은 8옥텟이기 때문입니다.

모든 인터넷 대상은 576 옥텟의 데이터그램을 한 조각으로 또는 재조립할 조각으로 수신할 수 있어야 합니다.

조각화의 영향을 받을 수 있는 필드는 다음과 같습니다.

```text
      (1) options field
      (2) more fragments flag
      (3) fragment offset
      (4) internet header length field
      (5) total length field
      (6) header checksum
```

Don't Fragment 플래그\(DF\) 비트가 설정되면 이 데이터그램의 인터넷 단편화가 허용되지 않지만 폐기될 수 있습니다. 수신 호스트에 인터넷 조각을 재조립할 리소스가 충분하지 않은 경우 조각화를 금지하는 데 사용할 수 있습니다.

Don't Fragment 기능을 사용하는 한 가지 예는 작은 호스트를 다운라인 로드하는 것입니다. 소규모 호스트는 데이터그램을 받아들여 메모리에 저장한 다음 실행하는 부트스트랩 프로그램을 가질 수 있습니다.

조각화 및 재조립 절차는 예를 통해 가장 쉽게 설명됩니다. 다음 절차는 구현 예입니다.

다음 의사 프로그램의 일반 표기: "=<"는 "작거나 같음", "#"은 "같지 않음", "="는 "같음", "<-"는 "다음으로 설정됨"을 의미합니다. 또한 "x에서 y"는 x를 포함하고 y를 제외합니다. 예를 들어 "4 to 7"은 4, 5, 6을 포함하지만 7은 포함하지 않습니다.

```text
    An Example Fragmentation Procedure
```

- 다음 네트워크를 통해 전송할 수 있는 최대 크기의 데이터그램을 최대 전송 단위\(MTU\)라고 합니다.

- 총 길이가 최대 전송 단위보다 작거나 같으면 이 데이터그램을 데이터그램 처리의 다음 단계로 제출합니다. 그렇지 않으면 데이터그램을 두 조각으로 자르는데 첫 번째 조각은 최대 크기이고 두 번째 조각은 나머지 데이터그램입니다. 첫 번째 조각은 데이터그램 처리의 다음 단계로 제출되고 두 번째 조각은 여전히 ​​너무 큰 경우 이 절차에 제출됩니다.

```text
      Notation:

        FO    -  Fragment Offset
        IHL   -  Internet Header Length
        DF    -  Don't Fragment flag
        MF    -  More Fragments flag
        TL    -  Total Length
        OFO   -  Old Fragment Offset
        OIHL  -  Old Internet Header Length
        OMF   -  Old More Fragments flag
        OTL   -  Old Total Length
        NFB   -  Number of Fragment Blocks
        MTU   -  Maximum Transmission Unit

      Procedure:

        IF TL =< MTU THEN Submit this datagram to the next step
             in datagram processing ELSE IF DF = 1 THEN discard the
        datagram ELSE
        To produce the first fragment:
        (1)  Copy the original internet header;
        (2)  OIHL <- IHL; OTL <- TL; OFO <- FO; OMF <- MF;
        (3)  NFB <- (MTU-IHL*4)/8;
        (4)  Attach the first NFB*8 data octets;
        (5)  Correct the header:
             MF <- 1;  TL <- (IHL*4)+(NFB*8);
             Recompute Checksum;
        (6)  Submit this fragment to the next step in
             datagram processing;
        To produce the second fragment:
        (7)  Selectively copy the internet header (some options
             are not copied, see option definitions);
        (8)  Append the remaining data;
        (9)  Correct the header:
             IHL <- (((OIHL*4)-(length of options not copied))+3)/4;
```

TL <- OTL - NFB\*8 - \(OIHL-IHL\)\*4\);

- FO <- OFO + NFB; MF <- OMF; 체크섬 재계산; \(10\) 이 조각을 조각화 테스트에 제출합니다. 완료.

- 위의 절차에서 각 조각\(마지막 조각 제외\)은 최대 허용 크기로 만들어졌습니다. 대안은 최대 크기보다 작은 데이터그램을 생성할 수 있습니다. 예를 들어, 결과 조각이 최대 전송 단위 크기보다 작아질 때까지 큰 데이터그램을 반복적으로 반으로 나누는 조각화 절차를 구현할 수 있습니다.

```text
    An Example Reassembly Procedure
```

- 각 데이터그램에 대해 버퍼 식별자는 소스, 대상, 프로토콜 및 식별 필드의 연결로 계산됩니다. 이것이 전체 데이터그램\(즉, 조각 오프셋과 더 많은 조각 필드가 모두 0인 경우\)이면 이 버퍼 식별자와 관련된 모든 재조립 리소스가 해제되고 데이터그램이 데이터그램 처리의 다음 단계로 전달됩니다.

- 이 버퍼 식별자를 가진 다른 조각이 없으면 재조립 리소스가 할당됩니다. 재조립 자원은 데이터 버퍼, 헤더 버퍼, 조각 블록 비트 테이블, 총 데이터 길이 필드 및 타이머로 구성됩니다. 프래그먼트의 데이터는 프래그먼트 오프셋 및 길이에 따라 데이터 버퍼에 배치되고 비트는 수신된 프래그먼트 블록에 해당하는 프래그먼트 블록 비트 테이블에 설정됩니다.

- 이것이 첫 번째 프래그먼트인 경우\(즉, 프래그먼트 오프셋이 0인 경우\) 이 헤더는 헤더 버퍼에 배치됩니다. 이것이 마지막 조각인 경우\(더 많은 조각 필드가 0인 경우\) 총 데이터 길이가 계산됩니다. 이 조각이 데이터그램을 완료하면\(조각 블록 테이블에 설정된 비트를 확인하여 테스트\) 데이터그램은 데이터그램 처리의 다음 단계로 보내집니다. 그렇지 않으면 타이머는 현재 타이머 값과 이 조각의 TTL\(Time to Live\) 필드 값의 최대값으로 설정됩니다. 재조립 루틴은 제어를 포기합니다.

- 타이머가 만료되면 이 버퍼 식별자에 대한 모든 재조립 리소스가 해제됩니다. 타이머의 초기 설정은 재조립 대기 시간의 하한값입니다. 이는 도착하는 fragment의 TTL이 현재 타이머 값보다 크면 대기 시간이 늘어나고 작으면 줄어들지 않기 때문입니다. 이 타이머 값이 도달할 수 있는 최대값은 최대 수명\(약 4.25분\)입니다. 초기 타이머 설정에 대한 현재 권장 사항은 15초입니다. 이것은 경험에 따라 변경될 수 있습니다.

- 이 프로토콜은 누적됩니다. 이 매개변수 값의 선택은 사용 가능한 버퍼 용량 및 전송 매체의 데이터 속도와 관련됩니다. 즉, 데이터 속도 x 타이머 값은 버퍼 크기와 같습니다\(예: 10Kb/s X 15s = 150Kb\).

```text
      Notation:

        FO    -  Fragment Offset
        IHL   -  Internet Header Length
        MF    -  More Fragments flag
        TTL   -  Time To Live
        NFB   -  Number of Fragment Blocks
        TL    -  Total Length
        TDL   -  Total Data Length
        BUFID -  Buffer Identifier
        RCVBT -  Fragment Received Bit Table
        TLB   -  Timer Lower Bound

      Procedure:
```

- \(1\) BUFID <- 소스|프로토콜|식별; \(2\) IF FO = 0 AND MF = 0 \(3\) THEN IF 버퍼에 BUFID가 할당된 경우 \(4\) THEN 이 BUFID에 대한 모든 재조립을 플러시합니다. \(5\) 데이터그램을 다음 단계로 제출합니다. 완료. \(6\) ELSE IF BUFID가 있는 버퍼가 할당되지 않은 경우 \(7\) THEN BUFID가 있는 재조립 리소스를 할당합니다. 타이머 <- TLB; TDL <- 0; \(8\) 옥텟 FO\*8에서 옥텟 \(TL-\(IHL\*4\)\)+FO\*8까지의 BUFID를 사용하여 프래그먼트의 데이터를 데이터 버퍼에 넣습니다. \(9\) RCVBT 비트를 FO에서 FO+\(\(TL-\(IHL\*4\)+7\)/8\)로 설정; \(10\) IF MF = 0 THEN TDL <- TL-\(IHL\*4\)+\(FO\*8\) \(11\) IF FO = 0 THEN 헤더 버퍼에 헤더 넣기 \(12\) IF TDL # 0 \(13\) AND 0에서 \(TDL+7\)/8까지의 모든 RCVBT 비트가 설정됨 \(14\) THEN TL <- TDL+\(IHL\*4\) \(15\) 데이터그램을 다음 단계로 제출; \(16\) 이 BUFID에 대한 모든 재조립 리소스를 해제합니다. 완료. \(17\) 타이머 <-맥스\(타이머,TTL\); \(18\) 다음 프래그먼트 또는 타이머가 만료될 때까지 포기합니다. \(19\) 타이머 만료: 이 BUFID로 모든 재조립을 플러시합니다. 완료.

- 2개 이상의 프래그먼트에 동일한 데이터가 포함된 경우

- 동일하게 또는 부분 중첩을 통해 이 절차는 데이터 버퍼 및 전달된 데이터그램에서 더 최근에 도착한 사본을 사용합니다.

```text
  Identification
```

데이터그램에 대한 식별자 선택은 특정 데이터그램의 조각을 고유하게 식별하는 방법을 제공해야 할 필요성을 기반으로 합니다. 프래그먼트를 조립하는 프로토콜 모듈은 프래그먼트의 소스, 대상, 프로토콜 및 식별자가 동일하면 동일한 데이터그램에 속하는 것으로 판단합니다. 따라서 보낸 사람은 데이터그램\(또는 데이터그램의 일부\)이 인터넷에서 살아 있을 수 있는 시간 동안 이 소스, 대상 쌍 및 프로토콜에 대해 고유한 식별자를 선택해야 합니다.

그러면 전송 프로토콜 모듈은 인터넷의 마지막 최대 패킷 수명에서 통신한 각 대상에 대해 하나의 항목인 식별자 테이블을 유지해야 하는 것 같습니다.

그러나 Identifier 필드는 65,536개의 서로 다른 값을 허용하기 때문에 일부 호스트는 목적지와 별개로 고유한 식별자를 사용할 수 있습니다.

일부 상위 수준 프로토콜이 식별자를 선택하는 것이 적절합니다. 예를 들어, TCP 프로토콜 모듈은 동일한 TCP 세그먼트를 재전송할 수 있으며, 올바른 TCP 세그먼트를 구성하는 데 두 데이터그램의 조각이 사용될 수 있으므로 재전송이 원래 전송과 동일한 식별자를 전달하는 경우 올바른 수신 가능성이 향상됩니다.

```text
  Type of Service
```

서비스 유형\(TOS\)은 인터넷 서비스 품질 선택을 위한 것입니다. 서비스 유형은 추상 매개변수 우선 순위, 지연, 처리량 및 안정성에 따라 지정됩니다. 이러한 추상 매개변수는 데이터그램이 통과하는 특정 네트워크의 실제 서비스 매개변수에 매핑됩니다.

상위. 이 데이터그램의 중요성에 대한 독립적인 척도입니다.

지연. 이 표시가 있는 데이터그램의 경우 신속한 전달이 중요합니다.

처리량. 이 표시가 있는 데이터그램에는 높은 데이터 속도가 중요합니다.

신뢰할 수 있음. 이 표시가 있는 데이터그램의 경우 배달을 보장하기 위한 더 높은 수준의 노력이 중요합니다.

예를 들어 ARPANET에는 우선 순위 비트가 있으며 "표준" 메시지\(유형 0\)와 "제어되지 않은" 메시지\(유형 3\) 중에서 선택할 수 있습니다\(단일 패킷과 다중 패킷 메시지 간의 선택도 서비스 매개변수로 간주될 수 있음\). 제어되지 않은 메시지는 덜 안정적으로 전달되는 경향이 있으며 지연이 적습니다. 인터넷 데이터그램이 ARPANET을 통해 전송된다고 가정합니다. 인터넷 서비스 유형을 다음과 같이 지정합니다.

```text
      Precedence:    5
      Delay:         0
      Throughput:    1
      Reliability:   1
```

이 예에서 이러한 매개변수를 ARPANET에 사용할 수 있는 매개변수에 매핑하는 것은 인터넷 우선 순위가 해당 범위의 상위 절반에 있으므로 ARPANET 우선 순위 비트를 on으로 설정하고 처리량 및 안정성 요구 사항이 표시되고 지연이 표시되지 않기 때문에 표준 메시지를 선택하는 것입니다. 서비스 매핑에 대한 자세한 내용은 "서비스 매핑" \[8\]에서 제공됩니다.

```text
  Time to Live
```

TTL\(Time to Live\)은 송신자가 데이터그램이 인터넷 시스템에 있을 수 있는 최대 시간으로 설정됩니다. 데이터그램이 TTL\(Time to Live\)보다 오래 인터넷 시스템에 있으면 데이터그램을 파괴해야 합니다.

데이터그램을 처리하는 데 소요된 시간을 반영하기 위해 인터넷 헤더가 처리되는 각 지점에서 이 필드를 줄여야 합니다. 실제로 소요된 시간에 대한 로컬 정보가 없더라도 필드는 1씩 감소해야 합니다. 시간은 초 단위로 측정됩니다\(즉, 값 1은 1초를 의미함\). 따라서 최대 생존 시간은 255초 또는 4.25분입니다. 데이터그램을 처리하는 모든 모듈은 1초 이내에 데이터그램을 처리하더라도 최소한 TTL을 1씩 줄여야 하므로 TTL은 데이터그램이 존재할 수 있는 시간의 상한 정도로만 생각해야 합니다. 의도는 배달할 수 없는 데이터그램을 폐기하고 최대 데이터그램 수명을 제한하는 것입니다.

일부 높은 수준의 신뢰할 수 있는 연결 프로토콜은 특정 시간이 경과한 후에 오래된 중복 데이터그램이 도착하지 않는다는 가정을 기반으로 합니다. TTL은 그러한 프로토콜이 가정이 충족된다는 확신을 가질 수 있는 방법입니다.

```text
  Options
```

옵션은 각 데이터그램에서 선택 사항이지만 구현에서는 필수입니다. 즉, 옵션의 유무는 발신자의 선택이지만 각 인터넷 모듈은 모든 옵션을 파싱할 수 있어야 합니다. 옵션 필드에 여러 옵션이 있을 수 있습니다.

옵션은 32비트 경계에서 끝나지 않을 수 있습니다. 인터넷 헤더는 0의 옥텟으로 채워져야 합니다. 이들 중 첫 번째는 옵션 종료 옵션으로 해석되고 나머지는 인터넷 헤더 패딩으로 해석됩니다.

모든 인터넷 모듈은 모든 옵션에 따라 작동할 수 있어야 합니다. 보안 옵션은 분류, 제한 또는 구획화된 트래픽을 통과해야 하는 경우에 필요합니다.

```text
  Checksum
```

인터넷 헤더가 변경되면 인터넷 헤더 체크섬이 다시 계산됩니다. 예를 들어 TTL\(Time to Live\) 감소, 인터넷 옵션의 추가 또는 변경 또는 단편화로 인한 것입니다. 인터넷 수준의 이 체크섬은 전송 오류로부터 인터넷 헤더 필드를 보호하기 위한 것입니다.

일부 데이터 비트 오류는 허용되지만 재전송 지연은 허용되지 않는 일부 애플리케이션이 있습니다. 인터넷 프로토콜이 데이터 정확성을 강제하는 경우 그러한 애플리케이션은 지원되지 않을 수 있습니다.

```text
  Errors
```

인터넷 프로토콜 오류는 ICMP 메시지\[3\]를 통해 보고될 수 있습니다.

---
### **3.3.  Interfaces**

IP에 대한 사용자 인터페이스의 기능 설명은 모든 운영 체제가 서로 다른 기능을 갖기 때문에 기껏해야 허구에 불과합니다. 결과적으로 우리는 다른 IP 구현이 다른 사용자 인터페이스를 가질 수 있음을 독자들에게 경고해야 합니다. 그러나 모든 IP는 모든 IP 구현이 동일한 프로토콜 계층을 지원할 수 있도록 보장하기 위해 특정 최소 서비스 집합을 제공해야 합니다. 이 섹션은 모든 IP 구현에 필요한 기능적 인터페이스를 지정합니다.

```text
  Internet protocol interfaces on one side to the local network and on
  the other side to either a higher level protocol or an application
  program.  In the following, the higher level protocol or application
```

프로그램\(또는 게이트웨이 프로그램\)은 인터넷 모듈을 사용하므로 "사용자"라고 합니다. 인터넷 프로토콜은 데이터그램 프로토콜이기 때문에 데이터그램 전송 간에 유지되는 최소한의 메모리 또는 상태가 있으며 사용자가 인터넷 프로토콜 모듈을 호출할 때마다 IP가 요청된 서비스를 수행하는 데 필요한 모든 정보를 제공합니다.

```text
  An Example Upper Level Interface
```

다음 두 예제 호출은 인터넷 프로토콜 모듈 통신에 대한 사용자 요구 사항을 충족합니다\("=\>"는 반환을 의미함\).

```text
  SEND (src, dst, prot, TOS, TTL, BufPTR, len, Id, DF, opt => result)

    where:
```

src = 소스 주소

- dst = 대상 주소 prot = 프로토콜 TOS = 서비스 유형 TTL = 수명 BufPTR = 버퍼 포인터 len = 버퍼 길이 Id = 식별자 DF = 조각화 안 함 opt = 옵션 데이터 결과 = 응답 확인 = 데이터그램 전송 확인 오류 = 인수 오류 또는 로컬 네트워크 오류

우선 순위는 TOS에 포함되어 있으며 보안/구획은 옵션으로 전달됩니다.

```text
  RECV (BufPTR, prot, => result, src, dst, TOS, len, opt)

    where:
```

BufPTR = 버퍼 포인터

- prot = 프로토콜 결과 = 응답 OK = 데이터그램 수신 확인 Error = 인수 오류 len = 버퍼 길이 src = 소스 주소 dst = 대상 주소 TOS = 서비스 유형 opt = 옵션 데이터

사용자가 데이터그램을 보낼 때 모든 인수를 제공하는 SEND 호출을 실행합니다. 인터넷 프로토콜 모듈은 이 호출을 받으면 인수를 확인하고 메시지를 준비하여 보냅니다. 인수가 양호하고 데이터그램이 로컬 네트워크에서 수락되면 호출이 성공적으로 반환됩니다. 인수가 잘못되었거나 데이터그램이 로컬 네트워크에서 수락되지 않으면 호출이 성공적으로 반환되지 않습니다. 반품에 실패한 경우 문제의 원인에 대해 합당한 보고를 해야 하지만 그러한 보고의 세부 사항은 개별 구현에 달려 있습니다.

데이터그램이 로컬 네트워크에서 인터넷 프로토콜 모듈에 도착하면 주소 지정된 사용자로부터 보류 중인 RECV 호출이 있거나 없습니다. 첫 번째 경우 보류 중인 호출은 데이터그램의 정보를 사용자에게 전달함으로써 충족됩니다. 두 번째 경우 주소 지정된 사용자에게 보류 중인 데이터그램이 통지됩니다. 주소가 지정된 사용자가 없으면 ICMP 오류 메시지가 발신자에게 반환되고 데이터가 삭제됩니다.

사용자의 통지는 의사 인터럽트 또는 구현의 특정 운영 체제 환경에 적절한 유사한 메커니즘을 통해 이루어질 수 있습니다.

사용자의 RECV 호출은 보류 중인 데이터그램에 의해 즉시 충족되거나 데이터그램이 도착할 때까지 호출이 보류될 수 있습니다.

송신 호스트에 여러 주소\(여러 물리적 연결 또는 논리 주소\)가 있는 경우 송신 호출에 소스 주소가 포함됩니다. 인터넷 모듈은 소스 주소가 이 호스트의 법적 주소 중 하나인지 확인해야 합니다.

구현은 또한 데이터그램 클래스\(예: 프로토콜 필드에서 특정 값을 가진 모든 것\)에 대한 관심을 표시하거나 독점 사용을 예약하기 위해 인터넷 모듈에 대한 호출을 허용하거나 요구할 수 있습니다.

이 섹션은 USER/IP 인터페이스를 기능적으로 특성화합니다. 사용된 표기법은 고급 언어에서 대부분의 함수 호출 절차와 유사하지만 트랩 유형 서비스 호출\(예: SVC, UUO, EMT\) 또는 다른 형태의 프로세스 간 통신을 배제하기 위한 것은 아닙니다.

```text
  
```

---
# **APPENDIX A:  Examples & Scenarios**
---
# **Example 1:**

이것은 인터넷 데이터그램을 운반하는 최소 데이터의 예입니다.

```text
                                    
    0                   1                   2                   3   
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |Ver= 4 |IHL= 5 |Type of Service|        Total Length = 21      |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |      Identification = 111     |Flg=0|   Fragment Offset = 0   |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |   Time = 123  |  Protocol = 1 |        header checksum        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                         source address                        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                      destination address                      |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |     data      |                                                
   +-+-+-+-+-+-+-+-+                                                

                       Example Internet Datagram

                               Figure 5.
```

각 눈금 표시는 1비트 위치를 나타냅니다.

이것은 인터넷 프로토콜 버전 4의 인터넷 데이터그램입니다. 인터넷 헤더는 5개의 32비트 워드로 구성되며 데이터그램의 총 길이는 21 옥텟입니다. 이 데이터그램은 조각이 아닌 완전한 데이터그램입니다.

---
# **Example 2:**

이 예에서는 먼저 적당한 크기의 인터넷 데이터그램\(452 데이터 옥텟\)을 표시한 다음 허용된 최대 크기 전송이 280 옥텟인 경우 이 데이터그램의 조각화로 인해 발생할 수 있는 두 개의 인터넷 조각을 보여줍니다.

```text
                                    
    0                   1                   2                   3   
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |Ver= 4 |IHL= 5 |Type of Service|       Total Length = 472      |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |     Identification = 111      |Flg=0|     Fragment Offset = 0 |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |   Time = 123  | Protocol = 6  |        header checksum        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                         source address                        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                      destination address                      |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                             data                              |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                             data                              |
   \                                                               \
   \                                                               \
   |                             data                              |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |             data              |                                
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+                                

                       Example Internet Datagram

                               Figure 6.
```

이제 256 데이터 옥텟 이후에 데이터그램을 분할한 결과로 생긴 첫 번째 단편입니다.

```text
                                    
    0                   1                   2                   3   
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |Ver= 4 |IHL= 5 |Type of Service|       Total Length = 276      |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |     Identification = 111      |Flg=1|     Fragment Offset = 0 |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |   Time = 119  | Protocol = 6  |        Header Checksum        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                         source address                        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                      destination address                      |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                             data                              |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                             data                              |
   \                                                               \
   \                                                               \
   |                             data                              |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                             data                              |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                       Example Internet Fragment

                               Figure 7.
```

그리고 두 번째 조각.

```text
                                    
    0                   1                   2                   3   
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |Ver= 4 |IHL= 5 |Type of Service|       Total Length = 216      |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |     Identification = 111      |Flg=0|  Fragment Offset  =  32 |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |   Time = 119  | Protocol = 6  |        Header Checksum        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                         source address                        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                      destination address                      |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                             data                              |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                             data                              |
   \                                                               \
   \                                                               \
   |                             data                              |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |            data               |                                
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+                                

                       Example Internet Fragment

                               Figure 8.
```

---
# **Example 3:**

다음은 옵션을 포함하는 데이터그램의 예를 보여줍니다.

```text
                                    
    0                   1                   2                   3   
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |Ver= 4 |IHL= 8 |Type of Service|       Total Length = 576      |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |       Identification = 111    |Flg=0|     Fragment Offset = 0 |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |   Time = 123  |  Protocol = 6 |       Header Checksum         |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                        source address                         |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                      destination address                      |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   | Opt. Code = x | Opt.  Len.= 3 | option value  | Opt. Code = x |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   | Opt. Len. = 4 |           option value        | Opt. Code = 1 |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   | Opt. Code = y | Opt. Len. = 3 |  option value | Opt. Code = 0 |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                             data                              |
   \                                                               \
   \                                                               \
   |                             data                              |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                             data                              |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                       Example Internet Datagram

                               Figure 9.
```

---
# **APPENDIX B:  Data Transmission Order**

헤더의 전송 순서와 이 문서에 기술된 데이터
문서는 옥텟 수준으로 확인됩니다. 다이어그램에
옥텟 그룹의 경우 해당 옥텟의 전송 순서는 정상입니다.
영어로 읽는 순서. 예를 들어 다음에서
다이어그램에서 옥텟은 번호가 매겨진 순서대로 전송됩니다.

```text
                                    
    0                   1                   2                   3   
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |       1       |       2       |       3       |       4       |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |       5       |       6       |       7       |       8       |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |       9       |      10       |      11       |      12       |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                      Transmission Order of Bytes

                               Figure 10.
```

옥텟이 숫자 양을 나타낼 때마다 가장 왼쪽 비트는
다이어그램은 상위 또는 최상위 비트입니다. 즉, 비트
0으로 레이블이 지정된 최상위 비트입니다. 예를 들어, 다음
다이어그램은 값 170\(십진수\)을 나타냅니다.

```text
                                    
                            0 1 2 3 4 5 6 7 
                           +-+-+-+-+-+-+-+-+
                           |1 0 1 0 1 0 1 0|
                           +-+-+-+-+-+-+-+-+

                          Significance of Bits

                               Figure 11.
```

마찬가지로 다중 옥텟 필드가 숫자 수량을 나타낼 때마다
전체 필드의 가장 왼쪽 비트가 최상위 비트입니다. 언제
다중 옥텟 양이 전송되는 경우 가장 중요한 옥텟은
먼저 전송되었습니다.

```text
                                GLOSSARY
```

1822 BBN 보고서 1822, "호스트와 IMP의 상호 연결 사양". 호스트와 ARPANET 간의 인터페이스 사양입니다.

ARPANET 리더 호스트-IMP 인터페이스에서 ARPANET 메시지에 대한 제어 정보.

ARPANET 메시지 ARPANET에서 호스트와 IMP 사이의 전송 단위. 최대 크기는 약 1012옥텟\(8096비트\)입니다.

ARPANET 패킷 IMP 사이의 ARPANET에서 내부적으로 사용되는 전송 단위. 최대 크기는 약 126옥텟\(1008비트\)입니다.

목적지 목적지 주소, 인터넷 헤더 필드.

DF 플래그 필드에 전달된 Don't Fragment 비트.

플래그 다양한 제어 플래그를 포함하는 인터넷 헤더 필드입니다.

조각 오프셋 이 인터넷 헤더 필드는 조각이 속한 인터넷 데이터그램의 위치를 ​​나타냅니다.

라우팅 및 기타 게이트웨이 기능을 제어하기 위해 게이트웨이 간에 주로 사용되는 프로토콜인 게이트웨이 프로토콜에 대한 GGP 게이트웨이.

헤더 메시지, 세그먼트, 데이터그램, 패킷 또는 데이터 블록의 시작 부분에 있는 제어 정보.

인터넷 모듈에 구현된 ICMP 인터넷 제어 메시지 프로토콜인 ICMP는 게이트웨이에서 호스트로 그리고 호스트 간에 오류를 보고하고 라우팅 제안을 하는 데 사용됩니다.

식별 데이터그램의 조각을 조립하는 데 도움이 되도록 발신자가 할당한 식별 값을 전달하는 인터넷 헤더 필드입니다.

IHL 인터넷 헤더 필드 인터넷 헤더 길이는 32비트 단어로 측정된 인터넷 헤더의 길이입니다.

IMP ARPANET의 패킷 스위치인 Interface Message Processor.

인터넷 주소 네트워크 필드와 로컬 주소 필드로 구성된 4옥텟\(32비트\) 소스 또는 대상 주소.

인터넷 데이터그램 한 쌍의 인터넷 모듈\(인터넷 헤더 포함\) 간에 교환되는 데이터 단위.

인터넷 조각 인터넷 헤더가 있는 인터넷 데이터그램의 데이터 부분입니다.

로컬 주소 네트워크 내의 호스트 주소입니다. 네트워크의 호스트 주소에 대한 인터넷 로컬 주소의 실제 매핑은 다대일 매핑을 허용하는 매우 일반적입니다.

MF 인터넷 헤더 플래그 필드에 포함된 More-Fragments 플래그입니다.

모듈 일반적으로 소프트웨어에서 프로토콜 또는 기타 절차를 구현합니다.

more-fragments 플래그 이 인터넷 데이터그램이 인터넷 데이터그램의 끝을 포함하는지 여부를 나타내는 플래그로, 인터넷 헤더 플래그 필드에서 전달됩니다.

NFB 인터넷 조각의 데이터 부분에 있는 조각 블록 수입니다. 즉, 8 옥텟 단위로 측정된 데이터의 일부 길이입니다.

옥텟 8비트 바이트.

옵션 인터넷 헤더 옵션 필드에는 여러 옵션이 포함될 수 있으며 각 옵션의 길이는 여러 옥텟일 수 있습니다.

패딩 인터넷 헤더 패딩 필드는 데이터가 32비트 단어 경계에서 시작되도록 하는 데 사용됩니다. 패딩은 0입니다.

프로토콜 이 문서에서 다음 상위 프로토콜 식별자인 인터넷 헤더 필드입니다.

나머지 인터넷 주소의 로컬 주소 부분입니다.

소스 소스 주소, 인터넷 헤더 필드입니다.

TCP 전송 제어 프로토콜: 인터넷 환경에서 안정적인 통신을 위한 호스트 간 프로토콜입니다.

TCP 세그먼트 TCP 모듈 간에 교환되는 데이터의 단위\(TCP 헤더 포함\).

TFTP Trivial File Transfer Protocol: UDP 기반의 간단한 파일 전송 프로토콜입니다.

TTL\(Time to Live\) 이 인터넷 데이터그램이 존재할 수 있는 기간의 상한을 나타내는 인터넷 헤더 필드입니다.

TOS 서비스 유형

총 길이 인터넷 헤더 필드 총 길이는 인터넷 헤더 및 데이터를 포함하는 옥텟 단위의 데이터그램 길이입니다.

TTL TTL\(Time to Live\)

Type of Service 이 인터넷 데이터그램에 대한 서비스 유형\(또는 품질\)을 나타내는 인터넷 헤더 필드입니다.

UDP 사용자 데이터그램 프로토콜: 트랜잭션 지향 애플리케이션을 위한 사용자 수준 프로토콜입니다.

사용자 인터넷 프로토콜의 사용자입니다. 이것은 더 높은 수준의 프로토콜 모듈, 응용 프로그램 또는 게이트웨이 프로그램일 수 있습니다.

버전 버전 필드는 인터넷 헤더의 형식을 나타냅니다.

```text
                               REFERENCES
```

\[1\] Cerf, V., "인터네트워킹을 위한 Catenet 모델," Information Processing Techniques Office, Defense Advanced Research Projects Agency, IEN 48, 1978년 7월.

\[2\] Bolt Beranek 및 Newman, "호스트와 IMP의 상호 연결에 대한 사양", BBN 기술 보고서 ​​1822, 1978년 5월 개정.

```text
[3]  Postel, J., "Internet Control Message Protocol - DARPA Internet
     Program Protocol Specification," RFC 792, USC/Information Sciences
     Institute, September 1981.
```

\[4\] Shoch, J., "Inter-Network Naming, Addressing, and Routing," COMPCON, IEEE Computer Society, 1978년 가을.

```text
[5]  Postel, J., "Address Mappings," RFC 796, USC/Information Sciences
     Institute, September 1981.
```

\[6\] Shoch, J., "네트워크 간 프로토콜의 패킷 조각화", Computer Networks, v. 3, n. 1979년 2월 1일.

\[7\] Strazisar, V., "게이트웨이 구축 방법", IEN 109, Bolt Beranek 및 Newman, 1979년 8월.

```text
[8]  Postel, J., "Service Mappings," RFC 795, USC/Information Sciences
     Institute, September 1981.

[9]  Postel, J., "Assigned Numbers," RFC 790, USC/Information Sciences
     Institute, September 1981.
```
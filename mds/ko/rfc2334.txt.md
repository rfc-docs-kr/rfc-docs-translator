

```text
Network Working Group                                         J. Luciani
Request for Comments: 2334                                  Bay Networks
Category: Standards Track                                    G. Armitage
                                                                Bellcore
                                                              J. Halpern
                                                               Newbridge
                                                            N. Doraswamy
                                                            Bay Networks
                                                              April 1998

              Server Cache Synchronization Protocol (SCSP)
```

---
# **Status of this Memo**

이 문서는 인터넷 커뮤니티를 위한 인터넷 표준 추적 프로토콜을 지정하고 개선을 위한 토론 및 제안을 요청합니다. 이 프로토콜의 표준화 상태 및 상태에 대해서는 "Internet Official Protocol Standards"\(STD 1\) 최신판을 참조하십시오. 이 메모의 배포는 무제한입니다.

---
# **Copyright Notice**

Copyright \(C\) The Internet Society \(1998\). 판권 소유.

---
# **Abstract**

이 문서는 SCSP\(Server Cache Synchronization Protocol\)에 대해 설명하고 NBMA\(Non Broadcast Multiple Access\) 네트워크 내에서 SCSP를 사용하는 관점에서 작성되었습니다. 그러나 BMA 네트워크에는 다소 간단한 사용법이 적용됩니다. SCSP는 분산 프로토콜 엔터티에 대한 일반화된 캐시 동기화/캐시 복제 문제를 해결하려고 시도합니다. 그러나 이 문서에서 SCSP는 어떤 수단을 통해 서버 그룹\(SG\)에 바인딩된 분산 서버 엔터티가 그들의 콘텐츠\(또는 그 일부\)를 동기화하고자 하는 클라이언트/서버 패러다임의 관점에서 표현됩니다. 서비스 중인 클라이언트의 상태에 대한 정보를 포함하는 캐시.

---
## **1. Introduction**

키워드 MUST, MUST NOT, REQUIRED, SHALL, SHALL NOT, SHOULD, SHOULD NOT, RECOMMENDED, MAY 및 OPTIONAL은 이 문서에 나타날 때 \[10\]에 설명된 대로 해석됩니다.\(MUST NOT\)

클라이언트/서버 패러다임에 단일 서버가 있는 것과 같은 단일 실패 지점으로 자체를 제한하지 않는 것이 모든 프로토콜의 분명한 목표일 것입니다. 중복 서버가 있는 경우에도

여전히 캐시 동기화 문제가 남아 있습니다. 즉, 한 서버가 캐시 정보의 상태 변경을 알게 되면 해당 서버는 상태 변경 정보를 해당 상태 정보를 능동적으로 미러링하는 모든 서버에 전파해야 합니다. 또한 이 작업은 서버에 과도한 리소스 부담을 주지 않고 적시에 수행되어야 합니다. 서버 캐시에 보관된 상태 정보가 서버의 클라이언트 상태라고 가정하면 클라이언트에 가해지는 부담을 최소화하기 위해 클라이언트가 사용할 수 있는 모든 서버에 대해 완전히 알 필요가 없는 것이 매우 바람직합니다. 그러나 동기화 메커니즘은 클라이언트가 여러\(또는 모든\) 서버에 액세스하는 것을 방해해서는 안 됩니다. 물론 모든 솔루션은 합리적으로 확장 가능하고 일부 자동 구성 서비스를 사용할 수 있어야 하며 광범위한 인증 방법론에 적합해야 합니다.

이 문서는 서버 캐시 동기화 프로토콜\(SCSP\)에 대해 설명합니다. SCSP는 위에서 설명한 문제를 해결하면서 일반화된 서버 동기화/캐시 복제 문제를 해결합니다. SCSP는 몇 가지 수단\(예: LIS\(Logical IP Subnet\)에 속하는 모든 NHRP 서버\[ 1\]\). 특정 서버가 사용하는 클라이언트/서버 프로토콜은 프로토콜 ID\(PID\)로 식별됩니다. SG는 당연히 SGID라고 하는 ID로 식별됩니다. 따라서 PID/SGID 조합은 SG의 서버가 동기화되는 클라이언트/서버 프로토콜과 해당 프로토콜의 인스턴스를 모두 식별합니다. 이는 동일한 프로토콜의 여러 인스턴스가 동시에 작동하고 서버가 서로 독립적으로 동기화될 수 있음을 의미합니다. 동기화해야 하는 정보 유형의 예는 IP를 사용하는 NHRP\[2\]에서 볼 수 있습니다. 정보에는 등록된 클라이언트의 IP와 SG LIS의 NBMA 매핑이 포함됩니다.

SCSP를 이해하는 가장 간단한 방법은 여기에 사용된 알고리즘이 OSPF\[3\]에서 사용된 것과 매우 유사하다는 것을 이해하는 것입니다. 실제로 독자가 SCSP의 장단점 및 안정성 측면에 대한 자세한 내용을 이해하려면 OSPF \[3\]의 Hello, Database Synchronization 및 Flooding 절차를 참조해야 합니다.

나중에 설명하는 대로 프로토콜은 세 단계를 거칩니다. 매우 짧은 첫 번째 단계는 두 장치가 서로 대화할 수 있는지 확인하는 Hello 단계입니다. 다음은 데이터베이스 동기화입니다. SCSP의 작동은 새로운 정보가 수신되는 시점까지 두 엔티티가 동일한 데이터를 사용할 수 있다고 가정합니다. 데이터베이스 동기화 단계는 이를 보장합니다.

데이터베이스 동기화에서 두 이웃은 데이터베이스의 각 항목에 대한 요약 정보를 교환합니다. 데이터베이스 자체가 잠재적으로 상당히 크기 때문에 요약이 사용됩니다. 이러한 요약을 기반으로 이웃은 서로에게 필요한 정보가 있는지 확인할 수 있습니다. 그렇다면 요청 및 제공됩니다. 따라서 이 작업 단계가 끝나면 두 이웃은 데이터베이스에 동일한 데이터를 갖게 됩니다.

그 후 엔터티는 플러딩 상태로 들어가고 유지됩니다. 플러딩 상태에서 학습된 모든 새로운 정보는 정보를 학습한 이웃\(있는 경우\)을 제외한 모든 이웃에게 전송됩니다. 이로 인해 시스템의 모든 새로운 정보가 모든 노드에 전파되어 모두가 같은 것을 알고 있는 상태로 복원됩니다. Flooding은 각 링크에서 안정적으로 수행되므로 낮은 속도의 패킷 손실 패턴이 중단을 일으키지 않습니다. \(분명히, 충분히 높은 패킷 손실률은 전체 이웃 관계를 무너뜨리지만 링크가 작동하지 않는 경우 원하는 것입니다.\)

링크가 나타날 때마다 데이터베이스 동기화 절차가 실행되기 때문에 시스템은 모든 참여 노드가 사용 가능한 모든 정보를 가지고 있음을 확실하게 보장합니다. 파티션에서 제대로 복구하고 다른 장애에 대처합니다.

SCSP 사양은 독립 실행형 프로토콜로 유용하지 않습니다. 주어진 프로토콜이 SCSP에서 제공하는 동기화 프리미티브를 사용하는 방법을 정의하는 SCSP 프로토콜 특정 사양의 사용과 결합되어야 합니다. 이러한 사양은 별도의 문서로 작성됩니다. 예: \[8\] \[9\].

---
## **2. Overview**

SCSP는 SG에 대한 토폴로지 요구 사항을 지정하지 않습니다. 그러나 분명히 결과 그래프는 동기화할 서버 집합에 걸쳐 있어야 합니다. SCSP는 링크 상태 프로토콜\[3,4\]에서 캐시 배포 메커니즘을 차용합니다. 그러나 이러한 기술과 달리 필수 SPF\(Shortest Path First\) 계산이 없으며 SCSP는 동기화 기술과 관계없이 존재하는 캐시된 정보를 저장하는 데 필요한 것 이상의 추가 메모리 요구 사항을 부과하지 않습니다.

다음 논의를 위한 참조 프레임을 제공하기 위해 로컬 서버\(LS\), 직접 연결된 서버\(DCS\) 및 원격 서버\(RS\)라는 용어를 소개합니다. LS는 감시 대상 서버입니다. 즉, 모든 진술은 SCSP 프로토콜을 논의할 때 LS의 관점에서 만들어집니다. DCS는 LS에 직접 연결된 서버입니다. 예를 들어, LS와 DCS 사이에 VC가 존재합니다. 따라서 모든 서버는 직접 연결된 다른 모든 서버의 관점에서 DCS이며 모든 서버는 0개 이상의 DCS가 직접 연결된 LS입니다. LS의 관점에서 볼 때 RS는 LS와 직접 연결되지 않은 LS와는 별개의 서버입니다\(즉, RS는 항상 LS에서 2홉 이상 떨어져 있는 반면 DCS는 항상 LS에서 1홉 떨어져 있음\). LS\).

SCSP에는 "Hello" 프로토콜, "캐시 정렬" 프로토콜 및 "캐시 상태 업데이트" 프로토콜의 세 가지 하위 프로토콜이 포함되어 있습니다. "Hello" 프로토콜은 DCS가 작동하는지 여부와 LS와 DCS 간의 연결이 양방향인지, 단방향인지 또는 비기능인지 확인하는 데 사용됩니다. "캐시 정렬"\(CA\) 프로토콜을 사용하면 LS가 전체 캐시를 DCS의 캐시와 동기화할 수 있습니다. "캐시 상태 업데이트"\(CSU\) 프로토콜은 지정된 SG에 대한 서버의 캐시 항목 상태를 업데이트하는 데 사용됩니다. 섹션 2.1, 2.2 및 2.3에는 Hello, CA 및 CSU 프로토콜과 이들이 사용하는 메시지에 대한 보다 자세한 설명이 포함되어 있습니다.

SCSP 기반 동기화는 프로토콜 인스턴스별로 수행됩니다. 즉, 주어진 상자에서 실행되는 주어진 프로토콜의 각 인스턴스에 대해 별도의 SCSP 인스턴스가 실행됩니다. 프로토콜은 프로토콜 ID를 통해 SCSP에서 식별되고 프로토콜의 인스턴스는 서버 그룹 ID\(SGID\)로 식별됩니다. 따라서 PID/SGID 쌍은 SCSP 인스턴스를 고유하게 식별합니다. 일반적으로 이것은 주어진 프로토콜의 많은 인스턴스\(분산되고 캐시 동기화가 필요함\)가 동일한 물리적 상자 내에서 실행되는 경우가 거의 없기 때문에 문제가 되지 않습니다. 그러나 이 경우 제어 측면에서 적은 실제 비용으로 유지 관리 트래픽을 크게 줄일 수 있는 Family ID\(Hello 프로토콜에 간략하게 설명됨\)라는 메커니즘이 있습니다. 가족 ID 메커니즘의 사용은 SCSP를 사용하는 주어진 프로토콜에 적합할 때 주어진 SCSP 프로토콜 특정 사양에서 완전히 정의됩니다.

```text
                       +---------------+
                       |               |
              +------->|     DOWN      |<-------+
              |        |               |        |
              |        +---------------+        |
              |            |       ^            |
              |            |       |            |
              |            |       |            |
              |            |       |            |
              |            @       |            |
              |        +---------------+        |
              |        |               |        |
              |        |    WAITING    |        |
              |     +--|               |--+     |
              |     |  +---------------+  |     |
              |     |    ^           ^    |     |
              |     |    |           |    |     |
              |     @    |           |    @     |
            +---------------+     +---------------+
            | BIDIRECTIONAL |---->| UNIDIRECTIONAL|
            |               |     |               |
            |  CONNECTION   |<----|  CONNECTION   |
            +---------------+     +---------------+

          Figure 1: Hello Finite State Machine (HFSM)
```

---
## **2.1  Hello Protocol**

"Hello" 메시지는 DCS가 작동하는지 여부와 LS와 DCS 간의 연결이 양방향인지, 단방향인지 또는 비기능인지 확인하는 데 사용됩니다. 이를 위해 모든 LS는 주기적으로 Hello 메시지를 DCS에 보내야 합니다.\(MUST\)

LS는 SCSP를 실행하기 위해 LS가 직접 연결하려는 SG의 피어 서버 주소를 나타내는 NBMA 주소 목록으로 구성되어야 합니다. 즉, 이러한 주소는 DCS가 될 주소입니다. 이러한 NBMA 주소로 LS를 구성하는 메커니즘은 이 문서의 범위를 벗어납니다. 가능한 메커니즘 중 하나는 자동 구성 서버입니다.

LS에는 지정된 SG에 대한 각 DCS\(그림 1 참조\)와 연결된 HFSM\(Hello Finite State Machine\)이 있으며 HFSM은 서버 간의 연결 상태를 모니터링합니다.

HFSM은 "다운" 상태에서 시작하여 NBMA 레벨 연결이 설정된 후 "대기" 상태로 전환됩니다. 대기 상태가 되면 LS는 Hello 메시지를 DCS로 보내기 시작합니다. Hello 메시지는 다음을 포함합니다: LS의 ID\(LSID\)로 설정된 Sender ID, LS가 최근에 Hello 메시지를 들은 DCS를 식별하는 0개 이상의 수신자 ID\(아래 설명됨\) 및 HelloInterval 및 DeadFactor 아래에서 설명합니다. 이 시점에서 DCS는 자체 Hello 메시지를 LS에 이미 전송 중일 수도 있고 아닐 수도 있습니다.

LS가 DCS 중 하나로부터 Hello 메시지를 수신하면 LS는 LSID가 방금 수신한 해당 메시지의 수신자 ID 필드 중 하나에 있는지 확인하고 LS는 해당 Hello 메시지의 발신자 ID를 저장합니다. LSID가 수신기 ID 필드 중 하나에 있으면 LS는 HFSM을 양방향 연결 상태로 전환하고 그렇지 않으면 HFSM을 단방향 연결 상태로 전환합니다. 저장된 Sender ID는 DCS의 ID\(DCSID\)입니다. 다음에 LS가 자신의 Hello 메시지를 DCS로 보내기 전에 LS는 LS 자신의 Hello 메시지를 보낼 때 LS가 사용하는 수신자 ID 목록에 대해 저장된 DCSID를 확인합니다. 수신자 ID 목록에서 DCSID를 찾을 수 없으면 LS가 Hello 메시지를 보내기 전에 DCSID가 해당 목록에 추가됩니다.

Hello 메시지에는 HelloInterval 및 DeadFactor도 포함됩니다. Hello 간격은 "현재" Hello 메시지를 보내는 서버에서 연속적인 Hello 메시지를 보내는 시간\(초\)을 알립니다. 즉, DCS로부터 Hello 메시지 수신 사이의 시간이 해당 DCS에 의해 광고된 HelloInterval을 초과하면 다음 Hello 메시지는 LS에서 늦은 것으로 간주됩니다. LS가 수신자 ID 필드 중 하나에 LS의 LSID를 포함하는 Hello 메시지를 HelloInterval\*DeadFactor 초 간격\(이전 Hello 메시지에서 DCS에 의해 DeadFactor가 광고된 경우\) 내에 수신하지 않으면 LS는 다음을 고려해야 합니다. DCS가 중단됩니다. 이 시점에서 두 가지 중 하나가 발생합니다. 1\) 마지막 HelloInterval\*DeadFactor 초 동안 Hello 메시지가 수신된 경우 LS는 해당 DCS에 대한 HFSM을 단방향 연결 상태로 전환해야 합니다. 그렇지 않으면 LS는 해당 DCS에 대한 HFSM을 대기 상태로 전환하고 수신기 ID 목록에서 DCSID를 제거해야 합니다.\(MUST\)

Hello 프로토콜은 PID/SGID 기준입니다. 따라서 예를 들어 NBMA 주소 X와 연결된 두 개의 서버\(하나는 SGA A에, 다른 하나는 SG B에 있음\)와 NBMA 주소 Y와 연결된 다른 두 개의 서버\(SGA A에 하나, SG B에 다른 하나\)가 있는 경우 NBMA 주소 사이에 적절한 점대점 VC가 있고 VC의 각 측면에서 실행 중인 두 개의 HFSM이 있습니다\(PID/SGID당 하나\).

Hello 메시지에는 지점 간 연결을 사용하기 위해 단일 수신기 ID 대신 수신기 ID 목록이 포함됩니다. DCS당 HFSM이 있는 동안 LS는 점 대 다점 연결의 리프로 연결된 DCS에 단일 Hello 메시지만 보내야 합니다. LS는 LS가 다음 Hello 메시지를 보낼 때 수신자 ID 목록에 DCSID를 포함하여 이를 수행합니다. LS가 Hello 메시지를 들은 정지되지 않은 DCS의 DCSID만 포함됩니다.\(MUST\)

잘못된 SCSP 메시지 수신과 같은 비정상적인 이벤트로 인해 HFSM이 대기 상태로 전환됩니다. 그러나 NBMA 연결이 끊어지면 HFSM이 다운 상태로 전환됩니다. HFSM이 양방향 연결 상태에 있을 때까지 Hello 메시지 이외의 적절하게 구성된 SCSP 메시지가 수신되면 해당 메시지를 무시해야 합니다\(예를 들어, 포인트 투 멀티포인트 연결이 포함된 경우\).\(MUST\)

```text
                   +------------+
                   |            |
              +--->|    DOWN    |
              |    |            |
              |    +------------+
              |          |
              ^          |
              |          @
              |    +------------+
              |    |Master/Slave|
              |-<--|            |<---+
              |    |Negotiation |    |
              |    +------------+    |
              |          |           |
              ^          |           ^
              |          @           |
              |    +------------+    |
              |    |   Cache    |    |
              |-<--|            |-->-|
              |    | Summarize  |    |
              |    +------------+    |
              |          |           |
              ^          |           ^
              |          @           |
              |    +------------+    |
              |    |   Update   |    |
              |-<--|            |-->-|
              |    |   Cache    |    |
              |    +------------+    |
              |          |           |
              ^          |           ^
              |          @           |
              |    +------------+    |
              |    |            |    |
              +-<--|  Aligned   |-->-+
                   |            |
                   +------------+

     Figure 2: Cache Alignment Finite State Machine
```

---
## **2.2 Cache Alignment Protocol**

"캐시 정렬"\(CA\) 메시지는 LS에서 캐시를 각 DCS의 캐시와 동기화하는 데 사용됩니다. 즉, CA 메시지는 부팅 LS가 각 DCS와 동기화할 수 있도록 합니다. CA 메시지에는 0개 이상의 CSAS 레코드\(Cache State Advertisement Summary 레코드\)가 뒤따르는 CA 헤더가 포함됩니다.

LS에는 PID/SGID별로 각 DCS와 연결된 CAFSM\(Cache Alignment Finite State Machine\)이 있으며\(그림 2 참조\) CAFSM은 서버 간의 캐시 정렬 상태를 모니터링합니다. CAFSM은 다운 상태에서 시작됩니다. CAFSM은 HFSM과 연관되어 있으며 해당 HFSM이 양방향 상태에 도달하면 CAFSM은 마스터/슬레이브 협상 상태로 전환됩니다. 마스터/슬레이브 협상 상태는 LS 또는 DCS가 캐시 정렬 프로세스에 대한 마스터 역할을 맡도록 합니다. 어떤 의미에서 마스터 서버는 캐시 정렬을 위한 템포를 설정합니다.

LS의 CAFSM이 마스터/슬레이브 협상 상태에 도달하면 LS는 CA 메시지를 CAFSM과 연결된 DCS로 보냅니다. CA 메시지의 형식은 섹션 B.2.1에 설명되어 있습니다. LS가 전송하는 첫 번째 CA 메시지에는 CSAS 레코드가 없으며 Sender ID 필드의 LSID, Receiver ID 필드의 DCSID, CA 시퀀스 번호 및 3비트를 포함하는 CA 헤더가 포함됩니다. 이 세 비트는 M\(마스터/슬레이브\) 비트, I\(마스터 초기화\) 비트 및 O\(자세히\) 비트입니다. LS가 특정 DCS로 보낸 첫 번째 CA 메시지에서 M, O 및 I 비트는 1로 설정됩니다. LS가 CAReXmtInterval 초 내에 DCS로부터 CA 메시지를 받지 못하면 방금 보낸 CA 메시지를 다시 보냅니다. LS는 CAFSM이 캐시 요약 상태로 전환되거나 HFSM이 양방향 상태에서 전환될 때까지 이 작업을 계속합니다. HFSM이 양방향 상태에서 전환될 때마다 CAFSM은 다운 상태로 전환됩니다.

---
### **2.2.1 Master Slave Negotiation State**

LS가 마스터/슬레이브 협상 상태에 있는 동안 DCS로부터 CA 메시지를 수신하면 교환에서 LS가 수행하는 역할은 다음과 같이 패킷 처리에 따라 달라집니다.

1\) DCS의 CA가 M, I, O 비트를 1로 설정하고 CA 메시지에 CSAS 레코드가 없고 DCS의 CA 메시지에 지정된 발신자 ID가 LSID보다 큰 경우

```text
     a) The timer counting down the CAReXmtInterval is stopped.
     b) The CAFSM corresponding to that DCS transitions to the
        Cache Summarize    State and the LS takes on the role of slave.
     c) The LS adopts the CA sequence number it received in the CA
        message as its own CA sequence number.
     d) The LS sends a CA message to the DCS which is formated as
        follows: the M and I bits are set to zero, the Sender ID field
        is set to the LSID, the Receiver ID field is set to the DCSID,
        and the CA sequence number is set to the CA sequence number that
        appeared in the DCS's CA message.  If there are CSAS records to
        be sent (i.e., if the LS's cache is not empty), and if all of
        them will not fit into this CA message then the O bit is set to
```

- CSAS 레코드의 초기 세트와 하나가 CA 메시지에 포함됩니다. 그렇지 않으면 O 비트가 0으로 설정되고 CSAS 레코드를 보내야 하는 경우 해당 레코드가 CA 메시지에 포함됩니다.

2\) DCS의 CA 메시지에서 M 및 I 비트가 꺼져 있고 DCS의 CA 메시지에 지정된 발신자 ID가 LSID보다 작은 경우

a\) CAReXmtInterval을 카운트다운하는 타이머가 중지됩니다. b\) 해당 DCS에 해당하는 CAFSM은 Cache Summarize State로 전환되고 LS가 마스터 역할을 맡습니다. c\) LS는 수신된 CA 메시지를 처리해야 합니다. CA 메시지 처리에 대한 설명은 다음과 같습니다. d\) LS는 다음과 같은 형식의 CA 메시지를 DCS로 보냅니다. DCSID 및 LS의 현재 CA 시퀀스 번호는 1씩 증가하여 CA 메시지에 배치됩니다. LS에서 DCS로 보낼 CSAS 레코드가 있는 경우\(즉, LS의 캐시가 비어 있지 않은 경우\) O 비트는 1로 설정되고 CSAS 레코드의 초기 세트는 LS가 DCS로 보내고 있습니다.

3\) 그렇지 않으면 패킷을 무시해야 합니다.

---
### **2.2.2 The Cache Summarize State**

주어진 시간에 마스터 또는 슬레이브는 기껏해야 하나의 미해결 CA 메시지를 가집니다. LS의 CAFSM이 캐시 요약 상태로 전환되면 CA 메시지 교환 순서는 다음과 같이 발생합니다.

1\) LS가 M 비트가 잘못 설정된 CA 메시지를 수신하거나\(예: M 비트가 DCS의 CA에 설정되고 LS가 마스터임\) I 비트가 설정된 경우 CAFSM은 다시 마스터로 전환됩니다. /슬레이브 협상 상태.

2\) LS가 마스터이고 LS가 LS의 현재 CA 시퀀스 번호보다 하나 작은 CA 시퀀스 번호를 가진 CA 메시지를 수신하면 메시지는 중복되며 메시지는 폐기되어야 합니다.\(MUST\)

3\) LS가 마스터이고 LS가 LS의 현재 CA 시퀀스 번호와 동일한 CA 시퀀스 번호를 가진 CA 메시지를 수신하면 CA 메시지를 처리해야 합니다. "CA 메시지 처리"에 대한 설명은 다음과 같습니다. DCS로부터 CA 메시지를 수신한 결과로 다음이 발생합니다.\(MUST\)

a\) CAReXmtInterval을 카운트다운하는 타이머가 중지됩니다. b\) LS는 수신된 CA 메시지의 모든 CSAS 레코드를 처리해야 합니다. c\) LS의 CA 시퀀스 번호를 1씩 증가시킵니다. d\) 캐시 교환은 다음과 같이 계속됩니다.

- 1\) LS에 더 이상 보낼 CSAS 레코드가 없고 수신된 CA 메시지에 O 비트가 꺼져 있으면 CAFSM은 캐시 업데이트 상태로 전환합니다. 2\) LS에 더 이상 보낼 CSAS 레코드가 없고 수신된 CA 메시지에 O 비트가 켜져 있으면 LS는 CSAS 레코드가 없고 O 비트가 꺼져 있는 CA 메시지\(새 CA 시퀀스 번호 포함\)를 다시 보냅니다. CAReXmtInterval을 카운트다운하는 타이머를 재설정합니다. 3\) LS에 전송할 CSAS 레코드가 더 있는 경우 LS는 LS의 다음 CSAS 레코드 세트와 함께 다음 CA 메시지를 전송합니다. LS가 CSAS 레코드의 마지막 세트를 보내는 경우 O 비트가 꺼지고 그렇지 않으면 O 비트가 켜집니다. CAReXmtInterval을 카운트다운하는 타이머를 재설정합니다.

4\) LS가 슬레이브이고 LS가 LS의 현재 CA 시퀀스 번호와 동일한 CA 시퀀스 번호를 가진 CA 메시지를 수신하면 CA 메시지는 중복되며 LS는 방금 보낸 CA 메시지를 다시 보내야 합니다. DCS.\(MUST\)

5\) LS가 슬레이브이고 LS가 LS의 현재 CA 시퀀스 번호보다 하나 더 큰 CA 시퀀스 번호를 가진 CA 메시지를 수신하면 메시지는 유효하며 처리되어야 합니다. "CA 메시지 처리"에 대한 설명은 다음과 같습니다. DCS로부터 CA 메시지를 수신한 결과로 다음이 발생합니다.\(MUST\)

a\) LS는 수신된 CA 메시지의 모든 CSAS 레코드를 처리해야 합니다. b\) LS의 CA 시퀀스 번호를 CA 메시지의 CA 시퀀스 번호로 설정합니다. c\) 캐시 교환은 다음과 같이 계속됩니다.

- 1\) LS가 방금 O 비트가 꺼진 CA 메시지를 보냈고 수신된 CA 메시지의 O 비트가 꺼진 경우 CAFSM은 업데이트 캐시 상태로 전환하고 LS는 CSAS 레코드가 없는 CA 메시지를 보냅니다. 오 비트 오프. 2\) LS에 보낼 CSAS 레코드가 여전히 있는 경우 LS는 CSAS 레코드가 포함된 CA 메시지를 보내야 합니다.\(MUST\)

- a\) LS에서 DCS로 전송되는 메시지에 LS가 전송해야 하는 마지막 CSAS 레코드가 포함되어 있지 않으면 CA 메시지는 O 비트가 켜진 상태로 전송됩니다. b\) LS에서 DCS로 전송되는 메시지에 LS가 필요로 하는 마지막 CSAS 레코드가 포함되어 있는 경우

- 전송하고 DCS에서 방금 수신한 CA 메시지의 O 비트가 꺼져 있는 경우 CA 메시지는 O 비트가 꺼진 상태로 전송되고 LS는 CAFSM을 업데이트 캐시 상태로 전환합니다. c\) LS에서 DCS로 전송되는 메시지에 LS가 전송해야 하는 마지막 CSAS 레코드가 포함되어 있고 DCS에서 방금 수신한 CA 메시지에 O 비트가 켜져 있는 경우 CA 메시지는 O 비트가 꺼진 상태로 전송됩니다. 정렬 프로세스가 계속됩니다.

6\) LS가 슬레이브이고 LS가 현재 LS의 CA 시퀀스 번호와 같지도 않고 하나 더 크지도 않은 CA 시퀀스 번호를 가진 CA 메시지를 수신하면 오류가 발생하고 CAFSM은 마스터/슬레이브 협상 상태로 전환됩니다. .

CA 프로세스 동안 LS가 슬레이브인 경우 CAFSM을 업데이트 캐시 상태로 전환할 때 LS는 보낸 마지막 CA 메시지의 복사본을 유지해야 하며 LS는 타이머를 CAReXmtInterval과 동일하게 설정해야 합니다. 타이머가 만료되거나 LS가 DCS로부터 CSUS\(CSU Solicit\) 메시지\(CSUS 메시지는 섹션 2.2.3에 설명됨\)를 수신하면 LS는 CA 메시지의 복사본을 해제합니다. 그 이유는 DCS\(마스터\)가 LS가 보낸 마지막 CA 메시지를 잃어버리면 DCS가 마지막 CA 시퀀스 번호를 사용하여 이전 CA 메시지를 다시 보낼 것이기 때문입니다. 그런 일이 발생한다면 LS는 마지막으로 보낸 CA 메시지도 다시 보내야 합니다.\(MUST\)

---
#### **2.2.2.1 "CA message processing":**

LS는 LS 자신의 캐시보다 DCS에서 더 "최신"인 캐시 항목 목록을 만듭니다. 이 목록을 CSA 요청 목록\(CRL\)이라고 합니다. CSA\(클라이언트 상태 광고\) 레코드 또는 CSAS 레코드가 LS의 캐시 항목보다 더 "최신"이라는 의미에 대한 설명은 섹션 2.4를 참조하십시오.

---
### **2.2.3 The Update Cache State**

업데이트 캐시 상태로 전환할 때 LS의 관련 CAFSM의 CRL이 비어 있으면 CAFSM은 즉시 정렬 상태로 전환됩니다.

업데이트 캐시 상태로 전환할 때 CRL이 비어 있지 않으면 LS는 LS가 CRL에 보유하고 있는 요약\(즉, CSAS 레코드\)에 해당하는 CSA 레코드를 보내도록 DCS에 요청합니다. 요청된 CSA 레코드에는 지정된 캐시 항목에 대해 DCS의 캐시에 보관된 캐시된 정보 전체가 포함됩니다. LS는 CRL에서 CSU 요청\(CSUS\) 메시지를 구성하여 관련 CSA 레코드를 요청합니다. CSUS 메시지 형식에 대한 설명은 섹션 B.2.4를 참조하십시오. 그런 다음 LS는 CSUS 메시지를 DCS로 보냅니다. DCS는 하나 이상의 LS에 전송하여 CSUS 메시지에 응답합니다.

CSUS 메시지에서 식별된 최신 캐시 정보 전체를 포함하는 CSU 요청 메시지. CSU 요청을 수신하면 LS는 섹션 2.3에 설명된 대로 하나 이상의 CSU 응답을 보냅니다. LS에는 주어진 시간에 최대 하나의 CSUS 메시지가 있을 수 있습니다.

첫 번째 CSUS 메시지가 LS에서 CAFSM과 관련된 DCS로 전송되기 직전에 타이머가 CSUSReXmtInterval 초로 설정됩니다. CSUS 메시지의 CSAS 레코드에 해당하는 모든 CSA 레코드가 타이머가 만료될 때까지 수신되지 않으면 적절한 CSA 레코드가 수신되지 않은 모든 CSAS 레코드와 추가 추가 정보를 포함하는 새로운 CSUS 메시지가 생성됩니다. 이전 CSUS 메시지에서 다루지 않은 CSAS 레코드입니다. 그런 다음 새 CSUS 메시지가 DCS로 전송됩니다. 타이머가 만료되기 전 어느 시점에서 이전에 전송된 CSUS 메시지에 포함된 모든 CSAS 레코드에 대한 모든 CSA 레코드 업데이트가 수신되면 타이머가 중지됩니다. 타이머가 중지되면 이전 CSUS 메시지에 포함되지 않았지만 CRL에 있던 추가 CSAS 레코드가 있는 경우 타이머가 재설정되고 CRL에서 포함되지 않은 CSAS 레코드만 포함하는 새 CSAS 메시지가 생성됩니다. 아직 DCS로 보내지지 않았습니다. 이 프로세스는 모든 CSA 레코드가 CRL에 있던 해당 CSAS 레코드를 LS에서 수신할 때까지 계속됩니다. LS에 완전히 업데이트된 캐시가 있으면 LS는 DCS와 연결된 CAFSM을 Aligned State로 전환합니다.

LS가 LS의 LSID가 아닌 수신자 ID를 가진 CSUS 메시지 또는 CA 메시지를 수신하면 메시지를 버리고 무시해야 합니다. 이는 LS가 SG의 다른 서버와의 지점 대 다중 지점 연결의 리프일 수 있기 때문에 필요합니다.

---
### **2.2.4 The Aligned State**

정렬 상태에 있는 동안 LS는 섹션 2.3에 설명된 대로 캐시 상태 업데이트 프로토콜을 수행합니다.

LS는 Aligned State에 있는 동안 CSUS 메시지를 수신할 수 있으며 LS는 섹션 2.2.3에서 이전에 설명한 방법과 유사한 방식으로 적절한 CSU 요청 메시지로 CSUS 메시지에 응답해야 합니다.\(MUST\)

---
## **2.3 Cache State Update Protocol**

"캐시 상태 업데이트"\(CSU\) 메시지는 주어진 PID/SGID 기준으로 서버의 캐시 항목 상태를 동적으로 업데이트하는 데 사용됩니다. CSU 메시지에는 0개 이상의 "캐시 상태 광고"\(CSA\) 레코드가 포함되며 각 레코드에는 특정 캐시 항목의 상태에 대한 자체 스냅샷이 포함됩니다. LS는 DCS와 CSU를 송수신할 수 있습니다.

해당 CAFSM이 Aligned State 또는 Update Cache State에 있을 때만 가능합니다.

CSU 메시지에는 CSU 요청 및 CSU 응답의 두 가지 유형이 있습니다. 메시지 형식에 대해서는 섹션 B.2.2 및 B.2.3을 각각 참조하십시오. CSU 요청 메시지는 다음 두 가지 이유 중 하나로 LS에서 하나 이상의 DCS로 전송됩니다. LS가 CSUS 메시지를 수신하고 CSUS 메시지를 발신한 DCS에만 응답해야 하거나 LS가 변경 사항을 인식하게 된 경우 캐시 항목의 상태. LS는 DCS 중 하나로부터 CSU 요청을 수신하거나 LS에서 시작된 캐시된 항목에서 관찰되는 상태 변경의 결과로 캐시 항목의 상태 변경을 인식하게 됩니다. 전자의 경우 LS는 LS가 상태 변경을 알게 된 DCS를 제외한 각 DCS에 CSU 요청을 보냅니다. 후자의 경우 LS는 각 DCS에 CSU 요청을 보냅니다. 특정 캐시 항목의 상태 변경은 CSU 요청 메시지 필수 부분의 끝에 추가되는 CSA 레코드에 기록됩니다. 이러한 방식으로 상태 변경이 SG 전체에 전파됩니다.\(MUST\)

이러한 상태 변경의 예는 다음과 같습니다.

- 1\) 서버가 클라이언트로부터 항목을 캐시에 추가하라는 요청을 수신함, 2\) 서버가 클라이언트로부터 항목을 캐시에서 제거하라는 요청을 수신함, 3\) 캐시 항목이 서버 캐시에서 시간 초과됨, 서버의 캐시에서 새로 고쳐졌거나 관리상 수정되었습니다.

LS가 DCS 중 하나로부터 CSU 요청을 수신하면 LS는 CSU 응답을 전송하여 CSU 요청에 포함된 하나 이상의 CSA 레코드를 승인합니다. CSU 응답에는 확인 중인 CSA 레코드에 해당하는 하나 이상의 CSAS 레코드가 포함되어 있습니다. 따라서, 예를 들어 CSA 레코드를 처리할 리소스가 부족하여 LS에 의해 CSA 레코드가 삭제\(또는 처리 지연\)되면 해당 CSAS 레코드는 DCS에 대한 CSU 응답에 포함되지 않습니다.

LS는 CSU 요청에 포함된 CSA 레코드를 승인하는 CSU 응답을 수신하기 전에 여러 CSU 요청 메시지를 보낼 수 있습니다. 또한 CSU 응답에는 여러 CSU 요청의 CSA 레코드에 대한 승인이 포함될 수 있습니다. 따라서 "요청"과 "회신"이라는 용어는 다소 혼동될 수 있습니다.

CSA 레코드에는 캐시 항목에 포함된 클라이언트/서버 프로토콜 특정 정보가 뒤따르는 CSAS 레코드가 포함되어 있습니다\(CSAS 레코드 형식 정보 및

CSA 레코드 형식 정보는 섹션 B.2.2.1 참조\). CSA 레코드가 LS의 캐시 내에 포함된 캐시된 정보보다 더 "최신"\(섹션 2.4 참조\)인 캐시된 정보를 나타내는 것으로 LS에 의해 간주되면 두 가지 일이 발생합니다. 1\) LS의 캐시가 다음으로 업데이트됩니다. 2\) LS는 CSA 레코드가 도착한 DCS를 제외한 각 DCS에 CSA 레코드가 포함된 CSU 요청을 보냅니다. 이러한 방식으로 상태 변경은 PID/SGID 내에서 전파됩니다. 물론 어느 시점에서 LS는 적절한 DCS에 해당 CSAS 레코드가 포함된 CSU 응답 메시지를 보냄으로써 CSA 레코드의 수신을 확인합니다.

LS가 새 CSU 요청을 보낼 때 LS는 해당 CSU 요청의 미해결 CSA 레코드와 LS가 CSU 요청을 보낸 DCS를 추적합니다. CSU 요청이 전송된 각 DCS에 대해 CSUReXmtInterval 초로 설정된 타이머는 CSU 요청을 전송하기 직전에 시작됩니다. 이 타이머는 해당 DCS로부터 모든 CSA 레코드가 승인되기 전에 타이머가 만료되면 \(그리고 오직 그때에만\) CSU 요청이 LS에 의해 해당 DCS로 재전송되도록 해당 CSU 요청에 포함된 CSA 레코드와 연관됩니다. 그러나 재전송된 CSU 요청에는 아직 승인되지 않은 CSA 레코드만 포함됩니다. 타이머와 관련된 모든 CSA 레코드가 확인되면 타이머가 중지됩니다. 재전송된 CSA 레코드는 새 레코드인 것처럼 동일한 시간 제한 및 재전송 규칙을 따릅니다. 재전송은 지정된 CSA 레코드에 대해 구성된 횟수만큼 발생하며 승인이 발생하지 않으면 DCS와 연결된 HFSM이 대기 상태로 전환되는 시점에서 "비정상적인 이벤트"가 발생한 것입니다.

CSA 레코드 인스턴스는 이전에 언급한 타이머와 연결될 때 "DCS 재전송 대기열"에 있다고 합니다. 최신 CSA 레코드만 지정된 DCS 재전송 대기열에 대기할 수 있습니다. 따라서 최신 CSA 레코드 인스턴스가 해당 DCS 재전송 대기열에 대기하려고 할 때 최신 CSA 레코드가 DCS 재전송 대기열에 대기 중인 경우 이전 CSA 레코드 인스턴스는 대기열에서 제외되고 직전에 해당 타이머와 연결 해제됩니다. CSA 레코드의 최신 인스턴스를 대기열에 넣습니다.

LS가 DCS 중 하나로부터 CSU 응답을 수신하면 LS는 DCS 재전송 대기열에 대기 중인 CSA 레코드의 CSAS 레코드 부분에 대해 CSU 응답의 각 CSAS 레코드를 확인합니다.

1\) CSA 레코드의 CSAS 레코드 부분과 CSU 응답의 CSAS 레코드 간에 정확히 일치하는 항목이 있는 경우 해당 CSA 레코드는 승인된 것으로 간주되어 DCS 재전송 대기열에서 제외되고 해당 타이머와 연결이 해제됩니다.

2\) CSAS 레코드 부분이 일치하는 경우

- CSA 시퀀스 번호를 제외한 CSA 응답의 CSA 레코드 및 CSAS 레코드 중

- a\) DCS 재전송 대기열에 대기 중인 CSA 레코드에 CSU 응답의 CSAS 레코드에 있는 CSA 시퀀스 번호보다 큰 CSA 시퀀스 번호가 있으면 CSU 응답에 있는 CSAS 레코드는 무시됩니다. b\) DCS 재전송 대기열에 대기 중인 CSA 레코드의 CSA 시퀀스 번호가 CSU 응답의 CSAS 레코드에 있는 CSA 시퀀스 번호보다 작은 경우 DCS 재전송 대기열에 대기 중인 CSA 레코드는 대기열에서 제거되고 CSA는 레코드와 타이머의 연결이 해제됩니다. 또한 최신 CSAS 레코드를 보낸 DCS에 CSUS 메시지가 전송됩니다. 모든 일반 CSUS 처리는 CSUS가 CA 프로토콜의 일부로 전송된 것처럼 발생합니다.

LS가 캐싱된 CSA의 CSA 시퀀스 번호보다 작은 CSA 시퀀스 번호를 포함하는 CSA 레코드를 포함하는 CSU 요청 메시지를 수신하면 LS는 CSU 요청의 CSA 레코드를 확인 응답해야 하지만 다음을 보내서 확인해야 합니다. CSU 요청에 포함된 CSA 레코드의 CSAS 레코드 부분이 아니라 캐시에 저장된 CSA 레코드의 CSAS 레코드 부분을 포함하는 CSU 응답 메시지.\(MUST\)

LS는 적절한 CSA 레코드를 포함하는 CSU 요청 메시지를 DCS로 보냄으로써 DCS의 CSUS 메시지에 응답합니다. LS가 더 이상 데이터베이스에 없는 항목에 대한 CSAS 레코드를 포함하는 CSUS 메시지를 수신하는 경우\(예: 항목이 시간 초과되어 캐시 정렬 교환이 완료된 후 항목이 CSUS 메시지를 통해 요청되기 전에 폐기됨\) LS는 CSUS 메시지의 CSAS 레코드를 CSU 요청 메시지로 복사하여 응답하고 LS는 캐시 항목이 LS의 캐시에 더 이상 존재하지 않기 때문에 이 레코드가 NULL 레코드임을 나타내는 N 비트를 설정합니다. 이 경우 NULL 캐시 항목을 나타내기 위해 CSU 요청에 포함된 "CSA 레코드"는 캐시 항목에 대한 클라이언트/서버 프로토콜 특정 정보가 존재하지 않기 때문에 말 그대로 CSAS 레코드일 뿐입니다.

LS가 해당 DCS의 DCS 재전송 대기열에 게시된 동일한 CSA 레코드가 있는 DCS로부터 CSU 요청의 CSA 레코드를 수신하는 경우 DCS 재전송 대기열의 CSA 레코드는 암시적으로 승인된 것으로 간주됩니다. 따라서 CSA 레코드는 DCS 재전송 대기열에서 제외되고 해당 타이머와의 연결이 해제됩니다. 그러나 DCS가 보낸 CSA 레코드는 CSU 응답에서 LS에 의해 승인되어야 합니다. 이것은 포인트의 경우에 유용합니다.\(MUST\)

"LS가 DCS로부터 CSA 레코드를 수신할 때 해당 LS는 수신한 DCS를 제외한 모든 DCS에 CSA 레코드를 플러딩한다"는 규칙이 깨질 수 있는 다지점 연결에 적용됩니다.

LS가 LSID와 같지 않고 모두 0xFF로 설정되지 않은 수신기 ID를 가진 CSU를 수신하면 CSU는 폐기되고 무시되어야 합니다. 이는 LS가 LS의 SG에 있는 다른 서버와의 지점 대 다지점 연결의 리프일 수 있기 때문에 필요합니다.

LS는 DCS 집합과의 지점 대 다중 지점 연결의 루트일 때 모든 0xFF 수신기 ID에 CSU 요청을 보낼 수 있습니다. LS가 수신자 ID가 모두 0xFF인 CSU 요청을 수신하면 응답 시 CSU 요청의 발신자 ID를 CSU 응답의 수신자 ID로 사용해야 합니다\(즉, 응답을 요청 발신자에게 유니캐스트해야 함\). LS가 모든 0xFF 수신자 ID에 CSU 요청을 보내려는 경우 CSU 요청을 보내기 전에 점 대 다점 연결의 잎사귀인 각 DCS에 대해 타임아웃 및 재전송 타이머를 생성해야 합니다. 이 경우 주어진 CSA 레코드를 승인하기 전에 주어진 DCS에 대한 타임아웃 및 재전송 타이머가 만료되면 LS는 모든 0xFFs 수신기 ID가 아닌 특정 DCSID를 수신기 ID로 사용해야 합니다. 마찬가지로 CSA 레코드를 다시 보내야 하는 경우 LS는 모든 0xFFs 수신기 ID가 아닌 특정 DCSID를 수신기 ID로 지정해야 합니다.\(MAY, MUST, MUST, MUST, MUST\)

서버 세트가 지점 대 다 지점 연결의 전체 메시에 있고 해당 메시의 한 서버가 CSU 요청을 해당 전체 메시로 보내고 보내는 서버는 CSU 요청의 CSA 레코드를 모든 0xFFs 수신기로 보냅니다. 그러면 메시에 있는 다른 모든 서버가 CSA 레코드를 적절하게 플러딩하기 위해 해당 CSA 레코드를 포함하는 자체 CSU 요청을 메시에 소싱할 필요가 없습니다. 메시의 모든 서버가 CSU 요청을 듣고 포함된 CSA 레코드를 적절하게 처리했기 때문입니다. 따라서 전체 메시의 서버는 메시를 단일 논리 포트로 간주할 수 있으므로 "LS가 DCS로부터 CSA 레코드를 수신하면 해당 LS는 CSA 레코드를 DCS를 제외한 모든 DCS로 플러딩합니다. 받았습니다"가 깨지지 않았습니다. 풀 메시의 수신 서버는 응답 서버의 LSID를 발신자 ID로 포함하고 CSU 요청을 수신자 ID 필드로 보낸 서버의 ID를 포함하는 CSU 응답 메시지로 CSA 레코드를 승인해야 합니다. 시간 초과 및 재전송 사례에서 CSU 요청의 수신자 ID는 CSA 레코드를 승인하지 않은 특정 DCSID로 설정됩니다\(모든 0xFFs 수신자 ID와 반대\). 풀 메시는 풀 메시에 연결된 서버의 브로드캐스트 미디어를 에뮬레이션하므로 브로드캐스트 미디어에서 SCSP를 사용하는 경우에도 이 기술을 사용할 수 있습니다. 풀 메시 사용 또는 브로드캐스트 미디어 사용에 대한 추가 논의는 클라이언트/서버 프로토콜에 맡겨집니다.

```text
   specific documents.
```

---
## **2.4 The meaning of "More Up To Date"/"Newness"**

캐시 정렬 프로세스 및 일반 CSU 처리 중에 CSAS 레코드는 레코드에 포함된 정보가 LS의 해당 캐시 항목보다 "최신"인지 여부를 결정하기 위해 LS의 캐시 항목 내용과 비교됩니다.

레코드가 레코드를 처리하는 LS의 캐시 항목에 포함된 정보보다 "최신" 정보를 포함하는지 여부를 결정하는 데 사용되는 세 가지 정보가 있습니다. 1\) 캐시 키, 2\) 발신자 ID\(OID\) 및 3\) CSA 시퀀스 번호로 설명되는 발신자. 이러한 필드에 대한 자세한 내용은 섹션 B.2.0.2를 참조하십시오.

이러한 세 가지 정보가 주어지면 CSAS 레코드\(CSA 레코드의 일부이거나 독립 실행형\)는 다음이 모두 충족되는 경우 LS 캐시에 포함된 정보보다 더 "최신"인 것으로 간주됩니다. 사실:

1\) CSAS 레코드의 캐시 키가 LS의 캐시 항목에 저장된 캐시 키와 일치합니다. 2\) CSAS 레코드의 OID가 LS의 캐시 항목에 저장된 OID와 일치합니다. 3\) CSAS 레코드의 CSA 시퀀스 번호가 더 큽니다. LS의 캐시 항목에 있는 CSA 시퀀스 번호보다

---
# **Discussion and Conclusions**

위의 텍스트는 SG에 포함된 서버의 캐시 내에서 클라이언트 상태 지식을 동기화하는 측면에서 표현되지만 이 솔루션은 여러 데이터베이스 동기화 문제\(예: LECS 동기화\)에 대해 쉽게 일반화됩니다.

SCSP는 일반적인 플러딩 프로토콜을 정의합니다. 클라이언트/서버 프로토콜 특정 문서에 더 적절하게 정의된 캐시 유지 관리 및 토폴로지 유지 관리와 관련된 여러 관련 문제가 있습니다. 예를 들어 SG에 있는 서버의 토포맵을 얻을 수 있도록 주어진 프로토콜에 대한 일반 캐시 항목 시간 초과 메커니즘을 정의하거나 서버 간에 인접성 정보를 알리는 것이 바람직할 수 있습니다. 이와 같은 메커니즘이 바람직한 경우 클라이언트/서버 프로토콜 특정 문서에 정의됩니다.

---
# **Appendix A: Terminology and Definitions**

CA 메시지 - 캐시 정렬 메시지 이 메시지를 통해 LS는 전체 캐시를 해당 DCS 중 하나의 캐시와 동기화할 수 있습니다.

CAFSM - 캐시 정렬 유한 상태 머신 CAFSM은 LS와 특정 DCS 간의 캐시 정렬 상태를 모니터링합니다. LS에서 볼 때 DCS당 하나의 CAFSM이 존재합니다.

CSA 레코드 - 캐시 상태 광고 레코드 CSA는 "특정" 캐시 항목의 상태에 대한 업데이트를 식별하는 CSU 메시지 내의 레코드입니다.

CSAS 레코드 - 캐시 상태 광고 요약 레코드 CSAS에는 CSA의 정보 요약이 포함되어 있습니다. 서버는 캐시 정렬 프로세스 중에 캐시 항목을 설명하는 CSAS 레코드를 다른 서버로 보냅니다. CSAS 레코드는 LS가 DCS에서 전체 CSA를 요청하려는 경우 CSUS 메시지에도 포함됩니다. LS는 DCS가 문제의 캐시 항목 상태에 대한 보다 최근의 보기를 가지고 있다고 믿기 때문에 DCS로부터 CSA를 요청하고 있습니다.

CSU 메시지 - 캐시 상태 업데이트 메시지 LS가 캐시 항목의 상태 변경을 알게 되었을 때 LS에서 해당 DCS로 보내는 메시지입니다.

CSUS 메시지 - 캐시 상태 업데이트 요청 메시지 이 메시지는 LS와 DCS가 CA 메시지를 교환한 후 LS에서 해당 DCS로 전송됩니다. CSUS 메시지에는 전체 CSA 레코드에 대한 권유를 나타내는 하나 이상의 CSAS 레코드가 포함됩니다\(CSAS에 보관된 요약 정보와 반대임\).

DCS - 직접 연결된 서버 DCS는 LS에 직접 연결된 서버입니다. 예를 들어, LS와 DCS 사이에 VC가 존재합니다. 이 용어는 LS 및 RS와 함께 서버 및 해당 동기화에 대해 이야기할 때 참조 프레임을 제공하는 데 사용됩니다. 명시적으로 달리 명시되지 않는 한 DCS, LS 및 RS 간의 기능 차이는 없습니다.

HFSM - Hello Finite State Machine LS에는 각 DCS와 연결된 HFSM이 있습니다. HFSM은 LS와 특정 DCS 간의 연결 상태를 모니터링합니다.

LS - 로컬 서버 LS는 감시 대상 서버입니다. 즉, 모든 진술은 LS의 관점에서 만들어집니다. 이 용어는 DCS 및 RS라는 용어와 함께 서버 및 해당 동기화에 대해 이야기할 때 참조 프레임을 제공하는 데 사용됩니다. 명시적으로 달리 명시되지 않는 한 DCS, LS 및 RS 간의 기능 차이는 없습니다.

LSID - 로컬 서버 ID LSID는 LS를 식별하는 고유한 토큰입니다. 이 값은 LS의 프로토콜 주소에서 가져올 수 있습니다.

PID - 프로토콜 ID 이 필드는 주어진 메시지에 대해 SCSP를 사용하는 클라이언트/서버 프로토콜을 식별하는 식별자를 포함합니다. 이 필드에 대한 프로토콜 ID 할당은 섹션 C에 설명된 대로 IANA에 제공됩니다.

RS - 원격 서버\(RS\) LS의 관점에서 볼 때 RS는 LS와 직접 연결되지 않은 LS와는 별개의 서버입니다\(즉, RS는 항상 LS에서 두 개 이상의 홉 떨어져 있지만 DCS는 항상 LS에서 한 홉 떨어져 있습니다. 달리 명시되지 않는 한 RS는 SG의 서버를 나타냅니다. 이 용어는 LS 및 DCS와 함께 서버 및 해당 동기화에 대해 이야기할 때 참조 프레임을 제공하는 데 사용됩니다. 명시적으로 달리 명시되지 않는 한 DCS, LS 및 RS 간의 기능 차이는 없습니다.

SG - 서버 그룹 SCSP는 몇 가지 수단\(예: LIS\(Logical IP Subnet\)\[1\]에 속하는 모든 서버\)을 통해 SG에 연결된 서버 엔티티 집합의 캐시\(또는 캐시의 일부\)를 동기화합니다. 따라서 SG는 공통성을 중심으로 서버를 그룹화한 것입니다.

SGID - 서버 그룹 ID 이 ID는 SG의 서버가 동기화되는 인스턴스 클라이언트/서버 프로토콜을 고유하게 식별하는 16비트 식별 필드입니다. 이는 동일한 프로토콜의 여러 인스턴스가 동시에 작동하고 서버가 서로 독립적으로 동기화될 수 있음을 의미합니다.

---
# **Appendix B:  SCSP Message Formats**

부록의 이 섹션에는 SCSP의 메시지 형식이 포함되어 있습니다. SCSP 프로토콜은 LLC=0xAA-AA-03 및 OUI=0x00-00-5e 및 PID=0x00-05로 캡슐화된 LLC/SNAP입니다.

SCSP는 모든 패킷에 고정 부분, 필수 부분 및 확장 부분의 세 부분으로 구성됩니다. 메시지의 고정 부분은 모든 패킷에 존재하며 아래와 같습니다. 필수 부분은 특정 메시지 유형\(즉, CA, CSU 요청/응답, Hello, CSUS\)에 고유하며, \(다른 패킷 요소 중에서\) 필수 공통 부분과 각 레코드에 관련된 정보를 포함하는 0개 이상의 레코드를 포함합니다. 정보가 SG 내에서 동기화되는 특정 캐시 항목의 상태\(Hello 메시지의 경우 제외\). 확장 부분에는 SCSP 메시지에 대한 확장 집합이 포함되어 있습니다.

다음 메시지 형식에서 "사용되지 않음"으로 표시된 필드는 해당 메시지 전송 시 0으로 설정되어야 하며 해당 메시지 수신 시 무시되어야 합니다.\(MUST\)

---
## **B.1 Fixed Part**

```text
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |    Version    |  Type Code    |        Packet Size            |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |          Checksum             |      Start Of Extensions      |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

버전 사용 중인 SCSP 프로토콜의 버전입니다. 현재 버전은 1입니다.

Type Code 메시지 유형에 대한 코드입니다\(예: Hello\(5\), CSU Request\(2\), CSU Reply\(3\), CSUS\(4\), CA\(1\)\).

패킷 크기 옥텟 단위의 SCSP 패킷의 총 길이입니다\(링크 계층 및/또는 기타 프로토콜 캡슐화 제외\).

체크섬 고정 헤더에서 시작하는 전체 SCSP 패킷에 대한 표준 IP 체크섬입니다. 패킷 길이가 홀수 바이트인 경우 이 계산은 0x00으로 설정된 바이트가 패킷 끝에 추가된 것처럼 수행됩니다.

확장 시작 이 필드는 메시지에 확장이 없을 때 0으로 코딩됩니다. 확장자가 있는 경우 이 필드는 고정 헤더의 맨 위에서 첫 번째 확장자의 시작 부분까지의 오프셋으로 코딩됩니다.

---
### **B.2.0 Mandatory Part**

SCSP 패킷의 필수 부분에는 주어진 메시지 유형\(예: SCSP 캐시 상태 업데이트 요청/응답 등\)에 대한 작업 특정 정보가 포함되어 있으며 \(다른 패킷 요소 중에서\) 필수 공통 부분\(섹션 B에 설명됨\)이 포함됩니다. .2.0.1\) 및 정보가 SG 내에서 동기화되는 특정 캐시 항목\(Hello 메시지의 경우 제외\)의 상태와 관련된 정보를 각각 포함하는 0개 이상의 레코드. 이러한 레코드는 메시지 유형에 따라 CSAS\(캐시 상태 광고 요약\) 레코드\(섹션 B.2.0.2에서 설명\) 또는 캐시 상태 광고\(CSA\) 레코드\(섹션 B.2.2.1에서 설명\)일 수 있습니다. CSA 레코드에는 캐시 항목 정보\(즉, CSAS 레코드\)의 요약과 일부 추가 클라이언트/서버 프로토콜 관련 정보가 포함됩니다. 필수 공통 부분 형식 및 CSAS 레코드 형식은 메시지 설명 내에서 복제를 방지하기 위해 SCSP 메시지에서 사용을 표시하기 전에 바로 아래에 표시됩니다.

---
#### **B.2.0.1 Mandatory Common Part**

섹션 B.2.1에서 B.2.5는 형식이 상당히 겹칩니다. 이 겹치는 형식을 필수 공통 부분이라고 하며 해당 형식은 다음과 같습니다.

```text
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |         Protocol ID           |        Server Group ID        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |            unused             |             Flags             |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   | Sender ID Len | Recvr ID Len  |       Number of Records       |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                  Sender ID (variable length)                  |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                Receiver ID (variable length)                  |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

프로토콜 ID 이 필드는 주어진 메시지에 대해 SCSP를 사용하는 클라이언트/서버 프로토콜을 식별하는 식별자를 포함합니다. 이 필드에 대한 프로토콜 ID의 할당은 섹션 C에 설명된 대로 IANA에 제공됩니다. 현재 문서가 있는 프로토콜에는 다음과 같이 정의된 값이 있습니다.

```text
       1 - ATMARP
       2 - NHRP
       3 - MARS
       4 - DHCP
       5 - LNNI
```

서버 그룹 ID 이 ID는 서버가 동기화되는 특정 클라이언트/서버 프로토콜의 인스턴스를 고유하게 식별합니다.

플래그 플래그 필드는 메시지별로 다르며 그 사용은 아래의 특정 메시지 형식 섹션에서 설명합니다.

발신자 ID Len 이 필드는 발신자 ID의 옥텟 길이를 보유합니다.

Recvr ID Len 이 필드는 수신자 ID의 옥텟 길이를 보유합니다.

레코드 수 이 필드에는 주어진 메시지와 관련된 추가 레코드 수가 포함됩니다. 이러한 레코드의 정확한 형식은 메시지에 따라 다르며 아래 섹션에서 각 메시지 유형에 대해 설명합니다.

발신자 ID 주어진 메시지를 보내는 서버에 할당된 식별자입니다. 가능한 할당 중 하나는 보내는 서버의 프로토콜 주소일 수 있습니다.

수신자 ID 주어진 메시지를 수신할 서버에 할당된 식별자입니다. 한 가지 가능한 할당은 주어진 메시지를 받을 서버의 프로토콜 주소일 수 있습니다.

---
#### **B.2.0.2 Cache State Advertisement Summary Record (CSAS record)**

CSAS 레코드에는 SCSP를 사용하여 동기화되는 특정 클라이언트/서버 데이터베이스의 캐시 항목에 포함된 요약 정보가 포함되어 있습니다. 요약에는 SCSP가 클라이언트/서버 데이터베이스에서 적절한 데이터베이스 캐시 항목을 조사한 다음 요약의 "새로움"을 캐시된 항목의 "새로움"과 비교할 수 있는 충분한 정보가 포함되어 있습니다.

CSAS 레코드에는 SGID\(서버 그룹 ID\)나 프로토콜 ID가 포함되어 있지 않습니다. 이러한 ID는 요약이 적용되는 프로토콜과 해당 프로토콜의 인스턴스를 식별하는 데 필요합니다. 이러한 ID는 각 메시지의 필수 공통 부분에 있습니다.

또한 CSAS 레코드의 홉 수 및 레코드 길이 필드 값은 CSAS 레코드가 "독립형" 레코드로 존재하는지 또는 CSAS 레코드가 CSA 레코드에 "내장"되어 있는지 여부에 따라 달라집니다. 이에 대해서는 아래에서 자세히 설명합니다.

```text
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |           Hop Count           |        Record Length          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   | Cache Key Len |  Orig ID Len  |N|          unused             |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                       CSA Sequence Number                     |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                           Cache Key  ...                      |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                         Originator ID   ...                   |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

홉 수 이 필드는 레코드가 삭제되기 전에 걸릴 수 있는 홉 수를 나타냅니다. 따라서 레코드가 통과하는 각 서버에서 홉 수가 감소합니다. CSAS 레코드가 "독립형" 레코드인 경우\(즉, CSA 레코드에 내장되지 않은 경우\) 이 필드는 1로 설정됩니다. 캐시 정렬 프로세스 중에 요약이 한 홉을 넘지 않기 때문입니다. CSAS 레코드가 CSA 레코드 내에 "내장"된 경우 홉 수는 거의 확실히 SG의 카디널리티에서 1을 뺀 값보다 크거나 같은 관리상 정의된 값으로 설정됩니다. CSA 레코드가 권유에 대한 응답으로 전송된 CSU 요청 내에서 전달되는 경우\(즉, CSUS 메시지로 전송된 CSAS 레코드에 대한 응답으로\) 이전 규칙에 대한 예외가 발생합니다. 이 경우 홉 수를 1로 설정해야 합니다\(SHOULD\).\(SHOULD\)

레코드 길이 CSAS 레코드가 "독립형" 레코드인 경우 이 값은 12+"캐시 키 길이"+"원본 ID 길이"\(바이트\)입니다. 그렇지 않으면 이 값은 12+"Cache Key Leng"+"Orig ID Len"+ sizeof\("캐시 항목에 대한 클라이언트/서버 프로토콜 특정 부분"\)으로 설정됩니다. 클라이언트/서버 프로토콜 특정 부분의 크기는 주어진 프로토콜 ID에 대한 클라이언트/서버 프로토콜 특정 문서에서 얻을 수 있습니다.

캐시 키 길이 캐시 키 필드의 길이\(바이트\)입니다.

원본 ID 렌. 작성자 ID 필드의 길이\(바이트\)입니다.

N "N" 비트는 이 CSAS 레코드가 실제로 Null 레코드임을 나타냅니다. 이 비트는 CSUS 메시지에 대한 응답으로 전송되는 CSU 요청/응답에 포함된 CSAS 레코드에서만 사용됩니다. 요청된 CSA 레코드가 나타내는 캐시 항목이 LS의 캐시에 더 이상 존재하지 않을 때 LS가 CSA 레코드에 대한 요청을 수신할 수 있습니다\(자세한 내용은 섹션 2.3 참조\). 이 경우 LS는 CSUS 메시지에서 CSU 요청으로 직접 CSAS 레코드를 복사하고 LS는 캐시 항목이 더 이상 존재하지 않음을 나타내는 N 비트를 설정합니다. 더 이상 존재하지 않는 CSA 기록을 요청한 DCS는 여전히 CSU 응답으로 응답합니다. 이 비트는 일반적으로 0으로 설정됩니다.

CSA 시퀀스 번호 이 필드에는 요약 중인 CSA 레코드 인스턴스의 "새로움"을 식별하는 시퀀스 번호가 포함되어 있습니다. "더 큰" 시퀀스 번호는 더 최근 광고를 의미합니다. 따라서 캐시 항목의 일부\(또는 전체\) 상태를 업데이트해야 하는 경우 새 상태를 광고하는 CSA 레코드는 이전 광고에 해당하는 것보다 큰 CSA 시퀀스 번호를 포함해야 합니다. 이 번호는 CSA 레코드의 작성자가 할당합니다. CSA 시퀀스 번호는 발신 서버 또는 서버가 자신의 존재를 알리게 한 클라이언트에 의해 할당될 수 있습니다.\(MUST\)

```text
     The CSA Sequence Number is a signed 32 bit number.  Within the CSA
     Sequence Number space, the number -2^31 (0x80000000) is reserved.
     Thus, the usable portion of the CSA Sequence Number space for a
     given Cache Key is between the numbers -2^31+1 (0x80000001) and
     2^31-1 (0x7fffffff).  An LS uses -2^31+1 the first time it
     originates a CSA Record for a cache entry that it created.  Each
     time the cache entry is modified in some manner and when that
     modification needs to be synchronized with the other servers in the
     SG, the LS increments the CSA Sequence number associated with the
```

업데이트를 광고할 때 새 CSA 시퀀스 번호를 사용합니다. 주어진 CSA 시퀀스 번호가 2^31-2에 도달하고 관련 캐시 항목이 SG의 나머지 서버로 업데이트를 보내야 하도록 수정된 경우에는 주어진 캐시 항목이 먼저 캐시 항목이 다른 서버에서 제거되도록 하는 CSA 레코드를 전송하여 LS가 SG에서 제거해야 하며 이 CSA 레코드는 2^31-1의 CSA 시퀀스 번호를 전달합니다. 캐시 항목이 제거되는 정확한 패킷 형식 및 메커니즘은 해당 프로토콜 관련 문서에 정의되어 있습니다. 삭제 CSA 레코드가 각 DCS에서 승인된 후 LS는 업데이트된 정보를 포함하는 새 CSA 레코드를 전송하고 이 새 CSA 레코드는 -2^31+1의 CSA 시퀀스 번호를 포함합니다.\(MUST\)

재시작이 발생하고 재시작하는 LS의 CAFSM이 Aligned 상태를 달성한 후, 기존 캐시 항목에 대한 업데이트를 동기화해야 하거나 새 캐시 항목을 동기화해야 하는 경우 후속 CSA 레코드는 다음과 같은 CSA 시퀀스 번호를 포함해야 합니다. 주어진 OID 및 캐시 키에 대해 SG 내에서 고유합니다. 이 번호를 얻는 권장 방법\(프로토콜 특정 문서에서 명시적으로 반대되는 경우가 아닌 한\)은 CSA 레코드의 CSA 시퀀스 번호를 기존 캐시 항목과 관련된 CSA 시퀀스 번호로 설정하는 것입니다\(오래된 캐시 항목인 경우\). 이미 존재하며 그렇지 않은 경우 0\)에 구성된 상수를 더합니다. 프로토콜 특정 문서는 캐시 항목을 업데이트하기 전에 다시 시작하는 LS의 OID를 포함하는 모든 캐시 항목을 제거하도록 요구할 수 있습니다. 이 경우 업데이트하는 CSA 레코드에는 이전의 기존 캐시 항목과 연결된 CSA 시퀀스 번호로 설정된 CSA 시퀀스 번호와 구성된 상수가 계속 포함됩니다.\(MUST, SHOULD\)

캐시 키 이것은 CSA 레코드의 생성자가 주어진 "프로토콜 ID/서버 그룹 ID" 쌍에 대해 피어와 동기화하려는 데이터 조각을 고유하게 식별하는 데이터베이스 조회 키입니다. 이 키는 일반적으로 SCSP가 캐시의 지정된 데이터 조각과 연결하는 작은 불투명 바이트 문자열입니다. 따라서, 예를 들어 발신자는 특정 4바이트 문자열을 IP 주소와 ATM 주소의 바인딩에 할당할 수 있습니다. 일반적으로 말하면, CSA 레코드의 원래 서버는 지정된 서버에서 시작되고 서버가 SG의 피어와 동기화하려는 데이터의 모든 요소에 대해 캐시 키를 생성할 책임이 있습니다.

작성자 ID 이 필드에는 CSA 레코드의 작성자인 서버에 관리상 할당된 ID가 포함됩니다.

---
### **B.2.1 Cache Alignment (CA)**

CA\(Cache Alignment\) 메시지는 LS가 전체 캐시를 서버 그룹 내 DCS의 캐시와 동기화할 수 있도록 합니다. CA 메시지 유형 코드는 1입니다. CA 메시지 필수 부분 형식은 다음과 같습니다.

```text
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                     CA  Sequence Number                       |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                    Mandatory Common Part                      |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                          CSAS Record                          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                                .......
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                          CSAS Record                          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

CA Sequence Number 캐시 정렬 프로세스의 순서를 지정하는 데 도움이 되는 고유 식별자를 제공하는 값입니다. "더 큰" 시퀀스 번호는 더 최근의 CA 메시지를 의미합니다. 슬레이브 서버는 항상 마스터 서버의 이전 CA 메시지에서 전송 중인 현재 CA 메시지로 시퀀스 번호를 복사하고 슬레이브는 마스터의 CA 메시지를 승인합니다. 초기 CA 프로세스는 잠금 단계이므로 슬레이브가 이전에 받은 것과 동일한 시퀀스 번호를 받지 못하면 슬레이브의 이전 CA 메시지에 있는 정보가 암시적으로 승인됩니다. 각 CAFSM과 연결된 별도의 CA 시퀀스 번호 공간이 있습니다.

캐시 정렬을 \(재\)시작해야 하고 CAFSM이 마스터/슬레이브 협상 상태에 들어갈 때마다 CA 시퀀스 번호는 이전에 DCS에서 볼 수 없는 값으로 설정되어야 합니다. 한 가지 가능한 계획은 기계의 시간 카운터를 사용하는 것입니다.

필수 공통 부분 필수 공통 부분은 섹션 B.2.0.1에 자세히 설명되어 있습니다. 필수 공통 부분에는 지정된 메시지 유형에 고유한 코딩이 있는 두 개의 필드가 있습니다. 이러한 필드는 "레코드 수" 필드와 "플래그" 필드입니다.

레코드 수

- CA 메시지에 대한 필수 공통 부분의 레코드 수 필드는 CA 메시지 필수 부분에 추가된 CSAS 레코드의 수를 제공합니다.

플래그

- CA 메시지에 대한 필수 공통 부분의 플래그 필드는 다음 형식을 갖습니다.

```text
        0                   1
        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |M|I|O|         unused          |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

중

- 이 비트는 캐시 정렬을 위한 협상 프로세스의 일부입니다. 이 비트가 설정되면 CA 메시지의 발신자는 정렬 프로세스를 주도하고자 함을 나타냅니다. 이 비트는 "마스터/슬레이브 비트"입니다.

나

- 설정된 경우 이 비트는 CA 메시지의 발신자가 자신이 마스터 또는 슬레이브의 상태에 대해 협상 중인 상태에 있다고 믿는다는 것을 나타냅니다. 이 비트는 "초기화 비트"입니다.

영형

- 이 비트는 CA 메시지의 보낸 사람이 보낼 CSAS 레코드가 더 있음을 나타냅니다. 이는 캐시 정렬 프로세스가 계속되어야 함을 의미합니다. 이 비트는 모호한 이름에도 불구하고 "mOre 비트"입니다.

필수 공통 부분의 다른 모든 필드는 섹션 B.2.0.1에 설명된 대로 코딩됩니다.

CSAS 레코드 CA 메시지는 필수 부분의 끝에 CSAS 레코드를 추가합니다. 이러한 CSAS 레코드는 CSA 레코드에 포함되지 않습니다. CSAS 기록에 대한 자세한 내용은 섹션 B.2.0.2를 참조하십시오.

---
### **B.2.2 Cache State Update Request (CSU Request)**

CSU 요청\(Cache State Update Request\) 메시지는 메시지를 보내는 서버에 직접 연결된 서버의 캐시 항목 상태를 업데이트하는 데 사용됩니다. LS가 하나 이상의 캐시 상태 변화를 관찰하면 하나의 서버\(LS\)에서 직접 연결된 서버\(DCS\)로 CSU 요청 메시지가 전송됩니다.

항목. LS는 LS의 데이터베이스를 업데이트하는 CSU 요청을 수신하거나 LS에서 시작된 캐시된 항목의 상태 변경을 관찰하여 이러한 상태 변경을 관찰합니다. 캐시 항목의 상태 변경은 아래와 같이 CSU 요청의 필수 부분 끝에 "CSA\(캐시 상태 광고\)" 레코드를 추가하여 CSU 메시지에 기록됩니다.

CSU 요청 메시지 유형 코드는 2입니다. CSU 요청 메시지 필수 부분 형식은 다음과 같습니다.

```text
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                    Mandatory Common Part                      |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                         CSA Record                            |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                              .......
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                         CSA Record                            |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

필수 공통 부분 필수 공통 부분은 섹션 B.2.0.1에 자세히 설명되어 있습니다. 필수 공통 부분에는 지정된 메시지 유형에 고유한 코딩이 있는 두 개의 필드가 있습니다. 이러한 필드는 "레코드 수" 필드와 "플래그" 필드입니다.

레코드 수

- CSU 요청 메시지에 대한 필수 공통 부분의 레코드 수 필드는 CSU 요청 메시지 필수 부분에 추가된 CSA 레코드의 수를 제공합니다.

플래그

- 현재 CSU 요청 메시지에 대한 필수 공통 부분의 Flags 필드에 대해 정의된 플래그가 없습니다.

필수 공통 부분의 다른 모든 필드는 섹션 B.2.0.1에 설명된 대로 코딩됩니다.

```text
   CSA Record
     See Section B.2.2.1.
```

---
#### **B.2.2.1 Cache State Advertisement Record (CSA record)**

CSA 레코드에는 SG에 있는 캐시 항목의 현재 상태를 동기화 중인 서버와 관련시키는 데 필요한 정보가 포함되어 있습니다. CSA 레코드에는 CSAS 레코드 헤더와 클라이언트/서버 프로토콜 특정 부분이 포함됩니다. CSAS 레코드에는 SCSP가 클라이언트/서버 데이터베이스에서 적절한 데이터베이스 캐시 항목을 조사한 다음 요약의 "새로움"을 캐시된 항목의 "새로움"과 비교할 수 있는 충분한 정보가 포함되어 있습니다. CSA에 포함된 정보가 수신 서버의 캐시된 항목보다 새로운 정보인 경우 캐시된 항목은 CSA 레코드의 내용에 따라 업데이트됩니다. CSA 레코드의 클라이언트/서버 프로토콜 특정 부분은 그러한 각 프로토콜에 대해 별도로 문서화됩니다. NHRP 및 ATMARP에 대한 프로토콜 특정 부분의 예는 각각 \[8\] 및 \[9\]에 나와 있습니다.

특정 CSA 레코드에 의해 전달되는 정보의 양은 링크 계층 PDU의 크기를 초과할 수 있습니다. 따라서 이러한 CSA 레코드는 여러 CSU 요청 메시지에 걸쳐 단편화되어야 합니다. 이를 수행하는 방법은 클라이언트/서버 프로토콜에 따라 다르며 적절한 프로토콜 관련 문서에 문서화되어 있습니다.\(MUST\)

CSA 레코드의 내용은 다음과 같습니다.

```text
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                          CSAS Record                          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |   Client/Server Protocol Specific Part for cache entry ...    |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

CSAS 레코드 CSA 레코드에 "내장"된 경우 CSAS 레코드를 작성하기 위한 규칙 및 형식은 섹션 B.2.0.2를 참조하십시오.

캐시 항목에 대한 클라이언트/서버 프로토콜 특정 부분 이 필드에는 SCSP 처리의 프로토콜 특정 부분에 특정한 필드가 포함되어 있습니다. 특정 필드 집합은 SCSP의 각 프로토콜 사용자에 대해 별도의 문서에 정의되어 있습니다. 주어진 패킷에서 SCSP를 사용하는 프로토콜을 식별하는 프로토콜 ID는 메시지의 필수 부분에 있습니다.

---
### **B.2.3 Cache State Update Reply (CSU Reply)**

캐시 상태 업데이트 응답\(CSU 응답\) 메시지는 CSU 요청에서 수신된 하나 이상의 CSA 레코드를 승인하기 위해 DCS에서 LS로 전송됩니다. CSU 요청에서 CSA 레코드의 수신은 확인되는 CSA 레코드에 해당하는 CSU 응답에 CSAS 레코드를 포함함으로써 확인됩니다. CSU 응답 메시지는 다음을 제외하고는 CSU 요청 메시지와 형식이 동일합니다. 유형 코드가 3이고 CSAS 레코드\(CSA 레코드가 아님\)만 반환되며 CSA 레코드가 확인되는 CSAS 레코드만 반환됩니다. 돌아왔다. 이는 CSU 요청을 보내는 주어진 LS가 CSU 요청에 포함된 모든 CSA 레코드에 대한 단일 CSU 응답에서 승인을 수신하지 못할 수 있음을 의미합니다.

---
### **B.2.4 Cache State Update Solicit Message (CSUS message)**

이 메시지는 하나의 서버\(LS\)가 직접 연결된 서버\(DCS\)의 캐시에 저장된 전체 CSA 레코드 데이터를 요청하도록 허용합니다. DCS는 적절한 CSA 레코드가 포함된 CSU 요청 메시지로 응답합니다. CSUS 메시지 타입 코드는 4이다. CSUS 메시지 포맷은 CSU Reply 메시지와 동일하다. CSUS 메시지는 하나의 서버\(메시지의 필수 부분에 있는 수신자 ID로 식별되는 서버\)에서만 CSU 요청을 요청합니다.

---
### **B.2.5 Hello:**

Hello 메시지는 송신 서버\(LS\)와 직접 연결된 이웃 서버\(DCS\) 간의 연결을 확인하는 데 사용됩니다. Hello 메시지 유형 코드는 5입니다. Hello 메시지 필수 부분 형식은 다음과 같습니다.

```text
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |         HelloInterval         |          DeadFactor           |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |            unused             |          Family ID            |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                    Mandatory Common Part                      |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                 Additional Receiver ID Record                 |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                               .........
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                 Additional Receiver ID Record                 |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

HelloInterval Hello 간격은 연속적인 Hello 메시지 전송 사이의 시간을 알립니다. LS가 DCS가 광고한 HelloInterval 내에 DCS\(수신자 ID로 LSID 포함\)로부터 Hello 메시지를 수신하지 않으면 DCS의 Hello가 늦은 것으로 간주됩니다. 또한 LS는 자신의 Hello 메시지를 해당 DCS에 대한 LS의 이전 Hello 메시지에서 DCS에 광고한 HelloInterval 내의 DCS에 보내야 합니다\(그렇지 않으면 DCS는 LS의 Hello가 늦은 것으로 간주함\).\(MUST\)

DeadFactor 이것은 HelloInterval에 대한 승수입니다. LS가 이전 Hello 메시지에서 HelloInterval 및 DeadFactor를 광고한 지정된 DCS로부터 HelloInterval\*DeadFactor 간격 내에서 수신자 ID로 LS의 LSID를 포함하는 Hello 메시지를 수신하지 않으면 LS는 DCS를 다음과 같이 고려해야 합니다. 실속; 이 시점에서 두 가지 중 하나가 발생해야 합니다. 1\) LS가 이 시간 동안 DCS로부터 Hello 메시지를 수신한 경우 LS는 해당 HFSM을 단방향 상태로 전환합니다. 그렇지 않으면 2\) LS는 해당 HFSM을 대기 상태로 전환합니다.\(MUST\)

패밀리 ID 이것은 프로토콜 ID/SGID 쌍의 집계를 참조하는 데 사용되는 불투명한 비트 문자열입니다. Family ID에 할당된 모든 프로토콜 ID/SGID 쌍에 대해 단일 HFSM만 실행됩니다. 따라서 단일 HFSM과 각 프로토콜 ID/SGID 쌍에 해당하는 CAFSM 간에 일대다 매핑이 ​​있습니다. 이는 HFSM 유지 관리 트래픽을 크게 줄이는 순 효과를 가질 수 있습니다. 자세한 내용은 프로토콜별 SCSP 문서를 참조하십시오.

필수 공통 부분 필수 공통 부분은 섹션 B.2.0.1에 자세히 설명되어 있습니다. 필수 공통 부분에는 지정된 메시지 유형에 고유한 코딩이 있는 두 개의 필드가 있습니다. 이러한 필드는 "레코드 수" 필드와 "플래그" 필드입니다.

레코드 수

- Hello 메시지에 대한 필수 공통 부분의 Number of Records 필드는 Hello에 포함된 "추가 수신자 ID" 레코드의 개수를 포함합니다. 추가 수신자 ID 레코드에는 길이 필드와 수신자 ID 필드가 포함되어 있습니다. "Number of Records"의 개수에는 필수 공통 부분에 포함된 수신자 ID가 포함되지 않습니다.

플래그

- 현재 Hello 메시지에 대한 필수 공통 부분의 Flags 필드에 대해 정의된 플래그가 없습니다.

필수 공통 부분의 다른 모든 필드는 섹션 B.2.0.1에 설명된 대로 코딩됩니다.

추가 수신자 ID 레코드 이 레코드에는 수신자 ID가 뒤따르는 길이 필드가 있습니다. 주어진 수신자 ID의 길이는 SG 내에서도 다를 수 있기 때문에 \(첫 번째 수신자를 넘어\) 수신된 각 추가 수신자 ID는 바이트 길이와 "추가 수신자 ID 레코드"에 인코딩된 값을 모두 갖게 됩니다. 수신자 ID는 LS가 최근 Hello를 들었던 DCS의 ID입니다\(즉, 이전 Hello 메시지에서 DCS에 의해 광고된 DeadFactor\*HelloInterval 내에서\).

이 레코드의 형식은 다음과 같습니다.

```text
      0                   1                   2                   3
      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |  Rec ID Len   |                 Receiver ID                   |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

LS가 어떤 DCS로부터도 듣지 못한 경우 LS는 Hello 메시지 필드를 다음과 같이 설정합니다. Recvr ID Len은 0으로 설정되고 Common Mandatory Part의 Receiver ID에 대해 할당된 스토리지가 없습니다. "Number of Records"는 다음과 같이 설정됩니다. 0이고 "추가 수신자 ID 레코드"에 할당된 스토리지가 없습니다.

LS가 정확히 하나의 DCS로부터 수신한 경우 LS는 Hello 메시지 필드를 다음과 같이 설정합니다. 수신된 DCS의 수신기 ID와 해당 수신자 ID의 길이는 공통 필수 부분에 인코딩됩니다. "레코드 수"는 다음과 같습니다. 0으로 설정되고 "추가 수신자 ID 레코드"에 대해 스토리지가 할당되지 않습니다.

LS가 2개 이상의 DCS로부터 수신한 경우 LS는 Hello 메시지 필드를 다음과 같이 설정합니다. 수신된 첫 번째 DCS의 수신기 ID와 해당 수신자 ID의 길이는 공통 필수 부분인 "레코드 수"에 인코딩됩니다. "는 수신된 "추가" DCS의 수로 설정되며 각 추가 DCS에 대해 "추가 수신자 ID 레코드"가 형성되어 Hello 메시지의 끝에 추가됩니다.

---
## **B.3  Extensions Part**

Extensions Part가 있는 경우 {Type, Length, Value} triplet에서 하나 이상의 확장을 전달합니다.

확장 프로그램의 형식은 다음과 같습니다.

```text
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |            Type               |           Length              |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                         Value...                              |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

유형 확장 유형 코드\(아래 참조\).

길이 값의 길이\(유형 및 길이 필드 제외, 널 확장에는 확장 헤더와 길이가 0만 있음\).

확장이 존재하는 경우 확장 부분은 Type = 0 및 Length = 0인 End of Extensions 확장으로 종료됩니다.

확장은 임의의 순서로 발생할 수 있지만 특정 확장 유형은 SCSP 패킷에서 한 번만 발생할 수 있습니다. LS는 확장 순서를 변경하면 안 됩니다\(MUST NOT\).\(MUST NOT\)

---
### **B.3.0  The End Of Extensions**

```text
    Type = 0
    Length = 0
```

확장자가 존재할 경우 확장자 부분은 End Of Extensions 확장자에 의해 종료된다.

---
### **B.3.1 SCSP Authentication Extension**

```text
   Type = 1 Length = variable
```

SCSP 인증 확장은 동일한 SG에서 LS와 DCS 사이에 인증 정보를 전달하기 위해 SCSP 패킷으로 운반됩니다.

인증은 LS에서 DCS로 쌍으로 이루어집니다. 즉, 인증 확장은 각 LS에서 생성됩니다. 수신된 패킷이 인증 테스트에 실패하면 "비정상 이벤트"가 발생한 것입니다. 패킷이 삭제되고 이 이벤트가 기록됩니다.

인증 유무는 로컬 문제입니다.

---
#### **B.3.1.1 Header Format**

인증 헤더의 형식은 다음과 같습니다.

```text
   0                   1                   2                   3
   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |               Security Parameter Index (SPI)                  |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+ Authentication Data... -+-+-+-+-+-+-+-+-+-+
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

SPI\(Security Parameter Index\)는 키 및 해시 알고리즘과 같은 기타 정보를 유지 관리하는 테이블에 대한 인덱스로 생각할 수 있습니다. LS와 DCS는 수동 키 입력을 사용하여 오프라인으로 통신하거나 키 관리 프로토콜을 사용하여 온라인으로 통신하여 이 테이블을 채웁니다. 수신 SCSP 엔터티는 항상 SPI 및 관련 매개변수를 할당합니다.

인증 데이터 필드에는 전체 SCSP 페이로드에 대해 계산된 MAC\(메시지 인증 코드\)이 포함됩니다. 이 필드의 길이는 MAC 계산에 사용되는 해시 알고리즘에 따라 다릅니다.

---
#### **B.3.1.2 Supported Hash Algorithms**

지원되는 기본 해시 알고리즘은 HMAC-MD5-128\[11\]입니다. HMAC는 일반 키 해시보다 안전합니다. 다른 해시 알고리즘은 def에 의해 지원될 수 있습니다.\(MAY\)

IANA는 섹션 C에 설명된 대로 사용 중인 알고리즘을 식별하기 위해 번호를 할당합니다.

---
#### **B.3.1.3 SPI and Security Parameters Negotiation**

SPI는 수동으로 또는 인터넷 키 관리 프로토콜을 사용하여 협상할 수 있습니다. 수동 키 입력이 지원되어야 합니다. 다음 매개변수는 튜플 <SPI, DCS ID\>-lifetime, Algorithm, Key와 연결됩니다. 수명은 지속 시간\(초\)을 나타냅니다.\(MUST\)

키가 유효합니다. 수동 키잉의 경우 이 기간은 무한할 수 있습니다. 또한 수동 키잉을 더 잘 지원하기 위해 동시에 여러 튜플이 활성화될 수 있습니다\(DCS ID는 동일함\).

모든 인터넷 표준 키 관리 프로토콜을 사용하여 SPI 및 매개변수를 협상할 수 있습니다\(MAY\).\(MAY\)

---
#### **B.3.1.4 Message Processing**

인증 확장 헤더를 추가할 때 LS는 DCS ID를 기반으로 SPI 및 보안 매개변수를 가져오기 위해 테이블에서 조회합니다. 테이블에 항목이 없고 키 관리 지원이 있는 경우 LS는 키 관리 프로토콜을 시작하여 필요한 매개변수를 가져옵니다. 그런 다음 LS는 송신 측에서 MAC을 계산하기 전에 인증 데이터 필드를 제로화하여 해시를 계산합니다. 결과는 0으로 설정된 인증 데이터 필드에서 대체됩니다. 키 관리가 지원되지 않고 인증이 필수인 경우 패킷이 삭제되고 이 정보가 기록됩니다.

트래픽을 수신할 때 LS는 SPI 및 해당 ID를 기반으로 매개변수를 가져옵니다. 해시를 계산하기 위해 제로화하기 전에 인증 데이터 필드가 추출됩니다. 전체 페이로드에 대한 해시를 계산하고 해시가 일치하지 않으면 "비정상 이벤트"가 발생한 것입니다.

---
#### **B.3.1.5 Security Considerations**

전체 시스템의 보안은 적절하게 선택된 키와 알고리즘의 올바른 구현에 달려 있기 때문에 선택한 키가 강력해야 합니다.

SCSP에는 피어 투 피어 신뢰 모델이 있습니다. 인터넷 표준 키 관리 프로토콜을 사용하여 이웃 간에 키를 협상하는 것이 좋습니다. 일반 텍스트로 키를 전송하면 다른 협상 방법을 사용하는 경우 보안이 완전히 손상됩니다.

데이터 무결성은 전체 SCSP 페이로드를 포괄합니다. 이렇게 하면 메시지가 수정되지 않았으며 소스도 인증됩니다. 인증 확장이 사용되지 않거나 보안이 손상된 경우 SCSP 서버는 스푸핑 공격, 능동적 공격 및 수동적 공격 모두에 취약합니다.

메시지를 암호화하는 메커니즘이 없습니다. 메시지를 암호화하고 해독하는 데 표준 계층 3 기밀성 메커니즘이 사용된다고 가정합니다. SCSP 메시지에서 무결성이 계산됨에 따라

각 레코드가 아니라 도메인의 모든 서버 간에 묵시적 신뢰가 있습니다. 하위 집합 서버가 아닌 도메인의 모든 서버 간에 보안 확장을 사용하는 것이 좋습니다.

모든 SCSP 서버는 서비스 거부\(DOS\) 공격에 취약합니다. 루즈 호스트는 SCSP 패킷으로 인접한 SCSP 서버를 범람시킬 수 있습니다. 그러나 인증 옵션을 사용하면 SCSP 데이터베이스가 손상되지 않습니다. 인증 확인에 실패하면 가짜 패킷이 폐기되기 때문입니다.

SCSP의 쌍별 인증 모델로 인해 적절하게 인증된 서버에서 수신한 정보는 서버 그룹 전체에 신뢰되고 전파됩니다. 결과적으로 SCSP 서버의 보안이 손상되면 전체 데이터베이스가 손상된 서버에서 발생하는 손상에 취약해집니다.

---
### **B.3.2  SCSP Vendor-Private Extension**

```text
    Type = 2
    Length = variable
```

SCSP Vendor-Private Extension은 동일한 SG에서 LS와 DCS 사이에 벤더 개인 정보를 전달하기 위해 SCSP 패킷으로 전달되므로 사용이 제한됩니다. 더 미세한 세분성\(예: CSA 레코드 수준\)이 필요한 경우 주어진 클라이언트/서버 프로토콜 특정 SCSP 문서에서 이러한 메커니즘을 정의해야 합니다. 그러나 이러한 프로토콜 특정 메커니즘은 분명히 이 확장과 똑같이 보일 수 있습니다. 공급업체 개인 확장은 주어진 공급업체 ID 값에 대한 SCSP 패킷에 두 번 이상 나타나지 않을 수 있습니다.\(MUST, MAY\)

```text
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                  Vendor ID                    |  Data....     |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

공급업체 ID 802 IEEE에서 할당한 공급업체 ID\[7\].

데이터 페이로드에서 공급업체 ID 뒤의 나머지 옥텟은 공급업체에 따라 다른 데이터입니다.

수신자가 이 확장을 처리하지 않거나 확장의 공급업체 ID와 일치하지 않으면 수신자가 확장을 완전히 무시할 수 있습니다.

---
## **C. IANA Considerations**

이 문서에 설명된 다양한 숫자 공간의 값 할당에 대한 모든 요청에는 적절한 문서가 필요합니다. 가능한 문서 형식에는 RFC 또는 다른 협력 표준 기관\(예: ATM 포럼의 MPOA 및 LANE 하위 작업 그룹\)의 제품이 포함되지만 이에 국한되지 않습니다. "지정 전문가"의 조언에 따라 다른 요청도 수락될 수 있습니다. \(현재 전문가의 연락처 정보는 IANA에 문의하십시오.\)

---
# **References**

\[1\] Laubach, M. 및 J. Halpern, "ATM을 통한 클래식 IP 및 ARP", Laubach, RFC 2225, 1998년 4월.

\[2\] Luciani, J., Katz, D., Piscitello, D., Cole, B. 및 N. Doraswamy, "NMBA 다음 홉 해상도 프로토콜\(NHRP\)", RFC 2332, 1998년 4월.

```text
   [3] Moy, J., "OSPF Version 2", STD 54, RFC 2328, April 1998.

   [4] "P-NNI V1", Dykeman, Goguen, 1996.
```

\[5\] Armitage, G., "UNI 3.0/3.1 기반 ATM 네트워크를 통한 멀티캐스트 지원", RFC 2022, 1996년 11월.

\[6\] Keene, "ATM 버전 2를 통한 LAN 에뮬레이션 - LNNI 사양", btd-lane-lnni-02.08

\[7\] Reynolds, J. 및 J. Postel, "할당된 번호", STD 2, RFC 1700, 1994년 10월.

```text
   [8] Luciani, J., "A Distributed NHRP Service Using SCSP", RFC 2335,
   April 1998.
```

\[9\] Luciani, J., "SCSP를 사용한 분산 ATMARP 서비스", 진행 중인 작업.

\[10\] Bradner, S., "요구 수준을 나타내기 위해 RFC에서 사용할 핵심 단어", BCP 14, RFC 2119, 1997년 3월.

\[11\] Krawczyk, H., Bellare, M. 및 R. Canetti, "HMAC: 메시지 인증을 위한 키 해싱", RFC 2104, 1997년 2월.

---
# **Acknowledgments**

이 메모는 비공개 토론, IP-ATM 메일링 리스트 및 Dallas IETF\(12/95\) 중에 제기된 문제를 추출한 것입니다. 도움을 주신 모든 분들께 감사드리며 특히 다음 분들에게 감사드립니다\(순서 없음\): Barbara Fox of Harris 및 Jeffries; IBM의 Colin Verrilli; Raj Nair, Ascom Nexion의 Matthew Doar; Cascade의 Andy Malis; Bay Networks의 Andre Fredette; Newbridge의 James Watt; 그리고 Fore의 Carl Marcinik.

---
# **Authors' Addresses**

```text
   James V. Luciani
   Bay Networks, Inc.
   3 Federal Street, BL3-03
   Billerica, MA  01821

   Phone: +1-978-916-4734
   EMail: luciani@baynetworks.com

   Grenville Armitage
   Bell Labs Lucent Technologies
   101 Crawfords Corner Road
   Holmdel, NJ 07733

   Phone: +1 201 829 2635
   EMail: gja@lucent.com

   Joel M. Halpern
   Newbridge Networks Corp.
   593 Herndon Parkway
   Herndon, VA 22070-5241

   Phone: +1-703-708-5954
   EMail: jhalpern@Newbridge.COM

   Naganand Doraswamy
   Bay Networks, Inc.
   3 Federal St, BL3-03
   Billerice, MA 01821

   Phone: +1-978-916-1323
   EMail: naganand@baynetworks.com
```

---
# **Full Copyright Statement**

Copyright \(C\) The Internet Society \(1998\). 판권 소유.

이 문서와 그 번역본은 복사되어 타인에게 제공될 수 있으며, 이에 대해 설명하거나 설명하거나 구현을 지원하는 파생물은 어떤 종류의 제한 없이 전체적으로 또는 부분적으로 준비, 복사, 출판 및 배포될 수 있습니다. , 단, 위의 저작권 표시와 이 단락은 그러한 모든 사본 및 파생물에 포함됩니다. 그러나 이 문서 자체는 인터넷 표준 개발 목적으로 필요한 경우를 제외하고는 저작권 표시를 제거하거나 Internet Society 또는 기타 인터넷 조직에 대한 참조를 제거하는 등 어떤 식으로든 수정할 수 없습니다. 인터넷 표준 프로세스를 따르거나 영어 이외의 언어로 번역하는 데 필요한 대로 따라야 합니다.

위에서 부여된 제한된 권한은 영구적이며 Internet Society 또는 그 승계자 또는 양수인에 의해 취소되지 않습니다.

이 문서와 여기에 포함된 정보는 "있는 그대로" 제공되며 인터넷 사회 및 인터넷 공학 태스크포스는 여기에 포함된 정보의 사용이 상품성 또는 특정 목적에의 적합성에 대한 권리 또는 묵시적 보증을 침해하는 행위.
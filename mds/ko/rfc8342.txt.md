

```text
Internet Engineering Task Force (IETF)                      M. Bjorklund
Request for Comments: 8342                                Tail-f Systems
Updates: 7950                                           J. Schoenwaelder
Category: Standards Track                              Jacobs University
ISSN: 2070-1721                                                P. Shafer
                                                               K. Watsen
                                                        Juniper Networks
                                                               R. Wilton
                                                           Cisco Systems
                                                              March 2018

            Network Management Datastore Architecture (NMDA)
```

---
# **Abstract**

데이터스토어는 YANG 데이터 모델링 언어로 작성된 데이터 모델을 NETCONF\(Network Configuration Protocol\) 및 RESTCONF와 같은 네트워크 관리 프로토콜에 바인딩하는 기본 개념입니다. 이 문서에서는 단순한 초기 모델에서 얻은 경험을 바탕으로 데이터 저장소에 대한 아키텍처 프레임워크를 정의하고 초기 모델에서 제대로 지원되지 않았던 요구 사항을 해결합니다. 이 문서는 RFC 7950을 업데이트합니다.

---
# **Status of This Memo**

이것은 인터넷 표준 추적 문서입니다.

이 문서는 IETF\(Internet Engineering Task Force\)의 제품입니다. 이는 IETF 커뮤니티의 합의를 나타냅니다. 공개 검토를 받았으며 IESG\(Internet Engineering Steering Group\)의 출판 승인을 받았습니다. 인터넷 표준에 대한 자세한 내용은 RFC 7841의 섹션 2에서 확인할 수 있습니다.

이 문서의 현재 상태, 정오표, 피드백 제공 방법에 대한 정보는 https://www.rfc-editor.org/info/rfc8342에서 확인할 수 있습니다.

---
# **Copyright Notice**

Copyright \(c\) 2018 IETF Trust 및 문서 작성자로 확인된 사람. 판권 소유.

이 문서는 이 문서의 발행일에 유효한 BCP 78 및 IETF 문서에 관한 IETF 트러스트의 법적 조항\(https://trustee.ietf.org/license-info\)의 적용을 받습니다. 이 문서와 관련된 귀하의 권리 및 제한 사항을 설명하므로 이 문서를 주의 깊게 검토하십시오. 이 문서에서 추출한 코드 구성 요소는 Trust Legal Provisions의 섹션 4.e에 설명된 대로 Simplified BSD License 텍스트를 포함해야 하며 Simplified BSD License에 설명된 대로 보증 없이 제공됩니다.

---
# **Table of Contents**

```text
   1. Introduction ....................................................3
   2. Objectives ......................................................4
   3. Terminology .....................................................5
   4. Background ......................................................8
      4.1. Original Model of Datastores ...............................9
   5. Architectural Model of Datastores ..............................11
      5.1. Conventional Configuration Datastores .....................12
           5.1.1. The Startup Configuration Datastore (<startup>) ....12
           5.1.2. The Candidate Configuration Datastore
                  (<candidate>) ......................................13
           5.1.3. The Running Configuration Datastore (<running>) ....13
           5.1.4. The Intended Configuration Datastore (<intended>) ..13
      5.2. Dynamic Configuration Datastores ..........................14
      5.3. The Operational State Datastore (<operational>) ...........14
           5.3.1. Remnant Configuration ..............................16
           5.3.2. Missing Resources ..................................16
           5.3.3. System-Controlled Resources ........................16
           5.3.4. Origin Metadata Annotation .........................17
   6. Implications on YANG ...........................................18
      6.1. XPath Context .............................................18
      6.2. Invocation of Actions and RPCs ............................19
   7. YANG Modules ...................................................20
   8. IANA Considerations ............................................26
      8.1. Updates to the IETF XML Registry ..........................26
      8.2. Updates to the YANG Module Names Registry .................27
   9. Security Considerations ........................................27
   10. References ....................................................28
      10.1. Normative References .....................................28
      10.2. Informative References ...................................29
   Appendix A. Guidelines for Defining Datastores ....................31
     A.1. Define Which YANG Modules Can Be Used in the Datastore .....31
     A.2. Define Which Subset of YANG-Modeled Data Applies ...........31
     A.3. Define How Data Is Actualized ..............................31
     A.4. Define Which Protocols Can Be Used .........................31
     A.5. Define YANG Identities for the Datastore ...................32
   Appendix B. Example of an Ephemeral Dynamic Configuration
               Datastore .............................................32
   Appendix C. Example Data ..........................................33
     C.1. System Example .............................................34
     C.2. BGP Example ................................................37
       C.2.1. Datastores .............................................38
       C.2.2. Adding a Peer ..........................................38
       C.2.3. Removing a Peer ........................................39
     C.3. Interface Example ..........................................40
       C.3.1. Pre-provisioned Interfaces .............................41
       C.3.2. System-Provided Interface ..............................42
   Acknowledgments ...................................................43
   Authors' Addresses ................................................44
```

---
## **1.  Introduction**

이 문서는 네트워크 구성 프로토콜\(NETCONF\) \[RFC6241\], RESTCONF \[RFC8040\] 및 YANG 데이터 모델링 언어 \[RFC7950\]와 같은 네트워크 관리 프로토콜에서 사용되는 데이터 저장소에 대한 아키텍처 프레임워크를 제공합니다. 데이터스토어는 네트워크 관리 데이터 모델을 네트워크 관리 프로토콜에 바인딩하는 기본 개념입니다. 데이터 저장소의 공통 아키텍처 모델에 대한 합의는 네트워크 관리 프로토콜에 구애받지 않는 방식으로 데이터 모델을 작성할 수 있도록 보장합니다. 이 아키텍처 프레임워크는 일련의 개념적 데이터 저장소를 식별하지만 모든 네트워크 관리 프로토콜이 이러한 모든 개념적 데이터 저장소를 노출하도록 요구하지는 않습니다. 이 아키텍처는 네트워크 관리 프로토콜에서 사용되는 인코딩과 관련하여 불가지론적입니다.

이 문서는 일부 XML 경로 언어\(XPath\) 컨텍스트\(섹션 6.1 참조\) 및 작업 호출 컨텍스트\(섹션 6.2 참조\)에 대한 액세스 가능한 트리 정의를 구체화하여 RFC 7950을 업데이트합니다.

키워드 "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY" 및 "OPTIONAL" "는 BCP 14 \[RFC2119\] \[RFC8174\]에 설명된 대로 여기에 표시된 것처럼 모두 대문자로 표시되는 경우에만 해석됩니다.\(MUST NOT\)

---
## **2.  Objectives**

네트워크 관리 데이터 개체는 사용자나 애플리케이션이 구성한 값\(구성\)과 장치가 실제로 사용하는 값\(작동 상태\)이라는 두 가지 다른 값을 가질 수 있는 경우가 많습니다. 이 두 값은 하드웨어와의 시스템 내부 상호 작용, 프로토콜 또는 기타 장치와의 상호 작용, 단순히 구성 변경 사항을 시스템의 소프트웨어 및 하드웨어 구성 요소에 전파하는 데 걸리는 시간 등 여러 가지 이유로 인해 다를 수 있습니다. 또한 구성 및 작동 상태 데이터 개체의 수명은 다를 수 있습니다.

데이터 저장소의 원래 모델에서는 이러한 데이터 개체를 YANG 스키마에서 "config true" 개체와 "config false" 개체로 두 번 모델링해야 했습니다. 인터페이스 데이터 모델 \[RFC8343\]과 IP 데이터 모델 \[RFC8344\]에서 채택한 규칙은 데이터 트리의 루트에 뿌리를 둔 두 개의 개별 분기를 사용하는 것이었습니다. 하나는 구성 데이터 개체용 분기이고 다른 하나는 작동 상태 데이터 개체용 분기입니다.

정의가 중복되고 구성 데이터에서 작동 상태 데이터가 임시적으로 분리되면 여러 가지 문제가 발생합니다. 데이터 모델의 별도 분기에 구성 및 작동 상태 데이터를 갖는 것은 운영상 복잡하며 모듈 정의의 가독성에 영향을 미칩니다. 또한 분기 간의 관계는 기계에서 읽을 수 없으며 구성 및 관련 작동 상태에서 작동하는 필터 표현식이 다릅니다.

이 문서에 정의된 데이터 저장소의 수정된 아키텍처 모델을 사용하면 데이터 개체가 YANG 스키마에서 한 번만 정의되지만 독립적인 인스턴스화는 서로 다른 데이터 저장소에 나타날 수 있습니다\(예: 구성된 값에 대해 하나, 운영상 사용되는 값에 대해 다른 하나\). 이는 문제에 대한 보다 우아하고 간단한 솔루션을 제공합니다.

데이터 저장소의 수정된 아키텍처 모델은 구성을 작동 상태로 변환하는 고급 처리 체인을 지원하는 시스템을 위한 추가 데이터 저장소를 지원합니다. 예를 들어 일부 시스템은 현재 사용되지 않는 구성\(소위 "비활성 구성"\)을 지원하거나 공통 템플릿을 통해 구성 데이터를 확장하는 데 사용되는 구성 템플릿을 지원합니다.

---
## **3.  Terminology**

이 문서에서는 다음 용어를 정의합니다. 일부 용어는 \[RFC6241\] 및 \[RFC7950\]에 원래 정의된 용어의 정의가 개정되었습니다\(섹션 4 참조\). 개정된 정의는 \[RFC6241\] 및 \[RFC7950\]에 있는 정의와 의미상 동일합니다. 이 문서가 개정되면 이 섹션에 제공된 개정된 정의가 \[RFC6241\] 및 \[RFC7950\]의 정의를 대체할 것으로 예상됩니다.

o 데이터 저장소: 정보를 저장하고 액세스하는 개념적 장소입니다. 예를 들어, 데이터 저장소는 파일, 데이터베이스, 플래시 메모리 위치 또는 이들의 조합을 사용하여 구현될 수 있습니다. 데이터 저장소는 인스턴스화된 YANG 데이터 트리에 매핑됩니다.

o 스키마 노드: 스키마 트리의 노드입니다. 공식적인 정의는 RFC 7950에 제공되어 있습니다.

o 데이터 저장소 스키마: 특정 데이터 저장소에서 지원하는 모든 모듈에 대한 결합된 스키마 노드 세트로, 해당 데이터 저장소에 대해 모든 편차와 활성화된 기능을 고려합니다.

o 구성: 장치를 초기 기본 상태에서 원하는 작동 상태로 전환하는 데 필요한 데이터입니다. 이 데이터는 "config true" 노드를 사용하여 YANG에서 모델링되었습니다. 구성은 다양한 소스에서 시작될 수 있습니다.

o 구성 데이터 저장소: 구성을 보유하는 데이터 저장소입니다.

o 실행 중인 구성 데이터 저장소: 장치의 현재 구성을 보유하는 구성 데이터 저장소입니다. 적용하기 전에 추가 변환이 필요한 구성이 포함될 수 있습니다. 이 데이터스토어를 "<실행\>"이라고 합니다.

o 후보 구성 데이터 저장소: 장치의 실행 중인 구성 데이터 저장소에 영향을 주지 않고 조작할 수 있고 실행 중인 구성 데이터 저장소에 커밋될 수 있는 구성 데이터 저장소입니다. 이 데이터 저장소를 "<후보\>"라고 합니다.

o 시작 구성 데이터 저장소: 장치가 부팅할 때 실행 중인 구성 데이터 저장소에 로드된 구성을 보유하는 구성 데이터 저장소입니다. 이 데이터 저장소를 "<startup\>"이라고 합니다.

o 의도된 구성: 장치에서 사용하도록 의도된 구성입니다. 이는 <running\>으로의 모든 구성 변환이 수행된 후의 구성을 나타내며 시스템이 적용하려고 시도하는 구성입니다.

o 의도된 구성 데이터 저장소: 장치의 의도된 전체 구성을 보유하는 구성 데이터 저장소입니다. 이 데이터 저장소를 "<의도\>"라고 합니다.

o 구성 변환: <실행 중인\> 데이터 저장소와 <의도된\> 데이터 저장소 간의 구성 추가, 수정 또는 제거입니다. 구성 변환의 예로는 비활성 구성 제거 및 템플릿 확장을 통해 생성된 구성이 포함됩니다.

o 기존 구성 데이터 저장소: <running\>, <startup\>, <candidate\> 및 <intended\> 구성 데이터 저장소 집합 중 하나입니다. 이러한 데이터 저장소는 공통 데이터 저장소 스키마를 공유하며 프로토콜 작업을 통해 이러한 데이터 저장소 간에 데이터를 복사할 수 있습니다. "기존"이라는 용어는 이러한 데이터 저장소에 대한 일반적인 포괄적 용어로 선택되었습니다.

o 기존 구성: 기존 구성 데이터 저장소에 저장된 구성입니다.

o 동적 구성 데이터 저장소: 기존 구성 데이터 저장소 중 하나를 통하지 않고 다른 시스템과의 상호 작용을 통해 장치 작동 중에 동적으로 얻은 구성을 보유하는 구성 데이터 저장소입니다.

o 동적 구성: 동적 구성 데이터 저장소를 통해 얻은 구성입니다.

o 학습된 구성: 다른 시스템과의 프로토콜 상호 작용을 통해 학습되었으며 기존 구성도 동적 구성도 아닌 구성입니다.

o 시스템 구성: 장치 자체에서 제공되는 구성입니다.

o 기본 구성: 명시적으로 제공되지는 않지만 데이터 모델에 정의된 값이 사용되는 구성입니다.

o 적용된 구성: 장치에서 적극적으로 사용 중인 구성입니다. 적용된 구성은 기존 구성, 동적 구성, 학습된 구성, 시스템 구성 및 기본 구성에서 비롯됩니다.

o 시스템 상태: 시스템에 존재하지 않는 추가 데이터

- 읽기 전용 상태 정보, 수집된 통계 등의 구성. 시스템 상태는 일시적이며 내부 구성 요소 또는 다른 시스템과의 상호 작용에 의해 수정됩니다. 시스템 상태는 "config false" 노드를 사용하여 YANG에서 모델링됩니다.

o 작동 상태: 적용된 구성과 시스템 상태의 조합입니다.

o 작동 상태 데이터 저장소: 장치의 전체 작동 상태를 보관하는 데이터 저장소입니다. 이 데이터스토어를 "<운영\>"이라고 합니다.

o 출처: 데이터의 출처를 나타내는 메타데이터 주석입니다.

- 데이터 항목.

o 잔여 구성: 의도한 구성 또는 동적 구성에서 제거된 후에도 일정 기간 동안 적용된 구성의 일부로 남아 있는 구성입니다. 이 기간은 새로 삭제된 구성\(예: 네트워크 연결, 메모리 할당, 파일 핸들\)에서 사용하는 모든 리소스가 할당 취소될 때까지 최소일 수도 있고 지속될 수도 있습니다.

다음 추가 용어는 데이터 저장소에 국한되지 않지만 일반적으로 사용되므로 여기에서도 정의됩니다.

o 클라이언트: 일부 네트워크 관리 프로토콜을 통해 서버의 YANG 정의 데이터에 액세스할 수 있는 엔터티입니다.

o 서버: 일부 네트워크 관리 프로토콜을 통해 클라이언트에게 YANG 정의 데이터에 대한 액세스를 제공하는 엔터티입니다.

o 알림: 서버가 특정 이벤트를 인식했음을 나타내는 서버 시작 메시지입니다.

o 원격 프로시저 호출: 서버의 클라이언트가 호출할 수 있는 작업입니다.

---
## **4.  Background**

NETCONF \[RFC6241\]은 다음과 같은 정의를 제공합니다.

o 데이터 저장소: 정보를 저장하고 액세스하는 개념적 장소입니다. 예를 들어, 데이터 저장소는 파일, 데이터베이스, 플래시 메모리 위치 또는 이들의 조합을 사용하여 구현될 수 있습니다.

o 구성 데이터 저장소: 장치를 초기 기본 상태에서 원하는 작동 상태로 전환하는 데 필요한 전체 구성 세트를 보유하는 데이터 저장소입니다.

YANG 1.1 \[RFC7950\]은 NETCONF를 YANG과 함께 사용할 때 다음과 같은 개선 사항을 제공합니다\(일반적인 경우이지만 NETCONF는 YANG이 존재하기 전에 정의되었습니다\).

o 데이터 저장소: YANG으로 모델링할 때 데이터 저장소는 인스턴스화된 데이터 트리로 구현됩니다.

o 구성 데이터 저장소: YANG으로 모델링할 때 구성 데이터 저장소는 구성이 포함된 인스턴스화된 데이터 트리로 실현됩니다.

\[RFC6244\]는 작동 상태 데이터를 다음과 같이 정의했습니다.

o 작동 상태 데이터는 시스템이 런타임 시 획득한 데이터 세트이며 구성 데이터와 유사한 시스템 동작에 영향을 미칩니다. 구성 데이터와 달리 작동 상태는 일시적이며 특수 프로토콜을 통한 내부 구성 요소 또는 기타 시스템과의 상호 작용에 의해 수정됩니다.

\[RFC6244\]의 섹션 4.3.3에서는 작동 상태를 논의하고 무엇보다도 작동 상태를 다른 데이터 저장소에 저장되는 것으로 간주하는 옵션에 대해 언급합니다. 그런 다음 \[RFC6244\]의 섹션 4.4에서는 작성 당시 상태를 별개의 리프와 별개의 가지로 모델링하는 것이 권장되는 접근 방식이라고 결론지었습니다.

구현 경험 및 운영자 \[OpState-Reqs\] \[OpState-Modeling\]의 요청은 처음에 NETCONF용으로 설계되고 YANG에 의해 개선된 데이터 저장소 모델을 확장해야 함을 나타냅니다. 특히, 의도된 구성과 적용되는 구성에 대한 개념이 발전했습니다.

---
### **4.1.  Original Model of Datastores**

다음 그림은 현재 NETCONF \[RFC6241\]에서 사용되는 데이터 저장소의 원래 모델을 보여줍니다.

```text
          +-------------+                 +-----------+
          | <candidate> |                 | <startup> |
          |  (ct, rw)   |<---+       +--->| (ct, rw)  |
          +-------------+    |       |    +-----------+
                 |           |       |           |
                 |         +-----------+         |
                 +-------->| <running> |<--------+
                           | (ct, rw)  |
                           +-----------+
                                 |
                                 v
                          operational state  <--- control plane
                              (cf, ro)

          ct = config true; cf = config false
          rw = read-write; ro = read-only
          boxes denote datastores

                                 Figure 1
```

이 다이어그램은 모델을 단순화합니다. "읽기 전용"\(ro\) 및 "읽기-쓰기"\(rw\)는 개념적 수준에서 클라이언트의 관점에서 이해되어야 합니다. 예를 들어 NETCONF에서 <candidate\> 및 <startup\>에 대한 지원은 선택 사항이며 <running\>은 쓰기 가능하지 않아도 됩니다. 또한 <startup\>은 표준화된 NETCONF 데이터 저장소 편집 모델에서 <running\>을 <startup\>으로 복사해야만 수정할 수 있습니다. RESTCONF 프로토콜은 이러한 차이점을 노출하지 않고 대신 쓰기 가능한 통합 데이터 저장소만 제공합니다. 이는 편집이 <candidate\>를 통해 수행되는지, <running\>을 직접 수정하여 또는 기타 구현별 메커니즘을 통해 수행되는지 여부를 숨깁니다. RESTCONF는 구성이 지속되는 방법도 숨깁니다. 구현에는 <running\>에 변경 사항을 전파할 수 있는 추가 데이터 저장소가 있을 수도 있습니다. NETCONF는 소위 "명명된 데이터 저장소"를 명시적으로 언급합니다.

```text
   Some observations:
```

o 과거에 작동 상태 데이터 저장소를 도입하라는 제안이 있었지만 작동 상태는 데이터 저장소로 정의되지 않았습니다.

o NETCONF <get\> 작업은 작동 상태와 함께 <running\> 내용을 반환합니다. 따라서 작동 상태가 구성과 다른 수명을 가질 수 있거나 구성이 즉시 또는 성공적으로 적용되지 않는 경우 "config false" 데이터는 "config true" 데이터와 다른 분기에 있어야 합니다.

o 여러 구현에는 클라이언트가 <running\>에 비활성 데이터를 저장할 수 있는 독점 메커니즘이 있습니다. 비활성 데이터는 검증 전에 개념적으로 제거됩니다.

o 일부 구현에는 클라이언트가 <running\>에서 구성 템플릿을 정의할 수 있는 독점 메커니즘이 있습니다. 이러한 템플릿은 시스템에 의해 자동으로 확장되며 결과 구성은 내부적으로 적용됩니다.

o 일부 운영자는 실제로 성공적으로 적용된 구성\(<running\> 구성의 하위 집합 또는 상위 집합일 수 있음\)을 검색할 수 있는 것이 필수적이라고 보고했습니다.

---
## **5.  Architectural Model of Datastores**

아래는 원래 모델에서 얻은 경험을 반영하기 위해 원래 모델을 확장한 데이터 저장소의 새로운 개념적 모델입니다.

```text
     +-------------+                 +-----------+
     | <candidate> |                 | <startup> |
     |  (ct, rw)   |<---+       +--->| (ct, rw)  |
     +-------------+    |       |    +-----------+
            |           |       |           |
            |         +-----------+         |
            +-------->| <running> |<--------+
                      | (ct, rw)  |
                      +-----------+
                            |
                            |        // configuration transformations,
                            |        // e.g., removal of nodes marked as
                            |        // "inactive", expansion of
                            |        // templates
                            v
                      +------------+
                      | <intended> | // subject to validation
                      | (ct, ro)   |
                      +------------+
                            |        // changes applied, subject to
                            |        // local factors, e.g., missing
                            |        // resources, delays
                            |
       dynamic              |   +-------- learned configuration
       configuration        |   +-------- system configuration
       datastores -----+    |   +-------- default configuration
                       |    |   |
                       v    v   v
                    +---------------+
                    | <operational> | <-- system state
                    | (ct + cf, ro) |
                    +---------------+

     ct = config true; cf = config false
     rw = read-write; ro = read-only
     boxes denote named datastores

                                 Figure 2
```

---
### **5.1.  Conventional Configuration Datastores**

기존 구성 데이터 저장소는 정확히 동일한 데이터 저장소 스키마를 공유하여 데이터 저장소 간에 데이터를 복사할 수 있는 구성 데이터 저장소 집합입니다. 이 용어는 이러한 데이터 저장소에 대한 일반적인 포괄적인 설명을 의미합니다. 모듈에 구성 데이터 노드가 포함되어 있지 않고 가져오기를 충족하는 데 필요하지 않은 경우 기존 구성 데이터 저장소에 대한 데이터 저장소 스키마에서 모듈을 생략할 수 있습니다. 데이터 저장소 세트에는 다음이 포함됩니다.\(MAY\)

```text
   o  <running>

   o  <candidate>

   o  <startup>

   o  <intended>
```

다른 기존 구성 데이터 저장소는 향후 문서에서 정의될 수 있습니다.

이러한 데이터 저장소 간의 데이터 흐름은 섹션 5에 설명되어 있습니다.

특정 프로토콜은 이러한 데이터 저장소 간에 복사하기 위한 명시적 작업을 정의할 수 있습니다. 예를 들어 NETCONF는 <copy-config\> 작업을 정의합니다.

---
#### **5.1.1.  The Startup Configuration Datastore (<startup>)**

시작 구성 데이터 저장소\(<startup\>\)는 부팅 시 디바이스에서 로드한 구성을 보관하는 구성 데이터 저장소입니다. <startup\>은 실행 중인 구성 데이터 저장소에서 시작 구성을 분리하는 장치에만 존재합니다.

시작 구성 데이터 저장소는 모든 프로토콜이나 구현에서 지원되지 않을 수 있습니다.

비휘발성 저장소를 지원하는 장치에서 <startup\>의 내용은 일반적으로 해당 저장소를 통해 재부팅해도 유지됩니다. 부팅 시 장치는 저장된 시작 구성을 <running\>으로 로드합니다. 새로운 시작 구성을 저장하기 위해 암시적 또는 명시적 프로토콜 작업을 통해 데이터가 <startup\>에 복사됩니다.

---
#### **5.1.2.  The Candidate Configuration Datastore (<candidate>)**

```text
   The candidate configuration datastore (<candidate>) is a
   configuration datastore that can be manipulated without impacting the
   device's current configuration and that can be committed to
   <running>.
```

후보 구성 데이터 저장소는 일부 프로토콜이나 구현에서 지원되지 않을 수 있습니다.

```text
   <candidate> does not typically persist across reboots, even in the
   presence of non-volatile storage.  If <candidate> is stored using
   non-volatile storage, it is reset at boot time to the contents of
   <running>.
```

---
#### **5.1.3.  The Running Configuration Datastore (<running>)**

실행 중인 구성 데이터 저장소\(<running\>\)는 디바이스의 현재 구성을 보유하는 구성 데이터 저장소입니다. 여기에는 적용하기 전에 추가 변환이 필요한 구성\(예: 비활성 구성 또는 추가 확장이 필요한 템플릿 메커니즘 지향 구성\)이 포함될 수 있습니다. 그러나 <running\>은 \[RFC7950\]의 섹션 8.1에 정의된 대로 항상 유효한 구성 데이터 트리여야 합니다.\(MAY, MUST\)

<running\>은 장치가 기존 구성 데이터 저장소를 통해 구성될 수 있는 경우 지원되어야 합니다.\(MUST\)

장치에 고유한 <startup\>이 없고 비휘발성 저장소를 사용할 수 있는 경우 장치는 일반적으로 해당 비휘발성 저장소를 사용하여 재부팅 후에도 <running\>이 ​​지속되도록 허용합니다.

---
#### **5.1.4.  The Intended Configuration Datastore (<intended>)**

의도된 구성 데이터 저장소\(<intended\>\)는 읽기 전용 구성 데이터 저장소입니다. <running\>으로의 모든 구성 변환\(예: 템플릿 확장, 비활성 구성 제거\)이 수행된 후의 구성을 나타내며 시스템이 적용하려고 시도하는 구성입니다.

```text
   <intended> is tightly coupled to <running>.  Whenever data is written
   to <running>, the server MUST also immediately update and validate
   <intended>.
```

<intended\>는 구성 변환의 효과가 변경되는 경우 <running\>과 독립적으로 업데이트될 수도 있지만 <intended\>는 \[RFC7950\]의 섹션 8.1에 정의된 대로 항상 유효한 구성 데이터 트리여야 합니다.\(MUST\)

간단한 구현의 경우 <running\>과 <intended\>는 동일합니다.

```text
   The contents of <intended> are also related to the "config true"
   subset of <operational>; hence, a client can determine to what extent
   the intended configuration is currently in use by checking to see
   whether the contents of <intended> also appear in <operational>.
```

<의도\>는 재부팅 후에도 지속되지 않습니다. <running\>과의 관계는 불필요합니다.

현재 <의도\>에 영향을 주어 <실행\>과 다른 내용을 갖도록 정의된 표준 메커니즘이 없지만 이 아키텍처에서는 그러한 메커니즘을 정의할 수 있습니다.

```text
   One example of such a mechanism is support for marking nodes as
   inactive in <running>.  Inactive nodes are not copied to <intended>.
   A second example is support for templates, which can perform
   transformations on the configuration from <running> to the
   configuration written to <intended>.
```

---
### **5.2.  Dynamic Configuration Datastores**

```text
   The model recognizes the need for dynamic configuration datastores
   that are, by definition, not part of the persistent configuration of
   a device.  In some contexts, these have been termed "ephemeral
   datastores", since the information is ephemeral, i.e., lost upon
   reboot.  The dynamic configuration datastores interact with the rest
   of the system through <operational>.
```

동적 구성 데이터 저장소의 데이터 저장소 스키마는 기존 구성 데이터 저장소에 사용되는 데이터 저장소 스키마와 다를 수 있습니다. 모듈에 구성 데이터 노드가 포함되어 있지 않고 가져오기를 충족하는 데 필요하지 않은 경우 동적 구성 데이터 저장소에 대한 데이터 저장소 스키마에서 모듈이 생략될 수 있습니다.\(MAY, MAY\)

---
### **5.3.  The Operational State Datastore (<operational>)**

작동 상태 데이터 저장소\(<operal\>\)는 데이터 저장소의 스키마에 정의된 모든 "config true" 및 "config false" 노드로 구성된 읽기 전용 데이터 저장소입니다. 원래 NETCONF 모델에서는 작동 상태에 "config false" 노드만 있었습니다. 여기에 "config true" 노드를 통합하는 이유는 데이터 모델에서 정의를 복제할 필요 없이 모든 운영 설정을 노출할 수 있기 때문입니다.

<운영\>에는 시스템 상태와 시스템에서 실제로 사용하는 모든 구성이 포함됩니다. 여기에는 <intended\>에서 적용된 모든 구성, 학습된 구성, 시스템 제공 구성 및 지원되는 데이터 모델에서 정의된 기본값이 포함됩니다. 또한 <운영\>에는 동적 구성 데이터 저장소의 적용된 구성도 포함됩니다.

<운영\>에 대한 데이터 저장소 스키마는 구성 데이터 저장소에서 지원되는 구성 데이터 노드가 서버가 이를 정확하게 보고할 수 없는 경우 <운영\>에서 생략될 수 있다는 점을 제외하고 모든 구성 데이터 저장소에 사용되는 결합된 데이터 저장소 스키마의 상위 집합이어야 합니다.\(MUST\)

<운영\>에서 노드를 검색하라는 요청은 YANG 모듈에 지정된 기본값에 관계없이 노드가 존재하는 경우 항상 사용 중인 값을 반환합니다. 지정된 노드에 대해 값이 반환되지 않으면 이는 해당 노드가 장치에서 사용되지 않음을 의미합니다.

```text
   The interpretation of what constitutes being "in use" by the system
   is dependent on both the schema definition and the device
   implementation.  Generally, functionality that is enabled and
   operational on the system would be considered to be "in use".
   Conversely, functionality that is neither enabled nor operational on
   the system is considered not to be "in use"; hence, it SHOULD be
   omitted from <operational>.
```

<Operational\>은 데이터 모델에 지정된 모든 제약 조건을 준수해야 하지만 "사용 중" 값을 반환하는 주요 목적을 고려할 때 일부 상황에서는 제약 조건을 위반할 수 있습니다\(예: 비정상적인 값이 "사용 중", 목록의 구조가 수정 중이거나 남은 구성\(섹션 5.3.1 참조\)이 여전히 존재합니다. 장치가 <운영\> 스키마를 완전히 준수하지 않는다는 것이 미리 알려진 경우 편차를 사용해야 합니다.\(SHOULD, SHOULD\)

의미론적 제약만 위반할 수 있습니다. 이는 YANG "언제", "반드시", "필수", "고유", "최소 요소" 및 "최대 요소" 문입니다. 그리고 핵심 가치의 고유성.\(MAY\)

계층적 구성, 식별자 및 유형 기반 제약 조건을 포함하여 구문 제약 조건을 위반해서는 안 됩니다. <Operational\>의 노드가 구문 제약 조건을 충족하지 않으면 반환되어서는 안 되며, 다른 메커니즘을 사용하여 오류를 표시해야 합니다.\(MUST NOT, MUST NOT\)

<운영\>은 재부팅 후에도 지속되지 않습니다.

---
#### **5.3.1.  Remnant Configuration**

구성 변경 사항이 <운영\>에 적용되는 데 시간이 걸릴 수 있습니다. 이 기간 동안 <작동\>에는 이전 구성과 현재 구성 모두에 대한 노드가 포함될 수 있으며 장치의 현재 작동을 최대한 밀접하게 추적합니다. 이전 구성의 남은 구성은 시스템이 새로 삭제된 구성\(예: 네트워크 연결, 메모리 할당, 파일 핸들\)에서 사용하는 리소스를 해제할 때까지 유지됩니다.

잔여 구성은 <운영\>에 대해 데이터 모델에 정의된 의미적 제약 조건을 신뢰할 수 없는 일반적인 예입니다. 시스템에 이전 구성에서는 유효했지만 현재 구성에서는 유효하지 않은 제약 조건이 있는 잔여 구성이 있을 수 있기 때문입니다. "config false" 노드에 대한 제약 조건은 "config true" 노드를 참조할 수 있으므로 나머지 구성으로 인해 해당 제약 조건이 위반될 수 있습니다.

---
#### **5.3.2.  Missing Resources**

```text
   Configuration in <intended> can refer to resources that are not
   available or otherwise not physically present.  In these situations,
   these parts of <intended> are not applied.  The data appears in
   <intended> but does not appear in <operational>.

   A typical example is an interface configuration that refers to an
   interface that is not currently present.  In such a situation, the
   interface configuration remains in <intended> but the interface
   configuration will not appear in <operational>.

   Note that configuration validity cannot depend on the current state
   of such resources, since that would imply that removing a resource
   might render the configuration invalid.  This is unacceptable,
   especially given that rebooting such a device would cause it to
   restart with an invalid configuration.  Instead, we allow
   configuration for missing resources to exist in <running> and
   <intended>, but it will not appear in <operational>.
```

---
#### **5.3.3.  System-Controlled Resources**

때로는 리소스가 장치에 의해 제어되고 해당 시스템 제어 데이터가 <운영\>에 동적으로 나타나거나 사라집니다. 시스템 제어 리소스가 나타날 때 <의도\>에 일치하는 구성이 있는 경우 시스템은 해당 구성을 적용하려고 시도합니다. 이로 인해 구성이 결국 <operal\>에 표시됩니다\(구성 적용이 성공한 경우\).

---
#### **5.3.4.  Origin Metadata Annotation**

구성이 <Operational\>로 유입되면 개념적으로 해당 출처를 나타내는 메타데이터 주석 \[RFC7952\]이 표시됩니다. 원본은 존재하지 않는 컨테이너를 제외한 모든 구성 노드에 적용됩니다. "원본" 메타데이터 주석은 섹션 7에 정의되어 있습니다. 값은 YANG ID입니다. 다음 ID가 정의됩니다.

o 원산지: 다른 원산지 아이덴티티가 파생되는 추상 기본 아이덴티티.

```text
   o  intended: represents configuration provided by <intended>.
```

o 동적: 동적이 제공하는 구성을 나타냅니다.

- 구성 데이터 저장소.

o 시스템: 시스템 자체에서 제공하는 구성을 나타냅니다. 시스템 구성의 예로는 항상 존재하는 루프백 인터페이스에 적용되는 구성이나 현재 장치에 존재하는 하드웨어로 인해 자동 생성되는 인터페이스 구성이 있습니다.

o 학습됨: 링크 계층 협상, 라우팅 프로토콜 및 DHCP와 같은 프로토콜을 포함하여 다른 시스템과의 프로토콜 상호 작용을 통해 학습된 구성을 나타냅니다.

o 기본값: "기본" 문에 있는 값이나 "설명" 문에 설명된 값을 사용하여 데이터 모델에 지정된 기본값을 사용하여 구성을 나타냅니다. 기본 원본은 다른 소스에서 구성을 제공하지 않은 경우에만 사용됩니다.

o 알 수 없음: 시스템이 원본을 식별할 수 없는 구성을 나타냅니다.

이러한 ID는 더욱 구체화될 수 있습니다. 예를 들어 "동적"에서 파생된 동적 구성 데이터 저장소의 특정 유형이나 인스턴스에 대해 별도의 ID가 있을 수 있습니다.

<운영\>의 모든 구성 데이터 노드에 대해 장치는 시스템에서 사용 중인 구성의 소스를 가장 정확하게 반영하는 원본을 보고해야 합니다.\(SHOULD\)

어떤 출처를 사용해야 하는지 모호할 수 있는 경우, 즉 동일한 데이터 노드 값이 여러 소스에서 유래한 경우 YANG 모듈의 "설명" 문을 적절한 출처를 선택하기 위한 지침으로 사용해야 합니다. 예를 들어:\(SHOULD\)

특정 구성 노드에 대해 연관된 YANG "설명" 문이 프로토콜 협상 값이 구성된 값보다 우선한다는 것을 나타내는 경우 학습된 값이 구성된 값과 동일한 경우에도 원본은 "학습됨"으로 보고됩니다. .

반대로, 특정 구성 노드의 경우 관련 YANG "설명" 문이 프로토콜 협상 값이 명시적으로 구성된 값을 재정의하지 않는다는 것을 나타내는 경우 학습된 값이 구성된 값과 동일합니다.

장치가 특정 구성 데이터 노드에 대해 정확한 출처를 제공할 수 없는 경우 '알 수 없음' 출처를 사용해야 합니다.\(SHOULD\)

---
## **6.  Implications on YANG**
---
### **6.1.  XPath Context**

이 섹션에서는 RFC 7950의 섹션 6.4.1을 업데이트합니다.

서버가 이 문서에 정의된 아키텍처를 구현하는 경우 일부 XPath 컨텍스트에 대한 액세스 가능한 트리는 다음과 같이 구체화됩니다.

o XPath 표현식이 시스템 상태를 나타내는 데이터 노드에 대한 하위 설명에 정의된 경우 액세스 가능한 트리는 서버의 모든 작동 상태입니다. 루트 노드는 모든 모듈의 모든 최상위 데이터 노드를 하위 노드로 갖습니다.

o XPath 표현식이 하위 설명에 정의된 경우

- "알림" 문, 액세스 가능한 트리는 알림 인스턴스와 서버의 모든 작동 상태입니다. 알림이 모듈의 최상위 수준에 정의된 경우 루트 노드에는 정의 중인 알림을 나타내는 노드와 모든 모듈의 모든 최상위 데이터 노드가 하위 노드로 포함됩니다. 그렇지 않으면 루트 노드는 모든 모듈의 모든 최상위 데이터 노드를 자식으로 갖습니다.

o XPath 표현식이 "rpc" 또는 "action" 문의 "input" 문에 대한 하위 문으로 정의된 경우 액세스 가능한 트리는 RPC 또는 작업 작업 인스턴스와 서버의 모든 작동 상태입니다. 루트 노드에는 모든 모듈의 최상위 데이터 노드가 하위로 있습니다. 또한 RPC의 경우 루트 노드에는 하위로 정의되는 RPC 작업을 나타내는 노드도 있습니다. 정의 중인 작업을 나타내는 노드에는 해당 작업의 입력 매개변수가 자식으로 포함됩니다.

o XPath 표현식이 "rpc" 또는 "action" 문의 "output" 문에 대한 하위 문으로 정의된 경우 액세스 가능한 트리는 RPC 또는 작업 작업 인스턴스와 서버의 모든 작동 상태입니다. 루트 노드에는 모든 모듈의 최상위 데이터 노드가 하위로 있습니다. 또한 RPC의 경우 루트 노드에는 하위로 정의되는 RPC 작업을 나타내는 노드도 있습니다. 정의되는 작업을 나타내는 노드는 작업의 출력 매개변수를 하위로 갖습니다.

---
### **6.2.  Invocation of Actions and RPCs**

이 섹션에서는 RFC 7950의 섹션 7.15를 업데이트합니다.

작업은 항상 작동 상태 데이터 저장소의 컨텍스트에서 호출됩니다. 작업이 호출되는 노드는 작동 상태 데이터 저장소에 존재해야 합니다.\(MUST\)

이 문서는 어떤 방식으로든 RPC 또는 작업 호출 결과를 제한하지 않습니다. 예를 들어 일부 데이터 저장소의 콘텐츠를 수정하기 위해 RPC를 정의할 수 있습니다.

---
## **7.  YANG Modules**

```text
   <CODE BEGINS> file "ietf-datastores@2018-02-14.yang"

   module ietf-datastores {
     yang-version 1.1;
     namespace "urn:ietf:params:xml:ns:yang:ietf-datastores";
     prefix ds;

     organization
       "IETF Network Modeling (NETMOD) Working Group";

     contact
       "WG Web:   <https://datatracker.ietf.org/wg/netmod/>

        WG List:  <mailto:netmod@ietf.org>

        Author:   Martin Bjorklund
                  <mailto:mbj@tail-f.com>

        Author:   Juergen Schoenwaelder
                  <mailto:j.schoenwaelder@jacobs-university.de>

        Author:   Phil Shafer
                  <mailto:phil@juniper.net>

        Author:   Kent Watsen
                  <mailto:kwatsen@juniper.net>

        Author:   Rob Wilton
                  <rwilton@cisco.com>";
```

설명

- "이 YANG 모듈은 데이터 저장소를 식별하기 위한 일련의 ID를 정의합니다.

- Copyright \(c\) 2018 IETF Trust 및 코드 작성자로 식별된 사람. 판권 소유.

- 수정 여부에 관계없이 소스 및 바이너리 형식의 재배포 및 사용은 IETF 문서와 관련된 IETF Trust 법률 조항 섹션 4.c에 명시된 Simplified BSD 라이센스에 포함된 라이센스 조건에 따라 허용됩니다. \(https://trustee.ietf.org/license-info\).

```text
        This version of this YANG module is part of RFC 8342
        (https://www.rfc-editor.org/info/rfc8342); see the RFC itself
        for full legal notices.";

     revision 2018-02-14 {
       description
         "Initial revision.";
       reference
         "RFC 8342: Network Management Datastore Architecture (NMDA)";
     }

     /*
      * Identities
      */

     identity datastore {
       description
         "Abstract base identity for datastore identities.";
     }

     identity conventional {
       base datastore;
       description
         "Abstract base identity for conventional configuration
          datastores.";
     }

     identity running {
       base conventional;
       description
         "The running configuration datastore.";
     }

     identity candidate {
       base conventional;
       description
         "The candidate configuration datastore.";
     }

     identity startup {
       base conventional;
       description
         "The startup configuration datastore.";
     }

     identity intended {
       base conventional;
       description
         "The intended configuration datastore.";
     }

     identity dynamic {
       base datastore;
       description
         "Abstract base identity for dynamic configuration datastores.";
     }

     identity operational {
       base datastore;
       description
         "The operational state datastore.";
     }

     /*
      * Type definitions
      */

     typedef datastore-ref {
       type identityref {
         base datastore;
       }
       description
         "A datastore identity reference.";
     }
   }

   <CODE ENDS>

   <CODE BEGINS> file "ietf-origin@2018-02-14.yang"

   module ietf-origin {
     yang-version 1.1;
     namespace "urn:ietf:params:xml:ns:yang:ietf-origin";
     prefix or;

     import ietf-yang-metadata {
       prefix md;
     }

     organization
       "IETF Network Modeling (NETMOD) Working Group";

     contact
       "WG Web:   <https://datatracker.ietf.org/wg/netmod/>

        WG List:  <mailto:netmod@ietf.org>

        Author:   Martin Bjorklund
                  <mailto:mbj@tail-f.com>

        Author:   Juergen Schoenwaelder
                  <mailto:j.schoenwaelder@jacobs-university.de>

        Author:   Phil Shafer
                  <mailto:phil@juniper.net>

        Author:   Kent Watsen
                  <mailto:kwatsen@juniper.net>

        Author:   Rob Wilton
                  <rwilton@cisco.com>";
```

설명

- "이 YANG 모듈은 '원본' 메타데이터 주석과 원본 값에 대한 ID 세트를 정의합니다.

- Copyright \(c\) 2018 IETF Trust 및 코드 작성자로 식별된 사람. 판권 소유.

- 수정 여부에 관계없이 소스 및 바이너리 형식의 재배포 및 사용은 IETF 문서와 관련된 IETF Trust 법률 조항 섹션 4.c에 명시된 Simplified BSD 라이센스에 포함된 라이센스 조건에 따라 허용됩니다. \(https://trustee.ietf.org/license-info\).

```text
        This version of this YANG module is part of RFC 8342
        (https://www.rfc-editor.org/info/rfc8342); see the RFC itself
        for full legal notices.";

     revision 2018-02-14 {
       description
         "Initial revision.";
       reference
         "RFC 8342: Network Management Datastore Architecture (NMDA)";
     }

     /*
      * Identities
      */

     identity origin {
       description
         "Abstract base identity for the origin annotation.";
     }

     identity intended {
       base origin;
       description
         "Denotes configuration from the intended configuration
          datastore.";
     }

     identity dynamic {
       base origin;
       description
         "Denotes configuration from a dynamic configuration
          datastore.";
     }
```

신원 시스템 {

- 기본 원산지; 설명 "시스템 자체에서 시작된 구성을 나타냅니다.

```text
          Examples of system configuration include applied configuration
          for an always-existing loopback interface, or interface
          configuration that is auto-created due to the hardware
          currently present in the device.";
     }
```

배운 신원 {

- 기본 원산지; 설명 "의도된 구성 데이터 저장소나 동적 구성 데이터 저장소를 통하는 대신 다른 장치와의 프로토콜 상호 작용을 통해 학습된 구성을 나타냅니다.

```text
          Examples of protocols that provide learned configuration
          include link-layer negotiations, routing protocols, and
          DHCP.";
     }

     identity default {
       base origin;
       description
         "Denotes configuration that does not have a configured or
          learned value but has a default value in use.  Covers both
          values defined in a 'default' statement and values defined
          via an explanation in a 'description' statement.";
     }

     identity unknown {
       base origin;
       description
         "Denotes configuration for which the system cannot identify the
          origin.";
     }

     /*
      * Type definitions
      */

     typedef origin-ref {
       type identityref {
         base origin;
       }
       description
         "An origin identity reference.";
     }

     /*
      * Metadata annotations
      */

     md:annotation origin {
       type origin-ref;
       description
         "The 'origin' annotation can be present on any configuration
          data node in the operational state datastore.  It specifies
          from where the node originated.  If not specified for a given
          configuration data node, then the origin is the same as the
          origin of its parent node in the data tree.  The origin for
          any top-level configuration data nodes must be specified.";
     }
   }

   <CODE ENDS>
```

---
## **8.  IANA Considerations**
---
### **8.1.  Updates to the IETF XML Registry**

이 문서는 "IETF XML 레지스트리" \[RFC3688\]에 두 개의 URI를 등록합니다. \[RFC3688\] 형식에 따라 다음과 같이 등록되었습니다.

URI: urn:ietf:params:xml:ns:yang:ietf-datastores

- 등록자 연락처: IESG. XML: 해당 없음; 요청된 URI는 XML 네임스페이스입니다.

URI: urn:ietf:params:xml:ns:yang:ietf-origin

- 등록자 연락처: IESG. XML: 해당 없음; 요청된 URI는 XML 네임스페이스입니다.

---
### **8.2.  Updates to the YANG Module Names Registry**

이 문서는 "YANG 모듈 이름" 레지스트리 \[RFC6020\]에 두 개의 YANG 모듈을 등록합니다. \[RFC6020\]의 형식에 따라 다음과 같이 등록되었습니다.

```text
      name:         ietf-datastores
      namespace:    urn:ietf:params:xml:ns:yang:ietf-datastores
      prefix:       ds
      reference:    RFC 8342
```

이름: ietf-origin

- 네임스페이스: urn:ietf:params:xml:ns:yang:ietf-origin 접두사: 또는 참조: RFC 8342

---
## **9.  Security Considerations**

이 문서에서는 NETCONF/RESTCONF 및 YANG을 사용하여 네트워크 관리를 위한 데이터 저장소의 아키텍처 모델을 설명합니다. 인터넷 보안에는 아무런 영향을 미치지 않습니다.

이 문서에서는 여러 YANG 모듈을 지정하지만 이러한 모듈은 ID와 메타데이터 주석만 정의합니다. 따라서 "YANG 모듈 보안 지침"\[YANG-SEC\]이 적용되지 않습니다.

원본 메타데이터 주석은 적용된 구성에 있는 값의 원본을 노출합니다. 원본 정보는 특정 제어 영역 프로토콜이 장치에서 활성화되어 있다는 힌트를 제공할 수 있습니다. 원본 정보는 적용된 구성 값과 연결되어 있으므로 적용된 구성 값을 읽을 수 있는 권한이 있는 클라이언트만 액세스할 수 있습니다. 보안 관리자는 액세스 제어 규칙을 정의하는 동안 원본 정보의 민감도를 고려해야 합니다.

---
## **10.  References**
---
### **10.1.  Normative References**

```text
   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", BCP 14, RFC 2119,
              DOI 10.17487/RFC2119, March 1997,
              <https://www.rfc-editor.org/info/rfc2119>.

   [RFC6241]  Enns, R., Ed., Bjorklund, M., Ed., Schoenwaelder, J., Ed.,
              and A. Bierman, Ed., "Network Configuration Protocol
              (NETCONF)", RFC 6241, DOI 10.17487/RFC6241, June 2011,
              <https://www.rfc-editor.org/info/rfc6241>.

   [RFC7950]  Bjorklund, M., Ed., "The YANG 1.1 Data Modeling Language",
              RFC 7950, DOI 10.17487/RFC7950, August 2016,
              <https://www.rfc-editor.org/info/rfc7950>.

   [RFC7952]  Lhotka, L., "Defining and Using Metadata with YANG",
              RFC 7952, DOI 10.17487/RFC7952, August 2016,
              <https://www.rfc-editor.org/info/rfc7952>.

   [RFC8040]  Bierman, A., Bjorklund, M., and K. Watsen, "RESTCONF
              Protocol", RFC 8040, DOI 10.17487/RFC8040, January 2017,
              <https://www.rfc-editor.org/info/rfc8040>.

   [RFC8174]  Leiba, B., "Ambiguity of Uppercase vs Lowercase in
              RFC 2119 Key Words", BCP 14, RFC 8174,
              DOI 10.17487/RFC8174, May 2017,
              <https://www.rfc-editor.org/info/rfc8174>.

   [W3C.REC-xml-20081126]
              Bray, T., Paoli, J., Sperberg-McQueen, M., Maler, E., and
              F. Yergeau, "Extensible Markup Language (XML) 1.0
              (Fifth Edition)", World Wide Web Consortium Recommendation
              REC-xml-20081126, November 2008,
              <https://www.w3.org/TR/2008/REC-xml-20081126>.
```

---
### **10.2.  Informative References**

\[NETMOD-작동\]

- Bjorklund, M. 및 L. Lhotka, "NETCONF 및 YANG의 운영 데이터", 진행 중인 작업, 초안-bjorklund-netmod-operative-00, 2012년 10월.

\[OpState-강화\]

- Watsen, K., Bierman, A., Bjorklund, M. 및 J. Schoenwaelder, "YANG, NETCONF 및 RESTCONF에 대한 운영 상태 향상", 진행 중인 작업,draft-kwatsen-netmod-opstate-02, 2016년 2월 .

\[OpState 모델링\]

- Shakir, R., Shaikh, A. 및 M. Hines, "YANG의 운영 상태 데이터에 대한 일관된 모델링", 진행 중인 작업, 초안-openconfig-netmod-opstate-01, 2015년 7월.

\[OpState-요구사항\]

- Watsen, K. 및 T. Nadeau, "운영 상태 처리 강화를 위한 용어 및 요구 사항", 진행 중인 작업, 초안-ietf-netmod-opstate-reqs-04, 2016년 1월.

```text
   [RFC3688]  Mealling, M., "The IETF XML Registry", BCP 81, RFC 3688,
              DOI 10.17487/RFC3688, January 2004,
              <https://www.rfc-editor.org/info/rfc3688>.

   [RFC6020]  Bjorklund, M., Ed., "YANG - A Data Modeling Language for
              the Network Configuration Protocol (NETCONF)", RFC 6020,
              DOI 10.17487/RFC6020, October 2010,
              <https://www.rfc-editor.org/info/rfc6020>.

   [RFC6244]  Shafer, P., "An Architecture for Network Management Using
              NETCONF and YANG", RFC 6244, DOI 10.17487/RFC6244,
              June 2011, <https://www.rfc-editor.org/info/rfc6244>.

   [RFC8343]  Bjorklund, M., "A YANG Data Model for Interface
              Management", RFC 8343, DOI 10.17487/RFC8343, March 2018,
              <https://www.rfc-editor.org/info/rfc8343>.

   [RFC8344]  Bjorklund, M., "A YANG Data Model for IP Management",
              RFC 8344, DOI 10.17487/RFC8344, March 2018,
              <https://www.rfc-editor.org/info/rfc8344>.
```

\[구성 상태 있음\]

- Wilton, R., "NETCONF/RESTCONF를 위한 "With-config-state" 기능", 진행 중인 작업, 초안-wilton-netmod-opstate-yang-02, 2015년 12월.

```text
   [YANG-SEC] IETF, "YANG Security Guidelines", <https://trac.ietf.org/
              trac/ops/wiki/yang-security-guidelines>.
```

---
# **Appendix A.  Guidelines for Defining Datastores**

이 아키텍처의 새 데이터 저장소 정의는 데이터 저장소 정의용 문서\(예: RFC\)에 제공되어야 합니다. 합리적인 경우 동일한 문서에 둘 이상의 데이터 저장소가 정의될 ​​수 있습니다\(예: 데이터 저장소가 논리적으로 연결된 경우\). 각 데이터 저장소의 정의는 아래 하위 섹션에 지정된 사항을 다루어야 합니다.

---
### **A.1.  Define Which YANG Modules Can Be Used in the Datastore**

모든 YANG 모듈이 모든 데이터 저장소에서 사용될 수 있는 것은 아닙니다. 일부 데이터 저장소는 사용할 수 있는 데이터 모델을 제한할 수 있습니다. 모든 모듈의 하위 집합이 데이터 저장소를 대상으로 하는 것이 바람직한 경우 데이터 저장소를 정의하는 문서에 이를 명시해야 합니다.

---
### **A.2.  Define Which Subset of YANG-Modeled Data Applies**

기본적으로 데이터 저장소의 데이터는 사용 가능한 YANG 모듈의 모든 YANG 문으로 모델링됩니다. 그러나 YANG 문이 데이터 저장소에 존재하기 위해 충족해야 하는 기준을 지정할 수 있습니다. 예를 들어, "config true" 노드 또는 특정 YANG 확장자를 가진 "config false" 노드만 데이터 저장소에 있을 수 있습니다.

---
### **A.3.  Define How Data Is Actualized**

새 데이터 저장소는 다른 데이터 저장소와 상호 작용하는 방법을 지정해야 합니다.

예를 들어 섹션 5의 다이어그램은 <운영\>에 공급되는 동적 구성 데이터 저장소를 보여줍니다. 이 상호 작용이 발생하는 방식은 특정 동적 구성 데이터 저장소에 의해 정의되어야 합니다. 어떤 경우에는 데이터가 동적 구성 데이터 저장소에 입력되자마자 암시적으로 발생할 수 있지만, 다른 경우에는 데이터 저장소의 데이터 적용을 트리거하기 위해 명시적인 작업\(예: RPC\)이 필요할 수 있습니다.

---
### **A.4.  Define Which Protocols Can Be Used**

기본적으로 NETCONF 및 RESTCONF 프로토콜을 모두 사용하여 데이터 저장소와 상호 작용할 수 있다고 가정합니다. 그러나 특정 프로토콜만 사용할 수 있거나\(예: ForCES\(전달 및 제어 요소 분리\)\) 모든 프로토콜 작업 또는 기능의 하위 집합을 사용할 수 있습니다\(예: 잠금 없음 또는 XPath 기반 필터링 없음\).

---
### **A.5.  Define YANG Identities for the Datastore**

데이터 저장소는 "ds:datastore" ID 또는 파생 ID 중 하나를 기본으로 사용하는 YANG ID로 정의되어야 합니다. 프로토콜 작업\(예: <get-data\>\)에서 데이터 저장소를 참조할 수 있으려면 이 ID가 필요합니다.

데이터 저장소는 "or:origin" ID 또는 파생 ID 중 하나를 기본으로 사용하는 ID로 정의될 수도 있습니다. 데이터 저장소가 <운영\>과 상호작용하는 경우 이 ID가 필요합니다. 그러면 데이터 저장소에서 발생하는 데이터는 섹션 7에 정의된 '원본' 메타데이터 속성을 통해 식별될 수 있습니다.

이러한 지침의 사용 예는 부록 B에 나와 있습니다.

---
# **Appendix B.  Example of an Ephemeral Dynamic Configuration Datastore**

이 섹션에서는 부록 A에 제공된 지침을 사용하여 예제 동적 구성 데이터 저장소에 대한 설명서를 정의합니다. 간결성을 위해 간단한 예제만 제공됩니다. 이러한 유형의 시나리오가 완전히 고려되면 독립형 RFC가 작성될 것으로 예상됩니다.

이 예에서는 I2RS Working Group에서 수행된 작업을 따라 느슨하게 모델링된 "ephemeral"이라는 동적 구성 데이터 저장소를 정의합니다.

```text
   +--------------------+----------------------------------------------+
   | Name               | Value                                        |
   +--------------------+----------------------------------------------+
   | Name               | ephemeral                                    |
   |                    |                                              |
   | YANG modules       | all (default)                                |
   |                    |                                              |
   | YANG nodes         | all "config true" data nodes                 |
   |                    |                                              |
   | How applied        | changes automatically propagated to          |
   |                    | <operational>                                |
   |                    |                                              |
   | Protocols          | NETCONF/RESTCONF (default)                   |
   |                    |                                              |
   | Defining YANG      | "example-ds-ephemeral"                       |
   | module             |                                              |
   +--------------------+----------------------------------------------+

              Properties of the Example "ephemeral" Datastore

   module example-ds-ephemeral {
     yang-version 1.1;
     namespace "urn:example:ds-ephemeral";
     prefix eph;

     import ietf-datastores {
       prefix ds;
     }
     import ietf-origin {
       prefix or;
     }

     // datastore identity
     identity ds-ephemeral {
       base ds:dynamic;
       description
         "The ephemeral dynamic configuration datastore.";
     }

     // origin identity
     identity or-ephemeral {
       base or:dynamic;
       description
         "Denotes data from the ephemeral dynamic configuration
          datastore.";
     }
   }
```

---
# **Appendix C.  Example Data**

데이터저장소의 사용은 복잡하며 많은 미묘한 효과는 예제를 사용하여 더 쉽게 표현됩니다. 이 섹션에서는 다양한 데이터 저장소의 일부 샘플 콘텐츠가 포함된 일련의 예제 데이터 모델을 제공합니다.

다음 XML \[W3C.REC-xml-20081126\] 조각은 예제로만 제공됩니다.

---
### **C.1.  System Example**

이 예에서는 다음 가상 모듈이 사용됩니다.

```text
   module example-system {
     yang-version 1.1;
     namespace urn:example:system;
     prefix sys;

     import ietf-inet-types {
       prefix inet;
     }

     container system {
       leaf hostname {
         type string;
       }

       list interface {
         key name;

         leaf name {
           type string;
         }

         container auto-negotiation {
           leaf enabled {
             type boolean;
             default true;
           }
           leaf speed {
             type uint32;
             units mbps;
             description
               "The advertised speed, in Mbps.";
           }
         }

         leaf speed {
           type uint32;
           units mbps;
           config false;
           description
             "The speed of the interface, in Mbps.";
         }

         list address {
           key ip;

           leaf ip {
             type inet:ip-address;
           }
           leaf prefix-length {
             type uint8;
           }
         }
       }
     }
   }
```

운영자가 호스트 이름과 두 개의 인터페이스를 구성했으므로 <intended\>의 내용은 다음과 같습니다.

```text
   <system xmlns="urn:example:system">

     <hostname>foo.example.com</hostname>

     <interface>
       <name>eth0</name>
       <auto-negotiation>
         <speed>1000</speed>
       </auto-negotiation>
       <address>
         <ip>2001:db8::10</ip>
         <prefix-length>64</prefix-length>
       </address>
     </interface>

     <interface>
       <name>eth1</name>
       <address>
         <ip>2001:db8::20</ip>
         <prefix-length>64</prefix-length>
       </address>
     </interface>

   </system>
```

시스템에서 구성된 인터페이스\("eth1"\) 중 하나에 대한 하드웨어가 아직 존재하지 않음을 감지하여 해당 인터페이스에 대한 구성이 적용되지 않습니다. 또한 시스템은 DHCP를 통해 "eth0"에 대한 호스트 이름과 추가 IP 주소를 수신했습니다. 자동 협상이 활성화된 리프의 기본값을 채우는 것 외에도 루프백 인터페이스 항목도 자동으로

시스템에 의해 인스턴스화됩니다. 이 모든 것이 <운영\>에 반영됩니다. 여러 "config true" 데이터 노드의 "origin" 메타데이터 속성이 상위 데이터 노드에서 상속되는 방식에 유의하세요.

```text
   <system
       xmlns="urn:example:system"
       xmlns:or="urn:ietf:params:xml:ns:yang:ietf-origin">

     <hostname or:origin="or:learned">bar.example.com</hostname>

     <interface or:origin="or:intended">
       <name>eth0</name>
       <auto-negotiation>
         <enabled or:origin="or:default">true</enabled>
         <speed>1000</speed>
       </auto-negotiation>
       <speed>100</speed>
       <address>
         <ip>2001:db8::10</ip>
         <prefix-length>64</prefix-length>
       </address>
       <address or:origin="or:learned">
         <ip>2001:db8::1:100</ip>
         <prefix-length>64</prefix-length>
       </address>
     </interface>

     <interface or:origin="or:system">
       <name>lo0</name>
       <address>
         <ip>::1</ip>
         <prefix-length>128</prefix-length>
       </address>
     </interface>

   </system>
```

---
### **C.2.  BGP Example**

가상 BGP 모듈의 다음 부분을 고려해보세요.

```text
       container bgp {
         leaf local-as {
           type uint32;
         }
         leaf peer-as {
           type uint32;
         }
         list peer {
           key name;
           leaf name {
             type inet:ip-address;
           }
           leaf local-as {
             type uint32;
             description
               "... Defaults to ../local-as.";
           }
           leaf peer-as {
             type uint32;
             description
               "... Defaults to ../peer-as.";
           }
           leaf local-port {
             type inet:port;
           }
           leaf remote-port {
             type inet:port;
             default 179;
           }
           leaf state {
             config false;
             type enumeration {
               enum init;
               enum established;
               enum closing;
             }
           }
         }
       }
```

이 예제 모델에서는 bgp/peer/local-as 및 bgp/peer/peer-as 모두 복잡한 계층적 값을 가지므로 사용자는 단일 위치에서 모든 피어에 대한 기본값을 지정할 수 있습니다.

또한 이 모델은 상태\("config false"\) 노드를 구성\("config true"\) 노드와 완전히 통합하는 패턴을 따릅니다. 포함 및 명명 노드가 반복되는 별도의 "bgp-state" 계층 구조는 없습니다. 이렇게 하면 모델이 더 간단해지고 읽기 쉬워집니다.

---
#### **C.2.1.  Datastores**

각 데이터스토어는 이러한 노드의 다양한 보기를 나타냅니다. <running\>은 운영자가 제공한 구성\(예: 단일 BGP 피어\)을 보유합니다. <intended\>는 유효성 검사를 위해 의도되지 않은 데이터를 제거한 후 로컬 템플릿 메커니즘이 수행된 후 개념적으로 데이터를 유효성이 검사된 대로 보유합니다. <operal\>은 <intended\>의 데이터와 "config false" 노드를 표시합니다.

---
#### **C.2.2.  Adding a Peer**

사용자가 단일 BGP 피어를 구성하면 해당 피어는 <running\> 및 <intended\> 모두에서 표시됩니다. 서버가 후보 구성 데이터 저장소를 지원하는 경우 <candidate\>에도 나타날 수 있습니다. 피어를 검색하면 사용자가 지정한 값만 반환됩니다.

```text
   No time delay should exist between the appearance of the peer in
   <running> and <intended>.
```

이 시나리오에서는 <running\>에 다음을 추가했습니다.

```text
     <bgp>
       <local-as>64501</local-as>
       <peer-as>64502</peer-as>
       <peer>
         <name>2001:db8::2:3</name>
       </peer>
     </bgp>
```

---
##### **C.2.2.1.  <operational>**

운영 데이터 저장소에는 "config false" 노드를 포함하여 완전히 확장된 피어 데이터가 포함됩니다. 이 예에서는 "상태" 노드가 나타납니다.

또한 <운영\>에는 모든 노드에 대한 "현재 사용 중" 값이 포함됩니다. 이는 <intended\>에 값이 지정되지 않은 경우에도 local-as 및 Peer-as가 채워짐을 의미합니다. bgp/peer/local-as가 제공되지 않으면 bgp/local-as 값이 사용됩니다. bgp/peer-as와 bgp/peer/peer-as는 동일한 관계를 갖습니다. \~ 안에

운영 보기에서는 해당 값이 명시적으로 구성되지 않았지만 bgp/local-as 및 bgp/peer-as에서 제공되는 경우에도 모든 피어가 local-as 및 Peer-as에 대한 값을 갖게 됨을 의미합니다.

각 BGP 피어에는 <의도\>의 로컬 포트 ​​및 원격 포트 값을 사용하여 연결된 TCP 연결이 있습니다. 해당 값이 제공되지 않으면 시스템이 값을 선택합니다. 연결이 설정되면 <Operational\>에는 원본에 관계없이 로컬 포트 ​​및 원격 포트 노드에 대한 현재 값이 포함됩니다. 시스템이 값을 선택한 경우 "origin" 속성은 "system"으로 설정됩니다. 연결이 설정되기 전에는 시스템에 해당 값이 아직 없기 때문에 노드 중 하나 또는 둘 다 표시되지 않을 수 있습니다.

```text
     <bgp xmlns:or="urn:ietf:params:xml:ns:yang:ietf-origin"
          or:origin="or:intended">
       <local-as>64501</local-as>
       <peer-as>64502</peer-as>
       <peer>
         <name>2001:db8::2:3</name>
         <local-as or:origin="or:default">64501</local-as>
         <peer-as or:origin="or:default">64502</peer-as>
         <local-port or:origin="or:system">60794</local-port>
         <remote-port or:origin="or:default">179</remote-port>
         <state>established</state>
       </peer>
     </bgp>
```

---
#### **C.2.3.  Removing a Peer**

구성 변경 사항이 관련된 다양한 소프트웨어 구성 요소를 통해 여과되는 데 시간이 걸릴 수 있습니다. 이 기간 동안 장치 작동에 대한 정확한 보기를 계속해서 제공하는 것이 중요합니다. <작동\>에는 이전 구성과 현재 구성 모두에 대한 노드가 포함되어 장치의 현재 작동을 최대한 밀접하게 추적합니다.

클라이언트가 BGP 피어를 제거하는 시나리오를 생각해 보세요. 피어가 제거되면 작동 상태는 피어의 연결 종료를 포함하여 피어의 리소스가 해제될 때까지 해당 피어의 존재를 계속 반영합니다. 이 기간 동안 현재 데이터 값은 원본 데이터의 출처를 나타내도록 설정된 "origin" 속성과 함께 <운영\>에 계속 표시됩니다.

```text
     <bgp xmlns:or="urn:ietf:params:xml:ns:yang:ietf-origin"
          or:origin="or:intended">
       <local-as>64501</local-as>
       <peer-as>64502</peer-as>
       <peer>
         <name>2001:db8::2:3</name>
         <local-as or:origin="or:default">64501</local-as>
         <peer-as or:origin="or:default">64502</peer-as>
         <local-port or:origin="or:system">60794</local-port>
         <remote-port or:origin="or:default">179</remote-port>
         <state>closing</state>
       </peer>
     </bgp>

   Once resources are released and the connection is closed, the peer's
   data is removed from <operational>.
```

---
### **C.3.  Interface Example**

이 섹션에서는 다음과 같은 간단한 인터페이스 데이터 모델을 사용합니다.

```text
     container interfaces {
       list interface {
         key name;
         leaf name {
           type string;
         }
         leaf description {
           type string;
         }
         leaf mtu {
           type uint16;
         }
         leaf-list ip-address {
           type inet:ip-address;
         }
       }
     }
```

---
#### **C.3.1.  Pre-provisioned Interfaces**

네트워킹 장치의 일반적인 문제 중 하나는 재부팅을 요구하거나 정상적인 작동을 방해하지 않고 장치에 삽입하고 제거할 수 있는 FRU\(현장 교체 가능 장치\) 지원입니다. 이러한 FRU는 일반적으로 인터페이스 카드이며 장치는 이러한 인터페이스의 사전 프로비저닝을 지원합니다.

클라이언트가 "et-0/0/0" 인터페이스를 생성했지만 이 시점에 인터페이스가 물리적으로 존재하지 않는 경우 <intended\>에는 다음이 포함될 수 있습니다.

```text
     <interfaces>
       <interface>
         <name>et-0/0/0</name>
         <description>Test interface</description>
       </interface>
     </interfaces>

   Since the interface does not exist, this data does not appear in
   <operational>.
```

이 인터페이스가 포함된 FRU를 삽입하면 시스템이 이를 감지하고 관련 구성을 처리합니다. <운영\>에는 <의도\>의 데이터와 인터페이스 MTU의 현재 값과 같이 시스템에서 추가한 노드가 포함됩니다.

```text
     <interfaces xmlns:or="urn:ietf:params:xml:ns:yang:ietf-origin"
                 or:origin="or:intended">
       <interface>
         <name>et-0/0/0</name>
         <description>Test interface</description>
         <mtu or:origin="or:system">1500</mtu>
       </interface>
     </interfaces>

   If the FRU is removed, the interface data is removed from
   <operational>.
```

---
#### **C.3.2.  System-Provided Interface**

```text
   Imagine that the system provides a loopback interface (named "lo0")
   with a default IPv4 address of "127.0.0.1" and a default IPv6 address
   of "::1".  The system will only provide configuration for this
   interface if there is no data for it in <intended>.
```

<intended\>에 "lo0"에 대한 구성이 나타나지 않으면 <operal\>은 시스템 제공 데이터를 표시합니다.

```text
     <interfaces xmlns:or="urn:ietf:params:xml:ns:yang:ietf-origin"
                 or:origin="or:intended">
       <interface or:origin="or:system">
         <name>lo0</name>
         <ip-address>127.0.0.1</ip-address>
         <ip-address>::1</ip-address>
       </interface>
     </interfaces>
```

"lo0"에 대한 구성이 <intended\>에 나타나면 <operal\>은 원본이 "intended"로 설정된 데이터를 표시합니다. "ip-address"가 제공되지 않으면 시스템 제공 값은 다음과 같이 나타납니다.

```text
     <interfaces xmlns:or="urn:ietf:params:xml:ns:yang:ietf-origin"
                 or:origin="or:intended">
       <interface>
         <name>lo0</name>
         <description>loopback</description>
         <ip-address or:origin="or:system">127.0.0.1</ip-address>
         <ip-address>::1</ip-address>
       </interface>
     </interfaces>
```

---
# **Acknowledgments**

이 문서는 2010년 이후 진행된 많은 논의에서 발전했습니다. 여러 문서\(\[NETMOD-Operational\] \[With-config-state\] \[OpState-Reqs\] \[OpState-Enhance\] \[OpState-Modeling\] 및 \[RFC6244\] \)에서는 원래 데이터 저장소 모델의 일부 문제를 다루었습니다. 다음 사람들은 진행 중인 작업의 저자이거나 이 문서를 작성하기 위한 토론에 적극적으로 참여했습니다.

```text
   o  Lou Berger, LabN Consulting, L.L.C., <lberger@labn.net>

   o  Andy Bierman, YumaWorks, <andy@yumaworks.com>

   o  Marcus Hines, Google, <hines@google.com>

   o  Christian Hopps, Deutsche Telekom, <chopps@chopps.org>

   o  Balazs Lengyel, Ericsson, <balazs.lengyel@ericsson.com>

   o  Ladislav Lhotka, CZ.NIC, <lhotka@nic.cz>

   o  Acee Lindem, Cisco Systems, <acee@cisco.com>

   o  Thomas Nadeau, Brocade Networks, <tnadeau@lucidvision.com>

   o  Tom Petch, Engineering Networks Ltd, <ietfc@btconnect.com>

   o  Anees Shaikh, Google, <aashaikh@google.com>

   o  Rob Shakir, Google, <robjs@google.com>

   o  Jason Sterne, Nokia, <jason.sterne@nokia.com>
```

Juergen Schoenwaelder는 제7차 프레임워크 프로그램에 따라 유럽연합 집행위원회가 지원하는 Network of Excellence 프로젝트\(ICT-318488\)인 Flamingo의 자금을 일부 지원받았습니다.

---
# **Authors' Addresses**

```text
   Martin Bjorklund
   Tail-f Systems

   Email: mbj@tail-f.com

   Juergen Schoenwaelder
   Jacobs University

   Email: j.schoenwaelder@jacobs-university.de

   Phil Shafer
   Juniper Networks

   Email: phil@juniper.net

   Kent Watsen
   Juniper Networks

   Email: kwatsen@juniper.net

   Robert Wilton
   Cisco Systems

   Email: rwilton@cisco.com
```
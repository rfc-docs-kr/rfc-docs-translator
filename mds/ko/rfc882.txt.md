

```text
Network Working Group                                     P. Mockapetris
Request for Comments:  882                                           ISI
                                                           November 1983

                 DOMAIN NAMES - CONCEPTS and FACILITIES

        +-----------------------------------------------------+
        |                                                     |
        | This RFC introduces domain style names, their use   |
        | for ARPA Internet mail and host address support,    |
        | and the protocols and servers used to implement     |
        | domain name facilities.                             |
        |                                                     |
        | This memo describes the conceptual framework of the |
        | domain system and some uses, but it omits many      |
        | uses, fields, and implementation details.  A        |
        | complete specification of formats, timeouts, etc.   |
        | is presented in RFC 883, "Domain Names -            |
        | Implementation and Specification".  That RFC        |
        | assumes that the reader is familiar with the        |
        | concepts discussed in this memo.                    |
        |                                                     |
        +-----------------------------------------------------+
```

---
# **INTRODUCTION**

도메인 이름의 필요성

- 애플리케이션이 여러 호스트, 네트워크, 최종적으로 인터넷으로 확장됨에 따라 이러한 애플리케이션은 여러 관리 경계 및 관련 작동 방법\(프로토콜, 데이터 형식 등\)에도 확장되어야 합니다. 유사하지만 환경 전체에 흩어져 있는 특정 리소스를 참조하기 위한 일관된 방법을 만들려고 할 때 리소스\(예: 사서함\) 수, 리소스 위치 수 및 이러한 환경의 다양성은 엄청난 문제를 야기합니다.

- ARPA 인터넷은 크기 관련 문제를 보여줍니다. 이는 대규모 시스템이므로 훨씬 더 커질 가능성이 높습니다. 호스트 이름\(예: USC-ISIF\)과 ARPA 인터넷 주소\(예: 10.2.0.52\) 간의 매핑이 필요하기 때문에 기존 메커니즘이 강조되기 시작했습니다. 현재 ARPA 인터넷의 호스트는 NIC\(Network Information Center\)에 등록되어 있으며 전역 테이블\(SRI-NIC 호스트에서 <NETINFO\>HOSTS.TXT 파일로 사용 가능\)에 나열되어 있습니다\[1\]. 이 테이블의 크기, 특히 테이블 업데이트 빈도는 관리 효율성의 한계에 가깝습니다. 필요한 것은 동일한 기능을 수행하여 중앙 집중식 데이터베이스로 인해 발생하는 문제를 방지하는 분산 데이터베이스입니다.

- 컴퓨터 메일의 문제는 더욱 심각하다. 메일 시스템 구현자들은 오래 전부터 중앙 집중화의 불가능함을 인식했지만

- 사서함 이름으로 인해 사서함 위치를 식별하는 방법이 점점 더 크고 불규칙해졌습니다. 이러한 방법 중 일부는 경로를 사용하고 호스트를 메일 대상 주소의 일부로 전달하므로 결과적으로 메일 사용자가 여러 주소 형식, 다양한 전달자의 기능 및 중개자를 통해 주소 사양을 전달하기 위한 임시 트릭을 알도록 합니다.

- 이러한 문제는 솔루션의 성격을 암시하는 공통된 특징을 가지고 있습니다.

- 기본적인 요구 사항은 리소스를 참조하는 데 사용되는 일관된 이름 공간입니다. 임시 인코딩으로 인해 발생하는 문제를 방지하려면 이름에 주소, 경로 또는 유사한 정보가 이름의 일부로 포함되어서는 안 됩니다.

- 데이터베이스의 엄청난 크기와 업데이트 빈도로 인해 성능을 향상하려면 로컬 캐싱을 사용하여 분산 방식으로 유지 관리해야 합니다. 전체 데이터베이스의 일관된 복사본을 수집하려는 접근 방식은 점점 더 비용이 많이 들고 어려워지므로 피해야 합니다. 이름 공간의 구조, 특히 이름을 생성하고 삭제하는 메커니즘에도 동일한 원칙이 적용됩니다. 이것들도 배포되어야 합니다.

- 이러한 기능을 구현하는 데 드는 비용은 일반적으로 유용하며 단일 응용 프로그램으로 제한되지 않음을 나타냅니다. 이름을 사용하여 호스트 주소, 메일함 데이터 및 기타 아직 결정되지 않은 정보를 검색할 수 있어야 합니다.

- 우리는 이름 공간이 서로 다른 네트워크에서 유용하기를 원하기 때문에 도메인 이름을 사용하는 모든 사용자가 이름을 사용하여 검색하는 리소스 또는 리소스 정보 세트에 동의할 가능성은 거의 없습니다. 따라서 이름은 리소스 집합을 참조하고 쿼리에는 리소스 식별자가 포함됩니다. 네임스페이스 전반에 걸쳐 볼 것으로 예상되는 유일한 표준 정보 유형은 네임스페이스 자체에 대한 구조적 정보와 비표준 데이터 없이 도메인 이름을 사용하여 설명되는 리소스입니다.

- 또한 우리는 네임 서버 트랜잭션이 이를 전달하는 통신 시스템과 독립적이기를 원합니다. 일부 시스템에서는 간단한 쿼리 및 응답에 데이터그램을 사용하고 신뢰성이 필요한 트랜잭션\(예: 데이터베이스 업데이트, 긴 트랜잭션\)에 대해서만 가상 회로를 설정하기를 원할 수 있습니다. 다른 시스템은 가상 회로를 독점적으로 사용합니다.

솔루션의 요소

- 제안된 솔루션은 세 가지 주요 구성 요소로 구성됩니다.

- 트리 구조의 네임스페이스에 대한 사양인 DOMAIN NAME SPACE. 개념적으로 도메인 이름 공간 트리의 각 노드와 리프는 정보 집합의 이름을 지정하며 쿼리 작업은 특정 집합에서 특정 유형의 정보를 추출하려는 시도입니다. 쿼리는 관심 있는 도메인 이름을 지정하고 원하는 리소스 정보 유형을 설명합니다. 예를 들어, ARPA 인터넷은 도메인 이름 중 일부를 사용하여 호스트를 식별합니다. 주소 리소스에 대한 쿼리는 ARPA 인터넷 호스트 주소를 반환합니다. 그러나 도메인 메커니즘의 일반성을 유지하기 위해 도메인 이름은 호스트 이름, 호스트 주소 또는 기타 유형의 정보와 일대일 대응을 가질 필요는 없습니다.

- NAME SERVERS는 도메인 트리의 구조 및 설정 정보에 대한 정보를 보유하는 서버 프로그램입니다. 이름 서버는 도메인 트리의 모든 부분에 대한 구조를 캐시하거나 정보를 설정할 수 있지만 일반적으로 특정 이름 서버는 도메인 공간의 하위 집합에 대한 완전한 정보와 정보를 가져오는 데 사용할 수 있는 다른 이름 서버에 대한 포인터를 가지고 있습니다. 도메인 트리의 모든 부분. 이름 서버는 완전한 정보가 있는 도메인 트리 부분을 알고 있습니다. 이러한 부분을 ZONE이라고 합니다. 네임서버는 네임스페이스의 이러한 부분에 대한 권한입니다.

- RESOLVERS는 사용자 요청에 응답하여 네임서버에서 정보를 추출하는 프로그램입니다. 확인자는 하나 이상의 이름 서버에 액세스하고 해당 이름 서버의 정보를 사용하여 쿼리에 직접 응답하거나 다른 이름 서버에 대한 참조를 사용하여 쿼리를 추적할 수 있어야 합니다. 리졸버는 일반적으로 사용자 프로그램에 직접 액세스할 수 있는 시스템 루틴입니다. 따라서 리졸버와 사용자 프로그램 사이에는 프로토콜이 필요하지 않습니다.

- 이 세 가지 구성 요소는 대략 도메인 시스템의 세 가지 계층 또는 보기에 해당합니다.

- 사용자 입장에서는 간단한 절차나 Resolver에 대한 OS 호출을 통해 도메인 시스템에 접근한다. 도메인 공간은 단일 트리로 구성되며 사용자는 트리의 모든 섹션에서 정보를 요청할 수 있습니다.

- 리졸버 입장에서 보면 도메인 시스템은 알 수 없는 수의 네임서버로 구성되어 있다. 각 이름 서버에는 전체 도메인 트리 데이터 중 하나 이상의 조각이 있습니다.

- 그러나 확인자는 이러한 각 데이터베이스를 본질적으로 정적인 것으로 간주합니다.

- 네임서버의 관점에서 도메인 시스템은 존\(zone\)이라고 불리는 별도의 로컬 정보 세트로 구성됩니다. 이름 서버에는 일부 영역의 로컬 복사본이 있습니다. 이름 서버는 로컬 파일이나 외부 이름 서버의 마스터 복사본에서 해당 영역을 주기적으로 새로 고쳐야 합니다. 이름 서버는 로컬 영역을 사용하여 확인자로부터 도착하는 쿼리를 동시에 처리해야 합니다.

- 성능을 위해 이러한 레이어는 약간 흐려집니다. 예를 들어 이름 서버와 동일한 시스템에 있는 확인자는 데이터베이스를 공유할 수 있으며 나중에 쿼리에 사용하기 위해 외부 정보를 도입할 수도 있습니다. 이 캐시된 정보는 영역의 신뢰할 수 있는 데이터와 다르게 처리됩니다.

```text
   Database model
```

도메인 시스템의 구성은 일부에서 파생됩니다.

- 사용자 커뮤니티의 요구와 사용 패턴에 대한 가정을 바탕으로 하며 범용 데이터베이스 시스템에서 발견되는 복잡한 문제를 방지하도록 설계되었습니다.

- 가정은 다음과 같습니다.

- 전체 데이터베이스의 크기는 처음에는 시스템을 사용하는 호스트 수에 비례하지만, 도메인 시스템에 사서함 및 기타 정보가 추가됨에 따라 결국 해당 호스트의 사용자 수에 비례하도록 증가합니다.

- 시스템에 있는 대부분의 데이터는 매우 느리게 변경되지만\(예: 사서함 바인딩, 호스트 주소\) 시스템은 더 빠르게\(몇 분 단위로\) 변경되는 하위 집합을 처리할 수 있어야 합니다.

- 데이터베이스에 대한 책임을 분배하는 데 사용되는 관리 경계는 일반적으로 하나 이상의 호스트가 있는 조직에 해당합니다. 특정 도메인 세트에 대한 책임이 있는 각 조직은 조직 자체 호스트 또는 조직이 사용하도록 준비한 다른 호스트에 중복 이름 서버를 제공합니다.

- 도메인 시스템의 클라이언트는 이 "신뢰할 수 있는" 세트 외부의 이름 서버에 대한 참조를 수락하기 전에 사용하기를 선호하는 신뢰할 수 있는 이름 서버를 식별할 수 있어야 합니다.

- 정보에 대한 접근은 즉각적인 것보다 더 중요합니다.

- 업데이트 또는 일관성 보장. 따라서 업데이트 프로세스를 통해 모든 복사본이 동시에 업데이트되도록 보장하기보다는 업데이트가 도메인 시스템 사용자를 통해 여과될 수 있습니다. 네트워크 또는 호스트 장애로 인해 업데이트를 사용할 수 없는 경우 일반적인 과정은 업데이트를 계속하면서 오래된 정보를 믿는 것입니다. 일반적인 모델은 새로 고침에 대한 시간 제한을 두고 복사본이 배포된다는 것입니다. 배포자는 시간 초과 값을 설정하고 배포 수신자는 새로 고침을 수행해야 합니다. 특별한 상황에서는 매우 짧은 간격을 지정하거나 소유자가 복사를 금지할 수 있습니다.

- 일부 사용자는 데이터그램을 통해 데이터베이스에 액세스하기를 원할 것입니다. 다른 사람들은 가상 회로를 선호할 것입니다. 도메인 시스템은 간단한 쿼리와 응답이 어느 스타일이든 사용할 수 있도록 설계되었습니다. 단, 새로 고침 작업에는 가상 회로의 신뢰성이 필요합니다. 모든 통신에는 동일한 전체 메시지 형식이 사용됩니다. 도메인 시스템은 통신 시스템의 특별한 속성을 가정하지 않으므로 모든 데이터그램이나 가상 회선 프로토콜과 함께 사용할 수 있습니다.

- 분산 데이터베이스가 있는 시스템에서는 특정 이름 서버에 다른 서버에서만 응답할 수 있는 쿼리가 제공될 수 있습니다. 이 문제를 처리하는 두 가지 일반적인 접근 방식은 첫 번째 서버가 다른 서버에서 클라이언트에 대한 쿼리를 추구하는 "재귀적"과 서버가 클라이언트를 다른 서버로 참조하고 클라이언트가 쿼리를 수행하도록 하는 "반복적"입니다. 질문. 두 접근 방식 모두 장점과 단점이 있지만 데이터그램 스타일의 액세스에는 반복 접근 방식이 선호됩니다. 도메인 시스템에서는 반복적 접근 방식의 구현이 필요하지만 옵션으로 재귀적 접근 방식을 허용합니다. 선택적 재귀 스타일은 \[14\]에서 논의되며 이 메모의 추가 논의에서는 생략됩니다.

- 도메인 시스템은 모든 데이터가 도메인 시스템을 사용하는 호스트에 흩어져 있는 마스터 파일에서 유래한다고 가정합니다. 이러한 마스터 파일은 로컬 시스템 관리자에 의해 업데이트됩니다. 마스터 파일은 로컬 이름 서버에서 읽혀 도메인 시스템 사용자가 사용할 수 있는 텍스트 파일입니다. 이러한 파일의 표준 형식은 \[14\]에 나와 있습니다.

- 표준 형식을 사용하면 이러한 파일을 호스트 간에\(FTP, 메일 또는 기타 메커니즘을 통해\) 교환할 수 있습니다. 이 기능은 조직이 도메인을 원하지만 이름 서버를 지원하고 싶지 않을 때 유용합니다. 조직은 텍스트 편집기를 사용하여 로컬에서 마스터 파일을 유지 관리하고 이를 이름 서버를 실행하는 외부 호스트로 전송한 다음 이름 서버의 시스템 관리자와 협의하여 파일을 로드할 수 있습니다.

- 각 호스트의 네임서버와 리졸버는 로컬 시스템 관리자가 구성합니다. 이름 서버의 경우 이 구성 데이터에는 로컬 마스터 파일의 ID와 외부 서버에서 로드되는 비로컬 마스터 파일에 대한 지침이 포함됩니다. 이름 서버는 마스터 파일이나 복사본을 사용하여 해당 영역을 로드합니다. 확인자의 경우 구성 데이터는 정보의 주요 소스가 되어야 하는 이름 서버를 식별합니다.

- 도메인 시스템은 데이터 액세스 및 다른 이름 서버에 대한 참조 절차를 정의합니다. 도메인 시스템은 검색된 데이터를 캐싱하고 시스템 관리자가 정의한 데이터를 주기적으로 새로 고치는 절차도 정의합니다.

- 시스템 관리자는 다음을 제공합니다.

- 구역 경계의 정의

- 데이터의 마스터 파일

- 마스터 파일 업데이트

- 원하는 새로 고침 정책 설명

- 도메인 시스템은 다음을 제공합니다.

- 리소스 데이터의 표준 형식

- 데이터베이스 쿼리를 위한 표준 방법

- 외부 이름 서버의 로컬 데이터를 새로 고치는 이름 서버의 표준 방법

---
# **DOMAIN NAME SPACE**

네임스페이스 사양 및 용어

- 도메인 이름 공간은 트리 구조입니다. 트리의 각 노드와 리프는 리소스 세트\(비어 있을 수 있음\)에 해당합니다. 각 노드와 리프에는 연관된 레이블이 있습니다. null 레이블이 있는 루트 노드를 제외하고 레이블은 고유성이 보장되지 않습니다. 노드 또는 리프의 도메인 이름은 트리의 루트에서 노드 또는 리프까지의 경로입니다. 관례적으로 도메인 이름을 구성하는 레이블은 가장 구체적인 것\(가장 낮은 것\)부터 가장 덜 구체적인 것\(가장 높은 것\)까지 왼쪽에서 오른쪽으로 읽습니다.

- 내부적으로 도메인 이름을 조작하는 프로그램은 도메인 이름을 일련의 레이블로 표시합니다. 여기서 각 레이블은 길이 옥텟과 옥텟 문자열로 구성됩니다. 모든 도메인 이름은 레이블에 대한 null 문자열이 있는 루트에서 끝나기 때문에 이러한 내부

- 표현은 도메인 이름을 종료하기 위해 0의 길이 바이트를 사용할 수 있습니다. 도메인 이름이 인쇄되면 경로의 레이블은 점\("."\)으로 구분됩니다. 루트 레이블 및 관련 점은 인쇄된 도메인 이름에서 생략되지만 루트는 널 도메인 이름\(이 메모에서는 " "\)으로 명명될 수 있습니다.

- 구현을 단순화하기 위해 레이블 옥텟과 레이블 길이를 나타내는 총 옥텟 수는 255개로 제한됩니다. 따라서 인쇄된 도메인 이름은 최대 254자까지 가능합니다.

- 다른 라벨과 일치하는 특수 라벨이 정의됩니다. 이 레이블은 별표 또는 "\*"입니다. 별표는 단일 라벨과 일치합니다. 따라서 \*.ARPA는 FOO.ARPA와 일치하지만 FOO.BAR.ARPA와는 일치하지 않습니다. 별표는 프로토콜 계열 간의 경계에서 기본 리소스 레코드를 생성하는 데 주로 사용되며 신중하게 사용해야 합니다.

- 도메인은 도메인 이름으로 식별되며 도메인을 지정하는 도메인 이름 또는 그 아래에 있는 도메인 이름 공간의 일부로 구성됩니다. 도메인은 해당 도메인 내에 포함된 경우 다른 도메인의 하위 도메인입니다. 이 관계는 하위 도메인 이름의 이름 오른쪽 부분에 포함 도메인 이름이 있는지 확인하여 테스트할 수 있습니다. 예를 들어 A.B.C.D는 B.C.D, C.D, D 및 " "의 하위 도메인입니다.

- 이 트리 구조는 행정 조직과 권한 위임을 병행하기 위한 것입니다. 잠재적으로 트리의 각 노드나 잎은 새로운 하위 도메인을 무한정 생성할 수 있습니다. 실제로 이러한 위임은 도메인 공간과 리소스 데이터를 관리하는 이름 서버의 관리자에 의해 제한될 수 있습니다.

- 다음 그림은 도메인 네임스페이스의 예를 보여줍니다.

```text
                                   |                            
                +------------------+------------------+         
                |                  |                  |         
              COLORS            FLAVORS             TRUTH       
                |                  |                            
          +-----+-----+            |                            
          |     |     |         NATURAL                         
         RED  BLUE  GREEN          |                            
                                   |                            
                   +---------------+---------------+            
                   |               |               |            
               CHOCOLATE        VANILLA        STRAWBERRY       
```

- 이 예에서 루트 도메인에는 COLORS, FLAVORS 및 TRUTH의 세 가지 하위 도메인이 있습니다. FLAVORS 도메인에는 NATURAL.FLAVORS라는 하나의 직계 하위 도메인이 있습니다. 나뭇잎도 모두

- 도메인. 이 도메인 트리의 이름은 " "\(루트\), COLORS, RED.COLORS, BLUE.COLORS, GREEN.COLORS, FLAVORS, NATURAL.FLAVORS, CHOCOLATE.NATURAL.FLAVORS, VANILLA.NATURAL.FLAVORS, STRAWBERRY.NATURAL.FLAVORS입니다. , 그리고 진실. FLAVORS 아래에 ARTIFICIAL이라는 새 도메인을 추가하려는 경우 FLAVORS가 일반적으로 결정하는 관리 주체가 됩니다. CHOCOLATE 아래에 CHIP 및 MOCHA 이름을 생성하려는 경우 일반적으로 CHOCOLATE.NATURAL.FLAVORS가 적절한 관리 엔터티가 됩니다.

```text
   Resource set information
```

- 도메인 이름은 일련의 리소스 정보를 식별합니다. 특정 이름과 관련된 리소스 정보 집합은 별도의 리소스 레코드\(RR\)로 구성됩니다.

- 각 리소스 레코드에는 다음과 같은 주요 구성요소가 있습니다.

- 이 기록을 보유하고 있는 자원 세트를 식별하는 도메인 이름, 즉 정보의 "소유자"입니다. 예를 들어, 호스트 주소를 지정하는 RR에는 해당 주소를 갖는 호스트를 지정하는 도메인 이름이 있습니다. 따라서 F.ISI.ARPA는 10.2.0.52의 주소 필드를 지정한 RR의 소유자일 수 있습니다. 네임 서버는 일반적으로 도메인 공간 구성과 병행하여 트리 구조에 리소스 정보를 저장하므로 이 정보는 일반적으로 데이터베이스에 암시적으로 저장될 수 있습니다. 그러나 메시지에 포함된 각 리소스 레코드에는 항상 포함됩니다.

- 길이 필드, 시간 제한 등과 같이 RR을 관리하는 데 사용되는 기타 정보. 이 정보는 이 메모의 대부분에서 생략되었지만 \[14\]에서 논의됩니다.

- 이 리소스 레코드의 리소스 유형을 지정하는 리소스 유형 필드입니다. 유형은 호스트 주소나 메일 배달 에이전트와 같은 추상적인 리소스를 나타냅니다. 유형 필드는 길이가 2옥텟이고 도메인 이름 시스템 전반에 걸쳐 표준인 인코딩을 사용합니다.

- 클래스 필드는 특정 RR 유형\(예: 주소 데이터\)에 대해 ARPA 인터넷 형식\(IN\) 또는 컴퓨터 과학 네트워크 형식\(CSNET\)과 같은 리소스 데이터의 형식을 식별합니다. 클래스가 서로 다른 프로토콜 제품군, 네트워크 등을 분리할 수 있지만 모든 경우에 그렇게 되는 것은 아닙니다. 예를 들어 IN 클래스는 32비트 IP 주소만 사용하지만 CSNET 클래스는 32비트 IP 주소, X.25 주소, 전화번호를 사용합니다. 따라서 클래스 필드는 리소스 데이터를 해석하기 위한 지침으로 사용해야 합니다. 클래스 필드는 길이가 2옥텟이고 도메인 이름 시스템 전반에 걸쳐 표준인 인코딩을 사용합니다.

- 리소스를 설명하는 리소스 데이터입니다. 이 데이터의 형식은 유형 및 클래스 필드에 따라 결정될 수 있지만 항상 이름 서버 또는 확인자가 "이해"할 수 없는 경우에도 모든 트랜잭션에서 리소스 데이터의 경계를 결정할 수 있도록 하는 2옥텟 길이 필드로 시작합니다. 리소스 데이터 자체. 따라서 이름 서버와 확인자는 해석할 수 없는 레코드를 보유하고 전달할 수 있습니다. 내부 데이터의 형식은 최대 길이 65535옥텟으로만 제한됩니다. 예를 들어 호스트 주소 레코드는 한 클래스에 대해 고정된 32비트 숫자를 지정하고 다른 클래스에 대해서는 가변 길이 주소 목록을 지정할 수 있습니다.

- 클래스 필드는 도메인 이름 시스템의 리소스 데이터를 클래스에 따라 별도의 병렬 섹션으로 분할하는 반면, 서비스는 호환 가능한 리소스 데이터 형식을 사용하는 경우 클래스 경계를 ​​확장할 수 있습니다. 예를 들어, 도메인 이름 시스템은 구조 정보에 호환되는 형식을 사용하고 메일 데이터는 메일 에이전트 식별과 에이전트에 연락하는 방법\(예: 호스트 주소\)에 대한 세부 정보를 분리합니다.

- 이 메모는 예시에서 다음 유형을 사용합니다.

```text
         A     - the host address associated with the domain name

         MF    - identifies a mail forwarder for the domain

         MD    - identifies a mail destination for the domain

         NS    - the authoritative name server for the domain
```

- SOA - 권한 영역의 시작을 식별합니다.

- CNAME - 별칭의 정식 이름을 식별합니다.

- 이 메모는 예제에서 다음 클래스를 사용합니다.

- IN - ARPA 인터넷 시스템

- CS - CSNET 시스템

- 첫 번째 유형의 리소스 레코드는 호스트 주소 바인딩에 대한 호스트 이름을 보유합니다. 해당 필드는 다음과 같습니다.

```text
  +--------+--------+--------+--------------//----------------------+
  |<owner> |   A    | <class>| <class specific address>information  |
  +--------+--------+--------+--------------//----------------------+
```

- CLASS 필드의 값에 따라 클래스별 정보의 내용이 달라집니다. ARPA 인터넷의 경우 호스트의 32비트 ARPA 인터넷 주소이고, CSNET의 경우 호스트의 전화번호일 수 있습니다. 예를 들어 F.ISI.ARPA에는 다음 형식의 A 레코드가 두 개 있을 수 있습니다.

```text
       +----------+--------+--------+----------------------------+
       |F.ISI.ARPA|   A    |   IN   |          10.2.0.52         |
       +----------+--------+--------+----------------------------+
                                  and
       +----------+--------+--------+----------------------------+
       |F.ISI.ARPA|   A    |   CS   |         213-822-2112       |
       +----------+--------+--------+----------------------------+
```

- A 유형의 데이터 형식은 클래스에 따라 다르며, 위에 표시된 인터넷 주소 및 전화번호 형식은 예시 목적으로만 사용됩니다. 실제 데이터 형식은 \[14\]에 지정되어 있습니다. 예를 들어, 유형 A 레코드에 대한 CS 클래스 데이터는 실제로 인터넷 주소, 전화번호 및 TELENET 주소 목록일 수 있습니다.

- 메일 전달자\(MF\) 및 메일 배달\(MD\) 기록의 형식은 다음과 같습니다.

```text
        +--------+--------+--------+----------------------------+
        |<owner> | MD/MF  | <class>|       <domain name>        |
        +--------+--------+--------+----------------------------+
```

- <도메인 이름\> 필드는 메일을 처리할 호스트의 도메인 이름입니다. 이 도메인 이름은 리소스 레코드의 이름을 지정하는 도메인 이름과 완전히 다를 수 있습니다. 예를 들어 F.ISI.ARPA에는 다음 형식의 두 개의 레코드가 있을 수 있습니다.

```text
       +----------+--------+--------+----------------------------+
       |F.ISI.ARPA|  MD    |   IN   |         F.ISI.ARPA         |
       +----------+--------+--------+----------------------------+
                                  and
       +----------+--------+--------+----------------------------+
       |F.ISI.ARPA|  MF    |   IN   |         B.ISI.ARPA         |
       +----------+--------+--------+----------------------------+
```

이러한 기록은 F.ISI.ARPA에 대한 메일이 다음 중 하나일 수 있음을 의미합니다.

- 호스트 F.ISI.ARPA로 전달되거나 B.ISI.ARPA로 전달되며, B.ISI.ARPA는 최종 전달에 대한 책임을 집니다. 원칙적으로 호스트의 도메인 이름을 적절한 주소에 매핑하려면 추가 이름 조회가 필요합니다. 실제로 이 정보는 일반적으로 메일 쿼리에 대한 응답으로 반환됩니다.

- SOA 및 NS 유형의 리소스 레코드는 제한을 정의하는 데 사용됩니다.

- 권위의. SOA 레코드의 소유자 필드에 지정된 도메인 이름은 영역의 시작입니다. NS 레코드의 소유자 필드에 의해 제공된 도메인 이름은 권한이 위임된 네임스페이스의 지점을 식별하고 따라서 영역 경계를 표시합니다. 이름 서버가 자신에게 권한을 위임하는 경우를 제외하고 SOA는 권한의 최대 한도를 식별하고 NS 레코드는 영역 외부의 이름을 정의합니다. 이러한 리소스 레코드는 모든 네임스페이스에 대한 표준 형식을 갖습니다.

```text
      +----------+--------+--------+-----------------------------+
      | <owner>  |   SOA  | <class>|       <domain name, etc>    |
      +----------+--------+--------+-----------------------------+
                                    
      +----------+--------+--------+-----------------------------+
      | <owner>  |   NS   | <class>|       <domain name>         |
      +----------+--------+--------+-----------------------------+
```

- SOA 레코드는 데이터베이스에 존재할 때 영역의 시작을 표시합니다. NS 레코드는 SOA에 의해 시작된 영역의 끝을 표시하고\(더 높은 SOA가 있는 경우\) <owner.properties에 의해 지정된 영역의 복사본이 있는 이름 서버를 가리킵니다. NS 레코드의 필드입니다.

- SOA 레코드의 <도메인 이름 등\>은 해당 영역에 있는 정보의 원본 소스와 이름 서버가 활동을 구성하는 데 사용하는 기타 정보를 지정합니다. SOA 레코드는 캐시되지 않습니다. 그렇지 않으면 잘못된 영역이 생성됩니다. 특별한 이름 서버 유지 관리 작업에서만 생성될 수 있습니다.

```text
      The NS record says that a name server which is authoritative for
      records of the given CLASS can be found at <domain name>.

   Queries
```

이름 서버에 대한 쿼리에는 도메인 이름이 포함되어야 합니다.

- 대상 자원 세트\(QNAME\)와 원하는 자원 레코드의 유형 및 클래스를 식별합니다. 쿼리의 유형 및 클래스 필드에는 리소스 레코드에 대해 정의된 해당 유형 및 클래스 필드가 포함될 수 있습니다. 또한 쿼리 유형\(QTYPE\) 및 쿼리 클래스\(QCLASS\) 필드에는 RR의 해당 필드 중 두 개 이상과 일치하는 특수 값이 포함될 수 있습니다.

- 예를 들어 QTYPE 필드에는 다음이 포함될 수 있습니다.

- MAILA - 모든 메일 에이전트 RR\(예: MD 및 MF\)과 일치합니다.

```text
         *     - matches any RR type.
```

- QCLASS 필드에는 다음이 포함될 수 있습니다.

```text
         *    - matches any RR class.
```

- 쿼리 도메인 이름, QTYPE 및 QCLASS를 사용하여 네임 서버는 일치하는 RR을 찾습니다. 관련 레코드 외에도 네임 서버는 원하는 정보가 있는 네임 서버를 가리키는 RR 또는 관련 RR을 해석하는 데 유용할 것으로 예상되는 RR을 반환할 수 있습니다. 예를 들어, 요청된 정보가 없는 이름 서버는 정보가 있는 이름 서버를 알고 있을 수 있습니다. 관련 RR의 도메인 이름을 반환하는 네임 서버는 해당 도메인 이름을 주소에 바인딩하는 RR도 반환할 수 있습니다.

- QCLASS=\* 구성에는 권한에 대한 특별한 해석이 필요합니다. 네임 서버는 도메인 시스템에서 사용 가능한 모든 클래스를 알지 못할 수 있으므로 모든 클래스에 대해 권한이 있는지 결코 알 수 없습니다. 따라서 QCLASS=\* 쿼리에 대한 응답은 결코 신뢰할 수 없습니다.

```text
   Example space
```

- 설명을 위해 이 메모의 나머지 부분에는 다음 이름 공간이 사용됩니다.

```text
                                    |                            
                 +------------------+------------------+         
                 |                  |                  |         
                DDN               ARPA               CSNET       
                 |                  |                  |         
           +-----+-----+            |            +-----+-----+   
           |     |     |            |            |           |   
          JCS  ARMY  NAVY           |           UDEL        UCI  
                                    |                            
           +--------+---------------+---------------+--------+   
           |        |               |               |        |   
          DTI      MIT             ISI             UDEL     NBS  
                    |               |                            
                +---+---+       +---+---+                        
                |       |       |   |   |                        
               DMS     AI       A   B   F                        
```

---
# **NAME SERVERS**

```text
   Introduction
```

- 이름 서버는 도메인 이름 공간의 구조, 도메인 이름과 관련된 리소스 세트, 이름 서버 간의 작업을 조정하는 데 사용되는 기타 정보로 구성된 분산 데이터베이스를 저장합니다.

- 일반적으로 네임서버는 특정 도메인의 전부 또는 일부에 대한 권한을 갖습니다. 이 권한이 적용되는 지역을 구역이라고 합니다. 이름 서버는 권한 있는 데이터를 담당하지 않을 수 있으므로 영역이 없거나 여러 영역이 있을 수 있습니다. 이름 서버에 여러 영역이 있는 경우 영역에는 공통 경계가 없거나 영역이 연속되어 있을 수 있습니다.

- 관리자는 중복되는 영역을 구성해서는 안 되며, 네임 서버는 중복된 영역을 방어해야 하지만, 중복은 데이터베이스의 치명적이지 않은 결함으로 간주됩니다. 따라서 이를 방지하기 위해 취해진 조치는 이 메모의 나머지 부분에서는 생략됩니다. 자세한 논의는 \[14\]에서 찾아볼 수 있다.

- 권한이 있는 도메인 이름에 대한 쿼리가 제공되면 이름 서버는 원하는 리소스 정보 또는 쿼리가 존재하지 않는 도메인 이름이나 리소스를 참조한다는 표시를 반환합니다. 네임 서버에 권한 범위에 속하지 않는 도메인 이름에 대한 쿼리가 표시되면 원하는 정보를 얻을 수 있지만 권한 있는 네임 서버를 가리키는 응답도 반환됩니다. 네임서버가 쿼리 권한이 없는 경우에는 결코 부정적인 응답을 반환할 수 없습니다.

- 도메인의 이름 서버가 동일한 도메인에 이름을 가진 호스트에 있어야 한다는 요구 사항은 없지만 일반적으로 그렇습니다. 특정 도메인에 대한 권한을 가질 수 있는 네임 서버의 수에도 제한이 없습니다. 대부분의 도메인에는 중복된 권한 있는 이름 서버가 있습니다. 업데이트가 수행될 때 불일치가 발생할 수 있더라도 서로 다른 신뢰할 수 있는 복사본은 동일하다고 가정합니다.

- 네임서버 기능은 네임서버를 매우 간단하게 구현할 수 있도록 설계되었습니다. 가장 간단한 이름 서버는 정적인 정보 세트를 갖고 있으며 데이터그램을 사용하여 쿼리를 수신하고 응답을 반환합니다.

- 보다 정교한 이름 서버 구현은 다른 도메인의 정보를 캐싱하여 클라이언트 성능을 향상시킬 수 있습니다. 이 정보는 다양한 방법으로 얻을 수 있지만 일반적인 방법은 다음과 같이 얻은 정보를 저장하는 것입니다.

- 해석기가 다른 이름 서버를 참조하는 경우 해석기. 정교한 호스트에서는 확인자와 이름 서버가 작업을 조정하고 공유 데이터베이스를 사용합니다. 이러한 협력을 위해서는 캐시된 모든 리소스 레코드에 TTL\(Time-To-Live\) 필드를 통합해야 합니다. 캐싱은 이 메모의 리졸버 섹션에서 논의됩니다. 이 섹션은 캐시하지 않는 이름 서버의 작업에 대해 다룹니다.

- 단순 네임 서버에서 이러한 시간 초과를 관리해야 하는 요구 사항을 없애기 위해 단순 네임 서버에는 매우 오랜 기간 동안 일정하게 유지될 것으로 예상되는 리소스 레코드 또는 네임 서버가 권한을 부여하는 리소스 레코드만 포함되어야 합니다. 다음 설명에서는 TTL 필드가 리소스 레코드에 저장되는 것으로 가정하지만 명확성을 위해 데이터베이스 및 응답 설명에서는 생략되었습니다.

도메인에 대한 권한 및 관리 통제

우리는 위임할 수 있는 잠재력을 갖고 싶어하지만

- 모든 노드의 네임스페이스 관리 권한, 우리는 그러한 위임이 요구되는 것을 원하지 않습니다.

- 그래서 우리는 권위의 개념을 소개합니다. 권한은 네임서버에 부여됩니다. 이름 서버는 하위 도메인에 대한 권한을 다른 이름 서버에 위임할 때까지 모든 도메인에 대한 권한을 갖습니다.

- 자체 도메인을 구축하려는 모든 관리 주체는 네임 서버를 제공하고 해당 서버를 상위 네임 서버\(즉, 새 도메인을 보유할 도메인 네임 공간의 위치에 대한 권한을 가진 네임 서버\)가 수락하도록 해야 합니다. . 권위의 원칙에 따라 승인은 상위 네임 서버의 재량에 따라 허용되지만 다음 기준은 루트에서 사용되며 하위 항목의 작업에 대한 책임이 있으므로 모든 네임 서버에 권장됩니다.

- 1. 도메인의 상위관리자에게 등록을 해야 합니다.

- 2. 책임자를 밝혀야 합니다.

- 3. 중복된 이름 서버를 제공해야 합니다.

- 이름 충돌을 방지하고 도메인 관련 정보를 다른 도메인에서 사용할 수 있도록 하려면 도메인 이름을 관리자에게 등록해야 합니다. 중앙 관리자는 추가 요구 사항이 있을 수 있으며 중앙 관리자가 모든 요구 사항이 충족된다는 데 동의할 때까지 도메인은 등록되지 않습니다.

- 각 도메인에는 담당 책임자가 있어야 합니다.

- 도메인에 관한 질문에 대한 연락 지점 역할을 하고, 도메인 관련 정보를 확인 및 업데이트하고, 도메인 내 호스트와 관련된 문제\(예: 프로토콜 위반\)를 해결합니다.

- 도메인은 주소 확인 서비스에 대한 이름을 제공하기 위해 중복\(예: 2개 이상\) 이름 서버를 제공해야 합니다. 이러한 이름 서버는 도메인 외부\(내부는 물론\)에서 액세스할 수 있어야 하며 최소한 도메인에 있는 모든 호스트의 이름을 확인해야 합니다.

- 중앙 관리자가 만족하면 다른 도메인의 적절한 관리자에게 존재를 전달하여 새 이름 서버에 대한 NS 레코드를 데이터베이스에 통합할 수 있도록 합니다.

```text
   Name server logic
```

- 쿼리에 응답하여 이름 서버가 수행하는 처리 단계는 개념적으로 간단하지만 구현에는 매우 복잡한 내부 데이터베이스가 있을 수 있습니다.

- 설명을 위해 쿼리가 QTYPE 유형, QCLASS 클래스 및 도메인 이름 QNAME으로 구성되어 있다고 가정합니다. 우리는 이름 서버가 각 세트에 특정 도메인에 대한 모든 RR이 있는 세트에 RR을 저장한다고 가정합니다. 이 데이터베이스 구조와 다음 알고리즘은 모든 서버를 구현해야 하는 방법에 대한 사양이 아니라 가능한 구현 중 하나를 설명하기 위한 것입니다.

- 다음 표기법이 사용됩니다.

- ord\(DOMAIN-NAME\)은 DOMAIN-NAME의 라벨 수를 반환합니다.

- findset\(DOMAIN-NAME\)은 DOMAIN-NAME에 대해 저장된 RR 세트에 대한 포인터를 반환하거나 그러한 정보가 없는 경우 NULL을 반환합니다.

- set\(POINTER\)는 findset이 이전에 찾은 집합을 나타냅니다. 여기서 POINTER는 findset이 반환한 값입니다.

- 관련\(QTYPE,TYPE\)은 지정된 TYPE의 RR이 지정된 QTYPE과 관련된 경우 true를 반환합니다. 예를 들어, 관련\(MAILA,MF\)은 true이고 관련\(MAILA,NS\)은 false입니다.

- right\(NAME,NUMBER\)는 NAME 문자열에서 가장 오른쪽 NUMBER 레이블에 있는 도메인 이름을 반환합니다.

- copy\(RR\)는 RR이 지정한 리소스 레코드를 응답에 복사합니다.

- 네임서버 코드는 다음과 같은 일련의 단계로 표현될 수 있습니다.

```text
     {    find out whether the database makes this server          
          authoritative for the domain name specified by QNAME   } 

     for i:=0 to ord(QNAME) { sequence through all nodes in QNAME }
     do   begin                                                    
          ptr:=findset(right(QNAME,i));                            
          if ptr<>NULL                                             
          then { there is domain data for this domain name }       
               begin                                               
               for all RRs in set(ptr)                             
               do   if type(RR)=NS and class(RR)=QCLASS            
                    then begin                                     
                         auth=false;                               
                         NSptr:=ptr                                
                         end;                                      
               for all RRs in set(ptr)                             
               do   if type(RR)=SOA and class(RR)=QCLASS           
                    then auth:=true                                
                    end                                            
               end;                                                
           end;                                                    

      {    copy out authority search results }                     

      if auth                                                      
      then { if authority check for domain found }                 
           if ptr=null                                             
           then return(Name error)                                 
           else                                                    
      else { if not authority, copy NS RRs }                       
           for all RRs in set(nsptr)                               
           do   if (type(RR)=NS and class(RR)=QCLASS)              
                                 or                                
                              (QCLASS=*)                           
                then copy(RR);                                     

      {    Copy all RRs that answer the question }                 

      for all RRs in set(ptr)                                      
      do   if class(RR)=QCLASS and relevant(QTYPE,type(RR))        
           then copy(RR);                                          
```

- 코드의 첫 번째 섹션\(전체에 걸쳐 for 루프로 구분됨\)

- QNAME의 하위 노드 중\)은 이름 서버가 QNAME에 의해 지정된 도메인에 대해 권한이 있는지 여부를 검색합니다. 루트에서 시작하여 QNAME의 모든 포함 도메인을 통해 시퀀스됩니다. SOA를 만나면 권한을 위임하는 하위 NS RR을 찾지 않는 한 이름 서버가 권한이 있다는 것을 알게 됩니다. 이름 서버가 신뢰할 수 있으면 auth=true로 설정됩니다. 이름 서버가 권한이 없는 경우 QNAME이 지정한 도메인에 가장 가까운 NS RR이 포함된 집합을 가리키도록 NSptr을 설정합니다.

코드의 두 번째 섹션은 다음의 결과를 반영합니다.

- 응답에 대한 권한 검색. 이름 서버가 신뢰할 수 있는 경우 코드는 QNAME으로 지정된 도메인이 존재하는지 확인합니다. 그렇지 않으면 이름 오류가 반환됩니다. 이름 서버가 신뢰할 수 없는 경우 코드는 더 가까운 이름 서버에 대한 RR을 응답에 복사합니다.

- 코드의 마지막 섹션은 모든 관련 RR을 응답에 복사합니다.

- 이 코드는 실제 구현을 의미하지 않으며 여러 측면에서 불완전합니다. 예를 들어 추가 정보 제공, 와일드카드, QCLASS=\* 또는 겹치는 영역을 처리하지 않습니다. 이들 문제 중 처음 두 개는 다음 논의에서 다루어지고 나머지 문제는 \[14\]에서 논의됩니다.

```text
   Additional information
```

- 리졸버가 사용자 프로그램에 정보를 반환할 때 반환된 정보는 종종 두 번째 쿼리로 이어집니다. 예를 들어, 메일러가 확인자에게 특정 도메인 이름에 대한 적절한 메일 에이전트를 요청하면 확인자가 쿼리한 이름 서버는 에이전트를 식별하는 도메인 이름을 반환합니다. 일반적으로 우리는 메일러가 메일 에이전트에 대한 주소 바인딩에 대한 도메인 이름을 요청하고 새로운 이름 서버 쿼리가 발생할 것으로 예상합니다.

이러한 노력의 중복을 피하기 위해 이름 서버는

- 예상된 쿼리를 만족시키는 응답이 포함된 추가 정보. 이 정보는 응답의 별도 섹션에 보관됩니다. 네임서버는 해당 정보가 있는 경우 적절한 추가 정보를 완성해야 하지만, 네임서버에 해당 정보가 없을 수도 있으므로 요청자는 정보의 존재 여부에 의존해서는 안 됩니다. 확인자가 추가 정보를 캐시하면 추가 네트워크 트랜잭션 없이 두 번째 쿼리에 응답할 수 있습니다.

- 적절한 정보는 \[14\]에 정의되어 있지만 일반적으로

- 반환된 RR의 도메인 이름에 대한 호스트-주소 바인딩으로 구성됩니다.

별칭 및 정식 이름

- 기존 시스템에서 호스트 및 기타 리소스에는 동일한 리소스를 식별하는 여러 이름이 있는 경우가 많습니다. 예를 들어, 현재 ARPA 인터넷 이름 지정 지원에서는 USC-ISIF와 ISIF가 모두 동일한 호스트를 식별합니다. 마찬가지로 사서함의 경우 많은 조직에서 실제로 동일한 사서함으로 이동하는 많은 이름을 제공합니다. 예를 들어 Mockapetris@ISIF, Mockapetris@ISIB 등은 모두 동일한 사서함으로 이동합니다\(이에 대한 메커니즘은 다소 복잡하지만\).

- 이러한 시스템의 대부분은 동등한 이름 ​​집합 중 하나가 표준 이름이고 다른 모든 것은 별칭이라는 개념을 가지고 있습니다.

- 도메인 시스템은 정식 이름\(CNAME\) RR을 사용하여 유사한 기능을 제공합니다. 네임 서버가 일부 도메인 이름과 연관된 세트에서 원하는 RR을 찾지 못하면 리소스 세트에 일치하는 클래스가 있는 CNAME 레코드가 포함되어 있는지 확인합니다. 그렇다면 이름 서버는 응답에 CNAME 레코드를 포함하고 CNAME 레코드의 데이터 필드에 지정된 도메인 이름에서 쿼리를 계속합니다.

- 이름 서버가 QNAME=ISIF.ARPA, QTYPE=A 및 QCLASS=IN을 사용하여 쿼리를 처리 중이고 다음과 같은 리소스 레코드를 가지고 있다고 가정합니다.

```text
            ISIF.ARPA     CNAME   IN     F.ISI.ARPA         
            F.ISI.ARPA    A       IN     10.2.0.52          
```

- 이 두 RR은 모두 응답으로 반환됩니다.

- 위의 예에서 ISIF.ARPA에는 CNAME RR 이외의 RR이 없기 때문에 ISIF.ARPA와 연결된 리소스는 IN CLASS의 F.ISI.ARPA와 정확히 연결된 리소스로 나타납니다. CNAME은 검색이 실패한 경우에만 유효하므로 CNAME을 사용하여 기본값을 구성할 수도 있습니다. 예를 들어, 이름 서버에 다음과 같은 RR 세트가 있다고 가정합니다.

```text
            F.ISI.ARPA    A       IN     10.2.0.52          
            F.ISI.ARPA    MD      IN     F.ISI.ARPA         
            XXXX.ARPA     CNAME   IN     F.ISI.ARPA         
            XXXX.ARPA     MF      IN     A.ISI.ARPA         
```

- 이 데이터베이스를 사용하면 XXXX.ARPA에 대한 유형 A 쿼리는 XXXX.ARPA CNAME RR 및 F.ISI.ARPA A RR을 반환하지만 XXXX.ARPA에 대한 MAILA 또는 MF 쿼리는 정보 없이 XXXX.ARPA MF RR을 반환합니다. F.ISI.ARPA에서. 이 구조는 전송하는 데 사용될 수 있습니다.

- XXXX.ARPA로 주소가 지정된 메일은 A.ISI.ARPA로, XXXX.ARPA용 TELNET은 F.ISI.ARPA로 지정됩니다.

```text
   Wildcards
```

- 어떤 경우에는 관리자가 도메인 전체 또는 일부에 대한 기본 리소스 정보를 연결하기를 원할 수 있습니다. 예를 들어, CSNET 도메인 관리자는 IN 기능 없이 CSNET 도메인의 모든 호스트에 대해 IN 클래스 메일 전달을 설정하려고 할 수 있습니다. 이러한 경우 도메인 시스템은 다른 레이블과 일치하는 특수 레이블 "\*"를 제공합니다. "\*"는 단일 레이블에만 일치하며 0개 또는 2개 이상의 레이블과 일치하지 않습니다. 또한 "\*"는 QCLASS 및 QTYPE의 "\*" 값과 구별됩니다.

- "\*"의 의미는 쿼리 도메인 이름\(QNAME\)에 나타나는지 아니면 데이터베이스의 RR에 나타나는지에 따라 달라집니다.

- QNAME에 "\*"가 사용되면 리소스 레코드의 "\*"만 일치할 수 있습니다.

- 데이터베이스의 RR에 "\*"가 나타나면 기존의 정확한 일치를 재정의할 수 없습니다. 예를 들어, 이름 서버가 UDEL.CSNET 도메인에 대한 쿼리를 수신하고 UDEL.CSNET 및 \*.CSNET 모두에 대해 적절한 RR이 있는 경우 UDEL.CSNET RR이 사용되고 \*.CSNET RR은 무시됩니다. 동일한 데이터베이스에 대한 쿼리가 FOO.CSNET을 지정한 경우 \*.CSNET RR이 사용되지만 QNAME의 해당 레이블이 "\*"를 대체합니다. 따라서 FOO.CSNET 쿼리는 \*.CSNET RR과 일치하고 \*.CSNET이 아닌 FOO.CSNET에 대한 RR을 반환합니다.

- "\*" 라벨이 포함된 RR은 네임 서버 유지 관리 작업을 통해 영역이 전송될 때 정확하게 복사됩니다.

- 이러한 의미는 이름 서버가 먼저 쿼리와 정확히 일치하는 항목을 검색한 다음 가장 왼쪽 레이블을 "\*"로 바꾸고 다시 시도하여 모든 레이블이 "\*"가 되거나 검색이 성공할 때까지 프로세스를 반복함으로써 쉽게 구현됩니다. .

- RR의 TYPE=\*은 금지됩니다. 허용되는 경우 이 데이터는 유형에 따라 다르므로 요청자는 RR의 데이터를 해석할 방법이 없습니다.

- CLASS=\*도 금지됩니다. QCLASS=\*를 사용하여 유사한 효과를 얻을 수 있으며, QCLASS=\* 및 CLASS=\*를 모두 허용하면 뚜렷한 이점 없이 복잡성이 발생합니다.

시나리오

샘플 도메인 공간에서 별도의 도메인 공간을 원한다고 가정합니다.

- 루트, DDN, ARPA, CSNET, MIT 및 ISI 도메인에 대한 관리 제어. 다음과 같이 네임서버를 할당할 수 있습니다.

```text
                                   |(B.ISI.ARPA)                  
                                   |(UDEL.CSNET)                  
                +------------------+------------------+           
                |                  |                  |           
               DDN               ARPA               CSNET         
                |(JCS.DDN)         |(F.ISI.ARPA)      |(UDEL.ARPA)
          +-----+-----+            |(A.ISI.ARPA)+-----+-----+     
          |     |     |            |            |           |     
         JCS  ARMY  NAVY           |           UDEL        UCI    
                                   |                              
          +--------+---------------+---------------+--------+     
          |        |               |               |        |     
         DTI      MIT             ISI             UDEL     NBS    
                   |(AI.MIT.ARPA)  |(F.ISI.ARPA)                  
               +---+---+       +---+---+                          
               |       |       |   |   |                          
              DMS     AI       A   B   F                          
```

이 예에서 권한 있는 이름 서버는 다음과 같습니다.

- 도메인 트리에서 제어권을 갖는 지점에 괄호를 붙입니다.

- 따라서 루트 이름 서버는 B.ISI.ARPA 및 UDEL.CSNET에 있고, DDN 이름 서버는 JCS.DDN에 있고, CSNET 도메인 서버는 UDEL.ARPA에 있습니다.

- 실제 시스템에서는 모든 도메인에 중복 네임서버가 있어야 하는데, 이 예시에서는 ARPA 도메인에만 A.ISI.ARPA, F.ISI.ARPA 중복 서버가 있습니다. \(B.ISI.ARPA 및 UDEL.CSNET 이름 서버는 서로 다른 클래스를 처리하기 때문에 중복되지 않습니다.\) F.ISI.ARPA 이름 서버는 ARPA 도메인에 대한 권한을 가지지만 MIT.ARPA 도메인에 대한 권한을 다음에게 위임합니다. AI.MIT.ARPA의 이름 서버. A.ISI.ARPA 이름 서버도 ARPA 도메인에 대한 권한을 가지지만 ISI.ARPA 및 MIT.ARPA 도메인을 모두 다른 이름 서버에 위임합니다.

```text
   B.ISI.ARPA Name server for " "
```

- B.ISI.ARPA에는 IN 클래스에 대한 루트 이름 서버가 있습니다. 해당 데이터베이스에는 다음이 포함될 수 있습니다.

```text
            Domain        Resource Record                   

            " "           SOA     IN     A.ISI.ARPA         
            DDN           NS      IN     JCS.DDN            
            ARPA          NS      IN     F.ISI.ARPA         
            CSNET         NS      IN     UDEL.ARPA          
            " "           NS      IN     B.ISI.ARPA         
            " "           NS      CS     UDEL.CSNET         
                                    
            JCS.DDN       A       IN     9.0.0.1            
            F.ISI.ARPA    A       IN     10.2.0.52          
            UDEL.CSNET    A       CS     302-555-0000       
            UDEL.ARPA     A       IN     10.0.0.96          
```

- 네임 서버가 IN 클래스의 루트 도메인에 대해 권한이 있음을 알 수 있도록 루트에 대한 SOA 레코드가 필요합니다. SOA 리소스 레코드의 내용은 다시 A.ISI.ARPA를 가리키며 권한 영역에 대한 마스터 데이터가 원래 이 호스트에서 온 것임을 나타냅니다. 처음 세 개의 NS 레코드는 권한 위임을 나타냅니다. B.ISI.ARPA 이름 서버에 대한 NS 루트 항목은 이 이름 서버가 자신에 대해 알고 루트\(권한이 있는\)에 대한 NS 정보에 대한 쿼리에 올바르게 응답할 수 있도록 필요합니다. CS 클래스의 루트 항목은 UDEL.CSNET이 CS 클래스 루트에 대한 권한 있는 이름 서버임을 나타냅니다. UDEL.CSNET 및 UDEL.ARPA는 동일한 이름 서버를 참조할 수도 있고 참조하지 않을 수도 있습니다. 이 정보로는 알 수 없습니다.

- 이 이름 서버가 QTYPE=MAILA, QCLASS=IN, QNAME=F.ISI.ARPA를 지정하는 쿼리를 전송받은 경우 F.ISI.ARPA에 대한 권한이 없다고 판단하여 처리\(이전 알고리즘 사용\)를 시작합니다. . 테스트에서는 " "에 권한이 있음을 기록하지만 권한이 ARPA에서 위임되었으며 다른 SOA를 통해 다시 설정되지 않았다는 점도 기록합니다. 따라서 응답은 도메인 ARPA에 대한 NS 레코드를 반환합니다.

- QCLASS=CS로 이 서버에 제시된 모든 쿼리는 UDEL.CSNET NS 레코드가 응답으로 반환되는 결과를 낳습니다.

F.ISI.ARPA ARPA 및 ISI.ARPA용 이름 서버

- 동일한 도메인 공간에서 도메인 ARPA 및 ISI.ARPA에 대한 F.ISI.ARPA 데이터베이스는 다음과 같을 수 있습니다.

```text
            Domain        Resource Record                   

            " "           NS      IN     B.ISI.ARPA         
            " "           NS      CS     CSNET.UDEL         
            ARPA          SOA     IN     B.ISI.ARPA         
            ARPA          NS      IN     A.ISI.ARPA         
            ARPA          NS      IN     F.ISI.ARPA         
            MIT.ARPA      NS      IN     AI.MIT.ARPA        
            ISI.ARPA      SOA     IN     F.ISI.ARPA         
            ISI.ARPA      NS      IN     F.ISI.ARPA         

            A.ISI.ARPA    MD      IN     A.ISI.ARPA         
            ISI.ARPA      MD      IN     F.ISI.ARPA         
            A.ISI.ARPA    MF      IN     F.ISI.ARPA         
            B.ISI.ARPA    MD      IN     B.ISI.ARPA         
            B.ISI.ARPA    MF      IN     F.ISI.ARPA         
            F.ISI.ARPA    MD      IN     F.ISI.ARPA         
            F.ISI.ARPA    MF      IN     A.ISI.ARPA         
            DTI.ARPA      MD      IN     DTI.ARPA           
            NBS.ARPA      MD      IN     NBS.ARPA           
            UDEL.ARPA     MD      IN     UDEL.ARPA          

            A.ISI.ARPA    A       IN     10.1.0.32          
            F.ISI.ARPA    A       IN     10.2.0.52          
            B.ISI.ARPA    A       IN     10.3.0.52          
            DTI.ARPA      A       IN     10.0.0.12          
            AI.MIT.ARPA   A       IN     10.2.0.6           
            DMS.MIT.ARPA  A       IN     10.1.0.6           
            NBS.ARPA      A       IN     10.0.0.19          
            UDEL.ARPA     A       IN     10.0.0.96          
```

- IN 클래스의 경우 ARPA용 SOA RR은 이 이름 서버가 도메인 ARPA에 대해 권한이 있고 이 권한에 대한 마스터 파일이 B.ISI.ARPA에 저장되어 있음을 나타냅니다. 이 영역은 데이터베이스가 다른 영역의 이 이름 서버에 권한을 다시 위임하는 ISI.ARPA로 확장되며 AI.MIT.ARPA의 이름 서버에서 제공되는 MIT.ARPA 도메인을 포함하지 않습니다.

- 이 이름 서버는 CS 클래스의 모든 데이터에 대해 권한이 없습니다. CS 클래스 쿼리를 해결하는 데 사용할 수 있는 CS 데이터의 루트 서버에 대한 포인터가 있습니다.

이 이름 서버가 다음 형식의 쿼리를 받았다고 가정합니다.

- QNAME=A.ISI.ARPA, QTYPE=A, QCLASS=IN. 권위 검색

- " "에 대한 NS 레코드, ARPA의 SOA, ISI.ARPA의 위임 및 ISI.ARPA의 권한 재개를 알 수 있습니다. 따라서 이 쿼리에 대한 권한이 있다는 것을 알 수 있습니다. 그런 다음 A.ISI.ARPA에 대한 A 레코드를 찾고 이 레코드가 포함된 데이터그램을 반환합니다.

- 다른 쿼리는 QNAME=B.ISI.ARPA, QTYPE=MAILA, QCLASS=\*일 수 있습니다. 이 경우 네임 서버는 QCLASS의 "\*" 값 때문에 권한을 부여할 수 없다는 것을 알고 일치하는 도메인 B.ISI.ARPA에 대한 레코드를 찾습니다. 이름 서버가 이름 서버 알고리즘에 언급된 추가 레코드 포함을 수행한다고 가정하면 반환된 데이터그램에는 다음이 포함됩니다.

```text
            ISI.ARPA      NS      IN     F.ISI.ARPA         
            " "           NS      CS     UDEL.CSNET         
            B.ISI.ARPA    MD      IN     B.ISI.ARPA         
            B.ISI.ARPA    MF      IN     F.ISI.ARPA         
            B.ISI.ARPA    A       IN     10.3.0.52          
            F.ISI.ARPA    A       IN     10.2.0.52          
```

- 쿼리가 QNAME=DMS.MIT.ARPA, QTYPE=MAILA, QCLASS=IN인 경우 네임 서버는 AI.MIT.ARPA가 권한 있는 네임 서버임을 발견하고 다음을 반환합니다.

```text
            MIT.ARPA      NS      IN     AI.MIT.ARPA        
            AI.MIT.ARPA   A       IN     10.2.0.6           
```

- 이 경우 요청자는 AI.MIT.ARPA에 있는 MIT.ARPA 도메인 이름 서버에서 정보를 찾도록 지시됩니다.

UDEL.ARPA 및 UDEL.CSNET 이름 서버

- 샘플 도메인에 대한 이전 논의에서 UDEL.CSNET과 UDEL.ARPA가 동일한 이름 서버일 수 있다고 언급했습니다. 이 예에서는 이것이 사실이라고 가정합니다. 따라서 이름 서버는 CS 클래스의 루트에 대한 권한이고 클래스 IN의 경우 CSNET 도메인에 대한 권한입니다.

- 이 이름 서버는 ARPA 인터넷과 CSNET 시스템 간의 메일 전달을 처리합니다. RR은 이 문제를 해결하는 한 가지 접근 방식을 보여줍니다. 이름 서버에는 다음과 같은 리소스 레코드가 있습니다.

```text
            " "           SOA     CS     UDEL.CSNET         
            " "           NS      CS     UDEL.CSNET         
            " "           NS      IN     B.ISI.ARPA         
            CSNET         SOA     IN     UDEL.ARPA          
            CSNET         NS      IN     UDEL.ARPA          
            ARPA          NS      IN     A.ISI.ARPA         

            *.CSNET       MF      IN     UDEL.ARPA          
            UDEL.CSNET    MD      CS     UDEL.CSNET         
            UCI.CSNET     MD      CS     UCI.CSNET          
            UDEL.ARPA     MD      IN     UDEL.ARPA          

            B.ISI.ARPA    A       IN     10.3.0.52          
            UDEL.ARPA     A       IN     10.0.0.96          
            UDEL.CSNET    A       CS     302-555-0000       
            UCI.CSNET     A       CS     714-555-0000       
```

이 이름 서버가 다음 형식의 쿼리를 받았다고 가정합니다.

- QNAME=UCI.CSNET, QTYPE=MAILA, QCLASS=IN. 이름 서버는 IN 클래스 아래의 CSNET 도메인에 대해 권한이 있음을 발견하지만 UCI.CSNET에 대한 명시적인 메일 데이터는 찾지 않습니다. 그러나 \*.CSNET 레코드를 사용하면 다음과 같은 응답을 생성합니다.

```text
            UCI.CSNET     MF      IN     UDEL.ARPA          
            UDEL.ARPA     A       IN     10.0.0.96          
```

- 이 이름 서버가 QNAME=UCI.CSNET, QTYPE=MAILA 및 QCLASS=CS 형식의 쿼리를 수신한 경우 이름 서버는 다음을 반환합니다.

```text
            UCI.CSNET     MD      CS     UCI.CSNET          
            UCI.CSNET     A       CS     714-555-0000       
```

- 이 구성표를 사용하면 <anything\>.CSNET으로 주소가 지정된 모든 메일을 전달할 수 있지만 세 개 이상의 구성 요소가 있는 이름에는 도움이 되지 않습니다. A.B.CSNET. 이 문제는 \*.\*.CSNET에 대한 일련의 MF 항목으로 "수정"될 수 있지만,

- \*.\*.\*.CSNET 등 더 세련된 솔루션은 CSNET 이름 서버에 더 영리한 패턴 일치 알고리즘을 도입하는 것입니다.

네임서버 요구사항 요약

- 네임서버의 요구사항은 다음과 같습니다.

- 1. 부모로부터 인정을 받아야 합니다.

- 2. 권한이 있는 모든 도메인 이름에 대한 완전한 리소스 정보를 가지고 있어야 합니다.

- 3. 마스터를 보유하고 있는 마스터 파일이나 이름 서버로부터 권위 있는 정보를 주기적으로 새로 고쳐야 합니다.

- 4. 정보를 캐시하는 경우 해당 정보에 대한 TTL 관리도 처리해야 합니다.

```text
         5. It must answer simple queries.

   Inverse queries
```

이름 서버는 매핑하는 역 쿼리도 지원할 수 있습니다.

- 특정 리소스를 해당 리소스가 있는 도메인 이름 또는 도메인 이름에 연결합니다. 예를 들어 쿼리가 도메인 이름을 호스트 주소에 매핑하는 동안 해당 역 쿼리는 주소를 다시 도메인 이름에 매핑할 수 있습니다.

- 이 서비스의 구현은 네임 서버에서 선택 사항이지만 모든 네임 서버는 최소한 역 쿼리 메시지를 이해하고 오류 응답을 반환할 수 있어야 합니다.

- 도메인 시스템은 호스트 주소나 기타 리소스 유형이 아닌 도메인 이름으로 구성되므로 역질의의 완전성이나 고유성을 보장할 수 없습니다. 일반적으로 역 쿼리의 작동을 보장하려는 확인자 또는 기타 프로그램은 적절한 데이터가 있는 것으로 알려진 이름 서버를 사용하거나 관심 도메인의 모든 이름 서버에 요청해야 합니다.

- 예를 들어, 확인자가 ARPA 인터넷의 임의 호스트에 대해 역 쿼리를 수행하려는 경우 모든 IN 데이터가 고려되었음을 알 수 있을 만큼 충분한 이름 서버 세트를 참조해야 합니다. 실제로는 상당히 포괄적인 데이터베이스가 있는 이름 서버에 대한 단일 역 쿼리가 대부분의 역 쿼리를 만족시켜야 합니다.

- 역질의에 대한 자세한 논의는 \[14\]에 포함되어 있다.

```text
   Completion services
```

- 일부 기존 시스템은 인수의 부분 사양을 완료하는 기능을 제공합니다. 일반적인 원칙은 사용자가 인수의 처음 몇 문자를 입력한 다음 이스케이프 문자를 눌러 시스템이 나머지를 완료하도록 하는 것입니다. 일부 완성 시스템에서는 사용자가 고유할 만큼 충분한 인수 유형을 요구합니다. 다른 사람들은 그렇지 않습니다.

- 다른 시스템에서는 사용자가 하나의 인수를 지정하고 시스템에 다른 인수를 입력하도록 요청할 수 있습니다. 예를 들어, 많은 메일 시스템에서는 사용자가 로컬 메일 배달을 위해 호스트 없이 사용자 이름을 지정할 수 있습니다.

- 도메인 시스템은 도메인 시스템에 대해 유사한 서비스를 수행하는 이름 서버 완료 트랜잭션을 정의합니다. 이 서비스의 구현은 이름 서버에서 선택 사항이지만 모든 이름 서버는 최소한 완료 요청을 이해하고 오류 응답을 반환할 수 있어야 합니다.

- 확인자가 완료를 요청하려는 경우 QNAME을 부분 문자열로, QTYPE을 원하는 리소스 유형으로, QCLASS를 원하는 클래스로 설정하는 메시지를 네임 서버에 보냅니다. 완료 요청에는 대상 도메인에 대한 RR도 포함됩니다. 대상 도메인 RR은 리소스의 기본 위치를 식별합니다. 완료 요청에서 QNAME에는 이름을 종료하기 위한 null 레이블이 있어야 하지만 그 존재는 무시됩니다. 완료 요청은 쿼리가 아니지만 일부 동일한 필드 형식을 공유합니다.

- 예를 들어 완료 요청에는 QTYPE=A, QNAME=B, QCLASS=IN 및 ISI.ARPA에 대한 RR이 포함될 수 있습니다. 이 요청은 이름이 "B"로 시작하고 ISI.ARPA에 "가까운" 리소스에 대한 완료를 요청합니다. 이는 B.ISI.ARPA를 참조하는 방법으로 "B"를 사용하는 ISI 커뮤니티에서 사용되는 일반적인 약어일 수 있습니다.

- 완료 요청 처리의 첫 번째 단계는 "전체 라벨" 일치를 찾는 것입니다. 이름 서버가 위에서 언급한 요청을 받으면 유형 A, 클래스 IN이고 도메인 이름이 QNAME 레이블\(이 경우 "B"\)로 시작하는\(왼쪽\) 모든 레코드를 찾습니다. 여러 레코드가 일치하는 경우 이름 서버는 도메인 이름이 기본 도메인 이름의 레이블과 가장 많이 일치하는 레코드\(오른쪽부터\)를 선택합니다. 여전히 후보가 여러 개인 경우 이름 서버는 도메인 이름이 가장 짧은\(이름의 옥텟 기준\) 도메인 이름을 가진 레코드를 선택합니다. 여러 개의 레코드가 남아 있으면 이름 서버는 이를 모두 반환합니다.

- 이전 알고리즘에서 레코드가 발견되지 않으면 네임 서버는 QNAME의 가장 오른쪽 레이블이 완전하지 않다고 가정하고

- 일치하지만 QNAME의 가장 오른쪽 레이블에 문자를 추가해야 하는 레코드를 찾습니다. 예를 들어, 이전 검색에서는 BB.ARPA가 B와 일치하지 않지만 이 검색에서는 일치합니다. 여러 개의 적중 항목이 발견되면 동일한 삭제 전략을 따릅니다.

- 완성에 대한 자세한 논의는 \[14\]에서 확인할 수 있다.

---
# **RESOLVERS**

```text
   Introduction
```

- 리졸버는 사용자 프로그램을 도메인 이름 서버에 연결하는 프로그램입니다. 가장 간단한 경우, 리졸버는 서브루틴 호출, 시스템 호출 등의 형태로 사용자 프로그램\(예: 메일 프로그램, TELNET, FTP\)으로부터 요청을 수신하고 원하는 정보를 로컬 호스트의 데이터와 호환되는 형식으로 반환합니다. 형식.

- 확인자는 여러 이름 서버를 참조해야 할 수 있으므로 확인자가 완료하는 데 걸리는 시간은 다를 수 있습니다. 이러한 차이는 이름 서버와 확인자 간의 분할을 정당화하는 일부입니다. 네임 서버는 데이터그램을 사용할 수 있으며 기본적으로 네트워크 지연에 짧은 서비스 시간을 더한 것과 동일한 응답 시간을 갖는 반면, 확인자는 본질적으로 불확실한 시간이 걸릴 수 있습니다.

- 두 가지 유형의 리졸버가 있을 것으로 예상됩니다. 필요할 때 여러 이름 서버를 통해 연결할 수 있는 간단한 리졸버와 향후 쿼리에 사용하기 위해 리소스 레코드를 캐시하는 보다 복잡한 리졸버입니다.

```text
   Simple resolvers
```

- 단순 리졸버에는 다음 기능이 필요합니다.

- 1. 네임서버에 접근하는 방법을 알아야 하며, 자신이 서비스하는 호스트에 대한 권한 있는 네임서버를 알아야 한다.

- 2. 클라이언트에게 유용한 정보를 반환하기 위해 보내는 쿼리의 클래스 필드를 설정할 수 있도록 클라이언트에 대한 프로토콜 기능을 알아야 합니다. 확인자가 여러 프로토콜 기능을 가진 클라이언트에 서비스를 제공하는 경우 클라이언트의 기본 설정을 지원할 수 있어야 합니다.

- 다중 프로토콜 클라이언트에 대한 해석기는 \* 클래스 값을 사용하여 모든 클래스에 대한 정보를 수집하거나 클라이언트가 지원하는 클래스를 반복할 수 있습니다. 두 경우 모두 확인자는 호스트의 기본 설정을 이해해야 합니다. 예를 들어 CSNET과 ARPA를 모두 지원하는 호스트

- 인터넷 프로토콜은 프로토콜에 관계없이 메일 전달\(MF\)보다 메일 전달\(MD\)을 선호할 수도 있고, MD 또는 MF가 필요한지 여부에 관계없이 하나의 프로토콜을 선호할 수도 있습니다. 루프를 방지하려면 주의가 필요합니다.

- 3. 확인자는 쿼리에 대해 신뢰할 수 있는 이름 서버에 도달하기 위해 여러 이름 서버를 통해 연결할 수 있어야 합니다. 확인자는 참조의 루프를 방지해야 합니다. 간단한 정책은 참조하는 이름 서버보다 쿼리 이름과 더 많이 일치하지 않는 참조를 삭제하고 동일한 이름 서버에 두 번 쿼리하는 것을 방지하는 것입니다. \(이 테스트는 도메인 이름 대신 이름 서버의 주소를 사용하여 수행해야 합니다. 이름 서버에 여러 도메인 이름이 있거나 별칭에 오류가 있는 경우 문제가 발생합니다.

- 4. 확인자는 이름 서버가 응답하지 않을 때 대체 이름 서버를 시도할 수 있어야 합니다.

- 5. 확인자는 클라이언트에게 다양한 실패 조건을 전달할 수 있어야 합니다. 이러한 실패 조건에는 알 수 없는 도메인 이름, 알려진 도메인 이름에 대한 알 수 없는 리소스, 도메인에 대한 권한 있는 이름 서버에 액세스할 수 없음 등이 포함됩니다.

- 6. 리졸버가 쿼리에 데이터그램을 사용하는 경우 손실되고 중복된 데이터그램을 복구해야 합니다.

캐시 관리 기능이 있는 리졸버

- 캐싱은 이름 서비스 성능을 향상시키는 도구를 제공하지만 잘못된 결과의 잠재적인 원인이기도 합니다. 예를 들어 데이터베이스는 나중에 권한 있는 이름 서버에서 변경되는 정보를 캐시할 수 있습니다. 캐싱을 제거하지 않으면 이 문제를 해결할 수 없지만 시간 제한을 사용하면 드물게 발생하는 문제로 줄일 수 있습니다.

- 이름 서버가 리소스 레코드를 반환할 때 각 레코드에는 관련 TTL\(Time-To-Live\) 필드가 있습니다. 이 필드는 초 단위로 표현되며 16비트의 의미를 갖습니다.

- 확인자가 반환된 리소스 레코드를 캐시할 때 TTL 필드도 기억해야 합니다. 확인자는 해당 시간이 경과하면 레코드를 삭제해야 합니다. 확인자가 이름 서버와 데이터베이스를 공유하는 경우 단순히 레코드를 삭제하는 대신 가져온 레코드의 TTL 필드를 주기적으로 줄여야 합니다. 이 전략은 TTL 필드가 리소스 레코드가 캐시된 시간을 반영하지 않는 리소스 레코드를 내보내는 것을 방지하는 데 필요합니다. 물론 리졸버는

- 연관된 이름 서버가 권한인 레코드의 TTL 필드를 감소시키지 않습니다.

---
# **Appendix 1 - Domain Name Syntax Specification**

도메인 이름의 기본 구문은 다음 BNF 규칙에 따라 제공됩니다. 이 구문을 준수하면 도메인 이름을 사용하는 많은 응용 프로그램\(예: 메일, TELNET\)에서 문제가 줄어듭니다. \[14\]에 설명된 일부 애플리케이션은 이진 정보가 포함된 도메인 이름을 사용하므로 이 구문을 따르지 않습니다.

```text
      <domain> ::=  <subdomain> | " "

      <subdomain> ::=  <label> | <subdomain> "." <label>

      <label> ::= <letter> [ [ <ldh-str> ] <let-dig> ]

      <ldh-str> ::= <let-dig-hyp> | <let-dig-hyp> <ldh-str>

      <let-dig-hyp> ::= <let-dig> | "-"

      <let-dig> ::= <letter> | <digit>
```

- <letter\> ::= 대문자 A\~Z, 소문자 a\~z 중 영문자 52자 중 하나

- <digit\> ::= 0\~9까지 10개의 숫자 중 하나

도메인 이름에는 대문자와 소문자가 허용되지만 대소문자에는 아무런 의미가 없습니다. 즉, 철자는 동일하지만 대소문자가 다른 두 이름은 동일한 것처럼 처리됩니다.

레이블은 ARPANET 호스트 이름에 대한 규칙을 따라야 합니다. 문자로 시작하고 문자나 숫자로 끝나야 하며 내부 문자로는 문자, 숫자 및 하이픈만 사용할 수 있습니다. 길이에도 몇 가지 제한이 있습니다. 라벨은 63자 이하여야 합니다.

예를 들어, 다음 문자열은 ARPA 인터넷에서 호스트를 식별합니다.

```text
      F.ISI.ARPA     LINKABIT-DCN5.ARPA     UCL-TAC.ARPA
```

---
# **REFERENCES and BIBLIOGRAPHY**

\[1\] E. Feinler, K. Harrenstien, Z. Su 및 V. White, "DOD 인터넷 호스트 테이블 사양", RFC 810, 네트워크 정보 센터, SRI International, 1982년 3월.

```text
   [2]  J. Postel, "Computer Mail Meeting Notes", RFC 805,
        USC/Information Sciences Institute, February 1982.
```

\[3\] Z. Su 및 J. Postel, "인터넷 사용자 응용 프로그램을 위한 도메인 명명 규칙", RFC 819, 네트워크 정보 센터, SRI International, 1982년 8월.

\[4\] Z. Su, "인터넷 이름 서비스를 위한 분산 시스템", RFC 830, 네트워크 정보 센터, SRI International, 1982년 10월.

\[5\] K. Harrenstien 및 V. White, "NICNAME/WHOIS", RFC 812, 네트워크 정보 센터, SRI International, 1982년 3월.

\[6\] M. Solomon, L. Landweber 및 D. Neuhengen, "CSNET 이름 서버", 컴퓨터 네트워크, vol 6, nr 3, 1982년 7월.

```text
   [7]  K. Harrenstien, "NAME/FINGER", RFC 742, Network Information
        Center, SRI International, December 1977.

   [8]  J. Postel, "Internet Name Server", IEN 116, USC/Information
        Sciences Institute, August 1979.
```

\[9\] K. Harrenstien, V. White 및 E. Feinler, "호스트 이름 서버", RFC 811, 네트워크 정보 센터, SRI International, 1982년 3월.

```text
   [10] J. Postel, "Transmission Control Protocol", RFC 793,
        USC/Information Sciences Institute, September 1981.

   [11] J. Postel, "User Datagram Protocol", RFC 768, USC/Information
        Sciences Institute, August 1980.

   [12] J. Postel, "Simple Mail Transfer Protocol", RFC 821,
        USC/Information Sciences Institute, August 1980.
```

\[13\] J. Reynolds 및 J. Postel, "할당된 번호", RFC 870, USC/정보 과학 연구소, 1983년 10월.

\[14\] P. Mockapetris, "도메인 이름 - 구현 및

- 사양", RFC 883, USC/정보 과학 연구소, 1983년 11월.
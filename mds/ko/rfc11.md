

```text
Network Working Group                                         G. Deloche
Request for Comments: 11                                            UCLA
                                                             August 1969

                   Implementation of the Host - Host
                      Software Procedures in GORDO
```

---
# **TABLE OF CONTENTS**

```text
   Chapter                                                        Page
   -------                                                        ----
   1.  Introduction . . . . . . . . . . . . . . . . . . . . . . .   1
   2.  HOST - HOST Procedures . . . . . . . . . . . . . . . . . .   2
       2.1  Generalities  . . . . . . . . . . . . . . . . . . . .   2
       2.2  Connections and Links . . . . . . . . . . . . . . . .   2
            2.2.1  Definitions  . . . . . . . . . . . . . . . . .   2
            2.2.2  Connection types . . . . . . . . . . . . . . .   3
       2.3  Message Structure . . . . . . . . . . . . . . . . . .   5
       2.4  User Transactions . . . . . . . . . . . . . . . . . .   6
            2.4.1  List of transactions   . . . . . . . . . . . .   7
            2.4.2  HOST-HOST protocol and control messages  . . .   8
   3.  Implementation in GORDO  . . . . . . . . . . . . . . . . .  11
       3.1  Introduction to GORDO . . . . . . . . . . . . . . . .  11
            3.1.1  GORDO file system  . . . . . . . . . . . . . .  11
            3.1.2  GORDO process  . . . . . . . . . . . . . . . .  12
       3.2  Software Organization Overview  . . . . . . . . . . .  12
       3.3  Software Description  . . . . . . . . . . . . . . . .  13
            3.3.1  Data structures  . . . . . . . . . . . . . . .  13
                   3.3.1.1  Allocation tables . . . . . . . . . .  13
                   3.3.1.2  Buffer pages  . . . . . . . . . . . .  16
            3.3.2  Programs . . . . . . . . . . . . . . . . . . .  18
                   3.3.2.1  Handler . . . . . . . . . . . . . . .  18
                   3.3.2.2  Network . . . . . . . . . . . . . . .  19
       3.4  Software Procedures . . . . . . . . . . . . . . . . .  20
            3.4.1  Description of some typical sequences  . . . .  20
   Appendix A:  Flowcharts  . . . . . . . . . . . . . . . . . . .  23
```

```text
   [[RFC Editor Note: [s] represents subscript s]]
```

---
## **1.  INTRODUCTION**

이 기술 노트는 \(1\) HOST-HOST 절차와 \(2\) GORDO\(UCLA HOST 운영 체제\)에서 해당 프로그램의 구현에 중점을 둡니다.

첫 번째 섹션은 BBN 보고서 번호 1822 및 1763\[1\]과 밀접하게 관련되어 있으며 메시지 교환을 위한 HOST 기능을 지정합니다. 주로 링크와 연결, 메시지 구조, 트랜잭션, 제어 메시지를 다룬다.

두 번째 섹션은 소프트웨어 중심입니다. HOST 기능이 GORDO에 어떻게 구현되고 통합되는지 설명합니다. 데이터 구조, 프로그램, 버퍼, 인터럽트 처리 등과 관련됩니다.

```text
   [1]  Parts of this section are taken from or referred to those
   reports.
```

---
## **2.  HOST-HOST PROCEDURES**
---
## **2.1  Generalities**

기본 아이디어는 주어진 HOST에서 여러 사용자가 물리적 시설을 시분할하여 동시에 네트워크를 활용할 수 있어야 한다는 것입니다.

이는 각 HOST 운영 체제 내에 사용자로부터 나가는 메시지를 네트워크로 다중화하고 들어오는 메시지를 적절한 사용자에게 배포하는 특수 프로그램이 있어야 함을 의미합니다. 우리는 이 특별한 프로그램을 네트워크 프로그램이라고 부르겠습니다.

---
## **2.2  Links and Connections  (See figure 1)**

```text
   2.2.1  Definitions
```

네트워크를 호스트 컴퓨터 쌍이 아닌 원격 사용자 간에 메시지를 통신하기 위한 블랙박스\(동작은 알려져 있지만 메커니즘은 알려지지 않은 시스템\)로 간주하는 것이 편리합니다.

```text
      (a)  Logical connections
```

- 원격 HOST에 있는 두 사용자를 연결하는 통신 경로로 논리적 연결을 정의합니다.

- 이 개념을 사용하면 HOST 컴퓨터의 사용자\(사용자 프로그램\)는 \(1\) 원격 HOST 사용자에게 여러 논리적 연결을 설정하고 \(2\) 해당 연결을 통해 메시지를 보내거나 받을 수 있습니다.

- 연결은 사용자에게 전이중으로 나타납니다.

- 네트워크 프로그램의 목적 중 하나는 이러한 연결을 설정, 식별 및 유지하는 데 있어 사용자에게 서비스를 제공하는 것입니다.

```text
      (b)  Logical links
```

- 각 논리적 연결은 한 쌍의 방향 링크로 구성됩니다. 하나는 전송용이고 다른 하나는 수신용입니다.

- 논리 링크라고 불리는 이러한 링크는 네트워크 프로그램에 의해 설정되고 사용됩니다.

- 여기서 사용자는 연결에만 관심이 있고 링크에 대해서는 전혀 인식하지 못한다는 점에 유의하세요. 링크와 연결 사이의 관계는 네트워크 프로그램에 의해 수행됩니다.

- 한 쌍의 방향 링크로 연결을 정의하는 장점 중 하나는 HOST가 IMP를 통해 자신을 루프할 수 있다는 것입니다\(자신에게 연결을 엽니다\). 이 기능은 디버깅 목적으로 유용할 수 있습니다.

- 이 문서를 통해 더 이상 링크나 연결을 참조할 때 논리적 속성을 사용하지 않을 것입니다.

```text
   2.2.2  Connection types
```

네트워크 활용 시 높은 유연성을 얻으려면 연결을 분류하는 것이 좋습니다.

\(a\) 제어 연결, \(b\) 기본 연결, \(c\) 보조 연결의 세 가지 유형의 연결이 구별됩니다.

```text
      (a)  Control connection
```

- 이 연결은 특별한 상태를 가지며 HOST 쌍 사이에서 고유합니다. 예를 들어 네트워크에 x HOST가 포함된 경우 하나의 HOST에서 최대 x 개의 제어 연결이 발행됩니다.

- 이 연결은 제어 메시지를 주고받기 위해 원격 네트워크 프로그램에서 사용됩니다. 제어 메시지는 표준 연결 설정/삭제의 기본입니다. \(2.4.2 참조\)

- 여기서 이 제어 연결은 HOST 사용자가 사용하지 않는 유일한 연결입니다.

- 이제 표준 연결에 대해 설명하겠습니다.

```text
      (b)  Primary connection

      These connections connect remote users.
```

- 기본 연결:

```text
            * Is unique between a pair of users and is the first to be
               established.

            * Is "teletype-like", i.e.:
               - ASCII characters are transmitted;
               - Echoes are generated by the remote HOST;
               - The receiving HOST[s] scan for break characters;
               - The transmission rate is slow (less than 20
               characters/sec).

            * Is mainly used for transmitting control commands, e.g.,
               for log-in into a remote HOST operating system.

      (c) Auxiliary connection

         These connections also connect remote users:
```

- 보조 연결:

```text
            * Is opened in parallel to a primary connection and is not
               unique, i.e., several auxiliary connections can be
               established between users.

            * Is used for transmitting large volumes of data (file
               oriented).
```

- \* 바이너리 또는 문자 전송에 사용됩니다.

- \[그림 1 - 링크 및 연결 - PDF 파일 참조\]

---
## **2.3  Message Structure**

HOST는 메시지를 통해 서로 통신합니다. 메시지의 길이는 최대 8095비트까지 다양할 수 있습니다\(아래 구조 참조\). 따라서 더 큰 전송은 HOST 사용자에 의해 이러한 메시지의 시퀀스로 분할되어야 합니다.

- 메시지 구조는 그림 2와 같습니다.

- 여기에는 다음이 포함됩니다.

```text
      (1) A leader (32 bits): Message type, Source/Destination HOST,
          link number.  (See BBN report No. 1822, pp 13, 17)

      (2) A marketing (32 bits when sent by the Sigma 7) for starting a
          message text on a word boundary.  (See BBN report No. 1822,
          pp. 17, 19)

      (3) The message text (Max: 8015 bits for the Sigma 7).  It mostly
          consists of user's text.  However, it may represent
          information for use by the Network programs.  (Control
          messages, see 2.4.2)

      (4) A checksum (16 bits).  Its purpose is to check, at the HOST
          level, the right transmission of a message.  (Changes in bit
          pattern or packet transposition; packets are defined in BBN
          report No. 1763, p. 13)  See down below for checksum
          calculation.

      (5) A padding for solving word length mismatch problems.  (See BBN
          report No. 1822, p. 17, 19.).  As far as software is
          concerned, padding is only involved at message reception for
          delineating message ends.  (At transmission the hardware takes
          care of the padding.)

   Remark:

      Checksum calculation:
```

- HOST가 보낸 모든 메시지의 마지막 16비트는 체크섬입니다. 이 체크섬은 표시를 포함하여 전체 메시지에 대해 계산되지만 32비트 리더와 패딩은 제외됩니다. 체크섬을 계산하려면 다음을 수행하십시오.

```text
      1.  Consider the message to be padded with zeroes to a length of
          8640 bits.
```

1. 8640비트를 6개의 1440비트 세그먼트 S0, S1...S5로 분할합니다.

```text
      3.  Section each 1440-bit segment S into 90 16-bit elements, T0,
          T1...T89.

      4.  Define a function [(+)], which takes two 16-bit elements as
          inputs and outputs a 16-bit element.  This function is defined
          by

          Tm [(+)] Tn = Tm [(+)] Tn, if Tm + Tn < 2[exp 16]

          Tm [(+)] Tn = Tm [(+)] Tn - 2[exp 16] + 1, if Tm + Tn >= 2[exp
          16]
```

1. 각 1440비트 세그먼트 Si에 대해 Ci = K\(Si\)를 계산합니다. 여기서

```text
          K(S) = T0 [(+)] T1 + ..... T89

      6.  Computer C =
          C0[(+)]C1[(+)]C1[(+)]C2[(+)]C2[(+)]C2[(+)]C2....[(+)]C5
```

- \(C1\[\(+\)\]C1은 C1이 왼쪽으로 1비트 회전한 것임을 참고하세요\)

숫자 C는 체크섬입니다. Ci를 i비트만큼 회전시키는 이유는 패킷 전치를 감지하기 위함이다.

\[그림 2 - Sigma 7에서 보내는 메시지 형식 - PDF 파일 참조\]

---
## **2.4  User Transactions**

지금까지 논의한 내용에서 네트워크는 사용자에게 연결 묶음으로 나타납니다. 이제 이러한 연결을 어떻게 활용할 수 있는지 설명하겠습니다.

먼저, 연결 기능을 활용하기 위해 사용자가 액세스할 수 있어야 하는 일련의 트랜잭션을 설명하겠습니다.

그런 다음 이러한 트랜잭션을 실행하기 위한 네트워크 프로그램의 역할을 설명하겠습니다. 이는 네트워크 프로그램 간에 제어 메시지가 교환되는 HOST-HOST 프로토콜을 다룹니다.

설명을 위해 이러한 트랜잭션은 사용자 수준에서 서브루틴 호출 및 매개변수의 형태로 표시됩니다. 그러나 이는 구현이 이 패턴을 밀접하게 따른다는 것을 전혀 의미하지 않습니다. \(여기서는 구현 측면보다 설명에 더 관련되어 있습니다. 3장을 참조하세요.\)

2.4.1 거래 목록

아래 목록은 연결을 생성/끊고 이를 통해 데이터를 전송/수신하기 위해 사용자가 사용할 수 있는 서브루틴에 대한 설명입니다. 이 서브루틴 세트는 사용자 수준과 네트워크 프로그램 수준 사이의 일종의 인터페이스로 간주될 수 있습니다.

```text
   (a)  Open primary connection:

        OPENPRIM (CONNECTID, HOSTID, BUFFADDR, [OPT])
        CONNECTID:  Connection identification #
        HOSTID:  Remote HOST identification #
        BUFFADDR:  Buffer address for incoming messages.
        OPT:  Options such as message required after successful
              connection establishment, "full echo" (each message is
              transmitted back by the remote HOST for checking purpose),
              etc.

        Remark: [  ] means optional

   (b) Open auxiliary connection

        OPENAUX (CONNECTID, BUFFADDR, N, [OPT])
        CONNECTID:  Connection identification #, i.e., the
                    identification of the corresponding primary
                    connection (First a user has to open a primary
                    connection).
        BUFFADDR:  Same meaning as above.
        N:  Number of auxiliary connections that should be opened.
        OPT:  Same meaning as above.
```

\(c\) 연결을 통한 전송

```text
        TRANSM (CONNECTID, NO, BUFFADDR, N, [OPT])
        CONNECTID:  Connection identification #
        NO:  Connection #.  The primary connection is always referred to
             as being NO=0.  An auxiliary connection number corresponds
             to the order in which it has been established.  (The first
             auxiliary opened is referred to by NO=1, the second by
             NO=2, etc.)
        BUFFADDR:  Buffer address of the message to be transmitted.
        N:  Message size (byte number)
        OPT:  Options such as data type (characters vs. binary), trace
              bit, etc.

   (d)  Close connection

        CLOSE (CONNECTID, [N], [NO])
        CONNECTID: Connection identification #.
        N:  Number of connections to be closed.  If omitted all
            connections in use by the user, included the primary link,
            are closed.
        NO:  In case of N different from zero this number indicates the
             auxiliary connection # to be closed.
```

2.4.2 HOST-HOST 프로토콜 및 제어 메시지

HOST-HOST 프로토콜은 네트워크 프로그램에 의해 수행됩니다. 이는 주로 이전 트랜잭션\(사용자가 시작한\)의 실행을 포함하며 HOST-HOST 대화를 다룹니다.

이 대화는 연결을 열거나 끊는 제어 절차를 수행하며 제어 링크를 통해 제어 메시지를 교환하는 것으로 구성됩니다. 제어 메시지는 일반 메시지와 동일한 구조를 가지고 있습니다. 사용자 대신 네트워크 프로그램이 사용하는 텍스트만 다릅니다.

이 제어 절차는 IMP 컴퓨터에 구현된 전송 제어 절차와 전혀 관련이 없다고 주장하겠습니다. 우리는 호스트 수준\(네트워크 프로그램\)에 있으므로 아래에서 설명할 제어 메시지는 일반 메시지처럼 IMP를 통해 전송됩니다.

이제 이전 트랜잭션을 고려하고 각 트랜잭션에 대해 어떤 메시지가 어떤 링크를 통해 교환되는지 설명하십시오. 각 사례는 간단한 예를 통해 설명됩니다.

HOST\(x\) 사용자가 URSA라는 원격 HOST\(y\) 프로그램을 원한다고 가정합니다.

- \(a\) 기본 연결 열기: \(OPENPRIM\)

- HOST\(x\)의 네트워크 프로그램은 기본 연결 열기를 사용하여 깨어나\(3.3 참조\) HOST\(y\)의 네트워크 프로그램과 대화를 시작합니다.

- \(i\) HOST\(x\)는 다음 제어 메시지를 보냅니다:

```text
             HOST(x)       Control link                      HOST(y)
                         -------------------->
                           ENQ PRIM 0 1 2

             ENQ:     Enquiry for connection establishment (one ASCII
                      character)
             PRIM:    Connection type: primary (one special character)
             0 1 2:   Outgoing link #.  It is a decimal number (3 ASCII
                      characters), e.g., link #12.

                      This link # has been determined by the HOST(x)
                      Network program (See implementation: 3.3)

        (ii) HOST(y) acknowledges by sending back the following control
                      message:

             HOST(x)        Control link                     HOST(y)
                         <------------------------
                          ACK ENQ PRIM 0 1 2 0 1 5

             ACK:     Positive acknowledgment (one ASCII character)
             ENQ PRIM 0 1 2:  Same meaning as above.  This part of the
                      message is returned for checking purposes.
             0 1 5:   Incoming link #.  It follows the same pattern as
                      the outgoing link #.  This link # has been
                      determined by the HOST(y) Network program.

                      Now the connection is established; it will use
                      links #12 and 15 for exchanging user messages.
                      The connection is said to be in a pre-log-in
                      state, i.e., the remote HOST(y) expects its
                      standard log-in procedures.
```

- \(b\) 기본 연결을 통한 전송: \(TRANSM\)

- 기본 연결을 참조하는 TRANSM 서브루틴을 통해 HOST\(x\) 사용자는 HOST\(y\) 운영 체제에 로그인한 다음 URSA 프로그램\(HOST\(y\) 사용자 프로그램\)을 호출할 수 있습니다.

- 양쪽 끝의 네트워크 프로그램은 메시지 전달을 위해 링크 #12와 #15를 사용합니다. 이러한 메시지는 내용이 로그인 순서에 사용되는 표준 메시지입니다.

- 간단한 예는 다음과 같습니다.

```text
             HOST(x)     Prim. Link #12                       HOST(y)
                         ---------------------------->
                         ! S I G N - I N : X X

             HOST(x)     Prim. Link #15                       HOST(y)
                         <--------------------------
                         ! ! R E A D Y

             HOST(x)     Prim. Link #12                       HOST(y)
                         ---------------------------->
                           ! U R S A
```

- \(c\) 보조 연결 열기: \(OPENAUXI\)

- \(a\)와 매우 유사한 방식으로 HOST\(x\)와 HOST\(y\) 사이에 보조 연결이 설정됩니다. 이를 위해 제어 메시지는 제어 링크를 통해 교환됩니다.

```text
             HOST(x)           Control link                  HOST(y)
                         ------------------------------>
                               ENQ AUX 0 2 5

             HOST(x)           Control link                  HOST(y)
                         <--------------------------------
                             ACK ENQ AUX 0 2 5 0 2 1
```

- 이제 보조 연결이 설정되었으며 표준 메시지 교환을 위해 링크 #25 및 21을 사용합니다.

- \(d\) 보조 연결을 통한 전송: \(TRANSM\)

- 보조 연결을 참조하는 TRANSM 서브루틴을 통해 양쪽 끝의 사용자가 데이터를 교환할 수 있습니다.

```text
             HOST(x)        Aux. Link #25                    HOST(y)
                         -------------------------------->
                               X X ..... X X

             HOST(x)         Aux. Link #21                   HOST(y)
                         <--------------------------------
                             X ......... X

         etc.......

      (e)  Close connections: (CLOSE)
```

- \(a\)와 유사한 방식으로 수행된다. 사용자가 CLOSE 서브루틴을 호출하면 양쪽 끝의 네트워크 프로그램이 제어 메시지를 교환합니다.

```text
             HOST(x)           Control Link                  HOST(y)
                         ----------------------------->
                               EOT 0 0 1 0 1 2

             EOT:     End of transmission (one ASCII character)
             0 0 1 :  No. of connections to be closed (3 decimal ASCII
                       characters)
             0 1 2 :  Outgoing link # to be closed.
```

- 그러면 HOST\(y\)는 \(a\)와 같이 다시 응답합니다.

```text
             HOST(x)           Control Link                  HOST(y)
                         <-----------------------------
                            ACK EOT 0 0 1 0 1 2 0 1 5
```

- 참고 1 - \(a\), \(c\), \(e\)에서 HOST\(y\)는 ACK 대신 부정 응답 문자 NAK를 포함하는 메시지에 응답할 수 있습니다. 이는 잘못된 순서, 이미 열린 연결 등 다양한 이유 때문입니다. 메시지는 NAK IND일 수 있습니다. 여기서 IND는 이전 블록이 거부된 이유를 코딩된 형식으로 나타내는 영숫자 문자입니다. 이러한 승인을 다시 받으면 HOST\(x\)는 HOST\(y\)가 이를 수락할 때까지 메시지를 반복합니다. 연속적인 "NAK 메시지"가 너무 많이 발생하면 긴급 절차가 수행됩니다.

- 참고 2 - 위의 각 그림\(화살표\)에는 메시지 텍스트만 표시됩니다. 실제로 완전한 메시지\(리더, 표시, 패딩 등 포함\)가 이러한 링크를 통해 교환됩니다.

---
## **3.  IMPLEMENTATION IN GORDO**
---
## **3.1  Introduction to GORDO**

GORDO는 SDS Sigma 7에 구현된 시분할 시스템입니다. 우리 논문과 관련된 몇 가지 특징을 아래에 간략히 설명합니다.

```text
   3.1.1  GORDO file system
```

파일 시스템은 페이지 지향적입니다. 파일과 디렉토리로 구성됩니다. 파일은 제목과 파일 본문을 구성하는 여러 페이지로 구성됩니다. 디렉토리는 파일이나 다른 디렉토리를 가리키는 여러 항목으로 구성됩니다.

```text
   3.1.2  GORDO process
```

\* 프로세스는 프로그램\(프로시저 및 데이터\)에 논리 환경을 더한 것입니다. 즉, 프로세스는 GORDO 스케줄러에 의해 알려지고 제어되는 프로그램입니다.

\* 사용자\(작업\)는 컴파일러, 로더, 편집기, 응용 프로그램 등 다양한 프로세스를 가질 수 있습니다. 프로세스는 시스템 호출\(FORK\)을 통해 생성됩니다.

\* 프로세스가 참조할 수 있는 공간은 128k 워드 길이의 가상 공간이다. 그 중 일부\(8k\)는 운영 체제용으로 예약되어 있고, 다른 부분\(120k\)은 사용자가 직접 액세스합니다. 이는 나중에 '결합' 시 가상 공간의 일부를 채우거나 수정할 수 있습니다. \(아래 참조: 서비스 호출\) 다른 파일에서 가져온 페이지입니다. 그림 3은 이러한 결합을 보여줍니다.

\* 프로세스는 시스템 호출을 통해 서비스를 요청할 수 있습니다. 우리 논문과 관련된 시스템 호출은 다음과 같습니다.

```text
         WAKE    for awaking (set active) a sleeping process
         SLEEP   for putting asleep another process (or itself)
         COUPLE  for coupling a page from the file space to the virtual
                 space.
```

\* 프로세스는 일반적으로 슬레이브 모드에서 실행됩니다. 그러나 I/O 프로세스로 설정되면 권한 있는 명령어에 액세스할 수 있습니다.

\* 프로세스는 "메일 박스" 디렉토리에 첨부된 파일을 통해 데이터를 공유할 수 있습니다.

비고: 이 노트에서는 프로세스와 프로그램이라는 단어가 같은 의미로 사용됩니다.

- \[그림 3 - 가상 공간과 결합 - PDF 파일 참조\]

---
## **3.2  Software Organization Overview**

그림 4는 전체 조직을 보여줍니다.

시스템은 "네트워크"와 "핸들러"라는 두 가지 주요 프로그램을 기반으로 합니다.

핸들러는 IMP-HOST 하드웨어 인터페이스와 밀접하게 관련된 I/O 인터럽트 루틴입니다. 수신 네트워크 메시지를 전송할 때 네트워크 프로세스를 제공합니다.

네트워크 프로세스는 대부분의 작업을 수행합니다.

주요 기능은 연결 열기/닫기 및 네트워크 메시지 전송/수신에 대한 사용자의 요청을 충족시키는 것입니다. 그렇게 하기 위해,

\* 할당 테이블\(HOST, CONNECT, INPUT LINK; 3.3.1.1 참조\)을 사용하여 링크를 설정, 식별 및 끊습니다.

\* 네트워크 메일박스 디렉토리를 탐색할 때 새로운 사용자의 존재를 인식합니다.

\* 메시지와 요청이 교환되는 공유 페이지\(연결 공유 페이지\)를 통해 활성 사용자와 통신합니다.

\* 작업 페이지에서 들어오고 나가는 메시지의 형식을 지정합니다. 이 작업 페이지에는 확장 기능\(비상 벨소리\)이 있습니다.

\* I/O 통신 버퍼를 포함하는 공유 페이지\(I/O 통신 페이지\)를 통해 핸들러와 통신합니다.

```text
        [Figure 4 - Software organization overview - see PDF file]
```

---
## **3.3  Software Description**
---
### **3.3.1  Data Structures**

```text
   3.3.1.1  Allocation tables: HOST, CONNECT, INPUT LINK
```

- 네트워크 프로그램은 3개의 테이블을 사용하여 링크와 연결을 설정, 식별 및 끊습니다.

- 원격 HOST #으로 정렬된 테이블입니다.

- 연결 번호별로 정렬된 테이블입니다.

- 입력 링크 #별로 정렬된 테이블입니다.

```text
        (a) HOST table (see figure 5)

            It is a bit table indicating the free outgoing links.  It
            has the following characteristics:

            *  Location: Disc resident
```

- \* 결합: 네트워크 프로세스 가상 공간에 결합됩니다.

- \* 크기: 원격 HOST만큼의 슬롯 수.

```text
            *  Slot structure: As many bits as possible outgoing links
                               to a remote HOST, i.e., 256.

            *  Access: Indexing.  Each slot is accessed through a remote
                       HOST #.

            *  Specific feature:  Throughout the whole table no more
                                  than 64 bits can be turned on.  This
                                  figure corresponds to the maximum
                                  number of outgoing links that can be
                                  activated at one time (No matter what
                                  is the number of remote HOST[s]).

        (b)  CONNECT table
```

- 이 테이블은 모든 연결 환경을 추적합니다.

- 다음과 같은 특징을 가지고 있습니다.

```text
            *  Location:  Disc resident
```

- \* 결합: 네트워크 프로세스 가상 공간에 결합

- \* 크기: 사용 중인 연결만큼의 슬롯 수.

```text
            *  Slot structure:  See figure 6.  Each slot is 2 word
                                length

            *  Access:  Indexing.  Each slot is accessed through a
                        connection #.  See 3.4 the way it is handled.

            *  Specific feature 1:  The slot structure corresponding to
                                    a primary connection is not
                                    identical to that of an auxiliary
                                    connection (See figure 7).  This
                                    because user identifications and
                                    requests are done through primary
                                    shared pages.

            *  Specific feature 2:  This table is handled in parallel
                                    with the connection pages (See 3.3.2
                                    (b))

            *  Specific feature 3:  This table is mainly used for
                                    transmitting messages.  (For each
                                    connection it contains the outgoing
                                    link # and remote HOST #, i.e., all
                                    the information required for
                                    transmitting a message.)

        (c)  INPUT LINK table

            This table keeps track of all the incoming (input) links and
            so is closely related to the CONNECT table.

                  [Figure 5 - HOST table - see PDF file]

         [Figure 6 - CONNECT table: Slot structure - see PDF file]

       [Figure 7 - INSERT LINK table: Slot structure - see PDF file]
```

다음과 같은 특징이 있습니다.

```text
   *  Location:  Disc resident.
```

\* 결합: 네트워크 프로세스 가상 공간에 결합됩니다.

```text
            *  Size:  As many slots as incoming links, i.e., as
                      connections

            *  Slot structure:  See figure 7.  Each slot is 1 word
                                length

            *  Access:  Hashing.  The hashed key value is mainly based
                        upon the incoming link # and the remote HOST #.

            *  Specific feature 1:  This table is also used for
                                    momentarily memorizing the
                                    connection number while establishing
                                    the next connection.  See 3.4 the
                                    way it is handled.

            *  Specific feature 2:  This table is primarily used upon
                                    receiving messages.  (For each
                                    incoming link it contains the
                                    corresponding connection #, i.e.,
                                    indirectly the user identification
                                    to which the message should be
                                    passed along)

      3.3.1.2  Buffer pages
```

- 이제 설명할 모든 페이지에는 두 개의 버퍼\(입력 및 출력\)가 포함되어 있습니다. 이러한 버퍼는 메시지를 전달하거나 처리하는 데 사용됩니다.

- 각 버퍼의 크기는 적어도 메시지의 크기와 같아야 합니다\(예: 8095비트\). 우리는 두 버퍼가 모두 한 페이지\(512워드\) 내에 포함되도록 253워드\(8096비트\)의 버퍼 크기를 선택했습니다. 페이지의 나머지 6개 단어는 일반적으로 제어에 사용됩니다.

- 일반적인 버퍼 페이지 구조는 그림 8에 나와 있습니다.

```text
      (a)  I/O communication page

         See figure 9.
```

- 이 I/O 통신 페이지는 Handler와 Network 프로그램 간의 인터페이스로 사용됩니다.

- 이 페이지의 버퍼에서 메시지는 핸들러에 의해 단어 단위로 어셈블링\(입력\)되거나 디어셈블링\(출력\)됩니다. 예를 들어 출력 버퍼에서 네트워크 프로그램에 의해 정렬된 "ready to go" 메시지가 배송됩니다. 핸들러가 한 단어씩 출력합니다.

```text
         Main characteristics:

         *  Location:  Resident in core: Locked page
         *  Coupling:  Coupled to the Network process virtual space
         *  Content: * Input buffer (253 words) for incoming messages
                       Output buffer (253 words) for outgoing messages
                     * Input control zone (6 half words)
                     * Output control zone (6 half words)
         *  Structure:  See figure 9.
         *  Specific feature: * The input buffer is filled by the
                                Handler (read from hardware) and emptied
                                by the Network program
                              * Vice versa for the output buffer

      (b)  Connection shared pages (User-Network shared zone)

         General features:
```

- \* 연결 수만큼 공유 페이지가 있습니다.

```text
         *  These pages shared between the network and the user
            processes constitute a communication zone for (1) passing

            the messages back and forth, and (2) exchanging control
            information, e.g., a request for establishing new
            connections.

         Main characteristics:

         *  Location:  Disc resident
         *  Coupling:  Coupled to both a user process virtual space and
            the
                          network process virtual space.
         *  Content: - Input buffer (253 words) for incoming messages
                      - Output buffer (253 words) for outgoing messages
                      - Input control zone (6 half words)
                      - Output control zone (6 half words)
         *  Structure:  See figure 10.
         *  Specific feature 1: - The input buffer is filled by the
                                  Network and emptied by the user.
                                - Vice versa for the output buffer.
         *  Specific feature 2:  The control zone corresponding to a
                                  primary connection shared page differs
                                  from that of an auxiliary connection.
                                  This because it is via a "primary
                                  connection control zone" that
                                  auxiliary connection establishment
                                  requests are transmitted to the
                                  Network process.

      (c)  Working page

         General feature:
```

- \* 이 페이지에서는 네트워크 및 처리기 프로그램이 서로 다른 메시지에 대해 독립적으로 작동할 수 있으므로 중복이 발생합니다. 예를 들어 핸들러가 하드웨어에 메시지를 전송하는 중일 때 네트워크 프로그램은 재설정 메시지를 포맷\(리더, 표시 등\)하여 발송할 수 있으므로 핸들러가 사용 가능한 즉시 다시 시작할 수 있습니다.

```text
         Main characteristics:

         *  Location:  Disc resident
         *  Coupling:  Coupled to the Network process virtual space
         *  Content:  - Input buffer (253 words) for incoming messages
                      - Output buffer (253 words) for outgoing messages

         Remark:
```

- 수신 중에 사용자 프로그램이 새 메시지를 수락할 준비가 되지 않은 경우가 발생할 수 있습니다. 이 경우 시스템의 정체를 방지하기 위해 네트워크는 들어오는 메시지를 비상 링의 버퍼 중 하나에 일시적으로 저장합니다. \(이 링이 가득 차면 도움말 루틴이 호출됩니다.\)

- 방출 중에 모든 작업은 RFNM과 동기화되므로 이러한 절차를 제공할 필요가 없습니다. \(네트워크 프로그램에서는 이전에 전송한 메시지의 RFNM을 수신한 경우에만 사용자가 다시 전송하도록 허용합니다.\)

```text
             [Figure 8 - Typical buffer page - see PDF file]

       [Figure 9 - I/O Communication page structure - see PDF file]

       [Figure 10 - Connection shared page structure - see PDF file]
```

---
### **3.3.2  Programs**

```text
   3.3.2.1  Handler program

      General features:
```

- 메시지를 전송하거나 수신하기 위해 IMP/HOST 하드웨어 인터페이스를 구동하는 I/O 인터럽트 루틴입니다. 전송 및 수신은 전이중 모드로 수행됩니다.

```text
      Main characteristics:

      *  Location:  Core resident.  The Handler is in the same memory
                    zone as the operating system and can be considered
                    as part of it.

      *  Initiation: By the IMP-HOST hardware interrupt.  This interrupt
                     is triggered either:

                     * during transmission when a message word is
                       completely sent to the IMP

                     * during reception when a message word has been
                       completely received from the IMP

                     * during idle time when the hardware received
                       either a 'start input' or 'start output' order
                       from the Sigma 7 CPU.  Those orders are issued by
                       the Network program for provoking interrupts back

                       (consequently for indirectly initiating the
                       Handler).

      *  Main functions: * Empties the output buffer upon transmitting
                           its content (outgoing message to the IMP.
                           This operation is carried out word by word
                           (32 bits) and makes use of "Write" orders for
                           driving the HOST-IMP hardware.

                         * Fills the input buffer with data received
                           from HOST-IMP hardware (incoming message).
                           This operation is also carried out word by
                           word and makes use of "Read" orders for
                           driving the HOST-IMP hardware.

                         * Wakes up the Network program when any of the
                           previous operations is complete.

   3.3.2.2  Network program

      General features:
```

- 이 프로그램은 사용자에게 연결 열기/닫기 및 메시지 전송/수신 기능을 제공합니다. 하드웨어와의 인터페이스를 돕기 위해 핸들러를 사용합니다.

- GORDO의 관점에서는 이는 일반적인 프로세스이며 그렇게 취급됩니다.

```text
      Main characteristics:

      *  Location:  Disc resident.  More precisely it is on disc when
                    asleep and called in core when awakened by a
                    program.
      *  Initiation:  It is initiated through 'WAKE' service calls
                      issued either by a user process or by the Handler.
      *  Main functions: * Establishes/deletes outgoing connections upon
                           users' requests.  For so doing it sends
                           control messages (see 2.4.2) to remote
                           HOST[s] in order to get links
                           established/released; it then notifies back
                           the users.
                         * Insures the processing of incoming control
                           messages (transmitted over control links),
                           e.g., for contributing to
                           establishments/deletions of connections
                           (those requested by remote HOSTS).

                         * Prepares transmission of outgoing messages.
                           It picks up text messages from shared pages
                           (the messages are stored there by users),
                           formats them (adds leader, marking,
                           checksum..), and passes them along to the
                           Handler for transmission.
                         * Insures delivery of incoming messages.  It is
                           the opposite of the above operation.  The
                           users to which the messages should be
                           delivered are identified through the leaders.

      *  Virtual space configuration:  See figure 11.

      *  Specific feature:  It is integrated as an I/O process, so that
                            it can access privileged instruction (RD/WD
                            for indirectly initiating the Handler).

        [Figure 11 - Network Process Virtual Space - see PDF file]
```

---
## **3.4  Software Procedures**

자세한 소프트웨어 절차는 부록 A에 첨부된 순서도에 나와 있습니다.

그러나 구현을 빠르게 이해하기 위해 몇 가지 일반적인 소프트웨어 절차를 아래에 나열합니다.

---
### **3.4.1  Description of some typical sequences**

사용자가 처리할 수 있는 일부 트랜잭션\(2.4 참조\)을 고려하고 그것이 암시하는 기본 소프트웨어 절차를 지적하십시오. 각 경우에 대해 \(i\) 사용자 프로그램이 수행하는 작업과 \(ii\) 네트워크 프로그램이 수행하는 작업을 설명합니다.

\(a\) 기본 링크 열기\(2.4.2 참조\)

- \(i\) 사용자 프로그램이 수행하는 작업\[1\]:

```text
              *  it stores in the Network mail box directory the name of
                 a file, e.g., DATA;
              *  it couples the first page of this file to its virtual
                 space;
              *  it stores information in this page (its job/process #,
                 the remote HOST #, e.g., (i));
              *  it wakes up the Network process;
              *  it goes to sleep.
```

- \(ii\) 네트워크 프로그램의 기능:

```text
              *  it explores the Network mail box directory and accesses
                 the file DATA;
              *  it couples the first page of this file to its virtual
                 space (Shared Zone, see 3.3.1.2).  Suppose this page to
                 be kth in the shared zone; k is the internal connection
                 #;
              *  it explores the ith slot of the new HOST table (See
                 3.3.1.1 (a)) and selects the first bit = 0, e.g., the
                 (alpha)th bit; alpha corresponds to the outgoing link
                 #;
              *  it stores information (job/process #, remote HOST #
                 (i), outgoing link # (alpha)) in the kth slot of the
                 CONNECT table (See 3.3.1.2).
              *  it momentarily stores the connection # (k) in the INPUT
                 LINK table.  This is carried out upon creating an entry
                 in this table (Hashing the key value:  "outgoing link #
                 (alpha) + remote HOST # (i) + outgoing flag".);
              *  it prepares the message text ENQ PRIM 0 0 a and formats
                 a complete message in adding leader, marking, checksum,
                 etc.;
              *  it checks the Handler state (bit in I/O locked page).
                 If the Handler is free, it stores the 'ready to go'
                 control message in the output buffer of the I/O locked
                 page, initiates the Handler, and goes to sleep.  Else
                 it goes to sleep.
```

잠시 후 핸들러는 완전한 메시지를 수신했기 때문에 네트워크 프로세스를 깨웁니다. 이 메시지는 연결 설정을 승인하기 위해 원격 HOST에서 보낸 제어 메시지라고 가정합니다. 메시지 텍스트는 다음과 같아야 합니다.

```text
            ACK ENQ PRIM 0 0 alpha 0 0 beta
```

여기서 베타는 수신 링크 #입니다. \(2.4.2 참조\)

이제 위의 제어 메시지를 수신할 때 네트워크 프로그램이 수행하는 작업을 살펴보겠습니다.

```text
              *  it retrieves the connection # previously stored in the
                 INPUT LINK table upon re-hashing the same key value
                 (See above).  Also it deletes this entry;
              *  it creates an entry in the INPUT LINK table for the
                 incoming link.  For so doing it hashes the key value:
                 "incoming link # (beta]) + remote HOST # (i) +
                 "incoming flag".  In this entry it stores the HOST #
                 (i), the incoming link # (beta), and connection # (k);

              *  it updates the kth slot of the CONNECT table in storing
                 the incoming link # (beta);
              *  it turns on the 'net-user' bit in the kth shared page
                 (page corresponding to the primary connection that has
                 just been opened) and wakes up the user process;
              *  it goes to sleep.
```

\(b\) 기본 링크를 통해 메시지 전송

- \(i\) 사용자 프로그램이 하는 일\[1\].

```text
              *  it stores the message text in the output buffer of the
                 primary connection shared page (see 3.3.1.2);
              *  it turns on the 'user-net' bit of this page and wakes
                 up the Network process;
              *  it goes to sleep.
```

- \(ii\) 네트워크 프로그램의 기능:

```text
              *  it looks for user request, i.e., it explores in
                 sequence the connection shared pages and selects the
                 one that has its 'user-net' bit turned on.  Suppose k
                 be the selected page # on the shared list, K is the
                 connection #;
              *  it determines the request type in testing the 'request
                 bits' of the shared page k.  It finds out that it is a
                 request for transmitting a message.
              *  it takes the message text from the output buffer of the
                 shared page k, formats it into a complete message and
                 transmits to the Handler in a very similar way as above
                 (See Open a primary link).
              *  it goes to sleep.

      [1]  Remark:  In a first phase the user will directly write the
                    network functions in his program.  Later on
                    subroutines will be put at user's disposal.  These
                    subroutines will be very close to those described in
                    2.4.
```

---
# **APPENDIX A**

```text
   Flowcharts
```

- \[흐름도는 PDF 파일 참조\]

```text
       [ This RFC was put into machine readable form for entry ]
          [ into the online RFC archives by Bob German 8/99 ]
```
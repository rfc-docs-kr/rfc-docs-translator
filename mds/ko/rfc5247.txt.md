

```text
Network Working Group                                           B. Aboba
Request for Comments: 5247                                      D. Simon
Updates: 3748                                      Microsoft Corporation
Category: Standards Track                                      P. Eronen
                                                                   Nokia
                                                             August 2008

   Extensible Authentication Protocol (EAP) Key Management Framework
```

---
# **Status of This Memo**

이 문서는 인터넷 커뮤니티를 위한 인터넷 표준 추적 프로토콜을 지정하고 개선을 위한 토론 및 제안을 요청합니다. 이 프로토콜의 표준화 상태 및 상태에 대해서는 "Internet Official Protocol Standards"\(STD 1\) 최신판을 참조하십시오. 이 메모의 배포는 무제한입니다.

---
# **Abstract**

RFC 3748에 정의된 EAP\(확장 가능 인증 프로토콜\)는 확장 가능한 네트워크 액세스 인증을 가능하게 합니다. 이 문서는 EAP 키 계층 구조를 지정하고 "메서드"라고 알려진 EAP 인증 알고리즘에 의해 생성된 키 자료 및 매개변수의 전송 및 사용을 위한 프레임워크를 제공합니다. 또한 RFC 4962에 설명된 주요 관리 지침이 충족될 수 있는 조건을 설명하는 자세한 시스템 수준 보안 분석을 제공합니다.

---
# **Table of Contents**

```text
   1. Introduction ....................................................3
      1.1. Requirements Language ......................................3
      1.2. Terminology ................................................3
      1.3. Overview ...................................................7
      1.4. EAP Key Hierarchy .........................................10
      1.5. Security Goals ............................................15
      1.6. EAP Invariants ............................................16
   2. Lower-Layer Operation ..........................................20
      2.1. Transient Session Keys ....................................20
      2.2. Authenticator and Peer Architecture .......................22
      2.3. Authenticator Identification ..............................23
      2.4. Peer Identification .......................................27
      2.5. Server Identification .....................................29
   3. Security Association Management ................................31
      3.1. Secure Association Protocol ...............................32
      3.2. Key Scope .................................................35
      3.3. Parent-Child Relationships ................................35
      3.4. Local Key Lifetimes .......................................37
      3.5. Exported and Calculated Key Lifetimes .....................37
      3.6. Key Cache Synchronization .................................40
      3.7. Key Strength ..............................................40
      3.8. Key Wrap ..................................................41
   4. Handoff Vulnerabilities ........................................41
      4.1. EAP Pre-Authentication ....................................43
      4.2. Proactive Key Distribution ................................44
      4.3. AAA Bypass ................................................46
   5. Security Considerations ........................................50
      5.1. Peer and Authenticator Compromise .........................51
      5.2. Cryptographic Negotiation .................................53
      5.3. Confidentiality and Authentication ........................54
      5.4. Key Binding ...............................................59
      5.5. Authorization .............................................60
      5.6. Replay Protection .........................................63
      5.7. Key Freshness .............................................64
      5.8. Key Scope Limitation ......................................66
      5.9. Key Naming ................................................66
      5.10. Denial-of-Service Attacks ................................67
   6. References .....................................................68
      6.1. Normative References ......................................68
      6.2. Informative References ....................................68
   Acknowledgments ...................................................74
   Appendix A - Exported Parameters in Existing Methods ..............75
```

---
## **1.  Introduction**

\[RFC3748\]에 정의된 확장 가능 인증 프로토콜\(EAP\)은 인터넷 프로토콜\(IP\) 프로토콜을 사용할 수 없는 상황에서 네트워크 액세스에 대한 확장 가능한 인증을 활성화하도록 설계되었습니다. 원래 PPP\(Point-to-Point Protocol\)\[RFC1661\]와 함께 사용하기 위해 개발되었지만 이후 IEEE 802 유선 네트워크\[IEEE-802.1X\], Internet Key Exchange Protocol 버전 ​​2\(IKEv2\)\[RFC4306\]에도 적용되었습니다. \[IEEE-802.11\], \[IEEE-802.16e\] 등의 무선 네트워크.

EAP는 EAP 피어와 서버 간에 사용되는 양방향 프로토콜입니다. EAP 내에서 키 자료는 "메서드"라고 알려진 EAP 인증 알고리즘에 의해 생성됩니다. 이 키 자료의 일부는 EAP 방법 자체에서 사용될 수 있으며 이 자료의 일부는 내보낼 수 있습니다. 키 자료 내보내기 외에도 EAP 방법은 인증된 피어 및 서버 ID와 고유한 EAP 대화 식별자와 같은 관련 매개 변수를 내보낼 수 있으며 "채널 바인딩 매개 변수" 또는 간단히 ""라고 알려진 하위 계층 매개 변수를 가져오고 내보낼 수 있습니다. 채널 바인딩".

이 문서는 EAP 키 계층 구조를 지정하고 EAP 방법으로 생성된 키 자료 및 매개 변수의 전송 및 사용을 위한 프레임워크를 제공합니다. 또한 "AAA\(인증, 권한 부여 및 회계\) 키 관리에 대한 지침"\[RFC4962\]에 설명된 요구 사항을 충족할 수 있는 조건을 설명하는 자세한 보안 분석을 제공합니다.

---
### **1.1.  Requirements Language**

이 문서에서 키워드 "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY" 및 "OPTIONAL"은 다음과 같습니다. \[RFC2119\]에 설명된 대로 해석됩니다.\(MUST NOT\)

---
### **1.2.  Terminology**

"암호 바인딩", "암호 분리", "키 강도" 및 "상호 인증"이라는 용어는 \[RFC3748\]에 정의되어 있으며 이 문서에서도 동일한 의미로 사용되며 다음 용어도 자주 사용됩니다.

4방향 핸드셰이크

- \[IEEE-802.11\]에 정의된 AKMP\(Pairwise Authentication and Key Management Protocol\)는 두 당사자가 쌍방향 마스터 키의 상호 소유를 확인하고 그룹 키를 배포하는 것을 의미합니다.

AAA 인증, 권한 부여 및 회계

- EAP를 지원하는 AAA 프로토콜에는 "EAP를 위한 RADIUS 지원"\[RFC3579\] 및 "Diameter EAP 애플리케이션"\[RFC4072\]이 포함됩니다. 이 문서에서는 "AAA 서버"와 "백엔드 인증 서버"라는 용어가 같은 의미로 사용됩니다.

AAA 키

- AAA 키라는 용어는 MSK\(마스터 세션 키\)와 동의어입니다. 여러 키가 AAA로 전송될 수 있으므로 이 용어는 혼동될 수 있으므로 이 문서에서는 사용되지 않습니다.

인증자

- EAP 인증을 시작하는 엔터티입니다.

백엔드 인증 서버

- 백엔드 인증 서버는 인증자에게 인증 서비스를 제공하는 엔터티입니다. 사용되는 경우 이 서버는 일반적으로 인증자에 대해 EAP 방법을 실행합니다. 이 용어는 \[IEEE-802.1X\]에서도 사용된다.

채널 바인딩

- 인증자가 전송한 매개변수의 하위 집합\(예: 인증자 식별자 및 속성\)이 EAP 피어와 서버에서 합의되도록 보장하는 보안 메커니즘입니다. 인증자가 매개변수를 광고한 경우 매개변수는 하위 계층을 통해 EAP 피어와 인증자에 의해 안전하게 합의될 것으로 예상됩니다.

파생 키잉 자료

- TSK\(임시 세션 키\)와 같은 EAP 키 자료에서 파생된 키.

EAP 키 관련 자료

- EAP 방식으로 파생된 키 여기에는 내보낸 키 자료\(MSK, 확장 MSK\(EMSK\), 초기화 벡터\(IV\)\)는 물론 TEK\(임시 EAP 키\)와 같은 로컬 키 자료도 포함됩니다.

EAP 사전 인증

- 인증자가 관리하는 액세스 네트워크에 피어가 도착하기 전에 인증자에 EAP 키 자료를 사전 설정하기 위해 EAP를 사용합니다.

EAP 재인증

- EAP 피어와 EAP 피어가 만료되지 않은 유효한 EAP 키 자료를 공유하는 서버 간의 EAP 인증.

EAP 서버

- 피어와의 EAP 인증 방법을 종료하는 개체입니다. 백엔드 인증 서버가 사용되지 않는 경우 EAP 서버는 인증자의 일부입니다. 인증자가 통과 모드로 작동하는 경우 EAP 서버는 백엔드 인증 서버에 위치합니다.

내보낸 키잉 자료

- EAP 마스터 세션 키\(MSK\), 확장 마스터 세션 키\(EMSK\) 및 초기화 벡터\(IV\).

확장 마스터 세션 키\(EMSK\)

- EAP 방법으로 내보낸 피어와 서버 간에 파생된 추가 키 자료입니다. EMSK의 길이는 최소 64옥텟이며 제3자와 절대 공유되지 않습니다. EMSK는 적어도 MSK 크기만큼 길어야 합니다.\(MUST\)

초기화 벡터\(IV\)

- 피어와 EAP 서버 간에 파생되는 초기화 벡터 필드에 사용하기에 적합한 최소 64옥텟의 수량입니다. IV는 EAP-TLS\(전송 계층 보안\) \[RFC5216\]과 같은 방법에서 알려진 값이므로 비밀로 유지되어야 하는 수량의 계산에 단독으로 사용할 수 없습니다. 결과적으로 해당 사용은 더 이상 사용되지 않으며 EAP 방법으로 생성하는 것은 선택 사항입니다. 그러나 생성되면 예측할 수 없어야 합니다.\(MAY, MUST\)

키잉 재료

- 달리 한정되지 않는 한 "키 자료"라는 용어는 EAP 키 자료와 파생 키 자료를 의미합니다.

주요 범위

- 키를 사용할 수 있는 당사자입니다.

키 랩

- 하나의 대칭 암호화 키를 다른 대칭 암호화 키로 암호화합니다. 암호화에 사용되는 알고리즘을 키 랩 알고리즘 또는 키 암호화 알고리즘이라고 합니다. 암호화 프로세스에 사용되는 키를 KEK\(키 암호화 키\)라고 합니다.

장기 자격증

- EAP 방법은 피어와 서버 간의 인증을 활성화하기 위해 장기 비밀을 자주 사용합니다. 사전 공유 키 인증 기반 방법의 경우 장기 자격 증명은 사전 공유 키입니다. 공개 키 기반 방법의 경우 장기 자격 증명은 해당 개인 키입니다.

하위 레이어

- 하위 계층은 피어와 인증자 간에 EAP 프레임을 전달하는 역할을 담당합니다.

하위 계층 ID

- 하위 계층 내에서 EAP 피어 및 인증자를 식별하는 데 사용되는 이름입니다.

마스터 세션 키\(MSK\)

- EAP 피어와 서버 간에 파생되고 EAP 방법으로 내보내지는 키 자료입니다. MSK의 길이는 최소 64옥텟입니다.

네트워크 액세스 서버\(NAS\)

- 사용자에게 네트워크에 대한 액세스 서비스를 제공하는 장치입니다.

PMK\(쌍별 마스터 키\)

- 하위 계층은 하위 계층 종속 방식으로 MSK를 사용합니다. 예를 들어, IEEE 802.11 \[IEEE-802.11\]에서 MSK의 옥텟 0-31은 PMK\(Pairwise Master Key\)로 알려져 있습니다. TKIP\(임시 키 무결성 프로토콜\) 및 AES CCMP\(Advanced Encryption Standard Counter Mode with CBC-MAC Protocol\) 암호화 제품군은 PMK에서만 TSK\(Transient Session Key\)를 파생하는 반면, WEP\(Wired Equivalent Privacy\) 암호화 제품군은 다음에 설명되어 있습니다. "IEEE 802.1X RADIUS 사용 지침" \[RFC3580\]은 MSK의 두 부분 모두에서 TSK를 파생합니다. \[IEEE-802.16e\]에서는 MSK가 PMK의 경우 20옥텟, PMK2의 경우 20옥텟으로 잘립니다.

또래

- 인증자에게 응답하는 엔터티입니다. \[IEEE-802.1X\]에서는 이 엔터티를 신청자라고 합니다.

보안 협회

- 정보를 보호하는 데 사용되는 일련의 정책 및 암호화 상태입니다. 보안 연관 요소에는 암호화 키, 협상된 암호 제품군 및 기타 매개변수, 카운터, 시퀀스 공간, 인증 속성 등이 포함됩니다.

보안 연결 프로토콜

- EAP 교환에서 파생된 보안 연결을 관리하기 위해 EAP 피어와 인증자 간에 발생하는 교환입니다. 프로토콜은 대칭 키와 키 사용을 위한 컨텍스트를 포함하는 유니캐스트 및 \(선택적으로\) 멀티캐스트 보안 연결을 설정합니다. 보안 연관 프로토콜의 예로는 \[IEEE-802.11\]에 정의된 4방향 핸드셰이크가 있습니다.

세션 ID

- EAP 세션 ID는 EAP 피어\(피어 ID로 식별됨\)와 서버\(서버 ID로 식별됨\) 간의 EAP 인증 교환을 고유하게 식별합니다. 자세한 내용은 섹션 1.4를 참조하세요.

TEK\(임시 EAP 키\)

- EAP 인증 교환 중에 EAP 피어와 서버 간에 보호된 채널을 설정하는 데 사용되는 세션 키입니다. TEK는 EAP 대화를 보호하는 데 사용하기 위해 EAP 피어와 서버 간에 협상된 암호 제품군과 함께 사용하기에 적합합니다. TEK는 EAP 방법을 통해 로컬로 저장되며 내보내지지 않습니다. EAP 인증 중에 EAP 피어와 서버 간에 보호된 채널을 설정하는 데 사용되는 암호 모음은 이후에 EAP 피어와 인증자 간에 전송되는 데이터를 보호하는 데 사용되는 암호 모음과 관련이 없습니다.

임시 세션 키\(TSK\)

- EAP 피어와 인증자 간에 협상된 암호화 제품군을 사용하여 EAP 인증이 성공적으로 완료된 후 교환된 데이터를 보호하는 데 사용되는 키입니다.

---
### **1.3.  Overview**

EAP 키 파생이 지원되는 경우 대화는 일반적으로 다음 세 단계로 진행됩니다.

```text
      Phase 0: Discovery
      Phase 1: Authentication
               1a: EAP authentication
               1b: AAA Key Transport (optional)
      Phase 2: Secure Association Protocol
               2a: Unicast Secure Association
               2b: Multicast Secure Association (optional)
```

이러한 단계 중 0, 1b, 2단계는 EAP 외부에서 처리됩니다. 0단계와 2단계는 하위 계층 프로토콜에 의해 처리되고, 1b단계는 일반적으로 AAA 프로토콜에 의해 처리됩니다.

검색 단계\(0단계\)에서 피어는 인증자를 찾고 해당 기능을 검색합니다. 피어는 특정 네트워크에 대한 액세스를 제공하는 인증자를 찾거나 보안 연결을 설정하려는 브리지 뒤에 있는 인증자를 찾을 수 있습니다. 검색은 EAP가 실행되는 하위 계층에 따라 수동 또는 자동으로 발생할 수 있습니다.

피어와 인증자가 서로를 발견하면 인증 단계\(1단계\)가 시작될 수 있습니다. 이 단계가 발생하는 경우 항상 EAP 인증\(1a단계\)이 포함됩니다. 선택한 EAP 방법이 키 파생을 지원하는 경우 1a단계에서 EAP 키 자료는 피어와 EAP 서버 모두에서 파생됩니다.

백엔드 인증 서버를 포함하는 배포에서는 키 자료를 백엔드 인증 서버에서 인증자로 전송하기 위해 추가 단계\(1b단계\)가 필요합니다. 백엔드 인증 서버가 있는 모드 독립 원칙\(섹션 1.6.1 참조\)을 준수하기 위해 하위 계층에 필요한 모든 키 자료는 EAP 서버에서 인증자로 전송됩니다. 기존 TSK 파생 및 전송 기술은 MSK에만 의존하기 때문에 기존 구현에서는 이것이 AAA 키 전송 단계 1b에서 복제된 유일한 키 자료입니다.

피어 및 EAP 서버에 의한 EAP 인증 및 키 파생이 성공적으로 완료되었다고 해서 해당 피어가 EAP 서버와 연결된 네트워크에 합류하기로 약속했다는 의미는 아닙니다. 오히려 이러한 약속은 보안 연결 프로토콜\(2단계\)의 일부로 EAP 피어와 인증자 간의 보안 연결 생성을 통해 암시됩니다. 피어와 인증자 간의 유니캐스트\(2a단계\) 및 멀티캐스트\(2b단계\) 보안 연결의 생성 및 삭제를 관리하기 위해 피어와 인증자 간에 보안 연결 프로토콜 교환\(2단계\)이 발생합니다. 당사자 간의 대화는 그림 1에 나와 있습니다.

```text
   EAP peer                   Authenticator               Auth. Server
   --------                   -------------               ------------
    |<----------------------------->|                               |
    |     Discovery (phase 0)       |                               |
    |<----------------------------->|<----------------------------->|
    |   EAP auth (phase 1a)         |  AAA pass-through (optional)  |
    |                               |                               |
    |                               |<----------------------------->|
    |                               |       AAA Key transport       |
    |                               |      (optional; phase 1b)     |
    |<----------------------------->|                               |
    |  Unicast Secure association   |                               |
    |          (phase 2a)           |                               |
    |                               |                               |
    |<----------------------------->|                               |
    | Multicast Secure association  |                               |
    |     (optional; phase 2b)      |                               |
    |                               |                               |

                  Figure 1: Conversation Overview
```

---
#### **1.3.1.  Examples**

기존 EAP 하위 계층은 다양한 방식으로 0단계, 2a단계, 2b단계를 구현합니다.

PPP

- \[RFC1661\]에 정의된 PPP\(Point-to-Point Protocol\)는 검색을 지원하지 않으며 보안 연결 프로토콜도 포함하지 않습니다.

PPPoE

- \[RFC2516\]에 정의된 PPPoE\(PPP over Ethernet\)에는 검색 단계\(단계 0\)에 대한 지원이 포함됩니다. 이 단계에서 EAP 피어는 요청하는 서비스를 나타내는 PPPoE PADI\(Active Discovery Initiation\) 패킷을 브로드캐스트 주소로 보냅니다. 액세스 집선 장치는 이름, 서비스 이름 및 집선 장치가 제공하는 서비스 표시가 포함된 PADO\(PPPoE Active Discovery Offer\) 패킷으로 응답합니다. 검색 단계는 보안되지 않습니다. PPP와 마찬가지로 PPPoE에는 보안 연결 프로토콜이 포함되어 있지 않습니다.

IKEv2

- \[RFC4306\]에 정의된 IKEv2\(Internet Key Exchange v2\)는 EAP에 대한 지원을 포함하고 유니캐스트 보안 연결 설정\(2a단계\)을 처리합니다. 그러나 멀티캐스트 보안 연결\(2b단계\) 설정에는 일반적으로 EAP가 포함되지 않으며 GDOI\(Group Domain of Interpretation\) \[RFC3547\], GSAKMP\(Group Secure Association Key Management Protocol\)와 같은 그룹 키 관리 프로토콜에 의해 처리되어야 합니다. \[RFC4535\], 멀티미디어 인터넷 키잉\(MIKEY\) \[RFC3830\] 또는 그룹 키 분배 프로토콜\(GKDP\) \[GKDP\]. IPsec 보안 게이트웨이 검색을 위해 여러 가지 메커니즘이 제안되었습니다. \[RFC2230\]에서는 IPsec 게이트웨이 검색을 위한 KX\(Key eXchange\) RR\(리소스 레코드\) 사용에 대해 설명합니다. KX RR은 많은 DNS\(도메인 이름 서비스\) 서버 구현에서 지원되지만 아직 널리 배포되지는 않았습니다. 또는 DNS SRV RR \[RFC2782\]을 이 목적으로 사용할 수 있습니다. 게이트웨이 위치에 DNS가 사용되는 경우 DNS 보안\(DNSSEC\)\(\[RFC4033\], \[RFC4035\]\), TSIG \[RFC2845\] 및 단순 보안 동적 업데이트\[RFC3007\]와 같은 DNS 보안 메커니즘을 사용할 수 있습니다.

IEEE 802.11

- \[IEEE-802.11\]에 정의된 IEEE 802.11은 비콘 및 프로브 요청/응답 메커니즘을 통해 검색을 처리합니다. IEEE 802.11 AP\(액세스 포인트\)는 비콘 프레임을 사용하여 SSID\(서비스 세트 식별자\)와 기능을 주기적으로 발표합니다. 역은 할 수 있습니다

- 프로브 요청을 보내 AP를 쿼리합니다. 비콘이나 프로브 요청/응답 프레임은 모두 보호되지 않습니다. \[IEEE-802.11\]에 정의된 4방향 핸드셰이크는 유니캐스트\(2a단계\) 및 멀티캐스트/브로드캐스트\(2b단계\) 보안 연결의 파생을 가능하게 합니다. 그룹 키 교환은 AP에서 스테이션으로 그룹 키를 전송하므로 P2P 통신을 지원하려면 두 개의 4방향 핸드셰이크가 필요할 수 있습니다. EAP-TLS와 함께 사용되는 경우 IEEE 802.11 4방향 핸드셰이크의 보안 증명은 \[He\]에서 제공됩니다.

IEEE 802.1X

- \[IEEE-802.1X\]에 정의된 IEEE 802.1X-2004는 검색\(단계 0\)을 지원하지 않으며 유니캐스트 또는 멀티캐스트 보안 연결 파생도 제공하지 않습니다.

---
### **1.4.  EAP Key Hierarchy**

그림 2에 표시된 것처럼 EAP 방법 키 파생에는 선택한 EAP 방법에서 사용하는 장기 자격 증명이 루트에 있습니다. 사전 공유 키를 기반으로 인증하는 경우 당사자는 사용할 EAP 방법과 사전 공유 키를 저장합니다. EAP 서버는 피어의 신원과 추가 정보도 저장합니다. 이 정보는 일반적으로 서비스에 대한 액세스 권한을 부여할지 여부를 결정하기 위해 EAP 방법 외부에서 사용됩니다. 피어는 어떤 서비스에 사용할 비밀을 선택하는 데 필요한 정보를 저장합니다.

인증이 인증서에 포함된 공개 키에 해당하는 개인 키 소유 증명을 기반으로 하는 경우 당사자는 사용할 EAP 방법과 인증서 검증에 사용되는 트러스트 앵커를 저장합니다. EAP 서버는 피어의 신원도 저장하고, 피어는 어떤 서비스에 사용할 인증서를 선택하는 데 필요한 정보를 저장합니다. 피어와 서버 사이에 설정된 장기 자격 증명을 기반으로 이 방법은 두 가지 유형의 EAP 키 자료를 파생합니다.

- \(a\) 임시 EAP 키\(TEK\)와 같이 EAP 방법으로 로컬로 계산되지만 내보내지지 않는 키 관련 자료.

- \(b\) EAP 방법으로 내보낸 키 자료: 마스터 세션 키\(MSK\), 확장 마스터 세션 키\(EMSK\), 초기화 벡터\(IV\).

\[RFC3748\] 섹션 7.10에 명시된 대로:

- 이후 협상된 암호 모음에 사용할 키 자료를 제공하려면 키 파생을 지원하는 EAP 방법은 최소 64옥텟의 MSK\(마스터 세션 키\)와 최소 64옥텟의 EMSK\(확장 마스터 세션 키\)를 내보내야 합니다. .\(MUST\)

EAP 방법은 IV를 내보낼 수도 있습니다. 그러나 IV의 사용은 더 이상 사용되지 않습니다. EMSK는 EAP 서버 또는 피어 외부의 엔터티에 제공되어서는 안 되며, 반전과 같은 일부 암호화 가정을 위반하지 않고 EMSK를 계산할 수 있는 EAP 서버 또는 피어 외부의 엔터티에 수량을 전달하는 것도 허용되지 않습니다. 단방향 기능.\(MAY, MUST NOT\)

키 파생 및 상호 인증을 지원하는 EAP 방법은 Session-Id로 알려진 방법별 EAP 대화 식별자와 하나 이상의 방법별 피어 식별자\(Peer-Id\)를 내보내야 하며 하나 이상의 방법을 내보낼 수 있습니다. -특정 서버 식별자\(서버 ID\). EAP 방법은 채널 바인딩 매개변수 가져오기 및 내보내기도 지원할 수 있습니다. 이 문서 발행 이후 개발된 EAP 방법 사양은 Peer-Id, Server-Id 및 Session-Id를 정의해야 합니다. 제공된 경우 Peer-Id 및 Server-Id는 EAP 키 자료 생성과 관련된 엔터티를 식별합니다. 기존 EAP 방식의 경우 Peer-Id, Server-Id, Session-Id는 부록 A에 정의되어 있습니다.\(SHOULD, MAY, MUST\)

```text
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+         ---+
|                                                         |            ^
|                EAP Method                               |            |
|                                                         |            |
| +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+   +-+-+-+-+-+-+-+   |            |
| |                                 |   |             |   |            |
| |       EAP Method Key            |<->| Long-Term   |   |            |
| |         Derivation              |   | Credential  |   |            |
| |                                 |   |             |   |            |
| |                                 |   +-+-+-+-+-+-+-+   |  Local to  |
| |                                 |                     |       EAP  |
| +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+                     |     Method |
|   |             |               |                       |            |
|   |             |               |                       |            |
|   |             |               |                       |            |
|   |             |               |                       |            |
|   |         +-+-+-+-+-+-+ +-+-+-+-+-+-+ +-+-+-+-+-+-+-+ |            |
|   |         | TEK       | |MSK, EMSK  | |IV           | |            |
|   |         |Derivation | |Derivation | |Derivation   | |            |
|   |         |           | |           | |(Deprecated) | |            |
|   |         +-+-+-+-+-+-+ +-+-+-+-+-+-+ +-+-+-+-+-+-+-+ |            |
|   |               ^             |               |       |            |
|   |               |             |               |       |            V
+-+-|-+-+-+-+-+-+-+-|-+-+-+-+-+-+-|-+-+-+-+-+-+-+-|-+-+-+-+         ---+
    |               |             |               |                    ^
    |               |             |               |           Exported |
    | Peer-Id(s),   | channel     | MSK (64+B)    | IV (64B)      by   |
    | Server-Id(s), | bindings    | EMSK (64+B)   | (Optional)    EAP  |
    | Session-Id    | & Result    |               |             Method |
    V               V             V               V                    V

     Figure 2:  EAP Method Parameter Import/Export

   Peer-Id
```

- 키를 생성하는 EAP 방법이 하나 이상의 방법별 피어 ID를 인증하는 경우 해당 ID는 해당 방법에 의해 피어 ID로 내보내집니다. EAP 방법으로 둘 이상의 Peer-Id를 내보낼 수 있습니다. 모든 EAP 방법이 방법별 피어 ID를 제공하는 것은 아닙니다. 이것이 정의되지 않은 경우 Peer-Id는 null 문자열입니다. 키 생성을 지원하지 않는 EAP 방법에서 Peer-Id는 null 문자열이어야 합니다. 키를 파생하는 EAP 방법이 Peer-Id를 제공하지 않는 경우 EAP 서버는 키 자료를 파생한 EAP 피어의 ID를 인증하지 않습니다.\(MUST\)

```text
   Server-Id
```

- 키를 생성하는 EAP 방법이 하나 이상의 방법별 서버 ID를 인증하는 경우 해당 ID는 해당 방법에 의해 서버 ID로 내보내집니다. EAP 방법으로 둘 이상의 서버 ID를 내보낼 수 있습니다. 모든 EAP 방법이 방법별 서버 ID를 제공하는 것은 아닙니다. 정의되지 않은 경우 Server-Id는 null 문자열입니다. EAP 방법이 키 입력 자료를 생성하지 않는 경우 Server-Id는 반드시 null 문자열이어야 합니다. 키를 파생하는 EAP 방법이 서버 ID를 제공하지 않는 경우 EAP 피어는 EAP 키 자료를 파생한 EAP 서버의 ID를 인증하지 않습니다.\(MUST\)

```text
   Session-Id
```

- Session-Id는 EAP 피어\(Peer-Id로 식별됨\)와 서버\(Server-Id로 식별됨\) 간의 EAP 세션을 고유하게 식별합니다. 확장되지 않은 EAP 유형 코드가 사용되는 경우\(EAP 유형 코드는 254가 아님\) EAP 세션 ID는 단일 옥텟 EAP 유형 코드와 방법에서 얻은 시간적으로 고유한 식별자\(Method-Id라고 함\)를 연결한 것입니다. \):

```text
      Session-Id = Type-Code || Method-Id
```

- 확장된 EAP 유형 코드가 사용되는 경우 EAP Session-Id는 \[RFC3748\]에 정의된 확장 유형 코드\(유형, Vendor-Id\(네트워크 바이트 순서\) 및 Vendor-Type 필드\(네트워크 바이트 순서\) 포함\)로 구성됩니다. 섹션 5.7\), 메서드\(Method-Id\)에서 얻은 시간적으로 고유한 식별자와 연결됩니다.

```text
      Session-Id = 0xFE || Vendor-Id || Vendor-Type || Method-Id
```

- Method-Id는 일반적으로 EAP 메소드 교환 내에서 사용되는 nonce 또는 카운터로 구성됩니다. EAP Session-Id에 유형 코드 또는 확장 유형 코드를 포함하면 각 EAP 방법에 고유한 Session-Id 공간이 있음이 보장됩니다. EAP 세션은 특정 인증자 또는 피어 및 인증자의 특정 포트에 바인딩되지 않으므로 인증자 포트 또는 ID는 Session-Id에 포함되지 않습니다.

```text
   Channel Binding
```

- 채널 바인딩은 EAP 피어와 서버 간의 일관성을 위해 하위 계층 매개변수를 확인하는 프로세스입니다. 미디어 종속성을 방지하기 위해 채널 바인딩 매개변수를 전송하는 EAP 방법은 이 데이터를 불투명 옥텟으로 처리해야 합니다. 자세한 내용은 섹션 5.3.3을 참조하세요.\(MUST\)

---
#### **1.4.1.  Key Naming**

EAP 키 관리 프레임워크 내에서 생성된 각 키에는 이름\(고유 식별자\)과 범위\(키를 사용할 수 있는 당사자\)가 있습니다. 내보낸 키 자료 및 TEK의 범위는 사용 가능한 경우 인증된 방법별 피어 ID\(피어 ID\) 및 인증된 서버 ID\(서버 ID\)에 의해 정의됩니다.

MSK 및 EMSK 이름

- MSK 및 EMSK는 EAP 피어 및 EAP 서버에 의해 내보내지며 EAP 세션 ID와 참조되는 EAP 키 자료의 바이너리 또는 텍스트 표시를 사용하여 이름을 지정해야 합니다.\(MUST\)

PMK 이름

- 이 문서에서는 PMK\(Pairwise Master Key\)에 대한 명명 체계를 지정하지 않습니다. PMK는 파생된 키의 이름으로만 식별됩니다.

- 참고: IEEE 802.11은 보안 연결 프로토콜에서 참조할 수 있도록 PMK의 이름을 지정합니다. PMK 이름\(PMKID라고도 함\)은 PMK 자체의 해시 및 일부 기타 매개변수를 기반으로 합니다\(\[IEEE-802.11\] 섹션 8.5.1.2 참조\).

TEK 이름

- TEK\(임시 EAP 키\)의 이름이 지정될 수 있습니다. 해당 이름은 EAP 방법 사양에 지정되어 있습니다.\(MAY\)

TSK 이름

- 임시 세션 키\(TSK\)는 일반적으로 이름이 지정됩니다. 주어진 패킷을 처리하기 위해 올바른 TSK 세트를 식별할 수 있도록 해당 이름은 하위 계층에 지정됩니다.

---
### **1.5.  Security Goals**

EAP 대화의 목표는 해당 당사자에게만 알려진 EAP 피어와 인증자 간의 새로운 세션 키를 파생시키고, EAP 피어와 인증자 모두가 서로 또는 다른 사람에 의해 역할을 수행할 권한이 있음을 입증하는 것입니다. 신뢰할 수 있는 제3자\(백엔드 인증 서버\)

키 파생을 지원하는 EAP 방법 교환\(1a단계\)이 완료되면 EAP 피어\(Peer-Id로 식별됨\)와 EAP 서버\(식별됨\)에만 알려진 EAP 키 자료\(MSK, EMSK, TEK\)가 파생됩니다. 서버 ID별\). EAP 피어와 EAP 서버 모두 이 키 입력 자료가 최신임을 알고 있습니다. Peer-Id와 Server-Id는 섹션 1.4, 2.4, 2.5와 부록 A에서 논의됩니다. 주요 최신성은 섹션 3.4, 3.5, 5.7에서 논의됩니다.

AAA 교환\(1b단계\)이 완료되면 다른 당사자에게 공개되지 않고 키 자료가 EAP 서버\(서버 ID로 식별됨\)에서 EAP 인증자\(NAS 식별자로 식별됨\)로 전송됩니다. EAP 서버와 EAP 인증자 모두 이 키 입력 자료가 최신임을 알고 있습니다. 공개 문제는 섹션 3.8 및 5.3에서 논의됩니다. AAA 프로토콜의 보안 속성은 섹션 5.1 - 5.9에서 논의됩니다.

백엔드 인증 서버는 피어와 함께 설정된 인증자에게만 키 자료를 전송하도록 신뢰되며 해당 키 자료를 다른 당사자에게는 전송하지 않습니다. 많은 시스템에서 EAP 피어 및 EAP 서버가 설정한 EAP 키 자료는 공개적으로 사용 가능한 데이터와 결합되어 다른 키를 파생합니다. 백엔드 인증 서버는 필요한 키 자료에 액세스할 수 있더라도 동일한 키를 파생하거나 중간자 역할을 하지 않도록 신뢰됩니다.

인증자는 신뢰할 수 있는 당사자이기도 합니다. 인증자는 백엔드 인증 서버에서 제공한 키 입력 자료를 다른 당사자에게 배포하지 않도록 신뢰됩니다. 인증자가 키 파생 기능을 사용하여 추가 키 자료를 파생하는 경우 인증자는 파생된 키 자료를 피어에게 알려진 적절한 당사자에게만 배포하고 다른 당사자에게는 배포하지 않도록 신뢰됩니다. 이 접근 방식을 사용하는 경우 결과 키 관리 시스템이 \[RFC4962\]의 모든 원칙을 충족하고 데이터를 보호하는 데 사용되는 키가 피어와 인증자에게만 알려지도록 주의를 기울여야 합니다.

보안 연결 프로토콜\(2단계\)이 완료되면 EAP 피어\(피어 ID로 식별됨\) 및 인증자\(NAS 식별자로 식별됨\)에게만 알려진 임시 세션 키\(TSK\)가 파생되거나 전송됩니다. . EAP 피어와 인증자 모두 TSK가 최신임을 알고 있습니다. EAP 피어와 인증자 모두 자신의 역할을 수행할 권한이 있음을 보여줍니다. 승인 문제는 섹션 4.3.2 및 5.5에서 논의됩니다. 보안 연관 프로토콜의 보안 속성은 섹션 3.1에서 논의됩니다.

---
### **1.6.  EAP Invariants**

"EAP 불변"으로 알려진 특정 기본 특성은 EAP 구현에 적용됩니다.

```text
      Mode independence
      Media independence
      Method independence
      Ciphersuite independence
```

---
#### **1.6.1.  Mode Independence**

EAP는 일반적으로 피어가 하나 이상의 인증자를 통해 네트워크 액세스를 원하는 상황에서 확장 가능한 네트워크 액세스 인증을 지원하기 위해 배포됩니다. 인증자가 독립형으로 배포되는 경우 피어와 인증자 간에 EAP 대화가 발생하고 인증자는 하나 이상의 EAP 방법을 로컬로 구현합니다. 그러나 "통과" 모드에서 EAP를 활용하면 인증자에서 새 코드를 개발하지 않고도 새로운 인증 방법을 배포할 수 있습니다.

인증자는 일부 EAP 방법을 로컬로 구현하고 해당 방법을 사용하여 로컬 사용자를 인증할 수 있지만 동시에 다른 사용자 및 방법에 대한 통과 역할을 하여 백엔드 인증 서버와 피어 간에 EAP 패킷을 앞뒤로 전달할 수 있습니다. . 이는 인증자와 백엔드 인증 서버 간에 사용되는 AAA\(Authentication, Authorization, Accounting\) 프로토콜 내에서 EAP 패킷을 캡슐화하여 수행됩니다. EAP를 지원하는 AAA 프로토콜에는 RADIUS \[RFC3579\] 및 Diameter \[RFC4072\]가 포함됩니다.

EAP 방법 계층에서 EAP 피어와 서버 간의 대화는 EAP 인증자가 "통과" 모드에서 작동하는지 여부에 영향을 받지 않는다는 것이 EAP의 기본 속성입니다. EAP 방법은 인증자가 통과로 작동하는지 여부에 관계없이 키 파생 및 매개변수 가져오기/내보내기를 포함한 모든 측면에서 동일하게 작동합니다.

키 파생을 지원하는 EAP 방법이 성공적으로 완료되면 EAP 피어 및 서버에서 EAP 키 입력 자료 및 매개변수가 내보내집니다. EAP 피어 또는 서버가 EAP 인증자의 ID를 포함할 수 있는 채널 바인딩 매개변수를 가져올 수 있더라도 이 정보는 불투명 옥텟으로 처리됩니다. 결과적으로 EAP 내에서 유일한 관련 ID는 피어 ID와 서버 ID입니다. 채널 바인딩 매개변수는 하위 계층에서만 해석됩니다.

EAP 내에서 AAA 프로토콜의 주요 기능은 모드 독립성 원칙을 유지하는 것입니다. EAP 피어에 관한 한 EAP 인증자와의 대화 및 해당 대화의 모든 결과는 인증자 작동 모드에 관계없이 동일합니다.

---
#### **1.6.2.  Media Independence**

EAP의 목표 중 하나는 EAP 방법이 \[RFC3748\] 섹션 3.1에 설명된 기준을 충족하는 하위 계층에서 작동하도록 허용하는 것입니다. 예를 들어 \[RFC3748\]에 설명된 대로 EAP 인증은 PPP\[RFC1661\], IEEE 802 유선 네트워크\[IEEE-802.1X\], 802.11\[IEEE-802.11\] 및 802.16\[IEEE-802.16e\]과 같은 무선 네트워크를 통해 실행될 수 있습니다. \].

미디어 독립성을 유지하기 위해서는 EAP가 미디어별 요소를 고려하지 않는 것이 필요합니다. 예를 들어, EAP 방법은 해당 방법이 전송되는 하위 계층에 대한 지식을 가지고 있다고 가정할 수 없으며 특정 사용 환경\(예: 매체 액세스 제어\(MAC\) 주소\)과 관련된 식별자로 제한될 수 없습니다.

채널 바인딩 또는 방법별 식별을 지원하는 EAP 방법 내에서 미디어 독립성이 유지될 수 있습니다. EAP 방법은 식별자를 사용하기 위해 식별자의 내용을 알 필요가 없습니다. 이를 통해 EAP 방법은 미디어 독립성을 손상시키지 않고 MAC 주소와 같은 미디어별 식별자를 사용할 수 있습니다. 채널 바인딩 매개변수는 EAP 방법에 의해 불투명 옥텟으로 처리되므로 이를 처리하는 데 미디어 관련 지식이 필요하지 않습니다.

---
#### **1.6.3.  Method Independence**

통과를 활성화하면 인증자는 로컬로 구현된 메서드뿐만 아니라 피어와 서버에 구현된 모든 메서드를 지원할 수 있습니다. 이를 통해 인증자는 피어가 사용하도록 구성된 EAP 방법을 구현하지 않아도 됩니다. 실제로 통과 인증자는 EAP 방법을 전혀 구현할 필요가 없으므로 EAP 방법별 코드를 지원한다고 가정할 수 없습니다. \[RFC3748\] 섹션 2.3에 명시된 대로:

- 규정을 준수하는 통과 인증자 구현은 기본적으로 모든 유형의 EAP 패킷을 전달해야 합니다.\(MUST\)

이는 반드시 구현해야 하고 사용 중인 미디어에 허용 가능한 보안을 제공하는 단일 EAP 방법이 없는 경우에 유용합니다. 예를 들어, \[RFC3748\] 필수 EAP 방법\(MD5-Challenge\)은 사전 공격 저항, 상호 인증 또는 키 파생을 제공하지 않으므로 무선 근거리 통신망\(WLAN\)에서 사용하기에 적합하지 않습니다. \) 인증 \[RFC4017\]. 그러나 그럼에도 불구하고 EAP 피어와 서버 모두에서 적절한 EAP 방법이 지원되는 한 피어와 인증자는 상호 운용이 가능합니다.

---
#### **1.6.4.  Ciphersuite Independence**

암호 제품군 독립성은 미디어 독립성을 위한 요구 사항입니다. 하위 계층 암호 모음은 미디어마다 다르므로 미디어 독립성을 위해서는 내보낸 EAP 키 자료가 모든 암호 모음을 처리할 수 있을 만큼 충분히 커야 합니다\(충분한 엔트로피 포함\).

EAP 방법은 EAP 대화 보호에 사용되는 암호 모음을 협상할 수 있지만, EAP 인증이 완료된 후 교환되는 데이터 보호에 사용되는 암호 모음은 EAP 외부의 하위 계층 내 피어와 인증자 간에 협상됩니다.

예를 들어, PPP 내에서 암호화 제품군은 EAP 인증이 완료된 후 \[RFC1968\]에 정의된 ECP\(암호화 제어 프로토콜\) 내에서 협상됩니다. \[IEEE-802.11\] 내에서 AP 암호화 제품군은 EAP 인증 이전에 비콘 및 프로브 응답에 광고되며 4방향 핸드셰이크 교환 중에 안전하게 확인됩니다.

데이터를 보호하는 데 사용되는 암호화 모음은 하위 계층에 의존하므로 EAP 방법이 하위 계층 암호 모음에 대한 지식을 갖도록 요구하면 미디어 독립성 원칙이 손상됩니다. 결과적으로 메서드는 암호 제품군에 독립적인 EAP 키 입력 자료를 내보냅니다. 암호 집합 협상은 하위 계층에서 발생하므로 EAP 내에서는 하위 계층 암호 집합 협상이 필요하지 않습니다.

EAP 키잉 프레임워크 내에서 암호 모음을 사용할 수 있도록 하려면 암호 모음 사양에서는 암호 모음과 함께 사용하기에 적합한 TSK가 내보낸 EAP 키 자료에서 파생되는 방법을 설명해야 합니다. 방법 독립성을 유지하기 위해 TSK 파생을 위한 알고리즘은 EAP 방법에 의존해서는 안 되지만, TEK 파생을 위한 알고리즘은 EAP 방법에 특정할 수 있습니다.\(MUST NOT\)

암호 모음 독립성의 장점은 다음과 같습니다.

업데이트 요구 사항 감소

- 암호 모음 독립성을 통해 방법을 업데이트할 필요 없이 EAP 방법을 새로운 암호 모음과 함께 사용할 수 있습니다. EAP 방법이 각 암호 모음에 대한 임시 세션 키를 파생하는 방법을 지정하려면 새 암호 모음이 개발될 때마다 업데이트해야 합니다. 또한 백엔드 인증 서버는 모든 EAP 가능 인증자와 함께 사용하지 못할 수도 있습니다. 왜냐하면 백엔드 인증 서버는 인증자에 새로운 암호 모음에 대한 지원이 추가될 때마다 업데이트해야 하기 때문입니다.

EAP 방법의 복잡성 감소

- 암호 모음 독립성을 통해 EAP 방법에서는 암호 모음별 코드를 포함할 필요가 없습니다. 임시 세션 키 파생을 위해 각 EAP 방법에 암호 제품군별 코드를 포함하도록 요구하면 방법이 복잡해지고 노력이 중복됩니다.

단순화된 구성

- 암호화 제품군 독립성을 통해 피어 및 서버에서 EAP 방법 구현을 통해 암호화 제품군별 매개변수를 구성할 필요가 없습니다. 암호 모음은 EAP 외부의 피어와 인증자 간에 협상됩니다. 인증자가 "통과" 모드에서 작동하는 경우 EAP 서버는 이 협상의 당사자가 아니며 EAP 피어와 인증자 간의 데이터 흐름에도 관여하지 않습니다. 결과적으로 EAP 서버는 피어와 인증자가 구현한 암호 모음 및 협상 정책에 대한 지식이 없으며 둘 사이에 협상된 암호 모음도 인식하지 못합니다. 예를 들어 ECP\(암호화 제어 프로토콜\) 협상은 인증 후에 발생하므로 PPP를 통해 실행되면 EAP 피어와

- 서버는 협상된 암호 그룹을 예상할 수 없으므로 이 정보를 EAP 방법에 제공할 수 없습니다.

---
## **2.  Lower-Layer Operation**

EAP 인증이 완료되면 EAP 방법으로 내보낸 EAP 키 자료 및 매개변수가 하위 계층과 AAA 계층\(있는 경우\)에 제공됩니다. 여기에는 MSK\(마스터 세션 키\), EMSK\(확장 마스터 세션 키\), 피어 ID, 서버 ID 및 세션 ID가 포함됩니다. 초기화 벡터\(IV\)는 더 이상 사용되지 않지만 제공될 수 있습니다.

메소드 내에서 파생된 EAP 키 자료의 보안을 유지하기 위해 하위 계층은 EAP 메소드에 의해 전달된 키를 내보내면 안 됩니다. 이는 하위 계층으로 전달된 EAP 키 자료가 해당 하위 계층에서만 사용되며 다른 하위 계층 내에서 사용되어서는 안 된다는 것을 의미합니다. 이는 하나의 하위 계층이 EAP 키 자료를 사용하여 다른 애플리케이션을 손상시키는 것을 방지합니다.\(MUST NOT, MUST NOT\)

하위 계층에 제공된 EAP 키 자료는 다른 엔터티로 전송되어서는 안 됩니다. 예를 들어, EAP 피어 하위 계층으로 전달된 EAP 키 자료는 피어를 떠나서는 안 됩니다. EAP 인증자 하위 계층으로 전달되거나 전송되는 EAP 키 자료는 인증자를 떠나서는 안 됩니다.\(MUST NOT, MUST NOT\)

EAP 서버에서 AAA 계층에 의해 요청되고 전달된 키 자료 및 매개변수는 인증자의 AAA 계층에 복제될 수 있습니다\(EMSK 제외\). 인증자에서 AAA 계층은 복제된 키 입력 자료와 매개변수를 EAP 인증 대화가 발생한 하위 계층에 제공합니다. 이를 통해 모드 독립성을 유지할 수 있습니다.\(MAY\)

EAP 계층과 피어 및 인증자 계층은 EAP 방법 계층과 하위 계층 또는 AAA 계층 사이의 어느 방향으로든 전달되는 키 자료 또는 매개변수\(채널 바인딩 포함\)를 수정하거나 캐시해서는 안 됩니다.\(MUST NOT\)

---
### **2.1.  Transient Session Keys**

하위 계층에서 명시적으로 지원하는 경우 하위 계층은 내보낸 EAP 키 자료 및/또는 TSK를 포함하여 키 자료를 캐시할 수 있습니다. 이 키 캐시의 구조는 하위 계층에 의해 정의됩니다. 상호 운용성을 활성화하려면 새로운 하위 계층 사양이 키 캐싱 동작을 설명해야 합니다. 하위 계층에서 명시적으로 지정하지 않는 한 EAP 피어, 서버 및 인증자는 다음을 가정해야 합니다.\(MAY, MUST, MUST\)

피어와 인증자는 키 입력 자료를 캐시하지 않습니다. 기존 EAP 하위 계층과 AAA 계층은 임시 세션 키 생성과 EAP 키 자료 캐싱을 다양한 방식으로 처리합니다.

IEEE 802.1X-2004

- 유선 네트워크와 함께 사용하는 경우 IEEE 802.1X-2004 \[IEEE-802.1X\]는 링크 계층 암호화 제품군을 지원하지 않으므로 TSK 생성 또는 EAP 키 자료 및 매개변수 캐싱을 제공하지 않습니다. EAP 인증이 완료되면 EAP 키 자료 및 매개변수가 폐기되는 것으로 간주됩니다. IEEE 802 유선 네트워크에서는 후속 보안 연결 프로토콜 교환이 없습니다. PFS\(Perfect Forward Secrecy\)는 협상된 EAP 방법이 이를 지원하는 경우에만 가능합니다.

PPP

- \[RFC1661\]에 정의된 PPP는 보안 연결 프로토콜에 대한 지원을 포함하지 않으며 EAP 키 자료 또는 매개변수의 캐싱도 지원하지 않습니다. PPP 암호 모음은 \[RFC2716\] 섹션 3.5에 설명된 대로 MSK에서 직접 TSK를 파생합니다. PPP가 EAP 키 자료의 캐싱을 지원하는 경우 TSK가 재사용될 수 있으므로 이는 권장되지 않습니다. 결과적으로, PPP 세션이 종료되면 EAP 키 자료 및 매개변수를 폐기해야 합니다. EAP 키 자료의 캐싱은 PPP 내에서 허용되지 않으므로 EAP 재인증 없이는 TSK 재키를 처리할 수 있는 방법이 없습니다. PFS\(Perfect Forward Secrecy\)는 협상된 EAP 방법이 이를 지원하는 경우에만 가능합니다.\(SHOULD NOT, MUST\)

IKEv2

- \[RFC4306\]에 정의된 IKEv2는 키 파생이 아닌 인증 목적으로만 MSK를 사용합니다. EMSK, IV, Peer-Id, Server-Id 또는 Session-Id는 사용되지 않습니다. 결과적으로 IKEv2에서 파생된 TSK는 EAP 키 자료와 암호화적으로 독립적이며 IPsec SA의 키 재설정은 EAP 재인증 없이 처리될 수 있습니다. IKEv2 내에서는 어떤 EAP 방법이 협상되는지에 관계없이 PFS를 협상할 수 있습니다. \[RFC4306\]에 지정된 IKEv2는 EAP 키 입력 자료 또는 매개변수를 캐시하지 않습니다. IKEv2 인증이 완료되면 EAP 키 입력 자료 및 매개변수가 삭제되는 것으로 가정됩니다. 따라서 세션 시간 초과 속성은 MSK 키 수명을 나타내는 것이 아니라 VPN 세션 시간에 대한 제한으로 해석됩니다.

IEEE 802.11

- IEEE 802.11은 MSK 캐싱을 활성화하지만 EMSK, IV, Peer-Id, Server-Id 또는 Session-Id는 활성화하지 않습니다. 캐시 구조에 대한 자세한 내용은 \[IEEE-802.11\]에서 확인할 수 있습니다. IEEE에서는

- 802.11, TSK는 Nonce 교환을 포함하는 4방향 핸드셰이크로 알려진 보안 연결 프로토콜을 사용하여 MSK에서 파생됩니다. 이는 MSK를 재사용하더라도 TSK의 신선도를 보장합니다. 4방향 핸드셰이크를 사용하면 EAP 재인증 없이 TSK 키 재설정이 가능합니다. PFS는 캐싱이 활성화되지 않고 협상된 EAP 방법이 PFS를 지원하는 경우 IEEE 802.11 내에서만 가능합니다.

IEEE 802.16e

- \[IEEE-802.16e\]에 정의된 IEEE 802.16e는 MSK 캐싱을 지원하지만 EMSK, IV, Peer-Id, Server-Id 또는 Session-Id는 지원하지 않습니다. IEEE 802.16e는 피어의 기여 없이 인증자가 TSK를 선택하는 보안 연관 프로토콜을 지원합니다. TSK는 MSK를 사용하여 암호화, 인증 및 무결성 보호되며 인증자에서 피어로 전송됩니다. EAP 재인증 없이 TSK re-key가 가능합니다. 협상된 EAP 방법이 PFS를 지원하더라도 PFS는 불가능합니다.

AAA

- RADIUS/EAP \[RFC3579\] 또는 Diameter EAP \[RFC4072\]에 대한 기존 구현 및 사양은 키 자료 또는 매개변수의 캐싱을 지원하지 않습니다. 기존 AAA 클라이언트, 프록시 및 서버 구현에서 내보낸 EAP 키 자료\(MSK, EMSK 및 IV\)와 매개변수 및 파생 키는 캐시되지 않으며 AAA 교환이 완료된 후 손실된 것으로 추정해야 합니다\(MUST\).\(MUST\)

키 재사용을 방지하려면 AAA 레이어를 삭제해야 합니다.

- 키가 전송되면 전송됩니다. AAA 계층은 이전에 보낸 키를 보관해서는 안 됩니다. 예를 들어, MSK를 전송한 AAA 계층은 이를 삭제해야 하며\(MUST\) 해당 지점부터 MSK에서 키가 파생되어서는 안 됩니다\(MUST NOT\).\(MUST, MUST NOT, MUST NOT\)

---
### **2.2.  Authenticator and Peer Architecture**

이 사양은 EAP 인증자 또는 피어의 아키텍처에 제한을 두지 않습니다. 예를 들어 \[RFC4118\]에 설명된 인증자 아키텍처 중 하나를 사용할 수 있습니다. 결과적으로 하위 계층은 피어 및 인증자 아키텍처에 대한 암시적 가정을 통합하지 않고 EAP 피어 및 인증자를 명확하게 식별해야 합니다.

예를 들어, 여러 기지국과 "컨트롤러"\(예: WLAN 스위치\)가 단일 EAP 인증자를 구성하는 것이 가능합니다. 이러한 상황에서 "기지국 ID"는 채널 바인딩에 사용되는 불투명한 blob을 제외하고는 EAP 방법 대화와 관련이 없습니다. 많은 기지국이 동일한 인증자 ID를 공유할 수 있습니다. EAP 인증자 또는 피어:

\(a\) 하나 이상의 물리적 또는 논리적 포트를 포함할 수 있습니다.

- \(b\) 자신을 하나 이상의 "가상" 인증자 또는 피어로 광고할 수 있습니다. \(c\) 여러 CPU를 활용할 수 있습니다. \(d\) 로드 밸런싱이나 장애 조치를 위한 클러스터링 서비스를 지원할 수 있습니다.

EAP 피어와 인증자 모두 둘 이상의 물리적 또는 논리적 포트를 가질 수 있습니다. 피어는 여러 인증자를 통해 또는 특정 인증자의 여러 물리적 또는 논리적 포트를 통해 네트워크에 동시에 액세스할 수 있습니다. 마찬가지로 인증자는 각각 별도의 물리적 또는 논리적 포트를 통해 여러 피어에 대한 네트워크 액세스를 제공할 수 있습니다. 단일 물리적 인증자가 자신을 여러 가상 인증자로 광고하는 경우 단일 물리적 포트가 여러 가상 인증자에 속할 수 있습니다.

인증자는 둘 이상의 EAP 서버와 통신하도록 구성할 수 있으며, 각 서버는 인증자의 하위 집합과 통신하도록 구성됩니다. 상황은 그림 3에 나와 있습니다.

---
### **2.3.  Authenticator Identification**

EAP 방법 대화는 EAP 피어와 서버 간에 이루어집니다. 인증자 ID는 EAP 방법으로 고려되는 경우 채널 바인딩을 위해 불투명한 블롭으로 처리됩니다\(섹션 5.3.3 참조\). 그러나 인증자 신원은 다른 두 교환, 즉 AAA 프로토콜 교환과 보안 연관 프로토콜 대화에서 중요합니다.

AAA 대화는 EAP 인증자와 백엔드 인증 서버 간에 이루어집니다. 백엔드 인증 서버의 관점에서 볼 때 키 입력 자료와 매개변수는 NAS 식별자 속성으로 식별되는 EAP 인증자로 전송됩니다. EAP 인증자는 EAP 키 자료 또는 매개변수를 다른 당사자와 공유해서는 안 되기 때문에, EAP 피어 또는 백엔드 인증 서버가 NAS 식별자에 의해 정의된 범위를 벗어나는 EAP 키 자료 및 매개변수의 사용을 감지하는 경우 키 자료는 손상된 것으로 간주되어야 합니다.\(MUST NOT\)

Secure Association Protocol 대화는 피어와 인증자 사이에서 이루어집니다. 키 캐싱을 지원하는 하위 계층의 경우 EAP 피어, 인증자 및 백엔드 서버가 전송된 키 자료의 사용 범위에 대한 일관된 보기를 갖는 것이 특히 중요합니다. 이를 활성화하려면 인증자와 피어 엔드포인트 주소에 의해 정의된다고 암묵적으로 가정하기보다는 보안 연결 프로토콜이 하위 계층으로 전달된 EAP 키 자료의 사용 범위를 명시적으로 전달하는 것이 권장됩니다.\(SHOULD\)

```text
                     +-+-+-+-+
                     | EAP   |
                     | Peer  |
                     +-+-+-+-+
                       | | |  Peer Ports
                      /  |  \
                     /   |   \
                    /    |    \
                   /     |     \
                  /      |      \
                 /       |       \
                /        |        \
               /         |         \     Authenticator
            | | |      | | |      | | |   Ports
          +-+-+-+-+  +-+-+-+-+  +-+-+-+-+
          |       |  |       |  |       |
          | Auth1 |  | Auth2 |  | Auth3 |
          |       |  |       |  |       |
          +-+-+-+-+  +-+-+-+-+  +-+-+-+-+
               \        | \         |
                \       |  \        |
                 \      |   \       |
   EAP over AAA   \     |    \      |
     (optional)    \    |     \     |
                    \   |      \    |
                     \  |       \   |
                      \ |        \  |
                   +-+-+-+-+-+  +-+-+-+-+-+  Backend
                   |  EAP    |  |  EAP    |  Authentication
                   | Server1 |  | Server2 |  Servers
                   +-+-+-+-+-+  +-+-+-+-+-+
```

그림 3: EAP 피어, 인증자 및 서버 간의 관계

인증자는 여러 포트를 가질 수 있으므로 인증자 키 캐시의 범위는 단일 엔드포인트 주소로 설명할 수 없습니다. 마찬가지로 피어가 여러 포트를 가질 수 있고 동일한 피어 포트 간에 EAP 키 입력 자료 및 매개변수를 공유할 수 있습니다.

링크 유형이 허용되면 단일 엔드포인트 주소를 사용하여 피어 키 캐시의 범위를 전달할 수 없습니다. 대신, EAP 피어와 인증자는 엔드포인트 주소나 포트 식별자가 아닌 명시적 식별자를 사용하여 일관되게 자신을 식별하는 것이 좋습니다.\(SHOULD\)

RADIUS \[RFC3579\] 및 Diameter \[RFC4072\]와 같은 AAA 프로토콜은 AAA 클라이언트 식별을 위한 메커니즘을 제공합니다. EAP 인증자와 AAA 클라이언트는 반드시 공동 상주해야 하므로 이 메커니즘은 EAP 인증자의 식별에 적용 가능합니다.\(MUST\)

RADIUS \[RFC2865\]에서는 액세스 요청 패킷에 NAS-식별자, NAS-IP-주소 및 NAS-IPv6-주소 속성 중 하나 이상이 포함되어야 합니다. NAS는 하나 이상의 IP 주소를 가질 수 있으므로 AAA 프로토콜 교환 및 보안 연관 프로토콜 대화 내에서 인증자의 명시적인 식별을 위해 NAS-식별자 속성을 권장합니다.\(SHOULD\)

피어와 인증자가 끝점 주소를 사용하여 암시적으로 자신을 식별하는 경우 발생할 수 있는 문제는 다음과 같습니다.

\(a\) 피어는 어떤 인증자 포트가 어떤 인증자와 연관되어 있는지 확인하지 못할 수도 있습니다. 결과적으로 EAP 피어는 인증자 키 캐시를 효율적인 방식으로 활용할 수 없으며 EAP 키 자료가 승인된 범위 외부에서 공유되었는지 여부도 확인할 수 없으므로 손상된 것으로 간주해야 합니다.

\(b\) 인증자가 어떤 피어 포트가 어떤 피어와 연관되어 있는지 확인할 수 없어 피어가 여러 피어 포트를 사용하여 통신하지 못하게 될 가능성이 있습니다.

\(c\) 피어가 어떤 가상 인증자와 통신하고 있는지 확인하지 못할 수도 있습니다. 예를 들어, 여러 가상 인증자는 MAC 주소를 공유할 수 있지만 다른 NAS 식별자를 활용할 수 있습니다.

\(d\) 인증자가 어떤 가상 피어와 통신하고 있는지 확인하지 못할 수도 있습니다. 여러 가상 피어가 MAC 주소를 공유할 수 있지만 서로 다른 피어 ID를 활용할 수 있습니다.

\(e\) EAP 피어와 서버가 채널 바인딩을 통해 인증자 ID를 확인하지 못할 수도 있습니다.

예를 들어, 4-way 핸드셰이크 내에서 피어 및 인증자 MAC 주소를 활용하는 \[IEEE-802.11\]에서는 \(a\), \(c\), \(e\) 문제가 발생합니다. \[IEEE-802.11\]에서는 가상 피어가 단일 포트만 활용하도록 허용하므로 \(b\) 및 \(d\) 문제는 발생하지 않습니다.

다음 단계를 통해 모든 당사자가 하위 계층 ID를 안전하게 확인할 수 있습니다.

\(f\) 식별하는 데 사용되는 하위 계층 매개변수를 지정합니다.

- 인증자 및 피어. 앞에서 언급한 것처럼 인증자나 피어가 여러 포트를 가질 수 있는 경우 이를 식별하는 데 엔드포인트나 포트 식별자는 권장되지 않습니다.

\(g\) 0단계 내에서 피어와 인증자 사이의 하위 계층 ID를 통신합니다. 이를 통해 키 캐시가 활용되는 경우 피어와 인증자가 키 범위를 결정할 수 있습니다.

\(h\) NAS-식별자 속성 내에서 인증자와 백엔드 인증 서버 간에 하위 계층 인증자 ID를 전달합니다.

\(i\) 1a단계의 채널 바인딩\(지원되는 경우\) 내에 하위 계층 ID를 포함하여 EAP 피어와 서버 간에 통신되도록 합니다.

\(j\) 2a단계 내에서 무결성으로 보호된 신원 교환을 지원합니다.

\(k\) 공개된 하위 계층 ID를 활용하여 피어와 인증자가 키가 공개된 범위 내에 유지되는지 확인할 수 있도록 합니다.

---
#### **2.3.1.  Virtual Authenticators**

단일 물리적 인증자가 자신을 여러 가상 인증자로 광고할 때 가상 인증자가 논리적으로 별도의 키 캐시를 유지하지 않는 경우 하나의 가상 인증자에게 인증함으로써 피어는 키 캐시를 공유하는 다른 가상 인증자에 액세스할 수 있습니다.

예를 들어, 물리적 인증자가 "게스트" 및 "기업 인트라넷" 가상 인증자를 구현하는 경우 피어 역할을 하는 공격자는 "게스트" 가상 인증자로 인증하고 EAP 키 자료를 파생할 수 있습니다. "게스트" 및 "회사 인트라넷" 가상 인증자가 키 캐시를 공유하는 경우 피어는 "게스트" 네트워크에 대해 파생된 EAP 키 자료를 활용하여 "회사 인트라넷" 네트워크에 대한 액세스 권한을 얻을 수 있습니다.

이 취약점을 완화하려면 다음 단계를 수행할 수 있습니다.

\(a\) 인증자는 EAP 키 자료 및 매개변수와 함께 관련 인증을 캐시하고 어떤 가상 인증자가 액세스되는지에 관계없이 각 네트워크 액세스 시 피어에 인증을 적용해야 합니다. 이렇게 하면 키 캐시가 가상 인증자 간에 공유되는 경우에도 공격자가 상승된 권한을 얻을 수 없으며 피어는 다른 가상 인증자와 함께 사용하기 위해 생성된 키 캐시 항목을 활용하여 하나의 가상 인증자에 대한 액세스 권한을 얻을 수 있습니다.\(MUST\)

\(b\) 물리적 인증자는 각 가상 인증자에 대해 별도의 키 캐시를 유지하는 것이 좋습니다. 이렇게 하면 하나의 가상 인증자에 사용하기 위해 생성된 캐시 항목이 다른 가상 인증자에 액세스하는 데 사용될 수 없습니다. 가상 인증 간에 키 캐시 항목을 더 이상 공유할 수 없으므로 이 단계에서는 \(a\)에서 제공하는 것 이상의 보호 기능을 제공합니다. 이는 액세스 제한을 시행하기 위해 권한 부여가 사용되지 않는 상황에서 유용합니다. 예를 들어 인증자에게 제공되는 인증을 사용하지 않고 라우터에 설치된 필터를 사용하여 액세스가 제한되는 경우 피어는 공유 키 캐시 항목을 이용하여 리소스에 대한 무단 액세스를 얻을 수 있습니다.\(SHOULD\)

\(c\) 피어가 채널 바인딩을 통해 인증자 신원을 확인할 수 있도록 각 가상 인증자가 피어 및 백엔드 인증 서버에 일관되게 자신을 식별하는 것이 권장됩니다\(섹션 5.3.3 참조\).\(SHOULD\)

\(d\) 피어 및 백엔드 인증 서버가 이들을 구별할 수 있도록 각 가상 인증자가 자신을 뚜렷하게 식별하는 것이 권장됩니다. 예를 들어, 이는 NAS 식별자 속성의 고유한 값을 활용하여 수행할 수 있습니다.\(SHOULD\)

---
### **2.4.  Peer Identification**

\[RFC3748\] 7.3절에 설명된 바와 같이 EAP-Response/Identity에 제공되는 피어 ID는 EAP 방식으로 인증된 피어 ID와 다를 수 있습니다. 예를 들어, 제공된 ID

EAP-Response/Identity는 "네트워크 액세스 식별자" \[RFC4282\] 섹션 2에 설명된 대로 개인 정보 식별자가 될 수 있습니다. \[RFC4284\]에 명시된 대로 NAI\(네트워크 액세스 식별자\)를 목적으로 활용하는 것도 가능합니다. 소스 라우팅; 소스 라우팅에 활용되는 NAI는 \[RFC4282\] 섹션 2.7에 설명된 대로 "장식"되었다고 합니다.

\[RFC3579\]에 설명된 대로 EAP 피어가 EAP-Response/Identity 내에 NAI\(Network Access Identity\)를 제공하면 인증자는 EAP-Response/Identity에 포함된 NAI를 Access에 포함된 User-Name 속성에 복사합니다. -요구. 액세스 요청이 백엔드 인증 서버로 전달되면 AAA 프록시는 사용자 이름 속성에 포함된 NAI에서 장식을 제거합니다. 액세스 요청에 캡슐화된 EAP 응답/ID 내에 포함된 NAI는 변경되지 않습니다. 결과적으로 액세스 요청이 백엔드 인증 서버에 도착하면 EAP 응답/ID는 사용자 이름 속성\(장식의 일부 또는 전부가 제거될 수 있음\)과 다를 수 있습니다. Peer-Id가 없는 경우 백엔드 인증 서버는 EAP-Response/Identity가 아닌 User-Name Attribute의 내용을 피어 ID로 사용해야 합니다.\(SHOULD\)

EAP 방법으로 둘 이상의 Peer-Id를 내보낼 수 있습니다. 예를 들어 피어 인증서에는 둘 이상의 피어 ID가 포함될 수 있습니다. 터널 방식에서는 피어 ID가 외부 및 내부 교환 모두에서 인증될 수 있으며 이러한 ID는 유형과 내용이 다를 수 있습니다. 예를 들어, 외부 교환은 RDN\(Relative Distinguished Name\) 형식으로 Peer-Id를 제공할 수 있는 반면, 내부 교환은 NAI 또는 MAC 주소를 통해 피어를 식별할 수 있습니다. EAP 키 자료가 외부 교환에서만 결정되는 경우 외부 피어 ID만 내보내집니다. EAP 키 자료가 내부 및 외부 교환 모두에서 결정되는 경우 내부 및 외부 Peer-Id가 모두 터널 방법으로 내보내집니다.

---
### **2.5.  Server Identification**

EAP 방법으로 둘 이상의 서버 ID를 내보낼 수 있습니다. 예를 들어, 서버 인증서에는 둘 이상의 서버 ID가 포함될 수 있습니다. 터널 방식에서는 서버 신원이 외부 및 내부 교환 모두에서 인증될 수 있으며 이러한 신원은 유형과 내용이 다를 수 있습니다. 예를 들어 외부 교환은 IP 주소 형식으로 서버 ID를 제공할 수 있는 반면, 내부 교환은 FQDN\(정규화된 도메인 이름\) 또는 호스트 이름을 통해 서버를 식별할 수 있습니다. EAP 키 자료가 외부 교환에서만 결정되는 경우 외부 서버 ID만 EAP 방법으로 내보내집니다. EAP 키 자료가 내부 및 외부 교환 모두에서 결정되는 경우 내부 및 외부 서버 ID가 모두 EAP 방법으로 내보내집니다.

그림 3에 표시된 것처럼 인증자는 여러 EAP 서버와 통신하도록 구성할 수 있습니다. 인증자가 통신하는 EAP 서버는 구성, 네트워크 및 서버 가용성에 따라 달라질 수 있습니다. EAP 피어는 영역 내의 모든 EAP 서버가 인증 시도를 확인하는 데 필요한 자격 증명에 액세스할 수 있다고 가정할 수 있지만 모든 EAP 서버가 영구 상태를 공유한다고 가정할 수는 없습니다.

로드 균형을 맞추기 위해 다양한 기본 또는 보조 EAP 서버로 인증자를 구성할 수 있습니다. 또한 인증자는 요청이 전송될 EAP 서버를 동적으로 결정할 수 있습니다. 통신 장애가 발생하는 경우 인증자는 다른 EAP 서버로 장애 조치할 수 있습니다. 예를 들어 그림 3에서 Authenticator2는 처음에 EAP server1을 기본 백엔드 인증 서버로, EAP server2를 백업으로 사용하여 구성할 수 있지만 EAP server1을 사용할 수 없게 되면 EAP server2가 기본 서버가 될 수 있습니다.

일반적으로 EAP 피어는 영역 내의 특정 EAP 서버에 인증 시도를 지시할 수 없습니다. 이 결정은 AAA 클라이언트에 의해 이루어지며, 피어는 EAP 방법을 시작하기 전에 어떤 EAP 서버와 통신할 것인지 결정할 수도 없습니다. 대화. Server-Id는 EAP-요청/ID에 포함되지 않으며 EAP 서버는 동적으로 결정될 수 있으므로 일반적으로 인증자가 검색 단계 동안 Server-Id를 광고하는 것은 불가능합니다. 일부 EAP 방법은 Server-Id를 내보내지 않으므로 EAP 대화가 성공적으로 완료된 후 EAP 피어가 어떤 서버와 대화 중인지 알 수 없습니다.

결과적으로 EAP 피어는 새 인증자에 연결하거나 동일한 인증자에 다시 연결할 때 다른 EAP 서버와 통신하고 있음을 알 수 있습니다. \[RFC3748\]에 정의된 빠른 재연결

섹션 7.2는 피어가 통신하는 EAP 서버가 처음에 보안 연결을 설정한 서버와 동일하지 않으면 실패할 수 있습니다. 예를 들어, EAP-TLS 세션 재개를 시도하는 EAP 피어는 새 EAP-TLS 서버가 TLS 세션 ID로 식별되는 TLS 마스터 키에 액세스할 수 없으므로 세션 재개 시도가 실패하고 완료가 필요함을 알 수 있습니다. 전체 EAP-TLS 교환.

Server-Id를 내보내는 EAP 방법은 서버를 인증해야 합니다. 그러나 상호 인증을 지원하는 모든 EAP 방법이 null이 아닌 서버 ID를 제공하는 것은 아닙니다. 일부 방법에서는 EAP 피어가 EAP 서버가 장기 비밀을 보유하고 있는지 확인할 수만 있고 EAP 서버의 ID는 제공하지 않습니다. 이 경우 EAP 피어는 인증자가 EAP 서버에 의해 승인되었음을 알지만 EAP 서버의 신원은 확인하지 않습니다. EAP 방법이 서버 ID를 제공하지 않는 경우 피어는 키 자료를 생성한 EAP 서버를 식별할 수 없습니다. 이로 인해 EAP 피어가 해당 EAP 서버가 소유한 키의 위치를 ​​식별하기 어려울 수 있습니다.\(MUST\)

\[RFC5216\] 섹션 5.2에 명시된 대로 서버 인증서를 사용하여 인증을 지원하는 EAP 방법은 서버 인증서의 주체 또는 subjectAltName 필드에서 Server-Id를 결정할 수 있습니다. EAP 서버 ID를 확인하면 EAP 피어가 특정 EAP 서버가 인증되었는지 여부를 결정하는 데 도움이 될 수 있습니다. \[RFC4334\]에 정의된 인증서 확장이 서버 인증서에 포함되어 있는 경우와 같은 경우에는 피어가 서버 인증서에서 일부 채널 바인딩 매개변수를 확인하는 것도 가능할 수도 있습니다.

EAP 서버가 EAP 피어 및 인증자와 다르게 자신을 식별하는 상황에서 문제가 발생할 수 있습니다. 예를 들어 EAP 방법으로 내보낸 서버 ID는 백엔드 인증 서버의 FQDN\(정규화된 도메인 이름\)과 동일하지 않을 수 있습니다. RADIUS 또는 Diameter 내에서 인증서 기반 인증이 사용되는 경우 백엔드 인증 서버 인증서에 사용되는 subjectAltName이 서버 ID 또는 백엔드 인증 서버 FQDN과 동일하지 않을 수 있습니다. 인증자는 EAP 피어와 서버 간에 사용되는 ID를 인식하지 못하므로 이는 일반적으로 EAP에서 문제가 되지 않습니다. 그러나 인증자가 EAP 피어에서 제공한 서버 ID에 해당하는 백엔드 인증 서버를 찾을 것으로 예상되는 경우 이는 키 캐싱에 문제가 될 수 있습니다.

백엔드 인증 서버 FQDN이 백엔드 인증 서버 인증서의 subjectAltName과 다른 경우 AAA 클라이언트가 올바른 백엔드 인증 서버와 통신하고 있는지 여부를 확인하지 못할 수 있습니다. 어디

서버 ID와 백엔드 인증 서버 FQDN이 다르면 키 범위\(피어 ID, 서버 ID\)와 EAP 대화 식별자\(세션 ID\)의 조합만으로는 충분하지 않을 수 있습니다. 키가 어디에 있는지 확인합니다. 예를 들어 인증자는 IP 주소\(RADIUS에서 발생\) 또는 정규화된 도메인 이름\(Diameter에서와 같이\)을 사용하여 백엔드 인증 서버를 식별할 수 있습니다. 서버 ID가 알려진 백엔드 인증 서버의 IP 주소 또는 FQDN과 일치하지 않는 경우 키를 소유한 백엔드 인증 서버를 찾는 것이 불가능할 수 있습니다.

---
## **3.  Security Association Management**

\[RFC3748\]에 정의된 EAP는 키 파생을 지원하지만 하위 계층 보안 연결 관리를 제공하지 않습니다. 누락된 기능은 다음과 같습니다.

\(a\) 보안 협회 협상. EAP는 암호화 알고리즘이나 트래픽 프로필을 포함하여 하위 계층 유니캐스트 또는 멀티캐스트 보안 연결을 협상하지 않습니다. EAP 방법은 기본 하위 계층이 아닌 자체 사용을 위한 암호화 알고리즘만 협상합니다. 또한 EAP는 협상된 암호 제품군으로 보호할 트래픽 프로필을 협상하지 않습니다. 어떤 경우에는 보호할 트래픽이 하위 계층 피어 또는 인증자 주소와 다른 하위 계층 소스 및 대상 주소를 가질 수 있습니다.

\(b\) 키를 다시 입력하세요. EAP 방법은 \[RFC3748\] 섹션 7.2.1에 정의된 대로 "빠른 재연결"을 지원할 수 있지만 EAP는 EAP 재인증 없이 내보낸 EAP 키 자료의 키 재입력을 지원하지 않습니다.

\(c\) 키 삭제/설치 의미론. EAP가 동기화되지 않음

- EAP 피어 및 인증자에 키 자료를 설치하거나 삭제합니다.

\(d\) 평생 협상. EAP는 내보낸 EAP 키 자료에 대한 수명 협상을 지원하지 않으며 기존 EAP 방법도 키 수명 협상을 지원하지 않습니다.

\(e\) TSK 신선도 보장. EAP 이후 핸드셰이크가 없으면 EAP 키 자료가 캐시되면 TSK를 재사용할 수 있습니다.

이러한 결함은 일반적으로 보안 연결 프로토콜\(Secure Association Protocol\)로 알려진 EAP 이후 핸드셰이크를 통해 해결됩니다.

---
### **3.1.  Secure Association Protocol**

EAP나 EAP 방법 모두 하위 계층 보안 연결 설정을 제공하지 않으므로 다음을 포함하여 보안 연결 프로토콜 내에서 이러한 기능을 제공하는 것이 좋습니다.\(SHOULD\)

\(a\) 엔터티 명명. Secure Association Protocol의 기본 기능은 교환에 참여하는 당사자의 이름을 명시적으로 지정하는 것입니다. 명시적인 식별이 없으면 교환에 참여하는 당사자가 식별되지 않으며 EAP 교환 중에 협상된 EAP 키 매개변수의 범위가 정의되지 않습니다.

\(b\) EAP 키 자료 보유에 대한 상호 증명. 보안 연결 프로토콜\(Secure Association Protocol\) 동안 EAP 피어와 인증자는 피어와 인증자가 승인되었음을 입증하기 위해 백엔드 인증 서버와 인증자\(예: MSK\) 사이에 전송되는 키 자료의 소유를 입증해야 합니다. 상호 소유 증명은 상호 인증과 동일하지 않기 때문에 피어는 이 교환의 결과로 인증자 주장\(인증자 ID 포함\)을 확인할 수 없습니다. 인증자 신원 확인은 섹션 2.3에서 논의됩니다.\(MUST\)

\(c\) 안전한 능력 협상. 검색 단계에서 스푸핑을 방지하고, "최상의" 암호 제품군을 선택하고, 협상된 보안 매개변수의 위조를 방지하기 위해 보안 연결 프로토콜은 보안 기능 협상을 지원해야 합니다. 여기에는 사용 모드, 세션 매개변수\(예: 보안 연관 식별자\(SAID\) 및 키 수명\), 암호 제품군 및 0단계에서 발견된 보안 관련 기능의 확인을 포함한 필수 필터의 보안 협상이 포함됩니다. 보안 연관 프로토콜은 무결성 및 키 수명을 지원해야 합니다. 모든 능력 협상 메시지의 재생 보호.\(MUST, MUST\)

\(d\) 키 이름 지정 및 선택. 키 캐싱이 지원되는 경우 EAP 피어와 인증자가 특정 유형의 키를 두 개 이상 공유할 수 있습니다. 결과적으로 보안 연결 프로토콜은 소유 증명 교환에 사용되는 키의 이름을 명시적으로 지정해야 합니다. 그래야 둘 이상의 키 자료 세트가 잠재적으로 교환의 기초로 사용될 수 있는 경우 혼란을 방지할 수 있습니다. 섹션 1.4.1에 설명된 키 명명 메커니즘을 사용하는 것이 권장됩니다.\(MUST, SHOULD\)

```text
        In order to support the correct processing of phase 2 security
        associations, the Secure Association (phase 2) protocol MUST
        support the naming of phase 2 security associations and
```

- 주어진 패킷을 처리하기 위해 올바른 임시 세션 키 세트를 식별할 수 있도록 관련 임시 세션 키. 2단계 보안 연관 프로토콜은 또한 임시 세션 키 활성화를 지원해야 하며\(MUST\) 임시 세션 키의 설정 및 재설정이 당사자 간에 동기화될 수 있도록 삭제를 지원해야 합니다\(SHOULD\).\(MUST\)

\(e\) 새로운 임시 세션 키\(TSK\) 생성. 하위 계층이 키 자료 캐싱을 지원하는 경우 EAP 피어 하위 계층은 이전 세션에서 파생된 키 자료를 사용하여 새 세션을 시작할 수 있습니다. TSK가 내보낸 EAP 키 자료의 일부에서만 파생된다면 기본 암호화 제품군이 공격에 노출될 수 있는 세션 키가 재사용되는 결과를 낳게 됩니다.

- 키 자료 캐싱이 지원되는 하위 계층에서는 보안 연결 프로토콜 단계가 필수이며 백엔드 인증 서버에서 제공하는 전송된 키 자료가 신선하지 않은 경우에도 새로운 유니캐스트 및 멀티캐스트 TSK의 파생을 지원해야 합니다. 이는 일반적으로 새로운 유니캐스트\(2a단계\) 세션 키와 멀티캐스트\(2b단계\) 세션 키를 생성하기 위해 키 자료와 혼합되는 nonce 또는 카운터 교환을 통해 지원됩니다. 데이터를 보호하기 위해 내보낸 EAP 키 자료를 직접 사용하지 않음으로써 Secure Association Protocol은 데이터가 손상되지 않도록 보호합니다.\(MUST\)

\(f\) 주요 수명 관리. 여기에는 명시적인 키 수명 협상 또는 원활한 키 재입력이 포함됩니다. EAP는 재인증 없이 EAP 키 자료의 키 재입력을 지원하지 않으며 기존 EAP 방법은 키 수명 협상을 지원하지 않습니다. 결과적으로 Secure Association Protocol은 키 갱신 및 키 수명 결정을 처리할 수 있습니다. 키 캐싱이 지원되는 경우 키 수명에 대한 보안 협상을 권장합니다. 키 재입력을 지원하지만 키 캐싱을 지원하지 않는 하위 계층에는 키 수명 협상이 필요하지 않을 수 있습니다. 예를 들어, IKEv1 \[RFC2409\]과 IKEv2 \[RFC4306\]의 차이점은 IKEv1 SA 수명이 협상되었다는 것입니다. IKEv2에서는 SA의 각 끝이 SA에 대한 자체 수명 정책을 시행하고 필요한 경우 SA 키를 다시 입력하는 일을 담당합니다.\(MAY, SHOULD\)

\(g\) 키 상태 재동기화. 피어나 인증자가 재부팅하거나 리소스를 회수하여 키 캐시의 일부 또는 전부를 지울 수 있습니다. 따라서 키 수명 협상은 키 캐시가 동기화된 상태를 유지한다고 보장할 수 없으며, 피어가 키를 사용하려고 시도하기 전에 키가 인증자 캐시 내에 존재하는지 여부를 확인하는 것이 불가능할 수 있습니다. 따라서 EAP 하위 계층에서 키 상태에 대한 메커니즘을 제공하는 것이 권장됩니다.\(SHOULD\)

- SAP를 통하거나 하위 계층 표시를 사용하는 재동기화\(\[RFC3748\] 섹션 3.4 참조\) 피어와 인증자가 재동기화 교환을 보호할 키를 공동으로 소유하지 않는 경우 보안 재동기화는 불가능하며 적시에 재동기화를 보장하기 위한 대안\(예: 타이머 만료 후 EAP 재인증 시작\)이 필요합니다.

\(h\) 주요 범위 동기화. 키 범위 결정을 지원하기 위해 보안 연결 프로토콜은 피어가 각 인증자의 키 캐시 범위를 결정할 수 있고 인증자가 피어의 키 캐시 범위를 결정할 수 있는 메커니즘을 제공해야 합니다. 여기에는 키 사용에 대한 제한 협상이 포함됩니다.\(SHOULD\)

\(i\) 트래픽 프로필 협상. 하위 계층 보안 연결에 의해 보호되는 트래픽은 EAP 피어 및 인증자와 동일한 하위 계층 소스 또는 대상 주소를 가질 필요가 없으며 피어와 인증자가 각각 하나의 보안 연결을 사용하여 여러 보안 연결을 협상할 수 있습니다. 다른 트래픽 프로필. 이 경우 보호되는 트래픽의 프로필을 명시적으로 협상해야 합니다. 예를 들어, IKEv2에서는 개시자 및 응답자가 인증을 위해 EAP를 사용한 다음 개시자 및 응답자 이외의 호스트에서 발생하는 트래픽 전달을 허용하는 터널 모드 보안 연결\(SA\)을 협상할 수 있습니다. 마찬가지로, IEEE 802.16e에서는 SS\(가입자국\)가 자신이 연결된 LAN\(Local Area Network\)에서 발생하는 BS\(기지국\)로 트래픽을 전달할 수 있습니다. 이를 활성화하기 위해 IEEE 802.16e 내의 보안 연결은 EAP 피어 및 인증자 MAC 주소가 아닌 CID\(연결 식별자\)로 식별됩니다. IKEv2와 IEEE 802.16e 모두에서 EAP 피어와 인증자 사이에는 각각 고유한 트래픽 프로필과 서비스 품질 매개변수가 있는 여러 보안 연결이 존재할 수 있습니다.\(SHOULD\)

\(j\) 직접 운영. 2단계 보안 연결 프로토콜은 임시 세션 키 파생을 포함하여 EAP 피어와 인증자 간의 보안 연결 설정과 관련되므로 해당 당사자만 임시 세션 키를 "알 필요"가 있습니다. 보안 연결 프로토콜은 피어와 인증자 사이에서 직접 작동해야 하며 백엔드 인증 서버를 통과하거나 추가 당사자를 포함해서는 안 됩니다.\(MUST NOT\)

\(k\) 양방향 작동. 일부 암호 제품군에는 양방향 트래픽을 보호하기 위해 단일 임시 세션 키 세트만 필요한 반면, 다른 암호 제품군에는 고유한 임시 세션 키 세트가 필요합니다.

- 각 방향의 임시 세션 키. 2단계 보안 연결 프로토콜은 양방향 2단계 보안 연결을 생성하기 위해 두 개의 별도 2단계 교환이 필요하지 않도록 각 방향에서 유니캐스트 및 멀티캐스트 키의 파생을 제공해야 합니다\(SHOULD\). 자세한 내용은 \[RFC3748\] 섹션 2.4를 참조하세요.\(SHOULD\)

---
### **3.2.  Key Scope**

하위 계층 내에 명시적 사양이 없으면 1b단계가 완료된 후 전송된 키 자료와 매개변수가 EAP 피어 및 인증자에 바인딩되지만 특정 피어 또는 인증자 포트에는 바인딩되지 않습니다.

하위 계층으로 전달된 EAP 키 자료는 본질적으로 특정 인증자 및 피어 포트에 바인딩되지 않지만 TSK는 보안 연관 프로토콜에 의해 특정 인증자 및 피어 포트에 바인딩될 수 있습니다. 그러나 하위 계층은 TSK 신선도가 보장되는 경우\(예: 인증자 내에서 재생 카운터 상태를 유지함으로써\) 여러 피어 및/또는 인증자 포트에서 TSK를 사용하도록 허용할 수도 있습니다.\(MAY, MAY\)

주요 범위를 더욱 제한하기 위해 다음과 같은 조치가 제안됩니다.

\(a\) 하위 계층은 EAP 피어의 EAP 키 자료 및 매개변수 사용을 EAP 대화가 수행된 포트로 제한하는 등 키 사용에 대한 추가 제한을 지정할 수 있습니다.\(MAY\)

\(b\) 백엔드 인증 서버와 인증자는 다음을 수행할 수 있습니다.

- 키 입력 자료의 범위를 더욱 제한하기 위해 추가 속성을 구현합니다. 예를 들어, IEEE 802.11에서 백엔드 인증 서버는 인증된 발신 또는 발신 스테이션 ID 및/또는 키 자료가 유효한 SSID 목록을 인증자에게 제공할 수 있습니다.\(MAY\)

\(c\) 백엔드 인증 서버가 키 범위를 제한하는 속성을 제공하는 경우 인증자가 제한 사항을 피어에 안전하게 전달하는 것이 좋습니다. 이는 Secure Association Protocol을 사용하여 수행할 수 있지만 EAP 방법이나 하위 계층을 통해서도 수행할 수 있습니다.\(SHOULD\)

---
### **3.3.  Parent-Child Relationships**

EAP 재인증이 수행되면 새 EAP 키 자료가 EAP 방법으로 내보내집니다. EAP 재인증으로 인해 결국 TSK 교체가 발생하는 EAP 하위 계층에서는 최대

파생 키 자료\(TSK 포함\)의 수명은 EAP 키 자료\(MSK/EMSK\)의 수명보다 작거나 같을 수 있지만 더 클 수는 없습니다.

TSK가 내보낸 EAP 키 자료에서 파생되거나 포장된 경우, 내보낸 EAP 키 자료의 손상은 TSK의 손상을 의미합니다. 따라서 EAP 키 자료가 오래된 것으로 간주되면 EAP 재인증을 시작해야 할 뿐만 아니라 TSK를 포함한 하위 키를 교체해야 합니다.\(SHOULD\)

EAP 키 자료가 엔터티 인증에만 사용되고 TSK 파생\(IKEv2에서와 같이\)에는 사용되지 않는 경우 내보낸 EAP 키 자료의 손상이 TSK의 손상을 의미하지 않습니다. 그럼에도 불구하고 EAP 키 자료가 손상되면 공격자가 인증자를 가장할 수 있으므로 EAP 재인증 및 TSK 키 재입력을 권장합니다.\(SHOULD\)

IKEv2와 관련하여 \[RFC4718\]의 섹션 5.2, "IKEv2 설명 및 구현 지침"에는 다음과 같이 명시되어 있습니다.

- IKE\_SA 키 재생성과 재인증은 IKEv2에서 다른 개념입니다. IKE\_SA 키를 다시 입력하면 IKE\_SA에 대한 새 키가 설정되고 메시지 ID 카운터가 재설정되지만 당사자를 다시 인증하지는 않습니다\(AUTH 또는 EAP 페이로드는 관련되지 않음\). 즉, 재인증을 통해 IKE\_SA 및 CHILD\_SA에 대한 새 키도 설정된다는 의미입니다. 따라서 키 재생성은 재인증보다 더 자주 수행될 수 있지만 "인증 수명"이 "키 수명"보다 짧은 상황은 의미가 없습니다.

자주 사용되는 하위 키\(예: 트래픽 보호에 사용되는 TSK\)는 종속된 내보낸 EAP 키 자료보다 빨리 만료될 수 있으므로 EAP 키 재설정 전에 하위 키 재설정을 지원하는 것이 유리합니다. 입증. MSK/EMSK를 삭제한다고 해서 반드시 TSK 또는 하위 키가 삭제되는 것은 아닙니다.

Secure Association Protocol 교환 중에 내보낸 EAP 키 자료의 소유를 상호 증명하지 못했다고 해서 양 당사자가 키 자료를 삭제할 근거가 될 필요는 없습니다. 무차별 대입 공격을 방지하기 위해 속도 제한 보안 연관 프로토콜\(Secure Association Protocol\) 교환을 사용할 수 있습니다.

---
### **3.4.  Local Key Lifetimes**

TEK\(임시 EAP 키\)는 EAP 대화를 보호하는 데 사용되는 세션 키입니다. TEK는 EAP 방법 내부에 있으며 내보내지지 않습니다. TEK는 일반적으로 EAP 대화 중에 생성되며 대화가 끝날 때까지 사용된 후 삭제됩니다. 그러나 EAP 대화 중에 메서드를 통해 TEK를 다시 입력할 수 있습니다.

EAP 대화 내에서 또는 여러 대화에서 TEK를 사용하는 경우 재생 보호 및 키 분리 요구 사항이 충족되는지 확인해야 합니다. 예를 들어, 재생 카운터가 사용되는 경우 TEK 키 재설정은 카운터를 래핑하기 전에 발생해야 합니다. 마찬가지로 TSK 키 재설정 또는 캐싱에도 불구하고 TSK는 TEK와 암호화 방식으로 분리되어 있어야 합니다. 이는 TEK 손상이 TSK 손상으로 직접 이어지는 것을 방지하며 그 반대의 경우도 마찬가지입니다.\(MUST, MUST\)

EAP 방법은 빠른 재연결이 사용될 때 여러 EAP 대화에 대해 지속될 수 있는 로컬 EAP 키 자료\(TEK\)를 캐시할 수 있습니다\[RFC3748\]. 예를 들어 TLS\(예: EAP-TLS \[RFC5216\]\) 기반의 EAP 방법은 일반적으로 상당한 기간 동안 TLS 마스터 비밀을 파생하고 캐시합니다. EAP 방법 내에서 계산된 다른 로컬 EAP 키 자료의 수명은 해당 방법에 의해 정의됩니다. 일반적으로 빠른 재연결을 사용할 때 원래의 장기 자격 증명이 여전히 피어의 소유라는 보장은 없습니다. 예를 들어 EAP-TLS용 개인 키가 들어 있는 스마트 카드가 제거되었을 수 있습니다. EAP 서버는 또한 원래 인증에 사용된 인증서가 아직 만료되지 않았는지 확인하는 등 장기 자격 증명이 여전히 유효한지 확인해야 합니다.\(MAY, SHOULD\)

---
### **3.5.  Exported and Calculated Key Lifetimes**

EAP 피어, 서버 및 인증자 간에 키 자료의 수명을 통신하는 데 다음 메커니즘을 사용할 수 있습니다.

```text
      AAA protocols  (backend authentication server and authenticator)
      Lower-layer mechanisms (authenticator and peer)
      EAP method-specific negotiation (peer and server)
```

EAP 방법이 내보낸 EAP 키 자료의 수명 협상을 지원하지 않고 키 수명 협상 메커니즘이 하위 계층에서 제공되지 않는 경우 피어가 키 자료의 수명을 알 수 있는 방법이 없을 가능성이 있습니다. 키링 재료. 이로 인해 피어는 인증자가 키 캐시 내에 키 자료를 얼마나 오랫동안 유지할 것인지 확신할 수 없게 될 수 있습니다. 이 경우 키 자료의 수명은 피어 및 인증자에 대한 시스템 매개변수로 관리될 수 있습니다. 기본 수명은 8시간이 권장됩니다.\(SHOULD\)

---
#### **3.5.1.  AAA Protocols**

RADIUS \[RFC2865\] 및 Diameter \[RFC4072\]와 같은 AAA 프로토콜을 사용하여 백엔드 인증 서버에서 인증자에게 최대 키 수명을 전달할 수 있습니다.

Session-Timeout 속성은 \[RFC2865\]의 RADIUS와 \[RFC4005\]의 Diameter에 대해 정의됩니다. EAP가 인증에 사용되는 경우 \[RFC3580\] 섹션 3.17은 RADIUS-요청의 종료 작업 값과 함께 Access-Accept로 전송된 세션 시간 초과 속성이 EAP 응답 이전에 제공되는 서비스의 최대 시간\(초\)을 지정함을 나타냅니다. -입증.

그러나 캐시된 키 자료의 최대 수명을 지정할 수 있어야 할 필요성도 있습니다. EAP 사전 인증이 지원되는 경우 캐시된 키 자료는 세션 시작 전에 인증자에 사전 설정될 수 있으며 만료될 때까지 그대로 유지됩니다. 키 자료 캐싱을 지원하는 EAP 하위 계층은 세션이 끝난 후에도 해당 자료를 유지할 수 있으므로 피어가 캐시된 키 자료를 활용하여 이후에 통신을 재개할 수 있습니다. 이러한 상황에서는 백엔드 인증 서버가 캐시된 키 자료의 최대 수명을 지정하는 것이 바람직할 수 있습니다.\(MAY\)

이를 달성하기 위해 \[IEEE-802.11\]은 전송된 키 자료가 캐시되었는지 여부에 관계없이 전송된 키 자료가 인증자에서 만료되는 최대 시간을 나타내는 것으로 가정하여 세션 시간 초과 속성을 오버로드합니다.

전송된 키 자료를 수신하는 IEEE 802.11 인증자는 타이머를 세션 시간 초과 값으로 초기화해야 하며, 타이머가 만료되면 전송된 키 자료도 만료됩니다. 이로 인해 세션이 종료되는지 또는 EAP 재인증이 발생하는지 여부는 Termination-Action 속성 값에 의해 제어됩니다. EAP 재인증이 발생하면 전송된 키 자료가 교체되고 이를 통해 새로 계산된 키가 제자리에 배치됩니다. 세션 종료가 발생하면 전송 및 파생된 키 자료가 삭제됩니다.

Session-Timeout 속성을 오버로드하는 것은 최대 세션 시간과 키 수명을 독립적으로 제어해야 하는 상황에서 문제가 됩니다. 예를 들어, 일단 인증된 사용자가 재인증 없이 최대 1시간 동안 연결을 유지하도록 허용하면서 캐시된 키 자료의 수명을 5분으로 제한하는 것이 바람직할 수 있습니다. 결과적으로 향후에는 캐시된 키의 수명을 제어하기 위해 추가 속성을 지정할 수 있습니다. 이러한 속성은 특정 상황에서 Session-Timeout 속성의 의미를 수정할 수 있습니다.\(MAY\)

TSK 수명은 인증자 리소스에 의해 결정되는 경우가 많고 백엔드 인증 서버는 암호 모음 독립성 원칙에 따라 TSK 파생 프로세스에 대한 통찰력이 없으므로 백엔드 인증 서버가 TSK 파생 프로세스의 모든 측면을 관리하는 것은 적절하지 않습니다. TSK 수명을 포함합니다.

---
#### **3.5.2.  Lower-Layer Mechanisms**

하위 계층 메커니즘을 사용하면 피어와 인증자 간에 키 자료의 수명을 협상할 수 있습니다. 이는 Secure Association Protocol을 사용하거나 하위 계층 전송 내에서 수행할 수 있습니다.

보안 연결 프로토콜\(Secure Association Protocol\) 교환의 결과로 TSK가 설정된 경우 보안 연결 프로토콜에 TSK 키 재설정에 대한 지원이 포함되도록 권장됩니다. TSK를 MSK에서 직접 가져오는 경우에는 TSK 수명과 MSK 수명이 동일하므로 TSK 수명을 별도의 매개변수로 관리할 필요가 없습니다.\(SHOULD\)

---
#### **3.5.3.  EAP Method-Specific Negotiation**

\[RFC3748\] 섹션 7.10에 명시된 대로:

- 이후 협상된 암호 모음에 사용할 키 자료를 제공하려면 키 파생을 지원하는 EAP 방법은 최소 64옥텟의 MSK\(마스터 세션 키\)와 최소 64옥텟의 EMSK\(확장 마스터 세션 키\)를 내보내야 합니다. . EAP 메서드 파생 키는 EAP 피어와 EAP 서버 간의 상호 인증을 제공해야 합니다.\(MUST, MUST\)

그러나 EAP는 MSK, EMSK 및 IV와 같이 내보낸 EAP 키 자료의 수명 협상을 자체적으로 지원하지 않습니다.

EAP 자체는 수명 협상을 지원하지 않지만 이를 지원하는 방법을 지정하는 것은 가능합니다. 그러나 EAP 방법 내에서 주요 수명 협상에 의존하는 시스템은 이러한 방법을 통해서만 작동합니다. 또한 EAP 방법 내에서 협상된 키 수명이 백엔드 인증 서버 정책과 호환된다는 보장도 없습니다. 방법 독립성과 백엔드 인증 서버 구현과의 호환성을 위해 키 자료의 수명 관리는 EAP 방법 내에서 제공되어서는 안 됩니다.\(SHOULD NOT\)

---
### **3.6.  Key Cache Synchronization**

키 수명 협상만으로는 키 캐시 동기화를 보장할 수 없습니다. 키 자료의 수명을 결정하기 위해 EAP 직후 하위 계층 교환이 실행되는 경우에도 인증자가 키 캐시의 전체 또는 일부를 조기에 제거할 수 있습니다\(예: 재부팅 또는 메모리 회수 필요로 인해\). \).

하위 계층은 Discovery 단계 0을 활용하여 키 캐시 동기화를 향상시킬 수 있습니다. 예를 들어, 인증자가 가장 오래된 키를 먼저 삭제하여 키 캐시를 관리하는 경우 삭제할 마지막 키의 상대적 생성 시간이 검색 단계 내에서 알려질 수 있으며, 이를 통해 피어는 키 입력 자료가 키 입력 자료에서 조기에 만료되었는지 여부를 확인할 수 있습니다. 인증자 키 캐시.

---
### **3.7.  Key Strength**

섹션 2.1에서 언급했듯이 EAP 하위 계층은 TSK를 다른 방식으로 결정합니다. 내보낸 EAP 키 자료가 TSK의 파생, 암호화 또는 인증에 활용되는 경우 EAP 키 생성이 가장 약한 링크를 나타낼 수 있습니다.

적절한 대칭 키 강도의 EAP 키 자료를 생성하는 방법을 보장하려면 공개 키 암호화를 활용하는 EAP 방법에서 필요한 수준의 공격 저항을 제공하는 암호화 강도를 가진 공개 키를 선택하는 것이 좋습니다. 이는 일반적으로 EAP 방법을 구성하여 제공됩니다. 왜냐하면 최소 필수 대칭 키 강도와 관련하여 하위 계층과 EAP 방법 간에 조정이 없기 때문입니다.\(SHOULD\)

BCP 86 \[RFC3766\]의 섹션 5에서는 주어진 공격 저항 수준\(비트\)에 대해 필요한 RSA 또는 DH 모듈과 DSA 하위 그룹 크기\(비트\)에 대한 조언을 제공합니다. NIST\(National Institute for Standards and Technology\)는 \[SP800-57\]에서 적절한 키 크기에 대한 조언도 제공합니다.

---
### **3.8.  Key Wrap**

MD5 기반 스트림 암호를 기반으로 하는 \[RFC2548\]에 지정된 키 랩에는 \[RFC3579\] 섹션 4.3에 설명된 대로 알려진 문제가 있습니다. RADIUS는 패킷별 인증 및 속성 숨기기를 포함하여 여러 목적으로 공유 비밀을 사용하며 각 패킷과 함께 공유 비밀에 대한 상당한 정보가 노출됩니다. 이로 인해 공유 비밀이 사전 공격에 노출됩니다. MD5는 RADIUS 응답 인증자와 메시지 인증자 속성을 계산하는 데 사용되며 이 해시\[MD5Collision\]의 보안과 관련된 우려가 있습니다.

\[RFC3579\] 섹션 4.3에서 설명한 것처럼 RADIUS의 보안 취약성은 광범위하므로 RADIUS 공유 비밀을 기반으로 하는 대체 키 래핑 기술을 개발해도 보안이 크게 향상되지는 않습니다. 결과적으로 \[RFC3579\] 섹션 4.2에서는 IPsec을 통해 RADIUS를 실행할 것을 권장합니다. 동일한 접근 방식이 4.1.3절에서 EAP-마스터-세션-키 속성-값 쌍\(AVP\)을 일반 텍스트로 정의하여 IPsec 또는 TLS로 보호되는 Diameter EAP \[RFC4072\]에서도 사용됩니다.

---
## **4.  Handoff Vulnerabilities**

EAP 피어가 새 인증자로 이동하면 핸드오프가 발생합니다. EAP를 활용하는 네트워크 내에서 핸드오프 대기 시간을 줄이기 위한 여러 메커니즘이 제안되었습니다. 여기에는 다음이 포함됩니다.

EAP 사전 인증

- EAP 사전 인증에서는 EAP 피어가 도착하기 전에 인증자와 함께 EAP 키 자료를 사전 설정합니다. EAP 사전 인증은 EAP 인증 시점에만 영향을 미치며 EAP\(1a단계\) 또는 AAA\(1b단계\) 교환을 단축하거나 제거하지 않습니다. 검색\(0단계\) 및 보안 연결 프로토콜\(2단계\) 교환은 섹션 1.3에 설명된 대로 발생합니다. 결과적으로 주요 이점은 핸드오프 중요 경로에서 EAP 인증을 제거하여 대기 시간을 줄이는 것입니다. IEEE 802.11 내에서 EAP 사전 인증 사용은 \[IEEE-802.11\] 및 \[8021XPreAuth\]에 설명되어 있습니다.

사전 키 배포

- 사전 대응 키 배포에서는 핸드오프에 앞서 키 자료 및 인증이 백엔드 인증 서버에서 후보 인증자에게 전송됩니다. 결과적으로 EAP\(1a단계\)는 필요하지 않지만 Discovery\(0단계\) 및 Secure Association Protocol 교환\(2단계\)은 여전히 ​​필요합니다. AAA 교환\(1b단계\) 내에서는 일반적으로 승인 및 키 배포 기능이 지원되지만 인증은 지원되지 않습니다. 사전 키 배포는 \[MishraPro\], \[IEEE-03-084\] 및 \[HANDOFF\]에 설명되어 있습니다.

키 캐싱

- EAP 키 자료를 캐싱하면 EAP 피어가 EAP\(1a단계\) 또는 AAA\(1b단계\) 교환을 요구하지 않고 인증자에 다시 연결할 수 있습니다. 그러나 Discovery\(0단계\) 및 Secure Association Protocol\(2단계\) 교환은 여전히 ​​필요합니다. IEEE 802.11 내에서 키 캐싱 사용은 \[IEEE-802.11\]에 설명되어 있습니다.

컨텍스트 전송

- 컨텍스트 전송 방식에서는 키 자료 및 권한 부여가 이전 인증자와 새 인증자 간에 전송됩니다. 이는 EAP 피어의 핸드오프 요청에 대한 응답으로 또는 사전 키 배포와 같이 사전에 발생할 수 있습니다. 결과적으로 EAP\(1a단계\)는 제거되지만 Discovery\(0단계\) 또는 Secure Association Protocol 교환\(2단계\)은 제거되지 않습니다. 백엔드 인증 서버의 도움 없이 새 인증자와 이전 인증자 간에 보안 채널을 설정할 수 있는 경우 AAA 교환\(1b단계\)이 제거될 수 있습니다. 그렇지 않으면 단축될 수 있지만 여전히 필요합니다. 컨텍스트 전송 프로토콜은 \[IEEE-802.11F\]\(현재 더 이상 사용되지 않음\) 및 "컨텍스트 전송 프로토콜\(CXTP\)" \[RFC4067\]에 설명되어 있습니다. "IEEE 802.11 무선 LAN 간의 핸드오버를 위한 빠른 인증 방법"\[Bargh\]은 컨텍스트 전송 메커니즘을 포함한 빠른 핸드오프 기술을 분석합니다.

토큰 분배

- 토큰 배포 방식에서는 EAP 피어에 자격 증명이 제공되어 이후에 하나 이상의 추가 인증자를 통해 인증할 수 있습니다. 후속 인증 중에는 EAP\(1a단계\)가 제거되거나 단축됩니다. Discovery\(0단계\) 및 Secure Association Protocol 교환\(2단계\)은 여전히 ​​발생하지만 후자는 단축될 수 있습니다. 토큰에 권한 부여가 포함되어 있고 백엔드 인증 서버의 지원 없이 인증자가 검증할 수 있는 경우 AAA 교환\(1b단계\)이 제거될 수 있습니다. 그렇지 않으면 단축될 수 있지만 여전히 필요합니다. IEEE 802.11i \[IEEE-802.11i\]의 초기 버전에서 처음 제안된 토큰 기반 방식은 \[Token\], \[Tokenk\] 및 \[SHORT-TERM\]에 설명되어 있습니다.

다음 섹션에서는 위의 체계로 인해 발생하는 보안 취약점에 대해 설명합니다.

---
### **4.1.  EAP Pre-Authentication**

EAP 사전 인증은 주로 하위 계층 캡슐화 측면에서 일반 EAP 대화와 다릅니다. 예를 들어, \[IEEE-802.11\]에서 EAP 사전 인증 프레임은 고유한 Ethertype을 사용하지만 그 외에는 \[IEEE-802.1X\]에 설명된 캡슐화를 따릅니다. 결과적으로 EAP 사전 인증 대화는 1단계와 2단계 사이에 지연이 도입된다는 점을 제외하면 섹션 1.3에 설명된 모델과 거의 다르지 않습니다.

EAP 사전 인증은 후보 인증자를 검색하기 위해 하위 계층 메커니즘을 사용합니다. 발견이 즉각적인 청취 범위 밖에 있는 후보 인증자에 대한 정보를 제공할 수 있고 피어가 이미 후보 인증자와 함께 유효한 EAP 키 자료를 보유하고 있는지 여부를 결정할 수 있는 경우, 피어는 불필요한 EAP 사전 인증을 피할 수 있으며 사전에 EAP 키 자료를 설정할 수 있습니다. 인증자 간의 적용 범위가 겹치는 것과 관계없이. 그러나 피어가 청취 범위 내에서만 후보 인증자를 발견할 수 있고 기존 EAP 키 자료를 재사용할 수 있는지 여부를 결정할 수 없는 경우 피어는 연결이 끊어지기 전에 EAP 사전 인증을 완료하지 못하거나 다음 작업을 수행할 수 없을 가능성이 있습니다. 동일한 인증자로 여러 번 사전 인증을 수행하므로 백엔드 인증 서버 부하가 늘어납니다.

피어는 최종적으로 연결하지 않고도 인증자를 사용하여 EAP 사전 인증을 완료할 수 있으므로 2단계가 발생하지 않을 가능성이 있습니다. 이 경우 서비스 시작을 알리는 Accounting-Request는 전송되지 않거나, 인증 완료 후 상당한 지연 후에만 전송됩니다.

"IEEE 802.1X RADIUS 사용 지침" \[RFC3580\]에 명시된 바와 같이 EAP 사전 인증으로 인한 AAA 교환은 "EAP에 대한 RADIUS 지원" \[RFC3579\]에 설명된 일반 교환과 거의 다르지 않습니다. 예를 들어 IEEE 802.11 \[IEEE-802.11\]에서는 EAP 사전 인증 이전에 연관 교환이 발생하지 않으므로 인증 시 인증자가 SSID를 알 수 없으므로 액세스 요청은 호출된 SSID 내에 SSID를 포함할 수 없습니다. - \[RFC3580\] 섹션 3.20에 설명된 Station-Id 속성.

Called-Station-Id 속성에 SSID가 없는 것만이 EAP 사전 인증 시도를 구별하므로, 인증자가 일반 EAP 인증 시도에 SSID를 항상 포함하지 않는 경우 백엔드 인증 서버가 인증되지 않을 수 있습니다. 세션이 EAP 사전 인증 시도로 구성되어 잠재적으로 승인 또는 계정 문제가 발생할 수 있는지 여부를 확인할 수 있습니다. 동시 세션 수가 제한된 경우 백엔드 인증 서버는 유효한 EAP 사전 인증 시도 승인을 거부하거나 피어가 승인된 것보다 더 많은 동시 세션에 참여하도록 할 수 있습니다. 피어가 연결되지 않은 인증자를 통해 EAP 사전 인증이 발생하는 경우 백엔드 계정 서버는 계정 요청 부재가 패킷 손실로 인한 것인지 또는 시작되지 않은 세션으로 인한 것인지 여부를 판단하지 못할 수도 있습니다.

사전 인증 요청을 보다 안정적으로 처리하려면 AAA 프로토콜이 EAP 사전 인증을 명시적으로 식별하는 것이 좋습니다. 불필요한 EAP 사전 인증 교환을 억제하려면 섹션 2.3에 설명된 대로 인증자가 자신을 명확하게 식별하는 것이 좋습니다.\(SHOULD, SHOULD\)

---
### **4.2.  Proactive Key Distribution**

사전 키 배포 체계에서 백엔드 인증 서버는 피어가 도착하기 전에 키 자료와 인증을 인증자에게 전송합니다. 전송된 키 자료를 수신하기 위해 선택된 인증자는 "이웃 그래프"로 알려진 인증자 간 피어 이동의 과거 패턴을 기반으로 선택됩니다. 핸드오프 대기 시간을 줄이기 위해 사전 예방적 키 배포 체계는 일반적으로 EAP 피어와 인증자 간에 전송된 키 자료의 소유 증명만 보여줍니다. 핸드오프 중에 백엔드 인증 서버에는 피어가 인증자에게 성공적으로 인증되었다는 증거가 제공되지 않습니다. 대신, 인증자는 해당 인증 교환 세트 없이 계정 메시지 스트림을 생성합니다. \[MishraPro\]에 설명된 대로 이웃 그래프에 대한 지식은 인증 교환의 정적 구성 또는 분석을 통해 확립될 수 있습니다. \~ 안에

이웃 그래프의 손상을 방지하기 위해 새로운 이웃 그래프 항목은 성공적인 EAP 교환의 결과로만 생성될 수 있으며, 해당 인증 교환이 없는 어카운팅 패킷은 이웃 그래프 항목\(예: 핸드오프에 해당\)에 해당하는지 확인해야 합니다. 이웃 사이\).

한 인증자의 손상으로 인해 다른 인증자가 손상되는 것을 방지하려면 각 인증자에게 전송되는 키 자료 간에 암호화 분리가 유지되어야 합니다. 그러나 암호화 분리가 유지되는 경우에도 인증자를 손상시키는 공격자는 여전히 다른 인증자의 작업을 방해할 수 있습니다. \[RFC3579\] 섹션 4.3.7에 명시된 대로 AAA 인프라 내에 스푸핑 탐지가 없으면 EAP 인증자가 서로를 가장할 수 있습니다. 인증 메시지 내에서 NAS 식별 속성을 위조함으로써 하나의 인증자를 손상시키는 공격자는 인접 그래프를 손상시켜 백엔드 인증 서버를 속여 키 자료를 임의의 인증자에게 전송하도록 할 수 있습니다. 이는 기본적인 암호화 가정을 위반하지 않고 EAP 키 자료를 복구할 수는 없지만 후속 사기 계정 메시지를 활성화하거나 공격자가 백엔드 인증 서버의 로드를 늘리거나 인증자 키 캐시를 스래싱하여 서비스를 중단시킬 수 있습니다.

사전 키 배포에는 파생 키 자료를 후보 인증자에게 배포해야 하므로 이 체계의 효율성은 EAP 피어의 이동을 예측하는 백엔드 인증 서버의 능력에 따라 달라집니다. 사전 키 배포는 인접 그래프에 대한 백엔드 인증 서버 지식에 의존하므로 도메인 내 핸드오프 시나리오에 가장 적합합니다. 그러나 인증자가 많을 수 있는 도메인 간 핸드오프에서는 피어가 이전에 접하지 않은 인증자에 자주 연결할 수 있으므로 백엔드 인증 서버가 완전한 이웃 그래프를 도출하기가 어렵습니다.

사전 키 배포 방식은 일반적으로 \[RFC5176\] 및 \[HANDOFF\]에 설명된 대로 서버 시작 메시지의 도입을 요구하므로 \[RFC5176\] 섹션 6에 설명된 보안 문제\(인증\(Section 6.1\) 및 재생 감지\(Section 6.3\) 문제를 포함하여 적용 가능\) .

---
### **4.3.  AAA Bypass**

AAA 교환\(1b단계\)을 제거할 수 있는 빠른 핸드오프 기술은 제공되는 서비스에 대한 인증은 물론 사용자 인증을 포함하는 일반적인 네트워크 액세스 시나리오\(전화 접속, 유선 LAN 등\)와 근본적으로 다릅니다. AAA 교환\(1b단계\)이 생략된 경우 백엔드 인증 서버에서 인증 및 키 자료를 제공하지 않으므로 다른 수단을 통해 제공해야 합니다. 이 섹션에서는 몇 가지 의미를 설명합니다.

---
#### **4.3.1.  Key Transport**

전송된 키 자료가 백엔드 인증 서버에서 제공되지 않는 경우 해당 키 자료에 액세스할 권한이 있는 다른 당사자가 이를 제공해야 합니다. 섹션 1.5에 명시된 대로 EAP 피어, 인증자 및 서버만이 전송된 키 자료를 소유할 권한이 있습니다. EAP 피어는 서로를 신뢰하지 않기 때문에 백엔드 인증 서버가 전송된 키 자료를 새 인증자에게 제공하지 않는 경우 이전 인증자에 의해서만 제공될 수 있습니다.

섹션 1.5에서 설명한 대로 EAP 대화의 목표는 피어와 인증자에게만 알려진 세션 키를 파생시키는 것입니다. 이전 인증자와 새 인증자 간에 키 자료가 복제되면 이전 인증자는 피어와 새 인증자 간에 사용되는 세션 키를 소유할 수 있습니다. 또한 새 인증자는 피어와 이전 인증자 간에 사용되는 세션 키를 소유할 수 있습니다.

단방향 기능을 사용하여 새 인증자에게 전송될 키 자료를 파생하는 경우 새 인증자는 기본적인 암호화 가정을 위반하지 않고는 이전 세션 키를 소유할 수 없습니다.

---
#### **4.3.2.  Authorization**

인증 프로세스의 일부로 백엔드 인증 서버는 사용자의 인증 프로필을 결정하고 전송된 키 자료와 함께 인증을 인증자에게 전송합니다. 일반적으로 프로필은 사용자 ID를 기반으로 결정되지만 사용자가 제시한 인증서도 인증 정보를 제공할 수 있습니다.

백엔드 인증 서버는 다음 질문에 답해야 하는 사용자 권한 부여 결정을 내리는 역할을 담당합니다.

\(a\) 이 사람이 이 네트워크의 합법적인 사용자입니까?

\(b\) 사용자가 이 네트워크에 액세스할 수 있습니까?

\(c\) 사용자가 이날과 이 시간에 이 네트워크에 액세스하는 것이 허용됩니까?

\(d\) 사용자가 동시 세션 제한 내에 있습니까?

\(e\) 액세스 거부로 이어질 수 있는 사기, 신용 한도 또는 기타 문제가 있습니까?

\(f\) 액세스가 허용되는 경우 사용자에게 제공할 서비스 매개변수\(필수 터널링, 대역폭, 필터 등\)는 무엇입니까?

권한 부여 결정은 원칙적으로 간단하지만 분산된 의사 결정 프로세스는 복잡성을 더할 수 있습니다. 브로커나 프록시가 관련된 경우 인증자부터 홈 백엔드 인증 서버까지 체인의 모든 AAA 엔터티가 결정에 참여합니다. 예를 들어, 홈 백엔드 인증 서버가 액세스를 허용하더라도 브로커는 액세스를 거부할 수 있고, 프록시는 인증\(예: 대역폭 제한\)을 추가할 수 있습니다.

결정은 정적 정책 정의 및 프로필은 물론 동적 상태\(예: 시간 또는 동시 세션 제한\)를 기반으로 이루어질 수 있습니다. AAA 엔터티의 승인/거부 결정 외에도 서비스 매개변수 또는 제약 조건이 인증자에게 전달될 수 있습니다.

승인/거부 결정 기준이나 특정 인증을 선택하는 이유는 일반적으로 인증자에게 전달되지 않으며 최종 결과만 전달됩니다. 결과적으로 인증자는 결정의 근거가 무엇인지 알 수 없습니다. 이 서비스가 항상 사용자에게 제공되기 때문에 일련의 인증 매개변수가 전송되었습니까? 아니면 시간과 인증자의 기능을 기반으로 결정되었습니까?

---
#### **4.3.3.  Correctness**

AAA 교환\(1b단계\)이 우회되면 올바른 인증을 보장하는 데 몇 가지 문제가 발생합니다.

서비스 도용

- AAA 교환\(1b단계\)을 우회하면 사용자가 네트워크 액세스를 확장하거나 자격이 없는 서비스에 액세스할 수 있어서는 안 됩니다.\(SHOULD NOT\)

네트워크 전체 상태 고려

- 핸드오프 기술은 백엔드 인증 서버가 네트워크 전체 상태를 추적할 수 없도록 렌더링해서는 안 됩니다. 예를 들어 백엔드 인증 서버는 동시 사용자 세션을 추적해야 할 수 있습니다.\(SHOULD NOT\)

권한 승격

- 백엔드 인증 서버는 종종 조건부 평가를 수행합니다. 여기서 액세스 승인 메시지로 반환된 인증은 인증자 또는 시간과 같은 동적 상태에 따라 달라집니다. 이 상황에서 AAA 교환을 우회하면 백엔드 인증 서버에서 제공하는 인증 내에서 제한 사항이 명시적으로 인코딩되지 않는 한 무단 액세스가 가능해질 수 있습니다.

적절한 인증을 제공하는 핸드오프 메커니즘을 "정확하다"고 합니다. 정확성의 한 가지 조건은 다음과 같습니다.

- 핸드오프가 "정확"하려면 새 인증자가 백엔드 인증 서버와 AAA 대화를 완료한 경우 생성되었을 것과 동일한 인증을 새 인증자에 설정해야 합니다.\(MUST\)

적절하게 설계된 핸드오프 방식은 이러한 방식으로 "올바른" 경우에만 성공합니다. 성공적인 핸드오프로 인해 "잘못된" 인증이 설정되면 실패하는 것이 좋습니다. 지원되는 서비스가 인증자마다 다른 경우 백엔드 인증 서버를 우회하는 핸드오프가 실패할 가능성이 높습니다. \[RFC2865\]의 섹션 1.1에는 다음과 같이 명시되어 있습니다.

- 주어진 서비스를 구현하지 않는 인증자는 해당 서비스에 대한 RADIUS 속성을 구현해서는 안 됩니다. 예를 들어, ARAP 서비스를 제공할 수 없는 인증자는 ARAP에 대한 RADIUS 속성을 구현해서는 안 됩니다. 인증자는 대신 사용할 수 없는 서비스를 액세스 거부로 승인하는 RADIUS 액세스 허용을 처리해야 합니다.\(MUST NOT, MUST NOT, MUST\)

이 동작은 알려져 있지만 구현되지 않은 속성에 적용됩니다. 알 수 없는 속성의 경우 \[RFC2865\]의 섹션 5에는 다음과 같이 명시되어 있습니다.

- RADIUS 서버는 유형을 알 수 없는 속성을 무시할 수 있습니다. RADIUS 클라이언트는 유형을 알 수 없는 속성을 무시할 수 있습니다.\(MAY, MAY\)

올바른 핸드오프를 수행하기 위해, 새로운 인증자가 알려졌으나 사용할 수 없는 서비스에 대한 RADIUS 인증을 제공받는 경우, 사용할 수 없는 서비스를 요청하는 RADIUS 액세스 허용을 처리하는 것과 동일한 방식으로 이러한 인증을 처리해야 합니다.\(MUST\)

서비스; 이로 인해 핸드오프가 실패해야 합니다. 그러나 새로운 인증자가 알 수 없는 속성을 포함한 인증과 함께 제공되면 이러한 속성은 무시될 수 있습니다. "알려졌지만 지원되지 않는 서비스"의 정의는 사용할 수 없는 보안 서비스에 대한 요청을 포함해야 합니다. 여기에는 \[RFC2548\]에 설명된 것과 같은 보안과 관련된 공급업체별 속성이 포함됩니다. 다소 반직관적으로 보일 수 있지만, 알려졌지만 지원되지 않는 서비스가 요청된 경우 실패는 실제로 "올바른" 결과입니다.\(MUST, MAY, MUST\)

아마도 올바르게 구성된 백엔드 인증 서버는 인증자가 구현하지 않은 서비스를 제공하도록 요청하지 않을 것입니다. 이는 새 인증자가 AAA 대화를 완료하면 다른 서비스 지침을 받을 가능성이 있음을 의미합니다. 핸드오프가 실패하면 새 인증자가 적절한 서비스 정의를 받기 위해 백엔드 서버로 돌아가게 되므로 바람직한 결과입니다.

백엔드 인증 서버를 우회하는 핸드오프 메커니즘은 단일 관리 도메인 내의 동종 배포에 사용될 때 성공할 가능성이 가장 높습니다. 이기종 배포에서 백엔드 인증 서버는 요청한 서비스가 인증자 기능과 일치하는지 확인하기 위해 요청하는 인증자에 따라 다른 인증을 반환할 수 있습니다. 백엔드 인증 서버가 이전 인증자에게 보낸 것과 다른 인증을 새 인증자에게 보내는 경우 이전 인증자와 새 인증자 간에 권한을 전송하면 잘못된 인증이 발생합니다.

가상 LAN\(VLAN\) 지원은 \[IEEE-802.1Q\]에 정의되어 있습니다. 동적 VLAN에 대한 RADIUS 지원은 \[RFC3580\] 및 \[RFC4675\]에 설명되어 있습니다. 일부 인증자가 동적 VLAN을 지원하는 반면 다른 인증자는 지원하지 않는 경우 액세스 요청에 있는 속성\(예: NAS 포트 유형, NAS-IP 주소, NAS-IPv6-주소 및 NAS 식별자\)을 다음을 통해 검사할 수 있습니다. 백엔드 인증 서버를 사용하여 VLAN 속성이 반환되는 시기와 반환되는 경우 어느 속성을 결정합니다. 그러나 백엔드 인증자가 우회되면 서로 다른 VLAN 기능을 지원하는 인증자 간에 핸드오프가 발생하여 사용자가 승인되지 않은 VLAN에 액세스할 수 있습니다\(예: 게스트 VLAN에 액세스할 수 있는 사용자에게 네트워크에 대한 무제한 액세스가 제공됨\).

마찬가지로, 기밀성을 제공하는 인증자와 실패하지 않는 다른 인증자 간의 핸드오프가 바람직합니다. 왜냐하면 핸드오프가 성공하면 사용자가 백엔드 인증 서버의 허가 없이 보안 채널에서 비보안 채널로 이동하게 되기 때문입니다.

---
## **5.  Security Considerations**

EAP 위협 모델은 \[RFC3748\] 섹션 7.1에 설명되어 있습니다. EAP 방법의 보안 속성\("보안 클레임"이라고도 함\)은 \[RFC3748\] 섹션 7.2.1에 설명되어 있습니다. 무선 LAN 인증과 같은 애플리케이션에 대한 EAP 방법 요구 사항은 \[RFC4017\]에 설명되어 있습니다. RADIUS 위협 모델은 \[RFC3579\] 섹션 4.1에 설명되어 있으며 이러한 위협에 대한 대응은 \[RFC3579\] 섹션 4.2 및 4.3에 설명되어 있습니다.

그러나 EAP 및 AAA에 대한 위협 외에도 다른 시스템 수준 위협도 있습니다. 위협 모델을 개발할 때 다음을 가정합니다.

공격자는 모든 트래픽을 볼 수 있습니다.

- 공격자는 메시지를 변경, 위조, 재생할 수 있습니다. 공격자는 메시지를 다른 주체에게 다시 라우팅할 수 있습니다. 공격자는 주체일 수도 있고 외부인일 수도 있습니다. 공격자는 충분히 오래된 키라면 무엇이든 손상시킬 수 있습니다.

이러한 가정으로 인해 발생하는 위협은 다음과 같습니다.

\(a\) 공격자는 EAP 피어를 손상시키거나 훔칠 수 있습니다.

- 다른 EAP 피어 또는 인증자에 대한 액세스 권한을 얻거나 장기 비밀을 얻으려는 시도의 인증자.

\(b\) 공격자는 인증 방법이나 암호화 알고리즘의 알려진 약점을 이용하기 위해 다운그레이드 공격을 시도할 수 있습니다.

\(c\) 공격자는 Discovery 또는 Secure Association Protocol 프레임, EAP 또는 AAA 패킷을 포함한 패킷을 수정하거나 스푸핑하려고 시도할 수 있습니다.

\(d\) 공격자는 EAP 피어, 인증자 또는 서버가 키 자료를 무단 당사자에게 공개하도록 유도하거나 의도된 컨텍스트 외부에서 키 자료를 활용하려고 시도할 수 있습니다.

\(e\) 공격자는 패킷을 변경, 위조 또는 재생할 수 있습니다.

\(f\) 공격자는 EAP 피어, 인증자 또는 서버가 오래된 키를 재사용하도록 만들 수 있습니다. 오래된 키의 사용이 의도치 않게 발생할 수도 있습니다. 예를 들어, 제대로 구현되지 않은 백엔드 인증 서버는 인증자에게 오래된 키 자료를 제공할 수 있고, 잘못 구현된 인증자는 nonce를 재사용할 수 있습니다.

\(g\) 인증된 공격자는 권한이 없는 정보에 접근하기 위해 상승된 권한을 얻으려고 시도할 수 있습니다.

\(h\) 공격자는 네트워크에 접근하기 위해 중간자 공격을 시도할 수 있습니다.

\(i\) 공격자는 사기 행위를 시도하기 위해 EAP 인증자를 손상시킬 수 있습니다. 예를 들어 손상된 인증자는 대역 외 메커니즘\(예: AAA 또는 하위 계층 프로토콜\)을 통해 EAP 피어 및/또는 서버에 잘못된 정보를 제공할 수 있습니다. 여기에는 다른 인증자를 가장하거나 피어 및 EAP 서버에 일관되지 않은 정보를 제공하는 것이 포함됩니다.

\(j\) 공격자는 EAP 피어, 인증자 또는 백엔드 인증 서버에 대해 서비스 거부 공격을 시작할 수 있습니다.

이러한 위협을 해결하기 위해 \[RFC4962\] 섹션 3에서는 필수 및 권장 보안 속성을 설명합니다. 다음 섹션에서는 이러한 지침에 따라 EAP 방법, AAA 프로토콜 및 보안 연결 프로토콜의 준수 여부를 분석합니다.

---
### **5.1.  Peer and Authenticator Compromise**

요구 사항: 인증자가 손상되거나 도난당하는 경우 공격자는 해당 인증자를 통해 네트워크에 액세스할 수 있거나 인증자/AAA 클라이언트가 하나 이상의 백엔드 인증 서버와 통신하는 데 필요한 자격 증명을 얻을 수 있습니다. 마찬가지로, 피어가 손상되거나 도난당하는 경우 공격자는 하나 이상의 인증자와 통신하는 데 필요한 자격 증명을 얻을 수 있습니다. \[RFC4962\] 섹션 3의 필수 요구 사항:

- 도미노 효과 방지

- 단일 피어의 손상으로 인해 세션 키 및 장기 키를 포함하여 시스템 내 다른 피어가 보유한 키 자료가 손상되어서는 안 됩니다. 마찬가지로 단일 인증자의 손상으로 인해 시스템 내의 다른 인증자가 보유한 키 자료가 손상되어서는 안 됩니다. 키의 맥락에서\(MUST NOT, MUST NOT\)

- 계층 구조, 이는 키 계층 구조의 한 노드가 손상되더라도 키 계층 구조의 다른 분기를 손상시키는 데 필요한 정보가 공개되어서는 안 된다는 의미입니다. 분명히 키 계층 구조의 루트가 손상되면 모든 키가 손상됩니다. 그러나 한 브랜치의 손상으로 인해 다른 브랜치가 손상되어서는 안 됩니다. 이 요구 사항에는 많은 의미가 있습니다. 그러나 두 가지 의미를 강조할 가치가 있습니다. 첫째, 키 자료를 보유하고 있는 당사자와 통신하는 모든 당사자가 키 자료의 범위를 정의하고 이해해야 합니다. 둘째, 키 계층에서 키 자료를 보유하는 당사자는 해당 키 자료를 키 계층의 다른 분기와 연관된 당사자와 공유해서는 안 됩니다.\(MUST NOT\)

- 그룹 키는 명백한 예외입니다. 그룹의 모든 구성원은 동일한 키의 복사본을 갖고 있으므로 그룹 구성원 중 한 명이 손상되면 그룹 키가 공개됩니다.

요구사항의 일부 의미는 다음과 같습니다.

키 공유

- 키 자료가 공유되었는지 여부를 확인할 수 있으려면 EAP 인증자\(NAS-식별자\)의 신원을 이와 통신하는 모든 당사자가 정의하고 이해해야 합니다. \[IEEE-802.11\], \[IEEE-802.16e\], \[IEEE-802.1X\], IKEv2 \[RFC4306\] 및 PPP \[RFC1661\]와 같은 EAP 하위 계층 사양에는 키 공유가 포함되지 않습니다.

AAA 자격 증명 공유

- AAA 자격 증명\(예: RADIUS 공유 비밀, IPsec 사전 공유 키 또는 인증서\)은 AAA 클라이언트 간에 공유되어서는 안 됩니다. 왜냐하면 하나의 AAA 클라이언트가 손상되면 공격자가 다른 AAA 클라이언트를 백엔드 인증 서버로 가장할 수 있기 때문입니다. 또는 백엔드 인증 서버를 다른 AAA 클라이언트로 가장할 수도 있습니다.\(MUST NOT\)

장기 자격 증명의 손상

- 키 자료\(TSK, TEK 또는 MSK 등\)를 획득하는 공격자는 기본적인 암호화 가정을 위반하지 않고 사전 공유 키, 비밀번호 또는 개인 키와 같은 장기 사용자 자격 증명을 얻을 수 있어서는 안 됩니다. \[RFC4017\] 섹션 2.2의 필수 요구 사항에는 EAP 키 자료 생성, 128비트 유효 강도의 EAP 키 자료 생성 기능, 사전 공격에 대한 저항, 공유 상태 동등성 및 중간자 공격에 대한 보호가 포함됩니다.\(MUST NOT\)

---
### **5.2.  Cryptographic Negotiation**

\[RFC4962\] 섹션 3의 필수 요구 사항:

```text
      Cryptographic algorithm independent
```

- AAA 키 관리 프로토콜은 암호화 알고리즘에 독립적이어야 합니다. 그러나 EAP 방법은 특정 암호화 알고리즘에 따라 달라질 수 있습니다. 특정 암호화 알고리즘의 사용을 협상하는 기능은 특정 암호화 알고리즘의 손상에 대한 탄력성을 제공합니다. 보안 연결 프로토콜이 정의된 경우 알고리즘 독립성도 필요합니다. 이는 일반적으로 프로토콜에 알고리즘 식별자와 매개변수를 포함하고 프로토콜 사양에 알고리즘 요구 사항을 지정하여 수행됩니다. 매우 바람직하지만 KDF\(핵심 파생 함수\)를 협상하는 기능은 필요하지 않습니다. 상호 운용성을 위해 최소 하나 이상의 필수 구현 알고리즘 제품군을 선택해야 합니다. \[RFC3579\] 섹션 4.2에 설명된 대로 IPsec에 의한 보호가 없으면 RADIUS \[RFC2865\]는 무결성 보호 알고리즘을 협상할 수 없기 때문에 이 요구 사항을 충족하지 않습니다.\(MUST, MAY, MUST, MUST\)

- 이 요구 사항은 프로토콜이 공개 키와 대칭 키 암호화 알고리즘을 모두 지원해야 한다는 의미는 아닙니다. 이는 공개 키 알고리즘이 사용될 때마다 여러 공개 키 알고리즘을 사용할 수 있는 방식으로 프로토콜을 구성해야 함을 의미합니다. 마찬가지로 이는 대칭 키 알고리즘이 사용될 때마다 여러 대칭 키 알고리즘을 사용할 수 있는 방식으로 프로토콜을 구성해야 함을 의미합니다.

```text
      Confirm ciphersuite selection
```

- "최상의" 암호 모음 선택은 안전하게 확인되어야 합니다. 메커니즘은 시도된 롤백 공격을 감지해야 합니다.\(SHOULD, SHOULD\)

\[RFC4017\] 섹션 2.2 필수 요구 사항을 충족하는 EAP 방법과 전송 계층 보안을 활용하는 AAA 프로토콜은 다운그레이드 공격을 처리할 수 있습니다. \[RFC3748\] 섹션 7.2.1에서는 EAP 방법 대화를 보호하는 데 사용되는 암호 그룹을 협상하고 암호 그룹 협상의 무결성을 보호하는 EAP 방법의 능력을 나타내는 "보호된 암호 그룹 협상" 보안 주장을 설명합니다. \[RFC4017\] 섹션 2.2에서는 이 보안 주장을 충족하는 EAP 방법을 요구합니다. TLS v1.2 \[RFC5246\] 및 IKEv2 \[RFC4306\]는 KDF\(키 파생 기능\) 협상을 지원하므로 TLS 또는 IKEv2 기반 EAP 방법은 적절하게 설계된 경우 다음을 수행합니다.

이 능력을 물려받습니다. 그러나 RFC 4962 \[RFC4962\]에서는 KDF 협상이 요구되지 않으며 TLS나 IKEv2를 기반으로 하는 EAP 방법은 일반적으로 KDF 협상을 지원하지 않습니다.

AAA 프로토콜이 전송 계층 보안을 위해 TLS \[RFC5246\] 또는 IPsec \[RFC4301\]을 활용하는 경우 IKEv2 \[RFC4306\] 또는 TLS \[RFC5246\]에서 제공하는 암호화 알고리즘 협상 지원을 활용할 수 있습니다. RADIUS \[RFC3579\] 자체는 암호화 알고리즘 협상을 지원하지 않으며 무결성 보호, 인증 및 기밀성을 위해 MD5를 사용합니다. MD5 \[MD5Collision\]의 알려진 약점을 고려할 때 이는 바람직하지 않으며 \[RFC3579\] 섹션 4.2에 설명된 대로 IPsec을 통한 RADIUS를 사용하여 해결할 수 있습니다.

하위 계층 프로토콜 내에서 다운그레이드 공격을 방지하려면 키 파생을 위해 EAP를 사용하는 하위 계층에서 알고리즘 독립성이 필요합니다. 상호 운용성을 위해 최소 하나 이상의 필수 구현 알고리즘 제품군을 선택해야 합니다. 키 파생을 위해 EAP를 지원하는 하위 계층 프로토콜은 KDF 협상뿐만 아니라 보안 암호화 제품군 협상도 지원해야 합니다\(SHOULD\).\(MUST, MUST, SHOULD\)

\[RFC1968\]에 설명된 대로 PPP ECP는 보안 암호화 제품군 협상을 지원하지 않습니다. \[IEEE-802.16e\] 및 \[IEEE-802.11\]은 데이터 보호를 위한 암호화 제품군 협상을 지원하지만 MIC\(메시지 무결성 검사\) 및 KDF와 같은 보안 연관 프로토콜 내에서 사용되는 암호화 기본 요소의 협상은 지원하지 않습니다.

---
### **5.3.  Confidentiality and Authentication**

\[RFC4962\] 섹션 3의 필수 요구 사항:

```text
      Authenticate all parties
```

AAA 키 관리 프로토콜의 각 당사자는 다음과 같아야 합니다.

- 통신하는 다른 당사자에게 인증됩니다. 인증 메커니즘은 인증 프로세스에 사용되는 모든 비밀 값의 기밀성을 유지해야 합니다. 보안 연결 프로토콜을 사용하여 세션 키를 설정하는 경우 보안 연결 프로토콜에 관련된 당사자는 세션 키를 사용할 하위 계층 프로토콜 환경에서 의미 있는 ID를 사용하여 자신을 식별해야 합니다. 이러한 상황에서는 인증자와 피어가 AAA 프로토콜 환경과 하위 계층 프로토콜 환경에서 서로 다른 식별자로 알려질 수 있으므로 명확한 키 범위가 없으면 권한 부여 결정이 어려워집니다. 하위 계층 식별자인 경우\(MUST, MUST, MUST\)

- 피어는 인증 결정을 내리는 데 사용되며, 피어와 관련된 식별자 쌍은 인증자 및/또는 AAA 서버에 의해 인증되어야 합니다.\(MUST\)

- RADIUS \[RFC2865\] 및 Diameter \[RFC3588\]와 같은 AAA 프로토콜은 AAA 클라이언트 식별을 위한 메커니즘을 제공합니다. EAP 인증자와 AAA 클라이언트는 항상 공동 상주하므로 이 메커니즘은 EAP 인증자의 식별에 적용됩니다.

- 여러 기지국과 "컨트롤러"\(예: WLAN 스위치\)가 단일 EAP 인증자를 구성하는 경우 "기지국 ID"는 관련이 없습니다. EAP 방법 대화는 EAP 피어와 EAP 서버 간에 이루어집니다. 또한 많은 기지국이 동일한 인증자 ID를 공유할 수 있습니다. 인증자 ID는 AAA 프로토콜 교환 및 보안 연관 프로토콜 대화에서 중요합니다.

- 인증 메커니즘은 일반 텍스트 비밀번호를 사용해서는 안 됩니다. 비밀번호는 기밀 보호 없이 타인에게 전송되지 않는 한 사용할 수 있습니다.\(MUST NOT\)

- 키 자료의 기밀성 및 무결성

- 알고리즘 독립성을 유지하면서 모든 키 자료의 기밀성과 무결성을 유지해야 합니다.\(MUST\)

이러한 요구 사항에 대한 적합성은 다음 섹션에서 분석됩니다.

---
#### **5.3.1.  Spoofing**

패킷별 인증 및 무결성 보호는 스푸핑 공격으로부터 보호합니다.

Diameter \[RFC3588\]는 IPsec 또는 TLS를 사용하여 패킷별 인증 및 무결성 보호를 지원합니다. RADIUS/EAP \[RFC3579\]는 메시지 인증자 속성을 사용하여 패킷별 인증 및 무결성 보호를 제공합니다.

\[RFC3748\] 섹션 7.2.1에서는 "무결성 보호" 보안 주장을 설명하고 \[RFC4017\] 섹션 2.2에서는 이 주장을 지원하는 EAP 방법을 요구합니다.

Secure Association Protocol 프레임 위조를 방지하기 위해 모든 메시지에 대해 프레임별 인증 및 무결성 보호를 권장합니다. IKEv2 \[RFC4306\]는 프레임별 무결성을 지원합니다.\(SHOULD\)

보호 및 인증은 \[IEEE-802.16e\]에 정의된 보안 연결 프로토콜과 같습니다. \[IEEE-802.11\]은 첫 번째 메시지를 제외한 4방향 핸드셰이크 내의 모든 메시지에 대해 프레임별 무결성 보호 및 인증을 지원합니다. 이러한 생략을 활용한 공격은 \[분석\]에 설명되어 있습니다.

---
#### **5.3.2.  Impersonation**

RADIUS \[RFC2865\] 및 Diameter \[RFC3588\] 구현은 모두 다른 인증자를 가장하는 악성 인증자에게 잠재적으로 취약합니다. 두 프로토콜 모두 AAA 클라이언트/인증자와 백엔드 인증 서버 간의 상호 인증을 지원하지만 보안 메커니즘은 다양합니다.

RADIUS에서 인증에 사용되는 공유 비밀은 RADIUS 패킷의 소스 주소에 따라 결정됩니다. 그러나 RADIUS 액세스 요청이 프록시에 의해 전달되는 경우 RADIUS 서버가 수신한 NAS-IP-주소, NAS-식별자 또는 NAS-IPv6-주소 속성은 소스 주소와 일치하지 않습니다. \[RFC3579\] 섹션 4.3.7에 언급된 바와 같이, 첫 번째 홉 프록시가 액세스 요청 패킷의 소스 주소에 대해 NAS 식별 속성을 확인하지 않으면 불량 인증자가 NAS-IP 주소를 위조할 수 있습니다. RFC2865\], NAS-IPv6-Address \[RFC3162\] 또는 NAS-Identifier \[RFC2865\] 속성을 사용하여 다른 인증자를 가장합니다. Called-Station-Id \[RFC2865\] 및 Calling-Station-Id \[RFC2865\]와 같은 속성도 위조될 수 있습니다. 무엇보다도 이로 인해 메시지\(및 전송된 키 자료\)가 잘못된 인증자에게 전송될 수 있습니다.

\[RFC3588\]에서는 Route-Record AVP를 사용해야 하지만 FQDN\(정규화된 도메인 이름\)을 사용하므로 가장 탐지를 위해서는 DNS A, AAAA 및 PTR RR\(리소스 레코드\)을 적절하게 구성해야 합니다. 결과적으로 Diameter는 RADIUS만큼 이 공격에 취약합니다. \[RFC3579\] 섹션 4.3.7에서는 가장 탐지를 위한 메커니즘을 권장합니다. "알 필요" 없이 프록시가 키 자료에 액세스하는 것을 방지하려면 백엔드 인증 서버가 \[RFC3588\]에서 지원되는 리디렉션 기능을 통해 인증자와 직접 통신할 수 있도록 허용해야 합니다.

---
#### **5.3.3.  Channel Binding**

손상되었거나 제대로 구현되지 않은 EAP 인증자가 EAP 피어 및/또는 서버에 잘못된 정보를 전달할 수 있습니다. 이를 통해 인증자가 다른 인증자를 가장하거나 대역 외 메커니즘\(예: AAA 또는 하위 계층을 통해\)을 통해 잘못된 정보를 전달할 수 있습니다.

EAP가 통과 모드에서 사용되는 경우 EAP 피어는 EAP 대화 내에서 통과 인증자의 ID를 확인하지 않습니다. 보안 연결 프로토콜 내에서 EAP 피어와 인증자는 전송된 키 자료의 상호 소유만을 입증합니다. 그들은 상호 인증하지 않습니다. 이로 인해 \[RFC3748\] 섹션 7.15에 설명된 잠재적인 보안 취약점이 발생합니다.

\[RFC3579\] 섹션 4.3.7에 설명된 대로 첫 번째 홉 AAA 프록시가 다른 인증자를 가장하려고 시도하는 AAA 클라이언트를 감지하는 것이 가능합니다. 그러나 AAA 클라이언트 역할을 하는 통과 인증자가 하위 계층을 통해 EAP 피어에 잘못된 정보를 전달하면서 백엔드 인증 서버에 올바른 정보를 제공하는 것이 가능합니다.

예를 들어, 손상된 인증자는 하위 계층을 통해 EAP 피어와 통신할 때 다른 인증자의 Called-Station-Id 또는 NAS-Identifier를 활용할 수 있습니다. 또한 AAA 클라이언트 역할을 하는 통과 인증자는 AAA 프로토콜을 통해 잘못된 피어 Calling-Station-Id \[RFC2865\] \[RFC3580\]를 백엔드 인증 서버에 제공할 수 있습니다.

\[RFC3748\] 섹션 7.15에 명시된 대로 이 취약점은 Called-Station-Id \[RFC2865\] \[RFC3580\]을 포함하되 이에 국한되지 않는 엔드포인트 식별자와 같은 채널 속성의 보호된 교환을 지원하는 EAP 방법으로 해결될 수 있습니다. Calling-Station-Id \[RFC2865\] \[RFC3580\], NAS-Identifier \[RFC2865\], NAS-IP-Address \[RFC2865\] 및 NAS-IPv6-Address \[RFC3162\].

이러한 보호된 교환을 사용하면 대역 외 메커니즘을 통해 인증자가 제공한 채널 속성을 EAP 방법 내에서 교환된 채널 속성과 일치시키는 것이 가능합니다. 일반적으로 EAP 방법은 피어의 하위 계층에서 채널 바인딩 매개변수를 가져와 EAP 서버로 안전하게 전송하고, EAP 서버는 이를 하위 계층 또는 AAA 계층으로 내보냅니다. 그러나 전송은 EAP 서버에서 피어로 발생할 수도 있고 양방향으로 이루어질 수도 있습니다. 채널 바인딩이 검증된 교환기\(피어 또는 서버\) 측에서는 하위 계층 또는 AAA 계층이 검증 결과\(TRUE 또는 FALSE\)를 EAP 방식으로 전달합니다. 확인은 피어나 서버에 의해 수행될 수 있지만 일반적으로 값의 동일성을 단순히 확인하는 것이 아니라 서버만이 값의 정확성을 결정할 수 있는 지식을 가지고 있습니다. 자세한 내용은 \[EAP-SERVICE\]를 참조하세요.

\[EAP-CHANNEL\]에 설명된 대로 EAP를 통해 데이터를 전송하지 않고 채널 바인딩을 수행하는 것도 가능합니다. 이 접근 방식에서 EAP 방법은 내보낸 EAP 키 자료 계산에 채널 바인딩 매개 변수를 포함하므로 피어 및

채널 바인딩 매개변수에 불일치가 있는 경우 보안 연관 프로토콜을 완료하기 위한 인증자입니다. 그러나 이 접근법은 EAP 키 자료를 생성하는 방법이 EAP 키 자료를 활용하는 하위 계층과 함께 사용되는 경우에만 적용될 수 있습니다. 예를 들어, 이 메커니즘은 \[IEEE-802.1X\]를 사용하는 유선 IEEE 802 네트워크에서 채널 바인딩을 확인할 수 없습니다.

---
#### **5.3.4.  Mutual Authentication**

\[RFC3748\] 섹션 7.2.1에서는 "상호 인증" 및 "사전 공격 저항" 주장을 설명하고 \[RFC4017\]에서는 이러한 주장을 충족하는 EAP 방법이 필요합니다. 따라서 \[RFC4017\]을 준수하는 EAP 방법은 EAP 피어와 서버 간의 상호 인증을 제공합니다.

\[RFC3748\] 섹션 7.2.1에서는 "암호화 바인딩" 보안 주장도 설명하고 \[RFC4017\] 섹션 2.2에서는 이 주장에 대한 지원이 필요합니다. \[EAP-BINDING\]에 설명된 대로 EAP 방법 시퀀스 및 복합 인증 메커니즘은 중간자 공격의 대상이 될 수 있습니다. 이러한 공격이 성공적으로 수행되면 공격자는 피해자와 합법적인 인증자 사이의 중개자 역할을 합니다. 이를 통해 공격자는 인증자에게 성공적으로 인증할 수 있을 뿐만 아니라 네트워크에 대한 액세스 권한도 얻을 수 있습니다.

이러한 공격을 방지하기 위해 \[EAP-BINDING\]에서는 EAP 피어와 서버가 전체 EAP 교환에 참여했음을 증명할 수 있는 복합 키 파생을 권장합니다. 복합 키는 인증자 역할을 하는 공격자에게 알려져서는 안 되며 EAP 키 자료에서 파생되어야 하므로 EMSK의 일부에서 복합 키를 파생하는 것이 바람직할 수 있습니다. 이 작업이 수행되는 경우 적절한 키 위생을 제공하기 위해 중간자 보호에 사용되는 복합 키를 EMSK에서 파생된 다른 키와 암호화 방식으로 분리하는 것이 좋습니다.\(MUST NOT, SHOULD\)

Diameter \[RFC3588\]는 IPsec 또는 TLS를 통한 패킷별 인증 및 무결성 보호를 제공하며, RADIUS/EAP \[RFC3579\]도 패킷별 인증 및 무결성 보호를 제공합니다. 인증자/AAA 클라이언트 및 백엔드 인증 서버가 직접 통신하고 신뢰할 수 있는 키 랩이 사용되는 경우\(섹션 3.8 참조\) 이는 AAA 키 전송\(1b단계\)이 보안 목표\(AAA 클라이언트/인증자 및 백엔드 인증을 상호 인증함\)를 달성하도록 보장합니다. 서버를 통해 전송된 키 자료를 EAP 인증자에게만 제공하고 다른 당사자에게는 제공하지 않습니다.

\[RFC2607\] 7장은 인증자/AAA 클라이언트와 백엔드 인증 서버가 직접 통신하지 않을 때 발생하는 보안 문제를 설명합니다. AAA 중개자가 있고\(예: RADIUS 프록시 또는 Diameter 에이전트\) 데이터 개체 보안이 사용되지 않는 경우 전송된 키 자료는 중개자를 제어하는 ​​공격자가 복구할 수 있습니다. 섹션 2.1에서 설명한 대로 TSK가 EAP 키 자료\(IKEv2에서와 같이\)와 독립적으로 파생되지 않는 한 전송된 키 자료를 소유하면 피어와 키 자료가 전송된 인증자 간에 전송된 데이터 트래픽의 암호를 해독할 수 있습니다. 또한 AAA 중개자가 인증자나 피어를 가장할 수도 있습니다. 피어는 AAA 중개자를 인증하지 않기 때문에 이것이 인증되었는지 또는 키 자료를 얻을 수 있는 권한이 있는지 확인할 수 없습니다.

그러나 전송된 키 자료 또는 여기에서 파생된 키가 단일 인증자에 의해서만 활용되는 한, 전송된 키 자료가 손상되더라도 공격자가 피어를 다른 인증자에게 가장할 수는 없습니다. AAA 중개자의 손상에 대한 취약성은 \[RFC3588\] 및 \[RFC4072\]에 설명된 대로 리디렉션 기능을 구현하여 완화할 수 있습니다.

보안 연결 프로토콜은 EAP 피어와 인증자 간의 상호 인증을 제공하지 않으며 전송된 키 자료의 소유에 대한 상호 증명만 제공합니다. 피어가 인증자의 신원을 확인하려면 상호 소유 증명이 가장 방지 및 채널 바인딩과 결합되어야 합니다. 가장 방지\(섹션 5.3.2에 설명됨\)를 통해 백엔드 인증 서버는 전송된 키 자료가 올바른 인증자에게 제공되었는지 확인할 수 있습니다. 가장 방지와 함께 사용하면 채널 바인딩\(섹션 5.3.3에 설명됨\)을 통해 EAP 피어는 EAP 서버가 전송된 키 자료를 소유하도록 인증자에게 권한을 부여했는지 확인할 수 있습니다. Secure Association Protocol 교환이 완료되면 EAP 피어와 인증자가 전송된 키 자료를 소유하고 있음이 입증됩니다.

---
### **5.4.  Key Binding**

\[RFC4962\] 섹션 3의 필수 요구 사항:

- 키를 해당 컨텍스트에 바인딩

- 키 입력 자료는 적절한 컨텍스트에 바인딩되어야 합니다. 컨텍스트에는 다음이 포함됩니다.\(MUST\)

- o 키 자료가 사용될 것으로 예상되는 방식.

- o 키 자료에 접근할 것으로 예상되는 다른 당사자.

- o 키 자료의 예상 수명. 하위 키의 수명은 키 계층 구조에 있는 상위 키의 수명보다 길어서는 안 됩니다.\(SHOULD NOT\)

- 키 자료에 대한 합법적인 접근 권한을 가진 모든 당사자는 해당 내용을 확인할 수 있습니다. 또한 프로토콜은 키 자료에 대한 합법적인 액세스 권한을 가진 모든 당사자가 키 자료에 대해 동일한 컨텍스트를 갖도록 보장해야 합니다. 이를 위해서는 키 자료에 액세스할 수 있는 모든 당사자를 확인할 수 있도록 당사자를 적절하게 식별하고 인증해야 합니다.\(MUST\)

- 컨텍스트에는 둘 이상의 형식으로 피어 및 NAS ID가 포함됩니다. 인증 교환 및 AAA 프로토콜에서 이러한 당사자를 식별하려면 하나 이상의 이름 형식이 필요합니다. 세션 키를 사용할 하위 계층 내에서 이러한 당사자를 식별하려면 다른 이름 형식이 필요할 수 있습니다.

EAP 내에서 내보낸 키 자료\(MSK, EMSK, IV\)는 키 자료와 함께 내보내지는 피어 ID 및 서버 ID에 바인딩됩니다. 그러나 모든 EAP 방법이 인증된 서버 ID를 지원하는 것은 아닙니다\(부록 A 참조\).

AAA 프로토콜 내에서 전송된 키 자료는 요청 내의 NAS-식별자 속성으로 식별된 EAP 인증자로 향하며 Peer-Id\(s\), User-Name \[RFC2865\]로 식별된 EAP 피어에서 사용됩니다. 또는 CUI\(Chargeable User Identity\) \[RFC4372\] 속성. 섹션 3.5.1에서 설명한 대로 전송된 키 자료의 최대 수명이 제공될 수 있습니다. 섹션 3.2에 설명된 대로 키 사용 제한도 포함될 수 있습니다. 주요 수명 문제는 섹션 3.3, 3.4 및 3.5에서 논의됩니다.

---
### **5.5.  Authorization**

요구 사항: Secure Association Protocol\(2단계\) 대화는 EAP 대화\(1a단계\)와 다른 식별자를 활용할 수 있으므로 EAP와 Secure Association Protocol ID 간의 바인딩이 필요합니다.\(MUST\)

\[RFC4962\] 섹션 3의 필수 요구 사항:

- 피어 및 인증자 인증

- 피어 및 인증자 인증을 반드시 수행해야 합니다. 이러한 엔터티는 공개하지 않고 적절한 키 자료를 소유하고 있음을 입증해야 합니다. 승인이 필요합니다\(MUST, MUST, MUST\)

피어가 새 인증자와 연결될 때마다. 그만큼

- 인증 확인은 권한 상승 공격을 방지하고 인증되지 않은 인증자가 감지되는지 확인합니다.

- 인증은 피어, NAS 및 백엔드 인증 서버 간에 동기화되어야 합니다. AAA 키 관리 프로토콜 교환이 완료되면 이러한 모든 당사자는 다른 당사자와 관련된 인증에 대한 공통된 관점을 보유해야 합니다.\(SHOULD\)

모든 당사자를 인증하는 것 외에도 키 관리

- 프로토콜은 당사자가 키 자료를 소유할 권한이 있음을 입증해야 합니다. 키 자료를 소유했다는 증거가 반드시 해당 키 자료를 보유할 권한이 있음을 증명하는 것은 아닙니다. 예를 들어, IEEE 802.11 내에서 4방향 핸드셰이크는 피어와 인증자 모두가 동일한 EAP 키 자료를 소유하고 있음을 보여줍니다. 그러나 이 소유 증명 자체로는 인증자가 백엔드 인증 서버에 의해 해당 키 자료를 소유하도록 승인되었음을 입증하지 못합니다. AAA 프록시가 존재하는 섹션 4.3.7의 \[RFC3579\]에 명시된 대로 AAA 체인의 각 링크가 가장에 대한 검사를 구현하지 않는 한 한 인증자가 다른 인증자를 가장할 수 있습니다. 이러한 검사가 이루어지더라도 인증자는 여전히 피어와 백엔드 인증 서버에 대해 다른 ID를 요구할 수 있습니다. \[RFC3748\] 섹션 7.15에 설명된 대로 피어가 인증자의 ID 주장이 일관되고 올바른지 확인할 수 있도록 하려면 채널 바인딩이 필요합니다.

\[RFC4962\] 섹션 3의 권장사항:

```text
      Authorization restriction
```

- 피어 인증이 제한되는 경우 피어는 제한 사항을 인식해야 합니다. 그렇지 않으면 피어가 실수로 제한을 우회하려고 시도할 수 있습니다. 예를 들어 IEEE 802.11 환경의 인증 제한 사항은 다음과 같습니다.\(SHOULD\)

```text
      o  Key lifetimes, where the keying material can only be used for a
         certain period of time;

      o  SSID restrictions, where the keying material can only be used
         with a specific IEEE 802.11 SSID;
```

- o 키 자료가 단일 IEEE 802.11 BSSID에만 사용될 수 있는 Called-Station-ID 제한 사항. 그리고

- o 키 자료가 단일 피어 IEEE 802 MAC 주소에만 사용될 수 있는 호출 스테이션 ID 제한.

섹션 2.3에 설명된 대로 EAP 인증자의 일관된 식별을 통해 EAP 피어는 인증자에게 제공되는 키 자료의 범위를 결정할 수 있을 뿐만 아니라 EAP 인증자가 EAP 키 자료의 소유를 증명하는 백엔드 인증 서버를 통해 확인할 수 있습니다. Secure Association Protocol이 이를 획득하도록 승인되었습니다.

AAA 프로토콜 내에서 인증 속성은 전송된 키 자료에 바인딩됩니다. AAA 교환은 AAA 클라이언트/인증자에게 EAP 피어와 관련된 인증을 제공하지만 EAP나 AAA 교환은 EAP 피어에 인증을 제공하지 않습니다. 모든 당사자가 인증에 대해 동일한 관점을 갖도록 보장하기 위해 보안 연결 프로토콜을 통해 EAP 인증자와 피어 간의 인증 통신을 활성화하는 것이 좋습니다.\(SHOULD\)

인증자가 피어 및 백엔드 인증 서버에 대해 일관되게 자신을 식별하고 EAP 피어가 EAP 대화를 완료하는 데 사용한 동일한 인증자와 SAA\(Secure Association Protocol\) 교환을 완료하는 하위 계층에서 인증자의 권한 부여는 상호 인증을 통해 피어에 시연됩니다. 이전 섹션에서 설명한 대로 피어와 인증자 사이에 있습니다. 식별 문제는 섹션 2.3, 2.4, 2.5에서 논의되며 주요 범위 문제는 섹션 3.2에서 논의됩니다.

EAP 피어가 EAP 방법 및 보안 연결 프로토콜 대화 내에서 서로 다른 식별자를 활용하는 경우 피어 권한 부여는 추가 제한 없이 인증자에게 입증하기 어려울 수 있습니다. 이 문제는 IKEv2 및 EAP 내에서 피어 식별을 위해 ID 페이로드가 사용되고 EAP 및 IKEv2 교환을 바인딩하는 IKEv2 내에서 EAP 대화가 암호화 방식으로 보호되는 IKEv2에는 존재하지 않습니다. 그러나 \[IEEE-802.11\]에서는 4-way 핸드셰이크 내에서 EAP 피어 ID가 사용되지 않으므로 인증자는 EAP 피어가 4-way 핸드셰이크와 동일한 MAC 주소를 EAP 인증에 사용하도록 요구해야 합니다. 악수하는 법.

---
### **5.6.  Replay Protection**

\[RFC4962\] 섹션 3의 필수 요구 사항:

```text
      Replay detection mechanism
```

AAA 키 관리 프로토콜 교환은 반드시 재생되어야 합니다.

- AAA, EAP 및 Secure Association Protocol 교환을 포함하여 보호됩니다. 재생 보호를 사용하면 프로토콜 메시지 수신자가 이전의 합법적인 대화 중에 녹음되어 현재 대화에 속한 것처럼 표시된 모든 메시지를 삭제할 수 있습니다.\(MUST\)

\[RFC3748\] 섹션 7.2.1에서는 "재생 보호" 보안 주장을 설명하고 \[RFC4017\] 섹션 2.2에서는 이 주장을 지원하는 EAP 방법을 사용해야 합니다.

Diameter \[RFC3588\]는 IPsec 또는 TLS를 사용하여 재생 보호를 지원합니다. "EAP에 대한 RADIUS 지원"\[RFC3579\]은 요청 인증자를 통한 키 자료의 재생을 방지합니다. \[RFC2865\] 섹션 3에 따르면:

- 액세스 요청 패킷에서 인증자 값은 요청 인증자라고 하는 16옥텟 난수입니다.

그러나 일부 RADIUS 패킷은 재생 보호되지 않습니다. Accounting, Disconnect 및 CoA\(Care-of Address\) 요청 패킷에서 요청 인증자는 nonce가 아닌 키가 포함된 MIC\(Message Integrity Code\)를 포함합니다. Accounting, Disconnect 및 CoA-Response 패킷의 응답 인증자에는 요청 또는 응답 패킷의 nonce에 의존하지 않는 계산을 수행하는 키 입력 MIC도 포함되어 있습니다. 따라서 Event-Timestamp 특성이 포함되거나 IPsec이 사용되지 않으면 수신자가 이러한 패킷이 재생되었는지 여부를 확인하지 못할 수도 있습니다. 이 문제는 \[RFC5176\] 섹션 6.3에서 자세히 논의됩니다.

Secure Association Protocol 프레임의 재생을 방지하려면 모든 메시지에 재생 보호가 필요합니다. \[IEEE-802.11\]은 4방향 핸드셰이크 내의 모든 메시지에 대한 재생 보호를 지원합니다. IKEv2 \[RFC4306\]도 이를 지원합니다.\(MUST\)

---
### **5.7.  Key Freshness**

요구 사항: 세션 키는 승인된 수명을 초과하여 계속 사용되는 경우 손상된 것으로 간주되어야 합니다. \[RFC4962\] 섹션 3의 필수 요구 사항:\(SHOULD\)

```text
      Strong, fresh session keys
```

- 알고리즘 독립성을 유지하면서 세션 키는 강력하고 신선해야 합니다. 각 세션에는 독립적인 세션 키가 필요합니다. 상태 손실로 인해 동일한 카운터 값이 동일한 세션 키와 함께 두 번 이상 사용되지 않도록 하기 위해 긴 재생 카운터\(즉, "랩핑되지 않는" 카운터\)를 사용하는 경우에도 새로운 키가 필요합니다.\(MUST\)

- 일부 EAP 방법은 다양한 강도의 키를 파생할 수 있으며 이러한 EAP 방법은 최소 동등한 키 강도를 충족하는 키 생성을 허용해야 합니다. BCP 86 \[RFC3766\]은 적절한 키 크기에 대한 조언을 제공합니다. NIST\(National Institute for Standards and Technology\)는 \[SP800-57\]에서 적절한 키 크기에 대한 조언도 제공합니다.\(MUST\)

- 새로운 암호화 키는 의도된 용도를 위해 특별히 생성된 키입니다. 이 상황에서는 보안 연결 프로토콜을 사용하여 세션 키를 설정합니다. AAA 프로토콜과 EAP 방법은 세션 키 파생에 대한 입력으로 제공된 키 자료가 최신인지 확인해야 하며, 보안 연결 프로토콜은 EAP에서 제공하는 키 자료가 캐시된 경우에도 각 세션에 대해 별도의 세션 키를 생성해야 합니다. 캐시된 키는 인증 교환이 완료된 후에도 유지됩니다. AAA/EAP 서버의 경우 상태가 서버에 유지될 때 키 캐싱이 발생할 수 있습니다. NAS 또는 클라이언트의 경우 NAS 또는 클라이언트가 세션 키 파생 직후 키 입력 자료를 삭제하지 않을 때 키 캐싱이 발생할 수 있습니다.\(MUST\)

- 세션 키는 서로 종속되어서는 안 됩니다. 일반적으로 nonce라고 하는 일회성 값을 사용하여 각 세션 키가 최신인지 확인하는 한 여러 세션 키는 상위 수준 공유 비밀에서 파생될 수 있습니다. 세션 키를 생성하는 데 사용되는 메커니즘은 하나의 세션 키 공개가 공격자가 다른 세션 키를 발견하는 데 도움이 되지 않도록 해야 합니다.\(MUST NOT, MUST\)

EAP, AAA 및 하위 계층은 각각 새롭고 강력한 세션 키의 사용을 보장할 책임이 있습니다. EAP 방법은 세션 키 파생에 대한 입력으로 제공되는 EAP 키 자료의 최신성과 강도를 보장해야 합니다. \[RFC3748\] 섹션 7.10에는 다음과 같이 명시되어 있습니다.

- EAP 방법은 한 당사자가 고품질 난수 생성기를 보유하지 않은 경우에도 MSK 및 EMSK의 최신성을 보장해야 합니다. 권장되는 방법은 각 당사자가 MSK 및 EMSK 파생에 사용되는 최소 128비트의 nonce를 제공하는 것입니다.\(SHOULD, SHOULD\)

nonce의 기여를 통해 EAP 피어 및 서버는 내보낸 EAP 키 입력 자료가 최신인지 확인할 수 있습니다.

\[RFC3748\] 섹션 7.2.1에서는 "키 강도" 및 "세션 독립성" 보안 주장을 설명하고 \[RFC4017\]에서는 이러한 주장을 지원하는 EAP 방법과 128비트 이상의 동등한 키 강도를 제공할 수 있는 방법을 요구합니다. 키 강도에 대한 자세한 내용은 섹션 3.7을 참조하세요.

AAA 프로토콜은 전송된 키 자료가 최신 상태이고 권장 수명 외에는 사용되지 않도록 해야 합니다. 키를 최신 상태로 유지하려면 재생 보호가 필요하지만 공격자가 재생 보호된 메시지에 오래된\(따라서 손상될 수 있는\) 키를 전달할 수 있으므로 재생 보호로는 충분하지 않습니다. 섹션 3.5에서 설명한 대로 세션 시간 초과 속성을 사용하면 백엔드 인증 서버가 전송된 키 자료의 노출을 제한할 수 있습니다.

섹션 1.4에 설명된 EAP 세션 ID를 사용하면 EAP 피어, 인증자 및 서버가 EAP 대화를 구별할 수 있습니다. 그러나 인증자가 EAP 세션 ID를 추적하지 않는 한 인증자는 세션 ID를 사용하여 키 자료의 최신성을 보장할 수 없습니다.

섹션 3.1에 설명된 보안 연결 프로토콜은 메소드에서 제공하는 EAP 키 자료 및 매개변수가 캐시되거나 피어 또는 인증자 중 하나에 높은 엔트로피 난수 생성기가 부족한 경우에도 각 세션에 대해 새로운 세션 키를 생성해야 합니다. 권장되는 방법은 피어와 인증자가 각각 세션 키 파생에 사용되는 nonce 또는 카운터를 제공하는 것입니다. nonce를 사용하는 경우 최소 128비트인 것이 좋습니다. \[IEEE-802.11\] 및 IKEv2 \[RFC4306\]는 이 요구 사항을 충족하지만 \[IEEE-802.16e\]는 무작위성이 기지국에서만 제공되므로 충족하지 않습니다.\(MUST, SHOULD, SHOULD\)

---
### **5.8.  Key Scope Limitation**

\[RFC4962\] 섹션 3의 필수 요구 사항:

```text
      Limit key scope
```

- 최소 권한 원칙에 따라 당사자는 자신의 역할을 수행하는 데 필요하지 않은 키 자료에 액세스해서는 안 됩니다. 당사자가 특정 키를 파생하는 데 필요한 모든 비밀 정보에 액세스할 수 있는 경우 특정 키에 액세스할 수 있습니다.\(MUST NOT\)

- 세션 키를 설정하는 데 사용되는 모든 프로토콜은 세션 키의 범위를 지정하여 세션 키를 사용할 수 있는 당사자를 명확하게 식별해야 합니다.\(MUST\)

전송된 키 자료는 EAP 피어, 인증자 및 서버에서 액세스할 수 있도록 허용됩니다. EAP 피어와 서버는 선택된 EAP 방법을 사용하여 서로를 상호 인증하는 과정에서 EAP 키 자료를 파생합니다. 보안 연결 프로토콜\(Secure Association Protocol\) 교환 중에 EAP 피어는 키 자료를 활용하여 EAP 서버에 인증되고 권한을 부여받은 당사자와 동일한 당사자임을 인증자에게 보여줍니다. EAP 인증자는 전송된 키 자료를 활용하여 EAP 대화가 이를 통해 전송되었을 뿐만 아니라\(중간자에 의해 시연될 수 있음\) EAP 서버에 의해 고유하게 승인되었음을 피어에게 증명합니다. 피어에게 네트워크에 대한 액세스를 제공합니다. 고유 인증은 EAP 인증자가 전송된 키 자료를 EAP 피어 및 서버 이외의 당사자와 공유하지 않는 경우에만 입증될 수 있습니다. TSK는 EAP 피어 및 인증자만 액세스하도록 허용됩니다\(섹션 1.5 참조\). TSK 도출은 섹션 2.1에서 논의됩니다. Secure Association Protocol 교환 내에서 인증 입증은 전송된 키 자료의 보유에 달려 있으므로 백엔드 인증 서버는 전송된 키 자료를 보낸 후 삭제하지 않는 한 TSK를 얻을 수 있습니다.

---
### **5.9.  Key Naming**

\[RFC4962\] 섹션 3의 필수 요구 사항:

```text
      Uniquely named keys
```

- AAA 키 관리 제안에는 특히 키 캐싱이 지원되는 경우 강력한 키 명명 체계가 필요합니다. 키 이름은 어떤 키가 참조되고 있는지 모든 당사자가 명확하게 알 수 있도록 프로토콜에서 키를 참조하는 방법을 제공합니다. 이름을 지정할 수 없는 개체는 관리할 수 없습니다. 모든 키의 이름은 고유해야 하며, 키 이름은 키잉을 직접 또는 간접적으로 공개해서는 안 됩니다.\(MUST NOT\)

-  재료. 키 이름이 키 입력 자료를 기반으로 하지 않으면 키 값 검색을 지원하는 데 사용할 수 없다는 것을 확신할 수 있습니다.

피어 ID 및 서버 ID와 함께 EAP 키 이름\(섹션 1.4.1에 정의됨\)은 EAP 키 자료를 고유하게 식별하며 EAP 키 자료를 직간접적으로 노출하지 않습니다.

기존 AAA 서버 구현에서는 전송된 키 자료와 함께 키 이름을 배포하지 않습니다. 그러나 Diameter EAP \[RFC4072\] 섹션 4.1.4에서는 EAP Session-Id 전송을 목적으로 EAP-Key-Name AVP를 정의합니다. EAP-Key-Name AVP는 RADIUS 속성 공간 내에 정의되므로 RADIUS 또는 Diameter와 함께 사용할 수 있습니다.

기존 백엔드 인증 서버 구현에서는 전송된 키 자료의 이름이 인증자에게 제공되지 않으므로 기존 보안 연결 프로토콜은 EAP 키 이름을 활용하지 않습니다. 예를 들어 \[IEEE-802.11\]은 PMK 캐싱을 지원합니다. 피어와 인증자가 4방향 핸드셰이크 내에서 활용할 캐시된 PMK를 결정할 수 있도록 하려면 PMK의 이름을 지정해야 합니다. 이를 위해 \[IEEE-802.11\]은 키를 기반으로 하는 PMK 명명 체계를 활용합니다. IKEv2 \[RFC4306\]는 전송된 키 자료를 캐시하지 않으므로 전송된 키 자료를 참조할 필요가 없습니다.

---
### **5.10.  Denial-of-Service Attacks**

키 캐싱으로 인해 서비스 거부 공격에 취약해질 수 있습니다. 예를 들어, 지속 상태를 생성하는 EAP 방법은 악의적인 EAP 피어에 의한 EAP 서버에 대한 서비스 거부 공격에 취약할 수 있습니다.

이 취약점을 해결하기 위해 지속 상태를 생성하는 EAP 방법은 EAP 피어가 생성하는 지속 상태를 제한할 수 있습니다. 예를 들어 각 피어에 대해 EAP 서버는 지속 상태를 EAP 세션 ID로 구별되는 몇 가지 EAP 대화로 제한하도록 선택할 수 있습니다. 이는 불량 피어가 다른 피어에 대한 액세스를 거부하는 것을 방지합니다.

마찬가지로 리소스를 절약하기 위해 인증자는 각 피어에 해당하는 지속 상태를 제한하도록 선택할 수 있습니다. 이는 각 피어를 EAP Session-Id로 구별되는 몇 가지 EAP 대화에 해당하는 지속 상태로 제한함으로써 달성될 수 있습니다.

새로운 TSK 생성이 이전에 파생된 TSK의 삭제를 의미하는지 여부는 EAP 하위 계층에 따라 다릅니다. 묵시적인 삭제가 없는 경우 인증자는 각 피어에 대해 저장할 수 있는 TSK 및 관련 상태의 수를 제한하도록 선택할 수 있습니다.

---
## **6.  References**
---
### **6.1.  Normative References**

\[RFC2119\] Bradner, S., "요구 사항 수준을 나타내기 위해 RFC에서 사용할 핵심 단어", BCP 14, RFC 2119, 1997년 3월.

\[RFC3748\] Aboba, B., Blunk, L., Vollbrecht, J., Carlson, J. 및 H. Levkowetz, Ed., "EAP\(확장 가능 인증 프로토콜\)", RFC 3748, 2004년 6월.

\[RFC4962\] Housley, R. 및 B. Aboba, "지침

- AAA\(인증, 권한 부여 및 회계\) 키 관리", BCP 132, RFC 4962, 2007년 7월.

---
### **6.2.  Informative References**

\[8021XPreAuth\] Pack, S. 및 Y. Choi, "IEEE 802.1x 모델 기반 공용 무선 LAN에서 사전 인증된 빠른 핸드오프", 개인 무선 통신에 관한 IFIP TC6/WG6.8 실무 회의 진행, p.175 -182, 2002년 10월 23-25일.

\[분석\] He, C. 및 J. Mitchell, "802.11i 4-Way Handshake 분석", Proceedings of the 2004 ACM Workshop on Wireless Security, pp. 43-50, ISBN: 1-58113-925-X.

\[Bargh\] Bargh, M., Hulsebosch, R., Eertink, E., Prasad, A., Wang, H. 및 P. Schoo, "IEEE 802.11 무선 LAN 간 핸드오버를 위한 빠른 인증 방법", 2차 ACM 논문집 WLAN 핫스팟의 무선 모바일 애플리케이션 및 서비스에 관한 국제 워크숍, 2004년 10월.

\[GKDP\] Dondeti, L., Xiang, J. 및 S. Rowles, "GKDP: 그룹 키 배포 프로토콜", 진행 중인 작업, 2006년 3월.

\[그는\] He, C., Sundararajan, M., Datta, A. Derek, A. 및 J. C. Mitchell, "TLS 및 IEEE 802.11i의 모듈식 정확성 증명", 컴퓨터 및 통신 보안에 관한 ACM 컨퍼런스\(CCS '05\) , 2005년 11월.

\[IEEE-802.11\] 전기전자공학회, "정보 기술 - 시스템 간 통신 및 정보 교환 - 근거리 및 수도권 네트워크 - 특정 요구 사항 파트 11: 무선 LAN 매체 액세스 제어\(MAC\) 및 물리 계층\(PHY\) 사양" , IEEE 표준 802.11-2007, 2007.

\[IEEE-802.1X\] 전기전자공학협회, "로컬 및 메트로폴리탄 영역 네트워크: 포트 기반 네트워크 액세스 제어", IEEE 표준 802.1X-2004, 2004년 12월.

\[IEEE-802.1Q\] 근거리 및 대도시권 네트워크에 대한 IEEE 표준: 가상 브리지 근거리 통신망에 대한 표준 초안, P802.1Q-2003, 2003년 1월.

\[IEEE-802.11i\] 전기 전자 엔지니어 협회, "시스템 간 통신 및 정보 교환 표준에 대한 보충 자료 - LAN/MAN 특정 요구 사항 - 파트 11: 무선 LAN 매체 액세스 제어\(MAC\) 및 물리 계층\(PHY\) 사양: 보안 강화 사양", IEEE 802.11i/D1, 2001.

\[IEEE-802.11F\] 전기 전자 엔지니어 협회, "IEEE 802.11 작동을 지원하는 배포 시스템 간 액세스 포인트 프로토콜을 통한 다중 공급업체 액세스 포인트 상호 운용성을 위한 권장 사례", IEEE 802.11F, 2003년 7월\(현재는 더 이상 사용되지 않음\)

\[IEEE-802.16e\] 전기 전자 엔지니어 협회, "근거리 및 수도권 네트워크에 대한 IEEE 표준: 파트 16: 고정 및 모바일 광대역 무선 액세스 시스템을 위한 무선 인터페이스: 결합된 고정 및 모바일을 위한 물리적 및 매체 액세스 제어 계층에 대한 수정안 허가된 대역에서의 작동" IEEE 802.16e, 2005년 8월.

\[IEEE-03-084\] Mishra, A., Shin, M., Arbaugh, W., Lee, I. 및 K. Zhang, "빠르고 안전한 로밍을 지원하는 사전 예방적 키 배포", IEEE 802.11 Working Group, IEEE- 03-084r1-I, http://www.ieee802.org/11/Documents/DocumentHolder/3-084.zip, 2003년 1월.

\[EAP-SERVICE\] Arkko, J. 및 P. Eronen, "EAP\(확장 가능 인증 프로토콜\)에 대한 인증된 서비스 정보", 진행 중인 작업, 2005년 10월.

\[단기\] Friedman, A., Sheffer, Y. 및 A. Shaqed, "단기 인증서", 진행 중인 작업, 2007년 6월.

\[핸드오프\] Arbaugh, W. 및 B. Aboba, "RADIUS로의 핸드오프 확장", 진행 중인 작업, 2003년 10월.

\[EAP-채널\] Ohba, Y., Parthasrathy, M. 및 M. Yanagiya, "키 파생의 매개변수 바인딩을 기반으로 한 채널 바인딩 메커니즘", 진행 중인 작업, 2007년 6월.

\[EAP-바인딩\] Puthenkulam, J., Lortz, V., Palekar, A. 및 D. Simon, "복합 인증 바인딩 문제", 진행 중인 작업, 2003년 10월.

\[MD5Collision\] Klima, V., "해시 함수의 터널: 1분 이내의 MD5 충돌", 암호화 ePrint 아카이브, 2006년 3월, http://eprint.iacr.org/2006/105.pdf

\[MishraPro\] Mishra, A., Shin, M. 및 W. Arbaugh, "이웃 그래프를 사용한 사전 예방적 키 배포", IEEE Wireless Communications, vol. 2004년 2월 11일.

```text
   [RFC1661]      Simpson, W., Ed., "The Point-to-Point Protocol (PPP)",
                  STD 51, RFC 1661, July 1994.

   [RFC1968]      Meyer, G., "The PPP Encryption Control Protocol
                  (ECP)", RFC 1968, June 1996.
```

\[RFC2230\] Atkinson, R., "DNS에 대한 키 교환 위임 레코드", RFC 2230, 1997년 11월.

\[RFC2409\] Harkins, D. 및 D. Carrel, "인터넷 키 교환\(IKE\)", RFC 2409, 1998년 11월.

\[RFC2516\] Mamakos, L., Lidl, K., Evarts, J., Carrel, D., Simone, D. 및 R. Wheeler, "PPPoE\(이더넷을 통한 PPP 전송 방법\)", RFC 2516, 2월 1999.

```text
   [RFC2548]      Zorn, G., "Microsoft Vendor-specific RADIUS
                  Attributes", RFC 2548, March 1999.
```

\[RFC2607\] Aboba, B. 및 J. Vollbrecht, "로밍의 프록시 연결 및 정책 구현", RFC 2607, 1999년 6월.

\[RFC2716\] Aboba, B. 및 D. Simon, "PPP EAP TLS 인증 프로토콜", RFC 2716, 1999년 10월.

\[RFC2782\] Gulbrandsen, A., Vixie, P. 및 L. Esibov, "서비스 위치 지정을 위한 DNS RR\(DNS SRV\)", RFC 2782, 2000년 2월.

\[RFC2845\] Vixie, P., Gudmundsson, O., Eastlake 3rd, D. 및 B. Wellington, "TSIG\(DNS에 대한 비밀 키 트랜잭션 인증\)", RFC 2845, 2000년 5월.

\[RFC2865\] Rigney, C., Willens, S., Rubens, A. 및 W. Simpson, "RADIUS\(원격 인증 다이얼 인 사용자 서비스\)", RFC 2865, 2000년 6월.

```text
   [RFC3007]      Wellington, B., "Secure Domain Name System (DNS)
                  Dynamic Update", RFC 3007, November 2000.
```

\[RFC3162\] Aboba, B., Zorn, G. 및 D. Mitton, "RADIUS 및 IPv6", RFC 3162, 2001년 8월.

\[RFC3547\] Baugher, M., Weis, B., Hardjono, T. 및 H. Harney, "해석의 그룹 도메인", RFC 3547, 2003년 7월.

\[RFC3579\] Aboba, B. 및 P. Calhoun, "RADIUS\(원격

- 사용자 서비스의 인증 다이얼\) 확장 가능 인증 프로토콜\(EAP\) 지원", RFC 3579, 2003년 9월.

\[RFC3580\] Congdon, P., Aboba, B., Smith, A., Zorn, G. 및 J. Roese, "IEEE 802.1X RADIUS\(Remote Authentication Dial In User Service\) 사용 지침", RFC 3580, 2003년 9월 .

\[RFC3588\] Calhoun, P., Loughney, J., Guttman, E., Zorn, G. 및 J. Arkko, "직경 기본 프로토콜", RFC 3588, 2003년 9월.

\[RFC3766\] Orman, H. 및 P. Hoffman, "대칭 키 교환에 사용되는 공개 키의 강도 결정", BCP 86, RFC 3766, 2004년 4월.

\[RFC3830\] Arkko, J., Carrara, E., Lindholm, F., Naslund, M. 및 K. Norrman, "MIKEY: 멀티미디어 인터넷 키잉", RFC 3830, 2004년 8월.

\[RFC4005\] Calhoun, P., Zorn, G., Spence, D. 및 D. Mitton, "Diameter 네트워크 액세스 서버 애플리케이션", RFC 4005, 2005년 8월.

\[RFC4017\] Stanley, D., Walker, J. 및 B. Aboba, "무선 LAN에 대한 EAP\(확장 가능 인증 프로토콜\) 방법 요구 사항", RFC 4017, 2005년 3월.

\[RFC4033\] Arends, R., Austein, R., Larson, M., Massey, D. 및 S. Rose, "DNS 보안 소개 및 요구 사항", RFC 4033, 2005년 3월.

\[RFC4035\] Arends, R., Austein, R., Larson, M., Massey, D. 및 S. Rose, "DNS 보안 확장을 위한 프로토콜 수정", RFC 4035, 2005년 3월.

\[RFC4067\] Loughney, J., Ed., Nakhjiri, M., Perkins, C. 및 R. Koodli, "CXTP\(컨텍스트 전송 프로토콜\)", RFC 4067, 2005년 7월.

\[RFC4072\] Eronen, P., Ed., Hiller, T. 및 G. Zorn, "EAP\(직경 확장 인증 프로토콜\) 애플리케이션", RFC 4072, 2005년 8월.

\[RFC4118\] Yang, L., Zerfos, P. 및 E. Sadot, "무선 액세스 포인트 제어 및 프로비저닝을 위한 아키텍처 분류\(CAPWAP\)", RFC 4118, 2005년 6월.

\[RFC4186\] Haverinen, H., Ed. 및 J. Salowey, Ed., "GSM\(Global System for Mobile Communications\) 가입자 식별 모듈\(EAP-SIM\)을 위한 확장 가능 인증 프로토콜 방법", RFC 4186, 2006년 1월.

\[RFC4187\] Arkko, J. 및 H. Haverinen, "EAP-AKA\(3세대 인증 및 키 계약을 위한 확장 가능한 인증 프로토콜 방법\)", RFC 4187, 2006년 1월.

\[RFC4282\] Aboba, B., Beadles, M., Arkko, J. 및 P. Eronen, "네트워크 액세스 식별자", RFC 4282, 2005년 12월.

\[RFC4284\] Adrangi, F., Lortz, V., Bari, F. 및 P. Eronen, "확장 가능 인증 프로토콜\(EAP\)에 대한 ID 선택 힌트", RFC 4284, 2006년 1월.

\[RFC4301\] Kent, S. 및 K. Seo, "인터넷 프로토콜을 위한 보안 아키텍처", RFC 4301, 2005년 12월.

```text
   [RFC4306]      Kaufman, C., Ed., "Internet Key Exchange (IKEv2)
                  Protocol", RFC 4306, December 2005.
```

\[RFC4372\] Adrangi, F., Lior, A., Korhonen, J. 및 J. Loughney, "청구 가능한 사용자 ID", RFC 4372, 2006년 1월.

\[RFC4334\] Housley, R. 및 T. Moore, "PPP\(지점 간 프로토콜\) 및 WLAN\(무선 근거리 통신망\)에서 인증을 지원하는 인증서 확장 및 속성", RFC 4334, 2006년 2월.

\[RFC4535\] Harney, H., Meth, U., Colegrove, A. 및 G. Gross, "GSAKMP: 그룹 보안 연관 키 관리 프로토콜", RFC 4535, 2006년 6월.

\[RFC4763\] Vanderveen, M. 및 H. Soliman, "확장 가능

- 공유 비밀 인증 및 키 설정을 위한 인증 프로토콜 방법\(EAP-SAKE\)", RFC 4763, 2006년 11월.

\[RFC4675\] Congdon, P., Sanchez, M. 및 B. Aboba, "가상 LAN 및 우선 순위 지원을 위한 RADIUS 특성", RFC 4675, 2006년 9월.

\[RFC4718\] Eronen, P. 및 P. Hoffman, "IKEv2 설명 및 구현 지침", RFC 4718, 2006년 10월.

\[RFC4764\] Bersani, F. 및 H. Tschofenig, "EAP-PSK 프로토콜: 사전 공유 키 확장 가능 인증 프로토콜\(EAP\) 방법", RFC 4764, 2007년 1월.

\[RFC5176\] Chiba, M., Dommity, G., Eklund, M., Mitton, D. 및 B. Aboba, "RADIUS\(원격 인증 다이얼 인 사용자 서비스\)에 대한 동적 권한 부여 확장", RFC 5176, 2008년 1월.

\[RFC5216\] Simon, D., Aboba, B. 및 R. Hurst, "EAP-TLS 인증 프로토콜", RFC 5216, 2008년 3월.

\[RFC5246\] Dierks, T. 및 E. Rescorla, "TLS\(전송 계층 보안\) 프로토콜 버전 1.2", RFC 5246, 2008년 8월.

\[SP800-57\] 국립표준기술원\(National Institute of Standards and Technology\), "키 관리에 대한 권장사항", 특별 간행물 800-57, 2006년 5월.

\[토큰\] Fantacci, R., Maccari, L., Pecorella, T. 및 F. Frosali, "인프라 및 메시 802.1X 네트워크를 위한 안전하고 성능이 뛰어난 토큰 기반 인증", 컴퓨터 통신에 관한 IEEE 컨퍼런스, 2006년 6월.

\[Tokenk\] Ohba, Y., Das, S. 및 A. Duttak, "Kerberized Handover Keying: 미디어 독립적인 핸드오버 키 관리 아키텍처", Mobiarch 2007.

---
# **Acknowledgments**

유용한 피드백을 주신 Ashwin Palekar, Charlie Kaufman, Tim Moore, Ericsson의 Jari Arkko, Aruba Networks의 Dorothy Stanley, TruSecure의 Bob Moskowitz, Intel의 Jesse Walker, Cisco의 Joe Salowey, Vigil Security의 Russ Housley에게 감사드립니다.

---
# **Appendix A - Exported Parameters in Existing Methods**

이 부록에서는 이 사양 이전에 게시된 EAP 방법에 대한 Session-Id, Peer-Id, Server-Id 및 Key-Lifetime을 지정합니다. 향후 EAP 방법 사양에는 Session-Id, Peer-Id 및 Server-Id\(널 문자열일 수 있음\)의 정의가 포함되어야 합니다. 다음 설명에서는 Session-Id를 구성하는 모든 필드가 네트워크 바이트 순서로 되어 있다고 가정합니다.\(MUST\)

```text
   EAP-Identity
```

- EAP-Identity 방법은 \[RFC3748\]에 정의되어 있습니다. 키를 파생하지 않으므로 Session-Id를 정의하지 않습니다. Peer-Id 및 Server-Id는 null 문자열\(길이 0\)입니다.

```text
   EAP-Notification
```

- EAP-Notification 방법은 \[RFC3748\]에 정의되어 있습니다. 키를 파생하지 않으므로 Session-Id를 정의하지 않습니다. Peer-Id 및 Server-Id는 null 문자열\(길이 0\)입니다.

```text
   EAP-MD5-Challenge
```

- EAP-MD5-Challenge 방법은 \[RFC3748\]에 정의되어 있습니다. 키를 파생하지 않으므로 Session-Id를 정의하지 않습니다. Peer-Id 및 Server-Id는 null 문자열\(길이 0\)입니다.

```text
   EAP-GTC
```

- EAP-GTC 방식은 \[RFC3748\]에 정의되어 있다. 키를 파생하지 않으므로 Session-Id를 정의하지 않습니다. Peer-Id 및 Server-Id는 null 문자열\(길이 0\)입니다.

```text
   EAP-OTP
```

- EAP-OTP 방식은 \[RFC3748\]에 정의되어 있다. 키를 파생하지 않으므로 Session-Id를 정의하지 않습니다. Peer-Id 및 Server-Id는 null 문자열\(길이 0\)입니다.

```text
   EAP-AKA
```

- EAP-AKA는 \[RFC4187\]에 정의되어 있습니다. EAP-AKA 세션 ID는 EAP 유형 코드\(0x17\)와 AT\_RAND 속성의 RAND 필드 내용, 그 뒤에 AT\_AUTN 속성의 AUTN 필드 내용을 연결한 것입니다.

```text
      Session-Id = 0x17 || RAND || AUTN
```

- Peer-Id는 처음부터 실제 ID 길이 옥텟만 사용하는 AT\_IDENTITY 속성의 ID 필드 내용입니다. 전송된 ID가 영구, 가명 또는 빠른 EAP 재인증 ID인지 여부에 관계없이 콘텐츠는 전송되는 대로 사용됩니다. Server-Id는 널 문자열\(길이 0\)입니다.

```text
   EAP-SIM
```

- EAP-SIM은 \[RFC4186\]에 정의되어 있습니다. EAP-SIM 세션 ID는 EAP 유형 코드\(0x12\)와 AT\_RAND 속성의 RAND 필드 내용, 그 뒤에 AT\_NONCE\_MT 속성의 NONCE\_MT 필드 내용을 연결한 것입니다.

```text
      Session-Id = 0x12 || RAND || NONCE_MT
```

- Peer-Id는 처음부터 실제 ID 길이 옥텟만 사용하는 AT\_IDENTITY 속성의 ID 필드 내용입니다. 전송된 ID가 영구, 가명 또는 빠른 EAP 재인증 ID인지 여부에 관계없이 콘텐츠는 전송되는 대로 사용됩니다. Server-Id는 널 문자열\(길이 0\)입니다.

```text
   EAP-PSK
```

- EAP-PSK는 \[RFC4764\]에 정의되어 있습니다. EAP-PSK 세션 ID는 EAP 유형 코드\(0x2F\)와 피어\(RAND\_P\) 및 서버\(RAND\_S\) nonce를 연결한 것입니다.

```text
      Session-Id = 0x2F || RAND_P || RAND_S
```

- Peer-Id는 ID\_P 필드의 내용이고 Server-Id는 ID\_S 필드의 내용입니다.

```text
   EAP-SAKE
```

- EAP-SAKE는 \[RFC4763\]에 정의되어 있습니다. EAP-SAKE 세션 ID는 EAP 유형 코드\(0x30\)와 AT\_RAND\_S 속성의 RAND\_S 필드 내용, 그 뒤에 AT\_RAND\_P 속성의 RAND\_P 필드 내용을 연결한 것입니다.

```text
      Session-Id = 0x30 || RAND_S || RAND_P
```

- EAP-SAKE Session-Id는 서버가 선택한 "세션 ID" 매개변수와 동일하지 않습니다. 이 매개변수는 첫 번째 메시지에서 전송되고 후속 메시지에서 복제됩니다. Peer-Id는 AT\_PEERID 속성의 값 필드 내에 포함되며 Server-Id\(사용 가능한 경우\)는 AT\_SERVERID 속성의 값 필드에 포함됩니다.

```text
   EAP-TLS
```

- EAP-TLS의 경우 Peer-Id, Server-Id, Session-Id는 \[RFC5216\]에 정의되어 있습니다.

---
# **Authors' Addresses**

```text
    Bernard Aboba
    Microsoft Corporation
    One Microsoft Way
    Redmond, WA 98052

    EMail: bernarda@microsoft.com
    Phone: +1 425 706 6605
    Fax:   +1 425 936 7329

    Dan Simon
    Microsoft Research
    Microsoft Corporation
    One Microsoft Way
    Redmond, WA 98052

    EMail: dansimon@microsoft.com
    Phone: +1 425 706 6711
    Fax:   +1 425 936 7329

    Pasi Eronen
    Nokia Research Center
    P.O. Box 407
    FIN-00045 Nokia Group
    Finland

    EMail: pasi.eronen@nokia.com
```

---
# **Full Copyright Statement**

저작권 \(C\) IETF 트러스트\(2008\).

이 문서는 BCP 78에 포함된 권리, 라이선스 및 제한 사항의 적용을 받으며 여기에 명시된 경우를 제외하고 작성자는 모든 권리를 보유합니다.

이 문서 및 여기에 포함된 정보는 "있는 그대로" 제공되며 기여자, 기여자가 대표하거나 후원하는 조직\(있는 경우\), 인터넷 협회, IETF 트러스트 및 인터넷 엔지니어링 태스크포스는 모든 내용을 부인합니다. 여기에 포함된 정보의 사용이 특정 목적에 대한 상품성 또는 적합성에 대한 권리 또는 묵시적 보증을 침해하지 않는다는 보증을 포함하되 이에 국한되지 않는 명시적 또는 묵시적 보증.

---
# **Intellectual Property**

IETF는 이 문서에 설명된 기술의 구현 또는 사용과 관련이 있다고 주장할 수 있는 지적 재산권 또는 기타 권리의 유효성 또는 범위 또는 그러한 권리에 따른 라이센스의 범위에 대해 어떠한 입장도 취하지 않습니다. 는 가능하다; 또한 그러한 권리를 식별하기 위해 독립적인 노력을 기울였다는 것을 나타내지 않습니다. RFC 문서의 권리와 관련된 절차에 대한 정보는 BCP 78 및 BCP 79에서 찾을 수 있습니다.

IETF 사무국에 제출된 IPR 공개 사본 및 사용 가능한 라이선스에 대한 보증 또는 이 사양의 구현자 또는 사용자가 이러한 독점권 사용에 대한 일반 라이선스 또는 허가를 얻으려는 시도의 결과를 얻을 수 있습니다. http://www.ietf.org/ipr의 IETF 온라인 IPR 저장소에서.

IETF는 이 표준을 구현하는 데 필요할 수 있는 기술을 포함할 수 있는 저작권, 특허 또는 특허 출원 또는 기타 소유권에 관심을 갖도록 이해 당사자를 초대합니다. 정보를 IETF\(ietf-ipr@ietf.org\)로 보내주십시오.


```text
Network Working Group                                          J. Newkirk
Request for Comments: 55                                        M. Kraley
                                                                  Harvard
                                                                J. Postel
                                                               S. Crocker
                                                                     UCLA
                                                             19 June 1970

                A Prototypical Implementation of the NCP
```

공식 프로토콜을 지정하려고 시도하는 동안 Algol과 같은 언어로 원형 NCP를 공식화하려고 시도했습니다. 몇 주간의 집중적인 노력 끝에 코드를 읽을 수 없게 되었다는 사실을 깨닫고 프로젝트가 중단되었습니다. 그러나 우리는 여전히 NCP가 구현될 수 있는 방법에 대한 우리의 개념을 입증할 필요성을 느꼈습니다. 우리는 이것이 공식적인 사양을 기존 시스템에 맞추려고 할 때 발생할 수 있는 문제에 대한 해결책을 제시하는 데 도움이 될 것이라고 생각했습니다. 이 문서는 NCP가 어떻게 생겼는지 산문 형식으로 지정하려는 시도입니다.

이러한 성격의 프로젝트에는 분명한 한계가 있습니다. 우리는 NCP를 작성해야 하는 다양한 시스템의 단점을 모두 알 수 없고 알 수도 없습니다. 우리는 환경, 시스템 호출 등에 대해 몇 가지 가정을 해야 합니다. 우리는 가능한 한 일반화하려고 노력했지만 의심할 여지 없이 많은 사이트가 NCP를 개념화하는 완전히 다른 방식을 가질 것입니다. 사물을 보는 완전히 다른 방식을 가진 사람들에게 우리의 개념과 이러한 개념을 다루는 메커니즘을 전달하는 데는 큰 어려움이 있습니다. 그러나 우리는 가상 머신을 위해 이 프로그램을 실제로 코딩함으로써 큰 ​​이점을 얻었습니다. 코딩 중에 예상치 못한 많은 문제가 발생했으며 이 문서를 발행하여 개별 사례에서 발생할 수 있는 유사한 문제를 완화하는 데 도움이 되기를 바랍니다.

물론 이 문서에 포함된 어떤 것도 구현해야 한다는 요구 사항은 전혀 없습니다. NCP가 \_반드시\_ 준수해야 하는 유일한 엄격한 규칙은 NWG/RFC#54에 명시되어 있습니다. 이 설명은 예시일 뿐이며 모델이 \_아닙니다\_.

이어지는 논의에서 우리는 먼저 가정할 환경을 설명하고 일련의 시스템 호출을 가정합니다. NCP의 전체 아키텍처와 관련 정보를 보관하는 데 사용할 테이블에 대해 논의합니다. 네트워크 운영에 대한 설명이 이어집니다. 그런 다음 이벤트의 인과 관계 순서를 개념화하기 위한 편리한 방법으로 상태 다이어그램이 제시됩니다. 그런 다음 각 유형의 네트워크 이벤트\(시스템 호출 또는 들어오는 네트워크 메시지\)의 자세한 처리에 대해 설명합니다.

---
## **II. Environment**

우리는 호스트가 프로세스에 의해 CPU가 공유되는 시분할 운영 체제를 가질 것이라고 가정합니다.

우리는 각 프로세스에 사용자 번호가 붙는다고 생각합니다. 동일한 사용자 번호를 가진 프로세스가 둘 이상 있을 수 있습니다. 그렇다면 네트워크 사용과 관련하여 모두 협력해야 합니다.

우리는 각 프로세스가 프로세스에 고유한 일련의 포트를 포함한다고 생각합니다. 이러한 포트는 프로세스, 파일, 장치 또는 기타 프로세스의 입력 또는 출력에 사용됩니다.

우리는 또한 프로세스가 LISTEN 또는 CONNECT를 시도할 때 휴면 상태\(예: 차단 또는 해제\)되지 않는 것을 구상합니다. 대신 일부 작업이 완료되면 알려줍니다. 물론 프로세스는 일부 외부 이벤트에서만 깨어나도록 자신을 닫을 수 있습니다.

네트워크 활동에 참여하기 위해 프로세스는 로컬 소켓을 해당 포트 중 하나에 연결합니다. 소켓은 사용자 번호, 호스트 및 AEN으로 식별됩니다. 두 소켓의 사용자 번호가 일치하고 동일한 호스트에 있는 경우 소켓은 프로세스에 대해 로컬입니다. 따라서 프로세스는 로컬 소켓을 참조할 때 AEN만 지정하면 됩니다.

각 포트는 시스템 호출 및 프로세스 외부의 동시 이벤트\(예: 외부 호스트의 '연결 닫기' 명령\)에 의해 수정되는 상태를 가집니다. 프로세스는 STATUS 시스템 호출을 통해 언제든지 포트의 상태를 볼 수 있습니다.

우리는 포트와 소켓 사이에 일대일 대응을 가정합니다.

---
## **III. System Calls**

이들은 사용자 프로세스가 실행할 수 있는 일반적인 시스템 호출입니다.

- 우리는 표기법을 사용합니다

```text
                  SYSCALL (ARG1, ARG2....)
```

어디

- SYSCALL은 시스템 콜의 이름이고 ARGk 등은 시스템 콜의 파라미터이다.

```text
   CONNECT (P, AEN, FS, CR)

         P        specifies a port of the process
         AEN      specifies a local socket; the user number and host are
                  implicit
         FS       specifies a socket with any user number in any hose,
                  and with any AEN
         CR       the condition code returned
```

- CONNECT는 AEN이 지정한 로컬 소켓을 포트 P에 연결하고 특정 외부 소켓 FS와의 연결을 시작하려고 시도합니다. CR의 가능한 값은 다음과 같습니다.

- CR=OK CONNECT가 합법적이고 소켓 FS에 접속 중입니다. 연결이 설정되거나 거부되면 상태가 업데이트됩니다.

- CR = BUSY 로컬 소켓이 사용 중입니다\(잘못된 명령 시퀀스\).

- CR = BADSKT 소켓 사양이 잘못되었습니다.

- CR = NOROOM 로컬 호스트의 리소스가 소진되었습니다.

```text
         CR = HOMOSEX   Incorrect send/receive pair
```

- CR = IMP DEAD 임프가 사망했습니다.

- CR = LINK DEAD 다음과 같은 이유로 외부 호스트에 대한 링크가 작동하지 않습니다. 1. 외부 Imp가 작동하지 않거나 2. 외부 호스트가 작동하지 않거나 3. 외부 NCP가 응답하지 않습니다.

```text
   LISTEN (P, AEN, CR)

         P             specifies a port of the process
         AEN           specifies a local socket
         CR            the condition code returned
```

- AEN이 지정한 로컬 소켓은 포트 P에 연결되어 있습니다. 보류 중인 호출이 있으면 처리됩니다. 그렇지 않으면 아무 조치도 취하지 않습니다. 전화가 오면 사용자에게 알려줍니다. 전화를 검토한 후 그는 수락하거나 거부할 수 있습니다. CR의 가능한 값은 다음과 같습니다.

```text
         CR = OK         Connection begun, listening

         CR = BUSY

         CR = NOROOM

         CR = IMP DEAD

         CR = LINK DEAD

   ACCEPT (P, CR)

         P       specifies a port of the process
         CR      the condition code returned
```

- 수락은 사용자 프로세스가 외부 소켓을 검사하여 누가 호출하고 호출을 수락할지 결정했음을 의미합니다. \(참고: 흥미로운 대안은 ACCEPT를 암시적 기본 조건으로 정의합니다. 따라서 들어오는 모든 RFC는 자동으로 LISTEN을 충족합니다.\) 가능한 CR 값은 다음과 같습니다.

```text
         CR = BADSKT

         CR = NOROOM

         CR = IMP DEAD

         CR = LINK DEAD
```

- CR = BADCOMM 잘못된 명령 시퀀스. \(예: LISTEN 이전에 발행된 Accept.

- CR = PREMCLS 외부 사용자가 RFC를 로컬에서 수신한 후 Accept가 실행되기 전에 연결을 중단했습니다.

```text
   TRANSMIT (P, BUFF, BITSRQST, BITSACC, CR)

         P        specifies a port of the process
         BUFF     specifies the text buffer for transmission
         BITSRQST specifies the length to be transmitted in bits
         BITSACC  returns the number of bits actually transmitted
         CR       the condition code returned
```

- 전송이 이루어집니다. CR에 가능한 값은 다음과 같습니다.

```text
         CR = OK

         CR = IMP DEAD

         CR = LINK DEAD
```

CR = NOT OPEN 연결이 열려 있지 않습니다\(잘못된 명령

-                    순서\).

- CR = 범위를 벗어난 BAD BOUND BITSRQST\(예: 수신 소켓의 경우 BUFF가 표시된 BITSRQST보다 짧음\).

```text
   INT (P, CR)

         P       specifies the local socket of this process
         CR      the condition code returned
```

- 이 포트의 다른 쪽\(외부\)에 있는 프로세스가 중단됩니다. CR의 가능한 값은 다음과 같습니다.

```text
         CR = OK

         CR = BADSKT

         CR = BADCOMM

         CR = IMP DEAD

         CR = LINK DEAD

   STATUS (P, RTAB, CR)

         P       specifies a port of this process
         RTAB    the returned rendezvous table entry
         CR      the condition code returned
```

- 이 포트와 관련된 랑데부 테이블 항목의 관련 필드는 RTAB에서 반환됩니다. 이것은 사용자 프로세스가 연결 상태를 모니터링하기 위해 사용하는 메커니즘입니다. CR의 가능한 값은 다음과 같습니다.

```text
         CR = OK

         CR = BADSKT

   CLOSE (P, CR)

         P       specifies a port of this process
         CR      the condition code returned
```

- 이 포트에 연결된 연결에 대한 활동이 중지되고 연결이 끊어지고 포트가 다른 용도로 사용 가능해집니다. CR의 가능한 값은 다음과 같습니다.

```text
         CR = OK

         CR = BADSKT

         CR = BADCOMM

         CR = IMP DEAD

         CR = LINK DEAD
```

---
## **IV.  The NCP - Gross Structure**

우리는 NCP가 5개의 구성 요소 프로그램, 여러 연관 테이블, 일부 대기열 및 버퍼를 가지고 있다고 봅니다.

```text
      The Component Programs (see Fig. 4.1)
```

- 1. 입력 핸들러

- 이것은 인터럽트 구동 루틴입니다. Imp-to-Host 전송을 상주 버퍼로 시작하고 전송이 완료되면 입력 인터프리터를 깨웁니다.

- 2. 출력 핸들러

- 인터럽트 구동 출력 루틴입니다. 상주 버퍼에서 Host-to-Imp 전송을 시작하고 전송이 완료되면 출력 스케줄러를 깨웁니다.

- 3. 입력 해석기

- 이 프로그램은 입력이 사용자를 위한 일반 메시지인지, 네트워크 제어 메시지인지, Imp-to Host 메시지인지 또는 오류인지를 결정합니다. 메시지의 각 클래스에 대해 이 프로그램은 서브루틴을 호출하여 적절한 조치를 취합니다.

- 4. 출력 스케줄러

- 세 가지 종류의 메시지가 임프에게 전송됩니다.

```text
            (a) Host-to-Imp messages
            (b) Control messages
            (c) Regular messages
```

- 우리는 이러한 클래스들 사이에 우선순위가 부여되어야 한다고 믿습니다. 우리가 제안하는 우선 순위는 위의 순서입니다. 출력 스케줄러는 우선 순위가 가장 높은 메시지를 선택하여 출력 처리기로 전달합니다.

- Host-to-Imp 메시지는 선착순으로 처리됩니다. 제어 메시지는 호스트에 의해 개별적으로 처리되며 각 호스트는 차례로 가져옵니다. 각 외부 호스트에 대한 제어 메시지 큐가 제공됩니다. 특정 호스트가 출력되도록 예약되면 해당 호스트에 대한 제어 명령이 하나의 메시지로 연결됩니다. 일반 메시지는 호스트 및 링크별로 그룹으로 처리되며 각각의 고유한 조합이 차례로 사용됩니다.

- 5. 시스템 콜 인터프리터

- 이 프로그램은 사용자의 요청을 해석합니다. 각 시스템 호출에는 적절한 조치를 취하는 해당 루틴이 있습니다.

- 두 가지 흥미로운 구성 요소는 입력 인터프리터와 시스템 호출 인터프리터입니다. 이들은 입력 인터프리터가 외부 요청을 처리하고 시스템 호출 인터프리터가 로컬 요청을 처리한다는 점에서 유사합니다.

- 그림 4.1의 다이어그램은 네트워크 제어 프로그램의 개념입니다. 물렁물렁한 아메바와 같은 물체는 구성 요소 프로그램을 나타내고 실린더는 큐를 나타내고 화살표는 데이터 경로를 나타냅니다. 이 단순화된 다이어그램에서는 테이블이 표시되지 않습니다. \[원본 손 그림의 "아메바 같은" 개체는 이제 단단한 직사각형 상자입니다: Ed.\]

- 그림의 약어 라벨은 다음과 같은 의미를 갖습니다.

```text
            HIQ       -     Host-to-Imp Queue
            OCCQ      -     Output Control Command Queue
            DQ        -     Data Queue
            IHBUF     -     Input Handler Buffer
            OHBUF     -     Output Handler Buffer

             ____________
            |    USER    |    STRUCTURE OF THE NETWORK CONTROL PROGRAM
            |____________|
               ^      |                      Fig. 4.1
          _____|______V____
         |                 |
         |     System      |
         |      Call       |
         |   Interpreter   |
         |_________________|              _____________
            ^  |      |                  |             |
            |  |      |  +---------------|    Input    |
            |  |      |  |         +-----| Interpreter |
            |  |      |  |         |     |             |
            |  V      V  V         V      -------------
          |======| |=========| |=======|     |      ^
          | D Q  | | O C C Q | | H I Q |     |      |
          |======| |=========| |=======|     |      |
            |  ^        |          |         |      |
            |  |        |          |         |      |
            |  +--------)----------)---------+      |
            |           |          |                |
            +-------+   |   +------+                |
                  __V___V___V__                     |
                 |             |                    |
                 |   Output    |                    |
                 |  Scheduler  |                    |
                 |_____________|                    |
                        |                           |
                        V                           |
                  (===========)               (===========)
                  ( O H B U F )               ( I H B U F )
                  (===========)               (===========)
                        |                           ^
                  ______V______               ______|______
                 |             |             |             |
                 |   Output    |             |    Input    |
                 |   Handler   |             |   Handler   |
                 |             |             |             |
                  -------------               -------------
                        |                           ^
                        |                           |
                        +----------+    +-----------+
                                   |    |
                               ____V____|____
                              |              |
                              |     I M P    |
                              |______________|
```

---
## **V. Tables in the NCP**

우리는 NCP 데이터베이스의 대부분이 연관 테이블에 있다고 생각합니다. "연관"이란 키와 함께 제공되고 해당 항목에 대한 포인터와 함께 성공적으로 반환되거나 키에 해당하는 항목이 없으면 실패하는 검색 루틴이 있음을 의미합니다. 주요 테이블은 다음과 같습니다.

- 1. 랑데부 테이블

- 이 테이블은 연결 속성을 보유합니다. 테이블은 로컬 소켓에 의해 액세스되지만 다른 테이블에는 기존 항목에 대한 포인터가 있을 수 있습니다.

- 항목의 구성 요소는 다음과 같습니다.

\(a\) 로컬 소켓

- \(b\) 외부 소켓 \(c\) 링크 \(d\) 연결 상태 \(e\) 흐름 상태 \(f\) 데이터 큐 \(g\) 호출 큐 \(h\) 포트 포인터 \(i\) 버퍼 크기\(전송 측에서만 필요\) \(j\) 오류 상태

- CONNECT 또는 LISTEN 시스템 호출이 실행되거나 연결 요청이 수신되면 항목이 생성됩니다. 다양한 필드는 연결이 설정될 때까지 사용되지 않습니다.

- 2. 입력 링크 테이블

- 입력 해석기는 외부 호스트의 연결을 사용하고 입력 테이블에 대한 키로 링크합니다. 이 테이블은 랑데부 테이블에 대한 포인터를 제공하여 들어오는 링크에서 사용자 대상 메시지를 처리하는 데 사용됩니다.

- 3. 출력 링크 테이블

- 입력 해석기는 전송된 메시지에서 RFNM의 반환으로 흐름 상태에 액세스하기 위해 출력 링크 테이블을 사용합니다. 출력 링크 테이블은 호스트 및 링크에 의해 키 지정되며 랑데부 테이블에 대한 포인터를 제공합니다.

- 4. 포트 테이블

- 시스템 호출 인터프리터는 랑데부 테이블에 대한 포인터를 얻기 위해 프로세스 식별과 포트 식별의 연결을 키로 사용합니다.

- 5. 출력 제어 명령어 표

- 시스템 호출 인터프리터와 입력 인터프리터는 이 테이블을 사용하여 적절한 출력 제어 명령 큐에 항목을 만듭니다. 명령은 외부 호스트에 해당하는 별도의 테이블 항목에 대기합니다. 출력하기 전에 대기열의 내용이 큰 제어 메시지로 연결됩니다. 항목의 구성 요소는 다음과 같습니다.

```text
            (a)  Host
            (b)  Output Control Command Queue
```

- 6. 출력 요청 큐

- 이 대기열에는 네트워크로 전송해야 하는 데이터가 있는 각 연결에 대한 항목이 포함되어 있습니다. 연결당 하나의 항목만 있으며 마지막 데이터 패킷이 전송될 때 삭제되고 사용자가 시스템에서 데이터 전송을 요청할 때마다 입력됩니다.

- 전송이 완료되지 않았거나\(메시지가 너무 김\) 흐름 제어 메커니즘에 의해 차단된 경우 항목이 다시 삽입됩니다. 항목의 유일한 구성 요소는 로컬 소켓입니다.

- 7. 호스트 라이브 테이블

- 이것은 살아 있는 호스트를 나열하는 간단한 테이블입니다. 이 테이블은 연결을 설정하기 전과 대상 호스트가 실제로 존재하는지 확인하기 위해 데이터를 보내기 전에 검사됩니다. 현재 프로토콜은 호스트 작동/호스트 작동 중지 조건에 대해 따라야 할 절차를 정의하지 않습니다. NWG/RFC#57을 참조하십시오.

- 8. 링크 할당 테이블

- 링크 번호는 수신자가 할당합니다. 이 테이블은 사용 가능한 링크를 기록하므로 할당할 수 있습니다.

---
## **VI.  Informal Description of Network Operations**

여기에서 네트워크 사용의 세 가지 주요 단계인 열기, 흐름 제어 및 닫기 중에 수행되는 작업을 설명하는 내러티브를 제시합니다.

```text
   A. Opening
```

- 데이터 전송을 위한 연결을 설정하기 위해서는 한 쌍의 RFC를 교환해야 합니다. RTS는 수신측에서 송신측으로 이동해야 하며 송신측에서 수신측으로 STR을 발행해야 합니다. 또한 RTS에서 수신측은 링크 번호를 지정해야 합니다. 이러한 RFC\(RFC는 RTS 및 STR을 포괄하는 일반 용어\)는 임의의 시간 순서로 발행될 수 있습니다. 보류 중인 호출\(즉, 사용자 프로그램에서 처리하지 않은 RFC\)을 대기시키기 위한 준비도 이루어져야 합니다. 따라서 사용자가 연결을 마치면 다른 프로세스에서 보류 중인 다음 호출을 검토하고 연결 요청을 수락할지 거부할지 결정할 수 있습니다. 사용자가 보류 중인 통화를 검토하도록 선택하지 않을 수 있기 때문에 문제가 발생합니다. 따라서 그들은 단지 NCP에서 대기열 공간을 차지하는 역할만 할 것입니다. 이 문제에 대한 몇 가지 대안 솔루션은 나중에 언급될 것입니다.

- 위에서 설명한 프로토타입 시스템 호출의 프레임워크를 활용하여 성공적으로 열린 연결을 얻기 위한 최소 4개의 시간 시퀀스를 구상합니다.

- 1. 사용자는 자신에게 RFC를 보내는 누구에게나 연결을 고려할 의향이 있음을 나타내는 LISTEN을 발행할 수 있습니다. RFC가 들어오면 사용자에게 알립니다. 그런 다음 사용자는 이 소켓에 연결할지 여부를 결정하고 해당 결정에 따라 ACCEPT 또는 CLOSE를 발행합니다. CLOSE는 "닫기"에서 설명한 것처럼 연결을 '거부'합니다. ACCEPT는 연결하려는 의사가 있음을 나타냅니다. RFC가 발행되고 연결이 완전히 열립니다.

- 2. LISTEN에 대한 사용자 요청을 처리할 때 NCP는 해당 로컬 소켓에 대해 보류 중인 호출이 있음을 발견합니다. 사용자는 즉시 알림을 받고 위와 같이 수락하거나 닫을 수 있습니다.

- 3. 사용자는 연결하려는 특정 외부 소켓을 지정하여 CONNECT를 발행합니다. RFC가 발행됩니다. 외부 프로세스가 요청을 수락하면 RFC를 반환하여 응답합니다. 이 승인 RFC를 수신하면 연결이 열립니다.

- 4. CONNECT가 제공되면 NCP는 지정된 외부 소켓에서 문제의 로컬 소켓으로 보류 중인 호출이 있음을 발견할 수 있습니다. 승인 RFC가 발급되고 연결이 열립니다.

- 위의 모든 경우에 연결이 열릴 때 사용자에게 통지되지만 버퍼 공간이 할당되고 ALL 명령이 전송될 때까지 데이터 흐름을 시작할 수 없습니다.

```text
      Any of these connection scenarios will be interrupted if a CLS
      comes in, as discussed under "Closing."

         1. Pending Call Queues
```

- 보류 중인 RFC에 대한 대기열 형식을 구현하는 것이 필수적입니다. 이를 확인하는 간단한 방법은 일반적인 LISTEN-CONNECT 시퀀스를 검사하는 것입니다. 한쪽은 LISTEN을 발행하고 다른 쪽은 CONNECT를 발행합니다. 원격 CONNECT에서 오는 RFC가 도착하기 전에 LISTEN이 발행되면 모든 것이 정상입니다. 그러나 네트워크의 비동기 특성으로 인해 이러한 일련의 이벤트가 발생한다고 보장할 수 없습니다. 호출이 대기열에 있지 않고 LISTEN이 실행되기 전에 RFC가 들어오면 거부됩니다. 나중에 도착하면 수락됩니다. 따라서 우리는 매우 모호한 상황에 처해 있습니다.

- 대기열 공간이 무한하지 않은 경우 사용자가 전혀 검토하지 않은 이전 RFC의 대기열을 제거하기 위한 일부 메커니즘이 바람직합니다. 명백하지만 비공식적인 방법은 각 RFC가 대기열에 들어가는 시간을 기록한 다음 임의의 시간 제한을 초과한 모든 RFC를 주기적으로 거부하는 것입니다. 체계의 맥락에 포함되어야 하는 또 다른 생각은 사용자가 로그아웃하거나 폭발할 때 NCP가 모든 미결 연결 또는 보류 중인 통화에 대해 CLS를 보내는 것입니다.

- 이 설명에서 활용되는 체계는 언뜻 보기에 직관적이지 않은 것처럼 보일 수 있습니다. 그러나 우리는 그것이 다른 제안보다 더 현실적이라고 생각합니다. 기본적으로 CONNECT가 발행되면 NCP는 이 소켓이 지정된 외부 소켓과 해당 소켓과만 통신하기를 원한다고 가정합니다. 따라서 CLS를 다시 전송하여 보류 중인 호출 대기열에서 일치하지 않는 모든 RFC를 제거합니다. 마찬가지로 연결이 RFC-SEND 상태에 있을 때\(CONNECT가 발행됨\) 일치하지 않는 모든 RFC는 거부됩니다. LISTEN- ACCEPT 또는 LISTEN- CLOSE 시퀀스가 ​​실행되면 나머지

- 사용자가 나중에 이러한 요청을 수락하기를 원할 것으로 예상하여 대기 중인 통화 중 가 대기열에서 제거되지 않습니다.

- 후자의 방법이 임의적이거나 불필요하게 제한적인 것처럼 보일 수 있지만 유능한 프로그래머\(즉, 경쟁 조건과 네트워크의 비동기 특성을 경계하는 사람\)를 다루고 있다고 가정하여 이 방법으로 금지되는 시나리오를 아직 만들지 않았습니다. 물론 특정 사이트가 선택하는 체계는 구현에 크게 의존합니다. 위에서 언급한 CONNECT-clear 체계에서 유지되는 최소한의 시간 동안 RFC의 큐잉을 위한 일부 조항을 제공할 것을 제안합니다.

```text
   B. Flow Control
```

- 의미 있는 데이터는 연결이 완전히 열린 경우에만 연결에서 흐를 수 있습니다\(즉, 두 개의 RFC가 교환되고 닫기가 시작되지 않음\). 우리는 NCP가 들어오는 데이터를 수신하기 위한 버퍼를 가지고 있고 그들이 처리할 수 있는 크기 메시지를 나타내는 \(연결당 기준으로\) 광고할 수 있는 의미 있는 양이 있다고 가정합니다. 또한 보내는 쪽이 해당 크기의 광고에 따라 전송을 규제한다고 가정합니다.

- 연결이 열리면 셀\('그들의 크기'라고 함\)이 0으로 설정됩니다. 수신 측은 할당할 수 있는 공간을 결정하고 해당 공간을 지정하는 ALL 메시지를 보냅니다. 송신측은 할당된 공간만큼 'Their Size'를 증가시키고 'Their Size'보다 작거나 같은 길이의 메시지를 보낼 수 있습니다. 메시지가 전송될 때 메시지 길이는 'Their Size'에서 뺍니다. 수신측에서 더 많은 버퍼 공간을 할당하면\(예: 사용자가 메시지를 받아 일부 시스템 버퍼 공간이 비워지는 경우\) 해제된 비트 수가 ALL 메시지를 통해 송신측으로 전송됩니다.

- 따라서 'Their Size'는 절대 음수가 될 수 없으며 'Their Size'가 0이면 전송이 수행되지 않습니다.

- 모든 메시지에 지정된 길이는 수신 버퍼의 절대 크기가 아닌 증가분입니다. 이는 흐름 제어 프로토콜의 전이중 특성에 의해 필요합니다. ALL 메시지의 길이 필드는 길이가 32비트가 될 수 있으므로\(참고: 이것은 부호 없는 정수임\) 원하는 경우 기본적으로 무한 "비트 싱크"에 대한 기능을 제공합니다.

```text
   C. Closing
```

- 연결을 여는 데 두 개의 RFC가 필요한 것처럼 연결을 닫는 데 두 개의 CLS가 필요합니다. 종료는 다양한 상황에서 발생하며 여러 목적을 수행합니다. 경합 조건 분석을 단순화하기 위해 중단, 거부, 수신자에 의한 종료, 발신자에 의한 종료의 네 가지 경우를 구분합니다.

- 사용자는 CONNECT를 발행한 다음 CONNECT가 확인되기 전에 CLOSE를 발행하면 연결을 "중단"합니다. 일반적으로 사용자는 승인을 오래 기다린 후에 중단합니다. 그가 폭파하면 그의 시스템도 그를 위해 중단될 수 있습니다.

- 사용자는 LISTEN을 발행하고 예상 호출자에 대한 알림을 받은 후 CLOSE를 발행할 때 연결을 "거부"합니다. 특정 소켓의 호출을 기대하는 소켓에 대한 모든 연결 요청도 거부됩니다.

- 연결이 설정된 후 어느 쪽이든 종료할 수 있습니다. 이벤트의 필수 시퀀스는 수신측에서 CLOSE하려는 시도를 항상 송신측에서 가능한 한 빨리 처리하는 "요청"으로 보아야 함을 나타냅니다. 아직 사용자에게 전달되지 않았거나 네트워크를 통해 계속되는 모든 데이터는 삭제됩니다. 송신 측의 CLOSE 요청은 모든 데이터 전송이 완료되는 즉시 수락됩니다.

```text
         1. Aborting

            We may distinguish three cases:
```

- a\) 가장 간단한 경우 RFC를 보내고 나중에 CLS를 보냅니다. 상대방은 CLS로 응답하고 연결 시도가 종료됩니다.

b\) 외부 프로세스는 연결을 수락할 수 있습니다.

- 로컬 프로세스가 중단하는 것과 동시에. 이 경우 외부 프로세스는 로컬 프로세스가 열린 연결을 종료한다고 믿을 것입니다.

c\) 외부 프로세스는 연결을 거부할 수 있습니다.

- 로컬 프로세스가 중단하는 것과 동시에. 이 경우 외국 프로세스는 국내 프로세스가 거부를 인정한다고 믿을 것입니다.

```text
         2. Refusing
```

- RFC를 수신한 후 로컬 호스트는 RFC 또는 CLS로 응답하거나 응답하지 않을 수 있습니다. \(로컬 호스트는 이미 자신의 RFC 등을 보냈을 수 있습니다.\) 로컬 호스트가 CLS를 보내는 경우 로컬 호스트는 연결 요청을 "거부"한다고 합니다.

- 연결을 종료하려면 CLS 명령을 교환해야 하므로 로컬 호스트는 CLS 승인이 반환될 때까지 랑데부 테이블 항목을 유지해야 합니다.

- 3. 발신자에 의한 해지

- 송신 측의 사용자가 CLOSE 시스템 호출을 발행하면 그의 NCP는 즉시 이를 수락해야 하지만 로컬 버퍼의 모든 데이터가 외부 호스트로 전달될 때까지 CLS 명령을 보낼 수 없습니다. 따라서 CLS 명령을 보내기 전에 '버퍼 비움'과 'RFNM 수신'을 모두 테스트해야 합니다. 평소와 같이 항목을 삭제하기 전에 CLS를 확인해야 합니다.

- 4. 수신자에 의한 종료

- 수신측 사용자가 CLOSE 시스템 호출을 발행하면 그의 NCP는 즉시 CLS 명령을 수락하고 전송합니다. 그러나 데이터가 계속 도착할 수 있으므로 이 데이터를 버려야 합니다. 송신측은 CLS를 수신하는 즉시 데이터 흐름을 종료해야 합니다.

---
## **VII. Connection Status**

연결을 설정하고 종료하는 데 필요한 일련의 이벤트를 설명하는 훌륭한 메커니즘에는 상태 다이어그램이 포함됩니다. 우리는 각 소켓이 상태 머신과 연결될 수 있고 이 상태 머신이 언제든지 가능한 10가지 상태 중 하나에 있을 수 있다고 가정할 수 있습니다. 어떤 상태에서든 특정 네트워크 이벤트로 인해 연결 상태가 다른 상태로 전환됩니다. 다른 이벤트는 무시됩니다. 여전히 다른 사람들은 오류입니다. 전환에는 일부 작업을 수행하는 로컬 NCP가 포함될 수도 있습니다. 그림 7.1은 상태 머신을 보여줍니다. 원\[현재 상자: Ed\]은 상태를 나타냅니다\(아래에 설명됨\). 화살표는 상태 간의 법적 전환을 보여줍니다. 화살표의 레이블은 원인이 된 이벤트를 식별합니다\(CLOSE는 시스템 호출이고 CLS는 제어 명령임\). 슬래시 뒤의 문구는 해당 화살표 위로 이동하는 동안 수행해야 하는 작업을 나타냅니다. '\[E\]RFC'\(상태 0과 1 사이에 있음\)라는 레이블이 붙은 화살표는 다음을 나타냅니다.

연결이 CLOSED 상태에 들어갈 때마다 해당 연결에 대한 대기 중인 호출 대기열이 확인되는 조건 \[Original was backwards "E": Ed.\]

대기 중인 통화가 대기열에 있으면 연결이 PENDING 상태로 이동합니다. CLOSED 상태의 소켓에 대해 RFC가 수신되면 이 경로를 따라 PENDING 상태로 이동됩니다. 이벤트와 이벤트로 인한 조치는 아래 VIII 및 IX 섹션에 설명되어 있습니다. 10개 상태에 대한 설명은 다음과 같습니다.

```text
      (0) CLOSED
```

- 로컬 소켓이 어떤 포트에도 연결되어 있지 않으며 사용자가 연결을 요청하지 않았습니다. \(테이블 항목이 존재하지 않습니다\).

```text
      (1) PENDING CALL
```

- 소켓이 어떤 포트에도 연결되어 있지 않지만 하나 이상의 연결 요청이 수신되었습니다. LISTEN 시스템 호출은 일치하는 요청에 대해 보류 중인 호출 대기열의 첫 번째 항목에 의해 즉시 충족됩니다. 다른 모든 보류 중인 통화는 삭제됩니다.

```text
      (2) LISTENING
```

- 소켓이 포트에 연결되어 있습니다. 사용자가 이 소켓과의 연결을 요청하기를 기다리고 있습니다.

```text
      (3) RFC-RCVD
```

- 듣고 있으며 RFC를 받았습니다. 로컬 사용자에게 보류 중인 통화가 있음을 알렸습니다. 그는 CLOSE 또는 ACCEPT로 응답해야 합니다.

```text
      (4) ABORT
```

- 사용자에게 LISTEN에 만족했지만 아직 응답하지 않았음을 알렸습니다. 이 시간 동안 외부 사용자가 CLS를 보내 연결을 중단하면 CLS를 보내 중단을 확인하고 사실을 이 상태로 표시합니다. 사용자가 통화를 수락하거나 거부하면 연결이 조기에 종료되었음을 알릴 수 있습니다.

```text
      (5) RFC-SENT
```

- 이 상태는 다음과 같은 경우에 들어갑니다.

- a\) 로컬 사용자가 CONNECT를 발행하여 이 소켓을 포트에 연결했습니다. b\) RFC가 전송되었으며 c\) 응답이 수신되지 않았습니다.

- 사용자가 CONNECT를 발행하면 보류 중인 통화 큐가 검색됩니다.

- 일치하는 RFC가 없으면 대기열이 삭제되고 이 상태로 들어갑니다. 새로운 RFC가 도착하면 사용자의 요청과 비교됩니다. 일치하지 않으면 RFC가 즉시 거부됩니다. RFC가 일치하면 초기화 프로세스를 완료하고 연결이 OPEN 상태가 됩니다.

```text
      (6) OPEN
```

- RFC가 교환되었으며 연결이 안전하게 설정되었습니다. 전송은 수신측에서 ALL 명령을 수신한 후 시작될 수 있으며 흐름 제어에 따라 진행됩니다.

```text
      (7) CLS-WAIT
```

- 로컬 사용자가 CLOSE를 실행하고 CLS를 실행한 후 연결이 완전히 닫히기 전에 승인 CLS를 기다려야 합니다. 적절한 CLS가 아직 수신되지 않은 경우 이 상태에 들어갑니다.

```text
      (8) DATA-WAIT
```

- 송신 측에 있고 로컬 사용자가 CLOSE 시스템 호출을 실행하는 경우 데이터 버퍼가 비어 있지 않거나 마지막 데이터 메시지에 대한 RFNM이 미해결인 경우 CLS를 실행할 수 없습니다. 연결은 이러한 조건이 충족될 때까지 대기하기 위해 이 상태로 들어갑니다. 출력이 완료되고 확인되면 CLS가 발행되고 연결이 CLS-WAIT 상태가 되어 확인하는 CLS를 기다립니다. DATA-WAIT 상태에 있는 동안 CLS가 도착하면 버퍼를 지우고\(CLS는 수신 소켓에서 왔으며 더 이상 데이터에 관심이 없음을 나타냄\) RFNM-WAIT 상태로 들어가 네트워크가 지워질 때까지 기다립니다.

```text
      (9) RFNM-WAIT
```

- 송신 측에 있고 CLS 명령이 도착하면 마지막 데이터 메시지에 대한 RFNM을 수신하지 않은 경우 승인 CLS를 발행할 수 없습니다. RFNM을 기다리기 위해 이 상태로 들어가고 모든 추가 데이터 전송을 중단합니다. RFNM이 들어오면 CLS가 발급될 수 있으며 연결이 닫힙니다.

```text
                      ______________
                     |              |       CLOSE
      CONN/          |    CLOSED    |<---------------------------+
      send RFC       |     (0)      |       LISTEN               |
    +----------------|              |-----------------------+    |
    |                |______________|                       |    |
    |                     |    ^                            |    |
    |              [E]RFC |    |  CLS/send CLS              |    |
    |                  ___V____|____                     ___V____|____
    |  non-matching   |             |                   |             |
    |  CONN/send RFC  |   PENDING   | LISTEN        RFC |  LISTENING  |
    |   +-------------|    (1)      |----------+   +----|     (2)     |
    |   |             |_____________|          |   |    |_____________|
    |   |       matching     |                 |   |
 ___V___V_____  CONN/send RFC|               __V___V______
|             |              |     ACCEPT/  |             | CLS/
|   RFC-SENT  | RFC          |     send RFC |   RFC-RECD  | send CLS
|     (5)     |----------+   |   +----------|     (3)     |---------+
|_____________|          |   |   |          |_____________|         |
   |   |                 |   |   |               |                  |
   |   |              ___V___V___V___  SND&CLOSE |   ____________   |
   |   |    RCV&CLS/ |               |-----------)->|            |  |
   |   |    send CLS |      OPEN     | SND&CLS   |  |  DATA-WAIT |  |
   |   |   +---------|      (6)      |--------+  |  |    (8)     |  |
   |   |   |         |_______________|        |  |  |____________|  |
   |   |   |      RCV&CLOSE/ |                |  |   |              |
   |   |   |       send CLS  |                |  |   |              |
   |   |   |                 |                |  |   | CLS          |
   |   |   |           ______V______          |  |   |              |
   |   |   |   CLOSE/ |             |CLOSE/   |  |   |              |
   |   |   |  send CLS|   CLS-WAIT  |send CLS |  |   |              |
   |   +---)--------->|     (8)     |<--------)--+   |              |
   |       |          |_____________|         |      |              |
   |       |                 |             ___V______V_       ______V___
   |       |                 |            |            |     |          |
   |       |                 |            |  RFNM-WAIT |     |   ABORT  |
   |       |             CLS |            |     (9)    |     |    (4)   |
   |       |                 |            |____________|     |__________|
   |       |                 |                   |                 |
   |       |           ______V_______  RFNM/     |                 |
   |       |          |              | send CLS  |                 |
   |  CLS/ +--------->|    CLOSED    |<----------+                 |
   | send CLS         |     (0)      |                ACCEPT|CLOSE |
   +----------------->|              |<----------------------------+
                      |______________|

                         Figure 7.1
                  Connection State Diagram
```

---
## **VIII.  Algorithms for the Input Interpreter**

다음은 들어오는 네트워크 명령에 대한 NCP의 응답에 대한 간결한 설명입니다. CS는 항상 연결 상태를 나타냅니다. CLOSE는 로컬 사용자 프로세스에 의해 실행되는 시스템 호출이고 CLS는 네트워크 명령입니다.

```text
   NOP

      Discard.

   RFC (RTS or STR)
```

- 항목이 없으면 status = PENDING CALL인 항목을 만들고 메시지를 대기열에 넣습니다.

- CS = LISTENING이면 항목을 대기열에 넣고 RFC-RCVD 상태로 들어가 사용자에게 요청을 알립니다.

- CS = RFC-SENT이지만 새 RFC가 요청과 일치하지 않는 경우 RFC를 거부합니다.

- 다른 모든 경우에는 RFC에서 일치하는지 확인하십시오. 존재하지 않는 경우 RFC를 큐에 넣습니다. RFC가 일치하면 다음과 같습니다.

- CS = RFC-SENT, OPEN 상태로 들어갑니다.

- CS = CLOSE-WAIT, RFC가 무시됩니다.

- 그렇지 않으면 요청이 이미 수신되었음을 나타내는 모든 상태\(이러한 상태는 1,3,4,6,8,9\)에서 요청이 불법입니다.

- 어떠한 경우에도 RFC를 처리하는 과정에서 오버플로 상태\(리소스 소진\)가 발생하면 연결을 거부합니다\(CLS 전송\).

```text
   CLS
```

- 대기 중인 통화 대기열이 검색됩니다. CLS가 현재 요청과 일치하지 않지만 다른 요청과 일치하는 경우 해당 요청을 삭제하고 CLS를 실행합니다. 일치하는 항목이 없으면 CLS가 무시됩니다.

```text
      If the CLS matches the current request, and CS =
```

- PENDING, 현재 요청을 삭제합니다. 요청 대기열이 비어 있으면 항목을 삭제합니다. 그렇지 않으면 항목을 그대로 둡니다.

RFC-RCVD, CLS를 발행하고 ABORT 상태로 들어갑니다.

- 중단, 무시합니다.

- RFC-SENT, CLS를 발행합니다. 보류 중인 통화 대기열이 비어 있으면 항목을 삭제하고 그렇지 않으면 PENDING 상태로 들어갑니다.

- OPEN, 수신측이면 응답은 RFC-SENT에 대한 응답과 동일합니다. 송신 측에 있는 경우 데이터 대기열을 지우고 RFNM이 아직 보류 중인 경우 RFNM-WAIT 상태로 들어갑니다. 그렇지 않으면 응답은 RFC-SENT에 대한 응답과 동일합니다.

- CLS-WAIT, CLS를 발행하고 보류 중인 통화 대기열이 비어 있으면 항목을 삭제하고 그렇지 않으면 CS = PENDING.

- DATA-WAIT, 데이터 대기열을 지우고 RFNM-WAIT 상태로 들어갑니다. CLOSED 또는 LISTENING 상태에서는 일치하는 CLS가 발생할 수 없습니다.

```text
   ERR
```

- 오류는 나중에 시스템 프로그래머가 주의를 기울이도록 대기하며 교환을 시작한 호스트의 시스템 오류로 간주됩니다. \(어떤 주와도 연관되지 않음\).

```text
   ECO
```

- op 코드가 ERP로 변경되어 재전송됩니다\(어떤 상태와도 연관되지 않음\).

```text
   ERP
```

- ERP를 수신하면 시스템은 명령 텍스트를 ECO를 발행한 프로세스로 다시 전달합니다.

```text
   INR, INS
```

- 이 명령은 OPEN 상태에서만 활성화됩니다. INTERRUPT를 수신하면 시스템은 관련 프로세스에 이벤트를 전송합니다. CLS-WAIT, DATA-WAIT 및 RFNM-WAIT 상태에서는 INTERRUPT가 무시됩니다. 다른 상태에서는 오류입니다.

```text
   ALL
```

- ALLOCATE는 OPEN 상태에서만 유효하며 송신 소켓에만 보낼 수 있습니다. NCP는 ALLOCATE 명령에 지정된 크기만큼 연관된 랑데뷰 테이블 항목의 'Their Size' 필드를 증가시킵니다.

- CLS-WAIT 및 DATA-WAIT 상태에서 이 명령은 무시됩니다. 다른 상태에서는 오류입니다.

```text
   Data-RFNM
```

- OPEN 상태인 ​​경우 적절한 랑데부 테이블 항목의 흐름 제어 상태 필드를 RFNM-RECVD로 표시하고 필요한 경우 추가 데이터를 보냅니다.

- DATA-WAIT 상태이면 Flow Control Status를 유지한다. 데이터 대기열이 비어 있으면 CLS를 실행하고 CLS-WAIT 상태로 들어갑니다. 그렇지 않으면 다음 메시지를 전송합니다.

- RFNM-WAIT 상태이면 Flow Control Status를 유지하고 CLS를 발행한다. 대기 중인 통화 대기열이 비어 있는 경우 랑데뷰 테이블 항목을 삭제합니다. 그렇지 않으면 CS = PENDING입니다.

- Data-RFNM은 다른 모든 상태에서 오류입니다.

---
## **IX.  Algorithms for the System Call Interpreter**

각 시스템 호출에 대해 논의하여 영향을 미칠 수 있는 상태 변경을 제공합니다.

```text
   CONNECT
```

- 항목이 없으면 항목을 만들고 RFC를 발급한 다음 RFC-SENT 상태로 들어갑니다.

- CS = PENDING인 경우 대기열을 검색하고 일치하지 않는 모든 요청을 거부합니다. 일치하는 항목이 없으면 RFC를 발행하고 RFC-SENT 상태로 들어갑니다. 일치하는 항목이 있으면 RFC를 발행하고 OPEN 상태로 들어갑니다. 버퍼 공간이 할당되자마자 전송을 시작할 수 있습니다.

- 다른 상태에서는 이 명령이 불법입니다.

```text
   LISTEN
```

- 항목이 없으면 항목을 만들고 LISTENING 상태로 들어갑니다.

- CS = PENDING인 경우 사용자에게 알리고 RFC-RCVD 상태로 들어갑니다.

- 다른 상태에서는 이 명령이 불법입니다.

```text
   ACCEPT
```

- CS = RFC-RCVD이면 RFC를 발행하고 OPEN 상태로 들어갑니다. 버퍼 공간이 할당되는 즉시 데이터 전송이 발생할 수 있습니다.

- CS = ABORT인 경우 사용자에게 연결 조기 종료를 알립니다. 보류 중인 통화 대기열이 비어 있으면 항목을 삭제합니다. 그렇지 않으면 PENDING 상태가 됩니다.

- 이 명령은 다른 상태에서는 합법적으로 실행할 수 없습니다.

```text
   CLOSE

         If CS =
```

- 듣기, 그런 다음 항목을 삭제하십시오.

- RFC-RCVD, 그런 다음 CLS를 발행하고 CLS-WAIT 상태로 들어갑니다.

- ABORT, 연결의 조기 종료를 사용자에게 알립니다. 보류 중인 통화 대기열이 비어 있으면 항목을 삭제합니다. 그렇지 않으면 PENDING 상태가 됩니다.

- RFC-SENT, 그런 다음 CLS를 발행하고 CLS-WAIT 상태로 들어갑니다.

- OPEN, 송신 측에 있고 데이터 큐가 비어 있지 않거나 Data-RFNM이 여전히 미해결인 경우 DATA-WAIT 상태로 들어갑니다. 그렇지 않으면 CLS를 발행하고 CLS-WAIT 상태로 들어갑니다.

- CLS-WAIT, 이 상태에서 CLOSE를 발행하는 것은 USER ERROR이다.

- DATA-WAIT, 이 상태에서 CLOSE를 발행하는 것도 잘못된 시퀀스입니다.

- RFNM-WAIT, CLOSE 무시.

- 항목이 없거나 소켓이 PENDING 상태인 경우 유효한 CLOSE를 발행할 수 없습니다.

- \[ 이 RFC는 입력을 위해 기계가 읽을 수 있는 형식으로 입력되었습니다. \] \[ Anthony Anderberg 5/00의 온라인 RFC 아카이브로 \]
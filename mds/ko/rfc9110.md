

```text
﻿

Internet Engineering Task Force (IETF)                  R. Fielding, Ed.
Request for Comments: 9110                                         Adobe
STD: 97                                               M. Nottingham, Ed.
Obsoletes: 2818, 7230, 7231, 7232, 7233, 7235,                    Fastly
           7538, 7615, 7694                              J. Reschke, Ed.
Updates: 3864                                                 greenbytes
Category: Standards Track                                      June 2022
ISSN: 2070-1721

                             HTTP Semantics
```

---
# **Abstract**

HTTP\(Hypertext Transfer Protocol\)는 분산형 협업 하이퍼텍스트 정보 시스템을 위한 상태 비저장 응용 프로그램 수준 프로토콜입니다. 이 문서는 HTTP의 전반적인 아키텍처를 설명하고, 공통 용어를 설정하며, 모든 버전에서 공유되는 프로토콜의 측면을 정의합니다. 이 정의에는 핵심 프로토콜 요소, 확장성 메커니즘, "http" 및 "https" URI\(Uniform Resource Identifier\) ​​체계가 있습니다.

이 문서는 RFC 3864를 업데이트하고 RFC 2818, 7231, 7232, 7233, 7235, 7538, 7615, 7694 및 7230의 일부를 더 이상 사용하지 않습니다.

---
# **Status of This Memo**

이것은 인터넷 표준 추적 문서입니다.

이 문서는 IETF\(Internet Engineering Task Force\)의 산물입니다. 이는 IETF 커뮤니티의 합의를 나타냅니다. 공개 검토를 받았으며 IESG\(Internet Engineering Steering Group\)의 게시 승인을 받았습니다. 인터넷 표준에 대한 추가 정보는 RFC 7841의 섹션 2에서 확인할 수 있습니다.

이 문서의 현재 상태, 정오표, 피드백 제공 방법에 대한 정보는 https://www.rfc-editor.org/info/rfc9110에서 확인할 수 있습니다.

---
# **Copyright Notice**

Copyright \(c\) 2022 IETF Trust 및 문서 작성자로 식별된 사람. 판권 소유.

이 문서에는 이 문서 발행일에 유효한 BCP 78 및 IETF 문서와 관련된 IETF Trust의 법적 조항\(https://trustee.ietf.org/license-info\)이 적용됩니다. 이 문서에 관한 귀하의 권리와 제한 사항이 설명되어 있으므로 이 문서를 주의 깊게 검토하십시오. 이 문서에서 추출된 코드 구성 요소는 신뢰 법률 조항의 섹션 4.e에 설명된 대로 개정된 BSD 라이센스 텍스트를 포함해야 하며 개정된 BSD 라이센스에 설명된 대로 보증 없이 제공됩니다.

이 문서에는 2008년 11월 10일 이전에 공개되거나 공개된 IETF 문서 또는 IETF 기여의 자료가 포함될 수 있습니다. 이 자료 중 일부의 저작권을 관리하는 사람은 IETF Trust에 해당 자료의 수정을 허용할 권한을 부여하지 않았을 수 있습니다. IETF 표준 프로세스 외부. 해당 자료의 저작권을 관리하는 사람으로부터 적절한 라이센스를 얻지 않은 경우 이 문서는 IETF 표준 프로세스 외부에서 수정될 수 없으며 해당 문서의 파생물은 형식을 지정하는 경우를 제외하고 IETF 표준 프로세스 외부에서 생성될 수 없습니다. RFC로 출판하거나 영어 이외의 언어로 번역합니다.

---
# **Table of Contents**

```text
   1.  Introduction
     1.1.  Purpose
     1.2.  History and Evolution
     1.3.  Core Semantics
     1.4.  Specifications Obsoleted by This Document
   2.  Conformance
     2.1.  Syntax Notation
     2.2.  Requirements Notation
     2.3.  Length Requirements
     2.4.  Error Handling
     2.5.  Protocol Version
   3.  Terminology and Core Concepts
     3.1.  Resources
     3.2.  Representations
     3.3.  Connections, Clients, and Servers
     3.4.  Messages
     3.5.  User Agents
     3.6.  Origin Server
     3.7.  Intermediaries
     3.8.  Caches
     3.9.  Example Message Exchange
   4.  Identifiers in HTTP
     4.1.  URI References
     4.2.  HTTP-Related URI Schemes
       4.2.1.  http URI Scheme
       4.2.2.  https URI Scheme
       4.2.3.  http(s) Normalization and Comparison
       4.2.4.  Deprecation of userinfo in http(s) URIs
       4.2.5.  http(s) References with Fragment Identifiers
     4.3.  Authoritative Access
       4.3.1.  URI Origin
       4.3.2.  http Origins
       4.3.3.  https Origins
       4.3.4.  https Certificate Verification
       4.3.5.  IP-ID Reference Identity
   5.  Fields
     5.1.  Field Names
     5.2.  Field Lines and Combined Field Value
     5.3.  Field Order
     5.4.  Field Limits
     5.5.  Field Values
     5.6.  Common Rules for Defining Field Values
       5.6.1.  Lists (#rule ABNF Extension)
         5.6.1.1.  Sender Requirements
         5.6.1.2.  Recipient Requirements
       5.6.2.  Tokens
       5.6.3.  Whitespace
       5.6.4.  Quoted Strings
       5.6.5.  Comments
       5.6.6.  Parameters
       5.6.7.  Date/Time Formats
   6.  Message Abstraction
     6.1.  Framing and Completeness
     6.2.  Control Data
     6.3.  Header Fields
     6.4.  Content
       6.4.1.  Content Semantics
       6.4.2.  Identifying Content
     6.5.  Trailer Fields
       6.5.1.  Limitations on Use of Trailers
       6.5.2.  Processing Trailer Fields
     6.6.  Message Metadata
       6.6.1.  Date
       6.6.2.  Trailer
   7.  Routing HTTP Messages
     7.1.  Determining the Target Resource
     7.2.  Host and :authority
     7.3.  Routing Inbound Requests
       7.3.1.  To a Cache
       7.3.2.  To a Proxy
       7.3.3.  To the Origin
     7.4.  Rejecting Misdirected Requests
     7.5.  Response Correlation
     7.6.  Message Forwarding
       7.6.1.  Connection
       7.6.2.  Max-Forwards
       7.6.3.  Via
     7.7.  Message Transformations
     7.8.  Upgrade
   8.  Representation Data and Metadata
     8.1.  Representation Data
     8.2.  Representation Metadata
     8.3.  Content-Type
       8.3.1.  Media Type
       8.3.2.  Charset
       8.3.3.  Multipart Types
     8.4.  Content-Encoding
       8.4.1.  Content Codings
         8.4.1.1.  Compress Coding
         8.4.1.2.  Deflate Coding
         8.4.1.3.  Gzip Coding
     8.5.  Content-Language
       8.5.1.  Language Tags
     8.6.  Content-Length
     8.7.  Content-Location
     8.8.  Validator Fields
       8.8.1.  Weak versus Strong
       8.8.2.  Last-Modified
         8.8.2.1.  Generation
         8.8.2.2.  Comparison
       8.8.3.  ETag
         8.8.3.1.  Generation
         8.8.3.2.  Comparison
         8.8.3.3.  Example: Entity Tags Varying on Content-Negotiated
                 Resources
   9.  Methods
     9.1.  Overview
     9.2.  Common Method Properties
       9.2.1.  Safe Methods
       9.2.2.  Idempotent Methods
       9.2.3.  Methods and Caching
     9.3.  Method Definitions
       9.3.1.  GET
       9.3.2.  HEAD
       9.3.3.  POST
       9.3.4.  PUT
       9.3.5.  DELETE
       9.3.6.  CONNECT
       9.3.7.  OPTIONS
       9.3.8.  TRACE
   10. Message Context
     10.1.  Request Context Fields
       10.1.1.  Expect
       10.1.2.  From
       10.1.3.  Referer
       10.1.4.  TE
       10.1.5.  User-Agent
     10.2.  Response Context Fields
       10.2.1.  Allow
       10.2.2.  Location
       10.2.3.  Retry-After
       10.2.4.  Server
   11. HTTP Authentication
     11.1.  Authentication Scheme
     11.2.  Authentication Parameters
     11.3.  Challenge and Response
     11.4.  Credentials
     11.5.  Establishing a Protection Space (Realm)
     11.6.  Authenticating Users to Origin Servers
       11.6.1.  WWW-Authenticate
       11.6.2.  Authorization
       11.6.3.  Authentication-Info
     11.7.  Authenticating Clients to Proxies
       11.7.1.  Proxy-Authenticate
       11.7.2.  Proxy-Authorization
       11.7.3.  Proxy-Authentication-Info
   12. Content Negotiation
     12.1.  Proactive Negotiation
     12.2.  Reactive Negotiation
     12.3.  Request Content Negotiation
     12.4.  Content Negotiation Field Features
       12.4.1.  Absence
       12.4.2.  Quality Values
       12.4.3.  Wildcard Values
     12.5.  Content Negotiation Fields
       12.5.1.  Accept
       12.5.2.  Accept-Charset
       12.5.3.  Accept-Encoding
       12.5.4.  Accept-Language
       12.5.5.  Vary
   13. Conditional Requests
     13.1.  Preconditions
       13.1.1.  If-Match
       13.1.2.  If-None-Match
       13.1.3.  If-Modified-Since
       13.1.4.  If-Unmodified-Since
       13.1.5.  If-Range
     13.2.  Evaluation of Preconditions
       13.2.1.  When to Evaluate
       13.2.2.  Precedence of Preconditions
   14. Range Requests
     14.1.  Range Units
       14.1.1.  Range Specifiers
       14.1.2.  Byte Ranges
     14.2.  Range
     14.3.  Accept-Ranges
     14.4.  Content-Range
     14.5.  Partial PUT
     14.6.  Media Type multipart/byteranges
   15. Status Codes
     15.1.  Overview of Status Codes
     15.2.  Informational 1xx
       15.2.1.  100 Continue
       15.2.2.  101 Switching Protocols
     15.3.  Successful 2xx
       15.3.1.  200 OK
       15.3.2.  201 Created
       15.3.3.  202 Accepted
       15.3.4.  203 Non-Authoritative Information
       15.3.5.  204 No Content
       15.3.6.  205 Reset Content
       15.3.7.  206 Partial Content
         15.3.7.1.  Single Part
         15.3.7.2.  Multiple Parts
         15.3.7.3.  Combining Parts
     15.4.  Redirection 3xx
       15.4.1.  300 Multiple Choices
       15.4.2.  301 Moved Permanently
       15.4.3.  302 Found
       15.4.4.  303 See Other
       15.4.5.  304 Not Modified
       15.4.6.  305 Use Proxy
       15.4.7.  306 (Unused)
       15.4.8.  307 Temporary Redirect
       15.4.9.  308 Permanent Redirect
     15.5.  Client Error 4xx
       15.5.1.  400 Bad Request
       15.5.2.  401 Unauthorized
       15.5.3.  402 Payment Required
       15.5.4.  403 Forbidden
       15.5.5.  404 Not Found
       15.5.6.  405 Method Not Allowed
       15.5.7.  406 Not Acceptable
       15.5.8.  407 Proxy Authentication Required
       15.5.9.  408 Request Timeout
       15.5.10. 409 Conflict
       15.5.11. 410 Gone
       15.5.12. 411 Length Required
       15.5.13. 412 Precondition Failed
       15.5.14. 413 Content Too Large
       15.5.15. 414 URI Too Long
       15.5.16. 415 Unsupported Media Type
       15.5.17. 416 Range Not Satisfiable
       15.5.18. 417 Expectation Failed
       15.5.19. 418 (Unused)
       15.5.20. 421 Misdirected Request
       15.5.21. 422 Unprocessable Content
       15.5.22. 426 Upgrade Required
     15.6.  Server Error 5xx
       15.6.1.  500 Internal Server Error
       15.6.2.  501 Not Implemented
       15.6.3.  502 Bad Gateway
       15.6.4.  503 Service Unavailable
       15.6.5.  504 Gateway Timeout
       15.6.6.  505 HTTP Version Not Supported
   16. Extending HTTP
     16.1.  Method Extensibility
       16.1.1.  Method Registry
       16.1.2.  Considerations for New Methods
     16.2.  Status Code Extensibility
       16.2.1.  Status Code Registry
       16.2.2.  Considerations for New Status Codes
     16.3.  Field Extensibility
       16.3.1.  Field Name Registry
       16.3.2.  Considerations for New Fields
         16.3.2.1.  Considerations for New Field Names
         16.3.2.2.  Considerations for New Field Values
     16.4.  Authentication Scheme Extensibility
       16.4.1.  Authentication Scheme Registry
       16.4.2.  Considerations for New Authentication Schemes
     16.5.  Range Unit Extensibility
       16.5.1.  Range Unit Registry
       16.5.2.  Considerations for New Range Units
     16.6.  Content Coding Extensibility
       16.6.1.  Content Coding Registry
       16.6.2.  Considerations for New Content Codings
     16.7.  Upgrade Token Registry
   17. Security Considerations
     17.1.  Establishing Authority
     17.2.  Risks of Intermediaries
     17.3.  Attacks Based on File and Path Names
     17.4.  Attacks Based on Command, Code, or Query Injection
     17.5.  Attacks via Protocol Element Length
     17.6.  Attacks Using Shared-Dictionary Compression
     17.7.  Disclosure of Personal Information
     17.8.  Privacy of Server Log Information
     17.9.  Disclosure of Sensitive Information in URIs
     17.10. Application Handling of Field Names
     17.11. Disclosure of Fragment after Redirects
     17.12. Disclosure of Product Information
     17.13. Browser Fingerprinting
     17.14. Validator Retention
     17.15. Denial-of-Service Attacks Using Range
     17.16. Authentication Considerations
       17.16.1.  Confidentiality of Credentials
       17.16.2.  Credentials and Idle Clients
       17.16.3.  Protection Spaces
       17.16.4.  Additional Response Fields
   18. IANA Considerations
     18.1.  URI Scheme Registration
     18.2.  Method Registration
     18.3.  Status Code Registration
     18.4.  Field Name Registration
     18.5.  Authentication Scheme Registration
     18.6.  Content Coding Registration
     18.7.  Range Unit Registration
     18.8.  Media Type Registration
     18.9.  Port Registration
     18.10. Upgrade Token Registration
   19. References
     19.1.  Normative References
     19.2.  Informative References
   Appendix A.  Collected ABNF
   Appendix B.  Changes from Previous RFCs
     B.1.  Changes from RFC 2818
     B.2.  Changes from RFC 7230
     B.3.  Changes from RFC 7231
     B.4.  Changes from RFC 7232
     B.5.  Changes from RFC 7233
     B.6.  Changes from RFC 7235
     B.7.  Changes from RFC 7538
     B.8.  Changes from RFC 7615
     B.9.  Changes from RFC 7694
   Acknowledgements
   Index
   Authors' Addresses
```

---
## **1.  Introduction**
---
### **1.1.  Purpose**

HTTP\(Hypertext Transfer Protocol\)는 일반 인터페이스, 확장 가능한 의미 체계 및 자체 설명 메시지를 공유하여 네트워크 기반 하이퍼텍스트 정보 시스템과의 유연한 상호 작용을 가능하게 하는 상태 비저장 애플리케이션 수준 요청/응답 프로토콜 제품군입니다.

HTTP는 제공된 리소스 유형과 관계없이 클라이언트에 균일한 인터페이스를 제공하여 서비스 구현 방법에 대한 세부 정보를 숨깁니다. 마찬가지로, 서버는 각 클라이언트의 목적을 알 필요가 없습니다. 요청은 특정 유형의 클라이언트 또는 미리 결정된 애플리케이션 단계 순서와 연관되기보다는 별도로 고려될 수 있습니다. 이를 통해 범용 구현을 다양한 상황에서 효과적으로 사용할 수 있고 상호 작용 복잡성을 줄이며 시간이 지남에 따라 독립적인 발전이 가능합니다.

HTTP는 또한 프록시와 게이트웨이가 HTTP가 아닌 정보 시스템을 보다 일반적인 인터페이스로 변환할 수 있는 중개 프로토콜로 사용하도록 설계되었습니다.

이러한 유연성의 한 가지 결과는 프로토콜이 인터페이스 뒤에서 발생하는 측면에서 정의될 수 없다는 것입니다. 대신, 우리는 통신 구문, 수신된 통신의 의도 및 수신자의 예상되는 동작을 정의하는 것으로 제한됩니다. 통신이 독립적으로 고려되는 경우 서버에서 제공하는 관찰 가능한 인터페이스에 대한 해당 변경 사항에 성공적인 작업이 반영되어야 합니다. 그러나 여러 클라이언트가 병렬로 작동하고 아마도 교차 목적으로 작동할 수 있으므로 이러한 변경 사항이 단일 응답 범위를 넘어 관찰 가능하도록 요구할 수는 없습니다.

---
### **1.2.  History and Evolution**

HTTP는 1990년에 도입된 이후 World Wide Web의 주요 정보 전송 프로토콜이었습니다. HTTP는 주어진 문자열로 식별되는 추정 하이퍼텍스트 문서의 전송을 요청하는 단일 메소드\(GET\)를 사용하여 대기 시간이 짧은 요청을 위한 간단한 메커니즘으로 시작되었습니다. 경로명. 웹이 성장함에 따라 HTTP는 요청과 응답을 메시지 내에 포함하고, MIME과 같은 미디어 유형을 사용하여 임의의 데이터 형식을 전송하고, 중개자를 통해 요청을 라우팅하도록 확장되었습니다. 이러한 프로토콜은 결국 HTTP/0.9 및 HTTP/1.0으로 정의되었습니다\(\[HTTP/1.0\] 참조\).

HTTP/1.1은 기존 텍스트 기반 메시징 구문과의 호환성을 유지하면서 프로토콜의 기능을 개선하고 인터넷 전반에 걸쳐 상호 운용성, 확장성 및 견고성을 향상시키도록 설계되었습니다. 여기에는 고정 및 동적\(청크\) 콘텐츠에 대한 길이 기반 데이터 구분 기호, 콘텐츠 협상을 위한 일관된 프레임워크, 조건부 요청을 위한 불투명 유효성 검사기, 더 나은 캐시 일관성을 위한 캐시 제어, 부분 업데이트를 위한 범위 요청 및 기본 영구 연결이 포함되었습니다. HTTP/1.1은 1995년에 도입되어 1997년에 표준 트랙에 게시되었으며 \[RFC2068\], 1999년에 개정되었으며 \[RFC2616\], 2014년에 다시 개정되었습니다\(\[RFC7230\] \~ \[RFC7235\]\).

HTTP/2\(\[HTTP/2\]\)는 효율적인 필드 압축 및 서버 푸시를 통해 동시 HTTP 메시지를 교환하기 위해 기존 TLS 및 TCP 프로토콜 위에 다중화된 세션 계층을 도입했습니다. HTTP/3\(\[HTTP/3\]\)은 TCP 대신 UDP를 통한 보안 다중화 전송으로 QUIC를 사용하여 동시 메시지에 대한 더 큰 독립성을 제공합니다.

HTTP의 세 가지 주요 버전은 모두 이 문서에서 정의한 의미를 따릅니다. 각 제품은 사용 상황에 따라 특정한 이점과 제한 사항이 있으므로 서로를 쓸모없게 만들지 않습니다. 구현에서는 특정 컨텍스트에 가장 적합한 전송 및 메시징 구문을 선택해야 합니다.

이 HTTP 개정판은 현재 HTTP/1.1 메시징 구문\(\[HTTP/1.1\]\)에서 의미론\(본 문서\) 및 캐싱\(\[CACHING\]\)의 정의를 분리하여 동일한 코어를 참조하면서 각 주요 프로토콜 버전이 독립적으로 진행될 수 있도록 합니다. 의미론.

---
### **1.3.  Core Semantics**

HTTP는 표현을 조작하거나 전송하는 메시지를 전송함으로써\(섹션 3.2\) 리소스 유형, 특성 또는 구현에 관계없이 리소스\(섹션 3.1\)와 상호 작용하기 위한 통일된 인터페이스를 제공합니다.

각 메시지는 요청이거나 응답입니다. 클라이언트는 의도를 전달하고 해당 메시지를 식별된 원본 서버로 라우팅하는 요청 메시지를 구성합니다. 서버는 요청을 수신하고, 수신된 각 메시지를 구문 분석하고, 식별된 대상 리소스와 관련된 메시지 의미를 해석하고, 하나 이상의 응답 메시지로 해당 요청에 응답합니다. 클라이언트는 수신된 응답을 검사하여 의도가 수행되었는지 확인하고 수신된 상태 코드와 콘텐츠를 기반으로 다음에 수행할 작업을 결정합니다.

HTTP 의미 체계에는 각 요청 메서드\(섹션 9\)에 의해 정의된 의도, 요청 헤더 필드에 설명될 수 있는 의미 체계에 대한 확장, 응답을 설명하는 상태 코드\(섹션 15\), 기타 제어 데이터 및 제공될 수 있는 리소스 메타데이터가 포함됩니다. 응답 필드에.

의미론에는 수신자가 콘텐츠를 해석하는 방법을 설명하는 표현 메타데이터, 콘텐츠 선택에 영향을 줄 수 있는 요청 헤더 필드, 집합적으로 "콘텐츠 협상"\(섹션 12\)이라고 하는 다양한 선택 알고리즘이 포함됩니다.

---
### **1.4.  Specifications Obsoleted by This Document**

```text
   +============================================+===========+=====+
   | Title                                      | Reference | See |
   +============================================+===========+=====+
   | HTTP Over TLS                              | [RFC2818] | B.1 |
   +--------------------------------------------+-----------+-----+
   | HTTP/1.1 Message Syntax and Routing [*]    | [RFC7230] | B.2 |
   +--------------------------------------------+-----------+-----+
   | HTTP/1.1 Semantics and Content             | [RFC7231] | B.3 |
   +--------------------------------------------+-----------+-----+
   | HTTP/1.1 Conditional Requests              | [RFC7232] | B.4 |
   +--------------------------------------------+-----------+-----+
   | HTTP/1.1 Range Requests                    | [RFC7233] | B.5 |
   +--------------------------------------------+-----------+-----+
   | HTTP/1.1 Authentication                    | [RFC7235] | B.6 |
   +--------------------------------------------+-----------+-----+
   | HTTP Status Code 308 (Permanent Redirect)  | [RFC7538] | B.7 |
   +--------------------------------------------+-----------+-----+
   | HTTP Authentication-Info and Proxy-        | [RFC7615] | B.8 |
   | Authentication-Info Response Header Fields |           |     |
   +--------------------------------------------+-----------+-----+
   | HTTP Client-Initiated Content-Encoding     | [RFC7694] | B.9 |
   +--------------------------------------------+-----------+-----+

                               Table 1
```

\[\*\] 이 문서는 HTTP/1.1 메시징 구문 및 연결 관리와 독립적인 RFC 7230 부분만 폐기합니다. RFC 7230의 나머지 비트는 "HTTP/1.1"\[HTTP/1.1\]에 의해 폐기됩니다.

---
## **2.  Conformance**
---
### **2.1.  Syntax Notation**

이 사양은 \[RFC7405\]에 정의된 문자열의 대소문자 구분 표기법으로 확장된 \[RFC5234\]의 ABNF\(Augmented Backus-Naur Form\) 표기법을 사용합니다.

또한 섹션 5.6.1에 정의된 목록 확장을 사용하여 "#" 연산자를 사용하여 쉼표로 구분된 목록을 간결하게 정의할 수 있습니다\("\*" 연산자가 반복을 나타내는 방식과 유사\). 부록 A는 표준 ABNF 표기법으로 확장된 모든 목록 연산자와 함께 수집된 문법을 보여줍니다.

관례적으로 "obs-" 접두사가 붙은 ABNF 규칙 이름은 역사적인 이유로 나타나는 오래된 문법 규칙을 나타냅니다.

\[RFC5234\]의 부록 B.1에 정의된 대로 다음 핵심 규칙이 참조로 포함됩니다: ALPHA\(문자\), CR\(캐리지 리턴\), CRLF\(CR LF\), CTL\(컨트롤\), DIGIT\(십진수 0-9\) , DQUOTE\(큰따옴표\), HEXDIG\(16진수 0-9/A-F/a-f\), HTAB\(가로 탭\), LF\(줄 바꿈\), OCTET\(8비트 데이터 시퀀스\), SP\(공백\) 및 VCHAR\( 표시되는 모든 US-ASCII 문자\).

섹션 5.6에서는 필드 값에 대한 몇 가지 일반적인 구문 구성 요소를 정의합니다.

이 사양에서는 \[RFC6365\]에 정의된 대로 "문자", "문자 인코딩 체계", "문자 집합" 및 "프로토콜 요소"라는 용어를 사용합니다.

---
### **2.2.  Requirements Notation**

핵심 단어 "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY" 및 "OPTIONAL 이 문서의 "는 여기에 표시된 대로 모두 대문자로 표시되는 경우에만 BCP 14 \[RFC2119\] \[RFC8174\]에 설명된 대로 해석됩니다.

이 사양은 HTTP 통신 참가자의 역할에 따른 적합성 기준을 목표로 합니다. 따라서 요구 사항에 의해 제한되는 동작에 따라 발신자, 수신자, 클라이언트, 서버, 사용자 에이전트, 중개자, 원본 서버, 프록시, 게이트웨이 또는 캐시에 대한 요구 사항이 적용됩니다. 단일 통신 범위를 넘어서 적용되는 경우 구현, 리소스 소유자 및 프로토콜 요소 등록에 대한 추가 요구 사항이 적용됩니다.

요구사항이 수신된 요소를 다운스트림으로 전달하는 구현이 아니라 프로토콜 요소를 생성하는 구현에만 적용되는 경우 "보내기" 대신 동사 "생성"이 사용됩니다.

구현은 HTTP에서 참여하는 역할과 관련된 모든 요구 사항을 준수하는 경우 준수로 간주됩니다.

발신자는 해당 ABNF 규칙에 의해 정의된 문법과 일치하지 않는 프로토콜 요소를 생성해서는 안 됩니다. 주어진 메시지 내에서 발신자는 다른 역할\(즉, 발신자가 해당 메시지에 대해 갖고 있지 않은 역할\)의 참여자에 의해서만 생성되도록 허용된 프로토콜 요소 또는 구문 대안을 생성해서는 안 됩니다.

HTTP 준수에는 사용 중인 프로토콜 버전의 특정 메시징 구문에 대한 준수와 전송된 프로토콜 요소의 의미에 대한 준수가 모두 포함됩니다. 예를 들어, HTTP/1.1 준수를 주장하지만 HTTP/1.1 수신자에게 필요한 기능을 인식하지 못하는 클라이언트는 해당 주장에 따라 응답을 조정하는 서버와 상호 운용되지 않습니다. 콘텐츠 협상 및 사용자가 선택한 확장과 같은 사용자 선택을 반영하는 기능은 프로토콜 스트림을 넘어서는 애플리케이션 동작에 영향을 미칠 수 있습니다. 사용자의 선택을 부정확하게 반영하는 프로토콜 요소를 보내는 것은 사용자를 혼란스럽게 하고 선택을 방해할 것입니다.

구현이 의미 체계 준수에 실패하면 해당 구현 메시지를 받는 사람은 결국 그에 따라 동작을 조정하는 해결 방법을 개발하게 됩니다. 해결 방법이 결함이 있는 구현으로 제한되는 경우 수신자는 이 프로토콜을 준수하면서 그러한 해결 방법을 사용할 수 있습니다. 예를 들어, 서버는 종종 User-Agent 필드 값의 일부를 스캔하고, 사용자 에이전트는 종종 서버 필드 값을 스캔하여 알려진 버그 또는 잘못 선택된 기본값과 관련하여 자체 동작을 조정합니다.

---
### **2.3.  Length Requirements**

수신자는 수신된 프로토콜 요소를 방어적으로 구문 분석해야 하며, 요소가 ABNF 문법을 준수하고 합리적인 버퍼 크기에 맞을 것이라는 한계적인 기대만 가지고 있어야 합니다.

HTTP에는 배포 컨텍스트와 구현 목적에 따라 적절한 길이가 크게 달라지기 때문에 많은 프로토콜 요소에 대한 특정 길이 제한이 없습니다. 따라서 발신자와 수신자 간의 상호 운용성은 각 프로토콜 요소의 합리적인 길이에 관한 공유된 기대에 따라 달라집니다. 또한, 일부 프로토콜 요소의 합리적인 길이로 일반적으로 이해되는 길이는 지난 30년 동안 HTTP를 사용하는 과정에서 변경되었으며 앞으로도 계속 변경될 것으로 예상됩니다.

최소한 수신자는 다른 메시지의 동일한 프로토콜 요소에 대해 생성하는 값보다 긴 프로토콜 요소 길이를 구문 분석하고 처리할 수 있어야 합니다. 예를 들어, 자체 리소스에 대한 매우 긴 URI 참조를 게시하는 원본 서버는 대상 URI로 수신될 때 동일한 참조를 구문 분석하고 처리할 수 있어야 합니다.

수신된 많은 프로토콜 요소는 해당 요소를 식별하고 다운스트림으로 전달하는 데 필요한 범위까지만 구문 분석됩니다. 예를 들어 중개자는 수신된 필드를 필드 이름 및 필드 값 구성 요소로 구문 분석한 다음 필드 값 내부를 추가로 구문 분석하지 않고 필드를 전달할 수 있습니다.

---
### **2.4.  Error Handling**

수신자가 \(경험이나 구성을 통해\) 발신자가 해당 의미에 의해 암시된 내용을 잘못 구현했다고 판단하지 않는 한, 수신자는 이 사양에 대한 확장을 포함하여 이 사양에 의해 정의된 의미에 따라 수신된 프로토콜 요소를 해석해야 합니다. 예를 들어, User-Agent 헤더 필드를 조사한 결과 특정 콘텐츠 코딩 수신 시 실패하는 것으로 알려진 특정 구현 버전이 표시되는 경우 원서버는 수신된 Accept-Encoding 헤더 필드의 콘텐츠를 무시할 수 있습니다.

달리 명시하지 않는 한, 수신자는 유효하지 않은 구성으로부터 사용 가능한 프로토콜 요소를 복구하려고 시도할 수 있습니다. HTTP는 보안에 직접적인 영향을 미치는 경우를 제외하고 특정 오류 처리 메커니즘을 정의하지 않습니다. 프로토콜의 다양한 응용 프로그램에는 서로 다른 오류 처리 전략이 필요하기 때문입니다. 예를 들어, 웹 브라우저는 Location 헤더 필드가 ABNF에 따라 구문 분석되지 않는 응답에서 투명하게 복구하기를 원하는 반면, 시스템 제어 클라이언트는 모든 형태의 오류 복구를 위험하다고 간주할 수 있습니다.

일부 요청은 섹션 9.2.2에 설명된 대로 기본 연결 실패 시 클라이언트가 자동으로 재시도할 수 있습니다.

---
### **2.5.  Protocol Version**

HTTP의 버전 번호는 "."로 구분된 두 개의 십진수로 구성됩니다. \(마침표 또는 소수점\). 첫 번째 숫자\(주 버전\)는 메시징 구문을 나타내고 두 번째 숫자\(부 버전\)는 보낸 사람이 준수하는\(향후 통신을 위해 이해할 수 있음\) 해당 주요 버전 내에서 가장 높은 부 버전을 나타냅니다.

HTTP의 핵심 의미 체계는 프로토콜 버전 간에 변경되지 않지만 "연결 중"이라는 표현은 변경될 수 있으므로 연결 형식에 호환되지 않는 변경이 발생하면 HTTP 버전 번호가 변경됩니다. 또한 HTTP를 사용하면 정의된 확장 지점\(섹션 16\)을 사용하여 버전을 변경하지 않고도 프로토콜에 대한 점진적이고 이전 버전과 호환되는 변경이 가능합니다.

전체적으로 프로토콜 버전은 해당 버전의 해당 사양에 제시된 요구 사항 집합에 대한 보낸 사람의 적합성을 나타냅니다. 예를 들어, "HTTP/1.1" 버전은 이 문서의 "HTTP 캐싱" \[CACHING\] 및 "HTTP/1.1" \[HTTP/1.1\]의 결합된 사양에 의해 정의됩니다.

호환되지 않는 메시지 구문이 도입되면 HTTP의 주요 버전 번호가 증가합니다. 마이너 번호는 프로토콜 변경으로 인해 메시지 의미가 추가되거나 보낸 사람의 추가 기능이 암시될 때 증가됩니다.

마이너 버전은 발신자가 이전 버전과 호환되는 프로토콜 하위 집합만 사용하는 경우에도 발신자의 통신 기능을 광고하므로 수신자에게 응답\(서버에 의한\) 또는 향후 요청\(클라이언트에 의한\)에 더 고급 기능을 사용할 수 있음을 알립니다. .

HTTP의 주 버전이 부 버전을 정의하지 않는 경우 부 버전 "0"이 암시됩니다. "0"은 부 버전 식별자가 필요한 요소 내에서 해당 프로토콜을 참조할 때 사용됩니다.

---
## **3.  Terminology and Core Concepts**

HTTP는 WWW\(World Wide Web\) 아키텍처를 위해 만들어졌으며 시간이 지남에 따라 전 세계 하이퍼텍스트 시스템의 확장성 요구를 지원하도록 발전해 왔습니다. 해당 아키텍처의 대부분은 HTTP를 정의하는 데 사용되는 용어에 반영됩니다.

---
### **3.1.  Resources**

HTTP 요청의 대상을 "리소스"라고 합니다. HTTP는 리소스의 성격을 제한하지 않습니다. 단지 리소스와 상호 작용하는 데 사용할 수 있는 인터페이스를 정의할 뿐입니다. 대부분의 리소스는 섹션 4에 설명된 대로 URI\(Uniform Resource Identifier\)로 식별됩니다.

HTTP의 한 가지 설계 목표는 요청 의미론에서 리소스 식별을 분리하는 것입니다. 이는 요청 메서드\(9장\)와 몇 가지 요청 수정 헤더 필드에 요청 의미론을 부여함으로써 가능해집니다. 리소스는 요청 메서드의 의미와 일치하지 않는 방식으로 요청을 처리할 수 없습니다. 예를 들어 리소스의 URI가 안전하지 않은 의미를 암시할 수 있더라도 클라이언트는 리소스가 안전한 메서드로 요청을 처리할 때 안전하지 않은 작업을 피할 것으로 기대할 수 있습니다\(섹션 9.2.1 참조\).

HTTP는 URI\(Uniform Resource Identifier\) ​​표준 \[URI\]을 사용하여 대상 리소스\(섹션 7.1\)와 리소스 간의 관계를 나타냅니다.

---
### **3.2.  Representations**

"표현"은 주어진 자원의 과거, 현재 또는 원하는 상태를 프로토콜을 통해 쉽게 전달할 수 있는 형식으로 반영하기 위한 정보입니다. 표현은 표현 메타데이터 집합과 잠재적으로 제한되지 않는 표현 데이터 스트림으로 구성됩니다\(섹션 8\).

HTTP는 리소스 자체를 전송하는 대신 리소스 상태의 전송 가능한 표현과 관련하여 통신을 정의함으로써 균일한 인터페이스 뒤에 "정보 숨기기"를 허용합니다. 이를 통해 URI로 식별되는 리소스는 "라구나 비치의 현재 날씨"와 같은 임시 기능을 포함하여 무엇이든 될 수 있으며 잠재적으로 메시지가 생성될 때 해당 리소스를 나타내는 정보를 제공할 수 있습니다\[REST\].

통일된 인터페이스는 상대방의 독립된 행위자에게 메시지를 전달함으로써 사물을 관찰하고 행동할 수 있는 창과 유사하다. 우리의 커뮤니케이션에서 해당 사물의 현재 또는 원하는 상태를 표현\("대체"\)하려면 공유 추상화가 필요합니다. 표현이 하이퍼텍스트인 경우 리소스 상태 표현과 수신자의 향후 상호 작용을 안내하는 데 도움이 되는 처리 지침을 모두 제공할 수 있습니다.

대상 리소스는 각각 리소스의 현재 상태를 반영하도록 의도된 여러 표현을 제공하거나 생성할 수 있습니다. 일반적으로 콘텐츠 협상\(섹션 12\)을 기반으로 하는 알고리즘을 사용하여 주어진 요청에 가장 적합한 표현 중 하나를 선택합니다. 이 "선택된 표현"은 조건부 요청\(섹션 13\)을 평가하고 GET\(섹션 9.3.1\)에 대한 200\(OK\), 206\(부분 콘텐츠\) 및 304\(수정되지 않음\) 응답에 대한 콘텐츠를 구성하기 위한 데이터 및 메타데이터를 제공합니다.

---
### **3.3.  Connections, Clients, and Servers**

HTTP는 안정적인 전송 또는 세션 계층 "연결"을 통해 작동하는 클라이언트/서버 프로토콜입니다.

HTTP "클라이언트"는 하나 이상의 HTTP 요청을 보내기 위해 서버에 연결을 설정하는 프로그램입니다. HTTP "서버"는 HTTP 응답을 전송하여 HTTP 요청을 서비스하기 위해 연결을 수락하는 프로그램입니다.

클라이언트와 서버라는 용어는 이러한 프로그램이 특정 연결에 대해 수행하는 역할만을 나타냅니다. 동일한 프로그램이 일부 연결에서는 클라이언트 역할을 하고 다른 연결에서는 서버 역할을 할 수 있습니다.

HTTP는 상태 비저장 프로토콜로 정의됩니다. 즉, 각 요청 메시지의 의미를 개별적으로 이해할 수 있으며 연결과 메시지 간의 관계가 해당 메시지 해석에 영향을 미치지 않는다는 의미입니다. 예를 들어 CONNECT 요청\(섹션 9.3.6\) 또는 업그레이드 헤더 필드가 있는 요청\(섹션 7.8\)은 연결의 첫 번째 메시지뿐만 아니라 언제든지 발생할 수 있습니다. 많은 구현은 프록시 연결을 재사용하거나 여러 서버에 걸쳐 요청을 동적으로 로드 밸런싱하기 위해 HTTP의 상태 비저장 설계에 의존합니다.

결과적으로, 서버는 연결이 보안되고 해당 에이전트에 특정되지 않는 한 동일한 연결에 대한 두 요청이 동일한 사용자 에이전트에서 왔다고 가정해서는 안 됩니다. 일부 비표준 HTTP 확장\(예: \[RFC4559\]\)은 이 요구 사항을 위반하여 보안 및 상호 운용성 문제를 일으키는 것으로 알려져 있습니다.

---
### **3.4.  Messages**

HTTP는 연결을 통해 "메시지"를 교환하기 위한 상태 비저장 요청/응답 프로토콜입니다. "발신자" 및 "수신자"라는 용어는 각각 주어진 메시지를 보내거나 받는 모든 구현을 나타냅니다.

클라이언트는 메서드\(9절\)와 요청 대상\(7.1절\)이 포함된 "요청" 메시지 형식으로 서버에 요청을 보냅니다. 요청에는 요청 수정자, 클라이언트 정보 및 표현 메타데이터에 대한 헤더 필드\(6.3절\), 메서드에 따라 처리하기 위한 콘텐츠\(6.4절\) 및 전송 중에 수집된 정보를 전달하기 위한 트레일러 필드\(6.5절\)가 포함될 수도 있습니다. 콘텐츠.

서버는 각각 상태 코드를 포함하는 하나 이상의 "응답" 메시지를 보내 클라이언트의 요청에 응답합니다\(섹션 15\). 응답에는 서버 정보, 리소스 메타데이터 및 표현 메타데이터에 대한 헤더 필드, 상태 코드에 따라 해석될 콘텐츠, 콘텐츠를 보내는 동안 수집된 정보를 전달하기 위한 트레일러 필드가 포함될 수도 있습니다.

---
### **3.5.  User Agents**

"사용자 에이전트"라는 용어는 요청을 시작하는 다양한 클라이언트 프로그램을 의미합니다.

가장 친숙한 형태의 사용자 에이전트는 범용 웹 브라우저이지만 이는 구현의 극히 일부에 불과합니다. 다른 일반적인 사용자 에이전트에는 스파이더\(웹 탐색 로봇\), 명령줄 도구, 광고판 화면, 가전 제품, 저울, 전구, 펌웨어 업데이트 스크립트, 모바일 앱 및 다양한 모양과 크기의 통신 장치가 포함됩니다.

사용자 에이전트라는 것이 요청 시 소프트웨어 에이전트와 직접 상호 작용하는 인간 사용자가 있다는 것을 의미하지는 않습니다. 대부분의 경우 사용자 에이전트는 백그라운드에서 실행되고 나중에 검사를 위해 결과를 저장하도록 설치되거나 구성됩니다\(또는 흥미롭거나 오류가 있을 수 있는 결과의 하위 집합만 저장\). 예를 들어 스파이더에는 일반적으로 시작 URI가 제공되며 웹을 하이퍼텍스트 그래프로 크롤링하는 동안 특정 동작을 따르도록 구성됩니다.

많은 사용자 에이전트는 사용자에게 대화형 제안을 제공하거나 보안 또는 개인 정보 보호 문제에 대해 적절한 경고를 제공할 수 없거나 제공하지 않기로 선택할 수 있습니다. 이 사양에서 사용자에게 오류를 보고해야 하는 소수의 경우 이러한 보고는 오류 콘솔이나 로그 파일에서만 관찰할 수 있습니다. 마찬가지로, 진행하기 전에 사용자가 자동 ​​작업을 확인해야 한다는 요구 사항은 고급 구성 선택, 런타임 옵션 또는 안전하지 않은 작업의 간단한 회피를 통해 충족될 수 있습니다. 확인은 사용자가 이미 해당 선택을 한 경우 특정 사용자 인터페이스나 일반 처리 중단을 의미하지 않습니다.

---
### **3.6.  Origin Server**

"원본 서버"라는 용어는 주어진 대상 리소스에 대해 신뢰할 수 있는 응답을 생성할 수 있는 프로그램을 나타냅니다.

가장 친숙한 형태의 원본 서버는 대규모 공개 웹사이트입니다. 그러나 사용자 에이전트가 브라우저와 동일시되는 것처럼 모든 원본 서버가 동일하다고 오해하기 쉽습니다. 일반적인 원본 서버에는 홈 자동화 장치, 구성 가능한 네트워킹 구성 요소, 사무용 기계, 자율 로봇, 뉴스 피드, 교통 카메라, 실시간 광고 선택기 및 주문형 비디오 플랫폼도 포함됩니다.

대부분의 HTTP 통신은 URI로 식별되는 일부 리소스 표현에 대한 검색 요청\(GET\)으로 구성됩니다. 가장 간단한 경우 이는 사용자 에이전트\(UA\)와 원본 서버\(O\) 간의 단일 양방향 연결\(===\)을 통해 수행될 수 있습니다.

```text
            request   >
       UA ======================================= O
                                   <   response

                                  Figure 1
```

---
### **3.7.  Intermediaries**

HTTP를 사용하면 중개자를 사용하여 연결 체인을 통해 요청을 충족할 수 있습니다. HTTP "중개자"에는 프록시, 게이트웨이, 터널의 세 가지 일반적인 형태가 있습니다. 어떤 경우에는 단일 중개자가 원본 서버, 프록시, 게이트웨이 또는 터널 역할을 하여 각 요청의 특성에 따라 동작을 전환할 수 있습니다.

```text
            >             >             >             >
       UA =========== A =========== B =========== C =========== O
                  <             <             <             <

                                  Figure 2
```

위 그림은 사용자 에이전트와 원본 서버 사이의 세 가지 중개자\(A, B, C\)를 보여줍니다. 전체 체인을 이동하는 요청 또는 응답 메시지는 4개의 개별 연결을 통과합니다. 일부 HTTP 통신 옵션은 가장 가까운 터널이 아닌 이웃과의 연결에만 적용되거나 체인의 끝점에만 적용되거나 체인을 따른 모든 연결에 적용될 수 있습니다. 다이어그램은 선형이지만 각 참가자는 여러 동시 통신에 참여할 수 있습니다. 예를 들어, B는 A 이외의 많은 클라이언트로부터 요청을 수신하거나 A의 요청을 처리하는 동시에 C 이외의 서버로 요청을 전달할 수 있습니다. 마찬가지로 나중에 요청은 로드 밸런싱을 위한 동적 구성을 기반으로 하는 다른 연결 경로를 통해 전송될 수 있습니다.

"업스트림" 및 "다운스트림"이라는 용어는 메시지 흐름과 관련된 방향 요구 사항을 설명하는 데 사용됩니다. 모든 메시지는 업스트림에서 다운스트림으로 흐릅니다. "인바운드" 및 "아웃바운드"라는 용어는 요청 경로와 관련된 방향 요구 사항을 설명하는 데 사용됩니다. 인바운드는 "원본 서버 방향"을 의미하고 아웃바운드는 "사용자 에이전트 방향"을 의미합니다.

"프록시"는 특정 유형의 절대 URI에 대한 요청을 수신하고 HTTP 인터페이스를 통한 변환을 통해 해당 요청을 만족시키려고 일반적으로 로컬 구성 규칙을 통해 클라이언트가 선택하는 메시지 전달 에이전트입니다. "http" URI에 대한 프록시 요청과 같은 일부 번역은 최소한이지만, 다른 요청은 완전히 다른 애플리케이션 수준 프로토콜로의 번역이 필요할 수 있습니다. 프록시는 보안 서비스, 주석 서비스 또는 공유 캐싱을 위해 공통 중개자를 통해 조직의 HTTP 요청을 그룹화하는 데 자주 사용됩니다. 일부 프록시는 섹션 7.7에 설명된 대로 전달되는 동안 선택한 메시지나 콘텐츠에 변환을 적용하도록 설계되었습니다.

"게이트웨이"\(일명 "역방향 프록시"\)는 아웃바운드 연결에 대한 원본 서버 역할을 하지만 수신된 요청을 변환하고 인바운드로 다른 서버로 전달하는 중개자입니다. 게이트웨이는 종종 레거시 또는 신뢰할 수 없는 정보 서비스를 캡슐화하고, "가속기" 캐싱을 통해 서버 성능을 향상시키며, 여러 시스템에 걸쳐 HTTP 서비스의 분할 또는 로드 균형 조정을 활성화하는 데 사용됩니다.

원본 서버에 적용되는 모든 HTTP 요구 사항은 게이트웨이의 아웃바운드 통신에도 적용됩니다. 게이트웨이는 이 사양의 범위를 벗어나는 HTTP에 대한 개인 확장을 포함하여 원하는 프로토콜을 사용하여 인바운드 서버와 통신합니다. 그러나 타사 HTTP 서버와 상호 운용하려는 HTTP-HTTP 게이트웨이는 게이트웨이의 인바운드 연결에 대한 사용자 에이전트 요구 사항을 준수해야 합니다.

"터널"은 메시지를 변경하지 않고 두 연결 간의 블라인드 릴레이 역할을 합니다. 일단 활성화되면 터널은 HTTP 요청에 의해 시작되었을 수 있지만 HTTP 통신의 당사자로 간주되지 않습니다. 릴레이된 연결의 양쪽 끝이 닫히면 터널은 더 이상 존재하지 않습니다. 터널은 전송 계층 보안\(TLS, \[TLS13\]\)을 사용하여 공유 방화벽 프록시를 통해 기밀 통신을 설정하는 경우와 같이 중개자를 통해 가상 연결을 확장하는 데 사용됩니다.

중개자에 대한 위의 범주는 HTTP 통신의 참가자 역할만 고려합니다. 네트워크 프로토콜 스택의 하위 계층에서 작동하여 메시지 보낸 사람이 알지 못하거나 허가를 받지 않고도 HTTP 트래픽을 필터링하거나 리디렉션할 수 있는 중개자도 있습니다. 네트워크 중개자는 \(프로토콜 수준에서\) 경로상의 공격자와 구별할 수 없으며 실수로 HTTP 의미 체계를 위반하여 보안 결함이나 상호 운용성 문제를 일으키는 경우가 많습니다.

예를 들어, "가로채기 프록시"\[RFC3040\]\(일반적으로 "투명 프록시"\[RFC1919\]라고도 함\)는 클라이언트가 선택하지 않는다는 점에서 HTTP 프록시와 다릅니다. 대신, 차단 프록시는 나가는 TCP 포트 80 패킷\(때때로 기타 일반 포트 트래픽\)을 필터링하거나 리디렉션합니다. 가로채기 프록시는 로컬이 아닌 인터넷 서비스 사용을 허용하기 전에 계정 가입을 시행하는 수단으로, 그리고 회사 방화벽 내에서 네트워크 사용 정책을 시행하는 수단으로 공용 네트워크 액세스 포인트에서 흔히 발견됩니다.

---
### **3.8.  Caches**

"캐시"는 이전 응답 메시지의 로컬 저장소이자 메시지 저장, 검색 및 삭제를 제어하는 ​​하위 시스템입니다. 캐시는 향후 동등한 요청에 대한 응답 시간과 네트워크 대역폭 소비를 줄이기 위해 캐시 가능한 응답을 저장합니다. 모든 클라이언트나 서버는 캐시를 사용할 수 있지만 터널 역할을 하는 동안에는 캐시를 사용할 수 없습니다.

캐시의 효과는 체인에 있는 참가자 중 하나가 해당 요청에 적용할 수 있는 캐시된 응답을 가지고 있는 경우 요청/응답 체인이 단축된다는 것입니다. 다음은 UA 또는 A가 캐시하지 않은 요청에 대해 \(C를 통해\) O로부터 이전 응답의 캐시된 복사본이 B에 있는 경우 결과 체인을 보여줍니다.

```text
               >             >
          UA =========== A =========== B - - - - - - C - - - - - - O
                     <             <

                                  Figure 3
```

캐시가 후속 요청에 응답하는 데 사용하기 위해 응답 메시지의 복사본을 저장할 수 있는 경우 응답은 "캐시 가능"합니다. 응답을 캐시할 수 있는 경우에도 캐시된 응답을 특정 요청에 사용할 수 있는 시기에 대해 클라이언트나 원본 서버에서 추가 제약 조건을 적용할 수 있습니다. 캐시 동작 및 캐시 가능한 응답에 대한 HTTP 요구 사항은 \[CACHING\]에 정의되어 있습니다.

World Wide Web과 대규모 조직 내부에는 매우 다양한 아키텍처와 캐시 구성이 배포되어 있습니다. 여기에는 대역폭을 절약하고 대기 시간을 줄이기 위한 프록시 캐시의 국가 계층 구조, 인기 사이트의 지역 및 글로벌 배포를 최적화하기 위해 게이트웨이 캐싱을 사용하는 콘텐츠 전달 네트워크, 캐시 항목을 브로드캐스트 또는 멀티캐스트하는 협업 시스템, 다음에서 사용할 수 있도록 미리 가져온 캐시 항목 아카이브가 포함됩니다. 오프라인 또는 대기 시간이 긴 환경 등.

---
### **3.9.  Example Message Exchange**

다음 예에서는 URI "http://www.example.com/hello.txt"의 GET 요청\(9.3.1절\)에 대한 일반적인 HTTP/1.1 메시지 교환을 보여줍니다.

```text
   Client request:

   GET /hello.txt HTTP/1.1
   User-Agent: curl/7.64.1
   Host: www.example.com
   Accept-Language: en, mi

   Server response:

   HTTP/1.1 200 OK
   Date: Mon, 27 Jul 2009 12:28:53 GMT
   Server: Apache
   Last-Modified: Wed, 22 Jul 2009 19:15:56 GMT
   ETag: "34aa387-d-1568eb00"
   Accept-Ranges: bytes
   Content-Length: 51
   Vary: Accept-Encoding
   Content-Type: text/plain
```

안녕하세요 월드! 내 콘텐츠에는 후행 CRLF가 포함되어 있습니다.

---
## **4.  Identifiers in HTTP**

URI\(Uniform Resource Identifier\) ​​\[URI\]는 HTTP 전체에서 리소스를 식별하는 수단으로 사용됩니다\(섹션 3.1\).

---
### **4.1.  URI References**

URI 참조는 요청 대상 지정, 리디렉션 표시 및 관계 정의에 사용됩니다.

"URI-reference", "absolute-URI", "relative-part", "authority", "port", "host", "path-abempty", "segment" 및 "query"의 정의는 다음에서 채택됩니다. URI 일반 구문. 비어 있지 않은 경로 구성 요소를 포함할 수 있는 프로토콜 요소에 대해 "절대 경로" 규칙이 정의됩니다. \(이 규칙은 빈 경로를 허용하는 RFC 3986의 경로 금지 규칙 및 "//"로 시작하는 경로를 허용하지 않는 경로 절대 규칙과 약간 다릅니다.\) "부분 URI" 규칙은 다음과 같습니다. 상대 URI는 포함할 수 있지만 조각 구성 요소는 포함할 수 없는 프로토콜 요소에 대해 정의됩니다.

```text
     URI-reference = <URI-reference, see [URI], Section 4.1>
     absolute-URI  = <absolute-URI, see [URI], Section 4.3>
     relative-part = <relative-part, see [URI], Section 4.2>
     authority     = <authority, see [URI], Section 3.2>
     uri-host      = <host, see [URI], Section 3.2.2>
     port          = <port, see [URI], Section 3.2.3>
     path-abempty  = <path-abempty, see [URI], Section 3.3>
     segment       = <segment, see [URI], Section 3.3>
     query         = <query, see [URI], Section 3.4>

     absolute-path = 1*( "/" segment )
     partial-URI   = relative-part [ "?" query ]
```

URI 참조를 허용하는 HTTP의 각 프로토콜 요소는 해당 요소가 모든 참조 형식\(URI-참조\)을 허용하는지, 절대 형식의 URI\(절대-URI\)만 허용하는지, 경로 및 선택적 쿼리 구성 요소\( 부분 URI\) 또는 위의 일부 조합입니다. 달리 명시하지 않는 한, URI 참조는 대상 URI\(섹션 7.1\)를 기준으로 구문 분석됩니다.

모든 발신자와 수신자는 프로토콜 요소에서 최소한 길이가 8000옥텟인 URI를 지원하는 것이 좋습니다. 이는 일부 구조와 온-와이어 표현\(예: HTTP/1.1의 요청 라인\)이 어떤 경우에는 필연적으로 더 커질 수 있음을 의미합니다.

---
### **4.2.  HTTP-Related URI Schemes**

IANA는 <https://www.iana.org/locationments/uri-schemes/\>에서 URI 체계 \[BCP35\]의 레지스트리를 유지 관리합니다. 요청은 모든 URI 체계를 대상으로 할 수 있지만 다음 체계는 HTTP 서버에 고유합니다.

```text
   +============+====================================+=========+
   | URI Scheme | Description                        | Section |
   +============+====================================+=========+
   | http       | Hypertext Transfer Protocol        | 4.2.1   |
   +------------+------------------------------------+---------+
   | https      | Hypertext Transfer Protocol Secure | 4.2.2   |
   +------------+------------------------------------+---------+

                              Table 2
```

"http" 또는 "https" URI가 있다고 해서 식별된 원본에 항상 연결을 수신하는 HTTP 서버가 있다는 의미는 아닙니다. 서버의 존재 여부와 해당 서버가 현재 해당 식별자를 리소스에 매핑하는지 여부에 관계없이 누구나 URI를 생성할 수 있습니다. 등록된 이름과 IP 주소의 위임된 특성은 HTTP 서버의 존재 여부에 관계없이 페더레이션된 네임스페이스를 생성합니다.

---
#### **4.2.1.  http URI Scheme**

"http" URI 체계는 주어진 포트에서 TCP\(\[TCP\]\) 연결을 수신하는 잠재적인 HTTP 원본 서버가 관리하는 계층적 네임스페이스 내에서 식별자를 생성하기 위해 정의됩니다.

```text
     http-URI = "http" "://" authority path-abempty [ "?" query ]
```

"http" URI의 원본 서버는 호스트 식별자\(\[URI\], 섹션 3.2.2\)와 선택적 포트 번호\(\[URI\], 섹션 3.2.3\)를 포함하는 권한 구성 요소로 식별됩니다. 포트 하위 구성 요소가 비어 있거나 지정되지 않은 경우 TCP 포트 80\(WWW 서비스용으로 예약된 포트\)이 기본값입니다. 원본은 섹션 4.3.2에 정의된 대로 식별된 리소스를 대상으로 하는 요청에 권위 있게 응답할 권리가 있는 사람을 결정합니다.

발신자는 빈 호스트 식별자를 사용하여 "http" URI를 생성해서는 안 됩니다. 그러한 URI 참조를 처리하는 수신자는 이를 유효하지 않은 것으로 거부해야 합니다.

계층적 경로 구성 요소와 선택적 쿼리 구성 요소는 원본 서버의 네임스페이스 내에서 대상 리소스를 식별합니다.

---
#### **4.2.2.  https URI Scheme**"https" URI 체계는 주어진 포트에서 TCP 연결을 수신하고 HTTP 통신을 위해 보안이 설정된 TLS\(\[TLS13\]\) 연결을 설정할 수 있는 잠재적인 원서버에 의해 관리되는 계층적 네임스페이스 내에서 식별자를 생성하기 위해 정의됩니다. 이 맥락에서 "보안됨"은 특히 서버가 식별된 기관을 대신하여 작동하는 것으로 인증되었으며 해당 서버와의 모든 HTTP 통신에 클라이언트와 서버 모두에서 허용되는 기밀성과 무결성 보호가 있음을 의미합니다.

```text
     https-URI = "https" "://" authority path-abempty [ "?" query ]
```

"https" URI의 원본 서버는 호스트 식별자\(\[URI\], 섹션 3.2.2\)와 선택적 포트 번호\(\[URI\], 섹션 3.2.3\)를 포함하는 권한 구성 요소로 식별됩니다. 포트 하위 구성 요소가 비어 있거나 지정되지 않은 경우 TCP 포트 443\(TLS를 통한 HTTP용으로 예약된 포트\)이 기본값입니다. 원본은 섹션 4.3.3에 정의된 대로 식별된 리소스를 대상으로 하는 요청에 권위 있게 응답할 권리가 있는 사람을 결정합니다.

발신자는 빈 호스트 식별자를 사용하여 "https" URI를 생성해서는 안 됩니다. 그러한 URI 참조를 처리하는 수신자는 이를 유효하지 않은 것으로 거부해야 합니다.

계층적 경로 구성 요소와 선택적 쿼리 구성 요소는 원본 서버의 네임스페이스 내에서 대상 리소스를 식별합니다.

클라이언트는 통신하기 전에 "https" 리소스에 대한 HTTP 요청이 보안되어 있는지 확인하고 해당 요청에 대한 보안 응답만 수락하는지 확인해야 합니다. 클라이언트와 서버에 허용되는 암호화 메커니즘에 대한 정의는 일반적으로 협상되며 시간이 지남에 따라 변경될 수 있습니다.

"https" 구성표를 통해 사용할 수 있는 리소스는 "http" 구성표와 공유된 ID가 없습니다. 이는 별도의 네임스페이스를 가진 고유한 원본입니다. 그러나 쿠키 프로토콜 \[COOKIE\]과 같이 동일한 호스트를 사용하는 모든 원본에 적용되도록 정의된 HTTP 확장을 사용하면 한 서비스에서 설정한 정보가 일치하는 호스트 도메인 그룹 내의 다른 서비스와의 통신에 영향을 미칠 수 있습니다. 이러한 확장은 보안 연결에서 얻은 정보가 보안되지 않은 컨텍스트 내에서 실수로 교환되는 것을 방지하기 위해 세심한 주의를 기울여 설계되어야 합니다.

---
#### **4.2.3.  http(s) Normalization and Comparison**

"http" 또는 "https" 구성표를 사용하는 URI는 각 구성표에 대해 위에서 설명한 기본값을 사용하여 \[URI\]의 섹션 6에 정의된 방법에 따라 정규화되고 비교됩니다.

HTTP는 동등성을 결정하기 위해 특정 방법을 사용할 것을 요구하지 않습니다. 예를 들어 캐시 키는 구문 기반 정규화 후 또는 구성표 기반 정규화 후에 단순 문자열로 비교될 수 ​​있습니다.

"http" 및 "https" URI의 체계 기반 정규화\(\[URI\]의 섹션 6.2.3\)에는 다음과 같은 추가 규칙이 포함됩니다.

\* 포트가 구성표의 기본 포트와 동일한 경우 일반적인 형식은 포트 하위 구성 요소를 생략하는 것입니다.

\* OPTIONS 요청의 대상으로 사용되지 않는 경우 빈 경로 구성 요소는 "/"의 절대 경로와 동일하므로 대신 "/"의 경로를 제공하는 것이 일반적인 형식입니다.

\* 구성표와 호스트는 대소문자를 구분하지 않으며 일반적으로 소문자로 제공됩니다. 다른 모든 구성요소는 대소문자를 구분하여 비교됩니다.

\* "예약된" 집합에 있는 문자 이외의 문자는 백분율로 인코딩된 옥텟과 동일합니다. 일반적인 형식은 해당 문자를 인코딩하지 않는 것입니다\(\[URI\]의 섹션 2.1 및 2.2 참조\).

예를 들어 다음 세 개의 URI는 동일합니다.

```text
      http://example.com:80/~smith/home.html
      http://EXAMPLE.com/%7Esmith/home.html
      http://EXAMPLE.com:/%7esmith/home.html
```

정규화\(어떤 방법을 사용하든\) 후에 동등한 두 HTTP URI는 동일한 리소스를 식별하는 것으로 가정할 수 있으며 모든 HTTP 구성 요소는 정규화를 수행할 수 있습니다. 결과적으로, 고유한 리소스는 정규화 후\(\[URI\]의 섹션 6.2에 정의된 방법을 사용하여\) 동등한 HTTP URI로 식별되어서는 안 됩니다.

---
#### **4.2.4.  Deprecation of userinfo in http(s) URIs**

권한에 대한 URI 일반 구문에는 URI에 사용자 인증 정보를 포함하기 위한 userinfo 하위 구성요소\(\[URI\], 섹션 3.2.1\)도 포함되어 있습니다. 해당 하위 구성요소에서는 "user:password" 형식의 사용이 더 이상 사용되지 않습니다.

일부 구현에서는 명령 호출 옵션, 구성 파일 또는 책갈피 목록 내와 같은 인증 정보의 내부 구성을 위해 userinfo 구성 요소를 사용합니다. 이러한 사용으로 인해 사용자 식별자나 비밀번호가 노출될 수도 있습니다.

"http" 또는 "https" URI 참조가 메시지 내에서 대상 URI 또는 ​​필드 값으로 생성될 때 발신자는 userinfo 하위 구성 요소\(및 해당 "@" 구분 기호\)를 생성해서는 안 됩니다.

신뢰할 수 없는 소스로부터 수신된 "http" 또는 "https" URI 참조를 사용하기 전에 수신자는 사용자 정보를 구문 분석하고 그 존재를 오류로 처리해야 합니다. 피싱 공격을 위해 권한을 모호하게 하는 데 사용될 가능성이 높습니다.

---
#### **4.2.5.  http(s) References with Fragment Identifiers**

조각 식별자는 \[URI\]의 섹션 3.5에 정의된 대로 URI 체계와 관계없이 보조 리소스의 간접적인 식별을 허용합니다. URI를 참조하는 일부 프로토콜 요소는 조각 포함을 허용하지만 다른 요소는 그렇지 않습니다. 조각이 허용되는 요소에 대해 ABNF 규칙을 사용하여 구별됩니다. 그렇지 않으면 조각을 제외하는 특정 규칙이 사용됩니다.

- | \*참고:\* 조각 식별자 구성요소는 | URI 체계에 대한 체계 정의\(\[URI\]의 섹션 4.3 참조\), | 따라서 "http" 및 |에 대한 ABNF 정의에는 나타나지 않습니다. 위의 "https" URI 체계.

---
### **4.3.  Authoritative Access**

권한 있는 액세스는 식별된 리소스에 액세스하기 위해 클라이언트가 권한이 있다고 믿는 방식\(리소스 소유자에 의해 제어됨\)으로 지정된 식별자를 역참조하는 것을 의미합니다. 접근 허가 여부를 결정하는 프로세스는 URI 체계에 의해 정의되며 일반 구문이 사용될 때 권한 구성 요소와 같은 URI 구성 요소 내의 데이터를 사용하는 경우가 많습니다. 그러나 권한 있는 액세스는 식별된 메커니즘으로 제한되지 않습니다.

섹션 4.3.1에서는 그러한 사용을 돕기 위해 출처의 개념을 정의하고 후속 하위 섹션에서는 피어가 출처를 표시할 권한이 있는지 확인하는 방법을 설명합니다.

권한 설정과 관련된 보안 고려 사항은 섹션 17.1을 참조하세요.

---
#### **4.3.1.  URI Origin**

지정된 URI의 "원산지"는 구성표와 호스트를 소문자로 정규화하고 앞에 오는 0을 제거하기 위해 포트를 정규화한 후 구성표, 호스트 및 포트의 세 가지입니다. 포트가 URI에서 제거되면 해당 구성표의 기본 포트가 사용됩니다. 예를 들어, URI

```text
      https://Example.Com/happy.js
```

유래가 있겠지

```text
      { "https", "example.com", "443" }
```

이는 포트가 항상 존재하는 정규화된 URI 접두사로 설명될 수도 있습니다.

```text
      https://example.com:443
```

각 원본은 자체 네임스페이스를 정의하고 해당 네임스페이스 내의 식별자가 리소스에 매핑되는 방식을 제어합니다. 결과적으로, 오리진이 시간이 지남에 따라 일관되게 유효한 요청에 응답하는 방식에 따라 사용자가 URI와 연관시킬 의미 체계가 결정되며, 이러한 의미 체계의 유용성은 궁극적으로 이러한 메커니즘을 사용자가 미래에 참조하고 액세스할 수 있는 리소스로 변환하는 것입니다. .

두 원본은 구성표, 호스트 또는 포트가 다른 경우 서로 다릅니다. 동일한 엔터티가 두 개의 서로 다른 원본을 제어하는 ​​것이 확인될 수 있더라도 해당 원본에 대해 권한이 있는 서버가 명시적으로 별칭을 지정하지 않는 한 해당 원본 아래의 두 네임스페이스는 서로 다릅니다.

Origin은 \[RFC6454\]에 설명된 대로 이 문서의 범위를 벗어나 HTML 및 관련 웹 프로토콜 내에서도 사용됩니다.

---
#### **4.3.2.  http Origins**

HTTP는 전송 프로토콜과 독립적이지만 "http" 체계\(4.2.1절\)는 권한 구성요소 내에서 식별된 호스트의 지정된 포트에서 TCP 연결을 수신하는 원서버를 제어하는 ​​사람과 권한을 연관시키는 데 특정합니다. 이는 클라이언트별 이름 확인 메커니즘과 경로상의 공격자로부터 보호되지 않을 수 있는 통신에 의존하기 때문에 권위가 매우 약합니다. 그럼에도 불구하고 이는 신뢰할 수 있는 환경 내에서 일관된 해결을 위해 "http" 식별자를 원본 서버에 바인딩하기 위한 충분한 최소값입니다.

호스트 식별자가 IP 주소로 제공되는 경우 원본 서버는 해당 IP 주소에 표시된 TCP 포트의 수신기\(있는 경우\)입니다. 호스트가 등록된 이름인 경우 등록된 이름은 적절한 원본 서버의 주소를 찾기 위해 DNS와 같은 이름 확인 서비스와 함께 사용하기 위한 간접 식별자입니다.

표시된 리소스에 대한 액세스를 요구하는 컨텍스트 내에서 "http" URI가 사용되는 경우 클라이언트는 호스트 식별자를 IP 주소로 확인하고 표시된 포트에서 해당 주소에 대한 TCP 연결을 설정한 후 전송을 통해 액세스를 시도할 수 있습니다. 해당 연결은 클라이언트의 대상 URI\(섹션 7.1\)와 일치하는 요청 대상을 포함하는 HTTP 요청 메시지입니다.

서버가 섹션 15에 설명된 대로 임시가 아닌 HTTP 응답 메시지로 해당 요청에 응답하는 경우 해당 응답은 클라이언트 요청에 대한 신뢰할 수 있는 응답으로 간주됩니다.

그러나 위의 내용은 권위 있는 응답을 얻기 위한 유일한 수단이 아니며, 권위 있는 응답이 항상 필요하다는 의미도 아닙니다\(\[CACHING\] 참조\). 예를 들어 Alt-Svc 헤더 필드 \[ALTSVC\]를 사용하면 원본 서버가 해당 원본에 대해 권한이 있는 다른 서비스를 식별할 수 있습니다. "http"로 식별된 리소스에 대한 액세스는 이 문서의 범위를 벗어난 프로토콜을 통해 제공될 수도 있습니다.

---
#### **4.3.3.  https Origins**

"https" 체계\(Section 4.2.2\)는 클라이언트가 식별된 원본 서버에 대해 신뢰할 수 있다고 간주하는 인증서에 해당하는 개인 키를 사용하는 서버의 능력을 기반으로 권한을 연결합니다. 클라이언트는 일반적으로 인증서를 신뢰할 수 있는 것으로 간주하기 위해 미리 준비되거나 구성된 트러스트 앵커에서 전달되는 신뢰 체인에 의존합니다\(4.3.4절\).

HTTP/1.1 및 이전 버전에서 클라이언트는 해당 URI 원본의 호스트에 대해 성공적으로 설정되고 보안된 연결을 통해 통신할 때만 서버에 권한을 부여합니다. 연결 설정 및 인증서 확인은 권한 증명으로 사용됩니다.

HTTP/2 및 HTTP/3에서 클라이언트는 성공적으로 설정되고 보안된 연결을 통해 통신할 때 URI 원본의 호스트가 서버 인증서에 있는 호스트 중 하나와 일치하고 클라이언트가 그럴 수 있다고 믿는 경우 서버에 권한을 부여합니다. 해당 URI에 대해 해당 호스트에 대한 연결을 엽니다. 실제로 클라이언트는 원본 호스트에 설정된 연결과 동일한 서버 IP 주소가 포함되어 있는지 확인하기 위해 DNS 쿼리를 수행합니다. 이 제한은 원본 서버가 동등한 ORIGIN 프레임 \[RFC8336\]을 보내면 제거될 수 있습니다.

요청 대상의 호스트 및 포트 값은 각 HTTP 요청 내에서 전달되어 원본을 식별하고 동일한 서버에 의해 제어될 수 있는 다른 네임스페이스와 구별됩니다\(섹션 7.2\). 인증서의 개인 키에 대한 제어를 제공하는 모든 서비스가 해당 "https" 네임스페이스를 관리하는 데 동등하게 책임이 있거나 적어도 잘못된 방향으로 표시된 요청을 거부할 준비가 되어 있는지 확인하는 것은 원본의 책임입니다\(7.4절\).

원본 서버는 권한이 있어도 특정 대상 URI에 대한 요청을 처리하지 않을 수 있습니다. 예를 들어, 호스트가 서로 다른 포트\(예: 443 및 8000\)에서 고유한 서비스를 운영하는 경우 네트워크 공격자가 한 포트에 대한 연결을 유발하여 연결이 보안된 후에도 원본 서버에서 대상 URI를 확인해야 합니다. 다른 항구에서 받을 수 있습니다. 대상 URI를 확인하지 못하면 공격자가 하나의 대상 URI\(예: "https://example.com/foo"\)에 대한 응답을 다른 포트\(예: "https:/ /example.com:8000/foo"\).

"https" 구성표는 인증 기관을 연결하기 위해 TCP와 연결된 포트 번호에 의존하지 않습니다. 둘 다 보안 통신 외부에 있으므로 최종적으로 신뢰할 수 없기 때문입니다. 따라서 HTTP 통신은 TCP를 사용하지 않는 프로토콜을 포함하여 섹션 4.2.2에 정의된 대로 보안이 설정된 모든 채널을 통해 발생할 수 있습니다.

표시된 리소스에 대한 액세스를 요구하는 컨텍스트 내에서 "https" URI가 사용되는 경우 클라이언트는 호스트 식별자를 IP 주소로 확인하고 표시된 포트에서 해당 주소에 대한 TCP 연결을 설정하고 연결을 보호함으로써 액세스를 시도할 수 있습니다. 기밀성 및 무결성 보호를 통해 TCP를 통한 TLS를 성공적으로 시작하고 클라이언트의 대상 URI\(섹션 7.1\)와 일치하는 요청 대상이 포함된 HTTP 요청 메시지를 해당 연결을 통해 전송함으로써 엔드 투 엔드를 수행합니다.

서버가 섹션 15에 설명된 대로 임시가 아닌 HTTP 응답 메시지로 해당 요청에 응답하는 경우 해당 응답은 클라이언트 요청에 대한 신뢰할 수 있는 응답으로 간주됩니다.

그러나 위의 내용은 권위 있는 응답을 얻기 위한 유일한 수단이 아니며, 권위 있는 응답이 항상 필요하다는 의미도 아닙니다\(\[CACHING\] 참조\).

---
#### **4.3.4.  https Certificate Verification**

URI를 역참조하기 위해 보안 연결을 설정하려면 클라이언트는 서비스의 ID가 URI의 원본 서버에 대해 허용 가능한 일치인지 확인해야 합니다. 인증서 확인은 경로상의 공격자 또는 이름 확인을 제어하는 ​​공격자의 서버 가장을 방지하는 데 사용됩니다. 이 프로세스에서는 트러스트 앵커 세트로 클라이언트를 구성해야 합니다.

일반적으로 클라이언트는 \[RFC6125\]의 섹션 6에 정의된 확인 프로세스를 사용하여 서비스 ID를 확인해야 합니다. 클라이언트는 서비스의 호스트에서 참조 ID를 구성해야 합니다. 호스트가 리터럴 IP 주소\(섹션 4.3.5\)인 경우 참조 ID는 IP-ID이고, 그렇지 않으면 호스트는 이름이고 참조 ID는 DNS입니다. ID.

CN-ID 유형의 참조 ID는 클라이언트에서 사용하면 안 됩니다. \[RFC6125\]의 섹션 6.2.1에 명시된 대로 CN-ID 유형의 참조 ID는 이전 클라이언트에서 사용될 수 있습니다.

클라이언트는 서버 ID 확인의 대체 형식을 허용하도록 특별히 구성되었을 수 있습니다. 예를 들어, 클라이언트는 서비스가 대상 URI의 원본과 일치하는 인증서가 아닌 특정 인증서\(또는 외부에서 정의된 일부 참조 ID와 일치하는 인증서\)를 제공할 것으로 기대하면서 주소와 호스트 이름이 동적인 서버에 연결할 수 있습니다.

특별한 경우에는 클라이언트가 단순히 서버의 ID를 무시하는 것이 적절할 수 있지만 이로 인해 연결이 활성 공격에 노출된다는 점을 이해해야 합니다.

인증서가 대상 URI의 출처에 대해 유효하지 않은 경우 사용자 에이전트는 계속 진행하기 전에 사용자로부터 확인을 얻거나\(섹션 3.5 참조\) 잘못된 인증서 오류로 연결을 종료해야 합니다. 자동화된 클라이언트는 적절한 감사 로그\(사용 가능한 경우\)에 오류를 기록해야 하며\(잘못된 인증서 오류가 있는 경우\) 연결을 종료해야 합니다. 자동화된 클라이언트는 이 검사를 비활성화하는 구성 설정을 제공할 수 있지만 이를 활성화하는 설정을 제공해야 합니다.

---
#### **4.3.5.  IP-ID Reference Identity**

"https" URI의 "호스트" 필드에서 IP 주소 리터럴을 사용하여 식별되는 서버에는 IP-ID 유형의 참조 ID가 있습니다. IP 버전 4 주소는 "IPv4address" ABNF 규칙을 사용하고, IP ​​버전 6 주소는 "IPv6address" 옵션과 함께 "IP-literal" 생성을 사용합니다. \[URI\]의 섹션 3.2.2를 참조하세요. IP-ID의 참조 ID에는 IP 주소의 디코딩된 바이트가 포함됩니다.

IP 버전 4 주소는 4옥텟이고, IP ​​버전 6 주소는 16옥텟입니다. 다른 IP 버전에서는 IP-ID 사용이 정의되지 않습니다. 인증서 subjectAltName 확장의 iPAddress 선택에는 IP 버전이 명시적으로 포함되지 않으므로 주소 길이에 따라 버전을 구별합니다. \[RFC5280\]의 섹션 4.2.1.6을 참조하세요.

IP-ID 유형의 참조 ID는 주소가 인증서의 subjectAltName 확장의 iPAddress 값과 동일한 경우 일치합니다.

---
## **5.  Fields**

HTTP는 "필드"를 사용하여 등록된 키 네임스페이스와 함께 확장 가능한 이름/값 쌍의 형태로 데이터를 제공합니다. 필드는 메시지의 헤더 및 트레일러 섹션 내에서 전송되고 수신됩니다\(섹션 6\).

---
### **5.1.  Field Names**

필드 이름은 해당 필드 값에 해당 이름으로 정의된 의미를 갖는 것으로 레이블을 지정합니다. 예를 들어 Date 헤더 필드는 섹션 6.6.1에서 그것이 나타나는 메시지의 발생 타임스탬프를 포함하는 것으로 정의됩니다.

```text
     field-name     = token
```

필드 이름은 대소문자를 구분하지 않으며 "HTTP\(Hypertext Transfer Protocol\) 필드 이름 레지스트리" 내에 등록되어야 합니다. 섹션 16.3.1을 참조하세요.

필드 해석은 동일한 주요 HTTP 버전의 부 버전 간에 변경되지 않습니다. 하지만 해당 필드가 없을 때 수신자의 기본 동작은 변경될 수 있습니다. 달리 지정하지 않는 한 필드는 모든 HTTP 버전에 대해 정의됩니다. 특히, 호스트 및 연결 필드는 HTTP/1.1 준수를 광고하는지 여부에 관계없이 모든 HTTP 구현에서 인식되어야 합니다.

정의된 의미 체계를 통해 해당 필드를 인식하지 못하는 수신자가 해당 필드를 안전하게 무시할 수 있는 경우 프로토콜 버전을 변경하지 않고도 새 필드를 도입할 수 있습니다. 섹션 16.3을 참조하세요.

필드 이름이 연결 헤더 필드\(섹션 7.6.1\)에 나열되어 있지 않거나 프록시가 그러한 필드를 차단하거나 변환하도록 특별히 구성되지 않은 한 프록시는 인식되지 않는 헤더 필드를 전달해야 합니다\(MUST\). 다른 수신자는 인식되지 않는 헤더 및 트레일러 필드를 무시해야 합니다\(SHOULD\). 이러한 요구 사항을 준수하면 배포된 중개자를 업데이트하거나 제거하지 않고도 HTTP 기능을 확장할 수 있습니다.

---
### **5.2.  Field Lines and Combined Field Value**

필드 섹션은 필드를 식별하는 "필드 이름"\(섹션 5.1 참조\)과 해당 필드 인스턴스에 대한 데이터를 전달하는 "필드 라인 값"을 포함하는 여러 개의 "필드 라인"으로 구성됩니다.

필드 이름이 섹션에 한 번만 존재하는 경우 해당 필드에 대해 결합된 "필드 값"은 해당 필드 줄 값으로 구성됩니다. 섹션 내에서 필드 이름이 반복되는 경우 결합된 필드 값은 해당 섹션 내의 해당 필드 줄 값 목록으로 구성되며, 각 필드 줄 값은 쉼표로 구분되어 순서대로 연결됩니다.

예를 들어 이 섹션은 다음과 같습니다.

```text
   Example-Field: Foo, Bar
   Example-Field: Baz
```

필드 이름이 "Example-Field"인 두 개의 필드 줄이 포함되어 있습니다. 첫 번째 필드 라인의 필드 라인 값은 "Foo, Bar"이고, 두 번째 필드 라인 값은 "Baz"입니다. "예제 필드"의 필드 값은 "Foo, Bar, Baz" 목록입니다.

---
### **5.3.  Field Order**

수신자는 메시지의 의미를 변경하지 않고 동일한 필드 이름을 가진 필드 섹션 내의 여러 필드 행을 하나의 필드 행으로 결합할 수 있습니다. 이는 각각의 후속 필드 행 값을 쉼표로 구분하여 초기 필드 행 값에 순서대로 추가합니다. \(","\) 및 선택적 공백\(OWS, 섹션 5.6.3에 정의됨\). 일관성을 위해 쉼표 SP를 사용하십시오.

따라서 동일한 이름을 가진 필드 줄이 수신되는 순서는 필드 값 해석에 중요합니다. 프록시는 메시지를 전달할 때 이러한 필드 라인 값의 순서를 변경해서는 안 됩니다.

이는 아래에 언급된 잘 알려진 예외를 제외하고 발신자는 메시지\(헤더 또는 트레일러에 관계없이\)에서 동일한 이름을 가진 여러 필드 행을 생성하거나 동일한 이름의 필드 행이 있을 때 필드 행을 추가해서는 안 된다는 것을 의미합니다. 해당 필드의 정의가 여러 필드 줄 값을 쉼표로 구분된 목록으로 재결합하는 것을 허용하지 않는 한 메시지에 이미 존재합니다. 즉, 필드 정의의 적어도 하나의 대안이 #\(의 ABNF 규칙과 같이 쉼표로 구분된 목록을 허용합니다. 값\) 섹션 5.6.1\)에 정의되어 있습니다.

- | \*참고:\* 실제로는 "Set-Cookie" 헤더 필드\(\[COOKIE\]\) | 여러 필드 줄에 걸쳐 응답 메시지에 자주 나타남 | 위의 사항을 위반하여 목록 구문을 사용하지 않습니다 | 동일한 필드 이름을 가진 여러 필드 줄에 대한 요구 사항입니다. | 단일 필드 값으로 결합할 수 없으므로 | 수신자는 "Set-Cookie"를 특별한 경우로 처리해야 하며 | 처리 분야. \(자세한 내용은 \[Kri2001\]의 부록 A.2.3을 참조하세요.\)

서로 다른 필드 이름을 가진 필드 줄이 섹션에 수신되는 순서는 중요하지 않습니다. 그러나 구현 시 가능한 한 빨리 메시지를 처리하지 않을 시기를 결정할 수 있도록 요청 시 호스트, 응답 시 날짜 등 추가 제어 데이터가 포함된 헤더 필드를 먼저 보내는 것이 좋습니다.

서버는 전체 요청 헤더 섹션을 수신할 때까지 대상 리소스에 요청을 적용해서는 안 됩니다. 왜냐하면 이후 헤더 필드 라인에는 조건부, 인증 자격 증명 또는 요청 처리에 영향을 줄 수 있는 의도적으로 오해의 소지가 있는 중복 헤더 필드가 포함될 수 있기 때문입니다.

---
### **5.4.  Field Limits**

HTTP는 섹션 2에 설명된 것처럼 각 필드 줄의 길이, 필드 값 또는 헤더나 트레일러 섹션 전체의 길이에 미리 정의된 제한을 두지 않습니다. 실제로는 개별 길이에 대한 다양한 임시 제한이 있습니다. 종종 특정 필드의 의미에 따라 달라집니다.

처리하려는 것보다 더 큰 요청 헤더 필드 라인, 필드 값 또는 필드 세트를 수신하는 서버는 적절한 4xx\(클라이언트 오류\) 상태 코드로 응답해야 합니다. 이러한 헤더 필드를 무시하면 밀수 공격을 요청하는 서버의 취약성이 증가합니다\(\[HTTP/1.1\]의 섹션 11.2\).

필드 의미 체계가 메시지 프레임이나 응답 의미 체계를 변경하지 않고 삭제된 값을 안전하게 무시할 수 있는 경우 클라이언트는 클라이언트가 처리하기를 원하는 것보다 큰 수신 필드 행을 삭제하거나 잘라낼 수 있습니다.

---
### **5.5.  Field Values**

HTTP 필드 값은 필드의 문법에 의해 정의된 형식의 문자 시퀀스로 구성됩니다. 각 필드의 문법은 일반적으로 ABNF\(\[RFC5234\]\)를 사용하여 정의됩니다.

```text
     field-value    = *field-content
     field-content  = field-vchar
                      [ 1*( SP / HTAB / field-vchar ) field-vchar ]
     field-vchar    = VCHAR / obs-text
     obs-text       = %x80-FF
```

필드 값에는 선행 또는 후행 공백이 포함되지 않습니다. 특정 버전의 HTTP가 이러한 공백을 메시지에 표시하도록 허용하는 경우 필드 구문 분석 구현은 필드 값을 평가하기 전에 이러한 공백을 제외해야 합니다\(MUST\).

필드 값은 일반적으로 US-ASCII 문자 범위\[USASCII\]로 제한됩니다. 더 넓은 범위의 문자가 필요한 필드는 \[RFC8187\]에 정의된 것과 같은 인코딩을 사용할 수 있습니다. 역사적으로 HTTP는 ISO-8859-1 문자 집합 \[ISO-8859-1\]의 텍스트가 포함된 필드 콘텐츠를 허용했으며 \[RFC2047\] 인코딩을 통해서만 다른 문자 집합을 지원했습니다. 새로 정의된 필드에 대한 사양은 해당 값을 표시 가능한 US-ASCII 옥텟\(VCHAR\), SP 및 HTAB로 제한해야 합니다\(SHOULD\). 수신자는 필드 콘텐츠\(예: obs-text\)의 다른 허용된 옥텟을 불투명 데이터로 처리해야 합니다\(SHOULD\).

CR, LF 또는 NUL 문자가 포함된 필드 값은 구현 시 해당 문자를 구문 분석하고 해석할 수 있는 다양한 방식으로 인해 유효하지 않고 위험합니다. 필드 값 내의 CR, LF 또는 NUL 수신자는 해당 메시지를 추가로 처리하거나 전달하기 전에 메시지를 거부하거나 해당 문자를 각각 SP로 바꿔야 합니다. 다른 CTL 문자를 포함하는 필드 값도 유효하지 않습니다. 그러나 수신자는 안전한 컨텍스트\(예: 다운스트림 HTTP 파서에서 처리되지 않는 애플리케이션별 인용 문자열\) 내에 나타날 때 견고성을 위해 이러한 문자를 유지할 수 있습니다.

단일 멤버만 필드 값으로 예상하는 필드를 "싱글톤 필드"라고 합니다.

여러 구성원을 필드 값으로 허용하는 필드를 "목록 기반 필드"라고 합니다. 섹션 5.6.1의 목록 연산자 확장은 여러 멤버를 포함할 수 있는 필드 값을 정의하기 위한 일반적인 표기법으로 사용됩니다.

쉼표\(","\)는 멤버 간의 구분 기호로 사용되므로 멤버 내에서 데이터로 허용되는 경우 주의해서 처리해야 합니다. 이는 목록 기반 필드와 싱글톤 필드 모두에 해당됩니다. 싱글톤 필드가 여러 멤버와 함께 잘못 전송될 수 있고 이러한 오류를 감지하면 상호 운용성이 향상되기 때문입니다. HTTP 날짜 또는 URI 참조 요소와 같이 구성원 내에 쉼표가 포함될 것으로 예상되는 필드는 해당 데이터 내의 쉼표를 잠재적인 목록 구분 기호와 구별하기 위해 해당 요소 주위에 구분 기호를 사용하여 정의해야 합니다.

예를 들어 텍스트 날짜와 URI\(둘 중 하나에 쉼표가 포함될 수 있음\)는 다음과 같은 목록 기반 필드 값으로 안전하게 전달될 수 있습니다.

```text
   Example-URIs: "http://example.com/a.html,foo",
                 "http://without-a-comma.example.com/"
   Example-Dates: "Sat, 04 May 1996", "Wed, 14 Sep 2005"
```

큰따옴표 구분 기호는 인용 문자열 생성 시 거의 항상 사용된다는 점에 유의하세요\(5.6.4절\). 큰따옴표 안에 다른 구문을 사용하면 불필요한 혼란이 발생할 수 있습니다.

많은 필드\(예: 섹션 8.3에 정의된 Content-Type\)는 매개 변수 값에 대해 인용되지 않은\(토큰\) 구문과 인용된\(인용 문자열\) 구문을 모두 허용하는 매개 변수에 대한 공통 구문을 사용합니다\(섹션 5.6.6\). 공통 구문을 사용하면 수신자가 기존 파서 구성 요소를 재사용할 수 있습니다. 두 가지 형식을 모두 허용하는 경우 매개변수 값의 의미는 토큰으로 수신되든 인용된 문자열로 수신되든 동일해야 합니다.

- | \*참고:\* 필드 값 구문을 정의하려면 이 사양 | 필드 이름을 따라 명명된 ABNF 규칙을 사용하여 | 해당 필드 값에 대해 허용되는 문법\(해당 값이 | 기본 메시징 구문에서 추출되고 | 여러 인스턴스가 목록으로 결합된 후\)

---
### **5.6.  Common Rules for Defining Field Values**
---
#### **5.6.1.  Lists (#rule ABNF Extension)**

\[RFC5234\]의 ABNF 규칙에 대한 #rule 확장은 일부 목록 기반 필드 값 정의의 가독성을 향상시키는 데 사용됩니다.

쉼표로 구분된 요소 목록을 정의하기 위해 "\*"와 유사한 구성 "#"이 정의됩니다. 전체 형식은 "<n\>#<m\>element"이며, 각각은 단일 쉼표\(","\)와 선택적 공백\(OWS, 섹션 5.6에 정의됨\)으로 구분되어 최소 <n\>개 및 최대 <m\>개의 요소를 나타냅니다. 삼\).

---
##### **5.6.1.1.  Sender Requirements**

목록 구성을 사용하는 모든 제작에서 발신자는 빈 목록 요소를 생성해서는 안 됩니다. 즉, 발신자는 다음 구문을 만족하는 목록을 생성해야 합니다.

```text
     1#element => element *( OWS "," OWS element )

   and:

     #element => [ 1#element ]
```

n \>= 1이고 m \> 1인 경우:

```text
     <n>#<m>element => element <n-1>*<m-1>( OWS "," OWS element )
```

부록 A는 목록 구성이 확장된 후 보낸 사람에 대해 수집된 ABNF를 보여줍니다.

---
##### **5.6.1.2.  Recipient Requirements**

빈 요소는 존재하는 요소 수에 영향을 주지 않습니다. 수신자는 합리적인 수의 빈 목록 요소를 구문 분석하고 무시해야 합니다. 값을 병합하는 발신자의 일반적인 실수를 처리하기에 충분하지만 서비스 거부 메커니즘으로 사용될 수 있을 만큼 많지는 않습니다. 즉, 수신자는 다음 구문을 충족하는 목록을 수락해야 합니다.

```text
     #element => [ element ] *( OWS "," OWS [ element ] )
```

빈 목록 요소가 존재할 가능성이 있기 때문에 RFC 5234 ABNF는 목록 요소의 카디널리티를 적용할 수 없으며 결과적으로 모든 사례는 지정된 카디널리티가 없는 것처럼 매핑됩니다.

예를 들어 다음과 같은 ABNF 프로덕션이 있다고 가정해 보겠습니다.

```text
     example-list      = 1#example-list-elmt
     example-list-elmt = token ; see Section 5.6.2
```

다음은 example-list에 유효한 값입니다\(구분용으로만 사용되는 큰따옴표는 포함되지 않음\).

```text
     "foo,bar"
     "foo ,bar,"
     "foo , ,bar,charlie"
```

반면, 예제 목록 생성에는 비어 있지 않은 요소가 하나 이상 필요하므로 다음 값은 유효하지 않습니다.

```text
     ""
     ","
     ",   ,"
```

---
#### **5.6.2.  Tokens**

토큰은 공백이나 구분 기호를 포함하지 않는 짧은 텍스트 식별자입니다.

```text
     token          = 1*tchar

     tchar          = "!" / "#" / "$" / "%" / "&" / "'" / "*"
                    / "+" / "-" / "." / "^" / "_" / "`" / "|" / "~"
                    / DIGIT / ALPHA
                    ; any VCHAR, except delimiters
```

많은 HTTP 필드 값은 공백이나 특정 구분 문자로 구분된 공통 구문 구성 요소를 사용하여 정의됩니다. 구분 기호는 토큰에 허용되지 않는 US-ASCII 시각적 문자 집합\(DQUOTE 및 "\(\),/:;<=\>?@\[\]{}"\)에서 선택됩니다.

---
#### **5.6.3.  Whitespace**

이 사양에서는 선형 공백의 사용을 나타내기 위해 OWS\(선택적 공백\), RWS\(필수 공백\) 및 BWS\("잘못된" 공백\)의 세 가지 규칙을 사용합니다.

OWS 규칙은 0개 이상의 선형 공백 옥텟이 나타날 수 있는 경우에 사용됩니다. 가독성을 높이기 위해 선택적 공백이 선호되는 프로토콜 요소의 경우 발신자는 선택적 공백을 단일 SP로 생성해야 합니다. 그렇지 않으면 발신자는 내부 메시지 필터링 중에 유효하지 않거나 원치 않는 프로토콜 요소를 덮어쓰는 데 필요한 경우를 제외하고 선택적 공백을 생성해서는 안 됩니다.

RWS 규칙은 필드 토큰을 구분하기 위해 하나 이상의 선형 공백 옥텟이 필요할 때 사용됩니다. 발신자는 RWS를 단일 SP로 생성해야 합니다.

OWS와 RWS는 단일 SP와 동일한 의미를 갖습니다. OWS 또는 RWS로 정의된 것으로 알려진 모든 콘텐츠는 이를 해석하거나 메시지 다운스트림을 전달하기 전에 단일 SP로 대체될 수 있습니다.

BWS 규칙은 문법이 역사적인 이유로 선택적 공백을 허용하는 경우에만 사용됩니다. 발신자는 메시지에서 BWS를 생성해서는 안 됩니다. 수신자는 프로토콜 요소를 해석하기 전에 잘못된 공백을 구문 분석하고 제거해야 합니다.

BWS에는 의미가 없습니다. BWS로 정의된 것으로 알려진 모든 콘텐츠는 이를 해석하거나 메시지 다운스트림을 전달하기 전에 제거될 수 있습니다.

```text
     OWS            = *( SP / HTAB )
                    ; optional whitespace
     RWS            = 1*( SP / HTAB )
                    ; required whitespace
     BWS            = OWS
                    ; "bad" whitespace
```

---
#### **5.6.4.  Quoted Strings**

텍스트 문자열이 큰따옴표를 사용하여 인용된 경우 단일 값으로 구문 분석됩니다.

```text
     quoted-string  = DQUOTE *( qdtext / quoted-pair ) DQUOTE
     qdtext         = HTAB / SP / %x21 / %x23-5B / %x5D-7E / obs-text
```

백슬래시 옥텟\("\"\)은 인용 문자열 및 주석 구성 내에서 단일 옥텟 인용 메커니즘으로 사용될 수 있습니다. 인용 문자열의 값을 처리하는 수신자는 마치 백슬래시 뒤의 옥텟으로 대체된 것처럼 인용 쌍을 처리해야 합니다.

```text
     quoted-pair    = "\" ( HTAB / SP / VCHAR / obs-text )
```

발신자는 해당 문자열 내에서 발생하는 DQUOTE 및 백슬래시 옥텟을 인용하는 데 필요한 경우를 제외하고는 인용 문자열에서 인용 쌍을 생성해서는 안 됩니다. 발신자는 괄호\["\(" 및 "\)"\]와 해당 주석 내에서 발생하는 백슬래시 옥텟을 인용하는 데 필요한 경우를 제외하고 주석에서 인용 쌍을 생성해서는 안 됩니다.

---
#### **5.6.5.  Comments**

주석 텍스트를 괄호로 묶어 일부 HTTP 필드에 주석을 포함할 수 있습니다. 설명은 필드 값 정의의 일부로 "설명"을 포함하는 필드에서만 허용됩니다.

```text
     comment        = "(" *( ctext / quoted-pair / comment ) ")"
     ctext          = HTAB / SP / %x21-27 / %x2A-5B / %x5D-7E / obs-text
```

---
#### **5.6.6.  Parameters**

매개변수는 이름/값 쌍의 인스턴스입니다. 항목에 보조 정보를 추가하기 위한 일반적인 구문으로 필드 값에 자주 사용됩니다. 각 매개변수는 일반적으로 바로 앞에 오는 세미콜론으로 구분됩니다.

```text
     parameters      = *( OWS ";" OWS [ parameter ] )
     parameter       = parameter-name "=" parameter-value
     parameter-name  = token
     parameter-value = ( token / quoted-string )
```

매개변수 이름은 대소문자를 구분합니다. 매개변수 값은 매개변수 이름의 의미에 따라 대소문자를 구분할 수도 있고 그렇지 않을 수도 있습니다. 매개 변수 및 일부 동등한 형식의 예는 미디어 유형\(섹션 8.3.1\) 및 Accept 헤더 필드\(섹션 12.5.1\)에서 볼 수 있습니다.

토큰 생성과 일치하는 매개변수 값은 토큰으로 또는 인용 문자열 내에서 전송될 수 있습니다. 인용된 값과 인용되지 않은 값은 동일합니다.

- | \*참고:\* 매개변수는 "=" 문자 주위에 공백\("bad" | 공백도 포함\)을 허용하지 않습니다.

---
#### **5.6.7.  Date/Time Formats**

1995년 이전에는 서버에서 타임스탬프를 전달하기 위해 일반적으로 사용되는 세 가지 형식이 있었습니다. 이전 구현과의 호환성을 위해 세 가지 모두 여기에 정의되어 있습니다. 선호되는 형식은 인터넷 메시지 형식\[RFC5322\]에서 사용되는 날짜 및 시간 사양의 고정 길이 및 단일 영역 하위 집합입니다.

```text
     HTTP-date    = IMF-fixdate / obs-date
```

선호되는 형식의 예는 다음과 같습니다.

```text
     Sun, 06 Nov 1994 08:49:37 GMT    ; IMF-fixdate
```

더 이상 사용되지 않는 두 가지 형식의 예는 다음과 같습니다.

```text
     Sunday, 06-Nov-94 08:49:37 GMT   ; obsolete RFC 850 format
     Sun Nov  6 08:49:37 1994         ; ANSI C's asctime() format
```

HTTP 필드의 타임스탬프 값을 구문 분석하는 수신자는 세 가지 HTTP 날짜 형식을 모두 수락해야 합니다. 발신자가 HTTP 날짜로 정의된 하나 이상의 타임스탬프를 포함하는 필드를 생성하는 경우 발신자는 해당 타임스탬프를 IMF-fixdate 형식으로 생성해야 합니다.

HTTP-date 값은 UTC\(협정 세계시\)의 인스턴스로 시간을 나타냅니다. 처음 두 형식은 UTC 이름의 전신인 그리니치 표준시의 세 글자 약어인 "GMT"로 UTC를 나타냅니다. asctime 형식의 값은 UTC로 간주됩니다.

"시계"는 UTC 기준으로 현재 순간에 대한 합리적인 근사치를 제공할 수 있는 구현입니다. 시계 구현은 UTC와 동기화하기 위해 NTP\(\[RFC5905\]\) 또는 유사한 프로토콜을 사용해야 합니다.

```text
   Preferred format:

     IMF-fixdate  = day-name "," SP date1 SP time-of-day SP GMT
     ; fixed length/zone/capitalization subset of the format
     ; see Section 3.3 of [RFC5322]

     day-name     = %s"Mon" / %s"Tue" / %s"Wed"
                  / %s"Thu" / %s"Fri" / %s"Sat" / %s"Sun"

     date1        = day SP month SP year
                  ; e.g., 02 Jun 1982

     day          = 2DIGIT
     month        = %s"Jan" / %s"Feb" / %s"Mar" / %s"Apr"
                  / %s"May" / %s"Jun" / %s"Jul" / %s"Aug"
                  / %s"Sep" / %s"Oct" / %s"Nov" / %s"Dec"
     year         = 4DIGIT

     GMT          = %s"GMT"

     time-of-day  = hour ":" minute ":" second
                  ; 00:00:00 - 23:59:60 (leap second)

     hour         = 2DIGIT
     minute       = 2DIGIT
     second       = 2DIGIT

   Obsolete formats:

     obs-date     = rfc850-date / asctime-date

     rfc850-date  = day-name-l "," SP date2 SP time-of-day SP GMT
     date2        = day "-" month "-" 2DIGIT
                  ; e.g., 02-Jun-82

     day-name-l   = %s"Monday" / %s"Tuesday" / %s"Wednesday"
                  / %s"Thursday" / %s"Friday" / %s"Saturday"
                  / %s"Sunday"

     asctime-date = day-name SP date3 SP time-o발신자는 문법에 SP로 특별히 포함된 것 이상으로 HTTP 날짜에 추가 공백을 생성해서는 안 됩니다. 일 이름, 일, 월, 연도 및 시간의 의미는 해당 이름\(\[RFC5322\], 섹션 3.3\)을 사용하여 인터넷 메시지 형식 구성에 대해 정의된 것과 동일합니다.

두 자리 연도를 사용하는 rfc850-date 형식의 타임스탬프 값 수신자는 미래 50년 이상으로 보이는 타임스탬프를 마지막 두 자리가 동일한 과거의 가장 최근 연도를 나타내는 것으로 해석해야 합니다. .

타임스탬프 값의 수신자는 필드 정의에 의해 달리 제한되지 않는 한 타임스탬프 구문 분석에 강력하도록 권장됩니다. 예를 들어 메시지는 인터넷 메시지 형식에 정의된 날짜 및 시간 사양을 생성할 수 있는 비 HTTP 소스에서 HTTP를 통해 때때로 전달됩니다.

- | \*참고:\* 타임스탬프 형식에 대한 HTTP 요구 사항은 | 프로토콜 스트림 내에서의 사용. 구현은 | 사용자 프리젠테이션을 위해 이러한 형식을 사용할 필요는 없습니다. | 요청 로깅 등

---
## **6.  Message Abstraction**

HTTP의 각 주요 버전은 메시지 통신을 위한 고유한 구문을 정의합니다. 이 섹션에서는 메시지 특성의 일반화, 공통 구조 및 의미 전달 능력을 기반으로 HTTP 메시지에 대한 추상 데이터 유형을 정의합니다. 이 추상화는 HTTP 버전과 독립적인 발신자와 수신자에 대한 요구 사항을 정의하는 데 사용됩니다. 예를 들어 한 버전의 메시지는 의미를 변경하지 않고 다른 버전을 통해 전달될 수 있습니다.

"메시지"는 다음으로 구성됩니다.

\* 메시지를 설명하고 라우팅하기 위한 제어 데이터

\* 해당 제어 데이터를 확장하고 보낸 사람, 메시지, 콘텐츠 또는 컨텍스트에 대한 추가 정보를 전달하기 위한 이름/값 쌍의 헤더 조회 테이블,

\* 잠재적으로 무한한 콘텐츠 스트림, 그리고

\* 콘텐츠를 전송하는 동안 얻은 정보를 전달하기 위한 이름/값 쌍의 예고편 조회 테이블입니다.

프레이밍 및 제어 데이터가 먼저 전송된 다음 헤더 테이블의 필드가 포함된 헤더 섹션이 전송됩니다. 메시지에 콘텐츠가 포함된 경우 콘텐츠는 헤더 섹션 뒤에 전송되며, 잠재적으로 트레일러 테이블에 대한 필드를 포함할 수 있는 트레일러 섹션이 뒤따릅니다.

메시지는 스트림으로 처리될 것으로 예상되며, 스트림의 목적과 지속적인 처리는 읽는 동안 드러납니다. 따라서 제어 데이터는 수신자가 즉시 알아야 할 사항을 설명하고, 헤더 필드는 콘텐츠를 수신하기 전에 알아야 할 사항을 설명하며, 콘텐츠\(존재하는 경우\)에는 수신자가 메시지 의미를 충족하기 위해 원하거나 필요로 하는 내용이 포함될 수 있으며, 트레일러 필드는 선택 사항을 제공합니다. 콘텐츠를 전송하기 전에는 알려지지 않은 메타데이터.

메시지는 "자기 설명적"으로 만들어졌습니다. 수신자가 메시지에 대해 알아야 하는 모든 것은 메시지 자체를 살펴보고 메시지 자체를 살펴보면 메시지에 대한 이해 없이도 전송 중에 압축되거나 생략된 부분을 디코딩하거나 재구성하여 결정할 수 있습니다. 발신자의 현재 애플리케이션 상태\(이전 메시지를 통해 설정됨\) 그러나 클라이언트는 해당 응답을 구문 분석, 해석 또는 캐싱할 ​​때 요청에 대한 지식을 유지해야 합니다. 예를 들어 HEAD 메서드에 대한 응답은 GET에 대한 응답의 시작 부분과 비슷해 보이지만 동일한 방식으로 구문 분석할 수는 없습니다.

이 메시지 추상화는 일부 버전에서 찾을 수 없는 기능을 포함하여 여러 버전의 HTTP에 대한 일반화입니다. 예를 들어, 예고편은 HTTP/1.1 청크 전송 코딩 내에서 콘텐츠 뒤의 예고편 섹션으로 도입되었습니다. 각 스트림을 종료하는 헤더 블록 내의 HTTP/2 및 HTTP/3에는 동등한 기능이 있습니다.

---
### **6.1.  Framing and Completeness**

메시지 프레이밍은 각 메시지가 시작되고 끝나는 방식을 나타냅니다. 이를 통해 각 메시지는 동일한 연결에서 다른 메시지나 잡음과 구별될 수 있습니다. HTTP의 각 주요 버전은 자체 프레이밍 메커니즘을 정의합니다.

HTTP/0.9 및 HTTP/1.0의 초기 배포에서는 기본 연결을 닫아 응답을 종료했습니다. 이전 버전과의 호환성을 위해 이 암시적 프레이밍은 HTTP/1.1에서도 허용됩니다. 그러나 연결이 일찍 닫히면 암시적 프레이밍이 불완전한 응답을 구별하지 못할 수 있습니다. 이러한 이유로 거의 모든 최신 구현에서는 길이로 구분된 메시지 데이터 시퀀스 형식의 명시적 프레이밍을 사용합니다.

프레임에 표시된 모든 옥텟을 사용할 수 있는 경우 메시지는 "완료"된 것으로 간주됩니다. 명시적인 프레이밍이 사용되지 않으면 기본 연결이 닫혀 종료되는 응답 메시지는 전송 수준 오류가 완료되지 않았음을 나타내지 않는 한 불완전한 응답과 구별할 수 없더라도 완료된 것으로 간주됩니다.

---
### **6.2.  Control Data**

메시지는 기본 목적을 설명하는 제어 데이터로 시작됩니다. 요청 메시지 제어 데이터에는 요청 방법\(Section 9\), 요청 대상\(Section 7.1\) 및 프로토콜 버전\(Section 2.5\)이 포함됩니다. 응답 메시지 제어 데이터에는 상태 코드\(섹션 15\), 선택적 이유 문구 및 프로토콜 버전이 포함됩니다.

HTTP/1.1\(\[HTTP/1.1\]\) 이하에서는 제어 데이터가 메시지의 첫 번째 줄로 전송됩니다. HTTP/2\(\[HTTP/2\]\) 및 HTTP/3\(\[HTTP/3\]\)에서 제어 데이터는 예약된 이름 접두사\(예: ":authority"\)가 있는 의사 헤더 필드로 전송됩니다.

모든 HTTP 메시지에는 프로토콜 버전이 있습니다. 사용 중인 버전에 따라 메시지 내에서 명시적으로 식별되거나 메시지가 수신되는 연결에 의해 유추될 수 있습니다. 수신자는 해당 버전 정보를 사용하여 해당 발신자와 향후 통신에 대한 제한 사항이나 가능성을 확인합니다.

중개자가 메시지를 전달하면 해당 중개자가 사용하는 버전을 반영하도록 프로토콜 버전이 업데이트됩니다. Via 헤더 필드\(7.6.3절\)는 전달된 메시지 내에서 업스트림 프로토콜 정보를 전달하는 데 사용됩니다.

클라이언트는 클라이언트가 준수하는 가장 높은 버전과 동일한 요청 버전을 전송해야 하며, 해당 버전의 주요 버전은 서버가 지원하는 가장 높은 버전보다 높지 않습니다\(알려진 경우\). 클라이언트는 자신이 준수하지 않는 버전을 보내서는 안 됩니다.

서버가 HTTP 사양을 잘못 구현한 것으로 알려진 경우 클라이언트는 더 낮은 요청 버전을 보낼 수 있지만, 클라이언트가 적어도 하나의 정상적인 요청을 시도하고 응답 상태 코드 또는 헤더 필드\(예: 서버\)에서 결정한 후에만 가능합니다. 서버가 더 높은 요청 버전을 부적절하게 처리합니다.

서버는 요청에서 수신된 버전보다 작거나 같은 주요 버전을 포함하는 서버가 준수하는 가장 높은 버전과 동일한 응답 버전을 보내야 합니다\(SHOULD\). 서버는 자신이 준수하지 않는 버전을 보내서는 안 됩니다. 서버는 어떤 이유로든 클라이언트의 주요 프로토콜 버전 서비스를 거부하려는 경우 505\(HTTP 버전은 지원되지 않음\) 응답을 보낼 수 있습니다.

구현하는 주 버전 번호와 구현하는 것보다 높은 부 버전 번호가 있는 메시지를 수신하는 수신자는 해당 메시지가 수신자가 준수하는 주 버전 내에서 가장 높은 부 버전에 있는 것처럼 메시지를 처리해야 합니다. 수신자는 더 높은 부 버전이 포함된 메시지를 아직 더 높은 버전에 대한 지원을 표시하지 않은 수신자에게 보낼 때 동일한 주요 버전의 구현에서 안전하게 처리할 수 있을 만큼 충분히 이전 버전과 호환된다고 가정할 수 있습니다.

---
### **6.3.  Header Fields**

콘텐츠 이전에 전송되거나 수신되는 필드\(섹션 5\)를 "헤더 필드"\(또는 구어적으로 "헤더"\)라고 합니다.

메시지의 "헤더 섹션"은 일련의 헤더 필드 줄로 구성됩니다. 각 헤더 필드는 메시지 의미 체계를 수정 또는 확장하고, 보낸 사람을 설명하고, 콘텐츠를 정의하거나, 추가 컨텍스트를 제공할 수 있습니다.

- | \*참고:\* 명명된 필드를 헤더 | 부분.

---
### **6.4.  Content**

HTTP 메시지는 종종 전체 또는 부분 표현을 메시지 "콘텐츠"로 전송합니다. 즉, 메시지 프레임에 설명된 대로 헤더 섹션 다음에 전송된 옥텟 스트림입니다.

콘텐츠에 대한 이 추상적 정의는 메시지 프레이밍에서 추출된 데이터를 반영합니다. 예를 들어, HTTP/1.1 메시지 본문\(\[HTTP/1.1\]의 섹션 6\)은 청크 전송 코딩으로 인코딩된 데이터 스트림\(데이터 청크 시퀀스, 길이가 0인 청크 1개, 트레일러 섹션\)으로 구성될 수 있습니다. - 동일한 메시지의 내용에는 전송 코딩이 디코딩된 후의 데이터 스트림만 포함됩니다. 여기에는 청크 길이, 청크 프레이밍 구문, 트레일러 필드\(6.5절\)가 포함되지 않습니다.

- | \*참고:\* 일부 필드 이름에는 "Content-" 접두사가 있습니다. 이것은 | 비공식 컨벤션; 이 필드 중 일부는 | 위에 정의된 대로 메시지 내용의 범위는 | 선택한 표현\(섹션 3.2\) 개인 보기 | 필드의 정의를 명확하게 합니다.

---
#### **6.4.1.  Content Semantics**

요청 콘텐츠의 목적은 메서드 의미론\(섹션 9\)에 의해 정의됩니다.

예를 들어, PUT 요청\(섹션 9.3.4\) 내용의 표현은 요청이 성공적으로 적용된 후 대상 리소스의 원하는 상태를 나타내는 반면, POST 요청\(섹션 9.3.3\) 내용의 표현은 다음을 나타냅니다. 대상 리소스가 처리할 정보입니다.

응답에서 콘텐츠의 목적은 요청 메서드, 응답 상태 코드\(섹션 15\) 및 해당 콘텐츠를 설명하는 응답 필드에 의해 정의됩니다. 예를 들어, GET\(섹션 9.3.1\)에 대한 200\(OK\) 응답의 내용은 메시지 발생 날짜\(섹션 6.6.1\) 당시 관찰된 대상 리소스의 현재 상태를 나타내는 반면, POST에 대한 응답의 동일한 상태 코드는 처리 결과 또는 처리를 적용한 후 대상 리소스의 새로운 상태를 나타낼 수 있습니다.

GET에 대한 206\(부분 콘텐츠\) 응답의 콘텐츠에는 섹션 15.3.7에 설명된 대로 선택한 표현의 단일 부분 또는 해당 표현의 여러 부분을 포함하는 다중 부분 메시지 본문이 포함됩니다.

오류 상태 코드가 포함된 응답 메시지에는 일반적으로 오류 상태를 나타내는 콘텐츠가 포함되어 있습니다. 콘텐츠에는 오류 상태와 이를 해결하기 위해 제안되는 단계가 설명되어 있습니다.

HEAD 요청 메서드\(섹션 9.3.2\)에 대한 응답에는 콘텐츠가 포함되지 않습니다. 연관된 응답 헤더 필드는 요청 메소드가 GET\(9.3.1절\)인 경우 해당 값이 무엇인지만 나타냅니다.

CONNECT 요청 메서드\(9.3.6절\)에 대한 2xx\(성공\) 응답은 콘텐츠를 갖는 대신 연결을 터널 모드로 전환합니다.

모든 1xx\(정보\), 204\(콘텐츠 없음\) 및 304\(수정되지 않음\) 응답에는 콘텐츠가 포함되지 않습니다.

다른 모든 응답에는 콘텐츠가 포함되어 있지만 해당 콘텐츠의 길이는 0일 수 있습니다.

---
#### **6.4.2.  Identifying Content**

전체 또는 부분 표현이 메시지 콘텐츠로 전송될 때 송신자가 해당 특정 표현에 해당하는 리소스에 대한 식별자를 제공하거나 수신자가 결정하는 것이 종종 바람직합니다. 예를 들어, "현재 일기 예보"에 대한 리소스에 대해 GET 요청을 하는 클라이언트는 반환된 콘텐츠에 특정한 식별자를 원할 수 있습니다\(예: "20210720T1711의 Laguna Beach에 대한 일기 예보"\). 이는 시간이 지남에 따라 표현이 변경될 것으로 예상되는 리소스의 콘텐츠를 공유하거나 북마크하는 데 유용할 수 있습니다.

요청 메시지의 경우:

\* 요청에 Content-Location 헤더 필드가 있는 경우 보낸 사람은 해당 콘텐츠가 Content-Location 필드 값으로 식별되는 리소스의 표현임을 주장합니다. 그러나 그러한 주장은 다른 수단\(이 사양에서 정의되지 않음\)으로 확인할 수 없으면 신뢰할 수 없습니다. 이 정보는 개정 내역 링크에 여전히 유용할 수 있습니다.

\* 그렇지 않으면 콘텐츠가 HTTP에 의해 식별되지 않지만 콘텐츠 자체 내에서 더 구체적인 식별자가 제공될 수 있습니다.

응답 메시지의 경우 일치하는 항목이 발견될 때까지 다음 규칙이 순서대로 적용됩니다.

1. 요청 메소드가 HEAD이거나 응답 상태 코드가 204\(No Content\) 또는 304\(Not Modified\)인 경우 응답에 내용이 없습니다.

1. 요청 방법이 GET이고 응답 상태 코드가 200\(OK\)인 경우 콘텐츠는 대상 리소스\(Section 7.1\)를 나타냅니다.

1. 요청 방법이 GET이고 응답 상태 코드가 203\(신뢰할 수 없는 정보\)인 경우 콘텐츠는 중개자가 제공한 대상 리소스의 잠재적으로 수정되거나 향상된 표현입니다.

1. 요청 방법이 GET이고 응답 상태 코드가 206\(부분 콘텐츠\)인 경우 콘텐츠는 대상 리소스 표현의 하나 이상의 부분입니다.

1. 응답에 Content-Location 헤더 필드가 있고 해당 필드 값이 대상 URI와 동일한 URI에 대한 참조인 경우 콘텐츠는 대상 리소스의 표현입니다.

1. 응답에 Content-Location 헤더 필드가 있고 해당 필드 값이 대상 URI와 다른 URI에 대한 참조인 경우 보낸 사람은 콘텐츠가 Content-Location 필드 값으로 식별되는 리소스의 표현임을 주장합니다. 그러나 그러한 주장은 다른 수단\(이 사양에서 정의되지 않음\)으로 확인할 수 없으면 신뢰할 수 없습니다.

1. 그렇지 않으면 콘텐츠가 HTTP에 의해 식별되지 않지만 콘텐츠 자체 내에서 더 구체적인 식별자가 제공될 수 있습니다.

---
### **6.5.  Trailer Fields**

"예고편 섹션" 내에 있는 필드\(섹션 5\)를 "예고편 필드"\(또는 구어적으로는 "예고편"\)라고 합니다. 예고편 필드는 메시지 무결성 검사, 디지털 서명, 배달 지표 또는 사후 처리 상태 정보를 제공하는 데 유용할 수 있습니다.

헤더 섹션이 완료될 때 알려진 메시지 의미 체계와 모순되는 것을 방지하려면 트레일러 필드를 헤더 섹션의 필드와 별도로 처리하고 저장해야 합니다. 특정 헤더 필드의 존재 여부는 트레일러가 수신되기 전에 메시지 전체의 라우팅 또는 처리에 대한 선택에 영향을 미칠 수 있습니다. 이러한 선택은 나트레일러 섹션은 사용 중인 HTTP 버전에서 지원되고 명시적인 프레이밍 메커니즘에 의해 활성화된 경우에만 가능합니다. 예를 들어, HTTP/1.1의 청크 전송 코딩을 사용하면 콘텐츠 뒤에 트레일러 섹션이 전송될 수 있습니다\(\[HTTP/1.1\]의 섹션 7.1.2\).

메시지 프레이밍, 라우팅, 인증, 요청 수정자, 응답 제어 또는 콘텐츠 형식을 설명하는 필드와 같이 콘텐츠를 수신하기 전에 평가가 필요하기 때문에 헤더 섹션 외부에서 많은 필드를 처리할 수 없습니다. 발신자는 해당 헤더 필드 이름의 정의가 해당 필드가 트레일러로 전송되도록 허용하지 않는 한 트레일러 필드를 생성해서는 안 됩니다.

트레일러 필드는 한 프로토콜 버전에서 다른 프로토콜 버전으로 메시지를 전달하는 중개자가 처리하기 어려울 수 있습니다. 전체 메시지를 전송 중에 버퍼링할 수 있는 경우 일부 중개자는 메시지가 전달되기 전에 트레일러 필드를 헤더 섹션\(해당하는 경우\)에 병합할 수 있습니다. 그러나 대부분의 경우 트레일러는 단순히 폐기됩니다. 수신자가 해당 헤더 필드 정의를 이해하고 해당 정의가 트레일러 필드 값을 안전하게 병합할 수 있는 방법을 명시적으로 허용하고 정의하지 않는 한, 수신자는 트레일러 필드를 헤더 섹션에 병합해서는 안 됩니다.

요청의 TE 헤더 필드\(10.1.4절\)에 키워드 "트레일러"가 있다는 것은 클라이언트가 자신과 모든 다운스트림 클라이언트를 대신하여 트레일러 필드를 기꺼이 수락한다는 것을 나타냅니다. 중개자로부터의 요청의 경우 이는 모든 다운스트림 클라이언트가 전달된 응답의 트레일러 필드를 기꺼이 받아들인다는 것을 의미합니다. "트레일러"가 있다고 해서 클라이언트가 응답의 특정 트레일러 필드를 처리한다는 의미는 아닙니다. 단, 어떤 클라이언트도 예고편 섹션을 삭제하지 않을 것입니다.

전송 중에 트레일러 필드가 삭제될 가능성이 있기 때문에 서버는 사용자 에이전트가 수신하는 데 필요하다고 생각되는 트레일러 필드를 생성해서는 안 됩니다.

---
#### **6.5.2.  Processing Trailer Fields**

"트레일러" 헤더 필드\(6.6.2절\)는 트레일러 섹션에서 전송될 가능성이 있는 필드를 나타내기 위해 전송될 수 있으며, 이를 통해 수신자는 콘텐츠를 처리하기 전에 수신을 준비할 수 있습니다. 예를 들어, 필드 이름이 콘텐츠가 수신될 때 동적 체크섬을 계산한 다음 트레일러 필드 값을 수신하는 즉시 확인해야 함을 나타내는 경우 유용할 수 있습니다.

헤더 필드와 마찬가지로 이름이 같은 트레일러 필드는 수신된 순서대로 처리됩니다. 동일한 이름을 가진 여러 개의 트레일러 필드 줄은 여러 값을 멤버 목록으로 추가하는 것과 동일한 의미를 갖습니다. 메시지 중에 두 번 이상 생성될 수 있는 트레일러 필드는 각 멤버 값이 수신된 필드 라인당 한 번만 처리되더라도 목록 기반 필드로 정의되어야 합니다.

메시지 끝에서 수신자는 수신된 트레일러 필드 세트를 헤더 필드와 유사하지만 별개인 이름/값 쌍의 데이터 구조로 처리할 수 있습니다. 예고편에 사용하기 위한 필드에 대한 필드 사양 내에서 추가 처리 기대치가 정의될 ​​수 있습니다.

---
### **6.6.  Message Metadata**

메시지가 생성된 시기와 방법 등 메시지 자체를 설명하는 필드는 요청과 응답 모두에 나타날 수 있습니다.

---
#### **6.6.1.  Date**

"Date" 헤더 필드는 메시지가 시작된 날짜와 시간을 나타내며 \[RFC5322\] 섹션 3.6.1에 정의된 Origination Date Field\(orig-date\)와 동일한 의미를 갖습니다. 필드 값은 섹션 5.6.7에 정의된 대로 HTTP 날짜입니다.

```text
     Date = HTTP-date
```

예는 다음과 같습니다

```text
   Date: Tue, 15 Nov 1994 08:12:31 GMT
```

Date 헤더 필드를 생성하는 발신자는 메시지 생성 날짜 및 시간에 대해 사용 가능한 최상의 근사치로 필드 값을 생성해야 합니다. 이론적으로 날짜는 메시지 콘텐츠를 생성하기 직전의 순간을 나타내야 합니다. 실제로 보낸 사람은 메시지가 생성되는 동안 언제든지 날짜 값을 생성할 수 있습니다.

시계\(섹션 5.6.7에 정의됨\)가 있는 원서버는 모든 2xx\(성공\), 3xx\(리디렉션\) 및 4xx\(클라이언트 오류\) 응답에서 Date 헤더 필드를 생성해야 하며, 1xx에서 Date 헤더 필드를 생성할 수 있습니다. \(정보 제공\) 및 5xx\(서버 오류\) 응답.

시계가 없는 원서버는 Date 헤더 필드를 생성해서는 안 됩니다.

Date 헤더 필드 없이 응답 메시지를 수신하는 시계를 가진 수신자는 수신된 시간을 기록해야 하며, 해당 Date 헤더 필드가 캐시되거나 다운스트림으로 전달되는 경우 해당 Date 헤더 필드를 메시지 헤더 섹션에 추가해야 합니다.

유효하지 않은 Date 헤더 필드 값이 포함된 응답을 수신한 시계를 가진 수신자는 해당 값을 응답이 수신된 시간으로 대체할 수 있습니다.

사용자 에이전트는 요청에 Date 헤더 필드를 보낼 수 있지만 일반적으로 서버에 유용한 정보를 전달한다고 생각되지 않는 한 그렇게 하지 않습니다. 예를 들어, 서버가 사용자 에이전트와 서버 시계 간의 차이를 기반으로 사용자 요청 해석을 조정할 것으로 예상되는 경우 HTTP의 사용자 정의 애플리케이션은 날짜를 전달할 수 있습니다.

---
#### **6.6.2.  Trailer**

"Trailer" 헤더 필드는 보낸 사람이 해당 메시지 내에서 트레일러 필드로 보낼 것으로 예상하는 필드 이름 목록을 제공합니다. 이를 통해 수신자는 콘텐츠 처리를 시작하기 전에 표시된 메타데이터 수신을 준비할 수 있습니다.

```text
     Trailer = #field-name
```

예를 들어 발신자는 콘텐츠가 스트리밍되는 동안 서명이 계산된다는 점을 표시하고 최종 서명을 트레일러 필드로 제공할 수 있습니다. 이를 통해 수신자는 콘텐츠를 수신하면서 즉시 동일한 검사를 수행할 수 있습니다.

메시지에서 하나 이상의 트레일러 필드를 생성하려는 발신자는 해당 메시지의 헤더 섹션에 트레일러 헤더 필드를 생성하여 트레일러에 존재할 수 있는 필드를 나타내야 합니다.

중개자가 전송 중에 트레일러 섹션을 삭제하는 경우 Trailer 필드는 손실된 메타데이터에 대한 힌트를 제공할 수 있지만 Trailer의 발신자가 항상 명명된 필드를 전송하여 이를 따라갈 것이라는 보장은 없습니다.

---
## **7.  Routing HTTP Messages**

HTTP 요청 메시지 라우팅은 대상 리소스, 클라이언트의 프록시 구성, 인바운드 연결 설정 또는 재사용을 기반으로 각 클라이언트에 의해 결정됩니다. 해당 응답 라우팅은 동일한 연결 체인을 따라 클라이언트로 돌아갑니다.

---
### **7.1.  Determining the Target Resource**

HTTP는 다양한 애플리케이션에서 사용되지만 대부분의 클라이언트는 범용 웹 브라우저와 동일한 리소스 식별 메커니즘 및 구성 기술을 사용합니다. 통신 옵션이 클라이언트 구성에 하드 코딩되어 있는 경우에도 이들의 결합된 효과를 URI 참조\(섹션 4.1\)로 생각할 수 있습니다.

"대상 URI"를 얻기 위해 URI 참조는 절대 형식으로 확인됩니다. 조각 식별자는 클라이언트 측 처리를 위해 예약되어 있으므로 대상 URI는 참조의 조각 구성 요소를 제외합니다\(\[URI\], 섹션 3.5\).

"대상 리소스"에 대한 작업을 수행하기 위해 클라이언트는 수신자가 동일한 리소스를 식별할 수 있도록 구문 분석된 대상 URI의 충분한 구성 요소가 포함된 요청 메시지를 보냅니다. 역사적인 이유로 "요청 대상"이라고 집합적으로 참조되는 구문 분석된 대상 URI 구성 요소는 메시지 제어 데이터 및 Host 헤더 필드\(섹션 7.2\) 내에서 전송됩니다.

요청 대상 구성 요소가 메서드별 형식으로 되어 있는 두 가지 특이한 경우가 있습니다.

\* CONNECT\(9.3.6절\)의 경우 요청 대상은 콜론으로 구분된 터널 대상의 호스트 이름과 포트 번호입니다.

\* OPTIONS\(9.3.7절\)의 경우 요청 대상은 단일 별표\("\*"\)일 수 있습니다.

자세한 내용은 해당 메서드 정의를 참조하세요. 이러한 양식은 다른 방법과 함께 사용하면 안 됩니다.

클라이언트의 요청을 받으면 서버는 로컬 구성 및 들어오는 연결 컨텍스트에 따라 수신된 구성 요소로부터 대상 URI를 재구성합니다. 이 재구성은 각 주요 프로토콜 버전에 따라 다릅니다. 예를 들어, \[HTTP/1.1\]의 섹션 3.3은 서버가 HTTP/1.1 요청의 대상 URI를 결정하는 방법을 정의합니다.

- | \*참고:\* 이전 사양은 재구성된 대상을 정의했습니다 | URI는 별개의 개념으로 "유효 요청 URI"입니다.

---
### **7.2.  Host and :authority**

요청의 "Host" 헤더 필드는 대상 URI의 호스트 및 포트 정보를 제공하므로 원본 서버가 여러 호스트 이름에 대한 요청을 처리하는 동안 리소스를 구별할 수 있습니다.

HTTP/2\[HTTP/2\] 및 HTTP/3\[HTTP/3\]에서 Host 헤더 필드는 경우에 따라 요청 제어 데이터의 ":authority" 의사 헤더 필드로 대체됩니다.

```text
     Host = uri-host [ ":" port ] ; Section 4
```

대상 URI의 권한 정보는 요청을 처리하는 데 중요합니다. 사용자 에이전트는 해당 정보를 ":authority" 의사 헤더 필드로 전송하지 않는 한 요청에서 Host 헤더 필드를 생성해야 합니다. 호스트를 보내는 사용자 에이전트는 이를 요청 헤더 섹션의 첫 번째 필드로 보내야 합니다.

예를 들어 <http://www.example.org/pub/WWW/\>에 대한 원본 서버에 대한 GET 요청은 다음으로 시작됩니다.

```text
   GET /pub/WWW/ HTTP/1.1
   Host: www.example.org
```

호스트 및 포트 정보는 애플리케이션 수준 라우팅 메커니즘으로 작동하므로 공유 캐시를 손상시키거나 요청을 의도하지 않은 서버로 리디렉션하려는 악성 프로그램의 빈번한 대상이 됩니다. 차단 프록시는 차단된 연결이 해당 호스트의 유효한 IP 주소를 대상으로 하는지 먼저 확인하지 않고 내부 서버로 요청을 리디렉션하거나 공유 캐시에서 캐시 키로 사용하기 위해 호스트 및 포트 정보에 의존하는 경우 특히 취약합니다. .

---
### **7.3.  Routing Inbound Requests**

대상 URI와 해당 출처가 결정되면 클라이언트는 원하는 의미를 달성하기 위해 네트워크 요청이 필요한지 여부와 필요한 경우 해당 요청을 어디로 보낼지 결정합니다.

---
#### **7.3.1.  To a Cache**

클라이언트에 \[CACHING\] 캐시가 있고 요청이 이를 충족할 수 있는 경우 일반적으로 요청이 먼저 해당 캐시로 전달됩니다.

---
#### **7.3.2.  To a Proxy**

요청이 캐시에 의해 충족되지 않으면 일반 클라이언트는 해당 구성을 확인하여 요청을 충족하기 위해 프록시를 사용할지 여부를 결정합니다. 프록시 구성은 구현에 따라 다르지만 종종 URI 접두사 일치, 선택적 권한 일치 또는 둘 다를 기반으로 하며 프록시 자체는 일반적으로 "http" 또는 "https" URI로 식별됩니다.

"http" 또는 "https" 프록시가 적용 가능한 경우 클라이언트는 해당 프록시에 대한 연결을 설정\(또는 재사용\)한 다음 클라이언트의 대상 URI와 일치하는 요청 대상이 포함된 HTTP 요청 메시지를 보내 인바운드에 연결합니다.

---
#### **7.3.3.  To the Origin**

적용 가능한 프록시가 없으면 일반적인 클라이언트는 식별된 리소스에 대한 액세스 권한을 얻기 위해 핸들러 루틴\(대상 URI의 체계에 특정한\)을 호출합니다. 이를 수행하는 방법은 대상 URI 체계에 따라 달라지며 관련 사양에 의해 정의됩니다.

섹션 4.3.2에서는 식별된 원본 서버에 대한 인바운드 연결을 설정\(또는 재사용\)한 다음 클라이언트의 대상 URI와 일치하는 요청 대상이 포함된 HTTP 요청 메시지를 전송하여 "http" 리소스에 대한 액세스를 얻는 방법을 정의합니다.

4.3.3절에서는 식별된 원본에 대해 권한이 있는 원본 서버에 대한 인바운드 보안 연결을 설정\(또는 재사용\)한 다음 일치하는 요청 대상이 포함된 HTTP 요청 메시지를 보내어 "https" 리소스에 대한 액세스를 얻는 방법을 정의합니다. 클라이언트의 대상 URI.

---
### **7.4.  Rejecting Misdirected Requests**

서버가 요청을 수신하고 대상 URI를 결정할 만큼 충분히 구문 분석하면 서버는 요청 자체를 처리할지, 요청을 다른 서버로 전달할지, 클라이언트를 다른 리소스로 리디렉션할지, 오류로 응답할지, 아니면 삭제할지 결정합니다. 연결. 이 결정은 요청 또는 연결 컨텍스트에 대한 모든 요소의 영향을 받을 수 있지만 특히 서버가 해당 대상 URI에 대한 요청을 처리하도록 구성되었는지 여부와 연결 컨텍스트가 해당 요청에 적합한지 여부에 따라 결정됩니다.

예를 들어 요청이 의도적으로 또는 실수로 잘못 전달되어 수신된 Host 헤더 필드 내의 정보가 연결의 호스트 또는 포트와 다를 수 있습니다. 신뢰할 수 있는 게이트웨이에서 연결하는 경우 이러한 불일치가 예상될 수 있습니다. 그렇지 않으면 보안 필터를 우회하거나 서버를 속여 비공개 콘텐츠를 전달하거나 캐시를 손상시키려는 시도를 나타낼 수 있습니다. 메시지 라우팅에 관한 보안 고려 사항은 섹션 17을 참조하세요.

연결이 신뢰할 수 있는 게이트웨이에서 나온 것이 아닌 이상, 대상 URI에 대한 체계별 요구 사항이 충족되지 않으면 원서버는 요청을 거부해야 합니다. 특히, "https" 리소스에 대한 요청은 섹션 4.2.2에 정의된 대로 해당 대상 URI의 출처에 유효한 인증서를 통해 보안된 연결을 통해 수신되지 않은 한 반드시 거부되어야 합니다.

응답의 421\(잘못된 요청\) 상태 코드는 요청이 잘못 전달된 것으로 보이기 때문에 원서버가 요청을 거부했음을 나타냅니다\(15.5.20절\).

---
### **7.5.  Response Correlation**

여러 요청/응답 교환에 연결이 사용될 수 있습니다. 요청 메시지와 응답 메시지 간의 상관관계를 지정하는 데 사용되는 메커니즘은 버전에 따라 다릅니다. 일부 HTTP 버전은 메시지의 암시적 순서를 사용하는 반면 다른 버전은 명시적 식별자를 사용합니다.

상태 코드\(임시 응답 포함\)에 관계없이 모든 응답은 요청이 아직 완료되지 않은 경우에도 요청을 받은 후 언제든지 보낼 수 있습니다. 해당 요청이 완료되기 전에 응답이 완료될 수 있습니다\(6.1절\). 마찬가지로 클라이언트는 응답을 위해 특정 시간 동안 기다리지 않아도 됩니다. 합리적인 기간 내에 응답이 수신되지 않으면 클라이언트\(중개자 포함\)가 요청을 포기할 수 있습니다.

연관된 요청을 보내는 동안 응답을 수신하는 클라이언트는 명시적인 반대 표시를 수신하지 않는 한 해당 요청을 계속 보내야 합니다\(예: \[HTTP/1.1\]의 섹션 9.5 및 \[HTTP/2\]의 섹션 6.4 참조\). \).

---
### **7.6.  Message Forwarding**

섹션 3.7에 설명된 대로 중개자는 HTTP 요청 및 응답 처리에서 다양한 역할을 수행할 수 있습니다. 일부 중개자는 성능이나 가용성을 향상시키는 데 사용됩니다. 다른 것들은 액세스 제어나 콘텐츠 필터링에 사용됩니다. HTTP 스트림은 파이프 및 필터 아키텍처와 유사한 특성을 가지므로 중개자가 스트림의 어느 방향이든 향상\(또는 간섭\)할 수 있는 정도에는 본질적인 제한이 없습니다.

중개자는 프로토콜 요소가 인식되지 않는 경우에도\(예: 새로운 방법, 상태 코드 또는 필드 이름\) 메시지를 전달할 것으로 예상됩니다. 이는 다운스트림 수신자를 위한 확장성을 유지하기 때문입니다.

터널 역할을 하지 않는 중개자는 섹션 7.6.1에 지정된 대로 연결 헤더 필드를 구현해야 하며, 들어오는 연결에만 사용되는 필드를 전달에서 제외해야 합니다.

중개자는 무한 요청 루프로부터 보호되지 않는 한 메시지를 자신에게 전달해서는 안 됩니다. 일반적으로 중개자는 별칭, 로컬 변형 또는 문자 그대로의 IP 주소를 포함하여 자체 서버 이름을 인식하고 그러한 요청에 직접 응답해야 합니다.

HTTP 메시지는 증분 처리 또는 다운스트림 전달을 위해 스트림으로 구문 분석될 수 있습니다. 그러나 일부 구현에서는 네트워크 효율성, 보안 검사 또는 콘텐츠 변환을 위해 메시지 전달을 버퍼링하거나 지연시키기 때문에 발신자와 수신자는 부분 메시지의 증분 전달에 의존할 수 없습니다.

---
#### **7.6.1.  Connection**

"Connection" 헤더 필드를 통해 발신자는 현재 연결에 대해 원하는 제어 옵션을 나열할 수 있습니다.

```text
     Connection        = #connection-option
     connection-option = token
```

연결 옵션은 대소문자를 구분하지 않습니다.

Connection 이외의 필드가 현재 연결에 대한 제어 정보를 제공하는 데 사용되는 경우 송신자는 Connection 헤더 필드 내에 해당 필드 이름을 나열해야 합니다. 일부 HTTP 버전에서는 해당 정보에 대한 필드 사용을 금지하므로 연결 필드를 허용하지 않습니다.

중개자는 메시지가 전달되기 전에 수신된 연결 헤더 필드를 구문 분석해야 하며, 이 필드의 각 연결 옵션에 대해 연결 옵션과 동일한 이름을 가진 메시지에서 헤더 또는 트레일러 필드를 제거한 다음 연결 헤더 필드 자체\(또는 전달된 메시지에 대한 중개자의 자체 제어 옵션으로 대체\)

따라서 연결 헤더 필드는 체인의 모든 수신자를 대상으로 하는 필드\("end-to-end"\)와 직접 수신자만을 대상으로 하는 필드\("hop-by-hop"\)를 구별하는 선언적 방법을 제공합니다. \), 메시지가 자기 설명적일 수 있도록 하고 향후 연결별 확장이 이전 중개자에 의해 맹목적으로 전달될 것이라는 두려움 없이 배포될 수 있도록 합니다.

또한 중개자는 해당 필드의 의미를 적용한 후 연결 옵션으로 표시되는지 여부에 관계없이 전달하기 전에 제거가 필요한 것으로 알려진 필드를 제거하거나 교체해야 합니다. 여기에는 다음이 포함되지만 이에 국한되지는 않습니다.

\* 프록시 연결\(\[HTTP/1.1\]의 부록 C.2.2\)

\* 연결 유지\(\[RFC2068\]의 섹션 19.7.1\)

```text
   *  TE (Section 10.1.4)
```

\* 전송 인코딩\(\[HTTP/1.1\]의 섹션 6.1\)

```text
   *  Upgrade (Section 7.8)
```

발신자는 콘텐츠의 모든 수신자를 대상으로 하는 필드에 해당하는 연결 옵션을 보내서는 안 됩니다. 예를 들어 Cache-Control은 연결 옵션으로 적합하지 않습니다\(\[CACHING\]의 섹션 5.2\).

연결 옵션과 연관된 매개변수가 없으면 연결별 필드가 필요하지 않을 수 있으므로 연결 옵션이 항상 메시지에 있는 필드와 일치하는 것은 아닙니다. 대조적으로, 해당 연결 옵션 없이 수신된 연결별 필드는 일반적으로 해당 필드가 중개자에 의해 부적절하게 전달되었으므로 수신자가 무시해야 함을 나타냅니다.

필드에 해당하지 않는 새로운 연결 옵션을 정의할 때 사양 작성자는 나중에 충돌을 피하기 위해 해당 필드 이름을 예약해야 합니다. 이러한 예약된 필드 이름은 "HTTP\(Hypertext Transfer Protocol\) 필드 이름 레지스트리"\(16.3.1절\)에 등록됩니다.

---
#### **7.6.2.  Max-Forwards**

"Max-Forwards" 헤더 필드는 요청이 프록시에 의해 전달되는 횟수를 제한하기 위해 TRACE\(섹션 9.3.8\) 및 OPTIONS\(섹션 9.3.7\) 요청 메서드가 포함된 메커니즘을 제공합니다. 이는 클라이언트가 체인 중간에서 실패하거나 반복되는 것으로 보이는 요청을 추적하려고 할 때 유용할 수 있습니다.

```text
     Max-Forwards = 1*DIGIT
```

Max-Forwards 값은 이 요청 메시지가 전달될 수 있는 남은 횟수를 나타내는 10진수 정수입니다.

Max-Forwards 헤더 필드가 포함된 TRACE 또는 OPTIONS 요청을 수신하는 각 중개자는 요청을 전달하기 전에 해당 값을 확인하고 업데이트해야 합니다. 수신된 값이 0인 경우 중개자는 요청을 전달해서는 안 됩니다. 대신 중개자는 최종 수신자로 응답해야 합니다. 수신된 Max-Forwards 값이 0보다 큰 경우 중개자는 a\) 1만큼 감소된 수신 값 또는 b\) 다음 중 작은 필드 값을 사용하여 전달된 메시지에서 업데이트된 Max-Forwards 필드를 생성해야 합니다. Max-Forwards에 대한 수신자의 최대 지원 값입니다.

수신자는 다른 요청 방법으로 수신된 Max-Forwards 헤더 필드를 무시할 수 있습니다.

---
#### **7.6.3.  Via**

"Via" 헤더 필드는 이메일의 "Received" 헤더 필드와 유사하게 사용자 에이전트와 서버\(요청 시\) 또는 원본 서버와 클라이언트 사이\(응답 시\) 사이에 중간 프로토콜과 수신자의 존재를 나타냅니다\(섹션 \[RFC5322\]의 3.6.7\). Via는 메시지 전달을 추적하고, 요청 루프를 방지하고, 요청/응답 체인을 따라 보낸 사람의 프로토콜 기능을 식별하는 데 사용할 수 있습니다.

Via = #\( received-protocol RWS received-by \[ RWS 주석 \] \)

```text
     received-protocol = [ protocol-name "/" ] protocol-version
                       ; see Section 7.8
     received-by       = pseudonym [ ":" port ]
     pseudonym         = token
```

Via 필드 값의 각 구성원은 메시지를 전달한 프록시 또는 게이트웨이를 나타냅니다. 각 중개자는 메시지 수신 방법에 대한 자체 정보를 추가하므로 최종 결과는 전달 받는 사람의 순서에 따라 정렬됩니다.

프록시는 전달하는 각 메시지에 아래 설명된 대로 적절한 Via 헤더 필드를 보내야 합니다. HTTP-to-HTTP 게이트웨이는 각 인바운드 요청 메시지에 적절한 Via 헤더 필드를 보내야 하며 전달된 응답 메시지에 Via 헤더 필드를 보낼 수 있습니다.

각 중개자에 대해 received-protocol은 메시지의 업스트림 발신자가 사용하는 프로토콜 및 프로토콜 버전을 나타냅니다. 따라서 Via 필드 값은 요청/응답 체인의 광고된 프로토콜 기능을 기록하여 다운스트림 수신자에게 계속 표시됩니다. 이는 섹션 2.5에 설명된 대로 응답 또는 이후 요청 내에서 사용하기에 안전한 이전 버전과 호환되지 않는 기능을 결정하는 데 유용할 수 있습니다. 간결하게 하기 위해 수신된 프로토콜이 HTTP인 경우 프로토콜 이름은 생략됩니다.

수신자 부분은 일반적으로 이후에 메시지를 전달한 수신자 서버 또는 클라이언트의 호스트 및 선택적 포트 번호입니다. 그러나 실제 호스트가 민감한 정보로 간주되는 경우 발신자는 이를 가명으로 대체할 수 있습니다. 포트가 제공되지 않으면 수신자는 수신 프로토콜에 대한 기본 포트\(있는 경우\)에서 수신되었음을 의미하는 것으로 해석할 수 있습니다.

발신자는 User-Agent 및 Server 헤더 필드와 유사하게 각 수신자의 소프트웨어를 식별하기 위한 주석을 생성할 수 있습니다. 그러나 Via의 댓글은 선택 사항이므로 수신자는 메시지를 전달하기 전에 댓글을 삭제할 수 있습니다.

예를 들어, 요청 메시지는 HTTP/1.0 사용자 에이전트에서 "fred"라는 내부 프록시 코드명으로 전송될 수 있습니다. 이 프록시는 HTTP/1.1을 사용하여 요청을 p.example.net의 공개 프록시로 전달합니다. www.example.com의 원본 서버로 전달하여 요청합니다. www.example.com에서 수신한 요청에는 다음과 같은 Via 헤더 필드가 있습니다.

```text
   Via: 1.0 fred, 1.1 p.example.net
```

네트워크 방화벽을 통해 포털로 사용되는 중개자는 명시적으로 활성화되지 않는 한 방화벽 지역 내 호스트의 이름과 포트를 전달해서는 안 됩니다. 활성화되지 않은 경우 이러한 중개자는 방화벽 뒤의 호스트에서 수신한 각 호스트를 해당 호스트에 대한 적절한 가명으로 대체해야 합니다.

항목이 동일한 수신 프로토콜 값을 갖는 경우 중개자는 Via 헤더 필드 목록 멤버의 순서가 지정된 하위 시퀀스를 단일 멤버로 결합할 수 있습니다. 예를 들어,

```text
   Via: 1.0 ricky, 1.1 ethel, 1.1 fred, 1.0 lucy
```

로 축소될 수 있음

```text
   Via: 1.0 ricky, 1.1 mertz, 1.0 lucy
```

발신자는 여러 목록 구성원이 모두 동일한 조직 통제하에 있고 호스트가 이미 가명으로 대체되지 않은 한 여러 목록 구성원을 결합해서는 안 됩니다. 발신자는 서로 다른 received-protocol 값을 가진 멤버를 결합해서는 안 됩니다.

---
### **7.7.  Message Transformations**

일부 중개자에는 메시지와 내용을 변환하는 기능이 포함되어 있습니다. 예를 들어 프록시는 캐시 공간을 절약하거나 느린 링크의 트래픽 양을 줄이기 위해 이미지 형식을 변환할 수 있습니다. 그러나 이러한 변환이 의료 영상 또는 과학 데이터 분석과 같은 중요한 애플리케이션용 콘텐츠에 적용될 때, 특히 무결성 검사 또는 디지털 서명을 사용하여 수신된 콘텐츠가 원본과 동일한지 확인하는 경우 운영 문제가 발생할 수 있습니다.

의미상 의미 있는 방식으로 메시지를 수정하도록 설계되거나 구성된 경우 HTTP-HTTP 프록시를 "변환 프록시"라고 합니다\(즉, 일반적인 HTTP 처리에 필요한 것 이상의 수정으로 메시지를 변경하는 방식\). 원래 보낸 사람에게 중요하거나 다운스트림 수신자에게 잠재적으로 중요할 수 있음\) 예를 들어 변환 프록시는 공유 주석 서버\(로컬 주석 데이터베이스에 대한 참조를 포함하도록 응답 수정\), 맬웨어 필터, 형식 트랜스코더 또는 개인 정보 보호 필터 역할을 할 수 있습니다. 이러한 변환은 프록시를 선택한 클라이언트\(또는 클라이언트 조직\)가 원하는 것으로 추정됩니다.

프록시가 정규화된 도메인 이름이 아닌 호스트 이름을 가진 대상 URI를 수신하는 경우 요청을 전달할 때 수신한 호스트 이름에 자체 도메인을 추가할 수 있습니다. 대상 URI에 정규화된 도메인 이름이 포함된 경우 프록시는 호스트 이름을 변경해서는 안 됩니다.

프록시는 해당 전달 프로토콜에서 요구하는 경우를 제외하고 수신된 대상 URI를 다음 인바운드 서버로 전달할 때 수신된 대상 URI의 "절대 경로" 및 "쿼리" 부분을 수정해서는 안 됩니다. 예를 들어, HTTP/1.1을 통해 원본 서버로 요청을 전달하는 프록시는 빈 경로를 "/"\(\[HTTP/1.1\]의 섹션 3.2.1\) 또는 "\*"\(\[HTTP/1.1의 섹션 3.2.4\)로 바꿉니다. 1.1\]\), 요청 방법에 따라 다릅니다.

프록시는 변환 불가 캐시 지시문\(\[CACHING\]의 섹션 5.2.2.6\)을 포함하는 응답 메시지의 콘텐츠\(섹션 6.4\)를 변환해서는 안 됩니다. 이는 전송 코딩의 추가 또는 제거와 같이 내용을 변경하지 않는 메시지 변환에는 적용되지 않습니다\(\[HTTP/1.1\]의 섹션 7\).

프록시는 변환 불가 캐시 지시문을 포함하지 않는 메시지의 내용을 변환할 수 있습니다. 200\(OK\) 응답의 내용을 변환하는 프록시는 응답 상태 코드를 203\(신뢰할 수 없는 정보\)\(15.3.4절\)으로 변경하여 변환이 적용되었음을 다운스트림 수신자에게 알릴 수 있습니다.

프록시는 필드의 정의가 그러한 수정을 구체적으로 허용하거나 수정이 개인 정보 보호 또는 보안을 위해 필요하다고 간주되지 않는 한 통신 체인의 끝점, 리소스 상태 또는 선택된 표현\(콘텐츠 제외\)에 대한 정보를 제공하는 헤더 필드를 수정해서는 안 됩니다. .

---
### **7.8.  Upgrade**

"Upgrade" 헤더 필드는 동일한 연결에서 HTTP/1.1에서 다른 프로토콜로 전환하기 위한 간단한 메커니즘을 제공하기 위한 것입니다.

클라이언트는 최종 응답을 보내기 전에 선호도 순으로 하나 이상의 명명된 프로토콜로 전환하도록 서버를 초대하기 위해 요청의 업그레이드 헤더 필드에 프로토콜 이름 목록을 보낼 수 있습니다. 서버는 해당 연결에서 현재 프로토콜을 계속 사용하려는 경우 수신된 업그레이드 헤더 필드를 무시할 수 있습니다. 업그레이드는 프로토콜 변경을 요구하는 데 사용할 수 없습니다.

```text
     Upgrade          = #protocol

     protocol         = protocol-name ["/" protocol-version]
     protocol-name    = token
     protocol-version = token
```

프로토콜 이름은 선호되는 대소문자로 등록되지만, 수신자는 각 프로토콜 이름을 지원되는 프로토콜과 일치시킬 때 대소문자를 구분하지 않는 비교를 사용해야 합니다.

101\(Switching Protocols\) 응답을 보내는 서버는 연결이 전환되는 새로운 프로토콜을 나타내기 위해 업그레이드 헤더 필드를 보내야 합니다. 여러 프로토콜 계층이 전환되는 경우 발신자는 프로토콜을 계층 오름차순으로 나열해야 합니다. 서버는 해당 요청의 업그레이드 헤더 필드에 클라이언트가 표시하지 않은 프로토콜로 전환해서는 안 됩니다. 서버는 클라이언트가 지정한 우선 순위를 무시하고 요청의 성격이나 서버의 현재 로드와 같은 다른 요소를 기반으로 새 프로토콜을 선택할 수 있습니다.

426\(업그레이드 필요\) 응답을 보내는 서버는 선호도 내림차순으로 허용 가능한 프로토콜을 나타내기 위해 업그레이드 헤더 필드를 보내야 합니다.

서버는 향후 요청에 적합한 경우 선호도 내림차순으로 나열된 프로토콜로 업그레이드하기 위한 지원을 구현한다는 것을 알리기 위해 다른 응답에 업그레이드 헤더 필드를 보낼 수 있습니다.

다음은 클라이언트가 보낸 가상의 예입니다.

```text
   GET /hello HTTP/1.1
   Host: www.example.com
   Connection: upgrade
   Upgrade: websocket, IRC/6.9, RTA/x11
```

프로토콜 변경 후 애플리케이션 수준 통신의 기능과 특성은 전적으로 선택한 새 프로토콜에 따라 달라집니다. 그러나 101\(스위칭 프로토콜\) 응답을 보낸 직후 서버는 마치 새 프로토콜 내에서 해당 요청을 수신한 것처럼 원래 요청에 계속 응답할 것으로 예상됩니다. 즉, 서버에는 프로토콜 이후에 충족해야 할 미해결 요청이 여전히 남아 있습니다. 변경되었으며 요청을 반복할 필요 없이 변경될 것으로 예상됩니다\).

예를 들어, GET 요청에서 업그레이드 헤더 필드가 수신되고 서버가 프로토콜을 전환하기로 결정한 경우 먼저 HTTP/1.1의 101\(스위칭 프로토콜\) 메시지로 응답한 다음 즉시 새 프로토콜의 해당 응답으로 이어집니다. 대상 리소스에 대한 GET입니다. 이를 통해 추가 왕복으로 인한 대기 시간 비용 없이 HTTP와 동일한 의미를 갖는 프로토콜로 연결을 업그레이드할 수 있습니다. 서버는 수신된 메시지 의미가 새로운 프로토콜에 의해 존중되지 않는 한 프로토콜을 전환해서는 안 됩니다. OPTIONS 요청은 모든 프로토콜에서 수락될 수 있습니다.

다음은 위의 가상 요청에 대한 응답 예시입니다.

```text
   HTTP/1.1 101 Switching Protocols
   Connection: upgrade
   Upgrade: websocket
```

\[... 데이터 스트림은 "GET /hello" 요청에 대한 적절한 응답\(새 프로토콜에 의해 정의됨\)을 사용하여 websocket으로 전환됩니다...\]

업그레이드 발신자는 또한 연결 헤더 필드\(섹션 7.6.1\)에 "업그레이드" 연결 옵션을 보내 중개자에게 이 필드를 전달하지 말 것을 알려야 합니다. HTTP/1.0 요청에서 업그레이드 헤더 필드를 수신하는 서버는 해당 업그레이드 필드를 무시해야 합니다.

클라이언트는 요청 메시지를 완전히 보낼 때까지 연결에서 업그레이드된 프로토콜을 사용하기 시작할 수 없습니다. 즉, 클라이언트는 메시지 중간에 보내는 프로토콜을 변경할 수 없습니다. 서버가 "100-continue" 예상\(섹션 10.1.1\)과 함께 Upgrade 및 Expect 헤더 필드를 모두 수신하는 경우 서버는 101\(스위칭 프로토콜\) 응답을 보내기 전에 100\(계속\) 응답을 보내야 합니다.

업그레이드 헤더 필드는 기존 연결 위에 있는 프로토콜 전환에만 적용됩니다. 기본 연결\(전송\) 프로토콜을 전환하거나 기존 통신을 다른 연결로 전환하는 데 사용할 수 없습니다. 이러한 목적을 위해서는 3xx\(리디렉션\) 응답\(15.4절\)을 사용하는 것이 더 적절합니다.

이 사양은 섹션 2.5의 HTTP 버전 규칙과 이 사양에 대한 향후 업데이트에 정의된 대로 하이퍼텍스트 전송 프로토콜 제품군에서 사용하기 위한 프로토콜 이름 "HTTP"만 정의합니다. 추가 프로토콜 이름은 섹션 16.7에 정의된 등록 절차를 사용하여 등록해야 합니다.

---
## **8.  Representation Data and Metadata**
---
### **8.1.  Representation Data**

HTTP 메시지와 연관된 표현 데이터는 메시지 내용으로 제공되거나 메시지 의미론 및 대상 URI에 의해 참조됩니다. 표현 데이터는 표현 메타데이터 헤더 필드에 정의된 형식과 인코딩을 따릅니다.

표현 데이터의 데이터 유형은 헤더 필드 Content-Type 및 Content-Encoding을 통해 결정됩니다. 이는 순서가 지정된 2계층 인코딩 모델을 정의합니다.

```text
     representation-data := Content-Encoding( Content-Type( data ) )
```

---
### **8.2.  Representation Metadata**

표현 헤더 필드는 표현에 대한 메타데이터를 제공합니다. 메시지에 콘텐츠가 포함된 경우 표현 헤더 필드는 해당 데이터를 해석하는 방법을 설명합니다. HEAD 요청에 대한 응답에서 표현 헤더 필드는 동일한 요청이 GET인 경우 콘텐츠에 포함되었을 표현 데이터를 설명합니다.

---
### **8.3.  Content-Type**

"Content-Type" 헤더 필드는 연관된 표현의 미디어 유형\(메시지 내용에 포함된 표현 또는 메시지 의미론에 따라 결정된 선택된 표현\)을 나타냅니다. 표시된 미디어 유형은 Content-Encoding으로 표시된 콘텐츠 코딩이 디코딩된 후 수신된 메시지 의미의 범위 내에서 데이터 형식과 수신자가 해당 데이터를 처리하는 방법을 모두 정의합니다.

```text
     Content-Type = media-type
```

미디어 유형은 섹션 8.3.1에 정의되어 있습니다. 해당 분야의 예는 다음과 같습니다.

```text
   Content-Type: text/html; charset=ISO-8859-4
```

콘텐츠가 포함된 메시지를 생성하는 발신자는 포함된 표현의 의도된 미디어 유형을 발신자에게 알 수 없는 경우를 제외하고 해당 메시지에 Content-Type 헤더 필드를 생성해야 합니다. Content-Type 헤더 필드가 없으면 수신자는 "application/octet-stream"\(\[RFC2046\], 섹션 4.5.1\)의 미디어 유형을 가정하거나 데이터를 검사하여 해당 유형을 결정할 수 있습니다.

실제로 리소스 소유자는 주어진 표현에 대해 올바른 Content-Type을 제공하기 위해 원본 서버를 항상 적절하게 구성하지 않습니다. 일부 사용자 에이전트는 콘텐츠를 검사하고 어떤 경우에는 수신된 유형을 재정의합니다\(예: \[스니핑\] 참조\). 이러한 "MIME 스니핑"은 데이터에 대해 잘못된 결론을 도출할 위험이 있으며, 이로 인해 사용자가 추가적인 보안 위험\(예: "권한 상승"\)에 노출될 수 있습니다. 더욱이, 서로 다른 미디어 유형은 공통 데이터 형식을 공유하는 경우가 많으며, 데이터 처리 방법만 다르며, 이는 데이터만 검사하여 구별하는 것이 불가능합니다. 스니핑이 구현되면 구현자는 사용자가 이를 비활성화할 수 있는 수단을 제공하는 것이 좋습니다.

Content-Type은 단일 필드로 정의되어 있지만 여러 번 잘못 생성되어 결합된 필드 값이 목록처럼 나타나는 경우가 있습니다. 수신자는 구문적으로 유효한 목록의 마지막 멤버를 사용하여 이 오류를 처리하려고 시도하는 경우가 많으며, 이로 인해 구현마다 오류 처리 동작이 다를 경우 잠재적인 상호 운용성 및 보안 문제가 발생할 수 있습니다.

---
#### **8.3.1.  Media Type**

HTTP는 개방적이고 확장 가능한 데이터 유형 지정 및 유형 협상을 제공하기 위해 Content-Type\(섹션 8.3\) 및 Accept\(섹션 12.5.1\) 헤더 필드에서 미디어 유형 \[RFC2046\]을 사용합니다. 미디어 유형은 데이터 형식과 다양한 처리 모델, 즉 메시지 컨텍스트에 따라 해당 데이터를 처리하는 방법을 모두 정의합니다.

```text
     media-type = type "/" subtype parameters
     type       = token
     subtype    = token
```

유형 및 하위 유형 토큰은 대소문자를 구분하지 않습니다.

유형/하위 유형 뒤에는 이름/값 쌍의 형태로 세미콜론으로 구분된 매개변수\(섹션 5.6.6\)가 올 수 있습니다. 매개변수의 유무는 미디어 유형 레지스트리 내의 정의에 따라 미디어 유형 처리에 중요할 수 있습니다. 매개변수 값은 매개변수 이름의 의미에 따라 대소문자를 구분할 수도 있고 그렇지 않을 수도 있습니다.

예를 들어, 다음 미디어 유형은 UTF-8 문자 인코딩 체계로 인코딩된 HTML 텍스트 데이터를 설명하는 데 동일하지만 일관성을 위해 첫 번째 미디어 유형이 선호됩니다\("charset" 매개변수 값은 \[RFC2046\]에서 대소문자를 구분하지 않는 것으로 정의되어 있습니다. 섹션 4.1.2\):

```text
     text/html;charset=utf-8
     Text/HTML;Charset="utf-8"
     text/html; charset="utf-8"
     text/html;charset=UTF-8
```

미디어 유형은 \[BCP13\]에 정의된 절차에 따라 IANA에 등록되어야 합니다.

---
#### **8.3.2.  Charset**

HTTP는 "문자 집합" 이름을 사용하여 텍스트 표현의 문자 인코딩 체계\(\[RFC6365\], 섹션 2\)를 나타내거나 협상합니다. 이 문서에서 정의한 필드에서 문자 집합 이름은 매개 변수\(Content-Type\)에 표시되거나 Accept-Encoding의 경우 일반 토큰 형식으로 표시됩니다. 두 경우 모두 문자 세트 이름은 대소문자를 구분하지 않고 일치됩니다.

문자 세트 이름은 \[RFC2978\]의 섹션 2에 정의된 절차에 따라 IANA "문자 세트" 레지스트리\(<https://www.iana.org/locationments/character-sets\>\)에 등록되어야 합니다.

- | \*참고:\* 이론적으로 문자 집합 이름은 \[RFC2978\]의 섹션 2.3에 정의된 "mime- | charset" ABNF 규칙에 따라 정의됩니다\(\[Err1912\]에서 | 수정됨\). 이 규칙은 | "토큰"\("{" 및 "}"\)에는 포함되지 않지만 문자 세트 이름은 없습니다 | 이 글을 쓰는 시점에 등록된 등록에는 중괄호가 포함되어 있습니다\(| \[Err5433\] 참조\).

---
#### **8.3.3.  Multipart Types**

MIME은 단일 메시지 본문 내에서 하나 이상의 표현을 캡슐화하는 다양한 "다중 부분" 유형을 제공합니다. 모든 멀티파트 유형은 \[RFC2046\]의 섹션 5.1.1에 정의된 대로 공통 구문을 공유하며 미디어 유형 값의 일부로 경계 매개변수를 포함합니다. 메시지 본문 자체는 프로토콜 요소입니다. 발신자는 본문 부분 사이의 줄 바꿈을 나타내기 위해 CRLF만 생성해야 합니다.

HTTP 메시지 프레이밍은 다중 부분 경계를 메시지 본문 길이의 표시기로 사용하지 않지만 콘텐츠를 생성하거나 처리하는 구현에서는 사용할 수 있습니다. 예를 들어, "multipart/form-data" 유형은 \[RFC7578\]에 설명된 대로 요청에서 양식 데이터를 전달하는 데 자주 사용되며 "multipart/byteranges" 유형은 일부 206\(부분 부분\)에서 사용하기 위해 이 사양에 의해 정의됩니다. 내용\) 응답\(섹션 15.3.7 참조\).

---
### **8.4.  Content-Encoding**

"Content-Encoding" 헤더 필드는 미디어 유형에 내재된 코딩을 넘어 어떤 콘텐츠 코딩이 표현에 적용되었는지, 따라서 Content-Encoding에서 참조하는 미디어 유형의 데이터를 얻기 위해 어떤 디코딩 메커니즘을 적용해야 하는지를 나타냅니다. 헤더 필드를 입력하세요. Content-Encoding은 주로 기본 미디어 유형의 ID를 잃지 않고 표현의 데이터를 압축할 수 있도록 하는 데 사용됩니다.

```text
     Content-Encoding = #content-coding
```

그 사용 예는 다음과 같습니다.

```text
   Content-Encoding: gzip
```

하나 이상의 인코딩이 표현에 적용된 경우 인코딩을 적용한 발신자는 적용된 순서대로 콘텐츠 코딩을 나열하는 Content-Encoding 헤더 필드를 생성해야 합니다. "identity"라는 코딩은 Accept-Encoding의 특별한 역할을 위해 예약되어 있으므로 포함되어서는 안 됩니다.

인코딩 매개변수에 대한 추가 정보는 이 사양에 정의되지 않은 다른 헤더 필드에서 제공될 수 있습니다.

Transfer-Encoding\(\[HTTP/1.1\]의 섹션 6.1\)과 달리 Content-Encoding에 나열된 코딩은 표현의 특징입니다. 표현은 코드화된 형식의 관점에서 정의되며, 표현에 대한 다른 모든 메타데이터는 메타데이터 정의에서 달리 명시하지 않는 한 코드화된 형식에 관한 것입니다. 일반적으로 표현은 렌더링 또는 유사한 사용 직전에만 디코딩됩니다.

미디어 유형에 항상 압축되는 데이터 형식과 같은 고유 인코딩이 포함된 경우 해당 인코딩은 콘텐츠 코딩 중 하나와 동일한 알고리즘이더라도 Content-Encoding에서 다시 지정되지 않습니다. 이러한 콘텐츠 코딩은 어떤 이상한 이유로 표현을 형성하기 위해 두 번째로 적용되는 경우에만 나열됩니다. 마찬가지로 원서버는 코딩이 Content-Type 또는 Content-Encoding의 일부로 정의되는지 여부만 다른 여러 표현으로 동일한 데이터를 게시하도록 선택할 수 있습니다. 왜냐하면 일부 사용자 에이전트는 각 응답을 처리할 때 다르게 동작하기 때문입니다\(예: , 자동 압축 풀기 및 콘텐츠 렌더링 대신 "다른 이름으로 저장..." 대화 상자를 엽니다.

요청 메시지의 표현에 허용되지 않는 콘텐츠 코딩이 있는 경우 원서버는 상태 코드 415\(지원되지 않는 미디어 유형\)로 응답할 수 있습니다.

---
#### **8.4.1.  Content Codings**

콘텐츠 코딩 값은 표현에 적용되었거나 적용될 수 있는 인코딩 변환을 나타냅니다. 콘텐츠 코딩은 주로 기본 미디어 유형의 정체성을 잃지 않고 정보 손실 없이 표현을 압축하거나 유용하게 변환할 수 있도록 하는 데 사용됩니다. 흔히 표현은 코드화된 형태로 저장되고, 직접 전송되며, 최종 수신자에 의해서만 디코딩됩니다.

```text
     content-coding   = token
```

모든 콘텐츠 코딩은 대소문자를 구분하지 않으며 섹션 16.6에 설명된 대로 "HTTP 콘텐츠 코딩 레지스트리" 내에 등록되어야 합니다.

콘텐츠 코딩 값은 Accept-Encoding\(섹션 12.5.3\) 및 Content-Encoding\(섹션 8.4\) 헤더 필드에 사용됩니다.

---
##### **8.4.1.1.  Compress Coding**

"압축" 코딩은 UNIX 파일 압축 프로그램 "compress"에 의해 일반적으로 생성되는 적응형 Lempel-Ziv-Welch\(LZW\) 코딩\[Welch\]입니다. 수신자는 "x-compress"를 "압축"과 동일하다고 간주해야 합니다.

---
##### **8.4.1.2.  Deflate Coding**

"deflate" 코딩은 Lempel-Ziv\(LZ77\) 압축 알고리즘과 Huffman 코딩의 조합을 사용하는 "deflate" 압축 데이터 스트림\[RFC1951\]을 포함하는 "zlib" 데이터 형식\[RFC1950\]입니다.

- | \*참고:\* 일부 비준수 구현은 "deflate" | zlib 래퍼 없이 압축된 데이터.

---
##### **8.4.1.3.  Gzip Coding**

"gzip" 코딩은 gzip 파일 압축 프로그램\[RFC1952\]에 의해 일반적으로 생성되는 32비트 CRC\(Cyclic Redundancy Check\)를 사용하는 LZ77 코딩입니다. 수신자는 "x-gzip"이 "gzip"과 동일하다고 간주해야 합니다.

---
### **8.5.  Content-Language**

"Content-Language" 헤더 필드는 표현을 위해 의도된 청중의 자연 언어를 설명합니다. 이는 표현 내에서 사용되는 모든 언어와 동일하지 않을 수도 있습니다.

```text
     Content-Language = #language-tag
```

언어 태그는 섹션 8.5.1에 ​​정의되어 있습니다. Content-Language의 주요 목적은 사용자가 자신이 선호하는 언어에 따라 표현을 식별하고 차별화할 수 있도록 하는 것입니다. 따라서 콘텐츠가 덴마크어를 읽을 수 있는 청중만을 대상으로 하는 경우 해당 필드는 다음과 같습니다.

```text
   Content-Language: da
```

Content-Language가 지정되지 않은 경우 기본값은 콘텐츠가 모든 언어 사용자를 대상으로 하는 것입니다. 이는 보낸 사람이 해당 내용을 자연어에만 적용되는 것으로 간주하지 않거나 어떤 언어에 대한 것인지 보낸 사람이 알지 못함을 의미할 수 있습니다.

여러 청중을 대상으로 하는 콘텐츠의 경우 여러 언어가 나열될 수 있습니다. 예를 들어, 원본 마오리어와 영어 버전으로 동시에 제시된 "와이탕이 조약"의 번역은 다음을 요구합니다.

```text
   Content-Language: mi, en
```

그러나 표현 내에 여러 언어가 존재한다고 해서 그것이 여러 언어를 사용하는 청중을 대상으로 한다는 의미는 아닙니다. 예를 들어 "라틴어 첫 수업"과 같은 초보자용 언어 입문서는 분명히 영어를 구사하는 청중이 사용하도록 의도된 것입니다. 이 경우 Content-Language에는 "en"만 올바르게 포함됩니다.

Content-Language는 모든 미디어 유형에 적용될 수 있으며 텍스트 문서에만 국한되지 않습니다.

---
#### **8.5.1.  Language Tags**

\[RFC5646\]에 정의된 언어 태그는 다른 인간에게 정보를 전달하기 위해 인간이 말하거나 쓰거나 전달하는 자연어를 식별합니다. 컴퓨터 언어는 명시적으로 제외됩니다.

HTTP는 Accept-Language 및 Content-Language 헤더 필드 내의 언어 태그를 사용합니다. Accept-Language는 섹션 12.5.4에 정의된 더 넓은 언어 범위 생성을 사용하는 반면, Content-Language는 아래에 정의된 언어 태그 생성을 사용합니다.

```text
     language-tag = <Language-Tag, see [RFC5646], Section 2.1>
```

언어 태그는 대소문자를 구분하지 않는 하나 이상의 하위 태그 시퀀스로, 각 하위 태그는 하이픈 문자\("-", %x2D\)로 구분됩니다. 대부분의 경우 언어 태그는 광범위한 관련 언어군을 식별하는 기본 언어 하위 태그\(예: "en" = 영어\)로 구성되며, 선택적으로 해당 언어의 범위를 구체화하거나 좁히는 일련의 하위 태그가 뒤따릅니다\(예: "en-CA" = 캐나다에서 사용되는 다양한 영어\). 언어 태그 내에는 공백이 허용되지 않습니다. 예제 태그는 다음과 같습니다.

```text
     fr, en-US, es-419, az-Arab, x-pig-latin, man-Nkoo-GN
```

자세한 내용은 \[RFC5646\]을 참조하세요.

---
### **8.6.  Content-Length**

"Content-Length" 헤더 필드는 연관된 표현의 데이터 길이를 음이 아닌 정수 옥텟 수의 십진수로 나타냅니다. 표현을 콘텐츠로 전송할 때 Content-Length는 프레임을 구분하는 데 사용할 수 있도록 포함된 데이터의 양을 구체적으로 나타냅니다\(예: \[HTTP/1.1\]의 섹션 6.2\). 다른 경우, Content-Length는 선택된 표현의 현재 길이를 나타내며, 이는 수신자가 전송 시간을 추정하거나 이전에 저장된 표현과 비교하는 데 사용할 수 있습니다.

```text
     Content-Length = 1*DIGIT
```

예는 다음과 같습니다

```text
   Content-Length: 3495
```

사용자 에이전트는 메서드가 포함된 콘텐츠에 대한 의미를 정의하고 Transfer-Encoding을 전송하지 않는 경우 요청에 Content-Length를 보내야 합니다. 예를 들어, 사용자 에이전트는 일반적으로 값이 0\(빈 콘텐츠를 나타냄\)인 경우에도 POST 요청에서 Content-Length를 보냅니다. 사용자 에이전트는 요청 메시지에 콘텐츠가 포함되어 있지 않고 메소드 의미론이 그러한 데이터를 예상하지 않는 경우 Content-Length 헤더 필드를 전송해서는 안 됩니다.

서버는 HEAD 요청에 대한 응답으로 Content-Length 헤더 필드를 보낼 수 있습니다\(섹션 9.3.2\). 서버는 해당 필드 값이 동일한 요청이 GET 메서드를 사용한 경우 응답 콘텐츠로 전송되었을 옥텟의 십진수와 동일하지 않는 한 그러한 응답에서 Content-Length를 전송해서는 안 됩니다.

서버는 조건부 GET 요청\(섹션 15.4.5\)에 대한 304\(수정되지 않음\) 응답으로 Content-Length 헤더 필드를 보낼 수 있습니다. 서버는 해당 필드 값이 동일한 요청에 대한 200\(OK\) 응답의 콘텐츠로 전송된 옥텟의 십진수와 동일하지 않는 한 그러한 응답에서 Content-Length를 전송해서는 안 됩니다.

서버는 상태 코드가 1xx\(정보\) 또는 204\(콘텐츠 없음\)인 응답으로 Content-Length 헤더 필드를 전송해서는 안 됩니다. 서버는 CONNECT 요청\(섹션 9.3.6\)에 대한 2xx\(성공\) 응답에서 Content-Length 헤더 필드를 전송해서는 안 됩니다.

위에 정의된 경우를 제외하고 Transfer-Encoding이 없는 경우 원서버는 전체 헤더 섹션을 전송하기 전에 콘텐츠 크기가 알려진 경우 Content-Length 헤더 필드를 전송해야 합니다. 이를 통해 다운스트림 수신자는 전송 진행 상황을 측정하고, 수신된 메시지가 완료된 시기를 알 수 있으며, 잠재적으로 추가 요청에 대한 연결을 재사용할 수 있습니다.

0보다 크거나 같은 모든 Content-Length 필드 값이 유효합니다. 콘텐츠 길이에 미리 정의된 제한이 없기 때문에 수신자는 잠재적으로 큰 십진수를 예상해야 하며 정수 변환 오버플로로 인한 구문 분석 오류 또는 정수 변환으로 인한 정밀도 손실을 방지해야 합니다\(17.5절\).

Content-Length는 HTTP/1.1에서 메시지 구분에 사용되므로 해당 필드 값은 직접 연결이 HTTP/1.1을 사용하지 않는 경우에도 다운스트림 수신자가 메시지를 구문 분석하는 방식에 영향을 미칠 수 있습니다. 메시지가 다운스트림 중개자에 의해 전달되는 경우 수신된 메시지 프레이밍과 일치하지 않는 Content-Length 필드 값으로 인해 요청 밀수 또는 응답 분할로 인해 보안 오류가 발생할 수 있습니다.

결과적으로 발신자는 잘못된 것으로 알려진 Content-Length 헤더 필드 값을 사용하여 메시지를 전달해서는 안 됩니다.

마찬가지로 발신자는 위의 ABNF와 일치하지 않는 Content-Length 헤더 필드 값이 있는 메시지를 전달해서는 안 됩니다. 단, 한 가지 예외는 쉼표로 반복되는 동일한 십진수 값으로 구성된 Content-Length 헤더 필드 값의 수신자입니다. 분리된 목록\(예: "Content-Length: 42, 42"\)은 메시지를 유효하지 않은 것으로 거부하거나 해당 유효하지 않은 필드 값을 소수 값의 단일 인스턴스로 대체할 수 있습니다. 이는 중복이 생성되었거나 다음에 의해 결합되었음을 나타낼 가능성이 높기 때문입니다. 업스트림 메시지 프로세서.

---
### **8.7.  Content-Location**

"Content-Location" 헤더 필드는 이 메시지 콘텐츠의 표현에 해당하는 특정 리소스에 대한 식별자로 사용할 수 있는 URI를 참조합니다. 즉, 이 메시지 생성 시 이 URI에 대해 GET 요청을 수행하는 경우 200\(OK\) 응답에는 이 메시지의 콘텐츠로 포함된 동일한 표현이 포함됩니다.

```text
     Content-Location = absolute-URI / partial-URI
```

필드 값은 절대 URI 또는 ​​부분 URI입니다. 후자의 경우\(섹션 4\), 참조된 URI는 대상 URI\(\[URI\], 섹션 5\)를 기준으로 합니다.

Content-Location 값은 대상 URI\(섹션 7.1\)를 대체하지 않습니다. 표현 메타데이터입니다. 이는 \[RFC2557\]의 섹션 4에서 MIME 본문 부분에 대해 정의된 동일한 이름의 헤더 필드와 동일한 구문 및 의미를 갖습니다. 그러나 HTTP 메시지에 표시되는 내용은 HTTP 수신자에게 몇 가지 특별한 의미를 갖습니다.

Content-Location이 2xx\(성공\) 응답 메시지에 포함되어 있고 해당 값이 \(절대 형식으로 변환된 후\) 대상 URI와 동일한 URI를 참조하는 경우 수신자는 해당 콘텐츠를 다음의 현재 표현으로 간주할 수 있습니다. 메시지 발생 날짜로 표시된 시간에 해당 리소스를 사용합니다. GET\(섹션 9Content-Location이 2xx\(성공\) 응답 메시지에 포함되어 있고 해당 값이 \(절대 형식으로 변환된 후\) 대상 URI와 동일한 URI를 참조하는 경우 수신자는 해당 콘텐츠를 다음의 현재 표현으로 간주할 수 있습니다. 메시지 발생 날짜로 표시된 시간에 해당 리소스를 사용합니다. GET\(섹션 9.3.1\) 또는 HEAD\(섹션 9.3.2\) 요청의 경우 이는 서버에서 Content-Location을 제공하지 않을 때의 기본 의미 체계와 동일합니다. PUT\(섹션 9.3.4\) 또는 POST\(섹션 9.3.3\)와 같은 상태 변경 요청의 경우 서버의 응답에 해당 리소스의 새로운 표현이 포함되어 있음을 의미하므로 작업에 대해서만 보고할 수 있는 표현과 구별됩니다\( 예를 들어 "효과가 있었습니다!"\). 이를 통해 저작 애플리케이션은 후속 GET 요청 없이도 로컬 복사본을 업데이트할 수 있습니다.

Content-Location이 2xx\(성공\) 응답 메시지에 포함되어 있고 해당 필드 값이 대상 URI와 다른 URI를 참조하는 경우 원서버는 해당 URI가 포함된 표현에 해당하는 다른 리소스에 대한 식별자라고 주장합니다. 이러한 클레임은 두 식별자가 동일한 리소스 소유자를 공유하는 경우에만 신뢰할 수 있으며 이는 HTTP를 통해 프로그래밍 방식으로 확인할 수 없습니다.

\* GET 또는 HEAD 요청에 대한 응답의 경우 이는 대상 URI가 콘텐츠 협상 대상인 리소스를 참조하고 Content-Location 필드 값이 선택한 표현에 대한 보다 구체적인 식별자임을 나타냅니다.

\* 상태 변경 메서드에 대한 201\(Created\) 응답의 경우 Location 필드 값과 동일한 Content-Location 필드 값은 이 콘텐츠가 새로 생성된 리소스의 현재 표현임을 나타냅니다.

\* 그렇지 않은 경우 이러한 Content-Location은 이 콘텐츠가 요청된 작업의 상태를 보고하는 표현이고 동일한 보고서가 지정된 URI에서 \(향후 GET을 통해 액세스할 경우\) 사용 가능함을 나타냅니다. 예를 들어, POST 요청을 통해 이루어진 구매 거래에는 200\(OK\) 응답의 내용으로 영수증 문서가 포함될 수 있습니다. Content-Location 필드 값은 나중에 동일한 영수증의 복사본을 검색하기 위한 식별자를 제공합니다.

요청 메시지에서 Content-Location을 보내는 사용자 에이전트는 해당 값이 사용자 에이전트가 동봉된 표현의 콘텐츠를 원래 얻은 위치\(해당 사용자 에이전트가 수정하기 전\)를 참조한다고 명시하고 있습니다. 즉, 사용자 에이전트는 원본 표현의 소스에 대한 백링크를 제공합니다.

요청 메시지에서 Content-Location 필드를 수신하는 원서버는 해당 정보를 표현의 일부로 축어적으로 저장할 메타데이터가 아닌 임시 요청 컨텍스트로 처리해야 합니다. 원본 서버는 해당 컨텍스트를 사용하여 요청 처리를 안내하거나 소스 링크 또는 버전 관리 메타데이터 내에서와 같은 다른 용도로 저장할 수 있습니다. 그러나 원서버는 요청 의미를 변경하기 위해 그러한 컨텍스트 정보를 사용해서는 안 됩니다.

예를 들어, 클라이언트가 협상된 리소스에 대해 PUT 요청을 하고 원본 서버가 해당 PUT\(리디렉션 없이\)을 수락하는 경우 해당 리소스의 새로운 상태는 해당 PUT에 제공된 하나의 표현과 일치할 것으로 예상됩니다. Content-Location은 협상된 표현 중 하나만 업데이트하기 위한 역방향 콘텐츠 선택 식별자의 형태로 사용될 수 없습니다. 사용자 에이전트가 후자의 의미를 원했다면 PUT를 Content-Location URI에 직접 적용했을 것입니다.

---
### **8.8.  Validator Fields**

조건부 요청\(섹션 13\)을 만들기 위해 전제 조건\(섹션 13.1\) 내에서 사용될 수 있는 경우 리소스 메타데이터를 "유효성 검사기"라고 합니다. 유효성 검사기 필드는 선택한 표현에 대한 현재 유효성 검사기를 전달합니다\(섹션 3.2\).

안전한 요청에 대한 응답에서 유효성 검사기 필드는 응답을 처리하는 동안 원본 서버가 선택한 표현을 설명합니다. 메서드 및 상태 코드 의미에 따라 주어진 응답에 대해 선택된 표현이 반드시 응답 콘텐츠로 포함된 표현과 동일하지는 않습니다.

상태 변경 요청에 대한 성공적인 응답에서 유효성 검사기 필드는 요청 처리 결과로 이전에 선택한 표현을 대체한 새로운 표현을 설명합니다.

예를 들어, 201\(생성됨\) 응답의 ETag 필드는 새로 생성된 리소스 표현의 엔터티 태그를 전달하므로 엔터티 태그는 "업데이트 손실" 문제를 방지하기 위해 이후 조건부 요청에서 유효성 검사기로 사용될 수 있습니다.

이 사양은 리소스 상태를 관찰하고 전제 조건을 테스트하는 데 일반적으로 사용되는 두 가지 형태의 메타데이터, 즉 수정 날짜\(섹션 8.8.2\)와 불투명 엔터티 태그\(섹션 8.8.3\)를 정의합니다. 리소스 상태를 반영하는 추가 메타데이터는 이 사양의 범위를 벗어나는 Web Distributed Authoring and Versioning \[WEBDAV\]와 같은 다양한 HTTP 확장에 의해 정의되었습니다.

---
#### **8.8.1.  Weak versus Strong**

유효성 검사기는 강함과 약함의 두 가지 형태로 제공됩니다. 약한 유효성 검사기는 생성하기 쉽지만 비교에 훨씬 덜 유용합니다. 강력한 유효성 검사기는 비교에 이상적이지만 효율적으로 생성하기가 매우 어려울 수 있습니다\(때로는 불가능할 수도 있음\). 모든 형태의 리소스가 동일한 유효성 검사기 강도를 준수하도록 강요하는 대신 HTTP는 사용 중인 유효성 검사기 유형을 노출하고 약한 유효성 검사기를 전제 조건으로 사용할 수 있는 경우에 대한 제한을 부과합니다.

"강력한 유효성 검사기"는 GET에 대한 200\(OK\) 응답의 내용에서 관찰할 수 있는 표현 데이터에 변경이 발생할 때마다 값을 변경하는 표현 메타데이터입니다.

강력한 유효성 검사기는 표현 메타데이터의 의미상 중요한 부분\(예: Content-Type\)이 변경되는 경우와 같이 표현 데이터 변경 이외의 이유로 변경될 수 있지만 원서버의 최선의 이익은 다음과 같습니다. 원격 캐시 및 작성 도구에 저장된 응답을 무효화해야 하는 경우 값을 변경하십시오.

캐시 항목은 만료 시간에 관계없이 임의로 장기간 지속될 수 있습니다. 따라서 캐시는 먼 과거에 얻은 유효성 검사기를 사용하여 항목의 유효성을 검사하려고 시도할 수 있습니다. 강력한 유효성 검사기는 시간이 지남에 따라 실제로 사용되는 다양한 강력한 유효성 검사기가 있습니다. 가장 좋은 방법은 엄격한 개정 제어를 기반으로 하며, 표현에 대한 각 변경으로 인해 해당 표현이 GET에 액세스 가능해지기 전에 항상 고유한 노드 이름과 개정 식별자가 할당됩니다. 응답 헤더 필드가 전송되기 전에 데이터를 사용할 수 있고 유효성 검사 요청이 수신될 때마다 다이제스트를 다시 계산할 필요가 없는 경우 표현 데이터에 적용되는 충돌 방지 해시 함수로도 충분합니다. 그러나 리소스에 메타데이터만 다른 고유한 표현이 있는 경우\(예: 동일한 데이터 형식을 공유하는 미디어 유형에 대한 콘텐츠 협상에서 발생할 수 있음\) 원서버는 해당 표현을 구별하기 위해 유효성 검사기에 추가 정보를 통합해야 합니다. .

이와 대조적으로 "약한 유효성 검사기"는 표현 데이터가 변경될 때마다 변경되지 않을 수 있는 표현 메타데이터입니다. 이러한 약점은 값이 계산되는 방식\(예: 클럭 해상도\)의 제한, 리소스의 가능한 모든 표현에 대한 고유성을 보장할 수 없음, 리소스 소유자가 자체 결정된 집합으로 표현을 그룹화하려는 바람으로 인해 발생할 수 있습니다. 데이터의 고유한 시퀀스가 ​​아닌 동등성입니다.

원서버는 이전 표현이 현재 표현을 대체할 수 없다고 생각할 때마다 약한 엔터티 태그를 변경해야 합니다\(SHOULD\). 즉, 약한 엔터티 태그는 원본 서버가 캐시를 통해 이전 응답을 무효화하기를 원할 때마다 변경되어야 합니다.

예를 들어, 동적 측정을 기반으로 매초 콘텐츠가 변경되는 일기 예보의 표현은 캐시된 표현이 유효하도록 허용하기 위해 동일한 약한 유효성 검사기를 사용하여 \(원서버의 관점에서\) 등가 표현 세트로 그룹화될 수 있습니다. 합리적인 기간 동안\(서버 로드나 날씨 품질에 따라 동적으로 조정될 수 있음\) 마찬가지로 표현의 수정 시간은 1초 분해능으로만 정의된 경우 표현이 1초 동안 두 번 수정되고 해당 수정 사이에서 검색될 수 있는 경우 약한 유효성 검사기가 될 수 있습니다.

마찬가지로, 해당 표현이 동일한 표현 데이터를 갖지 않는 한, 주어진 리소스에 대한 두 개 이상의 표현이 동시에 공유되는 경우 유효성 검사기는 약합니다. 예를 들어 원본 서버가 콘텐츠 코딩이 없는 표현과 마찬가지로 gzip 콘텐츠 코딩이 적용된 표현에 대해 동일한 유효성 검사기를 보내는 경우 해당 유효성 검사기는 약합니다. 그러나 두 개의 동시 표현은 동일한 표현 데이터에 대해 두 개의 다른 미디어 유형을 사용할 수 있는 경우와 같이 표현 메타데이터만 다른 경우 동일한 강력한 유효성 검사기를 공유할 수 있습니다.

캐시 유효성 검사, 부분 콘텐츠 범위 및 "업데이트 손실" 방지를 포함한 모든 조건부 요청에 대해 강력한 유효성 검사기를 사용할 수 있습니다. 약한 유효성 검사기는 캐시 항목의 유효성을 검사하거나 웹 탐색을 최근 변경 사항으로 제한하는 경우와 같이 클라이언트가 이전에 얻은 표현 데이터와의 정확한 동일성을 요구하지 않는 경우에만 사용할 수 있습니다.

---
#### **8.8.2.  Last-Modified**

응답의 "Last-Modified" 헤더 필드는 요청 처리가 끝날 때 결정된 대로 원서버가 선택된 표현이 마지막으로 수정되었다고 믿는 날짜와 시간을 나타내는 타임스탬프를 제공합니다.

```text
     Last-Modified = HTTP-date
```

그 사용 예는 다음과 같습니다.

```text
   Last-Modified: Tue, 15 Nov 1994 12:45:26 GMT
```

---
##### **8.8.2.1.  Generation**

원본 서버는 조건부 요청 및 캐시 신선도 평가\(\[CACHING\]\)에 사용하면 불필요한 전송을 크게 줄이고 서비스 가용성을 크게 향상시킬 수 있으므로 마지막 수정 날짜가 합리적이고 일관되게 결정될 수 있는 선택된 표현에 대해 Last-Modified를 보내야 합니다. 그리고 확장성.

표현은 일반적으로 리소스 인터페이스 뒤에 있는 여러 부분의 합계입니다. 마지막 수정 시간은 일반적으로 해당 부분이 변경된 가장 최근 시간입니다. 특정 리소스에 대해 해당 값이 결정되는 방법은 이 사양의 범위를 벗어나는 구현 세부 사항입니다.

원서버는 응답에 대한 Date 필드 값을 생성하는 시간에 최대한 가까운 표현의 Last-Modified 값을 얻어야 합니다\(SHOULD\). 이를 통해 수신자는 특히 응답이 생성되는 시간 근처에 표현이 변경되는 경우 표현의 수정 시간을 정확하게 평가할 수 있습니다.

시계가 있는 원서버\(섹션 5.6.7에 정의됨\)는 서버의 메시지 발생 시간\(날짜, 섹션 6.6.1\)보다 이후의 최종 수정 날짜를 생성해서는 안 됩니다. 마지막 수정 시간이 원서버의 시계에 따라 미래의 특정 시간으로 평가되는 구현별 메타데이터에서 파생된 경우 원서버는 해당 값을 메시지 발생 날짜로 바꿔야 합니다. 이렇게 하면 향후 수정 날짜가 캐시 유효성 검사에 부정적인 영향을 미치는 것을 방지할 수 있습니다.

시계가 없는 원서버는 해당 날짜 값이 다른 시스템\(아마도 시계가 있는 시스템\)에 의해 리소스에 할당되지 않는 한 응답에 대한 Last-Modified 날짜를 생성해서는 안 됩니다.

---
##### **8.8.2.2.  Comparison**

요청에서 유효성 검사기로 사용되는 Last-Modified 시간은 다음 규칙을 사용하여 강력하다고 추론할 수 없는 한 암시적으로 약합니다.

\* 검증자는 표현을 위해 원본 서버에 의해 실제 현재 검증자와 비교됩니다.

\* 해당 원서버는 제시된 검증자가 다루는 두 번째 동안 관련 표현이 두 번 변경되지 않았다는 것을 확실하게 알고 있습니다.

```text
   or
```

\* 클라이언트가 관련 표현에 대한 캐시 항목을 가지고 있기 때문에 클라이언트가 If-Modified-Since, If-Unmodified-Since 또는 If-Range 헤더 필드에서 유효성 검사기를 사용하려고 합니다.

\* 해당 캐시 항목에는 Last-Modified 값보다 최소 1초 이후의 Date 값이 포함되어 있으며 클라이언트는 해당 값이 동일한 시계에 의해 생성되었거나 Last-Modified와 Date 값 사이에 충분한 차이가 있다고 믿을 만한 이유가 있습니다. 시계 동기화 문제가 발생하지 않도록 합니다.

```text
   or
```

\* 유효성 검사기는 중간 캐시에 의해 표현을 위해 캐시 항목에 저장된 유효성 검사기와 비교됩니다.

\* 해당 캐시 항목에는 Last-Modified 값보다 최소 1초 이후의 Date 값이 포함되어 있으며 캐시는 해당 값이 동일한 시계에 의해 생성되었거나 Last-Modified와 Date 값 사이에 충분한 차이가 있다고 믿을 만한 이유가 있습니다. 시계 동기화 문제가 발생하지 않도록 합니다.

이 방법은 동일한 초 동안 원본 서버에서 두 개의 서로 다른 응답을 보냈지만 둘 다 동일한 Last-Modified 시간을 가졌다면 해당 응답 중 적어도 하나는 Last-Modified와 동일한 Date 값을 갖는다는 사실에 의존합니다. 시간.

---
#### **8.8.3.  ETag**

응답의 "ETag" 필드는 요청 처리가 끝난 후 결정된 대로 선택한 표현에 대한 현재 엔터티 태그를 제공합니다. 엔터티 태그는 시간이 지남에 따라 여러 표현이 리소스 상태 변경으로 인한 것인지, 여러 표현이 동시에 유효한 콘텐츠 협상으로 인한 것인지, 또는 둘 다로 인한 것인지 여부에 관계없이 동일한 리소스의 여러 표현을 구별하기 위한 불투명한 유효성 검사기입니다. 엔터티 태그는 불투명한 인용 문자열로 구성되며, 앞에 약점 표시자가 붙을 수도 있습니다.

```text
     ETag       = entity-tag

     entity-tag = [ weak ] opaque-tag
     weak       = %s"W/"
     opaque-tag = DQUOTE *etagc DQUOTE
     etagc      = %x21 / %x23-7E / obs-text
                ; VCHAR except double quotes, plus obs-text
```

- | \*참고:\* 이전에는 opaque-tag가 quoted- | 문자열\(\[RFC2616\], 섹션 3.11\); 따라서 일부 수신자는 | 백슬래시 이스케이프 해제를 수행합니다. 따라서 서버는 다음을 피해야 합니다 | 엔터티 태그의 백슬래시 문자.

수정 날짜를 저장하는 것이 불편한 경우, HTTP 날짜 값의 1초 해상도가 충분하지 않은 경우 또는 수정 날짜가 일관되게 유지되지 않는 경우 엔터티 태그는 수정 날짜보다 유효성 검사에 더 신뢰할 수 있습니다.

```text
   Examples:

   ETag: "xyzzy"
   ETag: W/"xyzzy"
   ETag: ""
```

엔터티 태그는 약하거나 강한 유효성 검사기일 수 있으며 기본값은 강함입니다. 원서버가 표현을 위한 엔터티 태그를 제공하고 해당 엔터티 태그의 생성이 강력한 유효성 검사기\(섹션 8.8.1\)의 모든 특성을 충족하지 못하는 경우 원서버는 해당 엔터티 태그에 접두사를 붙여서 엔터티 태그를 약한 것으로 표시해야 합니다. "W/"\(대소문자 구분\)가 포함된 불투명 값입니다.

발신자는 트레일러 섹션의 ETag 필드를 보낼 수 있습니다\(섹션 6.5 참조\). 다만, 트레일러는 무시되는 경우가 많기 때문에 콘텐츠 전송 시 엔터티 태그가 생성되지 않는 이상 ETag를 헤더 필드로 전송하는 것이 바람직하다.

---
##### **8.8.3.1.  Generation**

엔터티 태그의 기본 원칙은 서비스 작성자만이 해당 리소스에 대해 가장 정확하고 효율적인 유효성 검사 메커니즘을 선택할 수 있을 만큼 리소스의 구현을 잘 알고 있으며 이러한 메커니즘은 쉽게 비교할 수 있도록 간단한 옥텟 시퀀스에 매핑될 수 있다는 것입니다. 값이 불투명하기 때문에 클라이언트는 각 엔터티 태그가 어떻게 구성되는지 알 필요가 없습니다.

예를 들어, 모든 변경 사항에 구현별 버전 관리가 적용되는 리소스는 표현을 정확하게 구별하기 위해 콘텐츠 협상을 위한 차이 식별자와 결합된 내부 개정 번호를 사용할 수 있습니다. 다른 구현에서는 표현 콘텐츠의 충돌 방지 해시, 다양한 파일 속성의 조합 또는 1초 미만의 해상도를 갖는 수정 타임스탬프를 사용할 수 있습니다.

조건부 요청 및 캐시 신선도 평가\(\[CACHING\]\)에서 엔터티 태그를 사용하면 불필요한 전송을 크게 줄이고 서비스 가용성을 크게 향상시킬 수 있으므로 원서버는 변경 감지가 합리적이고 일관되게 결정될 수 있는 선택된 표현에 대해 ETag를 보내야 합니다. , 확장성 및 안정성.

---
##### **8.8.3.2.  Comparison**

비교 컨텍스트에서 약한 유효성 검사기 사용을 허용하는지 여부에 따라 두 가지 엔터티 태그 비교 함수가 있습니다.

"강력한 비교": 두 엔터티 태그가 모두 약하지 않고 불투명 태그가 문자별로 일치하는 경우 두 엔터티 태그는 동일합니다.

"약한 비교": 불투명 태그가 문자별로 일치하는 경우 두 엔터티 태그는 둘 중 하나 또는 둘 다 "약함"으로 태그 지정되었는지 여부에 관계없이 동일합니다.

아래 예는 엔터티 태그 쌍 집합에 대한 결과와 약한 비교 함수 결과와 강한 비교 함수 결과를 보여줍니다.

```text
   +========+========+===================+=================+
   | ETag 1 | ETag 2 | Strong Comparison | Weak Comparison |
   +========+========+===================+=================+
   | W/"1"  | W/"1"  | no match          | match           |
   +--------+--------+-------------------+-----------------+
   | W/"1"  | W/"2"  | no match          | no match        |
   +--------+--------+-------------------+-----------------+
   | W/"1"  | "1"    | no match          | match           |
   +--------+--------+-------------------+-----------------+
   | "1"    | "1"    | match             | match           |
   +--------+--------+-------------------+-----------------+

                            Table 3
```

---
##### **8.8.3.3.  Example: Entity Tags Varying on Content-Negotiated Resources**

콘텐츠 협상\(섹션 12\)이 적용되는 리소스와 GET 요청에 대한 응답으로 전송된 표현이 Accept-Encoding 요청 헤더 필드\(섹션 12.5.3\)에 따라 달라지는 경우를 생각해 보세요.

```text
   >> Request:

   GET /index HTTP/1.1
   Host: www.example.com
   Accept-Encoding: gzip
```

이 경우 응답은 gzip 콘텐츠 코딩을 사용할 수도 있고 사용하지 않을 수도 있습니다. 그렇지 않은 경우 응답은 다음과 같습니다.

```text
   >> Response:

   HTTP/1.1 200 OK
   Date: Fri, 26 Mar 2010 00:05:00 GMT
   ETag: "123-a"
   Content-Length: 70
   Vary: Accept-Encoding
   Content-Type: text/plain

   Hello World!
   Hello World!
   Hello World!
   Hello World!
   Hello World!
```

gzip 콘텐츠 코딩을 사용하는 대체 표현은 다음과 같습니다.

```text
   >> Response:

   HTTP/1.1 200 OK
   Date: Fri, 26 Mar 2010 00:05:00 GMT
   ETag: "123-b"
   Content-Length: 43
   Vary: Accept-Encoding
   Content-Type: text/plain
   Content-Encoding: gzip

   ...binary data...
```

- | \*참고:\* 콘텐츠 코딩은 표현의 속성입니다 | 데이터이므로 콘텐츠 인코딩을 위한 강력한 엔터티 태그 | 표현은 |의 엔터티 태그와 구별되어야 합니다. 잠재적인 충돌을 방지하기 위해 인코딩되지 않은 표현 | 캐시 업데이트 및 범위 요청. 대조적으로 전송 | 코딩\(\[HTTP/1.1\]의 섹션 7\)은 메시지 중에만 적용 | 전송되며 고유한 엔터티 태그가 생성되지 않습니다.

---
## **9.  Methods**
---
### **9.1.  Overview**

요청 메소드 토큰은 요청 의미 체계의 기본 소스입니다. 이는 클라이언트가 이 요청을 한 목적과 클라이언트가 성공적인 결과로 기대하는 바를 나타냅니다.

요청 메소드의 의미는 추가 의미가 메소드와 충돌하지 않는 경우 요청에 존재할 때 일부 헤더 필드의 의미에 의해 더욱 특수화될 수 있습니다. 예를 들어 클라이언트는 조건부 요청 헤더 필드\(13.1절\)를 보내 요청된 작업을 대상 리소스의 현재 상태에 따라 조건부로 만들 수 있습니다.

HTTP는 분산 객체 시스템에 대한 인터페이스로 사용할 수 있도록 설계되었습니다. 요청 메소드는 원격 메소드 호출이 식별된 객체에 전송될 수 있는 것과 거의 동일한 방식으로 대상 리소스에 적용될 작업을 호출합니다.

```text
     method = token
```

메소드 토큰은 메소드 이름이 대소문자를 구분하는 객체 기반 시스템에 대한 게이트웨이로 사용될 수 있으므로 대소문자를 구분합니다. 관례적으로 표준화된 방법은 모두 대문자 US-ASCII 문자로 정의됩니다.

분산 개체와 달리 HTTP의 표준화된 요청 방법은 리소스별로 다르지 않습니다. 왜냐하면 균일한 인터페이스가 네트워크 기반 시스템\[REST\]에서 더 나은 가시성과 재사용을 제공하기 때문입니다. 일단 정의되면 표준화된 방법은 모든 리소스에 적용될 때 동일한 의미를 가져야 하지만 각 리소스는 해당 의미가 구현되거나 허용되는지 여부를 자체적으로 결정합니다.

이 사양은 다음 표에 설명된 대로 HTTP에서 일반적으로 사용되는 여러 가지 표준화된 메서드를 정의합니다.

```text
   +=========+============================================+=========+
   | Method  | Description                                | Section |
   | Name    |                                            |         |
   +=========+============================================+=========+
   | GET     | Transfer a current representation of the   | 9.3.1   |
   |         | target resource.                           |         |
   +---------+--------------------------------------------+---------+
   | HEAD    | Same as GET, but do not transfer the       | 9.3.2   |
   |         | response content.                          |         |
   +---------+--------------------------------------------+---------+
   | POST    | Perform resource-specific processing on    | 9.3.3   |
   |         | the request content.                       |         |
   +---------+--------------------------------------------+---------+
   | PUT     | Replace all current representations of the | 9.3.4   |
   |         | target resource with the request content.  |         |
   +---------+--------------------------------------------+---------+
   | DELETE  | Remove all current representations of the  | 9.3.5   |
   |         | target resource.                           |         |
   +---------+--------------------------------------------+---------+
   | CONNECT | Establish a tunnel to the server           | 9.3.6   |
   |         | identified by the target resource.         |         |
   +---------+--------------------------------------------+---------+
   | OPTIONS | Describe the communication options for the | 9.3.7   |
   |         | target resource.                           |         |
   +---------+--------------------------------------------+---------+
   | TRACE   | Perform a message loop-back test along the | 9.3.8   |
   |         | path to the target resource.               |         |
   +---------+--------------------------------------------+---------+

                                Table 4
```

모든 범용 서버는 GET 및 HEAD 메소드를 지원해야 합니다. 다른 모든 방법은 선택사항입니다.

대상 리소스에서 허용하는 메서드 집합은 Allow 헤더 필드\(섹션 10.2.1\)에 나열될 수 있습니다. 그러나 허용되는 메서드 집합은 동적으로 변경될 수 있습니다. 인식되지 않거나 구현되지 않은 요청 방법을 수신한 원서버는 501\(구현되지 않음\) 상태 코드로 응답해야 합니다. 인식되고 구현되었지만 대상 리소스에 대해 허용되지 않는 요청 방법을 수신하는 원서버는 405\(허용되지 않는 방법\) 상태 코드로 응답해야 합니다\(SHOULD\).

이 사양의 범위를 벗어나는 추가 메서드는 HTTP에서 사용하도록 지정되었습니다. 이러한 모든 메서드는 섹션 16.1에 설명된 대로 "HTTP\(Hypertext Transfer Protocol\) 메서드 레지스트리" 내에 등록되어야 합니다.

---
### **9.2.  Common Method Properties**
---
#### **9.2.1.  Safe Methods**

정의된 의미 체계가 기본적으로 읽기 전용인 경우 요청 메서드는 "안전한" 것으로 간주됩니다. 즉, 클라이언트는 대상 리소스에 안전한 방법을 적용한 결과 원본 서버의 상태 변경을 요청하지도 예상하지도 않습니다. 마찬가지로, 안전한 방법을 합리적으로 사용한다고 해서 원본 서버에 피해나 재산 손실 또는 비정상적인 부담이 발생할 것으로 예상되지는 않습니다.

안전한 메서드에 대한 이러한 정의는 잠재적으로 해로울 수 있는 동작, 완전히 읽기 전용이 아니거나 안전한 메서드를 호출하는 동안 부작용을 일으키는 동작을 구현에 포함하는 것을 방지하지 않습니다. 그러나 중요한 것은 내담자가 그런 추가적인 행동을 요구한 것이 아니므로 그에 대해 책임을 질 수 없다는 점이다. 예를 들어 대부분의 서버는 방식에 관계없이 모든 응답이 완료될 때마다 로그 파일에 액세스하기 위해 요청 정보를 추가하며 이는 로그 저장소가 가득 차서 서버에 장애가 발생하더라도 안전한 것으로 간주됩니다. 마찬가지로, 웹에서 광고를 선택하여 시작된 안전한 요청은 광고 계정에 비용을 청구하는 부작용이 있는 경우가 많습니다.

본 사양에서 정의한 요청 메소드 중 GET, HEAD, OPTIONS, TRACE 메소드는 안전하다고 정의되어 있다.

안전한 방법과 안전하지 않은 방법을 구별하는 목적은 자동화된 검색 프로세스\(스파이더\)와 캐시 성능 최적화\(프리페칭\)가 해를 끼칠 염려 없이 작동하도록 하는 것입니다. 또한 사용자 에이전트는 잠재적으로 신뢰할 수 없는 콘텐츠를 처리할 때 안전하지 않은 방법의 자동화된 사용에 대해 적절한 제약 조건을 적용할 수 있습니다.

사용자 에이전트는 사용자에게 잠재적인 작업을 제시할 때 안전한 방법과 안전하지 않은 방법을 구별해야 합니다. 따라서 사용자는 요청되기 전에 안전하지 않은 작업을 인식할 수 있습니다.

대상 URI 내의 매개변수가 작업을 선택하는 효과를 갖도록 리소스가 구성되면 해당 작업이 요청 메서드 의미 체계와 일치하는지 확인하는 것은 리소스 소유자의 책임입니다. 예를 들어, 웹 기반 콘텐츠 편집 소프트웨어에서는 "page?do=delete"와 같은 쿼리 매개변수 내의 작업을 사용하는 것이 일반적입니다. 이러한 리소스의 목적이 안전하지 않은 작업을 수행하는 것이라면 리소스 소유자는 안전한 요청 방법을 사용하여 액세스할 때 해당 작업을 비활성화하거나 허용하지 않아야 합니다. 그렇게 하지 않으면 자동화된 프로세스가 링크 유지 관리, 미리 가져오기, 검색 색인 구축 등을 위해 모든 URI 참조에 대해 GET을 수행할 때 불행한 부작용이 발생합니다.

---
#### **9.2.2.  Idempotent Methods**

해당 메소드를 사용하는 여러 개의 동일한 요청이 서버에 의도한 효과가 단일 요청에 대한 효과와 동일한 경우 요청 메소드는 "멱등성"으로 간주됩니다. 본 사양에서 정의한 요청 방식 중 PUT, DELETE, safe 요청 방식은 멱등성을 갖는다.

안전의 정의와 마찬가지로 멱등성 속성은 사용자가 요청한 항목에만 적용됩니다. 서버는 자유롭게 각 요청을 별도로 기록하거나 개정 제어 기록을 유지하거나 각 멱등성 요청에 대해 기타 비멱등성 부작용을 구현할 수 있습니다.

멱등성 메서드는 클라이언트가 서버의 응답을 읽을 수 있기 전에 통신 오류가 발생하는 경우 요청이 자동으로 반복될 수 있다는 점에서 구별됩니다. 예를 들어 클라이언트가 PUT 요청을 보내고 응답이 수신되기 전에 기본 연결이 닫히면 클라이언트는 새 연결을 설정하고 멱등성 요청을 다시 시도할 수 있습니다. 요청을 반복하면 원래 요청이 성공하더라도 응답이 다를 수 있지만 의도한 것과 동일한 효과가 있다는 것을 알고 있습니다.

클라이언트는 메소드에 관계없이 요청 의미론이 실제로 멱등성을 갖는다는 것을 알 수 있는 수단이 없거나 원래 요청이 전혀 적용되지 않았음을 감지할 수 있는 수단이 없는 한 비멱등성 메소드로 요청을 자동으로 재시도해서는 안 됩니다.

예를 들어, 사용자 에이전트는 요청이 해당 리소스에 대해 안전하다는 것을 \(설계 또는 구성을 통해\) 알고 있는 경우 자동으로 POST 요청을 반복할 수 있습니다. 마찬가지로, 버전 제어 저장소에서 작동하도록 특별히 설계된 사용자 에이전트는 연결 실패 후 대상 리소스 개정을 확인하고 부분적으로 적용된 변경 사항을 되돌리거나 수정한 다음 자동으로 부분 실패 조건에서 복구할 수 있습니다. 실패한 요청을 다시 시도합니다.

일부 클라이언트는 더 위험한 접근 방식을 취하고 자동 재시도가 가능한 시기를 추측하려고 시도합니다. 예를 들어, 응답의 일부가 수신되기 전에 기본 전송 연결이 닫힌 경우, 특히 유휴 영구 연결이 사용된 경우 클라이언트는 자동으로 POST 요청을 재시도할 수 있습니다.

프록시는 멱등성이 아닌 요청을 자동으로 재시도해서는 안 됩니다. 클라이언트는 실패한 자동 재시도를 자동으로 재시도해서는 안 됩니다.

---
#### **9.2.3.  Methods and Caching**

캐시가 응답을 저장하고 사용하려면 연결된 메서드가 명시적으로 캐싱을 허용하고 후속 요청을 충족하기 위해 응답을 사용할 수 있는 조건을 자세히 설명해야 합니다. 그렇게 하지 않는 메서드 정의는 캐시될 수 없습니다. 추가 요구 사항은 \[캐싱\]을 참조하세요.

이 사양은 GET, HEAD 및 POST에 대한 캐싱 의미를 정의하지만 압도적인 대다수의 캐시 구현은 GET 및 HEAD만 지원합니다.

---
### **9.3.  Method Definitions**
---
#### **9.3.1.  GET**

GET 메소드는 대상 리소스에 대해 현재 선택된 표현의 전송을 요청합니다. 성공적인 응답은 대상 URI\(\[URI\]의 섹션 1.2.2\)로 식별된 "동일성"의 품질을 반영합니다. 따라서 HTTP를 통해 식별 가능한 정보를 검색하는 것은 일반적으로 200\(OK\) 응답에서 해당 정보를 제공할 가능성과 관련된 식별자에 대해 GET 요청을 수행하여 수행됩니다.

GET은 정보 검색의 기본 메커니즘이자 거의 모든 성능 최적화의 초점입니다. 각각의 중요한 리소스에 대한 URI를 생성하는 애플리케이션은 이러한 최적화의 이점을 누리는 동시에 다른 애플리케이션에서 이를 재사용할 수 있도록 하여 웹의 추가 확장을 촉진하는 네트워크 효과를 생성할 수 있습니다.

리소스 식별자를 원격 파일 시스템 경로 이름으로 생각하고 표현을 해당 파일 내용의 복사본으로 생각하기 쉽습니다. 실제로 이는 얼마나 많은 리소스가 구현되는지입니다\(관련 보안 고려 사항은 섹션 17.3 참조\). 그러나 실제로는 그러한 제한이 없습니다.

리소스에 대한 HTTP 인터페이스는 콘텐츠 개체 트리, 다양한 데이터베이스 레코드에 대한 프로그래밍 방식 보기 또는 다른 정보 시스템에 대한 게이트웨이로 구현될 가능성이 높습니다. URI 매핑 메커니즘이 파일 시스템에 연결되어 있는 경우에도 원본 서버는 파일을 직접 전송하는 대신 요청을 입력으로 사용하여 파일을 실행하고 출력을 표현으로 보내도록 구성될 수 있습니다. 그럼에도 불구하고, 원본 서버만이 각 리소스 식별자가 구현에 어떻게 대응하는지, 해당 구현이 대상 리소스의 현재 표현을 선택하고 보내는 방법을 알아야 합니다.

클라이언트는 요청에 Range 헤더 필드를 전송하여\(14.2절\) 선택한 표현의 일부만 전송하도록 요청하는 "범위 요청"으로 GET의 의미를 변경할 수 있습니다.

요청 메시지 프레이밍은 사용된 방법과 무관하지만 GET 요청에서 수신된 콘텐츠에는 일반적으로 정의된 의미 체계가 없으며 요청의 의미나 대상을 변경할 수 없으며 일부 구현에서는 잠재적인 문제로 인해 요청을 거부하고 연결을 닫을 수도 있습니다. 요청 밀수 공격\(\[HTTP/1.1\]의 섹션 11.2\). 클라이언트는 대역 내 또는 대역 외에서 해당 요청에 목적이 있고 적절하게 지원될 것임을 이전에 표시한 원서버에 직접 요청하지 않는 한 GET 요청에서 콘텐츠를 생성해서는 안 됩니다. 원본 서버는 콘텐츠 수신을 위해 개인 계약에 의존해서는 안 됩니다. HTTP 통신 참가자는 종종 요청 체인에 있는 중개자를 인식하지 못하기 때문입니다.

GET 요청에 대한 응답은 캐시 가능합니다. 캐시는 Cache-Control 헤더 필드\(\[CACHING\]의 섹션 5.2\)에 달리 표시되지 않는 한 후속 GET 및 HEAD 요청을 충족하기 위해 이를 사용할 수 있습니다.

GET을 사용하는 양식의 쿼리 필드와 같이 사용자 제공 정보에서 대상 URI를 구성하는 메커니즘을 사용하여 정보 검색을 수행하는 경우 URI 내 공개에 적합하지 않은 잠재적으로 민감한 데이터가 제공될 수 있습니다\(섹션 17.9 참조\). \). 어떤 경우에는 해당 정보가 공개되지 않도록 데이터를 필터링하거나 변환할 수 있습니다. 다른 경우, 특히 응답 캐싱의 이점이 없는 경우 GET 대신 POST 메서드\(9.3.3절\)를 사용하면 대상 URI가 아닌 요청 콘텐츠에 해당 정보를 전송할 수 있습니다.

---
#### **9.3.2.  HEAD**

HEAD 메소드는 서버가 응답으로 콘텐츠를 전송해서는 안 된다는 점을 제외하면 GET과 동일합니다. HEAD는 하이퍼텍스트 링크를 테스트하거나 최근 수정 사항을 찾기 위해 표현 데이터를 전송하지 않고 선택한 표현에 대한 메타데이터를 얻는 데 사용됩니다.

서버는 HEAD 요청에 대한 응답으로 요청 메소드가 GET인 경우 전송했을 것과 동일한 헤더 필드를 전송해야 합니다\(SHOULD\). 그러나 서버는 콘텐츠를 생성하는 동안에만 값이 결정되는 헤더 필드를 생략할 수 있습니다. 예를 들어, 일부 서버는 작은 응답을 보다 효율적으로 구분하거나 콘텐츠 선택과 관련하여 늦은 결정을 내릴 수 있도록 최소량의 데이터가 생성될 때까지 GET에 대한 동적 응답을 버퍼링합니다. GET에 대한 이러한 응답에는 HEAD 응답 내에서 생성되지 않는 Content-Length 및 Vary 필드가 포함될 수 있습니다. HEAD는 일반적으로 효율성을 위해 요청되므로 이러한 사소한 불일치는 HEAD 요청에 대한 콘텐츠를 생성하고 삭제하는 것보다 선호되는 것으로 간주됩니다.

요청 메시지 프레이밍은 사용된 방법과 무관하지만 HEAD 요청에서 수신된 콘텐츠에는 일반적으로 정의된 의미가 없으며 요청의 의미나 대상을 변경할 수 없으며 일부 구현에서 요청을 거부하고 연결을 닫을 수 있습니다. 요청 밀수 공격\(\[HTTP/1.1\]의 섹션 11.2\). 클라이언트는 대역 내 또는 대역 외에서 해당 요청에 목적이 있고 적절하게 지원될 것임을 이전에 표시한 원서버에 직접 요청하지 않는 한 HEAD 요청에서 콘텐츠를 생성해서는 안 됩니다. 원본 서버는 콘텐츠 수신을 위해 개인 계약에 의존해서는 안 됩니다. HTTP 통신 참가자는 종종 요청 체인에 있는 중개자를 인식하지 못하기 때문입니다.

HEAD 요청에 대한 응답은 캐시 가능합니다. 캐시는 Cache-Control 헤더 필드\(\[CACHING\]의 섹션 5HEAD 요청에 대한 응답은 캐시 가능합니다. 캐시는 Cache-Control 헤더 필드\(\[CACHING\]의 섹션 5.2\)에 달리 표시되지 않는 한 후속 HEAD 요청을 만족시키기 위해 이를 사용할 수 있습니다. HEAD 응답은 이전에 캐시된 GET 응답에도 영향을 미칠 수 있습니다. \[CACHING\]의 섹션 4.3.5를 참조하세요.

---
#### **9.3.3.  POST**

POST 메서드는 대상 리소스가 리소스 고유의 특정 의미에 따라 요청에 포함된 표현을 처리하도록 요청합니다. 예를 들어 POST는 다음 기능에 사용됩니다.

\* HTML 양식에 입력된 필드와 같은 데이터 블록을 데이터 처리 프로세스에 제공합니다.

\* 게시판, 뉴스그룹, 메일링 리스트, 블로그 또는 유사한 기사 그룹에 메시지를 게시하는 행위

\* 아직 원본 서버에서 식별되지 않은 새로운 리소스를 생성합니다. 그리고

\* 자원의 기존 표현에 데이터를 추가합니다.

원서버는 POST 요청 처리 결과에 따라 적절한 상태 코드를 선택하여 응답 의미를 나타냅니다. 이 사양에 정의된 거의 모든 상태 코드는 POST에 대한 응답으로 수신될 수 있습니다\(예외: 206\(부분 콘텐츠\), 304\(수정되지 않음\) 및 416\(범위가 만족스럽지 않음\)\).

POST 요청을 성공적으로 처리한 결과 원서버에 하나 이상의 리소스가 생성된 경우 원서버는 생성된 기본 리소스에 대한 식별자를 제공하는 Location 헤더 필드가 포함된 201\(Created\) 응답을 보내야 합니다\(10.2절\). .2\) 및 새 리소스를 참조하면서 요청 상태를 설명하는 표현입니다.

POST 요청에 대한 응답은 명시적인 신선도 정보\(\[CACHING\]의 섹션 4.2.1 참조\)와 POST의 대상 URI\(섹션 8.7\)와 동일한 값을 갖는 Content-Location 헤더 필드를 포함하는 경우에만 캐시할 수 있습니다. 캐시된 POST 응답은 나중에 GET 또는 HEAD 요청을 충족하기 위해 재사용될 수 있습니다. 대조적으로, POST는 잠재적으로 안전하지 않기 때문에 POST 요청은 캐시된 POST 응답으로 충족될 수 없습니다. \[캐싱\]의 섹션 4를 참조하세요.

POST 처리 결과가 기존 리소스의 표현과 동일할 경우 원서버는 Location 필드에 기존 리소스 식별자가 포함된 303\(See Other\) 응답을 전송하여 사용자 에이전트를 해당 리소스로 리디렉션할 수 있습니다\(MAY\). 이는 사용자 에이전트에 리소스 식별자를 제공하고 공유 캐싱에 더 적합한 방법을 통해 표현을 전송하는 이점이 있지만 사용자 에이전트에 아직 캐시된 표현이 없는 경우 추가 요청이 필요합니다.

---
#### **9.3.4.  PUT**

PUT 메서드는 대상 리소스의 상태가 생성되거나 요청 메시지 내용에 포함된 표현으로 정의된 상태로 대체되도록 요청합니다. 주어진 표현의 성공적인 PUT은 동일한 대상 리소스에 대한 후속 GET이 200\(OK\) 응답으로 전송되는 동등한 표현을 초래할 것임을 제안합니다. 그러나 후속 GET이 수신되기 전에 대상 리소스가 다른 사용자 에이전트에 의해 병렬로 작동되거나 원본 서버에 의해 동적 처리될 수 있으므로 이러한 상태 변경이 관찰 가능하다는 보장은 없습니다. 성공적인 응답은 원서버가 처리할 때 사용자 에이전트의 의도가 달성되었음을 의미합니다.

대상 리소스에 현재 표현이 없고 PUT가 성공적으로 표현을 생성한 경우 원서버는 201\(생성됨\) 응답을 전송하여 사용자 에이전트에 알려야 합니다. 대상 리소스에 현재 표현이 있고 해당 표현이 포함된 표현의 상태에 따라 성공적으로 수정된 경우 원서버는 성공적인 완료를 나타내기 위해 200\(OK\) 또는 204\(No Content\) 응답을 보내야 합니다. 요청.

원본 서버는 PUT 표현이 대상 리소스에 대해 구성된 제약 조건과 일치하는지 확인해야 합니다\(SHOULD\). 예를 들어 원서버가 URI를 기반으로 리소스의 표현 메타데이터를 결정하는 경우 원서버는 성공적인 PUT 요청에서 수신된 콘텐츠가 해당 메타데이터와 일치하는지 확인해야 합니다. PUT 표현이 대상 리소스와 일치하지 않는 경우 원서버는 표현을 변환하거나 리소스 구성을 변경하여 이를 일관되게 만들거나 표현이 부적합한 이유를 설명하기에 충분한 정보가 포함된 적절한 오류 메시지로 응답해야 합니다. 409\(충돌\) 또는 415\(지원되지 않는 미디어 유형\) 상태 코드가 제안되며, 후자는 Content-Type 값에 대한 제약 조건과 관련이 있습니다.

예를 들어 대상 리소스가 항상 "text/html"의 Content-Type을 갖도록 구성되고 PUT 표현의 Content-Type이 "image/jpeg"인 경우 원본 서버는 다음 중 하나를 수행해야 합니다.

1. 새로운 미디어 유형을 반영하도록 대상 리소스를 재구성합니다.

1. PUT 표현을 새로운 리소스 상태로 저장하기 전에 리소스의 표현과 일치하는 형식으로 변환합니다. 또는,

1. 대상 리소스가 "text/html"로 제한되어 있음을 나타내는 415\(지원되지 않는 미디어 유형\) 응답으로 요청을 거부합니다. 아마도 새 표현에 적합한 대상이 될 다른 리소스에 대한 링크가 포함될 수 있습니다.

HTTP는 사용자 에이전트 요청의 의도와 원서버 응답의 의미로 표현할 수 있는 것 이상으로 PUT 메서드가 원서버의 상태에 어떻게 영향을 미치는지 정확히 정의하지 않습니다. 어떤 의미에서든 HTTP를 통해 제공되는 인터페이스를 넘어서는 리소스가 무엇인지 정의하지 않습니다. 리소스 상태가 어떻게 "저장"되는지, 리소스 상태 변경으로 인해 이러한 저장소가 어떻게 변경될 수 있는지, 원본 서버가 리소스 상태를 표현으로 변환하는 방법을 정의하지 않습니다. 일반적으로 리소스 인터페이스 뒤의 모든 구현 세부 사항은 서버에 의해 의도적으로 숨겨집니다.

이는 헤더 및 트레일러 필드가 저장되는 방식까지 확장됩니다. Content-Type과 같은 공통 헤더 필드는 일반적으로 후속 GET 요청 시 저장되고 반환되지만 헤더 및 트레일러 필드 처리는 요청을 수신한 리소스에 따라 다릅니다. 결과적으로 원서버는 PUT 요청에서 수신된 인식되지 않은 헤더 및 트레일러 필드를 무시해야 합니다\(즉, 리소스 상태의 일부로 저장하면 안 됩니다\).

요청의 표현 데이터가 콘텐츠\(즉, 리소스의 새로운 표현 데이터는 PUT 요청에서 수신된 콘텐츠와 동일하며 유효성 검사기 필드 값은 새로운 표현을 반영합니다. 이 요구 사항을 통해 사용자 에이전트는 보낸 표현\(및 메모리에 유지하는\)이 언제 PUT의 결과인지 알 수 있으므로 원본 서버에서 다시 검색할 필요가 없습니다. 실수로 덮어쓰는 것을 방지하기 위해 응답으로 수신된 새 유효성 검사기를 향후 조건부 요청에 사용할 수 있습니다\(13.1절\).

POST와 PUT 메소드 간의 근본적인 차이점은 포함된 표현의 의도가 다르기 때문에 강조됩니다. POST 요청의 대상 리소스는 리소스 자체 의미에 따라 포함된 표현을 처리하기 위한 반면, PUT 요청의 포함된 표현은 대상 리소스의 상태를 대체하는 것으로 정의됩니다. 따라서 PUT의 의도는 멱등성이 있고 중개자에게 표시됩니다. 비록 정확한 효과는 원본 서버에서만 알 수 있습니다.

PUT 요청을 올바르게 해석하려면 사용자 에이전트가 어떤 대상 리소스가 필요한지 알고 있다고 가정합니다. 상태 변경 요청을 수신한 후 클라이언트를 대신하여 적절한 URI를 선택하는 서비스는 PUT가 아닌 POST 메서드를 사용하여 구현되어야 합니다. 원서버가 요청된 PUT 상태를 대상 리소스로 변경하지 않고 대신 리소스가 다른 URI로 이동된 경우와 같이 다른 리소스에 적용하기를 원하는 경우 원서버는 적절한 3xx를 보내야 합니다. \(리디렉션\) 응답; 그런 다음 사용자 에이전트는 요청을 리디렉션할지 여부를 자체적으로 결정할 수 있습니다.

대상 리소스에 적용된 PUT 요청은 다른 리소스에 부작용을 일으킬 수 있습니다. 예를 들어 기사에는 각 특정 버전\(한 지점에서 현재 버전 리소스와 동일한 상태를 공유한 다양한 리소스\)을 식별하는 URI와 별개인 "현재 버전"\(리소스\)을 식별하기 위한 URI가 있을 수 있습니다. 따라서 "현재 버전" URI에 대한 PUT 요청이 성공하면 대상 리소스의 상태를 변경하는 것 외에도 새 버전 리소스가 생성될 수 있으며 관련 리소스 간에 링크가 추가될 수도 있습니다.

일부 원본 서버는 섹션 14.5에 설명된 대로 부분 PUT를 수행하기 위한 요청 수정자로 Content-Range 헤더 필드\(섹션 14.4\)의 사용을 지원합니다.

PUT 메서드에 대한 응답은 캐시할 수 없습니다. 성공적인 PUT 요청이 대상 URI에 대해 하나 이상의 저장된 응답이 있는 캐시를 통과하는 경우 해당 저장된 응답은 무효화됩니다\(\[CACHING\]의 섹션 4.4 참조\).

---
#### **9.3.5.  DELETE**

DELETE 메소드는 원본 서버가 대상 리소스와 현재 기능 간의 연결을 제거하도록 요청합니다. 실제로 이 방법은 UNIX의 "rm" 명령과 유사합니다. 즉, 이전에 연관된 정보가 삭제된다는 기대보다는 원본 서버의 URI 매핑에 대한 삭제 작업을 표현합니다.

대상 리소스에 하나 이상의 현재 표현이 있는 경우 해당 표현은 원서버에 의해 파기되거나 삭제되지 않을 수 있으며, 관련 저장소는 리소스의 성격과 원서버에 의한 구현에 전적으로 따라 회수될 수도 있고 그렇지 않을 수도 있습니다\( 이는 이 사양의 범위를 벗어납니다.\) 마찬가지로 데이터베이스 또는 게이트웨이 연결과 같은 DELETE의 결과로 리소스의 다른 구현 측면을 비활성화하거나 보관해야 할 수도 있습니다. 일반적으로 원본 서버는 삭제를 수행하기 위해 규정된 메커니즘이 있는 리소스에 대해서만 DELETE를 허용한다고 가정합니다.

DELETE 메소드를 허용하는 리소스는 상대적으로 적습니다. 이 메소드의 주요 용도는 사용자가 그 효과에 대해 특정 방향을 갖는 원격 저작 환경입니다. 예를 들어 이전에 PUT 요청을 사용하여 생성되었거나 POST 요청에 대한 201\(Created\) 응답 후 Location 헤더 필드를 통해 식별된 리소스는 해당 DELETE 요청이 해당 작업을 취소하도록 허용할 수 있습니다. 마찬가지로 원격 작업을 위해 HTTP를 사용하는 개정 제어 클라이언트와 같은 저작 기능을 구현하는 사용자 지정 사용자 에이전트 구현에서는 서버의 URI 공간이 버전 저장소에 해당하도록 제작되었다는 가정에 따라 DELETE를 사용할 수 있습니다.

DELETE 메소드가 성공적으로 적용되면 원서버는 전송해야 합니다.

\* 작업이 성공할 가능성이 있지만 아직 실행되지 않은 경우 202\(수락됨\) 상태 코드,

\* 작업이 실행되었고 추가 정보가 제공되지 않는 경우 204\(콘텐츠 없음\) 상태 코드, 또는

\* 작업이 실행되고 응답 메시지에 상태를 설명하는 표현이 포함된 경우 200\(OK\) 상태 코드입니다.

요청 메시지 프레이밍은 사용된 방법과 무관하지만 DELETE 요청에서 수신된 콘텐츠에는 일반적으로 정의된 의미 체계가 없으며 요청의 의미나 대상을 변경할 수 없으며 일부 구현에서 요청을 거부하고 연결을 닫을 수 있습니다. 요청 밀수 공격\(\[HTTP/1.1\]의 섹션 11.2\). 클라이언트는 DELETE 요청에 목적이 있고 적절하게 지원될 것임을 대역 내 또는 대역 외에서 이전에 표시한 원서버에 직접 요청하지 않는 한 DELETE 요청에서 콘텐츠를 생성해서는 안 됩니다. 원본 서버는 콘텐츠 수신을 위해 개인 계약에 의존해서는 안 됩니다. HTTP 통신 참가자는 종종 요청 체인에 있는 중개자를 인식하지 못하기 때문입니다.

DELETE 메소드에 대한 응답은 캐시할 수 없습니다. 성공적인 DELETE 요청이 대상 URI에 대해 하나 이상의 저장된 응답이 있는 캐시를 통과하는 경우 해당 저장된 응답은 무효화됩니다\(\[CACHING\]의 섹션 4.4 참조\).

---
#### **9.3.6.  CONNECT**

CONNECT 메소드는 수신자가 요청 대상에 의해 식별된 대상 원본 서버에 대한 터널을 설정하도록 요청하고, 성공하면 이후 터널이 닫힐 때까지 양방향으로 데이터를 블라인드 전달하도록 동작을 제한합니다. 터널은 일반적으로 하나 이상의 프록시를 통해 엔드투엔드 가상 연결을 생성하는 데 사용되며, 이는 TLS\(전송 계층 보안, \[TLS13\]\)를 사용하여 보호될 수 있습니다.

CONNECT는 콜론으로 구분된 터널 대상의 호스트 및 포트 번호로만 구성된 이 방법에 고유한 특수한 형태의 요청 대상을 사용합니다. 기본 포트는 없습니다. 클라이언트는 CONNECT 요청이 생략된 포트가 있는 권한 구성 요소를 포함하는 URI 참조를 기반으로 하는 경우에도 포트 번호를 보내야 합니다\(섹션 4.1\). 예를 들어,

```text
   CONNECT server.example.com:80 HTTP/1.1
   Host: server.example.com
```

서버는 일반적으로 400\(잘못된 요청\) 상태 코드로 응답하여 비어 있거나 유효하지 않은 포트 번호를 대상으로 하는 CONNECT 요청을 거부해야 합니다.

CONNECT는 HTTP 연결의 요청/응답 특성을 변경하기 때문에 특정 HTTP 버전에는 의미 체계를 프로토콜의 연결 형식으로 매핑하는 다양한 방법이 있을 수 있습니다.

CONNECT는 프록시에 대한 요청에 사용하기 위한 것입니다. 수신자는 요청 대상으로 식별된 서버에 직접 연결하거나, 다른 프록시를 사용하도록 구성된 경우 CONNECT 요청을 다음 인바운드 프록시로 전달하여 터널을 설정할 수 있습니다. 원서버는 CONNECT 요청을 수락할 수 있지만 대부분의 원서버는 CONNECT를 구현하지 않습니다.

2xx\(성공\) 응답은 발신자\(및 모든 인바운드 프록시\)가 응답 헤더 섹션 직후에 터널 모드로 전환함을 나타냅니다. 해당 헤더 섹션 이후에 수신된 데이터는 요청 대상에 의해 식별된 서버에서 온 것입니다. 성공적인 응답 이외의 응답은 터널이 아직 형성되지 않았음을 나타냅니다.

터널 중개자는 한쪽이 연결을 닫았음을 감지하면 터널이 닫힙니다. 중개자는 닫힌 쪽에서 다른 쪽으로 온 미해결 데이터를 전송하려고 시도하고 두 연결을 모두 닫은 다음 전달되지 않은 나머지 데이터를 삭제해야 합니다.

프록시 인증을 사용하여 터널을 생성할 수 있는 권한을 설정할 수 있습니다. 예를 들어,

```text
   CONNECT server.example.com:443 HTTP/1.1
   Host: server.example.com:443
   Proxy-Authorization: basic aGVsbG86d29ybGQ=
```

임의의 서버에 대한 터널을 설정하는 데는 상당한 위험이 있습니다. 특히 대상이 웹 트래픽용이 아닌 잘 알려져 있거나 예약된 TCP 포트인 경우 더욱 그렇습니다. 예를 들어 "example.com:25"에 대한 CONNECT는 프록시가 SMTP 트래픽용으로 예약된 포트에 연결하도록 제안합니다. 허용되는 경우 프록시를 속여 스팸 이메일을 전달하도록 할 수 있습니다. CONNECT를 지원하는 프록시는 알려진 포트의 제한된 집합이나 구성 가능한 안전한 요청 대상 목록으로 사용을 제한해야 합니다.

서버는 CONNECT에 대한 2xx\(성공\) 응답으로 Transfer-Encoding 또는 Content-Length 헤더 필드를 전송해서는 안 됩니다. 클라이언트는 CONNECT에 대한 성공적인 응답으로 수신된 모든 Content-Length 또는 Transfer-Encoding 헤더 필드를 무시해야 합니다.

CONNECT 요청 메시지에는 콘텐츠가 없습니다. CONNECT 요청 메시지의 헤더 섹션 이후에 전송된 데이터의 해석은 사용 중인 HTTP 버전에 따라 다릅니다.

CONNECT 메소드에 대한 응답은 캐시할 수 없습니다.

---
#### **9.3.7.  OPTIONS**

OPTIONS 메소드는 원본 서버 또는 중간 중개자에서 대상 리소스에 사용 가능한 통신 옵션에 대한 정보를 요청합니다. 이 방법을 사용하면 클라이언트는 리소스 작업을 암시하지 않고 리소스 또는 서버 기능과 관련된 옵션 및/또는 요구 사항을 결정할 수 있습니다.

요청 대상\(7.1절\)으로 별표\("\*"\)가 있는 OPTIONS 요청은 특정 리소스가 아닌 일반적으로 서버에 적용됩니다. 서버의 통신 옵션은 일반적으로 리소스에 따라 달라지므로 "\*" 요청은 "ping" 또는 "no-op" 유형의 방법으로만 유용합니다. 클라이언트가 서버의 기능을 테스트하도록 허용하는 것 외에는 아무 것도 수행하지 않습니다. 예를 들어, 이는 프록시의 HTTP/1.1 적합성\(또는 적합성 부족\)을 테스트하는 데 사용될 수 있습니다.

요청 대상이 별표가 아닌 경우 OPTIONS 요청은 대상 리소스와 통신할 때 사용할 수 있는 옵션에 적용됩니다.

OPTIONS에 대한 성공적인 응답을 생성하는 서버는 이 사양에서 정의되지 않은 잠재적 확장을 포함하여 서버에서 구현하고 대상 리소스에 적용할 수 있는 선택적 기능\(예: 허용\)을 나타낼 수 있는 모든 헤더를 보내야 합니다. 응답 콘텐츠가 있는 경우 기계 또는 사람이 읽을 수 있는 표현으로 통신 옵션을 설명할 수도 있습니다. 이러한 표현에 대한 표준 형식은 이 사양에 의해 정의되지 않지만 향후 HTTP 확장에 의해 정의될 수 있습니다.

클라이언트는 요청 체인의 특정 수신자를 대상으로 OPTIONS 요청에 Max-Forwards 헤더 필드를 보낼 수 있습니다\(섹션 7.6.2 참조\). 요청이 Max-Forwards 필드와 함께 수신되지 않는 한 프록시는 요청을 전달하는 동안 Max-Forwards 헤더 필드를 생성해서는 안 됩니다.

콘텐츠가 포함된 OPTIONS 요청을 생성하는 클라이언트는 표현 미디어 유형을 설명하는 유효한 Content-Type 헤더 필드를 보내야 합니다. 이 사양은 그러한 콘텐츠의 용도를 정의하지 않습니다.

OPTIONS 메서드에 대한 응답은 캐시할 수 없습니다.

---
#### **9.3.8.  TRACE**

TRACE 메소드는 요청 메시지의 원격 애플리케이션 수준 루프백을 요청합니다. 요청의 최종 수신자는 아래 설명된 일부 필드를 제외하고 수신된 메시지를 200\(OK\) 응답의 내용으로 클라이언트에 다시 반영해야 합니다. "message/http" 형식\(\[HTTP/1.1\]의 섹션 10.1\)은 이를 수행하는 한 가지 방법입니다. 최종 수신자는 원본 서버이거나 요청에서 Max-Forwards 값 0\(7.6.2절\)을 수신한 첫 번째 서버입니다.

클라이언트는 응답에 의해 공개될 수 있는 민감한 데이터가 포함된 TRACE 요청의 필드를 생성해서는 안 됩니다. 예를 들어 사용자 에이전트가 TRACE 요청에 저장된 사용자 자격 증명\(섹션 11\) 또는 쿠키 \[COOKIE\]를 보내는 것은 어리석은 일입니다. 요청의 최종 수신자는 응답 콘텐츠를 생성할 때 민감한 데이터를 포함할 가능성이 있는 모든 요청 필드를 제외해야 합니다\(SHOULD\).

TRACE를 통해 클라이언트는 요청 체인의 다른 쪽 끝에서 수신되는 내용을 확인하고 해당 데이터를 테스트 또는 진단 정보에 사용할 수 있습니다. Via 헤더 필드\(섹션 7.6.3\)의 값은 요청 체인의 추적 역할을 하기 때문에 특히 중요합니다. Max-Forwards 헤더 필드를 사용하면 클라이언트가 요청 체인의 길이를 제한할 수 있으며, 이는 무한 루프에서 메시지를 전달하는 프록시 체인을 테스트하는 데 유용합니다.

클라이언트는 TRACE 요청에 콘텐츠를 보내면 안 됩니다.

TRACE 메소드에 대한 응답은 캐시할 수 없습니다.

---
## **10.  Message Context**
---
### **10.1.  Request Context Fields**

아래 요청 헤더 필드는 요청 뒤의 사용자, 사용자 에이전트 및 리소스에 대한 정보를 포함하여 요청 컨텍스트에 대한 추가 정보를 제공합니다.

---
#### **10.1.1.  Expect**

요청의 "Expect" 헤더 필드는 이 요청을 적절하게 처리하기 위해 서버에서 지원해야 하는 특정 동작\(기대\) 집합을 나타냅니다.

```text
     Expect =      #expectation
     expectation = token [ "=" ( token / quoted-string ) parameters ]
```

Expect 필드 값은 대소문자를 구분하지 않습니다.

이 사양에 정의된 유일한 기대치는 "100-continue"\(정의된 매개변수 없음\)입니다.

100-continue 이외의 멤버가 포함된 Expect 필드 값을 수신한 서버는 417\(Expectation Failed\) 상태 코드로 응답하여 예상치 못한 기대치를 충족할 수 없음을 나타낼 수 있습니다.

"100-continue" 기대는 클라이언트가 이 요청에서 \(대규모로 추정되는\) 콘텐츠를 보내려고 하고 메서드, 대상 URI 및 헤더 필드가 충분하지 않은 경우 100\(Continue\) 중간 응답을 받기를 원한다는 것을 수신자에게 알립니다. 즉각적인 성공, 리디렉션 또는 오류 응답. 이를 통해 클라이언트는 실제로 콘텐츠를 보내기 전에 콘텐츠를 보낼 가치가 있다는 표시를 기다릴 수 있습니다. 이는 데이터가 방대하거나 클라이언트가 오류가 발생할 가능성이 있다고 예상할 때\(예: 상태 변경 메시지를 보낼 때\) 효율성을 향상할 수 있습니다. 이전에 검증된 인증 자격 증명 없이 처음으로 방법을 사용합니다\).

예를 들어 다음으로 시작하는 요청은

```text
   PUT /somewhere/fun HTTP/1.1
   Host: origin.example.com
   Content-Type: video/h264
   Content-Length: 1234567890987
   Expect: 100-continue
```

클라이언트가 불필요한 데이터 전송으로 파이프를 채우기 시작하기 전에 원본 서버가 401\(인증되지 않음\) 또는 405\(메소드 허용되지 않음\)과 같은 오류 메시지로 즉시 응답할 수 있습니다.

클라이언트 요구 사항:

\* 클라이언트는 콘텐츠가 포함되지 않은 요청에서 100-continue 기대치를 생성해서는 안 됩니다.

\* 요청 콘텐츠를 보내기 전에 100\(Continue\) 응답을 기다리는 클라이언트는 100-continue 기대치를 포함하는 Expect 헤더 필드를 보내야 합니다.

\* 100 연속 기대치를 보내는 클라이언트는 특정 시간 동안 기다릴 필요가 없습니다. 그러한 클라이언트는 아직 응답을 받지 못한 경우에도 콘텐츠 전송을 계속할 수 있습니다. 또한 100\(계속\) 응답은 HTTP/1.0 중개자를 통해 전송할 수 없으므로 이러한 클라이언트는 콘텐츠를 전송하기 전에 무기한 대기해서는 안 됩니다.

\* 100 연속 기대치를 포함하는 요청에 대한 응답으로 417\(예상 실패\) 상태 코드를 수신하는 클라이언트는 100 연속 기대 없이 해당 요청을 반복해야 합니다. 417 응답은 단지 응답 체인이 기대치를 지원하지 않는다는 것을 나타낼 뿐이기 때문입니다\( 예를 들어 HTTP/1.0 서버를 통과합니다.

서버 요구 사항:

\* HTTP/1.0 요청에서 100-continue 기대치를 수신하는 서버는 해당 기대치를 무시해야 합니다.

\* 서버는 해당 요청에 대한 콘텐츠의 일부 또는 전부를 이미 수신했거나 프레이밍에 콘텐츠가 없음을 나타내는 경우 100\(계속\) 응답 전송을 생략할 수 있습니다.

\* 100\(계속\) 응답을 보내는 서버는 연결이 조기에 종료되지 않는 한 요청 콘텐츠를 수신하고 처리한 후 궁극적으로 최종 상태 코드를 보내야 합니다.

\* 전체 요청 콘텐츠를 읽기 전에 최종 상태 코드로 응답하는 서버는 연결을 닫을 것인지\(예: \[HTTP/1.1\]의 섹션 9.6 참조\) 요청 콘텐츠를 계속 읽을 것인지 여부를 나타내야 합니다.

메서드, 대상 URI, 100 연속 예상 및 요청 콘텐츠가 뒤따를 것이라는 표시를 포함하는 전체 헤더 섹션이 있는 HTTP/1.1\(또는 그 이상\) 요청을 수신하면 원서버는 다음 중 하나를 보내야 합니다.

\* 메소드, 대상 URI 및 헤더 필드만 검사하여 해당 상태를 확인할 수 있는 경우 최종 상태 코드가 포함된 즉각적인 응답, 또는

\* 클라이언트가 요청 콘텐츠를 보내도록 권장하는 즉각적인 100\(계속\) 응답입니다.

원본 서버는 100\(계속\) 응답을 보내기 전에 콘텐츠를 기다려서는 안 됩니다.

메서드, 대상 URI 및 100 연속 기대치를 포함하고 요청 콘텐츠가 따를 것임을 나타내는 전체 헤더 섹션이 있는 HTTP/1.1\(또는 그 이상\) 요청을 수신하면 프록시는 다음 중 하나를 수행해야 합니다.

\* 메소드, 대상 URI 및 헤더 필드만 검사하여 해당 상태를 확인할 수 있는 경우 최종 상태 코드와 함께 즉각적인 응답을 보냅니다.

\* 해당 요청 라인과 헤더 섹션을 다음 인바운드 서버로 전송하여 요청을 원본 서버로 전달합니다.

프록시가 \(구성 또는 과거 상호 작용을 통해\) 다음 인바운드 서버가 HTTP/1.0만 지원한다고 믿는 경우, 프록시는 클라이언트가 콘텐츠 전송을 시작하도록 권장하기 위해 즉시 100\(계속\) 응답을 생성할 수 있습니다.

---
#### **10.1.2.  From**

"From" 헤더 필드에는 요청하는 사용자 에이전트를 제어하는 ​​인간 사용자의 인터넷 이메일 주소가 포함되어 있습니다. 주소는 \[RFC5322\] 섹션 3.4의 "사서함"에 정의된 대로 컴퓨터에서 사용할 수 있어야 합니다.

```text
     From    = mailbox

     mailbox = <mailbox, see [RFC5322], Section 3.4>
```

예는 다음과 같습니다:

```text
   From: spider-admin@example.org
```

From 헤더 필드는 로봇이 아닌 사용자 에이전트에서는 거의 전송되지 않습니다. 사용자 에이전트는 사용자의 명시적인 구성 없이 From 헤더 필드를 전송해서는 안 됩니다. 이는 사용자의 개인 정보 보호 이익이나 해당 사이트의 보안 정책과 충돌할 수 있기 때문입니다.

로봇 사용자 에이전트는 로봇이 과도하거나 원치 않거나 유효하지 않은 요청을 보내는 경우와 같이 서버에서 문제가 발생하는 경우 로봇 실행 담당자에게 연락할 수 있도록 유효한 From 헤더 필드를 보내야 합니다.

서버는 액세스 제어 또는 인증을 위해 From 헤더 필드를 사용해서는 안 됩니다. 그 값은 요청을 수신하거나 관찰하는 모든 사람에게 표시될 것으로 예상되고 개인 정보 보호를 기대하지 않고 로그 파일 및 오류 보고서 내에 기록되는 경우가 많기 때문입니다.

---
#### **10.1.3.  Referer**

"Referer" \[sic\] 헤더 필드를 사용하면 사용자 에이전트는 대상 URI를 얻은 리소스에 대한 URI 참조를 지정할 수 있습니다\(즉, 필드 이름의 철자가 틀리더라도 "referrer"\). 사용자 에이전트는 Referer 필드 값을 생성할 때 URI 참조 \[URI\]의 조각 및 userinfo 구성 요소를 포함해서는 안 됩니다.

```text
     Referer = absolute-URI / partial-URI
```

필드 값은 절대 URI 또는 ​​부분 URI입니다. 후자의 경우\(섹션 4\), 참조된 URI는 대상 URI\(\[URI\], 섹션 5\)를 기준으로 합니다.

Referer 헤더 필드를 사용하면 서버가 간단한 분석, 로깅, 최적화된 캐싱 등을 위해 다른 리소스에 대한 백링크를 생성할 수 있습니다. 또한 유지 관리를 위해 더 이상 사용되지 않거나 잘못 입력된 링크를 찾을 수 있습니다. 일부 서버는 다른 사이트의 링크를 거부하거나\(소위 "딥 링크"\) 사이트 간 요청 위조\(CSRF\)를 제한하는 수단으로 Referer 헤더 필드를 사용하지만 모든 요청에 ​​이를 포함하는 것은 아닙니다.

```text
   Example:

   Referer: http://www.example.org/hypertext/Overview.html
```

대상 URI가 자체 URI\(예: 사용자 키보드의 입력 또는 사용자 북마크/즐겨찾기 내의 항목\)가 없는 소스에서 획득된 경우 사용자 에이전트는 Referer 헤더 필드를 제외하거나 다음과 함께 보내야 합니다. "about:blank" 값입니다.

Referer 헤더 필드 값은 참조 리소스의 전체 URI를 전달할 필요가 없습니다. 사용자 에이전트는 참조 원본 이외의 부분을 잘라낼 수 있습니다.

Referer 헤더 필드에는 사용자의 요청 컨텍스트 또는 검색 기록에 대한 정보가 공개될 수 있습니다. 이는 참조 리소스의 식별자가 개인 정보\(예: 계정 이름\) 또는 기밀로 간주되는 리소스를 공개하는 경우 개인정보 보호 문제가 될 수 있습니다. \(예: 방화벽 뒤 또는 보안 서비스 내부\) 대부분의 범용 사용자 에이전트는 참조 리소스가 로컬 "파일" 또는 "데이터" URI인 경우 Referer 헤더 필드를 보내지 않습니다. 사용자 에이전트는 참조 리소스가 보안 프로토콜을 통해 액세스되었고 요청 대상이 참조 리소스와 다른 출처를 가지고 있는 경우 참조 리소스가 명시적으로 Referer 전송을 허용하지 않는 한 Referer 헤더 필드를 보내서는 안 됩니다. 사용자 에이전트는 참조 리소스가 보안 프로토콜을 통해 액세스된 경우 보안되지 않은 HTTP 요청에서 Referer 헤더 필드를 전송해서는 안 됩니다. 추가 보안 고려 사항은 섹션 17.9를 참조하세요.

일부 중개자는 나가는 요청에서 Referer 헤더 필드를 무차별적으로 제거하는 것으로 알려져 있습니다. 이는 CSRF 공격에 대한 보호를 방해하는 불행한 부작용을 가져오며, 이는 사용자에게 훨씬 더 해로울 수 있습니다. Referer의 정보 공개를 제한하려는 중개자 및 사용자 에이전트 확장은 내부 도메인 이름을 가명으로 바꾸거나 쿼리 및/또는 경로 구성 요소를 자르는 등 특정 편집으로 변경을 제한해야 합니다. 필드 값이 대상 URI와 동일한 체계 및 호스트를 공유하는 경우 중개자는 Referer 헤더 필드를 수정하거나 삭제해서는 안 됩니다.

---
#### **10.1.4.  TE**

"TE" 헤더 필드는 전송 코딩 및 트레일러 섹션과 관련된 클라이언트의 기능을 설명합니다.

섹션 6.5에 설명된 대로 요청에 전송된 "트레일러" 멤버가 있는 TE 필드는 클라이언트가 트레일러 필드를 삭제하지 않음을 나타냅니다.

TE는 또한 클라이언트가 응답에서 어떤 전송 코딩을 받아들일 수 있는지 서버에 알리기 위해 HTTP/1.1 내에서 사용됩니다. 출판 당시에는 HTTP/1.1만이 전송 코딩을 사용했습니다\(\[HTTP/1.1\]의 섹션 7 참조\).

TE 필드 값은 멤버 목록이며, 각 멤버\("트레일러" 제외\)는 해당 전송 코딩\(섹션 12.4.2\)에 대한 클라이언트의 상대적 선호도를 나타내는 선택적 가중치와 함께 전송 코딩 이름 토큰으로 구성됩니다. 그 전송 코딩.

```text
     TE                 = #t-codings
     t-codings          = "trailers" / ( transfer-coding [ weight ] )
     transfer-coding    = token *( OWS ";" OWS transfer-parameter )
     transfer-parameter = token BWS "=" BWS ( token / quoted-string )
```

TE의 발신자는 또한 연결 헤더 필드\(섹션 7.6.1\) 내에 "TE" 연결 옵션을 보내 중개자에게 이 필드를 전달하지 말 것을 알려야 합니다.

---
#### **10.1.5.  User-Agent**

"User-Agent" 헤더 필드에는 요청을 시작한 사용자 에이전트에 대한 정보가 포함되어 있습니다. 이 정보는 보고된 상호 운용성 문제의 범위를 식별하고, 특정 사용자 에이전트 제한을 피하기 위해 응답을 조정하거나 해결하고, 분석을 위해 서버에서 자주 사용됩니다. 브라우저 또는 운영 체제 사용과 관련하여. 사용자 에이전트는 특별히 그렇게 하지 않도록 구성하지 않는 한 각 요청에 User-Agent 헤더 필드를 보내야 합니다\(SHOULD\).

```text
     User-Agent = product *( RWS ( product / comment ) )
```

User-Agent 필드 값은 하나 이상의 제품 식별자로 구성되며 각 식별자 뒤에는 0개 이상의 주석\(섹션 5.6.5\)이 옵니다. 이는 함께 사용자 에이전트 소프트웨어와 그 중요한 하위 제품을 식별합니다. 관례적으로 제품 식별자는 사용자 에이전트 소프트웨어를 식별하는 중요성의 내림차순으로 나열됩니다. 각 제품 식별자는 이름과 선택적 버전으로 구성됩니다.

```text
     product         = token ["/" product-version]
     product-version = token
```

발신자는 생성된 제품 식별자를 제품을 식별하는 데 필요한 것으로 제한해야 합니다. 발신자는 제품 식별자 내에 광고 또는 기타 중요하지 않은 정보를 생성해서는 안 됩니다. 발신자는 버전 식별자가 아닌 제품 버전에서 정보를 생성해서는 안 됩니다\(즉, 동일한 제품 이름의 연속 버전은 제품 식별자의 제품 버전 부분에서만 달라야 합니다\).

```text
   Example:

   User-Agent: CERN-LineMode/2.15 libwww/2.17b3
```

사용자 에이전트는 불필요하게 세분화된 세부정보가 포함된 User-Agent 헤더 필드를 생성해서는 안 되며 제3자가 하위 제품을 추가하는 것을 제한해야 합니다. 지나치게 길고 상세한 User-Agent 필드 값은 요청 대기 시간을 증가시키고 사용자가 원하는 것과는 반대로 사용자가 식별될 위험\("지문"\)을 발생시킵니다.

마찬가지로 구현에서는 호환성을 선언하기 위해 다른 구현의 제품 토큰을 사용하지 않는 것이 좋습니다. 이는 필드의 목적을 우회하기 때문입니다. 사용자 에이전트가 다른 사용자 에이전트로 가장하는 경우 수신자는 사용 중인 실제 사용자 에이전트에 대해 잘 작동하지 않더라도 사용자가 식별된 사용자 에이전트에 맞게 조정된 응답을 의도적으로 보고 싶어한다고 가정할 수 있습니다.

---
### **10.2.  Response Context Fields**

아래 응답 헤더 필드는 서버, 대상 리소스 또는 관련 리소스에 대한 정보를 포함하여 상태 코드가 암시하는 것 이상으로 응답에 대한 추가 정보를 제공합니다.

---
#### **10.2.1.  Allow**

"Allow" 헤더 필드에는 대상 리소스에서 지원하는 것으로 알려진 메서드 집합이 나열됩니다. 이 필드의 목적은 엄격하게 리소스와 관련된 유효한 요청 방법을 수신자에게 알리는 것입니다.

```text
     Allow = #method
```

사용 예:

```text
   Allow: GET, HEAD, PUT
```

허용되는 실제 메소드 세트는 각 요청 시 원본 서버에 의해 정의됩니다. 원본 서버는 405\(허용되지 않는 메서드\) 응답에서 Allow 헤더 필드를 생성해야 하며 다른 응답에서도 그렇게 할 수 있습니다. 비어 있는 허용 필드 값은 리소스가 메서드를 허용하지 않음을 나타냅니다. 이는 리소스가 구성에 의해 일시적으로 비활성화된 경우 405 응답에서 발생할 수 있습니다.

프록시는 Allow 헤더 필드를 수정해서는 안 됩니다. 일반 메시지 처리 규칙에 따라 처리하기 위해 표시된 모든 메서드를 이해할 필요는 없습니다.

---
#### **10.2.2.  Location**

"Location" 헤더 필드는 일부 응답에서 응답과 관련된 특정 리소스를 참조하는 데 사용됩니다. 관계 유형은 요청 방법과 상태 코드 의미의 조합으로 정의됩니다.

```text
     Location = URI-reference
```

필드 값은 단일 URI 참조로 구성됩니다. 상대 참조\(\[URI\], 섹션 4.2\) 형식을 갖는 경우 최종 값은 대상 URI\(\[URI\], 섹션 5\)에 대해 이를 확인하여 계산됩니다.

201\(생성됨\) 응답의 경우 위치 값은 요청에 의해 생성된 기본 리소스를 나타냅니다. 3xx\(리디렉션\) 응답의 경우 위치 값은 요청을 자동으로 리디렉션하기 위해 선호하는 대상 리소스를 나타냅니다.

3xx\(리디렉션\) 응답에 제공된 위치 값에 조각 구성 요소가 없는 경우 사용자 에이전트는 값이 대상 URI를 생성하는 데 사용된 URI 참조의 조각 구성 요소를 상속하는 것처럼 리디렉션을 처리해야 합니다\(즉, 리디렉션은 다음을 상속합니다\). 원본 참조의 조각\(있는 경우\).

예를 들어, URI 참조 "http://www.example.org/\~tim"에 대해 생성된 GET 요청은 헤더 필드를 포함하는 303\(기타 참조\) 응답으로 이어질 수 있습니다.

```text
   Location: /People.html#tim
```

이는 사용자 에이전트가 "http://www.example.org/People.html#tim"으로 리디렉션되도록 제안합니다.

마찬가지로, URI 참조 "http://www.example.org/index.html#larry"에 대해 생성된 GET 요청은 헤더 필드를 포함하는 301\(영구적으로 이동됨\) 응답을 생성할 수 있습니다.

```text
   Location: http://www.example.net/index.html
```

이는 사용자 에이전트가 원래 조각 식별자를 유지하면서 "http://www.example.net/index.html#larry"로 리디렉션되도록 제안합니다.

위치 값의 조각 식별자가 적절하지 않은 상황이 있습니다. 예를 들어 201\(Created\) 응답의 Location 헤더 필드는 생성된 리소스에 특정한 URI를 제공해야 합니다.

- | \*참고:\* 일부 수신자는 위치 헤더 | 유효한 URI 참조가 아닌 필드입니다. 이 사양 | 그러한 처리를 의무화하거나 정의하지는 않지만 허용합니다 | 견고함을 위해서. 위치 필드 값은 | 쉼표 목록 구분 기호는 |이므로 구성원 목록을 허용합니다. URI 참조 내의 유효한 데이터 문자입니다. 잘못된 경우 | 메시지가 여러 위치 필드 줄과 함께 전송되면 수신자 | 경로를 따라 해당 필드 라인을 하나의 값으로 결합할 수 있습니다. | 해당 상황에서 유효한 위치 필드 값을 복구하는 방법은 | 구현이 어렵고 상호 운용이 불가능합니다.

- | \*참고:\* Content-Location 헤더 필드\(섹션 8.7\)는 다릅니다 | Content-Location이 가장 많은 것을 참조한다는 점에서 Location에서 | 동봉된 표현에 해당하는 특정 리소스입니다. | 따라서 응답에 | Location 및 Content-Location 헤더 필드.

---
#### **10.2.3.  Retry-After**

서버는 후속 요청을 하기 전에 사용자 에이전트가 기다려야 하는 시간을 나타내기 위해 "Retry-After" 헤더 필드를 보냅니다. 503\(서비스 사용 불가\) 응답과 함께 전송된 경우 Retry-After는 클라이언트가 서비스를 사용할 수 없을 것으로 예상되는 기간을 나타냅니다. 3xx\(리디렉션\) 응답과 함께 전송되는 경우 Retry-After는 리디렉션된 요청을 발행하기 전에 사용자 에이전트가 기다려야 하는 최소 시간을 나타냅니다.

Retry-After 필드 값은 HTTP 날짜이거나 응답 수신 후 지연되는 시간\(초\)일 수 있습니다.

```text
     Retry-After = HTTP-date / delay-seconds
```

지연-초 값은 음이 아닌 십진수 정수로, 시간을 초 단위로 나타냅니다.

```text
     delay-seconds  = 1*DIGIT
```

그 사용의 두 가지 예는 다음과 같습니다

```text
   Retry-After: Fri, 31 Dec 1999 23:59:59 GMT
   Retry-After: 120
```

후자의 예에서는 지연 시간이 2분입니다.

---
#### **10.2.4.  Server**

"Server" 헤더 필드에는 요청을 처리하기 위해 원본 서버에서 사용하는 소프트웨어에 대한 정보가 포함되어 있습니다. 이 소프트웨어는 보고된 상호 운용성 문제의 범위를 식별하는 데 도움을 주고 특정 서버 제한을 ​​피하기 위해 요청을 조정하거나 해결하기 위해 클라이언트에서 자주 사용됩니다. 서버 또는 운영 체제 사용에 관한 분석을 위해. 원서버는 응답에 서버 헤더 필드를 생성할 수 있습니다.

```text
     Server = product *( RWS ( product / comment ) )
```

서버 헤더 필드 값은 하나 이상의 제품 식별자로 구성되며, 각 식별자 뒤에는 0개 이상의 주석\(5.6.5절\)이 따르며, 이는 원본 서버 소프트웨어와 그 중요한 하위 제품을 함께 식별합니다. 관례적으로 제품 식별자는 원본 서버 소프트웨어를 식별하는 중요성의 내림차순으로 나열됩니다. 각 제품 식별자는 섹션 10.1.5에 정의된 대로 이름과 선택적 버전으로 구성됩니다.

```text
   Example:

   Server: CERN/3.0 libwww/2.17
```

원본 서버는 불필요하게 세분화된 세부 정보가 포함된 서버 헤더 필드를 생성해서는 안 되며 제3자가 하위 제품을 추가하는 것을 제한해야 합니다. 지나치게 길고 상세한 서버 필드 값은 응답 대기 시간을 늘리고 잠재적으로 공격자가 알려진 보안 허점을 찾아 악용하는 것을 \(약간\) 더 쉽게 만들 수 있는 내부 구현 세부 정보를 노출할 수 있습니다.

---
## **11.  HTTP Authentication**
---
### **11.1.  Authentication Scheme**

HTTP는 서버가 클라이언트 요청에 도전하고 클라이언트가 인증 정보를 제공하는 데 사용할 수 있는 확장 가능한 시도-응답 인증 체계 세트를 통해 액세스 제어 및 인증을 위한 일반 프레임워크를 제공합니다. 대소문자를 구분하지 않는 토큰을 사용하여 인증 체계를 식별합니다.

```text
     auth-scheme    = token
```

일반적인 프레임워크 외에 이 문서에서는 인증 체계를 지정하지 않습니다. 신규 및 기존 인증 체계는 독립적으로 지정되며 "HTTP\(Hypertext Transfer Protocol\) 인증 체계 레지스트리" 내에 등록되어야 합니다. 예를 들어 "기본" 및 "다이제스트" 인증 체계는 각각 \[RFC7617\] 및 \[RFC7616\]에 의해 정의됩니다.

---
### **11.2.  Authentication Parameters**

인증 체계 다음에는 쉼표로 구분된 매개변수 목록 또는 base64로 인코딩된 정보를 보유할 수 있는 단일 문자 시퀀스로서 해당 체계를 통해 인증을 달성하는 데 필요한 추가 정보가 옵니다.

```text
     token68        = 1*( ALPHA / DIGIT /
                          "-" / "." / "_" / "~" / "+" / "/" ) *"="
```

token68 구문은 66개의 예약되지 않은 URI 문자\(\[URI\]\)와 기타 몇 가지 문자를 허용하므로 패딩 유무에 관계없이 base64, base64url\(URL 및 파일 이름 안전 알파벳\), base32 또는 base16\(16진수\) 인코딩을 보유할 수 있습니다. , 그러나 공백은 제외됩니다\(\[RFC4648\]\).

인증 매개변수는 이름/값 쌍입니다. 여기서 이름 토큰은 대소문자를 구분하지 않고 일치하며 각 매개변수 이름은 챌린지당 한 번만 발생해야 합니다.

```text
     auth-param     = token BWS "=" BWS ( token / quoted-string )
```

매개변수 값은 "토큰" 또는 "인용 문자열"\(섹션 5.6\)로 표현될 수 있습니다. 인증 체계 정의는 수신자가 인증 체계에 관계없이 일반 구문 분석 구성 요소를 사용할 수 있도록 발신자와 수신자 모두에 대해 두 표기법을 모두 허용해야 합니다.

이전 버전과의 호환성을 위해 인증 체계 정의는 보낸 사람의 형식을 두 변형 중 하나로 제한할 수 있습니다. 두 가지 형식 중 하나가 발생하면 배포된 구현이 실패한다는 것이 알려진 경우 이는 중요할 수 있습니다.

---
### **11.3.  Challenge and Response**

401\(Unauthorized\) 응답 메시지는 요청된 리소스에 적용할 수 있는 최소 하나의 챌린지를 포함하는 WWW-Authenticate 헤더 필드를 포함하여 사용자 에이전트의 인증을 챌린지하기 위해 원서버에서 사용됩니다.

407\(프록시 인증 필요\) 응답 메시지는 요청된 리소스에 대한 프록시에 적용할 수 있는 하나 이상의 챌린지를 포함하는 프록시 인증 헤더 필드를 포함하여 클라이언트의 인증을 챌린지하기 위해 프록시에서 사용됩니다.

```text
     challenge   = auth-scheme [ 1*SP ( token68 / #auth-param ) ]
```

- | \*참고:\* 많은 클라이언트가 | 알려지지 않은 계획. 이 문제에 대한 해결 방법은 잘 나열하는 것입니다. | 먼저 지원되는 구성표\(예: "기본"\)를 선택하세요.

원본 서버로 자신을 인증하려는 사용자 에이전트는 일반적으로 401\(Unauthorized\)을 수신한 후 반드시 그런 것은 아니지만 요청에 Authorization 헤더 필드를 포함하여 인증할 수 있습니다.

일반적으로 407\(프록시 인증 필요\)을 수신한 후 반드시 그런 것은 아니지만 프록시를 사용하여 자신을 인증하려는 클라이언트는 요청에 Proxy-Authorization 헤더 필드를 포함시켜 인증할 수 있습니다.

---
### **11.4.  Credentials**

Authorization 필드 값과 Proxy-Authorization 필드 값 모두 응답에서 수신된 인증 확인\(아마도 과거 어느 시점\)을 기반으로 요청 중인 리소스 영역에 대한 클라이언트 자격 증명을 포함합니다. 값을 생성할 때 사용자 에이전트는 자신이 이해하는 가장 안전한 인증 체계로 챌린지를 선택하고 사용자로부터 적절하게 자격 증명을 얻어야 합니다. 헤더 필드 값 내의 자격 증명 전송은 섹션 17.16.1에 설명된 대로 기본 연결의 기밀성에 관한 중요한 보안 고려 사항을 의미합니다.

```text
     credentials = auth-scheme [ 1*SP ( token68 / #auth-param ) ]
```

자격 증명을 생략하거나 유효하지 않은 자격 증명\(예: 잘못된 비밀번호\) 또는 부분 자격 증명\(예: 인증 체계에 두 번 이상의 왕복이 필요한 경우\)이 포함된 보호된 리소스에 대한 요청을 수신하면 원서버는 401\(Unauthorized\)을 보내야 합니다. \) 요청된 리소스에 적용 가능한 하나 이상의\(아마도 새로운\) 챌린지가 있는 WWW-Authenticate 헤더 필드가 포함된 응답입니다.

마찬가지로, 프록시 자격 증명을 생략하거나 유효하지 않거나 부분적인 프록시 자격 증명을 포함하는 요청을 수신하면 인증이 필요한 프록시는 하나 이상의\(아마도 새로운\) Proxy-Authenticate 헤더 필드를 포함하는 407\(프록시 인증 필요\) 응답을 생성해야 합니다. 프록시에 적용 가능한 챌린지입니다.

액세스 권한을 얻는 데 적합하지 않은 유효한 자격 증명을 수신한 서버는 403\(금지됨\) 상태 코드\(섹션 15.5.4\)로 응답해야 합니다.

HTTP는 액세스 인증을 위한 이 간단한 시도-응답 프레임워크로 애플리케이션을 제한하지 않습니다. 전송 수준에서의 인증이나 메시지 캡슐화를 통한 인증, 인증 정보를 지정하는 추가 헤더 필드와 같은 추가 메커니즘을 사용할 수 있습니다. 그러나 이러한 추가 메커니즘은 이 사양에서 정의되지 않습니다.

사용자 인증을 위한 다양한 사용자 정의 메커니즘은 인증과 관련된 토큰을 전달하기 위해 \[COOKIE\]에 정의된 Set-Cookie 및 Cookie 헤더 필드를 사용합니다.

---
### **11.5.  Establishing a Protection Space (Realm)**

"영역" 인증 매개변수는 보호 범위를 표시하려는 인증 체계에서 사용하도록 예약되어 있습니다.

"보호 공간"은 액세스되는 서버의 원본\(섹션 4.3.1 참조\)과 영역 값\(존재하는 경우\)의 조합으로 정의됩니다. 이러한 영역을 사용하면 서버의 보호된 리소스를 각각 고유한 인증 체계 및/또는 권한 부여 데이터베이스가 있는 보호 공간 집합으로 분할할 수 있습니다. 영역 값은 일반적으로 원본 서버에 의해 할당되는 문자열로, 인증 체계에 특정한 추가 의미를 가질 수 있습니다. 응답에는 인증 체계는 동일하지만 영역이 다른 여러 문제가 있을 수 있습니다.

보호 공간은 자격 증명이 자동으로 적용될 수 있는 도메인을 결정합니다. 이전 요청이 승인된 경우 사용자 에이전트는 인증 체계, 매개변수 및/또는 사용자 기본 설정\(예: 구성 가능한 비활성 시간 초과\)에 의해 결정된 기간 동안 해당 보호 공간 내의 다른 모든 요청에 ​​대해 동일한 자격 증명을 재사용할 수 있습니다. .

보호 공간의 범위와 자격 증명이 자동으로 적용될 수 있는 요청은 추가 정보 없이 클라이언트에 반드시 알려지지는 않습니다. 인증 체계는 보호 공간의 범위를 설명하는 매개변수를 정의할 수 있습니다. 인증 체계에서 특별히 허용하지 않는 한 단일 보호 공간은 서버 범위 외부로 확장될 수 없습니다.

역사적인 이유로 발신자는 인용 문자열 구문만 생성해야 합니다. 수신자는 오랫동안 두 표기법을 모두 수락해 온 기존 클라이언트와의 최대 상호 운용성을 위해 토큰 및 인용 문자열 구문을 모두 지원해야 할 수도 있습니다.

---
### **11.6.  Authenticating Users to Origin Servers**
---
#### **11.6.1.  WWW-Authenticate**

"WWW-Authenticate" 응답 헤더 필드는 대상 리소스에 적용 가능한 인증 체계 및 매개변수를 나타냅니다.

```text
     WWW-Authenticate = #challenge
```

401\(Unauthorized\) 응답을 생성하는 서버는 최소한 하나의 챌린지를 포함하는 WWW-Authenticate 헤더 필드를 보내야 합니다. 서버는 자격 증명\(또는 다른 자격 증명\)을 제공하면 응답에 영향을 미칠 수 있음을 나타내기 위해 다른 응답 메시지에 WWW-Authenticate 헤더 필드를 생성할 수 있습니다.

응답을 전달하는 프록시는 해당 응답의 WWW-Authenticate 헤더 필드를 수정해서는 안 됩니다.

필드 값에는 둘 이상의 질문이 포함될 수 있고 각 질문에는 쉼표로 구분된 인증 매개변수 목록이 포함될 수 있으므로 사용자 에이전트는 필드 값을 구문 분석할 때 특별한 주의를 기울이는 것이 좋습니다. 또한 헤더 필드 자체가 여러 번 나타날 수 있습니다.

예를 들어:

```text
   WWW-Authenticate: Basic realm="simple", Newauth realm="apps",
                    type=1, title="Login to \"apps\""
```

이 헤더 필드에는 두 개의 챌린지가 포함되어 있습니다. 하나는 영역 값이 "simple"인 "Basic" 체계에 대한 것이고 다른 하나는 영역 값이 "apps"인 "Newauth" 체계에 대한 것입니다. 또한 두 개의 추가 매개변수인 "type"과 "title"도 포함되어 있습니다.

그러나 일부 사용자 에이전트는 이 형식을 인식하지 못합니다. 결과적으로 동일한 필드 줄에 둘 이상의 구성원이 있는 WWW 인증 필드 값을 보내는 것은 상호 운용되지 않을 수 있습니다.

- | \*참고:\* 챌린지 문법 생성에서는 목록 구문 | 또한. 따라서 일련의 쉼표, 공백 및 쉼표 | 이전 | 챌린지 또는 챌린지 목록의 빈 항목이 됩니다. | 실제로 이러한 모호성은 |의 의미에 영향을 주지 않습니다. 헤더 필드 값이므로 무해합니다.

---
#### **11.6.2.  Authorization**

"Authorization" 헤더 필드를 사용하면 사용자 에이전트가 원본 서버에 자신을 인증할 수 있습니다. 일반적으로 401\(Unauthorized\) 응답을 수신한 후 반드시 그런 것은 아닙니다. 해당 값은 요청 중인 리소스 영역에 대한 사용자 에이전트의 인증 정보가 포함된 자격 증명으로 구성됩니다.

```text
     Authorization = credentials
```

요청이 인증되고 영역이 지정된 경우 동일한 자격 증명이 이 영역 내의 다른 모든 요청에 ​​대해 유효한 것으로 간주됩니다\(인증 체계 자체에서는 챌린지 값에 따라 달라지는 자격 증명이나 동기화된 자격 증명과 같은 달리 요구하지 않는다고 가정\). 시계\).

요청을 전달하는 프록시는 해당 요청의 Authorization 헤더 필드를 수정해서는 안 됩니다. HTTP 캐시에 의한 Authorization 헤더 필드 처리에 관한 세부 사항 및 요구 사항은 \[CACHING\]의 섹션 3.5를 참조하세요.

---
#### **11.6.3.  Authentication-Info**

HTTP 인증 체계는 "Authentication-Info" 응답 필드를 사용하여 클라이언트의 인증 자격 증명이 승인된 후 정보를 전달할 수 있습니다. 이 정보에는 서버의 종료 메시지가 포함될 수 있습니다\(예: 서버 인증이 포함될 수 있음\).

필드 값은 섹션 11.3에 정의된 "auth-param" 구문을 사용하는 매개변수\(이름/값 쌍\) 목록입니다. 이 사양에서는 일반 형식만 설명합니다. 인증 정보를 사용하는 인증 체계는 개별 매개변수를 정의합니다. 예를 들어 "다이제스트" 인증 체계는 \[RFC7616\]의 섹션 3.5에서 여러 매개변수를 정의합니다.

```text
     Authentication-Info = #auth-param
```

인증 정보 필드는 요청 방법 및 상태 코드와 관계없이 모든 HTTP 응답에서 사용할 수 있습니다. 그 의미는 해당 요청의 Authorization 헤더 필드\(섹션 11.6.2\)에 표시된 인증 체계에 의해 정의됩니다.

응답을 전달하는 프록시는 어떤 방식으로든 필드 값을 수정할 수 없습니다.

인증 체계가 이를 명시적으로 허용하는 경우 인증 정보는 트레일러 필드\(6.5절\)로 전송될 수 있습니다.

---
### **11.7.  Authenticating Clients to Proxies**
---
#### **11.7.1.  Proxy-Authenticate**

"Proxy-Authenticate" 헤더 필드는 이 요청에 대한 프록시에 적용할 수 있는 인증 체계 및 매개변수를 나타내는 하나 이상의 챌린지로 구성됩니다. 프록시는 생성되는 각 407\(프록시 인증 필요\) 응답에 최소한 하나의 프록시 인증 헤더 필드를 보내야 합니다.

```text
     Proxy-Authenticate = #challenge
```

WWW-Authenticate와 달리 Proxy-Authenticate 헤더 필드는 응답 체인의 다음 아웃바운드 클라이언트에만 적용됩니다. 이는 특정 프록시를 선택한 클라이언트만이 인증에 필요한 자격 증명을 가질 가능성이 높기 때문입니다. 그러나 대규모 회사 네트워크 내의 사무실 및 지역 캐싱 프록시와 같이 동일한 관리 도메인 내에서 여러 프록시가 사용되는 경우 자격 증명이 사용자 에이전트에 의해 생성되고 소비될 때까지 계층 구조를 통과하는 것이 일반적입니다. 따라서 이러한 구성에서는 각 프록시가 동일한 챌린지 세트를 보내기 때문에 프록시 인증이 전달되는 것처럼 나타납니다.

WWW-Authenticate에 대한 구문 분석 고려 사항은 이 헤더 필드에도 적용됩니다. 자세한 내용은 섹션 11.6.1을 참조하세요.

---
#### **11.7.2.  Proxy-Authorization**

"Proxy-Authorization" 헤더 필드를 사용하면 클라이언트는 인증이 필요한 프록시에 대해 자신\(또는 해당 사용자\)을 식별할 수 있습니다. 해당 값은 요청 중인 리소스의 프록시 및/또는 영역에 대한 클라이언트의 인증 정보가 포함된 자격 증명으로 구성됩니다.

```text
     Proxy-Authorization = credentials
```

Authorization과 달리 Proxy-Authorization 헤더 필드는 Proxy-Authenticate 헤더 필드를 사용하여 인증을 요구한 다음 인바운드 프록시에만 적용됩니다. 여러 프록시가 체인에 사용되는 경우 자격 증명을 받을 것으로 예상되는 첫 번째 인바운드 프록시에서 Proxy-Authorization 헤더 필드를 사용합니다. 프록시가 주어진 요청을 협력적으로 인증하는 메커니즘인 경우 프록시는 클라이언트 요청의 자격 증명을 다음 프록시로 중계할 수 있습니다.

---
#### **11.7.3.  Proxy-Authentication-Info**

"Proxy-Authentication-Info" 응답 헤더 필드는 프록시 인증\(섹션 11.3\)에 적용되고 그 의미가 Proxy-Authorization 헤더 필드\(섹션 11.7.1\)에 표시된 인증 체계에 의해 정의된다는 점을 제외하면 Authentication-Info와 동일합니다. 2\) 해당 요청 중:

```text
     Proxy-Authentication-Info = #auth-param
```

그러나 Authentication-Info와 달리 Proxy-Authentication-Info 헤더 필드는 응답 체인의 다음 아웃바운드 클라이언트에만 적용됩니다. 이는 특정 프록시를 선택한 클라이언트만이 인증에 필요한 자격 증명을 가질 가능성이 높기 때문입니다. 그러나 대규모 회사 네트워크 내의 사무실 및 지역 캐싱 프록시와 같이 동일한 관리 도메인 내에서 여러 프록시가 사용되는 경우 자격 증명이 사용자 에이전트에 의해 생성되고 소비될 때까지 계층 구조를 통과하는 것이 일반적입니다. 따라서 이러한 구성에서는 각 프록시가 동일한 필드 값을 보내기 때문에 Proxy-Authentication-Info가 전달되는 것처럼 나타납니다.

Proxy-Authentication-Info는 인증 체계가 이를 명시적으로 허용하는 경우 트레일러 필드\(6.5절\)로 전송될 수 있습니다.

---
## **12.  Content Negotiation**

응답이 성공을 나타내든 오류를 나타내든 내용을 전달할 때 원본 서버는 해당 정보를 표현하는 다양한 방법을 사용하는 경우가 많습니다. 예를 들어 다양한 형식, 언어 또는 인코딩이 있습니다. 마찬가지로, 다양한 사용자 또는 사용자 에이전트는 사용 가능한 표현 중에서 어떤 표현이 가장 전달하기에 영향을 미칠 수 있는 서로 다른 기능, 특성 또는 선호도를 가질 수 있습니다. 이러한 이유로 HTTP는 콘텐츠 협상을 위한 메커니즘을 제공합니다.

이 사양은 프로토콜 내에서 볼 수 있는 세 가지 콘텐츠 협상 패턴을 정의합니다. 즉, 서버가 사용자 에이전트의 명시된 기본 설정에 따라 표현을 선택하는 "사전" 협상입니다. 서버가 사용자 에이전트가 선택할 수 있는 표현 목록을 제공하는 "반응적" 협상 및 "요청 콘텐츠" 협상. 여기서 사용자 에이전트는 과거 응답에서 서버가 명시한 기본 설정을 기반으로 향후 요청에 대한 표현을 선택합니다.

콘텐츠 협상의 다른 패턴에는 표현이 사용자 에이전트 매개변수를 기반으로 선택적으로 렌더링되는 여러 부분으로 구성된 "조건부 콘텐츠", 표현에 기반하여 추가\(보다 구체적인\) 요청을 하는 스크립트가 포함된 "활성 콘텐츠"가 포함됩니다. 사용자 에이전트 특성 및 "투명한 콘텐츠 협상"\(\[RFC2295\]\), 여기서 콘텐츠 선택은 중개자에 의해 수행됩니다. 이러한 패턴은 상호 배타적이지 않으며 적용 가능성과 실용성 면에서 각각 장단점이 있습니다.

모든 경우에 HTTP는 리소스 의미를 인식하지 못합니다. 원서버가 시간이 지남에 따라 그리고 콘텐츠 협상의 다양한 차원에 걸쳐 요청에 응답하는 일관성, 그리고 시간이 지남에 따라 관찰된 리소스 표현의 "동일성"은 전적으로 해당 응답을 선택하거나 생성하는 엔터티 또는 알고리즘에 의해 결정됩니다.

---
### **12.1.  Proactive Negotiation**

서버에 있는 알고리즘이 선호하는 표현을 선택하도록 장려하기 위한 요청에서 사용자 에이전트가 콘텐츠 협상 기본 설정을 전송하는 경우 이를 "사전 협상"\(일명 "서버 중심 협상"\)이라고 합니다. 선택은 아래의 명시적 협상 헤더 필드와 암시적 특성을 모두 포함하여 요청에 제공된 다양한 정보와 비교하여 응답에 사용 가능한 표현\(언어, 콘텐츠 코딩 등 다양할 수 있는 차원\)을 기반으로 합니다. 클라이언트의 네트워크 주소나 User-Agent 필드의 일부와 같은 것입니다.

사용 가능한 표현 중에서 선택하기 위한 알고리즘이 사용자 에이전트에 설명하기 어려울 때 또는 서버가 첫 번째 응답과 함께 "최상의 추측"을 사용자 에이전트에 보내려고 할 때\("최선의 추측"이 있을 때\) 사전 협상이 유리합니다. "는 사용자에게 충분하므로 후속 요청의 왕복 지연을 방지합니다.\) 서버의 추측을 향상시키기 위해 사용자 에이전트는 자신의 기본 설정을 설명하는 요청 헤더 필드를 보낼 수 있습니다.

적극적인 협상에는 다음과 같은 심각한 단점이 있습니다.

\* 서버가 특정 사용자에게 "최적"인 것이 무엇인지 정확하게 결정하는 것은 불가능합니다. 이를 위해서는 사용자 에이전트의 기능과 응답의 의도된 사용에 대한 완전한 지식이 필요하기 때문입니다\(예: 사용자가 원하는지 여부\) 화면으로 볼 것인가 아니면 종이에 인쇄할 것인가?\);

\* 사용자 에이전트가 모든 요청에서 자신의 기능을 설명하도록 하는 것은 매우 비효율적일 수 있으며\(응답의 소수만이 다중 표현을 갖는다는 점을 고려하면\) 사용자의 개인 정보 보호에 잠재적인 위험이 있을 수 있습니다.

\* 이는 원본 서버의 구현과 요청에 대한 응답을 생성하는 알고리즘을 복잡하게 만듭니다. 그리고,

\* 공유 캐싱에 대한 응답의 재사용성을 제한합니다.

사용자 에이전트는 원서버가 요청된 리소스에 대해 사전 협상을 구현하지 않거나 사용자 에이전트의 기본 설정에 맞지 않는 응답을 보내는 것이 406\( 허용되지 않음\) 응답.

Vary 헤더 필드\(12.5.5절\)는 선택 알고리즘에 사용된 요청 정보 부분을 나타내기 위해 사전 협상에 따라 응답으로 전송되는 경우가 많습니다.

요청 헤더 필드 Accept, Accept-Charset, Accept-Encoding 및 Accept-Language는 사용자 에이전트가 응답 콘텐츠의 사전 협상에 참여할 수 있도록 아래에 정의되어 있습니다. 이러한 필드에 전송된 기본 설정은 대상 리소스 표현, 오류 또는 처리 상태 표현, 심지어 프로토콜 내에 나타날 수 있는 기타 텍스트 문자열까지 포함하여 응답의 모든 콘텐츠에 적용됩니다.

---
### **12.2.  Reactive Negotiation**

"반응적 협상"\(즉, "에이전트 중심 협상"\)을 사용하면 초기 응답을 받은 후 사용자 에이전트가 콘텐츠 선택\(상태 코드에 관계없이\)을 수행합니다. 반응적 협상을 위한 메커니즘은 대체 표현에 대한 참조 목록만큼 간단할 수 있습니다.

사용자 에이전트가 초기 응답 내용에 만족하지 않으면 하나 이상의 대체 리소스에 대해 GET 요청을 수행하여 다른 표현을 얻을 수 있습니다. 그러한 대안의 선택은 자동으로\(사용자 에이전트에 의해\) 또는 수동으로\(예: 사용자가 하이퍼텍스트 메뉴에서 선택하여\) 수행될 수 있습니다.

서버는 대안 목록 이외의 초기 표현을 보내지 않기로 선택할 수 있으며 이에 따라 사용자 에이전트에 의한 반응적 협상이 선호됨을 나타낼 수 있습니다. 예를 들어, 300\(다중 선택\) 및 406\(허용되지 않음\) 상태 코드에 대한 응답에 나열된 대안에는 사용자 또는 사용자 에이전트가 선택을 통해 반응할 수 있도록 사용 가능한 표현에 대한 정보가 포함됩니다.

반응적 협상은 응답이 일반적으로 사용되는 차원\(예: 유형, 언어 또는 인코딩\)에 따라 다를 때, 원서버가 요청 검사에서 사용자 에이전트의 기능을 결정할 수 없을 때, 일반적으로 공개 캐시를 사용하여 배포할 때 유리합니다. 서버 부하를 줄이고 네트워크 사용량을 줄입니다.

반응적 협상은 대안 목록을 사용자 에이전트에 전송한다는 단점이 있습니다. 이는 헤더 섹션에서 전송되는 경우 사용자 인식 대기 시간을 저하시키고 대안 표현을 얻기 위해 두 번째 요청이 필요합니다. 또한, 이 사양은 자동 선택을 지원하는 메커니즘을 정의하지 않지만 이러한 메커니즘의 개발을 방해하지는 않습니다.

---
### **12.3.  Request Content Negotiation**

콘텐츠 협상 기본 설정이 서버의 응답으로 전송되면 나열된 기본 설정은 해당 리소스에 대한 후속 요청에 대한 적절한 콘텐츠 선택에 영향을 미치기 때문에 "콘텐츠 협상 요청"이라고 합니다. 예를 들어 Accept\(12.5.1항\) 및 Accept-Encoding\(12.5.3항\) 헤더 필드는 해당 리소스에 대한 후속 요청에 대해 선호하는 미디어 유형 및 콘텐츠 코딩을 나타내기 위해 응답으로 전송될 수 있습니다.

마찬가지로 \[RFC5789\]의 섹션 3.1에서는 PATCH 요청에서 어떤 콘텐츠 유형이 허용되는지 검색할 수 있는 "Accept-Patch" 응답 헤더 필드를 정의합니다.

---
### **12.4.  Content Negotiation Field Features**
---
#### **12.4.1.  Absence**

각 콘텐츠 협상 필드에 대해 해당 필드가 포함되지 않은 요청은 보낸 사람이 해당 협상 차원을 선호하지 않음을 의미합니다.

요청에 콘텐츠 협상 헤더 필드가 있고 응답에 사용 가능한 표현 중 어느 것도 그에 따라 허용 가능한 것으로 간주될 수 없는 경우 원본 서버는 406\(허용되지 않음\) 응답을 보내 헤더 필드를 존중하거나 헤더를 무시할 수 있습니다. 해당 요청 헤더 필드에 대한 콘텐츠 협상의 대상이 아닌 것처럼 응답을 처리합니다. 그러나 이것이 클라이언트가 표현을 사용할 수 있다는 것을 의미하지는 않습니다.

- | \*참고:\* 이러한 헤더 필드를 보내는 사용자 에이전트는 | 서버가 |를 통해 개인을 더 쉽게 식별할 수 있습니다. 사용자 에이전트의 요청 특성\(17.13절\)

---
#### **12.4.2.  Quality Values**

이 사양에 정의된 콘텐츠 협상 필드는 관련 콘텐츠 종류에 대한 선호도에 상대적인 '가중치'를 할당하기 위해 "q"\(대소문자 구분 안 함\)라는 공통 매개변수를 사용합니다. 이 가중치를 "품질 값"\(또는 "qvalue"\)이라고 합니다. 리소스에 대해 선택할 수 있는 다양한 표현의 상대적 품질에 가중치를 할당하기 위해 서버 구성 내에서 동일한 매개변수 이름이 자주 사용되기 때문입니다.

가중치는 0\~1 범위의 실수로 정규화됩니다. 여기서 0.001은 가장 선호되지 않고 1은 가장 선호됩니다. 값 0은 "허용되지 않음"을 의미합니다. "q" 매개변수가 없으면 기본 가중치는 1입니다.

```text
     weight = OWS ";" OWS "q=" qvalue
     qvalue = ( "0" [ "." 0*3DIGIT ] )
            / ( "1" [ "." 0*3("0") ] )
```

qvalue의 발신자는 소수점 이하 3자리 이상을 생성해서는 안 됩니다. 이러한 값의 사용자 구성은 동일한 방식으로 제한되어야 합니다.

---
#### **12.4.3.  Wildcard Values**

표시된 경우 대부분의 이러한 헤더 필드는 지정되지 않은 값을 선택하기 위해 와일드카드 값\("\*"\)을 정의합니다. 와일드카드가 없으면 필드에 명시적으로 언급되지 않은 값은 허용되지 않는 것으로 간주됩니다. Vary 내에서 와일드카드 값은 분산이 무제한임을 의미합니다.

- | \*참고:\* 실제로 콘텐츠 협상에 와일드카드를 사용하면 | 에 대해 말하는 것이 거의 유용하지 않기 때문에 실용적인 가치가 제한되어 있습니다. 예를 들어, "나는 \(다른 | 특정 값\)보다 image/\*를 더 선호합니다." Accept: \*/\*;q=0을 보내 클라이언트는 | 더 많은 경우 명시적으로 406\(허용되지 않음\) 응답을 요청합니다. 선호하는 형식은 사용할 수 없지만 여전히 | 서버가 허용되므로 다른 응답을 처리할 수 있습니다 | 자신의 취향을 무시합니다.

---
### **12.5.  Content Negotiation Fields**
---
#### **12.5.1.  Accept**

"Accept" 헤더 필드는 사용자 에이전트가 응답 미디어 유형에 관한 기본 설정을 지정하는 데 사용할 수 있습니다. 예를 들어 Accept 헤더 필드는 인라인 이미지에 대한 요청의 경우와 같이 요청이 원하는 유형의 작은 집합으로 구체적으로 제한된다는 것을 나타내는 데 사용될 수 있습니다.

서버에서 응답으로 전송하면 Accept는 동일한 리소스에 대한 후속 요청 콘텐츠에서 어떤 콘텐츠 유형이 선호되는지에 대한 정보를 제공합니다.

```text
     Accept = #( media-range [ weight ] )

     media-range    = ( "*/*"
                        / ( type "/" "*" )
                        / ( type "/" subtype )
                      ) parameters
```

별표 "\*" 문자는 미디어 유형을 범위로 그룹화하는 데 사용됩니다. "\*/\*"는 모든 미디어 유형을 나타내고 "type/\*"는 해당 유형의 모든 하위 유형을 나타냅니다. 미디어 범위에는 해당 범위에 적용할 수 있는 미디어 유형 매개변수가 포함될 수 있습니다.

각 미디어 범위 뒤에는 선택적 적용 가능한 미디어 유형 매개변수\(예: charset\)가 올 수 있고 그 뒤에는 상대적 가중치를 나타내는 선택적 "q" 매개변수가 올 수 있습니다\(12.4.2절\).

이전 사양에서는 가중치 매개변수 뒤에 추가 확장 매개변수가 표시되도록 허용했습니다. accept 확장 문법\(accept-params, accept-ext\)은 정의가 복잡하고 실제로 사용되지 않았으며 새로운 헤더 필드를 통해 보다 쉽게 ​​배포될 수 있기 때문에 제거되었습니다. 가중치를 사용하는 발신자는 "q"를 마지막으로 전송해야 합니다\(모든 미디어 범위 매개변수 다음\). 수신자는 매개변수 순서에 관계없이 "q"라는 이름의 매개변수를 가중치로 처리해야 합니다.

- | \*참고:\* 콘텐츠 제어를 위해 "q" 매개변수 이름 사용 | 협상이 미디어 유형 매개변수를 방해할 경우 | 같은 이름을 가지고 있습니다. 따라서 미디어 유형 레지스트리는 | "q"라는 매개변수.

예

```text
   Accept: audio/*; q=0.2, audio/basic
```

"나는 오디오/기본을 선호하지만 품질이 80% 인하된 후 사용할 수 있는 최고 오디오 유형이면 나에게 보내주십시오"로 해석됩니다.

좀 더 정교한 예는 다음과 같습니다.

```text
   Accept: text/plain; q=0.5, text/html,
          text/x-dvi; q=0.8, text/x-c
```

구두로 말하면 "text/html 및 text/x-c는 똑같이 선호되는 미디어 유형이지만, 존재하지 않으면 text/x-dvi 표현을 보내고, 존재하지 않으면 text/ 일반 표현".

미디어 범위는 보다 구체적인 미디어 범위나 특정 미디어 유형으로 재정의될 수 있습니다. 특정 유형에 둘 이상의 미디어 범위가 적용되는 경우 가장 구체적인 참조가 우선적으로 적용됩니다. 예를 들어,

```text
   Accept: text/*, text/plain, text/plain;format=flowed, */*
```

다음과 같은 우선순위를 갖습니다:

```text
   1.  text/plain;format=flowed

   2.  text/plain

   3.  text/*

   4.  */*
```

특정 유형과 관련된 미디어 유형 품질 요소는 해당 유형과 일치하는 우선순위가 가장 높은 미디어 범위를 찾아 결정됩니다. 예를 들어,

```text
   Accept: text/*;q=0.3, text/plain;q=0.7, text/plain;format=flowed,
          text/plain;format=fixed;q=0.4, */*;q=0.5
```

다음 값이 연결됩니다.

```text
   +==========================+===============+
   | Media Type               | Quality Value |
   +==========================+===============+
   | text/plain;format=flowed | 1             |
   +--------------------------+---------------+
   | text/plain               | 0.7           |
   +--------------------------+---------------+
   | text/html                | 0.3           |
   +--------------------------+---------------+
   | image/jpeg               | 0.5           |
   +--------------------------+---------------+
   | text/plain;format=fixed  | 0.4           |
   +--------------------------+---------------+
   | text/html;level=3        | 0.7           |
   +--------------------------+---------------+

                     Table 5
```

- | \*참고:\* 사용자 에이전트에는 | 특정 미디어 범위의 품질 값. 그러나 | 사용자 에이전트는 다른 시스템과 상호 작용할 수 없는 폐쇄형 시스템입니다. | 렌더링 에이전트의 경우 이 기본 세트는 | 사용자.

---
#### **12.5.2.  Accept-Charset**

"Accept-Charset" 헤더 필드는 텍스트 응답 콘텐츠의 문자 집합에 대한 기본 설정을 나타내기 위해 사용자 에이전트에 의해 전송될 수 있습니다. 예를 들어, 이 필드를 사용하면 보다 포괄적이거나 특수 목적의 문자 집합을 이해할 수 있는 사용자 에이전트가 해당 문자 집합의 정보를 표현할 수 있는 원본 서버에 해당 기능을 알릴 수 있습니다.

```text
     Accept-Charset = #( ( token / "*" ) [ weight ] )
```

문자 집합 이름은 섹션 8.3.2에 정의되어 있습니다. 사용자 에이전트는 섹션 12.4.2에 정의된 대로 해당 문자 세트에 대한 사용자의 상대적 선호도를 나타내기 위해 품질 값을 각 문자 세트와 연관시킬 수 있습니다. 예는 다음과 같습니다

```text
   Accept-Charset: iso-8859-5, unicode-1-1;q=0.8
```

Accept-Charset 헤더 필드에 있는 특수 값 "\*"는 필드의 다른 곳에서 언급되지 않은 모든 문자 세트와 일치합니다.

- | \*참고:\* UTF-8이 | 거의 어디에나 존재하며 사용자가 선호하는 세부 목록을 전송 | 문자 세트는 대역폭을 낭비하고 대기 시간을 늘리며 수동적으로 만듭니다. | 지문 채취가 너무 쉽습니다\(17.13절\). 가장 일반적인- | 목적 사용자 에이전트는 |가 아닌 이상 Accept-Charset을 보내지 않습니다. 그렇게 하도록 특별히 구성되었습니다.

---
#### **12.5.3.  Accept-Encoding**

"Accept-Encoding" 헤더 필드는 콘텐츠 코딩 사용에 관한 기본 설정을 나타내는 데 사용될 수 있습니다\(섹션 8.4.1\).

요청에서 사용자 에이전트가 보낸 경우 Accept-Encoding은 응답에서 허용되는 콘텐츠 코딩을 나타냅니다.

Accept-Encoding은 서버에서 응답을 보낼 때 동일한 리소스에 대한 후속 요청 콘텐츠에서 어떤 콘텐츠 코딩이 선호되는지에 대한 정보를 제공합니다.

"ID" 토큰은 인코딩이 선호되지 않을 때 통신하기 위해 "인코딩 없음"의 동의어로 사용됩니다.

```text
     Accept-Encoding  = #( codings [ weight ] )
     codings          = content-coding / "identity" / "*"
```

각 코딩 값에는 섹션 12.4.2에 정의된 대로 해당 인코딩에 대한 선호도를 나타내는 관련 품질 값\(가중치\)이 제공될 수 있습니다. Accept-Encoding 필드의 별표 "\*" 기호는 필드에 명시적으로 나열되지 않은 사용 가능한 콘텐츠 코딩과 일치합니다.

```text
   Examples:

   Accept-Encoding: compress, gzip
   Accept-Encoding:
   Accept-Encoding: *
   Accept-Encoding: compress;q=0.5, gzip;q=1.0
   Accept-Encoding: gzip;q=1.0, identity; q=0.5, *;q=0
```

서버는 다음 규칙을 사용하여 주어진 표현에 대한 콘텐츠 코딩이 허용되는지 여부를 테스트합니다.

1. 요청에 Accept-Encoding 헤더 필드가 없으면 사용자 에이전트는 모든 콘텐츠 코딩을 허용하는 것으로 간주합니다.

1. 표현에 콘텐츠 코딩이 없으면 "identity;q=0" 또는 "\*;q=0"을 나타내는 Accept-Encoding 헤더 필드에 의해 특별히 제외되지 않는 한 기본적으로 허용됩니다. 신원".

1. 표현의 콘텐츠 코딩이 Accept-Encoding 필드 값에 나열된 콘텐츠 코딩 중 하나인 경우 qvalue 0이 동반되지 않는 한 허용됩니다. \(12.4.2절에 정의된 대로 qvalue 0은 다음을 의미합니다. "받아 드릴 수없는".\)

표현은 여러 콘텐츠 코딩으로 인코딩될 수 있습니다. 그러나 대부분의 콘텐츠 코딩은 동일한 목적\(예: 데이터 압축\)을 달성하기 위한 대체 방법입니다. 동일한 목적을 가진 여러 콘텐츠 코딩 중에서 선택할 때 0이 아닌 가장 높은 q값을 가진 허용 가능한 콘텐츠 코딩이 선호됩니다.

필드 값이 비어 있는 Accept-Encoding 헤더 필드는 사용자 에이전트가 응답으로 콘텐츠 코딩을 원하지 않음을 의미합니다. 비어 있지 않은 Accept-Encoding 헤더 필드가 요청에 존재하고 응답에 대해 사용 가능한 표현 중 어느 것도 허용 가능한 것으로 나열된 콘텐츠 코딩을 갖지 않는 경우, 원서버는 신원 코딩이 그렇지 않은 한 콘텐츠 코딩 없이 응답을 보내야 합니다\(SHOULD\). 받아들일 수 없는 것으로 표시됩니다.

Accept-Encoding 헤더 필드가 응답에 있으면 리소스가 관련 요청에서 수락하려는 콘텐츠 코딩을 나타냅니다. 필드 값은 요청과 동일한 방식으로 평가됩니다.

이 정보는 연관된 요청에만 해당됩니다. 지원되는 인코딩 세트는 동일한 서버의 다른 리소스마다 다를 수 있으며 시간이 지남에 따라 변경되거나 요청의 다른 측면\(예: 요청 방법\)에 따라 달라질 수 있습니다.

지원되지 않는 콘텐츠 코딩으로 인해 요청에 실패한 서버는 415\(지원되지 않는 미디어 유형\) 상태로 응답하고 해당 응답에 Accept-Encoding 헤더 필드를 포함해야 합니다. 이를 통해 클라이언트는 콘텐츠 코딩과 미디어 유형과 관련된 문제를 구별할 수 있습니다. 미디어 유형과 관련된 문제와의 혼동을 피하기 위해 콘텐츠 코딩과 관련되지 않은 이유로 415 상태의 요청에 실패한 서버는 Accept-Encoding 헤더 필드를 포함해서는 안 됩니다.

Accept-Encoding의 가장 일반적인 사용은 클라이언트의 낙관적인 콘텐츠 코딩 사용에 대한 응답으로 415\(지원되지 않는 미디어 유형\) 상태 코드에 대한 응답입니다. 그러나 헤더 필드는 향후 상호 작용을 최적화하기 위해 콘텐츠 코딩이 지원된다는 것을 클라이언트에 알리는 데 사용될 수도 있습니다. 예를 들어, 요청 콘텐츠가 압축 코딩 사용을 정당화할 만큼 충분히 컸지만 클라이언트가 그렇게 하지 못한 경우 리소스는 이를 2xx\(성공\) 응답에 포함할 수 있습니다.

---
#### **12.5.4.  Accept-Language**

"Accept-Language" 헤더 필드는 사용자 에이전트가 응답에서 선호하는 자연어 세트를 나타내는 데 사용할 수 있습니다. 언어 태그는 섹션 8.5.1에 ​​정의되어 있습니다.

```text
     Accept-Language = #( language-range [ weight ] )
     language-range  =
               <language-range, see [RFC4647], Section 2.1>
```

각 언어 범위에는 섹션 12.4.2에 정의된 대로 해당 범위에 지정된 언어에 대한 사용자 선호도의 추정치를 나타내는 관련 품질 값이 제공될 수 있습니다. 예를 들어,

```text
   Accept-Language: da, en-gb;q=0.8, en;q=0.7
```

"나는 덴마크어를 선호하지만 영국식 영어와 다른 유형의 영어도 허용합니다"를 의미합니다.

일부 수신자는 언어 태그가 나열되는 순서를 내림차순 우선순위 표시로 취급합니다. 특히 동일한 품질 값이 할당된 태그의 경우\(q=1과 동일한 값은 없습니다\). 그러나 이 동작은 신뢰할 수 없습니다. 일관성과 상호 운용성을 극대화하기 위해 많은 사용자 에이전트는 각 언어 태그에 고유한 품질 값을 할당하는 동시에 품질이 낮은 순서로 나열합니다. 언어 우선순위 목록에 대한 추가 논의는 \[RFC4647\]의 섹션 2.3에서 확인할 수 있습니다.

매칭을 위해 \[RFC4647\]의 섹션 3에서는 여러 매칭 방식을 정의합니다. 구현에서는 요구 사항에 가장 적합한 일치 방식을 제공할 수 있습니다. "기본 필터링" 체계\(\[RFC4647\], 섹션 3.3.1\)는 이전에 \[RFC2616\]의 섹션 14.4에서 HTTP에 대해 정의된 일치 체계와 동일합니다.

모든 요청에서 사용자의 완전한 언어 기본 설정과 함께 Accept-Language 헤더 필드를 보내는 것은 사용자의 개인 정보 보호 기대에 어긋날 수 있습니다\(17.13절\).

명료성은 개별 사용자에 따라 크게 달라지기 때문에 사용자 에이전트는 언어 선호도에 대한 사용자 제어를 허용해야 합니다\(사용자 에이전트 자체 구성을 통해 또는 사용자가 제어할 수 있는 시스템 설정을 기본값으로 지정하여\). 사용자에게 그러한 제어를 제공하지 않는 사용자 에이전트는 Accept-Language 헤더 필드를 보내서는 안 됩니다.

- | \*참고:\* 사용자 에이전트는 | 사용자가 기본 설정에 거의 익숙하지 않기 때문에 | 위에서 설명한 대로 언어 매칭에 대한 자세한 내용을 확인하세요. 예를 들어 | 사용자는 "en-gb"를 선택하면 | 영국 영어가 아닌 경우 모든 종류의 영어 문서를 제공 | 사용 가능. 이러한 경우 사용자 에이전트는 | 더 나은 일치 동작을 위해 목록에 "en"을 추가합니다.

---
#### **12.5.5.  Vary**

응답의 "Vary" 헤더 필드는 메서드 및 대상 URI를 제외하고 요청 메시지의 어떤 부분이 이 응답의 콘텐츠를 선택하는 원본 서버의 프로세스에 영향을 미쳤는지 설명합니다.

```text
     Vary = #( "*" / field-name )
```

Vary 필드 값은 와일드카드 멤버 "\*" 또는 선택 헤더 필드로 알려진 요청 필드 이름 목록이며 이 응답에 대한 표현을 선택하는 역할을 했을 수 있습니다. 잠재적인 선택 헤더 필드는 이 사양에 정의된 필드로 제한되지 않습니다.

멤버 "\*"를 포함하는 목록은 메시지 구문 외부의 측면\(예: 클라이언트의 네트워크 주소\)을 포함하여 요청의 다른 측면이 응답 표현을 선택하는 데 역할을 했을 수 있음을 나타냅니다. 수신자는 요청을 원본 서버로 전달하지 않고는 이 응답이 이후 요청에 적합한지 여부를 결정할 수 없습니다. 프록시는 Vary 필드 값에 "\*"를 생성해서는 안 됩니다.

예를 들어, 다음을 포함하는 응답

```text
   Vary: accept-encoding, accept-language
```

원서버가 이 응답의 콘텐츠를 선택하는 동안 요청의 Accept-Encoding 및 Accept-Language 헤더 필드\(또는 그 필드 부족\)를 결정 요인으로 사용했을 수 있음을 나타냅니다.

필드 이름 목록이 포함된 Vary 필드에는 두 가지 목적이 있습니다.

1. 이후 요청이 원래 요청\(\[CACHING\]의 섹션 4.1\)과 나열된 헤더 필드에 대해 동일한 값을 가지거나 응답을 재사용하지 않는 한 이후 요청을 충족하기 위해 이 응답을 사용해서는 안 된다는 점을 캐시 수신자에게 알리기 위해 원본 서버에서 유효성을 검사합니다. 즉, Vary는 새 요청을 저장된 캐시 항목과 일치시키는 데 필요한 캐시 키를 확장합니다.

1. 이 응답은 콘텐츠 협상\(섹션 12\)의 대상이었으며 나열된 헤더 필드에 다른 값이 제공되는 경우 후속 요청에서 다른 표현이 전송될 수 있음을 사용자 에이전트 수신자에게 알리기 위해\(사전 협상\)

원서버는 해당 응답이 후속 요청에 대해 선택적으로 재사용되기를 원할 때 캐시 가능한 응답에 Vary 헤더 필드를 생성해야 합니다\(SHOULD\). 일반적으로 이는 원본 서버가 요청의 Accept-Language 헤더 필드를 기반으로 응답 언어를 선택한 경우와 같이 헤더 필드를 선택하여 표현된 기본 설정에 더 잘 맞도록 응답 콘텐츠를 맞춤화한 경우입니다.

Vary는 원본 서버가 캐싱에 대한 Vary의 성능 영향보다 콘텐츠 선택의 변화가 덜 중요하다고 간주하는 경우, 특히 캐시 응답 지시문\(\[CACHING\]의 섹션 5.2\)에 의해 재사용이 이미 제한되어 있는 경우 생략될 수 있습니다.

필드 정의\(섹션 11.6.2\)에 따라 다른 사용자에 대한 해당 응답의 재사용이 금지되어 있으므로 Vary에서 Authorization 필드 이름을 보낼 필요가 없습니다. 마찬가지로 응답 내용이 네트워크 지역에 의해 선택되거나 영향을 받았지만 수신자가 한 지역에서 다른 지역으로 이동하더라도 원서버가 캐시된 응답을 재사용하기를 원하는 경우 원서버는 이러한 차이를 표시할 필요가 없습니다. 달라지다.

---
## **13.  Conditional Requests**

조건부 요청은 요청 메서드를 대상 리소스에 적용하기 전에 테스트할 전제 조건을 나타내는 하나 이상의 요청 헤더 필드가 포함된 HTTP 요청입니다. 섹션 13.2에서는 전제 조건을 평가하는 시기와 둘 이상의 전제 조건이 있을 때 우선 순위를 정의합니다.

조건부 GET 요청은 HTTP 캐시 업데이트\[CACHING\]를 위한 가장 효율적인 메커니즘입니다. "업데이트 손실" 문제를 방지하기 위해 PUT 및 DELETE와 같은 상태 변경 메서드에 조건문을 적용할 수도 있습니다. 즉, 한 클라이언트가 병렬로 작동하던 다른 클라이언트의 작업을 실수로 덮어쓰는 문제입니다.

---
### **13.1.  Preconditions**

전제 조건은 일반적으로 대상 리소스의 전체 상태\(현재 값 집합\) 또는 이전에 얻은 표현에서 관찰된 상태\(해당 집합의 한 값\)와 관련하여 정의됩니다. 리소스에 각각 관찰 가능한 상태가 있는 여러 개의 현재 표현이 있는 경우 전제 조건은 선택한 표현\(섹션 3.2\)에 대한 각 요청의 매핑이 시간이 지남에 따라 일관성이 있다고 가정합니다. 그럼에도 불구하고 매핑이 일관되지 않거나 서버가 적절한 표현을 선택할 수 없는 경우 전제 조건이 false로 평가되면 아무런 해가 발생하지 않습니다.

아래에 정의된 각 전제 조건은 대상 리소스의 이전 표현에서 얻은 검증기 집합과 선택한 표현에 대한 검증기의 현재 상태 간의 비교로 구성됩니다\(섹션 8.8\). 따라서 이러한 전제 조건은 클라이언트가 알고 있는 특정 상태 이후 대상 리소스의 상태가 변경되었는지 여부를 평가합니다. 이러한 평가의 효과는 섹션 13.2에 정의된 대로 메서드 의미론과 조건부 선택에 따라 달라집니다.

다른 사양에 의해 확장 필드로 정의된 다른 전제 조건은 모든 수신자, 일반적인 대상 리소스 상태 또는 리소스 그룹에 대한 조건을 배치할 수 있습니다. 예를 들어 WebDAV의 "If" 헤더 필드는 수신자가 해당 필드를 이해하고 구현하는 경우 잠금과 같은 여러 리소스의 다양한 측면에 대한 조건부 요청을 만들 수 있습니다\(\[WEBDAV\], 섹션 10.4\).

전제 조건의 확장성은 알 수 없는 경우\(예: If-Modified-Since\) 전제 조건을 안전하게 무시할 수 있는 경우, 주어진 사용 사례에 대해 배포를 가정할 수 있는 경우 또는 대상 리소스의 다른 속성에 의해 구현이 신호를 받는 경우에만 가능합니다. 이는 공통 표준의 상호 합의된 배포에 중점을 두는 것을 장려합니다.

---
#### **13.1.1.  If-Match**

"If-Match" 헤더 필드는 필드 값이 "\*"일 때 대상 리소스의 현재 표현을 하나 이상 갖거나 다음과 같은 대상 리소스의 현재 표현을 갖는 수신자 원본 서버에서 요청 방법을 조건부로 만듭니다. 필드 값에 제공된 엔터티 태그 목록의 구성원과 일치하는 엔터티 태그입니다.

원서버는 If-Match\(Section 8.8.3.2\)에 대한 엔터티 태그를 비교할 때 강력한 비교 기능을 사용해야 합니다. 클라이언트는 표현 데이터에 변경 사항이 있는 경우 메서드가 적용되는 것을 방지하기 위해 이 전제 조건을 의도하기 때문입니다.

```text
     If-Match = "*" / #entity-tag

   Examples:

   If-Match: "xyzzy"
   If-Match: "xyzzy", "r2d2xxxx", "c3piozzzz"
   If-Match: *
```

If-Match는 여러 사용자 에이전트가 동일한 리소스에서 병렬로 작동할 때 실수로 덮어쓰는 것을 방지하기 위해\(예: "업데이트 손실" 문제 방지\) 상태 변경 방법\(예: POST, PUT, DELETE\)과 함께 가장 자주 사용됩니다. . 일반적으로 선택한 표현의 현재 엔터티 태그가 If-Match 필드 값 내의 멤버가 아닌 경우 요청을 중단하기 위해 표현의 선택 또는 수정과 관련된 모든 방법과 함께 사용할 수 있습니다.

원서버가 표현을 선택하는 요청을 수신하고 그 요청에 If-Match 헤더 필드가 포함되어 있는 경우, 원서버는 방법을 수행하기 전에 섹션 13.2에 따라 If-Match 조건을 평가해야 합니다.

수신된 If-Match 헤더 필드를 평가하려면:

1. 필드 값이 "\*"인 경우 원본 서버에 대상 리소스에 대한 현재 표현이 있으면 조건은 true입니다.

1. 필드 값이 엔터티 태그 목록인 경우 나열된 태그 중 하나라도 선택한 표현의 엔터티 태그와 일치하면 조건은 true입니다.

1. 그렇지 않으면 조건은 거짓입니다.

If-Match 조건을 평가하는 원서버는 조건이 false로 평가되는 경우 요청된 메서드를 수행해서는 안 됩니다. 대신, 원서버는 412\(전제 조건 실패\) 상태 코드로 응답하여 조건부 요청이 실패했음을 나타낼 수 있습니다. 대안으로 요청이 선택된 표현에 이미 적용된 것처럼 보이는 상태 변경 작업인 경우 원서버는 2xx\(성공\) 상태 코드로 응답할 수 있습니다\(즉, 사용자 에이전트가 요청한 변경이 이미 성공했습니다. 그러나 사용자 에이전트는 이를 인식하지 못할 수도 있습니다. 아마도 이전 응답이 손실되었거나 다른 사용자 에이전트에 의해 동등한 변경이 이루어졌기 때문일 수 있습니다.

변경 요청이 이미 적용된 것으로 보일 때 원본 서버가 성공 응답을 보내도록 허용하는 것은 많은 저작 사용 사례에 더 효율적이지만, 여러 사용자 에이전트가 매우 유사하지만 협조적이지 않은 변경 요청을 하는 경우 약간의 위험이 따릅니다. 예를 들어, 공통 리소스에 세마포어\(예: 비원자적 증분\)로 쓰는 여러 사용자 에이전트는 충돌할 가능성이 높으며 잠재적으로 중요한 상태 전환이 손실될 수 있습니다. 이러한 종류의 리소스의 경우 원본 서버는 안전하지 않은 메서드에서 실패한 모든 전제 조건에 대해 412를 엄격하게 보내는 것이 더 좋습니다. 다른 경우에는 성공 응답에서 ETag 필드를 제외하면 사용자 에이전트가 리소스의 현재 상태에 대한 혼란을 없애기 위해 다음 요청으로 GET을 수행하도록 권장할 수 있습니다.

클라이언트는 선택한 표현이 일치하지 않는 경우 412\(전제 조건 실패\) 응답을 선호함을 나타내기 위해 GET 요청에 If-Match 헤더 필드를 보낼 수 있습니다. 그러나 이는 새로운 표현을 원하지 않을 때 이전에 수신된 부분 표현을 완성하기 위한 범위 요청\(섹션 14\)에만 유용합니다. If-Range\(13.1.5절\)는 클라이언트가 새로운 표현 수신을 선호할 때 범위 요청에 더 적합합니다.

캐시나 중개자는 상호 운용성 기능이 원서버에만 필요하기 때문에 If-Match를 무시할 수 있습니다.

"\*" 및 기타 값\("\*"의 다른 인스턴스 포함\)을 포함하는 목록 값이 있는 If-Match 헤더 필드는 구문상 유효하지 않으며\(따라서 생성이 허용되지 않음\) 더 나아가 상호 운용이 불가능할 수도 있습니다.

---
#### **13.1.2.  If-None-Match**

"If-None-Match" 헤더 필드는 필드 값이 "\*"일 때 대상 리소스에 대한 현재 표현이 없거나 엔터티와 함께 ​​선택된 표현이 있는 경우 수신자 캐시 또는 원서버에서 요청 방법을 조건부로 만듭니다. 필드 값에 나열된 것과 일치하지 않는 태그입니다.

수신자는 If-None-Match\(섹션 8.8.3.2\)에 대한 엔터티 태그를 비교할 때 약한 비교 기능을 사용해야 합니다. 약한 엔터티 태그는 표현 데이터가 변경된 경우에도 캐시 유효성 검사에 사용될 수 있기 때문입니다.

```text
     If-None-Match = "*" / #entity-tag

   Examples:

   If-None-Match: "xyzzy"
   If-None-Match: W/"xyzzy"
   If-None-Match: "xyzzy", "r2d2xxxx", "c3piozzzz"
   If-None-Match: W/"xyzzy", W/"r2d2xxxx", W/"c3piozzzz"
   If-None-Match: *
```

If-None-Match는 최소한의 트랜잭션 오버헤드로 캐시된 정보를 효율적으로 업데이트할 수 있도록 조건부 GET 요청에 주로 사용됩니다. 클라이언트가 엔터티 태그가 있는 하나 이상의 저장된 응답을 업데이트하려는 경우 클라이언트는 GET 요청을 할 때 해당 엔터티 태그 목록을 포함하는 If-None-Match 헤더 필드를 생성해야 합니다. 이를 통해 수신자 서버는 저장된 응답 중 하나가 선택한 표현과 일치하는 경우를 나타내기 위해 304\(수정되지 않음\) 응답을 보낼 수 있습니다.

If-None-Match는 클라이언트가 리소스에 현재 표현이 없다고 믿을 때 안전하지 않은 요청 메서드\(예: PUT\)가 대상 리소스의 기존 표현을 실수로 수정하는 것을 방지하기 위해 "\*" 값과 함께 사용할 수도 있습니다. \(섹션 9.2.1\). 이는 둘 이상의 클라이언트가 대상 리소스에 대한 초기 표현을 생성하려고 시도하는 경우 발생할 수 있는 "업데이트 손실" 문제의 변형입니다.

원서버가 표현을 선택하는 요청을 수신하고 그 요청에 If-None-Match 헤더 필드가 포함되어 있는 경우, 원서버는 방법을 수행하기 전에 섹션 13.2에 따라 If-None-Match 조건을 평가해야 합니다.

수신된 If-None-Match 헤더 필드를 평가하려면 다음을 수행하십시오.

1. 필드 값이 "\*"인 경우 원본 서버에 대상 리소스에 대한 현재 표현이 있으면 조건은 false입니다.

1. 필드 값이 엔터티 태그 목록인 경우 나열된 태그 중 하나가 선택한 표현의 엔터티 태그와 일치하면 조건은 false입니다.

1. 그렇지 않으면 조건이 참입니다.

If-None-Match 조건을 평가하는 원서버는 조건이 false로 평가되는 경우 요청된 메서드를 수행해서는 안 됩니다. 대신 원서버는 a\) 요청 방법이 GET 또는 HEAD인 경우 304\(수정되지 않음\) 상태 코드 또는 b\) 다른 모든 요청 방법에 대해 412\(전제 조건 실패\) 상태 코드로 응답해야 합니다.

수신된 If-None-Match 헤더 필드의 캐시 처리에 대한 요구 사항은 \[CACHING\]의 섹션 4.3.2에 정의되어 있습니다.

"\*" 및 기타 값\("\*"의 다른 인스턴스 포함\)을 포함하는 목록 값이 있는 If-None-Match 헤더 필드는 구문상 유효하지 않으며\(따라서 생성이 허용되지 않음\) 더 나아가 상호 운용이 불가능할 수도 있습니다.

---
#### **13.1.3.  If-Modified-Since**

"If-Modified-Since" 헤더 필드는 선택된 표현의 수정 날짜가 필드 값에 제공된 날짜보다 최근인 것을 조건으로 GET 또는 HEAD 요청 메소드를 만듭니다. 해당 데이터가 변경되지 않은 경우 선택한 표현의 데이터 전송이 방지됩니다.

```text
     If-Modified-Since = HTTP-date
```

필드의 예는 다음과 같습니다.

```text
   If-Modified-Since: Sat, 29 Oct 1994 19:43:31 GMT
```

요청에 If-None-Match 헤더 필드가 포함된 경우 수신자는 If-Modified-Since를 무시해야 합니다. If-None-Match의 조건은 If-Modified-Since의 조건을 보다 정확하게 대체하는 것으로 간주되며, If-None-Match를 구현하지 않을 수 있는 이전 중개자와의 상호 운용을 위해서만 두 가지가 결합됩니다.

수신된 필드 값이 유효한 HTTP 날짜가 아니거나 필드 값에 둘 이상의 멤버가 있거나 요청 방법이 GET 또는 HEAD가 아닌 경우 수신자는 If-Modified-Since 헤더 필드를 무시해야 합니다.

리소스에 사용 가능한 수정 날짜가 없는 경우 수신자는 If-Modified-Since 헤더 필드를 무시해야 합니다.

수신자는 원본 서버의 시계 측면에서 If-Modified-Since 필드 값의 타임스탬프를 해석해야 합니다.

If-Modified-Since는 일반적으로 두 가지 별개의 목적으로 사용됩니다. 1\) 엔터티 태그가 없는 캐시된 표현의 효율적인 업데이트를 허용하고 2\) 웹 탐색 범위를 최근 변경된 리소스로 제한합니다.

캐시 업데이트에 사용되는 경우 캐시는 일반적으로 캐시된 메시지의 Last-Modified 헤더 필드 값을 사용하여 If-Modified-Since 필드 값을 생성합니다. 이 동작은 시계가 제대로 동기화되지 않은 경우 또는 서버가 정확한 타임스탬프 일치만 따르도록 선택한 경우\(원본 서버의 시계가 수정될 때 "시간을 거슬러" 돌아가는 것처럼 보이는 Last-Modified 날짜 문제로 인해\) 가장 상호 운용 가능합니다. 또는 보관된 백업에서 표현이 복원됩니다. 그러나 캐시는 때때로 캐시된 메시지의 날짜 헤더 필드 또는 메시지가 수신된 시계 시간과 같은 다른 데이터를 기반으로 필드 값을 생성합니다. 특히 캐시된 메시지에 Last-Modified 헤더 필드가 포함되지 않은 경우 더욱 그렇습니다.

검색 범위를 최근 기간으로 제한하는 데 사용되는 경우 사용자 에이전트는 자체 시계 또는 이전 응답에서 서버로부터 수신된 Date 헤더 필드를 기반으로 If-Modified-Since 필드 값을 생성합니다. 선택한 표현의 Last-Modified 헤더 필드를 기반으로 정확한 타임스탬프 일치를 선택하는 원본 서버는 사용자 에이전트가 지정된 기간 동안 변경된 데이터 전송으로만 데이터 전송을 제한하는 데 도움을 줄 수 없습니다.

원서버가 표현을 선택하는 요청을 수신하고 그 요청이 If-None-Match 헤더 필드 없이 If-Modified-Since 헤더 필드를 포함하는 경우, 원서버는 이전에 섹션 13.2에 따라 If-Modified-Since 조건을 평가해야 합니다. 방법을 수행합니다.

수신된 If-Modified-Since 헤더 필드를 평가하려면:

1. 선택한 표현의 마지막 수정 날짜가 필드 값에 제공된 날짜와 같거나 이전인 경우 조건은 거짓입니다.

1. 그렇지 않으면 조건이 참입니다.

If-Modified-Since 조건을 평가하는 원서버는 조건이 false로 평가되면 요청된 메서드를 수행해서는 안 됩니다. 대신 원본 서버는 이전에 캐시된 응답을 식별하거나 업데이트하는 데 유용한 메타데이터만 포함하여 304\(수정되지 않음\) 응답을 생성해야 합니다\(SHOULD\).

수신된 If-Modified-Since 헤더 필드의 캐시 처리에 대한 요구 사항은 \[CACHING\]의 섹션 4.3.2에 정의되어 있습니다.

---
#### **13.1.4.  If-Unmodified-Since**

"If-Unmodified-Since" 헤더 필드는 선택한 표현의 마지막 수정 날짜가 필드 값에 제공된 날짜보다 빠르거나 같은지에 대한 조건부 요청 방법을 만듭니다. 이 필드는 사용자 에이전트에 표현에 대한 엔터티 태그가 없는 경우 If-Match와 동일한 목적을 수행합니다.

```text
     If-Unmodified-Since = HTTP-date
```

필드의 예는 다음과 같습니다.

```text
   If-Unmodified-Since: Sat, 29 Oct 1994 19:43:31 GMT
```

요청에 If-Match 헤더 필드가 포함되어 있으면 수신자는 If-Unmodified-Since를 무시해야 합니다. If-Match의 조건은 If-Unmodified-Since의 조건을 보다 정확하게 대체하는 것으로 간주되며 If-Match를 구현하지 않을 수 있는 이전 중개자와의 상호 운용을 위해서만 두 가지가 결합됩니다.

수신된 필드 값이 유효한 HTTP 날짜가 아닌 경우\(필드 값이 날짜 목록으로 나타나는 경우 포함\) 수신자는 If-Unmodified-Since 헤더 필드를 무시해야 합니다.

리소스에 사용 가능한 수정 날짜가 없는 경우 수신자는 If-Unmodified-Since 헤더 필드를 무시해야 합니다.

수신자는 원본 서버의If-Unmodified-Since는 상태 변경 방법\(예: POST, PUT, DELETE\)과 함께 가장 자주 사용되어 여러 사용자 에이전트가 해당 표현과 함께 엔터티 태그를 제공하지 않는 리소스에서 병렬로 작동할 수 있는 경우 실수로 덮어쓰는 것을 방지합니다\(예: , "업데이트 손실" 문제를 방지하기 위해\). 일반적으로 선택한 표현의 마지막 수정 날짜가 If-Unmodified-Since 필드 값에 제공된 날짜 이후 변경된 경우 요청을 중단하기 위해 표현 선택 또는 수정과 관련된 모든 방법과 함께 사용할 수 있습니다.

원서버가 표현을 선택하는 요청을 수신하고 그 요청이 If-Match 헤더 필드 없이 If-Unmodified-Since 헤더 필드를 포함하는 경우, 원서버는 다음을 수행하기 전에 섹션 13.2에 따라 If-Unmodified-Since 조건을 평가해야 합니다. 방법.

수신된 If-Unmodified-Since 헤더 필드를 평가하려면:

1. 선택한 표현의 마지막 수정 날짜가 필드 값에 제공된 날짜보다 빠르거나 같은 경우 조건은 true입니다.

1. 그렇지 않으면 조건은 거짓입니다.

If-Unmodified-Since 조건을 평가하는 원서버는 조건이 false로 평가되는 경우 요청된 메서드를 수행해서는 안 됩니다. 대신, 원서버는 412\(전제 조건 실패\) 상태 코드로 응답하여 조건부 요청이 실패했음을 나타낼 수 있습니다. 대안으로, 요청이 선택된 표현에 이미 적용된 것처럼 보이는 상태 변경 작업인 경우, 원서버는 2xx\(성공\) 상태 코드로 응답할 수 있습니다\(즉, 사용자 에이전트가 요청한 변경이 이미 성공했습니다. 그러나 사용자 에이전트는 이를 인식하지 못할 수도 있습니다. 아마도 이전 응답이 손실되었거나 다른 사용자 에이전트에 의해 동등한 변경이 이루어졌기 때문일 수 있습니다.

변경 요청이 이미 적용된 것으로 나타날 때 원본 서버가 성공 응답을 보내도록 허용하는 것은 많은 작성 사용 사례에 더 효율적이지만, 여러 사용자 에이전트가 매우 유사하지만 협조적이지 않은 변경 요청을 하는 경우 약간의 위험이 따릅니다. 이러한 경우 원본 서버는 안전하지 않은 메서드에서 실패한 모든 전제 조건에 대해 412를 엄격하게 보내는 것이 더 좋습니다.

클라이언트는 선택한 표현이 수정된 경우 412\(전제 조건 실패\) 응답을 선호함을 나타내기 위해 GET 요청에 If-Unmodified-Since 헤더 필드를 보낼 수 있습니다. 그러나 이는 새로운 표현을 원하지 않을 때 이전에 수신된 부분 표현을 완성하기 위한 범위 요청\(섹션 14\)에만 유용합니다. If-Range\(13.1.5절\)는 클라이언트가 새로운 표현 수신을 선호할 때 범위 요청에 더 적합합니다.

캐시나 중개자는 상호 운용성 기능이 원서버에만 필요하기 때문에 If-Unmodified-Since를 무시할 수 있습니다.

---
#### **13.1.5.  If-Range**

"If-Range" 헤더 필드는 If-Match 및 If-Unmodified-Since 헤더 필드와 유사하지만 유효성 검사기가 일치하지 않는 경우 수신자에게 Range 헤더 필드를 무시하도록 지시하는 특수 조건부 요청 메커니즘을 제공합니다. 412\(전제 조건 실패\) 응답 대신 새로 선택한 표현을 전송하는 중입니다.

클라이언트가 표현의 부분 복사본을 가지고 있고 전체 표현의 최신 복사본을 갖고자 하는 경우 조건부 GET\(If-Unmodified-Since 및 If 중 하나 또는 둘 다를 사용\)과 함께 Range 헤더 필드를 사용할 수 있습니다. -Match.\) 그러나 표현이 수정되어 전제 조건이 실패하면 클라이언트는 전체 현재 표현을 얻기 위해 두 번째 요청을 해야 합니다.

"If-Range" 헤더 필드를 사용하면 클라이언트가 두 번째 요청을 "단락"할 수 있습니다. 비공식적으로 그 의미는 다음과 같습니다. 표현이 변경되지 않은 경우 Range에서 요청하는 부품을 나에게 보내십시오. 그렇지 않으면 전체 내용을 나에게 보내주십시오.

```text
     If-Range = entity-tag / HTTP-date
```

유효한 엔터티 태그는 DQUOTE의 처음 세 문자를 검사하여 유효한 HTTP 날짜와 구별할 수 있습니다.

클라이언트는 Range 헤더 필드를 포함하지 않는 요청에서 If-Range 헤더 필드를 생성해서는 안 됩니다. 서버는 Range 헤더 필드를 포함하지 않는 요청에서 수신된 If-Range 헤더 필드를 무시해야 합니다. 원서버는 Range 요청을 지원하지 않는 대상 리소스에 대한 요청에서 수신된 If-Range 헤더 필드를 무시해야 합니다\(MUST\).

클라이언트는 약한 것으로 표시된 엔터티 태그를 포함하는 If-Range 헤더 필드를 생성해서는 안 됩니다. 클라이언트는 해당 표현에 대한 엔터티 태그가 없고 날짜가 섹션 8.8.2.2에 정의된 의미에서 강력한 유효성 검사기가 아닌 한 HTTP 날짜를 포함하는 If-Range 헤더 필드를 생성해서는 안 됩니다.

Range 요청에서 If-Range 헤더 필드를 수신하는 서버는 메서드를 수행하기 전에 섹션 13.2에 따라 조건을 평가해야 합니다.

HTTP 날짜가 포함된 수신된 If-Range 헤더 필드를 평가하려면 다음을 수행하세요.

1. 제공된 HTTP 날짜 유효성 검사기가 섹션 8.8.2.2에 정의된 의미에서 강력한 유효성 검사기가 아닌 경우 조건은 false입니다.

1. 제공된 HTTP 날짜 유효성 검사기가 선택한 표현에 대한 Last-Modified 필드 값과 정확하게 일치하는 경우 조건은 true입니다.

1. 그렇지 않으면 조건은 거짓입니다.

엔터티 태그가 포함된 수신된 If-Range 헤더 필드를 평가하려면 다음을 수행하세요.

1. 제공된 엔터티 태그 유효성 검사기가 강력한 비교 기능\(섹션 8.8.3.2\)을 사용하여 선택한 표현에 대한 ETag 필드 값과 정확하게 일치하는 경우 조건은 true입니다.

1. 그렇지 않으면 조건은 거짓입니다.

If-Range 헤더 필드의 수신자는 If-Range 조건이 false로 평가되는 경우 Range 헤더 필드를 무시해야 합니다. 그렇지 않으면 수신자는 요청된 대로 Range 헤더 필드를 처리해야 합니다.

If-Range 비교는 유효성 검사기가 HTTP 날짜인 경우를 포함하여 정확히 일치하므로 If-Unmodified-Since 조건을 평가할 때 사용되는 "이전 또는 같음" 비교와 다릅니다.

---
### **13.2.  Evaluation of Preconditions**
---
#### **13.2.1.  When to Evaluate**

아래에서 제외된 경우를 제외하고 수신자 캐시 또는 원서버는 정상적인 요청 확인을 성공적으로 수행한 후 요청 콘텐츠\(있는 경우\)를 처리하거나 요청 방법과 관련된 작업을 수행하기 직전에 수신된 요청 전제 조건을 평가해야 합니다. 서버는 요청 콘텐츠를 처리하기 전에 해당 조건 없이 동일한 요청에 대한 응답이 2xx\(성공\) 또는 412\(전제 조건 실패\)가 아닌 상태 코드인 경우 수신된 모든 전제 조건을 무시해야 합니다. 즉, 중요한 처리가 발생하기 전에 감지할 수 있는 리디렉션 및 실패가 전제 조건 평가보다 우선합니다.

대상 리소스에 대한 원서버가 아니고 대상 리소스에 대한 요청에 대한 캐시 역할을 할 수 없는 서버는 이 사양에 정의된 조건부 요청 헤더 필드를 평가해서는 안 되며, 요청이 전달되면 이를 전달해야 합니다. 클라이언트를 생성하는 것은 현재 표현을 제공할 수 있는 서버에 의해 평가되도록 의도합니다. 마찬가지로, 서버는 CONNECT, OPTIONS 또는 TRACE와 같은 선택된 표현의 선택이나 수정을 포함하지 않는 요청 방법으로 수신될 때 이 사양에 의해 정의된 조건부 요청 헤더 필드를 무시해야 합니다\(MUST\).

프로토콜 확장은 전제 조건이 평가되는 조건이나 평가 결과를 수정할 수 있습니다. 예를 들어, 불변 캐시 지시어\(\[RFC8246\]에 의해 정의됨\)는 캐시가 새로운 응답을 보유할 때 조건부 요청 전달을 중단하도록 지시합니다.

조건부 요청 헤더 필드는 HEAD 메서드와 함께 사용할 수 있도록 정의되어 있지만\(HEAD의 의미를 GET의 의미와 일관되게 유지하기 위해\) 성공적인 응답의 크기는 304\(수정되지 않음\)와 거의 같기 때문에 조건부 HEAD를 보내는 것은 의미가 없습니다. \) 응답이며 412\(전제 조건 실패\) 응답보다 더 유용합니다.

---
#### **13.2.2.  Precedence of Preconditions**

요청에 둘 이상의 조건부 요청 헤더 필드가 있는 경우 필드가 평가되는 순서가 중요해집니다. 실제로 이 문서에 정의된 필드는 단일 논리적 순서로 일관되게 구현됩니다. 왜냐하면 "업데이트 손실" 전제 조건은 캐시 유효성 검사보다 더 엄격한 요구 사항을 갖고 있고, 검증된 캐시는 부분 응답보다 효율적이며, 엔터티 태그는 다음과 같은 것으로 가정되기 때문입니다. 날짜 유효성 검사기보다 더 정확합니다.

수신자 캐시 또는 원서버는 이 사양에 정의된 요청 전제 조건을 다음 순서로 평가해야 합니다.

1. 수신자가 원본 서버이고 If-Match가 존재하는 경우 If-Match 전제 조건을 평가합니다.

- \* true인 경우 3단계로 진행합니다.

```text
       *  if false, respond 412 (Precondition Failed) unless it can be
          determined that the state-changing request has already
          succeeded (see Section 13.1.1)
```

1. 수신자가 원본 서버이고 If-Match가 존재하지 않고 If-Unmodified-Since가 존재하는 경우 If-Unmodified-Since 전제 조건을 평가합니다.

- \* true인 경우 3단계로 진행합니다.

```text
       *  if false, respond 412 (Precondition Failed) unless it can be
          determined that the state-changing request has already
          succeeded (see Section 13.1.4)
```

1. If-None-Match가 있는 경우 If-None-Match 전제 조건을 평가합니다.

- \* true인 경우 5단계로 진행합니다.

- \* GET/HEAD가 false인 경우 304\(수정되지 않음\)를 응답합니다.

- \* 다른 방법이 false인 경우 412\(Precondition Failed\)를 응답합니다.

1. 메서드가 GET 또는 HEAD이고 If-None-Match가 존재하지 않고 If-Modified-Since가 존재하는 경우 If-Modified-Since 전제 조건을 평가합니다.

- \* true인 경우 5단계로 진행합니다.

- \* 거짓인 경우 304\(수정되지 않음\) 응답

1. 메서드가 GET이고 Range와 If-Range가 모두 존재하는 경우 If-Range 전제 조건을 평가합니다.

```text
       *  if true and the Range is applicable to the selected
          representation, respond 206 (Partial Content)
```

- \* 그렇지 않으면 Range 헤더 필드를 무시하고 200\(OK\)을 응답합니다.

```text
   6.  Otherwise,

       *  perform the requested method and respond according to its
          success or failure.
```

추가 조건부 요청 헤더 필드를 정의하는 HTTP 확장은 이 문서에 정의된 필드 및 실제로 발견될 수 있는 기타 조건과 관련하여 해당 필드를 평가하는 순서를 정의해야 합니다.

---
## **14.  Range Requests**

요청 취소 또는 연결 끊김으로 인해 클라이언트에서 데이터 전송이 중단되는 경우가 종종 있습니다. 클라이언트가 부분 표현을 저장한 경우 전체 표현을 전송하는 대신 후속 요청에서 해당 표현의 나머지 부분을 요청하는 것이 바람직합니다. 마찬가지로 로컬 저장 공간이 제한된 장치는 매우 큰 문서의 단일 페이지나 삽입된 이미지의 크기와 같은 더 큰 표현의 하위 집합만 요청할 수 있다는 이점을 누릴 수 있습니다.

범위 요청은 HTTP의 선택적 기능으로, 이 기능을 구현하지 않는\(또는 대상 리소스에 대해 지원하지 않는\) 수신자가 상호 운용성에 영향을 주지 않고 일반 GET 요청인 것처럼 응답할 수 있도록 설계되었습니다. 부분 응답은 기능을 구현하지 않을 수 있는 캐시에 의해 전체 응답으로 착각되지 않도록 고유한 상태 코드로 표시됩니다.

---
### **14.1.  Range Units**

표현 데이터는 해당 데이터의 콘텐츠 코딩이나 미디어 유형에 고유한 주소 지정 가능한 구조 단위가 있는 경우 하위 범위로 분할될 수 있습니다. 예를 들어, 옥텟\(일명 바이트\) 경계는 모든 표현 데이터에 공통된 구조 단위로, 데이터의 파티션이 해당 데이터의 시작 또는 끝에서 일부 오프셋에 있는 바이트 범위로 식별될 수 있도록 합니다.

"범위 단위"에 대한 이 일반적인 개념은 범위 요청에 대한 지원을 알리기 위해 Accept-Ranges\(Section 14.3\) 응답 헤더 필드에서 사용되며, Range\(Section 14.2\) 요청 헤더 필드에서는 요청된 표현 부분을 기술합니다. 표현의 어느 부분이 전송되는지 설명하는 Content-Range\(14.4절\) 헤더 필드.

```text
     range-unit       = token
```

모든 범위 단위 이름은 대소문자를 구분하지 않으며 섹션 16.5.1에 ​​정의된 대로 "HTTP 범위 단위 레지스트리" 내에 등록되어야 합니다.

범위 단위는 섹션 16.5에 설명된 대로 확장 가능하도록 고안되었습니다.

---
#### **14.1.1.  Range Specifiers**

범위는 범위 지정자 세트와 쌍을 이루는 범위 단위로 표현됩니다. 범위 단위 이름은 자체 지정자에 적용할 수 있는 range-spec의 종류를 결정합니다. 따라서 다음 문법은 일반적입니다. 각 범위 단위는 int-range, suffix-range 및 other-range가 허용되는 경우에 대한 요구 사항을 지정해야 합니다.

범위 요청은 단일 범위 또는 단일 표현 내의 범위 집합을 지정할 수 있습니다.

```text
     ranges-specifier = range-unit "=" range-set
     range-set        = 1#range-spec
     range-spec       = int-range
                      / suffix-range
                      / other-range
```

int-range는 표현 데이터의 끝까지 음이 아닌 두 개의 정수 또는 음이 아닌 하나의 정수로 표현되는 범위입니다. 범위 단위는 정수의 의미를 지정합니다\(예: 처음부터의 단위 오프셋, 숫자가 지정된 부분 포함 등을 나타낼 수 있음\).

```text
     int-range     = first-pos "-" [ last-pos ]
     first-pos     = 1*DIGIT
     last-pos      = 1*DIGIT
```

마지막 위치 값이 존재하고 첫 번째 위치 값보다 작으면 int 범위가 유효하지 않습니다.

Suffix-range는 음수가 아닌 정수 최대 길이\(범위 단위\)를 제공하여 표현 데이터의 접미사로 표현되는 범위입니다. 즉, 표현데이터의 마지막 N개 단위이다.

```text
     suffix-range  = "-" suffix-length
     suffix-length = 1*DIGIT
```

확장성을 제공하기 위해 other-range 규칙은 애플리케이션별 또는 향후 범위 단위가 추가 범위 지정자를 정의할 수 있도록 하는 거의 제한되지 않은 문법입니다.

```text
     other-range   = 1*( %x21-2B / %x2D-7E )
                   ; 1*(VCHAR excluding comma)
```

표시된 범위 단위에 대해 유효하지 않거나 정의되지 않은 범위 사양이 포함된 경우 범위 지정자는 유효하지 않습니다.

유효한 ranges-specifier는 표시된 range-unit에 정의된 대로 만족할 수 있는 range-spec을 하나 이상 포함하는 경우 "satisfiable"입니다. 그렇지 않으면 범위 지정자는 "만족할 수 없습니다".

---
#### **14.1.2.  Byte Ranges**

"바이트" 범위 단위는 표현 데이터의 옥텟 시퀀스의 하위 범위를 표현하는 데 사용됩니다. 각 바이트 범위는 표현 데이터의 시작\(int-range\) 또는 끝\(suffix-range\)을 기준으로 일부 오프셋에서 정수 범위로 표현됩니다. 바이트 범위는 other-range 지정자를 사용하지 않습니다.

바이트 int-range의 첫 번째 위치 값은 범위의 첫 번째 바이트의 오프셋을 제공합니다. last-pos 값은 범위 내 마지막 바이트의 오프셋을 제공합니다. 즉, 지정된 바이트 위치가 포함됩니다. 바이트 오프셋은 0부터 시작합니다.

표현 데이터에 적용된 콘텐츠 코딩이 있는 경우 각 바이트 범위는 디코딩 후 얻을 수 있는 기본 바이트 시퀀스가 ​​아니라 인코딩된 바이트 시퀀스를 기준으로 계산됩니다.

바이트 범위 지정자의 예:

\* 처음 500바이트\(바이트 오프셋 0-499 포함\):

```text
           bytes=0-499
```

\* 두 번째 500바이트\(바이트 오프셋 500-999 포함\):

```text
           bytes=500-999
```

클라이언트는 선택된 표현의 크기를 알지 못한 채 요청된 바이트 수를 제한할 수 있습니다. last-pos 값이 없거나 값이 표현 데이터의 현재 길이보다 크거나 같은 경우 바이트 범위는 표현의 나머지 부분으로 해석됩니다\(즉, 서버는 last-pos의 값을 대체합니다\) 선택한 표현의 현재 길이보다 1 작은 값으로\).

클라이언트는 접미사 범위를 사용하여 선택한 표현의 마지막 N 바이트\(N \> 0\)를 참조할 수 있습니다. 선택한 표현이 지정된 suffix-length보다 짧은 경우 전체 표현이 사용됩니다.

길이가 10000이라고 가정하는 추가 예:

\* 마지막 500바이트\(바이트 오프셋 9500-9999 포함\):

```text
           bytes=-500

      Or:

           bytes=9500-
```

\* 첫 번째 및 마지막 바이트만\(바이트 0 및 9999\):

```text
           bytes=0-0,-1
```

\* 첫 번째, 중간, 마지막 1000바이트:

```text
           bytes= 0-999, 4500-5499, -1000
```

\* 두 번째 500바이트의 기타 유효한\(표준은 아님\) 사양\(바이트 오프셋 500-999 포함\):

```text
           bytes=500-600,601-999
           bytes=500-700,601-999
```

GET 요청의 경우 유효한 바이트 범위 사양은 다음 중 하나에 해당하는 경우 충족됩니다.

\* 선택된 표현의 현재 길이보다 작은 첫 번째 위치를 가진 내부 범위 또는

\* 접미사 길이가 0이 아닌 접미사 범위.

선택된 표현의 길이가 0인 경우 GET 요청에서 만족할 수 있는 유일한 범위 사양 형식은 0이 아닌 suffix-length를 갖는 suffix-range입니다.

바이트 범위 구문에서 first-pos, last-pos 및 suffix-length는 10진수 옥텟으로 표현됩니다. 콘텐츠 길이에 미리 정의된 제한이 없으므로 수신자는 잠재적으로 큰 십진수를 예상하고 정수 변환 오버플로로 인한 구문 분석 오류를 방지해야 합니다.

---
### **14.2.  Range**

GET 요청의 "Range" 헤더 필드는 선택된 표현 전체가 아닌 선택된 표현 데이터\(8.1절\)의 하나 이상의 하위 범위만 전송하도록 요청하도록 메소드 의미를 수정합니다.

```text
     Range = ranges-specifier
```

서버는 Range 헤더 필드를 무시할 수 있습니다. 그러나 원본 서버와 중간 캐시는 부분적으로 실패한 전송 및 대규모 표현의 부분 검색으로부터 효율적인 복구를 지원하므로 가능하면 바이트 범위를 지원해야 합니다.

서버는 인식되지 않거나 범위 처리가 정의되지 않은 요청 방법으로 수신된 Range 헤더 필드를 무시해야 합니다. 이 사양의 경우 GET은 범위 처리가 정의되는 유일한 방법입니다.

원서버는 자신이 이해하지 못하는 범위 단위를 포함하는 Range 헤더 필드를 무시해야 합니다. 프록시는 이해하지 못하는 범위 단위를 포함하는 Range 헤더 필드를 삭제할 수 있습니다.

범위 요청을 지원하는 서버는 유효하지 않은 범위 지정자\(섹션 14.1.1\), 두 개 이상의 겹치는 범위가 있는 범위 지정자 또는 나열되지 않은 많은 작은 범위 집합을 포함하는 Range 헤더 필드를 무시하거나 거부할 수 있습니다. 이는 클라이언트가 손상되었거나 고의적인 서비스 거부 공격이 있음을 나타 내기 때문에 오름차순으로 표시됩니다\(17.15절\). 클라이언트는 동일한 데이터를 포함하는 단일 범위보다 처리 및 전송 효율성이 본질적으로 떨어지는 여러 범위를 요청해서는 안 됩니다.

범위 요청을 지원하는 서버는 선택된 표현에 내용이 없을 때\(즉, 선택된 표현의 데이터 길이가 0인 경우\) Range 헤더 필드를 무시할 수 있습니다.

여러 범위를 요청하는 클라이언트는 이후 부분을 더 일찍 요청해야 하는 특정 요구가 없는 한 해당 범위를 오름차순\(일반적으로 완전한 표현으로 수신되는 순서\)으로 나열해야 합니다. 예를 들어, 부분의 내부 카탈로그가 있는 큰 표현을 처리하는 사용자 에이전트는 특히 표현이 역순으로 저장된 페이지로 구성되어 있고 사용자 에이전트가 한 번에 한 페이지를 전송하려는 경우 나중에 부분을 먼저 요청해야 할 수 있습니다.

Range 헤더 필드는 섹션 13.1에 정의된 전제조건 헤더 필드를 평가한 후 Range 헤더 필드가 없는 결과가 200\(OK\) 응답인 경우에만 평가됩니다. 즉, 조건부 GET으로 인해 304\(수정되지 않음\) 응답이 발생하면 Range가 무시됩니다.

If-Range 헤더 필드\(Section 13.1.5\)는 Range 헤더 필드를 적용하기 위한 전제 조건으로 사용될 수 있습니다.

모든 전제 조건이 true인 경우 서버는 대상 리소스에 대한 Range 헤더 필드를 지원하고 수신된 Range 필드 값에는 해당 대상 리소스에 대해 지원되는 범위 단위가 있는 유효한 범위 지정자가 포함되며 해당 범위 지정자는 만족됩니다. 선택된 표현과 관련하여 서버는 요청된 만족 가능한 범위 사양에 해당하는 하나 이상의 부분 표현을 포함하는 콘텐츠와 함께 206\(부분 콘텐츠\) 응답을 보내야 합니다.

위의 내용은 서버가 요청된 모든 범위를 전송한다는 의미는 아닙니다. 어떤 경우에는 요청된 범위의 일부만 먼저 보내는 것이 가능\(또는 효율적\)할 수 있으며 클라이언트가 여전히 원할 경우 나머지 부분을 나중에 다시 요청하기를 기대합니다\(섹션 15.3.7 참조\).

모든 전제 조건이 true인 경우 서버는 대상 리소스에 대한 Range 헤더 필드를 지원하고, 수신된 Range 필드 값에는 유효한 ranges-specifier가 포함되며, range-unit은 해당 대상 리소스 또는 범위에 대해 지원되지 않습니다. 지정자가 선택한 표현과 관련하여 만족스럽지 않으면 서버는 416\(Range Not Satisfiable\) 응답을 보내야 합니다.

---
### **14.3.  Accept-Ranges**

응답의 "Accept-Ranges" 필드는 업스트림 서버가 대상 리소스에 대한 범위 요청을 지원하는지 여부를 나타냅니다.

```text
     Accept-Ranges     = acceptable-ranges
     acceptable-ranges = 1#range-unit
```

예를 들어 바이트 범위 요청\(섹션 14.1.2\)을 지원하는 서버는 다음 필드를 보낼 수 있습니다.

```text
   Accept-Ranges: bytes
```

해당 대상 리소스에 대한 바이트 범위 요청을 지원함을 나타내므로 동일한 요청 경로에서 향후 부분 요청에 대해 클라이언트의 사용을 장려합니다. 범위 단위는 섹션 14.1에 정의되어 있습니다.

클라이언트는 Accept-Ranges 필드 수신 여부에 관계없이 범위 요청을 생성할 수 있습니다. 이 정보는 성능을 향상하고 불필요한 네트워크 전송을 줄이기 위한 조언만 제공합니다.

반대로 클라이언트는 Accept-Ranges 필드를 수신하면 향후 범위 요청이 부분 응답을 반환한다는 의미라고 가정해서는 안 됩니다. 콘텐츠가 변경될 수 있고, 서버가 특정 시간이나 특정 조건에서만 범위 요청을 지원할 수도 있고, 다른 중개자가 다음 요청을 처리할 수도 있습니다.

대상 리소스에 대한 어떤 종류의 범위 요청도 지원하지 않는 서버는 다음을 보낼 수 있습니다.

```text
   Accept-Ranges: none
```

클라이언트에게 동일한 요청 경로에서 범위 요청을 시도하지 않도록 조언합니다. 범위 단위 "none"은 이 목적으로 예약되어 있습니다.

Accept-Ranges 필드는 트레일러 섹션에서 전송될 수 있지만 헤더 필드로 전송되는 것이 선호됩니다. 왜냐하면 이 정보는 중간 콘텐츠\(트레일러 섹션이 수신되기 전\)에서 실패한 대규모 정보 전송을 다시 시작하는 데 특히 유용하기 때문입니다.

---
### **14.4.  Content-Range**

"Content-Range" 헤더 필드는 메시지 콘텐츠로 포함된 선택된 표현의 부분 범위를 나타내기 위해 단일 부분 206\(부분 콘텐츠\) 응답으로 전송되며, 내부에 포함된 범위를 나타내기 위해 멀티파트 206 응답의 각 부분으로 전송됩니다. 각 신체 부위\(섹션 14.6\)를 선택하고 416\(Range Not Satisfiable\) 응답을 보내 선택한 표현에 대한 정보를 제공합니다.

```text
     Content-Range       = range-unit SP
                           ( range-resp / unsatisfied-range )

     range-resp          = incl-range "/" ( complete-length / "*" )
     incl-range          = first-pos "-" last-pos
     unsatisfied-range   = "*/" complete-length

     complete-length     = 1*DIGIT
```

206\(부분 콘텐츠\) 응답에 수신자가 이해할 수 없는 범위 단위\(섹션 14.1\)가 있는 Content-Range 헤더 필드가 포함되어 있는 경우 수신자는 이를 저장된 표현과 재결합하려고 시도해서는 안 됩니다. 그러한 메시지를 수신한 프록시는 이를 다운스트림으로 전달해야 합니다.

Content-Range는 클라이언트와 원본 서버 간의 비공개 계약을 기반으로 섹션 14.5에 설명된 대로 부분 PUT를 요청하기 위한 요청 수정자로 전송될 수도 있습니다. 서버는 Content-Range 지원이 정의되지 않은 메소드를 사용하여 요청에서 수신된 Content-Range 헤더 필드를 무시해야 합니다\(MUST\).

바이트 범위의 경우 전체 길이를 알 수 없거나 결정하기 어려운 경우를 제외하고 발신자는 범위가 추출된 표현의 전체 길이를 표시해야 합니다. 전체 길이 대신 별표 문자\("\*"\)는 헤더 필드가 생성될 때 표현 길이를 알 수 없음을 나타냅니다.

다음 예는 선택한 표현의 전체 길이가 보낸 사람에 의해 1234바이트로 알려진 경우를 보여줍니다.

```text
   Content-Range: bytes 42-1233/1234
```

이 두 번째 예는 전체 길이를 알 수 없는 경우를 보여줍니다.

```text
   Content-Range: bytes 42-1233/*
```

Content-Range 필드 값은 last-pos 값이 first-pos 값보다 작거나 전체 길이 값이 last-pos 값보다 작거나 같은 range-resp를 포함하는 경우 유효하지 않습니다. 유효하지 않은 Content-Range의 수신자는 수신된 콘텐츠를 저장된 표현과 재결합하려고 시도해서는 안 됩니다.

바이트 범위 요청에 대한 416\(Range Not Satisfiable\) 응답을 생성하는 서버는 다음 예와 같이 충족되지 않은 범위 값이 포함된 Content-Range 헤더 필드를 보내야 합니다.

```text
   Content-Range: bytes */1234
```

416 응답의 전체 길이는 선택한 표현의 현재 길이를 나타냅니다.

Content-Range 헤더 필드는 해당 의미를 명시적으로 설명하지 않는 상태 코드에는 의미가 없습니다. 이 사양에서는 206\(부분 콘텐츠\) 및 416\(범위가 만족스럽지 않음\) 상태 코드만 Content-Range의 의미를 설명합니다.

다음은 선택한 표현에 총 1234바이트가 포함된 Content-Range 값의 예입니다.

\* 처음 500바이트:

```text
      Content-Range: bytes 0-499/1234
```

\* 두 번째 500바이트:

```text
      Content-Range: bytes 500-999/1234
```

\* 처음 500바이트를 제외한 모든 항목:

```text
      Content-Range: bytes 500-1233/1234
```

\* 마지막 500바이트:

```text
      Content-Range: bytes 734-1233/1234
```

---
### **14.5.  Partial PUT**

일부 원본 서버는 사용자 에이전트가 요청에서 Content-Range 헤더 필드\(14.4절\)를 보낼 때 부분 표현의 PUT를 지원하지만, 이러한 지원은 일관성이 없으며 사용자 에이전트와의 비공개 계약에 따라 다릅니다. 일반적으로 대상 리소스의 상태가 Content-Range 값으로 표시된 오프셋과 길이에서 포함된 콘텐츠로 부분적으로 대체되도록 요청합니다. 여기서 오프셋은 현재 선택된 표현을 기준으로 합니다.

원본 서버는 부분 PUT 요청을 지원하지 않는 대상 리소스에 대해 PUT에서 Content-Range를 수신하는 경우 400\(잘못된 요청\) 상태 코드로 응답해야 합니다.

부분 PUT은 PUT의 원래 정의와 역호환되지 않습니다. 이로 인해 콘텐츠가 현재 표현을 완전히 대체하여 작성될 수 있습니다.

부분 리소스 업데이트는 더 큰 리소스의 일부를 겹치거나 확장하는 상태로 별도로 식별된 리소스를 대상으로 하거나 부분 업데이트에 대해 특별히 정의된 다른 방법\(예: \[RFC5789에 정의된 PATCH 방법\)을 사용하여 가능합니다. \]\).

---
### **14.6.  Media Type multipart/byteranges**

206\(부분 콘텐츠\) 응답 메시지에 여러 범위의 콘텐츠가 포함된 경우 미디어 유형이 "multipart/byteranges"인 다중 부분 메시지 본문\(\[RFC2046\], 섹션 5.1\)의 본문 부분으로 전송됩니다.

"multipart/byteranges" 미디어 유형에는 각각 고유한 Content-Type 및 Content-Range 필드가 있는 하나 이상의 본문 부분이 포함됩니다. 필수 경계 매개변수는 각 신체 부분을 구분하는 데 사용되는 경계 문자열을 지정합니다.

```text
   Implementation Notes:
```

1. 추가 CRLF는 본문의 첫 번째 경계 문자열 앞에 올 수 있습니다.

1. \[RFC2046\]에서는 경계 문자열을 인용하는 것을 허용하지만 일부 기존 구현에서는 인용된 경계 문자열을 잘못 처리합니다.

1. 다수의 클라이언트와 서버가 "multipart/x-byteranges" 미디어 유형을 사용하는 byteranges 사양의 초기 초안으로 코딩되었습니다. 이는 이 유형과 거의\(그러나 완전히는 아니지만\) 호환됩니다.

이름에도 불구하고 "multipart/byteranges" 미디어 유형은 바이트 범위로 제한되지 않습니다. 다음 예에서는 "exampleunit" 범위 단위를 사용합니다.

```text
   HTTP/1.1 206 Partial Content
   Date: Tue, 14 Nov 1995 06:25:24 GMT
   Last-Modified: Tue, 14 July 04:58:08 GMT
   Content-Length: 2331785
   Content-Type: multipart/byteranges; boundary=THIS_STRING_SEPARATES

   --THIS_STRING_SEPARATES
   Content-Type: video/example
   Content-Range: exampleunit 1.2-4.3/25

   ...the first range...
   --THIS_STRING_SEPARATES
   Content-Type: video/example
   Content-Range: exampleunit 11.2-14.3/25

   ...the second range
   --THIS_STRING_SEPARATES--
```

다음 정보는 "multipart/byteranges" 미디어 유형에 대한 등록 양식 역할을 합니다.

```text
   Type name:  multipart

   Subtype name:  byteranges

   Required parameters:  boundary

   Optional parameters:  N/A
```

인코딩 고려 사항: "7bit", "8bit" 또는 "binary"만 허용됩니다.

```text
   Security considerations:  see Section 17

   Interoperability considerations:  N/A

   Published specification:  RFC 9110 (see Section 14.6)
```

이 미디어 유형을 사용하는 애플리케이션: 단일 요청에서 여러 범위를 지원하는 HTTP 구성 요소

```text
   Fragment identifier considerations:  N/A
```

추가 정보: 이 유형에 대해 더 이상 사용되지 않는 별칭 이름: 해당 없음

```text
                            Magic number(s):  N/A

                            File extension(s):  N/A

                            Macintosh file type code(s):  N/A
```

자세한 내용은 연락할 사람 및 이메일 주소: 작성자의 주소 섹션을 참조하세요.

```text
   Intended usage:  COMMON
```

이용 제한 : 해당 없음

```text
   Author:  See Authors' Addresses section.

   Change controller:  IESG
```

---
## **15.  Status Codes**

응답의 상태 코드는 요청 성공 여부와 포함된 콘텐츠\(있는 경우\)를 포함하여 요청 결과와 응답 의미를 설명하는 3자리 정수 코드입니다. 모든 유효한 상태 코드는 100\~599 범위 내에 있습니다.

상태 코드의 첫 번째 숫자는 응답 클래스를 정의합니다. 마지막 두 자리에는 분류 역할이 없습니다. 첫 번째 숫자에는 5개의 값이 있습니다.

\* 1xx\(정보\): 요청이 수신되었으며 프로세스가 계속됩니다.

\* 2xx\(성공\): 요청이 성공적으로 수신되고 이해되었으며 수락되었습니다.

\* 3xx\(리디렉션\): 요청을 완료하려면 추가 조치가 필요합니다.

\* 4xx\(클라이언트 오류\): 요청에 잘못된 구문이 포함되어 있거나 처리할 수 없습니다.

\* 5xx\(서버 오류\): 서버가 명백히 유효한 요청을 이행하지 못했습니다.

HTTP 상태 코드는 확장 가능합니다. 클라이언트가 등록된 모든 상태 코드의 의미를 이해할 필요는 없지만 그러한 이해가 바람직하다는 것은 분명합니다. 그러나 클라이언트는 첫 번째 숫자로 표시된 모든 상태 코드의 클래스를 이해해야 하며 인식할 수 없는 상태 코드를 해당 클래스의 x00 상태 코드와 동일한 것으로 처리해야 합니다.

예를 들어, 클라이언트가 인식할 수 없는 상태 코드 471을 수신하면 첫 번째 숫자에서 요청에 문제가 있음을 확인하고 응답을 400\(잘못된 요청\) 상태 코드를 수신한 것처럼 처리할 수 있습니다. 응답 메시지에는 일반적으로 상태를 설명하는 표현이 포함됩니다.

100..599 범위 밖의 값은 유효하지 않습니다. 구현에서는 HTTP가 아닌 상태\(예: 라이브러리 오류\)의 내부 통신을 위해 해당 범위\(예: 600..999\)를 벗어난 세 자리 정수 값을 사용하는 경우가 많습니다. 유효하지 않은 상태 코드가 포함된 응답을 수신한 클라이언트는 마치 5xx\(서버 오류\) 상태 코드가 있는 것처럼 응답을 처리해야 합니다.

단일 요청에는 여러 관련 응답이 있을 수 있습니다. "정보"\(1xx\) 범위의 상태 코드가 있는 0개 이상의 "중간"\(최종 아님\) 응답과 다음 중 하나의 상태 코드가 있는 정확히 하나의 "최종" 응답이 뒤따릅니다. 다른 범위.

---
### **15.1.  Overview of Status Codes**

아래 나열된 상태 코드는 이 사양에 정의되어 있습니다. 여기에 나열된 이유 문구는 단지 권장사항일 뿐입니다. 프로토콜에 영향을 주지 않고 해당 지역의 문구로 대체하거나 완전히 생략할 수 있습니다.

경험적으로 캐시할 수 있는 것으로 정의된 상태 코드\(예: 이 사양에서는 200, 203, 204, 206, 300, 301, 308, 404, 405, 410, 414 및 501\)가 있는 응답은 경험적 만료가 있는 캐시에서 재사용할 수 있습니다. 메소드 정의 또는 명시적인 캐시 제어 \[CACHING\]에 의해 달리 지정되지 않는 한; 다른 모든 상태 코드는 경험적으로 캐시할 수 없습니다.

이 사양의 범위를 벗어나는 추가 상태 코드는 HTTP에서 사용하도록 지정되었습니다. 이러한 모든 상태 코드는 섹션 16.2에 설명된 대로 "HTTP\(Hypertext Transfer Protocol\) 상태 코드 레지스트리" 내에 등록되어야 합니다.

---
### **15.2.  Informational 1xx**

상태 코드의 1xx\(정보\) 클래스는 요청된 작업을 완료하고 최종 응답을 보내기 전에 연결 상태 또는 요청 진행 상황을 전달하기 위한 임시 응답을 나타냅니다. HTTP/1.0은 1xx 상태 코드를 정의하지 않았으므로 서버는 HTTP/1.0 클라이언트에 1xx 응답을 보내서는 안 됩니다.

1xx 응답은 헤더 섹션이 끝나면 종료됩니다. 콘텐츠나 예고편을 포함할 수 없습니다.

클라이언트는 최종 응답을 기대하지 않더라도 최종 응답 이전에 수신된 하나 이상의 1xx 응답을 구문 분석할 수 있어야 합니다\(MUST\). 사용자 에이전트는 예상치 못한 1xx 응답을 무시할 수 있습니다.

프록시 자체가 1xx 응답 생성을 요청하지 않는 한 프록시는 1xx 응답을 전달해야 합니다. 예를 들어 프록시가 요청을 전달할 때 "Expect: 100-continue" 헤더 필드를 추가하면 해당 100\(Continue\) 응답을 전달할 필요가 없습니다.

---
#### **15.2.1.  100 Continue**

100\(계속\) 상태 코드는 요청의 초기 부분이 수신되었으며 서버에서 아직 거부되지 않았음을 나타냅니다. 서버는 요청이 완전히 수신되어 조치를 취한 후에 최종 응답을 보내려고 합니다.

요청에 100-continue 기대치를 포함하는 Expect 헤더 필드가 포함되어 있는 경우, 100 응답은 섹션 10.1.1에 설명된 대로 서버가 요청 콘텐츠를 수신하기를 원한다는 것을 나타냅니다. 클라이언트는 요청을 계속 보내고 100 응답을 삭제해야 합니다.

요청에 100-continue 기대치를 포함하는 Expect 헤더 필드가 포함되어 있지 않은 경우 클라이언트는 이 임시 응답을 간단히 삭제할 수 있습니다.

---
#### **15.2.2.  101 Switching Protocols**

101\(스위칭 프로토콜\) 상태 코드는 서버가 업그레이드 헤더 필드\(섹션 7.8\)를 통해 이 연결에서 사용되는 애플리케이션 프로토콜의 변경에 대한 클라이언트의 요청을 이해하고 이를 준수할 의향이 있음을 나타냅니다. 서버는 이 응답 후에 어떤 프로토콜이 적용될 것인지를 나타내는 응답에서 업그레이드 헤더 필드를 생성해야 합니다.

서버는 프로토콜 전환이 유리한 경우에만 프로토콜 전환에 동의한다고 가정합니다. 예를 들어, 최신 버전의 HTTP로 전환하는 것은 이전 버전보다 유리할 수 있으며, 실시간 동기 프로토콜로 전환하는 것은 이러한 기능을 사용하는 리소스를 전달할 때 유리할 수 있습니다.

---
### **15.3.  Successful 2xx**

상태 코드의 2xx\(성공\) 클래스는 클라이언트의 요청이 성공적으로 수신, 이해 및 승인되었음을 나타냅니다.

---
#### **15.3.1.  200 OK**

200\(OK\) 상태 코드는 요청이 성공했음을 나타냅니다. 200 응답으로 전송되는 콘텐츠는 요청 방법에 따라 다릅니다. 본 사양에서 정의한 방법에 대해 내용의 의도된 의미는 다음과 같이 요약될 수 있습니다.

```text
   +================+============================================+
   | Request Method | Response content is a representation of:   |
   +================+============================================+
   | GET            | the target resource                        |
   +----------------+--------------------------------------------+
   | HEAD           | the target resource, like GET, but without |
   |                | transferring the representation data       |
   +----------------+--------------------------------------------+
   | POST           | the status of, or results obtained from,   |
   |                | the action                                 |
   +----------------+--------------------------------------------+
   | PUT, DELETE    | the status of the action                   |
   +----------------+--------------------------------------------+
   | OPTIONS        | communication options for the target       |
   |                | resource                                   |
   +----------------+--------------------------------------------+
   | TRACE          | the request message as received by the     |
   |                | server returning the trace                 |
   +----------------+--------------------------------------------+

                               Table 6
```

CONNECT에 대한 응답 외에도 메시지 프레이밍에서 내용의 길이가 0임을 명시적으로 나타내지 않는 한 200 응답에는 메시지 내용이 포함될 것으로 예상됩니다. 요청의 일부 측면에서 성공 시 콘텐츠 없음을 선호하는 것으로 나타나면 원본 서버는 대신 204\(No Content\) 응답을 보내야 합니다. CONNECT의 경우 성공적인 결과는 200 응답 헤더 섹션 바로 다음에 시작되는 터널이므로 콘텐츠가 없습니다.

200 응답은 경험적으로 캐시 가능합니다. 즉, 메서드 정의나 명시적인 캐시 제어로 달리 지정되지 않는 한\(\[CACHING\]의 섹션 4.2.2 참조\)

GET 또는 HEAD에 대한 200개의 응답에서 원서버는 강력한 엔터티 태그와 Last-Modified 날짜가 모두 선호되는 선택된 표현에 대해 사용 가능한 유효성 검사기 필드\(8.8절\)를 보내야 합니다.

상태 변경 메서드에 대한 200개의 응답에서 응답으로 전송된 모든 유효성 검사기 필드\(8.8절\)는 요청 의미 체계를 성공적으로 적용한 결과 형성된 새로운 표현에 대한 현재 유효성 검사기를 전달합니다. PUT 방법\(섹션 9.3.4\)에는 그러한 유효성 검사기를 보내는 것을 방지할 수 있는 추가 요구 사항이 있습니다.

---
#### **15.3.2.  201 Created**

201\(생성됨\) 상태 코드는 요청이 이행되어 하나 이상의 새 리소스가 생성되었음을 나타냅니다. 요청에 의해 생성된 기본 리소스는 응답의 Location 헤더 필드로 식별되거나 Location 헤더 필드가 수신되지 않은 경우 대상 URI로 식별됩니다.

201 응답 콘텐츠는 일반적으로 생성된 리소스를 설명하고 이에 대한 링크를 제공합니다. 응답으로 전송된 모든 유효성 검사기 필드\(섹션 8.8\)는 요청에 의해 생성된 새로운 표현에 대한 현재 유효성 검사기를 전달합니다. PUT 방법\(섹션 9.3.4\)에는 그러한 유효성 검사기를 보내는 것을 방지할 수 있는 추가 요구 사항이 있습니다.

---
#### **15.3.3.  202 Accepted**

202\(수락됨\) 상태 코드는 요청 처리가 승인되었지만 처리가 완료되지 않았음을 나타냅니다. 요청이 실제로 처리될 때 허용되지 않을 수 있으므로 결국에는 요청이 실행될 수도 있고 실행되지 않을 수도 있습니다. HTTP에는 비동기 작업에서 상태 코드를 다시 보내는 기능이 없습니다.

202 응답은 의도적으로 비커밋입니다. 그 목적은 프로세스가 완료될 때까지 서버에 대한 사용자 에이전트의 연결이 지속될 필요 없이 서버가 다른 프로세스\(아마도 하루에 한 번만 실행되는 배치 지향 프로세스\)에 대한 요청을 수락할 수 있도록 하는 것입니다. 이 응답과 함께 전송된 표현은 요청의 현재 상태를 설명하고 사용자에게 요청이 언제 이행될지에 대한 추정치를 제공할 수 있는 상태 모니터를 가리켜야 합니다\(또는 포함해야 합니다\).

---
#### **15.3.4.  203 Non-Authoritative Information**

203\(Non-Authoritative Information\) 상태 코드는 요청이 성공했지만 포함된 내용이 변환 프록시\(섹션 7.7\)에 의해 원본 서버의 200\(OK\) 응답 내용에서 수정되었음을 나타냅니다. 이 상태 코드를 사용하면 변환이 적용되었을 때 프록시가 수신자에게 알릴 수 있습니다. 해당 지식이 콘텐츠에 관한 이후 결정에 영향을 미칠 수 있기 때문입니다. 예를 들어, 콘텐츠에 대한 향후 캐시 유효성 검사 요청은 동일한 요청 경로\(동일한 프록시를 통해\)를 통해서만 적용될 수 있습니다.

203 응답은 경험적으로 캐시할 수 있습니다. 즉, 메서드 정의나 명시적인 캐시 제어로 달리 지정되지 않는 한\(\[CACHING\]의 섹션 4.2.2 참조\)

---
#### **15.3.5.  204 No Content**

204\(콘텐츠 없음\) 상태 코드는 서버가 요청을 성공적으로 이행했으며 응답 콘텐츠에 보낼 추가 콘텐츠가 없음을 나타냅니다. 응답 헤더 필드의 메타데이터는 요청된 작업이 적용된 후 대상 리소스와 선택한 표현을 참조합니다.

예를 들어, PUT 요청에 대한 응답으로 204 상태 코드가 수신되고 응답에 ETag 필드가 포함된 경우 PUT가 성공한 것이며 ETag 필드 값에는 해당 대상 리소스의 새 표현에 대한 엔터티 태그가 포함됩니다.

204 응답을 통해 서버는 작업이 대상 리소스에 성공적으로 적용되었음을 나타내는 동시에 사용자 에이전트가 현재 "문서 보기"\(있는 경우\)에서 벗어날 필요가 없음을 암시합니다. 서버는 사용자 에이전트가 자체 인터페이스에 따라 사용자에게 성공에 대한 일부 표시를 제공하고 활성 표현에 대한 응답으로 새 메타데이터나 업데이트된 메타데이터를 적용한다고 가정합니다.

예를 들어, 204 상태 코드는 "저장" 작업에 해당하는 문서 편집 인터페이스에서 일반적으로 사용됩니다. 따라서 저장되는 문서는 사용자가 편집할 수 있는 상태로 유지됩니다. 또한 분산 버전 제어 시스템 내에서와 같이 자동화된 데이터 전송이 널리 보급될 것으로 예상되는 인터페이스와 함께 자주 사용됩니다.

204 응답은 헤더 섹션이 끝나면 종료됩니다. 콘텐츠나 예고편을 포함할 수 없습니다.

204 응답은 경험적으로 캐시 가능합니다. 즉, 메서드 정의나 명시적인 캐시 제어로 달리 지정되지 않는 한\(\[CACHING\]의 섹션 4.2.2 참조\)

---
#### **15.3.6.  205 Reset Content**

205\(콘텐츠 재설정\) 상태 코드는 서버가 요청을 이행했으며 사용자 에이전트가 요청을 전송하게 만든 "문서 보기"를 원본 서버에서 수신한 원래 상태로 재설정하기를 원한다는 것을 나타냅니다.

이 응답은 사용자가 데이터 입력을 지원하는 콘텐츠\(양식, 메모장, 캔버스 등\)를 수신하고, 해당 공간에 데이터를 입력하거나 조작하고, 입력된 데이터가 제출되도록 하는 일반적인 데이터 입력 사용 사례를 지원하기 위한 것입니다. 요청하면 데이터 입력 메커니즘이 다음 입력에 대해 재설정되므로 사용자는 다른 입력 작업을 쉽게 시작할 수 있습니다.

205 상태 코드는 추가 콘텐츠가 제공되지 않음을 의미하므로 서버는 205 응답에서 콘텐츠를 생성해서는 안 됩니다.

---
#### **15.3.7.  206 Partial Content**

206\(부분 콘텐츠\) 상태 코드는 서버가 선택된 표현의 하나 이상의 부분을 전송하여 대상 리소스에 대한 범위 요청을 성공적으로 이행하고 있음을 나타냅니다.

범위 요청\(섹션 14\)을 지원하는 서버는 일반적으로 요청된 범위를 모두 충족하려고 시도합니다. 더 적은 데이터를 전송하면 나머지 클라이언트에 대한 다른 요청이 발생할 가능성이 높기 때문입니다. 그러나 서버는 일시적인 가용성, 캐시 효율성, 로드 밸런싱 등과 같은 자체적인 이유로 요청된 데이터의 하위 집합만 전송하려고 할 수 있습니다. 206 응답은 자체 설명적이므로 클라이언트는 여전히 응답을 이해할 수 있습니다. 범위 요청을 부분적으로만 충족합니다.

클라이언트는 206 응답의 Content-Type 및 Content-Range 필드를 검사하여 포함된 부분과 추가 요청이 필요한지 여부를 결정해야 합니다.

206 응답을 생성하는 서버는 해당 필드가 동일한 요청에 대한 200\(OK\) 응답으로 전송된 경우 아래 하위 섹션에 필요한 헤더 필드 외에도 Date, Cache-Control, ETag와 같은 헤더 필드를 생성해야 합니다. , 만료, 콘텐츠 위치 및 다양합니다.

206 응답에 있는 Content-Length 헤더 필드는 이 메시지 내용의 옥텟 수를 나타냅니다. 이는 일반적으로 선택한 표현의 전체 길이가 아닙니다. 각 Content-Range 헤더 필드에는 선택한 표현의 전체 길이에 대한 정보가 포함됩니다.

If-Range 헤더 필드가 있는 요청에 대한 206 응답을 생성하는 발신자는 필요한 것 이상의 다른 표현 헤더 필드를 생성해서는 안 됩니다. 왜냐하면 클라이언트가 이미 해당 헤더 필드를 포함하는 이전 응답을 가지고 있기 때문입니다. 그렇지 않으면 발신자는 동일한 요청에 대한 200\(OK\) 응답으로 전송되었을 모든 표현 헤더 필드를 생성해야 합니다.

206 응답은 경험적으로 캐시할 수 있습니다. 즉, 명시적인 캐시 제어로 달리 지정되지 않는 한\(\[CACHING\]의 섹션 4.2.2 참조\).

---
##### **15.3.7.1.  Single Part**

단일 부분이 전송되는 경우 206 응답을 생성하는 서버는 선택된 표현의 범위와 해당 범위로 구성된 콘텐츠를 설명하는 Content-Range 헤더 필드를 생성해야 합니다. 예를 들어:

```text
   HTTP/1.1 206 Partial Content
   Date: Wed, 15 Nov 1995 06:25:24 GMT
   Last-Modified: Wed, 15 Nov 1995 04:58:08 GMT
   Content-Range: bytes 21010-47021/47022
   Content-Length: 26012
   Content-Type: image/gif
```

... 부분 이미지 데이터 26012바이트 ...

---
##### **15.3.7.2.  Multiple Parts**

여러 부분이 전송되는 경우 206 응답을 생성하는 서버는 섹션 14.6에 정의된 대로 "multipart/byteranges" 콘텐츠와 "multipart/byteranges" 미디어 유형 및 필수 경계 매개변수를 포함하는 Content-Type 헤더 필드를 생성해야 합니다. 단일 부분 응답과의 혼동을 피하기 위해 서버는 다중 부분 응답의 HTTP 헤더 섹션에 Content-Range 헤더 필드를 생성해서는 안 됩니다\(이 필드는 대신 각 부분에서 전송됩니다\).

멀티파트 콘텐츠의 각 본문 부분 헤더 영역 내에서 서버는 해당 본문 부분에 포함된 범위에 해당하는 Content-Range 헤더 필드를 생성해야 합니다. 선택된 표현이 200\(OK\) 응답에 Content-Type 헤더 필드를 갖고 있다면 서버는 각 본문 부분의 헤더 영역에 동일한 Content-Type 헤더 필드를 생성해야 합니다. 예를 들어:

```text
   HTTP/1.1 206 Partial Content
   Date: Wed, 15 Nov 1995 06:25:24 GMT
   Last-Modified: Wed, 15 Nov 1995 04:58:08 GMT
   Content-Length: 1741
   Content-Type: multipart/byteranges; boundary=THIS_STRING_SEPARATES

   --THIS_STRING_SEPARATES
   Content-Type: application/pdf
   Content-Range: bytes 500-999/8000

   ...the first range...
   --THIS_STRING_SEPARATES
   Content-Type: application/pdf
   Content-Range: bytes 7000-7999/8000

   ...the second range
   --THIS_STRING_SEPARATES--
```

여러 범위가 요청되면 서버는 해당 범위 사양이 수신된 순서에 관계없이 겹치거나 여러 부분을 보내는 오버헤드보다 작은 간격으로 분리된 범위를 통합할 수 있습니다. 범위 헤더 필드. "multipart/byteranges"의 각 부분 사이의 일반적인 오버헤드는 약 80바이트이므로 선택한 표현의 미디어 유형과 선택한 경계 매개변수 길이에 따라 여러 작은 분리된 부분을 전송하는 것보다 비효율적일 수 있습니다. 전체 선택된 표현.

서버는 단일 범위에 대한 요청에 대해 다중 부분 응답을 생성해서는 안 됩니다. 여러 부분을 요청하지 않는 클라이언트는 다중 부분 응답을 지원하지 않을 수 있기 때문입니다. 그러나 여러 범위가 요청되었고 하나의 범위만 만족스러운 것으로 확인되었거나 병합 후 하나의 범위만 남은 경우 서버는 단일 본문 부분만으로 "multipart/byteranges" 응답을 생성할 수 있습니다. "multipart/byteranges" 응답을 처리할 수 없는 클라이언트는 여러 범위를 요청하는 요청을 생성해서는 안 됩니다.

다중 부분 응답을 생성하는 서버는 만족스럽지 않은 것으로 간주되거나 다른 범위로 통합된 범위를 제외하고 수신된 Range 헤더 필드에 해당 범위 사양이 나타나는 것과 동일한 순서로 부분을 전송해야 합니다. 다중 부분 응답을 수신하는 클라이언트는 해당 본문 부분에 어떤 범위가 포함되어 있는지 확인하기 위해 각 본문 부분에 있는 Content-Range 헤더 필드를 검사해야 합니다. 클라이언트는 요청한 것과 동일한 범위나 요청한 것과 동일한 순서를 수신할 수 없습니다.

---
##### **15.3.7.3.  Combining Parts**

연결이 조기에 종료되거나 요청이 하나 이상의 범위 사양을 사용한 경우 응답은 표현의 하위 범위만 전송할 수 있습니다. 그러한 전송을 여러 번 한 후에 클라이언트는 동일한 표현의 여러 범위를 수신했을 수 있습니다. 이러한 범위는 모두 공통적으로 동일한 강력한 유효성 검사기를 갖는 경우에만 안전하게 결합될 수 있습니다\(섹션 8.8.1\).

대상 리소스에 대한 GET 요청에 대해 여러 부분 응답을 받은 클라이언트는 동일한 강력한 유효성 검사기를 공유하는 경우 해당 응답을 더 큰 연속 범위로 결합할 수 있습니다.

가장 최근 응답이 불완전한 200\(OK\) 응답인 경우 해당 응답의 헤더 필드는 결합된 응답에 사용되며 일치하는 저장된 응답의 헤더 필드를 대체합니다.

가장 최근 응답이 206\(부분 콘텐츠\) 응답이고 일치하는 저장된 응답 중 하나 이상이 200\(OK\)인 경우 결합된 응답 헤더 필드는 가장 최근 200개 응답의 헤더 필드로 구성됩니다. 일치하는 저장된 응답이 모두 206 응답인 경우 가장 최근 헤더 필드가 있는 저장된 응답은 결합된 응답에 대한 헤더 필드의 소스로 사용됩니다. 단, 클라이언트는 반드시 새 응답에 제공된 다른 헤더 필드를 사용해야 합니다. Content-Range에서 저장된 응답에 있는 해당 헤더 필드의 모든 인스턴스를 바꿉니다.

결합된 응답 콘텐츠는 새 응답 내의 부분 콘텐츠 범위와 일치하는 모든 저장된 응답의 합집합으로 구성됩니다. 통합이 표현의 전체 범위로 구성된 경우 클라이언트는 전체 길이를 반영하는 Content-Length 헤더 필드를 포함하여 완전한 200\(OK\) 응답인 것처럼 결합된 응답을 처리해야 합니다. 그렇지 않은 경우 클라이언트는 연속 범위 집합을 다음 중 하나로 처리해야 합니다. 결합된 응답이 표현의 접두사인 경우 불완전한 200\(OK\) 응답, "multipart/byteranges" 콘텐츠를 포함하는 단일 206\(부분 콘텐츠\) 응답 또는 여러 206\(부분 콘텐츠\) 응답으로, 각각은 Content-Range 헤더 필드로 표시되는 하나의 연속 범위를 갖습니다.

---
### **15.4.  Redirection 3xx**

상태 코드의 3xx\(리디렉션\) 클래스는 요청을 이행하기 위해 사용자 에이전트가 추가 조치를 취해야 함을 나타냅니다. 리디렉션에는 여러 유형이 있습니다.

1. 이 리소스를 나타내는 리디렉션은 상태 코드 301\(영구적으로 이동됨\), 302\(발견\), 307\(임시 리디렉션\) 및 308\(영구 리디렉션\)에서와 같이 Location 헤더 필드에서 제공하는 대로 다른 URI에서 사용할 수 있습니다. \).

1. 300\(다중 선택\) 상태 코드에서와 같이 이 리소스를 나타낼 수 있는 일치하는 리소스 중에서 선택을 제공하는 리디렉션입니다.

1. 303\(기타 참조\) 상태 코드와 같이 요청에 대한 간접적인 응답을 나타낼 수 있는 Location 헤더 필드로 식별되는 다른 리소스로의 리디렉션입니다.

1. 304\(수정되지 않음\) 상태 코드와 같이 이전에 저장된 결과로 리디렉션됩니다.

- | \*참고:\* HTTP/1.0에서는 상태 코드 301\(영구적으로 이동됨\) | 및 302\(Found\)는 원래 메서드 보존 | \(\[HTTP/1.0\], 섹션 9.3\)의 구현과 일치하도록 | CERN; 303\(기타 참조\)이 | 메소드를 GET으로 변경했습니다. 그러나 초기 사용자 에이전트는 | POST 요청을 POST\(현재 사양에 따라\)로 리디렉션할지 | GET\(다른 사이트로 리디렉션할 때 더 안전한 대안\)으로 리디렉션할지 여부입니다. 일반적인 관행 | 결국 메소드를 GET으로 변경하는 것으로 수렴되었습니다. 307 | \(임시 리디렉션\) 및 308\(영구 리디렉션\) \[RFC7538\] | 나중에 방법 보존을 명확하게 나타내기 위해 추가되었습니다 | 리디렉션 및 상태 코드 301 및 302가 | POST 요청이 GET으로 리디렉션되도록 허용합니다.

Location 헤더 필드\(섹션 10.2.2\)가 제공되면 사용자 에이전트는 특정 상태 코드가 이해되지 않는 경우에도 Location 필드 값이 참조하는 URI로 요청을 자동으로 리디렉션할 수 있습니다. 사용자가 안전하지 않은 요청을 리디렉션하기를 원하지 않을 수 있으므로 섹션 9.2.1에 정의된 대로 안전하지 않은 것으로 알려진 방법에 대해 자동 리디렉션을 주의해서 수행해야 합니다.

리디렉션된 요청을 자동으로 따를 때 사용자 에이전트는 다음 수정 사항을 적용하여 원래 요청 메시지를 다시 보내야 합니다.

1. 원래 요청의 대상 URI를 기준으로 대상 URI를 확인한 후 리디렉션 응답의 Location 헤더 필드 값에서 참조하는 URI로 바꿉니다.

1. 구현 시 자동으로 생성된 헤더 필드를 제거하고 새 요청에 맞게 업데이트된 값으로 바꿉니다. 여기에는 다음이 포함됩니다.

```text
       1.  Connection-specific header fields (see Section 7.6.1),

       2.  Header fields specific to the client's proxy configuration,
           including (but not limited to) Proxy-Authorization,

       3.  Origin-specific header fields (if any), including (but not
           limited to) Host,

       4.  Validating header fields that were added by the
           implementation's cache (e.g., If-None-Match,
           If-Modified-Since), and

       5.  Resource-specific header fields, including (but not limited
           to) Referer, Origin, Authorization, and Cookie.
```

1. 구현에 의해 자동으로 생성되지 않은 헤더 필드\(즉, 호출 컨텍스트에 의해 추가되었기 때문에 요청에 존재하는 필드\)는 보안에 영향을 미칠 수 있으므로 제거하는 것을 고려하십시오. 여기에는 승인 및 쿠키가 포함되지만 이에 국한되지는 않습니다.

1. 해당되는 경우 리디렉션 상태 코드의 의미에 따라 요청 방법을 변경합니다.

1. 요청 방법이 GET 또는 HEAD로 변경된 경우 Content-Encoding, Content-Language, Content-Location, Content-Type, Content-Length, Digest를 포함하되 이에 국한되지 않는 콘텐츠별 헤더 필드를 제거합니다. 최종 수정됨.

클라이언트는 주기적 리디렉션\(즉, "무한" 리디렉션 루프\)을 감지하고 개입해야 합니다.

- | \*참고:\* 이 사양의 이전 버전에서는 | 최대 5개의 리디렉션\(\[RFC2068\], 섹션 10.3\) | 콘텐츠 개발자는 일부 클라이언트가 | 그러한 고정된 제한을 구현하십시오.

---
#### **15.4.1.  300 Multiple Choices**

300\(다중 선택\) 상태 코드는 대상 리소스에 둘 이상의 표현이 있고 각 표현에는 보다 구체적인 식별자가 있으며 대안에 대한 정보가 제공되어 사용자\(또는 사용자 에이전트\)가 다음을 통해 선호하는 표현을 선택할 수 있음을 나타냅니다. 요청을 해당 식별자 중 하나 이상으로 리디렉션합니다. 즉, 서버는 사용자 에이전트가 필요에 가장 적합한 표현을 선택하기 위해 반응적 협상에 참여하기를 원합니다\(섹션 12\).

서버가 선호하는 선택을 갖고 있는 경우, 서버는 선호하는 선택의 URI 참조를 포함하는 Location 헤더 필드를 생성해야 합니다\(SHOULD\). 사용자 에이전트는 자동 리디렉션을 위해 위치 필드 값을 사용할 수 있습니다.

HEAD 이외의 요청 방법의 경우 서버는 사용자 또는 사용자 에이전트가 가장 선호하는 것을 선택할 수 있는 표현 메타데이터 및 URI 참조 목록을 포함하는 300 응답의 콘텐츠를 생성해야 합니다\(SHOULD\). 사용자 에이전트는 제공된 미디어 유형을 이해하는 경우 해당 목록에서 자동으로 선택할 수 있습니다. HTTP는 콘텐츠 정의와 직교를 유지하려고 하기 때문에 자동 선택을 위한 특정 형식은 이 사양에서 정의되지 않습니다. 실제로 표현은 공유 디자인이나 콘텐츠 협상에 의해 결정된 대로 사용자 에이전트가 허용할 수 있다고 생각되는 쉽게 구문 분석되는 형식이나 일반적으로 허용되는 일부 하이퍼텍스트 형식으로 제공됩니다.

300 응답은 경험적으로 캐시 가능합니다. 즉, 메서드 정의나 명시적인 캐시 제어로 달리 지정되지 않는 한\(\[CACHING\]의 섹션 4.2.2 참조\)

- | \*참고:\* 정의된 300 상태 코드에 대한 원래 제안 | 대체 목록을 제공하는 URI 헤더 필드 | 200, 300 및 | 406 응답을 수신하고 HEAD | 방법. 그러나 배포 부족 및 의견 불일치 | 구문이 URI와 대체 항목 모두로 이어졌습니다\(후속 제안\) | 이 사양에서 삭제되었습니다. | 목록을 링크 헤더 필드 값으로 전달합니다. \[RFC8288\] | 하지만 그 구성원은 "대체" 관계를 가지고 있습니다 | 배포는 닭과 달걀의 문제입니다.

---
#### **15.4.2.  301 Moved Permanently**

301\(영구적으로 이동됨\) 상태 코드는 대상 리소스에 새로운 영구 URI가 할당되었으며 이 리소스에 대한 향후 참조는 포함된 URI 중 하나를 사용해야 함을 나타냅니다. 서버는 링크 편집 기능이 있는 사용자 에이전트가 대상 URI에 대한 참조를 서버에서 보낸 새 참조 중 하나로 영구적으로 대체할 수 있다고 제안합니다. 그러나 이 제안은 사용자 에이전트가 참조를 적극적으로 편집하고\(예: 콘텐츠 작성에 참여\) 연결이 보안되고 원본 서버가 편집 중인 콘텐츠에 대해 신뢰할 수 있는 기관이 아닌 한 일반적으로 무시됩니다.

서버는 새로운 영구 URI에 대한 기본 URI 참조를 포함하는 응답에서 Location 헤더 필드를 생성해야 합니다\(SHOULD\). 사용자 에이전트는 자동 리디렉션을 위해 위치 필드 값을 사용할 수 있습니다. 서버의 응답 콘텐츠에는 일반적으로 새 URI에 대한 하이퍼링크가 포함된 짧은 하이퍼텍스트 메모가 포함되어 있습니다.

- | \*참고:\* 기록상의 이유로 사용자 에이전트는 | 후속 요청에 대해 POST에서 GET으로의 요청 메소드입니다. 만약 | 이 동작은 바람직하지 않습니다. 308\(영구 리디렉션\) 상태 | 대신 코드를 사용할 수 있습니다.

301 응답은 경험적으로 캐시 가능합니다. 즉, 메서드 정의나 명시적인 캐시 제어로 달리 지정되지 않는 한\(\[CACHING\]의 섹션 4.2.2 참조\)

---
#### **15.4.3.  302 Found**

302\(Found\) 상태 코드는 대상 리소스가 일시적으로 다른 URI 아래에 있음을 나타냅니다. 때때로 리디렉션이 변경될 수 있으므로 클라이언트는 향후 요청에 대해 대상 URI를 계속 사용해야 합니다.

서버는 다른 URI에 대한 URI 참조를 포함하는 응답에 Location 헤더 필드를 생성해야 합니다\(SHOULD\). 사용자 에이전트는 자동 리디렉션을 위해 위치 필드 값을 사용할 수 있습니다. 서버의 응답 콘텐츠에는 일반적으로 다른 URI에 대한 하이퍼링크가 포함된 짧은 하이퍼텍스트 메모가 포함되어 있습니다.

- | \*참고:\* 기록상의 이유로 사용자 에이전트는 | 후속 요청에 대해 POST에서 GET으로의 요청 메소드입니다. 만약 | 이 동작은 바람직하지 않습니다. 307\(임시 리디렉션\) 상태 | 대신 코드를 사용할 수 있습니다.

---
#### **15.4.4.  303 See Other**

303\(기타 참조\) 상태 코드는 원래 요청에 대한 간접적인 응답을 제공하기 위한 Location 헤더 필드의 URI에 표시된 대로 서버가 사용자 에이전트를 다른 리소스로 리디렉션하고 있음을 나타냅니다. 사용자 에이전트는 리디렉션될 수도 있는 해당 URI\(HTTP를 사용하는 경우 GET 또는 HEAD 요청\)를 대상으로 하는 검색 요청을 수행하고 최종 결과를 원래 요청에 대한 응답으로 제시할 수 있습니다. Location 헤더 필드의 새 URI는 대상 URI와 동일한 것으로 간주되지 않습니다.

이 상태 코드는 모든 HTTP 메서드에 적용 가능합니다. 이는 주로 POST 작업의 출력이 사용자 에이전트를 다른 리소스로 리디렉션할 수 있도록 하는 데 사용됩니다. 그렇게 하면 POST 응답에 해당하는 정보가 별도로 식별되고, 북마크에 추가되고, 캐시될 수 있는 리소스로 제공되기 때문입니다.

GET 요청에 대한 303 응답은 원본 서버에 HTTP를 통해 서버가 전송할 수 있는 대상 리소스에 대한 표현이 없음을 나타냅니다. 그러나 위치 필드 값은 대상 리소스를 설명하는 리소스를 참조하므로 다른 리소스에 대한 검색 요청을 하면 원래 대상 리소스를 나타낸다는 것을 암시하지 않고 수신자에게 유용한 표현이 생성될 수 있습니다. 무엇을 표현할 수 있는지, 어떤 표현이 적절한지, 무엇이 유용한 설명이 될 수 있는지에 대한 질문에 대한 대답은 HTTP의 범위를 벗어납니다.

HEAD 요청에 대한 응답을 제외하고 303 응답 표현에는 Location 헤더 필드에 제공된 동일한 URI 참조에 대한 하이퍼링크가 있는 짧은 하이퍼텍스트 메모가 포함되어야 합니다.

---
#### **15.4.5.  304 Not Modified**

304\(수정되지 않음\) 상태 코드는 조건부 GET 또는 HEAD 요청이 수신되었으며 조건이 false로 평가되지 않았다면 200\(OK\) 응답이 발생했음을 나타냅니다. 즉, 요청을 조건부로 만든 클라이언트가 이미 유효한 표현을 가지고 있음을 요청이 나타내기 때문에 서버가 대상 리소스의 표현을 전송할 필요가 없습니다. 따라서 서버는 마치 200\(OK\) 응답의 내용인 것처럼 저장된 표현을 사용하도록 클라이언트를 리디렉션합니다.

304 응답을 생성하는 서버는 동일한 요청에 대한 200\(OK\) 응답으로 전송되었을 다음 헤더 필드 중 하나를 생성해야 합니다.

\* 콘텐츠 위치, 날짜, ETag 및 Vary

\* 캐시 제어 및 만료\(\[캐싱\] 참조\)

304 응답의 목표는 수신자가 이미 하나 이상의 캐시된 표현을 가지고 있을 때 정보 전송을 최소화하는 것이므로, 캐시 업데이트를 안내할 목적으로 해당 메타데이터가 존재하지 않는 한 발신자는 위에 나열된 필드 이외의 표현 메타데이터를 생성해서는 안 됩니다\(예: 응답에 ETag 필드가 없는 경우 Last-Modified가 유용할 수 있습니다.

304 응답을 수신하는 캐시에 대한 요구 사항은 \[CACHING\]의 섹션 4.3.4에 정의되어 있습니다. 조건부 요청이 아웃바운드 클라이언트에서 시작된 경우\(예: 자체 캐시가 있는 사용자 에이전트가 공유 프록시에 조건부 GET을 보내는 경우\) 프록시는 304 응답을 해당 클라이언트에 전달해야 합니다.

304 응답은 헤더 섹션이 끝나면 종료됩니다. 콘텐츠나 예고편을 포함할 수 없습니다.

---
#### **15.4.6.  305 Use Proxy**

305\(프록시 사용\) 상태 코드는 이 사양의 이전 버전에서 정의되었으며 이제 더 이상 사용되지 않습니다\(\[RFC7231\]의 부록 B\).

---
#### **15.4.7.  306 (Unused)**

306 상태 코드는 이 사양의 이전 버전에서 정의되었으며 더 이상 사용되지 않으며 코드는 예약되어 있습니다.

---
#### **15.4.8.  307 Temporary Redirect**

307\(임시 리디렉션\) 상태 코드는 대상 리소스가 일시적으로 다른 URI 아래에 상주하며 사용자 에이전트가 해당 URI로 자동 리디렉션을 수행하는 경우 요청 방법을 변경해서는 안 된다는 것을 나타냅니다. 리디렉션은 시간이 지남에 따라 변경될 수 있으므로 클라이언트는 향후 요청에 대해 원래 대상 URI를 계속 사용해야 합니다.

서버는 다른 URI에 대한 URI 참조를 포함하는 응답에 Location 헤더 필드를 생성해야 합니다\(SHOULD\). 사용자 에이전트는 자동 리디렉션을 위해 위치 필드 값을 사용할 수 있습니다. 서버의 응답 콘텐츠에는 일반적으로 다른 URI에 대한 하이퍼링크가 포함된 짧은 하이퍼텍스트 메모가 포함되어 있습니다.

---
#### **15.4.9.  308 Permanent Redirect**

308\(영구 리디렉션\) 상태 코드는 대상 리소스에 새로운 영구 URI가 할당되었으며 이 리소스에 대한 향후 참조는 포함된 URI 중 하나를 사용해야 함을 나타냅니다. 서버는 링크 편집 기능이 있는 사용자 에이전트가 대상 URI에 대한 참조를 서버에서 보낸 새 참조 중 하나로 영구적으로 대체할 수 있다고 제안합니다. 그러나 이 제안은 사용자 에이전트가 참조를 적극적으로 편집하고\(예: 콘텐츠 작성에 참여\) 연결이 보안되고 원본 서버가 편집 중인 콘텐츠에 대해 신뢰할 수 있는 기관이 아닌 한 일반적으로 무시됩니다.

서버는 새로운 영구 URI에 대한 기본 URI 참조를 포함하는 응답에서 Location 헤더 필드를 생성해야 합니다\(SHOULD\). 사용자 에이전트는 자동 리디렉션을 위해 위치 필드 값을 사용할 수 있습니다. 서버의 응답 콘텐츠에는 일반적으로 새 URI에 대한 하이퍼링크가 포함된 짧은 하이퍼텍스트 메모가 포함되어 있습니다.

308 응답은 경험적으로 캐시 가능합니다. 즉, 메서드 정의나 명시적인 캐시 제어로 달리 지정되지 않는 한\(\[CACHING\]의 섹션 4.2.2 참조\)

- | \*참고:\* 이 상태 코드는 | | 형제 코드이므로 모든 곳에서 인식되지 않을 수 있습니다. 참조 | 배포 고려 사항은 \[RFC7538\]의 섹션 4입니다.

---
### **15.5.  Client Error 4xx**

상태 코드의 4xx\(클라이언트 오류\) 클래스는 클라이언트에 오류가 있는 것 같음을 나타냅니다. HEAD 요청에 응답할 때를 제외하고 서버는 오류 상황에 대한 설명과 그것이 일시적인지 영구적인지 여부를 포함하는 표현을 보내야 합니다. 이러한 상태 코드는 모든 요청 방법에 적용 가능합니다. 사용자 에이전트는 포함된 모든 표현을 사용자에게 표시해야 합니다.

---
#### **15.5.1.  400 Bad Request**

400\(잘못된 요청\) 상태 코드는 클라이언트 오류로 인식되는 원인\(예: 잘못된 요청 구문, 잘못된 요청 메시지 프레이밍 또는 사기성 요청 라우팅\)으로 인해 서버가 요청을 처리할 수 없거나 처리하지 않음을 나타냅니다.

---
#### **15.5.2.  401 Unauthorized**

401\(승인되지 않음\) 상태 코드는 대상 리소스에 대한 유효한 인증 자격 증명이 부족하여 요청이 적용되지 않았음을 나타냅니다. 401 응답을 생성하는 서버는 대상 리소스에 적용 가능한 적어도 하나의 챌린지를 포함하는 WWW-Authenticate 헤더 필드\(섹션 11.6.1\)를 보내야 합니다.

요청에 인증 자격 증명이 포함된 경우 401 응답은 해당 자격 증명에 대한 인증이 거부되었음을 나타냅니다. 사용자 에이전트는 새롭거나 대체된 Authorization 헤더 필드\(섹션 11.6.2\)를 사용하여 요청을 반복할 수 있습니다. 401 응답에 이전 응답과 동일한 챌린지가 포함되어 있고 사용자 에이전트가 이미 한 번 이상 인증을 시도한 경우 사용자 에이전트는 일반적으로 관련 진단 정보를 포함하므로 동봉된 표현을 사용자에게 제시해야 합니다.

---
#### **15.5.3.  402 Payment Required**

402\(결제 필요\) 상태 코드는 향후 사용을 위해 예약되어 있습니다.

---
#### **15.5.4.  403 Forbidden**

403\(금지됨\) 상태 코드는 서버가 요청을 이해했지만 이행을 거부했음을 나타냅니다. 요청이 금지된 이유를 공개하려는 서버는 응답 콘텐츠\(있는 경우\)에 해당 이유를 설명할 수 있습니다.

요청에 인증 자격 증명이 제공된 경우 서버는 액세스 권한을 부여하기에 충분하지 않은 것으로 간주합니다. 클라이언트는 동일한 자격 증명을 사용하여 요청을 자동으로 반복해서는 안 됩니다. 클라이언트는 새 자격 증명이나 다른 자격 증명을 사용하여 요청을 반복할 수 있습니다. 그러나 자격 증명과 관련 없는 이유로 요청이 금지될 수 있습니다.

금지된 대상 리소스의 현재 존재를 "숨기려는" 원서버는 대신 404\(찾을 수 없음\) 상태 코드로 응답할 수 있습니다.

---
#### **15.5.5.  404 Not Found**

404\(찾을 수 없음\) 상태 코드는 원본 서버가 대상 리소스에 대한 현재 표현을 찾지 못했거나 해당 표현이 존재한다는 사실을 공개할 의사가 없음을 나타냅니다. 404 상태 코드는 이러한 표현 부족이 일시적인지 영구적인지를 나타내지 않습니다. 원본 서버가 아마도 일부 구성 가능한 수단을 통해 조건이 영구적일 가능성이 있다는 것을 알고 있는 경우 404보다 410\(사라짐\) 상태 코드가 선호됩니다.

404 응답은 경험적으로 캐시 가능합니다. 즉, 메서드 정의나 명시적인 캐시 제어로 달리 지정되지 않는 한\(\[CACHING\]의 섹션 4.2.2 참조\)

---
#### **15.5.6.  405 Method Not Allowed**

405\(Method Not Allowed\) 상태 코드는 요청 라인에서 수신된 메소드가 원본 서버에 알려져 있지만 대상 리소스에서는 지원되지 않음을 나타냅니다. 원본 서버는 대상 리소스의 현재 지원되는 메서드 목록을 포함하는 405 응답에서 Allow 헤더 필드를 생성해야 합니다.

405 응답은 경험적으로 캐시 가능합니다. 즉, 메서드 정의나 명시적인 캐시 제어로 달리 지정되지 않는 한\(\[CACHING\]의 섹션 4.2.2 참조\)

---
#### **15.5.7.  406 Not Acceptable**

406\(허용되지 않음\) 상태 코드는 요청\(섹션 12.1\)에서 수신된 사전 협상 헤더 필드에 따라 대상 리소스에 사용자 에이전트가 허용할 수 있는 현재 표현이 없으며 서버가 이를 원하지 않음을 나타냅니다. 기본 표현을 제공합니다.

서버는 사용 가능한 표현 특성 목록과 사용자 또는 사용자 에이전트가 가장 적절한 것을 선택할 수 있는 해당 리소스 식별자를 포함하는 콘텐츠를 생성해야 합니다\(SHOULD\). 사용자 에이전트는 해당 목록에서 가장 적절한 선택을 자동으로 선택할 수 있습니다. 그러나 이 사양은 섹션 15.4.1에 설명된 대로 자동 선택에 대한 표준을 정의하지 않습니다.

---
#### **15.5.8.  407 Proxy Authentication Required**

407\(프록시 인증 필요\) 상태 코드는 401\(권한 없음\)과 유사하지만 이 요청에 프록시를 사용하려면 클라이언트가 자체 인증해야 함을 나타냅니다. 프록시는 요청에 대해 해당 프록시에 적용 가능한 챌린지를 포함하는 Proxy-Authenticate 헤더 필드\(섹션 11.7.1\)를 보내야 합니다. 클라이언트는 새롭거나 대체된 Proxy-Authorization 헤더 필드\(섹션 11.7.2\)를 사용하여 요청을 반복할 수 있습니다.

---
#### **15.5.9.  408 Request Timeout**

408\(요청 시간 초과\) 상태 코드는 서버가 대기할 준비가 된 시간 내에 완전한 요청 메시지를 받지 못했음을 나타냅니다.

클라이언트가 전송 중에 미해결 요청이 있는 경우 해당 요청을 반복할 수 있습니다. 현재 연결을 사용할 수 없는 경우\(예: 요청 구분이 손실되어 HTTP/1.1에 있는 경우\) 새 연결이 사용됩니다.

---
#### **15.5.10.  409 Conflict**

409\(충돌\) 상태 코드는 대상 리소스의 현재 상태와의 충돌로 인해 요청을 완료할 수 없음을 나타냅니다. 이 코드는 사용자가 충돌을 해결하고 요청을 다시 제출할 수 있는 상황에서 사용됩니다. 서버는 사용자가 충돌의 원인을 인식할 수 있을 만큼 충분한 정보를 포함하는 콘텐츠를 생성해야 합니다\(SHOULD\).

PUT 요청에 대한 응답으로 충돌이 발생할 가능성이 가장 높습니다. 예를 들어, 버전 관리가 사용되고 PUT 중인 표현에 이전\(제3자\) 요청에 의해 생성된 것과 충돌하는 리소스에 대한 변경 사항이 포함된 경우 원본 서버는 409 응답을 사용하여 해당 작업을 완료할 수 없음을 나타낼 수 있습니다. 요구. 이 경우 응답 표현에는 개정 기록을 기반으로 차이점을 병합하는 데 유용한 정보가 포함될 수 있습니다.

---
#### **15.5.11.  410 Gone**

410\(Gone\) 상태 코드는 원본 서버에서 대상 리소스에 대한 액세스가 더 이상 가능하지 않으며 이 상태가 영구적일 가능성이 있음을 나타냅니다. 원본 서버가 조건이 영구적인지 여부를 알 수 없거나 결정할 수 있는 기능이 없는 경우 상태 코드 404\(찾을 수 없음\)를 대신 사용해야 합니다.

410 응답은 주로 리소스를 의도적으로 사용할 수 없으며 서버 소유자가 해당 리소스에 대한 원격 링크를 제거하기를 원한다는 사실을 수신자에게 알려 웹 유지 관리 작업을 지원하기 위한 것입니다. 이러한 이벤트는 제한된 시간 동안 진행되는 판촉 서비스 및 원본 서버 사이트와 더 이상 연결되지 않은 개인에게 속한 리소스에 대해 일반적입니다. 영구적으로 사용할 수 없는 모든 리소스를 "사라짐"으로 표시하거나 일정 기간 동안 표시를 유지할 필요는 없습니다. 이는 서버 소유자의 재량에 달려 있습니다.

410 응답은 경험적으로 캐시 가능합니다. 즉, 메서드 정의나 명시적인 캐시 제어로 달리 지정되지 않는 한\(\[CACHING\]의 섹션 4.2.2 참조\)

---
#### **15.5.12.  411 Length Required**

411\(길이 필요\) 상태 코드는 서버가 정의된 Content-Length\(섹션 8.6\) 없이 요청 수락을 거부함을 나타냅니다. 클라이언트는 요청 콘텐츠의 길이를 포함하는 유효한 Content-Length 헤더 필드를 추가하는 경우 요청을 반복할 수 있습니다.

---
#### **15.5.13.  412 Precondition Failed**

412\(전제 조건 실패\) 상태 코드는 요청 헤더 필드에 제공된 하나 이상의 조건이 서버에서 테스트될 때 거짓으로 평가되었음을 나타냅니다\(섹션 13\). 이 응답 상태 코드를 사용하면 클라이언트가 현재 리소스 상태\(현재 표현 및 메타데이터\)에 전제 조건을 배치할 수 있으므로 대상 리소스가 예상치 못한 상태에 있을 경우 요청 메서드가 적용되는 것을 방지할 수 있습니다.

---
#### **15.5.14.  413 Content Too Large**

413\(콘텐츠가 너무 큼\) 상태 코드는 요청 콘텐츠가 서버가 처리할 의사가 있거나 처리할 수 있는 것보다 크기 때문에 서버가 요청 처리를 거부하고 있음을 나타냅니다. 사용 중인 프로토콜 버전이 허용하는 경우 서버는 요청을 종료할 수 있습니다. 그렇지 않으면 서버가 연결을 닫을 수 있습니다.

조건이 일시적인 경우 서버는 Retry-After 헤더 필드를 생성하여 그것이 일시적임을 나타내고 클라이언트가 몇 시간 후에 다시 시도할 수 있는지를 나타내야 합니다.

---
#### **15.5.15.  414 URI Too Long**

414\(URI가 너무 김\) 상태 코드는 대상 URI가 서버가 해석할 수 있는 것보다 길기 때문에 서버가 요청 서비스를 거부하고 있음을 나타냅니다. 이 드문 상황은 클라이언트가 긴 쿼리 정보가 포함된 POST 요청을 GET 요청으로 부적절하게 변환한 경우, 클라이언트가 무한 리디렉션 루프\(예: 접미사를 가리키는 리디렉션된 URI 접두사\)에 빠진 경우에만 발생할 가능성이 높습니다. 자체\) 또는 서버가 잠재적인 보안 허점을 악용하려는 클라이언트의 공격을 받고 있는 경우입니다.

414 응답은 경험적으로 캐시 가능합니다. 즉, 메서드 정의나 명시적인 캐시 제어로 달리 지정되지 않는 한\(\[CACHING\]의 섹션 4.2.2 참조\)

---
#### **15.5.16.  415 Unsupported Media Type**

415\(지원되지 않는 미디어 유형\) 상태 코드는 콘텐츠가 대상 리소스에서 이 방법으로 지원되지 않는 형식이기 때문에 원본 서버가 요청 서비스를 거부하고 있음을 나타냅니다.

형식 문제는 요청에 표시된 Content-Type 또는 Content-Encoding 때문이거나 데이터를 직접 검사한 결과일 수 있습니다.

지원되지 않는 콘텐츠 코딩으로 인해 문제가 발생한 경우 Accept-Encoding 응답 헤더 필드\(섹션 12.5.3\)를 사용하여 요청에서 허용된 콘텐츠 코딩\(있는 경우\)을 나타내야 합니다.

반면, 원인이 지원되지 않는 미디어 유형인 경우 Accept 응답 헤더 필드\(Section 12.5.1\)를 사용하여 요청에서 어떤 미디어 유형이 허용되었는지 나타낼 수 있습니다.

---
#### **15.5.17.  416 Range Not Satisfiable**

416\(Range Not Satisfiable\) 상태 코드는 요청된 범위 중 어느 것도 만족할 수 없거나 클라이언트가 너무 작거나 겹치는 수를 요청했기 때문에 요청의 Range 헤더 필드\(섹션 14.2\)에 있는 범위 집합이 거부되었음을 나타냅니다. 범위\(잠재적인 서비스 거부 공격\).

각 범위 단위는 자체 범위 집합이 충족되기 위해 필요한 사항을 정의합니다. 예를 들어, 섹션 14.1.2에서는 바이트 범위 집합을 만족스럽게 만드는 요소를 정의합니다.

바이트 범위 요청에 대한 416 응답을 생성하는 서버는 선택된 표현의 현재 길이를 지정하는 Content-Range 헤더 필드를 생성해야 합니다\(14.4절\).

예를 들어:

```text
   HTTP/1.1 416 Range Not Satisfiable
   Date: Fri, 20 Jan 2012 15:41:54 GMT
   Content-Range: bytes */47022
```

- | \*참고:\* 서버는 Range를 자유롭게 무시할 수 있으므로 많은 | 구현은 선택된 전체 | 200\(OK\) 응답으로 표현됩니다. 그 이유는 부분적으로 | 대부분의 클라이언트는 | 작업을 완료하기 위해 200\(OK\)을 받을 준비가 되어 있습니다. \(비록 효율성은 떨어지지만\) 클라이언트가 | 유효하지 않은 범위 요청을 중단하지 마세요 | 완전한 표현을 받았습니다. 따라서 클라이언트는 | 416\(범위가 만족스럽지 않음\) 응답을 수신하더라도 | 가장 적절할 때.

---
#### **15.5.18.  417 Expectation Failed**

417\(예상 실패\) 상태 코드는 요청의 Expect 헤더 필드\(섹션 10.1.1\)에 제공된 기대가 인바운드 서버 중 하나 이상에서 충족될 수 없음을 나타냅니다.

---
#### **15.5.19.  418 (Unused)**

\[RFC2324\]는 HTTP가 남용되는 다양한 방식을 풍자한 4월 1일 RFC였습니다. 이러한 남용 중 하나는 애플리케이션별 418 상태 코드의 정의였으며, 이는 코드를 나중에 사용할 수 없을 만큼 자주 농담으로 배포되었습니다.

따라서 418 상태 코드는 IANA HTTP 상태 코드 레지스트리에 예약되어 있습니다. 이는 현재 상태 코드를 다른 애플리케이션에 할당할 수 없음을 나타냅니다. 향후 상황에 따라 사용해야 하는 경우\(예: 4NN 상태 코드 소진\) 다른 용도로 다시 할당될 수 있습니다.

---
#### **15.5.20.  421 Misdirected Request**

421\(잘못된 요청\) 상태 코드는 요청이 대상 URI에 대한 신뢰할 수 있는 응답을 생성할 수 없거나 생성할 의사가 없는 서버로 전달되었음을 나타냅니다. 원본 서버\(또는 원본 서버를 대신하여 작동하는 게이트웨이\)는 서버가 구성된 원본\(섹션 4.3.1\)과 일치하지 않거나 연결 컨텍스트와 일치하지 않는 대상 URI를 거부하기 위해 421을 보냅니다. 요청이 수신되었습니다\(섹션 7.4\).

421\(잘못된 요청\) 응답을 수신한 클라이언트는 요청 방법이 멱등성인지 여부에 관계없이 대상 리소스의 출처에 특정한 새로운 연결과 같은 다른 연결을 통해 또는 대체 서비스\[ALTSVC\]를 통해 요청을 재시도할 수 있습니다. .

프록시는 421 응답을 생성해서는 안 됩니다.

---
#### **15.5.21.  422 Unprocessable Content**

422\(처리할 수 없는 콘텐츠\) 상태 코드는 서버가 요청 콘텐츠의 콘텐츠 유형을 이해하고\(따라서 415\(지원되지 않는 미디어 유형\) 상태 코드가 부적절함\) 요청 콘텐츠의 구문은 정확하지만 서버가 요청 콘텐츠를 처리할 수 없음을 나타냅니다. 포함된 지침을 처리합니다. 예를 들어, XML 요청 콘텐츠에 올바른 형식\(구문상으로는 정확\)이 포함되어 있지만 의미상으로 잘못된 XML 명령이 포함된 경우 이 상태 코드가 전송될 수 있습니다.

---
#### **15.5.22.  426 Upgrade Required**

426\(업그레이드 필요\) 상태 코드는 서버가 현재 프로토콜을 사용하여 요청 수행을 거부하지만 클라이언트가 다른 프로토콜로 업그레이드한 후에는 기꺼이 수행할 수 있음을 나타냅니다. 서버는 필요한 프로토콜을 나타내기 위해 426 응답으로 업그레이드 헤더 필드를 보내야 합니다\(7.8절\).

```text
   Example:

   HTTP/1.1 426 Upgrade Required
   Upgrade: HTTP/3.0
   Connection: Upgrade
   Content-Length: 53
   Content-Type: text/plain
```

이 서비스를 사용하려면 HTTP/3.0 프로토콜을 사용해야 합니다.

---
### **15.6.  Server Error 5xx**

상태 코드의 5xx\(서버 오류\) 클래스는 서버가 오류가 발생했거나 요청된 메서드를 수행할 수 없음을 인식하고 있음을 나타냅니다. HEAD 요청에 응답할 때를 제외하고 서버는 오류 상황에 대한 설명과 그것이 일시적인지 영구적인지 여부를 포함하는 표현을 보내야 합니다. 사용자 에이전트는 포함된 모든 표현을 사용자에게 표시해야 합니다\(SHOULD\). 이러한 상태 코드는 모든 요청 방법에 적용 가능합니다.

---
#### **15.6.1.  500 Internal Server Error**

500\(내부 서버 오류\) 상태 코드는 서버가 요청을 이행하지 못하게 하는 예상치 못한 상황에 직면했음을 나타냅니다.

---
#### **15.6.2.  501 Not Implemented**

501\(구현되지 않음\) 상태 코드는 서버가 요청을 이행하는 데 필요한 기능을 지원하지 않음을 나타냅니다. 이는 서버가 요청 방법을 인식하지 못하고 어떤 리소스에도 이를 지원할 수 없는 경우에 적합한 응답입니다.

501 응답은 경험적으로 캐시 가능합니다. 즉, 메서드 정의나 명시적인 캐시 제어로 달리 지정되지 않는 한\(\[CACHING\]의 섹션 4.2.2 참조\)

---
#### **15.6.3.  502 Bad Gateway**

502\(잘못된 게이트웨이\) 상태 코드는 서버가 게이트웨이 또는 프록시 역할을 하는 동안 요청을 이행하려고 시도하는 동안 액세스한 인바운드 서버로부터 잘못된 응답을 받았음을 나타냅니다.

---
#### **15.6.4.  503 Service Unavailable**

503\(서비스를 사용할 수 없음\) 상태 코드는 일시적인 과부하 또는 예정된 유지 관리로 인해 서버가 현재 요청을 처리할 수 없음을 나타냅니다. 이는 약간의 지연 후에 완화될 가능성이 높습니다. 서버는 요청을 재시도하기 전에 클라이언트가 기다려야 할 적절한 시간을 제안하기 위해 Retry-After 헤더 필드\(섹션 10.2.3\)를 보낼 수 있습니다.

- | \*참고:\* 503 상태 코드가 있다고 해서 | 서버가 과부하 상태가 되면 이를 사용해야 한다는 것입니다. 일부 | 서버는 단순히 연결을 거부할 수도 있습니다.

---
#### **15.6.5.  504 Gateway Timeout**

504\(게이트웨이 시간 초과\) 상태 코드는 서버가 게이트웨이 또는 프록시 역할을 하는 동안 요청을 완료하기 위해 액세스해야 하는 업스트림 서버로부터 적시에 응답을 받지 못했음을 나타냅니다.

---
#### **15.6.6.  505 HTTP Version Not Supported**

505\(HTTP 버전 지원 안 됨\) 상태 코드는 서버가 요청 메시지에 사용된 HTTP의 주요 버전을 지원하지 않거나 지원을 거부함을 나타냅니다. 서버는 이 오류 메시지 외에 섹션 2.5에 설명된 대로 클라이언트와 동일한 주요 버전을 사용하여 요청을 완료할 수 없거나 완료할 의사가 없음을 나타냅니다. 서버는 해당 버전이 지원되지 않는 이유와 해당 서버에서 지원하는 다른 프로토콜을 설명하는 505 응답에 대한 표현을 생성해야 합니다.

---
## **16.  Extending HTTP**

HTTP는 메서드, 상태 코드, 필드 이름, 인증 체계 및 캐시 지시문과 같은 정의된 필드 내의 추가 확장성 지점을 포함하여 새 버전을 도입하지 않고도 프로토콜에 기능을 도입하는 데 사용할 수 있는 여러 일반 확장 지점을 정의합니다\(참조\). \[CACHING\] 섹션 5.2.3의 캐시 제어 확장\). HTTP의 의미 체계는 버전이 지정되지 않기 때문에 이러한 확장 지점은 지속됩니다. 사용 중인 프로토콜 버전은 의미에 영향을 주지 않습니다.

버전 독립적 확장은 사용 중인 특정 프로토콜 버전에 의존하거나 상호 작용하는 것이 권장되지 않습니다. 이것이 불가피한 경우 확장이 여러 버전에서 어떻게 상호 운용될 수 있는지 신중하게 고려해야 합니다.

또한 특정 버전의 HTTP에는 HTTP/1.1\(\[HTTP/1.1\]의 섹션 6.1\)의 전송 코딩 및 HTTP/2 설정 또는 프레임 유형\(\[HTTP/2\]\)과 같은 자체 확장 지점이 있을 수 있습니다. 이러한 확장 지점은 해당 확장 지점이 발생하는 프로토콜 버전에 따라 다릅니다.

버전별 확장은 해당 프로토콜 요소에서 명시적으로 허용하지 않는 한 버전 독립적 메커니즘이나 확장 지점\(예: 메서드 또는 헤더 필드\)의 의미를 재정의하거나 수정할 수 없습니다. 예를 들어 CONNECT 메소드\(9.3.6절\)가 이를 허용합니다.

이러한 지침은 경로의 일부가 다른 버전의 HTTP를 구현하는 경우에도 프로토콜이 정확하고 예측 가능하게 작동하도록 보장합니다.

---
### **16.1.  Method Extensibility**
---
#### **16.1.1.  Method Registry**

IANA가 관리하는 "HTTP\(Hypertext Transfer Protocol\) 메소드 레지스트리"\(<https://www.iana.org/locationments/http-methods\>\)는 메소드 이름을 등록합니다.

HTTP 메소드 등록에는 다음 필드가 포함되어야 합니다.

```text
   *  Method Name (see Section 9)
```

\* 안전함\("예" 또는 "아니오", 섹션 9.2.1 참조\)

\* 멱등성\("예" 또는 "아니요", 섹션 9.2.2 참조\)

\* 사양 텍스트에 대한 포인터

이 네임스페이스에 추가할 값에는 IETF 검토가 필요합니다\(\[RFC8126\], 섹션 4.8 참조\).

---
#### **16.1.2.  Considerations for New Methods**

표준화된 방법은 일반적입니다. 즉, 특정 미디어 유형, 리소스 종류 또는 애플리케이션뿐만 아니라 모든 리소스에 잠재적으로 적용할 수 있습니다. 따라서 직교 기술은 직교 사양을 받을 자격이 있으므로 단일 응용 프로그램이나 데이터 형식에 국한되지 않는 문서에 새로운 방법을 등록하는 것이 좋습니다.

메시지 구문 분석\(섹션 6\)은 메서드 의미론\(HEAD에 대한 응답 제외\)과 독립적이어야 하므로 새로운 메서드 정의는 구문 분석 알고리즘을 변경하거나 요청 또는 응답 메시지에 콘텐츠가 존재하는 것을 금지할 수 없습니다. 새로운 메소드 정의에서는 값이 "0"인 Content-Length 헤더 필드를 요구하여 길이가 0인 콘텐츠만 허용되도록 지정할 수 있습니다.

마찬가지로, 새로운 메소드는 각각 CONNECT 및 OPTIONS에 허용되는 요청 대상의 특수한 호스트:포트 및 별표 형식을 사용할 수 없습니다\(7.1절\). 대상 URI에는 절대 형식의 전체 URI가 필요합니다. 즉, 요청 대상을 절대 형식으로 보내야 하거나 대상 URI가 다른 메서드와 동일한 방식으로 요청 컨텍스트에서 재구성된다는 의미입니다.

새로운 메서드 정의는 안전한지\(섹션 9.2.1\), 멱등성\(섹션 9.2.2\), 캐시 가능한지\(섹션 9.2.3\), 요청 콘텐츠와 연결되는 의미\(있는 경우\)를 나타내야 합니다. 메소드가 헤더 필드 또는 상태 코드 의미를 어떻게 개선하는지. 새로운 메소드가 캐시 가능하다면 그 정의는 캐시가 응답을 저장하고 이를 사용하여 후속 요청을 충족할 수 있는 방법과 조건을 설명해야 합니다. 새로운 메서드는 조건부로 만들 수 있는지\(13.1절\), 그렇다면 조건이 false일 때 서버가 어떻게 응답하는지 설명해야 합니다. 마찬가지로, 새로운 방법이 부분 응답 의미론\(14.2절\)에 어느 정도 사용될 수 있다면 이 방법도 문서화해야 합니다.

- | \*참고:\* "M-"으로 시작하는 메서드 이름을 정의하지 마세요. | 해당 접두사가 |를 갖는 것으로 잘못 해석될 수 있기 때문입니다. \[RFC2774\]에 의해 할당된 의미.

---
### **16.2.  Status Code Extensibility**
---
#### **16.2.1.  Status Code Registry**

<https://www.iana.org/locationments/http-status-codes\>에서 IANA가 관리하는 "HTTP\(Hypertext Transfer Protocol\) 상태 코드 레지스트리"는 상태 코드 번호를 등록합니다.

등록에는 다음 필드가 포함되어야 합니다.

```text
   *  Status Code (3 digits)

   *  Short Description
```

\* 사양 텍스트에 대한 포인터

HTTP 상태 코드 네임스페이스에 추가할 값에는 IETF 검토가 필요합니다\(\[RFC8126\], 섹션 4.8 참조\).

---
#### **16.2.2.  Considerations for New Status Codes**

현재 상태 코드로 정의되지 않은 응답에 대해 의미를 표현해야 하는 경우 새로운 상태 코드를 등록할 수 있습니다. 상태 코드는 일반적입니다. 이는 특정 미디어 유형, 리소스 종류 또는 HTTP 애플리케이션뿐만 아니라 모든 리소스에 잠재적으로 적용 가능합니다. 따라서 단일 애플리케이션에만 국한되지 않는 문서에 새 상태 코드를 등록하는 것이 좋습니다.

새로운 상태 코드는 섹션 15에 정의된 범주 중 하나에 속해야 합니다. 기존 파서가 응답 메시지를 처리할 수 있도록 하기 위해 새 상태 코드는 길이가 0인 콘텐츠를 요구할 수 있지만 콘텐츠를 허용하지 않을 수 없습니다.

아직 널리 배포되지 않은 새로운 상태 코드에 대한 제안은 코드가 등록될 것이라는 명확한 합의가 있을 때까지 코드에 특정 번호를 할당하지 않아야 합니다. 대신, 초기 초안에서는 "4NN" 또는 "3N0" .. "3N9"와 같은 표기법을 사용하여 조기에 숫자를 사용하지 않고 제안된 상태 코드의 클래스를 나타낼 수 있습니다.



기본적으로 상태 코드는 발생하는 응답에 해당하는 요청에만 적용됩니다. 상태 코드가 더 넓은 적용 범위에 적용되는 경우\(예: 문제의 리소스에 대한 모든 요청 또는 서버에 대한 모든 요청\) 이를 명시적으로 지정해야 합니다. 그렇게 할 때 모든 클라이언트가 새 상태 코드를 이해하지 못할 수 있으므로 더 큰 범위를 일관되게 적용할 것으로 예상할 수는 없다는 점에 유의해야 합니다.

새로운 최종 상태 코드의 정의는 경험적으로 캐시 가능한지 여부를 지정해야 합니다. 응답에 명시적인 최신 정보가 있는 경우 최종 상태 코드가 있는 응답은 캐시될 수 있습니다. 경험적으로 캐시 가능하다고 정의된 상태 코드는 명시적인 신선도 정보 없이 캐시될 수 있습니다. 마찬가지로, must-understand 캐시 지시문이 사용되는 경우 상태 코드 정의는 캐시 동작에 제약을 둘 수 있습니다. 자세한 내용은 \[캐싱\]을 참조하세요.

마지막으로, 새로운 상태 코드의 정의는 콘텐츠가 식별된 리소스와 암시적인 연관성을 가지고 있는지 여부를 나타내야 합니다\(섹션 6.4.2\).

---
### **16.3.  Field Extensibility**

HTTP에서 가장 널리 사용되는 확장성 지점은 새로운 헤더 및 트레일러 필드의 정의입니다.

수신자가 이해할 때 이전에 정의된 필드의 해석을 재정의하거나 향상시키거나, 요청 평가에 대한 전제 조건을 정의하거나, 응답의 의미를 구체화하도록 새 필드를 정의할 수 있습니다.

그러나 필드를 정의한다고 해서 수신자의 배포나 인식이 보장되는 것은 아닙니다. 대부분의 필드는 수신자가 인식되지 않는 필드를 안전하게 무시\(그러나 다운스트림 전달\)할 수 있다는 기대를 가지고 설계되었습니다. 다른 경우에는 특정 필드를 이해하는 발신자의 능력이 이전 통신, 아마도 이전 메시지에서 보낸 프로토콜 버전이나 필드 또는 특정 미디어 유형의 사용으로 표시될 수 있습니다. 마찬가지로 OPTIONS 요청을 통해 또는 해당 검사가 도입되는 필드와 함께 정의된 경우 정의된 잘 알려진 URI \[RFC8615\]와 상호 작용하여 지원에 대한 직접적인 검사가 가능할 수 있습니다.

---
#### **16.3.1.  Field Name Registry**

"HTTP\(Hypertext Transfer Protocol\) 필드 이름 레지스트리"는 HTTP 필드 이름에 대한 네임스페이스를 정의합니다.

모든 당사자는 HTTP 필드 등록을 요청할 수 있습니다. 새 HTTP 필드를 생성할 때 고려해야 할 사항은 섹션 16.3.2를 참조하세요.

"HTTP\(Hypertext Transfer Protocol\) 필드 이름 레지스트리"는 <https://www.iana.org/locationments/http-fields/\>에 있습니다. 등록 요청은 해당 지침을 따르거나 "ietf-http-wg@w3.org" 메일링 리스트로 이메일을 보내서 할 수 있습니다.

필드 이름은 지정된 전문가\(IESG 또는 그 대리인이 임명\)의 조언에 따라 등록됩니다. 상태가 '영구'인 필드는 사양이 필요합니다\(\[RFC8126\], 섹션 4.6\).

등록 요청은 다음 정보로 구성됩니다.

필드 이름: - 요청된 필드 이름입니다. 이는 섹션 5.1에 정의된 필드 이름 구문을 준수해야 하며 문자, 숫자 및 하이픈\('-'\) 문자로만 제한되어야 하며 첫 번째 문자는 문자여야 합니다.

상태: - "영구", "임시", "더 이상 사용되지 않음" 또는 "사용되지 않음".

사양 문서: - 필드를 지정하는 문서에 대한 참조입니다. 문서의 복사본을 검색하는 데 사용할 수 있는 URI를 포함하는 것이 좋습니다. 선택 사항이지만 임시 등록을 권장합니다. 관련 섹션의 표시도 포함될 수 있지만 필수는 아닙니다.

그리고 선택적으로:

설명: 예약된 항목에 대한 추가 정보입니다.

전문가는 커뮤니티와 협의하여 레지스트리에 수집할 추가 필드를 정의할 수 있습니다.

표준 정의 이름은 "영구" 상태를 갖습니다. 전문가가 커뮤니티와의 협의를 통해 다른 이름이 사용 중임을 확인한 경우 다른 이름도 영구적으로 등록할 수 있습니다. 다른 이름은 "임시"로 등록해야 합니다.

임시 항목은 커뮤니티와 협의하여 전문가가 해당 항목이 사용되지 않는다고 판단한 경우 전문가가 제거할 수 있습니다. 전문가는 언제든지 임시 항목의 상태를 영구 항목으로 변경할 수 있습니다.

전문가가 등록되지 않은 이름이 널리 배포되어 적시에 등록될 가능성이 없다고 판단하는 경우 제3자\(전문가 포함\)가 이름을 등록할 수 있습니다.

---
#### **16.3.2.  Considerations for New Fields**

HTTP 헤더 및 트레일러 필드는 프로토콜의 확장 지점으로 널리 사용됩니다. 임시적으로 사용할 수 있지만 더 폭넓게 사용하도록 의도된 필드는 상호 운용성을 보장하기 위해 주의 깊게 문서화해야 합니다.

특히, 새로운 필드를 정의하는 사양 작성자는 다음 측면을 고려하고 적절한 경우 문서화하는 것이 좋습니다.

\* 어떤 조건에서 해당 필드를 사용할 수 있습니까? 예를 들어, 응답이나 요청에서만, 모든 메시지에서, 특정 요청 방법에 대한 응답에서만 등.

\* 필드 의미가 특정 요청 방법이나 상태 코드와 함께 사용되는 등 해당 컨텍스트에 따라 추가로 구체화되는지 여부.

\* 전달되는 정보의 적용범위는 다음과 같습니다. 기본적으로 필드는 연결된 메시지에만 적용되지만 일부 응답 필드는 리소스의 모든 표현, 리소스 자체 또는 더 넓은 범위에 적용되도록 설계되었습니다. 응답 필드의 범위를 확장하는 사양은 콘텐츠 협상, 적용 기간 및 \(경우에 따라\) 다중 테넌트 서버 배포와 같은 문제를 신중하게 고려해야 합니다.

\* 중개자가 필드 값을 삽입, 삭제 또는 수정할 수 있는 조건은 무엇입니까?

\* 예고편에 해당 필드가 허용되는 경우; 기본적으로는 그렇지 않습니다\(섹션 6.5.1 참조\).

\* 연결 헤더 필드에 필드 이름을 나열하는 것이 적절한지 또는 필요한지 여부\(즉, 필드가 hop-by-hop인 경우, 섹션 7.6.1 참조\).

\* 현장에서 개인 정보 보호 관련 데이터 공개와 같은 추가 보안 고려 사항을 도입하는지 여부.

요청 헤더 필드에는 기본 동작이 적절하지 않은 경우 문서화해야 하는 추가 고려 사항이 있습니다.

\* Vary 응답 헤더 필드에 필드 이름을 나열하는 것이 적절한 경우\(예: 요청 헤더 필드가 원서버의 콘텐츠 선택 알고리즘에 의해 사용되는 경우, 섹션 12.5.5 참조\).

\* 필드가 PUT 요청에서 수신될 때 저장되도록 의도된 경우\(섹션 9.3.4 참조\).

\* 보안 문제로 인해 요청을 자동으로 리디렉션할 때 필드를 제거해야 하는 경우\(섹션 15.4 참조\)

---
##### **16.3.2.1.  Considerations for New Field Names**

새 필드를 정의하는 사양 작성자는 짧지만 설명이 포함된 필드 이름을 선택하는 것이 좋습니다. 짧은 이름은 불필요한 데이터 전송을 방지합니다. 설명적인 이름은 더 광범위하게 사용될 수 있는 이름에 대한 혼란과 "무단 점유"를 방지합니다.

이를 위해 제한된 사용 필드\(예: 단일 애플리케이션 또는 사용 사례에 국한된 헤더\)에서는 해당 사용\(또는 약어\)을 접두사로 포함하는 이름을 사용하는 것이 좋습니다. 예를 들어 Foo 애플리케이션에 설명 필드가 필요한 경우 "Foo-Desc"를 사용할 수 있습니다. "설명"은 너무 일반적이고 "Foo-Description"은 불필요하게 깁니다.

필드 이름 구문은 모든 토큰 문자를 허용하도록 정의되어 있지만 실제로 일부 구현에서는 필드 이름에 허용되는 문자에 제한을 둡니다. 상호 운용이 가능하려면 새 필드 이름이 영숫자 문자\("-" 및 "."\)로 제한되어야 하며 문자로 시작해야 합니다\(SHOULD\). 예를 들어 밑줄\("\_"\) 문자는 HTTP가 아닌 게이트웨이 인터페이스를 통해 전달될 때 문제가 될 수 있습니다\(섹션 17.10 참조\).

필드 이름에는 "X-" 접두사가 붙으면 안 됩니다. 자세한 내용은 \[BCP178\]을 참조하세요.

HTTP 필드 이름에 다른 접두사가 사용되는 경우도 있습니다. 예를 들어 "Accept-"는 많은 콘텐츠 협상 헤더에서 사용되며 "Content-"는 섹션 6.4에 설명된 대로 사용됩니다. 이러한 접두사는 필드의 목적을 인식하는 데 도움이 될 뿐이며 자동 처리를 트리거하지 않습니다.

---
##### **16.3.2.2.  Considerations for New Field Values**

새로운 HTTP 필드 정의의 주요 작업은 필드 값 구문\(발신자가 생성해야 하는 항목, 수신자가 수신된 항목에서 의미를 추론하는 방법\)을 지정하는 것입니다.

작성자는 이 사양의 ABNF 규칙이나 \[RFC8941\]의 규칙을 사용하여 새 필드 값의 구문을 정의하는 것이 좋습니다\(필수는 아님\).

저자는 여러 필드 라인의 조합이 자신에게 어떤 영향을 미칠지 신중하게 고려하는 것이 좋습니다\(섹션 5.3 참조\). 발신자가 실수로 여러 값을 보낼 수 있고 중개자와 HTTP 라이브러리 모두 자동으로 조합을 수행할 수 있으므로 이는 단일 값만 예상되는 경우에도 모든 필드 값에 적용됩니다.

따라서 작성자는 쉼표가 포함된 값을 구분하거나 인코딩하는 것이 좋습니다\(예: 섹션 5.6.4의 인용 문자열 규칙, \[RFC8941\]의 문자열 데이터 유형 또는 필드별 인코딩을 사용\). 이렇게 하면 필드 데이터 내의 쉼표가 목록 값을 구분하는 쉼표와 혼동되지 않습니다.

예를 들어, Content-Type 필드 값은 따옴표로 묶인 문자열 내의 쉼표만 허용하므로 여러 값이 있는 경우에도 안정적으로 구문 분석할 수 있습니다. Location 필드 값은 에뮬레이션해서는 안되는 반례를 제공합니다. URI에는 쉼표가 포함될 수 있으므로 두 값에서 쉼표가 포함된 단일 값을 확실하게 구별하는 것이 불가능합니다.

싱글톤 값\(섹션 5.5 참조\)이 있는 필드의 작성자는 여러 멤버가 있는 메시지를 처리하는 방법을 문서화하는 것이 좋습니다\(합리적인 기본값은 필드를 무시하는 것이지만 이것이 항상 올바른 선택은 아닐 수도 있음\).

---
### **16.4.  Authentication Scheme Extensibility**
---
#### **16.4.1.  Authentication Scheme Registry**

"HTTP\(Hypertext Transfer Protocol\) 인증 체계 레지스트리"는 챌린지 및 자격 증명의 인증 체계에 대한 네임스페이스를 정의합니다. <https://www.iana.org/locationments/http-authschemes\>에서 관리됩니다.

등록에는 다음 필드가 포함되어야 합니다.

```text
   *  Authentication Scheme Name
```

\* 사양 텍스트에 대한 포인터

```text
   *  Notes (optional)
```

이 네임스페이스에 추가할 값에는 IETF 검토가 필요합니다\(\[RFC8126\], 섹션 4.8 참조\).

---
#### **16.4.2.  Considerations for New Authentication Schemes**

새로운 인증 체계가 작동하는 방식에 제약을 가하는 HTTP 인증 프레임워크의 특정 측면이 있습니다.

\* HTTP 인증은 상태 비저장으로 간주됩니다. 요청을 인증하는 데 필요한 모든 정보는 이전 요청을 기억하는 서버에 의존하기보다는 요청에 제공되어야 합니다. 기본 연결을 기반으로 하거나 바인딩된 인증은 이 사양의 범위를 벗어나며 인증된 사용자 이외의 다른 당사자가 연결을 사용할 수 없도록 하는 조치를 취하지 않는 한 본질적으로 결함이 있습니다\(섹션 3.3 참조\).

\* 인증 매개변수 "영역"은 섹션 11.5에 설명된 대로 보호 공간을 정의하기 위해 예약되어 있습니다. 새로운 체계는 해당 정의와 호환되지 않는 방식으로 이를 사용해서는 안 됩니다.

\* "token68" 표기법은 기존 인증 체계와의 호환성을 위해 도입되었으며 챌린지 또는 자격 증명당 한 번만 사용할 수 있습니다. 따라서 새로운 체계에서는 auth-param 구문을 대신 사용해야 합니다. 그렇지 않으면 향후 확장이 불가능하기 때문입니다.

\* 챌린지 및 자격 증명의 구문 분석은 이 사양에 의해 정의되며 새로운 인증 체계로 수정할 수 없습니다. auth-param 구문을 사용하는 경우 모든 매개변수는 토큰 및 인용 문자열 구문을 모두 지원해야 하며 구문 분석\(예: 인용 문자열 처리\) 후 필드 값에 대해 구문 제약 조건을 정의해야 합니다. 이는 수신자가 모든 인증 체계에 적용되는 일반 구문 분석기를 사용할 수 있도록 하기 위해 필요합니다.

- \*참고:\* "realm" 매개변수의 값 구문이 인용 문자열로 제한된다는 사실은 새 매개변수에 대해 반복되지 않도록 하는 잘못된 설계 선택이었습니다.

\* 새로운 계획의 정의는 알려지지 않은 확장 매개변수의 처리를 정의해야 합니다. 일반적으로 "무시해야 함" 규칙이 "이해해야 함" 규칙보다 선호됩니다. 그렇지 않으면 레거시 수신자가 있는 경우 새 매개 변수를 도입하기가 어렵기 때문입니다. 또한, 새로운 매개변수를 정의하기 위한 정책\(예: "사양 업데이트" 또는 "이 레지스트리 사용"\)을 설명하는 것이 좋습니다.

\* 인증 체계는 원본 서버 인증\(예: WWW-인증 사용\) 및/또는 프록시 인증\(예: 프록시 인증 사용\)에서 사용할 수 있는지 여부를 문서화해야 합니다.

\* Authorization 헤더 필드에 포함된 자격 증명은 사용자 에이전트에 따라 다르므로 HTTP 캐시에 "private" 캐시 응답 지시어\(\[CACHING\]의 섹션 5.2.2.7\)와 동일한 효과를 갖습니다. 그들이 나타나는 요청.

- 따라서 Authorization 헤더 필드에 자격 증명을 전달하지 않기로 선택한 새로운 인증 방식\(예: 새로 정의된 헤더 필드 사용\)은 캐시 응답 지시어\(예: "private"\) 사용을 의무화하여 명시적으로 캐싱을 허용하지 않아야 합니다.

\* 인증 정보, 프록시 인증 정보 또는 기타 인증 관련 응답 헤더 필드를 사용하는 방식은 관련 보안 고려 사항을 고려하고 문서화해야 합니다\(섹션 17.16.4 참조\).

---
### **16.5.  Range Unit Extensibility**
---
#### **16.5.1.  Range Unit Registry**

"HTTP 범위 단위 레지스트리"는 범위 단위 이름에 대한 네임스페이스를 정의하고 해당 사양을 참조합니다. <https://www.iana.org/locationments/http-parameters\>에서 관리됩니다.

HTTP 범위 단위 등록에는 다음 필드가 포함되어야 합니다.

```text
   *  Name

   *  Description
```

\* 사양 텍스트에 대한 포인터

이 네임스페이스에 추가할 값에는 IETF 검토가 필요합니다\(\[RFC8126\], 섹션 4.8 참조\).

---
#### **16.5.2.  Considerations for New Range Units**

페이지, 섹션, 레코드, 행 또는 시간과 같은 형식별 경계와 같은 기타 범위 단위는 응용프로그램별 목적으로 HTTP에서 잠재적으로 사용할 수 있지만 실제로는 일반적으로 사용되지 않습니다. 대체 범위 단위의 구현자는 콘텐츠 코딩 및 범용 중개자와 어떻게 작동할지 고려해야 합니다.

---
### **16.6.  Content Coding Extensibility**
---
#### **16.6.1.  Content Coding Registry**

<https://www.iana.org/locationments/http-parameters/\>에서 IANA가 관리하는 "HTTP 콘텐츠 코딩 레지스트리"는 콘텐츠 코딩 이름을 등록합니다.

콘텐츠 코딩 등록에는 다음 필드가 포함되어야 합니다.

```text
   *  Name

   *  Description
```

\* 사양 텍스트에 대한 포인터

콘텐츠 코딩의 이름은 인코딩 변환이 동일하지 않는 한\(<https://www.iana.org/locationments/http-parameters/\>에 있는 "HTTP Transfer Coding Registry"에 따라\) 전송 코딩의 이름과 겹쳐서는 안 됩니다\(MUST NOT\). 섹션 8.4.1에 정의된 압축 코딩의 경우입니다.

이 네임스페이스에 추가되는 값은 IETF 검토\(\[RFC8126\]의 섹션 4.8 참조\)가 필요하며 섹션 8.4.1에 정의된 콘텐츠 코딩의 목적을 준수해야 합니다.

---
#### **16.6.2.  Considerations for New Content Codings**

새로운 콘텐츠 코딩은 전송 중에 손실될 수 있는 외부 메타데이터에 의존하기보다는 코딩 형식 자체 내에서 검색 가능한 선택적 매개변수를 사용하여 가능할 때마다 자체 설명적이어야 합니다.

---
### **16.7.  Upgrade Token Registry**

"HTTP\(Hypertext Transfer Protocol\) 업그레이드 토큰 레지스트리"는 업그레이드 헤더 필드에서 프로토콜을 식별하는 데 사용되는 프로토콜 이름 토큰의 네임스페이스를 정의합니다. 레지스트리는 <https://www.iana.org/locationments/http-upgrade-tokens\>에서 유지 관리됩니다.

등록된 각 프로토콜 이름은 연락처 정보 및 연결이 업그레이드된 후 연결이 처리되는 방법을 자세히 설명하는 선택적 사양 세트와 연결됩니다.

등록은 "선착순" 방식으로 이루어지며\(\[RFC8126\]의 섹션 4.4 참조\) 다음 규칙이 적용됩니다.

1. 프로토콜 이름 토큰은 한 번 등록되면 영원히 등록된 상태로 유지됩니다.

1. 프로토콜 이름 토큰은 대소문자를 구분하지 않으며 보낸 사람이 생성할 기본 대소문자로 등록됩니다.

1. 등록에는 등록에 대한 책임이 있는 당사자가 명시되어야 합니다.

1. 등록에는 연락처가 명시되어야 합니다.

1. 등록은 해당 토큰과 관련된 일련의 사양을 명명할 수 있습니다. 이러한 사양은 공개적으로 이용 가능해야 할 필요는 없습니다.

1. 등록 시에는 등록 시 해당 토큰과 관련된 예상 "프로토콜 버전" 토큰 세트의 이름을 지정해야 합니다.

1. 책임 있는 당사자는 언제든지 등록을 변경할 수 있습니다. IANA는 이러한 모든 변경 사항을 기록하고 요청 시 제공합니다.

1. IESG는 프로토콜 토큰에 대한 책임을 재할당할 수 있습니다. 이는 일반적으로 책임 있는 당사자에게 연락할 수 없는 경우에만 사용됩니다.

---
## **17.  Security Considerations**

이 섹션은 개발자, 정보 제공자 및 사용자에게 HTTP 의미 체계 및 인터넷을 통해 정보를 전송하는 데 사용되는 HTTP 의미와 관련된 알려진 보안 문제를 알리기 위한 것입니다. 캐싱과 관련된 고려 사항은 \[CACHING\]의 섹션 7에서 논의되고, HTTP/1.1 메시지 구문 및 구문 분석과 관련된 고려 사항은 \[HTTP/1.1\]의 섹션 11에서 논의됩니다.

아래 고려 사항 목록은 완전한 것이 아닙니다. HTTP 의미론과 관련된 대부분의 보안 문제는 프로토콜 보안보다는 서버 측 애플리케이션\(HTTP 인터페이스 뒤의 코드\) 보안, HTTP를 통해 수신된 콘텐츠의 사용자 에이전트 처리 보안 또는 일반적인 인터넷 보안 사용에 관한 것입니다. HTTP 작업의 기본인 URI에 대한 보안 고려 사항은 \[URI\]의 섹션 7에서 논의됩니다. 다양한 조직에서는 웹 애플리케이션 보안에 대한 최신 연구\(예: \[OWASP\]\)에 대한 주제 정보와 링크를 유지 관리합니다.

---
### **17.1.  Establishing Authority**

HTTP는 "권한 있는 응답"이라는 개념에 의존합니다. 대상 리소스의 상태를 고려하여 해당 요청에 가장 적합한 응답으로 대상 URI 내에서 식별된 원본 서버에 의해\(또는 그 지시에 따라\) 결정된 응답입니다. 응답 메시지 발생 시.

등록된 이름이 권한 구성 요소에서 사용되는 경우 "http" URI 체계\(섹션 4.2.1\)는 사용자의 로컬 이름 확인 서비스에 의존하여 신뢰할 수 있는 응답을 찾을 수 있는 위치를 결정합니다. 이는 사용자의 네트워크 호스트 테이블, 캐시된 이름 또는 이름 확인 라이브러리에 대한 모든 공격이 "http" URI에 대한 권한을 설정하기 위한 공격 수단이 된다는 것을 의미합니다. 마찬가지로 사용자가 DNS\(도메인 이름 서비스\)용 서버를 선택하는 것과 확인 결과를 얻는 서버 계층 구조가 주소 매핑의 신뢰성에 영향을 미칠 수 있습니다. DNS 보안 확장\(DNSSEC, \[RFC4033\]\)은 보다 안전한 전송 프로토콜을 통해 DNS 요청을 수행하는 다양한 메커니즘과 마찬가지로 신뢰성을 향상시키는 한 가지 방법입니다.

더욱이, IP 주소를 획득한 후 "http" URI에 대한 권한을 설정하는 것은 인터넷 프로토콜 라우팅에 대한 공격에 취약합니다.

"https" 구성표\(섹션 4.2.2\)는 협상된 연결이 보안되고 클라이언트가 통신 서버의 ID가 대상과 일치하는지 적절하게 확인하는 경우 권한 설정에 대한 이러한 잠재적인 공격을 방지\(또는 적어도 드러내기\)하기 위한 것입니다. URI의 권한 구성 요소\(섹션 4.3.4\). 이러한 검증을 올바르게 구현하는 것은 어려울 수 있습니다\(\[Georgiev\] 참조\).

특정 원본 서버에 대한 권한은 프로토콜 확장을 통해 위임될 수 있습니다. 예를 들어 \[ALTSVC\]입니다. 마찬가지로, 연결이 신뢰할 수 있는 것으로 간주되는 서버 세트는 \[RFC8336\]과 같은 프로토콜 확장을 사용하여 변경할 수 있습니다.

공유 프록시 캐시와 같이 신뢰할 수 없는 소스에서 응답을 제공하는 것은 성능과 가용성을 향상시키는 데 유용한 경우가 많지만, 소스를 신뢰할 수 있거나 신뢰할 수 없는 응답을 안전하게 사용할 수 있는 경우에만 가능합니다.

불행하게도 사용자에게 권한을 전달하는 것은 어려울 수 있습니다. 예를 들어, "피싱"은 권한에 대한 사용자의 인식에 대한 공격으로, 권한 구성 요소를 난독화하는 사용자 정보의 도움을 받아 유사한 브랜드를 하이퍼텍스트로 표시함으로써 해당 인식이 오해될 수 있습니다\(섹션 4.2.1 참조\). 사용자 에이전트는 사용자가 작업을 수행하기 전에 대상 URI를 쉽게 검사할 수 있도록 하고, 사용자 정보가 있는 경우 눈에 띄게 구별\(또는 거부\)하고, 참조 문서가 다른 문서에서 온 경우 저장된 자격 증명과 쿠키를 보내지 않음으로써 피싱 공격의 영향을 줄일 수 있습니다. 알 수 없거나 신뢰할 수 없는 소스.

---
### **17.2.  Risks of Intermediaries**

HTTP 중개자는 본질적으로 경로상의 공격을 위해 위치합니다. 중개자가 실행되는 시스템이 손상되면 심각한 보안 및 개인 정보 보호 문제가 발생할 수 있습니다. 중개자는 보안 관련 정보, 개별 사용자 및 조직에 대한 개인 정보, 사용자 및 콘텐츠 제공자 소유의 독점 정보에 액세스할 수 있습니다. 손상된 중개자 또는 보안 및 개인 정보 보호 고려 사항을 고려하지 않고 구현 또는 구성된 중개자는 광범위한 잠재적 공격을 수행하는 데 사용될 수 있습니다.

공유 캐시를 포함하는 중개자는 \[CACHING\]의 섹션 7에 설명된 대로 캐시 중독 공격에 특히 취약합니다.

구현자는 설계 및 코딩 결정과 운영자에게 제공하는 구성 옵션\(특히 기본 구성\)이 개인 정보 보호 및 보안에 미치는 영향을 고려해야 합니다.

중개자는 그들이 운영하는 사람과 정책보다 더 신뢰할 수 없습니다. HTTP는 이 문제를 해결할 수 없습니다.

---
### **17.3.  Attacks Based on File and Path Names**

원본 서버는 로컬 파일 시스템을 사용하여 대상 URI에서 리소스 표현으로의 매핑을 관리하는 경우가 많습니다. 대부분의 파일 시스템은 악성 파일이나 경로 이름으로부터 보호하도록 설계되지 않았습니다. 따라서 원본 서버는 대상 리소스를 파일, 폴더 또는 디렉터리에 매핑할 때 시스템에 특별한 의미를 갖는 이름에 액세스하지 않아야 합니다.

예를 들어 UNIX, Microsoft Windows 및 기타 운영 체제는 ".."를 경로 구성 요소로 사용하여 현재 디렉터리 수준보다 높은 디렉터리 수준을 나타내며 특별히 명명된 경로나 파일 이름을 사용하여 시스템 장치에 데이터를 보냅니다. 다른 유형의 스토리지 시스템에도 유사한 명명 규칙이 있을 수 있습니다. 마찬가지로, 로컬 저장 시스템은 유효하지 않거나 예상치 못한 문자를 처리할 때, 분해된 문자를 재구성할 때, 대소문자를 구분하지 않는 이름의 대소문자 정규화를 처리할 때 보안보다 사용자 친화성을 선호하는 성가신 경향이 있습니다.

이러한 특수 이름을 기반으로 한 공격은 서비스 거부\(예: 서버에 COM 포트에서 읽도록 지시\) 또는 제공되지 않을 구성 및 소스 파일 공개에 초점을 맞추는 경향이 있습니다.

---
### **17.4.  Attacks Based on Command, Code, or Query Injection**

원본 서버는 시스템 서비스 식별, 데이터베이스 항목 선택 또는 데이터 소스 선택 수단으로 URI 내의 매개변수를 사용하는 경우가 많습니다. 그러나 요청으로 수신된 데이터는 신뢰할 수 없습니다. 공격자는 명령 호출, 언어 해석기 또는 데이터베이스 인터페이스를 통해 전달될 때 명령, 코드 또는 쿼리로 잘못 해석될 수 있는 데이터를 포함하도록 요청 데이터 요소\(메서드, 대상 URI, 헤더 필드 또는 콘텐츠\)를 구성할 수 있습니다. .

예를 들어, SQL 삽입은 대상 URI 또는 ​​헤더 필드\(예: 호스트, 참조자 등\)의 일부에 추가 쿼리 언어가 삽입되는 일반적인 공격입니다. 수신된 데이터가 SELECT 문 내에서 직접 사용되는 경우 쿼리 언어는 단순 문자열 값 대신 데이터베이스 명령으로 해석될 수 있습니다. 이러한 유형의 구현 취약점은 예방하기가 쉽지만 매우 일반적입니다.

일반적으로 리소스 구현은 명령으로 처리되거나 해석되는 컨텍스트에서 요청 데이터의 사용을 피해야 합니다. 매개변수는 신뢰할 수 없는 데이터에 대해 준비되지 않은 인터페이스를 통해 전달되기보다는 고정 문자열과 비교되어 해당 비교 결과에 따라 작동되어야 합니다. 고정된 매개변수를 기반으로 하지 않은 수신된 데이터는 잘못 해석되는 것을 방지하기 위해 신중하게 필터링하거나 인코딩해야 합니다.

요청 데이터를 저장하고 나중에 처리할 때\(예: 로그 파일, 모니터링 도구 내에서 또는 포함된 스크립트를 허용하는 데이터 형식에 포함될 때\) 유사한 고려 사항이 적용됩니다.

---
### **17.5.  Attacks via Protocol Element Length**

HTTP는 대부분 문자로 구분된 텍스트 필드를 사용하기 때문에 파서는 매우 긴\(또는 매우 느린\) 데이터 스트림 전송을 기반으로 하는 공격에 취약한 경우가 많습니다. 특히 구현이 미리 정의된 길이가 없는 프로토콜 요소를 기대하는 경우\(섹션 2.3\).

상호 운용성을 촉진하기 위해 필드의 최소 크기 제한에 대한 구체적인 권장 사항이 제시됩니다\(섹션 5.4\). 이는 제한된 리소스를 사용한 구현에서도 지원되도록 선택된 최소 권장 사항입니다. 대부분의 구현에서는 훨씬 더 높은 제한을 선택할 것으로 예상됩니다.

서버는 대상 URI가 너무 긴\(섹션 15.5.15\) 메시지를 거부하거나 너무 큰 콘텐츠를 요청할 수 있습니다\(섹션 15.5.14\). 용량 제한과 관련된 추가 상태 코드는 HTTP \[RFC6585\] 확장으로 정의되었습니다.

수신자는 요청 방법, 응답 상태 문구, 필드 이름, 숫자 값 및 청크 길이를 포함하되 이에 국한되지 않는 다른 프로토콜 요소를 처리하는 범위를 신중하게 제한해야 합니다. 이러한 처리를 제한하지 않으면 버퍼 또는 산술 오버플로로 인해 임의 코드가 실행될 수 있으며 서비스 거부 공격에 대한 취약성이 높아질 수 있습니다.

---
### **17.6.  Attacks Using Shared-Dictionary Compression**

암호화된 프로토콜에 대한 일부 공격은 동적 압축으로 생성된 크기 차이를 이용하여 기밀 정보를 노출합니다. 예를 들어 \[BREACH\]입니다. 이러한 공격은 공격자가 제어하는 ​​콘텐츠와 기밀 정보 사이에 중복성을 생성하는 데 의존합니다. 따라서 두 콘텐츠에 대해 동일한 사전을 사용하는 동적 압축 알고리즘은 공격자가 제어하는 ​​콘텐츠가 기밀 콘텐츠의 일부와 일치할 때 더 효율적으로 압축됩니다.

HTTP 메시지는 TLS 압축, 콘텐츠 코딩, 전송 코딩, 기타 확장 또는 버전별 메커니즘을 사용하는 등 다양한 방법으로 압축될 수 있습니다.

이 위험에 대한 가장 효과적인 완화 방법은 민감한 데이터에 대한 압축을 비활성화하거나 공격자가 제어하는 ​​데이터와 민감한 데이터를 엄격하게 분리하여 동일한 압축 사전을 공유할 수 없도록 하는 것입니다. 신중하게 설계하면 HPACK\(\[HPACK\]\)과 같은 제한된 사용 사례에서 악용 가능한 것으로 간주되지 않는 방식으로 압축 방식을 설계할 수 있습니다.

---
### **17.7.  Disclosure of Personal Information**

클라이언트는 리소스와 상호 작용하기 위해 사용자가 제공한 정보\(예: 사용자 이름, 위치, 메일 주소, 비밀번호, 암호화 키 등\)와 사용자의 검색 활동에 대한 정보를 포함하여 대량의 개인 정보에 접근하는 경우가 많습니다. 시간\(예: 기록, 북마크 등\) 구현에서는 의도하지 않은 개인 정보 공개를 방지해야 합니다.

---
### **17.8.  Privacy of Server Log Information**

서버는 시간이 지남에 따라 사용자의 요청에 대한 개인 데이터를 저장할 수 있는 위치에 있으며, 이를 통해 사용자의 독서 패턴이나 관심 주제를 식별할 수 있습니다. 특히 중개자에서 수집된 로그 정보에는 개별 사용자를 추적할 수 있는 다수의 사이트에 걸친 사용자 에이전트 상호 작용 기록이 포함되는 경우가 많습니다.

HTTP 로그 정보는 본질적으로 기밀입니다. 그 취급은 종종 법률과 규정에 의해 제한됩니다. 로그 정보는 안전하게 저장되어야 하며 분석을 위해서는 적절한 지침을 따라야 합니다. 개별 항목 내의 개인 정보를 익명화하면 도움이 되지만 일반적으로 다른 액세스 특성과의 상관 관계를 기반으로 실제 로그 추적이 재식별되는 것을 방지하는 것만으로는 충분하지 않습니다. 따라서 특정 클라이언트에 대한 액세스 추적은 키가 가명인 경우에도 게시하는 것이 안전하지 않습니다.

도난이나 우발적인 게시의 위험을 최소화하려면 로그 정보에서 사용자 식별자, IP 주소, 사용자 제공 쿼리 매개변수 등 개인 식별 정보가 더 이상 보안 운영 요구 사항을 지원하는 데 필요하지 않게 되는 즉시 삭제해야 합니다. , 감사 또는 사기 통제.

---
### **17.9.  Disclosure of Sensitive Information in URIs**

URI는 보안 리소스를 식별하는 경우에도 보안이 아닌 공유를 위한 것입니다. URI는 종종 디스플레이에 표시되고, 페이지가 인쇄될 때 템플릿에 추가되며, 보호되지 않은 다양한 책갈피 목록에 저장됩니다. 많은 서버, 프록시 및 사용자 에이전트는 제3자가 볼 수 있는 위치에 대상 URI를 기록하거나 표시합니다. 따라서 민감하거나 개인 식별이 가능하거나 공개 위험이 있는 정보를 URI에 포함시키는 것은 현명하지 않습니다.

애플리케이션이 클라이언트 측 메커니즘을 사용하여 GET을 사용하는 양식의 쿼리 필드와 같이 사용자 제공 정보에서 대상 URI를 구성하는 경우 URI 내 공개에 적합하지 않은 잠재적으로 민감한 데이터가 제공될 수 있습니다. POST는 일반적으로 URI를 구성하지 않기 때문에 이러한 경우에 선호되는 경우가 많습니다. 대신 양식의 POST는 요청 콘텐츠에 잠재적으로 민감한 데이터를 전송합니다. 그러나 이는 캐싱을 방해하고 그렇지 않으면 안전한 요청에 대해 안전하지 않은 방법을 사용합니다. 대체 해결 방법에는 URI를 구성하기 전에 사용자가 제공한 데이터를 변환하거나 중요하지 않은 일반 값만 포함하도록 데이터를 필터링하는 것이 포함됩니다. 마찬가지로 쿼리 결과를 다른\(서버 생성\) URI로 리디렉션하면 이후 링크에서 잠재적으로 민감한 데이터를 제거하고 나중에 재사용할 수 있도록 캐시 가능한 응답을 제공할 수 있습니다.

Referer 헤더 필드는 요청이 발생한 컨텍스트에 대해 대상 사이트에 알려주기 때문에 사용자의 즉각적인 검색 기록에 대한 정보와 참조 리소스의 URI에서 찾을 수 있는 개인 정보를 공개할 가능성이 있습니다. Referer 헤더 필드에 대한 제한 사항은 일부 보안 고려 사항을 다루기 위해 섹션 10.1.3에 설명되어 있습니다.

---
### **17.10.  Application Handling of Field Names**

서버는 HTTP가 아닌 게이트웨이 인터페이스와 프레임워크를 사용하여 수신된 요청을 처리하고 응답에 대한 콘텐츠를 생성하는 경우가 많습니다. 역사적인 이유로 이러한 인터페이스는 환경 변수에 적합한 이름 매핑을 사용하여 수신된 필드 이름을 외부 변수 이름으로 전달하는 경우가 많습니다.

예를 들어, \[RFC3875\]의 4.1.18절에 정의된 프로토콜별 메타 변수의 CGI\(Common Gateway Interface\) 매핑은 CGI의 표준 변수 중 하나에 해당하지 않는 수신된 헤더 필드에 적용됩니다. 매핑은 각 이름 앞에 "HTTP\_"를 추가하고 하이픈\("-"\)의 모든 인스턴스를 밑줄\("\_"\)로 변경하는 것으로 구성됩니다. 한 플랫폼에서 다음 플랫폼으로 애플리케이션 이동을 단순화하기 위해 이와 동일한 매핑이 다른 많은 애플리케이션 프레임워크에 상속되었습니다.

CGI에서 수신된 Content-Length 필드는 수신된 필드 값과 일치하는 문자열 값을 갖는 메타변수 "CONTENT\_LENGTH"로 전달됩니다. 대조적으로, 수신된 "Content\_Length" 헤더 필드는 프로토콜별 메타 변수 "HTTP\_CONTENT\_LENGTH"로 전달됩니다. 이는 애플리케이션이 기본 메타 변수 대신 프로토콜별 메타 변수를 실수로 읽는 경우 약간의 혼란을 초래할 수 있습니다. \(이러한 역사적 관행 때문에 섹션 16.3.2.1에서는 밑줄이 포함된 새 필드 이름 생성을 권장하지 않습니다.\)

불행하게도 필드 이름을 다른 인터페이스 이름으로 매핑하면 매핑이 불완전하거나 모호할 경우 보안 취약점이 발생할 수 있습니다. 예를 들어, 공격자가 "Transfer\_Encoding"이라는 필드를 보내면 순진한 인터페이스는 이를 "Transfer-Encoding" 필드와 동일한 변수 이름에 매핑하여 잠재적인 요청 밀수 취약점을 초래할 수 있습니다\(\[HTTP/의 섹션 11.2\). 1.1\]\).

관련 위험을 완화하기 위해 이러한 매핑을 수행하는 구현에서는 이름으로 수신된 잠재적 옥텟의 전체 범위\(HTTP 문법에서 권장되지 않거나 금지된 옥텟 포함\)에 대해 매핑을 명확하고 완전하게 만드는 것이 좋습니다. 예를 들어, 특이한 이름 문자가 있는 필드로 인해 요청이 차단되거나, 특정 필드가 제거되거나, 다른 필드와 구별하기 위해 이름이 다른 접두사와 함께 전달될 수 있습니다.

---
### **17.11.  Disclosure of Fragment after Redirects**

URI 참조 내에서 사용되는 조각 식별자는 요청으로 전송되지 않지만 구현자는 사용자 에이전트와 응답의 결과로 실행되는 모든 확장 프로그램 또는 스크립트에 해당 식별자가 표시된다는 점을 인식해야 합니다. 특히 리디렉션이 발생하고 원래 요청의 조각 식별자가 위치의 새 참조\(섹션 10.2.2\)에 의해 상속되면 이는 한 사이트의 조각을 다른 사이트에 공개하는 효과가 있을 수 있습니다. 첫 번째 사이트가 개인 정보를 조각으로 사용하는 경우 해당 상속을 차단하기 위해 다른 사이트로의 리디렉션에 \(아마도 비어 있는\) 조각 구성 요소가 포함되어 있는지 확인해야 합니다.

---
### **17.12.  Disclosure of Product Information**

User-Agent\(섹션 10.1.5\), Via\(섹션 7.6.3\) 및 Server\(섹션 10.2.4\) 헤더 필드는 종종 해당 발신자의 소프트웨어 시스템에 대한 정보를 공개합니다. 이론적으로 이는 공격자가 알려진 보안 허점을 악용하기 더 쉽게 만들 수 있습니다. 실제로 공격자는 사용 중인 명백한 소프트웨어 버전에 관계없이 모든 잠재적인 허점을 시도하는 경향이 있습니다.

네트워크 방화벽을 통해 포털 역할을 하는 프록시는 방화벽 뒤의 호스트를 식별할 수 있는 헤더 정보 전송과 관련하여 특별한 예방 조치를 취해야 합니다. Via 헤더 필드를 사용하면 중개자가 민감한 시스템 이름을 가명으로 바꿀 수 있습니다.

---
### **17.13.  Browser Fingerprinting**

브라우저 핑거프린팅은 고유한 특성 세트를 통해 시간이 지남에 따라 특정 사용자 에이전트를 식별하는 일련의 기술입니다. 이러한 특성에는 기본 전송 프로토콜, 기능 및 스크립팅 환경을 사용하는 방법과 관련된 정보가 포함될 수 있지만 여기서 특히 흥미로운 것은 HTTP를 통해 통신할 수 있는 일련의 고유한 특성입니다. 핑거프린팅은 사용자가 다른 형태의 데이터 수집\(예: 쿠키\)에 대해 가질 수 있는 해당 제어 없이 시간 경과에 따른 사용자 에이전트의 동작\(\[Bujlow\]\)을 추적할 수 있기 때문에 개인정보 보호 문제로 간주됩니다. 많은 범용 사용자 에이전트\(예: 웹 브라우저\)는 지문을 줄이기 위한 조치를 취했습니다.

지문 채취를 활성화할 만큼 충분히 고유한 정보를 서버에 공개할 수 있는 요청 헤더 필드가 많이 있습니다. From 헤더 필드가 가장 명확하지만 From은 사용자가 자체 식별을 원하는 경우에만 전송될 것으로 예상됩니다. 마찬가지로 쿠키 헤더 필드는 재식별이 가능하도록 의도적으로 설계되었으므로 지문 인식 문제는 사용자 에이전트 구성에 의해 쿠키가 비활성화되거나 제한되는 상황에만 적용됩니다.

User-Agent 헤더 필드에는 일반적으로 다른 특성과 결합될 때 특정 장치를 고유하게 식별하는 데 충분한 정보가 포함될 수 있습니다. 특히 사용자 에이전트가 사용자 시스템이나 확장에 대한 과도한 세부 정보를 보내는 경우 더욱 그렇습니다. 그러나 사용자가 가장 기대하지 않는 고유 정보의 소스는 Accept, Accept-Charset, Accept-Encoding 및 Accept-Language 헤더 필드를 포함한 사전 협상\(12.1절\)입니다.

지문 채취 문제 외에도 Accept-Language 헤더 필드를 자세히 사용하면 사용자가 비공개 성격으로 간주할 수 있는 정보가 드러날 수 있습니다. 예를 들어, 특정 언어 집합을 이해하는 것은 특정 민족 그룹의 구성원과 밀접한 상관관계가 있을 수 있습니다. 이러한 개인 정보 손실을 제한하는 접근 방식은 사용자 에이전트가 명시적으로 허용된 사이트를 제외하고 Accept-Language 전송을 생략하는 것입니다. 아마도 언어 협상이 유용할 수 있음을 나타내는 Vary 헤더 필드를 감지한 후 상호 작용을 통해 가능할 것입니다.

개인 정보 보호를 강화하기 위해 프록시를 사용하는 환경에서 사용자 에이전트는 사전 협상 헤더 필드를 보내는 데 보수적이어야 합니다. 높은 수준의 헤더 필드 구성 가능성을 제공하는 범용 사용자 에이전트는 너무 많은 세부 정보가 제공될 경우 발생할 수 있는 개인 정보 보호 손실에 대해 사용자에게 알려야 합니다. 극단적인 개인 정보 보호 조치로서 프록시는 릴레이된 요청에서 사전 협상 헤더 필드를 필터링할 수 있습니다.

---
### **17.14.  Validator Retention**

이 사양에서 정의한 유효성 검사기는 표현의 유효성을 보장하거나 악의적인 변경을 방지하거나 경로 공격을 감지하기 위한 것이 아닙니다. 기껏해야 모든 참가자가 정상적으로 작동할 때 보다 효율적인 캐시 업데이트와 낙관적인 동시 쓰기가 가능합니다. 최악의 경우 조건이 실패하고 클라이언트는 조건부 요청이 없는 HTTP 교환보다 더 해롭지 않은 응답을 받게 됩니다.

엔터티 태그는 개인 정보 보호 위험을 초래하는 방식으로 남용될 수 있습니다. 예를 들어, 사이트는 사용자 또는 사용자 에이전트에 고유한 의미상 유효하지 않은 엔터티 태그를 의도적으로 구성하고 이를 긴 신선도 시간으로 캐시 가능한 응답으로 보낸 다음 나중에 조건부 요청에서 해당 엔터티 태그를 읽을 수 있습니다. - 해당 사용자 또는 사용자 에이전트를 식별합니다. 이러한 식별 태그는 사용자 에이전트가 원래 캐시 항목을 유지하는 한 영구 식별자가 됩니다. 표현을 캐시하는 사용자 에이전트는 사용자가 저장된 쿠키를 지우거나 개인 브라우징 모드로 변경하는 등 개인 정보 보호 작업을 수행할 때마다 캐시가 지워지거나 교체되도록 해야 합니다.

---
### **17.15.  Denial-of-Service Attacks Using Range**

제한되지 않은 다중 범위 요청은 동일한 데이터의 겹치는 범위를 많이 요청하는 데 필요한 노력이 여러 부분에서 요청된 데이터를 제공하려고 시도하는 데 소비되는 시간, 메모리 및 대역폭에 비해 작기 때문에 서비스 거부 공격에 취약합니다. 서버는 세 개 이상의 겹치는 범위에 대한 요청이나 단일 세트의 많은 작은 범위에 대한 요청과 같은 심각한 범위 요청을 무시, 통합 또는 거부해야 합니다. 특히 범위가 뚜렷한 이유 없이 순서대로 요청되지 않는 경우에는 더욱 그렇습니다. 다중 부분 범위 요청은 임의 액세스를 지원하도록 설계되지 않았습니다.

---
### **17.16.  Authentication Considerations**

HTTP 인증 주제에 관한 모든 사항은 보안 고려 사항이므로 아래 고려 사항 목록은 완전하지 않습니다. 또한 특정 인증 체계\(해당 체계를 정의하는 사양에 문서화되어야 함\)에 대한 모든 잠재적 고려 사항을 논의하기보다는 일반적으로 인증 프레임워크와 관련된 보안 고려 사항으로 제한됩니다. 다양한 조직에서는 실제로 발견되는 인증 체계를 구현하고 사용하는 데 있어 일반적인 함정을 포함하여 웹 애플리케이션 보안\(예: \[OWASP\]\)에 대한 현재 연구에 대한 주제 정보와 링크를 유지합니다.

---
#### **17.16.1.  Confidentiality of Credentials**

HTTP 인증 프레임워크는 자격 증명의 기밀성을 유지하기 위한 단일 메커니즘을 정의하지 않습니다. 대신 각 인증 체계는 전송 전에 자격 증명을 인코딩하는 방법을 정의합니다. 이는 향후 인증 체계 개발에 유연성을 제공하지만 자체적으로 기밀성을 제공하지 않거나 재생 공격으로부터 충분히 보호하지 못하는 기존 체계를 보호하기에는 부적절합니다. 또한 서버가 각 개별 사용자에게 특정한 자격 증명을 기대하는 경우 해당 자격 증명을 교환하면 자격 증명 내의 콘텐츠가 기밀로 유지되더라도 해당 사용자를 식별하는 효과가 있습니다.

HTTP는 기본 전송 또는 세션 수준 연결의 보안 속성에 따라 필드의 기밀 전송을 제공합니다. 개별 사용자 인증에 의존하는 서비스에는 자격 증명을 교환하기 전에 보안 연결이 필요합니다\(섹션 4.2.2\).

---
#### **17.16.2.  Credentials and Idle Clients**

기존 HTTP 클라이언트와 사용자 에이전트는 일반적으로 인증 정보를 무기한 유지합니다. HTTP는 원본 서버가 클라이언트에게 캐시된 자격 증명을 삭제하도록 지시하는 메커니즘을 제공하지 않습니다. 프로토콜은 사용자 에이전트가 자격 증명을 획득하거나 관리하는 방법을 인식하지 못하기 때문입니다. 자격 증명을 만료하거나 취소하는 메커니즘은 인증 체계 정의의 일부로 지정할 수 있습니다.

자격 증명 캐싱이 애플리케이션의 보안 모델을 방해할 수 있는 상황은 다음을 포함하지만 이에 국한되지는 않습니다.

\* 오랜 기간 동안 유휴 상태였던 클라이언트. 이후 서버는 클라이언트가 사용자에게 자격 증명을 다시 묻는 메시지를 표시하도록 할 수 있습니다.

\* 세션 종료 표시\(예: 페이지의 "로그아웃" 또는 "커밋" 버튼\)를 포함하는 응용 프로그램은 클라이언트가 자격 증명을 유지할 더 이상 이유가 없다는 것을 응용 프로그램의 서버 측에서 "인식"합니다.

자격 증명을 캐시하는 사용자 에이전트는 사용자 제어 하에 캐시된 자격 증명을 삭제하기 위해 쉽게 액세스할 수 있는 메커니즘을 제공하는 것이 좋습니다.

---
#### **17.16.3.  Protection Spaces**

보호 공간을 설정하기 위해 "영역" 메커니즘에만 의존하는 인증 체계는 원본 서버의 모든 리소스에 자격 증명을 노출합니다. 리소스에 대한 인증 요청을 성공적으로 수행한 클라이언트는 동일한 원본 서버의 다른 리소스에 대해 동일한 인증 자격 증명을 사용할 수 있습니다. 이를 통해 다른 리소스가 다른 리소스에 대한 인증 자격 증명을 수집할 수 있습니다.

이는 원본 서버가 동일한 원본 아래에 있는 여러 당사자에 대한 리소스를 호스팅할 때 특히 중요합니다\(11.5절\). 가능한 완화 전략에는 인증 자격 증명에 대한 직접 액세스를 제한하는 것\(즉, 인증 요청 헤더 필드의 내용을 사용 가능하게 하지 않음\), 각 당사자에 대해 서로 다른 호스트 이름\(또는 포트 번호\)을 사용하여 보호 공간을 분리하는 것이 포함됩니다.

---
#### **17.16.4.  Additional Response Fields**

암호화되지 않은 채널을 통해 전송되는 응답에 정보를 추가하면 보안 및 개인 정보 보호에 영향을 미칠 수 있습니다. Authentication-Info 및 Proxy-Authentication-Info 헤더 필드만 있으면 HTTP 인증이 사용 중임을 나타냅니다. 인증 체계별 매개변수의 내용으로 추가 정보가 노출될 수 있습니다. 이는 이러한 계획의 정의에서 고려되어야 합니다.

---
## **18.  IANA Considerations**

다음 등록에 대한 변경 컨트롤러는 "IETF\(iesg@ietf.org\) - Internet Engineering Task Force"입니다.

---
### **18.1.  URI Scheme Registration**

IANA는 섹션 4.2의 표 2에 나열된 영구 체계를 사용하여 <https://www.iana.org/locationments/uri-schemes/\>에서 "URI\(Uniform Resource Identifier\) ​​체계" 레지스트리\[BCP35\]를 업데이트했습니다.

---
### **18.2.  Method Registration**

IANA는 섹션 16.1.1의 등록 절차와 다음 표에 요약된 메서드 이름을 사용하여 <https://www.iana.org/locationments/http-methods\>에서 "HTTP\(Hypertext Transfer Protocol\) 메서드 레지스트리"를 업데이트했습니다. .

```text
                 +=========+======+============+=========+
                 | Method  | Safe | Idempotent | Section |
                 +=========+======+============+=========+
                 | CONNECT | no   | no         | 9.3.6   |
                 +---------+------+------------+---------+
                 | DELETE  | no   | yes        | 9.3.5   |
                 +---------+------+------------+---------+
                 | GET     | yes  | yes        | 9.3.1   |
                 +---------+------+------------+---------+
                 | HEAD    | yes  | yes        | 9.3.2   |
                 +---------+------+------------+---------+
                 | OPTIONS | yes  | yes        | 9.3.7   |
                 +---------+------+------------+---------+
                 | POST    | no   | no         | 9.3.3   |
                 +---------+------+------------+---------+
                 | PUT     | no   | yes        | 9.3.4   |
                 +---------+------+------------+---------+
                 | TRACE   | yes  | yes        | 9.3.8   |
                 +---------+------+------------+---------+
                 | *       | no   | no         | 18.2    |
                 +---------+------+------------+---------+

                                  Table 7
```

메소드 이름 "\*"은 메소드 이름으로 "\*"를 사용하는 것이 일부 필드\(예: "Access-Control-Request-Method"\)에서 와일드카드로 사용하는 것과 충돌하기 때문에 예약되어 있습니다.

---
### **18.3.  Status Code Registration**

IANA는 섹션 16.2.1의 등록 절차와 요약된 상태 코드 값을 사용하여 <https://www.iana.org/locationments/http-status-codes\>에서 "HTTP\(Hypertext Transfer Protocol\) 상태 코드 레지스트리"를 업데이트했습니다. 다음 표에서.

```text
            +=======+===============================+=========+
            | Value | Description                   | Section |
            +=======+===============================+=========+
            | 100   | Continue                      | 15.2.1  |
            +-------+-------------------------------+---------+
            | 101   | Switching Protocols           | 15.2.2  |
            +-------+-------------------------------+---------+
            | 200   | OK                            | 15.3.1  |
            +-------+-------------------------------+---------+
            | 201   | Created                       | 15.3.2  |
            +-------+-------------------------------+---------+
            | 202   | Accepted                      | 15.3.3  |
            +-------+-------------------------------+---------+
            | 203   | Non-Authoritative Information | 15.3.4  |
            +-------+-------------------------------+---------+
            | 204   | No Content                    | 15.3.5  |
            +-------+-------------------------------+---------+
            | 205   | Reset Content                 | 15.3.6  |
            +-------+-------------------------------+---------+
            | 206   | Partial Content               | 15.3.7  |
            +-------+-------------------------------+---------+
            | 300   | Multiple Choices              | 15.4.1  |
            +-------+-------------------------------+---------+
            | 301   | Moved Permanently             | 15.4.2  |
            +-------+-------------------------------+---------+
            | 302   | Found                         | 15.4.3  |
            +-------+-------------------------------+---------+
            | 303   | See Other                     | 15.4.4  |
            +-------+-------------------------------+---------+
            | 304   | Not Modified                  | 15.4.5  |
            +-------+-------------------------------+---------+
            | 305   | Use Proxy                     | 15.4.6  |
            +-------+-------------------------------+---------+
            | 306   | (Unused)                      | 15.4.7  |
            +-------+-------------------------------+---------+
            | 307   | Temporary Redirect            | 15.4.8  |
            +-------+-------------------------------+---------+
            | 308   | Permanent Redirect            | 15.4.9  |
            +-------+-------------------------------+---------+
            | 400   | Bad Request                   | 15.5.1  |
            +-------+-------------------------------+---------+
            | 401   | Unauthorized                  | 15.5.2  |
            +-------+-------------------------------+---------+
            | 402   | Payment Required              | 15.5.3  |
            +-------+-------------------------------+---------+
            | 403   | Forbidden                     | 15.5.4  |
            +-------+-------------------------------+---------+
            | 404   | Not Found                     | 15.5.5  |
            +-------+-------------------------------+---------+
            | 405   | Method Not Allowed            | 15.5.6  |
            +-------+-------------------------------+---------+
            | 406   | Not Acceptable                | 15.5.7  |
            +-------+-------------------------------+---------+
            | 407   | Proxy Authentication Required | 15.5.8  |
            +-------+-------------------------------+---------+
            | 408   | Request Timeout               | 15.5.9  |
            +-------+-------------------------------+---------+
            | 409   | Conflict                      | 15.5.10 |
            +-------+-------------------------------+---------+
            | 410   | Gone                          | 15.5.11 |
            +-------+-------------------------------+---------+
            | 411   | Length Required               | 15.5.12 |
            +-------+-------------------------------+---------+
            | 412   | Precondition Failed           | 15.5.13 |
            +-------+-------------------------------+---------+
            | 413   | Content Too Large             | 15.5.14 |
            +-------+-------------------------------+---------+
            | 414   | URI Too Long                  | 15.5.15 |
            +-------+-------------------------------+---------+
            | 415   | Unsupported Media Type        | 15.5.16 |
            +-------+-------------------------------+---------+
            | 416   | Range Not Satisfiable         | 15.5.17 |
            +-------+-------------------------------+---------+
            | 417   | Expectation Failed            | 15.5.18 |
            +-------+-------------------------------+---------+
            | 418   | (Unused)                      | 15.5.19 |
            +-------+-------------------------------+---------+
            | 421   | Misdirected Request           | 15.5.20 |
            +-------+-------------------------------+---------+
            | 422   | Unprocessable Content         | 15.5.21 |
            +-------+-------------------------------+---------+
            | 426   | Upgrade Required              | 15.5.22 |
            +-------+-------------------------------+---------+
            | 500   | Internal Server Error         | 15.6.1  |
            +-------+-------------------------------+---------+
            | 501   | Not Implemented               | 15.6.2  |
            +-------+-------------------------------+---------+
            | 502   | Bad Gateway                   | 15.6.3  |
            +-------+-------------------------------+---------+
            | 503   | Service Unavailable           | 15.6.4  |
            +-------+-------------------------------+---------+
            | 504   | Gateway Timeout               | 15.6.5  |
            +-------+-------------------------------+---------+
            | 505   | HTTP Version Not Supported    | 15.6.6  |
            +-------+-------------------------------+---------+

                                  Table 8
```

---
### **18.4.  Field Name Registration**

이 사양은 \[RFC3864\]에 정의된 메시지 헤더 필드에 대한 기존 등록 절차의 HTTP 관련 측면을 업데이트합니다. 이는 새로운 등록 절차를 정의하고 HTTP 필드 정의를 별도의 레지스트리로 이동하여 HTTP와 관련된 이전 절차를 대체합니다.

IANA는 섹션 16.3.1에 설명된 대로 "HTTP\(Hypertext Transfer Protocol\) 필드 이름 레지스트리"라는 제목의 새 레지스트리를 만들었습니다.

IANA는 "영구 메시지 헤더 필드 이름" 및 "임시 메시지 헤더 필드 이름" 레지스트리\(<https://www.iana.org/locationments/message-headers/\> 참조\)의 모든 항목을 'http' 프로토콜로 이동했습니다. 이 레지스트리에 다음 변경 사항을 적용했습니다.

1. '적용 가능한 프로토콜' 항목이 생략되었습니다.

1. '표준', '실험', '보존', '정보' 상태였던 출품작은 '영구' 상태로 변경되었습니다.

1. 상태가 없는 잠정 입국이 '잠정' 상태로 처리되었습니다.

1. 상태가 없는 영구 입국\(등록 문서에 상태가 정의되지 않았음을 확인한 후\)은 '임시' 상태로 처리되었습니다. 전문가는 다른 항목이 더 적절하다는 증거가 있는 경우 항목의 상태를 업데이트하도록 선택할 수 있습니다.

IANA는 HTTP 필드 이름 등록이 이동되었음을 나타내기 위해 "영구 메시지 헤더 필드 이름" 및 "임시 메시지 헤더 필드 이름" 레지스트리에 다음 메모를 추가했습니다.

- | \*참고\* | | HTTP 필드 이름 등록이 | \[RFC9110\]에 따른 \[https://www.iana.org/locationments/http-fields\].

IANA는 다음 표에 나열된 필드 이름으로 "HTTP\(Hypertext Transfer Protocol\) 필드 이름 레지스트리"를 업데이트했습니다.

```text
   +===========================+============+=========+============+
   | Field Name                | Status     | Section | Comments   |
   +===========================+============+=========+============+
   | Accept                    | permanent  | 12.5.1  |            |
   +---------------------------+------------+---------+------------+
   | Accept-Charset            | deprecated | 12.5.2  |            |
   +---------------------------+------------+---------+------------+
   | Accept-Encoding           | permanent  | 12.5.3  |            |
   +---------------------------+------------+---------+------------+
   | Accept-Language           | permanent  | 12.5.4  |            |
   +---------------------------+------------+---------+------------+
   | Accept-Ranges             | permanent  | 14.3    |            |
   +---------------------------+------------+---------+------------+
   | Allow                     | permanent  | 10.2.1  |            |
   +---------------------------+------------+---------+------------+
   | Authentication-Info       | permanent  | 11.6.3  |            |
   +---------------------------+------------+---------+------------+
   | Authorization             | permanent  | 11.6.2  |            |
   +---------------------------+------------+---------+------------+
   | Connection                | permanent  | 7.6.1   |            |
   +---------------------------+------------+---------+------------+
   | Content-Encoding          | permanent  | 8.4     |            |
   +---------------------------+------------+---------+------------+
   | Content-Language          | permanent  | 8.5     |            |
   +---------------------------+------------+---------+------------+
   | Content-Length            | permanent  | 8.6     |            |
   +---------------------------+------------+---------+------------+
   | Content-Location          | permanent  | 8.7     |            |
   +---------------------------+------------+---------+------------+
   | Content-Range             | permanent  | 14.4    |            |
   +---------------------------+------------+---------+------------+
   | Content-Type              | permanent  | 8.3     |            |
   +---------------------------+------------+---------+------------+
   | Date                      | permanent  | 6.6.1   |            |
   +---------------------------+------------+---------+------------+
   | ETag                      | permanent  | 8.8.3   |            |
   +---------------------------+------------+---------+------------+
   | Expect                    | permanent  | 10.1.1  |            |
   +---------------------------+------------+---------+------------+
   | From                      | permanent  | 10.1.2  |            |
   +---------------------------+------------+---------+------------+
   | Host                      | permanent  | 7.2     |            |
   +---------------------------+------------+---------+------------+
   | If-Match                  | permanent  | 13.1.1  |            |
   +---------------------------+------------+---------+------------+
   | If-Modified-Since         | permanent  | 13.1.3  |            |
   +---------------------------+------------+---------+------------+
   | If-None-Match             | permanent  | 13.1.2  |            |
   +---------------------------+------------+---------+------------+
   | If-Range                  | permanent  | 13.1.5  |            |
   +---------------------------+------------+---------+------------+
   | If-Unmodified-Since       | permanent  | 13.1.4  |            |
   +---------------------------+------------+---------+------------+
   | Last-Modified             | permanent  | 8.8.2   |            |
   +---------------------------+------------+---------+------------+
   | Location                  | permanent  | 10.2.2  |            |
   +---------------------------+------------+---------+------------+
   | Max-Forwards              | permanent  | 7.6.2   |            |
   +---------------------------+------------+---------+------------+
   | Proxy-Authenticate        | permanent  | 11.7.1  |            |
   +---------------------------+------------+---------+------------+
   | Proxy-Authentication-Info | permanent  | 11.7.3  |            |
   +---------------------------+------------+---------+------------+
   | Proxy-Authorization       | permanent  | 11.7.2  |            |
   +---------------------------+------------+---------+------------+
   | Range                     | permanent  | 14.2    |            |
   +---------------------------+------------+---------+------------+
   | Referer                   | permanent  | 10.1.3  |            |
   +---------------------------+------------+---------+------------+
   | Retry-After               | permanent  | 10.2.3  |            |
   +---------------------------+------------+---------+------------+
   | Server                    | permanent  | 10.2.4  |            |
   +---------------------------+------------+---------+------------+
   | TE                        | permanent  | 10.1.4  |            |
   +---------------------------+------------+---------+------------+
   | Trailer                   | permanent  | 6.6.2   |            |
   +---------------------------+------------+---------+------------+
   | Upgrade                   | permanent  | 7.8     |            |
   +---------------------------+------------+---------+------------+
   | User-Agent                | permanent  | 10.1.5  |            |
   +---------------------------+------------+---------+------------+
   | Vary                      | permanent  | 12.5.5  |            |
   +---------------------------+------------+---------+------------+
   | Via                       | permanent  | 7.6.3   |            |
   +---------------------------+------------+---------+------------+
   | WWW-Authenticate          | permanent  | 11.6.1  |            |
   +---------------------------+------------+---------+------------+
   | *                         | permanent  | 12.5.5  | (reserved) |
   +---------------------------+------------+---------+------------+

                                Table 9
```

필드 이름 "\*"는 해당 이름을 HTTP 헤더 필드로 사용하면 Vary 헤더 필드\(섹션 12.5.5\)의 특수 의미와 충돌할 수 있으므로 예약되어 있습니다.

IANA는 \[RFC2616\]의 섹션 14.15\(헤더 필드 정의용\) 및 \[RFC7231\]의 부록 B\(제거됨\)를 참조하여 새 레지스트리의 "Content-MD5" 항목을 '구식' 상태로 업데이트했습니다. 업데이트된 사양의 필드 정의\).

---
### **18.5.  Authentication Scheme Registration**

IANA는 섹션 16.4.1의 등록 절차를 사용하여 <https://www.iana.org/locationments/http-authschemes\>에서 "HTTP\(Hypertext Transfer Protocol\) 인증 체계 레지스트리"를 업데이트했습니다. 이 문서에는 인증 체계가 정의되어 있지 않습니다.

---
### **18.6.  Content Coding Registration**

IANA는 섹션 16.6.1의 등록 절차와 아래 표에 요약된 콘텐츠 코딩 이름을 사용하여 <https://www.iana.org/locationments/http-parameters/\>에서 "HTTP 콘텐츠 코딩 레지스트리"를 업데이트했습니다.

```text
   +============+===========================================+=========+
   | Name       | Description                               | Section |
   +============+===========================================+=========+
   | compress   | UNIX "compress" data format [Welch]       | 8.4.1.1 |
   +------------+-------------------------------------------+---------+
   | deflate    | "deflate" compressed data ([RFC1951])     | 8.4.1.2 |
   |            | inside the "zlib" data format ([RFC1950]) |         |
   +------------+-------------------------------------------+---------+
   | gzip       | GZIP file format [RFC1952]                | 8.4.1.3 |
   +------------+-------------------------------------------+---------+
   | identity   | Reserved                                  | 12.5.3  |
   +------------+-------------------------------------------+---------+
   | x-compress | Deprecated (alias for compress)           | 8.4.1.1 |
   +------------+-------------------------------------------+---------+
   | x-gzip     | Deprecated (alias for gzip)               | 8.4.1.3 |
   +------------+-------------------------------------------+---------+

                                 Table 10
```

---
### **18.7.  Range Unit Registration**

IANA는 섹션 16.5.1의 등록 절차와 아래 표에 요약된 범위 단위 이름을 사용하여 <https://www.iana.org/locationments/http-parameters/\>의 "HTTP 범위 단위 레지스트리"를 업데이트했습니다.

```text
   +=================+==================================+=========+
   | Range Unit Name | Description                      | Section |
   +=================+==================================+=========+
   | bytes           | a range of octets                | 14.1.2  |
   +-----------------+----------------------------------+---------+
   | none            | reserved as keyword to indicate  | 14.3    |
   |                 | range requests are not supported |         |
   +-----------------+----------------------------------+---------+

                               Table 11
```

---
### **18.8.  Media Type Registration**

IANA는 미디어 유형 "multipart/byteranges"에 대한 섹션 14.6의 등록 정보로 <https://www.iana.org/locationments/media-types\>의 "미디어 유형" 레지스트리를 업데이트했습니다.

IANA는 이 문서의 섹션 12.5.1에 ​​대한 링크를 포함하여 "q" 매개변수에 대한 레지스트리 참고 사항을 업데이트했습니다.

---
### **18.9.  Port Registration**

IANA는 UDP 또는 TCP를 사용하는 포트 80 및 443의 서비스에 대해 <https://www.iana.org/locationments/service-names-port-number/\>에서 "서비스 이름 및 전송 프로토콜 포트 번호 레지스트리"를 업데이트했습니다. 에게:

1. 본 문서를 "참고자료"로 활용하고,

1. 현재 지정되지 않은 경우 "Assignee"를 "IESG"로 설정하고 "Contact"를 "IETF\_Chair"로 설정합니다.

---
### **18.10.  Upgrade Token Registration**

IANA는 섹션 16.7에 설명된 등록 절차와 요약된 업그레이드 토큰 이름을 사용하여 <https://www.iana.org/locationments/http-upgrade-tokens\>에서 "HTTP\(Hypertext Transfer Protocol\) 업그레이드 토큰 레지스트리"를 업데이트했습니다. 다음 표.

```text
   +======+===================+=========================+=========+
   | Name | Description       | Expected Version Tokens | Section |
   +======+===================+=========================+=========+
   | HTTP | Hypertext         | any DIGIT.DIGIT (e.g.,  | 2.5     |
   |      | Transfer Protocol | "2.0")                  |         |
   +------+-------------------+-------------------------+---------+

                               Table 12
```

---
## **19.  References**
---
### **19.1.  Normative References**

```text
   [CACHING]  Fielding, R., Ed., Nottingham, M., Ed., and J. Reschke,
              Ed., "HTTP Caching", STD 98, RFC 9111,
              DOI 10.17487/RFC9111, June 2022,
              <https://www.rfc-editor.org/info/rfc9111>.

   [RFC1950]  Deutsch, P. and J-L. Gailly, "ZLIB Compressed Data Format
              Specification version 3.3", RFC 1950,
              DOI 10.17487/RFC1950, May 1996,
              <https://www.rfc-editor.org/info/rfc1950>.

   [RFC1951]  Deutsch, P., "DEFLATE Compressed Data Format Specification
              version 1.3", RFC 1951, DOI 10.17487/RFC1951, May 1996,
              <https://www.rfc-editor.org/info/rfc1951>.

   [RFC1952]  Deutsch, P., "GZIP file format specification version 4.3",
              RFC 1952, DOI 10.17487/RFC1952, May 1996,
              <https://www.rfc-editor.org/info/rfc1952>.

   [RFC2046]  Freed, N. and N. Borenstein, "Multipurpose Internet Mail
              Extensions (MIME) Part Two: Media Types", RFC 2046,
              DOI 10.17487/RFC2046, November 1996,
              <https://www.rfc-editor.org/info/rfc2046>.

   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", BCP 14, RFC 2119,
              DOI 10.17487/RFC2119, March 1997,
              <https://www.rfc-editor.org/info/rfc2119>.

   [RFC4647]  Phillips, A., Ed. and M. Davis, Ed., "Matching of Language
              Tags", BCP 47, RFC 4647, DOI 10.17487/RFC4647, September
              2006, <https://www.rfc-editor.org/info/rfc4647>.

   [RFC4648]  Josefsson, S., "The Base16, Base32, and Base64 Data
              Encodings", RFC 4648, DOI 10.17487/RFC4648, October 2006,
              <https://www.rfc-editor.org/info/rfc4648>.

   [RFC5234]  Crocker, D., Ed. and P. Overell, "Augmented BNF for Syntax
              Specifications: ABNF", STD 68, RFC 5234,
              DOI 10.17487/RFC5234, January 2008,
              <https://www.rfc-editor.org/info/rfc5234>.

   [RFC5280]  Cooper, D., Santesson, S., Farrell, S., Boeyen, S.,
              Housley, R., and W. Polk, "Internet X.509 Public Key
              Infrastructure Certificate and Certificate Revocation List
              (CRL) Profile", RFC 5280, DOI 10.17487/RFC5280, May 2008,
              <https://www.rfc-editor.org/info/rfc5280>.

   [RFC5322]  Resnick, P., Ed., "Internet Message Format", RFC 5322,
              DOI 10.17487/RFC5322, October 2008,
              <https://www.rfc-editor.org/info/rfc5322>.

   [RFC5646]  Phillips, A., Ed. and M. Davis, Ed., "Tags for Identifying
              Languages", BCP 47, RFC 5646, DOI 10.17487/RFC5646,
              September 2009, <https://www.rfc-editor.org/info/rfc5646>.

   [RFC6125]  Saint-Andre, P. and J. Hodges, "Representation and
              Verification of Domain-Based Application Service Identity
              within Internet Public Key Infrastructure Using X.509
              (PKIX) Certificates in the Context of Transport Layer
              Security (TLS)", RFC 6125, DOI 10.17487/RFC6125, March
              2011, <https://www.rfc-editor.org/info/rfc6125>.

   [RFC6365]  Hoffman, P. and J. Klensin, "Terminology Used in
              Internationalization in the IETF", BCP 166, RFC 6365,
              DOI 10.17487/RFC6365, September 2011,
              <https://www.rfc-editor.org/info/rfc6365>.

   [RFC7405]  Kyzivat, P., "Case-Sensitive String Support in ABNF",
              RFC 7405, DOI 10.17487/RFC7405, December 2014,
              <https://www.rfc-editor.org/info/rfc7405>.

   [RFC8174]  Leiba, B., "Ambiguity of Uppercase vs Lowercase in RFC
              2119 Key Words", BCP 14, RFC 8174, DOI 10.17487/RFC8174,
              May 2017, <https://www.rfc-editor.org/info/rfc8174>.

   [TCP]      Postel, J., "Transmission Control Protocol", STD 7,
              RFC 793, DOI 10.17487/RFC0793, September 1981,
              <https://www.rfc-editor.org/info/rfc793>.

   [TLS13]    Rescorla, E., "The Transport Layer Security (TLS) Protocol
              Version 1.3", RFC 8446, DOI 10.17487/RFC8446, August 2018,
              <https://www.rfc-editor.org/info/rfc8446>.

   [URI]      Berners-Lee, T., Fielding, R., and L. Masinter, "Uniform
              Resource Identifier (URI): Generic Syntax", STD 66,
              RFC 3986, DOI 10.17487/RFC3986, January 2005,
              <https://www.rfc-editor.org/info/rfc3986>.

   [USASCII]  American National Standards Institute, "Coded Character
              Set -- 7-bit American Standard Code for Information
              Interchange", ANSI X3.4, 1986.

   [Welch]    Welch, T., "A Technique for High-Performance Data
              Compression", IEEE Computer 17(6),
              DOI 10.1109/MC.1984.1659158, June 1984,
              <https://ieeexplore.ieee.org/document/1659158/>.
```

---
### **19.2.  Informative References**

```text
   [ALTSVC]   Nottingham, M., McManus, P., and J. Reschke, "HTTP
              Alternative Services", RFC 7838, DOI 10.17487/RFC7838,
              April 2016, <https://www.rfc-editor.org/info/rfc7838>.

   [BCP13]    Freed, N. and J. Klensin, "Multipurpose Internet Mail
              Extensions (MIME) Part Four: Registration Procedures",
              BCP 13, RFC 4289, December 2005.

              Freed, N., Klensin, J., and T. Hansen, "Media Type
              Specifications and Registration Procedures", BCP 13,
              RFC 6838, January 2013.

              <https://www.rfc-editor.org/info/bcp13>

   [BCP178]   Saint-Andre, P., Crocker, D., and M. Nottingham,
              "Deprecating the "X-" Prefix and Similar Constructs in
              Application Protocols", BCP 178, RFC 6648, June 2012.

              <https://www.rfc-editor.org/info/bcp178>

   [BCP35]    Thaler, D., Ed., Hansen, T., and T. Hardie, "Guidelines
              and Registration Procedures for URI Schemes", BCP 35,
              RFC 7595, June 2015.

              <https://www.rfc-editor.org/info/bcp35>

   [BREACH]   Gluck, Y., Harris, N., and A. Prado, "BREACH: Reviving the
              CRIME Attack", July 2013,
              <http://breachattack.com/resources/
              BREACH%20-%20SSL,%20gone%20in%2030%20seconds.pdf>.

   [Bujlow]   Bujlow, T., Carela-Español, V., Solé-Pareta, J., and P.
              Barlet-Ros, "A Survey on Web Tracking: Mechanisms,
              Implications, and Defenses", In Proceedings of the IEEE
              105(8), DOI 10.1109/JPROC.2016.2637878, August 2017,
              <https://doi.org/10.1109/JPROC.2016.2637878>.

   [COOKIE]   Barth, A., "HTTP State Management Mechanism", RFC 6265,
              DOI 10.17487/RFC6265, April 2011,
              <https://www.rfc-editor.org/info/rfc6265>.

   [Err1912]  RFC Errata, Erratum ID 1912, RFC 2978,
              <https://www.rfc-editor.org/errata/eid1912>.

   [Err5433]  RFC Errata, Erratum ID 5433, RFC 2978,
              <https://www.rfc-editor.org/errata/eid5433>.

   [Georgiev] Georgiev, M., Iyengar, S., Jana, S., Anubhai, R., Boneh,
              D., and V. Shmatikov, "The Most Dangerous Code in the
              World: Validating SSL Certificates in Non-Browser
              Software", In Proceedings of the 2012 ACM Conference on
              Computer and Communications Security (CCS '12), pp. 38-49,
              DOI 10.1145/2382196.2382204, October 2012,
              <https://doi.org/10.1145/2382196.2382204>.

   [HPACK]    Peon, R. and H. Ruellan, "HPACK: Header Compression for
              HTTP/2", RFC 7541, DOI 10.17487/RFC7541, May 2015,
              <https://www.rfc-editor.org/info/rfc7541>.

   [HTTP/1.0] Berners-Lee, T., Fielding, R., and H. Frystyk, "Hypertext
              Transfer Protocol -- HTTP/1.0", RFC 1945,
              DOI 10.17487/RFC1945, May 1996,
              <https://www.rfc-editor.org/info/rfc1945>.

   [HTTP/1.1] Fielding, R., Ed., Nottingham, M., Ed., and J. Reschke,
              Ed., "HTTP/1.1", STD 99, RFC 9112, DOI 10.17487/RFC9112,
              June 2022, <https://www.rfc-editor.org/info/rfc9112>.

   [HTTP/2]   Thomson, M., Ed. and C. Benfield, Ed., "HTTP/2", RFC 9113,
              DOI 10.17487/RFC9113, June 2022,
              <https://www.rfc-editor.org/info/rfc9113>.

   [HTTP/3]   Bishop, M., Ed., "HTTP/3", RFC 9114, DOI 10.17487/RFC9114,
              June 2022, <https://www.rfc-editor.org/info/rfc9114>.

   [ISO-8859-1]
              International Organization for Standardization,
              "Information technology -- 8-bit single-byte coded graphic
              character sets -- Part 1: Latin alphabet No. 1", ISO/
              IEC 8859-1:1998, 1998.

   [Kri2001]  Kristol, D., "HTTP Cookies: Standards, Privacy, and
              Politics", ACM Transactions on Internet Technology 1(2),
              November 2001, <http://arxiv.org/abs/cs.SE/0105018>.

   [OWASP]    The Open Web Application Security Project,
              <https://www.owasp.org/>.

   [REST]     Fielding, R.T., "Architectural Styles and the Design of
              Network-based Software Architectures", Doctoral
              Dissertation, University of California, Irvine, September
              2000, <https://roy.gbiv.com/pubs/dissertation/top.htm>.

   [RFC1919]  Chatel, M., "Classical versus Transparent IP Proxies",
              RFC 1919, DOI 10.17487/RFC1919, March 1996,
              <https://www.rfc-editor.org/info/rfc1919>.

   [RFC2047]  Moore, K., "MIME (Multipurpose Internet Mail Extensions)
              Part Three: Message Header Extensions for Non-ASCII Text",
              RFC 2047, DOI 10.17487/RFC2047, November 1996,
              <https://www.rfc-editor.org/info/rfc2047>.

   [RFC2068]  Fielding, R., Gettys, J., Mogul, J., Frystyk, H., and T.
              Berners-Lee, "Hypertext Transfer Protocol -- HTTP/1.1",
              RFC 2068, DOI 10.17487/RFC2068, January 1997,
              <https://www.rfc-editor.org/info/rfc2068>.

   [RFC2145]  Mogul, J. C., Fielding, R., Gettys, J., and H. Frystyk,
              "Use and Interpretation of HTTP Version Numbers",
              RFC 2145, DOI 10.17487/RFC2145, May 1997,
              <https://www.rfc-editor.org/info/rfc2145>.

   [RFC2295]  Holtman, K. and A. Mutz, "Transparent Content Negotiation
              in HTTP", RFC 2295, DOI 10.17487/RFC2295, March 1998,
              <https://www.rfc-editor.org/info/rfc2295>.

   [RFC2324]  Masinter, L., "Hyper Text Coffee Pot Control Protocol
              (HTCPCP/1.0)", RFC 2324, DOI 10.17487/RFC2324, 1 April
              1998, <https://www.rfc-editor.org/info/rfc2324>.

   [RFC2557]  Palme, J., Hopmann, A., and N. Shelness, "MIME
              Encapsulation of Aggregate Documents, such as HTML
              (MHTML)", RFC 2557, DOI 10.17487/RFC2557, March 1999,
              <https://www.rfc-editor.org/info/rfc2557>.

   [RFC2616]  Fielding, R., Gettys, J., Mogul, J., Frystyk, H.,
              Masinter, L., Leach, P., and T. Berners-Lee, "Hypertext
              Transfer Protocol -- HTTP/1.1", RFC 2616,
              DOI 10.17487/RFC2616, June 1999,
              <https://www.rfc-editor.org/info/rfc2616>.

   [RFC2617]  Franks, J., Hallam-Baker, P., Hostetler, J., Lawrence, S.,
              Leach, P., Luotonen, A., and L. Stewart, "HTTP
              Authentication: Basic and Digest Access Authentication",
              RFC 2617, DOI 10.17487/RFC2617, June 1999,
              <https://www.rfc-editor.org/info/rfc2617>.

   [RFC2774]  Nielsen, H., Leach, P., and S. Lawrence, "An HTTP
              Extension Framework", RFC 2774, DOI 10.17487/RFC2774,
              February 2000, <https://www.rfc-editor.org/info/rfc2774>.

   [RFC2818]  Rescorla, E., "HTTP Over TLS", RFC 2818,
              DOI 10.17487/RFC2818, May 2000,
              <https://www.rfc-editor.org/info/rfc2818>.

   [RFC2978]  Freed, N. and J. Postel, "IANA Charset Registration
              Procedures", BCP 19, RFC 2978, DOI 10.17487/RFC2978,
              October 2000, <https://www.rfc-editor.org/info/rfc2978>.

   [RFC3040]  Cooper, I., Melve, I., and G. Tomlinson, "Internet Web
              Replication and Caching Taxonomy", RFC 3040,
              DOI 10.17487/RFC3040, January 2001,
              <https://www.rfc-editor.org/info/rfc3040>.

   [RFC3864]  Klyne, G., Nottingham, M., and J. Mogul, "Registration
              Procedures for Message Header Fields", BCP 90, RFC 3864,
              DOI 10.17487/RFC3864, September 2004,
              <https://www.rfc-editor.org/info/rfc3864>.

   [RFC3875]  Robinson, D. and K. Coar, "The Common Gateway Interface
              (CGI) Version 1.1", RFC 3875, DOI 10.17487/RFC3875,
              October 2004, <https://www.rfc-editor.org/info/rfc3875>.

   [RFC4033]  Arends, R., Austein, R., Larson, M., Massey, D., and S.
              Rose, "DNS Security Introduction and Requirements",
              RFC 4033, DOI 10.17487/RFC4033, March 2005,
              <https://www.rfc-editor.org/info/rfc4033>.

   [RFC4559]  Jaganathan, K., Zhu, L., and J. Brezak, "SPNEGO-based
              Kerberos and NTLM HTTP Authentication in Microsoft
              Windows", RFC 4559, DOI 10.17487/RFC4559, June 2006,
              <https://www.rfc-editor.org/info/rfc4559>.

   [RFC5789]  Dusseault, L. and J. Snell, "PATCH Method for HTTP",
              RFC 5789, DOI 10.17487/RFC5789, March 2010,
              <https://www.rfc-editor.org/info/rfc5789>.

   [RFC5905]  Mills, D., Martin, J., Ed., Burbank, J., and W. Kasch,
              "Network Time Protocol Version 4: Protocol and Algorithms
              Specification", RFC 5905, DOI 10.17487/RFC5905, June 2010,
              <https://www.rfc-editor.org/info/rfc5905>.

   [RFC6454]  Barth, A., "The Web Origin Concept", RFC 6454,
              DOI 10.17487/RFC6454, December 2011,
              <https://www.rfc-editor.org/info/rfc6454>.

   [RFC6585]  Nottingham, M. and R. Fielding, "Additional HTTP Status
              Codes", RFC 6585, DOI 10.17487/RFC6585, April 2012,
              <https://www.rfc-editor.org/info/rfc6585>.

   [RFC7230]  Fielding, R., Ed. and J. Reschke, Ed., "Hypertext Transfer
              Protocol (HTTP/1.1): Message Syntax and Routing",
              RFC 7230, DOI 10.17487/RFC7230, June 2014,
              <https://www.rfc-editor.org/info/rfc7230>.

   [RFC7231]  Fielding, R., Ed. and J. Reschke, Ed., "Hypertext Transfer
              Protocol (HTTP/1.1): Semantics and Content", RFC 7231,
              DOI 10.17487/RFC7231, June 2014,
              <https://www.rfc-editor.org/info/rfc7231>.

   [RFC7232]  Fielding, R., Ed. and J. Reschke, Ed., "Hypertext Transfer
              Protocol (HTTP/1.1): Conditional Requests", RFC 7232,
              DOI 10.17487/RFC7232, June 2014,
              <https://www.rfc-editor.org/info/rfc7232>.

   [RFC7233]  Fielding, R., Ed., Lafon, Y., Ed., and J. Reschke, Ed.,
              "Hypertext Transfer Protocol (HTTP/1.1): Range Requests",
              RFC 7233, DOI 10.17487/RFC7233, June 2014,
              <https://www.rfc-editor.org/info/rfc7233>.

   [RFC7234]  Fielding, R., Ed., Nottingham, M., Ed., and J. Reschke,
              Ed., "Hypertext Transfer Protocol (HTTP/1.1): Caching",
              RFC 7234, DOI 10.17487/RFC7234, June 2014,
              <https://www.rfc-editor.org/info/rfc7234>.

   [RFC7235]  Fielding, R., Ed. and J. Reschke, Ed., "Hypertext Transfer
              Protocol (HTTP/1.1): Authentication", RFC 7235,
              DOI 10.17487/RFC7235, June 2014,
              <https://www.rfc-editor.org/info/rfc7235>.

   [RFC7538]  Reschke, J., "The Hypertext Transfer Protocol Status Code
              308 (Permanent Redirect)", RFC 7538, DOI 10.17487/RFC7538,
              April 2015, <https://www.rfc-editor.org/info/rfc7538>.

   [RFC7540]  Belshe, M., Peon, R., and M. Thomson, Ed., "Hypertext
              Transfer Protocol Version 2 (HTTP/2)", RFC 7540,
              DOI 10.17487/RFC7540, May 2015,
              <https://www.rfc-editor.org/info/rfc7540>.

   [RFC7578]  Masinter, L., "Returning Values from Forms: multipart/
              form-data", RFC 7578, DOI 10.17487/RFC7578, July 2015,
              <https://www.rfc-editor.org/info/rfc7578>.

   [RFC7615]  Reschke, J., "HTTP Authentication-Info and Proxy-
              Authentication-Info Response Header Fields", RFC 7615,
              DOI 10.17487/RFC7615, September 2015,
              <https://www.rfc-editor.org/info/rfc7615>.

   [RFC7616]  Shekh-Yusef, R., Ed., Ahrens, D., and S. Bremer, "HTTP
              Digest Access Authentication", RFC 7616,
              DOI 10.17487/RFC7616, September 2015,
              <https://www.rfc-editor.org/info/rfc7616>.

   [RFC7617]  Reschke, J., "The 'Basic' HTTP Authentication Scheme",
              RFC 7617, DOI 10.17487/RFC7617, September 2015,
              <https://www.rfc-editor.org/info/rfc7617>.

   [RFC7694]  Reschke, J., "Hypertext Transfer Protocol (HTTP) Client-
              Initiated Content-Encoding", RFC 7694,
              DOI 10.17487/RFC7694, November 2015,
              <https://www.rfc-editor.org/info/rfc7694>.

   [RFC8126]  Cotton, M., Leiba, B., and T. Narten, "Guidelines for
              Writing an IANA Considerations Section in RFCs", BCP 26,
              RFC 8126, DOI 10.17487/RFC8126, June 2017,
              <https://www.rfc-editor.org/info/rfc8126>.

   [RFC8187]  Reschke, J., "Indicating Character Encoding and Language
              for HTTP Header Field Parameters", RFC 8187,
              DOI 10.17487/RFC8187, September 2017,
              <https://www.rfc-editor.org/info/rfc8187>.

   [RFC8246]  McManus, P., "HTTP Immutable Responses", RFC 8246,
              DOI 10.17487/RFC8246, September 2017,
              <https://www.rfc-editor.org/info/rfc8246>.

   [RFC8288]  Nottingham, M., "Web Linking", RFC 8288,
              DOI 10.17487/RFC8288, October 2017,
              <https://www.rfc-editor.org/info/rfc8288>.

   [RFC8336]  Nottingham, M. and E. Nygren, "The ORIGIN HTTP/2 Frame",
              RFC 8336, DOI 10.17487/RFC8336, March 2018,
              <https://www.rfc-editor.org/info/rfc8336>.

   [RFC8615]  Nottingham, M., "Well-Known Uniform Resource Identifiers
              (URIs)", RFC 8615, DOI 10.17487/RFC8615, May 2019,
              <https://www.rfc-editor.org/info/rfc8615>.

   [RFC8941]  Nottingham, M. and P-H. Kamp, "Structured Field Values for
              HTTP", RFC 8941, DOI 10.17487/RFC8941, February 2021,
              <https://www.rfc-editor.org/info/rfc8941>.

   [Sniffing] WHATWG, "MIME Sniffing",
              <https://mimesniff.spec.whatwg.org>.

   [WEBDAV]   Dusseault, L., Ed., "HTTP Extensions for Web Distributed
              Authoring and Versioning (WebDAV)", RFC 4918,
              DOI 10.17487/RFC4918, June 2007,
              <https://www.rfc-editor.org/info/rfc4918>.
```

---
# **Appendix A.  Collected ABNF**

아래 수집된 ABNF에서는 섹션 5.6.1에 따라 목록 규칙이 확장됩니다.

```text
   Accept = [ ( media-range [ weight ] ) *( OWS "," OWS ( media-range [
    weight ] ) ) ]
   Accept-Charset = [ ( ( token / "*" ) [ weight ] ) *( OWS "," OWS ( (
    token / "*" ) [ weight ] ) ) ]
   Accept-Encoding = [ ( codings [ weight ] ) *( OWS "," OWS ( codings [
    weight ] ) ) ]
   Accept-Language = [ ( language-range [ weight ] ) *( OWS "," OWS (
    language-range [ weight ] ) ) ]
   Accept-Ranges = acceptable-ranges
   Allow = [ method *( OWS "," OWS method ) ]
   Authentication-Info = [ auth-param *( OWS "," OWS auth-param ) ]
   Authorization = credentials

   BWS = OWS

   Connection = [ connection-option *( OWS "," OWS connection-option )
    ]
   Content-Encoding = [ content-coding *( OWS "," OWS content-coding )
    ]
   Content-Language = [ language-tag *( OWS "," OWS language-tag ) ]
   Content-Length = 1*DIGIT
   Content-Location = absolute-URI / partial-URI
   Content-Range = range-unit SP ( range-resp / unsatisfied-range )
   Content-Type = media-type

   Date = HTTP-date

   ETag = entity-tag
   Expect = [ expectation *( OWS "," OWS expectation ) ]
```

보낸 사람 = 사서함

```text
   GMT = %x47.4D.54 ; GMT

   HTTP-date = IMF-fixdate / obs-date
   Host = uri-host [ ":" port ]

   IMF-fixdate = day-name "," SP date1 SP time-of-day SP GMT
   If-Match = "*" / [ entity-tag *( OWS "," OWS entity-tag ) ]
   If-Modified-Since = HTTP-date
   If-None-Match = "*" / [ entity-tag *( OWS "," OWS entity-tag ) ]
   If-Range = entity-tag / HTTP-date
   If-Unmodified-Since = HTTP-date

   Last-Modified = HTTP-date
   Location = URI-reference

   Max-Forwards = 1*DIGIT

   OWS = *( SP / HTAB )

   Proxy-Authenticate = [ challenge *( OWS "," OWS challenge ) ]
   Proxy-Authentication-Info = [ auth-param *( OWS "," OWS auth-param )
    ]
   Proxy-Authorization = credentials

   RWS = 1*( SP / HTAB )
   Range = ranges-specifier
   Referer = absolute-URI / partial-URI
   Retry-After = HTTP-date / delay-seconds

   Server = product *( RWS ( product / comment ) )

   TE = [ t-codings *( OWS "," OWS t-codings ) ]
   Trailer = [ field-name *( OWS "," OWS field-name ) ]

   URI-reference = <URI-reference, see [URI], Section 4.1>
   Upgrade = [ protocol *( OWS "," OWS protocol ) ]
   User-Agent = product *( RWS ( product / comment ) )
```

Vary = \[ \( "\*" / 필드 이름 \) \*\( OWS "," OWS \( "\*" / 필드 이름 \) \) \] Via = \[ \( received-protocol RWS received-by \[ RWS comment \] \) \*\( OWS " ," OWS \( 수신 프로토콜 RWS 수신자 \[ RWS 주석 \] \) \) \]

```text
   WWW-Authenticate = [ challenge *( OWS "," OWS challenge ) ]

   absolute-URI = <absolute-URI, see [URI], Section 4.3>
   absolute-path = 1*( "/" segment )
   acceptable-ranges = range-unit *( OWS "," OWS range-unit )
   asctime-date = day-name SP date3 SP time-of-day SP year
   auth-param = token BWS "=" BWS ( token / quoted-string )
   auth-scheme = token
   authority = <authority, see [URI], Section 3.2>

   challenge = auth-scheme [ 1*SP ( token68 / [ auth-param *( OWS ","
    OWS auth-param ) ] ) ]
   codings = content-coding / "identity" / "*"
   comment = "(" *( ctext / quoted-pair / comment ) ")"
   complete-length = 1*DIGIT
   connection-option = token
   content-coding = token
   credentials = auth-scheme [ 1*SP ( token68 / [ auth-param *( OWS ","
    OWS auth-param ) ] ) ]
   ctext = HTAB / SP / %x21-27 ; '!'-'''
    / %x2A-5B ; '*'-'['
    / %x5D-7E ; ']'-'~'
    / obs-text

   date1 = day SP month SP year
   date2 = day "-" month "-" 2DIGIT
   date3 = month SP ( 2DIGIT / ( SP DIGIT ) )
   day = 2DIGIT
   day-name = %x4D.6F.6E ; Mon
    / %x54.75.65 ; Tue
    / %x57.65.64 ; Wed
    / %x54.68.75 ; Thu
    / %x46.72.69 ; Fri
    / %x53.61.74 ; Sat
    / %x53.75.6E ; Sun
   day-name-l = %x4D.6F.6E.64.61.79 ; Monday
    / %x54.75.65.73.64.61.79 ; Tuesday
    / %x57.65.64.6E.65.73.64.61.79 ; Wednesday
    / %x54.68.75.72.73.64.61.79 ; Thursday
    / %x46.72.69.64.61.79 ; Friday
    / %x53.61.74.75.72.64.61.79 ; Saturday
    / %x53.75.6E.64.61.79 ; Sunday
   delay-seconds = 1*DIGIT

   entity-tag = [ weak ] opaque-tag
   etagc = "!" / %x23-7E ; '#'-'~'
    / obs-text
   expectation = token [ "=" ( token / quoted-string ) parameters ]

   field-content = field-vchar [ 1*( SP / HTAB / field-vchar )
    field-vchar ]
   field-name = token
   field-value = *field-content
   field-vchar = VCHAR / obs-text
   first-pos = 1*DIGIT

   hour = 2DIGIT
   http-URI = "http://" authority path-abempty [ "?" query ]
   https-URI = "https://" authority path-abempty [ "?" query ]

   incl-range = first-pos "-" last-pos
   int-range = first-pos "-" [ last-pos ]

   language-range = <language-range, see [RFC4647], Section 2.1>
   language-tag = <Language-Tag, see [RFC5646], Section 2.1>
   last-pos = 1*DIGIT

   mailbox = <mailbox, see [RFC5322], Section 3.4>
   media-range = ( "*/*" / ( type "/*" ) / ( type "/" subtype ) )
    parameters
   media-type = type "/" subtype parameters
   method = token
   minute = 2DIGIT
   month = %x4A.61.6E ; Jan
    / %x46.65.62 ; Feb
    / %x4D.61.72 ; Mar
    / %x41.70.72 ; Apr
    / %x4D.61.79 ; May
    / %x4A.75.6E ; Jun
    / %x4A.75.6C ; Jul
    / %x41.75.67 ; Aug
    / %x53.65.70 ; Sep
    / %x4F.63.74 ; Oct
    / %x4E.6F.76 ; Nov
    / %x44.65.63 ; Dec

   obs-date = rfc850-date / asctime-date
   obs-text = %x80-FF
   opaque-tag = DQUOTE *etagc DQUOTE
   other-range = 1*( %x21-2B ; '!'-'+'
    / %x2D-7E ; '-'-'~'
    )

   parameter = parameter-name "=" parameter-value
   parameter-name = token
   parameter-value = ( token / quoted-string )
   parameters = *( OWS ";" OWS [ parameter ] )
   partial-URI = relative-part [ "?" query ]
   path-abempty = <path-abempty, see [URI], Section 3.3>
   port = <port, see [URI], Section 3.2.3>
   product = token [ "/" product-version ]
   product-version = token
   protocol = protocol-name [ "/" protocol-version ]
   protocol-name = token
   protocol-version = token
   pseudonym = token

   qdtext = HTAB / SP / "!" / %x23-5B ; '#'-'['
    / %x5D-7E ; ']'-'~'
    / obs-text
   query = <query, see [URI], Section 3.4>
   quoted-pair = "\" ( HTAB / SP / VCHAR / obs-text )
   quoted-string = DQUOTE *( qdtext / quoted-pair ) DQUOTE
   qvalue = ( "0" [ "." *3DIGIT ] ) / ( "1" [ "." *3"0" ] )

   range-resp = incl-range "/" ( complete-length / "*" )
   range-set = range-spec *( OWS "," OWS range-spec )
   range-spec = int-range / suffix-range / other-range
   range-unit = token
   ranges-specifier = range-unit "=" range-set
   received-by = pseudonym [ ":" port ]
   received-protocol = [ protocol-name "/" ] protocol-version
   relative-part = <relative-part, see [URI], Section 4.2>
   rfc850-date = day-name-l "," SP date2 SP time-of-day SP GMT

   second = 2DIGIT
   segment = <segment, see [URI], Section 3.3>
   subtype = token
   suffix-length = 1*DIGIT
   suffix-range = "-" suffix-length

   t-codings = "trailers" / ( transfer-coding [ weight ] )
   tchar = "!" / "#" / "$" / "%" / "&" / "'" / "*" / "+" / "-" / "." /
    "^" / "_" / "`" / "|" / "~" / DIGIT / ALPHA
   time-of-day = hour ":" minute ":" second
   token = 1*tchar
   token68 = 1*( ALPHA / DIGIT / "-" / "." / "_" / "~" / "+" / "/" )
    *"="
   transfer-coding = token *( OWS ";" OWS transfer-parameter )
   transfer-parameter = token BWS "=" BWS ( token / quoted-string )
   type = token

   unsatisfied-range = "*/" complete-length
   uri-host = <host, see [URI], Section 3.2.2>

   weak = %x57.2F ; W/
   weight = OWS ";" OWS "q=" qvalue

   year = 4DIGIT
```

---
# **Appendix B.  Changes from Previous RFCs**
---
### **B.1.  Changes from RFC 2818**

```text
   None.
```

---
### **B.2.  Changes from RFC 7230**

HTTP의 설계 목표, 역사, 아키텍처, 적합성 기준, 프로토콜 버전 관리, URI, 메시지 라우팅 및 헤더 필드를 소개하는 섹션이 여기로 이동되었습니다.

의미론적 적합성에 대한 요구 사항은 구현별 실패를 무시하거나 해결할 수 있는 권한으로 대체되었습니다. \(섹션 2.2\)

원본 서버에 대한 권한 있는 액세스에 대한 설명은 대체 서비스와 반드시 TCP를 기반으로 하지 않는 보안 연결을 설명하기 위해 "http" 및 "https" URI 모두에 대해 확장되었습니다. \(섹션 4.2.1, 4.2.2, 4.3.1 및 7.3.3\)

대상 URI 체계의 의미를 확인하고 관련 요구 사항을 충족하지 않는 요청을 거부하기 위한 명시적 요구 사항이 추가되었습니다. \(섹션 7.4\)

미디어 유형, 미디어 범위 및 예상 매개변수는 하나 이상의 후행 세미콜론을 통해 비어 있을 수 있습니다. \(섹션 5.6.6\)

이제 "필드 값"은 여러 필드 줄을 쉼표로 결합한 후의 값을 나타냅니다. 이는 지금까지 가장 일반적으로 사용됩니다. 단일 헤더 라인의 값을 참조하려면 "필드 라인 값"을 사용하십시오. \(섹션 6.3\)

트레일러 필드 의미론은 이제 청크 분할 전송 코딩의 특성을 초월합니다. 트레일러 필드의 사용은 발신자가 필드가 해당 사용법을 정의한다는 것을 알고 있는 경우에만 트레일러 필드로 생성을 허용하고 수신자가 해당 필드 정의가 허용하고 병합 방법을 정의하는 경우에만 헤더 섹션에 병합을 허용하도록 제한되었습니다. 다른 모든 경우에는 트레일러 필드를 별도로 저장하거나 병합하는 대신 삭제하는 것이 권장됩니다. \(섹션 6.5.1\)

원본 서버의 Host 헤더 필드에 대한 요청 URI의 절대 형식 우선순위가 프록시 처리에 맞춰 명시적으로 지정되었습니다. \(섹션 7.2\)

Via 필드의 "received-by"에 대한 문법 정의는 Via에 바람직하지 않은 호스트 \[URI\]에 대한 URI 문법의 변경으로 인해 RFC 7230에서 확장되었습니다. 단순화를 위해 uri-host는 가명에 대한 기존 문법에 포함될 수 있으므로 수신자 프로덕션에서 제거했습니다. 특히 이번 변경으로 received-by의 호스트 이름에 허용되는 문자 집합에서 쉼표가 제거되었습니다. \(섹션 7.6.3\)

---
### **B.3.  Changes from RFC 7231**

이제 구현에서 지원되는 최소 URI 길이가 권장됩니다. \(섹션 4.1\)

다음 사항이 명확해졌습니다. 필드 값의 CR 및 NUL은 거부되거나 SP에 매핑되고 선행 및 후행 공백은 사용되기 전에 필드 값에서 제거되어야 합니다. \(섹션 5.5\)

미디어 유형, 미디어 범위 및 예상 매개변수는 하나 이상의 후행 세미콜론을 통해 비어 있을 수 있습니다. \(섹션 5.6.6\)

HTTP 메시지에 대한 추상 데이터 유형은 \[HTTP/1.1\]의 HTTP/1.1의 특정 구문 형식의 관점이 아닌 여러 HTTP 버전에 대한 추상화로 메시지의 구성 요소와 의미를 정의하고 이를 반영하기 위해 도입되었습니다. 메시지가 구문 분석된 후의 내용입니다. 이를 통해 콘텐츠에 대한 요구 사항\(전달되는 내용\)과 메시징 구문에 대한 요구 사항\(전달 방법\)을 더 쉽게 구분할 수 있으며 초기 프로토콜 버전의 제한 사항을 HTTP의 미래에 반영하는 것을 방지할 수 있습니다. \(6항\)

"페이로드" 및 "페이로드 본문"이라는 용어는 다른 곳에서의 사용\(예: 필드 이름\)과 더 잘 일치하고 HTTP/2 및 HTTP/3의 프레임 페이로드와의 혼동을 피하기 위해 "콘텐츠"로 대체되었습니다. \(섹션 6.4\)

"유효 요청 URI"라는 용어가 "대상 URI"로 대체되었습니다. \(섹션 7.1\)

구현 동작을 반영하기 위해 클라이언트 재시도에 대한 제한이 완화되었습니다. \(섹션 9.2.2\)

GET, HEAD 및 DELETE의 요청 본문이 상호 운용 가능하지 않다는 사실이 명확해졌습니다. \(섹션 9.3.1, 9.3.2 및 9.3.5\)

PUT의 요청 수정자로 Content-Range 헤더 필드\(섹션 14.4\)를 사용하는 것이 허용됩니다. \(9.3.4항\)

Content-Length 설정에 대한 불필요한 요구 사항이 OPTIONS 메서드 설명에서 제거되었습니다. \(9.3.7절\)

TRACE 응답에서 "message/http" 미디어 유형을 사용하기 위한 규범적 요구 사항이 제거되었습니다. \(9.3.8절\)

RFC 2616과의 호환성을 위해 Expect의 목록 기반 문법이 복원되었습니다. \(10.1.1절\)

응답 메시지에는 Accept 및 Accept-Encoding이 허용됩니다. 후자는 \[RFC7694\]에 의해 도입되었습니다. \(12.3항\)

"수락 매개변수"\(accept-params 및 accept-ext ABNF 생성\)가 Accept 필드 정의에서 제거되었습니다. \(섹션 12.5.1\)

Accept-Charset 필드는 이제 더 이상 사용되지 않습니다. \(섹션 12.5.2\)

다른 값이 있을 때 Vary 헤더 필드의 "\*" 의미가 명확해졌습니다. \(섹션 12.5.5\)

범위 단위는 대소문자를 구분하지 않고 비교됩니다. \(14.1항\)

Accept-Ranges 필드의 사용은 원본 서버로 제한되지 않습니다. \(14.3항\)

리디렉션된 요청을 생성하는 프로세스가 명확해졌습니다. \(15.4항\)

상태 코드 308\(이전에 \[RFC7538\]에 정의됨\)이 추가되어 상태 코드 301, 302 및 307에 더 가깝게 정의되었습니다. \(15.4.9절\)

일반적인 적용 가능성으로 인해 상태 코드 421\(이전에 \[RFC7540\]의 섹션 9.1.2에 정의됨\)이 추가되었습니다. 421은 응답이 연결\(대상 리소스가 아님\)에 특정하기 때문에 더 이상 경험적으로 캐시 가능한 것으로 정의되지 않습니다. \(섹션 15.5.20\)

일반적인 적용 가능성으로 인해 상태 코드 422\(이전에 \[WEBDAV\]의 섹션 11.2에 정의됨\)가 추가되었습니다. \(섹션 15.5.21\)

---
### **B.4.  Changes from RFC 7232**

이전 HTTP 개정판에서는 Date 및 Last-Modified 값이 준비 중 다른 시계 또는 다소 다른 시간에 생성될 가능성을 방지하기 위해 Last-Modified가 강력한 유효성 검사기인지 여부를 결정하는 데 임의의 60초 제한을 적용했습니다. 응답. 이 사양은 합리적인 재량권을 허용하도록 완화되었습니다. \(섹션 8.8.2.2\)

변경 요청이 이미 적용되었기 때문에 유효성 검사가 실패하는 경우 유효성 검사기가 2xx 응답으로 전송되지 않도록 요구하는 If-Match 및 If-Unmodified-Since에 대한 극단적인 경우 요구 사항이 제거되었습니다. \(섹션 13.1.1 및 13.1.4\)

수정 시간 개념이 없는 자원에는 If-Unmodified-Since가 적용되지 않는다는 사실을 명확히 했습니다. \(섹션 13.1.4\)

이제 응답이 성공할 때까지 기다리지 않고 요청 콘텐츠가 처리되기 전에 전제 조건을 평가할 수 있습니다. \(13.2항\)

---
### **B.5.  Changes from RFC 7233**

범위 단위 및 범위 지정자 문법을 리팩터링하여 바이트와 기타\(확장\) 범위 단위 사이의 인위적인 구별을 단순화하고 줄이고, 범위 단위를 일반적으로 토큰으로 정의하고 범위 내에 확장을 배치하여 other-range-unit의 중복 문법을 제거했습니다. 범위 사양\(기타 범위\)입니다. 이는 두 개 이상의 범위로 구성된 범위 집합을 나타내기 위해 확장 범위 단위를 포함한 모든 범위 집합에서 목록 구문\(쉼표\)의 역할을 명확하게 합니다. 확장 문법을 범위 지정자로 이동하면 바이트 범위에 특정한 프로토콜을 별도로 지정할 수도 있습니다.

이제 확장 메서드에서 범위 처리를 정의할 수 있습니다. \(14.2항\)

부분 PUT를 수행하기 위한 요청 수정자로 Content-Range 헤더 필드\(섹션 14.4\)를 사용하는 방법을 설명했습니다. \(14.5항\)

---
### **B.6.  Changes from RFC 7235**

```text
   None.
```

---
### **B.7.  Changes from RFC 7538**

```text
   None.
```

---
### **B.8.  Changes from RFC 7615**

```text
   None.
```

---
### **B.9.  Changes from RFC 7694**

이 사양에는 \[RFC7694\]에 정의된 확장이 포함되어 있지만 예제와 배포 고려 사항은 생략되었습니다.

---
# **Acknowledgements**

현재 편집자 외에도 HTTP 및 핵심 사양의 초기 측면에 기여한 공로로 특별한 표창을 받을 자격이 있는 사람은 다음과 같습니다. Marc Andreessen, Tim Berners-Lee, Robert Cailliau, Daniel W. Connolly, Bob Denny, John Franks, Jim Gettys, Jean-François Groff, Phillip M. Hallam-Baker, Koen Holtman, Jeffery L. Hostetler, Shel Kaphan, Dave Kristol, Yves Lafon, Scott D. Lawrence, Paul J. Leach, Håkon W. Lie, Ari Luotonen, Larry Masinter, Rob McCool, Jeffrey C. Mogul, Lou Montulli, David Morris, Henrik Frystyk Nielsen, Dave Raggett, Eric Rescorla, Tony Sanders, Lawrence C. Stewart, Marc VanHeyningen 및 Steve Zilles.

이 문서는 \[HTTP/1.0\], \[RFC2068\], \[RFC2145\], \[RFC2616\], \[RFC2617\], \[RFC2818\], \[RFC7230\], \[RFC7231\], \[RFC7232\], \[RFC7233\], \[RFC7234\] 및 \[RFC7235\]. 해당 문서에 포함된 승인 내용은 여전히 ​​적용됩니다.

2014년부터 다음 기여자는 버그 보고, 현명한 질문 요청, 텍스트 초안 작성 또는 검토, 문제 평가를 통해 이 사양을 개선하는 데 도움을 주었습니다.

Alan Egerton, Alex Rousskov, Amichai Rothman, Amos Jeffries, Anders Kaseorg, Andreas Gebhardt, Anne van Kesteren, Armin Abfalterer, Aron Duby, Asanka Herath, Asbjørn Ulsberg, Asta Olofsson, Attila Gulyas, Austin Wright, Barry Pollard, Ben Burkert, Benjamin Kaduk, Björn Höhrmann, Brad Fitzpatrick, Chris Pacejo, Colin Bendell, Cory Benfield, Cory Nelson, Daisuke Miyakawa, Dale Worley, Daniel Stenberg, Danil Suits, David Benjamin, David Matson, David Schinazi, Дилян Палаузов \(Dilyan Palauzov\), Eric Anderson , Eric Rescorla, Éric Vyncke, Erik Kline, Erwin Pe, Etan Kissling, Evert Pot, Evgeny Vrublevsky, Florian Best, Francesca Palombini, Igor Lubashev, James Callahan, James Peach, Jeffrey Yasskin, Kalin Gyokov, Kannan Goundan, 奥 一穂\(Kazuho\) Oku\), Ken Murchison, Krzysztof Maczyński, Lars Eggert, Lucas Pardue, Martin Duke, Martin Dürst, Martin Thomson, Martynas Jusevičius, Matt Menke, Matthias Pigulla, Mattias Grenfeldt, Michael Osipov, Mike Bishop, Mike Pennisi, Mike Taylor, Mike West , Mohit Sethi, Murray Kucherawy, Nathaniel J. Smith, Nicholas Hurley, Nikita Prokhorov, Patrick McManus, Piotr Sikora, Poul-Henning Kamp, Rick van Rein, Robert Wilton, Roberto Polli, Roman Danyliw, Samuel Williams, Semyon Kholodnov, Simon Pieters , Simon Schüppel, Stefan Eissing, Taylor Hunt, Todd Greer, Tommy Pauly, Vasiliy Faronov, Vladimir Lashchev, Wenbo Zhu, William A. Rowe Jr., Willy Tarreau, Xingwei Liu, Yishuai Li 및 Zaheduzzaman Sarker.

---
# **Index**

1 2 3 4 5 A B C D E F G H I L M N O P R S T U V W X

```text
      1

         100 Continue (status code)  *_Section 15.2.1_*
         100-continue (expect value)  *_Section 10.1.1_*
         101 Switching Protocols (status code)  *_Section 15.2.2_*
         1xx Informational (status code class)  *_Section 15.2_*

      2

         200 OK (status code)  *_Section 15.3.1_*
         201 Created (status code)  *_Section 15.3.2_*
         202 Accepted (status code)  *_Section 15.3.3_*
         203 Non-Authoritative Information (status code)  *_Section 15.3
            .4_*
         204 No Content (status code)  *_Section 15.3.5_*
         205 Reset Content (status code)  *_Section 15.3.6_*
         206 Partial Content (status code)  *_Section 15.3.7_*
         2xx Successful (status code class)  *_Section 15.3_*

      3

         300 Multiple Choices (status code)  *_Section 15.4.1_*
         301 Moved Permanently (status code)  *_Section 15.4.2_*
         302 Found (status code)  *_Section 15.4.3_*
         303 See Other (status code)  *_Section 15.4.4_*
         304 Not Modified (status code)  *_Section 15.4.5_*
         305 Use Proxy (status code)  *_Section 15.4.6_*
         306 (Unused) (status code)  *_Section 15.4.7_*
         307 Temporary Redirect (status code)  *_Section 15.4.8_*
         308 Permanent Redirect (status code)  *_Section 15.4.9_*
         3xx Redirection (status code class)  *_Section 15.4_*

      4

         400 Bad Request (status code)  *_Section 15.5.1_*
         401 Unauthorized (status code)  *_Section 15.5.2_*
         402 Payment Required (status code)  *_Section 15.5.3_*
         403 Forbidden (status code)  *_Section 15.5.4_*
         404 Not Found (status code)  *_Section 15.5.5_*
         405 Method Not Allowed (status code)  *_Section 15.5.6_*
         406 Not Acceptable (status code)  *_Section 15.5.7_*
         407 Proxy Authentication Required (status code)  *_Section 15.5
            .8_*
         408 Request Timeout (status code)  *_Section 15.5.9_*
         409 Conflict (status code)  *_Section 15.5.10_*
         410 Gone (status code)  *_Section 15.5.11_*
         411 Length Required (status code)  *_Section 15.5.12_*
         412 Precondition Failed (status code)  *_Section 15.5.13_*
         413 Content Too Large (status code)  *_Section 15.5.14_*
         414 URI Too Long (status code)  *_Section 15.5.15_*
         415 Unsupported Media Type (status code)  *_Section 15.5.16_*
         416 Range Not Satisfiable (status code)  *_Section 15.5.17_*
         417 Expectation Failed (status code)  *_Section 15.5.18_*
         418 (Unused) (status code)  *_Section 15.5.19_*
         421 Misdirected Request (status code)  *_Section 15.5.20_*
         422 Unprocessable Content (status code)  *_Section 15.5.21_*
         426 Upgrade Required (status code)  *_Section 15.5.22_*
         4xx Client Error (status code class)  *_Section 15.5_*

      5

         500 Internal Server Error (status code)  *_Section 15.6.1_*
         501 Not Implemented (status code)  *_Section 15.6.2_*
         502 Bad Gateway (status code)  *_Section 15.6.3_*
         503 Service Unavailable (status code)  *_Section 15.6.4_*
         504 Gateway Timeout (status code)  *_Section 15.6.5_*
         505 HTTP Version Not Supported (status code)  *_Section 15.6.6_
            *
         5xx Server Error (status code class)  *_Section 15.6_*

      A

         accelerator  *_Section 3.7, Paragraph 6_*
         Accept header field  *_Section 12.5.1_*
         Accept-Charset header field  *_Section 12.5.2_*
         Accept-Encoding header field  *_Section 12.5.3_*
         Accept-Language header field  *_Section 12.5.4_*
         Accept-Ranges header field  *_Section 14.3_*
         Allow header field  *_Section 10.2.1_*
         Authentication-Info header field  *_Section 11.6.3_*
         authoritative response  *_Section 17.1_*
         Authorization header field  *_Section 11.6.2_*

      B

         browser  *_Section 3.5_*

      C

         cache  *_Section 3.8_*
         cacheable  *_Section 3.8, Paragraph 4_*
         client  *_Section 3.3_*
         clock  *_Section 5.6.7_*
         complete  *_Section 6.1_*
         compress (Coding Format)  Section 8.4.1.1
         compress (content coding)  *_Section 8.4.1_*
         conditional request  *_Section 13_*
         CONNECT method  *_Section 9.3.6_*
         connection  *_Section 3.3_*
         Connection header field  *_Section 7.6.1_*
         content  Section 6.4
         content coding  *_Section 8.4.1_*
         content negotiation  Section 1.3, Paragraph 4
         Content-Encoding header field  *_Section 8.4_*
         Content-Language header field  *_Section 8.5_*
         Content-Length header field  *_Section 8.6_*
         Content-Location header field  *_Section 8.7_*
         Content-MD5 header field  *_Section 18.4, Paragraph 10_*
         Content-Range header field  *_Section 14.4_*; Section 14.5
         Content-Type header field  *_Section 8.3_*
         control data  *_Section 6.2_*

      D

         Date header field  *_Section 6.6.1_*
         deflate (Coding Format)  Section 8.4.1.2
         deflate (content coding)  *_Section 8.4.1_*
         DELETE method  *_Section 9.3.5_*
         Delimiters  Section 5.6.2, Paragraph 3
         downstream  *_Section 3.7, Paragraph 4_*

      E

         effective request URI  *_Section 7.1, Paragraph 8.1_*
         ETag field  *_Section 8.8.3_*
         Expect header field  *_Section 10.1.1_*

      F

         field  *_Section 5_*; Section 6.3
         field line  Section 5.2, Paragraph 1
         field line value  Section 5.2, Paragraph 1
         field name  Section 5.2, Paragraph 1
         field value  Section 5.2, Paragraph 2
         Fields
            *  *_Section 18.4, Paragraph 9_*
            Accept  *_Section 12.5.1_*
            Accept-Charset  *_Section 12.5.2_*
            Accept-Encoding  *_Section 12.5.3_*
            Accept-Language  *_Section 12.5.4_*
            Accept-Ranges  *_Section 14.3_*
            Allow  *_Section 10.2.1_*
            Authentication-Info  *_Section 11.6.3_*
            Authorization  *_Section 11.6.2_*
            Connection  *_Section 7.6.1_*
            Content-Encoding  *_Section 8.4_*
            Content-Language  *_Section 8.5_*
            Content-Length  *_Section 8.6_*
            Content-Location  *_Section 8.7_*
            Content-MD5  *_Section 18.4, Paragraph 10_*
            Content-Range  *_Section 14.4_*; Section 14.5
            Content-Type  *_Section 8.3_*
            Date  *_Section 6.6.1_*
            ETag  *_Section 8.8.3_*
            Expect  *_Section 10.1.1_*
            From  *_Section 10.1.2_*
            Host  *_Section 7.2_*
            If-Match  *_Section 13.1.1_*
            If-Modified-Since  *_Section 13.1.3_*
            If-None-Match  *_Section 13.1.2_*
            If-Range  *_Section 13.1.5_*
            If-Unmodified-Since  *_Section 13.1.4_*
            Last-Modified  *_Section 8.8.2_*
            Location  *_Section 10.2.2_*
            Max-Forwards  *_Section 7.6.2_*
            Proxy-Authenticate  *_Section 11.7.1_*
            Proxy-Authentication-Info  *_Section 11.7.3_*
            Proxy-Authorization  *_Section 11.7.2_*
            Range  *_Section 14.2_*
            Referer  *_Section 10.1.3_*
            Retry-After  *_Section 10.2.3_*
            Server  *_Section 10.2.4_*
            TE  *_Section 10.1.4_*
            Trailer  *_Section 6.6.2_*
            Upgrade  *_Section 7.8_*
            User-Agent  *_Section 10.1.5_*
            Vary  *_Section 12.5.5_*
            Via  *_Section 7.6.3_*
            WWW-Authenticate  *_Section 11.6.1_*
         Fragment Identifiers  Section 4.2.5
         From header field  *_Section 10.1.2_*

      G

         gateway  *_Section 3.7, Paragraph 6_*
         GET method  *_Section 9.3.1_*
         Grammar
            ALPHA  *_Section 2.1_*
            Accept  *_Section 12.5.1_*
            Accept-Charset  *_Section 12.5.2_*
            Accept-Encoding  *_Section 12.5.3_*
            Accept-Language  *_Section 12.5.4_*
            Accept-Ranges  *_Section 14.3_*
            Allow  *_Section 10.2.1_*
            Authentication-Info  *_Section 11.6.3_*
            Authorization  *_Section 11.6.2_*
            BWS  *_Section 5.6.3_*
            CR  *_Section 2.1_*
            CRLF  *_Section 2.1_*
            CTL  *_Section 2.1_*
            Connection  *_Section 7.6.1_*
            Content-Encoding  *_Section 8.4_*
            Content-Language  *_Section 8.5_*
            Content-Length  *_Section 8.6_*
            Content-Location  *_Section 8.7_*
            Content-Range  *_Section 14.4_*
            Content-Type  *_Section 8.3_*
            DIGIT  *_Section 2.1_*
            DQUOTE  *_Section 2.1_*
            Date  *_Section 6.6.1_*
            ETag  *_Section 8.8.3_*
            Expect  *_Section 10.1.1_*
            From  *_Section 10.1.2_*
            GMT  *_Section 5.6.7_*
            HEXDIG  *_Section 2.1_*
            HTAB  *_Section 2.1_*
            HTTP-date  *_Section 5.6.7_*
            Host  *_Section 7.2_*
            IMF-fixdate  *_Section 5.6.7_*
            If-Match  *_Section 13.1.1_*
            If-Modified-Since  *_Section 13.1.3_*
            If-None-Match  *_Section 13.1.2_*
            If-Range  *_Section 13.1.5_*
            If-Unmodified-Since  *_Section 13.1.4_*
            LF  *_Section 2.1_*
            Last-Modified  *_Section 8.8.2_*
            Location  *_Section 10.2.2_*
            Max-Forwards  *_Section 7.6.2_*
            OCTET  *_Section 2.1_*
            OWS  *_Section 5.6.3_*
            Proxy-Authenticate  *_Section 11.7.1_*
            Proxy-Authentication-Info  *_Section 11.7.3_*
            Proxy-Authorization  *_Section 11.7.2_*
            RWS  *_Section 5.6.3_*
            Range  *_Section 14.2_*
            Referer  *_Section 10.1.3_*
            Retry-After  *_Section 10.2.3_*
            SP  *_Section 2.1_*
            Server  *_Section 10.2.4_*
            TE  *_Section 10.1.4_*
            Trailer  *_Section 6.6.2_*
            URI-reference  *_Section 4.1_*
            Upgrade  *_Section 7.8_*
            User-Agent  *_Section 10.1.5_*
            VCHAR  *_Section 2.1_*
            Vary  *_Section 12.5.5_*
            Via  *_Section 7.6.3_*
            WWW-Authenticate  *_Section 11.6.1_*
            absolute-URI  *_Section 4.1_*
            absolute-path  *_Section 4.1_*
            acceptable-ranges  *_Section 14.3_*
            asctime-date  *_Section 5.6.7_*
            auth-param  *_Section 11.2_*
            auth-scheme  *_Section 11.1_*
            authority  *_Section 4.1_*
            challenge  *_Section 11.3_*
            codings  *_Section 12.5.3_*
            comment  *_Section 5.6.5_*
            complete-length  *_Section 14.4_*
            connection-option  *_Section 7.6.1_*
            content-coding  *_Section 8.4.1_*
            credentials  *_Section 11.4_*
            ctext  *_Section 5.6.5_*
            date1  *_Section 5.6.7_*
            day  *_Section 5.6.7_*
            day-name  *_Section 5.6.7_*
            day-name-l  *_Section 5.6.7_*
            delay-seconds  *_Section 10.2.3_*
            entity-tag  *_Section 8.8.3_*
            etagc  *_Section 8.8.3_*
            field-content  *_Section 5.5_*
            field-name  *_Section 5.1_*; Section 6.6.2
            field-value  *_Section 5.5_*
            field-vchar  *_Section 5.5_*
            first-pos  *_Section 14.1.1_*; Section 14.4
            hour  *_Section 5.6.7_*
            http-URI  *_Section 4.2.1_*
            https-URI  *_Section 4.2.2_*
            incl-range  *_Section 14.4_*
            int-range  *_Section 14.1.1_*
            language-range  *_Section 12.5.4_*
            language-tag  *_Section 8.5.1_*
            last-pos  *_Section 14.1.1_*; Section 14.4
            media-range  *_Section 12.5.1_*
            media-type  *_Section 8.3.1_*
            method  *_Section 9.1_*
            minute  *_Section 5.6.7_*
            month  *_Section 5.6.7_*
            obs-date  *_Section 5.6.7_*
            obs-text  *_Section 5.5_*
            opaque-tag  *_Section 8.8.3_*
            other-range  *_Section 14.1.1_*
            parameter  *_Section 5.6.6_*
            parameter-name  *_Section 5.6.6_*
            parameter-value  *_Section 5.6.6_*
            parameters  *_Section 5.6.6_*
            partial-URI  *_Section 4.1_*
            port  *_Section 4.1_*
            product  *_Section 10.1.5_*
            product-version  *_Section 10.1.5_*
            protocol-name  *_Section 7.6.3_*
            protocol-version  *_Section 7.6.3_*
            pseudonym  *_Section 7.6.3_*
            qdtext  *_Section 5.6.4_*
            query  *_Section 4.1_*
            quoted-pair  *_Section 5.6.4_*
            quoted-string  *_Section 5.6.4_*
            qvalue  *_Section 12.4.2_*
            range-resp  *_Section 14.4_*
            range-set  *_Section 14.1.1_*
            range-spec  *_Section 14.1.1_*
            range-unit  *_Section 14.1_*
            ranges-specifier  *_Section 14.1.1_*
            received-by  *_Section 7.6.3_*
            received-protocol  *_Section 7.6.3_*
            rfc850-date  *_Section 5.6.7_*
            second  *_Section 5.6.7_*
            segment  *_Section 4.1_*
            subtype  *_Section 8.3.1_*
            suffix-length  *_Section 14.1.1_*
            suffix-range  *_Section 14.1.1_*
            t-codings  *_Section 10.1.4_*
            tchar  *_Section 5.6.2_*
            time-of-day  *_Section 5.6.7_*
            token  *_Section 5.6.2_*
            token68  *_Section 11.2_*
            transfer-coding  *_Section 10.1.4_*
            transfer-parameter  *_Section 10.1.4_*
            type  *_Section 8.3.1_*
            unsatisfied-range  *_Section 14.4_*
            uri-host  *_Section 4.1_*
            weak  *_Section 8.8.3_*
            weight  *_Section 12.4.2_*
            year  *_Section 5.6.7_*
         gzip (Coding Format)  Section 8.4.1.3
         gzip (content coding)  *_Section 8.4.1_*

      H

         HEAD method  *_Section 9.3.2_*
         Header Fields
            Accept  *_Section 12.5.1_*
            Accept-Charset  *_Section 12.5.2_*
            Accept-Encoding  *_Section 12.5.3_*
            Accept-Language  *_Section 12.5.4_*
            Accept-Ranges  *_Section 14.3_*
            Allow  *_Section 10.2.1_*
            Authentication-Info  *_Section 11.6.3_*
            Authorization  *_Section 11.6.2_*
            Connection  *_Section 7.6.1_*
            Content-Encoding  *_Section 8.4_*
            Content-Language  *_Section 8.5_*
            Content-Length  *_Section 8.6_*
            Content-Location  *_Section 8.7_*
            Content-MD5  *_Section 18.4, Paragraph 10_*
            Content-Range  *_Section 14.4_*; Section 14.5
            Content-Type  *_Section 8.3_*
            Date  *_Section 6.6.1_*
            ETag  *_Section 8.8.3_*
            Expect  *_Section 10.1.1_*
            From  *_Section 10.1.2_*
            Host  *_Section 7.2_*
            If-Match  *_Section 13.1.1_*
            If-Modified-Since  *_Section 13.1.3_*
            If-None-Match  *_Section 13.1.2_*
            If-Range  *_Section 13.1.5_*
            If-Unmodified-Since  *_Section 13.1.4_*
            Last-Modified  *_Section 8.8.2_*
            Location  *_Section 10.2.2_*
            Max-Forwards  *_Section 7.6.2_*
            Proxy-Authenticate  *_Section 11.7.1_*
            Proxy-Authentication-Info  *_Section 11.7.3_*
            Proxy-Authorization  *_Section 11.7.2_*
            Range  *_Section 14.2_*
            Referer  *_Section 10.1.3_*
            Retry-After  *_Section 10.2.3_*
            Server  *_Section 10.2.4_*
            TE  *_Section 10.1.4_*
            Trailer  *_Section 6.6.2_*
            Upgrade  *_Section 7.8_*
            User-Agent  *_Section 10.1.5_*
            Vary  *_Section 12.5.5_*
            Via  *_Section 7.6.3_*
            WWW-Authenticate  *_Section 11.6.1_*
         header section  *_Section 6.3_*
         Host header field  *_Section 7.2_*
         http URI scheme  *_Section 4.2.1_*
         https URI scheme  *_Section 4.2.2_*

      I

         idempotent  *_Section 9.2.2_*
         If-Match header field  *_Section 13.1.1_*
         If-Modified-Since header field  *_Section 13.1.3_*
         If-None-Match header field  *_Section 13.1.2_*
         If-Range header field  *_Section 13.1.5_*
         If-Unmodified-Since header field  *_Section 13.1.4_*
         inbound  *_Section 3.7, Paragraph 4_*
         incomplete  *_Section 6.1_*
         interception proxy  *_Section 3.7, Paragraph 10_*
         intermediary  *_Section 3.7_*

      L

         Last-Modified header field  *_Section 8.8.2_*
         list-based field  Section 5.5, Paragraph 7
         Location header field  *_Section 10.2.2_*

      M

         Max-Forwards header field  *_Section 7.6.2_*
         Media Type
            multipart/byteranges  *_Section 14.6_*
            multipart/x-byteranges  Section 14.6, Paragraph 4, Item 3
         message  Section 3.4; *_Section 6_*
         message abstraction  *_Section 6_*
         messages  *_Section 3.4_*
         metadata  *_Section 8.8_*
         Method
            *  *_Section 18.2, Paragraph 3_*
            CONNECT  *_Section 9.3.6_*
            DELETE  *_Section 9.3.5_*
            GET  *_Section 9.3.1_*
            HEAD  *_Section 9.3.2_*
            OPTIONS  *_Section 9.3.7_*
            POST  *_Section 9.3.3_*
            PUT  *_Section 9.3.4_*
            TRACE  *_Section 9.3.8_*
         multipart/byteranges Media Type  *_Section 14.6_*
         multipart/x-byteranges Media Type  Section 14.6, Paragraph 4,
            Item 3

      N

         non-transforming proxy  *_Section 7.7_*

      O

         OPTIONS method  *_Section 9.3.7_*
         origin  *_Section 4.3.1_*; Section 11.5
         origin server  *_Section 3.6_*
         outbound  *_Section 3.7, Paragraph 4_*

      P

         phishing  *_Section 17.1_*
         POST method  *_Section 9.3.3_*
         Protection Space  Section 11.5
         proxy  *_Section 3.7, Paragraph 5_*
         Proxy-Authenticate header field  *_Section 11.7.1_*
         Proxy-Authentication-Info header field  *_Section 11.7.3_*
         Proxy-Authorization header field  *_Section 11.7.2_*
         PUT method  *_Section 9.3.4_*

      R

         Range header field  *_Section 14.2_*
         Realm  Section 11.5
         recipient  *_Section 3.4_*
         Referer header field  *_Section 10.1.3_*
         representation  *_Section 3.2_*
         request  *_Section 3.4_*
         request target  *_Section 7.1_*
         resource  *_Section 3.1_*; Section 4
         response  *_Section 3.4_*
         Retry-After header field  *_Section 10.2.3_*
         reverse proxy  *_Section 3.7, Paragraph 6_*

      S

         safe  *_Section 9.2.1_*
         satisfiable range  *_Section 14.1.1_*
         secured  *_Section 4.2.2_*
         selected representation  *_Section 3.2, Paragraph 4_*;
            Section 8.8; Section 13.1
         self-descriptive  *_Section 6_*
         sender  *_Section 3.4_*
         server  *_Section 3.3_*
         Server header field  *_Section 10.2.4_*
         singleton field  Section 5.5, Paragraph 6
         spider  *_Section 3.5_*
         Status Code  Section 15
         Status Codes
            Final  Section 15, Paragraph 7
            Informational  Section 15, Paragraph 7
            Interim  Section 15, Paragraph 7
         Status Codes Classes
            1xx Informational  *_Section 15.2_*
            2xx Successful  *_Section 15.3_*
            3xx Redirection  *_Section 15.4_*
            4xx Client Error  *_Section 15.5_*
            5xx Server Error  *_Section 15.6_*

      T

         target resource  *_Section 7.1_*
         target URI  *_Section 7.1_*
         TE header field  *_Section 10.1.4_*
         TRACE method  *_Section 9.3.8_*
         Trailer Fields  *_Section 6.5_*
            ETag  *_Section 8.8.3_*
         Trailer header field  *_Section 6.6.2_*
         trailer section  *_Section 6.5_*
         trailers  *_Section 6.5_*
         transforming proxy  *_Section 7.7_*
         transparent proxy  *_Section 3.7, Paragraph 10_*
         tunnel  *_Section 3.7, Paragraph 8_*

      U

         unsatisfiable range  *_Section 14.1.1_*
         Upgrade header field  *_Section 7.8_*
         upstream  *_Section 3.7, Paragraph 4_*
         URI  *_Section 4_*
            origin  *_Section 4.3.1_*
         URI reference  *_Section 4.1_*
         URI scheme
            http  *_Section 4.2.1_*
            https  *_Section 4.2.2_*
         user agent  *_Section 3.5_*
         User-Agent header field  *_Section 10.1.5_*

      V

         validator  *_Section 8.8_*
            strong  *_Section 8.8.1_*
            weak  *_Section 8.8.1_*
         Vary header field  *_Section 12.5.5_*
         Via header field  *_Section 7.6.3_*

      W

         WWW-Authenticate header field  *_Section 11.6.1_*

      X

         x-compress (content coding)  *_Section 8.4.1_*
         x-gzip (content coding)  *_Section 8.4.1_*
```

---
# **Authors' Addresses**

Roy T. Fielding\(편집자\) Adobe 345 Park Ave San Jose, CA 95110 United States of America 이메일: fielding@gbiv.com URI: https://roy.gbiv.com/

```text
   Mark Nottingham (editor)
   Fastly
   Prahran
   Australia
   Email: mnot@mnot.net
   URI:   https://www.mnot.net/

   Julian Reschke (editor)
   greenbytes GmbH
   Hafenweg 16
   48155 Münster
   Germany
   Email: julian.reschke@greenbytes.de
   URI:   https://greenbytes.de/tech/webdav/
```  Germany
   Email: julian.reschke@greenbytes.de
   URI:   https://greenbytes.de/tech/webdav/
```dresses**

Roy T. Fielding\(편집자\) Adobe 345 Park Ave San Jose, CA 95110 United States of America 이메일: fielding@gbiv.com URI: https://roy.gbiv.com/

```text
   Mark Nottingham (editor)
   Fastly
   Prahran
   Australia
   Email: mnot@mnot.net
   URI:   https://www.mnot.net/

   Julian Reschke (editor)
   greenbytes GmbH
   Hafenweg 16
   48155 Münster
   Germany
   Email: julian.reschke@greenbytes.de
   URI:   https://greenbytes.de/tech/webdav/
```
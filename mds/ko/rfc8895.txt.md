

```text
﻿

Internet Engineering Task Force (IETF)                          W. Roome
Request for Comments: 8895                               Nokia Bell Labs
Category: Standards Track                                        Y. Yang
ISSN: 2070-1721                                          Yale University
                                                           November 2020

Application-Layer Traffic Optimization (ALTO) Incremental Updates Using
                        Server-Sent Events (SSE)
```

---
# **Abstract**

ALTO\(Application-Layer Traffic Optimization\) 프로토콜\(RFC 7285\)은 네트워크 정보 리소스라고 하는 네트워크 관련 정보를 클라이언트 애플리케이션에 제공하므로 클라이언트는 네트워크 리소스 활용 시 정보에 근거한 결정을 내릴 수 있습니다. 이 문서에서는 ALTO 서버가 ALTO 클라이언트에 업데이트를 푸시하여 두 가지 이점을 얻을 수 있는 메커니즘을 제시합니다. \(1\) 업데이트는 증분식일 수 있습니다. 즉, 정보 리소스의 작은 부분만 변경되는 경우 ALTO 서버는 변경 사항만 보낼 수 있습니다. \(2\) 업데이트는 즉시 이루어질 수 있습니다. 즉, ALTO 서버는 업데이트가 사용 가능한 즉시 보낼 수 있습니다.

---
# **Status of This Memo**

이것은 인터넷 표준 추적 문서입니다.

이 문서는 IETF\(Internet Engineering Task Force\)의 제품입니다. 이는 IETF 커뮤니티의 합의를 나타냅니다. 공개 검토를 받았으며 IESG\(Internet Engineering Steering Group\)의 출판 승인을 받았습니다. 인터넷 표준에 대한 자세한 내용은 RFC 7841의 섹션 2에서 확인할 수 있습니다.

이 문서의 현재 상태, 정오표 및 피드백 제공 방법에 대한 정보는 https://www.rfc-editor.org/info/rfc8895에서 얻을 수 있습니다.

---
# **Copyright Notice**

Copyright \(c\) 2020 IETF Trust 및 문서 작성자로 확인된 사람. 판권 소유.

이 문서는 이 문서의 발행일에 유효한 BCP 78 및 IETF 문서에 관한 IETF 트러스트의 법적 조항\(https://trustee.ietf.org/license-info\)의 적용을 받습니다. 이 문서와 관련된 귀하의 권리 및 제한 사항을 설명하므로 이 문서를 주의 깊게 검토하십시오. 이 문서에서 추출한 코드 구성 요소는 Trust Legal Provisions의 섹션 4.e에 설명된 대로 Simplified BSD License 텍스트를 포함해야 하며 Simplified BSD License에 설명된 대로 보증 없이 제공됩니다.

---
# **Table of Contents**

```text
   1.  Introduction
   2.  Terms
     2.1.  Requirements Language
   3.  Background
     3.1.  Incremental Encoding: JSON Merge Patch
       3.1.1.  JSON Merge Patch Encoding
       3.1.2.  JSON Merge Patch ALTO Messages
     3.2.  Incremental Encoding: JSON Patch
       3.2.1.  JSON Patch Encoding
       3.2.2.  JSON Patch ALTO Messages
     3.3.  Multiplexing and Server Push: HTTP/2
     3.4.  Server Push: Server-Sent Event
   4.  Overview of Approach and High-Level Protocol Message Flow
     4.1.  Update Stream Service Message Flow
     4.2.  Stream Control Service Message Flow
     4.3.  Service Announcement and Management Message Flow
   5.  Update Messages: Data Update and Control Update Messages
     5.1.  Generic ALTO Update Message Structure
     5.2.  ALTO Data Update Message
     5.3.  ALTO Control Update Message
   6.  Update Stream Service
     6.1.  Media Type
     6.2.  HTTP Method
     6.3.  Capabilities
     6.4.  Uses
     6.5.  Request: Accept Input Parameters
     6.6.  Response
     6.7.  Additional Requirements on Update Stream Service
       6.7.1.  Event Sequence Requirements
       6.7.2.  Cross-Stream Consistency Requirements
       6.7.3.  Multipart Update Requirements
     6.8.  Keep-Alive Messages
   7.  Stream Control Service
     7.1.  URI
     7.2.  Media Type
     7.3.  HTTP Method
     7.4.  IRD Capabilities & Uses
     7.5.  Request: Accept Input Parameters
     7.6.  Response
   8.  Examples
     8.1.  Example: IRD Announcing Update Stream Services
     8.2.  Example: Simple Network and Cost Map Updates
     8.3.  Example: Advanced Network and Cost Map Updates
     8.4.  Example: Endpoint Property Updates
     8.5.  Example: Multipart Message Updates
   9.  Operation and Processing Considerations
     9.1.  Considerations for Choosing Data Update Messages
     9.2.  Considerations for Client Processing Data Update Messages
     9.3.  Considerations for Updates to Filtered Cost Maps
     9.4.  Considerations for Updates to Ordinal Mode Costs
     9.5.  Considerations for SSE Text Formatting and Processing
   10. Security Considerations
     10.1.  Update Stream Server: Denial-of-Service Attacks
     10.2.  ALTO Client: Update Overloading or Instability
     10.3.  Stream Control: Spoofed Control Requests and Information
            Breakdown
   11. Requirements on Future ALTO Services to Use This Design
   12. IANA Considerations
     12.1.  application/alto-updatestreamparams+json Media Type
     12.2.  application/alto-updatestreamcontrol+json Media Type
   13. Appendix: Design Decision: Not Allowing Stream Restart
   14. References
     14.1.  Normative References
     14.2.  Informative References
   Acknowledgments
   Contributors
   Authors' Addresses
```

---
## **1.  Introduction**

ALTO\(Application-Layer Traffic Optimization\) 프로토콜 \[RFC7285\]은 네트워크 정보 리소스라고 하는 네트워크 관련 정보를 클라이언트 애플리케이션에 제공하여 클라이언트가 네트워크 리소스 활용 시 정보에 근거한 결정을 내릴 수 있도록 합니다. 예를 들어, ALTO 서버는 네트워크 및 비용 맵을 제공합니다. 여기서 네트워크 맵은 엔드포인트 세트를 각각 PID\(공급자 정의 식별자\)로 정의된 관리 가능한 수의 세트로 분할하고 비용 맵은 PID 간의 비용을 지정합니다. 네트워크 및 비용 맵이 주어지면 ALTO 클라이언트는 먼저 네트워크 맵을 사용하여 각 엔드포인트에 대한 PID를 가져온 다음 비용 맵을 사용하여 해당 PID 간의 비용을 가져오는 방식으로 엔드포인트 간의 비용을 얻을 수 있습니다. 이러한 비용은 클라이언트가 낮은 네트워크 비용으로 통신 엔드포인트를 선택하는 데 사용될 수 있습니다.

ALTO 프로토콜은 ALTO 클라이언트가 주기적으로 다시 가져오는 대신 네트워크 정보 리소스에 대한 업데이트를 얻을 수 있도록 허용하는 메커니즘을 정의하지 않고 ALTO 클라이언트 풀 모델만 정의합니다. 정보 리소스는 크지만 일부만 자주 변경될 수 있는 환경\(예: 비용 지도의 일부 항목\)에서는 전체 다시 가져오기가 비효율적일 수 있습니다.

이 문서에서는 ALTO 서버가 증분 업데이트를 ALTO 클라이언트에 푸시할 수 있도록 하는 메커니즘을 제시합니다. 서버 푸시 및 증분 업데이트를 통합하면 두 가지 이점이 있습니다. \(1\) 정보 리소스의 작은 부분만 변경되는 경우 ALTO 서버가 변경 사항만 보낼 수 있다는 점에서 업데이트가 작을 수 있고 \(2\) 업데이트가 즉각적일 수 있습니다. ALTO 서버는 업데이트가 제공되는 즉시 보낼 수 있습니다.

주로 GET 모드 네트워크 및 비용 맵에 대한 업데이트를 제공하기 위한 것이지만, 이 문서에 정의된 메커니즘은 ALTO 엔드포인트 속성 및 엔드포인트 비용 서비스와 같은 POST 모드 ALTO 서비스에 대한 업데이트도 제공할 수 있습니다. 메커니즘은 향후 확장에 의해 정의될 새로운 ALTO 서비스도 지원할 수 있지만 향후 서비스는 섹션 11에 지정된 요구 사항을 충족해야 합니다.

이 문서의 나머지 부분은 다음과 같이 구성됩니다. 섹션 3에서는 이 설계에 사용된 기본 기술에 대한 배경 정보를 제공합니다. \(1\) 증분 업데이트를 허용하는 JSON 병합 패치 및 JSON 패치와 \(2\) 서버 푸시를 허용하는 SSE\(서버 전송 이벤트\) \[SSE\]. 배경과 함께 섹션 4에서는 설계에 대한 비표준적인 개요를 제공합니다. 섹션 5에서는 업데이트 스트림의 개별 메시지를 정의합니다. 섹션 6에서는 업데이트 스트림 서비스를 정의합니다. 섹션 7에서는 스트림 제어 서비스를 정의합니다. 섹션 8에서는 두 가지 유형의 서비스를 설명하는 몇 가지 예를 제공합니다. 섹션 9에서는 ALTO 서버와 클라이언트 모두의 작동 및 처리 고려 사항을 설명합니다. 섹션 13에서는 지원되지 않는 설계 기능에 대해 설명합니다. 섹션 10에서는 보안 문제에 대해 논의합니다. 섹션 11과 12에서는 각각 SSE 및 IANA 고려 사항을 사용하기 위한 향후 ALTO 서비스의 요구 사항을 검토합니다.

---
## **2.  Terms**

\[RFC7285\]에 정의된 용어 외에도 이 문서에서는 다음과 같이 정의된 추가 용어도 사용합니다.

업데이트 스트림:

- 서버가 \[SSE\]를 사용하여 일련의 업데이트 메시지를 클라이언트에 푸시할 수 있도록 ALTO 클라이언트와 ALTO 서버 간의 HTTP/1.x와 호환되는 안정적인 순서 연결입니다.

스트림 서버 업데이트:

- 이 문서에서는 업데이트 스트림을 제공하는 ALTO 서버를 ALTO 업데이트 스트림 서버, 줄여서 업데이트 스트림 서버라고 지칭한다. 본 문서에서 언급하는 ALTO 서버는 다양한 서비스를 제공하는 일반 서버를 의미하므로 참고하시기 바랍니다. 업데이트 스트림 서버 또는 스트림 제어 서버일 수 있습니다\(아래 참조\). ALTO IRD\(정보 리소스 디렉터리\)를 제공하는 서버일 수도 있습니다.

업데이트 메시지:

- 데이터 업데이트 메시지 또는 제어 업데이트 메시지인 메시지.

데이터 업데이트 메시지:

- 단일 ALTO 정보 자원에 대한 업데이트 메시지로, 자원이 변경될 때 업데이트 스트림 서버에서 ALTO 클라이언트로 전송됩니다. 데이터 업데이트 메시지는 전체 교체 메시지이거나 증분 변경 메시지일 수 있습니다. 전체 교체는 전체 교체 메시지의 약어이고, 증분 변경은 증분 변경 메시지의 약어입니다.

전체 교체:

- 리소스의 내용을 원래의 ALTO 인코딩으로 인코딩한 리소스에 대한 데이터 업데이트 메시지입니다.

증분 변경:

- 신규 콘텐츠와 이전 버전의 차이점만을 명시하는 데이터 업데이트 메시지입니다. 이 문서의 JSON 병합 패치 또는 JSON 패치를 사용하여 증분 변경 사항을 인코딩할 수 있습니다.

스트림 제어 서비스:

- 업데이트 스트림의 ALTO 클라이언트가 업데이트 스트림에서 업데이트 메시지를 수신하는 리소스를 추가하거나 제거할 때 ALTO 서버에 스트림 제어 요청을 보내는 데 사용할 수 있도록 HTTP URI를 제공하는 서비스입니다. ALTO 서버는 각 업데이트 스트림 인스턴스에 대해 새 스트림 제어 리소스를 생성하고 여기에 고유한 URI를 할당한 다음 스트림의 첫 번째 이벤트로 URI를 클라이언트에 보냅니다. \(ALTO의 스트림 제어 서비스는 비슷한 이름의 스트림 제어 전송 프로토콜 \[RFC4960\]과 연관되어 있지 않습니다.\)

스트림 제어:

- 스트림 제어 서비스의 약어입니다.

스트림 제어 서버:

- 스트림 제어 서비스를 제공하는 ALTO 서버입니다.

하위 스트림 ID:

- ALTO 클라이언트는 업데이트 스트림에서 업데이트 메시지를 수신하는 리소스 추가를 요청할 때 고유한 substream-id를 할당할 수 있습니다. 서버는 해당 리소스에 대한 각 업데이트 이벤트에 하위 스트림 ID를 넣습니다. substream-id를 사용하면 클라이언트가 하나의 업데이트 스트림을 사용하여 동일한 리소스\(예: ALTO IRD에서 동일한 리소스 ID 사용\)에 대한 여러 요청\(예: 입력 매개변수가 서로 다른 POST 모드 리소스\)에 대한 업데이트를 수신할 수 있습니다. .

데이터 ID:

- 업데이트할 ALTO 데이터\(객체\)를 식별하기 위한 \[SSE\]의 "이벤트" 필드의 하위 필드입니다. 멀티파트 응답을 반환하는 ALTO 리소스의 경우 데이터\(객체\)를 식별하는 data-id는 멀티파트 응답에 있는 객체의 Content-ID 외에 서브스트림 ID입니다. 단일 부분 응답의 data-id는 단지 substream-id입니다.

제어 업데이트 메시지:

- 업데이트 스트림 서버가 ALTO 클라이언트에게 업데이트 스트림 관련 제어 정보를 알리기 위한 업데이트 메시지. 제어 업데이트 메시지는 서버 과부하와 같은 서버 내부 이벤트에 의해 트리거될 수 있으므로 업데이트 스트림 서버는 더 이상 정보 리소스에 대한 업데이트를 보내지 않거나 클라이언트가 스트림 제어 서비스를 통해 요청을 보낸 결과로 발생합니다. . 업데이트 스트림의 첫 번째 메시지는 ALTO 클라이언트에 제어 URI를 제공하는 제어 업데이트 메시지입니다. ALTO 클라이언트는 URI를 사용하여 스트림 제어 서버에 스트림 제어 요청을 보낼 수 있습니다.

---
### **2.1.  Requirements Language**

키워드 "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY" 및 "OPTIONAL" "는 BCP 14 \[RFC2119\] \[RFC8174\]에 설명된 대로 여기에 표시된 것처럼 모두 대문자로 표시되는 경우에만 해석됩니다.\(MUST NOT\)

---
## **3.  Background**

설계에는 증분 변경 사항 인코딩과 서버 푸시라는 두 가지 기본 기술이 필요합니다. 증분 변경의 경우 기존 기술에는 JSON 병합 패치와 JSON 패치가 포함됩니다. 이 디자인은 두 가지를 모두 사용합니다. 서버 푸시의 경우 기존 기술에는 HTTP/2 및 \[SSE\]가 포함됩니다. 이 디자인은 HTTP/2의 일부 디자인 기능을 채택하지만 \[SSE\]를 기본 서버 푸시 디자인으로 사용합니다. 이 섹션의 나머지 부분에서는 JSON 병합 패치, JSON 패치, HTTP/2 및 \[SSE\]에 대한 비표준 요약을 제공합니다.

---
### **3.1.  Incremental Encoding: JSON Merge Patch**

항상 완전한 데이터를 보내는 것을 방지하려면 서버에 증분 변경 사항을 인코딩하는 메커니즘이 필요하며 JSON 병합 패치가 하나의 메커니즘입니다. \[RFC7396\]은 HTTP PATCH 메서드 \[RFC5789\]에서 사용할 증분 변경 사항\(JSON 병합 패치 개체라고 함\)의 인코딩을 정의합니다. \[RFC7396\]에서 이 문서는 JSON 병합 패치 객체 인코딩만 채택하고 업데이트가 HTTP 메서드 대신 이벤트로 전송되므로 HTTP PATCH 메서드를 사용하지 않습니다. 또한 업데이트는 서버에서 클라이언트로 이루어지며 PATCH 의미 체계는 클라이언트에서 서버로 더 많이 적용됩니다. 다음은 JSON 병합 패치 개체에 대한 비표준 요약입니다. 규범적 정의는 \[RFC7396\]을 참조하세요.

---
#### **3.1.1.  JSON Merge Patch Encoding**

비공식적으로 JSON 병합 패치 메시지는 재귀 병합 패치 알고리즘을 사용하여 하나의 JSON 값을 다른 JSON 값으로 변환하는 방법을 정의하는 JSON 병합 패치 개체\(\[RFC7396\]에서 패치라고 함\)로 구성됩니다. 특히 패치는 두 개의 JSON 값\(첫 번째 값은 원본이고 두 번째 값은 업데이트됨\)을 중첩된 JSON 개체\(이름/값 쌍의 사전\) 트리로 처리하여 계산됩니다. 여기서 잎은 값\(예: JSON 배열, 문자열 및 숫자\), JSON 개체가 아닌 각 리프의 경로는 해당 리프로 이어지는 키 시퀀스입니다. 두 번째 트리가 경로의 리프에 대해 다른 값을 가지거나 새 리프를 추가하면 패치는 해당 경로에 새 값을 갖는 리프를 갖습니다. 첫 번째 트리의 리프가 두 번째 트리에 없으면 JSON 병합 패치 트리에는 JSON "null" 값이 있는 리프가 있습니다. 따라서 패치에서 이름/값 쌍의 값인 null은 원래 JSON 값에서 "name"이 있는 요소를 삭제합니다. 패치에는 두 버전 모두에서 동일한 값을 갖는 리프에 대한 항목이 없습니다. 주어진 패치를 적용하는 방법에 대한 공식 사양은 \[RFC7396\] 섹션 2의 시작 부분에 있는 MergePatch 의사코드를 참조하세요. 결과적으로 모든 리프 값이 단순 스칼라인 경우 JSON 병합 패치는 증분 변경 사항을 매우 효율적으로 표현합니다. 리프 값이 배열인 경우에는 항목이 하나만 변경되더라도 JSON 병합 패치가 배열 전체를 대체하므로 효율성이 떨어집니다.

---
#### **3.1.2.  JSON Merge Patch ALTO Messages**

JSON 병합 패치의 예와 ALTO에 JSON 병합 패치를 적용하는 타당성을 보여주기 위해 아래 섹션에서는 두 가지 주요 ALTO 메시지에 JSON 병합 패치를 적용하는 방법을 보여줍니다.

---
##### **3.1.2.1.  JSON Merge Patch Network Map Messages**

\[RFC7285\]의 섹션 11.2.1.6은 ALTO 네트워크 맵 메시지의 형식을 정의합니다. 초기 네트워크 맵을 보내는 간단한 ALTO 메시지 예를 가정해 보겠습니다.

```text
     {
       "meta" : {
         "vtag": {
           "resource-id" : "my-network-map",
           "tag" : "da65eca2eb7a10ce8b059740b0b2e3f8eb1d4785"
         }
       },
       "network-map" : {
         "PID1" : {
           "ipv4" : [ "192.0.2.0/24", "198.51.100.0/25" ]
         },
         "PID2" : {
           "ipv4" : [ "198.51.100.128/25" ]
         },
         "PID3" : {
           "ipv4" : [ "0.0.0.0/0" ],
           "ipv6" : [ "::/0" ]
         }
       }
     }
```

\(1\) ipv4 접두사 "203.0.113.0/25" 및 ipv6 접두사 "2001:db8:8000::/33"을 "PID1"에 추가하고, \(2\) "PID2를 삭제하는 다음 JSON 병합 패치 업데이트 메시지를 고려하세요. ", \(3\) 네트워크 맵에 새 "태그"를 할당합니다.

```text
     {
       "meta" : {
         "vtag" : {
           "tag" : "a10ce8b059740b0b2e3f8eb1d4785acd42231bfe"
         }
       },
       "network-map": {
         "PID1" : {
           "ipv4" : [ "192.0.2.0/24", "198.51.100.0/25",
                      "203.0.113.0/25" ],
           "ipv6" : [ "2001:db8:8000::/33" ]
         },
         "PID2" : null
       }
     }
```

JSON 병합 패치 업데이트를 초기 네트워크 맵에 적용하는 것은 다음 ALTO 네트워크 맵과 동일합니다.

```text
     {
       "meta" : {
         "vtag": {
           "resource-id" : "my-network-map",
           "tag" : "a10ce8b059740b0b2e3f8eb1d4785acd42231bfe"
         }
       },
       "network-map" : {
         "PID1" : {
           "ipv4" : [ "192.0.2.0/24", "198.51.100.0/25",
                      "203.0.113.0/25" ],
           "ipv6" : [ "2001:db8:8000::/33" ]
         },
         "PID3" : {
           "ipv4" : [ "0.0.0.0/0" ],
           "ipv6" : [ "::/0" ]
         }
       }
     }
```

---
##### **3.1.2.2.  JSON Merge Patch Cost Map Messages**

\[RFC7285\]의 섹션 11.2.3.6은 ALTO 비용 맵 메시지의 형식을 정의합니다. 초기 비용 맵에 대한 간단한 ALTO 메시지 예를 가정해 보겠습니다.

```text
     {
       "meta" : {
         "dependent-vtags" : [
           {"resource-id": "my-network-map",
            "tag": "a10ce8b059740b0b2e3f8eb1d4785acd42231bfe"
           }
         ],
         "cost-type" : {
           "cost-mode"  : "numerical",
           "cost-metric": "routingcost"
         },
         "vtag": {
           "resource-id" : "my-cost-map",
           "tag" : "3ee2cb7e8d63d9fab71b9b34cbf764436315542e"
         }
       },
       "cost-map" : {
         "PID1": { "PID1": 1,  "PID2": 5,  "PID3": 10 },
         "PID2": { "PID1": 5,  "PID2": 1,  "PID3": 15 },
         "PID3": { "PID1": 20, "PID2": 15  }
       }
     }
```

다음 JSON 병합 패치 메시지는 \(1\) 비용 맵의 "태그" 필드가 업데이트되고, \(2\) PID1-\>PID2의 비용이 5 대신 9가 되고, \(3\) 비용이 9가 되도록 비용 맵 예시를 업데이트합니다. PID3-\>PID1은 더 이상 사용할 수 없으며, \(4\) PID3-\>PID3의 비용은 1로 정의됩니다.

```text
     {
       "meta" : {
         "vtag": {
           "tag": "c0ce023b8678a7b9ec00324673b98e54656d1f6d"
         }
       }
       "cost-map" : {
         "PID1" : { "PID2" : 9 },
         "PID3" : { "PID1" : null, "PID3" : 1 }
       }
     }
```

따라서 JSON 병합 패치를 초기 비용 맵에 적용하는 것은 다음 ALTO 비용 맵과 동일합니다.

```text
     {
       "meta" : {
         "dependent-vtags" : [
           {"resource-id": "my-network-map",
            "tag": "a10ce8b059740b0b2e3f8eb1d4785acd42231bfe"
           }
         ],
         "cost-type" : {
           "cost-mode"  : "numerical",
           "cost-metric": "routingcost"
         },
         "vtag": {
           "resource-id": "my-cost-map",
           "tag": "c0ce023b8678a7b9ec00324673b98e54656d1f6d"
         }
       },
       "cost-map" : {
         "PID1": { "PID1": 1,  "PID2": 9,  "PID3": 10 },
         "PID2": { "PID1": 5,  "PID2": 1,  "PID3": 15 },
         "PID3": {             "PID2": 15, "PID3": 1  }
       }
     }
```

---
### **3.2.  Incremental Encoding: JSON Patch**
---
#### **3.2.1.  JSON Patch Encoding**

JSON 병합 패치의 한 가지 문제는 배열 변경 사항을 잘 처리하지 못한다는 것입니다. 특히 JSON 병합 패치는 배열을 단일 개체로 간주하므로 배열 전체만 교체할 수 있습니다. 큰 배열에서 요소를 삭제하는 등 배열에 작은 변경을 적용하는 경우 전체 배열 교체는 비효율적입니다. 섹션 3.1.2.1의 예를 고려하십시오. PID1에 대한 ipv4 배열에 새 항목을 추가하려면 서버는 완전히 새로운 배열을 보내야 합니다. 또 다른 문제는 JSON 병합 패치 처리 알고리즘\(섹션 3.1.1의 MergePatch\)이 null을 제거 명령으로 해석하기 때문에 JSON 병합 패치가 값을 null로 변경할 수 없다는 것입니다. 반면 일부 ALTO 리소스는 null 값을 가질 수 있으며 업데이트에서 새 값을 null로 변경하려고 할 수도 있습니다.

JSON 패치 \[RFC6902\]는 이전 문제를 해결할 수 있습니다. JSON 객체를 수정하기 위한 연산자 세트를 정의합니다. 규범적 정의는 \[RFC6902\]를 참조하세요.

---
#### **3.2.2.  JSON Patch ALTO Messages**

JSON 패치의 예와 JSON 패치와 JSON 병합 패치의 차이점을 보여주기 위해 아래 섹션에서는 섹션 3.1.2에 표시된 동일한 업데이트에 JSON 패치를 적용하는 방법을 보여줍니다.

---
##### **3.2.2.1.  JSON Patch Network Map Messages**

먼저 네트워크 맵에 대해 섹션 3.1.2.1과 동일한 업데이트를 고려하십시오. 다음은 JSON 패치를 사용한 인코딩입니다.

```text
     [
       {
         "op": "replace",
         "path": "/meta/vtag/tag",
         "value": "a10ce8b059740b0b2e3f8eb1d4785acd42231bfe"
       },
       {
         "op": "add",
         "path": "/network-map/PID1/ipv4/2",
         "value": "203.0.113.0/25"
       }
       {
         "op": "add",
         "path": "/network-map/PID1/ipv6",
         "value": ["2001:db8:8000::/33"]
       },
       {
         "op": "remove",
         "path": "/network-map/PID2"
       }
     ]
```

---
##### **3.2.2.2.  JSON Patch Cost Map Messages**

JSON 병합 패치와 비교하여 JSON 패치는 비용 맵 업데이트를 효율적으로 인코딩하지 않습니다. 섹션 3.1.2.2에 표시된 비용 맵 업데이트를 고려하면 JSON 패치를 사용하는 인코딩은 다음과 같습니다.

```text
     [
       {
         "op": "replace",
         "path": "/meta/vtag/tag",
         "value": "c0ce023b8678a7b9ec00324673b98e54656d1f6d"
       },
       {
         "op": "replace",
         "path": "/cost-map/PID1/PID2",
         "value": 9
       },
       {
         "op": "remove",
         "path": "/cost-map/PID3/PID1"
       },
       {
         "op": "replace",
         "path": "/cost-map/PID3/PID3",
         "value": 1
       }
     ]
```

---
### **3.3.  Multiplexing and Server Push: HTTP/2**

HTTP/2 \[RFC7540\]은 멀티플렉싱과 서버 푸시라는 두 가지 관련 기능을 제공합니다. 특히 HTTP/2를 사용하면 클라이언트와 서버가 단일 TCP 연결을 통해 여러 HTTP 요청과 응답을 다중화할 수 있습니다. HTTP/2 메시지에 요청과 응답을 표시하여 요청과 응답을 블록\(프레임\) 단위로 인터리브할 수 있으므로 HTTP/1.1에서 발생하는 헤드 오브 라인 차단 문제를 피할 수 있습니다. 동일한 목표를 달성하기 위해 이 디자인에서는 클라이언트가 여러 리소스에 대한 업데이트를 받을 수 있도록 substream-id를 도입합니다. HTTP/2는 또한 서버가 비동기 업데이트를 보낼 수 있도록 서버 푸시 기능을 제공합니다.

HTTP/2의 두 가지 특징에도 불구하고 이 디자인은 HTTP/1.x의 단순성을 위해 HTTP/1.x와 호환되는 디자인을 선택합니다. HTTP/2 기반 디자인은 더 복잡한 HTTP/2 클라이언트 라이브러리를 사용하여 구현해야 할 가능성이 높습니다. 이러한 경우 업데이트를 위해 서버 푸시를 사용하는 한 가지 접근 방식은 업데이트 스트림 서버가 각 데이터 업데이트 메시지를 별도의 서버 푸시 항목으로 보내고 클라이언트가 해당 업데이트가 도착할 때 적용하도록 하는 것입니다. HTTP/2 클라이언트 라이브러리는 서버가 리소스를 푸시할 때 클라이언트 애플리케이션에 반드시 알릴 필요는 없습니다. 대신, 라이브러리는 푸시된 리소스를 캐시하고 클라이언트가 해당 URI를 명시적으로 요청할 때만 클라이언트에 전달할 수 있습니다. 또한 HTTP/2 기반 설계에서는 클라이언트와 서버 간의 프록시 관련 문제가 발생할 가능성이 더 높습니다. 서버 푸시는 선택 사항이고 클라이언트와 서버 간의 모든 프록시에 의해 비활성화될 수 있다는 점입니다. 이는 서버 푸시의 의도된 사용에는 문제가 되지 않습니다. 결국 클라이언트는 해당 리소스를 요청하게 되므로 서버 푸시를 비활성화하면 지연만 추가됩니다. 그러나 이는 클라이언트가 요청할지 모르는 리소스에는 서버 푸시가 적합하지 않음을 의미합니다.

따라서 이 설계에서는 HTTP/2 기반 설계를 향후 작업으로 남기고 HTTP/1.x 및 \[SSE\]에 대한 ALTO 업데이트에 중점을 둡니다.

---
### **3.4.  Server Push: Server-Sent Event**

SSE\(서버 전송 이벤트\)는 HTTP/1.1에서 작동할 수 있는 기술입니다. 다음은 SSE의 비표준 요약입니다. 규범적인 정의는 \[SSE\]를 참조하세요.

SSE를 사용하면 서버가 "서버 푸시"를 통해 클라이언트에 새 데이터를 보낼 수 있습니다. 클라이언트는 서버에 대한 HTTP \[RFC7230\] \[RFC7231\] 연결을 설정하고 연결을 열린 상태로 유지합니다. 서버는 지속적으로 메시지를 보냅니다. 각 메시지에는 하나 이상의 줄이 있습니다. 여기서 줄은 바로 뒤에 새 줄이 오는 캐리지 리턴, 새 줄이 바로 오지 않는 캐리지 리턴 또는 캐리지 리턴 바로 앞에 오지 않는 새 줄로 끝납니다. 메시지는 빈 줄\(행에 두 개의 줄 종결자\)로 종료됩니다.

메시지의 각 줄은 "필드 이름: 문자열 값" 형식입니다. 필드 이름이 비어 있는 줄\(즉, 콜론으로 시작하는 줄\)은 콜론이 없는 줄과 마찬가지로 무시됩니다. 프로토콜은 event, id 및 data라는 세 가지 필드 이름을 정의합니다. 메시지에 "데이터" 줄이 두 개 이상 있는 경우 데이터 필드의 값은 해당 줄의 값을 연결한 것입니다. 메시지당 하나의 "event" 및 "id" 줄만 있을 수 있습니다. "데이터" 필드는 필수입니다. 나머지는 선택 사항입니다.

그림 1은 클라이언트 요청으로 시작하는 샘플 SSE 스트림입니다. 서버는 세 가지 이벤트를 보낸 다음 스트림을 닫습니다.

```text
     (Client request)
     GET /stream HTTP/1.1
     Host: example.com
     Accept: text/event-stream

     (Server response)
     HTTP/1.1 200 OK
     Connection: keep-alive
     Content-Type: text/event-stream

     event: start
     id: 1
     data: hello there

     event: middle
     id: 2
     data: let's chat some more ...
     data: and more and more and ...

     event: end
     id: 3
     data: goodbye

                       Figure 1: A Sample SSE Stream
```

---
## **4.  Overview of Approach and High-Level Protocol Message Flow**

이전 배경을 바탕으로 이 섹션에서는 이제 이 문서의 이후 섹션에서 정의할 업데이트 메커니즘과 메시지 흐름에 대한 비표준적인 개요를 제공합니다. 그림 2는 주요 구성 요소와 전체 메시지 흐름을 보여줍니다.

```text
    -------------------------------------------------------------------
   |                                                                   |
   |          +-------+         +-------+ 1. init request   +------+   |
   |          |       |         |       | <--------------   |      |   |
   |          |       |         |       | -------------->   |      |   |
   | 3.add/   |       |         |       | 1'. control URI   |      |   |
   | remove   |       |         |       |                   |      |   |
   | resource |Stream |         |Update |                   |      |   |
     -------->|Control| private |Stream | 2a. data update   |Client| --
              |Server |<------->|Server | messages          |      |
     -------- |       |         |       | --------------->  |      | <-
   | response |       |         |       | --------------->  |      |   |
   |          |       |         |       | 2b. control update|      |   |
   |          +-------+         +-------+ messages          +------+   |
   |                                                                   |
    -------------------------------------------------------------------

              Figure 2: ALTO SSE Architecture and Message Flow
```

---
### **4.1.  Update Stream Service Message Flow**

이 문서에 정의된 업데이트 메커니즘의 빌딩 블록은 업데이트 스트림 서비스\(섹션 6에 정의됨\)이며, 여기서 각 업데이트 스트림 서비스는 업데이트 스트림을 제공하는 POST 모드 서비스입니다.

"\*\* ... \*\*" 형식의 행은 이 섹션과 다음 섹션의 메시지 흐름을 설명하는 데 사용됩니다.

\*\* 초기 요청: 클라이언트 -\> 업데이트 서버 \*\*:

- ALTO 클라이언트가 업데이트 스트림 서비스를 요청하면 ALTO 클라이언트는 업데이트 스트림 서버에 대한 지속적인 연결을 설정하고 초기 업데이트 스트림 요청\(섹션 6.5에 정의됨\)을 제출하여 업데이트 스트림을 생성합니다. 업데이트 스트림을 생성하는 이 초기 요청은 그림 2에서 "1. init request"로 표시되어 있습니다.

- 업데이트 스트림은 ALTO 네트워크 및 비용 맵과 같은 GET 모드 리소스와 ALTO 엔드포인트 속성 서비스와 같은 POST 모드 리소스 모두에 대한 업데이트를 제공할 수 있습니다. 또한 업데이트 스트림이 너무 많이 생성되는 것을 방지하기 위해 이 설계를 통해 ALTO 클라이언트는 하나의 업데이트 스트림을 사용하여 여러 요청에 대한 업데이트를 수신할 수 있습니다. 특히 클라이언트는 여러 리소스에 대한 업데이트를 단일 스트림으로 통합할 수 있을 뿐만 아니라 POST 모드 리소스에 대해 서로 다른 매개변수를 사용하여 동일한 리소스에 대한 업데이트 수신을 요청할 수 있습니다. 각 요청에 대한 업데이트를 서브스트림이라고 부르므로 업데이트 서버는 업데이트를 보낼 때 서브스트림을 나타내는 식별자가 필요합니다. 이 목표를 달성하기 위해 클라이언트는 업데이트 스트림의 리소스에 대한 업데이트를 요청할 때 고유한 substream-id를 할당하고 서버는 각 업데이트에 substream-id를 넣습니다.

\*\* 데이터 업데이트: 업데이트 서버 -\> 클라이언트 \*\*:

- 업데이트 스트림의 목적은 리소스 세트가 ALTO 클라이언트의 요청에 의해 지정되는 리소스 세트에 대한 데이터 값 변경 사항을 ALTO 클라이언트에 지속적으로 푸시하는 것입니다. 이 문서에서는 데이터 업데이트 메시지\(섹션 5.2에 정의됨\)와 같은 데이터 값 변경 사항을 보내는 메시지를 참조합니다. 업데이트 스트림은 하나 이상의 요청을 업데이트할 수 있지만 각 데이터 업데이트 메시지는 하나의 요청만 업데이트하고 \[SSE\]에 정의된 대로 SSE\(서버 전송 이벤트\)로 전송됩니다. 데이터 업데이트 메시지는 전체 교체 또는 증분 변경으로 인코딩됩니다. 전체 교체는 ALTO 프로토콜에 정의된 JSON 메시지 형식을 사용합니다. 증분 변경에는 여러 인코딩이 있을 수 있습니다. 현재 설계는 리소스 변경 사항을 설명하기 위해 JSON 병합 패치 \[RFC7396\] 또는 JSON 패치 \[RFC6902\]를 사용하여 증분 변경을 지원합니다. 향후 문서에서는 점진적인 변경을 위한 추가 메커니즘을 정의할 수 있습니다. 업데이트 스트림 서버는 데이터 업데이트 메시지를 보낼 시기와 전체 교체 또는 증분 변경 사항을 보낼지 여부를 결정합니다. 이러한 결정은 리소스마다, 업데이트마다 다를 수 있습니다. 전송은 HTTP/1.x와 호환되는 설계이므로 데이터 업데이트 메시지는 안정적이고 순서대로 전달되며 메시지의 무손실 순차적 전달을 통해 서버는 클라이언트의 정확한 상태를 파악하여 올바른 증분 업데이트를 계산할 수 있습니다. . 그림 2는 전체 메시지 흐름에서 데이터 업데이트 메시지\("2a. 데이터 업데이트 메시지"로 라벨 지정\)의 예를 보여줍니다.

\*\* 업데이트 제어: 업데이트 서버 -\> 클라이언트 \*\*:

- 업데이트 스트림은 오랫동안 실행될 수 있으므로 업데이트 스트림의 수명 동안 업데이트 스트림 서버 측에서 상태 변경이 있을 수 있습니다. 예를 들어 업데이트 스트림 서버에 오류가 발생하거나 유지 관리를 위해 종료해야 할 수 있습니다. 강력하고 유연한 프로토콜 설계를 지원하기 위해 이 문서에서는 업데이트 스트림 서버가 ALTO 클라이언트에 데이터 업데이트 메시지 외에도 제어 업데이트 메시지\(섹션 5.3에 정의됨\)를 보낼 수 있도록 허용합니다. 그림 2는 데이터 업데이트와 제어 업데이트가 모두 서버에서 클라이언트로 전송될 수 있음을 보여줍니다\("2b. 제어 업데이트 메시지"라고 표시됨\).

---
### **4.2.  Stream Control Service Message Flow**

\*\* 스트림 제어: 클라이언트 -\> 스트림 제어 서버 \*\*:

- 유연한 설계에서는 업데이트 스트림 서버 측에서 트리거된 제어 변경 외에도 ALTO 클라이언트가 특히 업데이트를 수신하는 ALTO 리소스를 추가하거나 제거하여 제어 변경을 시작할 수도 있습니다. ALTO 클라이언트는 스트림 제어 서비스\(섹션 7에 정의됨\)를 사용하여 이러한 변경을 시작합니다. 클라이언트가 제어 요청을 보내기 위해 동일한 HTTP 연결로 사용하는 설계를 사용할 수도 있지만 이를 위해서는 HTTP 파이프라인과 같은 더 강력한 서버 지원이 필요합니다. 유연성을 높이기 위해 이 문서에서는 스트림 제어 서비스를 소개합니다. 특히 업데이트 스트림의 업데이트 스트림 서버는 첫 번째 메시지를 사용하여 스트림 제어 서비스의 URI\(그림 2에서 "1': 제어 URI"로 표시\)를 제공합니다.

- 그런 다음 ALTO 클라이언트는 URI를 사용하여 URI에 지정된 스트림 제어 서버에 업데이트 스트림 서버에 \(1\) 추가 리소스에 대한 데이터 업데이트 메시지 전송, \(2\) 이전에 요청한 리소스에 대한 데이터 업데이트 메시지 전송 중지, 또는 \(3\) 업데이트 스트림을 완전히 중지하고 닫습니다.

---
### **4.3.  Service Announcement and Management Message Flow**

\*\* 서비스 공지사항: IRD 서버 -\> 클라이언트 \*\*:

- 업데이트 서버는 원하는 수의 업데이트 스트림 서비스를 제공할 수 있으며, 각 업데이트 스트림은 ALTO 서버 리소스의 특정 하위 집합에 대한 업데이트를 제공할 수 있습니다. ALTO 서버의 IRD\(정보 리소스 디렉터리\)는 업데이트 스트림 서비스를 정의하고 각 업데이트 스트림 서비스가 업데이트를 제공하는 리소스 집합을 선언합니다. ALTO 서버는 각 업데이트 스트림 서비스에 대한 리소스 세트를 선택합니다. 리소스가 하나 이상의 다른 리소스\(\[RFC7285\]에 정의된 "uses" 속성으로 표시됨\)에 의존하는 경우 이러한 다른 리소스도 해당 업데이트 스트림의 일부가 되어야 하는 것이 좋습니다. 따라서 비용 맵의 업데이트 스트림은 해당 비용 맵이 의존하는 네트워크 맵에 대한 업데이트도 제공해야 합니다.

\*\* 서비스 관리\(서버\) \*\*:

- ALTO 클라이언트는 동시에 원하는 만큼의 업데이트 스트림을 요청할 수 있습니다. 각 업데이트 스트림은 업데이트 스트림 서버의 리소스를 소비하기 때문에 업데이트 스트림 서버는 클라이언트 권한 부여 및/또는 인증을 요구하거나, 열린 업데이트 스트림 수를 제한하거나, 비활성 스트림을 닫거나, ALTO 클라이언트를 다른 업데이트 스트림 서버로 리디렉션할 수 있습니다.

---
## **5.  Update Messages: Data Update and Control Update Messages**

이 섹션에서는 서버에서 클라이언트로 전송되는 업데이트 메시지의 형식을 정의합니다. 먼저 업데이트 메시지의 일반적인 구조를 정의합니다\(섹션 5.1\). 그런 다음 데이터 업데이트 메시지\(섹션 5.2\)와 제어 업데이트 메시지\(섹션 5.3\)의 세부 사항을 정의합니다. 이러한 메시지는 다음 두 섹션에서 업데이트 스트림 서비스\(섹션 6\)와 스트림 제어 서비스\(섹션 7\)를 정의하는 데 사용됩니다.

---
### **5.1.  Generic ALTO Update Message Structure**

서버에서 클라이언트로 전달되는 데이터 업데이트 메시지와 제어 업데이트 메시지 모두 기본 구조는 동일합니다. 각 메시지에는 데이터 정보를 제공하는 데이터 필드\(일반적으로 JSON 개체\)와 데이터 필드 앞에 이벤트 필드가 포함되어 데이터 필드의 인코딩을 나타내는 미디어 유형을 지정합니다.

데이터 업데이트 메시지에는 해당 업데이트 메시지가 적용되는 ALTO 데이터\(객체\)를 식별하기 위한 추가 정보가 필요합니다. 일반적으로 이 문서에서는 data-id를 사용하여 업데이트할 ALTO 데이터\(객체\)를 식별합니다. 아래를 참조하세요.

따라서 ALTO 업데이트 메시지의 이벤트 필드에는 두 개의 하위 필드\(media-type 및 data-id\)가 포함될 수 있으며, 두 하위 필드는 쉼표\(',', U+002C\)로 구분됩니다.

```text
         media-type [ ',' data-id ]
```

\[RFC6838\]의 섹션 4.2에 따르면 미디어 유형 이름에는 쉼표 문자가 허용되지 않으므로 두 하위 필드를 디코딩할 때 모호성이 없습니다.

업데이트 메시지는 SSE "id" 필드를 사용하지 않습니다.

---
### **5.2.  ALTO Data Update Message**

```text
   A data update message is sent when a monitored resource changes.  As
   discussed in the preceding section, the event field of a data update
   message includes two subfields: 'media-type' and 'data-id'.
```

'미디어 유형' 하위 필드는 데이터 업데이트가 식별된 데이터의 완전한 사양인지 아니면 증분 패치\(예: JSON 병합 패치 또는 JSON 패치\)인지에 따라 달라지며, 가능한 경우 데이터의 마지막 버전의 변경 사항을 설명합니다. . 이 문서에서는 이를 각각 전체 교체 및 증분 변경이라고 합니다. 전체 교체의 인코딩은 정의 문서\(예: \[RFC7285\]의 네트워크 및 비용 맵 메시지\)에 의해 정의되며 해당 문서에 정의된 미디어 유형을 사용합니다. JSON 병합 패치의 인코딩은 \[RFC7396\]에 정의되어 있으며 미디어 유형은 "application/merge-patch+json"입니다. JSON 패치의 인코딩은 \[RFC6902\]에 정의되어 있으며 미디어 유형은 "application/json-patch+json"입니다.

'data-id' 하위 필드는 데이터 업데이트 메시지가 적용되는 ALTO 데이터를 식별합니다.

```text
   First, consider the case that the resource contains only a single
   JSON object.  For example, since an ALTO client can request data
   updates for both a cost map resource (object) and its dependent
   network map resource (object) in the same update stream, to
   distinguish the updates, the client assigns a substream-id for each
   resource receiving data updates.  Substream-ids MUST be unique within
   an update stream but need not be globally unique.  A substream-id is
   encoded as a JSON string with the same format as that of the type
   ResourceID (Section 10.2 of [RFC7285]).  The type SubstreamID is used
   in this document to indicate a string of this format.  The substream-
   id of a single JSON object is the 'data-id'.
```

예를 들어, ALTO 클라이언트가 네트워크 맵에 대한 업데이트를 수신하기 위해 요청에 하위 스트림 ID "1"을 할당하고 비용 맵에 하위 스트림 ID "2"를 할당한다고 가정합니다. 그런 다음 하위 스트림 ID는 업데이트할 객체를 나타내는 데이터 ID입니다. 그림 3은 ALTO 데이터 업데이트 메시지의 몇 가지 예를 보여줍니다.

```text
     event: application/alto-networkmap+json,1
     data: { ... full network map message ... }

     event: application/alto-costmap+json,2
     data: { ... full cost map message ... }

     event: application/merge-patch+json,2
     data: { ... JSON merge patch update for the cost map ... }

              Figure 3: Examples of ALTO Data Update Messages
```

다음으로 리소스에 여러 JSON 개체가 포함될 수 있는 경우를 생각해 보세요. 이 문서에서는 리소스가 여러 구성 요소\(부분\)를 포함할 수 있고 "multipart/관련" \[RFC2387\] 미디어 유형을 사용하여 인코딩되는 경우를 고려합니다. 이 다중 부분 응답의 각 부분은 Content-ID 헤더와 JSON 개체 본문을 포함하는 HTTP 메시지여야 합니다. 업데이트 스트림 서비스\(섹션 6에 정의됨\)가 필요한 각 구성 요소는 정의 문서에 정의되는 고유한 Content-ID로 식별되어야 합니다.\(MUST, MUST\)

미디어 유형 "multipart/관련"을 사용하는 리소스의 경우 'data- id' 하위 필드는 반드시 substream-id '.'의 연결이어야 합니다. 구분 기호\(U+002E\) 및 고유한 Content-ID를 순서대로 지정합니다.\(MUST\)

---
### **5.3.  ALTO Control Update Message**

제어 업데이트 메시지의 미디어 유형은 "application/alto-updatestreamcontrol+json"이고 데이터 유형은 UpdateStreamControlEvent입니다.

```text
     object {
        [String          control-uri;]
        [SubstreamID     started<1..*>;]
        [SubstreamID     stopped<1..*>;]
        [String          description;]
     } UpdateStreamControlEvent;
```

제어-uri:

- 이 업데이트 스트림에 대한 스트림 제어를 제공하는 URI\(섹션 7 참조\). 서버는 클라이언트에 control-uri를 알리는 컨트롤 업데이트 메시지를 보냅니다. control-uri를 알리는 이 제어 업데이트 메시지는 한 번 전송되며 업데이트 스트림의 첫 번째 이벤트여야 합니다. URI 값이 NULL이면 업데이트 스트림 서버는 이 업데이트 스트림에 대한 스트림 제어를 지원하지 않습니다. 그렇지 않으면 업데이트 스트림 서버가 지정된 URI를 통해 스트림 제어를 제공합니다.\(MUST\)

시작됨:

- 리소스의 하위 스트림 ID 목록입니다. 업데이트 스트림 서버가 나열된 각 리소스에 대한 데이터 업데이트 메시지 전송을 시작함을 ALTO 클라이언트에 알립니다.

중지됨:

- 리소스의 하위 스트림 ID 목록입니다. 업데이트 스트림 서버가 나열된 리소스에 대해 더 이상 데이터 업데이트 메시지를 보내지 않을 것임을 ALTO 클라이언트에 알립니다. 업데이트 스트림 서버가 리소스에 대한 데이터 업데이트 메시지 전송을 중지하는 데에는 스트림 제어\(6.7.1절\) 또는 내부 서버 이벤트를 사용하는 ALTO 클라이언트의 요청을 포함하여 여러 가지 이유가 있을 수 있습니다.

설명:

- 제어 이벤트에 대한 설명을 제공하는 비표준적이고 사람이 읽을 수 있는 텍스트입니다. 업데이트 스트림 서버가 리소스에 대한 데이터 업데이트 메시지 전송을 중지하면 업데이트 스트림 서버가 설명 필드를 사용하여 세부 정보를 제공하는 것이 좋습니다. "중지된" 이벤트를 트리거하는 데는 여러 가지 이유가 있을 수 있습니다. 위 참조. 이 필드의 목적은 개발자 및/또는 관리자가 잠재적인 문제를 진단할 수 있도록 사람이 읽을 수 있는 텍스트를 제공하는 것입니다.\(SHOULD\)

---
## **6.  Update Stream Service**

업데이트 스트림 서비스는 섹션 5에 정의된 대로 업데이트 메시지 스트림을 반환합니다. ALTO 서버의 IRD\(정보 자원 디렉토리\)는 ALTO 클라이언트가 새로운 업데이트 스트림 인스턴스를 요청하는 데 사용하는 하나 이상의 업데이트 스트림 서비스를 정의할 수 있습니다. 업데이트 스트림 서비스를 정의하는 IRD 항목은 미디어 유형, HTTP 방법 및 기능을 정의하고 다음과 같이 사용해야 합니다.\(MAY, MUST\)

---
### **6.1.  Media Type**

ALTO 업데이트 스트림 서비스의 미디어 유형은 \[SSE\]에 정의된 대로 "text/event-stream"입니다.

---
### **6.2.  HTTP Method**

ALTO 업데이트 스트림 서비스는 HTTP POST 메서드를 사용하여 요청됩니다.

---
### **6.3.  Capabilities**

기능은 UpdateStreamCapability 유형의 객체로 정의됩니다.

```text
     object {
       IncrementalUpdateMediaTypes incremental-change-media-types;
       Boolean                     support-stream-control;
     } UpdateStreamCapabilities;

     object-map {
        ResourceID -> String;
     } IncrementalUpdateMediaTypes;
```

이 업데이트 스트림이 리소스에 대한 증분 변경 사항이 포함된 데이터 업데이트 메시지를 제공할 수 있는 경우 "incremental-change-media-type" 필드에는 해당 리소스 ID에 대한 항목이 있고 값은 다음으로 구분된 증분 변경에 대해 지원되는 미디어 유형입니다. 쉼표. 일반적으로 이는 섹션에 설명된 대로 "application/merge-patch+json", "application/json-patch+json" 또는 "application/merge-patch+json,application/json-patch+json"입니다. 5, 이는 이 문서에서 정의한 유일한 증분 변경 유형입니다. 그러나 향후 확장에서는 다른 유형의 증분 변경을 정의할 수도 있습니다.

리소스에 대한 증분 변경 사항을 인코딩하기 위해 미디어 유형을 선택할 때 업데이트 스트림 서버는 인코딩 제한을 고려해야 합니다. 예를 들어, JSON 병합 패치가 필드 값이 null임을 지정하는 경우 해당 필드가 대상에서 제거되므로 필드가 더 이상 정의되지 않습니다\(즉, 정의되지 않음\). null 값이 처리되는 방법에 대해서는 섹션 3.1.1의 MergePatch 알고리즘을 참조하세요. 그러나 null과 정의되지 않음이 리소스에 대해 서로 다른 의미를 갖는 경우 이는 리소스에 대해 의도된 결과가 아닐 수 있습니다. 이러한 경우 JSON 패치가 업데이트 스트림 서버의 기능으로 표시되면 업데이트 스트림 서버는 JSON 병합 패치 대신 JSON 패치를 선택해야 합니다. 서버가 이러한 경우를 처리하기 위해 JSON 패치를 지원하지 않는 경우 서버는 전체 교체를 보내야 합니다.\(MUST, MUST\)

"support-stream-control" 필드는 주어진 업데이트 스트림이 스트림 제어를 지원하는지 여부를 지정합니다. "support-stream-control" 필드가 "true"인 경우 업데이트 스트림 서버는 이 문서에 지정된 스트림 제어를 사용합니다. 그렇지 않으면 업데이트 스트림 서버가 다른 메커니즘을 사용하여 스트림 제어와 동일한 기능을 제공할 수 있습니다.

---
### **6.4.  Uses**

"uses" 속성은 이 업데이트 스트림이 업데이트를 제공할 수 있는 모든 리소스의 리소스 ID가 포함된 배열이어야 합니다. "사용"에 지정된 각 리소스는 전체 교체를 지원해야 합니다. 업데이트 스트림 서버는 항상 전체 교체를 보낼 수 있으며 ALTO 클라이언트는 전체 교체를 수락해야 합니다.\(MUST, MUST\)

이 집합은 ALTO 서버 리소스의 하위 집합일 수 있으며 연결된 IRD에 정의된 리소스를 포함할 수 있습니다. 그러나 ALTO 서버는 리소스 종속 관계에 따라 닫힌 집합을 선택하는 것이 좋습니다. 즉, 업데이트 스트림의 "사용" 집합에 리소스 R1이 포함되고 리소스 R1이 리소스 R0에 종속\("사용"\)되는 경우 업데이트 스트림의 "사용" 집합에는 R1뿐만 아니라 R0도 포함되어야 합니다. 예를 들어, 비용 맵에 대한 업데이트 스트림은 해당 비용 맵이 의존하는 네트워크 맵에 대한 업데이트도 제공해야 합니다\(SHOULD\).\(SHOULD, SHOULD, SHOULD\)

---
### **6.5.  Request: Accept Input Parameters**

ALTO 클라이언트는 미디어 유형 "application/alto-updatestreamparams+json"을 사용하여 HTTP POST 본문을 전송하여 새 업데이트 스트림에 대한 매개변수를 지정합니다. 해당 본문에는 UpdateStreamReq 유형의 JSON 개체가 포함되어 있습니다.

```text
     object {
        [AddUpdatesReq   add;]
        [SubstreamID     remove<0..*>;]
     } UpdateStreamReq;

     object-map {
        SubstreamID -> AddUpdateReq;
     } AddUpdatesReq;

     object {
        ResourceID   resource-id;
        [JSONString  tag;]
        [Boolean     incremental-changes;]
        [Object      input;]
     } AddUpdateReq;
```

추가하다:

- ALTO 클라이언트가 업데이트를 원하는 리소스\(및 리소스에 대한 매개변수\)를 지정합니다. 동일한 업데이트 스트림 범위에서 ALTO 클라이언트는 각 항목에 대해 업데이트 스트림\(섹션 5.2\) 범위에서 고유한 substream-id를 할당하고 해당 substream-id를 "추가" 필드의 키로 사용해야 합니다. .\(MUST\)

리소스 ID:

- ALTO 리소스의 리소스 ID는 업데이트 스트림의 "사용" 목록\(섹션 6.4\)에 있어야 합니다. Resource-id가 \[RFC7285\]의 섹션 6.3 및 10.3에 정의된 대로 버전 태그\(또는 "vtag"\)가 있는 GET 모드 리소스이고 ALTO 클라이언트가 이전에 업데이트 스트림에서 해당 리소스의 버전을 검색한 경우 서버에서 ALTO 클라이언트는 "태그" 필드를 해당 리소스의 클라이언트 버전의 태그 부분으로 설정할 수 있습니다. 해당 버전이 최신 버전이 아닌 경우 업데이트 스트림 서버는 섹션 6.7.1에 설명된 대로 증분 변경 사항을 보내기 전에 전체 교체를 보내야 합니다. 해당 버전이 아직 최신인 경우 업데이트 스트림 서버는 초기 전체 교체를 생략할 수 있습니다.\(MUST, MAY, MUST, MAY\)

증분 변경:

- ALTO 클라이언트는 이 서브스트림에 대해 업데이트 스트림 서버로부터 증분 변경 사항을 수신할 의향이 있는지 여부를 지정합니다. "incremental-changes" 필드가 "true"인 경우 업데이트 스트림 서버는 이 하위 스트림에 대한 증분 변경 사항을 보낼 수 있습니다. 이 경우 클라이언트는 이 리소스에 대한 서버 기능에 발표된 세트의 모든 증분 방법을 지원해야 합니다. 잠재적인 증분 방법에 대한 서버의 발표는 섹션 6.3을 참조하세요. 클라이언트가 서버 기능에 발표된 세트의 모든 증분 방법을 지원하지 않는 경우 클라이언트는 "incremental-changes"를 "false"로 설정할 수 있으며 업데이트 스트림 서버는 해당 서브스트림에 대한 증분 변경 사항을 전송해서는 안 됩니다. "incremental-changes"의 기본값은 "true"이므로 증분 변경을 억제하려면 ALTO 클라이언트는 명시적으로 "incremental-changes"를 "false"로 설정해야 합니다. 증분 변경 제어의 대안 설계는 클라이언트가 서버 기능에 발표된 세트에서 증분 방법의 하위 세트를 선택할 수 있도록 함으로써 더욱 세분화된 제어입니다. 그러나 이 대체 디자인은 서버에 복잡성을 더해 병목 현상이 발생할 가능성이 높기 때문에 이 문서에서는 채택되지 않습니다. ALTO 클라이언트는 전체 교체를 억제할 수 없습니다. ALTO 클라이언트가 "incremental-changes"를 "false"로 설정하면 업데이트 스트림 서버는 ALTO 클라이언트에 증분 변경 대신 전체 교체를 보내야 합니다. 업데이트 스트림 서버는 더 많은 변경 사항이 제공될 때까지 기다렸다가 해당 변경 사항으로 단일 전체 교체를 보낼 수 있습니다. 따라서 증분 변경 사항 수락을 거부하는 ALTO 클라이언트는 이를 수락하는 ALTO 클라이언트만큼 빠르게 업데이트를 받지 못할 수 있습니다.\(MAY, MUST, MUST NOT, MUST, MUST, MAY\)

입력:

- 리소스가 입력이 필요한 POST 모드 서비스인 경우 ALTO 클라이언트는 리소스가 예상하는 매개변수를 사용하여 "입력" 필드를 JSON 객체로 설정해야 합니다.\(MUST\)

제거하다:

- 업데이트 스트림 제어 요청\(섹션 7\)에 사용되며 업데이트 스트림 요청에서는 허용되지 않습니다. 업데이트 스트림 서버는 이 필드가 요청에 포함된 경우 이를 무시해야 합니다\(SHOULD\).\(SHOULD\)

요청에 오류가 있는 경우 업데이트 스트림 서버는 업데이트 스트림을 생성해서는 안 됩니다. 또한 업데이트 스트림 서버는 섹션 6.6에 지정된 대로 ALTO 클라이언트에 오류 응답을 보냅니다.\(MUST NOT\)

---
### **6.6.  Response**

업데이트 스트림 요청에 오류가 있는 경우 업데이트 스트림 서버는 ALTO 클라이언트에 HTTP "400 잘못된 요청"을 반환해야 합니다. 응답 본문은 \[RFC7285\]의 섹션 8.5.2에 지정된 일반 ALTO 오류 응답 형식을 따릅니다. 따라서 ALTO 오류 응답 예시의 형식은 다음과 같습니다.\(MUST\)

```text
          HTTP/1.1 400 Bad Request
          Content-Length: 131
          Content-Type: application/alto-error+json
          Connection: Closed

          {
              "meta":{
                  "code":  "E_INVALID_FIELD_VALUE",
                  "field": "add/my-network-map/resource-id",
                  "value": "my-networkmap/#"
              }
          }
```

"필드"와 "값"은 선택 필드입니다. "값" 필드가 존재하는 경우 "필드" 필드도 존재해야 합니다.\(MUST\)

\* 업데이트 스트림 요청에 "추가" 필드가 없는 경우

- 하나 이상의 리소스를 지정하는 경우 오류 메시지의 오류 코드는 E\_MISSING\_FIELD여야 하고 "필드" 필드는 "추가"여야 합니다. 업데이트 스트림 서버는 이벤트를 전송하지 않고 스트림을 닫아야 합니다.\(MUST, MUST\)

\* "resource-id" 필드가 유효하지 않거나 업데이트 스트림과 연결되지 않은 경우 오류 메시지의 오류 코드는 E\_INVALID\_FIELD\_VALUE여야 합니다. "필드" 필드는 "resource-id" 필드의 전체 경로여야 하며, "값" 필드는 유효하지 않은 리소스 ID여야 합니다. 유효하지 않은 리소스 ID가 두 개 이상인 경우 업데이트 스트림 서버는 하나를 선택하여 반환해야 합니다. 업데이트 스트림 서버는 이벤트를 전송하지 않고 스트림\(예: TCP 연결\)을 닫아야 합니다.\(MUST, SHOULD, SHOULD, MUST\)

\* 리소스가 입력이 필요한 POST 모드 서비스인 경우 클라이언트는 해당 리소스가 예상하는 매개변수를 사용하여 "입력" 필드를 JSON 개체로 설정해야 합니다. "입력" 필드가 누락되었거나 유효하지 않은 경우 업데이트 스트림 서버는 해당 리소스가 누락되거나 유효하지 않은 입력에 대해 반환하는 것과 동일한 오류 응답을 반환해야 합니다\(\[RFC7285\] 참조\). 이 경우 업데이트 스트림 서버는 이벤트를 전송하지 않고 업데이트 스트림을 닫아야 합니다. 여러 POST 모드 리소스에 대한 입력이 누락되거나 유효하지 않은 경우 업데이트 스트림 서버는 반드시 하나를 선택하여 반환해야 합니다.\(MUST, MUST, MUST, MUST\)

유효한 요청에 대한 응답은 업데이트 메시지 스트림입니다. 섹션 5는 업데이트 메시지를 정의하고 \[SSE\]는 업데이트 메시지가 스트림으로 인코딩되는 방법을 정의합니다.

업데이트 스트림 서버는 기본 값이 변경될 때만 업데이트를 보내야 합니다\(SHOULD\). 그러나 업데이트 스트림 서버가 모든 상황에서 이를 보장하는 것은 어려울 수 있습니다. 따라서 클라이언트는 업데이트 메시지가 실제 변경을 나타낸다고 가정해서는 안 됩니다.\(SHOULD, MUST NOT\)

---
### **6.7.  Additional Requirements on Update Stream Service**
---
#### **6.7.1.  Event Sequence Requirements**

\* 첫 번째 이벤트는 이 업데이트 스트림에 대한 업데이트 스트림 제어 서비스\(섹션 7 참조\)의 URI가 포함된 제어 업데이트 메시지여야 합니다. control-uri의 값은 제어 스트림 서비스가 없음을 나타내는 "null"일 수 있습니다.\(MUST\)

\* 가능한 한 빨리 ALTO 클라이언트가 시작된 후

- 연결되면 업데이트 스트림 서버는 추가된 각 업데이트 요청에 대해 "태그" 필드를 확인합니다. 추가된 업데이트 요청에 "태그" 필드가 지정되지 않은 경우 업데이트 스트림 서버는 먼저 요청에 대한 전체 교체를 보내야 합니다. "태그" 필드가 지정되면 클라이언트는 증분 변경 사항을 수락할 수 있고 서버는 "태그"를 기반으로 증분 업데이트를 계산할 수 있습니다. 서버는 입력이 있는 POST 리소스의 경우 "태그"가 다음을 나타내야 함을 확인해야 합니다. 다양한 입력에 대한 올바른 결과\) 업데이트 스트림 서버는 초기 전체 교체를 생략할 수 있습니다.\(MUST, MAY\)

\* 이 업데이트 스트림이 리소스 ID R0 및 R1에 대한 업데이트를 제공하고 R1이 R0에 의존하는 경우 업데이트 스트림 서버는 R1에 대한 관련 업데이트를 보내기 전에 R0에 대한 업데이트를 보내야 합니다. 예를 들어 업데이트 스트림이 네트워크 맵과 해당 종속 비용 맵에 대한 업데이트를 제공한다고 가정합니다. 네트워크 맵이 변경되면 업데이트 스트림 서버는 비용 맵 업데이트를 보내기 전에 네트워크 맵 업데이트를 보내야 합니다.\(MUST, MUST\)

\* ALTO 클라이언트가 스트림 제어 서비스를 사용하여 하나 이상의 리소스에 대한 업데이트를 중지하는 경우\(섹션 7\) ALTO 클라이언트는 스트림 제어 요청을 보내야 합니다. 업데이트 스트림 서버는 "stopped" 필드에 중지된 모든 리소스의 substream-id가 포함된 제어 업데이트 메시지를 보내야 합니다.\(MUST, MUST\)

---
#### **6.7.2.  Cross-Stream Consistency Requirements**

여러 ALTO 클라이언트가 동일한 업데이트 스트림 리소스와 동일한 업데이트 요청 매개변수\(즉, 동일한 리소스 및 동일한 입력\)를 사용하여 여러 업데이트 스트림을 생성하는 경우 업데이트 스트림 서버는 모든 클라이언트에 동일한 업데이트를 보내야 합니다. 그러나 업데이트 스트림 서버는 해당 업데이트를 적용한 최종 결과가 동일한 한 데이터 항목을 다른 패치 이벤트로 압축할 수 있습니다.\(MUST, MAY\)

예를 들어 두 개의 서로 다른 ALTO 클라이언트가 동일한 비용 맵에 대해 두 개의 서로 다른 업데이트 스트림을 생성하고 업데이트 스트림 서버가 각 업데이트 사이에 짧은 일시 중지를 통해 세 개의 별도 비용 포인트 업데이트를 처리한다고 가정합니다. 서버는 두 클라이언트 모두에게 세 가지 새로운 비용 포인트를 모두 보내야 합니다. 그러나 업데이트 스트림 서버는 단일 패치 이벤트\(세 가지 비용 포인트 모두 포함\)를 하나의 ALTO 클라이언트에 보내는 동시에 세 개의 개별 패치 이벤트\(이벤트당 하나의 비용 포인트 포함\)를 다른 ALTO 클라이언트에 보낼 수 있습니다.\(MUST, MAY\)

업데이트 스트림 서버는 동일한 기본 리소스에 대한 업데이트를 제공하는 여러 가지 다른 업데이트 스트림 리소스를 제공할 수 있습니다\(즉, 리소스 ID가 둘 이상의 업데이트 스트림 리소스의 "사용" 필드에 나타날 수 있음\). 이 경우 해당 업데이트 스트림 리소스는 동일한 업데이트를 반환해야 합니다.\(MAY, MUST\)

---
#### **6.7.3.  Multipart Update Requirements**

이 디자인에서는 모든 유효한 미디어 유형을 완전히 교체할 수 있습니다. 따라서 다중 JSON 개체를 포함하기 위해 멀티파트를 사용하는 ALTO 리소스를 지원합니다. 이는 푸시 이점을 실현하지만 SSE의 증분 인코딩 이점은 실현하지 않습니다.

JSON 패치 및 병합 패치는 증분 인코딩 이점을 제공하지만 단일 JSON 개체에만 적용될 수 있습니다. 업데이트 스트림 서비스가 멀티파트 리소스라고 하는 멀티파트 미디어 유형을 제공하는 리소스를 지원하는 경우 업데이트 스트림 서비스는 전체 멀티파트 리소스의 메시지에 여러 JSON 개체가 포함될 수 있다는 문제를 처리해야 합니다. 문제를 해결하려면 업데이트 스트림 서비스가 멀티파트 리소스에 대한 JSON 패치 또는 병합 패치 증분 업데이트를 지원하도록 지정할 때 서비스는 \(1\) 멀티파트 메시지의 각 부분이 단일 JSON 개체인지, \(2\) 각 부분이 단일 JSON 개체인지 확인해야 합니다. 부분은 초기 전체 메시지에서 정적 Content-ID로 지정되고, \(3\) 각 데이터 업데이트 이벤트는 하나의 부분에만 적용되며, \(4\) 각 데이터 업데이트는 substream-id.content-id를 "이벤트" 필드로 지정합니다. 업데이트할 부분을 식별하기 위한 이벤트입니다.\(MUST\)

---
### **6.8.  Keep-Alive Messages**

SSE 스트림에서 콜론\(U+003A\) 문자로 시작하는 모든 줄은 주석이며 ALTO 클라이언트는 해당 줄\[SSE\]을 무시해야 합니다. \[SSE\]에서 권장하는 대로, 업데이트 스트림 서버는 ALTO 클라이언트와 프록시 서버가 HTTP 연결을 끊는 것을 방지하기 위해 15초마다 주석 라인\(또는 이벤트\)을 보내야 합니다\(SHOULD\). TCP도 Keep-Alive 기능을 제공하지만 TCP Keep-Alive 메시지 간의 간격은 OS 구성에 따라 달라질 수 있습니다. 앞서 권장된 SSE 연결 유지를 통해 SSE 클라이언트는 업데이트 스트림 서버의 상태를 보다 확실하게 감지할 수 있습니다.\(MUST, SHOULD\)

---
## **7.  Stream Control Service**

스트림 제어 서비스를 사용하면 ALTO 클라이언트가 업데이트 스트림에서 모니터링하는 리소스 집합에서 리소스를 제거하거나 해당 집합에 추가 리소스를 추가할 수 있습니다. 또한 이 서비스를 사용하면 ALTO 클라이언트가 업데이트 스트림을 정상적으로 종료할 수 있습니다.

업데이트 스트림 서버가 새 업데이트 스트림을 생성하고 업데이트 스트림 서버가 업데이트 스트림에 대한 스트림 제어를 지원하는 경우 업데이트 스트림 서버는 해당 업데이트 스트림에 대한 스트림 제어 서비스를 생성합니다. ALTO 클라이언트는 스트림 제어 서비스를 사용하여 업데이트 스트림 인스턴스에서 리소스를 제거하거나 추가 리소스에 대한 업데이트를 요청합니다. ALTO 클라이언트는 IRD를 통해 스트림 제어 서비스를 얻을 수 없습니다. 대신 업데이트 스트림 서버가 ALTO 클라이언트에 보내는 첫 번째 이벤트에는 관련 스트림 제어 서비스에 대한 URI가 있습니다\(섹션 5.3 참조\).

각 스트림 제어 요청은 개별 HTTP 요청입니다. ALTO 클라이언트는 동일한 HTTP 연결을 사용하여 스트림 제어 서버에 여러 스트림 제어 요청을 보낼 수 있습니다.\(MAY\)

---
### **7.1.  URI**

스트림 제어 서비스의 URI는 그 자체로 제어하는 ​​업데이트 스트림 인스턴스를 고유하게 지정해야 합니다. 스트림 제어 서버는 업데이트 스트림을 결정하기 위해 쿠키나 클라이언트의 IP 주소와 같은 HTTP 요청의 다른 속성을 사용해서는 안 됩니다. 또한 업데이트 스트림 서버는 관련 업데이트 스트림이 닫힌 후에는 제어 서비스 URI를 재사용해서는 안 됩니다.\(MUST, MUST NOT, MUST NOT\)

ALTO 클라이언트는 업데이트 스트림을 생성하는 데 사용되는 URI의 컨텍스트에서 상대 제어 URI 참조 \[RFC3986\]\(예: 호스트가 없거나 상대 경로가 있는 URI 참조\)를 평가해야 합니다. 스트림 제어 서비스의 호스트는 업데이트 스트림의 호스트와 다를 수 있습니다.\(MUST, MAY\)

스트림 제어 URI를 제어할 고유 업데이트 스트림 인스턴스에 매핑하는 내부 메커니즘이 있을 것으로 예상됩니다. 예를 들어 업데이트 스트림 서비스는 각 업데이트 스트림 인스턴스에 고유한 내부 스트림 ID를 할당할 수 있습니다. 그러나 정확한 메커니즘은 업데이트 스트림 서비스 제공자에게 맡겨집니다.

```text
   To prevent an attacker from forging a stream control URI and sending
   bogus requests to disrupt other update streams, the service should
   consider two security issues.  First, if http, not https, is used,
   the stream control URI can be exposed to an on-path attacker.  To
   address this issue, in a setting where the path from the server to
   the client can traverse such an attacker, the server SHOULD use
   https.  Second, even without direct exposure, an off-path attacker
   may guess valid stream control URIs.  To address this issue, the
   server SHOULD choose stream control URIs with enough randomness to
   make guessing difficult; the server SHOULD introduce mechanisms that
   detect repeated guesses indicating an attack (e.g., keeping track of
   the number of failed stream control attempts).  Please see the W3C's
   "Good Practices for Capability URLs" <https://www.w3.org/TR/
   capability-urls/>.
```

---
### **7.2.  Media Type**

ALTO 스트림 제어 응답에는 특정 미디어 유형이 없습니다.

---
### **7.3.  HTTP Method**

ALTO 업데이트 스트림 제어 리소스는 HTTP POST 메서드를 사용하여 요청됩니다.

---
### **7.4.  IRD Capabilities & Uses**

없음\(스트림 제어 서비스는 IRD에 표시되지 않습니다\).

---
### **7.5.  Request: Accept Input Parameters**

스트림 제어 서비스는 업데이트 스트림 서비스\(6.5절\)와 동일한 입력 미디어 유형 및 입력 매개변수를 허용합니다. 유일한 차이점은 스트림 제어 서비스가 "제거" 필드도 허용한다는 것입니다.

지정된 경우 "제거" 필드는 이전에 이 업데이트 스트림에 추가된 ALTO 클라이언트의 하위 스트림 ID 배열입니다. 빈 "제거" 배열은 현재 활성화된 모든 리소스 목록과 동일합니다. 업데이트 스트림 서버는 모든 리소스를 제거하고 스트림을 닫는 방식으로 응답합니다.

ALTO 클라이언트는 추가 리소스를 추가하기 위해 "추가" 필드를 사용할 수 있습니다. ALTO 클라이언트는 각 추가 리소스에 고유한 하위 스트림 ID를 할당해야 합니다. 하위 스트림 ID는 이 업데이트 스트림의 수명 동안 고유해야 합니다. ALTO 클라이언트는 이전에 제거된 substream-id를 재사용해서는 안 됩니다. "추가" 리소스의 처리는 섹션 6.5 및 6.6에서 설명한 것과 동일합니다.\(MAY, MUST, MUST NOT\)

요청에 오류가 있는 경우 업데이트 스트림 서버는 관련 업데이트 스트림에서 리소스를 추가하거나 제거해서는 안 됩니다. 또한 스트림 제어 서버는 섹션 7.6에 지정된 대로 클라이언트에 오류 응답을 반환합니다.\(MUST NOT\)

---
### **7.6.  Response**

스트림 제어 서버는 "제거" 필드 이전에 "추가" 필드를 처리해야 합니다. 요청이 추가 리소스를 추가하지 않고 모든 활성 리소스를 제거하는 경우 업데이트 스트림 서버는 업데이트 스트림을 닫아야 합니다. 따라서 업데이트 스트림에는 리소스가 0개 있을 수 없습니다.\(MUST, MUST\)

요청에 오류가 있는 경우 스트림 제어 서버는 ALTO 클라이언트에 HTTP "400 잘못된 요청"을 반환해야 합니다. 응답의 본문 부분은 \[RFC7285\]의 섹션 8.5.2에 지정된 일반 ALTO 오류 응답 형식을 따릅니다. 오류 응답은 섹션 6.6에 지정된 것과 동일한 형식을 갖습니다. 자세한 오류 코드 및 오류 정보는 다음과 같습니다.\(MUST\)

\* "추가" 요청이 요구 사항을 충족하지 않는 경우

- 섹션 6.5, 스트림 제어 서버는 섹션 6.6에 정의된 ALTO 오류 메시지를 반환해야 합니다.\(MUST\)

\* 이전 요청에서 "remove" 필드의 하위 스트림 ID가 추가되지 않은 경우 오류 메시지의 오류 코드는 E\_INVALID\_FIELD\_VALUE여야 하고, "field" 필드는 "remove"여야 하며, "value" 필드는 다음과 같아야 합니다. 잘못된 하위 스트림 ID의 배열입니다. 따라서 동일한 요청에서 동일한 하위 스트림 ID를 "추가" 및 "제거"하는 것은 불법입니다. 그러나 하위 스트림 ID를 두 번 제거하는 것은 합법적입니다. 이전 검사를 지원하려면 업데이트 스트림 서버는 이전에 사용되었지만 현재는 닫힌 substream-id를 추적해야 합니다.\(MUST, MUST\)

\* "추가" 필드의 하위 스트림 ID가 이전에 이 스트림에서 사용된 경우 오류 메시지의 오류 코드는 E\_INVALID\_FIELD\_VALUE여야 하고 "필드" 필드는 "추가"여야 하며 "값" 필드는 다음과 같아야 합니다. 잘못된 하위 스트림 ID의 배열입니다.\(MUST\)

\* 요청에 비어 있지 않은 "추가" 필드와 빈 서브스트림 ID 목록이 있는 "제거" 필드가 있는 경우\(모든 활성 리소스를 새 세트로 대체하려면 클라이언트는 제거할 서브스트림 ID를 명시적으로 열거해야 합니다\) \), 오류 메시지의 오류 코드는 E\_INVALID\_FIELD\_VALUE여야 하고, "필드" 필드는 "제거"여야 하며, "값" 필드는 빈 배열이어야 합니다.\(MUST\)

요청이 유효하지만 관련 업데이트 스트림이 닫힌 경우 스트림 제어 서버는 HTTP "404 찾을 수 없음"을 반환해야 합니다.\(MUST\)

요청이 유효하고 스트림 제어 서버가 오류 없이 성공적으로 요청을 처리하는 경우 스트림 제어 서버는 HTTP "202 Accepted" 응답 또는 HTTP "204 No Content" 응답을 반환해야 합니다. 차이점은 후자의 경우 스트림 제어 서버는 업데이트 스트림 서버도 요청을 처리했음을 확신한다는 것입니다. 202 또는 204 HTTP 응답에 관계없이 모듈식 설계로 인해 관련 리소스의 최종 업데이트는 제어 업데이트 메시지를 사용하여 업데이트 스트림 서버에서 통보됩니다.

---
## **8.  Examples**
---
### **8.1.  Example: IRD Announcing Update Stream Services**

다음은 세 가지 업데이트 스트림 서비스를 발표하는 IRD의 예입니다. "update-my-costs"라는 첫 번째 항목은 네트워크 맵, "routingcost" 및 "hopcount" 비용 맵, 필터링된 비용 맵 리소스에 대한 업데이트를 제공합니다. "update-my-prop"라는 두 번째 항목은 끝점 속성 서비스에 대한 업데이트를 제공합니다. "update-my-pv"라는 세 번째 서비스는 다중 부분 응답을 반환하는 비표준 ALTO 서비스에 대한 업데이트를 제공합니다.

예제 IRD에 표시된 "update-my-costs" 업데이트 스트림에서 업데이트 스트림 서버는 네트워크 맵에 JSON 패치를 사용하고 JSON 병합 패치를 사용하여 다른 리소스를 업데이트합니다. 또한 업데이트 스트림은 "my-simple-filtered-cost-map"에 대한 전체 교체만 제공합니다.

또한 이 IRD는 두 개의 필터링된 비용 맵 리소스를 정의합니다. 동일한 비용 유형을 사용하지만 "my-filtered-cost-map"은 비용 제약 조건 테스트를 허용하는 반면 "my-simple-filtered-cost-map"은 허용하지 않습니다. 섹션 9.3에서 설명한 문제를 방지하기 위해 업데이트 스트림은 첫 번째가 아닌 두 번째에 대한 업데이트를 제공합니다.

이 IRD는 또한 "my-pv"라는 비표준 ALTO 서비스를 발표합니다. 이 서비스는 확장된 엔드포인트 비용 요청을 입력으로 받아들이고 엔드포인트 비용 리소스 및 속성 맵 리소스를 포함한 다중 부분 응답을 반환합니다. 이 문서는 이 새로운 서비스의 다른 설계 세부 사항에 의존하지 않습니다. 이 문서에서 "my-pv" 서비스는 업데이트 스트림 서비스가 멀티파트 응답을 반환하는 ALTO 리소스에 대한 업데이트를 제공하는 방법을 설명하기 위해서만 사용됩니다.

```text
     "my-network-map": {
       "uri": "https://alto.example.com/networkmap",
       "media-type": "application/alto-networkmap+json",
     },
     "my-routingcost-map": {
       "uri": "https://alto.example.com/costmap/routingcost",
       "media-type": "application/alto-costmap+json",
       "uses": ["my-networkmap"],
       "capabilities": {
         "cost-type-names": ["num-routingcost"]
       }
     },
     "my-hopcount-map": {
       "uri": "https://alto.example.com/costmap/hopcount",
       "media-type": "application/alto-costmap+json",
       "uses": ["my-networkmap"],
       "capabilities": {
         "cost-type-names": ["num-hopcount"]
       }
     },
     "my-filtered-cost-map": {
       "uri": "https://alto.example.com/costmap/filtered/constraints",
       "media-type": "application/alto-costmap+json",
       "accepts": "application/alto-costmapfilter+json",
       "uses": ["my-networkmap"],
       "capabilities": {
         "cost-type-names": ["num-routingcost", "num-hopcount"],
         "cost-constraints": true
       }
     },
     "my-simple-filtered-cost-map": {
       "uri": "https://alto.example.com/costmap/filtered/simple",
       "media-type": "application/alto-costmap+json",
       "accepts": "application/alto-costmapfilter+json",
       "uses": ["my-networkmap"],
       "capabilities": {
         "cost-type-names": ["num-routingcost", "num-hopcount"],
         "cost-constraints": false
       }
     },
     "my-props": {
       "uri": "https://alto.example.com/properties",
       "media-type": "application/alto-endpointprops+json",
       "accepts": "application/alto-endpointpropparams+json",
       "capabilities": {
         "prop-types": ["priv:ietf-bandwidth"]
       }
     },
     "my-pv": {
       "uri": "https://alto.example.com/endpointcost/pv",
       "media-type": "multipart/related;
                      type=application/alto-endpointcost+json",
       "accepts": "application/alto-endpointcostparams+json",
       "capabilities": {
         "cost-type-names": [ "path-vector" ],
         "ane-properties": [ "maxresbw", "persistent-entities" ]
       }
     },
     "update-my-costs": {
       "uri": "https://alto.example.com/updates/costs",
       "media-type": "text/event-stream",
       "accepts": "application/alto-updatestreamparams+json",
       "uses": [
          "my-network-map",
          "my-routingcost-map",
          "my-hopcount-map",
          "my-simple-filtered-cost-map"
       ],
       "capabilities": {
         "incremental-change-media-types": {
           "my-network-map": "application/json-patch+json",
           "my-routingcost-map": "application/merge-patch+json",
           "my-hopcount-map": "application/merge-patch+json"
         },
         "support-stream-control": true
       }
     },
     "update-my-props": {
       "uri": "https://alto.example.com/updates/properties",
       "media-type": "text/event-stream",
       "uses": [ "my-props" ],
       "accepts": "application/alto-updatestreamparams+json",
       "capabilities": {
         "incremental-change-media-types": {
           "my-props": "application/merge-patch+json"
         },
         "support-stream-control": true
       }
     },
     "update-my-pv": {
       "uri": "https://alto.example.com/updates/pv",
       "media-type": "text/event-stream",
       "uses": [ "my-pv" ],
       "accepts": "application/alto-updatestreamparams+json",
       "capabilities": {
         "incremental-change-media-types": {
           "my-pv": "application/merge-patch+json"
         },
         "support-stream-control": true
       }
     }
```

---
### **8.2.  Example: Simple Network and Cost Map Updates**

이전 예제 IRD에서 발표된 업데이트 스트림을 고려하면 아래 섹션에서는 업데이트 스트림 리소스 "update-my-costs"를 사용하여 ALTO 클라이언트의 요청과 업데이트 스트림 서버의 즉각적인 응답의 예를 보여줍니다. 이 예에서 ALTO 클라이언트는 네트워크 맵과 "routingcost" 비용 맵에 대한 업데이트를 요청하지만 "hopcount" 비용 맵에 대해서는 업데이트를 요청하지 않습니다. ALTO 클라이언트는 ALTO 서버의 리소스 ID를 하위 스트림 ID로 사용합니다. 클라이언트는 네트워크 맵에 대한 "태그"를 제공하지 않기 때문에 업데이트 스트림 서버는 비용 맵뿐만 아니라 네트워크 맵에 대한 전체 교체를 보내야 합니다. ALTO 클라이언트는 "incremental-changes"를 "false"로 설정하지 않으므로 기본값은 "true"입니다. 따라서 업데이트 스트림 서버는 비용 맵과 네트워크 맵에 대한 패치 업데이트를 보냅니다.

```text
     POST /updates/costs HTTP/1.1
     Host: alto.example.com
     Accept: text/event-stream,application/alto-error+json
     Content-Type: application/alto-updatestreamparams+json
     Content-Length: 155

     { "add": {
         "my-network-map": {
           "resource-id": "my-network-map"
           },
         "my-routingcost-map": {
           "resource-id": "my-routingcost-map"
         }
       }
     }

     HTTP/1.1 200 OK
     Connection: keep-alive
     Content-Type: text/event-stream

     event: application/alto-updatestreamcontrol+json
     data: {"control-uri":
     data: "https://alto.example.com/updates/streams/3141592653589"}

     event: application/alto-networkmap+json,my-network-map
     data: {
     data:   "meta" : {
     data:     "vtag": {
     data:       "resource-id" : "my-network-map",
     data:         "tag" : "da65eca2eb7a10ce8b059740b0b2e3f8eb1d4785"
     data:       }
     data:     },
     data:     "network-map" : {
     data:       "PID1" : {
     data:         "ipv4" : [ "192.0.2.0/24", "198.51.100.0/25" ]
     data:       },
     data:       "PID2" : {
     data:         "ipv4" : [ "198.51.100.128/25" ]
     data:       },
     data:       "PID3" : {
     data:         "ipv4" : [ "0.0.0.0/0" ],
     data:         "ipv6" : [ "::/0" ]
     data:       }
     data:     }
     data:   }
     data: }

     event: application/alto-costmap+json,my-routingcost-map
     data: {
     data:   "meta" : {
     data:     "dependent-vtags" : [{
     data:       "resource-id": "my-network-map",
     data:       "tag": "da65eca2eb7a10ce8b059740b0b2e3f8eb1d4785"
     data:     }],
     data:     "cost-type" : {
     data:       "cost-mode"  : "numerical",
     data:       "cost-metric": "routingcost"
     data:     },
     data:     "vtag": {
     data:       "resource-id" : "my-routingcost-map",
     data:       "tag" : "3ee2cb7e8d63d9fab71b9b34cbf764436315542e"
     data:     }
     data:   },
     data:   "cost-map" : {
     data:     "PID1": { "PID1": 1,  "PID2": 5,  "PID3": 10 },
     data:     "PID2": { "PID1": 5,  "PID2": 1,  "PID3": 15 },
     data:     "PID3": { "PID1": 20, "PID2": 15  }
     data:   }
     data: }
```

해당 이벤트를 즉시 보낸 후 업데이트 스트림 서버는 지도가 변경되면 추가 이벤트를 보냅니다. 예를 들어 다음은 비용 맵에 대한 작은 변경 사항을 나타냅니다. PID1-\>PID2는 5에서 9로 변경되고, PID3-\>PID1은 더 이상 사용할 수 없으며, PID3-\>PID3은 이제 1로 정의됩니다.

```text
     event: application/merge-patch+json,my-routingcost-map
     data: {
     data:   "meta" : {
     data:     "vtag": {
     data:       "tag": "c0ce023b8678a7b9ec00324673b98e54656d1f6d"
     data:     }
     data:   },
     data:   "cost-map": {
     data:     "PID1" : { "PID2" : 9 },
     data:     "PID3" : { "PID1" : null, "PID3" : 1 }
     data:   }
     data: }
```

또 다른 예로, 다음은 네트워크 맵에 대한 변경 사항을 나타냅니다. ipv4 접두사 "203.0.113.0/25"가 PID1에 추가됩니다. 이는 비용 지도에 대한 변경을 유발합니다. 업데이트 스트림 서버는 네트워크 맵에 대한 증분 변경 사항을 보내고 비용 맵에 대한 증분 변경 대신 전체 교체를 보내도록 선택합니다.

```text
         event: application/json-patch+json,my-network-map
         data: {
         data:   {
         data:     "op": "replace",
         data:     "path": "/meta/vtag/tag",
         data:     "value" :"a10ce8b059740b0b2e3f8eb1d4785acd42231bfe"
         data:   },
         data:   {
         data:     "op": "add",
         data:     "path": "/network-map/PID1/ipv4/2",
         data:     "value": "203.0.113.0/25"
         data:   }
         data: }

         event: application/alto-costmap+json,my-routingcost-map
         data: {
         data:   "meta" : {
         data:     "vtag": {
         data:       "tag": "c0ce023b8678a7b9ec00324673b98e54656d1f6d"
         data:     }
         data:   },
         data:   "cost-map" : {
         data:     "PID1": { "PID1": 1,  "PID2": 3,  "PID3": 7 },
         data:     "PID2": { "PID1": 12, "PID2": 1,  "PID3": 9 },
         data:     "PID3": { "PID1": 14, "PID2": 8  }
         data:   }
         data: }
```

---
### **8.3.  Example: Advanced Network and Cost Map Updates**

이 예는 ALTO 클라이언트가 "hopcount" 비용 맵과 "routingcost" 비용 맵에 대한 업데이트를 요청하고 네트워크 맵의 현재 버전 태그를 제공한다는 점을 제외하면 이전 예제와 유사합니다. 스트림 시작 시 전체 네트워크 맵 데이터 업데이트 메시지를 보내는 데 필요합니다. 이 예에서 클라이언트는 해당 리소스에 대해 하위 스트림 ID "net", "routing" 및 "hops"를 사용합니다. 업데이트 스트림 서버는 스트림 제어 URI와 전체 비용 맵을 보낸 다음 네트워크 맵과 비용 맵에 대한 업데이트가 제공되면 다음과 같이 보냅니다.

```text
     POST /updates/costs HTTP/1.1
     Host: alto.example.com
     Accept: text/event-stream,application/alto-error+json
     Content-Type: application/alto-updatestreamparams+json
     Content-Length: 244

     { "add": {
         "net": {
           "resource-id": "my-network-map",
           "tag": "a10ce8b059740b0b2e3f8eb1d4785acd42231bfe"
         },
         "routing": {
           "resource-id": "my-routingcost-map"
         },
         "hops": {
           "resource-id": "my-hopcount-map"
         }
       }
     }

     HTTP/1.1 200 OK
     Connection: keep-alive
     Content-Type: text/event-stream

     event: application/alto-updatestreamcontrol+json
     data: {"control-uri":
     data: "https://alto.example.com/updates/streams/2718281828459"}

     event: application/alto-costmap+json,routing
     data: { ... full routingcost cost map message ... }

     event: application/alto-costmap+json,hops
     data: { ... full hopcount cost map message ... }

        (pause)

     event: application/merge-patch+json,routing
     data: {"cost-map": {"PID2" : {"PID3" : 31}}}

     event: application/merge-patch+json,hops
     data: {"cost-map": {"PID2" : {"PID3" : 4}}}
```

ALTO 클라이언트가 "hopcount" 비용 맵에 대한 업데이트 수신을 중지하려는 경우 ALTO 클라이언트는 스트림 제어 URI에서 "제거" 요청을 보낼 수 있습니다.

```text
     POST /updates/streams/2718281828459 HTTP/1.1
     Host: alto.example.com
     Accept: text/plain,application/alto-error+json
     Content-Type: application/alto-updatestreamparams+json
     Content-Length: 24

     {
       "remove": [ "hops" ]
     }

     HTTP/1.1 204 No Content
     Content-Length: 0

         (stream closed without sending data content)
```

업데이트 스트림 서버는 해당 리소스에 대한 업데이트가 중지되었음을 ALTO 클라이언트에 알리기 위해 원래 요청 스트림에 대해 "중지된" 제어 업데이트 메시지를 보냅니다.

```text
     event: application/alto-updatestreamcontrol+json
     data: {
     data:   "stopped": ["hops"]
     data: }
```

다음은 잘못된 스트림 제어 요청의 예입니다. 요청의 "remove" 필드에는 정의되지 않은 substream-id가 포함되어 있으며 스트림 제어 서버는 ALTO 클라이언트에 오류 응답을 반환합니다.

```text
         POST /updates/streams/2718281828459 HTTP/1.1
         Host: alto.example.com
         Accept: text/plain,application/alto-error+json
         Content-Type: application/alto-updatestreamparams+json
         Content-Length: 31
         {
           "remove": [ "properties" ]
         }

         HTTP/1.1 400 Bad Request
         Content-Length: 89
         Content-Type: application/alto-error+json

         {
           "meta":{
           "code": "E_INVALID_FIELD_VALUE",
           "field": "remove",
           "value": "properties"
         }
```

ALTO 클라이언트에 더 이상 업데이트가 필요하지 않고 업데이트 스트림을 정상적으로 종료하려는 경우 클라이언트는 빈 배열을 사용하여 "제거" 요청을 보낼 수 있습니다.

```text
     POST /updates/streams/2718281828459 HTTP/1.1
     Host: alto.example.com
     Accept: text/plain,application/alto-error+json
     Content-Type: application/alto-updatestreamparams+json
     Content-Length: 17

     {
       "remove": [ ]
     }

     HTTP/1.1 204 No Content
     Content-Length: 0

         (stream closed without sending data content)
```

업데이트 스트림 서버는 원래 요청 스트림에 대한 최종 제어 업데이트 메시지를 보내 ALTO 클라이언트에 모든 업데이트가 중지되었음을 알리고 스트림을 닫습니다.

```text
     event: application/alto-updatestreamcontrol+json
     data: {
     data:   "stopped": ["net", "routing"]
     data: }

         (server closes stream)
```

---
### **8.4.  Example: Endpoint Property Updates**

또 다른 예로, ALTO 클라이언트가 한 엔드포인트 세트에 대해 "priv:ietf-bandwidth" 속성에 대한 업데이트를 요청하고 다른 엔드포인트 세트에 대해 "priv:ietf-load" 속성에 대한 업데이트를 요청할 수 있는 방법은 다음과 같습니다. 업데이트 스트림 서버는 모든 끝점에 대한 속성 값으로 전체 대체 항목을 즉시 보냅니다. 그 후 업데이트 스트림 서버는 해당 속성 값이 변경됨에 따라 개별 엔드포인트에 대한 데이터 업데이트 메시지를 보냅니다.

```text
     POST /updates/properties HTTP/1.1
     Host: alto.example.com
     Accept: text/event-stream
     Content-Type: application/alto-updatestreamparams+json
     Content-Length: 511

     { "add": {
         "props-1": {
           "resource-id": "my-props",
           "input": {
             "properties" : [ "priv:ietf-bandwidth" ],
             "endpoints" : [
               "ipv4:198.51.100.1",
               "ipv4:198.51.100.2",
               "ipv4:198.51.100.3"
             ]
           }
         },
         "props-2": {
           "resource-id": "my-props",
           "input": {
             "properties" : [ "priv:ietf-load" ],
             "endpoints" : [
               "ipv6:2001:db8:100::1",
               "ipv6:2001:db8:100::2",
               "ipv6:2001:db8:100::3"
             ]
           }
         }
       }
     }

     HTTP/1.1 200 OK
     Connection: keep-alive
     Content-Type: text/event-stream

     event: application/alto-updatestreamcontrol+json
     data: {"control-uri":
     data: "https://alto.example.com/updates/streams/1414213562373"}

     event: application/alto-endpointprops+json,props-1
     data: { "endpoint-properties": {
     data:     "ipv4:198.51.100.1" : { "priv:ietf-bandwidth": "13" },
     data:     "ipv4:198.51.100.2" : { "priv:ietf-bandwidth": "42" },
     data:     "ipv4:198.51.100.3" : { "priv:ietf-bandwidth": "27" }
     data:  } }

     event: application/alto-endpointprops+json,props-2
     data: { "endpoint-properties": {
     data:     "ipv6:2001:db8:100::1" : { "priv:ietf-load": "8" },
     data:     "ipv6:2001:db8:100::2" : { "priv:ietf-load": "2" },
     data:     "ipv6:2001:db8:100::3" : { "priv:ietf-load": "9" }
     data:  } }

        (pause)

     event: application/merge-patch+json,props-1
     data: { "endpoint-properties":
     data:   {"ipv4:198.51.100.1" : {"priv:ietf-bandwidth": "3"}}
     data: }

        (pause)

     event: application/merge-patch+json,props-2
     data: { "endpoint-properties":
     data:   {"ipv6:2001:db8:100::3" : {"priv:ietf-load": "7"}}
     data: }
```

ALTO 클라이언트에 "priv:ietf-bandwidth" 속성과 추가 엔드포인트에 대한 "priv:ietf-load" 속성이 필요한 경우 ALTO 클라이언트는 스트림 제어 URI에 대해 "add" 요청을 보낼 수 있습니다.

```text
     POST /updates/streams/1414213562373" HTTP/1.1
     Host: alto.example.com
     Accept: text/plain,application/alto-error+json
     Content-Type: application/alto-updatestreamparams+json
     Content-Length: 448

     { "add": {
         "props-3": {
           "resource-id": "my-props",
           "input": {
             "properties" : [ "priv:ietf-bandwidth" ],
             "endpoints" : [
               "ipv4:198.51.100.4",
               "ipv4:198.51.100.5"
             ]
           }
         },
         "props-4": {
           "resource-id": "my-props",
           "input": {
             "properties" : [ "priv:ietf-load" ],
             "endpoints" : [
               "ipv6:2001:db8:100::4",
               "ipv6:2001:db8:100::5"
             ]
           }
         }
       }
     }

     HTTP/1.1 204 No Content
     Content-Length: 0

         (stream closed without sending data content)
```

업데이트 스트림 서버는 두 개의 새로운 리소스에 대한 전체 대체 항목을 보낸 다음, 요청이 도착하면 4개 요청 모두에 대한 증분 변경 사항을 보냅니다.

```text
     event: application/alto-endpointprops+json,props-3
     data: { "endpoint-properties": {
     data:     "ipv4:198.51.100.4" : { "priv:ietf-bandwidth": "25" },
     data:     "ipv4:198.51.100.5" : { "priv:ietf-bandwidth": "31" },
     data:  } }

     event: application/alto-endpointprops+json,props-4
     data: { "endpoint-properties": {
     data:     "ipv6:2001:db8:100::4" : { "priv:ietf-load": "6" },
     data:     "ipv6:2001:db8:100::5" : { "priv:ietf-load": "4" },
     data:  } }

        (pause)

     event: application/merge-patch+json,props-3
     data: { "endpoint-properties":
     data:   {"ipv4:198.51.100.5" : {"priv:ietf-bandwidth": "15"}}
     data: }

        (pause)

     event: application/merge-patch+json,props-2
     data: { "endpoint-properties":
     data:   {"ipv6:2001:db8:100::2" : {"priv:ietf-load": "9"}}
     data: }

        (pause)

     event: application/merge-patch+json,props-4
     data: { "endpoint-properties":
     data:   {"ipv6:2001:db8:100::4" : {"priv:ietf-load": "3"}}
     data: }
```

---
### **8.5.  Example: Multipart Message Updates**

이 예에서는 ALTO 클라이언트가 다중 부분 응답을 반환하는 비표준 ALTO 서비스를 요청할 수 있는 방법을 보여줍니다. 업데이트 스트림 서버는 멀티파트 응답의 전체 교체를 즉시 보냅니다. 이후 업데이트 스트림 서버는 각 부분의 ALTO 데이터\(객체\)가 변경됨에 따라 응답의 개별 부분에 대한 데이터 업데이트 메시지를 보냅니다.

```text
      POST /updates/pv HTTP/1.1
      Host: alto.example.com
      Accept: text/event-stream
      Content-Type: application/alto-updatestreamparams+json
      Content-Length: 382

      {
        "add": {
          "ecspvsub1": {
            "resource-id": "my-pv",
            "input": {
              "cost-type": {
                "cost-mode": "array",
                "cost-metric": "ane-path"
              },
              "endpoints": {
                "srcs": [ "ipv4:192.0.2.2" ],
                "dsts": [ "ipv4:192.0.2.89", "ipv4:203.0.113.45" ]
              },
              "ane-properties": [ "maxresbw", "persistent-entities" ]
            }
          }
        }
      }

      HTTP/1.1 200 OK
      Connection: keep-alive
      Content-Type: text/event-stream

      event: application/alto-updatestreamcontrol+json
      data: {"control-uri":
      data:    "https://alto.example.com/updates/streams/1414"}

      event: multipart/related;boundary=example-pv;
             type=application/alto-endpointcost+json,ecspvsub1
      data: --example-pv
      data: Content-ID: ecsmap
      data: Content-Type: application/alto-endpointcost+json
      data:
      data: { ... data (object) of an endpoint cost map ... }
      data: --example-pv
      data: Content-ID: propmap
      data: Content-Type: application/alto-propmap+json
      data:
      data: { ... data (object) of a property map ... }
      data: --example-pv--

         (pause)

      event: application/merge-patch+json,ecspvsub1.ecsmap
      data: { ... merge patch for updates of ecspvsub1.ecsmap ... }

      event: application/merge-patch+json,ecspvsub1.propmap
      data: { ... merge patch for updates of ecspvsub1.propmap ... }
```

---
## **9.  Operation and Processing Considerations**
---
### **9.1.  Considerations for Choosing Data Update Messages**

업데이트 스트림 서버는 타이밍 선택\(예: 업데이트를 트리거할 시기/대상\)과 메시지 형식 선택\(예: 업데이트가 있는 경우 전체 교체 보내기\)을 모두 포함하는 업데이트 일정의 영향을 인식해야 합니다. 또는 점진적인 변경\). 특히, 업데이트 일정은 오버헤드와 정보의 최신성 모두에 영향을 미칠 수 있습니다. 오버헤드를 최소화하기 위해 서버는 누적 업데이트를 전송하거나 잠시 후 전체 교체를 전송하여 자주 변경되는 리소스에 대한 일련의 업데이트를 일괄 처리하도록 선택할 수 있습니다. 업데이트 스트림 서버는 일괄 처리가 정보의 최신성을 감소시킨다는 것을 인식해야 합니다. 또한 서버는 이러한 지연이 클라이언트 동작에 미치는 영향을 고려해야 합니다\(종속 리소스의 업데이트를 기다리는 동안 클라이언트 시간 초과에 대한 아래 참조\).

증분 업데이트의 경우 이 설계에서는 증분 변경을 위해 JSON 패치와 JSON 병합 패치를 모두 허용합니다. JSON 병합 패치는 비용 맵, 엔드포인트 비용 및 엔드포인트 속성의 점진적인 변경 사항을 설명하는 데 있어 JSON 패치보다 확실히 우수합니다. 이러한 데이터 구조의 경우 JSON 병합 패치는 공간 효율적일 뿐만 아니라 적용하기도 더 간단합니다. 서버가 해당 리소스에 대해 JSON 패치를 사용하도록 허용하면 이점이 없습니다.

네트워크 맵의 증분 변경에 대한 사례는 명확하지 않습니다.

먼저, 한 PID에서 다른 PID로 접두사를 이동하는 등의 작은 변경을 고려하십시오. JSON 패치는 이를 간단한 삽입 및 삭제로 인코딩할 수 있는 반면, JSON 병합 패치는 두 PID에 대한 전체 접두사 배열을 대체해야 합니다. 반면에 JSON 패치 업데이트를 처리하려면 ALTO 클라이언트는 각 PID에 대한 접두사의 인덱스를 유지해야 합니다. 논리적으로 PID의 접두사는 배열이 아니라 순서가 지정되지 않은 세트입니다. 업데이트를 처리하는 것 외에 클라이언트는 접두사의 배열 인덱스를 유지할 필요가 없습니다. 따라서 네트워크 맵에 JSON 패치를 활용하려면 ALTO 클라이언트는 불필요한 추가 데이터를 유지해야 합니다.

둘째, PID에서 접두어의 절반을 제거하는 등 더 관련된 변경 사항을 고려하십시오. JSON 병합 패치는 해당 PID에 대한 새 배열을 보내는 반면, JSON 패치는 제거 작업 목록을 보내고 접두사를 하나씩 삭제해야 합니다.

따라서 각 업데이트 스트림 서버는 네트워크 맵의 변경 사항에 따라 JSON 병합 패치를 사용할지 JSON 패치를 사용할지 자체적으로 결정할 수 있습니다.

---
### **9.2.  Considerations for Client Processing Data Update Messages**

일반적으로 ALTO 클라이언트가 리소스에 대한 전체 교체를 수신하면 ALTO 클라이언트는 현재 버전을 새 버전으로 교체해야 합니다. ALTO 클라이언트가 리소스에 대한 증분 변경 사항을 수신하면 ALTO 클라이언트는 해당 패치를 리소스의 현재 버전에 적용해야 합니다.

그러나 리소스는 다른 리소스에 의존할 수 있으므로\(예: 비용 맵은 네트워크 맵에 따라 다름\) ALTO 클라이언트는 의존하는 리소스가 변경된 경우 종속 리소스를 사용해서는 안 됩니다. ALTO 클라이언트가 이를 수행할 수 있는 방법에는 최소한 두 가지가 있습니다. 다음 단락에서는 네트워크 및 비용 맵 메시지를 참조하여 이러한 기술을 설명합니다. 단, 이러한 기술은 모든 종속 리소스에 적용됩니다.\(MUST NOT\)

네트워크 맵이 변경되면 업데이트 스트림 서버는 종속 비용 맵에 대한 업데이트를 보내기 전에 네트워크 맵 업데이트 메시지를 보내야 합니다\(섹션 6.7.1 참조\).\(MUST\)

한 가지 접근 방식은 ALTO 클라이언트가 네트워크 맵 업데이트 메시지를 버퍼에 저장하고 ALTO 클라이언트가 모든 종속 비용 맵에 대한 업데이트 메시지를 수신할 때까지 이전 네트워크 맵 및 관련 비용 맵을 계속 사용하는 것입니다. 그런 다음 ALTO 클라이언트는 모든 네트워크 및 비용 맵 업데이트를 원자적으로 적용합니다.

또는 ALTO 클라이언트가 네트워크 맵을 즉시 업데이트할 수도 있습니다. 이 경우 네트워크 맵을 사용하는 비용 맵은 현재 네트워크 맵과 일치하지 않으므로 유효하지 않게 됩니다. 따라서 ALTO 클라이언트는 각 종속 비용 맵을 일시적으로 유효하지 않은 것으로 표시해야 하며 ALTO 클라이언트가 새 네트워크 맵 버전 태그를 기반으로 함을 나타내는 비용 맵 업데이트 메시지를 수신할 때까지 이러한 각 비용 맵을 사용해서는 안 됩니다.\(MAY, MUST NOT\)

업데이트 스트림 서버는 적시에 종속 리소스\(즉, 이전 예의 비용 맵\)에 대한 업데이트를 보내야 합니다\(SHOULD\). 그러나 ALTO 클라이언트가 예상 업데이트를 수신하지 못하는 경우 간단한 복구 방법은 ALTO 클라이언트가 업데이트 스트림 연결을 닫고 종속 리소스를 삭제한 후 업데이트 스트림을 다시 설정하는 것입니다. ALTO 클라이언트는 태그가 지정된 리소스의 마지막 버전의 버전 태그를 유지하고 새 업데이트 스트림을 요청할 때 해당 버전 태그를 제공할 수 있습니다. 이 경우 버전이 아직 최신이면 업데이트 스트림 서버는 해당 리소스를 다시 보내지 않습니다.\(SHOULD, MAY\)

가능한 한 효율적이지는 않지만 이 복구 방법은 간단하고 안정적입니다.

---
### **9.3.  Considerations for Updates to Filtered Cost Maps**

업데이트 스트림이 제약 조건 테스트를 허용하는 필터링된 비용 맵에 대한 업데이트를 제공하는 경우 ALTO 클라이언트는 제약 조건 테스트를 통해 필터링된 비용 맵 요청에 대한 업데이트를 요청할 수 있습니다. 이 경우 비용이 변경되면 업데이트 스트림 서버는 새 값이 테스트를 만족하는 경우 업데이트를 보내야 합니다. 새 값이 그렇지 않은 경우 업데이트 스트림 서버가 업데이트를 보낼지 여부는 이전 값이 테스트를 충족했는지 여부에 따라 달라집니다. 그렇지 않은 경우 업데이트 스트림 서버는 ALTO 클라이언트에 업데이트를 보내서는 안 됩니다. 그러나 이전 값이 그랬다면 업데이트 스트림 서버는 이 비용이 더 이상 기준을 충족하지 않는다는 것을 ALTO 클라이언트에 알리기 위해 "null" 값이 포함된 업데이트를 보내야 합니다.\(MAY, MUST, SHOULD NOT, MUST\)

업데이트 스트림 서버는 제약 조건 테스트를 허용하지 않는 필터링된 비용 맵에 대해서만 업데이트 스트림을 제공함으로써 이러한 복잡한 동작을 처리할 필요가 없습니다.

---
### **9.4.  Considerations for Updates to Ordinal Mode Costs**

순서 모드 비용 맵의 경우 단일 비용 지점을 변경하려면 다른 많은 비용을 업데이트해야 할 수도 있습니다. 극단적인 예로, 최저 비용이 최고 비용으로 변경된다고 가정해 보겠습니다. 수치 모드 비용 맵의 경우 해당 비용 하나만 변경됩니다. 그러나 순서 모드 비용 맵의 경우 모든 비용이 변경될 수 있습니다. 이 문서에서는 업데이트 스트림 서버가 순서 모드 비용 맵에 대한 증분 업데이트를 제공하도록 허용하지만 업데이트 스트림 서버 구현자는 순서 비용에 대한 증분 업데이트가 수치 비용보다 더 복잡하다는 점을 인식해야 하며 ALTO 클라이언트는 작은 변경이 발생할 수 있음을 인식해야 합니다. 대규모 업데이트에서.

업데이트 스트림 서버는 서수 비용 맵에 대한 전체 교체만 제공하여 이러한 복잡성을 피할 수 있습니다.

---
### **9.5.  Considerations for SSE Text Formatting and Processing**

SSE는 상대적으로 적은 양의 줄 기반 텍스트 데이터로 구성된 이벤트를 위해 설계되었으며 SSE 클라이언트는 입력을 한 번에 한 줄씩 읽는 경우가 많습니다. 그러나 업데이트 스트림은 전체 비용 맵을 단일 이벤트로 전송하며 비용 맵에는 수십 메가바이트는 아니더라도 메가바이트의 텍스트가 포함될 수 있습니다. 이는 ALTO 클라이언트와 업데이트 스트림 서버가 고려할 수 있는 의미를 갖습니다.

첫째, 일부 SSE 클라이언트 라이브러리는 이벤트에 대한 모든 데이터를 메모리로 읽은 다음 이를 클라이언트에 문자 배열로 제공합니다. 그러나 클라이언트에는 대규모 비용 맵에 대한 전체 JSON 텍스트를 보관할 메모리가 충분하지 않을 수 있습니다. 따라서 ALTO 클라이언트는 이벤트 데이터를 관리 가능한 청크로 표시하는 SSE 라이브러리 사용을 고려해야 합니다. 그러면 ALTO 클라이언트는 비용 맵을 점진적으로 구문 분석하고 기본 데이터를 보다 컴팩트한 형식으로 저장할 수 있습니다.\(SHOULD\)

둘째, SSE 클라이언트 라이브러리는 상위 수준 파서가 프로토콜 형식 지정의 일부로 줄 구분 기호를 필요로 하는 경우를 대비해 이벤트 데이터의 각 줄을 저장하는 낮은 수준의 일반 소켓 읽기 라이브러리를 사용할 수 있습니다. 완전한 비용 맵을 단일 라인으로 전송하는 서버는 수 메가바이트의 데이터 "라인"을 생성할 수 있으며, 이렇게 긴 라인은 클라이언트에서 복잡한 메모리 관리를 요구할 수 있습니다. 업데이트 스트림 서버가 데이터 라인의 길이를 제한하는 것이 권장됩니다.\(SHOULD\)

셋째, SSE 서버는 라이브러리를 사용할 수 있으며, 이는 ALTO 업데이트에 대한 의미론적 결과를 가져올 수 있는 위치에 줄 바꿈을 배치할 수 있습니다. 섹션 11을 참조하십시오. 업데이트 스트림 서버 구현은 의미를 변경하기 위해 줄 바꿈이 도입되지 않도록 해야 합니다.\(MUST\)

---
## **10.  Security Considerations**

기본 프로토콜의 보안 고려 사항\(\[RFC7285\] 섹션 15\)이 이 확장에 완전히 적용됩니다. 예를 들어, 동일한 신뢰성 및 무결성 고려 사항\(\[RFC7285\]의 섹션 15.1\)이 여전히 완전히 적용됩니다. ALTO 사용자의 개인 정보 보호에 대한 동일한 고려 사항\(\[RFC7285\]의 섹션 15.4\)도 여전히 완전히 적용됩니다.

이 확장이 제공하는 추가 서비스\(업데이트 스트림 및 스트림 제어 URI의 추가\)는 \[RFC7285\]의 섹션 15.1.1에 설명된 공격 표면을 확장합니다. 아래에서는 추가 위험과 해결 방법에 대해 설명합니다.

---
### **10.1.  Update Stream Server: Denial-of-Service Attacks**

지속적인 업데이트 스트림 연결을 허용하면 새로운 종류의 서비스 거부 공격이 가능해집니다.

업데이트 스트림 서버의 경우 ALTO 클라이언트는 무리한 수의 업데이트 스트림 연결을 생성하거나 하나의 업데이트 스트림에 무리한 수의 하위 스트림 ID를 추가할 수 있습니다.

업데이트 스트림 서버에 대한 이러한 공격을 방지하려면 서버는 활성 스트림 수를 제한하고 해당 임계값에 도달할 때 새 요청을 거부하도록 선택해야 합니다. 또한 업데이트 스트림 서버는 특정 스트림에서 활성 하위 스트림 ID 수를 제한하거나 스트림 수명 동안 사용되는 총 하위 스트림 ID 수를 제한하고 해당 제한을 초과하는 모든 스트림 제어 요청을 거부하도록 선택해야 합니다\(SHOULD\). 이러한 경우 업데이트 스트림 서버는 HTTP 상태 "503 서비스를 사용할 수 없음"을 반환해야 합니다.\(SHOULD, SHOULD, SHOULD\)

위의 접근 방식이 유일한 가능성은 아니라는 점에 유의하는 것이 중요합니다. 예를 들어, 업데이트 스트림 서버가 IP 평판, 속도 제한 및 전체 임계값을 잠재 클라이언트의 하위 집합에 적용되는 더 작은 임계값으로 분류하는 것과 관련된 좀 더 영리한 논리를 사용하는 것이 가능할 수 있습니다.

이전 기술은 업데이트 스트림 DoS 공격이 업데이트 스트림 서버의 다른 서비스를 방해하는 것을 방지하지만 DoS 공격이 업데이트 스트림 서비스를 더 쉽게 방해할 수 있게 해줍니다. 따라서 업데이트 스트림 서버는 \[RFC7285\]의 섹션 15에 설명된 대로 업데이트 스트림 서비스를 인증된 클라이언트로 제한하는 것을 선호할 수 있습니다.\(MAY\)

또는 업데이트 스트림 서버는 HTTP 상태 "307 임시 리디렉션"을 반환하여 클라이언트를 많은 수의 업데이트 스트림을 더 잘 처리할 수 있는 다른 ALTO 서버로 리디렉션할 수 있습니다.\(MAY\)

---
### **10.2.  ALTO Client: Update Overloading or Instability**

지속적인 업데이트가 가능하면 ALTO 클라이언트, 특히 처리 기능이 제한된 ALTO 클라이언트에 과부하가 발생할 수도 있습니다. 현재 설계에는 클라이언트가 서버의 업데이트 속도를 줄이기 위한 흐름 제어 메커니즘이 포함되어 있지 않습니다. 과부하 상태에서 클라이언트는 업데이트 속도가 높은 정보 리소스를 제거하도록 선택할 수 있습니다.\(MAY\)

또한 과부하가 발생하면 클라이언트는 정보가 여전히 최신인지 또는 오래되었는지 여부를 더 이상 감지하지 못할 수 있습니다. 이러한 경우 클라이언트는 안정성이나 효율성 문제를 피하기 위해 정보를 사용하는 방법에 주의해야 합니다.

10.3. 스트림 제어: 스푸핑된 제어 요청 및 정보 분석

업데이트 스트림 응답을 읽을 수 있거나 스트림 제어 요청을 관찰할 수 있는 외부 당사자는 제어 URI를 획득하고 이를 사용하여 사기성 "제거" 요청을 보내 유효한 ALTO 클라이언트에 대한 업데이트를 비활성화할 수 있습니다. 이는 업데이트 스트림 및 스트림 제어 요청을 암호화하여 방지할 수 있습니다\(\[RFC7285\]의 섹션 15 참조\). 또한 업데이트 스트림 서버는 업데이트 스트림에서 "제거" 요청을 에코하므로 유효한 ALTO 클라이언트는 승인되지 않은 요청을 감지할 수 있습니다.

일반적으로 아키텍처에서는 업데이트 스트림 서버와 스트림 제어 서버가 서로 다른 엔터티일 가능성을 허용하므로 추가 위험을 평가하고 해결해야 합니다. 예를 들어, 서버 간의 개인 통신 경로가 공격을 받아 서버 간의 통신이 중단될 위험이 있을 뿐만 아니라 해당 개인 통신 경로에 있다고 주장하는 유효하지 않거나 스푸핑된 메시지가 발생할 수 있습니다. 기밀성, 신뢰성, 무결성 메커니즘을 포함한 적절한 보안 메커니즘을 고려해야 합니다.

---
## **11.  Requirements on Future ALTO Services to Use This Design**

이 디자인은 매우 유연하지만 기본 요구 사항이 있습니다.

주요 요구 사항은 \(1\) 각 데이터 업데이트 메시지가 단일 리소스에 대한 것이고 \(2\) JSON 병합 패치와 JSON 패치가 모두 단일 JSON 개체인 리소스에만 증분 변경 사항을 적용할 수 있다는 것입니다. 단일 JSON 개체. 따라서 향후 ALTO 리소스에 여러 개체가 포함될 수 있는 경우 각 개별 개체에도 리소스 ID가 있거나 이 디자인이 확장됩니다.

낮은 수준의 인코딩 수준에서 SSE의 새 줄에는 고유한 의미가 있습니다. 따라서 이 설계에서는 리소스 인코딩에 SSE 인코딩과 혼동될 수 있는 새 줄이 포함되지 않아야 합니다. 특히, 데이터 업데이트 메시지는 데이터 메시지의 일부로 새 줄에 "event: " 또는 "data: "를 포함해서는 안 됩니다.\(MUST NOT\)

업데이트 스트림이 제약 조건 테스트를 허용하는 필터링된 비용 맵에 대한 업데이트를 제공하는 경우 해당 서비스에 대한 요구 사항은 섹션 9.3에 명시되어 있습니다.

---
## **12.  IANA Considerations**

이 문서는 섹션 6.5에 설명된 "application/alto-updatestreamparams+json"과 섹션 5.3에 설명된 "application/alto-updatestreamcontrol+json"이라는 두 가지 새로운 미디어 유형을 정의합니다. 이 문서에 사용된 다른 모든 미디어 유형은 ALTO, JSON 병합 패치 또는 JSON 패치에 이미 등록되어 있습니다.

---
### **12.1.  application/alto-updatestreamparams+json Media Type**

```text
   Type name:  application

   Subtype name:  alto-updatestreamparams+json

   Required parameters:  N/A

   Optional parameters:  N/A
```

인코딩 고려 사항: 인코딩 고려 사항은 "application/json" 미디어 유형에 지정된 것과 동일합니다. \[RFC8259\]를 참조하세요.

보안 고려 사항: ALTO 프로토콜 메시지의 생성 및 소비와 관련된 보안 고려 사항은 RFC 8895의 섹션 10 및 \[RFC7285\]의 섹션 15에서 논의됩니다.

상호 운용성 고려 사항: RFC 8895는 적합한 메시지의 형식과 그에 대한 해석을 지정합니다.

게시된 사양: RFC 8895의 섹션 6.5.

이 미디어 유형을 사용하는 애플리케이션: ALTO 서버 및 ALTO 클라이언트는 독립형이거나 다른 애플리케이션 내에 내장되어 있습니다.

```text
   Fragment identifier considerations:  N/A

   Additional information:
```

- 이 유형에 대해 더 이상 사용되지 않는 별칭 이름: 해당 없음

```text
      Magic number(s):  N/A
```

- 파일 확장자: RFC 8895는 미디어 유형을 사용하여 프로토콜 메시지를 참조하므로 파일 확장자가 필요하지 않습니다.

```text
      Macintosh file type code(s):  N/A
```

자세한 내용은 연락할 사람 및 이메일 주소: 저자 주소 섹션을 참조하세요.

```text
   Intended usage:  COMMON
```

사용 제한: 해당 없음

```text
   Author:  See Authors' Addresses section.

   Change controller:  Internet Engineering Task Force
      (mailto:iesg@ietf.org).
```

---
### **12.2.  application/alto-updatestreamcontrol+json Media Type**

```text
   Type name:  application

   Subtype name:  alto-updatestreamcontrol+json

   Required parameters:  N/A

   Optional parameters:  N/A
```

인코딩 고려 사항: 인코딩 고려 사항은 "application/json" 미디어 유형에 지정된 것과 동일합니다. \[RFC8259\]를 참조하세요.

보안 고려 사항: ALTO 프로토콜 메시지의 생성 및 소비와 관련된 보안 고려 사항은 RFC 8895의 섹션 10 및 \[RFC7285\]의 섹션 15에서 논의됩니다.

상호 운용성 고려 사항: RFC 8895는 적합한 메시지의 형식과 그에 대한 해석을 지정합니다.

게시된 사양: RFC 8895의 섹션 5.3.

이 미디어 유형을 사용하는 애플리케이션: ALTO 서버 및 ALTO 클라이언트는 독립형이거나 다른 애플리케이션 내에 내장되어 있습니다.

```text
   Fragment identifier considerations:  N/A

   Additional information:
```

- 이 유형에 대해 더 이상 사용되지 않는 별칭 이름: 해당 없음

```text
      Magic number(s):  N/A
```

- 파일 확장자: RFC 8895는 미디어 유형을 사용하여 프로토콜 메시지를 참조하므로 파일 확장자가 필요하지 않습니다.

```text
      Macintosh file type code(s):  N/A
```

자세한 내용은 연락할 사람 및 이메일 주소: 저자 주소 섹션을 참조하세요.

```text
   Intended usage:  COMMON
```

사용 제한: 해당 없음

```text
   Author:  See Authors' Addresses section.

   Change controller:  Internet Engineering Task Force
      (mailto:iesg@ietf.org).
```

---
## **13.  Appendix: Design Decision: Not Allowing Stream Restart**

업데이트 스트림이 실수로 닫힌 경우 ALTO 클라이언트가 다시 연결될 때 업데이트 스트림 서버는 전체 맵을 다시 보내야 합니다. 이는 분명히 비효율적입니다. 이러한 비효율성을 피하기 위해 SSE 사양에서는 업데이트 스트림 서버가 각 이벤트에 ID를 할당할 수 있도록 허용합니다. ALTO 클라이언트가 다시 연결되면 ALTO 클라이언트는 마지막으로 성공적으로 수신된 이벤트의 ID를 제공할 수 있으며 업데이트 스트림 서버는 다음 이벤트로 다시 시작됩니다.

그러나 해당 메커니즘으로 인해 복잡성이 추가됩니다. 업데이트 스트림 서버는 ALTO 클라이언트가 다시 연결되는 경우 SSE 메시지를 버퍼에 저장해야 합니다. 그러나 해당 메커니즘은 결코 완벽하지 않습니다. ALTO 클라이언트가 다시 연결하는 데 너무 오래 기다리거나 ALTO 클라이언트가 잘못된 ID를 보내는 경우 어쨌든 업데이트 스트림 서버는 전체 맵을 다시 보내야 합니다.

게다가 이는 실제로 문제가 될 가능성도 없습니다. 전체 네트워크 및 비용 지도와 같은 대규모 리소스에 대한 지속적인 업데이트를 원하는 ALTO 클라이언트는 P2P 추적기와 같은 것일 가능성이 높습니다. 이러한 ALTO 클라이언트는 네트워크에 잘 연결됩니다. 연결이 거의 끊어지지 않습니다.

모바일 장치는 분명히 연결을 끊을 수 있으며 다시 연결해야 합니다. 그러나 모바일 장치에는 메가바이트 비용 지도에 대한 지속적인 업데이트가 필요하지 않습니다. 모바일 장치에 지속적인 업데이트가 필요한 경우 장치가 현재 재생 중인 영화를 스트리밍할 수 있는 소규모 미디어 서버 세트의 비용과 같은 작은 쿼리에 업데이트가 필요합니다. 모바일 장치가 연결을 끊고 업데이트 스트림을 다시 설정하는 경우 업데이트 스트림 서버는 소량의 중복 데이터만 다시 전송해야 합니다.

간단히 말해서, 이벤트 ID를 사용하여 전체 지도를 다시 보내는 것을 방지하면 매우 드문 상황을 피하기 위해 상당한 복잡성이 추가됩니다. 복잡성은 이점을 누릴 가치가 없습니다.

업데이트 스트림 서비스를 사용하면 ALTO 클라이언트가 태그가 지정된 리소스의 마지막으로 수신된 버전의 태그를 지정할 수 있으며, 해당 버전이 여전히 최신인 경우 업데이트 스트림 서버는 전체 리소스를 재전송할 필요가 없습니다. 따라서 ALTO 클라이언트는 이를 사용하여 전체 네트워크 맵의 재전송을 방지할 수 있습니다. 비용 맵에는 태그가 지정되지 않으므로 해당 맵에는 작동하지 않습니다. 물론 비용 맵에 버전 태그를 추가하여 ALTO 프로토콜을 확장할 수 있으며, 이를 통해 재연결 시 재전송 문제를 해결할 수 있습니다. 그러나 비용 맵에 태그를 추가하면 새로운 문제가 추가될 수 있습니다.

---
## **14.  References**
---
### **14.1.  Normative References**

```text
   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", BCP 14, RFC 2119,
              DOI 10.17487/RFC2119, March 1997,
              <https://www.rfc-editor.org/info/rfc2119>.

   [RFC2387]  Levinson, E., "The MIME Multipart/Related Content-type",
              RFC 2387, DOI 10.17487/RFC2387, August 1998,
              <https://www.rfc-editor.org/info/rfc2387>.

   [RFC3986]  Berners-Lee, T., Fielding, R., and L. Masinter, "Uniform
              Resource Identifier (URI): Generic Syntax", STD 66,
              RFC 3986, DOI 10.17487/RFC3986, January 2005,
              <https://www.rfc-editor.org/info/rfc3986>.

   [RFC6838]  Freed, N., Klensin, J., and T. Hansen, "Media Type
              Specifications and Registration Procedures", BCP 13,
              RFC 6838, DOI 10.17487/RFC6838, January 2013,
              <https://www.rfc-editor.org/info/rfc6838>.

   [RFC6902]  Bryan, P., Ed. and M. Nottingham, Ed., "JavaScript Object
              Notation (JSON) Patch", RFC 6902, DOI 10.17487/RFC6902,
              April 2013, <https://www.rfc-editor.org/info/rfc6902>.

   [RFC7285]  Alimi, R., Ed., Penno, R., Ed., Yang, Y., Ed., Kiesel, S.,
              Previdi, S., Roome, W., Shalunov, S., and R. Woundy,
              "Application-Layer Traffic Optimization (ALTO) Protocol",
              RFC 7285, DOI 10.17487/RFC7285, September 2014,
              <https://www.rfc-editor.org/info/rfc7285>.

   [RFC7396]  Hoffman, P. and J. Snell, "JSON Merge Patch", RFC 7396,
              DOI 10.17487/RFC7396, October 2014,
              <https://www.rfc-editor.org/info/rfc7396>.

   [RFC8174]  Leiba, B., "Ambiguity of Uppercase vs Lowercase in RFC
              2119 Key Words", BCP 14, RFC 8174, DOI 10.17487/RFC8174,
              May 2017, <https://www.rfc-editor.org/info/rfc8174>.

   [RFC8259]  Bray, T., Ed., "The JavaScript Object Notation (JSON) Data
              Interchange Format", STD 90, RFC 8259,
              DOI 10.17487/RFC8259, December 2017,
              <https://www.rfc-editor.org/info/rfc8259>.

   [SSE]      Hickson, I., "Server-Sent Events", W3C Recommendation,
              February 2015, <https://www.w3.org/TR/eventsource/>.
```

---
### **14.2.  Informative References**

```text
   [RFC4960]  Stewart, R., Ed., "Stream Control Transmission Protocol",
              RFC 4960, DOI 10.17487/RFC4960, September 2007,
              <https://www.rfc-editor.org/info/rfc4960>.

   [RFC5789]  Dusseault, L. and J. Snell, "PATCH Method for HTTP",
              RFC 5789, DOI 10.17487/RFC5789, March 2010,
              <https://www.rfc-editor.org/info/rfc5789>.

   [RFC7230]  Fielding, R., Ed. and J. Reschke, Ed., "Hypertext Transfer
              Protocol (HTTP/1.1): Message Syntax and Routing",
              RFC 7230, DOI 10.17487/RFC7230, June 2014,
              <https://www.rfc-editor.org/info/rfc7230>.

   [RFC7231]  Fielding, R., Ed. and J. Reschke, Ed., "Hypertext Transfer
              Protocol (HTTP/1.1): Semantics and Content", RFC 7231,
              DOI 10.17487/RFC7231, June 2014,
              <https://www.rfc-editor.org/info/rfc7231>.

   [RFC7540]  Belshe, M., Peon, R., and M. Thomson, Ed., "Hypertext
              Transfer Protocol Version 2 (HTTP/2)", RFC 7540,
              DOI 10.17487/RFC7540, May 2015,
              <https://www.rfc-editor.org/info/rfc7540>.
```

---
# **Acknowledgments**

이 문서의 이전 버전에 기여한 Dawn Chen\(Tongji University\), Shawn Lin\(Tongji University\) 및 Xiao Shi\(Yale University\)에게 감사드립니다.

---
# **Contributors**

이 문서의 섹션 2, 5.1, 5.2 및 8.5는 Jingxuan Jensen Zhang의 기여를 기반으로 하며 그는 저자로 간주됩니다.

---
# **Authors' Addresses**

Wendy Roome Nokia Bell Labs\(은퇴\) 124 Burlington Rd Murray Hill, NJ 07974 미국

```text
   Phone: +1-908-464-6975
   Email: wendy@wdroome.com
```

Y. Richard Yang Yale University 51 Prospect St New Haven, CT 미국

```text
   Email: yry@cs.yale.edu
```
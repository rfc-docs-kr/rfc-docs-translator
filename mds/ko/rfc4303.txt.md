

```text
Network Working Group                                            S. Kent
Request for Comments: 4303                              BBN Technologies
Obsoletes: 2406                                            December 2005
Category: Standards Track

                IP Encapsulating Security Payload (ESP)
```

---
# **Status of This Memo**

이 문서는 인터넷 커뮤니티를 위한 인터넷 표준 추적 프로토콜을 지정하고 개선을 위한 토론 및 제안을 요청합니다. 이 프로토콜의 표준화 상태 및 상태에 대해서는 "Internet Official Protocol Standards"\(STD 1\) 최신판을 참조하십시오. 이 메모의 배포는 무제한입니다.

---
# **Copyright Notice**

Copyright \(C\) The Internet Society \(2005\).

---
# **Abstract**

이 문서에서는 IPv4와 IPv6에서 혼합된 보안 서비스를 제공하도록 설계된 ESP\(Encapslating Security Payload\) 프로토콜의 업데이트된 버전에 대해 설명합니다. ESP는 기밀성, 데이터 원본 인증, 연결 없는 무결성, 재생 방지 서비스\(부분 시퀀스 무결성의 한 형태\) 및 제한된 트래픽 흐름 기밀성을 제공하는 데 사용됩니다. 이 문서는 RFC 2406\(1998년 11월\)을 폐기합니다.

---
# **Table of Contents**

```text
   1. Introduction ....................................................3
   2. Encapsulating Security Payload Packet Format ....................5
      2.1. Security Parameters Index (SPI) ...........................10
      2.2. Sequence Number ...........................................12
           2.2.1. Extended (64-bit) Sequence Number ..................12
      2.3. Payload Data ..............................................13
      2.4. Padding (for Encryption) ..................................14
      2.5. Pad Length ................................................15
      2.6. Next Header ...............................................16
      2.7. Traffic Flow Confidentiality (TFC) Padding ................17
      2.8. Integrity Check Value (ICV) ...............................17
   3. Encapsulating Security Protocol Processing .....................18
      3.1. ESP Header Location .......................................18
           3.1.1. Transport Mode Processing ..........................18
           3.1.2. Tunnel Mode Processing .............................19
      3.2. Algorithms ................................................20
           3.2.1. Encryption Algorithms ..............................21
           3.2.2. Integrity Algorithms ...............................21
           3.2.3. Combined Mode Algorithms ...........................22
      3.3. Outbound Packet Processing ................................22
           3.3.1. Security Association Lookup ........................22
           3.3.2. Packet Encryption and Integrity Check Value
                  (ICV) Calculation ..................................22
                  3.3.2.1. Separate Confidentiality and
                           Integrity Algorithms ......................23
                  3.3.2.2. Combined Confidentiality and
                           Integrity Algorithms ......................24
           3.3.3. Sequence Number Generation .........................25
           3.3.4. Fragmentation ......................................26
      3.4. Inbound Packet Processing .................................27
           3.4.1. Reassembly .........................................27
           3.4.2. Security Association Lookup ........................27
           3.4.3. Sequence Number Verification .......................28
           3.4.4. Integrity Check Value Verification .................30
                  3.4.4.1. Separate Confidentiality and
                           Integrity Algorithms ......................30
                  3.4.4.2. Combined Confidentiality and
                           Integrity Algorithms ......................32
   4. Auditing .......................................................33
   5. Conformance Requirements .......................................34
   6. Security Considerations ........................................34
   7. Differences from RFC 2406 ......................................34
   8. Backward-Compatibility Considerations ..........................35
   9. Acknowledgements ...............................................36
   10. References ....................................................36
      10.1. Normative References .....................................36
      10.2. Informative References ...................................37
   Appendix A: Extended (64-bit) Sequence Numbers ....................38
      A1. Overview ...................................................38
      A2. Anti-Replay Window .........................................38
          A2.1. Managing and Using the Anti-Replay Window ............39
          A2.2. Determining the Higher-Order Bits (Seqh) of the
                Sequence Number ......................................40
          A2.3. Pseudo-Code Example ..................................41
      A3. Handling Loss of Synchronization due to Significant
          Packet Loss ................................................42
          A3.1. Triggering Re-synchronization ........................43
          A3.2. Re-synchronization Process ...........................43
```

---
## **1.  Introduction**

이 문서는 독자가 "인터넷 프로토콜에 대한 보안 아키텍처"\[Ken-Arch\]\(이하 보안 아키텍처 문서라고 함\)에 설명된 용어와 개념에 익숙하다고 가정합니다. 특히, 독자는 ESP\(Encapsulation Security Payload\)와 ​​AH\(IP Authentication Header\)가 제공하는 보안 서비스의 정의, 보안 연관의 개념, ESP를 AH와 함께 사용할 수 있는 방식에 대해 잘 알고 있어야 합니다. , ESP 및 AH에 사용할 수 있는 다양한 키 관리 옵션이 있습니다.

이 문서에 나타나는 키워드 MUST, MUST NOT, REQUIRED, SHALL, SHALL NOT, SHOULD, SHOULD NOT, RECOMMENDED, MAY 및 OPTIONAL은 RFC 2119 \[Bra97\]에 설명된 대로 해석됩니다.\(MUST NOT\)

ESP\(Encapslating Security Payload\) 헤더는 IPv4와 IPv6 \[DH98\]에서 혼합된 보안 서비스를 제공하도록 설계되었습니다. ESP는 AH \[Ken-AH\]와 결합하여 단독으로 적용하거나 중첩된 방식으로 적용할 수 있습니다\(보안 아키텍처 문서 \[Ken-Arch\] 참조\). 통신하는 호스트 쌍 사이, 통신하는 보안 게이트웨이 쌍 사이, 보안 게이트웨이와 호스트 사이에 보안 서비스가 제공될 수 있다. 다양한 네트워크 환경에서 ESP 및 AH를 사용하는 방법에 대한 자세한 내용은 보안 아키텍처 문서 \[Ken-Arch\]를 참조하세요.

ESP 헤더는 IP 헤더 뒤, 다음 계층 프로토콜 헤더 앞\(전송 모드\) 또는 캡슐화된 IP 헤더 앞\(터널 모드\)에 삽입됩니다. 이러한 모드는 아래에 더 자세히 설명되어 있습니다.

ESP는 기밀성, 데이터 원본 인증, 연결 없는 무결성, 재생 방지 서비스\(부분 시퀀스 무결성의 한 형태\) 및 \(제한된\) 트래픽 흐름 기밀성을 제공하는 데 사용될 수 있습니다. 제공되는 서비스 세트는 SA\(보안 연결\) 설정 시 선택한 옵션과 네트워크 토폴로지의 구현 위치에 따라 달라집니다.

ESP에서는 기밀성을 위해 암호화 전용을 사용하는 것이 허용됩니다. 그러나 일반적으로 이는 수동적 공격자에 대해서만 방어를 제공한다는 점에 유의해야 합니다. 강력한 무결성 메커니즘 없이 암호화를 사용하면\(ESP에서 또는 별도로 AH를 통해\) 기밀성 서비스가 일부 형태의 활성 공격에 대해 안전하지 않게 될 수 있습니다\[Bel96, Kra01\]. 또한, 암호화 이전에 적용되는 AH와 같은 기본 무결성 서비스는 적극적인 공격자로부터 암호화 전용 기밀성을 반드시 보호하지는 않습니다\[Kra01\]. ESP는 암호화 전용 SA를 허용합니다. 이는 훨씬 더 나은 성능을 제공하면서도 여전히

적절한 보안\(예: 상위 계층 인증/무결성 보호가 독립적으로 제공되는 경우\) 그러나 이 표준에서는 암호화 전용 서비스를 제공하기 위해 ESP 구현을 요구하지 않습니다.

데이터 출처 인증과 비연결 무결성은 공동 서비스이며, 이하 "무결성"으로 통칭합니다. \(이 용어는 패킷 단위로 수행되는 계산이 연결 없는 무결성을 직접 제공하기 때문에 사용됩니다. 무결성을 확인하는 데 사용되는 키를 IPsec 피어의 ID에 바인딩한 결과 데이터 원본 인증이 간접적으로 제공됩니다. 일반적으로 , 이 바인딩은 공유된 대칭 키를 사용하여 적용됩니다.\) 무결성 전용 ESP는 서비스 선택 옵션으로 제공되어야 합니다. 예를 들어 SA 관리 프로토콜에서 협상 가능해야 하며 관리 인터페이스를 통해 구성 가능해야 합니다. 무결성 전용 ESP는 처리 속도가 더 빠르고 많은 구현에서 파이프라인에 더 적합하기 때문에 여러 상황에서 AH에 대한 매력적인 대안입니다.\(MUST\)

기밀성과 무결성은 독립적으로 제공될 수 있지만 ESP는 일반적으로 두 서비스를 모두 사용합니다. 즉, 패킷은 기밀성과 무결성과 관련하여 보호됩니다. 따라서 이러한 서비스와 관련된 ESP 보안 서비스 조합에는 세 가지가 있습니다.

```text
            - confidentiality-only (MAY be supported)
            - integrity only (MUST be supported)
            - confidentiality and integrity (MUST be supported)
```

해당 SA에 대해 무결성 서비스가 선택된 경우에만 재생 방지 서비스가 해당 SA에 대해 선택될 수 있습니다. 이 서비스의 선택은 전적으로 수신자의 재량이므로 협상이 필요하지 않습니다. 그러나 상호 운용 가능한 방식으로 확장된 시퀀스 번호 기능을 사용하기 위해 ESP는 SA 관리 프로토콜에 이 기능을 협상할 수 있는 요구 사항을 부과합니다\(아래 섹션 2.2.1 참조\).

TFC\(트래픽 흐름 기밀성\) 서비스는 일반적으로 보안 게이트웨이 간의 터널 모드와 같이 통신 상대의 최종 소스 및 대상 주소를 숨기는 방식으로 ESP가 사용되는 경우와 IPsec 피어\(둘 중 하나\) 간에 충분한 트래픽이 흐르는 경우에만 효과적입니다. 자연적으로 또는 마스킹 트래픽 생성의 결과\) 특정 개별 가입자 트래픽 흐름의 특성을 숨기기 위해. \(ESP는 상위 계층 TFC 시스템\(예: Onion Routing \[Syverson\]\)의 일부로 사용될 수 있지만 이러한 시스템은 이 표준의 범위를 벗어납니다.\) ESP에 있는 새로운 TFC 기능은 더미 트래픽의 효율적인 생성 및 폐기를 촉진하고 이전 버전과 호환되는 방식으로 실제 트래픽을 더 효과적으로 패딩합니다.

섹션 7에서는 이 문서와 RFC 2406 간의 차이점을 간략하게 검토합니다.

---
## **2.  Encapsulating Security Payload Packet Format**

ESP 헤더 바로 앞에 있는 \(외부\) 프로토콜 헤더\(IPv4, IPv6 또는 확장\)는 프로토콜\(IPv4\) 또는 다음 헤더\(IPv6, 확장\) 필드에 값 50을 포함해야 합니다\(http://의 IANA 웹 페이지 참조\). www.iana.org/locationments/protocol-numbers\). 그림 1은 ESP 패킷의 최상위 형식을 보여줍니다. 패킷은 두 개의 4바이트 필드\(SPI\(보안 매개변수 색인\) 및 시퀀스 번호\)로 시작됩니다. 이러한 필드 다음에는 암호화 알고리즘 및 모드 선택과 TFC 패딩 사용에 따라 달라지는 하위 구조를 갖는 페이로드 데이터가 있으며 이에 대해서는 나중에 자세히 살펴보겠습니다. 페이로드 데이터 다음에는 패딩 및 패드 길이 필드와 다음 헤더 필드가 있습니다. 선택적 ICV\(무결성 검사 값\) 필드가 패킷을 완성합니다.\(MUST\)

```text
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ ----
|               Security Parameters Index (SPI)                 | ^Int.
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |Cov-
|                      Sequence Number                          | |ered
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | ----
|                    Payload Data* (variable)                   | |   ^
~                                                               ~ |   |
|                                                               | |Conf.
+               +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |Cov-
|               |     Padding (0-255 bytes)                     | |ered*
+-+-+-+-+-+-+-+-+               +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |   |
|                               |  Pad Length   | Next Header   | v   v
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ ------
|         Integrity Check Value-ICV   (variable)                |
~                                                               ~
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

- 그림 1. ESP 패킷의 최상위 형식

\* 페이로드 필드에 포함된 경우 암호화 동기화 데이터\(예: 초기화 벡터\(IV, 섹션 2.3 참조\)\)는 일반적으로 암호문의 일부로 참조되지만 그 자체로는 암호화되지 않습니다.

\(전송된\) ESP 트레일러는 Padding, Pad Length 및 Next Header 필드로 구성됩니다. 아래 설명된 대로 추가 암시적 ESP 트레일러 데이터\(전송되지 않음\)가 무결성 계산에 포함됩니다.

무결성 서비스를 선택한 경우 무결성 계산에는 SPI, 시퀀스 번호, 페이로드 데이터 및 ESP 트레일러\(명시적 및 암시적\)가 포함됩니다.

기밀 유지 서비스를 선택한 경우 암호 텍스트는 페이로드 데이터\(포함될 수 있는 암호화 동기화 데이터 제외\)와 \(명시적\) ESP 트레일러로 구성됩니다.

위에서 언급한 것처럼 페이로드 데이터는 하위 구조를 가질 수 있습니다. 명시적인 IV\(초기화 벡터\)가 필요한 암호화 알고리즘\(예: CBC\(암호 블록 체인\) 모드\)은 종종 보호할 페이로드 데이터 앞에 해당 값을 추가합니다. 일부 알고리즘 모드는 암호화와 무결성을 단일 작업으로 결합합니다. 이 문서에서는 이러한 알고리즘 모드를 "결합 모드 알고리즘"이라고 합니다. 결합 모드 알고리즘을 수용하려면 알고리즘이 무결성 데이터를 전달하는 데 사용되는 페이로드 하위 구조를 명시적으로 설명해야 합니다.

일부 결합 모드 알고리즘은 암호화된 데이터에 대해서만 무결성을 제공하는 반면 다른 알고리즘은 전송을 위해 암호화되지 않은 일부 추가 데이터에 대해 무결성을 제공할 수 있습니다. SPI 및 시퀀스 번호 필드는 무결성 서비스의 일부로 무결성을 요구하고 암호화되지 않기 때문에 사용되는 결합 알고리즘 모드의 스타일에 관계없이 서비스를 선택할 때마다 무결성이 제공되는지 확인해야 합니다.

결합 모드 알고리즘을 사용하는 경우 알고리즘 자체는 해독된 일반 텍스트와 무결성 검사에 대한 통과/실패 표시를 모두 반환할 것으로 예상됩니다. 결합 모드 알고리즘의 경우 일반적으로 ESP 패킷 끝에 나타나는 ICV\(무결성이 선택된 경우\)가 생략될 수 있습니다. ICV가 생략되고 무결성이 선택된 경우 페이로드 데이터 내에서 패킷의 무결성을 확인하는 ICV와 동등한 수단을 인코딩하는 것은 결합 모드 알고리즘의 책임입니다.

결합 모드 알고리즘이 암호화된 데이터에만 무결성을 제공하는 경우 페이로드 데이터의 일부로 SPI 및 시퀀스 번호를 복제해야 합니다.

마지막으로, 페이로드 데이터 뒤와 ESP 트레일러 앞에 교통 흐름 기밀성을 위한 패딩을 삽입하는 새로운 조항이 만들어졌습니다. 그림 2는 페이로드 데이터의 하위 구조를 보여줍니다. \(참고: 이

다이어그램은 비트 온 더 와이어\(bits-on-the-wire\)를 보여줍니다. 따라서 확장된 시퀀스 번호가 사용되는 경우에도 시퀀스 번호의 32비트만 전송됩니다\(섹션 2.2.1 참조\).

```text
     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |               Security Parameters Index (SPI)                 |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                      Sequence Number                          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+---
   |                    IV (optional)                              | ^ p
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | a
   |                    Rest of Payload Data  (variable)           | | y
   ~                                                               ~ | l
   |                                                               | | o
   +               +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | a
   |               |         TFC Padding * (optional, variable)    | v d
   +-+-+-+-+-+-+-+-+         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+---
   |                         |        Padding (0-255 bytes)        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                               |  Pad Length   | Next Header   |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |         Integrity Check Value-ICV   (variable)                |
   ~                                                               ~
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

- 그림 2. 페이로드 데이터의 하위 구조

- \* 터널 모드가 사용되는 경우 IPsec 구현은 페이로드 데이터 뒤와 패딩\(0-255바이트\) 필드 앞에 TFC\(Traffic Flow Confidentiality\) 패딩\(섹션 2.4 참조\)을 추가할 수 있습니다.

결합된 알고리즘 모드가 사용되는 경우 그림 1과 2에 표시된 명시적 ICV는 생략될 수 있습니다\(아래 섹션 3.3.2.2 참조\). SA가 설정되면 알고리즘과 모드가 고정되므로 SA의 모든 트래픽에 대해 특정 SA\(페이로드 데이터 하위 구조 포함\)에 대한 ESP 패킷의 세부 형식이 고정됩니다.

아래 표는 이전 그림의 필드를 참조하고 각각 다른 처리 모델을 사용하는 여러 가지 알고리즘 옵션 범주가 위에서 언급한 필드에 어떤 영향을 미치는지 보여줍니다. 처리 세부사항은 이후 섹션에서 설명됩니다.

```text
          Table 1. Separate Encryption and Integrity Algorithms
```

```text
                                            What    What    What
                          # of     Requ'd  Encrypt Integ    is
                          bytes      [1]   Covers  Covers  Xmtd
                          ------   ------  ------  ------  ------
   SPI                       4        M              Y     plain
   Seq# (low-order bits)     4        M              Y     plain       p
                                                                ------ a
   IV                     variable    O              Y     plain     | y
   IP datagram [2]        variable  M or D    Y      Y     cipher[3] |-l
   TFC padding [4]        variable    O       Y      Y     cipher[3] | o
                                                                ------ a
   Padding                 0-255      M       Y      Y     cipher[3]   d
   Pad Length                1        M       Y      Y     cipher[3]
   Next Header               1        M       Y      Y     cipher[3]
   Seq# (high-order bits)    4     if ESN [5]        Y     not xmtd
   ICV Padding            variable if need           Y     not xmtd
   ICV                    variable   M [6]                 plain
```

\[1\] M = 필수; O = 선택 사항; D = 더미

- \[2\] 터널 모드인 경우 -\> IP 데이터그램 전송 모드인 경우 -\> 다음 헤더 및 데이터 \[3\] 암호화가 선택된 경우 암호문 \[4\] 페이로드가 "실제" 길이를 지정하는 경우에만 사용할 수 있습니다. \[5\] 섹션 2.2를 참조하세요. .1 \[6\] 별도의 무결성 알고리즘이 사용되는 경우 필수

```text
                  Table 2. Combined Mode Algorithms
```

```text
                                             What    What    What
                            # of     Requ'd  Encrypt Integ    is
                            bytes      [1]   Covers  Covers  Xmtd
                            ------   ------  ------  ------  ------
    SPI                        4        M                    plain
    Seq# (low-order bits)      4        M                    plain    p
                                                                  --- a
    IV                      variable    O              Y     plain  | y
    IP datagram [2]         variable  M or D    Y      Y     cipher |-l
    TFC padding [3]         variable    O       Y      Y     cipher | o
                                                                  --- a
    Padding                  0-255      M       Y      Y     cipher   d
    Pad Length                 1        M       Y      Y     cipher
    Next Header                1        M       Y      Y     cipher
    Seq# (high-order bits)     4     if ESN [4]        Y     [5]
    ICV Padding             variable if need           Y     [5]
    ICV                     variable    O [6]                plain
```

\[1\] M = 필수; O = 선택 사항; D = 더미

- \[2\] 터널 모드인 경우 -\> IP 데이터그램 전송 모드인 경우 -\> 다음 헤더 및 데이터 \[3\] 페이로드가 "실제" 길이를 지정하는 경우에만 사용할 수 있습니다. \[4\] 섹션 2.2.1을 참조하세요. \[5\] 알고리즘 선택에 따라 결정됩니다. 전송되는지 여부는 알 수 없으나 두 경우 모두 결과는 ESP에 표시되지 않습니다. \[6\] 알고리즘 사양에 따라 이 필드가 있는지 여부가 결정됩니다.

다음 하위 섹션에서는 헤더 형식의 필드를 설명합니다. "선택적"은 옵션이 선택되지 않은 경우 필드가 생략됨을 의미합니다. 즉, 해당 필드가 전송된 패킷에 존재하지 않고 ICV 계산을 위해 형식화되지 않은 상태로도 존재하지 않습니다\(섹션 2.7 참조\). 옵션 선택 여부는 SA\(Security Association\) 설정의 일부로 결정됩니다. 따라서 특정 SA에 대한 ESP 패킷 형식은 SA 기간 동안 고정됩니다. 이와 대조적으로 "필수" 필드는 모든 SA에 대해 ESP 패킷 형식으로 항상 존재합니다.

참고: IPsec에 사용되는 모든 암호화 알고리즘은 표준 네트워크 바이트 순서로 입력을 예상하고\(RFC 791 \[Pos81\]의 부록 참조\) 출력을 표준 네트워크 바이트 순서로 생성합니다. IP 패킷도 네트워크 바이트 순서로 전송됩니다.

ESP에는 버전 번호가 포함되어 있지 않으므로 이전 버전과의 호환성에 대한 우려가 있는 경우 ESP의 호환 가능한 버전을 보장하기 위해 두 IPsec 피어 간의 신호 메커니즘을 사용하여 문제를 해결해야 합니다\(예: 인터넷 키 교환\(IKEv2\) \[Kau05\]\). 또는 대역 외 구성 메커니즘.\(MUST\)

---
### **2.1.  Security Parameters Index (SPI)**

SPI는 수신자가 수신 패킷이 바인딩된 SA를 식별하는 데 사용되는 임의의 32비트 값입니다. SPI 필드는 필수입니다.

유니캐스트 SA의 경우 SPI는 단독으로 SA를 지정하는 데 사용되거나 IPsec 프로토콜 유형\(이 경우 ESP\)과 함께 사용될 수 있습니다. SPI 값은 유니캐스트 SA에 대한 수신기에서 생성되므로 해당 값이 자체적으로 SA를 식별하는 데 충분한지 또는 IPsec 프로토콜 값과 함께 사용해야 하는지 여부는 지역적인 문제입니다. 인바운드 트래픽을 유니캐스트 SA에 매핑하는 이 메커니즘은 모든 ESP 구현에서 지원되어야 합니다.\(MUST\)

IPsec 구현이 멀티캐스트를 지원하는 경우 인바운드 IPsec 데이터그램을 SA에 매핑하기 위해 아래 알고리즘을 사용하여 멀티캐스트 SA를 지원해야 합니다. 유니캐스트 트래픽만 지원하는 구현에서는 이 역다중화 알고리즘을 구현할 필요가 없습니다.\(MUST\)

많은 보안 멀티캐스트 아키텍처\(예: \[RFC3740\]\)에서 중앙 그룹 컨트롤러/키 서버는 그룹 보안 연결의 SPI를 일방적으로 할당합니다. 이 SPI 할당은 그룹을 구성하는 개별 최종 시스템에 있는 키 관리\(예: IKE\) 하위 시스템과 협상되거나 조정되지 않습니다. 결과적으로 그룹 보안 연결과 유니캐스트 보안 연결이 동일한 SPI를 동시에 사용할 수 있습니다. 멀티캐스트 가능 IPsec 구현은 SPI 충돌 상황에서도 인바운드 트래픽을 올바르게 다중화 해제해야 합니다.\(MUST\)

SAD\(Security Association Database\) \[Ken-Arch\]의 각 항목은 SA 조회가 SPI 외에 대상 또는 대상 및 소스, IP 주소를 사용하는지 여부를 나타내야 합니다. 멀티캐스트 SA의 경우 프로토콜 필드는 SA 조회에 사용되지 않습니다. 각 인바운드 IPsec 보호 패킷에 대해 구현에서는 "가장 긴" SA 식별자와 일치하는 항목을 찾을 수 있도록 SAD 검색을 수행해야 합니다. 이 컨텍스트에서 두 개 이상의 SAD 항목이 SPI 값을 기준으로 일치하는 경우 대상 또는 대상과 소스, 주소 비교\(SAD 항목에 표시된 대로\)를 기준으로 일치하는 항목이 "가장 긴" 일치 항목입니다. 이는 다음과 같이 SAD 검색의 논리적 순서를 의미합니다.

- 1. SAD에서 {SPI, 대상 주소, 소스 주소}와 일치하는 항목을 검색합니다. SAD 항목이 일치하면 일치하는 SAD 항목으로 인바운드 ESP 패킷을 처리합니다. 그렇지 않으면 2단계로 진행하세요.

- 2. {SPI, 대상 주소}와 일치하는 SAD를 검색합니다. SAD 항목이 일치하면 일치하는 SAD 항목으로 인바운드 ESP 패킷을 처리합니다. 그렇지 않으면 3단계로 진행하세요.

- 3. 수신기가 AH 및 ESP에 대해 단일 SPI 공간을 유지하도록 선택한 경우에만 {SPI}에서 일치하는 항목에 대해 SAD를 검색하고, 그렇지 않으면 {SPI, 프로토콜}에서 일치 항목을 검색합니다. SAD 항목이 일치하면 일치하는 SAD 항목으로 인바운드 ESP 패킷을 처리합니다. 그렇지 않으면 패킷을 삭제하고 감사 가능한 이벤트를 기록합니다.

실제로, 구현은 이 검색을 가속화하기 위해 어떤 방법이든 선택할 수 있지만, 외부적으로 보이는 동작은 위의 순서로 SAD를 검색한 것과 기능적으로 동일해야 합니다. 예를 들어, 소프트웨어 기반 구현은 SPI를 통해 해시 테이블에 색인을 생성할 수 있습니다. 각 해시 테이블 버킷의 연결 목록에 있는 SAD 항목은 해당 연결 목록에서 가장 긴 SA 식별자를 가진 SAD 항목이 먼저 정렬되도록 정렬됩니다. 가장 짧은 SA 식별자를 가진 SAD 항목은 연결 목록의 마지막 항목이 되도록 정렬됩니다. 하드웨어 기반 구현은 일반적으로 사용 가능한 TCAM\(Ternary Content-Addressable Memory\) 기능을 사용하여 본질적으로 가장 긴 일치 검색에 영향을 미칠 수 있습니다.\(MUST\)

인바운드 IPsec 트래픽을 SA에 매핑하기 위해 원본 및 대상 주소 일치가 필요한지 여부에 대한 표시는 수동 SA 구성의 부작용으로 또는 IKE 또는 GDOI\(그룹 해석 도메인\)와 같은 SA 관리 프로토콜을 사용하는 협상을 통해 설정되어야 합니다. \[RFC3547\]. 일반적으로 소스별 멀티캐스트\(SSM\) \[HC03\] 그룹은 SPI, 대상 멀티캐스트 주소 및 소스 주소로 구성된 3튜플 SA 식별자를 사용합니다. 모든 소스 멀티캐스트 그룹 SA에는 식별자로 SPI와 대상 멀티캐스트 주소만 필요합니다.\(MUST\)

```text
   The set of SPI values in the range 1 through 255 are reserved by the
   Internet Assigned Numbers Authority (IANA) for future use; a reserved
   SPI value will not normally be assigned by IANA unless the use of the
   assigned SPI value is specified in an RFC.  The SPI value of zero (0)
   is reserved for local, implementation-specific use and MUST NOT be
   sent on the wire.  (For example, a key management implementation
   might use the zero SPI value to mean "No Security Association Exists"
```

IPsec 구현에서 키 관리 엔터티가 새로운 SA를 설정하도록 요청했지만 SA가 아직 설정되지 않은 기간 동안\)

---
### **2.2.  Sequence Number**

이 부호 없는 32비트 필드에는 전송된 각 패킷에 대해 1씩 증가하는 카운터 값, 즉 SA별 패킷 시퀀스 번호가 포함됩니다. 유니캐스트 SA 또는 단일 송신자 멀티캐스트 SA의 경우 송신자는 전송된 모든 패킷에 대해 이 필드를 증가시켜야 합니다. 여러 발신자 간에 SA를 공유하는 것은 허용되지만 일반적으로 권장되지는 않습니다. ESP는 여러 발신자 간에 패킷 카운터를 동기화하거나 여러 발신자의 컨텍스트에서 수신자 패킷 카운터 및 창을 의미 있게 관리하는 수단을 제공하지 않습니다. 따라서 다중 발신자 SA의 경우 ESP의 재생 방지 기능을 사용할 수 없습니다\(섹션 3.3.3 및 3.4.3 참조\).\(MUST\)

이 필드는 필수이며 수신자가 특정 SA에 대해 재생 방지 서비스를 활성화하도록 선택하지 않은 경우에도 항상 존재해야 합니다. 시퀀스 번호 필드의 처리는 수신자의 재량에 따르지만 모든 ESP 구현은 섹션 3.3.3 및 3.4.3에 설명된 처리를 수행할 수 있어야 합니다. 따라서 발신자는 항상 이 필드를 전송해야 하지만 수신자는 이에 따라 조치를 취할 필요가 없습니다\(아래 "인바운드 패킷 처리" 섹션\(3.4.3\)의 시퀀스 번호 확인에 대한 설명 참조\).\(MUST, MUST, MUST\)

SA가 설정되면 송신측 카운터와 수신측 카운터는 0으로 초기화됩니다. \(주어진 SA를 사용하여 전송된 첫 번째 패킷은 시퀀스 번호 1을 갖습니다. 시퀀스 번호 생성 방법에 대한 자세한 내용은 섹션 3.3.3을 참조하십시오.\) 재생 방지가 활성화된 경우\(기본값\) 전송된 시퀀스 번호는 다음과 같아야 합니다. 절대로 자전거를 타면 안 됩니다. 따라서 발신자의 카운터와 수신자의 카운터는 SA에서 2^32번째 패킷을 전송하기 전에 반드시 재설정되어야 합니다\(새 SA 및 새 키를 설정하여\).\(MUST\)

---
#### **2.2.1.  Extended (64-bit) Sequence Number**

고속 IPsec 구현을 지원하려면 현재 32비트 시퀀스 번호 필드에 대한 확장으로 확장 시퀀스 번호\(ESN\)를 구현해야 합니다. ESN 사용은 SA 관리 프로토콜에 의해 협상되어야 합니다. IKEv2에서는 이 협상이 암시적입니다. 32비트 시퀀스 번호가 명시적으로 협상되지 않는 한 기본값은 ESN입니다. \(ESN 기능은 유니캐스트 SA뿐만 아니라 멀티캐스트에도 적용 가능합니다.\)\(SHOULD, MUST\)

ESN 기능을 사용하면 SA에 64비트 시퀀스 번호를 사용할 수 있습니다. \(자세한 내용은 부록 A, "확장\(64비트\) 시퀀스 번호"를 참조하십시오.\) 시퀀스 번호의 하위 32비트만 각 패킷의 일반 텍스트 ESP 헤더로 전송되므로 패킷 오버헤드가 최소화됩니다. 상위 32비트는 송신기와 수신기 모두에 의해 시퀀스 번호 카운터의 일부로 유지되며 ICV 계산에 포함됩니다\(무결성 서비스가 선택된 경우\). 별도의 무결성 알고리즘이 사용되는 경우 상위 비트는 암시적 ESP 트레일러에 포함되지만 무결성 알고리즘 패딩 비트와 유사하게 전송되지 않습니다. 결합 모드 알고리즘이 사용되는 경우 알고리즘 선택에 따라 상위 ESN 비트가 전송되는지 아니면 계산에 암시적으로 포함되는지가 결정됩니다. 처리 세부사항은 섹션 3.3.2.2를 참조하십시오.

---
### **2.3.  Payload Data**

페이로드 데이터는 다음 헤더 필드에서 설명하는 데이터\(원래 IP 패킷의\)를 포함하는 가변 길이 필드입니다. 페이로드 데이터 필드는 필수이며 길이는 정수 바이트입니다. 페이로드를 암호화하는 데 사용되는 알고리즘에 초기화 벡터\(IV\)와 같은 암호화 동기화 데이터가 필요한 경우 이 데이터는 페이로드 필드에 명시적으로 전달되지만 ESP에서 별도의 필드로 호출되지는 않습니다. 명시적인 IV는 ESP에 표시되지 않습니다. \(그림 2 참조\) 이러한 명시적인 패킷별 동기화 데이터가 필요한 모든 암호화 알고리즘은 알고리즘이 ESP와 함께 사용되는 방법을 지정하는 RFC의 일부로 해당 데이터의 길이, 구조 및 이 데이터의 위치를 ​​나타내야 합니다. \(일반적으로 IV는 암호문 바로 앞에 옵니다. 그림 2를 참조하십시오.\) 이러한 동기화 데이터가 암시적인 경우 데이터를 파생하는 알고리즘은 알고리즘 정의 RFC의 일부여야 합니다. \(페이로드 필드에 포함된 경우 초기화 벡터\(IV\)와 같은 암호화 동기화 데이터는 일반적으로 그 자체로 암호화되지 않지만\(표 1 및 2 참조\) 암호문의 일부로 참조되기도 합니다.\)\(MUST, MUST\)

다음 계층 프로토콜 헤더의 시작 부분은 다음과 같이 ESP 헤더의 시작 부분을 기준으로 정렬되어야 합니다. IPv4의 경우 이 정렬은 4바이트의 배수입니다. IPv6의 경우 정렬은 8바이트의 배수입니다.\(MUST\)

IV가 있는 경우 \(실제\) 암호문의 정렬을 보장하는 것과 관련하여 다음 사항에 유의하십시오.

- o 일부 IV 기반 작동 모드의 경우 수신기는 IV를 암호문의 시작으로 처리하여 이를 알고리즘에 직접 공급합니다. 이러한 모드에서는 \(실제\) 암호문의 시작 정렬이 수신기에서 문제가 되지 않습니다.

- o 어떤 경우에는 수신자가 IV를 암호문과 별도로 읽습니다. 이러한 경우, 알고리즘 사양은 \(실제\) 암호문의 정렬이 달성되는 방법을 다루어야 합니다.\(MUST\)

---
### **2.4.  Padding (for Encryption)**

두 가지 주요 요인으로 인해 패딩 필드 사용이 필요하거나 동기가 부여됩니다.

- o 일반 텍스트가 특정 바이트 수의 배수가 되도록 요구하는 암호화 알고리즘\(예: 블록 암호의 블록 크기\)을 사용하는 경우 Padding 필드는 일반 텍스트를 채우는 데 사용됩니다\(페이로드 데이터, 패딩, 패드 길이 및 다음 헤더 필드\)를 알고리즘에 필요한 크기로 설정합니다.

- o 결과 암호문이 4바이트 경계에서 끝나도록 암호화 알고리즘 요구 사항에 관계없이 패딩이 필요할 수도 있습니다. 특히 ICV 필드\(있는 경우\)가 4바이트 경계에 정렬되도록 하려면 위의 ESP 패킷 형식 그림에 표시된 대로 Pad Length 및 Next Header 필드를 4바이트 단어 내에서 오른쪽으로 정렬해야 합니다.

위에 언급된 알고리즘이나 정렬 이유에 필요한 것 이상의 패딩은 TFC를 지원하여 페이로드의 실제 길이를 숨기는 데 사용될 수 있습니다. 그러나 설명된 Padding 필드는 TFC에 효과적이기에는 너무 제한적이므로 해당 목적으로 사용해서는 안 됩니다. 대신 TFC가 필요한 경우 아래에 설명된 별도의 메커니즘\(섹션 2.7 참조\)을 사용해야 합니다.

발신자는 0\~255바이트의 패딩을 추가할 수 있습니다. ESP 패킷에 Padding 필드를 포함하는 것은 위에서 언급한 요구 사항에 따라 선택 사항이지만 모든 구현은 패딩 생성 및 소비를 지원해야 합니다.\(MAY, MUST\)

- o 암호화할 비트가 알고리즘 블록 크기\(위의 첫 번째 글머리 기호\)의 배수인지 확인하기 위해 패딩 계산은 모든 IV를 제외하고 ESP 트레일러 필드를 포함하는 페이로드 데이터에 적용됩니다. 결합된 알고리즘 모드에서 무결성을 구현하기 위해 SPI 및 시퀀스 번호의 전송이 필요한 경우\(예: 페이로드 데이터의 SPI 및 시퀀스 번호 복제\), 이러한 데이터 항목의 복제된 버전과 관련 ICV 동등 데이터는 다음과 같습니다. 패드 길이 계산에 포함됩니다. \(ESN 옵션이

- 선택하면 결합 모드 알고리즘이 무결성을 위해 전송을 요구하는 경우 ESN의 상위 32비트도 계산에 입력됩니다.\)

- o ICV가 4바이트 경계\(위의 두 번째 글머리 기호\)에 정렬되도록 하기 위해 패딩 계산은 IV, 패드 길이 및 다음 헤더 필드를 포함하는 페이로드 데이터에 적용됩니다. 결합 모드 알고리즘을 사용하는 경우 복제된 데이터 및 ICV와 동등한 데이터는 패딩 계산에 포함되는 페이로드 데이터에 포함됩니다.

패딩 바이트가 필요하지만 암호화 알고리즘이 패딩 내용을 지정하지 않는 경우 다음 기본 처리를 사용해야 합니다. 패딩 바이트는 일련의 \(부호 없는 1바이트\) 정수 값으로 초기화됩니다. 일반 텍스트에 추가된 첫 번째 패딩 바이트는 1로 번호가 지정되고 후속 패딩 바이트는 단조롭게 증가하는 시퀀스\(1, 2, 3, ...\)를 구성합니다. 이 패딩 방식을 사용할 경우 수신자는 패딩 필드를 검사해야 합니다\(SHOULD\). \(이 방식은 상대적으로 단순하고 하드웨어 구현이 용이하며 수신자가 암호 해독 시 패딩 값을 확인하는 경우 다른 무결성 측정 없이 특정 형태의 "잘라내기 및 붙여넣기" 공격에 대해 제한적인 보호를 제공하기 때문에 선택되었습니다. .\)\(MUST, SHOULD\)

암호화 또는 결합 모드 알고리즘이 패딩에 사용되는 바이트 값에 제약 조건을 부과하는 경우 알고리즘이 ESP와 함께 사용되는 방법을 정의하는 RFC에 의해 지정되어야 합니다. 알고리즘이 패딩에 사용된 바이트 값을 확인해야 하는 경우 이 역시 해당 RFC에 지정되어야 합니다.\(MUST, MUST\)

---
### **2.5.  Pad Length**

Pad Length 필드는 Padding 필드 바로 앞에 있는 패드 바이트 수를 나타냅니다. 유효한 값의 범위는 0\~255입니다. 여기서 값 0은 패딩 바이트가 없음을 나타냅니다. 위에서 언급한 대로 여기에는 TFC 패딩 바이트가 포함되지 않습니다. 패드 길이 필드는 필수입니다.

---
### **2.6.  Next Header**

다음 헤더는 페이로드 데이터 필드에 포함된 데이터 유형\(예: IPv4 또는 IPv6 패킷, 다음 계층 헤더 및 데이터\)을 식별하는 필수 8비트 필드입니다. 이 필드의 값은 IANA 웹 페이지에 정의된 IP 프로토콜 번호 세트에서 선택됩니다. 예를 들어 값 4는 IPv4를 나타내고 값 41은 IPv6를 나타내고 값 6은 TCP를 나타냅니다.

트래픽 흐름 기밀성을 지원하는 패딩 트래픽의 신속한 생성 및 폐기를 용이하게 하려면\(섹션 2.4 참조\) 프로토콜 값 59\("다음 헤더 없음"을 의미\)를 사용하여 "더미" 패킷을 지정해야 합니다. 송신기는 다음 프로토콜 필드에 이 값이 표시된 더미 패킷을 생성할 수 있어야 하며, 수신기는 오류를 표시하지 않고 이러한 패킷을 폐기할 준비를 해야 합니다\(MUST\). 다른 모든 ESP 헤더 및 트레일러 필드\(SPI, 시퀀스 번호, 패딩, 패드 길이, 다음 헤더 및 ICV\)는 더미 패킷에 있어야 하지만 이 다음 헤더 필드 이외의 페이로드의 일반 텍스트 부분은 잘 될 필요는 없습니다. - 예를 들어 페이로드 데이터의 나머지 부분은 임의의 바이트로만 구성될 수 있습니다. 더미 패킷은 편견 없이 폐기됩니다.\(MUST, MUST, MUST\)

구현에서는 SA별로 이 기능을 사용할 수 있도록 로컬 관리 제어를 제공해야 합니다. 컨트롤을 통해 사용자는 이 기능을 사용할지 여부를 지정할 수 있어야 하며 파라메트릭 컨트롤도 제공해야 합니다. 예를 들어 관리자는 제어를 통해 임의 길이 또는 고정 길이 더미 패킷을 생성할 수 있습니다.\(SHOULD\)

토론: 실제 트래픽이 없는 것을 가리기 위해 더미 패킷을 무작위 간격으로 삽입할 수 있습니다. 또한 배포 매개변수에 따라 더미 트래픽이 추가되는 일부 배포와 일치하도록 실제 트래픽을 "형성"할 수도 있습니다. TFS\(Traffic Flow Security\)를 위한 패킷 길이 패딩 기능과 마찬가지로 가장 안전한 접근 방식은 SA에서 일정한 속도를 유지하는 데 필요한 속도로 더미 패킷을 생성하는 것입니다. 패킷의 크기가 모두 동일한 경우 SA는 링크 암호화가 레이어 1 또는 2에서 제공하는 것과 유사한 일정한 비트 전송률 데이터 스트림의 모양을 나타냅니다. 그러나 이는 다음과 같은 많은 상황에서 실용적이지 않을 것입니다. 여러 SA가 활성화되어 있는 경우 SA 수에 따라 사이트에 허용되는 대역폭이 줄어들고 패킷 교환의 이점이 약화될 수 있기 때문입니다. 구현은 로컬 관리자가 TFC 목적을 위한 더미 패킷 생성을 관리할 수 있도록 제어를 제공해야 합니다\(SHOULD\).\(SHOULD\)

---
### **2.7.  Traffic Flow Confidentiality (TFC) Padding**

위에서 언급한 대로 Padding 필드의 길이는 255바이트로 제한됩니다. 이는 일반적으로 트래픽 흐름 기밀성 요구 사항과 관련된 트래픽 특성을 숨기는 데 적합하지 않습니다. 페이로드 데이터 내의 선택적 필드는 TFC 요구 사항을 해결하기 위해 특별히 제공됩니다.

IPsec 구현은 페이로드 데이터 끝 뒤, 패딩 필드 시작 전 바이트를 추가하여 트래픽을 패딩할 수 있어야 합니다. 그러나 이 패딩\(이하 TFC 패딩\)은 페이로드 데이터 필드에 IP 데이터그램 길이에 대한 사양이 포함된 경우에만 추가할 수 있습니다. 이는 터널 모드에서는 항상 true이고, 다음 계층 프로토콜\(예: IP, UDP, ICMP\)에 명시적인 길이 정보가 포함되어 있는지 여부에 따라 전송 모드에서도 true일 수 있습니다. 이 길이 정보를 사용하면 페이로드 데이터의 실제 길이가 알려지기 때문에 수신기가 TFC 패딩을 삭제할 수 있습니다. \(ESP 트레일러 필드는 ESP 패킷의 끝에서부터 역으로 계산하여 위치합니다.\) 따라서 TFC 패딩이 추가되는 경우 IP 데이터그램의 길이 사양을 포함하는 필드는 이 패딩을 반영하도록 수정되어서는 안 됩니다. 이 패딩 값에 대한 요구 사항은 이 표준에 의해 설정되지 않습니다.\(SHOULD, MUST NOT\)

원칙적으로 기존 IPsec 구현에서는 이전에 투명한 방식으로 이 기능을 사용할 수 있었습니다. 그러나 수신기가 이 패딩을 처리할 준비가 되어 있지 않을 수 있으므로 SA 관리 프로토콜은 이전 버전과의 호환성을 보장하기 위해 송신기가 이를 사용하기 전에 이 서비스를 협상해야 합니다. 프로토콜 ID 59의 사용에 관해 위의 섹션 2.6에 설명된 규칙과 결합하여 ESP 구현은 TFC를 지원하여 훨씬 더 큰 길이 가변성을 나타내는 더미 및 실제 패킷을 생성할 수 있습니다.\(MUST\)

구현에서는 SA별로 이 기능을 사용할 수 있도록 로컬 관리 제어를 제공해야 합니다. 컨트롤을 통해 사용자는 이 기능을 사용할지 여부를 지정할 수 있어야 하며 해당 기능에 대한 파라메트릭 컨트롤도 제공해야 합니다.\(SHOULD\)

---
### **2.8.  Integrity Check Value (ICV)**

무결성 검사 값은 ESP 헤더, 페이로드 및 ESP 트레일러 필드에 대해 계산된 가변 길이 필드입니다. 암시적 ESP 트레일러 필드\(해당되는 경우 무결성 패딩 및 상위 ESN 비트\)가 ICV 계산에 포함됩니다. ICV 필드는 선택 사항입니다. 무결성 서비스가 선택되고 별도의 무결성 알고리즘이나 ICV를 사용하는 결합 모드 알고리즘에 의해 제공되는 경우에만 존재합니다. 필드의 길이는

선택되고 SA와 연관된 무결성 알고리즘에 의해 지정됩니다. 무결성 알고리즘 사양은 ICV의 길이와 비교 규칙 및 검증을 위한 처리 단계를 지정해야 합니다.\(MUST\)

---
## **3.  Encapsulating Security Protocol Processing**
---
### **3.1.  ESP Header Location**

ESP는 전송 모드 또는 터널 모드라는 두 가지 방식으로 사용될 수 있습니다.

---
#### **3.1.1.  Transport Mode Processing**

전송 모드에서 ESP는 IP 헤더 뒤와 다음 계층 프로토콜\(예: TCP, UDP, ICMP 등\) 앞에 삽입됩니다. IPv4의 맥락에서 이는 IP 헤더\(및 포함된 모든 옵션\) 뒤에 ESP를 배치하는 것을 의미합니다. \), 그러나 다음 레이어 프로토콜 이전입니다. \(AH가 패킷에도 적용되는 경우 ESP 헤더, 페이로드, ESP 트레일러 및 ICV\(있는 경우\)에도 적용됩니다.\) \("전송" 모드라는 용어는 해당 사용을 TCP 및 UDP.\) 다음 다이어그램은 "이전 및 이후" 기준으로 일반적인 IPv4 패킷에 대한 ESP 전송 모드 위치 지정을 보여줍니다. \(이 섹션의 이 다이어그램과 후속 다이어그램은 ICV 필드를 보여줍니다. ICV 필드의 존재 여부는 보안 서비스와 선택한 알고리즘/모드의 기능입니다.\)

```text
                  BEFORE APPLYING ESP
             ----------------------------
       IPv4  |orig IP hdr  |     |      |
             |(any options)| TCP | Data |
             ----------------------------

                  AFTER APPLYING ESP
             -------------------------------------------------
       IPv4  |orig IP hdr  | ESP |     |      |   ESP   | ESP|
             |(any options)| Hdr | TCP | Data | Trailer | ICV|
             -------------------------------------------------
                                 |<---- encryption ---->|
                           |<-------- integrity ------->|
```

IPv6 컨텍스트에서 ESP는 엔드투엔드 페이로드로 간주되므로 홉별, 라우팅 및 조각화 확장 헤더 뒤에 나타나야 합니다. 대상 옵션 확장 헤더는 원하는 의미에 따라 ESP 헤더 앞, 뒤 또는 앞과 뒤에 모두 나타날 수 있습니다. 그러나 ESP는 ESP 헤더 뒤의 필드만 보호하므로 일반적으로 ESP 헤더 뒤에 대상 옵션 헤더를 배치하는 것이 바람직합니다. 다음 다이어그램은 일반적인 IPv6 패킷에 대한 ESP 전송 모드 위치 지정을 보여줍니다.

```text
                      BEFORE APPLYING ESP
             ---------------------------------------
       IPv6  |             | ext hdrs |     |      |
             | orig IP hdr |if present| TCP | Data |
             ---------------------------------------

                      AFTER APPLYING ESP
             ---------------------------------------------------------
       IPv6  | orig |hop-by-hop,dest*,|   |dest|   |    | ESP   | ESP|
             |IP hdr|routing,fragment.|ESP|opt*|TCP|Data|Trailer| ICV|
             ---------------------------------------------------------
                                          |<--- encryption ---->|
                                      |<------ integrity ------>|
```

- \* = 존재하는 경우 ESP 앞, ESP 뒤 또는 둘 다일 수 있습니다.

보안 아키텍처 문서에 정의된 대로 전송 모드에서 "bump-in-the-stack" 또는 "bump-in-the-wire" 구현의 경우 인바운드 및 아웃바운드 IP 조각은 추가 IP를 수행하기 위해 IPsec 구현이 필요할 수 있습니다. 이 사양을 준수하고 투명한 IPsec 지원을 제공하기 위한 재조립/조각화입니다. 여러 인터페이스가 사용 중인 경우 이러한 구현 내에서 이러한 작업을 수행하려면 특별한 주의가 필요합니다.

---
#### **3.1.2.  Tunnel Mode Processing**

터널 모드에서 "내부" IP 헤더는 최종\(IP\) 소스 및 대상 주소를 전달하는 반면 "외부" IP 헤더에는 IPsec "피어"의 주소\(예: 보안 게이트웨이 주소\)가 포함됩니다. 혼합된 내부 및 외부 IP 버전이 허용됩니다\(예: IPv4를 통한 IPv6 및 IPv6을 통한 IPv4\). 터널 모드에서 ESP는 전체 내부 IP 헤더를 포함하여 전체 내부 IP 패킷을 보호합니다. 외부 IP 헤더에 상대적인 터널 모드의 ESP 위치는 전송 모드의 ESP 위치와 동일합니다. 다음 다이어그램은 일반적인 IPv4 및 IPv6 패킷에 대한 ESP 터널 모드 위치 지정을 보여줍니다.

```text
                 BEFORE APPLYING ESP
            ----------------------------
      IPv4  |orig IP hdr  |     |      |
            |(any options)| TCP | Data |
            ----------------------------

                 AFTER APPLYING ESP

            -----------------------------------------------------------
      IPv4  | new IP hdr* |     | orig IP hdr*  |   |    | ESP   | ESP|
            |(any options)| ESP | (any options) |TCP|Data|Trailer| ICV|
            -----------------------------------------------------------
                                |<--------- encryption --------->|
                          |<------------- integrity ------------>|

                      BEFORE APPLYING ESP
            ---------------------------------------
      IPv6  |             | ext hdrs |     |      |
            | orig IP hdr |if present| TCP | Data |
            ---------------------------------------
```

- ESP 적용 후

```text
            ------------------------------------------------------------
      IPv6  | new* |new ext |   | orig*|orig ext |   |    | ESP   | ESP|
            |IP hdr| hdrs*  |ESP|IP hdr| hdrs *  |TCP|Data|Trailer| ICV|
            ------------------------------------------------------------
                                |<--------- encryption ---------->|
                            |<------------ integrity ------------>|
```

- \* = 존재하는 경우 외부 IP hdr/확장 구성 및 내부 IP hdr/확장 수정은 보안 아키텍처 문서에서 논의됩니다.

---
### **3.2.  Algorithms**

ESP와 함께 사용하기 위한 필수 구현 알고리즘은 프로토콜 자체와 독립적으로 알고리즘 요구 사항을 쉽게 업데이트할 수 있도록 별도의 RFC에 설명되어 있습니다. ESP에 요구되는 것 이상의 추가 알고리즘이 지원될 수 있습니다. 기밀성과 무결성은 모두 선택 사항이지만 이러한 서비스 중 적어도 하나를 선택해야 하므로 두 알고리즘이 동시에 NULL이 되어서는 안 됩니다.\(MAY, MUST NOT\)

---
#### **3.2.1.  Encryption Algorithms**

ESP 패킷을 보호하기 위해 사용되는 암호화 알고리즘은 패킷이 전송/수신되는 SA에 의해 지정됩니다. IP 패킷이 순서 없이 도착할 수 있고 모든 패킷이 도착하지 않을 수 있으므로\(패킷 손실\) 각 패킷은 수신자가 암호 해독을 위한 암호화 동기화를 설정하는 데 필요한 모든 데이터를 전달해야 합니다. 이 데이터는 페이로드 필드에 명시적으로 전달될 수 있습니다\(예: IV\(위에서 설명\)\). 또는 데이터가 \(외부 IP 또는 ESP\) 패킷 헤더의 일반 텍스트 부분에서 파생될 수 있습니다. \(일반 텍스트 헤더 정보를 사용하여 IV를 파생하는 경우 해당 정보는 보안에 중요할 수 있으므로 암호화 프로세스와 관련된 보호 경계가 커질 수 있습니다. 예를 들어 ESP 시퀀스 번호를 사용하여 IV를 파생하는 경우 시퀀스 번호 생성 논리\(하드웨어 또는 소프트웨어\)는 암호화 알고리즘 구현의 일부로 평가되어야 합니다. FIPS 140-2 \[NIST01\]의 경우 이는 암호화 모듈 평가 범위를 크게 확장할 수 있습니다.\) ESP 평문 패딩을 제공하는 경우 ESP에 사용되는 암호화 알고리즘은 블록 모드 또는 스트림 모드 특성을 나타낼 수 있습니다. 암호화\(기밀성\)는 선택적 서비스\(예: 무결성 전용 ESP\)일 수 있으므로 이 알고리즘은 "NULL" \[Ken-Arch\]일 수 있습니다.\(MAY\)

ESP 구현이 블록 모드 암호화 알고리즘에 필요한 암호화 패딩을 계산하도록 허용하고 알고리즘의 MTU 영향을 확인하려면 ESP와 함께 사용되는 각 암호화 알고리즘에 대한 RFC가 알고리즘의 패딩 모듈러스를 지정해야 합니다.

---
#### **3.2.2.  Integrity Algorithms**

ICV 계산에 사용되는 무결성 알고리즘은 패킷이 전송/수신되는 SA에 의해 지정됩니다. 암호화 알고리즘의 경우와 마찬가지로 ESP와 함께 사용되는 모든 무결성 알고리즘은 순서 없이 도착하는 패킷의 처리를 허용하고 패킷 손실을 수용할 수 있는 규정을 만들어야 합니다. 위에서 언급한 동일한 경고는 무결성 알고리즘의 수신기 동기화를 용이하게 하기 위해 일반 텍스트 데이터를 사용하는 경우에도 적용됩니다. 무결성 서비스는 선택 사항일 수 있으므로 이 알고리즘은 "NULL"일 수 있습니다.\(MAY\)

ESP 구현이 필요한 암시적 무결성 알고리즘 패딩을 계산할 수 있도록 하려면 ESP와 함께 사용되는 각 알고리즘에 대한 RFC는 알고리즘에 대한 패딩 계수를 지정해야 합니다.

---
#### **3.2.3.  Combined Mode Algorithms**

결합 모드 알고리즘을 사용하면 기밀성 및 무결성 서비스가 모두 제공됩니다. 암호화 알고리즘의 경우와 마찬가지로 결합 모드 알고리즘도 패킷별 암호화 동기화를 제공하여 순서 없이 도착하는 패킷의 암호 해독을 허용하고 패킷 손실을 수용해야 합니다. 결합 모드 알고리즘이 페이로드, SPI 및 \(확장\) 시퀀스 번호 필드에 대한 무결성을 제공하는 방법은 알고리즘 선택에 따라 달라질 수 있습니다. 결합 모드 알고리즘 호출에 대한 균일하고 알고리즘 독립적인 접근 방식을 제공하기 위해 페이로드 하위 구조가 정의되지 않습니다. 예를 들어 SPI 및 시퀀스 번호 필드는 암호문 봉투 내에서 복제될 수 있으며 ICV가 ESP 트레일러에 추가될 수 있습니다. 이러한 세부 사항 중 어느 것도 외부에서 관찰할 수 있어서는 안 됩니다.

ESP 구현이 결합 모드 알고리즘의 MTU 영향을 결정할 수 있도록 하려면 ESP와 함께 사용되는 각 알고리즘에 대한 RFC는 일반 텍스트 페이로드 및 시퀀스 번호 크기의 함수로 암호화된 페이로드 크기를 생성하는 \(간단한\) 공식을 지정해야 합니다.

---
### **3.3.  Outbound Packet Processing**

전송 모드에서 발신자는 ESP 헤더와 ESP 트레일러 필드 사이의 다음 계층 프로토콜 정보를 캡슐화하고 지정된 IP 헤더\(및 IPv6 컨텍스트의 모든 IP 확장 헤더\)를 유지합니다. 터널 모드에서는 외부 및 내부 IP 헤더/확장자가 다양한 방식으로 상호 연관될 수 있습니다. 캡슐화 프로세스 중 외부 IP 헤더/확장 구성은 보안 아키텍처 문서에 설명되어 있습니다.

---
#### **3.3.1.  Security Association Lookup**

ESP는 IPsec 구현에서 패킷이 ESP 처리를 요구하는 SA와 연결되어 있음을 확인한 후에만 아웃바운드 패킷에 적용됩니다. IPsec 처리가 아웃바운드 트래픽에 적용되는지 결정하는 프로세스는 보안 아키텍처 문서에 설명되어 있습니다.

---
#### **3.3.2.  Packet Encryption and Integrity Check Value (ICV) Calculation**

이 섹션에서는 형식 관련 영향으로 인해 암호화가 항상 적용된다는 점에 대해 설명합니다. 이는 NULL 암호화 알고리즘\(RFC 2410\)을 사용하여 "기밀성 없음"이 제공된다는 점을 이해하고 수행됩니다. 몇 가지 알고리즘 옵션이 있습니다.

---
##### **3.3.2.1.  Separate Confidentiality and Integrity Algorithms**

별도의 기밀성 및 무결성 알고리즘이 사용되는 경우 보낸 사람은 다음과 같이 진행합니다.

1. 캡슐화\(ESP 페이로드 필드에\):

- - 전송 모드의 경우 - 원래의 다음 계층 프로토콜 정보입니다. - 터널 모드의 경우 -- 전체 원본 IP 데이터그램.

- 2. 필요한 패딩 추가 -- 선택적인 TFC 패딩 및 \(암호화\) 패딩

- 3. SA에 지정된 키, 암호화 알고리즘, 알고리즘 모드를 사용하고 필요한 암호화 동기화 데이터를 사용하여 결과를 암호화합니다. - 명시적인 암호화 동기화 데이터\(예: IV\)가 표시된 경우 알고리즘 사양에 따라 암호화 알고리즘에 입력되어 페이로드 필드에 배치됩니다. - 암시적 암호화 동기화 데이터를 사용하는 경우 알고리즘 사양에 따라 암호화 알고리즘에 구성되어 입력됩니다. - 무결성을 선택한 경우 무결성 알고리즘을 적용하기 전에 먼저 암호화를 수행하며 암호화에는 ICV 필드가 포함되지 않습니다. 이러한 처리 순서는 패킷을 해독하기 전에 수신자가 재생된 패킷이나 가짜 패킷을 신속하게 감지하고 거부하도록 하여 잠재적으로 서비스 거부\(DoS\) 공격의 영향을 줄입니다. 이는 또한 수신자에서 패킷의 병렬 처리 가능성을 허용합니다. 즉, 무결성 검사와 동시에 암호 해독이 이루어질 수 있습니다. ICV는 암호화로 보호되지 않으므로 ICV를 계산하려면 키 무결성 알고리즘을 사용해야 합니다.

- 4. ESP 패킷에서 ICV 필드를 뺀 ICV를 계산합니다. 따라서 ICV 계산에는 SPI, 시퀀스 번호, 페이로드 데이터, 패딩\(있는 경우\), 패드 길이 및 다음 헤더가 포함됩니다. \(암호화가 먼저 수행되므로 마지막 4개 필드는 암호문 형식입니다.\) SA에 대해 ESN 옵션이 활성화된 경우 시퀀스 번호의 상위 32비트가 다음 헤더 필드 뒤에 추가됩니다. 이 계산은 전송되지 않습니다.

일부 무결성 알고리즘의 경우 ICV 계산이 수행되는 바이트 문자열은 알고리즘에서 지정한 블록 크기의 배수여야 합니다. 위에서 설명한 대로 ESP 패킷의 길이가 알고리즘의 블록 크기 요구 사항과 일치하지 않는 경우 암시적 패딩을 ESP 패킷 끝에 추가해야 합니다. \(이 패딩은 다음 헤더 필드 뒤에 추가되거나 ESN이 선택된 경우 시퀀스 번호의 상위 32비트 뒤에 추가됩니다.\) 블록 크기\(및 패딩 길이\)는 무결성 알고리즘 사양에 의해 지정됩니다. 이 패딩은 패킷과 함께 전송되지 않습니다. 위에서 설명한 대로 암시적 패딩이 필요한지 여부를 결정하려면 무결성 알고리즘을 정의하는 문서를 참조해야 합니다. 문서에서 이 질문에 대한 답변을 지정하지 않은 경우 기본값은 암시적 패딩이 필요하다고 가정하는 것입니다\(패킷 길이를 알고리즘의 블록 크기에 일치시키는 데 필요함\). 패딩 바이트가 필요하지만 알고리즘이 지정하지 않은 경우 패딩 내용이 있는 경우 패딩 옥텟의 값은 0이어야 합니다.\(MUST, MUST, MUST\)

---
##### **3.3.2.2.  Combined Confidentiality and Integrity Algorithms**

기밀성/무결성 알고리즘이 결합된 경우 보낸 사람은 다음과 같이 진행합니다.

1. ESP 페이로드 데이터 필드로 캡슐화합니다.

- - 전송 모드의 경우 - 원래의 다음 계층 프로토콜 정보입니다. - 터널 모드의 경우 -- 전체 원본 IP 데이터그램.

- 2. 필요한 패딩을 추가합니다. 선택적인 TFC 패딩 및 \(암호화\) 패딩이 포함됩니다.

- 3. SA에 대해 지정된 키와 결합 모드 알고리즘을 사용하고 필요한 암호화 동기화 데이터를 사용하여 결과를 암호화 및 무결성 보호합니다. - 명시적인 암호화 동기화 데이터\(예: IV\)가 표시된 경우 알고리즘 사양에 따라 결합 모드 알고리즘에 입력되어 페이로드 필드에 배치됩니다. - 암시적 암호화 동기화 데이터를 사용하는 경우 알고리즘 사양에 따라 암호화 알고리즘에 구성되어 입력됩니다. - 시퀀스 번호\(또는 해당하는 경우 확장 시퀀스 번호\) 및 SPI는 무결성 검사 계산에 포함되어야 하므로 알고리즘에 대한 입력입니다. 이러한 값이 이 계산에 포함되는 수단은 다음의 함수입니다.

- 이 표준에 명시되지 않은 결합 모드 알고리즘이 사용됩니다. - \(명시적\) ICV 필드는 결합 모드 알고리즘이 사용될 때 ESP 패킷 형식의 일부일 수 있습니다. 하나를 사용하지 않는 경우 유사한 필드는 일반적으로 암호문 페이로드의 일부가 됩니다. 무결성 필드의 위치와 시퀀스 번호 및 SPI가 무결성 계산에 포함되는 수단은 ESP와 결합 모드 알고리즘의 사용을 정의하는 RFC에 정의되어야 합니다.\(MAY, MUST\)

---
#### **3.3.3.  Sequence Number Generation**

SA가 설정되면 보낸 사람의 카운터가 0으로 초기화됩니다. 송신자는 이 SA에 대한 시퀀스 번호\(또는 ESN\) 카운터를 증가시키고 해당 값의 하위 32비트를 시퀀스 번호 필드에 삽입합니다. 따라서 주어진 SA를 사용하여 전송된 첫 번째 패킷에는 시퀀스 번호 1이 포함됩니다.

재생 방지가 활성화된 경우\(기본값\) 송신자는 시퀀스 번호 필드에 새 값을 삽입하기 전에 카운터가 순환되지 않았는지 확인합니다. 즉, 발신자는 SA에서 패킷을 보내면 시퀀스 번호가 순환하게 되어서는 안 됩니다. 시퀀스 번호 오버플로를 초래하는 패킷 전송 시도는 감사 가능한 이벤트입니다. 이 이벤트에 대한 감사 로그 항목에는 SPI 값, 현재 날짜/시간, 소스 주소, 대상 주소 및 \(IPv6의 경우\) 일반 텍스트 흐름 ID가 포함되어야 합니다.\(MUST NOT, SHOULD\)

발신자는 수신자가 별도로 통지하지 않는 한 재생 방지가 기본적으로 활성화되어 있다고 가정합니다\(섹션 3.4.3 참조\). 따라서 ESP 구현의 일반적인 동작에서는 시퀀스 번호\(또는 ESN\)가 순환할 때 또는 이 값 순환을 예상할 때 송신자가 새로운 SA를 설정해야 합니다.

ICV를 계산하는 데 사용되는 키가 수동으로 배포되는 경우 호환 구현은 재생 방지 서비스를 제공해서는 안 됩니다. 사용자가 수동으로 키를 입력한 SA와 함께 재생 방지를 사용하기로 선택한 경우 키가 교체될 때까지 로컬 재부팅 등을 통해 발신자의 시퀀스 번호 카운터가 올바르게 유지되어야 합니다. \(섹션 5 참조\)\(SHOULD NOT, MUST\)

재생 방지가 비활성화된 경우\(위에서 언급한 대로\) 발신자는 카운터를 모니터링하거나 재설정할 필요가 없습니다. 그러나 발신자는 여전히 카운터를 증가시키고 최대값에 도달하면 카운터가 다시 0으로 롤오버됩니다. \(이 동작은 외부 재생 방지 메커니즘이 아닌 한 다중 전송자, 멀티캐스트 SA에 권장됩니다.

이 표준의 범위는 발신자와 수신자 간에 협상됩니다.\)

ESN\(부록 참조\)을 선택한 경우 송신자와 수신자 모두 전체 64비트 ESN 카운터를 유지하더라도 시퀀스 번호의 하위 32비트만 시퀀스 번호 필드에 전송됩니다. 상위 32비트는 알고리즘/모드별 방식으로 무결성 검사에 포함됩니다. 예를 들어 별도의 무결성 알고리즘이 사용되는 경우 상위 32비트는 다음 헤더 필드 뒤에 추가될 수 있습니다.

참고: 수신자가 SA에 대해 재생 방지를 활성화하지 않기로 선택한 경우 수신자는 SA 관리 프로토콜에서 ESN을 협상해서는 안 됩니다. ESN을 사용하면 수신자가 재생 방지 창을 관리해야 할 필요성이 발생합니다\(ICV 계산에 사용되는 ESN의 상위 비트에 대한 올바른 값을 결정하기 위해\). 이는 일반적으로 개념과 반대입니다. SA에 대한 재생 방지를 비활성화합니다.\(SHOULD NOT\)

---
#### **3.3.4.  Fragmentation**

필요한 경우 IPsec 구현 내에서 ESP 처리 후에 조각화가 수행됩니다. 따라서 전송 모드 ESP는 IP 조각이 아닌 전체 IP 데이터그램에만 적용됩니다. ESP가 적용된 IP 패킷은 도중에 라우터에 의해 그 자체로 조각화될 수 있으며, 이러한 조각은 수신기에서 ESP 처리에 앞서 재조립되어야 합니다. 터널 모드에서는 ESP가 IP 데이터그램의 일부일 수 있는 IP 패킷에 적용됩니다. 예를 들어, 보안 게이트웨이 또는 "bump-in-the-stack" 또는 "bump-in-the-wire" IPsec 구현\(보안 아키텍처 문서에 정의됨\)은 이러한 조각에 터널 모드 ESP를 적용할 수 있습니다.

참고: 전송 모드의 경우 - 섹션 3.1.1의 끝 부분에서 언급했듯이, Bump-in-the-Stack 및 Bump-in-the-Wire 구현은 먼저 로컬 IP 계층에 의해 조각난 패킷을 재조립한 다음 적용해야 할 수도 있습니다. IPsec을 선택한 다음 결과 패킷을 조각화합니다.

참고: IPv6의 경우 -- Bump-in-the-Stack 및 Bump-in-the-wire 구현의 경우 모든 확장 헤더를 검사하여 조각화 헤더가 있는지, 따라서 패킷을 먼저 재조립해야 하는지 확인해야 합니다. IPsec 처리에.

IPsec 구현에 의해 수행되거나 IPsec 피어 간 경로를 따라 라우터에 의해 수행되는 조각화는 성능을 크게 저하시킵니다. 더욱이 ESP 수신기가 재조립을 위해 조각을 허용해야 한다는 요구 사항으로 인해 서비스 거부 취약점이 발생합니다. 따라서 ESP 구현은 PMTU\(경로 MTU\) 검색을 용이하게 하기 위해 조각화를 지원하지 않도록 선택할 수 있으며 전송된 패킷에 DF 비트를 표시할 수 있습니다. 어쨌든 ESP 구현은 반드시\(MAY, MUST\)

조각화 가능성을 최소화하기 위해 ICMP PMTU 메시지\(또는 기본 호스트 구현을 위한 동등한 내부 신호\) 생성을 지원합니다. MTU 관리에 필요한 지원에 대한 자세한 내용은 보안 아키텍처 문서에 포함되어 있습니다.

---
### **3.4.  Inbound Packet Processing**
---
#### **3.4.1.  Reassembly**

필요한 경우 ESP 처리 전에 재조립이 수행됩니다. 처리를 위해 ESP에 제공된 패킷이 IP 조각으로 나타나는 경우, 즉 OFFSET 필드가 0이 아니거나 MORE FRAGMENTS 플래그가 설정된 경우 수신기는 패킷을 폐기해야 합니다. 이는 감사 가능한 이벤트입니다. 이 이벤트에 대한 감사 로그 항목에는 SPI 값, 수신된 날짜/시간, 소스 주소, 대상 주소, 시퀀스 번호 및 \(IPv6의 경우\) 흐름 ID가 포함되어야 합니다.\(MUST, SHOULD\)

참고: 패킷 재조립의 경우 현재 IPv4 사양에서는 OFFSET 필드를 0으로 설정하거나 MORE FRAGMENTS 플래그를 지울 필요가 없습니다. 재조립된 패킷을 IPsec에서 처리하려면\(명백한 조각으로 폐기되는 것이 아니라\) IP 코드가 패킷을 재조립한 후 이 두 가지 작업을 수행해야 합니다.

---
#### **3.4.2.  Security Association Lookup**

ESP 헤더가 포함된 패킷을 수신하면 수신기는 SAD 조회를 통해 적절한\(단방향\) SA를 결정합니다. 유니캐스트 SA의 경우 이 결정은 섹션 2.1에 설명된 대로 SPI 또는 SPI 플러스 프로토콜 필드를 기반으로 합니다. 구현이 멀티캐스트 트래픽을 지원하는 경우 섹션 2.1에 설명된 대로 대상 주소도 SPI와 함께 조회에 사용되며 보낸 사람 주소도 사용될 수 있습니다. \(이 프로세스는 보안 아키텍처 문서에 자세히 설명되어 있습니다.\) SA에 대한 SAD 항목은 또한 시퀀스 번호 필드를 확인할지 여부, SA에 32비트 또는 64비트 시퀀스 번호를 사용하는지 여부, \(명시적\) ICV 필드가 있어야 합니다\(있는 경우 해당 크기\). 또한 SAD 항목은 암호 해독 및 ICV 계산\(해당되는 경우\)에 사용할 알고리즘과 키를 지정합니다.

이 패킷에 대해 유효한 보안 연결이 존재하지 않으면 수신자는 패킷을 폐기해야 합니다. 이는 감사 가능한 이벤트입니다. 이 이벤트에 대한 감사 로그 항목에는 SPI 값, 수신된 날짜/시간, 소스 주소, 대상 주소, 시퀀스 번호 및 \(IPv6의 경우\) 일반 텍스트 흐름 ID가 포함되어야 합니다.\(MUST, SHOULD\)

\(IKE 패킷과 같은 SA 관리 트래픽은 SPI를 기반으로 처리할 필요가 없습니다. 즉, 예를 들어 다음 프로토콜 및 포트 필드를 기반으로 이 트래픽을 별도로 역다중화할 수 있습니다.\)

---
#### **3.4.3.  Sequence Number Verification**

모든 ESP 구현은 재생 방지 서비스를 지원해야 하지만 해당 서비스의 사용은 SA별로 수신기에 의해 활성화되거나 비활성화될 수 있습니다. SA에 대해 ESP 무결성 서비스도 활성화되지 않는 한 이 서비스를 활성화해서는 안 됩니다. 그렇지 않으면 시퀀스 번호 필드가 무결성 보호되지 않았기 때문입니다. 재생 방지는 멀티캐스트 SA뿐만 아니라 유니캐스트에도 적용됩니다. 그러나 이 표준은 다중 송신자 SA\(유니캐스트 또는 멀티캐스트\)에 대한 재생 방지를 제공하는 메커니즘을 지정하지 않습니다. 이러한 SA에 대한 재생 방지 메커니즘의 협상\(또는 수동 구성\)이 없는 경우 아래 설명된 대로 SA에 대한 시퀀스 번호의 발신자와 수신자 확인을 비활성화하는 것이 좋습니다\(협상 또는 수동 구성을 통해\).\(MUST, MUST NOT\)

수신자가 SA에 대해 재생 방지를 활성화하지 않으면 시퀀스 번호에 대한 인바운드 확인이 수행되지 않습니다. 그러나 발신자의 관점에서 볼 때 기본값은 수신자에서 재생 방지가 활성화되어 있다고 가정하는 것입니다. 발신자가 불필요한 시퀀스 번호 모니터링 및 SA 설정\(섹션 3.3.3 참조\)을 수행하지 않도록 하기 위해 SA 설정 프로토콜이 사용되는 경우 수신자는 SA 설정 중에 수신자가 재생 방지 보호를 제공하지 않는 경우 발신자에게 알려야 합니다. .\(SHOULD\)

수신기가 이 SA에 대한 재생 방지 서비스를 활성화한 경우 SA가 설정될 때 SA에 대한 수신 패킷 카운터는 0으로 초기화되어야 합니다. 수신된 각 패킷에 대해 수신자는 패킷에 이 SA 수명 동안 수신된 다른 패킷의 시퀀스 번호와 중복되지 않는 시퀀스 번호가 포함되어 있는지 확인해야 합니다. 이는 중복 패킷 거부 속도를 높이기 위해 패킷이 SA에 일치된 후 패킷에 적용되는 첫 번째 ESP 검사여야 합니다.\(MUST, MUST, SHOULD\)

ESP는 패킷 시퀀스 번호의 2단계 검증을 허용합니다. 이 기능은 ESP 구현\(일반적으로 해당 암호화 모듈 부분\)이 보호되지 않은 네트워크에 대한 인터페이스와 동일한 속도로 암호 해독 및/또는 무결성 검사를 수행할 수 없을 때마다 중요합니다. 구현이 이러한 "라인 속도" 작업을 지원하는 경우 아래 설명된 예비 검증 단계를 수행할 필요가 없습니다.

예비 시퀀스 번호 확인은 ESP 헤더의 시퀀스 번호 값을 활용하여 수행되며 무결성 확인 및 암호 해독에 앞서 수행됩니다. 이 사전 점검이 실패할 경우,

패킷은 폐기되므로 수신자의 암호화 작업이 필요하지 않습니다. 예비 검사가 성공하면 이 시점에서 시퀀스 번호의 무결성이 확인되지 않았기 때문에 수신자는 아직 로컬 카운터를 수정할 수 없습니다.

슬라이딩 수신 창을 사용하여 중복 항목이 거부됩니다. 창을 구현하는 방법은 지역적인 문제이지만 다음 텍스트에서는 구현이 표시해야 하는 기능을 설명합니다.

창의 "오른쪽" 가장자리는 이 SA에서 수신된 검증된 가장 높은 시퀀스 번호 값을 나타냅니다. 창의 "왼쪽" 가장자리보다 낮은 시퀀스 번호를 포함하는 패킷은 거부됩니다. 창 내에 있는 패킷은 창 내에서 수신된 패킷 목록과 비교하여 확인됩니다. SA에 대해 ESN 옵션이 선택된 경우 시퀀스 번호의 하위 32비트만 명시적으로 전송되지만 수신기는 표시된 SA에 대해 상위 32비트를 사용하여 계산된 전체 시퀀스 번호를 사용합니다\(자신의 로컬 카운터에서\). \) 수신 창에서 수신된 Sequence Number를 확인할 때. 전체 시퀀스 번호를 구성할 때 패킷에 포함된 하위 32비트의 값이 수신자 시퀀스 번호의 하위 32비트보다 낮으면 수신자는 상위 32비트가 증가한 것으로 가정하여 이동합니다. 새로운 시퀀스 번호 부분 공간으로. \(이 알고리즘은 2\*\*32-1 패킷만큼 큰 단일 SA에 대한 수신 간격을 수용합니다. 더 큰 간격이 발생하는 경우 수신기 시퀀스 번호 카운터의 재동기화에 대한 추가 경험적 검사를 사용할 수 있습니다. 부록.\)\(MAY\)

수신된 패킷이 윈도우 내에 있고 중복이 아닌 경우, 또는 패킷이 윈도우의 오른쪽에 있는 경우, 별도의 무결성 알고리즘을 사용하는 경우 수신자는 무결성 검증을 진행합니다. 결합 모드 알고리즘을 사용하는 경우 복호화와 함께 무결성 검사도 수행됩니다. 두 경우 모두 무결성 검사가 실패하면 수신자는 수신된 IP 데이터그램을 유효하지 않은 것으로 폐기해야 합니다. 이는 감사 가능한 이벤트입니다. 이 이벤트에 대한 감사 로그 항목에는 SPI 값, 수신된 날짜/시간, 소스 주소, 대상 주소, 시퀀스 번호 및 \(IPv6의 경우\) 흐름 ID가 포함되어야 합니다. 수신창은 무결성 검증이 성공한 경우에만 업데이트됩니다. \(결합 모드 알고리즘을 사용하는 경우 무결성 보호 시퀀스 번호는 재생 방지 보호에 사용되는 시퀀스 번호와도 일치해야 합니다.\)\(MUST, SHOULD\)

32비트 시퀀스 번호를 사용하는 경우 최소 창 크기 32개 패킷을 지원해야 합니다. 64의 창 크기가 선호되며 기본값으로 사용해야 합니다. 수신자는 다른 창 크기\(최소값보다 큰\)를 선택할 수 있습니다. \(수신자는 송신자에게 창 크기를 알리지 않습니다.\) 수신 창 크기\(MUST, MAY\)

보증 문제에 관계없이 고속 환경에서는 증가해야 합니다. 초고속\(예: 멀티 기가비트/초\) 장치에 대한 최소 및 권장 수신 창 크기 값은 이 표준에서 지정되지 않습니다.

---
#### **3.4.4.  Integrity Check Value Verification**

아웃바운드 처리와 마찬가지로 인바운드 처리에도 사용된 알고리즘의 기능에 따라 여러 가지 옵션이 있습니다.

---
##### **3.4.4.1.  Separate Confidentiality and Integrity Algorithms**

별도의 기밀성 및 무결성 알고리즘을 사용하는 경우 처리는 다음과 같이 진행됩니다.

- 1. 무결성이 선택된 경우 수신기는 지정된 무결성 알고리즘을 사용하여 ESP 패킷에서 ICV를 뺀 ICV를 계산하고 그것이 패킷에 전달된 ICV와 동일한지 확인합니다. 계산의 세부 사항은 아래에 제공됩니다.

- 계산된 ICV와 수신된 ICV가 일치하면 데이터그램이 유효하고 수락됩니다. 테스트가 실패하면 수신자는 수신된 IP 데이터그램을 유효하지 않은 것으로 폐기해야 합니다. 이는 감사 가능한 이벤트입니다. 로그 데이터에는 SPI 값, 수신된 날짜/시간, 소스 주소, 대상 주소, 시퀀스 번호 및 \(IPv6의 경우\) 일반 텍스트 흐름 ID가 포함되어야 합니다.\(MUST, SHOULD\)

```text
            Implementation Note:
```

- 구현에서는 다음 단계 집합과 동일한 결과를 가져오는 모든 단계 집합을 사용할 수 있습니다. ICV 필드를 제거하고 저장하여 시작하십시오. 다음으로 ESP 패킷에서 ICV 필드를 뺀 전체 길이를 확인합니다. 암시적 패딩이 필요한 경우 무결성 알고리즘의 블록 크기에 따라 ESP 패킷의 끝 부분에 다음 헤더 필드 바로 뒤 또는 ESN이 다음인 경우 시퀀스 번호의 상위 32비트 뒤에 0으로 채워진 바이트를 추가합니다. 선택된. ICV 계산을 수행하고 알고리즘 사양에 정의된 비교 규칙을 사용하여 결과를 저장된 값과 비교합니다.

- 2. 수신기는 SA가 지시하는 키, 암호화 알고리즘, 알고리즘 모드 및 암호화 동기화 데이터\(있는 경우\)를 사용하여 ESP 페이로드 데이터, 패딩, 패드 길이 및 다음 헤더를 해독합니다. 섹션 3.3.2에서와 같이 여기서는 암호화가 항상 적용된다는 점을 설명합니다.

형식화의 의미. 이 작업은

- NULL 암호화 알고리즘\(RFC 2410\)을 사용하여 "기밀성 없음"이 제공된다는 점을 이해합니다.

- - 명시적인 암호화 동기화 데이터\(예: IV\)가 표시된 경우 페이로드 필드에서 가져와 알고리즘 사양에 따라 암호 해독 알고리즘에 입력합니다.

- - 암시적 암호화 동기화 데이터가 표시된 경우 IV의 로컬 버전이 구성되어 알고리즘 사양에 따라 암호 해독 알고리즘에 입력됩니다.

- 3. 수신자는 암호화 알고리즘 사양에 지정된 대로 모든 Padding을 처리합니다. 기본 패딩 방식\(섹션 2.4 참조\)이 사용된 경우 수신기는 해독된 데이터를 다음 계층으로 전달하기 전에 패딩을 제거하기 전에 패딩 필드를 검사해야 합니다.\(SHOULD\)

- 4. 수신자는 Next Header 필드를 확인합니다. 값이 "59"\(다음 헤더 없음\)인 경우 \(더미\) 패킷은 추가 처리 없이 삭제됩니다.

- 5. 수신기는 다음으로부터 원본 IP 데이터그램을 재구성합니다.

- - 전송 모드의 경우 - 외부 IP 헤더와 ESP 페이로드 필드의 원래 다음 계층 프로토콜 정보 - 터널 모드의 경우 - ESP 페이로드 필드의 전체 IP 데이터그램.

- 원본 데이터그램을 재구성하는 정확한 단계는 모드\(전송 또는 터널\)에 따라 다르며 보안 아키텍처 문서에 설명되어 있습니다. 최소한 IPv6 컨텍스트에서 수신자는 다음 헤더 필드에서 식별된 프로토콜에 의한 처리를 용이하게 하기 위해 해독된 데이터가 8바이트로 정렬되어 있는지 확인해야 합니다. 이 처리에서는 트래픽 흐름 기밀성을 위해 추가된 모든\(선택적\) TFC 패딩을 "폐기"합니다. \(존재하는 경우 이는 IP 데이터그램\(또는 전송 계층 프레임\) 뒤와 패딩 필드 앞에 삽입됩니다\(섹션 2.4 참조\).\(SHOULD\)

무결성 검사와 암호화가 동시에 수행되는 경우 해독된 패킷이 추가 처리를 위해 전달되기 전에 무결성 검사를 완료해야 합니다. 이러한 처리 순서를 통해 재생되거나 가짜인 콘텐츠를 신속하게 탐지하고 거부할 수 있습니다.\(MUST\)

패킷을 해독하기 전에 수신자가 패킷을 해독하므로 잠재적으로 서비스 거부 공격의 영향을 줄일 수 있습니다.

참고: 수신자가 무결성 검사와 병행하여 암호 해독을 수행하는 경우 패킷 액세스 및 암호 해독된 패킷 추출과 관련하여 발생할 수 있는 경쟁 조건을 피하기 위해 주의를 기울여야 합니다.

---
##### **3.4.4.2.  Combined Confidentiality and Integrity Algorithms**

기밀성과 무결성 알고리즘이 결합된 경우 수신자는 다음과 같이 진행합니다.

- 1. SA가 표시하는 키, 알고리즘, 알고리즘 모드 및 암호화 동기화 데이터\(있는 경우\)를 사용하여 ESP 페이로드 데이터, 패딩, 패드 길이 및 다음 헤더를 해독하고 무결성을 확인합니다. ESP 헤더의 SPI 및 \(수신기\) 패킷 카운터 값\(섹션 3.4.3에 설명된 처리에서 필요에 따라 조정됨\)은 무결성 검사에 필요하므로 이 알고리즘의 입력입니다.

- - 명시적인 암호화 동기화 데이터\(예: IV\)가 표시된 경우 페이로드 필드에서 가져와 알고리즘 사양에 따라 암호 해독 알고리즘에 입력합니다.

- - 암시적 암호화 동기화 데이터\(예: IV\)가 표시된 경우 IV의 로컬 버전이 구성되어 알고리즘 사양에 따라 암호 해독 알고리즘에 입력됩니다.

- 2. 결합 모드 알고리즘에 의해 수행된 무결성 검사가 실패하면 수신기는 수신된 IP 데이터그램을 유효하지 않은 것으로 폐기해야 합니다. 이는 감사 가능한 이벤트입니다. 로그 데이터에는 SPI 값, 수신된 날짜/시간, 소스 주소, 대상 주소, 시퀀스 번호 및 \(IPv6의 경우\) 일반 텍스트 흐름 ID가 포함되어야 합니다.\(MUST, SHOULD\)

- 3. 알고리즘이 아직 처리하지 않은 경우 암호화 알고리즘 사양에 지정된 대로 패딩을 처리합니다.

- 4. 수신자는 Next Header 필드를 확인합니다. 값이 "59"\(다음 헤더 없음\)인 경우 \(더미\) 패킷은 추가 처리 없이 삭제됩니다.

5. 원본 IP 데이터그램을 추출합니다\(터널 모드\). 또는

- ESP 페이로드 데이터 필드의 전송 계층 프레임\(전송 모드\). 이는 모든 \(선택적\) 패딩을 암시적으로 삭제합니다.

- 트래픽 흐름 기밀성을 위해 추가되었습니다. \(있는 경우 TFC 패딩은 IP 페이로드 뒤와 패딩 필드 앞에 삽입됩니다\(섹션 2.4 참조\).\)

---
## **4.  Auditing**

ESP를 구현하는 모든 시스템이 감사를 구현하는 것은 아닙니다. 그러나 ESP가 감사를 지원하는 시스템에 통합된 경우 ESP 구현은 감사도 지원해야 하며 시스템 관리자가 ESP에 대한 감사를 활성화하거나 비활성화할 수 있도록 허용해야 합니다\(MUST\). 대부분의 경우 감사의 세분성은 지역적인 문제입니다. 그러나 이 사양에서는 여러 감사 가능한 이벤트가 식별되며 이러한 각 이벤트에 대해 감사 로그에 포함되어야 하는 최소 정보 집합이 정의됩니다.\(MUST, SHOULD\)

- - 세션에 유효한 보안 연결이 없습니다. 이 이벤트에 대한 감사 로그 항목에는 SPI 값, 수신된 날짜/시간, 소스 주소, 대상 주소, 시퀀스 번호 및 \(IPv6의 경우\) 일반 텍스트 흐름 ID가 포함되어야 합니다.\(SHOULD\)

- - 처리를 위해 ESP에 제공된 패킷이 IP 조각인 것 같습니다. 즉, OFFSET 필드가 0이 아니거나 MORE FRAGMENTS 플래그가 설정되었습니다. 이 이벤트에 대한 감사 로그 항목에는 SPI 값, 수신된 날짜/시간, 소스 주소, 대상 주소, 시퀀스 번호 및 \(IPv6의 경우\) 흐름 ID가 포함되어야 합니다.\(SHOULD\)

- - 시퀀스 번호 오버플로를 초래하는 패킷 전송을 시도합니다. 이 이벤트에 대한 감사 로그 항목에는 SPI 값, 현재 날짜/시간, 소스 주소, 대상 주소, 시퀀스 번호 및 \(IPv6의 경우\) 일반 텍스트 흐름 ID가 포함되어야 합니다.\(SHOULD\)

- - 수신된 패킷이 재생 방지 검사에 실패합니다. 이 이벤트에 대한 감사 로그 항목에는 SPI 값, 수신된 날짜/시간, 소스 주소, 대상 주소, 시퀀스 번호 및 \(IPv6의 경우\) 흐름 ID가 포함되어야 합니다.\(SHOULD\)

- - 무결성 검사에 실패했습니다. 이 이벤트에 대한 감사 로그 항목에는 SPI 값, 수신된 날짜/시간, 소스 주소, 대상 주소, 시퀀스 번호 및 \(IPv6의 경우\) 흐름 ID가 포함되어야 합니다.\(SHOULD\)

추가 정보도 이러한 각 이벤트에 대한 감사 로그에 포함될 수 있으며, 이 사양에서 명시적으로 호출되지 않은 추가 이벤트도 감사 로그 항목이 될 수 있습니다. 수신자가 메시지를 전송해야 한다는 요구사항은 없습니다.\(MAY\)

그러한 조치를 통해 서비스 거부를 유도할 가능성이 있기 때문에 감사 가능한 이벤트 감지에 대한 응답으로 알려진 발신인입니다.

---
## **5.  Conformance Requirements**

이 사양에 대한 적합성을 주장하는 구현은 유니캐스트 트래픽에 대해 여기에 설명된 ESP 구문 및 처리를 구현해야 하며 보안 아키텍처 문서 \[Ken-Arch\]에서 부과한 모든 추가 패킷 처리 요구 사항을 준수해야 합니다. 또한 구현이 멀티캐스트 트래픽을 지원한다고 주장하는 경우 해당 트래픽 지원을 위해 지정된 추가 요구 사항을 준수해야 합니다. ICV를 계산하는 데 사용되는 키가 수동으로 배포되는 경우 재생 방지 서비스를 올바르게 제공하려면 키가 교체될 때까지 발신자에서 카운터 상태를 올바르게 유지 관리해야 합니다\(로컬 재부팅 등\). 카운터 오버플로가 임박한 경우 자동 복구 조항이 없습니다. 따라서 호환 구현은 수동으로 키가 입력된 SA와 함께 재생 방지 서비스를 제공해서는 안 됩니다.\(MUST, MUST, SHOULD NOT\)

ESP와 함께 사용하기 위한 필수 구현 알고리즘은 프로토콜 자체와 독립적으로 알고리즘 요구 사항을 쉽게 업데이트할 수 있도록 별도의 문서 \[Eas04\]에 설명되어 있습니다. ESP에 요구되는 것 이상의 추가 알고리즘이 지원될 수 있습니다.\(MAY\)

ESP에서 암호화 사용은 선택 사항이므로 ESP 서비스가 협상되는 방식과 일관성을 유지하려면 "NULL" 암호화 알고리즘에 대한 지원도 필요합니다. ESP의 기밀성 전용 서비스 버전에 대한 지원은 선택 사항입니다. 구현이 이 서비스를 제공하는 경우 "NULL" 무결성 알고리즘의 협상도 지원해야 합니다\(MUST\). 위에서 언급한 상황에서는 무결성과 암호화가 각각 "NULL"일 수 있지만 둘 다 "NULL"이 되어서는 안 됩니다.\(MUST, MUST NOT\)

---
## **6.  Security Considerations**

보안은 이 프로토콜 설계의 핵심이므로 보안 고려 사항이 사양에 스며듭니다. IPsec 프로토콜 사용에 대한 추가적인 보안 관련 측면은 보안 아키텍처 문서에서 논의됩니다.

---
## **7.  Differences from RFC 2406**

이 문서는 여러 가지 중요한 면에서 RFC 2406과 다릅니다.

- o 기밀성 전용 서비스 - 이제는 필수가 아닌 MAY입니다.\(MUST\)

- o SPI - 광범위한 멀티캐스트 기술을 포괄하는 유니캐스트 및 멀티캐스트 SA에 대한 SAD 조회를 위한 균일한 알고리즘을 지정하도록 수정되었습니다. 유니캐스트의 경우 SPI는 SA를 선택하기 위해 단독으로 사용될 수도 있고, 수신자의 선택에 따라 프로토콜과 결합될 수도 있습니다. 멀티캐스트 SA의 경우 SPI는 대상 주소 및 선택적으로 소스 주소와 결합되어 SA를 선택합니다. o 확장된 시퀀스 번호 - 초고속 통신을 위한 64비트 시퀀스 번호에 대한 새 옵션이 추가되었습니다. 멀티캐스트 SA 및 다중 발신자 SA에 대한 발신자 및 수신자 처리 요구 사항을 명확히 했습니다. o 페이로드 데이터 - 결합 모드 알고리즘을 수용하기 위해 확장된 모델입니다. o 향상된 트래픽 흐름 기밀성을 위한 패딩 - IP 페이로드 종료 후, 패딩 필드 시작 전에 바이트를 추가할 수 있어야 한다는 요구 사항이 추가되었습니다. o 다음 헤더 - 더미 패딩 패킷을 생성하고 삭제할 수 있도록 요구 사항이 추가되었습니다\(다음 헤더 = 59\). o ICV - 결합 모드 알고리즘을 수용하기 위해 확장된 모델입니다. o 알고리즘 - 결합된 기밀 모드 알고리즘이 추가되었습니다. o 필수 알고리즘에 대한 참조를 별도의 문서로 이동했습니다. o 인바운드 및 아웃바운드 패킷 처리 - 이제 \(1\) 별도의 기밀성 및 무결성 알고리즘과 \(2\) 결합된 기밀성 모드 알고리즘의 두 가지 경로가 있습니다. 결합 모드 알고리즘이 추가되었기 때문에 인바운드 및 아웃바운드 패킷 처리 모두에 대해 암호화/암호 해독 및 무결성 섹션이 결합되었습니다.

---
## **8.  Backward-Compatibility Considerations**

ESP에는 버전 번호가 없으며 IPsec 피어가 각각이 사용하고 있거나 사용해야 하는 ESP 버전을 검색하거나 협상할 수 있는 메커니즘이 없습니다. 이 섹션에서는 그에 따른 이전 버전과의 호환성 문제에 대해 설명합니다.

첫째, ESP v3에서 사용할 수 있는 새로운 기능 중 어느 것도 사용되지 않으면 ESP 패킷의 형식은 ESP v2와 v3에서 동일합니다. ESP v3에서만 지원되는 기능인 결합 모드 암호화 알고리즘을 사용하는 경우 결과 패킷 형식은 ESP v2 사양과 다를 수 있습니다. 그러나 ESP v2만 구현하는 피어는 ESP v3 컨텍스트에서만 사용하도록 정의된 알고리즘을 협상하지 않습니다.

ESN\(확장된 시퀀스 번호\) 협상은 IKE v2에서 지원되며 IKE v1 DOI\(해석 도메인\)에 대한 ESN 부록을 통해 IKE v1에 대해 해결되었습니다.

새로운 ESP\(v3\)에서는 트래픽 흐름 기밀성\(TFC\)을 더 잘 지원하기 위해 두 가지 조항을 만듭니다.

- IP 패킷 끝 이후의 임의 패딩

- - 다음 헤더를 사용한 폐기 규칙 = 59

첫 번째 기능은 IP 전체 길이 필드가 IP 패킷이 끝나는 위치를 나타내기 때문에 수신기에 문제를 일으키지 않아야 하는 기능입니다. 따라서 패킷 끝 이후의 모든 TFC 패딩 바이트는 IPsec 소프트웨어가 해당 패딩을 제거하지 않더라도 ESP 처리 후 IP 패킷 처리 중 특정 지점에서 제거되어야 합니다. 따라서 이는 수신자가 ESP v2 또는 ESP v3을 구현하는지 여부에 관계없이 송신자가 사용할 수 있는 ESP v3 기능입니다.

두 번째 기능을 사용하면 발신자가 TFC 목적으로 터널 내부에서 반드시 올바른 형식의 IP 패킷을 구성할 필요는 없는 임의의 바이트 문자열인 페이로드를 보낼 수 있습니다. ESP 패킷의 다음 헤더 필드에 "59" 값이 포함되어 있을 때 ESP v2 수신기가 수행할 작업에 대한 공개 질문입니다. 형식이 잘못된 IP 헤더를 발견하면 패킷을 삭제하고 이 이벤트를 기록할 수 있지만 충돌해서는 안 됩니다. 이러한 동작은 인증된 피어로부터 수신된 트래픽과 관련하여 DoS 취약점을 구성할 수 있기 때문입니다. 따라서 이 기능은 수신자가 ESP v2 또는 ESP v3을 구현하는지 여부에 관계없이 ESP v3 발신자가 사용할 수 있는 최적화입니다.

---
## **9.  Acknowledgements**

저자는 초기 IPsec 활동에서 중요한 역할을 하고 첫 번째 IPsec 표준 시리즈인 RFC 1825-1827을 작성한 Ran Atkinson의 공헌에 감사를 표하고 싶습니다. 이 사양과 이 사양의 이전 버전을 편집하는 데 도움을 준 Karen Seo에게 특별한 감사를 드립니다. 저자는 또한 이 프로토콜 사양 개발에 기여한 IPSEC 및 MSEC 작업 그룹 구성원에게도 감사의 말씀을 전하고 싶습니다.

---
## **10.  References**
---
### **10.1.  Normative References**

\[Bra97\] Bradner, S., "요구 사항 수준을 나타내기 위해 RFC에 사용되는 핵심 단어", BCP 14, RFC 2119, 1997년 3월.

\[DH98\] Deering, S. 및 R. Hinden, "인터넷 프로토콜, 버전 6\(IPv6\) 사양", RFC 2460, 1998년 12월.

\[Eas04\] 3rd Eastlake, D., "보안 페이로드\(ESP\) 및 인증 헤더\(AH\) 캡슐화를 위한 암호화 알고리즘 구현 요구 사항", RFC 4305, 2005년 12월.

\[Ken-Arch\] Kent, S. 및 K. Seo, "인터넷 프로토콜을 위한 보안 아키텍처", RFC 4301, 2005년 12월.

```text
   [Pos81]    Postel, J., "Internet Protocol", STD 5, RFC 791, September
              1981.
```

---
### **10.2.  Informative References**

\[Bel96\] Steven M. Bellovin, "IP 보안 프로토콜의 문제 영역", 제6회 Usenix Unix 보안 심포지엄 간행물, 1996년 7월.

\[HC03\] Holbrook, H. 및 B. Cain, "IP용 소스별 멀티캐스트", 진행 중인 작업, 2002년 11월 3일.

```text
   [Kau05]    Kaufman, C., Ed., "The Internet Key Exchange (IKEv2)
              Protocol", RFC 4306, December 2005.

   [Ken-AH]   Kent, S., "IP Authentication Header", RFC 4302, December
              2005.
```

\[Kra01\] Krawczyk, H., "통신 보호를 위한 암호화 및 인증 순서\(또는: SSL은 얼마나 안전한가요?\)", CRYPTO' 2001.

\[NIST01\] 연방 정보 처리 표준 공개 140-2\(FIPS PUB 140-2\), "암호화 모듈에 대한 보안 요구 사항", 미국 국립 표준 기술 연구소 정보 기술 연구소, 2001년 5월 25일.

\[RFC3547\] Baugher, M., Weis, B., Hardjono, T. 및 H. Harney, "해석의 그룹 도메인", RFC 3547, 2003년 7월.

\[RFC3740\] Hardjono, T. 및 B. Weis, "멀티캐스트 그룹 보안 아키텍처", RFC 3740, 2004년 3월.

\[Syverson\] P. Syverson, D. Goldschlag 및 M. Reed, "익명 연결 및 양파 라우팅", 보안 및 개인 정보 보호 심포지엄 진행, 캘리포니아주 오클랜드, 1997년 5월, 44-54페이지.

---
# **Appendix A: Extended (64-bit) Sequence Numbers**
---
## **A1.  Overview**

이 부록에서는 64비트 시퀀스 번호를 사용하지만 하위 32비트만 각 패킷의 일부로 전송되는 IPsec\(ESP 및 AH\)에 사용되는 확장 시퀀스 번호\(ESN\) 방식에 대해 설명합니다. 이는 재생된 패킷을 감지하는 데 사용되는 창 방식과 재생 거부 및 ICV 계산에 사용되는 시퀀스 번호의 상위 비트 결정을 모두 다룹니다. 또한 \(전송되지 않은\) 상위 비트와 관련된 동기화 손실을 처리하는 메커니즘에 대해서도 설명합니다.

---
## **A2.  Anti-Replay Window**

수신자는 W 크기의 재생 방지 창을 유지합니다. 이 창은 지금까지 인증된 시퀀스 번호가 가장 높은 패킷과 관련하여 패킷의 순서가 어긋날 수 있는 정도를 제한합니다. \(32비트 시퀀스 번호 창에 대해 이미 설정된 32패킷 및 64패킷 값을 넘어서 이 창에 대한 최소 또는 권장 크기에 대한 요구 사항은 설정되어 있지 않습니다. 그러나 구현자는 지원되는 인터페이스 속도에 맞게 이러한 값을 조정하는 것이 좋습니다. ESN 옵션을 사용하는 구현에 의해 또한 아래 설명된 알고리즘은 창의 너비가 2^31 패킷보다 크지 않다고 가정합니다.\) 모든 2^32 시퀀스 번호는 상위 32에 대한 고정 값과 연결됩니다. 비트\(Seqh\)는 이후 시퀀스 번호 부분공간으로 불립니다. 다음 표에는 관련 변수와 해당 정의가 나열되어 있습니다.

```text
        Var.   Size
        Name  (bits)            Meaning
        ----  ------  ---------------------------
        W       32    Size of window
        T       64    Highest sequence number authenticated so far,
                      upper bound of window
          Tl      32    Lower 32 bits of T
          Th      32    Upper 32 bits of T
        B       64    Lower bound of window
          Bl      32    Lower 32 bits of B
          Bh      32    Upper 32 bits of B
        Seq     64    Sequence Number of received packet
          Seql    32    Lower 32 bits of Seq
          Seqh    32    Upper 32 bits of Seq
```

재생 방지 검사를 수행하거나 들어오는 패킷을 인증하는 데 사용할 상위 비트를 결정할 때 다음 두 가지 경우가 있습니다.

```text
     + Case A: Tl >= (W - 1). In this case, the window is within one
                              sequence number subspace.  (See Figure 1)
     + Case B: Tl < (W - 1).  In this case, the window spans two
                              sequence number subspaces.  (See Figure 2)

   In the figures below, the bottom line ("----") shows two consecutive
   sequence number subspaces, with zeros indicating the beginning of
   each subspace.  The two shorter lines above it show the higher-order
   bits that apply.  The "====" represents the window.  The "****"
   represents future sequence numbers, i.e., those beyond the current
   highest sequence number authenticated (ThTl).

        Th+1                         *********

        Th               =======*****

              --0--------+-----+-----0--------+-----------0--
                         Bl    Tl            Bl
                                        (Bl+2^32) mod 2^32

                            Figure 1 -- Case A

        Th                           ====**************

        Th-1                      ===

              --0-----------------+--0--+--------------+--0--
                                  Bl    Tl            Bl
                                                 (Bl+2^32) mod 2^32

                            Figure 2 -- Case B
```

---
### **A2.1.  Managing and Using the Anti-Replay Window**

재생 방지 창은 'W'가 문자열의 길이를 정의하는 비트 문자열로 생각될 수 있습니다. W = T - B + 1이며 값이 2^32 - 1을 초과할 수 없습니다. 최하위 비트는 B에 대응하고, 최상위 비트는 T에 대응하며, B1부터 T1까지의 각 시퀀스 번호는 대응되는 비트로 표현된다. 비트 값은 해당 시퀀스 번호가 있는 패킷이 수신 및 인증되었는지 여부를 나타내므로 재생을 감지하고 거부할 수 있습니다.

T보다 큰 64비트 시퀀스 번호\(Seq\)를 가진 패킷이 수신되어 검증되면,

+ B는 \(Seq - T\)만큼 증가합니다.

- + \(Seq - T\) 비트는 창의 낮은 끝에서 삭제됩니다. + \(Seq - T\) 비트는 창의 높은 끝에 추가됩니다. + 맨 위 비트는 해당 시퀀스 번호를 가진 패킷이 전송되었음을 나타내기 위해 설정됩니다. 수신 및 인증됨 + T와 최상위 비트 사이의 새 비트는 해당 시퀀스 번호를 가진 패킷이 아직 수신되지 않았음을 나타내기 위해 설정됩니다. + T는 새로운 시퀀스 번호로 설정됩니다.

재생된 패킷을 확인하는데 있어서,

- + 사례 A에서: Seql \>= Bl\(Bl = Tl - W + 1\) AND Seql <= Tl이면 창에서 해당 비트를 확인하여 이 Seql이 이미 표시되었는지 확인합니다. 그렇다면 패킷을 거부하십시오. 그렇지 않은 경우 무결성 검사를 수행합니다\(Seqh 결정은 아래 부록 A2.2 참조\).

- + 사례 B의 경우: Seql \>= Bl\(Bl = Tl - W + 1\) 또는 Seql <= Tl이면 창에서 해당 비트를 확인하여 이 Seql이 이미 표시되었는지 확인합니다. 그렇다면 패킷을 거부하십시오. 그렇지 않은 경우 무결성 검사를 수행합니다\(Seqh 결정은 아래 부록 A2.2 참조\).

---
### **A2.2.  Determining the Higher-Order Bits (Seqh) of the Sequence Number**

'Seql'만이 패킷과 함께 전송되기 때문에 수신자는 각 패킷이 속하는 시퀀스 번호 하위 공간을 추론하고 추적해야 합니다. 즉, Seqh의 값을 결정해야 합니다. 다음 방정식은 "정상" 조건에서 Seqh를 선택하는 방법을 정의합니다. 극심한 패킷 손실을 복구하는 방법에 대한 설명은 섹션 A3을 참조하세요.

+ 사례 A의 경우\(그림 1\):

- Seql \>= Bl\(Bl = Tl - W + 1\)이면 Seqh = Th Seql < Bl\(Bl = Tl - W + 1\)이면 Seqh = Th + 1

+ 사례 B의 경우\(그림 2\):

- Seql \>= B1\(Bl = Tl - W + 1\)인 경우 Seqh = Th - 1 Seql < Bl\(Bl = T1 - W + 1\)인 경우 Seqh = Th

---
### **A2.3.  Pseudo-Code Example**

다음 의사 코드는 재생 방지 및 무결성 검사를 위한 위의 알고리즘을 보여줍니다. \`Seql', \`Tl', \`Th' 및 \`W'의 값은 32비트 부호 없는 정수입니다. 산술은 mod 2^32입니다.

```text
        If (Tl >= W - 1)                            Case A
            If (Seql >= Tl - W + 1)
                Seqh = Th
                If (Seql <= Tl)
                    If (pass replay check)
                        If (pass integrity check)
                            Set bit corresponding to Seql
                            Pass the packet on
                        Else reject packet
                    Else reject packet
                Else
                    If (pass integrity check)
                        Tl = Seql (shift bits)
                        Set bit corresponding to Seql
                        Pass the packet on
                    Else reject packet
            Else
                Seqh = Th + 1
                If (pass integrity check)
                    Tl = Seql (shift bits)
                    Th = Th + 1
                    Set bit corresponding to Seql
                    Pass the packet on
                Else reject packet
        Else                                    Case B
            If (Seql >= Tl - W + 1)
                Seqh = Th - 1
                If (pass replay check)
                    If (pass integrity check)
                        Set the bit corresponding to Seql
                        Pass packet on
                    Else reject packet
                Else reject packet
            Else
                Seqh = Th
                If (Seql <= Tl)
                    If (pass replay check)
                        If (pass integrity check)
                            Set the bit corresponding to Seql
                            Pass packet on
                        Else reject packet
                    Else reject packet

                Else
                    If (pass integrity check)
                        Tl = Seql (shift bits)
                        Set the bit corresponding to Seql
                        Pass packet on
                    Else reject packet
```

---
## **A3.  Handling Loss of Synchronization due to Significant Packet Loss**

단일 SA에서 2^32 이상의 연속 패킷의 감지되지 않은 패킷 손실이 있는 경우 송신기와 수신기는 상위 비트의 동기화, 즉 섹션 A2.2의 방정식을 잃게 됩니다. 올바른 값을 산출하지 못할 것입니다. 이 문제가 감지되어 해결되지 않으면 이 SA의 후속 패킷은 인증 확인에 실패하고 삭제됩니다. 다음 절차는 ESN 옵션을 지원하는 IPsec\(ESP 또는 AH\) 구현으로 구현되어야 합니다.\(SHOULD\)

이러한 종류의 확장된 트래픽 손실은 IPsec이 A3.1 및 A3.2에 설명된 일종의 재동기화 메커니즘을 호출해야 하기 전에 대부분의 경우 상위 계층에서 감지될 가능성이 높습니다. 문제의 SA 트래픽 중 상당 부분이 TCP인 경우 소스는 ACK 수신에 실패하고 2^32 패킷이 손실되기 오래 전에 전송을 중지합니다. 또한 UDP 이상으로 작동하는 양방향 애플리케이션의 경우에도 이러한 확장된 중단으로 인해 일종의 시간 초과가 발생할 수 있습니다. 그러나 UDP를 통해 작동하는 단방향 애플리케이션에는 이 규모의 손실을 자동으로 감지하는 피드백이 부족할 수 있으므로 이 경우에 대한 복구 방법을 개발하려는 동기가 부여됩니다. 위의 관찰 내용은 보안 게이트웨이 간, 호스트 간 또는 호스트와 보안 게이트웨이 간 SA에 적용됩니다.

우리가 선택한 솔루션은 다음과 같이 선택되었습니다.

+ 정상적인 트래픽 처리에 미치는 영향을 최소화합니다.

+ 공격자가 강제로 리소스를 재동기화 프로세스로 전환함으로써 발생할 수 있는 새로운 서비스 거부 공격 기회 생성을 방지합니다.

+ 복구 메커니즘을 수신기로 제한합니다. 재생 방지는 수신기만을 위한 서비스이고 송신기는 일반적으로 수신기가 이 선택적 서비스를 지원하기 위해 시퀀스 번호를 사용하고 있는지 여부를 알지 못하기 때문에 복구 메커니즘이 바람직합니다. 수신기에 로컬이 되도록 합니다. 이는 또한 이전 버전과의 호환성을 허용합니다.

---
### **A3.1.  Triggering Re-synchronization**

각 SA에 대해 수신기는 인증에 실패한 연속 패킷 수를 기록합니다. 이 카운트는 백그라운드에서 또는 별도의 프로세서를 사용하여 수행되어야 하는 재동기화 프로세스를 트리거하는 데 사용됩니다. SA에서 유효한 패킷을 수신하면 카운터가 0으로 재설정됩니다. 재동기화 프로세스를 트리거하는 데 사용되는 값은 로컬 매개변수입니다. 구현자가 그렇게 하도록 선택할 수도 있지만 서로 다른 SA에 대해 고유한 트리거 값을 지원해야 한다는 요구 사항은 없습니다.

---
### **A3.2.  Re-synchronization Process**

위의 트리거 지점에 도달하면 시퀀스 번호\(Seqh\)의 상위 절반에 대해 연속적으로 더 큰 값을 사용하여 인증을 재시도하는 "불량" 패킷이 선택됩니다. 이러한 값은 재시도할 때마다 1씩 증가하여 생성됩니다. "과거"의 패킷이거나 가짜 패킷인 경우 재시도 횟수를 제한해야 합니다. 한계값은 로컬 매개변수입니다. \(Seqh 값은 암시적으로 ESP\(또는 AH\) 페이로드 뒤에 배치되므로 페이로드의 끝점까지 패킷에 대해 무결성 알고리즘을 실행하여 이 절차를 최적화한 다음 값을 변경하여 다른 후보 ICV를 계산하는 것이 가능할 수 있습니다. of Seqh.\) 이 절차를 통해 패킷 인증이 성공하면 연속 실패 횟수가 재설정되고 T 값이 수신된 패킷의 값으로 설정됩니다.

이 솔루션은 수신기 부분에서만 지원이 필요하므로 이전 버전과의 호환성이 가능합니다. 또한 재동기화 노력은 백그라운드에서 발생하거나 추가 프로세서를 활용하기 때문에 이 솔루션은 트래픽 처리에 영향을 주지 않으며 서비스 거부 공격이 리소스를 트래픽 처리에서 다른 방향으로 전환할 수 없습니다.

---
# **Author's Address**

```text
   Stephen Kent
   BBN Technologies
   10 Moulton Street
   Cambridge, MA  02138
   USA

   Phone: +1 (617) 873-3988
   EMail: kent@bbn.com
```

---
# **Full Copyright Statement**

Copyright \(C\) The Internet Society \(2005\).

이 문서는 BCP 78에 포함된 권리, 라이선스 및 제한 사항의 적용을 받으며 여기에 명시된 경우를 제외하고 작성자는 모든 권리를 보유합니다.

이 문서 및 여기에 포함된 정보는 "있는 그대로" 제공되며 기여자, 기여자가 대표하거나 후원하는 조직\(있는 경우\), 인터넷 사회 및 인터넷 공학 태스크포스는 모든 명시적 또는 묵시적 보증을 부인합니다. 여기에서 구성은 상품성 또는 특정 목적에의 적합성에 대한 권리 또는 묵시적 보증을 침해하지 않습니다.

---
# **Intellectual Property**

IETF는 이 문서에 설명된 기술의 구현 또는 사용과 관련이 있다고 주장할 수 있는 지적 재산권 또는 기타 권리의 유효성 또는 범위 또는 그러한 권리에 따른 라이센스의 범위에 대해 어떠한 입장도 취하지 않습니다. 는 가능하다; 또한 그러한 권리를 식별하기 위해 독립적인 노력을 기울였다는 것을 나타내지 않습니다. RFC 문서의 권리와 관련된 절차에 대한 정보는 BCP 78 및 BCP 79에서 찾을 수 있습니다.

IETF 사무국에 제출된 IPR 공개 사본 및 사용 가능한 라이선스에 대한 보증 또는 이 사양의 구현자 또는 사용자가 이러한 독점권 사용에 대한 일반 라이선스 또는 허가를 얻으려는 시도의 결과를 얻을 수 있습니다. http://www.ietf.org/ipr의 IETF 온라인 IPR 저장소에서.

IETF는 이 표준을 구현하는 데 필요할 수 있는 기술을 포함할 수 있는 저작권, 특허 또는 특허 출원 또는 기타 소유권에 관심을 갖도록 이해 당사자를 초대합니다. 정보를 IETF\(ietf-ipr@ietf.org\)로 보내주십시오.

---
# **Acknowledgement**

RFC 편집기 기능에 대한 자금은 현재 Internet Society에서 제공하고 있습니다.
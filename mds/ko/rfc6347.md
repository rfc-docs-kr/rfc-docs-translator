

```text
Internet Engineering Task Force (IETF)                       E. Rescorla
Request for Comments: 6347                                    RTFM, Inc.
Obsoletes: 4347                                              N. Modadugu
Category: Standards Track                                   Google, Inc.
ISSN: 2070-1721                                             January 2012

             Datagram Transport Layer Security Version 1.2
```

---
# **Abstract**

이 문서에서는 DTLS\(Datagram Transport Layer Security\) 프로토콜 버전 1.2를 지정합니다. DTLS 프로토콜은 데이터그램 프로토콜에 대한 통신 프라이버시를 제공합니다. 이 프로토콜을 사용하면 클라이언트/서버 응용 프로그램이 도청, 변조 또는 메시지 위조를 방지하도록 설계된 방식으로 통신할 수 있습니다. DTLS 프로토콜은 TLS\(Transport Layer Security\) 프로토콜을 기반으로 하며 동등한 보안 보장을 제공합니다. 기본 전송의 데이터그램 의미는 DTLS 프로토콜에 의해 보존됩니다. 이 문서는 TLS 버전 1.2와 작동하도록 DTLS 1.0을 업데이트합니다.

---
# **Status of This Memo**

이것은 인터넷 표준 추적 문서입니다.

이 문서는 IETF\(Internet Engineering Task Force\)의 산물입니다. 이는 IETF 커뮤니티의 합의를 나타냅니다. 공개 검토를 받았으며 IESG\(Internet Engineering Steering Group\)의 게시 승인을 받았습니다. 인터넷 표준에 대한 추가 정보는 RFC 5741의 섹션 2에서 확인할 수 있습니다.

이 문서의 현재 상태, 정오표, 피드백 제공 방법에 대한 정보는 http://www.rfc-editor.org/info/rfc6347에서 얻을 수 있습니다.

---
# **Copyright Notice**

Copyright \(c\) 2012 IETF Trust 및 문서 작성자로 식별된 사람. 판권 소유.

이 문서는 이 문서 발행일에 유효한 BCP 78 및 IETF 문서와 관련된 IETF Trust의 법적 조항\(http://trustee.ietf.org/license-info\)의 적용을 받습니다. 이 문서에 관한 귀하의 권리와 제한 사항이 설명되어 있으므로 이 문서를 주의 깊게 검토하십시오. 이 문서에서 추출된 코드 구성 요소는 신뢰 법률 조항의 섹션 4.e에 설명된 대로 단순화된 BSD 라이센스 텍스트를 포함해야 하며 단순화된 BSD 라이센스에 설명된 대로 보증 없이 제공됩니다.

이 문서에는 2008년 11월 10일 이전에 공개되거나 공개된 IETF 문서 또는 IETF 기여의 자료가 포함될 수 있습니다. 이 자료 중 일부의 저작권을 관리하는 사람은 IETF Trust에 해당 자료의 수정을 허용할 권한을 부여하지 않았을 수 있습니다. IETF 표준 프로세스 외부. 해당 자료의 저작권을 관리하는 사람으로부터 적절한 라이센스를 얻지 않은 경우 이 문서는 IETF 표준 프로세스 외부에서 수정될 수 없으며 해당 문서의 파생물은 형식을 지정하는 경우를 제외하고 IETF 표준 프로세스 외부에서 생성될 수 없습니다. RFC로 출판하거나 영어 이외의 언어로 번역합니다.

---
# **Table of Contents**

```text
   1. Introduction ....................................................4
      1.1. Requirements Terminology ...................................5
   2. Usage Model .....................................................5
   3. Overview of DTLS ................................................5
      3.1. Loss-Insensitive Messaging .................................6
      3.2. Providing Reliability for Handshake ........................6
           3.2.1. Packet Loss .........................................6
           3.2.2. Reordering ..........................................7
           3.2.3. Message Size ........................................7
      3.3. Replay Detection ...........................................7
   4. Differences from TLS ............................................7
      4.1. Record Layer ...............................................8
           4.1.1. Transport Layer Mapping ............................10
                  4.1.1.1. PMTU Issues ...............................10
           4.1.2. Record Payload Protection ..........................12
                  4.1.2.1. MAC .......................................12
                  4.1.2.2. Null or Standard Stream Cipher ............13
                  4.1.2.3. Block Cipher ..............................13
                  4.1.2.4. AEAD Ciphers ..............................13
                  4.1.2.5. New Cipher Suites .........................13
                  4.1.2.6. Anti-Replay ...............................13
                  4.1.2.7. Handling Invalid Records ..................14
      4.2. The DTLS Handshake Protocol ...............................14
           4.2.1. Denial-of-Service Countermeasures ..................15
           4.2.2. Handshake Message Format ...........................18
           4.2.3. Handshake Message Fragmentation and Reassembly .....19
           4.2.4. Timeout and Retransmission .........................20
                  4.2.4.1. Timer Values ..............................24
           4.2.5. ChangeCipherSpec ...................................25
           4.2.6. CertificateVerify and Finished Messages ............25
           4.2.7. Alert Messages .....................................25
           4.2.8. Establishing New Associations with Existing
                  Parameters .........................................25
      4.3. Summary of New Syntax .....................................26
           4.3.1. Record Layer .......................................26
           4.3.2. Handshake Protocol .................................27
   5. Security Considerations ........................................27
   6. Acknowledgments ................................................28
   7. IANA Considerations ............................................28
   8. Changes since DTLS 1.0 .........................................29
   9. References .....................................................30
      9.1. Normative References ......................................30
      9.2. Informative References ....................................31
```

---
## **1.  Introduction**

TLS\[TLS\]는 네트워크 트래픽 보안을 위해 가장 널리 배포되는 프로토콜입니다. 이는 웹 트래픽을 보호하고 IMAP\[IMAP\] 및 POP\[POP\]과 같은 전자 메일 프로토콜에 널리 사용됩니다. TLS의 주요 장점은 투명한 연결 지향 채널을 제공한다는 것입니다. 따라서 애플리케이션 계층과 전송 계층 사이에 TLS를 삽입함으로써 애플리케이션 프로토콜의 보안을 확보하는 것이 용이하다. 그러나 TLS는 안정적인 전송 채널\(일반적으로 TCP\[TCP\]\)을 통해 실행되어야 합니다. 따라서 신뢰할 수 없는 데이터그램 트래픽을 보호하는 데 사용할 수 없습니다.

UDP 전송을 사용하는 애플리케이션 계층 프로토콜이 점점 더 많이 설계되었습니다. 특히 SIP\(Session Initiation Protocol\) \[SIP\] 및 전자 게임 프로토콜과 같은 프로토콜이 점점 더 대중화되고 있습니다. \(SIP는 TCP와 UDP 모두에서 실행될 수 있지만 UDP가 선호되는 상황이 있다는 점에 유의하십시오.\) 현재 이러한 애플리케이션의 설계자는 여러 가지 만족스럽지 못한 선택에 직면해 있습니다. 첫째, IPsec \[RFC4301\]을 사용할 수 있습니다. 그러나 \[WHYIPSEC\]에 자세히 설명된 여러 가지 이유로 인해 이는 일부 애플리케이션에만 적합합니다. 둘째, 맞춤형 애플리케이션 계층 보안 프로토콜을 설계할 수 있습니다. 불행하게도 애플리케이션 계층 보안 프로토콜은 일반적으로 우수한 보안 속성\(예: S/MIME의 경우 종단 간 보안\)을 제공하지만 일반적으로 상대적으로 적은 양의 보안 프로토콜과 달리 설계에 많은 노력이 필요합니다. TLS를 통해 프로토콜을 실행하는 데 필요한 노력입니다.

많은 경우 클라이언트/서버 애플리케이션을 보호하는 가장 바람직한 방법은 TLS를 사용하는 것입니다. 그러나 데이터그램 의미론에 대한 요구 사항은 자동으로 TLS 사용을 금지합니다. 이 메모에서는 이러한 목적을 위한 프로토콜인 DTLS\(데이터그램 전송 계층 보안\)에 대해 설명합니다. DTLS는 새로운 보안 발명을 최소화하고 코드 및 인프라 재사용의 양을 최대화하기 위해 의도적으로 TLS와 유사하게 설계되었습니다.

DTLS 1.0 \[DTLS1\]은 원래 \[TLS11\]의 델타로 정의되었습니다. 이 문서에서는 TLS 1.2\[TLS12\]에 대한 일련의 델타로 정의된 DTLS의 새 버전인 DTLS 1.2를 소개합니다. DTLS 1.1은 없습니다. 버전 번호를 TLS와 조화시키기 위해 해당 버전 번호를 건너뛰었습니다. 또한 이 버전에서는 DTLS 1.0 사양의 몇 가지 혼란스러운 점을 명확하게 설명합니다.

DTLS 1.2와 DTLS 1.0을 모두 사용하는 구현은 TLS 1.2 구현이 이전 버전의 TLS와 상호 운용할 수 있는 것처럼 DTLS 1.0\(물론 DTLS 1.0 사용\)만 사용하는 구현과 상호 운용할 수 있습니다\(자세한 내용은 \[TLS12\]의 부록 E.1 참조\). \), 단, SSLv2 또는 SSLv3의 DTLS 버전이 없으므로 해당 프로토콜에 대한 이전 버전과의 호환성 문제는 적용되지 않습니다.

---
### **1.1. Requirements Terminology**

이 문서의 핵심 단어 "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY" 및 "OPTIONAL"은 다음과 같습니다. RFC 2119 \[REQ\]에 설명된 대로 해석됩니다.

---
## **2.  Usage Model**

DTLS 프로토콜은 통신 애플리케이션 간의 데이터를 보호하도록 설계되었습니다. 커널 수정 없이 애플리케이션 공간에서 실행되도록 설계되었습니다.

데이터그램 전송은 안정적이거나 순차적인 데이터 전달을 요구하거나 제공하지 않습니다. DTLS 프로토콜은 페이로드 데이터에 대해 이 속성을 유지합니다. 미디어 스트리밍, 인터넷 전화, 온라인 게임과 같은 애플리케이션은 전송되는 데이터의 지연에 민감한 특성으로 인해 통신에 데이터그램 전송을 사용합니다. DTLS 프로토콜이 통신 보안을 위해 사용될 때 이러한 애플리케이션의 동작은 변경되지 않습니다. DTLS 프로토콜은 손실되거나 순서가 변경된 데이터 트래픽을 보상하지 않기 때문입니다.

---
## **3.  Overview of DTLS**

DTLS의 기본 설계 철학은 "데이터그램 전송을 통한 TLS"를 구성하는 것입니다. 데이터그램 환경에서 TLS를 직접 사용할 수 없는 이유는 단순히 패킷이 손실되거나 재정렬될 수 있기 때문입니다. TLS에는 이러한 종류의 불안정성을 처리할 수 있는 내부 시설이 없습니다. 따라서 데이터그램 전송 시 다시 호스트되면 TLS 구현이 중단됩니다. DTLS의 목적은 이 문제를 해결하는 데 필요한 TLS를 최소한으로 변경하는 것입니다. 가능한 한 DTLS는 TLS와 동일합니다. 새로운 메커니즘을 개발해야 할 때마다 우리는 TLS 스타일을 유지하는 방식으로 그렇게 하려고 노력합니다.

신뢰성이 낮으면 TLS에 다음 두 가지 수준의 문제가 발생합니다.

1. TLS는 개별 기록의 독립적인 암호 해독을 허용하지 않습니다. 무결성 검사는 시퀀스 번호에 따라 달라지므로 레코드 N이 수신되지 않으면 레코드 N+1에 대한 무결성 검사가 잘못된 시퀀스 번호를 기반으로 하여 실패하게 됩니다. \(TLS 1.1 이전에는 명시적인 IV가 없었으므로 암호 해독도 실패했습니다.\)

1. TLS 핸드셰이크 계층은 핸드셰이크 메시지가 안정적으로 전달된다고 가정하고 해당 메시지가 손실되면 중단됩니다.

이 섹션의 나머지 부분에서는 DTLS가 이러한 문제를 해결하기 위해 사용하는 접근 방식을 설명합니다.

---
### **3.1.  Loss-Insensitive Messaging**

TLS의 트래픽 암호화 계층\(TLS 레코드 계층이라고 함\)에서 레코드는 독립적이지 않습니다. 레코드 간 종속성에는 두 가지 종류가 있습니다.

1. 레코드 간에 암호화 컨텍스트\(스트림 암호 키 스트림\)가 유지됩니다.

1. 재생 방지 및 메시지 재정렬 보호는 시퀀스 번호를 포함하는 MAC에 의해 제공되지만 시퀀스 번호는 레코드에 암시되어 있습니다.

DTLS는 스트림 암호를 금지하여 첫 번째 문제를 해결합니다. DTLS는 명시적인 시퀀스 번호를 추가하여 두 번째 문제를 해결합니다.

---
### **3.2.  Providing Reliability for Handshake**

TLS 핸드셰이크는 잠금 단계 암호화 핸드셰이크입니다. 메시지는 정의된 순서에 따라 전송 및 수신되어야 합니다. 다른 주문은 오류입니다. 분명히 이는 재정렬 및 ​​메시지 손실과 호환되지 않습니다. 또한 TLS 핸드셰이크 메시지는 잠재적으로 특정 데이터그램보다 크기 때문에 IP 조각화 문제가 발생합니다. DTLS는 이 두 가지 문제에 대한 수정 사항을 제공해야 합니다.

---
#### **3.2.1.  Packet Loss**

DTLS는 간단한 재전송 타이머를 사용하여 패킷 손실을 처리합니다. 다음 그림은 DTLS 핸드셰이크의 첫 번째 단계를 사용하는 기본 개념을 보여줍니다.

```text
         Client                                   Server
         ------                                   ------
         ClientHello           ------>

                                 X<-- HelloVerifyRequest
                                                  (lost)

         [Timer Expires]

         ClientHello           ------>
         (retransmit)
```

클라이언트가 ClientHello 메시지를 전송하면 서버에서 HelloVerifyRequest를 볼 것으로 예상합니다. 그러나 서버의 메시지가 손실되면 클라이언트는 ClientHello 또는 HelloVerifyRequest가 손실되었음을 알고 재전송합니다. 서버는 재전송을 수신하면 재전송을 인지합니다.

또한 서버는 재전송 타이머를 유지하고 해당 타이머가 만료되면 재전송합니다.

서버에서 상태를 생성해야 하기 때문에 시간 초과 및 재전송은 HelloVerifyRequest에 적용되지 않습니다. HelloVerifyRequest는 자체적으로 조각화되지 않을 만큼 충분히 작게 설계되어 여러 HelloVerifyRequest를 인터리빙하는 것에 대한 우려를 방지합니다.

---
#### **3.2.2.  Reordering**

DTLS에서 각 핸드셰이크 메시지에는 해당 핸드셰이크 내의 특정 시퀀스 번호가 할당됩니다. 피어가 핸드셰이크 메시지를 받으면 해당 메시지가 예상한 다음 메시지인지 빠르게 확인할 수 있습니다. 그렇다면 처리합니다. 그렇지 않은 경우 이전 메시지를 모두 수신한 후 향후 처리를 위해 대기열에 넣습니다.

---
#### **3.2.3.  Message Size**

TLS 및 DTLS 핸드셰이크 메시지는 상당히 클 수 있습니다\(이론적으로 최대 2^24-1바이트, 실제로는 수 킬로바이트\). 대조적으로, IP 조각화가 바람직하지 않은 경우 UDP 데이터그램은 1500바이트 미만으로 제한되는 경우가 많습니다. 이러한 제한을 보완하기 위해 각 DTLS 핸드셰이크 메시지는 여러 DTLS 레코드로 분할될 수 있으며, 각 레코드는 단일 IP 데이터그램에 맞도록 고안되었습니다. 각 DTLS 핸드셰이크 메시지에는 조각 오프셋과 조각 길이가 모두 포함되어 있습니다. 따라서 핸드셰이크 메시지의 모든 바이트를 소유한 수신자는 조각화되지 않은 원본 메시지를 재조립할 수 있습니다.

---
### **3.3.  Replay Detection**

DTLS는 선택적으로 레코드 재생 감지를 지원합니다. 사용된 기술은 수신된 레코드의 비트맵 창을 유지함으로써 IPsec AH/ESP와 동일합니다. 너무 오래되어 창에 맞지 ​​않는 레코드와 이전에 수신된 레코드는 자동으로 삭제됩니다. 패킷 복제가 항상 악의적인 것은 아니지만 라우팅 오류로 인해 발생할 수도 있으므로 재생 감지 기능은 선택 사항입니다. 응용 프로그램은 아마도 중복 패킷을 감지하고 이에 따라 데이터 전송 전략을 수정할 수 있습니다.

---
## **4.  Differences from TLS**

섹션 3에서 언급했듯이 DTLS는 의도적으로 TLS와 매우 유사합니다. 따라서 DTLS를 새로운 프로토콜로 제시하는 대신 TLS 1.2 \[TLS12\]의 일련의 델타로 제시합니다. 차이점을 명시적으로 설명하지 않는 경우 DTLS는 \[TLS12\]와 동일합니다.

---
### **4.1.  Record Layer**

DTLS 레코드 계층은 TLS 1.2의 레코드 계층과 매우 유사합니다. 유일한 변경 사항은 레코드에 명시적인 일련 번호가 포함된다는 것입니다. 이 시퀀스 번호를 통해 수신자는 TLS MAC를 올바르게 확인할 수 있습니다. DTLS 레코드 형식은 다음과 같습니다.

```text
      struct {
           ContentType type;
           ProtocolVersion version;
           uint16 epoch;                                    // New field
           uint48 sequence_number;                          // New field
           uint16 length;
           opaque fragment[DTLSPlaintext.length];
         } DTLSPlaintext;
```

유형 - TLS 1.2 레코드의 유형 필드와 동일합니다.

버전 - 사용 중인 프로토콜의 버전입니다. 이 문서에서는 버전 { 254, 253 }을 사용하는 DTLS 버전 1.2에 대해 설명합니다. 버전 값 254.253은 DTLS 버전 1.2의 1의 보수입니다. TLS와 DTLS 버전 번호 사이의 최대 간격은 두 프로토콜의 레코드를 쉽게 구별할 수 있도록 보장합니다. DTLS의 향후 온라인 버전 번호의 가치는 감소하고 있지만 실제 버전 번호의 가치는 증가하고 있다는 점에 유의해야 합니다.

epoch - 암호 상태가 변경될 때마다 증가하는 카운터 값입니다.

시퀀스\_번호 - 이 레코드의 시퀀스 번호입니다.

길이 - TLS 1.2 레코드의 길이 필드와 동일합니다. TLS 1.2와 마찬가지로 길이는 2^14를 초과할 수 없습니다.

조각 - TLS 1.2 레코드의 조각 필드와 동일합니다.

DTLS는 레코드의 시퀀스 번호 필드에 포함된 암시적 시퀀스 번호가 아닌 명시적 시퀀스 번호를 사용합니다. 시퀀스 번호는 각 에포크마다 별도로 유지 관리되며, 각 에포크에 대해 각 시퀀스\_번호는 초기에 0입니다. 예를 들어, epoch 0의 핸드셰이크 메시지가 재전송되면 epoch 1의 메시지가 epoch 1의 메시지 뒤에 시퀀스 번호가 있을 수 있습니다.

먼저 전달되었습니다. 재전송된 메시지가 올바른 에포크와 키 자료를 사용하도록 보장하려면 핸드셰이크 중에 약간의 주의가 필요합니다.

여러 핸드셰이크가 연속적으로 수행되는 경우 회선에 시퀀스 번호는 동일하지만 암호화 상태가 다른 여러 레코드가 있을 수 있습니다. epoch 필드를 사용하면 수신자가 이러한 패킷을 구별할 수 있습니다. 에포크 번호는 처음에는 0이며 ChangeCipherSpec 메시지가 전송될 때마다 증가됩니다. 주어진 시퀀스/에포크 쌍이 고유하다는 것을 보장하기 위해 구현에서는 TCP 최대 세그먼트 수명의 2배 내에서 동일한 에포크 값이 재사용되는 것을 허용해서는 안 됩니다. 실제로 TLS 구현은 재핸드셰이크를 거의 수행하지 않습니다. 따라서 이것이 문제가 될 것으로 예상하지 않습니다.

DTLS 레코드는 재정렬될 수 있으므로 에포크 2가 시작된 후에 에포크 1의 레코드가 수신될 수 있습니다. 일반적으로 구현은 이전 시대의 패킷을 폐기해야 하지만, 패킷 손실로 인해 눈에 띄는 문제가 발생하는 경우 패킷 재정렬을 허용하기 위해 TCP\[TCP\]에 대해 지정된 기본 MSL까지 이전 시대의 키 자료를 유지하도록 선택할 수 있습니다. \(여기서의 의도는 구현자가 MSL에 대한 IETF의 현재 지침을 사용하는 것이지 시스템 TCP 스택이 사용하는 MSL을 조사하려는 것이 아닙니다.\) 핸드셰이크가 완료될 때까지 구현은 이전 시대의 패킷을 수락해야 합니다. .

반대로, 새로 협상된 컨텍스트에 의해 보호되는 레코드가 핸드셰이크가 완료되기 전에 수신될 수도 있습니다. 예를 들어, 서버는 Finished 메시지를 보낸 다음 데이터 전송을 시작할 수 있습니다. 구현에서는 이러한 패킷을 버퍼링하거나 삭제할 수 있지만 DTLS가 안정적인 전송\(예: SCTP\)을 통해 사용되는 경우 핸드셰이크가 완료되면 버퍼링되고 처리되어야 합니다. 패킷 전송 시기에 대한 TLS의 제한 사항은 여전히 ​​적용되며 수신자는 패킷이 올바른 순서로 전송된 것처럼 처리합니다. 특히 첫 번째 핸드셰이크가 완료되기 전에 데이터를 보내는 것은 여전히 ​​허용되지 않습니다.

기존 연결에 대한 재핸드셰이크의 특수한 경우에는 ChangeCipherSpec 또는 Finished 메시지가 아직 수신되지 않은 경우에도 재핸드셰이크가 기존 세션을 재개하거나 정확하게 사용하는 경우 데이터 패킷을 즉시 처리하는 것이 안전합니다. 기존 연관과 동일한 보안 매개변수. 다른 경우에는 다운그레이드 공격을 방지하기 위해 구현이 완료 메시지 수신을 기다려야 합니다.

TLS에서와 마찬가지로 구현은 시퀀스 번호 래핑을 허용하기 전에 연결을 포기하거나 재핸드셰이크를 수행해야 합니다.

마찬가지로 구현은 에포크 랩핑을 허용해서는 안 되며, 대신 섹션 4.2.8에 설명된 대로 이전 연결을 종료하여 새 연결을 설정해야 합니다. 실제로 구현 시 동일한 채널에서 반복적으로 재핸드셰이크를 수행하는 경우는 거의 없으므로 이는 문제가 되지 않습니다.

---
#### **4.1.1.  Transport Layer Mapping**

각 DTLS 레코드는 단일 데이터그램 내에 맞아야 합니다. IP 조각화를 피하기 위해 DTLS 레코드 계층의 클라이언트는 레코드 계층에서 얻은 PMTU 추정치 내에 맞도록 레코드 크기를 조정해야 합니다.

IPsec과 달리 DTLS 레코드에는 연결 식별자가 포함되어 있지 않습니다. 애플리케이션은 연관 간의 다중화를 준비해야 합니다. UDP를 사용하면 이는 아마도 호스트/포트 번호를 사용하여 수행될 것입니다.

여러 DTLS 레코드가 단일 데이터그램에 배치될 수 있습니다. 단순히 연속적으로 인코딩됩니다. DTLS 레코드 프레이밍은 경계를 결정하는 데 충분합니다. 그러나 데이터그램 페이로드의 첫 번째 바이트는 레코드의 시작이어야 합니다. 레코드는 데이터그램에 걸쳐 있을 수 없습니다.

DCCP\[DCCP\]와 같은 일부 전송은 자체 시퀀스 번호를 제공합니다. 해당 전송을 통해 전달되면 DTLS와 전송 시퀀스 번호가 모두 표시됩니다. 이로 인해 약간의 비효율성이 발생하기는 하지만 전송 계층과 DTLS 시퀀스 번호는 서로 다른 용도로 사용됩니다. 따라서 개념적 단순화를 위해 두 시퀀스 번호를 모두 사용하는 것이 더 좋습니다. 앞으로는 제한된 환경에서 배포를 위해 하나의 시퀀스 번호 세트만 사용할 수 있도록 DTLS에 대한 확장이 지정될 수 있습니다.

DCCP와 같은 일부 전송은 전송되는 트래픽에 대해 혼잡 제어를 제공합니다. 혼잡 창이 충분히 좁은 경우 DTLS 핸드셰이크 재전송이 즉시 전송되지 않고 보류되어 잠재적으로 시간 초과 및 허위 재전송이 발생할 수 있습니다. 이러한 전송에 대해 DTLS를 사용할 경우 혼잡 가능성이 있는 창을 초과하지 않도록 주의해야 합니다. \[DCCPDTLS\]는 이러한 문제를 고려하여 DTLS와 DCCP의 매핑을 정의합니다.

---
##### **4.1.1.1.  PMTU Issues**

일반적으로 DTLS의 철학은 PMTU 검색을 애플리케이션에 맡기는 것입니다. 그러나 DTLS는 다음 세 가지 이유로 PMTU를 완전히 무시할 수 없습니다.

- DTLS 레코드 프레이밍은 데이터그램 크기를 확장하여 애플리케이션 관점에서 효과적인 PMTU를 낮춥니다.

- 일부 구현에서는 애플리케이션이 네트워크와 직접 통신하지 못할 수 있습니다. 이 경우 DTLS 스택은 ICMP \[RFC1191\] "데이터그램 너무 큼" 표시 또는 ICMPv6 \[RFC4443\] "패킷 너무 큼" 표시를 흡수할 수 있습니다.

- DTLS 핸드셰이크 메시지는 PMTU를 초과할 수 있습니다.

처음 두 가지 문제를 처리하려면 DTLS 레코드 계층이 아래 설명된 대로 동작해야 합니다.

기본 전송 프로토콜에서 PMTU 추정치를 사용할 수 있는 경우 상위 계층 프로토콜에서도 사용할 수 있어야 합니다. 특히:

- UDP를 통한 DTLS의 경우 상위 계층 프로토콜은 IP 계층에서 유지되는 PMTU 추정치를 획득하도록 허용되어야 합니다.

- DCCP를 통한 DTLS의 경우 상위 계층 프로토콜이 PMTU의 현재 추정치를 얻을 수 있도록 허용해야 합니다.

- 데이터그램을 자동으로 조각화하고 재조립하는 TCP 또는 SCTP를 통한 DTLS의 경우 PMTU 제한이 없습니다. 그러나 상위 계층 프로토콜은 최대 레코드 크기인 2^14바이트를 초과하는 레코드를 작성해서는 안 됩니다.

DTLS 레코드 계층은 상위 계층 프로토콜이 DTLS 처리에 의해 예상되는 레코드 확장의 양을 발견할 수 있도록 허용해야 합니다\(SHOULD\). 이 숫자는 블록 패딩과 DTLS 압축의 잠재적 사용으로 인한 추정치일 뿐입니다.

전송 프로토콜 표시\(ICMP를 통하거나 \[DCCP\]의 섹션 14에서와 같이 데이터그램 전송 거부를 통해\)가 있는 경우 DTLS 레코드 계층은 상위 계층 프로토콜에 오류를 알려야 합니다.

DTLS 레코드 계층은 \[RFC1191\] 또는 \[RFC4821\] 메커니즘을 통해 PMTU 검색을 수행하는 상위 계층 프로토콜을 간섭해서는 안 됩니다. 특히:

- 기본 전송 프로토콜에서 허용하는 경우 상위 계층 프로토콜은 DF 비트 상태\(IPv4에서\)를 설정하거나 로컬 조각화\(IPv6에서\)를 금지하도록 허용해야 합니다.

- 기본 전송 프로토콜이 애플리케이션이 PMTU 검색\(예: DCCP\)을 요청하도록 허용하는 경우 DTLS 레코드 계층은 이 요청을 수락해야 합니다.

마지막 문제는 DTLS 핸드셰이크 프로토콜입니다. DTLS 레코드 계층의 관점에서 보면 이는 또 다른 상위 계층 프로토콜일 뿐입니다. 그러나 DTLS 핸드셰이크는 자주 발생하지 않으며 몇 번의 왕복만 포함됩니다. 따라서 핸드셰이크 프로토콜 PMTU 처리는 정확한 PMTU 검색보다 빠른 완료에 더 중점을 둡니다. 이러한 상황에서 연결을 허용하려면 DTLS 구현은 다음 규칙을 따라야 합니다.

- DTLS 레코드 계층이 DTLS 핸드셰이크 계층에 메시지가 너무 크다고 알리면 PMTU에 대한 기존 정보를 사용하여 즉시 조각화를 시도해야 합니다.

- 반복된 재전송이 응답을 가져오지 않고 PMTU를 알 수 없는 경우 후속 재전송은 더 작은 레코드 크기로 백오프하여 핸드셰이크 메시지를 적절하게 조각화해야 합니다. 이 표준은 백오프 전 시도할 정확한 재전송 횟수를 지정하지 않지만 2\~3회가 적절해 보입니다.

---
#### **4.1.2.  Record Payload Protection**

TLS와 마찬가지로 DTLS는 데이터를 일련의 보호된 레코드로 전송합니다. 이 섹션의 나머지 부분에서는 해당 형식에 대해 자세히 설명합니다.

---
##### **4.1.2.1.  MAC**

DTLS MAC은 TLS 1.2와 동일합니다. 그러나 TLS의 암시적 시퀀스 번호를 사용하는 대신 MAC을 계산하는 데 사용되는 시퀀스 번호는 회선에 나타나는 순서대로 에포크와 시퀀스 번호를 연결하여 형성된 64비트 값입니다. DTLS 에포크 + 시퀀스 번호는 TLS 시퀀스 번호와 길이가 동일합니다.

TLS MAC 계산은 프로토콜 버전 번호에서 매개변수화됩니다. 이는 DTLS의 경우 실시간 버전입니다\(예: DTLS 1.2의 경우 {254, 253}\).

DTLS와 TLS MAC 처리 간의 한 가지 중요한 차이점은 TLS에서는 MAC 오류로 인해 연결이 종료되어야 한다는 것입니다. DTLS에서 수신 구현은 단순히 문제가 있는 레코드를 삭제하고 연결을 계속할 수 있습니다. 이러한 변경은 DTLS 레코드가 TLS 레코드와 달리 서로 종속되지 않기 때문에 가능합니다.

일반적으로 DTLS 구현은 잘못된 MAC이 있거나 유효하지 않은 레코드를 자동으로 삭제해야 합니다\(SHOULD\). 그들은 오류를 기록할 수도 있습니다. DTLS 구현이 유효하지 않은 MAC가 포함된 메시지를 수신할 때 경고를 생성하도록 선택한 경우 bad\_record\_mac 경고를 생성해야 합니다.

치명적인 수준으로 연결 상태를 종료합니다. 오류로 인해 연결이 종료되지 않으므로 DTLS 스택은 TLS 스택보다 더 효율적인 오류 유형 오라클입니다. 따라서 \[TLS12\] 섹션 6.2.3.2의 조언을 따르는 것이 특히 중요합니다.

---
##### **4.1.2.2.  Null or Standard Stream Cipher**

DTLS NULL 암호화는 TLS 1.2 NULL 암호화와 동일하게 수행됩니다.

TLS 1.2에 설명된 유일한 스트림 암호는 무작위로 액세스할 수 없는 RC4입니다. RC4는 DTLS와 함께 사용하면 안 됩니다.

---
##### **4.1.2.3.  Block Cipher**

DTLS 블록 암호 암호화 및 암호 해독은 TLS 1.2와 동일하게 수행됩니다.

---
##### **4.1.2.4.  AEAD Ciphers**

TLS 1.2에는 추가 데이터\(AEAD\) 암호화 제품군을 사용한 인증된 암호화가 도입되었습니다. \[ECCGCM\] 및 \[RSAGCM\]에 정의된 기존 AEAD 암호화 제품군은 TLS 1.2와 동일하게 DTLS와 함께 사용할 수 있습니다.

---
##### **4.1.2.5.  New Cipher Suites**

등록 시 새로운 TLS 암호화 제품군은 반드시 DTLS 사용에 적합한지 여부와 적용해야 하는 경우 무엇을 수정해야 하는지 명시해야 합니다\(IANA 고려 사항은 섹션 7 참조\).

---
##### **4.1.2.6.  Anti-Replay**

DTLS 레코드에는 재생 보호를 제공하는 시퀀스 번호가 포함되어 있습니다. 시퀀스 번호 확인은 \[ESP\]의 섹션 3.4.3에서 가져온 다음 슬라이딩 윈도우 절차를 사용하여 수행되어야 합니다.

이 세션에 대한 수신자 패킷 카운터는 세션이 설정될 때 0으로 초기화되어야 합니다. 수신된 각 레코드에 대해 수신자는 해당 레코드에 이 세션 기간 동안 수신된 다른 레코드의 시퀀스 번호와 중복되지 않는 시퀀스 번호가 포함되어 있는지 확인해야 합니다. 이는 중복 레코드 거부 속도를 높이기 위해 패킷이 세션과 일치된 후 패킷에 적용되는 첫 번째 확인이어야 합니다.

슬라이딩 수신 창을 사용하여 중복 항목이 거부됩니다. \(창이 구현되는 방법은 지역적 문제이지만 다음 텍스트에서는 구현이 표시해야 하는 기능을 설명합니다.\) 최소 창 크기 32가 지원되어야 하지만

창 크기 64가 선호되며 기본값으로 사용해야 합니다. 수신자는 다른 창 크기\(최소값보다 큰\)를 선택할 수 있습니다. \(수신자는 송신자에게 창 크기를 알리지 않습니다.\)

창의 "오른쪽" 가장자리는 이 세션에서 수신된 가장 높은 검증된 시퀀스 번호 값을 나타냅니다. 창의 "왼쪽" 가장자리보다 낮은 시퀀스 번호를 포함하는 레코드는 거부됩니다. 창 내에 있는 패킷은 창 내에서 수신된 패킷 목록과 비교하여 확인됩니다. 비트 마스크 사용을 기반으로 이 검사를 수행하는 효율적인 방법은 \[ESP\]의 섹션 3.4.3에 설명되어 있습니다.

수신된 레코드가 창 내에 있고 새 레코드이거나 패킷이 창 오른쪽에 있는 경우 수신기는 MAC 확인을 진행합니다. MAC 검증이 실패하면 수신자는 수신된 레코드를 유효하지 않은 것으로 폐기해야 합니다. 수신 창은 MAC 확인이 성공한 경우에만 업데이트됩니다.

---
##### **4.1.2.7.  Handling Invalid Records**

TLS와 달리 DTLS는 잘못된 레코드\(예: 잘못된 형식, 길이, MAC 등\)가 있는 경우 복원력이 뛰어납니다. 일반적으로 유효하지 않은 기록은 자동으로 폐기되어야 하며 따라서 연관성이 유지되어야 합니다. 그러나 진단 목적으로 오류가 기록될 수 있습니다. 대신 경고를 생성하기로 선택한 구현은 공격자가 구현을 반복적으로 조사하여 다양한 유형의 오류에 어떻게 대응하는지 확인하는 공격을 피하기 위해 치명적인 수준의 경고를 생성해야 합니다. DTLS가 UDP를 통해 실행되는 경우 UDP 위조가 매우 쉽기 때문에 이를 수행하는 모든 구현은 서비스 거부\(DoS\) 공격에 매우 취약합니다. 따라서 이러한 방식은 그러한 전송에 권장되지 않습니다.

DTLS가 위조 방지 전송\(예: SCTP-AUTH가 포함된 SCTP\)을 통해 전달되는 경우 공격자가 전송 계층에서 거부되지 않는 데이터그램을 위조하는 데 어려움을 겪게 되므로 경고를 보내는 것이 더 안전합니다.

---
### **4.2.  The DTLS Handshake Protocol**

DTLS는 세 가지 주요 변경 사항을 제외하고 TLS와 동일한 핸드셰이크 메시지 및 흐름을 모두 사용합니다.

1. 서비스 거부 공격을 방지하기 위해 상태 비저장 쿠키 교환이 추가되었습니다.

1. 메시지 손실, 재정렬 및 ​​DTLS 메시지 조각화\(IP 조각화를 방지하기 위해\)를 처리하기 위해 핸드셰이크 헤더를 수정합니다.

1. 메시지 손실을 처리하기 위한 재전송 타이머.

이러한 예외를 제외하면 DTLS 메시지 형식, 흐름 및 논리는 TLS 1.2와 동일합니다.

---
#### **4.2.1.  Denial-of-Service Countermeasures**

데이터그램 보안 프로토콜은 다양한 DoS 공격에 매우 취약합니다. 특히 우려되는 두 가지 공격은 다음과 같습니다.

1. 공격자는 일련의 핸드셰이크 시작 요청을 전송하여 서버에서 과도한 리소스를 소비할 수 있으며, 이로 인해 서버는 상태를 할당하고 잠재적으로 비용이 많이 드는 암호화 작업을 수행하게 됩니다.

1. 공격자는 피해자의 소스를 위조하여 연결 시작 메시지를 보내 서버를 증폭기로 사용할 수 있습니다. 그런 다음 서버는 다음 메시지\(DTLS에서는 상당히 클 수 있는 인증서 메시지\)를 피해자 컴퓨터에 보내서 플러딩을 발생시킵니다.

이 두 가지 공격에 대응하기 위해 DTLS는 Photuris \[PHOTURIS\] 및 IKE \[IKEv2\]에서 사용하는 상태 비저장 쿠키 기술을 차용합니다. 클라이언트가 ClientHello 메시지를 서버에 보낼 때 서버는 HelloVerifyRequest 메시지로 응답할 수 있습니다. 이 메시지에는 \[PHOTURIS\] 기술을 사용하여 생성된 상태 비저장 쿠키가 포함되어 있습니다. 클라이언트는 쿠키가 추가된 ClientHello를 재전송해야 합니다. 그런 다음 서버는 쿠키를 확인하고 유효한 경우에만 핸드셰이크를 진행합니다. 이 메커니즘은 공격자/클라이언트가 쿠키를 수신할 수 있도록 강제하여 스푸핑된 IP 주소를 사용한 DoS 공격을 어렵게 만듭니다. 이 메커니즘은 유효한 IP 주소에서 탑재된 DoS 공격에 대한 방어 기능을 제공하지 않습니다.

교환은 아래와 같습니다.

```text
      Client                                   Server
      ------                                   ------
      ClientHello           ------>

                            <----- HelloVerifyRequest
                                   (contains cookie)

      ClientHello           ------>
      (with cookie)
```

- \[나머지 악수\]

따라서 DTLS는 ClientHello 메시지를 수정하여 쿠키 값을 추가합니다.

```text
   struct {
     ProtocolVersion client_version;
     Random random;
     SessionID session_id;
     opaque cookie<0..2^8-1>;                             // New field
     CipherSuite cipher_suites<2..2^16-1>;
           CompressionMethod compression_methods<1..2^8-1>;
   } ClientHello;
```

첫 번째 ClientHello를 보낼 때 클라이언트에는 아직 쿠키가 없습니다. 이 경우 쿠키 필드는 비어 있습니다\(길이 0\).

HelloVerifyRequest의 정의는 다음과 같습니다.

```text
   struct {
     ProtocolVersion server_version;
     opaque cookie<0..2^8-1>;
   } HelloVerifyRequest;
```

HelloVerifyRequest 메시지 유형은 hello\_verify\_request\(3\)입니다.

server\_version 필드는 TLS와 동일한 구문을 갖습니다. 그러나 초기 핸드셰이크에서 버전 협상을 수행해야 하는 요구 사항을 피하기 위해 DTLS 1.2 서버 구현은 협상될 것으로 예상되는 TLS 버전에 관계없이 DTLS 버전 1.0을 사용해야 합니다. DTLS 1.2 및 1.0 클라이언트는 버전 협상의 일부가 아닌 패킷 형식\(DTLS 1.2 및 1.0 모두에서 동일\)을 나타내기 위해서만 버전을 사용해야 합니다. 특히, DTLS 1.2 클라이언트는 서버가 HelloVerifyRequest에서 버전 1.0을 사용하기 때문에 서버가 DTLS 1.2가 아니거나 결국 DTLS 1.2가 아닌 DTLS 1.0을 협상할 것이라고 가정해서는 안 됩니다.

HelloVerifyRequest에 응답할 때 클라이언트는 원래 ClientHello에서와 동일한 매개변수 값\(version, random, session\_id, cipher\_suites, 압축\_method\)을 사용해야 합니다. 서버는 해당 값을 사용하여 쿠키를 생성하고 쿠키 수신 시 해당 값이 올바른지 확인해야 합니다. 서버는 ServerHello를 보낼 때 사용할 HelloVerifyRequest에서 동일한 버전 번호를 사용해야 합니다. ServerHello를 수신하면 클라이언트는 서버 버전 값이 일치하는지 확인해야 합니다. 여러 HelloVerifyRequests의 경우 시퀀스 번호 중복을 피하기 위해 서버는 ClientHello의 레코드 시퀀스 번호를 HelloVerifyRequest의 레코드 시퀀스 번호로 사용해야 합니다.

참고: 이 사양에서는 향후 유연성을 높이기 위해 쿠키 크기 제한을 255바이트로 늘립니다. 이전 버전의 DTLS에서는 제한이 32개로 유지됩니다.

DTLS 서버는 서버에서 클라이언트별 상태를 유지하지 않고 확인할 수 있는 방식으로 쿠키를 생성해야 합니다. 한 가지 기술은 무작위로 생성된 비밀을 갖고 다음과 같이 쿠키를 생성하는 것입니다.

```text
      Cookie = HMAC(Secret, Client-IP, Client-Parameters)
```

두 번째 ClientHello가 수신되면 서버는 쿠키가 유효한지, 클라이언트가 지정된 IP 주소에서 패킷을 수신할 수 있는지 확인할 수 있습니다. 다중 쿠키 교환의 경우 시퀀스 번호 중복을 피하기 위해 서버는 ClientHello의 레코드 시퀀스 번호를 초기 ServerHello의 레코드 시퀀스 번호로 사용해야 합니다. 후속 ServerHellos는 서버가 상태를 생성한 후에만 전송되며 정상적으로 증가해야 합니다.

이 체계에 대한 잠재적인 공격 중 하나는 공격자가 여러 주소에서 여러 쿠키를 수집한 다음 이를 재사용하여 서버를 공격하는 것입니다. 서버는 Secret 값을 자주 변경하여 해당 쿠키를 무효화함으로써 이 공격을 방어할 수 있습니다. 서버가 합법적인 클라이언트가 전환을 통해 핸드셰이크할 수 있기를 원하는 경우\(예: Secret 1이 포함된 쿠키를 수신한 다음 서버가 Secret 2로 변경된 후 두 번째 ClientHello를 전송함\) 서버는 해당 클라이언트가 작동하는 동안 제한된 창을 가질 수 있습니다. 두 비밀을 모두 받아들입니다. \[IKEv2\]에서는 이 경우를 감지하기 위해 쿠키에 버전 번호를 추가할 것을 제안합니다. 다른 접근 방식은 단순히 두 비밀을 모두 확인하는 것입니다.

DTLS 서버는 새로운 핸드셰이크가 수행될 때마다 쿠키 교환을 수행해야 합니다. 증폭이 문제가 되지 않는 환경에서 서버가 운영되고 있는 경우, 서버는 쿠키 교환을 수행하지 않도록 구성될 수 있습니다. 그러나 기본값은 교환이 수행되는 것이어야 합니다. 또한 서버는

세션이 재개될 때 쿠키 교환을 수행하지 않도록 선택합니다. 클라이언트는 모든 핸드셰이크에서 쿠키 교환을 수행할 준비가 되어 있어야 합니다.

HelloVerifyRequest를 사용하는 경우 초기 ClientHello 및 HelloVerifyRequest는 handshake\_messages\(CertificateVerify 메시지의 경우\) 및 verify\_data\(Finished 메시지의 경우\) 계산에 포함되지 않습니다.

서버가 유효하지 않은 쿠키가 포함된 ClientHello를 수신하는 경우 이를 쿠키가 없는 ClientHello와 동일하게 처리해야 합니다. 이렇게 하면 클라이언트가 잘못된 쿠키를 얻는 경우\(예: 서버가 쿠키 서명 키를 변경하는 경우\) 경합/교착 상태를 방지할 수 있습니다.

구현자 참고 사항: 이로 인해 클라이언트가 서로 다른 쿠키가 포함된 여러 HelloVerifyRequest 메시지를 수신하게 될 수 있습니다. 클라이언트는 새로운 HelloVerifyRequest에 대한 응답으로 쿠키와 함께 새로운 ClientHello를 전송하여 이를 처리해야 합니다.

---
#### **4.2.2.  Handshake Message Format**

메시지 손실, 재정렬 및 ​​메시지 조각화를 지원하기 위해 DTLS는 TLS 1.2 핸드셰이크 헤더를 수정합니다.

```text
   struct {
     HandshakeType msg_type;
     uint24 length;
     uint16 message_seq;                               // New field
     uint24 fragment_offset;                           // New field
     uint24 fragment_length;                           // New field
     select (HandshakeType) {
       case hello_request: HelloRequest;
       case client_hello:  ClientHello;
       case hello_verify_request: HelloVerifyRequest;  // New type
       case server_hello:  ServerHello;
       case certificate:Certificate;
       case server_key_exchange: ServerKeyExchange;
       case certificate_request: CertificateRequest;
       case server_hello_done:ServerHelloDone;
       case certificate_verify:  CertificateVerify;
       case client_key_exchange: ClientKeyExchange;
       case finished: Finished;
     } body;
   } Handshake;
```

각 핸드셰이크에서 각 측이 전송하는 첫 번째 메시지는 항상 message\_seq = 0입니다. 각각의 새 메시지가 생성될 때마다 message\_seq 값은 1씩 증가합니다. 다음의 경우에는 주의하세요.

rehandshake, 이는 HelloRequest가 message\_seq = 0을 가지며 ServerHello가 message\_seq = 1을 갖는다는 것을 의미합니다. 메시지가 재전송될 때 동일한 message\_seq 값이 사용됩니다. 예를 들어:

```text
         Client                             Server
         ------                             ------
         ClientHello (seq=0)  ------>

                                 X<-- HelloVerifyRequest (seq=0)
                                                 (lost)

         [Timer Expires]

         ClientHello (seq=0)  ------>
         (retransmit)

                              <------ HelloVerifyRequest (seq=0)

         ClientHello (seq=1)  ------>
         (with cookie)

                              <------        ServerHello (seq=1)
                              <------        Certificate (seq=2)
                              <------    ServerHelloDone (seq=3)
```

- \[나머지 악수\]

그러나 DTLS 레코드 계층의 관점에서 보면 재전송은 새로운 레코드라는 점에 유의하세요. 이 레코드는 새로운 DTLSPlaintext.sequence\_number 값을 갖게 됩니다.

DTLS 구현은 \(적어도 개념적으로는\) next\_receive\_seq 카운터를 유지합니다. 이 카운터는 처음에 0으로 설정됩니다. 메시지가 수신되면 해당 시퀀스 번호가 next\_receive\_seq와 일치하면 next\_receive\_seq가 증가하고 메시지가 처리됩니다. 시퀀스 번호가 next\_receive\_seq보다 작으면 메시지를 폐기해야 합니다. 시퀀스 번호가 next\_receive\_seq보다 큰 경우 구현은 메시지를 대기열에 추가해야 하지만 삭제할 수 있습니다. \(이것은 단순한 공간/대역폭 절충안입니다.\)

---
#### **4.2.3.  Handshake Message Fragmentation and Reassembly**

섹션 4.1.1에서 설명한 것처럼 각 DTLS 메시지는 단일 전송 계층 데이터그램 내에 맞아야 합니다. 그러나 핸드셰이크 메시지는 최대 레코드 크기보다 클 가능성이 있습니다. 따라서 DTLS는 핸드셰이크 메시지를 여러 레코드로 조각화하는 메커니즘을 제공합니다. 각 레코드는 개별적으로 전송될 수 있으므로 IP 조각화를 방지할 수 있습니다.

핸드셰이크 메시지를 전송할 때 보낸 사람은 메시지를 일련의 N개의 연속적인 데이터 범위로 나눕니다. 이러한 범위는 최대 핸드셰이크 조각 크기보다 클 수 없으며 전체 핸드셰이크 메시지를 함께 포함해야 합니다. 범위는 겹쳐서는 안 됩니다. 그런 다음 발신자는 원본 핸드셰이크 메시지와 동일한 message\_seq 값을 사용하여 N개의 핸드셰이크 메시지를 생성합니다. 각각의 새 메시지에는 조각\_오프셋\(이전 조각에 포함된 바이트 수\) 및 조각\_길이\(이 조각의 길이\) 레이블이 지정됩니다. 모든 메시지의 길이 필드는 원본 메시지의 길이 필드와 동일합니다. 조각화되지 않은 메시지는 조각\_오프셋=0 및 조각\_길이=길이를 갖는 퇴화 사례입니다.

DTLS 구현이 핸드셰이크 메시지 조각을 수신하면 전체 핸드셰이크 메시지를 얻을 때까지 이를 버퍼링해야 합니다. DTLS 구현은 겹치는 조각 범위를 처리할 수 있어야 합니다. 이를 통해 발신자는 PMTU 추정치가 변경되는 경우 더 작은 조각 크기로 핸드셰이크 메시지를 재전송할 수 있습니다.

TLS와 마찬가지로 공간이 있고 동일한 항공편의 일부인 경우 여러 핸드셰이크 메시지가 동일한 DTLS 레코드에 배치될 수 있습니다. 따라서 두 개의 DTLS 메시지를 동일한 데이터그램으로 묶는 데는 동일한 레코드 또는 별도의 레코드라는 두 가지 방법이 있습니다.

---
#### **4.2.4.  Timeout and Retransmission**

DTLS 메시지는 아래 다이어그램에 따라 일련의 메시지 플라이트로 그룹화됩니다. 각 메시지 비행은 여러 메시지로 구성될 수 있지만 시간 초과 및 재전송을 위해 단일체로 간주되어야 합니다.

```text
   Client                                          Server
   ------                                          ------

   ClientHello             -------->                           Flight 1

                           <-------    HelloVerifyRequest      Flight 2

   ClientHello             -------->                           Flight 3

                                              ServerHello    \
                                             Certificate*     \
                                       ServerKeyExchange*      Flight 4
                                      CertificateRequest*     /
                           <--------      ServerHelloDone    /

   Certificate*                                              \
   ClientKeyExchange                                          \
   CertificateVerify*                                          Flight 5
   [ChangeCipherSpec]                                         /
   Finished                -------->                         /

                                       [ChangeCipherSpec]    \ Flight 6
                           <--------             Finished    /
```

- 그림 1. 전체 핸드셰이크를 위한 메시지 플라이트

```text
   Client                                           Server
   ------                                           ------

   ClientHello             -------->                          Flight 1

                                              ServerHello    \
                                       [ChangeCipherSpec]     Flight 2
                            <--------             Finished    /

   [ChangeCipherSpec]                                         \Flight 3
   Finished                 -------->                         /

         Figure 2. Message Flights for Session-Resuming Handshake
                           (No Cookie Exchange)
```

DTLS는 다음 상태 머신과 함께 간단한 시간 초과 및 재전송 체계를 사용합니다. DTLS 클라이언트는 첫 번째 메시지\(ClientHello\)를 보내기 때문에 PREPARING 상태에서 시작합니다. DTLS 서버는 WAITING 상태에서 시작되지만 버퍼가 비어 있고 재전송 타이머가 없습니다.

```text
                      +-----------+
                      | PREPARING |
                +---> |           | <--------------------+
                |     |           |                      |
                |     +-----------+                      |
                |           |                            |
                |           | Buffer next flight         |
                |           |                            |
                |          \|/                           |
                |     +-----------+                      |
                |     |           |                      |
                |     |  SENDING  |<------------------+  |
                |     |           |                   |  | Send
                |     +-----------+                   |  | HelloRequest
        Receive |           |                         |  |
           next |           | Send flight             |  | or
         flight |  +--------+                         |  |
                |  |        | Set retransmit timer    |  | Receive
                |  |       \|/                        |  | HelloRequest
                |  |  +-----------+                   |  | Send
                |  |  |           |                   |  | ClientHello
                +--)--|  WAITING  |-------------------+  |
                |  |  |           |   Timer expires   |  |
                |  |  +-----------+                   |  |
                |  |         |                        |  |
                |  |         |                        |  |
                |  |         +------------------------+  |
                |  |                Read retransmit      |
        Receive |  |                                     |
           last |  |                                     |
         flight |  |                                     |
                |  |                                     |
               \|/\|/                                    |
                                                         |
            +-----------+                                |
            |           |                                |
            | FINISHED  | -------------------------------+
            |           |
            +-----------+
                 |  /|\
                 |   |
                 |   |
                 +---+

              Read retransmit
           Retransmit last flight

          Figure 3. DTLS Timeout and Retransmission State Machine
```

상태 머신에는 세 가지 기본 상태가 있습니다.

PREPARING 상태에서 구현은 다음 메시지 비행을 준비하는 데 필요한 모든 계산을 수행합니다. 그런 다음 전송을 위해 버퍼링하고\(먼저 버퍼를 비움\) SENDING 상태로 들어갑니다.

SENDING 상태에서 구현은 버퍼링된 메시지 비행을 전송합니다. 메시지가 전송되면 이것이 핸드셰이크의 마지막 비행인 경우 구현은 FINISHED 상태로 들어갑니다. 또는 구현에서 더 많은 메시지를 받을 것으로 예상되면 재전송 타이머를 설정한 다음 WAITING 상태로 들어갑니다.

WAITING 상태를 종료하는 방법에는 세 가지가 있습니다.

1. 재전송 타이머가 만료됩니다. 구현이 SENDING 상태로 전환되어 항공편을 재전송하고 재전송 타이머를 재설정한 다음 WAITING 상태로 돌아갑니다.

1. 구현은 피어로부터 재전송된 항공편을 읽습니다. 구현은 SENDING 상태로 전환되어 항공편을 재전송하고 재전송 타이머를 재설정한 다음 WAITING 상태로 돌아갑니다. 여기서의 이론적 근거는 중복 메시지 수신이 피어의 타이머 만료로 인한 결과일 가능성이 높으며 따라서 이전 비행의 일부가 손실되었음을 암시한다는 것입니다.

1. 구현은 다음 메시지 비행을 수신합니다. 이것이 메시지의 마지막 비행인 경우 구현은 FINISHED로 전환됩니다. 구현에서 새 항공편을 보내야 하는 경우 PREPARING 상태로 전환됩니다. 부분 읽기\(부분 메시지이든 비행 중인 메시지 중 일부만이든\)는 상태 전환이나 타이머 재설정을 유발하지 않습니다.

DTLS 클라이언트는 첫 번째 메시지\(ClientHello\)를 보내기 때문에 PREPARING 상태에서 시작합니다. DTLS 서버는 WAITING 상태에서 시작되지만 버퍼가 비어 있고 재전송 타이머가 없습니다.

서버가 rehandshake를 원하면 FINISHED 상태에서 PREPARING 상태로 전환하여 HelloRequest를 전송합니다. 클라이언트가 HelloRequest를 받으면 FINISHED에서 PREPARING으로 전환하여 ClientHello를 전송합니다.

또한 \[TCP\]에 정의된 기본 MSL의 최소 두 배에 대해 FINISHED 상태에 있을 때 마지막 비행을 전송하는 노드\(일반 핸드셰이크의 서버 또는 재개된 핸드셰이크의 클라이언트\)는 다음의 재전송에 응답해야 합니다. 동료의 마지막 비행

마지막 항공편을 재전송합니다. 이는 마지막 비행이 손실되는 경우 교착 상태를 방지합니다. 이 요구 사항은 DTLS 1.0에도 적용되며 \[DTLS1\]에서는 명시적이지 않지만 상태 기계가 올바르게 작동하려면 항상 필요했습니다. 이것이 왜 필요한지 알아보려면 서버의 Finished 메시지가 손실된 경우 일반적인 핸드셰이크에서 어떤 일이 발생하는지 생각해 보세요. 서버는 핸드셰이크가 완료되었다고 믿지만 실제로는 그렇지 않습니다. 클라이언트가 완료 메시지를 기다리는 동안 클라이언트의 재전송 타이머가 실행되고 클라이언트의 완료 메시지가 재전송됩니다. 그러면 서버가 자체 Finished 메시지로 응답하여 핸드셰이크를 완료하게 됩니다. 재개된 핸드셰이크에 대해 서버 측에도 동일한 논리가 적용됩니다.

패킷 손실로 인해 다른 쪽이 첫 번째 쪽의 완료 메시지를 받지 못하더라도 한 쪽에서는 애플리케이션 데이터를 보낼 수 있습니다. 구현은 해당 에포크에 대한 완료 메시지를 수신할 때까지 새로운 에포크에 대한 모든 애플리케이션 데이터 패킷을 삭제하거나 버퍼링해야 합니다. 구현은 재정렬 또는 패킷 손실의 증거로 해당 완료 메시지를 수신하기 전에 새로운 에포크의 애플리케이션 데이터 수신을 처리하고 최종 비행을 즉시 재전송하여 재전송 타이머를 단축할 수 있습니다.

---
##### **4.2.4.1. Timer Values**

타이머 값은 구현에 따라 선택되지만 타이머를 잘못 처리하면 심각한 정체 문제가 발생할 수 있습니다. 예를 들어, DTLS의 많은 인스턴스가 일찍 시간 초과되어 혼잡한 링크에서 너무 빨리 재전송하는 경우입니다. 구현에서는 1초\(RFC 6298 \[RFC6298\]에 정의된 최소값\)의 초기 타이머 값을 사용해야 하며 각 재전송 시 값을 RFC 6298 최대값인 60초보다 두 배로 늘려야 합니다. 시간에 민감한 애플리케이션의 대기 시간을 개선하려면 RFC 6298 기본값인 3초 대신 1초 타이머를 권장합니다. DTLS는 데이터 흐름이 아닌 핸드셰이크에만 재전송을 사용하므로 혼잡에 대한 영향은 최소화되어야 합니다.

구현은 손실 없이 전송이 발생할 때까지 현재 타이머 값을 유지해야 하며 이때 값은 초기 값으로 재설정될 수 있습니다. 현재 타이머 값의 10배 이상인 오랜 기간 동안 유휴 상태가 지속되면 구현에서는 타이머를 초기 값으로 재설정할 수 있습니다. 이런 일이 발생할 수 있는 상황 중 하나는 상당한 데이터 전송 후 재핸드셰이크가 사용되는 경우입니다.

---
#### **4.2.5.  ChangeCipherSpec**

TLS와 마찬가지로 ChangeCipherSpec 메시지는 기술적으로 핸드셰이크 메시지가 아니지만 시간 초과 및 재전송을 위해 연결된 Finished 메시지와 동일한 플라이트의 일부로 처리되어야 합니다. 이는 메시지 손실 시 핸드셰이크 메시지와 관련하여 ChangeCipherSpec의 순서를 명확하게 설정할 수 없기 때문에 잠재적인 모호성을 만듭니다.

ChangeCipherSpec에 논리적으로 선행하는 예상되는 핸드셰이크 메시지 세트는 나머지 핸드셰이크 상태에서 예측 가능하기 때문에 이는 현재 TLS 모드에서는 문제가 되지 않습니다. 그러나 향후 모드에서는 모호함이 발생하지 않도록 주의해야 합니다.

---
#### **4.2.6.  CertificateVerify and Finished Messages**

CertificateVerify 및 Finished 메시지는 TLS와 동일한 형식을 갖습니다. 해시 계산에는 DTLS 관련 필드\(message\_seq, 조각\_오프셋 및 조각\_길이\)를 포함한 전체 핸드셰이크 메시지가 포함됩니다. 그러나 핸드셰이크 메시지 조각화에 대한 민감도를 제거하려면 각 핸드셰이크 메시지가 단일 조각으로 전송된 것처럼 Finished MAC을 계산해야 합니다. 쿠키 교환이 사용되는 경우 초기 ClientHello 및 HelloVerifyRequest는 CertificateVerify 또는 Finished MAC 계산에 포함되어서는 안 됩니다.

---
#### **4.2.7.  Alert Messages**

경고 메시지는 핸드셰이크 중에 발생하더라도 전혀 재전송되지 않습니다. 그러나 일반적으로 경고를 발행하는 DTLS 구현은 위반 레코드가 다시 수신되면\(예: 재전송된 핸드셰이크 메시지로\) 새로운 경고 메시지를 생성해야 합니다\(SHOULD\). 구현은 피어가 지속적으로 잘못된 메시지를 보내는 시기를 감지하고 그러한 잘못된 동작이 감지된 후 로컬 연결 상태를 종료해야 합니다\(SHOULD\).

---
#### **4.2.8.  Establishing New Associations with Existing Parameters**

DTLS 클라이언트-서버 쌍이 동일한 호스트/포트 4중주에서 반복되는 연결이 발생하는 방식으로 구성된 경우 클라이언트가 자동으로 하나의 연결을 포기한 다음 동일한 매개변수를 사용하여 다른 연결을 시작할 수 있습니다\(예: 재부팅\). 이는 epoch=0인 새 핸드셰이크로 서버에 나타납니다. 서버가 주어진 호스트/포트 4중주에 기존 연결이 있다고 믿고 epoch=0 ClientHello를 수신하는 경우, 새로운 핸드셰이크를 진행해야 하지만 클라이언트가 완료하거나 완료하여 연결 가능성을 입증할 때까지 기존 연결을 파괴해서는 안 됩니다. 쿠키 교환 또는 완전한 악수 완료

검증 가능한 Finished 메시지 전달을 포함합니다. 올바른 Finished 메시지가 수신된 후 서버는 겹치는 에포크가 있는 두 개의 유효한 연결 간의 혼동을 피하기 위해 이전 연결을 포기해야 합니다. 연결 가능성 요구 사항은 경로를 벗어난/맹인 공격자가 위조된 ClientHello를 보내는 것만으로도 연결을 파괴하는 것을 방지합니다.

---
### **4.3.  Summary of New Syntax**

이 섹션에는 TLS 1.2와 DTLS 1.2 사이에 변경된 데이터 구조에 대한 사양이 포함되어 있습니다. 이 구문의 정의는 \[TLS12\]를 참조하세요.

---
#### **4.3.1.  Record Layer**

```text
   struct {
        ContentType type;
        ProtocolVersion version;
        uint16 epoch;                                     // New field
        uint48 sequence_number;                           // New field
        uint16 length;
        opaque fragment[DTLSPlaintext.length];
      } DTLSPlaintext;

      struct {
        ContentType type;
        ProtocolVersion version;
        uint16 epoch;                                     // New field
        uint48 sequence_number;                           // New field
        uint16 length;
        opaque fragment[DTLSCompressed.length];
      } DTLSCompressed;

      struct {
        ContentType type;
        ProtocolVersion version;
        uint16 epoch;                                     // New field
        uint48 sequence_number;                           // New field
        uint16 length;
        select (CipherSpec.cipher_type) {
          case block:  GenericBlockCipher;
          case aead:   GenericAEADCipher;                 // New field
        } fragment;
      } DTLSCiphertext;
```

---
#### **4.3.2.  Handshake Protocol**

```text
   enum {
     hello_request(0), client_hello(1), server_hello(2),
     hello_verify_request(3),                          // New field
     certificate(11), server_key_exchange (12),
     certificate_request(13), server_hello_done(14),
     certificate_verify(15), client_key_exchange(16),
     finished(20), (255) } HandshakeType;

   struct {
     HandshakeType msg_type;
     uint24 length;
     uint16 message_seq;                               // New field
     uint24 fragment_offset;                           // New field
     uint24 fragment_length;                           // New field
     select (HandshakeType) {
       case hello_request: HelloRequest;
       case client_hello:  ClientHello;
       case server_hello:  ServerHello;
       case hello_verify_request: HelloVerifyRequest;  // New field
       case certificate:Certificate;
       case server_key_exchange: ServerKeyExchange;
       case certificate_request: CertificateRequest;
       case server_hello_done:ServerHelloDone;
       case certificate_verify:  CertificateVerify;
       case client_key_exchange: ClientKeyExchange;
       case finished: Finished;
     } body; } Handshake;

   struct {
     ProtocolVersion client_version;
     Random random;
     SessionID session_id;
     opaque cookie<0..2^8-1>;                             // New field
     CipherSuite cipher_suites<2..2^16-1>;
     CompressionMethod compression_methods<1..2^8-1>; } ClientHello;

   struct {
     ProtocolVersion server_version;
     opaque cookie<0..2^8-1>; } HelloVerifyRequest;
```

---
## **5.  Security Considerations**

이 문서는 TLS 1.2의 변형을 설명합니다. 따라서 대부분의 보안 고려 사항은 부록 D, E 및 F에 설명된 TLS 1.2 \[TLS12\]의 고려 사항과 동일합니다.

DTLS가 제기한 주요 추가 보안 고려 사항은 서비스 거부에 대한 것입니다. DTLS에는 서비스 거부로부터 보호하도록 설계된 쿠키 교환이 포함되어 있습니다. 그러나 이 쿠키 교환을 사용하지 않는 구현은 여전히 ​​DoS에 취약합니다. 특히 쿠키 교환을 사용하지 않는 DTLS 서버는 자체적으로 DoS가 발생하지 않더라도 공격 증폭기로 사용될 수 있습니다. 따라서 DTLS 서버는 증폭이 해당 환경에 위협이 되지 않는다고 믿을 만한 타당한 이유가 없는 한 쿠키 교환을 사용해야 합니다. 클라이언트는 모든 핸드셰이크에서 쿠키 교환을 수행할 준비가 되어 있어야 합니다.

TLS 구현과 달리 DTLS 구현은 연결을 종료하여 유효하지 않은 레코드에 응답해서는 안 됩니다. 이에 대한 자세한 내용은 섹션 4.1.2.7을 참조하세요.

---
## **6.  Acknowledgments**

저자는 DTLS 설계에 대한 토론과 의견을 주신 Dan Boneh, Eu-Jin Goh, Russ Housley, Constantine Sapuntzakis 및 Hovav Shacham에게 감사의 말씀을 전하고 싶습니다. 의견을 주신 DTLS \[DTLS\] 원본 NDSS 논문의 익명 NDSS 검토자에게 감사드립니다. 또한 많은 사항을 명확히 하는 데 도움이 된 피드백을 주신 Steve Kent에게도 감사드립니다. PMTU에 관한 섹션은 DCCP 사양\[DCCP\]에서 발췌되었습니다. Pasi Eronen은 이 사양에 대한 자세한 리뷰를 제공했습니다. Peter Saint-Andre는 섹션 8의 변경 사항 목록을 제공했습니다. Mark Allman, Jari Arkko, Mohamed Badra, Michael D'Errico, Adrian Farrell, Joel Halpern, Ted Hardie, Charlia Kaufman, Pekka Savola로부터도 문서에 대한 유용한 의견을 받았습니다. , Allison Mankin, Nikos Mavrogiannopoulos, Alexey Melnikov, Robin Seggelmann, Michael Tuexen, Juho Vaha-Herttua 및 Florian Weimer.

---
## **7.  IANA Considerations**

이 문서는 TLS \[TLS12\]와 동일한 식별자 공간을 사용하므로 새로운 IANA 레지스트리가 필요하지 않습니다. TLS에 새 식별자가 할당되면 작성자는 해당 식별자가 DTLS에 적합한지 여부를 지정해야 합니다. IANA는 사양이 DTLS와 함께 사용될 수 있는지 여부를 나타내는 DTLS-OK 플래그를 추가하기 위해 모든 TLS 매개변수 레지스트리를 수정했습니다. 발행 시점에서 다음을 제외한 \[TLS12\] 등록은 모두 DTLS에 적합합니다. 전체 등록표는 \[IANA\]에서 확인할 수 있습니다.

TLS Cipher Suite Registry에서:

```text
      0x00,0x03 TLS_RSA_EXPORT_WITH_RC4_40_MD5        [RFC4346]
      0x00,0x04 TLS_RSA_WITH_RC4_128_MD5              [RFC5246]
      0x00,0x05 TLS_RSA_WITH_RC4_128_SHA              [RFC5246]
      0x00,0x17 TLS_DH_anon_EXPORT_WITH_RC4_40_MD5    [RFC4346]

      0x00,0x18 TLS_DH_anon_WITH_RC4_128_MD5          [RFC5246]
      0x00,0x20 TLS_KRB5_WITH_RC4_128_SHA             [RFC2712]
      0x00,0x24 TLS_KRB5_WITH_RC4_128_MD5             [RFC2712]
      0x00,0x28 TLS_KRB5_EXPORT_WITH_RC4_40_SHA       [RFC2712]
      0x00,0x2B TLS_KRB5_EXPORT_WITH_RC4_40_MD5       [RFC2712]
      0x00,0x8A TLS_PSK_WITH_RC4_128_SHA              [RFC4279]
      0x00,0x8E TLS_DHE_PSK_WITH_RC4_128_SHA          [RFC4279]
      0x00,0x92 TLS_RSA_PSK_WITH_RC4_128_SHA          [RFC4279]
      0xC0,0x02 TLS_ECDH_ECDSA_WITH_RC4_128_SHA       [RFC4492]
      0xC0,0x07 TLS_ECDHE_ECDSA_WITH_RC4_128_SHA      [RFC4492]
      0xC0,0x0C TLS_ECDH_RSA_WITH_RC4_128_SHA         [RFC4492]
      0xC0,0x11 TLS_ECDHE_RSA_WITH_RC4_128_SHA        [RFC4492]
      0xC0,0x16 TLS_ECDH_anon_WITH_RC4_128_SHA        [RFC4492]
      0xC0,0x33 TLS_ECDHE_PSK_WITH_RC4_128_SHA        [RFC5489]
```

TLS 내보내기 레이블 레지스트리에서:

```text
      client EAP encryption       [RFC5216]
      ttls   keying material      [RFC5281]
      ttls   challenge            [RFC5281]
```

이 문서는 \[TLS12\]에 정의된 TLS HandshakeType 레지스트리에서 값이 할당된 새로운 핸드셰이크 메시지 hello\_verify\_request를 정의합니다. IANA는 값 "3"을 할당했습니다.

---
## **8.  Changes since DTLS 1.0**

이 문서는 DTLS 1.0 \[DTLS1\] 이후 다음과 같은 변경 사항을 반영합니다.

- TLS 1.2 \[TLS12\]와 일치하도록 업데이트되었습니다.

- 섹션 4.1.2.3에 AEAD 암호 추가\(TLS 1.2의 변경 사항 추적\)

- 섹션 4.1의 시퀀스 번호 및 에포크에 대한 설명과 섹션 4.2.8의 상태 손실 처리를 위한 명확한 절차입니다.

- 섹션 4.1.1.1의 경로 MTU 문제에 대한 설명 및 자세한 규칙. 조각화 텍스트 전체에 대한 설명.

- 섹션 4.1.2.7의 유효하지 않은 기록 처리에 관한 설명.

- 섹션 4.2.1 끝에 잘못된 쿠키 처리를 설명하는 새로운 단락이 있습니다.

- 섹션 4.2.4 끝에 핸드셰이크 교착 상태를 방지하는 방법을 설명하는 몇 가지 새로운 텍스트가 있습니다.

- 섹션 4.2.6의 CertificateVerify 메시지에 대한 일부 새로운 텍스트입니다.

- 섹션 4.1의 에포크 래핑 금지.

- IANA 요구사항을 명확히 하고 각 매개변수에 대한 새로운 IANA 등록 플래그에 대한 명시적인 요구사항을 명시합니다.

- 반복되는 ClientHello 메시지를 처리하기 위한 레코드 시퀀스 번호 미러링 기술이 추가되었습니다.

- HelloVerifyRequest에 대한 고정 버전 번호를 권장합니다.

```text
   -  Numerous editorial changes.
```

---
## **9.  References**
---
### **9.1.  Normative References**

```text
   [REQ]       Bradner, S., "Key words for use in RFCs to Indicate
               Requirement Levels", BCP 14, RFC 2119, March 1997.

   [RFC1191]   Mogul, J. and S. Deering, "Path MTU discovery", RFC 1191,
               November 1990.

   [RFC4301]   Kent, S. and K. Seo, "Security Architecture for the
               Internet Protocol", RFC 4301, December 2005.

   [RFC4443]   Conta, A., Deering, S., and M. Gupta, Ed., "Internet
               Control Message Protocol (ICMPv6) for the Internet
               Protocol Version 6 (IPv6) Specification", RFC 4443, March
               2006.

   [RFC4821]   Mathis, M. and J. Heffner, "Packetization Layer Path MTU
               Discovery", RFC 4821, March 2007.

   [RFC6298]   Paxson, V., Allman, M., Chu, J., and M. Sargent,
               "Computing TCP's Retransmission Timer", RFC 6298, June
               2011.

   [RSAGCM]    Salowey, J., Choudhury, A., and D. McGrew, "AES Galois
               Counter Mode (GCM) Cipher Suites for TLS", RFC 5288,
               August 2008.

   [TCP]       Postel, J., "Transmission Control Protocol", STD 7, RFC
               793, September 1981.

   [TLS12]     Dierks, T. and E. Rescorla, "The Transport Layer Security
               (TLS) Protocol Version 1.2", RFC 5246, August 2008.
```

---
### **9.2.  Informative References**

```text
   [DCCP]      Kohler, E., Handley, M., and S. Floyd, "Datagram
               Congestion Control Protocol (DCCP)", RFC 4340, March
               2006.

   [DCCPDTLS]  Phelan, T., "Datagram Transport Layer Security (DTLS)
               over the Datagram Congestion Control Protocol (DCCP)",
               RFC 5238, May 2008.

   [DTLS]      Modadugu, N. and E. Rescorla, "The Design and
               Implementation of Datagram TLS", Proceedings of ISOC NDSS
               2004, February 2004.

   [DTLS1]     Rescorla, E. and N. Modadugu, "Datagram Transport Layer
               Security", RFC 4347, April 2006.

   [ECCGCM]    Rescorla, E., "TLS Elliptic Curve Cipher Suites with
               SHA-256/384 and AES Galois Counter Mode (GCM)", RFC 5289,
               August 2008.

   [ESP]       Kent, S., "IP Encapsulating Security Payload (ESP)", RFC
               4303, December 2005.

   [IANA]      IANA, "Transport Layer Security (TLS) Parameters",
               http://www.iana.org/assignments/tls-parameters.

   [IKEv2]     Kaufman, C., Hoffman, P., Nir, Y., and P. Eronen,
               "Internet Key Exchange Protocol Version 2 (IKEv2)", RFC
               5996, September 2010.

   [IMAP]      Crispin, M., "INTERNET MESSAGE ACCESS PROTOCOL - VERSION
               4rev1", RFC 3501, March 2003.

   [PHOTURIS]  Karn, P. and W. Simpson, "Photuris: Session-Key
               Management Protocol", RFC 2522, March 1999.

   [POP]       Myers, J. and M. Rose, "Post Office Protocol - Version
               3", STD 53, RFC 1939, May 1996.

   [SIP]       Rosenberg, J., Schulzrinne, H., Camarillo, G., Johnston,
               A., Peterson, J., Sparks, R., Handley, M., and E.
               Schooler, "SIP: Session Initiation Protocol", RFC 3261,
               June 2002.

   [TLS]       Dierks, T. and C. Allen, "The TLS Protocol Version 1.0",
               RFC 2246, January 1999.

   [TLS11]     Dierks, T. and E. Rescorla, "The Transport Layer Security
               (TLS) Protocol Version 1.1", RFC 4346, April 2006.

   [WHYIPSEC]  Bellovin, S., "Guidelines for Specifying the Use of IPsec
               Version 2", BCP 146, RFC 5406, February 2009.
```

---
# **Authors' Addresses**

```text
   Eric Rescorla
   RTFM, Inc.
   2064 Edgewood Drive
   Palo Alto, CA 94303

   EMail: ekr@rtfm.com

   Nagendra Modadugu
   Google, Inc.

   EMail: nagendra@cs.stanford.edu
```
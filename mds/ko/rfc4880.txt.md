

```text
Network Working Group                                          J. Callas
Request for Comments: 4880                               PGP Corporation
Obsoletes: 1991, 2440                                     L. Donnerhacke
Category: Standards Track                                       IKS GmbH
                                                               H. Finney
                                                         PGP Corporation
                                                                 D. Shaw
                                                               R. Thayer
                                                           November 2007

                         OpenPGP Message Format
```

---
# **Status of This Memo**

이 문서는 인터넷 커뮤니티를 위한 인터넷 표준 추적 프로토콜을 지정하고 개선을 위한 토론 및 제안을 요청합니다. 이 프로토콜의 표준화 상태 및 상태에 대해서는 "Internet Official Protocol Standards"\(STD 1\) 최신판을 참조하십시오. 이 메모의 배포는 무제한입니다.

---
# **Abstract**

이 문서는 OpenPGP 형식을 기반으로 상호 운용 가능한 응용 프로그램을 개발하는 데 필요한 모든 필수 정보를 게시하기 위해 유지 관리됩니다. 이 책은 신청서 작성을 위한 단계별 요리책이 아닙니다. 모든 네트워크에서 적합한 패킷을 읽고, 확인하고, 생성하고, 쓰는 데 필요한 형식과 방법만 설명합니다. 저장 및 구현 문제는 다루지 않습니다. 그러나 보안 결함을 방지하는 데 필요한 구현 문제에 대해서는 논의합니다.

OpenPGP 소프트웨어는 강력한 공개 키와 대칭 암호화의 조합을 사용하여 전자 통신 및 데이터 저장을 위한 보안 서비스를 제공합니다. 이러한 서비스에는 기밀성, 키 관리, 인증 및 디지털 서명이 포함됩니다. 이 문서는 OpenPGP에서 사용되는 메시지 형식을 지정합니다.

---
# **Table of Contents**

```text
   1. Introduction ....................................................5
      1.1. Terms ......................................................5
   2. General functions ...............................................6
      2.1. Confidentiality via Encryption .............................6
      2.2. Authentication via Digital Signature .......................7
      2.3. Compression ................................................7
      2.4. Conversion to Radix-64 .....................................8
      2.5. Signature-Only Applications ................................8
   3. Data Element Formats ............................................8
      3.1. Scalar Numbers .............................................8
      3.2. Multiprecision Integers ....................................9
      3.3. Key IDs ....................................................9
      3.4. Text .......................................................9
      3.5. Time Fields ...............................................10
      3.6. Keyrings ..................................................10
      3.7. String-to-Key (S2K) Specifiers ............................10
           3.7.1. String-to-Key (S2K) Specifier Types ................10
                  3.7.1.1. Simple S2K ................................10
                  3.7.1.2. Salted S2K ................................11
                  3.7.1.3. Iterated and Salted S2K ...................11
           3.7.2. String-to-Key Usage ................................12
                  3.7.2.1. Secret-Key Encryption .....................12
                  3.7.2.2. Symmetric-Key Message Encryption ..........13
   4. Packet Syntax ..................................................13
      4.1. Overview ..................................................13
      4.2. Packet Headers ............................................13
           4.2.1. Old Format Packet Lengths ..........................14
           4.2.2. New Format Packet Lengths ..........................15
                  4.2.2.1. One-Octet Lengths .........................15
                  4.2.2.2. Two-Octet Lengths .........................15
                  4.2.2.3. Five-Octet Lengths ........................15
                  4.2.2.4. Partial Body Lengths ......................16
           4.2.3. Packet Length Examples .............................16
      4.3. Packet Tags ...............................................17
   5. Packet Types ...................................................17
      5.1. Public-Key Encrypted Session Key Packets (Tag 1) ..........17
      5.2. Signature Packet (Tag 2) ..................................19
           5.2.1. Signature Types ....................................19
           5.2.2. Version 3 Signature Packet Format ..................21
           5.2.3. Version 4 Signature Packet Format ..................24
                  5.2.3.1. Signature Subpacket Specification .........25
                  5.2.3.2. Signature Subpacket Types .................27
                  5.2.3.3. Notes on Self-Signatures ..................27
                  5.2.3.4. Signature Creation Time ...................28
                  5.2.3.5. Issuer ....................................28
                  5.2.3.6. Key Expiration Time .......................28
                  5.2.3.7. Preferred Symmetric Algorithms ............28
                  5.2.3.8. Preferred Hash Algorithms .................29
                  5.2.3.9. Preferred Compression Algorithms ..........29
                  5.2.3.10. Signature Expiration Time ................29
                  5.2.3.11. Exportable Certification .................29
                  5.2.3.12. Revocable ................................30
                  5.2.3.13. Trust Signature ..........................30
                  5.2.3.14. Regular Expression .......................31
                  5.2.3.15. Revocation Key ...........................31
                  5.2.3.16. Notation Data ............................31
                  5.2.3.17. Key Server Preferences ...................32
                  5.2.3.18. Preferred Key Server .....................33
                  5.2.3.19. Primary User ID ..........................33
                  5.2.3.20. Policy URI ...............................33
                  5.2.3.21. Key Flags ................................33
                  5.2.3.22. Signer's User ID .........................34
                  5.2.3.23. Reason for Revocation ....................35
                  5.2.3.24. Features .................................36
                  5.2.3.25. Signature Target .........................36
                  5.2.3.26. Embedded Signature .......................37
           5.2.4. Computing Signatures ...............................37
                  5.2.4.1. Subpacket Hints ...........................38
      5.3. Symmetric-Key Encrypted Session Key Packets (Tag 3) .......38
      5.4. One-Pass Signature Packets (Tag 4) ........................39
      5.5. Key Material Packet .......................................40
           5.5.1. Key Packet Variants ................................40
                  5.5.1.1. Public-Key Packet (Tag 6) .................40
                  5.5.1.2. Public-Subkey Packet (Tag 14) .............40
                  5.5.1.3. Secret-Key Packet (Tag 5) .................41
                  5.5.1.4. Secret-Subkey Packet (Tag 7) ..............41
           5.5.2. Public-Key Packet Formats ..........................41
           5.5.3. Secret-Key Packet Formats ..........................43
      5.6. Compressed Data Packet (Tag 8) ............................45
      5.7. Symmetrically Encrypted Data Packet (Tag 9) ...............45
      5.8. Marker Packet (Obsolete Literal Packet) (Tag 10) ..........46
      5.9. Literal Data Packet (Tag 11) ..............................46
      5.10. Trust Packet (Tag 12) ....................................47
      5.11. User ID Packet (Tag 13) ..................................48
      5.12. User Attribute Packet (Tag 17) ...........................48
           5.12.1. The Image Attribute Subpacket .....................48
      5.13. Sym. Encrypted Integrity Protected Data Packet (Tag 18) ..49
      5.14. Modification Detection Code Packet (Tag 19) ..............52
   6. Radix-64 Conversions ...........................................53
      6.1. An Implementation of the CRC-24 in "C" ....................54
      6.2. Forming ASCII Armor .......................................54
      6.3. Encoding Binary in Radix-64 ...............................57
      6.4. Decoding Radix-64 .........................................58
      6.5. Examples of Radix-64 ......................................59
      6.6. Example of an ASCII Armored Message .......................59
   7. Cleartext Signature Framework ..................................59
      7.1. Dash-Escaped Text .........................................60
   8. Regular Expressions ............................................61
   9. Constants ......................................................61
      9.1. Public-Key Algorithms .....................................62
      9.2. Symmetric-Key Algorithms ..................................62
      9.3. Compression Algorithms ....................................63
      9.4. Hash Algorithms ...........................................63
   10. IANA Considerations ...........................................63
      10.1. New String-to-Key Specifier Types ........................64
      10.2. New Packets ..............................................64
           10.2.1. User Attribute Types ..............................64
                  10.2.1.1. Image Format Subpacket Types .............64
           10.2.2. New Signature Subpackets ..........................64
                  10.2.2.1. Signature Notation Data Subpackets .......65
                  10.2.2.2. Key Server Preference Extensions .........65
                  10.2.2.3. Key Flags Extensions .....................65
                  10.2.2.4. Reason For Revocation Extensions .........65
                  10.2.2.5. Implementation Features ..................66
           10.2.3. New Packet Versions ...............................66
      10.3. New Algorithms ...........................................66
           10.3.1. Public-Key Algorithms .............................66
           10.3.2. Symmetric-Key Algorithms ..........................67
           10.3.3. Hash Algorithms ...................................67
           10.3.4. Compression Algorithms ............................67
   11. Packet Composition ............................................67
      11.1. Transferable Public Keys .................................67
      11.2. Transferable Secret Keys .................................69
      11.3. OpenPGP Messages .........................................69
      11.4. Detached Signatures ......................................70
   12. Enhanced Key Formats ..........................................70
      12.1. Key Structures ...........................................70
      12.2. Key IDs and Fingerprints .................................71
   13. Notes on Algorithms ...........................................72
      13.1. PKCS#1 Encoding in OpenPGP ...............................72
           13.1.1. EME-PKCS1-v1_5-ENCODE .............................73
           13.1.2. EME-PKCS1-v1_5-DECODE .............................73
           13.1.3. EMSA-PKCS1-v1_5 ...................................74
      13.2. Symmetric Algorithm Preferences ..........................75
      13.3. Other Algorithm Preferences ..............................76
           13.3.1. Compression Preferences ...........................76
           13.3.2. Hash Algorithm Preferences ........................76
      13.4. Plaintext ................................................77
      13.5. RSA ......................................................77
      13.6. DSA ......................................................77
      13.7. Elgamal ..................................................78
      13.8. Reserved Algorithm Numbers ...............................78
      13.9. OpenPGP CFB Mode .........................................78
      13.10. Private or Experimental Parameters ......................79
      13.11. Extension of the MDC System .............................80
      13.12. Meta-Considerations for Expansion .......................80
   14. Security Considerations .......................................81
   15. Implementation Nits ...........................................84
   16. References ....................................................86
      16.1. Normative References .....................................86
      16.2. Informative References ...................................88
```

---
## **1.  Introduction**

이 문서는 암호화, 암호 해독, 서명 및 키 관리 기능을 제공하기 위해 OpenPGP에서 사용하는 메시지 교환 패킷 형식에 대한 정보를 제공합니다. 이는 RFC 1991, "PGP 메시지 교환 형식" \[RFC1991\] \[RFC2440\]을 대체하는 RFC 2440 "OpenPGP 메시지 형식"의 개정판입니다.

---
### **1.1.  Terms**

\* OpenPGP - PGP 5.x를 기반으로 하는 보안 소프트웨어를 가리키는 용어로, RFC 2440과 본 문서에서 공식화되어 있다.

\* PGP - 꽤 좋은 개인 정보 보호. PGP는 OpenPGP의 기반이 되는 Philip R. Zimmermann이 개발한 소프트웨어 시스템 제품군입니다.

\* PGP 2.6.x - 이 PGP 버전에는 다양한 변형이 있으므로 PGP 2.6.x라는 용어가 사용됩니다. 암호화 변환에는 RSA, MD5 및 IDEA만 사용되었습니다. 이 버전의 PGP를 설명하는 정보 제공용 RFC인 RFC 1991이 작성되었습니다.

\* PGP 5.x - 이 PGP 버전은 이전에 커뮤니티에서 "PGP 3"으로 알려졌으며 이 문서의 이전 버전인 RFC 1991에서도 알려져 있습니다. 이 버전은 새로운 형식을 가지며 PGP 2.6.x 디자인의 여러 문제를 수정합니다. . 이 소프트웨어는 "PGP 3" 코드 베이스의 첫 번째 릴리스였기 때문에 여기서는 PGP 5.x라고 합니다.

\* GnuPG - GNU Privacy Guard, GPG라고도 합니다. GnuPG는 방해가 되는 모든 알고리즘을 피하는 OpenPGP 구현입니다. 결과적으로 GnuPG의 초기 버전에는 RSA 공개 키가 포함되지 않았습니다. GnuPG는 \(버전에 따라\) IDEA 또는 기타 방해가 되는 알고리즘을 지원할 수도 있고 지원하지 않을 수도 있습니다.

"PGP", "Pretty Good" 및 "Pretty Good Privacy"는 PGP Corporation의 상표이며 허가를 받아 사용됩니다. "OpenPGP"라는 용어는 이 문서와 관련 문서에 설명된 프로토콜을 나타냅니다.

이 문서에서 키워드 "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY" 및 "OPTIONAL"은 다음과 같습니다. \[RFC2119\]에 설명된 대로 해석됩니다.\(MUST NOT\)

이 문서에 나타나는 키워드 "PRIVATE USE", "HIERARCHICAL ALLOCATION", "FIRST COME FIRST SERVED", "EXPERT REVIEW", "SPECIFICATION REQUIRED", "IESG APPROVAL", "IETF CONSENSUS" 및 "STANDARDS ACTION" 네임스페이스 할당을 설명하는 데 사용되는 경우는 \[RFC2434\]에 설명된 대로 해석됩니다.\(MUST\)

---
## **2.  General functions**

OpenPGP는 다음 핵심 기술을 사용하여 메시지 및 데이터 파일에 대한 데이터 무결성 서비스를 제공합니다.

```text
     - digital signatures

     - encryption

     - compression

     - Radix-64 conversion
```

또한 OpenPGP는 키 관리 및 인증서 서비스를 제공하지만 이들 중 대부분은 이 문서의 범위를 벗어납니다.

---
### **2.1.  Confidentiality via Encryption**

OpenPGP는 대칭 키 암호화와 공개 키 암호화를 결합하여 기밀성을 제공합니다. 기밀로 설정되면 먼저 대칭 암호화 알고리즘을 사용하여 객체를 암호화합니다. 각 대칭 키는 단일 개체에 대해 한 번만 사용됩니다. 새로운 "세션 키"는 각 개체\(때때로 세션이라고도 함\)에 대해 임의의 숫자로 생성됩니다. 한 번만 사용되므로 세션 키가 메시지에 바인딩되어 함께 전송됩니다. 키를 보호하기 위해 수신자의 공개 키로 암호화됩니다. 순서는 다음과 같습니다.

1. 발신자가 메시지를 작성합니다.

2. 보내는 OpenPGP는 이 메시지에 대해서만 세션 키로 사용할 임의의 숫자를 생성합니다.

3. 세션 키는 각 수신자의 공개 키를 사용하여 암호화됩니다. 이러한 "암호화된 세션 키"는 메시지를 시작합니다.

4. 보내는 OpenPGP는 메시지의 나머지 부분을 구성하는 세션 키를 사용하여 메시지를 암호화합니다. 메시지도 일반적으로 압축됩니다.

5. 수신 OpenPGP는 다음을 사용하여 세션 키를 해독합니다.

- 수신자의 개인 키.

6. 수신 OpenPGP는 세션 키를 사용하여 메시지를 해독합니다. 메시지가 압축된 경우 압축이 풀립니다.

대칭 키 암호화를 사용하면 암호\(또는 다른 공유 비밀\)에서 파생된 대칭 키를 사용하여 객체를 암호화할 수 있습니다. 또는 세션 키 자체를 암호화하는 위에서 설명한 공개 키 방법과 유사한 2단계 메커니즘을 사용하여 객체를 암호화할 수 있습니다. 공유 비밀에서 키가 지정된 대칭 알고리즘입니다.

디지털 서명과 기밀 유지 서비스가 모두 동일한 메시지에 적용될 수 있습니다. 먼저 메시지에 대한 서명이 생성되어 메시지에 첨부됩니다. 그런 다음 메시지와 서명이 대칭 세션 키를 사용하여 암호화됩니다. 마지막으로 세션 키는 공개 키 암호화를 사용하여 암호화되고 암호화된 블록 앞에 붙습니다.

---
### **2.2.  Authentication via Digital Signature**

디지털 서명은 해시 코드 또는 메시지 다이제스트 알고리즘과 공개 키 서명 알고리즘을 사용합니다. 순서는 다음과 같습니다.

1. 발신자가 메시지를 작성합니다.

2. 보내는 소프트웨어는 메시지의 해시 코드를 생성합니다.

3. 보내는 소프트웨어는 보낸 사람의 개인 키를 사용하여 해시 코드에서 서명을 생성합니다.

4. 바이너리 서명이 메시지에 첨부됩니다.

5. 수신 소프트웨어는 메시지 서명의 사본을 보관합니다.

6. 수신 소프트웨어는 수신된 메시지에 대한 새로운 해시 코드를 생성하고 메시지 서명을 사용하여 이를 확인합니다. 확인이 성공하면 메시지가 진짜로 승인됩니다.

---
### **2.3.  Compression**

OpenPGP 구현은 서명을 적용한 후 암호화하기 전에 메시지를 압축해야 합니다.\(SHOULD\)

구현이 압축을 구현하지 않는 경우 작성자는 전 세계 대부분의 OpenPGP 메시지가 압축된다는 점을 알고 있어야 합니다. 따라서 공간이 제한된 구현에서는 압축이 아닌 압축 해제를 구현하는 것이 현명할 수도 있습니다.

또한 압축에는 약간 변경된 압축 데이터가 심각한 오류 없이는 거의 압축 해제되지 않는다는 사실로 인해 일부 유형의 공격을 저지할 수 있다는 추가 부작용이 있습니다. 이는 엄격하지는 않지만 운영상 유용합니다. 이러한 공격은 다음 섹션에 설명된 대로 수정 감지 코드를 구현하고 사용하여 엄격하게 방지할 수 있습니다.

---
### **2.4.  Conversion to Radix-64**

암호화된 메시지, 서명 인증서 및 키에 대한 OpenPGP의 기본 기본 표현은 임의 옥텟의 스트림입니다. 일부 시스템에서는 인쇄 가능한 7비트 텍스트로 구성된 블록의 사용만 허용합니다. 원시 바이너리 데이터에 안전하지 않은 채널을 통해 OpenPGP의 기본 원시 바이너리 옥텟을 전송하려면 이러한 바이너리 옥텟의 인쇄 가능한 인코딩이 필요합니다. OpenPGP는 원시 8비트 이진 옥텟 스트림을 Radix-64 인코딩 또는 ASCII Armor라고 하는 인쇄 가능한 ASCII 문자 스트림으로 변환하는 서비스를 제공합니다.

```text
   Implementations SHOULD provide Radix-64 conversions.
```

---
### **2.5.  Signature-Only Applications**

OpenPGP는 암호화와 서명을 모두 사용하는 응용 프로그램용으로 설계되었지만 서명 전용 구현으로 해결되는 많은 문제가 있습니다. 이 사양에는 암호화와 서명이 모두 필요하지만 암호화를 생략한다는 점에서만 부적합한 하위 집합 구현이 있는 것이 합리적입니다.

---
## **3.  Data Element Formats**

이 섹션에서는 OpenPGP에서 사용하는 데이터 요소에 대해 설명합니다.

---
### **3.1.  Scalar Numbers**

스칼라 숫자는 부호가 없으며 항상 빅엔디안 형식으로 저장됩니다. n\[k\]를 사용하여 해석되는 k번째 옥텟을 참조하면 2옥텟 스칼라의 값은 \(\(n\[0\] << 8\) + n\[1\]\)입니다. 4옥텟 스칼라의 값은 \(\(n\[0\] << 24\) + \(n\[1\] << 16\) + \(n\[2\] << 8\) + n\[3\]\)입니다.

---
### **3.2.  Multiprecision Integers**

다중 정밀도 정수\(MPI라고도 함\)는 암호화 계산에 사용되는 것과 같은 큰 정수를 보유하는 데 사용되는 부호 없는 정수입니다.

MPI는 비트 단위의 MPI 길이인 2옥텟 스칼라와 실제 정수를 포함하는 옥텟 문자열로 구성됩니다.

이 옥텟은 빅엔디안 숫자를 형성합니다. 빅엔디안 숫자 앞에 적절한 길이를 붙여서 MPI로 만들 수 있습니다.

```text
   Examples:

   (all numbers are in hexadecimal)
```

옥텟 문자열 \[00 01 01\]은 값 1로 MPI를 형성합니다. 문자열 \[00 09 01 FF\]는 값 511로 MPI를 형성합니다.

```text
   Additional rules:
```

MPI의 크기는 \(\(MPI.length + 7\) / 8\) + 2옥텟입니다.

MPI의 길이 필드는 0이 아닌 가장 중요한 비트부터 시작하는 길이를 설명합니다. 따라서 MPI \[00 02 01\]이 올바르게 형성되지 않았습니다. \[00 01 01\]이어야 합니다.

MPI의 사용되지 않은 비트는 0이어야 합니다.\(MUST\)

또한 MPI가 암호화되면 길이는 일반 텍스트 MPI를 나타냅니다. 암호문의 형식이 잘못되었을 수 있습니다.

---
### **3.3.  Key IDs**

키 ID는 키를 식별하는 8옥텟 스칼라입니다. 구현에서는 키 ID가 고유하다고 가정해서는 안 됩니다. 아래의 "향상된 키 형식" 섹션에서는 키 ID가 형성되는 방식을 설명합니다.\(SHOULD NOT\)

---
### **3.4.  Text**

별도로 지정하지 않는 한 텍스트의 문자 집합은 유니코드\[ISO10646\]의 UTF-8 \[RFC3629\] 인코딩입니다.

---
### **3.5.  Time Fields**

시간 필드는 1970년 1월 1일 자정\(UTC\) 이후 경과된 초 수를 포함하는 부호 없는 4옥텟 숫자입니다.

---
### **3.6.  Keyrings**

키링은 파일이나 데이터베이스에 있는 하나 이상의 키 모음입니다. 전통적으로 키링은 단순히 순차적인 키 목록이지만 적합한 데이터베이스일 수도 있습니다. 키링이나 기타 데이터베이스의 세부 사항을 논의하는 것은 이 표준의 범위를 벗어납니다.

---
### **3.7.  String-to-Key (S2K) Specifiers**

S2K\(String-to-key\) 지정자는 암호 문자열을 대칭 키 암호화/암호 해독 키로 변환하는 데 사용됩니다. 현재는 개인 키링에 있는 개인 키의 비밀 부분을 암호화하고 대칭적으로 암호화된 메시지에 대한 암호 문구를 암호화 키로 변환하는 두 가지 위치에서 사용됩니다.

---
#### **3.7.1.  String-to-Key (S2K) Specifier Types**

현재 지원되는 S2K 지정자에는 세 가지 유형이 있으며 일부 예약된 값은 다음과 같습니다.

```text
       ID          S2K Type
       --          --------
       0           Simple S2K
       1           Salted S2K
       2           Reserved value
       3           Iterated and Salted S2K
       100 to 110  Private/Experimental S2K
```

이에 대해서는 섹션 3.7.1.1 - 3.7.1.3에 설명되어 있습니다.

---
##### **3.7.1.1.  Simple S2K**

이는 문자열을 직접 해시하여 키 데이터를 생성합니다. 이 해싱이 수행되는 방법은 아래를 참조하세요.

```text
       Octet 0:        0x00
       Octet 1:        hash algorithm
```

Simple S2K는 암호를 해시하여 세션 키를 생성합니다. 이 작업이 수행되는 방식은 세션 키의 크기\(사용된 암호에 따라 다름\)와 해시의 크기에 따라 다릅니다.

알고리즘의 출력. 해시 크기가 세션 키 크기보다 큰 경우 해시의 상위\(가장 왼쪽\) 옥텟이 키로 사용됩니다.

해시 크기가 키 크기보다 작으면 필요한 키 데이터를 생성하기에 충분한 해시 컨텍스트의 여러 인스턴스가 생성됩니다. 이러한 인스턴스는 0, 1, 2, ... 옥텟의 0으로 사전 로드됩니다. 즉, 첫 번째 인스턴스에는 사전 로드가 없고, 두 번째 인스턴스에는 1옥텟의 0이 사전 로드되고, 세 번째 인스턴스에는 2개의 0 옥텟이 사전 로드됩니다. 기타 등등\).

데이터가 해시되면 각 해시 컨텍스트에 독립적으로 제공됩니다. 컨텍스트가 다르게 초기화되었으므로 각각 다른 해시 출력을 생성합니다. 암호가 해시되면 여러 해시의 출력 데이터가 가장 왼쪽부터 연결되어 키 데이터를 생성하고 오른쪽의 초과 옥텟은 삭제됩니다.

---
##### **3.7.1.2.  Salted S2K**

여기에는 사전 공격을 방지하는 데 도움이 되도록 암호 문자열과 함께 해시되는 S2K 지정자의 "salt" 값\(일부 임의 데이터\)이 포함됩니다.

```text
       Octet 0:        0x01
       Octet 1:        hash algorithm
       Octets 2-9:     8-octet salt value
```

Salted S2K는 해시 함수에 대한 입력이 S2K 지정자의 솔트 8옥텟과 암호문으로 구성된다는 점을 제외하면 Simple S2K와 똑같습니다.

---
##### **3.7.1.3.  Iterated and Salted S2K**

여기에는 솔트 및 옥텟 수가 모두 포함됩니다. 솔트가 암호문과 결합되고 결과 값이 반복적으로 해시됩니다. 이로 인해 공격자가 사전 공격을 시도하기 위해 수행해야 하는 작업량이 더욱 늘어납니다.

```text
       Octet  0:        0x03
       Octet  1:        hash algorithm
       Octets 2-9:      8-octet salt value
       Octet  10:       count, a one-octet, coded value
```

개수는 다음 공식을 사용하여 1옥텟 숫자로 코딩됩니다.

```text
       #define EXPBIAS 6
           count = ((Int32)16 + (c & 15)) << ((c >> 4) + EXPBIAS);
```

위 공식은 C에 ​​있습니다. 여기서 "Int32"는 32비트 정수의 유형이고 변수 "c"는 코드화된 개수인 Octet 10입니다.

Iterated-Salted S2K는 암호 및 솔트 데이터를 여러 번 해시합니다. 해시할 총 옥텟 수는 S2K 지정자의 인코딩된 개수에 지정됩니다. 결과 개수 값은 반복 개수가 아니라 해시될 옥텟 수에 대한 옥텟 개수입니다.

처음에는 필요한 핵심 데이터의 옥텟 수에 따라 다른 S2K 알고리즘과 마찬가지로 하나 이상의 해시 컨텍스트가 설정됩니다. 그런 다음 옥텟 수에 지정된 옥텟 수가 해시될 때까지 솔트와 암호 데이터가 반복적으로 해시됩니다. 한 가지 예외는 옥텟 수가 솔트와 암호 문구의 크기보다 작은 경우 전체 솔트와 암호 문구가 옥텟 수보다 크더라도 해시된다는 점입니다. 해싱이 완료되면 다른 S2K 알고리즘과 마찬가지로 데이터가 해시 컨텍스트에서 언로드됩니다.

---
#### **3.7.2.  String-to-Key Usage**

단순 S2K 지정자는 사전 공격에 더 취약하므로 구현에서는 솔트 처리된 또는 반복 및 솔트 처리된 S2K 지정자를 사용해야 합니다.\(SHOULD\)

---
##### **3.7.2.1.  Secret-Key Encryption**

S2K 지정자를 비밀 키링에 저장하여 암호를 비밀 데이터를 잠금 해제하는 키로 변환하는 방법을 지정할 수 있습니다. 이전 버전의 PGP는 비밀 데이터 앞에 암호 알고리즘 옥텟을 저장했거나 비밀 데이터가 암호화되지 않았음을 나타내는 0을 저장했습니다. MD5 해시 함수는 항상 암호를 지정된 암호화 알고리즘의 키로 변환하는 데 사용되었습니다.

호환성을 위해 S2K 지정자를 사용하면 특수 값 254 또는 255가 이전 데이터 구조에서 해시 알고리즘 옥텟이 있었던 위치에 저장됩니다. 그런 다음 바로 뒤에 1옥텟 알고리즘 식별자가 오고, 그 다음에는 위에 인코딩된 S2K 지정자가 옵니다.

따라서 비밀 데이터 앞에는 다음 가능성 중 하나가 있습니다.

0: 비밀 데이터가 암호화되지 않았습니다\(암호 문구 없음\).

- 255 또는 254: 뒤에 알고리즘 옥텟 및 S2K 지정자 Cipher alg: MD5 해시를 사용하는 단순 S2K 알고리즘 사용

이 마지막 가능성인 MD5 및 IDEA를 암시적으로 사용하는 암호화 알고리즘 번호는 이전 버전과의 호환성을 위해 제공됩니다. 이해할 수 있지만 생성해서는 안 되며 더 이상 사용되지 않습니다.\(SHOULD NOT\)

그 뒤에는 비밀 값\(암호화된 경우\)의 해독을 위한 암호의 블록 크기와 동일한 길이의 초기 벡터와 비밀 키 값 자체가 옵니다.

---
##### **3.7.2.2.  Symmetric-Key Message Encryption**

OpenPGP는 메시지 앞에 대칭 키 암호화 세션 키\(ESK\) 패킷을 생성할 수 있습니다. 이는 암호 변환에 S2K 지정자를 사용하거나 대칭 키 ESK와 공개 키 ESK가 혼합된 메시지를 생성하는 데 사용됩니다. 이를 통해 암호나 공개 키 쌍을 사용하여 메시지를 해독할 수 있습니다.

PGP 2.X는 대칭 알고리즘으로 메시지를 암호화할 때 항상 단순 문자열-키 변환과 함께 IDEA를 사용했습니다. 이는 더 이상 사용되지 않지만 이전 버전과의 호환성을 위해 사용될 수 있습니다.\(MAY\)

---
## **4.  Packet Syntax**

이 섹션에서는 OpenPGP에서 사용하는 패킷에 대해 설명합니다.

---
### **4.1.  Overview**

OpenPGP 메시지는 전통적으로 패킷이라고 불리는 여러 레코드로 구성됩니다. 패킷은 의미를 지정하는 태그가 있는 데이터 덩어리입니다. OpenPGP 메시지, 키링, 인증서 등은 다수의 패킷으로 구성됩니다. 이러한 패킷 중 일부에는 다른 OpenPGP 패킷이 포함될 수 있습니다\(예: 압축된 데이터 패킷이 압축 해제되면 OpenPGP 패킷이 포함됨\).

각 패킷은 패킷 헤더와 패킷 본문으로 구성됩니다. 패킷 헤더는 가변 길이입니다.

---
### **4.2.  Packet Headers**

패킷 헤더의 첫 번째 옥텟을 "패킷 태그"라고 합니다. 헤더의 형식을 결정하고 패킷 내용을 나타냅니다. 패킷 헤더의 나머지 부분은 패킷의 길이입니다.

가장 중요한 비트는 비트 7이라고 하는 가장 왼쪽 비트입니다. 이 비트의 마스크는 16진수로 0x80입니다.

```text
              +---------------+
         PTag |7 6 5 4 3 2 1 0|
              +---------------+
         Bit 7 -- Always one
         Bit 6 -- New packet format if set
```

PGP 2.6.x는 이전 형식의 패킷만 사용합니다. 따라서 해당 버전의 PGP와 상호 운용되는 소프트웨어는 이전 형식의 패킷만 사용해야 합니다. 상호 운용성이 문제가 되지 않으면 새로운 패킷 형식을 권장합니다. 이전 형식 패킷에는 4비트의 패킷 태그가 있고 새 형식 패킷에는 6비트가 있습니다. 일부 기능은 사용할 수 없지만 여전히 이전 버전과 호환됩니다.\(SHOULD\)

또한 16보다 크거나 같은 태그가 있는 패킷은 반드시 새로운 형식의 패킷을 사용해야 합니다. 이전 형식 패킷은 15개 이하의 태그만 표현할 수 있습니다.\(MUST\)

```text
   Old format packets contain:

         Bits 5-2 -- packet tag
         Bits 1-0 -- length-type

   New format packets contain:

         Bits 5-0 -- packet tag
```

---
#### **4.2.1.  Old Format Packet Lengths**

이전 형식 패킷에서 길이 유형의 의미는 다음과 같습니다.

0 - 패킷의 길이는 1옥텟입니다. 헤더의 길이는 2옥텟입니다.

1 - 패킷의 길이는 2옥텟입니다. 헤더의 길이는 3옥텟입니다.

2 - 패킷의 길이는 4옥텟입니다. 헤더의 길이는 5옥텟입니다.

3 - 패킷의 길이가 불확실합니다. 헤더의 길이는 1옥텟이며, 구현에서는 패킷의 길이를 결정해야 합니다. 패킷이 파일에 있으면 패킷이 파일 끝까지 확장된다는 의미입니다. 일반적으로 구현에서는 데이터의 끝이 컨텍스트에서 명확해지는 경우를 제외하고는 불확정 길이 패킷을 사용해서는 안 되며, 그런 경우에도 한정된 길이 또는 새로운 형식 헤더를 사용하는 것이 더 좋습니다. 아래에 설명된 새로운 형식 헤더에는 불확실한 길이의 데이터를 정확하게 인코딩하는 메커니즘이 있습니다.\(SHOULD NOT\)

---
#### **4.2.2.  New Format Packet Lengths**

새로운 형식의 패킷에는 길이를 인코딩하는 네 가지 방법이 있습니다.

1. 1옥텟의 본문 길이 헤더는 최대 191옥텟의 패킷 길이를 인코딩합니다.

2. 2옥텟 본문 길이 헤더는 192\~8383옥텟의 패킷 길이를 인코딩합니다.

3. 5옥텟 본문 길이 헤더는 최대 4,294,967,295\(0xFFFFFFFF\) 옥텟 길이의 패킷 길이를 인코딩합니다. \(이것은 실제로 4옥텟 스칼라 숫자를 인코딩합니다.\)

4. 발급자가 패킷 본문의 길이를 미리 알 수 없는 경우 부분 본문 길이 헤더는 불확실한 길이의 패킷을 인코딩하여 효과적으로 스트림으로 만듭니다.

---
##### **4.2.2.1.  One-Octet Lengths**

1옥텟의 Body Length 헤더는 0\~191옥텟의 길이를 인코딩합니다. 이 유형의 길이 헤더는 한 옥텟 값이 192보다 작기 때문에 인식됩니다. 본문 길이는 다음과 같습니다.

```text
       bodyLen = 1st_octet;
```

---
##### **4.2.2.2.  Two-Octet Lengths**

2옥텟 본문 길이 헤더는 192\~8383옥텟의 길이를 인코딩합니다. 첫 번째 옥텟이 192\~223 범위에 있기 때문에 인식됩니다. 본문 길이는 다음과 같습니다.

```text
       bodyLen = ((1st_octet - 192) << 8) + (2nd_octet) + 192
```

---
##### **4.2.2.3.  Five-Octet Lengths**

5옥텟의 Body Length 헤더는 값 255를 보유한 단일 옥텟과 그 뒤에 오는 4옥텟 스칼라로 구성됩니다. 몸 길이는 다음과 같습니다.

```text
       bodyLen = (2nd_octet << 24) | (3rd_octet << 16) |
                 (4th_octet << 8)  | 5th_octet
```

1옥텟, 2옥텟, 5옥텟 길이의 기본 세트는 일부 패킷에 내부적으로도 사용됩니다.

---
##### **4.2.2.4.  Partial Body Lengths**

부분 본문 길이 헤더는 1옥텟 길이이며 데이터 패킷의 일부 길이만 인코딩합니다. 이 길이는 1부터 1,073,741,824까지\(2의 30승\) 2의 거듭제곱입니다. 224보다 크거나 같고 255보다 작은 1옥텟 값으로 인식됩니다. 부분 본문 길이는 다음과 같습니다.

```text
       partialBodyLen = 1 << (1st_octet & 0x1F);
```

각 부분 본문 길이 헤더 뒤에는 패킷 본문 데이터의 일부가 옵니다. 부분 본문 길이 헤더는 이 부분의 길이를 지정합니다. 해당 부분 뒤에는 또 다른 길이 헤더\(1옥텟, 2옥텟, 5옥텟 또는 부분\)가 옵니다. 패킷의 마지막 길이 헤더는 부분 본문 길이 헤더가 되어서는 안 됩니다. 부분 본문 길이 헤더는 패킷의 최종 부분이 아닌 부분에만 사용될 수 있습니다.\(MUST NOT\)

마지막 Body Length 헤더는 길이가 0인 헤더일 수도 있습니다.

구현에서는 데이터 패킷에 대해 리터럴, 압축 또는 암호화된 부분 본문 길이를 사용할 수 있습니다. 첫 번째 부분 길이는 최소 512옥텟 길이여야 합니다. 부분 본문 길이는 다른 패킷 유형에 사용되어서는 안 됩니다.\(MAY, MUST, MUST NOT\)

---
#### **4.2.3.  Packet Length Examples**

이러한 예는 새로운 형식의 패킷이 패킷 길이를 인코딩할 수 있는 방법을 보여줍니다.

길이가 100인 패킷의 길이는 한 옥텟\(0x64\)으로 인코딩될 수 있습니다. 그 다음에는 100옥텟의 데이터가 옵니다.

길이가 1723인 패킷은 두 개의 옥텟\(0xC5, 0xFB\)으로 인코딩된 길이를 가질 수 있습니다. 이 헤더 뒤에는 1723 옥텟의 데이터가 옵니다.

길이가 100000인 패킷의 길이는 5개의 옥텟\(0xFF, 0x00, 0x01, 0x86, 0xA0\)으로 인코딩될 수 있습니다.

또한 다음 옥텟 스트림으로 인코딩될 수도 있습니다: 0xEF, 데이터의 첫 번째 32768 옥텟; 0xE1, 데이터의 다음 두 옥텟; 0xE0, 데이터의 다음 1옥텟; 0xF0, 다음 65536 옥텟의 데이터; 0xC5, 0xDD, 데이터의 마지막 1693 옥텟. 이는 가능한 인코딩 중 하나일 뿐이며 일반 본문 길이 헤더가 데이터의 마지막 부분을 인코딩하는 한 부분 본문 길이 헤더의 크기에 대한 다양한 변형이 가능합니다.

이러한 모든 설명에서 패킷의 전체 길이는 헤더 길이에 본문 길이를 더한 값이라는 점에 유의하세요.

---
### **4.3.  Packet Tags**

패킷 태그는 본문이 어떤 유형의 패킷을 보유하고 있는지 나타냅니다. 이전 형식 헤더에는 16개 미만의 태그만 있을 수 있는 반면, 새 형식 헤더에는 최대 63개의 태그가 있을 수 있습니다. 정의된 태그\(십진수\)는 다음과 같습니다.

```text
       0        -- Reserved - a packet tag MUST NOT have this value
       1        -- Public-Key Encrypted Session Key Packet
       2        -- Signature Packet
       3        -- Symmetric-Key Encrypted Session Key Packet
       4        -- One-Pass Signature Packet
       5        -- Secret-Key Packet
       6        -- Public-Key Packet
       7        -- Secret-Subkey Packet
       8        -- Compressed Data Packet
       9        -- Symmetrically Encrypted Data Packet
       10       -- Marker Packet
       11       -- Literal Data Packet
       12       -- Trust Packet
       13       -- User ID Packet
       14       -- Public-Subkey Packet
       17       -- User Attribute Packet
       18       -- Sym. Encrypted and Integrity Protected Data Packet
       19       -- Modification Detection Code Packet
       60 to 63 -- Private or Experimental Values
```

---
## **5.  Packet Types**
---
### **5.1.  Public-Key Encrypted Session Key Packets (Tag 1)**

공개 키 암호화 세션 키 패킷에는 메시지를 암호화하는 데 사용되는 세션 키가 들어 있습니다. 0개 이상의 공개 키 암호화 세션 키 패킷 및/또는 대칭 키 암호화 세션 키 패킷은 암호화된 메시지를 보유하는 대칭 암호화 데이터 패킷 앞에 올 수 있습니다. 메시지는 세션 키로 암호화되며 세션 키 자체는 암호화되어 암호화된 세션 키 패킷에 저장됩니다. 대칭 암호화 데이터 패킷 앞에는 메시지가 암호화되는 각 OpenPGP 키에 대한 하나의 공개 키 암호화 세션 키 패킷이 옵니다. 메시지 수신자는 자신의 공개 키로 암호화된 세션 키를 찾고, 세션 키를 해독한 다음, 세션 키를 사용하여 메시지를 해독합니다.

이 패킷의 본문은 다음으로 구성됩니다.

- 패킷 유형의 버전 번호를 나타내는 1옥텟 숫자입니다. 현재 정의된 패킷 버전 값은 3입니다.

- 세션 키가 암호화되는 공개 키의 키 ID를 제공하는 8옥텟 숫자입니다. 세션 키가 하위 키로 암호화된 경우 기본 키의 키 ID 대신 이 하위 키의 키 ID가 여기에서 사용됩니다.

- 사용된 공개 키 알고리즘을 제공하는 1옥텟 숫자입니다.

- 암호화된 세션 키인 옥텟 문자열입니다. 이 문자열은 패킷의 나머지 부분을 차지하며 그 내용은 사용된 공개 키 알고리즘에 따라 달라집니다.

RSA 암호화를 위한 알고리즘 특정 필드

- RSA 암호화된 값 m\*\*e mod n의 다중정밀도 정수\(MPI\).

Elgamal 암호화를 위한 알고리즘별 필드:

- Elgamal\(Diffie-Hellman\) 값 g\*\*k mod p의 MPI.

- Elgamal\(Diffie-Hellman\) 값의 MPI m \* y\*\*k mod p.

위 수식에서 "m" 값은 다음과 같이 세션 키에서 파생됩니다. 첫째, 세션 키에는 다음 대칭 암호화 데이터 패킷을 암호화하는 데 사용되는 대칭 암호화 알고리즘을 지정하는 1옥텟 알고리즘 식별자가 접두사로 붙습니다. 그런 다음 알고리즘 식별자\(모듈로 65536\)를 포함하지 않고 이전 세션 키 옥텟의 합계와 동일한 2옥텟 체크섬이 추가됩니다. 그런 다음 이 값은 EME-PKCS1-v1\_5를 인코딩하는 PKCS#1 블록에 설명된 대로 인코딩됩니다. 위 공식에 사용되는 "m" 값을 구성하는 \[RFC3447\]의 섹션 7.2.1입니다. OpenPGP의 PKCS#1 사용에 대한 참고 사항은 이 문서의 섹션 13.1을 참조하세요.

구현이 하나의 세션 키로 여러 PKESK를 형성하여 여러 키로 해독될 수 있는 메시지를 형성하는 경우 구현은 각 키에 대해 새로운 PKCS#1 인코딩을 만들어야 합니다.\(MUST\)

구현에서는 "와일드 카드" 또는 "추측" 키 ID로 0의 키 ID를 허용하거나 사용할 수 있습니다. 이 경우 수신 구현에서는 사용 가능한 모든 개인 키를 시도하여 유효한 복호화 세션 키를 확인합니다. 이 형식은 메시지의 트래픽 분석을 줄이는 데 도움이 됩니다.\(MAY\)

---
### **5.2.  Signature Packet (Tag 2)**

서명 패킷은 일부 공개 키와 일부 데이터 간의 바인딩을 설명합니다. 가장 일반적인 서명은 파일이나 텍스트 블록의 서명과 사용자 ID를 인증하는 서명입니다.

두 가지 버전의 서명 패킷이 정의됩니다. 버전 3은 기본 서명 정보를 제공하는 반면, 버전 4는 서명에 대한 추가 정보를 지정할 수 있는 하위 패킷이 포함된 확장 가능한 형식을 제공합니다. PGP 2.6.x는 버전 3 서명만 허용합니다.

```text
   Implementations SHOULD accept V3 signatures.  Implementations SHOULD
   generate V4 signatures.
```

구현이 V3 키로 암호화된 암호화 및 서명된 메시지를 생성하는 경우 V3 서명을 생성하는 것이 합리적입니다.

---
#### **5.2.1.  Signature Types**

서명에는 여러 가지 가능한 의미가 있으며, 이는 주어진 서명의 서명 유형 옥텟으로 표시됩니다. 이러한 의미가 모호한 것은 결함이 아니라 시스템의 특징이라는 점을 참고하시기 바랍니다. OpenPGP는 서명 수신자에게 유효성에 대한 최종 권한을 부여하기 때문에 한 서명자의 우연한 행위가 다른 기관의 적극적인 행위보다 더 엄격할 수 있습니다. 각 유형의 서명을 계산하고 확인하는 방법에 대한 자세한 내용은 섹션 5.2.4, "서명 계산"을 참조하세요.

이러한 의미는 다음과 같습니다.

0x00: 바이너리 문서의 서명입니다.

- 이는 서명자가 이를 소유하거나 생성했거나 수정되지 않았음을 인증한다는 의미입니다.

```text
   0x01: Signature of a canonical text document.
       This means the signer owns it, created it, or certifies that it
       has not been modified.  The signature is calculated over the text
       data with its line endings converted to <CR><LF>.
```

0x02: 독립형 서명.

- 이 서명은 자신의 서브패킷 내용만의 서명이다. 길이가 0인 이진 문서의 서명과 동일하게 계산됩니다. V3 독립형 서명을 갖는 것은 의미가 없습니다.

0x10: 사용자 ID 및 공개 키 패킷의 일반 인증입니다. 이 인증서 발급자는 키 소유자가 실제로 사용자 ID에 설명된 사람인지 인증자가 얼마나 잘 확인했는지에 대해 특별한 주장을 하지 않습니다.

0x11: 사용자 ID 및 공개 키 패킷의 페르소나 인증입니다. 이 인증서 발급자는 이 키의 소유자가 지정된 사용자 ID라는 주장에 대해 어떠한 확인도 수행하지 않았습니다.

0x12: 사용자 ID 및 공개 키 패킷의 일반 인증입니다. 이 인증서 발급자는 신원 주장에 대해 약간의 임시 확인을 수행했습니다.

0x13: 사용자 ID 및 공개 키 패킷의 확실한 인증입니다. 이 인증서 발급자는 신원 주장에 대해 실질적인 검증을 수행했습니다.

- 대부분의 OpenPGP 구현은 "키 서명"을 0x10 인증으로 만듭니다. 일부 구현에서는 0x11-0x13 인증을 발행할 수 있지만 유형을 구별하는 경우는 거의 없습니다.

0x18: 하위 키 바인딩 서명

- 이 서명은 하위 키를 소유하고 있음을 나타내는 최상위 서명 키의 설명입니다. 이 서명은 사용자 ID나 다른 패킷이 아닌 기본 키와 하위 키에서 직접 계산됩니다. 서명 하위 키를 바인딩하는 서명은 기본 키와 하위 키의 서명 하위 키에 의해 생성된 0x19 서명을 포함하는 이 바인딩 서명에 포함된 서명 하위 패킷을 가져야 합니다.\(MUST\)

0x19: 기본 키 바인딩 서명

- 이 서명은 기본 키와 하위 키가 소유하고 있음을 나타내는 서명 하위 키에 의한 설명입니다. 이 서명은 0x18 서명과 동일한 방식으로 계산됩니다. 즉, 사용자 ID나 다른 패킷이 아닌 기본 키와 하위 키에서 직접 계산됩니다.

0x1F: 키에 직접 서명

- 이 서명은 키에서 직접 계산됩니다. 서명 하위 패킷의 정보를 키에 바인딩하며, 해지 키 하위 패킷과 같이 키에 대한 정보를 제공하는 하위 패킷에 사용하기에 적합합니다. 또한 자체 인증자가 아닌 사람이 키와 이름 사이의 바인딩이 아닌 키 자체에 대해 설명하려는 경우에도 적합합니다.

0x20: 키 해지 서명

- 서명은 취소되는 키에서 직접 계산됩니다. 취소된 키는 사용되지 않습니다. 해지되는 키 또는 승인된 해지 키에 의한 해지 서명만 유효한 해지 서명으로 간주되어야 합니다.

0x28: 하위 키 해지 서명

- 서명은 취소되는 하위 키에서 직접 계산됩니다. 취소된 하위 키는 사용되지 않습니다. 이 하위 키에 바인딩된 최상위 서명 키 또는 승인된 해지 키에 의한 해지 서명만 유효한 해지 서명으로 간주되어야 합니다.

0x30: 인증 해지 서명

- 이 서명은 이전 사용자 ID 인증 서명\(서명 클래스 0x10\~0x13\) 또는 직접 키 서명\(0x1F\)을 취소합니다. 이는 폐기된 서명을 발행한 동일한 키 또는 승인된 폐기 키로 발행되어야 합니다. 서명은 해지된 인증서와 동일한 데이터를 통해 계산되며 해당 인증서보다 생성 날짜가 이후여야 합니다.

0x40: 타임스탬프 서명.

- 이 서명은 포함된 타임스탬프에 대해서만 의미가 있습니다.

0x50: 제3자 확인 서명.

- 이 서명은 다른 OpenPGP 서명 패킷에 대한 서명입니다. 이는 서명된 데이터에 대한 공증인 인감과 유사합니다. 제3자 서명에는 쉽게 식별할 수 있도록 서명 대상 하위 패킷이 포함되어야 합니다. 실제로는 'SHOULD'를 의미합니다. 대상 하위 패킷을 포함할 수 없는 이에 대한 그럴듯한 용도\(예: 키나 소스 문서가 아닌 서명만 보는 맹목적인 당사자\)가 있습니다.\(SHOULD, SHOULD\)

---
#### **5.2.2.  Version 3 Signature Packet Format**

버전 3 서명 패킷의 본문에는 다음이 포함됩니다.

```text
     - One-octet version number (3).
```

- 다음 해시된 자료의 1옥텟 길이입니다. 5여야 합니다.\(MUST\)

```text
         - One-octet signature type.

         - Four-octet creation time.
```

- 서명자의 8옥텟 키 ID입니다.

```text
     - One-octet public-key algorithm.

     - One-octet hash algorithm.
```

- 부호 있는 해시 값의 왼쪽 16비트를 보유하는 2옥텟 필드입니다.

- 서명을 구성하는 하나 이상의 다중 정밀도 정수. 이 부분은 아래에 설명된 대로 알고리즘에 따라 다릅니다.

서명할 데이터의 연결, 서명 유형 및 서명 패킷의 생성 시간\(추가 옥텟 5개\)이 해시됩니다. 결과 해시 값은 서명 알고리즘에 사용됩니다. 일부 유효하지 않은 서명을 거부하는 빠른 테스트를 제공하기 위해 해시의 상위 16비트\(처음 2옥텟\)가 서명 패킷에 포함됩니다.

RSA 서명에 대한 알고리즘별 필드:

- RSA 서명 값 m\*\*d mod n의 다중정밀도 정수\(MPI\).

DSA 서명을 위한 알고리즘별 필드:

- DSA 값 r의 MPI.

- DSA 값의 MPI.

서명 계산은 위에서 설명한 대로 서명된 데이터의 해시를 기반으로 합니다. DSA 서명의 계산 세부 사항은 RSA 서명의 경우와 다릅니다.

RSA 서명을 사용하면 해시 값은 RFC 3447의 섹션 9.2에 설명된 대로 PKCS#1 인코딩 유형 EMSA-PKCS1-v1\_5를 사용하여 인코딩됩니다. 이를 위해서는 해시 값을 ASN.1 구조에 옥텟 문자열로 삽입해야 합니다. 사용되는 해시 유형에 대한 개체 식별자가 구조에 포함됩니다. 현재 정의된 해시 알고리즘의 16진수 표현은 다음과 같습니다.

```text
     - MD5:        0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x02, 0x05

     - RIPEMD-160: 0x2B, 0x24, 0x03, 0x02, 0x01

     - SHA-1:      0x2B, 0x0E, 0x03, 0x02, 0x1A

     - SHA224:     0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x04

     - SHA256:     0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x01

     - SHA384:     0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x02

     - SHA512:     0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x03
```

ASN.1 OID\(객체 식별자\)는 다음과 같습니다.

```text
     - MD5:        1.2.840.113549.2.5

     - RIPEMD-160: 1.3.36.3.2.1

     - SHA-1:      1.3.14.3.2.26

     - SHA224:     2.16.840.1.101.3.4.2.4

     - SHA256:     2.16.840.1.101.3.4.2.1

     - SHA384:     2.16.840.1.101.3.4.2.2

     - SHA512:     2.16.840.1.101.3.4.2.3
```

이에 대한 전체 해시 접두사는 다음과 같습니다.

```text
       MD5:        0x30, 0x20, 0x30, 0x0C, 0x06, 0x08, 0x2A, 0x86,
                   0x48, 0x86, 0xF7, 0x0D, 0x02, 0x05, 0x05, 0x00,
                   0x04, 0x10

       RIPEMD-160: 0x30, 0x21, 0x30, 0x09, 0x06, 0x05, 0x2B, 0x24,
                   0x03, 0x02, 0x01, 0x05, 0x00, 0x04, 0x14

       SHA-1:      0x30, 0x21, 0x30, 0x09, 0x06, 0x05, 0x2b, 0x0E,
                   0x03, 0x02, 0x1A, 0x05, 0x00, 0x04, 0x14

       SHA224:     0x30, 0x31, 0x30, 0x0d, 0x06, 0x09, 0x60, 0x86,
                   0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x04, 0x05,
                   0x00, 0x04, 0x1C

       SHA256:     0x30, 0x31, 0x30, 0x0d, 0x06, 0x09, 0x60, 0x86,
                   0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x01, 0x05,
                   0x00, 0x04, 0x20

       SHA384:     0x30, 0x41, 0x30, 0x0d, 0x06, 0x09, 0x60, 0x86,
                   0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x02, 0x05,
                   0x00, 0x04, 0x30

       SHA512:     0x30, 0x51, 0x30, 0x0d, 0x06, 0x09, 0x60, 0x86,
                   0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x03, 0x05,
                   0x00, 0x04, 0x40
```

DSA 서명은 DSA 키의 생성기 값에 의해 생성된 그룹인 q의 비트 수와 크기가 동일한 해시를 사용해야 합니다.\(MUST\)

선택한 해시의 출력 크기가 q의 비트 수보다 큰 경우 해시 결과는 q의 비트 수와 동일한 가장 왼쪽 비트 수를 취하여 적합하도록 잘립니다. 이\(잘릴 수도 있음\) 해시 함수 결과는 숫자로 처리되며 DSA 서명 알고리즘에서 직접 사용됩니다.

---
#### **5.2.3.  Version 4 Signature Packet Format**

버전 4 서명 패킷의 본문에는 다음이 포함됩니다.

```text
     - One-octet version number (4).

     - One-octet signature type.

     - One-octet public-key algorithm.

     - One-octet hash algorithm.
```

- 다음 해시된 하위 패킷 데이터에 대한 2옥텟 스칼라 옥텟 수입니다. 이는 해시된 모든 하위 패킷의 길이\(옥텟\)입니다. 이 숫자만큼 증가된 포인터는 해시된 하위 패킷을 건너뜁니다.

- 해시된 하위 패킷 데이터 세트\(0개 이상의 하위 패킷\).

- 해시되지 않은 다음 하위 패킷 데이터에 대한 2옥텟 스칼라 옥텟 수입니다. 이는 해시되지 않은 모든 하위 패킷의 길이\(옥텟\)입니다. 이 숫자만큼 증가된 포인터는 해시되지 않은 하위 패킷을 건너뜁니다.

- 해시되지 않은 하위 패킷 데이터 세트\(0개 이상의 하위 패킷\)

- 서명된 해시 값의 왼쪽 16비트를 보유하는 2옥텟 필드입니다.

- 서명을 구성하는 하나 이상의 다중 정밀도 정수. 이 부분은 위에서 설명한 대로 알고리즘에 따라 다릅니다.

서명되는 데이터와 해시된 서브패킷 데이터\(포함\)를 통한 버전 번호의 서명 데이터의 연결이 해시됩니다. 결과 해시 값은 서명된 값입니다. 일부 잘못된 서명을 거부하는 빠른 테스트를 제공하기 위해 해시의 왼쪽 16비트가 서명 패킷에 포함됩니다.

서명 하위 패킷으로 구성된 두 개의 필드가 있습니다. 첫 번째 필드는 나머지 서명 데이터로 해시되고 두 번째 필드는 해시되지 않습니다. 두 번째 하위 패킷 세트는 암호화되지 않습니다.

서명으로 보호되며 권고 정보만 포함해야 합니다.

해시 함수 결과를 서명으로 변환하는 알고리즘은 아래 섹션에 설명되어 있습니다.

---
##### **5.2.3.1.  Signature Subpacket Specification**

하위 패킷 데이터 세트는 0개 이상의 서명 하위 패킷으로 구성됩니다. 서명 패킷에서 하위 패킷 데이터 세트 앞에는 모든 하위 패킷 길이\(옥텟\)의 2옥텟 스칼라 수가 옵니다. 이 숫자만큼 증가된 포인터는 하위 패킷 데이터 세트를 건너뜁니다.

각 하위 패킷은 하위 패킷 헤더와 본문으로 구성됩니다. 헤더는 다음으로 구성됩니다.

```text
     - the subpacket length (1, 2, or 5 octets),

     - the subpacket type (1 octet),
```

그 뒤에는 하위 패킷 관련 데이터가 옵니다.

길이에는 옥텟 유형이 포함되지만 이 길이는 포함되지 않습니다. 해당 형식은 "새로운" 형식의 패킷 헤더 길이와 유사하지만 부분 본문 길이를 가질 수 없습니다. 그건:

```text
       if the 1st octet <  192, then
           lengthOfLength = 1
           subpacketLen = 1st_octet

       if the 1st octet >= 192 and < 255, then
           lengthOfLength = 2
           subpacketLen = ((1st_octet - 192) << 8) + (2nd_octet) + 192

       if the 1st octet = 255, then
           lengthOfLength = 5
           subpacket length = [four-octet scalar starting at 2nd_octet]
```

서브패킷 유형 옥텟의 값은 다음과 같습니다.

```text
            0 = Reserved
            1 = Reserved
            2 = Signature Creation Time
            3 = Signature Expiration Time
            4 = Exportable Certification
            5 = Trust Signature
            6 = Regular Expression
```

7 = 취소 가능

- 8 = 예약됨 9 = 키 만료 시간 10 = 이전 버전과의 호환성을 위한 자리 표시자 11 = 기본 대칭 알고리즘 12 = 해지 키 13 = 예약됨 14 = 예약됨 15 = 예약됨 16 = 발급자 17 = 예약됨 18 = 예약됨 19 = 예약됨 20 = 표기법 데이터 21 = 기본 해시 알고리즘 22 = 기본 압축 알고리즘 23 = 키 서버 기본 설정 24 = 기본 키 서버 25 = 기본 사용자 ID 26 = 정책 URI 27 = 키 플래그 28 = 서명자의 사용자 ID 29 = 취소 이유 30 = 기능 31 = 서명 대상 32 = 내장된 서명 100 \~ 110 = 비공개 또는 실험적

구현은 인식하지 못하는 유형의 하위 패킷을 모두 무시해야 합니다\(SHOULD\).\(SHOULD\)

하위 패킷 유형의 비트 7은 "중요" 비트입니다. 설정된 경우 해당 하위 패킷이 서명 평가자가 인식하는 데 중요한 패킷임을 나타냅니다. 중요하다고 표시되었지만 평가 소프트웨어에 알려지지 않은 하위 패킷이 발견되면 평가자는 서명에 오류가 있는 것으로 간주해야 합니다.\(SHOULD\)

평가자는 하위 패킷을 "인식"할 수 있지만 이를 구현할 수는 없습니다. 중요한 비트의 목적은 서명자가 평가자에게 오류를 생성하는 새로운 알려지지 않은 기능을 무시하는 것보다 선호한다고 알릴 수 있도록 하는 것입니다.

구현은 "해지 이유" 하위 패킷뿐만 아니라 세 가지 선호 알고리즘 하위 패킷\(11, 21, 22\)을 구현해야 합니다\(SHOULD\). 그러나 구현에서 일부 기본 설정을 구현하지 않기로 선택한 경우 이러한 기본 설정을 구현하는 사용자의 희망을 존중하기 위해 정중하게 행동해야 합니다.\(SHOULD\)

---
##### **5.2.3.2.  Signature Subpacket Types**

현재 다수의 하위 패킷이 정의되어 있습니다. 일부 하위 패킷은 서명 자체에 적용되고 일부는 키의 속성입니다. 자체 서명에 있는 하위 패킷은 키 자체에 의해 만들어진 인증에 배치됩니다. 키에는 둘 이상의 사용자 ID가 있을 수 있으므로 둘 이상의 자체 서명과 서로 다른 하위 패킷이 있을 수 있습니다.

하위 패킷은 서명의 해시된 하위 패킷 섹션이나 해시되지 않은 하위 패킷 섹션에서 찾을 수 있습니다. 하위 패킷이 해시되지 않은 경우 해당 하위 패킷의 정보는 적절한 서명의 일부가 아니기 때문에 최종적인 것으로 간주될 수 없습니다.

---
##### **5.2.3.3.  Notes on Self-Signatures**

자체 서명은 서명이 참조하는 키에 의해 만들어진 구속력 있는 서명입니다. 자체 서명에는 인증 서명\(유형 0x10-0x13\), 직접 키 서명\(유형 0x1F\) 및 하위 키 바인딩 서명\(유형 0x18\)의 세 가지 유형이 있습니다. 인증 자체 서명의 경우 각 사용자 ID에는 자체 서명이 있을 수 있으므로 해당 자체 서명의 하위 패킷도 다를 수 있습니다. 하위 키 바인딩 서명의 경우 실제로 각 하위 키에는 자체 서명이 있습니다. 인증 자체 서명에 나타나는 하위 패킷은 사용자 이름에 적용되고, 하위 키 자체 서명에 나타나는 하위 패킷은 하위 키에 적용됩니다. 마지막으로 직접 키 서명의 하위 패킷은 전체 키에 적용됩니다.

소프트웨어를 구현하면 자체 서명의 기본 설정 하위 패킷을 최대한 좁게 해석해야 합니다. 예를 들어, 키에 Alice와 Bob이라는 두 개의 사용자 이름이 있다고 가정합니다. Alice는 대칭 알고리즘 CAST5를 선호하고 Bob은 IDEA 또는 TripleDES를 선호한다고 가정합니다. 소프트웨어가 Alice의 이름을 통해 이 키를 찾는 경우 선호되는 알고리즘은 CAST5입니다. 소프트웨어가 Bob의 이름을 통해 키를 찾는 경우 선호되는 알고리즘은 IDEA입니다. 키가 키 ID로 위치하는 경우 키의 기본 사용자 ID 알고리즘이 기본 대칭 알고리즘을 제공합니다.

자체 서명을 취소하거나 만료되도록 허용하는 것은 서명 유형에 따라 의미가 다릅니다. 사용자 ID의 자체 서명을 취소하면 해당 사용자 이름이 사실상 폐기됩니다. 자체 서명은 "내 이름 X는 내 서명 키 K와 연결되어 있습니다"라는 진술이며 다른 사용자의 인증으로 확증됩니다. 다른 사용자가 인증을 취소하면 해당 이름과 키가 서로 연결되어 있다고 더 이상 믿지 않는다는 의미입니다. 마찬가지로, 사용자가 자체 서명을 취소하면 사용자는 더 이상 해당 이름을 사용하지 않고 해당 이메일 주소도 갖지 않게 됩니다. 구속력 있는 서명을 취소하면 해당 서명이 효과적으로 폐기됩니다.

하위 키. 직접 키 서명을 취소하면 해당 서명이 취소됩니다. 보다 자세한 내용은 "해지 이유" 하위 패킷\(섹션 5.2.3.23\)을 참조하세요.

자체 서명에는 키 사용에 대한 중요한 정보가 포함되어 있으므로 구현에서는 사용자가 자체 서명과 기본 설정 및 키 만료와 같은 중요한 정보를 다시 작성할 수 있도록 허용해야 합니다\(SHOULD\).\(SHOULD\)

구현으로 가져온 자체 서명이 구현에서 지원하지 않는 기능을 알리지 않는지 확인하고 적절하게 서명을 다시 작성하는 것이 좋습니다.

동일한 객체에서 여러 자체 서명을 발견하는 구현은 적합하다고 판단되는 방식으로 모호성을 해결할 수 있지만 가장 최근의 자체 서명에 우선순위를 부여하는 것이 좋습니다\(RECOMMENDED\).\(SHOULD\)

---
##### **5.2.3.4.  Signature Creation Time**

```text
   (4-octet time field)
```

서명이 작성된 시간입니다.

해시된 영역에 있어야 합니다.\(MUST\)

---
##### **5.2.3.5.  Issuer**

```text
   (8-octet Key ID)
```

서명을 발행하는 키의 OpenPGP 키 ID입니다.

---
##### **5.2.3.6.  Key Expiration Time**

```text
   (4-octet time field)
```

키의 유효 기간입니다. 키 생성 시간 이후 키가 만료되는 시간\(초\)입니다. 이것이 없거나 값이 0이면 키는 만료되지 않습니다. 이는 자체 서명에서만 찾을 수 있습니다.

---
##### **5.2.3.7.  Preferred Symmetric Algorithms**

```text
   (array of one-octet values)
```

키 보유자가 선호하는 알고리즘을 나타내는 대칭 알고리즘 번호입니다. 하위 패킷 본문은 가장 선호하는 항목이 먼저 나열되는 순서가 지정된 옥텟 목록입니다. 단지

나열된 알고리즘은 수신자의 소프트웨어에서 지원됩니다. 알고리즘 번호는 섹션 9에 있습니다. 이는 자기 서명에서만 찾을 수 있습니다.

---
##### **5.2.3.8.  Preferred Hash Algorithms**

```text
   (array of one-octet values)
```

키 보유자가 수신하기를 선호하는 알고리즘을 나타내는 메시지 다이제스트 알고리즘 번호입니다. 선호하는 대칭 알고리즘과 마찬가지로 목록도 순서가 지정됩니다. 알고리즘 번호는 섹션 9에 있습니다. 이는 자체 서명에서만 찾을 수 있습니다.

---
##### **5.2.3.9.  Preferred Compression Algorithms**

```text
   (array of one-octet values)
```

키 보유자가 선호하는 알고리즘을 나타내는 압축 알고리즘 번호입니다. 선호하는 대칭 알고리즘과 마찬가지로 목록도 순서가 지정됩니다. 알고리즘 번호는 섹션 9에 있습니다. 이 하위 패킷이 포함되지 않은 경우 ZIP이 선호됩니다. 0은 압축되지 않은 데이터가 선호됨을 나타냅니다. 키 보유자의 소프트웨어에는 해당 구현에 압축 소프트웨어가 없을 수도 있습니다. 이는 자체 서명에서만 찾을 수 있습니다.

---
##### **5.2.3.10.  Signature Expiration Time**

```text
   (4-octet time field)
```

서명의 유효 기간입니다. 서명 생성 시간 이후 서명이 만료되는 시간\(초\)입니다. 이것이 존재하지 않거나 값이 0이면 만료되지 않습니다.

---
##### **5.2.3.11.  Exportable Certification**

```text
   (1 octet of exportability, 0 for not, 1 for exportable)
```

이 하위 패킷은 인증서 서명이 서명 발급자가 아닌 다른 사용자가 사용할 수 있도록 "내보낼 수 있는지" 여부를 나타냅니다. 패킷 본문에는 서명을 내보낼 수 있는지 여부를 나타내는 부울 플래그가 포함되어 있습니다. 이 패킷이 없으면 인증서를 내보낼 수 있습니다. 이는 1을 포함하는 플래그와 동일합니다.

내보낼 수 없는 또는 "로컬" 인증은 해당 사용자의 구현 내에서만 키가 유효한 것으로 표시하기 위해 사용자가 만든 서명입니다.

따라서 구현 시 다른 사용자에게 전송하기 위해 사용자의 키 복사본을 준비하는 경우\(키를 "내보내는" 프로세스\) 모든 로컬 인증 서명이 키에서 삭제됩니다.

전송된 키의 수신자는 키를 "가져오고" 마찬가지로 모든 현지 인증을 자릅니다. 일반적인 작업에서는 내보낸 키에 대해 가져오기가 수행된다고 가정하면 아무 것도 없습니다. 그러나 이것이 합리적으로 일어날 수 있는 경우가 있습니다. 예를 들어, 구현에서 내보낸 키 외에 키 데이터베이스에서 키도 가져올 수 있도록 허용하는 경우 이러한 상황이 발생할 수 있습니다.

일부 구현은 단일 사용자의 관심을 나타내지 않습니다\(예: 키 서버\). 이러한 구현은 항상 처리하는 키에서 로컬 인증을 잘라냅니다.

---
##### **5.2.3.12.  Revocable**

```text
   (1 octet of revocability, 0 for not, 1 for revocable)
```

서명의 취소 가능 상태입니다. 패킷 본문에는 서명이 취소 가능한지 여부를 나타내는 부울 플래그가 포함되어 있습니다. 취소할 수 없는 서명에는 이후의 취소 서명이 무시됩니다. 이는 키 수명 동안 서명을 취소할 수 없다는 서명자의 약속을 나타냅니다. 이 패킷이 없으면 서명을 취소할 수 있습니다.

---
##### **5.2.3.13.  Trust Signature**

```text
   (1 octet "level" (depth), 1 octet of trust amount)
```

서명자는 키가 유효할 뿐만 아니라 지정된 수준에서 신뢰할 수 있다고 주장합니다. 레벨 0은 일반 유효성 서명과 동일한 의미를 갖습니다. 레벨 1은 서명된 키가 신뢰도를 지정하는 본문의 두 번째 옥텟과 함께 유효하고 신뢰할 수 있는 소개자임을 주장함을 의미합니다. 레벨 2는 서명된 키가 레벨 1 신뢰 서명을 발행하기 위해 신뢰된다는 것을 의미합니다. 즉, "메타 도입자"입니다. 일반적으로 레벨 n 신뢰 서명은 키가 레벨 n-1 신뢰 서명을 발행하도록 신뢰됨을 나타냅니다. 신뢰량의 범위는 0\~255이며, 120보다 작은 값은 부분 신뢰를 나타내고 120 이상의 값은 완전 신뢰를 나타내는 것으로 해석됩니다. 구현은 부분 신뢰의 경우 60, 완전 신뢰의 경우 120 값을 내보내야 합니다\(SHOULD\).\(SHOULD\)

---
##### **5.2.3.14.  Regular Expression**

```text
   (null-terminated regular expression)
```

확장된 신뢰 범위를 제한하기 위해 신뢰 서명 패킷\(레벨 \> 0\)과 함께 사용됩니다. 이 패킷 본문의 정규식과 일치하는 사용자 ID의 대상 키에 의한 서명만 신뢰 서명 하위 패킷에 의해 확장된 신뢰를 갖습니다. 정규식은 Henry Spencer의 "거의 공개 도메인" 정규식 \[REGEX\] 패키지와 동일한 구문을 사용합니다. 구문에 대한 설명은 아래 섹션 8에 나와 있습니다.

---
##### **5.2.3.15.  Revocation Key**

```text
   (1 octet of class, 1 octet of public-key algorithm ID, 20 octets of
   fingerprint)
```

이 키에 대한 해지 서명을 발행하도록 지정된 키에 권한을 부여합니다. 클래스 옥텟에는 비트 0x80이 설정되어 있어야 합니다. 비트 0x40이 설정되면 이는 해지 정보가 민감하다는 것을 의미합니다. 다른 비트는 향후 다른 종류의 인증으로 확장하기 위한 것입니다. 이는 자체 서명에서 확인할 수 있습니다.

"민감한" 플래그가 설정된 경우 키 보유자는 이 하위 패킷에 실제 민감한 관계를 설명하는 개인 신뢰 정보가 포함되어 있다고 느낍니다. 이 플래그가 설정된 경우 구현에서는 데이터를 사용할 수 있어야 하는 경우\(서명이 지정된 취소자에게 전송되는 경우 또는 해당 취소자의 취소 서명이 수반되는 경우\)를 제외하고 이 서명을 다른 사용자에게 내보내서는 안 됩니다. 이 하위 패킷을 내보내야 하는 다른 하위 패킷과 결합되지 않도록 별도의 서명 내에서 격리하는 것이 적절할 수 있습니다.\(SHOULD NOT\)

---
##### **5.2.3.16.  Notation Data**

```text
       (4 octets of flags, 2 octets of name length (M),
                           2 octets of value length (N),
                           M octets of name data,
                           N octets of value data)
```

이 서브패킷은 발행자가 만들고자 하는 서명의 "표기법"을 설명합니다. 표기법에는 이름과 값이 있으며 각각은 옥텟 문자열입니다. 서명에는 둘 이상의 표기법이 있을 수 있습니다. 서명 발급자가 원하는 확장에 대해 표기법을 사용할 수 있습니다. "플래그" 필드에는 4옥텟의 플래그가 포함됩니다.

정의되지 않은 모든 플래그는 0이어야 합니다. 정의된 플래그는 다음과 같습니다.\(MUST\)

- 첫 번째 옥텟: 0x80 = 사람이 읽을 수 있음. 이 메모 값은 텍스트입니다. 기타 옥텟: 없음.

표기법 이름은 UTF-8로 인코딩된 임의의 문자열입니다. 이는 IETF 네임스페이스와 사용자 네임스페이스라는 두 개의 네임스페이스에 있습니다.

IETF 네임스페이스는 IANA에 등록되어 있습니다. 이러한 이름에는 "@" 문자\(0x40\)가 포함되어서는 안 됩니다. 사용자 네임스페이스에 대한 태그입니다.\(MUST NOT\)

사용자 네임스페이스의 이름은 UTF-8 문자열 태그, "@", DNS 도메인 이름으로 구성됩니다. 태그에는 "@" 문자가 포함되어서는 안 됩니다. 예를 들어, example Corporation에서 사용하는 "sample" 태그는 "sample@example.com"일 수 있습니다.\(MUST NOT\)

사용자 공간의 이름은 해당 도메인 소유자가 소유하고 제어합니다. 분명히 자신이 소유하지 않은 DNS 공간에 새 이름을 만드는 것은 좋지 않은 형태입니다.

사용자 네임스페이스는 이메일 주소 형식이므로 구현자는 명명된 태그 사용에 대해 상담할 수 있는 사람에게 해당 주소가 도달하도록 준비할 수 있습니다. UTF-8 인코딩으로 인해 유효한 사용자 공간 이름 태그가 모두 유효한 이메일 주소는 아닙니다.\(MAY\)

비판적 표기법이 있는 경우 비판성은 일반적인 표기법이 아닌 해당 특정 표기법에 적용됩니다.

---
##### **5.2.3.17.  Key Server Preferences**

```text
   (N octets of flags)
```

이는 키 보유자가 키 서버에서 키를 처리하는 방식에 대해 갖고 있는 기본 설정을 나타내는 1비트 플래그 목록입니다. 정의되지 않은 모든 플래그는 0이어야 합니다.\(MUST\)

첫 번째 옥텟: 0x80 = 수정 안 함

- 키 보유자는 이 키를 본인 또는 키 서버 관리자에 의해서만 수정 또는 업데이트하도록 요청합니다.

이는 자체 서명에서만 찾을 수 있습니다.

---
##### **5.2.3.18.  Preferred Key Server**

```text
   (String)
```

이는 키 보유자가 업데이트에 사용하기를 선호하는 키 서버의 URI입니다. 여러 사용자 ID가 있는 키에는 각 사용자 ID에 대해 선호하는 키 서버가 있을 수 있습니다. 또한 이는 URI이므로 키 서버는 실제로 ftp, http, Finger 등으로 검색된 키의 복사본일 수 있습니다.

---
##### **5.2.3.19.  Primary User ID**

```text
   (1 octet, Boolean)
```

이는 이 사용자 ID가 이 키의 기본 사용자 ID인지 여부를 나타내는 사용자 ID 자체 서명의 플래그입니다. 기본 사용자 ID를 참조하여 선호도 등의 모호성을 해결하는 구현이 합리적입니다. 이 플래그가 없으면 해당 값은 0입니다. 키에서 둘 이상의 사용자 ID가 기본으로 표시된 경우 구현 시 적합하다고 판단되는 방식으로 모호성을 해결할 수 있지만 가장 최근의 자체 서명이 있는 사용자 ID에 우선순위를 부여하는 것이 좋습니다.\(SHOULD\)

사용자 ID 패킷의 자체 서명에 나타날 때 이 하위 패킷은 사용자 ID 패킷에만 적용됩니다. 사용자 속성 패킷의 자체 서명에 나타날 때 이 하위 패킷은 사용자 속성 패킷에만 적용됩니다. 즉, 두 개의 서로 다른 독립적인 "기본"이 있습니다. 하나는 사용자 ID용이고 다른 하나는 사용자 속성용입니다.

---
##### **5.2.3.20.  Policy URI**

```text
   (String)
```

이 하위 패킷에는 서명이 발행된 정책을 설명하는 문서의 URI가 포함되어 있습니다.

---
##### **5.2.3.21.  Key Flags**

```text
   (N octets of flags)
```

이 하위 패킷에는 키에 대한 정보를 보유하는 바이너리 플래그 목록이 포함되어 있습니다. 이는 옥텟 문자열이며 구현은 고정된 크기를 가정해서는 안 됩니다. 이는 시간이 지남에 따라 성장할 수 있기 때문입니다. 목록이 구현이 예상하는 것보다 짧은 경우, 명시되지 않은 플래그는 0으로 간주됩니다. 정의된 플래그는 다음과 같습니다.\(MUST NOT\)

```text
       First octet:
```

- 0x01 - 이 키는 다른 키를 인증하는 데 사용될 수 있습니다.

- 0x02 - 이 키는 데이터 서명에 사용될 수 있습니다.

- 0x04 - 이 키는 통신을 암호화하는 데 사용될 수 있습니다.

- 0x08 - 이 키는 저장소를 암호화하는 데 사용될 수 있습니다.

- 0x10 - 이 키의 개인 구성 요소가 비밀 공유 메커니즘에 의해 분할되었을 수 있습니다.

- 0x20 - 이 키는 인증에 사용될 수 있습니다.

0x80 - 이 키의 개인 구성 요소는

- 한 사람 이상을 소유하고 있는 경우.

```text
   Usage notes:
```

이 패킷의 플래그는 자체 서명이나 인증 서명에 나타날 수 있습니다. 이는 진술하는 사람에 따라 다른 의미를 갖습니다. 예를 들어 "서명 데이터" 플래그가 있는 인증 서명은 해당 인증이 해당 용도로 사용된다는 것을 나타냅니다. 반면, 자체 서명의 "통신 암호화" 플래그는 특정 키가 통신에 사용된다는 기본 설정을 나타냅니다. 그러나 무엇이 "통신"이고 무엇이 "저장"인지를 결정하는 것은 까다로운 문제입니다. 이 결정은 전적으로 구현에 달려 있습니다. 이 문서의 저자는 이 문제에 대해 어떤 특별한 지혜도 주장하지 않으며, 받아들여진 의견이 바뀔 수 있다는 것을 알고 있습니다.

"분할 키"\(0x10\) 및 "그룹 키"\(0x80\) 플래그는 자체 서명에만 배치됩니다. 인증 서명에서는 의미가 없습니다. 이는 플래그가 적용되는 키를 참조하는 직접 키 서명\(유형 0x1F\) 또는 하위 키 서명\(유형 0x18\)에만 배치되어야 합니다.\(SHOULD\)

---
##### **5.2.3.22.  Signer's User ID**

```text
   (String)
```

이 하위 패킷을 사용하면 키홀더가 서명을 담당하는 사용자 ID를 명시할 수 있습니다. 많은 키홀더는 비즈니스 통신은 물론 개인 통신 등 다양한 목적으로 단일 키를 사용합니다. 이 하위 패킷을 사용하면 해당 키홀더가 자신의 역할 중 어느 것이 서명을 하는지 명시할 수 있습니다.

이 서브패킷은 사용자 속성 패킷을 참조하는 데 사용하기에 적합하지 않습니다.

---
##### **5.2.3.23.  Reason for Revocation**

```text
   (1 octet of revocation code, N octets of reason string)
```

이 하위 패킷은 키 취소 및 인증 취소 서명에만 사용됩니다. 키 또는 인증서가 해지된 이유를 설명합니다.

첫 번째 옥텟에는 해지 이유를 나타내는 기계 판독 가능 코드가 포함되어 있습니다.

- 0 - 지정된 이유 없음\(키 취소 또는 인증서 취소\) 1 - 키가 대체됨\(키 취소\) 2 - 키 자료가 손상됨\(키 취소\) 3 - 키가 폐기되고 더 이상 사용되지 않음\(키 취소\) 32 - 사용자 ID 정보가 더 이상 유효하지 않습니다\(인증서 해지\) 100-110 - 개인 사용

해지 코드 다음에는 해지 이유에 대한 정보를 사람이 읽을 수 있는 형식\(UTF-8\)으로 제공하는 옥텟 문자열이 있습니다. 문자열은 null, 즉 길이가 0일 수 있습니다. 서브패킷의 길이는 이유 문자열의 길이에 1을 더한 값입니다. 구현은 이 서브패킷을 구현하고, 이를 모든 해지 서명에 포함하고, 해지를 적절하게 해석해야 합니다. 이유 사이에는 중요한 의미상의 차이가 있으므로 서명을 취소하는 데에는 중요한 이유가 있습니다.\(SHOULD\)

손상으로 인해 키가 취소된 경우 해당 키로 생성된 모든 서명은 의심됩니다. 그러나 단순히 대체되거나 폐기된 경우에는 이전 서명이 여전히 유효합니다. 폐기된 서명이 사용자 ID를 인증하기 위한 자체 서명인 경우 폐기는 해당 사용자 이름이 더 이상 사용되지 않음을 의미합니다. 이러한 철회에는 0x20 코드가 포함되어야 합니다.\(SHOULD\)

다른 사람의 키에 대한 인증을 포함하여 모든 서명이 취소될 수 있습니다. 키홀더가 이메일 주소를 가지고 회사를 그만두는 경우 등 인증 서명을 취소하는 데에는 여러 가지 이유가 있습니다. 취소된 인증은 더 이상 유효성 계산에 포함되지 않습니다.

---
##### **5.2.3.24.  Features**

```text
   (N octets of flags)
```

기능 서브패킷은 사용자 구현이 지원하는 고급 OpenPGP 기능을 나타냅니다. 이는 이전 버전과 호환되지 않는 기능이 OpenPGP에 추가될 때 사용자가 해당 기능을 사용할 수 있다고 명시할 수 있도록 하기 위한 것입니다. 플래그는 특정 기능이 지원됨을 나타내는 단일 비트입니다.

이 하위 패킷은 기본 설정 하위 패킷과 유사하며 자체 서명에만 나타납니다.

구현은 사용할 수 있다고 명시하지 않은 사용자에게 보낼 때 나열된 기능을 사용해서는 안 됩니다.\(SHOULD NOT\)

정의된 기능은 다음과 같습니다.

```text
       First octet:

       0x01 - Modification Detection (packets 18 and 19)
```

구현이 정의된 기능 중 하나를 구현하는 경우 기능 하위 패킷도 구현해야 합니다.\(SHOULD\)

구현은 다른 적절한 구현 종속 메커니즘의 기능을 자유롭게 추론할 수 있습니다.

---
##### **5.2.3.25.  Signature Target**

```text
   (1 octet public-key algorithm, 1 octet hash algorithm, N octets hash)
```

이 하위 패킷은 서명이 참조하는 특정 대상 서명을 식별합니다. 해지 서명의 경우 이 하위 패킷은 어떤 서명이 해지되는지 명시적으로 지정합니다. 타사 또는 타임스탬프 서명의 경우 이는 서명된 서명을 지정합니다. 모든 인수는 해당 대상 서명의 식별자입니다.

해시 데이터의 N 옥텟은 반드시 서명 해시의 크기여야 합니다. 예를 들어 SHA-1 해시가 포함된 대상 서명에는 20옥텟의 해시 데이터가 있어야 합니다.\(MUST, MUST\)

---
##### **5.2.3.26.  Embedded Signature**

```text
   (1 signature packet body)
```

이 하위 패킷에는 위의 섹션 5.2에 지정된 완전한 서명 패킷 본문이 포함되어 있습니다. 한 서명이 다른 서명을 참조하거나 다른 서명에 통합되어야 할 때 유용합니다.

---
#### **5.2.4.  Computing Signatures**

모든 서명은 서명 데이터에 대한 해시를 생성한 다음 서명 알고리즘에서 결과 해시를 사용하여 형성됩니다.

바이너리 문서 서명\(유형 0x00\)의 경우 문서 데이터가 직접 해시됩니다. 텍스트 문서 서명\(유형 0x01\)의 경우 줄 끝을 <CR\><LF\>로 변환하여 문서를 표준화하고 결과 데이터를 해시합니다.

키에 대한 서명이 작성되면 해시 데이터는 옥텟 0x99로 시작하고 그 뒤에 2옥텟 길이의 키, 키 패킷 본문이 옵니다. \(이것은 2옥텟 길이의 키 패킷에 대한 구식 패킷 헤더입니다.\) 하위 키 바인딩 서명\(유형 0x18\) 또는 기본 키 바인딩 서명\(유형 0x19\)은 기본 키와 동일한 형식을 사용하여 하위 키를 해시합니다. 키\(첫 번째 옥텟으로 0x99 사용\) 키 해지 서명\(유형 0x20 및 0x28\)은 해지되는 키만 해시합니다.

인증 서명\(유형 0x10\~0x13\)은 키에 바인딩되는 사용자 ID를 위 데이터 뒤의 해시 컨텍스트로 해시합니다. V3 인증은 헤더 없이 사용자 ID 또는 속성 패킷 패킷의 내용을 해시합니다. V4 인증은 사용자 ID 인증의 경우 상수 0xB4, 사용자 속성 인증의 경우 상수 0xD1, 사용자 ID 또는 사용자 속성 데이터의 길이를 제공하는 4옥텟 숫자, 사용자 ID 또는 사용자 속성 데이터를 해시합니다.

서명 패킷\(유형 0x50\)을 통해 서명이 작성되면 해시 데이터는 옥텟 0x88로 시작하고 그 뒤에 서명의 4옥텟 길이, 서명 패킷의 본문이 옵니다. \(길이 길이가 0으로 설정된 서명 패킷에 대한 구식 패킷 헤더입니다.\) 해시되는 서명 패킷의 해시되지 않은 하위 패킷 데이터는 해시에 포함되지 않으며, 해시되지 않은 하위 패킷 데이터 길이 값은 0으로 설정됩니다.

데이터 본문이 해시되면 트레일러도 해시됩니다. V3 서명은 서명 유형 필드에서 시작하여 패킷 본문의 5옥텟을 해시합니다. 이 데이터는 서명 유형이며 그 뒤에 4옥텟 서명 시간이 옵니다. V4 서명은 패킷 본문을 해시합니다.

첫 번째 필드인 버전 번호부터 시작하여 해시된 하위 패킷 데이터의 끝까지. 따라서 해시된 필드는 서명 버전, 서명 유형, 공개 키 알고리즘, 해시 알고리즘, 해시된 하위 패킷 길이 및 해시된 하위 패킷 본문입니다.

V4 서명은 또한 6옥텟의 최종 트레일러에 해시됩니다. 서명 패킷의 버전\(예: 0x04\); 0xFF; 서명 패킷의 해시된 데이터 길이인 4옥텟, 빅 엔디안 숫자\(이 숫자에는 마지막 6옥텟이 포함되지 않음\).

이 모든 것이 단일 해시 컨텍스트에서 해시된 후 결과 해시 필드가 서명 알고리즘에 사용되고 서명 패킷의 끝에 배치됩니다.

---
##### **5.2.4.1.  Subpacket Hints**

서명의 하위 패킷에 충돌하는 정보가 포함될 가능성이 있습니다. 예를 들어, 서명에는 기본 설정의 여러 복사본이나 여러 만료 시간이 포함될 수 있습니다. 대부분의 경우 구현은 서명의 마지막 하위 패킷을 사용해야 하지만 더 합리적인 충돌 해결 체계를 사용할 수 있습니다. 우리는 의도적으로 충돌 해결을 구현자에게 맡깁니다. 대부분의 충돌은 단순히 구문 오류이며, 여기에서 촌스러운 언어는 수신자가 수용하는 것에 관대하도록 허용하는 반면, 생성자는 생성하는 것에 인색하도록 압력을 가합니다.\(SHOULD\)

일부 명백한 충돌은 실제로 의미가 있을 수 있습니다. 예를 들어 키홀더에 동일한 RSA 키 자료를 공유하는 V3 키와 V4 키가 있다고 가정해 보겠습니다. 이러한 키 중 하나는 다른 키가 생성한 서명을 확인할 수 있으며 해당 키를 서명에 명시적으로 연결하는 방법으로 서명에 각 키에 대한 발급자 하위 패킷을 포함하는 것이 합리적일 수 있습니다.

---
### **5.3.  Symmetric-Key Encrypted Session Key Packets (Tag 3)**

대칭 키 암호화 세션 키 패킷은 메시지를 암호화하는 데 사용되는 세션 키의 대칭 키 암호화를 보유합니다. 0개 이상의 공개 키 암호화 세션 키 패킷 및/또는 대칭 키 암호화 세션 키 패킷이 암호화된 메시지를 보유하는 대칭 암호화 데이터 패킷 앞에 올 수 있습니다. 메시지는 세션 키로 암호화되며, 세션 키 자체가 암호화되어 암호화 세션 키 패킷 또는 대칭 키 암호화 세션 키 패킷에 저장됩니다.

대칭 암호화 데이터 패킷 앞에 하나 이상의 대칭 키 암호화 세션 키 패킷이 오는 경우 각 패킷은 메시지를 해독하는 데 사용할 수 있는 암호를 지정합니다. 이를 통해 메시지를 여러 공개 키와 하나 이상의 암호로 암호화할 수 있습니다. 이 패킷 유형은 새로운 패킷 유형이며 PGP 2.x 또는 PGP 5.0에서 생성되지 않습니다.

이 패킷의 본문은 다음으로 구성됩니다.

- 1옥텟 버전 번호. 현재 정의된 유일한 버전은 4입니다.

- 사용된 대칭 알고리즘을 설명하는 1옥텟 숫자입니다.

- 위에 정의된 길이의 문자열-키\(S2K\) 지정자입니다.

- 선택적으로 암호화된 세션 키 자체가 문자열-키 개체로 해독됩니다.

암호화된 세션 키가 없는 경우\(패킷 길이 및 S2K 지정자 크기를 기준으로 감지할 수 있음\) 암호 문구에 적용된 S2K 알고리즘은 대칭 암호화 알고리즘을 사용하여 파일 암호 해독을 위한 세션 키를 생성합니다. -키 암호화 세션 키 패킷.

암호화된 세션 키가 있는 경우 암호 문구에 S2K 알고리즘을 적용한 결과는 IV가 모두 0인 CFB 모드를 사용하여 암호화된 세션 키 필드만 해독하는 데 사용됩니다. 암호 해독 결과는 다음 대칭 암호화 데이터 패킷을 암호화하는 데 사용되는 대칭 키 암호화 알고리즘을 지정하는 1옥텟 알고리즘 식별자와 세션 키 옥텟 자체로 구성됩니다.

참고: 이 암호 해독에는 모두 0인 IV가 사용되기 때문에 S2K 지정자는 솔트 값\(Salted S2K 또는 Iterated-Salted S2K\)을 사용해야 합니다. 솔트 값은 암호가 재사용되더라도 암호 해독 키가 반복되지 않도록 보장합니다.\(MUST\)

---
### **5.4.  One-Pass Signature Packets (Tag 4)**

원패스 서명 패킷은 서명된 데이터보다 앞서며 수신자가 서명을 확인하는 데 필요한 해시 계산을 시작할 수 있도록 충분한 정보를 포함합니다. 이를 통해 서명 패킷을 메시지 끝에 배치할 수 있으므로 서명자는 한 번에 서명된 전체 메시지를 계산할 수 있습니다.

원패스 서명은 PGP 2.6.x 이하 버전과 상호 운용되지 않습니다.

이 패킷의 본문은 다음으로 구성됩니다.

- 1옥텟 버전 번호. 현재 버전은 3입니다.

- 1옥텟 서명 유형. 서명 유형은 섹션 5.2.1에 설명되어 있습니다.

- 사용된 해시 알고리즘을 설명하는 1옥텟 숫자입니다.

- 사용된 공개 키 알고리즘을 설명하는 1옥텟 숫자입니다.

- 서명 키의 키 ID를 포함하는 8옥텟 숫자입니다.

- 서명이 중첩되었는지 여부를 나타내는 플래그를 포함하는 1옥텟 숫자입니다. 0 값은 다음 패킷이 동일한 메시지 데이터에 적용될 다른 서명을 설명하는 또 다른 원패스 서명 패킷임을 나타냅니다.

메시지에 1회 통과 서명이 두 개 이상 포함되어 있으면 서명 패킷이 메시지를 괄호로 묶습니다. 즉, 메시지 뒤의 첫 번째 서명 패킷은 마지막 1패스 패킷에 해당하고 마지막 서명 패킷은 첫 번째 1패스 패킷에 해당합니다.

---
### **5.5.  Key Material Packet**

키 자료 패킷에는 공개 키 또는 개인 키에 대한 모든 정보가 포함되어 있습니다. 이 패킷 유형에는 네 가지 변형과 두 가지 주요 버전이 있습니다. 결과적으로 이 섹션은 복잡합니다.

---
#### **5.5.1.  Key Packet Variants**
---
##### **5.5.1.1.  Public-Key Packet (Tag 6)**

공개 키 패킷은 OpenPGP 키\(OpenPGP 인증서라고도 함\)를 형성하는 일련의 패킷을 시작합니다.

---
##### **5.5.1.2.  Public-Subkey Packet (Tag 14)**

공개 하위 키 패킷\(태그 14\)은 공개 키 패킷과 정확히 동일한 형식을 갖지만 하위 키를 나타냅니다. 하나 이상의 하위 키가 최상위 키와 연결될 수 있습니다. 규칙에 따라 최상위 키는 서명 서비스를 제공하고 하위 키는 암호화 서비스를 제공합니다.

참고: PGP 2.6.x에서 태그 14는 주석 패킷을 나타내기 위한 것입니다. 이전 버전의 PGP에서는 주석 패킷을 내보낸 적이 없지만 적절하게 무시했기 때문에 이 태그를 재사용하기 위해 선택했습니다.

그들을. 공개 하위 키 패킷은 PGP 2.6.x에서 무시되며 실패를 유발하지 않으므로 제한된 수준의 이전 버전과의 호환성을 제공합니다.

---
##### **5.5.1.3.  Secret-Key Packet (Tag 5)**

비밀 키 패킷에는 공개 키 자료를 포함하여 공개 키 패킷에 있는 모든 정보가 포함되어 있지만 모든 공개 키 필드 다음에는 비밀 키 자료도 포함되어 있습니다.

---
##### **5.5.1.4.  Secret-Subkey Packet (Tag 7)**

비밀-하위 키 패킷\(태그 7\)은 비밀 키 패킷의 하위 키 아날로그이며 정확히 동일한 형식을 갖습니다.

---
#### **5.5.2.  Public-Key Packet Formats**

키 자료 패킷에는 두 가지 버전이 있습니다. 버전 3 패킷은 PGP 2.6에서 처음 생성되었습니다. 버전 4 키는 PGP 5.0에 처음 등장했으며 OpenPGP에서 선호하는 키 버전입니다.

OpenPGP 구현은 버전 4 형식으로 키를 생성해야 합니다. V3 키는 더 이상 사용되지 않습니다. 구현은 V3 키를 생성해서는 안 되지만 이를 수락할 수도 있습니다.\(MUST, MUST NOT\)

버전 3 공개 키 또는 공개 하위 키 패킷에는 다음이 포함됩니다.

- 1옥텟 버전 번호\(3\).

- 키가 생성된 시간을 나타내는 4옥텟 숫자입니다.

- 이 키가 유효한 시간\(일\)을 나타내는 2옥텟 숫자입니다. 이 숫자가 0이면 만료되지 않습니다.

- 이 키의 공개 키 알고리즘을 나타내는 1옥텟 숫자입니다.

- 키 자료를 구성하는 일련의 다중 정밀도 정수:

```text
           - a multiprecision integer (MPI) of RSA public modulus n;
```

- - RSA 공개 암호화 지수의 MPI e.

V3 키는 더 이상 사용되지 않습니다. 여기에는 세 가지 약점이 있습니다. 첫째, 키 ID가 단순히 공개 모듈러스의 낮은 64비트이기 때문에 다른 키와 동일한 키 ID를 가진 V3 키를 구성하는 것이 상대적으로 쉽습니다. 둘째, V3 키의 지문은 키 자료를 해시하지만 길이는 해시하지 않기 때문에 지문 충돌 가능성이 높아집니다. 셋째, MD5에는 약점이 있습니다.

개발자가 다른 알고리즘을 선호하게 만드는 해시 알고리즘. 키 ID 및 지문에 대한 자세한 내용은 아래를 참조하세요.

V2 키는 버전 번호를 제외하고 더 이상 사용되지 않는 V3 키와 동일합니다. 구현은 이를 생성해서는 안 되며 적절하다고 판단되는 대로 이를 수락하거나 거부할 수 있습니다.\(MUST NOT\)

버전 4 형식은 유효 기간이 없다는 점을 제외하면 버전 3 형식과 유사합니다. 이는 서명 패킷으로 이동되었습니다. 또한 버전 4 키의 지문은 "향상된 키 형식" 섹션에 설명된 대로 버전 3 키와 다르게 계산됩니다.

버전 4 패킷에는 다음이 포함됩니다.

- 1옥텟 버전 번호\(4\).

- 키가 생성된 시간을 나타내는 4옥텟 숫자입니다.

- 이 키의 공개 키 알고리즘을 나타내는 1옥텟 숫자입니다.

- 키 자료를 구성하는 일련의 다중 정밀도 정수입니다. 이 알고리즘 관련 부분은 다음과 같습니다.

- RSA 공개 키에 대한 알고리즘 관련 필드:

```text
         - multiprecision integer (MPI) of RSA public modulus n;
```

- - RSA 공개 암호화 지수의 MPI e.

- DSA 공개 키에 대한 알고리즘 관련 필드:

```text
         - MPI of DSA prime p;

         - MPI of DSA group order q (q is a prime divisor of p-1);

         - MPI of DSA group generator g;
```

- DSA 공개 키 값 y의 MPI\(= g\*\*x mod p 여기서 x

-비밀입니다\).

- Elgamal 공개 키에 대한 알고리즘별 필드:

```text
         - MPI of Elgamal prime p;

         - MPI of Elgamal group generator g;
```

- - Elgamal 공개 키 값 y의 MPI\(= g\*\*x mod p, 여기서 x는 비밀임\).

---
#### **5.5.3.  Secret-Key Packet Formats**

비밀 키 및 비밀 하위 키 패킷에는 일반적으로 암호화된 형식으로 추가된 알고리즘별 비밀 키 데이터와 함께 공개 키 및 공개 하위 키 패킷의 모든 데이터가 포함됩니다.

패킷에는 다음이 포함됩니다.

- 위에서 설명한 공개 키 또는 공개 하위 키 패킷.

- 문자열-키 사용 규칙을 나타내는 1옥텟. 0은 비밀 키 데이터가 암호화되지 않았음을 나타냅니다. 255 또는 254는 문자열-키 지정자가 제공되고 있음을 나타냅니다. 다른 값은 대칭 키 암호화 알고리즘 식별자입니다.

- \[선택 사항\] 문자열-키 사용 옥텟이 255 또는 254인 경우 1옥텟 대칭 암호화 알고리즘입니다.

- \[선택 사항\] 문자열-키 사용 옥텟이 255 또는 254인 경우 문자열-키 지정자입니다. 위에서 설명한 대로 문자열-키 지정자의 길이는 해당 유형에 따라 결정됩니다.

- \[선택 사항\] 비밀 데이터가 암호화된 경우\(문자열-키 사용 옥텟은 0이 아님\) 암호의 블록 크기와 동일한 길이의 초기 벡터\(IV\)입니다.

- 비밀 키 데이터를 구성하는 일반 또는 암호화된 다중 정밀도 정수. 이러한 알고리즘별 필드는 아래에 설명되어 있습니다.

- 문자열-키 사용 옥텟이 0 또는 255인 경우 알고리즘 특정 부분의 일반 텍스트에 대한 2옥텟 체크섬\(모든 옥텟의 합계, 모드 65536\). 문자열-키 사용 옥텟이 254인 경우 알고리즘 특정 부분의 일반 텍스트에 대한 20옥텟 SHA-1 해시입니다. 이 체크섬 또는 해시는 알고리즘별 필드와 함께 암호화됩니다\(문자열-키 사용 옥텟이 0이 아닌 경우\). 다른 모든 값의 경우 2옥텟 체크섬이 필요합니다.

- RSA 비밀 키에 대한 알고리즘별 필드:

- - RSA 비밀 지수의 다중 정밀도 정수\(MPI\) d.

- - RSA 비밀 소수 값의 MPI p.

- - RSA 비밀 소수 값 q의 MPI\(p < q\).

- - u의 MPI, p의 곱셈의 역수, mod q.

- DSA 비밀 키에 대한 알고리즘별 필드:

- - DSA 비밀 지수 x의 MPI.

- Elgamal 비밀 키에 대한 알고리즘별 필드:

- - Elgamal 비밀 지수 x의 MPI.

비밀 MPI 값은 암호를 사용하여 암호화할 수 있습니다. 문자열-키 지정자가 제공되면 이는 암호를 키로 변환하는 알고리즘을 설명하고, 그렇지 않으면 암호의 간단한 MD5 해시가 사용됩니다. 구현에서는 문자열-키 지정자를 사용해야 합니다. 단순 해시는 이전 버전과의 호환성을 위한 것이므로 더 이상 사용되지 않지만 구현에서는 이전 형식의 기존 개인 키를 계속 사용할 수 있습니다. MPI 암호화를 위한 암호는 Secret-Key 패킷에 지정됩니다.\(MUST\)

비밀 데이터의 암호화/복호화는 암호 문구에서 생성된 키와 패킷의 초기 벡터를 사용하여 CFB 모드에서 수행됩니다. V3 키\(RSA만 해당\)에는 다른 키 형식과 다른 모드가 사용됩니다. V3 키를 사용하면 MPI 비트 수 접두사\(즉, 처음 두 옥텟\)가 암호화되지 않습니다. MPI 비접두사 데이터만 암호화됩니다. 또한 CFB 상태는 새로운 MPI 값이 시작될 때마다 재동기화되어 CFB 블록 경계가 MPI 데이터의 시작 부분과 정렬됩니다.

V4 키를 사용하면 더 간단한 방법이 사용됩니다. MPI 비트카운트 접두사를 포함하여 모든 비밀 MPI 값은 CFB 모드에서 암호화됩니다.

알고리즘별 부분 뒤에 오는 2옥텟 체크섬은 모든 알고리즘별 옥텟\(MPI 접두사 및 데이터 포함\)의 일반 텍스트에 대한 대수적 합계\(mod 65536\)입니다. V3 키를 사용하면 체크섬이 일반 형식으로 저장됩니다. V4 키를 사용하면 체크섬이 알고리즘별 데이터처럼 암호화됩니다. 이 값은 암호가 올바른지 확인하는 데 사용됩니다. 그러나 이 체크섬은 더 이상 사용되지 않습니다. 구현에서는 이를 사용해서는 안 되며, 사용 옥텟 254로 표시된 SHA-1 해시를 사용해야 합니다. 그 이유는 비밀 키를 감지할 수 없게 수정하는 것과 관련된 일부 공격이 있기 때문입니다.\(SHOULD NOT\)

---
### **5.6.  Compressed Data Packet (Tag 8)**

압축 데이터 패킷에는 압축된 데이터가 포함되어 있습니다. 일반적으로 이 패킷은 암호화된 패킷의 내용으로 발견되거나 서명 또는 원패스 서명 패킷 다음에 발견되며 리터럴 데이터 패킷을 포함합니다.

이 패킷의 본문은 다음으로 구성됩니다.

- 패킷을 압축하는 데 사용되는 알고리즘을 제공하는 1옥텟.

- 패킷의 나머지 부분을 구성하는 압축된 데이터입니다.

압축된 데이터 패킷의 본문에는 일부 패킷 세트를 압축하는 블록이 포함되어 있습니다. 메시지 구성 방법에 대한 자세한 내용은 "패킷 구성" 섹션을 참조하세요.

ZIP 압축 패킷은 원시 RFC 1951 \[RFC1951\] DEFLATE 블록으로 압축됩니다. PGP V2.6은 13비트 압축을 사용합니다. 구현에서 더 많은 압축 비트를 사용하는 경우 PGP V2.6은 압축을 풀 수 없습니다.

ZLIB 압축 패킷은 RFC 1950 \[RFC1950\] ZLIB 스타일 블록으로 압축됩니다.

BZip2 압축 패킷은 BZip2 \[BZ2\] 알고리즘을 사용하여 압축됩니다.

---
### **5.7.  Symmetrically Encrypted Data Packet (Tag 9)**

대칭 암호화 데이터 패킷에는 대칭 키 알고리즘으로 암호화된 데이터가 포함되어 있습니다. 암호가 해독되면 다른 패킷\(일반적으로 문자 그대로의 데이터 패킷 또는 압축된 데이터 패킷이지만 이론적으로는 다른 대칭 암호화 데이터 패킷 또는 전체 OpenPGP 메시지를 구성하는 패킷 시퀀스\)이 포함됩니다.

이 패킷의 본문은 다음으로 구성됩니다.

- 암호화된 데이터, OpenPGP의 CFB\(Cipher Feedback\) 모드 변형에서 작동하는 선택된 대칭 키 암호의 출력입니다.

사용되는 대칭 암호는 대칭 암호화 데이터 패킷 앞에 오는 공개 키 또는 대칭 키 암호화 세션 키 패킷에 지정될 수 있습니다. 이 경우 암호화 알고리즘 옥텟은 암호화되기 전에 세션 키 앞에 붙습니다. 암호화된 데이터 앞에 이러한 유형의 패킷이 없으면 암호 문구의 MD5 해시로 계산된 세션 키와 함께 IDEA 알고리즘이 사용되지만 이 사용은 더 이상 사용되지 않습니다.

데이터는 CFB 모드에서 암호화되며, CFB 이동 크기는 암호의 블록 크기와 동일합니다. 초기 벡터\(IV\)는 모두 0으로 지정됩니다. IV를 사용하는 대신 OpenPGP는 암호화되기 전에 데이터에 암호의 블록 크기에 2를 더한 길이의 문자열을 접두사로 붙입니다. 첫 번째 블록 크기 옥텟\(예: 64비트 블록 길이의 경우 8옥텟\)은 무작위이며 다음 두 옥텟은 IV의 마지막 두 옥텟의 복사본입니다. 예를 들어, 8옥텟 블록에서 옥텟 9는 옥텟 7의 반복이고 옥텟 10은 옥텟 8의 반복입니다. 길이가 16인 암호에서 옥텟 17은 옥텟 15의 반복이고 옥텟 18은 반복입니다. 현학적 설명으로서, 이 두 예 모두에서 첫 번째 옥텟의 번호가 1로 간주됩니다.

첫 번째 블록 크기와 2옥텟을 암호화한 후 CFB 상태가 다시 동기화됩니다. 암호문의 마지막 블록 크기 옥텟이 암호를 통과하고 블록 경계가 재설정됩니다.

메시지 앞에 붙은 무작위 데이터의 16비트 반복을 통해 수신자는 세션 키가 잘못된지 즉시 확인할 수 있습니다. 이 "빠른 확인"의 올바른 사용에 대한 힌트는 "보안 고려 사항" 섹션을 참조하세요.

---
### **5.8.  Marker Packet (Obsolete Literal Packet) (Tag 10)**

PGP의 실험 버전은 이 패킷을 리터럴 패킷으로 사용했지만, 출시된 PGP 버전에서는 이 태그가 있는 리터럴 패킷을 생성하지 않았습니다. PGP 5.x에서는 이 패킷이 재할당되어 마커 패킷으로 사용하도록 예약되었습니다.

이 패킷의 본문은 다음으로 구성됩니다.

- 3개의 옥텟 0x50, 0x47, 0x50\(UTF-8에서는 "PGP"로 표기\).

이러한 패킷은 수신 시 무시되어야 합니다. PGP 2.6.x에서 사용할 수 없는 기능을 사용하는 메시지의 시작 부분에 배치하면 해당 버전에서 메시지를 처리하는 데 최신 소프트웨어가 필요하다고 보고할 수 있습니다.\(MUST\)

---
### **5.9.  Literal Data Packet (Tag 11)**

리터럴 데이터 패킷에는 메시지 본문이 포함됩니다. 더 이상 해석할 수 없는 데이터입니다.

이 패킷의 본문은 다음으로 구성됩니다.

- 데이터 형식을 설명하는 1옥텟 필드입니다.

'b'\(0x62\)인 경우 리터럴 패킷에는 이진 데이터가 포함됩니다. 't'\(0x74\)인 경우 텍스트 데이터가 포함되어 있으므로 줄 끝을 로컬 형식으로 변환하거나 기타 텍스트 모드를 변경해야 할 수 있습니다. 태그 'u'\(0x75\)는 't'와 동일한 의미이지만 구현 시 리터럴 데이터에 UTF-8 텍스트가 포함되어 있다고 믿는 것을 나타냅니다.

PGP의 초기 버전에서는 'l' 값을 머신-로컬 변환을 위한 '로컬' 모드로 정의했습니다. RFC 1991 \[RFC1991\]에서는 이 로컬 모드 플래그를 '1'\(ASCII 숫자 1\)로 잘못 명시했습니다. 이러한 로컬 모드는 모두 더 이상 사용되지 않습니다.

- 문자열 형식의 파일 이름\(1옥텟 길이 뒤에 파일 이름이 옴\). 길이가 0인 문자열일 수 있습니다. 일반적으로 암호화된 데이터의 원본이 파일인 경우 암호화된 파일의 이름이 됩니다. 구현에서는 리터럴 패킷의 파일 이름을 실제 파일 이름보다 더 권위 있는 이름으로 간주할 수 있습니다.\(MAY\)

특수 이름 "\_CONSOLE"을 사용하면 메시지는 "눈에만 보이는" 것으로 간주됩니다. 이는 메시지 데이터가 비정상적으로 민감하므로 수신 프로그램이 수신된 데이터를 디스크에 저장하는 것을 피하는 등 보다 주의 깊게 처리해야 함을 나타냅니다.

- 리터럴 데이터와 관련된 날짜를 나타내는 4옥텟 숫자입니다. 일반적으로 날짜는 파일 수정 날짜, 패킷이 생성된 시간 또는 특정 시간이 없음을 나타내는 0일 수 있습니다.

- 패킷의 나머지 부분은 리터럴 데이터입니다.

- 텍스트 데이터는 <CR\><LF\> 텍스트 끝\(예: 네트워크 일반 줄 끝\)으로 저장됩니다. 이는 수신 소프트웨어에 의해 기본 줄 끝으로 변환되어야 합니다.

---
### **5.10.  Trust Packet (Tag 12)**

신뢰 패킷은 키링 내에서만 사용되며 일반적으로 내보내지지 않습니다. 신뢰 패킷에는 키 보유자가 신뢰할 수 있는 소개자인 사용자의 사양을 기록하는 데이터와 함께 구현 소프트웨어가 신뢰 정보에 사용하는 기타 정보가 포함되어 있습니다. 신뢰 패킷의 형식은 지정된 구현에 의해 정의됩니다.

신뢰 패킷은 다른 사용자에게 전송되는 출력 스트림으로 방출되어서는 안 되며, 로컬 키링 파일 이외의 입력에서는 무시되어야 합니다.\(SHOULD NOT\)

---
### **5.11.  User ID Packet (Tag 13)**

사용자 ID 패킷은 키 소유자의 이름과 이메일 주소를 나타내기 위한 UTF-8 텍스트로 구성됩니다. 관례적으로 RFC 2822 \[RFC2822\] 메일 이름 주소를 포함하지만 내용에는 제한이 없습니다. 헤더의 패킷 길이는 사용자 ID의 길이를 지정합니다.

---
### **5.12.  User Attribute Packet (Tag 17)**

사용자 속성 패킷은 사용자 ID 패킷의 변형입니다. 텍스트로 제한되는 사용자 ID 패킷보다 더 많은 유형의 데이터를 저장할 수 있습니다. 사용자 ID 패킷과 마찬가지로 사용자 속성 패킷은 키 소유자\("자체 서명"\) 또는 이를 인증하려는 다른 키 소유자에 의해 인증될 수 있습니다. 명시된 경우를 제외하고 사용자 속성 패킷은 사용자 ID 패킷이 사용될 수 있는 모든 곳에서 사용될 수 있습니다.

사용자 속성 패킷은 OpenPGP 표준의 필수 부분은 아니지만 구현은 사용자 속성 패킷의 인증 서명을 적절하게 처리할 수 있을 만큼 최소한 충분한 호환성을 제공해야 합니다. 이를 수행하는 간단한 방법은 사용자 속성 패킷을 불투명한 내용이 있는 사용자 ID 패킷으로 처리하는 것이지만 구현에서는 원하는 모든 방법을 사용할 수 있습니다.\(SHOULD\)

사용자 속성 패킷은 하나 이상의 속성 하위 패킷으로 구성됩니다. 각 하위 패킷은 하위 패킷 헤더와 본문으로 구성됩니다. 헤더는 다음으로 구성됩니다.

```text
     - the subpacket length (1, 2, or 5 octets)

     - the subpacket type (1 octet)
```

그 뒤에는 서브패킷 특정 데이터가 옵니다.

현재 정의된 유일한 하위 패킷 유형은 이미지를 나타내는 1입니다. 구현은 인식하지 못하는 유형의 하위 패킷을 모두 무시해야 합니다\(SHOULD\). 하위 패킷 유형 100\~110은 개인용 또는 실험용으로 예약되어 있습니다.\(SHOULD\)

---
#### **5.12.1.  The Image Attribute Subpacket**

이미지 속성 서브패킷은 키 소유자의 이미지\(필수는 아니지만\)를 인코딩하는 데 사용됩니다.

이미지 속성 서브패킷은 이미지 헤더로 시작됩니다. 이미지 헤더의 처음 두 옥텟에는 이미지 헤더의 길이가 포함됩니다. 이 문서의 다른 다중 옥텟 숫자 값과 달리 역사적 사고로 인해 이 값은 다음과 같이 인코딩됩니다.

리틀 엔디안 수. 이미지 헤더 길이 뒤에는 이미지 헤더 버전에 대한 단일 옥텟이 옵니다. 현재 정의된 이미지 헤더의 유일한 버전은 16옥텟 이미지 헤더인 1입니다. 따라서 버전 1 이미지 헤더의 처음 3개 옥텟은 0x10, 0x00, 0x01입니다.

버전 1 이미지 헤더의 네 번째 옥텟은 이미지의 인코딩 형식을 지정합니다. 현재 정의된 유일한 인코딩 형식은 JPEG를 나타내는 값 1입니다. 이미지 형식 유형 100\~110은 개인용 또는 실험용으로 예약되어 있습니다. 버전 1 이미지 헤더의 나머지 부분은 12개의 예약된 옥텟으로 구성되며 모두 0으로 설정되어야 합니다.\(MUST\)

이미지 하위 패킷의 나머지 부분에는 이미지 자체가 포함됩니다. 현재 정의된 유일한 이미지 유형은 JPEG이므로 이미지는 JPEG 이미지의 표준 파일 형식인 JFIF\(JPEG File Interchange Format\)로 인코딩됩니다.

구현은 특정 버전의 이미지 헤더를 처리할 수 없거나 지정된 인코딩 형식 값이 인식되지 않는 경우 이미지 데이터를 검사하여 이미지 유형을 결정하려고 시도할 수 있습니다.\(MAY\)

---
### **5.13.  Sym. Encrypted Integrity Protected Data Packet (Tag 18)**

대칭적으로 암호화된 무결성 보호 데이터 패킷은 대칭적으로 암호화된 데이터 패킷의 변형입니다. 이는 암호화된 데이터의 수정을 감지하는 문제를 해결하는 OpenPGP용으로 만들어진 새로운 기능입니다. 수정 감지 코드 패킷과 함께 사용됩니다.

기능 서명 서브패킷에는 구현이 이 패킷 유형을 적절하게 사용할 수 있음을 나타내는 해당 기능이 있습니다. 구현은 이러한 패킷의 암호 해독을 지원해야 하며\(MUST\) 가능하면 이전 대칭 암호화 데이터 패킷보다 생성하는 것을 선호해야 합니다\(SHOULD\). 이 데이터 패킷은 수정 공격으로부터 보호하므로 이 표준은 확산을 장려합니다. 이 데이터 패킷을 전면적으로 채택하면 상호 운용성 문제가 발생하지만 그럼에도 불구하고 신속한 채택이 중요합니다. 구현은 이 패킷에 대한 지원을 구체적으로 나타내야 하지만 다른 메커니즘에서 이를 추론할 수도 있습니다.\(MUST, SHOULD\)

예를 들어 구현 시 AES\(Advanced Encryption Standard\) 또는 Twofish와 같은 암호 사용을 통해 사용자가 이 기능을 지원한다고 추론할 수 있습니다. 이는 다른 사용자 키 서명의 해시되지 않은 부분에 기능 하위 패킷을 배치할 수 있습니다. 또한 사용자에게 기능 하위 패킷을 사용하여 자신의 자체 서명을 다시 생성할 수 있는 기회를 제공할 수도 있습니다.

이 패킷에는 대칭 키 알고리즘으로 암호화되고 SHA-1 해시 알고리즘에 의한 수정으로부터 보호되는 데이터가 포함되어 있습니다. 암호가 해독되면 일반적으로 다른 패킷\(종종 리터럴 데이터 패킷 또는 압축 데이터 패킷\)이 포함됩니다. 이 패킷의 페이로드에서 마지막으로 해독된 패킷은 수정 감지 코드 패킷이어야 합니다.\(MUST\)

이 패킷의 본문은 다음으로 구성됩니다.

- 1옥텟 버전 번호. 현재 정의된 유일한 값은 1입니다.

- 암호화된 데이터, 암호의 블록 크기\(CFB-n, 여기서 n은 블록 크기\)와 동일한 이동량을 사용하여 암호 피드백 모드에서 작동하는 선택된 대칭 키 암호의 출력입니다.

사용되는 대칭 암호는 대칭 암호화 데이터 패킷 앞에 오는 공개 키 또는 대칭 키 암호화 세션 키 패킷에 지정되어야 합니다. 두 경우 모두 암호화 알고리즘 옥텟은 암호화되기 전에 세션 키 앞에 붙습니다.\(MUST\)

데이터는 CFB 모드에서 암호화되며, CFB 이동 크기는 암호의 블록 크기와 동일합니다. 초기 벡터\(IV\)는 모두 0으로 지정됩니다. IV를 사용하는 대신 OpenPGP는 데이터가 암호화되기 전에 데이터에 옥텟 문자열 접두사를 붙입니다. 옥텟 문자열의 길이는 옥텟 단위의 암호 블록 크기에 2를 더한 것과 같습니다. 그룹의 첫 번째 옥텟은 길이가 암호의 블록 크기와 같으며 무작위입니다. 마지막 두 옥텟은 각각 두 번째 이전 옥텟의 복사본입니다. 예를 들어, 블록 크기가 128비트 또는 16옥텟인 암호의 경우 접두사 데이터에는 16개의 임의 옥텟이 포함되고, 그 다음에는 각각 15번째 및 16번째 옥텟의 복사본인 2개의 옥텟이 추가됩니다. 대칭 암호화 데이터 패킷과 달리 이 접두사 데이터를 암호화한 후에는 특별한 CFB 재동기화가 수행되지 않습니다. 자세한 내용은 아래 "OpenPGP CFB 모드"를 참조하세요.

메시지 앞에 붙은 무작위 데이터의 16비트 반복을 통해 수신자는 세션 키가 잘못된지 즉시 확인할 수 있습니다.

암호화할 데이터의 평문은 SHA-1 해시 함수를 통해 전달되며, 해시 결과는 수정 감지 코드 패킷의 평문에 추가됩니다. 해시 함수에 대한 입력에는 위에서 설명한 접두사 데이터가 포함됩니다. 여기에는 모든 일반 텍스트가 포함되고 0xD3, 0x14 값의 두 옥텟도 포함됩니다. 이는 수정 감지 코드 패킷 태그의 인코딩과 20옥텟의 길이 필드를 나타냅니다.

결과 해시 값은 수정 감지 코드\(MDC\) 패킷에 저장되며, 태그와 길이 필드를 나타내기 위해 방금 제공된 두 옥텟 인코딩을 사용해야 합니다. MDC 패킷의 본문은 SHA-1 해시의 20옥텟 출력입니다.\(MUST\)

수정 감지 코드 패킷은 일반 텍스트에 추가되고 동일한 CFB 컨텍스트를 사용하여 일반 텍스트와 함께 암호화됩니다.

암호 해독 중에 수정 감지 코드 패킷의 접두사 데이터와 패킷 태그 및 길이 필드를 포함하여 일반 텍스트 데이터가 SHA-1로 해시되어야 합니다. 해독 시 MDC 패킷의 본문은 SHA-1 해시의 결과와 비교됩니다.

MDC의 모든 실패는 메시지가 수정되었으며 보안 문제로 처리되어야 함을 나타냅니다. 실패에는 해시 값의 차이가 포함되지만 MDC 패킷이 없거나 일반 텍스트 끝 이외의 위치에 MDC 패킷이 있는 경우도 포함됩니다. 모든 실패는 사용자에게 보고되어야 합니다.\(MUST, SHOULD\)

참고: 이 패킷의 새 버전에 대한 향후 설계에서는 공격자가 버전을 다시 1로 변경할 수 있으므로 롤백 공격을 고려해야 합니다.

```text
      NON-NORMATIVE EXPLANATION
```

- 패킷 18과 19라고 불리는 MDC 시스템은 서명보다 덜 강력하지만 순수 CFB 암호화보다 강력한 무결성 메커니즘을 제공하기 위해 만들어졌습니다.

- 암호문이 손상되면 영향을 받는 암호 블록과 그에 따르는 블록도 손상된다는 것은 CFB 암호화의 한계입니다. 또한 CFB로 암호화된 블록의 끝에서 데이터가 제거되면 해당 제거를 감지할 수 없습니다. \(CBC 모드에도 비슷한 제한이 있지만 블록 앞쪽에서 제거된 데이터는 감지할 수 없습니다.\)

- 암호화된 블록을 보호하거나 인증하는 확실한 방법은 디지털 서명을 하는 것입니다. 그러나 많은 사람들은 이 문서의 범위를 벗어나는 여러 가지 이유로 습관적으로 데이터에 서명하는 것을 원하지 않습니다. 많은 사람들이 부인성과 같은 속성을 무결성만큼 가치 있다고 생각한다고만 말하면 충분합니다.

- OpenPGP는 원시 암호화보다 더 많은 보안을 유지하면서도 MDC 시스템으로 거부성을 유지하려는 이러한 욕구를 해결합니다. MDC는 의도적으로 MAC이 아닙니다. 그 이름은 우연히 선택된 것이 아닙니다. 체크섬과 유사합니다.

- 상대적으로 소박한 시스템임에도 불구하고 현실 세계에서 그 성능이 입증되었습니다. 이는 생성된 이후 표면화된 여러 공격에 대한 효과적인 방어입니다. 그것은 적당한 목표를 훌륭하게 달성했습니다.

- 결과적으로, 이는 적당한 보안 시스템이기 때문에 사용하는 해시 함수에 대한 적당한 요구 사항을 갖습니다. 충돌이 없는 해시 함수에 의존하지 않고 단방향 해시 함수에 의존합니다. 위조자 Frank가 Alice에게 "나는 항상 비밀리에 당신을 사랑했습니다. Bob에게 서명했습니다."라는 서명되지 않은 메시지를 \(디지털로\) 보내고자 한다면 가로챈 내용을 수정하는 것보다 그가 새로운 메시지를 구성하는 것이 훨씬 쉽습니다. 밥에게서. \(또한 Bob이 Alice와 비밀리에 통신하려고 하지만 인증이나 식별 없이 위조자가 포함된 위협 모델을 사용하는 경우 단순한 암호화를 넘어서는 문제가 있다는 점에 유의하세요.\)

- 거의 모든 OpenPGP 하위 시스템과 달리 MDC 시스템에는 매개변수가 없습니다. SHA-1을 해시 함수로 하드 정의합니다. 이것은 사고가 아닙니다. 간단하고 빠른 시스템을 만들면서 다운그레이드 및 크로스그레이드 공격을 방지하려는 의도적인 선택입니다. \(예를 들어 다운그레이드 공격은 SHA-256을 SHA-1로 대체하는 공격입니다. 크로스그레이드 공격은 SHA-1을 RIPE-MD/160과 같은 다른 160비트 해시로 대체합니다.\)

- 그러나 현재의 해시 함수 암호해석 및 암호학 상태를 고려할 때 MDC 시스템을 새로운 해시 함수로 업그레이드하는 것이 바람직할 수 있습니다. 지침은 "IANA 고려 사항"의 섹션 13.11을 참조하세요.

---
### **5.14.  Modification Detection Code Packet (Tag 19)**

수정 감지 코드 패킷에는 메시지 수정을 감지하는 데 사용되는 일반 텍스트 데이터의 SHA-1 해시가 포함되어 있습니다. 대칭적으로 암호화된 무결성 보호 데이터 패킷에만 사용됩니다. 수정 감지 코드 패킷은 대칭적으로 암호화된 무결성 보호 데이터 패킷에서 암호화된 일반 텍스트 데이터의 마지막 패킷이어야 하며 다른 위치에는 나타나서는 안 됩니다.\(MUST\)

수정 감지 코드 패킷의 길이는 20옥텟이어야 합니다.\(MUST\)

이 패킷의 본문은 다음으로 구성됩니다.

- 수정 감지 코드 패킷의 접두사 데이터, 태그 옥텟 및 길이 옥텟을 포함하여 대칭적으로 암호화된 무결성 보호 데이터 패킷의 이전 일반 텍스트 데이터의 20옥텟 SHA-1 해시입니다.

수정 감지 코드 패킷은 항상 패킷 태그의 새로운 형식 인코딩과 패킷 길이의 1옥텟 인코딩을 사용해야 합니다. 그 이유는 수정 감지를 위한 해싱 규칙에 데이터 해시에 1옥텟 태그와 1옥텟 길이가 포함되기 때문입니다. 이는 약간 제한적이지만 복잡성을 줄여줍니다.\(MUST\)

---
## **6.  Radix-64 Conversions**

서문에서 언급했듯이 OpenPGP의 객체에 대한 기본 기본 표현은 임의의 옥텟의 스트림이며 일부 시스템에서는 이러한 객체가 문자 집합 변환, 데이터 변환 등으로 인한 손상으로부터 면역되기를 원합니다.

원칙적으로, 안전하지 않은 채널의 요구 사항을 충족하는 인쇄 가능한 인코딩 방식이면 충분합니다. 기본 OpenPGP 데이터 구조의 기본 바이너리 비트 스트림을 변경하지 않기 때문입니다. OpenPGP 표준은 상호 운용성을 보장하기 위해 인쇄 가능한 인코딩 체계 중 하나를 지정합니다.

OpenPGP의 Radix-64 인코딩은 바이너리 데이터의 base64 인코딩과 체크섬이라는 두 부분으로 구성됩니다. base64 인코딩은 MIME base64 콘텐츠 전송 인코딩 \[RFC2045\]과 동일합니다.

체크섬은 등호\(=\)가 앞에 오는 동일한 MIME base64 변환을 통해 4개의 기수-64 인코딩 문자로 변환된 24비트 CRC\(순환 중복 검사\)입니다. CRC는 생성기 0x864CFB와 초기화 0xB704CE를 사용하여 계산됩니다. 변환된 데이터가 아닌 64진수로 변환되기 전의 데이터에 대해 누적이 이루어집니다. 이 알고리즘의 샘플 구현은 다음 섹션에 있습니다.

선행 등호가 있는 체크섬은 base64로 인코딩된 데이터 뒤의 첫 번째 줄에 나타날 수 있습니다.\(MAY\)

CRC-24의 이론적 근거: 24비트 크기는 인쇄 가능한 base64에 균등하게 맞습니다. 0이 아닌 초기화는 0 초기화보다 더 많은 오류를 감지할 수 있습니다.

---
### **6.1.  An Implementation of the CRC-24 in "C"**

```text
      #define CRC24_INIT 0xB704CEL
      #define CRC24_POLY 0x1864CFBL

      typedef long crc24;
      crc24 crc_octets(unsigned char *octets, size_t len)
      {
          crc24 crc = CRC24_INIT;
          int i;
          while (len--) {
              crc ^= (*octets++) << 16;
              for (i = 0; i < 8; i++) {
                  crc <<= 1;
                  if (crc & 0x1000000)
                      crc ^= CRC24_POLY;
              }
          }
          return crc & 0xFFFFFFL;
      }
```

---
### **6.2.  Forming ASCII Armor**

OpenPGP가 데이터를 ASCII Armor로 인코딩할 때 Radix-64로 인코딩된 데이터 주위에 특정 헤더를 배치하므로 OpenPGP가 나중에 데이터를 재구성할 수 있습니다. OpenPGP 구현은 원시 바이너리 데이터를 보호하기 위해 ASCII 갑옷을 사용할 수 있습니다. OpenPGP는 헤더를 사용하여 ASCII Armor에 어떤 종류의 데이터가 인코딩되어 있는지 사용자에게 알려줍니다.\(MAY\)

다음 데이터를 연결하면 ASCII Armor가 생성됩니다.

- 데이터 유형에 적합한 Armor Header Line

```text
     - Armor Headers
```

- 공백\(길이가 0이거나 공백만 포함\) 행

- ASCII-Armored 데이터

- 방어구 체크섬

- Armor Header Line에 따라 달라지는 Armor Tail

Armor 헤더 라인은 헤더 라인 텍스트 양쪽에 5개의 대시\('-', 0x2D\)로 둘러싸인 적절한 헤더 라인 텍스트로 구성됩니다. 헤더 줄 텍스트는 Armor에서 인코딩되는 데이터 유형과 인코딩 방법에 따라 선택됩니다. 헤더 줄 텍스트에는 다음 문자열이 포함됩니다.

PGP 메시지 시작

- 서명, 암호화 또는 압축된 파일에 사용됩니다.

PGP 공개 키 블록 시작

- 공개 키를 보호하는 데 사용됩니다.

PGP 개인 키 블록 시작

- 개인 키를 보호하는 데 사용됩니다.

PGP 메시지 시작, 부분 X/Y

- 갑옷이 Y 부분으로 분할되는 다중 부분 메시지에 사용되며 이는 Y 부분 중 X번째 부분입니다.

PGP 메시지 시작, 파트 X

- 지정되지 않은 부분 수의 X번째 부분인 다중 부분 메시지에 사용됩니다. MESSAGE-ID Armor 헤더를 사용해야 합니다.

PGP 서명 시작

- 분리된 서명, OpenPGP/MIME 서명 및 일반 텍스트 서명에 사용됩니다. PGP 2.x는 분리된 서명에 BEGIN PGP MESSAGE를 사용합니다.

이러한 모든 방어구 헤더 라인은 완전한 라인으로 구성됩니다. 즉, 시작하는 5개의 대시 앞에는 항상 줄 끝이 있고, 끝나는 5개의 대시 뒤에는 줄 끝이 있습니다. 따라서 헤더 줄은 줄의 시작 부분에서 시작해야 하며, 같은 줄 뒤에 공백 이외의 텍스트가 있어서는 안 됩니다. 이러한 줄 끝은 구분하는 내용을 결정하기 위해 Armor Header Line의 일부로 간주됩니다. 이는 일반 텍스트 서명을 계산할 때 특히 중요합니다\(아래 참조\).\(MUST NOT\)

Armor 헤더는 사용자 또는 수신 OpenPGP 구현에 메시지를 디코딩하거나 사용하는 방법에 대한 정보를 제공할 수 있는 문자열 쌍입니다. Armor Header는 메시지의 일부가 아닌 Armor의 일부이므로 메시지에 적용된 서명으로 보호되지 않습니다.

Armor Header의 형식은 키-값 쌍의 형식입니다. 콜론\(':' 0x38\)과 단일 공백\(0x20\)으로 키와 값이 구분됩니다. OpenPGP는 부적절하게 형식화된 Armor 헤더를 ASCII Armor의 손상으로 간주해야 합니다. 알 수 없는 키는 사용자에게 보고되어야 하지만 OpenPGP는 계속해서 메시지를 처리해야 합니다.

일부 전송 방법은 라인 길이에 민감합니다. Radix-64 데이터\(섹션 6.3\)에는 76자 제한이 있지만 Armor Header의 길이에는 제한이 없습니다. 주의해야 할 점

Armor Header는 운송에 견딜 수 있을 만큼 충분히 짧습니다. 이를 수행하는 한 가지 방법은 한 줄이 지나치게 길지 않도록 각각 다른 값을 사용하여 Armor Header 키를 여러 번 반복하는 것입니다.

현재 정의된 Armor Header Key는 다음과 같습니다.

- 메시지를 인코딩하는 데 사용되는 OpenPGP 구현 및 버전을 나타내는 "버전".

- "Comment", 사용자 정의 설명입니다. OpenPGP는 모든 텍스트를 UTF-8로 정의합니다. 주석은 UTF-8 문자열일 수 있습니다. 그러나 아머링의 핵심은 7비트의 깨끗한 데이터를 제공하는 것입니다. 결과적으로, 주석에 UTF의 US-ASCII 범위를 벗어나는 문자가 있는 경우 해당 문자는 전송 후에도 유지되지 않을 수 있습니다.

- "MessageID"는 인쇄 가능한 문자로 구성된 32자 문자열입니다. 문자열은 "PART X" Armor Header를 사용하는 다중 부분 메시지의 모든 부분에 대해 동일해야 합니다. MessageID 문자열은 메일 수신자가 메시지의 모든 부분을 서로 연결할 수 있을 만큼 고유해야 합니다. 좋은 체크섬이나 암호화 해시 함수이면 충분합니다.

- MessageID는 여러 부분으로 구성된 메시지가 아닌 이상 나타나지 않아야 합니다. 그것이 나타나는 경우에는 순전히 무작위 값을 포함하는 것이 아니라 결정론적인 방식으로 완료된\(암호화, 서명 등\) 메시지에서 계산되어야 합니다. 이는 합법적인 수신자가 MessageID가 암호화 키 정보를 유출하는 은밀한 수단으로 사용될 수 없음을 확인할 수 있도록 하기 위한 것입니다.\(SHOULD NOT, MUST\)

- "해시"는 이 메시지에 사용된 해시 알고리즘의 쉼표로 구분된 목록입니다. 이는 일반 텍스트로 서명된 메시지에만 사용됩니다.

- "문자 집합", 일반 텍스트가 포함된 문자 집합에 대한 설명. OpenPGP는 텍스트를 UTF-8로 정의한다는 점에 유의하세요. 구현은 UTF-8로 변환하거나 UTF-8로 변환하여 최상의 결과를 얻습니다. 그러나 이것이 말처럼 쉽지 않고 실행되는 경우도 많습니다. 또한 ISO Latin-5 또는 일본어 문자 집합과 같은 문자 집합에 모두 만족하기 때문에 UTF-8이 필요하지 않은 사용자 커뮤니티도 있습니다. 이러한 경우 구현은 이 헤더 키를 사용하여 UTF-8 기본값을 재정의할 수 있습니다. 구현은 이 키와 관심 있는 모든 번역을 구현할 수 있습니다. 구현에서는 이를 무시하고 모든 텍스트가 UTF-8이라고 가정할 수 있습니다.\(MAY, MAY\)

- Armor Tail Line은 Armor Header Line과 동일한 방식으로 구성되지만 "BEGIN" 문자열이 "END" 문자열로 대체됩니다.

---
### **6.3.  Encoding Binary in Radix-64**

인코딩 프로세스는 입력 비트의 24비트 그룹을 4개의 인코딩된 문자의 출력 문자열로 나타냅니다. 왼쪽에서 오른쪽으로 진행하면서 3개의 8비트 입력 그룹을 연결하여 24비트 입력 그룹이 형성됩니다. 이 24비트는 4개의 연결된 6비트 그룹으로 처리되며, 각 그룹은 Radix-64 알파벳의 한 자리로 변환됩니다. Radix-64 인코딩으로 비트 스트림을 인코딩할 때 비트 스트림은 최상위 비트부터 정렬되는 것으로 가정되어야 합니다. 즉, 스트림의 첫 번째 비트는 첫 번째 8비트 옥텟의 상위 비트가 되고, 8번째 비트는 첫 번째 8비트 옥텟의 하위 비트가 되는 식입니다.

```text
         +--first octet--+-second octet--+--third octet--+
         |7 6 5 4 3 2 1 0|7 6 5 4 3 2 1 0|7 6 5 4 3 2 1 0|
         +-----------+---+-------+-------+---+-----------+
         |5 4 3 2 1 0|5 4 3 2 1 0|5 4 3 2 1 0|5 4 3 2 1 0|
         +--1.index--+--2.index--+--3.index--+--4.index--+
```

각 6비트 그룹은 아래 표의 인쇄 가능한 64개 문자 배열에 대한 인덱스로 사용됩니다. 인덱스에서 참조하는 문자는 출력 문자열에 배치됩니다.

```text
     Value Encoding  Value Encoding  Value Encoding  Value Encoding
         0 A            17 R            34 i            51 z
         1 B            18 S            35 j            52 0
         2 C            19 T            36 k            53 1
         3 D            20 U            37 l            54 2
         4 E            21 V            38 m            55 3
         5 F            22 W            39 n            56 4
         6 G            23 X            40 o            57 5
         7 H            24 Y            41 p            58 6
         8 I            25 Z            42 q            59 7
         9 J            26 a            43 r            60 8
        10 K            27 b            44 s            61 9
        11 L            28 c            45 t            62 +
        12 M            29 d            46 u            63 /
        13 N            30 e            47 v
        14 O            31 f            48 w         (pad) =
        15 P            32 g            49 x
        16 Q            33 h            50 y
```

인코딩된 출력 스트림은 각각 76자 이하의 줄로 표시되어야 합니다.

인코딩되는 데이터의 끝에서 사용 가능한 비트가 24비트 미만인 경우 특수 처리가 수행됩니다. 세 가지 가능성이 있습니다:

1. 마지막 데이터 그룹은 24비트\(3옥텟\)입니다. 특별한 처리가 필요하지 않습니다.

2. 마지막 데이터 그룹은 16비트\(2옥텟\)입니다. 처음 두 개의 6비트 그룹은 위와 같이 처리됩니다. 세 번째\(불완전\) 데이터 그룹에는 두 개의 0 값 비트가 추가되어 위와 같이 처리됩니다. 패드 문자\(=\)가 출력에 추가됩니다.

3. 마지막 데이터 그룹은 8비트\(1옥텟\)입니다. 첫 번째 6비트 그룹은 위와 같이 처리됩니다. 두 번째\(불완전\) 데이터 그룹에는 4개의 0값 비트가 추가되어 위와 같이 처리됩니다. 두 개의 패드 문자\(=\)가 출력에 추가됩니다.

---
### **6.4.  Decoding Radix-64**

Radix-64 데이터에서 테이블에 있는 문자 이외의 문자, 줄 바꿈 및 기타 공백은 전송 오류를 나타낼 수 있으며, 이에 대한 경고 메시지 또는 심지어 메시지 거부도 상황에 따라 적절할 수 있습니다. 디코딩 소프트웨어는 모든 공백을 무시해야 합니다.

데이터 끝 부분을 채우는 데에만 사용되기 때문에 "=" 문자가 발생하면 데이터 끝에 도달했다는 증거로 간주될 수 있습니다\(전송 중 잘림 없음\). 그러나 전송된 옥텟 수가 3의 배수이고 "=" 문자가 없는 경우에는 그러한 보장이 불가능합니다.

---
### **6.5.  Examples of Radix-64**

```text
   Input data:  0x14FB9C03D97E
   Hex:     1   4    F   B    9   C     | 0   3    D   9    7   E
   8-bit:   00010100 11111011 10011100  | 00000011 11011001 11111110
   6-bit:   000101 001111 101110 011100 | 000000 111101 100111 111110
   Decimal: 5      15     46     28       0      61     37     62
   Output:  F      P      u      c        A      9      l      +
   Input data:  0x14FB9C03D9
   Hex:     1   4    F   B    9   C     | 0   3    D   9
   8-bit:   00010100 11111011 10011100  | 00000011 11011001
                                                   pad with 00
   6-bit:   000101 001111 101110 011100 | 000000 111101 100100
   Decimal: 5      15     46     28       0      61     36
                                                      pad with =
   Output:  F      P      u      c        A      9      k      =
   Input data:  0x14FB9C03
   Hex:     1   4    F   B    9   C     | 0   3
   8-bit:   00010100 11111011 10011100  | 00000011
                                          pad with 0000
   6-bit:   000101 001111 101110 011100 | 000000 110000
   Decimal: 5      15     46     28       0      48
                                               pad with =      =
   Output:  F      P      u      c        A      w      =      =
```

---
### **6.6.  Example of an ASCII Armored Message**

```text
   -----BEGIN PGP MESSAGE-----
   Version: OpenPrivacy 0.99

   yDgBO22WxBHv7O8X7O/jygAEzol56iUKiXmV+XmpCtmpqQUKiQrFqclFqUDBovzS
   vBSFjNSiVHsuAA==
   =njUN
   -----END PGP MESSAGE-----
```

이 예제에는 추가 들여쓰기가 있습니다. 실제 기갑 메시지에는 선행 공백이 없습니다.

---
## **7.  Cleartext Signature Framework**

스트림 자체를 ASCII로 보호하지 않고 텍스트 옥텟 스트림에 서명할 수 있어서 특수 소프트웨어 없이도 서명된 텍스트를 계속 읽을 수 있는 것이 바람직합니다. 이러한 일반 텍스트에 서명을 바인딩하기 위해 이 프레임워크가 사용됩니다. \(이 프레임워크는 되돌릴 수 있도록 의도되지 않았습니다. RFC 3156 \[RFC3156\]은 MIME을 지원하는 환경에 대해 일반 텍스트 메시지에 서명하는 다른 방법을 정의합니다.\)

일반 텍스트로 서명된 메시지는 다음으로 구성됩니다.

```text
     - The cleartext header '-----BEGIN PGP SIGNED MESSAGE-----' on a
       single line,
```

- 하나 이상의 "해시" 방어구 헤더,

- 메시지 다이제스트에 포함되지 않은 정확히 하나의 빈 줄,

- 메시지 다이제스트에 포함된 대시 이스케이프 일반 텍스트입니다.

```text
     - The ASCII armored signature(s) including the '-----BEGIN PGP
       SIGNATURE-----' Armor Header and Armor Tail Lines.
```

"해시" Armor Header가 제공되면 지정된 메시지 다이제스트 알고리즘이 서명에 사용됩니다. 해당 헤더가 없으면 MD5가 사용됩니다. MD5가 사용된 유일한 해시인 경우 구현에서는 향상된 V2.x 호환성을 위해 이 헤더를 생략할 수 있습니다. 서명에 둘 이상의 메시지 다이제스트가 사용되는 경우 "Hash" armor 헤더에는 사용된 메시지 다이제스트의 쉼표로 구분된 목록이 포함됩니다.\(MAY\)

현재 메시지 다이제스트 이름은 아래에 알고리즘 ID와 함께 설명되어 있습니다.

구현은 일반 텍스트 뒤에 줄 바꿈을 추가해야 하지만\(SHOULD\) 일반 텍스트가 줄 바꿈으로 끝나는 경우 이를 생략할 수 있습니다. 이는 시각적 명확성을 위한 것입니다.\(SHOULD\)

---
### **7.1.  Dash-Escaped Text**

메시지의 일반 텍스트 콘텐츠도 대시 이스케이프 처리되어야 합니다.

대시 이스케이프된 일반 텍스트는 대시 '-'\(0x2D\)로 시작하는 모든 줄 앞에 대시 '-'\(0x2D\)와 공백 ' '\(0x20\)이 붙는 일반적인 일반 텍스트입니다. 이렇게 하면 파서가 일반 텍스트 자체의 armor 헤더를 인식하지 못합니다. 구현에서는 모든 줄을 대시로 이스케이프할 수 있고, "From"으로 시작하고 공백이 오는 줄을 대시로 이스케이프해야 하며, 대시로 시작하는 모든 줄을 대시로 이스케이프해야 합니다\(MUST\). 메시지 다이제스트는 대시 이스케이프 형식이 아닌 일반 텍스트 자체를 사용하여 계산됩니다.\(MUST\)

```text
   As with binary signatures on text documents, a cleartext signature is
   calculated on the text using canonical <CR><LF> line endings.  The
   line ending (i.e., the <CR><LF>) before the '-----BEGIN PGP
   SIGNATURE-----' line that terminates the signed text is not
   considered part of the signed text.
```

대시 이스케이프를 되돌릴 때 구현에서는 "-" 문자열이 줄 시작 부분에 나타나면 이를 제거해야 하며\(MUST\) 줄 시작 부분에 있는 "-" 및 공백 이외의 모든 문자에 대해 경고해야 합니다\(SHOULD\).\(MUST\)

또한 일반 텍스트 서명이 생성되면 줄 끝의 모든 후행 공백\(공백\(0x20\) 및 탭\(0x09\)\)이 제거됩니다.

---
## **8.  Regular Expressions**

정규식은 '|'로 구분된 0개 이상의 분기입니다. 이는 분기 중 하나와 일치하는 모든 항목과 일치합니다.

가지\(branch\)는 0개 이상의 조각이 연결된 것입니다. 첫 번째 일치 항목과 일치하고 두 번째 일치 항목 등이 이어집니다.

조각은 '\*', '+' 또는 '?'가 뒤에 올 수 있는 원자입니다. 뒤에 '\*'가 오는 원자는 0개 이상의 원자 일치 시퀀스와 일치합니다. 뒤에 '+'가 오는 원자는 해당 원자와 일치하는 1개 이상의 시퀀스와 일치합니다. 원자 뒤에 '?'가 옵니다. 원자 일치 또는 널 문자열과 일치합니다.

원자는 괄호 안의 정규식\(정규식과 일치\), 범위\(아래 참조\), '.'입니다. \(모든 단일 문자와 일치\), '^' \(입력 문자열 시작 부분의 null 문자열과 일치\), '$' \(입력 문자열 끝 부분의 null 문자열과 일치\), '\' 뒤에 단일 문자가 옴 \(해당 문자와 ​​일치\) 또는 다른 의미가 없는 단일 문자\(해당 문자와 ​​일치\).

범위는 '\[\]'로 묶인 일련의 문자입니다. 일반적으로 시퀀스의 단일 문자와 일치합니다. 시퀀스가 '^'로 시작하면 시퀀스의 나머지 부분이 아닌 모든 단일 문자와 일치합니다. 시퀀스의 두 문자가 '-'로 구분된 경우 이는 두 문자 사이의 전체 ASCII 문자 목록을 단축한 것입니다\(예: '\[0-9\]'는 모든 10진수와 일치합니다\). 시퀀스에 리터럴 '\]'을 포함하려면 이를 첫 번째 문자\(가능한 '^' 다음에 오는\)로 만듭니다. 리터럴 '-'를 포함하려면 해당 문자를 첫 번째 또는 마지막 문자로 만드세요.

---
## **9.  Constants**

이 섹션에서는 OpenPGP에서 사용되는 상수에 대해 설명합니다.

이 표는 완전한 목록이 아닙니다. 구현은 알고리즘 번호가 비공개 또는 실험적 알고리즘 범위에서 선택되는 한 이러한 목록에 없는 알고리즘을 구현할 수 있습니다.\(MAY\)

알고리즘에 대한 자세한 내용은 아래의 "알고리즘에 대한 참고 사항" 섹션을 참조하세요.

---
### **9.1.  Public-Key Algorithms**

```text
      ID           Algorithm
      --           ---------
      1          - RSA (Encrypt or Sign) [HAC]
      2          - RSA Encrypt-Only [HAC]
      3          - RSA Sign-Only [HAC]
      16         - Elgamal (Encrypt-Only) [ELGAMAL] [HAC]
      17         - DSA (Digital Signature Algorithm) [FIPS186] [HAC]
      18         - Reserved for Elliptic Curve
      19         - Reserved for ECDSA
      20         - Reserved (formerly Elgamal Encrypt or Sign)
      21         - Reserved for Diffie-Hellman (X9.42,
                   as defined for IETF-S/MIME)
      100 to 110 - Private/Experimental algorithm
```

구현에서는 서명을 위해 DSA를 구현하고 암호화를 위해 Elgamal을 구현해야 합니다. 구현은 RSA 키\(1\)를 구현해야 합니다\(SHOULD\). RSA 암호화 전용\(2\) 및 RSA 서명 전용은 더 이상 사용되지 않으며 생성되어서는 안 되지만 해석될 수 있습니다. 섹션 13.5를 참조하십시오. 타원 곡선\(18\), ECDSA\(19\), Elgamal Encrypt 또는 Sign\(20\) 및 X9.42\(21\)에 대한 참고 사항은 섹션 13.8을 참조하세요. 구현은 다른 알고리즘을 구현할 수도 있습니다\(MAY\).\(MUST, SHOULD, SHOULD NOT, MAY\)

---
### **9.2.  Symmetric-Key Algorithms**

```text
       ID           Algorithm
       --           ---------
       0          - Plaintext or unencrypted data
       1          - IDEA [IDEA]
       2          - TripleDES (DES-EDE, [SCHNEIER] [HAC] -
                    168 bit key derived from 192)
       3          - CAST5 (128 bit key, as per [RFC2144])
       4          - Blowfish (128 bit key, 16 rounds) [BLOWFISH]
       5          - Reserved
       6          - Reserved
       7          - AES with 128-bit key [AES]
       8          - AES with 192-bit key
       9          - AES with 256-bit key
       10         - Twofish with 256-bit key [TWOFISH]
       100 to 110 - Private/Experimental algorithm
```

구현은 TripleDES를 구현해야 합니다. 구현은 AES-128 및 CAST5를 구현해야 합니다\(SHOULD\). 상호 운용되는 구현\(MUST, SHOULD\)

PGP 2.6 이하에서는 IDEA를 지원해야 합니다. IDEA는 해당 버전에서 사용하는 유일한 대칭 암호이기 때문입니다. 구현은 다른 알고리즘을 구현할 수도 있습니다\(MAY\).\(MAY\)

---
### **9.3.  Compression Algorithms**

```text
       ID           Algorithm
       --           ---------
       0          - Uncompressed
       1          - ZIP [RFC1951]
       2          - ZLIB [RFC1950]
       3          - BZip2 [BZ2]
       100 to 110 - Private/Experimental algorithm

   Implementations MUST implement uncompressed data.  Implementations
   SHOULD implement ZIP.  Implementations MAY implement any other
   algorithm.
```

---
### **9.4.  Hash Algorithms**

```text
      ID           Algorithm                             Text Name
      --           ---------                             ---------
      1          - MD5 [HAC]                             "MD5"
      2          - SHA-1 [FIPS180]                       "SHA1"
      3          - RIPE-MD/160 [HAC]                     "RIPEMD160"
      4          - Reserved
      5          - Reserved
      6          - Reserved
      7          - Reserved
      8          - SHA256 [FIPS180]                      "SHA256"
      9          - SHA384 [FIPS180]                      "SHA384"
      10         - SHA512 [FIPS180]                      "SHA512"
      11         - SHA224 [FIPS180]                      "SHA224"
      100 to 110 - Private/Experimental algorithm
```

구현은 SHA-1을 구현해야 합니다. 구현은 다른 알고리즘을 구현할 수도 있습니다\(MAY\). MD5는 더 이상 사용되지 않습니다.\(MUST, MAY\)

---
## **10.  IANA Considerations**

OpenPGP는 고도로 매개변수화되어 있으므로 확장에 매개변수를 할당할 때 고려해야 할 사항이 많습니다. 이 섹션에서는 IANA가 이 문서에 설명된 대로 프로토콜 확장을 어떻게 봐야 하는지 설명합니다.

---
### **10.1.  New String-to-Key Specifier Types**

OpenPGP S2K 지정자에는 문자열을 키로 변환하는 새로운 알고리즘에 대한 메커니즘이 포함되어 있습니다. 이 사양은 S2K 지정자 유형의 레지스트리를 생성합니다. 레지스트리에는 S2K 유형, S2K 이름, 정의 사양에 대한 참조가 포함됩니다. 이 레지스트리의 초기 값은 섹션 3.7.1에서 찾을 수 있습니다. 새로운 S2K 지정자를 추가하는 것은 \[RFC2434\]에 설명된 대로 IETF CONSENSUS 방법을 통해 수행되어야 합니다.\(MUST\)

---
### **10.2.  New Packets**

OpenPGP의 새로운 주요 기능은 새로운 패킷 유형을 통해 정의됩니다. 이 사양은 패킷 유형의 레지스트리를 생성합니다. 레지스트리에는 패킷 유형, 패킷 이름 및 정의 사양에 대한 참조가 포함됩니다. 이 레지스트리의 초기 값은 섹션 4.3에서 찾을 수 있습니다. 새로운 패킷 유형을 추가하는 것은 \[RFC2434\]에 설명된 대로 IETF CONSENSUS 방법을 통해 수행되어야 합니다.\(MUST\)

---
#### **10.2.1.  User Attribute Types**

사용자 속성 패킷은 다른 유형의 인증서 식별을 위한 확장 가능한 메커니즘을 허용합니다. 이 사양은 사용자 속성 유형의 레지스트리를 생성합니다. 레지스트리에는 사용자 속성 유형, 사용자 속성 이름 및 정의 사양에 대한 참조가 포함됩니다. 이 레지스트리의 초기 값은 섹션 5.12에서 찾을 수 있습니다. 새로운 사용자 속성 유형을 추가하는 것은 \[RFC2434\]에 설명된 대로 IETF CONSENSUS 방법을 통해 수행되어야 합니다.\(MUST\)

---
##### **10.2.1.1.  Image Format Subpacket Types**

사용자 속성 패킷 내에는 다른 유형의 이미지 기반 사용자 속성에 대한 확장 가능한 메커니즘이 있습니다. 이 사양은 이미지 속성 하위 패킷 유형의 레지스트리를 생성합니다. 레지스트리에는 이미지 속성 하위 패킷 유형, 이미지 속성 하위 패킷의 이름 및 정의 사양에 대한 참조가 포함됩니다. 이 레지스트리의 초기 값은 섹션 5.12.1에서 찾을 수 있습니다. 새로운 이미지 속성 하위 패킷 유형을 추가하는 것은 \[RFC2434\]에 설명된 대로 IETF CONSENSUS 방법을 통해 수행되어야 합니다.\(MUST\)

---
#### **10.2.2.  New Signature Subpackets**

OpenPGP 서명에는 섹션 5.2.3.1에서 설명한 대로 서명 하위 패킷에 다양한 목적으로 서명된\(또는 서명되지 않은\) 데이터를 추가하는 메커니즘이 포함되어 있습니다. 이 사양은 서명 하위 패킷 유형의 레지스트리를 생성합니다. 레지스트리에는 서명 하위 패킷 유형, 하위 패킷 이름 및 정의 사양에 대한 참조가 포함됩니다. 에 대한 초기 값

이 레지스트리는 섹션 5.2.3.1에서 찾을 수 있습니다. 새로운 서명 하위 패킷 추가는 \[RFC2434\]에 설명된 대로 IETF CONSENSUS 방법을 통해 수행되어야 합니다.\(MUST\)

---
##### **10.2.2.1.  Signature Notation Data Subpackets**

OpenPGP 서명에는 서명 확장을 위한 메커니즘도 포함되어 있습니다. 이는 키/값 쌍을 포함하는 표기법 데이터 하위 패킷입니다. 표기법에는 완전히 관리되지 않는 사용자 공간과 IETF 공간이 포함됩니다.

이 사양은 서명 표기법 데이터 유형의 레지스트리를 생성합니다. 레지스트리에는 서명 표기법 데이터 유형, 서명 표기법 데이터의 이름, 허용된 값 및 정의 사양에 대한 참조가 포함됩니다. 이 레지스트리의 초기 값은 섹션 5.2.3.16에서 찾을 수 있습니다. 새로운 서명 표기법 데이터 하위 패킷을 추가하는 것은 \[RFC2434\]에 설명된 대로 전문가 검토 방법을 통해 수행되어야 합니다.\(MUST\)

---
##### **10.2.2.2.  Key Server Preference Extensions**

OpenPGP 서명에는 키 서버에 대한 기본 설정을 지정하는 메커니즘이 포함되어 있습니다. 이 사양은 주요 서버 기본 설정의 레지스트리를 생성합니다. 레지스트리에는 키 서버 기본 설정, 기본 설정 이름 및 정의 사양에 대한 참조가 포함됩니다. 이 레지스트리의 초기 값은 섹션 5.2.3.17에서 찾을 수 있습니다. 새로운 키 서버 기본 설정을 추가하는 것은 \[RFC2434\]에 설명된 대로 IETF CONSENSUS 방법을 통해 수행되어야 합니다.\(MUST\)

---
##### **10.2.2.3.  Key Flags Extensions**

OpenPGP 서명에는 키 사용에 대해 플래그를 지정하는 메커니즘이 포함되어 있습니다. 이 사양은 키 사용 플래그의 레지스트리를 생성합니다. 레지스트리에는 키 플래그 값, 플래그 이름, 정의 사양에 대한 참조가 포함됩니다. 이 레지스트리의 초기 값은 섹션 5.2.3.21에서 찾을 수 있습니다. 새로운 키 사용 플래그 추가는 \[RFC2434\]에 설명된 대로 IETF CONSENSUS 방법을 통해 수행되어야 합니다.\(MUST\)

---
##### **10.2.2.4.  Reason for Revocation Extensions**

OpenPGP 서명에는 키가 취소된 이유에 대해 플래그를 지정하는 메커니즘이 포함되어 있습니다. 이 사양은 "해지 이유" 플래그의 레지스트리를 생성합니다. 레지스트리에는 "해지 이유" 플래그 값, 플래그 이름 및 정의 사양에 대한 참조가 포함됩니다. 이 레지스트리의 초기 값은 섹션 5.2.3.23에서 찾을 수 있습니다. 새로운 기능 플래그 추가는 \[RFC2434\]에 설명된 대로 IETF CONSENSUS 방법을 통해 수행되어야 합니다.\(MUST\)

---
##### **10.2.2.5.  Implementation Features**

OpenPGP 서명에는 구현이 지원하는 선택적 기능을 나타내는 플래그를 지정하는 메커니즘이 포함되어 있습니다. 이 사양은 기능 구현 플래그의 레지스트리를 생성합니다. 레지스트리에는 기능 구현 플래그 값, 플래그 이름, 정의 사양에 대한 참조가 포함됩니다. 이 레지스트리의 초기 값은 섹션 5.2.3.24에서 찾을 수 있습니다. 새로운 기능 구현 플래그를 추가하는 것은 \[RFC2434\]에 설명된 대로 IETF CONSENSUS 방법을 통해 수행되어야 합니다.\(MUST\)

또한 기능 플래그가 필요한 경우에 대한 자세한 내용은 섹션 13.12를 참조하세요.

---
#### **10.2.3.  New Packet Versions**

핵심 OpenPGP 패킷에는 모두 버전 번호가 있으며 기존 패킷의 새 버전을 도입하여 개정될 수 있습니다. 이 사양은 패킷 유형의 레지스트리를 생성합니다. 레지스트리에는 패킷 유형, 버전 번호 및 정의 사양에 대한 참조가 포함됩니다. 이 레지스트리의 초기 값은 섹션 5에서 찾을 수 있습니다. 새로운 패킷 버전을 추가하는 것은 \[RFC2434\]에 설명된 대로 IETF CONSENSUS 방법을 통해 수행되어야 합니다.\(MUST\)

---
### **10.3.  New Algorithms**

섹션 9에는 OpenPGP가 사용하는 핵심 알고리즘이 나열되어 있습니다. 새로운 알고리즘을 추가하는 것은 일반적으로 간단합니다. 예를 들어, 새로운 대칭 암호를 추가하는 경우 일반적으로 해당 암호에 상수를 할당하는 것 외에는 아무것도 필요하지 않습니다. 해당 암호의 블록 크기가 64비트 또는 128비트가 아닌 경우 OpenPGP-CFB 모드 조정 방법을 설명하는 추가 문서가 필요할 수 있습니다. 마찬가지로, DSA가 최대 1024비트 공개 키에서 3072비트 공개 키로 확장되었을 때 FIPS 186 개정판 자체에는 구현이 가능하도록 충분한 정보가 포함되었습니다. 이 문서의 변경은 주로 강조를 위해 이루어졌습니다.

---
#### **10.3.1.  Public-Key Algorithms**

OpenPGP는 다수의 공개 키 알고리즘을 지정합니다. 이 사양은 공개 키 알고리즘 식별자의 레지스트리를 생성합니다. 레지스트리에는 알고리즘 이름, 해당 키 크기 및 매개변수, 정의 사양에 대한 참조가 포함됩니다. 이 레지스트리의 초기 값은 섹션 9에서 찾을 수 있습니다. 새로운 공개 키 알고리즘을 추가하는 것은 \[RFC2434\]에 설명된 대로 IETF CONSENSUS 방법을 통해 수행되어야 합니다.\(MUST\)

---
#### **10.3.2.  Symmetric-Key Algorithms**

OpenPGP는 여러 대칭 키 알고리즘을 지정합니다. 이 사양은 대칭 키 알고리즘 식별자의 레지스트리를 생성합니다. 레지스트리에는 알고리즘 이름, 해당 키 크기 및 블록 크기, 정의 사양에 대한 참조가 포함됩니다. 이 레지스트리의 초기 값은 섹션 9에서 찾을 수 있습니다. 새로운 대칭 키 알고리즘을 추가하는 것은 \[RFC2434\]에 설명된 대로 IETF CONSENSUS 방법을 통해 수행되어야 합니다.\(MUST\)

---
#### **10.3.3.  Hash Algorithms**

OpenPGP는 다양한 해시 알고리즘을 지정합니다. 이 사양은 해시 알고리즘 식별자의 레지스트리를 생성합니다. 레지스트리에는 알고리즘 이름, 해당 이름의 텍스트 표현, 블록 크기, OID 해시 접두사 및 정의 사양에 대한 참조가 포함됩니다. 이 레지스트리의 초기 값은 알고리즘 식별자 및 텍스트 이름에 대한 섹션 9와 OID 및 확장된 서명 접두사에 대한 섹션 5.2.2에서 찾을 수 있습니다. 새로운 해시 알고리즘을 추가하는 것은 \[RFC2434\]에 설명된 대로 IETF CONSENSUS 방법을 통해 수행되어야 합니다.\(MUST\)

---
#### **10.3.4.  Compression Algorithms**

OpenPGP는 다양한 압축 알고리즘을 지정합니다. 이 사양은 압축 알고리즘 식별자의 레지스트리를 생성합니다. 레지스트리에는 알고리즘 이름과 정의 사양에 대한 참조가 포함됩니다. 이 레지스트리의 초기 값은 섹션 9.3에서 찾을 수 있습니다. 새로운 압축 키 알고리즘을 추가하는 것은 \[RFC2434\]에 설명된 대로 IETF CONSENSUS 방법을 통해 수행되어야 합니다.\(MUST\)

---
## **11.  Packet Composition**

OpenPGP 패킷은 메시지를 생성하고 키를 전송하기 위해 시퀀스로 조립됩니다. 가능한 모든 패킷 시퀀스가 ​​의미 있고 올바른 것은 아닙니다. 이 섹션에서는 패킷을 시퀀스에 배치하는 방법에 대한 규칙을 설명합니다.

---
### **11.1.  Transferable Public Keys**

OpenPGP 사용자는 공개 키를 전송할 수 있습니다. 양도 가능한 공개 키의 필수 요소는 다음과 같습니다.

```text
     - One Public-Key packet
```

- 0개 이상의 철회 서명

- 하나 이상의 사용자 ID 패킷

```text
     - After each User ID packet, zero or more Signature packets
       (certifications)
```

- 0개 이상의 사용자 속성 패킷

```text
     - After each User Attribute packet, zero or more Signature packets
       (certifications)
```

- 0개 이상의 하위 키 패킷

- 각 하위 키 패킷 뒤에 하나의 서명 패킷과 선택적으로 해지

공개 키 패킷이 먼저 발생합니다. 다음 각 사용자 ID 패킷은 이 공개 키 소유자의 신원을 제공합니다. 사용자 ID 패킷이 여러 개인 경우 이는 동일한 고유 개별 사용자를 식별하는 여러 수단에 해당합니다. 예를 들어, 사용자는 하나 이상의 이메일 주소를 갖고 각 주소에 대해 사용자 ID를 구성할 수 있습니다.

각 사용자 ID 패킷 바로 뒤에는 0개 이상의 서명 패킷이 있습니다. 각 서명 패킷은 바로 앞의 사용자 ID 패킷과 초기 공개 키 패킷을 기준으로 계산됩니다. 서명은 해당 공개 키와 사용자 ID를 인증하는 역할을 합니다. 실제로 서명자는 이 공개 키가 이 사용자 ID로 식별된 사용자에게 속한다는 자신의 믿음을 증언하는 것입니다.

사용자 ID 패킷과 동일한 섹션 내에는 0개 이상의 사용자 속성 패킷이 있습니다. 사용자 ID 패킷과 마찬가지로 사용자 속성 패킷 뒤에는 바로 앞선 사용자 속성 패킷과 초기 공개 키 패킷에서 계산된 0개 이상의 서명 패킷이 옵니다.

사용자 속성 패킷과 사용자 ID 패킷은 뒤따르는 서명이 적절한 사용자 속성 또는 사용자 ID 패킷에서 유지되는 한 이 섹션에서 자유롭게 혼합될 수 있습니다.

사용자 ID 패킷이나 속성 패킷 뒤에는 0개 이상의 하위 키 패킷이 있을 수 있습니다. 일반적으로 최상위 공개 키가 서명 전용 키인 경우 하위 키가 제공됩니다. 그러나 모든 V4 키에는 하위 키가 있을 수 있으며 하위 키는 암호화 전용 키, 서명 전용 키 또는 범용 키일 수 있습니다. V3 키에는 하위 키가 있어서는 안 됩니다.\(MUST NOT\)

각 하위 키 패킷 뒤에는 하나의 서명 패킷이 와야 하며, 이는 최상위 키에서 발행한 하위 키 바인딩 서명이어야 합니다. 서명을 발급할 수 있는 하위 키의 경우 하위 키 바인딩 서명에는 최상위 키의 하위 키에서 발급한 기본 키 바인딩 서명\(0x19\)이 포함된 내장형 서명 하위 패킷이 포함되어야 합니다.\(MUST, MUST\)

하위 키 및 키 패킷 뒤에는 키가 취소되었음을 나타내는 취소 서명 패킷이 각각 올 수 있습니다. 해지 서명은 키 자체에 의해 발행되거나 최상위 키에 의한 자체 서명의 해지 키 하위 패킷을 통해 해지 발행 권한이 부여된 키에 의해 발행된 경우에만 허용됩니다.

전송 가능한 공개 키 패킷 시퀀스는 한 번의 작업으로 여러 공개 키를 전송할 수 있도록 연결될 수 있습니다.

---
### **11.2.  Transferable Secret Keys**

OpenPGP 사용자는 비밀 키를 전송할 수 있습니다. 양도 가능한 비밀 키의 형식은 공개 키 및 공개 하위 키 패킷 대신 비밀 키 및 비밀 하위 키 패킷이 사용된다는 점을 제외하면 양도 가능한 공개 키와 동일합니다. 구현 시 모든 사용자 ID 및 하위 키에 자체 서명을 포함해야 합니다. 이를 통해 양도 가능한 비밀 키에서 완전한 공개 키가 자동으로 추출될 수 있습니다. 구현 시 자체 서명을 생략하도록 선택할 수 있습니다. 특히 양도 가능한 공개 키가 양도 가능한 비밀 키와 함께 제공되는 경우 더욱 그렇습니다.\(SHOULD, MAY\)

---
### **11.3.  OpenPGP Messages**

OpenPGP 메시지는 다음 문법 규칙에 해당하는 패킷 또는 패킷 시퀀스입니다\(쉼표는 순차적 구성을 나타내고 수직 막대는 대안을 구분함\).

```text
   OpenPGP Message :- Encrypted Message | Signed Message |
                      Compressed Message | Literal Message.

   Compressed Message :- Compressed Data Packet.

   Literal Message :- Literal Data Packet.

   ESK :- Public-Key Encrypted Session Key Packet |
          Symmetric-Key Encrypted Session Key Packet.

   ESK Sequence :- ESK | ESK Sequence, ESK.

   Encrypted Data :- Symmetrically Encrypted Data Packet |
         Symmetrically Encrypted Integrity Protected Data Packet

   Encrypted Message :- Encrypted Data | ESK Sequence, Encrypted Data.

   One-Pass Signed Message :- One-Pass Signature Packet,
               OpenPGP Message, Corresponding Signature Packet.

   Signed Message :- Signature Packet, OpenPGP Message |
               One-Pass Signed Message.
```

또한 대칭적으로 암호화된 데이터 패킷 또는 대칭적으로 암호화된 무결성 보호 데이터 패킷의 암호를 해독하고 압축된 데이터 패킷의 압축을 풀면 유효한 OpenPGP 메시지가 생성되어야 합니다.

---
### **11.4.  Detached Signatures**

일부 OpenPGP 응용 프로그램은 소위 "분리된 서명"을 사용합니다. 예를 들어, 프로그램 번들에는 파일이 포함될 수 있으며, 첫 번째 파일의 분리된 서명인 두 번째 파일도 포함될 수 있습니다. 이러한 분리된 서명은 단순히 서명인 데이터와 별도로 저장된 서명 패킷입니다.

---
## **12.  Enhanced Key Formats**
---
### **12.1.  Key Structures**

OpenPGP V3 키의 형식은 다음과 같습니다. 대괄호 안의 항목은 선택사항이며 타원은 반복을 나타냅니다.

```text
           RSA Public Key
              [Revocation Self Signature]
               User ID [Signature ...]
              [User ID [Signature ...] ...]
```

각 서명은 RSA 공개 키와 이전 사용자 ID를 인증합니다. RSA 공개 키에는 많은 사용자 ID가 있을 수 있으며 각 사용자 ID에는 많은 서명이 있을 수 있습니다. V3 키는 더 이상 사용되지 않습니다. 구현 시 새로운 V3 키를 생성해서는 안 되지만 기존 키를 계속 사용할 수도 있습니다\(MAY\).\(MUST NOT\)

여러 공개 키를 사용하는 OpenPGP V4 키의 형식은 다른 키가 기본 키의 "하위 키"로 끝에 추가된다는 점을 제외하면 유사합니다.

```text
           Primary-Key
              [Revocation Self Signature]
              [Direct Key Signature...]
               User ID [Signature ...]
              [User ID [Signature ...] ...]
              [User Attribute [Signature ...] ...]
              [[Subkey [Binding-Signature-Revocation]
                      Primary-Key-Binding-Signature] ...]
```

하위 키에는 두 키를 함께 연결하기 위해 기본 키를 사용하여 발급된 단일 서명이 항상 있습니다. 이 바인딩 서명은 V3 또는 V4 형식일 수 있지만 V4여야 합니다. 서명을 발행할 수 있는 하위 키에는 필수 내장 기본 키 바인딩 서명으로 인해 V4 바인딩 서명이 있어야 합니다.\(SHOULD, MUST\)

위 다이어그램에서 하위 키의 바인딩 서명이 취소된 경우 취소된 키는 제거되고 키는 하나만 남을 수 있습니다.

V4 키에서 기본 키는 인증이 가능한 키여야 합니다. 하위 키는 다른 유형의 키일 수 있습니다. V4 키의 다른 구성도 있을 수 있습니다. 예를 들어 V4 형식의 단일 키 RSA 키, RSA 암호화 키가 있는 DSA 기본 키, Elgamal 하위 키가 있는 RSA 기본 키 등이 있을 수 있습니다.\(MUST\)

서명 전용 하위 키를 갖는 것도 가능합니다. 이는 인증\(키 서명\)을 수집하는 기본 키를 허용하지만 암호화 및 서명에 사용되는 하위 키를 인증하는 데에만 사용됩니다.

---
### **12.2.  Key IDs and Fingerprints**

V3 키의 경우 8옥텟 키 ID는 RSA 키 공개 모듈러스의 하위 64비트로 구성됩니다.

V3 키의 지문은 키 자료\(공용 모듈 n, 뒤에 지수 e가 옴\)를 형성하는 MPI의 본문\(2옥텟 길이는 아님\)을 MD5로 해싱하여 형성됩니다. V3 키와 MD5는 모두 더 이상 사용되지 않습니다.

V4 지문은 옥텟 0x99의 160비트 SHA-1 해시이며, 그 뒤에 2옥텟 패킷 길이가 오고 그 뒤에 버전 필드로 시작하는 전체 공개 키 패킷이 옵니다. 키 ID는 지문의 하위 64비트입니다. 다음은 DSA 키의 예와 함께 해시 자료의 필드입니다.

```text
   a.1) 0x99 (1 octet)

   a.2) high-order length octet of (b)-(e) (1 octet)

   a.3) low-order length octet of (b)-(e) (1 octet)

     b) version number = 4 (1 octet);

     c) timestamp of key creation (4 octets);

     d) algorithm (1 octet): 17 = DSA (example);

     e) Algorithm-specific fields.
```

DSA 키에 대한 알고리즘별 필드\(예\):

```text
   e.1) MPI of DSA prime p;

   e.2) MPI of DSA group order q (q is a prime divisor of p-1);

   e.3) MPI of DSA group generator g;
```

e.4\) DSA 공개 키 값 y의 MPI\(= g\*\*x mod p, 여기서 x는 비밀임\).

키 ID\(동일한 키 ID를 가진 두 개의 다른 키\)가 충돌할 수 있습니다. 두 개의 서로 다른 키가 동일한 지문을 가질 확률은 훨씬 작지만 여전히 0이 아닙니다.

또한 V3 및 V4 형식 키가 동일한 RSA 키 자료를 공유하는 경우 키 ID와 지문이 서로 다릅니다.

마지막으로 하위 키의 키 ID와 지문은 첫 번째 옥텟인 0x99를 포함하여 기본 키와 동일한 방식으로 계산됩니다\(공개 하위 키에 대한 유효한 패킷 ID가 아니더라도\).

---
## **13.  Notes on Algorithms**
---
### **13.1.  PKCS#1 Encoding in OpenPGP**

이 표준은 PKCS#1 기능 EME-PKCS1-v1\_5 및 EMSA-PKCS1-v1\_5를 사용합니다. 그러나 이러한 함수의 호출 규칙은 과거에 변경되었습니다. 잠재적인 혼란과 상호 운용성 문제를 피하기 위해 이 문서에는 PKCS#1 v2.1 \[RFC3447\]의 내용을 수정한 로컬 복사본을 포함하고 있습니다. RFC 3447은 OpenPGP용 PKCS#1에 대한 최종 권한으로 처리되어야 합니다. 그럼에도 불구하고 우리는 규칙에 필요한 변경 사항으로 인해 향후 문제를 방지하는 자체 포함된 문서를 갖는 것이 가치가 있다고 믿습니다.

---
#### **13.1.1.  EME-PKCS1-v1_5-ENCODE**

```text
   Input:
```

k = 키 모듈러스의 길이\(옥텟\)

M = 인코딩할 메시지, 길이가 mLen인 옥텟 문자열, 여기서 mLen <= k - 11

```text
   Output:
```

EM = 인코딩된 메시지, 길이 k의 옥텟 문자열

```text
   Error:   "message too long"
```

1. 길이 확인: mLen \> k - 11이면 "message too long"을 출력하고 중지합니다.

2. 의사 무작위로 생성된 0이 아닌 옥텟으로 구성된 길이 k - mLen - 3의 옥텟 문자열 PS를 생성합니다. PS의 길이는 최소 8옥텟입니다.

3. PS, 메시지 M 및 기타 패딩을 연결하여 길이 k 옥텟의 인코딩된 메시지 EM을 형성합니다.

```text
        EM = 0x00 || 0x02 || PS || 0x00 || M.

     4. Output EM.
```

---
#### **13.1.2.  EME-PKCS1-v1_5-DECODE**

```text
   Input:
```

EM = 인코딩된 메시지, 옥텟 문자열

```text
   Output:
```

M = 메시지, 옥텟 문자열

```text
   Error:   "decryption error"
```

EME-PKCS1\_v1\_5 메시지를 디코딩하려면 인코딩된 메시지 EM을 다음과 같이 0이 아닌 옥텟과 메시지 M으로 구성된 옥텟 문자열 PS로 분리합니다.

```text
     EM = 0x00 || 0x02 || PS || 0x00 || M.
```

EM의 첫 번째 옥텟에 16진수 값 0x00이 없는 경우, EM의 두 번째 옥텟에 16진수 값 0x02가 없는 경우, PS를 M과 구분하는 16진수 값 0x00을 갖는 옥텟이 없거나 PS의 길이가 8옥텟, "암호해독 오류"를 출력하고 중지합니다. 암호 해독 오류와 패딩 오류 간의 보고 차이점에 대해서는 섹션 14의 보안 참고 사항도 참조하세요.

---
#### **13.1.3.  EMSA-PKCS1-v1_5**

이 인코딩 방법은 결정적이며 인코딩 작업만 포함합니다.

```text
   Option:
```

해시 - hLen이 해시 함수 출력의 옥텟 길이를 나타내는 해시 함수

```text
   Input:
```

M = 인코딩할 메시지

mL = 인코딩된 메시지의 의도된 옥텟 길이, 최소 tLen + 11, 여기서 tLen은 인코딩 작업 중에 계산된 특정 값의 DER 인코딩 T의 옥텟 길이입니다.

```text
   Output:
```

EM = 인코딩된 메시지, 길이가 emLen인 옥텟 문자열

```text
   Errors: "message too long"; "intended encoded message length too
   short"

   Steps:
```

1. 메시지 M에 해시 함수를 적용하여 해시 값 H를 생성합니다.

```text
        H = Hash(M).
```

- 해시 함수가 "메시지가 너무 김"을 출력하는 경우 "메시지가 너무 김"을 출력하고 중지합니다.

2. 섹션 5.2.2의 목록을 사용하여 사용된 해시 함수에 대한 ASN.1 DER 값을 생성합니다. T를 섹션 5.2.2의 전체 해시 접두사로 두고, tLen을 T의 옥텟 길이로 둡니다.

3. emLen < tLen + 11인 경우 "의도된 인코딩된 메시지 길이가 너무 짧음"을 출력하고 중지합니다.

4. 16진수 값 0xFF를 갖는 emLen - tLen - 3옥텟으로 구성된 옥텟 문자열 PS를 생성합니다. PS의 길이는 최소 8옥텟입니다.

5. PS, 해시 접두사 T 및 기타 패딩을 연결하여 다음과 같이 인코딩된 메시지 EM을 형성합니다.

```text
        EM = 0x00 || 0x01 || PS || 0x00 || T.

     6. Output EM.
```

---
### **13.2.  Symmetric Algorithm Preferences**

대칭 알고리즘 기본 설정은 키홀더가 허용하는 정렬된 알고리즘 목록입니다. 이는 자체 서명에서 발견되므로 키홀더가 여러 가지 선호도를 가질 수 있습니다. 예를 들어, Alice는 "alice@work.com"에 대해서만 TripleDES를 지정하고 "alice@home.org"에 대해서는 CAST5, Blowfish 및 TripleDES를 지정할 수 있습니다. 기본 설정이 하위 키의 바인딩 서명에 포함될 수도 있습니다.

TripleDES는 반드시 구현해야 하는 알고리즘이므로 명시적으로 목록에 없으면 암묵적으로 끝에 있습니다. 그러나 명시적으로 배치하는 것이 좋은 형식입니다. 또한 구현이 기본 설정을 구현하지 않는 경우 암시적으로 TripleDES 전용 구현이라는 점에 유의하세요.\(MUST\)

구현은 수신자의 기본 설정 목록에 없는 대칭 알고리즘을 사용해서는 안 됩니다. 두 명 이상의 수신자를 암호화하는 경우 구현에서는 수신자의 기본 설정을 교차시켜 적합한 알고리즘을 찾습니다. MUST 구현 알고리즘인 TripleDES는 교차점이 null이 아닌지 확인합니다. 구현에서는 교차점에서 알고리즘을 선택하기 위해 모든 메커니즘을 사용할 수 있습니다.\(MUST NOT, MUST\)

구현이 키 소유자의 기본 설정에 없는 메시지를 해독할 수 있는 경우 구현은 어쨌든 메시지를 해독해야 하지만 키 소유자에게 프로토콜이 위반되었음을 경고해야 합니다\(MUST\). 예를 들어, 위의 Alice가 이 사양의 모든 알고리즘을 구현하는 소프트웨어를 가지고 있다고 가정합니다. 그럼에도 불구하고 그녀는 직장이나 집에서 하위 집합을 선호합니다. 그녀가 선호하지 않는 IDEA로 암호화된 메시지를 받으면 소프트웨어는 누군가 그녀에게 IDEA로 암호화된 메시지를 보냈다고 경고하지만 어쨌든 이상적으로는 해독할 것입니다.\(MUST\)

---
### **13.3.  Other Algorithm Preferences**

다른 알고리즘 기본 설정은 키홀더가 허용하는 알고리즘을 지정한다는 점에서 대칭 알고리즘 기본 설정과 유사하게 작동합니다. 하지만 압축 기본 설정과 해시 기본 설정에 대해 다른 의견을 제시해야 하는 두 가지 흥미로운 사례가 있습니다.

---
#### **13.3.1.  Compression Preferences**

압축은 처음부터 PGP의 필수적인 부분이었습니다. OpenPGP와 모든 이전 버전의 PGP는 압축을 제공했습니다. 이 사양에서는 구현이 반드시 필요한 것은 아니지만 기본값은 메시지를 압축하는 것입니다. 결과적으로 압축 기본 설정은 키홀더가 메시지가 압축되지 않도록 요청할 수 있는 방법을 제공합니다. 아마도 압축을 포함하지 않는 최소 구현을 사용하고 있기 때문일 것입니다. 또한 이는 키홀더에게 대체 알고리즘을 지원할 수 있음을 명시하는 방법을 제공합니다.

알고리즘 기본 설정과 마찬가지로 구현은 기본 설정 벡터에 없는 알고리즘을 사용해서는 안 됩니다. 기본 설정이 없으면 \[ZIP\(1\), Uncompressed\(0\)\]인 것으로 간주됩니다.\(MUST NOT\)

또한 구현에서는 압축되지 않은 메시지를 보낼 시기를 인식할 수 있을 정도로 이 기본 설정을 구현해야 합니다. 강력한 구현은 수신자의 선호도를 살펴보고 그에 따라 행동함으로써 이 요구 사항을 충족합니다. 모든 구현이 압축되지 않은 메시지를 처리할 수 있으므로 최소 구현은 압축된 메시지를 생성하지 않음으로써 이 요구 사항을 충족할 수 있습니다.\(MUST\)

---
#### **13.3.2.  Hash Algorithm Preferences**

일반적으로 해시 알고리즘 선택은 검증자가 아닌 서명자가 수행하는 작업입니다. 서명자는 서명을 검증할 사람이 누구인지 거의 알지 못하기 때문입니다. 그러나 이러한 기본 설정을 통해 디지털 서명을 기반으로 하는 프로토콜의 협상이 쉬워집니다.

따라서 Alice가 서명을 사용하여 Bob에게 자신을 인증하는 경우 Bob의 소프트웨어에서 사용하는 해시 알고리즘을 사용하는 것이 합리적입니다. 이 기본 설정을 통해 Bob은 Alice가 사용할 수 있는 알고리즘을 자신의 키에 명시할 수 있습니다.

SHA1은 반드시 구현해야 하는 해시 알고리즘이므로 목록에 명시적으로 없으면 암묵적으로 끝에 있습니다. 그러나 명시적으로 배치하는 것이 좋은 형식입니다.\(MUST\)

---
### **13.4.  Plaintext**

알고리즘 0, "일반 텍스트"는 일반 텍스트로 저장된 비밀 키를 나타내는 데에만 사용할 수 있습니다. 구현에서는 대칭적으로 암호화된 데이터 패킷에 일반 텍스트를 사용하면 안 됩니다. 암호화되지 않은 데이터나 리터럴 데이터를 인코딩하려면 리터럴 데이터 패킷을 사용해야 합니다.\(MUST NOT\)

---
### **13.5.  RSA**

RSA 서명 전용 키와 RSA 암호화 전용 키에 대한 알고리즘 유형이 있습니다. 이러한 유형은 더 이상 사용되지 않습니다. 서명의 "키 플래그" 하위 패킷은 동일한 아이디어를 표현하는 훨씬 더 좋은 방법이며 이를 모든 알고리즘에 일반화합니다. 구현은 그러한 키를 생성해서는 안 되지만 이를 해석할 수 있습니다.\(SHOULD NOT\)

구현은 1024비트보다 작은 크기의 RSA 키를 구현해서는 안 됩니다.\(SHOULD NOT\)

---
### **13.6.  DSA**

구현은 1024비트보다 작은 크기의 DSA 키를 구현해서는 안 됩니다. q 크기가 160비트 미만인 DSA 키를 구현하면 안 됩니다. DSA 키는 64비트의 배수여야 하며, q 크기는 8비트의 배수여야 합니다. 디지털 서명 표준\(DSS\) \[FIPS186\]에서는 DSA가 다음 방법 중 하나로 사용되도록 지정합니다.\(SHOULD NOT, MUST NOT, MUST\)

\* 1024비트 키, 160비트 q, SHA-1, SHA-224, SHA-256, SHA-384 또는 SHA-512 해시

\* 2048비트 키, 224비트 q, SHA-224, SHA-256, SHA-384 또는 SHA-512 해시

\* 2048비트 키, 256비트 q, SHA-256, SHA-384 또는 SHA-512 해시

\* 3072비트 키, 256비트 q, SHA-256, SHA-384 또는 SHA-512 해시

위의 키와 q 크기 쌍은 키의 강도와 해시의 강도의 균형을 가장 잘 맞추기 위해 선택되었습니다. 구현에서는 DSA 키를 생성할 때 위의 키와 q 크기 쌍 중 하나를 사용해야 합니다. DSS 규정 준수를 원하는 경우 지정된 SHA 해시 중 하나도 사용해야 합니다. \[FIPS186\]은 DSS에 대한 최종 권한을 갖고 있으며 DSS 준수에 관한 모든 질문에 대해 문의해야 합니다.\(SHOULD\)

이 표준의 이전 버전에서는 잘림이 허용되지 않는 160비트 q만 허용했기 때문에 이전 구현에서는 다른 q 크기 또는 잘린 해시가 있는 서명을 처리하지 못할 수도 있습니다.

---
### **13.7.  Elgamal**

구현은 1024비트보다 작은 크기의 Elgamal 키를 구현해서는 안 됩니다.\(SHOULD NOT\)

---
### **13.8.  Reserved Algorithm Numbers**

OpenPGP 구현에 사용하는 데 유용한 알고리즘을 위해 다수의 알고리즘 ID가 예약되어 있지만 구현자가 실제로 알고리즘을 구현하지 못하게 하는 문제가 있습니다. 이는 섹션 9.1, "공개 키 알고리즘"에 "예약됨"으로 표시되어 있습니다.

예약된 공개 키 알고리즘인 Elliptic Curve\(18\), ECDSA\(19\) 및 X9.42\(21\)에는 필요한 매개변수, 매개변수 순서 또는 정의된 의미가 없습니다.

이전 버전의 OpenPGP는 공개 키 식별자가 20인 Elgamal \[ELGAMAL\] 서명을 허용했습니다. 이는 더 이상 허용되지 않습니다. 구현은 그러한 키를 생성해서는 안 됩니다. 구현은 Elgamal 서명을 생성해서는 안 됩니다. \[BLEICHENBACHER\]를 참조하세요.\(MUST NOT, MUST NOT\)

---
### **13.9.  OpenPGP CFB Mode**

OpenPGP는 Cipher Feedback 모드\(CFB 모드\)의 변형을 사용하여 대칭 암호화를 수행합니다. 이 섹션에서는 사용되는 절차를 자세히 설명합니다. 이 모드는 대칭적으로 암호화된 데이터 패킷에 사용됩니다. 비밀 키 자료를 암호화하는 데 사용되는 메커니즘은 유사하며 위 섹션에서 설명합니다.

아래 설명에서 BS 값은 암호의 블록 크기\(옥텟\)입니다. 대부분의 암호의 블록 크기는 8옥텟입니다. AES와 Twofish의 블록 크기는 16옥텟입니다. 또한 아래 설명에서는 IV 및 CFB 배열이 인덱스 1로 시작한다고 가정합니다\(배열이 인덱스 0으로 시작한다고 가정하는 C 언어와는 다름\).

OpenPGP CFB 모드는 모두 0으로 구성된 초기화 벡터\(IV\)를 사용하고 일반 텍스트 앞에 임의 데이터의 BS+2 옥텟을 추가합니다. 즉, 옥텟 BS+1 및 BS+2가 옥텟 BS-1 및 BS와 일치합니다. BS+2 옥텟을 암호화한 후 CFB 재동기화를 수행합니다.

따라서 블록 크기가 8옥텟\(64비트\)인 알고리즘의 경우 IV는 길이가 10옥텟이고 IV의 옥텟 7 및 8은 옥텟 9 및 10과 동일합니다. 블록 크기가 16인 알고리즘의 경우 옥텟\(128비트\)의 경우 IV는 길이가 18옥텟이고 옥텟 17과 18은 옥텟 15와 16을 복제합니다. 이러한 추가 두 옥텟은 올바른 키를 쉽게 확인할 수 있습니다.

단계별 절차는 다음과 같습니다.

1. 피드백 레지스터\(FR\)는 모두 0인 IV로 설정됩니다.

2. FR을 암호화하여 FRE\(FR Encrypted\)를 생성합니다. 이는 모두 0인 값의 ​​암호화입니다.

3. FRE는 암호문의 첫 번째 BS 옥텟인 C\[1\]부터 C\[BS\]까지 생성하기 위해 일반 텍스트 앞에 붙은 무작위 데이터의 첫 번째 BS 옥텟과 결합됩니다.

4. FR은 C\[1\]부터 C\[BS\]까지 로드됩니다.

5. FR은 암호문의 첫 번째 BS 옥텟의 암호화인 FRE를 생성하기 위해 암호화됩니다.

6. FRE의 왼쪽 두 옥텟은 일반 텍스트 앞에 붙은 다음 두 옥텟의 데이터와 결합됩니다. 이는 암호문의 다음 두 옥텟인 C\[BS+1\] 및 C\[BS+2\]를 생성합니다.

7. \(재동기화 단계\) FR은 C\[3\]부터 C\[BS+2\]까지 로드됩니다.

8. FR은 FRE를 생성하기 위해 암호화됩니다.

9. FRE는 주어진 일반 텍스트의 첫 번째 BS 옥텟과 결합됩니다. 이제 접두사가 붙은 데이터의 BS+2 옥텟 암호화가 완료되었습니다. 이는 암호문의 다음 BS 옥텟인 C\[BS+3\]부터 C\[BS+\(BS+2\)\]까지 생성됩니다.

10. FR은 C\[BS+3\] \~ C\[BS + \(BS+2\)\]\(8옥텟 블록의 경우 C11-C18\)로 로드됩니다.

- 11. FR은 FRE를 생성하기 위해 암호화됩니다.

- 12. FRE는 다음 BS 옥텟의 일반 텍스트와 결합되어 다음 BS 옥텟의 암호문을 생성합니다. 이들은 FR에 로드되고 일반 텍스트가 다 사용될 때까지 프로세스가 반복됩니다.

---
### **13.10.  Private or Experimental Parameters**

섹션 9에 설명된 S2K 지정자, 서명 하위 패킷 유형, 사용자 속성 유형, 이미지 형식 유형 및 알고리즘은 모두 개인 및 실험용으로 100\~110 범위를 예약합니다. 패킷 유형은 개인용 및 실험용으로 60\~63 범위를 예약합니다. 이는 \[RFC2434\]에 설명된 대로 PRIVATE USE 방법으로 의도적으로 관리됩니다.

그러나 구현 시에는 이에 주의해야 하며 원래의 제한된 시스템 이상으로 성장할 경우 전체 IANA 관리 매개변수로 승격해야 합니다.

---
### **13.11.  Extension of the MDC System**

섹션 5.13의 비표준적인 설명에서 설명했듯이 MDC 시스템은 OpenPGP에서 고유하게 매개변수화되지 않습니다. 이는 크로스그레이드 공격을 피하기 위한 의도적인 결정이었습니다. MDC 시스템이 더 강력한 해시 기능으로 확장되는 경우 다운그레이드 및 크로스그레이드 공격을 방지하기 위해 주의를 기울여야 합니다.

이를 수행하는 간단한 방법 중 하나는 새 MDC에 대한 새 패킷을 생성하는 것입니다. 예를 들어, 패킷 18과 19를 사용하는 MDC 시스템 대신에 새로운 MDC가 20과 21을 사용할 수 있습니다. 이는 명백한 단점이 있습니다\(최대 60으로 제한된 공간에서 각각의 새로운 해시 함수에 대해 2개의 패킷 번호를 사용합니다\). .

MDC 시스템을 확장하는 또 다른 간단한 방법은 패킷 18의 새 버전을 생성하고 이를 패킷 19에 반영하는 것입니다. 예를 들어, 패킷 18의 V2가 암시적으로 SHA-256을 사용했다고 가정합니다. 이렇게 하려면 패킷 19의 길이가 32옥텟이어야 합니다. 패킷 18의 버전 변경과 패킷 19의 크기는 다운그레이드 공격을 방지합니다.

이 후자의 접근 방식에는 두 가지 단점이 있습니다. 첫 번째는 알고리즘 정보를 전달하기 위해 패킷의 버전 번호를 사용하는 것이 프로토콜 설계 관점에서 깔끔하지 않다는 것입니다. 일반적으로 사용되는 MDC 시스템의 여러 버전이 있을 수 있지만 이러한 어수선함은 해시 함수 보안에 대한 암호화 합의의 어수선함을 반영합니다. 두 번째는 패킷 19의 다양한 버전이 고유한 크기를 가져야 한다는 것입니다. 각각 256비트 해시를 가진 두 가지 버전이 있는 경우 크로스그레이드 공격의 가능성을 인정하지 않고는 둘 다 32옥텟 패킷 19를 가질 수 없습니다.

MDC 시스템을 확장하기 위한 또 다른 복잡한 접근 방식은 위의 두 가지 방법을 혼합한 것입니다. 즉, 완전히 매개변수화되어 있으면서도 다운그레이드 및 크로스그레이드로부터 보호되는 새로운 MDC 패킷 쌍을 생성하는 것입니다.

MDC 시스템에 대한 모든 변경은 \[RFC2434\]에 설명된 대로 IETF CONSENSUS 방법을 통해 수행되어야 합니다.\(MUST\)

---
### **13.12.  Meta-Considerations for Expansion**

OpenPGP가 이전 버전과 호환되지 않는 방식으로 확장된 경우, 이는 이전 구현이 해당 OpenPGP를 정상적으로 처리하지 못한다는 것을 의미합니다.

새로운 기능이 없으면 확장 제안은 기능 서명 서브패킷의 일부로 키 보유자의 자체 서명에서 선언될 수 있습니다.

어떤 확장이 상위 버전과 호환되지 않는지 확실히 말할 수는 없지만 일반적으로 새로운 알고리즘은 상위 버전과 호환되는 반면 새 패킷은 그렇지 않습니다.

확장 제안이 기능 시스템을 업데이트하지 않는 경우 이것이 불필요한 이유에 대한 설명을 포함해야 합니다. 제안에 기능 시스템에 대한 확장이나 그러한 확장이 불필요한 이유에 대한 설명이 포함되어 있지 않으면 해당 제안을 거부해야 합니다\(SHOULD\).\(SHOULD, SHOULD\)

---
## **14.  Security Considerations**

\* 암호화와 관련된 기술과 마찬가지로 현재 문헌을 확인하여 여기에 사용된 알고리즘이 공격에 취약한 것으로 확인되었는지 확인해야 합니다.

\* 본 사양은 공개키 암호화 기술을 사용합니다. 공개-개인 키 쌍의 개인 키 부분은 적절한 당사자에 의해 제어되고 보호된다고 가정합니다.

\* 이 사양의 특정 작업에는 난수 사용이 포함됩니다. 이러한 숫자를 생성하려면 적절한 엔트로피 소스를 사용해야 합니다\(\[RFC4086\] 참조\).

\* MD5 해시 알고리즘은 여러 가지 경우에 충돌이 발견되는 등 약점이 있는 것으로 확인되었습니다. MD5는 OpenPGP에서 더 이상 사용되지 않습니다. 구현은 MD5를 해시 함수로 사용하여 새로운 서명을 생성해서는 안 됩니다. 그들은 MD5를 유효한 것으로 사용한 이전 서명을 계속해서 고려할 수 있습니다.\(MUST NOT, MAY\)

\* SHA-224 및 SHA-384에는 각각 SHA-256 및 SHA-512와 동일한 작업이 필요합니다. 일반적으로 DSS 호환성 외에 이를 사용하는 데에는 몇 가지 이유가 있습니다. 작은 해시보다 더 많은 보안이 필요하지만 전체 256비트 또는 512비트 데이터 길이를 원하지 않는 상황이 필요합니다.

\* 많은 보안 프로토콜 설계자들은 개인 정보 보호\(암호화\)와 무결성\(서명\)을 모두 위해 단일 키를 사용하는 것은 좋지 않은 생각이라고 생각합니다. 실제로 이는 별도의 서명 및 암호화 키를 사용하는 V4 키 형식을 뒷받침하는 원동력 중 하나였습니다. 구현자로서 이중 사용 키를 홍보하는 경우 최소한 이 논란에 대해 알고 있어야 합니다.

\* DSA 알고리즘은 모든 해시에서 작동하지만 해시 알고리즘의 품질에 민감합니다. 검증자는 서명자가 강력한 해시를 사용하더라도 공격자가 약한 해시를 사용하도록 서명을 수정할 수 있다는 점을 인식해야 합니다. 허용 가능한 강력한 해시 알고리즘을 사용하는 서명만 유효한 것으로 승인되어야 합니다.

\* OpenPGP는 다양한 비대칭, 대칭 및 해시 알고리즘을 결합하고 각각 서로 다른 강도 측정값을 갖기 때문에 OpenPGP 메시지의 가장 약한 요소가 여전히 현재 목적에 맞게 충분히 강력하다는 점에 주의해야 합니다. 특정 알고리즘의 강점에 대한 합의가 발전할 수 있지만 NIST 특별 간행물 800-57 \[SP800-57\]에서는 다음과 같은 동등한 강점 목록을 권장합니다.

```text
           Asymmetric  |  Hash  |  Symmetric
            key size   |  size  |   key size
           ------------+--------+-----------
              1024        160         80
              2048        224        112
              3072        256        128
              7680        384        192
             15360        512        256
```

\* 서명에는 다소 관련된 잠재적인 보안 문제가 있습니다. 공격자가 다른 알고리즘을 사용하여 동일한 해시로 해시하는 메시지를 찾을 수 있는 경우 올바르게 평가되는 가짜 서명 구조가 구성될 수 있습니다.

예를 들어, Alice DSA가 해시 알고리즘 H를 사용하여 메시지 M에 서명한다고 가정합니다. Mallet이 H'를 사용하여 M과 동일한 해시 값을 갖는 메시지 M'을 찾았다고 가정합니다. 그런 다음 Mallet은 Alice의 M' 서명과 H'를 확인하는 서명 블록을 구성할 수 있습니다. 그러나 이는 H나 H' 또는 둘 다의 약점이기도 합니다. 이런 일이 발생하면 허용되는 해시 알고리즘을 수정하기 위해 이 문서를 수정해야 합니다.

\* 인증 시스템을 구축하는 경우 수신자가 선호하는 서명 알고리즘을 지정할 수 있습니다. 그러나 단순히 수신자가 요청했다는 이유만으로 약한 알고리즘을 사용하는 것은 서명자가 어리석은 일입니다.

\* 본 문서에 언급된 암호화 알고리즘 중 일부는 다른 암호화 알고리즘에 비해 덜 분석되었습니다. 예를 들어 CAST5는 현재 강력한 것으로 간주되지만 TripleDES보다 덜 분석되었습니다. 다른 알고리즘에는 이를 둘러싼 다른 논란이 있을 수 있습니다.

\* 2002년 늦여름에 Jallad, Katz 및 Schneier는 OpenPGP 프로토콜과 그 구현 중 일부에 대한 흥미로운 공격을 발표했습니다\[JKS02\]. 이 공격에서는 공격자가 메시지를 수정하여 사용자에게 보낸 다음 잘못 해독된 메시지를 공격자에게 반환합니다. 따라서 공격자는 사용자를 임의의 오라클로 사용하고 있으며 종종 메시지를 해독할 수 있습니다.

데이터를 압축하면 이 공격을 개선할 수 있습니다. 잘못 해독된 데이터는 거의 항상 공격을 물리칠 수 있는 방식으로 압축이 풀립니다. 그러나 이는 엄격한 수정이 아니며 일부 작은 취약점이 남아 있습니다. 예를 들어 구현이 암호화 전에 메시지를 압축하지 않으면\(아마도 메시지가 이미 압축되었음을 알고 있기 때문에\) 해당 메시지는 취약합니다. 압축 해제 오류로 인해 수정 공격이 방해받을 수 있는 이러한 우연한 상황 때문에 구현에서는 압축 해제 오류를 단순한 데이터 문제가 아닌 보안 문제로 처리해야 합니다.\(SHOULD\)

이 공격은 사용자가 순진하게 데이터를 공격자에게 반환하는 것을 허용하지 않는 경우 수정 탐지를 사용하여 물리칠 수 있습니다. 구현에서는 MDC 실패를 단순한 데이터 문제가 아닌 보안 문제로 처리해야 합니다.\(MUST\)

두 경우 모두 구현 시 잘못된 데이터에 대한 사용자 액세스를 허용할 수 있지만 해당 데이터가 보낸 사람에게 반환될 경우 잠재적인 보안 문제에 대해 사용자에게 경고해야 합니다.\(MUST\)

이 공격은 다소 모호하여 이를 생성하려면 특별한 상황이 필요하지만 그럼에도 불구하고 누군가가 메시지를 해독하도록 사용자를 속일 수 있다는 점에서 매우 심각합니다. 결과적으로 다음이 중요합니다.

- 1. 구현자는 MDC 오류 및 압축 해제 실패를 보안 문제로 취급합니다.

- 2. 구현자는 수정 감지를 적절한 속도로 구현하고 확산을 장려합니다.

- 3. 사용자는 모든 적절한 속도로 수정 감지를 지원하는 구현으로 마이그레이션합니다.

\* PKCS#1은 패딩 오류와 복호화 오류를 다르게 보고하는 시스템이 수백만 번의 쿼리만으로 개인 키를 유출할 수 있는 임의의 오라클이 되는 공격에 취약한 것으로 밝혀졌습니다. 구현에서는 이 공격을 인지하고 발생을 방지해야 합니다. 가장 간단한 해결책은 공격자에게 정보가 유출되지 않도록 모든 변형된 암호 해독 오류에 대해 단일 오류 코드를 보고하는 것입니다.

\* 여기에 언급된 일부 기술은 일부 국가에서 정부의 통제를 받을 수 있습니다.

\* 2005년 겨울, Entrust의 Serge Mister와 Robert Zuccherato는 OpenPGP CFB 모드의 "빠른 검사"를 무작위 오라클과 함께 사용하여 모든 암호 블록의 두 옥텟을 해독할 수 있는 방법을 설명하는 논문을 발표했습니다\[MZ05\]. 예방 차원에서 퀵 체크를 전혀 사용하지 않는 것이 좋습니다.

많은 구현자는 대칭적으로 암호화되고 세션 키가 공개 키로 암호화된 모든 데이터에 대해 이 조언을 마음에 새겼습니다. 이 경우 세션 키의 공개 키 암호화가 올바른 세션 키임을 보장해야 하므로 빠른 확인이 필요하지 않습니다. 다른 경우에는 구현 시 빠른 검사를 주의해서 사용해야 합니다.

한편으로는 공격자에게 정보를 유출할 수 있는 임의의 오라클이 있는 경우 이를 사용하는 데 위험이 있습니다. 좀 더 쉽게 말하면, 검사에 대한 타이밍 정보가 특히 빠르게 반복되는 쿼리를 허용하는 자동화된 서비스를 통해 공격자에게 노출될 수 있는 경우 빠른 검사를 사용하는 것은 위험합니다.

반면에, 페타바이트 규모의 데이터가 해독된 후에야 잘못된 암호를 입력했다는 사실을 사용자가 알게 되는 것은 불편합니다. 암호화 엔지니어링에는 구현자가 주의와 지혜를 기울여야 하는 경우가 많이 있는데, 이것이 바로 그 중 하나입니다.

---
## **15.  Implementation Nits**

이 섹션은 특히 이전 버전과의 호환성 측면에서 구현자에게 도움이 되는 설명 모음입니다. 이전 PGP 구현은 OpenPGP와 호환되지 않습니다. 종종 차이는 작지만, 작은 차이가 큰 차이보다 더 짜증나는 경우가 많습니다. 따라서 이는 이전 버전과 호환되도록 노력하는 개발자를 위한 잠재적인 문제와 문제점에 대한 포괄적이지 않은 목록입니다.

\* IDEA 알고리즘은 특허를 받았지만 PGP 2.x 상호 운용성을 위해 필요합니다. 이는 또한 V3 자체 서명이 있는\(또는 자체 서명이 없는\) V3 키에 대해 사실상 선호되는 알고리즘이기도 합니다.

\* 개인 키를 내보낼 때 PGP 2.x는 "BEGIN PGP PRIVATE KEY BLOCK" 대신 "BEGIN PGP SECRET KEY BLOCK" 헤더를 생성합니다. 이전 버전에서는 모두 묵시적인 데이터 유형을 무시하고 패킷 데이터 유형을 직접 살펴봅니다.

\* PGP 2.0\~2.5에서는 V2 공개 키 패킷이 생성되었습니다. 이는 버전 번호를 제외하고 더 이상 사용되지 않는 V3 키와 동일합니다. 구현은 이를 생성해서는 안 되며 적절하다고 판단되면 이를 수락하거나 거부할 수 있습니다. 일부 이전 PGP 버전에서는 V2 PKESK 패킷\(태그 1\)도 생성되었습니다. 구현은 적절하다고 판단되는 V2 PKESK 패킷을 수락하거나 거부할 수 있으며 패킷을 생성해서는 안 됩니다.\(MUST NOT, MUST NOT\)

\* PGP 2.6.x는 버전 3보다 큰 키 자료 패킷을 허용하지 않습니다.

\* 두 개의 키가 동일한 키 자료를 가지지만 지문\(따라서 키 ID\)이 다른 경우는 여러 가지가 있습니다. 아마도 가장 흥미로운 것은 V4 형식으로 "업그레이드"된 RSA 키일 것입니다. 그러나 V4 지문은 키 생성 시간을 다른 것들과 함께 해싱하여 구성되므로 두 개의 V4 키가 서로 다른 시간에 생성되지만 키 자료는 동일합니다. 다른 지문을 가지게 됩니다.

\* 구현이 zlib를 사용하여 PGP 2.x와 상호 운용되는 경우 "windowBits" 매개변수를 -13으로 설정해야 합니다.

\* 비교적 최근까지는 하위 키 서명에 0x19 백 서명이 필요하지 않았습니다. 결과적으로 이러한 백서명이 없는 키가 실제로 있을 수 있습니다. 소프트웨어를 구현하면 적절하다고 판단되는 대로 이러한 키를 처리할 수 있습니다.

\* OpenPGP는 공개 키의 크기에 제한을 두지 않습니다. 그러나 더 큰 키가 반드시 더 좋은 키는 아닙니다. 키가 클수록 사용하는 데 더 많은 계산 시간이 걸리며 이는 금방 실용적이지 않게 될 수 있습니다. 다양한 OpenPGP 구현에서는 공개 키 크기에 대해 서로 다른 상한을 사용할 수도 있으므로 상호 운용성을 유지하기 위해 크기를 선택할 때는 주의해야 합니다. 2007년 현재 대부분의 구현에는 4096비트의 상한이 있습니다.

\* ASCII Armor는 OpenPGP의 선택적 기능입니다. OpenPGP 작업 그룹은 최소한의 필수 구현 기능 세트를 위해 노력하고 있으며 바이너리 객체 형식만 사용하는 유용한 구현이 있을 수 있으므로 이는 구현에 "필수" 기능이 아닙니다. 예를 들어 OpenPGP를 파일 서명 메커니즘으로 사용하는 구현에서는 ASCII 갑옷이 불필요하다고 생각할 수 있습니다. OpenPGP는 구현이 지원하는 기능과 지원하지 않는 기능을 선언하는 것을 허용하지만 ASCII armor는 이러한 기능 중 하나가 아닙니다. 대부분의 구현에서는 바이너리 및 Armored 개체를 무분별하게 사용할 수 있으므로 ASCII Armor를 구현하지 않는 구현은 범용 구현과의 호환성 문제가 발생할 수 있습니다. 게다가 OpenPGP-MIME \[RFC3156\]의 구현에는 이미\(MUST\)

- ASCII armor에 대한 요구 사항이므로 해당 구현에는 반드시 지원이 필요합니다.

---
## **16.  References**
---
### **16.1.  Normative References**

```text
   [AES]            NIST, FIPS PUB 197, "Advanced Encryption Standard
                    (AES)," November 2001.
                    http://csrc.nist.gov/publications/fips/fips197/fips-
                    197.{ps,pdf}
```

\[복어\] Schneier, B. "새로운 가변 길이 키에 대한 설명, 64비트 블록 암호\(복어\)" 빠른 소프트웨어 암호화, Cambridge Security Workshop Proceedings\(1993년 12월\), Springer-Verlag, 1994, pp191-204 <http ://www.counterpane.com/bfsverlag.html\>

\[BZ2\] J. Seward, jseward@acm.org, "Bzip2 및 libbzip2 홈 페이지" <http://www.bzip.org/\>

\[ELGAMAL\] T. Elgamal, "이산 로그에 기반한 공개 키 암호화 시스템 및 서명 체계", IEEE Transactions on Information Theory, v. IT-31, n. 4, 1985, pp. 469-472.

```text
   [FIPS180]        Secure Hash Signature Standard (SHS) (FIPS PUB 180-
                    2).
                    <http://csrc.nist.gov/publications/fips/fips180-
                    2/fips180-2withchangenotice.pdf>
```

\[FIPS186\] 디지털 서명 표준\(DSS\)\(FIPS PUB 186-2\). <http://csrc.nist.gov/publications/fips/fips186-2/fips186-2-change1.pdf\> FIPS 186-3은 1024비트보다 큰 키를 설명합니다. 최신 초안은 <http://csrc.nist.gov/publications/drafts/fips\_186-3/Draft-FIPS-186-3%20\_March2006.pdf\>에 있습니다.

\[HAC\] Alfred Menezes, Paul van Oorschot 및 Scott Vanstone, "응용 암호학 핸드북", CRC Press, 1996. <http://www.cacr.math.uwaterloo.ca/hac/\>

\[IDEA\] Lai, X, "블록 암호의 설계 및 보안", 정보 처리 분야의 ETH 시리즈, J.L. Massey\(편집자\), Vol. 1, Hartung-Gorre Verlag Knostanz, Technische Hochschule\(취리히\), 1992

\[ISO10646\] ISO/IEC 10646-1:1993. 국제 표준 - 정보 기술 - 범용 다중 옥텟 코드 문자 집합\(UCS\) - 1부: 아키텍처 및 기본 다국어 평면.

```text
   [JFIF]           JPEG File Interchange Format (Version 1.02).  Eric
                    Hamilton, C-Cube Microsystems, Milpitas, CA,
                    September 1, 1992.
```

\[RFC1950\] Deutsch, P. 및 J-L. Gailly, "ZLIB 압축 데이터 형식 사양 버전 3.3", RFC 1950, 1996년 5월.

```text
   [RFC1951]        Deutsch, P., "DEFLATE Compressed Data Format
                    Specification version 1.3", RFC 1951, May 1996.
```

\[RFC2045\] Freed, N. 및 N. Borenstein, "다목적 인터넷 메일 확장\(MIME\) 1부: 인터넷 메시지 본문 형식", RFC 2045, 1996년 11월

\[RFC2119\] Bradner, S., "요구 사항 수준을 나타내기 위해 RFC에서 사용할 핵심 단어", BCP 14, RFC 2119, 1997년 3월.

```text
   [RFC2144]        Adams, C., "The CAST-128 Encryption Algorithm", RFC
                    2144, May 1997.
```

\[RFC2434\] Narten, T. 및 H. Alvestrand, "RFC에서 IANA 고려 사항 섹션 작성 지침", BCP 26, RFC 2434, 1998년 10월.

```text
   [RFC2822]        Resnick, P., "Internet Message Format", RFC 2822,
                    April 2001.
```

\[RFC3156\] Elkins, M., Del Torto, D., Levien, R. 및 T. Roessler, "OpenPGP를 사용한 MIME 보안", RFC 3156, 2001년 8월.

\[RFC3447\] Jonsson, J. 및 B. Kaliski, "공개 키 암호화 표준\(PKCS\) #1: RSA 암호화 사양 버전 2.1", RFC 3447, 2003년 2월.

\[RFC3629\] Yergeau, F., "UTF-8, ISO 10646의 변환 형식", STD 63, RFC 3629, 2003년 11월.

\[RFC4086\] Eastlake, D., 3rd, Schiller, J. 및 S. Crocker, "보안을 위한 무작위성 요구 사항", BCP 106, RFC 4086, 2005년 6월.

\[SCHNEIER\] Schneier, B., "응용 암호화 제2판: C의 프로토콜, 알고리즘 및 소스 코드", 1996.

\[TWOFISH\] B. Schneier, J. Kelsey, D. Whiting, D. Wagner, C. Hall 및 N. Ferguson, "Twofish 암호화 알고리즘", John Wiley & Sons, 1999.

---
### **16.2.  Informative References**

\[BLEICHENBACHER\] 블레이헨바허, 다니엘, "엘가말 생성

- 비밀 키를 모르는 서명", Eurocrypt 96. 절차의 버전에 오류가 있음을 참고하십시오. 수정된 버전은 작성 당시 <ftp://ftp.inf.ethz.ch/pub/publications에서 사용할 수 있습니다. /papers/ti /isc/ElGamal.ps\>

\[JKS02\] 카힐 잘라드, 조나단 카츠, 브루스 슈나이어

- "PGP 및 GnuPG에 대한 선택 암호문 공격 구현" http://www.counterpane.com/pgp-attack.html

\[MAURER\] Ueli Maurer, "공개 키 모델링

- 인프라", Proc. 1996 컴퓨터 보안 연구에 관한 유럽 심포지엄\(ESORICS' 96\), 컴퓨터 과학 강의 노트, Springer-Verlag, vol. 1146, pp. 325-350, 1996년 9월.

\[MZ05\] Serge Mister, Robert Zuccherato, "OpenPGP에서 사용되는 CFB 모드 암호화에 대한 공격", IACR ePrint 아카이브: 보고서 2005/033, 2005년 2월 8일 http://eprint.iacr.org/2005/033

```text
   [REGEX]          Jeffrey Friedl, "Mastering Regular Expressions,"
                    O'Reilly, ISBN 0-596-00289-0.
```

\[RFC1423\] Balenson, D., "인터넷 전자 메일의 개인 정보 보호 강화: 파트 III: 알고리즘, 모드 및 식별자", RFC 1423, 1993년 2월.

\[RFC1991\] Atkins, D., Stallings, W. 및 P. Zimmermann, "PGP 메시지 교환 형식", RFC 1991, 1996년 8월.

\[RFC2440\] Callas, J., Donnerhacke, L., Finney, H. 및 R. Thayer, "OpenPGP 메시지 형식", RFC 2440, 1998년 11월.

\[SP800-57\] NIST 특별 간행물 800-57, 키 관리에 대한 권장사항 <http://csrc.nist.gov/publications/nistpubs/ 800-57/SP800-57-Part1.pdf\> <http://csrc. nist.gov/publications/nistpubs/800-57/SP800-57-Part2.pdf\>

---
# **Acknowledgements**

이 메모는 또한 Derek Atkins, Charles Breed, Dave Del Torto, Marc Dyksterhouse, Gail Haspert, Gene Hoffman, Paul Hoffman, Ben Laurie, Raph Levien, Colin Plumb, Will Price를 포함한 여러 다른 저자의 이전 작업을 바탕으로 작성되었습니다. , 데이비드 쇼, 윌리엄 스톨링스, 마크 위버, 필립 R. 짐머만.

---
# **Authors' Addresses**

실무그룹은 현재 의장을 통해 연락할 수 있습니다.

```text
      Derek Atkins
      IHTFP Consulting, Inc.
      4 Farragut Ave
      Somerville, MA  02144  USA

      EMail: derek@ihtfp.com
      Tel: +1 617 623 3745
```

이 문서의 주요 작성자는 다음과 같습니다.

```text
      Jon Callas
      EMail: jon@callas.org

      Lutz Donnerhacke
      IKS GmbH
      Wildenbruchstr. 15
      07745 Jena, Germany
      EMail: lutz@iks-jena.de

      Hal Finney
      EMail: hal@finney.org

      David Shaw
      EMail: dshaw@jabberwocky.com

      Rodney Thayer
      EMail: rodney@canola-jones.com
```

---
# **Full Copyright Statement**

저작권\(C\) IETF 트러스트\(2007\).

이 문서는 BCP 78에 포함된 권리, 라이선스 및 제한 사항의 적용을 받으며 여기에 명시된 경우를 제외하고 작성자는 모든 권리를 보유합니다.

이 문서 및 여기에 포함된 정보는 "있는 그대로" 제공되며 기여자, 기여자가 대표하거나 후원하는 조직\(있는 경우\), 인터넷 협회, IETF 트러스트 및 인터넷 엔지니어링 태스크포스는 모든 내용을 부인합니다. 여기에 포함된 정보의 사용이 특정 목적에 대한 상품성 또는 적합성에 대한 권리 또는 묵시적 보증을 침해하지 않는다는 보증을 포함하되 이에 국한되지 않는 명시적 또는 묵시적 보증.

---
# **Intellectual Property**

IETF는 이 문서에 설명된 기술의 구현 또는 사용과 관련이 있다고 주장할 수 있는 지적 재산권 또는 기타 권리의 유효성 또는 범위 또는 그러한 권리에 따른 라이센스의 범위에 대해 어떠한 입장도 취하지 않습니다. 는 가능하다; 또한 그러한 권리를 식별하기 위해 독립적인 노력을 기울였다는 것을 나타내지 않습니다. RFC 문서의 권리와 관련된 절차에 대한 정보는 BCP 78 및 BCP 79에서 찾을 수 있습니다.

IETF 사무국에 제출된 IPR 공개 사본 및 사용 가능한 라이선스에 대한 보증 또는 이 사양의 구현자 또는 사용자가 이러한 독점권 사용에 대한 일반 라이선스 또는 허가를 얻으려는 시도의 결과를 얻을 수 있습니다. http://www.ietf.org/ipr의 IETF 온라인 IPR 저장소에서.

IETF는 이 표준을 구현하는 데 필요할 수 있는 기술을 포함할 수 있는 저작권, 특허 또는 특허 출원 또는 기타 소유권에 관심을 갖도록 이해 당사자를 초대합니다. 정보를 IETF\(ietf-ipr@ietf.org\)로 보내주십시오.
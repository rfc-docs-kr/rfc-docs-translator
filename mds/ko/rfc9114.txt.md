

```text
﻿

Internet Engineering Task Force (IETF)                    M. Bishop, Ed.
Request for Comments: 9114                                        Akamai
Category: Standards Track                                      June 2022
ISSN: 2070-1721

                                 HTTP/3
```

---
# **Abstract**

QUIC 전송 프로토콜에는 스트림 다중화, 스트림별 흐름 제어 및 낮은 대기 시간 연결 설정과 같은 HTTP 전송에 바람직한 여러 기능이 있습니다. 이 문서는 QUIC를 통한 HTTP 의미론의 매핑을 설명합니다. 이 문서는 또한 QUIC에 포함된 HTTP/2 기능을 식별하고 HTTP/2 확장을 HTTP/3으로 포팅할 수 있는 방법을 설명합니다.

---
# **Status of This Memo**

이것은 인터넷 표준 추적 문서입니다.

이 문서는 IETF\(Internet Engineering Task Force\)의 제품입니다. 이는 IETF 커뮤니티의 합의를 나타냅니다. 공개 검토를 받았으며 IESG\(Internet Engineering Steering Group\)의 출판 승인을 받았습니다. 인터넷 표준에 대한 자세한 내용은 RFC 7841의 섹션 2에서 확인할 수 있습니다.

이 문서의 현재 상태, 정오표, 피드백 제공 방법에 대한 정보는 https://www.rfc-editor.org/info/rfc9114에서 확인할 수 있습니다.

---
# **Copyright Notice**

Copyright \(c\) 2022 IETF Trust 및 문서 작성자로 확인된 사람. 판권 소유.

이 문서는 이 문서의 발행일에 유효한 BCP 78 및 IETF 문서에 관한 IETF 트러스트의 법적 조항\(https://trustee.ietf.org/license-info\)의 적용을 받습니다. 이 문서와 관련된 귀하의 권리 및 제한 사항을 설명하므로 이 문서를 주의 깊게 검토하십시오. 이 문서에서 추출한 코드 구성요소는 Trust Legal Provisions의 섹션 4.e에 설명된 대로 개정된 BSD 라이센스 텍스트를 포함해야 하며 개정된 BSD 라이센스에 설명된 대로 보증 없이 제공됩니다.

---
# **Table of Contents**

```text
   1.  Introduction
     1.1.  Prior Versions of HTTP
     1.2.  Delegation to QUIC
   2.  HTTP/3 Protocol Overview
     2.1.  Document Organization
     2.2.  Conventions and Terminology
   3.  Connection Setup and Management
     3.1.  Discovering an HTTP/3 Endpoint
       3.1.1.  HTTP Alternative Services
       3.1.2.  Other Schemes
     3.2.  Connection Establishment
     3.3.  Connection Reuse
   4.  Expressing HTTP Semantics in HTTP/3
     4.1.  HTTP Message Framing
       4.1.1.  Request Cancellation and Rejection
       4.1.2.  Malformed Requests and Responses
     4.2.  HTTP Fields
       4.2.1.  Field Compression
       4.2.2.  Header Size Constraints
     4.3.  HTTP Control Data
       4.3.1.  Request Pseudo-Header Fields
       4.3.2.  Response Pseudo-Header Fields
     4.4.  The CONNECT Method
     4.5.  HTTP Upgrade
     4.6.  Server Push
   5.  Connection Closure
     5.1.  Idle Connections
     5.2.  Connection Shutdown
     5.3.  Immediate Application Closure
     5.4.  Transport Closure
   6.  Stream Mapping and Usage
     6.1.  Bidirectional Streams
     6.2.  Unidirectional Streams
       6.2.1.  Control Streams
       6.2.2.  Push Streams
       6.2.3.  Reserved Stream Types
   7.  HTTP Framing Layer
     7.1.  Frame Layout
     7.2.  Frame Definitions
       7.2.1.  DATA
       7.2.2.  HEADERS
       7.2.3.  CANCEL_PUSH
       7.2.4.  SETTINGS
       7.2.5.  PUSH_PROMISE
       7.2.6.  GOAWAY
       7.2.7.  MAX_PUSH_ID
       7.2.8.  Reserved Frame Types
   8.  Error Handling
     8.1.  HTTP/3 Error Codes
   9.  Extensions to HTTP/3
   10. Security Considerations
     10.1.  Server Authority
     10.2.  Cross-Protocol Attacks
     10.3.  Intermediary-Encapsulation Attacks
     10.4.  Cacheability of Pushed Responses
     10.5.  Denial-of-Service Considerations
       10.5.1.  Limits on Field Section Size
       10.5.2.  CONNECT Issues
     10.6.  Use of Compression
     10.7.  Padding and Traffic Analysis
     10.8.  Frame Parsing
     10.9.  Early Data
     10.10. Migration
     10.11. Privacy Considerations
   11. IANA Considerations
     11.1.  Registration of HTTP/3 Identification String
     11.2.  New Registries
       11.2.1.  Frame Types
       11.2.2.  Settings Parameters
       11.2.3.  Error Codes
       11.2.4.  Stream Types
   12. References
     12.1.  Normative References
     12.2.  Informative References
   Appendix A.  Considerations for Transitioning from HTTP/2
     A.1.  Streams
     A.2.  HTTP Frame Types
       A.2.1.  Prioritization Differences
       A.2.2.  Field Compression Differences
       A.2.3.  Flow-Control Differences
       A.2.4.  Guidance for New Frame Type Definitions
       A.2.5.  Comparison of HTTP/2 and HTTP/3 Frame Types
     A.3.  HTTP/2 SETTINGS Parameters
     A.4.  HTTP/2 Error Codes
       A.4.1.  Mapping between HTTP/2 and HTTP/3 Errors
   Acknowledgments
   Index
   Author's Address
```

---
## **1.  Introduction**

HTTP 의미 체계\(\[HTTP\]\)는 인터넷의 광범위한 서비스에 사용됩니다. 이러한 의미 체계는 HTTP/1.1 및 HTTP/2에서 가장 일반적으로 사용되었습니다. HTTP/1.1은 다양한 전송 및 세션 계층에서 사용된 반면, HTTP/2는 주로 TCP를 통한 TLS와 함께 사용되었습니다. HTTP/3은 새로운 전송 프로토콜인 QUIC에 대해 동일한 의미를 지원합니다.

---
### **1.1.  Prior Versions of HTTP**

HTTP/1.1\(\[HTTP/1.1\]\)은 공백으로 구분된 텍스트 필드를 사용하여 HTTP 메시지를 전달합니다. 이러한 교환은 사람이 읽을 수 있지만 메시지 형식화에 공백을 사용하면 구문 분석이 복잡해지고 변형 동작에 대한 과도한 허용이 발생합니다.

HTTP/1.1에는 다중화 계층이 포함되어 있지 않기 때문에 여러 TCP 연결을 사용하여 요청을 병렬로 처리하는 경우가 많습니다. 그러나 이는 TCP가 여러 연결에서 정체 제어를 공유하지 않기 때문에 정체 제어 및 네트워크 효율성에 부정적인 영향을 미칩니다.

HTTP/2\(\[HTTP/2\]\)는 전송 계층을 수정하지 않고도 대기 시간을 개선하기 위해 바이너리 프레이밍 및 다중화 계층을 도입했습니다. 그러나 HTTP/2 멀티플렉싱의 병렬 특성은 TCP의 손실 복구 메커니즘에 표시되지 않기 때문에 패킷이 손실되거나 재정렬되면 해당 트랜잭션이 손실된 패킷의 직접적인 영향을 받았는지 여부에 관계없이 모든 활성 트랜잭션이 중단됩니다.

---
### **1.2.  Delegation to QUIC**

QUIC 전송 프로토콜은 HTTP/2 프레이밍 계층에서 제공하는 것과 유사한 스트림 다중화 및 스트림별 흐름 제어를 통합합니다. QUIC는 스트림 수준의 안정성과 전체 연결에 대한 혼잡 제어를 제공함으로써 TCP 매핑에 비해 HTTP 성능을 향상시키는 기능을 갖추고 있습니다. QUIC은 또한 전송 계층에 TLS 1.3\(\[TLS\]\)을 통합하여 TCP Fast Open\(\[TFO\]\)의 향상된 연결 설정 대기 시간과 함께 TCP를 통해 TLS를 실행하는 것과 비슷한 기밀성과 무결성을 제공합니다.

이 문서는 HTTP/3, 즉 QUIC 전송 프로토콜을 통한 HTTP 의미론의 매핑을 정의하며 HTTP/2 설계에 크게 의존합니다. HTTP/3은 QUIC를 사용하여 데이터의 기밀성과 무결성 보호를 제공합니다. 피어 인증; 안정적이고 순서대로 스트림별로 전달됩니다. 스트림 수명 및 흐름 제어 문제를 QUIC에 위임하는 동안 HTTP/2 프레이밍과 유사한 바이너리 프레이밍이 각 스트림에서 사용됩니다. 일부 HTTP/2 기능은 QUIC에 포함되는 반면 다른 기능은 QUIC 위에 구현됩니다.

QUIC은 \[QUIC-TRANSPORT\]에 설명되어 있습니다. HTTP/2에 대한 자세한 설명은 \[HTTP/2\]를 참조하세요.

---
## **2.  HTTP/3 Protocol Overview**

HTTP/3은 QUIC 전송 프로토콜과 HTTP/2와 유사한 내부 프레이밍 계층을 사용하여 HTTP 의미 체계에 대한 전송을 제공합니다.

클라이언트가 특정 엔드포인트에 HTTP/3 서버가 존재한다는 것을 알게 되면 QUIC 연결을 엽니다. QUIC은 프로토콜 협상, 스트림 기반 다중화 및 흐름 제어를 제공합니다. HTTP/3 엔드포인트 검색은 섹션 3.1에 설명되어 있습니다.

각 스트림 내에서 HTTP/3 통신의 기본 단위는 프레임입니다\(7.2절\). 각 프레임 유형은 서로 다른 용도로 사용됩니다. 예를 들어 HEADERS 및 DATA 프레임은 HTTP 요청 및 응답의 기초를 형성합니다\(섹션 4.1\). 전체 연결에 적용되는 프레임은 전용 제어 스트림을 통해 전달됩니다.

요청의 다중화는 \[QUIC-TRANSPORT\]의 섹션 2에 설명된 QUIC 스트림 추상화를 사용하여 수행됩니다. 각 요청-응답 쌍은 단일 QUIC 스트림을 사용합니다. 스트림은 서로 독립적이므로 하나의 스트림이 차단되거나 패킷 손실이 발생하더라도 다른 스트림의 진행이 방해받지 않습니다.

서버 푸시는 HTTP/2\(\[HTTP/2\]\)에 도입된 상호 작용 모드로, 클라이언트가 지정된 요청을 할 것을 예상하여 서버가 요청-응답 교환을 클라이언트에 푸시할 수 있도록 합니다. 이는 잠재적인 대기 시간 증가와 네트워크 사용량을 절충합니다. PUSH\_PROMISE, MAX\_PUSH\_ID 및 CANCEL\_PUSH와 같은 여러 HTTP/3 프레임이 서버 푸시를 관리하는 데 사용됩니다.

HTTP/2와 마찬가지로 요청 및 응답 필드는 전송을 위해 압축됩니다. HPACK\(\[HPACK\]\)은 압축된 필드 섹션의 순차적 전송\(QUIC에서 제공되지 않는 보장\)에 의존하기 때문에 HTTP/3은 HPACK을 QPACK\(\[QPACK\]\)으로 대체합니다. QPACK은 별도의 단방향 스트림을 사용하여 필드 테이블 상태를 수정하고 추적하는 반면, 인코딩된 필드 섹션은 테이블을 수정하지 않고 테이블 상태를 참조합니다.

---
### **2.1.  Document Organization**

다음 섹션에서는 HTTP/3 연결의 수명 주기에 대한 자세한 개요를 제공합니다.

\* "연결 설정 및 관리"\(섹션 3\)에서는 HTTP/3 끝점을 검색하고 HTTP/3 연결을 설정하는 방법을 다룹니다.

\* "HTTP/3에서 HTTP 의미론 표현"\(4장\)에서는 프레임을 사용하여 HTTP 의미론을 표현하는 방법을 설명합니다.

\* "연결 종료"\(섹션 5\)는 HTTP/3 연결이 정상적으로 또는 갑자기 종료되는 방법을 설명합니다.

유선 프로토콜 및 전송과의 상호 작용에 대한 세부 정보는 다음 섹션에서 설명됩니다.

\* "스트림 매핑 및 사용"\(섹션 6\)에서는 QUIC 스트림이 사용되는 방식을 설명합니다.

\* "HTTP 프레이밍 계층"\(섹션 7\)은 대부분의 스트림에서 사용되는 프레임을 설명합니다.

\* "오류 처리"\(섹션 8\)는 특정 스트림이나 연결 전체에서 오류 조건을 처리하고 표현하는 방법을 설명합니다.

마지막 섹션에는 추가 리소스가 제공됩니다.

\* "HTTP/3 확장"\(섹션 9\)은 향후 문서에 새로운 기능을 추가할 수 있는 방법을 설명합니다.

\* HTTP/2와 HTTP/3의 보다 자세한 비교는 부록 A에서 확인할 수 있습니다.

---
### **2.2.  Conventions and Terminology**

키워드 "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY" 및 "OPTIONAL" "는 BCP 14 \[RFC2119\] \[RFC8174\]에 설명된 대로 여기에 표시된 것처럼 모두 대문자로 표시되는 경우에만 해석됩니다.\(MUST NOT\)

이 문서는 \[QUIC-TRANSPORT\]의 가변 길이 정수 인코딩을 사용합니다.

다음 용어가 사용됩니다.

abort: 오류 조건으로 인해 연결이나 스트림이 갑자기 종료되는 것입니다.

클라이언트: HTTP/3 연결을 시작하는 엔드포인트입니다. 클라이언트는 HTTP 요청을 보내고 HTTP 응답을 받습니다.

연결: QUIC를 전송 프로토콜로 사용하는 두 끝점 간의 전송 계층 연결입니다.

연결 오류: HTTP/3 전체에 영향을 미치는 오류입니다.

-  연결.

끝점: 연결의 클라이언트 또는 서버입니다.

프레임: HTTP/3의 스트림에서 가장 작은 통신 단위로, 프레임 유형에 따라 구조화된 헤더와 가변 길이 바이트 시퀀스로 구성됩니다.

- "프레임"이라는 프로토콜 요소는 이 문서와 \[QUIC-TRANSPORT\] 모두에 존재합니다. \[QUIC-TRANSPORT\]의 프레임이 참조되는 경우 프레임 이름 앞에 "QUIC"가 붙습니다. 예를 들어 'QUIC CONNECTION\_CLOSE 프레임'입니다. 이 머리말이 없는 참조는 섹션 7.2에 정의된 프레임을 참조합니다.

HTTP/3 연결: 협상된 QUIC 연결

- 애플리케이션 프로토콜은 HTTP/3입니다.

피어: 끝점입니다. 특정 엔드포인트를 논의할 때 "피어"는 논의의 기본 주제에 대해 원격인 엔드포인트를 나타냅니다.

수신기: 프레임을 수신하는 끝점입니다.

보낸 사람: 프레임을 전송하는 끝점입니다.

서버: HTTP/3 연결을 수락하는 엔드포인트입니다. 서버는 HTTP 요청을 받고 HTTP 응답을 보냅니다.

스트림: QUIC 전송에서 제공되는 양방향 또는 단방향 바이트스트림입니다. HTTP/3 연결 내의 모든 스트림은 "HTTP/3 스트림"으로 간주될 수 있지만 HTTP/3 내에서는 여러 스트림 유형이 정의됩니다.

스트림 오류: 개별 스트림의 애플리케이션 수준 오류입니다.

"컨텐츠"라는 용어는 \[HTTP\]의 섹션 6.4에 정의되어 있습니다.

마지막으로 "리소스", "메시지", "사용자 에이전트", "원본 서버", "게이트웨이", "중개자", "프록시" 및 "터널"이라는 용어는 \[HTTP\]의 섹션 3에 정의되어 있습니다.

이 문서의 패킷 다이어그램은 필드의 순서와 크기를 설명하기 위해 \[QUIC-TRANSPORT\]의 섹션 1.3에 정의된 형식을 사용합니다.

---
## **3.  Connection Setup and Management**
---
### **3.1.  Discovering an HTTP/3 Endpoint**

HTTP는 권한 있는 응답이라는 개념에 의존합니다. 즉, 원본 서버에 의해\(또는 원본 서버의 지시에 따라\) 응답 메시지가 생성될 때 대상 리소스의 상태를 고려하여 해당 요청에 가장 적합한 응답으로 결정된 응답입니다. 대상 URI 내에서 식별됩니다. HTTP URI에 대한 권한 있는 서버를 찾는 방법은 \[HTTP\]의 섹션 4.3에서 논의됩니다.

"https" 체계는 권한을 클라이언트가 URI의 권한 구성 요소에 의해 식별된 호스트에 대해 신뢰할 수 있다고 간주하는 인증서 소유와 연관시킵니다. TLS 핸드셰이크에서 서버 인증서를 수신하면 클라이언트는 \[HTTP\]의 섹션 4.3.4에 설명된 프로세스를 사용하여 인증서가 URI의 원본 서버에 대해 허용 가능한 일치인지 확인해야 합니다. URI의 원본 서버와 관련하여 인증서를 확인할 수 없는 경우 클라이언트는 해당 원본에 대해 권한이 있는 서버를 고려해서는 안 됩니다.\(MUST, MUST NOT\)

클라이언트는 호스트 식별자를 IP 주소로 확인하고 표시된 포트에서 해당 주소에 대한 QUIC 연결을 설정하고\(위에서 설명한 서버 인증서 유효성 검사 포함\) "https" URI가 있는 리소스에 대한 액세스를 시도할 수 있습니다. 해당 보안 연결을 통해 서버에 대한 URI를 대상으로 하는 HTTP/3 요청 메시지입니다. HTTP/3을 선택하는 데 다른 메커니즘을 사용하지 않는 한 TLS 핸드셰이크 중에 ALPN\(Application-Layer Protocol Negotiation\) 확장에 "h3" 토큰이 사용됩니다.\(MAY\)

연결 문제\(예: UDP 차단\)로 인해 QUIC 연결 설정이 실패할 수 있습니다. 이 경우 클라이언트는 TCP 기반 버전의 HTTP를 사용하려고 시도해야 합니다\(SHOULD\).\(SHOULD\)

서버는 모든 UDP 포트에서 HTTP/3을 제공할 수 있습니다. 대체 서비스 광고에는 항상 명시적인 포트가 포함되며, URI에는 명시적인 포트 또는 체계와 연결된 기본 포트가 포함됩니다.\(MAY\)

---
#### **3.1.1.  HTTP Alternative Services**

HTTP 원본은 Alt-Svc HTTP 응답 헤더 필드 또는 "h3" ALPN 토큰을 사용하는 HTTP/2 ALTSVC 프레임\(\[ALTSVC\]\)을 통해 동등한 HTTP/3 엔드포인트의 가용성을 알릴 수 있습니다.

예를 들어 원본은 다음 헤더 필드를 포함하여 동일한 호스트 이름의 UDP 포트 50781에서 HTTP/3을 사용할 수 있음을 HTTP 응답에 나타낼 수 있습니다.

```text
   Alt-Svc: h3=":50781"
```

HTTP/3 지원을 나타내는 Alt-Svc 레코드를 수신하면 클라이언트는 표시된 호스트 및 포트에 대한 QUIC 연결 설정을 시도할 수 있습니다. 연결이 성공하면 클라이언트는 이 문서에 설명된 매핑을 사용하여 HTTP 요청을 보낼 수 있습니다.\(MAY\)

---
#### **3.1.2.  Other Schemes**

HTTP는 전송 프로토콜과 독립적이지만 "http" 체계는 권한 구성 요소 내에서 식별되는 호스트의 지정된 포트에서 TCP 연결을 수신하는 기능과 권한을 연관시킵니다. HTTP/3은 TCP를 사용하지 않기 때문에 "http" URI로 식별되는 리소스에 대해 권한 있는 서버에 직접 액세스하는 데 HTTP/3을 사용할 수 없습니다. 그러나 \[ALTSVC\]와 같은 프로토콜 확장을 사용하면 권한 있는 서버가 권한 있고 HTTP/3을 통해 연결할 수 있는 다른 서비스를 식별할 수 있습니다.

"https"가 아닌 스키마를 가진 원본을 요청하기 전에 클라이언트는 서버가 해당 스키마를 제공할 의향이 있는지 확인해야 합니다. 체계가 "http"인 출처의 경우 이를 달성하기 위한 실험적 방법이 \[RFC8164\]에 설명되어 있습니다. 향후 다양한 체계에 대해 다른 메커니즘이 정의될 수 있습니다.\(MUST\)

---
### **3.2.  Connection Establishment**

HTTP/3은 기본 전송으로 QUIC 버전 1을 사용합니다. HTTP/3을 포함한 다른 QUIC 전송 버전의 사용은 향후 사양에 의해 정의될 수 있습니다.\(MAY\)

QUIC 버전 1은 TLS 버전 1.3 이상을 핸드셰이크 프로토콜로 사용합니다. HTTP/3 클라이언트는 TLS 핸드셰이크 중에 대상 호스트를 서버에 표시하는 메커니즘을 지원해야 합니다. 서버가 도메인 이름\(\[DNS-TERMS\]\)으로 식별되는 경우 대상 호스트를 표시하는 대체 메커니즘이 사용되지 않는 한 클라이언트는 서버 이름 표시\(SNI; \[RFC6066\]\) TLS 확장을 보내야 합니다.\(MUST, MUST\)

QUIC 연결은 \[QUIC-TRANSPORT\]에 설명된 대로 설정됩니다. 연결 설정 중에 TLS 핸드셰이크에서 ALPN 토큰 "h3"을 선택하면 HTTP/3 지원이 표시됩니다. 다른 애플리케이션 계층 프로토콜에 대한 지원은 동일한 핸드셰이크에서 제공될 수 있습니다.\(MAY\)

핵심 QUIC 프로토콜과 관련된 연결 수준 옵션은 초기 암호화 핸드셰이크에서 설정되지만 HTTP/3 관련 설정은 SETTINGS 프레임에 전달됩니다. QUIC 연결이 설정된 후 각 엔드포인트는 SETTINGS 프레임을 해당 HTTP 제어 스트림의 초기 프레임으로 전송해야 합니다.\(MUST\)

---
### **3.3.  Connection Reuse**

HTTP/3 연결은 여러 요청에 걸쳐 지속됩니다. 최상의 성능을 위해 클라이언트는 서버와의 추가 통신이 필요하지 않다고 판단되거나\(예: 사용자가 특정 웹 페이지에서 다른 곳으로 이동할 때\) 서버가 연결을 닫을 때까지 연결을 닫지 않을 것으로 예상됩니다.

서버 끝점에 대한 연결이 존재하면 이 연결은 여러 다른 URI 권한 구성 요소가 있는 요청에 재사용될 수 있습니다. 새로운 원본에 대한 기존 연결을 사용하려면 클라이언트는 \[HTTP\]의 섹션 4.3.4에 설명된 프로세스를 사용하여 새로운 원본 서버에 대해 서버가 제시한 인증서를 검증해야 합니다. 이는 클라이언트가 서버 인증서와 해당 인증서를 확인하는 데 필요한 추가 정보를 유지해야 함을 의미합니다. 그렇게 하지 않는 클라이언트는 추가 원본에 대한 연결을 재사용할 수 없습니다.\(MAY, MUST\)

어떤 이유로든 새 원본과 관련하여 인증서가 허용되지 않는 경우 연결을 재사용해서는 안 되며 새 원본에 대해 새 연결을 설정해야 합니다. 인증서를 확인할 수 없는 이유가 이미 연결과 연결된 다른 출처에 적용될 수 있는 경우 클라이언트는 해당 출처에 대한 서버 인증서를 재검증해야 합니다. 예를 들어 인증서가 만료되거나 취소되어 인증서 유효성 검사에 실패하는 경우 해당 인증서가 권한을 설정하는 데 사용된 다른 모든 원본을 무효화하는 데 사용될 수 있습니다.\(MUST NOT, SHOULD\)

클라이언트는 지정된 IP 주소 및 UDP 포트에 대해 둘 이상의 HTTP/3 연결을 열어서는 안 됩니다. 여기서 IP 주소와 포트는 URI, 선택한 대체 서비스\(\[ALTSVC\]\), 구성된 프록시 또는 이름 확인에서 파생될 수 있습니다. 이 중 하나. 클라이언트는 서로 다른 전송 또는 TLS 구성을 사용하여 동일한 IP 주소 및 UDP 포트에 대한 여러 HTTP/3 연결을 열 수 있지만 동일한 구성으로 여러 연결을 생성하는 것을 피해야 합니다\(SHOULD\).\(SHOULD NOT, SHOULD\)

서버는 가능한 한 오랫동안 열린 HTTP/3 연결을 유지하는 것이 좋지만 필요한 경우 유휴 연결을 종료하는 것이 허용됩니다. 두 엔드포인트 중 하나가 HTTP/3 연결을 닫기로 선택하면 종료 엔드포인트는 먼저 GOAWAY 프레임\(섹션 5.2\)을 보내야 합니다. 그러면 두 엔드포인트 모두 이전에 전송된 프레임이 처리되었는지 여부를 안정적으로 결정하고 필요한 나머지 작업을 정상적으로 완료하거나 종료할 수 있습니다.\(SHOULD\)

클라이언트가 특정 출처에 대해 HTTP/3 연결을 재사용하는 것을 원하지 않는 서버는 요청에 대한 응답으로 421\(잘못된 요청\) 상태 코드를 전송하여 요청에 대한 권한이 없음을 나타낼 수 있습니다. \[HTTP\]의 섹션 7.4를 참조하세요.

---
## **4.  Expressing HTTP Semantics in HTTP/3**
---
### **4.1.  HTTP Message Framing**

클라이언트는 클라이언트가 시작한 양방향 QUIC 스트림인 요청 스트림에서 HTTP 요청을 보냅니다. 섹션 6.1을 참조하세요. 클라이언트는 주어진 스트림에 대해 단일 요청만 보내야 합니다. 서버는 아래에 자세히 설명된 대로 요청과 동일한 스트림에서 0개 이상의 임시 HTTP 응답을 보낸 다음 단일 최종 HTTP 응답을 보냅니다. 중간 및 최종 HTTP 응답에 대한 설명은 \[HTTP\]의 섹션 15를 참조하세요.\(MUST\)

푸시된 응답은 서버가 시작한 단방향 QUIC 스트림을 통해 전송됩니다. 섹션 6.2.2를 참조하세요. 서버는 표준 응답과 동일한 방식으로 0개 이상의 임시 HTTP 응답을 보낸 다음 단일 최종 HTTP 응답을 보냅니다. 푸시에 대한 자세한 내용은 섹션 4.6에 설명되어 있습니다.

주어진 스트림에서 여러 요청의 수신이나 최종 HTTP 응답에 따른 추가 HTTP 응답의 수신은 잘못된 형식으로 처리되어야 합니다\(MUST\).\(MUST\)

HTTP 메시지\(요청 또는 응답\)는 다음으로 구성됩니다.

1. 단일 HEADERS 프레임으로 전송되는 메시지 제어 데이터를 포함한 헤더 섹션,

2. 선택적으로 콘텐츠가 있는 경우 일련의 DATA 프레임으로 전송됩니다.

3. 선택적으로 트레일러 섹션이 있는 경우 단일 HEADERS 프레임으로 전송됩니다.

헤더 및 트레일러 섹션은 \[HTTP\]의 섹션 6.3 및 6.5에 설명되어 있습니다. 내용은 \[HTTP\]의 섹션 6.4에 설명되어 있습니다.

유효하지 않은 프레임 시퀀스의 수신은 H3\_FRAME\_UNEXPECTED 유형의 연결 오류로 처리되어야 합니다. 특히 HEADERS 프레임 앞의 DATA 프레임이나 후행 HEADERS 프레임 뒤의 HEADERS 또는 DATA 프레임은 유효하지 않은 것으로 간주됩니다. 다른 프레임 유형, 특히 알 수 없는 프레임 유형은 자체 규칙에 따라 허용될 수 있습니다. 섹션 9를 참조하세요.\(MUST\)

서버는 응답 메시지의 프레임 전, 후 또는 인터리브된 하나 이상의 PUSH\_PROMISE 프레임을 보낼 수 있습니다. 이러한 PUSH\_PROMISE 프레임은 응답의 일부가 아닙니다. 자세한 내용은 섹션 4.6을 참조하세요. 푸시 스트림에는 PUSH\_PROMISE 프레임이 허용되지 않습니다. PUSH\_PROMISE 프레임을 포함하는 푸시된 응답은 H3\_FRAME\_UNEXPECTED 유형의 연결 오류로 처리되어야 합니다.\(MAY, MUST\)

예약된 프레임\(섹션 7.2.8\)을 포함하여 알 수 없는 유형\(섹션 9\)의 프레임은 이 섹션에 설명된 다른 프레임 앞, 뒤 또는 인터리브된 요청 또는 푸시 스트림을 통해 전송될 수 있습니다.\(MAY\)

HEADERS 및 PUSH\_PROMISE 프레임은 QPACK 동적 테이블에 대한 업데이트를 참조할 수 있습니다. 이러한 업데이트는 메시지 교환에 직접적으로 포함되지는 않지만 메시지를 사용하기 전에 업데이트를 수신하고 처리해야 합니다. 자세한 내용은 섹션 4.2를 참조하세요.

전송 코딩\(\[HTTP/1.1\]의 섹션 7 참조\)은 HTTP/3에 대해 정의되지 않습니다. Transfer-Encoding 헤더 필드는 사용되어서는 안 됩니다.\(MUST NOT\)

응답은 하나 이상의 중간 응답\(1xx; \[HTTP\]의 섹션 15.2 참조\)이 동일한 요청에 대한 최종 응답 앞에 올 때만 여러 메시지로 구성될 수 있습니다. 임시 응답에는 콘텐츠나 예고편 섹션이 포함되어 있지 않습니다.\(MAY\)

HTTP 요청/응답 교환은 클라이언트가 시작한 양방향 QUIC 스트림을 완전히 소비합니다. 요청을 보낸 후 클라이언트는 전송을 위해 스트림을 닫아야 합니다. CONNECT 메소드\(섹션 4.4 참조\)를 사용하지 않는 한 클라이언트는 요청에 대한 응답 수신에 따라 스트림 폐쇄를 수행해서는 안 됩니다. 최종 응답을 보낸 후 서버는 전송을 위해 스트림을 닫아야 합니다. 이 시점에서 QUIC 스트림은 완전히 닫힙니다.\(MUST, MUST NOT, MUST\)

스트림이 닫히면 이는 최종 HTTP 메시지의 끝을 나타냅니다. 일부 메시지는 크거나 제한이 없기 때문에 엔드포인트는 진행하기에 충분한 메시지가 수신되면 부분 HTTP 메시지 처리를 시작해야 합니다\(SHOULD\). 클라이언트가 시작한 스트림이 완전한 응답을 제공하기에 충분한 HTTP 메시지 없이 종료되는 경우 서버는 오류 코드 H3\_REQUEST\_INCOMPLETE와 함께 응답 스트림을 중단해야 합니다.\(SHOULD, SHOULD\)

응답이 전송 및 수신되지 않은 요청 부분에 의존하지 않는 경우 클라이언트가 전체 요청을 보내기 전에 서버는 완전한 응답을 보낼 수 있습니다. 서버가 요청의 나머지 부분을 수신할 필요가 없으면 요청 스트림 읽기를 중단하고 완전한 응답을 보낸 다음 스트림의 전송 부분을 완전히 닫을 수 있습니다. 클라이언트가 요청 스트림에서 전송을 중지하도록 요청할 때 오류 코드 H3\_NO\_ERROR를 사용해야 합니다. 클라이언트는 요청이 갑자기 종료된 결과로 완전한 응답을 삭제해서는 안 됩니다. 하지만 클라이언트는 다른 이유로 항상 재량에 따라 응답을 삭제할 수 있습니다. 서버가 부분 또는 전체 응답을 보내지만 요청 읽기를 중단하지 않는 경우 클라이언트는 계속해서 요청 내용을 보내고 스트림을 정상적으로 닫아야 합니다.\(MAY, SHOULD, MUST NOT, SHOULD\)

---
#### **4.1.1.  Request Cancellation and Rejection**

요청 스트림이 열리면 양쪽 끝점 중 하나에서 요청이 취소될 수 있습니다. 응답이 더 이상 관심이 없으면 클라이언트는 요청을 취소합니다. 서버는 응답할 수 없거나 응답하지 않기로 선택한 경우 요청을 취소합니다. 가능하다면 서버가 이미 처리를 시작한 요청을 취소하는 대신 적절한 상태 코드와 함께 HTTP 응답을 보내는 것이 좋습니다.\(MAY, SHOULD\)

구현에서는 아직 열려 있는 스트림의 모든 방향을 갑자기 종료하여 요청을 취소해야 합니다\(SHOULD\). 이를 위해 구현에서는 스트림의 전송 부분을 재설정하고 스트림의 수신 부분에 대한 읽기를 중단합니다. \[QUIC-TRANSPORT\]의 섹션 2.4를 참조하세요.\(SHOULD\)

서버가 애플리케이션 처리를 수행하지 않고 요청을 취소하면 해당 요청은 "거부"된 것으로 간주됩니다. 서버는 오류 코드 H3\_REQUEST\_REJECTED와 함께 응답 스트림을 중단해야 합니다. 이 맥락에서 "처리됨"은 스트림의 일부 데이터가 결과적으로 어떤 조치를 취할 수 있는 소프트웨어의 상위 계층으로 전달되었음을 의미합니다. 클라이언트는 서버에서 거부한 요청을 전혀 보낸 적이 없는 것처럼 처리하여 나중에 다시 시도할 수 있도록 합니다.\(SHOULD\)

서버는 부분적으로 또는 완전히 처리된 요청에 대해 H3\_REQUEST\_REJECTED 오류 코드를 사용해서는 안 됩니다. 서버가 부분 처리 후 응답을 포기하면 오류 코드 H3\_REQUEST\_CANCELLED와 함께 응답 스트림을 중단해야 합니다.\(MUST NOT, SHOULD\)

클라이언트는 요청을 취소하려면 오류 코드 H3\_REQUEST\_CANCELLED를 사용해야 합니다. 이 오류 코드를 수신하면 처리가 수행되지 않은 경우 서버는 오류 코드 H3\_REQUEST\_REJECTED를 사용하여 응답을 갑자기 종료할 수 있습니다. 클라이언트는 서버가 이 오류 코드로 요청 스트림의 폐쇄를 요청한 경우를 제외하고는 H3\_REQUEST\_REJECTED 오류 코드를 사용해서는 안 됩니다.\(SHOULD, MAY, MUST NOT\)

완전한 응답을 받은 후 스트림이 취소되면 클라이언트는 취소를 무시하고 응답을 사용할 수 있습니다. 그러나 부분 응답을 받은 후 스트림이 취소되면 응답을 사용해서는 안 됩니다. GET, PUT 또는 DELETE와 같은 멱등성 작업만 안전하게 재시도할 수 있습니다. 클라이언트는 요청 의미론이 메서드와 독립적으로 멱등적이라는 것을 알 수 있는 수단이 없거나 원래 요청이 전혀 적용되지 않았음을 감지할 수 있는 수단이 없는 한 멱등성이 없는 메서드로 요청을 자동으로 재시도해서는 안 됩니다. 자세한 내용은 \[HTTP\]의 섹션 9.2.2를 참조하세요.\(MAY, SHOULD NOT, SHOULD NOT\)

---
#### **4.1.2.  Malformed Requests and Responses**

잘못된 요청 또는 응답은 유효한 프레임 시퀀스이지만 다음과 같은 이유로 유효하지 않은 요청 또는 응답입니다.

\* 금지된 필드 또는 의사 헤더 필드의 존재,

\* 필수 의사 헤더 필드가 없는 경우

\* 의사 헤더 필드의 값이 잘못되었습니다.

\* 필드 뒤의 의사 헤더 필드,

\* 잘못된 HTTP 메시지 시퀀스

\* 대문자 필드 이름 포함 또는

\* 필드 이름이나 값에 유효하지 않은 문자가 포함되었습니다.

Content-Length 헤더 필드\(\[HTTP\]의 섹션 8.6\)를 포함할 때 콘텐츠가 있는 것으로 정의된 요청 또는 응답은 Content-Length 헤더 필드의 값이 수신된 DATA 프레임 길이의 합과 같지 않으면 잘못된 형식입니다. . Content-Length가 있더라도 콘텐츠가 없는 것으로 정의된 응답은 DATA 프레임에 콘텐츠가 포함되어 있지 않더라도 0이 아닌 Content-Length 헤더 필드를 가질 수 있습니다.

HTTP 요청이나 응답을 처리하는 중개자\(즉, 터널 역할을 하지 않는 중개자\)는 잘못된 요청이나 응답을 전달해서는 안 됩니다. 잘못된 형식의 요청이나 감지된 응답은 H3\_MESSAGE\_ERROR 유형의 스트림 오류로 처리되어야 합니다.\(MUST NOT, MUST\)

잘못된 요청의 경우 서버는 스트림을 닫거나 재설정하기 전에 오류를 나타내는 HTTP 응답을 보낼 수 있습니다. 클라이언트는 잘못된 응답을 수락해서는 안 됩니다. 이러한 요구 사항은 HTTP에 대한 여러 유형의 일반적인 공격으로부터 보호하기 위한 것입니다. 허용하면 구현이 이러한 취약점에 노출될 수 있으므로 의도적으로 엄격합니다.\(MAY, MUST NOT\)

---
### **4.2.  HTTP Fields**

HTTP 메시지는 "HTTP 필드"라고 하는 일련의 키-값 쌍으로 메타데이터를 전달합니다. \[HTTP\]의 섹션 6.3 및 6.5를 참조하세요. 등록된 HTTP 필드 목록을 보려면 <https://www.iana.org/locationments/http-fields/\>에서 유지 관리되는 "HTTP\(Hypertext Transfer Protocol\) 필드 이름 레지스트리"를 참조하세요. HTTP/2와 마찬가지로 HTTP/3에는 필드 이름, 연결 헤더 필드 및 의사 헤더 필드의 문자 사용과 관련된 추가 고려 사항이 있습니다.

필드 이름은 ASCII 문자의 하위 집합을 포함하는 문자열입니다. HTTP 필드 이름과 값의 속성은 \[HTTP\]의 섹션 5.1에서 자세히 논의됩니다. 필드 이름의 문자는 인코딩 전에 소문자로 변환되어야 합니다. 필드 이름에 대문자가 포함된 요청이나 응답은 잘못된 형식으로 처리되어야 합니다.\(MUST, MUST\)

HTTP/3은 연결별 필드를 나타내기 위해 연결 헤더 필드를 사용하지 않습니다. 이 프로토콜에서는 연결별 메타데이터가 다른 수단으로 전달됩니다. 엔드포인트는 연결별 필드를 포함하는 HTTP/3 필드 섹션을 생성해서는 안 됩니다. 연결별 필드를 포함하는 모든 메시지는 잘못된 형식으로 처리되어야 합니다.\(MUST NOT\)

이에 대한 유일한 예외는 HTTP/3 요청 헤더에 존재할 수 있는 TE 헤더 필드입니다. 이 경우 "트레일러" 이외의 값을 포함하면 안 됩니다.\(MUST NOT\)

HTTP/1.x 메시지를 HTTP/3으로 변환하는 중개자는 \[HTTP\]의 섹션 7.6.1에 설명된 대로 연결별 헤더 필드를 제거해야 합니다. 그렇지 않으면 메시지가 다른 HTTP/3 엔드포인트에 의해 잘못된 형식으로 처리됩니다.\(MUST\)

---
#### **4.2.1.  Field Compression**

\[QPACK\]은 압축으로 인해 발생할 수 있는 헤드 오브 라인 차단 정도를 인코더에 제어할 수 있는 HPACK의 변형을 설명합니다. 이를 통해 인코더는 압축 효율성과 대기 시간의 균형을 맞출 수 있습니다. HTTP/3은 QPACK을 사용하여 헤더 섹션에 있는 제어 데이터를 포함하여 헤더 및 트레일러 섹션을 압축합니다.

더 나은 압축 효율성을 허용하기 위해 쿠키 헤더 필드\(\[COOKIES\]\)는 압축 전에 각각 하나 이상의 쿠키 쌍이 있는 별도의 필드 줄로 분할될 수 있습니다. 압축 해제된 필드 섹션에 여러 개의 쿠키 필드 행이 포함된 경우 HTTP/2 또는 HTTP/ 이외의 컨텍스트로 전달되기 전에 ";"\(ASCII 0x3b, 0x20\)의 2바이트 구분 기호를 사용하여 단일 바이트 문자열로 연결해야 합니다. 3\(예: HTTP/1.1 연결 또는 일반 HTTP 서버 애플리케이션\)\(MAY, MUST\)

---
#### **4.2.2.  Header Size Constraints**

HTTP/3 구현은 개별 HTTP 메시지에서 허용할 메시지 헤더의 최대 크기에 제한을 부과할 수 있습니다. 처리할 수 있는 것보다 더 큰 헤더 섹션을 수신하는 서버는 HTTP 431\(요청 헤더 필드가 너무 큼\) 상태 코드\(\[RFC6585\]\)를 보낼 수 있습니다. 클라이언트는 처리할 수 없는 응답을 삭제할 수 있습니다. 필드 목록의 크기는 이름 및 값의 길이\(바이트\)와 각 필드에 대한 32바이트의 오버헤드를 포함하여 압축되지 않은 필드 크기를 기준으로 계산됩니다.\(MAY\)

구현이 피어에게 이 제한을 알리고자 하는 경우 SETTINGS\_MAX\_FIELD\_SECTION\_SIZE 매개변수에 바이트 수로 전달할 수 있습니다. 이 매개변수를 수신한 구현은 표시된 크기를 초과하는 HTTP 메시지 헤더를 전송해서는 안 됩니다. 피어가 처리를 거부할 가능성이 있기 때문입니다. 그러나 HTTP 메시지는 원본 서버에 도달하기 전에 하나 이상의 중개자를 통과할 수 있습니다. \[HTTP\]의 섹션 3.7을 참조하세요. 이 제한은 메시지를 처리하는 각 구현에 따라 별도로 적용되기 때문에 이 제한 미만의 메시지는 허용되지 않을 수 있습니다.\(SHOULD NOT\)

---
### **4.3.  HTTP Control Data**

HTTP/2와 마찬가지로 HTTP/3은 일련의 의사 헤더 필드를 사용합니다. 여기서 필드 이름은 : 문자\(ASCII 0x3a\)로 시작됩니다. 이러한 의사 헤더 필드는 메시지 제어 데이터를 전달합니다. \[HTTP\]의 섹션 6.2를 참조하세요.

의사 헤더 필드는 HTTP 필드가 아닙니다. 엔드포인트는 이 문서에 정의된 것 이외의 의사 헤더 필드를 생성해서는 안 됩니다. 그러나 확장은 이 제한 사항의 수정을 협상할 수 있습니다. 섹션 9를 참조하세요.\(MUST NOT\)

의사 헤더 필드는 해당 필드가 정의된 컨텍스트에서만 유효합니다. 요청에 대해 정의된 의사 헤더 필드는 응답에 나타나서는 안 됩니다. 응답에 대해 정의된 의사 헤더 필드는 요청에 나타나서는 안 됩니다. 의사 헤더 필드는 트레일러 섹션에 표시되어서는 안 됩니다. 엔드포인트는 정의되지 않았거나 유효하지 않은 의사 헤더 필드가 포함된 요청이나 응답을 잘못된 형식으로 처리해야 합니다\(MUST\).\(MUST NOT, MUST NOT, MUST\)

모든 의사 헤더 필드는 반드시 일반 헤더 필드 이전의 헤더 섹션에 나타나야 합니다. 일반 헤더 필드 뒤의 헤더 섹션에 나타나는 의사 헤더 필드를 포함하는 모든 요청 또는 응답은 잘못된 형식으로 처리되어야 합니다.\(MUST, MUST\)

---
#### **4.3.1.  Request Pseudo-Header Fields**

요청에 대해 다음과 같은 의사 헤더 필드가 정의됩니다.

```text
   ":method":  Contains the HTTP method (Section 9 of [HTTP])
```

":scheme": 대상 URI의 구성표 부분을 포함합니다.

- \(\[URI\]의 섹션 3.1\).

- :scheme 의사 헤더는 "http" 및 "https" 체계를 사용하는 URI로 제한되지 않습니다. 프록시나 게이트웨이는 HTTP가 아닌 체계에 대한 요청을 변환하여 HTTP를 사용하여 HTTP가 아닌 서비스와 상호 작용할 수 있습니다.

- "https" 이외의 체계 사용에 대한 지침은 섹션 3.1.2를 참조하세요.

":authority": 대상 URI의 권한 부분을 포함합니다\(\[URI\]의 섹션 3.2\). 권한은 "http" 또는 "https" 체계의 URI에 대해 더 이상 사용되지 않는 userinfo 하위 구성 요소를 포함해서는 안 됩니다.\(MUST NOT\)

- HTTP/1.1 요청 라인이 정확하게 재현될 수 있도록 하려면 메소드별 형식의 요청 대상이 있는 HTTP/1.1 요청을 변환할 때 이 의사 헤더 필드를 생략해야 합니다. \[HTTP\]의 섹션 7.1을 참조하세요. HTTP/3 요청을 직접 생성하는 클라이언트는 Host 헤더 필드 대신 :authority 의사 헤더 필드를 사용해야 합니다. HTTP/3 요청을 HTTP/1.1로 변환하는 중개자는 요청에 Host 필드가 없는 경우 :authority 의사 헤더 필드의 값을 복사하여 Host 필드를 생성해야 합니다.\(MUST, SHOULD, MUST\)

":path": 대상 URI\("경로 절대" 생성 및 선택적으로 ? 문자\(ASCII 0x3f\) 뒤에 "쿼리" 생성이 오는 경로 및 쿼리 부분이 포함됩니다. \[URI\]의 섹션 3.3 및 3.4를 참조하세요.

- 이 의사 헤더 필드는 "http" 또는 "https" URI에 대해 비어 있어서는 안 됩니다. 경로 구성 요소를 포함하지 않는 "http" 또는 "https" URI는 /\(ASCII 0x2f\) 값을 포함해야 합니다. 경로 구성 요소를 포함하지 않는 OPTIONS 요청에는 :path 의사 헤더 필드에 대한 값 \*\(ASCII 0x2a\)이 포함됩니다. \[HTTP\]의 섹션 7.1을 참조하세요.\(MUST NOT\)

모든 HTTP/3 요청은 요청이 CONNECT 요청이 아닌 한 :method, :scheme 및 :path 의사 헤더 필드에 대해 정확히 하나의 값을 포함해야 합니다. 섹션 4.4를 참조하세요.\(MUST\)

:scheme 의사 헤더 필드가 필수 권한 구성 요소\("http" 및 "https" 포함\)가 있는 체계를 식별하는 경우 요청에는 :authority 의사 헤더 필드 또는 Host 헤더 필드가 포함되어야 합니다. 이러한 필드가 있는 경우 비어 있으면 안 됩니다. 두 필드가 모두 존재하는 경우 동일한 값을 포함해야 합니다. 체계에 필수 권한 구성 요소가 없고 요청 대상에 아무것도 제공되지 않은 경우 요청에는 :authority 의사 헤더 또는 Host 헤더 필드가 포함되어서는 안 됩니다.\(MUST, MUST NOT, MUST, MUST NOT\)

필수 의사 헤더 필드를 생략하거나 해당 의사 헤더 필드에 유효하지 않은 값을 포함하는 HTTP 요청의 형식이 잘못되었습니다.

HTTP/3은 HTTP/1.1 요청 라인에 포함된 버전 식별자를 전달하는 방법을 정의하지 않습니다. HTTP/3 요청에는 암시적으로 프로토콜 버전 "3.0"이 있습니다.

---
#### **4.3.2.  Response Pseudo-Header Fields**

응답의 경우, HTTP 상태 코드를 전달하는 단일 ":status" 의사 헤더 필드가 정의됩니다. \[HTTP\]의 섹션 15를 참조하세요. 이 의사 헤더 필드는 모든 응답에 포함되어야 합니다. 그렇지 않으면 응답 형식이 잘못되었습니다\(섹션 4.1.2 참조\).\(MUST\)

HTTP/3은 HTTP/1.1 상태 줄에 포함된 버전이나 이유 문구를 전달하는 방법을 정의하지 않습니다. HTTP/3 응답에는 암시적으로 프로토콜 버전 "3.0"이 있습니다.

---
### **4.4.  The CONNECT Method**

CONNECT 메소드는 수신자가 요청 대상으로 식별된 대상 원본 서버에 대한 터널을 설정하도록 요청합니다. \[HTTP\]의 섹션 9.3.6을 참조하세요. 이는 "https" 리소스와 상호 작용할 목적으로 원본 서버와 TLS 세션을 설정하기 위해 주로 HTTP 프록시와 함께 사용됩니다.

HTTP/1.x에서 CONNECT는 전체 HTTP 연결을 원격 호스트에 대한 터널로 변환하는 데 사용됩니다. HTTP/2 및 HTTP/3에서는 CONNECT 메서드를 사용하여 단일 스트림을 통해 터널을 설정합니다.

CONNECT 요청은 다음과 같이 구성되어야 합니다.\(MUST\)

```text
   *  The :method pseudo-header field is set to "CONNECT"
```

\* :scheme 및 :path 의사 헤더 필드는 생략됩니다.

\* :authority 의사 헤더 필드에는 연결할 호스트와 포트가 포함되어 있습니다\(CONNECT 요청의 request-target의 Authority 형식과 동일합니다. \[HTTP\]의 섹션 7.1 참조\).

요청 스트림은 전송될 데이터를 전달하기 위한 요청이 끝날 때 열린 상태로 유지됩니다. 이러한 제한 사항을 준수하지 않는 CONNECT 요청은 잘못된 형식입니다.

CONNECT를 지원하는 프록시는 :authority 의사 헤더 필드에서 식별된 서버에 대한 TCP 연결\(\[RFC0793\]\)을 설정합니다. 이 연결이 성공적으로 설정되면 프록시는 \[HTTP\]의 섹션 15.3에 정의된 대로 2xx 시리즈 상태 코드가 포함된 HEADERS 프레임을 클라이언트에 보냅니다.

스트림의 모든 DATA 프레임은 TCP 연결에서 보내거나 받은 데이터에 해당합니다. 클라이언트가 보낸 DATA 프레임의 페이로드는 프록시에 의해 TCP 서버로 전송됩니다. TCP 서버로부터 수신된 데이터는 프록시에 의해 DATA 프레임으로 패키지됩니다. TCP 세그먼트의 크기와 수는 HTTP DATA 또는 QUIC STREAM 프레임의 크기와 수에 예측 가능하게 매핑된다고 보장되지 않습니다.

CONNECT 메소드가 완료되면 DATA 프레임만 스트림으로 전송할 수 있습니다. 확장 정의에서 특별히 허용하는 경우 확장 프레임을 사용할 수 있습니다. 다른 알려진 프레임 유형의 수신은 H3\_FRAME\_UNEXPECTED 유형의 연결 오류로 처리되어야 합니다.\(MAY, MUST\)

두 피어 모두 TCP 연결을 닫을 수 있습니다. 클라이언트가 요청 스트림을 종료하면\(즉, 프록시의 수신 스트림이 "Data Recvd" 상태로 전환됨\) 프록시는 TCP 서버에 대한 연결에 FIN 비트를 설정합니다. 프록시가 FIN 비트가 설정된 패킷을 수신하면 클라이언트로 보내는 전송 스트림을 닫습니다. 단일 방향으로 절반 닫힌 상태로 유지되는 TCP 연결은 유효하지 않지만 서버에서 제대로 처리되지 않는 경우가 많으므로 클라이언트는 CONNECT 대상에서 데이터 수신을 기대하는 동안 전송 스트림을 닫아서는 안 됩니다.\(SHOULD NOT\)

스트림이 갑자기 종료되면 TCP 연결 오류가 표시됩니다. 프록시는 RST 비트가 설정된 TCP 세그먼트 수신을 포함하여 TCP 연결의 모든 오류를 H3\_CONNECT\_ERROR 유형의 스트림 오류로 처리합니다.

이에 따라 프록시가 스트림이나 QUIC 연결에서 오류를 감지하면 TCP 연결을 닫아야 합니다. 프록시가 클라이언트가 스트림을 재설정했거나 스트림 읽기를 중단했음을 감지하면 TCP 연결을 닫아야 합니다. 스트림이 재설정되거나 클라이언트에 의해 읽기가 중단된 경우 프록시는 스트림의 두 방향이 모두 취소되도록 하기 위해 다른 방향에서 동일한 작업을 수행해야 합니다. 이러한 모든 경우에 기본 TCP 구현이 이를 허용하는 경우 프록시는 RST 비트가 설정된 TCP 세그먼트를 보내야 합니다.\(MUST, MUST, SHOULD, SHOULD\)

CONNECT는 임의의 서버에 대한 터널을 생성하므로 CONNECT를 지원하는 프록시는 알려진 포트 집합이나 안전한 요청 대상 목록으로 그 사용을 제한해야 합니다. 자세한 내용은 \[HTTP\]의 섹션 9.3.6을 참조하세요.\(SHOULD\)

---
### **4.5.  HTTP Upgrade**

HTTP/3은 HTTP 업그레이드 메커니즘\(\[HTTP\]의 섹션 7.8\) 또는 101\(전환 프로토콜\) 정보 상태 코드\(\[HTTP\]의 섹션 15.2.2\)를 지원하지 않습니다.

---
### **4.6.  Server Push**

서버 푸시는 클라이언트가 지정된 요청을 할 것을 예상하여 서버가 요청-응답 교환을 클라이언트에 푸시하도록 허용하는 상호 작용 모드입니다. 이는 잠재적인 대기 시간 증가와 네트워크 사용량을 절충합니다. HTTP/3 서버 푸시는 \[HTTP/2\]의 섹션 8.2에 설명된 것과 유사하지만 다른 메커니즘을 사용합니다.

각 서버 푸시에는 서버에서 고유한 푸시 ID가 할당됩니다. 푸시 ID는 HTTP/3 연결 수명 전반에 걸쳐 다양한 컨텍스트에서 푸시를 참조하는 데 사용됩니다.

푸시 ID 공간은 0에서 시작하여 MAX\_PUSH\_ID 프레임에 의해 설정된 최대값에서 끝납니다. 특히 클라이언트가 MAX\_PUSH\_ID 프레임을 보낼 때까지 서버는 푸시할 수 없습니다. 클라이언트는 서버가 약속할 수 있는 푸시 수를 제어하기 위해 MAX\_PUSH\_ID 프레임을 보냅니다. 서버는 0부터 시작하여 순차적으로 푸시 ID를 사용해야 합니다. MAX\_PUSH\_ID 프레임이 전송되지 않았거나 스트림이 최대 푸시 ID보다 큰 푸시 ID를 참조하는 경우 클라이언트는 푸시 스트림 수신을 H3\_ID\_ERROR 유형의 연결 오류로 처리해야 합니다.\(SHOULD, MUST\)

푸시 ID는 요청 메시지의 헤더 필드와 제어 데이터를 전달하는 하나 이상의 PUSH\_PROMISE 프레임에 사용됩니다. 이러한 프레임은 푸시를 생성한 요청 스트림을 통해 전송됩니다. 이를 통해 서버 푸시를 클라이언트 요청과 연결할 수 있습니다. 여러 요청 스트림에서 동일한 푸시 ID가 약속된 경우 압축 해제된 요청 필드 섹션에는 동일한 필드가 동일한 순서로 포함되어야 하며 각 필드의 이름과 값이 모두 동일해야 합니다.\(MUST\)

그런 다음 푸시 ID는 궁극적으로 해당 약속을 이행하는 푸시 스트림에 포함됩니다. 푸시 스트림은 이행하는 약속의 푸시 ID를 식별한 다음 섹션 4.1에 설명된 대로 약속된 요청에 대한 응답을 포함합니다.

마지막으로 푸시 ID는 CANCEL\_PUSH 프레임에서 사용될 수 있습니다. 섹션 7.2.3을 참조하세요. 클라이언트는 이 프레임을 사용하여 약속된 리소스를 받고 싶지 않음을 나타냅니다. 서버는 이 프레임을 사용하여 이전 약속을 이행하지 않을 것임을 나타냅니다.

모든 요청을 푸시할 수 있는 것은 아닙니다. 서버는 다음 속성을 가진 요청을 푸시할 수 있습니다.\(MAY\)

\* 캐시 가능; \[HTTP\]의 섹션 9.2.3을 참조하세요.

\*  안전한; \[HTTP\]의 섹션 9.2.1을 참조하세요.

\* 요청 콘텐츠나 예고편 섹션은 포함되지 않습니다.

서버는 서버가 신뢰할 수 있는 :authority 의사 헤더 필드에 값을 포함해야 합니다. 클라이언트가 푸시된 요청에 표시된 원본에 대한 연결을 아직 확인하지 않은 경우 연결에서 해당 원본에 대한 요청을 보내기 전에 수행하는 것과 동일한 확인 프로세스를 수행해야 합니다. 섹션 3.3을 참조하세요. 이 확인이 실패하면 클라이언트는 해당 원본에 대한 권한이 있는 서버를 고려해서는 안 됩니다.\(MUST, MUST, MUST NOT\)

클라이언트는 캐시할 수 없거나, 안전하지 않은 것으로 알려져 있거나, 요청 콘텐츠가 있음을 나타내거나, 서버에 권한이 있다고 간주하지 않는 요청을 전달하는 PUSH\_PROMISE 프레임을 수신하면 CANCEL\_PUSH 프레임을 보내야 합니다. 해당 응답을 사용하거나 캐시해서는 안 됩니다.\(SHOULD, MUST NOT\)

푸시된 각 응답은 하나 이상의 클라이언트 요청과 연결됩니다. 푸시는 PUSH\_PROMISE 프레임이 수신된 요청 스트림과 연결됩니다. 여러 요청 스트림에서 동일한 푸시 ID를 가진 PUSH\_PROMISE 프레임을 사용하여 동일한 서버 푸시를 추가 클라이언트 요청과 연결할 수 있습니다. 이러한 연결은 프로토콜 작동에 영향을 미치지 않지만 푸시된 리소스를 사용하는 방법을 결정할 때 사용자 에이전트가 고려할 수 있습니다.\(MAY\)

응답의 특정 부분과 관련하여 PUSH\_PROMISE 프레임의 순서를 지정하는 것이 중요합니다. 서버는 약속된 응답을 참조하는 HEADERS 또는 DATA 프레임을 보내기 전에 PUSH\_PROMISE 프레임을 보내야 합니다. 이렇게 하면 클라이언트가 서버에서 푸시할 리소스를 요청할 가능성이 줄어듭니다.\(SHOULD\)

재정렬로 인해 푸시 스트림 데이터가 해당 PUSH\_PROMISE 프레임보다 먼저 도착할 수 있습니다. 클라이언트가 아직 알려지지 않은 푸시 ID가 포함된 새 푸시 스트림을 수신하면 연결된 클라이언트 요청과 푸시된 요청 헤더 필드를 모두 알 수 없습니다. 클라이언트는 일치하는 PUSH\_PROMISE를 기대하여 스트림 데이터를 버퍼링할 수 있습니다. 클라이언트는 스트림 흐름 제어\(\[QUIC-TRANSPORT\]의 섹션 4.1\)를 사용하여 서버가 푸시된 스트림에 커밋할 수 있는 데이터의 양을 제한할 수 있습니다. 적절한 시간 내에 해당 PUSH\_PROMISE 프레임이 처리되지 않으면 클라이언트는 읽기를 중단하고 푸시 스트림에서 이미 읽은 데이터를 삭제해야 합니다.\(SHOULD\)

푸시 스트림 데이터는 클라이언트가 푸시를 취소한 후에도 도착할 수 있습니다. 이 경우 클라이언트는 H3\_REQUEST\_CANCELLED 오류 코드로 스트림 읽기를 중단할 수 있습니다. 이는 서버에 추가 데이터를 전송하지 말라고 요청하며 수신 시 해당 데이터가 삭제됨을 나타냅니다.

캐시 가능한 푸시된 응답\(\[HTTP-CACHING\]의 섹션 3 참조\)은 HTTP 캐시를 구현하는 경우 클라이언트에 의해 저장될 수 있습니다. 푸시된 응답은 푸시된 응답이 수신되는 시점에 원서버에서 성공적으로 검증된 것으로 간주됩니다\(예: "no-cache" 캐시 응답 지시문이 있는 경우, \[HTTP-CACHING\]의 섹션 5.2.2.4 참조\).

캐시할 수 없는 푸시된 응답은 HTTP 캐시에 의해 저장되어서는 안 됩니다\(MUST NOT\). 응용 프로그램에서 별도로 사용할 수 있습니다.\(MUST NOT, MAY\)

---
## **5.  Connection Closure**

HTTP/3 연결은 일단 설정되면 연결이 닫힐 때까지 시간이 지남에 따라 많은 요청과 응답에 사용될 수 있습니다. 연결 종료는 여러 가지 방법으로 발생할 수 있습니다.

---
### **5.1.  Idle Connections**

각 QUIC 엔드포인트는 핸드셰이크 중에 유휴 시간 제한을 선언합니다. QUIC 연결이 이 기간보다 오랫동안 유휴 상태\(수신된 패킷 없음\)로 유지되면 피어는 연결이 닫혔다고 가정합니다. HTTP/3 구현은 기존 연결이 QUIC 핸드셰이크 중에 협상된 유휴 시간 초과보다 오랫동안 유휴 상태인 경우 새 요청에 대해 새 HTTP/3 연결을 열어야 하며 유휴 시간 초과에 가까워지면 그렇게 해야 합니다. \[QUIC-TRANSPORT\]의 섹션 10.1을 참조하세요.\(SHOULD\)

HTTP 클라이언트는 \[QUIC-TRANSPORT\]의 섹션 10.1.2에 설명된 대로 요청 또는 서버 푸시에 대한 응답이 처리되지 않은 동안 전송이 연결을 열어두도록 요청할 것으로 예상됩니다. 클라이언트가 서버의 응답을 기대하지 않는 경우에는 필요하지 않은 연결을 유지하기 위해 노력을 기울이는 것보다 유휴 연결을 시간 초과하도록 허용하는 것이 좋습니다. 게이트웨이는 서버 연결 설정에 따른 대기 시간 비용을 발생시키지 않고 필요에 따라 연결을 유지할 수 있습니다. 서버는 연결을 적극적으로 열어두어서는 안 됩니다.\(MAY, SHOULD NOT\)

---
### **5.2.  Connection Shutdown**

연결이 유휴 상태가 아닌 경우에도 두 끝점 모두 연결 사용을 중지하고 정상적인 연결 닫기를 시작할 수 있습니다. 끝점은 GOAWAY 프레임을 전송하여 HTTP/3 연결의 정상적인 종료를 시작합니다. GOAWAY 프레임에는 이 연결에서 처리되었거나 처리될 수 있는 요청 또는 푸시의 범위를 수신자에게 나타내는 식별자가 포함되어 있습니다. 서버는 클라이언트가 시작한 양방향 스트림 ID를 보냅니다. 클라이언트가 푸시 ID를 보냅니다. 표시된 식별자 이상의 요청 또는 푸시는 GOAWAY 발신자에 의해 거부됩니다\(섹션 4.1.1\). 요청이나 푸시가 처리되지 않은 경우 이 식별자는 0일 수 있습니다.\(MAY\)

GOAWAY 프레임의 정보를 통해 클라이언트와 서버는 HTTP/3 연결이 종료되기 전에 어떤 요청이나 푸시가 허용되었는지 합의할 수 있습니다. GOAWAY 프레임을 전송할 때 엔드포인트는 영향을 받은 스트림의 전송 상태를 정리하기 위해 표시된 것보다 크거나 같은 식별자를 가진 모든 요청이나 푸시를 명시적으로 취소해야 합니다\(섹션 4.1.1 및 7.2.3 참조\). 더 많은 요청이나 푸시가 도착하면 엔드포인트는 계속해서 그렇게 해야 합니다.\(SHOULD, SHOULD\)

엔드포인트는 피어로부터 GOAWAY 프레임을 수신한 후 연결에 대한 새로운 요청을 시작하거나 새로운 푸시를 약속해서는 안 됩니다. 클라이언트는 추가 요청을 보내기 위해 새로운 연결을 설정할 수 있습니다.\(MUST NOT, MAY\)

일부 요청이나 푸시가 이미 전송 중일 수 있습니다.

\* GOAWAY 프레임을 수신한 후 클라이언트가 이미 GOAWAY 프레임에 포함된 식별자보다 크거나 같은 스트림 ID로 요청을 보낸 경우 해당 요청은 처리되지 않습니다. 클라이언트는 다른 HTTP 연결에서 처리되지 않은 요청을 안전하게 재시도할 수 있습니다. 요청을 재시도할 수 없는 클라이언트는 서버가 연결을 닫을 때 진행 중인 모든 요청을 잃게 됩니다.

- 서버의 GOAWAY 프레임에 있는 스트림 ID보다 작은 스트림 ID에 대한 요청이 처리되었을 수 있습니다. 응답이 수신되거나, 스트림이 개별적으로 재설정되거나, 문제의 요청보다 낮은 스트림 ID로 다른 GOAWAY가 수신되거나, 연결이 종료될 때까지 상태를 알 수 없습니다.

- 서버는 요청이 처리되지 않은 경우 표시된 ID 아래의 스트림에 대한 개별 요청을 거부할 수 있습니다.\(MAY\)

\* 서버가 GOAWAY 프레임에 포함된 식별자보다 크거나 같은 푸시 ID로 약속된 푸시를 수행한 후 GOAWAY 프레임을 수신하는 경우 해당 푸시는 허용되지 않습니다.

서버는 연결 종료가 미리 알려지면 원격 피어가 요청이 부분적으로 처리되었는지 여부를 알 수 있도록 사전 알림이 작더라도 GOAWAY 프레임을 보내야 합니다. 예를 들어, HTTP 클라이언트가 서버가 QUIC 연결을 닫는 것과 동시에 POST를 보내는 경우, 서버가 어떤 스트림을 나타낼 수 있는지 나타내기 위해 GOAWAY 프레임을 보내지 않으면 클라이언트는 서버가 해당 POST 요청 처리를 시작했는지 여부를 알 수 없습니다. 조치를 취했습니다.\(SHOULD\)

엔드포인트는 서로 다른 식별자를 나타내는 여러 GOAWAY 프레임을 보낼 수 있지만 클라이언트가 이미 다른 HTTP 연결에서 처리되지 않은 요청을 재시도했을 수 있으므로 각 프레임의 식별자는 이전 프레임의 식별자보다 커서는 안 됩니다. 이전에 수신한 것보다 더 큰 식별자가 포함된 GOAWAY를 수신하면 H3\_ID\_ERROR 유형의 연결 오류로 처리되어야 합니다.\(MUST NOT, MUST\)

연결을 정상적으로 종료하려고 시도하는 엔드포인트는 가능한 최대 값\(서버의 경우 2^62-4, 클라이언트의 경우 2^62-1\)으로 설정된 값으로 GOAWAY 프레임을 보낼 수 있습니다. 이렇게 하면 피어가 새 요청이나 푸시 생성을 중지합니다. 진행 중인 요청이나 푸시가 도착할 때까지 시간을 허용한 후 엔드포인트는 연결이 끝나기 전에 수락할 수 있는 요청이나 푸시를 나타내는 또 다른 GOAWAY 프레임을 보낼 수 있습니다. 이렇게 하면 요청 손실 없이 연결을 완전히 종료할 수 있습니다.

클라이언트는 보내는 GOAWAY의 푸시 ID 필드에 대해 선택하는 값에 더 많은 유연성을 갖습니다. 2^62-1 값은 서버가 이미 약속된 푸시를 계속해서 이행할 수 있음을 나타냅니다. 값이 작을수록 클라이언트가 이 값보다 크거나 같은 푸시 ID를 가진 푸시를 거부한다는 의미입니다. 서버와 마찬가지로 클라이언트는 지정된 푸시 ID가 이전에 보낸 값보다 크지 않은 한 후속 GOAWAY 프레임을 보낼 수 있습니다.\(MAY\)

GOAWAY가 특정 요청이나 푸시가 처리되지 않거나 수신 시 수락되지 않음을 나타내는 경우에도 기본 전송 리소스는 여전히 존재합니다. 이러한 요청을 시작한 엔드포인트는 요청을 취소하여 전송 상태를 정리할 수 있습니다.

승인된 모든 요청과 푸시가 처리되면 엔드포인트는 연결이 유휴 상태가 되도록 허용하거나 연결을 즉시 종료할 수 있습니다. 정상적인 종료를 완료하는 엔드포인트는 연결을 닫을 때 H3\_NO\_ERROR 오류 코드를 사용해야 합니다.\(MAY, SHOULD\)

클라이언트가 요청과 함께 사용 가능한 모든 양방향 스트림 ID를 사용한 경우 클라이언트가 추가 요청을 할 수 없으므로 서버는 GOAWAY 프레임을 보낼 필요가 없습니다.

---
### **5.3.  Immediate Application Closure**

HTTP/3 구현은 언제든지 QUIC 연결을 즉시 닫을 수 있습니다. 그 결과 애플리케이션 계층이 연결을 종료했음을 나타내는 QUIC CONNECTION\_CLOSE 프레임을 피어에 보냅니다. 이 프레임의 애플리케이션 오류 코드는 연결이 닫히는 이유를 피어에게 나타냅니다. HTTP/3에서 연결을 닫을 때 사용할 수 있는 오류 코드는 섹션 8을 참조하세요.

연결을 닫기 전에 클라이언트가 일부 요청을 재시도할 수 있도록 GOAWAY 프레임을 보낼 수도 있습니다. QUIC CONNECTION\_CLOSE 프레임과 동일한 패킷에 GOAWAY 프레임을 포함하면 클라이언트가 프레임을 수신할 가능성이 높아집니다.\(MAY\)

명시적으로 닫히지 않은 열린 스트림이 있는 경우 연결이 닫힐 때 암시적으로 닫힙니다. \[QUIC-TRANSPORT\]의 섹션 10.2를 참조하세요.

---
### **5.4.  Transport Closure**

다양한 이유로 인해 QUIC 전송은 연결이 종료되었음을 애플리케이션 계층에 나타낼 수 있습니다. 이는 피어의 명시적인 종료, 전송 수준 오류 또는 연결을 중단하는 네트워크 토폴로지 변경으로 인해 발생할 수 있습니다.

GOAWAY 프레임 없이 연결이 종료되는 경우 클라이언트는 전송된 요청 전체 또는 일부가 처리되었을 수 있다고 가정해야 합니다.\(MUST\)

---
## **6.  Stream Mapping and Usage**

QUIC 스트림은 안정적인 바이트 전달을 제공하지만 다른 스트림의 바이트와 관련된 전달 순서는 보장하지 않습니다. QUIC 버전 1에서는 HTTP 프레임이 포함된 스트림 데이터가 QUIC STREAM 프레임에 의해 전달되지만 이 프레임은 HTTP 프레이밍 계층에 표시되지 않습니다. 전송 계층은 수신된 스트림 데이터를 버퍼링하고 순서를 지정하여 신뢰할 수 있는 바이트 스트림을 애플리케이션에 노출합니다. QUIC는 스트림 내에서 비순차적 전달을 허용하지만 HTTP/3은 이 기능을 사용하지 않습니다.

QUIC 스트림은 개시자에서 수신자로만 데이터를 전달하는 단방향이거나 양방향으로 데이터를 전달하는 양방향일 수 있습니다. 스트림은 클라이언트나 서버에 의해 시작될 수 있습니다. QUIC 스트림에 대한 자세한 내용은 \[QUIC-TRANSPORT\]의 섹션 2를 참조하세요.

HTTP 필드와 데이터가 QUIC를 통해 전송되면 QUIC 계층이 대부분의 스트림 관리를 처리합니다. HTTP는 QUIC를 사용할 때 별도의 멀티플렉싱을 수행할 필요가 없습니다. QUIC 스트림을 통해 전송된 데이터는 항상 특정 HTTP 트랜잭션 또는 전체 HTTP/3 연결 컨텍스트에 매핑됩니다.

---
### **6.1.  Bidirectional Streams**

클라이언트가 시작한 모든 양방향 스트림은 HTTP 요청 및 응답에 사용됩니다. 양방향 스트림은 응답이 요청과 쉽게 연관될 수 있도록 보장합니다. 이러한 스트림을 요청 스트림이라고 합니다.

이는 클라이언트의 첫 번째 요청이 QUIC 스트림 0에서 발생하고 후속 요청이 스트림 4, 8 등에서 발생한다는 것을 의미합니다. 이러한 스트림이 열리도록 허용하려면 HTTP/3 서버는 허용된 스트림 수와 초기 스트림 흐름 제어 창에 대해 0이 아닌 최소값을 구성해야 합니다. 병렬성을 불필요하게 제한하지 않으려면 한 번에 최소 100개의 요청 스트림을 허용해야 합니다.\(SHOULD, SHOULD\)

HTTP/3은 서버에서 시작하는 양방향 스트림을 사용하지 않지만 확장 프로그램에서 이러한 스트림에 대한 용도를 정의할 수 있습니다. 클라이언트는 그러한 확장이 협상되지 않는 한 서버가 시작한 양방향 스트림의 수신을 H3\_STREAM\_CREATION\_ERROR 유형의 연결 오류로 처리해야 합니다.\(MUST\)

---
### **6.2.  Unidirectional Streams**

어느 방향이든 단방향 스트림은 다양한 목적으로 사용됩니다. 목적은 스트림 시작 시 가변 길이 정수로 전송되는 스트림 유형으로 표시됩니다. 이 정수 뒤에 오는 데이터의 형식과 구조는 스트림 유형에 따라 결정됩니다.

```text
   Unidirectional Stream Header {
     Stream Type (i),
   }

                   Figure 1: Unidirectional Stream Header
```

이 문서에는 제어 스트림\(섹션 6.2.1\)과 푸시 스트림\(섹션 6.2.2\)이라는 두 가지 스트림 유형이 정의되어 있습니다. \[QPACK\]은 두 가지 추가 스트림 유형을 정의합니다. 다른 스트림 유형은 HTTP/3 확장으로 정의할 수 있습니다. 자세한 내용은 섹션 9를 참조하세요. 일부 스트림 유형은 예약되어 있습니다\(섹션 6.2.3\).

수명 초기 단계의 HTTP/3 연결 성능은 단방향 스트림의 데이터 생성 및 교환에 민감합니다. 스트림 수 또는 이러한 스트림의 흐름 제어 창을 과도하게 제한하는 엔드포인트는 원격 피어가 제한에 일찍 도달하여 차단될 가능성을 높입니다. 특히, 구현에서는 원격 피어가 사용이 허용된 일부 단방향 스트림을 사용하여 예약된 스트림 동작\(6.2.3절\)을 실행하기를 원할 수 있다는 점을 고려해야 합니다.

각 끝점은 HTTP 제어 스트림에 대해 하나 이상의 단방향 스트림을 생성해야 합니다. QPACK에는 두 개의 추가 단방향 스트림이 필요하며 다른 확장에는 추가 스트림이 필요할 수 있습니다. 따라서 클라이언트와 서버 모두에서 보낸 전송 매개변수는 피어가 최소 3개의 단방향 스트림을 생성할 수 있도록 허용해야 합니다. 또한 이러한 전송 매개변수는 각 단방향 스트림에 최소 1,024바이트의 흐름 제어 크레딧을 제공해야 합니다\(SHOULD\).\(MUST, SHOULD\)

피어가 중요한 단방향 스트림을 생성하기 전에 모든 초기 크레딧을 소비하는 경우 엔드포인트는 더 많은 단방향 스트림을 생성하기 위해 추가 크레딧을 부여할 필요가 없습니다. 엔드포인트는 필수 확장\(예: QPACK 인코더 및 디코더 스트림\)에 필요한 단방향 스트림뿐만 아니라 HTTP 제어 스트림을 먼저 생성한 다음 피어에서 허용하는 대로 추가 스트림을 생성해야 합니다.\(SHOULD\)

스트림 헤더가 수신자가 지원하지 않는 스트림 유형을 나타내는 경우 의미를 알 수 없으므로 스트림의 나머지 부분을 사용할 수 없습니다. 알 수 없는 스트림 유형의 수신자는 스트림 읽기를 중단하거나 추가 처리 없이 들어오는 데이터를 폐기해야 합니다. 읽기가 중단된 경우 수신자는 H3\_STREAM\_CREATION\_ERROR 오류 코드 또는 예약된 오류 코드\(섹션 8.1\)를 사용해야 합니다. 수신자는 알 수 없는 스트림 유형을 모든 종류의 연결 오류로 간주해서는 안 됩니다.\(MUST, SHOULD, MUST NOT\)

특정 스트림 유형이 연결 상태에 영향을 미칠 수 있으므로 수신자는 스트림 유형을 읽기 전에 들어오는 단방향 스트림에서 데이터를 삭제해서는 안 됩니다.\(SHOULD NOT\)

구현은 피어가 스트림 유형을 지원하는지 여부를 알기 전에 스트림 유형을 보낼 수 있습니다. 그러나 QPACK 또는 기타 확장을 포함하여 기존 프로토콜 구성 요소의 상태 또는 의미를 수정할 수 있는 스트림 유형은 피어가 이를 지원하는 것으로 알려질 때까지 전송되어서는 안 됩니다.\(MAY, MUST NOT\)

달리 지정하지 않는 한 발신자는 단방향 스트림을 닫거나 재설정할 수 있습니다. 수신기는 단방향 스트림 헤더를 수신하기 전에 단방향 스트림이 닫히거나 재설정되는 것을 허용해야 합니다\(MUST\).\(MUST\)

---
#### **6.2.1.  Control Streams**

제어 스트림은 스트림 유형 0x00으로 표시됩니다. 이 스트림의 데이터는 섹션 7.2에 정의된 대로 HTTP/3 프레임으로 구성됩니다.

각 측은 연결 시작 시 단일 제어 스트림을 시작하고 해당 SETTINGS 프레임을 이 스트림의 첫 번째 프레임으로 보내야 합니다. 제어 스트림의 첫 번째 프레임이 다른 프레임 유형인 경우 이는 H3\_MISSING\_SETTINGS 유형의 연결 오류로 처리되어야 합니다. 피어당 하나의 제어 스트림만 허용됩니다. 제어 스트림이라고 주장하는 두 번째 스트림의 수신은 H3\_STREAM\_CREATION\_ERROR 유형의 연결 오류로 처리되어야 합니다. 송신자는 제어 스트림을 닫아서는 안 되며, 수신자는 송신자에게 제어 스트림을 닫도록 요청해서는 안 됩니다. 어느 시점에서든 제어 스트림이 닫히면 이는 H3\_CLOSED\_CRITICAL\_STREAM 유형의 연결 오류로 처리되어야 합니다. 연결 오류는 섹션 8에 설명되어 있습니다.\(MUST, MUST, MUST, MUST NOT, MUST\)

제어 스트림의 콘텐츠는 다른 스트림의 동작을 관리하는 데 사용되므로 엔드포인트는 피어의 제어 스트림이 차단되지 않도록 충분한 흐름 제어 크레딧을 제공해야 합니다.\(SHOULD\)

단일 양방향 스트림이 아닌 한 쌍의 단방향 스트림이 사용됩니다. 이를 통해 두 피어 모두 가능한 한 빨리 데이터를 보낼 수 있습니다. QUIC 연결에서 0-RTT를 사용할 수 있는지 여부에 따라 클라이언트나 서버가 먼저 스트림 데이터를 보낼 수 있습니다.

---
#### **6.2.2.  Push Streams**

서버 푸시는 요청이 이루어지기 전에 서버가 응답을 시작할 수 있도록 하는 HTTP/2에 도입된 선택적 기능입니다. 자세한 내용은 섹션 4.6을 참조하세요.

푸시 스트림은 스트림 유형 0x01로 표시되고 그 뒤에는 이행하는 약속의 푸시 ID가 옵니다\(가변 길이 정수로 인코딩됨\). 이 스트림의 나머지 데이터는 섹션 7.2에 정의된 대로 HTTP/3 프레임으로 구성되며 섹션 4.1에 정의된 대로 0개 이상의 임시 HTTP 응답과 단일 최종 HTTP 응답으로 약속된 서버 푸시를 이행합니다. 서버 푸시 및 푸시 ID는 섹션 4.6에 설명되어 있습니다.

서버만 푸시할 수 있습니다. 서버가 클라이언트가 시작한 푸시 스트림을 수신하는 경우 이는 H3\_STREAM\_CREATION\_ERROR 유형의 연결 오류로 처리되어야 합니다.\(MUST\)

```text
   Push Stream Header {
     Stream Type (i) = 0x01,
     Push ID (i),
   }

                        Figure 2: Push Stream Header
```

클라이언트는 푸시 스트림 헤더를 읽기 전에 푸시 스트림 읽기를 중단해서는 안 됩니다. 이는 푸시 ID가 이미 사용된 클라이언트와 서버 간에 불일치가 발생할 수 있기 때문입니다.\(SHOULD NOT\)

각 푸시 ID는 푸시 스트림 헤더에서 한 번만 사용해야 합니다. 클라이언트가 푸시 스트림 헤더에 다른 푸시 스트림 헤더에서 사용된 푸시 ID가 포함되어 있음을 감지하면 클라이언트는 이를 H3\_ID\_ERROR 유형의 연결 오류로 처리해야 합니다.\(MUST, MUST\)

---
#### **6.2.3.  Reserved Stream Types**

N의 음수가 아닌 정수 값에 대한 0x1f \* N + 0x21 형식의 스트림 유형은 알 수 없는 유형이 무시된다는 요구 사항을 실행하기 위해 예약되어 있습니다. 이러한 스트림에는 의미 체계가 없으며 애플리케이션 계층 패딩이 필요할 때 전송될 수 있습니다. 현재 데이터가 전송되지 않는 연결에서도 전송될 수도 있습니다. 엔드포인트는 이러한 스트림을 수신 시 의미가 있다고 간주해서는 안 됩니다.\(MAY, MUST NOT\)

스트림의 페이로드와 길이는 전송 구현이 선택하는 방식으로 선택됩니다. 예약된 스트림 유형을 전송할 때 구현은 스트림을 완전히 종료하거나 재설정할 수 있습니다. 스트림을 재설정할 때 H3\_NO\_ERROR 오류 코드 또는 예약된 오류 코드\(8.1절\)를 사용해야 합니다.\(MAY, SHOULD\)

---
## **7.  HTTP Framing Layer**

HTTP 프레임은 섹션 6에 설명된 대로 QUIC 스트림을 통해 전달됩니다. HTTP/3은 제어 스트림, 요청 스트림 및 푸시 스트림의 세 가지 스트림 유형을 정의합니다. 이 섹션에서는 HTTP/3 프레임 형식과 허용되는 스트림 유형에 대해 설명합니다. 개요는 표 1을 참조하세요. HTTP/2와 HTTP/3 프레임 간의 비교는 부록 A.2에 나와 있습니다.

```text
   +==============+================+================+========+=========+
   | Frame        | Control Stream | Request        | Push   | Section |
   |              |                | Stream         | Stream |         |
   +==============+================+================+========+=========+
   | DATA         | No             | Yes            | Yes    | Section |
   |              |                |                |        | 7.2.1   |
   +--------------+----------------+----------------+--------+---------+
   | HEADERS      | No             | Yes            | Yes    | Section |
   |              |                |                |        | 7.2.2   |
   +--------------+----------------+----------------+--------+---------+
   | CANCEL_PUSH  | Yes            | No             | No     | Section |
   |              |                |                |        | 7.2.3   |
   +--------------+----------------+----------------+--------+---------+
   | SETTINGS     | Yes (1)        | No             | No     | Section |
   |              |                |                |        | 7.2.4   |
   +--------------+----------------+----------------+--------+---------+
   | PUSH_PROMISE | No             | Yes            | No     | Section |
   |              |                |                |        | 7.2.5   |
   +--------------+----------------+----------------+--------+---------+
   | GOAWAY       | Yes            | No             | No     | Section |
   |              |                |                |        | 7.2.6   |
   +--------------+----------------+----------------+--------+---------+
   | MAX_PUSH_ID  | Yes            | No             | No     | Section |
   |              |                |                |        | 7.2.7   |
   +--------------+----------------+----------------+--------+---------+
   | Reserved     | Yes            | Yes            | Yes    | Section |
   |              |                |                |        | 7.2.8   |
   +--------------+----------------+----------------+--------+---------+

              Table 1: HTTP/3 Frames and Stream Type Overview
```

SETTINGS 프레임은 제어 스트림의 첫 번째 프레임으로만 발생할 수 있습니다. 이는 표 1에 \(1\)로 표시되어 있습니다. 관련 섹션에 구체적인 지침이 제공됩니다.

QUIC 프레임과 달리 HTTP/3 프레임은 여러 패킷에 걸쳐 있을 수 있습니다.

---
### **7.1.  Frame Layout**

모든 프레임의 형식은 다음과 같습니다.

```text
   HTTP/3 Frame Format {
     Type (i),
     Length (i),
     Frame Payload (..),
   }

                       Figure 3: HTTP/3 Frame Format
```

프레임에는 다음 필드가 포함됩니다.

유형: 프레임 유형을 식별하는 가변 길이 정수입니다.

길이: 프레임 페이로드의 길이를 바이트 단위로 설명하는 가변 길이 정수입니다.

프레임 페이로드: 페이로드의 의미는 유형 필드에 의해 결정됩니다.

각 프레임의 페이로드는 해당 설명에서 식별된 필드를 정확하게 포함해야 합니다. 식별된 필드 뒤에 추가 바이트를 포함하는 프레임 페이로드 또는 식별된 필드가 끝나기 전에 종료되는 프레임 페이로드는 H3\_FRAME\_ERROR 유형의 연결 오류로 처리되어야 합니다. 특히, 중복 길이 인코딩은 자체 일관성이 있는지 확인해야 합니다. 섹션 10.8을 참조하세요.\(MUST, MUST, MUST\)

스트림이 완전히 종료될 때 스트림의 마지막 프레임이 잘린 경우 이는 H3\_FRAME\_ERROR 유형의 연결 오류로 처리되어야 합니다. 갑자기 종료되는 스트림은 프레임의 어느 지점에서나 재설정될 수 있습니다.\(MUST\)

---
### **7.2.  Frame Definitions**
---
#### **7.2.1.  DATA**

DATA 프레임\(유형=0x00\)은 HTTP 요청 또는 응답 콘텐츠와 관련된 임의의 가변 길이 바이트 시퀀스를 전달합니다.

DATA 프레임은 반드시 HTTP 요청 또는 응답과 연결되어야 합니다. DATA 프레임이 제어 스트림에서 수신되면 수신자는 H3\_FRAME\_UNEXPECTED 유형의 연결 오류로 응답해야 합니다.\(MUST, MUST\)

```text
   DATA Frame {
     Type (i) = 0x00,
     Length (i),
     Data (..),
   }

                            Figure 4: DATA Frame
```

---
#### **7.2.2.  HEADERS**

HEADERS 프레임\(유형=0x01\)은 QPACK을 사용하여 인코딩된 HTTP 필드 섹션을 전달하는 데 사용됩니다. 자세한 내용은 \[QPACK\]을 참조하세요.

```text
   HEADERS Frame {
     Type (i) = 0x01,
     Length (i),
     Encoded Field Section (..),
   }

                          Figure 5: HEADERS Frame
```

HEADERS 프레임은 요청 스트림 또는 푸시 스트림에서만 전송할 수 있습니다. HEADERS 프레임이 제어 스트림에서 수신되면 수신자는 H3\_FRAME\_UNEXPECTED 유형의 연결 오류로 응답해야 합니다.\(MUST\)

---
#### **7.2.3.  CANCEL_PUSH**

CANCEL\_PUSH 프레임\(유형=0x03\)은 푸시 스트림이 수신되기 전에 서버 푸시 취소를 요청하는 데 사용됩니다. CANCEL\_PUSH 프레임은 가변 길이 정수로 인코딩된 푸시 ID\(섹션 4.6 참조\)로 서버 푸시를 식별합니다.

클라이언트가 CANCEL\_PUSH 프레임을 보낼 때 이는 약속된 리소스를 수신하고 싶지 않음을 나타냅니다. 서버는 리소스 전송을 중단해야 하지만 이를 수행하는 메커니즘은 해당 푸시 스트림의 상태에 따라 다릅니다. 서버가 아직 푸시 스트림을 생성하지 않은 경우 푸시 스트림을 생성하지 않습니다. 푸시 스트림이 열려 있으면 서버는 해당 스트림을 갑자기 종료해야 합니다. 푸시 스트림이 이미 종료된 경우 서버는 여전히 스트림을 갑자기 종료하거나 아무 조치도 취하지 않을 수 있습니다.\(SHOULD, SHOULD, MAY\)

서버는 이전에 보낸 약속을 이행하지 않을 것임을 나타내기 위해 CANCEL\_PUSH 프레임을 보냅니다. 클라이언트는 약속된 응답을 이미 수신하고 처리하지 않는 한 해당 약속이 이행되기를 기대할 수 없습니다. 푸시 스트림이 열렸는지 여부에 관계없이 서버는 약속이 이행되지 않을 것이라고 판단되면 CANCEL\_PUSH 프레임을 보내야 합니다. 스트림이 이미 열려 있는 경우 서버는 H3\_REQUEST\_CANCELLED 오류 코드와 함께 스트림 전송을 중단할 수 있습니다.\(SHOULD\)

CANCEL\_PUSH 프레임 전송은 기존 푸시 스트림 상태에 직접적인 영향을 미치지 않습니다. 클라이언트는 해당 푸시 스트림을 이미 수신한 경우 CANCEL\_PUSH 프레임을 보내면 안 됩니다. 서버가 CANCEL\_PUSH를 처리하지 않았을 수 있으므로 클라이언트가 CANCEL\_PUSH 프레임을 보낸 후에 푸시 스트림이 도착할 수 있습니다. 클라이언트는 H3\_REQUEST\_CANCELLED 오류 코드로 스트림 읽기를 중단해야 합니다.\(SHOULD NOT, SHOULD\)

CANCEL\_PUSH 프레임이 제어 스트림으로 전송됩니다. 제어 스트림이 아닌 스트림에서 CANCEL\_PUSH 프레임을 수신하는 것은 H3\_FRAME\_UNEXPECTED 유형의 연결 오류로 처리되어야 합니다.\(MUST\)

```text
   CANCEL_PUSH Frame {
     Type (i) = 0x03,
     Length (i),
     Push ID (i),
   }

                        Figure 6: CANCEL_PUSH Frame
```

CANCEL\_PUSH 프레임은 가변 길이 정수로 인코딩된 푸시 ID를 전달합니다. 푸시 ID 필드는 취소되는 서버 푸시를 식별합니다. 섹션 4.6을 참조하세요. 현재 연결에 허용된 것보다 큰 푸시 ID를 참조하는 CANCEL\_PUSH 프레임이 수신된 경우 이는 H3\_ID\_ERROR 유형의 연결 오류로 처리되어야 합니다.\(MUST\)

클라이언트가 CANCEL\_PUSH 프레임을 수신하는 경우 해당 프레임은 재정렬로 인해 PUSH\_PROMISE 프레임에서 아직 언급되지 않은 푸시 ID를 식별할 수 있습니다. 서버가 PUSH\_PROMISE 프레임에서 아직 언급되지 않은 푸시 ID에 대한 CANCEL\_PUSH 프레임을 수신하는 경우 이는 H3\_ID\_ERROR 유형의 연결 오류로 처리되어야 합니다.\(MUST\)

---
#### **7.2.4.  SETTINGS**

SETTINGS 프레임\(유형=0x04\)은 피어 동작에 대한 기본 설정 및 제약 조건과 같이 엔드포인트의 통신 방식에 영향을 미치는 구성 매개변수를 전달합니다. 개별적으로 SETTINGS 매개변수는 "설정"이라고도 합니다. 각 설정 매개변수의 식별자와 값은 "설정 식별자" 및 "설정 값"으로 지칭될 수 있습니다.

SETTINGS 프레임은 항상 단일 스트림이 아닌 전체 HTTP/3 연결에 적용됩니다. SETTINGS 프레임은 각 피어에 의해 각 제어 스트림\(섹션 6.2.1 참조\)의 첫 번째 프레임으로 전송되어야 하며 이후에 전송되어서는 안 됩니다. 엔드포인트가 제어 스트림에서 두 번째 SETTINGS 프레임을 수신하는 경우 엔드포인트는 H3\_FRAME\_UNEXPECTED 유형의 연결 오류로 응답해야 합니다.\(MUST NOT, MUST\)

SETTINGS 프레임은 제어 스트림 이외의 다른 스트림으로 전송되어서는 안 됩니다. 엔드포인트가 다른 스트림에서 SETTINGS 프레임을 수신하는 경우 엔드포인트는 H3\_FRAME\_UNEXPECTED 유형의 연결 오류로 응답해야 합니다.\(MUST NOT, MUST\)

SETTINGS 매개변수는 협상되지 않습니다. 이는 수신 피어가 사용할 수 있는 송신 피어의 특성을 설명합니다. 그러나 SETTINGS를 사용하면 협상이 암시될 수 있습니다. 각 피어는 SETTINGS를 사용하여 지원되는 값 집합을 광고합니다. 설정의 정의는 각 피어가 두 세트를 결합하여 어떤 선택이 사용될지 결론을 내리는 방법을 설명합니다. SETTINGS는 선택 사항이 적용되는 시점을 식별하는 메커니즘을 제공하지 않습니다.

동일한 매개변수에 대해 서로 다른 값을 각 피어에서 알릴 수 있습니다. 예를 들어 클라이언트는 매우 큰 응답 필드 섹션을 기꺼이 사용하려는 반면 서버는 요청 크기에 대해 더 신중할 수 있습니다.

동일한 설정 식별자는 SETTINGS 프레임에서 두 번 이상 발생해서는 안 됩니다. 수신기는 중복된 설정 식별자의 존재를 H3\_SETTINGS\_ERROR 유형의 연결 오류로 처리할 수 있습니다.\(MUST NOT, MAY\)

SETTINGS 프레임의 페이로드는 0개 이상의 매개변수로 구성됩니다. 각 매개변수는 설정 식별자와 값으로 구성되며 둘 다 QUIC 가변 길이 정수로 인코딩됩니다.

```text
   Setting {
     Identifier (i),
     Value (i),
   }

   SETTINGS Frame {
     Type (i) = 0x04,
     Length (i),
     Setting (..) ...,
   }

                          Figure 7: SETTINGS Frame
```

구현은 이해하지 못하는 식별자가 있는 매개변수를 무시해야 합니다.\(MUST\)

---
##### **7.2.4.1.  Defined SETTINGS Parameters**

HTTP/3에는 다음 설정이 정의되어 있습니다.

SETTINGS\_MAX\_FIELD\_SECTION\_SIZE\(0x06\): 기본값은 무제한입니다. 사용법은 섹션 4.2.2를 참조하세요.

N의 음수가 아닌 정수 값에 대해 0x1f \* N + 0x21 형식의 식별자 설정은 알 수 없는 식별자를 무시해야 한다는 요구 사항을 실행하기 위해 예약되어 있습니다. 이러한 설정에는 정의된 의미가 없습니다. 엔드포인트는 SETTINGS 프레임에 이러한 설정을 하나 이상 포함해야 합니다. 엔드포인트는 이러한 설정을 수신 시 의미가 있다고 간주해서는 안 됩니다.\(SHOULD, MUST NOT\)

설정에는 정의된 의미가 없으므로 설정 값은 구현에서 선택하는 모든 값이 될 수 있습니다.

해당 HTTP/3 설정이 없는 \[HTTP/2\]에 정의된 설정 식별자도 예약되어 있습니다\(11.2.2절\). 이러한 예약된 설정은 전송되어서는 안 되며, 해당 수신은 H3\_SETTINGS\_ERROR 유형의 연결 오류로 처리되어야 합니다.\(MUST NOT\)

HTTP/3 확장을 통해 추가 설정을 정의할 수 있습니다. 자세한 내용은 섹션 9를 참조하세요.

---
##### **7.2.4.2.  Initialization**

HTTP 구현은 피어 설정에 대한 현재 이해를 기반으로 유효하지 않은 프레임이나 요청을 전송해서는 안 됩니다.\(MUST NOT\)

모든 설정은 초기값에서 시작됩니다. 설정을 전달하는 패킷이 손실되거나 지연될 수 있으므로 각 엔드포인트는 피어의 SETTINGS 프레임이 도착하기 전에 이러한 초기 값을 사용하여 메시지를 보내야 합니다\(SHOULD\). SETTINGS 프레임이 도착하면 모든 설정이 새 값으로 변경됩니다.\(SHOULD\)

이렇게 하면 메시지를 보내기 전에 SETTINGS 프레임을 기다릴 필요가 없습니다. 엔드포인트는 SETTINGS 프레임을 전송하기 전에 피어로부터 데이터를 수신하도록 요구해서는 안 됩니다. 전송이 데이터를 보낼 준비가 되자마자 설정을 보내야 합니다.\(MUST NOT\)

서버의 경우 각 클라이언트 설정의 초기값은 기본값입니다.

1-RTT QUIC 연결을 사용하는 클라이언트의 경우 각 서버 설정의 초기값은 기본값입니다. 1-RTT 키는 서버가 SETTINGS를 즉시 전송하더라도 QUIC가 SETTINGS를 포함하는 패킷을 처리하기 전에 항상 사용할 수 있게 됩니다. 클라이언트는 요청을 보내기 전에 SETTINGS가 도착할 때까지 무기한 기다리면 안 되지만, 첫 번째 요청을 보내기 전에 SETTINGS를 처리할 가능성을 높이기 위해 수신된 데이터그램을 처리해야 합니다.\(SHOULD NOT\)

0-RTT QUIC 연결을 사용하는 경우 각 서버 설정의 초기 값은 이전 세션에서 사용된 값입니다. 클라이언트는 재개 정보가 제공된 HTTP/3 연결에서 서버가 제공한 설정을 저장해야 하지만 특정 경우\(예: 세션 티켓이 SETTINGS 프레임 전에 수신된 경우\)에는 설정을 저장하지 않도록 선택할 수도 있습니다. 클라이언트는 0-RTT를 시도할 때 저장된 설정\(값이 저장되지 않은 경우 기본값\)을 준수해야 합니다. 서버가 새로운 설정을 제공하면 클라이언트는 해당 값을 준수해야 합니다.\(SHOULD, MUST, MUST\)

서버는 자신이 광고한 설정을 기억하거나 티켓 값의 무결성 보호 복사본을 저장하고 0-RTT 데이터를 수락할 때 정보를 복구할 수 있습니다. 서버는 0-RTT 데이터 허용 여부를 결정할 때 HTTP/3 설정 값을 사용합니다. 서버가 클라이언트가 기억하는 설정이 현재 설정과 호환되는지 확인할 수 없는 경우 0-RTT 데이터를 수락해서는 안 됩니다. 해당 설정을 준수하는 클라이언트가 서버의 현재 설정을 위반하지 않는 경우 기억된 설정은 호환 가능합니다.\(MUST NOT\)

서버는 0-RTT를 수락한 후 SETTINGS 프레임에 다른 설정을 제공할 수 있습니다. 서버가 0-RTT 데이터를 수락하는 경우 해당 SETTINGS 프레임은 클라이언트가 0-RTT 데이터로 위반할 수 있는 제한을 줄이거나 값을 변경해서는 안 됩니다. 서버에는 기본값과 다른 모든 설정이 포함되어야 합니다. 서버가 0-RTT를 수락했지만 이전에 지정된 설정과 호환되지 않는 설정을 보내는 경우 이는 H3\_SETTINGS\_ERROR 유형의 연결 오류로 처리되어야 합니다. 서버가 0-RTT를 수락했지만 이전에 기본값이 아닌 값을 갖도록 지정된 클라이언트가 이해하는 설정 값\(예약된 설정 식별자는 제외\)을 생략하는 SETTINGS 프레임을 보내는 경우 이는 다음의 연결 오류로 처리되어야 합니다. H3\_SETTINGS\_ERROR를 입력하세요.\(MAY, MUST NOT, MUST, MUST, MUST\)

---
#### **7.2.5.  PUSH_PROMISE**

PUSH\_PROMISE 프레임\(유형=0x05\)은 요청 스트림을 통해 서버에서 클라이언트로 약속된 요청 헤더 섹션을 전달하는 데 사용됩니다.

```text
   PUSH_PROMISE Frame {
     Type (i) = 0x05,
     Length (i),
     Push ID (i),
     Encoded Field Section (..),
   }

                        Figure 8: PUSH_PROMISE Frame
```

페이로드는 다음으로 구성됩니다.

푸시 ID: 서버 푸시 작업을 식별하는 가변 길이 정수입니다. 푸시 ID는 푸시 스트림 헤더\(섹션 4.6\) 및 CANCEL\_PUSH 프레임에 사용됩니다.

인코딩된 필드 섹션: 약속된 응답에 대한 QPACK 인코딩 요청 헤더 필드입니다. 자세한 내용은 \[QPACK\]을 참조하세요.

서버는 클라이언트가 MAX\_PUSH\_ID 프레임\(7.2.7절\)에 제공한 것보다 큰 푸시 ID를 사용해서는 안 됩니다. 클라이언트는 클라이언트가 H3\_ID\_ERROR의 연결 오류로 광고한 것보다 더 큰 푸시 ID를 포함하는 PUSH\_PROMISE 프레임의 수신을 처리해야 합니다.\(MUST NOT, MUST\)

서버는 여러 PUSH\_PROMISE 프레임에서 동일한 푸시 ID를 사용할 수 있습니다. 그렇다면 압축 해제된 요청 헤더 세트는 동일한 필드를 동일한 순서로 포함해야 하며 각 필드의 이름과 값은 모두 정확히 일치해야 합니다. 클라이언트는 약속된 리소스에 대한 요청 헤더 섹션을 여러 번 비교해야 합니다\(SHOULD\). 클라이언트가 이미 약속된 푸시 ID를 수신하고 불일치를 감지한 경우 H3\_GENERAL\_PROTOCOL\_ERROR 유형의 연결 오류로 응답해야 합니다. 압축 해제된 필드 섹션이 정확히 일치하는 경우 클라이언트는 푸시된 콘텐츠를 PUSH\_PROMISE 프레임이 수신된 각 스트림과 연결해야 합니다.\(MAY, MUST, SHOULD, MUST, SHOULD\)

동일한 푸시 ID에 대한 중복 참조를 허용하는 것은 주로 동시 요청으로 인한 중복을 줄이기 위한 것입니다. 서버는 장기간에 걸쳐 푸시 ID를 재사용하는 것을 피해야 합니다\(SHOULD\). 클라이언트는 서버 푸시 응답을 소비하고 시간이 지나도 재사용을 위해 이를 유지하지 않을 가능성이 있습니다. 이미 사용하고 폐기한 푸시 ID를 사용하는 PUSH\_PROMISE 프레임을 보는 클라이언트는 약속을 무시해야 합니다.\(SHOULD\)

PUSH\_PROMISE 프레임이 제어 스트림에서 수신되면 클라이언트는 H3\_FRAME\_UNEXPECTED 유형의 연결 오류로 응답해야 합니다.\(MUST\)

클라이언트는 PUSH\_PROMISE 프레임을 보내면 안 됩니다. 서버는 PUSH\_PROMISE 프레임 수신을 H3\_FRAME\_UNEXPECTED 유형의 연결 오류로 처리해야 합니다.\(MUST NOT, MUST\)

전체 서버 푸시 메커니즘에 대한 설명은 섹션 4.6을 참조하세요.

---
#### **7.2.6.  GOAWAY**

GOAWAY 프레임\(유형=0x07\)은 양쪽 끝점에서 HTTP/3 연결의 정상적인 종료를 시작하는 데 사용됩니다. GOAWAY를 사용하면 엔드포인트가 이전에 수신된 요청 및 푸시 처리를 계속 완료하면서 새 요청 또는 푸시 수락을 중지할 수 있습니다. 이를 통해 서버 유지 관리와 같은 관리 작업이 가능해집니다. GOAWAY 자체로는 연결을 닫지 않습니다.

```text
   GOAWAY Frame {
     Type (i) = 0x07,
     Length (i),
     Stream ID/Push ID (i),
   }

                           Figure 9: GOAWAY Frame
```

GOAWAY 프레임은 항상 제어 스트림을 통해 전송됩니다. 서버-클라이언트 방향에서는 가변 길이 정수로 인코딩된 클라이언트 시작 양방향 스트림에 대한 QUIC 스트림 ID를 전달합니다. 클라이언트는 다른 유형의 스트림 ID를 포함하는 GOAWAY 프레임의 수신을 H3\_ID\_ERROR 유형의 연결 오류로 처리해야 합니다.\(MUST\)

클라이언트-서버 방향에서 GOAWAY 프레임은 가변 길이 정수로 인코딩된 푸시 ID를 전달합니다.

GOAWAY 프레임은 특정 스트림이 아닌 전체 연결에 적용됩니다. 클라이언트는 제어 스트림이 아닌 스트림의 GOAWAY 프레임을 H3\_FRAME\_UNEXPECTED 유형의 연결 오류로 처리해야 합니다.\(MUST\)

GOAWAY 프레임 사용에 대한 자세한 내용은 섹션 5.2를 참조하세요.

---
#### **7.2.7.  MAX_PUSH_ID**

MAX\_PUSH\_ID 프레임\(유형=0x0d\)은 클라이언트가 서버가 시작할 수 있는 서버 푸시 수를 제어하는 ​​데 사용됩니다. 서버가 PUSH\_PROMISE 및 CANCEL\_PUSH 프레임에서 사용할 수 있는 푸시 ID의 최대값을 설정합니다. 결과적으로 이는 QUIC 전송에 의해 유지되는 제한 외에도 서버가 시작할 수 있는 푸시 스트림의 수도 제한합니다.

MAX\_PUSH\_ID 프레임은 항상 제어 스트림을 통해 전송됩니다. 다른 스트림에서 MAX\_PUSH\_ID 프레임 수신은 H3\_FRAME\_UNEXPECTED 유형의 연결 오류로 처리되어야 합니다.\(MUST\)

서버는 MAX\_PUSH\_ID 프레임을 보내면 안 됩니다. 클라이언트는 MAX\_PUSH\_ID 프레임 수신을 H3\_FRAME\_UNEXPECTED 유형의 연결 오류로 처리해야 합니다.\(MUST NOT, MUST\)

HTTP/3 연결이 생성되면 최대 푸시 ID가 설정되지 않습니다. 즉, 서버는 MAX\_PUSH\_ID 프레임을 수신할 때까지 푸시할 수 없습니다. 약속된 서버 푸시 횟수를 관리하려는 클라이언트는 서버가 서버 푸시를 이행하거나 취소할 때 MAX\_PUSH\_ID 프레임을 전송하여 최대 푸시 ID를 늘릴 수 있습니다.

```text
   MAX_PUSH_ID Frame {
     Type (i) = 0x0d,
     Length (i),
     Push ID (i),
   }

                        Figure 10: MAX_PUSH_ID Frame
```

MAX\_PUSH\_ID 프레임은 서버가 사용할 수 있는 푸시 ID의 최대값을 식별하는 단일 가변 길이 정수를 전달합니다. 섹션 4.6을 참조하세요. MAX\_PUSH\_ID 프레임은 최대 푸시 ID를 줄일 수 없습니다. 이전에 수신된 것보다 더 작은 값을 포함하는 MAX\_PUSH\_ID 프레임의 수신은 H3\_ID\_ERROR 유형의 연결 오류로 처리되어야 합니다.\(MUST\)

---
#### **7.2.8.  Reserved Frame Types**

N의 음수가 아닌 정수 값에 대한 0x1f \* N + 0x21 형식의 프레임 유형은 알 수 없는 유형을 무시해야 한다는 요구 사항을 실행하기 위해 예약되어 있습니다\(섹션 9\). 이러한 프레임에는 의미가 없으며 프레임 전송이 허용되는 모든 스트림에서 전송될 수 있습니다. 이를 통해 애플리케이션 레이어 패딩에 사용할 수 있습니다. 엔드포인트는 이러한 프레임을 수신 시 어떤 의미도 갖는 것으로 간주해서는 안 됩니다.\(MAY, MUST NOT\)

프레임의 페이로드와 길이는 구현이 선택하는 방식으로 선택됩니다.

해당 HTTP/3 프레임이 없는 HTTP/2에서 사용된 프레임 유형도 예약되었습니다\(11.2.1절\). 이러한 프레임 유형은 전송되어서는 안 되며, 해당 수신은 H3\_FRAME\_UNEXPECTED 유형의 연결 오류로 처리되어야 합니다.\(MUST NOT\)

---
## **8.  Error Handling**

스트림이 성공적으로 완료될 수 없는 경우, QUIC는 애플리케이션이 해당 스트림을 갑자기 종료\(재설정\)하고 이유를 전달할 수 있도록 합니다. \[QUIC-TRANSPORT\]의 섹션 2.4를 참조하세요. 이를 "스트림 오류"라고 합니다. HTTP/3 구현은 QUIC 스트림을 닫고 오류 유형을 전달하기로 결정할 수 있습니다. 오류 코드의 와이어 인코딩은 섹션 8.1에 정의되어 있습니다. 스트림 오류는 오류 조건을 나타내는 HTTP 상태 코드와 다릅니다. 스트림 오류는 보낸 사람이 전체 요청 또는 응답을 전송하거나 사용하지 않았음을 나타내고, HTTP 상태 코드는 성공적으로 수신된 요청의 결과를 나타냅니다.

전체 연결을 종료해야 하는 경우 QUIC는 마찬가지로 이유를 전달하는 메커니즘을 제공합니다. \[QUIC-TRANSPORT\]의 섹션 5.3을 참조하세요. 이를 "연결 오류"라고 합니다. 스트림 오류와 마찬가지로 HTTP/3 구현은 QUIC 연결을 종료하고 섹션 8.1의 오류 코드를 사용하여 이유를 전달할 수 있습니다.

스트림과 연결을 닫는 이유를 "오류"라고 부르지만 이러한 작업이 반드시 연결이나 구현에 문제가 있음을 나타내는 것은 아닙니다. 예를 들어 요청한 리소스가 더 이상 필요하지 않으면 스트림을 재설정할 수 있습니다.

엔드포인트는 특정 상황에서 스트림 오류를 연결 오류로 처리하여 단일 스트림의 조건에 대한 응답으로 전체 연결을 닫도록 선택할 수 있습니다. 구현에서는 이 선택을 하기 전에 미해결 요청에 대한 영향을 고려해야 합니다.\(MAY\)

새로운 오류 코드는 협상 없이 정의될 수 있으므로\(섹션 9 참조\) 예상치 못한 상황에서 오류 코드를 사용하거나 알 수 없는 오류 코드를 수신하는 것은 H3\_NO\_ERROR와 동일하게 처리되어야 합니다. 그러나 스트림을 닫으면 오류 코드에 관계없이 다른 영향을 미칠 수 있습니다. 예를 들어 섹션 4.1을 참조하세요.\(MUST\)

---
### **8.1.  HTTP/3 Error Codes**

다음 오류 코드는 스트림을 갑자기 종료하거나, 스트림 읽기를 중단하거나, HTTP/3 연결을 즉시 닫을 때 사용하도록 정의됩니다.

H3\_NO\_ERROR \(0x0100\): 오류가 없습니다. 연결이나 스트림을 닫아야 하는데 신호에 오류가 없는 경우에 사용됩니다.

H3\_GENERAL\_PROTOCOL\_ERROR \(0x0101\): 피어가 프로토콜을 위반했습니다.

- 더 구체적인 오류 코드와 일치하지 않는 방식의 요구 사항 또는 엔드포인트가 더 구체적인 오류 코드 사용을 거부합니다.

H3\_INTERNAL\_ERROR \(0x0102\): HTTP 스택에 내부 오류가 발생했습니다.

H3\_STREAM\_CREATION\_ERROR \(0x0103\): 엔드포인트가 피어가 허용하지 않는 스트림을 생성했음을 감지했습니다.

H3\_CLOSED\_CRITICAL\_STREAM\(0x0104\): HTTP/3 연결에 필요한 스트림이 닫혔거나 재설정되었습니다.

H3\_FRAME\_UNEXPECTED \(0x0105\): 현재 상태 또는 현재 스트림에서 허용되지 않는 프레임이 수신되었습니다.

H3\_FRAME\_ERROR \(0x0106\): 레이아웃 요구 사항을 충족하지 못하거나 잘못된 크기의 프레임이 수신되었습니다.

H3\_EXCESSIVE\_LOAD\(0x0107\): 엔드포인트가 해당 피어가 과도한 로드를 생성할 수 있는 동작을 보이고 있음을 감지했습니다.

H3\_ID\_ERROR \(0x0108\): 스트림 ID 또는 푸시 ID가 한도 초과, 한도 감소, 재사용 등 잘못 사용되었습니다.

H3\_SETTINGS\_ERROR \(0x0109\): 엔드포인트가 SETTINGS 프레임의 페이로드에서 오류를 감지했습니다.

H3\_MISSING\_SETTINGS \(0x010a\): 제어 스트림 시작 부분에서 SETTINGS 프레임이 수신되지 않았습니다.

H3\_REQUEST\_REJECTED \(0x010b\): 서버가 애플리케이션 처리를 수행하지 않고 요청을 거부했습니다.

H3\_REQUEST\_CANCELLED \(0x010c\): 요청 또는 그에 대한 응답

- \(푸시응답 포함\) 취소됩니다.

H3\_REQUEST\_INCOMPLETE \(0x010d\): 클라이언트의 스트림이 완전한 형식의 요청을 포함하지 않고 종료되었습니다.

H3\_MESSAGE\_ERROR \(0x010e\): HTTP 메시지의 형식이 잘못되어 처리할 수 없습니다.

H3\_CONNECT\_ERROR \(0x010f\): CONNECT 요청에 대한 응답으로 설정된 TCP 연결이 재설정되었거나 비정상적으로 종료되었습니다.

H3\_VERSION\_FALLBACK \(0x0110\): 요청한 작업을 HTTP/3을 통해 제공할 수 없습니다. 피어는 HTTP/1.1을 통해 다시 시도해야 합니다.

N의 음수가 아닌 정수 값에 대한 0x1f \* N + 0x21 형식의 오류 코드는 알 수 없는 오류 코드가 H3\_NO\_ERROR\(섹션 9\)와 동일하게 처리되어야 한다는 요구 사항을 실행하기 위해 예약되어 있습니다. 구현은 H3\_NO\_ERROR를 보냈을 때 어느 정도 확률로 이 공간에서 오류 코드를 선택해야 합니다.\(SHOULD\)

---
## **9.  Extensions to HTTP/3**

HTTP/3은 프로토콜 확장을 허용합니다. 이 섹션에 설명된 제한 내에서 프로토콜 확장을 사용하여 추가 서비스를 제공하거나 프로토콜의 모든 측면을 변경할 수 있습니다. 확장은 단일 HTTP/3 연결 범위 내에서만 유효합니다.

이는 이 문서에 정의된 프로토콜 요소에 적용됩니다. 이는 새 메소드, 상태 코드 또는 필드 정의와 같은 HTTP 확장을 위한 기존 옵션에 영향을 주지 않습니다.

확장은 새로운 프레임 유형\(섹션 7.2\), 새로운 설정\(섹션 7.2.4.1\), 새로운 오류 코드\(섹션 8\) 또는 새로운 단방향 스트림 유형\(섹션 6.2\)을 사용하도록 허용됩니다. 프레임 유형\(섹션 11.2.1\), 설정\(섹션 11.2.2\), 오류 코드\(섹션 11.2.3\) 및 스트림 유형\(섹션 11.2.4\)과 같은 확장 지점을 관리하기 위해 레지스트리가 설정됩니다.

구현 시 모든 확장 가능한 프로토콜 요소에서 알 수 없거나 지원되지 않는 값을 무시해야 합니다\(MUST\). 구현 시에는 알 수 없거나 지원되지 않는 유형이 있는 단방향 스트림에 대한 데이터 읽기를 중단하거나 데이터를 삭제해야 합니다. 이는 사전 합의나 협상 없이 확장 프로그램에서 이러한 확장 포인트를 안전하게 사용할 수 있음을 의미합니다. 그러나 알려진 프레임 유형이 제어 스트림의 첫 번째 프레임인 SETTINGS 프레임과 같이 특정 위치에 있어야 하는 경우\(섹션 6.2.1 참조\) 알 수 없는 프레임 유형은 해당 요구 사항을 충족하지 않으며 처리되어야 합니다. 오류로.\(MUST, MUST, SHOULD\)

기존 프로토콜 구성 요소의 의미를 변경할 수 있는 확장은 사용하기 전에 반드시 협상되어야 합니다. 예를 들어, HEADERS 프레임의 레이아웃을 변경하는 확장은 피어가 이것이 허용된다는 긍정적인 신호를 제공할 때까지 사용할 수 없습니다. 이렇게 수정된 레이아웃이 적용될 때 조정하는 것은 복잡할 수 있습니다. 따라서 기존 프로토콜 요소의 새로운 정의를 위해 새로운 식별자를 할당하는 것이 더 효과적일 수 있습니다.\(MUST\)

이 문서는 확장 사용을 협상하기 위한 특정 방법을 요구하지는 않지만 해당 목적으로 설정\(섹션 7.2.4.1\)을 사용할 수 있음을 명시합니다. 두 피어 모두 확장을 사용할 의사가 있음을 나타내는 값을 설정하면 확장을 사용할 수 있습니다. 확장 협상에 설정이 사용되는 경우 설정이 생략되면 확장이 비활성화되는 방식으로 기본값을 정의해야 합니다.\(MUST\)

---
## **10.  Security Considerations**

HTTP/3의 보안 고려 사항은 TLS를 사용하는 HTTP/2의 보안 고려 사항과 유사해야 합니다. 그러나 \[HTTP/2\] 섹션 10의 고려 사항 중 많은 부분이 \[QUIC-TRANSPORT\]에 적용되며 해당 문서에서 논의됩니다.

---
### **10.1.  Server Authority**

HTTP/3은 권한에 대한 HTTP 정의를 따릅니다. 권한 설정에 대한 보안 고려사항은 \[HTTP\]의 섹션 17.1에서 논의됩니다.

---
### **10.2.  Cross-Protocol Attacks**

TLS 및 QUIC 핸드셰이크에서 ALPN을 사용하면 애플리케이션 계층 바이트가 처리되기 전에 대상 애플리케이션 프로토콜이 설정됩니다. 이를 통해 엔드포인트는 피어가 동일한 프로토콜을 사용하고 있다는 강력한 확신을 갖게 됩니다.

이는 모든 프로토콜 간 공격으로부터 보호를 보장하지 않습니다. \[QUIC-TRANSPORT\]의 섹션 21.5에서는 인증된 전송을 사용하지 않는 엔드포인트에 대해 요청 위조를 수행하기 위해 QUIC 패킷의 일반 텍스트를 사용할 수 있는 몇 가지 방법을 설명합니다.

---
### **10.3.  Intermediary-Encapsulation Attacks**

HTTP/3 필드 인코딩은 HTTP에서 사용되는 구문에서 유효한 필드 이름이 아닌 이름의 표현을 허용합니다\(\[HTTP\]의 섹션 5.1\). 유효하지 않은 필드 이름을 포함하는 요청 또는 응답은 잘못된 형식으로 처리되어야 합니다. 따라서 중개자는 잘못된 필드 이름이 포함된 HTTP/3 요청이나 응답을 HTTP/1.1 메시지로 변환할 수 없습니다.\(MUST\)

마찬가지로 HTTP/3은 유효하지 않은 필드 값을 전송할 수 있습니다. 인코딩될 수 있는 대부분의 값은 필드 구문 분석을 변경하지 않지만 캐리지 리턴\(ASCII 0x0d\), 줄 바꿈\(ASCII 0x0a\) 및 널 문자\(ASCII 0x00\)는 그대로 변환되면 공격자가 악용할 수 있습니다. 필드 값에 허용되지 않는 문자가 포함된 요청이나 응답은 잘못된 형식으로 처리되어야 합니다. 유효한 문자는 \[HTTP\] 섹션 5.5의 "field-content" ABNF 규칙에 의해 정의됩니다.\(MUST\)

---
### **10.4.  Cacheability of Pushed Responses**

푸시된 응답에는 클라이언트의 명시적 요청이 없습니다. 요청은 PUSH\_PROMISE 프레임에서 서버에 의해 제공됩니다.

Cache-Control 헤더 필드의 원본 서버에서 제공하는 지침에 따라 푸시되는 응답을 캐싱할 수 있습니다. 그러나 단일 서버가 둘 이상의 테넌트를 호스트하는 경우 문제가 발생할 수 있습니다. 예를 들어 서버는 여러 사용자에게 각각 URI 공간의 작은 부분을 제공할 수 있습니다.

여러 테넌트가 동일한 서버에서 공간을 공유하는 경우 해당 서버는 테넌트가 권한이 없는 리소스 표현을 푸시할 수 없도록 해야 합니다. 이를 적용하지 않으면 테넌트가 권한 있는 테넌트가 제공하는 실제 표현을 무시하고 캐시에서 제공되는 표현을 제공할 수 있습니다.\(MUST\)

클라이언트는 원본 서버가 신뢰할 수 없는 푸시된 응답을 거부해야 합니다. 섹션 4.6을 참조하세요.

---
### **10.5.  Denial-of-Service Considerations**

HTTP/3 연결은 HTTP/1.1 또는 HTTP/2 연결보다 작동하기 위해 더 많은 리소스를 요구할 수 있습니다. 필드 압축 및 흐름 제어의 사용은 더 많은 양의 상태를 저장하기 위한 리소스 투입에 따라 달라집니다. 이러한 기능을 설정하면 해당 기능에 대한 메모리 할당이 엄격하게 제한됩니다.

PUSH\_PROMISE 프레임의 수도 비슷한 방식으로 제한됩니다. 서버 푸시를 수락하는 클라이언트는 한 번에 발급하는 푸시 ID 수를 제한해야 합니다.\(SHOULD\)

처리 용량은 상태 용량만큼 효과적으로 보호할 수 없습니다.

피어가 무시해야 하는 정의되지 않은 프로토콜 요소를 보내는 기능을 남용하여 피어가 추가 처리 시간을 소비하게 할 수 있습니다. 이는 정의되지 않은 여러 SETTINGS 매개변수, 알 수 없는 프레임 유형 또는 알 수 없는 스트림 유형을 설정하여 수행할 수 있습니다. 그러나 트래픽 분석에 대한 저항을 높이기 위한 이해하기 쉬운 확장 및 패딩과 같은 일부 사용은 완전히 합법적입니다.

현장 섹션의 압축은 처리 자원을 낭비할 수 있는 기회도 제공합니다. 잠재적인 남용에 대한 자세한 내용은 \[QPACK\]의 섹션 7을 참조하세요.

이러한 모든 기능\(예: 서버 푸시, 알 수 없는 프로토콜 요소, 필드 압축\)은 합법적으로 사용됩니다. 이러한 기능은 불필요하게 또는 과도하게 사용될 때만 부담이 됩니다.

이러한 동작을 모니터링하지 않는 엔드포인트는 서비스 거부 공격의 위험에 노출됩니다. 구현에서는 이러한 기능의 사용을 추적하고 사용에 대한 제한을 설정해야 합니다\(SHOULD\). 엔드포인트는 의심스러운 활동을 H3\_EXCESSIVE\_LOAD 유형의 연결 오류로 처리할 수 있지만 거짓 긍정으로 인해 유효한 연결 및 요청이 중단될 수 있습니다.\(SHOULD, MAY\)

---
#### **10.5.1.  Limits on Field Section Size**

큰 필드 섹션\(섹션 4.1\)으로 인해 구현이 많은 양의 상태를 커밋할 수 있습니다. 라우팅에 중요한 헤더 필드는 헤더 섹션의 끝 부분에 나타날 수 있으며, 이로 인해 헤더 섹션이 최종 대상으로 스트리밍되지 않습니다. 캐시 정확성 보장과 같은 이러한 순서 및 기타 이유는 엔드포인트가 전체 헤더 섹션을 버퍼링해야 할 가능성이 있음을 의미합니다. 필드 섹션의 크기에는 엄격한 제한이 없으므로 일부 엔드포인트는 헤더 필드에 사용 가능한 많은 양의 메모리를 커밋해야 할 수 있습니다.

엔드포인트는 SETTINGS\_MAX\_FIELD\_SECTION\_SIZE\(섹션 4.2.2\) 설정을 사용하여 필드 섹션의 크기에 적용될 수 있는 제한을 피어에게 알릴 수 있습니다. 이 설정은 단지 권고사항이므로 엔드포인트는 이 제한을 초과하는 필드 섹션을 보내도록 선택할 수 있으며 요청이나 응답이 잘못된 형식으로 처리될 위험이 있습니다. 이 설정은 HTTP/3 연결에만 적용되므로 모든 요청이나 응답에서 알 수 없는 더 낮은 제한이 있는 홉이 발생할 수 있습니다. 중개자는 다른 동료가 제시한 값을 전달하여 이 문제를 방지하려고 시도할 수 있지만 그렇게 할 의무는 없습니다.\(MAY\)

처리할 수 있는 것보다 더 큰 필드 섹션을 수신하는 서버는 HTTP 431\(요청 헤더 필드가 너무 큼\) 상태 코드\(\[RFC6585\]\)를 보낼 수 있습니다. 클라이언트는 처리할 수 없는 응답을 삭제할 수 있습니다.

---
#### **10.5.2.  CONNECT Issues**

CONNECT 메서드를 사용하면 프록시에 불균형적인 부하를 생성할 수 있습니다. 왜냐하면 스트림 생성은 TCP 연결 생성 및 유지 관리에 비해 상대적으로 저렴하기 때문입니다. 따라서 CONNECT를 지원하는 프록시는 허용하는 동시 요청 수에 있어서 더 보수적일 수 있습니다.

나가는 TCP 연결이 TIME\_WAIT 상태로 유지되므로 프록시는 CONNECT 요청을 전달하는 스트림을 닫은 이후에도 TCP 연결을 위한 일부 리소스를 유지할 수도 있습니다. 이를 설명하기 위해 프록시는 TCP 연결이 종료된 후 일정 시간 동안 QUIC 스트림 제한 증가를 지연할 수 있습니다.

---
### **10.6.  Use of Compression**

압축을 사용하면 공격자가 제어하는 ​​데이터와 동일한 컨텍스트에서 비밀 데이터를 압축할 때 공격자가 비밀 데이터를 복구할 수 있습니다. HTTP/3은 필드 압축을 가능하게 합니다\(섹션 4.2\). HTTP 압축 콘텐츠 코딩 사용에도 다음과 같은 우려 사항이 적용됩니다. \[HTTP\]의 섹션 8.4.1을 참조하세요.

웹의 특성을 악용하는 압축에 대한 입증 가능한 공격이 있습니다\(예: \[BREACH\]\). 공격자는 다양한 일반 텍스트를 포함하는 여러 요청을 유도하고 각각의 결과 암호문 길이를 관찰하여 비밀에 대한 추측이 맞을 때 더 짧은 길이를 나타냅니다.

보안 채널에서 통신하는 구현은 각 데이터 소스에 대해 별도의 압축 컨텍스트가 사용되지 않는 한 기밀 데이터와 공격자가 제어하는 ​​데이터를 모두 포함하는 콘텐츠를 압축해서는 안 됩니다. 데이터 소스를 안정적으로 결정할 수 없는 경우 압축을 사용하면 안 됩니다.\(MUST NOT, MUST NOT\)

필드 섹션의 압축에 관한 추가 고려 사항은 \[QPACK\]에 설명되어 있습니다.

---
### **10.7.  Padding and Traffic Analysis**

패딩은 프레임 콘텐츠의 정확한 크기를 숨기는 데 사용할 수 있으며 HTTP 내의 특정 공격, 예를 들어 공격자가 제어하는 ​​일반 텍스트와 비밀 데이터가 모두 포함된 압축 콘텐츠 공격\(예: \[BREACH\]\)을 완화하기 위해 제공됩니다.

HTTP/2가 PADDING 프레임과 다른 프레임의 패딩 필드를 사용하여 트래픽 분석에 대한 연결의 저항성을 높이는 반면, HTTP/3은 전송 계층 패딩에 의존하거나 섹션 7.2.8 및 6.2에서 논의한 예약된 프레임 및 스트림 유형을 사용할 수 있습니다. .삼. 이러한 패딩 방법은 패딩의 세분성, 보호되는 정보와 관련하여 패딩이 배열되는 방식, 패킷 손실 시 패딩이 적용되는지 여부, 구현이 패딩을 제어할 수 있는 방법 측면에서 서로 다른 결과를 생성합니다.

예약된 스트림 유형을 사용하면 연결이 유휴 상태일 때에도 트래픽을 보내는 것처럼 보일 수 있습니다. HTTP 트래픽은 종종 버스트에서 발생하기 때문에 명백한 트래픽을 사용하여 이러한 버스트의 타이밍이나 기간을 모호하게 만들 수 있으며 심지어 일정한 데이터 스트림을 보내는 것처럼 보일 수도 있습니다. 그러나 이러한 트래픽은 여전히 ​​수신자에 의해 흐름 제어되므로 이러한 스트림을 즉시 배출하지 못하고 추가 흐름 제어 크레딧을 제공하지 못하면 발신자가 실제 트래픽을 보내는 능력이 제한될 수 있습니다.

압축에 의존하는 공격을 완화하려면 패딩을 사용하는 것보다 압축을 비활성화하거나 제한하는 것이 대책으로 더 나을 수 있습니다.

패딩을 사용하면 즉시 명백해 보이는 것보다 보호 효과가 떨어질 수 있습니다. 중복된 패딩은 역효과를 낳을 수도 있습니다. 기껏해야 패딩은 공격자가 관찰해야 하는 프레임 수를 늘려 공격자가 길이 정보를 유추하는 것을 더 어렵게 만들 뿐입니다. 잘못 구현된 패딩 방식은 쉽게 패배할 수 있습니다. 특히, 예측 가능한 분포를 갖는 무작위 패딩은 보호 기능을 거의 제공하지 않습니다. 마찬가지로 페이로드를 고정 크기로 패딩하면 페이로드 크기가 고정 크기 경계를 넘을 때 정보가 노출됩니다. 이는 공격자가 일반 텍스트를 제어할 수 있는 경우 가능할 수 있습니다.

---
### **10.8.  Frame Parsing**

여러 프로토콜 요소에는 중첩된 길이 요소가 포함되어 있으며 일반적으로 가변 길이 정수를 포함하는 명시적 길이가 있는 프레임 형태입니다. 이는 부주의한 구현자에게 보안 위험을 초래할 수 있습니다. 구현에서는 프레임의 길이가 프레임에 포함된 필드의 길이와 정확히 일치하는지 확인해야 합니다.\(MUST\)

---
### **10.9.  Early Data**

HTTP/3과 함께 0-RTT를 사용하면 재생 공격에 노출될 수 있습니다. 0-RTT와 함께 HTTP/3을 사용할 때 \[HTTP-REPLAY\]의 재생 방지 완화를 적용해야 합니다. HTTP/3에 \[HTTP-REPLAY\]를 적용할 때 TLS 계층에 대한 참조는 QUIC 내에서 수행되는 핸드셰이크를 참조하는 반면, 애플리케이션 데이터에 대한 모든 참조는 스트림의 내용을 참조합니다.\(MUST\)

---
### **10.10.  Migration**

특정 HTTP 구현에서는 로깅 또는 액세스 제어 목적으로 클라이언트 주소를 사용합니다. QUIC 클라이언트의 주소는 연결 중에 변경될 수 있으므로\(향후 버전에서는 여러 주소의 동시 사용을 지원할 수 있음\) 이러한 구현에서는 클라이언트의 현재 주소 또는 관련성이 있는 주소를 적극적으로 검색하거나 원래 주소가 변경될 수 있음을 명시적으로 허용해야 합니다. .

---
### **10.11.  Privacy Considerations**

HTTP/3의 여러 특성은 관찰자에게 시간이 지남에 따라 단일 클라이언트 또는 서버의 작업을 상호 연관시킬 수 있는 기회를 제공합니다. 여기에는 설정 값, 자극에 대한 반응 타이밍, 설정에 의해 제어되는 기능 처리 등이 포함됩니다.

이것이 행동에 있어서 관찰 가능한 차이를 만들어내는 한, 특정 클라이언트를 지문 채취하기 위한 기초로 사용될 수 있습니다.

단일 QUIC 연결 사용에 대한 HTTP/3의 기본 설정을 통해 사이트에서 사용자 활동의 상관 관계를 허용합니다. 다양한 원본에 대한 연결을 재사용하면 해당 원본 전체에서 활동의 상관 관계가 가능해집니다.

QUIC의 여러 기능은 즉각적인 응답을 요청하며 엔드포인트에서 피어에 대한 대기 시간을 측정하는 데 사용할 수 있습니다. 이는 특정 시나리오에서 개인 정보 보호에 영향을 미칠 수 있습니다.

---
## **11.  IANA Considerations**

이 문서는 새로운 ALPN 프로토콜 ID\(섹션 11.1\)를 등록하고 HTTP/3에서 코드 포인트 할당을 관리하는 새로운 레지스트리를 만듭니다.

---
### **11.1.  Registration of HTTP/3 Identification String**

이 문서는 \[RFC7301\]에 확립된 "TLS ALPN\(Application-Layer Protocol Negotiation\) 프로토콜 ID" 레지스트리에서 HTTP/3 식별을 위한 새로운 등록을 생성합니다.

"h3" 문자열은 HTTP/3을 식별합니다.

```text
   Protocol:  HTTP/3

   Identification Sequence:  0x68 0x33 ("h3")
```

사양: 이 문서

---
### **11.2.  New Registries**

이 문서에서 생성된 새로운 레지스트리는 \[QUIC-TRANSPORT\]의 섹션 22.1에 문서화된 QUIC 등록 정책에 따라 작동합니다. 이러한 레지스트리에는 모두 \[QUIC-TRANSPORT\]의 섹션 22.1.1에 나열된 공통 필드 세트가 포함됩니다. 이러한 레지스트리는 "Hypertext Transfer Protocol 버전 ​​3\(HTTP/3\)" 제목 아래에 수집됩니다.

이러한 레지스트리의 초기 할당에는 모두 영구 상태가 할당되고 IETF의 변경 컨트롤러와 HTTP 작업 그룹\(ietf-http-wg@w3.org\)의 연락처가 나열됩니다.

---
#### **11.2.1.  Frame Types**

이 문서는 HTTP/3 프레임 유형 코드에 대한 레지스트리를 설정합니다. "HTTP/3 프레임 유형" 레지스트리는 62비트 공간을 관리합니다. 이 레지스트리는 QUIC 레지스트리 정책을 따릅니다. 섹션 11.2를 참조하세요. 이 레지스트리의 영구 등록은 사양 요구 정책\(\[RFC8126\]\)을 사용하여 할당됩니다. 단, 0x00과 0x3f 사이의 값\(16진수 포함\)은 제외됩니다. 이는 \[의 섹션 4.9 및 4.10에 정의된 대로 표준 조치 또는 IESG 승인을 사용하여 할당됩니다. RFC8126\].

이 레지스트리는 \[HTTP/2\]에 정의된 "HTTP/2 프레임 유형" 레지스트리와 별개이지만 코드 공간이 겹치는 경우 할당이 서로 평행한 것이 바람직합니다. 항목이 하나의 레지스트리에만 존재하는 경우 관련 없는 작업에 해당 값을 할당하지 않도록 모든 노력을 기울여야 합니다. 전문 검토자는 해당 레지스트리의 동일한 값과 충돌할 수 있는 관련 없는 등록을 거부할 수 있습니다.\(SHOULD, MAY\)

섹션 11.2에 설명된 공통 필드 외에도 이 레지스트리의 영구 등록에는 다음 필드가 포함되어야 합니다.\(MUST\)

프레임 유형: 프레임 유형의 이름 또는 레이블입니다.

프레임 유형의 사양에는 조건부로 존재하는 프레임의 모든 부분을 포함하여 프레임 레이아웃 및 의미에 대한 설명이 포함되어야 합니다.\(MUST\)

표 2의 항목은 이 문서에 등록되어 있습니다.

```text
                 +==============+=======+===============+
                 | Frame Type   | Value | Specification |
                 +==============+=======+===============+
                 | DATA         |  0x00 | Section 7.2.1 |
                 +--------------+-------+---------------+
                 | HEADERS      |  0x01 | Section 7.2.2 |
                 +--------------+-------+---------------+
                 | Reserved     |  0x02 | This document |
                 +--------------+-------+---------------+
                 | CANCEL_PUSH  |  0x03 | Section 7.2.3 |
                 +--------------+-------+---------------+
                 | SETTINGS     |  0x04 | Section 7.2.4 |
                 +--------------+-------+---------------+
                 | PUSH_PROMISE |  0x05 | Section 7.2.5 |
                 +--------------+-------+---------------+
                 | Reserved     |  0x06 | This document |
                 +--------------+-------+---------------+
                 | GOAWAY       |  0x07 | Section 7.2.6 |
                 +--------------+-------+---------------+
                 | Reserved     |  0x08 | This document |
                 +--------------+-------+---------------+
                 | Reserved     |  0x09 | This document |
                 +--------------+-------+---------------+
                 | MAX_PUSH_ID  |  0x0d | Section 7.2.7 |
                 +--------------+-------+---------------+

                   Table 2: Initial HTTP/3 Frame Types
```

N의 음수가 아닌 정수 값\(즉, 0x21, 0x40, ..., 0x3ffffffffffffffe까지\)에 대한 0x1f \* N + 0x21 형식의 각 코드는 IANA에 의해 할당되어서는 안 되며 할당된 값 목록에 표시되어서도 안 됩니다.\(MUST NOT\)

---
#### **11.2.2.  Settings Parameters**

이 문서는 HTTP/3 설정에 대한 레지스트리를 설정합니다. "HTTP/3 설정" 레지스트리는 62비트 공간을 관리합니다. 이 레지스트리는 QUIC 레지스트리 정책을 따릅니다. 섹션 11.2를 참조하세요. 이 레지스트리의 영구 등록은 사양 요구 정책\(\[RFC8126\]\)을 사용하여 할당됩니다. 단, 0x00과 0x3f 사이의 값\(16진수 포함\)은 제외됩니다. 이는 \[의 섹션 4.9 및 4.10에 정의된 대로 표준 조치 또는 IESG 승인을 사용하여 할당됩니다. RFC8126\].

이 레지스트리는 \[HTTP/2\]에 정의된 "HTTP/2 설정" 레지스트리와 별개이지만 할당이 서로 평행한 것이 바람직합니다. 항목이 하나의 레지스트리에만 존재하는 경우 관련 없는 작업에 해당 값을 할당하지 않도록 모든 노력을 기울여야 합니다. 전문 검토자는 해당 레지스트리의 동일한 값과 충돌할 수 있는 관련 없는 등록을 거부할 수 있습니다.\(SHOULD, MAY\)

섹션 11.2에 설명된 공통 필드 외에도 이 레지스트리의 영구 등록에는 다음 필드가 포함되어야 합니다.\(MUST\)

설정 이름: 설정에 대한 상징적 이름입니다. 설정 이름 지정은 선택 사항입니다.

기본값: 달리 명시하지 않는 한 설정 값입니다. 기본값은 가능한 가장 제한적인 값이어야 합니다.\(SHOULD\)

표 3의 항목은 이 문서에 등록되어 있습니다.

```text
     +========================+=======+=================+===========+
     | Setting Name           | Value | Specification   | Default   |
     +========================+=======+=================+===========+
     | Reserved               |  0x00 | This document   | N/A       |
     +------------------------+-------+-----------------+-----------+
     | Reserved               |  0x02 | This document   | N/A       |
     +------------------------+-------+-----------------+-----------+
     | Reserved               |  0x03 | This document   | N/A       |
     +------------------------+-------+-----------------+-----------+
     | Reserved               |  0x04 | This document   | N/A       |
     +------------------------+-------+-----------------+-----------+
     | Reserved               |  0x05 | This document   | N/A       |
     +------------------------+-------+-----------------+-----------+
     | MAX_FIELD_SECTION_SIZE |  0x06 | Section 7.2.4.1 | Unlimited |
     +------------------------+-------+-----------------+-----------+

                     Table 3: Initial HTTP/3 Settings
```

형식상의 이유로 'SETTINGS\_' 접두사를 제거하여 설정 이름을 축약할 수 있습니다.

N의 음수가 아닌 정수 값\(즉, 0x21, 0x40, ..., 0x3ffffffffffffffe까지\)에 대한 0x1f \* N + 0x21 형식의 각 코드는 IANA에 의해 할당되어서는 안 되며 할당된 값 목록에 표시되어서도 안 됩니다.\(MUST NOT\)

---
#### **11.2.3.  Error Codes**

이 문서는 HTTP/3 오류 코드에 대한 레지스트리를 설정합니다. "HTTP/3 오류 코드" 레지스트리는 62비트 공간을 관리합니다. 이 레지스트리는 QUIC 레지스트리 정책을 따릅니다. 섹션 11.2를 참조하세요. 이 레지스트리의 영구 등록은 사양 요구 정책\(\[RFC8126\]\)을 사용하여 할당됩니다. 단, 0x00과 0x3f 사이의 값\(16진수 포함\)은 제외됩니다. 이는 \[의 섹션 4.9 및 4.10에 정의된 대로 표준 조치 또는 IESG 승인을 사용하여 할당됩니다. RFC8126\].

오류 코드에 대한 설명을 포함하려면 오류 코드 등록이 필요합니다. 전문 검토자는 신규 등록에 기존 오류 코드와의 중복 가능성이 있는지 조사하는 것이 좋습니다. 기존 등록의 사용은 권장되지만 의무사항은 아닙니다. "HTTP/2 오류 코드" 레지스트리에 등록된 값의 사용은 권장되지 않으며 전문 검토자는 이러한 등록을 거부할 수 있습니다.\(MAY\)

섹션 11.2에 설명된 일반 필드 외에도 이 레지스트리에는 두 개의 추가 필드가 포함되어 있습니다. 이 레지스트리의 영구 등록에는 다음 필드가 포함되어야 합니다.\(MUST\)

이름: 오류 코드의 이름입니다.

설명: 오류 코드 의미에 대한 간략한 설명입니다.

표 4의 항목은 이 문서에 등록되어 있습니다. 이러한 오류 코드는 HTTP/2 오류 코드와의 충돌을 피하기 위해 사양 필수 정책에 따라 작동하는 범위에서 선택되었습니다.

```text
   +===========================+========+==============+===============+
   | Name                      | Value  | Description  | Specification |
   +===========================+========+==============+===============+
   | H3_NO_ERROR               | 0x0100 | No error     | Section 8.1   |
   +---------------------------+--------+--------------+---------------+
   | H3_GENERAL_PROTOCOL_ERROR | 0x0101 | General      | Section 8.1   |
   |                           |        | protocol     |               |
   |                           |        | error        |               |
   +---------------------------+--------+--------------+---------------+
   | H3_INTERNAL_ERROR         | 0x0102 | Internal     | Section 8.1   |
   |                           |        | error        |               |
   +---------------------------+--------+--------------+---------------+
   | H3_STREAM_CREATION_ERROR  | 0x0103 | Stream       | Section 8.1   |
   |                           |        | creation     |               |
   |                           |        | error        |               |
   +---------------------------+--------+--------------+---------------+
   | H3_CLOSED_CRITICAL_STREAM | 0x0104 | Critical     | Section 8.1   |
   |                           |        | stream was   |               |
   |                           |        | closed       |               |
   +---------------------------+--------+--------------+---------------+
   | H3_FRAME_UNEXPECTED       | 0x0105 | Frame not    | Section 8.1   |
   |                           |        | permitted    |               |
   |                           |        | in the       |               |
   |                           |        | current      |               |
   |                           |        | state        |               |
   +---------------------------+--------+--------------+---------------+
   | H3_FRAME_ERROR            | 0x0106 | Frame        | Section 8.1   |
   |                           |        | violated     |               |
   |                           |        | layout or    |               |
   |                           |        | size rules   |               |
   +---------------------------+--------+--------------+---------------+
   | H3_EXCESSIVE_LOAD         | 0x0107 | Peer         | Section 8.1   |
   |                           |        | generating   |               |
   |                           |        | excessive    |               |
   |                           |        | load         |               |
   +---------------------------+--------+--------------+---------------+
   | H3_ID_ERROR               | 0x0108 | An           | Section 8.1   |
   |                           |        | identifier   |               |
   |                           |        | was used     |               |
   |                           |        | incorrectly  |               |
   +---------------------------+--------+--------------+---------------+
   | H3_SETTINGS_ERROR         | 0x0109 | SETTINGS     | Section 8.1   |
   |                           |        | frame        |               |
   |                           |        | contained    |               |
   |                           |        | invalid      |               |
   |                           |        | values       |               |
   +---------------------------+--------+--------------+---------------+
   | H3_MISSING_SETTINGS       | 0x010a | No SETTINGS  | Section 8.1   |
   |                           |        | frame        |               |
   |                           |        | received     |               |
   +---------------------------+--------+--------------+---------------+
   | H3_REQUEST_REJECTED       | 0x010b | Request not  | Section 8.1   |
   |                           |        | processed    |               |
   +---------------------------+--------+--------------+---------------+
   | H3_REQUEST_CANCELLED      | 0x010c | Data no      | Section 8.1   |
   |                           |        | longer       |               |
   |                           |        | needed       |               |
   +---------------------------+--------+--------------+---------------+
   | H3_REQUEST_INCOMPLETE     | 0x010d | Stream       | Section 8.1   |
   |                           |        | terminated   |               |
   |                           |        | early        |               |
   +---------------------------+--------+--------------+---------------+
   | H3_MESSAGE_ERROR          | 0x010e | Malformed    | Section 8.1   |
   |                           |        | message      |               |
   +---------------------------+--------+--------------+---------------+
   | H3_CONNECT_ERROR          | 0x010f | TCP reset    | Section 8.1   |
   |                           |        | or error on  |               |
   |                           |        | CONNECT      |               |
   |                           |        | request      |               |
   +---------------------------+--------+--------------+---------------+
   | H3_VERSION_FALLBACK       | 0x0110 | Retry over   | Section 8.1   |
   |                           |        | HTTP/1.1     |               |
   +---------------------------+--------+--------------+---------------+

                    Table 4: Initial HTTP/3 Error Codes
```

N의 음수가 아닌 정수 값\(즉, 0x21, 0x40, ..., 0x3ffffffffffffffe까지\)에 대한 0x1f \* N + 0x21 형식의 각 코드는 IANA에 의해 할당되어서는 안 되며 할당된 값 목록에 표시되어서도 안 됩니다.\(MUST NOT\)

---
#### **11.2.4.  Stream Types**

이 문서는 HTTP/3 단방향 스트림 유형에 대한 레지스트리를 설정합니다. "HTTP/3 스트림 유형" 레지스트리는 62비트 공간을 관리합니다. 이 레지스트리는 QUIC 레지스트리 정책을 따릅니다. 섹션 11.2를 참조하세요. 이 레지스트리의 영구 등록은 사양 요구 정책\(\[RFC8126\]\)을 사용하여 할당됩니다. 단, 0x00과 0x3f 사이의 값\(16진수 포함\)은 제외됩니다. 이는 \[의 섹션 4.9 및 4.10에 정의된 대로 표준 조치 또는 IESG 승인을 사용하여 할당됩니다. RFC8126\].

섹션 11.2에 설명된 공통 필드 외에도 이 레지스트리의 영구 등록에는 다음 필드가 포함되어야 합니다.\(MUST\)

스트림 유형: 스트림 유형의 이름 또는 레이블입니다.

발신자: HTTP/3 연결의 어느 끝점이 이 유형의 스트림을 시작할 수 있는지입니다. 값은 "클라이언트", "서버" 또는 "둘 다"입니다.

영구 등록에 대한 사양에는 스트림 콘텐츠의 레이아웃 및 의미를 포함한 스트림 유형에 대한 설명이 포함되어야 합니다.\(MUST\)

표 5의 항목은 이 문서에 등록되어 있습니다.

```text
            +================+=======+===============+========+
            | Stream Type    | Value | Specification | Sender |
            +================+=======+===============+========+
            | Control Stream |  0x00 | Section 6.2.1 | Both   |
            +----------------+-------+---------------+--------+
            | Push Stream    |  0x01 | Section 4.6   | Server |
            +----------------+-------+---------------+--------+

                       Table 5: Initial Stream Types
```

N의 음수가 아닌 정수 값\(즉, 0x21, 0x40, ..., 0x3ffffffffffffffe까지\)에 대한 0x1f \* N + 0x21 형식의 각 코드는 IANA에 의해 할당되어서는 안 되며 할당된 값 목록에 표시되어서도 안 됩니다.\(MUST NOT\)

---
## **12.  References**
---
### **12.1.  Normative References**

```text
   [ALTSVC]   Nottingham, M., McManus, P., and J. Reschke, "HTTP
              Alternative Services", RFC 7838, DOI 10.17487/RFC7838,
              April 2016, <https://www.rfc-editor.org/info/rfc7838>.

   [COOKIES]  Barth, A., "HTTP State Management Mechanism", RFC 6265,
              DOI 10.17487/RFC6265, April 2011,
              <https://www.rfc-editor.org/info/rfc6265>.

   [HTTP]     Fielding, R., Ed., Nottingham, M., Ed., and J. Reschke,
              Ed., "HTTP Semantics", STD 97, RFC 9110,
              DOI 10.17487/RFC9110, June 2022,
              <https://www.rfc-editor.org/info/rfc9110>.

   [HTTP-CACHING]
              Fielding, R., Ed., Nottingham, M., Ed., and J. Reschke,
              Ed., "HTTP Caching", STD 98, RFC 9111,
              DOI 10.17487/RFC9111, June 2022,
              <https://www.rfc-editor.org/info/rfc9111>.

   [HTTP-REPLAY]
              Thomson, M., Nottingham, M., and W. Tarreau, "Using Early
              Data in HTTP", RFC 8470, DOI 10.17487/RFC8470, September
              2018, <https://www.rfc-editor.org/info/rfc8470>.

   [QPACK]    Krasic, C., Bishop, M., and A. Frindell, Ed., "QPACK:
              Field Compression for HTTP/3", RFC 9204,
              DOI 10.17487/RFC9204, June 2022,
              <https://www.rfc-editor.org/info/rfc9204>.

   [QUIC-TRANSPORT]
              Iyengar, J., Ed. and M. Thomson, Ed., "QUIC: A UDP-Based
              Multiplexed and Secure Transport", RFC 9000,
              DOI 10.17487/RFC9000, May 2021,
              <https://www.rfc-editor.org/info/rfc9000>.

   [RFC0793]  Postel, J., "Transmission Control Protocol", STD 7,
              RFC 793, DOI 10.17487/RFC0793, September 1981,
              <https://www.rfc-editor.org/info/rfc793>.

   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", BCP 14, RFC 2119,
              DOI 10.17487/RFC2119, March 1997,
              <https://www.rfc-editor.org/info/rfc2119>.

   [RFC6066]  Eastlake 3rd, D., "Transport Layer Security (TLS)
              Extensions: Extension Definitions", RFC 6066,
              DOI 10.17487/RFC6066, January 2011,
              <https://www.rfc-editor.org/info/rfc6066>.

   [RFC7301]  Friedl, S., Popov, A., Langley, A., and E. Stephan,
              "Transport Layer Security (TLS) Application-Layer Protocol
              Negotiation Extension", RFC 7301, DOI 10.17487/RFC7301,
              July 2014, <https://www.rfc-editor.org/info/rfc7301>.

   [RFC8126]  Cotton, M., Leiba, B., and T. Narten, "Guidelines for
              Writing an IANA Considerations Section in RFCs", BCP 26,
              RFC 8126, DOI 10.17487/RFC8126, June 2017,
              <https://www.rfc-editor.org/info/rfc8126>.

   [RFC8174]  Leiba, B., "Ambiguity of Uppercase vs Lowercase in RFC
              2119 Key Words", BCP 14, RFC 8174, DOI 10.17487/RFC8174,
              May 2017, <https://www.rfc-editor.org/info/rfc8174>.

   [URI]      Berners-Lee, T., Fielding, R., and L. Masinter, "Uniform
              Resource Identifier (URI): Generic Syntax", STD 66,
              RFC 3986, DOI 10.17487/RFC3986, January 2005,
              <https://www.rfc-editor.org/info/rfc3986>.
```

---
### **12.2.  Informative References**

```text
   [BREACH]   Gluck, Y., Harris, N., and A. Prado, "BREACH: Reviving the
              CRIME Attack", July 2013,
              <http://breachattack.com/resources/
              BREACH%20-%20SSL,%20gone%20in%2030%20seconds.pdf>.

   [DNS-TERMS]
              Hoffman, P., Sullivan, A., and K. Fujiwara, "DNS
              Terminology", BCP 219, RFC 8499, DOI 10.17487/RFC8499,
              January 2019, <https://www.rfc-editor.org/info/rfc8499>.

   [HPACK]    Peon, R. and H. Ruellan, "HPACK: Header Compression for
              HTTP/2", RFC 7541, DOI 10.17487/RFC7541, May 2015,
              <https://www.rfc-editor.org/info/rfc7541>.

   [HTTP/1.1] Fielding, R., Ed., Nottingham, M., Ed., and J. Reschke,
              Ed., "HTTP/1.1", STD 99, RFC 9112, DOI 10.17487/RFC9112,
              June 2022, <https://www.rfc-editor.org/info/rfc9112>.

   [HTTP/2]   Thomson, M., Ed. and C. Benfield, Ed., "HTTP/2", RFC 9113,
              DOI 10.17487/RFC9113, June 2022,
              <https://www.rfc-editor.org/info/rfc9113>.

   [RFC6585]  Nottingham, M. and R. Fielding, "Additional HTTP Status
              Codes", RFC 6585, DOI 10.17487/RFC6585, April 2012,
              <https://www.rfc-editor.org/info/rfc6585>.

   [RFC8164]  Nottingham, M. and M. Thomson, "Opportunistic Security for
              HTTP/2", RFC 8164, DOI 10.17487/RFC8164, May 2017,
              <https://www.rfc-editor.org/info/rfc8164>.

   [TFO]      Cheng, Y., Chu, J., Radhakrishnan, S., and A. Jain, "TCP
              Fast Open", RFC 7413, DOI 10.17487/RFC7413, December 2014,
              <https://www.rfc-editor.org/info/rfc7413>.

   [TLS]      Rescorla, E., "The Transport Layer Security (TLS) Protocol
              Version 1.3", RFC 8446, DOI 10.17487/RFC8446, August 2018,
              <https://www.rfc-editor.org/info/rfc8446>.
```

---
# **Appendix A.  Considerations for Transitioning from HTTP/2**

HTTP/3은 HTTP/2로부터 많은 정보를 얻었으며 많은 유사점을 가지고 있습니다. 이 섹션에서는 HTTP/3을 설계하는 데 사용되는 접근 방식을 설명하고, HTTP/2와의 중요한 차이점을 지적하고, HTTP/2 확장을 HTTP/3에 매핑하는 방법을 설명합니다.

HTTP/3은 HTTP/2와의 유사성이 바람직하지만 엄격한 요구 사항은 아니라는 전제에서 시작됩니다. HTTP/3은 QUIC 기능\(예: 스트림\)을 활용하거나 중요한 단점\(예: 전체 순서 지정 부족\)을 수용하기 위해 QUIC가 TCP와 다른 HTTP/2에서 출발합니다. HTTP/3은 스트림에 대한 요청 및 응답의 관계와 같은 주요 측면에서 HTTP/2와 유사하지만 HTTP/3 디자인의 세부 사항은 HTTP/2와 크게 다릅니다.

이 섹션에는 몇 가지 중요한 차이점이 언급되어 있습니다.

---
### **A.1.  Streams**

HTTP/3은 HTTP/2보다 더 많은 수의 스트림\(2^62-1\) 사용을 허용합니다. 스트림 식별자 공간 소진에 대한 동일한 고려 사항이 적용됩니다. 하지만 공간이 훨씬 더 크기 때문에 연결 흐름 제어 창의 제한과 같은 QUIC의 다른 제한에 먼저 도달할 가능성이 높습니다.

HTTP/2와 달리 HTTP/3의 스트림 동시성은 QUIC에 의해 관리됩니다. QUIC는 모든 데이터가 수신되고 전송된 데이터가 피어에 의해 확인되면 스트림이 닫힌 것으로 간주합니다. HTTP/2는 END\_STREAM 비트가 포함된 프레임이 전송에 커밋되면 스트림이 닫힌 것으로 간주합니다. 결과적으로 등가 교환을 위한 스트림은 더 오랜 기간 동안 "활성" 상태를 유지할 수 있습니다. HTTP/3 서버는 예상되는 사용 패턴에 따라 HTTP/2와 동등한 동시성을 달성하기 위해 더 많은 수의 동시 클라이언트 시작 양방향 스트림을 허용하도록 선택할 수 있습니다.

HTTP/2에서는 요청 및 응답 본문\(DATA 프레임의 프레임 페이로드\)만 흐름 제어를 받습니다. 모든 HTTP/3 프레임은 QUIC 스트림으로 전송되므로 모든 스트림의 모든 프레임은 HTTP/3에서 흐름이 제어됩니다.

다른 단방향 스트림 유형이 있기 때문에 HTTP/3은 동시 진행 중인 푸시 수를 제어하기 위해 동시 단방향 스트림 수에만 의존하지 않습니다. 대신 HTTP/3 클라이언트는 MAX\_PUSH\_ID 프레임을 사용하여 HTTP/3 서버에서 수신되는 푸시 수를 제어합니다.

---
### **A.2.  HTTP Frame Types**

HTTP/2의 많은 프레이밍 개념은 전송이 이를 다루기 때문에 QUIC에서는 생략될 수 있습니다. 프레임은 이미 스트림에 있으므로 스트림 번호를 생략할 수 있습니다. 프레임은 다중화를 차단하지 않기 때문에\(QUIC의 다중화는 이 계층 아래에서 발생함\) 가변 최대 길이 패킷에 대한 지원이 제거될 수 있습니다. 스트림 종료는 QUIC에 의해 처리되므로 END\_STREAM 플래그가 필요하지 않습니다. 이를 통해 일반 프레임 레이아웃에서 플래그 필드를 제거할 수 있습니다.

프레임 페이로드는 주로 \[HTTP/2\]에서 가져옵니다. 그러나 QUIC에는 HTTP/2에도 있는 많은 기능\(예: 흐름 제어\)이 포함되어 있습니다. 이러한 경우 HTTP 매핑은 이를 다시 구현하지 않습니다. 결과적으로 HTTP/3에서는 여러 HTTP/2 프레임 유형이 필요하지 않습니다. HTTP/2 정의 프레임이 더 이상 사용되지 않는 경우 HTTP/2와 HTTP/3 구현 간의 이식성을 최대화하기 위해 프레임 ID가 예약되었습니다. 그러나 두 매핑에 모두 나타나는 프레임 유형도 동일한 의미를 갖지 않습니다.

많은 차이점은 HTTP/2가 모든 스트림에 걸쳐 프레임 간의 절대 순서를 제공하는 반면 QUIC는 각 스트림에서만 이러한 보장을 제공한다는 사실에서 발생합니다. 결과적으로, 프레임 유형이 다른 스트림의 프레임이 전송된 순서대로 수신될 것이라고 가정하는 경우 HTTP/3는 이를 중단합니다.

기능 적응의 몇 가지 예와 HTTP/2 확장을 HTTP/3으로 변환하는 확장 프레임 구현에 대한 일반적인 지침이 아래에 설명되어 있습니다.

---
#### **A.2.1.  Prioritization Differences**

HTTP/2는 PRIORITY 프레임과 \(선택적으로\) HEADERS 프레임에 우선순위 할당을 지정합니다. HTTP/3은 신호 우선순위 수단을 제공하지 않습니다.

우선순위에 대한 명시적인 신호는 없지만 이것이 좋은 성능을 달성하는 데 우선순위가 중요하지 않다는 의미는 아닙니다.

---
#### **A.2.2.  Field Compression Differences**

HPACK은 순차적 배송을 가정하여 설계되었습니다. 인코딩된 필드 섹션의 시퀀스는 인코딩된 순서와 동일한 순서로 엔드포인트에 도착하고 디코딩되어야 합니다. 이렇게 하면 두 끝점의 동적 상태가 동기화된 상태로 유지됩니다.

이 전체 순서는 QUIC에서 제공되지 않기 때문에 HTTP/3은 QPACK이라는 수정된 HPACK 버전을 사용합니다. QPACK은 단일 단방향 스트림을 사용하여 동적 테이블에 대한 모든 수정을 수행하고 전체 업데이트 순서를 보장합니다. 인코딩된 필드를 포함하는 모든 프레임은 테이블 상태를 수정하지 않고 주어진 시간의 테이블 상태만 참조합니다.

```text
   [QPACK] provides additional details.
```

---
#### **A.2.3.  Flow-Control Differences**

HTTP/2는 스트림 흐름 제어 메커니즘을 지정합니다. 모든 HTTP/2 프레임은 스트림으로 전달되지만 DATA 프레임 페이로드만 흐름 제어를 받습니다. QUIC은 스트림 데이터에 대한 흐름 제어를 제공하며 이 문서에 정의된 모든 HTTP/3 프레임 유형은 스트림으로 전송됩니다. 따라서 모든 프레임 헤더와 페이로드는 흐름 제어를 받습니다.

---
#### **A.2.4.  Guidance for New Frame Type Definitions**

HTTP/3의 프레임 유형 정의는 종종 QUIC 가변 길이 정수 인코딩을 사용합니다. 특히 스트림 ID는 이 인코딩을 사용하므로 HTTP/2에서 사용되는 인코딩보다 더 넓은 범위의 가능한 값을 허용합니다. HTTP/3의 일부 프레임은 스트림 ID\(예: 푸시 ID\)가 아닌 식별자를 사용합니다. 인코딩에 스트림 ID가 포함된 경우 확장 프레임 유형의 인코딩을 재정의해야 할 수도 있습니다.

일반 HTTP/3 프레임에는 플래그 필드가 없기 때문에 플래그 존재에 의존하는 프레임은 프레임 페이로드의 일부로 플래그용 공간을 할당해야 합니다.

이러한 문제 외에도 프레임 유형 HTTP/2 확장은 일반적으로 HTTP/2의 스트림 0을 HTTP/3의 제어 스트림으로 바꾸는 것만으로 QUIC로 이식 가능합니다. HTTP/3 확장은 순서를 가정하지 않지만 순서로 인해 손상되지 않으며 HTTP/2로 이식될 것으로 예상됩니다.

---
#### **A.2.5.  Comparison of HTTP/2 and HTTP/3 Frame Types**

DATA \(0x00\): HTTP/3 프레임에는 패딩이 정의되어 있지 않습니다. 보다

- 섹션 7.2.1.

HEADERS\(0x01\): HEADERS의 PRIORITY 영역은 HTTP/3 프레임에 정의되어 있지 않습니다. HTTP/3 프레임에는 패딩이 정의되어 있지 않습니다. 섹션 7.2.2를 참조하세요.

PRIORITY\(0x02\): 부록 A.2.1에 설명된 대로 HTTP/3은 신호 우선 순위 수단을 제공하지 않습니다.

RST\_STREAM \(0x03\): QUIC가 스트림 수명주기 관리를 제공하므로 RST\_STREAM 프레임은 HTTP/3에 존재하지 않습니다. CANCEL\_PUSH 프레임에도 동일한 코드 포인트가 사용됩니다\(7.2.3절\).

SETTINGS\(0x04\): SETTINGS 프레임은 연결 시작 시에만 전송됩니다. 섹션 7.2.4 및 부록 A.3을 참조하십시오.

PUSH\_PROMISE \(0x05\): PUSH\_PROMISE 프레임은 스트림을 참조하지 않습니다. 대신 푸시 스트림은 푸시 ID를 사용하여 PUSH\_PROMISE 프레임을 참조합니다. 섹션 7.2.5를 참조하세요.

PING\(0x06\): QUIC가 동등한 기능을 제공하므로 PING 프레임은 HTTP/3에 존재하지 않습니다.

GOAWAY\(0x07\): GOAWAY에는 오류 코드가 포함되어 있지 않습니다. 클라이언트-서버 방향에서는 서버가 시작한 스트림 ID 대신 푸시 ID를 전달합니다. 섹션 7.2.6을 참조하십시오.

WINDOW\_UPDATE \(0x08\): QUIC가 흐름 제어를 제공하므로 WINDOW\_UPDATE 프레임은 HTTP/3에 존재하지 않습니다.

CONTINUATION \(0x09\): CONTINUATION 프레임은 HTTP/3에 존재하지 않습니다. 대신 HTTP/2보다 더 큰 HEADERS/PUSH\_PROMISE 프레임이 허용됩니다.

HTTP/2 확장으로 정의된 프레임 유형은 여전히 ​​적용 가능한 경우 HTTP/3에 대해 별도로 등록해야 합니다. \[HTTP/2\]에 정의된 프레임의 ID는 단순화를 위해 예약되었습니다. HTTP/3의 프레임 유형 공간은 상당히 크므로\(62비트 대 8비트\) 많은 HTTP/3 프레임 유형에는 동등한 HTTP/2 코드 포인트가 없습니다. 섹션 11.2.1을 참조하십시오.

---
### **A.3.  HTTP/2 SETTINGS Parameters**

HTTP/2와의 중요한 차이점은 설정이 제어 스트림의 첫 번째 프레임으로 한 번 전송되고 그 이후에는 변경할 수 없다는 것입니다. 이렇게 하면 변경 사항 동기화와 관련된 많은 코너 케이스가 제거됩니다.

HTTP/2가 SETTINGS 프레임을 통해 지정하는 일부 전송 수준 옵션은 HTTP/3의 QUIC 전송 매개변수로 대체됩니다. HTTP/3에 유지되는 HTTP 수준 설정은 HTTP/2와 동일한 값을 갖습니다. 대체된 설정은 예약되어 있으며 수신 오류가 발생했습니다. 보유된 값과 예약된 값에 대한 논의는 섹션 7.2.4.1을 참조하십시오.

다음은 각 HTTP/2 SETTINGS 매개변수가 매핑되는 방법 목록입니다.

```text
   SETTINGS_HEADER_TABLE_SIZE (0x01):  See [QPACK].
```

SETTINGS\_ENABLE\_PUSH\(0x02\): 이는 서버 푸시에 대한 보다 세부적인 제어를 제공하는 MAX\_PUSH\_ID 프레임을 위해 제거되었습니다. HTTP/3 SETTINGS 프레임에서 식별자 0x02\(SETTINGS\_ENABLE\_PUSH 매개변수에 해당\)로 설정을 지정하면 오류가 발생합니다.

SETTINGS\_MAX\_CONCURRENT\_STREAMS \(0x03\): QUIC는 흐름 제어 논리의 일부로 가장 큰 오픈 스트림 ID를 제어합니다. HTTP/3 SETTINGS 프레임에서 식별자 0x03\(SETTINGS\_MAX\_CONCURRENT\_STREAMS 매개변수에 해당\)으로 설정을 지정하면 오류가 발생합니다.

SETTINGS\_INITIAL\_WINDOW\_SIZE \(0x04\): QUIC에서는 초기 전송 핸드셰이크에 스트림 및 연결 흐름 제어 창 크기를 모두 지정해야 합니다. HTTP/3 SETTINGS 프레임에서 식별자 0x04\(SETTINGS\_INITIAL\_WINDOW\_SIZE 매개변수에 해당\)로 설정을 지정하면 오류가 발생합니다.

SETTINGS\_MAX\_FRAME\_SIZE\(0x05\): 이 설정은 HTTP/3에 상응하는 설정이 없습니다. HTTP/3 SETTINGS 프레임에서 식별자 0x05\(SETTINGS\_MAX\_FRAME\_SIZE 매개변수에 해당\)로 설정을 지정하면 오류가 발생합니다.

SETTINGS\_MAX\_HEADER\_LIST\_SIZE\(0x06\): 이 설정 식별자의 이름이 SETTINGS\_MAX\_FIELD\_SECTION\_SIZE로 변경되었습니다.

HTTP/3에서는 설정 값이 HTTP/2의 고정 길이 32비트 필드가 아닌 가변 길이 정수\(6, 14, 30 또는 62비트 길이\)입니다. 이렇게 하면 인코딩이 더 짧아지는 경우가 많지만 전체 32비트 공간을 사용하는 설정의 경우 인코딩이 길어질 수 있습니다. HTTP/2에서 이식된 설정은 보다 효율적인 인코딩을 위해 해당 값을 30비트로 제한하도록 값을 재정의하거나 30비트 이상이 필요한 경우 62비트 공간을 활용하도록 선택할 수 있습니다.

HTTP/2와 HTTP/3에 대해 별도로 설정을 정의해야 합니다. \[HTTP/2\]에 정의된 설정의 ID는 단순화를 위해 예약되었습니다. HTTP/3의 설정 식별자 공간은 훨씬 더 크므로\(62비트 대 16비트\) 많은 HTTP/3 설정에는 동등한 HTTP/2 코드 포인트가 없습니다. 섹션 11.2.2를 참조하십시오.

QUIC 스트림이 순서 없이 도착할 수 있으므로 엔드포인트는 다른 스트림에 응답하기 전에 피어의 설정이 도착할 때까지 기다리지 않는 것이 좋습니다. 섹션 7.2.4.2를 참조하십시오.

---
### **A.4.  HTTP/2 Error Codes**

QUIC에는 HTTP/2가 제공하는 "스트림" 및 "연결" 오류 개념이 동일합니다. 그러나 HTTP/2와 HTTP/3의 차이점은 오류 코드가 버전 간에 직접적으로 이식될 수 없음을 의미합니다.

\[HTTP/2\]의 섹션 7에 정의된 HTTP/2 오류 코드는 다음과 같이 HTTP/3 오류 코드에 논리적으로 매핑됩니다.

NO\_ERROR \(0x00\): 섹션 8.1의 H3\_NO\_ERROR.

PROTOCOL\_ERROR \(0x01\): 보다 구체적인 오류 코드가 정의된 경우를 제외하고는 H3\_GENERAL\_PROTOCOL\_ERROR에 매핑됩니다. 이러한 경우에는 섹션 8.1에 정의된 H3\_FRAME\_UNEXPECTED, H3\_MESSAGE\_ERROR 및 H3\_CLOSED\_CRITICAL\_STREAM이 포함됩니다.

INTERNAL\_ERROR \(0x02\): 섹션 8.1의 H3\_INTERNAL\_ERROR.

FLOW\_CONTROL\_ERROR \(0x03\): QUIC가 흐름 제어를 처리하므로 해당 사항이 없습니다.

SETTINGS\_TIMEOUT\(0x04\): SETTINGS에 대한 승인이 정의되지 않았으므로 해당 사항이 없습니다.

STREAM\_CLOSED \(0x05\): QUIC가 스트림 관리를 처리하므로 해당 사항이 없습니다.

FRAME\_SIZE\_ERROR \(0x06\): 섹션 8.1에 정의된 H3\_FRAME\_ERROR 오류 코드입니다.

REFUSED\_STREAM\(0x07\): H3\_REQUEST\_REJECTED\(섹션 8.1\)는 요청이 처리되지 않았음을 나타내는 데 사용됩니다. 그렇지 않으면 QUIC가 스트림 관리를 처리하므로 적용할 수 없습니다.

CANCEL\(0x08\): 섹션 8.1의 H3\_REQUEST\_CANCELLED입니다.

COMPRESSION\_ERROR \(0x09\): \[QPACK\]에 여러 오류 코드가 정의되어 있습니다.

CONNECT\_ERROR \(0x0a\): 섹션 8.1의 H3\_CONNECT\_ERROR.

ENHANCE\_YOUR\_CALM\(0x0b\): 섹션 8.1의 H3\_EXCESSIVE\_LOAD.

INADEQUATE\_SECURITY \(0x0c\): QUIC는 모든 연결에 대해 충분한 보안을 제공한다고 가정하므로 해당 사항이 없습니다.

HTTP\_1\_1\_REQUIRED\(0x0d\): 섹션 8.1의 H3\_VERSION\_FALLBACK.\(MUST\)

HTTP/2와 HTTP/3에 대해 오류 코드를 별도로 정의해야 합니다. 섹션 11.2.3을 참조하십시오.

---
#### **A.4.1.  Mapping between HTTP/2 and HTTP/3 Errors**

HTTP/2와 HTTP/3 사이를 변환하는 중개자는 업스트림 중 하나에서 오류 조건이 발생할 수 있습니다. 오류 발생을 다운스트림에 알리는 것이 유용하지만 오류 코드는 일반적으로 전파하는 것이 타당하지 않은 연결 로컬 문제를 주로 반영합니다.

업스트림 원본에서 오류가 발생한 중개자는 광범위한 오류 클래스에 적합한 502\(잘못된 게이트웨이\)와 같은 HTTP 상태 코드를 전송하여 이를 나타낼 수 있습니다.

드물게 오류를 수신기에 가장 가깝게 일치하는 오류 유형에 매핑하여 전파하는 것이 유익한 경우가 있습니다. 예를 들어, 원본으로부터 REFUSED\_STREAM 유형의 HTTP/2 스트림 오류를 수신한 중개자는 요청이 처리되지 않았으며 요청을 재시도해도 안전하다는 명확한 신호를 받습니다. 이 오류 조건을 H3\_REQUEST\_REJECTED 유형의 HTTP/3 스트림 오류로 클라이언트에 전파하면 클라이언트가 가장 적절하다고 판단되는 조치를 취할 수 있습니다. 반대 방향으로 중개자는 H3\_REQUEST\_CANCELLED로 스트림을 종료하여 표시된 클라이언트 요청 취소를 전달하는 것이 유익하다고 간주할 수 있습니다. 섹션 4.1.1을 참조하세요.

오류 간 변환은 논리 매핑에 설명되어 있습니다. 오류 코드는 대상 버전에 부적절하거나 알 수 없는 오류 코드를 사용할 수 있는 실수로 변환되는 것을 방지하기 위해 겹치지 않는 공간에 정의됩니다. 중개자는 스트림 오류를 연결 오류로 승격시킬 수 있지만 일시적이거나 간헐적인 오류일 수 있는 경우 HTTP/3 연결에 대한 비용을 인식해야 합니다.

---
# **Acknowledgments**

Robbie Shade와 Mike Warres는 이 문서의 전신인 draft-shade-quic-http2-mapping의 저자였습니다.

IETF QUIC 워킹 그룹은 많은 사람들로부터 엄청난 지원을 받았습니다. 그 중에서도 다음 사람들이 이 문서에 상당한 기여를 했습니다.

```text
   *  Bence Beky
   *  Daan De Meyer
   *  Martin Duke
   *  Roy Fielding
   *  Alan Frindell
   *  Alessandro Ghedini
   *  Nick Harper
   *  Ryan Hamilton
   *  Christian Huitema
   *  Subodh Iyengar
   *  Robin Marx
   *  Patrick McManus
   *  Luca Niccolini
   *  奥 一穂 (Kazuho Oku)
   *  Lucas Pardue
   *  Roberto Peon
   *  Julian Reschke
   *  Eric Rescorla
   *  Martin Seemann
   *  Ben Schwartz
   *  Ian Swett
   *  Willy Taureau
   *  Martin Thomson
   *  Dmitri Tikhonov
   *  Tatsuhiro Tsujikawa
```

Mike Bishop이 Microsoft에 근무하는 동안 기여의 일부는 Microsoft의 지원을 받았습니다.

---
# **Index**

```text
   C D G H M P R S

      C

         CANCEL_PUSH  Section 2, Paragraph 5; Section 4.6, Paragraph 6;
            Section 4.6, Paragraph 10; Table 1; *_Section 7.2.3_*;
            Section 7.2.5, Paragraph 4.2.1; Section 7.2.7, Paragraph 1;
            Table 2; Appendix A.2.5, Paragraph 1.8.1
         connection error  Section 2.2; Section 4.1, Paragraph 7;
            Section 4.1, Paragraph 8; Section 4.4, Paragraph 8;
            Section 4.4, Paragraph 10; Section 4.6, Paragraph 3;
            Section 5.2, Paragraph 7; Section 6.1, Paragraph 3;
            Section 6.2, Paragraph 7; Section 6.2.1, Paragraph 2;
            Section 6.2.1, Paragraph 2; Section 6.2.1, Paragraph 2;
            Section 6.2.2, Paragraph 3; Section 6.2.2, Paragraph 6;
            Section 7.1, Paragraph 5; Section 7.1, Paragraph 6;
            Section 7.2.1, Paragraph 2; Section 7.2.2, Paragraph 3;
            Section 7.2.3, Paragraph 5; Section 7.2.3, Paragraph 7;
            Section 7.2.3, Paragraph 8; Section 7.2.4, Paragraph 2;
            Section 7.2.4, Paragraph 3; Section 7.2.4, Paragraph 6;
            Section 7.2.4.1, Paragraph 5; Section 7.2.4.2, Paragraph 8;
            Section 7.2.4.2, Paragraph 8; Section 7.2.5, Paragraph 5;
            Section 7.2.5, Paragraph 6; Section 7.2.5, Paragraph 8;
            Section 7.2.5, Paragraph 9; Section 7.2.6, Paragraph 3;
            Section 7.2.6, Paragraph 5; Section 7.2.7, Paragraph 2;
            Section 7.2.7, Paragraph 3; Section 7.2.7, Paragraph 6;
            Section 7.2.8, Paragraph 3; *_Section 8_*; Section 10.5,
            Paragraph 7; Appendix A.4.1, Paragraph 4
         control stream  Section 2, Paragraph 3; Section 3.2, Paragraph
            4; Section 6.2, Paragraph 3; Section 6.2, Paragraph 5;
            Section 6.2, Paragraph 6; *_Section 6.2.1_*; Section 7,
            Paragraph 1; Section 7.2.1, Paragraph 2; Section 7.2.2,
            Paragraph 3; Section 7.2.3, Paragraph 5; Section 7.2.3,
            Paragraph 5; Section 7.2.4, Paragraph 2; Section 7.2.4,
            Paragraph 2; Section 7.2.4, Paragraph 3; Section 7.2.5,
            Paragraph 8; Section 7.2.6, Paragraph 3; Section 7.2.6,
            Paragraph 5; Section 7.2.7, Paragraph 2; Section 8.1,
            Paragraph 2.22.1; Section 9, Paragraph 4; Appendix A.2.4,
            Paragraph 3; Appendix A.3, Paragraph 1

      D

         DATA  Section 2, Paragraph 3; Section 4.1, Paragraph 5, Item 2;
            Section 4.1, Paragraph 7; Section 4.1, Paragraph 7;
            Section 4.1.2, Paragraph 3; Section 4.1.2, Paragraph 3;
            Section 4.4, Paragraph 7; Section 4.4, Paragraph 7;
            Section 4.4, Paragraph 7; Section 4.4, Paragraph 7;
            Section 4.4, Paragraph 8; Section 4.6, Paragraph 12;
            Table 1; *_Section 7.2.1_*; Table 2; Appendix A.1, Paragraph
            3; Appendix A.2.3, Paragraph 1; Appendix A.2.5

      G

         GOAWAY  Section 3.3, Paragraph 5; Section 5.2, Paragraph 1;
            Section 5.2, Paragraph 1; Section 5.2, Paragraph 1;
            Section 5.2, Paragraph 2; Section 5.2, Paragraph 2;
            Section 5.2, Paragraph 3; Section 5.2, Paragraph 5.1.1;
            Section 5.2, Paragraph 5.1.1; Section 5.2, Paragraph 5.1.2;
            Section 5.2, Paragraph 5.1.2; Section 5.2, Paragraph 5, Item
            2; Section 5.2, Paragraph 5, Item 2; Section 5.2, Paragraph
            6; Section 5.2, Paragraph 6; Section 5.2, Paragraph 7;
            Section 5.2, Paragraph 7; Section 5.2, Paragraph 8;
            Section 5.2, Paragraph 8; Section 5.2, Paragraph 9;
            Section 5.2, Paragraph 9; Section 5.2, Paragraph 10;
            Section 5.2, Paragraph 12; Section 5.3, Paragraph 2;
            Section 5.3, Paragraph 2; Section 5.4, Paragraph 2; Table 1;
            *_Section 7.2.6_*; Table 2; Appendix A.2.5; Appendix A.2.5,
            Paragraph 1.16.1

      H

         H3_CLOSED_CRITICAL_STREAM  Section 6.2.1, Paragraph 2;
            Section 8.1; Table 4; Appendix A.4, Paragraph 3.4.1
         H3_CONNECT_ERROR  Section 4.4, Paragraph 10; Section 8.1;
            Table 4; Appendix A.4, Paragraph 3.22.1
         H3_EXCESSIVE_LOAD  Section 8.1; Section 10.5, Paragraph 7;
            Table 4; Appendix A.4, Paragraph 3.24.1
         H3_FRAME_ERROR  Section 7.1, Paragraph 5; Section 7.1,
            Paragraph 6; Section 8.1; Table 4; Appendix A.4, Paragraph
            3.14.1
         H3_FRAME_UNEXPECTED  Section 4.1, Paragraph 7; Section 4.1,
            Paragraph 8; Section 4.4, Paragraph 8; Section 7.2.1,
            Paragraph 2; Section 7.2.2, Paragraph 3; Section 7.2.3,
            Paragraph 5; Section 7.2.4, Paragraph 2; Section 7.2.4,
            Paragraph 3; Section 7.2.5, Paragraph 8; Section 7.2.5,
            Paragraph 9; Section 7.2.6, Paragraph 5; Section 7.2.7,
            Paragraph 2; Section 7.2.7, Paragraph 3; Section 7.2.8,
            Paragraph 3; Section 8.1; Table 4; Appendix A.4, Paragraph
            3.4.1
         H3_GENERAL_PROTOCOL_ERROR  Section 7.2.5, Paragraph 6;
            Section 8.1; Table 4; Appendix A.4, Paragraph 3.4.1
         H3_ID_ERROR  Section 4.6, Paragraph 3; Section 5.2, Paragraph
            7; Section 6.2.2, Paragraph 6; Section 7.2.3, Paragraph 7;
            Section 7.2.3, Paragraph 8; Section 7.2.5, Paragraph 5;
            Section 7.2.6, Paragraph 3; Section 7.2.7, Paragraph 6;
            Section 8.1; Table 4
         H3_INTERNAL_ERROR  Section 8.1; Table 4; Appendix A.4,
            Paragraph 3.6.1
         H3_MESSAGE_ERROR  Section 4.1.2, Paragraph 4; Section 8.1;
            Table 4; Appendix A.4, Paragraph 3.4.1
         H3_MISSING_SETTINGS  Section 6.2.1, Paragraph 2; Section 8.1;
            Table 4
         H3_NO_ERROR  Section 4.1, Paragraph 15; Section 5.2, Paragraph
            11; Section 6.2.3, Paragraph 2; Section 8, Paragraph 5;
            Section 8.1; Section 8.1, Paragraph 3; Section 8.1,
            Paragraph 3; Table 4; Appendix A.4, Paragraph 3.2.1
         H3_REQUEST_CANCELLED  Section 4.1.1, Paragraph 4;
            Section 4.1.1, Paragraph 5; Section 4.6, Paragraph 14;
            Section 7.2.3, Paragraph 3; Section 7.2.3, Paragraph 4;
            Section 8.1; Table 4; Appendix A.4, Paragraph 3.18.1;
            Appendix A.4.1, Paragraph 3
         H3_REQUEST_INCOMPLETE  Section 4.1, Paragraph 14; Section 8.1;
            Table 4
         H3_REQUEST_REJECTED  Section 4.1.1, Paragraph 3; Section 4.1.1,
            Paragraph 4; Section 4.1.1, Paragraph 5; Section 4.1.1,
            Paragraph 5; Section 8.1; Table 4; Appendix A.4, Paragraph
            3.16.1; Appendix A.4.1, Paragraph 3
         H3_SETTINGS_ERROR  Section 7.2.4, Paragraph 6; Section 7.2.4.1,
            Paragraph 5; Section 7.2.4.2, Paragraph 8; Section 7.2.4.2,
            Paragraph 8; Section 8.1; Table 4
         H3_STREAM_CREATION_ERROR  Section 6.1, Paragraph 3;
            Section 6.2, Paragraph 7; Section 6.2.1, Paragraph 2;
            Section 6.2.2, Paragraph 3; Section 8.1; Table 4
         H3_VERSION_FALLBACK  Section 8.1; Table 4; Appendix A.4,
            Paragraph 3.28.1
         HEADERS  Section 2, Paragraph 3; Section 4.1, Paragraph 5, Item
            1; Section 4.1, Paragraph 5, Item 3; Section 4.1, Paragraph
            7; Section 4.1, Paragraph 7; Section 4.1, Paragraph 7;
            Section 4.1, Paragraph 10; Section 4.4, Paragraph 6;
            Section 4.6, Paragraph 12; Table 1; *_Section 7.2.2_*;
            Section 9, Paragraph 5; Table 2; Appendix A.2.1, Paragraph
            1; Appendix A.2.5; Appendix A.2.5, Paragraph 1.4.1;
            Appendix A.2.5, Paragraph 1.20.1

      M

         malformed  Section 4.1, Paragraph 3; *_Section 4.1.2_*;
            Section 4.2, Paragraph 2; Section 4.2, Paragraph 3;
            Section 4.2, Paragraph 5; Section 4.3, Paragraph 3;
            Section 4.3, Paragraph 4; Section 4.3.1, Paragraph 5;
            Section 4.3.2, Paragraph 1; Section 4.4, Paragraph 5;
            Section 8.1, Paragraph 2.30.1; Section 10.3, Paragraph 1;
            Section 10.3, Paragraph 2; Section 10.5.1, Paragraph 2
         MAX_PUSH_ID  Section 2, Paragraph 5; Section 4.6, Paragraph 3;
            Section 4.6, Paragraph 3; Section 4.6, Paragraph 3;
            Section 4.6, Paragraph 3; Table 1; Section 7.2.5, Paragraph
            5; *_Section 7.2.7_*; Table 2; Appendix A.1, Paragraph 4;
            Appendix A.3, Paragraph 4.4.1

      P

         push ID  *_Section 4.6_*; Section 5.2, Paragraph 1;
            Section 5.2, Paragraph 5, Item 2; Section 5.2, Paragraph 9;
            Section 6.2.2, Paragraph 2; Section 6.2.2, Paragraph 6;
            Section 6.2.2, Paragraph 6; Section 7.2.3, Paragraph 1;
            Section 7.2.3, Paragraph 7; Section 7.2.3, Paragraph 7;
            Section 7.2.3, Paragraph 8; Section 7.2.3, Paragraph 8;
            Section 7.2.5, Paragraph 4.2.1; Section 7.2.5, Paragraph 5;
            Section 7.2.5, Paragraph 5; Section 7.2.5, Paragraph 6;
            Section 7.2.5, Paragraph 6; Section 7.2.5, Paragraph 7;
            Section 7.2.5, Paragraph 7; Section 7.2.5, Paragraph 7;
            Section 7.2.6, Paragraph 4; Section 7.2.7, Paragraph 1;
            Section 7.2.7, Paragraph 4; Section 7.2.7, Paragraph 4;
            Section 7.2.7, Paragraph 6; Section 7.2.7, Paragraph 6;
            Section 8.1, Paragraph 2.18.1; Appendix A.2.5, Paragraph
            1.12.1; Appendix A.2.5, Paragraph 1.16.1
         push stream  Section 4.1, Paragraph 8; Section 4.1, Paragraph
            9; Section 4.6, Paragraph 3; Section 4.6, Paragraph 5;
            Section 4.6, Paragraph 5; Section 4.6, Paragraph 13;
            Section 4.6, Paragraph 13; Section 4.6, Paragraph 13;
            Section 6.2, Paragraph 3; *_Section 6.2.2_*; Section 7,
            Paragraph 1; Section 7.2.2, Paragraph 3; Section 7.2.3,
            Paragraph 1; Section 7.2.3, Paragraph 2; Section 7.2.3,
            Paragraph 2; Section 7.2.3, Paragraph 2; Section 7.2.3,
            Paragraph 2; Section 7.2.3, Paragraph 3; Section 7.2.3,
            Paragraph 4; Section 7.2.3, Paragraph 4; Section 7.2.3,
            Paragraph 4; Section 7.2.5, Paragraph 4.2.1; Section 7.2.7,
            Paragraph 1; Appendix A.2.5, Paragraph 1.12.1
         PUSH_PROMISE  Section 2, Paragraph 5; Section 4.1, Paragraph 8;
            Section 4.1, Paragraph 8; Section 4.1, Paragraph 8;
            Section 4.1, Paragraph 8; Section 4.1, Paragraph 10;
            Section 4.6, Paragraph 4; Section 4.6, Paragraph 10;
            Section 4.6, Paragraph 11; Section 4.6, Paragraph 11;
            Section 4.6, Paragraph 12; Section 4.6, Paragraph 12;
            Section 4.6, Paragraph 13; Section 4.6, Paragraph 13;
            Section 4.6, Paragraph 13; Table 1; Section 7.2.3, Paragraph
            8; Section 7.2.3, Paragraph 8; *_Section 7.2.5_*;
            Section 7.2.7, Paragraph 1; Section 10.4, Paragraph 1;
            Section 10.5, Paragraph 2; Table 2; Appendix A.2.5;
            Appendix A.2.5, Paragraph 1.12.1; Appendix A.2.5, Paragraph
            1.12.1; Appendix A.2.5, Paragraph 1.20.1

      R

         request stream  Section 4.1, Paragraph 1; Section 4.1,
            Paragraph 15; Section 4.1, Paragraph 15; Section 4.1.1,
            Paragraph 1; Section 4.1.1, Paragraph 5; Section 4.4,
            Paragraph 5; Section 4.4, Paragraph 9; Section 4.6,
            Paragraph 4; Section 4.6, Paragraph 4; Section 4.6,
            Paragraph 11; Section 4.6, Paragraph 11; *_Section 6.1_*;
            Section 7, Paragraph 1; Section 7.2.2, Paragraph 3;
            Section 7.2.5, Paragraph 1

      S

         SETTINGS  Section 3.2, Paragraph 4; Section 3.2, Paragraph 4;
            Section 6.2.1, Paragraph 2; Table 1; Section 7, Paragraph 3;
            *_Section 7.2.4_*; Section 8.1, Paragraph 2.20.1;
            Section 8.1, Paragraph 2.22.1; Section 9, Paragraph 4;
            Section 10.5, Paragraph 4; Table 2; Table 4; Table 4;
            Appendix A.2.5; Appendix A.2.5, Paragraph 1.10.1;
            Appendix A.3, Paragraph 2; Appendix A.3, Paragraph 3;
            Appendix A.3, Paragraph 4.4.1; Appendix A.3, Paragraph
            4.6.1; Appendix A.3, Paragraph 4.8.1; Appendix A.3,
            Paragraph 4.10.1; Appendix A.4, Paragraph 3.10.1
         SETTINGS_MAX_FIELD_SECTION_SIZE  Section 4.2.2, Paragraph 2;
            Section 7.2.4.1; Section 10.5.1, Paragraph 2; Appendix A.3,
            Paragraph 4.12.1
         stream error  Section 2.2; Section 4.1.2, Paragraph 4;
            Section 4.4, Paragraph 10; *_Section 8_*; Appendix A.4.1,
            Paragraph 3; Appendix A.4.1, Paragraph 3; Appendix A.4.1,
            Paragraph 4
```

---
# **Author's Address**

```text
   Mike Bishop (editor)
   Akamai
   Email: mbishop@evequefou.be
```
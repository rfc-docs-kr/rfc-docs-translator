

```text
Network Working Group                                         J. Klensin
Request for Comments: 5321                                  October 2008
Obsoletes: 2821
Updates: 1123
Category: Standards Track

                     Simple Mail Transfer Protocol
```

---
# **Status of This Memo**

이 문서는 인터넷 커뮤니티를 위한 인터넷 표준 추적 프로토콜을 지정하고 개선을 위한 토론 및 제안을 요청합니다. 이 프로토콜의 표준화 상태 및 상태에 대해서는 "Internet Official Protocol Standards"\(STD 1\) 최신판을 참조하십시오. 이 메모의 배포는 무제한입니다.

---
# **Abstract**

이 문서는 인터넷 전자메일 전송을 위한 기본 프로토콜의 사양이다. 여러 이전 문서를 통합, 업데이트 및 명확하게 하여 대부분의 문서 전체 또는 일부를 쓸모 없게 만듭니다. 이는 현대 인터넷에 대한 SMTP 확장 메커니즘과 모범 사례를 다루지만 특정 확장에 대한 세부 정보는 제공하지 않습니다. SMTP는 메일 전송 및 전달 프로토콜로 설계되었지만 이 사양에는 "분할-UA"\(사용자 에이전트\) 메일 읽기 시스템 및 모바일 환경에 대한 "메일 제출" 프로토콜로 사용하는 데 중요한 정보도 포함되어 있습니다.

---
# **Table of Contents**

```text
   1.  Introduction . . . . . . . . . . . . . . . . . . . . . . . . .  5
     1.1.  Transport of Electronic Mail . . . . . . . . . . . . . . .  5
     1.2.  History and Context for This Document  . . . . . . . . . .  5
     1.3.  Document Conventions . . . . . . . . . . . . . . . . . . .  6
   2.  The SMTP Model . . . . . . . . . . . . . . . . . . . . . . . .  7
     2.1.  Basic Structure  . . . . . . . . . . . . . . . . . . . . .  7
     2.2.  The Extension Model  . . . . . . . . . . . . . . . . . . .  9
       2.2.1.  Background . . . . . . . . . . . . . . . . . . . . . .  9
       2.2.2.  Definition and Registration of Extensions  . . . . . . 10
       2.2.3.  Special Issues with Extensions . . . . . . . . . . . . 11
     2.3.  SMTP Terminology . . . . . . . . . . . . . . . . . . . . . 11
       2.3.1.  Mail Objects . . . . . . . . . . . . . . . . . . . . . 11
       2.3.2.  Senders and Receivers  . . . . . . . . . . . . . . . . 12
       2.3.3.  Mail Agents and Message Stores . . . . . . . . . . . . 12
       2.3.4.  Host . . . . . . . . . . . . . . . . . . . . . . . . . 13
       2.3.5.  Domain Names . . . . . . . . . . . . . . . . . . . . . 13
       2.3.6.  Buffer and State Table . . . . . . . . . . . . . . . . 14
       2.3.7.  Commands and Replies . . . . . . . . . . . . . . . . . 14
       2.3.8.  Lines  . . . . . . . . . . . . . . . . . . . . . . . . 14
       2.3.9.  Message Content and Mail Data  . . . . . . . . . . . . 15
       2.3.10. Originator, Delivery, Relay, and Gateway Systems . . . 15
       2.3.11. Mailbox and Address  . . . . . . . . . . . . . . . . . 15
     2.4.  General Syntax Principles and Transaction Model  . . . . . 16
   3.  The SMTP Procedures: An Overview . . . . . . . . . . . . . . . 17
     3.1.  Session Initiation . . . . . . . . . . . . . . . . . . . . 18
     3.2.  Client Initiation  . . . . . . . . . . . . . . . . . . . . 18
     3.3.  Mail Transactions  . . . . . . . . . . . . . . . . . . . . 19
     3.4.  Forwarding for Address Correction or Updating  . . . . . . 21
     3.5.  Commands for Debugging Addresses . . . . . . . . . . . . . 22
       3.5.1.  Overview . . . . . . . . . . . . . . . . . . . . . . . 22
       3.5.2.  VRFY Normal Response . . . . . . . . . . . . . . . . . 24
       3.5.3.  Meaning of VRFY or EXPN Success Response . . . . . . . 25
       3.5.4.  Semantics and Applications of EXPN . . . . . . . . . . 26
     3.6.  Relaying and Mail Routing  . . . . . . . . . . . . . . . . 26
       3.6.1.  Source Routes and Relaying . . . . . . . . . . . . . . 26
       3.6.2.  Mail eXchange Records and Relaying . . . . . . . . . . 26
       3.6.3.  Message Submission Servers as Relays . . . . . . . . . 27
     3.7.  Mail Gatewaying  . . . . . . . . . . . . . . . . . . . . . 28
       3.7.1.  Header Fields in Gatewaying  . . . . . . . . . . . . . 28
       3.7.2.  Received Lines in Gatewaying . . . . . . . . . . . . . 29
       3.7.3.  Addresses in Gatewaying  . . . . . . . . . . . . . . . 29
       3.7.4.  Other Header Fields in Gatewaying  . . . . . . . . . . 29
       3.7.5.  Envelopes in Gatewaying  . . . . . . . . . . . . . . . 30
     3.8.  Terminating Sessions and Connections . . . . . . . . . . . 30
     3.9.  Mailing Lists and Aliases  . . . . . . . . . . . . . . . . 31
       3.9.1.  Alias  . . . . . . . . . . . . . . . . . . . . . . . . 31
       3.9.2.  List . . . . . . . . . . . . . . . . . . . . . . . . . 31
   4.  The SMTP Specifications  . . . . . . . . . . . . . . . . . . . 32
     4.1.  SMTP Commands  . . . . . . . . . . . . . . . . . . . . . . 32
       4.1.1.  Command Semantics and Syntax . . . . . . . . . . . . . 32
       4.1.2.  Command Argument Syntax  . . . . . . . . . . . . . . . 41
       4.1.3.  Address Literals . . . . . . . . . . . . . . . . . . . 43
       4.1.4.  Order of Commands  . . . . . . . . . . . . . . . . . . 44
       4.1.5.  Private-Use Commands . . . . . . . . . . . . . . . . . 46
     4.2.  SMTP Replies . . . . . . . . . . . . . . . . . . . . . . . 46
       4.2.1.  Reply Code Severities and Theory . . . . . . . . . . . 48
       4.2.2.  Reply Codes by Function Groups . . . . . . . . . . . . 50
       4.2.3.  Reply Codes in Numeric Order . . . . . . . . . . . . . 52
       4.2.4.  Reply Code 502 . . . . . . . . . . . . . . . . . . . . 53
       4.2.5.  Reply Codes after DATA and the Subsequent
               <CRLF>.<CRLF>  . . . . . . . . . . . . . . . . . . . . 53
     4.3.  Sequencing of Commands and Replies . . . . . . . . . . . . 54
       4.3.1.  Sequencing Overview  . . . . . . . . . . . . . . . . . 54
       4.3.2.  Command-Reply Sequences  . . . . . . . . . . . . . . . 55
     4.4.  Trace Information  . . . . . . . . . . . . . . . . . . . . 57
     4.5.  Additional Implementation Issues . . . . . . . . . . . . . 61
       4.5.1.  Minimum Implementation . . . . . . . . . . . . . . . . 61
       4.5.2.  Transparency . . . . . . . . . . . . . . . . . . . . . 62
       4.5.3.  Sizes and Timeouts . . . . . . . . . . . . . . . . . . 62
         4.5.3.1.  Size Limits and Minimums . . . . . . . . . . . . . 62
           4.5.3.1.1.  Local-part . . . . . . . . . . . . . . . . . . 63
           4.5.3.1.2.  Domain . . . . . . . . . . . . . . . . . . . . 63
           4.5.3.1.3.  Path . . . . . . . . . . . . . . . . . . . . . 63
           4.5.3.1.4.  Command Line . . . . . . . . . . . . . . . . . 63
           4.5.3.1.5.  Reply Line . . . . . . . . . . . . . . . . . . 63
           4.5.3.1.6.  Text Line  . . . . . . . . . . . . . . . . . . 63
           4.5.3.1.7.  Message Content  . . . . . . . . . . . . . . . 63
           4.5.3.1.8.  Recipients Buffer  . . . . . . . . . . . . . . 64
           4.5.3.1.9.  Treatment When Limits Exceeded . . . . . . . . 64
           4.5.3.1.10. Too Many Recipients Code . . . . . . . . . . . 64
         4.5.3.2.  Timeouts . . . . . . . . . . . . . . . . . . . . . 65
           4.5.3.2.1.  Initial 220 Message: 5 Minutes . . . . . . . . 65
           4.5.3.2.2.  MAIL Command: 5 Minutes  . . . . . . . . . . . 65
           4.5.3.2.3.  RCPT Command: 5 Minutes  . . . . . . . . . . . 65
           4.5.3.2.4.  DATA Initiation: 2 Minutes . . . . . . . . . . 66
           4.5.3.2.5.  Data Block: 3 Minutes  . . . . . . . . . . . . 66
           4.5.3.2.6.  DATA Termination: 10 Minutes.  . . . . . . . . 66
           4.5.3.2.7.  Server Timeout: 5 Minutes. . . . . . . . . . . 66
       4.5.4.  Retry Strategies . . . . . . . . . . . . . . . . . . . 66
       4.5.5.  Messages with a Null Reverse-Path  . . . . . . . . . . 68
   5.  Address Resolution and Mail Handling . . . . . . . . . . . . . 69
     5.1.  Locating the Target Host . . . . . . . . . . . . . . . . . 69
     5.2.  IPv6 and MX Records  . . . . . . . . . . . . . . . . . . . 71
   6.  Problem Detection and Handling . . . . . . . . . . . . . . . . 71
     6.1.  Reliable Delivery and Replies by Email . . . . . . . . . . 71
     6.2.  Unwanted, Unsolicited, and "Attack" Messages . . . . . . . 72
     6.3.  Loop Detection . . . . . . . . . . . . . . . . . . . . . . 73
     6.4.  Compensating for Irregularities  . . . . . . . . . . . . . 73
   7.  Security Considerations  . . . . . . . . . . . . . . . . . . . 75
     7.1.  Mail Security and Spoofing . . . . . . . . . . . . . . . . 75
     7.2.  "Blind" Copies . . . . . . . . . . . . . . . . . . . . . . 76
     7.3.  VRFY, EXPN, and Security . . . . . . . . . . . . . . . . . 76
     7.4.  Mail Rerouting Based on the 251 and 551 Response Codes . . 77
     7.5.  Information Disclosure in Announcements  . . . . . . . . . 77
     7.6.  Information Disclosure in Trace Fields . . . . . . . . . . 78
     7.7.  Information Disclosure in Message Forwarding . . . . . . . 78
     7.8.  Resistance to Attacks  . . . . . . . . . . . . . . . . . . 78
     7.9.  Scope of Operation of SMTP Servers . . . . . . . . . . . . 78
   8.  IANA Considerations  . . . . . . . . . . . . . . . . . . . . . 79
   9.  Acknowledgments  . . . . . . . . . . . . . . . . . . . . . . . 80
   10. References . . . . . . . . . . . . . . . . . . . . . . . . . . 81
     10.1. Normative References . . . . . . . . . . . . . . . . . . . 81
     10.2. Informative References . . . . . . . . . . . . . . . . . . 82
   Appendix A.  TCP Transport Service . . . . . . . . . . . . . . . . 85
   Appendix B.  Generating SMTP Commands from RFC 822 Header
                Fields  . . . . . . . . . . . . . . . . . . . . . . . 85
   Appendix C.  Source Routes . . . . . . . . . . . . . . . . . . . . 86
   Appendix D.  Scenarios . . . . . . . . . . . . . . . . . . . . . . 87
     D.1.  A Typical SMTP Transaction Scenario  . . . . . . . . . . . 88
     D.2.  Aborted SMTP Transaction Scenario  . . . . . . . . . . . . 89
     D.3.  Relayed Mail Scenario  . . . . . . . . . . . . . . . . . . 90
     D.4.  Verifying and Sending Scenario . . . . . . . . . . . . . . 92
   Appendix E.  Other Gateway Issues  . . . . . . . . . . . . . . . . 92
   Appendix F.  Deprecated Features of RFC 821  . . . . . . . . . . . 93
     F.1.  TURN . . . . . . . . . . . . . . . . . . . . . . . . . . . 93
     F.2.  Source Routing . . . . . . . . . . . . . . . . . . . . . . 93
     F.3.  HELO . . . . . . . . . . . . . . . . . . . . . . . . . . . 93
     F.4.  #-literals . . . . . . . . . . . . . . . . . . . . . . . . 94
     F.5.  Dates and Years  . . . . . . . . . . . . . . . . . . . . . 94
     F.6.  Sending versus Mailing . . . . . . . . . . . . . . . . . . 94
```

---
## **1.  Introduction**
---
### **1.1.  Transport of Electronic Mail**

SMTP\(Simple Mail Transfer Protocol\)의 목적은 메일을 안정적이고 효율적으로 전송하는 것입니다.

SMTP는 특정 전송 하위 시스템과 독립적이며 안정적으로 정렬된 데이터 스트림 채널만 필요합니다. 이 문서에서는 TCP를 통한 전송에 대해 구체적으로 설명하지만 다른 전송도 가능합니다. RFC 821 \[1\]의 부록에서는 그 중 일부를 설명합니다.

SMTP의 중요한 기능은 일반적으로 "SMTP 메일 릴레이"라고 하는 여러 네트워크를 통해 메일을 전송하는 기능입니다\(섹션 3.6 참조\). 네트워크는 공용 인터넷의 상호 TCP 액세스 가능 호스트, 방화벽 격리 TCP/IP 인트라넷의 상호 TCP 액세스 가능 호스트, 비TCP 전송 수준을 활용하는 다른 LAN 또는 WAN 환경의 호스트로 구성됩니다. 규약. SMTP를 사용하면 프로세스는 두 네트워크 모두에 액세스할 수 있는 릴레이 또는 게이트웨이 프로세스를 통해 동일한 네트워크의 다른 프로세스나 다른 네트워크로 메일을 전송할 수 있습니다.

이러한 방식으로 메일 메시지는 보낸 사람에서 최종 받는 사람까지의 경로에 있는 여러 중간 릴레이 또는 게이트웨이 호스트를 통과할 수 있습니다. 도메인 이름 시스템의 Mail eXchanger 메커니즘\(RFC 1035 \[2\], RFC 974 \[12\] 및 이 문서의 섹션 5\)은 전송되는 메시지에 대한 적절한 다음 홉 대상을 식별하는 데 사용됩니다.

---
### **1.2.  History and Context for This Document**

이 문서는 인터넷 전자메일 전송을 위한 기본 프로토콜의 사양이다. 다음 항목을 통합하고, 업데이트하고, 명확하게 설명하지만 새 기능을 추가하거나 기존 기능을 변경하지는 않습니다.

```text
   o  the original SMTP (Simple Mail Transfer Protocol) specification of
      RFC 821 [1],

   o  domain name system requirements and implications for mail
      transport from RFC 1035 [2] and RFC 974 [12],
```

o RFC 1123 \[3\]의 설명 및 적용 가능성 설명, 그리고

o RFC 1869\[13\]의 SMTP 확장 메커니즘에서 가져온 자료입니다.

o 해당 사양을 초안 표준으로 가져오기 위해 RFC 2821 \[14\]에 대한 편집 및 설명 변경.

RFC 821, RFC 974, RFC 1869 및 RFC 2821을 더 이상 사용하지 않으며 RFC 1123을 업데이트합니다\(RFC 1123의 메일 전송 자료 대체\). 그러나 RFC 821은 1990년대 중반까지 인터넷에서 크게 사용되지 않았던 일부 기능과 \(부록에서\) 일부 추가 전송 모델을 지정합니다. 여기서는 명확성과 간결성을 위해 해당 섹션을 생략했습니다. 필요한 독자는 RFC 821을 참조해야 합니다.

또한 증폭이 필요한 RFC 1123의 일부 추가 자료도 포함되어 있습니다. 이 자료는 주로 다양한 목록과 뉴스 그룹의 공격을 추적하고 SMTP 확장이 배포되면서 나타나는 비정상적인 판독 또는 해석 문제를 추적하여 여러 방법으로 식별되었습니다. 이 사양이 통합을 넘어 실제로 이전 문서와 다른 경우 기술적으로나 텍스트적으로 해당 사양을 대체합니다.

SMTP는 메일 전송 및 전달 프로토콜로 설계되었지만 이 사양에는 POP\(Post Office Protocol\)\(RFC 937 \[15\], RFC 1939 \[ 16\]\) 및 IMAP\(RFC 3501 \[17\]\). 일반적으로 RFC 4409 \[18\]에 지정된 별도의 메일 제출 프로토콜은 이제 SMTP를 직접 사용하는 것보다 선호됩니다. 해당 주제에 대한 자세한 내용은 해당 문서에 나와 있습니다.

섹션 2.3에서는 이 문서와 관련된 용어에 대한 정의를 제공합니다. 명확성을 위해 과거 용어가 필요한 경우를 제외하고 이 문서에서는 현재 '클라이언트' 및 '서버' 용어를 사용하여 각각 송신 및 수신 SMTP 프로세스를 식별합니다.

관련 문서인 RFC 5322\[4\]에서는 메시지 헤더 섹션과 본문을 논의하고 이에 대한 형식과 구조를 지정합니다.

---
### **1.3.  Document Conventions**

이 문서의 핵심 단어 "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY" 및 "OPTIONAL"은 다음과 같습니다. RFC 2119 \[5\]에 설명된 대로 해석됩니다. 이러한 각 용어는 이메일의 상호 운용성을 향상시키기 위해 의도적이고 신중하게 선택되었으므로 이러한 용어의 각 사용은 적합성 요구 사항으로 간주됩니다.\(MUST NOT\)

이 문서는 오랜 역사를 갖고 있으며 다양한 오류의 위험과 이 문서를 가리키는 독자와 문서의 혼란을 피하기 위해 대부분의 예제와 여기에 포함된 도메인 이름은 RFC 2821에서 보존됩니다.

코드나 구성 파일에서 실제로 사용해서는 안 되는 예시입니다.

---
## **2.  The SMTP Model**
---
### **2.1.  Basic Structure**

SMTP 디자인은 다음과 같이 묘사될 수 있습니다.

```text
                  +----------+                +----------+
      +------+    |          |                |          |
      | User |<-->|          |      SMTP      |          |
      +------+    |  Client- |Commands/Replies| Server-  |
      +------+    |   SMTP   |<-------------->|    SMTP  |    +------+
      | File |<-->|          |    and Mail    |          |<-->| File |
      |System|    |          |                |          |    |System|
      +------+    +----------+                +----------+    +------+
                   SMTP client                SMTP server
```

SMTP 클라이언트에 전송할 메시지가 있으면 SMTP 서버에 대한 양방향 전송 채널을 설정합니다. SMTP 클라이언트의 책임은 메일 메시지를 하나 이상의 SMTP 서버로 전송하거나 실패를 보고하는 것입니다.

메일 메시지가 SMTP 클라이언트에 표시되는 방법과 해당 클라이언트가 메일 메시지가 전송될 도메인의 식별자\("이름"\)를 결정하는 방법은 지역적인 문제입니다. 이 문서에서는 다루지 않습니다. 어떤 경우에는 지정된 도메인이나 SMTP 클라이언트에 의해 결정된 도메인이 메일 메시지의 최종 목적지를 식별합니다. 다른 경우에는 POP\(RFC 937 \[15\], RFC 1939 \[16\]\) 또는 IMAP\(RFC 3501 \[17\]\) 프로토콜 구현과 관련된 SMTP 클라이언트에서 일반적이거나 SMTP 클라이언트가 격리된 전송 서비스 환경 내에 있는 경우에 발생합니다. , 결정된 도메인은 모든 메일 메시지가 중계되는 중간 대상을 식별합니다. 개별 메시지와 연결된 대상 도메인에 관계없이 모든 트래픽을 전송하거나 처음에 완료할 수 없는 메시지 전송을 재시도하기 위한 대기열을 유지하지 않는 SMTP 클라이언트는 이 사양을 준수할 수 있지만 완전한 기능을 갖춘 것으로 간주되지 않습니다. 능력이 떨어지는 릴레이와 대상이 사용하는 릴레이를 포함하여 완전한 능력을 갖춘 SMTP 구현은 이 사양에서 논의된 모든 대기열, 재시도 및 대체 주소 기능을 지원할 것으로 예상됩니다. 많은 상황과 구성에서 위에 논의된 성능이 떨어지는 클라이언트는 SMTP가 아닌 메시지 제출 프로토콜\(RFC 4409 \[18\]\)을 사용해야 합니다.\(SHOULD\)

SMTP 클라이언트가 대상 도메인을 결정한 후 메시지 복사본이 전송될 SMTP 서버의 ID를 결정한 다음 해당 전송을 수행하는 방법은 이 문서에서 다룹니다. SMTP 서버로 메일을 전송하기 위해 SMTP 클라이언트는 해당 SMTP 서버에 대한 양방향 전송 채널을 설정합니다. SMTP 클라이언트는 대상 도메인 이름을 중간 Mail eXchanger 호스트 또는 최종 대상 호스트로 확인하여 SMTP 서버를 실행하는 적절한 호스트의 주소를 결정합니다.

SMTP 서버는 최종 목적지이거나 중간 "릴레이"\(즉, 메시지를 받은 후 SMTP 클라이언트의 역할을 맡을 수 있음\) 또는 "게이트웨이"\(즉, 일부 프로토콜을 사용하여 메시지를 추가로 전송할 수 있음\)일 수 있습니다. SMTP 이외\). SMTP 명령은 SMTP 클라이언트에 의해 생성되어 SMTP 서버로 전송됩니다. 명령에 대한 응답으로 SMTP 응답이 SMTP 서버에서 SMTP 클라이언트로 전송됩니다.

즉, 메시지 전송은 원래 SMTP 발신자와 최종 SMTP 수신자 간의 단일 연결에서 발생할 수도 있고 중간 시스템을 통한 일련의 홉에서 발생할 수도 있습니다. 두 경우 모두 서버가 메일 데이터 끝에서 성공 응답을 발행하면 메시지에 대한 공식적인 책임 전달이 발생합니다. 프로토콜은 서버가 메시지를 전달하거나 실패를 적절하게 보고하는 책임을 수락해야 함을 요구합니다. 그렇게 하십시오\(아래 섹션 6.1, 6.2, 7.8 참조\).\(MUST\)

전송 채널이 설정되고 초기 핸드쉐이킹이 완료되면 SMTP 클라이언트는 일반적으로 메일 트랜잭션을 시작합니다. 이러한 트랜잭션은 메일의 발신자와 대상을 지정하고 메시지 내용\(헤더 섹션 또는 기타 구조의 모든 행 포함\) 자체를 전송하는 일련의 명령으로 구성됩니다. 동일한 메시지가 여러 수신자에게 전송되는 경우 이 프로토콜은 동일한 대상\(또는 중간 릴레이\) 호스트의 모든 수신자에 대해 하나의 데이터 복사본만 전송하도록 권장합니다.

서버는 각 명령에 응답으로 응답합니다. 응답은 명령이 승인되었는지, 추가 명령이 예상되는지 또는 일시적 또는 영구적 오류 조건이 존재하는지 나타낼 수 있습니다. 보낸 사람이나 받는 사람을 지정하는 명령에는 섹션 2.2에서 설명한 대로 서버에서 허용하는 SMTP 서비스 확장 요청이 포함될 수 있습니다. 대화 상자는 의도적으로 한 번에 하나씩 잠금 단계로 이루어지지만 명령 파이프라인\(RFC 2920 \[19\]\)과 같은 확장 요청에 따라 상호 동의하여 수정할 수 있습니다.

특정 메일 메시지가 전송되면 클라이언트는 연결을 종료하도록 요청하거나 다른 메일을 시작할 수 있습니다.

업무. 또한 SMTP 클라이언트는 이메일 주소 확인이나 메일링 리스트 가입자 주소 검색과 같은 보조 서비스를 위해 SMTP 서버에 대한 연결을 사용할 수 있습니다.

위에서 제안한 대로 이 프로토콜은 메일 전송을 위한 메커니즘을 제공합니다. 역사적으로 이러한 전송은 일반적으로 두 호스트가 동일한 전송 서비스에 연결된 경우 보내는 사용자의 호스트에서 받는 사용자의 호스트로 직접 발생했습니다. 동일한 전송 서비스에 연결되지 않은 경우 하나 이상의 릴레이 SMTP 서버를 통해 전송이 이루어집니다. 오늘날 인터넷에서 매우 일반적인 경우는 원본 메시지를 중간 "메시지 제출" 서버에 제출하는 것과 관련됩니다. 이 서버는 릴레이와 유사하지만 몇 가지 추가 속성이 있습니다. 그러한 서버는 섹션 2.3.10과 RFC 4409 \[18\]에서 어느 정도 논의됩니다. SMTP 릴레이 또는 다른 전송 환경에 대한 게이트웨이 역할을 하는 중간 호스트는 일반적으로 DNS\(도메인 이름 서비스\) Mail eXchanger 메커니즘을 사용하여 선택됩니다.

일반적으로 중간 호스트는 명시적인 "소스" 라우팅이 아닌 DNS MX 레코드를 통해 결정됩니다\(섹션 5, 부록 C 및 부록 F.2 참조\).

---
### **2.2.  The Extension Model**
---
#### **2.2.1.  Background**

RFC 821이 완성된 지 약 10년 후인 1990년에 시작된 노력의 일환으로 프로토콜은 클라이언트와 서버가 원래 SMTP 요구 사항 이상으로 공유 기능을 활용하는 데 동의할 수 있도록 허용하는 "서비스 확장" 모델로 수정되었습니다. SMTP 확장 메커니즘은 확장된 SMTP 클라이언트와 서버가 서로를 인식하고 서버가 지원하는 서비스 확장에 대해 클라이언트에 알릴 수 있는 수단을 정의합니다.

최신 SMTP 구현은 기본 확장 메커니즘을 지원해야 합니다. 예를 들어 서버는 특정 확장을 구현하지 않더라도 EHLO 명령을 지원해야 하며 클라이언트는 HELO보다는 EHLO를 우선적으로 활용해야 합니다. \(그러나 이전 규격 구현과의 호환성을 위해 SMTP 클라이언트 및 서버는 원래 HELO 메커니즘을 폴백으로 지원해야 합니다.\) 상호 운용성을 위해 HELO의 다른 특성을 식별해야 하지 않는 한 이 문서에서는 EHLO만 설명합니다.\(MUST, MUST, MUST\)

SMTP는 널리 배포되어 있으며 고품질 구현이 매우 강력한 것으로 입증되었습니다. 그러나 이제 인터넷 커뮤니티는 프로토콜이 처음 설계되었을 때 예상하지 못했던 일부 서비스를 중요한 것으로 간주합니다. 해당 서비스에 대한 지원이 필요한 경우

또한 이전 구현이 계속해서 적절하게 작동할 수 있도록 허용하는 방식으로 수행되어야 합니다. 확장 프레임워크는 다음으로 구성됩니다.

o 이전 HELO를 대체하는 SMTP 명령 EHLO

o SMTP 서비스 확장의 레지스트리,

o SMTP MAIL 및 RCPT 명령에 대한 추가 매개변수

o 비ASCII 전송의 DATA와 같이 이 프로토콜에 정의된 명령에 대한 선택적 대체\(RFC 3030 \[20\]\).

SMTP의 강점은 주로 단순성에서 비롯됩니다. 많은 프로토콜에 대한 경험에 따르면 옵션이 거의 없는 프로토콜은 편재성 경향이 있는 반면, 옵션이 많은 프로토콜은 모호해지는 경향이 있습니다.

모든 확장은 그 이점에 관계없이 구현, 배포 및 상호 운용성 비용을 면밀히 조사해야 합니다. 대부분의 경우 SMTP 서비스 확장 비용이 이점보다 클 수 있습니다.

---
#### **2.2.2.  Definition and Registration of Extensions**

IANA는 SMTP 서비스 확장 레지스트리를 유지 관리합니다. 해당 EHLO 키워드 값은 각 확장과 연결됩니다. IANA에 등록된 각 서비스 확장은 공식 표준 트랙 또는 IESG 승인 실험 프로토콜 문서에 정의되어야 합니다. 정의에는 다음이 포함되어야 합니다.

```text
   o  the textual name of the SMTP service extension;

   o  the EHLO keyword value associated with the extension;

   o  the syntax and possible values of parameters associated with the
      EHLO keyword value;

   o  any additional SMTP verbs associated with the extension
      (additional verbs will usually be, but are not required to be, the
      same as the EHLO keyword value);

   o  any new parameters the extension associates with the MAIL or RCPT
      verbs;
```

o 확장에 대한 지원이 서버 및 클라이언트 SMTP의 동작에 어떤 영향을 미치는지에 대한 설명. 그리고

o 확장이 이 표준에 명시된 것 이상으로 MAIL 및/또는 RCPT 명령의 최대 길이를 늘리는 증분.

또한 대문자 또는 소문자 "X"로 시작하는 EHLO 키워드 값은 양자 합의를 통해서만 사용되는 로컬 SMTP 서비스 확장을 나타냅니다. "X"로 시작하는 키워드는 등록된 서비스 확장에 사용되어서는 안 됩니다. 반대로, "X"로 시작하지 않는 EHLO 응답에 제시된 키워드 값은 IANA에 등록된 표준, 표준 트랙 또는 IESG 승인 실험적 SMTP 서비스 확장과 일치해야 합니다. 적합한 서버는 등록된 확장에 설명되지 않은 "X" 접두사가 아닌 키워드 값을 제공해서는 안 됩니다.\(MUST NOT, MUST, MUST NOT\)

추가 동사와 매개변수 이름은 EHLO 키워드와 동일한 규칙에 따라 바인딩됩니다. 특히 "X"로 시작하는 동사는 등록되거나 표준화되지 않을 수 있는 로컬 확장입니다. 반대로 "X"로 시작하지 않는 동사는 항상 등록해야 합니다.

---
#### **2.2.3.  Special Issues with Extensions**

SMTP 작업의 기본적인 속성을 변경하는 확장은 허용됩니다. 이 문서의 다른 섹션에 있는 텍스트는 해당 맥락에서 이해되어야 합니다. 특히 확장은 섹션 4.5.3에 지정된 최소 제한을 변경하거나 위에서 언급한 ASCII 문자 집합 요구 사항을 변경하거나 메시지 처리의 일부 선택적 모드를 도입할 수 있습니다.

특히, 확장이 전달 경로가 일반적으로 해당 확장의 특수 기능을 지원한다는 것을 암시하고 중간 SMTP 시스템이 필요한 확장을 지원하지 않는 다음 홉을 찾은 경우 특정 확장 및 상황에 따라 다시 대기열을 선택할 수 있습니다. 메시지를 확인하고 나중에 시도하거나 대체 MX 호스트를 사용해 보십시오. 이 전략을 사용하는 경우 확장되지 않은 형식\(사용 가능한 경우\)으로 폴백하는 시간 초과는 전달할 수 없는 것으로 반송되는 일반적인 시간 초과보다 작아야 합니다\(예: 일반 시간 초과가 3일인 경우 메시지 전송을 시도하기 전의 재큐 시간 초과\). 연장 없이 메일을 보내면 하루가 걸릴 수 있습니다\).\(MAY, SHOULD\)

---
### **2.3.  SMTP Terminology**
---
#### **2.3.1.  Mail Objects**

SMTP는 메일 개체를 전송합니다. 메일 개체에는 봉투와 내용이 포함되어 있습니다.

SMTP 봉투는 일련의 SMTP 프로토콜 단위로 전송됩니다\(섹션 3에 설명되어 있음\). 발신자 주소로 구성됩니다.

어떤 오류 보고서를 보내야 하는지\), 하나 이상의 수신자 주소, 선택적 프로토콜 확장 자료 등이 있습니다. 역사적으로 역방향 경로\(발생자\) 주소 지정 명령\(MAIL\)의 변형을 사용하여 즉시 표시와 같은 대체 전달 모드를 지정할 수 있었습니다. 이러한 변형은 이제 더 이상 사용되지 않습니다\(부록 F 및 부록 F.6 참조\).

SMTP 콘텐츠는 SMTP DATA 프로토콜 단위로 전송되며 헤더 섹션과 본문의 두 부분으로 구성됩니다. 콘텐츠가 다른 현대 표준을 준수하는 경우 헤더 섹션은 메시지 형식 사양\(RFC 5322 \[4\]\)에 따라 구조화된 헤더 이름, 콜론 및 데이터로 구성된 헤더 필드 모음으로 구성됩니다. 구조화된 본문은 MIME\(RFC 2045 \[21\]\)에 따라 정의됩니다. 내용은 본질적으로 텍스트이며 US-ASCII 레퍼토리\[6\]를 사용하여 표현됩니다. SMTP 확장\(예: "8BITMIME", RFC 1652 \[22\]\)은 콘텐츠 본문에 대한 이러한 제한을 완화할 수 있지만 콘텐츠 헤더 필드는 항상 US-ASCII 레퍼토리를 사용하여 인코딩됩니다. 두 가지 MIME 확장\(RFC 2047 \[23\] 및 RFC 2231 \[24\]\)은 US-ASCII 레퍼토리를 사용하여 인코딩하는 동시에 US-ASCII 레퍼토리 외부의 헤더 값을 나타내는 알고리즘을 정의합니다.

---
#### **2.3.2.  Senders and Receivers**

RFC 821에서는 SMTP 트랜잭션에 참여하는 두 호스트를 "SMTP 발신자"와 "SMTP 수신자"로 설명했습니다. 이 문서는 현재 업계 용어를 반영하도록 변경되었으므로 각각 "SMTP 클라이언트"\(또는 때로는 "클라이언트"\) 및 "SMTP 서버"\(또는 "서버"\)라고 합니다. 특정 호스트가 릴레이 상황에서 서버와 클라이언트 역할을 모두 수행할 수 있으므로 명확성을 위해 필요한 경우 "수신자" 및 "발신자"라는 용어가 여전히 사용됩니다.

---
#### **2.3.3.  Mail Agents and Message Stores**

추가 메일 시스템 용어는 RFC 821이 발표된 이후 일반화되었으며 편리한 경우 이 사양에서 사용됩니다. 특히, SMTP 서버와 클라이언트는 메일 전송 서비스를 제공하므로 "MTA\(메일 전송 에이전트\)" 역할을 합니다. "메일 사용자 에이전트"\(MUA 또는 UA\)는 일반적으로 메일의 소스 및 대상으로 간주됩니다. 소스에서 MUA는 사용자로부터 전송될 메일을 수집하여 MTA에 전달할 수 있습니다. 최종\("배달"\) MTA는 메일을 MUA에 전달하는 것으로 간주됩니다\(또는 적어도 "메시지 저장소"에 메시지를 저장하여 MUA에 책임을 이전하는 것\). 그러나 이러한 용어는 다른 환경에서는 매우 정밀하게 사용되지만 MUA와 MTA 사이의 묵시적인 경계는 일반적이고 준수하는 관행과 정확하게 일치하지 않는 경우가 많습니다.

인터넷 메일. 따라서 독자는 이러한 용어가 다른 곳에서 사용될 경우 암시될 수 있는 강력한 관계와 책임을 추론하는 데 주의해야 합니다.

---
#### **2.3.4.  Host**

이 사양의 목적에 따라 호스트는 인터넷\(또는 경우에 따라 개인 TCP/IP 네트워크\)에 연결되고 SMTP 프로토콜을 지원하는 컴퓨터 시스템입니다. 호스트는 이름으로 알려져 있습니다\(다음 섹션 참조\). 이는 숫자 주소, 즉 섹션 4.1.2에 설명된 주소 리터럴로 식별되어서는 안 됩니다.\(SHOULD NOT\)

---
#### **2.3.5.  Domain Names**

도메인 이름\(또는 흔히 "도메인"\)은 하나 이상의 구성 요소로 구성되며, 둘 이상이 나타날 경우 점으로 구분됩니다. 이메일 주소에서 단독으로 사용되는 최상위 도메인의 경우 점 없이 단일 문자열을 사용합니다. 이로 인해 아래에 자세히 설명된 것처럼 공용 인터넷의 SMTP 트랜잭션에는 정규화된 도메인 이름만 표시되어야 한다는 요구 사항이 있으며, 특히 최상위 도메인이 관련된 경우 중요합니다. 이러한 구성 요소\(DNS 용어의 "레이블", RFC 1035 \[2\]\)는 SMTP 목적으로 ASCII 문자 집합에서 가져온 일련의 문자, 숫자 및 하이픈으로 구성되도록 제한됩니다\[6\]. 도메인 이름은 도메인 이름 계층 구조에서 호스트 및 기타 엔터티의 이름으로 사용됩니다. 예를 들어, 도메인은 호스트 이름을 나타내는 대신 메일을 전달하는 데 사용되는 별칭\(CNAME RR의 레이블\) 또는 Mail eXchanger 레코드의 레이블을 참조할 수 있습니다. RFC 1035 \[2\] 및 이 사양의 섹션 5를 참조하세요.

이 문서와 RFC 1035 \[2\]에 설명된 대로 도메인 이름은 완전한 정규화된 이름\(종종 "FQDN"이라고도 함\)입니다. FQDN 형식이 아닌 도메인 이름은 로컬 별칭에 지나지 않습니다. 로컬 별칭은 SMTP 트랜잭션에 표시되어서는 안 됩니다.\(MUST NOT\)

도메인 이름이 SMTP에서 사용되는 경우 확인 가능한 FQDN\(정규화된 도메인 이름\)만 허용됩니다. 즉, MX RR 또는 주소\(예: A 또는 AAAA\) RR\(섹션 5에서 설명\)로 확인될 수 있는 이름이 허용되며, 대상이 MX 또는 주소 RR로 확인될 수 있는 CNAME RR도 허용됩니다. . 지역 별명이나 자격이 없는 이름은 사용하면 안 됩니다. FQDN을 요구하는 규칙에는 두 가지 예외가 있습니다.\(MUST NOT\)

o EHLO 명령에 제공된 도메인 이름은 기본 호스트 이름\(주소 RR로 확인되는 도메인 이름\)이거나 호스트에 이름이 없는 경우 섹션 4.1.3에 설명되고 추가로 논의되는 주소 리터럴이어야 합니다. 섹션 4.1.4의 EHLO 논의에서.\(MUST\)

o 예약된 사서함 이름 "postmaster"는 도메인 자격 없이 RCPT 명령에 사용될 수 있으며\(섹션 4.1.1.3 참조\) 그렇게 사용되는 경우 반드시 허용되어야 합니다.\(MUST\)

---
#### **2.3.6.  Buffer and State Table**

SMTP 세션은 상태를 저장하므로 양 당사자가 현재 상태에 대한 공통된 보기를 주의 깊게 유지 관리합니다. 이 문서에서는 클라이언트가 예를 들어 "버퍼 지우기" 또는 "상태 테이블 재설정"을 위해 사용할 수 있는 서버의 가상 "버퍼"와 "상태 테이블"을 통해 이 상태를 모델링합니다. 버퍼에 있는 정보는 버려지고 상태는 이전 상태로 되돌아갑니다.

---
#### **2.3.7.  Commands and Replies**

SMTP 명령과 서비스 확장에 의해 변경되지 않는 한 메시지 데이터는 "라인"의 전송 채널을 통해 발신자에서 수신자로 전송됩니다.

SMTP 응답은 명령에 대한 응답으로 전송 채널을 통해 수신자에서 발신자에게 "라인"으로 전송되는 승인\(긍정적 또는 부정\)입니다. 일반적인 응답 형식은 숫자로 된 완료 코드\(실패 또는 성공을 나타냄\)와 일반적으로 텍스트 문자열이 뒤따르는 것입니다. 코드는 프로그램에서 사용하기 위한 것이며 텍스트는 일반적으로 인간 사용자를 위한 것입니다. RFC 3463 \[25\]은 보충적이고 보다 구체적인 완료 코드의 사용을 포함하여 응답 문자열의 추가 구조를 지정합니다\(RFC 5248 \[26\] 참조\).

---
#### **2.3.8.  Lines**

라인은 ASCII 문자 "CR"\(16진수 값 0D\) 바로 뒤에 ASCII 문자 "LF"\(16진수 값 0A\) 시퀀스로 끝나는 0개 이상의 데이터 문자로 구성됩니다. 이 종료 시퀀스는 이 문서에서 <CRLF\>로 표시됩니다. 준수 구현은 줄 종결자로 다른 문자나 문자 시퀀스를 인식하거나 생성해서는 안 됩니다. 서버별로 회선 길이에 제한이 적용될 수 있습니다\(섹션 4 참조\).\(MUST NOT, MAY\)

또한 텍스트에 "기본" "CR" 또는 "LF" 문자가 나타나는 경우\(즉, 다른 문자 없이\) 메일 시스템을 도구로 사용하는 메일 구현 및 응용 프로그램에서 문제를 일으킨 오랜 역사를 가지고 있습니다. SMTP 클라이언트 구현은 라인 종결자로 의도된 경우를 제외하고 이러한 문자를 전송해서는 안 되며, 위에 표시된 대로 해당 문자를 <CRLF\> 시퀀스로만 전송해야 합니다.\(MUST NOT\)

---
#### **2.3.9.  Message Content and Mail Data**

"메시지 내용"과 "메일 데이터"라는 용어는 DATA 명령이 승인된 후 및 데이터 표시의 끝이 전송되기 전에 전송되는 자료를 설명하기 위해 이 문서에서 같은 의미로 사용됩니다. 메시지 콘텐츠에는 메시지 헤더 섹션과 구조화된 메시지 본문이 포함됩니다. MIME 사양\(RFC 2045\[21\]\)은 구조화된 메시지 본문에 대한 표준 메커니즘을 제공합니다.

---
#### **2.3.10.  Originator, Delivery, Relay, and Gateway Systems**

이 사양에서는 전자 메일 전송 시 해당 시스템이 수행하는 역할을 기준으로 네 가지 유형의 SMTP 시스템을 구분합니다. "발신" 시스템\(때때로 SMTP 발신자라고도 함\)은 메일을 인터넷 또는 보다 일반적으로 전송 서비스 환경에 도입합니다. "배달" SMTP 시스템은 전송 서비스 환경에서 메일을 수신하여 메일 사용자 에이전트에 전달하거나 메일 사용자 에이전트가 이후에 액세스할 것으로 예상되는 메시지 저장소에 보관하는 시스템입니다. "릴레이" SMTP 시스템\(일반적으로 "릴레이"라고 함\)은 SMTP 클라이언트로부터 메일을 수신하고 추적 정보를 추가하는 것 외에 메시지 데이터를 수정하지 않고 이를 추가 릴레이 또는 전달을 위해 다른 SMTP 서버로 전송합니다.

"게이트웨이" SMTP 시스템\(일반적으로 "게이트웨이"라고 함\)은 한 전송 환경의 클라이언트 시스템으로부터 메일을 수신하고 이를 다른 전송 환경의 서버 시스템으로 전송합니다. 게이트웨이 양쪽의 전송 환경 간의 프로토콜 또는 메시지 의미 체계의 차이로 인해 게이트웨이 시스템이 SMTP 릴레이 시스템에 허용되지 않는 메시지에 대한 변환을 수행해야 할 수도 있습니다. 이 사양의 목적에 따라 주소를 다시 쓰는 방화벽은 양쪽에서 SMTP가 사용되더라도 게이트웨이로 간주되어야 합니다\(RFC 2979 \[27\] 참조\).

---
#### **2.3.11.  Mailbox and Address**

본 명세서에서 사용되는 "주소"는 메일이 전송될 사용자 또는 메일이 보관될 위치를 식별하는 문자열이다. "우편함"이라는 용어는 해당 보관소를 나타냅니다. 메일이 보관되는 위치\(우편함\)와 이에 대한 참조\(주소\) 사이의 구별이 중요하지 않은 한 두 용어는 일반적으로 같은 의미로 사용됩니다. 주소는 일반적으로 사용자 및 도메인 사양으로 구성됩니다. 표준 사서함 명명 규칙은 "local-part@domain"으로 정의됩니다. 현대의 사용법은 단순한 "사용자 이름"보다 훨씬 더 광범위한 응용 프로그램 집합을 허용합니다. 결과적으로, 중간 호스트가 시도할 때 문제가 발생한 오랜 역사로 인해

이를 수정하여 전송을 최적화하려면 로컬 부분은 주소의 도메인 부분에 지정된 호스트에 의해서만 해석되고 의미 체계가 할당되어야 합니다.\(MUST\)

---
### **2.4.  General Syntax Principles and Transaction Model**

SMTP 명령과 응답에는 엄격한 구문이 있습니다. 모든 명령은 명령 동사로 시작됩니다. 모든 응답은 세 자리 숫자 코드로 시작됩니다. 일부 명령 및 응답에서는 동사 또는 응답 코드 뒤에 인수가 필요합니다. 일부 명령은 인수\(동사 뒤\)를 허용하지 않으며 일부 응답 코드 뒤에는 선택적으로 자유 형식 텍스트가 오는 경우도 있습니다. 두 경우 모두 텍스트가 나타나는 경우 공백 문자로 동사 또는 응답 코드와 구분됩니다. 명령과 응답의 완전한 정의는 섹션 4에 나와 있습니다.

동사 및 인수 값\(예: RCPT 명령 및 확장 이름 키워드의 "TO:" 또는 "to:"\)은 사서함 로컬 부분 사양의 유일한 예외를 제외하고 대소문자를 구분하지 않습니다\(SMTP 확장은 대소문자를 명시적으로 지정할 수 있음\). -민감한 요소\). 즉, 명령 동사, 사서함 로컬 부분 이외의 인수 값 및 자유 형식 텍스트는 의미에 영향을 주지 않고 대문자, 소문자 또는 대문자와 소문자의 혼합으로 인코딩될 수 있습니다. 사서함의 로컬 부분은 대소문자를 구분해야 합니다. 따라서 SMTP 구현은 메일박스 로컬 부분의 대소문자를 보존하도록 주의를 기울여야 합니다. 특히 일부 호스트의 경우 사용자 "smith"는 사용자 "Smith"와 다릅니다. 그러나 사서함 로컬 부분의 대소문자 구분을 활용하는 것은 상호 운용성을 방해하므로 권장되지 않습니다. 사서함 도메인은 일반 DNS 규칙을 따르므로 대소문자를 구분하지 않습니다.\(MAY, MUST, MUST\)

이 사양\(및 RFC 821\)을 위반하는 일부 SMTP 서버에서는 클라이언트가 명령 동사를 대문자로 인코딩해야 합니다. 구현에서는 해당 서버를 수용하기 위해 이 인코딩을 사용할 수 있습니다.\(MAY\)

인수 절은 행의 끝으로 끝나는 가변 길이 문자열, 즉 <CRLF\> 문자 시퀀스로 구성됩니다. 수신자는 이 시퀀스를 수신할 때까지 아무런 조치도 취하지 않습니다.

각 명령의 구문은 해당 명령에 대한 설명과 함께 표시됩니다. 공통 요소와 매개변수는 섹션 4.1.2에 나와 있습니다.

명령과 응답은 ASCII 문자 집합\[6\]의 문자로 구성됩니다. 전송 서비스가 8비트 바이트\(옥텟\) 전송 채널을 제공하는 경우 각 7비트 문자는 상위 비트가 0으로 지워진 옥텟에서 오른쪽 정렬되어 전송됩니다. 보다 구체적으로, 확장되지 않은 SMTP 서비스는 7비트를 제공합니다.

운송만 가능합니다. 특정 서버와 적절한 확장을 성공적으로 협상하지 못한 발신 SMTP 클라이언트\(다음 단락 참조\)는 옥텟의 상위 비트에 있는 정보가 포함된 메시지를 전송해서는 안 됩니다. 이러한 메시지가 이 규칙을 위반하여 전송되는 경우 수신 SMTP 서버는 상위 비트를 지우거나 메시지를 유효하지 않은 것으로 거부할 수 있습니다. 일반적으로 중계 SMTP는 수신한 메시지 내용이 유효하다고 가정해야 하며, 봉투가 이를 허용한다고 가정하면 해당 내용을 검사하지 않고 이를 중계해야 합니다. 물론 콘텐츠에 잘못 레이블이 지정되어 데이터 경로가 실제 콘텐츠를 받아들일 수 없는 경우 심각하게 왜곡된 메시지가 수신자에게 전달될 수 있습니다. 배달 SMTP 시스템은 이러한 메시지를 배달하는 대신 거부하거나 배달할 수 없는 것으로 반환할 수 있습니다. 서버 제공 확장이 명시적으로 허용하지 않는 경우 보내는 SMTP 시스템은 US-ASCII 이외의 문자 집합으로 봉투 명령을 보내는 것이 허용되지 않습니다. 수신 시스템은 일반적으로 "500 구문 오류 - 잘못된 문자" 응답을 사용하여 이러한 명령을 거부해야 합니다.\(MUST NOT, MAY, SHOULD, MAY, SHOULD\)

8비트 메시지 콘텐츠 전송은 클라이언트가 확장된 SMTP 기능, 특히 "8BITMIME" 확장인 RFC 1652\[22\]를 사용하여 서버에 요청할 수 있습니다. 8BITMIME은 SMTP 서버에서 지원되어야 합니다. 그러나 이는 제한되지 않은 8비트 자료를 전송하는 권한으로 해석되어서는 안 되며, 8BITMIME은 ASCII 이외의 봉투 자료의 전송을 승인하지 않습니다. 8BITMIME은 적절한 콘텐츠 전송 인코딩을 사용하는 MIME 형식이 아닌 높은 비트가 있는 자료에 대해 발신자가 요청해서는 안 됩니다. 서버는 그러한 메시지를 거부할 수 있습니다.\(MAY, SHOULD, MUST NOT, MUST NOT\)

본 문서에 사용된 메타언어 표기법은 다른 인터넷 메일 시스템 문서에서 사용되는 "Augmented BNF"에 해당합니다. 해당 구문에 익숙하지 않은 독자는 RFC 5234 \[7\]의 ABNF 사양을 참조해야 합니다. 텍스트 실행에 사용되는 메타언어 용어는 명확성을 위해 뾰족한 괄호\(예: <CRLF\>\)로 묶입니다. 독자는 메타언어로 표현된 문법이 포괄적이지 않다는 점에 주의해야 합니다. 텍스트의 조항이 문법이 암시하는 구문이나 의미를 제한하거나 수정하는 경우가 많이 있습니다.

---
## **3.  The SMTP Procedures: An Overview**

이 섹션에는 세션 시작, 메일 트랜잭션, 메일 전달, 사서함 이름 확인, 메일링 목록 확장, 교환 열기 및 닫기 등 SMTP에서 사용되는 절차에 대한 설명이 포함되어 있습니다. 릴레이에 대한 설명, 메일 도메인에 대한 참고 사항 및 역할 변경에 대한 논의가 이 섹션의 끝에 포함되어 있습니다. 몇 가지 완전한 시나리오가 부록 D에 나와 있습니다.

---
### **3.1.  Session Initiation**

클라이언트가 서버에 대한 연결을 열고 서버가 시작 메시지로 응답하면 SMTP 세션이 시작됩니다.

SMTP 서버 구현에는 220 코드 뒤의 연결 인사말 응답에 소프트웨어 및 버전 정보 식별이 포함될 수 있습니다. 이는 문제를 보다 효율적으로 격리하고 복구할 수 있는 방식입니다. 구현 시 보안 문제가 발생할 경우 소프트웨어 및 버전 발표를 비활성화하기 위해 SMTP 서버를 제공할 수 있습니다. 일부 시스템에서는 메일 문제에 대한 연락처도 식별하지만 이것이 필수 "우편 담당자" 주소 유지를 대체할 수는 없습니다\(섹션 4 참조\).\(MAY, MAY\)

SMTP 프로토콜을 사용하면 서버는 다음과 같이 초기 연결을 허용하면서 메일 세션을 공식적으로 거부할 수 있습니다. 초기 연결 열기 메시지에 220 대신 554 응답이 제공될 수 있습니다. 이 접근 방식을 사용하는 서버는 클라이언트가 다음을 수행할 때까지 기다려야 합니다. 연결을 닫기 전에 QUIT\(섹션 4.1.1.10 참조\)를 보내고 중간에 있는 모든 명령에 "503 잘못된 명령 시퀀스"로 응답해야 합니다. 이러한 시스템에 대한 SMTP 연결 시도는 오류가 있을 수 있으므로 연결 시작 시 554 응답을 반환하는 서버는 전송 시스템의 디버깅을 용이하게 하기 위해 응답 텍스트에 충분한 정보를 제공해야 합니다.\(MAY, MUST, SHOULD\)

---
### **3.2.  Client Initiation**

서버가 인사말\(환영\) 메시지를 보내고 클라이언트가 이를 수신하면 일반적으로 클라이언트는 클라이언트의 신원을 나타내는 EHLO 명령을 서버에 보냅니다. 세션을 여는 것 외에도 EHLO를 사용하면 클라이언트가 서비스 확장을 처리할 수 있고 서버가 지원하는 확장 목록을 제공하도록 요청할 수 있음을 나타냅니다. 서비스 확장을 지원할 수 없는 이전 SMTP 시스템과 시작되는 메일 세션에서 서비스 확장이 필요하지 않은 최신 클라이언트는 EHLO 대신 HELO를 사용할 수 있습니다. 서버는 HELO 명령에 대한 확장된 EHLO 스타일 응답을 반환해서는 안 됩니다. 특정 연결 시도의 경우 서버가 EHLO에 "명령이 인식되지 않음" 응답을 반환하면 클라이언트는 대체하여 HELO를 보낼 수 있어야 합니다.\(MAY, MUST NOT, SHOULD\)

EHLO 명령에서 명령을 보내는 호스트는 자신을 식별합니다. 이 명령은 "안녕하세요, 저는 <도메인\>입니다"\(그리고 EHLO의 경우 "서비스 확장 요청을 지원합니다"\)라고 해석될 수 있습니다.

---
### **3.3.  Mail Transactions**

SMTP 메일 거래에는 세 단계가 있습니다. 트랜잭션은 보낸 사람 식별 정보를 제공하는 MAIL 명령으로 시작됩니다. \(일반적으로 MAIL 명령은 메일 트랜잭션이 진행 중이 아닐 때만 전송될 수 있습니다. 섹션 4.1.4를 참조하십시오.\) 일련의 하나 이상의 RCPT 명령이 뒤따라 수신자에게 정보를 제공합니다. 그런 다음 DATA 명령은 메일 데이터 전송을 시작하고 트랜잭션을 확인하는 "메일 끝" 데이터 표시기에 의해 종료됩니다.

절차의 첫 번째 단계는 MAIL 명령입니다.

```text
      MAIL FROM:<reverse-path> [SP <mail-parameters> ] <CRLF>
```

이 명령은 SMTP 수신자에게 새로운 메일 트랜잭션이 시작 중임을 알리고 수신자 또는 메일 데이터를 포함하여 모든 상태 테이블과 버퍼를 재설정합니다. 첫 번째 또는 유일한 인수의 <reverse-path\> 부분에는 오류를 보고하는 데 사용할 수 있는 원본 메일함\("<" 및 "\>" 대괄호 사이\)이 포함됩니다\(오류 보고에 대한 설명은 섹션 4.2 참조\). 수락되면 SMTP 서버는 "250 OK" 응답을 반환합니다. 메일함 사양이 어떤 이유로 허용되지 않는 경우 서버는 실패가 영구적인지\(즉, 클라이언트가 동일한 주소를 다시 보내려고 하면 다시 발생함\) 또는 일시적인지\(즉, 주소가 허용될 수 있음\) 여부를 나타내는 응답을 반환해야 합니다. 클라이언트가 나중에 다시 시도하는 경우\). 이 요구 사항의 명백한 범위에도 불구하고 하나 이상의 정방향 경로\(RCPT 명령에서\)를 검사할 수 있을 때까지 역방향 경로의 허용 여부가 결정되지 않을 수 있는 상황이 있습니다. 이러한 경우 서버는 역방향 경로\(250 응답\)를 합리적으로 수락한 다음 정방향 경로를 수신하고 검사한 후 문제를 보고할 수 있습니다. 일반적으로 실패는 550 또는 553개의 응답을 생성합니다.\(MUST, MAY\)

역사적으로 <reverse-path\>에는 단순한 사서함 이상을 포함하는 것이 허용되었습니다. 그러나 최신 시스템은 소스 라우팅을 사용해서는 안 됩니다\(부록 C 참조\).\(SHOULD NOT\)

선택적 <mail-parameters\>는 협상된 SMTP 서비스 확장과 연결됩니다\(섹션 2.2 참조\).

절차의 두 번째 단계는 RCPT 명령입니다. 이 절차 단계는 여러 번 반복할 수 있습니다.

```text
      RCPT TO:<forward-path> [ SP <rcpt-parameters> ] <CRLF>
```

이 명령의 첫 번째 또는 유일한 인수에는 수신자 한 명을 식별하는 정방향 경로\(일반적으로 항상 "<" 및 "\>" 대괄호로 묶인 사서함 및 도메인\)가 포함됩니다. 수락되면 SMTP 서버는 "250 OK" 응답을 반환하고 전달 경로를 저장합니다. 만약

수신자가 배달 가능한 주소가 아닌 것으로 알려진 경우 SMTP 서버는 일반적으로 "해당 사용자 없음 -"과 같은 문자열과 메일함 이름\(다른 상황 및 응답 코드도 가능\)과 함께 550 응답을 반환합니다.

<forward-path\>에는 사서함 이상의 내용이 포함될 수 있습니다. 역사적으로 <forward-path\>는 호스트의 원본 라우팅 목록과 대상 사서함을 포함하는 것이 허용되었습니다. 그러나 최신 SMTP 클라이언트는 소스 경로를 활용해서는 안 됩니다\(부록 C 참조\). 서버는 전달 경로에서 소스 경로 목록을 만날 준비를 해야 하지만 경로를 무시해야 하거나 암시하는 중계 지원을 거부할 수도 있습니다. 마찬가지로, 서버는 다른 호스트나 시스템으로 향하는 메일 수신을 거부할 수 있습니다. 이러한 제한으로 인해 서버는 전체 SMTP 기능을 지원하지 않는 클라이언트에 대한 릴레이로 쓸모가 없게 됩니다. 결과적으로, 제한된 기능의 클라이언트는 인터넷의 어떤 SMTP 서버도 메일 처리\(중계\) 사이트로 사용될 수 있다고 가정해서는 안 됩니다. 이전 MAIL 명령 없이 RCPT 명령이 나타나는 경우 서버는 503 "명령의 잘못된 순서" 응답을 반환해야 합니다. 선택적 <rcpt-parameters\>는 협상된 SMTP 서비스 확장과 연결됩니다\(섹션 2.2 참조\).\(SHOULD NOT, MUST, MAY, MUST NOT, MUST\)

이는 일반적인 오류 원인이므로 MAIL 명령의 FROM 또는 RCPT 명령의 TO 뒤의 콜론 양쪽에 공백이 허용되지 않는다는 점에 유의할 가치가 있습니다. 구문은 위에 주어진 것과 정확히 같습니다.

절차의 세 번째 단계는 DATA 명령\(또는 서비스 확장에 지정된 일부 대안\)입니다.

```text
      DATA <CRLF>
```

수락되면 SMTP 서버는 354 중간 응답을 반환하고 메일 데이터 표시기의 끝을 포함하지 않는 모든 후속 행을 메시지 텍스트로 간주합니다. 텍스트 끝을 성공적으로 수신하고 저장하면 SMTP 수신자는 "250 OK" 응답을 보냅니다.

메일 데이터는 전송 채널을 통해 전송되므로 명령 및 응답 대화 상자를 다시 시작할 수 있도록 메일 데이터의 끝을 표시해야 합니다. SMTP는 "."만 포함하는 행을 보내 메일 데이터의 끝을 나타냅니다. \(마침표 또는 마침표\). 이것이 사용자의 텍스트를 방해하는 것을 방지하기 위해 투명성 절차가 사용됩니다\(섹션 4.5.2 참조\).

메일 데이터 표시기 끝은 메일 거래를 확인하고 SMTP 서버에 이제 저장된 수신자와 메일을 처리하라고 지시합니다.

데이터. 수락되면 SMTP 서버는 "250 OK" 응답을 반환합니다. DATA 명령은 프로토콜 교환의 두 지점에서만 실패할 수 있습니다.

MAIL이 없거나 RCPT 명령이 없거나 그러한 명령이 모두 거부된 경우 서버는 DATA 명령에 대한 응답으로 "순서가 잘못된 명령"\(503\) 또는 "유효한 수신자 없음"\(554\) 응답을 반환할 수 있습니다. 해당 응답 중 하나\(또는 다른 5yz 응답\)가 수신되면 클라이언트는 메시지 데이터를 보내면 안 됩니다. 더 일반적으로는 354 응답이 수신되지 않는 한 메시지 데이터를 전송해서는 안 됩니다.\(MAY, MUST NOT\)

동사가 처음에 승인되고 354 응답이 발행된 경우 메일 트랜잭션이 불완전한 경우\(예: 수신자가 없는 경우\), 리소스를 사용할 수 없는 경우\(물론 서버가 예기치 않게 사용할 수 없는 경우 포함\)에만 DATA 명령이 실패해야 합니다. 서버가 정책이나 기타 이유로 메시지를 거부해야 한다고 결정한 경우.

그러나 실제로 일부 서버에서는 메시지 텍스트가 수신될 때까지 수신자 확인을 수행하지 않습니다. 이러한 서버는 한 명 이상의 수신자에 대한 오류를 "후속 오류"로 처리하고 섹션 6, 특히 섹션 6.1에 설명된 대로 메일 메시지를 반환해야 합니다. 데이터가 승인된 후 "550 사서함을 찾을 수 없음"\(또는 이에 상응하는\) 응답 코드를 사용하면 클라이언트가 어떤 수신자가 실패했는지 확인하기 어렵거나 불가능합니다.\(SHOULD\)

RFC 822 형식\(\[28\], \[4\]\)이 사용되는 경우 메일 데이터에는 날짜, 제목, 받는 사람, 참조 및 보낸 사람과 같은 헤더 필드가 포함됩니다. 서버 SMTP 시스템은 RFC 822 또는 MIME\(RFC 2045 \[21\]\) 메시지 헤더 섹션이나 메시지 본문에서 감지된 결함을 기반으로 메시지를 거부해서는 안 됩니다. 특히, Resent-header 필드의 수가 일치하지 않거나 Resent-from 및/또는 Resent-date 없이 Resent-to가 나타나는 메시지를 거부해서는 안 됩니다.\(SHOULD NOT, MUST NOT\)

메일 거래 명령은 위에서 설명한 순서대로 사용해야 합니다.\(MUST\)

---
### **3.4.  Forwarding for Address Correction or Updating**

전달 지원은 일부 기업 내에서 또는 기업과 관련된 주소를 통합하고 단순화하는 데 가장 자주 필요하며, 개인의 이전 주소를 현재 주소와 연결하기 위해 주소를 설정하는 경우에는 덜 자주 필요합니다. 보안이나 비공개 목적으로 메시지를 자동으로 전달\(발신자에게 서버에 알리지 않고\)하는 것은 현대 인터넷에서 일반적입니다.

기업 및 "새 주소"의 경우 모두 정보 숨기기\(때때로 보안\) 고려 사항은 전달 활동의 부작용으로 SMTP 프로토콜을 통해 "최종" 주소가 노출되는 것에 반대합니다. 이는 다음과 같은 경우에 특히 중요할 수 있습니다.

발신자가 최종 주소에 도달하지 못할 수도 있습니다. 결과적으로 RFC 821의 섹션 3.2에 설명된 "전달" 메커니즘, 특히 RCPT의 251\(수정된 대상\) 및 551 응답 코드는 구현자와 사용 가능한 경우 구성 시스템에서 신중하게 평가해야 합니다\(섹션 참조\). 7.4\).

특히:

o 서버는 주소 변경을 인지하면 메시지를 전달할 수 있습니다. 그렇게 하면 251 코드로 주소 업데이트 정보를 제공하거나 "자동"으로 전달하고 250 코드를 반환할 수 있습니다. 그러나 251 코드가 사용되는 경우 클라이언트가 실제로 주소 정보를 업데이트하거나 해당 정보를 사용자에게 반환할 것이라고 가정해서는 안 됩니다.\(MAY, MAY, MUST NOT\)

```text
   Alternately,
```

o 서버는 메시지가 주소 지정된 대로 정확하게 배달될 수 없는 경우 메시지를 거부하거나 배달 불가능으로 반환할 수 있습니다. 그렇게 하면 551 코드로 주소 업데이트 정보를 제공하거나 주소 관련 정보 없이 550 코드로 메시지를 전달할 수 없다고 거부할 수 있습니다. 그러나 551 코드가 사용되는 경우 클라이언트가 실제로 주소 정보를 업데이트하거나 해당 정보를 사용자에게 반환할 것이라고 가정해서는 안 됩니다.\(MAY, MAY, MUST NOT\)

251 및/또는 551 응답 코드를 지원하는 SMTP 서버 구현은 바람직하지 않게 정보를 공개한다고 결론을 내리는 사이트가 해당 정보의 사용을 비활성화하거나 제한할 수 있도록 구성 메커니즘을 제공해야 합니다.\(SHOULD\)

---
### **3.5.  Commands for Debugging Addresses**
---
#### **3.5.1.  Overview**

SMTP는 사용자 이름을 확인하거나 메일링 목록의 내용을 얻기 위한 명령을 제공합니다. 이는 문자열 인수가 있는 VRFY 및 EXPN 명령을 사용하여 수행됩니다. 구현은 VRFY 및 EXPN을 지원해야 합니다\(단, 섹션 3.5.2 및 섹션 7.3 참조\).\(SHOULD\)

VRFY 명령의 경우 문자열은 사용자 이름 또는 사용자 이름과 도메인입니다\(아래 참조\). 일반\(예: 250\) 응답이 반환되면 응답에는 사용자의 전체 이름이 포함될 수 있으며 사용자의 사서함이 포함되어야 합니다. 다음 형식 중 하나여야 합니다.\(MUST, MUST\)

```text
      User Name <local-part@domain>
      local-part@domain
```

VRFY에 대한 인수인 이름이 둘 이상의 사서함을 식별할 수 있는 경우 서버는 모호성을 기록하거나 대안을 식별할 수 있습니다. 즉, 다음 중 하나는 VRFY에 대한 합법적인 응답입니다.\(MAY\)

```text
      553 User ambiguous

   or
```

553 - 모호함; 가능성은

- 553-조 스미스 <jsmith@foo.com\> 553-해리 스미스 <hsmith@foo.com\> 553 멜빈 스미스 <dweep@foo.com\>

```text
   or

      553-Ambiguous; Possibilities
      553- <jsmith@foo.com>
      553- <hsmith@foo.com>
      553 <dweep@foo.com>
```

일반적인 상황에서는 553 응답을 받은 클라이언트가 사용자에게 결과를 노출할 것으로 예상됩니다. 주어진 형식을 정확하게 사용하고 RFC 3463 \[25\]에 설명된 것과 같은 확장 응답 코드로 보완할 수 있는 "사용자 모호한" 또는 "모호한" 키워드를 사용하면 필요에 따라 다른 언어로의 자동 번역이 용이해집니다. 물론 고도로 자동화되었거나 영어가 아닌 다른 언어로 운영되는 클라이언트는 응답을 번역하여 응답의 문자 텍스트가 아닌 다른 표시를 사용자에게 반환하거나 다음과 같은 자동화된 작업을 수행하도록 선택할 수 있습니다. 사용자에게 보고하기 전에 추가 정보에 대해 디렉토리 서비스에 문의하십시오.

EXPN 명령의 경우 문자열은 메일링 목록을 식별하며 성공적인\(예: 250\) 여러 줄 응답은 사용자의 전체 이름을 포함할 수 있으며 메일링 목록에 사서함을 제공해야 합니다.\(MUST\)

일부 호스트에서는 공통 데이터 구조에 두 가지 유형의 항목이 모두 포함될 수 있고 하나의 사서함만 포함하는 메일링 목록이 있을 수 있기 때문에 메일링 목록과 단일 메일함의 별칭 간의 구분이 약간 모호합니다. 메일링 리스트에 VRFY를 적용하라는 요청이 있는 경우, 주소가 지정된 메시지가 리스트에 있는 모든 사람에게 전달된다면 긍정적인 응답이 주어질 수 있습니다. 그렇지 않으면 오류가 보고되어야 합니다\(예: "550 That is a mailing list, 사용자가 아님' 또는 '252 메일링 리스트의 구성원을 확인할 수 없습니다.'\). 사용자 이름을 확장하라는 요청이 있는 경우 서버는\(SHOULD, MAY\)

하나의 이름을 포함하는 목록으로 구성된 긍정적인 응답 또는 오류가 보고될 수 있습니다\(예: "550 메일링 목록이 아닌 사용자 이름입니다."\).\(MAY\)

여러 줄로 구성된 응답이 성공한 경우\(EXPN의 경우 일반\) 응답의 각 줄에 정확히 하나의 사서함이 지정됩니다. 모호한 요청의 경우는 위에서 논의되었습니다.

"사용자 이름"은 모호한 용어이며 의도적으로 사용되었습니다. VRFY 또는 EXPN 명령의 구현에는 최소한 로컬 사서함을 "사용자 이름"으로 인식하는 기능이 포함되어야 합니다. 그러나 현재 인터넷 관행에서는 단일 호스트가 여러 도메인에 대한 메일을 처리하는 경우가 많기 때문에 호스트, 특히 이 기능을 제공하는 호스트는 "local-part@domain" 형식을 "사용자 이름"으로 허용해야 합니다. 호스트는 다른 문자열을 "사용자 이름"으로 인식하도록 선택할 수도 있습니다.\(MUST, SHOULD\)

사서함 목록을 확장하는 경우 다음과 같이 여러 줄로 된 응답이 필요합니다.

```text
      C: EXPN Example-People
      S: 250-Jon Postel <Postel@isi.edu>
      S: 250-Fred Fonebone <Fonebone@physics.foo-u.edu>
      S: 250 Sam Q. Smith <SQSmith@specific.generic.com>

   or
```

C: EXPN Executive-Washroom-List

- S: 550 액세스가 거부되었습니다.

VRFY 및 EXPN 명령의 문자열 인수는 사용자 이름 및 메일함 목록 개념의 다양한 구현으로 인해 더 이상 제한될 수 없습니다. 일부 시스템에서는 EXPN 명령의 인수가 메일링 목록을 포함하는 파일의 파일 이름이 되는 것이 적절할 수 있지만 인터넷에는 다양한 파일 명명 규칙이 있습니다. 마찬가지로, 이러한 명령에 의해 반환되는 내용의 역사적 변형은 응답을 매우 주의 깊게 해석해야 하며 일반적으로 진단 목적으로만 사용해야 합니다.\(SHOULD\)

---
#### **3.5.2.  VRFY Normal Response**

VRFY 또는 EXPN 요청에서 일반\(2yz 또는 551\) 응답이 반환되면 응답에는 "<local-part@domain\>" 구성을 사용하는 <Mailbox\> 이름이 포함되어야 합니다. 여기서 "domain"은 정규화된 도메인 이름입니다. . 이 사양의 의도를 위반하는 것을 정당화할 만큼 예외적인 상황에서는 자유 형식 텍스트가 반환될 수 있습니다. 두 컴퓨터 모두에서 구문 분석을 용이하게 하기 위해\(MUST, MAY\)

사람, 주소는 괄호 안에 표시되어야 합니다. 자유 형식 디버깅 정보가 아닌 주소가 반환되면 EXPN 및 VRFY는 SMTP RCPT 명령에서 사용할 수 있는 유효한 도메인 주소만 반환해야 합니다. 결과적으로 주소가 프로그램이나 다른 시스템으로의 전달을 암시하는 경우 해당 대상에 도달하는 데 사용되는 메일함 이름이 제공되어야 합니다. 경로\(명시적 소스 경로\)는 VRFY 또는 EXPN에 의해 ​​반환되어서는 안 됩니다.\(SHOULD, MUST, MUST, MUST NOT\)

서버 구현은 VRFY와 EXPN을 모두 지원해야 합니다\(SHOULD\). 보안상의 이유로 구현에서는 구성 옵션이나 이에 상응하는 옵션을 통해 이러한 명령 중 하나 또는 둘 다를 비활성화하는 방법을 로컬 설치에 제공할 수 있습니다\(섹션 7.3 참조\). 이러한 명령이 지원되면 릴레이가 지원될 때 릴레이 간에 작업할 필요가 없습니다. 둘 다 RFC 821에서는 선택 사항이었지만 VRFY는 RFC 1123\[3\]에서 필수로 지정되었으므로 EXPN이 지원되는 경우 EHLO 응답에 서비스 확장으로 나열되어야 합니다. VRFY는 편의상 나열될 수 있지만 이에 대한 지원이 필요하므로 SMTP 클라이언트는 이를 사용하기 전에 확장 목록에 해당 항목이 있는지 확인할 필요가 없습니다.\(SHOULD, MAY, MUST, MAY\)

---
#### **3.5.3.  Meaning of VRFY or EXPN Success Response**

서버는 실제로 주소를 확인하지 않는 한 VRFY 또는 EXPN 명령에 대한 응답으로 250 코드를 반환해서는 안 됩니다. 특히 서버가 수행한 작업이 주어진 구문이 유효한지 확인하는 것뿐이라면 서버는 250을 반환해서는 안 됩니다. 이 경우 502\(명령이 구현되지 않음\) 또는 500\(구문 오류, 명령이 인식되지 않음\)이 반환되어야 합니다. 다른 곳에서 언급했듯이 VRFY 및 EXPN의 구현\(실제로 주소를 확인하고 정보를 반환한다는 의미에서\)을 강력히 권장합니다. 따라서 VRFY에 대해 500 또는 502를 반환하는 구현은 이 사양을 완전히 준수하지 않습니다.\(MUST NOT, MUST NOT, SHOULD\)

주소가 유효한 것처럼 보이지만 실시간으로 합리적으로 확인할 수 없는 상황이 있을 수 있습니다. 특히 서버가 다른 서버나 도메인에 대한 메일 교환기 역할을 하는 경우에는 더욱 그렇습니다. 이 경우 "명백한 유효성"에는 일반적으로 최소한 구문 검사가 포함되며 지정된 모든 도메인이 호스트가 메일을 중계할 수 있을 것으로 예상되는 도메인인지 확인하는 작업이 포함될 수 있습니다. 이러한 상황에서는 응답 코드 252가 반환되어야 합니다. 이러한 사례는 섹션 2.1의 RCPT 검증에 대한 논의와 유사합니다. 마찬가지로 섹션 3.4의 논의는 VRFY\(및 EXPN\)와 함께 응답 코드 251 및 551을 사용하여 인식되지만 전달되거나 거부될 주소가 수신된 메일임을 나타내는 데 적용됩니다. 구현은 일반적으로 RCPT의 경우보다 VRFY의 경우 주소 확인에 대해 시간이 조금 더 걸리더라도 더 적극적이어야 합니다.\(SHOULD, SHOULD\)

---
#### **3.5.4.  Semantics and Applications of EXPN**

EXPN은 메일링 리스트 및 다중 대상 주소 별칭 관련 문제를 디버깅하고 이해하는 데 매우 유용합니다. 일부 시스템에서는 중복을 제거하는 수단으로 메일링 목록의 소스 확장을 사용하려고 시도했습니다. 호스트\(일반적으로 MX 및 CNAME DNS 레코드 포함\), 사서함\(다양한 유형의 로컬 호스트 별칭\) 및 다양한 프록시 배열을 위한 인터넷 메일의 별칭 시스템 전파로 인해 이러한 전략이 일관되게 작동하는 것이 거의 불가능해졌습니다. 메일 시스템은 이를 시도해서는 안 됩니다.\(SHOULD NOT\)

---
### **3.6.  Relaying and Mail Routing**
---
#### **3.6.1.  Source Routes and Relaying**

일반적으로 도메인 이름 시스템\(RFC 1035 \[2\], RFC 974 \[12\]\)에서 Mail eXchanger 레코드를 사용할 수 있으므로 인터넷 메일 시스템에서 명시적인 소스 경로를 사용할 필요가 없습니다. 명시적 소스 경로 해석과 관련된 많은 역사적 문제로 인해 해당 경로의 사용이 바람직하지 않게 되었습니다. SMTP 클라이언트는 특별한 상황을 제외하고 명시적인 소스 경로를 생성해서는 안 됩니다. SMTP 서버는 메일 릴레이 역할을 거부하거나 소스 경로를 지정하는 주소를 수락하는 것을 거부할 수 있습니다. 경로 정보가 발견되면 SMTP 서버는 경로 정보를 무시할 수 있으며 경로의 마지막 요소로 지정된 최종 목적지로 간단히 보낼 수 있으며 그렇게 해야 합니다. DNS에 표시되지 않는 이름을 대상 이름으로 사용하고 발신자가 문제를 해결하기 위해 소스 라우팅에 지정된 중간 호스트를 사용하는 잘못된 관행이 있었습니다. 소스 경로가 제거되면 이 방식으로 인해 오류가 발생합니다. 이는 SMTP 클라이언트가 잘못된 소스 경로를 생성하거나 이름의 직렬 해석에 의존해서는 안 되는 여러 가지 이유 중 하나입니다.\(SHOULD NOT, MAY, SHOULD, MUST NOT\)

원본 경로를 사용하지 않는 경우 RFC 821에 설명된 정방향 경로에서 역방향 경로를 구성하는 프로세스는 적용되지 않으며 전달 시 역방향 경로는 단순히 MAIL 명령에 표시된 주소가 됩니다.

---
#### **3.6.2.  Mail eXchange Records and Relaying**

릴레이 SMTP 서버는 일반적으로 최종 전달 시스템이 아니라 이를 지정하는 DNS MX 레코드의 대상입니다. 릴레이 서버는 로컬 사용자에 대한 메일을 수락하거나 거부하는 것과 동일한 방식으로 메일 릴레이 작업을 수락하거나 거부할 수 있습니다. 작업을 수락하면 SMTP 클라이언트가 되어 DNS에 지정된 다음 SMTP 서버에 대한 전송 채널을 설정하고\(섹션 5의 규칙에 따라\) 메일을 보냅니다. 이를 거부하는 경우

정책상의 이유로 특정 주소로 메일을 중계하는 경우 550 응답이 반환되어야 합니다.\(SHOULD\)

이 사양은 배달 알림에 사용하기 위한 반환 경로 확인을 다루지 않습니다. SPF \[29\] 및 DKIM \[30\] \[31\]과 같은 최근 작업은 주소가 유효하거나 실제로 메시지를 보낸 사람의 것인지 확인하는 방법을 제공하기 위해 수행되었습니다. 서버는 배달 알림을 위해 주소를 사용하기 전에 반환 경로를 확인하려고 시도할 수 있지만 그렇게 하는 방법은 여기에 정의되어 있지 않으며 현재 권장되는 특정 방법도 없습니다.\(MAY\)

---
#### **3.6.3.  Message Submission Servers as Relays**

많은 메일 전송 클라이언트가 존재하며, 특히 POP3 또는 IMAP을 통해 메일을 수신하는 기능과 함께 존재하며 후속 배달 시도를 위해 메시지를 대기열에 넣는 기능과 같이 이 사양의 일부 요구 사항을 지원하는 기능이 제한되어 있습니다. 이러한 클라이언트의 경우 처리 및 후속 배포를 위해 모든 메시지를 단일 서버로 보내도록 개인적으로 준비하는 것이 일반적입니다. 여기에 지정된 SMTP는 이 역할에 이상적으로 적합하지 않습니다. 점차적으로 SMTP 기반 관행을 대체하는 표준화된 메일 제출 프로토콜이 개발되었습니다\(RFC 4409 \[18\] 참조\). 어떤 경우에도 이러한 배열은 비공개이며 이 사양의 범위를 벗어나므로 여기서는 설명하지 않습니다.

MX 레코드는 SMTP 릴레이 및 최종 전달 시스템뿐만 아니라 다른 환경에 대한 게이트웨이 역할을 하는 SMTP 서버를 가리킬 수 있다는 점에 유의하는 것이 중요합니다. 섹션 3.7 및 5를 참조하세요.

SMTP 서버가 메일 릴레이 작업을 수락하고 나중에 목적지가 올바르지 않거나 다른 이유로 메일을 배달할 수 없다는 사실을 발견한 경우 "배달할 수 없는 메일" 알림 메시지를 구성하여 보낸 사람에게 보내야 합니다. 배달할 수 없는 메일\(역방향 경로로 표시\) 가능하다면 다른 표준\(예: RFC 3461 \[32\] 및 RFC 3464 \[33\] 참조\)에 의해 배달 불능 보고서에 대해 지정된 형식을 사용해야 합니다.\(MUST, SHOULD\)

이 알림 메시지는 릴레이 호스트 또는 배달이 불가능하다고 처음 결정한 호스트의 SMTP 서버에서 전송되어야 합니다. 물론 SMTP 서버는 알림 메시지 전송 문제에 대한 알림 메시지를 보내서는 안 됩니다. 오류 보고에서 루프를 방지하는 한 가지 방법은 알림 메시지의 MAIL 명령에 null 역방향 경로를 지정하는 것입니다. 그러한 메시지가 전송되면 역방향 경로는 반드시 null로 설정되어야 합니다\(참조:\(MUST NOT, MUST\)

추가 논의는 섹션 4.5.5 참조\). null 역방향 경로가 있는 MAIL 명령은 다음과 같이 나타납니다.

```text
      MAIL FROM:<>
```

섹션 6.4에서 설명한 것처럼 릴레이 SMTP는 메시지 데이터의 헤더 섹션이나 본문을 검사하거나 조치를 취할 필요가 없으며 자체 "Received:" 헤더 필드\(섹션 4.4\)를 추가하는 것 외에는 그렇게 해서는 안 됩니다\(MUST NOT\). 메일 시스템의 루핑을 감지하려고 시도합니다\(섹션 6.3 참조\). 물론 이러한 금지 사항은 이러한 헤더 필드나 텍스트를 수정하는 경우에도 적용됩니다\(섹션 7.9 참조\).\(MUST NOT\)

---
### **3.7.  Mail Gatewaying**

위에서 설명한 릴레이 기능은 인터넷 SMTP 전송 서비스 환경 내에서 작동하지만 MX 레코드 또는 다양한 형태의 명시적 라우팅에서는 중간 SMTP 서버가 한 전송 서비스와 다른 전송 서비스 간의 변환 기능을 수행해야 할 수도 있습니다. 섹션 2.3.10에서 설명한 것처럼 이러한 시스템이 두 전송 서비스 환경 사이의 경계에 있는 경우 이를 "게이트웨이" 또는 "게이트웨이 SMTP"라고 합니다.

다양한 메일 형식 및 프로토콜과 같은 다양한 메일 환경 간의 메일 게이트웨이는 복잡하며 표준화가 쉽지 않습니다. 그러나 인터넷과 다른 메일 환경 간의 게이트웨이에 대한 몇 가지 일반적인 요구 사항이 제공될 수 있습니다.

---
#### **3.7.1.  Header Fields in Gatewaying**

메시지가 메일 환경 경계를 넘어 게이트웨이되므로 필요한 경우 헤더 필드를 다시 작성할 수 있습니다. 여기에는 섹션 6.4의 금지 사항에도 불구하고 메시지 본문을 검사하거나 대상 주소의 로컬 부분을 해석하는 작업이 포함될 수 있습니다.\(MAY\)

인터넷으로 게이트웨이되는 다른 메일 시스템은 종종 RFC 822 헤더 섹션의 하위 집합을 사용하거나 다른 구문으로 유사한 기능을 제공하지만 이러한 메일 시스템 중 일부에는 SMTP 봉투에 해당하는 기능이 없습니다. 따라서 메시지가 인터넷 환경을 떠날 때 SMTP 봉투 정보를 메시지 헤더 섹션에 접어야 할 수도 있습니다. 가능한 해결책은 봉투 정보\(예: "X-SMTP-MAIL:" 및 "X-SMTP-RCPT:"\)를 전달하기 위해 새 헤더 필드를 만드는 것입니다. 그러나 이를 위해서는 외국 환경에서 메일 프로그램을 변경해야 하며 개인 정보가 공개될 위험이 있습니다\(섹션 7.2 참조\).

---
#### **3.7.2.  Received Lines in Gatewaying**

인터넷 환경 안팎으로 메시지를 전달할 때 게이트웨이는 반드시 수신: 행을 앞에 추가해야 하지만 이미 헤더 섹션에 있는 수신: 행을 어떤 식으로든 변경해서는 안 됩니다.\(MUST NOT\)

다른 환경에서 발생한 메시지의 "Received:" 헤더 필드는 이 사양을 정확히 따르지 않을 수 있습니다. 그러나 Receiverd: 행의 가장 중요한 용도는 메일 오류를 디버깅하는 것이며, 이 디버깅은 Receiverd: 행을 "수정"하려고 시도하는 선의의 게이트웨이에 의해 심각하게 방해받을 수 있습니다. 비SMTP 환경에서 발생하는 추적 헤더 필드의 또 다른 결과로, 수신 시스템은 추적 헤더 필드의 형식을 기반으로 메일을 거부해서는 안 되며, 해당 헤더 필드의 예상치 못한 정보나 형식을 고려하여 매우 강력해야 합니다.\(MUST NOT\)

게이트웨이는 자신이 제공하는 수신 헤더 필드의 "via" 절에 환경과 프로토콜을 표시해야 합니다.\(SHOULD\)

---
#### **3.7.3.  Addresses in Gatewaying**

인터넷 측에서 게이트웨이는 SMTP 명령과 RFC 822 헤더 섹션의 모든 유효한 주소 형식과 모든 유효한 RFC 822 메시지를 수락해야 합니다. 게이트웨이에 의해 생성된 주소 및 헤더 필드는 적용 가능한 표준\(이 표준 및 RFC 5322 \[4\] 포함\)을 준수해야 합니다. 물론 게이트웨이에는 섹션 3.3에서 다른 SMTP 시스템에 대해 설명한 것과 동일한 소스 경로 처리 규칙이 적용됩니다.\(SHOULD, MUST\)

---
#### **3.7.4.  Other Header Fields in Gatewaying**

게이트웨이는 인터넷 메일 환경으로 전달하는 메시지의 모든 헤더 필드가 인터넷 메일 요구 사항을 충족하는지 확인해야 합니다. 특히 "From:", "To:", "Cc:" 등의 헤더 필드에 있는 모든 주소는 RFC 5322 \[4\]의 표준 헤더 구문을 충족하기 위해 \(필요한 경우\) 변환되어야 하며, 전체 참조만 해야 합니다. -적격 도메인 이름은 답장을 보내는 데 효과적이고 유용해야 합니다. 인터넷 프로토콜의 메일을 다른 환경의 프로토콜로 변환하는 데 사용되는 변환 알고리즘은 외부 메일 환경의 오류 메시지가 "보낸 사람:", "발신자"의 주소가 아닌 SMTP 봉투의 역방향 경로로 전달되도록 해야 합니다. :" 또는 메시지의 유사한 헤더 필드입니다.\(MUST, MUST, SHOULD\)

---
#### **3.7.5.  Envelopes in Gatewaying**

마찬가지로, 다른 환경에서 인터넷으로 메시지를 전달할 때 게이트웨이는 외부 환경에서 제공되는 경우 오류 메시지 반환 주소에 따라 봉투 반환 경로를 설정해야 합니다. 외부 환경에 동등한 개념이 없는 경우 게이트웨이는 메시지 발신자의 주소를 최후의 수단으로 사용하여 최선의 근사치를 선택하고 사용해야 합니다.\(SHOULD\)

---
### **3.8.  Terminating Sessions and Connections**

클라이언트가 QUIT 명령을 보내면 SMTP 연결이 종료됩니다. 서버는 긍정적인 응답 코드로 응답한 후 연결을 닫습니다.

SMTP 서버는 다음을 제외하고 정상적인 작동 상황\(섹션 7.8 참조\)에서 의도적으로 연결을 닫아서는 안 됩니다.\(MUST NOT\)

o QUIT 명령을 받고 221 응답으로 응답한 후.

o SMTP 서비스 종료 필요성을 감지하고 421 응답 코드를 반환한 후. 이 응답 코드는 서버가 명령을 수신한 후에 발행될 수 있으며, 필요한 경우 명령 수신에서 비동기적으로 발행될 수 있습니다\(클라이언트가 다음 명령이 발행된 후에 응답 코드를 수신한다는 가정 하에\).

o 섹션 4.5.3.2에 지정된 대로 시간 초과 후 클라이언트가 명령이나 데이터를 보내기를 기다리는 동안 발생합니다.

특히, 이해되지 않는 명령에 대한 응답으로 연결을 닫는 서버는 이 사양을 위반합니다. 서버는 알 수 없는 명령을 허용하고 500 응답을 발행하고 클라이언트의 추가 지시를 기다립니다.

외부 수단을 통해 강제로 종료되는 SMTP 서버는 종료하기 전에 421 응답 코드가 포함된 행을 SMTP 클라이언트로 보내려고 시도해야 합니다. SMTP 클라이언트는 일반적으로 다음 명령을 보낸 후 421 응답 코드를 읽습니다.\(SHOULD\)

통제할 수 없는 상황\(본 사양의 의도를 위반하지만 때로는 피할 수 없는\)으로 인해 연결 종료, 재설정 또는 기타 통신 실패를 경험하는 SMTP 클라이언트는 메일 시스템의 견고성을 유지하기 위해 메일 트랜잭션을 다음과 같이 처리해야 합니다. 451 응답이 수신되면 그에 따라 조치를 취하십시오.\(SHOULD\)

---
### **3.9.  Mailing Lists and Aliases**

SMTP 가능 호스트는 다중 전달을 위한 주소 확장의 별칭 및 목록 모델을 모두 지원해야 합니다. 메시지가 확장된 목록 형식의 각 주소로 전달되거나 전달될 때 봉투의 반송 주소\("MAIL FROM:"\)는 목록을 관리하는 사람 또는 기타 개체의 주소로 변경되어야 합니다. 그러나 이 경우 메시지 헤더 섹션\(RFC 5322 \[4\]\)은 변경되지 않은 채로 남아 있어야 합니다. 특히 헤더 섹션의 "보낸 사람" 필드는 영향을 받지 않습니다.\(SHOULD, MUST, MUST\)

중요한 메일 기능은 의사 메일함 주소를 대상 메일함 주소 목록으로 변환\(또는 "확장" 또는 "폭발"\)하여 단일 메시지를 다중 대상으로 전달하기 위한 메커니즘입니다. 메시지가 이러한 유사 메일박스\("폭발기"라고도 함\)로 전송되면 복사본이 확장된 목록의 각 메일박스로 전달되거나 재배포됩니다. 서버는 단순히 목록에 있는 주소를 활용해야 합니다. 발신자의 주소와 같은 일부 주소를 제거하기 위해 경험적 방법이나 기타 일치 규칙을 적용하는 것은 권장되지 않습니다. 우리는 확장 규칙에 따라 이러한 의사 메일함을 "별칭" 또는 "목록"으로 분류합니다.\(SHOULD\)

---
#### **3.9.1.  Alias**

별칭을 확장하려면 수신자 메일러는 봉투에 있는 의사 메일함 주소를 확장된 각 주소로 간단히 대체합니다. 봉투의 나머지 부분과 메시지 본문은 변경되지 않습니다. 그런 다음 메시지는 각 확장된 주소로 배달되거나 전달됩니다.

---
#### **3.9.2.  List**

메일링 리스트는 "전달"보다는 "재배포"로 작동한다고 할 수 있습니다. 목록을 확장하기 위해 수신자 메일러는 봉투에 있는 의사 사서함 주소를 확장된 각 주소로 차례로 바꿉니다. 봉투의 반송\(역방향 지정\) 주소가 변경되어 최종 배달에서 생성된 모든 오류 메시지는 일반적으로 목록의 내용을 제어할 수 없으며 메시지 발신자가 아닌 목록 관리자에게 반환됩니다. 일반적으로 오류 메시지가 짜증납니다. 별칭 처리\(섹션 3.9.1\)와 전달\(이 하위 섹션\) 간의 주요 차이점은 이 경우 역방향 지정 주소가 변경된다는 것입니다. 목록이 여기에 설명된 매우 제한된 수정 및 작업 집합으로 처리를 제한하는 경우 MTA를 에뮬레이트하려고 시도하는 것입니다. 이러한 목록은 이메일 전송의 연속으로 처리될 수 있습니다.

메시지와 봉투에 대한 추가 수정, 때로는 광범위한 수정을 수행하는 메일링 리스트가 있습니다. 이러한 메일링 리스트는 배달을 수락하고 새 메시지를 게시하는 완전한 MUA로 보아야 합니다.

---
## **4.  The SMTP Specifications**
---
### **4.1.  SMTP Commands**
---
#### **4.1.1.  Command Semantics and Syntax**

SMTP 명령은 사용자가 요청한 메일 전송 또는 메일 시스템 기능을 정의합니다. SMTP 명령은 <CRLF\>로 끝나는 문자열입니다. 명령 자체는 매개변수가 뒤따르면 <SP\>로 끝나고 그렇지 않으면 <CRLF\>로 끝나는 알파벳 문자입니다. \(향상된 상호 운용성을 위해 SMTP 수신자는 종료 <CRLF\> 앞에 후행 공백을 허용해야 합니다.\) 사서함의 로컬 부분 구문은 수신자 사이트 규칙 및 섹션 4.1.2에 지정된 구문을 준수해야 합니다. SMTP 명령은 아래에 설명되어 있습니다. SMTP 응답은 섹션 4.2에서 논의됩니다.\(MUST\)

메일 트랜잭션에는 다양한 명령에 대한 인수로 전달되는 여러 데이터 개체가 포함됩니다. reverse-path는 MAIL 명령의 인수이고,ward-path는 RCPT 명령의 인수이며, 메일 데이터는 DATA 명령의 인수입니다. 이러한 인수 또는 데이터 개체는 트랜잭션을 완료하는 메일 데이터 표시의 끝에서 전달되는 확인을 기다리는 동안 전송 및 유지되어야 합니다. 이에 대한 모델은 데이터 객체의 유형을 보유하기 위해 고유한 버퍼가 제공된다는 것입니다. 즉, 역방향 경로 버퍼, 정방향 경로 버퍼 및 메일 데이터 버퍼가 있습니다. 특정 명령을 사용하면 정보가 특정 버퍼에 추가되거나 하나 이상의 버퍼가 지워집니다.

여러 명령\(RSET, DATA, QUIT\)이 매개변수를 허용하지 않는 것으로 지정되었습니다. 서버가 제공하고 클라이언트가 수락한 특정 확장이 없으면 클라이언트는 그러한 매개변수를 전송해서는 안 되며, 서버는 해당 매개변수가 포함된 명령을 잘못된 구문이 있는 것으로 거부해야 합니다.\(MUST NOT\)

---
##### **4.1.1.1.  Extended HELLO (EHLO) or HELLO (HELO)**

이러한 명령은 SMTP 서버에서 SMTP 클라이언트를 식별하는 데 사용됩니다. 인수 절에는 SMTP 클라이언트의 정규화된 도메인 이름\(사용 가능한 경우\)이 포함됩니다. SMTP 클라이언트 시스템에 의미 있는 도메인 이름이 없는 상황\(예: 주소가 동적으로 할당되고 역방향 매핑 기록이 없는 경우\)

가능\) 클라이언트는 주소 리터럴을 보내야 합니다\(섹션 4.1.3 참조\).\(SHOULD\)

RFC 2821 및 일부 초기 비공식 관행에서는 클라이언트 시스템을 식별하는 데 도움이 되는 정보를 문자 그대로 따르도록 권장했습니다. 해당 규칙은 널리 지원되지 않았으며 많은 SMTP 서버가 이를 오류로 간주했습니다. 상호 운용성을 위해 서버가 이 문자열이 발생하도록 준비하는 것이 현명할 수 있지만 SMTP 클라이언트는 이 문자열을 보내서는 안 됩니다.\(SHOULD NOT\)

SMTP 서버는 연결 인사말 응답과 이 명령에 대한 응답에서 SMTP 클라이언트에 대해 자신을 식별합니다.

클라이언트 SMTP는 EHLO 명령을 실행하여 SMTP 세션을 시작해야 합니다. SMTP 서버가 SMTP 서비스 확장을 지원하는 경우 성공적인 응답, 실패 응답 또는 오류 응답을 제공합니다. 이 사양을 위반하는 SMTP 서버가 SMTP 서비스 확장을 지원하지 않는 경우 오류 응답을 생성합니다. 위에서 설명한 것처럼 이전 클라이언트 SMTP 시스템은 EHLO 대신 HELO\(RFC 821에 지정된 대로\)를 사용할 수 있으며 서버는 HELO 명령을 지원하고 그에 적절하게 응답해야 합니다. 어떤 경우에도 클라이언트는 메일 거래를 시작하기 전에 HELO 또는 EHLO를 발행해야 합니다.\(SHOULD, MUST, MUST\)

이러한 명령과 그 중 하나에 대한 "250 OK" 응답은 SMTP 클라이언트와 SMTP 서버가 모두 초기 상태, 즉 진행 중인 트랜잭션이 없고 모든 상태 테이블과 버퍼가 지워졌음을 확인합니다.

```text
   Syntax:

   ehlo           = "EHLO" SP ( Domain / address-literal ) CRLF

   helo           = "HELO" SP Domain CRLF
```

일반적으로 EHLO에 대한 응답은 여러 줄로 된 응답입니다. 응답의 각 줄에는 키워드와 선택적으로 하나 이상의 매개변수가 포함됩니다. 여러 줄 응답에 대한 일반적인 구문에 따라 이러한 키워드는 마지막 줄을 제외한 모든 줄에 대해 코드\(250\)와 하이픈, 마지막 줄에 대한 코드와 공백 뒤에 옵니다. RFC 5234 \[7\]의 ABNF 표기법과 터미널 기호를 사용하는 긍정적인 응답의 구문은 다음과 같습니다.

```text
   ehlo-ok-rsp    = ( "250" SP Domain [ SP ehlo-greet ] CRLF )
                    / ( "250-" Domain [ SP ehlo-greet ] CRLF
                    *( "250-" ehlo-line CRLF )
                    "250" SP ehlo-line CRLF )

   ehlo-greet     = 1*(%d0-9 / %d11-12 / %d14-127)
                    ; string of any characters other than CR or LF

   ehlo-line      = ehlo-keyword *( SP ehlo-param )
```

ehlo-키워드 = \(ALPHA / DIGIT\) \*\(ALPHA / DIGIT / "-"\)

- ; ehlo-params의 추가 구문은 다음에 따라 다릅니다. ehlo 키워드

```text
   ehlo-param     = 1*(%d33-126)
                    ; any CHAR excluding <SP> and all
                    ; control characters (US-ASCII 0-31 and 127
                    ; inclusive)
```

EHLO 키워드는 대문자, 소문자 또는 대소문자 혼합으로 지정될 수 있지만 항상 대소문자를 구분하지 않고 인식되고 처리되어야 합니다. 이는 RFC 821 및 섹션 2.4에 지정된 관행의 확장일 뿐입니다.\(MUST\)

EHLO 응답에는 섹션 4.1.5에 설명된 개인용 명령만 제외하고 섹션 4.5.1에 ​​"필수"로 나열되지 않은 모든 명령에 대한 키워드\(및 필요한 경우 관련 매개변수\)가 포함되어야 합니다. 개인용 명령이 나열될 수 있습니다.\(MUST, MAY\)

---
##### **4.1.1.2.  MAIL (MAIL)**

이 명령은 메일 데이터가 SMTP 서버로 전달되고, SMTP 서버는 이를 하나 이상의 사서함으로 전달하거나 다른 시스템\(아마도 SMTP 사용\)으로 전달하는 메일 트랜잭션을 시작하는 데 사용됩니다. 인수 절에는 역방향 경로가 포함되어 있으며 선택적 매개변수가 포함될 수 있습니다. 일반적으로 MAIL 명령은 진행 중인 메일 트랜잭션이 없을 때만 전송될 수 있습니다. 섹션 4.1.4를 참조하세요.

역방향 경로는 보낸 사람 사서함으로 구성됩니다. 역사적으로 해당 사서함 앞에는 선택적으로 호스트 목록이 올 수 있었지만 이제 해당 동작은 더 이상 사용되지 않습니다\(부록 C 참조\). 회신으로 인해 메일 루프가 발생할 가능성이 있는 일부 보고 메시지 유형\(예: 메일 배달 및 배달 못 함 알림\)에서는 역방향 경로가 null일 수 있습니다\(섹션 3.6 참조\).

이 명령은 역방향 경로 버퍼, 정방향 경로 버퍼 및 메일 데이터 버퍼를 지우고 인수 절의 역방향 경로 정보를 역방향 경로 버퍼에 삽입합니다.

서비스 확장이 협상된 경우 MAIL 명령은 특정 서비스 확장과 관련된 매개변수를 전달할 수도 있습니다.

```text
   Syntax:

   mail = "MAIL FROM:" Reverse-path
                                       [SP Mail-parameters] CRLF
```

---
##### **4.1.1.3.  RECIPIENT (RCPT)**

이 명령은 메일 데이터의 개별 수신자를 식별하는 데 사용됩니다. 이 명령을 여러 번 사용하면 여러 수신자가 지정됩니다. 인수 절에는 정방향 경로가 포함되어 있으며 선택적 매개변수가 포함될 수 있습니다.

전달 경로는 일반적으로 필요한 대상 사서함으로 구성됩니다. 송신 시스템은 소스 경로로 알려진 선택적 호스트 목록을 생성해서는 안 됩니다. 수신 시스템은 소스 경로 구문을 인식해야 하지만\(MUST\) 소스 경로 사양을 제거하고 소스 경로가 제공되지 않은 것처럼 사서함과 연결된 도메인 이름을 활용해야 합니다.\(SHOULD NOT, MUST\)

마찬가지로 릴레이 호스트는 소스 경로를 제거하거나 무시해야 하며 이름은 역방향 경로에 복사되어서는 안 됩니다. 메일이 최종 목적지에 도달하면\(forward-path에는 대상 메일함만 포함됨\) SMTP 서버는 호스트 메일 규칙에 따라 메일을 대상 메일함에 삽입합니다.\(MUST NOT\)

이 명령은 전달 경로 인수를 전달 경로 버퍼에 추가합니다. 역방향 경로 버퍼나 메일 데이터 버퍼는 변경되지 않습니다.

예를 들어 봉투 명령을 사용하여 릴레이 호스트 xyz.com에서 수신된 메일

```text
      MAIL FROM:<userx@y.foo.org>
      RCPT TO:<@hosta.int,@jkl.org:userc@d.bar.org>
```

일반적으로 봉투 명령을 사용하여 호스트 d.bar.org로 직접 전송됩니다.

```text
      MAIL FROM:<userx@y.foo.org>
      RCPT TO:<userc@d.bar.org>
```

부록 C에 제공된 대로 xyz.com은 봉투 명령을 사용하여 메시지를 Hosta.int에 전달하도록 선택할 수도 있습니다.\(MAY\)

```text
      MAIL FROM:<userx@y.foo.org>
      RCPT TO:<@hosta.int,@jkl.org:userc@d.bar.org>
```

또는 봉투 명령을 사용하여 jkl.org로 이동

```text
      MAIL FROM:<userx@y.foo.org>
      RCPT TO:<@jkl.org:userc@d.bar.org>
```

이러한 방식으로 중계를 사용하려는 시도는 이제 강력히 권장되지 않습니다. 호스트는 메일을 릴레이할 필요가 전혀 없기 때문에 xyz.com은 RCPT 명령이 수신될 때 550 코드를 사용하여 메시지를 완전히 거부할 수도 있습니다\(이것이 "정책 이유"이기 때문\).\(MAY\)

서비스 확장이 협상된 경우 RCPT 명령은 서버가 제공하는 특정 서비스 확장과 관련된 매개변수를 전달할 수도 있습니다. 클라이언트는 EHLO 응답에서 서버가 제공하는 서비스 확장과 관련된 매개변수 이외의 매개변수를 전송해서는 안 됩니다.\(MUST NOT\)

```text
   Syntax:

      rcpt = "RCPT TO:" ( "<Postmaster@" Domain ">" / "<Postmaster>" /
                  Forward-path ) [SP Rcpt-parameters] CRLF
```

- 로컬 부분에 대한 일반적인 규칙과 달리 위에 표시된 "Postmaster" 문자열은 대소문자를 구분하지 않는 것으로 처리됩니다.

---
##### **4.1.1.4.  DATA (DATA)**

수신자는 일반적으로 DATA에 354 응답을 보낸 다음 명령 뒤의 라인\(섹션 2.3.7에 설명된 <CRLF\> 시퀀스로 끝나는 문자열\)을 보낸 사람의 메일 데이터로 처리합니다. 이 명령을 사용하면 메일 데이터가 메일 데이터 버퍼에 추가됩니다. 메일 데이터에는 128개의 ASCII 문자 코드가 포함될 수 있습니다. 경험에 따르면 SP, HT, CR 및 LF 이외의 제어 문자를 사용하면 문제가 발생할 수 있으므로 가능하면 피해야 합니다.\(SHOULD\)

메일 데이터는 마침표만 포함하는 줄, 즉 문자 시퀀스 "<CRLF\>.<CRLF\>"로 종료됩니다. 여기서 첫 번째 <CRLF\>는 실제로 이전 줄의 종결자입니다\(섹션 4.5.2 참조\). . 메일 데이터 표시의 끝입니다. 이 종료 시퀀스의 첫 번째 <CRLF\>는 데이터\(메시지 텍스트\)의 마지막 줄을 끝내는 <CRLF\>이기도 합니다. 또는 메일 데이터가 없는 경우 DATA 명령 자체를 종료합니다\("메일 데이터 없음"의 경우\). 이 사양에서 요구하는 추적 헤더 필드나 RFC 5322 \[4\]에서 요구하는 메시지 헤더 섹션이 전송될 필요가 없기 때문에 이 사양을 따르지 않습니다. 추가 <CRLF\>를 추가하면 안 됩니다. 그러면 메시지에 빈 줄이 추가됩니다. 이 규칙의 유일한 예외는 다음과 같은 경우에 발생합니다.\(MUST NOT\)

본문은 <CRLF\>로 끝나지 않는 마지막 "줄"과 함께 원래 SMTP 발신자에게 전달되었습니다. 이 경우 발신 SMTP 시스템은 메시지를 유효하지 않은 것으로 거부하거나 수신 SMTP 서버가 "데이터 끝" 조건을 인식하도록 <CRLF\>를 추가해야 합니다.\(MUST\)

일부 UNIX 시스템의 부적합한 동작에 대한 양보로 <LF\>로만 끝나는 줄을 허용하는 관습은 이것이 해결하는 것보다 더 많은 상호 운용성 문제를 일으키는 것으로 입증되었으며 SMTP 서버 시스템은 이러한 작업을 수행해서는 안 됩니다. 견고함을 더한 이름. 특히 "<LF\>.<LF\>" 시퀀스\(캐리지 리턴 없이 줄 바꿈\)는 메일 데이터 표시의 끝인 <CRLF\>.<CRLF\>와 동등한 것으로 취급되어서는 안 됩니다.\(MUST NOT, MUST NOT\)

메일 데이터 종료 표시를 수신하려면 서버에서 저장된 메일 거래 정보를 처리해야 합니다. 이 처리에서는 역방향 경로 버퍼, 전달 경로 버퍼 및 메일 데이터 버퍼의 정보를 소비하며 이 명령이 완료되면 이러한 버퍼가 지워집니다. 처리가 성공하면 수신자는 반드시 OK 응답을 보내야 합니다. 처리가 실패하면 수신자는 실패 응답을 보내야 합니다. SMTP 모델은 이 시점에서 부분적인 실패를 허용하지 않습니다. 즉, 메시지가 전달을 위해 서버에 의해 승인되고 긍정적인 응답이 반환되거나 메시지가 승인되지 않고 실패 응답이 반환됩니다. 데이터 종료 표시에 대해 긍정적인 "250 OK" 완료 응답을 보내는 경우 수신자는 메시지에 대한 전적인 책임을 집니다\(섹션 6.1 참조\). 이후에 진단된 오류는 섹션 4.4에 설명된 대로 메일 메시지로 보고되어야 합니다.\(MUST, MUST, MUST\)

SMTP 서버가 중계 또는 최종 전달을 위해 메시지를 수락하면 메일 데이터 상단에 추적 레코드\("타임스탬프 라인" 또는 "수신" 라인이라고도 함\)를 삽입합니다. 이 추적 레코드는 메시지를 보낸 호스트의 ID, 메시지를 받은\(그리고 이 타임스탬프를 삽입하는\) 호스트의 ID, 메시지를 받은 날짜와 시간을 나타냅니다. 릴레이된 메시지에는 여러 개의 타임스탬프 줄이 있습니다. 구문을 포함하여 이러한 행의 구성에 대한 세부 사항은 섹션 4.4에 지정되어 있습니다.

DATA 명령의 작동에 대한 추가 논의는 섹션 3.3에 나와 있습니다.

```text
   Syntax:

      data = "DATA" CRLF
```

---
##### **4.1.1.5.  RESET (RSET)**

이 명령은 현재 메일 트랜잭션이 중단되도록 지정합니다. 저장된 보낸 사람, 받는 사람 및 메일 데이터는 모두 삭제되어야 하며 모든 버퍼와 상태 테이블이 지워져야 합니다. 수신자는 인수 없이 RSET 명령에 "250 OK" 응답을 보내야 합니다. 클라이언트는 언제든지 재설정 명령을 실행할 수 있습니다. EHLO 직후, 세션에서 EHLO가 실행되기 전, 데이터 끝 표시기가 전송되고 승인된 후 또는 QUIT 직전에 실행되는 경우 NOOP\(즉, 효과가 없음\)와 실질적으로 동일합니다. SMTP 서버는 RSET 수신의 결과로 연결을 닫아서는 안 됩니다. 해당 작업은 QUIT용으로 예약되어 있습니다\(섹션 4.1.1.10 참조\).\(MUST, MUST, MUST NOT\)

EHLO는 서버의 일부 추가 처리 및 응답을 의미하므로 형식적인 의미가 동일하더라도 RSET는 일반적으로 해당 명령을 다시 실행하는 것보다 더 효율적입니다.

이 사양의 의도와는 반대로 SMTP 서버가 기본 TCP 연결이 닫혔거나 재설정되었다는 표시를 받을 수 있는 상황이 있습니다. 메일 시스템의 견고성을 유지하기 위해 SMTP 서버는 이 조건에 대비해야 하며 연결이 사라지기 전에 QUIT가 수신된 것처럼 처리해야 합니다.\(SHOULD\)

```text
   Syntax:

      rset = "RSET" CRLF
```

---
##### **4.1.1.6.  VERIFY (VRFY)**

이 명령은 수신자에게 인수가 사용자 또는 사서함을 식별하는지 확인하도록 요청합니다. 사용자 이름인 경우 섹션 3.5에 지정된 대로 정보가 반환됩니다.

이 명령은 역방향 경로 버퍼, 정방향 경로 버퍼 또는 메일 데이터 버퍼에 영향을 주지 않습니다.

```text
   Syntax:

      vrfy = "VRFY" SP String CRLF
```

---
##### **4.1.1.7.  EXPAND (EXPN)**

이 명령은 수신자에게 인수가 메일링 목록을 식별하는지 확인하고, 그렇다면 해당 목록의 멤버십을 반환하도록 요청합니다. 명령이 성공하면 섹션 3.5에 설명된 정보가 포함된 응답이 반환됩니다. 이 응답은 단일 구성원 목록의 사소한 경우를 제외하고 여러 줄로 구성됩니다.

이 명령은 역방향 경로 버퍼, 전달 경로 버퍼 또는 메일 데이터 버퍼에 영향을 주지 않으며 언제든지 실행될 수 있습니다.

```text
   Syntax:

      expn = "EXPN" SP String CRLF
```

---
##### **4.1.1.8.  HELP (HELP)**

이 명령을 사용하면 서버는 클라이언트에 유용한 정보를 보냅니다. 명령은 인수\(예: 명령 이름\)를 취하고 보다 구체적인 정보를 응답으로 반환할 수 있습니다.\(MAY\)

이 명령은 역방향 경로 버퍼, 전달 경로 버퍼 또는 메일 데이터 버퍼에 영향을 주지 않으며 언제든지 실행될 수 있습니다.

SMTP 서버는 인수 없이 HELP를 지원해야 하며 인수를 사용하여 지원할 수도 있습니다.\(SHOULD\)

```text
   Syntax:

      help = "HELP" [ SP String ] CRLF
```

---
##### **4.1.1.9.  NOOP (NOOP)**

이 명령은 매개변수나 이전에 입력한 명령에 영향을 주지 않습니다. 수신자가 "250 OK" 응답을 보내는 것 외에는 어떤 작업도 지정하지 않습니다.

이 명령은 역방향 경로 버퍼, 전달 경로 버퍼 또는 메일 데이터 버퍼에 영향을 주지 않으며 언제든지 실행될 수 있습니다. 매개변수 문자열이 지정되면 서버는 이를 무시해야 합니다.\(SHOULD\)

```text
   Syntax:

      noop = "NOOP" [ SP String ] CRLF
```

---
##### **4.1.1.10.  QUIT (QUIT)**

이 명령은 수신자가 "221 OK" 응답을 보낸 다음 전송 채널을 닫아야 함을 지정합니다.\(MUST\)

수신자는 QUIT 명령을 수신하고 이에 응답할 때까지\(오류가 발생한 경우에도\) 의도적으로 전송 채널을 닫아서는 안 됩니다. 발신자는 QUIT 명령을 보낼 때까지 전송 채널을 의도적으로 닫아서는 안 되며, 응답을 받을 때까지 기다려야 합니다\(이전 명령에 대한 오류 응답이 있더라도\). 위의 위반이나 시스템 또는 네트워크 오류로 인해 연결이 조기에 닫히는 경우 서버는 보류 중인 모든 트랜잭션을 취소해야 하지만 이전에 완료된 트랜잭션을 취소해서는 안 되며 일반적으로 진행 중인 명령이나 트랜잭션이 임시 트랜잭션을 수신한 것처럼 행동해야 합니다. 오류\(즉, 4yz 응답\).\(MUST NOT, MUST NOT, MUST\)

QUIT 명령은 언제든지 실행될 수 있습니다. 현재 완료되지 않은 메일 거래는 모두 중단됩니다.

```text
   Syntax:

      quit = "QUIT" CRLF
```

---
##### **4.1.1.11.  Mail-Parameter and Rcpt-Parameter Error Responses**

서버 SMTP가 특정 MAIL FROM 또는 RCPT TO 명령과 관련된 하나 이상의 매개 변수를 인식하지 못하거나 구현할 수 없는 경우 코드 555를 반환합니다.

어떤 이유로 인해 서버가 일시적으로 MAIL FROM 또는 RCPT TO 명령과 관련된 하나 이상의 매개변수를 수용할 수 없고 특정 매개변수의 정의가 다른 코드의 사용을 요구하지 않는 경우 코드를 반환해야 합니다. 455.

특정 매개변수 및 해당 값과 관련된 오류는 매개변수 정의 RFC에 지정됩니다.

---
#### **4.1.2.  Command Argument Syntax**

위 명령의 인수 절 구문\(해당되는 경우 RFC 5234 \[7\]에 지정된 구문 사용\)은 다음과 같습니다. 아래 제공된 일부 프로덕션은 부록 C에 설명된 대로 소스 경로와 함께만 사용됩니다. ALPHA, DIGIT, SP, CR, LF, CRLF와 같이 이 문서에 정의되지 않은 터미널은 "core" 구문에 정의되어 있습니다. RFC 5234 \[7\]의 섹션 6 또는 RFC 5322 \[4\]의 메시지 형식 구문에 있습니다.

```text
   Reverse-path   = Path / "<>"

   Forward-path   = Path

   Path           = "<" [ A-d-l ":" ] Mailbox ">"
```

A-d-l = At-도메인 \*\( "," At-도메인 \)

- ; 소위 "소스 ; 경로"라고 불리는 이 형식은 반드시 허용되어야 하며 허용되어서는 안 됩니다. 생성되며 무시해야 합니다.\(MUST\)

```text
   At-domain      = "@" Domain

   Mail-parameters  = esmtp-param *(SP esmtp-param)

   Rcpt-parameters  = esmtp-param *(SP esmtp-param)

   esmtp-param    = esmtp-keyword ["=" esmtp-value]

   esmtp-keyword  = (ALPHA / DIGIT) *(ALPHA / DIGIT / "-")
```

esmtp-값 = 1\*\(%d33-60 / %d62-126\)

- ; "=", SP 및 제어를 제외한 모든 CHAR; 문자. 이 문자열이 이메일 주소인 경우 ; 즉, 메일박스, "xtext" 구문 \[32\] ; 사용되어야한다.\(SHOULD\)

```text
   Keyword        = Ldh-str

   Argument       = Atom

   Domain         = sub-domain *("." sub-domain)

   sub-domain     = Let-dig [Ldh-str]

   Let-dig        = ALPHA / DIGIT

   Ldh-str        = *( ALPHA / DIGIT / "-" ) Let-dig

   address-literal  = "[" ( IPv4-address-literal /
                    IPv6-address-literal /
                    General-address-literal ) "]"
                    ; See Section 4.1.3

   Mailbox        = Local-part "@" ( Domain / address-literal )

   Local-part     = Dot-string / Quoted-string
                  ; MAY be case-sensitive

   Dot-string     = Atom *("."  Atom)

   Atom           = 1*atext

   Quoted-string  = DQUOTE *QcontentSMTP DQUOTE

   QcontentSMTP   = qtextSMTP / quoted-pairSMTP
```

인용된 쌍SMTP = %d92 %d32-126

- ; 즉, 백슬래시 뒤에 ASCII가 옵니다. 그래픽\(자체 포함\) 또는 SPace

qtextSMTP = %d32-33 / %d35-91 / %d93-126

- ; 즉, 인용된 문자열 내에서 any ; ASCII 그래픽 또는 공백이 허용됩니다. 제외하고 검은 슬래시 인용 없이 ; 큰따옴표와 백슬래시 자체.

```text
   String         = Atom / Quoted-string
```

Local-part에 대한 위의 정의는 비교적 허용적이지만 최대 상호 운용성을 위해 메일을 수신할 것으로 예상되는 호스트는 Local-part가 Quoted-string 형식을 요구\(또는 사용\)하거나 Local-part가 대소문자를 사용하는 사서함 정의를 피해야 합니다. - 예민한. 로컬 부분\(예: 특정 메일박스 이름\)을 생성하거나 비교해야 하는 목적을 위해 인용된 모든 양식은 동등하게 취급되어야 하며 전송 시스템은 가능한 최소 인용을 사용하는 양식을 전송해야 합니다\(SHOULD\).\(SHOULD, MUST\)

시스템은 SMTP에서 ASCII가 아닌 문자\(상위 비트가 설정된 옥텟\)의 사용을 요구하는 방식으로 메일함을 정의해서는 안 됩니다.\(MUST NOT\)

1\) 또는 ASCII "제어 문자"\(10진수 값 0-31 및 127\). 이러한 문자는 MAIL 또는 RCPT 명령이나 사서함 이름이 필요한 기타 명령에 사용되어서는 안 됩니다.\(MUST NOT\)

백슬래시 "\"는 다음 문자가 문자 그대로\(일반적인 해석 대신\) 사용됨을 나타내는 데 사용되는 따옴표 문자입니다. 예를 들어, "Joe\,Smith"는 9자로 구성된 단일 사용자 이름 문자열을 나타내며 쉼표는 해당 문자열의 네 번째 문자입니다.

상호 운용성을 촉진하고 이름 지정 및 응용 프로그램에서 DNS의 보수적인 사용에 대한 오랜 지침과 일관성을 유지하기 위해\(예: 기본 DNS 문서 RFC 1035 \[2\]의 섹션 2.3.1 참조\), 알파벳 문자 집합 밖의 문자, 숫자 및 하이픈은 SMTP 클라이언트 또는 서버의 도메인 이름 라벨에 표시되어서는 안 됩니다. 특히 밑줄 문자는 허용되지 않습니다. 유효하지 않은 문자 코드가 사용된 명령을 수신하고 거부할 다른 이유가 없는 SMTP 서버는 501 응답으로 해당 명령을 거부해야 합니다\(다른 규칙과 마찬가지로 이 규칙은 적절한 SMTP 확장으로 재정의될 수 있음\).\(MUST NOT, MUST\)

---
#### **4.1.3.  Address Literals**

때로는 호스트가 도메인 이름 시스템에 알려지지 않아 통신\(특히 오류를 보고하고 복구하기 위한 통신\)이 차단되는 경우가 있습니다. 이 장벽을 우회하기 위해 도메인 이름 대신 특수 문자 형식의 주소가 허용됩니다. IPv4 주소의 경우 이 형식은 점으로 구분되고 \[123.255.37.2\]와 같이 대괄호로 묶인 4개의 작은 십진 정수를 사용합니다. 이는 옥텟 시퀀스 형식의 \(IPv4\) 인터넷 주소를 나타냅니다. IPv6 및 최종적으로 표준화될 다른 주소 지정 형식의 경우, 해당 형식은 관련 표준\(예: RFC\)의 일부로 지정된 형식으로 주소 구문, 콜론 및 주소 자체를 식별하는 표준화된 "태그"로 구성됩니다. IPv6의 경우 4291\[8\]\).

```text
   Specifically:

   IPv4-address-literal  = Snum 3("."  Snum)

   IPv6-address-literal  = "IPv6:" IPv6-addr

   General-address-literal  = Standardized-tag ":" 1*dcontent
```

표준화된 태그 = Ldh-str

- ; 표준화된 태그는 반드시 ; 표준 추적 RFC 및 IANA에 등록됨\(MUST\)

```text
   dcontent       = %d33-90 / ; Printable US-ASCII
                  %d94-126 ; excl. "[", "\", "]"

   Snum           = 1*3DIGIT
                  ; representing a decimal integer
                  ; value in the range 0 through 255

   IPv6-addr      = IPv6-full / IPv6-comp / IPv6v4-full / IPv6v4-comp

   IPv6-hex       = 1*4HEXDIG

   IPv6-full      = IPv6-hex 7(":" IPv6-hex)
```

IPv6-comp = \[IPv6-16진수 \*5\(":" IPv6-16진수\)\] "::"

- \[IPv6-16진수 \*5\(":" IPv6-16진수\)\] ; "::"는 2개 이상의 16비트 그룹을 나타냅니다. 0. 를 제외한 그룹은 6개 이하입니다. "::"이 있을 수 있습니다.

```text
   IPv6v4-full    = IPv6-hex 5(":" IPv6-hex) ":" IPv4-address-literal
```

IPv6v4-comp = \[IPv6-16진수 \*3\(":" IPv6-16진수\)\] "::"

- \[IPv6-16진수 \*3\(":" IPv6-16진수\) ":"\] IPv4-주소-리터럴 ; "::"는 2개 이상의 16비트 그룹을 나타냅니다. 0. 를 제외한 4개 이상의 그룹은 허용되지 않습니다. "::" 및 IPv4-address-literal이 존재할 수 있습니다.

---
#### **4.1.4.  Order of Commands**

이러한 명령을 사용하는 순서에는 제한이 있습니다.

메일 트랜잭션을 포함할 세션은 먼저 EHLO 명령을 사용하여 초기화되어야 합니다. SMTP 서버는 이러한 초기화 없이 메일이 아닌 트랜잭션\(예: VRFY 또는 EXPN\)에 대한 명령을 수락해야 합니다.\(MUST, SHOULD\)

EHLO 명령은 나중에 세션에서 클라이언트에 의해 실행될 수 있습니다. 세션이 시작된 후에 실행되고 EHLO 명령이 SMTP 서버에서 허용되는 경우 SMTP 서버는 모든 버퍼를 지우고 RSET 명령이 실행된 것처럼 정확하게 상태를 재설정해야 합니다. 즉, EHLO 바로 다음에 오는 RSET 시퀀스는 중복되지만 불필요한 명령을 실행하는 데 따른 성능 비용 외에는 해롭지 않습니다.\(MAY, MUST\)

EHLO 명령이 SMTP 서버에서 허용되지 않는 경우 501, 500, 502 또는 550 실패 응답이 적절하게 반환되어야 합니다. 그만큼\(MUST\)

SMTP 서버는 이러한 응답을 전송한 후에도 EHLO를 수신하기 전과 동일한 상태를 유지해야 합니다.\(MUST\)

가능한 경우 SMTP 클라이언트는 EHLO 명령에 대한 도메인 매개변수가 섹션 2.3.5에서 이 명령에 대해 지정된 기본 호스트 이름인지 확인해야 합니다. 이것이 가능하지 않은 경우\(예: 클라이언트의 주소가 동적으로 할당되고 클라이언트에 명확한 이름이 없는 경우\) 도메인 이름을 주소 리터럴로 대체해야 합니다.\(MUST, SHOULD\)

SMTP 서버는 EHLO 명령의 도메인 이름 인수가 실제로 클라이언트의 IP 주소에 해당하는지 확인할 수 있습니다. 그러나 확인이 실패하는 경우 서버는 해당 메시지 수락을 거부해서는 안 됩니다\(MUST NOT\). 확인 시도에서 캡처된 정보는 로깅 및 추적 목적으로 사용됩니다. 이 금지 사항은 매개변수와 해당 IP 주소의 일치에만 적용됩니다. 들어오는 연결이나 메일 메시지 거부에 대한 보다 광범위한 논의는 섹션 7.9를 참조하세요.\(MAY, MUST NOT\)

NOOP, HELP, EXPN, VRFY 및 RSET 명령은 세션 중 언제든지 또는 이전에 세션을 초기화하지 않고도 사용할 수 있습니다. SMTP 서버는 EHLO 명령이 아직 수신되지 않은 경우에도 이를 정상적으로 처리해야 합니다\(즉, 503 코드를 반환하지 않음\). 클라이언트는 이러한 명령을 보내기 전에 EHLO로 세션을 열어야 합니다.\(SHOULD\)

이러한 규칙을 따르면 EXPN 명령에 대한 응답으로 "550 액세스 거부됨"을 표시하는 RFC 821의 예는 EHLO 명령이 EXPN 앞에 오거나 액세스 거부가 클라이언트의 IP 주소 또는 기타 인증을 기반으로 하지 않는 한 올바르지 않습니다. 또는 권한 부여 결정 메커니즘.

MAIL 명령\(또는 더 이상 사용되지 않는 SEND, SOML 또는 SAML 명령\)은 메일 트랜잭션을 시작합니다. 일단 시작된 메일 트랜잭션은 트랜잭션 시작 명령, 하나 이상의 RCPT 명령, DATA 명령의 순서로 구성됩니다. 메일 트랜잭션은 RSET, 새 EHLO 또는 QUIT 명령에 의해 중단될 수 있습니다. 세션에는 0개 이상의 트랜잭션이 있을 수 있습니다. MAIL\(또는 SEND, SOML 또는 SAML\)은 메일 트랜잭션이 이미 열려 있는 경우 전송되어서는 안 됩니다. 즉, 세션에서 메일 트랜잭션이 시작되지 않았거나 이전 트랜잭션이 성공적으로 완료된 경우에만 전송되어야 합니다. DATA 명령 또는 이전 명령이 중단된 경우\(예: RSET 또는 새 EHLO를 사용하여\)\(MUST NOT\)

트랜잭션 시작 명령 인수가 허용되지 않는 경우 501 실패 응답이 반환되어야 하며 SMTP 서버는 동일한 상태를 유지해야 합니다. 트랜잭션의 명령이 서버에서 처리할 수 없을 정도로 순서가 잘못된 경우 503 실패\(MUST\)

응답은 반드시 반환되어야 하며 SMTP 서버는 동일한 상태를 유지해야 합니다.\(MUST\)

세션의 마지막 명령은 QUIT 명령이어야 합니다. QUIT 명령은 세션 열기 명령이 전송 및 수락되지 않은 경우에도 연결 종료를 요청하기 위해 클라이언트 SMTP에서 사용해야 합니다.\(MUST, SHOULD\)

---
#### **4.1.5.  Private-Use Commands**

2.2.2절에 명시된 대로 "X"로 시작하는 명령은 클라이언트\(송신\)와 서버\(수신\) SMTP 에이전트 간의 쌍방 합의에 따라 사용될 수 있습니다. 이러한 명령을 인식하지 못하는 SMTP 서버는 "500 Command not recognition"로 응답할 것으로 예상됩니다. 확장된 SMTP 서버는 EHLO 명령에 대한 응답으로 이러한 개인 명령과 관련된 기능 이름을 나열할 수 있습니다.\(MAY\)

"X"로 시작하지 않는 SMTP 시스템에서 보내거나 수락하는 명령은 섹션 2.2.2의 요구 사항을 준수해야 합니다.\(MUST\)

---
### **4.2.  SMTP Replies**

SMTP 명령에 대한 응답은 메일 전송 과정에서 요청과 작업의 동기화를 보장하고 SMTP 클라이언트가 항상 SMTP 서버의 상태를 알 수 있도록 보장하는 역할을 합니다. 모든 명령은 정확히 하나의 응답을 생성해야 합니다.\(MUST\)

명령-응답 시퀀스의 세부 사항은 섹션 4.3에 설명되어 있습니다.

SMTP 응답은 이 문서에서 달리 지정하지 않는 한 3자리 숫자\(3자리 숫자로 전송됨\)와 그 뒤에 오는 일부 텍스트로 구성됩니다. 이 숫자는 오토마타가 다음에 어떤 상태로 들어갈지 결정하는 데 사용됩니다. 텍스트는 인간 사용자를 위한 것입니다. 세 자리 숫자에는 SMTP 클라이언트가 텍스트를 검사할 필요가 없으며 필요에 따라 해당 텍스트를 삭제하거나 사용자에게 전달할 수 있을 정도로 인코딩된 정보가 충분히 포함되어 있습니다. 예외는 이 문서의 다른 부분에 명시된 바와 같습니다. 특히 220, 221, 251, 421 및 551 응답 코드는 기계가 구문 분석하고 해석해야 하는 메시지 텍스트와 연관되어 있습니다. 일반적인 경우 텍스트는 수신자 및 상황에 따라 달라질 수 있으므로 각 응답 코드에 대해 다양한 텍스트가 있을 수 있습니다. 응답 코드 이론에 대한 논의는 섹션 4.2.1에 나와 있습니다. 공식적으로 응답은 세 자리 코드, <SP\>, 한 줄의 텍스트, <CRLF\> 또는 여러 줄의 응답\(동일 섹션에 정의됨\)의 순서로 정의됩니다. 이 사양을 위반하면 텍스트가 전송되지 않는 경우가 있으므로 텍스트를 받지 못한 클라이언트는 \(후행 공백 문자 유무에 관계없이\) 코드만 처리할 준비를 해야 합니다. EHLO, EXPN 및 HELP 명령만 정상적으로 여러 줄로 응답할 것으로 예상됩니다.\(SHOULD\)

상황; 그러나 모든 명령에 대해 여러 줄 응답이 허용됩니다.

ABNF에서 서버 응답은 다음과 같습니다.

```text
   Greeting       = ( "220 " (Domain / address-literal)
                  [ SP textstring ] CRLF ) /
                  ( "220-" (Domain / address-literal)
                  [ SP textstring ] CRLF
                  *( "220-" [ textstring ] CRLF )
                  "220" [ SP textstring ] CRLF )

   textstring     = 1*(%d09 / %d32-126) ; HT, SP, Printable US-ASCII

   Reply-line     = *( Reply-code "-" [ textstring ] CRLF )
                  Reply-code [ SP textstring ] CRLF

   Reply-code     = %x32-35 %x30-35 %x30-39
```

여기서 "인사말"은 서버가 연결의 일부를 열고 있음을 알리는 220 응답에만 나타납니다. \(접속시 가능한 다른 서버 응답은 Reply-line 구문을 따릅니다.\)

SMTP 서버는 이 문서에 나열된 응답 코드만 보내야 합니다. SMTP 서버는 필요할 때마다 예제에 표시된 텍스트를 사용해야 합니다.\(SHOULD, SHOULD\)

SMTP 클라이언트는 텍스트가 아닌 응답 코드에 의해서만 작업을 결정해야 합니다\("주소 변경" 251 및 551 및 필요한 경우 220, 221 및 421 응답 제외\). 일반적인 경우에는 텍스트가 전혀 없는 경우를 포함하여\(발신자가 베어 코드를 보내서는 안 됨\) 모든 텍스트를 허용해야 합니다\(MUST\). 응답 코드 뒤의 공백\(공백\)은 텍스트의 일부로 간주됩니다. 가능할 때마다 수신자 SMTP는 응답 코드의 첫 번째 숫자\(심각도 표시\)를 테스트해야 합니다.\(MUST, SHOULD\)

아래에 나타나는 코드 목록은 영구적인 것으로 해석되어서는 안 됩니다. 새로운 코드를 추가하는 것은 드물고 중요한 활동이어야 하며 응답의 텍스트 부분에 있는 추가 정보가 선호되는 반면, 새로운 표준 또는 표준-트랙 사양의 결과로 새로운 코드가 추가될 수 있습니다. 결과적으로, sender-SMTP는 이 문서에 지정되지 않은 코드를 처리하기 위해 준비되어야 하며 첫 번째 숫자만 해석하여 처리해야 합니다.\(MUST NOT, MUST\)

클라이언트와 협상된 확장이 없는 경우 SMTP 서버는 첫 번째 숫자가 2, 3, 4가 아닌 응답 코드를 보내서는 안 됩니다.\(MUST NOT\)

또는 5. 범위를 벗어난 코드를 수신한 클라이언트는 일반적으로 이를 치명적인 오류로 처리하고 메일 거래를 종료해야 합니다.\(SHOULD\)

---
#### **4.2.1.  Reply Code Severities and Theory**

답변의 세 자리 숫자는 각각 특별한 의미를 갖습니다. 첫 번째 숫자는 응답이 좋은지, 나쁜지, 불완전한지를 나타냅니다. 복잡하지 않은 SMTP 클라이언트 또는 예상치 못한 코드를 받은 클라이언트는 이 첫 번째 숫자를 검사하여 다음 작업\(계획대로 진행, 다시 실행, 축소 등\)을 결정할 수 있습니다. 어떤 종류의 오류가 발생했는지\(예: 메일 시스템 오류, 명령 구문 오류\) 대략 알고 싶은 SMTP 클라이언트는 두 번째 숫자를 검사할 수 있습니다. 세 번째 숫자와 존재할 수 있는 추가 정보는 가장 미세한 정보 등급을 위해 예약되어 있습니다.

응답 코드의 첫 번째 숫자에는 네 가지 값이 있습니다.

2yz 긍정적인 완료 답변

- 요청한 작업이 성공적으로 완료되었습니다. 새로운 요청이 시작될 수 있습니다.

3yz 긍정적 중간 답변

- 명령이 수락되었지만 요청한 작업은 추가 정보 수신을 기다리는 동안 보류 중입니다. SMTP 클라이언트는 이 정보를 지정하는 다른 명령을 보내야 합니다. 이 응답은 명령 시퀀스 그룹\(즉, DATA\)에서 사용됩니다.

4yz 일시적인 부정적인 완료 답변

- 명령이 승인되지 않아 요청한 작업이 발생하지 않았습니다. 그러나 오류 상태는 일시적이므로 작업이 다시 요청될 수 있습니다. 송신자는 명령 시퀀스의 시작 부분\(있는 경우\)으로 돌아가야 합니다. 서로 다른 두 사이트\(수신자 및 발신자 SMTP 에이전트\)가 해석에 동의해야 하는 경우 "일시적"이라는 의미를 할당하기가 어렵습니다. 이 카테고리의 각 응답은 서로 다른 시간 값을 가질 수 있지만 SMTP 클라이언트는 다시 시도해야 합니다. 응답이 4yz 또는 5yz 범주\(아래 참조\)에 적합한지 여부를 결정하는 경험적 규칙은 명령 형식이나 발신자 또는 수신자의 속성\(즉, 명령 형식을 변경하지 않고 반복할 경우 성공할 수 있는 경우 응답이 4yz라는 것입니다. , 명령은 동일하게 반복되며 수신자는 새로운 구현을 제시하지 않습니다.\)\(SHOULD\)

5yz 영구 부정적인 완료 답변

- 명령이 승인되지 않았으며 요청한 작업이 발생하지 않았습니다. SMTP 클라이언트는 정확한 요청을 \(동일한 순서로\) 반복해서는 안 됩니다. 일부 "영구적인" 오류 조건도 수정될 수 있으므로 인간 사용자는 SMTP 클라이언트에 다음을 지시할 수 있습니다.\(SHOULD NOT\)

- 미래의 특정 시점\(예: 철자가 변경되거나 사용자가 계정 상태를 변경한 후\)에 직접 작업을 통해 명령 시퀀스를 다시 시작합니다.

파일 전송 프로토콜\(FTP\)\[34\]이 매우 유사한 코드 아키텍처를 사용하고 SMTP 코드가 FTP 모델을 기반으로 한다는 점은 주목할 가치가 있습니다. 그러나 SMTP는 단일 명령, 단일 응답 모델\(FTP는 비동기식임\)을 사용하며 FTP의 1yz 코드는 SMTP 모델의 일부가 아닙니다.

두 번째 숫자는 특정 카테고리의 응답을 인코딩합니다.

x0z 구문: 이 응답은 구문 오류, 기능 범주에 맞지 않는 구문상 올바른 명령, 구현되지 않거나 불필요한 명령을 나타냅니다.

x1z 정보: 상태나 도움말과 같은 정보 요청에 대한 응답입니다.

x2z 연결: 전송 채널을 참조하는 응답입니다.

```text
   x3z  Unspecified.

   x4z  Unspecified.
```

x5z 메일 시스템: 이 응답은 요청된 전송 또는 기타 메일 시스템 작업에 대한 수신자 메일 시스템의 상태를 나타냅니다.

세 번째 숫자는 두 번째 숫자로 지정된 각 범주에서 더 미세한 의미 등급을 제공합니다. 응답 목록이 이를 보여줍니다. 각 응답 텍스트는 필수가 아닌 권장 사항이며 연결된 명령에 따라 변경될 수도 있습니다. 반면에 응답 코드는 이 섹션의 사양을 엄격하게 따라야 합니다. 수신기 구현은 여기에 설명된 것과 약간 다른 상황에 대한 새로운 코드를 생성해서는 안 되며, 오히려 이미 정의된 코드를 적용해야 합니다.

예를 들어 성공적으로 실행되어도 SMTP 클라이언트에 새로운 정보를 제공하지 않는 NOOP와 같은 명령은 250 응답을 반환합니다. 명령이 구현되지 않은 비사이트 특정 작업을 요청하면 응답은 502입니다. 이에 대한 개선은 구현되었지만 구현되지 않은 매개변수를 요청하는 명령에 대한 504 응답입니다.

응답 텍스트는 한 줄보다 길 수 있습니다. 이러한 경우 SMTP 클라이언트가 언제 응답 읽기를 중지할 수 있는지 알 수 있도록 전체 텍스트를 표시해야 합니다. 여러 줄의 응답을 나타내려면 특별한 형식이 필요합니다.

여러 줄 응답 형식에서는 마지막 줄을 제외한 모든 줄이 응답 코드로 시작하고 바로 뒤에 하이픈 "-"\(빼기라고도 함\), 텍스트가 와야 합니다. 마지막 줄은 응답 코드로 시작하고 바로 뒤에 <SP\>, 선택적으로 일부 텍스트 및 <CRLF\>가 옵니다. 위에서 언급한 것처럼 후속 텍스트가 전송되지 않으면 서버는 <SP\>를 전송해야 하지만 클라이언트는 이를 생략할 수 있도록 준비해야 합니다.\(MUST\)

예를 들어:

250-첫 번째 라인

- 250-두 번째 줄 250-234 숫자로 시작하는 텍스트 250 마지막 줄

여러 줄 응답에서는 각 줄의 응답 코드가 동일해야 합니다. 클라이언트가 이에 의존하는 것이 합리적이므로 다른 모든 코드가 동일하다고 가정하고 모든 줄의 코드를 기반으로 처리 결정을 내릴 수 있습니다. 어떤 경우에는 응답 "텍스트"에 클라이언트에 대한 중요한 데이터가 있습니다. 클라이언트는 현재 상황에서 이러한 사례를 식별할 수 있습니다.\(MUST\)

---
#### **4.2.2.  Reply Codes by Function Groups**

```text
   500  Syntax error, command unrecognized (This may include errors such
      as command line too long)
```

501 매개변수 또는 인수의 구문 오류

```text
   502  Command not implemented (see Section 4.2.4)
```

503 잘못된 명령 순서

```text
   504  Command parameter not implemented
```

211 시스템 상태 또는 시스템 도움말 응답

```text
   214  Help message (Information on how to use the receiver or the
      meaning of a particular non-standard command; this reply is useful
      only to the human user)

   220  <domain> Service ready

   221  <domain> Service closing transmission channel

   421  <domain> Service not available, closing transmission channel
      (This may be a reply to any command if the service knows it must
      shut down)

   250  Requested mail action okay, completed

   251  User not local; will forward to <forward-path> (See Section 3.4)

   252  Cannot VRFY user, but will accept message and attempt delivery
      (See Section 3.5.3)
```

455 서버가 매개변수를 수용할 수 없습니다.

555 MAIL FROM/RCPT TO 매개변수가 인식되지 않거나 구현되지 않았습니다.

```text
   450  Requested mail action not taken: mailbox unavailable (e.g.,
      mailbox busy or temporarily blocked for policy reasons)

   550  Requested action not taken: mailbox unavailable (e.g., mailbox
      not found, no access, or command rejected for policy reasons)
```

451 요청된 작업이 중단되었습니다. 처리 중 오류가 발생했습니다.

```text
   551  User not local; please try <forward-path> (See Section 3.4)

   452  Requested action not taken: insufficient system storage

   552  Requested mail action aborted: exceeded storage allocation

   553  Requested action not taken: mailbox name not allowed (e.g.,
      mailbox syntax incorrect)
```

354 메일 입력 시작; <CRLF\>.<CRLF\>로 끝납니다.

```text
   554  Transaction failed (Or, in the case of a connection-opening
      response, "No SMTP service here")
```

---
#### **4.2.3.  Reply Codes in Numeric Order**

211 시스템 상태 또는 시스템 도움말 응답

```text
   214  Help message (Information on how to use the receiver or the
      meaning of a particular non-standard command; this reply is useful
      only to the human user)

   220  <domain> Service ready

   221  <domain> Service closing transmission channel

   250  Requested mail action okay, completed

   251  User not local; will forward to <forward-path> (See Section 3.4)

   252  Cannot VRFY user, but will accept message and attempt delivery
      (See Section 3.5.3)
```

354 메일 입력 시작; <CRLF\>.<CRLF\>로 끝납니다.

```text
   421  <domain> Service not available, closing transmission channel
      (This may be a reply to any command if the service knows it must
      shut down)

   450  Requested mail action not taken: mailbox unavailable (e.g.,
      mailbox busy or temporarily blocked for policy reasons)
```

451 요청된 작업이 중단되었습니다. 처리 중 로컬 오류가 발생했습니다.

```text
   452  Requested action not taken: insufficient system storage
```

455 서버가 매개변수를 수용할 수 없습니다.

```text
   500  Syntax error, command unrecognized (This may include errors such
      as command line too long)
```

501 매개변수 또는 인수의 구문 오류

```text
   502  Command not implemented (see Section 4.2.4)
```

503 잘못된 명령 순서

```text
   504  Command parameter not implemented

   550  Requested action not taken: mailbox unavailable (e.g., mailbox
      not found, no access, or command rejected for policy reasons)

   551  User not local; please try <forward-path> (See Section 3.4)

   552  Requested mail action aborted: exceeded storage allocation

   553  Requested action not taken: mailbox name not allowed (e.g.,
      mailbox syntax incorrect)

   554  Transaction failed (Or, in the case of a connection-opening
      response, "No SMTP service here")
```

555 MAIL FROM/RCPT TO 매개변수가 인식되지 않거나 구현되지 않았습니다.

---
#### **4.2.4.  Reply Code 502**

응답 코드 502\(명령이 구현되지 않음\)가 다른 코드보다 우선적으로 반환되어야 하는 경우에 대한 질문이 제기되었습니다. 502는 명령이 실제로 SMTP 서버에서 인식되지만 구현되지 않은 경우에 사용해야 합니다. 명령이 인식되지 않으면 코드 500이 반환되어야 합니다. 확장된 SMTP 시스템은 EHLO에 대한 응답으로 502\(또는 500\)개의 응답을 반환하는 기능을 나열해서는 안 됩니다.\(SHOULD, SHOULD, SHOULD, MUST NOT\)

---
#### **4.2.5.  Reply Codes after DATA and the Subsequent <CRLF>.<CRLF>**

DATA 명령이 <CRLF\>.<CRLF\>로 완료된 후 SMTP 서버가 긍정적인 완료 상태\(2yz 코드\)를 반환하면 다음에 대한 책임을 수락합니다.

o 메시지 전달\(수신자 사서함이 있는 경우\) 또는

o 일시적인 문제로 인해 메시지 전달 시도가 실패한 경우

- 조건, 섹션 4.5.4에 지정된 간격으로 합리적인 횟수만큼 배달을 재시도합니다.

o 메시지 전달 시도가 영구적인 문제로 인해 실패한 경우

- 조건 또는 일시적인 조건으로 인해 반복적인 메시지 전달 시도가 실패한 경우 원본 메시지의 보낸 사람에게 적절한 알림을 반환합니다\(SMTP MAIL 명령의 주소 사용\).

DATA 명령이 <CRLF\>.<CRLF\>로 완료된 후 SMTP 서버가 임시 오류 상태\(4yz\) 코드를 반환하면 해당 메시지를 전달하려는 후속 시도를 해서는 안 됩니다. SMTP 클라이언트는 해당 메시지 전달에 대한 책임을 갖고 해당 메시지를 사용자에게 반환하거나 후속 시도를 위해 다시 대기열에 넣을 수 있습니다\(섹션 4.5.4.1 참조\).\(MUST NOT\)

메시지를 보낸 사용자는 영구적인 실패가 해석되는 것처럼 일시적인 실패 상태의 반환\(메일 메시지 등을 통해\)을 배달 불가 표시로 해석할 수 있어야 합니다. 클라이언트 SMTP가 이러한 조건을 성공적으로 처리하면 사용자는 그러한 응답을 받지 못합니다.\(SHOULD\)

DATA 명령이 <CRLF\>.<CRLF\>로 완료된 후 SMTP 서버가 영구 오류 상태\(5yz\) 코드를 반환하면 메시지 전달을 위한 후속 시도를 해서는 안 됩니다. 임시 오류 상태 코드와 마찬가지로 SMTP 클라이언트는 메시지에 대한 책임을 보유하지만 사용자가 메시지와 응답을 검토하고 적절한 개입 없이 동일한 서버로 전달을 다시 시도해서는 안 됩니다.\(MUST NOT, SHOULD\)

---
### **4.3.  Sequencing of Commands and Replies**
---
#### **4.3.1.  Sequencing Overview**

발신자와 수신자 간의 통신은 발신자가 제어하는 ​​교대 대화입니다. 따라서 송신자는 명령을 내리고 수신자는 응답으로 응답합니다. 서비스 확장을 통해 다른 합의가 협상되지 않는 한, 발신자는 추가 명령을 보내기 전에 이 응답을 기다려야 합니다. 중요한 답변 중 하나는 연결 인사말입니다. 일반적으로 수신자는 연결이 완료되면 220 "서비스 준비" 응답을 보냅니다. 발신자는 명령을 보내기 전에 이 인사말 메시지를 기다려야 합니다.\(MUST, SHOULD\)

참고: 모든 인사말 유형 응답에는 응답 코드 다음의 첫 번째 단어로 서버 호스트의 공식 이름\(정규화된 기본 도메인 이름\)이 있습니다. 때로는 호스트에 의미 있는 이름이 없을 수도 있습니다. 이러한 상황에서의 대안에 대한 논의는 섹션 4.1.3을 참조하십시오.

예를 들어,

```text
      220 ISIF.USC.EDU Service ready

   or

      220 mail.example.com SuperSMTP v 6.1.2 Service ready

   or

      220 [10.0.0.1] Clueless host service ready
```

아래 표에는 각 명령에 대한 대체 성공 및 실패 응답이 나열되어 있습니다. 이 사항은 엄격하게 준수되어야 합니다. 수신기는 다음과 같습니다.\(SHOULD, MAY\)

응답의 텍스트를 대체하지만 코드 번호와 특정 명령 응답 순서에 의해 암시되는 의미와 동작은 보존되어야 합니다.\(MUST\)

---
#### **4.3.2.  Command-Reply Sequences**

각 명령은 일반적인 가능한 응답과 함께 나열됩니다. 가능한 응답 앞에 사용되는 접두사는 중간의 경우 "I", 성공의 경우 "S", 오류의 경우 "E"입니다. 일부 서버는 특별한 상황에서 다른 응답을 생성할 수 있고 향후 확장을 허용하기 때문에 가능한 경우 SMTP 클라이언트는 응답의 첫 번째 숫자만 해석해야 하며 첫 번째 숫자만 해석하여 인식할 수 없는 응답 코드를 처리할 준비를 해야 합니다\(MUST\). 섹션 2.2에 설명된 메커니즘을 사용하여 확장되지 않는 한, SMTP 서버는 3자리 이외의 숫자 또는 2\~5 사이의 숫자로 시작하지 않는 응답 코드를 SMTP 클라이언트에 전송해서는 안 됩니다.\(MUST, MUST NOT\)

이러한 순서 규칙과 원칙적으로 코드 자체는 서버에서 제공하는 SMTP 확장에 의해 확장되거나 수정될 수 있으며 클라이언트에서 수락\(요청\)될 수 있습니다. 그러나 목표가 완전히 새로운 목적을 위한 코드보다는 코드의 더 정확한 입도인 경우 RFC 3463 \[25\]에 설명된 시스템을 새로운 코드의 발명보다 우선적으로 사용해야 합니다.\(SHOULD\)

아래 나열된 코드 외에도 모든 SMTP 명령은 해당하는 비정상적인 상황이 발생할 경우 다음 코드 중 하나를 반환할 수 있습니다.

500 "명령줄이 너무 깁니다"의 경우 또는 명령 이름이 인식되지 않는 경우입니다. 이러한 명령의 필수 하위 집합에 대한 응답으로 "명령이 인식되지 않음" 오류가 발생하는 것은 이 사양을 위반하는 것입니다. 마찬가지로, 512자보다 짧은 명령줄에 대해 "명령이 너무 깁니다" 메시지를 생성하는 것은 섹션 4.5.3.1.4의 조항을 위반하는 것입니다.

501 명령 또는 인수에 구문 오류가 있습니다. 향후 확장을 제공하기 위해 이 문서에서 인수를 허용하지 않는 것으로 지정된 명령\(DATA, RSET, QUIT\)은 EHLO 광고 확장이 없을 때 인수가 제공되면 501 메시지를 반환해야 합니다.\(SHOULD\)

421 서비스 종료 및 전송 채널 폐쇄

```text
   Specific sequences are:

      CONNECTION ESTABLISHMENT

         S: 220
         E: 554
```

- EHLO 또는 HELO

```text
         S: 250
         E: 504 (a conforming implementation could return this code only
         in fairly obscure cases), 550, 502 (permitted only with an old-
         style server that does not support EHLO)

      MAIL

         S: 250
         E: 552, 451, 452, 550, 553, 503, 455, 555

      RCPT
```

- S: 250, 251\(그러나 251 및 551에 대한 논의는 섹션 3.4 참조\) E: 550, 551, 552, 553, 450, 451, 452, 503, 455, 555

```text
      DATA

         I: 354 -> data -> S: 250

                           E: 552, 554, 451, 452

                           E: 450, 550 (rejections for policy reasons)

         E: 503, 554

      RSET

         S: 250

      VRFY

         S: 250, 251, 252
         E: 550, 551, 553, 502, 504

      EXPN

         S: 250, 252
         E: 550, 500, 502, 504

      HELP

         S: 211, 214
         E: 502, 504

      NOOP

         S: 250

      QUIT

         S: 221
```

---
### **4.4.  Trace Information**

SMTP 서버가 전달 또는 추가 처리를 위해 메시지를 수신하면 섹션 4.1.1.4에 설명된 대로 메시지 내용 시작 부분에 추적\("타임 스탬프" 또는 "수신"\) 정보를 삽입해야 합니다.\(MUST\)

이 줄은 다음과 같이 구성되어야 합니다.\(MUST\)

o SMTP 환경에서 제공되어야 하는 FROM 절은 \(1\) EHLO 명령에 표시된 소스 호스트의 이름과 \(2\) EHLO 명령에서 결정된 소스의 IP 주소를 포함하는 주소 리터럴을 모두 포함해야 합니다. TCP 연결.\(MUST\)

o ID 절에는 RFC 822에 제안된 대로 "@"이 포함될 수 있지만 필수는 아닙니다.\(MAY\)

o FOR 절이 나타나면 여러 RCPT 명령이 제공된 경우에도 정확히 하나의 <path\> 항목을 포함해야 합니다. 여러 <path\>는 일부 보안 문제를 일으키므로 더 이상 사용되지 않습니다. 섹션 7.2를 참조하세요.\(MUST\)

인터넷 메일 프로그램은 이전에 메시지 헤더 섹션에 추가된 수신: 행을 변경하거나 삭제해서는 안 됩니다. SMTP 서버는 메시지 앞에 수신 행을 추가해야 합니다. 기존 라인의 순서를 변경하거나 수신 라인을 다른 위치에 삽입해서는 안 됩니다.\(MUST NOT, MUST NOT\)

인터넷이 성장함에 따라 문제, 특히 느린 릴레이를 감지하는 데 수신 헤더 필드의 비교 가능성이 중요합니다. 수신 헤더 필드를 생성하는 SMTP 서버는 모든 유형의 시간대 이름이 아닌 날짜\(예: -0800\)에 명시적인 오프셋을 사용해야 합니다. 가능하다면 UT 대신 현지 시간\(오프셋 포함\)을 사용해야 합니다. 이 공식을 사용하면 지역 상황에 대해 약간 더 많은 정보를 지정할 수 있습니다. UT가 필요한 경우,\(SHOULD, SHOULD\)

수신자는 값을 변환하기 위해 간단한 산술 연산만 수행하면 됩니다. UT를 사용하면 서버의 시간대 위치에 대한 정보가 손실됩니다. 시간대 이름을 제공하려면 주석에 포함해야 합니다.\(SHOULD\)

배달 SMTP 서버가 메시지를 "최종 배달"할 때 메일 데이터 시작 부분에 반환 경로 줄을 삽입합니다. 이러한 return-path 사용은 필수입니다. 메일 시스템은 이를 지원해야 합니다. return-path 줄은 MAIL 명령의 <reverse-path\>에 있는 정보를 유지합니다. 여기서 최종 전달은 메시지가 SMTP 환경을 떠났다는 것을 의미합니다. 일반적으로 이는 대상 사용자 또는 관련 메일 드롭으로 전달되었음을 의미하지만 경우에 따라 다른 메일 시스템에서 추가 처리 및 전송될 수 있습니다.\(MUST\)

예를 들어 오류 응답이 메시지 보낸 사람이 아닌 특수 오류 처리 사서함으로 전달되는 경우 반환 경로의 사서함이 실제 보낸 사람의 사서함과 다를 수 있습니다. 메일링 목록이 관련된 경우 이러한 배열은 메시지 작성자가 아닌 목록 관리자에게 오류를 전달하는 수단으로 일반적이고 유용합니다.

위의 텍스트는 최종 메일 데이터가 반환 경로 줄로 시작하고 그 뒤에 하나 이상의 타임스탬프 줄이 따른다는 것을 의미합니다. 이 줄 뒤에는 나머지 메일 데이터가 옵니다. 먼저 메일 헤더 섹션의 잔액과 본문\(RFC 5322 \[4\]\)이 표시됩니다.

메시지 전달이 승인된 후에 전달이나 다른 작업이 발생할 수 있으므로 SMTP 서버가 최종 전달 중인지 여부를 결정하기 어려운 경우가 있습니다. 결과적으로, 추가\(전달, 게이트웨이 또는 중계\) 시스템은 반환 경로를 제거하고 필요에 따라 MAIL 명령을 다시 작성하여 전달된 메시지에 그러한 줄이 정확히 하나만 나타나도록 할 수 있습니다.\(MAY\)

메시지 발신 SMTP 시스템은 Return-path 헤더 필드가 이미 포함된 메시지를 보내서는 안 됩니다. 중계 기능을 수행하는 SMTP 서버는 메시지 데이터를 검사해서는 안 되며, 특히 Return-path 헤더 필드가 있는지 확인하는 데 필요한 정도까지 검사해서는 안 됩니다. 최종 전달을 수행하는 SMTP 서버는 자신의 항목을 추가하기 전에 Return-path 헤더 필드를 제거할 수 있습니다.\(SHOULD NOT, MUST NOT, MAY\)

Return-path의 주요 목적은 배달 불가 또는 기타 메일 시스템 오류를 나타내는 메시지가 전송될 주소를 지정하는 것입니다. 이를 명확하게 하려면 메시지가 전달될 때 정확히 하나의 반환 경로가 있어야 합니다. 비SMTP 전송과 함께 RFC 822 구문을 사용하는 시스템은 오류 보고서\(예: 배달 불가 메시지\)가 전송되어야 하는 전송 봉투와 관련된 명확한 주소를 지정해야 합니다.\(SHOULD, SHOULD\)

역사적 참고 사항: 반환 경로 헤더 필드\(또는 MAIL 명령의 봉투 역방향 경로 주소\)를 오류 메시지의 대상으로 사용하는 것과 모순되는 것처럼 보이는 RFC 822의 텍스트는 인터넷에 적용할 수 없습니다. 역방향 경로 주소\(반환 경로에 복사됨\)는 배달 오류 메시지가 포함된 모든 메일의 대상으로 사용해야 합니다.\(MUST\)

특히: o SMTP -\> 다른 곳의 게이트웨이는 "다른 곳" 전송도 인터넷 도메인 주소를 사용하고 봉투 보낸 사람 주소를 별도로 유지한다는 것이 알려지지 않은 한 반환 경로 헤더 필드를 삽입해야 합니다.\(SHOULD\)

o 다른 곳의 게이트웨이 -\> SMTP는 메시지에 있는 모든 반환 경로 헤더 필드를 삭제해야 하며 해당 정보를 SMTP 봉투에 복사하거나 다른 전송 시스템의 봉투에 있는 정보와 결합하여 역방향 경로 인수를 구성해야 합니다. SMTP 봉투의 MAIL 명령에.\(SHOULD\)

서버는 메일 데이터 표시 종료 이후의 처리가 부분적으로만 성공한 경우를 특별 처리해야 합니다. 이는 여러 수신자와 메일 데이터를 승인한 후 SMTP 서버가 메일 데이터가 수신자 전부가 아닌 일부에게 성공적으로 전달되었음을 발견한 경우 발생할 수 있습니다. 이러한 경우 DATA 명령에 대한 응답은 OK 응답이어야 합니다. 그러나 SMTP 서버는 "배달할 수 없는 메일" 알림 메시지를 작성하여 메시지 발신자에게 보내야 합니다.\(MUST, MUST\)

실패한 수신자를 모두 나열하는 단일 알림 또는 실패한 각 수신자에 대해 별도의 알림 메시지를 보내야 합니다. 발신자의 처리 효율성을 위해 가능하면 전자를 사용해야 합니다. 별칭 처리\(섹션 3.9.1\)와 전달\(이 하위 섹션\) 간의 주요 차이점은 이 경우 역방향 지정 주소가 변경된다는 것입니다. 배달할 수 없는 메일에 대한 모든 알림 메시지는 MAIL 명령을 사용하여 전송되어야 하며\(더 이상 사용되지 않는 SEND, SOML 또는 SAML 명령을 처리한 결과인 경우에도\) 섹션 3.6에 설명된 대로 null 반환 경로를 사용해야 합니다.\(MUST, SHOULD, MUST\)

타임스탬프 줄과 반환 경로 줄은 공식적으로 다음과 같이 정의됩니다\("FWS" 및 "CFWS"에 대한 정의는 RFC 5322 \[4\]에 나타남\).

```text
   Return-path-line  = "Return-Path:" FWS Reverse-path <CRLF>

   Time-stamp-line  = "Received:" FWS Stamp <CRLF>
```

스탬프 = 도메인별 Opt-info \[CFWS\] ";"

- FWS 날짜-시간 ; 여기서 "날짜-시간"은 RFC 5322 \[4\]에 정의되어 있습니다. 그러나 "obs-" 형식, 특히 두 자리 숫자 ; 년은 SMTP에서 금지되어 있으므로 사용해서는 안 됩니다.\(MUST NOT\)

```text
   From-domain    = "FROM" FWS Extended-Domain

   By-domain      = CFWS "BY" FWS Extended-Domain

   Extended-Domain  = Domain /
                    ( Domain FWS "(" TCP-info ")" ) /
                    ( address-literal FWS "(" TCP-info ")" )
```

TCP-info = 주소-리터럴 / \(도메인 FWS 주소-리터럴\) ; TCP 연결에서 서버에 의해 파생된 정보; 클라이언트 EHLO가 아닙니다.

```text
   Opt-info       = [Via] [With] [ID] [For]
                  [Additional-Registered-Clauses]

   Via            = CFWS "VIA" FWS Link

   With           = CFWS "WITH" FWS Protocol

   ID             = CFWS "ID" FWS ( Atom / msg-id )
                  ; msg-id is defined in RFC 5322 [4]

   For            = CFWS "FOR" FWS ( Path / Mailbox )
```

추가 등록 조항 = CFWS Atom FWS 문자열

- ; 여기에는 추가적인 표준 조항이 추가될 수 있습니다. 미래 표준에 따른 위치 및 등록 ; IANA. SMTP 서버는 등록되지 않은 ; 이름. 섹션 8을 참조하세요.\(SHOULD NOT\)

```text
   Link           = "TCP" / Addtl-Link
```

Addtl-Link = Atom

- ; 링크의 추가 표준 이름은 ; 인터넷 할당 번호에 등록되어 있습니다. 권한\(IANA\). "경유"는 주로 가치가 있습니다. 인터넷이 아닌 전송으로. SMTP 서버 ; 등록되지 않은 이름을 사용하면 안 됩니다.\(SHOULD NOT\)

```text
   Protocol       = "ESMTP" / "SMTP" / Attdl-Protocol
```

Attdl-프로토콜 = Atom

- ; 프로토콜의 추가 표준 이름은 ; 인터넷 할당 번호에 등록되어 있습니다. "메일 매개변수"의 권한\(IANA\) ; 레지스트리 \[9\]. SMTP 서버는 절대로 해서는 안 됩니다. 등록되지 않은 이름을 사용하세요.\(SHOULD NOT\)

---
### **4.5.  Additional Implementation Issues**
---
#### **4.5.1.  Minimum Implementation**

SMTP를 작동 가능하게 만들려면 모든 수신자가 다음과 같은 최소 구현을 제공해야 합니다. 이 사양을 준수하려면 다음 명령이 지원되어야 합니다.\(MUST, MUST\)

```text
      EHLO
      HELO
      MAIL
      RCPT
      DATA
      RSET
      NOOP
      QUIT
      VRFY
```

메일 중계 또는 전달을 지원하는 SMTP 서버를 포함하는 모든 시스템은 대소문자를 구분하지 않는 로컬 이름으로 예약된 사서함 "postmaster"를 지원해야 합니다. 서버가 연결을 열 때 항상 554를 반환하는 경우\(섹션 3.1에 설명된 대로\) 이 포스트마스터 주소는 꼭 필요한 것은 아닙니다. 포스트마스터에 대한 메일을 수락해야 한다는 요구 사항은 SMTP 서버가 메일 서비스를 제공하는 모든 도메인에서 포스트마스터의 사서함을 지정하는 RCPT 명령과 "RCPT TO:<Postmaster\>"\(도메인 없음\)의 특수한 경우를 의미합니다. 사양\)이 지원되어야 합니다.\(MUST, MUST\)

SMTP 시스템은 인터넷의 다른 시스템에서 Postmaster로 전달되는 메일을 수락하기 위해 모든 합리적인 노력을 다해야 합니다. 서비스 거부 공격이나 기타 보안 위반을 포함하는 극단적인 경우에는 SMTP 서버가 Postmaster로 전달되는 메일을 차단할 수 있습니다. 그러나 그러한 배열은 그러한 공격의 일부가 아닌 메시지를 차단하지 않도록 좁게 조정되어야 합니다.\(SHOULD\)

---
#### **4.5.2.  Transparency**

데이터 투명성을 위한 규정이 없으면 문자 시퀀스 "<CRLF\>.<CRLF\>"는 메일 텍스트를 끝내고 사용자가 보낼 수 없습니다. 일반적으로 사용자는 이러한 "금지된" 시퀀스를 인식하지 못합니다. 사용자가 작성한 모든 텍스트를 투명하게 전송하려면 다음 절차를 사용합니다.

o 메일 텍스트 한 줄을 보내기 전에 SMTP 클라이언트는 해당 줄의 첫 번째 문자를 확인합니다. 마침표인 경우 줄 시작 부분에 마침표가 하나 더 삽입됩니다.

o SMTP 서버가 메일 텍스트 한 줄을 받으면 해당 줄을 확인합니다. 행이 단일 마침표로 구성된 경우 메일 끝 표시기로 처리됩니다. 첫 번째 문자가 마침표이고 줄에 다른 문자가 있으면 첫 번째 문자가 삭제됩니다.

메일 데이터에는 128개의 ASCII 문자가 포함될 수 있습니다. 공백, 수직 및 수평 탭, 기타 제어 문자를 포함한 모든 문자는 수신자의 사서함으로 전달됩니다. 전송 채널이 8비트 바이트\(옥텟\) 데이터 스트림을 제공하는 경우 7비트 ASCII 코드는 옥텟에서 오른쪽 정렬되어 전송되며 상위 비트는 0으로 지워집니다. 중계 기능을 제공하는 SMTP 시스템에서 이러한 조건을 특별하게 처리하려면 섹션 3.6을 참조하세요.

일부 시스템에서는 데이터가 수신되고 저장될 때 데이터를 변환해야 할 수도 있습니다. 이는 ASCII가 아닌 다른 문자 세트를 로컬 문자 세트로 사용하거나 문자열이 아닌 레코드에 데이터를 저장하거나 특수 문자 시퀀스를 메일함 내부의 구분 기호로 사용하는 호스트에 필요할 수 있습니다. 그러한 변환이 필요한 경우, 특히 중계되는 메일에 적용되는 경우에는 되돌릴 수 있어야 합니다.\(MUST\)

---
#### **4.5.3.  Sizes and Timeouts**
---
##### **4.5.3.1.  Size Limits and Minimums**

최소/최대 크기가 필요한 여러 개체가 있습니다. 모든 구현은 최소한 이러한 크기의 객체를 수신할 수 있어야 합니다\(MUST\). 이 크기보다 큰 물체는 가능하면 피해야 합니다. 그러나 인코딩된 X.400 주소\(RFC 2156 \[35\]\)와 같은 일부 인터넷 메일 구성에는 더 큰 개체가 필요한 경우가 많습니다. 클라이언트는 이를 전송하려고 시도할 수 있지만 서버가 처리할 수 없는 경우 서버가 이를 거부할 수 있도록 준비해야 합니다. 가능한 한 최대로 이러한 객체의 길이에 제한을 두지 않는 구현 기술을 사용해야 합니다.\(MUST, SHOULD, MUST\)

SMTP 확장에는 각각 단일 옥텟 이상을 차지하는 문자의 사용이 포함될 수 있습니다. 따라서 이 섹션에서는 문자 수가 아닌 절대 길이가 필요한 경우 길이를 옥텟으로 지정합니다.

---
###### **4.5.3.1.1.  Local-part**

사용자 이름 또는 기타 로컬 부분의 최대 총 길이는 64옥텟입니다.

---
###### **4.5.3.1.2.  Domain**

도메인 이름 또는 번호의 최대 총 길이는 255옥텟입니다.

---
###### **4.5.3.1.3.  Path**

역방향 경로 또는 정방향 경로의 최대 총 길이는 256옥텟\(구두점 및 요소 구분 기호 포함\)입니다.

---
###### **4.5.3.1.4.  Command Line**

명령 단어와 <CRLF\>를 포함한 명령줄의 최대 총 길이는 512 옥텟입니다. 이 제한을 늘리려면 SMTP 확장을 사용할 수 있습니다.

---
###### **4.5.3.1.5.  Reply Line**

응답 코드와 <CRLF\>를 포함한 응답 줄의 최대 총 길이는 512옥텟입니다. 더 많은 정보는 여러 줄의 답변을 통해 전달될 수 있습니다.

---
###### **4.5.3.1.6.  Text Line**

<CRLF\>를 포함한 텍스트 줄의 최대 총 길이는 1000옥텟입니다\(투명성을 위해 중복된 선행 점은 계산하지 않음\). 이 숫자는 SMTP 서비스 확장을 사용하여 늘어날 수 있습니다.

---
###### **4.5.3.1.7.  Message Content**

메시지 콘텐츠\(메시지 헤더 섹션과 메시지 본문 포함\)의 최대 총 길이는 최소 64K 옥텟이어야 합니다. 멀티미디어 메일에 대한 인터넷 표준\(RFC 2045 \[21\]\)이 도입된 이후 인터넷의 메시지 길이는 극적으로 늘어났으며 가능하면 메시지 크기 제한을 피해야 합니다. 제한을 적용해야 하는 SMTP 서버 시스템은 RFC 1870\[10\]의 "SIZE" 서비스 확장을 구현해야 하며, 대용량 메시지를 보내는 SMTP 클라이언트 시스템은 가능하면 이를 활용해야 합니다.\(MUST, SHOULD\)

---
###### **4.5.3.1.8.  Recipients Buffer**

버퍼링해야 하는 최소 총 수신자 수는 100명입니다. 100개 미만의 RCPT 명령으로 메시지를 거부하는 것은\(수신자가 너무 많은 경우\) 이 사양을 위반하는 것입니다. 중계 SMTP 서버는 절대 안 되고, 배달 SMTP 서버는 메시지 헤더 필드에 대한 유효성 검사 테스트를 수행하면 안 된다는 일반 원칙은 헤더 필드에 표시된 총 수신자 수를 기준으로 메시지를 거부해서는 안 된다는 것을 의미합니다. 수신자 수에 제한을 가하는 서버는 이전에 수락한 주소를 자동으로 삭제하는 대신 제한을 초과하는 추가 주소를 거부하는 등 질서 있는 방식으로 작동해야 합니다. 100개 이상의 RCPT 명령이 포함된 메시지를 전달해야 하는 클라이언트는 서버가 단일 메시지에서 100명 이상의 수신자를 수락하는 것을 거부하는 경우 100명의 수신자 "청크"로 전송할 준비를 해야 합니다.\(MUST, MUST NOT, MUST, SHOULD\)

---
###### **4.5.3.1.9.  Treatment When Limits Exceeded**

이러한 제한 초과로 인한 오류는 응답 코드를 사용하여 보고될 수 있습니다. 응답 코드의 몇 가지 예는 다음과 같습니다.

```text
      500 Line too long.

   or

      501 Path too long

   or

      452 Too many recipients (see below)

   or

      552 Too much mail data.
```

---
###### **4.5.3.1.10.  Too Many Recipients Code**

RFC 821 \[1\]은 SMTP 서버가 RCPT 명령 수에 대한 구현 제한\("수신자가 너무 많음"\)을 소진하는 오류를 응답 코드 552로 잘못 나열했습니다. 이 조건에 대한 올바른 응답 코드는 452입니다. 클라이언트는 552 코드는 이 경우 영구적이 아닌 일시적인 오류이므로 아래 논리가 작동합니다.\(SHOULD\)

규격을 준수하는 SMTP 서버가 이 조건에 직면하면 수신자 버퍼에 최소 100개의 성공적인 RCPT 명령이 있습니다. 서버가 메시지를 수락할 수 있다면 최소한 이 100개는

주소는 SMTP 클라이언트의 대기열에서 제거됩니다. 클라이언트가 452개의 응답을 받은 주소의 재전송을 시도하면 이들 중 최소 100개가 SMTP 서버의 수신자 버퍼에 들어갈 수 있습니다. 무엇이든 전달할 수 있는 각 재전송 시도는 이러한 수신자 중 최소 100명을 처리할 수 있습니다.

SMTP 서버에 RCPT 명령 수에 대한 구현 제한이 있고 이 제한이 소진된 경우 응답 코드 452를 사용해야 합니다\(그러나 위에서 언급한 것처럼 클라이언트도 552에 대비해야 합니다\). 서버에 RCPT 명령 수에 대해 구성된 사이트 정책 제한이 있는 경우 대신 5yz 응답 코드를 사용할 수 있습니다. 특히 특정 메일 트랜잭션에서 수신자 수를 단순히 제한하는 것이 아니라 사이트에서 지정한 수신자 수보다 많은 메시지를 금지하려는 의도가 있는 경우 이후에 수신되는 모든 DATA 명령에 대해 503 응답을 반환하는 것이 합리적입니다. 452\(또는 552\) 코드로 변경하거나 이전 부정적인 응답을 반환하지 않고 DATA 뒤에 503을 반환합니다.\(MUST, MAY\)

---
##### **4.5.3.2.  Timeouts**

SMTP 클라이언트는 시간 초과 메커니즘을 제공해야 합니다. 전체 메일 트랜잭션의 시간을 측정하는 대신 명령별 시간 초과를 사용해야 합니다. 시간 초과는 가급적이면 SMTP 코드를 다시 컴파일하지 않고도 쉽게 재구성할 수 있어야 합니다. 이를 구현하기 위해 각 SMTP 명령과 데이터 전송의 각 버퍼에 대해 타이머가 설정됩니다. 후자는 전체 시간 초과가 본질적으로 메시지 크기에 비례한다는 것을 의미합니다.\(MUST, MUST, SHOULD\)

바쁜 메일 릴레이 호스트에 대한 광범위한 경험을 바탕으로 명령당 최소 시간 초과 값은 다음과 같아야 합니다.\(SHOULD\)

---
###### **4.5.3.2.1.  Initial 220 Message: 5 Minutes**

SMTP 클라이언트 프로세스는 실패한 TCP 연결과 초기 220 인사말 메시지 수신 지연을 구별해야 합니다. 많은 SMTP 서버는 TCP 연결을 허용하지만 시스템 로드가 더 많은 메일 처리를 허용할 때까지 220 메시지 전달을 지연합니다.

---
###### **4.5.3.2.2.  MAIL Command: 5 Minutes**
---
###### **4.5.3.2.3.  RCPT Command: 5 Minutes**

메시지가 승인될 때까지 메일링 목록 및 별칭 처리가 지연되지 않으면 더 긴 시간 제한이 필요합니다.

---
###### **4.5.3.2.4.  DATA Initiation: 2 Minutes**

이는 DATA 명령에 대한 "354 시작 입력" 응답을 기다리는 동안입니다.

---
###### **4.5.3.2.5.  Data Block: 3 Minutes**

이는 데이터 청크를 전송하는 각 TCP SEND 호출이 완료되기를 기다리는 동안입니다.

---
###### **4.5.3.2.6.  DATA Termination: 10 Minutes.**

"250 OK" 응답을 기다리는 동안입니다. 수신자는 메시지 데이터를 종료하는 마지막 기간을 얻으면 일반적으로 메시지를 사용자 사서함으로 전달하기 위한 처리를 수행합니다. 이 시점에서 허위 시간 초과는 매우 낭비적이며 일반적으로 메시지가 성공적으로 전송되었고 서버가 배달 책임을 수락했기 때문에 메시지의 여러 복사본이 배달되는 결과를 낳습니다. 추가 논의는 섹션 6.1을 참조하십시오.

---
###### **4.5.3.2.7.  Server Timeout: 5 Minutes.**

SMTP 서버는 발신자의 다음 명령을 기다리는 동안 최소 5분의 시간 제한을 가져야 합니다.\(SHOULD\)

---
#### **4.5.4.  Retry Strategies**

호스트 SMTP 구현의 일반적인 구조에는 사용자 메일함, 전송 중인 메시지를 큐에 넣기 위한 하나 이상의 영역, 메일을 보내고 받기 위한 하나 이상의 데몬 프로세스가 포함됩니다. 정확한 구조는 호스트 사용자의 요구사항과 호스트가 지원하는 메일링 리스트의 수와 크기에 따라 달라집니다. 특히 높은 트래픽 수준을 지원하는 메일러에 도움이 되는 것으로 입증된 몇 가지 최적화에 대해 설명합니다.

모든 대기열 전략에는 명령별로 모든 활동에 대한 시간 초과가 포함되어야 합니다. 큐잉 전략은 어떤 ​​상황에서도 오류 메시지에 대한 응답으로 오류 메시지를 보내서는 안 됩니다.\(MUST, MUST NOT\)

---
##### **4.5.4.1.  Sending Strategy**

SMTP 클라이언트의 일반 모델은 주기적으로 보내는 메일 전송을 시도하는 하나 이상의 프로세스입니다. 일반적인 시스템에서 메시지를 작성하는 프로그램에는 나가는 메일의 새로운 부분에 대해 즉각적인 주의를 요청하는 몇 가지 방법이 있지만, 즉시 전송할 수 없는 메일은 큐에 넣어야 하며 보낸 사람이 정기적으로 재시도해야 합니다. 메일 대기열 항목에는 메시지 자체뿐만 아니라 봉투 정보도 포함됩니다.\(MUST\)

발신자는 한 번의 시도가 실패한 후 특정 대상에 대한 재시도를 지연해야 합니다. 일반적으로 재시도 간격은 최소 30분이어야 합니다. 그러나 SMTP 클라이언트가 배달 불가 이유를 확인할 수 있는 경우에는 보다 정교하고 다양한 전략이 도움이 될 것입니다.\(MUST, SHOULD\)

메시지가 전송되거나 보낸 사람이 포기할 때까지 재시도가 계속됩니다. 포기 시간은 일반적으로 최소 4\~5일이 필요합니다. 표준 메시지보다 배달 불가 알림 및 이에 상응하는 오류 메시지에 대한 최대 재시도 횟수를 더 짧게 설정하는 것이 적절할 수 있습니다. 재시도 알고리즘에 대한 매개변수는 구성 가능해야 합니다.\(MAY, MUST\)

클라이언트는 대기 중인 메일 항목을 재시도하는 것보다 도달할 수 없는 호스트 목록과 해당 연결 시간 초과를 유지해야 합니다.\(SHOULD\)

경험에 따르면 실패는 일반적으로 일시적이며\(대상 시스템 또는 해당 연결이 중단됨\) 메시지가 대기열에 있는 첫 시간 동안 두 번의 연결 시도 정책을 선호하고 이후 2\~3시간마다 한 번으로 백오프됩니다.

SMTP 클라이언트는 SMTP 서버와 협력하여 대기열 지연을 단축할 수 있습니다. 예를 들어, 특정 주소에서 메일이 수신되면 해당 호스트에 대해 대기열에 있는 메일을 이제 보낼 수 있을 가능성이 높습니다. 이 원칙을 적용하면 많은 경우 ETRN, RFC 1985\[36\]과 같은 명시적인 "지금 대기열 보내기" 기능에 대한 요구 사항이 제거될 수 있습니다.

호스트당 여러 주소\(아래 참조\)의 결과로 전략을 추가로 수정하여 리소스 사용량 대비 배달 시간을 최적화할 수 있습니다.

SMTP 클라이언트에는 사용할 수 없는 각 대상 호스트에 대한 대규모 메시지 대기열이 있을 수 있습니다. 매 재시도 주기마다 이러한 메시지를 모두 재시도하면 과도한 인터넷 오버헤드가 발생하고 전송 시스템이 오랫동안 차단됩니다. SMTP 클라이언트는 일반적으로 몇 분의 시간 초과 후에만 배달 시도가 실패했음을 확인할 수 있으며, 연결당 1분의 시간 초과라도 재시도가 수십 또는 수백 번 반복되면 매우 큰 지연이 발생합니다. 동일한 호스트에 대기 중인 메시지입니다.

동시에, SMTP 클라이언트는 서버로부터 부정적인 응답을 캐싱하는 데 세심한 주의를 기울여야 합니다. 극단적인 경우 동일한 SMTP 연결 중에 EHLO가 여러 번 실행되면 서버에서 다른 응답이 반환될 수 있습니다. 더 중요한 점은 MAIL 명령에 대한 5yz 응답을 캐시하면 안 된다는 것입니다.\(SHOULD, MUST NOT\)

메일 메시지가 여러 수신자에게 전달되고 메시지 복사본이 전송될 SMTP 서버가 여러 수신자에 대해 동일한 경우 메시지 복사본 하나만 전송되어야 합니다. 즉, SMTP 클라이언트는 MAIL, RCPT, DATA, ..., MAIL, RCPT, DATA 시퀀스 대신 MAIL, RCPT, RCPT, ..., RCPT, DATA 명령 시퀀스를 사용해야 합니다. 그러나 주소가 매우 많은 경우 MAIL 명령당 RCPT 명령 수에 제한이 적용될 수 있습니다. 이 효율성 기능은 구현되어야 합니다.\(SHOULD, SHOULD, MAY, SHOULD\)

마찬가지로, 시기적절한 전달을 달성하기 위해 SMTP 클라이언트는 여러 개의 동시 발신 메일 트랜잭션을 지원할 수 있습니다. 그러나 호스트가 모든 리소스를 메일에 사용하지 않도록 보호하기 위해 일부 제한이 적절할 수 있습니다.\(MAY\)

---
##### **4.5.4.2.  Receiving Strategy**

SMTP 서버는 항상 SMTP 포트\(IANA에서 포트 25로 지정\)에서 보류 중인 수신 대기를 유지하려고 시도해야 합니다. 이를 위해서는 SMTP에 대한 여러 수신 TCP 연결 지원이 필요합니다. 일부 제한이 적용될 수 있지만 한 번에 둘 이상의 SMTP 트랜잭션을 처리할 수 없는 서버는 이 사양의 의도를 준수하지 않습니다.\(SHOULD, MAY\)

위에서 설명한 것처럼 SMTP 서버가 특정 호스트 주소로부터 메일을 받으면 자체 SMTP 대기열 메커니즘을 활성화하여 해당 호스트 주소에 대해 보류 중인 모든 메일을 다시 시도할 수 있습니다.

---
#### **4.5.5.  Messages with a Null Reverse-Path**

기존 및 제안된 표준에서 null 역방향 경로를 사용하여 전송하도록 요구하는 여러 유형의 알림 메시지가 있습니다. 즉, 섹션 3.7에 설명된 배달 불가 알림, 다른 종류의 배달 상태 알림\(DSN, RFC 3461\[32\]\)이 있습니다. \) 및 메시지 처리 알림\(MDN, RFC 3798 \[37\]\). 이러한 종류의 메시지는 모두 이전 메시지에 대한 알림이며 이전 메일 메시지의 역경로로 전송됩니다. \(이러한 알림 메시지 전달이 실패하는 경우 이는 일반적으로 알림 메시지가 전달되는 호스트의 메일 시스템에 문제가 있음을 나타냅니다. 이러한 이유로 일부 호스트에서는 실패한 알림 메시지를 다음 호스트로 전달하도록 MTA가 설정됩니다. 예를 들어 postmaster 별칭을 통해 메일 시스템 문제를 해결할 수 있는 사람입니다.\)

다른 모든 유형의 메시지\(즉, 표준 추적 RFC에서 null 역 경로를 요구하지 않는 모든 메시지\)는 null이 아닌 유효한 역 경로를 사용하여 전송되어야 합니다.\(SHOULD\)

자동화된 이메일 프로세서 구현자는 역방향 경로가 null인 다양한 종류의 메시지가 올바르게 처리되도록 주의해야 합니다. 특히 이러한 시스템은 null 역방향 경로가 있는 메시지에 응답해서는 안 되며, 전달할 때 이러한 메시지에 대해 null이 아닌 역방향 경로를 추가하거나 null이 아닌 역경로를 null이 아닌 경로로 변경해서는 안 됩니다.\(SHOULD NOT\)

---
## **5.  Address Resolution and Mail Handling**
---
### **5.1.  Locating the Target Host**

SMTP 클라이언트가 처리를 위해 메일이 배달될 도메인을 어휘적으로 식별하면\(섹션 2.3.5 및 3.6에 설명된 대로\) 도메인 이름을 확인하기 위해 DNS 조회를 수행해야 합니다\(RFC 1035 \[2\]\). 이름은 FQDN\(정규화된 도메인 이름\)이어야 합니다. 부분 이름이나 로컬 별칭에서 FQDN을 유추하는 메커니즘은 이 사양을 벗어납니다. 문제의 역사로 인해 메시지의 초기 제출에 사용되는 SMTP 서버는 그러한 추론을 해서는 안 되며\(메시지 제출 서버\[18\]는 다소 더 많은 유연성을 가짐\) 중간\(중계\) SMTP 서버는 그러한 추론을 해서는 안 됩니다.\(MUST, MUST NOT\)

조회에서는 먼저 이름과 연관된 MX 레코드를 찾으려고 시도합니다. CNAME 레코드가 발견되면 결과 이름이 초기 이름인 것처럼 처리됩니다. 존재하지 않는 도메인 오류가 반환되면 이 상황을 오류로 보고해야 합니다. 임시 오류가 반환되면 메시지를 대기열에 추가하고 나중에 다시 시도해야 합니다\(섹션 4.5.4.1 참조\). 빈 MX 목록이 반환되면 주소는 해당 호스트를 가리키는 기본 설정 0으로 암시적 MX RR과 연결된 것처럼 처리됩니다. MX 레코드가 있지만 그 중 어느 것도 사용할 수 없거나 암시적 MX를 사용할 수 없는 경우 이 상황은 오류로 보고되어야 합니다.\(MUST, MUST, MUST\)

특정 이름에 대해 하나 이상의 MX RR이 발견되면 SMTP 시스템은 MX RR을 사용하여 위치를 찾지 않는 한 해당 이름과 관련된 주소 RR을 활용해서는 안 됩니다. 위의 "암시적 MX" 규칙은 MX 레코드가 없는 경우에만 적용됩니다. MX 레코드가 있지만 그 중 어느 것도 사용할 수 없는 경우 이 상황은 오류로 보고되어야 합니다.\(MUST NOT, MUST\)

MX RR과 연관된 도메인 이름을 조회하고 연관된 데이터 필드를 얻은 경우 해당 응답의 데이터 필드에는 도메인 이름이 포함되어야 합니다. 해당 도메인 이름은 쿼리 시 메시지가 전달되어야 하는 SMTP 서버의 IP 주소를 제공하는 하나 이상의 주소 레코드\(예: A 또는 AAAA RR\)를 반환해야 합니다. 특히 쿼리 시 CNAME 레코드를 반환하는 값을 포함한 기타 모든 응답은 본 표준의 범위를 벗어납니다. CNAME으로 확인되는 데이터의 레이블 금지에 대해서는 RFC 2181, 섹션 10.3 \[38\]에 자세히 설명되어 있습니다.\(MUST, MUST\)

조회가 성공하면 여러 MX 레코드, 멀티호밍 또는 둘 다로 인해 매핑 결과 단일 주소가 아닌 대체 배달 주소 목록이 생성될 수 있습니다. 안정적인 메일 전송을 제공하려면 SMTP 클라이언트는 배달 시도가 성공할 때까지 이 목록의 각 관련 주소를 순서대로 시도\(및 재시도\)할 수 있어야 합니다. 그러나 시도할 수 있는 대체 주소 수에 대해 구성 가능한 제한이 있을 수도 있습니다. 어떤 경우든 SMTP 클라이언트는 최소한 두 개의 주소를 시도해야 합니다.\(MUST, MAY, SHOULD\)

호스트 주소의 순위를 지정하는 데는 두 가지 유형의 정보\(다중 MX 레코드 및 멀티홈 호스트\)가 사용됩니다.

MX 레코드에는 해당 레코드가 두 개 이상 나타나는 경우 반드시 정렬에 사용해야 하는 기본 설정 표시가 포함되어 있습니다\(아래 참조\). 높은 숫자보다 낮은 숫자가 더 선호됩니다. 동일한 기본 설정을 가진 여러 대상이 있고 하나를 선호할 명확한 이유가 없는 경우\(예: 쉽게 도달할 수 있는 주소 인식 등\), 발신자-SMTP는 이를 무작위로 지정하여 특정 조직의 여러 메일 교환기에 로드를 분산시켜야 합니다. .\(MUST, MUST\)

대상 호스트\(아마도 기본 MX 레코드에서 가져옴\)는 멀티홈일 수 있으며, 이 경우 도메인 이름 확인자는 대체 IP 주소 목록을 반환합니다. 필요한 경우 우선 순위를 줄여 이 목록을 정렬하는 것은 도메인 이름 확인자 인터페이스의 책임이며 SMTP 발신자는 제시된 순서대로 이를 시도해야 합니다.\(MUST\)

여러 대체 주소를 시도하는 기능이 필요하지만 특정 설치에서는 대체 주소 사용을 제한하거나 비활성화할 수 있습니다. 보낸 사람이 멀티홈 호스트의 다른 주소를 사용하여 재시도를 시도해야 하는지에 대한 질문은 논란의 여지가 있었습니다. 다중 주소를 사용하는 것에 대한 주요 주장은 적시 배송 가능성을 최대화하고 실제로 때로는 배송 가능성을 극대화한다는 것입니다. 반대 주장은 불필요한 자원 사용을 초래할 수 있다는 것입니다. 리소스 사용은 섹션 4.5.4.1에서 논의된 전송 전략에 의해 강력하게 결정된다는 점에 유의하십시오.

SMTP 서버가 지정된 Mail eXchanger인 대상이 있는 메시지를 수신하는 경우 메시지를 중계하거나\(MAIL FROM 및/또는 RCPT TO 주소를 다시 작성한 후\) 메시지를 최종 전달하거나 전달할 수 있습니다. SMTP 제공 전송 환경 외부의 일부 메커니즘을 사용하여 해제합니다. 물론 후자 중 어느 것도 MX 레코드 목록을 더 자세히 검사할 필요가 없습니다.\(MAY\)

주소를 다시 쓰지 않고 메시지를 중계해야 한다고 결정한 경우 MX 레코드를 정렬하여 후보를 결정해야 합니다.\(MUST\)

배달. 레코드는 먼저 선호도에 따라 정렬되며 가장 낮은 번호의 레코드가 가장 선호됩니다. 그러면 릴레이 호스트는 메일 거래에서 알 수 있는 이름이나 주소 목록을 검사해야 합니다. 일치하는 레코드가 발견되면 해당 기본 설정 수준의 모든 레코드와 번호가 더 높은 레코드는 고려 대상에서 삭제되어야 합니다. 해당 시점에 남아 있는 레코드가 없으면 이는 오류 조건이며 메시지는 전달할 수 없는 것으로 반환되어야 합니다. 기록이 남아 있는 경우 위에서 설명한 대로 최선의 방법으로 먼저 시도해야 합니다.\(MUST, MUST, MUST, SHOULD\)

---
### **5.2.  IPv6 and MX Records**

현대 인터넷에서 SMTP 클라이언트와 서버는 두 버전의 인터넷 프로토콜과 호환되는 IPv4 시스템, IPv6 시스템 또는 이중 스택 시스템에서 호스팅될 수 있습니다. 결과적으로 MX 레코드가 가리키는 호스트 도메인에는 "A RR"\(IPv4\), "AAAA RR"\(IPv6\) 또는 이들의 조합이 포함될 수 있습니다. RFC 3974 \[39\]는 혼합 환경에서의 일부 운영 경험을 논의하지만 표준화를 정당화할 만큼 포괄적이지 않았으며 권장 사항 중 일부가 이 사양과 일치하지 않는 것으로 보입니다. 취해야 할 적절한 조치는 관련 네트워크의 성능 및 필요할 수 있는 변환과 같은 현지 상황에 따라 달라지거나 명백할 것입니다\(예: IPv6 전용 클라이언트는 A RR을 조회하거나 시도할 필요가 없습니다\). IPv4 전용 서버에 도달하기 위해\). IPv6 또는 이중 스택 환경에서 실행될 수 있는 SMTP 구현 설계자는 위의 절차, 특히 멀티홈 호스트에 대한 설명을 연구해야 하며, 가능하면 로컬 상황을 고려하면서 IPv4와 IPv6 시스템 간의 작동 조정 및 메일 상호 운용성을 촉진하는 메커니즘을 제공해야 합니다.

---
## **6.  Problem Detection and Handling**
---
### **6.1.  Reliable Delivery and Replies by Email**

Receiver-SMTP가 메일을 수락하면\(DATA에 대한 응답으로 "250 OK" 메시지 전송\) 메시지 전달 또는 중계에 대한 책임을 수락합니다. 이 책임을 진지하게 받아들여야 합니다. 호스트가 나중에 충돌하거나 예측 가능한 리소스 부족과 같은 사소한 이유로 메시지를 잃어서는 안 됩니다. 사소한 것으로 간주되지 않는 몇 가지 이유는 다음 하위 섹션과 섹션 7.8에서 논의됩니다.\(MUST NOT\)

메시지 수락 후 배달 실패가 발생하는 경우 수신자-SMTP는 알림 메시지를 작성하여 메일로 보내야 합니다. 이 알림은 봉투의 null\("<\>"\) 역방향 경로를 사용하여 전송되어야 합니다. 이 알림의 수신자는 봉투 반환 경로\(또는 Return-Path: 행\)의 주소여야 합니다. 하지만,\(MUST, MUST, MUST\)

이 주소가 null\("<\>"\)인 경우 Receiver-SMTP는 알림을 보내서는 안 됩니다. 분명히, 이 섹션의 어떤 내용도 로컬 결정\(즉, 수신자-SMTP와 동일한 시스템 환경의 일부로서\)이 원하는 경우 로컬로 널 주소 이벤트에 대한 정보를 기록하거나 전송하는 것을 금지할 수 있거나 금지해서는 안 됩니다. 주소가 명시적인 소스 경로인 경우 최종 홉까지 제거되어야 합니다.\(MUST NOT, MUST\)

예를 들어, 다음과 같이 도착한 메시지에 대해 오류 알림을 보내야 한다고 가정해 보겠습니다.

```text
      MAIL FROM:<@a,@b:user@d>
```

알림 메시지는 다음을 사용하여 전송되어야 합니다.\(MUST\)

```text
      RCPT TO:<user@d>
```

SMTP에서 메시지를 수락한 후 일부 배달 실패는 불가피합니다. 예를 들어, 대상이 메일링 리스트이기 때문에 "소프트" 도메인 시스템 오류로 인해 수신 SMTP 서버가 RCPT 명령의 모든 배달 주소를 검증하는 것이 불가능할 수 있습니다\(RCPT에 대한 이전 논의 참조\). 서버가 중계 역할을 하며 전달 시스템에 즉시 접근할 수 없기 때문입니다.

시간 초과로 인한 중복 메시지 수신을 방지하려면 Receiver-SMTP는 최종 <CRLF\>.<CRLF\> 데이터 끝 표시기에 응답하는 데 필요한 시간을 최소화해야 합니다. 이 문제에 대한 논의는 RFC 1047 \[40\]을 참조하십시오.\(MUST\)

---
### **6.2.  Unwanted, Unsolicited, and "Attack" Messages**

인터넷 메일 시스템의 유용성과 예측 가능성을 위해서는 메시지와 관련된 구문이나 기타 결함 및 내용에 관계없이 배달할 수 있는 메시지가 배달되어야 합니다. 메시지를 전달할 수 없고 SMTP 트랜잭션 중에 SMTP 서버에서 거부할 수 없는 경우 위에서 설명한 대로 "반송"\(배달 불가 알림 메시지와 함께 반환\)되어야 합니다. 많은 SMTP 서버 운영자가 바람직하지 않은 대량 이메일의 양이 원하는 메일의 양을 훨씬 초과하고 메시지를 수락하면 주소 확인을 제공하여 바람직하지 않은 추가 트래픽을 유발할 수 있다는 사실을 발견한 오늘날의 세계에서는 이러한 원칙이 실용적이지 않을 수 있습니다. .

아래 섹션 7.8 및 섹션 7.9에 설명된 대로 보낸 사람에게 알리지 않고 메일을 삭제하는 것은 실제로 허용됩니다. 그러나 우편물이 배달되거나 반송되는 것은 매우 위험하며 오랜 전통과 커뮤니티의 기대에 위배됩니다. 만약에

자동 메시지 삭제가 오용되면 인터넷 메일 시스템의 신뢰성에 대한 신뢰가 쉽게 훼손될 수 있습니다. 따라서 메시지가 심각하게 사기적이거나 부적절하다는 확신이 매우 높은 경우에만 메시지 자동 삭제를 고려해야 합니다.

가능하다면 배달 원칙을 더욱 확장하기 위해 반송 주소가 잘못된 메일은 배달하지 않는 것이 합리적인 정책일 수 있습니다. 하지만 네트워크의 역사를 보면 일반적으로 배달 가능한 메시지를 모두 배달하는 것이 사용자에게 더 나은 서비스를 제공합니다. 반송 주소가 유효하지 않다는 것을 확실하게 결정하는 것은 어렵고 시간이 많이 걸리는 프로세스일 수 있습니다. 특히 추정 전송 시스템이 직접 액세스할 수 없거나 VRFY를 완전하고 정확하게 지원하지 않는 경우 및 "잘못된 반송 주소가 있는 메시지 삭제" 정책이 적용되는 경우에도 그렇습니다. 채택된 경우 반환 주소가 실제로 유효하지 않다는 것이 거의 확실할 경우에만 적용해야 합니다.\(SHOULD\)

반대로 메시지에 적대적인 내용\(이 문서에 정의된 SMTP 서버의 범위를 벗어난 결정\)이 포함된 것으로 확인되어 거부된 경우 거부\("바운스"\) 메시지는 수신 사이트가 아닌 이상 전송되어서는 안 됩니다. 그 메시지가 유용하게 전달될 것이라고 확신합니다. 이러한 경우 기본 설정 및 기본값은 들어오는 메시지에 적대적인 콘텐츠가 포함된 것으로 확인될 때 배달 못 함 메시지를 보내지 않는 것입니다.\(SHOULD NOT\)

---
### **6.3.  Loop Detection**

메시지의 "Received:" 헤더 필드 수를 간단히 계산하는 것은 최적의 경우는 아니지만 메일 시스템의 루프를 감지하는 효과적인 방법임이 입증되었습니다. 이 기술을 사용하는 SMTP 서버는 일반적으로 최소 100개의 수신 항목과 같은 큰 거부 임계값을 사용해야 합니다. 어떤 메커니즘을 사용하든 서버에는 사소한 루프를 감지하고 중지하기 위한 조항이 포함되어 있어야 합니다.\(SHOULD, MUST\)

---
### **6.4.  Compensating for Irregularities**

불행하게도 인터넷 메일 프로토콜에 대한 변형, 창의적인 해석 및 노골적인 위반이 발생합니다. 어떤 사람들은 그러한 일이 꽤 자주 발생한다고 제안합니다. 제대로 작동하는 SMTP 수신자나 중계기가 기형 메시지를 거부해야 하는지, 변경되지 않은 메시지를 전달하려고 시도해야 하는지, 아니면 성공적인 전달\(또는 후속 응답\) 확률을 높이기 위해 수리를 시도해야 하는지에 대한 논쟁은 거의 구조화된 메시지의 시작과 함께 시작되었습니다. 네트워크 메일이 줄어들 기미가 보이지 않습니다. 거부 옹호자들은 복구 시도가 완전히 적절한 경우는 거의 없으며 잘못된 메시지를 거부하는 것이 문제가 되는 소프트웨어를 복구할 수 있는 유일한 방법이라고 주장합니다. "수리" 또는 "무슨 일이 있어도 배송"을 옹호하는 사람들은 사용자가 다음을 선호한다고 주장합니다.

가능한 경우 우편물이 이를 통과하고 그 방향으로 상당한 시장 압력이 있음을 확인하십시오. 실제로 이러한 시장 압력은 실제 개발자의 선호도에 관계없이 표준을 엄격하게 준수하는 것보다 특정 공급업체에게 더 중요할 수 있습니다.

잘못된 형식의 메시지와 관련된 문제는 분할 UA 메일 읽기 프로토콜\(POP\(Post Office Protocol\) 버전 2\[15\], POP\(Post Office Protocol\) 버전 3\[16\], IMAP 버전 2\[16\]\)의 도입으로 더욱 악화되었습니다. 41\] 및 PCMAIL \[42\]\). 이러한 프로토콜은 SMTP를 게시\(메시지 제출\) 프로토콜로 사용하고 SMTP 서버를 이러한 클라이언트 호스트\(종종 간헐적으로 인터넷에 연결됨\)에 대한 릴레이 시스템으로 사용하도록 권장했습니다. 역사적으로 이러한 클라이언트 시스템 중 다수에는 SMTP\(그리고 실제로 메일 형식 프로토콜인 RFC 822\[28\]\)에서 가정한 일부 메커니즘과 정보가 부족했습니다. 일부는 시간을 적절하게 추적할 수 없었습니다. 다른 사람들은 시간대에 대한 개념이 없었습니다. 또 다른 사람들은 자신의 이름이나 주소를 식별할 수 없었습니다. 물론, 인증된 주소에 대한 RFC 822의 개념을 뒷받침하는 가정을 만족시킬 수 있는 사람은 아무도 없습니다.

이러한 취약한 SMTP 클라이언트에 대응하여 이제 많은 SMTP 시스템은 불완전하거나 잘못된 형식으로 전달되는 메시지를 완성합니다. 이 전략은 일반적으로 서버가 클라이언트를 식별하거나 인증할 수 있고 클라이언트 간에 사전 합의가 있는 경우 적절한 것으로 간주됩니다. 대조적으로, 사용자나 클라이언트 시스템에 대한 지식이 거의 또는 전혀 없는 릴레이 또는 배달 SMTP 서버에 의해 적용되는 수정 사항에 대해서는 기껏해야 큰 우려가 있습니다. 이러한 문제 중 다수는 메시지 전송을 위해 원래 SMTP 서버를 사용하는 대신 RFC 4409\[18\]에 정의된 것과 같은 별도의 프로토콜을 사용하여 해결됩니다.

처리 중인 메시지에 대한 다음 변경 사항은 원본 SMTP 서버 또는 초기 게시\(메시지 제출\) 프로토콜로서 SMTP의 대상으로 사용되는 서버에 의해 필요할 때 적용될 수 있습니다.\(MAY\)

o 아무것도 나타나지 않을 때 message-id 필드 추가

o 아무 것도 나타나지 않는 경우 날짜, 시간 또는 시간대 추가

o 적절한 FQDN 형식으로 주소 수정

서버가 클라이언트에 대해 갖고 있는 정보가 적을수록 이러한 변경 사항이 정확할 가능성이 낮아지므로 수정 사항을 수행할지 여부와 방법을 고려할 때 더 많은 주의와 보수성을 적용해야 합니다. 이러한 변경 사항은 중간 릴레이 기능을 제공하는 SMTP 서버에 의해 적용되어서는 안 됩니다.\(MUST NOT\)

모든 경우에 올바른 정보를 제공하는 제대로 작동하는 클라이언트가 SMTP 서버에 의한 수정보다 선호됩니다. 모든 경우에 서버가 수행하는 작업에 대한 추적 헤더 필드 및/또는 헤더 필드 주석에 문서를 제공해야 합니다.\(SHOULD\)

---
## **7.  Security Considerations**
---
### **7.1.  Mail Security and Spoofing**

SMTP 메일은 매우 일반적인 사용자라도 수신 및 중계 SMTP 서버와 직접 협상하여 순진한 수신자가 다른 곳에서 온 것처럼 믿도록 속이는 메시지를 생성할 수 있다는 점에서 본질적으로 안전하지 않습니다. 전문가가 "스푸핑된" 행동을 탐지할 수 없도록 그러한 메시지를 구성하는 것은 다소 어렵지만 결단력 있고 지식이 풍부한 사람을 억제할 만큼 충분하지는 않습니다. 결과적으로, 인터넷 메일에 대한 지식이 늘어남에 따라 SMTP 메일은 본질적으로 전송 수준에서 인증되거나 무결성 검사가 제공될 수 없다는 지식도 늘어납니다. 실제 메일 보안은 디지털 서명\(RFC 1847 \[43\] 참조 및 예를 들어 RFC 4880 \[44\]의 PGP\(Pretty Good Privacy\) 또는 RFC 3851 \[45\]의 다목적 인터넷 메일 확장\(S/MIME\).

전송 수준\(예: SMTP 클라이언트에서 SMTP 서버로\)에서 인증을 제공하는 다양한 프로토콜 확장 및 구성 옵션은 위에서 설명한 기존 상황을 어느 정도 개선합니다. 그러나 일반적으로 릴레이 및 서버 체인이 아닌 한 서버를 다른 서버에 대해서만 인증하며 사용자 또는 사용자 시스템을 인증하는 것은 훨씬 적습니다. 결과적으로 신중하게 설계된 신뢰 환경에서 신중하게 책임을 이양하지 않는 한 전송 시스템의 무결성에 의존하지 않고 디지털 서명된 메시지를 사용하는 엔드투엔드 메커니즘보다 본질적으로 약한 상태로 유지됩니다.

사용자가 자신의 주소가 아닌 유효한 주소를 가리키도록 봉투 반환 경로와 헤더 "보낸 사람" 필드를 설정하는 것을 더 어렵게 만드는 노력은 대체로 잘못된 것입니다. 이는 한 사용자가 다른 사용자를 대신하여 메일을 보내는 합법적인 응용 프로그램을 좌절시킵니다. 어떤 오류\(또는 일반\) 응답이 특수 주소로 전달되어야 하는지 또는 단일 메시지가 서로 다른 호스트의 여러 수신자에게 전송되어야 하는지를 나타냅니다. \(사용자가 메시지별로 이러한 헤더 필드를 변경할 수 있는 편리한 방법을 제공하는 시스템은 메시지 데이터 내의 보낸 사람 헤더 필드가 현명하게 생성될 수 있도록 사용자에 대한 기본 및 영구 사서함 주소를 설정하려고 시도해야 합니다.\)

이 사양은 메일을 위조하려는 사용자에 대해 약간의 보호 여유를 제공하기 위해 유용한 기능을 비활성화하지 않도록 옹호하는 것 외에는 SMTP와 관련된 인증 문제를 더 이상 다루지 않습니다.

---
### **7.2.  "Blind" Copies**

메시지 헤더 섹션에 나타나지 않는 주소는 여러 가지 이유로 SMTP 서버에 대한 RCPT 명령에 나타날 수 있습니다. 가장 일반적인 두 가지 방법은 우편 주소를 "목록 분해기"\(여러 주소로 확인되는 단일 주소\)로 사용하는 것과 "숨은 참조"로 나타나는 것입니다. 특히 둘 이상의 RCPT 명령이 존재할 때 이러한 메커니즘의 일부 목적을 무효화하는 것을 피하기 위해 SMTP 클라이언트와 서버는 추적 헤더 필드의 일부로 RCPT 명령 인수의 전체 집합을 헤더 섹션에 복사해서는 안 됩니다. 또는 정보 또는 개인 확장 헤더 필드로 사용됩니다. 이 규칙은 실제로 자주 위반되고 시행될 수 없기 때문에 "bcc" 사용을 인식하는 SMTP 시스템을 보내는 것은 단일 RCPT 명령만 포함하는 별도의 메시지 트랜잭션으로 각 숨은 복사본을 보내는 것이 도움이 될 수 있습니다.\(SHOULD NOT, MAY\)

SMTP 트랜잭션의 "역방향"\(MAIL, SAML 등 명령\) 또는 "전달"\(RCPT\) 주소\("봉투"\)와 헤더 섹션의 주소 사이에는 고유한 관계가 없습니다. 수신 시스템은 그러한 관계를 추론하고 이를 사용하여 배달할 메시지의 헤더 섹션을 변경하려고 시도해서는 안 됩니다. 널리 사용되는 "Apparently-to" 헤더 필드는 이 원칙을 위반할 뿐만 아니라 의도하지 않은 정보 공개의 일반적인 소스이므로 사용해서는 안 됩니다.\(SHOULD NOT, SHOULD NOT\)

---
### **7.3.  VRFY, EXPN, and Security**

섹션 3.5에서 설명한 대로 개별 사이트에서는 보안상의 이유로 VRFY 또는 EXPN 중 하나 또는 둘 다를 비활성화할 수 있습니다\(아래 참조\). 위의 결과에 따라 이를 허용하는 구현은 실제로 확인되지 않은 확인된 주소를 갖는 것처럼 보여서는 안 됩니다. 사이트에서 보안상의 이유로 이러한 명령을 비활성화하는 경우 SMTP 서버는 확인 성공 또는 실패와 혼동될 수 있는 코드 대신 252 응답을 반환해야 합니다.\(MUST NOT, MUST\)

구문만 확인한 후 VRFY 명령에 나열된 주소와 함께 250 응답 코드를 반환하는 것은 이 규칙을 위반합니다. 물론 주소가 유효한지 여부에 관계없이 항상 550을 반환하여 VRFY를 "지원"하는 구현은 똑같이 적합하지 않습니다.

```text
   On the public Internet, the contents of mailing lists have become
   popular as an address information source for so-called "spammers."
```

목록 관리자가 목록 자체의 부적절한 사용에 대한 보호 장치를 설치함에 따라 주소를 "수집"하기 위한 EXPN 사용이 증가했습니다. 그러나 VRFY 및 EXPN은 인증된 사용자 및 관리 도메인 내에서 여전히 유용합니다. 예를 들어 VRFY 및 EXPN은 이메일이 라우팅되는 방식에 대한 내부 감사를 수행하여 조직 외부로 민감한 메일을 자동으로 전달하는 사람이 없는지 확인하는 데 유용합니다. SMTP 인증을 구현하는 사이트는 VRFY 및 EXPN을 인증된 요청자에게만 제공하도록 선택할 수 있습니다. 구현은 여전히 ​​EXPN에 대한 지원을 제공해야 하지만 사이트는 장단점을 신중하게 평가해야 합니다.\(SHOULD\)

VRFY를 비활성화하면 실제 한계 보안이 제공되는지 여부는 일련의 다른 조건에 따라 달라집니다. 대부분의 경우 RCPT 명령을 사용하여 주소 유효성에 대한 동일한 정보를 얻을 수 있습니다. 반면, 특히 RCPT 명령에 대한 주소 유효성 결정이 DATA 명령이 수신될 때까지 연기되는 상황에서는 RCPT가 전혀 정보를 반환하지 않을 수 있지만 VRFY는 응답을 생성하기 전에 유효성을 확인하기 위해 진지한 시도를 할 것으로 예상됩니다. 코드\(위의 논의 참조\).

---
### **7.4.  Mail Rerouting Based on the 251 and 551 Response Codes**

클라이언트가 향후 동작\(예: 사용자 주소록 업데이트\)을 자동으로 업데이트하기 위해 RCPT 명령의 251 또는 551 응답 코드를 사용하기 전에 서버의 신뢰성을 확인해야 합니다. 그렇지 않으면 중간자 공격을 받을 수 있습니다.

---
### **7.5.  Information Disclosure in Announcements**

인사말 응답이나 HELP 명령에 대한 응답에서 서버 유형 및 버전\(때로는 서버 도메인 이름까지\)을 ​​알리는 디버깅 이점과 유용할 수 있는 정보 노출의 단점 사이의 절충점에 대한 지속적인 논쟁이 있었습니다. 잠재적인 적대적 공격에서. 디버깅 정보의 유용성은 의심할 여지가 없습니다. 이를 사용 가능하게 해야 한다고 주장하는 사람들은 서버의 정확한 신원을 숨겨 알려진 취약점을 숨기려고 시도하는 것보다 실제로 SMTP 서버를 보호하는 것이 훨씬 더 낫다고 지적합니다. 사이트에서는 해당 문제를 염두에 두고 균형을 평가하는 것이 좋습니다. 구현은 다른 네트워크 호스트가 어떤 방식으로든 유형 및 버전 정보를 사용할 수 있도록 최소한으로 제공해야 합니다\(SHOULD\).\(SHOULD\)

---
### **7.6.  Information Disclosure in Trace Fields**

호스트가 공용 인터넷에 직접 있지 않은 LAN 내에서 메일이 시작되는 경우와 같은 일부 상황에서는 이 사양에 따라 생성된 추적\("Received"\) 헤더 필드가 일반적으로 사용할 수 없는 호스트 이름 및 유사한 정보를 공개할 수 있습니다. . 이는 일반적으로 문제를 일으키지 않지만, 이름 공개에 대해 특별한 우려가 있는 사이트에서는 이를 인지해야 합니다. 또한 선택적 FOR 절은 여러 수신자가 관련된 경우 "숨은 참조" 수신자의 신원을 다른 사람에게 실수로 공개하지 않도록 주의해서 제공하거나 전혀 제공하지 않아야 합니다.

---
### **7.7.  Information Disclosure in Message Forwarding**

섹션 3.4에서 설명한 대로 사서함과 관련된 대체 주소를 식별하기 위해 251 또는 551 응답 코드를 사용하면 민감한 정보가 실수로 공개될 수 있습니다. 이러한 문제를 우려하는 사이트에서는 서버를 적절하게 선택하고 구성해야 합니다.

---
### **7.8.  Resistance to Attacks**

최근 몇 년 동안 원치 않는 메시지를 보내기 위한 주소를 알아내려는 시도와 함께 또는 단순히 다른 사람이 서버에 액세스할 수 없게 만드는 시도\(예: 애플리케이션 수준 서비스 거부 공격\)와 함께 SMTP 서버에 대한 공격이 증가했습니다. 그렇게 하는 수단은 이 표준의 범위를 벗어나지만, 합리적인 운영 활동을 위해서는 서버가 그러한 공격을 감지하고 스스로를 방어하기 위한 조치를 취하도록 허용되어야 합니다. 예를 들어, 서버가 이러한 공격의 일부로 많은 수의 RCPT TO 명령이 대부분 또는 모두 잘못된 주소로 전송되고 있다고 판단하는 경우 서버는 적절한 수의 명령을 생성한 후 연결을 닫는 것이 합리적입니다. 5yz\(보통 550\)가 응답합니다.

---
### **7.9.  Scope of Operation of SMTP Servers**

SMTP 서버가 서버를 제공하는 사이트에 적합한 운영상 또는 기술적인 이유로 메일 수신을 거부할 수 있다는 것은 잘 확립된 원칙입니다. 그러나 사이트와 설치 간의 협력이 인터넷을 가능하게 합니다. 사이트가 트래픽을 거부할 권리를 과도하게 활용하면 이메일 가용성\(인터넷의 강점 중 하나\)의 편재성이 위협받게 됩니다. 사이트가 수용하고 처리할 트래픽을 선별하기로 결정한 경우 상당한 주의를 기울여야 하며 균형이 유지되어야 합니다.

최근에는 메일의 실제 출처를 숨기려는 적대적인 노력의 일환으로 임의 사이트를 통한 중계 기능을 활용하는 사례가 발생하고 있습니다. 일부 사이트에서는 중계 기능의 사용을 알려졌거나 식별 가능한 소스로 제한하기로 결정했으며 구현에서는 이러한 유형의 필터링을 수행하는 기능을 제공해야 합니다. 이러한 또는 기타 정책 이유로 인해 메일이 거부되면 EHLO\(또는 HELO\), MAIL 또는 RCPT에 대한 응답으로 550 코드를 적절하게 사용해야 합니다.\(SHOULD, SHOULD\)

---
## **8.  IANA Considerations**

IANA는 이 사양을 지원하기 위해 세 개의 레지스트리를 유지 관리하며, 모두 RFC 2821 이하 버전을 위해 생성되었습니다. 이 문서는 아래에 명시된 대로 세 번째 문서를 확장합니다. 나열된 레지스트리 참조는 출판 당시의 것입니다. IANA는 URL과 관련된 위치를 보장하지 않습니다. 레지스트리는 다음과 같습니다.

o 첫 번째, "Simple Mail Transfer Protocol\(SMTP\) 서비스"

- 확장"\[46\]은 관련 키워드, 필요에 따라 매개변수 및 동사가 포함된 SMTP 서비스 확장으로 구성됩니다. 섹션 2.2.2에 지정된 대로 이 레지스트리에는 "X"로 시작하는 항목을 만들 수 없습니다. 이러한 목적을 위해 IESG가 특별히 승인한 표준 추적 또는 실험적 RFC에 정의된 서비스 확장\(및 관련 키워드, 매개변수 또는 동사\)에 대해서만 항목을 작성할 수 있습니다.

o 두 번째 레지스트리인 "주소 리터럴 태그"\[47\]는 IPv4 주소\(RFC 821 및 이 문서에 지정됨\) 이외의 도메인 리터럴 형식을 식별하는 "태그"로 구성됩니다. 해당 레지스트리의 초기 항목은 IPv6 주소\(이 문서에 지정됨\)에 대한 것입니다. 추가 리터럴 유형을 사용하려면 표준화가 필요합니다. 현재로서는 아무것도 예상되지 않습니다.

o RFC 821에 의해 설정되고 이 사양에 의해 갱신된 세 번째 "메일 전송 유형"\[46\]은 타임 스탬프의 "via" 및 "with" 하위 절과 함께 사용되는 링크 및 프로토콜 식별자의 레지스트리입니다\(" 수신됨:" 헤더 필드\) 섹션 4.4에 설명되어 있습니다. 이 문서에 지정된 것 외에 링크 및 프로토콜 식별자는 표준화나 RFC 문서화, IESG 승인 실험 프로토콜 확장을 통해서만 등록할 수 있습니다. 이 이름 공간은 식별을 위한 것이며 크기에 제한이 없습니다. IESG는 방법 자체의 속성에 대한 선호보다는 명확한 문서와 고유한 방법을 기반으로 승인하는 것이 좋습니다.

- 위에 설명된 "추가 등록 절"의 등록을 포함하기 위해 이 레지스트리의 "VIA 링크 유형" 및 "WITH 프로토콜 유형" 하위 섹션에 추가 하위 섹션이 추가되었습니다. 레지스트리에는 조항 이름, 설명,

- 관련 문자열의 구문 요약 및 참조입니다. 새 절이 정의되면 원칙적으로 문자열이 덜 제한된 문자열이 아닌 예약어나 키워드로 구성된 경우 자체 레지스트리 생성을 지정할 수 있습니다. 링크 및 프로토콜 식별자와 마찬가지로 추가 조항은 표준화나 RFC 문서화, IESG 승인 실험 프로토콜 확장을 통해서만 등록할 수 있습니다. 추가 조항 이름 공간은 식별을 위한 것이며 크기가 제한되지 않습니다. IESG는 명확한 문서, 실제 사용 또는 해당 조항이 사용될 것이라는 강력한 신호, 속성에 대한 선호도보다는 뚜렷한 요구 사항을 기반으로 승인하는 것이 좋습니다. 조항 자체의.

또한 추가 추적 헤더 필드\(예: Return-path 및 수신 외에\)가 생성된 경우 해당 추적 필드는 RFC 5322와 함께 사용하기 위해 BCP 90\(RFC 3864\)\[11\]에 의해 설정된 IANA 레지스트리에 추가되어야 합니다. \[4\].\(MUST\)

---
## **9.  Acknowledgments**

많은 사람들이 RFC 2821 개발에 기여했습니다. 그러한 감사의 말을 보려면 해당 문서를 참조해야 합니다. 현재 문서에 대해 편집자와 커뮤니티는 문서의 내부 형식을 한 시스템에서 다른 시스템으로 편집하고 변환하는 매우 고통스러운 과정을 도운 Dawn Mann과 Tony Hansen에게 감사를 표합니다.

이 문서나 RFC 2821은 Jon Postel의 많은 기여와 통찰력이 없었다면 불가능했을 것입니다. 물론 이러한 기여에는 RFC 821의 SMTP 원래 사양이 포함됩니다. 사양의 다른 변경 사항을 반영하기 위해 필요한 경우에만 업데이트된 Jon의 여러 원래 예제와 마찬가지로 RFC 821의 상당량의 텍스트가 이 문서에 여전히 나타납니다.

많은 사람들이 메일링 리스트나 작성자에게 보내는 메모에 의견이나 제안을 했습니다. Matti Aarnio, Glenn Anderson, Derek J. Balling, Alex van den Bogaerdt, Stephane Bortzmeyer, Vint Cerf, Jutta Degener, Steve Dorner, Lisa Dusseault, Frank Ellerman, Ned Freed, Randy Gellens를 포함한 여러 사람이 중요한 수정 또는 설명을 제안했습니다. , Sabahattin Gucukoglu, Philip Guenther, Arnt Gulbrandsen, Eric Hall, Richard O. Hammer, Tony Hansen, Peter J. Holzer, Kari Hurtta, Bryon Roche Kain, Valdis Kletnieks, Mathias Koerber, John Leslie, Bruce Lilly, Jeff Macdonald, Mark E Mallett, Mark Martinec, S. Moonesamy, Lyndon Nerenberg, Chris Newman, Douglas Otis, Pete Resnick, Robert A. Rosenberg, Vince Sabio, Hector Santos, David F. Skoll, Paul Smith 및 Brett Watson.

이러한 노력을 다시 시작하고 계속 진행하기 위한 지역 이사인 Lisa Dusseault, Ted Hardie 및 Chris Newman의 노력과 같은 목적을 가진 임시 위원회의 노력에 감사드립니다. 그 위원회의 구성원은 \(알파벳순으로\) Dave Crocker, Cyrus Daboo, Tony Finch, Ned Freed, Randall Gellens, 저자 Tony Hansen, Alexey Melnikov였습니다. Tony Hansen은 또한 이 문서를 검토하는 메일링 리스트의 임시 의장으로도 활동했습니다. 그의 노력, 균형 감각, 공정성, 인내심이 없었다면 불가능했을 것입니다.

---
## **10.  References**
---
### **10.1.  Normative References**

```text
   [1]   Postel, J., "Simple Mail Transfer Protocol", STD 10, RFC 821,
         August 1982.
```

\[2\] Mockapetris, P., "도메인 이름 - 구현 및

- 사양", STD 13, RFC 1035, 1987년 11월.

\[3\] Braden, R., "인터넷 호스트 요구 사항 - 응용 프로그램 및 지원", STD 3, RFC 1123, 1989년 10월.

```text
   [4]   Resnick, P., "Internet Message Format", RFC 5322, October 2008.
```

\[5\] Bradner, S., "요구 사항 수준을 나타 내기 위해 RFC에 사용되는 핵심 단어", BCP 14, RFC 2119, 1997년 3월.

\[6\] 미국 국립 표준 협회\(이전 미국 표준 협회\), "정보 교환을 위한 미국 코드", ANSI X3.4-1968, 1968.

- ANSI X3.4-1968은 약간의 수정을 거쳐 최신 버전으로 대체되었지만 1968 버전은 여전히 ​​인터넷에서 최종 버전으로 남아 있습니다.

\[7\] Crocker, D. 및 P. Overell, "구문을 위한 증강된 BNF

- 사양: ABNF", STD 68, RFC 5234, 2008년 1월.

\[8\] Hinden, R. 및 S. Deering, "IP 버전 6 주소 지정

- 아키텍처', RFC 4291, 2006년 2월.

\[9\] Newman, C., "ESMTP 및 LMTP 전송 유형 등록", RFC 3848, 2004년 7월.

\[10\] Klensin, J., Freed, N. 및 K. Moore, "메시지 크기 선언을 위한 SMTP 서비스 확장", STD 10, RFC 1870, 1995년 11월.

\[11\] Klyne, G., Nottingham, M. 및 J. Mogul, "등록

- 메시지 헤더 필드 절차", BCP 90, RFC 3864, 2004년 9월.

---
### **10.2.  Informative References**

\[12\] Partridge, C., "메일 라우팅 및 도메인 시스템", RFC 974, 1986년 1월.

\[13\] Klensin, J., Freed, N., Rose, M., Stefferud, E. 및 D. Crocker, "SMTP 서비스 확장", STD 10, RFC 1869, 1995년 11월.

```text
   [14]  Klensin, J., "Simple Mail Transfer Protocol", RFC 2821,
         April 2001.
```

\[15\] Butler, M., Postel, J., Chase, D., Goldberger, J. 및 J. Reynolds, "우체국 프로토콜: 버전 2", RFC 937, 1985년 2월.

\[16\] Myers, J. 및 M. Rose, "우체국 프로토콜 - 버전 3", STD 53, RFC 1939, 1996년 5월.

```text
   [17]  Crispin, M., "INTERNET MESSAGE ACCESS PROTOCOL - VERSION
         4rev1", RFC 3501, March 2003.
```

\[18\] Gellens, R. 및 J. Klensin, "메일을 위한 메시지 제출", RFC 4409, 2006년 4월.

\[19\] Freed, N., "명령 파이프라이닝을 위한 SMTP 서비스 확장", STD 60, RFC 2920, 2000년 9월.

\[20\] Vaudreuil, G., "대형 및 바이너리 MIME 메시지 전송을 위한 SMTP 서비스 확장", RFC 3030, 2000년 12월.

\[21\] Freed, N. 및 N. Borenstein, "다목적 인터넷 메일 확장\(MIME\) 1부: 인터넷 메시지 본문 형식", RFC 2045, 1996년 11월.

\[22\] Klensin, J., Freed, N., Rose, M., Stefferud, E. 및 D. Crocker, "8bit-MIMEtransport를 위한 SMTP 서비스 확장", RFC 1652, 1994년 7월.

\[23\] Moore, K., "MIME\(다목적 인터넷 메일 확장\) 3부: 비ASCII 텍스트에 대한 메시지 헤더 확장", RFC 2047, 1996년 11월.

\[24\] Freed, N. 및 K. Moore, "MIME 매개변수 값 및 인코딩된 단어 확장: 문자 세트, 언어 및 연속", RFC 2231, 1997년 11월.

```text
   [25]  Vaudreuil, G., "Enhanced Mail System Status Codes", RFC 3463,
         January 2003.
```

\[26\] Hansen, T. 및 J. Klensin, "SMTP 강화 메일 시스템 상태 코드 레지스트리", BCP 138, RFC 5248, 2008년 6월.

\[27\] Freed, N., "인터넷의 동작 및 요구 사항

- 방화벽', RFC 2979, 2000년 10월.

\[28\] Crocker, D., "ARPA 인터넷 문자 메시지 형식에 대한 표준", STD 11, RFC 822, 1982년 8월.

\[29\] Wong, M. 및 W. Schlitt, "이메일에서 도메인 사용 승인을 위한 SPF\(발신자 정책 프레임워크\) 버전 1", RFC 4408, 2006년 4월.

\[30\] Fenton, J., "DomainKeys에 동기를 부여하는 위협 분석

- 식별 메일\(DKIM\)", RFC 4686, 2006년 9월.

\[31\] Allman, E., Callas, J., Delany, M., Libbey, M., Fenton, J. 및 M. Thomas, "DKIM\(DomainKeys Identified Mail\) 서명", RFC 4871, 2007년 5월.

\[32\] Moore, K., "DSN\(배달 상태 알림\)을 위한 SMTP\(Simple Mail Transfer Protocol\) 서비스 확장", RFC 3461, 2003년 1월.

\[33\] Moore, K. 및 G. Vaudreuil, "배달 상태 알림을 위한 확장 가능한 메시지 형식", RFC 3464, 2003년 1월.

\[34\] Postel, J. 및 J. Reynolds, "파일 전송 프로토콜", STD 9, RFC 959, 1985년 10월.

\[35\] Kille, S., "MIXER\(Mime Internet X.400 Enhanced Relay\): X.400과 RFC 822/MIME 간의 매핑", RFC 2156, 1998년 1월.

\[36\] De Winter, J., "원격 메시지 대기열 시작을 위한 SMTP 서비스 확장", RFC 1985, 1996년 8월.

\[37\] Hansen, T. 및 G. Vaudreuil, "메시지 처리

- 공지", RFC 3798, 2004년 5월.

\[38\] Elz, R. 및 R. Bush, "DNS 사양에 대한 설명", RFC 2181, 1997년 7월.

\[39\] Nakamura, M. 및 J. Hagino, "혼합 IPv4/v6 환경의 SMTP 운영 경험", RFC 3974, 2005년 1월.

\[40\] Partridge, C., "중복 메시지 및 SMTP", RFC 1047, 1988년 2월.

```text
   [41]  Crispin, M., "Interactive Mail Access Protocol: Version 2",
         RFC 1176, August 1990.
```

\[42\] Lambert, M., "PCMAIL: 개인용 컴퓨터용 분산 메일 시스템", RFC 1056, 1988년 6월.

\[43\] Galvin, J., Murphy, S., Crocker, S. 및 N. Freed, "MIME용 보안 멀티파트: 멀티파트/서명 및 멀티파트/암호화", RFC 1847, 1995년 10월.

\[44\] Callas, J., Donnerhacke, L., Finney, H., Shaw, D. 및 R. Thayer, "OpenPGP 메시지 형식", RFC 4880, 2007년 11월.

```text
   [45]  Ramsdell, B., "Secure/Multipurpose Internet Mail Extensions
         (S/MIME) Version 3.1 Message Specification", RFC 3851,
         July 2004.

   [46]  Internet Assigned Number Authority (IANA), "IANA Mail
         Parameters", 2007,
         <http://www.iana.org/assignments/mail-parameters>.

   [47]  Internet Assigned Number Authority (IANA), "Address Literal
         Tags", 2007,
         <http://www.iana.org/assignments/address-literal-tags>.
```

---
# **Appendix A.  TCP Transport Service**

TCP 연결은 8비트 바이트 전송을 지원합니다. SMTP 데이터는 7비트 ASCII 문자입니다. 각 문자는 상위 비트가 0으로 지워진 8비트 바이트로 전송됩니다. 서비스 확장은 메시지 본문의 일부로 또는 특별히 설계된 경우 SMTP 명령이나 응답에서 전체 8비트 데이터 바이트의 전송을 허용하도록 이 규칙을 수정할 수 있습니다.

---
# **Appendix B.  Generating SMTP Commands from RFC 822 Header Fields**

일부 시스템은 메일 제출 프로토콜에서만 RFC 822 헤더 섹션을 사용하거나, 해당 메시지가 UA에서 MTA로 전달될 때 RFC 822 헤더 필드에서 SMTP 명령을 생성합니다. MTA-UA 프로토콜은 어떤 인터넷 표준에서도 다루지 않는 개인적인 문제이지만 이 접근 방식에는 문제가 있습니다. 예를 들어, 개념적으로 메일 봉투에 속하는 정보가 처리 초기에 헤더 필드 정보에서 분리되지 않고 별도로 유지되는 경우 "bcc" 복사본 및 재배포 목록을 적절하게 처리하는 데 문제가 반복적으로 발생했습니다.

UA는 메시지 자체와 별도로 봉투를 초기\("제출 클라이언트"\) MTA에 제공하는 것이 좋습니다. 그러나 봉투가 제공되지 않으면 SMTP 명령은 다음과 같이 생성되어야 합니다.\(SHOULD\)

1. TO, CC 또는 BCC 헤더 필드의 각 수신자 주소는 RCPT 명령에 복사되어야 합니다\(큐잉 또는 전달에 필요한 경우 여러 메시지 복사본 생성\). 여기에는 RFC 822 "그룹"에 나열된 모든 주소가 포함됩니다. 모든 BCC 헤더 필드는 헤더 섹션에서 제거되어야 합니다. 이 프로세스가 완료되면 나머지 헤더 필드를 검사하여 적어도 하나의 TO, CC 또는 BCC 헤더 필드가 남아 있는지 확인해야 합니다. 그렇지 않은 경우 추가 정보가 없는 BCC 헤더 필드는 \[4\]에 지정된 대로 삽입되어야 합니다.\(SHOULD, SHOULD, SHOULD, SHOULD\)

2. MAIL 명령의 반환 주소는 가능하다면 제출하는\(로컬\) 사용자의 시스템 ID에서 파생되어야 하며, 그렇지 않으면 "From:" 헤더 필드에서 파생되어야 합니다. 사용 가능한 시스템 ID가 있는 경우 From 헤더 필드의 주소와 다르면 Sender 헤더 필드에도 복사해야 합니다. \(이미 존재했던 모든 Sender 헤더 필드는 제거되어야 합니다.\) 시스템은 제출자가 봉투 반환 주소를 무시할 수 있는 방법을 제공할 수 있지만 권한이 있는 사용자에게만 사용을 제한할 수 있습니다. 이렇게 하면 메일 위조를 방지할 수는 없지만 발생률을 줄일 수 있습니다. 섹션 7.1을 참조하세요.\(SHOULD, SHOULD, SHOULD\)

MTA가 이러한 방식으로 사용되는 경우 전송되는 메시지가 유효한지 확인하는 책임을 집니다. 유효성을 확인하고 도착 시 유효하지 않은 메시지를 처리\(또는 반환\)하는 메커니즘은 MUA-MTA 인터페이스의 일부이며 이 사양에서는 다루지 않습니다.

표준 RFC 822 정보만을 기반으로 하는 제출 프로토콜은 외부\(SMTP가 아닌\) 메일 시스템에서 SMTP 환경으로 메시지를 게이트웨이하는 데 사용되어서는 안 됩니다. 엔벨로프를 구성하기 위한 추가 정보는 보조 헤더 필드이든 외부 시스템의 엔벨로프이든 다른 환경의 일부 소스에서 나와야 합니다.\(MUST NOT\)

헤더 "받는 사람" 및 "참조" 필드만 사용하여 메시지를 게이트웨이하려는 시도로 인해 메일 루프가 반복적으로 발생하고 인터넷 메일 환경의 올바른 작동에 반대되는 기타 동작이 발생했습니다. 이러한 문제는 메시지가 인터넷 메일링 목록에서 시작되어 봉투 정보를 사용하여 외부 환경으로 배포될 때 특히 일반적이었습니다. 이러한 메시지가 헤더 섹션만 있는 재메일러에 의해 처리되면 인터넷 환경\(및 메일링 목록\)으로의 루프백이 거의 불가피해집니다.

---
# **Appendix C.  Source Routes**

역사적으로 <reverse-path\>는 호스트 및 소스 사서함의 역방향 소스 라우팅 목록이었습니다. <reverse-path\>의 첫 번째 호스트는 역사적으로 MAIL 명령을 보내는 호스트였습니다. 현재 소스 경로는 역방향 경로에 표시되어서는 안 됩니다. 마찬가지로 <forward-path\>는 호스트의 소스 라우팅 목록과 대상 사서함일 수 있습니다. 그러나 일반적으로 <forward-path\>는 필요한 경우 라우팅 정보를 제공하기 위해 도메인 이름 시스템에 의존하여 사서함과 도메인 이름만 포함해야 합니다. 소스 경로의 사용은 더 이상 사용되지 않습니다\(부록 F.2 참조\). 서버는 섹션 3.3 및 부록 F.2에 설명된 대로 이를 수신하고 처리할 준비가 되어 있어야 하지만 클라이언트는 이를 전송해서는 안 되며 이 섹션은 컨텍스트를 제공하기 위해서만 현재 사양에 포함되어 있습니다. 전체 소스 경로 구현을 기대하지 않는 클라이언트 또는 후속 서버를 혼동시킬 수 있는 서버 작업을 방지하기 위해 RFC 821의 자료에서 다소 수정되었습니다.\(SHOULD NOT, SHOULD, MUST\)

릴레이 목적의 경우 전달 경로는 "@ONE,@TWO:JOE@THREE" 형식의 소스 경로일 수 있습니다. 여기서 ONE, TWO 및 THREE는 정규화된 도메인 이름이어야 합니다. 이 형식은 주소와 경로의 구별을 강조하는 데 사용됩니다. 메일함\(여기서 JOE@THREE\)은 절대 주소이고, 경로는 그곳으로 가는 방법에 대한 정보입니다. 두 개념을 혼동해서는 안 됩니다.\(MUST\)

소스 경로를 사용하는 경우 RFC 821과 아래 텍스트를 참조하여 구성 및 업데이트 메커니즘을 확인해야 합니다.

앞으로 경로. 소스 경로\(예: 전달 경로 목록의 첫 번째로 나타나는 도메인 이름\)를 통해 도달하는 서버는 메시지를 전달하기 전에 해당 도메인 이름이 나타나는 모든 전달 경로에서 해당 도메인 이름을 제거해야 하며 다음을 수행할 수 있습니다. 다른 모든 소스 라우팅 정보를 제거합니다. 역방향 경로는 이 사양을 준수하는 서버에 의해 업데이트되어서는 안 됩니다.\(MUST, SHOULD NOT\)

정방향 경로와 역방향 경로는 SMTP 명령과 응답에 나타나지만 반드시 메시지에는 나타나지는 않습니다. 즉, 이러한 경로, 특히 이 구문이 메시지 헤더 섹션의 "To:", "From:", "CC:" 등 필드에 나타날 필요가 없습니다. 반대로, SMTP 서버는 메시지 헤더 필드에서 최종 메시지 라우팅 정보를 파생해서는 안 됩니다.\(MUST NOT\)

위의 권장 사항에도 불구하고 호스트 목록이 존재하는 경우 이는 "역방향" 소스 경로이며 메일이 목록의 각 호스트를 통해 릴레이되었음을 나타냅니다\(목록의 첫 번째 호스트가 가장 최근 릴레이임\). 이 목록은 보낸 사람에게 배달 못 함 알림을 반환하기 위한 소스 경로로 사용됩니다. 여기의 권장 사항과 달리 릴레이 호스트가 목록의 시작 부분에 자신을 추가하는 경우 메일이 온 전송 환경의 이름이 아닌 메일을 중계하는 전송 환경에 알려진 이름을 사용해야 합니다. \(다른 경우\). 일부 릴레이 호스트는 자신의 이름을 역방향 소스 경로에 추가하고 다른 호스트는 추가하지 않아 라우팅 목록에 불연속성이 발생하는 상황이 쉽게 발생할 수 있습니다. 이는 메시지를 반환해야 하는 서버가 소스 경로를 완전히 무시하고 단순히 사서함에 지정된 도메인을 사용해야 하는 또 다른 이유입니다.\(MUST, SHOULD\)

---
# **Appendix D.  Scenarios**

이 섹션에서는 여러 유형의 SMTP 세션에 대한 전체 시나리오를 제공합니다. 예에서 "C:"는 SMTP 클라이언트가 말한 내용을 나타내고 "S:"는 SMTP 서버가 말한 내용을 나타냅니다.

---
### **D.1.  A Typical SMTP Transaction Scenario**

이 SMTP 예는 호스트 bar.com에서 Smith가 보낸 메일과 호스트 foo.com에서 Jones, Green 및 Brown에게 보낸 메일을 보여줍니다. 여기서는 bar.com 호스트가 foo.com 호스트에 직접 접속한다고 가정합니다. Jones와 Brown의 우편물이 허용됩니다. Green은 foo.com 호스트에 사서함이 없습니다.

S: 220 foo.com 간편 메일 전송 서비스 준비 완료

- C: EHLO bar.com S: 250-foo.com Greetings bar.com S: 250-8BITMIME S: 250-SIZE S: 250-DSN S: 250 도움말 C: 메일 보낸 사람:<Smith@bar.com\> S : 250 OK C: RCPT TO:<Jones@foo.com\> S: 250 OK C: RCPT TO:<Green@foo.com\> S: 550 여기에는 해당 사용자가 없습니다. C: RCPT TO:<Brown@foo.com\> S: 250 OK C: DATA S: 354 메일 입력 시작; <CRLF\>로 끝납니다.<CRLF\> C: 어쩌고 저쩌고... C: ...etc. 등등 등등. C: . S: 250 OK C: QUIT S: 221 foo.com 서비스가 전송 채널을 닫는 중입니다.

---
### **D.2.  Aborted SMTP Transaction Scenario**

```text
      S: 220 foo.com Simple Mail Transfer Service Ready
      C: EHLO bar.com
      S: 250-foo.com greets bar.com
      S: 250-8BITMIME
      S: 250-SIZE
      S: 250-DSN
      S: 250 HELP
      C: MAIL FROM:<Smith@bar.com>
      S: 250 OK
      C: RCPT TO:<Jones@foo.com>
      S: 250 OK
      C: RCPT TO:<Green@foo.com>
      S: 550 No such user here
      C: RSET
      S: 250 OK
      C: QUIT
      S: 221 foo.com Service closing transmission channel
```

---
### **D.3.  Relayed Mail Scenario**

1단계 - 소스 호스트에서 릴레이 호스트로

소스 호스트는 XYZ.COM\(대상 주소\)에서 DNS 조회를 수행하고 xyz.com을 가장 좋은 기본 설정으로 지정하고 foo.com을 더 낮은 기본 설정으로 지정하는 DNS MX 레코드를 찾습니다. xyz.com에 대한 연결을 열려고 시도했지만 실패합니다. 그런 다음 다음 대화 상자를 통해 foo.com에 대한 연결을 엽니다.

S: 220 foo.com 간편 메일 전송 서비스 준비 완료

- C: EHLO bar.com S: 250-foo.com Greetings bar.com S: 250-8BITMIME S: 250-SIZE S: 250-DSN S: 250 HELP C: MAIL FROM:<JQP@bar.com\> S : 250 OK C: RCPT TO:<Jones@XYZ.COM\> S: 250 OK C: DATA S: 354 메일 입력 시작; <CRLF\>로 끝납니다.<CRLF\> C: 날짜: 1998년 5월 21일 목요일 05:33:29 -0700 C: 보낸 사람: John Q. Public <JQP@bar.com\> C: 제목: 다음 이사회 회의 C: 받는 사람: Jones@xyz.com C: C: Bill: C: 다음 이사회 회의는 화요일 C:입니다. 답: 존. 씨: . S: 250 OK C: QUIT S: 221 foo.com 서비스가 전송 채널을 닫는 중입니다.

2단계 - 호스트를 대상 호스트로 릴레이

메시지를 받은 foo.com은 이제 xyz.com에서 DNS 조회를 수행합니다. 동일한 MX 레코드 세트를 찾았지만 자신을 가리키는 레코드\(또는 선호도가 더 낮은 다른 호스트\)를 사용할 수는 없습니다. xyz.com 자체에 대한 연결을 시도하고 성공합니다. 그런 다음 우리는 다음을 가집니다:

```text
           S: 220 xyz.com Simple Mail Transfer Service Ready
           C: EHLO foo.com
           S: 250 xyz.com is on the air
           C: MAIL FROM:<JQP@bar.com>
           S: 250 OK
           C: RCPT TO:<Jones@XYZ.COM>
           S: 250 OK
           C: DATA
           S: 354 Start mail input; end with <CRLF>.<CRLF>
           C: Received: from bar.com by foo.com ; Thu, 21 May 1998
           C:     05:33:29 -0700
           C: Date: Thu, 21 May 1998 05:33:22 -0700
           C: From: John Q. Public <JQP@bar.com>
           C: Subject:  The Next Meeting of the Board
           C: To: Jones@xyz.com
           C:
           C: Bill:
           C: The next meeting of the board of directors will be
           C: on Tuesday.
           C:                         John.
           C: .
           S: 250 OK
           C: QUIT
           S: 221 foo.com Service closing transmission channel
```

---
### **D.4.  Verifying and Sending Scenario**

S: 220 foo.com 간편 메일 전송 서비스 준비 완료

- C: EHLO bar.com S: 250-foo.com Greetings bar.com S: 250-8BITMIME S: 250-SIZE S: 250-DSN S: 250-VRFY S: 250 HELP C: VRFY Crispin S: 250 Mark Crispin <Admin.MRC@foo.com\> C: MAIL FROM:<EAK@bar.com\> S: 250 OK C: RCPT TO:<Admin.MRC@foo.com\> S: 250 OK C: DATA S: 354 메일 입력을 시작합니다. <CRLF\>로 끝납니다.<CRLF\> C: 어쩌고 저쩌고... C: ...etc. 등등 등등. C: . S: 250 OK C: QUIT S: 221 foo.com 서비스가 전송 채널을 닫는 중입니다.

---
# **Appendix E.  Other Gateway Issues**

일반적으로 인터넷과 다른 메일 시스템 사이의 게이트웨이는 관련된 두 메일 시스템 사이의 경계를 넘어 계층화 의미를 보존하려고 시도해야 합니다\(SHOULD\). 매핑\(예: 한 시스템의 봉투 정보를 다른 시스템의 메시지 헤더 섹션이나 본문으로 매핑\)을 통해 지름길을 시도하는 게이트웨이 변환 접근 방식은 일반적으로 중요한 측면에서 부적절한 것으로 입증되었습니다. 봉투와 헤더 섹션을 모두 지원하지 않는 환경과 인터넷 메일 간의 변환 시스템은 일부 정보 손실이 거의 불가피하다는 점을 이해하고 작성되어야 합니다.\(SHOULD\)

---
# **Appendix F.  Deprecated Features of RFC 821**

RFC 821의 몇 가지 기능은 문제가 있는 것으로 입증되었으며 인터넷 메일에 사용해서는 안 됩니다.\(SHOULD NOT\)

---
### **F.1.  TURN**

RFC 821에 설명된 이 명령은 클라이언트와 서버 역할 전환을 요청하는 호스트의 강력한 인증이 없는 경우 올바른 대상에서 메일을 전환하는 데 쉽게 사용될 수 있으므로 중요한 보안 문제를 제기합니다. 그 사용은 더 이상 사용되지 않습니다. 서버가 클라이언트를 인증할 수 없다면 SMTP 시스템은 이를 사용해서는 안 됩니다.\(SHOULD NOT\)

---
### **F.2.  Source Routing**

RFC 821은 일련의 릴레이를 통해 한 호스트에서 다른 호스트로 메일을 전달하기 위해 명시적 소스 라우팅 개념을 활용했습니다. 일반 메일 트래픽에서 소스 경로를 활용해야 하는 요구 사항은 도메인 이름 시스템 "MX" 레코드의 도입으로 제거되었으며 이에 대한 마지막 중요한 정당성은 RFC 1123에서 다음과 같은 명확한 요구 사항을 도입함으로써 제거되었습니다. @"는 모두 정규화된 도메인 이름이어야 합니다. 결과적으로 원본 경로 사용에 대한 유일한 남은 정당성은 매우 오래된 SMTP 클라이언트 또는 MUA에 대한 지원과 메일 시스템 디버깅입니다. 그러나 후자의 상황과 관련 DNS 레코드 문제와 같은 심각하지만 일시적인 문제를 해결하기 위해 메일을 라우팅하는 데 여전히 유용할 수 있습니다.

SMTP 서버는 이 문서의 본문과 RFC 1123에 지정된 대로 소스 경로 구문을 계속해서 수락해야 합니다. 필요한 경우 경로를 무시하고 주소의 대상 도메인만 활용할 수 있습니다. 소스 경로를 활용하는 경우 메시지는 주소에 표시된 첫 번째 도메인으로 전송되어야 합니다. 특히, 서버는 소스 경로 내의 지름길을 추측해서는 안 됩니다.\(MUST, MAY, MUST, MUST NOT\)

클라이언트는 방화벽이나 메일 시스템 구성 오류를 디버깅하거나 잠재적으로 릴레이하는 등 비정상적인 상황을 제외하고는 명시적 소스 라우팅을 활용해서는 안 됩니다.\(SHOULD NOT\)

---
### **F.3.  HELO**

섹션 3.1 및 4.1.1에서 설명한 대로 서버가 전자를 수락할 경우 HELO 대신 EHLO를 사용해야 합니다. 서버는 이전 클라이언트를 지원하기 위해 계속해서 HELO를 수락하고 처리해야 합니다.\(SHOULD, MUST\)

---
### **F.4.  #-literals**

RFC 821은 인터넷 주소를 파운드 기호\("#"\)가 앞에 붙은 10진 정수 호스트 번호로 지정하기 위해 제공되었습니다. 실제로 이 형식은 TCP/IP가 도입된 이후 더 이상 사용되지 않습니다. 더 이상 사용되지 않으며 사용하면 안 됩니다.\(MUST NOT\)

---
### **F.5.  Dates and Years**

SMTP 클라이언트나 서버\(예: 추적 헤더 필드\)가 메시지에 날짜를 삽입하는 경우 4자리 연도를 사용해야 합니다. 두 자리 연도는 더 이상 사용되지 않습니다. 인터넷 메일 시스템에서는 세 자리 연도가 허용되지 않습니다.\(MUST\)

---
### **F.6.  Sending versus Mailing**

사용자의 사서함에 메시지를 전달하기 위한 메커니즘을 지정하는 것 외에도 RFC 821은 메시지를 사용자의 터미널 화면에 직접 전달하기 위한 선택적 추가 명령을 제공했습니다. 이러한 명령\(SEND, SAML, SOML\)은 거의 구현되지 않았으며 워크스테이션 기술의 변경과 다른 프로토콜의 도입으로 인해 구현되는 경우에도 더 이상 사용되지 않을 수 있습니다.

클라이언트는 SEND, SAML 또는 SOML을 서비스로 제공해서는 안 됩니다. 서버는 이를 구현할 수 있습니다. 서버에 의해 구현되는 경우 RFC 821에 지정된 구현 모델을 사용해야 하며 명령 이름은 EHLO 명령에 대한 응답으로 게시되어야 합니다.\(SHOULD NOT, MAY, MUST\)

---
# **Author's Address**

```text
   John C. Klensin
   1770 Massachusetts Ave, Suite 322
   Cambridge, MA  02140
   USA

   EMail: john+smtp@jck.com
```

---
# **Full Copyright Statement**

저작권 \(C\) IETF 트러스트\(2008\).

이 문서는 BCP 78에 포함된 권리, 라이선스 및 제한 사항의 적용을 받으며 여기에 명시된 경우를 제외하고 작성자는 모든 권리를 보유합니다.

이 문서 및 여기에 포함된 정보는 "있는 그대로" 제공되며 기여자, 기여자가 대표하거나 후원하는 조직\(있는 경우\), 인터넷 협회, IETF 트러스트 및 인터넷 엔지니어링 태스크포스는 모든 내용을 부인합니다. 여기에 포함된 정보의 사용이 특정 목적에 대한 상품성 또는 적합성에 대한 권리 또는 묵시적 보증을 침해하지 않는다는 보증을 포함하되 이에 국한되지 않는 명시적 또는 묵시적 보증.

---
# **Intellectual Property**

IETF는 이 문서에 설명된 기술의 구현 또는 사용과 관련이 있다고 주장할 수 있는 지적 재산권 또는 기타 권리의 유효성 또는 범위 또는 그러한 권리에 따른 라이센스의 범위에 대해 어떠한 입장도 취하지 않습니다. 는 가능하다; 또한 그러한 권리를 식별하기 위해 독립적인 노력을 기울였다는 것을 나타내지 않습니다. RFC 문서의 권리와 관련된 절차에 대한 정보는 BCP 78 및 BCP 79에서 찾을 수 있습니다.

IETF 사무국에 제출된 IPR 공개 사본 및 사용 가능한 라이선스에 대한 보증 또는 이 사양의 구현자 또는 사용자가 이러한 독점권 사용에 대한 일반 라이선스 또는 허가를 얻으려는 시도의 결과를 얻을 수 있습니다. http://www.ietf.org/ipr의 IETF 온라인 IPR 저장소에서.

IETF는 이 표준을 구현하는 데 필요할 수 있는 기술을 포함할 수 있는 저작권, 특허 또는 특허 출원 또는 기타 소유권에 관심을 갖도록 이해 당사자를 초대합니다. 정보를 IETF\(ietf-ipr@ietf.org\)로 보내주십시오.
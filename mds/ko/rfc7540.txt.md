

```text
Internet Engineering Task Force (IETF)                         M. Belshe
Request for Comments: 7540                                         BitGo
Category: Standards Track                                        R. Peon
ISSN: 2070-1721                                              Google, Inc
                                                         M. Thomson, Ed.
                                                                 Mozilla
                                                                May 2015

             Hypertext Transfer Protocol Version 2 (HTTP/2)
```

---
# **Abstract**

이 사양은 HTTP 버전 2\(HTTP/2\)라고 하는 HTTP\(Hypertext Transfer Protocol\) 의미론의 최적화된 표현을 설명합니다. HTTP/2는 헤더 필드 압축을 도입하고 동일한 연결에서 여러 동시 교환을 허용함으로써 네트워크 리소스를 보다 효율적으로 사용하고 대기 시간에 대한 인식을 줄입니다. 또한 서버에서 클라이언트로의 요청되지 않은 표현 푸시를 도입합니다.

이 사양은 HTTP/1.1 메시지 구문의 대안이지만 폐기되지는 않습니다. HTTP의 기존 의미 체계는 변경되지 않은 상태로 유지됩니다.

---
# **Status of This Memo**

이것은 인터넷 표준 추적 문서입니다.

이 문서는 IETF\(Internet Engineering Task Force\)의 제품입니다. 이는 IETF 커뮤니티의 합의를 나타냅니다. 공개 검토를 받았으며 IESG\(Internet Engineering Steering Group\)의 출판 승인을 받았습니다. 인터넷 표준에 대한 자세한 내용은 RFC 5741의 섹션 2에서 확인할 수 있습니다.

이 문서의 현재 상태, 오류 및 이에 대한 피드백 제공 방법에 대한 정보는 http://www.rfc-editor.org/info/rfc7540에서 얻을 수 있습니다.

---
# **Copyright Notice**

Copyright \(c\) 2015 IETF Trust 및 문서 작성자로 확인된 사람. 판권 소유.

이 문서는 이 문서의 발행일에 유효한 BCP 78 및 IETF 문서에 관한 IETF 트러스트의 법적 조항\(http://trustee.ietf.org/license-info\)의 적용을 받습니다. 이 문서와 관련된 귀하의 권리 및 제한 사항을 설명하므로 이 문서를 주의 깊게 검토하십시오. 이 문서에서 추출한 코드 구성 요소는 Trust Legal Provisions의 섹션 4.e에 설명된 대로 Simplified BSD License 텍스트를 포함해야 하며 Simplified BSD License에 설명된 대로 보증 없이 제공됩니다.

---
# **Table of Contents**

```text
   1. Introduction ....................................................4
   2. HTTP/2 Protocol Overview ........................................5
      2.1. Document Organization ......................................6
      2.2. Conventions and Terminology ................................6
   3. Starting HTTP/2 .................................................7
      3.1. HTTP/2 Version Identification ..............................8
      3.2. Starting HTTP/2 for "http" URIs ............................8
           3.2.1. HTTP2-Settings Header Field .........................9
      3.3. Starting HTTP/2 for "https" URIs ..........................10
      3.4. Starting HTTP/2 with Prior Knowledge ......................10
      3.5. HTTP/2 Connection Preface .................................11
   4. HTTP Frames ....................................................12
      4.1. Frame Format ..............................................12
      4.2. Frame Size ................................................13
      4.3. Header Compression and Decompression ......................14
   5. Streams and Multiplexing .......................................15
      5.1. Stream States .............................................16
           5.1.1. Stream Identifiers .................................21
           5.1.2. Stream Concurrency .................................22
      5.2. Flow Control ..............................................22
           5.2.1. Flow-Control Principles ............................23
           5.2.2. Appropriate Use of Flow Control ....................24
      5.3. Stream Priority ...........................................24
           5.3.1. Stream Dependencies ................................25
           5.3.2. Dependency Weighting ...............................26
           5.3.3. Reprioritization ...................................26
           5.3.4. Prioritization State Management ....................27
           5.3.5. Default Priorities .................................28
      5.4. Error Handling ............................................28
           5.4.1. Connection Error Handling ..........................29
           5.4.2. Stream Error Handling ..............................29
           5.4.3. Connection Termination .............................30
      5.5. Extending HTTP/2 ..........................................30
   6. Frame Definitions ..............................................31
      6.1. DATA ......................................................31
      6.2. HEADERS ...................................................32
      6.3. PRIORITY ..................................................34
      6.4. RST_STREAM ................................................36
      6.5. SETTINGS ..................................................36
           6.5.1. SETTINGS Format ....................................38
           6.5.2. Defined SETTINGS Parameters ........................38
           6.5.3. Settings Synchronization ...........................39
      6.6. PUSH_PROMISE ..............................................40
      6.7. PING ......................................................42
      6.8. GOAWAY ....................................................43
      6.9. WINDOW_UPDATE .............................................46
           6.9.1. The Flow-Control Window ............................47
           6.9.2. Initial Flow-Control Window Size ...................48
           6.9.3. Reducing the Stream Window Size ....................49
      6.10. CONTINUATION .............................................49
   7. Error Codes ....................................................50
   8. HTTP Message Exchanges .........................................51
      8.1. HTTP Request/Response Exchange ............................52
           8.1.1. Upgrading from HTTP/2 ..............................53
           8.1.2. HTTP Header Fields .................................53
           8.1.3. Examples ...........................................57
           8.1.4. Request Reliability Mechanisms in HTTP/2 ...........60
      8.2. Server Push ...............................................60
           8.2.1. Push Requests ......................................61
           8.2.2. Push Responses .....................................63
      8.3. The CONNECT Method ........................................64
   9. Additional HTTP Requirements/Considerations ....................65
      9.1. Connection Management .....................................65
           9.1.1. Connection Reuse ...................................66
           9.1.2. The 421 (Misdirected Request) Status Code ..........66
      9.2. Use of TLS Features .......................................67
           9.2.1. TLS 1.2 Features ...................................67
           9.2.2. TLS 1.2 Cipher Suites ..............................68
   10. Security Considerations .......................................69
      10.1. Server Authority .........................................69
      10.2. Cross-Protocol Attacks ...................................69
      10.3. Intermediary Encapsulation Attacks .......................70
      10.4. Cacheability of Pushed Responses .........................70
      10.5. Denial-of-Service Considerations .........................70
           10.5.1. Limits on Header Block Size .......................71
           10.5.2. CONNECT Issues ....................................72
      10.6. Use of Compression .......................................72
      10.7. Use of Padding ...........................................73
      10.8. Privacy Considerations ...................................73
   11. IANA Considerations ...........................................74
      11.1. Registration of HTTP/2 Identification Strings ............74
      11.2. Frame Type Registry ......................................75
      11.3. Settings Registry ........................................75
      11.4. Error Code Registry ......................................76
      11.5. HTTP2-Settings Header Field Registration .................77
      11.6. PRI Method Registration ..................................78
      11.7. The 421 (Misdirected Request) HTTP Status Code ...........78
      11.8. The h2c Upgrade Token ....................................78
   12. References ....................................................79
      12.1. Normative References .....................................79
      12.2. Informative References ...................................81
   Appendix A. TLS 1.2 Cipher Suite Black List .......................83
   Acknowledgements ..................................................95
   Authors' Addresses ................................................96
```

---
## **1.  Introduction**

HTTP\(Hypertext Transfer Protocol\)는 매우 성공적인 프로토콜입니다. 그러나 HTTP/1.1이 기본 전송을 사용하는 방식\(\[RFC7230\], 섹션 6\)에는 오늘날 애플리케이션 성능에 전반적으로 부정적인 영향을 미치는 몇 가지 특성이 있습니다.

특히 HTTP/1.0은 주어진 TCP 연결에서 한 번에 하나의 요청만 미결 상태로 허용했습니다. HTTP/1.1은 요청 파이프라이닝을 추가했지만 이것은 요청 동시성을 부분적으로만 처리했으며 여전히 HOL\(head-of-line\) 차단 문제를 겪고 있습니다. 따라서 많은 요청을 해야 하는 HTTP/1.0 및 HTTP/1.1 클라이언트는 동시성을 달성하여 대기 시간을 줄이기 위해 서버에 대한 다중 연결을 사용합니다.

또한 HTTP 헤더 필드는 종종 반복적이고 장황하여 불필요한 네트워크 트래픽을 유발하고 초기 TCP\[TCP\] 혼잡 창을 빠르게 채웁니다. 이로 인해 새 TCP 연결에서 여러 요청이 생성될 때 과도한 대기 시간이 발생할 수 있습니다.

HTTP/2는 기본 연결에 대한 HTTP 의미 체계의 최적화된 매핑을 정의하여 이러한 문제를 해결합니다. 특히 동일한 연결에서 요청 및 응답 메시지의 인터리빙을 허용하고 HTTP 헤더 필드에 효율적인 코딩을 사용합니다. 또한 요청의 우선 순위를 지정하여 더 중요한 요청을 더 빨리 완료할 수 있도록 하여 성능을 더욱 향상시킵니다.

결과 프로토콜은 HTTP/1.x에 비해 더 적은 TCP 연결을 사용할 수 있기 때문에 네트워크에 더 친숙합니다. 이것은 다른 흐름과의 경쟁이 적고 수명이 긴 연결을 의미하므로 사용 가능한 네트워크 용량을 더 잘 활용할 수 있습니다.

마지막으로 HTTP/2는 바이너리 메시지 프레이밍을 사용하여 보다 효율적인 메시지 처리를 가능하게 합니다.

---
## **2.  HTTP/2 Protocol Overview**

HTTP/2는 HTTP 의미 체계에 최적화된 전송을 제공합니다. HTTP/2는 HTTP/1.1의 모든 핵심 기능을 지원하지만 여러 면에서 더 효율적인 것을 목표로 합니다.

HTTP/2의 기본 프로토콜 단위는 프레임입니다\(4.1절\). 각 프레임 유형은 다른 용도로 사용됩니다. 예를 들어, HEADERS 및 DATA 프레임은 HTTP 요청 및 응답의 기초를 형성합니다\(섹션 8.1\). SETTINGS, WINDOW\_UPDATE 및 PUSH\_PROMISE와 같은 다른 프레임 유형은 다른 HTTP/2 기능을 지원하는 데 사용됩니다.

요청의 다중화는 자체 스트림과 연결된 각 HTTP 요청/응답 교환을 가짐으로써 달성됩니다\(섹션 5\). 스트림은 대체로 서로 독립적이므로 차단되거나 중단된 요청 또는 응답이 다른 스트림의 진행을 방해하지 않습니다.

흐름 제어 및 우선 순위 지정은 다중화된 스트림을 효율적으로 사용할 수 있도록 합니다. 흐름 제어\(섹션 5.2\)는 수신자가 사용할 수 있는 데이터만 전송되도록 하는 데 도움이 됩니다. 우선 순위 지정\(섹션 5.3\)은 제한된 리소스를 가장 중요한 스트림으로 먼저 보낼 수 있도록 합니다.

HTTP/2는 서버가 클라이언트에 응답을 푸시할 수 있는 새로운 상호 작용 모드를 추가합니다\(섹션 8.2\). 서버 푸시를 통해 서버는 잠재적인 대기 시간 증가와 일부 네트워크 사용량을 교환하여 클라이언트가 필요로 할 것으로 예상하는 클라이언트에 데이터를 예측적으로 보낼 수 있습니다. 서버는 PUSH\_PROMISE 프레임으로 보내는 요청을 합성하여 이를 수행합니다. 그런 다음 서버는 별도의 스트림에서 합성 요청에 대한 응답을 보낼 수 있습니다.

연결에 사용되는 HTTP 헤더 필드에는 많은 양의 중복 데이터가 포함될 수 있으므로 이를 포함하는 프레임은 압축됩니다\(섹션 4.3\). 이는 일반적인 경우 요청 크기에 특히 유리한 영향을 미치므로 많은 요청을 하나의 패킷으로 압축할 수 있습니다.

---
### **2.1.  Document Organization**

HTTP/2 사양은 네 부분으로 나뉩니다.

o HTTP/2 시작하기\(섹션 3\)는 HTTP/2 연결이 시작되는 방법을 다룹니다.

o 프레임\(섹션 4\) 및 스트림\(섹션 5\) 계층은 HTTP/2 프레임이 구조화되고 다중화된 스트림으로 형성되는 방식을 설명합니다.

o 프레임\(섹션 6\) 및 오류\(섹션 7\) 정의에는 HTTP/2에서 사용되는 프레임 및 오류 유형에 대한 세부 정보가 포함됩니다.

o HTTP 매핑\(섹션 8\) 및 추가 요구 사항\(섹션 9\)은 프레임과 스트림을 사용하여 HTTP 의미 체계를 표현하는 방법을 설명합니다.

일부 프레임 및 스트림 계층 개념은 HTTP와 분리되어 있지만 이 사양은 완전히 일반적인 프레임 계층을 정의하지 않습니다. 프레임 및 스트림 계층은 HTTP 프로토콜 및 서버 푸시의 요구 사항에 맞게 조정됩니다.

---
### **2.2.  Conventions and Terminology**

이 문서에서 키워드 "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY" 및 "OPTIONAL"은 다음과 같습니다. RFC 2119\[RFC2119\]에 설명된 대로 해석됩니다.\(MUST NOT\)

모든 숫자 값은 네트워크 바이트 순서입니다. 달리 명시되지 않는 한 값은 부호가 없습니다. 리터럴 값은 적절하게 10진수 또는 16진수로 제공됩니다. 16진수 리터럴은 10진수 리터럴과 구별하기 위해 접두사 "0x"가 붙습니다.

다음 용어가 사용됩니다.

클라이언트: HTTP/2 연결을 시작하는 끝점입니다. 클라이언트는 HTTP 요청을 보내고 HTTP 응답을 받습니다.

연결: 두 끝점 간의 전송 계층 연결입니다.

연결 오류: 전체 HTTP/2에 영향을 미치는 오류

-  연결.

끝점: 연결의 클라이언트 또는 서버입니다.

프레임: HTTP/2 내에서 가장 작은 통신 단위

- 헤더와 프레임 유형에 따라 구조화된 옥텟의 가변 길이 시퀀스로 구성된 연결.

피어: 끝점입니다. 특정 엔드포인트를 논의할 때 "피어"는 논의의 기본 주제에 대해 원격인 엔드포인트를 나타냅니다.

수신기: 프레임을 수신하는 끝점입니다.

보낸 사람: 프레임을 전송하는 끝점입니다.

서버: HTTP/2 연결을 수락하는 끝점입니다. 서버는 HTTP 요청을 받고 HTTP 응답을 보냅니다.

스트림: HTTP/2 연결 내에서 프레임의 양방향 흐름입니다.

스트림 오류: 개별 HTTP/2 스트림의 오류입니다.

마지막으로 "게이트웨이", "중개자", "프록시" 및 "터널"이라는 용어는 \[RFC7230\]의 섹션 2.3에 정의되어 있습니다. 중개자는 서로 다른 시간에 클라이언트와 서버 역할을 모두 수행합니다.

"페이로드 본문"이라는 용어는 \[RFC7230\]의 섹션 3.3에 정의되어 있습니다.

---
## **3.  Starting HTTP/2**

HTTP/2 연결은 TCP 연결\(\[TCP\]\) 위에서 실행되는 애플리케이션 계층 프로토콜입니다. 클라이언트는 TCP 연결 개시자입니다.

HTTP/2는 HTTP/1.1에서 사용하는 것과 동일한 "http" 및 "https" URI 체계를 사용합니다. HTTP/2는 동일한 기본 포트 번호\("http" URI의 경우 80, "https" URI의 경우 443\)를 공유합니다. 결과적으로 "http://example.org/foo" 또는 "https://example.com/bar"와 같은 대상 리소스 URI에 대한 요청을 처리하는 구현은 먼저 업스트림 서버\(즉시 피어가 클라이언트가 연결을 설정하려는 경우\) HTTP/2를 지원합니다.

HTTP/2에 대한 지원을 결정하는 방법은 "http" 및 "https" URI에 따라 다릅니다. "http" URI에 대한 검색은 섹션 3.2에 설명되어 있습니다. "https" URI에 대한 검색은 섹션 3.3에 설명되어 있습니다.

---
### **3.1.  HTTP/2 Version Identification**

이 문서에 정의된 프로토콜에는 두 개의 식별자가 있습니다.

o 문자열 "h2"는 HTTP/2가 사용하는 프로토콜을 식별합니다.

- TLS\(전송 계층 보안\) \[TLS12\]. 이 식별자는 TLS 응용 계층 프로토콜 협상\(ALPN\) 확장\[TLS-ALPN\] 필드와 TLS를 통한 HTTP/2가 식별되는 모든 위치에서 사용됩니다.

- "h2" 문자열은 ALPN 프로토콜 식별자로 2옥텟 시퀀스\(0x68, 0x32\)로 직렬화됩니다.

o 문자열 "h2c"는 HTTP/2가 일반 텍스트 TCP를 통해 실행되는 프로토콜을 식별합니다. 이 식별자는 HTTP/1.1 업그레이드 헤더 필드와 TCP를 통한 HTTP/2가 식별되는 모든 위치에서 사용됩니다.

- "h2c" 문자열은 ALPN 식별자 공간에서 예약되었지만 TLS를 사용하지 않는 프로토콜을 설명합니다.

협상 "h2" 또는 "h2c"는 이 문서에 설명된 전송, 보안, 프레이밍 및 메시지 의미 체계의 사용을 의미합니다.

---
### **3.2.  Starting HTTP/2 for "http" URIs**

다음 홉에서 HTTP/2 지원에 대한 사전 지식 없이 "http" URI를 요청하는 클라이언트는 HTTP 업그레이드 메커니즘\(\[RFC7230\]의 섹션 6.7\)을 사용합니다. 클라이언트는 "h2c" 토큰과 함께 업그레이드 헤더 필드를 포함하는 HTTP/1.1 요청을 작성하여 이를 수행합니다. 이러한 HTTP/1.1 요청에는 정확히 하나의 HTTP2-Settings\(섹션 3.2.1\) 헤더 필드가 포함되어야 합니다.\(MUST\)

예를 들어:

```text
     GET / HTTP/1.1
     Host: server.example.com
     Connection: Upgrade, HTTP2-Settings
     Upgrade: h2c
     HTTP2-Settings: <base64url encoding of HTTP/2 SETTINGS payload>
```

페이로드 본문을 포함하는 요청은 클라이언트가 HTTP/2 프레임을 보낼 수 있기 전에 전체를 보내야 합니다. 이것은 큰 요청이 완전히 전송될 때까지 연결 사용을 차단할 수 있음을 의미합니다.\(MUST\)

초기 요청과 후속 요청의 동시성이 중요한 경우 추가 왕복 비용으로 OPTIONS 요청을 사용하여 HTTP/2로 업그레이드할 수 있습니다.

HTTP/2를 지원하지 않는 서버는 업그레이드 헤더 필드가 없는 것처럼 요청에 응답할 수 있습니다.

```text
     HTTP/1.1 200 OK
     Content-Length: 243
     Content-Type: text/html

     ...
```

서버는 업그레이드 헤더 필드에서 "h2" 토큰을 무시해야 합니다. "h2"가 있는 토큰의 존재는 TLS를 통한 HTTP/2를 의미하며 대신 섹션 3.3에 설명된 대로 협상됩니다.\(MUST\)

HTTP/2를 지원하는 서버는 101\(Switching Protocols\) 응답으로 업그레이드를 수락합니다. 101 응답을 종료하는 빈 줄 다음에 서버는 HTTP/2 프레임 전송을 시작할 수 있습니다. 이러한 프레임은 업그레이드를 시작한 요청에 대한 응답을 포함해야 합니다.\(MUST\)

예를 들어:

```text
     HTTP/1.1 101 Switching Protocols
     Connection: Upgrade
     Upgrade: h2c

     [ HTTP/2 connection ...
```

서버가 보낸 첫 번째 HTTP/2 프레임은 SETTINGS 프레임\(섹션 6.5\)으로 구성된 서버 연결 서문\(섹션 3.5\)이어야 합니다. 101 응답을 수신하면 클라이언트는 SETTINGS 프레임을 포함하는 연결 서문\(섹션 3.5\)을 보내야 합니다.\(MUST, MUST\)

업그레이드 전에 전송되는 HTTP/1.1 요청에는 기본 우선 순위 값\(5.3.5절\)과 함께 스트림 식별자 1\(5.1.1절 참조\)이 할당됩니다. 스트림 1은 요청이 HTTP/1.1 요청으로 완료되기 때문에 클라이언트에서 서버로 향하는 암시적으로 "절반 폐쇄"입니다\(섹션 5.1 참조\). HTTP/2 연결을 시작한 후 스트림 1이 응답에 사용됩니다.

---
#### **3.2.1.  HTTP2-Settings Header Field**

HTTP/1.1에서 HTTP/2로 업그레이드하는 요청에는 정확히 하나의 "HTTP2-Settings" 헤더 필드가 포함되어야 합니다. HTTP2-Settings 헤더 필드는 서버가 업그레이드 요청을 수락할 것으로 예상하여 제공되는 HTTP/2 연결을 제어하는 ​​매개변수를 포함하는 연결별 헤더 필드입니다.\(MUST\)

```text
     HTTP2-Settings    = token68
```

이 헤더 필드가 없거나 둘 이상이 있는 경우 서버는 HTTP/2에 대한 연결을 업그레이드하면 안 됩니다\(MUST NOT\). 서버는 이 헤더 필드를 보내면 안 됩니다.\(MUST NOT, MUST NOT\)

HTTP2-Settings 헤더 필드의 콘텐츠는 base64url 문자열\(즉, \[RFC4648\]의 섹션 5에 설명된 URL 및 파일 이름에 안전한 Base64 인코딩으로 인코딩된 SETTINGS 프레임\(섹션 6.5\)의 페이로드이며, 후행 '=' 문자 생략\). "token68"에 대한 ABNF \[RFC5234\] 생성은 \[RFC7235\]의 섹션 2.1에 정의되어 있습니다.

업그레이드는 즉시 연결에만 적용하기 위한 것이므로 HTTP2-Settings 헤더 필드를 보내는 클라이언트는 "HTTP2-Settings"가 전달되는 것을 방지하기 위해 Connection 헤더 필드의 연결 옵션으로 "HTTP2-Settings"도 보내야 합니다\(섹션 6.1 참조\). \[RFC7230\]\).\(MUST\)

서버는 다른 SETTINGS 프레임과 마찬가지로 이러한 값을 디코딩하고 해석합니다. 이러한 설정\(섹션 6.5.3\)의 명시적 승인은 필요하지 않습니다. 101 응답이 암시적 승인 역할을 하기 때문입니다. 업그레이드 요청에 이러한 값을 제공하면 클라이언트는 서버에서 프레임을 수신하기 전에 매개변수를 제공할 수 있습니다.

---
### **3.3.  Starting HTTP/2 for "https" URIs**

"https" URI에 요청하는 클라이언트는 응용 프로그램 계층 프로토콜 협상\(ALPN\) 확장\[TLS-ALPN\]과 함께 TLS\[TLS12\]를 사용합니다.

TLS를 통한 HTTP/2는 "h2" 프로토콜 식별자를 사용합니다. "h2c" 프로토콜 식별자는 클라이언트가 보내거나 서버가 선택해서는 안 됩니다. "h2c" 프로토콜 식별자는 TLS를 사용하지 않는 프로토콜을 나타냅니다.\(MUST NOT\)

TLS 협상이 완료되면 클라이언트와 서버 모두 연결 서문을 보내야 합니다\(섹션 3.5\).\(MUST\)

---
### **3.4.  Starting HTTP/2 with Prior Knowledge**

클라이언트는 특정 서버가 다른 방법으로 HTTP/2를 지원한다는 것을 알 수 있습니다. 예를 들어 \[ALT-SVC\]는 이 기능을 알리는 메커니즘을 설명합니다.

클라이언트는 반드시 연결 서문\(섹션 3.5\)을 보낸 다음 HTTP/2 프레임을 해당 서버로 즉시 보낼 수 있습니다. 서버는 연결 서문의 존재로 이러한 연결을 식별할 수 있습니다. 이것\(MUST\)

일반 텍스트 TCP를 통한 HTTP/2 연결 설정에만 영향을 미칩니다. TLS를 통해 HTTP/2를 지원하는 구현은 TLS\[TLS-ALPN\]에서 프로토콜 협상을 사용해야 합니다.\(MUST\)

마찬가지로 서버는 연결 서문을 보내야 합니다\(섹션 3.5\).\(MUST\)

추가 정보가 없다면 HTTP/2에 대한 사전 지원은 해당 서버가 향후 연결을 위해 HTTP/2를 지원할 것이라는 강력한 신호가 아닙니다. 예를 들어 서버 구성이 변경되거나, 클러스터링된 서버의 인스턴스 간에 구성이 달라지거나, 네트워크 조건이 변경될 수 있습니다.

---
### **3.5.  HTTP/2 Connection Preface**

HTTP/2에서 각 끝점은 사용 중인 프로토콜의 최종 확인으로 연결 서문을 보내고 HTTP/2 연결에 대한 초기 설정을 설정해야 합니다. 클라이언트와 서버는 각각 다른 연결 서문을 보냅니다.

클라이언트 연결 서문은 24옥텟 시퀀스로 시작하며 16진 표기법은 다음과 같습니다.

```text
     0x505249202a20485454502f322e300d0a0d0a534d0d0a0d0a
```

즉, 연결 서문은 "PRI \* HTTP/2.0\r\n\r\nSM\r\n\r\n"\) 문자열로 시작합니다. 이 시퀀스 뒤에는 비어 있을 수 있는 SETTINGS 프레임\(섹션 6.5\)이 뒤따라야 합니다. 클라이언트는 101\(스위칭 프로토콜\) 응답\(성공적인 업그레이드를 나타냄\)을 수신하는 즉시 또는 TLS 연결의 첫 번째 응용 프로그램 데이터 옥텟으로 클라이언트 연결 서문을 보냅니다. 프로토콜에 대한 서버 지원에 대한 사전 지식으로 HTTP/2 연결을 시작하는 경우 연결 설정 시 클라이언트 연결 서문이 전송됩니다.\(MUST\)

- 참고: 클라이언트 연결 서문은 HTTP/1.1 또는 HTTP/1.0 서버 및 중개자의 대부분이 추가 프레임 처리를 시도하지 않도록 선택됩니다. 이것은 \[TALKING\]에서 제기된 문제를 해결하지 않는다는 점에 유의하십시오.

서버 연결 서문은 HTTP/2 연결에서 서버가 보내는 첫 번째 프레임이어야 하는 잠재적으로 비어 있는 SETTINGS 프레임\(섹션 6.5\)으로 구성됩니다.\(MUST\)

연결 서문의 일부로 피어로부터 수신한 SETTINGS 프레임은 연결 서문을 보낸 후 승인되어야 합니다\(섹션 6.5.3 참조\).\(MUST\)

불필요한 대기 시간을 피하기 위해 클라이언트는 서버 연결 서문을 받을 때까지 기다리지 않고 클라이언트 연결 서문을 보낸 직후 서버에 추가 프레임을 보낼 수 있습니다. 그러나 서버 연결 서문 SETTINGS 프레임에는 클라이언트가 서버와 통신하는 방법을 반드시 변경하는 매개변수가 포함될 수 있다는 점에 유의해야 합니다. SETTINGS 프레임을 수신하면 클라이언트는 설정된 모든 매개변수를 존중해야 합니다. 일부 구성에서는 클라이언트가 추가 프레임을 보내기 전에 서버가 SETTINGS를 전송하여 이 문제를 피할 수 있는 기회를 제공할 수 있습니다.

클라이언트와 서버는 잘못된 연결 서문을 PROTOCOL\_ERROR 유형의 연결 오류\(섹션 5.4.1\)로 처리해야 합니다. GOAWAY 프레임\(섹션 6.8\)은 피어가 HTTP/2를 사용하지 않는다는 잘못된 서문을 나타내므로 이 경우 생략될 수 있습니다.\(MUST, MAY\)

---
## **4.  HTTP Frames**

HTTP/2 연결이 설정되면 끝점에서 프레임 교환을 시작할 수 있습니다.

---
### **4.1.  Frame Format**

모든 프레임은 고정된 9옥텟 헤더와 가변 길이 페이로드로 시작합니다.

```text
    +-----------------------------------------------+
    |                 Length (24)                   |
    +---------------+---------------+---------------+
    |   Type (8)    |   Flags (8)   |
    +-+-------------+---------------+-------------------------------+
    |R|                 Stream Identifier (31)                      |
    +=+=============================================================+
    |                   Frame Payload (0...)                      ...
    +---------------------------------------------------------------+

                          Figure 1: Frame Layout
```

프레임 헤더의 필드는 다음과 같이 정의됩니다.

길이: 부호 없는 24비트 정수로 표현되는 프레임 페이로드의 길이입니다. 2^14\(16,384\)보다 큰 값은 수신자가 SETTINGS\_MAX\_FRAME\_SIZE에 대해 더 큰 값을 설정하지 않는 한 보내서는 안 됩니다\(MUST NOT\).\(MUST NOT\)

- 프레임 헤더의 9 옥텟은 이 값에 포함되지 않습니다.

유형: 프레임의 8비트 유형입니다. 프레임 유형은 프레임의 형식과 의미를 결정합니다. 구현은 알 수 없는 유형을 가진 모든 프레임을 무시하고 폐기해야 합니다\(MUST\).\(MUST\)

플래그: 프레임 유형에 특정한 부울 플래그용으로 예약된 8비트 필드입니다.

- 플래그는 표시된 프레임 유형에 특정한 시맨틱이 할당됩니다. 특정 프레임 유형에 대해 정의된 의미가 없는 플래그는 무시해야 하며 전송 시 미설정\(0x0\) 상태로 두어야 합니다.\(MUST\)

R: 예약된 1비트 필드. 이 비트의 의미는 정의되지 않았으며 비트는 전송 시 설정되지 않은 상태\(0x0\)로 유지되어야 하며 수신 시 무시되어야 합니다\(MUST\).\(MUST\)

스트림 식별자: 부호 없는 31비트 정수로 표현되는 스트림 식별자\(섹션 5.1.1 참조\). 값 0x0은 개별 스트림이 아닌 전체 연결과 관련된 프레임용으로 예약되어 있습니다.

프레임 페이로드의 구조와 내용은 전적으로 프레임 유형에 따라 다릅니다.

---
### **4.2.  Frame Size**

프레임 페이로드의 크기는 수신기가 SETTINGS\_MAX\_FRAME\_SIZE 설정에서 알리는 최대 크기로 제한됩니다. 이 설정은 2^14\(16,384\)에서 2^24-1\(16,777,215\) 옥텟 사이의 값을 가질 수 있습니다.

모든 구현은 최대 2^14 옥텟 길이의 프레임과 9 옥텟 프레임 헤더\(섹션 4.1\)를 수신하고 최소한으로 처리할 수 있어야 합니다\(MUST\). 프레임 크기를 설명할 때 프레임 헤더의 크기는 포함되지 않습니다.\(MUST\)

- 참고: PING\(섹션 6.7\)과 같은 특정 프레임 유형은 허용되는 페이로드 데이터의 양에 추가 제한을 부과합니다.

프레임이 SETTINGS\_MAX\_FRAME\_SIZE에 정의된 크기를 초과하거나, 프레임 유형에 대해 정의된 제한을 초과하거나, 필수 프레임 데이터를 포함하기에 너무 작은 경우 엔드포인트는 FRAME\_SIZE\_ERROR의 오류 코드를 보내야 합니다\(MUST\). 전체 연결 상태를 변경할 수 있는 프레임의 프레임 크기 오류는 연결 오류로 취급되어야 합니다\(섹션 5.4.1\). 여기에는 헤더 블록\(섹션 4.3\)\(즉, HEADERS, PUSH\_PROMISE 및 CONTINUATION\), SETTINGS 및 스트림 식별자가 0인 프레임을 전달하는 모든 프레임이 포함됩니다.\(MUST, MUST\)

끝점은 프레임에서 사용 가능한 모든 공간을 사용할 의무가 없습니다. 허용된 최대 크기보다 작은 프레임을 사용하여 응답성을 향상시킬 수 있습니다. 큰 프레임을 보내면 시간에 민감한 프레임\(예: RST\_STREAM, WINDOW\_UPDATE 또는 PRIORITY\)을 보내는 데 지연이 발생할 수 있으며, 큰 프레임의 전송에 의해 차단되면 성능에 영향을 미칠 수 있습니다.

---
### **4.3.  Header Compression and Decompression**

HTTP/1에서와 마찬가지로 HTTP/2의 헤더 필드는 하나 이상의 관련 값이 있는 이름입니다. 헤더 필드는 HTTP 요청 및 응답 메시지와 서버 푸시 작업에서 사용됩니다\(섹션 8.2 참조\).

헤더 목록은 0개 이상의 헤더 필드 모음입니다. 연결을 통해 전송될 때 헤더 목록은 HTTP 헤더 압축\[COMPRESSION\]을 사용하여 헤더 블록으로 직렬화됩니다. 그런 다음 직렬화된 헤더 블록은 헤더 블록 조각이라고 하는 하나 이상의 옥텟 시퀀스로 분할되고 HEADERS\(섹션 6.2\), PUSH\_PROMISE\(섹션 6.6\) 또는 CONTINUATION\(섹션 6.10\) 프레임의 페이로드 내에서 전송됩니다.

쿠키 헤더 필드\[COOKIE\]는 HTTP 매핑에 의해 특별히 처리됩니다\(섹션 8.1.2.5 참조\).

수신 끝점은 조각을 연결하여 헤더 블록을 재조립한 다음 블록을 압축 해제하여 헤더 목록을 재구성합니다.

완전한 헤더 블록은 다음 중 하나로 구성됩니다.

o END\_HEADERS 플래그가 설정된 단일 HEADERS 또는 PUSH\_PROMISE 프레임, 또는

o END\_HEADERS 플래그가 지워진 HEADERS 또는 PUSH\_PROMISE 프레임과 하나 이상의 CONTINUATION 프레임, 여기서 마지막 CONTINUATION 프레임에는 END\_HEADERS 플래그가 설정되어 있습니다.

헤더 압축은 상태 저장입니다. 하나의 압축 컨텍스트와 하나의 압축 해제 컨텍스트가 전체 연결에 사용됩니다. 헤더 블록의 디코딩 오류는 COMPRESSION\_ERROR 유형의 연결 오류\(섹션 5.4.1\)로 처리되어야 합니다.\(MUST\)

각 헤더 블록은 개별 단위로 처리됩니다. 헤더 블록은 연속적인 프레임 시퀀스로 전송되어야 하며 다른 유형이나 다른 스트림의 인터리브 프레임이 없어야 합니다. HEADERS 또는 CONTINUATION 프레임 시퀀스의 마지막 프레임에는\(MUST\)

END\_HEADERS 플래그가 설정되었습니다. PUSH\_PROMISE 또는 CONTINUATION 프레임 시퀀스의 마지막 프레임에는 END\_HEADERS 플래그가 설정되어 있습니다. 이를 통해 헤더 블록이 단일 프레임과 논리적으로 동일할 수 있습니다.

헤더 블록 조각은 HEADERS, PUSH\_PROMISE 또는 CONTINUATION 프레임의 페이로드로만 보낼 수 있습니다. 이러한 프레임은 수신자가 유지 관리하는 압축 컨텍스트를 수정할 수 있는 데이터를 전달하기 때문입니다. HEADERS, PUSH\_PROMISE 또는 CONTINUATION 프레임을 수신하는 엔드포인트는 헤더 블록을 재조립하고 프레임을 폐기하더라도 압축 해제를 수행해야 합니다. 수신자는 헤더 블록을 압축 해제하지 않으면 COMPRESSION\_ERROR 유형의 연결 오류\(섹션 5.4.1\)로 연결을 종료해야 합니다.\(MUST\)

---
## **5.  Streams and Multiplexing**

"스트림"은 HTTP/2 연결 내에서 클라이언트와 서버 간에 교환되는 독립적인 양방향 프레임 시퀀스입니다. 스트림에는 몇 가지 중요한 특성이 있습니다.

o 단일 HTTP/2 연결은 여러 스트림의 프레임을 인터리빙하는 엔드포인트와 함께 여러 개의 동시에 열린 스트림을 포함할 수 있습니다.

o 스트림은 일방적으로 설정 및 사용하거나 클라이언트 또는 서버에서 공유할 수 있습니다.

o 스트림은 양쪽 끝점에서 닫힐 수 있습니다.

o 스트림에서 프레임이 전송되는 순서는 중요합니다. 수신자는 수신된 순서대로 프레임을 처리합니다. 특히 HEADERS와 DATA 프레임의 순서는 의미론적으로 중요하다.

o 스트림은 정수로 식별됩니다. 스트림 식별자는 스트림을 시작하는 엔드포인트에 의해 스트림에 할당됩니다.

---
### **5.1.  Stream States**

스트림의 수명 주기는 그림 2에 나와 있습니다.

```text
                                +--------+
                        send PP |        | recv PP
                       ,--------|  idle  |--------.
                      /         |        |         \
                     v          +--------+          v
              +----------+          |           +----------+
              |          |          | send H /  |          |
       ,------| reserved |          | recv H    | reserved |------.
       |      | (local)  |          |           | (remote) |      |
       |      +----------+          v           +----------+      |
       |          |             +--------+             |          |
       |          |     recv ES |        | send ES     |          |
       |   send H |     ,-------|  open  |-------.     | recv H   |
       |          |    /        |        |        \    |          |
       |          v   v         +--------+         v   v          |
       |      +----------+          |           +----------+      |
       |      |   half   |          |           |   half   |      |
       |      |  closed  |          | send R /  |  closed  |      |
       |      | (remote) |          | recv R    | (local)  |      |
       |      +----------+          |           +----------+      |
       |           |                |                 |           |
       |           | send ES /      |       recv ES / |           |
       |           | send R /       v        send R / |           |
       |           | recv R     +--------+   recv R   |           |
       | send R /  `----------->|        |<-----------'  send R / |
       | recv R                 | closed |               recv R   |
       `----------------------->|        |<----------------------'
                                +--------+

          send:   endpoint sends this frame
          recv:   endpoint receives this frame

          H:  HEADERS frame (with implied CONTINUATIONs)
          PP: PUSH_PROMISE frame (with implied CONTINUATIONs)
          ES: END_STREAM flag
          R:  RST_STREAM frame

                          Figure 2: Stream States
```

이 다이어그램은 스트림 상태 전환과 이러한 전환에만 영향을 미치는 프레임 및 플래그를 보여줍니다. 이와 관련하여 CONTINUATION 프레임은 상태 전환을 초래하지 않습니다. 그들은 사실상 그들이 따르는 HEADERS 또는 PUSH\_PROMISE의 일부입니다.

상태 전환을 위해 END\_STREAM 플래그는 이를 포함하는 프레임에 대한 별도의 이벤트로 처리됩니다. END\_STREAM 플래그가 설정된 HEADERS 프레임은 두 가지 상태 전환을 유발할 수 있습니다.

두 끝점에는 프레임이 전송 중일 때 다를 수 있는 스트림 상태에 대한 주관적인 보기가 있습니다. 끝점은 스트림 생성을 조정하지 않습니다. 끝점 중 하나에 의해 일방적으로 생성됩니다. 상태 불일치의 부정적인 결과는 RST\_STREAM을 보낸 후 "닫힌" 상태로 제한되며, 여기서 프레임은 닫힌 후 얼마 동안 수신될 수 있습니다.

스트림의 상태는 다음과 같습니다.

게으른:

- 모든 스트림은 "유휴" 상태에서 시작됩니다.

- 이 상태에서 다음 전환이 유효합니다.

- \* HEADERS 프레임을 보내거나 받으면 스트림이 "개방"됩니다. 스트림 식별자는 섹션 5.1.1에 설명된 대로 선택됩니다. 동일한 HEADERS 프레임으로 인해 스트림이 즉시 "절반 폐쇄"될 수도 있습니다.

- \* 다른 스트림에서 PUSH\_PROMISE 프레임을 전송하면 나중에 사용하기 위해 식별된 유휴 스트림이 예약됩니다. 예약된 스트림의 스트림 상태가 "예약됨\(로컬\)"으로 전환됩니다.

- \* 다른 스트림에서 PUSH\_PROMISE 프레임을 수신하면 나중에 사용하기 위해 식별되는 유휴 스트림을 예약합니다. 예약된 스트림의 스트림 상태가 "예약됨\(원격\)"으로 전환됩니다.

- \* PUSH\_PROMISE 프레임은 유휴 스트림에서 전송되지 않지만 Promised Stream ID 필드에서 새로 예약된 스트림을 참조합니다.

- 이 상태의 스트림에서 HEADERS 또는 PRIORITY 이외의 프레임을 수신하면 PROTOCOL\_ERROR 유형의 연결 오류\(섹션 5.4.1\)로 처리해야 합니다.\(MUST\)

예약됨\(로컬\):

- "예약됨\(로컬\)" 상태의 스트림은 PUSH\_PROMISE 프레임을 전송하여 약속된 스트림입니다. PUSH\_PROMISE 프레임은 스트림을 원격 피어에 의해 시작된 오픈 스트림과 연결하여 유휴 스트림을 예약합니다\(섹션 8.2 참조\).

- 이 상태에서는 다음 전환만 가능합니다.

- \* 엔드포인트는 HEADERS 프레임을 보낼 수 있습니다. 이로 인해 스트림이 "반쯤 닫힌\(원격\)" 상태로 열립니다.

- \* 어느 끝점이든 RST\_STREAM 프레임을 보내 스트림을 "닫히게" 할 수 있습니다. 이렇게 하면 스트림 예약이 해제됩니다.

- 엔드포인트는 이 상태에서 HEADERS, RST\_STREAM 또는 PRIORITY 이외의 프레임 유형을 보내면 안 됩니다\(MUST NOT\).\(MUST NOT\)

- 이 상태에서 PRIORITY 또는 WINDOW\_UPDATE 프레임이 수신될 수 있습니다. 이 상태의 스트림에서 RST\_STREAM, PRIORITY 또는 WINDOW\_UPDATE 이외의 프레임 유형을 수신하면 PROTOCOL\_ERROR 유형의 연결 오류\(섹션 5.4.1\)로 처리해야 합니다.\(MAY, MUST\)

예약됨\(원격\):

- "예약됨\(원격\)" 상태의 스트림이 원격 피어에 의해 예약되었습니다.

- 이 상태에서는 다음 전환만 가능합니다.

- \* HEADERS 프레임을 수신하면 스트림이 "반 폐쇄\(로컬\)"로 전환됩니다.

- \* 어느 끝점이든 RST\_STREAM 프레임을 보내 스트림을 "닫히게" 할 수 있습니다. 이렇게 하면 스트림 예약이 해제됩니다.

엔드포인트는 이 상태에서 PRIORITY 프레임을

- 예약된 스트림의 우선순위를 재지정합니다. 엔드포인트는 이 상태에서 RST\_STREAM, WINDOW\_UPDATE 또는 PRIORITY 이외의 프레임 유형을 보내면 안 됩니다\(MUST NOT\).\(MAY, MUST NOT\)

- 이 상태의 스트림에서 HEADERS, RST\_STREAM 또는 PRIORITY 이외의 프레임 유형을 수신하면 PROTOCOL\_ERROR 유형의 연결 오류\(섹션 5.4.1\)로 처리해야 합니다.\(MUST\)

열려 있는:

- "열린" 상태의 스트림은 모든 유형의 프레임을 전송하기 위해 두 피어에서 모두 사용할 수 있습니다. 이 상태에서 보내는 피어는 알려진 스트림 수준 흐름 제어 제한\(섹션 5.2\)을 준수합니다.

이 상태에서 두 엔드포인트는 다음과 같은 프레임을 보낼 수 있습니다.

- END\_STREAM 플래그가 설정되어 스트림이 "절반 폐쇄" 상태 중 하나로 전환됩니다. 보내는 엔드포인트

- END\_STREAM 플래그로 인해 스트림 상태가 "반 폐쇄\(로컬\)"가 됩니다. END\_STREAM 플래그를 수신하는 엔드포인트는 스트림 상태를 "반쯤 닫힘\(원격\)"으로 만듭니다.

- 두 끝점 중 하나가 이 상태에서 RST\_STREAM 프레임을 보낼 수 있으므로 즉시 "닫힘" 상태로 전환됩니다.

반 폐쇄\(로컬\):

- "half-closed\(로컬\)" 상태의 스트림은 WINDOW\_UPDATE, PRIORITY 및 RST\_STREAM 이외의 프레임 전송에 사용할 수 없습니다.

- END\_STREAM 플래그가 포함된 프레임이 수신되거나 피어가 RST\_STREAM 프레임을 보낼 때 스트림이 이 상태에서 "닫힘"으로 전환됩니다.

엔드포인트는 이 상태에서 모든 유형의 프레임을 수신할 수 있습니다.

- 흐름 제어 프레임을 계속 수신하려면 WINDOW\_UPDATE 프레임을 사용하여 흐름 제어 크레딧을 제공해야 합니다. 이 상태에서 수신기는 END\_STREAM 플래그가 포함된 프레임이 전송된 후 짧은 기간 동안 도착할 수 있는 WINDOW\_UPDATE 프레임을 무시할 수 있습니다.

- 이 상태에서 수신된 PRIORITY 프레임은 식별된 스트림에 의존하는 스트림의 우선 순위를 재지정하는 데 사용됩니다.

반폐쇄\(원격\):

- "반 폐쇄\(원격\)"인 스트림은 더 이상 피어에서 프레임을 전송하는 데 사용되지 않습니다. 이 상태에서 엔드포인트는 더 이상 수신기 흐름 제어 창을 유지할 의무가 없습니다.

끝점에서 이외의 추가 프레임을 수신하는 경우

- 이 상태에 있는 스트림의 경우 WINDOW\_UPDATE, PRIORITY 또는 RST\_STREAM은 STREAM\_CLOSED 유형의 스트림 오류\(섹션 5.4.2\)로 응답해야 합니다.\(MUST\)

- "반 폐쇄\(원격\)"인 스트림은 엔드포인트에서 모든 유형의 프레임을 보내는 데 사용할 수 있습니다. 이 상태에서 끝점은 알려진 스트림 수준 흐름 제어 제한\(섹션 5.2\)을 계속 관찰합니다.

- 스트림은 END\_STREAM 플래그가 포함된 프레임을 보내거나 피어가 RST\_STREAM 프레임을 보낼 때 이 상태에서 "닫힘" 상태로 전환할 수 있습니다.

닫은:

- "닫힌" 상태는 최종 상태입니다.

- 끝점은 닫힌 스트림에서 PRIORITY 이외의 프레임을 보내면 안 됩니다. RST\_STREAM을 수신한 후 PRIORITY 이외의 프레임을 수신하는 엔드포인트는 이를 STREAM\_CLOSED 유형의 스트림 오류\(섹션 5.4.2\)로 처리해야 합니다. 마찬가지로 END\_STREAM 플래그가 설정된 프레임을 수신한 후 프레임을 수신하는 끝점은 프레임이 아래 설명된 대로 허용되지 않는 한 이를 STREAM\_CLOSED 유형의 연결 오류\(섹션 5.4.1\)로 처리해야 합니다.\(MUST NOT, MUST, MUST\)

- END\_STREAM 플래그가 포함된 DATA 또는 HEADERS 프레임이 전송된 후 짧은 시간 동안 이 상태에서 WINDOW\_UPDATE 또는 RST\_STREAM 프레임을 수신할 수 있습니다. 원격 피어는 RST\_STREAM 또는 END\_STREAM 플래그가 포함된 프레임을 수신하고 처리할 때까지 이러한 유형의 프레임을 보낼 수 있습니다. 엔드포인트는 이 상태에서 수신된 WINDOW\_UPDATE 또는 RST\_STREAM 프레임을 무시해야 합니다\(MUST\). 하지만 엔드포인트는 END\_STREAM을 보낸 후 상당한 시간이 지난 후 도착하는 프레임을 PROTOCOL\_ERROR 유형의 연결 오류\(섹션 5.4.1\)로 처리하도록 선택할 수 있습니다.\(MUST\)

- 닫힌 스트림에 종속된 스트림의 우선 순위를 지정하기 위해 닫힌 스트림에서 PRIORITY 프레임을 보낼 수 있습니다. 끝점은 PRIORITY 프레임을 처리해야 하지만 스트림이 종속성 트리에서 제거된 경우 무시할 수 있습니다\(섹션 5.3.4 참조\).\(SHOULD\)

- RST\_STREAM 프레임을 전송한 결과 이 ​​상태에 도달한 경우 RST\_STREAM을 수신한 피어는 이미 철회할 수 없는 프레임을 전송했거나 전송을 위해 대기열에 넣었을 수 있습니다. 엔드포인트는 RST\_STREAM 프레임을 보낸 후 닫힌 스트림에서 수신하는 프레임을 무시해야 합니다. 끝점은 프레임을 무시하는 기간을 제한하고 이 시간 이후에 도착하는 프레임을 오류가 있는 것으로 처리하도록 선택할 수 있습니다\(MAY\).\(MUST, MAY\)

- RST\_STREAM을 보낸 후 수신된 흐름 제어 프레임\(즉, DATA\)은 연결 흐름 제어 창으로 계산됩니다. 이러한 프레임은 무시될 수 있지만 발신자가 RST\_STREAM을 수신하기 전에 전송되기 때문에 발신자는 프레임을 흐름 제어 창에 대해 계산할 것으로 간주합니다.

- 끝점이 RST\_STREAM을 보낸 후 PUSH\_PROMISE 프레임을 받을 수 있습니다. PUSH\_PROMISE로 인해 연결된 스트림이 재설정된 경우에도 스트림이 "예약"됩니다. 따라서 원치 않는 약속된 스트림을 닫으려면 RST\_STREAM이 필요합니다.

이 문서의 다른 부분에 더 구체적인 지침이 없는 경우 구현은 상태 설명에서 명시적으로 허용되지 않는 프레임 수신을 PROTOCOL\_ERROR 유형의 연결 오류\(섹션 5.4.1\)로 처리해야 합니다\(SHOULD\). PRIORITY는 모든 스트림 상태에서 보내고 받을 수 있습니다. 알 수 없는 유형의 프레임은 무시됩니다.\(SHOULD\)

HTTP 요청/응답 교환에 대한 상태 전환의 예는 섹션 8.1에서 찾을 수 있습니다. 서버 푸시에 대한 상태 전환의 예는 섹션 8.2.1 및 8.2.2에서 찾을 수 있습니다.

---
#### **5.1.1.  Stream Identifiers**

스트림은 부호 없는 31비트 정수로 식별됩니다. 클라이언트에 의해 시작된 스트림은 반드시 홀수 번호의 스트림 식별자를 사용해야 합니다. 서버에 의해 시작된 스트림 식별자는 반드시 짝수 번호의 스트림 식별자를 사용해야 합니다. 연결 제어 메시지에는 스트림 식별자 0\(0x0\)이 사용됩니다. 스트림 식별자 0은 새 스트림을 설정하는 데 사용할 수 없습니다.\(MUST\)

HTTP/2\(섹션 3.2 참조\)로 업그레이드된 HTTP/1.1 요청은 스트림 식별자 1\(0x1\)로 응답됩니다. 업그레이드가 완료된 후 스트림 0x1은 클라이언트에 대해 "반 폐쇄\(로컬\)" 상태입니다. 따라서 HTTP/1.1에서 업그레이드하는 클라이언트는 스트림 0x1을 새 스트림 식별자로 선택할 수 없습니다.

새로 설정된 스트림의 식별자는 시작 엔드포인트가 열거나 예약한 모든 스트림보다 수치적으로 커야 합니다. 이는 HEADERS 프레임을 사용하여 열린 스트림과 PUSH\_PROMISE를 사용하여 예약된 스트림을 제어합니다. 예기치 않은 스트림 식별자를 수신하는 끝점은 PROTOCOL\_ERROR 유형의 연결 오류\(섹션 5.4.1\)로 응답해야 합니다.\(MUST, MUST\)

새 스트림 식별자를 처음 사용하면 낮은 값의 스트림 식별자를 사용하여 해당 피어에 의해 시작되었을 수 있는 "유휴" 상태의 모든 스트림이 암시적으로 닫힙니다. 예를 들어 클라이언트가 스트림 5에서 프레임을 전송하지 않고 스트림 7에서 HEADERS 프레임을 전송하는 경우 스트림 7의 첫 번째 프레임이 전송되거나 수신될 때 스트림 5는 "닫힌" 상태로 전환됩니다.

스트림 식별자는 재사용할 수 없습니다. 수명이 긴 연결로 인해 끝점이 사용 가능한 스트림 식별자 범위를 소진할 수 있습니다. 새 스트림 식별자를 설정할 수 없는 클라이언트는 새 스트림에 대한 새 연결을 설정할 수 있습니다. 새 스트림 식별자를 설정할 수 없는 서버는 GOAWAY 프레임을 보내 클라이언트가 새 스트림에 대한 새 연결을 강제로 열도록 할 수 있습니다.

---
#### **5.1.2.  Stream Concurrency**

피어는 SETTINGS 프레임 내에서 SETTINGS\_MAX\_CONCURRENT\_STREAMS 매개변수\(섹션 6.5.2 참조\)를 사용하여 동시 활성 스트림의 수를 제한할 수 있습니다. 최대 동시 스트림 설정은 각 끝점에 따라 다르며 설정을 수신하는 피어에만 적용됩니다. 즉, 클라이언트는 서버가 시작할 수 있는 최대 동시 스트림 수를 지정하고 서버는 클라이언트가 시작할 수 있는 최대 동시 스트림 수를 지정합니다.

"개방" 상태 또는 "반 폐쇄" 상태에 있는 스트림은 엔드포인트가 열 수 있는 최대 스트림 수에 포함됩니다. 이 세 가지 상태의 스트림은 SETTINGS\_MAX\_CONCURRENT\_STREAMS 설정에 알려진 제한에 포함됩니다. "예약됨" 상태의 스트림은 스트림 제한에 포함되지 않습니다.

엔드포인트는 피어가 설정한 제한을 초과해서는 안 됩니다. 광고된 동시 스트림 제한을 초과하는 HEADERS 프레임을 수신하는 엔드포인트는 이를 PROTOCOL\_ERROR 또는 REFUSED\_STREAM 유형의 스트림 오류\(섹션 5.4.2\)로 처리해야 합니다. 오류 코드의 선택에 따라 끝점이 자동 재시도를 활성화할지 여부가 결정됩니다\(자세한 내용은 섹션 8.1.4 참조\).\(MUST NOT, MUST\)

SETTINGS\_MAX\_CONCURRENT\_STREAMS의 값을 현재 열린 스트림 수보다 낮은 값으로 줄이려는 엔드포인트는 새 값을 초과하는 스트림을 닫거나 스트림이 완료되도록 허용할 수 있습니다.

---
### **5.2.  Flow Control**

멀티플렉싱에 스트림을 사용하면 TCP 연결 사용에 대한 경합이 발생하여 스트림이 차단됩니다. 흐름 제어 체계는 동일한 연결의 스트림이 서로 파괴적으로 간섭하지 않도록 합니다. 흐름 제어는 개별 스트림과 전체 연결 모두에 사용됩니다.

HTTP/2는 WINDOW\_UPDATE 프레임\(섹션 6.9\)을 사용하여 흐름 제어를 제공합니다.

---
#### **5.2.1.  Flow-Control Principles**

HTTP/2 스트림 흐름 제어는 프로토콜 변경 없이 다양한 흐름 제어 알고리즘을 사용할 수 있도록 하는 것을 목표로 합니다. HTTP/2의 흐름 제어에는 다음과 같은 특징이 있습니다.

1. 흐름 제어는 연결에 따라 다릅니다. 두 유형의 흐름 제어 모두 전체 종단 간 경로가 아니라 단일 홉의 끝점 사이에 있습니다.

2. 흐름 제어는 WINDOW\_UPDATE 프레임을 기반으로 합니다. 수신기는 스트림과 전체 연결에 대해 수신할 준비가 된 옥텟 수를 알립니다. 이것은 신용 기반 제도입니다.

3. 흐름 제어는 수신기에서 제공하는 전체 제어와 함께 방향성입니다. 수신기는 각 스트림과 전체 연결에 대해 원하는 창 크기를 설정하도록 선택할 수 있습니다. 발신자는 수신자가 부과한 흐름 제어 제한을 준수해야 합니다. 클라이언트, 서버 및 중개자는 모두 독립적으로 흐름 제어 창을 수신기로 알리고 보낼 때 피어가 설정한 흐름 제어 제한을 준수합니다.\(MAY, MUST\)

4. 흐름 제어 창의 초기 값은 새 스트림과 전체 연결 모두에 대해 65,535옥텟입니다.

5. 프레임 유형은 흐름 제어가 프레임에 적용되는지 여부를 결정합니다. 이 문서에 지정된 프레임 중에서 DATA 프레임만 흐름 제어의 대상입니다. 다른 모든 프레임 유형은 알려진 흐름 제어 창에서 공간을 사용하지 않습니다. 이렇게 하면 중요한 제어 프레임이 흐름 제어에 의해 차단되지 않습니다.

6. 흐름 제어는 비활성화할 수 없습니다.

7. HTTP/2는 WINDOW\_UPDATE 프레임의 형식과 의미만 정의합니다\(섹션 6.9\). 이 문서는 수신자가 이 프레임을 보낼 시기나 보내는 값을 결정하는 방법을 규정하지 않으며 발신자가 패킷을 보내기 위해 선택하는 방법도 지정하지 않습니다. 구현은 필요에 맞는 알고리즘을 선택할 수 있습니다.

또한 구현은 우선 순위에 따라 요청 및 응답이 전송되는 방식을 관리하고, 요청에 대한 HOL\(head-of-line\) 차단을 방지하는 방법을 선택하고, 새 스트림 생성을 관리할 책임이 있습니다. 이에 대한 알고리즘 선택은 모든 흐름 제어 알고리즘과 상호 작용할 수 있습니다.

---
#### **5.2.2.  Appropriate Use of Flow Control**

흐름 제어는 리소스 제약 조건 하에서 작동하는 엔드포인트를 보호하기 위해 정의됩니다. 예를 들어 프록시는 많은 연결 간에 메모리를 공유해야 하며 느린 업스트림 연결과 빠른 다운스트림 연결이 있을 수 있습니다. 흐름 제어는 수신자가 한 스트림에서 데이터를 처리할 수 없지만 동일한 연결에서 다른 스트림을 계속 처리하려는 경우를 해결합니다.

이 기능이 필요하지 않은 배포는 최대 크기\(2^31-1\)의 흐름 제어 창을 알릴 수 있으며 데이터가 수신될 때 WINDOW\_UPDATE 프레임을 전송하여 이 창을 유지할 수 있습니다. 이는 해당 수신기에 대한 흐름 제어를 효과적으로 비활성화합니다. 반대로 발신자는 항상 수신자가 알리는 흐름 제어 창의 영향을 받습니다.

제한된 리소스\(예: 메모리\)가 있는 배포에서는 흐름 제어를 사용하여 피어가 사용할 수 있는 메모리 양을 제한할 수 있습니다. 그러나 이것은 대역폭 지연 제품에 대한 지식 없이 흐름 제어가 활성화된 경우 사용 가능한 네트워크 리소스를 차선책으로 사용할 수 있다는 점에 유의하십시오\(\[RFC7323\] 참조\).

현재 대역폭 지연 제품을 완전히 인식하더라도 흐름 제어 구현이 어려울 수 있습니다. 흐름 제어를 사용할 때 수신기는 적시에 TCP 수신 버퍼에서 읽어야 합니다. 그렇게 하지 않으면 WINDOW\_UPDATE와 같은 중요한 프레임을 읽거나 조치를 취하지 않을 때 교착 상태가 발생할 수 있습니다.\(MUST\)

---
### **5.3.  Stream Priority**

클라이언트는 스트림을 여는 HEADERS 프레임\(섹션 6.2\)에 우선 순위 정보를 포함하여 새 스트림에 대한 우선 순위를 할당할 수 있습니다. 그 외의 시간에는 PRIORITY 프레임\(섹션 6.3\)을 사용하여 스트림의 우선 순위를 변경할 수 있습니다.

우선 순위 지정의 목적은 엔드포인트가 동시 스트림을 관리할 때 피어가 리소스를 할당하는 방법을 표현할 수 있도록 하는 것입니다. 가장 중요한 것은 전송 용량이 제한되어 있을 때 프레임 전송을 위한 스트림을 선택하는 데 우선 순위를 사용할 수 있다는 것입니다.

스트림은 다른 스트림의 완료에 종속된 것으로 표시하여 우선 순위를 지정할 수 있습니다\(섹션 5.3.1\). 각 종속성에는 동일한 스트림에 종속된 스트림에 할당되는 사용 가능한 리소스의 상대적 비율을 결정하는 데 사용되는 숫자인 상대적 가중치가 할당됩니다.

스트림의 우선 순위를 명시적으로 설정하면 우선 순위 지정 프로세스에 입력됩니다. 다른 스트림과 관련된 스트림에 대한 특정 처리 또는 전송 순서를 보장하지 않습니다. 끝점은 피어가 우선 순위를 사용하여 특정 순서로 동시 스트림을 처리하도록 강제할 수 없습니다. 따라서 우선 순위를 표현하는 것은 단지 제안일 뿐입니다.

메시지에서 우선순위 정보를 생략할 수 있습니다. 명시적 값이 제공되기 전에 기본값이 사용됩니다\(섹션 5.3.5\).

---
#### **5.3.1.  Stream Dependencies**

각 스트림에는 다른 스트림에 대한 명시적 종속성이 부여될 수 있습니다. 종속성을 포함하면 종속 스트림이 아닌 식별된 스트림에 리소스를 할당하는 기본 설정을 나타냅니다.

다른 스트림에 종속되지 않은 스트림에는 0x0의 스트림 종속성이 부여됩니다. 즉, 존재하지 않는 스트림 0이 트리의 루트를 형성합니다.

다른 스트림에 의존하는 스트림은 종속 스트림입니다. 스트림이 종속된 스트림은 상위 스트림입니다. 현재 트리에 없는 스트림\(예: "유휴" 상태의 스트림\)에 대한 종속성으로 인해 해당 스트림에 기본 우선 순위가 부여됩니다\(섹션 5.3.5\).

다른 스트림에 종속성을 할당하면 스트림이 상위 스트림의 새 종속성으로 추가됩니다. 동일한 부모를 공유하는 종속 스트림은 서로에 대해 순서가 지정되지 않습니다. 예를 들어 스트림 B와 C가 스트림 A에 종속되어 있고 스트림 D가 스트림 A에 종속되어 생성된 경우 종속성 순서는 A, B, C, D 순으로 순서에 관계없이 생성됩니다.

```text
       A                 A
      / \      ==>      /|\
     B   C             B D C

             Figure 3: Example of Default Dependency Creation
```

배타적 플래그를 사용하면 새로운 수준의 종속성을 삽입할 수 있습니다. 배타적 플래그는 스트림이 상위 스트림의 유일한 종속성이 되도록 하여 다른 종속성이 배타적 스트림에 종속되도록 합니다. 앞의 예에서 스트림 D가 스트림 A에 대한 배타적 종속성을 사용하여 생성되면 D가 B와 C의 종속성 부모가 됩니다.

```text
                         A
       A                 |
      / \      ==>       D
     B   C              / \
                       B   C
```

- 그림 4: 배타 종속성 생성 예

종속성 트리 내에서 종속 스트림은 의존하는 모든 스트림\(0x0까지의 상위 스트림 체인\)이 닫히거나 진행이 불가능한 경우에만 리소스를 할당해야 합니다\(SHOULD\).\(SHOULD\)

스트림은 자체적으로 의존할 수 없습니다. 엔드포인트는 이것을 PROTOCOL\_ERROR 유형의 스트림 오류\(섹션 5.4.2\)로 처리해야 합니다.\(MUST\)

---
#### **5.3.2.  Dependency Weighting**

모든 종속 스트림에는 1에서 256\(포함\) 사이의 정수 가중치가 할당됩니다.

부모가 동일한 스트림은 가중치에 따라 비례적으로 리소스를 할당해야 합니다\(SHOULD\). 따라서 스트림 B가 가중치가 4인 스트림 A에 의존하고 스트림 C가 가중치가 12인 스트림 A에 의존하고 스트림 A에서 진행할 수 없는 경우 스트림 B는 이상적으로 스트림 C에 할당된 리소스의 1/3을 받습니다.\(SHOULD\)

---
#### **5.3.3.  Reprioritization**

스트림 우선순위는 PRIORITY 프레임을 사용하여 변경됩니다. 종속성을 설정하면 스트림이 식별된 상위 스트림에 종속됩니다.

종속 스트림은 상위 스트림의 우선 순위가 다시 지정되면 상위 스트림과 함께 이동합니다. 우선 순위가 재지정된 스트림에 대해 배타적 플래그로 종속성을 설정하면 새 상위 스트림의 모든 종속성이 우선 순위가 재지정된 스트림에 종속되게 됩니다.

스트림이 자체 종속성 중 하나에 종속되면 이전에 종속된 스트림이 먼저 우선 순위가 재지정된 스트림의 이전 부모에 종속되도록 이동됩니다. 이동된 종속성은 가중치를 유지합니다.

예를 들어, B와 C가 A에 의존하고, D와 E가 C에 의존하고, F가 D에 의존하는 원래 종속성 트리를 생각해 보십시오. A가 D에 종속되게 되면 D가 A를 대신합니다. 다른 모든 종속성 관계는 유지됩니다. 우선순위 재지정이 배타적인 경우 A에 종속되는 F를 제외하고 동일합니다.

```text
       x                x                x                 x
       |               / \               |                 |
       A              D   A              D                 D
      / \            /   / \            / \                |
     B   C     ==>  F   B   C   ==>    F   A       OR      A
        / \                 |             / \             /|\
       D   E                E            B   C           B C F
       |                                     |             |
       F                                     E             E
                  (intermediate)   (non-exclusive)    (exclusive)

                Figure 5: Example of Dependency Reordering
```

---
#### **5.3.4.  Prioritization State Management**

스트림이 종속성 트리에서 제거되면 종속성을 이동하여 닫힌 스트림의 상위에 종속될 수 있습니다. 새 종속성의 가중치는 해당 종속성의 가중치에 따라 닫힌 스트림의 종속성의 가중치를 비례적으로 분산하여 다시 계산됩니다.

종속성 트리에서 제거된 스트림으로 인해 일부 우선 순위 정보가 손실됩니다. 리소스는 동일한 부모 스트림이 있는 스트림 간에 공유됩니다. 즉, 해당 세트의 스트림이 닫히거나 차단되면 스트림에 할당된 예비 용량이 스트림의 바로 이웃에 배포됩니다. 그러나 공통 종속성이 트리에서 제거되면 해당 스트림은 다음으로 높은 수준의 스트림과 리소스를 공유합니다.

예를 들어 스트림 A와 B가 부모를 공유하고 스트림 C와 D가 모두 스트림 A에 종속되어 있다고 가정합니다. 스트림 A를 제거하기 전에 스트림 A와 D를 진행할 수 없는 경우 스트림 C는 전용 리소스를 모두 받습니다. 스트림 A. 스트림 A가 트리에서 제거되면 스트림 A의 가중치는 스트림 C와 D로 나뉩니다. 스트림 D가 계속 진행할 수 없는 경우 스트림 C는 감소된 비율의 리소스를 수신하게 됩니다. 동일한 시작 가중치의 경우 C는 사용 가능한 리소스의 절반이 아닌 1/3을 받습니다.

해당 스트림에 대한 종속성을 생성하는 우선 순위 정보가 전송되는 동안 스트림이 닫힐 수 있습니다. 종속성에서 식별된 스트림에 관련 우선 순위 정보가 없으면 대신 종속 스트림에 기본 우선 순위가 할당됩니다\(섹션 5.3.5\). 이는 스트림에 의도한 것과 다른 우선순위가 부여될 수 있기 때문에 잠재적으로 최적이 아닌 우선순위를 생성합니다.

이러한 문제를 방지하기 위해 끝점은 스트림이 닫힌 후 일정 기간 동안 스트림 우선 순위 지정 상태를 유지해야 합니다\(SHOULD\). 상태가 오래 유지될수록 스트림에 잘못되거나 기본 우선 순위 값이 할당될 가능성이 낮아집니다.\(SHOULD\)

마찬가지로 "유휴" 상태에 있는 스트림에 우선 순위를 할당하거나 다른 스트림의 부모가 될 수 있습니다. 이를 통해 종속성 트리에서 그룹화 노드를 생성할 수 있으므로 보다 유연한 우선 순위 표현이 가능합니다. 유휴 스트림은 기본 우선 순위로 시작합니다\(섹션 5.3.5\).

SETTINGS\_MAX\_CONCURRENT\_STREAMS에서 설정한 제한에 포함되지 않는 스트림에 대한 우선 순위 정보를 보유하면 엔드포인트에 큰 부담이 될 수 있습니다. 따라서 유지되는 우선순위 상태의 양은 제한될 수 있습니다.\(MAY\)

엔드포인트가 우선 순위 지정을 위해 유지하는 추가 상태의 양은 부하에 따라 달라질 수 있습니다. 부하가 높으면 우선 순위 지정 상태를 삭제하여 리소스 약정을 제한할 수 있습니다. 극단적인 경우 엔드포인트는 활성 또는 예약된 스트림에 대한 우선 순위 지정 상태를 버릴 수도 있습니다. 제한이 적용되면 끝점은 적어도 SETTINGS\_MAX\_CONCURRENT\_STREAMS 설정에서 허용하는 만큼의 스트림에 대한 상태를 유지해야 합니다\(SHOULD\). 구현은 또한 우선 순위 트리에서 활성 사용 중인 스트림에 대한 상태를 유지하려고 시도해야 합니다\(SHOULD\).\(SHOULD, SHOULD\)

충분한 상태를 유지한 경우 닫힌 스트림의 우선 순위를 변경하는 PRIORITY 프레임을 수신하는 끝점은 이에 의존하는 스트림의 종속성을 변경해야 합니다\(SHOULD\).\(SHOULD\)

---
#### **5.3.5.  Default Priorities**

모든 스트림은 처음에 스트림 0x0에 대한 비독점적 종속성을 할당받습니다. 푸시된 스트림\(섹션 8.2\)은 초기에 연결된 스트림에 의존합니다. 두 경우 모두 스트림에 기본 가중치 16이 할당됩니다.

---
### **5.4.  Error Handling**

HTTP/2 프레이밍은 두 종류의 오류를 허용합니다.

o 전체 연결을 사용할 수 없게 만드는 오류 상태는 연결 오류입니다.

o 개별 스트림의 오류는 스트림 오류입니다.

오류 코드 목록은 섹션 7에 포함되어 있습니다.

---
#### **5.4.1.  Connection Error Handling**

연결 오류는 프레임 계층의 추가 처리를 방해하거나 연결 상태를 손상시키는 모든 오류입니다.

연결 오류가 발생한 엔드포인트는 피어로부터 성공적으로 수신한 마지막 스트림의 스트림 식별자와 함께 GOAWAY 프레임\(섹션 6.8\)을 먼저 보내야 합니다\(SHOULD\). GOAWAY 프레임에는 연결이 종료되는 이유를 나타내는 오류 코드가 포함되어 있습니다. 오류 조건에 대해 GOAWAY 프레임을 보낸 후 엔드포인트는 TCP 연결을 닫아야 합니다.\(SHOULD, MUST\)

수신 엔드포인트에서 GOAWAY를 안정적으로 수신하지 못할 가능성이 있습니다\(\[RFC7230\], 섹션 6.6은 즉각적인 연결 종료로 인해 데이터 손실이 발생할 수 있는 방법을 설명함\). 연결 오류가 발생하는 경우 GOAWAY는 연결이 종료되는 이유에 대해 피어와 통신하기 위한 최선의 시도만 제공합니다.

엔드포인트는 언제든지 연결을 종료할 수 있습니다. 특히 엔드포인트는 스트림 오류를 연결 오류로 처리하도록 선택할 수 있습니다. 끝점은 연결을 종료할 때 상황이 허용한다면 GOAWAY 프레임을 보내야 합니다\(SHOULD\).\(MAY, SHOULD\)

---
#### **5.4.2.  Stream Error Handling**

스트림 오류는 다른 스트림의 처리에 영향을 미치지 않는 특정 스트림과 관련된 오류입니다.

스트림 오류를 감지한 끝점은 오류가 발생한 스트림의 스트림 식별자를 포함하는 RST\_STREAM 프레임\(섹션 6.4\)을 보냅니다. RST\_STREAM 프레임에는 오류의 종류를 나타내는 오류 코드가 포함되어 있습니다.

RST\_STREAM은 끝점이 스트림에서 보낼 수 있는 마지막 프레임입니다. RST\_STREAM 프레임을 전송하는 피어는 원격 피어가 전송했거나 전송을 위해 대기열에 넣은 모든 프레임을 수신할 준비가 되어 있어야 합니다. 이러한 프레임은 연결 상태\(예: 헤더 압축\(섹션 4.3\) 또는 흐름 제어를 위해 유지되는 상태\)를 수정하는 경우를 제외하고는 무시할 수 있습니다.\(MUST\)

일반적으로 엔드포인트는 모든 스트림에 대해 둘 이상의 RST\_STREAM 프레임을 보내면 안 됩니다\(SHOULD NOT\). 그러나 엔드포인트는 왕복 시간보다 긴 시간 후에 닫힌 스트림에서 프레임을 수신하는 경우 추가 RST\_STREAM 프레임을 보낼 수 있습니다\(MAY\). 이 동작은 오작동하는 구현을 처리하기 위해 허용됩니다.\(SHOULD NOT, MAY\)

루핑을 피하기 위해 엔드포인트는 RST\_STREAM 프레임에 대한 응답으로 RST\_STREAM을 보내면 안 됩니다\(MUST NOT\).\(MUST NOT\)

---
#### **5.4.3.  Connection Termination**

스트림이 "개방" 또는 "반 폐쇄" 상태에 있는 동안 TCP 연결이 닫히거나 재설정되면 영향을 받는 스트림을 자동으로 재시도할 수 없습니다\(자세한 내용은 섹션 8.1.4 참조\).

---
### **5.5.  Extending HTTP/2**

HTTP/2는 프로토콜의 확장을 허용합니다. 이 섹션에 설명된 제한 내에서 프로토콜 확장을 사용하여 추가 서비스를 제공하거나 프로토콜의 모든 측면을 변경할 수 있습니다. 확장은 단일 HTTP/2 연결 범위 내에서만 유효합니다.

이는 이 문서에 정의된 프로토콜 요소에 적용됩니다. 이는 새 메소드, 상태 코드 또는 헤더 필드 정의와 같은 HTTP 확장을 위한 기존 옵션에 영향을 미치지 않습니다.

확장은 새 프레임 유형\(섹션 4.1\), 새 설정\(섹션 6.5.2\) 또는 새 오류 코드\(섹션 7\)를 사용할 수 있습니다. 프레임 유형\(11.2절\), 설정\(11.3절\) 및 오류 코드\(11.4절\)와 같은 확장 지점을 관리하기 위해 레지스트리가 설정됩니다.

구현은 모든 확장 가능한 프로토콜 요소에서 알 수 없거나 지원되지 않는 값을 무시해야 합니다\(MUST\). 구현은 알 수 없거나 지원되지 않는 유형이 있는 프레임을 폐기해야 합니다\(MUST\). 이는 이러한 확장 지점 중 어느 것이든 사전 협의나 협상 없이 확장에서 안전하게 사용할 수 있음을 의미합니다. 그러나 헤더 블록\(섹션 4.3\) 중간에 나타나는 확장 프레임은 허용되지 않습니다. 이들은 PROTOCOL\_ERROR 유형의 연결 오류\(섹션 5.4.1\)로 처리되어야 합니다.\(MUST, MUST, MUST\)

기존 프로토콜 구성 요소의 의미 체계를 변경할 수 있는 확장은 사용하기 전에 반드시 협상되어야 합니다. 예를 들어 HEADERS 프레임의 레이아웃을 변경하는 확장은 피어가 이것이 허용된다는 긍정적인 신호를 제공할 때까지 사용할 수 없습니다. 이 경우 수정된 레이아웃이 적용되는 시점을 조정해야 할 수도 있습니다. DATA 프레임 이외의 프레임을 흐름 제어로 처리하는 것은 의미 체계의 변경이며 협상을 통해서만 수행할 수 있습니다.\(MUST\)

이 문서는 확장 사용을 협상하기 위한 특정 방법을 요구하지 않지만 해당 목적을 위해 설정\(섹션 6.5.2\)을 사용할 수 있음을 언급합니다. 두 피어 모두 확장을 사용할 의사가 있음을 나타내는 값을 설정하면 확장을 사용할 수 있습니다. 만약에

확장 협상에 설정이 사용되면 초기 값은 확장이 처음에 비활성화되는 방식으로 정의되어야 합니다.\(MUST\)

---
## **6.  Frame Definitions**

이 사양은 각각 고유한 8비트 유형 코드로 식별되는 여러 프레임 유형을 정의합니다. 각 프레임 유형은 연결 전체 또는 개별 스트림의 설정 및 관리에서 고유한 목적을 제공합니다.

특정 프레임 유형의 전송은 연결 상태를 변경할 수 있습니다. 엔드포인트가 연결 상태의 동기화된 보기를 유지하지 못하면 연결 내에서 성공적인 통신이 더 이상 가능하지 않습니다. 따라서 엔드포인트가 주어진 프레임 사용이 상태에 미치는 영향을 공유 이해하는 것이 중요합니다.

---
### **6.1.  DATA**

DATA 프레임\(유형=0x0\)은 스트림과 관련된 옥텟의 임의 가변 길이 시퀀스를 전달합니다. 예를 들어 HTTP 요청 또는 응답 페이로드를 전달하기 위해 하나 이상의 DATA 프레임이 사용됩니다.

데이터 프레임에는 패딩도 포함될 수 있습니다\(MAY\). 메시지 크기를 가리기 위해 패딩을 DATA 프레임에 추가할 수 있습니다. 패딩은 보안 기능입니다. 섹션 10.7을 참조하십시오.\(MAY\)

```text
    +---------------+
    |Pad Length? (8)|
    +---------------+-----------------------------------------------+
    |                            Data (*)                         ...
    +---------------------------------------------------------------+
    |                           Padding (*)                       ...
    +---------------------------------------------------------------+

                       Figure 6: DATA Frame Payload
```

DATA 프레임에는 다음 필드가 포함됩니다.

패드 길이: 옥텟 단위의 프레임 패딩 길이를 포함하는 8비트 필드입니다. 이 필드는 조건부\(다이어그램에서 "?"로 표시됨\)이며 PADDED 플래그가 설정된 경우에만 존재합니다.

데이터: 애플리케이션 데이터. 데이터의 양은 존재하는 다른 필드의 길이를 뺀 후 프레임 페이로드의 나머지 부분입니다.

패딩: 애플리케이션 시맨틱 값을 포함하지 않는 패딩 옥텟. 보낼 때 패딩 옥텟을 0으로 설정해야 합니다. 수신자는 패딩을 확인할 의무가 없지만 0이 아닌 패딩을 PROTOCOL\_ERROR 유형의 연결 오류\(섹션 5.4.1\)로 처리할 수 있습니다\(MAY\).\(MUST, MAY\)

DATA 프레임은 다음 플래그를 정의합니다.

END\_STREAM\(0x1\): 설정되면 비트 0은 이 프레임이 엔드포인트가 식별된 스트림에 대해 보낼 마지막 프레임임을 나타냅니다. 이 플래그를 설정하면 스트림이 "반 폐쇄" 상태 또는 "폐쇄" 상태\(섹션 5.1\) 중 하나로 들어가게 됩니다.

PADDED\(0x8\): 설정되면 비트 3은 패드 길이 필드와 여기에 설명된 패딩이 있음을 나타냅니다.

DATA 프레임은 반드시 스트림과 연결되어야 합니다. 스트림 식별자 필드가 0x0인 DATA 프레임이 수신되면 수신자는 PROTOCOL\_ERROR 유형의 연결 오류\(섹션 5.4.1\)로 응답해야 합니다.\(MUST, MUST\)

DATA 프레임은 흐름 제어의 대상이며 스트림이 "개방" 또는 "반폐쇄\(원격\)" 상태일 때만 보낼 수 있습니다. 전체 DATA 프레임 페이로드는 패드 길이 및 패딩 필드\(있는 경우\)를 포함하여 흐름 제어에 포함됩니다. 스트림이 "open" 또는 "half-closed \(local\)" 상태가 아닌 DATA 프레임이 수신되면 수신자는 STREAM\_CLOSED 유형의 스트림 오류\(섹션 5.4.2\)로 응답해야 합니다.\(MUST\)

패딩 옥텟의 총 수는 패드 길이 필드의 값으로 결정됩니다. 패딩 길이가 프레임 페이로드 길이 이상인 경우 수신자는 이를 PROTOCOL\_ERROR 유형의 연결 오류\(섹션 5.4.1\)로 처리해야 합니다.\(MUST\)

- 참고: 값이 0인 패드 길이 필드를 포함하여 프레임 크기를 한 옥텟씩 늘릴 수 있습니다.

---
### **6.2.  HEADERS**

HEADERS 프레임\(유형=0x1\)은 스트림\(섹션 5.1\)을 여는 데 사용되며 추가로 헤더 블록 조각을 전달합니다. HEADERS 프레임은 "idle", "reserved\(local\)", "open" 또는 "half-closed\(remote\)" 상태의 스트림에서 전송될 수 있습니다.

```text
    +---------------+
    |Pad Length? (8)|
    +-+-------------+-----------------------------------------------+
    |E|                 Stream Dependency? (31)                     |
    +-+-------------+-----------------------------------------------+
    |  Weight? (8)  |
    +-+-------------+-----------------------------------------------+
    |                   Header Block Fragment (*)                 ...
    +---------------------------------------------------------------+
    |                           Padding (*)                       ...
    +---------------------------------------------------------------+

                      Figure 7: HEADERS Frame Payload
```

HEADERS 프레임 페이로드에는 다음 필드가 있습니다.

패드 길이: 옥텟 단위의 프레임 패딩 길이를 포함하는 8비트 필드입니다. 이 필드는 PADDED 플래그가 설정된 경우에만 존재합니다.

E: 스트림 종속성이 배타적임을 나타내는 단일 비트 플래그\(섹션 5.3 참조\). 이 필드는 PRIORITY 플래그가 설정된 경우에만 존재합니다.

스트림 종속성: 이 스트림이 의존하는 스트림에 대한 31비트 스트림 식별자입니다\(섹션 5.3 참조\). 이 필드는 PRIORITY 플래그가 설정된 경우에만 존재합니다.

가중치: 스트림의 우선 순위 가중치를 나타내는 부호 없는 8비트 정수\(섹션 5.3 참조\). 1과 256 사이의 가중치를 얻으려면 값에 1을 더하십시오. 이 필드는 PRIORITY 플래그가 설정된 경우에만 존재합니다.

헤더 블록 조각: 헤더 블록 조각\(섹션 4.3\).

```text
   Padding:  Padding octets.
```

HEADERS 프레임은 다음 플래그를 정의합니다.

END\_STREAM\(0x1\): 설정되면 비트 0은 헤더 블록\(섹션 4.3\)이 엔드포인트가 식별된 스트림에 대해 보낼 마지막 블록임을 나타냅니다.

- HEADERS 프레임은 스트림의 끝을 알리는 END\_STREAM 플래그를 전달합니다. 그러나 END\_STREAM 플래그가 설정된 HEADERS 프레임 뒤에는 동일한 스트림의 CONTINUATION 프레임이 올 수 있습니다. 논리적으로 CONTINUATION 프레임은 HEADERS 프레임의 일부입니다.

END\_HEADERS\(0x4\): 설정되면 비트 2는 이 프레임이 전체 헤더 블록\(섹션 4.3\)을 포함하고 어떤 CONTINUATION 프레임도 뒤따르지 않음을 나타냅니다.

- END\_HEADERS 플래그가 설정되지 않은 HEADERS 프레임 뒤에는 동일한 스트림에 대한 CONTINUATION 프레임이 와야 합니다. 수신기는 다른 유형의 프레임 또는 다른 스트림의 프레임 수신을 PROTOCOL\_ERROR 유형의 연결 오류\(섹션 5.4.1\)로 처리해야 합니다.\(MUST, MUST\)

PADDED\(0x8\): 설정되면 비트 3은 패드 길이 필드와 여기에 설명된 패딩이 있음을 나타냅니다.

PRIORITY\(0x20\): 설정된 경우 비트 5는 Exclusive Flag\(E\), 스트림 종속성 및 가중치 필드가 있음을 나타냅니다. 섹션 5.3을 참조하십시오.

HEADERS 프레임의 페이로드에는 헤더 블록 조각이 포함됩니다\(섹션 4.3\). HEADERS 프레임에 맞지 않는 헤더 블록은 CONTINUATION 프레임\(섹션 6.10\)에서 계속됩니다.

HEADERS 프레임은 스트림과 연결되어야 합니다. 스트림 식별자 필드가 0x0인 HEADERS 프레임이 수신되면 수신자는 PROTOCOL\_ERROR 유형의 연결 오류\(섹션 5.4.1\)로 응답해야 합니다.\(MUST, MUST\)

HEADERS 프레임은 섹션 4.3에서 설명한 대로 연결 상태를 변경합니다.

HEADERS 프레임은 패딩을 포함할 수 있습니다. 패딩 필드와 플래그는 DATA 프레임에 대해 정의된 것과 동일합니다\(섹션 6.1\). 헤더 블록 조각에 남아 있는 크기를 초과하는 패딩은 PROTOCOL\_ERROR로 처리해야 합니다.\(MUST\)

HEADERS 프레임의 우선 순위 지정 정보는 논리적으로 별도의 PRIORITY 프레임과 동일하지만 HEADERS에 포함하면 새 스트림이 생성될 때 스트림 우선 순위 지정에서 이탈 가능성을 방지할 수 있습니다. 스트림의 첫 번째 프레임 다음에 있는 HEADERS 프레임의 우선 순위 지정 필드는 스트림의 우선 순위를 재지정합니다\(섹션 5.3.3\).

---
### **6.3.  PRIORITY**

PRIORITY 프레임\(유형=0x2\)은 스트림의 발신자 조언 우선순위를 지정합니다\(섹션 5.3\). 유휴 또는 닫힌 스트림을 포함하여 모든 스트림 상태에서 보낼 수 있습니다.

```text
    +-+-------------------------------------------------------------+
    |E|                  Stream Dependency (31)                     |
    +-+-------------+-----------------------------------------------+
    |   Weight (8)  |
    +-+-------------+

                     Figure 8: PRIORITY Frame Payload
```

PRIORITY 프레임의 페이로드에는 다음 필드가 포함됩니다.

E: 스트림 종속성이 배타적임을 나타내는 단일 비트 플래그\(섹션 5.3 참조\).

스트림 종속성: 이 스트림이 의존하는 스트림에 대한 31비트 스트림 식별자입니다\(섹션 5.3 참조\).

가중치: 스트림의 우선 순위 가중치를 나타내는 부호 없는 8비트 정수\(섹션 5.3 참조\). 값에 1을 더하여 1에서 256 사이의 가중치를 얻습니다.

PRIORITY 프레임은 플래그를 정의하지 않습니다.

PRIORITY 프레임은 항상 스트림을 식별합니다. 스트림 식별자 0x0으로 PRIORITY 프레임이 수신되면 수신자는 PROTOCOL\_ERROR 유형의 연결 오류\(섹션 5.4.1\)로 응답해야 합니다.\(MUST\)

PRIORITY 프레임은 단일 헤더 블록\(4.3절\)을 구성하는 연속 프레임 간에는 보낼 수 없지만 모든 상태의 스트림에서 보낼 수 있습니다. 이 프레임은 처리 또는 프레임 전송이 완료된 후에 도착할 수 있으며, 이로 인해 식별된 스트림에 영향을 주지 않습니다. "반 폐쇄\(원격\)" 또는 "폐쇄" 상태에 있는 스트림의 경우 이 프레임은 식별된 스트림 및 해당 종속 스트림의 처리에만 영향을 미칠 수 있습니다. 해당 스트림의 프레임 전송에는 영향을 주지 않습니다.

PRIORITY 프레임은 "유휴" 또는 "닫힌" 상태의 스트림에 대해 전송될 수 있습니다. 이렇게 하면 사용되지 않거나 닫힌 상위 스트림의 우선 순위를 변경하여 종속 스트림 그룹의 우선 순위를 재지정할 수 있습니다.

길이가 5 옥텟이 아닌 PRIORITY 프레임은 FRAME\_SIZE\_ERROR 유형의 스트림 오류\(섹션 5.4.2\)로 처리해야 합니다.\(MUST\)

---
### **6.4.  RST_STREAM**

RST\_STREAM 프레임\(유형=0x3\)을 사용하면 스트림을 즉시 종료할 수 있습니다. RST\_STREAM은 스트림 취소를 요청하거나 오류 조건이 발생했음을 나타내기 위해 전송됩니다.

```text
    +---------------------------------------------------------------+
    |                        Error Code (32)                        |
    +---------------------------------------------------------------+

                    Figure 9: RST_STREAM Frame Payload
```

RST\_STREAM 프레임에는 오류 코드를 식별하는 부호 없는 단일 32비트 정수가 포함됩니다\(섹션 7\). 오류 코드는 스트림이 종료되는 이유를 나타냅니다.

RST\_STREAM 프레임은 플래그를 정의하지 않습니다.

RST\_STREAM 프레임은 참조된 스트림을 완전히 종료하고 "닫힌" 상태로 들어가게 합니다. 스트림에서 RST\_STREAM을 수신한 후 수신자는 PRIORITY를 제외하고 해당 스트림에 대한 추가 프레임을 보내면 안 됩니다. 그러나 RST\_STREAM을 전송한 후 전송 엔드포인트는 RST\_STREAM이 도착하기 전에 피어가 전송했을 수 있는 스트림에서 전송된 추가 프레임을 수신하고 처리할 수 있도록 준비해야 합니다.\(MUST NOT, MUST\)

RST\_STREAM 프레임은 스트림과 연결되어야 합니다. RST\_STREAM 프레임이 스트림 식별자 0x0으로 수신되면 수신자는 이를 PROTOCOL\_ERROR 유형의 연결 오류\(섹션 5.4.1\)로 처리해야 합니다.\(MUST, MUST\)

"유휴" 상태의 스트림에 대해 RST\_STREAM 프레임을 보내서는 안 됩니다\(MUST NOT\). 유휴 스트림을 식별하는 RST\_STREAM 프레임이 수신되면 수신자는 이를 PROTOCOL\_ERROR 유형의 연결 오류\(섹션 5.4.1\)로 처리해야 합니다.\(MUST NOT, MUST\)

길이가 4 옥텟이 아닌 RST\_STREAM 프레임은 FRAME\_SIZE\_ERROR 유형의 연결 오류\(섹션 5.4.1\)로 처리해야 합니다.\(MUST\)

---
### **6.5.  SETTINGS**

SETTINGS 프레임\(유형=0x4\)은 피어 동작에 대한 기본 설정 및 제약과 같이 엔드포인트가 통신하는 방식에 영향을 미치는 구성 매개변수를 전달합니다. SETTINGS 프레임은 이러한 매개변수 수신을 승인하는 데에도 사용됩니다. 개별적으로 SETTINGS 매개변수는 "설정"이라고도 합니다.

SETTINGS 매개변수는 협상되지 않습니다. 수신 피어가 사용하는 송신 피어의 특성을 설명합니다. 동일한 매개변수에 대해 서로 다른 값을 각 피어에서 알릴 수 있습니다. 예를 들어 클라이언트는 초기 흐름 제어 창을 높게 설정하는 반면 서버는 리소스를 절약하기 위해 더 낮은 값을 설정할 수 있습니다.

SETTINGS 프레임은 연결 시작 시 두 엔드포인트에서 전송해야 하며 연결 ​​수명 동안 어느 한 엔드포인트에서 다른 시간에 전송할 수 있습니다. 구현은 이 사양에서 정의한 모든 매개변수를 지원해야 합니다.\(MUST, MUST\)

SETTINGS 프레임의 각 매개변수는 해당 매개변수의 기존 값을 대체합니다. 매개변수는 나타나는 순서대로 처리되며 SETTINGS 프레임의 수신자는 매개변수의 현재 값 이외의 상태를 유지할 필요가 없습니다. 따라서 SETTINGS 매개변수의 값은 수신기에 표시되는 마지막 값입니다.

SETTINGS 매개변수는 수신 피어에서 승인됩니다. 이를 활성화하기 위해 SETTINGS 프레임은 다음 플래그를 정의합니다.

ACK\(0x1\): 설정되면 비트 0은 이 프레임이 피어의 SETTINGS 프레임 수신 및 적용을 승인함을 나타냅니다. 이 비트가 설정되면 SETTINGS 프레임의 페이로드가 비어 있어야 합니다. ACK 플래그가 설정되고 길이 필드 값이 0이 아닌 SETTINGS 프레임의 수신은 FRAME\_SIZE\_ERROR 유형의 연결 오류\(섹션 5.4.1\)로 처리되어야 합니다. 자세한 내용은 섹션 6.5.3\("설정 동기화"\)을 참조하십시오.\(MUST, MUST\)

SETTINGS 프레임은 항상 단일 스트림이 아닌 연결에 적용됩니다. SETTINGS 프레임의 스트림 식별자는 0\(0x0\)이어야 합니다. 엔드포인트가 스트림 식별자 필드가 0x0이 아닌 SETTINGS 프레임을 수신하는 경우 엔드포인트는 PROTOCOL\_ERROR 유형의 연결 오류\(섹션 5.4.1\)로 응답해야 합니다.\(MUST, MUST\)

SETTINGS 프레임은 연결 상태에 영향을 미칩니다. 잘못 구성되었거나 불완전한 SETTINGS 프레임은 PROTOCOL\_ERROR 유형의 연결 오류\(섹션 5.4.1\)로 처리되어야 합니다.\(MUST\)

길이가 6 옥텟의 배수가 아닌 SETTINGS 프레임은 FRAME\_SIZE\_ERROR 유형의 연결 오류\(섹션 5.4.1\)로 처리해야 합니다.\(MUST\)

---
#### **6.5.1.  SETTINGS Format**

SETTINGS 프레임의 페이로드는 0개 이상의 매개변수로 구성되며, 각 매개변수는 부호 없는 16비트 설정 식별자와 부호 없는 32비트 값으로 구성됩니다.

```text
    +-------------------------------+
    |       Identifier (16)         |
    +-------------------------------+-------------------------------+
    |                        Value (32)                             |
    +---------------------------------------------------------------+

                         Figure 10: Setting Format
```

---
#### **6.5.2.  Defined SETTINGS Parameters**

다음 매개변수가 정의됩니다.

SETTINGS\_HEADER\_TABLE\_SIZE\(0x1\): 발신자가 헤더 블록을 디코딩하는 데 사용되는 헤더 압축 테이블의 최대 크기\(옥텟\)를 원격 엔드포인트에 알릴 수 있습니다. 인코더는 헤더 블록 내부의 헤더 압축 형식에 특정한 신호를 사용하여 이 값 이하의 크기를 선택할 수 있습니다\(\[COMPRESSION\] 참조\). 초기 값은 4,096 옥텟입니다.

SETTINGS\_ENABLE\_PUSH\(0x2\): 이 설정은 서버 푸시를 비활성화하는 데 사용할 수 있습니다\(섹션 8.2\). 엔드포인트는 값 0으로 설정된 이 매개변수를 수신하는 경우 PUSH\_PROMISE 프레임을 보내면 안 됩니다. 1\) PROTOCOL\_ERROR 유형.\(MUST NOT, MUST\)

- 초기 값은 1이며 서버 푸시가 허용됨을 나타냅니다. 0 또는 1 이외의 모든 값은 PROTOCOL\_ERROR 유형의 연결 오류\(섹션 5.4.1\)로 처리되어야 합니다.\(MUST\)

SETTINGS\_MAX\_CONCURRENT\_STREAMS\(0x3\): 발신자가 허용할 최대 동시 스트림 수를 나타냅니다. 이 제한은 방향적입니다. 발신자가 수신자가 생성하도록 허용하는 스트림 수에 적용됩니다. 처음에는 이 값에 제한이 없습니다. 불필요하게 병렬 처리를 제한하지 않도록 이 값은 100보다 작지 않은 것이 좋습니다.

- SETTINGS\_MAX\_CONCURRENT\_STREAMS에 대한 0 값은 끝점에서 특수한 것으로 취급되어서는 안 됩니다\(SHOULD NOT\). 값이 0이면 새 스트림이 생성되지 않습니다. 그러나 이것은 또한 모든 경우에 발생할 수 있습니다.\(SHOULD NOT\)

- 활성 스트림으로 소진된 제한. 서버는 짧은 기간 동안만 0 값을 설정해야 합니다. 서버가 요청을 수락하지 않으려면 연결을 닫는 것이 더 적절합니다.\(SHOULD\)

SETTINGS\_INITIAL\_WINDOW\_SIZE\(0x4\): 스트림 수준 흐름 제어를 위한 보낸 사람의 초기 창 크기\(옥텟\)를 나타냅니다. 초기 값은 2^16-1\(65,535\) 옥텟입니다.

이 설정은 모든 스트림의 창 크기에 영향을 미칩니다\(

- 섹션 6.9.2\).

- 2^31-1의 최대 흐름 제어 창 크기를 초과하는 값은 FLOW\_CONTROL\_ERROR 유형의 연결 오류\(섹션 5.4.1\)로 처리되어야 합니다.\(MUST\)

SETTINGS\_MAX\_FRAME\_SIZE\(0x5\): 발신자가 수신하고자 하는 가장 큰 프레임 페이로드의 크기를 옥텟 단위로 나타냅니다.

- 초기값은 2^14\(16,384\) 옥텟입니다. 끝점에서 광고하는 값은 이 초기 값과 최대 허용 프레임 크기\(2^24-1 또는 16,777,215 옥텟\) 사이여야 합니다. 이 범위 밖의 값은 PROTOCOL\_ERROR 유형의 연결 오류\(섹션 5.4.1\)로 처리해야 합니다.\(MUST, MUST\)

SETTINGS\_MAX\_HEADER\_LIST\_SIZE \(0x6\): 이 권고 설정은 발신자가 수락할 준비가 된 헤더 목록의 최대 크기를 옥텟 단위로 피어에게 알립니다. 이 값은 헤더 필드의 압축되지 않은 크기를 기반으로 하며 여기에는 옥텟 단위의 이름 및 값 길이와 각 헤더 필드에 대한 32옥텟의 오버헤드가 포함됩니다.

- 주어진 요청에 대해 광고된 것보다 더 낮은 제한이 적용될 수 있습니다. 이 설정의 초기 값은 무제한입니다.\(MAY\)

알 수 없거나 지원되지 않는 식별자가 있는 SETTINGS 프레임을 수신하는 엔드포인트는 해당 설정을 무시해야 합니다.\(MUST\)

---
#### **6.5.3.  Settings Synchronization**

SETTINGS의 대부분의 값은 피어가 변경된 매개변수 값을 수신하고 적용한 시기를 이해하거나 이해해야 합니다. 이러한 동기화 시점을 제공하기 위해 ACK 플래그가 설정되지 않은 SETTINGS 프레임의 수신자는 수신 즉시 업데이트된 매개변수를 적용해야 합니다.\(MUST\)

SETTINGS 프레임의 값은 값 사이에 다른 프레임 처리 없이 나타나는 순서대로 처리되어야 합니다. 지원되지 않는 매개변수는 무시해야 합니다. 모든 값이 처리되면\(MUST, MUST\)

수신자는 ACK 플래그가 설정된 SETTINGS 프레임을 즉시 내보내야 합니다. ACK 플래그가 설정된 SETTINGS 프레임을 수신하면 변경된 매개변수의 발신자는 적용된 설정에 의존할 수 있습니다.\(MUST\)

SETTINGS 프레임의 발신자가 합리적인 시간 내에 승인을 받지 못하면 SETTINGS\_TIMEOUT 유형의 연결 오류\(섹션 5.4.1\)를 발행할 수 있습니다.\(MAY\)

---
### **6.6.  PUSH_PROMISE**

PUSH\_PROMISE 프레임\(유형=0x5\)은 발신자가 시작하려는 스트림에 앞서 피어 엔드포인트에 알리는 데 사용됩니다. PUSH\_PROMISE 프레임에는 끝점이 스트림에 대한 추가 컨텍스트를 제공하는 헤더 집합과 함께 생성할 계획인 스트림의 서명되지 않은 31비트 식별자가 포함됩니다. 섹션 8.2에는 PUSH\_PROMISE 프레임 사용에 대한 자세한 설명이 포함되어 있습니다.

```text
    +---------------+
    |Pad Length? (8)|
    +-+-------------+-----------------------------------------------+
    |R|                  Promised Stream ID (31)                    |
    +-+-----------------------------+-------------------------------+
    |                   Header Block Fragment (*)                 ...
    +---------------------------------------------------------------+
    |                           Padding (*)                       ...
    +---------------------------------------------------------------+

                  Figure 11: PUSH_PROMISE Payload Format
```

PUSH\_PROMISE 프레임 페이로드에는 다음 필드가 있습니다.

패드 길이: 옥텟 단위의 프레임 패딩 길이를 포함하는 8비트 필드입니다. 이 필드는 PADDED 플래그가 설정된 경우에만 존재합니다.

R: 단일 예약 비트.

약속된 스트림 ID: PUSH\_PROMISE에 의해 예약된 스트림을 식별하는 부호 없는 31비트 정수입니다. 약속된 스트림 식별자는 발신자가 보낸 다음 스트림에 대해 유효한 선택이어야 합니다\(섹션 5.1.1의 "새 스트림 식별자" 참조\).\(MUST\)

헤더 블록 조각: 요청 헤더 필드를 포함하는 헤더 블록 조각\(섹션 4.3\).

```text
   Padding:  Padding octets.
```

PUSH\_PROMISE 프레임은 다음 플래그를 정의합니다.

END\_HEADERS\(0x4\): 설정되면 비트 2는 이 프레임이 전체 헤더 블록\(섹션 4.3\)을 포함하고 어떤 CONTINUATION 프레임도 뒤따르지 않음을 나타냅니다.

- END\_HEADERS 플래그가 설정되지 않은 PUSH\_PROMISE 프레임 뒤에는 동일한 스트림에 대한 CONTINUATION 프레임이 와야 합니다. 수신기는 다른 유형의 프레임 또는 다른 스트림의 프레임 수신을 PROTOCOL\_ERROR 유형의 연결 오류\(섹션 5.4.1\)로 처리해야 합니다.\(MUST, MUST\)

PADDED\(0x8\): 설정되면 비트 3은 패드 길이 필드와 여기에 설명된 패딩이 있음을 나타냅니다.

PUSH\_PROMISE 프레임은 "개방" 또는 "반폐쇄\(원격\)" 상태에 있는 피어 시작 스트림에서만 전송되어야 합니다. PUSH\_PROMISE 프레임의 스트림 식별자는 연결된 스트림을 나타냅니다. 스트림 식별자 필드가 값 0x0을 지정하는 경우 수신자는 PROTOCOL\_ERROR 유형의 연결 오류\(섹션 5.4.1\)로 응답해야 합니다.\(MUST, MUST\)

약속된 스트림은 약속된 순서대로 사용할 필요가 없습니다. PUSH\_PROMISE는 나중에 사용할 수 있도록 스트림 식별자만 예약합니다.

피어 끝점의 SETTINGS\_ENABLE\_PUSH 설정이 0으로 설정된 경우 PUSH\_PROMISE를 보내면 안 됩니다. 이 설정을 설정하고 승인을 받은 끝점은 PUSH\_PROMISE 프레임 수신을 PROTOCOL\_ERROR 유형의 연결 오류\(섹션 5.4.1\)로 처리해야 합니다. .\(MUST NOT, MUST\)

PUSH\_PROMISE 프레임의 수신자는 약속된 스트림 식별자를 참조하는 RST\_STREAM을 PUSH\_PROMISE의 발신자에게 다시 반환하여 약속된 스트림을 거부하도록 선택할 수 있습니다.

PUSH\_PROMISE 프레임은 두 가지 방식으로 연결 상태를 수정합니다. 첫째, 헤더 블록\(섹션 4.3\)의 포함은 잠재적으로 헤더 압축을 위해 유지되는 상태를 수정합니다. 둘째, PUSH\_PROMISE는 나중에 사용할 수 있도록 스트림을 예약하므로 약속된 스트림이 "예약됨" 상태가 됩니다. 송신자는 스트림이 "개방" 또는 "반 폐쇄\(원격\)"가 아닌 한 스트림에서 PUSH\_PROMISE를 보내면 안 됩니다\(MUST NOT\). 발신자는 약속된 스트림이 새로운 스트림 식별자\(섹션 5.1.1\)에 대해 유효한 선택인지 확인해야 합니다\(즉, 약속된 스트림이 "유휴" 상태에 있어야 함\).\(MUST NOT\)

PUSH\_PROMISE는 스트림을 예약하므로 PUSH\_PROMISE 프레임을 무시하면 스트림 상태가 불확실해집니다. 수신자는 PROTOCOL\_ERROR 유형의 연결 오류\(섹션 5.4.1\)로 "개방"도 "반폐쇄\(로컬\)"도 아닌 스트림에서 PUSH\_PROMISE 수신을 처리해야 합니다. 그러나 연결된 스트림에서 RST\_STREAM을 보낸 엔드포인트는 RST\_STREAM 프레임을 수신하고 처리하기 전에 생성되었을 수 있는 PUSH\_PROMISE 프레임을 처리해야 합니다.\(MUST, MUST\)

수신자는 잘못된 스트림 식별자\(섹션 5.1.1\)를 약속하는 PUSH\_PROMISE의 수신을 PROTOCOL\_ERROR 유형의 연결 오류\(섹션 5.4.1\)로 처리해야 합니다. 잘못된 스트림 식별자는 현재 "유휴" 상태가 아닌 스트림의 식별자입니다.\(MUST\)

PUSH\_PROMISE 프레임은 패딩을 포함할 수 있습니다. 패딩 필드와 플래그는 DATA 프레임에 대해 정의된 것과 동일합니다\(섹션 6.1\).

---
### **6.7.  PING**

PING 프레임\(유형=0x6\)은 송신자로부터의 최소 왕복 시간을 측정하고 유휴 연결이 여전히 작동하는지 여부를 결정하기 위한 메커니즘입니다. PING 프레임은 모든 끝점에서 보낼 수 있습니다.

```text
    +---------------------------------------------------------------+
    |                                                               |
    |                      Opaque Data (64)                         |
    |                                                               |
    +---------------------------------------------------------------+

                      Figure 12: PING Payload Format
```

프레임 헤더 외에도 PING 프레임은 페이로드에 8옥텟의 불투명 데이터를 포함해야 합니다. 발신자는 선택한 모든 값을 포함할 수 있으며 해당 옥텟을 어떤 방식으로든 사용할 수 있습니다.\(MUST\)

ACK 플래그를 포함하지 않는 PING 프레임의 수신자는 응답으로 동일한 페이로드와 함께 ACK 플래그가 설정된 PING 프레임을 보내야 합니다. PING 응답은 다른 프레임보다 높은 우선 순위를 부여받아야 합니다\(SHOULD\).\(MUST, SHOULD\)

PING 프레임은 다음 플래그를 정의합니다.

ACK\(0x1\): 설정되면 비트 0은 이 PING 프레임이 PING 응답임을 나타냅니다. 엔드포인트는 PING 응답에서 이 플래그를 설정해야 합니다. 엔드포인트는 이 플래그를 포함하는 PING 프레임에 응답하면 안 됩니다\(MUST NOT\).\(MUST, MUST NOT\)

PING 프레임은 개별 스트림과 연결되지 않습니다. 0x0 이외의 스트림 식별자 필드 값으로 PING 프레임이 수신되면 수신자는 PROTOCOL\_ERROR 유형의 연결 오류\(섹션 5.4.1\)로 응답해야 합니다.\(MUST\)

길이 필드 값이 8이 아닌 PING 프레임의 수신은 FRAME\_SIZE\_ERROR 유형의 연결 오류\(섹션 5.4.1\)로 처리되어야 합니다.\(MUST\)

---
### **6.8.  GOAWAY**

GOAWAY 프레임\(유형=0x7\)은 연결 종료를 시작하거나 심각한 오류 상태를 알리는 데 사용됩니다. GOAWAY를 사용하면 엔드포인트가 이전에 설정된 스트림의 처리를 계속 완료하면서 새 스트림 수락을 정상적으로 중지할 수 있습니다. 이를 통해 서버 유지 관리와 같은 관리 작업을 수행할 수 있습니다.

새 스트림을 시작하는 엔드포인트와 GOAWAY 프레임을 보내는 원격 사이에는 고유한 경합 조건이 있습니다. 이 경우를 처리하기 위해 GOAWAY에는 이 연결의 송신 엔드포인트에서 처리되었거나 처리될 수 있는 마지막 피어 시작 스트림의 스트림 식별자가 포함됩니다. 예를 들어 서버가 GOAWAY 프레임을 보내는 경우 식별된 스트림은 클라이언트에서 시작한 가장 높은 번호의 스트림입니다.

일단 전송되면 스트림에 포함된 마지막 스트림 식별자보다 높은 식별자가 있는 경우 전송자는 수신자가 시작한 스트림에서 전송된 프레임을 무시합니다. GOAWAY 프레임의 수신기는 새 스트림에 대해 새 연결을 설정할 수 있지만 연결에서 추가 스트림을 열면 안 됩니다\(MUST NOT\).\(MUST NOT\)

GOAWAY의 수신자가 GOAWAY 프레임에 표시된 것보다 더 높은 스트림 식별자가 있는 스트림에서 데이터를 보낸 경우 해당 스트림은 처리되지 않거나 처리되지 않습니다. GOAWAY 프레임의 수신자는 스트림을 전혀 생성되지 않은 것처럼 처리할 수 있으므로 나중에 새 연결에서 해당 스트림을 다시 시도할 수 있습니다.

엔드포인트는 원격 피어가 스트림이 부분적으로 처리되었는지 여부를 알 수 있도록 연결을 닫기 전에 항상 GOAWAY 프레임을 보내야 합니다\(SHOULD\). 예를 들어 HTTP 클라이언트가 서버가 연결을 닫는 것과 동시에 POST를 보내는 경우 서버가 어떤 스트림이 있는지 표시하기 위해 GOAWAY 프레임을 보내지 않으면 클라이언트는 서버가 해당 POST 요청을 처리하기 시작했는지 알 수 없습니다. 행동했다.\(SHOULD\)

엔드포인트는 오작동하는 피어에 대해 GOAWAY를 보내지 않고 연결을 닫도록 선택할 수 있습니다.

GOAWAY 프레임은 연결 종료 바로 앞에 있지 않을 수 있습니다. 더 이상 연결을 사용하지 않는 GOAWAY의 수신기는 연결을 종료하기 전에 여전히 GOAWAY 프레임을 보내야 합니다\(SHOULD\).\(SHOULD\)

```text
    +-+-------------------------------------------------------------+
    |R|                  Last-Stream-ID (31)                        |
    +-+-------------------------------------------------------------+
    |                      Error Code (32)                          |
    +---------------------------------------------------------------+
    |                  Additional Debug Data (*)                    |
    +---------------------------------------------------------------+

                     Figure 13: GOAWAY Payload Format
```

GOAWAY 프레임은 플래그를 정의하지 않습니다.

GOAWAY 프레임은 특정 스트림이 아닌 연결에 적용됩니다. 엔드포인트는 0x0 이외의 스트림 식별자를 가진 GOAWAY 프레임을 PROTOCOL\_ERROR 유형의 연결 오류\(섹션 5.4.1\)로 처리해야 합니다.\(MUST\)

GOAWAY 프레임의 마지막 스트림 식별자에는 GOAWAY 프레임의 발신자가 조치를 취했거나 아직 조치를 취하지 않은 가장 높은 번호의 스트림 식별자가 포함됩니다. 식별된 스트림까지의 모든 스트림은 어떤 방식으로든 처리되었을 수 있습니다. 스트림이 처리되지 않은 경우 마지막 스트림 식별자를 0으로 설정할 수 있습니다.

- 참고: 이 문맥에서 "처리됨"은 스트림의 일부 데이터가 결과적으로 어떤 조치를 취했을 수 있는 일부 상위 소프트웨어 계층으로 전달되었음을 의미합니다.

GOAWAY 프레임 없이 연결이 종료되면 마지막 스트림 식별자는 사실상 가능한 가장 높은 스트림 식별자입니다.

연결이 닫히기 전에 완전히 닫히지 않은 더 낮거나 같은 번호의 식별자가 있는 스트림에서는 HTTP GET, PUT 또는 DELETE와 같은 idempotent 작업을 제외하고 요청, 트랜잭션 또는 프로토콜 활동을 다시 시도할 수 없습니다. 더 높은 번호의 스트림을 사용하는 모든 프로토콜 활동은 새 연결을 사용하여 안전하게 재시도할 수 있습니다.

마지막 스트림 식별자보다 낮거나 같은 번호가 매겨진 스트림의 활동은 여전히 ​​성공적으로 완료될 수 있습니다. GOAWAY 프레임의 발신자는 진행 중인 모든 스트림이 완료될 때까지 연결을 "열린" 상태로 유지하면서 GOAWAY 프레임을 전송하여 연결을 정상적으로 종료할 수 있습니다.

엔드포인트는 상황이 바뀌면 여러 GOAWAY 프레임을 보낼 수 있습니다. 예를 들어 정상적인 종료 중에 NO\_ERROR와 함께 GOAWAY를 전송하는 엔드포인트는 이후 연결을 즉시 종료해야 하는 상황에 직면할 수 있습니다. 수신된 마지막 GOAWAY 프레임의 마지막 스트림 식별자는 어떤 스트림이 작동될 수 있었는지 나타냅니다. 엔드포인트는 피어가 이미 다른 연결에서 처리되지 않은 요청을 재시도했을 수 있으므로 마지막 스트림 식별자에서 보내는 값을 증가시켜서는 안 됩니다\(MUST NOT\).\(MAY, MUST NOT\)

요청을 재시도할 수 없는 클라이언트는 서버가 연결을 닫을 때 진행 중인 모든 요청을 잃게 됩니다. 이것은 특히 HTTP/2를 사용하여 클라이언트에 서비스를 제공하지 않을 수 있는 중개자에게 해당됩니다. 연결을 정상적으로 종료하려고 시도하는 서버는 마지막 스트림 식별자가 2^31-1로 설정된 초기 GOAWAY 프레임과 NO\_ERROR 코드를 보내야 합니다\(SHOULD\). 이는 종료가 임박했으며 추가 요청 시작이 금지됨을 클라이언트에 알립니다. 진행 중인 스트림 생성을 위한 시간\(적어도 한 번의 왕복 시간\)을 허용한 후 서버는 업데이트된 마지막 스트림 식별자와 함께 다른 GOAWAY 프레임을 보낼 수 있습니다. 이렇게 하면 요청 손실 없이 연결을 완전히 종료할 수 있습니다.\(SHOULD\)

GOAWAY 프레임을 보낸 후 발신자는 식별된 마지막 스트림보다 높은 식별자를 가진 수신자가 시작한 스트림의 프레임을 버릴 수 있습니다. 그러나 연결 상태를 변경하는 프레임은 완전히 무시할 수 없습니다. 예를 들어 HEADERS, PUSH\_PROMISE 및 CONTINUATION 프레임은 헤더 압축을 위해 유지되는 상태가 일관되도록 최소한으로 처리되어야 합니다\(섹션 4.3 참조\). 마찬가지로 DATA 프레임은 연결 흐름 제어 창으로 계산되어야 합니다. 이러한 프레임을 처리하지 못하면 흐름 제어 또는 헤더 압축 상태가 동기화되지 않을 수 있습니다.\(MUST\)

GOAWAY 프레임에는 연결 종료 이유가 포함된 32비트 오류 코드\(섹션 7\)도 포함되어 있습니다.

엔드포인트는 모든 GOAWAY 프레임의 페이로드에 불투명 데이터를 추가할 수 있습니다\(MAY\). 추가 디버그 데이터는 진단 목적으로만 사용되며 의미론적 값을 전달하지 않습니다. 디버그 정보에는 보안 또는 개인 정보에 민감한 데이터가 포함될 수 있습니다. 기록되거나 지속적으로 저장된 디버그 데이터에는 무단 액세스를 방지하기 위한 적절한 보호 장치가 있어야 합니다.\(MAY, MUST\)

---
### **6.9.  WINDOW_UPDATE**

WINDOW\_UPDATE 프레임\(유형=0x8\)은 흐름 제어를 구현하는 데 사용됩니다. 개요는 섹션 5.2를 참조하십시오.

흐름 제어는 각 개별 스트림과 전체 연결의 두 가지 수준에서 작동합니다.

두 흐름 제어 유형 모두 홉 바이 홉입니다. 즉, 두 끝점 사이에서만 가능합니다. 중개자는 종속 연결 간에 WINDOW\_UPDATE 프레임을 전달하지 않습니다. 그러나 수신자에 의한 데이터 전송 제한은 간접적으로 원래 발신자를 향한 흐름 제어 정보의 전파를 유발할 수 있습니다.

흐름 제어는 흐름 제어 대상으로 식별된 프레임에만 적용됩니다. 이 문서에 정의된 프레임 유형 중 DATA 프레임만 포함됩니다. 흐름 제어에서 제외된 프레임은 수신기가 프레임 처리에 리소스를 할당할 수 없는 경우가 아니면 수락 및 처리되어야 합니다. 수신기는 프레임을 수락할 수 없는 경우 FLOW\_CONTROL\_ERROR 유형의 스트림 오류\(섹션 5.4.2\) 또는 연결 오류\(섹션 5.4.1\)로 응답할 수 있습니다\(MAY\).\(MUST, MAY\)

```text
    +-+-------------------------------------------------------------+
    |R|              Window Size Increment (31)                     |
    +-+-------------------------------------------------------------+

                  Figure 14: WINDOW_UPDATE Payload Format
```

WINDOW\_UPDATE 프레임의 페이로드는 예약된 비트 1개에 기존 흐름 제어 창에 추가하여 발신자가 전송할 수 있는 옥텟 수를 나타내는 부호 없는 31비트 정수를 더한 것입니다. 흐름 제어 창에 대한 증분의 법적 범위는 1에서 2^31-1\(2,147,483,647\) 옥텟입니다.

WINDOW\_UPDATE 프레임은 플래그를 정의하지 않습니다.

WINDOW\_UPDATE 프레임은 스트림 또는 전체 연결에 고유할 수 있습니다. 전자의 경우 프레임의 스트림 식별자는 영향을 받는 스트림을 나타냅니다. 후자에서 값 "0"은 전체 연결이 프레임의 주체임을 나타냅니다.

수신기는 흐름 제어 창 증분이 0인 WINDOW\_UPDATE 프레임의 수신을 PROTOCOL\_ERROR 유형의 스트림 오류\(섹션 5.4.2\)로 처리해야 합니다. 연결 흐름 제어 창의 오류는 연결 오류로 처리되어야 합니다\(섹션 5.4.1\).\(MUST\)

WINDOW\_UPDATE는 END\_STREAM 플래그가 포함된 프레임을 보낸 피어에서 보낼 수 있습니다. 이는 수신기가 "반 폐쇄\(원격\)" 또는 "폐쇄" 스트림에서 WINDOW\_UPDATE 프레임을 수신할 수 있음을 의미합니다. 수신기는 이것을 오류로 취급해서는 안 됩니다\(섹션 5.1 참조\).\(MUST NOT\)

흐름 제어 프레임을 수신하는 수신자는 수신자가 이를 연결 오류\(섹션 5.4.1\)로 처리하지 않는 한 연결 흐름 제어 창에 대한 기여도를 항상 설명해야 합니다. 이는 프레임에 오류가 있는 경우에도 필요합니다. 발신자는 흐름 제어 창을 향해 프레임을 계산하지만 수신자가 계산하지 않으면 발신자와 수신자의 흐름 제어 창이 달라질 수 있습니다.\(MUST\)

길이가 4 옥텟이 아닌 WINDOW\_UPDATE 프레임은 FRAME\_SIZE\_ERROR 유형의 연결 오류\(섹션 5.4.1\)로 처리해야 합니다.\(MUST\)

---
#### **6.9.1.  The Flow-Control Window**

HTTP/2의 흐름 제어는 모든 스트림에서 각 발신자가 보관하는 창을 사용하여 구현됩니다. 흐름 제어 창은 보낸 사람이 전송할 수 있는 데이터 옥텟 수를 나타내는 간단한 정수 값입니다. 따라서 그 크기는 수신기의 버퍼링 용량을 측정한 것입니다.

스트림 흐름 제어 창과 연결 흐름 제어 창의 두 가지 흐름 제어 창을 적용할 수 있습니다. 발신자는 수신자가 광고한 흐름 제어 창 중 하나에서 사용 가능한 공간을 초과하는 길이의 흐름 제어 프레임을 보내면 안 됩니다\(MUST NOT\). END\_STREAM 플래그가 설정된 길이가 0인 프레임\(즉, 빈 DATA 프레임\)은 흐름 제어 창에 사용 가능한 공간이 없는 경우 전송될 수 있습니다\(MAY\).\(MUST NOT, MAY\)

흐름 제어 계산의 경우 9옥텟 프레임 헤더는 계산되지 않습니다.

흐름 제어 프레임을 보낸 후 보낸 사람은 전송된 프레임의 길이만큼 두 창에서 사용 가능한 공간을 줄입니다.

프레임의 수신자는 데이터를 소비하고 흐름 제어 창의 공간을 확보하면서 WINDOW\_UPDATE 프레임을 보냅니다. 스트림 및 연결 수준 흐름 제어 창에 대해 별도의 WINDOW\_UPDATE 프레임이 전송됩니다.

WINDOW\_UPDATE 프레임을 수신한 발신자는 프레임에 지정된 양만큼 해당 창을 업데이트합니다.

발신자는 흐름 제어 창이 2^31-1 옥텟을 초과하도록 허용해서는 안 됩니다\(MUST NOT\). 발신자가 흐름 제어 창이 이 최대값을 초과하게 하는 WINDOW\_UPDATE를 수신하는 경우 스트림 또는 연결을 적절하게 종료해야 합니다. 스트림의 경우 발신자는 오류 코드가 FLOW\_CONTROL\_ERROR인 RST\_STREAM을 보냅니다. 연결을 위해 오류 코드가 FLOW\_CONTROL\_ERROR인 GOAWAY 프레임이 전송됩니다.\(MUST NOT, MUST\)

송신자의 흐름 제어 프레임과 수신자의 WINDOW\_UPDATE 프레임은 서로 완전히 비동기식입니다. 이 속성을 사용하면 수신자가 송신자가 유지하는 창 크기를 적극적으로 업데이트하여 스트림이 중단되지 않도록 할 수 있습니다.

---
#### **6.9.2.  Initial Flow-Control Window Size**

HTTP/2 연결이 처음 설정되면 초기 흐름 제어 창 크기가 65,535옥텟인 새 스트림이 생성됩니다. 연결 흐름 제어 창도 65,535옥텟입니다. 두 엔드포인트는 연결 서문의 일부를 구성하는 SETTINGS 프레임에 SETTINGS\_INITIAL\_WINDOW\_SIZE 값을 포함하여 새 스트림의 초기 창 크기를 조정할 수 있습니다. 연결 흐름 제어 창은 WINDOW\_UPDATE 프레임을 사용해서만 변경할 수 있습니다.

SETTINGS\_INITIAL\_WINDOW\_SIZE에 대한 값을 설정하는 SETTINGS 프레임을 수신하기 전에 엔드포인트는 흐름 제어 프레임을 보낼 때 기본 초기 창 크기만 사용할 수 있습니다. 마찬가지로 연결 흐름 제어 창은 WINDOW\_UPDATE 프레임이 수신될 때까지 기본 초기 창 크기로 설정됩니다.

아직 활성화되지 않은 스트림에 대한 흐름 제어 창을 변경하는 것 외에도 SETTINGS 프레임은 활성 흐름 제어 창이 있는 스트림의 초기 흐름 제어 창 크기를 변경할 수 있습니다. -폐쇄\(원격\)" 상태\). SETTINGS\_INITIAL\_WINDOW\_SIZE 값이 변경되면 수신기는 새 값과 이전 값의 차이만큼 유지하는 모든 스트림 흐름 제어 창의 크기를 조정해야 합니다.\(MUST\)

SETTINGS\_INITIAL\_WINDOW\_SIZE를 변경하면 흐름 제어 창에서 사용 가능한 공간이 음수가 될 수 있습니다. 발신자는 음의 흐름 제어 창을 추적해야 하며 흐름 제어 창이 양수가 되도록 하는 WINDOW\_UPDATE 프레임을 수신할 때까지 새 흐름 제어 프레임을 보내서는 안 됩니다\(MUST NOT\).\(MUST NOT\)

예를 들어 클라이언트가 연결 설정 즉시 60KB를 보내고 서버가 초기 창 크기를 16KB로 설정하면 클라이언트는 사용 가능한 흐름 제어 창을 다음으로 다시 계산합니다.

SETTINGS 프레임을 수신하면 -44KB가 됩니다. 클라이언트는 WINDOW\_UPDATE 프레임이 창을 양수로 복원할 때까지 음수 흐름 제어 창을 유지한 후 클라이언트가 전송을 재개할 수 있습니다.

SETTINGS 프레임은 연결 흐름 제어 창을 변경할 수 없습니다.

엔드포인트는 흐름 제어 창이 최대 크기를 초과하도록 하는 SETTINGS\_INITIAL\_WINDOW\_SIZE의 변경을 FLOW\_CONTROL\_ERROR 유형의 연결 오류\(섹션 5.4.1\)로 처리해야 합니다.\(MUST\)

---
#### **6.9.3.  Reducing the Stream Window Size**

현재 크기보다 작은 흐름 제어 창을 사용하려는 수신기는 새 SETTINGS 프레임을 보낼 수 있습니다. 그러나 송신자가 SETTINGS 프레임을 처리하기 전에 하한을 초과하는 데이터를 보낼 수 있으므로 수신자는 이 창 크기를 초과하는 데이터를 수신할 준비가 되어 있어야 합니다.\(MUST\)

초기 흐름 제어 창 크기를 줄이는 SETTINGS 프레임을 보낸 후 수신기는 흐름 제어 제한을 초과하는 스트림을 계속 처리할 수 있습니다. 스트림이 계속되도록 허용해도 수신자는 흐름 제어 창을 위해 예약한 공간을 즉시 줄일 수 없습니다. 발신자가 전송을 다시 시작하려면 WINDOW\_UPDATE 프레임이 필요하기 때문에 이러한 스트림의 진행이 지연될 수도 있습니다. 수신자는 대신 영향을 받는 스트림에 대해 오류 코드 FLOW\_CONTROL\_ERROR와 함께 RST\_STREAM을 보낼 수 있습니다\(MAY\).\(MAY, MAY\)

---
### **6.10.  CONTINUATION**

CONTINUATION 프레임\(유형=0x9\)은 헤더 블록 조각 시퀀스를 계속하는 데 사용됩니다\(섹션 4.3\). 이전 프레임이 동일한 스트림에 있고 END\_HEADERS 플래그가 설정되지 않은 HEADERS, PUSH\_PROMISE 또는 CONTINUATION 프레임인 한 개수에 관계없이 CONTINUATION 프레임을 보낼 수 있습니다.

```text
    +---------------------------------------------------------------+
    |                   Header Block Fragment (*)                 ...
    +---------------------------------------------------------------+

                   Figure 15: CONTINUATION Frame Payload
```

CONTINUATION 프레임 페이로드에는 헤더 블록 조각\(섹션 4.3\)이 포함되어 있습니다.

CONTINUATION 프레임은 다음 플래그를 정의합니다.

END\_HEADERS\(0x4\): 설정되면 비트 2는 이 프레임이 헤더 블록을 종료함을 나타냅니다\(섹션 4.3\).

- END\_HEADERS 비트가 설정되지 않은 경우 이 프레임 다음에 다른 CONTINUATION 프레임이 와야 합니다. 수신기는 다른 유형의 프레임 또는 다른 스트림의 프레임 수신을 PROTOCOL\_ERROR 유형의 연결 오류\(섹션 5.4.1\)로 처리해야 합니다.\(MUST, MUST\)

CONTINUATION 프레임은 섹션 4.3에 정의된 대로 연결 상태를 변경합니다.

CONTINUATION 프레임은 반드시 스트림과 연결되어야 합니다. 스트림 식별자 필드가 0x0인 CONTINUATION 프레임이 수신되면 수신자는 PROTOCOL\_ERROR 유형의 연결 오류\(섹션 5.4.1\)로 응답해야 합니다.\(MUST, MUST\)

CONTINUATION 프레임 앞에는 END\_HEADERS 플래그가 설정되지 않은 HEADERS, PUSH\_PROMISE 또는 CONTINUATION 프레임이 있어야 합니다. 이 규칙 위반을 관찰한 수신자는 PROTOCOL\_ERROR 유형의 연결 오류\(섹션 5.4.1\)로 응답해야 합니다.\(MUST, MUST\)

---
## **7.  Error Codes**

오류 코드는 스트림 또는 연결 오류의 원인을 전달하기 위해 RST\_STREAM 및 GOAWAY 프레임에 사용되는 32비트 필드입니다.

오류 코드는 공통 코드 공간을 공유합니다. 일부 오류 코드는 스트림 또는 전체 연결에만 적용되며 다른 컨텍스트에는 정의된 의미 체계가 없습니다.

다음 오류 코드가 정의됩니다.

NO\_ERROR\(0x0\): 연결된 조건이 오류의 결과가 아닙니다. 예를 들어 GOAWAY에는 연결의 정상적인 종료를 나타내기 위해 이 코드가 포함될 수 있습니다.

PROTOCOL\_ERROR\(0x1\): 엔드포인트에서 불특정 프로토콜 오류를 감지했습니다. 이 오류는 더 구체적인 오류 코드를 사용할 수 없을 때 사용합니다.

INTERNAL\_ERROR\(0x2\): 끝점에서 예기치 않은 내부 오류가 발생했습니다.

FLOW\_CONTROL\_ERROR\(0x3\): 엔드포인트에서 피어가 흐름 제어 프로토콜을 위반했음을 감지했습니다.

SETTINGS\_TIMEOUT\(0x4\): 엔드포인트가 SETTINGS 프레임을 보냈지만 적시에 응답을 받지 못했습니다. 섹션 6.5.3\("설정 동기화"\)을 참조하십시오.

STREAM\_CLOSED\(0x5\): 스트림이 반쯤 닫힌 후 끝점이 프레임을 수신했습니다.

FRAME\_SIZE\_ERROR\(0x6\): 끝점이 유효하지 않은 크기의 프레임을 수신했습니다.

REFUSED\_STREAM\(0x7\): 엔드포인트가 애플리케이션 처리를 수행하기 전에 스트림을 거부했습니다\(자세한 내용은 섹션 8.1.4 참조\).

CANCEL\(0x8\): 스트림이 더 이상 필요하지 않음을 나타내기 위해 엔드포인트에서 사용됩니다.

COMPRESSION\_ERROR\(0x9\): 끝점이 연결에 대한 헤더 압축 컨텍스트를 유지할 수 없습니다.

CONNECT\_ERROR\(0xa\): CONNECT 요청\(섹션 8.3\)에 대한 응답으로 설정된 연결이 재설정되었거나 비정상적으로 닫혔습니다.

ENHANCE\_YOUR\_CALM\(0xb\): 엔드포인트에서 피어가 과도한 로드를 생성할 수 있는 동작을 나타내고 있음을 감지했습니다.

INADEQUATE\_SECURITY\(0xc\): 기본 전송에 최소 보안 요구 사항을 충족하지 않는 속성이 있습니다\(섹션 9.2 참조\).

HTTP\_1\_1\_REQUIRED\(0xd\): 끝점에서 HTTP/2 대신 HTTP/1.1을 사용해야 합니다.\(MUST\)

알 수 없거나 지원되지 않는 오류 코드는 특별한 동작을 트리거해서는 안 됩니다\(MUST NOT\). 이들은 구현에 의해 INTERNAL\_ERROR와 동등한 것으로 처리될 수 있습니다\(MAY\).\(MUST NOT, MAY\)

---
## **8.  HTTP Message Exchanges**

HTTP/2는 현재 HTTP 사용과 가능한 한 호환되도록 의도되었습니다. 이는 애플리케이션 관점에서 프로토콜의 기능이 크게 변경되지 않았음을 의미합니다. 이를 달성하기 위해 해당 의미 체계를 전달하는 구문이 변경되더라도 모든 요청 및 응답 의미 체계가 보존됩니다.

따라서 HTTP/1.1 Semantics and Content \[RFC7231\], Conditional Requests \[RFC7232\], Range Requests \[RFC7233\], Caching \[RFC7234\] 및 Authentication \[RFC7235\]의 사양 및 요구 사항이 HTTP/2에 적용됩니다. HTTP/1.1 메시지 구문의 선택된 부분

HTTP 및 HTTPS URI 체계와 같은 라우팅\[RFC7230\]은 HTTP/2에도 적용 가능하지만 이 프로토콜에 대한 해당 의미 체계의 표현은 아래 섹션에 정의되어 있습니다.

---
### **8.1.  HTTP Request/Response Exchange**

클라이언트는 이전에 사용하지 않은 스트림 식별자\(섹션 5.1.1\)를 사용하여 새 스트림에서 HTTP 요청을 보냅니다. 서버는 요청과 동일한 스트림에서 HTTP 응답을 보냅니다.

HTTP 메시지\(요청 또는 응답\)는 다음으로 구성됩니다.

```text
   1.  for a response only, zero or more HEADERS frames (each followed
       by zero or more CONTINUATION frames) containing the message
       headers of informational (1xx) HTTP responses (see [RFC7230],
       Section 3.2 and [RFC7231], Section 6.2),

   2.  one HEADERS frame (followed by zero or more CONTINUATION frames)
       containing the message headers (see [RFC7230], Section 3.2),
```

3. 페이로드 본문을 포함하는 0개 이상의 DATA 프레임\(\[RFC7230\], 섹션 3.3 참조\) 및

4. 선택적으로, 하나의 HEADERS 프레임에 이어 0개 이상이 뒤따름

- 존재하는 경우 트레일러 부분을 포함하는 CONTINUATION 프레임\(\[RFC7230\], 섹션 4.1.2 참조\).

시퀀스의 마지막 프레임에는 END\_STREAM 플래그가 있습니다. 즉, END\_STREAM 플래그가 있는 HEADERS 프레임 뒤에는 헤더 블록의 나머지 부분을 전달하는 CONTINUATION 프레임이 올 수 있습니다.

다른 프레임\(모든 스트림의\)은 HEADERS 프레임과 뒤따를 수 있는 CONTINUATION 프레임 사이에 발생해서는 안 됩니다.\(MUST NOT\)

HTTP/2는 DATA 프레임을 사용하여 메시지 페이로드를 전달합니다. \[RFC7230\]의 섹션 4.1에 정의된 "청크" 전송 인코딩은 HTTP/2에서 사용되어서는 안 됩니다\(MUST NOT\).\(MUST NOT\)

후행 헤더 필드는 스트림을 종료하는 헤더 블록에서도 전달됩니다. 이러한 헤더 블록은 HEADERS 프레임으로 시작하여 0개 이상의 CONTINUATION 프레임이 뒤따르는 시퀀스이며 HEADERS 프레임에는 END\_STREAM 플래그가 있습니다. 스트림을 종료하지 않는 첫 번째 이후의 헤더 블록은 HTTP 요청 또는 응답의 일부가 아닙니다.

HEADERS 프레임\(및 관련 CONTINUATION 프레임\)은 스트림의 시작 또는 끝에만 나타날 수 있습니다. 최종\(비정보용\) 상태 코드를 수신한 후 END\_STREAM 플래그가 설정되지 않은 HEADERS 프레임을 수신하는 엔드포인트는 해당 요청 또는 응답을 잘못된 형식으로 처리해야 합니다\(섹션 8.1.2.6\).\(MUST\)

HTTP 요청/응답 교환은 단일 스트림을 완전히 사용합니다. 요청은 스트림을 "열린" 상태로 만드는 HEADERS 프레임으로 시작됩니다. 요청은 END\_STREAM을 포함하는 프레임으로 끝납니다. 이로 인해 스트림이 클라이언트에 대해 "반 폐쇄\(로컬\)"되고 서버에 대해 "반 폐쇄\(원격\)"가 됩니다. 응답은 HEADERS 프레임으로 시작하여 스트림을 "닫힌" 상태로 만드는 END\_STREAM이 포함된 프레임으로 끝납니다.

HTTP 응답은 서버가 END\_STREAM 플래그가 설정된 프레임\(헤더 블록을 완성하는 데 필요한 모든 CONTINUATION 프레임 포함\)을 전송하거나 클라이언트가 수신한 후에 완료됩니다. 응답이 전송 및 수신되지 않은 요청 부분에 의존하지 않는 경우 서버는 클라이언트가 전체 요청을 전송하기 전에 완전한 응답을 전송할 수 있습니다. 이것이 사실일 때 서버는 완전한 응답\(즉, END\_STREAM 플래그가 있는 프레임\)을 보낸 후 오류 코드 NO\_ERROR와 함께 RST\_STREAM을 보내 클라이언트가 오류 없이 요청 전송을 중단하도록 요청할 수 있습니다\(MAY\). 클라이언트는 이러한 RST\_STREAM을 수신한 결과로 응답을 폐기해서는 안 됩니다\(MUST NOT\). 클라이언트는 다른 이유로 항상 재량에 따라 응답을 폐기할 수 있습니다.\(MAY, MUST NOT\)

---
#### **8.1.1.  Upgrading from HTTP/2**

HTTP/2는 101\(스위칭 프로토콜\) 정보 상태 코드\(\[RFC7231\], 섹션 6.2.2\)에 대한 지원을 제거합니다.

101\(Switching Protocols\)의 의미는 다중화된 프로토콜에 적용할 수 없습니다. 대체 프로토콜은 HTTP/2가 사용을 협상하는 데 사용하는 것과 동일한 메커니즘을 사용할 수 있습니다\(섹션 3 참조\).

---
#### **8.1.2.  HTTP Header Fields**

```text
   HTTP header fields carry information as a series of key-value pairs.
   For a listing of registered HTTP headers, see the "Message Header
   Field" registry maintained at <https://www.iana.org/assignments/
   message-headers>.
```

HTTP/1.x에서와 마찬가지로 헤더 필드 이름은 대소문자를 구분하지 않는 방식으로 비교되는 ASCII 문자열입니다. 그러나 헤더 필드 이름은 HTTP/2로 인코딩하기 전에 반드시 소문자로 변환해야 합니다. 대문자 헤더 필드 이름을 포함하는 요청 또는 응답은 잘못된 형식으로 처리되어야 합니다\(섹션 8.1.2.6\).\(MUST, MUST\)

---
##### **8.1.2.1.  Pseudo-Header Fields**

HTTP/1.x가 대상 URI, 요청 방법 및 응답의 상태 코드를 전달하기 위해 메시지 시작 줄\(\[RFC7230\], 섹션 3.1 참조\)을 사용하는 반면 HTTP/2는 특별한 의사 헤더 필드를 사용합니다. 이를 위해 ':' 문자\(ASCII 0x3a\)로 시작합니다.

의사 헤더 필드는 HTTP 헤더 필드가 아닙니다. 끝점은 이 문서에 정의된 것 이외의 의사 헤더 필드를 생성하면 안 됩니다\(MUST NOT\).\(MUST NOT\)

의사 헤더 필드는 정의된 컨텍스트에서만 유효합니다. 요청에 대해 정의된 의사 헤더 필드는 응답에 나타나지 않아야 합니다. 응답에 대해 정의된 의사 헤더 필드는 요청에 나타나지 않아야 합니다\(MUST NOT\). 의사 헤더 필드는 예고편에 나타나지 않아야 합니다\(MUST NOT\). 끝점은 정의되지 않았거나 유효하지 않은 의사 헤더 필드를 포함하는 요청 또는 응답을 잘못된 형식으로 처리해야 합니다\(섹션 8.1.2.6\).\(MUST NOT, MUST NOT, MUST\)

모든 의사 헤더 필드는 헤더 블록에서 일반 헤더 필드 앞에 나타나야 합니다. 일반 헤더 필드 다음에 헤더 블록에 나타나는 의사 헤더 필드를 포함하는 모든 요청 또는 응답은 형식이 잘못된 것으로 처리해야 합니다\(섹션 8.1.2.6\).\(MUST, MUST\)

---
##### **8.1.2.2.  Connection-Specific Header Fields**

HTTP/2는 연결 관련 헤더 필드를 나타내기 위해 연결 헤더 필드를 사용하지 않습니다. 이 프로토콜에서 연결별 메타데이터는 다른 수단으로 전달됩니다. 끝점은 연결별 헤더 필드를 포함하는 HTTP/2 메시지를 생성하면 안 됩니다. 연결별 헤더 필드를 포함하는 모든 메시지는 잘못된 형식으로 처리되어야 합니다\(섹션 8.1.2.6\).\(MUST NOT\)

이에 대한 유일한 예외는 HTTP/2 요청에 존재할 수 있는 TE 헤더 필드입니다. 이 경우 "트레일러" 이외의 값을 포함해서는 안 됩니다\(MUST NOT\).\(MUST NOT\)

이는 HTTP/1.x 메시지를 HTTP/2로 변환하는 중개자가 Connection 헤더 필드 자체와 함께 Connection 헤더 필드에서 지정한 모든 헤더 필드를 제거해야 함을 의미합니다. 이러한 중개자는 연결 헤더 필드에 의해 지정되지 않은 경우에도 Keep-Alive, Proxy-Connection, Transfer-Encoding 및 Upgrade와 같은 다른 연결 관련 헤더 필드도 제거해야 합니다\(SHOULD\).\(SHOULD\)

- 참고: HTTP/2는 의도적으로 다른 프로토콜로의 업그레이드를 지원하지 않습니다. 섹션 3에 설명된 핸드셰이크 방법은 대체 프로토콜 사용을 협상하기에 충분하다고 생각됩니다.

---
##### **8.1.2.3.  Request Pseudo-Header Fields**

다음 의사 헤더 필드는 HTTP/2 요청에 대해 정의됩니다.

o ":method" 의사 헤더 필드에는 HTTP 메서드\(\[RFC7231\], 섹션 4\)가 포함됩니다.

o ":scheme" 의사 헤더 필드는 대상 URI의 체계 부분을 포함합니다\(\[RFC3986\], 섹션 3.1\).

- ":scheme"은 "http" 및 "https" 스키마 URI로 제한되지 않습니다. 프록시 또는 게이트웨이는 비 HTTP 체계에 대한 요청을 변환하여 HTTP를 사용하여 비 HTTP 서비스와 상호 작용할 수 있습니다.

o ":authority" 의사 헤더 필드는 대상 URI의 권한 부분을 포함합니다\(\[RFC3986\], 섹션 3.2\). 권한은 "http" 또는 "https" 스키마 URI에 대한 더 이상 사용되지 않는 "userinfo" 하위 구성 요소를 포함해서는 안 됩니다\(MUST NOT\).\(MUST NOT\)

- HTTP/1.1 요청 라인이 정확하게 재생될 수 있도록 하기 위해 요청 대상이 원본 또는 별표 형식인 HTTP/1.1 요청에서 변환할 때 이 의사 헤더 필드를 생략해야 합니다\(\[RFC7230\], 섹션 5.3 참조\). . HTTP/2 요청을 직접 생성하는 클라이언트는 호스트 헤더 필드 대신 ":authority" 의사 헤더 필드를 사용해야 합니다. HTTP/2 요청을 HTTP/1.1로 변환하는 중개자는 요청에 호스트 헤더 필드가 없으면 ":authority" 의사 헤더 필드의 값을 복사하여 호스트 헤더 필드를 만들어야 합니다.\(MUST, SHOULD, MUST\)

o ":path" 의사 헤더 필드는 대상 URI의 경로 및 쿼리 부분을 포함합니다\("경로 절대" 생성 및 선택적으로 "쿼리" 생성이 뒤따르는 '?' 문자\(\[의 섹션 3.3 및 3.4 참조\). RFC3986\]\) 별표 형식의 요청에는 ":path" 의사 헤더 필드에 대한 값 '\*'이 포함됩니다.

- 이 의사 헤더 필드는 "http" 또는 "https" URI에 대해 비어 있으면 안 됩니다. 경로 구성요소를 포함하지 않는 "http" 또는 "https" URI는 '/' 값을 포함해야 합니다. 이 규칙의 예외는 경로 구성 요소를 포함하지 않는 "http" 또는 "https" URI에 대한 OPTIONS 요청입니다. 여기에는 값이 '\*'인 ":path" 의사 헤더 필드가 포함되어야 합니다\(\[RFC7230\], 섹션 5.3.4 참조\).\(MUST NOT, MUST\)

모든 HTTP/2 요청은 CONNECT 요청이 아닌 한 ":method", ":scheme" 및 ":path" 의사 헤더 필드에 대해 정확히 하나의 유효한 값을 포함해야 합니다\(섹션 8.3\). 필수 의사 헤더 필드를 생략하는 HTTP 요청은 잘못된 형식입니다\(섹션 8.1.2.6\).\(MUST\)

HTTP/2는 HTTP/1.1 요청 라인에 포함된 버전 식별자를 전달하는 방법을 정의하지 않습니다.

---
##### **8.1.2.4.  Response Pseudo-Header Fields**

HTTP/2 응답의 경우 HTTP 상태 코드 필드를 전달하는 단일 ":status" 의사 헤더 필드가 정의됩니다\(\[RFC7231\], 섹션 6 참조\). 이 의사 헤더 필드는 모든 응답에 포함되어야 합니다. 그렇지 않으면 응답 형식이 잘못되었습니다\(섹션 8.1.2.6\).\(MUST\)

HTTP/2는 HTTP/1.1 상태 표시줄에 포함된 버전 또는 이유 문구를 전달하는 방법을 정의하지 않습니다.

---
##### **8.1.2.5.  Compressing the Cookie Header Field**

쿠키 헤더 필드\[COOKIE\]는 세미콜론\(";"\)을 사용하여 쿠키 쌍\(또는 "부스러기"\)을 구분합니다. 이 헤더 필드는 쿠키 쌍이 다른 이름-값 쌍으로 분리되는 것을 방지하는 HTTP의 목록 구성 규칙\(\[RFC7230\], 섹션 3.2.2 참조\)을 따르지 않습니다. 이렇게 하면 개별 쿠키 쌍이 업데이트될 때 압축 효율성이 크게 감소할 수 있습니다.

더 나은 압축 효율성을 위해 쿠키 헤더 필드는 각각 하나 이상의 쿠키 쌍이 있는 별도의 헤더 필드로 분할될 수 있습니다. 압축 해제 후 쿠키 헤더 필드가 여러 개 있는 경우 이러한 필드는 HTTP/2가 아닌 컨텍스트로 전달되기 전에 0x3B, 0x20\(ASCII 문자열 ";"\)의 2옥텟 구분 기호를 사용하여 단일 옥텟 문자열로 연결되어야 합니다. HTTP/1.1 연결 또는 일반 HTTP 서버 애플리케이션으로.\(MAY, MUST\)

따라서 쿠키 헤더 필드의 다음 두 목록은 의미상 동일합니다.

```text
     cookie: a=b; c=d; e=f

     cookie: a=b
     cookie: c=d
     cookie: e=f
```

---
##### **8.1.2.6.  Malformed Requests and Responses**

잘못된 형식의 요청 또는 응답은 HTTP/2 프레임의 유효한 시퀀스이지만 관련 없는 프레임의 존재, 금지된 헤더 필드, 필수 헤더 필드의 부재 또는 대문자 헤더 필드 이름 포함으로 인해 유효하지 않은 요청 또는 응답입니다.

페이로드 본문을 포함하는 요청 또는 응답은 콘텐츠 길이 헤더 필드를 포함할 수 있습니다. 콘텐츠 길이 헤더 필드의 값이 본문을 구성하는 DATA 프레임 페이로드 길이의 합과 같지 않은 경우에도 요청 또는 응답의 형식이 잘못된 것입니다. \[RFC7230\], 섹션 3.3.2에 설명된 대로 페이로드가 없는 것으로 정의된 응답은 DATA 프레임에 콘텐츠가 포함되어 있지 않더라도 0이 아닌 콘텐츠 길이 헤더 필드를 가질 수 있습니다.

HTTP 요청 또는 응답을 처리하는 중개자\(즉, 터널 역할을 하지 않는 중개자\)는 형식이 잘못된 요청 또는 응답을 전달해서는 안 됩니다\(MUST NOT\). 감지된 잘못된 요청 또는 응답은 PROTOCOL\_ERROR 유형의 스트림 오류\(섹션 5.4.2\)로 처리되어야 합니다.\(MUST NOT, MUST\)

형식이 잘못된 요청의 경우 서버는 스트림을 닫거나 재설정하기 전에 HTTP 응답을 보낼 수 있습니다\(MAY\). 클라이언트는 형식이 잘못된 응답을 수락해서는 안 됩니다\(MUST NOT\). 이러한 요구 사항은 HTTP에 대한 몇 가지 일반적인 공격 유형으로부터 보호하기 위한 것입니다. 관대하면 구현이 이러한 취약점에 노출될 수 있기 때문에 의도적으로 엄격합니다.\(MAY, MUST NOT\)

---
#### **8.1.3.  Examples**

이 섹션에서는 HTTP/1.1 요청 및 응답을 동등한 HTTP/2 요청 및 응답 그림과 함께 보여줍니다.

HTTP GET 요청은 요청 헤더 필드를 포함하고 페이로드 본문은 포함하지 않으므로 단일 HEADERS 프레임으로 전송되며, 요청 헤더 필드의 직렬화된 블록을 포함하는 0개 이상의 CONTINUATION 프레임이 이어집니다. 다음의 HEADERS 프레임에는 END\_HEADERS 및 END\_STREAM 플래그가 모두 설정되어 있습니다. CONTINUATION 프레임이 전송되지 않습니다.

```text
     GET /resource HTTP/1.1           HEADERS
     Host: example.org          ==>     + END_STREAM
     Accept: image/jpeg                 + END_HEADERS
                                          :method = GET
                                          :scheme = https
                                          :path = /resource
                                          host = example.org
                                          accept = image/jpeg
```

마찬가지로, 응답 헤더 필드만 포함하는 응답은 응답 헤더 필드의 직렬화된 블록을 포함하는 HEADERS 프레임\(다시 0개 이상의 CONTINUATION 프레임이 뒤따름\)으로 전송됩니다.

```text
     HTTP/1.1 304 Not Modified        HEADERS
     ETag: "xyzzy"              ==>     + END_STREAM
     Expires: Thu, 23 Jan ...           + END_HEADERS
                                          :status = 304
                                          etag = "xyzzy"
                                          expires = Thu, 23 Jan ...
```

요청 헤더 필드와 페이로드 데이터를 포함하는 HTTP POST 요청은 하나의 HEADERS 프레임으로 전송되며, 요청 헤더 필드를 포함하는 0개 이상의 CONTINUATION 프레임, 하나 이상의 DATA 프레임, 마지막 CONTINUATION\(또는 HEADERS\) 프레임은 END\_HEADERS 플래그 세트 및 END\_STREAM 플래그 세트가 있는 최종 DATA 프레임:

```text
     POST /resource HTTP/1.1          HEADERS
     Host: example.org          ==>     - END_STREAM
     Content-Type: image/jpeg           - END_HEADERS
     Content-Length: 123                  :method = POST
                                          :path = /resource
     {binary data}                        :scheme = https

                                      CONTINUATION
                                        + END_HEADERS
                                          content-type = image/jpeg
                                          host = example.org
                                          content-length = 123

                                      DATA
                                        + END_STREAM
                                      {binary data}
```

지정된 헤더 필드에 기여하는 데이터는 헤더 블록 조각 간에 분산될 수 있습니다. 이 예에서 헤더 필드를 프레임에 할당하는 것은 예시일 뿐입니다.

헤더 필드와 페이로드 데이터를 포함하는 응답은 HEADERS 프레임으로 전송되며, 0개 이상의 CONTINUATION 프레임과 하나 이상의 DATA 프레임이 이어지며 시퀀스의 마지막 DATA 프레임에는 END\_STREAM 플래그가 설정됩니다.

```text
     HTTP/1.1 200 OK                  HEADERS
     Content-Type: image/jpeg   ==>     - END_STREAM
     Content-Length: 123                + END_HEADERS
                                          :status = 200
     {binary data}                        content-type = image/jpeg
                                          content-length = 123

                                      DATA
                                        + END_STREAM
                                      {binary data}
```

101 이외의 1xx 상태 코드를 사용하는 정보 응답은 HEADERS 프레임으로 전송되고 그 뒤에 0개 이상의 CONTINUATION 프레임이 이어집니다.

후행 헤더 필드는 요청 또는 응답 헤더 블록과 모든 DATA 프레임이 전송된 후 헤더 블록으로 전송됩니다. 트레일러 헤더 블록을 시작하는 HEADERS 프레임에는 END\_STREAM 플래그가 설정되어 있습니다.

다음 예제에는 Expect 헤더 필드에 "100-continue" 토큰이 포함된 요청에 대한 응답으로 전송되는 100\(계속\) 상태 코드와 후행 헤더 필드가 모두 포함되어 있습니다.

```text
     HTTP/1.1 100 Continue            HEADERS
     Extension-Field: bar       ==>     - END_STREAM
                                        + END_HEADERS
                                          :status = 100
                                          extension-field = bar

     HTTP/1.1 200 OK                  HEADERS
     Content-Type: image/jpeg   ==>     - END_STREAM
     Transfer-Encoding: chunked         + END_HEADERS
     Trailer: Foo                         :status = 200
                                          content-length = 123
     123                                  content-type = image/jpeg
     {binary data}                        trailer = Foo
     0
     Foo: bar                         DATA
                                        - END_STREAM
                                      {binary data}

                                      HEADERS
                                        + END_STREAM
                                        + END_HEADERS
                                          foo = bar
```

---
#### **8.1.4.  Request Reliability Mechanisms in HTTP/2**

HTTP/1.1에서 HTTP 클라이언트는 오류의 특성을 확인할 수 있는 수단이 없기 때문에 오류가 발생하면 멱등성이 아닌 요청을 재시도할 수 없습니다. 오류가 발생하기 전에 일부 서버 처리가 발생했을 수 있으며 이로 인해 요청을 다시 시도하면 바람직하지 않은 결과가 발생할 수 있습니다.

HTTP/2는 클라이언트에게 요청이 처리되지 않았음을 보장하는 두 가지 메커니즘을 제공합니다.

o GOAWAY 프레임은 처리되었을 수 있는 가장 높은 스트림 번호를 나타냅니다. 따라서 더 높은 숫자의 스트림에 대한 요청은 안전하게 재시도할 수 있습니다.

o REFUSED\_STREAM 오류 코드는 처리가 발생하기 전에 스트림이 닫히고 있음을 나타내기 위해 RST\_STREAM 프레임에 포함될 수 있습니다. 재설정 스트림에서 전송된 모든 요청은 안전하게 재시도할 수 있습니다.

처리되지 않은 요청은 실패한 것이 아닙니다. 클라이언트는 멱등성이 아닌 메서드를 사용하더라도 자동으로 재시도할 수 있습니다.\(MAY\)

서버는 사실을 보장할 수 없는 한 스트림이 처리되지 않았음을 나타내서는 안 됩니다\(MUST NOT\). 스트림에 있는 프레임이 임의의 스트림에 대한 애플리케이션 계층으로 전달되는 경우 해당 스트림에 REFUSED\_STREAM을 사용해서는 안 되며 GOAWAY 프레임에는 지정된 스트림 식별자보다 크거나 같은 스트림 식별자가 포함되어야 합니다.\(MUST NOT, MUST NOT\)

이러한 메커니즘 외에도 PING 프레임은 클라이언트가 연결을 쉽게 테스트할 수 있는 방법을 제공합니다. 유휴 상태로 남아 있는 연결은 일부 미들박스\(예: 네트워크 주소 변환기 또는 로드 밸런서\)가 자동으로 연결 바인딩을 버리기 때문에 끊어질 수 있습니다. PING 프레임을 사용하면 클라이언트가 요청을 보내지 않고도 연결이 여전히 활성화되어 있는지 여부를 안전하게 테스트할 수 있습니다.

---
### **8.2.  Server Push**

HTTP/2는 서버가 이전 클라이언트가 시작한 요청과 관련하여 클라이언트에 대응하는 "약속된" 요청과 함께 응답을 선제적으로 전송\(또는 "푸시"\)할 수 있도록 합니다. 이는 원래 요청에 대한 응답을 완전히 처리하기 위해 클라이언트가 이러한 응답을 사용할 수 있어야 한다는 것을 서버가 알고 있을 때 유용할 수 있습니다.

클라이언트는 서버 푸시를 비활성화하도록 요청할 수 있지만 이는 각 홉에 대해 독립적으로 협상됩니다. SETTINGS\_ENABLE\_PUSH 설정을 0으로 설정하여 서버 푸시가 비활성화되었음을 나타낼 수 있습니다.

약속된 요청은 캐시 가능해야 하고\(\[RFC7231\], 섹션 4.2.3 참조\) 안전해야 하며\(\[RFC7231\], 섹션 4.2.1 참조\) 요청 본문을 포함해서는 안 됩니다\(MUST NOT\). 캐시할 수 없거나 안전한 것으로 알려지지 않았거나 요청 본문의 존재를 나타내는 약속된 요청을 수신하는 클라이언트는 PROTOCOL\_ERROR 유형의 스트림 오류\(섹션 5.4.2\)로 약속된 스트림을 재설정해야 합니다. 이로 인해 클라이언트가 새로 정의된 메서드를 안전한 것으로 인식하지 못하는 경우 약속된 스트림이 재설정될 수 있습니다.\(MUST NOT, MUST\)

캐시 가능한 푸시 응답\(\[RFC7234\], 섹션 3 참조\)은 HTTP 캐시를 구현하는 경우 클라이언트에서 저장할 수 있습니다. 푸시된 응답은 약속된 스트림 ID로 식별되는 스트림이 아직 열려 있는 동안 원본 서버에서 성공적으로 검증된 것으로 간주됩니다\(예: "no-cache" 캐시 응답 지시문이 있는 경우\(\[RFC7234\], 섹션 5.2.2\)\).

캐시할 수 없는 푸시된 응답은 HTTP 캐시에 의해 저장되어서는 안 됩니다\(MUST NOT\). 응용 프로그램에서 별도로 사용할 수 있습니다.\(MUST NOT, MAY\)

서버는 서버가 신뢰할 수 있는 ":authority" 의사 헤더 필드에 값을 포함해야 합니다\(섹션 10.1 참조\). 클라이언트는 서버가 권한이 없는 PUSH\_PROMISE를 PROTOCOL\_ERROR 유형의 스트림 오류\(섹션 5.4.2\)로 처리해야 합니다.\(MUST, MUST\)

중개자는 서버에서 푸시를 수신하고 클라이언트에 전달하지 않도록 선택할 수 있습니다. 즉, 푸시된 정보를 어떻게 활용하느냐는 중개인의 몫이다. 마찬가지로 중개자는 서버가 수행하는 작업 없이 클라이언트에 추가 푸시를 수행하도록 선택할 수 있습니다.

클라이언트는 푸시할 수 없습니다. 따라서 서버는 PUSH\_PROMISE 프레임의 수신을 PROTOCOL\_ERROR 유형의 연결 오류\(섹션 5.4.1\)로 처리해야 합니다. 클라이언트는 메시지를 PROTOCOL\_ERROR 유형의 연결 오류\(섹션 5.4.1\)로 처리하여 SETTINGS\_ENABLE\_PUSH 설정을 0 이외의 값으로 변경하려는 모든 시도를 거부해야 합니다.\(MUST, MUST\)

---
#### **8.2.1.  Push Requests**

서버 푸시는 요청에 응답하는 서버와 의미상 동일합니다. 그러나 이 경우 해당 요청은 서버에서 PUSH\_PROMISE 프레임으로 전송됩니다.

PUSH\_PROMISE 프레임에는 서버가 요청에 속성을 부여하는 완전한 요청 헤더 필드 세트를 포함하는 헤더 블록이 포함됩니다. 요청 본문을 포함하는 요청에 대한 응답을 푸시할 수 없습니다.

푸시된 응답은 항상 클라이언트의 명시적 요청과 연결됩니다. 서버에서 보낸 PUSH\_PROMISE 프레임은 해당 명시적 요청의 스트림에서 전송됩니다. PUSH\_PROMISE 프레임에는 서버에서 사용할 수 있는 스트림 식별자에서 선택한 약속된 스트림 식별자도 포함됩니다\(섹션 5.1.1 참조\).

PUSH\_PROMISE 및 후속 CONTINUATION 프레임의 헤더 필드는 유효하고 완전한 요청 헤더 필드 집합이어야 합니다\(섹션 8.1.2.3\). 서버는 ":method" 의사 헤더 필드에 안전하고 캐시 가능한 메소드를 포함해야 합니다. 클라이언트가 완전하고 유효한 헤더 필드 집합을 포함하지 않는 PUSH\_PROMISE를 수신하거나 ":method" 의사 헤더 필드가 안전하지 않은 메서드를 식별하는 경우 다음과 같은 스트림 오류\(섹션 5.4.2\)로 응답해야 합니다. PROTOCOL\_ERROR를 입력합니다.\(MUST, MUST, MUST\)

서버는 약속된 응답을 참조하는 프레임을 보내기 전에 PUSH\_PROMISE\(섹션 6.6\) 프레임을 보내야 합니다\(SHOULD\). 이렇게 하면 클라이언트가 PUSH\_PROMISE 프레임을 수신하기 전에 요청을 발행하는 경쟁을 피할 수 있습니다.\(SHOULD\)

예를 들어, 서버가 여러 이미지 파일에 대한 포함된 링크가 포함된 문서에 대한 요청을 수신하고 서버가 이러한 추가 이미지를 클라이언트에 푸시하기로 선택한 경우 이미지 링크가 포함된 DATA 프레임 전에 PUSH\_PROMISE 프레임을 보내면 클라이언트가 다음을 수행할 수 있습니다. 포함된 링크를 검색하기 전에 리소스가 푸시되는지 확인합니다. 마찬가지로 서버가 헤더 블록\(예: 링크 헤더 필드\)에서 참조하는 응답을 푸시하는 경우 헤더 블록을 보내기 전에 PUSH\_PROMISE를 보내면 클라이언트가 해당 리소스를 요청하지 않습니다.

PUSH\_PROMISE 프레임은 클라이언트에 의해 전송되어서는 안됩니다\(MUST NOT\).\(MUST NOT\)

PUSH\_PROMISE 프레임은 클라이언트 시작 스트림에 대한 응답으로 서버에서 보낼 수 있지만 스트림은 서버에 대해 "개방" 또는 "반 폐쇄\(원격\)" 상태여야 합니다. PUSH\_PROMISE 프레임은 단일 헤더 블록을 구성하는 HEADERS 및 CONTINUATION 프레임과 함께 배치될 수 없지만 응답을 구성하는 프레임과 함께 배치됩니다.\(MUST\)

PUSH\_PROMISE 프레임을 전송하면 새 스트림이 생성되고 스트림이 서버에 대해 "예약됨\(로컬\)" 상태가 되고 클라이언트에 대해 "예약됨\(원격\)" 상태가 됩니다.

---
#### **8.2.2.  Push Responses**

PUSH\_PROMISE 프레임을 보낸 후 서버는 약속된 스트림 식별자를 사용하는 서버 시작 스트림에 대한 응답\(섹션 8.1.2.4\)으로 푸시된 응답 전달을 시작할 수 있습니다. 서버는 섹션 8.1에 정의된 것과 동일한 프레임 시퀀스를 사용하여 HTTP 응답을 전송하기 위해 이 스트림을 사용합니다. 이 스트림은 초기 HEADERS 프레임이 전송된 후 클라이언트\(섹션 5.1\)에 대해 "절반 폐쇄"됩니다.

클라이언트가 PUSH\_PROMISE 프레임을 수신하고 푸시된 응답을 수락하기로 선택하면 클라이언트는 약속된 스트림이 닫힐 때까지 약속된 응답에 대한 요청을 발행해서는 안 됩니다\(SHOULD NOT\).\(SHOULD NOT\)

어떤 이유로든 클라이언트가 서버로부터 푸시된 응답을 받고 싶지 않다고 결정하거나 서버가 약속된 응답 전송을 시작하는 데 너무 오래 걸리는 경우 클라이언트는 CANCEL 또는 REFUSED\_STREAM을 사용하여 RST\_STREAM 프레임을 보낼 수 있습니다. 코드 및 푸시된 스트림의 식별자를 참조합니다.

클라이언트는 SETTINGS\_MAX\_CONCURRENT\_STREAMS 설정을 사용하여 서버에서 동시에 푸시할 수 있는 응답 수를 제한할 수 있습니다. SETTINGS\_MAX\_CONCURRENT\_STREAMS 값을 0으로 광고하면 서버가 필요한 스트림을 생성하지 못하도록 하여 서버 푸시가 비활성화됩니다. 이는 서버가 PUSH\_PROMISE 프레임을 보내는 것을 금지하지 않습니다. 클라이언트는 원하지 않는 약속된 스트림을 재설정해야 합니다.

푸시된 응답을 수신하는 클라이언트는 서버가 권한이 있는지\(섹션 10.1 참조\) 또는 푸시된 응답을 제공한 프록시가 해당 요청에 대해 구성되었는지 확인해야 합니다. 예를 들어 "example.com" DNS-ID 또는 일반 이름에 대한 인증서만 제공하는 서버는 "https://www.example.org/doc"에 대한 응답을 푸시할 수 없습니다.\(MUST\)

PUSH\_PROMISE 스트림에 대한 응답은 HEADERS 프레임으로 시작하여 스트림을 즉시 서버의 경우 "반 폐쇄\(원격\)" 상태로, 클라이언트의 경우 "반 폐쇄\(로컬\)" 상태로 만들고 프레임으로 끝납니다. 스트림을 "닫힌" 상태로 만드는 END\_STREAM 베어링.

- 참고: 클라이언트는 서버 푸시를 위해 END\_STREAM 플래그가 있는 프레임을 보내지 않습니다.

---
### **8.3.  The CONNECT Method**

HTTP/1.x에서 의사 메서드 CONNECT\(\[RFC7231\], 섹션 4.3.6\)는 HTTP 연결을 원격 호스트에 대한 터널로 변환하는 데 사용됩니다. CONNECT는 주로 HTTP 프록시와 함께 사용되어 "https" 리소스와 상호 작용할 목적으로 원본 서버와 TLS 세션을 설정합니다.

HTTP/2에서 CONNECT 메서드는 유사한 목적을 위해 단일 HTTP/2 스트림을 통해 원격 호스트에 대한 터널을 설정하는 데 사용됩니다. HTTP 헤더 필드 매핑은 섹션 8.1.2.3\("의사 헤더 필드 요청"\)에 정의된 대로 작동하지만 몇 가지 차이점이 있습니다. 구체적으로:

o ":method" 의사 헤더 필드는 "CONNECT"로 설정됩니다.

o ":scheme" 및 ":path" 의사 헤더 필드는 생략해야 합니다.\(MUST\)

o ":authority" 의사 헤더 필드는 연결할 호스트와 포트를 포함합니다\(CONNECT 요청의 요청 대상의 권한 형식과 동일\(\[RFC7230\], 섹션 5.3 참조\)\).

이러한 제한 사항을 준수하지 않는 CONNECT 요청은 잘못된 형식입니다\(섹션 8.1.2.6\).

CONNECT를 지원하는 프록시는 ":authority" 의사 헤더 필드에서 식별된 서버에 대한 TCP 연결\[TCP\]을 설정합니다. 이 연결이 성공적으로 설정되면 프록시는 \[RFC7231\], 섹션 4.3.6에 정의된 대로 2xx 시리즈 상태 코드를 포함하는 HEADERS 프레임을 클라이언트로 보냅니다.

각 피어가 보낸 초기 HEADERS 프레임 이후의 모든 후속 DATA 프레임은 TCP 연결에서 보낸 데이터에 해당합니다. 클라이언트가 보낸 DATA 프레임의 페이로드는 프록시에 의해 TCP 서버로 전송됩니다. TCP 서버에서 받은 데이터는 프록시에 의해 DATA 프레임으로 어셈블됩니다. DATA 또는 스트림 관리 프레임\(RST\_STREAM, WINDOW\_UPDATE 및 PRIORITY\) 이외의 프레임 유형은 연결된 스트림에서 보내서는 안 되며 수신된 경우 스트림 오류\(섹션 5.4.2\)로 처리해야 합니다.\(MUST NOT\)

TCP 연결은 두 피어 중 하나에서 닫을 수 있습니다. DATA 프레임의 END\_STREAM 플래그는 TCP FIN 비트와 동일한 것으로 취급됩니다. 클라이언트는 END\_STREAM 플래그가 포함된 프레임을 수신한 후 END\_STREAM 플래그가 설정된 DATA 프레임을 보낼 것으로 예상됩니다. END\_STREAM 플래그가 설정된 DATA 프레임을 수신한 프록시는 마지막 TCP 세그먼트에 FIN 비트가 설정된 첨부된 데이터를 보냅니다. FIN 비트가 설정된 TCP 세그먼트를 수신하는 프록시는 END\_STREAM 플래그가 설정된 DATA 프레임을 보냅니다. 마지막 TCP 세그먼트 또는 DATA 프레임이 비어 있을 수 있습니다.

TCP 연결 오류는 RST\_STREAM으로 신호를 받습니다. 프록시는 RST 비트가 설정된 TCP 세그먼트 수신을 포함하는 TCP 연결의 모든 오류를 CONNECT\_ERROR 유형의 스트림 오류\(섹션 5.4.2\)로 처리합니다. 이에 따라 프록시는 스트림 또는 HTTP/2 연결에서 오류를 감지한 경우 RST 비트가 설정된 TCP 세그먼트를 보내야 합니다.\(MUST\)

---
## **9.  Additional HTTP Requirements/Considerations**

이 섹션에서는 상호 운용성을 개선하고, 알려진 보안 취약점에 대한 노출을 줄이거나, 구현 변동 가능성을 줄이는 HTTP 프로토콜의 속성에 대해 설명합니다.

---
### **9.1.  Connection Management**

HTTP/2 연결은 지속적입니다. 최상의 성능을 위해 클라이언트는 서버와의 추가 통신이 필요하지 않다고 판단될 때까지\(예: 사용자가 특정 웹 페이지에서 다른 곳으로 이동하는 경우\) 또는 서버가 연결을 닫을 때까지 연결을 닫지 않을 것으로 예상됩니다.

클라이언트는 호스트가 URI, 선택된 대체 서비스\[ALT-SVC\] 또는 구성된 프록시에서 파생되는 지정된 호스트 및 포트 쌍에 대해 둘 이상의 HTTP/2 연결을 열면 안 됩니다\(SHOULD NOT\).\(SHOULD NOT\)

클라이언트는 사용 가능한 스트림 식별자 공간을 거의 소진하는 연결을 교체하거나\(섹션 5.1.1\), TLS 연결에 대한 키 자료를 새로 고치거나, 오류가 발생한 연결을 교체\(섹션 5.4.1\).

클라이언트는 다른 서버 이름 표시\[TLS-EXT\] 값을 사용하거나 다른 TLS 클라이언트 인증서를 제공하기 위해 동일한 IP 주소 및 TCP 포트에 대한 여러 연결을 열 수 있지만 동일한 구성으로 여러 연결을 만드는 것을 피해야 합니다\(SHOULD\).\(SHOULD\)

서버는 가능한 한 오랫동안 열린 연결을 유지하도록 권장되지만 필요한 경우 유휴 연결을 종료할 수 있습니다. 끝점이 전송 계층 TCP 연결을 닫도록 선택하면 종료 끝점은 먼저 GOAWAY\(6.8절\) 프레임을 보내서 두 끝점이 이전에 보낸 프레임이 처리되었는지 여부를 안정적으로 결정하고 필요한 나머지 작업을 정상적으로 완료하거나 종료할 수 있도록 해야 합니다.\(SHOULD\)

---
#### **9.1.1.  Connection Reuse**

CONNECT 방법\(섹션 8.3\)을 사용하여 생성된 터널을 통해 또는 직접적으로 원서버에 대한 연결은 여러 다른 URI 권한 구성 요소가 있는 요청에 재사용될 수 있습니다\(MAY\). 원본 서버가 신뢰할 수 있는 한 연결을 재사용할 수 있습니다\(10.1절\). TLS가 없는 TCP 연결의 경우 이는 동일한 IP 주소로 확인된 호스트에 따라 다릅니다.\(MAY\)

"https" 리소스의 경우 연결 재사용은 추가로 URI의 호스트에 유효한 인증서가 있는지 여부에 따라 달라집니다. 서버에서 제공하는 인증서는 URI에서 호스트에 대한 새 TLS 연결을 형성할 때 클라이언트가 수행하는 모든 검사를 충족해야 합니다.\(MUST\)

원서버는 여러 "subjectAltName" 속성 또는 와일드카드가 있는 이름이 있는 인증서를 제공할 수 있으며 그 중 하나는 URI의 기관에 유효합니다. 예를 들어 "subjectAltName"이 "\*.example.com"인 인증서는 "https://a.example.com/" 및 "https://로 시작하는 URI에 대한 요청에 대해 동일한 연결 사용을 허용할 수 있습니다. b.example.com/".

일부 배포에서 여러 오리진에 대한 연결을 재사용하면 요청이 잘못된 오리진 서버로 전달될 수 있습니다. 예를 들어 TLS 종료는 원본 서버를 선택하기 위해 TLS 서버 이름 표시\(SNI\) \[TLS-EXT\] 확장을 사용하는 미들박스에 의해 수행될 수 있습니다. 즉, 서버가 권한이 있는 경우에도 클라이언트가 요청 대상이 아닐 수 있는 서버에 기밀 정보를 보낼 수 있습니다.

클라이언트가 연결을 재사용하는 것을 원하지 않는 서버는 요청에 대한 응답으로 421\(잘못 지정된 요청\) 상태 코드를 전송하여 요청에 대해 권한이 없음을 나타낼 수 있습니다\(섹션 9.1.2 참조\).

HTTP/2를 통해 프록시를 사용하도록 구성된 클라이언트는 단일 연결을 통해 요청을 해당 프록시로 보냅니다. 즉, 프록시를 통해 전송된 모든 요청은 프록시에 대한 연결을 재사용합니다.

---
#### **9.1.2.  The 421 (Misdirected Request) Status Code**

421\(잘못 지정된 요청\) 상태 코드는 요청이 응답을 생성할 수 없는 서버로 전달되었음을 나타냅니다. 이것은 요청 URI에 포함된 체계와 권한의 조합에 대한 응답을 생성하도록 구성되지 않은 서버에서 보낼 수 있습니다.

서버로부터 421\(잘못 지정된 요청\) 응답을 수신하는 클라이언트는 요청 방법이 멱등적이든 아니든 다른 연결을 통해 요청을 재시도할 수 있습니다. 이는 연결이 재사용되거나\(섹션 9.1.1\) 대체 서비스가 선택된 경우에 가능합니다\[ALT-SVC\].\(MAY\)

이 상태 코드는 프록시에 의해 생성되어서는 안 됩니다\(MUST NOT\).\(MUST NOT\)

421 응답은 기본적으로 캐시할 수 있습니다.

---
### **9.2.  Use of TLS Features**

HTTP/2 구현은 TLS를 통한 HTTP/2에 대해 TLS 버전 1.2\[TLS12\] 이상을 사용해야 합니다\(MUST\). \[TLSBCP\]의 일반 TLS 사용 지침을 따라야 하며 HTTP/2에 특정한 몇 가지 추가 제한 사항이 있습니다.\(MUST, SHOULD\)

TLS 구현은 TLS에 대한 SNI\(Server Name Indication\) \[TLS-EXT\] 확장을 지원해야 합니다. HTTP/2 클라이언트는 TLS를 협상할 때 대상 도메인 이름을 나타내야 합니다.\(MUST, MUST\)

TLS 1.3 이상을 협상하는 HTTP/2 배포는 SNI 확장만 지원하고 사용하면 됩니다. TLS 1.2 배포에는 다음 섹션의 요구 사항이 적용됩니다. 구현은 준수하는 기본값을 제공하도록 권장되지만 궁극적으로 준수에 대한 책임은 배포에 있음을 인식합니다.

---
#### **9.2.1.  TLS 1.2 Features**

이 섹션에서는 HTTP/2와 함께 사용할 수 있는 TLS 1.2 기능 세트에 대한 제한 사항을 설명합니다. 배포 제한으로 인해 이러한 제한이 충족되지 않으면 TLS 협상에 실패하지 못할 수 있습니다. 엔드포인트는 INADEQUATE\_SECURITY 유형의 연결 오류\(섹션 5.4.1\)와 함께 이러한 TLS 요구 사항을 충족하지 않는 HTTP/2 연결을 즉시 종료할 수 있습니다\(MAY\).\(MAY\)

TLS 1.2를 통한 HTTP/2 배포는 압축을 비활성화해야 합니다. TLS 압축은 그렇지 않으면 공개되지 않는 정보의 노출로 이어질 수 있습니다\[RFC3749\]. HTTP/2는 컨텍스트를 더 잘 인식하고 성능, 보안 또는 기타 이유로 사용하기에 더 적합한 압축 기능을 제공하므로 일반 압축은 필요하지 않습니다.\(MUST\)

TLS 1.2를 통한 HTTP/2 배포는 재협상을 비활성화해야 합니다. 엔드포인트는 TLS 재협상을 PROTOCOL\_ERROR 유형의 연결 오류\(섹션 5.4.1\)로 처리해야 합니다. 비활성화\(MUST, MUST\)

재협상으로 인해 기본 암호 그룹이 암호화할 수 있는 메시지 수 제한으로 인해 수명이 긴 연결을 사용할 수 없게 될 수 있습니다.

엔드포인트는 재협상을 사용하여 핸드셰이크에서 제공되는 클라이언트 자격 증명에 대한 기밀 보호를 제공할 수 있지만 재협상은 반드시 연결 서문을 보내기 전에 이루어져야 합니다. 서버는 연결을 설정한 직후에 재협상 요청을 본 경우 클라이언트 인증서를 요청해야 합니다\(SHOULD\).\(MUST, SHOULD\)

이렇게 하면 특정 보호 리소스에 대한 요청에 대한 응답으로 재협상을 사용하는 것을 효과적으로 방지할 수 있습니다. 향후 사양은 이 사용 사례를 지원하는 방법을 제공할 수 있습니다. 또는 서버가 HTTP\_1\_1\_REQUIRED 유형의 오류\(섹션 5.4\)를 사용하여 클라이언트가 재협상을 지원하는 프로토콜을 사용하도록 요청할 수 있습니다.\(MUST\)

구현은 임시 유한 필드 DHE\(Diffie-Hellman\)\[TLS12\]를 사용하는 암호화 제품군에 대해 최소 2048비트의 임시 키 교환 크기를 지원하고 임시 타원 곡선 Diffie-Hellman\(ECDHE\)\[RFC4492\]을 사용하는 암호 제품군에 대해 224비트를 지원해야 합니다\(MUST\). 클라이언트는 최대 4096비트의 DHE 크기를 수락해야 합니다. 엔드포인트는 하한보다 작은 키 크기 협상을 INADEQUATE\_SECURITY 유형의 연결 오류\(섹션 5.4.1\)로 처리할 수 있습니다\(MAY\).\(MUST, MUST, MAY\)

---
#### **9.2.2.  TLS 1.2 Cipher Suites**

TLS 1.2를 통한 HTTP/2 배포는 암호 그룹 블랙리스트\(부록 A\)에 나열된 암호 그룹을 사용하면 안 됩니다\(SHOULD NOT\).\(SHOULD NOT\)

끝점은 블랙리스트의 암호 그룹 중 하나가 협상되는 경우 INADEQUATE\_SECURITY 유형의 연결 오류\(섹션 5.4.1\)를 생성하도록 선택할 수 있습니다\(MAY\). 블랙리스트에 있는 암호 그룹을 사용하도록 선택한 배포는 잠재적 피어 세트가 해당 암호 그룹을 수락하는 것으로 알려지지 않는 한 연결 오류를 트리거할 위험이 있습니다.\(MAY\)

구현은 블랙리스트에 없는 암호 그룹의 협상에 대한 반응으로 이 오류를 생성해서는 안 됩니다\(MUST NOT\). 결과적으로 클라이언트가 블랙리스트에 없는 암호군을 제공할 때 HTTP/2와 함께 해당 암호군을 사용할 준비를 해야 합니다.\(MUST NOT\)

블랙리스트에는 TLS 1.2에서 필수로 지정하는 암호화 제품군이 포함되어 있습니다. 즉, TLS 1.2 배포에는 교차하지 않는 허용된 암호화 제품군 집합이 있을 수 있습니다. 이 문제로 인해 TLS 핸드셰이크 실패가 발생하지 않도록 TLS 1.2를 사용하는 HTTP/2 배포는 P-256 타원 곡선\[FIPS186\]이 있는 TLS\_ECDHE\_RSA\_WITH\_AES\_128\_GCM\_SHA256\[TLS-ECDHE\]를 지원해야 합니다.\(MUST\)

클라이언트는 HTTP/2를 지원하지 않는 서버에 대한 연결을 허용하기 위해 블랙리스트에 있는 암호화 제품군 지원을 광고할 수 있습니다. 이를 통해 서버는 HTTP/2 블랙리스트에 있는 암호화 제품군을 사용하여 HTTP/1.1을 선택할 수 있습니다. 그러나 이로 인해 애플리케이션 프로토콜과 암호화 제품군이 독립적으로 선택된 경우 블랙리스트에 있는 암호화 제품군과 HTTP/2가 협상될 수 있습니다.

---
## **10.  Security Considerations**
---
### **10.1.  Server Authority**

HTTP/2는 서버가 주어진 응답을 제공할 때 권한이 있는지 여부를 결정하기 위해 권한에 대한 HTTP/1.1 정의에 의존합니다\(\[RFC7230\], 섹션 9.1 참조\). 이는 "http" URI 체계에 대한 로컬 이름 확인 및 "https" 체계에 대한 인증된 서버 ID에 의존합니다\(\[RFC2818\], 섹션 3 참조\).

---
### **10.2.  Cross-Protocol Attacks**

교차 프로토콜 공격에서 공격자는 클라이언트가 다른 프로토콜을 이해하는 서버를 향해 한 프로토콜에서 트랜잭션을 시작하도록 합니다. 공격자는 트랜잭션이 두 번째 프로토콜에서 유효한 트랜잭션으로 나타나도록 할 수 있습니다. 웹 컨텍스트의 기능과 결합하여 사설 네트워크에서 제대로 보호되지 않는 서버와 상호 작용하는 데 사용할 수 있습니다.

HTTP/2용 ALPN 식별자로 TLS 핸드셰이크를 완료하는 것은 교차 프로토콜 공격에 대한 충분한 보호로 간주될 수 있습니다. ALPN은 서버가 다른 TLS 기반 프로토콜에 대한 공격을 방지하는 HTTP/2로 진행할 의사가 있다는 긍정적인 표시를 제공합니다.

TLS의 암호화는 공격자가 일반 텍스트 프로토콜에 대한 교차 프로토콜 공격에 사용될 수 있는 데이터를 제어하기 어렵게 만듭니다.

HTTP/2의 일반 텍스트 버전은 교차 프로토콜 공격에 대해 최소한의 보호 기능을 제공합니다. 연결 서문\(섹션 3.5\)에는 HTTP/1.1 서버를 혼동하도록 설계된 문자열이 포함되어 있지만 다른 프로토콜에 대해서는 특별한 보호가 제공되지 않습니다. 클라이언트 연결 서문 외에 업그레이드 헤더 필드가 포함된 HTTP/1.1 요청의 일부를 기꺼이 무시하려는 서버는 교차 프로토콜 공격에 노출될 수 있습니다.

---
### **10.3.  Intermediary Encapsulation Attacks**

HTTP/2 헤더 필드 인코딩을 사용하면 HTTP/1.1에서 사용하는 인터넷 메시지 구문에서 유효한 필드 이름이 아닌 이름을 표현할 수 있습니다. 유효하지 않은 헤더 필드 이름을 포함하는 요청 또는 응답은 형식이 잘못된 것으로 처리해야 합니다\(섹션 8.1.2.6\). 따라서 중개자는 유효하지 않은 필드 이름을 포함하는 HTTP/2 요청 또는 응답을 HTTP/1.1 메시지로 변환할 수 없습니다.\(MUST\)

마찬가지로 HTTP/2는 유효하지 않은 헤더 필드 값을 허용합니다. 인코딩할 수 있는 대부분의 값은 헤더 필드 구문 분석을 변경하지 않지만 캐리지 리턴\(CR, ASCII 0xd\), 줄 바꿈\(LF, ASCII 0xa\) 및 0 문자\(NUL, ASCII 0x0\)는 공격자가 악용할 수 있습니다. 그대로 번역된 경우. 헤더 필드 값에 허용되지 않는 문자를 포함하는 모든 요청 또는 응답은 잘못된 형식으로 처리되어야 합니다\(섹션 8.1.2.6\). 유효한 문자는 \[RFC7230\]의 섹션 3.2에 있는 "field-content" ABNF 규칙에 의해 정의됩니다.\(MUST\)

---
### **10.4.  Cacheability of Pushed Responses**

푸시된 응답에는 클라이언트의 명시적 요청이 없습니다. 요청은 PUSH\_PROMISE 프레임에서 서버에 의해 제공됩니다.

Cache-Control 헤더 필드의 원본 서버에서 제공하는 지침에 따라 푸시되는 응답을 캐싱할 수 있습니다. 그러나 단일 서버가 둘 이상의 테넌트를 호스트하는 경우 문제가 발생할 수 있습니다. 예를 들어 서버는 여러 사용자에게 각각 URI 공간의 작은 부분을 제공할 수 있습니다.

여러 테넌트가 동일한 서버에서 공간을 공유하는 경우 해당 서버는 테넌트가 권한이 없는 리소스 표현을 푸시할 수 없도록 해야 합니다. 이를 적용하지 않으면 테넌트가 권한 있는 테넌트가 제공하는 실제 표현을 무시하고 캐시에서 제공되는 표현을 제공할 수 있습니다.\(MUST\)

원본 서버가 권한이 없는 푸시된 응답\(섹션 10.1 참조\)을 사용하거나 캐시하면 안 됩니다\(MUST NOT\).\(MUST NOT\)

---
### **10.5.  Denial-of-Service Considerations**

HTTP/2 연결은 HTTP/1.1 연결보다 작동하기 위해 더 많은 리소스를 요구할 수 있습니다. 헤더 압축 및 흐름 제어의 사용은 더 많은 양의 상태를 저장하기 위한 리소스 투입에 따라 달라집니다. 이러한 기능에 대한 설정은 이러한 기능에 대한 메모리 약정이 엄격하게 제한되도록 합니다.

PUSH\_PROMISE 프레임의 수는 같은 방식으로 제한되지 않습니다. 서버 푸시를 수락하는 클라이언트는 "예약\(원격\)" 상태에 있도록 허용하는 스트림 수를 제한해야 합니다\(SHOULD\). 과도한 수의 서버 푸시 스트림은 ENHANCE\_YOUR\_CALM 유형의 스트림 오류\(섹션 5.4.2\)로 처리될 수 있습니다.\(SHOULD\)

처리 용량은 상태 용량만큼 효과적으로 보호할 수 없습니다.

SETTINGS 프레임은 피어가 추가 처리 시간을 소비하도록 남용될 수 있습니다. 이는 의미 없이 SETTINGS 매개변수를 변경하거나 정의되지 않은 여러 매개변수를 설정하거나 동일한 프레임에서 동일한 설정을 여러 번 변경하여 수행할 수 있습니다. WINDOW\_UPDATE 또는 PRIORITY 프레임을 남용하여 불필요한 리소스 낭비를 유발할 수 있습니다.

많은 수의 작거나 비어 있는 프레임을 악용하여 피어가 프레임 헤더를 처리하는 데 시간을 소비하게 할 수 있습니다. 그러나 스트림의 끝에서 빈 DATA 또는 CONTINUATION 프레임을 보내는 것과 같은 일부 사용은 전적으로 합법적입니다.

헤더 압축은 또한 처리 리소스를 낭비할 수 있는 기회를 제공합니다. 잠재적 남용에 대한 자세한 내용은 \[COMPRESSION\]의 섹션 7을 참조하십시오.

SETTINGS 매개변수의 제한은 즉시 감소할 수 없으므로 엔드포인트가 새 제한을 초과할 수 있는 피어의 동작에 노출됩니다. 특히, 연결을 설정한 직후 서버에서 설정한 제한은 클라이언트에 알려지지 않으며 명백한 프로토콜 위반 없이 초과될 수 있습니다.

이러한 모든 기능\(예: 설정 변경, 작은 프레임, 헤더 압축\)은 합법적으로 사용됩니다. 이러한 기능은 불필요하게 사용하거나 과도하게 사용할 때만 부담이 됩니다.

이 동작을 모니터링하지 않는 엔드포인트는 서비스 거부 공격의 위험에 노출됩니다. 구현은 이러한 기능의 사용을 추적하고 사용 제한을 설정해야 합니다. 엔드포인트는 의심스러운 활동을 ENHANCE\_YOUR\_CALM 유형의 연결 오류\(섹션 5.4.1\)로 처리할 수 있습니다\(MAY\).\(SHOULD, MAY\)

---
#### **10.5.1.  Limits on Header Block Size**

큰 헤더 블록\(섹션 4.3\)으로 인해 구현이 많은 양의 상태를 커밋할 수 있습니다. 라우팅에 중요한 헤더 필드는 헤더 블록의 끝에 나타날 수 있으며, 이는 헤더 필드가 최종 목적지로 스트리밍되는 것을 방지합니다. 이 순서 및 캐시 정확성 보장과 같은 기타 이유는 다음을 의미합니다.

엔드포인트가 전체 헤더 블록을 버퍼링해야 할 수도 있습니다. 헤더 블록의 크기에 엄격한 제한이 없기 때문에 일부 엔드포인트는 헤더 필드에 사용 가능한 많은 양의 메모리를 커밋해야 할 수 있습니다.

엔드포인트는 SETTINGS\_MAX\_HEADER\_LIST\_SIZE를 사용하여 헤더 블록의 크기에 적용될 수 있는 제한을 동료에게 알릴 수 있습니다. 이 설정은 권고 사항일 뿐이므로 끝점은 이 제한을 초과하는 헤더 블록을 보내도록 선택할 수 있으며 요청 또는 응답이 잘못된 형식으로 처리되는 위험이 있습니다. 이 설정은 연결에 따라 다르므로 모든 요청 또는 응답에서 더 낮고 알 수 없는 제한이 있는 홉이 발생할 수 있습니다. 중개자는 다른 피어가 제시한 값을 전달하여 이 문제를 피하려고 시도할 수 있지만 그렇게 할 의무는 없습니다.\(MAY\)

처리할 수 있는 것보다 더 큰 헤더 블록을 수신한 서버는 HTTP 431\(요청 헤더 필드가 너무 큼\) 상태 코드\[RFC6585\]를 보낼 수 있습니다. 클라이언트는 처리할 수 없는 응답을 삭제할 수 있습니다. 헤더 블록은 연결이 닫히지 않는 한 일관된 연결 상태를 보장하기 위해 처리되어야 합니다.\(MUST\)

---
#### **10.5.2.  CONNECT Issues**

CONNECT 방법은 TCP 연결의 생성 및 유지 관리와 비교할 때 스트림 생성이 상대적으로 저렴하기 때문에 프록시에 불균형적인 부하를 생성하는 데 사용할 수 있습니다. 나가는 TCP 연결이 TIME\_WAIT 상태로 남아 있기 때문에 프록시는 CONNECT 요청을 전달하는 스트림을 닫는 것 이상으로 TCP 연결에 대한 일부 리소스를 유지할 수도 있습니다. 따라서 프록시는 CONNECT 요청에 사용되는 리소스를 제한하기 위해 SETTINGS\_MAX\_CONCURRENT\_STREAMS에만 의존할 수 없습니다.

---
### **10.6.  Use of Compression**

압축을 사용하면 공격자가 제어하는 ​​데이터와 동일한 컨텍스트에서 압축될 때 공격자가 비밀 데이터를 복구할 수 있습니다. HTTP/2는 헤더 필드의 압축을 가능하게 합니다\(섹션 4.3\). 다음 문제는 HTTP 압축 콘텐츠 코딩\(\[RFC7231\], 섹션 3.1.2.1\)의 사용에도 적용됩니다.

웹의 특성을 악용하는 압축에 대한 입증 가능한 공격이 있습니다\(예: \[BREACH\]\). 공격자는 다양한 일반 텍스트를 포함하는 여러 요청을 유도하고 각각의 결과 암호문 길이를 관찰하여 비밀에 대한 추측이 맞을 때 더 짧은 길이를 나타냅니다.

보안 채널에서 통신하는 구현은 각 데이터 소스에 대해 별도의 압축 사전이 사용되지 않는 한 기밀 데이터와 공격자가 제어하는 ​​데이터를 모두 포함하는 콘텐츠를 압축하면 안 됩니다\(MUST NOT\). 데이터 소스를 안정적으로 결정할 수 없는 경우 압축을 사용해서는 안 됩니다. TLS에서 제공하는 것과 같은 일반 스트림 압축은 HTTP/2와 함께 사용하면 안 됩니다\(9.2절 참조\).\(MUST NOT, MUST NOT, MUST NOT\)

헤더 필드의 압축에 관한 추가 고려 사항은 \[COMPRESSION\]에 설명되어 있습니다.

---
### **10.7.  Use of Padding**

HTTP/2 내의 패딩은 TLS\[TLS12\]에서 제공할 수 있는 것과 같은 범용 패딩을 대체하기 위한 것이 아닙니다. 중복 패딩은 비생산적일 수도 있습니다. 올바른 적용은 채워지는 데이터에 대한 특정 지식이 있는지 여부에 따라 달라질 수 있습니다.

압축에 의존하는 공격을 완화하려면 패딩을 사용하는 것보다 압축을 비활성화하거나 제한하는 것이 대책으로 더 나을 수 있습니다.

패딩은 프레임 콘텐츠의 정확한 크기를 숨기는 데 사용할 수 있으며 HTTP 내의 특정 공격, 예를 들어 공격자가 제어하는 ​​일반 텍스트와 비밀 데이터가 모두 포함된 압축 콘텐츠 공격\(예: \[BREACH\]\)을 완화하기 위해 제공됩니다.

패딩을 사용하면 즉시 명백해 보이는 것보다 보호 수준이 떨어질 수 있습니다. 기껏해야 패딩은 공격자가 관찰해야 하는 프레임 수를 늘려 공격자가 길이 정보를 유추하는 것을 더 어렵게 만듭니다. 잘못 구현된 패딩 체계는 쉽게 무효화될 수 있습니다. 특히 예측 가능한 분포를 가진 무작위 패딩은 거의 보호를 제공하지 않습니다. 마찬가지로 페이로드를 고정 크기로 패딩하면 페이로드 크기가 고정 크기 경계를 넘어갈 때 정보가 노출되며, 이는 공격자가 일반 텍스트를 제어할 수 있는 경우 가능할 수 있습니다.

중개자는 DATA 프레임에 대한 패딩을 유지해야 하지만\(SHOULD\) HEADERS 및 PUSH\_PROMISE 프레임에 대한 패딩을 삭제할 수 있습니다\(MAY\). 중개인이 프레임의 패딩 양을 변경하는 타당한 이유는 패딩이 제공하는 보호 기능을 개선하기 위해서입니다.\(SHOULD\)

---
### **10.8.  Privacy Considerations**

HTTP/2의 몇 가지 특성은 관찰자에게 시간이 지남에 따라 단일 클라이언트 또는 서버의 작업을 상호 연관시킬 수 있는 기회를 제공합니다. 여기에는 설정 값, 흐름 제어 창이 관리되는 방식, 스트림에 우선 순위가 할당되는 방식, 자극에 대한 반응 타이밍 및 설정에 의해 제어되는 모든 기능의 처리가 포함됩니다.

이것들이 동작에서 눈에 띄는 차이를 만드는 한, \[HTML5\]의 섹션 1.8에 정의된 대로 특정 클라이언트를 핑거프린팅하기 위한 기반으로 사용할 수 있습니다.

단일 TCP 연결을 사용하는 HTTP/2의 기본 설정은 사이트에서 사용자 활동의 상관 관계를 허용합니다. 다른 출처에 대한 연결을 재사용하면 해당 출처를 추적할 수 있습니다.

PING 및 SETTINGS 프레임은 즉각적인 응답을 요청하기 때문에 엔드포인트에서 피어에 대한 대기 시간을 측정하는 데 사용할 수 있습니다. 이는 특정 시나리오에서 개인 정보 보호에 영향을 미칠 수 있습니다.

---
## **11.  IANA Considerations**

HTTP/2를 식별하기 위한 문자열은 \[TLS-ALPN\]에 설정된 "ALPN\(Application-Layer Protocol Negotiation\) 프로토콜 ID" 레지스트리에 입력됩니다.

이 문서는 프레임 유형, 설정 및 오류 코드에 대한 레지스트리를 설정합니다. 이러한 새 레지스트리는 새 "HTTP/2\(Hypertext Transfer Protocol 버전 ​​2\) 매개변수" 섹션에 나타납니다.

이 문서는 HTTP에서 사용할 HTTP2-Settings 헤더 필드를 등록합니다. 또한 421\(잘못 지정된 요청\) 상태 코드를 등록합니다.

이 문서는 연결 서문\(Section 3.5\)과의 충돌을 피하기 위해 HTTP에서 사용할 "PRI" 메서드를 등록합니다.

---
### **11.1.  Registration of HTTP/2 Identification Strings**

이 문서는 \[TLS-ALPN\]에 설정된 "ALPN\(Application-Layer Protocol Negotiation\) 프로토콜 ID" 레지스트리에서 HTTP/2\(섹션 3.3 참조\) 식별을 위해 두 개의 등록을 생성합니다.

"h2" 문자열은 TLS를 통해 사용될 때 HTTP/2를 식별합니다.

프로토콜: TLS를 통한 HTTP/2

```text
   Identification Sequence:  0x68 0x32 ("h2")
```

사양: 이 문서

"h2c" 문자열은 일반 텍스트 TCP를 통해 사용될 때 HTTP/2를 식별합니다.

프로토콜: TCP를 통한 HTTP/2

```text
   Identification Sequence:  0x68 0x32 0x63 ("h2c")
```

사양: 이 문서

---
### **11.2.  Frame Type Registry**

이 문서는 HTTP/2 프레임 유형 코드에 대한 레지스트리를 설정합니다. "HTTP/2 프레임 유형" 레지스트리는 8비트 공간을 관리합니다. "HTTP/2 프레임 유형" 레지스트리는 0x00과 0xef 사이의 값에 대해 "IETF 검토" 또는 "IESG 승인" 정책\[RFC5226\] 중 하나에 따라 작동하며 0xf0과 0xff 사이의 값은 실험용으로 예약되어 있습니다.

이 레지스트리의 새 항목에는 다음 정보가 필요합니다.

프레임 유형: 프레임 유형의 이름 또는 레이블입니다.

코드: 프레임 유형에 할당된 8비트 코드입니다.

사양: 플래그 값에 따라 조건부로 존재하는 프레임의 모든 부분을 포함하여 프레임 유형이 사용하는 프레임 레이아웃, 의미 체계 및 플래그에 대한 설명을 포함하는 사양에 대한 참조입니다.

다음 표의 항목은 이 문서에 의해 등록됩니다.

```text
   +---------------+------+--------------+
   | Frame Type    | Code | Section      |
   +---------------+------+--------------+
   | DATA          | 0x0  | Section 6.1  |
   | HEADERS       | 0x1  | Section 6.2  |
   | PRIORITY      | 0x2  | Section 6.3  |
   | RST_STREAM    | 0x3  | Section 6.4  |
   | SETTINGS      | 0x4  | Section 6.5  |
   | PUSH_PROMISE  | 0x5  | Section 6.6  |
   | PING          | 0x6  | Section 6.7  |
   | GOAWAY        | 0x7  | Section 6.8  |
   | WINDOW_UPDATE | 0x8  | Section 6.9  |
   | CONTINUATION  | 0x9  | Section 6.10 |
   +---------------+------+--------------+
```

---
### **11.3.  Settings Registry**

이 문서는 HTTP/2 설정을 위한 레지스트리를 설정합니다. "HTTP/2 설정" 레지스트리는 16비트 공간을 관리합니다. "HTTP/2 설정" 레지스트리는 0x0000에서 0xefff 범위의 값에 대해 "전문가 검토" 정책\[RFC5226\]에 따라 작동하며 0xf000에서 0xffff 사이의 값은 실험용으로 예약되어 있습니다.

신규 등록 시 다음 정보를 제공하는 것이 좋습니다.

이름: 설정의 상징적인 이름입니다. 설정 이름 지정은 선택 사항입니다.

코드: 설정에 할당된 16비트 코드입니다.

초기 값: 설정의 초기 값입니다.

사양: 설정 사용을 설명하는 사양에 대한 선택적 참조입니다.

다음 표의 항목은 이 문서에 의해 등록됩니다.

```text
   +------------------------+------+---------------+---------------+
   | Name                   | Code | Initial Value | Specification |
   +------------------------+------+---------------+---------------+
   | HEADER_TABLE_SIZE      | 0x1  | 4096          | Section 6.5.2 |
   | ENABLE_PUSH            | 0x2  | 1             | Section 6.5.2 |
   | MAX_CONCURRENT_STREAMS | 0x3  | (infinite)    | Section 6.5.2 |
   | INITIAL_WINDOW_SIZE    | 0x4  | 65535         | Section 6.5.2 |
   | MAX_FRAME_SIZE         | 0x5  | 16384         | Section 6.5.2 |
   | MAX_HEADER_LIST_SIZE   | 0x6  | (infinite)    | Section 6.5.2 |
   +------------------------+------+---------------+---------------+
```

---
### **11.4.  Error Code Registry**

이 문서는 HTTP/2 오류 코드에 대한 레지스트리를 설정합니다. "HTTP/2 오류 코드" 레지스트리는 32비트 공간을 관리합니다. "HTTP/2 오류 코드" 레지스트리는 "전문가 검토" 정책 \[RFC5226\]에 따라 작동합니다.

오류 코드에 대한 설명을 포함하려면 오류 코드 등록이 필요합니다. 전문 검토자는 기존 오류 코드와 중복 가능성이 있는지 새 등록을 검토하는 것이 좋습니다. 기존 등록을 사용하는 것이 권장되지만 의무 사항은 아닙니다.

신규 등록 시 다음 정보를 제공하는 것이 좋습니다.

이름: 오류 코드의 이름입니다. 오류 코드 이름 지정은 선택 사항입니다.

코드: 32비트 오류 코드 값입니다.

설명: 오류 코드 의미 체계에 대한 간략한 설명입니다. 자세한 사양이 제공되지 않으면 더 길어집니다.

사양: 오류 코드를 정의하는 사양에 대한 선택적 참조입니다.

다음 표의 항목은 이 문서에 의해 등록됩니다.

```text
   +---------------------+------+----------------------+---------------+
   | Name                | Code | Description          | Specification |
   +---------------------+------+----------------------+---------------+
   | NO_ERROR            | 0x0  | Graceful shutdown    | Section 7     |
   | PROTOCOL_ERROR      | 0x1  | Protocol error       | Section 7     |
   |                     |      | detected             |               |
   | INTERNAL_ERROR      | 0x2  | Implementation fault | Section 7     |
   | FLOW_CONTROL_ERROR  | 0x3  | Flow-control limits  | Section 7     |
   |                     |      | exceeded             |               |
   | SETTINGS_TIMEOUT    | 0x4  | Settings not         | Section 7     |
   |                     |      | acknowledged         |               |
   | STREAM_CLOSED       | 0x5  | Frame received for   | Section 7     |
   |                     |      | closed stream        |               |
   | FRAME_SIZE_ERROR    | 0x6  | Frame size incorrect | Section 7     |
   | REFUSED_STREAM      | 0x7  | Stream not processed | Section 7     |
   | CANCEL              | 0x8  | Stream cancelled     | Section 7     |
   | COMPRESSION_ERROR   | 0x9  | Compression state    | Section 7     |
   |                     |      | not updated          |               |
   | CONNECT_ERROR       | 0xa  | TCP connection error | Section 7     |
   |                     |      | for CONNECT method   |               |
   | ENHANCE_YOUR_CALM   | 0xb  | Processing capacity  | Section 7     |
   |                     |      | exceeded             |               |
   | INADEQUATE_SECURITY | 0xc  | Negotiated TLS       | Section 7     |
   |                     |      | parameters not       |               |
   |                     |      | acceptable           |               |
   | HTTP_1_1_REQUIRED   | 0xd  | Use HTTP/1.1 for the | Section 7     |
   |                     |      | request              |               |
   +---------------------+------+----------------------+---------------+
```

---
### **11.5.  HTTP2-Settings Header Field Registration**

이 섹션은 "Permanent Message Header Field Names" 레지스트리\[BCP90\]에 HTTP2-Settings 헤더 필드를 등록합니다.

```text
   Header field name:  HTTP2-Settings

   Applicable protocol:  http

   Status:  standard

   Author/Change controller:  IETF
```

사양 문서: 이 문서의 섹션 3.2.1

관련 정보: 이 헤더 필드는 업그레이드 기반 협상을 위해 HTTP/2 클라이언트에서만 사용됩니다.

---
### **11.6.  PRI Method Registration**

이 섹션에서는 "HTTP 메서드 레지스트리"\(\[RFC7231\], 섹션 8.1\)에 "PRI" 메서드를 등록합니다.

```text
   Method Name:  PRI

   Safe:  Yes

   Idempotent:  Yes
```

사양 문서: 이 문서의 섹션 3.5

관련 정보: 이 방법은 실제 클라이언트에서 사용되지 않습니다. 이 방법은 HTTP/1.1 서버 또는 중개자가 HTTP/2 연결 서문을 구문 분석하려고 시도할 때 사용되는 것으로 나타납니다.

---
### **11.7.  The 421 (Misdirected Request) HTTP Status Code**

이 문서는 "HTTP 상태 코드" 레지스트리\(\[RFC7231\], 섹션 8.2\)에 421\(잘못 지정된 요청\) HTTP 상태 코드를 등록합니다.

```text
   Status Code:  421

   Short Description:  Misdirected Request
```

사양: 이 문서의 섹션 9.1.2

---
### **11.8.  The h2c Upgrade Token**

이 문서는 "HTTP 업그레이드 토큰" 레지스트리\(\[RFC7230\], 섹션 8.6\)에 "h2c" 업그레이드 토큰을 등록합니다.

```text
   Value:  h2c

   Description:  Hypertext Transfer Protocol version 2 (HTTP/2)

   Expected Version Tokens:  None
```

참조: 이 문서의 섹션 3.2

---
## **12.  References**
---
### **12.1.  Normative References**

```text
   [COMPRESSION] Peon, R. and H. Ruellan, "HPACK: Header Compression for
                 HTTP/2", RFC 7541, DOI 10.17487/RFC7541, May 2015,
                 <http://www.rfc-editor.org/info/rfc7541>.

   [COOKIE]      Barth, A., "HTTP State Management Mechanism", RFC 6265,
                 DOI 10.17487/RFC6265, April 2011,
                 <http://www.rfc-editor.org/info/rfc6265>.

   [FIPS186]     NIST, "Digital Signature Standard (DSS)", FIPS PUB
                 186-4, July 2013,
                 <http://dx.doi.org/10.6028/NIST.FIPS.186-4>.

   [RFC2119]     Bradner, S., "Key words for use in RFCs to Indicate
                 Requirement Levels", BCP 14, RFC 2119, DOI 10.17487/
                 RFC2119, March 1997,
                 <http://www.rfc-editor.org/info/rfc2119>.

   [RFC2818]     Rescorla, E., "HTTP Over TLS", RFC 2818, DOI 10.17487/
                 RFC2818, May 2000,
                 <http://www.rfc-editor.org/info/rfc2818>.

   [RFC3986]     Berners-Lee, T., Fielding, R., and L. Masinter,
                 "Uniform Resource Identifier (URI): Generic Syntax",
                 STD 66, RFC 3986, DOI 10.17487/RFC3986, January 2005,
                 <http://www.rfc-editor.org/info/rfc3986>.

   [RFC4648]     Josefsson, S., "The Base16, Base32, and Base64 Data
                 Encodings", RFC 4648, DOI 10.17487/RFC4648, October
                 2006, <http://www.rfc-editor.org/info/rfc4648>.

   [RFC5226]     Narten, T. and H. Alvestrand, "Guidelines for Writing
                 an IANA Considerations Section in RFCs", BCP 26,
                 RFC 5226, DOI 10.17487/RFC5226, May 2008,
                 <http://www.rfc-editor.org/info/rfc5226>.

   [RFC5234]     Crocker, D., Ed. and P. Overell, "Augmented BNF for
                 Syntax Specifications: ABNF", STD 68, RFC 5234,
                 DOI 10.17487/ RFC5234, January 2008,
                 <http://www.rfc-editor.org/info/rfc5234>.

   [RFC7230]     Fielding, R., Ed. and J. Reschke, Ed., "Hypertext
                 Transfer Protocol (HTTP/1.1): Message Syntax and
                 Routing", RFC 7230, DOI 10.17487/RFC7230, June 2014,
                 <http://www.rfc-editor.org/info/rfc7230>.

   [RFC7231]     Fielding, R., Ed. and J. Reschke, Ed., "Hypertext
                 Transfer Protocol (HTTP/1.1): Semantics and Content",
                 RFC 7231, DOI 10.17487/RFC7231, June 2014,
                 <http://www.rfc-editor.org/info/rfc7231>.

   [RFC7232]     Fielding, R., Ed. and J. Reschke, Ed., "Hypertext
                 Transfer Protocol (HTTP/1.1): Conditional Requests",
                 RFC 7232, DOI 10.17487/RFC7232, June 2014,
                 <http://www.rfc-editor.org/info/rfc7232>.

   [RFC7233]     Fielding, R., Ed., Lafon, Y., Ed., and J. Reschke, Ed.,
                 "Hypertext Transfer Protocol (HTTP/1.1): Range
                 Requests", RFC 7233, DOI 10.17487/RFC7233, June 2014,
                 <http://www.rfc-editor.org/info/rfc7233>.

   [RFC7234]     Fielding, R., Ed., Nottingham, M., Ed., and J. Reschke,
                 Ed., "Hypertext Transfer Protocol (HTTP/1.1): Caching",
                 RFC 7234, DOI 10.17487/RFC7234, June 2014,
                 <http://www.rfc-editor.org/info/rfc7234>.

   [RFC7235]     Fielding, R., Ed. and J. Reschke, Ed., "Hypertext
                 Transfer Protocol (HTTP/1.1): Authentication",
                 RFC 7235, DOI 10.17487/RFC7235, June 2014,
                 <http://www.rfc-editor.org/info/rfc7235>.

   [TCP]         Postel, J., "Transmission Control Protocol", STD 7, RFC
                 793, DOI 10.17487/RFC0793, September 1981,
                 <http://www.rfc-editor.org/info/rfc793>.

   [TLS-ALPN]    Friedl, S., Popov, A., Langley, A., and E. Stephan,
                 "Transport Layer Security (TLS) Application-Layer
                 Protocol Negotiation Extension", RFC 7301,
                 DOI 10.17487/RFC7301, July 2014,
                 <http://www.rfc-editor.org/info/rfc7301>.

   [TLS-ECDHE]   Rescorla, E., "TLS Elliptic Curve Cipher Suites with
                 SHA-256/384 and AES Galois Counter Mode (GCM)",
                 RFC 5289, DOI 10.17487/RFC5289, August 2008,
                 <http://www.rfc-editor.org/info/rfc5289>.

   [TLS-EXT]     Eastlake 3rd, D., "Transport Layer Security (TLS)
                 Extensions: Extension Definitions", RFC 6066,
                 DOI 10.17487/RFC6066, January 2011,
                 <http://www.rfc-editor.org/info/rfc6066>.

   [TLS12]       Dierks, T. and E. Rescorla, "The Transport Layer
                 Security (TLS) Protocol Version 1.2", RFC 5246,
                 DOI 10.17487/ RFC5246, August 2008,
                 <http://www.rfc-editor.org/info/rfc5246>.
```

---
### **12.2.  Informative References**

\[ALT-SVC\] Nottingham, M., McManus, P. 및 J. Reschke, "HTTP 대체 서비스", 작업 진행 중, draft-ietf-httpbis-alt-svc-06, 2015년 2월.

```text
   [BCP90]       Klyne, G., Nottingham, M., and J. Mogul, "Registration
                 Procedures for Message Header Fields", BCP 90,
                 RFC 3864, September 2004,
                 <http://www.rfc-editor.org/info/bcp90>.

   [BREACH]      Gluck, Y., Harris, N., and A. Prado, "BREACH: Reviving
                 the CRIME Attack", July 2013,
                 <http://breachattack.com/resources/
                 BREACH%20-%20SSL,%20gone%20in%2030%20seconds.pdf>.

   [HTML5]       Hickson, I., Berjon, R., Faulkner, S., Leithead, T.,
                 Doyle Navara, E., O'Connor, E., and S. Pfeiffer,
                 "HTML5", W3C Recommendation REC-html5-20141028, October
                 2014, <http://www.w3.org/TR/2014/REC-html5-20141028/>.

   [RFC3749]     Hollenbeck, S., "Transport Layer Security Protocol
                 Compression Methods", RFC 3749, DOI 10.17487/RFC3749,
                 May 2004, <http://www.rfc-editor.org/info/rfc3749>.

   [RFC4492]     Blake-Wilson, S., Bolyard, N., Gupta, V., Hawk, C., and
                 B.  Moeller, "Elliptic Curve Cryptography (ECC) Cipher
                 Suites for Transport Layer Security (TLS)", RFC 4492,
                 DOI 10.17487/RFC4492, May 2006,
                 <http://www.rfc-editor.org/info/rfc4492>.

   [RFC6585]     Nottingham, M. and R. Fielding, "Additional HTTP Status
                 Codes", RFC 6585, DOI 10.17487/RFC6585, April 2012,
                 <http://www.rfc-editor.org/info/rfc6585>.

   [RFC7323]     Borman, D., Braden, B., Jacobson, V., and R.
                 Scheffenegger, Ed., "TCP Extensions for High
                 Performance", RFC 7323, DOI 10.17487/RFC7323, September
                 2014, <http://www.rfc-editor.org/info/rfc7323>.

   [TALKING]     Huang, L., Chen, E., Barth, A., Rescorla, E., and C.
                 Jackson, "Talking to Yourself for Fun and Profit",
                 2011, <http://w2spconf.com/2011/papers/websocket.pdf>.

   [TLSBCP]      Sheffer, Y., Holz, R., and P. Saint-Andre,
                 "Recommendations for Secure Use of Transport Layer
                 Security (TLS) and Datagram Transport Layer Security
                 (DTLS)", BCP 195, RFC 7525, DOI 10.17487/RFC7525, May
                 2015, <http://www.rfc-editor.org/info/rfc7525>.
```

---
# **Appendix A.  TLS 1.2 Cipher Suite Black List**

HTTP/2 구현은 INADEQUATE\_SECURITY 유형의 연결 오류\(섹션 5.4.1\)로 TLS 1.2를 사용한 다음 암호 제품군의 협상을 처리할 수 있습니다\(MAY\).\(MAY\)

```text
   o  TLS_NULL_WITH_NULL_NULL

   o  TLS_RSA_WITH_NULL_MD5

   o  TLS_RSA_WITH_NULL_SHA

   o  TLS_RSA_EXPORT_WITH_RC4_40_MD5

   o  TLS_RSA_WITH_RC4_128_MD5

   o  TLS_RSA_WITH_RC4_128_SHA

   o  TLS_RSA_EXPORT_WITH_RC2_CBC_40_MD5

   o  TLS_RSA_WITH_IDEA_CBC_SHA

   o  TLS_RSA_EXPORT_WITH_DES40_CBC_SHA

   o  TLS_RSA_WITH_DES_CBC_SHA

   o  TLS_RSA_WITH_3DES_EDE_CBC_SHA

   o  TLS_DH_DSS_EXPORT_WITH_DES40_CBC_SHA

   o  TLS_DH_DSS_WITH_DES_CBC_SHA

   o  TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA

   o  TLS_DH_RSA_EXPORT_WITH_DES40_CBC_SHA

   o  TLS_DH_RSA_WITH_DES_CBC_SHA

   o  TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA

   o  TLS_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA

   o  TLS_DHE_DSS_WITH_DES_CBC_SHA

   o  TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA

   o  TLS_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA

   o  TLS_DHE_RSA_WITH_DES_CBC_SHA

   o  TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA

   o  TLS_DH_anon_EXPORT_WITH_RC4_40_MD5

   o  TLS_DH_anon_WITH_RC4_128_MD5

   o  TLS_DH_anon_EXPORT_WITH_DES40_CBC_SHA

   o  TLS_DH_anon_WITH_DES_CBC_SHA

   o  TLS_DH_anon_WITH_3DES_EDE_CBC_SHA

   o  TLS_KRB5_WITH_DES_CBC_SHA

   o  TLS_KRB5_WITH_3DES_EDE_CBC_SHA

   o  TLS_KRB5_WITH_RC4_128_SHA

   o  TLS_KRB5_WITH_IDEA_CBC_SHA

   o  TLS_KRB5_WITH_DES_CBC_MD5

   o  TLS_KRB5_WITH_3DES_EDE_CBC_MD5

   o  TLS_KRB5_WITH_RC4_128_MD5

   o  TLS_KRB5_WITH_IDEA_CBC_MD5

   o  TLS_KRB5_EXPORT_WITH_DES_CBC_40_SHA

   o  TLS_KRB5_EXPORT_WITH_RC2_CBC_40_SHA

   o  TLS_KRB5_EXPORT_WITH_RC4_40_SHA

   o  TLS_KRB5_EXPORT_WITH_DES_CBC_40_MD5

   o  TLS_KRB5_EXPORT_WITH_RC2_CBC_40_MD5

   o  TLS_KRB5_EXPORT_WITH_RC4_40_MD5

   o  TLS_PSK_WITH_NULL_SHA

   o  TLS_DHE_PSK_WITH_NULL_SHA

   o  TLS_RSA_PSK_WITH_NULL_SHA

   o  TLS_RSA_WITH_AES_128_CBC_SHA

   o  TLS_DH_DSS_WITH_AES_128_CBC_SHA

   o  TLS_DH_RSA_WITH_AES_128_CBC_SHA

   o  TLS_DHE_DSS_WITH_AES_128_CBC_SHA

   o  TLS_DHE_RSA_WITH_AES_128_CBC_SHA

   o  TLS_DH_anon_WITH_AES_128_CBC_SHA

   o  TLS_RSA_WITH_AES_256_CBC_SHA

   o  TLS_DH_DSS_WITH_AES_256_CBC_SHA

   o  TLS_DH_RSA_WITH_AES_256_CBC_SHA

   o  TLS_DHE_DSS_WITH_AES_256_CBC_SHA

   o  TLS_DHE_RSA_WITH_AES_256_CBC_SHA

   o  TLS_DH_anon_WITH_AES_256_CBC_SHA

   o  TLS_RSA_WITH_NULL_SHA256

   o  TLS_RSA_WITH_AES_128_CBC_SHA256

   o  TLS_RSA_WITH_AES_256_CBC_SHA256

   o  TLS_DH_DSS_WITH_AES_128_CBC_SHA256

   o  TLS_DH_RSA_WITH_AES_128_CBC_SHA256

   o  TLS_DHE_DSS_WITH_AES_128_CBC_SHA256

   o  TLS_RSA_WITH_CAMELLIA_128_CBC_SHA

   o  TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA

   o  TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA

   o  TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA

   o  TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA

   o  TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA

   o  TLS_DHE_RSA_WITH_AES_128_CBC_SHA256

   o  TLS_DH_DSS_WITH_AES_256_CBC_SHA256

   o  TLS_DH_RSA_WITH_AES_256_CBC_SHA256

   o  TLS_DHE_DSS_WITH_AES_256_CBC_SHA256

   o  TLS_DHE_RSA_WITH_AES_256_CBC_SHA256

   o  TLS_DH_anon_WITH_AES_128_CBC_SHA256

   o  TLS_DH_anon_WITH_AES_256_CBC_SHA256

   o  TLS_RSA_WITH_CAMELLIA_256_CBC_SHA

   o  TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA

   o  TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA

   o  TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA

   o  TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA

   o  TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA

   o  TLS_PSK_WITH_RC4_128_SHA

   o  TLS_PSK_WITH_3DES_EDE_CBC_SHA

   o  TLS_PSK_WITH_AES_128_CBC_SHA

   o  TLS_PSK_WITH_AES_256_CBC_SHA

   o  TLS_DHE_PSK_WITH_RC4_128_SHA

   o  TLS_DHE_PSK_WITH_3DES_EDE_CBC_SHA

   o  TLS_DHE_PSK_WITH_AES_128_CBC_SHA

   o  TLS_DHE_PSK_WITH_AES_256_CBC_SHA

   o  TLS_RSA_PSK_WITH_RC4_128_SHA

   o  TLS_RSA_PSK_WITH_3DES_EDE_CBC_SHA

   o  TLS_RSA_PSK_WITH_AES_128_CBC_SHA

   o  TLS_RSA_PSK_WITH_AES_256_CBC_SHA

   o  TLS_RSA_WITH_SEED_CBC_SHA

   o  TLS_DH_DSS_WITH_SEED_CBC_SHA

   o  TLS_DH_RSA_WITH_SEED_CBC_SHA

   o  TLS_DHE_DSS_WITH_SEED_CBC_SHA

   o  TLS_DHE_RSA_WITH_SEED_CBC_SHA

   o  TLS_DH_anon_WITH_SEED_CBC_SHA

   o  TLS_RSA_WITH_AES_128_GCM_SHA256

   o  TLS_RSA_WITH_AES_256_GCM_SHA384

   o  TLS_DH_RSA_WITH_AES_128_GCM_SHA256

   o  TLS_DH_RSA_WITH_AES_256_GCM_SHA384

   o  TLS_DH_DSS_WITH_AES_128_GCM_SHA256

   o  TLS_DH_DSS_WITH_AES_256_GCM_SHA384

   o  TLS_DH_anon_WITH_AES_128_GCM_SHA256

   o  TLS_DH_anon_WITH_AES_256_GCM_SHA384

   o  TLS_PSK_WITH_AES_128_GCM_SHA256

   o  TLS_PSK_WITH_AES_256_GCM_SHA384

   o  TLS_RSA_PSK_WITH_AES_128_GCM_SHA256

   o  TLS_RSA_PSK_WITH_AES_256_GCM_SHA384

   o  TLS_PSK_WITH_AES_128_CBC_SHA256

   o  TLS_PSK_WITH_AES_256_CBC_SHA384

   o  TLS_PSK_WITH_NULL_SHA256

   o  TLS_PSK_WITH_NULL_SHA384

   o  TLS_DHE_PSK_WITH_AES_128_CBC_SHA256

   o  TLS_DHE_PSK_WITH_AES_256_CBC_SHA384

   o  TLS_DHE_PSK_WITH_NULL_SHA256

   o  TLS_DHE_PSK_WITH_NULL_SHA384

   o  TLS_RSA_PSK_WITH_AES_128_CBC_SHA256

   o  TLS_RSA_PSK_WITH_AES_256_CBC_SHA384

   o  TLS_RSA_PSK_WITH_NULL_SHA256

   o  TLS_RSA_PSK_WITH_NULL_SHA384

   o  TLS_RSA_WITH_CAMELLIA_128_CBC_SHA256

   o  TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA256

   o  TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA256

   o  TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA256

   o  TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA256

   o  TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA256

   o  TLS_RSA_WITH_CAMELLIA_256_CBC_SHA256

   o  TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA256

   o  TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA256

   o  TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA256

   o  TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA256

   o  TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA256

   o  TLS_EMPTY_RENEGOTIATION_INFO_SCSV

   o  TLS_ECDH_ECDSA_WITH_NULL_SHA

   o  TLS_ECDH_ECDSA_WITH_RC4_128_SHA

   o  TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA

   o  TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA

   o  TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA

   o  TLS_ECDHE_ECDSA_WITH_NULL_SHA

   o  TLS_ECDHE_ECDSA_WITH_RC4_128_SHA

   o  TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA

   o  TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA

   o  TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA

   o  TLS_ECDH_RSA_WITH_NULL_SHA

   o  TLS_ECDH_RSA_WITH_RC4_128_SHA

   o  TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA

   o  TLS_ECDH_RSA_WITH_AES_128_CBC_SHA

   o  TLS_ECDH_RSA_WITH_AES_256_CBC_SHA

   o  TLS_ECDHE_RSA_WITH_NULL_SHA

   o  TLS_ECDHE_RSA_WITH_RC4_128_SHA

   o  TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA

   o  TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA

   o  TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA

   o  TLS_ECDH_anon_WITH_NULL_SHA

   o  TLS_ECDH_anon_WITH_RC4_128_SHA

   o  TLS_ECDH_anon_WITH_3DES_EDE_CBC_SHA

   o  TLS_ECDH_anon_WITH_AES_128_CBC_SHA

   o  TLS_ECDH_anon_WITH_AES_256_CBC_SHA

   o  TLS_SRP_SHA_WITH_3DES_EDE_CBC_SHA

   o  TLS_SRP_SHA_RSA_WITH_3DES_EDE_CBC_SHA

   o  TLS_SRP_SHA_DSS_WITH_3DES_EDE_CBC_SHA

   o  TLS_SRP_SHA_WITH_AES_128_CBC_SHA

   o  TLS_SRP_SHA_RSA_WITH_AES_128_CBC_SHA

   o  TLS_SRP_SHA_DSS_WITH_AES_128_CBC_SHA

   o  TLS_SRP_SHA_WITH_AES_256_CBC_SHA

   o  TLS_SRP_SHA_RSA_WITH_AES_256_CBC_SHA

   o  TLS_SRP_SHA_DSS_WITH_AES_256_CBC_SHA

   o  TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256

   o  TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384

   o  TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256

   o  TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384

   o  TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256

   o  TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384

   o  TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256

   o  TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384

   o  TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256

   o  TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384

   o  TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256

   o  TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384

   o  TLS_ECDHE_PSK_WITH_RC4_128_SHA

   o  TLS_ECDHE_PSK_WITH_3DES_EDE_CBC_SHA

   o  TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA

   o  TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA

   o  TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA256

   o  TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA384

   o  TLS_ECDHE_PSK_WITH_NULL_SHA

   o  TLS_ECDHE_PSK_WITH_NULL_SHA256

   o  TLS_ECDHE_PSK_WITH_NULL_SHA384

   o  TLS_RSA_WITH_ARIA_128_CBC_SHA256

   o  TLS_RSA_WITH_ARIA_256_CBC_SHA384

   o  TLS_DH_DSS_WITH_ARIA_128_CBC_SHA256

   o  TLS_DH_DSS_WITH_ARIA_256_CBC_SHA384

   o  TLS_DH_RSA_WITH_ARIA_128_CBC_SHA256

   o  TLS_DH_RSA_WITH_ARIA_256_CBC_SHA384

   o  TLS_DHE_DSS_WITH_ARIA_128_CBC_SHA256

   o  TLS_DHE_DSS_WITH_ARIA_256_CBC_SHA384

   o  TLS_DHE_RSA_WITH_ARIA_128_CBC_SHA256

   o  TLS_DHE_RSA_WITH_ARIA_256_CBC_SHA384

   o  TLS_DH_anon_WITH_ARIA_128_CBC_SHA256

   o  TLS_DH_anon_WITH_ARIA_256_CBC_SHA384

   o  TLS_ECDHE_ECDSA_WITH_ARIA_128_CBC_SHA256

   o  TLS_ECDHE_ECDSA_WITH_ARIA_256_CBC_SHA384

   o  TLS_ECDH_ECDSA_WITH_ARIA_128_CBC_SHA256

   o  TLS_ECDH_ECDSA_WITH_ARIA_256_CBC_SHA384

   o  TLS_ECDHE_RSA_WITH_ARIA_128_CBC_SHA256

   o  TLS_ECDHE_RSA_WITH_ARIA_256_CBC_SHA384

   o  TLS_ECDH_RSA_WITH_ARIA_128_CBC_SHA256

   o  TLS_ECDH_RSA_WITH_ARIA_256_CBC_SHA384

   o  TLS_RSA_WITH_ARIA_128_GCM_SHA256

   o  TLS_RSA_WITH_ARIA_256_GCM_SHA384

   o  TLS_DH_RSA_WITH_ARIA_128_GCM_SHA256

   o  TLS_DH_RSA_WITH_ARIA_256_GCM_SHA384

   o  TLS_DH_DSS_WITH_ARIA_128_GCM_SHA256

   o  TLS_DH_DSS_WITH_ARIA_256_GCM_SHA384

   o  TLS_DH_anon_WITH_ARIA_128_GCM_SHA256

   o  TLS_DH_anon_WITH_ARIA_256_GCM_SHA384

   o  TLS_ECDH_ECDSA_WITH_ARIA_128_GCM_SHA256

   o  TLS_ECDH_ECDSA_WITH_ARIA_256_GCM_SHA384

   o  TLS_ECDH_RSA_WITH_ARIA_128_GCM_SHA256

   o  TLS_ECDH_RSA_WITH_ARIA_256_GCM_SHA384

   o  TLS_PSK_WITH_ARIA_128_CBC_SHA256

   o  TLS_PSK_WITH_ARIA_256_CBC_SHA384

   o  TLS_DHE_PSK_WITH_ARIA_128_CBC_SHA256

   o  TLS_DHE_PSK_WITH_ARIA_256_CBC_SHA384

   o  TLS_RSA_PSK_WITH_ARIA_128_CBC_SHA256

   o  TLS_RSA_PSK_WITH_ARIA_256_CBC_SHA384

   o  TLS_PSK_WITH_ARIA_128_GCM_SHA256

   o  TLS_PSK_WITH_ARIA_256_GCM_SHA384

   o  TLS_RSA_PSK_WITH_ARIA_128_GCM_SHA256

   o  TLS_RSA_PSK_WITH_ARIA_256_GCM_SHA384

   o  TLS_ECDHE_PSK_WITH_ARIA_128_CBC_SHA256

   o  TLS_ECDHE_PSK_WITH_ARIA_256_CBC_SHA384

   o  TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_CBC_SHA256

   o  TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_CBC_SHA384

   o  TLS_ECDH_ECDSA_WITH_CAMELLIA_128_CBC_SHA256

   o  TLS_ECDH_ECDSA_WITH_CAMELLIA_256_CBC_SHA384

   o  TLS_ECDHE_RSA_WITH_CAMELLIA_128_CBC_SHA256

   o  TLS_ECDHE_RSA_WITH_CAMELLIA_256_CBC_SHA384

   o  TLS_ECDH_RSA_WITH_CAMELLIA_128_CBC_SHA256

   o  TLS_ECDH_RSA_WITH_CAMELLIA_256_CBC_SHA384

   o  TLS_RSA_WITH_CAMELLIA_128_GCM_SHA256

   o  TLS_RSA_WITH_CAMELLIA_256_GCM_SHA384

   o  TLS_DH_RSA_WITH_CAMELLIA_128_GCM_SHA256

   o  TLS_DH_RSA_WITH_CAMELLIA_256_GCM_SHA384

   o  TLS_DH_DSS_WITH_CAMELLIA_128_GCM_SHA256

   o  TLS_DH_DSS_WITH_CAMELLIA_256_GCM_SHA384

   o  TLS_DH_anon_WITH_CAMELLIA_128_GCM_SHA256

   o  TLS_DH_anon_WITH_CAMELLIA_256_GCM_SHA384

   o  TLS_ECDH_ECDSA_WITH_CAMELLIA_128_GCM_SHA256

   o  TLS_ECDH_ECDSA_WITH_CAMELLIA_256_GCM_SHA384

   o  TLS_ECDH_RSA_WITH_CAMELLIA_128_GCM_SHA256

   o  TLS_ECDH_RSA_WITH_CAMELLIA_256_GCM_SHA384

   o  TLS_PSK_WITH_CAMELLIA_128_GCM_SHA256

   o  TLS_PSK_WITH_CAMELLIA_256_GCM_SHA384

   o  TLS_RSA_PSK_WITH_CAMELLIA_128_GCM_SHA256

   o  TLS_RSA_PSK_WITH_CAMELLIA_256_GCM_SHA384

   o  TLS_PSK_WITH_CAMELLIA_128_CBC_SHA256

   o  TLS_PSK_WITH_CAMELLIA_256_CBC_SHA384

   o  TLS_DHE_PSK_WITH_CAMELLIA_128_CBC_SHA256

   o  TLS_DHE_PSK_WITH_CAMELLIA_256_CBC_SHA384

   o  TLS_RSA_PSK_WITH_CAMELLIA_128_CBC_SHA256

   o  TLS_RSA_PSK_WITH_CAMELLIA_256_CBC_SHA384

   o  TLS_ECDHE_PSK_WITH_CAMELLIA_128_CBC_SHA256

   o  TLS_ECDHE_PSK_WITH_CAMELLIA_256_CBC_SHA384

   o  TLS_RSA_WITH_AES_128_CCM

   o  TLS_RSA_WITH_AES_256_CCM

   o  TLS_RSA_WITH_AES_128_CCM_8

   o  TLS_RSA_WITH_AES_256_CCM_8

   o  TLS_PSK_WITH_AES_128_CCM

   o  TLS_PSK_WITH_AES_256_CCM

   o  TLS_PSK_WITH_AES_128_CCM_8

   o  TLS_PSK_WITH_AES_256_CCM_8
```

- 참고: 이 목록은 작성 시점에 등록된 TLS 암호화 제품군 집합에서 수집되었습니다. 이 목록에는 임시 키 교환을 제공하지 않는 암호 제품군과 TLS null, 스트림 또는 블록 암호 유형\(\[TLS12\]의 섹션 6.2.3에 정의됨\)을 기반으로 하는 암호 제품군이 포함됩니다. 이러한 속성을 가진 추가 암호 제품군을 정의할 수 있습니다. 이는 명시적으로 금지되지 않습니다.

---
# **Acknowledgements**

이 문서에는 다음 개인의 실질적인 의견이 포함되어 있습니다.

o Adam Langley, Wan-Teh Chang, Jim Morrison, Mark Nottingham, Alyssa Wilk, Costin Manolache, William Chan, Vitaliy Lvin, Joe Chan, Adam Barth, Ryan Hamilton, Gavin Peters, Kent Alstad, Kevin Lindsay, Paul Amer, Fan Yang , Jonathan Leighton\(SPDY 기여자\).

o Gabriel Montenegro 및 Willy Tarreau\(업그레이드 메커니즘\).

o William Chan, Salvatore Loreto, Osama Mazahir, Gabriel Montenegro, Jitu Padhye, Roberto Peon 및 Rob Trace\(흐름 제어\).

```text
   o  Mike Bishop (Extensibility).
```

o Mark Nottingham, Julian Reschke, James Snell, Jeff Pinner, Mike Bishop 및 Herve Ruellan\(상당한 편집 기여\).

o Kari Hurtta, Tatsuhiro Tsujikawa, Greg Wilkins, Poul-Henning Kamp, Jonathan Thackray.

o Alexey Melnikov는 2013년에 이 문서의 편집자였습니다.

Martin의 기여 중 상당 부분은 그가 근무하는 동안 Microsoft의 지원을 받았습니다.

일본 HTTP/2 커뮤니티는 수많은 기술 및 편집 기여뿐만 아니라 수많은 구현을 포함하여 귀중한 기여를 제공했습니다.

---
# **Authors' Addresses**

```text
   Mike Belshe
   BitGo

   EMail: mike@belshe.com

   Roberto Peon
   Google, Inc

   EMail: fenix@google.com

   Martin Thomson (editor)
   Mozilla
   331 E Evelyn Street
   Mountain View, CA  94041
   United States

   EMail: martin.thomson@gmail.com
```
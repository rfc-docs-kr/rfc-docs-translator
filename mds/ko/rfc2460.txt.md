

```text
Network Working Group                                         S. Deering
Request for Comments: 2460                                         Cisco
Obsoletes: 1883                                                R. Hinden
Category: Standards Track                                          Nokia
                                                           December 1998

                  Internet Protocol, Version 6 (IPv6)
                             Specification
```

---
# **Status of this Memo**

이 문서는 인터넷 커뮤니티를 위한 인터넷 표준 추적 프로토콜을 지정하고 개선을 위한 토론 및 제안을 요청합니다. 이 프로토콜의 표준화 상태 및 상태에 대해서는 "Internet Official Protocol Standards"\(STD 1\) 최신판을 참조하십시오. 이 메모의 배포는 무제한입니다.

---
# **Copyright Notice**

Copyright \(C\) The Internet Society \(1998\). 판권 소유.

---
# **Abstract**

이 문서에서는 IP Next Generation 또는 IPng라고도 하는 인터넷 프로토콜\(IPv6\) 버전 6을 지정합니다.

---
# **Table of Contents**

```text
   1. Introduction..................................................2
   2. Terminology...................................................3
   3. IPv6 Header Format............................................4
   4. IPv6 Extension Headers........................................6
       4.1 Extension Header Order...................................7
       4.2 Options..................................................9
       4.3 Hop-by-Hop Options Header...............................11
       4.4 Routing Header..........................................12
       4.5 Fragment Header.........................................18
       4.6 Destination Options Header..............................23
       4.7 No Next Header..........................................24
   5. Packet Size Issues...........................................24
   6. Flow Labels..................................................25
   7. Traffic Classes..............................................25
   8. Upper-Layer Protocol Issues..................................27
       8.1 Upper-Layer Checksums...................................27
       8.2 Maximum Packet Lifetime.................................28
       8.3 Maximum Upper-Layer Payload Size........................28
       8.4 Responding to Packets Carrying Routing Headers..........29
   Appendix A. Semantics and Usage of the Flow Label Field.........30
   Appendix B. Formatting Guidelines for Options...................32
   Security Considerations.........................................35
   Acknowledgments.................................................35
   Authors' Addresses..............................................35
   References......................................................35
   Changes Since RFC-1883..........................................36
   Full Copyright Statement........................................39
```

---
## **1.  Introduction**

IP 버전 6\(IPv6\)은 IP 버전 4\(IPv4\) \[RFC-791\]의 후속으로 설계된 새로운 버전의 인터넷 프로토콜입니다. IPv4에서 IPv6으로의 변경 사항은 주로 다음 범주로 분류됩니다.

```text
      o  Expanded Addressing Capabilities
```

- IPv6은 IP 주소 크기를 32비트에서 128비트로 늘려 더 많은 수준의 주소 지정 계층 구조, 훨씬 더 많은 수의 주소 지정 가능한 노드 및 간단한 주소 자동 구성을 지원합니다. 멀티캐스트 주소에 "범위" 필드를 추가하면 멀티캐스트 라우팅의 확장성이 향상됩니다. 그리고 "애니캐스트 주소"라는 새로운 유형의 주소가 정의되어 노드 그룹 중 어느 하나로 패킷을 보내는 데 사용됩니다.

```text
      o  Header Format Simplification
```

- 패킷 처리의 일반적인 처리 비용을 줄이고 IPv6 헤더의 대역폭 비용을 제한하기 위해 일부 IPv4 헤더 필드가 삭제되거나 선택 사항이 되었습니다.

- o 확장 및 옵션에 대한 지원 개선

- IP 헤더 옵션이 인코딩되는 방식이 변경되어 전달 효율성이 향상되고, 옵션 길이에 대한 제한이 덜 엄격해지며, 향후 새로운 옵션 도입에 대한 유연성이 향상됩니다.

```text
      o  Flow Labeling Capability
```

- 기본이 아닌 서비스 품질 또는 "실시간" 서비스와 같이 발신자가 특수 처리를 요청하는 특정 트래픽 "흐름"에 속하는 패킷에 레이블을 지정할 수 있는 새로운 기능이 추가되었습니다.

- o 인증 및 개인 정보 보호 기능

- 인증, 데이터 무결성 및 \(선택 사항\) 데이터 기밀성을 지원하는 확장이 IPv6에 대해 지정됩니다.

이 문서에서는 기본 IPv6 헤더와 초기에 정의된 IPv6 확장 헤더 및 옵션을 지정합니다. 또한 패킷 크기 문제, 흐름 레이블 및 트래픽 클래스의 의미, 상위 계층 프로토콜에 대한 IPv6의 영향에 대해 설명합니다. IPv6 주소의 형식과 의미는 \[ADDRARCH\]에 별도로 지정됩니다. 모든 IPv6 구현에 포함되어야 하는 ICMP의 IPv6 버전은 \[ICMPv6\]에 지정되어 있습니다.

---
## **2.  Terminology**

노드 - IPv6을 구현하는 장치입니다.

라우터 - 명시적으로 주소가 지정되지 않은 IPv6 패킷을 자신에게 전달하는 노드입니다. \[아래 참고 참조\].

호스트 - 라우터가 아닌 모든 노드. \[아래 참고 참조\].

상위 계층 - IPv6 바로 위의 프로토콜 계층입니다. 예를 들어 TCP 및 UDP와 같은 전송 프로토콜, ICMP와 같은 제어 프로토콜, OSPF와 같은 라우팅 프로토콜, IPX, AppleTalk 또는 IPv6 자체와 같은 IPv6를 통해 "터널링"되는\(즉, 캡슐화되는\) 인터넷 또는 하위 계층 프로토콜이 있습니다. .

링크 - 노드가 링크 계층, 즉 IPv6 바로 아래 계층에서 통신할 수 있는 통신 시설 또는 매체입니다. 예를 들면 이더넷\(단순 또는 브리지\)입니다. PPP 링크; X.25, 프레임 릴레이 또는 ATM 네트워크; IPv4 또는 IPv6 자체를 통한 터널과 같은 인터넷\(또는 그 이상\) 계층 "터널".

이웃 - 동일한 링크에 연결된 노드.

인터페이스 - 링크에 대한 노드의 연결입니다.

주소 - 인터페이스 또는 인터페이스 세트에 대한 IPv6 계층 식별자입니다.

패킷 - IPv6 헤더와 페이로드.

링크 MTU - 링크를 통해 전달할 수 있는 최대 전송 단위, 즉 옥텟 단위의 최대 패킷 크기입니다.

경로 MTU - 소스 노드와 대상 노드 사이의 경로에 있는 모든 링크의 최소 링크 MTU입니다.

참고: 일반적이지는 않지만 여러 인터페이스가 있는 장치가 일부 인터페이스 세트\(전체보다 적은 수\)에서 도착하는 자체 목적지가 아닌 패킷을 전달하고 다음에서 도착하는 자체 목적지가 아닌 패킷을 삭제하도록 구성될 수 있습니다. 다른 인터페이스. 이러한 장치는 이전\(전달\) 인터페이스에서 패킷을 수신하고 이를 통해 이웃과 상호 작용할 때 라우터에 대한 프로토콜 요구 사항을 준수해야 합니다. 후자\(비전달\) 인터페이스에서 패킷을 수신하고 이를 통해 이웃과 상호 작용할 때 호스트에 대한 프로토콜 요구 사항을 준수해야 합니다.

---
## **3.  IPv6 Header Format**

```text
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |Version| Traffic Class |           Flow Label                  |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |         Payload Length        |  Next Header  |   Hop Limit   |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                                                               |
   +                                                               +
   |                                                               |
   +                         Source Address                        +
   |                                                               |
   +                                                               +
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                                                               |
   +                                                               +
   |                                                               |
   +                      Destination Address                      +
   |                                                               |
   +                                                               +
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

   Version              4-bit Internet Protocol version number = 6.

   Traffic Class        8-bit traffic class field.  See section 7.

   Flow Label           20-bit flow label.  See section 6.

   Payload Length       16-bit unsigned integer.  Length of the IPv6
                        payload, i.e., the rest of the packet following
                        this IPv6 header, in octets.  (Note that any
```

- 존재하는 확장 헤더 \[섹션 4\]는 페이로드의 일부로 간주됩니다. 즉, 길이 카운트에 포함됩니다.\)

다음 헤더 8비트 선택기. IPv6 헤더 바로 뒤에 오는 헤더 유형을 식별합니다. IPv4 프로토콜 필드\[RFC-1700 et seq.\]와 동일한 값을 사용합니다.

홉 제한 8비트 부호 없는 정수입니다. 패킷을 전달하는 각 노드에 의해 1씩 감소됩니다. Hop Limit가 0으로 감소하면 패킷이 삭제됩니다.

소스 주소 패킷 발신자의 128비트 주소입니다. \[주소\]를 참조하세요.

대상 주소 의도된 패킷 수신자의 128비트 주소입니다\(라우팅 헤더가 있는 경우 최종 수신자가 아닐 수도 있음\). \[ADDRARCH\] 및 섹션 4.4를 참조하세요.

---
## **4.  IPv6 Extension Headers**

IPv6에서는 선택적 인터넷 계층 정보가 패킷의 IPv6 헤더와 상위 계층 헤더 사이에 배치될 수 있는 별도의 헤더에 인코딩됩니다. 이러한 확장 헤더는 소수이며 각각 고유한 Next Header 값으로 식별됩니다. 이러한 예에 설명된 것처럼 IPv6 패킷은 0개, 1개 또는 그 이상의 확장 헤더를 전달할 수 있으며, 각각은 이전 헤더의 다음 헤더 필드로 식별됩니다.

```text
   +---------------+------------------------
   |  IPv6 header  | TCP header + data
   |               |
   | Next Header = |
   |      TCP      |
   +---------------+------------------------

   +---------------+----------------+------------------------
   |  IPv6 header  | Routing header | TCP header + data
   |               |                |
   | Next Header = |  Next Header = |
   |    Routing    |      TCP       |
   +---------------+----------------+------------------------

   +---------------+----------------+-----------------+-----------------
   |  IPv6 header  | Routing header | Fragment header | fragment of TCP
   |               |                |                 |  header + data
   | Next Header = |  Next Header = |  Next Header =  |
   |    Routing    |    Fragment    |       TCP       |
   +---------------+----------------+-----------------+-----------------
```

한 가지 예외를 제외하고, 패킷이 IPv6의 대상 주소 필드에 식별된 노드\(또는 멀티캐스트의 경우 각 노드 집합\)에 도달할 때까지 패킷 전달 경로를 따라 어떤 노드에서도 확장 헤더를 검사하거나 처리하지 않습니다. 머리글. 여기서 IPv6 헤더의 다음 헤더 필드에 대한 일반적인 역다중화는 모듈을 호출하여 첫 ​​번째 확장 헤더를 처리하거나 확장 헤더가 없는 경우 상위 계층 헤더를 처리합니다. 각 확장 헤더의 내용과 의미에 따라 다음 헤더로 진행할지 여부가 결정됩니다. 따라서 확장 헤더는 패킷에 나타나는 순서대로 엄격하게 처리되어야 합니다. 예를 들어, 수신기는 특정 종류의 확장 헤더를 찾기 위해 패킷을 스캔하여 이전 헤더를 모두 처리하기 전에 해당 헤더를 처리해서는 안 됩니다.

이전 단락에서 언급한 예외는 홉별 옵션 헤더로, 소스 및 대상 노드를 포함하여 패킷 전달 경로를 따라 모든 노드에서 검사하고 처리해야 하는 정보를 전달합니다. 홉별 옵션 헤더가 있는 경우 IPv6 헤더 바로 뒤에 와야 합니다. 해당 존재는 IPv6 헤더의 다음 헤더 필드에 0 값으로 표시됩니다.

헤더 처리 결과 노드가 다음 헤더로 진행해야 하는데 현재 헤더의 Next Header 값을 노드가 인식하지 못하는 경우, 해당 패킷을 폐기하고 ICMP Parameter Problem 메시지를 소스로 보내야 한다. ICMP 코드 값이 1\("인식할 수 없는 다음 헤더 유형이 발생함"\)이고 ICMP 포인터 필드에는 원래 패킷 내에서 인식할 수 없는 값의 오프셋이 포함되어 있습니다. 노드가 IPv6 헤더가 아닌 다른 헤더에서 다음 헤더 값이 0인 경우에도 동일한 조치를 취해야 합니다.

각 확장 헤더는 후속 헤더에 대해 8옥텟 정렬을 유지하기 위해 길이가 8옥텟의 정수 배수입니다. 각 확장 헤더 내의 다중 옥텟 필드는 자연 경계에 정렬됩니다. 즉, n 옥텟 너비의 필드는 n = 1, 2, 4 또는 8인 경우 헤더 시작 부분에서 n 옥텟의 정수 배수에 배치됩니다.

IPv6의 전체 구현에는 다음 확장 헤더 구현이 포함됩니다.

```text
           Hop-by-Hop Options
           Routing (Type 0)
           Fragment
           Destination Options
           Authentication
           Encapsulating Security Payload
```

처음 4개는 이 문서에 지정되어 있습니다. 마지막 두 개는 각각 \[RFC-2402\]와 \[RFC-2406\]에 지정되어 있습니다.

---
## **4.1  Extension Header Order**

동일한 패킷에 두 개 이상의 확장 헤더가 사용되는 경우 해당 헤더가 다음 순서로 나타나는 것이 좋습니다.

```text
           IPv6 header
           Hop-by-Hop Options header
           Destination Options header (note 1)
           Routing header
           Fragment header

           Authentication header (note 2)
           Encapsulating Security Payload header (note 2)
           Destination Options header (note 3)
           upper-layer header
```

- 참고 1: IPv6 대상 주소 필드에 나타나는 첫 번째 대상과 라우팅 헤더에 나열된 후속 대상에 의해 처리되는 옵션에 대한 것입니다.

- 참고 2: 인증 및 보안 페이로드 캡슐화 헤더의 상대적 순서에 관한 추가 권장 사항은 \[RFC-2406\]에 제공됩니다.

- 참고 3: 옵션은 패킷의 최종 목적지에서만 처리됩니다.

각 확장 헤더는 최대 두 번 발생해야 하는 대상 옵션 헤더를 제외하고 최대 한 번 발생해야 합니다\(라우팅 헤더 전에 한 번, 상위 계층 헤더 전에 한 번\).

상위 계층 헤더가 다른 IPv6 헤더인 경우\(IPv6가 IPv6를 통해 터널링되거나 캡슐화되는 경우\) 자체 확장 헤더가 뒤따를 수 있으며, 이는 별도로 동일한 순서 권장 사항이 적용됩니다.

다른 확장 헤더가 정의된 경우 위에 나열된 헤더와 관련된 순서 제약 조건을 지정해야 합니다.

IPv6 노드는 IPv6 헤더 바로 뒤에 나타나도록 제한되는 홉별 옵션 헤더를 제외하고 동일한 패킷에서 여러 번 발생하고 순서에 관계없이 확장 헤더를 수락하고 처리하려고 시도해야 합니다. 그럼에도 불구하고 IPv6 패킷의 소스는 후속 사양에서 해당 권장 사항을 수정할 때까지 위의 권장 순서를 따르는 것이 좋습니다.

---
## **4.2  Options**

현재 정의된 확장 헤더 중 두 개\(Hop-by-Hop 옵션 헤더 및 대상 옵션 헤더\)는 다음 형식의 가변 개수의 TLV\(유형 길이 값\)로 인코딩된 "옵션"을 전달합니다.

```text
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- - - - - - - - -
      |  Option Type  |  Opt Data Len |  Option Data
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- - - - - - - - -
```

- 옵션 유형 옵션 유형의 8비트 식별자입니다.

- Opt Data Len 8비트 부호 없는 정수. 이 옵션의 옵션 데이터 필드 길이\(옥텟\)입니다.

```text
      Option Data          Variable-length field.  Option-Type-specific
                           data.
```

헤더 내의 옵션 순서는 헤더에 나타나는 순서대로 엄격하게 처리되어야 합니다. 예를 들어, 수신자는 특정 종류의 옵션을 찾기 위해 헤더를 스캔하여 이전 옵션을 모두 처리하기 전에 해당 옵션을 처리해서는 안 됩니다.

옵션 유형 식별자는 처리 중인 IPv6 노드가 옵션 유형을 인식하지 못하는 경우 수행해야 하는 작업을 최상위 2비트가 지정하도록 내부적으로 인코딩됩니다.

- 00 - 이 옵션을 건너뛰고 헤더 처리를 계속합니다.

- 01 - 패킷을 폐기합니다.

- 10 - 패킷을 폐기하고, 패킷의 대상 주소가 멀티캐스트 주소인지 여부에 관계없이 인식할 수 없는 옵션 유형을 가리키는 ICMP 매개변수 문제, 코드 2, 메시지를 패킷의 소스 주소로 보냅니다.

- 11 - 패킷을 폐기하고, 패킷의 대상 주소가 멀티캐스트 주소가 아닌 경우에만 ICMP 매개변수 문제, 코드 2, 메시지를 패킷의 소스 주소로 보내 인식할 수 없는 옵션 유형을 가리킵니다.

옵션 유형의 세 번째로 높은 비트는 해당 옵션의 옵션 데이터가 패킷의 최종 목적지로 가는 도중에 변경될 수 있는지 여부를 지정합니다. 인증 헤더가 있는 경우

패킷에서 데이터가 도중에 변경될 수 있는 옵션의 경우 패킷의 인증 값을 계산하거나 확인할 때 해당 옵션 데이터 필드 전체를 값이 0인 옥텟으로 처리해야 합니다.

```text
      0 - Option Data does not change en-route

      1 - Option Data may change en-route
```

위에 설명된 세 개의 상위 비트는 옵션 유형과 별개가 아닌 옵션 유형의 일부로 처리됩니다. 즉, 특정 옵션은 옵션 유형의 하위 5비트뿐만 아니라 전체 8비트 옵션 유형으로 식별됩니다.

홉별 옵션 헤더와 대상 옵션 헤더 모두에 동일한 옵션 유형 번호 지정 공간이 사용됩니다. 그러나 특정 옵션을 지정하면 두 헤더 중 하나로만 사용이 제한될 수 있습니다.

개별 옵션에는 옵션 데이터 필드 내의 다중 옥텟 값이 자연 경계에 포함되도록 하기 위한 특정 정렬 요구 사항이 있을 수 있습니다. 옵션의 정렬 요구 사항은 xn+y 표기법을 사용하여 지정됩니다. 즉, 옵션 유형은 헤더 시작 부분부터 x 옥텟의 정수 배수에 y 옥텟을 더한 정수 배수로 나타나야 합니다. 예를 들어:

- 2n은 헤더 시작 부분에서 2옥텟 오프셋을 의미합니다. 8n+2는 헤더 시작 부분의 8옥텟 오프셋에 2옥텟을 더한 것을 의미합니다.

후속 옵션을 정렬하고 포함 헤더를 8옥텟의 배수 길이로 채우는 데 필요할 때 사용되는 두 가지 패딩 옵션이 있습니다. 모든 IPv6 구현에서는 이러한 패딩 옵션을 인식해야 합니다.

```text
   Pad1 option  (alignment requirement: none)

      +-+-+-+-+-+-+-+-+
      |       0       |
      +-+-+-+-+-+-+-+-+
```

-  메모! Pad1 옵션의 형식은 특별한 경우입니다. 즉, 길이 및 값 필드가 없습니다.

- Pad1 옵션은 헤더의 옵션 영역에 패딩 1옥텟을 삽입하는 데 사용됩니다. 패딩의 옥텟이 두 개 이상 필요한 경우 여러 개의 Pad1 옵션 대신 다음에 설명하는 PadN 옵션을 사용해야 합니다.

```text
   PadN option  (alignment requirement: none)

      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- - - - - - - - -
      |       1       |  Opt Data Len |  Option Data
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- - - - - - - - -
```

- PadN 옵션은 헤더의 옵션 영역에 2개 이상의 패딩 옥텟을 삽입하는 데 사용됩니다. N 옥텟의 패딩의 경우 Opt Data Len 필드에는 N-2 값이 포함되고 옵션 데이터는 N-2 0 값 옥텟으로 구성됩니다.

부록 B에는 새 옵션을 디자인하기 위한 형식 지정 지침이 포함되어 있습니다.

---
## **4.3  Hop-by-Hop Options Header**

홉별 옵션 헤더는 패킷 전달 경로를 따라 모든 노드에서 검사해야 하는 선택적 정보를 전달하는 데 사용됩니다. 홉별 옵션 헤더는 IPv6 헤더에서 다음 헤더 값 0으로 식별되며 형식은 다음과 같습니다.

```text
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |  Next Header  |  Hdr Ext Len  |                               |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+                               +
    |                                                               |
    .                                                               .
    .                            Options                            .
    .                                                               .
    |                                                               |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

다음 헤더 8비트 선택기. 홉별 옵션 헤더 바로 뒤에 오는 헤더 유형을 식별합니다. IPv4 프로토콜 필드\[RFC-1700 et seq.\]와 동일한 값을 사용합니다.

Hdr Ext Len 8비트 부호 없는 정수. 처음 8옥텟을 제외한 8옥텟 단위의 홉별 옵션 헤더 길이입니다.

옵션 전체 홉별 옵션 헤더 길이가 8옥텟의 정수 배수가 되는 길이의 가변 길이 필드입니다. 섹션 4.2에 설명된 대로 하나 이상의 TLV 인코딩 옵션을 포함합니다.

이 문서에 정의된 유일한 홉별 옵션은 섹션 4.2에 지정된 Pad1 및 PadN 옵션입니다.

---
## **4.4  Routing Header**

라우팅 헤더는 IPv6 소스에서 패킷 대상으로 가는 도중에 "방문"할 하나 이상의 중간 노드를 나열하는 데 사용됩니다. 이 기능은 IPv4의 Loose Source and Record Route 옵션과 매우 유사합니다. 라우팅 헤더는 바로 앞 헤더에서 다음 헤더 값 43으로 식별되며 형식은 다음과 같습니다.

```text
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |  Next Header  |  Hdr Ext Len  |  Routing Type | Segments Left |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                                                               |
    .                                                               .
    .                       type-specific data                      .
    .                                                               .
    |                                                               |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

다음 헤더 8비트 선택기. 라우팅 헤더 바로 뒤에 오는 헤더 유형을 식별합니다. IPv4 프로토콜 필드\[RFC-1700 et seq.\]와 동일한 값을 사용합니다.

Hdr Ext Len 8비트 부호 없는 정수. 처음 8옥텟을 제외한 8옥텟 단위의 라우팅 헤더 길이입니다.

라우팅 유형 특정 라우팅 헤더 변형의 8비트 식별자입니다.

세그먼트 왼쪽 8비트 부호 없는 정수. 남은 경로 세그먼트 수, 즉 최종 목적지에 도달하기 전에 아직 방문해야 하는 명시적으로 나열된 중간 노드 수입니다.

유형별 데이터 라우팅 유형에 의해 결정되는 형식의 가변 길이 필드이며 전체 라우팅 헤더 길이가 8옥텟의 정수 배수가 되는 길이입니다.

수신된 패킷을 처리하는 동안 노드가 인식할 수 없는 라우팅 유형 값이 있는 라우팅 헤더를 발견하는 경우 노드의 필수 동작은 다음과 같이 왼쪽 세그먼트 필드의 값에 따라 달라집니다.

- 남은 세그먼트가 0인 경우 노드는 라우팅 헤더를 무시하고 패킷의 다음 헤더 처리를 진행해야 합니다. 해당 유형은 라우팅 헤더의 다음 헤더 필드로 식별됩니다.

- 남은 세그먼트가 0이 아닌 경우 노드는 패킷을 폐기하고 인식할 수 없는 라우팅 유형을 가리키는 ICMP 매개변수 문제, 코드 0, 메시지를 패킷의 소스 주소로 보내야 합니다.

수신된 패킷의 Routing 헤더를 처리한 후 중간 노드가 해당 패킷을 링크 MTU가 패킷 크기보다 작은 링크로 전달되어야 한다고 결정하면 해당 노드는 해당 패킷을 폐기하고 ICMP Packet Too를 보내야 합니다. 패킷의 소스 주소에 대한 큰 메시지입니다.

유형 0 라우팅 헤더의 형식은 다음과 같습니다.

```text
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |  Next Header  |  Hdr Ext Len  | Routing Type=0| Segments Left |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                            Reserved                           |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                                                               |
    +                                                               +
    |                                                               |
    +                           Address[1]                          +
    |                                                               |
    +                                                               +
    |                                                               |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                                                               |
    +                                                               +
    |                                                               |
    +                           Address[2]                          +
    |                                                               |
    +                                                               +
    |                                                               |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    .                               .                               .
    .                               .                               .
    .                               .                               .
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                                                               |
    +                                                               +
    |                                                               |
    +                           Address[n]                          +
    |                                                               |
    +                                                               +
    |                                                               |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

다음 헤더 8비트 선택기. 라우팅 헤더 바로 뒤에 오는 헤더 유형을 식별합니다. IPv4 프로토콜 필드\[RFC-1700 et seq.\]와 동일한 값을 사용합니다.

Hdr Ext Len 8비트 부호 없는 정수. 처음 8옥텟을 제외한 8옥텟 단위의 라우팅 헤더 길이입니다. 유형 0 라우팅 헤더의 경우 Hdr Ext Len은 헤더에 있는 주소 수의 2배와 같습니다.

```text
   Routing Type         0.
```

세그먼트 왼쪽 8비트 부호 없는 정수. 남은 경로 세그먼트 수, 즉 최종 목적지에 도달하기 전에 아직 방문해야 하는 명시적으로 나열된 중간 노드 수입니다.

예약된 32비트 예약 필드입니다. 전송을 위해 0으로 초기화됩니다. 수신시 무시됩니다.

Address\[1..n\] 128비트 주소의 벡터이며 1부터 n까지 번호가 매겨져 있습니다.

멀티캐스트 주소는 유형 0의 라우팅 헤더 또는 유형 0의 라우팅 헤더를 전달하는 패킷의 IPv6 대상 주소 필드에 표시되어서는 안 됩니다.

라우팅 헤더는 IPv6 헤더의 대상 주소 필드에서 식별된 노드에 도달할 때까지 검사되거나 처리되지 않습니다. 해당 노드에서 바로 앞 헤더의 다음 헤더 필드를 디스패치하면 라우팅 헤더 모듈이 호출됩니다. 라우팅 유형 0의 경우 다음 알고리즘을 수행합니다.

남은 세그먼트 = 0인 경우 {

- 라우팅 헤더의 다음 헤더 필드에 의해 유형이 식별되는 패킷의 다음 헤더 처리를 진행합니다. } 그렇지 않으면 Hdr Ext Len이 홀수인 경우 { ICMP 매개변수 문제, 코드 0, 메시지를 소스 주소로 보냅니다. Hdr Ext Len 필드를 삭제하고 패킷을 폐기합니다. } else { Hdr Ext Len을 2로 나누어 라우팅 헤더의 주소 수 n을 계산합니다.

왼쪽 세그먼트가 n보다 큰 경우 {

- ICMP 매개변수 문제, 코드 0, 메시지를 소스 주소로 보내고 Segments Left 필드를 가리키며 패킷을 폐기합니다. } else { Segments Left를 1씩 감소시킵니다. n에서 Segments Left를 빼서 주소 벡터에서 방문할 다음 주소의 인덱스인 i를 계산합니다.

- 주소 \[i\] 또는 IPv6 대상 주소가 멀티캐스트인 경우 { 패킷을 폐기합니다. } else { IPv6 대상 주소와 주소\[i\]를 교환합니다.

IPv6 홉 제한이 1보다 작거나 같은 경우 {

- ICMP Time Exceeded -- Hop Limit Exceeded in Transit 메시지를 소스 주소로 보내고 패킷을 폐기합니다. } else { Hop Limit를 1만큼 감소시킵니다.

```text
               resubmit the packet to the IPv6 module for transmission
               to the new destination
            }
         }
      }
   }
```

위 알고리즘의 효과에 대한 예로서 소스 노드 S가 대상 노드 D로 패킷을 전송하는 경우 라우팅 헤더를 사용하여 패킷이 중간 노드 I1, I2 및 I3을 통해 라우팅되도록 하는 경우를 고려하십시오. 전달 경로의 각 세그먼트에 있는 관련 IPv6 헤더 및 라우팅 헤더 필드의 값은 다음과 같습니다.

패킷이 S에서 I1으로 이동할 때:

```text
        Source Address = S                  Hdr Ext Len = 6
        Destination Address = I1            Segments Left = 3
                                            Address[1] = I2
                                            Address[2] = I3
                                            Address[3] = D
```

패킷이 I1에서 I2로 이동할 때:

```text
        Source Address = S                  Hdr Ext Len = 6
        Destination Address = I2            Segments Left = 2
                                            Address[1] = I1
                                            Address[2] = I3
                                            Address[3] = D
```

패킷이 I2에서 I3으로 이동할 때:

```text
        Source Address = S                  Hdr Ext Len = 6
        Destination Address = I3            Segments Left = 1
                                            Address[1] = I1
                                            Address[2] = I2
                                            Address[3] = D
```

패킷이 I3에서 D로 이동할 때:

```text
        Source Address = S                  Hdr Ext Len = 6
        Destination Address = D             Segments Left = 0
                                            Address[1] = I1
                                            Address[2] = I2
                                            Address[3] = I3
```

---
## **4.5  Fragment Header**

조각 헤더는 IPv6 소스에서 경로 MTU에 맞는 것보다 큰 패킷을 대상으로 보내는 데 사용됩니다. \(참고: IPv4와 달리 IPv6의 조각화는 패킷 전달 경로에 있는 라우터가 아닌 소스 노드에 의해서만 수행됩니다. 섹션 5를 참조하십시오.\) 조각 헤더는 바로 앞 헤더에서 다음 헤더 값 44로 식별됩니다. 다음과 같은 형식을 갖습니다.

```text
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |  Next Header  |   Reserved    |      Fragment Offset    |Res|M|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                         Identification                        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

다음 헤더 8비트 선택기. 원본 패킷의 조각화 가능한 부분의 초기 헤더 유형을 식별합니다\(아래에 정의됨\). IPv4 프로토콜 필드\[RFC-1700 et seq.\]와 동일한 값을 사용합니다.

예약된 8비트 예약 필드입니다. 전송을 위해 0으로 초기화됩니다. 수신시 무시됩니다.

조각 오프셋 13비트 부호 없는 정수입니다. 원본 패킷의 조각화 가능 부분의 시작을 기준으로 이 헤더 뒤에 오는 데이터의 오프셋\(8옥텟 단위\)입니다.

Res 2비트 예약 필드입니다. 전송을 위해 0으로 초기화됩니다. 수신시 무시됩니다.

```text
   M flag               1 = more fragments; 0 = last fragment.

   Identification       32 bits.  See description below.
```

너무 커서 경로의 MTU에 맞지 않는 패킷을 대상으로 보내기 위해 소스 노드는 패킷을 조각으로 나누고 각 조각을 별도의 패킷으로 보내 수신기에서 재조립할 수 있습니다.

조각화될 모든 패킷에 대해 소스 노드는 식별 값을 생성합니다. 식별은 동일한 소스 주소와 대상 주소를 사용하여 최근\* 전송된 다른 조각난 패킷의 식별과 달라야 합니다. 라우팅 헤더가 있는 경우 해당 대상 주소는 최종 대상의 주소입니다.

- \* "최근"은 소스에서 대상까지의 전송 시간 및 동일한 패킷의 다른 조각과의 재조립을 기다리는 데 소요된 시간을 포함하여 패킷의 최대 예상 수명 내를 의미합니다. 그러나 소스 노드가 최대 패킷 수명을 알 필요는 없습니다. 오히려 패킷을 조각화해야 할 때마다 증가하는 간단한 32비트 "랩 어라운드" 카운터로 식별 값을 유지함으로써 요구 사항을 충족할 수 있다고 가정합니다. 노드에 대해 단일 카운터를 유지할지 여러 카운터를 유지할지 여부는 구현 선택입니다\(예: 노드의 가능한 소스 주소 각각에 대해 하나씩 또는 각 활성\(소스 주소, 대상 주소\) 조합에 대해 하나씩\).

조각화되지 않은 초기의 대규모 패킷을 "원래 패킷"이라고 하며 그림과 같이 두 부분으로 구성된 것으로 간주됩니다.

```text
   original packet:

   +------------------+----------------------//-----------------------+
   |  Unfragmentable  |                 Fragmentable                  |
   |       Part       |                     Part                      |
   +------------------+----------------------//-----------------------+
```

- 조각화할 수 없는 부분은 IPv6 헤더와 대상으로 가는 도중 노드에서 처리해야 하는 모든 확장 헤더, 즉 라우팅 헤더가 있는 경우 라우팅 헤더까지의 모든 헤더로 구성되며, 그렇지 않으면 홉별 옵션 헤더로 구성됩니다. 존재하지 않으면 확장 헤더가 없습니다.

- 조각화 가능 부분은 패킷의 나머지 부분, 즉 최종 대상 노드에서만 처리해야 하는 확장 헤더와 상위 계층 헤더 및 데이터로 구성됩니다.

원본 패킷의 조각화 가능 부분은 조각으로 나누어지며, 각 조각은 마지막\("가장 오른쪽"\) 조각을 제외하고 길이가 8옥텟의 정수 배수입니다. 조각은 그림과 같이 별도의 "조각 패킷"으로 전송됩니다.

```text
   original packet:

   +------------------+--------------+--------------+--//--+----------+
   |  Unfragmentable  |    first     |    second    |      |   last   |
   |       Part       |   fragment   |   fragment   | .... | fragment |
   +------------------+--------------+--------------+--//--+----------+

   fragment packets:

   +------------------+--------+--------------+
   |  Unfragmentable  |Fragment|    first     |
   |       Part       | Header |   fragment   |
   +------------------+--------+--------------+

   +------------------+--------+--------------+
   |  Unfragmentable  |Fragment|    second    |
   |       Part       | Header |   fragment   |
   +------------------+--------+--------------+
                         o
                         o
                         o
   +------------------+--------+----------+
   |  Unfragmentable  |Fragment|   last   |
   |       Part       | Header | fragment |
   +------------------+--------+----------+
```

각 조각 패킷은 다음으로 구성됩니다.

- \(1\) 원본 IPv6 헤더의 페이로드 길이가 이 조각 패킷의 길이만 포함하도록 변경된 원본 패킷의 조각화할 수 없는 부분\(IPv6 헤더 자체의 길이 제외\)과 마지막 패킷의 다음 헤더 필드 조각화할 수 없는 부분의 헤더가 44로 변경되었습니다.

- \(2\) 다음을 포함하는 조각 헤더:

- 원본 패킷의 조각화 가능한 부분의 첫 번째 헤더를 식별하는 다음 헤더 값입니다.

- 원본 패킷의 조각화 가능한 부분의 시작을 기준으로 조각의 오프셋을 8옥텟 단위로 포함하는 조각 오프셋입니다. 첫 번째\("가장 왼쪽"\) 조각의 조각 오프셋은 0입니다.

조각이 마지막 조각인 경우 M 플래그 값은 0입니다.

- \("가장 오른쪽"\) 1개, 그렇지 않으면 M 플래그 값 1.

- 원본 패킷에 대해 생성된 식별 값입니다.

-\(3\) 조각 자체.

결과 조각 패킷이 패킷 대상 경로의 MTU 내에 맞도록 조각의 길이를 선택해야 합니다.

대상에서 조각 패킷은 그림과 같이 조각화되지 않은 원래 형식으로 재조립됩니다.

```text
   reassembled original packet:

   +------------------+----------------------//------------------------+
   |  Unfragmentable  |                 Fragmentable                   |
   |       Part       |                     Part                       |
   +------------------+----------------------//------------------------+
```

재조립에는 다음 규칙이 적용됩니다.

- 원본 패킷은 동일한 소스 주소, 대상 주소 및 조각 ID를 가진 조각 패킷에서만 재조립됩니다.

- 재조립된 패킷의 Unfragmentable Part는 첫 번째 조각 패킷\(즉, 조각 오프셋이 0인 패킷\)의 조각 헤더까지의 모든 헤더로 구성되며 다음 두 가지 변경 사항이 있습니다.

- Unfragmentable Part의 마지막 헤더의 Next Header 필드는 첫 번째 조각의 Fragment 헤더의 Next Header 필드에서 가져옵니다.

- 재조립된 패킷의 페이로드 길이는 조각화할 수 없는 부분의 길이와 마지막 조각의 길이 및 오프셋으로부터 계산됩니다. 예를 들어, 재조립된 원본 패킷의 페이로드 길이를 계산하는 공식은 다음과 같습니다.

```text
           PL.orig = PL.first - FL.first - 8 + (8 * FO.last) + FL.last
```

어디

- PL.orig = 재조립된 패킷의 페이로드 길이 필드입니다. PL.first = 첫 번째 조각 패킷의 페이로드 길이 필드입니다. FL.first = 첫 번째 조각 패킷의 조각 헤더 다음에 나오는 조각의 길이입니다. FO.last = 마지막 조각 패킷의 조각 헤더에 있는 조각 오프셋 필드입니다. FL.last = 마지막 조각 패킷의 조각 헤더 다음에 나오는 조각의 길이입니다.

- 재조립된 패킷의 조각화 가능 부분은 각 조각 패킷의 조각 헤더 다음에 나오는 조각으로 구성됩니다. 각 조각의 길이는 패킷의 페이로드 길이에서 패킷의 길이를 빼서 계산됩니다.

- IPv6 헤더와 조각 자체 사이의 헤더 조각화 가능 부분의 상대 위치는 조각 오프셋 값에서 계산됩니다.

- Fragment 헤더는 최종 재조립된 패킷에 존재하지 않습니다.

조각난 패킷을 재조립할 때 다음과 같은 오류 조건이 발생할 수 있습니다.

- 해당 패킷의 처음 도착한 조각을 수신한 후 60초 이내에 패킷 재조립을 완료하기에 불충분한 조각이 수신된 경우 해당 패킷의 재조립을 포기해야 하며 해당 패킷에 대해 수신된 모든 조각을 폐기해야 합니다. 첫 번째 조각\(즉, 조각 오프셋이 0인 조각\)이 수신된 경우 ICMP 시간 초과 - 조각 재조립 시간 초과 메시지가 해당 조각의 소스로 전송되어야 합니다.

- 조각 패킷의 페이로드 길이 필드에서 파생된 조각의 길이가 8옥텟의 배수가 아니고 해당 조각의 M 플래그가 1인 경우 해당 조각은 폐기되어야 하며 ICMP 매개변수 문제, 코드 0, 메시지는 조각 패킷의 페이로드 길이 필드를 가리키는 조각 소스로 전송되어야 합니다.

- 조각의 길이와 오프셋이 해당 조각에서 재조립된 패킷의 페이로드 길이가 65,535옥텟을 초과하는 경우 해당 조각은 폐기되어야 하며 ICMP 매개변수 문제\(코드 0\) 메시지가 소스로 전송되어야 합니다. 조각 패킷의 조각 오프셋 필드를 가리키는 조각입니다.

다음 조건은 발생할 것으로 예상되지 않지만 발생하더라도 오류로 간주되지 않습니다.

- 동일한 원본 패킷의 여러 조각에 대한 조각 헤더 앞에 있는 헤더의 수와 내용이 다를 수 있습니다. 각 조각 패킷의 조각 헤더 앞에 있는 헤더가 무엇이든 패킷이 도착할 때 재조립을 위해 조각을 대기열에 넣기 전에 처리됩니다. 오프셋 0 조각 패킷의 헤더만 리어셈블된 패킷에 유지됩니다.

- 동일한 원본 패킷의 여러 조각에 대한 조각 헤더의 다음 헤더 값이 다를 수 있습니다. 리어셈블리에는 오프셋 0 조각 패킷의 값만 사용됩니다.

---
## **4.6  Destination Options Header**

대상 옵션 헤더는 패킷의 대상 노드에서만 검사해야 하는 선택적 정보를 전달하는 데 사용됩니다. 대상 옵션 헤더는 바로 앞 헤더의 다음 헤더 값 60으로 식별되며 형식은 다음과 같습니다.

```text
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |  Next Header  |  Hdr Ext Len  |                               |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+                               +
    |                                                               |
    .                                                               .
    .                            Options                            .
    .                                                               .
    |                                                               |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

다음 헤더 8비트 선택기. 대상 옵션 헤더 바로 뒤에 오는 헤더 유형을 식별합니다. IPv4 프로토콜 필드\[RFC-1700 et seq.\]와 동일한 값을 사용합니다.

Hdr Ext Len 8비트 부호 없는 정수. 길이

- 처음 8옥텟을 제외하고 8옥텟 단위의 대상 옵션 헤더입니다.

옵션 전체 대상 옵션 헤더 길이가 8옥텟의 정수 배수가 되는 길이의 가변 길이 필드입니다. 섹션 4.2에 설명된 대로 하나 이상의 TLV 인코딩 옵션을 포함합니다.

이 문서에 정의된 유일한 대상 옵션은 섹션 4.2에 지정된 Pad1 및 PadN 옵션입니다.

IPv6 패킷에서 선택적 대상 정보를 인코딩하는 방법에는 두 가지가 있습니다. 대상 옵션 헤더의 옵션 또는 별도의 확장 헤더입니다. Fragment 헤더와 Authentication 헤더는 후자 접근 방식의 예입니다. 사용할 수 있는 접근 방식은 선택적 정보를 이해하지 못하는 대상 노드에 대해 원하는 작업에 따라 다릅니다.

- o 원하는 작업이 대상 노드에서 패킷을 삭제하는 것이고, 패킷의 대상 주소가 멀티캐스트 주소가 아닌 경우에만 ICMP 인식할 수 없는 유형 메시지를 패킷의 소스 주소로 보내는 것이라면 정보는 다음 중 하나로 인코딩될 수 있습니다. 별도의 헤더 또는 옵션으로

- 옵션 유형의 최상위 2비트 값이 11인 대상 옵션 헤더입니다. 선택은 더 적은 옥텟을 사용하거나 더 나은 정렬 또는 더 효율적인 구문 분석을 생성하는 요소에 따라 달라질 수 있습니다.

- o 다른 작업이 필요한 경우 해당 정보는 옵션 유형의 최상위 2비트 값이 00, 01 또는 10인 대상 옵션 헤더의 옵션으로 인코딩되어 원하는 작업을 지정해야 합니다\(섹션 4.2 참조\). \).

---
## **4.7 No Next Header**

IPv6 헤더 또는 확장 헤더의 다음 헤더 필드 값 59는 해당 헤더 뒤에 아무것도 없음을 나타냅니다. IPv6 헤더의 페이로드 길이 필드가 다음 헤더 필드에 59가 포함된 헤더 끝을 지나 옥텟이 있음을 나타내는 경우 해당 옥텟은 무시되어야 하며 패킷이 전달되는 경우 변경되지 않은 채 전달되어야 합니다.

---
## **5. Packet Size Issues**

IPv6에서는 인터넷의 모든 링크에 1280옥텟 이상의 MTU가 필요합니다. 1280옥텟 패킷을 하나로 전달할 수 없는 링크에서는 링크별 조각화 및 재조립이 IPv6 아래 계층에서 제공되어야 합니다.

구성 가능한 MTU가 있는 링크\(예: PPP 링크 \[RFC-1661\]\)는 최소 1280옥텟의 MTU를 갖도록 구성되어야 합니다. IPv6 계층 조각화를 발생시키지 않고 가능한 캡슐화\(예: 터널링\)를 수용하려면 1500옥텟 이상의 MTU로 구성하는 것이 좋습니다.

노드가 직접 연결된 각 링크에서 노드는 해당 링크의 MTU만큼 큰 패킷을 받아들일 수 있어야 합니다.

1280 옥텟보다 큰 경로 MTU를 검색하고 활용하려면 IPv6 노드에서 경로 MTU 검색 \[RFC-1981\]을 구현하는 것이 좋습니다. 그러나 최소 IPv6 구현\(예: 부팅 ROM\)에서는 1280옥텟 이하의 패킷 전송으로 제한하고 경로 MTU 검색 구현을 생략할 수 있습니다.

경로의 MTU보다 큰 패킷을 전송하기 위해 노드는 IPv6 Fragment 헤더를 사용하여 소스에서 패킷을 조각화하고 대상에서 재조립할 수 있습니다. 그러나 측정된 경로 MTU\(즉, 1280옥텟까지\)에 맞게 패킷을 조정할 수 있는 애플리케이션에서는 이러한 조각화를 사용하지 않는 것이 좋습니다.

노드는 재조립 후 크기가 1500옥텟에 달하는 조각난 패킷을 받아들일 수 있어야 합니다. 노드는 1500옥텟 이상으로 재조립되는 조각화된 패킷을 허용할 수 있습니다. 경로의 MTU보다 큰 패킷을 보내기 위해 IPv6 조각화에 의존하는 상위 계층 프로토콜이나 애플리케이션은 대상이 더 큰 크기의 패킷을 재조립할 수 있다는 보장이 없는 한 1500옥텟보다 큰 패킷을 보내서는 안 됩니다.

IPv4 목적지로 전송되는 IPv6 패킷\(즉, IPv6에서 IPv4로 변환되는 패킷\)에 대한 응답으로, 원래 IPv6 노드는 1280 미만의 Next-Hop MTU를 보고하는 ICMP Packet Too Big 메시지를 수신할 수 있습니다. 이 경우 IPv6 노드는 후속 패킷의 크기를 1280 미만으로 줄일 필요는 없지만 IPv6-IPv4 변환 라우터가 결과에 사용할 적절한 식별 값을 얻을 수 있도록 해당 패킷에 조각 헤더를 포함해야 합니다. IPv4 조각. 이는 페이로드를 1232옥텟\(IPv6 헤더의 경우 1280에서 40, 조각 헤더의 경우 8\)으로 줄여야 하며, 추가 확장 헤더를 사용하는 경우에는 여전히 더 작아야 함을 의미합니다.

---
## **6.  Flow Labels**

IPv6 헤더의 20비트 흐름 레이블 필드는 기본이 아닌 서비스 품질 또는 "실시간" 서비스와 같이 IPv6 라우터의 특수 처리를 요청하는 패킷 시퀀스에 레이블을 지정하기 위해 소스에서 사용할 수 있습니다. 이 글을 쓰는 시점에서 IPv6의 이러한 측면은 여전히 ​​실험적이며 인터넷의 흐름 지원에 대한 요구 사항이 더욱 명확해짐에 따라 변경될 수 있습니다. Flow Label 필드 기능을 지원하지 않는 호스트나 라우터에서는 패킷을 보낼 때 해당 필드를 0으로 설정하고, 패킷을 전달할 때 해당 필드를 그대로 전달하고, 패킷을 받을 때 해당 필드를 무시해야 합니다.

부록 A에서는 흐름 레이블 필드의 현재 의도된 의미와 사용법을 설명합니다.

---
## **7.  Traffic Classes**

IPv6 헤더의 8비트 트래픽 클래스 필드는 IPv6 패킷의 다양한 클래스 또는 우선 순위를 식별하고 구별하기 위해 발신 노드 및/또는 전달 라우터에서 사용할 수 있습니다. 이 사양이 작성되는 시점에서 IP 패킷에 대해 다양한 형태의 "차별화된 서비스"를 제공하기 위해 IPv4 서비스 유형 및/또는 우선 순위 비트를 사용하는 많은 실험이 진행 중입니다. 명시적인 흐름 설정의 사용. IPv6 헤더의 트래픽 클래스 필드는 IPv6에서 유사한 기능을 지원할 수 있도록 하기 위한 것입니다.

이러한 실험을 통해 결국 어떤 종류의 트래픽 분류가 IP 패킷에 가장 유용한지에 대한 합의가 이루어지기를 바랍니다. 실험적이든 최종 표준화를 위한 것이든 IPv6 트래픽 클래스 비트 전체 또는 일부의 구문 및 의미에 대한 자세한 정의는 별도의 문서에서 제공됩니다.

트래픽 클래스 필드에는 다음과 같은 일반 요구 사항이 적용됩니다.

- o 노드 내의 IPv6 서비스에 대한 서비스 인터페이스는 상위 계층 프로토콜이 해당 상위 계층 프로토콜에서 시작된 패킷의 트래픽 클래스 비트 값을 제공할 수 있는 수단을 제공해야 합니다. 기본값은 8비트 모두 0이어야 합니다.

- o 트래픽 클래스 비트 중 일부 또는 전부의 특정\(실험적 또는 최종 표준\) 사용을 지원하는 노드는 해당 특정 사용에 필요한 대로 자신이 시작, 전달 또는 수신하는 패킷의 비트 값을 변경할 수 있습니다. 노드는 특정 용도를 지원하지 않는 트래픽 클래스 필드의 비트를 무시하고 변경하지 않고 그대로 두어야 합니다.

- o 상위 계층 프로토콜은 수신된 패킷의 트래픽 클래스 비트 값이 패킷 소스에서 보낸 값과 동일하다고 가정해서는 안 됩니다.

---
## **8. Upper-Layer Protocol Issues**
---
## **8.1 Upper-Layer Checksums**

체크섬 계산에 IP 헤더의 주소를 포함하는 모든 전송 또는 기타 상위 계층 프로토콜은 IPv6에서 사용하도록 수정되어 32비트 IPv4 주소 대신 128비트 IPv6 주소를 포함해야 합니다. 특히 다음 그림은 IPv6에 대한 TCP 및 UDP "의사 헤더"를 보여줍니다.

```text
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                                                               |
   +                                                               +
   |                                                               |
   +                         Source Address                        +
   |                                                               |
   +                                                               +
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                                                               |
   +                                                               +
   |                                                               |
   +                      Destination Address                      +
   |                                                               |
   +                                                               +
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                   Upper-Layer Packet Length                   |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                      zero                     |  Next Header  |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

- o IPv6 패킷에 라우팅 헤더가 포함된 경우 의사 헤더에 사용된 대상 주소는 최종 대상 주소입니다. 원래 노드에서 해당 주소는 라우팅 헤더의 마지막 요소에 있습니다. 수신자에서 해당 주소는 IPv6 헤더의 대상 주소 필드에 있습니다.

- o 의사 헤더의 다음 헤더 값은 상위 계층 프로토콜을 식별합니다\(예: TCP의 경우 6, UDP의 경우 17\). IPv6 헤더와 상위 계층 헤더 사이에 확장 헤더가 있는 경우 IPv6 헤더의 Next Header 값과 다릅니다.

- o 의사 헤더의 상위 계층 패킷 길이는 상위 계층 헤더와 데이터\(예: TCP 헤더 + TCP 데이터\)의 길이입니다. 일부 상위 계층 프로토콜은 자체 프로토콜을 가지고 있습니다.

- 길이 정보\(예: UDP 헤더의 길이 필드\) 그러한 프로토콜의 경우 이는 의사 헤더에 사용되는 길이입니다. 다른 프로토콜\(예: TCP\)은 자체 길이 정보를 전달하지 않습니다. 이 경우 의사 헤더에 사용되는 길이는 IPv6 헤더의 페이로드 길이에서 IPv6 헤더와 상위 헤더 사이에 있는 확장 헤더의 길이를 뺀 값입니다. -레이어 헤더.

- o IPv4와 달리 UDP 패킷이 IPv6 노드에서 시작되는 경우 UDP 체크섬은 선택 사항이 아닙니다. 즉, UDP 패킷이 발생할 때마다 IPv6 노드는 패킷과 의사 헤더에 대해 UDP 체크섬을 계산해야 하며, 계산 결과가 0인 경우 UDP 헤더에 배치하기 위해 16진수 FFFF로 변경해야 합니다. . IPv6 수신자는 체크섬이 0인 UDP 패킷을 삭제해야 하며 오류를 기록해야 합니다.

ICMP \[ICMPv6\]의 IPv6 버전은 체크섬 계산에 위의 의사 헤더를 포함합니다. 이는 체크섬에 의사 헤더가 포함되지 않은 ICMP IPv4 버전의 변경 사항입니다. 변경 이유는 IPv4와 달리 인터넷 계층 체크섬이 적용되지 않는 IPv6 헤더 필드의 잘못된 전달이나 손상으로부터 ICMP를 보호하기 위한 것입니다. ICMP 의사 헤더의 다음 헤더 필드에는 ICMP의 IPv6 버전을 식별하는 값 58이 포함되어 있습니다.

---
## **8.2 Maximum Packet Lifetime**

IPv4와 달리 IPv6 노드는 최대 패킷 수명을 적용할 필요가 없습니다. 이것이 IPv6에서 IPv4 "Time to Live" 필드의 이름이 "Hop Limit"로 변경된 이유입니다. 실제로 패킷 수명을 제한하는 요구 사항을 준수하는 IPv4 구현은 거의 없으므로 이는 실제로 변경되지 않습니다. 패킷 수명을 제한하기 위해 인터넷 계층\(IPv4 또는 IPv6\)에 의존하는 모든 상위 계층 프로토콜은 더 이상 사용되지 않는 패킷을 감지하고 삭제하기 위한 자체 메커니즘을 제공하도록 업그레이드되어야 합니다.

---
## **8.3 Maximum Upper-Layer Payload Size**

상위 계층 데이터에 사용할 수 있는 최대 페이로드 크기를 계산할 때 상위 계층 프로토콜은 IPv4 헤더에 비해 IPv6 헤더의 더 큰 크기를 고려해야 합니다. 예를 들어 IPv4에서 TCP의 MSS 옵션은 최대 패킷 크기\(기본값 또는 경로 MTU 검색을 통해 학습된 값\)에서 40옥텟\(최소 길이 IPv4 헤더의 경우 20옥텟, 최소 길이의 경우 20옥텟\)을 뺀 값으로 계산됩니다. TCP 헤더\). IPv6을 통해 TCP를 사용하는 경우 MSS는 최대 패킷 크기에서 60옥텟을 뺀 값으로 계산되어야 합니다.

최소 길이 IPv6 헤더\(즉, 확장 헤더가 없는 IPv6 헤더\)가 최소 길이 IPv4 헤더보다 20옥텟 더 길기 때문입니다.

---
## **8.4 Responding to Packets Carrying Routing Headers**

상위 계층 프로토콜이 라우팅 헤더를 포함하는 수신된 패킷에 대한 응답으로 하나 이상의 패킷을 보낼 때, 응답 패킷에는 무결성이 손상되지 않는 한 수신된 라우팅 헤더를 "역전"하여 자동으로 파생된 라우팅 헤더가 포함되어서는 안 됩니다. 수신된 소스 주소 및 라우팅 헤더의 신뢰성이 확인되었습니다\(예: 수신된 패킷의 인증 헤더 사용을 통해\). 즉, 라우팅 헤더가 포함된 수신 패킷에 대한 응답으로 다음 종류의 패킷만 허용됩니다.

- o 라우팅 헤더를 전달하지 않는 응답 패킷.

- o 수신된 패킷의 라우팅 헤더를 반전하여 파생되지 않은 라우팅 헤더를 전달하는 응답 패킷\(예: 로컬 구성에서 제공되는 라우팅 헤더\).

- o 수신된 패킷의 라우팅 헤더를 역전하여 파생된 라우팅 헤더를 전달하는 응답 패킷은 수신된 패킷의 소스 주소 및 라우팅 헤더의 무결성과 신뢰성이 응답자에 의해 확인된 경우에만 해당됩니다.

---
# **Appendix A. Semantics and Usage of the Flow Label Field**

흐름은 특정 소스에서 소스가 중간 라우터의 특별한 처리를 원하는 특정\(유니캐스트 또는 멀티캐스트\) 대상으로 전송되는 일련의 패킷입니다. 이러한 특수 처리의 특성은 리소스 예약 프로토콜과 같은 제어 프로토콜 또는 홉별 옵션과 같은 흐름 패킷 자체 내의 정보를 통해 라우터에 전달될 수 있습니다. 그러한 제어 프로토콜이나 옵션에 대한 세부 사항은 이 문서의 범위를 벗어납니다.

소스에서 대상까지 여러 활성 흐름이 있을 수 있을 뿐만 아니라 어떤 흐름과도 연결되지 않은 트래픽이 있을 수 있습니다. 흐름은 소스 주소와 0이 아닌 흐름 레이블의 조합으로 고유하게 식별됩니다. 흐름에 속하지 않는 패킷은 흐름 레이블 0을 갖습니다.

흐름 레이블은 흐름의 소스 노드에 의해 흐름에 할당됩니다. 새로운 흐름 레이블은 1에서 FFFFF 16진수 범위에서 \(의사\) 무작위로 균일하게 선택되어야 합니다. 무작위 할당의 목적은 흐름과 관련된 상태를 조회하기 위해 라우터에서 해시 키로 사용하기에 적합한 흐름 레이블 필드 내의 비트 세트를 만드는 것입니다.

동일한 흐름에 속하는 모든 패킷은 동일한 소스 주소, 대상 주소 및 흐름 레이블을 사용하여 전송되어야 합니다. 해당 패킷 중 하나라도 홉별 옵션 헤더를 포함하는 경우 해당 패킷은 모두 동일한 홉별 옵션 헤더 콘텐츠\(홉별 옵션 헤더의 다음 헤더 필드 제외\)로 시작되어야 합니다. 해당 패킷 중 하나라도 라우팅 헤더를 포함하는 경우 라우팅 헤더를 포함하여 모든 확장 헤더에서 동일한 내용으로 시작되어야 합니다\(라우팅 헤더의 다음 헤더 필드 제외\). 이러한 조건이 충족되는지 확인하기 위해 라우터 또는 대상이 허용되지만 필수는 아닙니다. 위반이 감지되면 흐름 레이블 필드의 상위 옥텟\(즉, IPv6 패킷 내의 오프셋 1\)을 가리키는 ICMP 매개 변수 문제 메시지 코드 0을 통해 소스에 보고되어야 합니다.

흐름 경로를 따라 설정된 흐름 처리 상태의 최대 수명은 상태 설정 메커니즘 설명\(예: 자원 예약 프로토콜 또는 흐름 설정 홉별 옵션\)의 일부로 지정되어야 합니다. 소스는 해당 흐름 레이블의 이전 사용을 위해 설정되었을 수 있는 흐름 처리 상태의 최대 수명 내에 새 흐름에 대한 흐름 레이블을 재사용해서는 안 됩니다.

노드가 중지되었다가 다시 시작될 때\(예: "충돌"의 결과\) 수명이 아직 만료되지 않은 이전 흐름에 사용했을 수 있는 흐름 레이블을 사용하지 않도록 주의해야 합니다. 이는 충돌 시 기억될 수 있도록 안정적인 저장소에 흐름 레이블 사용을 기록하거나 이전에 설정된 흐름의 최대 수명이 만료될 때까지 흐름 레이블 사용을 자제함으로써 수행할 수 있습니다. 노드를 재부팅하는 데 필요한 최소 시간을 알면 흐름 레이블 할당을 시작하기 전에 필요한 대기 기간에서 해당 시간을 공제할 수 있습니다.

모든 또는 대부분의 패킷이 흐름에 속해야 한다는 요구 사항은 없습니다. 즉, 0이 아닌 흐름 레이블을 전달해야 합니다. 이 관찰은 프로토콜 설계자와 구현자가 달리 가정하지 않도록 상기시키기 위해 여기에 배치되었습니다. 예를 들어, 대부분의 패킷이 흐름에 속하는 경우에만 성능이 적절한 라우터를 설계하거나 흐름에 속한 패킷에서만 작동하는 헤더 압축 방식을 설계하는 것은 현명하지 않습니다.

---
# **Appendix B. Formatting Guidelines for Options**

이 부록은 섹션 4.2에 설명된 대로 홉별 옵션 헤더 또는 대상 옵션 헤더에 사용할 새 옵션을 설계할 때 필드를 배치하는 방법에 대한 몇 가지 조언을 제공합니다. 이러한 지침은 다음과 같은 가정을 기반으로 합니다.

- o 한 가지 바람직한 기능은 옵션의 옵션 데이터 영역 내의 모든 다중 옥텟 필드가 자연 경계에 정렬된다는 것입니다. 즉, 너비 n 옥텟의 필드는 홉 시작부터 n 옥텟의 정수배에 배치되어야 합니다. n = 1, 2, 4 또는 8인 경우 홉별 또는 대상 옵션 헤더.

- o 또 다른 바람직한 기능은 홉별\(Hop-by-Hop\) 또는 대상 옵션 헤더가 8옥텟 길이의 정수 배수라는 요구 사항에 따라 가능한 한 적은 공간을 차지한다는 것입니다.

- o 옵션을 포함하는 헤더 중 하나가 존재할 때 매우 적은 수의 옵션\(보통 하나만 포함\)을 전달한다고 가정할 수 있습니다.

이러한 가정은 옵션의 필드를 레이아웃하는 다음과 같은 접근 방식을 제안합니다. 내부 패딩 없이 가장 작은 것부터 가장 큰 것까지 필드를 정렬한 다음 가장 큰 필드의 정렬 요구 사항을 기반으로 전체 옵션에 대한 정렬 요구 사항을 도출합니다\(최대 최대 정렬은 8옥텟\). 이 접근 방식은 다음 예에 설명되어 있습니다.

```text
   Example 1
```

옵션 X에 길이가 8옥텟인 데이터 필드와 길이가 4옥텟인 데이터 필드가 필요한 경우 다음과 같이 배치됩니다.

```text
                                   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                                   | Option Type=X |Opt Data Len=12|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                         4-octet field                         |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                                                               |
   +                         8-octet field                         +
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

8옥텟 필드가 둘러싸는 헤더의 시작 부분에서 8의 배수 오프셋에서 시작되도록 하기 위한 정렬 요구 사항은 8n+2입니다. 이 하나의 옵션을 포함하는 전체 홉별 또는 대상 옵션 헤더는 다음과 같습니다.

```text
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |  Next Header  | Hdr Ext Len=1 | Option Type=X |Opt Data Len=12|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                         4-octet field                         |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                                                               |
   +                         8-octet field                         +
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

   Example 2
```

옵션 Y에 세 개의 데이터 필드\(길이 4옥텟 중 하나, 길이 2옥텟 중 하나, 길이 1옥텟 중 하나\)가 필요한 경우 다음과 같이 배치됩니다.

```text
                                                   +-+-+-+-+-+-+-+-+
                                                   | Option Type=Y |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |Opt Data Len=7 | 1-octet field |         2-octet field         |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                         4-octet field                         |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

4옥텟 필드가 둘러싸는 헤더의 시작 부분에서 4의 배수 오프셋에서 시작되도록 하기 위한 정렬 요구 사항은 4n+3입니다. 이 하나의 옵션을 포함하는 전체 홉별 또는 대상 옵션 헤더는 다음과 같습니다.

```text
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |  Next Header  | Hdr Ext Len=1 | Pad1 Option=0 | Option Type=Y |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |Opt Data Len=7 | 1-octet field |         2-octet field         |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                         4-octet field                         |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   | PadN Option=1 |Opt Data Len=2 |       0       |       0       |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

   Example 3
```

예제 1과 2의 X와 Y 옵션을 모두 포함하는 홉별 또는 대상 옵션 헤더는 먼저 표시된 옵션에 따라 다음 두 가지 형식 중 하나를 갖습니다.

```text
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |  Next Header  | Hdr Ext Len=3 | Option Type=X |Opt Data Len=12|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                         4-octet field                         |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                                                               |
   +                         8-octet field                         +
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   | PadN Option=1 |Opt Data Len=1 |       0       | Option Type=Y |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |Opt Data Len=7 | 1-octet field |         2-octet field         |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                         4-octet field                         |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   | PadN Option=1 |Opt Data Len=2 |       0       |       0       |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |  Next Header  | Hdr Ext Len=3 | Pad1 Option=0 | Option Type=Y |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |Opt Data Len=7 | 1-octet field |         2-octet field         |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                         4-octet field                         |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   | PadN Option=1 |Opt Data Len=4 |       0       |       0       |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |       0       |       0       | Option Type=X |Opt Data Len=12|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                         4-octet field                         |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                                                               |
   +                         8-octet field                         +
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

---
# **Security Considerations**

IPv6의 보안 기능은 인터넷 프로토콜 보안 아키텍처 \[RFC-2401\]에 설명되어 있습니다.

---
# **Acknowledgments**

저자는 IPng 작업 그룹, 엔드투엔드 프로토콜 연구 그룹 및 인터넷 커뮤니티 전체의 구성원이 제공한 많은 유용한 제안에 감사드립니다.

---
# **Authors' Addresses**

```text
   Stephen E. Deering
   Cisco Systems, Inc.
   170 West Tasman Drive
   San Jose, CA 95134-1706
   USA

   Phone: +1 408 527 8213
   Fax:   +1 408 527 8254
   EMail: deering@cisco.com

   Robert M. Hinden
   Nokia
   232 Java Drive
   Sunnyvale, CA 94089
   USA

   Phone: +1 408 990-2004
   Fax:   +1 408 743-5677
   EMail: hinden@iprg.nokia.com
```

---
# **References**

\[RFC-2401\] Kent, S. 및 R. Atkinson, "인터넷 프로토콜을 위한 보안 아키텍처", RFC 2401, 1998년 11월.

\[RFC-2402\] Kent, S. 및 R. Atkinson, "IP 인증 헤더", RFC 2402, 1998년 11월.

\[RFC-2406\] Kent, S. 및 R. Atkinson, "IP 캡슐화 보안 프로토콜\(ESP\)", RFC 2406, 1998년 11월.

\[ICMPv6\] Conta, A. 및 S. Deering, "IPv6\(인터넷 프로토콜 버전 6\)용 ICMP", RFC 2463, 1998년 12월.

\[추가\] Hinden, R. 및 S. Deering, "IP 버전 6 주소 지정 아키텍처", RFC 2373, 1998년 7월.

\[RFC-1981\] McCann, J., Mogul, J. 및 S. Deering, "경로 MTU

- IP 버전 6"에 대한 검색, RFC 1981, 1996년 8월.

```text
   [RFC-791]    Postel, J., "Internet Protocol", STD 5, RFC 791,
                September 1981.
```

\[RFC-1700\] Reynolds, J. 및 J. Postel, "할당된 번호", STD 2, RFC 1700, 1994년 10월. 참조: http://www.iana.org/numbers.html

```text
   [RFC-1661]   Simpson, W., "The Point-to-Point Protocol (PPP)", STD
                51, RFC 1661, July 1994.
```

---
# **CHANGES SINCE RFC-1883**

이 메모에는 RFC-1883에서 다음과 같은 변경 사항이 있습니다. 숫자는 변경된 Internet-Draft 버전을 식별합니다.

02\) 점보그램 및 점보 페이로드 옵션에 대한 모든 참조를 제거했습니다\(별도의 문서로 이동됨\).

02\) Flow Label 설명의 대부분을 섹션 6에서 \(신규\) 부록 A로 이동했습니다.

02\) 이제 부록 A에 있는 Flow Label 설명에서 Flow Label 필드의 크기가 24비트에서 20비트로 감소함에 따라 최대 Flow Label 값을 FFFFFF에서 FFFFF\(즉, "F" 하나 뺀 값\)로 수정했습니다.

02\) 이전 부록 A를 부록 B로 번호를 다시 매겼습니다.

02\) 이 사양과 IPsec 사양 간의 종속성 루프를 피하기 위해 보안 고려 사항 섹션의 문구를 변경했습니다.

02\) R. Hinden의 이메일 주소 및 회사 소속을 업데이트했습니다.

```text
        --------------------------------------------------------
```

01\) 섹션 3에서는 필드 이름 "Class"를 "Traffic Class"로 변경하고 크기를 4비트에서 8비트로 늘렸습니다. 트래픽 클래스 필드의 증가를 보상하기 위해 흐름 레이블 필드의 크기를 24비트에서 20비트로 줄였습니다.

01\) 섹션 4.1에서는 이 메모의 00 버전에서 실수로 교체되었던 인증 헤더와 ESP 헤더의 순서를 복원했습니다.

01\) 섹션 4.4에서는 Type 0 Routing 헤더에서 Strict/Loose Bit Map 필드와 엄격한 라우팅 기능을 삭제하고 Type 0 Routing 헤더에 포함될 수 있는 주소 수에 대한 제한을 제거했습니다\(23개 주소로 제한됨\). , 엄격한/느슨한 비트맵의 크기 때문입니다\).

01\) 섹션 5에서는 최소 IPv6 MTU를 576에서 1280옥텟으로 변경하고, 구성 가능한 MTU가 있는 링크\(예: PPP 링크\)가 최소 1500옥텟의 MTU를 갖도록 구성하라는 권장 사항을 추가했습니다.

01\) 섹션 5에서는 노드가 대상 리어셈블리 버퍼 크기에 대한 지식 없이 1500옥텟 이상으로 리어셈블되는 조각화된 패킷을 보내서는 안 된다는 요구 사항을 삭제하고 상위 계층 프로토콜이나 애플리케이션이 그렇게 하지 않아야 한다는 권장 사항으로 대체했습니다. .

01\) IPv4 경로 MTU 검색 사양\(RFC-1191\)에 대한 참조를 IPv6 경로 MTU 검색 사양\(RFC-1981\)으로 대체하고 경로 MTU 검색에 관한 섹션 5 끝의 참고 사항을 삭제했습니다. 이제 RFC-1981이 적용됩니다.

01\) 섹션 6에서 "기회적" 흐름 설정 사양을 삭제하고, 기회적으로 설정된 흐름 상태에 대한 최대 수명 6초에 대한 모든 참조를 제거했습니다.

01\) 7항에서 트래픽 클래스 필드의 내부 구조 및 의미에 대한 임시 설명을 삭제하고 해당 설명을 별도 문서로 제공하도록 명시했습니다.

```text
        --------------------------------------------------------
```

00\) 섹션 4에서는 ICMP 매개변수 문제 메시지에서 "인식할 수 없는 다음 헤더 유형이 발생했습니다"를 나타내도록 코드 값을 수정했습니다\(2에서 1로 변경됨\).

00\) 섹션 3의 Payload Length 필드와 섹션 4.3의 Jumbo Payload Length 필드에 대한 설명에서 확장 헤더가 페이로드 길이 카운트에 포함된다는 점을 더 명확하게 했습니다.

00\) 섹션 4.1에서 인증 헤더와 ESP 헤더의 순서를 바꿨습니다. \(참고: 이는 실수였으며 버전 01에서는 변경 사항이 취소되었습니다.\)

00\) 섹션 4.2에서는 옵션이 옵션 유형의 하위 5비트가 아닌 전체 8비트 옵션 유형으로 식별된다는 점을 더 명확하게 했습니다. 또한 홉별 옵션과 대상 옵션 헤더 모두에 동일한 옵션 유형 번호 지정 공간이 사용되도록 지정했습니다.

00\) 섹션 4.4에는 라우팅 헤더를 처리하는 노드가 너무 커서 다음 홉 링크에 맞지 않는 패킷에 대한 응답으로\(예를 들어 조각화를 수행하는 대신\) ICMP Packet Too Big 메시지를 보내야 한다는 문장이 추가되었습니다.

00\) IPv6 우선순위 필드의 이름을 "클래스"로 변경하고 섹션 7의 이전 우선순위 설명을 클래스 필드에 대한 설명으로 대체했습니다. 또한 섹션 6에 지정된 대로 동일한 흐름의 모든 패킷에 대해 동일하게 유지되어야 하는 필드 집합에서 이 필드를 제외했습니다.

00\) 섹션 8.1의 의사 헤더에서 "Payload Length" 필드의 이름을 "Upper-Layer Packet Length"로 변경했습니다. 또한 자체 길이 정보\(예: 점보그램이 아닌 UDP\)를 전달하는 프로토콜의 경우 의사 헤더에 사용되는 것은 IP 계층에서 파생된 길이가 아니라 상위 계층에서 파생된 길이임을 명확히 했습니다. .

00\) 상위 계층 프로토콜이 라우팅 헤더를 전달하는 수신 패킷에 응답할 때 수신된 라우팅 헤더가 인증되지 않는 한 응답 패킷에 라우팅 헤더의 역방향을 포함해서는 안 된다는 점을 지정하는 섹션 8.4를 추가했습니다.

00\) 일부 오타 및 문법 오류를 수정했습니다.

```text
    00) Authors' contact info updated.

        --------------------------------------------------------
```

---
# **Full Copyright Statement**

Copyright \(C\) The Internet Society \(1998\). 판권 소유.

이 문서와 그 번역본은 복사되어 타인에게 제공될 수 있으며, 이에 대해 설명하거나 설명하거나 구현을 지원하는 파생물은 어떤 종류의 제한 없이 전체적으로 또는 부분적으로 준비, 복사, 출판 및 배포될 수 있습니다. , 단, 위의 저작권 표시와 이 단락은 그러한 모든 사본 및 파생물에 포함됩니다. 그러나 이 문서 자체는 인터넷 표준 개발 목적으로 필요한 경우를 제외하고는 저작권 표시를 제거하거나 Internet Society 또는 기타 인터넷 조직에 대한 참조를 제거하는 등 어떤 식으로든 수정할 수 없습니다. 인터넷 표준 프로세스를 따르거나 영어 이외의 언어로 번역하는 데 필요한 대로 따라야 합니다.

위에서 부여된 제한된 권한은 영구적이며 Internet Society 또는 그 승계자 또는 양수인에 의해 취소되지 않습니다.

이 문서와 여기에 포함된 정보는 "있는 그대로" 제공되며 인터넷 사회 및 인터넷 공학 태스크포스는 여기에 포함된 정보의 사용이 상품성 또는 특정 목적에의 적합성에 대한 권리 또는 묵시적 보증을 침해하는 행위.
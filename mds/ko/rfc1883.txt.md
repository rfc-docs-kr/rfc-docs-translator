

```text
Network Working Group                             S. Deering, Xerox PARC
Request for Comments: 1883                  R.  Hinden, Ipsilon Networks
Category: Standards Track                                  December 1995

                  Internet Protocol, Version 6 (IPv6)
                             Specification
```

---
# **Status of this Memo**

이 문서는 인터넷 커뮤니티를 위한 인터넷 표준 추적 프로토콜을 지정하고 개선을 위한 토론 및 제안을 요청합니다. 이 프로토콜의 표준화 상태 및 상태에 대해서는 "Internet Official Protocol Standards"\(STD 1\) 최신판을 참조하십시오. 이 메모의 배포는 무제한입니다.

---
# **Abstract**

이 문서에서는 IP Next Generation 또는 IPng라고도 하는 인터넷 프로토콜\(IPv6\) 버전 6을 지정합니다.

---
# **Table of Contents**

```text
   1. Introduction..................................................3
   2. Terminology...................................................4
   3. IPv6 Header Format............................................5
   4. IPv6 Extension Headers........................................6
       4.1 Extension Header Order...................................8
       4.2 Options..................................................9
       4.3 Hop-by-Hop Options Header...............................11
       4.4 Routing Header..........................................13
       4.5 Fragment Header.........................................19
       4.6 Destination Options Header..............................24
       4.7 No Next Header..........................................25
   5. Packet Size Issues...........................................26
   6. Flow Labels..................................................28
   7. Priority.....................................................30
   8. Upper-Layer Protocol Issues..................................31
       8.1 Upper-Layer Checksums...................................31
       8.2 Maximum Packet Lifetime.................................32
       8.3 Maximum Upper-Layer Payload Size........................32
   Appendix A. Formatting Guidelines for Options...................33
   Security Considerations.........................................36
   Acknowledgments.................................................36
   Authors' Addresses..............................................36
   References......................................................37
```

---
## **1.  Introduction**

IP 버전 6\(IPv6\)은 IP 버전 4\(IPv4\) \[RFC-791\]의 후속으로 설계된 새로운 버전의 인터넷 프로토콜입니다. IPv4에서 IPv6으로의 변경 사항은 주로 다음 범주로 분류됩니다.

```text
      o  Expanded Addressing Capabilities
```

- IPv6은 IP 주소 크기를 32비트에서 128비트로 늘려 더 많은 수준의 주소 지정 계층 구조, 훨씬 더 많은 수의 주소 지정 가능한 노드 및 간단한 주소 자동 구성을 지원합니다. 멀티캐스트 주소에 "범위" 필드를 추가하면 멀티캐스트 라우팅의 확장성이 향상됩니다. 그리고 "애니캐스트 주소"라는 새로운 유형의 주소가 정의되어 노드 그룹 중 어느 하나로 패킷을 보내는 데 사용됩니다.

```text
      o  Header Format Simplification
```

- 패킷 처리의 일반적인 처리 비용을 줄이고 IPv6 헤더의 대역폭 비용을 제한하기 위해 일부 IPv4 헤더 필드가 삭제되거나 선택 사항이 되었습니다.

- o 확장 및 옵션에 대한 지원 개선

- IP 헤더 옵션이 인코딩되는 방식이 변경되어 전달 효율성이 향상되고, 옵션 길이에 대한 제한이 덜 엄격해지며, 향후 새로운 옵션 도입에 대한 유연성이 향상됩니다.

```text
      o  Flow Labeling Capability
```

- 기본이 아닌 서비스 품질 또는 "실시간" 서비스와 같이 발신자가 특수 처리를 요청하는 특정 트래픽 "흐름"에 속하는 패킷에 레이블을 지정할 수 있는 새로운 기능이 추가되었습니다.

- o 인증 및 개인 정보 보호 기능

- 인증, 데이터 무결성 및 \(선택 사항\) 데이터 기밀성을 지원하는 확장이 IPv6에 대해 지정됩니다.

이 문서에서는 기본 IPv6 헤더와 초기에 정의된 IPv6 확장 헤더 및 옵션을 지정합니다. 또한 패킷 크기 문제, 흐름 레이블 및 우선순위의 의미, 상위 계층 프로토콜에 대한 IPv6의 영향에 대해 논의합니다. IPv6 주소의 형식과 의미는 \[RFC-1884\]에 별도로 지정됩니다. 모든 IPv6 구현에 포함되어야 하는 ICMP의 IPv6 버전은 \[RFC-1885\]에 지정되어 있습니다.

---
## **2.  Terminology**

노드 - IPv6을 구현하는 장치입니다.

라우터 - 명시적으로 주소가 지정되지 않은 IPv6 패킷을 자신에게 전달하는 노드입니다. \[아래 참고 참조\].

호스트 - 라우터가 아닌 모든 노드. \[아래 참고 참조\].

상위 계층 - IPv6 바로 위의 프로토콜 계층입니다. 예를 들어 TCP 및 UDP와 같은 전송 프로토콜, ICMP와 같은 제어 프로토콜, OSPF와 같은 라우팅 프로토콜, IPX, AppleTalk 또는 IPv6 자체와 같은 IPv6를 통해 "터널링"되는\(즉, 캡슐화되는\) 인터넷 또는 하위 계층 프로토콜이 있습니다. .

링크 - 노드가 링크 계층, 즉 IPv6 바로 아래 계층에서 통신할 수 있는 통신 시설 또는 매체입니다. 예를 들면 이더넷\(단순 또는 브리지\)입니다. PPP 링크; X.25, 프레임 릴레이 또는 ATM 네트워크; IPv4 또는 IPv6 자체를 통한 터널과 같은 인터넷\(또는 그 이상\) 계층 "터널".

이웃 - 동일한 링크에 연결된 노드.

인터페이스 - 링크에 대한 노드의 연결입니다.

주소 - 인터페이스 또는 인터페이스 세트에 대한 IPv6 계층 식별자입니다.

패킷 - IPv6 헤더와 페이로드.

링크 MTU - 링크를 통해 한 조각으로 전달할 수 있는 최대 전송 단위, 즉 옥텟 단위의 최대 패킷 크기입니다.

경로 MTU - 소스 노드와 대상 노드 사이의 경로에 있는 모든 링크의 최소 링크 MTU입니다.

참고: 일반적이지는 않지만 여러 인터페이스가 있는 장치가 일부 인터페이스 세트\(전체보다 적은 수\)에서 도착하는 자체 목적지가 아닌 패킷을 전달하고 다음에서 도착하는 자체 목적지가 아닌 패킷을 삭제하도록 구성될 수 있습니다. 다른 인터페이스. 이러한 장치는 이전\(전달\) 인터페이스에서 패킷을 수신하고 이를 통해 이웃과 상호 작용할 때 라우터에 대한 프로토콜 요구 사항을 준수해야 합니다. 후자\(비전달\) 인터페이스에서 패킷을 수신하고 이를 통해 이웃과 상호 작용할 때 호스트에 대한 프로토콜 요구 사항을 준수해야 합니다.

---
## **3.  IPv6 Header Format**

```text
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |Version| Prio. |                   Flow Label                  |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |         Payload Length        |  Next Header  |   Hop Limit   |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                                                               |
   +                                                               +
   |                                                               |
   +                         Source Address                        +
   |                                                               |
   +                                                               +
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                                                               |
   +                                                               +
   |                                                               |
   +                      Destination Address                      +
   |                                                               |
   +                                                               +
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

   Version              4-bit Internet Protocol version number = 6.

   Prio.                4-bit priority value.  See section 7.

   Flow Label           24-bit flow label.  See section 6.
```

페이로드 길이 16비트 부호 없는 정수. 페이로드의 길이, 즉 IPv6 헤더 뒤의 나머지 패킷\(옥텟\)입니다. 0인 경우 페이로드 길이가 점보 페이로드 홉별 옵션으로 전달됨을 나타냅니다.

다음 헤더 8비트 선택기. IPv6 헤더 바로 뒤에 오는 헤더 유형을 식별합니다. IPv4 프로토콜 필드\[RFC-1700 et seq.\]와 동일한 값을 사용합니다.

홉 제한 8비트 부호 없는 정수입니다. 패킷을 전달하는 각 노드에 의해 1씩 감소됩니다. Hop Limit가 0으로 감소하면 패킷이 삭제됩니다.

소스 주소 패킷 발신자의 128비트 주소입니다. \[RFC-1884\]를 참조하세요.

대상 주소 의도된 패킷 수신자의 128비트 주소입니다\(라우팅 헤더가 있는 경우 최종 수신자가 아닐 수도 있음\). \[RFC-1884\] 및 섹션 4.4를 참조하세요.

---
## **4.  IPv6 Extension Headers**

IPv6에서는 선택적 인터넷 계층 정보가 패킷의 IPv6 헤더와 상위 계층 헤더 사이에 배치될 수 있는 별도의 헤더에 인코딩됩니다. 이러한 확장 헤더는 소수이며 각각 고유한 Next Header 값으로 식별됩니다. 이러한 예에 설명된 것처럼 IPv6 패킷은 0개, 1개 또는 그 이상의 확장 헤더를 전달할 수 있으며, 각각은 이전 헤더의 다음 헤더 필드로 식별됩니다.

```text
   +---------------+------------------------
   |  IPv6 header  | TCP header + data
   |               |
   | Next Header = |
   |      TCP      |
   +---------------+------------------------

   +---------------+----------------+------------------------
   |  IPv6 header  | Routing header | TCP header + data
   |               |                |
   | Next Header = |  Next Header = |
   |    Routing    |      TCP       |
   +---------------+----------------+------------------------

   +---------------+----------------+-----------------+-----------------
   |  IPv6 header  | Routing header | Fragment header | fragment of TCP
   |               |                |                 |  header + data
   | Next Header = |  Next Header = |  Next Header =  |
   |    Routing    |    Fragment    |       TCP       |
   +---------------+----------------+-----------------+-----------------
```

한 가지 예외를 제외하고, 패킷이 IPv6의 대상 주소 필드에 식별된 노드\(또는 멀티캐스트의 경우 각 노드 집합\)에 도달할 때까지 패킷 전달 경로를 따라 어떤 노드에서도 확장 헤더를 검사하거나 처리하지 않습니다. 머리글. 여기서 IPv6 헤더의 다음 헤더 필드에 대한 일반적인 역다중화는 모듈을 호출하여 첫 ​​번째 확장 헤더를 처리하거나 확장 헤더가 없는 경우 상위 계층 헤더를 처리합니다. 각 확장 헤더의 내용과 의미에 따라

다음 헤더로 진행하지 마세요. 따라서 확장 헤더는 패킷에 나타나는 순서대로 엄격하게 처리되어야 합니다. 예를 들어, 수신기는 특정 종류의 확장 헤더를 찾기 위해 패킷을 스캔하여 이전 헤더를 모두 처리하기 전에 해당 헤더를 처리해서는 안 됩니다.

이전 단락에서 언급한 예외는 홉별 옵션 헤더로, 소스 및 대상 노드를 포함하여 패킷 전달 경로를 따라 모든 노드에서 검사하고 처리해야 하는 정보를 전달합니다. 홉별 옵션 헤더가 있는 경우 IPv6 헤더 바로 뒤에 와야 합니다. 해당 존재는 IPv6 헤더의 다음 헤더 필드에 0 값으로 표시됩니다.

헤더 처리 결과 노드가 다음 헤더로 진행해야 하는데 현재 헤더의 Next Header 값을 노드가 인식하지 못하는 경우, 해당 패킷을 폐기하고 ICMP Parameter Problem 메시지를 소스로 보내야 한다. ICMP 코드 값 2\("인식할 수 없는 다음 헤더 유형이 발생했습니다"\)와 원본 패킷 내에서 인식할 수 없는 값의 오프셋을 포함하는 ICMP 포인터 필드를 포함하는 패킷입니다. 노드가 IPv6 헤더가 아닌 다른 헤더에서 다음 헤더 값이 0인 경우에도 동일한 조치를 취해야 합니다.

각 확장 헤더는 후속 헤더에 대해 8옥텟 정렬을 유지하기 위해 길이가 8옥텟의 정수 배수입니다. 각 확장 헤더 내의 다중 옥텟 필드는 자연 경계에 정렬됩니다. 즉, n 옥텟 너비의 필드는 n = 1, 2, 4 또는 8인 경우 헤더 시작 부분에서 n 옥텟의 정수 배수에 배치됩니다.

IPv6의 전체 구현에는 다음 확장 헤더 구현이 포함됩니다.

```text
           Hop-by-Hop Options
           Routing (Type 0)
           Fragment
           Destination Options
           Authentication
           Encapsulating Security Payload
```

처음 4개는 이 문서에 지정되어 있습니다. 마지막 두 개는 각각 \[RFC-1826\]과 \[RFC-1827\]에 지정되어 있습니다.

---
## **4.1  Extension Header Order**

동일한 패킷에 두 개 이상의 확장 헤더가 사용되는 경우 해당 헤더가 다음 순서로 나타나는 것이 좋습니다.

```text
           IPv6 header
           Hop-by-Hop Options header
           Destination Options header (note 1)
           Routing header
           Fragment header
           Authentication header (note 2)
           Encapsulating Security Payload header (note 2)
           Destination Options header (note 3)
           upper-layer header
```

- 참고 1: IPv6 대상 주소 필드에 나타나는 첫 번째 대상과 라우팅 헤더에 나열된 후속 대상에 의해 처리되는 옵션에 대한 것입니다.

- 참고 2: 인증 및 보안 페이로드 캡슐화 헤더의 상대적 순서에 관한 추가 권장 사항은 \[RFC-1827\]에 제공됩니다.

- 참고 3: 옵션은 패킷의 최종 목적지에서만 처리됩니다.

각 확장 헤더는 최대 두 번 발생해야 하는 대상 옵션 헤더를 제외하고 최대 한 번 발생해야 합니다\(라우팅 헤더 전에 한 번, 상위 계층 헤더 전에 한 번\).

상위 계층 헤더가 다른 IPv6 헤더인 경우\(IPv6가 IPv6를 통해 터널링되거나 캡슐화되는 경우\), 자체 확장 헤더가 뒤따를 수 있으며, 이는 별도로 동일한 순서 권장 사항이 적용됩니다.

다른 확장 헤더가 정의된 경우 위에 나열된 헤더와 관련된 순서 제약 조건을 지정해야 합니다.

IPv6 노드는 IPv6 헤더 바로 뒤에 나타나도록 제한되는 홉별 옵션 헤더를 제외하고 동일한 패킷에서 여러 번 발생하고 순서에 관계없이 확장 헤더를 수락하고 처리하려고 시도해야 합니다. 그럼에도 불구하고 IPv6 패킷의 소스는 후속 사양에서 해당 권장 사항을 수정할 때까지 위의 권장 순서를 따르는 것이 좋습니다.

---
## **4.2  Options**

현재 정의된 확장 헤더 중 두 개\(Hop-by-Hop 옵션 헤더 및 대상 옵션 헤더\)는 다음 형식의 가변 개수의 TLV\(유형 길이 값\)로 인코딩된 "옵션"을 전달합니다.

```text
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- - - - - - - - -
      |  Option Type  |  Opt Data Len |  Option Data
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- - - - - - - - -
```

- 옵션 유형 옵션 유형의 8비트 식별자입니다.

- Opt Data Len 8비트 부호 없는 정수. 이 옵션의 옵션 데이터 필드 길이\(옥텟\)입니다.

```text
      Option Data          Variable-length field.  Option-Type-specific
                           data.
```

헤더 내의 옵션 순서는 헤더에 나타나는 순서대로 엄격하게 처리되어야 합니다. 예를 들어, 수신자는 특정 종류의 옵션을 찾기 위해 헤더를 스캔하여 이전 옵션을 모두 처리하기 전에 해당 옵션을 처리해서는 안 됩니다.

옵션 유형 식별자는 처리 중인 IPv6 노드가 옵션 유형을 인식하지 못하는 경우 수행해야 하는 작업을 최상위 2비트가 지정하도록 내부적으로 인코딩됩니다.

- 00 - 이 옵션을 건너뛰고 헤더 처리를 계속합니다.

- 01 - 패킷을 폐기합니다.

- 10 - 패킷을 폐기하고 패킷의 대상 주소가 멀티캐스트 주소인지 여부에 관계없이 인식할 수 없는 옵션 유형을 가리키는 ICMP 매개변수 문제, 코드 2, 메시지를 패킷의 소스 주소로 보냅니다.

- 11 - 패킷을 폐기하고, 패킷의 대상 주소가 멀티캐스트 주소가 아닌 경우에만 ICMP 매개변수 문제, 코드 2, 메시지를 패킷의 소스 주소로 보내 인식할 수 없는 옵션 유형을 가리킵니다.

옵션 유형의 세 번째로 높은 비트는 해당 옵션의 옵션 데이터가 패킷의 최종 목적지로 가는 도중에 변경될 수 있는지 여부를 지정합니다. 패킷에 인증 헤더가 있는 경우 데이터가 도중에 변경될 수 있는 모든 옵션에 대해 패킷의 인증 값을 계산하거나 확인할 때 전체 옵션 데이터 필드는 값이 0인 옥텟으로 처리되어야 합니다.

```text
      0 - Option Data does not change en-route

      1 - Option Data may change en-route
```

개별 옵션에는 옵션 데이터 필드 내의 다중 옥텟 값이 자연 경계에 포함되도록 하기 위한 특정 정렬 요구 사항이 있을 수 있습니다. 옵션의 정렬 요구 사항은 xn+y 표기법을 사용하여 지정됩니다. 즉, 옵션 유형은 헤더 시작 부분부터 x 옥텟의 정수 배수에 y 옥텟을 더한 정수 배수로 나타나야 합니다. 예를 들어:

- 2n은 헤더 시작 부분에서 2옥텟 오프셋을 의미합니다. 8n+2는 헤더 시작 부분의 8옥텟 오프셋에 2옥텟을 더한 것을 의미합니다.

후속 옵션을 정렬하고 포함 헤더를 8옥텟의 배수 길이로 채우는 데 필요할 때 사용되는 두 가지 패딩 옵션이 있습니다. 모든 IPv6 구현에서는 이러한 패딩 옵션을 인식해야 합니다.

```text
   Pad1 option  (alignment requirement: none)

       +-+-+-+-+-+-+-+-+
       |       0       |
       +-+-+-+-+-+-+-+-+
```

-   메모! Pad1 옵션의 형식은 특별한 경우입니다. 즉, 길이 및 값 필드가 없습니다.

- Pad1 옵션은 헤더의 옵션 영역에 패딩 1옥텟을 삽입하는 데 사용됩니다. 패딩의 옥텟이 두 개 이상 필요한 경우 여러 개의 Pad1 옵션 대신 다음에 설명하는 PadN 옵션을 사용해야 합니다.

```text
   PadN option  (alignment requirement: none)

       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- - - - - - - - -
       |       1       |  Opt Data Len |  Option Data
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- - - - - - - - -
```

- PadN 옵션은 헤더의 옵션 영역에 2개 이상의 패딩 옥텟을 삽입하는 데 사용됩니다. N 옥텟의 패딩의 경우 Opt Data Len 필드에는 N-2 값이 포함되고 옵션 데이터는 N-2 0 값 옥텟으로 구성됩니다.

부록 A에는 새 옵션을 디자인하기 위한 형식 지정 지침이 포함되어 있습니다.

---
## **4.3  Hop-by-Hop Options Header**

홉별 옵션 헤더는 패킷 전달 경로를 따라 모든 노드에서 검사해야 하는 선택적 정보를 전달하는 데 사용됩니다. 홉별 옵션 헤더는 IPv6 헤더에서 다음 헤더 값 0으로 식별되며 형식은 다음과 같습니다.

```text
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |  Next Header  |  Hdr Ext Len  |                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+                               +
   |                                                               |
   .                                                               .
   .                            Options                            .
   .                                                               .
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

다음 헤더 8비트 선택기. 홉별 옵션 헤더 바로 뒤에 오는 헤더 유형을 식별합니다. IPv4 프로토콜 필드\[RFC-1700 et seq.\]와 동일한 값을 사용합니다.

Hdr Ext Len 8비트 부호 없는 정수. 길이

- 처음 8옥텟을 포함하지 않고 8옥텟 단위의 홉별 옵션 헤더입니다.

옵션 전체 홉별 옵션 헤더 길이가 8옥텟의 정수 배수가 되는 길이의 가변 길이 필드입니다. 섹션 4.2에 설명된 대로 하나 이상의 TLV 인코딩 옵션을 포함합니다.

섹션 4.2에 지정된 Pad1 및 PadN 옵션 외에도 다음 홉별 옵션이 정의됩니다.

```text
   Jumbo Payload option  (alignment requirement: 4n + 2)

                                       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                                       |      194      |Opt Data Len=4 |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |                     Jumbo Payload Length                      |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

       The Jumbo Payload option is used to send IPv6 packets with
       payloads longer than 65,535 octets.  The Jumbo Payload Length is
       the length of the packet in octets, excluding the IPv6 header but
       including the Hop-by-Hop Options header; it must be greater than
       65,535.  If a packet is received with a Jumbo Payload option
       containing a Jumbo Payload Length less than or equal to 65,535,
```

- ICMP 매개변수 문제 메시지\(코드 0\)는 잘못된 점보 페이로드 길이 필드의 상위 옥텟을 가리키는 패킷 소스로 전송되어야 합니다.

- IPv6 헤더의 페이로드 길이 필드는 점보 페이로드 옵션을 전달하는 모든 패킷에서 0으로 설정되어야 합니다. 유효한 점보 페이로드 옵션이 있고 0이 아닌 IPv6 페이로드 길이 필드가 있는 패킷이 수신된 경우 ICMP 매개변수 문제 메시지인 코드 0이 점보 페이로드 옵션의 옵션 유형 필드를 가리키는 패킷 소스로 전송되어야 합니다. .

- Fragment 헤더를 전달하는 패킷에는 Jumbo Payload 옵션을 사용하면 안 됩니다. 유효한 점보 페이로드 옵션이 포함된 패킷에서 조각 헤더가 발견되면 ICMP 매개변수 문제 메시지인 코드 0이 조각 헤더의 첫 번째 옥텟을 가리키는 패킷 소스로 전송되어야 합니다.

- 점보 페이로드 옵션을 지원하지 않는 구현은 링크 MTU가 65,575\(40옥텟의 IPv6 헤더 + 65,535옥텟의 페이로드\)보다 큰 링크에 대한 인터페이스를 가질 수 없습니다.

---
## **4.4  Routing Header**

라우팅 헤더는 IPv6 소스에서 패킷 대상으로 가는 도중에 "방문"할 하나 이상의 중간 노드를 나열하는 데 사용됩니다. 이 기능은 IPv4의 소스 경로 옵션과 매우 유사합니다. 라우팅 헤더는 바로 앞 헤더에서 다음 헤더 값 43으로 식별되며 형식은 다음과 같습니다.

```text
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |  Next Header  |  Hdr Ext Len  |  Routing Type | Segments Left |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                                                               |
   .                                                               .
   .                       type-specific data                      .
   .                                                               .
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

다음 헤더 8비트 선택기. 라우팅 헤더 바로 뒤에 오는 헤더 유형을 식별합니다. IPv4 프로토콜 필드\[RFC-1700 et seq.\]와 동일한 값을 사용합니다.

Hdr Ext Len 8비트 부호 없는 정수. 길이

- 처음 8옥텟을 포함하지 않고 8옥텟 단위의 라우팅 헤더입니다.

라우팅 유형 특정 라우팅 헤더 변형의 8비트 식별자입니다.

세그먼트 왼쪽 8비트 부호 없는 정수. 남은 경로 세그먼트 수, 즉 최종 목적지에 도달하기 전에 아직 방문해야 하는 명시적으로 나열된 중간 노드 수입니다.

유형별 데이터 라우팅 유형에 의해 결정되는 형식의 가변 길이 필드이며 전체 라우팅 헤더 길이가 8옥텟의 정수 배수가 되는 길이입니다.

수신된 패킷을 처리하는 동안 노드가 인식할 수 없는 라우팅 유형 값이 있는 라우팅 헤더를 발견하는 경우 노드의 필수 동작은 다음과 같이 왼쪽 세그먼트 필드의 값에 따라 달라집니다.

- 남은 세그먼트가 0인 경우 노드는 라우팅 헤더를 무시하고 패킷의 다음 헤더 처리를 진행해야 합니다. 해당 유형은 라우팅 헤더의 다음 헤더 필드로 식별됩니다.

- 남은 세그먼트가 0이 아닌 경우 노드는 패킷을 폐기하고 인식할 수 없는 라우팅 유형을 가리키는 ICMP 매개변수 문제, 코드 0, 메시지를 패킷의 소스 주소로 보내야 합니다.

유형 0 라우팅 헤더의 형식은 다음과 같습니다.

```text
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |  Next Header  |  Hdr Ext Len  | Routing Type=0| Segments Left |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |   Reserved    |             Strict/Loose Bit Map              |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                                                               |
   +                                                               +
   |                                                               |
   +                           Address[1]                          +
   |                                                               |
   +                                                               +
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                                                               |
   +                                                               +
   |                                                               |
   +                           Address[2]                          +
   |                                                               |
   +                                                               +
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   .                               .                               .
   .                               .                               .
   .                               .                               .
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                                                               |
   +                                                               +
   |                                                               |
   +                           Address[n]                          +
   |                                                               |
   +                                                               +
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

다음 헤더 8비트 선택기. 라우팅 헤더 바로 뒤에 오는 헤더 유형을 식별합니다. IPv4 프로토콜 필드\[RFC-1700 et seq.\]와 동일한 값을 사용합니다.

Hdr Ext Len 8비트 부호 없는 정수. 길이

- 처음 8옥텟을 포함하지 않고 8옥텟 단위의 라우팅 헤더입니다. Type 0 라우팅 헤더의 경우 Hdr Ext Len은 헤더에 있는 주소 수의 2배와 동일하며 46보다 작거나 같은 짝수여야 합니다.

```text
   Routing Type         0.
```

세그먼트 왼쪽 8비트 부호 없는 정수. 남은 경로 세그먼트 수, 즉 최종 목적지에 도달하기 전에 아직 방문해야 하는 명시적으로 나열된 중간 노드 수입니다. 최대 법적 값 = 23.

예약된 8비트 예약 필드입니다. 전송을 위해 0으로 초기화됩니다. 수신시 무시됩니다.

엄격한/느슨한 비트 맵

- 왼쪽에서 오른쪽으로 0부터 23까지 번호가 매겨진 24비트 비트맵. 경로의 각 세그먼트에 대해 다음 대상 주소가 이전 주소의 이웃이어야 하는지 여부를 나타냅니다. 1은 엄격함\(이웃이어야 함\)을 의미하고 0은 느슨함\(이웃일 필요가 없음\)을 의미합니다.

Address\[1..n\] 128비트 주소의 벡터이며 1부터 n까지 번호가 매겨져 있습니다.

멀티캐스트 주소는 유형 0의 라우팅 헤더 또는 유형 0의 라우팅 헤더를 전달하는 패킷의 IPv6 대상 주소 필드에 표시되어서는 안 됩니다.

엄격한/느슨한 비트 맵의 ​​비트 번호 0의 ​​값이 1인 경우 원래 패킷에 있는 IPv6 헤더의 대상 주소 필드는 원래 노드의 이웃을 식별해야 합니다. 비트 번호 0의 ​​값이 0이면 발신자는 모든 합법적인 비멀티캐스트 주소를 초기 대상 주소로 사용할 수 있습니다.

n보다 큰 번호가 지정된 비트\(여기서 n은 라우팅 헤더의 주소 수\)는 발신자에 의해 0으로 설정되고 수신자에 의해 무시되어야 합니다.

라우팅 헤더는 IPv6 헤더의 대상 주소 필드에서 식별된 노드에 도달할 때까지 검사되거나 처리되지 않습니다. 해당 노드에서 바로 앞 헤더의 다음 헤더 필드를 디스패치하면 라우팅 헤더 모듈이 호출됩니다. 라우팅 유형 0의 경우 다음 알고리즘을 수행합니다.

남은 세그먼트 = 0인 경우 {

- 라우팅 헤더의 다음 헤더 필드에 의해 유형이 식별되는 패킷의 다음 헤더 처리를 진행합니다. } 그렇지 않으면 Hdr Ext Len이 홀수이거나 46보다 큰 경우 { ICMP 매개변수 문제, 코드 0, 메시지를 소스로 보냅니다. Hdr Ext Len 필드를 가리키는 주소, 패킷 폐기 } else { Hdr Ext Len을 2로 나누어 라우팅 헤더의 주소 개수 n을 계산합니다.

왼쪽 세그먼트가 n보다 큰 경우 {

- ICMP 매개변수 문제, 코드 0, 메시지를 소스 주소로 보내고 Segments Left 필드를 가리키며 패킷을 폐기합니다. } else { Segments Left를 1씩 감소시킵니다. n에서 Segments Left를 빼서 주소 벡터에서 방문할 다음 주소의 인덱스인 i를 계산합니다.

- 주소 \[i\] 또는 IPv6 대상 주소가 멀티캐스트인 경우 { 패킷을 폐기합니다. } else { IPv6 대상 주소와 주소\[i\]를 교환합니다.

- Strict/Loose Bit 맵의 비트 i가 값 1을 갖고 새 대상 주소가 이 노드의 이웃 주소가 아닌 경우 { 소스 주소에 ICMP Destination Unreachable - Not a Neighbor 메시지를 보내고 패킷을 폐기합니다. } else if IPv6 Hop Limit가 1보다 작거나 같은 경우 { ICMP Time Exceeded - Hop Limit Exceeded in Transit 메시지를 소스 주소로 보내고 패킷을 폐기합니다. } else { Hop Limit를 1만큼 감소시킵니다.

```text
               resubmit the packet to the IPv6 module for transmission
               to the new destination
            }
         }
      }
   }
```

위 알고리즘의 효과에 대한 예로서 소스 노드 S가 대상 노드 D로 패킷을 전송하는 경우 라우팅 헤더를 사용하여 패킷이 중간 노드 I1, I2 및 I3을 통해 라우팅되도록 하는 경우를 고려하십시오. 전달 경로의 각 세그먼트에 있는 관련 IPv6 헤더 및 라우팅 헤더 필드의 값은 다음과 같습니다.

패킷이 S에서 I1으로 이동할 때:

```text
        Source Address = S                  Hdr Ext Len = 6
        Destination Address = I1            Segments Left = 3
                                            Address[1] = I2
        (if bit 0 of the Bit Map is 1,      Address[2] = I3
         S and I1 must be neighbors;        Address[3] = D
         this is checked by S)
```

패킷이 I1에서 I2로 이동할 때:

```text
        Source Address = S                  Hdr Ext Len = 6
        Destination Address = I2            Segments Left = 2
                                            Address[1] = I1
        (if bit 1 of the Bit Map is 1,      Address[2] = I3
         I1 and I2 must be neighbors;       Address[3] = D
         this is checked by I1)
```

패킷이 I2에서 I3으로 이동할 때:

```text
        Source Address = S                  Hdr Ext Len = 6
        Destination Address = I3            Segments Left = 1
                                            Address[1] = I1
        (if bit 2 of the Bit Map is 1,      Address[2] = I2
         I2 and I3 must be neighbors;       Address[3] = D
         this is checked by I2)
```

패킷이 I3에서 D로 이동할 때:

```text
        Source Address = S                  Hdr Ext Len = 6
        Destination Address = D             Segments Left = 0
                                            Address[1] = I1
        (if bit 3 of the Bit Map is 1,      Address[2] = I2
         I3 and D must be neighbors;        Address[3] = I3
         this is checked by I3)
```

---
## **4.5  Fragment Header**

조각 헤더는 IPv6 소스에서 경로 MTU에 맞는 것보다 큰 패킷을 대상으로 보내는 데 사용됩니다. \(참고: IPv4와 달리 IPv6의 조각화는 패킷 전달 경로에 있는 라우터가 아닌 소스 노드에 의해서만 수행됩니다. 섹션 5를 참조하십시오.\) 조각 헤더는 바로 앞 헤더에서 다음 헤더 값 44로 식별됩니다. 다음과 같은 형식을 갖습니다.

```text
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |  Next Header  |   Reserved    |      Fragment Offset    |Res|M|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                         Identification                        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

다음 헤더 8비트 선택기. 원본 패킷의 조각화 가능한 부분의 초기 헤더 유형을 식별합니다\(아래에 정의됨\). IPv4 프로토콜 필드\[RFC-1700 et seq.\]와 동일한 값을 사용합니다.

예약된 8비트 예약 필드입니다. 전송을 위해 0으로 초기화됩니다. 수신시 무시됩니다.

조각 오프셋 13비트 부호 없는 정수입니다. 원본 패킷의 조각화 가능 부분의 시작을 기준으로 이 헤더 뒤에 오는 데이터의 오프셋\(8옥텟 단위\)입니다.

Res 2비트 예약 필드입니다. 전송을 위해 0으로 초기화됩니다. 수신시 무시됩니다.

```text
   M flag               1 = more fragments; 0 = last fragment.

   Identification       32 bits.  See description below.
```

너무 커서 경로의 MTU에 맞지 않는 패킷을 대상으로 보내기 위해 소스 노드는 패킷을 조각으로 나누고 각 조각을 별도의 패킷으로 보내 수신기에서 재조립할 수 있습니다.

조각화될 모든 패킷에 대해 소스 노드는 식별 값을 생성합니다. 식별은 동일한 소스 주소와 대상 주소를 사용하여 최근\* 전송된 다른 조각난 패킷의 식별과 달라야 합니다. 라우팅 헤더가 있는 경우 해당 대상 주소는 최종 대상의 주소입니다.

- \* "최근"은 소스에서 대상까지의 전송 시간 및 소요 시간을 포함하여 패킷의 최대 예상 수명 내를 의미합니다.

- 동일한 패킷의 다른 조각과의 재조립을 기다리고 있습니다. 그러나 소스 노드가 최대 패킷 수명을 알 필요는 없습니다. 오히려 패킷을 조각화해야 할 때마다 증가하는 간단한 32비트 "랩 어라운드" 카운터로 식별 값을 유지함으로써 요구 사항을 충족할 수 있다고 가정합니다. 노드에 대해 단일 카운터를 유지할지 여러 카운터를 유지할지 여부는 구현 선택입니다\(예: 노드의 가능한 소스 주소 각각에 대해 하나씩 또는 각 활성\(소스 주소, 대상 주소\) 조합에 대해 하나씩\).

조각화되지 않은 초기의 대규모 패킷을 "원래 패킷"이라고 하며 그림과 같이 두 부분으로 구성된 것으로 간주됩니다.

```text
   original packet:

   +------------------+----------------------//-----------------------+
   |  Unfragmentable  |                 Fragmentable                  |
   |       Part       |                     Part                      |
   +------------------+----------------------//-----------------------+
```

- 조각화할 수 없는 부분은 IPv6 헤더와 대상으로 가는 도중 노드에서 처리해야 하는 모든 확장 헤더, 즉 라우팅 헤더가 있는 경우 라우팅 헤더까지의 모든 헤더로 구성되며, 그렇지 않으면 홉별 옵션 헤더로 구성됩니다. 존재하지 않으면 확장 헤더가 없습니다.

- 조각화 가능 부분은 패킷의 나머지 부분, 즉 최종 대상 노드에서만 처리해야 하는 확장 헤더와 상위 계층 헤더 및 데이터로 구성됩니다.

원본 패킷의 조각화 가능 부분은 조각으로 나누어지며, 각 조각은 마지막\("가장 오른쪽"\) 조각을 제외하고 길이가 8옥텟의 정수 배수입니다. 조각은 그림과 같이 별도의 "조각 패킷"으로 전송됩니다.

```text
   original packet:

   +------------------+--------------+--------------+--//--+----------+
   |  Unfragmentable  |    first     |    second    |      |   last   |
   |       Part       |   fragment   |   fragment   | .... | fragment |
   +------------------+--------------+--------------+--//--+----------+

   fragment packets:

   +------------------+--------+--------------+
   |  Unfragmentable  |Fragment|    first     |
   |       Part       | Header |   fragment   |
   +------------------+--------+--------------+

   +------------------+--------+--------------+
   |  Unfragmentable  |Fragment|    second    |
   |       Part       | Header |   fragment   |
   +------------------+--------+--------------+
                         o
                         o
                         o
   +------------------+--------+----------+
   |  Unfragmentable  |Fragment|   last   |
   |       Part       | Header | fragment |
   +------------------+--------+----------+
```

각 조각 패킷은 다음으로 구성됩니다.

- \(1\) 원본 IPv6 헤더의 페이로드 길이가 이 조각 패킷의 길이만 포함하도록 변경된 원본 패킷의 조각화할 수 없는 부분\(IPv6 헤더 자체의 길이 제외\)과 마지막 패킷의 다음 헤더 필드 조각화할 수 없는 부분의 헤더가 44로 변경되었습니다.

- \(2\) 다음을 포함하는 조각 헤더:

- 원본 패킷의 조각화 가능한 부분의 첫 번째 헤더를 식별하는 다음 헤더 값입니다.

- 원본 패킷의 조각화 가능한 부분의 시작을 기준으로 조각의 오프셋을 8옥텟 단위로 포함하는 조각 오프셋입니다. 첫 번째\("가장 왼쪽"\) 조각의 조각 오프셋은 0입니다.

조각이 마지막 조각인 경우 M 플래그 값은 0입니다.

- \("가장 오른쪽"\) 1개, 그렇지 않으면 M 플래그 값 1.

- 원본 패킷에 대해 생성된 식별 값입니다.

-\(3\) 조각 자체.

결과 조각 패킷이 패킷 대상 경로의 MTU 내에 맞도록 조각의 길이를 선택해야 합니다.

대상에서 조각 패킷은 그림과 같이 조각화되지 않은 원래 형식으로 재조립됩니다.

```text
   reassembled original packet:

   +------------------+----------------------//------------------------+
   |  Unfragmentable  |                 Fragmentable                   |
   |       Part       |                     Part                       |
   +------------------+----------------------//------------------------+
```

재조립에는 다음 규칙이 적용됩니다.

- 원본 패킷은 동일한 소스 주소, 대상 주소 및 조각 ID를 가진 조각 패킷에서만 재조립됩니다.

- 재조립된 패킷의 Unfragmentable Part는 첫 번째 조각 패킷\(즉, 조각 오프셋이 0인 패킷\)의 조각 헤더까지의 모든 헤더로 구성되며 다음 두 가지 변경 사항이 있습니다.

- Unfragmentable Part의 마지막 헤더의 Next Header 필드는 첫 번째 조각의 Fragment 헤더의 Next Header 필드에서 가져옵니다.

- 재조립된 패킷의 페이로드 길이는 조각화할 수 없는 부분의 길이와 마지막 조각의 길이 및 오프셋으로부터 계산됩니다. 예를 들어, 재조립된 원본 패킷의 페이로드 길이를 계산하는 공식은 다음과 같습니다.

```text
           PL.orig = PL.first - FL.first - 8 + (8 * FO.last) + FL.last
```

어디

- PL.orig = 재조립된 패킷의 페이로드 길이 필드입니다. PL.first = 첫 번째 조각 패킷의 페이로드 길이 필드입니다. FL.first = 첫 번째 조각 패킷의 조각 헤더 다음에 나오는 조각의 길이입니다. FO.last = 마지막 조각 패킷의 조각 헤더에 있는 조각 오프셋 필드입니다. FL.last = 마지막 조각 패킷의 조각 헤더 다음에 나오는 조각의 길이입니다.

- 재조립된 패킷의 조각화 가능 부분은 각 조각 패킷의 조각 헤더 다음에 나오는 조각으로 구성됩니다. 각 조각의 길이는 패킷의 페이로드 길이에서 IPv6 헤더와 조각 자체 사이의 헤더 길이를 빼서 계산됩니다. 조각화 가능 부분의 상대 위치는 조각 오프셋 값에서 계산됩니다.

- Fragment 헤더는 최종 재조립된 패킷에 존재하지 않습니다.

조각난 패킷을 재조립할 때 다음과 같은 오류 조건이 발생할 수 있습니다.

- 해당 패킷의 처음 도착한 조각을 수신한 후 60초 이내에 패킷 재조립을 완료하기에 불충분한 조각이 수신된 경우 해당 패킷의 재조립을 포기해야 하며 해당 패킷에 대해 수신된 모든 조각을 폐기해야 합니다. 첫 번째 조각\(즉, 조각 오프셋이 0인 조각\)이 수신된 경우 ICMP 시간 초과 - 조각 재조립 시간 초과 메시지가 해당 조각의 소스로 전송되어야 합니다.

- 조각 패킷의 페이로드 길이 필드에서 파생된 조각의 길이가 8옥텟의 배수가 아니고 해당 조각의 M 플래그가 1인 경우 해당 조각은 폐기되어야 하며 ICMP 매개변수 문제, 코드 0, 메시지는 조각 패킷의 페이로드 길이 필드를 가리키는 조각 소스로 전송되어야 합니다.

- 조각의 길이와 오프셋이 해당 조각에서 재조립된 패킷의 페이로드 길이가 65,535옥텟을 초과하는 경우 해당 조각은 폐기되어야 하며 ICMP 매개변수 문제\(코드 0\) 메시지가 소스로 전송되어야 합니다. 조각 패킷의 조각 오프셋 필드를 가리키는 조각입니다.

다음 조건은 발생할 것으로 예상되지 않지만 발생하더라도 오류로 간주되지 않습니다.

- 동일한 원본 패킷의 여러 조각에 대한 조각 헤더 앞에 있는 헤더의 수와 내용이 다를 수 있습니다. 각 조각 패킷의 조각 헤더 앞에 있는 헤더가 무엇이든 패킷이 도착할 때 재조립을 위해 조각을 대기열에 넣기 전에 처리됩니다. 오프셋 0 조각 패킷의 헤더만 리어셈블된 패킷에 유지됩니다.

- 동일한 원본 패킷의 여러 조각에 대한 조각 헤더의 다음 헤더 값이 다를 수 있습니다. 리어셈블리에는 오프셋 0 조각 패킷의 값만 사용됩니다.

---
## **4.6  Destination Options Header**

대상 옵션 헤더는 패킷의 대상 노드에서만 검사해야 하는 선택적 정보를 전달하는 데 사용됩니다. 대상 옵션 헤더는 바로 앞 헤더의 다음 헤더 값 60으로 식별되며 형식은 다음과 같습니다.

```text
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |  Next Header  |  Hdr Ext Len  |                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+                               +
   |                                                               |
   .                                                               .
   .                            Options                            .
   .                                                               .
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

다음 헤더 8비트 선택기. 대상 옵션 헤더 바로 뒤에 오는 헤더 유형을 식별합니다. IPv4 프로토콜 필드\[RFC-1700 et seq.\]와 동일한 값을 사용합니다.

Hdr Ext Len 8비트 부호 없는 정수. 길이

- 처음 8옥텟을 제외하고 8옥텟 단위의 대상 옵션 헤더입니다.

옵션 전체 대상 옵션 헤더 길이가 8옥텟의 정수 배수가 되는 길이의 가변 길이 필드입니다. 섹션 4.2에 설명된 대로 하나 이상의 TLV 인코딩 옵션을 포함합니다.

이 문서에 정의된 유일한 대상 옵션은 섹션 4.2에 지정된 Pad1 및 PadN 옵션입니다.

IPv6 패킷에서 선택적 대상 정보를 인코딩하는 방법에는 두 가지가 있습니다. 대상 옵션 헤더의 옵션 또는 별도의 확장 헤더입니다. Fragment 헤더와 Authentication 헤더는 후자 접근 방식의 예입니다. 사용할 수 있는 접근 방식은 선택적 정보를 이해하지 못하는 대상 노드에 대해 원하는 작업에 따라 다릅니다.

- o 원하는 작업이 대상 노드가 패킷을 폐기하는 것이고, 패킷의 대상 주소가 멀티캐스트 주소가 아닌 경우에만 ICMP 인식할 수 없는 유형 메시지를 패킷의 소스 주소로 보내는 것이라면 정보는 다음 중 하나로 인코딩될 수 있습니다. 별도의 헤더 또는 옵션으로

- 옵션 유형의 최상위 2비트 값이 11인 대상 옵션 헤더입니다. 선택은 더 적은 옥텟을 사용하거나 더 나은 정렬 또는 더 효율적인 구문 분석을 생성하는 요소에 따라 달라질 수 있습니다.

- o 다른 작업이 필요한 경우 해당 정보는 옵션 유형의 최상위 2비트 값이 00, 01 또는 10인 대상 옵션 헤더의 옵션으로 인코딩되어 원하는 작업을 지정해야 합니다\(섹션 4.2 참조\). \).

---
## **4.7 No Next Header**

IPv6 헤더 또는 확장 헤더의 다음 헤더 필드 값 59는 해당 헤더 뒤에 아무것도 없음을 나타냅니다. IPv6 헤더의 페이로드 길이 필드가 다음 헤더 필드에 59가 포함된 헤더 끝을 지나 옥텟이 있음을 나타내는 경우 해당 옥텟은 무시되어야 하며 패킷이 전달되는 경우 변경되지 않은 채 전달되어야 합니다.

---
## **5. Packet Size Issues**

IPv6에서는 인터넷의 모든 링크에 576옥텟 이상의 MTU가 필요합니다. 576옥텟 패킷을 하나로 전달할 수 없는 링크에서는 링크별 조각화 및 재조립이 IPv6 아래 계층에서 제공되어야 합니다.

노드가 직접 연결된 각 링크에서 노드는 해당 링크의 MTU만큼 큰 패킷을 받아들일 수 있어야 합니다. 구성 가능한 MTU가 있는 링크\(예: PPP 링크 \[RFC-1661\]\)는 최소 576옥텟의 MTU를 갖도록 구성되어야 합니다. 조각화를 발생시키지 않고 가능한 캡슐화\(예: 터널링\)를 수용하려면 더 큰 MTU를 구성하는 것이 좋습니다.

MTU가 576옥텟보다 큰 경로를 검색하고 활용하려면 IPv6 노드에서 경로 MTU 검색 \[RFC-1191\]을 구현하는 것이 좋습니다. 그러나 최소 IPv6 구현\(예: 부팅 ROM\)에서는 576옥텟 이하의 패킷 전송으로 제한하고 경로 MTU 검색 구현을 생략할 수 있습니다.

경로의 MTU보다 큰 패킷을 전송하기 위해 노드는 IPv6 Fragment 헤더를 사용하여 소스에서 패킷을 조각화하고 대상에서 재조립할 수 있습니다. 그러나 측정된 경로 MTU\(즉, 576옥텟까지\)에 맞게 패킷을 조정할 수 있는 애플리케이션에서는 이러한 조각화를 사용하지 않는 것이 좋습니다.

노드는 리어셈블리 후 IPv6 헤더를 포함하여 최대 1500옥텟 크기의 조각화된 패킷을 수용할 수 있어야 합니다. 노드는 1500옥텟 이상으로 재조립되는 조각화된 패킷을 허용할 수 있습니다. 그러나 노드는 대상이 해당 크기의 패킷을 재조립할 수 있다는 명시적인 지식이 없는 한 1500옥텟보다 큰 크기로 재조립되는 조각을 보내서는 안 됩니다.

IPv4 목적지로 전송되는 IPv6 패킷\(즉, IPv6에서 IPv4로 변환되는 패킷\)에 대한 응답으로, 원래 IPv6 노드는 576 미만의 Next-Hop MTU를 보고하는 ICMP Packet Too Big 메시지를 수신할 수 있습니다. 이 경우 IPv6 노드는 후속 패킷의 크기를 576 미만으로 줄일 필요는 없지만 IPv6-IPv4 변환 라우터가 결과에 사용할 적절한 식별 값을 얻을 수 있도록 해당 패킷에 조각 헤더를 포함해야 합니다. IPv4 조각. 이는 페이로드를 528옥텟\(IPv6 헤더의 경우 576 - 40, 조각 헤더의 경우 8\)으로 줄여야 하며, 추가 확장 헤더를 사용하는 경우에는 여전히 더 작아야 함을 의미합니다.

- 참고: 호스트가 대상이 자신과 동일한 링크에 연결되어 있다고 "생각"하는 경우에도 경로 MTU 검색을 수행해야 합니다.

- 참고: IPv4와 달리 IPv6에서는 경로 MTU 검색을 수행하기 위해 패킷 헤더에 "조각화 안 함" 플래그를 설정할 필요가 없습니다. 이는 모든 IPv6 패킷의 암시적 속성입니다. 또한 MTU "고원" 테이블 사용과 관련된 RFC-1191 절차 부분은 IPv6에 적용되지 않습니다. "데이터그램이 너무 큼" 메시지의 IPv6 버전은 항상 사용할 정확한 MTU를 식별하기 때문입니다.

---
## **6.  Flow Labels**

IPv6 헤더의 24비트 흐름 레이블 필드는 기본이 아닌 서비스 품질 또는 "실시간" 서비스와 같이 IPv6 라우터의 특수 처리를 요청하는 패킷에 레이블을 지정하기 위해 소스에서 사용할 수 있습니다. 이 글을 쓰는 시점에서 IPv6의 이러한 측면은 여전히 ​​실험적이며 인터넷의 흐름 지원에 대한 요구 사항이 더욱 명확해짐에 따라 변경될 수 있습니다. Flow Label 필드 기능을 지원하지 않는 호스트나 라우터에서는 패킷을 보낼 때 해당 필드를 0으로 설정하고, 패킷을 전달할 때 해당 필드를 그대로 전달하고, 패킷을 받을 때 해당 필드를 무시해야 합니다.

흐름은 특정 소스에서 소스가 중간 라우터의 특별한 처리를 원하는 특정\(유니캐스트 또는 멀티캐스트\) 대상으로 전송되는 일련의 패킷입니다. 이러한 특수 처리의 특성은 리소스 예약 프로토콜과 같은 제어 프로토콜 또는 홉별 옵션과 같은 흐름 패킷 자체 내의 정보를 통해 라우터에 전달될 수 있습니다. 그러한 제어 프로토콜이나 옵션에 대한 세부 사항은 이 문서의 범위를 벗어납니다.

소스에서 대상까지 여러 활성 흐름이 있을 수 있을 뿐만 아니라 어떤 흐름과도 연결되지 않은 트래픽이 있을 수 있습니다. 흐름은 소스 주소와 0이 아닌 흐름 레이블의 조합으로 고유하게 식별됩니다. 흐름에 속하지 않는 패킷은 흐름 레이블 0을 갖습니다.

흐름 레이블은 흐름의 소스 노드에 의해 흐름에 할당됩니다. 새로운 흐름 레이블은 1에서 FFFFFF 16진수 범위에서 \(의사\) 무작위로 균일하게 선택되어야 합니다. 무작위 할당의 목적은 흐름과 관련된 상태를 조회하기 위해 라우터에서 해시 키로 사용하기에 적합한 흐름 레이블 필드 내의 비트 세트를 만드는 것입니다.

동일한 흐름에 속하는 모든 패킷은 동일한 소스 주소, 대상 주소, 우선 순위 및 흐름 레이블을 사용하여 전송되어야 합니다. 해당 패킷 중 하나라도 홉별 옵션 헤더를 포함하는 경우 해당 패킷은 모두 동일한 홉별 옵션 헤더 콘텐츠\(홉별 옵션 헤더의 다음 헤더 필드 제외\)로 시작되어야 합니다. 해당 패킷 중 하나라도 라우팅 헤더를 포함하는 경우 라우팅 헤더를 포함하여 모든 확장 헤더에서 동일한 내용으로 시작되어야 합니다\(라우팅 헤더의 다음 헤더 필드 제외\). 이러한 조건이 충족되는지 확인하기 위해 라우터 또는 대상이 허용되지만 필수는 아닙니다. 위반이 감지되면 흐름 레이블 필드의 상위 옥텟\(즉, IPv6 패킷 내의 오프셋 1\)을 가리키는 ICMP 매개 변수 문제 메시지 코드 0을 통해 소스에 보고되어야 합니다.

라우터는 제어 프로토콜, 홉별 옵션 또는 기타 수단을 통해 명시적인 흐름 설정 정보가 제공되지 않은 경우에도 모든 흐름에 대한 흐름 처리 상태를 "기회적으로" 설정할 수 있습니다. 예를 들어, 알 수 없는 0이 아닌 흐름 레이블이 있는 특정 소스로부터 패킷을 수신하면 라우터는 마치 흐름 레이블이 0인 것처럼 IPv6 헤더와 필요한 확장 헤더를 처리할 수 있습니다. 해당 처리에는 다음 홉 인터페이스 결정과 홉별 옵션 업데이트, 라우팅 헤더의 포인터 및 주소 전진, 우선 순위 필드를 기반으로 패킷을 대기열에 넣는 방법 결정과 같은 기타 작업이 포함될 수 있습니다. . 그런 다음 라우터는 해당 처리 단계의 결과를 "기억"하고 소스 주소와 흐름 레이블을 캐시 키로 사용하여 해당 정보를 캐시하도록 선택할 수 있습니다. 동일한 소스 주소와 흐름 레이블을 가진 후속 패킷은 이전 단락의 요구 사항에 따라 흐름에 표시된 첫 번째 패킷에서 변경되지 않은 것으로 가정할 수 있는 모든 필드를 검사하는 대신 캐시된 정보를 참조하여 처리될 수 있습니다.

이전 단락에서 설명한 대로 기회적으로 설정된 캐시된 흐름 처리 상태는 동일한 흐름의 패킷이 계속 도착하는지 여부에 관계없이 설정된 후 6초 이내에 삭제되어야 합니다. 캐시된 상태가 삭제된 후 동일한 소스 주소와 흐름 레이블을 가진 다른 패킷이 도착하면 패킷은 전체 정상적인 처리\(플로우 레이블이 0인 것처럼\)를 거치게 되며, 이로 인해 캐시된 흐름 상태가 다시 생성될 수 있습니다. 그 흐름.

예를 들어 제어 프로토콜이나 홉별 옵션에 의해 명시적으로 설정된 흐름 처리 상태의 수명은 명시적 설정 메커니즘 사양의 일부로 지정되어야 합니다. 6초를 초과할 수 있습니다.

소스는 해당 흐름 레이블의 이전 사용을 위해 설정되었을 수 있는 흐름 처리 상태의 수명 내에 새 흐름에 대한 흐름 레이블을 재사용해서는 안 됩니다. 수명이 6초인 흐름 처리 상태는 모든 흐름에 대해 기회적으로 설정될 수 있으므로 한 흐름의 마지막 패킷과 동일한 흐름 레이블을 사용하는 새 흐름의 첫 번째 패킷 사이의 최소 간격은 6초입니다. 흐름 상태 수명이 더 긴 명시적인 설정 흐름에 사용되는 흐름 레이블은 새 흐름에 재사용되기 전에 긴 수명 동안 사용되지 않은 상태로 유지되어야 합니다.

노드가 중지되었다가 다시 시작될 때\(예: "충돌"의 결과\) 수명이 아직 만료되지 않은 이전 흐름에 사용했을 수 있는 흐름 레이블을 사용하지 않도록 주의해야 합니다. 이는 충돌 시 기억될 수 있도록 안정적인 저장소에 흐름 레이블 사용량을 기록하거나 이전에 설정된 흐름의 가능한 최대 수명이 만료될 때까지\(최소 6초, 명시적인 경우 그 이상\) 흐름 레이블 사용을 자제함으로써 수행할 수 있습니다.

수명이 더 긴 흐름 설정 메커니즘이 사용되었을 수 있습니다. 노드 재부팅을 위한 최소 시간이 알려진 경우\(보통 6초 이상\) 흐름 레이블 할당을 시작하기 전에 필요한 대기 기간에서 해당 시간을 공제할 수 있습니다.

모든 또는 대부분의 패킷이 흐름에 속해야 한다는 요구 사항은 없습니다. 즉, 0이 아닌 흐름 레이블을 전달해야 합니다. 이 관찰은 프로토콜 설계자와 구현자가 달리 가정하지 않도록 상기시키기 위해 여기에 배치되었습니다. 예를 들어, 대부분의 패킷이 흐름에 속하는 경우에만 성능이 적절한 라우터를 설계하거나 흐름에 속한 패킷에서만 작동하는 헤더 압축 방식을 설계하는 것은 현명하지 않습니다.

---
## **7.  Priority**

IPv6 헤더의 4비트 우선 순위 필드를 통해 소스는 동일한 소스의 다른 패킷과 관련하여 해당 패킷의 원하는 배달 우선 순위를 식별할 수 있습니다. 우선 순위 값은 두 가지 범위로 나뉩니다. 값 0\~7은 소스가 정체 제어를 제공하는 트래픽, 즉 TCP 트래픽과 같이 정체에 응답하여 "백오프"하는 트래픽의 우선 순위를 지정하는 데 사용됩니다. 8부터 15까지의 값은 정체에 대한 응답으로 백오프하지 않는 트래픽의 우선순위를 지정하는 데 사용됩니다\(예: "실시간" 패킷이 일정한 속도로 전송됨\).

혼잡 제어 트래픽의 경우 특정 애플리케이션 범주에 대해 다음 우선 순위 값이 권장됩니다.

```text
         0 - uncharacterized traffic
         1 - "filler" traffic (e.g., netnews)
         2 - unattended data transfer (e.g., email)
         3 - (reserved)
         4 - attended bulk transfer (e.g., FTP, NFS)
         5 - (reserved)
         6 - interactive traffic (e.g., telnet, X)
         7 - internet control traffic (e.g., routing protocols, SNMP)
```

혼잡이 제어되지 않는 트래픽의 경우 혼잡 상황\(예: 고화질 비디오 트래픽\)에서 발신자가 폐기할 의사가 가장 높은 패킷에는 가장 낮은 우선 순위 값\(8\)을 사용해야 하며, 가장 높은 값\(15\)을 사용해야 합니다. \)은 발신자가 폐기할 의사가 가장 없는 패킷\(예: 저충실도 오디오 트래픽\)에 사용해야 합니다. 혼잡 제어 우선순위와 비혼잡 제어 우선순위 사이에는 상대적인 순서가 암시되어 있지 않습니다.

---
## **8. Upper-Layer Protocol Issues**
---
## **8.1 Upper-Layer Checksums**

체크섬 계산에 IP 헤더의 주소를 포함하는 모든 전송 또는 기타 상위 계층 프로토콜은 IPv6에서 사용하도록 수정되어 32비트 IPv4 주소 대신 128비트 IPv6 주소를 포함해야 합니다. 특히 다음 그림은 IPv6에 대한 TCP 및 UDP "의사 헤더"를 보여줍니다.

```text
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                                                               |
   +                                                               +
   |                                                               |
   +                         Source Address                        +
   |                                                               |
   +                                                               +
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                                                               |
   +                                                               +
   |                                                               |
   +                      Destination Address                      +
   |                                                               |
   +                                                               +
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                         Payload Length                        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                      zero                     |  Next Header  |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

- o 패킷에 라우팅 헤더가 포함된 경우 의사 헤더에 사용된 대상 주소는 최종 대상 주소입니다. 원래 노드에서 해당 주소는 라우팅 헤더의 마지막 요소에 있습니다. 수신자에서 해당 주소는 IPv6 헤더의 대상 주소 필드에 있습니다.

- o 의사 헤더의 다음 헤더 값은 상위 계층 프로토콜을 식별합니다\(예: TCP의 경우 6, UDP의 경우 17\). IPv6 헤더와 상위 계층 헤더 사이에 확장 헤더가 있는 경우 IPv6 헤더의 Next Header 값과 다릅니다.

- o 의사 헤더에 사용되는 페이로드 길이는 상위 계층 헤더를 포함한 상위 계층 패킷의 길이입니다. IPv6 헤더\(또는

- 점보 페이로드 옵션\) IPv6 헤더와 상위 계층 헤더 사이에 확장 헤더가 있는 경우.

- o IPv4와 달리 UDP 패킷이 IPv6 노드에서 시작되는 경우 UDP 체크섬은 선택 사항이 아닙니다. 즉, UDP 패킷이 발생할 때마다 IPv6 노드는 패킷과 의사 헤더에 대해 UDP 체크섬을 계산해야 하며, 계산 결과가 0인 경우 UDP 헤더에 배치하기 위해 16진수 FFFF로 변경해야 합니다. . IPv6 수신자는 체크섬이 0인 UDP 패킷을 삭제해야 하며 오류를 기록해야 합니다.

ICMP \[RFC-1885\]의 IPv6 버전은 체크섬 계산에 위의 의사 헤더를 포함합니다. 이는 체크섬에 의사 헤더가 포함되지 않은 ICMP IPv4 버전의 변경 사항입니다. 변경 이유는 IPv4와 달리 인터넷 계층 체크섬이 적용되지 않는 IPv6 헤더 필드의 잘못된 전달이나 손상으로부터 ICMP를 보호하기 위한 것입니다. ICMP 의사 헤더의 다음 헤더 필드에는 ICMP의 IPv6 버전을 식별하는 값 58이 포함되어 있습니다.

---
## **8.2 Maximum Packet Lifetime**

IPv4와 달리 IPv6 노드는 최대 패킷 수명을 적용할 필요가 없습니다. 이것이 IPv6에서 IPv4 "Time to Live" 필드의 이름이 "Hop Limit"로 변경된 이유입니다. 실제로 패킷 수명을 제한하는 요구 사항을 준수하는 IPv4 구현은 거의 없으므로 이는 실제로 변경되지 않습니다. 패킷 수명을 제한하기 위해 인터넷 계층\(IPv4 또는 IPv6\)에 의존하는 모든 상위 계층 프로토콜은 더 이상 사용되지 않는 패킷을 감지하고 삭제하기 위한 자체 메커니즘을 제공하도록 업그레이드되어야 합니다.

---
## **8.3 Maximum Upper-Layer Payload Size**

상위 계층 데이터에 사용할 수 있는 최대 페이로드 크기를 계산할 때 상위 계층 프로토콜은 IPv4 헤더에 비해 IPv6 헤더의 더 큰 크기를 고려해야 합니다. 예를 들어 IPv4에서 TCP의 MSS 옵션은 최대 패킷 크기\(기본값 또는 경로 MTU 검색을 통해 학습된 값\)에서 40옥텟\(최소 길이 IPv4 헤더의 경우 20옥텟, 최소 길이의 경우 20옥텟\)을 뺀 값으로 계산됩니다. TCP 헤더\). IPv6를 통해 TCP를 사용하는 경우 MSS는 최대 패킷 크기에서 60옥텟을 뺀 값으로 계산되어야 합니다. 왜냐하면 최소 길이 IPv6 헤더\(즉, 확장 헤더가 없는 IPv6 헤더\)가 최소 길이 IPv4 헤더보다 20옥텟 길기 때문입니다.

---
# **Appendix A. Formatting Guidelines for Options**

이 부록은 섹션 4.2에 설명된 대로 홉별 옵션 헤더 또는 대상 옵션 헤더에 사용할 새 옵션을 설계할 때 필드를 배치하는 방법에 대한 몇 가지 조언을 제공합니다. 이러한 지침은 다음과 같은 가정을 기반으로 합니다.

- o 한 가지 바람직한 기능은 옵션의 옵션 데이터 영역 내의 모든 다중 옥텟 필드가 자연 경계에 정렬된다는 것입니다. 즉, 너비 n 옥텟의 필드는 홉 시작부터 n 옥텟의 정수배에 배치되어야 합니다. n = 1, 2, 4 또는 8인 경우 홉별 또는 대상 옵션 헤더.

- o 또 다른 바람직한 기능은 홉별\(Hop-by-Hop\) 또는 대상 옵션 헤더가 8옥텟 길이의 정수 배수라는 요구 사항에 따라 가능한 한 적은 공간을 차지한다는 것입니다.

- o 옵션을 포함하는 헤더 중 하나가 존재할 때 매우 적은 수의 옵션\(보통 하나만 포함\)을 전달한다고 가정할 수 있습니다.

이러한 가정은 옵션의 필드를 레이아웃하는 다음과 같은 접근 방식을 제안합니다. 내부 패딩 없이 가장 작은 것부터 가장 큰 것까지 필드를 정렬한 다음 가장 큰 필드의 정렬 요구 사항을 기반으로 전체 옵션에 대한 정렬 요구 사항을 도출합니다\(최대 최대 정렬은 8옥텟\). 이 접근 방식은 다음 예에 설명되어 있습니다.

```text
   Example 1
```

옵션 X에 길이가 8옥텟인 데이터 필드와 길이가 4옥텟인 데이터 필드가 필요한 경우 다음과 같이 배치됩니다.

```text
                                   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                                   | Option Type=X |Opt Data Len=12|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                         4-octet field                         |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                                                               |
   +                         8-octet field                         +
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

8옥텟 필드가 둘러싸는 시작 부분에서 8의 배수 오프셋에서 시작되도록 하기 위한 정렬 요구 사항은 8n+2입니다.

머리글. 이 하나의 옵션을 포함하는 전체 홉별 또는 대상 옵션 헤더는 다음과 같습니다.

```text
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |  Next Header  | Hdr Ext Len=1 | Option Type=X |Opt Data Len=12|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                         4-octet field                         |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                                                               |
   +                         8-octet field                         +
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

   Example 2
```

옵션 Y에 세 개의 데이터 필드\(길이 4옥텟 중 하나, 길이 2옥텟 중 하나, 길이 1옥텟 중 하나\)가 필요한 경우 다음과 같이 배치됩니다.

```text
                                                   +-+-+-+-+-+-+-+-+
                                                   | Option Type=Y |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |Opt Data Len=7 | 1-octet field |         2-octet field         |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                         4-octet field                         |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

4옥텟 필드가 둘러싸는 헤더의 시작 부분에서 4의 배수 오프셋에서 시작되도록 하기 위한 정렬 요구 사항은 4n+3입니다. 이 하나의 옵션을 포함하는 전체 홉별 또는 대상 옵션 헤더는 다음과 같습니다.

```text
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |  Next Header  | Hdr Ext Len=1 | Pad1 Option=0 | Option Type=Y |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |Opt Data Len=7 | 1-octet field |         2-octet field         |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                         4-octet field                         |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   | PadN Option=1 |Opt Data Len=2 |       0       |       0       |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

   Example 3
```

예제 1과 2의 X와 Y 옵션을 모두 포함하는 홉별 또는 대상 옵션 헤더는 먼저 표시된 옵션에 따라 다음 두 가지 형식 중 하나를 갖습니다.

```text
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |  Next Header  | Hdr Ext Len=3 | Option Type=X |Opt Data Len=12|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                         4-octet field                         |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                                                               |
   +                         8-octet field                         +
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   | PadN Option=1 |Opt Data Len=1 |       0       | Option Type=Y |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |Opt Data Len=7 | 1-octet field |         2-octet field         |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                         4-octet field                         |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   | PadN Option=1 |Opt Data Len=2 |       0       |       0       |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |  Next Header  | Hdr Ext Len=3 | Pad1 Option=0 | Option Type=Y |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |Opt Data Len=7 | 1-octet field |         2-octet field         |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                         4-octet field                         |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   | PadN Option=1 |Opt Data Len=4 |       0       |       0       |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |       0       |       0       | Option Type=X |Opt Data Len=12|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                         4-octet field                         |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                                                               |
   +                         8-octet field                         +
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

---
# **Security Considerations**

이 문서에서는 인터넷 프로토콜 보안 아키텍처 \[RFC-1825\]에 따라 IP 인증 헤더 \[RFC-1826\] 및 IP 캡슐화 보안 페이로드 \[RFC-1827\]가 IPv6와 함께 사용되도록 지정합니다.

---
# **Acknowledgments**

저자는 IPng 작업 그룹, 엔드투엔드 프로토콜 연구 그룹 및 인터넷 커뮤니티 전체의 구성원이 제공한 많은 유용한 제안에 감사드립니다.

---
# **Authors' Addresses**

```text
   Stephen E. Deering                   Robert M. Hinden
   Xerox Palo Alto Research Center      Ipsilon Networks, Inc.
   3333 Coyote Hill Road                2191 E. Bayshore Road, Suite 100
   Palo Alto, CA 94304                  Palo Alto, CA 94303
   USA                                  USA

   Phone: +1 415 812 4839               Phone: +1 415 846 4604
   Fax:   +1 415 812 4471               Fax:   +1 415 855 1414
   EMail: deering@parc.xerox.com        EMail: hinden@ipsilon.com
```

---
# **References**

\[RFC-1825\] Atkinson, R., "인터넷 프로토콜을 위한 보안 아키텍처", RFC 1825, 해군 연구소, 1995년 8월.

```text
   [RFC-1826]   Atkinson, R., "IP Authentication Header", RFC 1826,
                Naval Research Laboratory, August 1995.

   [RFC-1827]   Atkinson, R., "IP Encapsulating Security Protocol
                (ESP)", RFC 1827, Naval Research Laboratory, August
                1995.
```

\[RFC-1885\] Conta, A. 및 S. Deering, "IPv6\(인터넷 프로토콜 버전 6\) 사양을 위한 ICMPv6\(인터넷 제어 메시지 프로토콜\)", RFC 1885, Digital Equipment Corporation, Xerox PARC, 1995년 12월.

\[RFC-1884\] Hinden, R. 및 S. Deering, 편집자, "IP 버전 6 주소 지정 아키텍처", RFC 1884, Ipsilon Networks, Xerox PARC, 1995년 12월.

\[RFC-1191\] Mogul, J. 및 S. Deering, "Path MTU Discovery", RFC 1191, DECWRL, Stanford University, 1990년 11월.

```text
   [RFC-791]    Postel, J., "Internet Protocol", STD 5, RFC 791,
                USC/Information Sciences Institute, September 1981.
```

\[RFC-1700\] Reynolds, J. 및 J. Postel, "할당된 번호", STD 2, RFC 1700, USC/정보 과학 연구소, 1994년 10월.

```text
   [RFC-1661]   Simpson, W., Editor, "The Point-to-Point Protocol
                (PPP)", STD 51, RFC 1661, Daydreamer, July 1994.
```
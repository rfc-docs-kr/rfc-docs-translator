

```text
﻿

Internet Engineering Task Force (IETF)                       B. Schwartz
Request for Comments: 9460                          Meta Platforms, Inc.
Category: Standards Track                                      M. Bishop
ISSN: 2070-1721                                                E. Nygren
                                                     Akamai Technologies
                                                           November 2023

Service Binding and Parameter Specification via the DNS (SVCB and HTTPS
                           Resource Records)
```

---
# **Abstract**

이 문서에서는 HTTP 원본과 같은 네트워크 서비스에 연결하는 데 필요한 정보 검색을 용이하게 하기 위해 "SVCB"\("서비스 바인딩"\) 및 "HTTPS" DNS 리소스 레코드\(RR\) 유형을 지정합니다. SVCB 레코드를 사용하면 각각 관련 매개 변수\(예: 전송 프로토콜 구성\)가 있는 여러 대체 끝점에서 서비스를 제공할 수 있으며 향후 사용\(예: TLS ClientHello 암호화를 위한 키\)을 지원하도록 확장 가능합니다. 또한 CNAME에서는 불가능한 apex 도메인의 별칭 지정을 활성화합니다. HTTPS RR은 HTTP와 함께 사용하기 위한 SVCB의 변형입니다\(RFC 9110, "HTTP 의미론" 참조\). 클라이언트가 연결을 시도하기 전에 더 많은 정보를 제공함으로써 이러한 기록은 성능과 개인 정보 보호 모두에 잠재적인 이점을 제공합니다.

---
# **Status of This Memo**

이것은 인터넷 표준 추적 문서입니다.

이 문서는 IETF\(Internet Engineering Task Force\)의 제품입니다. 이는 IETF 커뮤니티의 합의를 나타냅니다. 공개 검토를 받았으며 IESG\(Internet Engineering Steering Group\)의 출판 승인을 받았습니다. 인터넷 표준에 대한 자세한 내용은 RFC 7841의 섹션 2에서 확인할 수 있습니다.

이 문서의 현재 상태, 정오표, 피드백 제공 방법에 대한 정보는 https://www.rfc-editor.org/info/rfc9460에서 얻을 수 있습니다.

---
# **Copyright Notice**

Copyright \(c\) 2023 IETF Trust 및 문서 작성자로 확인된 사람. 판권 소유.

이 문서는 이 문서의 발행일에 유효한 BCP 78 및 IETF 문서에 관한 IETF 트러스트의 법적 조항\(https://trustee.ietf.org/license-info\)의 적용을 받습니다. 이 문서와 관련된 귀하의 권리 및 제한 사항을 설명하므로 이 문서를 주의 깊게 검토하십시오. 이 문서에서 추출한 코드 구성요소는 Trust Legal Provisions의 섹션 4.e에 설명된 대로 개정된 BSD 라이센스 텍스트를 포함해야 하며 개정된 BSD 라이센스에 설명된 대로 보증 없이 제공됩니다.

---
# **Table of Contents**

```text
   1.  Introduction
     1.1.  Goals
     1.2.  Overview of the SVCB RR
     1.3.  Terminology
   2.  The SVCB Record Type
     2.1.  Zone-File Presentation Format
     2.2.  RDATA Wire Format
     2.3.  SVCB Query Names
     2.4.  Interpretation
       2.4.1.  SvcPriority
       2.4.2.  AliasMode
       2.4.3.  ServiceMode
     2.5.  Special Handling of "." in TargetName
       2.5.1.  AliasMode
       2.5.2.  ServiceMode
   3.  Client Behavior
     3.1.  Handling Resolution Failures
     3.2.  Clients Using a Proxy
   4.  DNS Server Behavior
     4.1.  Authoritative Servers
     4.2.  Recursive Resolvers
       4.2.1.  DNS64
     4.3.  General Requirements
     4.4.  EDNS Client Subnet (ECS)
   5.  Performance Optimizations
     5.1.  Optimistic Pre-connection and Connection Reuse
     5.2.  Generating and Using Incomplete Responses
   6.  SVCB-Compatible RR Types
   7.  Initial SvcParamKeys
     7.1.  "alpn" and "no-default-alpn"
       7.1.1.  Representation
       7.1.2.  Use
     7.2.  "port"
     7.3.  "ipv4hint" and "ipv6hint"
     7.4.  "mandatory"
   8.  ServiceMode RR Compatibility and Mandatory Keys
   9.  Using Service Bindings with HTTP
     9.1.  Query Names for HTTPS RRs
     9.2.  Comparison with Alt-Svc
       9.2.1.  ALPN Usage
       9.2.2.  Untrusted Channels
       9.2.3.  Cache Lifetime
       9.2.4.  Granularity
     9.3.  Interaction with Alt-Svc
     9.4.  Requiring Server Name Indication
     9.5.  HTTP Strict Transport Security (HSTS)
     9.6.  Use of HTTPS RRs in Other Protocols
   10. Zone Structures
     10.1.  Structuring Zones for Flexibility
     10.2.  Structuring Zones for Performance
     10.3.  Operational Considerations
     10.4.  Examples
       10.4.1.  Protocol Enhancements
       10.4.2.  Apex Aliasing
       10.4.3.  Parameter Binding
       10.4.4.  Multi-CDN Configuration
       10.4.5.  Non-HTTP Uses
   11. Interaction with Other Standards
   12. Security Considerations
   13. Privacy Considerations
   14. IANA Considerations
     14.1.  SVCB RR Type
     14.2.  HTTPS RR Type
     14.3.  New Registry for Service Parameters
       14.3.1.  Procedure
       14.3.2.  Initial Contents
     14.4.  Other Registry Updates
   15. References
     15.1.  Normative References
     15.2.  Informative References
   Appendix A.  Decoding Text in Zone Files
     A.1.  Decoding a Comma-Separated List
   Appendix B.  HTTP Mapping Summary
   Appendix C.  Comparison with Alternatives
     C.1.  Differences from the SRV RR Type
     C.2.  Differences from the Proposed HTTP Record
     C.3.  Differences from the Proposed ANAME Record
     C.4.  Comparison with Separate RR Types for AliasMode and
           ServiceMode
   Appendix D.  Test Vectors
     D.1.  AliasMode
     D.2.  ServiceMode
     D.3.  Failure Cases
   Acknowledgments and Related Proposals
   Authors' Addresses
```

---
## **1.  Introduction**

SVCB\("서비스 바인딩"\) 및 HTTPS 리소스 레코드\(RR\)는 클라이언트에게 서비스 액세스에 대한 완전한 지침을 제공합니다. 이 정보는 최적이 아닌 기본 서버에 대한 일시적인 연결을 방지하고, 선호하는 프로토콜을 협상하고, 관련 공개 키를 제공함으로써 향상된 성능과 개인 정보 보호를 가능하게 합니다.

예를 들어, HTTP 클라이언트는 현재 원본 호스트 이름에 대한 A 및/또는 AAAA 레코드만 확인하고 해당 IP 주소만 학습합니다. HTTP 클라이언트가 연결하기 전에 원본에 대해 더 많이 알게 되면 "http" URL을 "https"로 업그레이드하거나, HTTP/3 또는 Encrypted ClientHello \[ECH\]를 활성화하거나, 운영상 선호되는 엔드포인트로 전환할 수 있습니다. 이 추가 정보를 학습하는 데 필요한 왕복 횟수와 조회 횟수를 최소화하는 것이 매우 바람직합니다.

SVCB 및 HTTPS RR은 서비스 운영자가 하나 이상의 다른 도메인에 운영 제어를 위임하려고 할 때에도 도움이 됩니다. 그물". 이 사례는 때때로 CNAME에 의해 처리될 수 있지만 모든 사용 사례를 다루지는 않습니다. CNAME은 서비스 운영자가 DNS를 통해 일관된 구성 매개변수\(예: 네트워크 위치, 프로토콜, 키 정보\)의 바인딩된 컬렉션을 제공해야 하는 경우에도 적합하지 않습니다.

이 문서에서는 먼저 SVCB RR을 광범위한 서비스에 직접적이고 효율적으로 적용할 수 있는 범용 RR로 설명합니다\(섹션 2\). 또한 HTTPS RR 유형\(섹션 9\)부터 시작하여 다른 SVCB 호환 RR 유형\(섹션 6\)을 정의하기 위한 규칙을 설명합니다. 이는 Attrleaf 레이블 \[Attrleaf\]\(섹션\)이 필요하지 않아 HTTP의 효율성과 편의성이 향상됩니다. 9.1\).

SVCB RR에는 두 가지 모드가 있습니다. 1\) 단순히 리소스에 대한 운영 제어를 위임하는 "AliasMode"와 2\) 서비스 끝점에 대한 구성 정보를 함께 바인딩하는 "ServiceMode"입니다. ServiceMode는 각 RDATA 세트 내에서 추가 key=value 매개변수를 제공합니다.

---
### **1.1.  Goals**

SVCB RR의 목표는 클라이언트가 다음과 같은 방식으로 단일 추가 DNS RR을 확인할 수 있도록 하는 것입니다.

\* 서비스에 대한 권한이 있는 대체 엔드포인트와 이러한 각 엔드포인트와 연관된 매개변수를 제공합니다.

\* 모든 대체 엔드포인트가 동일한 매개변수나 기능을 갖거나 동일한 엔터티에 의해 운영된다고 가정하지 않습니다. DNS는 동일한 이름에 대해 여러 RRset를 함께 묶는 방법을 제공하지 않기 때문에 이는 중요합니다. 예를 들어 "www.example.com"이 세 가지 CDN\(콘텐츠 전송 네트워크\) 또는 호스팅 환경 중 하나 간에 전환하는 CNAME 별칭인 경우 해당 이름에 대한 연속 쿼리는 서로 다른 환경에 해당하는 레코드를 반환할 수 있습니다.

\* 영역 정점에서 CNAME과 유사한 기능을 활성화합니다\(예:

- "example.com"\)은 프로토콜에 참여하며 일반적으로 도메인 이름으로 식별되는 서비스에 대한 운영 권한을 대체 이름을 가진 다른 인스턴스로 확장할 수 있습니다.

HTTPS RR 및 HTTP 사용 사례와 관련된 추가 목표는 다음과 같습니다.

\* HTTP/3\(QUIC 전송\) 대체 엔드포인트\[HTTP/3\]에 직접 연결합니다.

\* 기본이 아닌 TCP 및 UDP 포트를 지원합니다.

\* SRV\[SRV\]가 널리 채택되지 않은 HTTP에 대해 SRV와 유사한 이점\(예: 위에서 언급한 정점 앨리어싱\)을 활성화합니다.

\* HTTP Strict Transport Security \[HSTS\]와 유사하게 이 호스트 및 포트에 대한 모든 HTTP 요청에 대해 "http" 대신 "https" 체계를 사용해야 한다는 표시 신호를 제공합니다\(섹션 9.5 참조\).

\* 대체 엔드포인트와 연결된 암호화된 ClientHello 키\[ECH\] 전달을 활성화합니다.

---
### **1.2.  Overview of the SVCB RR**

이 하위 섹션에서는 각 구성 요소의 전체 설명을 참조하여 SVCB RR을 간략하게 설명합니다. \(섹션 6에서 설명한 것처럼 이 모든 내용은 동일한 인코딩, 형식 및 상위 수준 의미 체계를 공유하는 HTTPS RR에도 동일하게 적용됩니다.\)

SVCB RR에는 1\) 이름을 다른 이름으로 별칭을 지정하는 AliasMode\(섹션 2.4.2\)와 2\) 서비스 끝점 도메인에 바인딩된 연결 정보를 제공하는 ServiceMode\(섹션 2.4.3\)의 두 가지 모드가 있습니다. 단일 RR 유형에 두 양식을 모두 배치하면 클라이언트가 단일 쿼리로 관련 정보를 가져올 수 있습니다\(섹션 2.3\).

SVCB RR에는 필수 필드 2개와 선택 필드 1개가 있습니다. 필드는 다음과 같습니다.

SvcPriority\(섹션 2.4.1\): 이 레코드의 우선순위입니다\(다른 레코드에 비해 낮은 값이 선호됨\). 값 0은 AliasMode를 나타냅니다.

TargetName: 별칭 대상\(예:

- AliasMode\) 또는 대체 엔드포인트\(ServiceMode의 경우\).

SvcParams\(선택 사항\): TargetName의 대체 끝점을 설명하는 키=값 쌍 목록입니다\(ServiceMode에서만 사용되며 그렇지 않으면 무시됨\). SvcParams는 섹션 2.1에 설명되어 있습니다.

협력하는 DNS 재귀 확인자는 후속 레코드 확인\(SVCB, A 및 AAAA 레코드에 대한\)을 수행하고 이를 응답의 추가 섹션\(섹션 4.2\)에 반환합니다. 클라이언트는 재귀 확인자가 반환한 추가 섹션에 포함된 응답을 사용하거나 필요한 SVCB, A 및 AAAA 레코드 확인\(섹션 3\)을 수행합니다. DNS 권한 있는 서버는 추가 섹션의 in-bailiwick SVCB, A, AAAA 및 CNAME 레코드를 SVCB 쿼리에 대한 응답에 첨부할 수 있습니다\(섹션 4.1\).

ServiceMode에서 SVCB RR의 SvcParams는 이러한 각 대체 끝점과 연결된 매개 변수와 함께 서비스에 대해 권한이 있는 대체 끝점을 설명하기 위한 확장 가능한 데이터 모델을 제공합니다\(섹션 7\).

HTTP 사용 사례의 경우 HTTPS RR\(섹션 9\)은 선호하는 대안을 배우기 전에 전체 HTTP 연결 시작\(다중 왕복\)을 기다리지 않고 사용자의 정보를 반드시 공개하지 않고도 Alt-Svc \[AltSvc\]의 많은 이점을 활성화합니다. 네트워크 경로를 따라 모든 엔터티에 대한 의도된 대상입니다.

---
### **1.3.  Terminology**

이 문서의 용어는 권한 필드에 호스트로 DNS 호스트 이름이 포함된 URI로 식별되는 리소스에 액세스하는 데 SVCB 레코드가 사용되는 일반적인 경우를 기반으로 합니다.

\* "서비스"는 회사가 식별한 정보의 출처를 말합니다.

- 리소스에 대한 액세스를 제공할 수 있는 URI의 권한 및 체계. "https" URI의 경우 "서비스"는 "원본" \[RFC6454\]에 해당합니다.

\* "서비스 이름"은 권한의 호스트 부분입니다.

\* "권한 끝점"은 권한의 호스트 이름과 체계에 의해 암시되거나 URI에 지정된 포트 번호입니다.

\* "대체 엔드포인트"는 호스트 이름, 포트 번호 및 서비스 인스턴스에 도달하는 방법에 대한 클라이언트에 대한 기타 관련 지침입니다.

추가 DNS 용어는 \[DNSTerm\]과 일치하도록 의도되었습니다.

SVCB는 "서비스 바인딩"의 축약형입니다. SVCB RR, HTTPS RR 및 SVCB의 형식과 레지스트리를 공유하는 향후 RR 유형을 통칭하여 SVCB 호환 RR 유형이라고 합니다. 축약형 "SVCB"는 이 시스템을 전체적으로 지칭하는 데에도 사용됩니다.

키워드 "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY" 및 "OPTIONAL" "는 BCP 14 \[RFC2119\] \[RFC8174\]에 설명된 대로 여기에 표시된 것처럼 모두 대문자로 표시되는 경우에만 해석됩니다.\(MUST NOT\)

---
## **2.  The SVCB Record Type**

SVCB DNS RR 유형\(RR 유형 64\)은 서비스에 대한 대체 엔드포인트를 찾는 데 사용됩니다.

SVCB 레코드 및 관련 주소 레코드를 해결하기 위한 알고리즘은 섹션 3에 지정되어 있습니다.

필요에 따라 다른 SVCB 호환 RR 유형도 정의할 수 있습니다\(섹션 6 참조\). 특히, HTTPS RR\(RR 유형 65\)은 섹션 9에 설명된 대로 "https" 출처의 경우 특별한 처리를 제공합니다.

SVCB RR은 SvcParamKey 및 SvcParamValue로 구성된 쌍인 SvcParams 목록으로 확장 가능합니다. 각 SvcParamKey에는 프레젠테이션 이름과 등록된 번호가 있습니다. 값은 SvcParamKey와 관련된 형식입니다. 각 SvcParam에는 지정된 표시 형식\(영역 파일에 사용됨\)과 연결 인코딩\(예: 도메인 이름, 이진 데이터 또는 숫자 값\)이 있습니다. 초기 SvcParamKey 및 해당 형식은 섹션 7에 정의되어 있습니다.

---
### **2.1.  Zone-File Presentation Format**

레코드\(\[RFC1035\], 섹션 5.1\)의 표시 형식 <RDATA\>는 다음과 같은 형식을 갖습니다.

```text
   SvcPriority TargetName SvcParams
```

SVCB 레코드는 인터넷\("IN"\) 클래스\(\[RFC1035\], 섹션 3.2.4\) 내에서 구체적으로 정의됩니다.

SvcPriority는 0-65535 범위의 숫자이고 TargetName은 <domain-name\>\(\[RFC1035\], 섹션 5.1\)이며 SvcParams는 SvcParamKey=SvcParamValue 쌍 또는 독립 실행형으로 구성된 각 SvcParam이 있는 공백으로 구분된 목록입니다. SvcParamKey. SvcParamKey는 IANA\(섹션 14.3\)에 의해 등록됩니다.

```text
   Each SvcParamKey SHALL appear at most once in the SvcParams.  In
   presentation format, SvcParamKeys are lowercase alphanumeric strings.
   Key names contain 1-63 characters from the ranges "a"-"z", "0"-"9",
   and "-".  In ABNF [RFC5234],

   alpha-lc      = %x61-7A   ; a-z
   SvcParamKey   = 1*63(alpha-lc / DIGIT / "-")
   SvcParam      = SvcParamKey ["=" SvcParamValue]
   SvcParamValue = char-string ; See Appendix A.
   value         = *OCTET ; Value before key-specific parsing
```

SvcParamValue는 문자열 디코딩 알고리즘\(부록 A\)을 사용하여 구문 분석되어 값을 생성합니다. 그런 다음 값의 유효성을 검사하고 각 키에 특정한 방식으로 연결 형식으로 변환합니다.

선택적 "=" 및 SvcParamValue를 생략하면 값이 비어 있는 것으로 해석됩니다.

임의의 키는 알 수 없는 키 표시 형식인 "keyNNNNN"을 사용하여 표현할 수 있습니다. 여기서 NNNNN은 앞에 0이 없는 키 유형의 숫자 ​​값입니다. 이 형식의 SvcParam은 위에 지정된 대로 구문 분석되어야 하며, 디코딩된 값은 와이어 형식 인코딩으로 사용되어야 합니다.\(MUST\)

일부 SvcParamKeys의 경우 값은 항목 목록 또는 집합에 해당합니다. 이러한 키의 표시 형식은 쉼표로 구분된 목록\(부록 A.1\)을 사용해야 합니다.\(SHOULD\)

프레젠테이션 형식의 SvcParams는 어떤 순서로든 나타날 수 있지만 키는 반복되어서는 안 됩니다.\(MUST NOT\)

---
### **2.2.  RDATA Wire Format**

SVCB RR의 RDATA는 다음으로 구성됩니다.

\* 네트워크 바이트 순서의 정수인 SvcPriority에 대한 2옥텟 필드입니다.

\* \[RFC1035\]의 섹션 3.1에 따라 길이가 접두어로 붙는 레이블의 시퀀스로 표시되는 압축되지 않은 정규화된 TargetName입니다.

\* SvcParams는 레코드의 나머지 부분을 소비합니다\(따라서 65535 옥텟보다 작고 RDATA 및 DNS 메시지 크기로 제한됨\).

SvcParams 목록이 비어 있지 않으면 다음과 같이 표시되는 일련의 SvcParamKey=SvcParamValue 쌍이 포함됩니다.

\* SvcParamKey를 네트워크 바이트 순서의 정수로 포함하는 2옥텟 필드입니다. \(정의된 값은 섹션 14.3.2를 참조하십시오.\)

\* SvcParamValue의 길이를 네트워크 바이트 순서로 0에서 65535 사이의 정수로 포함하는 2옥텟 필드입니다.

\* 내용이 다음과 같은 길이의 옥텟 문자열

- SvcParamKey에 의해 결정된 형식의 SvcParamValue입니다.

SvcParamKeys는 숫자가 증가하는 순서로 나타나야 합니다.\(MUST\)

클라이언트는 다음과 같은 경우 잘못된 형식의 RR을 고려해야 합니다.\(MUST\)

\* RDATA의 끝은 SvcParam 내에서 발생합니다.

\* SvcParamKeys는 엄격하게 증가하는 숫자 순서가 아닙니다.

\* SvcParamKey의 SvcParamValue에 예상된 형식이 없습니다.

두 번째 조건은 중복된 SvcParamKey가 없음을 의미합니다.

RR의 형식이 잘못된 경우 클라이언트는 전체 RRset를 거부하고 SVCB가 아닌 연결 설정으로 돌아가야 합니다.\(MUST\)

---
### **2.3.  SVCB Query Names**

SVCB RR을 쿼리할 때 서비스 이름 앞에 구성표를 나타내는 레이블을 추가하고 밑줄을 접두사로 추가하여 서비스가 QNAME으로 변환됩니다. 결과적으로 "\_examplescheme.api.example.com."과 같은 도메인 이름이 생성됩니다. 이는 Attrleaf 명명 패턴 \[Attrleaf\]을 따르므로 체계가 IANA에 적절하게 등록되어야 합니다\(섹션 11 참조\).\(MUST\)

프로토콜 매핑 문서는 앞에 붙을 추가 밑줄 접두사 레이블을 지정할 수 있습니다. 포트를 지정하는 체계\(\[URI\]의 섹션 3.2.3\)의 경우, 기본이 아닌 포트 번호가 지정된 경우 표시된 포트 번호를 앞에 추가하는 것이 합리적인 가능성 중 하나입니다. 이 문서에서는 이 동작을 "포트 접두사 이름 지정"이라고 부르며 전체 예제에서 이를 사용합니다.\(MAY\)

HTTPS RR 동작에 대한 자세한 내용은 섹션 9.1을 참조하세요.

이전 CNAME 또는 SVCB 레코드가 SVCB 레코드에 별칭이 지정된 경우 각 RR은 일반 CNAME 처리\(\[RFC1034\], 섹션 3.6.2\)에서와 같이 자체 소유자 이름으로 반환되어야 합니다. 자세한 내용은 클라이언트\(섹션 3\), 서버\(섹션 4\) 및 영역\(섹션 10\)의 별칭에 관한 권장 사항을 참조하세요.\(MUST\)

이러한 양식 중 어느 것도 검증 목적으로 출처나 권한을 변경하지 않습니다. 예를 들어 TLS 클라이언트는 원래 서비스 이름에 대한 TLS 인증서의 유효성을 계속해서 검증해야 합니다.\(MUST\)

예를 들어, "example.com"의 소유자는 다음 레코드를 게시할 수 있습니다.

\_8443.\_foo.api.example.com. 7200 IN SVCB 0 svc4.example.net.

이 레코드는 "foo://api.example.com:8443"이 "svc4.example.net"으로 별칭이 지정되었음을 나타냅니다. "example.net"의 소유자는 다음 레코드를 게시할 수 있습니다.

```text
   svc4.example.net.  7200  IN SVCB 3 svc4.example.net. (
       alpn="bar" port="8004" )
```

이 기록은 이러한 서비스가 "foo://"에 대한 기본 전송 프로토콜 외에 "bar" 프로토콜과 관련 전송을 지원하는 포트 번호 8004에서 제공된다는 것을 나타냅니다.

\(괄호는 \[RFC1035\]의 섹션 5.1에 따라 DNS 영역 파일 표시 형식에서 줄 바꿈을 무시하는 데 사용됩니다.\)

---
### **2.4.  Interpretation**
---
#### **2.4.1.  SvcPriority**

SvcPriority가 0이면 SVCB 레코드는 AliasMode\(섹션 2.4.2\)에 있습니다. 그렇지 않으면 ServiceMode\(섹션 2.4.3\)에 있습니다.

SVCB RRset 내에서 모든 RR은 동일한 모드를 가져야 합니다. RRset에 AliasMode의 레코드가 포함되어 있는 경우 수신자는 해당 세트의 모든 ServiceMode 레코드를 무시해야 합니다.\(SHOULD, MUST\)

RRset는 명시적으로 순서가 지정되지 않은 컬렉션이므로 SvcPriority 필드는 SVCB RR에 순서를 적용하는 데 사용됩니다. SvcPriority가 작을수록 도메인 소유자가 SvcPriority 값이 더 큰 ServiceMode RR보다 이 레코드를 사용할 것을 권장한다는 의미입니다.

동일한 SvcPriority 값을 가진 여러 SVCB 레코드가 포함된 RRset를 수신할 때 클라이언트는 균일한 로드 밸런싱을 보장하기 위해 레코드를 사용하기 전에 우선순위 수준 내에서 레코드에 무작위 셔플을 적용해야 합니다.\(SHOULD\)

---
#### **2.4.2.  AliasMode**

AliasMode에서 SVCB 레코드는 서비스의 별칭을 TargetName으로 지정합니다. SVCB RRset는 AliasMode에서 단일 RR만 가져야 합니다. 여러 개의 AliasMode RR이 있는 경우 클라이언트 또는 재귀 확인자는 무작위로 하나를 선택해야 합니다.\(SHOULD, SHOULD\)

AliasMode의 주요 목적은 CNAME이 허용되지 않는 zone apex에서 앨리어싱을 허용하는 것입니다\(예: \[RFC1912\], 섹션 2.4 참조\). AliasMode에서 TargetName은 SVCB, AAAA 및/또는 A 레코드로 확인되는 도메인의 이름이 됩니다. \(SVCB 호환 RR 유형의 별칭 지정은 섹션 6을 참조하십시오.\) CNAME과 달리 AliasMode 레코드는 다른 RR 유형의 확인에 영향을 주지 않으며 전체 도메인 이름이 아닌 특정 서비스에만 적용됩니다.

AliasMode TargetName은 소유자 이름과 같아서는 안 됩니다. 이렇게 하면 루프가 발생하기 때문입니다. AliasMode에서 수신자는 존재하는 모든 SvcParam을 무시해야 합니다. AliasMode 레코드에 SvcParams가 있는 경우 영역 파일 파서가 경고를 내보낼 수 있습니다. AliasMode 레코드에서 SvcParams 사용은 현재 정의되지 않았지만 향후 사양에서는 SvcParams를 포함하도록 AliasMode 레코드를 확장할 수 있습니다.\(SHOULD NOT, MUST, MAY\)

예를 들어, "foo://example.com:8080"의 운영자는 다음을 게시하여 "foosvc.example.net"에서 작동하는 서비스로 요청을 가리킬 수 있습니다.

\_8080.\_foo.example.com. 3600 IN SVCB 0 foosvc.example.net.

AliasMode를 사용하면 우려 사항이 분리됩니다. "foosvc.example.net"의 소유자는 "example.com"에 대한 해당 변경을 요구하지 않고 ServiceMode SVCB 레코드를 추가하거나 제거할 수 있습니다. "foosvc.example.net"이 항상 SVCB 레코드를 게시하겠다고 약속하는 경우 이 AliasMode 레코드는 동일한 소유자 이름의 CNAME으로 대체될 수 있습니다.

AliasMode는 HTTPS RR 유형과 같이 밑줄 접두사가 필요하지 않은 SVCB 호환 RR 유형에 특히 유용합니다. 예를 들어, "https://example.com" 운영자는 zone apex에 다음 레코드를 게시하여 "svc.example.net"에 있는 서버로 요청을 보낼 수 있습니다.

example.com. 3600 IN HTTPS 0 svc.example.net.

SVCB 레코드의 소유자 이름은 CNAME 레코드의 정식 이름일 수 있고 TargetName은 CNAME 레코드의 소유자일 수 있습니다. 클라이언트와 재귀 확인자는 정상적으로 CNAME을 따라야 합니다.\(MAY, MUST\)

무제한 별칭 체인을 방지하려면 클라이언트와 재귀 확인자는 각 확인 요청에 대해 따를 SVCB 별칭의 총 수에 제한을 적용해야 합니다. 이 제한은 0이 되어서는 안 됩니다. 즉, 구현은 최소한 하나의 AliasMode 레코드를 따를 수 있어야 합니다. 이 제한의 정확한 값은 구현에 달려 있습니다.\(MUST, MUST NOT\)

여러 AliasMode 레코드를 따라야 하는 영역에서는 호환성 및 성능 문제가 발생할 수 있습니다.

레거시 클라이언트는 이 레코드를 사용하는 방법을 모르기 때문에 서비스 운영자는 이 SVCB 레코드와 함께 대체 AAAA 및 A 레코드를 유지해야 할 가능성이 높습니다. 그러나 일반적인 경우에는 SVCB 레코드의 대상이 더 나은 성능을 제공할 수 있으므로 다음과 같은 경우에 더 좋습니다. 이 사양을 구현하는 클라이언트가 사용합니다.

AliasMode 레코드는 특정 RR 유형에 대한 쿼리에만 적용됩니다. 예를 들어 SVCB 레코드는 HTTPS 레코드의 별칭을 지정할 수 없으며 그 반대의 경우도 마찬가지입니다.

---
#### **2.4.3.  ServiceMode**

ServiceMode에서 각 RR 내의 TargetName 및 SvcParams는 서비스의 대체 엔드포인트를 해당 연결 매개변수와 연결합니다.

SVCB를 사용하는 각 프로토콜 체계는 해당 체계의 연결에 SvcParam이 적용되는 방식을 설명하는 프로토콜 매핑을 정의해야 합니다. 프로토콜 매핑에서 달리 지정하지 않는 한 클라이언트는 인식하지 못하는 SvcParam을 무시해야 합니다.\(MUST, MUST\)

일부 SvcParam은 RR의 다른 SvcParam에 요구 사항을 적용합니다. ServiceMode RR은 해당 SvcParam이 모두 서로의 요구 사항을 준수하는 경우 "자체 일관성"이라고 합니다. 클라이언트는 인식된 SvcParam이 일관성이 없는 모든 RR을 거부해야 하며 전체 RRset를 거부할 수 있습니다. 영역 운영자가 이 조건을 피할 수 있도록 영역 파일 구현은 자체 일관성도 적용해야 합니다.\(MUST, SHOULD\)

---
### **2.5.  Special Handling of "." in TargetName**

TargetName에 "." 값이 있는 경우 \(와이어 형식에서 길이가 0인 레이블로 표시됨\) 특별한 규칙이 적용됩니다.

---
#### **2.5.1.  AliasMode**

AliasMode SVCB RR의 경우 TargetName은 "."입니다. 서비스를 사용할 수 없거나 존재하지 않음을 나타냅니다. 이 표시는 권고 사항입니다. 클라이언트는 이 표시를 무시하고 SVCB를 사용하지 않고 연결을 시도할 수 있습니다.\(MAY\)

---
#### **2.5.2.  ServiceMode**

ServiceMode SVCB RR의 경우 TargetName에 "." 값이 있으면 이 레코드의 소유자 이름을 유효한 TargetName으로 사용해야 합니다. 레코드의 영역 파일에 와일드카드 소유자 이름이 있는 경우 수신자는 응답의 합성 소유자 이름을 유효한 TargetName으로 사용해야 합니다.\(MUST, MUST\)

예를 들어 여기서는 "svc2.example.net"이 유효한 TargetName입니다.

```text
   example.com.      7200  IN HTTPS 0 svc.example.net.
   svc.example.net.  7200  IN CNAME svc2.example.net.
   svc2.example.net. 7200  IN HTTPS 1 . port=8002
   svc2.example.net. 300   IN A     192.0.2.2
   svc2.example.net. 300   IN AAAA  2001:db8::2
```

---
## **3.  Client Behavior**

"SVCB 확인"은 클라이언트가 수행하는 대로 서비스에 대해 사용 가능한 끝점을 열거하고 순서를 지정하는 프로세스입니다. SVCB 확인은 다음과 같이 구현됩니다.

1. $QNAME을 서비스 이름과 체계에 대한 적절한 접두사로 둡니다\(섹션 2.3 참조\).

2. $QNAME에 대한 SVCB 쿼리를 실행합니다.

3. $QNAME에 대해 AliasMode SVCB 레코드가 반환되면\(일반적으로 CNAME을 따른 후\) $QNAME을 TargetName\(추가 접두사 없이\)으로 설정하고 체인 길이 제한 및 루프 감지 휴리스틱에 따라 2단계로 루프백합니다\(섹션 참조\). 3.1\).

4. 하나 이상의 "호환 가능한"\(섹션 8\) ServiceMode 레코드가 반환되면 이는 대체 엔드포인트를 나타냅니다. SvcPriority를 ​​오름차순으로 레코드를 정렬합니다.

5. 그렇지 않으면 SVCB 확인이 실패하고 사용 가능한 끝점 목록이 비어 있습니다.

이 절차에서는 이 사양을 준수하거나 SVCB를 인식하기 위해 재귀적이거나 권한 있는 DNS 서버에 의존하지 않습니다.

ServiceMode 레코드를 사용하지 않고 연결할 수 있는 클라이언트를 "SVCB-선택적"이라고 합니다. 그렇지 않으면 "SVCB 의존"이라고 합니다. 기존 프로토콜\(예: HTTP\)에 대한 클라이언트는 SVCB 선택적 동작을 구현해야 합니다\(섹션 3.1에 명시된 경우 또는 향후 사양에 의해 수정되는 경우 제외\).\(MUST\)

SVCB 선택적 클라이언트는 SVCB 레코드가 없는 경우 연결 설정에 필요할 수 있는 다른 모든 DNS 쿼리를 병렬로 실행하여 해당 경우 지연을 최소화하고 섹션 5에서 설명한 최적화를 활성화해야 합니다.\(SHOULD\)

SVCB 해결이 완료되면 성공 여부에 관계없이 적어도 하나의 AliasMode 레코드가 처리된 경우 SVCB 선택적 클라이언트는 $QNAME의 최종 값, 기관 끝점의 포트 번호로 구성된 끝점을 끝점 목록에 추가해야 합니다. SvcParams. \(이 끝점은 비SVCB 연결 모드로 폴백하기 전에 시도됩니다. 이렇게 하면 SVCB 선택적 클라이언트가 TargetName에 A 및/또는 AAAA 레코드가 있지만 SVCB 레코드는 없는 AliasMode 레코드를 사용할 수 있습니다.\)\(MUST\)

클라이언트는 이 끝점 목록을 사용하여 연결 설정을 진행합니다. 클라이언트는 우선순위가 높은 대안을 먼저 시도하고 우선순위가 낮은 대안으로 대체해야 합니다. 클라이언트는 선택된 TargetName에 대한 AAAA 및/또는 A 레코드를 확인하고 Happy Eyeballs \[HappyEyeballsV2\]와 같은 접근 방식을 사용하여 둘 중 하나를 선택할 수 있습니다.\(SHOULD, MAY\)

클라이언트가 SVCB 선택 사항이고 이 끝점 목록을 사용하여 연결하는 데 실패한 경우 클라이언트는 이제 비SVCB 연결 모드를 사용하려고 시도합니다.

일반적인 AAAA/A 조회와 비교하여 추가 대기 시간을 피하기 위해 섹션 5에서 몇 가지 중요한 최적화에 대해 설명합니다.

---
### **3.1.  Handling Resolution Failures**

DNS 응답이 암호화 방식으로 보호되고\(예: DNSSEC 또는 TLS\[DoT\]\[DoH\] 사용\) 인증 오류, SERVFAIL 응답, 전송 오류 또는 시간 초과로 인해 SVCB 확인이 실패하는 경우 클라이언트는 서비스에 도달하려는 시도를 포기해야 합니다. 클라이언트가 SVCB 옵션인 경우에도 마찬가지입니다. 그렇지 않으면 적극적인 공격자가 SvcParams에 대한 사용자 액세스를 거부하여 다운그레이드 공격을 가할 수 있습니다.\(SHOULD\)

도메인이 DNSSEC로 서명되고, 재귀 확인자가 DNSSEC를 검증하고, 공격자가 재귀 확인자와 권한 있는 DNS 서버 사이에 있는 경우 SERVFAIL 오류가 발생할 수 있습니다. 클라이언트와 재귀 확인자 사이의 활성 공격자가 크기 또는 기타 관찰 가능한 패턴을 기반으로 SVCB 쿼리 또는 응답을 선택적으로 삭제하는 경우 전송 오류 또는 시간 초과가 발생할 수 있습니다.

클라이언트가 A/AAAA 응답에 대해 DNSSEC 유효성 검사를 시행하는 경우 SVCB에도 동일한 유효성 검사 정책을 적용해야 합니다\(SHOULD\). 그렇지 않으면 공격자가 클라이언트를 다른 IP 주소로 연결하는 SVCB 응답을 위조하여 A/AAAA 보호를 무력화할 수 있습니다.\(SHOULD\)

DNS 응답이 암호화로 보호되지 않는 경우 클라이언트는 SVCB 확인 실패를 치명적이거나 치명적이지 않은 것으로 처리할 수 있습니다.\(MAY\)

클라이언트가 체인 길이 제한으로 인해 SVCB 확인을 완료할 수 없는 경우 클라이언트는 마치 서비스의 SVCB 레코드가 존재하지 않는 것처럼 기관 끝점으로 대체해야 합니다.\(MUST\)

---
### **3.2.  Clients Using a Proxy**

HTTP CONNECT\(\[RFC7231\], 섹션 4.3.6\) 또는 SOCKS5 \[RFC1928\]와 같은 도메인 지향 전송 프록시를 사용하는 클라이언트에는 명명된 대상을 사용할 수 있는 옵션이 있으며, 이 경우 클라이언트는 대상 도메인에 대해 A 또는 AAAA 쿼리를 수행하지 않습니다. . 클라이언트가 SVCB 쿼리 기능을 제공하지 않는 프록시\(예: 제휴 DNS 확인자를 통해\)와 함께 명명된 대상을 사용하도록 구성된 경우 클라이언트는 SVCB 확인을 별도로 수행해야 하며 대상을 사용자뿐만 아니라 추가 당사자에게 공개할 가능성이 높습니다. 대리. 이 구성의 클라이언트는 적절한 개인정보 보호 속성을 사용하여 별도의 SVCB 해결 절차를 준비해야 합니다. 이것이 가능하지 않은 경우 SVCB 선택적 클라이언트는 SVCB 확인을 완전히 비활성화해야 하며 SVCB 의존 클라이언트는 구성을 유효하지 않은 것으로 처리해야 합니다.\(SHOULD, MUST\)

클라이언트가 SVCB 및 명명된 대상을 사용하는 경우 클라이언트는 클라이언트 및 프록시와 호환되는 가장 작은 SvcPriority 옵션을 선택하여 표준 SVCB 확인 프로세스를 따라야 합니다. SVCB 레코드를 사용하여 연결할 때 클라이언트는 필수 A 및 AAAA 조회를 수행하는 프록시에 최종 TargetName 및 포트를 제공해야 합니다.\(SHOULD, MUST\)

이 배열에는 다음과 같은 여러 가지 이점이 있습니다.

\* SVCB 비활성화와 비교:

- - 클라이언트가 특정 TargetName에만 사용할 수 있는 SvcParams\(있는 경우\)를 사용할 수 있도록 합니다. SvcParams에는 성능\(예: 지원되는 프로토콜\) 및 개인 정보 보호를 향상시키는 정보가 포함될 수 있습니다.

- - apex 도메인의 서비스에서 별칭을 사용할 수 있습니다.

\* 프록시에 IP 주소를 제공하는 것과 비교:

- - 프록시가 구성에 따라 서버의 IPv4와 IPv6 주소 중에서 선택할 수 있습니다.

- - 프록시가 클라이언트의 주소가 아닌 네트워크 지리적 위치를 기반으로 주소를 수신하는지 확인합니다.

- - 동일한 계열의 주소가 여러 개인 TCP 대상에 대해 더 빠른 대체를 가능하게 합니다.

---
## **4.  DNS Server Behavior**
---
### **4.1.  Authoritative Servers**

SVCB 쿼리에 응답할 때 권한 있는 DNS 서버는 영역에 있는 모든 TargetName에 대한 추가 섹션에 A, AAAA 및 SVCB 레코드를 반환해야 합니다. 영역이 서명된 경우 서버는 추가 섹션에 이러한 레코드의 존재 여부를 인증하는 DNSSEC 레코드도 포함해야 합니다.\(SHOULD, SHOULD\)

예외 사항은 섹션 4.4를 참조하세요.

---
### **4.2.  Recursive Resolvers**

재귀 확인자가 SVCB를 인식하는지 여부에 관계없이 알 수 없는 RR 유형\[RFC3597\]에 사용되는 일반적인 응답 구성 프로세스는 응답의 응답 섹션을 생성합니다. SVCB를 인식하는 재귀 확인자는 추가 유용한 정보를 다음과 같이 응답의 추가 섹션에 통합하여 클라이언트가 전체 대기 시간을 최소화하면서 섹션 3의 절차를 실행할 수 있도록 도와야 합니다.\(SHOULD\)

1. SVCB 결의 결과를 통합합니다. 재귀 확인자의 로컬 체인 길이 제한\(클라이언트 제한과 다를 수 있음\)에 도달한 경우 종료합니다.

2. 확인된 SVCB 레코드가 AliasMode에 있는 경우 무작위로 하나를 선택하고 해당 TargetName에 대한 SVCB, A 및 AAAA 레코드를 확인합니다.

- \* SVCB 레코드가 해결된 경우 1단계로 이동합니다.

- \* 그렇지 않은 경우 A 및 AAAA 해결 결과를 통합하고 종료합니다.

3. 확인된 모든 SVCB 레코드는 ServiceMode에 있습니다. 각 TargetName\(또는 TargetName이 "."인 경우 소유자 이름\)에 대한 A 및 AAAA 쿼리를 해결하고 모든 결과를 통합한 후 종료합니다.

이 절차에서 "해결"은 마치 해당 RRset에 대한 쿼리를 처리하는 것처럼 확인자의 일반적인 재귀 해결 절차를 의미합니다. 여기에는 확인자가 일반적으로 따르는 별칭\(예: CNAME, DNAME \[DNAME\]\)을 따르는 것이 포함됩니다. 추가 기록을 획득할 때 발생하는 오류나 이상 현상으로 인해 이 프로세스가 종료될 수 있지만 그 자체로 확인자가 실패 응답을 보내도록 해서는 안 됩니다.\(MUST NOT\)

루프를 완화하기 위해 구현할 재귀 확인자에 대한 추가 보호 조치는 섹션 2.4.2를 참조하세요.

이 절차의 가능한 최적화에 대해서는 섹션 5.2를 참조하십시오.

---
#### **4.2.1.  DNS64**

DNS64 확인자는 A 레코드만 있는 이름에 대한 AAAA 쿼리에 대한 응답을 합성합니다\(\[RFC6147\]의 섹션 5.1.7\). SVCB 인식 DNS64 확인자는 추가 섹션\(섹션 4.2의 2단계\)에 포함하기 위해 TargetName에 대한 AAAA 레코드를 확인할 때 동일한 합성 논리를 적용해야 하며 이 섹션에서 A 레코드를 생략할 수 있습니다.\(SHOULD\)

DNS64 확인자는 AAAA 합성 논리를 SvcParams\(섹션 7.3\)의 IP 힌트로 추정해서는 안 됩니다. IP 힌트를 수정하면 SVCB 레코드에 대한 DNSSEC 유효성 검사가 중단되고 위 권장 사항을 구현할 때 성능이 향상되지 않습니다.\(MUST NOT\)

---
### **4.3.  General Requirements**

재귀 확인자는 인식되지 않은 SvcParamKey가 포함된 SVCB 레코드를 전달할 수 있어야 합니다\(MUST\). 확인자는 내용이 유효하지 않은 경우에도 레코드의 전체 SvcParams 부분을 불투명하게 처리하여 이를 수행할 수 있습니다. 인식된 SvcParamKey 뒤에 SvcParam의 사양에 따라 유효하지 않은 값이 오는 경우 재귀 확인자는 레코드를 반환하는 대신 SERVFAIL과 같은 오류를 보고할 수 있습니다. 해석이 구현마다 다를 수 있거나 향후에 허용되는 추가 값\(예: URI 또는 ​​"alpn"\)이 있는 복잡한 값 유형의 경우 확인자는 유효성 검사를 지정된 제약 조건으로 제한해야 합니다\(SHOULD\).\(MUST, MAY, MAY, SHOULD\)

DNSSEC OK 비트\[RFC3225\]가 포함된 쿼리에 응답할 때 DNSSEC 가능 재귀적이고 권한 있는 DNS 서버는 해당 RRset를 답변으로 제공할 때 보낼 것과 동일한 DNSSEC 관련 레코드와 함께 추가 섹션의 각 RRset를 동반해야 합니다\(MUST\). 예: RRSIG, NSEC, NSEC3\).\(MUST\)

\[RFC2181\]의 섹션 5.4.1에 따르면 "추가 데이터 섹션에서 수신되고 캐시된 인증되지 않은 RR은 수신된 쿼리에 대한 응답으로 반환되는 방식으로 캐시되어서는 안 됩니다. 적절한 경우 추가 정보로 반환될 수 있습니다." 따라서 재귀 확인자는 추가 섹션 응답을 채우는 데 사용하기 위해 추가 섹션의 레코드를 캐시할 수 있으며, DNSSEC에 의해 인증된 경우 일반적인 사용을 위해 레코드를 캐시할 수 있습니다.\(MAY\)

---
### **4.4.  EDNS Client Subnet (ECS)**

EDNS 클라이언트 서브넷\(ECS\) 옵션 \[RFC7871\]을 사용하면 재귀 확인자가 특정 클라이언트 IP 범위에 적합한 IP 주소를 요청할 수 있습니다. SVCB 레코드는 IP 주소\(ipv\*hint SvcParams\)를 포함하거나 사용자를 서브넷별 TargetName으로 안내할 수 있으므로 재귀 확인자는 A/AAAA 쿼리와 마찬가지로 SVCB 쿼리에 동일한 ECS 옵션을 포함해야 합니다.\(SHOULD\)

\[RFC7871\]의 섹션 7.3.1에 따르면 "\[추가 섹션\]의 모든 레코드는 네트워크에 연결되어서는 안 됩니다." 따라서 QTYPE이 SVCB와 호환되는 응답을 처리할 때 확인자는 추가 섹션의 모든 레코드를 SOURCE PREFIX-LENGTH가 0으로 설정되고 SCOPE PREFIX-LENGTH가 ECS 옵션에 지정된 대로 처리해야 합니다. 권한 있는 서버는 SOURCE PREFIX-LENGTH를 0으로 설정한 스텁 확인자에서 사용하기에 적합하지 않은 경우 해당 레코드를 생략해야 합니다. 이렇게 하면 해석기가 적절하게 맞춤화된 ECS를 수신할 수 있는 후속 쿼리를 수행하게 됩니다. \(이는 \[RFC7871\], 섹션 7.2.1에서 논의된 ECS 옵션과 함께 CNAME을 사용하는 것과 유사합니다.\)\(MUST NOT, MUST\)

추가 레코드를 생략하는 권한 있는 서버는 섹션 10.2의 조언에 따라 후속 쿼리의 추가 대기 시간을 피할 수 있습니다.

---
## **5.  Performance Optimizations**

최적의 성능\(예: 최소 연결 설정 시간\)을 위해 클라이언트는 클라이언트측 DNS 캐시를 구현해야 합니다. SVCB 응답의 추가 섹션에 있는 응답은 후속 쿼리를 수행하기 전에 캐시에 저장되어야 합니다. 이 동작과 DNS 서버를 준수하는 경우 SVCB를 사용해도 연결 설정에 네트워크 대기 시간이 추가되지 않습니다.\(SHOULD, SHOULD\)

부적합 재귀 확인자를 사용할 때 성능을 향상시키려면 클라이언트는 TargetName의 예측 값을 기반으로 각 SVCB 쿼리와 병렬로 추측 A 및/또는 AAAA 쿼리를 발행해야 합니다\(섹션 10.2 참조\).\(SHOULD\)

ServiceMode RRset가 수신된 후 클라이언트는 두 개 이상의 옵션을 병렬로 시도할 수 있으며 여러 TargetName에 대한 A 및 AAAA 레코드를 프리페치할 수 있습니다.\(MAY\)

---
### **5.1.  Optimistic Pre-connection and Connection Reuse**

해당 SVCB 응답 이전에 주소 응답이 도착하는 경우 클라이언트는 SVCB 쿼리가 NODATA를 반환한 것처럼 연결을 시작할 수 있지만 SVCB 응답이 도착할 때까지 SVCB 응답에 의해 변경될 수 있는 정보를 전송해서는 안 됩니다. 예를 들어 TLS ClientHello를 변경하는 향후 SvcParamKeys를 정의할 수 있습니다.\(MUST NOT\)

이 최적화를 구현하는 클라이언트는 \[HappyEyeballsV2\]의 지침에 따라 낙관적 사전 연결을 시작하기 전에 50밀리초 동안 기다려야 합니다.\(SHOULD\)

클라이언트가 해당 레코드를 사용할 때 동등한 연결을 시도하는 경우 SVCB 레코드는 연결과 일치합니다. SVCB 레코드가 활성 또는 진행 중인 연결 C와 일치하는 경우 클라이언트는 해당 레코드를 선호하고 C를 연결로 사용할 수 있습니다. 예를 들어, 클라이언트가 TCP를 통한 TLS를 사용하는 프로토콜에 대해 이 SVCB RRset를 수신한다고 가정합니다.\(MAY\)

```text
   _1234._bar.example.com. 300 IN SVCB 1 svc1.example.net. (
       ipv6hint=2001:db8::1 port=1234 )
                                  SVCB 2 svc2.example.net. (
       ipv6hint=2001:db8::2 port=1234 )
```

클라이언트가 \[2001:db8::2\]:1234에 대해 진행 중인 TCP 연결을 갖고 있는 경우, RRset의 다른 레코드의 우선순위가 더 높더라도 해당 연결에서 TLS를 계속 진행할 수 있습니다.\(MAY\)

SVCB 레코드 중 어느 것도 활성 또는 진행 중인 연결과 일치하지 않는 경우 클라이언트는 섹션 3에 설명된 대로 연결 설정을 진행합니다.

---
### **5.2.  Generating and Using Incomplete Responses**

섹션 4.2의 절차를 따를 때 재귀적 확인자는 절차를 조기에 종료하고 관련 RRset 중 일부를 생략하는 응답을 생성할 수 있습니다. 이는 체인 길이 제한에 도달할 때 필수이지만\(섹션 4.2의 1단계\) 최대 응답 크기에 도달하거나 종속성을 완전히 추적하기 전에 응답할 때 성능이 향상되는 경우에도 적절할 수 있습니다. 특정 RRset를 생략할 때 재귀 확인자는 더 작은 SvcPriority 레코드에 대한 정보의 우선 순위를 지정해야 합니다.\(MAY, MUST, SHOULD\)

섹션 3에서 설명한 것처럼 클라이언트는 SVCB 레코드를 사용하는 데 필요한 추가 정보\(초기 응답에 포함되지 않은 경우\)를 가져올 수 있어야 합니다. 성능 최적화로서 추가 DNS 쿼리 없이 응답의 SVCB 레코드 중 일부를 사용할 수 있는 경우 클라이언트는 우선순위에 관계없이 해당 레코드를 선호할 수 있습니다.\(MUST, MAY\)

---
## **6.  SVCB-Compatible RR Types**

다음과 같은 측면에서 SVCB와 동일한 구현을 허용하는 경우 RR 유형을 "SVCB 호환"이라고 합니다.

```text
   *  RDATA presentation format

   *  RDATA wire format
```

\* SvcParamKeys에 사용되는 IANA 레지스트리

```text
   *  Authoritative server Additional section processing

   *  Recursive resolution process

   *  Relevant Class (i.e., Internet ("IN") [RFC1035])
```

이를 통해 신뢰할 수 있고 재귀적인 DNS 서버가 모든 SVCB 호환 RR 유형에 동일한 처리를 적용할 수 있습니다.

SVCB RR에 적용되는 것으로 설명된 다른 모든 동작은 별도로 명시하지 않는 한 모든 SVCB 호환 RR 유형에도 적용됩니다. RR 유형 $T의 AliasMode 레코드\(섹션 2.4.2\)를 따르는 경우 TargetName에 대한 후속 쿼리도 유형 $T에 대한 것이어야 합니다.\(MUST\)

이 문서는 하나의 SVCB 호환 RR 유형\(SVCB 자체 제외\)을 정의합니다. HTTPS RR 유형\(섹션 9\)은 HTTP에서 널리 사용되는 와일드카드 및 CNAME과의 호환성을 향상시키기 위해 Attrleaf 레이블 접두사 \[Attrleaf\]를 피합니다.

표준 작성자는 SVCB를 사용할지 아니면 새로운 SVCB 호환 RR 유형을 정의할지 신중하게 고려해야 합니다. 이러한 선택은 배포 후에 쉽게 되돌릴 수 없기 때문입니다.

---
## **7.  Initial SvcParamKeys**

여기에는 몇 가지 초기 SvcParamKey가 정의되어 있습니다. 이러한 키는 "https" 구성표에 유용하며 대부분은 일반적으로 다른 구성표에도 적용할 수 있을 것으로 예상됩니다.

각각의 새로운 프로토콜 매핑 문서는 어떤 키가 적용 가능하고 사용하기에 안전한지 지정해야 합니다. 프로토콜 매핑은 SvcParamKeys의 해석을 변경할 수 있지만 프레젠테이션이나 연결 형식을 변경해서는 안 됩니다.\(MUST, MUST NOT\)

---
### **7.1.  "alpn" and "no-default-alpn"**

"alpn" 및 "no-default-alpn" SvcParamKeys는 함께 ALPN\(Application-Layer Protocol Negotiation\) 프로토콜 식별자\[ALPN\] 집합과 이 서비스 끝점에서 지원하는 관련 전송 프로토콜 집합\("SVCB ALPN 집합"\)을 나타냅니다.

Alt-Svc\[AltSvc\]와 마찬가지로 각 ALPN 프로토콜 식별자는 엔드포인트에서 지원하는 애플리케이션 프로토콜 및 관련 프로토콜 제품군\("프로토콜 제품군"\)을 식별하는 데 사용됩니다. SVCB ALPN 세트에 ALPN 프로토콜 식별자가 있다는 것은 TargetName 및 기타 매개변수\(예: "포트"\)로 설명되는 이 서비스 끝점이 이 ALPN 식별자와 연결된 프로토콜 제품군으로 서비스를 제공한다는 것을 나타냅니다.

클라이언트는 지원하는 프로토콜 제품군과 일치하도록 ALPN 식별자 세트를 필터링하며, 이는 사용되는 기본 전송 프로토콜\(예: UDP를 통한 QUIC 또는 TCP를 통한 TLS\)에 대해 알려줍니다. 프로토콜 모음을 고유하게 식별하지 않는 ALPN 프로토콜 식별자\(예: TLS 및 DTLS와 함께 사용할 수 있는 식별 시퀀스\)는 이 SvcParamKey와 호환되지 않으며 SVCB ALPN 세트에 포함되어서는 안 됩니다.\(MUST NOT\)

---
#### **7.1.1.  Representation**

ALPN은 1-255 옥텟의 시퀀스인 등록된 "식별 시퀀스"\(alpn-id\)로 식별됩니다.

```text
   alpn-id = 1*255OCTET
```

"alpn"의 경우 표시 값은 하나 이상의 alpn-id가 쉼표로 구분된 목록\(부록 A.1\)이어야 합니다. 영역 파일 구현은 값 목록 이스케이프 절차를 구현하는 대신 ALPN ID의 "," 및 "\" 문자를 허용하지 않을 수 있으며, 이러한 문자가 필요한 경우 불투명 키 형식\(예: key1=\002h2\)을 사용합니다. .\(MUST, MAY\)

"alpn"에 대한 연결 형식 값은 단일 옥텟의 길이가 앞에 붙은 하나 이상의 alpn-id로 구성되며 이러한 길이-값 쌍은 연결되어 SvcParamValue를 형성합니다. 이러한 쌍은 SvcParamValue를 정확하게 채워야 합니다. 그렇지 않으면 SvcParamValue의 형식이 잘못되었습니다.\(MUST\)

"no-default-alpn"의 경우 Presentation 및 wire-format 값은 비어 있어야 합니다. RR에 "no-default-alpn"이 지정되면 RR이 "자체 일관성"이 되도록 "alpn"도 지정되어야 합니다\(2.4.3절\).\(MUST\)

이 SvcParamKey를 사용하는 각 체계는 거의 모든 클라이언트와 서버에서 지원되는 ALPN ID의 "기본 집합"을 정의합니다. 이 세트는 비어 있을 수 있습니다. SVCB ALPN 세트를 결정하기 위해 클라이언트는 "alpn" SvcParamKey의 alpn-id 목록으로 시작하고 "no-default-alpn" SvcParamKey가 없으면 기본 세트를 추가합니다.\(MAY\)

---
#### **7.1.2.  Use**

엔드포인트에 대한 연결을 설정하려면 클라이언트가 다음을 수행해야 합니다.\(MUST\)

1. SVCB-ALPN-Intersection을 클라이언트가 지원하는 SVCB ALPN 세트의 프로토콜 세트로 둡니다.

2. Intersection-Transports를 SVCB-ALPN-Intersection의 프로토콜에 의해 암시된 전송 집합\(예: TLS, DTLS, QUIC\)으로 둡니다.

3. Intersection-Transports의 각 전송에 대해 SVCB ALPN 세트에 관계없이 해당 전송에 대해 클라이언트가 지원하는 모든 ALPN 프로토콜의 식별 시퀀스를 포함하는 ProtocolNameList를 구성합니다.

예를 들어, SVCB ALPN 세트가 \["http/1.1", "h3"\]이고 클라이언트가 HTTP/1.1, HTTP/2 및 HTTP/3을 지원하는 경우 클라이언트는 ProtocolNameList와 함께 TLS over TCP를 사용하여 연결을 시도할 수 있습니다. \["http/1.1", "h2"\]이며 \["h3"\]의 ProtocolNameList와 함께 QUIC를 사용하여 연결을 시도할 수도 있습니다.

클라이언트가 ClientHello를 구성하면 해당 핸드셰이크의 프로토콜 협상은 SVCB ALPN 세트에 관계없이 \[ALPN\]에 지정된 대로 진행됩니다.

클라이언트는 선호도가 높은 전송이 연결에 실패할 경우 선호도가 낮은 전송을 사용하여 대체 절차를 구현할 수 있습니다. 이러한 대체 동작은 더 선호되는 전송을 차단하는 네트워크 공격자의 조작에 취약하지만 기존 네트워크와의 호환성을 위해 필요할 수도 있습니다.\(MAY\)

이 절차를 사용하면 DNS 및 네트워크 트래픽을 수정할 수 있는 공격자가 성공적인 전송 연결을 막을 수 있지만 ALPN 프로토콜 선택을 방해할 수는 없습니다. 또한 이 절차에서는 각 ProtocolNameList에 SVCB ALPN 세트의 프로토콜이 하나 이상 포함되어 있는지 확인합니다.

클라이언트는 SVCB ALPN 세트에 지원되는 프로토콜이 포함되지 않은 서비스 엔드포인트에 연결을 시도해서는 안 됩니다.\(SHOULD NOT\)

동작의 일관성을 보장하기 위해 클라이언트는 기본이 아닌 ALPN 프로토콜을 사용하여 연결이 성공할 수 있는 경우에도 호환 가능한 모든 RR이 "no-default-alpn"을 나타내는 경우 전체 SVCB RRset를 거부하고 기본 연결 설정으로 돌아갈 수 있습니다.\(MAY\)

영역 운영자는 각 RRset의 최소 하나의 RR이 기본 전송을 지원하는지 확인해야 합니다. 이를 통해 가장 많은 수의 클라이언트와의 호환성이 가능해집니다.\(SHOULD\)

---
### **7.2.  "port"**

"포트" SvcParamKey는 이 대체 엔드포인트에 연결하는 데 사용해야 하는 TCP 또는 UDP 포트를 정의합니다. 이 키가 없으면 클라이언트는 기관 끝점의 포트 번호를 사용해야 합니다.\(MUST\)

SvcParamValue의 표시 값은 ASCII에서 0에서 65535 사이의 단일 십진 정수입니다. 다른 값\(예: 빈 값\)은 구문 오류입니다. 더 간단한 구문 분석을 활성화하려면 이 SvcParamValue에 이스케이프 시퀀스가 ​​포함되어서는 안 됩니다.\(MUST NOT\)

SvcParamValue의 연결 형식은 네트워크 바이트 순서로 된 해당 2옥텟 숫자 값입니다.

일부 클라이언트와 서비스 엔드포인트 사이에 포트 제한 방화벽이 있는 경우 포트 번호를 변경하면 해당 클라이언트가 서비스에 액세스하지 못할 수 있으므로 운영자는 이 SvcParamKey를 사용하여 기본이 아닌 포트를 지정할 때 주의해야 합니다.

---
### **7.3.  "ipv4hint" and "ipv6hint"**

"ipv4hint" 및 "ipv6hint" 키는 클라이언트가 서비스에 도달하는 데 사용할 수 있는 IP 주소를 전달합니다. TargetName에 대한 A 및 AAAA 레코드를 로컬에서 사용할 수 있는 경우 클라이언트는 이러한 힌트를 무시해야 합니다\(SHOULD\). 그렇지 않은 경우 클라이언트는 섹션 3에 따라 TargetName에 대해 A 및/또는 AAAA 쿼리를 수행해야 하며 클라이언트는 향후 연결을 위해 해당 응답에서 IP 주소를 사용해야 합니다. 클라이언트는 힌트의 주소를 사용하여 연결을 종료하고 대신 TargetName 쿼리에 대한 응답으로 주소로 전환하도록 선택할 수 있습니다. A 및/또는 AAAA 응답 주소를 사용하지 않으면 로드 밸런싱이나 기타 지리 인식 기능에 부정적인 영향을 미쳐 클라이언트 성능이 저하될 수 있습니다.\(MAY, SHOULD, SHOULD, MAY\)

프리젠테이션 값은 표준 텍스트 형식 \[RFC5952\] \[RFC4001\]의 해당 제품군 중 하나 이상의 IP 주소를 쉼표로 구분한 목록\(부록 A.1\)이어야 합니다. 더 간단한 구문 분석을 활성화하려면 이 SvcParamValue에 이스케이프 시퀀스가 ​​포함되어서는 안 됩니다.\(MUST, MUST NOT\)

각 매개변수의 연결 형식은 네트워크 바이트 순서로 된 IP 주소 시퀀스입니다\(해당 주소 계열에 대해\). A 또는 AAAA RRset과 마찬가지로 주소 목록은 순서가 지정되지 않은 컬렉션을 나타내며 클라이언트는 사용할 주소를 무작위 순서로 선택해야 합니다. 빈 주소 목록은 유효하지 않습니다.\(SHOULD\)

사용할 IPv4와 IPv6 주소 중에서 선택할 때 클라이언트는 Happy Eyeballs \[HappyEyeballsV2\]와 같은 접근 방식을 사용할 수 있습니다. "ipv4hint"만 있는 경우 NAT64 클라이언트는 \[RFC7050\]에 지정된 대로 IPv6 주소를 합성하거나 "ipv4hint" 키를 무시하고 AAAA 확인\(섹션 3\)을 기다릴 수 있습니다. 최상의 성능을 위해 서버 운영자는 "ipv4hint" 매개변수를 포함할 때마다 "ipv6hint" 매개변수를 포함해야 합니다.\(SHOULD\)

이러한 매개변수는 재귀 확인자가 섹션 4의 요구 사항을 준수하지 않을 때 추가 연결 대기 시간을 최소화하기 위한 것이며 대부분의 클라이언트가 호환 재귀 확인자를 사용하는 경우에는 포함되어서는 안 됩니다. TargetName이 서비스 이름 또는 소유자 이름\("."로 작성될 수 있음\)인 경우 서버 운영자는 이러한 힌트를 포함해서는 안 됩니다. 이러한 힌트는 성능 이점을 제공할 가능성이 낮기 때문입니다.\(SHOULD NOT, SHOULD NOT\)

---
### **7.4.  "mandatory"**

```text
   See Section 8.
```

---
## **8.  ServiceMode RR Compatibility and Mandatory Keys**

ServiceMode RR에서 SvcParamKey는 이 SvcParamKey를 무시하는 클라이언트에 대해 RR이 올바르게 작동하지 않는 경우 "필수"로 간주됩니다. 각 SVCB 프로토콜 매핑은 "자동으로 필수"인 키 집합을 지정해야 합니다\(SHOULD\). 즉, RR에 존재하는 경우 필수입니다. SvcParamKey "필수"는 존재하는 자동 필수 키 외에 이 RR에 대한 필수 키를 나타내는 데 사용됩니다.\(SHOULD\)

클라이언트가 모든 필수 키를 인식하고 해당 값이 성공적인 연결 설정이 가능함을 나타내는 경우 ServiceMode RR은 클라이언트에 의해 "호환 가능"하다고 간주됩니다. 호환되지 않는 RR은 무시됩니다\(섹션 3에 정의된 절차의 5단계 참조\).

프리젠테이션 값은 등록된 이름 또는 알 수 없는 키 형식\(섹션 2.1\)으로 된 하나 이상의 유효한 SvcParamKey의 쉼표로 구분된 목록\(부록 A.1\)이어야 합니다. 키는 어떤 순서로든 나타날 수 있지만 두 번 이상 나타나서는 안 됩니다. 자체 일관성\(섹션 2.4.3\)을 위해 나열된 키는 SvcParams에도 나타나야 합니다.\(MUST, MUST NOT, MUST\)

더 간단한 구문 분석을 활성화하려면 이 SvcParamValue에 이스케이프 시퀀스가 ​​포함되어서는 안 됩니다.\(MUST NOT\)

예를 들어 다음은 유효한 SvcParams 목록입니다.

```text
   ipv6hint=... key65333=ex1 key65444=ex2 mandatory=key65444,ipv6hint
```

유선 형식에서 키는 네트워크 바이트 순서의 숫자 값으로 표시되며 숫자 값은 엄격하게 증가하는 순서로 연결됩니다.

이 SvcParamKey는 항상 자동으로 필수이며 자체 값 목록에 표시되어서는 안 됩니다. 다른 자동 필수 키도 목록에 표시되어서는 안 됩니다. \(포함하면 공간이 낭비되고 그렇지 않으면 아무런 효과가 없습니다.\)\(MUST NOT, SHOULD NOT\)

---
## **9.  Using Service Bindings with HTTP**

SVCB와 함께 프로토콜을 사용하려면 프로토콜별 매핑 사양이 필요합니다. 이 섹션에서는 "http" 및 "https" URI 체계\[HTTP\]에 대한 매핑을 지정합니다.

HTTP 사용 사례에 대한 특수 처리를 활성화하기 위해 HTTPS RR 유형은 "https" 및 "http" 구성표에 특정한 SVCB 호환 RR 유형으로 정의됩니다. 클라이언트는 SVCB 쿼리를 수행하거나 "https" 또는 "http" 체계에 대한 SVCB 응답을 수락해서는 안 됩니다.\(MUST NOT\)

기록의 제시 형식은 다음과 같습니다.

이름 TTL IN HTTPS SvcPriority TargetName SvcParams

섹션 7에 정의된 모든 SvcParamKey는 HTTPS RR에서 사용이 허용됩니다. ALPN ID의 기본 세트는 단일 값 "http/1.1"입니다. "자동 필수" 키\(섹션 8\)는 "port" 및 "no-default-alpn"입니다. \(섹션 8에 설명된 대로 클라이언트는 이러한 키를 구현하거나 키가 나타나는 RR을 무시해야 합니다.\) "https" URI에서 대상 포트를 제한하는 클라이언트\(예: \[FETCH\]의 "불량 포트" 목록 사용\)는 SHOULD "포트" SvcParam에도 동일한 제한을 적용합니다.\(SHOULD\)

또한 원본에 대한 HTTPS RR이 있다는 것은 섹션 9.5에서 설명한 대로 클라이언트가 안전하게 연결하고 "https" 구성표를 사용해야 함을 나타냅니다. 이를 통해 HTTPS RR을 기존 "http" 구성표 URL에 적용하는 동시에 클라이언트가 안전하고 인증된 연결을 사용하도록 보장할 수 있습니다.

HTTPS RR은 "HTTP 대체 서비스" \[AltSvc\]에 소개된 개념과 유사합니다. HTTPS RR을 구현하는 클라이언트 및 서버는 Alt-Svc를 구현하는 데 필요하지 않습니다.

---
### **9.1.  Query Names for HTTPS RRs**

HTTPS RR은 포트 접두사 명명\(섹션 2.3\)을 사용하며 한 가지 수정 사항이 있습니다. 구성표가 "https"이고 포트가 443인 경우 클라이언트의 원래 QNAME은 서비스 이름\(예: 원본의 호스트 이름\)과 동일합니다. 접두사 레이블.

SVCB에서 사용되는 Attrleaf 레이블\[Attrleaf\]을 제거함으로써 이 구성을 통해 일반적으로 HTTP에서 사용되는 와일드카드 도메인의 오프라인 DNSSEC 서명이 가능해집니다. 접두사 없이 서비스 이름을 HTTPS 레코드의 소유자 이름으로 사용하면 기존 CNAME 체인의 대상\(예: CDN 호스트\)이 원본 도메인에서 추가 위임을 구성하고 유지하지 않고도 HTTPS RR 응답 반환을 시작할 수 있습니다.

HTTPS AliasMode RR 및 CNAME 별칭을 따르는 절차는 SVCB에서 변경되지 않았습니다\(섹션 2.4.2 및 3에 설명되어 있음\).

클라이언트는 섹션 9.5에 설명된 프로세스를 사용하여 HTTPS RR 쿼리를 수행하기 전에 항상 "http" URL을 "https"로 변환하므로 도메인 소유자는 접두사가 "\_http"인 HTTPS RR을 게시해서는 안 됩니다.\(MUST NOT\)

이러한 형식 중 어느 것도 HTTPS 원본이나 권한을 변경하지 않습니다. 예를 들어 클라이언트는 원본을 기반으로 TLS 인증서 호스트 이름의 유효성을 계속 검증해야 합니다.\(MUST\)

---
### **9.2.  Comparison with Alt-Svc**

DNS에서 ServiceMode HTTPS RR을 게시하는 것은 HTTP를 통해 Alt-Svc 필드 값을 전송하는 것과 유사하며, HTTPS RR을 수신하는 것은 HTTP를 통해 해당 필드 값을 수신하는 것과 유사합니다. 그러나 의도된 클라이언트와 서버 동작에는 약간의 차이가 있습니다.

---
#### **9.2.1.  ALPN Usage**

Alt-Svc 필드 값과 달리 HTTPS RR에는 여러 ALPN ID가 포함될 수 있습니다. 이러한 ID의 의미와 사용은 섹션 7.1.2에서 논의됩니다.

---
#### **9.2.2.  Untrusted Channels**

HTTPS 레코드는 신뢰성 보장을 요구하거나 제공하지 않습니다. \(이러한 보증을 제공하는 DNSSEC 서명 및 확인은 선택 사항입니다.\) DNS 확인 프로세스는 공격자가 제어할 수 있는 신뢰할 수 없는 채널로 모델링되므로 이 모델에서 안전하게 수신할 수 없는 Alt-Svc 매개 변수는 포함되어서는 안 됩니다. 해당 정의된 SvcParamKey. 예를 들어 Alt-Svc "persist" 매개 변수에 해당하는 SvcParamKey는 없습니다. 이 매개 변수는 신뢰할 수 없는 채널을 통해 받아들이는 것이 안전하지 않기 때문입니다.\(MUST NOT\)

---
#### **9.2.3.  Cache Lifetime**

Alt-Svc "ma"\(최대 기간\) 매개변수에 해당하는 SvcParamKey가 없습니다. 대신 서버 운영자는 DNS TTL에 만료 시간을 인코딩합니다.

적절한 TTL 값은 원하는 효율성과 민첩성에 따라 Alt-Svc에 사용되는 "ma" 값과 다를 수 있습니다. 일부 DNS 캐시는 명시된 TTL 이상으로 DNS 레코드의 수명을 잘못 연장하므로 서버 운영자는 시간에 맞춰 만료되는 HTTPS RR에 의존할 수 없습니다. 잘못된 캐싱을 보상하기 위해 TTL을 줄이는 것은 권장되지 않습니다. 이 방법은 올바르게 작동하는 캐시의 성능을 손상시키고 잘못된 캐시로 인해 더 빠른 만료가 보장되지 않기 때문입니다. 대신, 서버 운영자는 거의 모든 연결이 새 구성으로 마이그레이션되었음을 확인할 때까지 만료된 레코드와의 호환성을 유지해야 합니다.\(SHOULD NOT, SHOULD\)

---
#### **9.2.4.  Granularity**

HTTP를 통해 Alt-Svc를 보내면 서버가 Alt-Svc 필드 값을 클라이언트에 맞게 구체적으로 조정할 수 있습니다. HTTPS RR을 사용하는 경우 클라이언트 그룹은 반드시 동일한 SvcParams를 수신하게 됩니다. 따라서 HTTPS RR은 단일 클라이언트 세분성이 필요한 용도에는 적합하지 않습니다.

---
### **9.3.  Interaction with Alt-Svc**

Alt-Svc 및 HTTPS 레코드에 대한 지원을 구현하고 캐시된 Alt-Svc 응답을 기반으로 연결하는 클라이언트는 Alt-Svc alt-authority에 대한 모든 HTTPS 레코드를 검색하고 연결 시도가 Alt-Svc 및 Alt-Svc 응답과 일치하는지 확인해야 합니다. -Svc 매개변수 및 수신된 모든 HTTPS SvcParams. 존재하는 경우 HTTPS 레코드의 TargetName 및 포트가 연결 설정에 사용됩니다\(섹션 3에 따라\). 예를 들어 "https://example.com"이 다음 Alt-Svc 필드 값을 전송한다고 가정합니다.\(SHOULD\)

```text
   Alt-Svc: h2="alt.example:443", h2="alt2.example:443", h3=":8443"
```

클라이언트는 다음 HTTPS 레코드를 검색합니다.

```text
   alt.example.              IN HTTPS 1 . alpn=h2,h3 foo=...
   alt2.example.             IN HTTPS 1 alt2b.example. alpn=h3 foo=...
   _8443._https.example.com. IN HTTPS 1 alt3.example. (
       port=9443 alpn=h2,h3 foo=... )
```

이러한 입력을 기반으로 다음 연결 시도가 항상 허용됩니다.

\* HTTP/2에서 alt.example:443으로

\* HTTP/3에서 alt3.example:9443으로

\* 클라이언트의 Alt-Svc가 아닌 연결 동작으로 대체

다음 연결 시도는 허용되지 않습니다.

```text
   *  HTTP/3 to alt.example:443 (not consistent with Alt-Svc)

   *  Any connection to alt2b.example (no ALPN ID consistent with both
      the HTTPS record and Alt-Svc)

   *  HTTPS over TCP to any port on alt3.example (not consistent with
      Alt-Svc)
```

"foo"가 클라이언트를 SVCB 기반으로 렌더링하는 SvcParamKey라고 가정합니다. 다음 Alt-Svc 전용 연결 시도는 SVCB 선택적 폴백 동작에 의존하기 때문에 클라이언트가 "foo"를 지원하지 않는 경우에만 허용됩니다.

\* HTTP/2에서 alt2.example:443으로

\* example.com:8443에 대한 HTTP/3

Alt 기관은 편차가 안전하다고 특별히 알려진 경우를 제외하고 원본과 동일한 SvcParam을 전달해야 합니다. \[AltSvc\]의 섹션 2.4에 명시된 대로 클라이언트는 자신의 기준에 따라 모든 Alt-Svc 연결을 허용하지 않을 수 있습니다. 예를 들어 기관 끝점에서 사용할 수 있는 개인 정보 보호 기능에 대한 지원이 부족한 Alt-Svc 연결을 허용하지 않을 수 있습니다.\(SHOULD, MAY\)

---
### **9.4.  Requiring Server Name Indication**

클라이언트가 TLS 서버 이름 표시\(SNI\) 확장을 지원하고 TLS ClientHello\(\[ECH\]와 같은 향후 사양을 통해 암호화될 수 있음\)에서 원본 이름을 표시하지 않는 한 클라이언트는 HTTPS RR 응답을 사용해서는 안 됩니다. 이는 IP 주소 보존을 지원합니다.\(MUST NOT\)

TLS SNI\(및 HTTP "Host" 또는 ":authority"\)는 TargetName이 아닌 원본을 나타냅니다.

---
### **9.5.  HTTP Strict Transport Security (HSTS)**

HTTPS RR은 HSTS \[HSTS\]와 유사한 보안 전송을 통해서만 이 호스트와 통신하도록 클라이언트에 지시합니다. "http" 구성표 요청을 하기 전에 클라이언트는 해당 원본에 대해 HTTPS RR이 존재하는지 확인하기 위해 조회를 수행해야 합니다. 그렇게 하려면 클라이언트는 다음과 같이 해당 "https" URL을 구성해야 합니다.\(SHOULD, SHOULD\)

1. "http" 구성표를 "https"로 바꿉니다.

2. "http" URL이 명시적으로 포트 80을 지정하는 경우 포트 443을 지정합니다.

3. URL의 다른 측면을 변경하지 마십시오.

이 구성은 \[HSTS\]의 섹션 8.3, 5단계와 동일합니다.

이 "https" URL에 대한 HTTPS RR 쿼리가 AliasMode HTTPS RR 또는 호환 가능한 ServiceMode HTTPS RR\(섹션 8 참조\)을 반환하는 경우 클라이언트는 이 "https"가 포함된 HTTP 307\(임시 리디렉션\) 상태 코드를 수신한 것처럼 동작해야 합니다. " 위치" 필드의 URL입니다. \(호환되지 않는 ServiceMode RR의 수신은 리디렉션 동작을 트리거하지 않습니다.\) HTTPS RR은 종종 안전하지 않은 채널\(DNS\)을 통해 수신되므로 클라이언트는 307\(임시 리디렉션\)을 수신한 경우보다 이 신호를 더 이상 신뢰해서는 안 됩니다. \) 일반 텍스트 HTTP를 통한 응답입니다.\(SHOULD, MUST NOT\)

HTTPS RR을 게시하면 "http" 리소스가 "https" 리소스로 리디렉션되지 않거나 동일한 기본 리소스를 참조하지 않는 경우 예기치 않은 결과가 발생하거나 기능이 손실될 수 있습니다.

인증서 유효성 검사 오류와 같은 기본 보안 전송 오류로 인해 "https" 연결이 실패하는 경우 일부 클라이언트는 현재 사용자가 보안 오류를 우회하고 연결하도록 허용하는 "사용자 의지"를 제공합니다. 직접적으로 또는 위의 리디렉션을 통해 HTTPS RR을 사용하여 원본에 "https" 체계 요청을 할 때 이러한 클라이언트는 사용자 의지 옵션을 제거할 수 있습니다. 따라서 HTTPS RR을 게시하는 원본은 액세스를 위해 사용자 리소스에 의존해서는 안 됩니다. 자세한 내용은 \[HSTS\]의 섹션 8.4 및 12.1을 참조하세요.\(MAY, MUST NOT\)

---
### **9.6.  Use of HTTPS RRs in Other Protocols**

명명된 원본에 대한 모든 HTTP 연결은 HTTP가 다른 프로토콜의 일부로 사용되거나 명시적인 HTTP 관련 URI 체계\(\[HTTP\]의 섹션 4.2\) 없이 사용되는 경우에도 HTTPS RR을 사용할 수 있습니다. 예를 들어, HTTPS RR을 지원하고 \[FETCH-WEBSOCKETS\]의 변경된 열기 핸드셰이크를 사용하여 \[WebSocket\]을 구현하는 클라이언트는 요청 URL에 HTTPS RR을 사용해야 합니다.\(SHOULD\)

URL 또는 리디렉션이 적용되지 않는 컨텍스트\(예: HTTP 프록시에 대한 연결\)에서 HTTP가 사용되는 경우 해당 HTTPS RR을 찾는 클라이언트는 섹션 9.5에 지정된 것과 동일한 보안 업그레이드 동작을 구현해야 합니다.\(SHOULD\)

이러한 프로토콜은 자체 SVCB 매핑을 정의할 수 있으며, 이는 HTTPS RR보다 우선하도록 정의될 수 있습니다.\(MAY\)

---
## **10.  Zone Structures**
---
### **10.1.  Structuring Zones for Flexibility**

각 ServiceMode RRset은 단일 구성표만 제공할 수 있습니다. 구성표는 소유자 이름과 RR 유형으로 표시됩니다. 일반 SVCB RR 유형의 경우 이는 각 소유자 이름이 단일 구성표에만 사용될 수 있음을 의미합니다. 밑줄 접두사 요구 사항\(섹션 2.3\)은 이것이 초기 쿼리에 적용되도록 보장하지만 CNAME 및 AliasMode 레코드를 포함한 별칭을 사용할 때 이 제약 조건을 충족하는 이름을 선택하는 것은 영역 소유자의 책임입니다.

별칭과 함께 일반 SVCB RR 유형을 사용할 때 영역 소유자는 사용 중인 체계를 나타내는 별칭 대상 이름을 선택해야 합니다\(예: "foo" 체계의 경우 "foosvc.example.net"\). 이는 구성에 다른 구성표를 추가해야 할 때 혼란을 피하는 데 도움이 됩니다. 여러 포트 번호를 사용하는 경우 별칭 대상 이름에 접두사 레이블을 반복하는 것이 도움이 될 수 있습니다\(예: "\_1234.\_foo.svc.example.net"\).\(SHOULD\)

---
### **10.2.  Structuring Zones for Performance**

부적합 재귀 확인자를 사용하는 클라이언트의 지연을 방지하려면 도메인 소유자는 AliasMode 레코드의 사용을 최소화해야 하며 클라이언트가 A 및/또는 AAAA 쿼리를 실행할 수 있도록 클라이언트에 알려진 예측 가능한 규칙에 따라 TargetName을 선택해야 합니다. TargetName을 미리 지정합니다\(섹션 5 참조\). 달리 지정하지 않는 한 TargetName을 초기 ServiceMode 레코드의 서비스 이름으로 설정하거나 "."로 설정하는 것이 규칙입니다. 별칭을 통해 도달하는 경우.\(SHOULD\)

```text
   $ORIGIN example.com. ; Origin
   foo                  3600 IN CNAME foosvc.example.net.
   _8080._foo.foo       3600 IN CNAME foosvc.example.net.
   bar                   300 IN AAAA 2001:db8::2
   _9090._bar.bar       3600 IN SVCB 1 bar key65444=...

   $ORIGIN example.net. ; Service provider zone
   foosvc               3600 IN SVCB 1 . key65333=...
   foosvc                300 IN AAAA 2001:db8::1

           Figure 1: "foo://foo.example.com:8080" Is Available at
      "foosvc.example.net", but "bar://bar.example.com:9090" Is Served
                                  Locally
```

도메인 소유자는 DNAME 아래에 있는 TargetName을 사용하지 않아야 합니다. 이는 불필요할 가능성이 높으며 응답이 더 느리고 커질 수 있기 때문입니다. 또한 8개 이상의 별칭\(AliasMode 및 CNAME 레코드를 모두 포함\)을 따라야 하는 영역 구조는 권장되지 않습니다.\(SHOULD, SHOULD NOT\)

---
### **10.3.  Operational Considerations**

일부 권한 있는 DNS 서버는 밑줄로 시작하는 이름에 대해 A 또는 AAAA 레코드를 허용하지 않을 수 있습니다\(예: \[BIND-CHECK-NAMES\]\). 이는 TargetName에 Attrleaf 레이블이 포함되어 있거나 "."의 TargetName을 사용할 때 작동 문제를 일으킬 수 있습니다. 소유자 이름에 Attrleaf 라벨이 포함된 경우.

---
### **10.4.  Examples**
---
#### **10.4.1.  Protocol Enhancements**

다음 형식의 간단한 영역을 고려해보세요.

```text
   $ORIGIN simple.example. ; Simple example zone
   @ 300 IN A    192.0.2.1
            AAAA 2001:db8::1
```

도메인 소유자는 다음 레코드를 추가할 수 있습니다.

@7200 IN HTTPS 1 . alpn=h3

이 레코드는 "https://simple.example"이 TLS over TCP\(암시적 기본값\)를 통해 HTTP/1.1 외에도 QUIC를 지원함을 나타냅니다. 기록에는 다른 정보\(예: 비표준 포트\)도 포함될 수 있습니다. "https://simple.example:8443"의 경우 레코드는 다음과 같습니다.

\_8443.\_https 7200 IN HTTPS 1 . alpn=h3

또한 이러한 레코드는 각각 "http://simple.example" 또는 "http://simple.example:8443"을 로드할 때 구성표를 "https"로 바꾸도록 클라이언트에 지시합니다.

---
#### **10.4.2.  Apex Aliasing**

CNAME 별칭을 사용하는 영역을 고려해보세요.

```text
   $ORIGIN aliased.example. ; A zone that is using a hosting service
   ; Subdomain aliased to a high-performance server pool
   www             7200 IN CNAME pool.svc.example.
   ; Apex domain on fixed IPs because CNAME is not allowed at the apex
   @                300 IN A     192.0.2.1
                        IN AAAA  2001:db8::1
```

HTTPS RR을 사용하면 aliased.example의 소유자는 하나의 추가 레코드를 추가하여 정점에 별칭을 지정할 수 있습니다.

@ 7200 IN HTTPS 0 pool.svc.example.

이 레코드가 있으면 HTTPS-RR 인식 클라이언트는 aliased.example 및 www.aliased.example에 대해 동일한 서버 풀을 사용합니다. \(또한 "http://aliased.example/..."을 "https"로 업그레이드합니다.\) HTTPS-RR을 인식하지 않는 클라이언트는 새 레코드를 무시합니다.

CNAME과 마찬가지로 HTTPS RR은 원본 이름에 영향을 주지 않습니다. 연결 시 클라이언트는 계속해서 신뢰할 수 있는 원본을 각각 "https://www.aliased.example" 및 "https://aliased.example"로 처리하고 이에 따라 TLS 서버 인증서의 유효성을 검사합니다.

---
#### **10.4.3.  Parameter Binding**

svc.example의 기본 서버 풀은 HTTP/3을 지원하지만 백업 서버 풀은 지원하지 않는다고 가정합니다. 이는 다음과 같은 형식으로 표현될 수 있습니다.

```text
   $ORIGIN svc.example. ; A hosting provider
   pool  7200 IN HTTPS 1 . alpn=h2,h3
                 HTTPS 2 backup alpn=h2 port=8443
   pool   300 IN A        192.0.2.2
                 AAAA     2001:db8::2
   backup 300 IN A        192.0.2.3
                 AAAA     2001:db8::3
```

이 구성은 클라이언트가 HTTPS RR을 지원하는지 여부에 관계없이 "apex aliasing" 예제와 완전히 호환됩니다. 클라이언트가 HTTPS RR을 지원하는 경우 모든 연결은 HTTPS로 업그레이드되며 클라이언트는 가능한 경우 HTTP/3을 사용합니다. 매개변수는 각 서버 풀에 "바인딩"되므로 각 서버 풀은 자체 프로토콜, 포트 번호 등을 가질 수 있습니다.

---
#### **10.4.4.  Multi-CDN Configuration**

HTTPS RR은 다양한 CDN이나 호스팅 제공업체 등 여러 독립 엔터티가 운영하는 HTTPS 서비스를 지원하기 위한 것입니다. 여기에는 서비스가 한 사업자에서 다른 사업자로 마이그레이션되는 경우뿐만 아니라 성능, 중복성 등을 위해 여러 사업자 간에 서비스가 다중화되는 경우도 포함됩니다.

이 예에서는 www.customer.example이 시간이 지남에 따라 또는 권한 있는 DNS 서버 내의 논리로 인해 서로 다른 쿼리에 대해 서로 다른 DNS 응답을 갖는 구성을 보여줍니다.

; 이 영역은 다양한 CNAME 레코드를 포함/반환합니다. 서로 다른 시점에. "www"에 대한 RRset은 다음과 같습니다. 단일 CNAME만 포함합니다.

; 때때로 영역에는 $ORIGIN customer.example이 있습니다. ; 다중 CDN 고객 도메인 www 900 IN CNAME cdn1.svc1.example.

; 다른 경우에는 $ORIGIN customer.example이 포함됩니다. www 900 IN CNAME customer.svc2.example.

; 하지만 다른 경우에는 $ORIGIN customer.example이 포함됩니다. www 900 IN CNAME cdn3.svc3.example.

```text
    ; With the following remaining constant and always included:
    $ORIGIN customer.example.  ; A multi-CDN customer domain
    ; The apex is also aliased to www to match its configuration.
    @     7200 IN HTTPS 0 www
    ; Non-HTTPS-aware clients use non-CDN IPs.
                  A    203.0.113.82
                  AAAA 2001:db8:203::2

    ; Resolutions following the cdn1.svc1.example
    ; path use these records.
    ; This CDN uses a different alternative service for HTTP/3.
    $ORIGIN svc1.example.  ; domain for CDN 1
    cdn1     1800 IN HTTPS 1 h3pool alpn=h3
                     HTTPS 2 . alpn=h2
                     A    192.0.2.2
                     AAAA 2001:db8:192::4
    h3pool 300 IN A 192.0.2.3
               AAAA 2001:db8:192:7::3

    ; Resolutions following the customer.svc2.example
    ; path use these records.
    ; Note that this CDN only supports HTTP/2.
    $ORIGIN svc2.example. ; domain operated by CDN 2
    customer 300 IN HTTPS 1 . alpn=h2
              60 IN A    198.51.100.2
                    A    198.51.100.3
                    A    198.51.100.4
                    AAAA 2001:db8:198::7
                    AAAA 2001:db8:198::12

    ; Resolutions following the cdn3.svc3.example
    ; path use these records.
    ; Note that this CDN has no HTTPS records.
    $ORIGIN svc3.example. ; domain operated by CDN 3
    cdn3      60 IN A    203.0.113.8
                    AAAA 2001:db8:113::8
```

위의 예에서는 CDN마다 구성과 기능이 다르지만 클라이언트는 HTTPS RR을 함께 바인딩된 단위로 사용합니다.

도메인 소유자는 다중 CDN 구성을 사용할 때 주의해야 합니다. 이 예에서 강조된 여러 가지 복잡성이 발생하기 때문입니다.

\* CDN 1이 원하는 프로토콜이나 기능을 지원하고 CDN 2가 지원하지 않는 경우 클라이언트가 CDN 2 레코드를 가져오도록 강요하는 네트워크 공격자에 의해 클라이언트가 다운그레이드될 위험이 있습니다.

\* Apex를 해당 하위 도메인에 별칭으로 지정하면 영역 파일이 단순화되지만 특히 HTTPS를 인식하지 않는 재귀 확인자를 사용하는 경우 확인 대기 시간이 늘어날 수 있습니다. 대안은 zone apex의 별칭을 CDN에서 관리하는 이름으로 직접 지정하는 것입니다.

\* A, AAAA 및 HTTPS 해상도는 독립적인 조회이므로 확인자는 서로 다른 CDN에 대한 서로 다른 CNAME을 관찰하고 따를 수 있습니다. 따라서 클라이언트는 A 및 AAAA 응답이 HTTPS 응답의 TargetName에 해당하지 않는다는 것을 알 수 있습니다. 이러한 클라이언트는 올바른 IP 주소를 검색하기 위해 추가 쿼리를 수행해야 합니다. ipv6hint 및 ipv4hint를 포함하면 이 경우의 성능 영향이 줄어듭니다.

\* 모든 CDN이 HTTPS 레코드를 게시하지 않는 경우 클라이언트는 때때로 HTTPS 쿼리에 대해 NODATA를 수신하지만\(위의 cdn3.svc3.example과 같이\) 다른 CDN에서 A/AAAA 레코드를 수신할 수도 있습니다. 클라이언트는 HTTPS 레코드를 활용하지 않고 이 CDN에 연결을 시도합니다.

---
#### **10.4.5.  Non-HTTP Uses**

HTTP 이외의 프로토콜의 경우 SVCB RR 및 Attrleaf 레이블 \[Attrleaf\]가 사용됩니다. 예를 들어 "baz://api.example.com:8765"라는 예제 리소스에 도달하려면 다음 SVCB 레코드를 사용하여 해당 레코드의 별칭을 "svc4-baz.example.net."으로 지정하고 결과적으로 다음을 반환할 수 있습니다. ServiceMode의 AAAA/A 레코드 및/또는 SVCB 레코드:

\_8765.\_baz.api.example.com. 7200 IN SVCB 0 svc4-baz.example.net.

원본에 기본이 아닌 포트가 포함된 경우 HTTPS RR은 유사한 Attrleaf 레이블을 사용합니다.

---
## **11.  Interaction with Other Standards**

이 표준은 연결 대기 시간을 줄이고 사용자 개인 정보 보호를 향상하기 위한 것입니다. 이 표준을 구현하는 서버 운영자는 TLS 1.3 \[RFC8446\] 및 온라인 인증서 상태 프로토콜\(OCSP\) 스테이플링\(즉, \[RFC6066\] 섹션 8의 인증서 상태 요청\)도 구현해야 하며, 둘 다 함께 사용하면 상당한 성능 및 개인 정보 보호 이점을 제공합니다. SVCB 레코드를 사용합니다.\(SHOULD\)

최고의 개인 정보 보호 이점을 실현하기 위해 이 제안은 개인 정보 보호 DNS 전송\(예: DNS over TLS\[DoT\] 또는 DNS over HTTPS\[DoH\]\)을 통해 사용하기 위한 것입니다. 그러나 이러한 표준을 사용하지 않고도 성능 향상과 약간의 개인정보 보호 개선이 가능합니다.

프로토콜과 함께 SVCB를 사용하기 위한 모든 사양에는 IANA DNS "Underscored and Globally Scoped DNS Node Names" 레지스트리\[Attrleaf\]의 SVCB RR 유형 아래에 해당 체계에 대한 항목이 있어야 합니다. 체계에는 "URI\(Uniform Resource Identifier\) ​​체계" 레지스트리 \[RFC7595\]에 항목이 있어야 하며 SVCB와 함께 사용하기 위해 정의된 사양이 있어야 합니다.\(MUST, MUST\)

---
## **12.  Security Considerations**

SVCB/HTTPS RR은 신뢰할 수 없는 채널을 통한 배포를 허용하며 클라이언트는 대체 엔드포인트가 서비스에 대해 권한이 있는지 확인해야 합니다\(\[AltSvc\]의 섹션 2.1과 유사\). 따라서 SVCB 및 HTTPS RR을 게시하고 사용하기 위한 DNSSEC 서명 및 검증은 선택 사항입니다.\(MUST, MAY\)

클라이언트는 한 네트워크의 로컬 공격자가 사용자를 추적하거나 해당 네트워크를 떠난 후 연결을 방해할 수 있는 위조된 DNS 레코드를 이식하는 것을 방지하기 위해 DNS 캐시가 각 로컬 네트워크에 대해 분할되거나 네트워크 변경 시 플러시되는지 확인해야 합니다.\(MUST\)

SVCB 확인을 방해할 수 있는 공격자는 클라이언트와 관련된 모든 보안 이점을 거부할 수 있습니다. 적대적인 재귀 확인자는 항상 SVCB 쿼리에 대한 서비스를 거부할 수 있지만 클라이언트와 재귀 확인자가 DNSSEC를 검증하고 보안 전송을 사용하는 경우에도 네트워크 중개자가 확인을 방해할 수 있는 경우가 많습니다. 이러한 다운그레이드 공격은 HTTPS RR\(섹션 9.5\)에서 제공하는 "https" 업그레이드를 방지할 수 있으며 SvcParams를 통해 조정되는 다른 모든 보호 기능을 비활성화할 수 있습니다. 다운그레이드를 방지하기 위해 섹션 3.1에서는 그러한 공격이 감지되면 클라이언트가 연결 시도를 포기할 것을 권장합니다.

적대적인 DNS 중개자가 AliasMode "."를 위조할 수 있습니다. 클라이언트가 특정 서비스에 액세스하지 못하도록 차단하는 방법으로 기록합니다\(섹션 2.5.1\). 이러한 공격자는 잘못된 응답을 위조하여 이미 전체 도메인을 차단할 수 있지만 이 메커니즘을 통해 도메인 내의 특정 프로토콜이나 포트를 표적으로 삼을 수 있습니다. 그러한 공격을 받을 수 있는 클라이언트는 AliasMode "."를 무시해야 합니다. 기록.\(SHOULD\)

적대적인 DNS 중개자 또는 권한 있는 서버는 로컬 네트워크 내부의 IP 주소와 내부 서비스에 할당된 포트 번호를 포함하여 모든 IP 주소와 포트 번호를 나타내는 SVCB 레코드를 반환할 수 있습니다. 공격자가 클라이언트의 페이로드\(예: TLS 세션 티켓 콘텐츠\)에 영향을 미칠 수 있고 내부 서비스의 파서가 충분히 느슨한 경우 공격자는 내부 서비스에 액세스할 수 있습니다. \(SRV 레코드, HTTP Alt-Svc 및 HTTP 리디렉션에도 동일한 문제가 적용됩니다.\) 완화 조치로서 SVCB 매핑 문서는 지원되는 전송에 적합한 포트 번호 제한을 나타내야 합니다.\(SHOULD\)

---
## **13.  Privacy Considerations**

표준 주소 쿼리는 특정 도메인에 액세스하려는 사용자의 의도를 드러냅니다. 이 정보는 재귀 확인자 및 일반 텍스트 DNS 전송이 사용될 때 다른 많은 당사자에게 표시됩니다. SRV 레코드 및 기타 특정 RR 유형에 대한 쿼리와 같은 SVCB 쿼리는 특정 프로토콜을 사용하려는 사용자의 의도를 추가적으로 드러냅니다. 이는 일반적으로 민감한 정보가 아니지만 새 컨텍스트에서 SVCB 지원을 추가할 때 고려해야 합니다.

---
## **14.  IANA Considerations**
---
### **14.1.  SVCB RR Type**

IANA는 "DNS\(도메인 이름 시스템\) 매개변수" 페이지의 "RR\(리소스 레코드\) 유형" 레지스트리에 다음과 같은 새로운 DNS RR 유형을 등록했습니다.

```text
   Type:  SVCB
   Value:  64
   Meaning:  General-purpose service binding
   Reference:  RFC 9460
```

---
### **14.2.  HTTPS RR Type**

IANA는 "DNS\(도메인 이름 시스템\) 매개변수" 페이지의 "RR\(리소스 레코드\) 유형" 레지스트리에 다음과 같은 새로운 DNS RR 유형을 등록했습니다.

유형: HTTPS 값: 65 의미: HTTP와 함께 사용하기 위한 SVCB 호환 유형 참조: RFC 9460

---
### **14.3.  New Registry for Service Parameters**

IANA는 "DNS 서비스 바인딩\(SVCB\)"이라는 새 페이지의 "DNS\(도메인 이름 시스템\) 매개 변수" 범주에 "서비스 매개 변수 키\(SvcParamKeys\)" 레지스트리를 만들었습니다. 이 레지스트리는 문자열 표현 및 숫자 SvcParamKey 값을 포함하여 매개변수에 대한 네임스페이스를 정의합니다. 이 레지스트리는 HTTPS RR과 같은 다른 SVCB 호환 RR 유형과 공유됩니다.

---
#### **14.3.1.  Procedure**

등록에는 다음 필드가 포함되어야 합니다.\(MUST\)

번호: 와이어 형식 숫자 식별자\(범위 0-65535\) 이름: 고유한 표시 이름 의미: 간단한 설명 참조: 사양 또는 등록 소스의 위치 변경 컨트롤러: 개인 또는 엔터티\(해당하는 경우 연락처 정보 포함\)

등록된 이름 필드 항목의 문자는 소문자 영숫자 또는 "-"여야 합니다\(섹션 2.1\). 이름은 "key" 또는 "invalid"로 시작해서는 안 됩니다.\(MUST, MUST NOT\)

신규 항목에 대한 등록 정책은 전문가 검토\(\[RFC8126\], 섹션 4.5\)입니다. 지정된 전문가는 참조가 안정적이고 공개적으로 사용 가능하며 SvcParamValue의 표시 형식을 유선 형식으로 변환하는 방법을 지정하는지 확인해야 합니다. 참조는 개인의 인터넷 초안이거나 유사한 안정성과 가용성을 보장하는 다른 소스의 문서일 수 있습니다. 항목이 기존 키와 동일한 표시 및 연결 형식을 사용하는 경우 "\(다른 키 이름\)과 동일" 형식의 참조를 지정할 수 있습니다.\(MUST, MAY, MAY\)

이러한 배열은 영역 파일의 상호 운용성을 보장하는 동시에 새로운 매개변수의 개발을 지원합니다.

---
#### **14.3.2.  Initial Contents**

"서비스 매개 변수 키\(SvcParamKeys\)" 레지스트리는 다음 초기 등록으로 채워졌습니다.

```text
   +===========+=================+================+=========+==========+
   |   Number  | Name            | Meaning        |Reference|Change    |
   |           |                 |                |         |Controller|
   +===========+=================+================+=========+==========+
   |     0     | mandatory       | Mandatory      |RFC 9460,|IETF      |
   |           |                 | keys in this   |Section 8|          |
   |           |                 | RR             |         |          |
   +-----------+-----------------+----------------+---------+----------+
   |     1     | alpn            | Additional     |RFC 9460,|IETF      |
   |           |                 | supported      |Section  |          |
   |           |                 | protocols      |7.1      |          |
   +-----------+-----------------+----------------+---------+----------+
   |     2     | no-default-alpn | No support     |RFC 9460,|IETF      |
   |           |                 | for default    |Section  |          |
   |           |                 | protocol       |7.1      |          |
   +-----------+-----------------+----------------+---------+----------+
   |     3     | port            | Port for       |RFC 9460,|IETF      |
   |           |                 | alternative    |Section  |          |
   |           |                 | endpoint       |7.2      |          |
   +-----------+-----------------+----------------+---------+----------+
   |     4     | ipv4hint        | IPv4 address   |RFC 9460,|IETF      |
   |           |                 | hints          |Section  |          |
   |           |                 |                |7.3      |          |
   +-----------+-----------------+----------------+---------+----------+
   |     5     | ech             | RESERVED       |N/A      |IETF      |
   |           |                 | (held for      |         |          |
   |           |                 | Encrypted      |         |          |
   |           |                 | ClientHello)   |         |          |
   +-----------+-----------------+----------------+---------+----------+
   |     6     | ipv6hint        | IPv6 address   |RFC 9460,|IETF      |
   |           |                 | hints          |Section  |          |
   |           |                 |                |7.3      |          |
   +-----------+-----------------+----------------+---------+----------+
   |65280-65534| N/A             | Reserved for   |RFC 9460 |IETF      |
   |           |                 | Private Use    |         |          |
   +-----------+-----------------+----------------+---------+----------+
   |   65535   | N/A             | Reserved       |RFC 9460 |IETF      |
   |           |                 | ("Invalid      |         |          |
   |           |                 | key")          |         |          |
   +-----------+-----------------+----------------+---------+----------+

                                  Table 1
```

---
### **14.4.  Other Registry Updates**

\[Attrleaf\]에 따라 DNS "Underscored and Globally Scoped DNS Node Names" 레지스트리에 다음 항목이 추가되었습니다.

```text
                   +=========+============+===========+
                   | RR Type | _NODE NAME | Reference |
                   +=========+============+===========+
                   | HTTPS   | _https     | RFC 9460  |
                   +---------+------------+-----------+

                                 Table 2
```

---
## **15.  References**
---
### **15.1.  Normative References**

```text
   [ALPN]     Friedl, S., Popov, A., Langley, A., and E. Stephan,
              "Transport Layer Security (TLS) Application-Layer Protocol
              Negotiation Extension", RFC 7301, DOI 10.17487/RFC7301,
              July 2014, <https://www.rfc-editor.org/info/rfc7301>.

   [Attrleaf] Crocker, D., "Scoped Interpretation of DNS Resource
              Records through "Underscored" Naming of Attribute Leaves",
              BCP 222, RFC 8552, DOI 10.17487/RFC8552, March 2019,
              <https://www.rfc-editor.org/info/rfc8552>.

   [DoH]      Hoffman, P. and P. McManus, "DNS Queries over HTTPS
              (DoH)", RFC 8484, DOI 10.17487/RFC8484, October 2018,
              <https://www.rfc-editor.org/info/rfc8484>.

   [DoT]      Hu, Z., Zhu, L., Heidemann, J., Mankin, A., Wessels, D.,
              and P. Hoffman, "Specification for DNS over Transport
              Layer Security (TLS)", RFC 7858, DOI 10.17487/RFC7858, May
              2016, <https://www.rfc-editor.org/info/rfc7858>.

   [HappyEyeballsV2]
              Schinazi, D. and T. Pauly, "Happy Eyeballs Version 2:
              Better Connectivity Using Concurrency", RFC 8305,
              DOI 10.17487/RFC8305, December 2017,
              <https://www.rfc-editor.org/info/rfc8305>.

   [HTTP]     Fielding, R., Ed., Nottingham, M., Ed., and J. Reschke,
              Ed., "HTTP Semantics", STD 97, RFC 9110,
              DOI 10.17487/RFC9110, June 2022,
              <https://www.rfc-editor.org/info/rfc9110>.

   [RFC1034]  Mockapetris, P., "Domain names - concepts and facilities",
              STD 13, RFC 1034, DOI 10.17487/RFC1034, November 1987,
              <https://www.rfc-editor.org/info/rfc1034>.

   [RFC1035]  Mockapetris, P., "Domain names - implementation and
              specification", STD 13, RFC 1035, DOI 10.17487/RFC1035,
              November 1987, <https://www.rfc-editor.org/info/rfc1035>.

   [RFC1928]  Leech, M., Ganis, M., Lee, Y., Kuris, R., Koblas, D., and
              L. Jones, "SOCKS Protocol Version 5", RFC 1928,
              DOI 10.17487/RFC1928, March 1996,
              <https://www.rfc-editor.org/info/rfc1928>.

   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", BCP 14, RFC 2119,
              DOI 10.17487/RFC2119, March 1997,
              <https://www.rfc-editor.org/info/rfc2119>.

   [RFC2181]  Elz, R. and R. Bush, "Clarifications to the DNS
              Specification", RFC 2181, DOI 10.17487/RFC2181, July 1997,
              <https://www.rfc-editor.org/info/rfc2181>.

   [RFC3225]  Conrad, D., "Indicating Resolver Support of DNSSEC",
              RFC 3225, DOI 10.17487/RFC3225, December 2001,
              <https://www.rfc-editor.org/info/rfc3225>.

   [RFC3597]  Gustafsson, A., "Handling of Unknown DNS Resource Record
              (RR) Types", RFC 3597, DOI 10.17487/RFC3597, September
              2003, <https://www.rfc-editor.org/info/rfc3597>.

   [RFC4001]  Daniele, M., Haberman, B., Routhier, S., and J.
              Schoenwaelder, "Textual Conventions for Internet Network
              Addresses", RFC 4001, DOI 10.17487/RFC4001, February 2005,
              <https://www.rfc-editor.org/info/rfc4001>.

   [RFC5234]  Crocker, D., Ed. and P. Overell, "Augmented BNF for Syntax
              Specifications: ABNF", STD 68, RFC 5234,
              DOI 10.17487/RFC5234, January 2008,
              <https://www.rfc-editor.org/info/rfc5234>.

   [RFC5952]  Kawamura, S. and M. Kawashima, "A Recommendation for IPv6
              Address Text Representation", RFC 5952,
              DOI 10.17487/RFC5952, August 2010,
              <https://www.rfc-editor.org/info/rfc5952>.

   [RFC6066]  Eastlake 3rd, D., "Transport Layer Security (TLS)
              Extensions: Extension Definitions", RFC 6066,
              DOI 10.17487/RFC6066, January 2011,
              <https://www.rfc-editor.org/info/rfc6066>.

   [RFC6147]  Bagnulo, M., Sullivan, A., Matthews, P., and I. van
              Beijnum, "DNS64: DNS Extensions for Network Address
              Translation from IPv6 Clients to IPv4 Servers", RFC 6147,
              DOI 10.17487/RFC6147, April 2011,
              <https://www.rfc-editor.org/info/rfc6147>.

   [RFC7050]  Savolainen, T., Korhonen, J., and D. Wing, "Discovery of
              the IPv6 Prefix Used for IPv6 Address Synthesis",
              RFC 7050, DOI 10.17487/RFC7050, November 2013,
              <https://www.rfc-editor.org/info/rfc7050>.

   [RFC7231]  Fielding, R., Ed. and J. Reschke, Ed., "Hypertext Transfer
              Protocol (HTTP/1.1): Semantics and Content", RFC 7231,
              DOI 10.17487/RFC7231, June 2014,
              <https://www.rfc-editor.org/info/rfc7231>.

   [RFC7595]  Thaler, D., Ed., Hansen, T., and T. Hardie, "Guidelines
              and Registration Procedures for URI Schemes", BCP 35,
              RFC 7595, DOI 10.17487/RFC7595, June 2015,
              <https://www.rfc-editor.org/info/rfc7595>.

   [RFC7871]  Contavalli, C., van der Gaast, W., Lawrence, D., and W.
              Kumari, "Client Subnet in DNS Queries", RFC 7871,
              DOI 10.17487/RFC7871, May 2016,
              <https://www.rfc-editor.org/info/rfc7871>.

   [RFC8126]  Cotton, M., Leiba, B., and T. Narten, "Guidelines for
              Writing an IANA Considerations Section in RFCs", BCP 26,
              RFC 8126, DOI 10.17487/RFC8126, June 2017,
              <https://www.rfc-editor.org/info/rfc8126>.

   [RFC8174]  Leiba, B., "Ambiguity of Uppercase vs Lowercase in RFC
              2119 Key Words", BCP 14, RFC 8174, DOI 10.17487/RFC8174,
              May 2017, <https://www.rfc-editor.org/info/rfc8174>.

   [RFC8446]  Rescorla, E., "The Transport Layer Security (TLS) Protocol
              Version 1.3", RFC 8446, DOI 10.17487/RFC8446, August 2018,
              <https://www.rfc-editor.org/info/rfc8446>.

   [WebSocket]
              Fette, I. and A. Melnikov, "The WebSocket Protocol",
              RFC 6455, DOI 10.17487/RFC6455, December 2011,
              <https://www.rfc-editor.org/info/rfc6455>.
```

---
### **15.2.  Informative References**

```text
   [AltSvc]   Nottingham, M., McManus, P., and J. Reschke, "HTTP
              Alternative Services", RFC 7838, DOI 10.17487/RFC7838,
              April 2016, <https://www.rfc-editor.org/info/rfc7838>.

   [ANAME-DNS-RR]
              Finch, T., Hunt, E., van Dijk, P., Eden, A., and W.
              Mekking, "Address-specific DNS aliases (ANAME)", Work in
              Progress, Internet-Draft, draft-ietf-dnsop-aname-04, 8
              July 2019, <https://datatracker.ietf.org/doc/html/draft-
              ietf-dnsop-aname-04>.

   [BIND-CHECK-NAMES]
              Internet Systems Consortium, "BIND v9.19.11 Configuration
              Reference: "check-names"", September 2023,
              <https://bind9.readthedocs.io/en/v9.19.11/
              reference.html#namedconf-statement-check-names>.

   [DNAME]    Rose, S. and W. Wijngaards, "DNAME Redirection in the
              DNS", RFC 6672, DOI 10.17487/RFC6672, June 2012,
              <https://www.rfc-editor.org/info/rfc6672>.

   [DNSTerm]  Hoffman, P., Sullivan, A., and K. Fujiwara, "DNS
              Terminology", BCP 219, RFC 8499, DOI 10.17487/RFC8499,
              January 2019, <https://www.rfc-editor.org/info/rfc8499>.

   [ECH]      Rescorla, E., Oku, K., Sullivan, N., and C. A. Wood, "TLS
              Encrypted Client Hello", Work in Progress, Internet-Draft,
              draft-ietf-tls-esni-17, 9 October 2023,
              <https://datatracker.ietf.org/doc/html/draft-ietf-tls-
              esni-17>.

   [FETCH]    WHATWG, "Fetch Living Standard", October 2023,
              <https://fetch.spec.whatwg.org/>.

   [FETCH-WEBSOCKETS]
              WHATWG, "WebSockets Living Standard", September 2023,
              <https://websockets.spec.whatwg.org/>.

   [HSTS]     Hodges, J., Jackson, C., and A. Barth, "HTTP Strict
              Transport Security (HSTS)", RFC 6797,
              DOI 10.17487/RFC6797, November 2012,
              <https://www.rfc-editor.org/info/rfc6797>.

   [HTTP-DNS-RR]
              Bellis, R., "A DNS Resource Record for HTTP", Work in
              Progress, Internet-Draft, draft-bellis-dnsop-http-record-
              00, 3 November 2018,
              <https://datatracker.ietf.org/doc/html/draft-bellis-dnsop-
              http-record-00>.

   [HTTP/3]   Bishop, M., Ed., "HTTP/3", RFC 9114, DOI 10.17487/RFC9114,
              June 2022, <https://www.rfc-editor.org/info/rfc9114>.

   [RFC1912]  Barr, D., "Common DNS Operational and Configuration
              Errors", RFC 1912, DOI 10.17487/RFC1912, February 1996,
              <https://www.rfc-editor.org/info/rfc1912>.

   [RFC6454]  Barth, A., "The Web Origin Concept", RFC 6454,
              DOI 10.17487/RFC6454, December 2011,
              <https://www.rfc-editor.org/info/rfc6454>.

   [SRV]      Gulbrandsen, A., Vixie, P., and L. Esibov, "A DNS RR for
              specifying the location of services (DNS SRV)", RFC 2782,
              DOI 10.17487/RFC2782, February 2000,
              <https://www.rfc-editor.org/info/rfc2782>.

   [URI]      Berners-Lee, T., Fielding, R., and L. Masinter, "Uniform
              Resource Identifier (URI): Generic Syntax", STD 66,
              RFC 3986, DOI 10.17487/RFC3986, January 2005,
              <https://www.rfc-editor.org/info/rfc3986>.
```

---
# **Appendix A.  Decoding Text in Zone Files**

DNS 영역 파일은 \[RFC1035\]의 섹션 5.1에 정의된 알고리즘에 따라 다양한 구분 기호와 인코딩을 사용하여 기본 ASCII 텍스트의 임의 옥텟 시퀀스를 나타낼 수 있습니다. 다음은 ABNF를 사용하여 해당 알고리즘에 허용되는 일부 입력을 요약한 것입니다.

```text
   ; non-special is VCHAR minus DQUOTE, ";", "(", ")", and "\".
   non-special = %x21 / %x23-27 / %x2A-3A / %x3C-5B / %x5D-7E
   ; non-digit is VCHAR minus DIGIT.
   non-digit   = %x21-2F / %x3A-7E
   ; dec-octet is a number 0-255 as a three-digit decimal number.
   dec-octet   = ( "0" / "1" ) 2DIGIT /
                 "2" ( ( %x30-34 DIGIT ) / ( "5" %x30-35 ) )
   escaped     = "\" ( non-digit / dec-octet )
   contiguous  = 1*( non-special / escaped )
   quoted      = DQUOTE *( contiguous / ( ["\"] WSP ) ) DQUOTE
   char-string = contiguous / quoted
```

디코딩 알고리즘을 사용하면 그룹 값\(예: 내부 공백이 있는 값\)에 따옴표를 사용하고 인쇄할 수 없는 각 옥텟을 단일 이스케이프 시퀀스로 나타내기 위해 이스케이프하여 char-string이 모든 \*OCTET을 나타낼 수 있습니다. 이 문서에서는 이 알고리즘을 "문자열 디코딩"이라고 합니다. \[RFC1035\]의 섹션 5.1에서 이 알고리즘을 사용하여 <문자열\>을 생성하기 때문입니다. <문자열\>의 길이는 255옥텟으로 제한되어 있지만 문자열 디코딩 알고리즘은 모든 길이의 출력을 생성할 수 있습니다.

---
### **A.1.  Decoding a Comma-Separated List**

영역 파일의 항목 목록을 나타내기 위해 이 사양에서는 쉼표로 구분된 목록을 사용합니다. 목록의 허용된 항목에 "," 또는 "\"가 포함될 수 없는 경우 이는 간단합니다. \(단순화를 위해 빈 항목은 허용되지 않습니다.\) ","로 분할되고 "\"가 포함된 항목을 금지하는 값 목록 파서는 이 문서의 모든 요구 사항을 준수하기에 충분합니다. 이는 간단한 쉼표로 구분된 구문에 해당합니다.

```text
   ; item-allowed is OCTET minus "," and "\".
   item-allowed           = %x00-2B / %x2D-5B / %x5D-FF
   simple-item            = 1*item-allowed
   simple-comma-separated = [simple-item *("," simple-item)]
```

항목 값에 "," 및 "\"를 허용하는 구현의 경우 다음 이스케이프 구문이 적용됩니다.

```text
   item            = 1*OCTET
   escaped-item    = 1*(item-allowed / "\," / "\\")
   comma-separated = [escaped-item *("," escaped-item)]
```

값 목록의 디코딩은 문자열 디코딩 후에 발생합니다. 예를 들어 다음 문자 문자열 SvcParamValues를 고려해보세요.

```text
   "part1,part2,part3\\,part4\\\\"
   part1\,\p\a\r\t2\044part3\092,part4\092\\
```

이러한 입력은 동일합니다. 둘 중 하나의 문자열 디코딩은 동일한 값을 생성합니다.

```text
   part1,part2,part3\,part4\\
```

이 값에 쉼표로 구분된 목록 디코딩을 적용하면 다음 세 가지 항목의 목록이 생성됩니다.

```text
   part1
   part2
   part3,part4\
```

---
# **Appendix B.  HTTP Mapping Summary**

이 표는 SVCB\(섹션 9\)에 대한 HTTP 매핑에 대한 비표준적인 요약 역할을 합니다. 향후 프로토콜 매핑에서는 유사한 요약 테이블을 제공할 수 있습니다.

```text
            +--------------------------+----------------------+
            | *Mapped scheme*          | "https"              |
            +--------------------------+----------------------+
            | *Other affected schemes* | "http", "wss", "ws", |
            |                          | (other HTTP-based)   |
            +--------------------------+----------------------+
            | *RR type*                | HTTPS (65)           |
            +--------------------------+----------------------+
            | *Name prefix*            | None for port 443,   |
            |                          | else _$PORT._https   |
            +--------------------------+----------------------+
            | *Automatically mandatory | port, no-default-    |
            | keys*                    | alpn                 |
            +--------------------------+----------------------+
            | *SvcParam defaults*      | alpn: ["http/1.1"]   |
            +--------------------------+----------------------+
            | *Special behaviors*      | Upgrade from HTTP to |
            |                          | HTTPS                |
            +--------------------------+----------------------+
            | *Keys that records must  | None                 |
            | include*                 |                      |
            +--------------------------+----------------------+

                                  Table 3
```

---
# **Appendix C.  Comparison with Alternatives**

SVCB 및 HTTPS RR 유형은 일부 기존 레코드 유형 및 제안과 매우 유사하며 영감을 받았습니다. 모든 대안에 대한 한 가지 불만은 웹 클라이언트가 대안 구현에 열의가 없어 보인다는 것입니다. 여기서 희망하는 것은 여러 문제를 해결하는 확장 가능한 솔루션이 이러한 관성을 극복하고 클라이언트 구현을 달성할 수 있는 경로를 갖게 된다는 것입니다.

---
### **C.1.  Differences from the SRV RR Type**

SRV 레코드\[SRV\]는 SVCB 레코드와 유사한 기능을 수행하여 클라이언트에게 서비스를 위해 다른 위치를 찾도록 알립니다. 그러나 몇 가지 차이점이 있습니다.

\* SRV 레코드는 일반적으로 필수인 반면, SVCB는 기존 프로토콜과 함께 사용할 경우 선택 사항입니다.

\* SRV 레코드는 클라이언트에게 프로토콜을 전환하거나 업그레이드하도록 지시할 수 없는 반면, SVCB는 그러한 업그레이드\(예: HTTP/2로\)를 알릴 수 있습니다.

\* SRV 레코드는 확장할 수 없지만 SVCB 및 HTTPS RR은 새로운 매개변수를 사용하여 확장할 수 있습니다.

\* SRV 레코드는 불균형 무작위 로드 밸런싱에 대한 "가중치"를 지정합니다. SVCB는 균형 잡힌 무작위 로드 밸런싱만 지원하지만 향후 SvcParam을 통해 가중치를 추가할 수 있습니다.

---
### **C.2.  Differences from the Proposed HTTP Record**

\[HTTP-DNS-RR\]과 달리 이 접근 방식은 Alt-Svc 및 암호화된 ClientHello 사용 사례를 포괄하도록 확장 가능합니다. 해당 제안과 마찬가지로 이는 zone-apex CNAME 문제를 해결합니다.

해당 제안과 마찬가지로 레거시 클라이언트의 zone apex에 주소 레코드를 계속 포함하는 것이 필요합니다.

---
### **C.3.  Differences from the Proposed ANAME Record**

\[ANAME-DNS-RR\]과 달리 이 접근 방식은 Alt-Svc 및 암호화된 ClientHello 사용 사례를 포괄하도록 확장 가능합니다. 또한 이 접근 방식은 선택적으로 베일리윅 내 추가 레코드를 반환하는 것 외에 권한 있는 서버나 기본 서버에서 변경 사항이나 특별한 처리가 필요하지 않습니다.

해당 제안과 마찬가지로 이를 구현하는 클라이언트의 zone-apex CNAME 문제를 해결합니다.

그러나 이 SVCB 제안에서는 레거시 클라이언트의 zone apex에 주소 레코드를 계속 포함해야 합니다. 이 표준이 성공적으로 배포되면 레거시 클라이언트 수가 시간이 지남에 따라 감소합니다. 레거시 클라이언트 수가 감소함에 따라 SVCB 간접 참조의 이점 없이 이러한 사용자에게 서비스를 제공하는 데 필요한 운영 노력도 줄어들 것입니다. 서버 운영자는 이 레거시 엔드포인트에 도달하는 트래픽의 양을 쉽게 관찰할 수 있으며 관찰된 레거시 트래픽이 무시할 수 있는 수준으로 떨어진 경우 정점의 주소 레코드를 제거할 수 있습니다.

---
### **C.4.  Comparison with Separate RR Types for AliasMode and ServiceMode**

추상적으로 AliasMode와 ServiceMode의 기능은 독립적이므로 별도의 RR 유형으로 지정하고 싶을 수도 있습니다. 그러나 이렇게 하면 클라이언트가 재귀 확인자에 의존하여 SVCB 별칭\(CNAME과 달리\)을 따를 수 없기 때문에 심각한 성능 저하가 발생할 수 있습니다. 따라서 클라이언트는 잠재적으로 별칭 체인의 각 단계에서 두 RR 유형에 대해 병렬로 쿼리를 실행해야 합니다. 사양을 구현하는 재귀 확인자는 ServiceMode 쿼리를 받으면 ServiceMode 쿼리와 AliasMode 쿼리를 모두 권한 있는 DNS 서버에 내보냅니다. 따라서 RR 유형을 분할하면 클라이언트와 서버의 로드가 두 배, 어떤 경우에는 세 배로 늘어나고 구현 복잡성이 줄어들지 않습니다.

---
# **Appendix D.  Test Vectors**

이러한 테스트 벡터에는 프레젠테이션 형식, 일반 형식\[RFC3597\] 및 유선 형식의 SVCB/HTTPS 레코드의 RDATA 부분만 포함됩니다. 연결 형식은 ASCII가 아닌 각 바이트에 대해 16진수\(\xNN\)를 사용합니다. 와이어 형식이 길기 때문에 여러 줄로 나누어집니다.

---
### **D.1.  AliasMode**

```text
   example.com.   HTTPS   0 foo.example.com.

   \# 19 (
   00 00                                              ; priority
   03 66 6f 6f 07 65 78 61 6d 70 6c 65 03 63 6f 6d 00 ; target
   )

   \x00\x00                                           # priority
   \x03foo\x07example\x03com\x00                      # target

                            Figure 2: AliasMode
```

---
### **D.2.  ServiceMode**

```text
   example.com.   SVCB   1 .

   \# 3 (
   00 01      ; priority
   00         ; target (root label)
   )

   \x00\x01   # priority
   \x00       # target (root label)

                        Figure 3: TargetName Is "."

   example.com.   SVCB   16 foo.example.com. port=53

   \# 25 (
   00 10                                              ; priority
   03 66 6f 6f 07 65 78 61 6d 70 6c 65 03 63 6f 6d 00 ; target
   00 03                                              ; key 3
   00 02                                              ; length 2
   00 35                                              ; value
   )

   \x00\x10                                           # priority
   \x03foo\x07example\x03com\x00                      # target
   \x00\x03                                           # key 3
   \x00\x02                                           # length 2
   \x00\x35                                           # value

                         Figure 4: Specifies a Port

   example.com.   SVCB   1 foo.example.com. key667=hello

   \# 28 (
   00 01                                              ; priority
   03 66 6f 6f 07 65 78 61 6d 70 6c 65 03 63 6f 6d 00 ; target
   02 9b                                              ; key 667
   00 05                                              ; length 5
   68 65 6c 6c 6f                                     ; value
   )

   \x00\x01                                           # priority
   \x03foo\x07example\x03com\x00                      # target
   \x02\x9b                                           # key 667
   \x00\x05                                           # length 5
   hello                                              # value

                 Figure 5: A Generic Key and Unquoted Value

   example.com.   SVCB   1 foo.example.com. key667="hello\210qoo"

   \# 32 (
   00 01                                              ; priority
   03 66 6f 6f 07 65 78 61 6d 70 6c 65 03 63 6f 6d 00 ; target
   02 9b                                              ; key 667
   00 09                                              ; length 9
   68 65 6c 6c 6f d2 71 6f 6f                         ; value
   )

   \x00\x01                                           # priority
   \x03foo\x07example\x03com\x00                      # target
   \x02\x9b                                           # key 667
   \x00\x09                                           # length 9
   hello\xd2qoo                                       # value

       Figure 6: A Generic Key and Quoted Value with a Decimal Escape

   example.com.   SVCB   1 foo.example.com. (
                         ipv6hint="2001:db8::1,2001:db8::53:1"
                         )

   \# 55 (
   00 01                                              ; priority
   03 66 6f 6f 07 65 78 61 6d 70 6c 65 03 63 6f 6d 00 ; target
   00 06                                              ; key 6
   00 20                                              ; length 32
   20 01 0d b8 00 00 00 00 00 00 00 00 00 00 00 01    ; first address
   20 01 0d b8 00 00 00 00 00 00 00 00 00 53 00 01    ; second address
   )

   \x00\x01                                           # priority
   \x03foo\x07example\x03com\x00                      # target
   \x00\x06                                           # key 6
   \x00\x20                                           # length 32
   \x20\x01\x0d\xb8\x00\x00\x00\x00
        \x00\x00\x00\x00\x00\x00\x00\x01              # first address
   \x20\x01\x0d\xb8\x00\x00\x00\x00
        \x00\x00\x00\x00\x00\x53\x00\x01              # second address

                      Figure 7: Two Quoted IPv6 Hints

   example.com.   SVCB   1 example.com. (
                           ipv6hint="2001:db8:122:344::192.0.2.33"
                           )
   \# 35 (
   00 01                                              ; priority
   07 65 78 61 6d 70 6c 65 03 63 6f 6d 00             ; target
   00 06                                              ; key 6
   00 10                                              ; length 16
   20 01 0d b8 01 22 03 44 00 00 00 00 c0 00 02 21    ; address
   )

   \x00\x01                                           # priority
   \x07example\x03com\x00                             # target
   \x00\x06                                           # key 6
   \x00\x10                                           # length 16
   \x20\x01\x0d\xb8\x01\x22\x03\x44
        \x00\x00\x00\x00\xc0\x00\x02\x21              # address

           Figure 8: An IPv6 Hint Using the Embedded IPv4 Syntax

   example.com.   SVCB   16 foo.example.org. (
                         alpn=h2,h3-19 mandatory=ipv4hint,alpn
                         ipv4hint=192.0.2.1
                         )

   \# 48 (
   00 10                                              ; priority
   03 66 6f 6f 07 65 78 61 6d 70 6c 65 03 6f 72 67 00 ; target
   00 00                                              ; key 0
   00 04                                              ; param length 4
   00 01                                              ; value: key 1
   00 04                                              ; value: key 4
   00 01                                              ; key 1
   00 09                                              ; param length 9
   02                                                 ; alpn length 2
   68 32                                              ; alpn value
   05                                                 ; alpn length 5
   68 33 2d 31 39                                     ; alpn value
   00 04                                              ; key 4
   00 04                                              ; param length 4
   c0 00 02 01                                        ; param value
   )

   \x00\x10                                           # priority
   \x03foo\x07example\x03org\x00                      # target
   \x00\x00                                           # key 0
   \x00\x04                                           # param length 4
   \x00\x01                                           # value: key 1
   \x00\x04                                           # value: key 4
   \x00\x01                                           # key 1
   \x00\x09                                           # param length 9
   \x02                                               # alpn length 2
   h2                                                 # alpn value
   \x05                                               # alpn length 5
   h3-19                                              # alpn value
   \x00\x04                                           # key 4
   \x00\x04                                           # param length 4
   \xc0\x00\x02\x01                                   # param value

        Figure 9: SvcParamKey Ordering Is Arbitrary in Presentation
                      Format but Sorted in Wire Format

   example.com.   SVCB   16 foo.example.org. alpn="f\\\\oo\\,bar,h2"
   example.com.   SVCB   16 foo.example.org. alpn=f\\\092oo\092,bar,h2

   \# 35 (
   00 10                                              ; priority
   03 66 6f 6f 07 65 78 61 6d 70 6c 65 03 6f 72 67 00 ; target
   00 01                                              ; key 1
   00 0c                                              ; param length 12
   08                                                 ; alpn length 8
   66 5c 6f 6f 2c 62 61 72                            ; alpn value
   02                                                 ; alpn length 2
   68 32                                              ; alpn value
   )

   \x00\x10                                           # priority
   \x03foo\x07example\x03org\x00                      # target
   \x00\x01                                           # key 1
   \x00\x0c                                           # param length 12
   \x08                                               # alpn length 8
   f\oo,bar                                           # alpn value
   \x02                                               # alpn length 2
   h2                                                 # alpn value
```

- 그림 10: 두 가지 표시 형식에서 이스케이프된 쉼표와 이스케이프된 백슬래시가 있는 "alpn" 값

---
### **D.3.  Failure Cases**

이 하위 섹션에는 이 문서를 준수하지 않는 테스트 벡터가 포함되어 있습니다. 규정을 준수하지 않는 다양한 이유가 각 예에 설명되어 있습니다.

```text
   example.com.   SVCB   1 foo.example.com. (
                          key123=abc key123=def
                          )

           Figure 11: Multiple Instances of the Same SvcParamKey

   example.com.   SVCB   1 foo.example.com. mandatory
   example.com.   SVCB   1 foo.example.com. alpn
   example.com.   SVCB   1 foo.example.com. port
   example.com.   SVCB   1 foo.example.com. ipv4hint
   example.com.   SVCB   1 foo.example.com. ipv6hint

          Figure 12: Missing SvcParamValues That Must Be Non-Empty

   example.com.   SVCB   1 foo.example.com. no-default-alpn=abc
```

- 그림 13: "no-default-alpn" SvcParamKey 값은 비어 있어야 합니다.

```text
   example.com.   SVCB   1 foo.example.com. mandatory=key123

                 Figure 14: A Mandatory SvcParam Is Missing

   example.com.   SVCB   1 foo.example.com. mandatory=mandatory

       Figure 15: The "mandatory" SvcParamKey Must Not Be Included in
                             the Mandatory List

   example.com.   SVCB   1 foo.example.com. (
                         mandatory=key123,key123 key123=abc
                         )

        Figure 16: Multiple Instances of the Same SvcParamKey in the
                               Mandatory List
```

---
# **Acknowledgments and Related Proposals**

수년에 걸쳐 IETF 참가자들은 \[HTTP-DNS-RR\], \[ANAME-DNS-RR\] 등을 포함하여 "CNAME at the zone apex" 과제에 대한 광범위한 솔루션을 제안해 왔습니다. 저자들은 문제를 설명하고 이를 해결하기 위한 유망한 전략을 식별한 작업에 감사하며 그 중 일부는 이 문서에 반영되어 있습니다.

Ian Swett, Ralf Weber, Jon Reed, Martin Thomson, Lucas Pardue, Ilari Liusvaara, Tim Wicinski, Tommy Pauly, Chris Wood, David Benjamin, Mark Andrews, Emily Stark, Eric Orth, Kyle Rose, Craig Taylor, Dan McArdle에게 감사드립니다. , Brian Dickson, Willem Toorop, Pieter Lexis, Puneet Sood, Olivier Poitrey, Mashooq Muhaimen, Tom Carpay 및 이 문서에 대한 피드백과 제안을 주신 많은 분들.

---
# **Authors' Addresses**

```text
   Ben Schwartz
   Meta Platforms, Inc.
   Email: ietf@bemasc.net

   Mike Bishop
   Akamai Technologies
   Email: mbishop@evequefou.be

   Erik Nygren
   Akamai Technologies
   Email: erik+ietf@nygren.org
```
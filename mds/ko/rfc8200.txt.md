

```text
Internet Engineering Task Force (IETF)                        S. Deering
Request for Comments: 8200                                       Retired
STD: 86                                                        R. Hinden
Obsoletes: 2460                                     Check Point Software
Category: Standards Track                                      July 2017
ISSN: 2070-1721

           Internet Protocol, Version 6 (IPv6) Specification
```

---
# **Abstract**

이 문서에서는 인터넷 프로토콜\(IPv6\) 버전 6을 지정합니다. RFC 2460은 더 이상 사용되지 않습니다.

---
# **Status of This Memo**

이것은 인터넷 표준 추적 문서입니다.

이 문서는 IETF\(Internet Engineering Task Force\)의 제품입니다. 이는 IETF 커뮤니티의 합의를 나타냅니다. 공개 검토를 받았으며 IESG\(Internet Engineering Steering Group\)의 출판 승인을 받았습니다. 인터넷 표준에 대한 자세한 내용은 RFC 7841의 섹션 2에서 확인할 수 있습니다.

이 문서의 현재 상태, 정오표, 피드백 제공 방법에 대한 정보는 http://www.rfc-editor.org/info/rfc8200에서 얻을 수 있습니다.

---
# **Copyright Notice**

Copyright \(c\) 2017 IETF Trust 및 문서 작성자로 확인된 사람. 판권 소유.

이 문서는 이 문서의 발행일에 유효한 BCP 78 및 IETF 문서에 관한 IETF 트러스트의 법적 조항\(http://trustee.ietf.org/license-info\)의 적용을 받습니다. 이 문서와 관련된 귀하의 권리 및 제한 사항을 설명하므로 이 문서를 주의 깊게 검토하십시오. 이 문서에서 추출한 코드 구성 요소는 Trust Legal Provisions의 섹션 4.e에 설명된 대로 Simplified BSD License 텍스트를 포함해야 하며 Simplified BSD License에 설명된 대로 보증 없이 제공됩니다.

이 문서에는 2008년 11월 10일 이전에 공개되거나 공개된 IETF 문서 또는 IETF 기고문의 자료가 포함될 수 있습니다. 이 자료의 일부에 대한 저작권을 제어하는 ​​사람은 해당 자료의 수정을 허용할 권리를 IETF 트러스트에 부여하지 않았을 수 있습니다. IETF 표준 프로세스 외부. 이러한 자료의 저작권을 관리하는 사람으로부터 적절한 라이센스를 얻지 않고 이 문서는 IETF 표준 프로세스 외부에서 수정할 수 없으며 IETF 표준 프로세스 외부에서 이 문서의 파생물을 생성할 수 없습니다. RFC로 게시하거나 영어 이외의 언어로 번역합니다.

---
# **Table of Contents**

```text
   1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   4
   2.  Terminology . . . . . . . . . . . . . . . . . . . . . . . . .   5
   3.  IPv6 Header Format  . . . . . . . . . . . . . . . . . . . . .   6
   4.  IPv6 Extension Headers  . . . . . . . . . . . . . . . . . . .   7
     4.1.  Extension Header Order  . . . . . . . . . . . . . . . . .  10
     4.2.  Options . . . . . . . . . . . . . . . . . . . . . . . . .  11
     4.3.  Hop-by-Hop Options Header . . . . . . . . . . . . . . . .  13
     4.4.  Routing Header  . . . . . . . . . . . . . . . . . . . . .  14
     4.5.  Fragment Header . . . . . . . . . . . . . . . . . . . . .  15
     4.6.  Destination Options Header  . . . . . . . . . . . . . . .  23
     4.7.  No Next Header  . . . . . . . . . . . . . . . . . . . . .  24
     4.8.  Defining New Extension Headers and Options  . . . . . . .  24
   5.  Packet Size Issues  . . . . . . . . . . . . . . . . . . . . .  25
   6.  Flow Labels . . . . . . . . . . . . . . . . . . . . . . . . .  26
   7.  Traffic Classes . . . . . . . . . . . . . . . . . . . . . . .  26
   8.  Upper-Layer Protocol Issues . . . . . . . . . . . . . . . . .  27
     8.1.  Upper-Layer Checksums . . . . . . . . . . . . . . . . . .  27
     8.2.  Maximum Packet Lifetime . . . . . . . . . . . . . . . . .  28
     8.3.  Maximum Upper-Layer Payload Size  . . . . . . . . . . . .  29
     8.4.  Responding to Packets Carrying Routing Headers  . . . . .  29
   9.  IANA Considerations . . . . . . . . . . . . . . . . . . . . .  29
   10. Security Considerations . . . . . . . . . . . . . . . . . . .  30
   11. References  . . . . . . . . . . . . . . . . . . . . . . . . .  32
     11.1.  Normative References . . . . . . . . . . . . . . . . . .  32
     11.2.  Informative References . . . . . . . . . . . . . . . . .  33
   Appendix A.  Formatting Guidelines for Options  . . . . . . . . .  36
   Appendix B.  Changes Since RFC 2460 . . . . . . . . . . . . . . .  39
   Acknowledgments . . . . . . . . . . . . . . . . . . . . . . . . .  42
   Authors' Addresses  . . . . . . . . . . . . . . . . . . . . . . .  42
```

---
## **1.  Introduction**

IP 버전 6\(IPv6\)은 IP 버전 4\(IPv4\) \[RFC791\]의 후속으로 설계된 새로운 버전의 인터넷 프로토콜\(IP\)입니다. IPv4에서 IPv6으로의 변경 사항은 주로 다음 범주로 분류됩니다.

```text
      o  Expanded Addressing Capabilities
```

- IPv6은 IP 주소 크기를 32비트에서 128비트로 늘려 더 많은 수준의 주소 지정 계층 구조, 훨씬 더 많은 수의 주소 지정 가능한 노드 및 간단한 주소 자동 구성을 지원합니다. 멀티캐스트 주소에 "범위" 필드를 추가하면 멀티캐스트 라우팅의 확장성이 향상됩니다. 그리고 "애니캐스트 주소"라는 새로운 유형의 주소가 정의됩니다. 이는 노드 그룹 중 하나로 패킷을 보내는 데 사용됩니다.

```text
      o  Header Format Simplification
```

- 패킷 처리의 일반적인 처리 비용을 줄이고 IPv6 헤더의 대역폭 비용을 제한하기 위해 일부 IPv4 헤더 필드가 삭제되거나 선택 사항이 되었습니다.

- o 확장 및 옵션에 대한 지원 개선

- IP 헤더 옵션이 인코딩되는 방식이 변경되어 전달 효율성이 향상되고, 옵션 길이에 대한 제한이 덜 엄격해지며, 향후 새로운 옵션 도입에 대한 유연성이 향상됩니다.

```text
      o  Flow Labeling Capability
```

- 네트워크에서 단일 흐름으로 처리되도록 보낸 사람이 요청하는 패킷 시퀀스의 레이블 지정을 가능하게 하는 새로운 기능이 추가되었습니다.

- o 인증 및 개인 정보 보호 기능

- 인증, 데이터 무결성 및 \(선택 사항\) 데이터 기밀성을 지원하는 확장이 IPv6에 대해 지정됩니다.

이 문서에서는 기본 IPv6 헤더와 초기에 정의된 IPv6 확장 헤더 및 옵션을 지정합니다. 또한 패킷 크기 문제, 흐름 레이블 및 트래픽 클래스의 의미, 상위 계층 프로토콜에 대한 IPv6의 영향에 대해 설명합니다. IPv6 주소의 형식과 의미는 \[RFC4291\]에 별도로 지정됩니다. 모든 IPv6 구현에 포함되어야 하는 ICMP의 IPv6 버전은 \[RFC4443\]에 지정되어 있습니다.

IPv6의 데이터 전송 순서는 \[RFC791\]의 부록 B에 정의된 IPv4의 순서와 동일합니다.

참고: 이 문서는 \[RFC2460\]을 폐기하므로 RFC 2460에 대한 포인터를 포함하는 이 문서에서 참조되는 모든 문서는 이 문서를 참조하는 것으로 해석되어야 합니다.

---
## **2.  Terminology**

노드는 IPv6를 구현하는 장치입니다.

```text
   router       a node that forwards IPv6 packets not explicitly
                addressed to itself.  (See Note below.)

   host         any node that is not a router.  (See Note below.)
```

상위 계층은 IPv6 바로 위의 프로토콜 계층입니다. 예를 들어 TCP 및 UDP와 같은 전송 프로토콜, ICMP와 같은 제어 프로토콜, OSPF와 같은 라우팅 프로토콜, IPX와 같은 IPv6를 통해 "터널링"되는\(즉, 캡슐화되는\) 인터넷 계층 또는 하위 계층 프로토콜이 있습니다. \), AppleTalk 또는 IPv6 자체.

링크 계층, 즉 IPv6 바로 아래 계층에서 노드가 통신할 수 있는 통신 시설이나 매체를 연결합니다. 예를 들면 이더넷\(단순 또는 브리지\)입니다. PPP 링크; X.25, 프레임 릴레이 또는 ATM 네트워크; IPv4 또는 IPv6 자체를 통한 터널과 같은 인터넷 계층 또는 상위 계층 "터널"이 있습니다.

동일한 링크에 연결된 이웃 노드.

노드의 연결을 링크에 연결합니다.

인터페이스 또는 인터페이스 세트에 대한 IPv6 계층 식별자를 지정합니다.

IPv6 헤더와 페이로드를 패킷화합니다.

링크 MTU 링크를 통해 전달될 수 있는 최대 전송 단위, 즉 옥텟 단위의 최대 패킷 크기입니다.

경로 MTU 소스 노드와 대상 노드 사이의 경로에 있는 모든 링크의 최소 링크 MTU입니다.

참고: 여러 인터페이스가 있는 장치는 일부 인터페이스 세트\(전체보다 적음\)에서 도착하는 자체 목적지가 아닌 패킷을 전달하고 다른 인터페이스에서 도착하는 자체 목적지가 아닌 패킷을 삭제하도록 구성할 수 있습니다. 이러한 장치는 이전\(전달\) 인터페이스에서 패킷을 수신하고 이를 통해 이웃과 상호 작용할 때 라우터에 대한 프로토콜 요구 사항을 준수해야 합니다. 후자\(비전달\) 인터페이스에서 패킷을 수신하고 이를 통해 이웃과 상호 작용할 때 호스트에 대한 프로토콜 요구 사항을 준수해야 합니다.

---
## **3.  IPv6 Header Format**

```text
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |Version| Traffic Class |           Flow Label                  |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |         Payload Length        |  Next Header  |   Hop Limit   |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                                                               |
   +                                                               +
   |                                                               |
   +                         Source Address                        +
   |                                                               |
   +                                                               +
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                                                               |
   +                                                               +
   |                                                               |
   +                      Destination Address                      +
   |                                                               |
   +                                                               +
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

      Version             4-bit Internet Protocol version number = 6.

      Traffic Class       8-bit Traffic Class field.  See Section 7.

      Flow Label          20-bit flow label.  See Section 6.

      Payload Length      16-bit unsigned integer.  Length of the IPv6
                          payload, i.e., the rest of the packet
                          following this IPv6 header, in octets.  (Note
                          that any extension headers (see Section 4)
                          present are considered part of the payload,
                          i.e., included in the length count.)
```

- 다음 헤더 8비트 선택기. IPv6 헤더 바로 뒤에 오는 헤더 유형을 식별합니다. IPv4 프로토콜 필드 \[IANA-PN\]과 동일한 값을 사용합니다.

- 홉 제한 8비트 부호 없는 정수. 패킷을 전달하는 각 노드에 의해 1씩 감소됩니다. 전달할 때 수신 시 홉 제한이 0이거나 0으로 감소하면 패킷이 삭제됩니다. 패킷의 목적지인 노드는 홉 제한이 0인 패킷을 폐기해서는 안 됩니다. 패킷을 정상적으로 처리해야 합니다.

- 소스 주소 패킷 발신자의 128비트 주소입니다. \[RFC4291\]을 참조하세요.

- 대상 주소 의도된 패킷 수신자의 128비트 주소입니다\(라우팅 헤더가 있는 경우 최종 수신자가 아닐 수도 있음\). \[RFC4291\] 및 섹션 4.4를 참조하세요.

---
## **4.  IPv6 Extension Headers**

IPv6에서는 선택적 인터넷 계층 정보가 패킷의 IPv6 헤더와 상위 계층 헤더 사이에 배치될 수 있는 별도의 헤더에 인코딩됩니다. 이러한 확장 헤더는 소수이며 각 헤더는 고유한 Next Header 값으로 식별됩니다.

확장 헤더에는 IPv4 및 IPv6에 사용되는 것과 동일한 값인 IANA IP 프로토콜 번호\[IANA-PN\]에서 번호가 지정됩니다. 패킷에서 일련의 Next Header 값을 처리할 때 확장 헤더가 아닌 첫 번째 헤더 \[IANA-EH\]는 패킷의 다음 항목이 해당 상위 계층 헤더임을 나타냅니다. 상위 계층 헤더가 없는 경우 특별한 "다음 헤더 없음" 값이 사용됩니다.

이러한 예에 설명된 것처럼 IPv6 패킷은 0개, 1개 또는 그 이상의 확장 헤더를 전달할 수 있으며, 각각은 이전 헤더의 다음 헤더 필드로 식별됩니다.

```text
   +---------------+------------------------
   |  IPv6 header  | TCP header + data
   |               |
   | Next Header = |
   |      TCP      |
   +---------------+------------------------

   +---------------+----------------+------------------------
   |  IPv6 header  | Routing header | TCP header + data
   |               |                |
   | Next Header = |  Next Header = |
   |    Routing    |      TCP       |
   +---------------+----------------+------------------------

   +---------------+----------------+-----------------+-----------------
   |  IPv6 header  | Routing header | Fragment header | fragment of TCP
   |               |                |                 |  header + data
   | Next Header = |  Next Header = |  Next Header =  |
   |    Routing    |    Fragment    |       TCP       |
   +---------------+----------------+-----------------+-----------------
```

확장 헤더\(홉별 옵션 헤더 제외\)는 패킷이 노드\(또는 다음의 경우 각 노드 집합\)에 도달할 때까지 패킷 전달 경로를 따라 어떤 노드에서도 처리, 삽입 또는 삭제되지 않습니다. 멀티캐스트\)은 IPv6 헤더의 대상 주소 필드에서 식별됩니다.

홉별 옵션 헤더는 삽입되거나 삭제되지 않지만, 패킷이 노드\(또는 멀티캐스트의 경우 각 노드 집합\)에 도달할 때까지 패킷 전달 경로를 따라 모든 노드에서 검사하거나 처리될 수 있습니다. IPv6 헤더의 대상 주소 필드에서 식별됩니다. 홉별 옵션 헤더가 있는 경우 IPv6 헤더 바로 뒤에 와야 합니다. 해당 존재는 IPv6 헤더의 다음 헤더 필드에 0 값으로 표시됩니다.

참고: \[RFC2460\]에서는 모든 노드가 홉별 옵션 헤더를 검사하고 처리해야 한다고 요구했지만, 이제 패킷의 전달 경로에 있는 노드는 명시적으로 다음과 같이 구성된 경우에만 홉별 옵션 헤더를 검사하고 처리해야 합니다. 그렇게 하세요.

대상 노드에서 IPv6 헤더의 다음 헤더 필드에 대한 일반적인 역다중화는 모듈을 호출하여 첫 ​​번째 확장 헤더를 처리하거나 확장 헤더가 없는 경우 상위 계층 헤더를 처리합니다. 각 확장 헤더의 내용과 의미에 따라 다음 헤더로 진행할지 여부가 결정됩니다. 따라서 확장 헤더는 패킷에 나타나는 순서대로 엄격하게 처리되어야 합니다. 예를 들어, 수신기는 특정 종류의 확장 헤더를 찾기 위해 패킷을 스캔하여 이전 헤더를 모두 처리하기 전에 해당 헤더를 처리해서는 안 됩니다.

헤더 처리 결과 목적지 노드가 다음 헤더로 진행해야 하는데 현재 헤더의 Next Header 값을 노드가 인식하지 못하는 경우, 해당 패킷을 폐기하고 ICMP Parameter Problem 메시지를 노드로 전송해야 한다. ICMP 코드 값 1\("인식할 수 없는 다음 헤더 유형이 발생했습니다."\)과 원래 패킷 내에서 인식할 수 없는 값의 오프셋을 포함하는 ICMP 포인터 필드가 있는 패킷 소스입니다. 노드가 IPv6 헤더가 아닌 다른 헤더에서 다음 헤더 값이 0인 경우에도 동일한 조치를 취해야 합니다.

각 확장 헤더는 후속 헤더에 대해 8옥텟 정렬을 유지하기 위해 길이가 8옥텟의 정수 배수입니다. 각 확장 헤더 내의 다중 옥텟 필드는 자연 경계에 정렬됩니다. 즉, n 옥텟 너비의 필드는 n = 1, 2, 4 또는 8인 경우 헤더 시작 부분에서 n 옥텟의 정수 배수에 배치됩니다.

IPv6의 전체 구현에는 다음 확장 헤더 구현이 포함됩니다.

```text
      Hop-by-Hop Options
      Fragment
      Destination Options
      Routing
      Authentication
      Encapsulating Security Payload
```

처음 4개는 이 문서에 지정되어 있습니다. 마지막 두 개는 각각 \[RFC4302\]와 \[RFC4303\]에 지정되어 있습니다. 현재 IPv6 확장 헤더 목록은 \[IANA-EH\]에서 확인할 수 있습니다.

---
### **4.1.  Extension Header Order**

동일한 패킷에 두 개 이상의 확장 헤더가 사용되는 경우 해당 헤더가 다음 순서로 나타나는 것이 좋습니다.

```text
      IPv6 header
      Hop-by-Hop Options header
      Destination Options header (note 1)
      Routing header
      Fragment header
      Authentication header (note 2)
      Encapsulating Security Payload header (note 2)
      Destination Options header (note 3)
      Upper-Layer header
```

- 참고 1: IPv6 대상 주소 필드에 나타나는 첫 번째 대상과 라우팅 헤더에 나열된 후속 대상에 의해 처리되는 옵션에 대한 것입니다.

- 참고 2: 인증 및 보안 페이로드 캡슐화 헤더의 상대적 순서에 관한 추가 권장 사항은 \[RFC4303\]에 제공됩니다.

- 참고 3: 옵션은 패킷의 최종 목적지에서만 처리됩니다.

각 확장 헤더는 최대 두 번 발생해야 하는 대상 옵션 헤더를 제외하고 최대 한 번 발생해야 합니다\(라우팅 헤더 전에 한 번, 상위 계층 헤더 전에 한 번\).

상위 계층 헤더가 다른 IPv6 헤더인 경우\(IPv6가 IPv6를 통해 터널링되거나 캡슐화되는 경우\) 자체 확장 헤더가 뒤따를 수 있으며, 이는 별도로 동일한 순서 권장 사항이 적용됩니다.

다른 확장 헤더가 정의된 경우 위에 나열된 헤더와 관련된 순서 제약 조건을 지정해야 합니다.

IPv6 노드는 IPv6 헤더 바로 뒤에 나타나도록 제한되는 홉별 옵션 헤더를 제외하고 동일한 패킷에서 여러 번 발생하고 순서에 관계없이 확장 헤더를 수락하고 처리하려고 시도해야 합니다. 그럼에도 불구하고 IPv6 패킷의 소스는 후속 사양에서 해당 권장 사항을 수정할 때까지 위의 권장 순서를 따르는 것이 좋습니다.

---
### **4.2.  Options**

이 문서에 지정된 현재 정의된 확장 헤더 중 두 개\(Hop-by-Hop 옵션 헤더와 대상 옵션 헤더\)는 다음과 같이 TLV\(유형 길이 값\)로 인코딩된 다양한 수의 "옵션"을 전달합니다. 체재:

```text
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- - - - - - - - -
      |  Option Type  |  Opt Data Len |  Option Data
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- - - - - - - - -
```

- 옵션 유형 옵션 유형의 8비트 식별자입니다.

- Opt Data Len 8비트 부호 없는 정수. 이 옵션의 옵션 데이터 필드 길이\(옥텟\)입니다.

```text
      Option Data         Variable-length field.  Option-Type-specific
                          data.
```

헤더 내의 옵션 순서는 헤더에 나타나는 순서대로 엄격하게 처리되어야 합니다. 예를 들어, 수신자는 특정 종류의 옵션을 찾기 위해 헤더를 스캔하여 이전 옵션을 모두 처리하기 전에 해당 옵션을 처리해서는 안 됩니다.

옵션 유형 식별자는 처리 중인 IPv6 노드가 옵션 유형을 인식하지 못하는 경우 수행해야 하는 작업을 최상위 2비트가 지정하도록 내부적으로 인코딩됩니다.

- 00 - 이 옵션을 건너뛰고 헤더 처리를 계속합니다.

- 01 - 패킷을 폐기합니다.

- 10 - 패킷을 폐기하고, 패킷의 대상 주소가 멀티캐스트 주소인지 여부에 관계없이 인식할 수 없는 옵션 유형을 가리키는 ICMP 매개변수 문제, 코드 2, 메시지를 패킷의 소스 주소로 보냅니다.

- 11 - 패킷을 폐기하고, 패킷의 대상 주소가 멀티캐스트 주소가 아닌 경우에만 ICMP 매개변수 문제, 코드 2, 메시지를 패킷의 소스 주소로 보내 인식할 수 없는 옵션 유형을 가리킵니다.

옵션 유형의 세 번째로 높은 비트는 해당 옵션의 옵션 데이터가 패킷의 최종 목적지로 가는 도중에 변경될 수 있는지 여부를 지정합니다. 인증 헤더가 있는 경우

패킷에서 데이터가 도중에 변경될 수 있는 모든 옵션의 경우 패킷의 인증 값을 계산하거나 확인할 때 전체 옵션 데이터 필드는 값이 0인 옥텟으로 처리되어야 합니다.

```text
       0 - Option Data does not change en route

       1 - Option Data may change en route
```

위에 설명된 세 개의 상위 비트는 옵션 유형과 별개가 아닌 옵션 유형의 일부로 처리됩니다. 즉, 특정 옵션은 옵션 유형의 하위 5비트뿐만 아니라 전체 8비트 옵션 유형으로 식별됩니다.

홉별 옵션 헤더와 대상 옵션 헤더 모두에 동일한 옵션 유형 번호 지정 공간이 사용됩니다. 그러나 특정 옵션을 지정하면 두 헤더 중 하나로만 사용이 제한될 수 있습니다.

개별 옵션에는 옵션 데이터 필드 내의 다중 옥텟 값이 자연 경계에 포함되도록 하기 위한 특정 정렬 요구 사항이 있을 수 있습니다. 옵션의 정렬 요구 사항은 xn+y 표기법을 사용하여 지정됩니다. 즉, 옵션 유형은 헤더 시작 부분부터 x 옥텟의 정수 배수에 y 옥텟을 더한 정수 배수로 나타나야 합니다. 예를 들어:

- 2n은 헤더 시작 부분에서 2옥텟 오프셋을 의미합니다. 8n+2는 헤더 시작 부분의 8옥텟 오프셋에 2옥텟을 더한 것을 의미합니다.

후속 옵션을 정렬하고 포함 헤더를 8옥텟의 배수 길이로 채우는 데 필요할 때 사용되는 두 가지 패딩 옵션이 있습니다. 모든 IPv6 구현에서는 이러한 패딩 옵션을 인식해야 합니다.

```text
   Pad1 option (alignment requirement: none)

      +-+-+-+-+-+-+-+-+
      |       0       |
      +-+-+-+-+-+-+-+-+
```

-  메모! Pad1 옵션의 형식은 특별한 경우입니다. 즉, 길이 및 값 필드가 없습니다.

- Pad1 옵션은 헤더의 옵션 영역에 1옥텟의 패딩을 삽입하는 데 사용됩니다. 패딩의 옥텟이 두 개 이상 필요한 경우 여러 개의 Pad1 옵션 대신 다음에 설명하는 PadN 옵션을 사용해야 합니다.

```text
   PadN option (alignment requirement: none)

      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- - - - - - - - -
      |       1       |  Opt Data Len |  Option Data
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- - - - - - - - -
```

- PadN 옵션은 헤더의 옵션 영역에 2개 이상의 패딩 옥텟을 삽입하는 데 사용됩니다. N 옥텟의 패딩의 경우 Opt Data Len 필드에는 N-2 값이 포함되고 옵션 데이터는 N-2 0 값 옥텟으로 구성됩니다.

부록 A에는 새 옵션을 디자인하기 위한 형식 지정 지침이 포함되어 있습니다.

---
### **4.3.  Hop-by-Hop Options Header**

홉별 옵션 헤더는 패킷 전달 경로를 따라 모든 노드에서 검사하고 처리할 수 있는 선택적 정보를 전달하는 데 사용됩니다. 홉별 옵션 헤더는 IPv6 헤더에서 다음 헤더 값 0으로 식별되며 형식은 다음과 같습니다.

```text
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |  Next Header  |  Hdr Ext Len  |                               |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+                               +
    |                                                               |
    .                                                               .
    .                            Options                            .
    .                                                               .
    |                                                               |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

- 다음 헤더 8비트 선택기. 홉별 옵션 헤더 바로 뒤에 오는 헤더 유형을 식별합니다. IPv4 프로토콜 필드 \[IANA-PN\]과 동일한 값을 사용합니다.

- Hdr Ext Len 8비트 부호 없는 정수. 처음 8옥텟을 제외한 8옥텟 단위의 홉별 옵션 헤더 길이입니다.

- 옵션 전체 홉별 옵션 헤더 길이가 8옥텟의 정수 배수가 되는 길이의 가변 길이 필드입니다. 섹션 4.2에 설명된 대로 하나 이상의 TLV 인코딩 옵션을 포함합니다.

이 문서에 정의된 유일한 홉별 옵션은 섹션 4.2에 지정된 Pad1 및 PadN 옵션입니다.

---
### **4.4.  Routing Header**

라우팅 헤더는 IPv6 소스에서 패킷 대상으로 가는 도중에 "방문"할 하나 이상의 중간 노드를 나열하는 데 사용됩니다. 이 기능은 IPv4의 Loose Source and Record Route 옵션과 매우 유사합니다. 라우팅 헤더는 바로 앞 헤더에서 다음 헤더 값 43으로 식별되며 형식은 다음과 같습니다.

```text
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |  Next Header  |  Hdr Ext Len  |  Routing Type | Segments Left |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                                                               |
    .                                                               .
    .                       type-specific data                      .
    .                                                               .
    |                                                               |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

- 다음 헤더 8비트 선택기. 라우팅 헤더 바로 뒤에 오는 헤더 유형을 식별합니다. IPv4 프로토콜 필드 \[IANA-PN\]과 동일한 값을 사용합니다.

- Hdr Ext Len 8비트 부호 없는 정수. 처음 8옥텟을 제외한 8옥텟 단위의 라우팅 헤더 길이입니다.

- 특정 라우팅 헤더 변형의 라우팅 유형 8비트 식별자입니다.

- 세그먼트 왼쪽 8비트 부호 없는 정수. 남은 경로 세그먼트 수, 즉 최종 목적지에 도달하기 전에 아직 방문해야 하는 명시적으로 나열된 중간 노드 수입니다.

- 유형별 데이터 라우팅 유형에 의해 결정되는 형식의 가변 길이 필드이며 전체 라우팅 헤더 길이가 8옥텟의 정수 배수가 되는 길이입니다.

수신된 패킷을 처리하는 동안 노드가 인식할 수 없는 라우팅 유형 값이 있는 라우팅 헤더를 발견하는 경우 노드의 필수 동작은 다음과 같이 왼쪽 세그먼트 필드의 값에 따라 달라집니다.

- 남은 세그먼트가 0인 경우 노드는 라우팅 헤더를 무시하고 패킷의 다음 헤더 처리를 진행해야 합니다. 해당 유형은 라우팅 헤더의 다음 헤더 필드로 식별됩니다.

- 남은 세그먼트가 0이 아닌 경우 노드는 패킷을 폐기하고 인식할 수 없는 라우팅 유형을 가리키는 ICMP 매개변수 문제, 코드 0, 메시지를 패킷의 소스 주소로 보내야 합니다.

수신된 패킷의 Routing 헤더를 처리한 후 중간 노드가 해당 패킷을 링크 MTU가 패킷 크기보다 작은 링크로 전달되어야 한다고 결정하면 해당 노드는 해당 패킷을 폐기하고 ICMP Packet Too를 보내야 합니다. 패킷의 소스 주소에 대한 큰 메시지입니다.

현재 정의된 IPv6 라우팅 헤더와 해당 상태는 \[IANA-RH\]에서 확인할 수 있습니다. IPv6 라우팅 헤더에 대한 할당 지침은 \[RFC5871\]에서 확인할 수 있습니다.

---
### **4.5.  Fragment Header**

조각 헤더는 IPv6 소스에서 경로 MTU에 맞는 것보다 큰 패킷을 대상으로 보내는 데 사용됩니다. \(참고: IPv4와 달리 IPv6의 조각화는 패킷 전달 경로를 따라 라우터가 아닌 소스 노드에 의해서만 수행됩니다. 섹션 5를 참조하십시오.\) 조각 헤더는 바로 앞 헤더에서 다음 헤더 값 44로 식별되며 다음을 갖습니다. 다음 형식:

```text
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |  Next Header  |   Reserved    |      Fragment Offset    |Res|M|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                         Identification                        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

- 다음 헤더 8비트 선택기. 원본 패킷의 조각화 가능한 부분의 초기 헤더 유형을 식별합니다\(아래에 정의됨\). IPv4 프로토콜 필드 \[IANA-PN\]과 동일한 값을 사용합니다.

- 예약된 8비트 예약 필드입니다. 전송을 위해 0으로 초기화됩니다. 수신시 무시됩니다.

- 조각 오프셋 13비트 부호 없는 정수. 원본 패킷의 조각화 가능 부분의 시작을 기준으로 이 헤더 뒤에 오는 데이터의 오프셋\(8옥텟 단위\)입니다.

- Res 2비트 예약 필드. 전송을 위해 0으로 초기화됩니다. 수신시 무시됩니다.

```text
      M flag              1 = more fragments; 0 = last fragment.

      Identification      32 bits.  See description below.
```

너무 커서 경로의 MTU에 맞지 않는 패킷을 대상으로 보내기 위해 소스 노드는 패킷을 조각으로 나누고 각 조각을 별도의 패킷으로 보내 수신기에서 재조립할 수 있습니다.

조각화될 모든 패킷에 대해 소스 노드는 식별 값을 생성합니다. 식별은 동일한 소스 주소와 대상 주소를 사용하여 최근\* 전송된 다른 조각난 패킷의 식별과 달라야 합니다. 라우팅 헤더가 있는 경우 해당 대상 주소는 최종 대상의 주소입니다.

- \* "최근"은 소스에서 대상까지의 전송 시간 및 동일한 패킷의 다른 조각과의 재조립을 기다리는 데 소요된 시간을 포함하여 패킷의 최대 예상 수명 내를 의미합니다. 그러나 소스 노드가 최대 패킷 수명을 알 필요는 없습니다. 오히려 식별 재사용 빈도가 낮은 알고리즘을 구현함으로써 요구 사항을 충족할 수 있다고 가정합니다. 이 요구 사항을 충족할 수 있는 알고리즘의 예는 \[RFC7739\]에 설명되어 있습니다.

조각화되지 않은 초기의 대규모 패킷을 "원래 패킷"이라고 하며 그림과 같이 세 부분으로 구성된 것으로 간주됩니다.

```text
   original packet:

   +------------------+-------------------------+---//----------------+
   |  Per-Fragment    | Extension & Upper-Layer |   Fragmentable      |
   |    Headers       |       Headers           |      Part           |
   +------------------+-------------------------+---//----------------+
```

- Per-Fragment 헤더는 IPv6 헤더와 대상으로 가는 도중에 노드가 처리해야 하는 모든 확장 헤더로 구성되어야 합니다. 즉, 라우팅 헤더가 있는 경우 라우팅 헤더까지의 모든 헤더, 그렇지 않으면 홉별 헤더로 구성되어야 합니다. 옵션 헤더가 있는 경우, 그렇지 않으면 확장 헤더가 없습니다.

- 확장 헤더는 패킷의 Per-Fragment 헤더 부분에 포함되지 않은 다른 모든 확장 헤더입니다. 이를 위해 ESP\(Encapsulated Security Payload\)는 확장 헤더로 간주되지 않습니다. 상위 계층 헤더는 IPv6 확장 헤더가 아닌 첫 번째 상위 계층 헤더입니다. 상위 계층 헤더의 예로는 TCP, UDP, IPv4, IPv6, ICMPv6 및 명시된 ESP가 있습니다.

- 조각화 가능 부분은 상위 계층 헤더 뒤 또는 다음 헤더 없음이라는 다음 헤더 값을 포함하는 헤더\(즉, 초기 IPv6 헤더 또는 확장 헤더\) 뒤의 나머지 패킷으로 구성됩니다.

원본 패킷의 조각화 가능 부분은 조각으로 나뉩니다. 결과 조각 패킷이 패킷 대상 경로의 MTU 내에 맞도록 조각의 길이를 선택해야 합니다. 마지막\("가장 오른쪽"\) 조각을 제외한 각 완전한 조각은 길이가 8옥텟의 정수 배수입니다.

조각은 그림과 같이 별도의 "조각 패킷"으로 전송됩니다.

```text
   original packet:

   +-----------------+-----------------+--------+--------+-//-+--------+
   |  Per-Fragment   |Ext & Upper-Layer|  first | second |    |  last  |
   |    Headers      |    Headers      |fragment|fragment|....|fragment|
   +-----------------+-----------------+--------+--------+-//-+--------+

   fragment packets:

   +------------------+---------+-------------------+----------+
   |  Per-Fragment    |Fragment | Ext & Upper-Layer |  first   |
   |    Headers       | Header  |   Headers         | fragment |
   +------------------+---------+-------------------+----------+

   +------------------+--------+-------------------------------+
   |  Per-Fragment    |Fragment|    second                     |
   |    Headers       | Header |   fragment                    |
   +------------------+--------+-------------------------------+
                         o
                         o
                         o
   +------------------+--------+----------+
   |  Per-Fragment    |Fragment|   last   |
   |    Headers       | Header | fragment |
   +------------------+--------+----------+
```

첫 번째 조각 패킷은 다음으로 구성됩니다.

- \(1\) 원래 IPv6 헤더의 페이로드 길이가 이 조각 패킷의 길이만 포함하도록 변경된 원본 패킷의 조각별 헤더\(IPv6 헤더 자체의 길이 제외\)와 다음 헤더 필드 Per-Fragment 헤더의 마지막 헤더가 44로 변경되었습니다.

- \(2\) 다음을 포함하는 조각 헤더:

- 원본 패킷의 Per-Fragment 헤더 다음의 첫 번째 헤더를 식별하는 다음 헤더 값입니다.

- 원본 패킷의 조각화 가능한 부분의 시작을 기준으로 조각의 오프셋을 8옥텟 단위로 포함하는 조각 오프셋입니다. 첫 번째\("가장 왼쪽"\) 조각의 조각 오프셋은 0입니다.

- 첫 번째 조각이므로 M 플래그 값은 1입니다.

- 원본 패킷에 대해 생성된 식별 값입니다.

- \(3\) 확장 헤더\(있는 경우\) 및 상위 계층 헤더. 이러한 헤더는 첫 번째 조각에 있어야 합니다. 참고: 이는 상위 계층 헤더를 통한 헤더 크기를 패킷 대상 경로의 MTU로 제한합니다.

-\(4\) 첫 번째 조각.

후속 조각 패킷은 다음으로 구성됩니다.

- \(1\) 원래 IPv6 헤더의 페이로드 길이가 이 조각 패킷의 길이만 포함하도록 변경된 원본 패킷의 조각별 헤더\(IPv6 헤더 자체의 길이 제외\)와 다음 헤더 필드 Per-Fragment 헤더의 마지막 헤더가 44로 변경되었습니다.

- \(2\) 다음을 포함하는 조각 헤더:

- 원본 패킷의 Per-Fragment 헤더 다음의 첫 번째 헤더를 식별하는 다음 헤더 값입니다.

- 원본 패킷의 조각화 가능한 부분의 시작을 기준으로 조각의 오프셋을 8옥텟 단위로 포함하는 조각 오프셋입니다.

조각이 마지막 조각인 경우 M 플래그 값은 0입니다.

- \("가장 오른쪽"\) 1개, 그렇지 않으면 M 플래그 값 1.

- 원본 패킷에 대해 생성된 식별 값입니다.

-\(3\) 조각 자체.

원본 패킷에서 생성된 다른 조각과 겹치는 조각을 생성해서는 안 됩니다.

대상에서 조각 패킷은 그림과 같이 조각화되지 않은 원래 형식으로 재조립됩니다.

```text
   reassembled original packet:

   +---------------+-----------------+---------+--------+-//--+--------+
   | Per-Fragment  |Ext & Upper-Layer|  first  | second |     | last   |
   |    Headers    |     Headers     |frag data|fragment|.....|fragment|
   +---------------+-----------------+---------+--------+-//--+--------+
```

재조립에는 다음 규칙이 적용됩니다.

- 원본 패킷은 동일한 소스 주소, 대상 주소 및 조각 ID를 가진 조각 패킷에서만 재조립됩니다.

- 재조립된 패킷의 Per-Fragment 헤더는 첫 번째 조각 패킷\(즉, 조각 오프셋이 0인 패킷\)의 조각 헤더까지의 모든 헤더로 구성되며 다음 두 가지 변경 사항이 있습니다.

- Per-Fragment 헤더의 마지막 헤더의 Next Header 필드는 첫 번째 조각의 Fragment 헤더의 Next Header 필드에서 가져옵니다.

- 재조립된 패킷의 페이로드 길이는 Per-Fragment 헤더의 길이와 마지막 조각의 길이 및 오프셋으로부터 계산됩니다. 예를 들어, 재조립된 원본 패킷의 페이로드 길이를 계산하는 공식은 다음과 같습니다.

```text
            PL.orig = PL.first - FL.first - 8 + (8 * FO.last) + FL.last
```

어디

- PL.orig = 재조립된 패킷의 페이로드 길이 필드입니다. PL.first = 첫 번째 조각 패킷의 페이로드 길이 필드입니다. FL.first = 첫 번째 조각 패킷의 조각 헤더 다음에 나오는 조각의 길이입니다. FO.last = 마지막 조각 패킷의 조각 헤더에 있는 조각 오프셋 필드입니다. FL.last = 마지막 조각 패킷의 조각 헤더 다음에 나오는 조각의 길이입니다.

- 재조립된 패킷의 조각화 가능 부분은 각 조각 패킷의 조각 헤더 다음에 나오는 조각으로 구성됩니다. 각 조각의 길이는 패킷의 페이로드 길이에서 IPv6 헤더와 조각 자체 사이의 헤더 길이를 빼서 계산됩니다. 그것은

- 조각화 가능한 부분의 상대 위치는 조각 오프셋 값에서 계산됩니다.

- Fragment 헤더는 최종 재조립된 패킷에 존재하지 않습니다.

- 조각이 전체 데이터그램인 경우\(즉, Fragment Offset 필드와 M 플래그가 모두 0인 경우\) 더 이상의 재조립이 필요하지 않으며 완전히 재조립된 패킷으로 처리되어야 합니다\(예: Next Header 업데이트, 조정 페이로드 길이, 조각 헤더 제거 등\). 이 패킷과 일치하는 다른 조각\(예: 동일한 IPv6 소스 주소, IPv6 대상 주소 및 조각 식별\)은 독립적으로 처리되어야 합니다.

조각난 패킷을 재조립할 때 다음과 같은 오류 조건이 발생할 수 있습니다.

- o 해당 패킷의 처음 도착한 조각을 수신한 후 60초 이내에 패킷 재조립을 완료하기에 불충분한 조각이 수신된 경우 해당 패킷의 재조립을 포기해야 하며 해당 패킷에 대해 수신된 모든 조각을 폐기해야 합니다. . 첫 번째 조각\(즉, 조각 오프셋이 0인 조각\)이 수신된 경우 ICMP 시간 초과 - 조각 재조립 시간 초과 메시지가 해당 조각의 소스로 전송되어야 합니다.

- o 조각 패킷의 페이로드 길이 필드에서 파생된 조각의 길이가 8옥텟의 배수가 아니고 해당 조각의 M 플래그가 1인 경우 해당 조각은 폐기되어야 하며 ICMP 매개변수 문제, 코드 0 , 메시지는 조각 패킷의 페이로드 길이 필드를 가리키는 조각 소스로 전송되어야 합니다.

- o 조각의 길이와 오프셋이 해당 조각에서 재조립된 패킷의 페이로드 길이가 65,535 옥텟을 초과하는 정도라면 해당 조각은 폐기되어야 하며 ICMP 매개변수 문제\(코드 0\) 메시지가 소스로 전송되어야 합니다. 조각 패킷의 조각 오프셋 필드를 가리키는 조각의

- o 첫 번째 조각이 상위 계층 헤더를 통해 모든 헤더를 포함하지 않는 경우 해당 조각은 폐기되어야 하며 ICMP 매개변수 문제\(코드 3\) 메시지는 포인터 필드가 다음으로 설정된 조각 소스로 전송되어야 합니다. 영.

- o 재조립 중인 조각 중 하나가 동일한 패킷에 대해 재조립 중인 다른 조각과 겹치는 경우 해당 패킷의 재조립을 중단하고 해당 패킷에 대해 수신된 모든 조각을 폐기해야 하며 ICMP 오류 메시지가 없어야 합니다. 전송된.

- 네트워크에서 조각이 중복될 수 있다는 점에 유의해야 합니다. 이러한 정확한 중복 조각을 중복 조각으로 처리하는 대신 구현에서는 이 경우를 감지하고 동일한 패킷에 속하는 다른 조각을 유지하면서 정확한 중복 조각을 삭제하도록 선택할 수 있습니다.

다음 조건은 자주 발생하지 않을 것으로 예상되지만 발생하더라도 오류로 간주되지 않습니다.

- 동일한 원본 패킷의 여러 조각에 대한 조각 헤더 앞에 있는 헤더의 수와 내용이 다를 수 있습니다. 각 조각 패킷의 조각 헤더 앞에 있는 헤더가 무엇이든 패킷이 도착할 때 재조립을 위해 조각을 대기열에 넣기 전에 처리됩니다. 오프셋 0 조각 패킷의 헤더만 리어셈블된 패킷에 유지됩니다.

- 동일한 원본 패킷의 여러 조각에 대한 조각 헤더의 다음 헤더 값이 다를 수 있습니다. 리어셈블리에는 오프셋 0 조각 패킷의 값만 사용됩니다.

- IPv6 헤더의 다른 필드도 재조립되는 조각에 따라 달라질 수 있습니다. 오프셋 0 조각의 값을 사용하는 기본 메커니즘이 충분하지 않은 경우 이러한 필드를 사용하는 사양은 추가 지침을 제공할 수 있습니다. 예를 들어, \[RFC3168\]의 섹션 5.3에서는 서로 다른 조각의 ECN\(Explicit Congestion Report\) 비트를 결합하여 리어셈블된 패킷의 ECN 비트를 파생시키는 방법을 설명합니다.

---
### **4.6.  Destination Options Header**

대상 옵션 헤더는 패킷의 대상 노드에서만 검사해야 하는 선택적 정보를 전달하는 데 사용됩니다. 대상 옵션 헤더는 바로 앞 헤더의 다음 헤더 값 60으로 식별되며 형식은 다음과 같습니다.

```text
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |  Next Header  |  Hdr Ext Len  |                               |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+                               +
    |                                                               |
    .                                                               .
    .                            Options                            .
    .                                                               .
    |                                                               |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

- 다음 헤더 8비트 선택기. 대상 옵션 헤더 바로 뒤에 오는 헤더 유형을 식별합니다. IPv4 프로토콜 필드 \[IANA-PN\]과 동일한 값을 사용합니다.

- Hdr Ext Len 8비트 부호 없는 정수. 처음 8옥텟을 제외한 8옥텟 단위의 대상 옵션 헤더 길이입니다.

- 옵션 전체 대상 옵션 헤더 길이가 8옥텟의 정수 배수가 되는 길이의 가변 길이 필드입니다. 섹션 4.2에 설명된 대로 하나 이상의 TLV 인코딩 옵션을 포함합니다.

이 문서에 정의된 유일한 대상 옵션은 섹션 4.2에 지정된 Pad1 및 PadN 옵션입니다.

IPv6 패킷에서 선택적 대상 정보를 인코딩하는 방법에는 대상 옵션 헤더의 옵션 또는 별도의 확장 헤더라는 두 가지 방법이 있습니다. Fragment 헤더와 Authentication 헤더는 후자 접근 방식의 예입니다. 사용할 수 있는 접근 방식은 선택적 정보를 이해하지 못하는 대상 노드에 대해 원하는 작업에 따라 다릅니다.

- o 원하는 작업이 대상 노드에서 패킷을 삭제하는 것이고, 패킷의 대상 주소가 멀티캐스트 주소가 아닌 경우에만 ICMP 인식할 수 없는 유형 메시지를 패킷의 소스 주소로 보내는 것이라면 정보는 다음 중 하나로 인코딩될 수 있습니다. 별도의 헤더 또는 옵션으로

- 옵션 유형의 최상위 2비트 값이 11인 대상 옵션 헤더입니다. 선택은 더 적은 옥텟을 사용하거나 더 나은 정렬 또는 더 효율적인 구문 분석을 생성하는 요소에 따라 달라질 수 있습니다.

- o 다른 작업이 필요한 경우 옵션 유형의 값이 최상위 2비트에 00, 01 또는 10인 대상 옵션 헤더의 옵션으로 정보를 인코딩하여 원하는 작업을 지정해야 합니다\(섹션 4.2 참조\). \).

---
### **4.7.  No Next Header**

IPv6 헤더 또는 확장 헤더의 다음 헤더 필드 값 59는 해당 헤더 뒤에 아무것도 없음을 나타냅니다. IPv6 헤더의 페이로드 길이 필드가 다음 헤더 필드에 59가 포함된 헤더 끝을 지나 옥텟이 있음을 나타내는 경우 해당 옥텟은 무시되고 패킷이 전달되는 경우 변경되지 않은 상태로 전달되어야 합니다.

---
### **4.8.  Defining New Extension Headers and Options**

해당 IPv6 확장 헤더에 대한 새 옵션을 지정하여 사용할 수 있는 기존 IPv6 확장 헤더가 없는 경우를 제외하고 새 IPv6 확장 헤더를 정의하는 것은 권장되지 않습니다. 새로운 IPv6 확장 헤더를 지정하기 위한 제안에는 기존 IPv6 확장 헤더를 원하는 새 기능에 사용할 수 없는 이유에 대한 자세한 기술 설명이 포함되어야 합니다. 추가 배경 정보는 \[RFC6564\]를 참조하세요.

참고: 홉별 동작이 필요한 새 확장 헤더는 정의해서는 안 됩니다. 왜냐하면 이 문서의 섹션 4에 지정된 대로 홉별 동작이 있는 유일한 확장 헤더는 홉별 옵션 헤더이기 때문입니다.

새로운 홉별 옵션은 권장되지 않습니다. 노드가 홉별 옵션 헤더를 무시하거나, 홉별 옵션 헤더가 포함된 패킷을 삭제하거나, 홉별 옵션 헤더가 포함된 패킷을 할당하도록 구성될 수 있기 때문입니다. 느린 처리 ​​경로로. 새로운 홉별 옵션 정의를 고려하는 설계자는 이러한 가능성 있는 동작을 인식해야 합니다. 새로운 hop-by-hop 옵션이 표준화되기 전에 왜 필요한지에 대한 매우 명확한 근거가 있어야 합니다.

새로운 확장 헤더를 정의하는 대신 목적지 옵션 헤더를 사용하여 패킷의 목적지 노드에서만 검사해야 하는 선택적 정보를 전달하는 것이 좋습니다. 더 나은 처리 및 이전 버전과의 호환성을 제공하기 때문입니다.

새 확장 헤더가 정의된 경우 다음 형식을 사용해야 합니다.

```text
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |  Next Header  |  Hdr Ext Len  |                               |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+                               +
    |                                                               |
    .                                                               .
    .                  Header-Specific Data                         .
    .                                                               .
    |                                                               |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

- 다음 헤더 8비트 선택기. 확장 헤더 바로 뒤에 오는 헤더 유형을 식별합니다. IPv4 프로토콜 필드 \[IANA-PN\]과 동일한 값을 사용합니다.

- Hdr Ext Len 8비트 부호 없는 정수. 처음 8옥텟을 제외한 8옥텟 단위의 대상 옵션 헤더 길이입니다.

- 헤더별 데이터 가변 길이 필드. 확장 헤더와 관련된 필드입니다.

---
## **5.  Packet Size Issues**

IPv6에서는 인터넷의 모든 링크에 1280옥텟 이상의 MTU가 필요합니다. 이를 IPv6 최소 링크 MTU라고 합니다. 1280옥텟 패킷을 하나로 전달할 수 없는 링크에서는 링크별 조각화 및 재조립이 IPv6 아래 계층에서 제공되어야 합니다.

구성 가능한 MTU가 있는 링크\(예: PPP 링크 \[RFC1661\]\)는 최소 1280옥텟의 MTU를 갖도록 구성되어야 합니다. IPv6 계층 조각화를 발생시키지 않고 가능한 캡슐화\(예: 터널링\)를 수용하려면 1500옥텟 이상의 MTU로 구성하는 것이 좋습니다.

노드가 직접 연결된 각 링크에서 노드는 해당 링크의 MTU만큼 큰 패킷을 받아들일 수 있어야 합니다.

1280 옥텟보다 큰 경로 MTU를 검색하고 활용하려면 IPv6 노드에서 경로 MTU 검색 \[RFC8201\]을 구현하는 것이 좋습니다. 그러나 최소 IPv6 구현\(예: 부팅 ROM\)에서는 1280옥텟 이하의 패킷 전송으로 제한하고 경로 MTU 검색 구현을 생략할 수 있습니다.

경로의 MTU보다 큰 패킷을 전송하기 위해 노드는 IPv6 Fragment 헤더를 사용하여 소스에서 패킷을 조각화하고 대상에서 재조립할 수 있습니다. 그러나 측정된 경로 MTU\(즉, 1280옥텟까지\)에 맞게 패킷을 조정할 수 있는 애플리케이션에서는 이러한 조각화를 사용하지 않는 것이 좋습니다.

노드는 재조립 후 크기가 1500옥텟에 달하는 조각난 패킷을 받아들일 수 있어야 합니다. 노드는 1500옥텟 이상으로 재조립되는 조각화된 패킷을 허용할 수 있습니다. 경로의 MTU보다 큰 패킷을 보내기 위해 IPv6 조각화에 의존하는 상위 계층 프로토콜이나 애플리케이션은 대상이 더 큰 크기의 패킷을 재조립할 수 있다는 보장이 없는 한 1500옥텟보다 큰 패킷을 보내서는 안 됩니다.

---
## **6.  Flow Labels**

IPv6 헤더의 20비트 흐름 레이블 필드는 네트워크에서 단일 흐름으로 처리될 패킷 시퀀스에 레이블을 지정하기 위해 소스에서 사용됩니다.

IPv6 흐름 레이블의 현재 정의는 \[RFC6437\]에서 확인할 수 있습니다.

---
## **7.  Traffic Classes**

IPv6 헤더의 8비트 트래픽 클래스 필드는 네트워크에서 트래픽 관리를 위해 사용됩니다. 수신된 패킷 또는 조각의 트래픽 클래스 비트 값은 패킷 소스에서 보낸 값과 다를 수 있습니다.

차별화된 서비스 및 명시적인 혼잡 알림을 위한 트래픽 클래스 필드의 현재 사용은 \[RFC2474\] 및 \[RFC3168\]에 지정되어 있습니다.

---
## **8.  Upper-Layer Protocol Issues**
---
### **8.1.  Upper-Layer Checksums**

체크섬 계산에 IP 헤더의 주소를 포함하는 모든 전송 또는 기타 상위 계층 프로토콜은 IPv6에서 사용하도록 수정되어 32비트 IPv4 주소 대신 128비트 IPv6 주소를 포함해야 합니다. 특히 다음 그림은 IPv6에 대한 TCP 및 UDP "의사 헤더"를 보여줍니다.

```text
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                                                               |
   +                                                               +
   |                                                               |
   +                         Source Address                        +
   |                                                               |
   +                                                               +
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                                                               |
   +                                                               +
   |                                                               |
   +                      Destination Address                      +
   |                                                               |
   +                                                               +
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                   Upper-Layer Packet Length                   |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                      zero                     |  Next Header  |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

- o IPv6 패킷에 라우팅 헤더가 포함된 경우 의사 헤더에 사용된 대상 주소는 최종 대상 주소입니다. 원래 노드에서 해당 주소는 라우팅 헤더의 마지막 요소에 있습니다. 수신자에서 해당 주소는 IPv6 헤더의 대상 주소 필드에 있습니다.

- o 의사 헤더의 다음 헤더 값은 상위 계층 프로토콜을 식별합니다\(예: TCP의 경우 6, UDP의 경우 17\). IPv6 헤더와 상위 계층 헤더 사이에 확장 헤더가 있는 경우 IPv6 헤더의 Next Header 값과 다릅니다.

- o 의사 헤더의 상위 계층 패킷 길이는 상위 계층 헤더와 데이터\(예: TCP 헤더 + TCP 데이터\)의 길이입니다. 일부 상위 계층 프로토콜은 자체 길이 정보\(예: UDP 헤더의 길이 필드\)를 전달합니다. 그러한 프로토콜의 경우 이는 의사 헤더에 사용되는 길이입니다. 다른 프로토콜\(예: TCP\)은 자체 길이 정보를 전달하지 않습니다. 이 경우 의사 헤더에 사용되는 길이는 IPv6 헤더의 페이로드 길이에서 IPv6 헤더와 상위 헤더 사이에 있는 확장 헤더의 길이를 뺀 값입니다. -레이어 헤더.

o IPv4와 달리 UDP 패킷이 다음과 같은 경우의 기본 동작은

- IPv6 노드에서 시작된 UDP 체크섬은 선택 사항이 아닙니다. 즉, UDP 패킷이 발생할 때마다 IPv6 노드는 패킷과 의사 헤더에 대해 UDP 체크섬을 계산해야 하며, 계산 결과가 0인 경우 UDP 헤더에 배치하기 위해 16진수 FFFF로 변경해야 합니다. . IPv6 수신자는 체크섬이 0인 UDP 패킷을 삭제해야 하며 오류를 기록해야 합니다.

- o 기본 동작에 대한 예외로 UDP를 터널 캡슐화로 사용하는 프로토콜은 전송 및/또는 수신을 위해 특정 포트\(또는 포트 집합\)에 대해 제로 체크섬 모드를 활성화할 수 있습니다. 제로 체크섬 모드를 구현하는 모든 노드는 "체크섬이 없는 IPv6 UDP 데이터그램 사용에 대한 적용 가능성 설명문" \[RFC6936\]에 지정된 요구 사항을 따라야 합니다.

ICMP \[RFC4443\]의 IPv6 버전은 체크섬 계산에 위의 의사 헤더를 포함합니다. 이는 체크섬에 의사 헤더가 포함되지 않은 ICMP IPv4 버전의 변경 사항입니다. 변경 이유는 IPv4와 달리 인터넷 계층 체크섬이 적용되지 않는 IPv6 헤더 필드의 잘못된 전달이나 손상으로부터 ICMP를 보호하기 위한 것입니다. ICMP 의사 헤더의 다음 헤더 필드에는 ICMP의 IPv6 버전을 식별하는 값 58이 포함되어 있습니다.

---
### **8.2.  Maximum Packet Lifetime**

IPv4와 달리 IPv6 노드는 최대 패킷 수명을 적용할 필요가 없습니다. 이것이 IPv4의 "Time-to-Live" 필드 이름이 IPv6에서 "Hop Limit"로 변경된 이유입니다. 실제로 패킷 수명을 제한하는 요구 사항을 준수하는 IPv4 구현은 거의 없으므로 이는 실제로 변경되지 않습니다. 패킷 수명을 제한하기 위해 인터넷 계층\(IPv4 또는 IPv6\)에 의존하는 모든 상위 계층 프로토콜은 더 이상 사용되지 않는 패킷을 감지하고 삭제하기 위한 자체 메커니즘을 제공하도록 업그레이드되어야 합니다.

---
### **8.3.  Maximum Upper-Layer Payload Size**

상위 계층 데이터에 사용할 수 있는 최대 페이로드 크기를 계산할 때 상위 계층 프로토콜은 IPv4 헤더에 비해 IPv6 헤더의 더 큰 크기를 고려해야 합니다. 예를 들어 IPv4에서 TCP의 MSS\(최대 세그먼트 크기\) 옵션은 최대 패킷 크기\(기본값 또는 경로 MTU 검색을 통해 학습된 값\)에서 40옥텟\(최소 길이 IPv4 헤더의 경우 20옥텟, 최소 길이 IPv4 헤더의 경우 20옥텟\)을 뺀 값으로 계산됩니다. 최소 길이의 TCP 헤더의 경우\). IPv6를 통해 TCP를 사용하는 경우 MSS는 최대 패킷 크기에서 60옥텟을 뺀 값으로 계산되어야 합니다. 왜냐하면 최소 길이 IPv6 헤더\(즉, 확장 헤더가 없는 IPv6 헤더\)가 최소 길이 IPv4 헤더보다 20옥텟 길기 때문입니다.

---
### **8.4.  Responding to Packets Carrying Routing Headers**

상위 계층 프로토콜이 라우팅 헤더를 포함하는 수신된 패킷에 대한 응답으로 하나 이상의 패킷을 보낼 때, 응답 패킷에는 무결성이 손상되지 않는 한 수신된 라우팅 헤더를 "역전"하여 자동으로 파생된 라우팅 헤더가 포함되어서는 안 됩니다. 수신된 소스 주소 및 라우팅 헤더의 신뢰성이 확인되었습니다\(예: 수신된 패킷의 인증 헤더 사용을 통해\). 즉, 라우팅 헤더가 포함된 수신 패킷에 대한 응답으로 다음 종류의 패킷만 허용됩니다.

- o 라우팅 헤더를 전달하지 않는 응답 패킷.

- o 수신된 패킷의 라우팅 헤더를 반전하여 파생되지 않은 라우팅 헤더를 전달하는 응답 패킷\(예: 로컬 구성에서 제공되는 라우팅 헤더\).

- o 수신된 패킷의 라우팅 헤더를 역전하여 파생된 라우팅 헤더를 전달하는 응답 패킷은 수신된 패킷의 소스 주소 및 라우팅 헤더의 무결성과 신뢰성이 응답자에 의해 확인된 경우에만 해당됩니다.

---
## **9.  IANA Considerations**

RFC 2460은 여러 IANA 레지스트리에서 참조됩니다. 여기에는 다음이 포함됩니다.

```text
      o  Internet Protocol Version 6 (IPv6) Parameters [IANA-6P]

      o  Assigned Internet Protocol Numbers [IANA-PN]

      o  ONC RPC Network Identifiers (netids) [IANA-NI]
```

- o 관심 있는 네트워크 계층 프로토콜 식별자\(NLPID\) \[IANA-NL\]

```text
      o  Protocol Registries [IANA-PR]
```

IANA는 이 문서를 가리키도록 이러한 참조를 업데이트했습니다.

---
## **10.  Security Considerations**

IPv6는 패킷의 기본 형식과 전송 측면에서 IPv4와 유사한 보안 특성을 가지고 있습니다. 이러한 보안 문제는 다음과 같습니다.

- o 도청. 경로상의 요소가 각 IPv6 데이터그램의 전체 패킷\(내용과 메타데이터 포함\)을 관찰할 수 있습니다. o 재생\(Replay\): 공격자가 유선에서 일련의 패킷을 녹음하고 원래 수신한 당사자에게 재생합니다. o 패킷 삽입. 공격자가 선택한 속성 집합으로 패킷을 위조하여 네트워크에 주입합니다. o 패킷 삭제: 공격자가 회선에서 패킷을 제거합니다. o 공격자가 회선에서 패킷을 제거하고 수정한 후 네트워크에 다시 주입하는 패킷 수정. o MITM\(Man-in-the-Middle\) 공격. 공격자는 수신자에게는 발신자 역할을 하고 발신자에게는 수신자 역할을 하기 위해 통신 스트림을 파괴합니다. o 서비스 거부\(DoS\) 공격. 공격자가 대상을 압도하기 위해 대량의 합법적인 트래픽을 대상으로 보냅니다.

IPv6 패킷은 "인터넷 프로토콜용 보안 아키텍처"\[RFC4301\]를 사용하여 도청, 재생, 패킷 삽입, 패킷 수정 및 MITM 공격으로부터 보호할 수 있습니다. 또한 TLS\(전송 계층 보안\) 또는 SSH\(보안 셸\)와 같은 상위 계층 프로토콜을 사용하여 IPv6 위에서 실행되는 애플리케이션 계층 트래픽을 보호할 수 있습니다.

DoS 공격으로부터 보호할 수 있는 메커니즘은 없습니다. 이러한 유형의 공격으로부터 방어하는 것은 이 사양의 범위를 벗어납니다.

IPv6 주소는 IPv4 주소보다 훨씬 크기 때문에 인터넷 전체는 물론 단일 네트워크 링크\(예: 근거리 통신망\)에서도 주소 공간을 검색하기가 훨씬 어렵습니다. 자세한 내용은 \[RFC7707\]을 참조하세요.

주소 변환 기술의 사용이 줄어들기 때문에 노드의 IPv6 주소는 IPv4에 비해 인터넷에서 더 잘 드러날 것으로 예상됩니다. 이로 인해 엔드포인트를 더 쉽게 구별할 수 있게 되는 등 몇 가지 추가적인 개인 정보 보호 문제가 발생합니다. 자세한 내용은 \[RFC7721\]을 참조하세요.

IPv6 확장 헤더 아키텍처의 설계는 많은 유연성을 추가하는 동시에 새로운 보안 문제도 야기합니다. 아래에 설명된 대로 조각 확장 헤더와 관련된 문제는 해결되었지만 향후 설계되는 모든 새 확장 헤더의 경우 보안 관련 사항을 철저히 조사해야 하며 여기에는 새 확장 헤더가 작동하는 방식이 포함되어야 합니다. 기존 확장 헤더. 자세한 내용은 \[RFC7045\]를 참조하세요.

이번 IPv6 사양 버전은 IPv6 사양의 이전 버전 \[RFC2460\]에서 발견된 여러 보안 문제를 해결합니다. 여기에는 다음이 포함됩니다.

- o 전체 데이터그램인 조각의 경우를 처리하기 위해 텍스트를 수정했습니다\(즉, 조각 오프셋 필드와 M 플래그가 모두 0입니다\). 수신된 경우 재조립된 패킷으로 처리되어야 합니다. 일치하는 다른 조각은 독립적으로 처리되어야 합니다. 전체 데이터그램 조각을 생성하지 않도록 조각 생성 프로세스가 수정되었습니다\(조각 오프셋 필드 및 M 플래그는 0입니다\). 자세한 내용은 \[RFC6946\] 및 \[RFC8021\]을 참조하세요.

- o 다음 홉 MTU를 보고하는 ICMP 패킷이 너무 큼 메시지가 1280보다 작은 경우 나가는 패킷에 조각 헤더를 포함해야 하는 섹션 5의 단락을 제거했습니다. 자세한 내용은 \[RFC6946\]을 참조하세요.

- o IPv6 노드가 겹치는 조각을 생성해서는 안 된다는 내용을 요구하도록 텍스트를 변경했습니다. 또한 IPv6 데이터그램을 재조립할 때 해당 구성 조각 중 하나 이상이 겹치는 조각으로 확인되면 전체 데이터그램\(및 모든 구성 조각\)을 자동으로 삭제해야 합니다. 겹치는 조각이 수신된 경우 ICMP 오류 메시지를 보내서는 안 된다는 설명이 포함되어 있습니다. 자세한 내용은 \[RFC5722\]를 참조하세요.

- o 첫 번째 상위 계층 헤더를 통과하는 모든 헤더가 첫 번째 조각에 있도록 텍스트를 수정했습니다. 자세한 내용은 \[RFC7112\]를 참조하세요.

- o \[RFC5095\] 및 \[RFC5871\]의 업데이트를 통합하여 라우팅 헤더 유형 0\(RH0\)에 대한 설명을 제거하고 라우팅 헤더에 대한 할당 지침이 RFC 5871에 지정되었으며 필수 확장 헤더 목록에서 RH0을 제거했습니다. .

주소 지정, ICMPv6, 경로 MTU 검색 등을 포함한 IPv6의 다른 부분과 관련된 보안 문제는 해당 사양에서 논의됩니다.

---
## **11.  References**
---
### **11.1.  Normative References**

```text
   [RFC791]   Postel, J., "Internet Protocol", STD 5, RFC 791,
              DOI 10.17487/RFC0791, September 1981,
              <http://www.rfc-editor.org/info/rfc791>.

   [RFC2474]  Nichols, K., Blake, S., Baker, F., and D. Black,
              "Definition of the Differentiated Services Field (DS
              Field) in the IPv4 and IPv6 Headers", RFC 2474,
              DOI 10.17487/RFC2474, December 1998,
              <http://www.rfc-editor.org/info/rfc2474>.

   [RFC3168]  Ramakrishnan, K., Floyd, S., and D. Black, "The Addition
              of Explicit Congestion Notification (ECN) to IP",
              RFC 3168, DOI 10.17487/RFC3168, September 2001,
              <http://www.rfc-editor.org/info/rfc3168>.

   [RFC4291]  Hinden, R. and S. Deering, "IP Version 6 Addressing
              Architecture", RFC 4291, DOI 10.17487/RFC4291, February
              2006, <http://www.rfc-editor.org/info/rfc4291>.

   [RFC4443]  Conta, A., Deering, S., and M. Gupta, Ed., "Internet
              Control Message Protocol (ICMPv6) for the Internet
              Protocol Version 6 (IPv6) Specification", STD 89,
              RFC 4443, DOI 10.17487/RFC4443, March 2006,
              <http://www.rfc-editor.org/info/rfc4443>.

   [RFC6437]  Amante, S., Carpenter, B., Jiang, S., and J. Rajahalme,
              "IPv6 Flow Label Specification", RFC 6437,
              DOI 10.17487/RFC6437, November 2011,
              <http://www.rfc-editor.org/info/rfc6437>.
```

---
### **11.2.  Informative References**

```text
   [Err2541]  RFC Errata, Erratum ID 2541, RFC 2460.

   [Err4279]  RFC Errata, Erratum ID 4279, RFC 2460.

   [Err4657]  RFC Errata, Erratum ID 4657, RFC 2460.

   [Err4662]  RFC Errata, Erratum ID 4662, RFC 2460.

   [IANA-6P]  IANA, "Internet Protocol Version 6 (IPv6) Parameters",
              <https://www.iana.org/assignments/ipv6-parameters>.

   [IANA-EH]  IANA, "IPv6 Extension Header Types",
              <https://www.iana.org/assignments/ipv6-parameters>.

   [IANA-NI]  IANA, "ONC RPC Network Identifiers (netids)",
              <https://www.iana.org/assignments/rpc-netids>.

   [IANA-NL]  IANA, "Network Layer Protocol Identifiers (NLPIDs) of
              Interest", <https://www.iana.org/assignments/nlpids>.

   [IANA-PN]  IANA, "Protocol Numbers",
              <https://www.iana.org/assignments/protocol-numbers>.

   [IANA-PR]  IANA, "Protocol Registries", <https://www.iana.org/
              protocols>.

   [IANA-RH]  IANA, "Routing Types", <https://www.iana.org/assignments/
              ipv6-parameters>.

   [RFC1661]  Simpson, W., Ed., "The Point-to-Point Protocol (PPP)",
              STD 51, RFC 1661, DOI 10.17487/RFC1661, July 1994,
              <http://www.rfc-editor.org/info/rfc1661>.

   [RFC2460]  Deering, S. and R. Hinden, "Internet Protocol, Version 6
              (IPv6) Specification", RFC 2460, DOI 10.17487/RFC2460,
              December 1998, <http://www.rfc-editor.org/info/rfc2460>.

   [RFC4301]  Kent, S. and K. Seo, "Security Architecture for the
              Internet Protocol", RFC 4301, DOI 10.17487/RFC4301,
              December 2005, <http://www.rfc-editor.org/info/rfc4301>.

   [RFC4302]  Kent, S., "IP Authentication Header", RFC 4302,
              DOI 10.17487/RFC4302, December 2005,
              <http://www.rfc-editor.org/info/rfc4302>.

   [RFC4303]  Kent, S., "IP Encapsulating Security Payload (ESP)",
              RFC 4303, DOI 10.17487/RFC4303, December 2005,
              <http://www.rfc-editor.org/info/rfc4303>.

   [RFC5095]  Abley, J., Savola, P., and G. Neville-Neil, "Deprecation
              of Type 0 Routing Headers in IPv6", RFC 5095,
              DOI 10.17487/RFC5095, December 2007,
              <http://www.rfc-editor.org/info/rfc5095>.

   [RFC5722]  Krishnan, S., "Handling of Overlapping IPv6 Fragments",
              RFC 5722, DOI 10.17487/RFC5722, December 2009,
              <http://www.rfc-editor.org/info/rfc5722>.

   [RFC5871]  Arkko, J. and S. Bradner, "IANA Allocation Guidelines for
              the IPv6 Routing Header", RFC 5871, DOI 10.17487/RFC5871,
              May 2010, <http://www.rfc-editor.org/info/rfc5871>.

   [RFC6564]  Krishnan, S., Woodyatt, J., Kline, E., Hoagland, J., and
              M. Bhatia, "A Uniform Format for IPv6 Extension Headers",
              RFC 6564, DOI 10.17487/RFC6564, April 2012,
              <http://www.rfc-editor.org/info/rfc6564>.

   [RFC6936]  Fairhurst, G. and M. Westerlund, "Applicability Statement
              for the Use of IPv6 UDP Datagrams with Zero Checksums",
              RFC 6936, DOI 10.17487/RFC6936, April 2013,
              <http://www.rfc-editor.org/info/rfc6936>.

   [RFC6946]  Gont, F., "Processing of IPv6 "Atomic" Fragments",
              RFC 6946, DOI 10.17487/RFC6946, May 2013,
              <http://www.rfc-editor.org/info/rfc6946>.

   [RFC7045]  Carpenter, B. and S. Jiang, "Transmission and Processing
              of IPv6 Extension Headers", RFC 7045,
              DOI 10.17487/RFC7045, December 2013,
              <http://www.rfc-editor.org/info/rfc7045>.

   [RFC7112]  Gont, F., Manral, V., and R. Bonica, "Implications of
              Oversized IPv6 Header Chains", RFC 7112,
              DOI 10.17487/RFC7112, January 2014,
              <http://www.rfc-editor.org/info/rfc7112>.

   [RFC7707]  Gont, F. and T. Chown, "Network Reconnaissance in IPv6
              Networks", RFC 7707, DOI 10.17487/RFC7707, March 2016,
              <http://www.rfc-editor.org/info/rfc7707>.

   [RFC7721]  Cooper, A., Gont, F., and D. Thaler, "Security and Privacy
              Considerations for IPv6 Address Generation Mechanisms",
              RFC 7721, DOI 10.17487/RFC7721, March 2016,
              <http://www.rfc-editor.org/info/rfc7721>.

   [RFC7739]  Gont, F., "Security Implications of Predictable Fragment
              Identification Values", RFC 7739, DOI 10.17487/RFC7739,
              February 2016, <http://www.rfc-editor.org/info/rfc7739>.

   [RFC8021]  Gont, F., Liu, W., and T. Anderson, "Generation of IPv6
              Atomic Fragments Considered Harmful", RFC 8021,
              DOI 10.17487/RFC8021, January 2017,
              <http://www.rfc-editor.org/info/rfc8021>.

   [RFC8201]  McCann, J., Deering, S., Mogul, J., and R. Hinden, "Path
              MTU Discovery for IP version 6", STD 87, RFC 8201,
              DOI 10.17487/RFC8201, July 2017,
              <http://www.rfc-editor.org/info/rfc8201>.
```

---
# **Appendix A.  Formatting Guidelines for Options**

이 부록은 섹션 4.2에 설명된 대로 홉별 옵션 헤더 또는 대상 옵션 헤더에 사용할 새 옵션을 설계할 때 필드를 배치하는 방법에 대한 몇 가지 조언을 제공합니다. 이러한 지침은 다음과 같은 가정을 기반으로 합니다.

- o 한 가지 바람직한 기능은 옵션의 옵션 데이터 영역 내의 모든 다중 옥텟 필드가 자연 경계에 정렬된다는 것입니다. 즉, 너비 n 옥텟의 필드는 홉 시작부터 n 옥텟의 정수배에 배치되어야 합니다. -by-Hop 또는 대상 옵션 헤더\(n = 1, 2, 4 또는 8인 경우\)

- o 또 다른 바람직한 기능은 홉별\(Hop-by-Hop\) 또는 대상 옵션 헤더가 8옥텟 길이의 정수 배수라는 요구 사항에 따라 가능한 한 적은 공간을 차지한다는 것입니다.

- o 옵션을 포함하는 헤더 중 하나가 존재할 때 매우 적은 수의 옵션\(보통 하나만 포함\)을 전달한다고 가정할 수 있습니다.

이러한 가정은 옵션의 필드를 레이아웃하는 다음과 같은 접근 방식을 제안합니다. 내부 패딩 없이 가장 작은 것부터 가장 큰 것까지 필드를 정렬한 다음 가장 큰 필드의 정렬 요구 사항을 기반으로 전체 옵션에 대한 정렬 요구 사항을 도출합니다\(최대 최대 정렬은 8옥텟\). 이 접근 방식은 다음 예에 설명되어 있습니다.

```text
   Example 1
```

옵션 X에 길이가 8옥텟인 데이터 필드와 길이가 4옥텟인 데이터 필드가 필요한 경우 다음과 같이 배치됩니다.

```text
                                   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                                   | Option Type=X |Opt Data Len=12|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                         4-octet field                         |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                                                               |
   +                         8-octet field                         +
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

8옥텟 필드가 둘러싸는 헤더의 시작 부분에서 8의 배수 오프셋에서 시작되도록 하기 위한 정렬 요구 사항은 8n+2입니다. 이 하나의 옵션을 포함하는 전체 홉별 또는 대상 옵션 헤더는 다음과 같습니다.

```text
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |  Next Header  | Hdr Ext Len=1 | Option Type=X |Opt Data Len=12|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                         4-octet field                         |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                                                               |
   +                         8-octet field                         +
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

   Example 2
```

옵션 Y에 세 개의 데이터 필드\(길이 4옥텟 중 하나, 길이 2옥텟 중 하나, 길이 1옥텟 중 하나\)가 필요한 경우 다음과 같이 배치됩니다.

```text
                                                   +-+-+-+-+-+-+-+-+
                                                   | Option Type=Y |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |Opt Data Len=7 | 1-octet field |         2-octet field         |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                         4-octet field                         |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

4옥텟 필드가 둘러싸는 헤더의 시작 부분에서 4의 배수 오프셋에서 시작되도록 하기 위한 정렬 요구 사항은 4n+3입니다. 이 하나의 옵션을 포함하는 전체 홉별 또는 대상 옵션 헤더는 다음과 같습니다.

```text
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |  Next Header  | Hdr Ext Len=1 | Pad1 Option=0 | Option Type=Y |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |Opt Data Len=7 | 1-octet field |         2-octet field         |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                         4-octet field                         |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   | PadN Option=1 |Opt Data Len=2 |       0       |       0       |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

   Example 3
```

예제 1과 2의 X와 Y 옵션을 모두 포함하는 홉별 또는 대상 옵션 헤더는 먼저 표시된 옵션에 따라 다음 두 가지 형식 중 하나를 갖습니다.

```text
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |  Next Header  | Hdr Ext Len=3 | Option Type=X |Opt Data Len=12|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                         4-octet field                         |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                                                               |
   +                         8-octet field                         +
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   | PadN Option=1 |Opt Data Len=1 |       0       | Option Type=Y |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |Opt Data Len=7 | 1-octet field |         2-octet field         |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                         4-octet field                         |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   | PadN Option=1 |Opt Data Len=2 |       0       |       0       |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |  Next Header  | Hdr Ext Len=3 | Pad1 Option=0 | Option Type=Y |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |Opt Data Len=7 | 1-octet field |         2-octet field         |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                         4-octet field                         |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   | PadN Option=1 |Opt Data Len=4 |       0       |       0       |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |       0       |       0       | Option Type=X |Opt Data Len=12|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                         4-octet field                         |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                                                               |
   +                         8-octet field                         +
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

---
# **Appendix B.  Changes Since RFC 2460**

이 메모에는 RFC 2460에서 다음과 같은 변경 사항이 있습니다.

o 초록에서 IP Next Generation을 삭제했습니다.

o 데이터 전송 순서가 RFC 791에 정의된 IPv4와 동일하다는 내용을 섹션 1에 추가했습니다.

o 홉 제한 감소에 대한 섹션 3의 텍스트를 명확히 했습니다.

o 확장 헤더\(홉별 옵션 헤더 제외\)는 패킷 전달 경로를 따라 어떤 노드에서도 처리, 삽입 또는 삭제되지 않는다는 점을 명확히 했습니다.

o 홉별 옵션 헤더에 대한 요구 사항을 "may"로 변경하고 홉별 옵션 헤더와 관련하여 예상되는 사항을 나타내는 메모를 추가했습니다.

o 확장 헤더에 번호를 매기는 방법과 상위 계층 헤더가 무엇인지 명확히 하기 위해 섹션 4에 단락을 추가했습니다.

o "IPv6 확장 헤더 유형" IANA 레지스트리의 섹션 4 끝에 참조를 추가했습니다.

o RFC 5095 및 5871의 업데이트를 통합하여 RH0에 대한 설명을 제거하고 라우팅 헤더에 대한 할당 지침이 RFC 5871에 지정되었으며 필수 확장 헤더 목록에서 RH0을 제거했습니다.

o RFC 5722, 6946, 7112 및 8021의 업데이트를 기반으로 IPv6 조각화에 대한 섹션 4.5를 개정했습니다. 여기에는 다음이 포함됩니다.

- - 전체 데이터그램인 조각의 경우를 처리하기 위해 텍스트를 수정했습니다\(예: 조각 오프셋 필드와 M 플래그가 모두 0임\). 수신된 경우 재조립된 패킷으로 처리되어야 합니다. 일치하는 다른 조각은 독립적으로 처리되어야 합니다. 수정된 조각 생성 프로세스는 전체 데이터그램 조각을 생성하지 않도록 수정되었습니다\(조각 오프셋 필드 및 M 플래그는 0임\).

- - IPv6 노드가 겹치는 조각을 생성하지 않아야 함을 요구하도록 텍스트를 변경했습니다. 또한 IPv6 데이터그램을 재조립할 때 해당 구성 조각 중 하나 이상이 겹치는 조각으로 확인되면 전체 데이터그램\(및 모든 구성 조각\)을 자동으로 삭제해야 합니다. 겹치는 조각이 수신되면 ICMP 오류 메시지가 전송되지 않아야 한다는 설명이 포함되어 있습니다.

- - 첫 번째 상위 계층 헤더를 통과하는 모든 헤더가 첫 번째 조각에 있도록 텍스트를 수정했습니다. 이로 인해 패킷이 조각화되고 재조립되는 방법을 설명하는 텍스트가 변경되었으며 새로운 오류 사례가 추가되었습니다.

- - 정확한 중복 조각 처리에 대한 조각 헤더 프로세스에 텍스트를 추가했습니다.

- - AH\(인증 헤더\) 포함을 수정하기 위해 조각화 헤더 텍스트를 업데이트하고 다음 헤더 없음 사례를 표시했습니다.

- - 조각 헤더 섹션의 용어가 "조각화할 수 없는 헤더"에서 "조각별 헤더"로 변경되었습니다.

- - ICMP 패킷이 너무 큼 메시지가 1280 미만의 다음 홉 MTU를 보고하는 경우 나가는 패킷에 조각 헤더를 포함해야 하는 섹션 5의 단락을 제거했습니다.

- MTU 제한 및 8바이트를 명확히 하기 위해 텍스트를 변경했습니다.

- 제한 사항, 첫 번째 조각의 헤더에 대한 제한 사항을 언급했습니다.

o 섹션 4.5에는 IPv6 헤더의 일부 필드가 재조립되는 조각에 따라 다를 수 있으며 다른 사양이 재조립 방법에 대한 추가 지침을 제공할 수 있다는 설명이 추가되었습니다. 예를 들어 \[RFC3168\]의 섹션 5.3을 참조하세요.

o 새로운 확장 헤더 및 옵션 정의에 대한 권장 사항을 설명하는 새로운 섹션 4.8을 추가하기 위해 RFC 6564의 업데이트를 통합했습니다.

o "IPv6 최소 링크 MTU"를 정의하기 위해 섹션 5에 텍스트를 추가했습니다.

o 흐름 레이블에 대한 섹션 6의 텍스트를 단순화하고 부록 A\("흐름 레이블 필드의 의미 및 사용법"\)를 제거했습니다. 대신 \[RFC6437\]의 IPv6 흐름 레이블 필드와 \[RFC2474\] 및 \[RFC3168\]의 트래픽 클래스 필드의 현재 사양을 지적했습니다.

o 섹션 8에 RFC 6935\("터널링된 패킷에 대한 IPv6 및 UDP 체크섬"\)의 업데이트를 통합했습니다. 터널에 대한 체크섬이 0인 UDP 패킷 처리에 대한 기본 동작에 예외를 추가했습니다.

o RFC 2460에 대한 참조를 이 문서로 변경하기 위해 섹션 9, "IANA 고려 사항"에 지침을 추가했습니다.

o 섹션 10, "보안 고려 사항"을 개정하고 확장했습니다.

o 업데이트 문서의 작성자를 인정하는 감사의 글 섹션에 단락을 추가했습니다.

o 현재 버전에 대한 참조를 업데이트하고 규범 및 정보에 대한 참조를 할당했습니다.

o RFC 2460의 정오표를 해결하기 위해 변경했습니다. 이는 다음과 같습니다.

- 정오표 ID 2541 \[Err2541\]: 이 정오표는 흐름 레이블의 길이가 RFC 1883에서 24비트에서 20비트로 변경되었을 때 RFC 2460이 RFC 2205를 업데이트하지 않았음을 나타냅니다. 이 문제는 흐름 레이블이 다음과 같은 RFC 6437에서 해결되었습니다. 한정된. 이 사양은 이제 RFC 6437을 참조합니다. 변경할 필요가 없습니다.

정오표 ID 4279 \[Err4279\]: 이 정오표는

- 사양에서는 홉 제한이 0인 패킷을 수신하는 전달 노드의 경우를 처리하지 않습니다. 이는 이 사양의 섹션 3에서 수정되었습니다.

- 정오표 ID 4657 \[Err4657\]: 이 정오표는 확장 헤더가 패킷 소스가 아닌 다른 노드에 의해 삽입되어서는 안 된다는 텍스트를 제안했습니다. 이 문제는 섹션 4, "IPv6 확장 헤더"에서 해결되었습니다.

- 정오표 ID 4662 \[Err4662\]: 이 정오표는 한 가지 예외를 제외하고 확장 헤더가 패킷 전달 경로를 따라 어떤 노드에서도 검사, 처리, 수정, 삽입 또는 삭제되지 않는다는 텍스트를 제안했습니다. 이 문제는 섹션 4, "IPv6 확장 헤더"에서 해결되었습니다.

- 정오표 ID 2843: 이 정오표는 "거부됨"으로 표시되어 있습니다. 변경사항이 없습니다.

---
# **Acknowledgments**

저자는 IPng 실무 그룹, 엔드투엔드 프로토콜 연구 그룹 및 인터넷 커뮤니티 전반의 많은 유용한 제안에 감사드립니다.

또한 저자는 IPv6 사양을 인터넷 표준으로 이동하기 위해 이 문서에 통합된 업데이트 RFC의 작성자에게도 감사의 말씀을 전하고 싶습니다. 그들은 Joe Abley, Shane Amante, Jari Arkko, Manav Bhatia, Ronald P. Bonica, Scott Bradner, Brian Carpenter, P.F. Chimento, Marshall Eubanks, Fernando Gont, James Hoagland, Sheng Jiang, Erik Kline, Suresh Krishnan, Vishwas Manral, George Neville-Neil, Jarno Rajahalme, Pekka Savola, Magnus Westerlund 및 James Woodyatt.

---
# **Authors' Addresses**

```text
   Stephen E. Deering
   Retired
   Vancouver, British Columbia
   Canada
```

Robert M. Hinden Check Point Software 959 Skyway Road San Carlos, CA 94070 미국

```text
   Email: bob.hinden@gmail.com
```
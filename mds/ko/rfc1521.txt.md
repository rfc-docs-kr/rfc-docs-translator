

```text
Network Working Group                                      N. Borenstein
Request for Comments: 1521                                      Bellcore
Obsoletes: 1341                                                 N. Freed
Category: Standards Track                                       Innosoft
                                                          September 1993
```

MIME\(Multipurpose Internet Mail Extensions\) 파트 1:

- 인터넷 메시지 본문의 형식 지정 및 기술 메커니즘

---
# **Status of this Memo**

이 RFC는 인터넷 커뮤니티를 위한 인터넷 표준 추적 프로토콜을 지정하고 개선을 위한 토론 및 제안을 요청합니다. 이 프로토콜의 표준화 상태 및 현황에 대해서는 "Internet Official Protocol Standards" 최신판을 참조하십시오. 이 메모의 배포는 무제한입니다.

---
# **Abstract**

STD 11, RFC 822는 메시지 헤더에 대한 상당한 세부 정보를 지정하지만 메시지 콘텐츠 또는 메시지 본문을 일반 ASCII 텍스트로 남겨두는 메시지 표현 프로토콜을 정의합니다. 이 문서는 정보 손실 없이 여러 부분으로 구성된 텍스트 및 비텍스트 메시지 본문을 표현하고 교환할 수 있도록 메시지 본문의 형식을 재정의합니다. 이것은 RFC 934 및 STD 11, RFC 1049에 문서화된 이전 작업을 기반으로 하지만 해당 작업을 확장하고 수정합니다. RFC 822는 메시지 본문에 대해 거의 언급하지 않았기 때문에 이 문서는 대체로 RFC 822와 직교합니다\(개정판이 아님\).

특히 이 문서는 단일 메시지에 여러 개체를 포함하고, US-ASCII 이외의 문자 집합으로 본문 텍스트를 나타내고, 형식이 지정된 다중 글꼴 텍스트 메시지를 나타내고, 이미지와 같은 비텍스트 자료를 나타내는 기능을 제공하도록 설계되었습니다. 및 오디오 조각, 그리고 일반적으로 협력 메일 에이전트에서 사용할 새로운 유형의 인터넷 메일을 정의하는 이후 확장을 용이하게 합니다.

이 문서는 US-ASCII 텍스트 데이터 이외의 것을 허용하기 위해 인터넷 메일 헤더 필드를 확장하지 않습니다. 이러한 확장은 동반 문서 \[RFC-1522\]의 주제입니다.

이 문서는 RFC 1341의 개정판입니다. RFC 1341과의 중요한 차이점은 부록 H에 요약되어 있습니다.

---
# **Table of Contents**

```text
   1.     Introduction.......................................  3
   2.     Notations, Conventions, and Generic BNF Grammar....  6
   3.     The MIME-Version Header Field......................  7
   4.     The Content-Type Header Field......................  9
   5.     The Content-Transfer-Encoding Header Field......... 13
   5.1.   Quoted-Printable Content-Transfer-Encoding......... 18
   5.2.   Base64 Content-Transfer-Encoding................... 21
   6.     Additional Content-Header Fields................... 23
   6.1.   Optional Content-ID Header Field................... 23
   6.2.   Optional Content-Description Header Field.......... 24
   7.     The Predefined Content-Type Values................. 24
   7.1.   The Text Content-Type.............................. 24
   7.1.1. The charset parameter.............................. 25
   7.1.2. The Text/plain subtype............................. 28
   7.2.   The Multipart Content-Type......................... 28
   7.2.1. Multipart:  The common syntax...................... 29
   7.2.2. The Multipart/mixed (primary) subtype.............. 34
   7.2.3. The Multipart/alternative subtype.................. 34
   7.2.4. The Multipart/digest subtype....................... 36
   7.2.5. The Multipart/parallel subtype..................... 37
   7.2.6. Other Multipart subtypes........................... 37
   7.3.   The Message Content-Type........................... 38
   7.3.1. The Message/rfc822 (primary) subtype............... 38
   7.3.2. The Message/Partial subtype........................ 39
   7.3.3. The Message/External-Body subtype.................. 42
   7.3.3.1.  The "ftp" and "tftp" access-types............... 44
   7.3.3.2.  The "anon-ftp" access-type...................... 45
   7.3.3.3.  The "local-file" and "afs" access-types......... 45
   7.3.3.4.  The "mail-server" access-type................... 45
   7.3.3.5.  Examples and Further Explanations............... 46
   7.4.   The Application Content-Type....................... 49
   7.4.1. The Application/Octet-Stream (primary) subtype..... 50
   7.4.2. The Application/PostScript subtype................. 50
   7.4.3. Other Application subtypes......................... 53
   7.5.   The Image Content-Type............................. 53
   7.6.   The Audio Content-Type............................. 54
   7.7.   The Video Content-Type............................. 54
   7.8.   Experimental Content-Type Values................... 54
   8.     Summary............................................ 56
   9.     Security Considerations............................ 56
   10.    Authors' Addresses................................. 57
   11.    Acknowledgements................................... 58
   Appendix A -- Minimal MIME-Conformance.................... 60
   Appendix B -- General Guidelines For Sending Email Data... 63
   Appendix C -- A Complex Multipart Example................. 66
   Appendix D -- Collected Grammar........................... 68
   Appendix E -- IANA Registration Procedures................ 72
   E.1  Registration of New Content-type/subtype Values...... 72
   E.2  Registration of New Access-type Values
        for Message/external-body............................ 73
   Appendix F -- Summary of the Seven Content-types.......... 74
   Appendix G -- Canonical Encoding Model.................... 76
   Appendix H -- Changes from RFC 1341....................... 78
   References................................................ 80
```

---
## **1.    Introduction**

1982년 발행 이후 STD 11, RFC 822\[RFC-822\]는 인터넷에서 텍스트 메일 메시지의 표준 형식을 정의했습니다. STD 10, RFC 821\[RFC-821\]에 의해 정의된 인터넷 및 인터넷 SMTP 전송의 범위를 훨씬 넘어서 RFC 822 형식이 전체적으로 또는 부분적으로 채택되는 등의 성공을 거두었습니다. 형식이 더 널리 사용됨에 따라 여러 제한 사항이 사용자 커뮤니티에 점점 더 제한적임이 입증되었습니다.

RFC 822는 텍스트 메시지의 형식을 지정하기 위한 것입니다. 따라서 오디오나 이미지를 포함할 수 있는 멀티미디어 메시지와 같은 텍스트가 아닌 메시지는 단순히 언급되지 않습니다. 그러나 텍스트의 경우에도 RFC 822는 US ASCII\[US-ASCII\]보다 풍부한 문자 집합을 사용해야 하는 언어를 사용하는 메일 사용자의 요구에 적합하지 않습니다. RFC 822는 오디오, 비디오, 아시아 언어 텍스트 또는 대부분의 유럽 언어 텍스트를 포함하는 메일에 대한 메커니즘을 지정하지 않기 때문에 추가 사양이 필요합니다.

RFC 821/822 기반 메일 시스템의 주목할만한 제한 사항 중 하나는 전자 메일 메시지의 내용을 비교적 짧은 7비트 ASCII 행으로 제한한다는 사실입니다. 이것은 사용자가 로컬 메일 UA\(인간 사용자가 메일을 보내고 받는 프로그램인 사용자 에이전트\)를 호출하기 전에 인쇄 가능한 ASCII 문자로 표시할 수 있는 7비트 바이트로 전송하려는 비텍스트 데이터를 변환하도록 강제합니다. 현재 인터넷에서 사용되는 이러한 인코딩의 예로는 순수 16진수, uuencode, RFC 1421에 지정된 3-in-4 base 64 체계, Andrew Toolkit Representation\[ATK\] 등이 있습니다.

RFC 822 메일의 제한 사항은 RFC 822 호스트와 X.400 호스트 간에 메일 메시지를 교환할 수 있도록 게이트웨이가 설계되었기 때문에 더욱 분명해집니다. X.400 \[X400\]은 전자 메일 메시지에 텍스트가 아닌 본문 부분을 포함하기 위한 메커니즘을 지정합니다. X.400 메시지를 RFC 822 메시지로 매핑하는 현재 표준은 X.400 텍스트가 아닌 본문 부분을 ASCII 형식으로 변환\(인코딩하지 않음\)하거나 폐기하여 RFC 822에 알리도록 지정합니다. 삭제가 발생한 사용자입니다. 이것은 분명히 바람직하지 않은데, 사용자가 원할 수 있는 정보로

수신이 손실되었습니다. 사용자의 UA에 텍스트가 아닌 본문 부분을 처리하는 기능이 없을 수 있지만 사용자는 본문 부분에서 유용한 정보를 추출할 수 있는 UA 외부 메커니즘을 가질 수 있습니다. 또한 메시지가 결국 X.400 메시지 처리 시스템\(즉, X.400 메시지가 인터넷 메일을 통해 "터널링"됨\)으로 다시 게이트웨이될 수 있다는 사실을 허용하지 않습니다. 다시 유용해집니다.

이 문서는 기존 RFC 822 메일 세계와의 심각한 비호환성을 도입하지 않고 대부분의 이러한 문제를 해결하기 위해 결합된 몇 가지 메커니즘을 설명합니다. 특히 다음과 같이 설명합니다.

1. 버전 번호를 사용하여 이 사양을 준수하는 메시지를 선언하고 메일 처리 에이전트가 이러한 메시지와 이전 또는 비준수 소프트웨어에서 생성된 메시지를 구별할 수 있도록 하는 MIME 버전 헤더 필드. 그런 분야.

2. RFC 1049\[RFC-1049\]에서 일반화된 Content-Type 헤더 필드는 메시지 본문에서 데이터의 유형 및 하위 유형을 지정하고 이러한 데이터의 기본 표현\(인코딩\)을 완전히 지정하는 데 사용할 수 있습니다. .

- 2.a. 표준화된 방식으로 여러 문자 세트 및 형식화된 텍스트 설명 언어로 텍스트 정보를 나타내는 데 사용할 수 있는 "텍스트" Content-Type 값입니다.

- 2.b. 데이터 유형이 다를 수 있는 여러 본문 부분을 단일 메시지로 결합하는 데 사용할 수 있는 "다중 부분" Content-Type 값입니다.

- 2.c. 응용 프로그램 데이터 또는 이진 데이터를 전송하는 데 사용할 수 있는 "응용 프로그램" Content-Type 값으로, 다른 용도 중에서도 전자 메일 파일 전송 서비스를 구현하는 데 사용할 수 있습니다.

- 2.d. 다른 메일 메시지를 캡슐화하기 위한 "메시지" Content-Type 값.

- 2.e 정지 이미지\(사진\) 데이터를 전송하기 위한 "이미지" Content-Type 값.

- 2.f. 오디오 또는 음성 데이터를 전송하기 위한 "오디오" Content-Type 값입니다.

- 2.g. 복합 비디오 데이터 형식의 일부로 오디오와 함께 비디오 또는 동영상 데이터를 전송하기 위한 "비디오" Content-Type 값.

3. 데이터 또는 문자 세트 제한이 있을 수 있는 메일 전송 메커니즘을 통과할 수 있도록 데이터에 적용된 보조 인코딩을 지정하는 데 사용할 수 있는 Content-Transfer-Encoding 헤더 필드.

4. 메시지 본문의 데이터를 자세히 설명하는 데 사용할 수 있는 두 개의 추가 헤더 필드인 Content-ID 및 Content-Description 헤더 필드입니다.

MIME은 확장 가능한 메커니즘으로 신중하게 설계되었으며 콘텐츠 유형/하위 유형 쌍 세트 및 관련 매개변수가 시간이 지남에 따라 크게 증가할 것으로 예상됩니다. 특히 문자 세트 이름을 포함하여 여러 다른 MIME 필드는 시간이 지남에 따라 정의된 새 값을 가질 수 있습니다. 이러한 값 집합이 질서정연하고 잘 지정되고 공개적인 방식으로 개발되도록 하기 위해 MIME은 IANA\(Internet Assigned Numbers Authority\)를 해당 값의 중앙 레지스트리로 사용하는 등록 프로세스를 정의합니다. 부록 E는 IANA 등록이 수행되는 방법에 대한 세부 정보를 제공합니다.

마지막으로 상호 운용성을 지정하고 촉진하기 위해 이 문서의 부록 A는 이 문서의 "적합성"의 최소 수준을 정의하는 위 메커니즘의 하위 집합에 대한 기본 적용 가능성 설명을 제공합니다.

- HISTORICAL NOTE: 이 문서에 설명된 여러 메커니즘은 처음 읽을 때 다소 이상하거나 심지어 바로크처럼 보일 수 있습니다. 기존 표준과의 호환성 및 기존 관행 전반의 견고성이 이 문서를 개발한 작업 그룹의 최우선 순위 중 두 가지라는 점에 유의하는 것이 중요합니다. 특히 우아함보다 호환성이 항상 선호되었습니다.

MIME은 처음에 RFC 1341 및 1342\[RFC-1341\] \[RFC-1342\]로 정의되고 게시되었습니다. 이 문서는 RFC 1341의 비교적 사소한 업데이트이며 이를 대체하기 위한 것입니다. 이 문서와 RFC 1341의 차이점은 부록 H에 요약되어 있습니다. 이 프로토콜의 표준화 상태 및 상태에 대해서는 "IAB 공식 프로토콜 표준" 최신판을 참조하십시오. 여러 다른 RFC 문서, 특히 \[RFC 1343\], \[RFC-1344\] 및 \[RFC-1345\]와 같은 MIME 구현자가 관심을 가질 것입니다.

---
## **2.    Notations, Conventions, and Generic BNF Grammar**

이 문서는 일반 ASCII 텍스트와 PostScript\(PostScript는 Adobe Systems Incorporated의 상표입니다.\)의 두 가지 버전으로 게시됩니다. 텍스트 버전이 공식 사양이지만 포스트스크립트 버전이 더 읽기 쉽다는 사람들도 있을 것입니다. 문자 내용은 동일합니다. 이 문서의 Andrew 형식 사본은 첫 번째 저자\(Borenstein\)로부터도 구할 수 있습니다.

이 문서에 지정된 메커니즘은 모두 산문으로 설명되지만 대부분은 RFC 822의 수정된 BNF 표기법에도 공식적으로 설명되어 있습니다. 구현자는 이 사양을 이해하기 위해 이 표기법에 익숙해야 하며 자세한 내용은 RFC 822를 참조하십시오. 수정된 BNF 표기법에 대한 완전한 설명.

```text
   Some of the modified BNF in this document makes reference to
   syntactic entities that are defined in RFC 822 and not in this
   document.  A complete formal grammar, then, is obtained by combining
   the collected grammar appendix of this document with that of RFC 822
   plus the modifications to RFC 822 defined in RFC 1123, which
   specifically changes the syntax for `return', `date' and `mailbox'.
```

이 문서에서 CRLF라는 용어는 두 개의 ASCII 문자 CR\(13\) 및 LF\(10\)의 시퀀스를 의미하며 이 순서로 함께 사용하면 RFC 822 메일에서 줄 바꿈을 나타냅니다.

이 문서에서 "문자 집합"이라는 용어는 인코딩된 텍스트를 일련의 옥텟으로 변환하기 위해 하나 이상의 테이블과 함께 사용되는 방법을 나타냅니다. 이 정의는 ASCII와 같은 간단한 단일 테이블 매핑에서 ISO 2022 기술을 사용하는 것과 같은 복잡한 테이블 전환 방법에 이르기까지 다양한 종류의 텍스트 인코딩을 허용하기 위한 것입니다. 그러나 MIME 문자 집합 이름은 수행할 매핑을 완전히 지정해야 합니다.

"메시지"라는 용어는 추가로 한정되지 않는 경우 네트워크에서 전송되는 \(완전한 또는 "최상위"\) 메시지 또는 "메시지" 유형의 본문에 캡슐화된 메시지를 의미합니다.

이 문서에서 "본문 부분"이라는 용어는 다중 부분 엔터티의 본문 부분 중 하나를 의미합니다. 본문 부분에는 머리글과 본문이 있으므로 본문 부분의 본문에 대해 말하는 것이 좋습니다.

이 문서에서 "엔티티"라는 용어는 메시지 또는 본문 부분을 의미합니다. 모든 종류의 엔터티는 헤더와 본문이 있다는 속성을 공유합니다.

"본문"이라는 용어는 추가로 한정되지 않는 경우 엔터티의 본문, 즉 메시지 또는 본문 부분의 본문을 의미합니다.

- 참고: 앞의 네 가지 정의는 분명히 순환적입니다. 이는 MIME 메시지의 전체 구조가 실제로 재귀적이기 때문에 피할 수 없습니다.

이 문서에서 모든 숫자 및 옥텟 값은 십진수 표기법으로 제공됩니다.

이 문서에 정의된 Content-Type 값, 하위 유형 및 매개변수 이름은 대소문자를 구분하지 않는다는 점에 유의해야 합니다. 그러나 매개변수 값은 특정 매개변수에 대해 달리 지정되지 않는 한 대소문자를 구분합니다.

- 서식 참고: 이 문서는 읽기 쉽도록 신중하게 서식을 지정했습니다. 특히 이 문서의 PostScript 버전은 독자가 건너뛸 수 있는 이와 같은 메모를 작고 이탤릭체 글꼴로 배치하고 들여쓰기도 합니다. 텍스트 버전에서는 들여쓰기만 유지되므로 이 텍스트 버전을 읽는 경우 대신 PostScript 버전을 사용하는 것이 좋습니다. 그러나 이러한 모든 메모는 텍스트 버전에서도 들여쓰기되고 앞에 "NOTE:" 또는 유사한 소개가 붙습니다.

- 이러한 비필수 메모의 주된 목적은 이 문서의 이론적 근거에 대한 정보를 전달하거나 이 문서를 적절한 역사적 또는 진화적 맥락에 배치하는 것입니다. 이러한 정보는 적합 구현을 구축하는 데 전적으로 집중하는 사람들은 건너뛸 수 있지만 이 문서가 있는 그대로 작성된 이유를 이해하려는 사람들에게는 유용할 수 있습니다.

- 쉽게 알아볼 수 있도록 모든 BNF 정의는 이 문서의 PostScript 버전에서 고정 너비 글꼴로 배치되었습니다.

---
## **3.    The MIME-Version Header Field**

RFC 822가 1982년에 발표된 이후 인터넷 메시지에 대한 형식 표준은 단 하나뿐이었고 사용 중인 형식 표준을 선언할 필요성이 거의 인식되지 않았습니다. 이 문서는 RFC 822를 보완하는 독립 문서입니다. 이 문서의 확장은 RFC 822와 호환되는 방식으로 정의되었지만 메일 처리 대리인이 알고 있어야 하는 상황이 여전히 있습니다. 새 표준을 염두에 두고 메시지를 작성했는지 여부.

따라서 이 문서에서는 사용 중인 인터넷 메시지 본문 형식 표준의 버전을 선언하는 데 사용되는 새로운 헤더 필드인 "MIME-Version"을 정의합니다.

이 문서에 따라 작성된 메시지는 다음을 포함해야 합니다.\(MUST\)

다음 약어 텍스트가 포함된 헤더 필드:

```text
   MIME-Version: 1.0
```

이 헤더 필드의 존재는 메시지가 이 문서에 따라 작성되었다는 주장입니다.

향후 문서에서 메시지 형식 표준을 다시 확장할 수 있으므로 MIME-Version 필드의 내용에 대해 공식적인 BNF가 제공됩니다.

```text
   version := "MIME-Version" ":" 1*DIGIT "." 1*DIGIT
```

따라서 "1.0"을 대체하거나 확장할 수 있는 향후 형식 지정자는 마침표로 구분된 두 개의 정수 필드로 제한됩니다. 메시지가 "1.0" 이외의 MIME 버전 값으로 수신되면 이 사양을 준수한다고 가정할 수 없습니다.

MIME-Version 헤더 필드는 메시지의 최상위 수준에 필요합니다. 멀티파트 엔터티의 각 본문 부분에는 필요하지 않습니다. 포함된 메시지 자체가 MIME 준수라고 주장되는 경우에만 "메시지" 유형 본문의 포함된 헤더에 필요합니다.

이 문서에 정의된 대로 MIME을 준수하는 메일 판독기가 "1.0"이 아닌 MIME-Version 값으로 미래에 도착할 수 있는 메시지를 처리하는 방법을 완전히 지정하는 것은 불가능합니다. 그러나 호환 소프트웨어는 버전 번호를 확인하고 인식할 수 없는 MIME 버전이 있으면 최소한 사용자에게 경고하도록 권장됩니다.

특정 콘텐츠 유형에 대한 버전 제어가 MIME 버전 메커니즘을 사용하여 수행되지 않는다는 점도 주목할 가치가 있습니다. 특히 일부 형식\(예: 응용 프로그램/포스트스크립트\)에는 문서 형식 내부의 버전 번호 지정 규칙이 있습니다. 이러한 규칙이 존재하는 경우 MIME은 이를 대체하지 않습니다. 이러한 규칙이 없는 경우 MIME 유형은 필요한 경우 콘텐츠 유형 필드에서 "버전" 매개변수를 사용할 수 있습니다.

구현자에 대한 참고 사항: MIME-Version, Content-type 등을 포함하여 이 문서에 정의된 모든 헤더 필드는 RFC 822에 지정된 헤더 필드에 대한 일반 구문 규칙을 따릅니다. 특히 모두 주석을 포함할 수 있습니다. 다음 두 MIME 버전 필드는 동일합니다.

```text
                    MIME-Version: 1.0
                    MIME-Version: 1.0 (Generated by GBD-killer 3.7)
```

---
## **4.    The Content-Type Header Field**

Content-Type 필드의 목적은 수신하는 사용자 에이전트가 적절한 에이전트나 메커니즘을 선택하여 사용자에게 데이터를 표시하거나 적절한 방식으로 데이터를 처리할 수 있도록 본문에 포함된 데이터를 충분히 설명하는 것입니다.

역사적 참고: Content-Type 헤더 필드는 RFC 1049에서 처음 정의되었습니다. RFC 1049 Content-types는 더 간단하고 덜 강력한 구문을 사용했지만 여기에 제공된 메커니즘과 대부분 호환됩니다.

Content-Type 헤더 필드는 유형 및 하위 유형 식별자를 제공하고 특정 유형에 필요할 수 있는 보조 정보를 제공하여 엔티티 본문의 데이터 특성을 지정하는 데 사용됩니다. 유형 및 하위 유형 이름 다음의 나머지 헤더 필드는 속성/값 표기법으로 지정된 매개변수 집합입니다. 의미 있는 매개변수 세트는 유형에 따라 다릅니다. 특히 모든 콘텐츠 유형에 적용되는 전역적으로 의미 있는 매개변수는 없습니다. 전역 메커니즘은 추가 Content-\* 헤더 필드의 정의에 의해 MIME 모델에서 가장 잘 처리됩니다. 매개변수의 순서는 중요하지 않습니다. 정의된 매개변수 중에는 본문에서 사용되는 문자 세트를 선언할 수 있는 "charset" 매개변수가 있습니다. 구조화된 헤더 필드에 대한 RFC 822 규칙에 따라 주석이 허용됩니다.

일반적으로 최상위 수준의 Content-Type은 일반적인 데이터 유형을 선언하는 데 사용되는 반면 하위 유형은 해당 데이터 유형에 대한 특정 형식을 지정합니다. 따라서 "image/xyz"의 Content-Type은 사용자 에이전트가 특정 이미지 형식 "xyz"에 대해 알지 못하는 경우에도 사용자 에이전트에게 데이터가 이미지임을 알리기에 충분합니다. 예를 들어 이러한 정보는 인식할 수 없는 하위 유형의 원시 데이터를 사용자에게 표시할지 여부를 결정하는 데 사용할 수 있습니다. 이러한 작업은 인식할 수 없는 텍스트 하위 유형에는 적합하지만 인식할 수 없는 이미지 또는 오디오 하위 유형에는 적합하지 않을 수 있습니다. 이러한 이유로 오디오, 이미지, 텍스트 및 비디오의 등록된 하위 유형에는 실제로 다른 유형의 임베디드 정보가 포함되어서는 안 됩니다. 이러한 복합 유형은 "multipart" 또는 "application" 유형을 사용하여 나타내야 합니다.

매개변수는 콘텐츠 하위 유형의 수정자이며 기본적으로 호스트 시스템의 요구사항에 영향을 미치지 않습니다. 대부분의 매개변수는 특정 콘텐츠 유형에서만 의미가 있지만 다른 매개변수는 모든 하위 유형에 적용할 수 있다는 점에서 "전역적"입니다. 예를 들어 "boundary" 매개변수는 "multipart" 콘텐츠 유형에만 의미가 있지만 "charset" 매개변수는 여러 콘텐츠 유형에 적합할 수 있습니다.

7개의 콘텐츠 유형의 초기 집합이 이 문서에 의해 정의됩니다. 이 최상위 이름 세트는 실질적으로 완전하도록 의도되었습니다. 일반적으로 이러한 초기 유형의 새 하위 유형을 생성하여 더 큰 지원 유형 세트에 대한 추가를 수행할 수 있습니다. 앞으로는 이 표준의 확장에 의해서만 더 많은 최상위 유형이 정의될 수 있습니다. 어떤 이유로든 다른 기본 유형을 사용하려면 비표준 상태를 나타내고 향후 공식 이름과 잠재적인 충돌을 피하기 위해 "X-"로 시작하는 이름을 지정해야 합니다.

RFC 822의 Augmented BNF 표기법에서 Content-Type 헤더 필드 값은 다음과 같이 정의됩니다.

```text
     content  :=   "Content-Type"  ":"  type  "/"  subtype  *(";"
     parameter)
               ; case-insensitive matching of type and subtype

     type :=          "application"     / "audio"
               / "image"           / "message"
               / "multipart"  / "text"
               / "video"           / extension-token
               ; All values case-insensitive

     extension-token :=  x-token / iana-token

     iana-token := <a publicly-defined extension token,
               registered with IANA, as specified in
               appendix E>

     x-token := <The two characters "X-" or "x-" followed, with
                 no intervening white space, by any token>

     subtype := token ; case-insensitive

     parameter := attribute "=" value

     attribute := token   ; case-insensitive

     value := token / quoted-string

     token  :=  1*<any (ASCII) CHAR except SPACE, CTLs,
                   or tspecials>

     tspecials :=  "(" / ")" / "<" / ">" / "@"
                /  "," / ";" / ":" / "\" / <">
                /  "/" / "[" / "]" / "?" / "="
               ; Must be in quoted-string,
               ; to use within parameter values
```

"tspecials"의 정의는 세 개의 문자 "/", "?" 및 "="가 추가되고 "."가 제거된 "specials"의 RFC 822 정의와 동일합니다.

또한 하위 유형 사양은 MANDATORY입니다. 기본 하위 유형이 없습니다.

유형, 하위 유형 및 매개변수 이름은 대소문자를 구분하지 않습니다. 예를 들어 TEXT, Text 및 TeXt는 모두 동일합니다. 매개변수 값은 일반적으로 대소문자를 구분하지만 특정 매개변수는 용도에 따라 대소문자를 구분하지 않는 것으로 해석됩니다. \(예를 들어, 다중 부분 경계는 대소문자를 구분하지만 message/External-body에 대한 "액세스 유형"은 대소문자를 구분하지 않습니다.\)

이 구문 외에 하위 유형 이름 정의에 대한 유일한 제약 조건은 용도가 충돌하지 않아야 한다는 것입니다. 즉, 서로 다른 두 가지를 의미하기 위해 "Content-Type: application/foobar"를 사용하는 두 개의 서로 다른 커뮤니티가 있는 것은 바람직하지 않습니다. 새로운 콘텐츠 하위 유형을 정의하는 프로세스는 제한을 부과하기 위한 메커니즘이 아니라 단순히 용도를 공개하기 위한 메커니즘입니다. 따라서 새로운 Content-Type 하위 유형을 정의하는 데 사용할 수 있는 두 가지 메커니즘이 있습니다.

1. 비공개 값\("X-"로 시작\)은

- 외부 등록 또는 표준화 없이 2개의 협력 에이전트 사이에서 양자적으로 정의됨.

2. 새로운 표준 값을 문서화해야 합니다.

- 부록 E에 설명된 대로 IANA에 등록되고 IANA의 승인을 받았습니다. 공용으로 사용하려는 경우 참조하는 형식도 게시된 사양에 의해 정의되어야 하며 표준화를 위해 제공되어야 합니다.

7개의 표준 초기 사전 정의 콘텐츠 유형은 이 문서의 대부분에 자세히 설명되어 있습니다. 그들은:

```text
    text -- textual information.  The primary subtype,
         "plain", indicates plain (unformatted) text.  No
         special software is required to get the full
         meaning of the text, aside from support for the
         indicated character set.  Subtypes are to be used
         for enriched text in forms where application
         software may enhance the appearance of the text,
         but such software must not be required in order to
         get the general idea of the content.  Possible
         subtypes thus include any readable word processor
```

체재. 매우 간단하고 휴대 가능한 하위 유형,

- 리치 텍스트는 RFC 1341에 정의되어 있으며 향후 개정이 예상됩니다.

multipart -- 여러 부분으로 구성된 데이터

- 독립적인 데이터 유형. 기본 "혼합" 하위 유형, 동일한 데이터를 여러 형식으로 나타내는 "대안", 동시에 표시되는 부분에 대한 "병렬", 각 부분이 다음과 같은 다중 부분 엔터티에 대한 "다이제스트"를 포함하여 4개의 초기 하위 유형이 정의됩니다. "메시지"를 입력하십시오.

메시지 -- 캡슐화된 메시지. 의 몸

- Content-Type "메시지"는 그 자체로 다른 Content-Type 헤더 필드를 포함할 수 있는 완전한 형식의 RFC 822 준수 메시지의 전부 또는 일부입니다. 기본 하위 유형은 "rfc822"입니다. "부분" 하위 유형은 메일 전송 시설을 통과하기에는 너무 크다고 생각되는 본문의 단편화된 전송을 허용하기 위해 부분 메시지에 대해 정의됩니다. 또 다른 하위 유형인 "External-body"는 외부 데이터 소스를 참조하여 큰 몸체를 지정하기 위해 정의됩니다.

이미지 -- 이미지 데이터. 이미지에는 디스플레이 장치가 필요합니다.

- \(그래픽 디스플레이, 프린터 또는 FAX 기계 등\) 정보를 볼 수 있습니다. 초기 하위 유형은 널리 사용되는 두 가지 이미지 형식인 jpeg 및 gif에 대해 정의됩니다.

오디오 -- 초기 하위 유형이 "기본"인 오디오 데이터.

- 오디오는 콘텐츠를 "표시"하기 위해 오디오 출력 장치\(예: 스피커 또는 전화기\)가 필요합니다.

비디오 -- 비디오 데이터. 비디오에는 다음 기능이 필요합니다.

- 일반적으로 특수 하드웨어 및 소프트웨어를 포함하는 동영상을 표시합니다. 초기 하위 유형은 "mpeg"입니다.

응용 -- 다른 종류의 데이터, 일반적으로

- 해석되지 않은 이진 데이터 또는 메일 기반 애플리케이션에서 처리할 정보. 기본 하위 유형인 "octet-stream"은 해석되지 않은 이진 데이터의 경우에 사용되며, 이 경우 가장 간단한 권장 작업은 사용자를 위해 정보를 파일에 쓰도록 제안하는 것입니다.

추가 하위 유형인 "PostScript"가 정의됩니다.

- PostScript 문서를 본문으로 전송합니다. "응용 프로그램"의 다른 예상 용도에는 스프레드시트, 메일 기반 일정 시스템용 데이터 및 "활성"\(계산\) 이메일용 언어가 포함됩니다. \(활성 이메일 및 기타 응용 프로그램 데이터는 특히 응용 프로그램/PostScript의 맥락에서 이 메모의 뒷부분에서 논의되는 몇 가지 보안 고려 사항을 수반할 수 있습니다.\)

기본 RFC 822 메시지는 "Content-type: text/plain; charset=us-ascii"로 명시적으로 지정할 수 있는 US-ASCII 문자 집합의 일반 텍스트로 이 프로토콜에 의해 입력됩니다. Content-Type이 지정되지 않은 경우 이 기본값이 사용됩니다. MIME-Version 헤더 필드가 있는 경우 수신 사용자 에이전트는 일반 US-ASCII 텍스트가 발신자의 의도라고 가정할 수도 있습니다. MIME 버전 사양이 없는 경우에도 일반 US-ASCII 텍스트로 가정해야 하지만 보낸 사람의 의도는 그렇지 않았을 수 있습니다.

- 근거: Content-Type 헤더 필드나 MIME-Version 헤더 필드가 없으면 메시지가 실제로 US-ASCII 문자 집합의 텍스트인지 확신할 수 없습니다. 이 문서 이전의 규칙에는 다른 문자 집합의 텍스트 또는 자동으로 인식할 수 없는 방식의 비텍스트 데이터\(예: uuencoded 압축 UNIX tar 파일\)가 포함됩니다. 유형이 지정되지 않은 메시지를 "text/plain; charset=us-ascii"로 처리하는 것 외에 완전히 수용 가능한 대안이 없지만 구현자는 메시지에 MIME-Version 및 Content-Type 헤더 필드가 모두 없는 경우 연습에는 거의 모든 것이 포함됩니다.

여기에 제공된 Content-Type 값 목록은 위에서 설명한 메커니즘을 통해 시간이 지남에 따라 증가할 수 있으며 하위 유형 집합이 크게 증가할 것으로 예상된다는 점에 유의해야 합니다.

메일 리더가 알 수 없는 Content-type 값을 가진 메일을 발견하면 일반적으로 이 문서의 뒷부분에서 설명하는 것처럼 "application/octet-stream"과 동일하게 처리해야 합니다.

---
## **5.    The Content-Transfer-Encoding Header Field**

이메일을 통해 유용하게 전송될 수 있는 많은 콘텐츠 유형은 8비트 문자 또는 이진 데이터로 "자연스러운" 형식으로 표현됩니다. 이러한 데이터는 일부 전송 프로토콜을 통해 전송할 수 없습니다. 예를 들어 RFC 821은 메일 메시지를 1000자 이하의 줄이 있는 7비트 US-ASCII 데이터로 제한합니다.

따라서 이러한 데이터를 7비트 쇼트 라인 형식으로 다시 인코딩하기 위한 표준 메커니즘을 정의해야 합니다. 이 문서는 그러한 인코딩이 새로운 "Content- Transfer-Encoding" 헤더 필드로 표시될 것이라고 지정합니다. Content-Transfer-Encoding 필드는 전송에 적합한 방식으로 본문을 표현하기 위해 사용된 변환 유형을 나타내는 데 사용됩니다.

Content-Types와 달리 Content-Transfer-Encoding 값의 확산은 바람직하지 않으며 불필요합니다. 그러나 단일 Content-Transfer-Encoding 메커니즘만 설정하는 것은 불가능해 보입니다. 대부분 이진 데이터의 간결하고 효율적인 인코딩에 대한 요구와 전체는 아니지만 대부분이 7비트 데이터인 데이터의 읽을 수 있는 인코딩에 대한 요구 사이에는 절충안이 있습니다. 이러한 이유로 "읽을 수 있는" 인코딩과 "조밀한" 인코딩의 두 가지 인코딩 메커니즘이 필요합니다.

Content-Transfer-Encoding 필드는 데이터 유형의 "네이티브" 표현과 RFC 821\(SMTP\)에서 정의한 것과 같은 7비트 메일 전송 프로토콜을 사용하여 쉽게 교환할 수 있는 표현 사이의 반전 가능한 매핑을 지정하도록 설계되었습니다. . 이 필드는 이전 표준에 의해 정의되지 않았습니다. 필드의 값은 아래 열거된 대로 인코딩 유형을 지정하는 단일 토큰입니다. 공식적으로:

```text
   encoding := "Content-Transfer-Encoding" ":" mechanism

   mechanism :=     "7bit"  ;  case-insensitive
                  / "quoted-printable"
                  / "base64"
                  / "8bit"
                  / "binary"
                  / x-token
```

이 값은 대소문자를 구분하지 않습니다. 즉, Base64와 BASE64 및 bAsE64는 모두 동일합니다. 인코딩 유형이 7BIT인 경우 본문이 이미 7비트 메일 준비 표현에 있어야 합니다. 이것이 기본값입니다. 즉, Content-Transfer-Encoding 헤더 필드가 없는 경우 "Content-Transfer-Encoding: 7BIT"로 간주됩니다.

값 "8bit", "7bit" 및 "binary"는 모두 인코딩이 수행되지 않았음을 의미합니다. 그러나 객체에 포함된 데이터의 종류와 주어진 전송 시스템에서 전송을 위해 수행해야 하는 인코딩 종류를 나타내는 데 잠재적으로 유용합니다. 특히:

"7bit"는 데이터가 모두 short로 표현됨을 의미합니다.

- US-ASCII 데이터 라인.

"8비트"는 라인이 짧다는 것을 의미하지만

- ASCII가 아닌 문자\(상위 비트가 설정된 옥텟\).

"바이너리"는 ASCII가 아닌 문자뿐만 아니라

- 존재하지만 SMTP 전송을 위해 회선이 반드시 짧을 필요는 없습니다.

"8비트"\(또는 다른 생각할 수 있는 비트 폭 토큰\)와 "바이너리" 토큰의 차이점은 "바이너리"는 라인 길이 또는 SMTP CRLF 시맨틱에 대한 제한을 준수할 필요가 없다는 점입니다. 그러한 준수가 필요합니다. 본문에 7비트 이외의 비트 폭의 데이터가 포함된 경우 적절한 비트 폭 Content-Transfer-Encoding 토큰을 사용해야 합니다\(예: 인코딩되지 않은 8비트 폭 데이터의 경우 "8bit"\). 본문에 이진 데이터가 포함된 경우 "이진" Content-Transfer-Encoding 토큰을 사용해야 합니다.

- 참고: "binary", "8bit" 등의 Content-Transfer-Encoding 값 간의 구분은 중요하지 않은 것처럼 보일 수 있습니다. 전송을 위한 데이터. 그러나 명확한 라벨링은 RFC 821 전송 제한 사항을 충족하지 않는 데이터 전송 기능이 다른 미래의 메일 전송 시스템 간의 게이트웨이에 엄청난 가치가 있을 것입니다.

- 인코딩되지 않은 8비트 데이터에 대한 메일 전송은 RFC-1426\[RFC-1426\]에 정의되어 있습니다. 이 문서의 출판 당시에는 메일 본문에 인코딩되지 않은 이진 데이터를 포함하는 것이 합법적인 표준화된 인터넷 메일 전송이 없습니다. 따라서 "바이너리" Content-Transfer-Encoding이 실제로 인터넷에서 합법적인 상황은 없습니다. 그러나 이진 메일 전송이 인터넷 메일에서 현실이 되거나 이 문서가 다른 이진 가능 전송 메커니즘과 함께 사용되는 경우 이 메커니즘을 사용하여 이진 본문에 레이블을 지정해야 합니다.

- 참고: Content-Transfer-Encoding 필드에 대해 정의된 5개의 값은 인코딩된 알고리즘 또는 인코딩되지 않은 경우 전송 시스템 요구 사항 외에는 Content-Type에 대해 아무 것도 암시하지 않습니다.

구현자는 필요한 경우 새 Content-Transfer-Encoding 값을 정의할 수 있지만 비표준 상태를 나타내기 위해 "X-" 접두사가 붙은 이름인 x-token을 사용해야 합니다\(예: "Content-Transfer-Encoding: x-my-new-encoding". 그러나 Content-Types 및 하위 유형과 달리 새로운 Content-Transfer-Encoding 값을 생성하는 것은 잠재적인 이점이 거의 없이 상호 운용성을 방해할 가능성이 있으므로 명시적으로 강력하게 권장하지 않습니다. 그들의 사용은

협력하는 사용자 에이전트 간의 합의 결과입니다.

Content-Transfer-Encoding 헤더 필드가 메시지 헤더의 일부로 나타나면 해당 메시지의 전체 본문에 적용됩니다. Content-Transfer-Encoding 헤더 필드가 본문 부분 헤더의 일부로 나타나면 해당 본문 부분에만 적용됩니다. 엔티티가 "multipart" 또는 "message" 유형인 경우 Content-Transfer-Encoding은 비트 폭\(예: "7bit", "8bit" 등\) 또는 "binary" 이외의 값을 가질 수 없습니다. .

이메일은 문자 지향적이므로 여기에 설명된 메커니즘은 비트 스트림이 아닌 임의의 옥텟 스트림을 인코딩하기 위한 메커니즘이라는 점에 유의해야 합니다. 비트 스트림이 이러한 메커니즘 중 하나를 통해 인코딩되는 경우 먼저 네트워크 표준 비트 순서\("big-endian"\)를 사용하여 8비트 바이트 스트림으로 변환되어야 합니다. 바이트의 상위 비트. 8비트 경계에서 끝나지 않는 비트 스트림은 0으로 채워야 합니다. 이 문서는 "padding" 매개변수가 있는 애플리케이션 Content-Type의 경우 이러한 패딩 추가를 알리는 메커니즘을 제공합니다.

여기에 정의된 인코딩 메커니즘은 모든 데이터를 ASCII로 명시적으로 인코딩합니다. 따라서 예를 들어 엔티티에 다음과 같은 헤더 필드가 있다고 가정합니다.

```text
        Content-Type: text/plain; charset=ISO-8859-1
        Content-transfer-encoding: base64
```

이는 본문이 원래 ISO-8859-1에 있던 데이터의 base64 ASCII 인코딩이며 디코딩 후 다시 해당 문자 집합에 있음을 의미하는 것으로 해석되어야 합니다.

다음 섹션에서는 두 가지 표준 인코딩 메커니즘을 정의합니다. 새로운 콘텐츠 전송 인코딩의 정의는 명시적으로 권장되지 않으며 절대적으로 필요한 경우에만 발생해야 합니다. "X-"로 시작하는 것을 제외한 모든 콘텐츠 전송 인코딩 네임스페이스는 향후 사용을 위해 IANA에 명시적으로 예약되어 있습니다. 콘텐츠 전송 인코딩에 대한 사적인 계약도 명시적으로 권장되지 않습니다.

특정 Content-Transfer-Encoding 값은 특정 Content-Types에서만 사용될 수 있습니다. 특히 "multipart" 및 "message" Content- 유형. multipart 또는 message 유형의 본문에 필요한 모든 인코딩은 인코딩해야 하는 실제 본문을 인코딩하여 가장 안쪽 수준에서 수행되어야 합니다.

- 인코딩 제한에 대한 참고 사항: multipart 또는 message 유형의 데이터에 대한 콘텐츠 전송 인코딩 사용에 대한 금지가 지나치게 제한적으로 보일 수 있지만 데이터가 인코딩 알고리즘을 통해 여러 번 전달되는 중첩 인코딩을 방지하고 제대로 보려면 여러 번 디코딩해야 합니다. 중첩 인코딩은 사용자 에이전트에 상당한 복잡성을 추가합니다. 이러한 다중 인코딩의 명백한 효율성 문제 외에도 메시지의 기본 구조를 모호하게 할 수 있습니다. 특히 메시지에 포함된 개체 유형을 찾기 위해 여러 디코딩 작업이 필요함을 암시할 수 있습니다. 중첩된 인코딩을 금지하면 특정 메일 게이트웨이의 작업이 복잡해질 수 있지만 이는 중첩된 인코딩이 사용자 에이전트에 미치는 영향보다 덜 문제인 것 같습니다.

- 콘텐츠 유형과 콘텐츠 전송 인코딩 간의 관계에 대한 참고 사항: 콘텐츠 전송 인코딩은 인코딩될 콘텐츠 유형의 특성에서 유추될 수 있거나 최소한 특정 Content-Transfer-Encoding은 특정 Content-Type과 함께 사용하도록 요구될 수 있습니다. 이것이 사실이 아닌 몇 가지 이유가 있습니다. 첫째, 메일에 사용되는 다양한 유형의 전송이 주어지면 일부 인코딩은 일부 Content-Type/전송 조합에 적합할 수 있으며 다른 것에는 적합하지 않을 수 있습니다. \(예를 들어, 8비트 전송에서 특정 문자 집합의 텍스트에는 인코딩이 필요하지 않지만 7비트 SMTP에는 이러한 인코딩이 분명히 필요합니다.\) 둘째, 특정 콘텐츠 유형은 다음과 같은 다른 유형의 전송 인코딩이 필요할 수 있습니다 다른 상황. 예를 들어 많은 PostScript 본문은 전체가 7비트 데이터의 짧은 줄로 구성되어 있으므로 인코딩이 거의 또는 전혀 필요하지 않을 수 있습니다. 다른 PostScript 본문\(특히 레벨 2 PostScript의 이진 인코딩 메커니즘을 사용하는 본문\)은 이진 전송 인코딩을 사용하여만 적절하게 표현될 수 있습니다. 마지막으로 Content-Type은 개방형 사양 메커니즘을 의도하기 때문에 Content-Type과 인코딩 사이의 연관성에 대한 엄격한 사양은 애플리케이션 프로토콜의 사양을 특정 하위 수준 전송과 효과적으로 결합합니다. Content-Type의 개발자가 사용 중인 모든 전송과 그 제한 사항을 알 필요가 없기 때문에 이는 바람직하지 않습니다.

- 번역 인코딩에 대한 참고 사항: quoted-printable 및 base64 인코딩은 변환이 가능하도록 설계되었습니다. 이러한 변환에서 발생하는 유일한 문제는 줄 바꿈 처리입니다. quoted-printable에서 base64로 변환할 때 줄 바꿈을 CRLF 시퀀스로 변환해야 합니다. 마찬가지로 base64 데이터의 CRLF 시퀀스는 따옴표로 묶인 인쇄 가능한 줄 바꿈으로 변환되어야 하지만 텍스트 데이터를 변환할 때만 가능합니다.

- 표준 인코딩 모델에 대한 참고 사항: 이 메모의 초기 초안에는 이메일 데이터가 표준 형식으로 변환되고 인코딩되는 시기에 대한 모델과 특히 이 프로세스가 CRLF 처리에 어떤 영향을 미치는지에 대해 약간의 혼란이 있었습니다. 줄 바꿈의 표현은 시스템마다 크게 다르고 콘텐츠 전송 인코딩과 문자 집합 간의 관계도 다릅니다. 이러한 이유로 인코딩을 위한 표준 모델이 부록 G로 제공됩니다.

---
### **5.1.  Quoted-Printable Content-Transfer-Encoding**

Quoted-Printable 인코딩은 주로 ASCII 문자 집합의 인쇄 가능한 문자에 해당하는 옥텟으로 구성된 데이터를 나타내기 위한 것입니다. 결과 옥텟이 메일 전송에 의해 수정되지 않는 방식으로 데이터를 인코딩합니다. 인코딩되는 데이터가 대부분 ASCII 텍스트인 경우 데이터의 인코딩된 형식은 대부분 사람이 인식할 수 있습니다. 전체가 ASCII인 본문은 메시지가 문자 변환 및/또는 줄 바꿈 게이트웨이를 통과하는 경우 데이터의 무결성을 보장하기 위해 Quoted-Printable로 인코딩될 수도 있습니다.

이 인코딩에서 옥텟은 다음 규칙에 의해 결정된 대로 표현됩니다.

- 규칙 #1: \(일반적인 8비트 표현\) 인코딩되는 데이터의 표준\(표준\) 형식의 개행 규칙에 따라 줄 바꿈을 나타내는 옥텟을 제외한 모든 옥텟은 "=" 다음에 옥텟 값의 두 자리 16진수 표현. 이를 위한 16진수 알파벳의 숫자는 "0123456789ABCDEF"입니다. 16진수 데이터를 보낼 때는 대문자를 사용해야 하지만 강력한 구현에서는 수신 시 소문자를 인식하도록 선택할 수 있습니다. 따라서 예를 들어 값 12\(ASCII 양식 피드\)는 "=0C"로 표시될 수 있고 값 61\(ASCII EQUAL SIGN\)은 "=3D"로 표시될 수 있습니다. 다음 규칙에서 대체 인코딩을 허용하는 경우를 제외하고 이 규칙은 필수입니다.

- 규칙 #2: \(리터럴 표현\) 십진수 값이 33에서 60까지, 62에서 126까지인 옥텟은 해당 옥텟에 해당하는 ASCII 문자로 표현될 수 있습니다. , 각각\).\(MAY\)

- 규칙 #3: \(공백\): 값이 9 및 32인 옥텟은 각각 ASCII TAB\(HT\) 및 SPACE 문자로 표시될 수 있지만 인코딩된 줄의 끝에 그렇게 표시되어서는 안 됩니다. 따라서 인코딩된 라인의 모든 TAB\(HT\) 또는 SPACE 문자는 해당 라인에서 인쇄 가능한 문자가 뒤따라야 합니다. 특히,\(MUST NOT, MUST\)

- 인코딩된 줄의 끝에서 "="는 소프트 줄 바꿈\(규칙 #5 참조\)이 하나 이상의 TAB\(HT\) 또는 SPACE 문자 뒤에 올 수 있음을 나타냅니다. 인코딩된 라인의 끝에 나타나는 값이 9 또는 32인 옥텟은 규칙 #1에 따라 표현되어야 합니다. 일부 MTA\(메시지 전송 에이전트, 한 사용자에서 다른 사용자로 메시지를 전송하거나 이러한 전송의 일부를 수행하는 프로그램\)는 텍스트 줄을 SPACE로 채우는 것으로 알려져 있고 다른 MTA는 "공백"을 제거하는 것으로 알려져 있기 때문에 이 규칙이 필요합니다. 줄 끝의 문자. 따라서 Quoted-Printable 본문을 디코딩할 때 줄의 후행 공백은 반드시 중간 전송 에이전트에 의해 추가되기 때문에 삭제해야 합니다.

- 규칙 #4\(줄 바꿈\): 텍스트 본문의 줄 바꿈은 인코딩되는 데이터의 표준 표현을 따르는 표현과 관계없이 CRLF 시퀀스인 \(RFC 822\) 줄 바꿈으로 표현되어야 합니다. , Quoted-Printable 인코딩에서. 텍스트 이외의 유형에 대한 정식 표현에는 일반적으로 줄 바꿈 표현이 포함되지 않으므로 인용 인쇄 가능 인코딩에서 하드 줄 바꿈\(즉, 의미 있고 사용자에게 표시하려는 줄 바꿈\)이 발생하지 않아야 합니다. 그런 유형. 물론 "=0D", "=0A", "0A=0D" 및 "=0D=0A"는 결국 발생합니다. 그러나 일반적으로 이진 데이터의 경우 인용 인쇄 가능보다 base64가 선호됩니다.

- 많은 구현은 부록 G에 설명된 대로 다양한 콘텐츠 유형의 로컬 표현을 직접 인코딩하도록 선택할 수 있습니다. 특히 이것은 CRLF 구분 기호 이외의 개행 규칙을 사용하는 시스템의 일반 텍스트 자료에 적용될 수 있습니다. 이러한 구현은 허용되지만 개행 시퀀스의 대체 표현이 사용되는 경우를 설명하기 위해 줄 바꿈 생성을 일반화해야 합니다.

- 규칙 #5\(부드러운 줄바꿈\): Quoted-Printable 인코딩에서는 인코딩된 줄의 길이가 76자 이하여야 합니다. Quoted-Printable 인코딩으로 긴 줄을 인코딩하려면 '부드러운' 줄 바꿈을 사용해야 합니다. 인코딩된 줄의 마지막 문자인 등호는 인코딩된 텍스트에서 중요하지 않은\('소프트'\) 줄 바꿈을 나타냅니다. 따라서 라인의 "원시" 형식이 다음과 같은 인코딩되지 않은 단일 라인인 경우:

지금은 온 국민이 힘을 모아야 할 때입니다.

- 그들의 나라.

- 이것은 Quoted-Printable 인코딩에서 다음과 같이 나타낼 수 있습니다.

지금이 그때 =

- 모든 사람들이 와서 = 조국을 돕기 위해.

- 사용자 에이전트에 의해 복원되는 방식으로 긴 줄이 인코딩되는 메커니즘을 제공합니다. 76자 제한은 후행 CRLF를 계산하지 않지만 등호를 포함하여 다른 모든 문자를 계산합니다.

하이픈 문자\("-"\)는 Quoted-Printable 인코딩에서 그 자체로 표현되기 때문에 다중 부분 엔터티에서 인용 인쇄 가능한 인코딩 본문을 캡슐화할 때 캡슐화 경계가 어디에도 나타나지 않도록 주의해야 합니다. 인코딩된 본체. \(좋은 전략은 인용된 인쇄 가능한 본문에 절대 나타날 수 없는 "=\_"와 같은 문자 시퀀스를 포함하는 경계를 선택하는 것입니다. 이 문서의 뒷부분에서 멀티파트 메시지의 정의를 참조하십시오.\)

- 참고: quoted-printable 인코딩은 전송 시 가독성과 안정성 간의 절충안을 나타냅니다. quoted-printable 인코딩으로 인코딩된 본문은 대부분의 메일 게이트웨이에서 안정적으로 작동하지만 일부 게이트웨이, 특히 EBCDIC로의 번역과 관련된 게이트웨이에서는 완벽하게 작동하지 않을 수 있습니다. \(이론적으로 EBCDIC 게이트웨이는 인용된 인쇄 가능한 본문을 디코딩하고 base64를 사용하여 다시 인코딩할 수 있지만 이러한 게이트웨이는 아직 존재하지 않습니다.\) base64 Content-Transfer-Encoding은 더 높은 수준의 신뢰도를 제공합니다. EBCDIC 게이트웨이를 통해 합리적으로 안정적인 전송을 얻는 방법은 ASCII 문자를 인용하는 것입니다.

```text
             !"#$@[\]^`{|}~
```

- 규칙 #1에 따라. 자세한 내용은 부록 B를 참조하십시오.

인용된 인쇄 가능 데이터는 일반적으로 줄 지향적인 것으로 간주되기 때문에 인용된 인쇄 가능 데이터 줄 사이의 구분 표시는 일반 텍스트 메일이 항상 변경된 것과 같은 방식으로 전송 시 변경될 수 있습니다. 줄 바꿈 규칙이 다른 시스템 간에 전달할 때 인터넷 메일에서. 이러한 변경으로 인해 데이터가 손상될 가능성이 있는 경우 quoted-printable 인코딩보다 base64 인코딩을 사용하는 것이 더 합리적일 수 있습니다.

구현자에 대한 경고: 이진 데이터가 quoted-printable로 인코딩된 경우 CR 및 LF 문자를 각각 "=0D" 및 "=0A"로 인코딩하도록 주의해야 합니다. 특히 바이너리 데이터의 CRLF 시퀀스는 "=0D=0A"로 인코딩되어야 합니다. 그렇지 않으면 CRLF가 하드 줄 바꿈으로 표시되면 잘못 디코딩될 수 있습니다.

줄 바꿈 규칙이 다른 플랫폼.

형식주의자의 경우 인용 인쇄 가능한 데이터의 구문은 다음 문법으로 설명됩니다.

인용 인쇄 가능 := \(\[\*\(ptext / SPACE / TAB\) ptext\] \["="\] CRLF\) ; CRLF를 제외한 최대 줄 길이는 76자입니다.

ptext := 옥텟 /<"=", SPACE 또는 TAB를 제외한 모든 ASCII 문자\> ; 부록 B에 "메일 안전"으로 나열되지 않은 문자; 또한 권장되지 않습니다.

옥텟 := "=" 2\(DIGIT / "A" / "B" / "C" / "D" / "E" / "F"\)

- ; 옥텟은 \> 127, =, SPACE 또는 TAB 문자에 사용되어야 합니다. 에 나열되지 않은 모든 문자에 권장됩니다. 부록 B는 "메일 안전"입니다.

---
### **5.2.  Base64 Content-Transfer-Encoding**

Base64 Content-Transfer-Encoding은 사람이 읽을 필요가 없는 형식으로 임의의 옥텟 시퀀스를 나타내도록 설계되었습니다. 인코딩 및 디코딩 알고리즘은 간단하지만 인코딩된 데이터는 인코딩되지 않은 데이터보다 일관되게 약 33%만 큽니다. 이 인코딩은 RFC 1421에 정의된 대로 PEM\(Privacy Enhanced Mail\) 애플리케이션에서 사용되는 것과 거의 동일합니다. base64 인코딩은 RFC 1421에서 채택되었으며 한 가지 변경 사항이 있습니다. base64는 포함된 일반 텍스트에 대한 "\*" 메커니즘을 제거합니다.

US-ASCII의 65자 하위 집합이 사용되어 인쇄 가능한 문자당 6비트를 나타낼 수 있습니다. \(추가 65번째 문자 "="는 특수 처리 기능을 나타내는 데 사용됩니다.\)

참고: 이 하위 집합에는 다음과 같은 중요한 속성이 있습니다.

- US ASCII를 포함하여 ISO 646의 모든 버전에서 동일하게 표현되며 하위 집합의 모든 문자도 모든 버전의 EBCDIC에서 동일하게 표현됩니다. uuencode 유틸리티에서 사용하는 인코딩 및 레벨 2 PostScript의 일부로 지정된 base85 인코딩과 같이 널리 사용되는 다른 인코딩은 이러한 속성을 공유하지 않으므로 메일용 이진 전송 인코딩이 충족해야 하는 이식성 요구 사항을 충족하지 않습니다.

인코딩 프로세스는 입력 비트의 24비트 그룹을 4개의 인코딩된 문자의 출력 문자열로 나타냅니다. 왼쪽에서 오른쪽으로 3개의 8비트 입력 그룹을 연결하여 24비트 입력 그룹을 형성합니다. 그런 다음 이 24비트는 4개의 연결된 6비트 그룹으로 취급되며, 각 그룹은 base64 알파벳에서 한 자리로 변환됩니다. base64 인코딩을 통해 비트 스트림을 인코딩할 때 비트 스트림은 가장 중요한 비트가 먼저 정렬되는 것으로 가정해야 합니다.

즉, 스트림의 첫 번째 비트는 첫 번째 바이트에서 상위 비트가 되고 여덟 번째 비트는 첫 번째 바이트에서 하위 비트가 됩니다.

각 6비트 그룹은 64개의 인쇄 가능한 문자 배열에 대한 인덱스로 사용됩니다. 색인이 참조하는 문자는 출력 문자열에 배치됩니다. 아래 표 1에 식별된 이러한 문자는 보편적으로 표시할 수 있도록 선택되었으며 SMTP\(예: ".", CR, LF\) 및 이 문서에 정의된 캡슐화 경계에 특별한 의미가 있는 문자는 제외됩니다\( 예: "-"\).

```text
                            Table 1: The Base64 Alphabet

      Value Encoding  Value Encoding  Value Encoding  Value Encoding
           0 A            17 R            34 i            51 z
           1 B            18 S            35 j            52 0
           2 C            19 T            36 k            53 1
           3 D            20 U            37 l            54 2
           4 E            21 V            38 m            55 3
           5 F            22 W            39 n            56 4
           6 G            23 X            40 o            57 5
           7 H            24 Y            41 p            58 6
           8 I            25 Z            42 q            59 7
           9 J            26 a            43 r            60 8
          10 K            27 b            44 s            61 9
          11 L            28 c            45 t            62 +
          12 M            29 d            46 u            63 /
          13 N            30 e            47 v
          14 O            31 f            48 w         (pad) =
          15 P            32 g            49 x
          16 Q            33 h            50 y
```

출력 스트림\(인코딩된 바이트\)은 각각 76자 이하의 라인으로 표시되어야 합니다. 표 1에 없는 모든 줄 바꿈 또는 기타 문자는 디코딩 소프트웨어에서 무시해야 합니다. base64 데이터에서 표 1 이외의 문자, 줄 바꿈 및 기타 공백은 전송 오류를 나타낼 수 있으며, 일부 상황에서는 이에 대한 경고 메시지 또는 메시지 거부가 적절할 수 있습니다.

인코딩 중인 데이터의 끝에서 사용할 수 있는 비트가 24비트 미만인 경우 특수 처리가 수행됩니다. 전체 인코딩 양자는 항상 본문의 끝에서 완료됩니다. 입력 그룹에서 사용할 수 있는 입력 비트가 24개 미만인 경우 0비트\(오른쪽\)가 추가되어 6비트 그룹의 정수를 형성합니다. 데이터 끝의 패딩은 '=' 문자를 사용하여 수행됩니다. 모든 base64 입력은 옥텟의 정수이므로 다음과 같은 경우에만 입력할 수 있습니다.

발생: \(1\) 인코딩 입력의 최종 양자는 24비트의 정수배입니다. 여기서 인코딩된 출력의 최종 단위는 "=" 패딩이 없는 4자의 정수 배수입니다. \(2\) 인코딩 입력의 최종 양자는 정확히 8비트입니다. 여기서 인코딩된 출력의 최종 단위는 두 개의 "=" 패딩 문자가 뒤따르는 두 문자이거나 \(3\) 인코딩 입력의 최종 양자는 정확히 16비트입니다. 여기서 인코딩된 출력의 최종 단위는 세 개의 문자와 하나의 "=" 패딩 문자입니다.

데이터 끝의 패딩에만 사용되기 때문에 '=' 문자의 발생은 데이터 끝에 도달했다는 증거로 간주될 수 있습니다\(전송 중 잘림 없음\). 그러나 전송된 옥텟 수가 3의 배수인 경우에는 그러한 보장이 불가능합니다.

```text
   Any characters outside of the base64 alphabet are to be ignored in
   base64-encoded data.  The same applies to any illegal sequence of
   characters in the base64 encoding, such as "====="
```

표준 형식으로 변환되지 않은 텍스트 자료에 base64 인코딩이 직접 적용되는 경우 줄바꿈에 적절한 옥텟을 사용하려면 주의를 기울여야 합니다. 특히 텍스트 줄 바꿈은 base64 인코딩 전에 CRLF 시퀀스로 변환되어야 합니다. 주목해야 할 중요한 점은 이것이 일부 구현의 사전 정규화 단계가 아니라 인코더에 의해 직접 수행될 수 있다는 것입니다.

참고: 명백한 인용에 대해 걱정할 필요가 없습니다.

- base64 인코딩에는 하이픈 문자가 사용되지 않기 때문에 멀티파트 엔터티의 base64 인코딩 부분 내의 캡슐화 경계.

---
## **6.    Additional Content-Header Fields**
---
### **6.1.  Optional Content-ID Header Field**

높은 수준의 사용자 에이전트를 구성할 때 한 본문이 다른 본문을 참조하도록 허용하는 것이 바람직할 수 있습니다. 따라서 본문은 "Message-ID" 헤더 필드와 구문적으로 동일한 "Content-ID" 헤더 필드를 사용하여 레이블을 지정할 수 있습니다.

id := "Content-ID" ":" msg-id Message-ID 값과 마찬가지로 Content-ID 값도 world-unique로 생성되어야 합니다.

Content-ID 값은 특히 메시지/외부 본문 메커니즘에서 참조하는 데이터를 캐싱하기 위해 여러 컨텍스트에서 MIME 엔터티를 고유하게 식별하는 데 사용될 수 있습니다. Content-ID 헤더는 일반적으로 선택 사항이지만

선택적 MIME 콘텐츠 유형 "message/external-body"의 데이터를 생성하는 구현. 즉, 각 메시지/외부 본문 엔터티에는 해당 데이터의 캐싱을 허용하는 Content-ID 필드가 있어야 합니다.

또한 Content-ID 값이 multipart/alternative 콘텐츠 유형의 경우 특별한 의미를 갖는다는 점도 주목할 가치가 있습니다. 이것은 multipart/alternative를 다루는 이 문서의 섹션에 설명되어 있습니다.

---
### **6.2.  Optional Content-Description Header Field**

일부 설명 정보를 주어진 본문과 연관시키는 기능은 종종 바람직합니다. 예를 들어 "이미지" 본문을 "우주 왕복선 엔데버의 사진"으로 표시하는 것이 유용할 수 있습니다. 이러한 텍스트는 Content-Description 헤더 필드에 배치될 수 있습니다.

```text
   description := "Content-Description" ":" *text
```

\[RFC-1522\]에 지정된 메커니즘이 US-ASCII가 아닌 콘텐츠 설명 값에 사용될 수 있지만 설명은 US-ASCII 문자 집합으로 제공되는 것으로 추정됩니다.

---
## **7.    The Predefined Content-Type Values**

이 문서는 비공개 또는 실험적 유형에 대한 7개의 초기 Content-Type 값과 확장 메커니즘을 정의합니다. 추가 표준 유형은 새로 게시된 사양에 의해 정의되어야 합니다. 여기에 정의된 7가지 유형의 하위 유형으로 새로운 유형의 메일에 대한 대부분의 혁신이 발생할 것으로 예상됩니다. 7가지 콘텐츠 유형의 가장 중요한 특성은 부록 F에 요약되어 있습니다.

---
## **7.1  The Text Content-Type**

텍스트 Content-Type은 주로 텍스트 형식의 자료를 전송하기 위한 것입니다. 기본 Content-Type입니다. "charset" 매개변수는 일부 텍스트 하위 유형, 특히 기본 하위 유형인 "text/plain"을 포함하여 일반\(포맷되지 않은\) 텍스트를 나타내는 본문 텍스트의 문자 집합을 나타내는 데 사용될 수 있습니다. 인터넷 메일의 기본 Content-Type은 "text/plain; charset=us-ascii"입니다.

일반 텍스트 외에도 "확장 텍스트"\(포맷 및 표시 정보가 포함된 텍스트\)를 나타내는 많은 형식이 있습니다. 이러한 많은 표현의 흥미로운 특징은 해석하는 소프트웨어 없이도 어느 정도 읽을 수 있다는 것입니다. 따라서 가장 높은 수준에서 다음과 같은 읽을 수 없는 데이터와 구별하는 것이 유용합니다.

읽을 수 없는 형식으로 표현된 이미지, 오디오 또는 텍스트. 적절한 해석 소프트웨어가 없는 경우 텍스트의 하위 유형을 사용자에게 표시하는 것이 합리적이지만 대부분의 비텍스트 데이터에 대해서는 그렇게 하는 것이 합리적이지 않습니다.

이러한 서식이 지정된 텍스트 데이터는 텍스트의 하위 유형을 사용하여 표현되어야 합니다. 그럴듯한 텍스트 하위 유형은 일반적으로 "텍스트/리치 텍스트"\[RFC-1341\]와 같은 표현 형식의 일반 이름으로 제공됩니다.

---
#### **7.1.1.     The charset parameter**

텍스트/일반 데이터에 대한 Content-Type 필드에 지정할 수 있는 중요한 매개변수는 문자 세트입니다. 이는 다음과 같이 "charset" 매개변수로 지정됩니다.

```text
        Content-type: text/plain; charset=us-ascii
```

일부 다른 매개변수 값과 달리 charset 매개변수의 값은 대소문자를 구분하지 않습니다. charset 매개 변수가 없는 경우 가정해야 하는 기본 문자 집합은 US-ASCII입니다.

"text"의 향후 하위 유형에 대한 사양은 "charset" 매개변수도 사용할지 여부를 지정해야 하며 해당 값도 제한할 수 있습니다. 특정 본문과 함께 사용될 때 "charset" 매개변수의 의미 체계는 여기에서 "text/plain"에 대해 지정된 것과 동일해야 합니다. 즉, 본문은 주어진 문자 집합의 문자로만 구성됩니다. 특히 미래 텍스트 하위 유형의 정의자는 해당 하위 유형 정의에 대한 멀티바이트 문자 집합의 의미에 세심한 주의를 기울여야 합니다.

이 RFC는 외부 프로파일링 정보가 필요하지 않은 매핑인 글리프에 대한 바이트 스트림의 고유한 매핑이 되도록 MIME의 목적을 위해 charset 매개 변수의 정의를 지정합니다.

미리 정의된 문자 집합 이름의 초기 목록은 이 섹션의 끝에서 찾을 수 있습니다. IANA에 추가 문자 세트를 등록할 수 있지만 사용 표준화에는 일반적인 IESG \[RFC-1340\] 검토 및 승인이 필요합니다. 지정된 문자 집합에 8비트 데이터가 포함된 경우 SMTP와 같은 일부 메일 전송 프로토콜을 통해 본문을 전송하려면 Content-Transfer-Encoding 헤더 필드와 데이터에 해당하는 인코딩이 필요합니다.

기본 문자 집합인 US-ASCII는 과거에 혼동과 모호함이 있었습니다. 정의에 약간의 모호성이 있었을 뿐만 아니라 실제로는 다양한 변형이 있었습니다. 이러한 모호함과 변수를 없애기 위해

미래에는 새로운 사용자 에이전트가 Content-Type 헤더 필드를 통해 문자 집합을 명시적으로 지정하는 것이 좋습니다. "US-ASCII"는 임의의 7비트 문자 코드를 나타내지 않지만 본문이 ASCII에 지정된 문자에 대한 코드의 정확한 대응을 사용하는 문자 코딩을 사용함을 지정합니다. ISO 646\[ISO-646\]의 국가별 사용 변형은 ASCII가 아니며 인터넷 메일에서의 사용은 명시적으로 권장되지 않습니다. 이와 관련하여 ISO 646 문자 집합의 생략은 의도적입니다. "US-ASCII"의 문자 집합 이름은 명시적으로 ANSI X3.4-1986 \[US-ASCII\]만 참조합니다. 문자 집합 이름 "ASCII"는 예약되어 있으며 어떤 용도로도 사용해서는 안 됩니다.

- 참고: RFC 821은 명시적으로 "ASCII"를 지정하고 미국 표준의 이전 버전을 참조합니다. Content-Type 및 문자 집합을 지정하는 목적 중 하나는 "strict ASCII" 이외의 것을 기본값으로 가정하면 의도하지 않고 호환되지 않는 위험이 있다고 가정하여 보낸 사람이 코딩된 메시지를 해석하려는 방법을 수신자가 명확하게 결정할 수 있도록 하는 것입니다. 현재 전송 중인 메시지의 의미 체계가 변경되었습니다. 이는 또한 ISO 646의 국가별 변형에 따라 코딩된 문자를 포함하거나 코드 전환 절차\(예: ISO 2022의 절차\)를 사용하는 메시지와 8비트 또는 다중 옥텟 문자 인코딩이 다음을 위해 적절한 문자 세트 사양을 사용해야 함을 의미합니다. 이 사양과 일치해야 합니다.\(MUST\)

전체 US-ASCII 문자 집합은 \[US-ASCII\]에 나열되어 있습니다. DEL\(0-31, 127\)을 포함한 제어 문자는 새 줄을 나타내는 조합 CRLF\(ASCII 값 13 및 10\) 외에 정의된 의미가 없습니다. 문자 중 두 개는 널리 사용되는 사실상의 의미를 갖습니다. FF\(12\)는 종종 "새 페이지의 시작 부분에서 후속 텍스트 시작"을 의미합니다. 그리고 TAB 또는 HT\(9\)는 종종\(항상은 아니지만\) "열 번호가 8의 배수인 현재 위치 다음으로 사용 가능한 다음 열로 커서를 이동\(첫 열을 열 0으로 계산\)"을 의미합니다. 이와는 별도로 본문에서 제어 문자 또는 DEL을 사용하는 것은 발신자와 수신자 간의 사적인 계약의 일부여야 합니다. 그러한 사적인 계약은 권장되지 않으며 이 문서의 다른 기능으로 대체되어야 합니다.

- 참고: US-ASCII를 넘어 문자 집합의 엄청난 확산이 가능합니다. 많은 수의 문자 집합이 좋은 것이 아니라는 것이 IETF 작업 그룹의 의견입니다. 전자 메일에서 전 세계 모든 언어를 나타내는 데 보편적으로 사용할 수 있는 단일 문자 집합을 지정하는 것이 좋습니다. 불행하게도 여러 커뮤니티의 기존 관행은 가까운 장래에 여러 문자 집합을 계속 사용할 것으로 보입니다. 이러한 이유로 우리는 다음을 정의합니다.

- 강력한 구성 기반이 존재하는 소수의 문자 집합에 대한 이름.

정의된 문자 집합 값은 다음과 같습니다.

US-ASCII -- \[US-ASCII\]에 정의된 대로.

- ISO-8859-X -- 여기서 "X"는 필요에 따라 ISO-8859 \[ISO-8859\]의 부품으로 대체됩니다. ISO 646 문자 집합은 인터넷 메일용으로 지정된 문자 집합인 8859를 대체하기 위해 의도적으로 생략되었습니다. 이 문서 발행 시점에서 "X"의 합법적인 값은 1에서 9까지의 숫자입니다.

위에서 지정한 문자 집합은 MIME 초안을 작성하는 동안 상대적으로 논쟁의 여지가 없는 문자 집합입니다. 이 문서는 US-ASCII 이외의 특정 문자 집합의 사용을 보증하지 않으며 세계 문자 집합의 향후 발전이 불확실하다는 점을 인식합니다. 향후 MIME에서 사용하기 위해 추가 문자 집합이 등록될 것으로 예상됩니다.

US-ASCII가 아닌 경우 사용되는 문자 집합은 항상 Content-Type 필드에 명시적으로 지정되어야 합니다.

공식 사양을 게시하고 IANA에 등록하지 않거나 사설 계약에 의하지 않고 인터넷 메일에서 다른 문자 집합 이름을 사용할 수 없습니다. 이 경우 문자 집합 이름은 "X-"로 시작해야 합니다.

구현자는 반드시 필요한 경우가 아니면 메일 사용을 위한 새 문자 집합을 정의하지 않는 것이 좋습니다.

"charset" 매개변수는 주로 텍스트 데이터의 목적으로 정의되었으며 이러한 이유로 이 섹션에서 설명합니다. 그러나 텍스트가 아닌 데이터도 어떤 목적을 위해 문자 집합 값을 지정하려고 할 수 있으며, 이 경우 동일한 구문과 값을 사용해야 합니다.

일반적으로 메일 전송 소프트웨어는 항상 가능한 "최소 공통 분모" 문자 집합을 사용해야 합니다. 예를 들어, 본문에 US-ASCII 문자만 포함된 경우 ISO-8859-1이 아닌 US-ASCII 문자 집합에 있는 것으로 표시되어야 합니다. US-ASCII의. 보다 일반적으로 널리 사용되는 문자 집합이 다른 문자 집합의 하위 집합이고 본문에 널리 사용되는 하위 집합의 문자만 포함되어 있는 경우 해당 하위 집합에 속하는 것으로 레이블을 지정해야 합니다. 이렇게 하면 받는 사람이 메일을 올바르게 볼 수 있는 가능성이 높아집니다.

---
#### **7.1.2.     The Text/plain subtype**

텍스트의 기본 하위 유형은 "일반"입니다. 일반\(포맷되지 않은\) 텍스트를 나타냅니다. 인터넷 메일의 기본 Content-Type인 "text/plain; charset=us-ascii"는 기존 인터넷 관행을 설명합니다. 즉, RFC 822에서 정의한 본문의 유형입니다.

이 문서에서는 다른 텍스트 하위 유형을 정의하지 않습니다.

텍스트에 대한 콘텐츠 유형 헤더 필드의 공식 문법은 다음과 같습니다.

```text
   text-type := "text" "/" text-subtype [";" "charset" "=" charset]

   text-subtype := "plain" / extension-token

   charset := "us-ascii"/ "iso-8859-1"/ "iso-8859-2"/ "iso-8859-3"
          / "iso-8859-4"/ "iso-8859-5"/ "iso-8859-6"/ "iso-8859-7"
          / "iso-8859-8" / "iso-8859-9" / extension-token
                    ; case insensitive
```

---
### **7.2.  The Multipart Content-Type**

하나 이상의 서로 다른 데이터 집합이 단일 본문에 결합된 여러 부분 엔터티의 경우 "다중 부분" 콘텐츠 유형 필드가 엔터티 헤더에 나타나야 합니다. 본문은 하나 이상의 "본문 부분"을 포함해야 하며 각 부분 앞에는 캡슐화 경계가 있고 마지막 부분에는 닫는 경계가 옵니다. 각 부분은 캡슐화 경계로 시작하여 헤더 영역, 빈 줄 및 본문 영역으로 구성된 본문 부분을 포함합니다. 따라서 본문 부분은 구문에서 RFC 822 메시지와 유사하지만 의미는 다릅니다.

본문 부분은 실제로 RFC 822 메시지로 해석되지 않습니다. 우선 본문 부분에는 헤더 필드가 실제로 필요하지 않습니다. 따라서 빈 줄로 시작하는 본문 부분이 허용되며 모든 기본값이 가정되는 본문 부분입니다. 이러한 경우 Content-Type 헤더 필드가 없다는 것은 해당 본문이 일반 US-ASCII 텍스트임을 의미합니다. 본문 부분에 대해 정의된 의미가 있는 유일한 헤더 필드는 이름이 "Content-"로 시작하는 필드입니다. 다른 모든 헤더 필드는 일반적으로 본문 부분에서 무시됩니다. 일반적으로 메일 처리에 보관해야 하지만 필요한 경우 게이트웨이에서 삭제할 수 있습니다. 이러한 다른 필드는 본문 부분에 나타날 수 있지만 의존해서는 안 됩니다. "X-" 필드는 포함된 정보가 일부 게이트웨이에서 손실될 수 있다는 인식과 함께 실험적 또는 개인적인 목적으로 생성될 수 있습니다.

- 참고: RFC 822 메시지와 본문 부분의 구분은 미묘하지만 중요합니다. 예를 들어 인터넷과 X.400 메일 사이의 게이트웨이는 이미지를 포함하는 본문 부분과 이미지 본문인 캡슐화된 메시지를 포함하는 본문 부분을 구분할 수 있어야 합니다. 후자를 나타내려면 본문 부분에 "Content-Type: message"가 있어야 하며 본문\(빈 줄 뒤\)은 자체 "Content-Type: image" 헤더 필드가 있는 캡슐화된 메시지여야 합니다. 유사한 구문을 사용하면 메시지를 본문 부분으로 또는 그 반대로 쉽게 변환할 수 있지만 구현자는 둘 사이의 차이점을 이해해야 합니다. \(모든 부분이 실제로 메시지인 특수한 경우 "다이제스트" 하위 유형도 정의됩니다.\)

앞에서 설명한 것처럼 각 본문 부분 앞에는 캡슐화 경계가 있습니다. 캡슐화 경계는 캡슐화된 부분 내부에 나타나서는 안 됩니다\(MUST NOT\). 따라서 구성 에이전트가 부분을 구분할 고유한 경계를 선택하고 지정할 수 있어야 합니다.\(MUST NOT\)

"multipart" 유형의 모든 현재 및 미래 하위 유형은 동일한 구문을 사용해야 합니다. 하위 유형은 의미 체계가 다를 수 있고 구문에 추가 제한을 부과할 수 있지만 멀티파트 유형에 필요한 구문을 준수해야 합니다. 이 요구 사항은 모든 준수 사용자 에이전트가 인식되지 않는 하위 유형의 경우에도 최소한 다중 부분 엔터티의 일부를 인식하고 분리할 수 있음을 보장합니다.

Content-Transfer-Encoding 필드의 정의에 명시된 바와 같이 "multipart" 유형의 엔터티에 대해 "7bit", "8bit" 또는 "binary" 이외의 인코딩은 허용되지 않습니다. 다중 부분 구분 기호 및 헤더 필드는 어떤 경우에도 항상 7비트 ASCII로 표시되며\(헤더 필드는 \[RFC-1522\]에 따라 비ASCII 헤더 텍스트를 인코딩할 수 있음\) 본문 부분 내의 데이터는 부분에서 인코딩할 수 있습니다. -각 적절한 본문 부분에 대한 Content-Transfer-Encoding 필드가 있는 부분 기반.

```text
   Mail gateways, relays, and other mail handling agents are commonly
   known to alter the top-level header of an RFC 822 message.  In
   particular, they frequently add, remove, or reorder header fields.
   Such alterations are explicitly forbidden for the body part headers
   embedded in the bodies of messages of type "multipart."
```

---
#### **7.2.1.     Multipart:  The common syntax**

"multipart"의 모든 하위 유형은 이 섹션에 정의된 공통 구문을 공유합니다. 멀티파트 메시지의 간단한 예도 이 섹션에 나와 있습니다. 더 복잡한 멀티파트 메시지의 예는 다음과 같습니다.

부록 C에 나와 있습니다.

멀티파트 엔터티의 Content-Type 필드에는 캡슐화 경계를 지정하는 데 사용되는 "boundary" 매개 변수가 필요합니다. 캡슐화 경계는 두 개의 하이픈 문자\("-", 10진수 코드 45\)와 Content-Type 헤더 필드의 경계 매개변수 값으로 구성된 행으로 정의됩니다.

- 참고: 하이픈은 이전 RFC 934 메시지 캡슐화 방법과의 대략적인 호환성과 일부 구현에서 경계를 쉽게 검색하기 위한 것입니다. 그러나 멀티파트 메시지는 RFC 934 캡슐화와 완전히 호환되지 않는다는 점에 유의해야 합니다. 특히 하이픈으로 시작하는 포함된 줄에 대한 RFC 934 인용 규칙을 따르지 않습니다. 이 메커니즘은 RFC 934 메커니즘이 각 인용 수준에 따라 줄을 늘리기 때문에 RFC 934 메커니즘보다 선택되었습니다. 이러한 성장과 SMTP 구현이 때때로 긴 줄을 래핑한다는 사실의 결합으로 RFC 934 메커니즘은 깊게 중첩된 다중 부분 구조가 필요한 경우에 사용하기에 부적합했습니다.

구현자에 대한 경고: Content-type 필드의 매개변수에 대한 문법은 종종 Content-type 행에서 경계를 따옴표로 묶을 필요가 있습니다. 이것은 항상 필요한 것은 아니지만 결코 아프지 않습니다. 구현자는 불법 Content-type 필드 생성을 피하기 위해 문법을 주의 깊게 연구해야 합니다. 따라서 일반적인 멀티파트 Content-Type 헤더 필드는 다음과 같습니다.

```text
                 Content-Type: multipart/mixed;
                      boundary=gc0p4Jq0M2Yt08jU534c0p
```

그러나 다음은 불법입니다.

```text
                 Content-Type: multipart/mixed;
                      boundary=gc0p4Jq0M:2Yt08jU534c0p
```

\(콜론 때문에\) 대신 다음과 같이 표시되어야 합니다.

```text
                 Content-Type: multipart/mixed;
                      boundary="gc0p4Jq0M:2Yt08jU534c0p"
```

이는 엔터티가 여러 부분으로 구성되어 있으며 각 부분은 RFC 822 메시지와 구문적으로 동일한 구조를 가지고 있음을 나타냅니다. 단, 헤더 영역이 완전히 비어 있을 수 있다는 점과 각 부분 앞에 행이 있다는 점만 다릅니다.

```text
                 --gc0p4Jq0M:2Yt08jU534c0p
```

캡슐화 경계는 줄의 시작 부분, 즉 CRLF 다음에서 발생해야 하며 초기 CRLF는 이전 부분의 일부가 아니라 캡슐화 경계에 연결된 것으로 간주됩니다. 경계 바로 뒤에는 다른 CRLF와 다음 부분에 대한 헤더 필드 또는 두 개의 CRLF가 와야 합니다. 이 경우 다음 부분에 대한 헤더 필드가 없습니다\(따라서 Content-Type text/ 솔직한\).

- 참고: 캡슐화 줄 앞의 CRLF는 개념적으로 경계에 붙어 있으므로 CRLF\(줄 바꿈\)로 끝나지 않는 부분이 있을 수 있습니다. 따라서 줄 바꿈으로 끝나는 것으로 간주해야 하는 본문 부분은 캡슐화 줄 앞에 두 개의 CRLF가 있어야 합니다. 첫 번째는 이전 본문 부분의 일부이고 두 번째는 캡슐화 경계의 일부입니다.

캡슐화 경계는 캡슐화 내에 나타나서는 안 되며 70자보다 길지 않아야 하며 두 개의 선행 하이픈을 포함하지 않아야 합니다.

마지막 본문 부분 다음에 오는 캡슐화 경계는 본문 부분이 더 이상 뒤따르지 않음을 나타내는 고유한 구분 기호입니다. 이러한 구분 기호는 이전 구분 기호와 동일하며 행 끝에 두 개의 하이픈이 더 추가됩니다.

```text
                 --gc0p4Jq0M2Yt08jU534c0p--
```

첫 번째 캡슐화 경계 이전과 최종 경계 이후에 추가 정보를 위한 공간이 있는 것으로 보입니다. 이러한 영역은 일반적으로 비워 두어야 하며 구현 시 첫 번째 경계 앞이나 마지막 경계 뒤에 나타나는 모든 항목을 무시해야 합니다.

- 참고: 이러한 "서문" 및 "에필로그" 영역은 이러한 부분의 적절한 유형이 부족하고 게이트웨이, 특히 X.400 게이트웨이에서 이러한 영역을 처리하기 위한 명확한 의미 체계가 부족하기 때문에 일반적으로 사용되지 않습니다. 그러나 서문 영역을 비워두는 것보다 많은 MIME 구현에서는 pre-MIME 소프트웨어로 메시지를 읽는 수신자를 위해 설명 메모를 삽입할 수 있는 편리한 위치를 찾았습니다. 이러한 메모는 MIME 호환 소프트웨어에서 무시되기 때문입니다.

- 참고: 캡슐화 경계는 캡슐화되는 본문 부분에 나타나지 않아야 하므로 사용자 에이전트는 고유한 경계를 선택하는 데 주의를 기울여야 합니다. 위 예의 경계는 이미 존재하는 매우 낮은 확률로 경계를 생성하도록 설계된 알고리즘의 결과일 수 있습니다.

```text
      data to be encapsulated without having to prescan the data.
      Alternate algorithms might result in more 'readable' boundaries
      for a recipient with an old user agent, but would require more
      attention to the possibility that the boundary might appear in the
      encapsulated part.  The simplest boundary possible is something
      like "---", with a closing boundary of "-----".
```

매우 간단한 예로서, 다음 다중 파트 메시지에는 두 부분이 있습니다. 둘 다 일반 텍스트이고, 하나는 명시적으로 입력되고 다른 하나는 암시적으로 입력됩니다.

```text
      From: Nathaniel Borenstein <nsb@bellcore.com>
      To:  Ned Freed <ned@innosoft.com>
      Subject: Sample message
      MIME-Version: 1.0
      Content-type: multipart/mixed; boundary="simple
      boundary"
```

서문입니다. 무시해도 되지만

- 메일 작성자가 MIME을 준수하지 않는 독자에게 설명 메모를 포함할 수 있는 편리한 장소입니다. --간단한 경계

암시적으로 입력된 일반 ASCII 텍스트입니다.

- 줄 바꿈으로 끝나지 않습니다. --단순 경계 콘텐츠 유형: 텍스트/일반; charset=us-ascii

이것은 명시적으로 입력된 일반 ASCII 텍스트입니다.

- 줄 바꿈으로 끝납니다.

--간단한 경계--

- 에필로그입니다. 역시 무시해야 합니다.

다른 멀티파트 엔터티 내의 본문 부분에서 멀티파트의 Content-Type 사용이 명시적으로 허용됩니다. 이러한 경우 명백한 이유로 각 중첩된 다중 부분 엔터티가 서로 다른 경계 구분 기호를 사용하도록 주의를 기울여야 합니다. 중첩된 멀티파트 엔터티의 예는 부록 C를 참조하십시오.

단일 본문 부분만 있는 다중 부분 Content-Type의 사용은 특정 컨텍스트에서 유용할 수 있으며 명시적으로 허용됩니다.

멀티파트 Content-Type에 대한 유일한 필수 매개변수는 경계 매개변수로, 이메일 게이트웨이를 통해 매우 강력한 것으로 알려진 문자 집합에서 1\~70자로 구성되며 공백으로 끝나지 않습니다. \(경계가 공백으로 끝나는 것처럼 보이면 공백이 추가된 것으로 추정해야 합니다.

게이트웨이이며 삭제해야 합니다.\) 다음 BNF에 의해 공식적으로 지정됩니다.

```text
   boundary := 0*69<bchars> bcharsnospace

   bchars := bcharsnospace / " "

   bcharsnospace :=    DIGIT / ALPHA / "'" / "(" / ")" / "+" /"_"
                 / "," / "-" / "." / "/" / ":" / "=" / "?"
```

전반적으로 멀티파트 엔터티의 본문은 다음과 같이 지정할 수 있습니다.

```text
   multipart-body := preamble 1*encapsulation
                  close-delimiter epilogue

   encapsulation := delimiter body-part CRLF
```

구분자 := "--" 경계 CRLF ; Content-Type 필드에서 가져온 것입니다. ; 공간이 없어야 합니다. "--"와 경계 사이.

```text
   close-delimiter := "--" boundary "--" CRLF ; Again, no space
   by "--",
```

서문 := 폐기 텍스트 ; 수신 시 무시됩니다.

에필로그 := 폐기 텍스트 ; 수신 시 무시됩니다.

```text
   discard-text := *(*text CRLF)
```

body-part := <RFC 822에 정의된 "메시지",

- 모든 헤더 필드는 선택 사항이며, 지정된 구분 기호는 메시지 본문의 어느 위치에서도 발생하지 않으며, 한 줄에 단독으로 또는 하위 문자열로 어디에도 없습니다. 부분의 의미론은 텍스트에 설명된 메시지의 의미론과 다릅니다.\>

- 참고: 특정 전송 영역에서는 본문을 인쇄 가능한 ASCII 문자로 제한하는 것과 같은 RFC 822 제한이 적용되지 않을 수 있습니다. \(즉, 전송 도메인은 특정 제한 없이 RFC821에 지정되고 RFC822에서 가정하는 표준 인터넷 메일 전송과 유사할 수 있습니다.\) 이러한 제한의 완화는 예를 들어 외부 옥텟을 포함하도록 본문의 정의를 로컬로 확장하는 것으로 해석되어야 합니다. 이러한 확장이 전송에 의해 지원되고 적절하게 문서화되어 있는 한 ASCII 범위의

- Content-Transfer-Encoding 헤더 필드. 그러나 어떤 경우에도 헤더\(메시지 헤더 또는 본문 부분 헤더\)는 ASCII 문자 이외의 것을 포함할 수 없습니다.

- 참고: 멀티파트 유형에서 눈에 띄게 누락된 것은 구조화된 관련 신체 부분의 개념입니다. 일반적으로 아직 인터파트 구조를 표준화하려는 시도는 시기상조인 것 같습니다. 보다 구조화되거나 통합된 멀티파트 메시징 기능을 제공하려는 사용자는 구문적으로 동일하지만 항상 다른 부분의 구조 및 통합을 지정하는 데 사용할 수 있는 구별된 부분을 포함할 것으로 기대하는 멀티파트의 하위 유형을 정의해야 합니다. Content-ID 필드로 참조할 수 있습니다. 이 접근 방식을 사용하면 다른 구현에서 새 하위 유형을 인식하지 못하지만 이를 기본 하위 유형\(multipart/mixed\)으로 취급하므로 인식된 부분을 사용자에게 보여줄 수 있습니다.

---
#### **7.2.2.     The Multipart/mixed (primary) subtype**

multipart의 기본 하위 유형인 "mixed"는 본문 부분이 독립적이고 특정 순서로 묶일 필요가 있을 때 사용하기 위한 것입니다. 구현이 인식하지 못하는 다중 부분 하위 유형은 "혼합" 하위 유형으로 처리되어야 합니다.

---
#### **7.2.3.     The Multipart/alternative subtype**

multipart/alternative 유형은 multipart/mixed와 구문적으로 동일하지만 의미 체계는 다릅니다. 특히 각 부분은 동일한 정보의 "대체" 버전입니다.

시스템은 다양한 부분의 내용이 상호 교환 가능하다는 것을 인식해야 합니다. 시스템은 경우에 따라 사용자 상호 작용을 통해서도 로컬 환경 및 기본 설정을 기반으로 "최상의" 유형을 선택해야 합니다. multipart/mixed와 마찬가지로 본문 부분의 순서가 중요합니다. 이 경우 원본 콘텐츠에 대한 충실도가 높아지는 순서로 대안이 나타납니다. 일반적으로 최상의 선택은 수신 시스템의 로컬 환경에서 지원하는 형식의 마지막 부분입니다.

Multipart/alternative는 예를 들어 어디에서나 쉽게 표시할 수 있는 멋진 텍스트 형식으로 메일을 보내는 데 사용할 수 있습니다.

```text
   From:  Nathaniel Borenstein <nsb@bellcore.com>
   To: Ned Freed <ned@innosoft.com>
   Subject: Formatted text mail
   MIME-Version: 1.0
   Content-Type: multipart/alternative; boundary=boundary42

   --boundary42

   Content-Type: text/plain; charset=us-ascii
```

- ...메시지의 일반 텍스트 버전이 여기에 옵니다.... --boundary42 Content-Type: text/richtext

- .... 같은 메시지의 RFC 1341 서식 있는 텍스트 버전이 여기에 있습니다 ... --boundary42 Content-Type: text/x-whatever

```text
      .... fanciest formatted version of same  message  goes  here
      ...
   --boundary42--
```

이 예에서 메일 시스템이 "text/x-what" 형식을 이해하는 사용자는 고급 버전만 볼 수 있는 반면 다른 사용자는 시스템 기능에 따라 서식 있는 텍스트 또는 일반 텍스트 버전만 볼 수 있습니다.

일반적으로 다중 부분/대체 엔터티를 구성하는 사용자 에이전트는 본문 부분을 선호도가 높은 순서로, 즉 선호하는 형식이 마지막에 배치해야 합니다. 멋진 텍스트의 경우 보내는 사용자 에이전트는 가장 평범한 형식을 먼저 넣고 가장 풍부한 형식을 마지막에 두어야 합니다. 수신 사용자 에이전트는 표시할 수 있는 마지막 형식을 선택하여 표시해야 합니다. 대안 중 하나가 "multipart" 유형이고 인식할 수 없는 하위 부분을 포함하는 경우 사용자 에이전트는 해당 대안, 이전 대안 또는 둘 다를 표시하도록 선택할 수 있습니다.

- 참고: 구현자의 관점에서 볼 때 이 순서를 반대로 하고 가장 평범한 대안을 마지막에 두는 것이 더 합리적으로 보일 수 있습니다. 그러나 MIME을 준수하지 않는 메일 판독기를 사용하여 다중 부분/대체 엔터티를 볼 때 가장 평범한 대안을 먼저 배치하는 것이 가장 친숙한 옵션입니다. 이 접근 방식은 준수 메일 판독기에 약간의 부담을 주지만, 이 경우에는 이전 메일 판독기와의 상호 운용성이 더 중요하다고 간주되었습니다.

일부 사용자 에이전트가 둘 이상의 형식을 인식할 수 있는 경우 사용자에게 선택권을 제공하는 것을 선호할 수 있습니다.

어떤 형식을 볼 수 있습니다. 예를 들어 메일에 멋진 형식의 이미지 버전과 쉽게 편집할 수 있는 텍스트 버전이 모두 포함되어 있는 경우 이는 의미가 있습니다. 그러나 가장 중요한 것은 사용자에게 동일한 데이터의 여러 버전이 자동으로 표시되지 않는다는 것입니다. 사용자에게 마지막으로 인식된 버전이 표시되거나 선택이 제공되어야 합니다.

MULTIPART/ALTERNATIVE에서 CONTENT-ID의 의미에 대한 참고 사항: multipart/alternative 엔터티의 각 부분은 동일한 데이터를 나타내지만 둘 사이의 매핑에서 반드시 정보 손실이 없는 것은 아닙니다. 예를 들어 ODA를 PostScript나 일반 텍스트로 번역할 때 정보가 손실됩니다. 두 부분의 정보 내용이 동일하지 않은 경우 각 부분의 Content-ID 값이 다른 것을 권장한다. 그러나 정보 내용이 동일한 경우\(예: "application/external-body" 유형의 여러 부분이 동일한 데이터에 액세스하는 대체 방법을 지정하는 경우\) 동일한 Content-ID 필드 값을 사용하여 캐싱을 최적화해야 합니다. 수신자 측에 존재할 수 있는 메커니즘. 그러나 그러한 Content-ID 필드가 있는 경우 부분에서 사용하는 Content-ID 값은 multipart/alternative를 전체적으로 설명하는 Content-ID 값과 동일하지 않아야 합니다. 즉, 하나의 Content-ID 값은 multipart/alternative 엔터티를 참조하고 하나 이상의 다른 Content-ID 값은 그 내부의 부분을 참조합니다.

---
#### **7.2.4.     The Multipart/digest subtype**

이 문서는 멀티파트 콘텐츠 유형의 "다이제스트" 하위 유형을 정의합니다. 이 유형은 multipart/mixed와 구문적으로 동일하지만 의미 체계는 다릅니다. 특히 다이제스트에서 본문 부분에 대한 기본 Content-Type 값은 "text/plain"에서 "message/rfc822"로 변경됩니다. 이는 RFC 934와 대부분 호환되는\(인용 규칙 제외\) 더 읽기 쉬운 다이제스트 형식을 허용하기 위해 수행됩니다.

이 형식의 다이제스트는 다음과 같을 수 있습니다.

```text
   From: Moderator-Address
   To: Recipient-List
   MIME-Version: 1.0
   Subject:  Internet Digest, volume 42
   Content-Type: multipart/digest;
        boundary="---- next message ----"

   ------ next message ----

   From: someone-else
   Subject: my opinion

      ...body goes here ...

   ------ next message ----

   From: someone-else-again
   Subject: my different opinion

      ... another body goes here...

   ------ next message ------
```

---
#### **7.2.5.     The Multipart/parallel subtype**

이 문서는 멀티파트 콘텐츠 유형의 "병렬" 하위 유형을 정의합니다. 이 유형은 multipart/mixed와 구문적으로 동일하지만 의미 체계는 다릅니다. 특히 병렬 개체에서는 신체 부위의 순서가 중요하지 않습니다.

이러한 유형의 일반적인 프레젠테이션은 그렇게 할 수 있는 하드웨어 및 소프트웨어에서 모든 부품을 동시에 표시하는 것입니다. 그러나 구성 에이전트는 많은 메일 판독기에서 이 기능이 부족하고 어떤 경우에도 부품을 연속적으로 표시한다는 점을 알고 있어야 합니다.

---
#### **7.2.6.     Other Multipart subtypes**

다른 멀티파트 하위 유형은 향후 예상됩니다. MIME 구현은 일반적으로 multipart의 인식되지 않는 하위 유형을 "multipart/mixed"와 동일하게 취급해야 합니다.

멀티파트 데이터에 대한 콘텐츠 유형 헤더 필드의 공식 문법은 다음과 같습니다.

```text
   multipart-type := "multipart" "/" multipart-subtype
                  ";" "boundary" "=" boundary

   multipart-subtype := "mixed" / "parallel" / "digest"
                  / "alternative" / extension-token
```

---
### **7.3.  The Message Content-Type**

메일을 보낼 때 다른 메일 메시지를 캡슐화하는 것이 바람직한 경우가 많습니다. 이 공통 작업을 위해 특별한 Content-Type인 "message"가 정의됩니다. 기본 하위 유형인 message/rfc822에는 Content-Type 필드에 필수 매개변수가 없습니다. 추가 하위 유형인 "partial" 및 "External-body"에는 필수 매개변수가 있습니다. 이러한 하위 유형은 아래에 설명되어 있습니다.

- 참고: 메시지의 하위 유형이 전달되거나 거부된 메시지에 대해 정의될 수 있음이 제안되었습니다. 그러나 전달 및 거부된 메시지는 첫 번째 부분이 제어 또는 설명 정보를 포함하고 메시지/rfc822 유형의 두 번째 부분이 전달되거나 거부된 메시지인 다중 부분 메시지로 처리될 수 있습니다. 이러한 방식으로 거부 및 전달 메시지를 작성하면 원본 메시지의 유형 정보가 보존되고 수신자에게 올바르게 표시될 수 있으므로 적극 권장됩니다.

Content-Transfer-Encoding 필드의 정의에 명시된 바와 같이 "7bit", "8bit" 또는 "binary" 이외의 인코딩은 메시지 또는 "message" 유형의 일부에 대해 허용되지 않습니다. 아래에 지정된 대로 "메시지/부분" 및 "메시지/외부 본문" 하위 유형에는 더 강력한 제한이 적용됩니다. 메시지 헤더 필드는 어떤 경우에도 항상 US-ASCII이며 본문 내의 데이터는 여전히 인코딩될 수 있습니다. 이 경우 캡슐화된 메시지의 Content-Transfer-Encoding 헤더 필드는 이를 반영합니다. 캡슐화된 메시지 헤더의 비ASCII 텍스트는 \[RFC-1522\]에 설명된 메커니즘을 사용하여 지정할 수 있습니다.

```text
   Mail gateways, relays, and other mail handling agents are commonly
   known to alter the top-level header of an RFC 822 message.  In
   particular, they frequently add, remove, or reorder header fields.
   Such alterations are explicitly forbidden for the encapsulated
   headers embedded in the bodies of messages of type "message."
```

---
#### **7.3.1.     The Message/rfc822 (primary) subtype**

Content-Type "message/rfc822"는 본문에 RFC 822 메시지 구문을 사용하여 캡슐화된 메시지가 포함되어 있음을 나타냅니다. 그러나 최상위 RFC 822 메시지와 달리 각 메시지/rfc822 본문에는 "From", "Subject" 및 적어도 하나의 대상 헤더가 포함되어야 하는 것은 아닙니다.

숫자 "822"를 사용했음에도 불구하고

message/rfc822 엔터티는 이 문서에 정의된 대로 향상된 정보를 포함할 수 있습니다. 즉, message/rfc822 메시지는 MIME 메시지일 수 있다.

---
#### **7.3.2.     The Message/Partial subtype**

메시지의 하위 유형인 "partial"은 큰 개체가 메일의 여러 개별 조각으로 전달되고 수신 사용자 에이전트에 의해 자동으로 재구성되도록 하기 위해 정의됩니다. \(이 개념은 기본 인터넷 프로토콜의 IP 조각화/재조립과 유사합니다.\) 이 메커니즘은 중간 전송 에이전트가 보낼 수 있는 개별 메시지의 크기를 제한할 때 사용할 수 있습니다. 따라서 Content-Type "message/partial"은 본문에 더 큰 메시지의 일부가 포함되어 있음을 나타냅니다.

message/partial 유형의 Content-Type 필드에 세 가지 매개변수를 지정해야 합니다. 첫 번째 "id"는 부품을 함께 일치시키는 데 사용되는 가능한 한 세계 고유 식별자에 가까운 고유 식별자입니다. \(일반적으로 식별자는 기본적으로 message-id입니다. 큰따옴표로 묶인 경우 이 사양의 앞부분에 제공된 "매개변수"에 대한 BNF에 따라 임의의 message-id가 될 수 있습니다.\) 두 번째 "숫자", 정수는 이 부품이 조각 시퀀스에 맞는 위치를 나타내는 부품 번호입니다. 또 다른 정수인 세 번째 "total"은 전체 부품 수입니다. 이 세 번째 하위 필드는 마지막 부분에서 필수이며 이전 부분에서는 선택 사항입니다\(권장됨\). 또한 이러한 매개변수는 임의의 순서로 제공될 수 있습니다.

따라서 세 부분으로 구성된 메시지의 부분 2에는 다음 헤더 필드 중 하나가 있을 수 있습니다.

```text
                Content-Type: Message/Partial;
                     number=2; total=3;
                     id="oc=jpbe0M2Yt4s@thumper.bellcore.com"

                Content-Type: Message/Partial;
                     id="oc=jpbe0M2Yt4s@thumper.bellcore.com";
                     number=2
```

그러나 파트 3은 총 파트 수를 지정해야 합니다.\(MUST\)

```text
                Content-Type: Message/Partial;
                     number=3; total=3;
                     id="oc=jpbe0M2Yt4s@thumper.bellcore.com"
```

부품 번호는 0이 아닌 1부터 시작합니다.

이렇게 쪼개진 메시지의 일부를 넣을 때

함께 결과는 자체 Content-Type 헤더 필드를 가질 수 있는 완전한 MIME 엔티티이며 따라서 다른 데이터 유형을 포함할 수 있습니다.

메시지 조각화 및 재조립: 재조립된 부분 메시지의 의미는 내부 메시지를 포함하는 메시지가 아니라 "내부" 메시지의 의미 체계여야 합니다. 예를 들어 큰 오디오 메시지를 여러 개의 부분 메시지로 보낼 수 있으며 수신자에게는 오디오 메시지가 포함된 캡슐화된 메시지가 아닌 단순한 오디오 메시지로 표시됩니다. 즉, 메시지의 캡슐화는 "투명"한 것으로 간주됩니다.

메시지/부분 메시지의 일부를 생성 및 재조립할 때 캡슐화된 메시지의 헤더는 엔클로징 엔터티의 헤더와 병합되어야 합니다. 이 과정에서 다음 규칙을 준수해야 합니다.

- \(1\) "Content-"로 시작하는 헤더 필드와 특정 헤더 필드 "Message-ID", "Encrypted" 및 "MIME-Version"을 제외한 초기 엔클로징 엔터티\(1부\)의 모든 헤더 필드, 새 메시지에 순서대로 복사해야 합니다.

- \(2\) "Content-" 및 "Message-ID", "Encrypted" 및 "MIME-Version"으로 시작하는 동봉된 메시지의 헤더 필드만 순서대로 새 메시지의 헤더 필드에 추가되어야 합니다. 메시지. 포함된 메시지에서 "Content-"로 시작하지 않는 모든 헤더 필드\("Message-ID", "Encrypted" 및 "MIME-Version" 제외\)는 무시됩니다.

- \(3\) 두 번째 및 후속 메시지의 모든 헤더 필드는 무시됩니다.

예를 들어 오디오 메시지가 두 부분으로 나뉘는 경우 첫 번째 부분은 다음과 같을 수 있습니다.

```text
      X-Weird-Header-1: Foo
      From: Bill@host.com
      To: joe@otherhost.com
      Subject: Audio mail
      Message-ID: <id1@host.com>
      MIME-Version: 1.0
      Content-type: message/partial;
           id="ABC@host.com";
           number=1; total=2

      X-Weird-Header-1: Bar
      X-Weird-Header-2: Hello

      Message-ID: <anotherid@foo.com>
      MIME-Version: 1.0
      Content-type: audio/basic
      Content-transfer-encoding: base64

         ... first half of encoded audio data goes here...
```

후반부는 다음과 같을 수 있습니다.

```text
      From: Bill@host.com
      To: joe@otherhost.com
      Subject: Audio mail
      MIME-Version: 1.0
      Message-ID: <id2@host.com>
      Content-type: message/partial;
           id="ABC@host.com"; number=2; total=2

         ... second half of encoded audio data goes here...
```

그런 다음 조각난 메시지가 다시 어셈블되면 사용자에게 표시되는 결과 메시지는 다음과 같아야 합니다.

```text
      X-Weird-Header-1: Foo
      From: Bill@host.com
      To: joe@otherhost.com
      Subject: Audio mail
      Message-ID: <anotherid@foo.com>
      MIME-Version: 1.0
      Content-type: audio/basic
      Content-transfer-encoding: base64

         ... first half of encoded audio data goes here...
         ... second half of encoded audio data goes here...

   Note on encoding of MIME entities encapsulated inside message/partial
   entities: Because data of type "message" may never be encoded in
   base64 or quoted-printable, a problem might arise if message/partial
   entities are constructed in an environment that supports binary or
   8-bit transport.  The problem is that the binary data would be split
   into multiple message/partial objects, each of them requiring binary
   transport.  If such objects were encountered at a gateway into a 7-
   bit transport environment, there would be no way to properly encode
   them for the 7-bit world, aside from waiting for all of the parts,
   reassembling the message, and then encoding the reassembled data in
   base64 or quoted-printable.  Since it is possible that different
   parts might go through different gateways, even this is not an
   acceptable solution.  For this reason, it is specified that MIME
   entities of type message/partial must always have a content-
```

7비트의 전송 인코딩\(기본값\). 특히, 바이너리 또는 8비트 전송을 지원하는 환경에서도 "8비트" 또는 "바이너리"의 콘텐츠 전송 인코딩 사용은 메시지/부분 유형의 엔터티에 대해 명시적으로 금지됩니다.

일부 메시지 전송 에이전트는 큰 메시지를 자동으로 조각화하도록 선택할 수 있고 이러한 에이전트는 다른 조각화 임계값을 사용할 수 있기 때문에 재조립 시 부분 메시지 조각이 부분 메시지를 구성하는 것으로 입증될 수 있습니다. 메시지. 이는 명시적으로 허용됩니다.

또한 이전 부분의 Message-Id를 참조하는 단편화된 메시지의 두 번째 및 후속 부분의 헤더에 "참조" 필드를 포함하면 참조를 이해하고 추적하는 메일 판독기에 도움이 될 수 있습니다. 그러나 이러한 "참조" 필드의 생성은 전적으로 선택 사항입니다.

마지막으로, "Encrypted" 헤더 필드는 PEM\(Privacy Enhanced Messaging\)에 의해 더 이상 사용되지 않지만 위의 규칙은 이를 처리하는 올바른 방법을 설명하는 것으로 믿어집니다. 메시지/부분 조각에서.

---
#### **7.3.3.     The Message/External-Body subtype**

external-body 하위 유형은 실제 신체 데이터가 포함되지 않고 단지 참조됨을 나타냅니다. 이 경우 매개변수는 외부 데이터에 액세스하기 위한 메커니즘을 설명합니다.

엔터티가 "message/external-body" 유형인 경우 헤더, 두 개의 연속된 CRLF 및 캡슐화된 메시지의 메시지 헤더로 구성됩니다. 다른 연속 CRLF 쌍이 나타나면 당연히 캡슐화된 메시지의 메시지 헤더가 끝납니다. 그러나 캡슐화된 메시지 본문 자체가 외부에 있으므로 다음 영역에 나타나지 않습니다. 예를 들어 다음 메시지를 고려하십시오.

```text
      Content-type: message/external-body; access-
      type=local-file;

           name="/u/nsb/Me.gif"

      Content-type:  image/gif
      Content-ID: <id42@guppylake.bellcore.com>
      Content-Transfer-Encoding: binary

      THIS IS NOT REALLY THE BODY!
```

"팬텀 본문"이라고 할 수 있는 끝에 있는 영역은 대부분의 외부 본문 메시지에서 무시됩니다. 그러나 액세스 유형이 "메일 서버"인 경우와 같이 일부 메시지에 대한 보조 정보를 포함하는 데 사용할 수 있습니다. 이 문서에서 정의한 액세스 유형 중 팬텀 본문은 액세스 유형이 "mail-server"인 경우에만 사용됩니다. 다른 모든 경우에는 팬텀 본체가 무시됩니다.

message/external-body에 대한 유일한 항상 필수 매개변수는 "access-type"입니다. 다른 모든 매개변수는 access-type 값에 따라 필수 또는 선택 사항일 수 있습니다.

```text
      ACCESS-TYPE -- A case-insensitive word, indicating the supported
      access mechanism by which the file or data may be obtained.
      Values include, but are not limited to, "FTP", "ANON-FTP", "TFTP",
      "AFS", "LOCAL-FILE", and "MAIL-SERVER".  Future values, except for
      experimental values beginning with "X-" must be registered with
      IANA, as described in Appendix E .
```

또한 다음 세 매개변수는 모든 액세스 유형에 대해 선택 사항입니다.

- EXPIRATION -- 외부 데이터의 존재가 보장되지 않는 날짜\(연도 필드에 4자리를 허용하기 위해 RFC 1123에 의해 확장된 RFC 822 "날짜-시간" 구문\).

- SIZE -- 데이터의 크기\(옥텟 단위\). 이 매개변수의 목적은 수신자가 외부 데이터를 검색하는 데 필요한 리소스를 소비할지 여부를 결정하는 데 도움을 주기 위한 것입니다. 이는 표준 형식, 즉 Content-Transfer-Encoding이 적용되기 전 또는 데이터가 디코딩된 후의 데이터 크기를 설명합니다.

- PERMISSION -- 클라이언트가 데이터를 덮어쓸 수도 있는지 여부를 나타내는 대소문자를 구분하지 않는 필드입니다. 기본적으로 또는 권한이 "읽기"인 경우에는 그렇지 않으며 데이터가 한 번 검색되면 다시는 필요하지 않다고 가정합니다. PERMISSION이 "읽기-쓰기"인 경우 이 가정은 유효하지 않으며 모든 로컬 복사본은 캐시 이상으로 간주되지 않아야 합니다. "읽기" 및 "읽기-쓰기"는 유일하게 정의된 권한 값입니다.

여기에 정의된 액세스 유형의 정확한 의미 체계는 다음 섹션에서 설명합니다.

모든 메시지/외부 본문 엔터티의 캡슐화된 헤더는 다음을 통해 고유한 식별자를 제공하는 Content-ID 헤더 필드를 포함해야 합니다.\(MUST\)

데이터를 참조하는 것입니다. 이 식별자는 캐시 메커니즘과 액세스 유형이 "메일 서버"일 때 데이터 수신을 인식하는 데 사용될 수 있습니다.

여기에 지정된 대로 파일 이름 및 메일 서버 명령과 같은 외부 본문 데이터를 설명하는 토큰은 US-ASCII 문자 세트에 있어야 합니다. 이것이 실제로 문제가 있는 것으로 판명되면 메시지/외부 본문에 대해 새로 정의된 액세스 유형 또는 일부 다른 메커니즘에 의해 MIME에 대한 향후 확장으로 새로운 메커니즘이 필요할 수 있습니다.

message/partial과 마찬가지로 message/external-body 유형의 MIME 엔터티에는 항상 7비트\(기본값\)의 콘텐츠 전송 인코딩이 있어야 합니다. 특히 바이너리 또는 8비트 전송을 지원하는 환경에서도 메시지/외부 본문 유형의 엔터티에 대해 "8비트" 또는 "바이너리"의 콘텐츠 전송 인코딩을 사용하는 것은 명시적으로 금지됩니다.

---
##### **7.3.3.1.  The "ftp" and "tftp" access-types**

FTP 또는 TFTP의 액세스 유형은 각각 FTP\[RFC-959\] 또는 TFTP\[RFC-783\] 프로토콜을 사용하여 메시지 본문에 파일로 액세스할 수 있음을 나타냅니다. 이러한 액세스 유형의 경우 다음 추가 매개변수가 필수입니다.

- NAME -- 실제 본문 데이터가 포함된 파일의 이름입니다.

- SITE -- 지정된 프로토콜을 사용하여 파일을 얻을 수 있는 시스템입니다. 닉네임이 아닌 정규화된 도메인 이름이어야 합니다.

FTP를 사용하여 데이터를 검색하기 전에 사용자는 일반적으로 사이트 매개변수로 명명된 시스템의 로그인 ID와 암호를 제공해야 합니다. 보안상의 이유로 이러한 ID와 암호는 콘텐츠 유형 매개 변수로 지정되지 않고 사용자로부터 얻어야 합니다.

또한 다음 매개변수는 선택 사항입니다.

- DIRECTORY -- NAME으로 명명된 데이터를 검색해야 하는 디렉토리입니다.

- MODE -- 정보를 검색할 때 사용할 모드를 나타내는 대소문자를 구분하지 않는 문자열입니다. 액세스 유형 "TFTP"의 유효한 값은 TFTP 프로토콜\[RFC-783\]에 지정된 대로 "NETASCII", "OCTET" 및 "MAIL"입니다. 액세스 유형 "FTP"에 대한 유효한 값은 "ASCII", "EBCDIC", "IMAGE" 및 "LOCALn"이며 여기서 "n"은 10진수 정수\(일반적으로 8\)입니다.

- FTP 프로토콜 \[RFC-959\]에 의해 지정된 표현 유형 "A" "E" "I" 및 "L n". "BINARY" 및 "TENEX"는 MODE에 유효한 값이 아니지만 대신 "OCTET" 또는 "IMAGE" 또는 "LOCAL8"을 사용해야 합니다. MODE가 지정되지 않은 경우 기본값은 TFTP의 경우 "NETASCII"이고 그렇지 않은 경우 "ASCII"입니다.

---
##### **7.3.3.2.  The "anon-ftp" access-type**

"anon-ftp" 액세스 유형은 "ftp" 액세스 유형과 동일하지만 사용자에게 지정된 사이트에 대한 이름과 암호를 제공하도록 요청하지 않아도 됩니다. 대신 "익명" 로그인 및 사용자의 이메일 주소에 해당하는 암호와 함께 ftp 프로토콜이 사용됩니다.

---
##### **7.3.3.3.  The "local-file" and "afs" access-types**

"로컬 파일"의 액세스 유형은 실제 본문이 로컬 시스템의 파일로 액세스 가능함을 나타냅니다. 액세스 유형 "afs"는 전역 AFS 파일 시스템을 통해 파일에 액세스할 수 있음을 나타냅니다. 두 경우 모두 단일 매개변수만 필요합니다.

- NAME -- 실제 본문 데이터가 포함된 파일의 이름입니다.

다음 선택적 매개변수를 사용하여 데이터 참조 지역, 즉 파일이 표시될 것으로 예상되는 사이트를 설명할 수 있습니다.

- SITE -- 데이터 파일에 액세스할 수 있는 것으로 알려진 시스템 또는 시스템 집합에 대한 도메인 지정자입니다. "\*.bellcore.com"과 같은 도메인 이름의 일부에 대한 와일드카드 일치에 별표를 사용하여 데이터를 직접 볼 수 있는 시스템 집합을 나타낼 수 있습니다. 예를 들어 전역 파일 시스템을 통해 보편적으로 사용할 수 있을 것으로 예상되는 파일입니다.

---
##### **7.3.3.4.  The "mail-server" access-type**

"메일 서버" 액세스 유형은 메일 서버에서 실제 본문을 사용할 수 있음을 나타냅니다. 이 액세스 유형에 대한 필수 매개변수는 다음과 같습니다.

- SERVER -- 실제 본문 데이터를 얻을 수 있는 메일 서버의 이메일 주소.

메일 서버는 다양한 구문을 허용하며 그 중 일부는 여러 줄이므로 메일 서버로 보낼 전체 명령은 content-type 줄의 매개 변수로 포함되지 않습니다. 대신 content-type이 다음과 같은 경우 "팬텀 본문"으로 제공됩니다.

message/external-body이고 액세스 유형은 메일 서버입니다.

이 액세스 유형에 대한 선택적 매개변수는 다음과 같습니다.

- SUBJECT -- 데이터를 얻기 위해 보내는 메일에 사용할 제목입니다. 제목 줄에 메일 서버를 입력하는 것은 권장되지 않지만 이러한 메일 서버는 존재하는 것으로 알려져 있습니다.

MIME은 메일 서버 구문을 정의하지 않습니다. 오히려 팬텀 본문에 임의의 메일 서버 명령을 포함할 수 있습니다. 구현은 관련 데이터를 검색하기 위해 메일 서버 주소로 보내는 메시지 본문에 가상 본문을 포함해야 합니다.

다른 액세스 유형과 달리 메일 서버 액세스는 비동기식이며 미래에 예측할 수 없는 시간에 발생한다는 점은 주목할 가치가 있습니다. 이러한 이유로 반환된 데이터를 원본 메시지/외부 본문 엔터티와 일치시킬 수 있는 메커니즘이 있다는 것이 중요합니다. MIME 메일 서버는 이러한 일치를 용이하게 하기 위해 원래 메시지/외부 본문 엔터티에서 사용된 반환된 메시지에서 동일한 Content-ID 필드를 사용해야 합니다.

---
##### **7.3.3.5.  Examples and Further Explanations**

광역 파일 시스템의 새로운 가능성으로 인해 파일 시스템에서 직접 파일에 액세스할 수 있는 시스템 집합을 미리 아는 것이 매우 어려워집니다. 따라서 직접 시도할 파일 이름과 파일에 액세스할 수 있는 것으로 알려진 하나 이상의 사이트 이름을 모두 제공하는 것이 좋습니다. 구현은 익명 파일 검색을 사용하거나 사용자에게 필요한 이름과 암호를 묻는 프롬프트를 사용하여 FTP 또는 기타 프로토콜을 사용하여 원격 파일 검색을 시도할 수 있습니다. 여러 메커니즘을 통해 외부 본문에 액세스할 수 있는 경우 발신자는 multipart/alternative 유형의 엔터티 내에 message/external-body 유형의 여러 부분을 포함할 수 있습니다.

그러나 외부 본문 메커니즘은 메일 서버 액세스 유형에서 볼 수 있듯이 파일 검색으로 제한되지 않습니다. 이 외에도 예를 들어 비디오 클립에 대한 외부 참조를 위해 비디오 서버를 사용하는 것을 상상할 수 있습니다.

엔터티가 "message/external-body" 유형인 경우 엔터티 본문에는 캡슐화된 메시지의 헤더 필드가 포함됩니다. 본체 자체는 외부 위치에서 찾을 수 있습니다. 즉, "message/external-body" 메시지의 본문에 두 개의 연속된 CRLF가 포함된 경우 해당 쌍 이후의 모든 내용은 메시지 자체의 일부가 아닙니다. 대부분의 메시지/외부 본문 메시지의 경우 이 후행 영역은 무시해야 합니다. 그러나 편리한

콘텐츠 유형 헤더 필드에 포함될 수 없는 추가 데이터를 위한 장소입니다. 특히 "access-type" 값이 "mail-server"인 경우 후행 영역에는 SERVER 매개변수 값으로 지정된 주소의 메일 서버로 보낼 명령이 포함되어야 합니다.

메시지/외부 본문 데이터의 본문에 나타나는 내장된 메시지 헤더 필드는 외부 본문에 헤더가 없기 때문에 일반 ASCII 텍스트가 아닌 경우 외부 본문의 Content-type을 선언하는 데 사용해야 합니다. 유형을 선언하는 섹션입니다. 마찬가지로 "7bit" 이외의 Content-transfer-encoding도 여기에서 선언해야 합니다. 따라서 PostScript 형식의 문서를 참조하는 완전한 메시지/외부 본문 메시지는 다음과 같습니다.

발신인: 누구든지

- 받는 사람: 누군가 제목: 모든 MIME 버전: 1.0 메시지 ID: <id1@host.com\> 콘텐츠 유형: multipart/alternative; 경계=42 콘텐츠 ID: <id001@guppylake.bellcore.com\>

```text
      --42
      Content-Type: message/external-body;
           name="BodyFormats.ps";
           site="thumper.bellcore.com";
           access-type=ANON-FTP;
           directory="pub";
           mode="image";
           expiration="Fri, 14 Jun 1991 19:13:14 -0400 (EDT)"

      Content-type: application/postscript
      Content-ID: <id42@guppylake.bellcore.com>

      --42
      Content-Type: message/external-body;
           name="/u/nsb/writing/rfcs/RFC-MIME.ps";
           site="thumper.bellcore.com";
           access-type=AFS
           expiration="Fri, 14 Jun 1991 19:13:14 -0400 (EDT)"

      Content-type: application/postscript
      Content-ID: <id42@guppylake.bellcore.com>

      --42
      Content-Type: message/external-body;
           access-type=mail-server

           server="listserv@bogus.bitnet";
           expiration="Fri, 14 Jun 1991 19:13:14 -0400 (EDT)"

      Content-type: application/postscript
      Content-ID: <id42@guppylake.bellcore.com>

      get RFC-MIME.DOC

      --42--
```

위의 예에서 "7비트"의 기본 Content-transfer-encoding은 외부 포스트스크립트 데이터에 대해 가정합니다.

message/partial type과 마찬가지로 message/external-body type은 투명하도록 의도되었습니다. 즉, 해당 유형의 본문으로 메시지를 전달하기보다는 외부 본문에 데이터 유형을 전달하기 위한 것입니다. 따라서 외부 및 내부 부분의 헤더는 메시지/부분과 동일한 규칙을 사용하여 병합되어야 합니다. 특히 이는 Content-type 헤더가 재정의되지만 From 및 Subject 헤더는 보존됨을 의미합니다.

외부 본문은 메일로 전송되지 않으므로 7비트 및 줄 길이 요구 사항을 준수할 필요는 없지만 실제로는 이진 파일일 수 있습니다. 따라서 Content-Transfer-Encoding은 허용되지만 일반적으로 필요하지 않습니다.

"message/external-body" 유형의 메시지 본문은 RFC 822 메시지의 기본 구문에 의해 관리됩니다. 특히 CRLF의 첫 번째 연속 쌍 이전의 모든 것은 헤더 정보이고 그 이후의 모든 것은 대부분의 액세스 유형에서 무시되는 본문 정보입니다.

메시지 유형의 데이터에 대한 컨텐츠 유형 헤더 필드의 공식 문법은 다음과 같습니다.

```text
   message-type := "message" "/" message-subtype

   message-subtype := "rfc822"
                   / "partial" 2#3partial-param
                   / "external-body" 1*external-param
                   / extension-token
```

부분 매개변수 := \(";" "id" "="값\)

- / \(";" "숫자" "=" 1\*DIGIT\) / \(";" "합계" "=" 1\*DIGIT\) ; ID 및 번호가 필요합니다. 마지막 부분에 필요한 합계

```text
   external-param :=   (";" "access-type" "=" atype)
```

/ \(";" "만료" "="날짜-시간\)

- ; 날짜-시간은 인용 부호로 표시됩니다. / \(";" "size" "=" 1\*DIGIT\) / \(";" "permission" "=" \("read" / "read-write"\)\) ; 권한은 대소문자를 구분하지 않습니다. / \(";" "이름" "="값\) / \(";" "사이트" "="값\) / \(";" "dir" "="값\) / \(";" " 모드" "="값\) / \(";" "서버" "="값\) / \(";" "제목" "="값\) ; 액세스 유형 필수;액세스 유형에 따라 필요한 기타 항목

```text
   atype := "ftp" / "anon-ftp" / "tftp" / "local-file"
                  / "afs" / "mail-server" / extension-token
                  ; Case-insensitive
```

---
### **7.4.  The Application Content-Type**

"응용 프로그램" Content-Type은 다른 범주에 맞지 않는 데이터, 특히 응용 프로그램의 메일 기반 사용에 의해 처리되는 데이터에 사용됩니다. 이것은 사용자가 보거나 사용할 수 있기 전에 애플리케이션에서 처리해야 하는 정보입니다. Content-Type 애플리케이션의 예상 용도에는 메일 기반 파일 전송, 스프레드시트, 메일 기반 스케줄링 시스템용 데이터 및 "활성"\(전산\) 이메일용 언어가 포함됩니다. \(특히 후자는 구현자가 이해해야 하는 보안 문제를 제기할 수 있으며 응용 프로그램/PostScript 콘텐츠 유형에 대한 논의에서 자세히 고려됩니다.\)

예를 들어, 회의 스케줄러는 제안된 회의 날짜에 대한 정보에 대한 표준 표현을 정의할 수 있습니다. 지능형 사용자 에이전트는 이 정보를 사용하여 사용자와 대화를 수행한 다음 해당 대화를 기반으로 추가 메일을 보낼 수 있습니다. 보다 일반적으로, 적절하게 전문화된 언어로 된 프로그램이 메일을 통해 전송되고 수신자의 환경에서 자동으로 실행되는 여러 "활성" 메시징 언어가 개발되었습니다.

이러한 애플리케이션은 "애플리케이션" 콘텐츠 유형의 하위 유형으로 정의될 수 있습니다. 이 문서는 두 가지 하위 유형인 octet-stream과 PostScript를 정의합니다.

일반적으로 응용 프로그램의 하위 유형은 종종 데이터가 의도된 응용 프로그램의 이름입니다. 그러나 이는 응용 프로그램 이름을 응용 프로그램의 하위 유형으로 자유롭게 사용할 수 있음을 의미하지는 않습니다. 이러한 사용\(시작하는 하위 유형 제외\)

"x-" 포함\)는 부록 E에 설명된 대로 IANA에 등록되어야 합니다.

---
#### **7.4.1.     The Application/Octet-Stream (primary) subtype**

응용 프로그램의 기본 하위 유형인 "octet-stream"은 본문에 이진 데이터가 포함되어 있음을 나타내는 데 사용될 수 있습니다. 가능한 매개변수 세트에는 다음이 포함되지만 이에 국한되지는 않습니다.

- TYPE -- 이진 데이터의 일반적인 유형 또는 범주. 이는 자동 처리가 아닌 수신자를 위한 정보로 사용됩니다.

- PADDING -- 포함된 바이트 지향 데이터를 생성하기 위해 실제 콘텐츠를 구성하는 비트 스트림에 추가된 패딩의 비트 수. 총 비트 수가 바이트 크기의 배수가 아닌 경우 본문에 비트 스트림을 포함하는 데 유용합니다.

추가 매개변수 "conversions"는 \[RFC-1341\]에 정의되었지만 제거되었습니다.

RFC 1341은 또한 데이터를 파일에 쓸 경우 사용할 제안 파일 이름을 제공하는 "NAME" 매개변수의 사용을 정의했습니다. 이는 후속 RFC에서 정의될 별도의 Content-Disposition 헤더 필드를 예상하여 더 이상 사용되지 않습니다.

응용 프로그램/옥텟 스트림 메일을 수신하는 구현에 대해 권장되는 조치는 Content-Transfer-Encoding을 실행 취소한 상태로 데이터를 파일에 넣거나 사용자 지정 프로세스에 대한 입력으로 사용하도록 제안하는 것입니다.

메일을 통해 악의적인 프로그램을 전송하는 위험을 줄이려면 Content-Type 매개변수\(예: "interpreter=" 매개변수\)에 이름이 지정된 임의의 프로그램을 찾아 실행하는 경로 검색 메커니즘을 구현하지 않는 것이 좋습니다. 메일 본문을 입력으로 사용합니다.

---
#### **7.4.2.     The Application/PostScript subtype**

"application/postscript"의 Content-Type은 PostScript 프로그램을 나타냅니다. 현재 PostScript 언어의 두 가지 변형이 허용됩니다. 원래 수준 1 변형은 \[POSTSCRIPT\]에 설명되어 있고 최신 수준 2 변형은 \[POSTSCRIPT2\]에 설명되어 있습니다.

PostScript는 Adobe Systems, Inc.의 등록 상표입니다. MIME 콘텐츠 유형 "응용 프로그램/포스트스크립트"의 사용은 해당 상표 및 그에 수반되는 모든 권리를 인정함을 의미합니다.

PostScript 언어 정의는 지정된 프로그램이 사용하는 특정 언어 기능의 내부 레이블 지정을 위한 기능을 제공합니다. PostScript 문서 구조화 규칙이라고 하는 이 레이블 지정은 매우 일반적이며 언어 수준보다 훨씬 더 많은 정보를 제공합니다.

필수는 아니지만 문서 구조화 규칙을 사용하는 것이 상호 운용성을 돕기 위해 강력히 권장됩니다. 적절한 구조화 규칙이 없는 문서는 주어진 환경에서 작동하는지 여부를 확인하기 위해 테스트할 수 없습니다. 따라서 일부 시스템은 최악의 상황을 가정하고 구조화되지 않은 문서 처리를 거부할 수 있습니다.

범용 PostScript 인터프리터의 실행은 심각한 보안 위험을 수반하며 구현자는 단순히 PostScript 이메일 본문을 "기성품" 인터프리터에게 보내는 것을 권장하지 않습니다. 피해 가능성이 매우 제한적인 프린터에 PostScript를 보내는 것이 일반적으로 안전하지만 구현자는 PostScript 본문의 대화형 표시를 메일 판독기에 추가하기 전에 다음 사항을 모두 고려해야 합니다.

이 섹션의 나머지 부분에서는 메일을 통해 PostScript를 보낼 때 발생할 수 있는 문제 중 일부\(전부는 아닐 수도 있음\)에 대해 간략하게 설명합니다.

PostScript 언어의 위험한 작업에는 PostScript 연산자 deletefile, renamefile, filenameforall 및 file이 포함되지만 이에 국한되지는 않습니다. 파일은 표준 입력 또는 출력 이외의 항목에 적용될 때만 위험합니다. 구현 시 추가 비표준 파일 연산자를 정의할 수도 있습니다. 이들은 또한 보안에 위협이 될 수 있습니다. 와일드카드 파일 검색 연산자인 Filenameforall은 처음에는 무해한 것처럼 보일 수 있습니다. 그러나 이 운영자는 수신자가 액세스할 수 있는 파일에 대한 정보를 공개할 가능성이 있으며 이 정보 자체가 중요할 수 있습니다. 메시지 발신자는 잠재적으로 위험한 파일 연산자의 사용을 피해야 합니다. 이러한 연산자는 보안 PostScript 구현에서 사용할 수 없을 가능성이 높기 때문입니다. 메시지 수신 및 표시 소프트웨어는 잠재적으로 위험한 모든 파일 운영자를 완전히 비활성화하거나 작업에 특별한 권한을 위임하지 않도록 특별한 주의를 기울여야 합니다. 이러한 연산자는 PostScript 문서를 해석할 때 외부 기관에서 수행하는 것으로 보아야 합니다. 이러한 비활성화 및/또는 확인은 PostScript 언어 자체의 범위 밖에서 완전히 수행되어야 합니다. 이러한 연산자의 전체 기능 버전을 다시 활성화하기 위한 방법이 존재하지 않도록 주의해야 합니다.

PostScript 언어는 일반 인터프리터 또는 서버 루프를 종료하기 위한 기능을 제공합니다. 이 "외부" 환경에서 변경한 내용은 관례적으로 문서 간에 유지되며 경우에 따라 비휘발성 메모리에 반영구적으로 유지될 수 있습니다. 그만큼

인터프리터 루프 종료와 관련된 연산자는 후속 문서 처리를 방해할 가능성이 있습니다. 따라서 이를 무단으로 사용하는 것은 서비스 거부의 위협이 됩니다. 인터프리터 루프를 종료하는 PostScript 연산자에는 exitserver 및 startjob 연산자가 포함되지만 이에 국한되지는 않습니다. 메시지 전송 소프트웨어는 작동을 위해 인터프리터 루프 종료에 의존하는 PostScript를 생성해서는 안 됩니다. 보안 PostScript 구현에서는 종료 기능을 사용하지 못할 수 있습니다. 메시지 수신 및 표시 소프트웨어는 가능한 경우 PostScript 환경에 대해 유지된 변경 사항을 적용하는 기능을 비활성화하고 startjob 및 exitserver 명령을 제거해야 합니다. 이러한 명령을 제거할 수 없는 경우 해당 명령과 관련된 암호는 최소한 추측하기 어려운 값으로 설정해야 합니다.

PostScript는 시스템 전체 및 장치별 매개변수를 설정하기 위한 연산자를 제공합니다. 이러한 매개변수 설정은 작업 전반에 걸쳐 유지될 수 있으며 잠재적으로 인터프리터의 올바른 작동에 위협이 될 수 있습니다. 시스템 및 장치 매개변수를 설정하는 PostScript 연산자에는 setsystemparams 및 setdevparams 연산자가 포함되지만 이에 국한되지는 않습니다. 메시지 전송 소프트웨어는 올바르게 작동하기 위해 시스템 또는 장치 매개변수 설정에 의존하는 PostScript를 생성해서는 안 됩니다. 보안 PostScript 구현에서는 이러한 매개변수를 설정하는 기능을 사용할 수 없습니다. 메시지 수신 및 표시 소프트웨어는 가능한 경우 시스템 및 장치 매개변수를 변경하는 기능을 비활성화해야 합니다. 이러한 연산자를 비활성화할 수 없는 경우 관련 암호는 최소한 추측하기 어려운 값으로 설정해야 합니다.

일부 PostScript 구현은 기계 코드의 직접 로드 및 실행을 위한 비표준 기능을 제공합니다. 이러한 시설은 명백히 상당한 남용에 노출되어 있습니다. 메시지 전송 소프트웨어는 이러한 기능을 사용해서는 안 됩니다. 전적으로 하드웨어에 따라 다르며 PostScript의 보안 구현에서는 사용하지 못할 수도 있습니다. 메시지 수신 및 표시 소프트웨어는 그러한 운영자가 존재하는 경우 이를 사용하도록 허용해서는 안 됩니다.

PostScript는 확장 가능한 언어이며 대부분은 아니더라도 대부분의 PostScript 구현은 여러 자체 확장을 제공합니다. 이 문서에서는 이러한 확장이 알려지지 않은 요소를 구성하므로 명시적으로 다루지 않습니다. 메시지 전송 소프트웨어는 비표준 확장을 사용해서는 안 됩니다. 일부 구현에서 누락되었을 수 있습니다. 메시지 수신 및 표시 소프트웨어는 비표준 PostScript 연산자가 안전하고 어떤 종류의 위협도 나타내지 않도록 해야 합니다.

막대한 양의 다양한 시스템 리소스를 소비하는 PostScript 작성이 가능합니다. 무한 반복하는 PostScript 프로그램을 작성하는 것도 가능합니다. 두 가지 유형의 프로그램 모두

의심하지 않는 수신자에게 보낼 경우 손상을 일으킬 가능성이 있습니다. 메시지 전송 소프트웨어는 반사회적 프로그램의 구축 및 유포를 피해야 합니다. 메시지 수신 및 표시 소프트웨어는 합리적인 시간이 경과한 후 문서 처리를 중단하는 적절한 메커니즘을 제공해야 합니다. 또한 PostScript 인터프리터는 주어진 시스템 리소스의 합당한 양만 사용하도록 제한되어야 합니다.

마지막으로 일부 PostScript 인터프리터에는 수신자의 시스템에 대한 무단 액세스 권한을 얻기 위해 악용될 수 있는 버그가 존재할 수 있습니다. 이러한 가능성을 언급하는 것 외에 이러한 버그가 발견될 경우 적시에 수정하는 것 외에는 이를 방지하기 위해 취할 특정 조치가 없습니다.

---
#### **7.4.3.     Other Application subtypes**

미래에 응용 프로그램의 많은 다른 하위 유형이 정의될 것으로 예상됩니다. MIME 구현은 일반적으로 인식되지 않는 하위 유형을 application/octet-stream과 동일한 것으로 처리해야 합니다.

애플리케이션 데이터의 콘텐츠 유형 헤더 필드에 대한 공식 문법은 다음과 같습니다.

```text
   application-type :=  "application" "/" application-subtype

   application-subtype := ("octet-stream" *stream-param)
                       / "postscript" / extension-token

   stream-param :=  (";" "type" "=" value)
                       / (";" "padding" "=" padding)

   padding := "0" / "1" /  "2" /  "3" / "4" / "5" / "6" / "7"
```

---
### **7.5.  The Image Content-Type**

"이미지"의 Content-Type은 본문에 이미지가 포함되어 있음을 나타냅니다. 하위 유형은 특정 이미지 형식의 이름을 지정합니다. 이 이름은 대소문자를 구분하지 않습니다. 두 가지 초기 하위 유형은 JPEG 형식의 경우 "jpeg", JFIF 인코딩 및 GIF 형식 \[GIF\]의 경우 "gif"입니다.

여기에 제공된 이미지 하위 유형 목록은 배타적이거나 완전하지 않으며 부록 E에 설명된 대로 더 많은 유형이 IANA에 등록됨에 따라 증가할 것으로 예상됩니다.

유형 이미지의 데이터에 대한 컨텐츠 유형 헤더 필드의 공식 문법은 다음과 같습니다.

```text
   image-type := "image" "/" ("gif" / "jpeg" / extension-token)
```

---
### **7.6.  The Audio Content-Type**

"audio"의 Content-Type은 본문에 오디오 데이터가 포함되어 있음을 나타냅니다. 컴퓨터에서 사용하기 위한 "이상적인" 오디오 형식에 대한 합의는 아직 없지만 상호 운용 가능한 동작을 제공할 수 있는 형식이 절실히 필요합니다.

"basic"의 초기 하위 유형은 최소한의 최소 공통 분모 오디오 형식을 제공하여 이 요구 사항을 충족하도록 지정됩니다. 더 높은 품질 및/또는 더 낮은 대역폭 오디오를 위한 더 풍부한 형식이 이후 문서에서 정의될 것으로 예상됩니다.

"오디오/기본" 하위 유형의 콘텐츠는 8비트 ISDN mu-law\[PCM\]를 사용하여 인코딩된 오디오입니다. 이 하위 유형이 있는 경우 샘플 속도가 8000Hz이고 단일 채널이 가정됩니다.

오디오 유형의 데이터에 대한 콘텐츠 유형 헤더 필드의 공식 문법은 다음과 같습니다.

```text
   audio-type := "audio" "/" ("basic" / extension-token)
```

---
### **7.7.  The Video Content-Type**

"비디오"의 Content-Type은 본문이 시간에 따라 변하는 그림 이미지를 포함하고 있음을 나타냅니다. "비디오"라는 용어는 특정 기술이나 형식을 참조하기보다는 매우 일반적으로 사용되며 압축적으로 인코딩된 애니메이션 그림과 같은 하위 유형을 배제하지 않습니다. 하위 유형 "mpeg"는 MPEG 표준\[MPEG\]에 따라 코딩된 비디오를 나타냅니다.

일반적으로 이 문서는 단일 본문에 여러 미디어를 혼합하는 것을 강력히 권장하지 않지만 소위 "비디오" 형식에는 동기화된 오디오에 대한 표현이 포함되어 있으며 이는 "비디오"의 하위 유형에 대해 명시적으로 허용됩니다.

비디오 유형의 데이터에 대한 콘텐츠 유형 헤더 필드의 공식 문법은 다음과 같습니다.

```text
   video-type := "video" "/" ("mpeg" / extension-token)
```

---
### **7.8.  Experimental Content-Type Values**

문자 "X-"로 시작하는 Content-Type 값은 상호 합의에 따라 동의 메일 시스템에서 사용되는 비공개 값입니다. 엄격하고 공개적인 정의가 없는 모든 형식은 이름을 지정해야 합니다.

"X-" 접두사를 사용하고 공개적으로 지정된 값은 "X-"로 시작하지 않아야 합니다. \(널리 사용되는 Andrew 시스템의 이전 버전은 "X-BE2" 이름을 사용하므로 새 시스템은 아마도 다른 이름을 선택해야 합니다.\)

일반적으로 "X-" 최상위 유형의 사용은 권장되지 않습니다. 구현자는 가능할 때마다 기존 유형의 하위 유형을 발명해야 합니다. 새로운 유형의 발명은 일반적으로 새로운 데이터 형식이 아닌 디지털 냄새 또는 홀로그래피와 같은 전자 메일을 위한 새로운 미디어 유형의 개발로 주로 제한됩니다. 대부분의 경우 응용 프로그램의 하위 유형이 새로운 최상위 수준 유형보다 더 적합합니다.

---
## **8. Summary**

MIME-Version, Content-Type 및 Content-Transfer-Encoding 헤더 필드를 사용하면 표준화된 방식으로 임의 유형의 데이터 개체를 RFC 822 준수 메일 메시지에 포함할 수 있습니다. RFC 821 또는 RFC 822에 의해 부과된 제한 사항은 위반되지 않으며 일부 인터넷 메일 전송 메커니즘의 특성에 의해 부과된 추가 제한 사항으로 인해 발생하는 문제를 피하기 위해 주의를 기울였습니다\(부록 B 참조\). "multipart" 및 "message" 콘텐츠 유형은 단일 메시지에서 다양한 유형의 개체를 혼합 및 계층 구조화할 수 있도록 합니다. 추가 콘텐츠 유형은 메시지 또는 본문 부분을 오디오, 이미지 또는 기타 여러 종류의 데이터로 태그 지정하기 위한 표준화된 메커니즘을 제공합니다. 고유 매개변수 구문을 사용하면 데이터 형식 세부사항, 특히 대체 문자 세트의 추가 지정이 가능합니다. 추가 선택적 헤더 필드는 많은 구현자가 바람직하다고 생각하는 특정 확장에 대한 메커니즘을 제공합니다. 마지막으로, 동의한 사용자 에이전트, 특히 message/partial 및 message/external-body에 의한 일반적인 사용을 위해 많은 유용한 Content-Type이 정의됩니다.

---
## **9. Security Considerations**

보안 문제는 섹션 7.4.2와 부록 F에서 논의됩니다. 구현자는 수신자 환경에서 모든 작업의 ​​원격 실행을 유발할 수 있는 모든 메일 콘텐츠 유형의 보안 의미에 특별한 주의를 기울여야 합니다. 그러한 경우, 섹션 7.4.2의 애플리케이션/포스트스크립트 콘텐츠 유형에 대한 논의는 원격 실행 기능이 있는 다른 콘텐츠 유형을 고려하기 위한 모델 역할을 할 수 있습니다.

---
## **10. Authors' Addresses**

자세한 내용은 인터넷 메일을 통해 이 문서의 작성자에게 연락할 수 있습니다.

```text
   Nathaniel S. Borenstein
   MRE 2D-296, Bellcore
   445 South St.
   Morristown, NJ 07962-1910

   Phone: +1 201 829 4270
   Fax:  +1 201 829 7019
   Email: nsb@bellcore.com

   Ned Freed
   Innosoft International, Inc.
   250 West First Street
   Suite 240
   Claremont, CA 91711

   Phone:  +1 909 624 7907
   Fax: +1 909 621 5319
   Email: ned@innosoft.com
```

MIME은 전자 메일 확장에 대한 Internet Engineering Task Force Working Group의 작업 결과입니다. 해당 그룹의 회장인 Greg Vaudreuil은 다음 주소로 연락할 수 있습니다.

```text
   Gregory M. Vaudreuil
   Tigon Corporation
   17060 Dallas Parkway
   Dallas Texas, 75248

   Phone:    +1 214-733-2722
   EMail: gvaudre@cnri.reston.va.us
```

---
## **11. Acknowledgements**

이 문서는 여러 IETF 회의, IETF-SMTP 및 IETF-822 메일링 리스트 등에서 많은 사람들이 공동으로 노력한 결과입니다. 모든 열거가 터무니없는 누락으로 인해 어려움을 겪는 것처럼 보이지만 다음은 이러한 노력에 기여한 많은 사람들 중 하나입니다.

```text
            Harald Tveit Alvestrand       Timo Lehtinen
            Randall Atkinson              John R. MacMillan
            Philippe Brandon              Rick McGowan
            Kevin Carosso                 Leo Mclaughlin
            Uhhyung Choi                  Goli Montaser-Kohsari
            Cristian Constantinof         Keith Moore
            Mark Crispin                  Tom Moore
            Dave Crocker                  Erik Naggum
            Terry Crowley                 Mark Needleman
            Walt Daniels                  John Noerenberg
            Frank Dawson                  Mats Ohrman
            Hitoshi Doi                   Julian Onions
            Kevin Donnelly                Michael Patton
            Keith Edwards                 David J. Pepper
            Chris Eich                    Blake C. Ramsdell
            Johnny Eriksson               Luc Rooijakkers
            Craig Everhart                Marshall T. Rose
            Patrik Faeltstroem            Jonathan Rosenberg
            Erik E. Fair                  Jan Rynning
            Roger Fajman                  Harri Salminen
            Alain Fontaine                Michael Sanderson
            James M. Galvin               Masahiro Sekiguchi
            Philip Gladstone              Mark Sherman
            Thomas Gordon                 Keld Simonsen
            Phill Gross                   Bob Smart
            James Hamilton                Peter Speck
            Steve Hardcastle-Kille        Henry Spencer
            David Herron                  Einar Stefferud
            Bruce Howard                  Michael Stein
            Bill Janssen                  Klaus Steinberger
            Olle Jaernefors               Peter Svanberg
            Risto Kankkunen               James Thompson
            Phil Karn                     Steve Uhler
            Alan Katz                     Stuart Vance
            Tim Kehres                    Erik van der Poel
            Neil Katin                    Guido van Rossum
            Kyuho Kim                     Peter Vanderbilt
            Anders Klemets                Greg Vaudreuil
            John Klensin                  Ed Vielmetti
            Valdis Kletniek               Ryan Waldron

            Jim Knowles                   Wally Wedel
            Stev Knowles                  Sven-Ove Westberg
            Bob Kummerfeld                Brian Wideen
            Pekka Kytolaakso              John Wobus
            Stellan Lagerstrom            Glenn Wright
            Vincent Lau                   Rayan Zachariassen
            Donald Lindsay                David Zimmerman
            Marc Andreessen               Bob Braden
            Brian Capouch                 Peter Clitherow
            Dave Collier-Brown            John Coonrod
            Stephen Crocker               Jim Davis
            Axel Deininger                Dana S Emery
            Martin Forssen                Stephen Gildea
            Terry Gray                    Mark Horton
            Warner Losh                   Carlyn Lowery
            Laurence Lundblade            Charles Lynn
            Larry Masinter                Michael J. McInerny
            Jon Postel                    Christer Romson
            Yutaka Sato                   Markku Savela
            Richard Alan Schafer          Larry W. Virden
            Rhys Weatherly                Jay Weber
            Dave Wecker
```

저자는 이 목록에서 누락된 사항에 대해 사과드립니다.
확실히 의도하지 않은.

---
# **Appendix A -- Minimal MIME-Conformance**

이 문서에서 설명하는 메커니즘은 제한이 없습니다. 모든 구현이 설명된 모든 콘텐츠 유형을 지원하거나 모두 동일한 확장을 공유할 것으로 예상되지는 않습니다. 그러나 상호 운용성을 촉진하기 위해 "MIME 적합성"의 개념을 정의하여 US ASCII 텍스트와 다른 콘텐츠가 있는 메시지의 유용한 상호 작용을 허용하는 특정 수준의 구현을 정의하는 것이 유용합니다. 이 섹션에서는 이러한 적합성에 대한 요구 사항을 지정합니다.

MIME을 준수하는 메일 사용자 에이전트는 다음을 충족해야 합니다.\(MUST\)

- 1. 항상 "MIME 버전: 1.0" 헤더 필드를 생성합니다.

- 2. Content-Transfer-Encoding 헤더 필드를 인식하고 quoted-printable 또는 base64 구현으로 인코딩된 모든 수신 데이터를 디코딩합니다. 기본 전송 메커니즘이 7비트가 아닌 데이터를 지원하지 않는 한 이러한 변환 중 하나를 사용하여 7비트 메일 준비 표현이 아닌 전송된 모든 데이터를 인코딩하고 적절한 Content-Transfer-Encoding 헤더 필드를 포함합니다.

- 3. Content-Type 헤더 필드를 인식 및 해석하고 텍스트 이외의 Content-Type 필드가 있는 원시 데이터를 사용자에게 표시하지 마십시오. US-ASCII가 아닌 경우 매개변수로 지정된 문자 집합을 사용하여 최소한 텍스트/일반 메시지를 보낼 수 있어야 합니다.

- 4. 다음 Content-Type 값을 최소한 다음 범위까지 명시적으로 처리합니다.

```text
      Text:

            -- Recognize and display "text" mail
                 with the character set "US-ASCII."
```

-- 다음에서 다른 문자 집합을 인식합니다.

- 최소한 메시지가 사용하는 문자 세트에 대해 사용자에게 알릴 수 있는 정도.

-- "ISO-8859-\*" 문자 인식

- ISO-8859-\* 및 US-ASCII에 공통되는 문자, 즉 옥텟 값 0-127로 표시되는 모든 문자를 표시할 수 있는 범위로 설정합니다.

-- 인식할 수 없는 하위 유형의 경우 표시 또는

- 콘텐츠를 표준 형식에서 로컬 형식으로 변환한 후 데이터의 "원시" 버전을 사용자에게 표시하도록 제안합니다.

```text
       Message:
```

-- 최소한 다음을 인식하고 표시합니다.

- 기본\(822\) 캡슐화.

```text
       Multipart:
```

-- 기본 인식\(혼합\)

- 하위 유형. 메시지 수준 및 본문 부분 헤더 수준에 대한 모든 관련 정보를 표시한 다음 각 본문 부분을 개별적으로 표시하거나 표시하도록 제안합니다.

-- "대체" 하위 유형을 인식하고,

- 멀티파트/대체 메일의 사용자 중복 부분을 표시하지 않도록 합니다.

-- 인식되지 않는 하위 유형을 다음과 같이 처리합니다.

-그들은 "혼합"되었습니다.

```text
       Application:
```

-- 다음 중 하나를 제거할 수 있는 기능 제공

- 이 문서에서 정의한 Content-Transfer-Encoding의 두 가지 유형 및 결과 정보를 사용자 파일에 넣습니다.

5. 인식할 수 없는 Content-Type을 발견하면

- 구현은 매개변수 하위 인수가 없는 "application/octet-stream"의 Content-Type을 갖는 것처럼 처리해야 합니다. 이러한 데이터를 처리하는 방법은 구현에 달려 있지만 이러한 인식되지 않은 데이터를 처리하기 위한 가능한 옵션에는 사용자에게 파일\(메일 전송 형식에서 디코딩됨\)에 데이터를 쓰도록 제안하거나 디코딩된 데이터가 있는 프로그램의 이름을 지정하도록 사용자에게 제공하는 것이 포함됩니다. 입력으로 전달되어야 합니다. MIME 준수 메일러에서 여전히 오디오, 이미지 또는 비디오를 포함할 수 있는 인식되지 않는 미리 정의된 유형도 이러한 방식으로 처리되어야 합니다.

```text
   A user agent that meets the above conditions is said to be MIME-
```

적합합니다. 이 구문의 의미는 그러한 메일 시스템의 사용자에게 적절하게 표시된 모든 종류의 데이터를 보내는 것이 "안전"하다고 가정한다는 것입니다. 순진한 사용자의 화면에 단순히 튀기는 것이 아닙니다. MIME을 준수하는 형식으로 데이터를 보내는 것이 항상 "안전"하다는 또 다른 의미가 있습니다. 즉, 이러한 데이터는 RFC 821 및 RFC 822를 준수하는 알려진 시스템에 의해 손상되거나 손상되지 않습니다. 사용자 MIME을 준수하는 에이전트는 텍스트로 표시되지 않도록 의도된 데이터를 사용자에게 표시하지 않는다는 추가 보장이 있습니다.

---
# **Appendix B -- General Guidelines For Sending Email Data**

인터넷 이메일은 완벽하고 동질적인 시스템이 아닙니다. 메일이 최종 목적지로 이동하는 여러 단계에서 손상될 수 있습니다. 특히 인터넷을 통해 전송된 전자 메일은 많은 네트워킹 기술을 통해 이동할 수 있습니다. 많은 네트워킹 및 메일 기술은 SMTP 전송 환경에서 가능한 전체 기능을 지원하지 않습니다. 이러한 시스템을 통과하는 메일은 전송될 수 있는 방식으로 수정될 수 있습니다.

인터넷에는 널리 배포된 비준수 MTA가 많이 있습니다. SMTP 프로토콜을 사용하는 이러한 MTA는 메시지가 구현된 호스트의 내부 데이터 구조를 이용하기 위해 즉석에서 메시지를 변경하거나 완전히 손상됩니다.

다음 지침은 가장 광범위한 네트워킹 기술과 손상된 것으로 알려진 MTA에서 손상되지 않고 살아남을 데이터 형식\(Content-Type\)을 고안하는 사람에게 유용할 수 있습니다. base64 인코딩으로 인코딩된 모든 항목은 이러한 규칙을 충족하지만 일부 잘 알려진 메커니즘, 특히 UNIX uuencode 기능은 그렇지 않습니다. 또한 Quoted-Printable 인코딩으로 인코딩된 모든 항목은 대부분의 게이트웨이에서 그대로 유지되지만 EBCDIC 문자 집합을 사용하는 시스템에 대한 일부 게이트웨이에서는 그렇지 않을 수 있습니다.

- \(1\) 일부 상황에서 데이터에 사용되는 인코딩은 일반 게이트웨이 또는 사용자 에이전트 작업의 일부로 변경될 수 있습니다. 특히 base64에서 인용 인쇄 가능으로 또는 그 반대로 변환이 필요할 수 있습니다. 이로 인해 텍스트 본문의 줄바꿈과 CRLF 시퀀스가 ​​혼동될 수 있습니다. 따라서 줄바꿈이 아닌 CRLF의 지속성에 의존해서는 안 됩니다.

- \(2\) 많은 시스템이 로컬 개행 규칙을 사용하여 텍스트 데이터를 표시하고 저장하도록 선택할 수 있습니다. 로컬 개행 규칙은 RFC822 CRLF 규칙과 일치하지 않을 수 있습니다. 시스템은 일반 CR, 일반 LF, CRLF 또는 계산된 레코드를 사용하는 것으로 알려져 있습니다. 결과적으로 격리된 CR 및 LF 문자는 일반적으로 허용되지 않습니다. 일부 시스템에서는 손실되거나 구분 기호로 변환될 수 있으므로 의존해서는 안 됩니다.

\(3\) TAB\(HT\) 문자가 잘못 해석되거나

- 가변 개수의 공백으로 자동 변환됩니다. 일부 환경, 특히 ASCII 문자 세트를 기반으로 하지 않는 환경에서는 이를 피할 수 없습니다. 이러한 변환은 강력히 권장하지 않지만 발생할 수 있으며 메일 형식은 TAB\(HT\) 문자의 지속성에 의존해서는 안 됩니다.

- \(4\) 76자보다 긴 행은 환경에 따라 줄바꿈되거나 잘릴 수 있습니다. 줄바꿈과 줄바꿈은 강력합니다.

- 낙담하지만 어떤 경우에는 피할 수 없습니다. 긴 줄이 필요한 애플리케이션은 부드러운 줄 바꿈과 단단한 줄 바꿈을 어떻게든 구분해야 합니다. \(간단한 방법은 quoted-printable 인코딩을 사용하는 것입니다.\)

- \(5\) 줄의 후행 "공백" 문자\(SPACE, TAB\(HT\)\)는 일부 전송 에이전트에서 버릴 수 있는 반면 다른 전송 에이전트는 메일 파일의 모든 줄이 동일하도록 이러한 문자로 줄을 채울 수 있습니다. 길이. 따라서 후행 공백의 지속성에 의존해서는 안 됩니다.

- \(6\) 많은 메일 도메인은 ASCII 문자 세트의 변형을 사용하거나 US-ASCII 문자의 전부는 아니지만 대부분을 포함하는 EBCDIC과 같은 문자 세트를 사용합니다. "불변" 집합에 없는 문자의 올바른 번역은 문자 변환 게이트웨이 간에 의존할 수 없습니다. 예를 들어 uuencode된 정보를 EBCDIC 시스템인 BITNET을 통해 전송할 때 이러한 상황이 문제가 됩니다. 많은 인터넷 호스트가 내부적으로 ASCII 이외의 문자 집합을 사용하기 때문에 게이트웨이를 통과하지 않고도 비슷한 문제가 발생할 수 있습니다. X.400의 인쇄 가능한 문자열 정의는 특정 특수한 경우에 추가 제한 사항을 추가합니다. 특히 모든 게이트웨이에서 일관된 것으로 알려진 유일한 문자는 대문자와 소문자 A-Z 및 a-z에 해당하는 73자, 0-9의 10자리 숫자 및 다음 11개의 특수 문자입니다.

```text
                        "'"  (ASCII code 39)
                        "("  (ASCII code 40)
                        ")"  (ASCII code 41)
                        "+"  (ASCII code 43)
                        ","  (ASCII code 44)
                        "-"  (ASCII code 45)
                        "."  (ASCII code 46)
                        "/"  (ASCII code 47)
                        ":"  (ASCII code 58)
                        "="  (ASCII code 61)
                        "?"  (ASCII code 63)
```

- base64 인코딩과 같이 최대로 이식 가능한 메일 표현은 이 73자 세트에서 의미 있는 문자만 가져오는 상대적으로 짧은 텍스트 행으로 제한됩니다.

- \(7\) 일부 메일 전송 에이전트는 특정 리터럴 문자열을 포함하는 데이터를 손상시킵니다. 특히 한 줄의 마침표\("."\)만 일부\(잘못된\) SMTP 구현에 의해 손상되는 것으로 알려져 있으며 "From"\(5번째 문자는 SPACE\)으로 시작하는 5개의 문자로 시작하는 줄이 일반적으로 손상됩니다. \~처럼

-  잘. 신중한 컴포지션 에이전트는 데이터를 인코딩하여 이러한 손상을 방지할 수 있습니다\(예: 인용된 인쇄 가능 인코딩에서 줄 시작 부분의 "From" 대신 "=46rom", "." 대신 "=2E"\). 한 줄에 혼자.

위의 목록은 MTA에 대한 권장 사례 목록이 아닙니다. RFC 821 MTA는 공백 문자를 변경하거나 긴 줄을 래핑하는 것을 금지합니다. 이러한 BAD 및 불법 관행은 기존 네트워크에서 발생하는 것으로 알려져 있으며 구현은 이로 인해 발생할 수 있는 나쁜 영향을 처리하는 데 강력해야 합니다.

---
# **Appendix C -- A Complex Multipart Example**

다음은 복잡한 멀티파트 메시지의 개요입니다. 이 메시지는 순차적으로 표시되는 다섯 부분으로 구성되어 있습니다. 소개 일반 텍스트 부분 두 개, 포함된 여러 부분으로 구성된 메시지, 서식 있는 텍스트 부분 및 ASCII가 아닌 문자 세트로 캡슐화된 닫는 텍스트 메시지입니다. 임베디드 멀티파트 메시지에는 병렬로 표시되는 두 부분인 그림과 오디오 조각이 있습니다.

MIME 버전: 1.0

- 보낸 사람: Nathaniel Borenstein <nsb@bellcore.com\> 받는 사람: Ned Freed <ned@innosoft.com\> 제목: 멀티파트 예제 콘텐츠 유형: multipart/mixed; 경계=고유 경계-1

멀티파트 메시지의 서문 영역입니다.

- 멀티파트 형식을 이해하는 메일 리더는 이 서문을 무시해야 합니다. 이 텍스트를 읽고 있는 경우 여러 부분으로 구성된 메시지를 올바르게 표시하는 방법을 이해하는 메일 판독기로 변경하는 것이 좋습니다. --unique-boundary-1

...여기에 일부 텍스트가 나타납니다...

- \[앞의 빈 줄은 헤더 필드가 제공되지 않았음을 의미하며 문자 집합이 US ASCII인 텍스트입니다. 다음 부분에서와 같이 명시적인 타이핑으로 수행할 수 있었습니다.\]

```text
      --unique-boundary-1
      Content-type: text/plain; charset=US-ASCII
```

이것은 이전 부분의 일부일 수 있습니다.

- 신체 부위의 명시적 유형과 암시적 유형을 보여줍니다.

```text
      --unique-boundary-1
      Content-Type: multipart/parallel;
           boundary=unique-boundary-2

      --unique-boundary-2
      Content-Type: audio/basic
      Content-Transfer-Encoding: base64

         ... base64-encoded 8000 Hz single-channel
             mu-law-format audio data goes here....

      --unique-boundary-2
      Content-Type: image/gif
      Content-Transfer-Encoding: base64

         ... base64-encoded image data goes here....

      --unique-boundary-2--

      --unique-boundary-1
      Content-type: text/richtext
```

<bold\><italic\>리치텍스트</italic\></bold\>입니다.

- <smaller\>RFC 1341에 정의된 대로</smaller\> <nl\><nl\><bigger\><bigger\>멋지죠?</bigger\></bigger\>

```text
      --unique-boundary-1
      Content-Type: message/rfc822
```

보내는 사람: \(US-ASCII의 사서함\)

- 수신자: \(US-ASCII 주소\) 제목: \(US-ASCII 제목\) 콘텐츠 유형: 텍스트/일반; charset=ISO-8859-1 Content-Transfer-Encoding: Quoted-printable

```text
         ... Additional text in ISO-8859-1 goes here ...

      --unique-boundary-1--
```

---
# **Appendix D -- Collected Grammar**

이 부록에는 이 문서에서 지정한 모든 구문에 대한 완전한 BNF 문법이 포함되어 있습니다.

그러나 그 자체로는 이 문법이 불완전합니다. 이것은 RFC 822에 의해 정의된 여러 엔터티를 나타냅니다. 여기서 이러한 정의를 재현하여 둘 사이의 의도하지 않은 차이점을 위험에 빠뜨리는 대신 이 문서는 독자에게 나머지 정의에 대해 RFC 822를 참조하도록 합니다. 정의되지 않은 용어는 RFC 822 정의를 참조합니다.

```text
   application-subtype := ("octet-stream" *stream-param)
                       / "postscript" / extension-token

   application-type :=  "application" "/" application-subtype

   attribute := token    ; case-insensitive

   atype := "ftp" / "anon-ftp" / "tftp" / "local-file"
                  / "afs" / "mail-server" / extension-token
                  ; Case-insensitive

   audio-type := "audio" "/" ("basic" / extension-token)
```

body-part := <RFC 822에 정의된 "메시지",

- 모든 헤더 필드는 선택 사항이며 지정된 구분 기호는 메시지 본문의 어느 곳에서도 발생하지 않으며, 자체적으로 또는 하위 문자열로 어디에도 없습니다.\>

- 참고: 특정 전송 영역에서는 본문을 인쇄 가능한 ASCII 문자로 제한하는 것과 같은 RFC 822 제한이 적용되지 않을 수 있습니다. \(즉, 전송 도메인은 특정 제한 없이 RFC821에 지정되고 RFC822에서 가정하는 표준 인터넷 메일 전송과 유사할 수 있습니다.\) 이러한 제한의 완화는 예를 들어 외부 옥텟을 포함하도록 본문의 정의를 로컬로 확장하는 것으로 해석되어야 합니다. 이러한 확장이 전송에서 지원되고 Content-Transfer-Encoding 헤더 필드에 적절하게 문서화되는 한 ASCII 범위의 그러나 어떤 경우에도 헤더\(메시지 헤더 또는 본문 부분 헤더\)는 ASCII 문자 이외의 것을 포함할 수 없습니다.

```text
   boundary := 0*69<bchars> bcharsnospace

   bchars := bcharsnospace / " "

   bcharsnospace :=    DIGIT / ALPHA / "'" / "(" / ")" / "+"  / "_"
                  / "," / "-" / "." / "/" / ":" / "=" / "?"

   charset := "us-ascii" / "iso-8859-1" / "iso-8859-2"/ "iso-8859-3"
        / "iso-8859-4" / "iso-8859-5" /  "iso-8859-6" / "iso-8859-7"
        / "iso-8859-8" / "iso-8859-9" / extension-token
        ; case insensitive

   close-delimiter := "--" boundary "--" CRLF;Again,no space by "--",
```

content := "콘텐츠 유형" ":" 유형 "/" 하위 유형 \*\(";" 매개변수\) ; 유형 및 하위 유형의 대소문자를 구분하지 않는 일치

delimiter := "--" 경계 CRLF ; Content-Type 필드에서 가져옴. ; 공간이 없어야 합니다. "--"와 경계 사이.

```text
   description := "Content-Description" ":" *text

   discard-text := *(*text CRLF)

   encapsulation := delimiter body-part CRLF

   encoding := "Content-Transfer-Encoding" ":" mechanism
```

에필로그 := 폐기 텍스트 ; 수신 시 무시됩니다.

```text
   extension-token :=  x-token / iana-token

   external-param :=   (";" "access-type" "=" atype)
                  / (";" "expiration" "=" date-time)
```

; 날짜-시간이 인용되어 있음에 유의하십시오.

- / \(";" "크기" "=" 1\*DIGIT\) / \(";" "권한" "=" \("읽기" / "읽기-쓰기"\)\) ; 권한은 대소문자를 구분하지 않습니다. / \(";" "이름" "="값\) / \(";" "사이트" "="값\) / \(";" "dir" "="값\) / \(";" " 모드" "="값\) / \(";" "서버" "="값\) / \(";" "제목" "="값\) ;액세스 유형 필요; 액세스 유형에 따라 필요한 기타

iana-token := <공개적으로 정의된 확장 토큰,

- 부록 E에 명시된 대로 IANA에 등록됨\>

```text
   id :=  "Content-ID" ":" msg-id

   image-type := "image" "/" ("gif" / "jpeg" / extension-token)

   mechanism :=     "7bit"    ;  case-insensitive
                  / "quoted-printable"
                  / "base64"
                  / "8bit"
                  / "binary"
                  / x-token

   message-subtype := "rfc822"
                  / "partial" 2#3partial-param
                  / "external-body" 1*external-param
                  / extension-token

   message-type := "message" "/" message-subtype

   multipart-body :=preamble 1*encapsulation close-delimiter epilogue

   multipart-subtype := "mixed" / "parallel" / "digest"
                  / "alternative" / extension-token

   multipart-type := "multipart" "/" multipart-subtype
                  ";" "boundary" "=" boundary
```

옥텟 := "=" 2\(DIGIT / "A" / "B" / "C" / "D" / "E" / "F"\)

- ; 옥텟은 \> 127, =, SPACE 또는 TAB 문자에 사용되어야 합니다. 에 나열되지 않은 모든 문자에 권장됩니다. 부록 B는 "메일 안전"입니다.

```text
   padding := "0" / "1" /  "2" /  "3" / "4" / "5" / "6" / "7"

   parameter := attribute "=" value
```

부분 매개변수 := \(";" "id" "="값\)

- / \(";" "숫자" "=" 1\*DIGIT\) / \(";" "합계" "=" 1\*DIGIT\) ; id & number required;마지막 부분에 필요한 합계

서문 := 폐기 텍스트 ; 수신 시 무시됩니다.

ptext := octet / <"=", SPACE 또는 TAB를 제외한 모든 ASCII 문자\>

; 부록 B에 "메일 안전"으로 나열되지 않은 문자

- ; 또한 권장되지 않습니다.

인용 인쇄 가능 := \(\[\*\(ptext / SPACE / TAB\) ptext\] \["="\] CRLF\) ; CRLF를 제외한 최대 줄 길이는 76자입니다.

```text
   stream-param :=  (";" "type" "=" value)
                / (";" "padding" "=" padding)

   subtype := token  ; case-insensitive

   text-subtype := "plain" / extension-token

   text-type := "text" "/" text-subtype [";" "charset" "=" charset]
```

토큰 := 1\*<SPACE, CTL 또는 tspecials를 제외한 모든\(ASCII\) CHAR\>

tspecials := "\(" / "\)" / "<" / "\>" / "@"

- / "," / ";" / ":" / "\" / <"\> / "/" / "\[" / "\]" / "?" / "=" ; 따옴표로 묶인 문자열이어야 함 ; 매개변수 값 내에서 사용

```text
   type :=     "application"     /  "audio"   ; case-insensitive
             / "image"           / "message"
             / "multipart"  / "text"
             / "video"           / extension-token
             ; All values case-insensitive

   value := token / quoted-string

   version := "MIME-Version" ":" 1*DIGIT "." 1*DIGIT

   video-type := "video" "/" ("mpeg" / extension-token)
```

x-token := <두 개의 문자 "X-" 또는 "x-" 뒤에 공백 없이 모든 토큰이 나옵니다.\>

---
# **Appendix E -- IANA Registration Procedures**

MIME은 확장 가능한 메커니즘을 갖도록 신중하게 설계되었으며 콘텐츠 유형/하위 유형 쌍 세트 및 관련 매개변수가 시간이 지남에 따라 크게 증가할 것으로 예상됩니다. 몇 가지 다른 MIME 필드, 특히 문자 세트 이름, 메시지/외부 본문 유형에 대한 액세스 유형 매개변수, 심지어 Content-Transfer-Encoding 값까지 시간이 지남에 따라 새로운 값이 정의될 가능성이 있습니다. 이러한 값 집합이 질서정연하고 잘 지정되고 공개적인 방식으로 개발되도록 하기 위해 MIME은 IANA\(Internet Assigned Numbers Authority\)를 해당 값의 중앙 레지스트리로 사용하는 등록 프로세스를 정의합니다.

일반적으로 콘텐츠 유형 헤더 필드의 매개변수는 다양한 콘텐츠 유형에 대한 추가 정보를 전달하는 데 사용되며 콘텐츠 유형 및 하위 유형이 정의될 때 용도가 정의됩니다. 새 매개변수는 새 기능을 도입하는 방법으로 정의되어서는 안 됩니다.

등록 프로세스를 간소화하고 표준화하기 위해 이 부록에서는 IANA에 새 값을 등록하기 위한 템플릿을 제공합니다. 이들 각각은 등록 당사자가 작성할 이메일 메시지 템플릿 형식으로 제공됩니다.

E.1 새로운 콘텐츠 유형/하위 유형 값 등록

MIME은 일반적으로 하위 유형에 의해 확장될 것으로 예상됩니다. 새로운 기본 최상위 유형이 필요한 경우 해당 사양을 RFC로 게시하거나 RFC가 되기에 적합한 형식으로 제출해야 하며 인터넷 표준 프로세스를 따라야 합니다.

받는 사람: IANA@isi.edu

- 제목: 새로운 MIME 콘텐츠 유형/하위 유형 등록

```text
      MIME type name:
```

\(위가 기존 최상위 MIME 타입이 아닌 경우,

- 기존 타입을 사용할 수 없는 이유를 설명해주세요.\)

```text
      MIME subtype name:

      Required parameters:

      Optional parameters:

      Encoding considerations:

      Security considerations:

      Published specification:
```

\(게시된 사양은 인터넷 RFC 또는

- 새로운 최상위 유형이 정의되고 어떤 경우에도 공개적으로 사용 가능한 사양이어야 하는 경우 RFC-to-be입니다.\)

- 추가 정보를 위해 연락할 사람 및 이메일 주소:

E.2 새로운 액세스 유형 값 등록

- 메시지/외부 본문용

받는 사람: IANA@isi.edu

- 제목 : Message/external-body content-type에 대한 신규 MIME Access-type 등록

```text
      MIME access-type name:

      Required parameters:

      Optional parameters:

      Published specification:
```

\(게시된 사양은 인터넷 RFC 또는

- RFC 예정.\)

- 추가 정보를 위해 연락할 사람 및 이메일 주소:

---
# **Appendix F -- Summary of the Seven Content-types**

```text
   Content-type: text
```

이 문서에서 정의한 하위 유형: plain

```text
   Important Parameters: charset
```

인코딩 참고 사항: 인코딩이 필요하고 문자 집합이 대부분 ASCII 상위 집합인 경우 인용 인쇄 가능이 일반적으로 선호됩니다.

보안 고려 사항: TeX 및 Troff와 같은 서식 있는 텍스트 형식에는 종종 임의 명령 또는 파일 시스템 작업을 실행하기 위한 메커니즘이 포함되어 있으므로 이러한 보안 문제가 해결되지 않는 한 자동으로 사용해서는 안 됩니다. 일반 텍스트에도 "지능형" 터미널의 기능을 악용하고 보안 위반을 일으키는 데 사용할 수 있는 제어 문자가 포함될 수 있습니다. 이러한 터미널에서 실행되도록 설계된 사용자 인터페이스는 이러한 문제를 인식하고 방지해야 합니다.

```text
   ________________________________________________________
   Content-type: multipart
```

이 문서에서 정의한 하위 유형: 혼합, 대체,

- 다이제스트, 병렬.

```text
   Important Parameters: boundary
```

인코딩 참고 사항: 콘텐츠 전송 인코딩은 허용되지 않습니다.

```text
   ________________________________________________________
   Content-type: message
```

이 문서에서 정의한 하위 유형: rfc822, partial, external-body

```text
   Important Parameters: id, number, total, access-type, expiration,
      size, permission, name, site, directory, mode, server, subject
```

인코딩 참고 사항: 콘텐츠 전송 인코딩은 허용되지 않습니다.

- 구체적으로 "message/partial" 또는 "message/external-body"는 "7bit"만 허용되며 "message"의 다른 하위 유형은 "7bit", "8bit" 또는 "binary"만 허용됩니다. \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_ 콘텐츠 유형: 신청서

이 문서에서 정의한 하위 유형: octet-stream, postscript

```text
   Important Parameters:  type, padding
```

더 이상 사용되지 않는 매개변수: 이름 및 변환은

- RFC 1341에 정의되어 있습니다.

인코딩 참고 사항: 읽을 수 없는 하위 유형에는 base64가 선호됩니다.

보안 고려 사항: 이 유형은 로컬에 설치된 프로그램에서 해석할 데이터 전송을 위한 것입니다. 예를 들어 실행 가능한 이진 프로그램이나 LISP 프로그램이나 쉘 스크립트와 같은 범용 해석 언어로 된 프로그램을 전송하는 데 사용하면 심각한 보안 문제가 발생할 수 있습니다. 메일 읽기 에이전트 작성자는 시스템에 보안 영향을 신중하게 고려하지 않고 메일 기반 응용 프로그램 데이터를 실행할 수 있는 권한을 부여하지 않도록 주의해야 합니다. 안전한 응용 프로그램 형식과 안전하지 않은 형식에 대한 안전한 인터프리터를 정의하는 것은 확실히 가능하지만 가능한 보안 문제에 대해 각 인터프리터를 개별적으로 평가해야 합니다. \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_ 콘텐츠 유형: 이미지

이 문서에서 정의한 하위 유형: jpeg, gif

```text
   Important Parameters: none

   Encoding notes: base64 generally preferred
   ________________________________________________________________
   Content-type: audio
```

이 문서에서 정의한 하위 유형: 기본

```text
   Important Parameters: none

   Encoding notes: base64 generally preferred
   ________________________________________________________________
   Content-type: video
```

이 문서에서 정의한 하위 유형: mpeg

```text
   Important Parameters: none

   Encoding notes: base64 generally preferred
```

---
# **Appendix G -- Canonical Encoding Model**

이 메모의 초기 초안에는 이메일 데이터가 표준 형식으로 변환되고 인코딩되는 시기에 대한 모델과 특히 이 프로세스가 CRLF 처리에 어떤 영향을 미치는지에 대해 혼란이 있었습니다. 시스템에서 시스템으로. 이러한 이유로 인코딩을 위한 표준 모델이 아래에 제시됩니다.

MIME 엔터티를 구성하는 프로세스는 여러 단계로 수행되는 것으로 모델링할 수 있습니다. 이러한 단계는 RFC 1421에서 사용되는 단계와 대략 유사하며 각 '가장 안쪽 수준' 본문에 대해 수행됩니다.

1단계. 로컬 양식 생성.

전송할 본문은 시스템의 기본 형식으로 생성됩니다. 기본 문자 집합이 사용되며 적절한 로컬 줄 끝 규칙도 사용됩니다. 본문은 UNIX 스타일의 텍스트 파일, Sun 래스터 이미지, VMS 색인 파일, 메모리에만 저장된 시스템 종속 형식의 오디오 데이터 또는 표현을 위한 로컬 모델에 해당하는 모든 것일 수 있습니다. 어떤 형태의 정보. 기본적으로 데이터는 유형/하위 유형 정보로 지정된 "네이티브" 형식으로 생성됩니다.

2단계. 정식 형식으로 변환.

레코드 길이 및 가능한 경우 파일 속성 정보와 같은 "대역 외" 정보를 포함하는 전체 본문은 범용 정식 형식으로 변환됩니다. 본문의 특정 콘텐츠 유형과 관련 속성은 사용되는 정식 형식의 특성을 나타냅니다. 적절한 표준 형식으로의 변환에는 문자 집합 변환, 오디오 데이터 변환, 압축 또는 다양한 콘텐츠 유형에 특정한 기타 다양한 작업이 포함될 수 있습니다. 그러나 문자 집합 변환이 포함된 경우 콘텐츠 유형의 의미 체계를 이해하기 위해 주의를 기울여야 합니다. "일반" 이외의 텍스트 하위 유형에서 구문적으로 의미 있는 문자와 관련하여.

예를 들어 텍스트/일반 데이터의 경우 텍스트는 지원되는 문자 집합으로 변환되어야 하며 줄은 RFC822에 따라 CRLF 구분 기호로 구분되어야 합니다. 다음 단계에서 quoted-printable 또는 base64 인코딩을 사용하는 경우 RFC822에 의해 암시된 줄 길이에 대한 제한이 제거됩니다.

```text
   Step 3.  Apply transfer encoding.
```

이 본문에 적합한 Content-Transfer-Encoding이 적용됩니다. 콘텐츠 유형과 전송 인코딩 사이에는 고정된 관계가 없습니다. 특히 본문의 주어진 인스턴스에 고유한 문자 빈도 수에 따라 base64 또는 quoted-printable을 선택하는 것이 적절할 수 있습니다.

4단계. 엔터티에 삽입.

인코딩된 개체는 적절한 헤더와 함께 MIME 엔터티에 삽입됩니다. 그런 다음 엔티티는 필요한 경우 상위 레벨 엔티티\(메시지 또는 멀티파트\)의 본문에 삽입됩니다.

이러한 단계는 모델일 뿐이라는 점에 유의해야 합니다. 구체적으로 실제 시스템을 구축하는 방법에 대한 청사진이 아닙니다. 특히 이 모델은 두 가지 일반적인 디자인을 설명하지 못합니다.

- 1. 많은 경우 인코딩 전에 표준 형식으로의 변환은 로컬 형식을 직접 이해하는 인코더 자체에 포함됩니다. 예를 들어 텍스트 본문에 대한 로컬 개행 규칙은 해당 형식에 대한 지식과 함께 인코더 자체로 전달될 수 있습니다.

- 2. 인코더의 출력은 메시지로 전송되기 전에 하나 이상의 추가 단계를 거쳐야 할 수 있습니다. 따라서 인코더의 출력이 RFC822에 지정된 형식과 일치하지 않을 수 있습니다. 특히 표준 RFC822 CRLF 구분 기호를 사용하는 대신 로컬 개행 규칙을 사용하여 변환기의 출력을 표현하는 것이 다시 한 번 적절할 수 있습니다.

다른 구현 변형도 생각할 수 있습니다. 이 논의의 중요한 측면은 최적화, 필수 단계 축소 또는 추가 처리 삽입에도 불구하고 결과 메시지가 여기에 설명된 모델에서 생성된 메시지와 일치해야 한다는 것입니다. 예를 들어 다음 헤더 필드가 있는 메시지:

```text
        Content-type: text/foo; charset=bar
        Content-Transfer-Encoding: base64
```

먼저 text/foo 형식으로 표현한 다음 \(필요한 경우\) "bar" 문자 집합으로 표현하고 마지막으로 base64 알고리즘을 통해 메일 안전 형식으로 변환해야 합니다.

---
# **Appendix H -- Changes from RFC 1341**

이 문서는 RFC 1341의 비교적 사소한 개정판입니다. RFC 1341에 익숙한 사용자의 편의를 위해 해당 문서의 기술적 변경 사항이 이 부록에 요약되어 있습니다.

1. "tspecials"의 정의가 더 이상 "."을 포함하지 않도록 변경되었습니다.

2. Content-ID 필드는 이제 메시지/외부 본문 부분에 필수입니다.

3. 텍스트/리치텍스트 유형\(이전 섹션 7.1.3 및 부록 D 포함\)은 별도의 문서로 이동되었습니다.

4. 메시지/부분 데이터의 헤더 병합에 대한 규칙이 변경되어 Encrypted 및 MIME-Version 헤더를 특수한 경우로 취급합니다.

5. external-body access-type 매개변수의 정의가 변경되어 단일 액세스 방법만 표시할 수 있습니다\(이것이 전부였습니다\).

6. 제목 필드 정보에 의존하는 메일 서버의 MIME 기반 사용을 허용하기 위해 메시지/외부 본문, 액세스 유형 메일 서버에 대한 새로운 "제목" 매개변수가 있습니다.

7. application/octet-stream에 대한 "conversions" 매개변수가 제거되었습니다.

8. 섹션 7.4.1은 이제 application/octet-stream에 대한 "name" 매개변수의 사용을 더 이상 사용하지 않습니다. 이것은 향후 Content-Disposition 헤더로 대체될 것입니다.

9. 첫 번째 경계선 앞에 CRLF가 더 이상 필요하지 않도록 다중 부분 본문의 공식 문법이 변경되었습니다.

10. "message/partial" 및 "message/external-body" 유형의 MIME 엔터티는 이제 "7bit" 전송 인코딩만 사용해야 합니다. \(구체적으로 "바이너리" 및 "8비트"는 허용되지 않습니다.\)

11. "application/oda" 콘텐츠 유형이 제거되었습니다.

12. multipart/alternative MIME 엔터티에서 Content-ID의 의미 체계를 설명하는 메모가 섹션 7.2.3 끝에 추가되었습니다.

13. "MIME-Version" 필드의 공식 구문이 강화되었지만 유일한

RFC 1341에 정의된 버전 번호입니다.

14. 섹션 7.3.1에서 필수 필드와 관련하여 message/rfc822의 정의가 완화되었습니다.

RFC 1341의 다른 모든 변경 사항은 편집상의 변경 사항이며 MIME의 기술적 내용에 영향을 미치지 않습니다. 상당한 형식 문법이 추가되었지만 이는 이미 자리 잡은 산문 사양을 반영합니다.

---
# **References**

\[US-ASCII\] 코드화된 문자 세트--정보 교환을 위한 7비트 미국 표준 코드, ANSI X3.4-1986.

\[ATK\] Borenstein, Nathaniel S., Andrew Toolkit을 사용한 멀티미디어 응용 프로그램 개발, Prentice-Hall, 1990.

```text
   [GIF] Graphics Interchange Format (Version 89a), Compuserve, Inc.,
   Columbus, Ohio, 1990.
```

\[ISO-2022\] 국제 표준--정보 처리--ISO 7비트 및 8비트 코드화 문자 집합--코드 확장 기술, ISO 2022:1986.

```text
   [ISO-8859] Information Processing -- 8-bit Single-Byte Coded Graphic
   Character Sets -- Part 1: Latin Alphabet No. 1, ISO 8859-1:1987.  Part
   2: Latin alphabet No.  2, ISO 8859-2, 1987.  Part 3: Latin alphabet
   No. 3, ISO 8859-3, 1988.  Part 4: Latin alphabet No.  4, ISO 8859-4,
   1988.  Part 5: Latin/Cyrillic alphabet, ISO 8859-5, 1988.  Part 6:
   Latin/Arabic alphabet, ISO 8859-6, 1987.  Part 7: Latin/Greek
   alphabet, ISO 8859-7, 1987.  Part 8: Latin/Hebrew alphabet, ISO
   8859-8, 1988.  Part 9: Latin alphabet No. 5, ISO 8859-9, 1990.
```

\[ISO-646\] 국제 표준--정보 처리--정보 교환을 위한 ISO 7비트 코드 문자 세트, ISO 646:1983.

```text
   [MPEG] Video Coding Draft Standard ISO 11172 CD, ISO IEC/TJC1/SC2/WG11
   (Motion Picture Experts Group), May, 1991.
```

\[PCM\] CCITT, Fascicle III.4 - Recommendation G.711, Geneva, 1972, "Pulse Code Modulation \(PCM\) of Voice Frequencies".

```text
   [POSTSCRIPT] Adobe Systems, Inc., PostScript Language Reference
   Manual, Addison-Wesley, 1985.

   [POSTSCRIPT2] Adobe Systems, Inc., PostScript Language Reference
   Manual, Addison-Wesley, Second Edition, 1990.
```

\[X400\] Schicker, Pietro, "메시지 처리 시스템, X.400", 메시지 처리 시스템 및 분산 응용 프로그램, E. Stefferud, O-j. Jacobsen, P. Schicker, eds., North-Holland, 1989, pp. 3-41.

```text
   [RFC-783] Sollins, K., "TFTP Protocol (revision 2)", RFC 783, MIT,
   June 1981.

   [RFC-821] Postel, J., "Simple Mail Transfer Protocol", STD 10, RFC
   821, USC/Information Sciences Institute, August 1982.
```

\[RFC-822\] Crocker, D., "ARPA 인터넷 텍스트 메시지 형식에 대한 표준", STD 11, RFC 822, UDEL, 1982년 8월.

\[RFC-934\] Rose, M. 및 E. Stefferud, "메시지 캡슐화에 대한 표준 제안", RFC 934, Delaware 및 NMA, 1985년 1월.

\[RFC-959\] Postel, J. 및 J. Reynolds, "파일 전송 프로토콜", STD 9, RFC 959, USC/Information Sciences Institute, 1985년 10월.

\[RFC-1049\] Sirbu, M., "인터넷 메시지용 콘텐츠 유형 헤더 필드", STD 11, RFC 1049, CMU, 1988년 3월.

\[RFC-1421\] Linn, J., "인터넷 전자 메일을 위한 개인 정보 강화: 파트 I - 메시지 암호화 및 인증 절차", RFC 1421, IAB IRTF PSRG, IETF PEM WG, 1993년 2월.

\[RFC-1154\] Robinson, D. 및 R. Ullmann, "인터넷 메시지용 헤더 필드 인코딩", RFC 1154, Prime Computer, Inc., 1990년 4월.

\[RFC-1341\] Borenstein, N. 및 N. Freed, "MIME\(다목적 인터넷 메일 확장\): 인터넷 메시지 본문의 형식 지정 및 설명을 위한 메커니즘", RFC 1341, Bellcore, Innosoft, 1992년 6월.

\[RFC-1342\] Moore, K., "인터넷 메시지 헤더의 비 ASCII 텍스트 표현", RFC 1342, 테네시 대학교, 1992년 6월.

\[RFC-1343\] Borenstein, N., "멀티미디어 메일 형식 정보를 위한 사용자 에이전트 구성 메커니즘", RFC 1343, Bellcore, 1992년 6월.

\[RFC-1344\] Borenstein, N., "인터넷 메일 게이트웨이에 대한 MIME의 의미", RFC 1344, Bellcore, 1992년 6월.

```text
   [RFC-1345] Simonsen, K., "Character Mnemonics & Character Sets",
   RFC 1345, Rationel Almen Planlaegning, June 1992.
```

\[RFC-1426\] Klensin, J., \(WG 의장\), Freed, N., \(편집자\), Rose, M., Stefferud, E. 및 D. Crocker, "8비트-MIME 전송을 위한 SMTP 서비스 확장", RFC 1426, United Nations Universit, Innosoft, Dover Beach Consulting, Inc., Network Management Associates, Inc., The Branch Office, 1993년 2월.

\[RFC-1522\] Moore, K., "인터넷 메시지 헤더의 비 ASCII 텍스트 표현" RFC 1522, University of Tennessee, 1993년 9월.

\[RFC-1340\] Reynolds, J. 및 J. Postel, "Assigned Numbers", STD 2, RFC 1340, USC/Information Sciences Institute, 1992년 7월.
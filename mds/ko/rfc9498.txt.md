

```text
﻿

Independent Submission                                   M. Schanzenbach
Request for Comments: 9498                              Fraunhofer AISEC
Category: Informational                                      C. Grothoff
ISSN: 2070-1721                                    Berner Fachhochschule
                                                                  B. Fix
                                                             GNUnet e.V.
                                                           November 2023

                          The GNU Name System
```

---
# **Abstract**

이 문서는 GNU 이름 시스템\(GNS\) 기술 사양을 제공합니다. GNS는 DNS\(도메인 이름 시스템\) 프로토콜에 대한 개인 정보 보호 강화 대안을 제공하는 분산형 및 검열 저항성 도메인 이름 확인 프로토콜입니다.

이 문서는 구현자가 사용할 리소스 레코드, 확인 프로세스, 암호화 루틴, 보안 및 개인 정보 보호 고려 사항의 규범적인 연결 형식을 정의합니다.

이 사양은 IETF 외부에서 개발되었으며 IETF 합의가 없습니다. 독자들에게 GNS의 기능에 대해 알리고, 향후 GNS 구현을 안내하고, 구현\(예: 기존 GNUnet 구현\) 간의 상호 운용성을 보장하기 위해 여기에 게시되었습니다.

---
# **Status of This Memo**

이 문서는 인터넷 표준 추적 사양이 아닙니다. 정보 제공의 목적으로 게시됩니다.

이것은 다른 RFC 스트림과 독립적으로 RFC 시리즈에 대한 기여입니다. RFC 편집자는 재량에 따라 이 문서를 게시하도록 선택했으며 구현 또는 배포의 가치에 대해 언급하지 않습니다. RFC 편집자가 게시하도록 승인한 문서는 인터넷 표준 수준의 후보가 아닙니다. RFC 7841의 섹션 2를 참조하십시오.

이 문서의 현재 상태, 정오표 및 피드백 제공 방법에 대한 정보는 https://www.rfc-editor.org/info/rfc9498에서 얻을 수 있습니다.

---
# **Copyright Notice**

Copyright \(c\) 2023 IETF Trust 및 문서 작성자로 확인된 사람. 판권 소유.

이 문서는 이 문서의 발행일에 유효한 BCP 78 및 IETF 문서에 관한 IETF 트러스트의 법적 조항\(https://trustee.ietf.org/license-info\)의 적용을 받습니다. 이 문서와 관련된 귀하의 권리 및 제한 사항을 설명하므로 이 문서를 주의 깊게 검토하십시오.

---
# **Table of Contents**

```text
   1.  Introduction
     1.1.  Requirements Notation
   2.  Terminology
   3.  Overview
     3.1.  Names and Zones
     3.2.  Publishing Binding Information
     3.3.  Resolving Names
   4.  Zones
     4.1.  Zone Top-Level Domain (zTLD)
     4.2.  Zone Revocation
   5.  Resource Records
     5.1.  Zone Delegation Records
       5.1.1.  PKEY
       5.1.2.  EDKEY
     5.2.  Redirection Records
       5.2.1.  REDIRECT
       5.2.2.  GNS2DNS
     5.3.  Auxiliary Records
       5.3.1.  LEHO
       5.3.2.  NICK
       5.3.3.  BOX
   6.  Record Encoding for Remote Storage
     6.1.  The Storage Key
     6.2.  Plaintext Record Data (RDATA)
     6.3.  The Resource Record Block
   7.  Name Resolution
     7.1.  Start Zones
     7.2.  Recursion
     7.3.  Record Processing
       7.3.1.  REDIRECT
       7.3.2.  GNS2DNS
       7.3.3.  BOX
       7.3.4.  Zone Delegation Records
       7.3.5.  NICK
   8.  Internationalization and Character Encoding
   9.  Security and Privacy Considerations
     9.1.  Availability
     9.2.  Agility
     9.3.  Cryptography
     9.4.  Abuse Mitigation
     9.5.  Zone Management
     9.6.  DHTs as Remote Storage
     9.7.  Revocations
     9.8.  Zone Privacy
     9.9.  Zone Governance
     9.10. Namespace Ambiguity
   10. GANA Considerations
     10.1.  GNUnet Signature Purposes Registry
     10.2.  GNS Record Types Registry
     10.3.  .alt Subdomains Registry
   11. IANA Considerations
   12. Implementation and Deployment Status
   13. References
     13.1.  Normative References
     13.2.  Informative References
   Appendix A.  Usage and Migration
     A.1.  Zone Dissemination
     A.2.  Start Zone Configuration
     A.3.  Globally Unique Names and the Web
     A.4.  Migration Paths
   Appendix B.  Example Flows
     B.1.  AAAA Example Resolution
     B.2.  REDIRECT Example Resolution
     B.3.  GNS2DNS Example Resolution
   Appendix C.  Base32GNS
   Appendix D.  Test Vectors
     D.1.  Base32GNS Encoding/Decoding
     D.2.  Record Sets
     D.3.  Zone Revocation
   Acknowledgements
   Authors' Addresses
```

---
## **1.  Introduction**

이 사양은 검열에 저항하고 개인 정보를 보호하며 분산된 도메인 이름 확인 프로토콜인 GNU 이름 시스템\(GNS\)에 대해 설명합니다. GNS는 임의의 토큰에 대한 이름 바인딩을 암호화 방식으로 보호하여 오늘날의 공개 키 인프라 중 일부에 대한 대안으로 어떤 측면에서 두 배의 기능을 제공합니다.

DNS\(도메인 이름 시스템\) 용어 \[RFC1035\]에 따라 GNS는 대략 로컬 루트 영역 배포 아이디어를 따릅니다\(\[RFC8806\] 참조\). 차이점은 디자인이 대체 루트를 장려하고 모든 배포에서 동일하거나 동일한 루트 영역을 사용하도록 기대하지 않는다는 차이점이 있습니다. 특정 루트 영역. GNS 참조 구현에서 사용자는 로컬 구성을 통해 영역에 대한 이름 제어를 자율적이고 자유롭게 위임할 수 있습니다. GNS는 각 사용자가 자신의 설정을 제어할 수 있을 것으로 기대합니다. 섹션 9.10의 지침을 따르면 사용자는 이름 확인 방법에 대한 혼란을 피할 수 있습니다.

이름 확인 및 영역 전파는 사용자가 영역에 로컬 이름을 할당할 수 있는 애완동물 이름 시스템의 원칙을 기반으로 합니다. GNS는 SDSI\(Simple Distributed Security Infrastructure\)의 아이디어에 뿌리를 두고 있으며 보안 식별자를 기억하기 쉬운 이름으로 분산 매핑할 수 있습니다. GNS의 암호화 아이디어에 대한 최초의 학문적 설명 중 하나는 \[GNS\]에서 찾을 수 있습니다.

이 문서는 구현자가 사용할 리소스 레코드, 확인 프로세스, 암호화 루틴, 보안 및 개인 정보 보호 고려 사항의 규범적인 연결 형식을 정의합니다.

---
### **1.1.  Requirements Notation**

키워드 "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY" 및 "OPTIONAL" "는 BCP 14 \[RFC2119\] \[RFC8174\]에 설명된 대로 여기에 표시된 것처럼 모두 대문자로 표시되는 경우에만 해석됩니다.\(MUST NOT\)

---
## **2.  Terminology**

Apex 레이블: 이 유형의 레이블은 특정 레이블을 제공하지 않고 확인할 수 있는 영역에 리소스 레코드를 게시하는 데 사용됩니다. DNS \[RFC4033\]에서 "zone apex"라는 것을 제공하기 위한 GNS 방법입니다. 정점 레이블은 문자 U+0040\(따옴표 없이 "@"\)을 사용하여 표시됩니다.

애플리케이션\(Application\): 애플리케이션은 GNS를 사용하는 구성요소입니다.

- 이름을 기록으로 분석하고 그 내용을 처리하기 위한 구현입니다.

블라인드 존 키: 블라인드 존 키는 존 키와 라벨에서 파생된 키입니다. 영역 키와 여기서 파생된 모든 블라인드 영역 키는 파생에 사용된 특정 레이블을 알지 못하면 연결이 불가능합니다.

확장 라벨: 이 유형의 라벨은 확장명을 참조하는 데 사용됩니다.

- 레코드가 있는 권한 있는 영역. 확장 레이블의 주요 용도는 리디렉션 대상이 리디렉션 레코드의 권한 있는 영역과 관련하여 정의되는 리디렉션입니다\(섹션 5.2 참조\). 확장 레이블은 문자 U+002B\(따옴표 제외 "+"\)를 사용하여 표시됩니다.

라벨 구분 기호: 이름의 라벨은 라벨 구분 기호 U+002E\(따옴표 제외 "."\)를 사용하여 구분됩니다. GNS에서는 영역 최상위 도메인\(zTLD\)\(아래 참조\) 및 박스형 레코드\(섹션 5.3.3 참조\)를 제외하고 이름의 모든 레이블 구분 기호는 다른 영역에 대한 위임을 나타냅니다.

라벨: GNS 라벨은 \[RFC8499\]에 정의된 라벨입니다. 레이블은 NFC\(Unicode Normalization Form C\) \[Unicode-UAX15\]의 UTF-8 문자열입니다. 정점 레이블과 확장 레이블은 이 문서의 나머지 부분에 정의된 해결 프로토콜에서 특별한 목적을 갖습니다. 영역 관리자는 등록 정책을 통해 다른 레이블과 쉽게 혼동될 수 있는 특정 레이블을 허용하지 않을 수 있습니다\(섹션 9.4 참조\).\(MAY\)

이름: GNS의 이름은 \[RFC8499\]에 정의된 도메인 이름입니다. 이름은 레이블 구분 기호로 연결된 정렬된 레이블 목록으로 구성된 UTF-8 문자열 \[RFC3629\]입니다. 이름은 가장 오른쪽 레이블부터 확인됩니다. GNS는 이름이나 라벨에 길이 제한을 두지 않습니다. 그러나 애플리케이션은 이름과 레이블 길이가 DNS, 특히 IDNA\(Internationalized Domain Names for Application\) \[RFC5890\]와 호환되는지 확인할 수 있습니다. \[RFC5895\]의 정신에 따라 애플리케이션은 DNS와의 호환성을 보장하거나 특정 사용자 기대치를 지원하기 위해 이름과 레이블을 사전 처리할 수 있습니다\(예: \[Unicode-UTS46\]에 따라\). GNS 이름은 DNS 이름과 구별되지 않을 수 있으므로 애플리케이션 및 구현자는 GNS 이름을 처리할 때 주의를 기울여야 합니다\(섹션 9.10 참조\). \(예약된\) DNS 도메인이 있는 예제 도메인의 오해를 피하기 위해 이 문서에서는 \[RFC9476\]에 따라 접미사 ".gns.alt"를 사용합니다. ".gns.alt"는 GANA ".alt 하위 도메인" 레지스트리\[GANA\]에도 등록되어 있습니다.\(MAY, MAY\)

확인자: 이 문서에서 확인자는 섹션 7에 정의된 재귀적 이름 확인 논리를 제공하는 GNS 구현의 구성 요소입니다.

리소스 레코드: GNS 리소스 레코드는 GNS 영역의 레이블과 관련된 정보입니다. GNS 리소스 레코드에는 리소스 레코드 유형에 정의된 정보가 포함됩니다.

시작 영역: 특정 GNS 이름을 확인하려면 이 이름에 대한 초기 시작 영역을 결정해야 합니다. 시작 영역은 zTLD를 사용하여 이름의 일부로 명시적으로 정의될 수 있습니다. 그렇지 않으면 로컬 접미사-영역 매핑을 통해 결정됩니다\(섹션 7.1 참조\).

최상위 도메인\(TLD\): GNS 이름의 가장 오른쪽 부분은 GNS TLD입니다. GNS TLD는 하나 이상의 라벨로 구성될 수 있습니다. DNS TLD\(\[RFC8499\]에 정의됨\)와 달리 GNS는 모든 사용자가 동일한 전역 루트 영역을 사용할 것으로 기대하지 않습니다. 대신 zTLD\(섹션 4.1 참조\)를 제외하고 GNS TLD는 일반적으로 로컬 확인자 구성\(섹션 7.1 참조\)의 일부이므로 전역적으로 고유하지 않을 수 있습니다.

영역: GNS 영역에는 신뢰할 수 있는 정보\(리소스 레코드\)가 포함됩니다. 영역은 해당 영역 키로 고유하게 식별됩니다. DNS 영역과 달리 GNS 영역은 정점 레이블 아래에 SOA 레코드를 가질 필요가 없습니다.

영역 키: 영역 키는 영역을 고유하게 식별하는 키입니다. 일반적으로 비대칭 키 쌍의 공개 키입니다. 그러나 확립된 기술 용어 "공개 키"는 오해의 소지가 있습니다. GNS에서 영역 키는 승인되지 않은 당사자에게 공개되어서는 안 되는 공유 비밀일 수 있기 때문입니다.

구역 키 파생 함수: 구역 키 파생 함수\(ZKDF\)는 레이블을 사용하여 구역 키를 숨깁니다.

영역 게시자: 영역 게시자는 섹션 6에 정의된 대로 로컬 영역 관리 및 게시를 제공하는 GNS 구현의 구성 요소입니다.

영역 소유자: 영역 소유자는 비밀\(일반적으로 개인 키\)의 소유자이며, 이는 \(레이블 및 서명할 값과 함께\) 각각의 블라인드 영역 키에 대해 검증할 수 있는 영역 서명 생성을 허용합니다.

영역 최상위 도메인\(zTLD\): GNS zTLD는 GNS 이름 끝에 있는 일련의 GNS 레이블입니다. zTLD는 구역의 구역 유형과 구역 키를 인코딩합니다\(섹션 4.1 참조\). 영역 키의 통계적 고유성으로 인해 zTLD는 전역적으로도 고유합니다. zTLD 레이블 시퀀스는 레이블을 영역 유형 및 영역 키로 디코딩하려고 시도함으로써 일반 TLD 레이블 시퀀스와만 구별될 수 있습니다.

영역 유형: GNS 영역 유형에 따라 영역 키, 블라인드 영역 키 및 암호화 서명의 암호화 시스템과 바이너리 인코딩 형식이 결정됩니다.

---
## **3.  Overview**

GNS는 애완동물 이름 시스템을 설명하는 데 일반적으로 사용되는 세 가지 속성을 나타냅니다.

zTLD 개념을 통한 전역 이름:

- 구역은 구역 키로 고유하게 식별될 수 있고 통계적으로 고유하므로 zTLD는 구역에 대한 전역적으로 고유한 매핑입니다. 결과적으로 zTLD 접미사가 붙은 GNS 도메인 이름은 전역적으로도 고유합니다. zTLD 접미사가 붙은 이름은 기억에 남지 않습니다.

구역에 대한 기억에 남는 애완동물 이름:

- 사용자는 영역에 대한 기억에 남는 로컬 참조를 구성할 수 있습니다. 이러한 애완동물 이름은 지역 운영자에게 편리한 구역 이름을 제공하는 zTLD 모니커 역할을 합니다. 애완동물 이름은 해당 영역을 참조할 때 사용할 좋은 레이블을 검색하는 다른 사용자를 위한 제안으로 게시될 수도 있습니다.

이름에서 기록으로의 안전한 매핑:

- GNS를 사용하면 영역 소유자가 라벨을 리소스 레코드에 매핑하거나 라벨에 의해 유도된 하위 도메인의 이름 권한을 다른 영역에 위임할 수 있습니다. 영역 소유자는 이 정보를 게시하여 다른 사용자가 사용할 수 있도록 선택할 수 있습니다. 매핑은 원격 저장소에 게시되기 전에 해당 레이블에서 파생된 키를 사용하여 암호화되고 서명됩니다. 이름이 확인되면 위임을 포함한 리소스 레코드의 서명이 재귀 확인자에 의해 확인됩니다.

이 문서의 나머지 부분에서 "구현자"는 확인자, 영역 게시자 및 시작 영역과 같은 지원 구성을 포함하는 GNS 구현을 구축하는 개발자를 의미합니다\(섹션 7.1 참조\).

---
### **3.1.  Names and Zones**

위에서부터 GNS는 전역적이고 안전하며 기억에 남는 이름을 지원하지 않습니다. 대신, 이름은 전역적이고 기억에 남지 않거나 전역적으로 독특하고 기억에 남지 않습니다. 영역에서 "example" 레코드를 가리키는 전역 이름의 예는 다음과 같습니다.

```text
   example.000G006K2TJNMD9VTCYRX7BRVV3HAEPS15E6NHDXKPJA1KAJJEG9AFF884
```

이제 사용자가 위 이름의 "example" 레코드를 사용하여 영역에 대해 petname "pet.gns.alt"를 로컬로 구성한 경우를 생각해 보세요. 그러면 "example.pet.gns.alt"라는 이름은 위의 전역적으로 고유한 이름과 동일한 레코드를 가리키지만 이름 확인은 "pet.gns.alt" 애완동물 이름이 구성된 로컬 시스템에서만 작동합니다.

애칭 위임 및 후속 위임 해결은 단순 분산 보안 인프라\(SDSI\)의 아이디어를 기반으로 합니다. GNS에서 시스템이 영역 게시자 구현을 제공하는 경우 모든 사용자는 원하는 수만큼 영역을 생성하고 관리할 수 있습니다\(섹션 4 참조\). 각 영역에 대해 영역 유형에 따라 해당 암호화 작업 집합과 암호화된 데이터, 공개 키 및 서명에 대한 연결 형식이 결정됩니다. 영역은 소유자가 레이블에서 리소스 레코드로의 매핑\(섹션 5 참조\)으로 채울 수 있습니다. 레이블은 위임 레코드에 매핑될 수 있습니다. 이로 인해 해당 하위 도메인이 다른 영역에 위임됩니다. 하위 도메인을 직속 상위 영역에 위임하는 것을 포함하여 순환 위임이 명시적으로 허용됩니다. \(레거시\) 애플리케이션을 지원하고 애완동물 이름의 사용을 용이하게 하기 위해 GNS는 기존 DNS 레코드 지원 외에 보조 레코드 유형을 정의합니다.

---
### **3.2.  Publishing Binding Information**

그림 1과 같이 영역 콘텐츠는 원격 키-값 저장소\(섹션 6 참조\)에 게시되기 전에 암호화되고 서명됩니다. 이 프로세스에서 키 블라인드를 사용하여 고유한 영역 식별이 네트워크에서 숨겨집니다. 키 블라인드를 사용하면 블라인드 공개/개인 키 쌍을 사용하여 영역 콘텐츠에 대한 서명을 생성할 수 있습니다. 이러한 블라인드는 원래 영역 키에서 파생된 결정론적 키와 블라인드 요소가 파생되는 입력으로 레코드 레이블 값을 사용하는 해당 개인 키를 사용하여 실현됩니다. 특히, 영역 소유자는 레이블에 게시된 각 레코드 세트에 대해 숨겨진 개인 키를 파생할 수 있고 확인자는 해당 숨겨진 공개 키를 파생할 수 있습니다. GNS 구현은 전용 인프라 없이도 네트워크 내에서 가용성을 촉진하기 위해 분산 해시 테이블\(DHT\)과 같은 분산형 원격 저장소 엔터티를 사용할 것으로 예상됩니다. 이러한 분산 또는 분산형 저장 엔터티의 사양은 이 문서의 범위를 벗어나지만 가능한 기존 구현에는 \[RFC7363\], \[Kademlia\] 또는 \[R5N\]을 기반으로 한 구현이 포함됩니다.

```text
          Host A           |     Remote      |      Host B
                           |     Storage     |
                           |                 |
                           |    +---------+  |
                           |   /         /|  |
                  Publish  |  +---------+ |  |  Publish
    +-----------+ Records  |  |         | |  |  Records +-----------+
    |   Zone    |----------|->| Record  | |<-|----------|   Zone    |
    | Publisher |          |  | Storage | |  |          | Publisher |
    +-----------+          |  |         |/   |          +-----------+
         A                 |  +---------+    |               A
         |                 |                 |               |
      +---------+          |                 |           +---------+
     /   |     /|          |                 |          /    |    /|
    +---------+ |          |                 |         +---------+ |
    |         | |          |                 |         |         | |
    |  Local  | |          |                 |         |  Local  | |
    |  Zones  | |          |                 |         |  Zones  | |
    |         |/           |                 |         |         |/
    +---------+            |                 |         +---------+

       Figure 1: An Example Diagram of Two Hosts Publishing GNS Zones
```

사용자가 영역을 생성하고 관리할 수 있도록 영역 게시자 구현은 GNS 구현의 일부로 제공되어야 합니다. 이 기능이 구현되지 않은 경우에도 이름 확인의 초기 단계에 대한 영역 키가 구성되었거나\(섹션 7 참조\) 이름이 zTLD 접미사로 끝나는 경우 이름을 계속 확인할 수 있습니다.\(SHOULD\)

---
### **3.3.  Resolving Names**

애플리케이션은 리졸버를 사용하여 GNS 이름을 조회합니다. 구성 가능한 시작 영역에서 시작하여 이름은 그림 2에 표시된 것처럼 영역 위임을 반복적으로 수행하여 확인됩니다. 이름의 각 레이블에 대해 재귀 GNS 확인자는 스토리지 계층에서 해당 레코드 세트를 가져옵니다\(섹션 7 참조\). 레이블 값과 영역 키에 대한 지식이 없으면 서로 다른 파생 키를 원래 영역 키와 서로 연결할 수 없습니다. 이는 영역 열거를 방지합니다\(비용이 많이 드는 온라인 무차별 대입 공격 제외\). 쿼리 또는 해당 암호화된 레코드 세트가 특정 영역과 연관되어 있는지 확인하려면 영역 키와 레이블에 대한 지식이 필요하며 둘 중 어느 것도 원격에 공개되지 않습니다. 프로토콜에 의한 저장. 동시에, 각 암호화된 레코드 세트와 연관된 블라인드 존 키와 디지털 서명을 통해 확인자 및 인식되지 않는 원격 스토리지는 원래 영역이나 레코드 세트에 대해 아무것도 공개하지 않고 게시된 정보의 무결성을 확인할 수 있습니다.

```text
                              Local Host           |   Remote
                                                   |   Storage
                                                   |
                                                   |    +---------+
                                                   |   /         /|
                                                   |  +---------+ |
   +-----------+ Name     +----------+ Recursive   |  |         | |
   |           | Lookup   |          | Resolution  |  | Record  | |
   |Application|--------->| Resolver |-------------|->| Storage | |
   |           |<---------|          |<------------|--|         |/
   +-----------+ Results  +----------+ Intermediate|  +---------+
                             A         Results     |
                             |                     |
                          +---------+              |
                         /   |     /|              |
                        +---------+ |              |
                        |         | |              |
                        |  Start  | |              |
                        |  Zones  | |              |
                        |         |/               |
                        +---------+                |

          Figure 2: High-Level View of the GNS Resolution Process
```

---
## **4.  Zones**

GNS의 구역은 구역 유형\(ztype\)과 구역 키로 고유하게 식별됩니다. 각 영역은 영역 유형과 영역 키를 인코딩하는 문자열인 zTLD\(섹션 4.1 참조\)로 참조될 수 있습니다. ztype은 GANA "GNS 레코드 유형" 레지스트리\[GANA\]에서 위임 레코드 유형을 식별하는 리소스 레코드 유형 번호에 해당하는 고유한 32비트 숫자입니다. ztype은 영역의 설정된 암호화 기능과 위임 레코드 유형의 형식에 대한 고유 식별자입니다. 모든 ztype 등록은 다음 암호화 기능 세트를 정의해야 합니다.\(MUST\)

KeyGen\(\) -\> d, zkey

- 새로운 개인 키 d와 해당 공개 영역 키 zkey를 생성하는 함수입니다.

ZKDF\(zkey, 라벨\) -\> zkey'

- 라벨을 사용하여 영역 키 zkey를 블라인드하는 ZKDF입니다. zkey 및 zkey'는 연결 해제되어야 합니다. 게다가 레이블에 대해 서로 다른 값을 사용하여 zkey를 가리면 서로 다른 연결 불가능한 zkey' 값이 생성되어야 합니다.

S-암호화\(zkey, 레이블, 만료, 일반 텍스트\) -\> 암호문

- 영역 키 zkey, 레이블 및 만료 타임스탬프에서 파생된 키 자료를 기반으로 일반 텍스트를 암호화하여 암호문을 파생시키는 대칭 암호화 기능입니다. 특정 기본 저장소 엔터티\(특히 DHT\)의 성능 향상 캐싱 기능을 활용하려면 결정론적 암호화 체계가 권장됩니다.

S-Decrypt\(zkey, 레이블, 만료, 암호문\) -\> 일반 텍스트

- 영역 키, 레이블 및 만료 타임스탬프에서 파생된 키 자료를 기반으로 암호문을 일반 텍스트로 해독하는 대칭형 암호 해독 기능입니다.

서명\(d, 메시지\) -\> 서명

- 개인 키 d를 사용하여 메시지에 서명하여 위조할 수 없는 암호화 서명을 생성하는 기능입니다. 특정 기본 저장소 엔터티\(특히 DHT\)의 성능 향상 캐싱 기능을 활용하려면 결정론적 서명 체계가 권장됩니다.

확인\(zkey, 메시지, 서명\) -\> 부울

- d,zkey := KeyGen\(\)인 영역 키 zkey에 해당하는 개인 키 d를 사용하여 서명이 생성되었는지 확인하는 함수. 이 함수는 서명이 유효하면 "TRUE"라는 부울 값을 반환하고 그렇지 않으면 "FALSE"를 반환합니다.

SignDerived\(d, label, message\) -\> 서명

- 파생된 영역 키 zkey' := ZKDF\(zkey, label\)를 사용하여 확인할 수 있는 메시지\(일반적으로 암호화된 레코드 데이터\)에 서명하기 위한 함수입니다. 특정 기본 저장소 엔터티\(특히 DHT\)의 성능 향상 캐싱 기능을 활용하려면 결정론적 서명 체계가 권장됩니다.

verifyDerived\(zkey', 메시지, 서명\) -\> 부울

- 파생된 영역 키 zkey' := ZKDF\(zkey, label\)를 사용하여 서명을 확인하는 함수. 이 함수는 서명이 유효하면 "TRUE"라는 부울 값을 반환하고 그렇지 않으면 "FALSE"를 반환합니다. 사용된 서명 체계에 따라 이 함수는 verify\(\) 함수와 동일할 수 있습니다.

기본 ztype의 암호화 기능은 섹션 5.1에서 설명한 대로 해당 위임 레코드로 지정됩니다. 암호화 민첩성을 지원하기 위해 향후 이 문서에 정의된 기본 ztype을 대체하거나 업데이트하는 추가 ztype을 정의할 수 있습니다. 모든 ztype은 GANA "GNS 레코드 유형" 레지스트리에 전용 영역 위임 레코드 유형으로 등록되어야 합니다\(\[GANA\] 참조\). 새로운 기록 유형을 정의할 때 이 문서, 특히 섹션 9.3의 암호화 보안 고려 사항이 적용됩니다.\(MAY, MUST\)

---
### **4.1.  Zone Top-Level Domain (zTLD)**

zTLD는 영역 유형과 영역 키를 도메인 이름 접미사로 인코딩하는 문자열입니다. zTLD는 이름 확인 과정에서 영역에 대한 전역적으로 고유한 참조로 사용됩니다. 이는 영역 유형과 영역 키의 이진 연결을 인코딩하여 생성됩니다\(그림 3 참조\). 사용된 인코딩은 Base32GNS라고 불리는 Crockford Base32 인코딩 \[CrockfordB32\]의 변형입니다. 이 변형을 포함하여 Base32GNS의 인코딩 및 디코딩 기호는 부록 C의 표 4에 정의되어 있습니다. 표 4를 기반으로 한 인코딩 및 디코딩 기능을 각각 Base32GNS-Encode 및 Base32GNS-Decode라고 합니다.

```text
   0     8     16    24    32    40    48    56
   +-----+-----+-----+-----+-----+-----+-----+-----+
   |       ZONE TYPE       |      ZONE KEY         /
   +-----+-----+-----+-----+                       /
   /                                               /
   /                                               /
   +-----+-----+-----+-----+-----+-----+-----+-----+

              Figure 3: The Binary Representation of the zTLD
```

ZONE TYPE은 네트워크 바이트 순서로 인코딩되어야 합니다. ZONE KEY의 형식은 전적으로 ZONE TYPE에 따라 다릅니다.\(MUST\)

결과적으로 zTLD는 다음과 같이 인코딩 및 디코딩됩니다.

```text
   zTLD := Base32GNS-Encode(ztype||zkey)
   ztype||zkey := Base32GNS-Decode(zTLD)
```

여기서 "||" 연결 연산자입니다.

zTLD는 GNS 이름의 가장 오른쪽 레이블로 "있는 그대로" 사용될 수 있습니다. 애플리케이션이 이름의 DNS 호환성을 보장하려는 경우 다음과 같이 zTLD를 나타낼 수도 있습니다. zTLD가 63자보다 작거나 같으면 그대로 zTLD로 사용할 수 있습니다. zTLD가 63자를 초과하는 경우 zTLD는 레이블 구분 기호로 구분된 더 작은 레이블로 나뉩니다. 여기서 "ztype||zkey" 연결의 최상위 바이트는 결과 문자열의 가장 오른쪽 레이블에 포함되어야 하고 최하위 바이트는 결과 문자열의 가장 왼쪽 레이블에 포함되어야 합니다. 이를 통해 확인자는 가장 오른쪽 레이블에서 ztype 및 zTLD 길이를 결정하고 이후에 zTLD가 확장되어야 하는 레이블 수를 결정할 수 있습니다. GNS 구현은 DNS 호환 레이블 길이로 zTLD 분할을 지원해야 합니다. 예를 들어 zTLD가 130자라고 가정하면 구분은 다음과 같습니다.\(MAY, MUST\)

```text
   zTLD[126..129].zTLD[63..125].zTLD[0..62]
```

---
### **4.2.  Zone Revocation**

영역 키를 취소하려면 서명된 취소 메시지를 게시해야 합니다. 이 메시지는 해당 영역의 개인 키를 사용하여 서명되어야 합니다. 취소 메시지는 네트워크에 브로드캐스트됩니다. 브로드캐스트 메커니즘의 사양은 이 문서의 범위를 벗어납니다. 분산 네트워크에서 효율적인 플러딩을 위한 가능한 브로드캐스트 메커니즘이 \[GNUnet\]에 구현되었습니다. 또는 해지 메시지를 분산 원장이나 신뢰할 수 있는 중앙 서버를 통해 배포할 수도 있습니다. 플러딩 공격을 방지하려면 해지 메시지에 작업 증명\(PoW\)이 포함되어야 합니다. PoW를 포함한 철회 메시지는 시기적절한 철회를 지원하기 위해 미리 계산될 수 있습니다.\(MUST, MUST, MUST, MAY\)

아래의 모든 경우에 대해 "Argon2id"는 \[RFC9106\]에 정의된 비밀번호 기반 키 파생 함수입니다. PoW 계산을 위해 알고리즘은 다음 매개변수를 사용하여 인스턴스화됩니다.

```text
   S:  The salt.  Fixed 16-byte string: "GnsRevocationPow"
```

t: 반복 횟수: 3

m: 메모리 크기\(KiB\): 1024

T: 해시 출력 길이\(바이트\): 64

```text
   p:  Parallelization parameter: 1

   v:  Algorithm version: 0x13

   y:  Algorithm type (Argon2id): 2

   X:  Unused

   K:  Unused
```

그림 4는 PoW가 계산되는 데이터 "P"의 형식을 보여줍니다.

```text
   0     8     16    24    32    40    48    56
   +-----+-----+-----+-----+-----+-----+-----+-----+
   |                      POW                      |
   +-----------------------------------------------+
   |                   TIMESTAMP                   |
   +-----------------------------------------------+
   |       ZONE TYPE       |    ZONE KEY           /
   +-----+-----+-----+-----+                       /
   /                                               /
   /                                               /
   +-----+-----+-----+-----+-----+-----+-----+-----+

                    Figure 4: The Format of the PoW Data
```

POW: PoW에 대한 솔루션인 64비트 값입니다. 네트워크 바이트 순서입니다.

TIMESTAMP: 취소가 계산된 절대 64비트 날짜를 나타냅니다. 네트워크 바이트 순서로 1970년 1월 1일 UTC 자정\(0시간\) 이후의 마이크로초 단위입니다.

ZONE TYPE: 네트워크 바이트 순서의 32비트 영역 유형입니다.

ZONE KEY: 취소되는 영역의 256비트 공개 키 zkey입니다. 이 값의 와이어 형식은 ZONE TYPE에 의해 정의됩니다.

일반적으로 PoW 체계에서는 하나의 POW 값을 찾아야 하며, 해시 결과에서 특정 개수의 선행 0이 발견됩니다. 이 숫자를 PoW의 난이도라고 합니다. PoW를 계산하는 데 걸리는 시간의 차이를 줄이기 위해 유효한 GNS 철회를 위해서는 평균적으로 D개 이상의 선행 0이 있는 다양한 PoW\(Z, 아래 정의됨\)를 찾아야 합니다.

평균 난이도 D를 고려하면 증명의 만료 시간은 EPOCH입니다. 애플리케이션은 선행 0이 \(평균적으로\) D 비트보다 많은 POW 값을 제공함으로써 D보다 더 높은 난이도로 증명을 계산할 수 있습니다. 난이도가 추가될 때마다 증명의 수명은 또 다른 EPOCH에 의해 연장됩니다. 결과적으로, 더 어려운 PoW를 계산함으로써 영역 소유자의 요구에 따라 증명의 수명, 즉 해지 메시지의 지속성을 늘릴 수 있습니다.\(MAY\)

매개변수는 다음과 같이 정의됩니다.

Z: 필요한 PoW 수입니다. 값은 32로 고정되어 있습니다.

D: 평균 난이도의 하한입니다. 값은 22로 고정되어 있습니다.

EPOCH: 단일 ​​시대. 그 값은 365일로 고정되어 있습니다.

- 마이크로초.

해지 메시지 연결 형식은 그림 5에 나와 있습니다.

```text
   0     8     16    24    32    40    48    56
   +-----+-----+-----+-----+-----+-----+-----+-----+
   |                   TIMESTAMP                   |
   +-----+-----+-----+-----+-----+-----+-----+-----+
   |                      TTL                      |
   +-----+-----+-----+-----+-----+-----+-----+-----+
   |                     POW_0                     |
   +-----+-----+-----+-----+-----+-----+-----+-----+
   |                       ...                     |
   +-----+-----+-----+-----+-----+-----+-----+-----+
   |                    POW_(Z-1)                  |
   +-----------------------------------------------+
   |       ZONE TYPE       |    ZONE KEY           /
   +-----+-----+-----+-----+                       /
   /                                               /
   /                                               /
   +-----+-----+-----+-----+-----+-----+-----+-----+
   /                   SIGNATURE                   /
   /                                               /
   /                                               /
   /                                               /
   +-----+-----+-----+-----+-----+-----+-----+-----+

                Figure 5: The Revocation Message Wire Format
```

TIMESTAMP: 취소가 계산된 절대 64비트 날짜를 나타냅니다. 네트워크 바이트 순서로 1970년 1월 1일 UTC 자정\(0시간\) 이후의 마이크로초 단위입니다. 이는 개별 PoW 계산에 사용된 타임스탬프와 동일한 값입니다.

TTL: 네트워크 바이트 순서로 레코드의 상대적인 64비트 TTL\(Time to Live\)을 마이크로초 단위로 나타냅니다. 필드는 EPOCH \* 1.1로 설정되어야 합니다. 선행 0의 평균 개수 D'가 주어지면 필드 값은 \(D'-D+1\) \* EPOCH \* 1.1까지 증가할 수 있습니다. 유효성 검사기는 수신 시 더 낮거나 더 높은 값을 가진 메시지를 거부할 수 있습니다.\(SHOULD, MAY, MAY\)

POW\_i: PoW의 일부로 계산된 값\(네트워크 바이트 순서\)입니다. 각 POW\_i는 POW 값 집합에서 고유해야 합니다. 고유성을 빠르게 확인하려면 메시지에서 POW 값을 엄격하게 단조롭게 증가하는 순서로 제공해야 합니다.\(MUST, MUST\)

ZONE TYPE: 네트워크 바이트 순서의 구역 키에 해당하는 32비트 구역 유형입니다.

ZONE KEY: 취소되는 영역의 공개 키 zkey와 SIGNATURE를 확인하는 데 사용되는 키입니다.

서명: 타임스탬프에 대한 서명과 취소된 영역의 영역 zkey 및 PoW에 사용된 키에 해당합니다. 서명은 영역 암호화 시스템의 Sign\(\) 함수와 개인 키를 사용하여 생성됩니다\(섹션 4 참조\).

해지 메시지의 서명은 TIMESTAMP, ZONE TYPE 및 ZONE KEY 필드 앞에 붙은 32비트 헤더를 포함합니다. 헤더에는 키 길이와 서명 목적이 포함됩니다. 와이어 형식은 그림 6에 나와 있습니다.

```text
   0     8     16    24    32    40    48    56
   +-----+-----+-----+-----+-----+-----+-----+-----+
   |         SIZE          |       PURPOSE (0x03)  |
   +-----+-----+-----+-----+-----+-----+-----+-----+
   |                   TIMESTAMP                   |
   +-----+-----+-----+-----+-----+-----+-----+-----+
   |       ZONE TYPE       |     ZONE KEY          /
   +-----+-----+-----+-----+                       /
   /                                               /
   /                                               /
   +-----+-----+-----+-----+-----+-----+-----+-----+

        Figure 6: The Wire Format of the Revocation Data for Signing
```

SIZE: 네트워크 바이트 순서에 따라 서명된 데이터의 길이\(바이트\)를 포함하는 32비트 값입니다.

목적: 32비트 서명 목적 플래그입니다. 이 필드의 값은 3이어야 합니다. 값은 네트워크 바이트 순서로 인코딩됩니다. 이는 가능한 향후 확장을 포함할 수 있는 프로토콜의 다른 부분에서 재사용할 수 없도록 서명이 생성되는 컨텍스트를 정의합니다. 이 필드의 값은 GANA "GNUnet 서명 목적" 레지스트리\[GANA\]의 항목에 해당합니다.\(MUST\)

TIMESTAMP: 위의 취소 메시지에 정의된 필드입니다.

ZONE TYPE: 위의 해지 메시지에 정의된 필드입니다.

영역 키: 위의 취소 메시지에 정의된 필드입니다.

철회를 검증하려면 다음 단계를 수행해야 합니다.\(MUST\)

1. 서명은 영역 키에 대해 확인되어야 합니다.\(MUST\)

2. POW 값 세트에는 중복이 포함되어서는 안 됩니다. 이는 값이 엄격하게 단조롭게 증가하는지 확인하여 확인해야 합니다.\(MUST NOT\)

```text
   3.  The average number of leading zeroes D' resulting from the
       provided POW values MUST be greater than or equal to D.
       Implementers MUST NOT use an integer data type to calculate or
       represent D'.
```

해지 메시지의 TTL 필드는 정보 제공용입니다. TTL\(TIMESTAMP와 함께\)이 취소가 이미 만료되었음을 나타내는 경우 POW 값이나 서명을 확인하지 않고 취소를 삭제할 수 있습니다. 철회의 실제 유효 기간은 POW 값의 앞에 오는 0을 검사하여 결정해야 합니다.\(MAY, MUST\)

철회 유효 기간은 \(D'-D+1\) \* EPOCH \* 1.1로 계산됩니다. 동기화되지 않은 클럭을 처리하기 위해 EPOCH가 10% 확장되었습니다. TIMESTAMP 위에 유효기간을 더하면 만료일이 됩니다. 현재 시간이 만료 날짜 이후인 경우 해지는 오래된 것으로 간주됩니다.

확인된 취소는 로컬에 저장되어야 합니다. 구현 시 오래된 취소를 삭제하고 언제든지 로컬 저장소에서 제거할 수 있습니다.\(MUST, MAY\)

구현 시 수신된 취소가 유효하고 오래되지 않은 경우 이를 브로드캐스트하는 것이 중요합니다. 계산된 유효 기간이 TTL 필드 값과 다른 경우, 취소 메시지를 전달할 때 계산된 값을 TTL 필드 값으로 사용해야 합니다. 시스템은 현재 시간에 동의하지 않을 수 있으므로 구현은 오래되었지만 유효한 취소를 사용할 수 있지만 이를 브로드캐스트해서는 안 됩니다. 전달된 오래된 철회는 수신자에 의해 폐기될 수 있습니다.\(MUST, SHOULD NOT, MAY\)

로컬에 저장된 모든 취소는 위임 기록 처리 중에 고려해야 합니다\(섹션 7.3.4 참조\).\(MUST\)

---
## **5.  Resource Records**

GNS 구현은 리소스 레코드에 대한 지속성 메커니즘\(예: 로컬 데이터베이스\)뿐만 아니라 로컬 영역을 생성하고 관리하기 위한 메커니즘을 제공해야 합니다. 영역 유형을 선택하고 영역 키 쌍을 생성하면 새 로컬 영역이 설정됩니다. 이 메커니즘이 구현되지 않으면 저장소에 영역을 게시할 수 없으며\(섹션 6 참조\) 이름 확인은 로컬이 아닌 시작 영역으로 제한됩니다\(섹션 7.1 참조\).\(SHOULD\)

GNS 리소스 레코드는 영역의 특정 레코드 데이터를 보유합니다. 리소스 레코드 형식은 그림 7에 나와 있습니다.

```text
   0     8     16    24    32    40    48    56
   +-----+-----+-----+-----+-----+-----+-----+-----+
   |                   EXPIRATION                  |
   +-----+-----+-----+-----+-----+-----+-----+-----+
   |    SIZE   |   FLAGS   |          TYPE         |
   +-----+-----+-----+-----+-----+-----+-----+-----+
   |                      DATA                     /
   /                                               /
   /                                               /

                 Figure 7: The Resource Record Wire Format
```

EXPIRATION: 레코드의 절대 64비트 만료 날짜를 나타냅니다. 네트워크 바이트 순서로 1970년 1월 1일 UTC 자정\(0시간\) 이후의 마이크로초 단위입니다.

SIZE: 네트워크 바이트 순서에 따라 DATA 필드의 16비트 크기\(바이트\)를 나타냅니다.

FLAGS: 리소스 레코드의 특수 속성을 나타내는 16비트 필드입니다. 다양한 비트의 의미는 아래에 정의되어 있습니다.

TYPE: 네트워크 바이트 순서의 32비트 리소스 레코드 유형입니다. 이 유형은 섹션 5에 정의된 GNS 리소스 레코드 중 하나, \[RFC1035\]에 정의된 DNS 레코드 유형 또는 보완적인 표준화된 DNS 리소스 레코드 유형 중 하나일 수 있습니다. 2^16 미만의 값은 IANA \[RFC6895\]에서 할당한 16비트 DNS 리소스 레코드 유형용으로 예약되어 있습니다. 2^16 이상의 값은 GANA "GNS 레코드 유형" 레지스트리\[GANA\]에 의해 할당됩니다.

DATA: 가변 길이 리소스 레코드 데이터 페이로드입니다. 콘텐츠는 리소스 레코드의 각 유형에 따라 정의됩니다.

FLAGS 필드는 리소스 레코드의 특수 속성을 나타내는 데 사용됩니다. 리소스 레코드를 생성하는 애플리케이션은 해당 플래그를 구체적으로 이해하고 설정하려는 경우가 아니면 FLAGS의 모든 비트를 0으로 설정해야 합니다. 추가 플래그는 향후 프로토콜 버전에서 정의될 수 있으므로 애플리케이션이나 구현이 인식하지 못하는 플래그를 발견하면 해당 플래그를 무시해야 합니다. 그러나 모든 구현은 아래에 정의된 SHADOW 및 CRITICAL 플래그를 이해해야 합니다. 아래에 지정된 플래그의 조합은 유효합니다. 그림 8은 리소스 레코드의 16비트 FLAGS 필드의 플래그 배포를 보여줍니다.\(MUST, MUST, MUST\)

```text
   0           13            14      15
   +--------...+-------------+-------+---------+
   | Reserved  |SUPPLEMENTAL |SHADOW |CRITICAL |
   +--------...+-------------+-------+---------+
```

- 그림 8: 리소스 레코드 플래그 와이어 형식

CRITICAL: 이 플래그가 설정되면 처리가 중요함을 나타냅니다. 레코드 유형을 지원하지 않거나 달리 레코드를 처리할 수 없는 구현은 해결 프로세스에서 레코드를 발견하면 해결을 중단해야 합니다\(MUST\).\(MUST\)

SHADOW: 이 플래그가 설정되면 이 레코드는 반드시 무시되어야 합니다.

- 동일한 레코드 유형의 모든\(다른\) 레코드가 만료되지 않은 경우 해결 프로그램. 영역 게시자가 레코드의 미래 값을 저장소에 넣을 수 있도록 하여 레코드가 변경될 때 우수한 성능을 촉진할 수 있도록 하는 데 사용됩니다. 이런 방식으로 미래 값이 전파될 수 있으며 전환이 활성화되기 전에 캐시될 수 있습니다.\(MUST\)

보충: 이것은 보충 기록입니다. 다른 기록과 함께 제공됩니다. 이 플래그는 이 레코드가 해당 이름으로 다른 레코드와 함께 명시적으로 관리되지는 않지만 애플리케이션에 유용할 수 있음을 나타냅니다.

---
### **5.1.  Zone Delegation Records**

이 섹션에서는 영역 위임 레코드 유형의 초기 세트를 정의합니다. 모든 구현은 여기에 정의된 모든 영역 유형을 지원해야 하며 GANA "GNS 레코드 유형" 레지스트리\(\[GANA\] 참조\)에 정의된 추가 위임 레코드를 원하는 수만큼 지원할 수 있습니다. 일부 영역 유형을 지원하지 않으면 해당 영역 유형이 발견될 경우 해결이 실패하게 됩니다. 일부 영역 위임 레코드 유형이 암호화되어 안전하지 않은 것으로 확인된 경우 이는 유효한 선택이 될 수 있습니다. 영역 위임 기록은 apex 레이블 아래에 저장되거나 게시되어서는 안 됩니다. 영역 위임 레코드 유형 값은 해당 ztype 값과 동일합니다. ztype은 위임되는 영역에 대한 암호화 기본 형식을 정의합니다. 영역 위임 레코드 페이로드에는 위임할 영역의 공개 키가 포함되어 있습니다. 영역 위임 레코드에는 CRITICAL 플래그가 설정되어 있어야 하며 레이블 아래의 유일한 비보조 레코드여야 합니다. 원활한 키 롤오버를 용이하게 하기 위해 SHADOW 플래그가 설정된 동일한 유형의 비활성 레코드가 있을 수 있습니다.\(SHOULD, MUST NOT, MUST, MAY\)

다음에서 "||" 두 바이트 문자열의 연결 연산자입니다. 알고리즘 사양은 GNS 레이블이나 상수 값과 같은 문자열을 사용합니다. 연결에 사용되거나 함수에 대한 입력으로 사용될 때 문자열의 0 종결자는 포함되어서는 안 됩니다.\(MUST NOT\)

---
#### **5.1.1.  PKEY**

GNS에서 "PKEY" 유형의 영역에 대한 레이블 위임은 PKEY 레코드를 통해 표시됩니다. PKEY DATA 입력 연결 형식은 그림 9에 나와 있습니다.

```text
   0     8     16    24    32    40    48    56
   +-----+-----+-----+-----+-----+-----+-----+-----+
   |                   PUBLIC KEY                  |
   |                                               |
   |                                               |
   |                                               |
   +-----+-----+-----+-----+-----+-----+-----+-----+

                       Figure 9: The PKEY Wire Format
```

공개 키: 256비트 Ed25519 공개 키입니다.

PKEY 영역의 경우 영역 키 자료는 ECDSA 방식\[RFC6979\]을 사용하여 Curve25519\[RFC7748\]\(이 곡선을 선택하는 이유는 섹션 9.3에서 찾을 수 있음\)의 뒤틀린 Edwards 표현의 곡선 매개변수를 사용하여 파생됩니다. PKEY 영역의 암호화 기본 요소에는 다음과 같은 명명 규칙이 사용됩니다.

d: 256비트 Ed25519 개인 키\(클램프된 개인 스칼라\).

zkey: d에 해당하는 Ed25519 공개 영역 키입니다.

p: \[RFC7748\]에 정의된 edwards25519의 소수, 즉 2^255 - 19.

G: 그룹 생성기\(X\(P\),Y\(P\)\). \[RFC7748\]에 정의된 대로 edwards25519의 X\(P\),Y\(P\)를 사용합니다.

L: \[RFC7748\]에 정의된 edwards25519의 소수 순서 하위 그룹의 순서입니다.

KeyGen\(\): \[RFC6979\]의 섹션 2.2에 정의된 개인 스칼라 d 및 곡선 점 zkey := d\*G\(여기서 G는 타원 곡선의 그룹 생성기\)의 생성은 KeyGen\(\) 함수를 나타냅니다.

PKEY의 영역 유형과 영역 키의 길이는 4 + 32바이트입니다. 이는 zTLD가 항상 단일 레이블에 적합하며 추가 변환이 필요하지 않음을 의미합니다. 레이블이 주어지면 ZKDF\(zkey, label\) 함수의 출력 zkey'는 PKEY 영역에 대해 다음과 같이 계산됩니다.

```text
   ZKDF(zkey, label):
     PRK_h := HKDF-Extract("key-derivation", zkey)
     h := HKDF-Expand(PRK_h, label || "gns", 512 / 8)
     zkey' := (h mod L) * zkey
     return zkey'
```

PKEY 암호 시스템은 \[RFC5869\]에 정의된 대로 HMAC 기반 키 파생 함수\(HKDF\)를 사용하며 추출 단계에는 SHA-512 \[RFC6234\]를, 확장 단계에는 SHA-256 \[RFC6234\]를 사용합니다. PRK\_h는 문자열 "key-derivation"을 솔트로 사용하고 영역 키를 초기 키 자료로 사용하는 HKDF를 사용하여 검색된 키 자료입니다. h는 512비트 HKDF 확장 결과이며 네트워크 바이트 순서로 해석되어야 합니다. 확장 정보 입력은 레이블과 문자열 "gns"를 연결한 것입니다. ZKDF\(\)에서 zkey와 h의 곱셈은 점 곱셈인 반면, 아래 SignDerived\(\)에서 d와 h의 곱셈은 스칼라 곱셈입니다.

PKEY 영역에 대한 Sign\(\) 및 verify\(\) 함수는 \[RFC6979\]에 지정된 대로 512비트 ECDSA 결정적 서명을 사용하여 구현됩니다. 파생 키에도 동일한 기능을 사용할 수 있습니다.

```text
   SignDerived(d, label, message):
     zkey := d * G
     PRK_h := HKDF-Extract("key-derivation", zkey)
     h := HKDF-Expand(PRK_h, label || "gns", 512 / 8)
     d' := (h * d) mod L
     return Sign(d', message)
```

다음이 성립하는 경우 파생 공개 키 zkey' := ZKDF\(zkey, label\)에 대한 서명이 유효합니다.

```text
   VerifyDerived(zkey', message, signature):
     return Verify(zkey', message, signature)
```

S-Encrypt\(\) 및 S-Decrypt\(\) 함수는 \[MODES\]\(CTR-AES256\)에 정의된 대로 카운터 모드에서 AES를 사용합니다.

```text
   S-Encrypt(zkey, label, expiration, plaintext):
     PRK_k := HKDF-Extract("gns-aes-ctx-key", zkey)
     PRK_n := HKDF-Extract("gns-aes-ctx-iv", zkey)
     K := HKDF-Expand(PRK_k, label, 256 / 8)
     NONCE := HKDF-Expand(PRK_n, label, 32 / 8)
     BLOCK_COUNTER := 0x0000000000000001
     IV := NONCE || expiration || BLOCK_COUNTER
     return CTR-AES256(K, IV, plaintext)

   S-Decrypt(zkey, label, expiration, ciphertext):
     PRK_k := HKDF-Extract("gns-aes-ctx-key", zkey)
     PRK_n := HKDF-Extract("gns-aes-ctx-iv", zkey)
     K := HKDF-Expand(PRK_k, label, 256 / 8)
     NONCE := HKDF-Expand(PRK_n, label, 32 / 8)
     BLOCK_COUNTER := 0x0000000000000001
     IV := NONCE || expiration || BLOCK_COUNTER
     return CTR-AES256(K, IV, ciphertext)
```

키 K와 카운터 초기화 벡터\(IV\)는 \[RFC5869\]에 정의된 HKDF를 사용하여 레코드 레이블과 영역 키 zkey에서 파생됩니다. 추출 단계에는 SHA-512 \[RFC6234\]가 사용되고 확장 단계에는 SHA-256 \[RFC6234\]가 사용됩니다. 출력 키 자료는 대칭 키의 경우 32바이트\(256비트\)이고 NONCE의 경우 4바이트\(32비트\)입니다. 대칭 키 K는 256비트 AES 키\[RFC3826\]입니다.

nonce는 \[RFC3686\]에 정의된 대로 64비트 IV 및 32비트 블록 카운터와 결합됩니다. 블록 카운터는 값 1로 시작하며 키 스트림의 후속 부분을 생성하기 위해 증가됩니다. 블록 카운터는 네트워크 바이트 순서의 32비트 정수 값입니다. S-Encrypt\(\) 및 S-Decrypt\(\) 함수에서 사용되는 카운터 IV의 형식은 그림 10에 나와 있습니다.

```text
   0     8     16    24    32
   +-----+-----+-----+-----+
   |         NONCE         |
   +-----+-----+-----+-----+
   |       EXPIRATION      |
   |                       |
   +-----+-----+-----+-----+
   |      BLOCK COUNTER    |
   +-----+-----+-----+-----+

     Figure 10: Structure of the Counter IV as Used in S-Encrypt() and
                                S-Decrypt()
```

---
#### **5.1.2.  EDKEY**

GNS에서 "EDKEY" 유형의 영역에 대한 레이블 위임은 EDKEY 레코드를 통해 표시됩니다. EDKEY DATA 입력 연결 형식은 그림 11에 나와 있습니다.

```text
   0     8     16    24    32    40    48    56
   +-----+-----+-----+-----+-----+-----+-----+-----+
   |                   PUBLIC KEY                  |
   |                                               |
   |                                               |
   |                                               |
   +-----+-----+-----+-----+-----+-----+-----+-----+

                   Figure 11: The EDKEY DATA Wire Format
```

공개 키: 256비트 EdDSA 영역 키입니다.

EDKEY 영역의 경우 영역 키 자료는 \[RFC8032\]에 지정된 대로 Ed25519 구성표\[ed25519\]를 사용하여 Curve25519\[RFC7748\]\(즉, Ed25519\)의 꼬인 Edwards 표현의 곡선 매개 변수를 사용하여 파생됩니다. EDKEY 영역의 암호화 기본 요소에는 다음 명명 규칙이 사용됩니다.

d: 256비트 EdDSA 개인 키입니다.

a: \[RFC8032\]에 정의된 SHA-512 해시 함수를 사용하여 d에서 파생된 정수입니다.

zkey: d에 해당하는 EdDSA 공개 키입니다. 이는 곡선 점 a\*G로 정의됩니다. 여기서 G는 \[RFC8032\]에 정의된 타원 곡선의 그룹 생성기입니다.

p: \[RFC8032\]에 정의된 edwards25519의 소수, 즉 2^255 - 19.

G: 그룹 생성기\(X\(P\),Y\(P\)\). \[RFC8032\]에 정의된 대로 edwards25519의 X\(P\),Y\(P\)를 사용합니다.

L: \[RFC8032\]에 정의된 edwards25519의 소수 순서 하위 그룹의 순서입니다.

KeyGen\(\): 개인 키 d 및 관련 공개 키 zkey := a\*G\(여기서 G는 타원 곡선의 그룹 생성기이고 a는 SHA-512 해시 함수를 사용하여 d에서 파생된 정수\)의 생성입니다. \[RFC8032\]의 5.1.5절에 정의된 KeyGen\(\) 함수를 나타낸다.

EDKEY의 영역 유형과 영역 키의 길이는 4 + 32바이트입니다. 이는 zTLD가 항상 단일 레이블에 적합하며 추가 변환이 필요하지 않음을 의미합니다.

"EDKEY" ZKDF 인스턴스화는 \[Tor224\]를 기반으로 합니다. 위에서 KeyGen\(\)에 대해 언급한 것처럼 a는 \[RFC8032\]의 섹션 5.1.5에 정의된 SHA-512 해시 함수를 사용하여 d에서 계산됩니다. 레이블이 주어지면 ZKDF 함수의 출력은 다음과 같이 계산됩니다.

ZKDF\(zkey, label\): /\* 블라인드 팩터 계산 \*/ PRK\_h := HKDF-Extract\("key-derivation", zkey\) h := HKDF-Expand\(PRK\_h, label || "gns", 512 / 8\) /\* h == h mod L인지 확인하세요. \*/ h := h mod L

```text
     zkey' := h * zkey
     return zkey'
```

구현자는 타이밍 공격으로부터 보호하기 위해 위의 구성에 대해 상수 시간 스칼라 곱셈을 사용해야 합니다. 그렇지 않고 공격자가 시스템이 게시 프로세스를 시작하는 시기를 예측할 수 있는 경우 타이밍 공격으로 개인 키 자료가 유출될 수 있습니다.\(SHOULD\)

EDKEY 암호 시스템은 추출 단계에 SHA-512 \[RFC6234\]를 사용하고 확장 단계에 HMAC-SHA-256 \[RFC6234\]를 사용하여 \[RFC5869\]에 정의된 HKDF를 사용합니다. PRK\_h는 문자열 "key-derivation"을 솔트로 사용하고 영역 키를 초기 키 자료로 사용하는 HKDF를 사용하여 검색된 키 자료입니다. 블라인드 팩터 h는 512비트 HKDF 확장 결과입니다. 확장 정보 입력은 레이블과 문자열 "gns"를 연결한 것입니다. HKDF의 결과는 네트워크 바이트 순서로 고정되고 해석되어야 합니다. a는 256비트 개인 키 d에 해당하는 256비트 정수입니다. zkey와 h의 곱셈은 점 곱셈입니다.

서명\(d, 메시지\) 및 확인\(zkey, 메시지, 서명\) 절차는 \[RFC8032\]에 정의된 대로 구현되어야 합니다.\(MUST\)

EDKEY 영역의 서명은 파생된 개인 스칼라 d'를 사용합니다. 이는 \[RFC8032\]를 준수하지 않습니다. 파생된 프라이빗 스칼라에 해당하는 프라이빗 키를 알 수 없으므로 \[RFC8032\]에 따른 서명 부분 R을 결정적으로 도출하는 것은 불가능합니다. 대신, 특정 메시지 및 개인 영역 키에 대해 서명은 다음과 같이 생성되어야 합니다. nonce는 개인 키 d 확장의 가장 높은 32바이트와 블라인드 인자 h로부터 계산됩니다. 그런 다음 nonce는 r에 대한 메시지와 함께 해시됩니다. 이러한 방식으로 전체 파생 경로가 서명의 R 값 계산에 포함되므로 두 개의 서로 다른 파생 경로 또는 메시지에 재사용되지 않습니다.\(MUST\)

SignDerived\(d, label, message\): /\* 키 확장 \*/ dh := SHA-512\(d\) /\* EdDSA 클램핑 \*/ a := dh\[0..31\] a\[0\] := a\[0\] & 248 a\[31\] := a\[31\] & 127 a\[31\] := a\[31\] | 64 /\* d에 해당하는 zkey를 계산합니다 \*/ zkey := a \* G

/\* 블라인드 인자 계산 \*/ PRK\_h := HKDF-Extract\("key-derivation", zkey\) h := HKDF-Expand\(PRK\_h, label || "gns", 512 / 8\) /\* h == h인지 확인 모드 L \*/ h := h 모드 L

```text
     d' := (h * a) mod L
     nonce := SHA-256(dh[32..63] || h)
     r := SHA-512(nonce || message)
     R := r * G
     S := r + SHA-512(R || zkey' || message) * d' mod L
     return (R,S)
```

다음이 성립하는 경우 파생된 공개 키 zkey' := ZKDF\(zkey, label\)에 대해 서명\(R,S\)이 유효합니다.

```text
   VerifyDerived(zkey', message, signature):
     (R,S) := signature
     return S * G == R + SHA-512(R, zkey', message) * zkey'
```

S-Encrypt\(\) 및 S-Decrypt\(\) 함수는 \[XSalsa20\]에 정의된 대로 XSalsa20을 사용하고 XSalsa20-Poly1305 암호화 함수를 사용합니다.

```text
   S-Encrypt(zkey, label, expiration, plaintext):
     PRK_k := HKDF-Extract("gns-xsalsa-ctx-key", zkey)
     PRK_n := HKDF-Extract("gns-xsalsa-ctx-iv", zkey)
     K := HKDF-Expand(PRK_k, label, 256 / 8)
     NONCE := HKDF-Expand(PRK_n, label, 128 / 8)
     IV := NONCE || expiration
     return XSalsa20-Poly1305(K, IV, plaintext)

   S-Decrypt(zkey, label, expiration, ciphertext):
     PRK_k := HKDF-Extract("gns-xsalsa-ctx-key", zkey)
     PRK_n := HKDF-Extract("gns-xsalsa-ctx-iv", zkey)
     K := HKDF-Expand(PRK_k, label, 256 / 8)
     NONCE := HKDF-Expand(PRK_n, label, 128 / 8)
     IV := NONCE || expiration
     return XSalsa20-Poly1305(K, IV, ciphertext)
```

XSalsa20-Poly1305 암호화 기능의 결과는 암호화된 암호문과 128비트 인증 태그입니다. 따라서 암호화된 데이터의 길이는 데이터 길이에 인증 태그의 16바이트를 더한 길이와 같습니다.

키 K와 카운터 IV는 \[RFC5869\]에 정의된 HKDF를 사용하여 레코드 레이블과 영역 키 zkey에서 파생됩니다. 추출 단계에는 SHA-512 \[RFC6234\]가 사용되고 확장 단계에는 SHA-256 \[RFC6234\]가 사용됩니다. 출력 키 자료는 대칭 키의 경우 32바이트\(256비트\)이고 NONCE의 경우 16바이트\(128비트\)입니다. 대칭 키 K는 256비트 XSalsa20 키\[XSalsa20\]입니다. 추가 인증 데이터\(AAD\)는 사용되지 않습니다.

nonce는 8바이트 IV와 결합됩니다. IV는 네트워크 바이트 순서로 나타낸 리소스 레코드 블록의 만료 시간입니다. 결과 카운터\(IV\) 와이어 형식은 그림 12에 나와 있습니다.

```text
   0     8     16    24    32    40    48    56
   +-----+-----+-----+-----+-----+-----+-----+-----+
   |                     NONCE                     |
   |                                               |
   +-----+-----+-----+-----+-----+-----+-----+-----+
   |                   EXPIRATION                  |
   +-----+-----+-----+-----+-----+-----+-----+-----+

             Figure 12: The Counter Block Initialization Vector
```

---
### **5.2.  Redirection Records**

리디렉션 레코드는 해결 방법을 리디렉션하는 데 사용됩니다. 모든 구현은 여기에 정의된 모든 리디렉션 레코드 유형을 지원해야 하며 GANA "GNS 레코드 유형" 레지스트리\[GANA\]에 정의된 추가 리디렉션 레코드를 원하는 수만큼 지원할 수 있습니다. 리디렉션 레코드에는 CRITICAL 플래그가 설정되어 있어야 합니다. 일부 레코드 유형을 지원하지 않으면 확인 실패가 발생할 수 있습니다. 일부 리디렉션 레코드 유형이 안전하지 않은 것으로 확인되었거나 애플리케이션이 복잡성이나 보안 등의 이유로 DNS로의 리디렉션을 지원하지 않는 이유가 있는 경우 이는 유효한 선택이 될 수 있습니다. 리디렉션 레코드는 apex 레이블 아래에 저장되거나 게시되어서는 안 됩니다.\(SHOULD, MUST, MUST NOT\)

---
#### **5.2.1.  REDIRECT**

REDIRECT 레코드는 DNS의 CNAME 레코드에 해당하는 GNS입니다. REDIRECT 레코드는 라벨 아래의 유일한 비보조 레코드여야 합니다. 리디렉션 대상의 원활한 변경을 용이하게 하기 위해 SHADOW 플래그가 설정된 동일한 유형의 비활성 레코드가 있을 수 있습니다. 다른 기록은 허용되지 않습니다. 이 기록 처리에 대한 자세한 내용은 섹션 7.3.1에 나와 있습니다. REDIRECT DATA 항목은 그림 13에 나와 있습니다.\(MUST, MAY\)

```text
   0     8     16    24    32    40    48    56
   +-----+-----+-----+-----+-----+-----+-----+-----+
   |                   REDIRECT NAME               |
   /                                               /
   /                                               /
   |                                               |
   +-----+-----+-----+-----+-----+-----+-----+-----+
```

- 그림 13: REDIRECT DATA 와이어 형식

REDIRECT NAME: 계속할 이름입니다. 이 값은 일반 이름이거나 상대 이름일 수 있습니다. 상대 GNS 이름은 가장 오른쪽 레이블로 확장 레이블\(U+002B\("+"\)\)로 표시됩니다. 문자열은 UTF-8로 인코딩되고 0으로 끝납니다.

---
#### **5.2.2.  GNS2DNS**

GNS2DNS 레코드는 확인을 DNS에 위임합니다. 리소스 레코드에는 확인자가 DNS에서 계속 사용할 DNS 이름과 DNS 서버가 포함되어 있습니다. 두 이름 모두 DNS 이름에 대해 \[RFC1034\]에 정의된 형식을 따릅니다. 라벨 아래에는 여러 개의 GNS2DNS 레코드가 있을 수 있습니다. 동일한 레이블 아래에 DNS 서버와의 연결을 보호하는 데 사용되는 DNSSEC DS 레코드 또는 기타 레코드가 있을 수도 있습니다. 리디렉션 대상의 원활한 변경을 촉진하기 위해 SHADOW 플래그가 설정된 동일한 유형의 비활성 레코드가 있을 수 있습니다. 동일한 레코드 세트에는 다른 비보조 레코드 유형이 허용되지 않습니다. GNS2DNS DATA 항목은 그림 14에 나와 있습니다.\(MAY, MAY, MAY\)

```text
   0     8     16    24    32    40    48    56
   +-----+-----+-----+-----+-----+-----+-----+-----+
   |                      NAME                     |
   /                                               /
   /                                               /
   |                                               |
   +-----+-----+-----+-----+-----+-----+-----+-----+
   |                 DNS SERVER NAME               |
   /                                               /
   /                                               /
   |                                               |
   +-----------------------------------------------+
```

- 그림 14: GNS2DNS 데이터 와이어 형식

NAME: DNS에서 계속 사용할 이름입니다. 값은 UTF-8로 인코딩되고 0으로 끝납니다.

DNS 서버 이름: 사용할 DNS 서버입니다. 이 값은 점으로 구분된 십진수 형식의 IPv4 주소, 콜론-16진수 형식의 IPv6 주소 또는 DNS 이름일 수 있습니다. 가장 오른쪽 레이블이 "+"로 끝나는 상대 GNS 이름일 수도 있습니다. 구현에서는 상대 GNS 이름을 확인하기 전에 해당 표기법에서 IP 주소에 대한 문자열을 구문적으로 확인해야 합니다. 세 가지 확인이 모두 실패하면 이름은 DNS 이름으로 처리되어야 합니다. 값은 UTF-8로 인코딩되고 0으로 끝납니다.\(MUST, MUST\)

참고: 애플리케이션이 DNS 요청의 GNS2DNS 레코드에서 얻은 DNS 이름을 사용하는 경우 먼저 IDNA 호환 표현\[RFC5890\]으로 변환해야 합니다.\(MUST\)

---
### **5.3.  Auxiliary Records**

이 섹션에서는 보조 GNS 레코드 유형의 초기 세트를 정의합니다. 모든 구현은 섹션 7.3에 따라 지정된 레코드 유형을 처리할 수 있어야 합니다\(SHOULD\).\(SHOULD\)

---
#### **5.3.1.  LEHO**

LEHO\(LEgacy HOstname\) 레코드는 레거시 호스트 이름에 대한 힌트를 제공하는 데 사용됩니다. 애플리케이션은 GNS를 사용하여 인터넷 서비스의 IPv4 또는 IPv6 주소를 조회할 수 있습니다. 그러나 이러한 서비스에 연결하려면 IP 주소와 포트에 대한 지식이 필요할 뿐만 아니라 전송 프로토콜을 통해 전송될 서비스의 정식 DNS 이름도 필요합니다. GNS에서 레거시 호스트 이름 레코드는 해당 서비스에 대한 연결을 설정하는 데 필요한 DNS 이름을 애플리케이션에 제공합니다. 가장 일반적인 사용 사례는 HTTP 가상 호스팅 및 TLS 서버 이름 표시 \[RFC6066\]입니다. 여기서 DNS 이름은 각각 HTTP "호스트" 헤더와 TLS 핸드셰이크에 제공되어야 합니다. 이러한 경우 GNS 이름을 사용하면 전역적으로 고유하지 않을 수 있으므로 작동하지 않을 수 있습니다. 게다가 고유성이 문제가 되지 않더라도 레거시 서비스는 GNS를 인식하지 못할 수도 있습니다.

LEHO 리소스 레코드는 IPv4 또는 IPv6 주소가 있는 A 또는 AAAA 리소스 레코드와 함께 발견될 것으로 예상됩니다. LEHO DATA 항목은 그림 15에 나와 있습니다.

```text
   0     8     16    24    32    40    48    56
   +-----+-----+-----+-----+-----+-----+-----+-----+
   |                 LEGACY HOSTNAME               |
   /                                               /
   /                                               /
   |                                               |
   +-----+-----+-----+-----+-----+-----+-----+-----+

                    Figure 15: The LEHO DATA Wire Format
```

LEGACY HOSTNAME: 레거시 호스트 이름을 나타내는 UTF-8 문자열\(0으로 끝나지 않음\)입니다.

참고: 애플리케이션이 HTTP 요청 헤더\(예: "Host" 헤더\)에서 LEHO 값을 사용하는 경우 IDNA 호환 표현\[RFC5890\]으로 변환해야 합니다.\(MUST\)

---
#### **5.3.2.  NICK**

닉네임 레코드는 영역 관리자가 영역을 참조할 때 사용하기를 선호하는 레이블을 게시하는 데 사용할 수 있습니다. 이는 이 영역 키가 포함된 위임 레코드\(섹션 5.1\)를 생성할 때 사용할 레이블과 관련하여 다른 영역에 대한 제안입니다. 이 기록은 정점 레이블 "@" 아래에만 로컬로 저장되어야 하지만 보충 기록으로 모든 레이블 아래의 기록 세트와 함께 반환될 수 있습니다. 섹션 7.3.5에서는 확인자가 보충 및 비보조 NICK 레코드를 처리하는 방법을 자세히 설명합니다. NICK DATA 항목은 그림 16에 나와 있습니다.\(SHOULD\)

```text
   0     8     16    24    32    40    48    56
   +-----+-----+-----+-----+-----+-----+-----+-----+
   |                  NICKNAME                     |
   /                                               /
   /                                               /
   |                                               |
   +-----+-----+-----+-----+-----+-----+-----+-----+

                    Figure 16: The NICK DATA Wire Format
```

NICKNAME: 영역의 기본 레이블을 나타내는 UTF-8 문자열\(0으로 끝나지 않음\)입니다. 이 문자열은 유효한 GNS 라벨이어야 합니다.\(MUST\)

---
#### **5.3.3.  BOX**

GNS 조회는 하나의 레코드 세트에 필요한 모든 유용한 정보를 반환할 것으로 예상됩니다. 이를 통해 불필요한 추가 조회를 방지하고 함께 속한 정보를 암호화 방식으로 연결하므로, 적대적인 스토리지 개체가 보안에 중요한 정보를 생략할 수 있는 부분적인 답변을 제공하는 것이 불가능해집니다.

이 일반 전략은 SRV 및 TLSA 레코드에 대해 DNS에서 사용하는 특수 레이블과 호환되지 않습니다. 따라서 GNS는 SRV 및 TLSA 레코드를 박스업하고 연결된 레이블의 레코드 세트에 포함시키기 위해 BOX 레코드 형식을 정의합니다. 예를 들어 "\_https.\_tcp.example.org"에 대한 TLSA 레코드는 서비스\(SVC\) 443\(https\), 프로토콜\(PROTO\) 6\(tcp\)을 사용하는 BOX 레코드로 "example.org" 레코드 세트에 저장됩니다. \), TYPE "TLSA"를 기록합니다. 참고로 \[RFC2782\]도 참조하세요. BOX DATA 항목은 그림 17에 나와 있습니다.

```text
   0     8     16    24    32    40    48    56
   +-----+-----+-----+-----+-----+-----+-----+-----+
   |   PROTO   |    SVC    |       TYPE            |
   +-----------+-----------------------------------+
   |                 RECORD DATA                   |
   /                                               /
   /                                               /
   |                                               |
   +-----+-----+-----+-----+-----+-----+-----+-----+

                    Figure 17: The BOX DATA Wire Format
```

PROTO: 네트워크 바이트 순서의 16비트 프로토콜 번호입니다. 2^8 미만의 값은 IANA \[RFC5237\]에서 할당한 8비트 인터넷 프로토콜 번호용으로 예약되어 있습니다\(예: TCP의 경우 6\). 2^8보다 큰 값은 GANA "GNUnet 오버레이 프로토콜" 레지스트리\[GANA\]에 의해 할당됩니다.

SVC: 네트워크 바이트 순서로 표시된 박스형 레코드의 16비트 서비스 값입니다. TCP, UDP의 경우 포트 번호입니다.

TYPE: 네트워크 바이트 순서로 표시된 박스형 레코드의 32비트 레코드 유형입니다.

RECORD DATA: 해당 TYPE에 대해 정의된 TYPE의 "DATA" 형식을 포함하는 가변 길이 필드입니다. 따라서 2^16 미만의 TYPE 값의 경우 형식은 DNS의 해당 레코드 유형의 바이너리 형식과 동일합니다.

---
## **6.  Record Encoding for Remote Storage**

512비트 키 아래에 블록을 저장하고 키에서 하나 이상의 블록을 검색할 수 있는 모든 API는 원격 저장소 구현에서 사용할 수 있습니다. 유용하고 정의된 영역 위임 레코드 인코딩을 지원할 수 있으려면 API가 176바이트 이상의 블록 저장을 허용해야 하며 1024바이트 이상의 블록 크기를 허용해야 합니다. 다음에서는 구현이 스토리지 외에 두 가지 절차를 실현한다고 가정합니다.\(MUST\)

```text
   PUT(key, block)
   GET(key) -> block
```

GNS 구현은 기본 원격 저장소의 속성 및 권장 사항에 따라 블록을 게시합니다. 여기에는 게시된 블록의 가용성을 보존하기 위한 주기적인 새로 고침 작업이 포함될 수 있습니다.

원격 저장소에서 개별 블록을 명시적으로 삭제하는 메커니즘은 없습니다. 그러나 블록에는 원격 저장소 구현이 블록 삭제 시기를 결정하도록 안내하는 EXPIRATION 필드가 포함되어 있습니다. 동일한 키에 대해 여러 블록이 주어지면 원격 저장소 구현은 가장 큰 EXPIRATION 값을 가진 블록을 보존하고 반환하도록 시도해야 합니다\(SHOULD\).\(SHOULD\)

동일한 레이블을 공유하는 동일한 영역의 모든 리소스 레코드는 그림 18에 설명된 것처럼 키 q 아래의 원격 저장소에 있는 단일 리소스 레코드 블록\(RRBLOCK\)에 암호화되어 함께 게시됩니다. GNS 구현은 만료된 리소스 레코드를 블록. 구현에서는 레코드 세트가 변경되어 영역 내용을 업데이트할 때 PUT 저장 절차를 사용해야 합니다. 구현에서는 블록에 있는 레코드의 최소 만료 시간이 증가하지 않는 경우에도 RRBLOCK의 EXPIRATION 필드가 모든 변경에 대해 엄격하게 단조롭게 증가하는지 확인해야 합니다.\(MUST NOT, MUST, MUST\)

```text
                               Local Host           |   Remote
                                                    |   Storage
                                                    |
                                                    |    +---------+
                                                    |   /         /|
                                                    |  +---------+ |
   +-----------+                                    |  |         | |
   |           |       +-----------+PUT(q, RRBLOCK) |  | Record  | |
   |    User   |       |   Zone    |----------------|->| Storage | |
   |           |       | Publisher |                |  |         |/
   +-----------+       +-----------+                |  +---------+
        |                     A                     |
        |                     | Zone records        |
        |                     | grouped by label    |
        |                     |                     |
        |                 +---------+               |
        |Create / Delete /    |    /|               |
        |and Update     +---------+ |               |
        |Local Zones    |         | |               |
        |               |  Local  | |               |
        +-------------->|  Zones  | |               |
                        |         |/                |
                        +---------+                 |

          Figure 18: Management and Publication of Local Zones in
                            Distributed Storage
```

스토리지 키 파생 및 레코드 블록 생성은 다음 섹션에 지정되어 있으며 그림 19에 설명되어 있습니다.

```text
   +----------+ +-------+ +------------+ +-------------+
   | Zone Key | | Label | | Record Set | | Private Key |
   +----------+ +-------+ +------------+ +-------------+
       |          |            |               |
       |          |            v               |
       |          |           +-----------+    |
       |          +---------->| S-Encrypt |    |
       +----------|---------->+-----------+    |
       |          |               |    |       |
       |          |               |    v       v
       |          |               |   +-------------+
       |          +---------------|-->| SignDerived |
       |          |               |   +-------------+
       |          |               |        |
       |          v               v        v
       |      +------+        +--------------+
       +----->| ZKDF |------->| Record Block |
              +------+        +--------------+
                 |
                 v
              +------+        +-------------+
              | Hash |------->| Storage Key |
              +------+        +-------------+
```

- 그림 19: 저장소 키 및 레코드 블록 생성 개요

---
### **6.1.  The Storage Key**

저장소 키는 영역 키와 포함된 레코드의 해당 레이블에서 파생됩니다. 유사하게 파생된 대칭 비밀 키 및 블라인드 영역 키와 결합된 영역 키와 레이블에 대한 필수 지식은 쿼리 프라이버시를 보장합니다\(\[RFC8324\], 섹션 3.5 참조\).

레이블이 주어지면 저장소 키 q는 다음과 같이 파생됩니다.

```text
   q := SHA-512(ZKDF(zkey, label))
```

label: 리소스 레코드가 있는 UTF-8 문자열입니다.

- 출판.

zkey: 영역 키입니다.

q: 리소스 레코드 블록이 게시되는 512비트 저장소 키입니다. 파생된 영역 키에 대한 SHA-512 해시\[RFC6234\]입니다.

---
### **6.2.  Plaintext Record Data (RDATA)**

영역의 GNS 레코드는 레이블별로 그룹화되어 동일한 레이블 아래의 모든 레코드가 저장소의 단일 블록으로 함께 게시됩니다. 이러한 그룹화된 기록 세트는 보충 기록과 짝을 이룰 수 있습니다.\(MAY\)

기록 데이터\(RDATA\)는 이러한 GNS 기록 그룹을 인코딩하는 데 사용되는 형식입니다. RDATA의 바이너리 형식은 그림 20에 나와 있습니다.

```text
   0     8     16    24    32    40    48    56
   +-----+-----+-----+-----+-----+-----+-----+-----+
   |                 EXPIRATION                    |
   +-----+-----+-----+-----+-----+-----+-----+-----+
   |    SIZE   |    FLAGS  |        TYPE           |
   +-----+-----+-----+-----+-----+-----+-----+-----+
   |                      DATA                     /
   /                                               /
   /                                               /
   +-----+-----+-----+-----+-----+-----+-----+-----+
   |                   EXPIRATION                  |
   +-----+-----+-----+-----+-----+-----+-----+-----+
   |    SIZE   |    FLAGS  |        TYPE           |
   +-----+-----+-----+-----+-----+-----+-----+-----+
   |                     DATA                      /
   /                                               /
   +-----+-----+-----+-----+-----+-----+-----+-----+
   |                     PADDING                   /
   /                                               /
   +-----+-----+-----+-----+-----+-----+-----+-----+

                      Figure 20: The RDATA Wire Format
```

만료, 크기, 유형, 플래그 및 데이터: 이러한 필드에 대한 정의는 섹션 5의 그림 7 아래에 제공됩니다.

PADDING: 레코드를 RDATA로 직렬화할 때 GNS 구현은 이 필드를 사용하여 RDATA의 크기가 2의 거듭제곱인지 확인해야 합니다. 필드는 0으로 설정되어야 하며 수신 시 무시되어야 합니다. 특별한 예외로, 영역 위임 레코드 유형만 있는 레코드 세트는 패딩되지 않습니다.\(MUST, MUST\)

---
### **6.3.  The Resource Record Block**

RDATA에 그룹화된 리소스 레코드는 리소스 레코드가 속한 영역의 영역 유형으로 정의되고 원격 저장을 위한 리소스 레코드 블록\(RRBLOCK\)에 메타데이터가 접두사로 정의된 S-Encrypt\(\) 함수를 사용하여 암호화됩니다. GNS RRBLOCK 와이어 형식은 그림 21에 나와 있습니다.

```text
   0     8     16    24    32    40    48    56
   +-----+-----+-----+-----+-----+-----+-----+-----+
   |          SIZE         |    ZONE TYPE          |
   +-----+-----+-----+-----+-----+-----+-----+-----+
   |                  ZONE KEY                     /
   /                  (BLINDED)                    /
   |                                               |
   +-----+-----+-----+-----+-----+-----+-----+-----+
   |                   SIGNATURE                   |
   /                                               /
   /                                               /
   |                                               |
   +-----+-----+-----+-----+-----+-----+-----+-----+
   |                   EXPIRATION                  |
   +-----+-----+-----+-----+-----+-----+-----+-----+
   |                    BDATA                      |
   /                                               /
   /                                               /
   +-----+-----+-----+-----+-----+-----+-----+-----+
```

- 그림 21: RRBLOCK 와이어 형식

SIZE: 네트워크 바이트 순서에 따른 블록 길이\(바이트\)를 포함하는 32비트 값입니다. 메시지 형식이 32비트 값을 사용함에도 불구하고 구현에서는 이론적 블록 크기 제한인 4GB보다 훨씬 낮은 특정 크기를 초과하는 블록 게시를 거부할 수 있습니다.\(MAY\)

ZONE TYPE: 네트워크 바이트 순서의 32비트 ztype입니다.

ZONE KEY \(BLINDED\): SIGNATURE를 확인하는 데 사용되는 블라인드 영역 키 "ZKDF\(zkey, label\)"입니다. 블라인드 공개 키의 길이와 형식은 ztype에 따라 다릅니다.

SIGNATURE: 서명은 그림 22에 표시된 것처럼 EXPIRATION 및 BDATA 필드에 대해 계산됩니다. 서명의 길이와 형식은 ztype에 따라 다릅니다. 서명은 영역 암호화 시스템의 SignDerived\(\) 함수를 사용하여 생성됩니다\(섹션 4 참조\).

EXPIRATION: RRBLOCK이 만료되는 시기를 지정하고 암호화된 블록은 오래되었을 가능성이 있으므로 저장소와 캐시에서 제거해야 합니다. 그러나 애플리케이션은 만료될 때까지 만료되지 않은 개인 기록을 계속 사용할 수 있습니다. RRBLOCK 만료 값은 먼저 RRBLOCK에 있는 각 레코드 유형에 대해 섀도우 레코드를 포함하여 해당 유형의 모든 레코드의 최대 만료 시간을 결정하여 계산되어야 합니다. 그런 다음 이러한 모든 만료 시간의 최소값이 사용됩니다. 그러면 최종 만료 시간은 \(1\) 동일한 스토리지 키에 대한 이전 RRBLOCK의 이전 EXPIRATION 값에 1\(있는 경우\)을 더한 값과 \(2\) 포함된 레코드 유형 전체에 걸쳐 계산된 최소 만료 시간 중 더 큰 값입니다. 이는 엄격한 단조성을 보장합니다\(섹션 9.3 참조\). 이는 네트워크 바이트 순서로 1970년 1월 1일 UTC 자정\(0시간\) 이후 마이크로초 단위의 64비트 절대 날짜입니다.\(SHOULD, MAY, MUST\)

BDATA: 영역 키, 레이블 및 만료 시간을 추가 입력으로 사용하여 S-Encrypt\(\)를 사용하여 계산된 암호화된 RDATA입니다. 최종 크기와 내용은 ztype의 S-Encrypt\(\) 함수에 의해 결정됩니다.

공개 키에 대한 서명은 개념상 EXPIRATION 및 BDATA 필드 앞에 붙는 32비트 의사 헤더를 포함합니다. 와이어 형식은 그림 22에 나와 있습니다.

```text
   0     8     16    24    32    40    48    56
   +-----+-----+-----+-----+-----+-----+-----+-----+
   |         SIZE          |       PURPOSE (0x0F)  |
   +-----+-----+-----+-----+-----+-----+-----+-----+
   |                   EXPIRATION                  |
   +-----+-----+-----+-----+-----+-----+-----+-----+
   |                    BDATA                      |
   /                                               /
   /                                               /
   +-----+-----+-----+-----+-----+-----+-----+-----+

     Figure 22: The Wire Format Used for Creating the Signature of the
                                  RRBLOCK
```

SIZE: 네트워크 바이트 순서에 따라 서명된 데이터의 길이\(바이트\)를 포함하는 32비트 값입니다.

목적: 네트워크 바이트 순서의 32비트 서명 목적 플래그입니다. 이 필드의 값은 15여야 합니다. 이는 가능한 향후 확장을 포함할 수 있는 프로토콜의 다른 부분에서 재사용될 수 없도록 서명이 생성되는 컨텍스트를 정의합니다. 이 필드의 값은 GANA "GNUnet 서명 목적" 레지스트리\[GANA\]의 항목에 해당합니다.\(MUST\)

EXPIRATION: 위의 RRBLOCK 메시지에 정의된 필드입니다.

BDATA: 위의 RRBLOCK 메시지에 정의된 필드입니다.

---
## **7.  Name Resolution**

GNS의 이름은 레코드 저장소를 재귀적으로 쿼리하여 확인됩니다. 이 맥락에서 재귀적이란 해석기가 쿼리에 대한 중간 결과를 애플리케이션에 제공하지 않는다는 것을 의미합니다. 대신, 요청된 리소스 레코드 또는 확인이 실패할 경우 오류 메시지로 확인 요청에 응답해야 합니다\(MUST\). 그림 23은 애플리케이션이 GNS 이름 조회를 요청하는 방법을 보여줍니다\(1\). 애플리케이션은 리졸버에 원하는 레코드 유형을 제공할 수 있습니다. 이어서 시작 영역이 결정되고\(2\) 재귀적 해결 프로세스가 시작됩니다. 여기서는 원하는 레코드 유형이 처리를 안내하는 데 사용됩니다. 예를 들어 영역 위임 레코드 유형이 요청된 경우 원하는 레코드가 이미 발견되었으므로 해당 영역의 Apex 레이블 확인을 건너뛰어야 합니다. 해결 프로세스가 시작되는 방법과 해결의 각 반복 결과\(3a,3b\)가 처리되는 방법에 대한 자세한 내용은 아래 섹션에 제공됩니다. 조회 결과는 결국 애플리케이션에 반환됩니다\(4\). 구현은 원하는 레코드 유형에 따라 반환된 리소스 레코드 세트를 필터링해서는 안 됩니다. 레코드 세트 필터링은 일반적으로 애플리케이션에 의해 수행됩니다.\(MUST, MAY, MUST NOT\)

```text
                              Local Host             |   Remote
                                                     |   Storage
                                                     |
                                                     |    +---------+
                                                     |   /         /|
                                                     |  +---------+ |
   +-----------+ (1) Name +----------+               |  |         | |
   |           | Lookup   |          | (3a) GET(q)   |  | Record  | |
   |Application|----------| Resolver |---------------|->| Storage | |
   |           |<---------|          |<--------------|--|         |/
   +-----------+ (4)      +----------+ (3b) RRBLOCK  |  +---------+
                 Records     A                       |
                             |                       |
        (2) Determination of |                       |
            Start Zone       |                       |
                             |                       |
                          +---------+                |
                         /   |     /|                |
                        +---------+ |                |
                        |         | |                |
                        |  Start  | |                |
                        |  Zones  | |                |
                        |         |/                 |
                        +---------+                  |

              Figure 23: The Recursive GNS Resolution Process
```

---
### **7.1.  Start Zones**

GNS 이름 확인은 시작 영역 접미사를 식별하는 것부터 시작됩니다. 시작 영역 접미사가 식별되면 이름의 나머지 부분에 대한 재귀적 확인이 시작됩니다\(섹션 7.2 참조\). 시작 영역 접미사에는 zTLD와 로컬 접미사-영역 매핑의 두 가지 유형이 있습니다. 사용 가능한 접미사-영역 매핑 선택은 로컬 시스템 관리자나 사용자의 단독 재량에 달려 있습니다. 이 속성은 중앙에서 제어되는 루트가 있는 단일 계층의 문제와 DNS에서 루트 서버의 배포 및 관리와 관련된 문제를 해결합니다\(각각 \[RFC8324\]의 섹션 3.12 및 3.10 참조\).

zTLD로 끝나는 이름의 경우 시작 영역은 확인할 이름의 접미사에 명시적으로 제공됩니다. zTLD를 사용하여 이름의 고유성을 보장하려면 모든 구현에서 지정된 영역을 시작 영역으로 사용해야 합니다. 구현에서는 먼저 지정된 이름의 가장 오른쪽 레이블을 zTLD의 시작으로 해석해야 합니다\(섹션 4.1 참조\). 가장 오른쪽 레이블을 \(부분적으로\) 디코딩할 수 없거나 지원되는 ztype을 나타내지 않는 경우 이름은 일반 이름으로 처리되며 시작 영역 검색은 계속해서 로컬 접미사-영역 매핑을 찾아야 합니다. 가장 오른쪽 레이블에서 유효한 ztype을 찾을 수 있는 경우 구현에서는 섹션 4.1에 따라 시작 영역 키를 검색하기 위해 zTLD를 합성하고 디코딩해야 합니다. zTLD를 합성하거나 디코딩할 수 없는 경우 이름 확인이 실패하고 오류가 애플리케이션에 반환됩니다. 그렇지 않으면 구역 키를 시작 구역으로 사용해야 합니다.\(MUST, MUST, MUST, MUST, MUST\)

이름 예: www.example.<zTLD\> =\> 시작 영역: ztype 유형의 zkey =\> 시작 영역에서 확인할 이름: www.example

zTLD로 끝나지 않는 이름의 경우 확인자는 로컬 접미사-영역 매핑을 통해 시작 영역을 결정해야 합니다. 접미사-영역 매핑은 사용자나 시스템 관리자가 로컬 구성 파일이나 데이터베이스를 통해 구성할 수 있어야 합니다. 접미사는 라벨 구분 기호로 연결된 여러 GNS 라벨로 구성될 수 있습니다. 여러 접미사가 확인할 이름과 일치하는 경우 가장 긴 일치 접미사를 사용해야 합니다. 두 결과의 접미사 길이는 동일하면 안 됩니다. 이는 구성이 잘못되었음을 나타내며 구현 시 오류를 반환해야 합니다. 다음은 시작 영역의 비표준적인 매핑 예입니다.\(MUST, MUST, MAY, MUST, MUST NOT, MUST\)

이름 예: www.example.xyz.gns.alt 로컬 접미사 매핑: xyz.gns.alt = zTLD0 := Base32GNS\(ztype0||zkey0\) example.xyz.gns.alt = zTLD1 := Base32GNS\(ztype1||zkey1\) example.com.gns.alt = zTLD2 := Base32GNS\(ztype2||zkey2\) ... =\> 시작 영역: zkey1 =\> 시작 영역에서 확인할 이름: www

특정 애플리케이션에 다른 프로세스가 필요한 경우 위에 제공된 프로세스는 다른 메커니즘으로 보완될 수 있습니다. 시작 영역을 식별할 수 없는 경우 해결이 실패해야 하며 오류가 애플리케이션에 반환되어야 합니다.\(MAY, MUST\)

---
### **7.2.  Recursion**

재귀적 이름 확인의 각 단계에는 신뢰할 수 있는 영역 zkey와 확인할 이름이 있습니다. 이름은 비어 있을 수 있습니다. 이름이 비어 있으면 정점 레이블 "@"로 해석됩니다. 처음에 권한 영역은 시작 영역입니다.\(MAY\)

여기에서 다음 단계가 순서대로 재귀적으로 실행됩니다.

1. 조회하려는 이름에서 가장 오른쪽 라벨을 추출합니다.

2. 섹션 6.1에 정의된 대로 레이블과 zkey를 사용하여 q를 계산합니다.

3. 스토리지 쿼리 GET\(q\)를 수행하여 RRBLOCK을 검색합니다.

4. \(a\) 블록이 만료되지 않았는지, \(b\) RRBLOCK에서 파생된 권한 있는 영역 키 zkey'의 SHA-512 해시가 쿼리 q와 일치하는지, \(c\) 서명이 유효한지 확인합니다. 이러한 테스트 중 하나라도 실패하면 RRBLOCK을 무시해야 하며, 해당하는 경우 저장소 조회 GET\(q\)는 계속해서 다른 RRBLOCK을 찾아야 합니다.\(MUST\)

5. 영역 유형에 정의된 대로 S-Decrypt\(\)를 사용하여 RRBLOCK에 포함된 BDATA를 해독하여 RDATA를 얻습니다. 이는 섹션 6.3에 설명된 프로세스를 효과적으로 반전시킵니다.

올바른 형식의 블록이 해독되면 RDATA의 레코드는 레코드 처리를 받게 됩니다.

---
### **7.3.  Record Processing**

기록 처리에서는 획득된 유효한 기록만 고려됩니다. 유효성을 기준으로 레코드를 필터링하려면 해석기는 최소한 해당 레코드의 만료 시간과 FLAGS 필드를 확인해야 합니다. 특히 해석기는 만료된 레코드를 무시해야 합니다\(MUST\). 또한 SHADOW 및 SUPPLEMENTAL 플래그는 레코드를 고려에서 제외할 수도 있습니다. 확인자가 CRITICAL 플래그가 설정된 레코드를 발견하고 레코드 유형을 지원하지 않는 경우 확인을 중단해야 하며 오류를 반환해야 합니다. 중요한 기록을 처리할 수 없음을 나타내는 정보는 오류 설명에 반환되어야 합니다. 구현 시 실패 이유를 반환하지 않고 사용자의 문제 해결을 복잡하게 만들 수도 있습니다.\(MUST, MUST, MUST, SHOULD, MAY\)

다음 단계는 확인되는 이름의 컨텍스트에 따라 다릅니다.

사례 1: 필터링된 레코드 세트가 단일 REDIRECT 레코드로 구성된 경우 이름의 나머지 부분이 REDIRECT DATA 앞에 추가되고 결과 이름에서 재귀가 다시 시작됩니다. 자세한 내용은 섹션 7.3.1에 나와 있습니다.

사례 2: 필터링된 레코드 세트가 하나 이상의 GNS2DNS 레코드로만 구성된 경우 DNS를 통해 확인이 계속됩니다. 자세한 내용은 섹션 7.3.2에 나와 있습니다.

사례 3: 해결될 이름의 나머지 부분이 "\_SERVICE.\_PROTO" 형식이고 레코드 세트에 일치하는 BOX 레코드가 하나 이상 포함되어 있는 경우 BOX 레코드의 레코드가 최종 결과이며 설명된 대로 재귀가 종료됩니다. 섹션 7.3.3.

사례 4: 현재 레코드 세트가 단일 위임 레코드로 구성된 경우 이름의 나머지 부분에 대한 확인은 섹션 7.3.4에 설명된 대로 대상 영역에 위임됩니다.

사례 5: 확인할 이름의 나머지 부분이 비어 있으면 레코드 세트가 최종 결과입니다. NICK 레코드가 최종 결과 세트에 있는 경우 먼저 섹션 7.3.5에 따라 처리되어야 합니다. 그렇지 않으면 레코드 결과 집합이 최종 결과로 직접 반환됩니다.\(MUST\)

마지막으로, 위의 경우 중 어느 것도 적용 가능하지 않으면 확인이 실패하고 확인자는 빈 레코드 세트를 반환해야 합니다.\(MUST\)

---
#### **7.3.1.  REDIRECT**

나머지 이름이 비어 있고 원하는 레코드 유형이 REDIRECT인 경우 해결은 REDIRECT 레코드로 끝납니다. REDIRECT NAME의 가장 오른쪽 레이블이 확장 레이블\(U+002B \("+"\)\)인 경우 현재 영역의 새 이름을 사용하여 GNS에서 확인이 계속됩니다. 그렇지 않으면 결과 이름은 기본 운영 체제 이름 확인 프로세스를 통해 확인됩니다. 그러면 시스템 구성에 따라 GNS 이름 확인 프로세스가 트리거될 수 있습니다. DNS에서 확인이 계속되는 경우 이름은 먼저 IDNA 호환 표현\[RFC5890\]으로 변환되어야 합니다.\(MUST\)

무한 루프를 방지하기 위해 리졸버는 루프 감지를 구현하거나 재귀적 해결 단계 수를 제한해야 합니다. 루프 감지는 GNS에서 발견된 REDIRECT가 기본 운영 체제 이름 확인 프로세스를 통해 후속 GNS 조회를 트리거하는 경우에도 효과적이어야 합니다.\(MUST, MUST\)

---
#### **7.3.2.  GNS2DNS**

다음 조건이 모두 충족되면 확인자가 GNS2DNS 레코드를 반환합니다.

```text
   1.  The resolver encounters one or more GNS2DNS records;
```

2. 나머지 이름은 비어 있습니다. 그리고

3. 원하는 레코드 유형은 GNS2DNS입니다.

그렇지 않으면 확인자가 먼저 지정된 DNS 이름 서버의 IP 주소를 확인해야 합니다. DNS 이름은 DNS에서 확인하기 위해 IDNA 호환 표현\[RFC5890\]으로 변환되어야 합니다. GNS2DNS 레코드에는 숫자 IPv4 또는 IPv6 주소가 포함될 수 있으므로 확인자가 이 단계를 건너뛸 수 있습니다. DNS 서버 이름 자체는 GNS 또는 DNS의 이름일 수 있습니다. DNS 서버 이름의 가장 오른쪽 레이블이 확장 레이블\(U+002B \("+"\)\)인 경우 이름의 나머지 부분은 GNS2DNS 레코드의 영역을 기준으로 해석됩니다. DNS 서버 이름이 영역 키의 레이블 표현으로 끝나는 경우 DNS 서버 이름은 GNS 영역 zkey에 대해 확인됩니다.\(MUST, MAY\)

여러 개의 GNS2DNS 레코드가 동일한 레이블 아래에 저장될 수 있으며, 이 경우 확인자는 모든 레코드를 시도해야 합니다. 리졸버는 순서에 상관없이 또는 병렬로 시도할 수도 있습니다. 여러 GNS2DNS 레코드가 있는 경우 DNS 이름은 모두 동일해야 합니다. 그렇지 않으면 확인자가 어떤 이름을 따라야 하는지 명확하지 않습니다. 다른 DNS 이름이 존재하는 경우 확인이 실패하고 적절한 오류가 애플리케이션에 반환되어야 합니다.\(MUST, MAY, MUST, SHOULD\)

DNSSEC DS 레코드 또는 레이블 아래에 저장된 DNS 서버와의 연결을 보호하는 데 사용되는 다른 레코드가 있는 경우 DNS 확인자는 이를 사용하여 DNS 서버와의 연결을 보호해야 합니다.\(SHOULD\)

DNS 서버의 IP 주소가 결정되면 GNS2DNS 레코드의 DNS 이름이 확인될 이름의 나머지 부분에 추가되고 DNS 이름 서버를 쿼리하여 확인됩니다. DNS에서 확인하려면 합성된 이름을 IDNA 호환 표현\[RFC5890\]으로 변환해야 합니다. 그러한 변환이 가능하지 않으면 해결이 중단되어야 하며 오류가 반환되어야 합니다. 중요한 기록을 처리할 수 없음을 나타내는 정보는 오류 설명에 반환되어야 합니다. 구현 시 실패 이유를 반환하지 않고 사용자의 문제 해결을 복잡하게 만들 수도 있습니다.\(MUST, SHOULD, MAY\)

지정된 DNS 서버는 권한 있는 DNS 서버일 가능성이 있으므로 GNS 확인자는 재귀적 DNS 확인을 지원해야 하며 이를 권한 있는 DNS 서버에 위임해서는 안 됩니다. 첫 번째 성공적인 재귀 이름 확인 결과가 애플리케이션에 반환됩니다. 또한 확인자는 쿼리된 DNS 이름을 상대 만료 시간이 1시간인 보충 LEHO 레코드\(섹션 5.3.1 참조\)로 반환해야 합니다.\(MUST NOT, SHOULD\)

GNS2DNS 레코드를 통해 GNS에서 DNS로 전환되면 "되돌릴" 수 없습니다. DNS 이름의 \(재귀적일 수 있는\) 확인은 GNS에 다시 위임해서는 안 되며 DNS 사양만 따라야 합니다. 예를 들어, DNS CNAME 레코드에 포함된 이름은 DNS와 GNS를 모두 GNS 이름으로 지원하는 확인자에 의해 해석되어서는 안 됩니다.\(MUST NOT, MUST NOT\)

GNS 확인자는 정보 유출을 방지하고 모든 이름 확인에 대해 일관된 보안 프로필을 제공하기 위해 DNS 처리를 비활성화하는 구성 옵션을 제공해야 합니다\(SHOULD\). 이러한 확인자는 재귀 중에 GNS2DNS 레코드를 발견하면 빈 레코드 세트를 반환합니다. 그러나 apex 레이블에 대한 레코드 세트에서 GNS2DNS 레코드가 발견되고 GNS2DNS 레코드가 애플리케이션에 의해 명시적으로 요청되는 경우 GNS 확인자 구성에 의해 DNS 지원이 비활성화된 경우에도 해당 레코드는 계속 반환되어야 합니다.\(SHOULD, MUST\)

---
#### **7.3.3.  BOX**

BOX 레코드가 수신되면 GNS 해석기는 해석할 이름이 "\_SERVICE.\_PROTO"로 계속되는 경우 이를 언박싱해야 합니다. 그렇지 않으면 BOX 레코드는 그대로 유지됩니다. 이렇게 하면 TLSA\(및 SRV\) 레코드는 별도의 네트워크 요청이 필요하지 않으며 TLSA 레코드는 해당 주소 레코드와 분리될 수 없게 됩니다.

---
#### **7.3.4.  Zone Delegation Records**

확인자가 지원되는 영역 위임 레코드 유형\(예: PKEY 또는 EDKEY\)의 레코드를 발견하고 이름의 나머지 부분이 비어 있지 않은 경우 위임 레코드에 지정된 GNS 영역에 있는 이름의 나머지 부분을 사용하여 확인이 반복적으로 계속됩니다.

확인자가 새로운 GNS 영역을 발견할 때마다 로컬 취소 목록\(섹션 4.2 참조\)을 확인하여 해당 영역 키가 취소되었는지 확인해야 합니다. 영역 키가 취소된 경우 빈 결과 집합으로 해결이 실패해야 합니다.\(MUST, MUST\)

구현 시 단일 레이블 아래에 여러 개의 서로 다른 영역 위임을 허용해서는 안 됩니다\(일부가 섀도우 레코드인 경우 제외\). 구현은 ztype의 모든 하위 집합을 지원할 수 있습니다\(MAY\). 구현은 정점 레이블\("@"\) 아래에 저장된 영역 위임 레코드를 처리해서는 안 됩니다. apex 레이블 아래에서 영역 위임 레코드가 발견되면 해결이 실패하고 오류가 반환되어야 합니다. 구현 시 실패 이유를 반환하지 않고 사용자의 문제 해결 정보에만 영향을 미치도록 선택할 수 있습니다.\(MUST NOT, MAY, MUST NOT, MUST, MAY\)

확인할 이름의 나머지 부분이 비어 있고 단일 위임 레코드만 포함된 레코드 세트가 수신된 경우 레코드 값을 권한 영역으로, 정점 레이블 "@"을 나머지 이름으로 사용하여 재귀가 계속됩니다. 예외는 애플리케이션에서 지정한 원하는 레코드 유형이 ztype과 동일한 경우이며, 이 경우 위임 레코드가 반환됩니다.

---
#### **7.3.5.  NICK**

NICK 레코드는 문제의 레코드 세트가 애플리케이션에 반환되는 최종 결과인 경우에만 재귀 해석기와 관련이 있습니다. 발견된 NICK 기록은 보충적이거나\(섹션 5 참조\) 보충적이지 않을 수 있습니다. NICK 레코드가 보충 레코드인 경우 확인자는 비보조 레코드 중 하나가 쿼리된 레코드 유형과 일치하는 경우에만 레코드 세트를 반환합니다. 하나의 기록 세트에 보충 및 비보충 NICK 기록이 모두 포함될 수 있습니다.

보충 NICK 레코드와 비보조 NICK 레코드를 구별하면 애플리케이션이 해당 레코드를 권한 있는 영역과 일치시킬 수 있습니다. 다음 예를 고려하십시오.

```text
   Query: alice.example.gns.alt (type=A)
   Result:
   A: 192.0.2.1
   NICK: eve (non-supplemental)
```

이 예에서 반환된 NICK 레코드는 보충적이지 않습니다. 애플리케이션의 경우 이는 NICK가 "alice.example.gns.alt" 영역에 속하고 A 레코드와 함께 정점 레이블 아래에 게시됨을 의미합니다. NICK 레코드는 다음과 같이 해석됩니다. "alice.example.gns.alt"에 의해 정의된 영역은 "eve"로 참조되기를 원합니다. 이와 대조적으로 다음을 고려하십시오.

```text
   Query: alice.example.gns.alt (type=AAAA)
   Result:
   AAAA: 2001:db8::1
   NICK: john (supplemental)
```

이 경우 NICK 레코드는 보충으로 표시됩니다. 이는 NICK 레코드가 "example.gns.alt" 영역에 속하고 AAAA 레코드와 함께 "alice" 레이블 아래에 게시된다는 의미입니다. 여기서 NICK 레코드는 다음과 같이 해석되어야 합니다. "example.gns.alt"에 의해 정의된 영역은 "john"으로 참조되기를 원합니다. 이러한 구별은 보충 자료로 출판된 다른 기록에 유용할 가능성이 높습니다.

---
## **8.  Internationalization and Character Encoding**

GNS의 모든 이름은 UTF-8 \[RFC3629\]로 인코딩됩니다. 라벨은 정규화 형식 C\(NFC\) \[Unicode-UAX15\]를 사용하여 정규화되어야 합니다. 여기에는 IDNA 사양을 통해 국제화되는 CNAME 레코드 데이터와 같은 DNS 레코드에 있는 DNS 이름이 포함되지 않습니다. \[RFC5890\]을 참조하세요.\(MUST\)

---
## **9.  Security and Privacy Considerations**
---
### **9.1.  Availability**

절대 만료 시간 이후에도 레코드의 가용성을 보장하기 위해 구현에서는 레코드의 상대적 만료 시간 값을 로컬로 정의하도록 허용할 수 있습니다\(MAY\). 그런 다음 구현에 따라 업데이트된 절대 만료 시간을 사용하여 레코드를 반복적으로 게시할 수 있습니다.\(MAY\)

구현을 통해 사용자는 저장소에 게시되지 않은 영역에서 개인 기록을 관리할 수 있습니다. 개인 기록은 로컬 영역에서 레이블을 확인할 때 일반 기록과 동일하게 처리되지만 해당 데이터는 로컬이 아닌 사용자가 전혀 사용할 수 없습니다.\(MAY\)

---
### **9.2.  Agility**

암호화 시스템의 보안은 선택한 암호화 알고리즘의 강도와 해당 알고리즘과 함께 사용되는 키의 강도에 따라 달라집니다. 또한 이 보안은 전체 시스템의 보안을 우회할 수 있는 비암호화 방법이 없도록 시스템에서 사용하는 프로토콜 엔지니어링에 따라 달라집니다. 이것이 바로 GNS 영역을 관리하는 애플리케이션 개발자가 소프트웨어 출시 시 안전하다고 간주되는 기본 ztype을 선택해야 하는 이유입니다. 암호화를 이해할 것으로 예상되지 않는 최종 사용자를 대상으로 하는 애플리케이션의 경우 애플리케이션 개발자는 새 영역의 ztype 선택을 최종 사용자에게 맡겨서는 안 됩니다.\(SHOULD, MUST NOT\)

이 문서는 GNS에 사용되는 암호화 알고리즘 선택에 관한 것입니다. 이 문서에서 확인된 알고리즘은 현재 암호화 측면에서 손상된 것으로 알려져 있지 않으며, 지금까지의 암호화 연구를 통해 가까운 미래에도 보안이 유지될 가능성이 있다고 믿게 되었습니다. 그러나 이것이 반드시 영구적인 것은 아니며 이 분야의 현재 모범 사례를 반영하기 위해 이 문서의 새로운 개정판이 수시로 발행될 것으로 예상됩니다.

암호화 민첩성 측면에서, 예를 들어 PKEY 레코드에 대해 Ed25519에서 ECDSA를 대체하기 위해 업데이트된 암호화 체계가 필요할 때마다 새 레코드 유형을 통해 간단히 도입할 수 있습니다. 그러면 영역 관리자는 향후 기록을 위해 위임 기록 유형을 바꿀 수 있습니다. 이전 레코드 유형은 그대로 유지되며 영역은 업데이트된 영역 키로 반복적으로 마이그레이션될 수 있습니다. 구현이 지원하지 않는 ztype을 발견할 때 오류 메시지를 올바르게 생성하도록 하려면 현재 및 미래의 위임 레코드에 항상 CRITICAL 플래그가 설정되어 있어야 합니다.

---
### **9.3.  Cryptography**

다음 고려 사항은 이 문서에 지정된 ztype의 디자인 선택에 대한 배경 정보를 제공합니다. 섹션 4에 따라 새 ztype을 지정할 때 동일한 고려 사항이 적용됩니다.

GNS PKEY 영역 키는 Ed25519를 통해 ECDSA를 사용합니다. ECDSA는 일반적으로 다른 곡선과 함께 사용되므로 이는 색다른 선택입니다. 그러나 표준화된 ECDSA 곡선은 Curve25519 및 EdDSA 문서 \[RFC7748\] \[ed25519\]에 설명된 대로 다양한 이유로 문제가 있습니다. EdDSA를 직접 사용하는 것도 불가능합니다. 해시 함수가 개인 키에 사용되어 GNS의 키 블라인드가 의존하는 선형성을 파괴하기 때문입니다. 비슷한 크기의 다른 공통 곡선 대신 Ed25519를 사용하면 ECDSA의 보안이 낮아질 것이라고 제안하는 사람은 아무도 없습니다. GNS는 256비트 곡선을 사용합니다. 이렇게 하면 인코딩된\(공개\) 키가 단일 DNS 레이블에 들어가므로 유용성이 좋습니다.

암호문의 구별 가능성을 보장하려면 카운터 블록의 IV에 주의를 기울여야 합니다. 우리 설계에서는 IV에 항상 레코드 블록의 만료 시간이 포함됩니다. 애플리케이션이 상대적 만료 시간을 사용하여 레코드를 저장하는 경우 블록이 스토리지에 게시될 때마다 해당 IV가 고유하기 때문에 단조성이 암묵적으로 보장됩니다. 만료 시간은 동적으로 계산되고 시스템 시간에 따라 단조롭게 증가하기 때문입니다. 그럼에도 불구하고 구현에서는 상대적 만료 시간이 감소할 때 다음 레코드 블록의 만료 시간이 마지막 게시된 블록 이후여야 함을 보장해야 합니다\(MUST\). 절대 만료 시간이 사용되는 레코드의 경우 구현에서는 레코드 데이터가 변경될 때 만료 시간이 항상 늘어나도록 해야 합니다. 예를 들어, 사용자가 변경을 요청하지 않은 경우에도 회선의 만료 시간은 1마이크로초씩 늘어날 수 있습니다. 레이블 아래의 모든 리소스 레코드를 삭제하는 경우 구현에서는 마지막으로 게시된 리소스 블록의 마지막 절대 만료 시간을 추적해야 합니다. 구현에서는 마지막 절대 만료 시간을 보존하는 삭제 표시로 특수 레코드 유형을 정의하고 사용할 수 있지만 그러한 삭제 표시 레코드가 포함된 블록을 게시하지 않도록 주의해야 합니다. 나중에 이 레이블 아래에 새 레코드가 추가되면 구현에서는 만료 시간이 마지막 게시된 블록 이후인지 확인해야 합니다. 마지막으로, 단조롭게 증가하는 만료 시간을 보장하기 위해 구현에서는 시스템 시계에서 얻은 마지막 시간의 로컬 기록을 유지해야 하며, 시스템 시계가 뒤로 점프하는 경우 단조로운 시계를 구성해야 합니다.\(MUST, MUST, MUST, MUST, MUST, MUST\)

---
### **9.4.  Abuse Mitigation**

GNS 이름은 UTF-8 문자열입니다. 결과적으로, GNS는 국제화된 도메인 이름과 관련하여 DNS의 경우와 유사한 이름 스푸핑과 관련된 문제에 직면해 있습니다. DNS에서 공격자는 피싱 공격을 실행하기 위해 유사하거나 유사한 이름\(위 참조\)을 등록할 수 있습니다. GNS 영역 관리자는 이 공격 벡터를 고려하고 이를 완화하기 위한 규칙을 통합해야 합니다.

또한 DNS는 당국이 해당 도메인을 압수함으로써 인터넷의 불법 콘텐츠와 싸우는 데 사용될 수 있습니다. 그러나 국가 검열을 부과하기 위해 동일한 메커니즘이 남용될 수도 있습니다. 그러한 가능성을 피하는 것이 GNS의 동기 중 하나입니다. GNS에서는 TLD를 열거할 수 없습니다. 설계상 리졸버의 시작 영역은 로컬로 정의되므로 GNS에서는 이러한 점유가 어렵고 비효율적입니다.

---
### **9.5.  Zone Management**

GNS에서는 영역 관리자가 자신의 영역 키를 관리하고 보호해야 합니다. 개인 영역 키가 손실되면 복구할 수 없으며 영역 취소 메시지를 더 이상 계산할 수 없습니다. 프라이빗 영역 키가 손실된 경우 취소가 필요한 경우 취소 메시지를 미리 계산할 수 있습니다. 영역 관리자\(GNS의 경우 최종 사용자 포함\)는 암호화 키를 책임감 있고 성실하게 보호해야 합니다. GNS는 개인 키 보호를 목표로 하는 프로세스\(예: 에어 갭\)를 지원하기 위해 사전\("오프라인"\) 기록 서명을 지원합니다.

마찬가지로 사용자는 로컬 시작 영역 구성을 관리해야 합니다. 이름의 무결성과 가용성을 보장하기 위해 사용자는 로컬 시작 영역 정보가 손상되거나 오래되지 않았는지 확인해야 합니다. 구역 취소 처리 및 초기 시작 구역은 GNS 구현\("직배송"\)과 함께 제공될 것으로 예상할 수 있습니다. 초기 시작 영역 구성을 배송하면 루트 영역이 효과적으로 설정됩니다. 영역 확장 및 사용자 정의는 전적으로 사용자의 재량에 달려 있습니다.

이 사양을 따르는 구현은 상호 운용 가능하지만 두 구현이 서로 다른 원격 저장소 엔터티에 연결되면 상호 연결할 수 없습니다. 이는 특정 이름에 대한 전역 네임스페이스에 레코드가 존재하지만 구현이 해당 블록을 포함하는 원격 저장소 엔터티와 통신하지 않아 이를 해결할 수 없는 상태로 이어질 수 있습니다. 이 상황은 분할-수평 DNS 구성과 유사합니다. 사용되는 원격 저장소 엔터티는 GNS 확인을 사용하는 특정 애플리케이션 컨텍스트에 따라 달라질 가능성이 높습니다. 예를 들어, 한 가지 응용 프로그램은 Tor 네트워크 \[TorRendSpec\] 내의 숨겨진 서비스를 해결하는 것인데, 이는 원격 저장을 위해 Tor 라우터를 사용하도록 제안합니다. "집합된" 원격 저장소 엔터티의 구현을 생각할 수 있지만 예외가 될 것으로 예상됩니다.

---
### **9.6.  DHTs as Remote Storage**

이 문서에서는 GNS 구현에 필요한 기본 원격 저장소의 속성을 지정하지 않습니다. 기본 원격 저장소의 속성은 GNS 구현에 의해 직접 상속된다는 점에 유의하는 것이 중요합니다. 여기에는 보안과 확장성, 성능 등 기타 비기능적 속성이 모두 포함됩니다. 구현자는 GNS 구현에서 원격 저장소로 사용할 DHT를 선택하거나 구현할 때 세심한 주의를 기울여야 합니다. 합리적인 보안 및 성능 속성을 갖춘 DHT가 존재합니다 \[R5N\]. 또한 서로 다른 DHT 오버레이를 기반으로 하는 GNS 구현이 상호 연결될 가능성이 낮다는 점도 고려해야 합니다.

---
### **9.7.  Revocations**

영역 관리자는 영역 취소를 미리 생성하고 향후 영역 키가 분실, 손상 또는 대체되는 경우 취소 정보를 안전하게 저장하는 것이 좋습니다. 만료 또는 에포크 조정과 같은 프로토콜 변경으로 인해 미리 계산된 취소가 더 이상 유효하지 않을 수 있습니다. 따라서 구현자와 사용자는 그에 따라 철회를 관리하기 위해 예방 조치를 취해야 합니다.

해지 페이로드에는 키 교체를 위한 "새" 키가 포함되지 않습니다. 이러한 키를 포함하면 두 가지 주요 단점이 있습니다.

1. 개인 키가 손상된 후 철회가 게시되면 키 교체를 허용하는 것은 위험할 수 있습니다. 공격자가 개인 키를 장악한 경우 공격자는 키 교체를 통해 철회를 브로드캐스팅할 수 있습니다. 교체의 경우 손상된 소유자는 철회를 발행할 기회가 없습니다. 따라서 해지 메시지가 개인 키를 대체하도록 허용하면 키 손상 상황 처리가 더욱 악화됩니다.

2. 때때로 암호화 시스템을 변경하려는 목적으로 키 취소가 사용됩니다. 해지 메시지를 통해 키를 교체하여 다른 암호화 시스템으로 마이그레이션하는 것은 두 암호화 시스템이 위조로부터 여전히 안전한 경우에만 안전합니다. 다른 암호화 시스템으로의 계획된 비긴급 마이그레이션은 한동안 두 암호화 시스템에 대한 영역을 병렬로 실행하여 수행되어야 합니다. 이전 영역 키가 더 이상 안전하지 않다고 판단되는 경우에만, 그리고 대부분의 사용자가 대체 영역 키로 마이그레이션한 후에만 이전 영역 키를 취소함으로써 마이그레이션이 종료됩니다.

---
### **9.8.  Zone Privacy**

GNS는 영역 내에서 이름의 존재에 대한 인증된 거부를 지원하지 않습니다. 레코드 데이터는 영역 키와 레코드 레이블에서 파생된 키를 사용하여 암호화된 형식으로 게시됩니다. 영역 관리자는 \(1\) 레이블과 영역 키가 공개인지, \(2\) 둘 중 하나 또는 둘 다를 공유 비밀로 사용하여 해당 레코드 데이터에 대한 액세스를 제한해야 하는지 신중하게 고려해야 합니다. 공개 영역 키와 달리 낮은 엔트로피 레이블은 공격자가 추측할 수 있습니다. 공격자가 공개 영역 키를 알고 있는 경우 잘 알려져 있거나 추측 가능한 레이블을 사용하면 해당 기록의 공개를 효과적으로 위협할 수 있습니다.

레이블에 대한 추측 공격은 영역 키가 어떻게든 적에게 공개된 경우에만 적용된다는 점에 유의해야 합니다. GNS 자체는 조회 중이나 리소스 레코드가 게시될 때 이를 공개하지 않습니다\(네트워크에서는 블라인드 존 키만 사용되기 때문\). 그러나 영역 키는 취소 중에 공개됩니다.

따라서 리소스 레코드 세트의 데이터가 민감한 경우 추측 공격을 방지하기 위해 엔트로피가 충분한 레이블을 사용하는 것이 좋습니다.\(SHOULD\)

---
### **9.9.  Zone Governance**

DNS는 분산되어 있지만 실제로는 중앙 집중식의 신뢰할 수 있는 등록 기관을 사용하여 전 세계적으로 고유한 이름을 제공합니다. DNS가 인터넷에서 수행하는 핵심 역할에 대한 인식이 높아지면서 다양한 기관이 자신의 권한\(법적 수단 포함\)을 사용하여 DNS에 대한 공격에 가담하고 있으며, 이로 인해 인터넷 정보의 글로벌 가용성과 무결성이 위협받고 있습니다. 이 문제에 대한 광범위한 논의는 이 문서의 범위를 벗어나지만 \[SecureNS\]를 포함한 최근 학술 연구 작업에서 분석 및 조사를 찾을 수 있습니다.

GNS는 특히 검열이나 조작이 발생할 때 DNS 이름 확인 프로토콜에 대한 안전하고 개인 정보 보호를 강화하는 대안을 제공하도록 설계되었습니다. 특히 쿼리 개인 정보 보호와 관련된 DNS의 문제를 직접적으로 해결합니다. 그러나 루트 영역의 거버넌스에 따라 모든 배포는 중앙에서 제어되는 루트가 있는 단일 계층 문제와 DNS의 루트 서버 배포 및 관리 관련 문제로 인해 어려움을 겪을 가능성이 높습니다. \[RFC8324\] 각각. DNS에서 이러한 문제는 ICANN\(Internet Corporation for Assigned Names and Numbers\)의 중앙 집중식 루트 영역 관리에서 직접적으로 발생합니다. 이를 통해 전역적으로 고유한 이름을 제공할 수 있습니다.

GNS에서 시작 영역은 사용자에게 선호하는 루트 영역 거버넌스에 대한 로컬 권한을 부여합니다. 이를 통해 사용자는 매우 강력한 적 모델 하에서 운영하면서 로컬 애칭을 사용하는 안전한 권한 위임을 통해 제3자\(예: 구현자 또는 ICANN과 같은 다중 이해관계자 거버넌스 기관\)가 제공하는 신뢰할 수 있는 루트 영역 구성을 대체하거나 강화할 수 있습니다. 이는 zTLD와 결합하여 GNS 사용자에게 신뢰할 수 있는 권한 없이도 안전하고 기억에 남는 글로벌 매핑을 제공합니다.

모든 GNS 구현은 초기 시작 영역 매핑 형식으로 기본 거버넌스 모델을 제공할 수 있습니다.\(MAY\)

---
### **9.10.  Namespace Ambiguity**

기술적으로 GNS 프로토콜은 글로벌 DNS의 네임스페이스에서 이름을 확인하는 데 사용될 수 있습니다. 그러나 이를 위해서는 각 거버넌스 기관과 이해관계자\(예: IETF 및 ICANN\)가 이 특정 사용 사례에 대해 GNS 사용을 표준화해야 합니다.

이 기능은 로컬 시작 영역 구성이 전역 DNS에서 GNS 영역으로 접미사를 매핑하는 경우 GNS 이름이 각각의 공통 표시 형식\[RFC8499\] 또는 기타 특수 용도 도메인 이름\[RFC6761\]의 DNS 이름과 구별되지 않을 수 있음을 의미합니다. 응용 프로그램의 경우 특정 이름을 확인하기 위해 어떤 이름 시스템을 사용해야 하는지가 모호해집니다. 이는 \[RFC8244\]에 설명된 대로 실제로 GNS 이름일 때 DNS를 통해 이름을 확인하려고 시도할 때 위험을 초래합니다. 이 경우 DNS 확인 과정에서 GNS 이름이 유출될 가능성이 높습니다.

쿼리된 GNS 이름의 공개를 방지하기 위해 GNS 인식 응용 프로그램은 잠재적인 접미사-영역 매핑 및 zTLD를 고려하여 다른 방법보다 먼저 GNS에서 주어진 이름을 확인하는 것이 좋습니다. 접미사-영역 매핑은 사용자 또는 로컬 관리자가 구성해야 하며, 따라서 DNS를 통해 이름을 확인할 수 있더라도 GNS의 확인은 사용자 기대와 일치합니다. 이름에 대한 접미사-영역 매핑이 존재하지 않고 zTLD가 발견되지 않으면 DNS와 같은 다른 방법을 사용하여 확인을 계속할 수 있습니다. 이름에 대한 접미사-영역 매핑이 존재하거나 이름이 zTLD로 끝나는 경우 GNS를 사용하여 확인해야 하며 GNS 확인 결과와 관계없이 다른 방법으로 확인을 계속해서는 안 됩니다.\(SHOULD, MAY, MUST NOT\)

UNIX 계열 운영 체제의 NSS\(Name Service Switch\)와 같은 메커니즘은 이러한 확인 프로세스를 구현하고 사용할 수 있는 방법의 예입니다. NSS를 사용하면 시스템 관리자가 호스트 이름 확인 우선 순위를 구성할 수 있으며 시스템 확인자 구현과 통합됩니다.

GNS 이름이 다른 이름 확인 메커니즘\(특히 DNS\)의 이름과 혼동될 수 있는 사용 사례의 경우 ".gns.alt" 도메인을 사용해야 합니다. 맬웨어 사이트를 차단하기 위해 싱크홀을 구현하거나 검열을 우회하기 위해 GNS를 통해 DNS 도메인을 제공하는 것과 같은 사용 사례의 경우 GNS는 다른 이름 시스템의 확인을 방해하는 방식으로 의도적으로 사용될 수 있습니다.\(SHOULD, MAY\)

---
## **10.  GANA Considerations**
---
### **10.1.  GNUnet Signature Purposes Registry**

GANA \[GANA\]는 표 1에 나열된 "GNUnet 서명 목적" 레지스트리에 서명 목적을 할당했습니다.

```text
   +=========+=================+============+==========================+
   | Purpose | Name            | References | Comment                  |
   +=========+=================+============+==========================+
   | 3       | GNS_REVOCATION  | RFC 9498   | GNS zone key revocation  |
   +---------+-----------------+------------+--------------------------+
   | 15      | GNS_RECORD_SIGN | RFC 9498   | GNS record set           |
   |         |                 |            | signature                |
   +---------+-----------------+------------+--------------------------+
```

- 표 1: GANA GNUnet 서명 목적 레지스트리

---
### **10.2.  GNS Record Types Registry**

GANA \[GANA\]는 "GNS 레코드 유형" 레지스트리를 관리합니다.

각 항목의 형식은 다음과 같습니다.

이름: 레코드 유형의 이름입니다\(대소문자를 구분하지 않는 ASCII 문자열, 영숫자로 제한됨\). 영역 위임 레코드의 경우 할당된 번호는 영역의 ztype 값을 나타냅니다.

숫자: 65535 이상의 32비트 숫자입니다.

설명: 선택적으로 레코드 유형의 목적을 설명하는 간단한 영어 텍스트\(UTF-8\)입니다.

연락처: 선택적으로 추가 정보를 위해 연락할 사람의 연락처 정보입니다.

참조: 선택적으로 레코드 유형을 설명하는 참조\(예: RFC\)입니다.

이 레지스트리의 등록 정책은 "선착순"입니다. 이 정책은 \[RFC8126\]에 설명된 내용을 모델로 하며 GANA가 취하는 조치를 설명합니다.

\* 고유한 이름 할당을 위한 선착순 정책을 사용하여 승인된 GANA 기여자의 검토 후 새 항목을 추가할 수 있습니다. 검토자는 선택한 "이름"이 기록 유형에 적합한지 확인할 책임이 있습니다. 레지스트리는 항목에 대한 고유 번호를 정의합니다.

```text
   *  Authorized GANA contributors for review of new entries are
      reachable at <gns-registry@gnunet.org>.
```

\* 모든 요청에는 고유한 이름과 연락처가 포함되어야 합니다. 요청자의 동의를 받아 연락처 정보를 레지스트리에 추가할 수 있습니다. 요청에는 위에 정의된 대로 설명 주석뿐만 아니라 관련 참조도 선택적으로 포함될 수 있습니다.\(MUST, MAY, MAY\)

GANA는 표 2에 나열된 "GNS 레코드 유형" 레지스트리에서 이 사양에 정의된 레코드 유형에 대한 번호를 할당했습니다.

```text
     +========+==========+=========+============+====================+
     | Number | Name     | Contact | References | Comment            |
     +========+==========+=========+============+====================+
     | 65536  | PKEY     | (*)     | RFC 9498   | GNS zone           |
     |        |          |         |            | delegation (PKEY)  |
     +--------+----------+---------+------------+--------------------+
     | 65537  | NICK     | (*)     | RFC 9498   | GNS zone nickname  |
     +--------+----------+---------+------------+--------------------+
     | 65538  | LEHO     | (*)     | RFC 9498   | GNS legacy         |
     |        |          |         |            | hostname           |
     +--------+----------+---------+------------+--------------------+
     | 65540  | GNS2DNS  | (*)     | RFC 9498   | Delegation to DNS  |
     +--------+----------+---------+------------+--------------------+
     | 65541  | BOX      | (*)     | RFC 9498   | Box records        |
     +--------+----------+---------+------------+--------------------+
     | 65551  | REDIRECT | (*)     | RFC 9498   | Redirection record |
     +--------+----------+---------+------------+--------------------+
     | 65556  | EDKEY    | (*)     | RFC 9498   | GNS zone           |
     |        |          |         |            | delegation (EDKEY) |
     +--------+----------+---------+------------+--------------------+
     | (*): gns-registry@gnunet.org                                  |
     +---------------------------------------------------------------+

                Table 2: The GANA GNS Record Types Registry
```

---
### **10.3.  .alt Subdomains Registry**

GANA \[GANA\]는 ".alt 하위 도메인" 레지스트리를 관리합니다. 이 GANA 운영 .alt 레지스트리는 특정 구현자에 의해 고려될 수도 있고 고려되지 않을 수도 있으며 어떤 방식으로든 IETF 또는 ICANN과 연관되거나 승인되지 않습니다.

각 항목의 형식은 다음과 같습니다.

레이블: 하위 도메인의 레이블\(\[RFC5890\]의 섹션 2.3.1에 정의된 DNS "문자, 숫자, 하이픈"\(LDH\) 형식\).

설명: 선택적으로 하위 도메인의 목적을 설명하는 간단한 영어 텍스트\(UTF-8\)입니다.

연락처: 선택적으로 추가 정보를 위해 연락할 사람의 연락처 정보입니다.

참조: 선택적으로 레코드 유형을 설명하는 참조\(예: RFC\)입니다.

이 레지스트리의 등록 정책은 "선착순"입니다. 이 정책은 \[RFC8126\]에 설명된 내용을 모델로 하며 GANA가 취하는 조치를 설명합니다.

\* 고유한 하위 도메인 할당을 위한 선착순 정책을 사용하여 승인된 GANA 기여자의 검토 후 새 항목을 추가할 수 있습니다. 검토자는 선택한 "하위 도메인"이 목적에 적합한지 확인할 책임이 있습니다.

```text
   *  Authorized GANA contributors for review of new entries are
      reachable at <alt-registry@gnunet.org>.
```

\* 모든 요청에는 고유한 하위 도메인과 연락처가 포함되어야 합니다. 요청자의 동의를 받아 연락처 정보를 레지스트리에 추가할 수 있습니다. 요청에는 위에 정의된 대로 설명 주석뿐만 아니라 관련 참조도 선택적으로 포함될 수 있습니다.\(MUST, MAY, MAY\)

GANA는 표 3에 나열된 ".alt Subdomains" 레지스트리에 본 사양에 정의된 하위 도메인을 할당했습니다.

```text
       +=======+=========+============+============================+
       | Label | Contact | References | Description                |
       +=======+=========+============+============================+
       | gns   | (*)     | RFC 9498   | The .alt subdomain for GNS |
       +-------+---------+------------+----------------------------+
       | (*): alt-registry@gnunet.org                              |
       +-----------------------------------------------------------+

                 Table 3: The GANA .alt Subdomains Registry
```

---
## **11.  IANA Considerations**

이 문서에는 IANA 작업이 없습니다.

---
## **12.  Implementation and Deployment Status**

이 사양을 준수하는 구현에는 각각 C와 Go로 작성된 두 가지가 있습니다. GNUnet \[GNUnetGNS\]의 일부인 C 구현은 원본 및 참조 구현을 나타냅니다. Go 구현\[GoGNS\]은 GNS의 두 구현이 동일한 기본 DHT 저장소 위에 구축된 경우 어떻게 상호 운용 가능한지 보여줍니다.

현재 GNUnet P2P 네트워크\[GNUnet\]는 DHT\[R5N\] 위에 GNS를 적극적으로 배포하고 있습니다. Go 구현\[GoGNS\]은 모든 GNUnet 피어에서 사용할 수 있는 GNUnet DHT 서비스를 기반으로 구축하여 이 배포를 사용합니다. GNS 구현이 기존 배포에 연결되고 이름 확인 및 영역 게시에 참여할 수 있는 방법을 보여줍니다.

자기주권 신원 시스템 re:claimID \[reclaim\]은 신원 속성 및 증명을 제3자와 선택적으로 공유하기 위해 GNS를 사용합니다.

Ascension 도구 \[Ascension\]은 DNS 영역 전송에서 검색된 정보를 GNS 영역으로 변환하여 DNS 영역을 GNS 영역으로 쉽게 마이그레이션합니다.

---
## **13.  References**
---
### **13.1.  Normative References**

```text
   [RFC1034]  Mockapetris, P., "Domain names - concepts and facilities",
              STD 13, RFC 1034, DOI 10.17487/RFC1034, November 1987,
              <https://www.rfc-editor.org/info/rfc1034>.

   [RFC1035]  Mockapetris, P., "Domain names - implementation and
              specification", STD 13, RFC 1035, DOI 10.17487/RFC1035,
              November 1987, <https://www.rfc-editor.org/info/rfc1035>.

   [RFC2782]  Gulbrandsen, A., Vixie, P., and L. Esibov, "A DNS RR for
              specifying the location of services (DNS SRV)", RFC 2782,
              DOI 10.17487/RFC2782, February 2000,
              <https://www.rfc-editor.org/info/rfc2782>.

   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", BCP 14, RFC 2119,
              DOI 10.17487/RFC2119, March 1997,
              <https://www.rfc-editor.org/info/rfc2119>.

   [RFC3629]  Yergeau, F., "UTF-8, a transformation format of ISO
              10646", STD 63, RFC 3629, DOI 10.17487/RFC3629, November
              2003, <https://www.rfc-editor.org/info/rfc3629>.

   [RFC3686]  Housley, R., "Using Advanced Encryption Standard (AES)
              Counter Mode With IPsec Encapsulating Security Payload
              (ESP)", RFC 3686, DOI 10.17487/RFC3686, January 2004,
              <https://www.rfc-editor.org/info/rfc3686>.

   [RFC3826]  Blumenthal, U., Maino, F., and K. McCloghrie, "The
              Advanced Encryption Standard (AES) Cipher Algorithm in the
              SNMP User-based Security Model", RFC 3826,
              DOI 10.17487/RFC3826, June 2004,
              <https://www.rfc-editor.org/info/rfc3826>.

   [RFC5237]  Arkko, J. and S. Bradner, "IANA Allocation Guidelines for
              the Protocol Field", BCP 37, RFC 5237,
              DOI 10.17487/RFC5237, February 2008,
              <https://www.rfc-editor.org/info/rfc5237>.

   [RFC5869]  Krawczyk, H. and P. Eronen, "HMAC-based Extract-and-Expand
              Key Derivation Function (HKDF)", RFC 5869,
              DOI 10.17487/RFC5869, May 2010,
              <https://www.rfc-editor.org/info/rfc5869>.

   [RFC5890]  Klensin, J., "Internationalized Domain Names for
              Applications (IDNA): Definitions and Document Framework",
              RFC 5890, DOI 10.17487/RFC5890, August 2010,
              <https://www.rfc-editor.org/info/rfc5890>.

   [RFC5895]  Resnick, P. and P. Hoffman, "Mapping Characters for
              Internationalized Domain Names in Applications (IDNA)
              2008", RFC 5895, DOI 10.17487/RFC5895, September 2010,
              <https://www.rfc-editor.org/info/rfc5895>.

   [RFC6234]  Eastlake 3rd, D. and T. Hansen, "US Secure Hash Algorithms
              (SHA and SHA-based HMAC and HKDF)", RFC 6234,
              DOI 10.17487/RFC6234, May 2011,
              <https://www.rfc-editor.org/info/rfc6234>.

   [RFC6895]  Eastlake 3rd, D., "Domain Name System (DNS) IANA
              Considerations", BCP 42, RFC 6895, DOI 10.17487/RFC6895,
              April 2013, <https://www.rfc-editor.org/info/rfc6895>.

   [RFC6979]  Pornin, T., "Deterministic Usage of the Digital Signature
              Algorithm (DSA) and Elliptic Curve Digital Signature
              Algorithm (ECDSA)", RFC 6979, DOI 10.17487/RFC6979, August
              2013, <https://www.rfc-editor.org/info/rfc6979>.

   [RFC7748]  Langley, A., Hamburg, M., and S. Turner, "Elliptic Curves
              for Security", RFC 7748, DOI 10.17487/RFC7748, January
              2016, <https://www.rfc-editor.org/info/rfc7748>.

   [RFC8032]  Josefsson, S. and I. Liusvaara, "Edwards-Curve Digital
              Signature Algorithm (EdDSA)", RFC 8032,
              DOI 10.17487/RFC8032, January 2017,
              <https://www.rfc-editor.org/info/rfc8032>.

   [RFC8126]  Cotton, M., Leiba, B., and T. Narten, "Guidelines for
              Writing an IANA Considerations Section in RFCs", BCP 26,
              RFC 8126, DOI 10.17487/RFC8126, June 2017,
              <https://www.rfc-editor.org/info/rfc8126>.

   [RFC8174]  Leiba, B., "Ambiguity of Uppercase vs Lowercase in RFC
              2119 Key Words", BCP 14, RFC 8174, DOI 10.17487/RFC8174,
              May 2017, <https://www.rfc-editor.org/info/rfc8174>.

   [RFC8499]  Hoffman, P., Sullivan, A., and K. Fujiwara, "DNS
              Terminology", BCP 219, RFC 8499, DOI 10.17487/RFC8499,
              January 2019, <https://www.rfc-editor.org/info/rfc8499>.

   [RFC9106]  Biryukov, A., Dinu, D., Khovratovich, D., and S.
              Josefsson, "Argon2 Memory-Hard Function for Password
              Hashing and Proof-of-Work Applications", RFC 9106,
              DOI 10.17487/RFC9106, September 2021,
              <https://www.rfc-editor.org/info/rfc9106>.

   [GANA]     GNUnet e.V., "GNUnet Assigned Numbers Authority (GANA)",
              2023, <https://gana.gnunet.org/>.

   [MODES]    Dworkin, M., "Recommendation for Block Cipher Modes of
              Operation: Methods and Techniques", NIST Special
              Publication 800-38A, DOI 10.6028/NIST.SP.800-38A, December
              2001, <https://doi.org/10.6028/NIST.SP.800-38A>.

   [CrockfordB32]
              Crockford, D., "Base 32", March 2019,
              <https://www.crockford.com/base32.html>.

   [XSalsa20] Bernstein, D. J., "Extending the Salsa20 nonce", 2011,
              <https://cr.yp.to/papers.html#xsalsa>.

   [Unicode-UAX15]
              Davis, M., Whistler, K., and M. Dürst, "Unicode Standard
              Annex #15: Unicode Normalization Forms", Revision 31, The
              Unicode Consortium, Mountain View, September 2009,
              <https://www.unicode.org/reports/tr15/tr15-31.html>.

   [Unicode-UTS46]
              Davis, M. and M. Suignard, "Unicode Technical Standard
              #46: Unicode IDNA Compatibility Processing", Revision 31,
              The Unicode Consortium, Mountain View, September 2023,
              <https://www.unicode.org/reports/tr46>.
```

---
### **13.2.  Informative References**

```text
   [RFC1928]  Leech, M., Ganis, M., Lee, Y., Kuris, R., Koblas, D., and
              L. Jones, "SOCKS Protocol Version 5", RFC 1928,
              DOI 10.17487/RFC1928, March 1996,
              <https://www.rfc-editor.org/info/rfc1928>.

   [RFC4033]  Arends, R., Austein, R., Larson, M., Massey, D., and S.
              Rose, "DNS Security Introduction and Requirements",
              RFC 4033, DOI 10.17487/RFC4033, March 2005,
              <https://www.rfc-editor.org/info/rfc4033>.

   [RFC6066]  Eastlake 3rd, D., "Transport Layer Security (TLS)
              Extensions: Extension Definitions", RFC 6066,
              DOI 10.17487/RFC6066, January 2011,
              <https://www.rfc-editor.org/info/rfc6066>.

   [RFC7363]  Maenpaa, J. and G. Camarillo, "Self-Tuning Distributed
              Hash Table (DHT) for REsource LOcation And Discovery
              (RELOAD)", RFC 7363, DOI 10.17487/RFC7363, September 2014,
              <https://www.rfc-editor.org/info/rfc7363>.

   [RFC8324]  Klensin, J., "DNS Privacy, Authorization, Special Uses,
              Encoding, Characters, Matching, and Root Structure: Time
              for Another Look?", RFC 8324, DOI 10.17487/RFC8324,
              February 2018, <https://www.rfc-editor.org/info/rfc8324>.

   [RFC8806]  Kumari, W. and P. Hoffman, "Running a Root Server Local to
              a Resolver", RFC 8806, DOI 10.17487/RFC8806, June 2020,
              <https://www.rfc-editor.org/info/rfc8806>.

   [RFC6761]  Cheshire, S. and M. Krochmal, "Special-Use Domain Names",
              RFC 6761, DOI 10.17487/RFC6761, February 2013,
              <https://www.rfc-editor.org/info/rfc6761>.

   [RFC8244]  Lemon, T., Droms, R., and W. Kumari, "Special-Use Domain
              Names Problem Statement", RFC 8244, DOI 10.17487/RFC8244,
              October 2017, <https://www.rfc-editor.org/info/rfc8244>.

   [RFC9476]  Kumari, W. and P. Hoffman, "The .alt Special-Use Top-Level
              Domain", RFC 9476, DOI 10.17487/RFC9476, September 2023,
              <https://www.rfc-editor.org/info/rfc9476>.

   [TorRendSpec]
              Tor Project, "Tor Rendezvous Specification - Version 3",
              commit b345ca0, June 2023,
              <https://github.com/torproject/torspec/blob/main/rend-
              spec-v3.txt>.

   [Tor224]   Goulet, D., Kadianakis, G., and N. Mathewson, "Next-
              Generation Hidden Services in Tor", Appendix A.2 ("Tor's
              key derivation scheme"), November 2013,
              <https://gitweb.torproject.org/torspec.git/tree/
              proposals/224-rend-spec-ng.txt#n2135>.

   [SDSI]     Rivest, R. L. and B. Lampson, "SDSI - A Simple Distributed
              Security Infrastructure", October 1996,
              <https://citeseerx.ist.psu.edu/document?repid=rep1&type=pd
              f&doi=3837e0206bf73e5e8f0ba6db767a2f714ea7c367>.

   [Kademlia] Maymounkov, P. and D. Mazières, "Kademlia: A Peer-to-peer
              Information System Based on the XOR Metric",
              DOI 10.1007/3-540-45748-8_5, 2002,
              <https://css.csail.mit.edu/6.824/2014/papers/
              kademlia.pdf>.

   [ed25519]  Bernstein, D. J., Duif, N., Lange, T., Schwabe, P., and
              B-Y. Yang, "High-speed high-security signatures",
              DOI 10.1007/s13389-012-0027-1, 2011,
              <https://ed25519.cr.yp.to/ed25519-20110926.pdf>.

   [GNS]      Wachs, M., Schanzenbach, M., and C. Grothoff, "A
              Censorship-Resistant, Privacy-Enhancing and Fully
              Decentralized Name System", 13th International Conference
              on Cryptology and Network Security (CANS),
              DOI 10.13140/2.1.4642.3044, October 2014,
              <https://sci-hub.st/10.1007/978-3-319-12280-9_9>.

   [R5N]      Evans, N. S. and C. Grothoff, "R5N: Randomized Recursive
              Routing for Restricted-Route Networks", 5th International
              Conference on Network and System Security (NSS),
              DOI 10.1109/ICNSS.2011.6060022, September 2011,
              <https://sci-hub.st/10.1109/ICNSS.2011.6060022>.

   [SecureNS] Grothoff, C., Wachs, M., Ermert, M., and J. Appelbaum,
              "Toward secure name resolution on the Internet", Computers
              and Security, Volume 77, Issue C, pp. 694-708,
              DOI 10.1016/j.cose.2018.01.018, August 2018, <https://sci-
              hub.st/https://doi.org/10.1016/j.cose.2018.01.018>.

   [GNUnetGNS]
              GNUnet e.V., "gnunet.git - GNUnet core repository", 2023,
              <https://git.gnunet.org/gnunet.git>.

   [Ascension]
              GNUnet e.V., "ascension.git - DNS zones to GNS migrating
              using incremental zone transfer (AXFR/IXFR)", 2023,
              <https://git.gnunet.org/ascension.git>.

   [GNUnet]   GNUnet e.V., "The GNUnet Project (Home Page)", 2023,
              <https://gnunet.org>.

   [reclaim]  GNUnet e.V., "re:claimID - Self-sovereign, Decentralised
              Identity Management and Personal Data Sharing", 2023,
              <https://reclaim.gnunet.org>.

   [GoGNS]    Fix, B., "gnunet-go (Go GNS)", commit 5c815ba, July 2023,
              <https://github.com/bfix/gnunet-
              go/tree/master/src/gnunet/service/gns>.

   [nsswitch] GNU Project, "System Databases and Name Service Switch
              (Section 29)",
              <https://www.gnu.org/software/libc/manual/html_node/Name-
              Service-Switch.html>.
```

---
# **Appendix A.  Usage and Migration**

이 섹션에서는 이 기술 사양을 읽는 독자가 프로토콜을 더 잘 이해하는 데 도움이 될 수 있는 다양한 특정 사용 사례에 대해 설명합니다. 아래 고려 사항은 어떤 방식으로든 GNS 프로토콜에 대한 규범이 아닙니다. 대신, 프로토콜 설계자가 의도한 프로토콜 사용에 대한 배경 지식을 제공하고 컨텍스트를 제공하기 위해 제공됩니다. 또한 이 섹션에서는 마이그레이션 경로에 대한 포인터를 제공합니다.

---
### **A.1.  Zone Dissemination**

영역 소유자가 되려면 GNS 구현을 사용하여 영역 키와 해당 비밀 키를 생성하는 것으로 충분합니다. 이 시점에서 영역 소유자는 로컬 영역 데이터베이스에서 GNS 리소스 레코드를 관리할 수 있습니다. 그러면 리소스 레코드는 섹션 6에 정의된 대로 GNS 구현에 의해 게시될 수 있습니다. 다른 사용자가 리소스 레코드를 확인하려면 해당 영역 정보가 먼저 전파되어야 합니다. 영역 소유자는 영역 키와 레이블을 선택된 사용자 집합에게만 알리거나 이 정보를 일반 대중에게 공개하도록 결정할 수 있습니다.

영역 정보를 특정 사용자와 직접 공유하면 영역을 잠재적으로 보존하고 개인정보를 기록할 수 있을 뿐만 아니라 영역 소유자와 사용자가 강력한 신뢰 관계를 구축할 수 있습니다. 예를 들어, 은행은 은행의 GNS 영역이 포함된 QR 코드가 포함된 고객 서신을 보낼 수 있습니다. 이를 통해 사용자는 QR 코드를 스캔하고 은행 영역 및 이를 통해 온라인 뱅킹 웹사이트의 IP 주소와 같은 강력한 링크를 설정할 수 있습니다.

대부분의 인터넷 서비스는 가능한 가장 효율적인 방법으로 일반 대중이 자신의 영역을 사용할 수 있도록 하려고 합니다. 첫째, 높은 수준의 평판과 신뢰를 받는 영역이 구현의 기본 접미사-영역 매핑에 포함될 가능성이 높다고 가정하는 것이 합리적입니다. 따라서 해당 영역에서 위임을 통해 영역을 전파하는 것은 영역을 공개적으로 전파하기 위한 실행 가능한 경로가 될 수 있습니다. 예를 들어, ICANN 또는 국가 코드 TLD 등록 기관과 같은 조직도 GNS 영역을 관리하고 등록 또는 위임 서비스를 제공할 수 있습니다.

모범 사례, 특히 보안 및 남용 완화와 관련된 모범 사례를 따르는 것은 영역 소유자와 야심 찬 등록자가 좋은 평판을 얻고 궁극적으로 신뢰를 얻을 수 있는 방법입니다. 물론 여기에는 프라이빗 영역 키 자료를 부지런히 보호하는 것도 포함됩니다. 이러한 모범 사례를 공식화하는 것은 이 사양의 범위를 벗어나며 이 문서의 섹션 9를 고려하는 별도의 문서에서 다루어야 합니다.

---
### **A.2.  Start Zone Configuration**

운영 체제나 브라우저 등 다른 수단을 통해 GNS 구현이 아직 제공되지 않은 경우 사용자는 GNS 구현을 설치해야 합니다. 구현에는 기본 시작 영역 구성이 함께 제공될 가능성이 높습니다. 이는 사용자가 zTLD로 끝나거나 기본 시작 영역 구성의 일부인 접미사-이름 매핑으로 끝나는 GNS 이름을 확인할 수 있음을 의미합니다. 이 시점에서 사용자는 구현의 기본 구성을 삭제하거나 수정할 수 있습니다.

\* 매핑에서 참조하는 영역 소유자가 사용자의 신뢰를 잃은 경우 접미사-영역 매핑을 삭제해야 할 수 있습니다. 예를 들어, 이는 느슨한 등록 정책으로 인해 피싱 활동이 발생할 수 있기 때문일 수 있습니다. 새로운 매핑을 수정하고 추가하는 것은 삭제 시 발생할 수 있는 네임스페이스 천공을 치료하거나 단순히 강력한 직접 신뢰 관계를 구축하기 위한 수단입니다. 그러나 이를 위해서는 각 영역 키에 대한 사용자의 지식이 필요합니다. 이 정보는 부록 A.1에 설명된 것처럼 대역 외에서 검색되어야 합니다. 은행은 은행의 GNS 영역이 포함된 QR 코드가 포함된 편지를 사용자에게 보낼 수 있습니다. 사용자는 QR 코드를 스캔하고 은행에 대해 선택한 지역 이름을 사용하여 새로운 접미사-이름 매핑을 추가합니다. 다른 예로는 친구의 장치, 상점 또는 광고의 스캐닝 구역 정보가 있습니다. 각 영역의 신뢰 수준은 상황에 따라 다르며 사용자마다 다를 수 있습니다. 신용카드가 포함된 은행 서신을 통해 제공되는 구역에 대한 신뢰는 거리의 무작위 광고에서 발견되는 구역과 확실히 다릅니다. 그러나 이러한 신뢰는 사용자가 즉시 확인할 수 있으며 로컬 이름 지정에도 반영될 수 있습니다.

\* 클라이언트이기도 한 사용자는 QR 코드 리더 또는 기타 가져오기 메커니즘을 제공하여 시작 영역 구성 수정을 용이하게 해야 합니다. 구현은 모범 사례에 따라 이상적으로 구현되고 섹션 9의 적용 가능한 사항을 처리합니다. 이러한 모범 사례를 공식화하는 것은 이 사양의 범위를 벗어납니다.

---
### **A.3.  Globally Unique Names and the Web**

HTTP 가상 호스팅 및 TLS 서버 이름 표시\(SNI\)는 웹에서 일반적인 사용 사례입니다. HTTP 클라이언트는 각각 HTTP "호스트" 헤더에 또는 TLS 핸드셰이크의 일부로 DNS 이름을 제공합니다. 이를 통해 HTTP 서버는 일치하는 TLS 인증서를 사용하여 표시된 가상 호스트를 제공할 수 있습니다. DNS 이름의 전역적 고유성은 이러한 사용 사례의 전제 조건입니다.

모든 GNS 이름이 전역적으로 고유한 것은 아닙니다. 그러나 GNS의 모든 리소스 레코드는 GNS 레이블과 영역의 zTLD를 연결하여 나타낼 수 있습니다. 기억하기 쉽지는 않지만, 동일한 사용 사례를 촉진하기 위해 전역적으로 고유한 이 GNS 이름을 활용할 수 있습니다. GNS 인식 HTTP 클라이언트에 입력된 GNS 이름 "www.example.gns.alt"를 생각해 보세요. 처음에는 "www.example.gns.alt"가 GNS를 사용하여 확인되어 레코드 세트가 생성됩니다. 그런 다음 HTTP 클라이언트는 다음과 같이 가상 호스트를 결정합니다.

레코드 세트에 "www.example.com"을 포함하는 LEHO 레코드\(섹션 5.3.1\)가 있는 경우 HTTP 클라이언트는 이를 HTTP 요청의 "Host" 헤더 필드 값으로 사용합니다.

```text
   GET / HTTP/1.1
   Host: www.example.com
```

LEHO 레코드가 없는 경우 "www.example.gns.alt" 자체가 영역 위임 레코드를 가리키는지 확인하기 위해 추가 GNS 확인이 필요합니다. 이는 원래 확인된 레코드 세트가 apex 레이블 아래에 게시되었음을 의미합니다. .

그렇다면 고유한 GNS 이름은 단순히 위임된 영역의 zTLD 표현입니다.

```text
   GET / HTTP/1.1
   Host: 000G0037FH3QTBCK15Y8BCCNRVWPV17ZC7TSGB1C9ZG2TPGHZVFV1GMG3W
```

반면에 "www.example.gns.alt"에 대한 영역 위임 기록이 없는 경우 고유 GNS 이름은 가장 왼쪽 레이블\(예: "www"\)과 영역의 zTLD 표현을 연결한 것입니다.

```text
   GET / HTTP/1.1
   Host: www.000G0037FH3QTBCK15Y8BCCNRVWPV17ZC7TSGB1C9ZG2TPGHZVFV1GMG3W
```

이 두 번째 GNS 확인에는 섹션 7.3.4의 마지막 문장에 언급된 예외에 따라 로컬 기록 처리만 다르기 때문에 추가 네트워크 작업이 필요하지 않습니다.

HTTP 클라이언트가 브라우저인 경우 가상 호스팅 또는 TLS SNI에 대한 고유 GNS 이름의 사용이 반드시 사용자에게 표시될 필요는 없습니다. 예를 들어, "Host" 헤더에 사용된 고유 이름이 다르더라도 URL 표시줄의 이름은 "www.example.gns.alt"로 유지될 수 있습니다.

---
### **A.4.  Migration Paths**

DNS 확인은 다양한 기존 소프트웨어 구성 요소, 특히 운영 체제와 HTTP 클라이언트에 내장되어 있습니다. 이 섹션에서는 레거시 애플리케이션이 GNS 이름을 확인할 수 있도록 하기 위해 두 가지 모두에 대해 가능한 마이그레이션 경로를 보여줍니다.

GNS 이름 확인을 효율적으로 촉진하는 한 가지 방법은 GNS 지원 DNS 서버 구현을 이용하는 것입니다. 따라서 로컬 DNS 쿼리는 로컬로 실행되는 "DNS-to-GNS" 서버에 의해 해결되도록 다시 라우팅되거나 명시적으로 구성됩니다. 이 DNS 서버는 이름에 대해 들어오는 쿼리를 GNS 확인 요청으로 해석하려고 합니다. 이름에 대한 시작 영역을 찾을 수 없고 zTLD로 끝나지 않는 경우 서버는 DNS에서 이름 확인을 시도합니다. 그렇지 않으면 이름이 GNS에서 확인됩니다. 후자의 경우 결과 레코드 세트는 DNS 응답 패킷으로 변환되어 그에 따라 반환됩니다. DNS-GNS 서버의 구현은 \[GNUnet\]에서 찾을 수 있습니다.

비슷한 접근 방식은 NSS \[nsswitch\]와 같은 운영 체제 확장을 사용하는 것입니다. 이를 통해 시스템 관리자는 호스트 이름 확인에 사용되는 플러그인을 구성할 수 있습니다. GNS nsswitch 플러그인은 DNS-GNS 서버에 사용되는 것과 유사한 방식으로 사용할 수 있습니다. GNS용 glibc 호환 nsswitch 플러그인 구현은 \[GNUnet\]에서 찾을 수 있습니다.

위의 방법은 일반적으로 HTTP 클라이언트 소프트웨어에도 효과적입니다. 그러나 HTTP 클라이언트는 일반적으로 TLS와 함께 사용됩니다. TLS 인증서 검증, 특히 SNI에는 GNS 이름이 사용될 때 HTTP 클라이언트에 추가 논리가 필요합니다\(부록 A.3\). 마이그레이션 목적으로 이 기능을 투명하게 활성화하려면 도메인 이름을 확인하도록 로컬 GNS 인식 SOCKS5 프록시 \[RFC1928\]를 구성할 수 있습니다. DNS-GNS 서버와 유사한 SOCKS5 프록시는 GNS 및 DNS 이름을 모두 확인할 수 있습니다. GNS 이름을 사용한 TLS 연결 요청이 있는 경우 SOCKS5 프록시는 TLS 연결을 종료하고 요청된 호스트에 대해 보안 연결을 설정할 수 있습니다. 보안 연결을 설정하기 위해 프록시는 GNS 이름 아래에 설정된 레코드에 저장된 LEHO 및 TLSA 레코드를 사용할 수 있습니다. 프록시는 GNS 이름에 대해 로컬로 신뢰할 수 있는 인증서를 HTTP 클라이언트에 제공해야 합니다. 이를 위해서는 일반적으로 브라우저에서 로컬 트러스트 앵커를 생성하고 구성해야 합니다. 이 SOCKS5 프록시의 구현은 \[GNUnet\]에서 찾을 수 있습니다.

---
# **Appendix B.  Example Flows**
---
### **B.1.  AAAA Example Resolution**

```text
                              Local Host             |   Remote
                                                     |   Storage
                                                     |
                                                     |    +---------+
                                                     |   /         /|
                                                     |  +---------+ |
   +-----------+ (1)      +----------+               |  |         | |
   |           |          |          |      (4,6)    |  | Record  | |
   |Application|----------| Resolver |---------------|->| Storage | |
   |           |<---------|          |<--------------|--|         |/
   +-----------+ (8)      +----------+      (5,7)    |  +---------+
                             A                       |
                             |                       |
                       (2,3) |                       |
                             |                       |
                             |                       |
                          +---------+                |
                         /   v     /|                |
                        +---------+ |                |
                        |         | |                |
                        |  Start  | |                |
                        |  Zones  | |                |
                        |         |/                 |
                        +---------+                  |

              Figure 24: Example Resolution of an IPv6 Address
```

1. 이름이 "www.example.gnu.gns.alt"인 AAAA 레코드를 찾습니다.

2. "www.example.gnu.gns.alt"의 시작 영역을 결정합니다.

```text
   3.  Start Zone: zkey0 - Remainder: "www.example".
```

4. q0=SHA512\(ZKDF\(zkey0, "example"\)\)을 계산하고 GET\(q0\)을 시작합니다.

5. zkey1이 포함된 단일 PKEY 레코드로 구성된 RRBLOCK을 검색하고 해독합니다.

6. q1=SHA512\(ZKDF\(zkey1, "www"\)\)를 계산하고 GET\(q1\)을 시작합니다.

7. IPv6 주소 2001:db8::1을 포함하는 단일 AAAA 레코드로 구성된 RRBLOCK을 검색합니다.

8. 신청서에 설정된 기록을 반환합니다.

---
### **B.2.  REDIRECT Example Resolution**

```text
                              Local Host              |   Remote
                                                      |   Storage
                                                      |
                                                      |    +---------+
                                                      |   /         /|
                                                      |  +---------+ |
   +-----------+ (1)      +----------+                |  |         | |
   |           |          |          |      (4,6,8)   |  | Record  | |
   |Application|----------| Resolver |----------------|->| Storage | |
   |           |<---------|          |<---------------|--|         |/
   +-----------+ (10)     +----------+      (5,7,9)   |  +---------+
                             A                        |
                             |                        |
                       (2,3) |                        |
                             |                        |
                             |                        |
                          +---------+                 |
                         /   v     /|                 |
                        +---------+ |                 |
                        |         | |                 |
                        |  Start  | |                 |
                        |  Zones  | |                 |
                        |         |/                  |
                        +---------+                   |

       Figure 25: Example Resolution of an IPv6 Address with Redirect
```

1. AAAA 레코드에서 이름 "www.example.tld.gns.alt"를 찾습니다.

2. "www.example.tld.gns.alt"에 대한 시작 영역을 결정합니다.

```text
   3.   Start Zone: zkey0 - Remainder: "www.example".
```

4. q0=SHA512\(ZKDF\(zkey0, "example"\)\)을 계산하고 GET\(q0\)을 시작합니다.

5. zkey1이 포함된 단일 PKEY 레코드로 구성된 RRBLOCK을 검색하고 해독합니다.

6. q1=SHA512\(ZKDF\(zkey1, "www"\)\)를 계산하고 GET\(q1\)을 시작합니다.

7. "www2.+"를 포함하는 단일 REDIRECT 레코드로 구성된 RRBLOCK을 검색하고 해독합니다.

8. q2=SHA512\(ZKDF\(zkey1, "www2"\)\)를 계산하고 GET\(q2\)를 시작합니다.

9. IPv6 주소 2001:db8::1을 포함하는 단일 AAAA 레코드로 구성된 RRBLOCK을 검색하고 해독합니다.

10. 신청서에 설정된 기록을 반환합니다.

---
### **B.3.  GNS2DNS Example Resolution**

```text
                              Local Host                |   Remote
                                                        |   Storage
                                                        |
                                                        |    +---------+
                                                        |   /         /|
                                                        |  +---------+ |
   +-----------+ (1)      +----------+                  |  |         | |
   |           |          |          |      (4)         |  | Record  | |
   |Application|----------| Resolver |------------------|->| Storage | |
   |           |<---------|          |<-----------------|--|         |/
   +-----------+ (8)      +----------+      (5)         |  +---------+
                             A    A                     |
                             |    |    (6,7)            |
                       (2,3) |    +----------+          |
                             |               |          |
                             |               v          |
                          +---------+    +------------+ |
                         /   v     /|    | System DNS | |
                        +---------+ |    | Resolver   | |
                        |         | |    +------------+ |
                        |  Start  | |                   |
                        |  Zones  | |                   |
                        |         |/                    |
                        +---------+                     |

     Figure 26: Example Resolution of an IPv6 Address with DNS Handover
```

1. 이름이 "www.example.gnu.gns.alt"인 AAAA 레코드를 찾습니다.

2. "www.example.gnu.gns.alt"의 시작 영역을 결정합니다.

```text
   3.  Start Zone: zkey0 - Remainder: "www.example".
```

4. q0=SHA512\(ZKDF\(zkey0, "example"\)\)을 계산하고 GET\(q0\)을 시작합니다.

5. 이름 "example.com"과 DNS 서버 IPv4 주소 192.0.2.1을 포함하는 단일 GNS2DNS 레코드로 구성된 RRBLOCK을 검색하고 해독합니다.

6. 시스템 확인자를 사용하여 DNS 이름 "www.example.com"에 대한 AAAA 레코드를 조회합니다.

7. 단일 AAAA 레코드로 구성된 DNS 응답을 검색합니다.

- IPv6 주소 2001:db8::1을 포함합니다.

8. 신청서에 설정된 기록을 반환합니다.

---
# **Appendix C.  Base32GNS**

인코딩은 바이트 배열을 기호 문자열로 변환합니다. 디코딩은 기호 문자열을 바이트 배열로 변환합니다. 입력 문자열에 정의된 세트 외부의 기호가 있으면 디코딩이 실패합니다.

표 4는 주어진 기호 값에 대한 인코딩 및 디코딩 기호를 정의합니다. 각 기호 값은 5비트를 인코딩합니다. 다음과 같이 읽어 인코딩을 구현하는 데 사용할 수 있습니다. 디코딩 시 기호 "A" 또는 "a"는 5비트 값 10으로 디코딩됩니다. 값이 18인 5비트 블록은 인코딩 시 문자 "J"로 인코딩됩니다. 인코딩할 바이트 문자열의 비트 길이가 5의 배수가 아닌 경우 다음 배수에 0으로 채워집니다. 문자 인식 실패에 대한 허용치를 더욱 높이려면 문자 "U"를 Base32GNS의 문자 "V"와 동일한 값으로 디코딩해야 합니다.\(MUST\)

```text
           +==============+=================+=================+
           | Symbol Value | Decoding Symbol | Encoding Symbol |
           +==============+=================+=================+
           | 0            | 0 O o           | 0               |
           +--------------+-----------------+-----------------+
           | 1            | 1 I i L l       | 1               |
           +--------------+-----------------+-----------------+
           | 2            | 2               | 2               |
           +--------------+-----------------+-----------------+
           | 3            | 3               | 3               |
           +--------------+-----------------+-----------------+
           | 4            | 4               | 4               |
           +--------------+-----------------+-----------------+
           | 5            | 5               | 5               |
           +--------------+-----------------+-----------------+
           | 6            | 6               | 6               |
           +--------------+-----------------+-----------------+
           | 7            | 7               | 7               |
           +--------------+-----------------+-----------------+
           | 8            | 8               | 8               |
           +--------------+-----------------+-----------------+
           | 9            | 9               | 9               |
           +--------------+-----------------+-----------------+
           | 10           | A a             | A               |
           +--------------+-----------------+-----------------+
           | 11           | B b             | B               |
           +--------------+-----------------+-----------------+
           | 12           | C c             | C               |
           +--------------+-----------------+-----------------+
           | 13           | D d             | D               |
           +--------------+-----------------+-----------------+
           | 14           | E e             | E               |
           +--------------+-----------------+-----------------+
           | 15           | F f             | F               |
           +--------------+-----------------+-----------------+
           | 16           | G g             | G               |
           +--------------+-----------------+-----------------+
           | 17           | H h             | H               |
           +--------------+-----------------+-----------------+
           | 18           | J j             | J               |
           +--------------+-----------------+-----------------+
           | 19           | K k             | K               |
           +--------------+-----------------+-----------------+
           | 20           | M m             | M               |
           +--------------+-----------------+-----------------+
           | 21           | N n             | N               |
           +--------------+-----------------+-----------------+
           | 22           | P p             | P               |
           +--------------+-----------------+-----------------+
           | 23           | Q q             | Q               |
           +--------------+-----------------+-----------------+
           | 24           | R r             | R               |
           +--------------+-----------------+-----------------+
           | 25           | S s             | S               |
           +--------------+-----------------+-----------------+
           | 26           | T t             | T               |
           +--------------+-----------------+-----------------+
           | 27           | V v U u         | V               |
           +--------------+-----------------+-----------------+
           | 28           | W w             | W               |
           +--------------+-----------------+-----------------+
           | 29           | X x             | X               |
           +--------------+-----------------+-----------------+
           | 30           | Y y             | Y               |
           +--------------+-----------------+-----------------+
           | 31           | Z z             | Z               |
           +--------------+-----------------+-----------------+

              Table 4: The Base32GNS Alphabet, Including the
                      Additional Encoding Symbol "U"
```

---
# **Appendix D.  Test Vectors**

구현 시 다음 테스트 벡터를 사용하여 이 사양에 대한 적합성을 테스트할 수 있습니다. 달리 명시하지 않는 한 테스트 벡터는 16진수 바이트 배열로 제공됩니다.

---
### **D.1.  Base32GNS Encoding/Decoding**

다음은 zTLD에 사용되는 Base32GNS 인코딩에 대한 테스트 벡터입니다. 입력 문자열은 0 종결자 없이 인코딩됩니다.

```text
   Base32GNS-Encode:
     Input string: "Hello World"
     Output string: "91JPRV3F41BPYWKCCG"

     Input bytes: 474e55204e616d652053797374656d
     Output string: "8X75A82EC5PPA82KF5SQ8SBD"

   Base32GNS-Decode:
     Input string: "91JPRV3F41BPYWKCCG"
     Output string: "Hello World"

     Input string: "91JPRU3F41BPYWKCCG"
     Output string: "Hello World"
```

---
### **D.2.  Record Sets**

테스트 벡터에는 PKEY 및 EDKEY 영역 모두에 대한 다양한 레코드 유형과 플래그가 있는 레코드 세트가 포함되어 있습니다. 여기에는 국제화된 레이블을 보여주기 위해 UTF-8 문자가 포함된 레이블이 포함됩니다.

```text
   *(1) PKEY zone with ASCII label and one delegation record*

   Zone private key (d, big-endian):
     50 d7 b6 52 a4 ef ea df
     f3 73 96 90 97 85 e5 95
     21 71 a0 21 78 c8 e7 d4
     50 fa 90 79 25 fa fd 98

   Zone identifier (ztype|zkey):
     00 01 00 00 67 7c 47 7d
     2d 93 09 7c 85 b1 95 c6
     f9 6d 84 ff 61 f5 98 2c
     2c 4f e0 2d 5a 11 fe df
     b0 c2 90 1f

   zTLD:
   000G0037FH3QTBCK15Y8BCCNRVWPV17ZC7TSGB1C9ZG2TPGHZVFV1GMG3W

   Label:
     74 65 73 74 64 65 6c 65
     67 61 74 69 6f 6e
```

레코드 수\(정수\): 1

```text
   Record #0 := (
     EXPIRATION: 8143584694000000 us
     00 1c ee 8c 10 e2 59 80

     DATA_SIZE:
     00 20

     TYPE:
     00 01 00 00

     FLAGS:   00 01

     DATA:
     21 e3 b3 0f f9 3b c6 d3
     5a c8 c6 e0 e1 3a fd ff
     79 4c b7 b4 4b bb c7 48
     d2 59 d0 a0 28 4d be 84

   )

   RDATA:
     00 1c ee 8c 10 e2 59 80
     00 20 00 01 00 01 00 00
     21 e3 b3 0f f9 3b c6 d3
     5a c8 c6 e0 e1 3a fd ff
     79 4c b7 b4 4b bb c7 48
     d2 59 d0 a0 28 4d be 84

   Encryption NONCE|EXPIRATION|BLOCK COUNTER:
     e9 0a 00 61 00 1c ee 8c
     10 e2 59 80 00 00 00 01

   Encryption key (K):
     86 4e 71 38 ea e7 fd 91
     a3 01 36 89 9c 13 2b 23
     ac eb db 2c ef 43 cb 19
     f6 bf 55 b6 7d b9 b3 b3

   Storage key (q):
     4a dc 67 c5 ec ee 9f 76
     98 6a bd 71 c2 22 4a 3d
     ce 2e 91 70 26 c9 a0 9d
     fd 44 ce f3 d2 0f 55 a2
     73 32 72 5a 6c 8a fb bb
     b0 f7 ec 9a f1 cc 42 64
     12 99 40 6b 04 fd 9b 5b
     57 91 f8 6c 4b 08 d5 f4

   ZKDF(zkey, label):
     18 2b b6 36 ed a7 9f 79
     57 11 bc 27 08 ad bb 24
     2a 60 44 6a d3 c3 08 03
     12 1d 03 d3 48 b7 ce b6

   Derived private key (d', big-endian):
     0a 4c 5e 0f 00 63 df ce
     db c8 c7 f2 b2 2c 03 0c
     86 28 b2 c2 cb ac 9f a7
     29 aa e6 1f 89 db 3e 9c

   BDATA:
     0c 1e da 5c c0 94 a1 c7
     a8 88 64 9d 25 fa ee bd
     60 da e6 07 3d 57 d8 ae
     8d 45 5f 4f 13 92 c0 74
     e2 6a c6 69 bd ee c2 34
     62 b9 62 95 2c c6 e9 eb

   RRBLOCK:
     00 00 00 a0 00 01 00 00
     18 2b b6 36 ed a7 9f 79
     57 11 bc 27 08 ad bb 24
     2a 60 44 6a d3 c3 08 03
     12 1d 03 d3 48 b7 ce b6
     0a d1 0b c1 3b 40 3b 5b
     25 61 26 b2 14 5a 6f 60
     c5 14 f9 51 ff a7 66 f7
     a3 fd 4b ac 4a 4e 19 90
     05 5c b8 7e 8d 1b fd 19
     aa 09 a4 29 f7 29 e9 f5
     c6 ee c2 47 0a ce e2 22
     07 59 e9 e3 6c 88 6f 35
     00 1c ee 8c 10 e2 59 80
     0c 1e da 5c c0 94 a1 c7
     a8 88 64 9d 25 fa ee bd
     60 da e6 07 3d 57 d8 ae
     8d 45 5f 4f 13 92 c0 74
     e2 6a c6 69 bd ee c2 34
     62 b9 62 95 2c c6 e9 eb

   *(2) PKEY zone with UTF-8 label and three records*

   Zone private key (d, big-endian):
     50 d7 b6 52 a4 ef ea df
     f3 73 96 90 97 85 e5 95
     21 71 a0 21 78 c8 e7 d4
     50 fa 90 79 25 fa fd 98

   Zone identifier (ztype|zkey):
     00 01 00 00 67 7c 47 7d
     2d 93 09 7c 85 b1 95 c6
     f9 6d 84 ff 61 f5 98 2c
     2c 4f e0 2d 5a 11 fe df
     b0 c2 90 1f

   zTLD:
   000G0037FH3QTBCK15Y8BCCNRVWPV17ZC7TSGB1C9ZG2TPGHZVFV1GMG3W

   Label:
     e5 a4 a9 e4 b8 8b e7 84
     a1 e6 95 b5
```

레코드 수\(정수\): 3

```text
   Record #0 := (
     EXPIRATION: 8143584694000000 us
     00 1c ee 8c 10 e2 59 80

     DATA_SIZE:
     00 10

     TYPE:
     00 00 00 1c

     FLAGS:   00 00

     DATA:
     00 00 00 00 00 00 00 00
     00 00 00 00 de ad be ef

   )

   Record #1 := (
     EXPIRATION: 17999736901000000 us
     00 3f f2 aa 54 08 db 40

     DATA_SIZE:
     00 06

     TYPE:
     00 01 00 01

     FLAGS:   00 00

     DATA:
     e6 84 9b e7 a7 b0

   )

   Record #2 := (
     EXPIRATION: 11464693629000000 us
     00 28 bb 13 ff 37 19 40

     DATA_SIZE:
     00 0b

     TYPE:
     00 00 00 10

     FLAGS:   00 04

     DATA:
     48 65 6c 6c 6f 20 57 6f
     72 6c 64

   )

   RDATA:
     00 1c ee 8c 10 e2 59 80
     00 10 00 00 00 00 00 1c
     00 00 00 00 00 00 00 00
     00 00 00 00 de ad be ef
     00 3f f2 aa 54 08 db 40
     00 06 00 00 00 01 00 01
     e6 84 9b e7 a7 b0 00 28
     bb 13 ff 37 19 40 00 0b
     00 04 00 00 00 10 48 65
     6c 6c 6f 20 57 6f 72 6c
     64 00 00 00 00 00 00 00
     00 00 00 00 00 00 00 00
     00 00 00 00 00 00 00 00
     00 00 00 00 00 00 00 00
     00 00 00 00 00 00 00 00
     00 00 00 00 00 00 00 00

   Encryption NONCE|EXPIRATION|BLOCK COUNTER:
     ee 96 33 c1 00 1c ee 8c
     10 e2 59 80 00 00 00 01

   Encryption key (K):
     fb 3a b5 de 23 bd da e1
     99 7a af 7b 92 c2 d2 71
     51 40 8b 77 af 7a 41 ac
     79 05 7c 4d f5 38 3d 01

   Storage key (q):
     af f0 ad 6a 44 09 73 68
     42 9a c4 76 df a1 f3 4b
     ee 4c 36 e7 47 6d 07 aa
     64 63 ff 20 91 5b 10 05
     c0 99 1d ef 91 fc 3e 10
     90 9f 87 02 c0 be 40 43
     67 78 c7 11 f2 ca 47 d5
     5c f0 b5 4d 23 5d a9 77

   ZKDF(zkey, label):
     a5 12 96 df 75 7e e2 75
     ca 11 8d 4f 07 fa 7a ae
     55 08 bc f5 12 aa 41 12
     14 29 d4 a0 de 9d 05 7e

   Derived private key (d', big-endian):
     0a be 56 d6 80 68 ab 40
     e1 44 79 0c de 9a cf 4d
     78 7f 2d 3c 63 b8 53 05
     74 6e 68 03 32 15 f2 ab

   BDATA:
     d8 c2 8d 2f d6 96 7d 1a
     b7 22 53 f2 10 98 b8 14
     a4 10 be 1f 59 98 de 03
     f5 8f 7e 7c db 7f 08 a6
     16 51 be 4d 0b 6f 8a 61
     df 15 30 44 0b d7 47 dc
     f0 d7 10 4f 6b 8d 24 c2
     ac 9b c1 3d 9c 6f e8 29
     05 25 d2 a6 d0 f8 84 42
     67 a1 57 0e 8e 29 4d c9
     3a 31 9f cf c0 3e a2 70
     17 d6 fd a3 47 b4 a7 94
     97 d7 f6 b1 42 2d 4e dd
     82 1c 19 93 4e 96 c1 aa
     87 76 57 25 d4 94 c7 64
     b1 55 dc 6d 13 26 91 74

   RRBLOCK:
     00 00 00 f0 00 01 00 00
     a5 12 96 df 75 7e e2 75
     ca 11 8d 4f 07 fa 7a ae
     55 08 bc f5 12 aa 41 12
     14 29 d4 a0 de 9d 05 7e
     08 5b d6 5f d4 85 10 51
     ba ce 2a 45 2a fc 8a 7e
     4f 6b 2c 1f 74 f0 20 35
     d9 64 1a cd ba a4 66 e0
     00 ce d6 f2 d2 3b 63 1c
     8e 8a 0b 38 e2 ba e7 9a
     22 ca d8 1d 4c 50 d2 25
     35 8e bc 17 ac 0f 89 9e
     00 1c ee 8c 10 e2 59 80
     d8 c2 8d 2f d6 96 7d 1a
     b7 22 53 f2 10 98 b8 14
     a4 10 be 1f 59 98 de 03
     f5 8f 7e 7c db 7f 08 a6
     16 51 be 4d 0b 6f 8a 61
     df 15 30 44 0b d7 47 dc
     f0 d7 10 4f 6b 8d 24 c2
     ac 9b c1 3d 9c 6f e8 29
     05 25 d2 a6 d0 f8 84 42
     67 a1 57 0e 8e 29 4d c9
     3a 31 9f cf c0 3e a2 70
     17 d6 fd a3 47 b4 a7 94
     97 d7 f6 b1 42 2d 4e dd
     82 1c 19 93 4e 96 c1 aa
     87 76 57 25 d4 94 c7 64
     b1 55 dc 6d 13 26 91 74

   *(3) EDKEY zone with ASCII label and one delegation record*

   Zone private key (d):
     5a f7 02 0e e1 91 60 32
     88 32 35 2b bc 6a 68 a8
     d7 1a 7c be 1b 92 99 69
     a7 c6 6d 41 5a 0d 8f 65

   Zone identifier (ztype|zkey):
     00 01 00 14 3c f4 b9 24
     03 20 22 f0 dc 50 58 14
     53 b8 5d 93 b0 47 b6 3d
     44 6c 58 45 cb 48 44 5d
     db 96 68 8f

   zTLD:
   000G051WYJWJ80S04BRDRM2R2H9VGQCKP13VCFA4DHC4BJT88HEXQ5K8HW

   Label:
     74 65 73 74 64 65 6c 65
     67 61 74 69 6f 6e
```

레코드 수\(정수\): 1

```text
   Record #0 := (
     EXPIRATION: 8143584694000000 us
     00 1c ee 8c 10 e2 59 80

     DATA_SIZE:
     00 20

     TYPE:
     00 01 00 00

     FLAGS:   00 01

     DATA:
     21 e3 b3 0f f9 3b c6 d3
     5a c8 c6 e0 e1 3a fd ff
     79 4c b7 b4 4b bb c7 48
     d2 59 d0 a0 28 4d be 84

   )

   RDATA:
     00 1c ee 8c 10 e2 59 80
     00 20 00 01 00 01 00 00
     21 e3 b3 0f f9 3b c6 d3
     5a c8 c6 e0 e1 3a fd ff
     79 4c b7 b4 4b bb c7 48
     d2 59 d0 a0 28 4d be 84

   Encryption NONCE|EXPIRATION:
     98 13 2e a8 68 59 d3 5c
     88 bf d3 17 fa 99 1b cb
     00 1c ee 8c 10 e2 59 80

   Encryption key (K):
     85 c4 29 a9 56 7a a6 33
     41 1a 96 91 e9 09 4c 45
     28 16 72 be 58 60 34 aa
     e4 a2 a2 cc 71 61 59 e2

   Storage key (q):
     ab aa ba c0 e1 24 94 59
     75 98 83 95 aa c0 24 1e
     55 59 c4 1c 40 74 e2 55
     7b 9f e6 d1 54 b6 14 fb
     cd d4 7f c7 f5 1d 78 6d
     c2 e0 b1 ec e7 60 37 c0
     a1 57 8c 38 4e c6 1d 44
     56 36 a9 4e 88 03 29 e9

   ZKDF(zkey, label):
     9b f2 33 19 8c 6d 53 bb
     db ac 49 5c ab d9 10 49
     a6 84 af 3f 40 51 ba ca
     b0 dc f2 1c 8c f2 7a 1a

   nonce := SHA-256(dh[32..63] || h):
     14 f2 c0 6b ed c3 aa 2d
     f0 71 13 9c 50 39 34 f3
     4b fa 63 11 a8 52 f2 11
     f7 3a df 2e 07 61 ec 35

   Derived private key (d', big-endian):
     3b 1b 29 d4 23 0b 10 a8
     ec 4d a3 c8 6e db 88 ea
     cd 54 08 5c 1d db 63 f7
     a9 d7 3f 7c cb 2f c3 98

   BDATA:
     57 7c c6 c9 5a 14 e7 04
     09 f2 0b 01 67 e6 36 d0
     10 80 7c 4f 00 37 2d 69
     8c 82 6b d9 2b c2 2b d6
     bb 45 e5 27 7c 01 88 1d
     6a 43 60 68 e4 dd f1 c6
     b7 d1 41 6f af a6 69 7c
     25 ed d9 ea e9 91 67 c3

   RRBLOCK:
     00 00 00 b0 00 01 00 14
     9b f2 33 19 8c 6d 53 bb
     db ac 49 5c ab d9 10 49
     a6 84 af 3f 40 51 ba ca
     b0 dc f2 1c 8c f2 7a 1a
     9f 56 a8 86 ea 73 9d 59
     17 50 8f 9b 75 56 39 f3
     a9 ac fa ed ed ca 7f bf
     a7 94 b1 92 e0 8b f9 ed
     4c 7e c8 59 4c 9f 7b 4e
     19 77 4f f8 38 ec 38 7a
     8f 34 23 da ac 44 9f 59
     db 4e 83 94 3f 90 72 00
     00 1c ee 8c 10 e2 59 80
     57 7c c6 c9 5a 14 e7 04
     09 f2 0b 01 67 e6 36 d0
     10 80 7c 4f 00 37 2d 69
     8c 82 6b d9 2b c2 2b d6
     bb 45 e5 27 7c 01 88 1d
     6a 43 60 68 e4 dd f1 c6
     b7 d1 41 6f af a6 69 7c
     25 ed d9 ea e9 91 67 c3

   *(4) EDKEY zone with UTF-8 label and three records*

   Zone private key (d):
     5a f7 02 0e e1 91 60 32
     88 32 35 2b bc 6a 68 a8
     d7 1a 7c be 1b 92 99 69
     a7 c6 6d 41 5a 0d 8f 65

   Zone identifier (ztype|zkey):
     00 01 00 14 3c f4 b9 24
     03 20 22 f0 dc 50 58 14
     53 b8 5d 93 b0 47 b6 3d
     44 6c 58 45 cb 48 44 5d
     db 96 68 8f

   zTLD:
   000G051WYJWJ80S04BRDRM2R2H9VGQCKP13VCFA4DHC4BJT88HEXQ5K8HW

   Label:
     e5 a4 a9 e4 b8 8b e7 84
     a1 e6 95 b5
```

레코드 수\(정수\): 3

```text
   Record #0 := (
     EXPIRATION: 8143584694000000 us
     00 1c ee 8c 10 e2 59 80

     DATA_SIZE:
     00 10

     TYPE:
     00 00 00 1c

     FLAGS:   00 00

     DATA:
     00 00 00 00 00 00 00 00
     00 00 00 00 de ad be ef

   )

   Record #1 := (
     EXPIRATION: 17999736901000000 us
     00 3f f2 aa 54 08 db 40

     DATA_SIZE:
     00 06

     TYPE:
     00 01 00 01

     FLAGS:   00 00

     DATA:
     e6 84 9b e7 a7 b0

   )

   Record #2 := (
     EXPIRATION: 11464693629000000 us
     00 28 bb 13 ff 37 19 40

     DATA_SIZE:
     00 0b

     TYPE:
     00 00 00 10

     FLAGS:   00 04

     DATA:
     48 65 6c 6c 6f 20 57 6f
     72 6c 64

   )

   RDATA:
     00 1c ee 8c 10 e2 59 80
     00 10 00 00 00 00 00 1c
     00 00 00 00 00 00 00 00
     00 00 00 00 de ad be ef
     00 3f f2 aa 54 08 db 40
     00 06 00 00 00 01 00 01
     e6 84 9b e7 a7 b0 00 28
     bb 13 ff 37 19 40 00 0b
     00 04 00 00 00 10 48 65
     6c 6c 6f 20 57 6f 72 6c
     64 00 00 00 00 00 00 00
     00 00 00 00 00 00 00 00
     00 00 00 00 00 00 00 00
     00 00 00 00 00 00 00 00
     00 00 00 00 00 00 00 00
     00 00 00 00 00 00 00 00

   Encryption NONCE|EXPIRATION:
     bb 0d 3f 0f bd 22 42 77
     50 da 5d 69 12 16 e6 c9
     00 1c ee 8c 10 e2 59 80

   Encryption key (K):
     3d f8 05 bd 66 87 aa 14
     20 96 28 c2 44 b1 11 91
     88 c3 92 56 37 a4 1e 5d
     76 49 6c 29 45 dc 37 7b

   Storage key (q):
     ba f8 21 77 ee c0 81 e0
     74 a7 da 47 ff c6 48 77
     58 fb 0d f0 1a 6c 7f bb
     52 fc 8a 31 be f0 29 af
     74 aa 0d c1 5a b8 e2 fa
     7a 54 b4 f5 f6 37 f6 15
     8f a7 f0 3c 3f ce be 78
     d3 f9 d6 40 aa c0 d1 ed

   ZKDF(zkey, label):
     74 f9 00 68 f1 67 69 53
     52 a8 a6 c2 eb 98 48 98
     c5 3a cc a0 98 04 70 c6
     c8 12 64 cb dd 78 ad 11

   nonce := SHA-256(dh[32..63] || h):
     f8 6a b5 33 8a 74 d7 a1
     d2 77 ea 11 ff 95 cb e8
     3a cf d3 97 3b b4 ab ca
     0a 1b 60 62 c3 7a b3 9c

   Derived private key (d', big-endian):
     17 c0 68 a6 c3 f7 20 de
     0e 1b 69 ff 3f 53 e0 5d
     3f e5 c5 b0 51 25 7a 89
     a6 3c 1a d3 5a c4 35 58

   BDATA:
     4e b3 5a 50 d4 0f e1 a4
     29 c7 f4 b2 67 a0 59 de
     4e 2c 8a 89 a5 ed 53 d3
     d4 92 58 59 d2 94 9f 7f
     30 d8 a2 0c aa 96 f8 81
     45 05 2d 1c da 04 12 49
     8f f2 5f f2 81 6e f0 ce
     61 fe 69 9b fa c7 2c 15
     dc 83 0e a9 b0 36 17 1c
     cf ca bb dd a8 de 3c 86
     ed e2 95 70 d0 17 4b 82
     82 09 48 a9 28 b7 f0 0e
     fb 40 1c 10 fe 80 bb bb
     02 76 33 1b f7 f5 1b 8d
     74 57 9c 14 14 f2 2d 50
     1a d2 5a e2 49 f5 bb f2
     a6 c3 72 59 d1 75 e4 40
     b2 94 39 c6 05 19 cb b1

   RRBLOCK:
     00 00 01 00 00 01 00 14
     74 f9 00 68 f1 67 69 53
     52 a8 a6 c2 eb 98 48 98
     c5 3a cc a0 98 04 70 c6
     c8 12 64 cb dd 78 ad 11
     75 6d 2c 15 7a d2 ea 4f
     c0 b1 b9 1c 08 03 79 44
     61 d3 de f2 0d d1 63 6c
     fe dc 03 89 c5 49 d1 43
     6c c3 5b 4e 1b f8 89 5a
     64 6b d9 a6 f4 6b 83 48
     1d 9c 0e 91 d4 e1 be bb
     6a 83 52 6f b7 25 2a 06
     00 1c ee 8c 10 e2 59 80
     4e b3 5a 50 d4 0f e1 a4
     29 c7 f4 b2 67 a0 59 de
     4e 2c 8a 89 a5 ed 53 d3
     d4 92 58 59 d2 94 9f 7f
     30 d8 a2 0c aa 96 f8 81
     45 05 2d 1c da 04 12 49
     8f f2 5f f2 81 6e f0 ce
     61 fe 69 9b fa c7 2c 15
     dc 83 0e a9 b0 36 17 1c
     cf ca bb dd a8 de 3c 86
     ed e2 95 70 d0 17 4b 82
     82 09 48 a9 28 b7 f0 0e
     fb 40 1c 10 fe 80 bb bb
     02 76 33 1b f7 f5 1b 8d
     74 57 9c 14 14 f2 2d 50
     1a d2 5a e2 49 f5 bb f2
     a6 c3 72 59 d1 75 e4 40
     b2 94 39 c6 05 19 cb b1
```

---
### **D.3.  Zone Revocation**

다음은 PKEY 영역에 대한 해지 예시입니다.

```text
   Zone private key (d, big-endian):
     6f ea 32 c0 5a f5 8b fa
     97 95 53 d1 88 60 5f d5
     7d 8b f9 cc 26 3b 78 d5
     f7 47 8c 07 b9 98 ed 70

   Zone identifier (ztype|zkey):
     00 01 00 00 2c a2 23 e8
     79 ec c4 bb de b5 da 17
     31 92 81 d6 3b 2e 3b 69
     55 f1 c3 77 5c 80 4a 98
     d5 f8 dd aa

   zTLD:
   000G001CM8HYGYFCRJXXXDET2WRS50EP7CQ3PTANY71QEQ409ACDBY6XN8

   Difficulty (5 base difficulty + 2 epochs): 7

   Signed message:
     00 00 00 34 00 00 00 03
     00 05 ff 1c 56 e4 b2 68
     00 01 00 00 2c a2 23 e8
     79 ec c4 bb de b5 da 17
     31 92 81 d6 3b 2e 3b 69
     55 f1 c3 77 5c 80 4a 98
     d5 f8 dd aa
```

증명: 00 05 ff 1c 56 e4 b2 68 00 00 39 5d 18 27 c0 00 38 0b 54 aa 70 16 ac a2 38 0b 54 aa 70 16 ad 62 38 0b 54 aa 70 16 af 3e 38 0b 54 aa 70 16 af 93 38 0b 54 aa 70 16 b0 bf 38 0b 54 aa 70 16 b0 ee 38 0b 54 aa 70 16 b1 c9 38 0b 54 aa 70 16 b1 e5 38 0b 54 aa 70 16 b2 78 38 0b 54 aa 70 1 6b2b2 380b 54 aa 70 16 b2 d6 38 0b 54 aa 70 16 b2 e4 38 0b 54 aa 70 16 b3 2c 38 0b 54 aa 70 16 b3 5a 38 0b 54 aa 70 16 b3 9d 38 0b 54 aa 70 16 b3 c 0 38 0b 54 AA 70 16 b3 dd 38 0b 54 aa 70 16 b3 f4 38 0b 54 aa 70 16 b4 42 38 0b 54 aa 70 16 b4 76 38 0b 54 aa 70 16 b4 8c 38 0b 54 aa 70 16 b4 a4 38 0b 54 AA 70 16 b4 c9 38 0b 54 aa 70 16 b4 f0 38 0b 54 aa 70 16 b4 f7 38 0b 54 aa 70 16 b5 79 38 0b 54 aa 70 16 b6 34 38 0b 54 aa 70 16 b6 8e 38 0b 54 a 70 16 b7 b4 38 0b 54 aa 70 16 b8 7e 38 0b 54 aa 70 16 b8 f8 38 0b 54 aa 70 16 b9 2a 00 01 00 00 2c a2 23 e8 79 ec c4 bb de b5 da 17 31 92 81 d6 3b 2e 3 b 69 55 f1 c3 77 5c 80 4a 98 d5 f8 dd aa 08 ca ff de 3c 6d f1 45 f7 e0 79 81 15 37 b2 b0 42 2d 5e 1f b2 01 97 81 ec a2 61 d1 f9 d8 ea 81 0a bc 2f 33 47 7f 04e3 64 81 11 있다 71 c2 48 82 1a d6 04 f4 94 e7 4d 0b f5 11 d2 c1 62 77 2e 81

다음은 EDKEY 영역에 대한 해지 예시입니다.

```text
   Zone private key (d):
     5a f7 02 0e e1 91 60 32
     88 32 35 2b bc 6a 68 a8
     d7 1a 7c be 1b 92 99 69
     a7 c6 6d 41 5a 0d 8f 65

   Zone identifier (ztype|zkey):
     00 01 00 14 3c f4 b9 24
     03 20 22 f0 dc 50 58 14
     53 b8 5d 93 b0 47 b6 3d
     44 6c 58 45 cb 48 44 5d
     db 96 68 8f

   zTLD:
   000G051WYJWJ80S04BRDRM2R2H9VGQCKP13VCFA4DHC4BJT88HEXQ5K8HW

   Difficulty (5 base difficulty + 2 epochs): 7

   Signed message:
     00 00 00 34 00 00 00 03
     00 05 ff 1c 57 35 42 bd
     00 01 00 14 3c f4 b9 24
     03 20 22 f0 dc 50 58 14
     53 b8 5d 93 b0 47 b6 3d
     44 6c 58 45 cb 48 44 5d
     db 96 68 8f

   Proof:
     00 05 ff 1c 57 35 42 bd
     00 00 39 5d 18 27 c0 00
     58 4c 93 3c b0 99 2a 08
     58 4c 93 3c b0 99 2d f7
     58 4c 93 3c b0 99 2e 21
     58 4c 93 3c b0 99 2e 2a
     58 4c 93 3c b0 99 2e 53
     58 4c 93 3c b0 99 2e 8e
     58 4c 93 3c b0 99 2f 13
     58 4c 93 3c b0 99 2f 2d
     58 4c 93 3c b0 99 2f 3c
     58 4c 93 3c b0 99 2f 41
     58 4c 93 3c b0 99 2f fd
     58 4c 93 3c b0 99 30 33
     58 4c 93 3c b0 99 30 82
     58 4c 93 3c b0 99 30 a2
     58 4c 93 3c b0 99 30 e1
     58 4c 93 3c b0 99 31 ce
     58 4c 93 3c b0 99 31 de
     58 4c 93 3c b0 99 32 12
     58 4c 93 3c b0 99 32 4e
     58 4c 93 3c b0 99 32 9f
     58 4c 93 3c b0 99 33 31
     58 4c 93 3c b0 99 33 87
     58 4c 93 3c b0 99 33 8c
     58 4c 93 3c b0 99 33 e5
     58 4c 93 3c b0 99 33 f3
     58 4c 93 3c b0 99 34 26
     58 4c 93 3c b0 99 34 30
     58 4c 93 3c b0 99 34 68
     58 4c 93 3c b0 99 34 88
     58 4c 93 3c b0 99 34 8a
     58 4c 93 3c b0 99 35 4c
     58 4c 93 3c b0 99 35 bd
     00 01 00 14 3c f4 b9 24
     03 20 22 f0 dc 50 58 14
     53 b8 5d 93 b0 47 b6 3d
     44 6c 58 45 cb 48 44 5d
     db 96 68 8f 04 ae 26 f7
     63 56 5a b7 aa ab 01 71
     72 4f 3c a8 bc c5 1a 98
     b7 d4 c9 2e a3 3c d9 34
     4c a8 b6 3e 04 53 3a bf
     1a 3c 05 49 16 b3 68 2c
     5c a8 cb 4d d0 f8 4c 3b
     77 48 7a ac 6e ce 38 48
     0b a9 d5 00
```

---
# **Acknowledgements**

저자는 의견을 주신 모든 검토자에게 감사드립니다. 특히 통찰력 있고 상세한 기술 검토를 해주신 DJ Bernstein, S. Bortzmeyer, A. Farrel, E. Lear 및 R. Salz에게 감사드립니다. 국제화 검토에 응해주신 J. Yao와 J. Klensin에게 감사드립니다. "GNU 이름 시스템"이라는 이름을 제안한 J. Appelbaum 박사와 그 사용을 승인한 Richard Stallman 박사에게 감사드립니다. GNS의 설계 및 구현에 대한 초기 기여에 대해 T. Lange와 M. Wachs에게 감사드립니다. GNU 이름 시스템에 자금을 지원해준 NLnet과 NGI DISCOVERY에 감사드립니다.

---
# **Authors' Addresses**

```text
   Martin Schanzenbach
   Fraunhofer AISEC
   Lichtenbergstrasse 11
   85748 Garching
   Germany
   Email: martin.schanzenbach@aisec.fraunhofer.de

   Christian Grothoff
   Berner Fachhochschule
   Hoeheweg 80
   CH-2501 Biel/Bienne
   Switzerland
   Email: christian.grothoff@bfh.ch

   Bernd Fix
   GNUnet e.V.
   Boltzmannstrasse 3
   85748 Garching
   Germany
   Email: fix@gnunet.org
```
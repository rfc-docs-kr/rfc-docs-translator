

```text
Network Working Group                                     P. Mockapetris
Request for Comments: 1035                                           ISI
                                                           November 1987
Obsoletes: RFCs 882, 883, 973
```

- 도메인 이름 - 구현 및 사양

---
## **1. STATUS OF THIS MEMO**

이 RFC는 도메인 시스템 및 프로토콜의 세부 사항을 설명하고 독자가 RFC와 함께 제공되는 "도메인 이름 - 개념 및 시설" \[RFC-1034\]에서 논의된 개념에 익숙하다고 가정합니다.

도메인 시스템은 공식 프로토콜인 함수 및 데이터 유형과 아직 실험적인 기능 및 데이터 유형이 혼합된 형태입니다. 도메인 시스템은 의도적으로 확장 가능하므로 공식 프로토콜을 넘어서는 시스템 부분에서는 항상 새로운 데이터 유형과 실험적 동작이 예상되어야 합니다. 공식 프로토콜 부분에는 표준 쿼리, 응답 및 인터넷 클래스 RR 데이터 형식\(예: 호스트 주소\)이 포함됩니다. 이전 RFC 세트 이후 여러 정의가 변경되었으므로 일부 이전 정의는 더 이상 사용되지 않습니다.

실험적이거나 더 이상 사용되지 않는 기능은 이러한 RFC에 명확하게 표시되어 있으므로 이러한 정보는 주의해서 사용해야 합니다.

독자는 예제에 현재 있거나 완전한 것으로 나타나는 값에 의존하지 않도록 특별히 주의해야 합니다. 그 목적은 주로 교육학적인 것이기 때문입니다. 이 메모의 배포는 무제한입니다.

- 목차

```text
  1. STATUS OF THIS MEMO                                              1
  2. INTRODUCTION                                                     3
      2.1. Overview                                                   3
      2.2. Common configurations                                      4
      2.3. Conventions                                                7
          2.3.1. Preferred name syntax                                7
          2.3.2. Data Transmission Order                              8
          2.3.3. Character Case                                       9
          2.3.4. Size limits                                         10
  3. DOMAIN NAME SPACE AND RR DEFINITIONS                            10
      3.1. Name space definitions                                    10
      3.2. RR definitions                                            11
          3.2.1. Format                                              11
          3.2.2. TYPE values                                         12
          3.2.3. QTYPE values                                        12
          3.2.4. CLASS values                                        13

          3.2.5. QCLASS values                                       13
      3.3. Standard RRs                                              13
          3.3.1. CNAME RDATA format                                  14
          3.3.2. HINFO RDATA format                                  14
          3.3.3. MB RDATA format (EXPERIMENTAL)                      14
          3.3.4. MD RDATA format (Obsolete)                          15
          3.3.5. MF RDATA format (Obsolete)                          15
          3.3.6. MG RDATA format (EXPERIMENTAL)                      16
          3.3.7. MINFO RDATA format (EXPERIMENTAL)                   16
          3.3.8. MR RDATA format (EXPERIMENTAL)                      17
          3.3.9. MX RDATA format                                     17
          3.3.10. NULL RDATA format (EXPERIMENTAL)                   17
          3.3.11. NS RDATA format                                    18
          3.3.12. PTR RDATA format                                   18
          3.3.13. SOA RDATA format                                   19
          3.3.14. TXT RDATA format                                   20
      3.4. ARPA Internet specific RRs                                20
          3.4.1. A RDATA format                                      20
          3.4.2. WKS RDATA format                                    21
      3.5. IN-ADDR.ARPA domain                                       22
      3.6. Defining new types, classes, and special namespaces       24
  4. MESSAGES                                                        25
      4.1. Format                                                    25
          4.1.1. Header section format                               26
          4.1.2. Question section format                             28
          4.1.3. Resource record format                              29
          4.1.4. Message compression                                 30
      4.2. Transport                                                 32
          4.2.1. UDP usage                                           32
          4.2.2. TCP usage                                           32
  5. MASTER FILES                                                    33
      5.1. Format                                                    33
      5.2. Use of master files to define zones                       35
      5.3. Master file example                                       36
  6. NAME SERVER IMPLEMENTATION                                      37
      6.1. Architecture                                              37
          6.1.1. Control                                             37
          6.1.2. Database                                            37
          6.1.3. Time                                                39
      6.2. Standard query processing                                 39
      6.3. Zone refresh and reload processing                        39
      6.4. Inverse queries (Optional)                                40
          6.4.1. The contents of inverse queries and responses       40
          6.4.2. Inverse query and response example                  41
          6.4.3. Inverse query processing                            42

      6.5. Completion queries and responses                          42
  7. RESOLVER IMPLEMENTATION                                         43
      7.1. Transforming a user request into a query                  43
      7.2. Sending the queries                                       44
      7.3. Processing responses                                      46
      7.4. Using the cache                                           47
  8. MAIL SUPPORT                                                    47
      8.1. Mail exchange binding                                     48
      8.2. Mailbox binding (Experimental)                            48
  9. REFERENCES and BIBLIOGRAPHY                                     50
  Index                                                              54
```

---
## **2. INTRODUCTION**
---
### **2.1. Overview**

도메인 이름의 목적은 다른 호스트, 네트워크, 프로토콜 계열, 인터넷 및 관리 조직에서 이름을 사용할 수 있는 방식으로 리소스에 이름을 지정하기 위한 메커니즘을 제공하는 것입니다.

사용자의 관점에서 볼 때 도메인 이름은 도메인 이름과 관련된 정보를 검색하는 확인자라고 하는 로컬 에이전트에 대한 인수로 유용합니다. 따라서 사용자는 특정 도메인 이름과 관련된 호스트 주소나 메일 정보를 요청할 수 있습니다. 사용자가 특정 유형의 정보를 요청할 수 있도록 적절한 쿼리 유형이 도메인 이름과 함께 확인자에게 전달됩니다. 사용자에게 도메인 트리는 단일 정보 공간입니다. 확인자는 사용자로부터 이름 서버 간의 데이터 배포를 숨기는 역할을 담당합니다.

리졸버의 관점에서 볼 때, 도메인 공간을 구성하는 데이터베이스는 다양한 네임서버에 분산되어 있습니다. 도메인 공간의 다른 부분은 다른 이름 서버에 저장되지만 특정 데이터 항목은 두 개 이상의 이름 서버에 중복 저장됩니다. 확인자는 하나 이상의 이름 서버에 대한 지식으로 시작됩니다. 확인자는 사용자 쿼리를 처리할 때 알려진 이름 서버에 정보를 요청합니다. 그 대가로 확인자는 원하는 정보를 받거나 다른 이름 서버에 대한 참조를 받습니다. 이러한 참조를 사용하여 확인자는 다른 이름 서버의 ID와 내용을 알아냅니다. 확인자는 도메인 공간의 분배를 처리하고 다른 서버의 중복 데이터베이스를 참조하여 이름 서버 오류의 영향을 처리하는 일을 담당합니다.

네임서버는 두 가지 종류의 데이터를 관리합니다. 영역이라고 불리는 세트에 보관되는 첫 번째 종류의 데이터입니다. 각 영역은 도메인 공간의 특정 "정리된" 하위 트리에 대한 완전한 데이터베이스입니다. 이 데이터를 신뢰할 수 있는 데이터라고 합니다. 네임서버는 주기적으로 해당 영역이 최신인지 확인하고, 그렇지 않은 경우 업데이트된 영역의 새 복사본을 얻습니다.

로컬 또는 다른 이름 서버에 저장된 마스터 파일에서. 두 번째 종류의 데이터는 로컬 해석기에 의해 획득된 캐시된 데이터입니다. 이 데이터는 불완전할 수 있지만 로컬이 아닌 데이터에 반복적으로 액세스할 때 검색 프로세스의 성능을 향상시킵니다. 캐시된 데이터는 결국 시간 초과 메커니즘에 의해 삭제됩니다.

이 기능 구조는 해석기에서 사용자 인터페이스, 오류 복구 및 배포 문제를 격리하고 이름 서버에서 데이터베이스 업데이트 및 새로 고침 문제를 격리합니다.

---
### **2.2. Common configurations**

호스트는 도메인 시스템에서 정보를 검색하는 프로그램, 다른 호스트의 쿼리에 응답하는 이름 서버 또는 두 기능의 다양한 조합을 호스트가 실행하는지 여부에 따라 다양한 방법으로 도메인 이름 시스템에 참여할 수 있습니다. 가장 간단하고 아마도 가장 일반적인 구성은 다음과 같습니다.

```text
                 Local Host                        |  Foreign
                                                   |
    +---------+               +----------+         |  +--------+
    |         | user queries  |          |queries  |  |        |
    |  User   |-------------->|          |---------|->|Foreign |
    | Program |               | Resolver |         |  |  Name  |
    |         |<--------------|          |<--------|--| Server |
    |         | user responses|          |responses|  |        |
    +---------+               +----------+         |  +--------+
                                |     A            |
                cache additions |     | references |
                                V     |            |
                              +----------+         |
                              |  cache   |         |
                              +----------+         |
```

사용자 프로그램은 확인자를 통해 도메인 이름 공간과 상호 작용합니다. 사용자 쿼리 및 사용자 응답의 형식은 호스트 및 해당 운영 체제에 따라 다릅니다. 사용자 쿼리는 일반적으로 운영 체제 호출이며 확인자와 해당 캐시는 호스트 운영 체제의 일부입니다. 능력이 떨어지는 호스트는 리졸버를 서비스가 필요한 모든 프로그램과 연결되는 서브루틴으로 구현하도록 선택할 수 있습니다. 확인자는 외부 이름 서버 및 로컬 캐시에 대한 쿼리를 통해 얻은 정보로 사용자 쿼리에 응답합니다.

확인자는 특정 사용자 쿼리에 응답하기 위해 여러 다른 외부 이름 서버에 여러 쿼리를 수행해야 할 수 있으므로 사용자 쿼리 해결에는 여러 네트워크 액세스와 임의의 시간이 포함될 수 있습니다. 외부 이름 서버에 대한 쿼리와 해당 응답은 다음과 같은 표준 형식을 갖습니다.

---
# **in this memo, and may be datagrams.**

기능에 따라 이름 서버는 전용 시스템의 독립 실행형 프로그램일 수도 있고 대규모 시분할 호스트의 프로세스일 수도 있습니다. 간단한 구성은 다음과 같습니다.

```text
                 Local Host                        |  Foreign
                                                   |
      +---------+                                  |
     /         /|                                  |
    +---------+ |             +----------+         |  +--------+
    |         | |             |          |responses|  |        |
    |         | |             |   Name   |---------|->|Foreign |
    |  Master |-------------->|  Server  |         |  |Resolver|
    |  files  | |             |          |<--------|--|        |
    |         |/              |          | queries |  +--------+
    +---------+               +----------+         |
```

여기서 기본 이름 서버는 로컬 파일 시스템에서 마스터 파일을 읽어 하나 이상의 영역에 대한 정보를 획득하고 외부 확인자에서 도착하는 해당 영역에 대한 쿼리에 응답합니다.

DNS에서는 모든 영역이 둘 이상의 이름 서버에서 중복적으로 지원되어야 합니다. 지정된 보조 서버는 DNS의 영역 전송 프로토콜을 사용하여 영역을 획득하고 기본 서버에서 업데이트를 확인할 수 있습니다. 이 구성은 아래와 같습니다.

```text
                 Local Host                        |  Foreign
                                                   |
      +---------+                                  |
     /         /|                                  |
    +---------+ |             +----------+         |  +--------+
    |         | |             |          |responses|  |        |
    |         | |             |   Name   |---------|->|Foreign |
    |  Master |-------------->|  Server  |         |  |Resolver|
    |  files  | |             |          |<--------|--|        |
    |         |/              |          | queries |  +--------+
    +---------+               +----------+         |
                                A     |maintenance |  +--------+
                                |     +------------|->|        |
                                |      queries     |  |Foreign |
                                |                  |  |  Name  |
                                +------------------|--| Server |
                             maintenance responses |  +--------+
```

이 구성에서 이름 서버는 영역의 복사본을 얻거나 기존 복사본이 변경되지 않았는지 확인하기 위해 외부 이름 서버에 대한 가상 회로를 주기적으로 설정합니다. 보낸 메시지

이러한 유지 관리 활동은 쿼리 및 응답과 동일한 형식을 따르지만 메시지 순서는 다소 다릅니다.

도메인 이름 시스템의 모든 측면을 지원하는 호스트의 정보 흐름은 다음과 같습니다.

```text
                 Local Host                        |  Foreign
                                                   |
    +---------+               +----------+         |  +--------+
    |         | user queries  |          |queries  |  |        |
    |  User   |-------------->|          |---------|->|Foreign |
    | Program |               | Resolver |         |  |  Name  |
    |         |<--------------|          |<--------|--| Server |
    |         | user responses|          |responses|  |        |
    +---------+               +----------+         |  +--------+
                                |     A            |
                cache additions |     | references |
                                V     |            |
                              +----------+         |
                              |  Shared  |         |
                              | database |         |
                              +----------+         |
                                A     |            |
      +---------+     refreshes |     | references |
     /         /|               |     V            |
    +---------+ |             +----------+         |  +--------+
    |         | |             |          |responses|  |        |
    |         | |             |   Name   |---------|->|Foreign |
    |  Master |-------------->|  Server  |         |  |Resolver|
    |  files  | |             |          |<--------|--|        |
    |         |/              |          | queries |  +--------+
    +---------+               +----------+         |
                                A     |maintenance |  +--------+
                                |     +------------|->|        |
                                |      queries     |  |Foreign |
                                |                  |  |  Name  |
                                +------------------|--| Server |
                             maintenance responses |  +--------+
```

공유 데이터베이스는 로컬 이름 서버 및 확인자를 위한 도메인 공간 데이터를 보유합니다. 공유 데이터베이스의 콘텐츠는 일반적으로 이름 서버의 주기적인 새로 고침 작업으로 유지 관리되는 신뢰할 수 있는 데이터와 이전 확인자 요청에서 캐시된 데이터가 혼합되어 있습니다. 도메인 데이터의 구조와 네임 서버와 확인자 간의 동기화 필요성은 이 데이터베이스의 일반적인 특성을 암시하지만 실제 형식은 로컬 구현자에 따라 다릅니다.

정보 흐름은 호스트 그룹이 함께 활동하여 활동을 최적화하도록 맞춤화될 수도 있습니다. 때때로 이는 전체 확인자를 구현할 필요가 없도록 성능이 떨어지는 호스트를 오프로드하기 위해 수행됩니다. 이는 필요한 새 네트워크 코드의 양을 최소화하려는 PC 또는 호스트에 적합할 수 있습니다. 또한 이 방식을 사용하면 중앙 집중식 캐시의 적중률이 더 높다는 전제 하에 호스트 그룹이 다수의 별도 캐시를 유지하는 대신 소수의 캐시를 공유할 수 있습니다. 두 경우 모두 확인자는 해당 서비스를 수행하는 것으로 알려진 하나 이상의 이름 서버에 있는 재귀 서버에 있는 확인자에 대한 프런트 엔드 역할을 하는 스텁 확인자로 대체됩니다.

```text
                   Local Hosts                     |  Foreign
                                                   |
    +---------+                                    |
    |         | responses                          |
    | Stub    |<--------------------+              |
    | Resolver|                     |              |
    |         |----------------+    |              |
    +---------+ recursive      |    |              |
                queries        |    |              |
                               V    |              |
    +---------+ recursive     +----------+         |  +--------+
    |         | queries       |          |queries  |  |        |
    | Stub    |-------------->| Recursive|---------|->|Foreign |
    | Resolver|               | Server   |         |  |  Name  |
    |         |<--------------|          |<--------|--| Server |
    +---------+ responses     |          |responses|  |        |
                              +----------+         |  +--------+
                              |  Central |         |
                              |   cache  |         |
                              +----------+         |
```

어떤 경우든 도메인 구성 요소는 가능할 때마다 안정성을 위해 항상 복제됩니다.

---
### **2.3. Conventions**

도메인 시스템에는 낮은 수준이지만 근본적인 문제를 다루는 몇 가지 규칙이 있습니다. 구현자는 자신의 시스템 내에서 이러한 규칙을 자유롭게 위반할 수 있지만, 다른 호스트에서 관찰되는 모든 동작에서는 이러한 규칙을 준수해야 합니다.

---
#### **2.3.1. Preferred name syntax**

DNS 사양은 도메인 이름 구성 규칙에서 가능한 한 일반적이도록 노력합니다. 아이디어는 기존 개체의 이름을 최소한의 변경만으로 도메인 이름으로 표현할 수 있다는 것입니다.

그러나 객체에 대한 도메인 이름을 할당할 때 신중한 사용자는 도메인 시스템의 규칙과 객체에 대한 기존 규칙\(이러한 규칙이 게시되었거나 기존 프로그램에 의해 암시되었는지 여부\)을 모두 만족하는 이름을 선택합니다.

예를 들어 메일 도메인의 이름을 지정할 때 사용자는 이 메모의 규칙과 RFC-822의 규칙을 모두 충족해야 합니다. 새 호스트 이름을 생성할 때 HOSTS.TXT에 대한 이전 규칙을 따라야 합니다. 이렇게 하면 이전 소프트웨어가 도메인 이름을 사용하도록 변환될 때 문제가 발생하지 않습니다.

---
# **The following syntax will result in fewer problems with many**
---
# **applications that use domain names (e.g., mail, TELNET).**

```text
<domain> ::= <subdomain> | " "

<subdomain> ::= <label> | <subdomain> "." <label>

<label> ::= <letter> [ [ <ldh-str> ] <let-dig> ]

<ldh-str> ::= <let-dig-hyp> | <let-dig-hyp> <ldh-str>

<let-dig-hyp> ::= <let-dig> | "-"

<let-dig> ::= <letter> | <digit>
```

<letter\> ::= 대문자 A\~Z, 소문자 a\~z 중 52개의 영문자 중 하나

<digit\> ::= 0부터 9까지 10개의 숫자 중 하나

도메인 이름에는 대문자와 소문자는 허용되지만 대소문자에는 아무런 의미가 없습니다. 즉, 철자는 동일하지만 대소문자가 다른 두 이름은 동일한 것처럼 처리됩니다.

레이블은 ARPANET 호스트 이름에 대한 규칙을 따라야 합니다. 문자로 시작하고 문자나 숫자로 끝나야 하며, 내부 문자로는 문자, 숫자, 하이픈만 사용할 수 있습니다. 길이에도 몇 가지 제한이 있습니다. 라벨은 63자 이하여야 합니다.

---
# **For example, the following strings identify hosts in the Internet:**
---
### **A.ISI.EDU XX.LCS.MIT.EDU SRI-NIC.ARPA**
---
#### **2.3.2. Data Transmission Order**

본 문서에 기술된 헤더와 데이터의 전송 순서는 옥텟 수준으로 결정됩니다. 다이어그램에 다음이 표시될 때마다

옥텟 그룹에서 해당 옥텟의 전송 순서는 영어로 읽는 일반적인 순서입니다. 예를 들어, 다음 다이어그램에서 옥텟은 번호가 매겨진 순서대로 전송됩니다.

```text
     0                   1
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |       1       |       2       |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |       3       |       4       |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |       5       |       6       |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

옥텟이 숫자 수량을 나타낼 때마다 다이어그램의 가장 왼쪽 비트는 상위 또는 최상위 비트입니다. 즉, 0으로 표시된 비트가 최상위 비트입니다. 예를 들어, 다음 다이어그램은 값 170\(십진수\)을 나타냅니다.

```text
     0 1 2 3 4 5 6 7
    +-+-+-+-+-+-+-+-+
    |1 0 1 0 1 0 1 0|
    +-+-+-+-+-+-+-+-+
```

마찬가지로 다중 옥텟 필드가 숫자 수량을 나타낼 때마다 전체 필드의 가장 왼쪽 비트가 최상위 비트입니다. 다중 옥텟 수량이 전송되면 가장 중요한 옥텟이 먼저 전송됩니다.

---
#### **2.3.3. Character Case**

공식 프로토콜의 일부인 DNS의 모든 부분에 대해 문자열\(예: 레이블, 도메인 이름 등\) 간의 모든 비교는 대소문자를 구분하지 않는 방식으로 수행됩니다. 현재 이 규칙은 예외 없이 도메인 시스템 전체에 적용됩니다. 그러나 현재 사용 범위를 넘어서는 미래의 추가에서는 이름에 전체 이진 옥텟 기능을 사용해야 할 수 있으므로 도메인 이름을 7비트 ASCII로 저장하거나 레이블을 종료하기 위해 특수 바이트를 사용하려는 시도는 피해야 합니다.

데이터가 도메인 시스템에 입력되면 가능하면 원래 케이스를 보존해야 합니다. 특정 상황에서는 이 작업을 수행할 수 없습니다. 예를 들어, 두 개의 RR이 x.y에 하나, X.Y에 하나씩 데이터베이스에 저장된 경우 실제로는 데이터베이스의 동일한 위치에 저장되므로 대소문자는 하나만 보존됩니다. 기본 규칙은 데이터가 데이터베이스의 구조를 정의하는 데 사용되는 경우에만 대소문자를 삭제할 수 있으며 대소문자를 구분하지 않고 비교할 때 두 이름이 동일하다는 것입니다.

대소문자를 구분하는 데이터의 손실을 최소화해야 합니다. 따라서 x.y 및 X.Y에 대한 데이터는 모두 단일 위치 x.y 또는 X.Y에 저장될 수 있지만 a.x 및 B.X에 대한 데이터는 A.x, A.X, b.x 또는 b.X에 저장되지 않습니다. 일반적으로 이는 도메인 이름의 첫 번째 레이블의 대소문자를 유지하지만 내부 노드 레이블의 표준화를 강제합니다.

도메인 데이터베이스에 데이터를 입력하는 시스템 관리자는 시스템이 대소문자를 구분하는 경우 도메인 시스템에 제공하는 데이터를 대소문자 일치 방식으로 표시하도록 주의해야 합니다. 도메인 시스템의 데이터 배포 시스템은 일관된 표현이 보존되도록 보장합니다.

---
#### **2.3.4. Size limits**

DNS의 다양한 개체와 매개변수에는 크기 제한이 있습니다. 아래에 나열되어 있습니다. 일부는 쉽게 변경할 수 있지만 일부는 더 근본적입니다.

---
# **labels          63 octets or less**
---
# **names           255 octets or less**
---
# **TTL             positive values of a signed 32 bit number.**
---
# **UDP messages    512 octets or less**
---
## **3. DOMAIN NAME SPACE AND RR DEFINITIONS**
---
### **3.1. Name space definitions**

메시지의 도메인 이름은 일련의 레이블로 표현됩니다. 각 레이블은 1옥텟 길이 필드와 해당 옥텟 수로 표시됩니다. 모든 도메인 이름은 루트의 null 레이블로 끝나기 때문에 도메인 이름은 길이 바이트 0으로 끝납니다. 모든 길이 옥텟의 상위 2비트는 0이어야 하며 길이 필드의 나머지 6비트는 레이블을 63옥텟 이하로 제한합니다.

구현을 단순화하기 위해 도메인 이름의 총 길이\(예: 레이블 옥텟 및 레이블 길이 옥텟\)는 255옥텟 이하로 제한됩니다.

레이블은 레이블을 구성하는 옥텟에 8비트 값을 포함할 수 있지만 레이블은 이 메모의 다른 부분에 설명된 기본 구문을 따르는 것이 좋습니다. 이는 기존 호스트 명명 규칙과 호환됩니다. 이름 서버와 확인자는 ASCII를 패리티가 0이라고 가정하고 대소문자를 구분하지 않는 방식\(예: A=a\)으로 레이블을 비교해야 합니다. 알파벳이 아닌 코드는 정확히 일치해야 합니다.

---
### **3.2. RR definitions**
---
#### **3.2.1. Format**
---
# **All RRs have the same top level format shown below:**

```text
                                    1  1  1  1  1  1
      0  1  2  3  4  5  6  7  8  9  0  1  2  3  4  5
    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
    |                                               |
    /                                               /
    /                      NAME                     /
    |                                               |
    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
    |                      TYPE                     |
    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
    |                     CLASS                     |
    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
    |                      TTL                      |
    |                                               |
    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
    |                   RDLENGTH                    |
    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--|
    /                     RDATA                     /
    /                                               /
    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
```

---
# **where:**

```text
NAME            an owner name, i.e., the name of the node to which this
                resource record pertains.
```

---
# **TYPE            two octets containing one of the RR TYPE codes.**
---
# **CLASS           two octets containing one of the RR CLASS codes.**

```text
TTL             a 32 bit signed integer that specifies the time interval
                that the resource record may be cached before the source
                of the information should again be consulted.  Zero
                values are interpreted to mean that the RR can only be
                used for the transaction in progress, and should not be
                cached.  For example, SOA records are always distributed
                with a zero TTL to prohibit caching.  Zero values can
                also be used for extremely volatile data.

RDLENGTH        an unsigned 16 bit integer that specifies the length in
                octets of the RDATA field.

RDATA           a variable length string of octets that describes the
                resource.  The format of this information varies
                according to the TYPE and CLASS of the resource record.
```

---
#### **3.2.2. TYPE values**

TYPE 필드는 리소스 레코드에 사용됩니다. 이러한 유형은 QTYPE의 하위 집합입니다.

---
# **TYPE            value and meaning**
---
# **A               1 a host address**
---
# **NS              2 an authoritative name server**
---
# **MD              3 a mail destination (Obsolete - use MX)**
---
# **MF              4 a mail forwarder (Obsolete - use MX)**
---
# **CNAME           5 the canonical name for an alias**
---
# **SOA             6 marks the start of a zone of authority**
---
# **MB              7 a mailbox domain name (EXPERIMENTAL)**
---
# **MG              8 a mail group member (EXPERIMENTAL)**
---
# **MR              9 a mail rename domain name (EXPERIMENTAL)**
---
# **NULL            10 a null RR (EXPERIMENTAL)**
---
# **WKS             11 a well known service description**
---
# **PTR             12 a domain name pointer**
---
# **HINFO           13 host information**
---
# **MINFO           14 mailbox or mail list information**
---
# **MX              15 mail exchange**
---
# **TXT             16 text strings**
---
#### **3.2.3. QTYPE values**

QTYPE 필드는 쿼리의 질문 부분에 나타납니다. QTYPES는 TYPE의 상위 집합이므로 모든 TYPE은 유효한 QTYPE입니다. 또한 다음 QTYPE이 정의됩니다.

---
# **AXFR            252 A request for a transfer of an entire zone**
---
# **MAILB           253 A request for mailbox-related records (MB, MG or MR)**
---
# **MAILA           254 A request for mail agent RRs (Obsolete - see MX)**

\* 255 모든 기록에 대한 요청

---
#### **3.2.4. CLASS values**

CLASS 필드는 리소스 레코드에 나타납니다. 다음 CLASS 니모닉 및 값이 정의됩니다.

---
# **IN              1 the Internet**

```text
CS              2 the CSNET class (Obsolete - used only for examples in
                some obsolete RFCs)
```

---
# **CH              3 the CHAOS class**
---
# **HS              4 Hesiod [Dyer 87]**
---
#### **3.2.5. QCLASS values**

QCLASS 필드는 쿼리의 질문 섹션에 나타납니다. QCLASS 값은 CLASS 값의 상위 집합입니다. 모든 CLASS는 유효한 QCLASS입니다. CLASS 값 외에도 다음 QCLASS가 정의됩니다.

```text
*               255 any class
```

---
### **3.3. Standard RRs**

다음 RR 정의는 적어도 잠재적으로 모든 클래스에서 발생할 것으로 예상됩니다. 특히 NS, SOA, CNAME, PTR은 모든 클래스에서 사용되며 모든 클래스에서 동일한 형식을 갖습니다. RDATA 형식이 알려져 있으므로 이러한 RR의 RDATA 섹션에 있는 모든 도메인 이름이 압축될 수 있습니다.

<domain-name\>은 일련의 레이블로 표시되고 길이가 0인 레이블로 끝나는 도메인 이름입니다. <문자열\>은 단일 길이 옥텟 뒤에 해당 문자 수가 옵니다. <문자열\>은 이진 정보로 처리되며 최대 256자\(길이 옥텟 포함\)까지 가능합니다.

---
#### **3.3.1. CNAME RDATA format**

```text
    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
    /                     CNAME                     /
    /                                               /
    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
```

---
# **where:**

```text
CNAME           A <domain-name> which specifies the canonical or primary
                name for the owner.  The owner name is an alias.
```

CNAME RR은 추가 섹션 처리를 발생시키지 않지만 이름 서버는 특정 경우 표준 이름에서 쿼리를 다시 시작하도록 선택할 수 있습니다. 자세한 내용은 \[RFC-1034\]의 이름 서버 논리 설명을 참조하세요.

---
#### **3.3.2. HINFO RDATA format**

```text
    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
    /                      CPU                      /
    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
    /                       OS                      /
    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
```

---
# **where:**
---
# **CPU             A <character-string> which specifies the CPU type.**

```text
OS              A <character-string> which specifies the operating
                system type.
```

---
# **Standard values for CPU and OS can be found in [RFC-1010].**

HINFO 레코드는 호스트에 대한 일반 정보를 얻는 데 사용됩니다. 주요 용도는 동일한 유형의 기계 또는 운영 체제 간에 통신할 때 특별한 절차를 사용할 수 있는 FTP와 같은 프로토콜에 대한 것입니다.

---
#### **3.3.3. MB RDATA format (EXPERIMENTAL)**

```text
    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
    /                   MADNAME                     /
    /                                               /
    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
```

---
# **where:**

```text
MADNAME         A <domain-name> which specifies a host which has the
                specified mailbox.
```

MB 레코드는 MADNAME에 해당하는 A 유형 RR을 찾는 추가 섹션 처리를 발생시킵니다.

---
#### **3.3.4. MD RDATA format (Obsolete)**

```text
    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
    /                   MADNAME                     /
    /                                               /
    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
```

---
# **where:**

```text
MADNAME         A <domain-name> which specifies a host which has a mail
                agent for the domain which should be able to deliver
                mail for the domain.
```

MD 레코드는 MADNAME에 해당하는 A 유형 레코드를 조회하는 추가 섹션 처리를 발생시킵니다.

MD는 구식입니다. 새로운 체계에 대한 자세한 내용은 MX 정의 및 \[RFC-974\]를 ​​참조하세요. 마스터 파일에 있는 MD RR을 처리할 때 권장되는 정책은 이를 거부하거나 기본 설정이 0인 MX RR로 변환하는 것입니다.

---
#### **3.3.5. MF RDATA format (Obsolete)**

```text
    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
    /                   MADNAME                     /
    /                                               /
    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
```

---
# **where:**

```text
MADNAME         A <domain-name> which specifies a host which has a mail
                agent for the domain which will accept mail for
                forwarding to the domain.
```

MF 레코드는 MADNAME에 해당하는 A 유형 레코드를 조회하는 추가 섹션 처리를 발생시킵니다.

MF는 구식입니다. 새로운 체계에 대한 자세한 내용은 MX 정의 및 \[RFC-974\]를 ​​참조하세요. 마스터 파일에 있는 MD RR을 처리할 때 권장되는 정책은 이를 거부하거나 기본 설정 10을 사용하여 MX RR로 변환하는 것입니다.

---
#### **3.3.6. MG RDATA format (EXPERIMENTAL)**

```text
    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
    /                   MGMNAME                     /
    /                                               /
    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
```

---
# **where:**

```text
MGMNAME         A <domain-name> which specifies a mailbox which is a
                member of the mail group specified by the domain name.
```

---
# **MG records cause no additional section processing.**
---
#### **3.3.7. MINFO RDATA format (EXPERIMENTAL)**

```text
    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
    /                    RMAILBX                    /
    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
    /                    EMAILBX                    /
    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
```

---
# **where:**

```text
RMAILBX         A <domain-name> which specifies a mailbox which is
                responsible for the mailing list or mailbox.  If this
                domain name names the root, the owner of the MINFO RR is
                responsible for itself.  Note that many existing mailing
                lists use a mailbox X-request for the RMAILBX field of
                mailing list X, e.g., Msgroup-request for Msgroup.  This
                field provides a more general mechanism.

EMAILBX         A <domain-name> which specifies a mailbox which is to
                receive error messages related to the mailing list or
                mailbox specified by the owner of the MINFO RR (similar
                to the ERRORS-TO: field which has been proposed).  If
                this domain name names the root, errors should be
                returned to the sender of the message.
```

MINFO 레코드는 추가 섹션 처리를 발생시키지 않습니다. 이러한 레코드는 단순 사서함과 연결될 수 있지만 일반적으로 메일링 목록과 함께 사용됩니다.

---
#### **3.3.8. MR RDATA format (EXPERIMENTAL)**

```text
    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
    /                   NEWNAME                     /
    /                                               /
    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
```

---
# **where:**

```text
NEWNAME         A <domain-name> which specifies a mailbox which is the
                proper rename of the specified mailbox.
```

MR 레코드로 인해 추가 섹션 처리가 발생하지 않습니다. MR의 주요 용도는 다른 사서함으로 이동한 사용자에 대한 전달 항목입니다.

---
#### **3.3.9. MX RDATA format**

```text
    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
    |                  PREFERENCE                   |
    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
    /                   EXCHANGE                    /
    /                                               /
    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
```

---
# **where:**

```text
PREFERENCE      A 16 bit integer which specifies the preference given to
                this RR among others at the same owner.  Lower values
                are preferred.

EXCHANGE        A <domain-name> which specifies a host willing to act as
                a mail exchange for the owner name.
```

MX 레코드 원인 유형 EXCHANGE로 지정된 호스트에 대한 추가 섹션 처리입니다. MX RR의 사용은 \[RFC-974\]에 자세히 설명되어 있습니다.

---
#### **3.3.10. NULL RDATA format (EXPERIMENTAL)**

```text
    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
    /                  <anything>                   /
    /                                               /
    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
```

65535 옥텟 이하라면 무엇이든 RDATA 필드에 있을 수 있습니다.

NULL 레코드는 추가 섹션 처리를 발생시키지 않습니다. NULL RR은 마스터 파일에서 허용되지 않습니다. NULL은 DNS의 일부 실험적 확장에서 자리 표시자로 사용됩니다.

---
#### **3.3.11. NS RDATA format**

```text
    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
    /                   NSDNAME                     /
    /                                               /
    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
```

---
# **where:**

```text
NSDNAME         A <domain-name> which specifies a host which should be
                authoritative for the specified class and domain.
```

NS 레코드는 유형 A 레코드를 찾기 위한 일반적인 추가 섹션 처리와 참조에 사용되는 경우 글루 정보를 찾기 위해 해당 레코드가 있는 영역에 대한 특수 검색을 수행합니다.

NS RR은 명명된 호스트가 지정된 클래스의 소유자 이름에서 시작하는 영역을 가져야 한다고 명시합니다. 클래스는 일반적으로 강력한 힌트이지만 호스트와 통신하는 데 사용해야 하는 프로토콜 계열을 나타내지 않을 수 있습니다. 예를 들어, 인터넷\(IN\) 또는 헤시오드\(HS\) 클래스 정보에 대한 이름 서버인 호스트는 일반적으로 IN 클래스 프로토콜을 사용하여 쿼리됩니다.

---
#### **3.3.12. PTR RDATA format**

```text
    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
    /                   PTRDNAME                    /
    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
```

---
# **where:**

```text
PTRDNAME        A <domain-name> which points to some location in the
                domain name space.
```

PTR 레코드는 추가 섹션 처리를 발생시키지 않습니다. 이러한 RR은 도메인 공간의 다른 위치를 가리키는 특수 도메인에서 사용됩니다. 이러한 레코드는 단순한 데이터이며 별칭을 식별하는 CNAME에서 수행되는 것과 유사한 특별한 처리를 의미하지 않습니다. 예를 보려면 IN-ADDR.ARPA 도메인 설명을 참조하세요.

---
#### **3.3.13. SOA RDATA format**

```text
    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
    /                     MNAME                     /
    /                                               /
    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
    /                     RNAME                     /
    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
    |                    SERIAL                     |
    |                                               |
    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
    |                    REFRESH                    |
    |                                               |
    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
    |                     RETRY                     |
    |                                               |
    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
    |                    EXPIRE                     |
    |                                               |
    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
    |                    MINIMUM                    |
    |                                               |
    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
```

---
# **where:**

```text
MNAME           The <domain-name> of the name server that was the
                original or primary source of data for this zone.

RNAME           A <domain-name> which specifies the mailbox of the
                person responsible for this zone.

SERIAL          The unsigned 32 bit version number of the original copy
                of the zone.  Zone transfers preserve this value.  This
                value wraps and should be compared using sequence space
                arithmetic.

REFRESH         A 32 bit time interval before the zone should be
                refreshed.

RETRY           A 32 bit time interval that should elapse before a
                failed refresh should be retried.

EXPIRE          A 32 bit time value that specifies the upper limit on
                the time interval that can elapse before the zone is no
                longer authoritative.

MINIMUM         The unsigned 32 bit minimum TTL field that should be
                exported with any RR from this zone.
```

---
# **SOA records cause no additional section processing.**
---
# **All times are in units of seconds.**

이러한 필드의 대부분은 이름 서버 유지 관리 작업에만 관련됩니다. 그러나 MINIMUM은 영역에서 RR을 검색하는 모든 쿼리 작업에 사용됩니다. 쿼리에 대한 응답으로 RR이 전송될 때마다 TTL 필드는 RR의 TTL 필드의 최대값과 해당 SOA의 MINIMUM 필드로 설정됩니다. 따라서 MINIMUM은 영역의 모든 RR에 대한 TTL 필드의 하한입니다. 이러한 MINIMUM 사용은 RR이 응답에 복사될 때 발생해야 하며 영역이 마스터 파일에서 또는 영역 전송을 통해 로드될 때가 아닙니다. 이 조항의 이유는 향후 동적 업데이트 기능이 알려진 의미론으로 SOA RR을 변경할 수 있도록 하기 위한 것입니다.

---
#### **3.3.14. TXT RDATA format**

```text
    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
    /                   TXT-DATA                    /
    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
```

---
# **where:**
---
# **TXT-DATA        One or more <character-string>s.**

TXT RR은 설명 텍스트를 보관하는 데 사용됩니다. 텍스트의 의미는 텍스트가 발견된 도메인에 따라 다릅니다.

---
### **3.4. Internet specific RRs**
---
#### **3.4.1. A RDATA format**

```text
    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
    |                    ADDRESS                    |
    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
```

---
# **where:**
---
# **ADDRESS         A 32 bit Internet address.**

여러 개의 인터넷 주소를 가진 호스트에는 여러 개의 A 레코드가 있습니다.

A 레코드에서는 추가 섹션 처리가 발생하지 않습니다. 마스터 파일에 있는 A 라인의 RDATA 섹션은 공백 없이 점으로 구분된 4개의 십진수로 표현되는 인터넷 주소입니다\(예: "10.2.0.52" 또는 "192.0.5.6"\).

---
#### **3.4.2. WKS RDATA format**

```text
    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
    |                    ADDRESS                    |
    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
    |       PROTOCOL        |                       |
    +--+--+--+--+--+--+--+--+                       |
    |                                               |
    /                   <BIT MAP>                   /
    /                                               /
    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
```

---
# **where:**
---
# **ADDRESS         An 32 bit Internet address**
---
# **PROTOCOL        An 8 bit IP protocol number**

```text
<BIT MAP>       A variable length bit map.  The bit map must be a
                multiple of 8 bits long.
```

WKS 레코드는 특정 인터넷 주소의 특정 프로토콜이 지원하는 잘 알려진 서비스를 설명하는 데 사용됩니다. PROTOCOL 필드는 IP 프로토콜 번호를 지정하고 비트맵은 지정된 프로토콜의 포트당 1비트를 갖습니다. 첫 번째 비트는 포트 0에 해당하고 두 번째 비트는 포트 1에 해당합니다. 비트맵에 관심 있는 프로토콜에 대한 비트가 포함되어 있지 않으면 해당 비트는 0으로 간주됩니다. 포트와 프로토콜에 대한 적절한 값과 니모닉은 \[RFC-1010\]에 지정되어 있습니다.

예를 들어 PROTOCOL=TCP\(6\)인 경우 26번째 비트는 TCP 포트 25\(SMTP\)에 해당합니다. 이 비트가 설정되면 SMTP 서버는 TCP 포트 25에서 수신 대기해야 합니다. 0이면 지정된 주소에서 SMTP 서비스가 지원되지 않습니다.

WKS RR의 목적은 TCP 및 UDP용 서버에 대한 가용성 정보를 제공하는 것입니다. 서버가 TCP와 UDP를 모두 지원하거나 인터넷 주소가 여러 개인 경우 여러 WKS RR이 사용됩니다.

---
# **WKS RRs cause no additional section processing.**

마스터 파일에서 포트와 프로토콜은 모두 니모닉이나 십진수를 사용하여 표현됩니다.

---
### **3.5. IN-ADDR.ARPA domain**

인터넷은 게이트웨이 위치와 인터넷 주소-호스트 매핑을 지원하기 위해 특수 도메인을 사용합니다. 다른 클래스는 다른 영역에서도 유사한 전략을 사용할 수 있습니다. 이 도메인의 목적은 호스트 주소 대 호스트 이름 매핑을 수행하는 보장된 방법을 제공하고 인터넷의 특정 네트워크에 있는 모든 게이트웨이를 찾는 쿼리를 용이하게 하는 것입니다.

이 두 서비스는 모두 역 쿼리로 수행할 수 있는 기능과 유사합니다. 차이점은 도메인 이름 공간의 이 부분이 주소에 따라 구조화되어 있으므로 도메인 공간을 철저하게 검색하지 않고도 적절한 데이터를 찾을 수 있다는 점입니다.

도메인은 IN-ADDR.ARPA에서 시작하고 인터넷 주소 지정 구조를 따르는 하위 ​​구조를 갖습니다.

IN-ADDR.ARPA 도메인의 도메인 이름은 IN-ADDR.ARPA 접미사 외에 최대 4개의 레이블을 갖도록 정의됩니다. 각 레이블은 인터넷 주소의 한 옥텟을 나타내며 0-255 범위의 10진수 값에 대한 문자열로 표현됩니다\(단일 0으로 표시되는 0 옥텟의 경우를 제외하고 선행 0은 생략됨\).

호스트 주소는 4개의 레이블이 모두 지정된 도메인 이름으로 표시됩니다. 따라서 인터넷 주소 10.2.0.52에 대한 데이터는 도메인 이름 52.0.2.10.IN-ADDR.ARPA에 있습니다. 읽기가 불편하기는 하지만 반전을 사용하면 정확히 하나의 주소 공간 네트워크인 영역을 위임할 수 있습니다. 예를 들어, 10.IN-ADDR.ARPA는 ARPANET용 데이터가 포함된 영역일 수 있고, 26.IN-ADDR.ARPA는 MILNET용 별도 영역일 수 있습니다. 주소 노드는 일반 도메인 공간에서 기본 호스트 이름에 대한 포인터를 보유하는 데 사용됩니다.

인터넷 네트워크 번호는 1, 2 또는 3옥텟이므로 네트워크 번호는 IN-ADDR.ARPA 도메인의 다양한 깊이에 있는 일부 비터미널 노드에 해당합니다. 네트워크 노드는 해당 네트워크에 연결된 게이트웨이의 기본 호스트 이름에 대한 포인터를 보유하는 데 사용됩니다. 게이트웨이는 정의에 따라 둘 이상의 네트워크에 있으므로 일반적으로 게이트웨이를 가리키는 두 개 이상의 네트워크 노드가 있습니다. 게이트웨이에는 정규화된 주소에 호스트 수준 포인터도 있습니다.

네트워크 노드의 게이트웨이 포인터와 전체 주소 노드의 일반 호스트 포인터는 모두 PTR RR을 사용하여 해당 호스트의 기본 도메인 이름을 다시 가리킵니다.

예를 들어 IN-ADDR.ARPA 도메인에는 net 10과 26 사이의 ISI 게이트웨이, net 10에서 MIT까지의 MIT 게이트웨이에 대한 정보가 포함됩니다.

net 18, A.ISI.EDU 및 MULTICS.MIT.EDU를 호스트합니다. ISI 게이트웨이의 주소가 10.2.0.22와 26.0.0.103이고 이름이 MILNET-GW.ISI.EDU이고, MIT 게이트웨이의 주소가 10.0.0.77과 18.10.0.4이고 이름이 GW.LCS.MIT.EDU라고 가정하면, 도메인 데이터베이스에는 다음이 포함됩니다.

```text
    10.IN-ADDR.ARPA.           PTR MILNET-GW.ISI.EDU.
    10.IN-ADDR.ARPA.           PTR GW.LCS.MIT.EDU.
    18.IN-ADDR.ARPA.           PTR GW.LCS.MIT.EDU.
    26.IN-ADDR.ARPA.           PTR MILNET-GW.ISI.EDU.
    22.0.2.10.IN-ADDR.ARPA.    PTR MILNET-GW.ISI.EDU.
    103.0.0.26.IN-ADDR.ARPA.   PTR MILNET-GW.ISI.EDU.
    77.0.0.10.IN-ADDR.ARPA.    PTR GW.LCS.MIT.EDU.
    4.0.10.18.IN-ADDR.ARPA.    PTR GW.LCS.MIT.EDU.
    103.0.3.26.IN-ADDR.ARPA.   PTR A.ISI.EDU.
    6.0.0.10.IN-ADDR.ARPA.     PTR MULTICS.MIT.EDU.
```

따라서 net 10에서 게이트웨이를 찾으려는 프로그램은 QTYPE=PTR, QCLASS=IN, QNAME=10.IN-ADDR.ARPA 형식의 쿼리를 시작합니다. 응답으로 두 개의 RR을 수신합니다.

```text
    10.IN-ADDR.ARPA.           PTR MILNET-GW.ISI.EDU.
    10.IN-ADDR.ARPA.           PTR GW.LCS.MIT.EDU.
```

그런 다음 프로그램은 MILNET-GW.ISI.EDU에 대한 QTYPE=A, QCLASS=IN 쿼리를 시작할 수 있습니다. 및 GW.LCS.MIT.EDU. 이러한 게이트웨이의 인터넷 주소를 검색합니다.

인터넷 호스트 주소 10.0.0.6에 해당하는 호스트 이름을 찾으려는 확인자는 QTYPE=PTR, QCLASS=IN, QNAME=6.0.0.10.IN-ADDR.ARPA 형식의 쿼리를 추구하고 다음을 수신합니다.

```text
    6.0.0.10.IN-ADDR.ARPA.     PTR MULTICS.MIT.EDU.
```

이러한 서비스를 사용할 때는 몇 가지 주의 사항이 적용됩니다. - 특정 호스트 또는 게이트웨이에 대한 IN-ADDR.ARPA 특수 도메인과 일반 도메인이 서로 다른 영역에 있으므로 데이터가 일치하지 않을 가능성이 있습니다.

- 게이트웨이는 별도의 도메인에 두 개의 이름을 갖는 경우가 많으며 그 중 하나만 기본이 될 수 있습니다.

- 도메인 데이터베이스를 사용하여 라우팅 테이블을 초기화하는 시스템은 적절한 이름 서버에 액세스할 수 있도록 충분한 게이트웨이 정보로 시작해야 합니다.

- 게이트웨이 데이터는 현재 HOSTS.TXT 파일과 동일한 방식으로 게이트웨이의 존재만을 반영합니다. GGP 또는 EGP의 동적 가용성 정보를 대체하지 않습니다.

---
### **3.6. Defining new types, classes, and special namespaces**

이전에 정의된 유형 및 클래스는 이 메모의 날짜를 기준으로 사용되는 유형 및 클래스입니다. 새로운 정의가 예상됩니다. 이 섹션에서는 기존 시설에 추가를 고려하는 설계자에게 몇 가지 권장 사항을 제시합니다. 메일링 리스트 NAMEDROPPERS@SRI-NIC.ARPA는 설계 문제에 대한 일반적인 토론이 이루어지는 포럼입니다.

일반적으로 기존 객체에 대한 새로운 정보가 데이터베이스에 추가되거나 완전히 새로운 객체에 대한 새로운 데이터 형식이 필요한 경우 새 유형이 적합합니다. 디자이너는 일반적으로 모든 클래스에 적용 가능하고 정보 중복을 방지하는 유형 및 해당 RDATA 형식을 정의해야 합니다. 새로운 클래스별 데이터 형식이 필요한 새 프로토콜 등에 DNS를 사용하거나 기존 네임스페이스의 복사본이 필요하지만 별도의 관리 도메인이 필요한 경우 새 클래스가 적합합니다.

새로운 유형과 클래스에는 마스터 파일에 대한 니모닉이 필요합니다. 마스터 파일의 형식에서는 유형과 클래스에 대한 니모닉이 분리되어야 합니다.

TYPE 및 CLASS 값은 각각 QTYPE 및 QCLASS의 적절한 하위 집합이어야 합니다.

현재 시스템은 단일 RR의 RDATA 섹션에 여러 값을 저장하는 대신 여러 RR을 ​​사용하여 유형의 여러 값을 나타냅니다. 이는 대부분의 애플리케이션에서 효율성이 떨어지지만 RR을 더 짧게 유지합니다. 다중 RR 가정은 동적 업데이트 방법에 대한 일부 실험 작업에 통합되었습니다.

현재 시스템은 일관성을 보장하기 위해 데이터베이스의 데이터 중복을 최소화하려고 시도합니다. 따라서 메일 교환을 위한 호스트 주소를 찾으려면 호스트 주소에 직접 매핑하는 대신 메일 도메인 이름을 호스트 이름에 매핑한 다음 호스트 이름을 주소에 매핑합니다. 이 접근 방식은 불일치 가능성을 방지하므로 선호됩니다.

새로운 유형의 데이터를 정의할 때 항목 간의 순서를 생성하거나 동등한 바인딩에 대해 서로 다른 형식을 표현하기 위해 여러 RR 유형을 사용해서는 안 됩니다. 대신 이 정보는 RR 본문에 전달되고 단일 유형이 사용되어야 합니다. 이 정책은 여러 유형을 캐싱하고 여러 유형과 일치하도록 QTYPE을 정의하는 데 따른 문제를 방지합니다.

예를 들어 메일 교환 바인딩의 원래 형식은 두 가지 RR 유형을 사용했습니다. 하나는 "더 가까운" 교환\(MD\)을 나타내고 다른 하나는 "덜 가까운" 교환\(MF\)을 나타냅니다. 어려운 점은 캐시된 정보를 획득한 쿼리가 MF, MD 또는 MAILA\(둘 다 일치함\)의 QTYPE을 사용했을 수 있기 때문에 캐시에 하나의 RR 유형이 있으면 다른 유형에 대한 정보를 전달하지 않는다는 것입니다. 새롭게 디자인된

서비스는 다양한 RR을 주문할 수 있는 RDATA 섹션에 "preference" 값이 있는 단일 유형\(MX\)을 사용했습니다. 그러나 캐시에서 MX RR이 발견되면 모두 거기에 있어야 합니다.

---
## **4. MESSAGES**
---
### **4.1. Format**

도메인 프로토콜 내부의 모든 통신은 메시지라는 단일 형식으로 전달됩니다. 메시지의 최상위 형식은 아래와 같이 5개 섹션으로 구분됩니다\(어떤 경우에는 일부가 비어 있음\).

```text
    +---------------------+
    |        Header       |
    +---------------------+
    |       Question      | the question for the name server
    +---------------------+
    |        Answer       | RRs answering the question
    +---------------------+
    |      Authority      | RRs pointing toward an authority
    +---------------------+
    |      Additional     | RRs holding additional information
    +---------------------+
```

헤더 섹션은 항상 존재합니다. 헤더에는 나머지 섹션이 존재하는지 지정하고 메시지가 쿼리인지 응답인지, 표준 쿼리인지 또는 다른 opcode인지 등을 지정하는 필드가 포함되어 있습니다.

헤더 뒤의 섹션 이름은 표준 쿼리에서의 사용에서 파생됩니다. 질문 섹션에는 이름 서버에 대한 질문을 설명하는 필드가 포함되어 있습니다. 이러한 필드는 쿼리 유형\(QTYPE\), 쿼리 클래스\(QCLASS\) 및 쿼리 도메인 이름\(QNAME\)입니다. 마지막 세 섹션은 동일한 형식을 갖습니다. 즉, 연결된 리소스 레코드\(RR\)의 빈 목록일 수 있습니다. 답변 섹션에는 질문에 답변하는 RR이 포함되어 있습니다. 권한 섹션에는 권한 있는 이름 서버를 가리키는 RR이 포함되어 있습니다. 추가 레코드 섹션에는 쿼리와 관련된 RR이 포함되어 있지만 엄밀히 말하면 질문에 대한 답변은 아닙니다.

---
#### **4.1.1. Header section format**
---
# **The header contains the following fields:**

```text
                                    1  1  1  1  1  1
      0  1  2  3  4  5  6  7  8  9  0  1  2  3  4  5
    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
    |                      ID                       |
    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
    |QR|   Opcode  |AA|TC|RD|RA|   Z    |   RCODE   |
    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
    |                    QDCOUNT                    |
    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
    |                    ANCOUNT                    |
    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
    |                    NSCOUNT                    |
    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
    |                    ARCOUNT                    |
    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
```

---
# **where:**

```text
ID              A 16 bit identifier assigned by the program that
                generates any kind of query.  This identifier is copied
                the corresponding reply and can be used by the requester
                to match up replies to outstanding queries.

QR              A one bit field that specifies whether this message is a
                query (0), or a response (1).

OPCODE          A four bit field that specifies kind of query in this
                message.  This value is set by the originator of a query
                and copied into the response.  The values are:

                0               a standard query (QUERY)

                1               an inverse query (IQUERY)

                2               a server status request (STATUS)

                3-15            reserved for future use

AA              Authoritative Answer - this bit is valid in responses,
                and specifies that the responding name server is an
                authority for the domain name in question section.

                Note that the contents of the answer section may have
                multiple owner names because of aliases.  The AA bit

                corresponds to the name which matches the query name, or
                the first owner name in the answer section.

TC              TrunCation - specifies that this message was truncated
                due to length greater than that permitted on the
                transmission channel.

RD              Recursion Desired - this bit may be set in a query and
                is copied into the response.  If RD is set, it directs
                the name server to pursue the query recursively.
                Recursive query support is optional.

RA              Recursion Available - this be is set or cleared in a
                response, and denotes whether recursive query support is
                available in the name server.

Z               Reserved for future use.  Must be zero in all queries
                and responses.

RCODE           Response code - this 4 bit field is set as part of
                responses.  The values have the following
                interpretation:

                0               No error condition

                1               Format error - The name server was
                                unable to interpret the query.

                2               Server failure - The name server was
                                unable to process this query due to a
                                problem with the name server.

                3               Name Error - Meaningful only for
                                responses from an authoritative name
                                server, this code signifies that the
                                domain name referenced in the query does
                                not exist.

                4               Not Implemented - The name server does
                                not support the requested kind of query.

                5               Refused - The name server refuses to
                                perform the specified operation for
                                policy reasons.  For example, a name
                                server may not wish to provide the
                                information to the particular requester,
                                or a name server may not wish to perform
                                a particular operation (e.g., zone
```

- 특정 데이터의 경우 전송\).

- 6-15 향후 사용을 위해 예약되어 있습니다.

```text
QDCOUNT         an unsigned 16 bit integer specifying the number of
                entries in the question section.

ANCOUNT         an unsigned 16 bit integer specifying the number of
                resource records in the answer section.

NSCOUNT         an unsigned 16 bit integer specifying the number of name
                server resource records in the authority records
                section.

ARCOUNT         an unsigned 16 bit integer specifying the number of
                resource records in the additional records section.
```

---
#### **4.1.2. Question section format**

질문 섹션은 대부분의 쿼리에서 "질문", 즉 질문 대상을 정의하는 매개변수를 전달하는 데 사용됩니다. 이 섹션에는 QDCOUNT\(일반적으로 1\)개의 항목이 포함되어 있으며 각 항목의 형식은 다음과 같습니다.

```text
                                    1  1  1  1  1  1
      0  1  2  3  4  5  6  7  8  9  0  1  2  3  4  5
    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
    |                                               |
    /                     QNAME                     /
    /                                               /
    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
    |                     QTYPE                     |
    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
    |                     QCLASS                    |
    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
```

---
# **where:**

```text
QNAME           a domain name represented as a sequence of labels, where
                each label consists of a length octet followed by that
                number of octets.  The domain name terminates with the
                zero length octet for the null label of the root.  Note
                that this field may be an odd number of octets; no
                padding is used.

QTYPE           a two octet code which specifies the type of the query.
                The values for this field include all codes valid for a
                TYPE field, together with some more general codes which
                can match more than one type of RR.

QCLASS          a two octet code that specifies the class of the query.
                For example, the QCLASS field is IN for the Internet.
```

---
#### **4.1.3. Resource record format**

```text
The answer, authority, and additional sections all share the same
format: a variable number of resource records, where the number of
records is specified in the corresponding count field in the header.
Each resource record has the following format:
                                    1  1  1  1  1  1
      0  1  2  3  4  5  6  7  8  9  0  1  2  3  4  5
    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
    |                                               |
    /                                               /
    /                      NAME                     /
    |                                               |
    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
    |                      TYPE                     |
    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
    |                     CLASS                     |
    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
    |                      TTL                      |
    |                                               |
    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
    |                   RDLENGTH                    |
    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--|
    /                     RDATA                     /
    /                                               /
    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
```

---
# **where:**
---
# **NAME            a domain name to which this resource record pertains.**

```text
TYPE            two octets containing one of the RR type codes.  This
                field specifies the meaning of the data in the RDATA
                field.

CLASS           two octets which specify the class of the data in the
                RDATA field.

TTL             a 32 bit unsigned integer that specifies the time
                interval (in seconds) that the resource record may be
                cached before it should be discarded.  Zero values are
                interpreted to mean that the RR can only be used for the
                transaction in progress, and should not be cached.

RDLENGTH        an unsigned 16 bit integer that specifies the length in
                octets of the RDATA field.

RDATA           a variable length string of octets that describes the
                resource.  The format of this information varies
                according to the TYPE and CLASS of the resource record.
                For example, the if the TYPE is A and the CLASS is IN,
                the RDATA field is a 4 octet ARPA Internet address.
```

---
#### **4.1.4. Message compression**

메시지 크기를 줄이기 위해 도메인 시스템은 메시지에서 도메인 이름이 반복되는 것을 제거하는 압축 방식을 사용합니다. 이 방식에서는 전체 도메인 이름이나 도메인 이름 끝에 있는 레이블 목록이 이전에 동일한 이름이 발생한 것을 가리키는 포인터로 대체됩니다.

---
# **The pointer takes the form of a two octet sequence:**

```text
    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
    | 1  1|                OFFSET                   |
    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
```

처음 두 비트는 1입니다. 레이블은 63옥텟 이하로 제한되므로 레이블은 2개의 0비트로 시작해야 하기 때문에 포인터를 레이블과 구별할 수 있습니다. \(10과 01 조합은 향후 사용을 위해 예약되어 있습니다.\) OFFSET 필드는 메시지 시작 부분의 오프셋을 지정합니다\(즉, 도메인 헤더에 있는 ID 필드의 첫 번째 옥텟\). 제로 오프셋은 ID 필드 등의 첫 번째 바이트를 지정합니다.

압축 방식을 사용하면 메시지의 도메인 이름이 다음 중 하나로 표시될 수 있습니다.

- 0 옥텟으로 끝나는 일련의 레이블

- 포인터

- 포인터로 끝나는 일련의 레이블

포인터는 형식이 클래스별로 지정되지 않은 도메인 이름 발생에만 사용할 수 있습니다. 그렇지 않은 경우 이름 서버나 확인자는 처리하는 모든 RR의 형식을 알아야 합니다. 아직까지는 그러한 경우가 없지만 향후 RDATA 형식에서는 발생할 수 있습니다.

길이 필드\(예: RR의 RDATA 섹션\)에 따라 메시지의 일부에 도메인 이름이 포함되어 있고 압축이

사용된 경우 확장된 이름의 길이가 아닌 압축된 이름의 길이가 길이 계산에 사용됩니다.

프로그램은 자신이 생성하는 메시지에 포인터를 사용하지 않아도 되지만 이로 인해 데이터그램 용량이 줄어들고 잘림 현상이 발생할 수 있습니다. 그러나 모든 프로그램은 포인터가 포함된 도착 메시지를 이해해야 합니다.

예를 들어, 데이터그램은 도메인 이름 F.ISI.ARPA, FOO.F.ISI.ARPA, ARPA 및 루트를 사용해야 할 수 있습니다. 메시지의 다른 필드를 무시하면 이러한 도메인 이름은 다음과 같이 표시될 수 있습니다.

```text
       +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
    20 |           1           |           F           |
       +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
    22 |           3           |           I           |
       +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
    24 |           S           |           I           |
       +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
    26 |           4           |           A           |
       +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
    28 |           R           |           P           |
       +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
    30 |           A           |           0           |
       +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+

       +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
    40 |           3           |           F           |
       +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
    42 |           O           |           O           |
       +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
    44 | 1  1|                20                       |
       +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+

       +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
    64 | 1  1|                26                       |
       +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+

       +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
    92 |           0           |                       |
       +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
```

F.ISI.ARPA의 도메인 이름은 오프셋 20에 표시됩니다. 도메인 이름 FOO.F.ISI.ARPA는 오프셋 40에 표시됩니다. 이 정의는 포인터를 사용하여 FOO에 대한 레이블을 이전에 정의된 F.ISI.ARPA에 연결합니다. 도메인 이름 ARPA는 20에 있는 F.ISI.ARPA 이름의 ARPA 구성 요소에 대한 포인터를 사용하여 오프셋 64에 정의됩니다. 이 포인터는 20에 있는 문자열의 마지막 레이블인 ARPA에 의존합니다. 루트 도메인 이름은 다음과 같습니다.

92에서 0으로 구성된 단일 옥텟으로 정의됩니다. 루트 도메인 이름에는 레이블이 없습니다.

---
### **4.2. Transport**

DNS는 메시지가 데이터그램이나 가상 회선에 의해 전달되는 바이트 스트림으로 전송된다고 가정합니다. 모든 DNS 활동에 가상 회선을 사용할 수 있지만 오버헤드가 낮고 성능이 우수하므로 쿼리에는 데이터그램이 선호됩니다. 영역 새로 고침 활동은 안정적인 전송이 필요하므로 가상 회로를 사용해야 합니다.

인터넷은 서버 포트 53\(10진수\)에서 TCP \[RFC-793\]을 사용하는 네임 서버 액세스와 UDP 포트 53\(10진수\)에서 UDP \[RFC-768\]을 사용하는 데이터그램 액세스를 지원합니다.

---
#### **4.2.1. UDP usage**
---
# **Messages sent using UDP user server port 53 (decimal).**

UDP를 통해 전달되는 메시지는 512바이트로 제한됩니다\(IP 또는 UDP 헤더는 계산하지 않음\). 긴 메시지는 잘리고 헤더에 TC 비트가 설정됩니다.

UDP는 영역 전송에는 허용되지 않지만 인터넷의 표준 쿼리에는 권장되는 방법입니다. UDP를 사용하여 보낸 쿼리는 손실될 수 있으므로 재전송 전략이 필요합니다. 쿼리나 응답은 네트워크나 이름 서버의 처리에 의해 재정렬될 수 있으므로 확인자는 쿼리가 순서대로 반환되는 것에 의존해서는 안 됩니다.

최적의 UDP 재전송 정책은 인터넷 성능과 클라이언트 요구 사항에 따라 다르지만 다음이 권장됩니다.

- 클라이언트는 서버의 특정 주소에 대한 쿼리를 반복하기 전에 다른 서버와 서버 주소를 시도해야 합니다.

- 재전송 간격은 가능하면 사전 통계를 기반으로 해야 합니다. 너무 공격적인 재전송은 커뮤니티 전체의 응답을 쉽게 느리게 만들 수 있습니다. 클라이언트가 예상 서버에 얼마나 잘 연결되어 있는지에 따라 최소 재전송 간격은 2\~5초가 되어야 합니다.

서버 선택 및 재전송 정책에 대한 추가 제안은 이 메모의 확인자 섹션에서 찾을 수 있습니다.

---
#### **4.2.2. TCP usage**

TCP 연결을 통해 전송되는 메시지는 서버 포트 53\(10진수\)을 사용합니다. 메시지에는 메시지를 제공하는 2바이트 길이 필드가 접두어로 붙습니다.

2바이트 길이 필드를 제외한 길이입니다. 이 길이 필드를 사용하면 하위 수준 처리에서 구문 분석을 시작하기 전에 완전한 메시지를 조합할 수 있습니다.

---
# **Several connection management policies are recommended:**

- 서버는 TCP 데이터를 기다리는 다른 활동을 차단해서는 안 됩니다.

- 서버는 다중 연결을 지원해야 합니다.

- 서버는 클라이언트가 연결 종료를 시작할 것이라고 가정해야 하며 모든 미결 클라이언트 요청이 만족될 때까지 연결 종료를 지연해야 합니다.

- 서버가 리소스를 회수하기 위해 휴면 연결을 닫아야 하는 경우 연결이 약 2분 동안 유휴 상태가 될 때까지 기다려야 합니다. 특히 서버는 SOA 및 AXFR 요청 시퀀스\(새로 고침 작업 시작\)가 단일 연결에서 수행되도록 허용해야 합니다. 어쨌든 서버는 쿼리에 응답할 수 없기 때문에 정상적인 닫기 대신 일방적 닫기 또는 재설정을 사용할 수 있습니다.

---
## **5. MASTER FILES**

마스터 파일은 텍스트 형식의 RR을 포함하는 텍스트 파일입니다. 영역의 내용은 RR 목록 형식으로 표현될 수 있으므로 마스터 파일은 캐시의 내용을 나열하는 데에도 사용할 수 있지만 영역을 정의하는 데 가장 자주 사용됩니다. 따라서 이 섹션에서는 먼저 마스터 파일의 RR 형식에 대해 설명한 다음 마스터 파일을 사용하여 일부 이름 서버에서 영역을 생성할 때 특별히 고려해야 할 사항에 대해 설명합니다.

---
### **5.1. Format**

이러한 파일의 형식은 일련의 항목입니다. 항목은 주로 줄 지향이지만 괄호를 사용하여 줄 경계를 넘어 항목 목록을 계속할 수 있고 텍스트 리터럴은 텍스트 내에 CRLF를 포함할 수 있습니다. 탭과 공백의 조합은 항목을 구성하는 개별 항목 사이의 구분 기호 역할을 합니다. 마스터 파일의 모든 줄 끝은 주석으로 끝날 수 있습니다. 주석은 ";"으로 시작합니다. \(세미콜론\).

---
# **The following entries are defined:**

```text
    <blank>[<comment>]

    $ORIGIN <domain-name> [<comment>]

    $INCLUDE <file-name> [<domain-name>] [<comment>]

    <domain-name><rr> [<comment>]

    <blank><rr> [<comment>]
```

---
# **Blank lines, with or without comments, are allowed anywhere in the file.**

$ORIGIN 및 $INCLUDE라는 두 개의 제어 항목이 정의됩니다. $ORIGIN 뒤에는 도메인 이름이 오고 상대 도메인 이름의 현재 출처를 명시된 이름으로 재설정합니다. $INCLUDE는 명명된 파일을 현재 파일에 삽입하고 선택적으로 포함된 파일에 대한 상대 도메인 이름 원본을 설정하는 도메인 이름을 지정할 수 있습니다. $INCLUDE에도 주석이 있을 수 있습니다. $INCLUDE 항목은 포함된 파일 내에서 상대 원본이 변경된 것과 관계없이 상위 파일의 상대 원본을 변경하지 않습니다.

마지막 두 형식은 RR을 나타냅니다. RR 항목이 공백으로 시작하는 경우 RR은 마지막으로 명시된 소유자가 소유한 것으로 간주됩니다. RR 항목이 <domain-name\>으로 시작하면 소유자 이름이 재설정됩니다.

<rr\> 내용은 다음 형식 중 하나를 취합니다.

```text
    [<TTL>] [<class>] <type> <RDATA>

    [<class>] [<TTL>] <type> <RDATA>
```

RR은 선택적 TTL 및 클래스 필드로 시작하고 그 뒤에 유형 및 클래스에 적합한 유형 및 RDATA 필드가 옵니다. 클래스 및 유형은 표준 니모닉을 사용하며 TTL은 10진수 정수입니다. 생략된 클래스 및 TTL 값은 마지막으로 명시적으로 명시된 값이 기본값입니다. 유형과 클래스 니모닉은 분리되어 있으므로 구문 분석은 고유합니다. \(이 순서는 예제에 사용된 순서 및 실제 RR에 사용된 순서와 다릅니다. 주어진 순서를 사용하면 구문 분석 및 기본값 설정이 더 쉬워집니다.\)

<domain-name\>은 마스터 파일에서 데이터의 큰 부분을 차지합니다. 도메인 이름의 레이블은 문자열로 표현되며 점으로 구분됩니다. 인용 규칙을 사용하면 임의의 문자를 도메인 이름에 저장할 수 있습니다. 점으로 끝나는 도메인 이름을 절대 도메인 이름이라고 하며 완전한 것으로 간주됩니다. 점으로 끝나지 않는 도메인 이름을 상대 도메인 이름이라고 합니다. 실제 도메인 이름은 $ORIGIN, $INCLUDE에 지정되거나 마스터 파일 로딩 루틴에 대한 인수로 지정된 원본과 상대 부분을 연결한 것입니다. 상대 이름은 출처가 없을 때 발생하는 오류입니다.

<character-string\>은 내부 공백이 없는 연속된 문자 집합 또는 "로 시작하고 "로 끝나는 문자열 등 한 가지 또는 두 가지 방법으로 표현됩니다. "로 구분된 문자열 내부에는 \(백슬래시\)를 사용하여 인용해야 하는 " 자체를 제외하고 모든 문자가 포함될 수 있습니다.

이러한 파일은 텍스트 파일이기 때문에 임의의 데이터를 로드하려면 몇 가지 특수 인코딩이 필요합니다. 특히:

- 뿌리의.

@ 독립형 @은 현재 원점을 나타내는 데 사용됩니다.

```text
\X              where X is any character other than a digit (0-9), is
                used to quote that character so that its special meaning
                does not apply.  For example, "\." can be used to place
                a dot character in a label.

\DDD            where each D is a digit is the octet corresponding to
                the decimal number described by DDD.  The resulting
                octet is assumed to be text and is not checked for
                special meaning.

( )             Parentheses are used to group data that crosses a line
                boundary.  In effect, line terminations are not
                recognized within parentheses.

;               Semicolon is used to start a comment; the remainder of
                the line is ignored.
```

---
### **5.2. Use of master files to define zones**

마스터 파일을 사용하여 영역을 로드하는 경우 마스터 파일에 오류가 발생하면 작업이 억제되어야 합니다. 이에 대한 근거는 단일 오류가 광범위한 결과를 초래할 수 있다는 것입니다. 예를 들어 위임을 정의하는 RR에 구문 오류가 있다고 가정해 보겠습니다. 그러면 서버는 하위 영역의 모든 이름에 대해 신뢰할 수 있는 이름 오류를 반환합니다\(하위 영역이 서버에도 있는 경우는 제외\).

파일의 구문이 올바른지 확인하는 것 외에도 수행해야 하는 몇 가지 다른 유효성 검사는 다음과 같습니다.

1. 파일의 모든 RR은 동일한 클래스를 가져야 합니다.

2. 영역 상단에는 정확히 하나의 SOA RR이 있어야 합니다.

3. 대표단이 참석하고 글루 정보가 필요한 경우 참석해야 합니다.

4. 영역의 권한 있는 노드 외부에 존재하는 정보는 원본이나 유사한 오류의 결과가 아닌 글루 정보여야 합니다.

---
### **5.3. Master file example**

다음은 ISI.EDU 영역을 정의하는 데 사용할 수 있고 ISI.EDU의 원본과 함께 로드되는 예제 파일입니다.

```text
@   IN  SOA     VENERA      Action\.domains (
                                 20     ; SERIAL
                                 7200   ; REFRESH
                                 600    ; RETRY
                                 3600000; EXPIRE
                                 60)    ; MINIMUM

        NS      A.ISI.EDU.
        NS      VENERA
        NS      VAXA
        MX      10      VENERA
        MX      20      VAXA
```

---
# **A       A       26.3.0.103**

```text
VENERA  A       10.1.0.52
        A       128.9.0.32

VAXA    A       10.2.0.27
        A       128.9.0.33

$INCLUDE <SUBSYS>ISI-MAILBOXES.TXT
```

---
# **Where the file <SUBSYS>ISI-MAILBOXES.TXT is:**

```text
    MOE     MB      A.ISI.EDU.
    LARRY   MB      A.ISI.EDU.
    CURLEY  MB      A.ISI.EDU.
    STOOGES MG      MOE
            MG      LARRY
            MG      CURLEY
```

담당자 사서함 "Action.domains@E.ISI.EDU"를 지정하려면 SOA RR에서 \ 문자를 사용합니다.

---
## **6. NAME SERVER IMPLEMENTATION**
---
### **6.1. Architecture**

이름 서버의 최적 구조는 호스트 운영 체제에 따라 달라지며, 재귀 서비스를 지원하거나 데이터베이스를 확인자와 공유하여 이름 서버가 확인자 작업과 통합되는지 여부에 따라 달라집니다. 이 섹션에서는 확인자와 데이터베이스를 공유하는 이름 서버에 대한 구현 고려 사항을 설명하지만 이러한 문제의 대부분은 모든 이름 서버에 존재합니다.

---
#### **6.1.1. Control**

이름 서버는 호스트 OS에서 별도의 작업으로 구현되거나 단일 이름 서버 프로그램 내에서 다중화되는지 여부에 관계없이 여러 동시 활동을 사용해야 합니다. 이름 서버가 새로 고침이나 쿼리 활동을 위해 TCP 데이터를 기다리는 동안 UDP 요청 서비스를 차단하는 것은 허용되지 않습니다. 마찬가지로, 이름 서버는 단일 클라이언트의 요청을 직렬화하거나 동일한 클라이언트의 동일한 요청을 중복으로 간주하도록 선택할 수 있지만 그러한 요청을 병렬로 처리하지 않고 재귀적인 서비스를 제공하려고 시도해서는 안 됩니다. 네임 서버는 마스터 파일에서 영역을 다시 로드하거나 새로 새로 고친 영역을 데이터베이스에 통합하는 동안 요청을 크게 지연해서는 안 됩니다.

---
#### **6.1.2. Database**

이름 서버 구현은 선택한 내부 데이터 구조를 자유롭게 사용할 수 있지만 제안된 구조는 세 가지 주요 부분으로 구성됩니다.

- 이 서버에서 사용할 수 있는 영역을 나열하는 "카탈로그" 데이터 구조와 영역 데이터 구조에 대한 "포인터"입니다. 이 구조의 주요 목적은 표준 쿼리 도착을 위해 가장 가까운 조상 영역을 찾는 것입니다.

- 네임 서버가 보유하는 각 영역에 대한 별도의 데이터 구조.

- 캐시된 데이터에 대한 데이터 구조입니다. \(또는 다른 클래스에 대해 별도의 캐시를 사용할 수도 있음\)

이러한 모든 데이터 구조는 동일한 트리 구조 형식으로 구현될 수 있으며, 서로 다른 데이터가 서로 다른 부분의 노드에 연결되어 있습니다. 카탈로그에서 데이터는 영역에 대한 포인터인 반면 영역 및 캐시 데이터 구조에서는 데이터가 RR이 됩니다. 트리 프레임워크를 설계할 때 디자이너는 쿼리 처리가 대소문자를 구분하지 않는 레이블 비교를 사용하여 트리를 순회해야 한다는 점을 인식해야 합니다. 그리고 그거

실제 데이터에서는 소수의 노드가 매우 높은 분기 인자\(100-1000 이상\)를 갖지만 대다수는 매우 낮은 분기 인자\(0-1\)를 갖습니다.

대소문자 문제를 해결하는 한 가지 방법은 각 노드의 레이블을 두 부분으로 저장하는 것입니다. 즉, 모든 ASCII 문자가 단일 대소문자로 표시되는 표준화된 대소문자 표현과 실제로 어떤 문자가 문자인지 나타내는 비트 마스크입니다. 다른 경우. 분기 요인 다양성은 분기 요인이 일부 임계값을 초과할 때까지 노드에 대한 간단한 연결 목록을 사용하고 임계값을 초과한 후 해시 구조로 전환하여 처리할 수 있습니다. 어떤 경우든 트리 섹션을 저장하는 데 사용되는 해시 구조는 해시 함수와 절차가 DNS의 대소문자 구분 규칙을 유지하도록 보장해야 합니다.

데이터베이스의 여러 부분에 대해 별도의 구조를 사용하는 것은 다음과 같은 여러 요인에 의해 결정됩니다.

- 카탈로그 구조는 시스템 관리자가 서버에서 지원하는 영역을 변경할 때만 변경이 필요한 거의 정적 구조일 수 있습니다. 이 구조는 새로 고침 활동을 제어하는 ​​데 사용되는 매개변수를 저장하는 데에도 사용할 수 있습니다.

- 구역의 개별 데이터 구조를 사용하면 카탈로그에서 포인터를 변경하여 구역을 간단히 교체할 수 있습니다. 영역 새로 고침 작업은 새로운 구조를 구축할 수 있으며, 완료되면 간단한 포인터 교체를 통해 이를 데이터베이스에 연결할 수 있습니다. 영역을 새로 고칠 때 쿼리에서 이전 데이터와 새 데이터를 동시에 사용해서는 안 된다는 것이 매우 중요합니다.

- 적절한 검색 절차를 사용하면 영역의 권한 있는 데이터가 항상 "숨겨져" 캐시된 데이터보다 우선합니다.

- 영역 중첩 등을 유발하는 영역 정의 오류로 인해 쿼리에 대한 잘못된 응답이 발생할 수 있지만 문제 판단이 단순화되고 "불량" 영역의 내용이 다른 영역을 손상시킬 수 없습니다.

- 캐시는 가장 자주 업데이트되므로 시스템을 다시 시작하는 동안 손상되기 가장 쉽습니다. 또한 만료된 RR 데이터로 가득 차 있을 수도 있습니다. 두 경우 모두 영역 데이터를 방해하지 않고 쉽게 삭제할 수 있습니다.

데이터베이스 설계의 주요 측면은 이름 서버가 이름 서버 호스트의 충돌을 처리할 수 있도록 하는 구조를 선택하는 것입니다. 시스템 충돌 시 네임서버가 저장해야 하는 상태 정보

카탈로그 구조\(각 영역의 새로 고침 상태 포함\)와 영역 데이터 자체가 포함됩니다.

---
#### **6.1.3. Time**

RR의 TTL 데이터와 활동 새로 고침을 위한 타이밍 데이터는 모두 초 단위의 32비트 타이머에 따라 달라집니다. 데이터베이스 내부에서는 캐시된 데이터에 대한 새로 고침 타이머와 TTL이 개념적으로 "카운트다운"되는 반면, 영역의 데이터는 일정한 TTL로 유지됩니다.

권장되는 구현 전략은 두 가지 방법, 즉 상대 증분과 절대 시간으로 시간을 저장하는 것입니다. 이를 수행하는 한 가지 방법은 한 유형에는 양수 32비트 숫자를 사용하고 다른 유형에는 음수를 사용하는 것입니다. 구역의 RR은 상대 시간을 사용합니다. 새로 고침 타이머와 캐시 데이터는 절대 시간을 사용합니다. 절대 숫자는 일부 알려진 출처와 관련하여 취해지며 쿼리에 대한 응답에 배치될 때 상대 값으로 변환됩니다. 상대 TTL로 변환한 후 절대 TTL이 음수이면 데이터가 만료되므로 무시해야 합니다.

---
### **6.2. Standard query processing**

표준 쿼리 처리를 위한 주요 알고리즘은 \[RFC-1034\]에 나와 있습니다.

QCLASS=\* 또는 여러 클래스와 일치하는 다른 QCLASS를 사용하여 쿼리를 처리할 때 서버가 응답이 모든 클래스를 포함한다고 보장할 수 없다면 응답은 절대 신뢰할 수 없습니다.

응답 작성시 추가란에 삽입해야 할 RR이 있으나, 답변 또는 권한란에 중복되는 RR은 추가란에서 생략할 수 있다.

응답이 너무 길어서 잘림이 필요한 경우 잘림은 응답 끝에서 시작하여 데이터그램에서 계속 진행되어야 합니다. 따라서 권한 섹션에 대한 데이터가 있으면 답변 섹션의 고유성이 보장됩니다.

SOA의 MINIMUM 값은 영역에서 배포된 데이터의 TTL에 대한 최소값을 설정하는 데 사용되어야 합니다. 이 바닥 기능은 데이터가 응답에 복사될 때 수행되어야 합니다. 이를 통해 향후 동적 업데이트 프로토콜이 모호한 의미 없이 SOA MINIMUM 필드를 변경할 수 있습니다.

---
### **6.3. Zone refresh and reload processing**

서버의 최선의 노력에도 불구하고 구문 오류 등으로 인해 마스터 파일에서 영역 데이터를 로드하지 못하거나 만료 매개변수 내에서 영역을 새로 고치지 못할 수 있습니다. 이 경우 네임서버는

---
# **should answer queries as if it were not supposed to possess the zone.**

마스터가 AXFR을 통해 영역을 전송하고 전송 중에 새 버전이 생성되는 경우 마스터는 가능하면 이전 버전을 계속 전송해야 합니다. 어떤 경우에도 한 버전의 일부와 다른 버전의 일부를 전송해서는 안 됩니다. 완료할 수 없는 경우 마스터는 영역 전송이 발생하는 연결을 재설정해야 합니다.

---
### **6.4. Inverse queries (Optional)**

역 쿼리는 DNS의 선택적 부분입니다. 이름 서버는 어떤 형태의 역 쿼리도 지원할 필요가 없습니다. 이름 서버가 지원하지 않는 역 쿼리를 수신하면 헤더에 "구현되지 않음" 오류가 설정된 오류 응답을 반환합니다. 역 쿼리 지원은 선택 사항이지만 모든 이름 서버는 최소한 오류 응답을 반환할 수 있어야 합니다.

6.4.1. 역 쿼리 및 응답의 내용 역 쿼리는 표준 쿼리 작업에 의해 수행된 매핑을 반대로 합니다. 표준 쿼리는 도메인 이름을 리소스에 매핑하는 반면, 역 쿼리는 리소스를 도메인 이름에 매핑합니다. 예를 들어, 표준 쿼리는 도메인 이름을 호스트 주소에 바인딩할 수 있습니다. 해당 역 쿼리는 호스트 주소를 도메인 이름에 바인딩합니다.

역 쿼리는 메시지의 답변 섹션에 빈 질문 섹션이 있는 단일 RR 형식을 취합니다. 쿼리 RR의 소유자 이름과 해당 TTL은 중요하지 않습니다. 응답은 이름 서버가 알고 있는 쿼리 RR을 소유한 모든 이름을 식별하는 질문 섹션에 질문을 전달합니다. 모든 도메인 이름 공간에 대해 아는 이름 서버가 없기 때문에 응답이 완전하다고 가정할 수 없습니다. 따라서 역 쿼리는 주로 데이터베이스 관리 및 디버깅 활동에 유용합니다. 역 쿼리는 호스트 주소를 호스트 이름에 매핑하는 데 허용되는 방법이 아닙니다. 대신 IN-ADDR.ARPA 도메인을 사용하세요.

가능하다면 네임서버는 역 쿼리에 대해 대소문자를 구분하지 않는 비교를 제공해야 합니다. 따라서 "Venera.isi.edu"의 MX RR을 요청하는 역 쿼리는 "VENERA.ISI.EDU"에 대한 쿼리와 동일한 응답을 얻어야 합니다. HINFO RR "IBM-PC UNIX"에 대한 역 쿼리는 "IBM-pc unix"에 대한 역 쿼리와 동일한 결과를 생성해야 합니다. 그러나 네임서버가 문자열을 포함하는 RR을 소유할 수 있지만 네임서버는 데이터가 문자인지 알지 못하기 때문에 이를 보장할 수 없습니다.

---
# **When a name server processes an inverse query, it either returns:**

1. 질문 섹션의 QNAME으로 지정된 리소스에 대한 0개, 1개 또는 여러 개의 도메인 이름

2. 네임 서버가 지정된 리소스 유형의 역 매핑을 지원하지 않음을 나타내는 오류 코드.

역 쿼리에 대한 응답에 하나 이상의 QNAME이 포함된 경우 역 쿼리를 정의하는 답변 섹션에 있는 RR의 소유자 이름과 TTL은 첫 번째 QNAME에서 발견된 RR과 정확히 일치하도록 수정됩니다.

역 쿼리에서 반환된 RR은 표준 쿼리에 대한 응답에 사용되는 것과 동일한 메커니즘을 사용하여 캐시할 수 없습니다. 그 이유 중 하나는 이름에 동일한 유형의 RR이 여러 개 있을 수 있고 하나만 나타날 수 있기 때문입니다. 예를 들어 다중 홈 호스트의 단일 주소에 대한 역 쿼리는 주소가 하나만 존재한다는 인상을 줄 수 있습니다.

```text
6.4.2. Inverse query and response example          The overall structure
of an inverse query for retrieving the domain name that corresponds to
Internet address 10.1.0.52 is shown below:

                         +-----------------------------------------+
           Header        |          OPCODE=IQUERY, ID=997          |
                         +-----------------------------------------+
          Question       |                 <empty>                 |
                         +-----------------------------------------+
           Answer        |        <anyname> A IN 10.1.0.52         |
                         +-----------------------------------------+
          Authority      |                 <empty>                 |
                         +-----------------------------------------+
         Additional      |                 <empty>                 |
                         +-----------------------------------------+
```

이 쿼리는 답변이 인터넷 스타일 주소 10.1.0.52인 질문을 요청합니다. 소유자 이름을 알 수 없으므로 모든 도메인 이름을 자리 표시자로 사용할 수 있습니다\(무시됩니다\). 루트를 나타내는 0의 단일 옥텟은 일반적으로 메시지 길이를 최소화하기 때문에 사용됩니다. RR의 TTL은 중요하지 않습니다. 이 쿼리에 대한 응답은 다음과 같습니다.

```text
                         +-----------------------------------------+
           Header        |         OPCODE=RESPONSE, ID=997         |
                         +-----------------------------------------+
          Question       |QTYPE=A, QCLASS=IN, QNAME=VENERA.ISI.EDU |
                         +-----------------------------------------+
           Answer        |  VENERA.ISI.EDU  A IN 10.1.0.52         |
                         +-----------------------------------------+
          Authority      |                 <empty>                 |
                         +-----------------------------------------+
         Additional      |                 <empty>                 |
                         +-----------------------------------------+
```

역 쿼리에 대한 응답의 QTYPE은 역 쿼리의 답변 섹션에 있는 TYPE 필드와 동일합니다. 역 쿼리에 대한 응답에는 역 쿼리가 고유하지 않은 경우 여러 질문이 포함될 수 있습니다. 응답의 질문 섹션이 비어 있지 않으면 답변 섹션의 RR이 첫 번째 QNAME에 있는 RR의 정확한 복사본에 해당하도록 수정됩니다.

---
#### **6.4.3. Inverse query processing**

역 쿼리를 지원하는 네임 서버는 데이터베이스의 철저한 검색을 통해 이러한 작업을 지원할 수 있지만 데이터베이스 크기가 증가함에 따라 이는 실용적이지 않습니다. 또 다른 접근 방식은 검색 키에 따라 데이터베이스를 반전시키는 것입니다.

여러 영역과 대용량 데이터를 지원하는 네임서버의 경우 권장되는 접근 방식은 각 영역에 대해 별도의 반전을 수행하는 것입니다. 새로 고치는 동안 특정 영역이 변경되면 해당 영역의 반전만 다시 실행하면 됩니다.

이러한 유형의 반전 전송에 대한 지원은 도메인 시스템의 향후 버전에 포함될 수 있지만 이 버전에서는 지원되지 않습니다.

---
### **6.5. Completion queries and responses**

RFC-882 및 RFC-883에 설명된 선택적 완성 서비스가 삭제되었습니다. 향후 재설계된 서비스가 제공될 수 있습니다.

---
## **7. RESOLVER IMPLEMENTATION**

권장되는 확인자 알고리즘의 최상위 수준은 \[RFC-1034\]에서 논의됩니다. 이 섹션에서는 이 메모의 이름 서버 구현 섹션에서 제안된 데이터베이스 구조를 가정하여 구현 세부 사항을 논의합니다.

---
### **7.1. Transforming a user request into a query**

리졸버가 취하는 첫 번째 단계는 로컬 OS에 적합한 형식으로 명시된 클라이언트의 요청을 특정 QTYPE 및 QCLASS와 일치하는 특정 이름의 RR에 대한 검색 사양으로 변환하는 것입니다. 가능하다면 QTYPE과 QCLASS는 단일 유형과 단일 클래스에 대응해야 합니다. 이렇게 하면 캐시된 데이터를 훨씬 더 쉽게 사용할 수 있기 때문입니다. 그 이유는 캐시에 한 가지 유형의 데이터가 있다고 해서 다른 유형의 데이터가 존재하는지 존재하지 않는지 확인하는 것이 아니기 때문입니다. 따라서 이를 확인하는 유일한 방법은 권위 있는 소스에 문의하는 것입니다. QCLASS=\*를 사용하면 신뢰할 수 있는 답변을 사용할 수 없습니다.

확인자가 기능을 효율적으로 수행하려면 여러 요청을 다중화할 수 있어야 하므로 보류 중인 각 요청은 일반적으로 일부 상태 정보 블록에 표시됩니다. 이 상태 블록에는 일반적으로 다음이 포함됩니다.

- 요청이 시작된 시간을 나타내는 타임스탬프입니다. 타임스탬프는 데이터베이스의 RR을 사용할 수 있는지 또는 오래된 것인지 결정하는 데 사용됩니다. 이 타임스탬프는 영역 및 캐시의 RR 저장소에 대해 이전에 설명한 절대 시간 형식을 사용합니다. RR TTL이 상대 시간을 나타내는 경우 RR은 영역의 일부이므로 시기적절해야 합니다. RR에 절대 시간이 있는 경우 이는 캐시의 일부이며 RR의 TTL은 요청 시작의 타임스탬프와 비교됩니다.

타임스탬프를 사용하는 것이 현재 시간을 사용하는 것보다 우수하다는 점에 유의하세요. TTL이 0인 RR을 일반적인 방식으로 캐시에 입력할 수 있지만 시스템 로드로 인해 몇 초의 간격이 지난 후에도 현재 요청에서 여전히 사용되기 때문입니다. , 쿼리 재전송 시간 초과 등

- 이 요청에 대해 수행될 작업량을 제한하는 일종의 매개변수입니다.

```text
     The amount of work which a resolver will do in response to a
     client request must be limited to guard against errors in the
     database, such as circular CNAME references, and operational
     problems, such as network partition which prevents the
```

확인자가 필요한 이름 서버에 액세스하지 못하게 합니다. 확인자가 특정 쿼리를 특정 이름 서버 주소로 재전송하는 횟수에 대한 로컬 제한은 필수적이지만 확인자에는 단일 요청에 대한 작업을 제한하기 위한 전역 요청별 카운터가 있어야 합니다. 카운터는 초기 값으로 설정되어야 하며 확인자가 작업\(재전송 시간 초과, 재전송 등\)을 수행할 때마다 감소해야 합니다. 카운터가 0을 전달하면 일시적인 오류와 함께 요청이 종료됩니다.

해석기 구조가 하나의 요청이 다른 요청을 병렬로 시작할 수 있도록 허용하는 경우\(예: 하나의 요청에 대해 이름 서버에 액세스해야 하여 이름 서버 주소에 대한 병렬 해석이 발생하는 경우\) 생성된 요청은 더 낮은 카운터로 시작되어야 합니다. 이렇게 하면 데이터베이스의 순환 참조가 확인자 활동의 연쇄 반응을 시작하는 것을 방지할 수 있습니다.

- \[RFC-1034\]에서 논의된 SLIST 데이터 구조.

이 구조는 외부 이름 서버의 응답을 기다려야 하는 경우 요청 상태를 추적합니다.

---
### **7.2. Sending the queries**

\[RFC-1034\]에 설명된 대로 확인자의 기본 작업은 클라이언트의 요청에 응답할 쿼리를 작성하고 해당 쿼리를 정보를 제공할 수 있는 이름 서버로 보내는 것입니다. 확인자는 일반적으로 NS RR 형식으로 어떤 서버에 요청할 것인지에 대한 매우 강력한 힌트만 가지며 CNAME에 대한 응답으로 쿼리를 수정하거나 확인자가 요청하는 이름 서버 세트를 수정해야 할 수도 있습니다. 확인자가 원하는 정보에 더 가까운 이름 서버를 가리키는 위임 응답입니다. 클라이언트가 요청한 정보 외에도 확인자는 연결하려는 이름 서버의 주소를 결정하기 위해 자체 서비스를 호출해야 할 수도 있습니다.

어떤 경우든 이 메모에 사용된 모델은 확인자가 여러 요청\(일부는 클라이언트로부터, 일부는 내부적으로 생성됨\) 간에 주의를 다중화하고 있다고 가정합니다. 각 요청은 일부 상태 정보로 표시되며, 원하는 동작은 요청에 응답할 확률을 최대화하고 요청에 소요되는 시간을 최소화하며 과도한 전송을 방지하는 방식으로 확인자가 이름 서버에 쿼리를 전송하는 것입니다. 키 알고리즘은 요청의 상태 정보를 사용하여 쿼리할 다음 이름 서버 주소를 선택하고 응답이 도착하지 않을 경우 다음 작업을 발생시키는 시간 초과를 계산합니다. 다음 작업은 일반적으로 다른 서버로 전송되는 것이지만 일시적인 오류일 수도 있습니다.

---
## **client.**

확인자는 항상 쿼리할 서버 이름 목록\(SLIST\)으로 시작합니다. 이 목록은 리졸버가 알고 있는 가장 가까운 상위 영역에 해당하는 모든 NS RR입니다. 시작 문제를 방지하려면 해석기에 적절한 현재 NS RR이 없는 경우 요청할 기본 서버 세트가 있어야 합니다. 그런 다음 확인자는 이름 서버에 대해 알려진 모든 주소를 SLIST에 추가하고 확인자에 이름 서버에 대한 이름은 있지만 주소가 없는 경우 서버 주소를 얻기 위해 병렬 요청을 시작할 수 있습니다.

SLIST의 초기화를 완료하기 위해 확인자는 자신이 가지고 있는 모든 기록 정보를 SLIST의 각 주소에 연결합니다. 이는 일반적으로 주소의 응답 시간에 대한 일종의 가중 평균과 주소의 타격 평균\(즉, 주소가 요청에 응답한 빈도\)으로 구성됩니다. 특정 서버의 응답 시간과 타격 평균은 주소마다 상당히 다를 수 있으므로 이 정보는 네임 서버 기준이 아닌 주소 기준으로 유지되어야 합니다. 또한 이 정보는 실제로 확인자 주소/서버 주소 쌍에만 해당되므로 주소가 여러 개인 확인자는 각 주소에 대해 별도의 기록을 유지하려고 할 수 있습니다. 이 단계의 일부는 그러한 기록이 없는 주소를 처리해야 합니다. 이 경우 예상 왕복 시간은 5\~10초가 최악의 경우이며 동일한 로컬 네트워크에 대한 추정치는 더 낮습니다.

위임을 따를 때마다 확인자 알고리즘이 SLIST를 다시 초기화합니다.

이 정보는 사용 가능한 이름 서버 주소의 부분 순위를 설정합니다. 주소가 선택될 때마다 다른 모든 주소를 시도할 때까지 해당 주소가 다시 선택되지 않도록 상태를 변경해야 합니다. 각 전송의 시간 초과는 응답의 변동을 허용하기 위해 평균 예측 값보다 50-100% 더 커야 합니다.

---
# **Some fine points:**

- 확인자는 SLIST에 명명된 이름 서버에 사용할 수 있는 주소가 없고 목록에 있는 서버가 일반적으로 자신의 주소를 찾는 데 사용되는 서버인 상황에 직면할 수 있습니다. 이러한 상황은 일반적으로 글루 주소 RR이 NS RR 표시 위임보다 TTL이 작거나 확인자가 NS 검색 결과를 캐시할 때 발생합니다. 해석기는 이 조건을 감지하고 다음 조상 영역이나 루트에서 검색을 다시 시작해야 합니다.

- 확인자가 이름 서버로부터 서버 오류나 기타 이상한 응답을 받으면 SLIST에서 이를 제거해야 하며 다음 후보 서버 주소로 즉시 전송하도록 예약할 수 있습니다.

---
### **7.3. Processing responses**

도착하는 응답 데이터그램을 처리하는 첫 번째 단계는 응답을 구문 분석하는 것입니다. 이 절차에는 다음이 포함되어야 합니다.

- 헤더의 합리성을 확인하세요. 응답이 예상되는 쿼리인 데이터그램을 폐기합니다.

- 메시지 섹션을 구문 분석하고 모든 RR의 형식이 올바른지 확인하세요.

- 선택 사항으로 TTL이 지나치게 긴 RR을 찾는 도착 데이터의 TTL을 확인합니다. RR의 TTL이 지나치게 긴 경우\(예: 1주 이상\) 전체 응답을 삭제하거나 응답의 모든 TTL을 1주로 제한합니다.

다음 단계는 응답을 현재 확인자 요청과 일치시키는 것입니다. 권장되는 전략은 도메인 헤더의 ID 필드를 사용하여 예비 매칭을 수행한 후 질문 섹션이 현재 원하는 정보와 일치하는지 확인하는 것입니다. 이를 위해서는 전송 알고리즘이 도메인 ID 필드의 여러 비트를 일종의 요청 식별자에 할당해야 합니다. 이 단계에는 몇 가지 중요한 사항이 있습니다.

- 일부 네임서버는 쿼리를 수신하는 데 사용된 주소와 다른 주소에서 응답을 보냅니다. 즉, 확인자는 해당 쿼리를 보낸 주소와 동일한 주소에서 응답이 올 것이라고 믿을 수 없습니다. 이 이름 서버 버그는 일반적으로 UNIX 시스템에서 발생합니다.

- 확인자가 특정 요청을 이름 서버로 재전송하는 경우 모든 전송의 응답을 사용할 수 있어야 합니다. 그러나 응답을 사용하여 이름 서버에 액세스하기 위한 왕복 시간을 샘플링하는 경우 어떤 전송이 응답과 일치하는지 판단하거나\(그리고 각 발신 메시지에 대한 전송 시간을 유지\) 다음을 기준으로 왕복 시간만 계산할 수 있어야 합니다. 초기 전송.

- 이름 서버에는 일부 NS RR에 따라 있어야 하는 영역의 현재 복사본이 없는 경우가 있습니다. 확인자는 현재 SLIST에서 이름 서버를 제거하고 계속 진행해야 합니다.

---
### **7.4. Using the cache**

일반적으로 확인자는 향후 클라이언트 요청에 응답하는 데 유용할 수 있으므로 응답으로 수신하는 모든 데이터를 캐시할 것으로 예상합니다. 그러나 캐시하면 안 되는 데이터 유형에는 여러 가지가 있습니다.

- 특정 소유자 이름에 대해 동일한 유형의 여러 RR을 ​​사용할 수 있는 경우 확인자는 이를 모두 캐시하거나 전혀 캐시하지 않아야 합니다. 응답이 잘리고 확인자가 완전한 세트가 있는지 여부를 알 수 없는 경우 부분적인 RR 세트를 캐시하면 안 됩니다.

- 캐시된 데이터는 신뢰할 수 있는 데이터보다 우선적으로 사용되어서는 안 됩니다. 따라서 캐싱으로 인해 이런 일이 발생하는 경우 데이터를 캐시해서는 안 됩니다.

- 역질의 결과는 캐시되어서는 안 됩니다.

- 데이터가 와일드카드를 구성하는 데 사용될 수 있는 경우 QNAME에 "\*" 레이블이 포함된 표준 쿼리의 결과입니다. 그 이유는 와일드카드 RR의 적용을 제한하는 데 필요한 기존 RR이나 영역 경계 정보가 캐시에 반드시 포함되어 있지 않기 때문입니다.

- 신뢰성이 의심되는 RR 데이터. 확인자가 원치 않는 응답이나 요청한 것 이외의 RR 데이터를 받으면 캐시하지 않고 이를 폐기해야 합니다. 기본적인 의미는 패킷에 대한 모든 온전성 검사가 캐시되기 전에 수행되어야 한다는 것입니다.

비슷한 맥락에서, 확인자가 응답의 일부 이름에 대한 RR 세트를 갖고 있고 RR을 캐시하려는 경우 캐시에서 이미 존재하는 RR을 확인해야 합니다. 상황에 따라 응답의 데이터나 캐시 중 하나가 선호되지만 이 둘을 결합해서는 안 됩니다. 응답의 데이터가 답변 섹션의 신뢰할 수 있는 데이터에서 나온 경우 항상 선호됩니다.

---
## **8. MAIL SUPPORT**

도메인 시스템은 메일함을 도메인 이름으로 매핑하는 표준과 메일 라우팅 정보를 파생하기 위해 메일함 정보를 사용하는 두 가지 방법을 정의합니다. 첫 번째 방법은 메일 교환 바인딩이고 다른 방법은 메일함 바인딩입니다. 사서함 인코딩 표준과 메일 교환 바인딩은 DNS 공식 프로토콜의 일부이며 인터넷에서 메일 라우팅에 권장되는 방법입니다. 사서함 바인딩은 아직 개발 중이며 변경될 수 있는 실험적인 기능입니다.

사서함 인코딩 표준에서는 "<local-part\>@<mail-domain\>" 형식의 사서함 이름을 가정합니다. 이러한 각 섹션에서 허용되는 구문은 다양한 메일 인터넷마다 크게 다르지만 ARPA 인터넷에 선호되는 구문은 \[RFC-822\]에 나와 있습니다.

DNS는 <local-part\>를 단일 레이블로 인코딩하고, <mail-domain\>을 도메인 이름으로 인코딩합니다. <local-part\>의 단일 레이블은 <mail-domain\>의 도메인 이름 앞에 추가되어 사서함에 해당하는 도메인 이름을 형성합니다. 따라서 사서함 HOSTMASTER@SRI-NIC.ARPA는 도메인 이름 HOSTMASTER.SRI-NIC.ARPA에 매핑됩니다. <local-part\>에 점이나 기타 특수 문자가 포함된 경우 마스터 파일에 표시하려면 도메인 이름이 올바르게 인코딩되도록 백슬래시 인용을 사용해야 합니다. 예를 들어 Action.domains@ISI.EDU 사서함은 Action\.domains.ISI.EDU로 표시됩니다.

---
### **8.1. Mail exchange binding**

메일 교환 바인딩은 메일을 보낼 위치를 결정하기 위해 메일함 사양의 <mail-domain\> 부분을 사용합니다. <local-part\>는 참조되지도 않습니다. \[RFC-974\]에서는 이 방법을 자세히 지정하고 있으며 메일 교환 지원을 사용하기 전에 문의해야 합니다.

이 방법의 장점 중 하나는 조회 기능의 또 다른 간접 계층을 희생하면서 메일 서비스를 지원하는 데 사용되는 호스트에서 메일 대상 이름 지정을 분리한다는 것입니다. 그러나 추가 레이어는 <local-part\>에서 복잡한 "%", "!" 등의 인코딩이 필요하지 않도록 해야 합니다.

이 방법의 핵심은 <mail-domain\>이 순서에 따라 호스트 순위를 매기는 기본 설정 값과 함께 <mail-domain\>에 대한 메일을 수락할 호스트를 나열하는 MX RR 유형을 찾기 위한 도메인 이름으로 사용된다는 것입니다. <mail-domain\>에 대해 관리자가 지정합니다.

이 메모에서는 <mail-domain\> ISI.EDU가 호스트 VENERA.ISI.EDU 및 VAXA.ISI.EDU와 함께 ISI.EDU의 메일 교환으로 사용되었습니다. 메일러에 Mockapetris@ISI.EDU에 대한 메시지가 있는 경우 ISI.EDU에 대한 MX RR을 검색하여 해당 메시지를 라우팅합니다. ISI.EDU 이름 VENERA.ISI.EDU 및 VAXA.ISI.EDU의 MX RR 및 유형 A 쿼리는 호스트 주소를 찾을 수 있습니다.

---
### **8.2. Mailbox binding (Experimental)**

사서함 바인딩에서 메일러는 전체 메일 대상 사양을 사용하여 도메인 이름을 구성합니다. 사서함의 인코딩된 도메인 이름은 QTYPE=MAILB 쿼리에서 QNAME 필드로 사용됩니다.

---
# **Several outcomes are possible for this query:**

1. 쿼리는 사서함이 도메인 이름으로 존재하지 않음을 나타내는 이름 오류를 반환할 수 있습니다.

- 장기적으로 이는 지정된 사서함이 존재하지 않음을 나타냅니다. 그러나 사서함 바인딩 사용이 보편화될 때까지 이 오류 조건은 전역 부분으로 식별된 조직이 사서함 바인딩을 지원하지 않는다는 의미로 해석되어야 합니다. 적절한 절차는 이 시점에서 교환 바인딩으로 되돌리는 것입니다.

2. 쿼리는 MR\(Mail Rename\) RR을 반환할 수 있습니다.

- MR RR은 RDATA 필드에 새로운 메일함 사양을 포함합니다. 메일러는 이전 사서함을 새 사서함으로 교체하고 작업을 다시 시도해야 합니다.

3. 쿼리는 MB RR을 반환할 수 있습니다.

- MB RR은 RDATA 필드에 호스트의 도메인 이름을 전달합니다. 메일러는 적용 가능한 프로토콜\(예: b,SMTP\)을 통해 해당 호스트에 메시지를 전달해야 합니다.

4. 쿼리는 하나 이상의 MG\(메일 그룹\) RR을 반환할 수 있습니다.

- 이 조건은 사서함이 실제로 단일 사서함이 아니라 메일링 목록 또는 메일 그룹이었음을 의미합니다. 각 MG RR에는 그룹의 구성원인 사서함을 식별하는 RDATA 필드가 있습니다. 우편물은 각 회원에게 메시지 사본을 전달해야 합니다.

5. 쿼리는 MB RR과 하나 이상의 MG RR을 반환할 수 있습니다.

- 이 조건은 사서함이 실제로 메일링 리스트였음을 의미합니다. 메일러는 메시지를 MB RR이 지정한 호스트에 전달하여 모든 구성원에게 전달하거나, 메일러가 MG RR을 사용하여 확장 자체를 수행할 수 있습니다.

이러한 경우 응답에는 MINFO\(Mail Information\) RR이 포함될 수 있습니다. 이 RR은 일반적으로 메일 그룹과 연결되지만 MB에는 적합합니다. MINFO RR은 두 개의 사서함을 식별합니다. 이들 중 하나는 원래 사서함 이름에 대한 책임자를 식별합니다. 이 메일함은 메일 그룹 등에 추가되는 요청에 사용되어야 합니다. MINFO RR의 두 번째 메일함 이름은 메일 오류에 대한 오류 메시지를 수신해야 하는 메일함을 식별합니다. 이는 회원 이름의 오류가 목록에 메시지를 보내는 사람이 아닌 다른 사람에게 보고되어야 하는 경우 메일링 목록에 특히 적합합니다.

---
# **New fields may be added to this RR in the future.**
---
## **9. REFERENCES and BIBLIOGRAPHY**

```text
[Dyer 87]       S. Dyer, F. Hsu, "Hesiod", Project Athena
                Technical Plan - Name Service, April 1987, version 1.9.
```

- Hesiod 이름 서비스의 기본 사항을 설명합니다.

```text
[IEN-116]       J. Postel, "Internet Name Server", IEN-116,
                USC/Information Sciences Institute, August 1979.

                A name service obsoleted by the Domain Name System, but
                still in use.

[Quarterman 86] J. Quarterman, and J. Hoskins, "Notable Computer Networks",
                Communications of the ACM, October 1986, volume 29, number
                10.

[RFC-742]       K. Harrenstien, "NAME/FINGER", RFC-742, Network
                Information Center, SRI International, December 1977.

[RFC-768]       J. Postel, "User Datagram Protocol", RFC-768,
                USC/Information Sciences Institute, August 1980.

[RFC-793]       J. Postel, "Transmission Control Protocol", RFC-793,
                USC/Information Sciences Institute, September 1981.

[RFC-799]       D. Mills, "Internet Name Domains", RFC-799, COMSAT,
                September 1981.

                Suggests introduction of a hierarchy in place of a flat
                name space for the Internet.

[RFC-805]       J. Postel, "Computer Mail Meeting Notes", RFC-805,
                USC/Information Sciences Institute, February 1982.

[RFC-810]       E. Feinler, K. Harrenstien, Z. Su, and V. White, "DOD
                Internet Host Table Specification", RFC-810, Network
                Information Center, SRI International, March 1982.

                Obsolete.  See RFC-952.

[RFC-811]       K. Harrenstien, V. White, and E. Feinler, "Hostnames
                Server", RFC-811, Network Information Center, SRI
                International, March 1982.

                Obsolete.  See RFC-953.

[RFC-812]       K. Harrenstien, and V. White, "NICNAME/WHOIS", RFC-812,
                Network Information Center, SRI International, March
                1982.

[RFC-819]       Z. Su, and J. Postel, "The Domain Naming Convention for
                Internet User Applications", RFC-819, Network
                Information Center, SRI International, August 1982.

                Early thoughts on the design of the domain system.
                Current implementation is completely different.

[RFC-821]       J. Postel, "Simple Mail Transfer Protocol", RFC-821,
                USC/Information Sciences Institute, August 1980.

[RFC-830]       Z. Su, "A Distributed System for Internet Name Service",
                RFC-830, Network Information Center, SRI International,
                October 1982.

                Early thoughts on the design of the domain system.
                Current implementation is completely different.

[RFC-882]       P. Mockapetris, "Domain names - Concepts and
                Facilities," RFC-882, USC/Information Sciences
                Institute, November 1983.
```

- 이 메모로 대체됩니다.

```text
[RFC-883]       P. Mockapetris, "Domain names - Implementation and
                Specification," RFC-883, USC/Information Sciences
                Institute, November 1983.
```

- 이 메모로 대체됩니다.

```text
[RFC-920]       J. Postel and J. Reynolds, "Domain Requirements",
                RFC-920, USC/Information Sciences Institute,
                October 1984.
```

- 최상위 도메인의 명명 체계를 설명합니다.

```text
[RFC-952]       K. Harrenstien, M. Stahl, E. Feinler, "DoD Internet Host
                Table Specification", RFC-952, SRI, October 1985.

                Specifies the format of HOSTS.TXT, the host/address
                table replaced by the DNS.

[RFC-953]       K. Harrenstien, M. Stahl, E. Feinler, "HOSTNAME Server",
                RFC-953, SRI, October 1985.

                This RFC contains the official specification of the
                hostname server protocol, which is obsoleted by the DNS.
                This TCP based protocol accesses information stored in
                the RFC-952 format, and is used to obtain copies of the
                host table.

[RFC-973]       P. Mockapetris, "Domain System Changes and
                Observations", RFC-973, USC/Information Sciences
                Institute, January 1986.

                Describes changes to RFC-882 and RFC-883 and reasons for
                them.

[RFC-974]       C. Partridge, "Mail routing and the domain system",
                RFC-974, CSNET CIC BBN Labs, January 1986.

                Describes the transition from HOSTS.TXT based mail
                addressing to the more powerful MX system used with the
                domain system.

[RFC-1001]      NetBIOS Working Group, "Protocol standard for a NetBIOS
                service on a TCP/UDP transport: Concepts and Methods",
                RFC-1001, March 1987.

                This RFC and RFC-1002 are a preliminary design for
                NETBIOS on top of TCP/IP which proposes to base NetBIOS
                name service on top of the DNS.

[RFC-1002]      NetBIOS Working Group, "Protocol standard for a NetBIOS
                service on a TCP/UDP transport: Detailed
                Specifications", RFC-1002, March 1987.

[RFC-1010]      J. Reynolds, and J. Postel, "Assigned Numbers", RFC-1010,
                USC/Information Sciences Institute, May 1987.

                Contains socket numbers and mnemonics for host names,
                operating systems, etc.

[RFC-1031]      W. Lazear, "MILNET Name Domain Transition", RFC-1031,
                November 1987.
```

- MILNET을 DNS로 전환하기 위한 계획을 설명합니다.

```text
[RFC-1032]      M. Stahl, "Establishing a Domain - Guidelines for
                Administrators", RFC-1032, November 1987.

                Describes the registration policies used by the NIC to
                administer the top level domains and delegate subzones.

[RFC-1033]      M. Lottor, "Domain Administrators Operations Guide",
                RFC-1033, November 1987.
```

- 도메인 관리자를 위한 요리책입니다.

```text
[Solomon 82]    M. Solomon, L. Landweber, and D. Neuhengen, "The CSNET
                Name Server", Computer Networks, vol 6, nr 3, July 1982.

                Describes a name service for CSNET which is independent
                from the DNS and DNS use in the CSNET.
```

---
# **Index**

```text
          *   13

          ;   33, 35

          <character-string>   35
          <domain-name>   34

          @   35

          \   35

          A   12

          Byte order   8

          CH   13
          Character case   9
          CLASS   11
          CNAME   12
          Completion   42
          CS   13

          Hesiod   13
          HINFO   12
          HS   13

          IN   13
          IN-ADDR.ARPA domain   22
          Inverse queries   40

          Mailbox names   47
          MB   12
          MD   12
          MF   12
          MG   12
          MINFO   12
          MINIMUM   20
          MR   12
          MX   12

          NS   12
          NULL   12

          Port numbers   32
          Primary server   5
          PTR   12, 18

          QCLASS   13
          QTYPE   12

          RDATA   12
          RDLENGTH  11

          Secondary server   5
          SOA   12
          Stub resolvers   7

          TCP   32
          TXT   12
          TYPE   11

          UDP   32

          WKS   12
```
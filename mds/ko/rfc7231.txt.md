

```text
Internet Engineering Task Force (IETF)                  R. Fielding, Ed.
Request for Comments: 7231                                         Adobe
Obsoletes: 2616                                          J. Reschke, Ed.
Updates: 2817                                                 greenbytes
Category: Standards Track                                      June 2014
ISSN: 2070-1721

     Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content
```

---
# **Abstract**

HTTP\(Hypertext Transfer Protocol\)는 분산, 협업, 하이퍼텍스트 정보 시스템을 위한 상태 비저장 애플리케이션 수준 프로토콜입니다. 이 문서는 메시지 페이로드\(메타데이터 및 본문 콘텐츠\) 및 콘텐츠 협상 메커니즘과 함께 요청 메서드, 요청 헤더 필드, 응답 상태 코드 및 응답 헤더 필드로 표현되는 HTTP/1.1 메시지의 의미를 정의합니다.

---
# **Status of This Memo**

이것은 인터넷 표준 추적 문서입니다.

이 문서는 IETF\(Internet Engineering Task Force\)의 제품입니다. 이는 IETF 커뮤니티의 합의를 나타냅니다. 공개 검토를 받았으며 IESG\(Internet Engineering Steering Group\)의 출판 승인을 받았습니다. 인터넷 표준에 대한 자세한 내용은 RFC 5741의 섹션 2에서 확인할 수 있습니다.

이 문서의 현재 상태, 정오표, 피드백 제공 방법에 대한 정보는 http://www.rfc-editor.org/info/rfc7231에서 얻을 수 있습니다.

---
# **Copyright Notice**

Copyright \(c\) 2014 IETF Trust 및 문서 작성자로 식별된 사람. 판권 소유.

이 문서는 이 문서의 발행일에 유효한 BCP 78 및 IETF 문서에 관한 IETF 트러스트의 법적 조항\(http://trustee.ietf.org/license-info\)의 적용을 받습니다. 이 문서와 관련된 귀하의 권리 및 제한 사항을 설명하므로 이 문서를 주의 깊게 검토하십시오. 이 문서에서 추출한 코드 구성 요소는 Trust Legal Provisions의 섹션 4.e에 설명된 대로 Simplified BSD License 텍스트를 포함해야 하며 Simplified BSD License에 설명된 대로 보증 없이 제공됩니다.

이 문서에는 2008년 11월 10일 이전에 공개되거나 공개된 IETF 문서 또는 IETF 기고문의 자료가 포함될 수 있습니다. 이 자료의 일부에 대한 저작권을 제어하는 ​​사람은 해당 자료의 수정을 허용할 권리를 IETF 트러스트에 부여하지 않았을 수 있습니다. IETF 표준 프로세스 외부. 이러한 자료의 저작권을 관리하는 사람으로부터 적절한 라이센스를 얻지 않고 이 문서는 IETF 표준 프로세스 외부에서 수정할 수 없으며 IETF 표준 프로세스 외부에서 이 문서의 파생물을 생성할 수 없습니다. RFC로 게시하거나 영어 이외의 언어로 번역합니다.

---
# **Table of Contents**

```text
   1. Introduction ....................................................6
      1.1. Conformance and Error Handling .............................6
      1.2. Syntax Notation ............................................6
   2. Resources .......................................................7
   3. Representations .................................................7
      3.1. Representation Metadata ....................................8
           3.1.1. Processing Representation Data ......................8
           3.1.2. Encoding for Compression or Integrity ..............11
           3.1.3. Audience Language ..................................13
           3.1.4. Identification .....................................14
      3.2. Representation Data .......................................17
      3.3. Payload Semantics .........................................17
      3.4. Content Negotiation .......................................18
           3.4.1. Proactive Negotiation ..............................19
           3.4.2. Reactive Negotiation ...............................20
   4. Request Methods ................................................21
      4.1. Overview ..................................................21
      4.2. Common Method Properties ..................................22
           4.2.1. Safe Methods .......................................22
           4.2.2. Idempotent Methods .................................23
           4.2.3. Cacheable Methods ..................................24
      4.3. Method Definitions ........................................24
           4.3.1. GET ................................................24
           4.3.2. HEAD ...............................................25
           4.3.3. POST ...............................................25
           4.3.4. PUT ................................................26
           4.3.5. DELETE .............................................29
           4.3.6. CONNECT ............................................30
           4.3.7. OPTIONS ............................................31
           4.3.8. TRACE ..............................................32
   5. Request Header Fields ..........................................33
      5.1. Controls ..................................................33
           5.1.1. Expect .............................................34
           5.1.2. Max-Forwards .......................................36
      5.2. Conditionals ..............................................36
      5.3. Content Negotiation .......................................37
           5.3.1. Quality Values .....................................37
           5.3.2. Accept .............................................38
           5.3.3. Accept-Charset .....................................40
           5.3.4. Accept-Encoding ....................................41
           5.3.5. Accept-Language ....................................42
      5.4. Authentication Credentials ................................44
      5.5. Request Context ...........................................44
           5.5.1. From ...............................................44
           5.5.2. Referer ............................................45
           5.5.3. User-Agent .........................................46
   6. Response Status Codes ..........................................47
      6.1. Overview of Status Codes ..................................48
      6.2. Informational 1xx .........................................50
           6.2.1. 100 Continue .......................................50
           6.2.2. 101 Switching Protocols ............................50
      6.3. Successful 2xx ............................................51
           6.3.1. 200 OK .............................................51
           6.3.2. 201 Created ........................................52
           6.3.3. 202 Accepted .......................................52
           6.3.4. 203 Non-Authoritative Information ..................52
           6.3.5. 204 No Content .....................................53
           6.3.6. 205 Reset Content ..................................53
      6.4. Redirection 3xx ...........................................54
           6.4.1. 300 Multiple Choices ...............................55
           6.4.2. 301 Moved Permanently ..............................56
           6.4.3. 302 Found ..........................................56
           6.4.4. 303 See Other ......................................57
           6.4.5. 305 Use Proxy ......................................58
           6.4.6. 306 (Unused) .......................................58
           6.4.7. 307 Temporary Redirect .............................58
      6.5. Client Error 4xx ..........................................58
           6.5.1. 400 Bad Request ....................................58
           6.5.2. 402 Payment Required ...............................59
           6.5.3. 403 Forbidden ......................................59
           6.5.4. 404 Not Found ......................................59
           6.5.5. 405 Method Not Allowed .............................59
           6.5.6. 406 Not Acceptable .................................60
           6.5.7. 408 Request Timeout ................................60
           6.5.8. 409 Conflict .......................................60
           6.5.9. 410 Gone ...........................................60
           6.5.10. 411 Length Required ...............................61
           6.5.11. 413 Payload Too Large .............................61
           6.5.12. 414 URI Too Long ..................................61
           6.5.13. 415 Unsupported Media Type ........................62
           6.5.14. 417 Expectation Failed ............................62
           6.5.15. 426 Upgrade Required ..............................62
      6.6. Server Error 5xx ..........................................62
           6.6.1. 500 Internal Server Error ..........................63
           6.6.2. 501 Not Implemented ................................63
           6.6.3. 502 Bad Gateway ....................................63
           6.6.4. 503 Service Unavailable ............................63
           6.6.5. 504 Gateway Timeout ................................63
           6.6.6. 505 HTTP Version Not Supported .....................64
   7. Response Header Fields .........................................64
      7.1. Control Data ..............................................64
ed            7.1.1. Origination Date ...................................65
           7.1.2. Location ...........................................68
           7.1.3. Retry-After ........................................69
           7.1.4. Vary ...............................................70
      7.2. Validator Header Fields ...................................71
      7.3. Authentication Challenges .................................72
      7.4. Response Context ..........................................72
           7.4.1. Allow ..............................................72
           7.4.2. Server .............................................73
   8. IANA Considerations ............................................73
      8.1. Method Registry ...........................................73
           8.1.1. Procedure ..........................................74
           8.1.2. Considerations for New Methods .....................74
           8.1.3. Registrations ......................................75
      8.2. Status Code Registry ......................................75
           8.2.1. Procedure ..........................................75
           8.2.2. Considerations for New Status Codes ................76
           8.2.3. Registrations ......................................76
      8.3. Header Field Registry .....................................77
           8.3.1. Considerations for New Header Fields ...............78
           8.3.2. Registrations ......................................80
      8.4. Content Coding Registry ...................................81
           8.4.1. Procedure ..........................................81
           8.4.2. Registrations ......................................81
   9. Security Considerations ........................................81
      9.1. Attacks Based on File and Path Names ......................82
      9.2. Attacks Based on Command, Code, or Query Injection ........82
      9.3. Disclosure of Personal Information ........................83
      9.4. Disclosure of Sensitive Information in URIs ...............83
      9.5. Disclosure of Fragment after Redirects ....................84
      9.6. Disclosure of Product Information .........................84
      9.7. Browser Fingerprinting ....................................84
   10. Acknowledgments ...............................................85
   11. References ....................................................85
      11.1. Normative References .....................................85
      11.2. Informative References ...................................86
   Appendix A. Differences between HTTP and MIME .....................89
      A.1. MIME-Version ..............................................89
      A.2. Conversion to Canonical Form ..............................89
      A.3. Conversion of Date Formats ................................90
      A.4. Conversion of Content-Encoding ............................90
      A.5. Conversion of Content-Transfer-Encoding ...................90
      A.6. MHTML and Line Length Limitations .........................90
   Appendix B. Changes from RFC 2616 .................................91
   Appendix C. Imported ABNF .........................................93
   Appendix D. Collected ABNF ........................................94
   Index .............................................................97
```

---
## **1.  Introduction**

각 HTTP\(Hypertext Transfer Protocol\) 메시지는 요청이거나 응답입니다. 서버는 요청에 대한 연결을 수신하고, 수신된 각 메시지를 구문 분석하고, 식별된 요청 대상과 관련된 메시지 의미를 해석하고, 하나 이상의 응답 메시지로 해당 요청에 응답합니다. 클라이언트는 특정 의도를 전달하기 위해 요청 메시지를 구성하고, 수신된 응답을 검사하여 의도가 수행되었는지 확인하고, 결과를 해석하는 방법을 결정합니다. 이 문서는 \[RFC7230\]에 정의된 아키텍처 측면에서 HTTP/1.1 요청 및 응답 의미를 정의합니다.

HTTP는 표현의 조작 및 전송\(섹션 3\)을 통해 리소스 유형, 성격 또는 구현에 관계없이 리소스\(섹션 2\)와 상호 작용하기 위한 통일된 인터페이스를 제공합니다.

HTTP 의미론에는 각 요청 방법에 의해 정의된 의도\(섹션 4\), 요청 헤더 필드에 설명될 수 있는 의미론에 대한 확장\(섹션 5\), 기계가 읽을 수 있는 응답을 나타내는 상태 코드의 의미\(섹션 6\)가 포함됩니다. 응답 헤더 필드에 제공될 수 있는 기타 제어 데이터 및 리소스 메타데이터의 의미\(섹션 7\)

또한 이 문서는 수신자가 페이로드를 해석하는 방법, 콘텐츠 선택에 영향을 줄 수 있는 요청 헤더 필드, 집합적으로 "콘텐츠 협상"이라고 하는 다양한 선택 알고리즘을 설명하는 표현 메타데이터를 정의합니다\(섹션 3.4\).

---
### **1.1.  Conformance and Error Handling**

이 문서에서 키워드 "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY" 및 "OPTIONAL"은 다음과 같습니다. \[RFC2119\]에 설명된 대로 해석됩니다.\(MUST NOT\)

오류 처리에 관한 적합성 기준 및 고려 사항은 \[RFC7230\]의 섹션 2.5에 정의되어 있습니다.

---
### **1.2.  Syntax Notation**

이 사양은 \[RFC7230\]의 섹션 7에 정의된 목록 확장과 함께 \[RFC5234\]의 ABNF\(Augmented Backus-Naur Form\) 표기법을 사용합니다. 이는 '#' 연산자를 사용하여 쉼표로 구분된 목록의 간결한 정의를 허용합니다\( '\*' 연산자가 반복을 나타내는 방법\) 부록 C에서는 다른 문서에서 가져온 규칙을 설명합니다. 부록 D는 표준 ABNF 표기법으로 확장된 모든 목록 연산자와 함께 수집된 문법을 보여줍니다.

이 사양에서는 \[RFC6365\]에 정의된 대로 "문자", "문자 인코딩 체계", "문자 집합" 및 "프로토콜 요소"라는 용어를 사용합니다.

---
## **2.  Resources**

HTTP 요청의 대상을 "리소스"라고 합니다. HTTP는 리소스의 성격을 제한하지 않습니다. 단지 리소스와 상호 작용하는 데 사용할 수 있는 인터페이스를 정의할 뿐입니다. 각 리소스는 \[RFC7230\]의 섹션 2.7에 설명된 대로 URI\(Uniform Resource Identifier\)로 식별됩니다.

클라이언트는 HTTP/1.1 요청 메시지를 구성할 때 \(\[RFC7230\]의 섹션 5.3\)에 정의된 대로 다양한 형식 중 하나로 대상 URI를 보냅니다. 요청이 수신되면 서버는 대상 리소스에 대한 유효한 요청 URI를 재구성합니다\(\[RFC7230\]의 섹션 5.5\).

HTTP의 한 가지 설계 목표는 요청 의미론에서 리소스 식별을 분리하는 것입니다. 이는 요청 메서드\(섹션 4\)와 몇 가지 요청 수정 헤더 필드\(섹션 5\)에 요청 의미론을 부여함으로써 가능해집니다. 4.2.1절에 설명된 대로 메서드 의미론과 URI 자체에 내포된 의미론 사이에 충돌이 있는 경우 메서드 의미론이 우선합니다.

---
## **3.  Representations**

리소스는 무엇이든 될 수 있고 HTTP가 제공하는 균일한 인터페이스는 상대방의 독립적인 행위자에게 메시지를 전달함으로써만 그러한 것을 관찰하고 조치를 취할 수 있는 창과 유사하다는 점을 고려하면 추상화는 다음과 같습니다. 우리의 의사소통에서 그 사물의 현재 또는 원하는 상태를 표현\("대신"\)하는 데 필요합니다. 이러한 추상화를 표현 \[REST\]이라고 합니다.

HTTP의 목적에 따라 "표현"은 주어진 자원의 과거, 현재 또는 원하는 상태를 프로토콜을 통해 쉽게 전달할 수 있는 형식으로 반영하기 위한 정보이며 표현 세트로 구성됩니다. 메타데이터 및 잠재적으로 제한되지 않은 표현 데이터 스트림.

원서버는 각각 대상 리소스의 현재 상태를 반영하도록 의도된 여러 표현을 제공하거나 생성할 수 있습니다. 이러한 경우 원본 서버는 일반적으로 콘텐츠 협상을 기반으로 특정 요청에 가장 적합한 표현 중 하나를 선택하기 위해 일부 알고리즘을 사용합니다. 이 "선택된 표현"은 다음을 제공하는 데 사용됩니다.

조건부 요청 \[RFC7232\]을 평가하고 GET에 대한 200\(OK\) 및 304\(수정되지 않음\) 응답에 대한 페이로드를 구성하기 위한 데이터 및 메타데이터\(섹션 4.3.1\).

---
### **3.1.  Representation Metadata**

표현 헤더 필드는 표현에 대한 메타데이터를 제공합니다. 메시지에 페이로드 본문이 포함된 경우 표현 헤더 필드는 페이로드 본문에 포함된 표현 데이터를 해석하는 방법을 설명합니다. HEAD 요청에 대한 응답에서 표현 헤더 필드는 동일한 요청이 GET인 경우 페이로드 본문에 포함되었을 표현 데이터를 설명합니다.

다음 헤더 필드는 표현 메타데이터를 전달합니다.

```text
   +-------------------+-----------------+
   | Header Field Name | Defined in...   |
   +-------------------+-----------------+
   | Content-Type      | Section 3.1.1.5 |
   | Content-Encoding  | Section 3.1.2.2 |
   | Content-Language  | Section 3.1.3.2 |
   | Content-Location  | Section 3.1.4.2 |
   +-------------------+-----------------+
```

---
#### **3.1.1.  Processing Representation Data**
---
##### **3.1.1.1.  Media Type**

HTTP는 개방적이고 확장 가능한 데이터 유형 지정 및 유형 협상을 제공하기 위해 Content-Type\(섹션 3.1.1.5\) 및 Accept\(섹션 5.3.2\) 헤더 필드에서 인터넷 미디어 유형 \[RFC2046\]을 사용합니다. 미디어 유형은 데이터 형식과 다양한 처리 모델, 즉 데이터가 수신되는 각 컨텍스트에 따라 해당 데이터를 처리하는 방법을 모두 정의합니다.

```text
     media-type = type "/" subtype *( OWS ";" OWS parameter )
     type       = token
     subtype    = token
```

유형/하위 유형 뒤에는 이름=값 쌍 형식의 매개변수가 올 수 있습니다.\(MAY\)

```text
     parameter      = token "=" ( token / quoted-string )
```

유형, 하위 유형 및 매개변수 이름 토큰은 대소문자를 구분하지 않습니다. 매개변수 값은 매개변수 이름의 의미에 따라 대소문자를 구분할 수도 있고 그렇지 않을 수도 있습니다. 매개변수의 유무는 미디어 유형 레지스트리 내의 정의에 따라 미디어 유형 처리에 중요할 수 있습니다.

토큰 생성과 일치하는 매개변수 값은 토큰으로 또는 인용 문자열 내에서 전송될 수 있습니다. 인용된 값과 인용되지 않은 값은 동일합니다. 예를 들어 다음 예는 모두 동일하지만 일관성을 위해 첫 번째 예가 선호됩니다.

```text
     text/html;charset=utf-8
     text/html;charset=UTF-8
     Text/HTML;Charset="utf-8"
     text/html; charset="utf-8"
```

인터넷 미디어 유형은 \[BCP13\]에 정의된 절차에 따라 IANA에 등록되어야 합니다.

- 참고: 다른 헤더 필드의 일부 유사한 구성과 달리 미디어 유형 매개변수는 "=" 문자 주위에 공백\("잘못된" 공백도 포함\)을 허용하지 않습니다.

---
##### **3.1.1.2.  Charset**

HTTP는 문자 집합 이름을 사용하여 텍스트 표현의 문자 인코딩 체계를 나타내거나 협상합니다\[RFC6365\]. 문자 세트는 대소문자를 구분하지 않는 토큰으로 식별됩니다.

```text
     charset = token
```

문자 집합 이름은 \[RFC2978\]에 정의된 절차에 따라 IANA "문자 집합" 레지스트리\(<http://www.iana.org/locationments/character-sets\>\)에 등록되어야 합니다.

---
##### **3.1.1.3.  Canonicalization and Text Defaults**

인터넷 미디어 유형은 다양한 기본 인코딩 형식을 사용하는 시스템 간에 상호 운용이 가능하도록 표준 형식으로 등록됩니다. HTTP를 통해 선택되거나 전송된 표현은 다목적 인터넷 메일 확장\(MIME\) \[RFC2045\]에 설명된 것과 동일한 이유로 표준 형식이어야 합니다. 그러나 이메일 배포의 성능 특성\(예: 메시지 저장 및 피어에게 메시지 전달\)은 HTTP 및 웹\(서버 기반 정보 서비스\)의 일반적인 성능 특성과 크게 다릅니다. 또한 이전 메일 전송 프로토콜과의 호환성을 위한 MIME 제약 조건은 HTTP에 적용되지 않습니다\(부록 A 참조\).

MIME의 표준 형식에서는 "텍스트" 유형의 미디어 하위 유형이 CRLF를 텍스트 줄 바꿈으로 사용해야 합니다. HTTP는 줄 바꿈이 전체 표현에 대해 일관되는 ​​경우 줄 바꿈을 나타내는 일반 CR 또는 LF만으로 텍스트 미디어의 전송을 허용합니다. HTTP 발신자는 CRLF, 베어 CR 또는 베어 LF로 구성된 텍스트 미디어에서 줄 바꿈을 생성할 수 있고 수신자는 구문 분석할 수 있어야 합니다. 또한 HTTP의 텍스트 미디어는 각각 CR 및 LF에 옥텟 13 및 10을 사용하는 문자 집합으로 제한되지 않습니다. 줄 바꿈에 대한 이러한 유연성은 "텍스트" 미디어 유형이 할당된 표현 내의 텍스트에만 적용됩니다. 페이로드 본문 외부의 "다중 부분" 유형이나 HTTP 요소\(예: 헤더 필드\)에는 적용되지 않습니다.\(MUST\)

표현이 콘텐츠 코딩으로 인코딩된 경우 기본 데이터는 인코딩되기 전에 위에 정의된 형식이어야 합니다.

---
##### **3.1.1.4.  Multipart Types**

MIME은 단일 메시지 본문 내에서 하나 이상의 표현을 캡슐화하는 다양한 "다중 부분" 유형을 제공합니다. 모든 멀티파트 유형은 \[RFC2046\]의 섹션 5.1.1에 정의된 대로 공통 구문을 공유하며 미디어 유형 값의 일부로 경계 매개변수를 포함합니다. 메시지 본문 자체는 프로토콜 요소입니다. 발신자는 본문 부분 사이의 줄 바꿈을 나타내기 위해 CRLF만 생성해야 합니다.\(MUST\)

HTTP 메시지 프레이밍은 멀티파트 경계를 메시지 본문 길이의 표시기로 사용하지 않지만 페이로드를 생성하거나 처리하는 구현에서는 사용할 수 있습니다. 예를 들어, "multipart/form-data" 유형은 \[RFC2388\]에 설명된 대로 요청에서 양식 데이터를 전달하는 데 자주 사용되며, "multipart/byteranges" 유형은 일부 206\(부분 부분\)에서 사용하기 위해 이 사양에 의해 정의됩니다. 내용\) 응답 \[RFC7233\].

---
##### **3.1.1.5.  Content-Type**

"Content-Type" 헤더 필드는 연관된 표현의 미디어 유형\(메시지 페이로드에 포함된 표현 또는 메시지 의미론에 따라 결정된 선택된 표현\)을 나타냅니다. 표시된 미디어 유형은 Content-Encoding으로 표시된 콘텐츠 코딩이 디코딩된 후 수신된 메시지 의미의 범위 내에서 데이터 형식과 수신자가 해당 데이터를 처리하는 방법을 모두 정의합니다.

```text
     Content-Type = media-type
```

미디어 유형은 섹션 3.1.1.1에 정의되어 있습니다. 해당 분야의 예는 다음과 같습니다.

```text
     Content-Type: text/html; charset=ISO-8859-4
```

페이로드 본문이 포함된 메시지를 생성하는 발신자는 포함된 표현의 의도된 미디어 유형을 발신자가 알 수 없는 경우를 제외하고 해당 메시지에 Content-Type 헤더 필드를 생성해야 합니다. Content-Type 헤더 필드가 없으면 수신자는 "application/octet-stream"\(\[RFC2046\], 섹션 4.5.1\)의 미디어 유형을 가정하거나 데이터를 검사하여 해당 유형을 결정할 수 있습니다.\(SHOULD, MAY\)

실제로 리소스 소유자는 주어진 표현에 대해 올바른 Content-Type을 제공하기 위해 원본 서버를 항상 적절하게 구성하지 않으며, 그 결과 일부 클라이언트는 페이로드의 콘텐츠를 검사하고 지정된 유형을 재정의합니다. 그렇게 하는 클라이언트는 잘못된 결론을 도출할 위험이 있으며, 이로 인해 추가 보안 위험\(예: "권한 상승"\)이 노출될 수 있습니다. 더욱이 데이터 형식을 검사하여 보낸 사람의 의도를 파악하는 것은 불가능합니다. 많은 데이터 형식은 처리 의미만 다른 여러 미디어 유형과 일치합니다. 구현자는 이러한 "콘텐츠 스니핑"을 사용할 때 비활성화하는 수단을 제공하는 것이 좋습니다.

---
#### **3.1.2.  Encoding for Compression or Integrity**
---
##### **3.1.2.1.  Content Codings**

콘텐츠 코딩 값은 표현에 적용되었거나 적용될 수 있는 인코딩 변환을 나타냅니다. 콘텐츠 코딩은 주로 기본 미디어 유형의 정체성을 잃지 않고 정보 손실 없이 표현을 압축하거나 유용하게 변환할 수 있도록 하는 데 사용됩니다. 흔히 표현은 코드화된 형태로 저장되고, 직접 전송되며, 최종 수신자에 의해서만 디코딩됩니다.

```text
     content-coding   = token
```

모든 콘텐츠 코딩 값은 대소문자를 구분하지 않으며 섹션 8.4에 정의된 대로 "HTTP 콘텐츠 코딩 레지스트리" 내에 등록되어야 합니다. 이는 Accept-Encoding\(섹션 5.3.4\) 및 Content-Encoding\(섹션 3.1.2.2\) 헤더 필드에 사용됩니다.

이 사양에서는 다음 콘텐츠 코딩 값을 정의합니다.

- 압축\(및 x-압축\): \[RFC7230\]의 섹션 4.2.1을 참조하세요.

- 수축: \[RFC7230\]의 섹션 4.2.2를 참조하세요.

- gzip\(및 x-gzip\): \[RFC7230\]의 섹션 4.2.3을 참조하세요.

---
##### **3.1.2.2.  Content-Encoding**

"Content-Encoding" 헤더 필드는 미디어 유형에 내재된 코딩을 넘어 어떤 콘텐츠 코딩이 표현에 적용되었는지, 따라서 Content-Encoding에서 참조하는 미디어 유형의 데이터를 얻기 위해 어떤 디코딩 메커니즘을 적용해야 하는지를 나타냅니다. 헤더 필드를 입력하세요. Content-Encoding은 기본 미디어 유형의 ID를 잃지 않고 표현의 데이터를 압축할 수 있도록 하는 데 주로 사용됩니다.

```text
     Content-Encoding = 1#content-coding
```

그 사용 예는 다음과 같습니다.

```text
     Content-Encoding: gzip
```

하나 이상의 인코딩이 표현에 적용된 경우 인코딩을 적용한 발신자는 적용된 순서대로 콘텐츠 코딩을 나열하는 Content-Encoding 헤더 필드를 생성해야 합니다. 인코딩 매개변수에 대한 추가 정보는 이 사양에 정의되지 않은 다른 헤더 필드에서 제공될 수 있습니다.\(MUST\)

Transfer-Encoding\(\[RFC7230\]의 섹션 3.3.1\)과 달리 Content-Encoding에 나열된 코딩은 표현의 특징입니다. 표현은 코드화된 형식의 관점에서 정의되며, 표현에 관한 다른 모든 메타데이터는 메타데이터 정의에서 달리 명시하지 않는 한 코드화된 형식에 관한 것입니다. 일반적으로 표현은 렌더링 또는 유사한 사용 직전에만 디코딩됩니다.

미디어 유형에 항상 압축되는 데이터 형식과 같은 고유 인코딩이 포함된 경우 해당 인코딩은 콘텐츠 코딩 중 하나와 동일한 알고리즘이더라도 Content-Encoding에서 다시 지정되지 않습니다. 이러한 콘텐츠 코딩은 어떤 이상한 이유로 표현을 형성하기 위해 두 번째로 적용되는 경우에만 나열됩니다. 마찬가지로 원본 서버는 코딩이 Content-Type의 일부로 정의되었는지 여부만 다른 여러 표현으로 동일한 데이터를 게시하도록 선택할 수 있습니다.

또는 콘텐츠 인코딩. 일부 사용자 에이전트는 각 응답을 처리할 때 다르게 동작하기 때문입니다\(예: 자동 압축 풀기 및 콘텐츠 렌더링 대신 "다른 이름으로 저장..." 대화 상자 열기\).

요청 메시지의 표현에 허용되지 않는 콘텐츠 코딩이 있는 경우 원서버는 상태 코드 415\(지원되지 않는 미디어 유형\)로 응답할 수 있습니다.\(MAY\)

---
#### **3.1.3.  Audience Language**
---
##### **3.1.3.1.  Language Tags**

\[RFC5646\]에 정의된 언어 태그는 다른 인간에게 정보를 전달하기 위해 인간이 말하거나 쓰거나 전달하는 자연어를 식별합니다. 컴퓨터 언어는 명시적으로 제외됩니다.

HTTP는 Accept-Language 및 Content-Language 헤더 필드 내의 언어 태그를 사용합니다. Accept-Language는 섹션 5.3.5에 정의된 보다 광범위한 언어 범위 생성을 사용하는 반면, Content-Language는 아래에 정의된 언어 태그 생성을 사용합니다.

```text
     language-tag = <Language-Tag, see [RFC5646], Section 2.1>
```

언어 태그는 대소문자를 구분하지 않는 하나 이상의 하위 태그 시퀀스이며 각 하위 태그는 하이픈 문자\("-", %x2D\)로 구분됩니다. 대부분의 경우 언어 태그는 광범위한 관련 언어군을 식별하는 기본 언어 하위 태그\(예: "en" = 영어\)로 구성되며, 선택적으로 해당 언어의 범위를 구체화하거나 좁히는 일련의 하위 태그가 뒤따릅니다\(예: "en-CA" = 캐나다에서 사용되는 다양한 영어\). 언어 태그 내에는 공백이 허용되지 않습니다. 예제 태그는 다음과 같습니다.

```text
     fr, en-US, es-419, az-Arab, x-pig-latin, man-Nkoo-GN
```

자세한 내용은 \[RFC5646\]을 참조하세요.

---
##### **3.1.3.2.  Content-Language**

"Content-Language" 헤더 필드는 표현을 위해 의도된 청중의 자연 언어를 설명합니다. 이는 표현 내에서 사용되는 모든 언어와 동일하지 않을 수도 있습니다.

```text
     Content-Language = 1#language-tag
```

언어 태그는 섹션 3.1.3.1에 정의되어 있습니다. Content-Language의 주요 목적은 사용자가 자신이 선호하는 언어에 따라 표현을 식별하고 차별화할 수 있도록 하는 것입니다. 따라서 콘텐츠가 덴마크어를 읽을 수 있는 청중만을 대상으로 하는 경우 해당 필드는 다음과 같습니다.

```text
     Content-Language: da
```

Content-Language가 지정되지 않은 경우 기본값은 콘텐츠가 모든 언어 사용자를 대상으로 하는 것입니다. 이는 보낸 사람이 해당 내용을 자연어에만 적용되는 것으로 간주하지 않거나 해당 내용이 어떤 언어에 해당하는지 알 수 없음을 의미할 수 있습니다.

여러 청중을 대상으로 하는 콘텐츠의 경우 여러 언어가 나열될 수 있습니다. 예를 들어, 원본 마오리어와 영어 버전으로 동시에 제시된 "와이탕이 조약"의 번역은 다음을 요구합니다.\(MAY\)

```text
     Content-Language: mi, en
```

그러나 표현 내에 여러 언어가 존재한다고 해서 그것이 여러 언어를 사용하는 청중을 대상으로 한다는 의미는 아닙니다. 예를 들어 "라틴어 첫 수업"과 같은 초보자용 언어 입문서는 분명히 영어를 읽을 수 있는 청중이 사용하도록 의도된 것입니다. 이 경우 Content-Language에는 "en"만 포함됩니다.

Content-Language는 모든 미디어 유형에 적용될 수 있으며 텍스트 문서에만 국한되지 않습니다.\(MAY\)

---
#### **3.1.4.  Identification**
---
##### **3.1.4.1.  Identifying a Representation**

전체 또는 부분 표현이 메시지 페이로드로 전송되는 경우 발신자가 해당 표현에 해당하는 리소스에 대한 식별자를 제공하거나 수신자가 결정하는 것이 종종 바람직합니다.

요청 메시지의 경우:

o 요청에 Content-Location 헤더 필드가 있는 경우 보낸 사람은 페이로드가 Content-Location 필드 값으로 식별되는 리소스의 표현임을 주장합니다. 그러나 그러한 주장은 다른 수단\(이 사양에서 정의되지 않음\)으로 확인할 수 없으면 신뢰할 수 없습니다. 이 정보는 개정 내역 링크에 여전히 유용할 수 있습니다.

o 그렇지 않으면 페이로드가 식별되지 않습니다.

응답 메시지의 경우 일치하는 항목이 발견될 때까지 다음 규칙이 순서대로 적용됩니다.

1. 요청 메소드가 GET 또는 HEAD이고 응답 상태 코드가 200\(OK\), 204\(No Content\), 206\(Partial Content\) 또는 304\(Not Modified\)인 경우 페이로드는 다음으로 식별되는 리소스의 표현입니다. 유효한 요청 URI\(\[RFC7230\]의 섹션 5.5\)

2. 요청 방법이 GET 또는 HEAD이고 응답 상태 코드가 203\(비인증 정보\)인 경우 페이로드는 중개자가 제공하는 대상 리소스의 잠재적으로 수정되거나 향상된 표현입니다.

3. 응답에 Content-Location 헤더 필드가 있고 해당 필드 값이 유효 요청 URI와 동일한 URI에 대한 참조인 경우 페이로드는 유효 요청 URI로 식별되는 리소스의 표현입니다.

4. 응답에 Content-Location 헤더 필드가 있고 해당 필드 값이 유효한 요청 URI와 다른 URI에 대한 참조인 경우 보낸 사람은 페이로드가 Content-Location 필드에 의해 식별된 리소스의 표현이라고 주장합니다. -값. 그러나 그러한 주장은 다른 수단\(이 사양에서 정의되지 않음\)으로 확인할 수 없으면 신뢰할 수 없습니다.

5. 그렇지 않으면 페이로드가 식별되지 않습니다.

---
##### **3.1.4.2.  Content-Location**

"Content-Location" 헤더 필드는 이 메시지 페이로드의 표현에 해당하는 특정 리소스에 대한 식별자로 사용할 수 있는 URI를 참조합니다. 즉, 이 메시지 생성 시 이 URI에 대해 GET 요청을 수행하는 경우 200\(OK\) 응답에는 이 메시지에 페이로드로 포함된 동일한 표현이 포함됩니다.

```text
     Content-Location = absolute-URI / partial-URI
```

Content-Location 값은 유효한 요청 URI\(\[RFC7230\]의 섹션 5.5\)를 대체하지 않습니다. 표현 메타데이터입니다. 이는 \[RFC2557\]의 섹션 4에서 MIME 본문 부분에 대해 정의된 동일한 이름의 헤더 필드와 동일한 구문 및 의미를 갖습니다. 그러나 HTTP 메시지에 표시되는 내용은 HTTP 수신자에게 몇 가지 특별한 의미를 갖습니다.

Content-Location이 2xx\(성공\) 응답 메시지에 포함되어 있고 해당 값이 \(절대 형식으로 변환된 후\) 유효 요청 URI와 동일한 URI를 참조하는 경우 수신자는 페이로드를 현재 표현으로 간주할 수 있습니다. 메시지 발생 날짜로 표시된 시간에 해당 리소스의 GET\(섹션 4.3.1\) 또는 HEAD\(섹션 4.3.2\) 요청의 경우 이는 서버에서 Content-Location을 제공하지 않을 때의 기본 의미 체계와 동일합니다. PUT\(섹션 4.3.4\) 또는 POST\(섹션 4.3.3\)와 같은 상태 변경 요청의 경우 서버의 응답에 해당 리소스의 새로운 표현이 포함되어 있음을 의미하므로 작업에 대해서만 보고할 수 있는 표현과 구별됩니다\( 예를 들어 "효과가 있었습니다!"\). 이를 통해 저작 애플리케이션은 후속 GET 요청 없이도 로컬 복사본을 업데이트할 수 있습니다.\(MAY\)

Content-Location이 2xx\(Successful\) 응답 메시지에 포함되어 있고 해당 field-value가 유효한 요청 URI와 다른 URI를 참조하는 경우 원서버는 해당 URI가 포함된 메시지에 해당하는 다른 리소스에 대한 식별자라고 주장합니다. 대표. 이러한 클레임은 두 식별자가 동일한 리소스 소유자를 공유하는 경우에만 신뢰할 수 있으며, 이는 HTTP를 통해 프로그래밍 방식으로 확인할 수 없습니다.

o GET 또는 HEAD 요청에 대한 응답의 경우 이는 유효 요청 URI가 콘텐츠 협상 대상인 리소스를 참조하고 Content-Location 필드 값이 선택한 표현에 대한 보다 구체적인 식별자임을 나타냅니다.

o 상태 변경 방법에 대한 201\(생성됨\) 응답의 경우, Location 필드 값과 동일한 Content-Location 필드 값은 이 페이로드가 새로 생성된 리소스의 현재 표현임을 나타냅니다.

o 그렇지 않은 경우 이러한 Content-Location은 이 페이로드가 요청된 작업의 상태를 보고하는 표현이고 동일한 보고서가 지정된 URI에서 \(향후 GET을 통해 액세스할 경우\) 사용 가능함을 나타냅니다. 예를 들어, POST 요청을 통해 이루어진 구매 거래에는 200\(OK\) 응답의 페이로드로 영수증 문서가 포함될 수 있습니다. Content-Location 필드 값은 나중에 동일한 영수증의 사본을 검색하기 위한 식별자를 제공합니다.

요청 메시지에서 Content-Location을 보내는 사용자 에이전트는 해당 값이 사용자 에이전트가 포함된 표현의 콘텐츠를 원래 얻은 위치\(해당 사용자 에이전트가 수정하기 전\)를 참조한다고 명시하고 있습니다. 즉, 사용자 에이전트는 원본 표현의 소스에 대한 백링크를 제공합니다.

요청 메시지에서 Content-Location 필드를 수신하는 원서버는 해당 정보를 표현의 일부로 축어적으로 저장되는 메타데이터가 아닌 임시 요청 컨텍스트로 처리해야 합니다. 원본 서버는 해당 컨텍스트를 사용하여 요청 처리를 안내하거나 소스 링크 또는 버전 관리 메타데이터 내와 같은 다른 용도로 저장할 수 있습니다. 그러나 원서버는 요청 의미를 변경하기 위해 그러한 컨텍스트 정보를 사용해서는 안 됩니다.\(MUST, MAY, MUST NOT\)

예를 들어, 클라이언트가 협상된 리소스에 대해 PUT 요청을 하고 원본 서버가 해당 PUT\(리디렉션 없이\)을 수락하는 경우 해당 리소스의 새로운 상태는 해당 PUT에 제공된 하나의 표현과 일치할 것으로 예상됩니다. Content-Location은 협상된 표현 중 하나만 업데이트하기 위한 역방향 콘텐츠 선택 식별자의 형태로 사용될 수 없습니다. 사용자 에이전트가 후자의 의미를 원했다면 PUT를 Content-Location URI에 직접 적용했을 것입니다.

---
### **3.2.  Representation Data**

HTTP 메시지와 관련된 표현 데이터는 메시지의 페이로드 본문으로 제공되거나 메시지 의미 체계 및 유효한 요청 URI에 의해 참조됩니다. 표현 데이터는 표현 메타데이터 헤더 필드에 의해 정의된 형식과 인코딩을 따릅니다.

표현 데이터의 데이터 유형은 헤더 필드 Content-Type 및 Content-Encoding을 통해 결정됩니다. 이는 순서가 지정된 2계층 인코딩 모델을 정의합니다.

```text
     representation-data := Content-Encoding( Content-Type( bits ) )
```

---
### **3.3.  Payload Semantics**

일부 HTTP 메시지는 메시지 "페이로드"로 전체 또는 부분 표현을 전송합니다. 어떤 경우에는 페이로드에 연관된 표현의 헤더 필드\(예: HEAD에 대한 응답\)만 포함되거나 표현 데이터의 일부 부분\(예: 206\(부분 콘텐츠\) 상태 코드\)만 포함될 수 있습니다.

요청에서 페이로드의 목적은 메소드 의미론에 의해 정의됩니다. 예를 들어, PUT 요청 페이로드\(섹션 4.3.4\)의 표현은 요청이 성공적으로 적용된 경우 대상 리소스의 원하는 상태를 나타내는 반면, POST 요청\(섹션 4.3.3\)의 페이로드 표현은 다음을 나타냅니다. 대상 리소스가 처리할 정보입니다.

응답에서 페이로드의 목적은 요청 메서드와 응답 상태 코드에 의해 정의됩니다. 예를 들어, GET\(섹션 4.3.1\)에 대한 200\(OK\) 응답의 페이로드는 메시지 발생 날짜\(섹션 7.1.1.2\) 당시 관찰된 대상 리소스의 현재 상태를 나타내는 반면, POST에 대한 응답의 동일한 상태 코드는 처리 결과 또는 처리를 적용한 후 대상 리소스의 새로운 상태를 나타낼 수 있습니다. 오류 상태 코드가 포함된 응답 메시지에는 일반적으로 오류 상태를 나타내는 페이로드가 포함되어 있으며, 오류 상태와 이를 해결하기 위해 제안되는 다음 단계를 설명합니다.

연관된 표현이 아닌 페이로드를 구체적으로 설명하는 헤더 필드를 "페이로드 헤더 필드"라고 합니다. 페이로드 헤더 필드는 메시지 구문 분석에 미치는 영향으로 인해 이 사양의 다른 부분에서 정의됩니다.

```text
   +-------------------+----------------------------+
   | Header Field Name | Defined in...              |
   +-------------------+----------------------------+
   | Content-Length    | Section 3.3.2 of [RFC7230] |
   | Content-Range     | Section 4.2 of [RFC7233]   |
   | Trailer           | Section 4.4 of [RFC7230]   |
   | Transfer-Encoding | Section 3.3.1 of [RFC7230] |
   +-------------------+----------------------------+
```

---
### **3.4.  Content Negotiation**

응답이 성공을 나타내든 오류를 나타내든 페이로드 정보를 전달할 때 원본 서버는 해당 정보를 표현하는 다양한 방법을 사용하는 경우가 많습니다. 예를 들어 다양한 형식, 언어 또는 인코딩이 있습니다. 마찬가지로, 다양한 사용자 또는 사용자 에이전트는 사용 가능한 표현 중에서 어떤 표현이 가장 전달하기에 영향을 미칠 수 있는 서로 다른 기능, 특성 또는 선호도를 가질 수 있습니다. 이러한 이유로 HTTP는 콘텐츠 협상을 위한 메커니즘을 제공합니다.

이 사양은 프로토콜 내에서 볼 수 있는 두 가지 콘텐츠 협상 패턴을 정의합니다. 즉, 서버가 사용자 에이전트의 명시된 기본 설정에 따라 표현을 선택하는 "사전" 협상과 서버가 다음에 대한 표현 목록을 제공하는 "반응" 협상입니다. 선택할 사용자 에이전트입니다. 콘텐츠 협상의 다른 패턴에는 표현이 사용자 에이전트 매개변수를 기반으로 선택적으로 렌더링되는 여러 부분으로 구성된 "조건부 콘텐츠", 표현에 기반하여 추가\(보다 구체적인\) 요청을 하는 스크립트가 포함된 "활성 콘텐츠"가 포함됩니다. 사용자 에이전트 특성 및 "투명한 콘텐츠 협상"\(\[RFC2295\]\), 여기서 콘텐츠

선택은 중개자를 통해 수행됩니다. 이러한 패턴은 상호 배타적이지 않으며 적용 가능성과 실용성 면에서 각각 장단점이 있습니다.

모든 경우에 HTTP는 리소스 의미를 인식하지 못합니다. 원서버가 시간이 지남에 따라 그리고 콘텐츠 협상의 다양한 차원에 걸쳐 요청에 응답하는 일관성, 그리고 시간이 지남에 따라 관찰된 리소스 표현의 "동일성"은 전적으로 해당 응답을 선택하거나 생성하는 엔터티 또는 알고리즘에 의해 결정됩니다. HTTP는 커튼 뒤에 있는 사람에게 관심을 기울이지 않습니다.

---
#### **3.4.1.  Proactive Negotiation**

서버에 있는 알고리즘이 선호하는 표현을 선택하도록 요청하면서 사용자 에이전트가 콘텐츠 협상 기본 설정을 전송하는 경우 이를 능동적 협상\(즉, 서버 기반 협상\)이라고 합니다. 선택은 섹션 5.3의 명시적 협상 필드와 암시적 협상 필드를 모두 포함하여 요청에 제공된 다양한 정보와 비교하여 응답에 사용 가능한 표현\(언어, 콘텐츠 코딩 등 다양할 수 있는 차원\)을 기반으로 합니다. 클라이언트의 네트워크 주소 또는 User-Agent 필드의 일부와 같은 특성.

사전 협상은 사용 가능한 표현 중에서 선택하기 위한 알고리즘이 사용자 에이전트에 설명하기 어려울 때 또는 서버가 첫 번째 응답과 함께 "최선의 추측"을 사용자 에이전트에 보내려고 할 때\(라운드를 피하기 위해\) 유리합니다. "최선의 추측"이 사용자에게 충분할 경우 후속 요청의 이동 지연\). 서버의 추측을 향상시키기 위해 사용자 에이전트는 자신의 기본 설정을 설명하는 요청 헤더 필드를 보낼 수 있습니다.\(MAY\)

적극적인 협상에는 다음과 같은 심각한 단점이 있습니다.

```text
   o  It is impossible for the server to accurately determine what might
      be "best" for any given user, since that would require complete
      knowledge of both the capabilities of the user agent and the
      intended use for the response (e.g., does the user want to view it
      on screen or print it on paper?);

   o  Having the user agent describe its capabilities in every request
      can be both very inefficient (given that only a small percentage
      of responses have multiple representations) and a potential risk
      to the user's privacy;
```

o 원본 서버의 구현과 요청에 대한 응답을 생성하는 알고리즘이 복잡해집니다. 그리고,

o 공유 캐싱에 대한 응답의 재사용성을 제한합니다.

사용자 에이전트는 원서버가 요청된 리소스에 대해 사전 협상을 구현하지 않거나 사용자 에이전트의 기본 설정에 맞지 않는 응답을 보내는 것이 406\( 허용되지 않음\) 응답.

Vary 헤더 필드\(섹션 7.1.4\)는 선택 알고리즘에 사용된 요청 정보 부분을 나타내기 위해 사전 협상에 따라 응답으로 전송되는 경우가 많습니다.

---
#### **3.4.2.  Reactive Negotiation**

반응적 협상\(즉, 에이전트 중심 협상\)을 사용하면 대체 표현에 대한 리소스 목록이 포함된 원본 서버로부터 초기 응답을 받은 후 사용자 에이전트가 최상의 응답 표현 선택\(상태 코드에 관계 없음\)을 수행합니다. 사용자 에이전트가 초기 응답 표현에 만족하지 않으면 목록에 포함된 메타데이터를 기반으로 선택된 하나 이상의 대체 리소스에 대해 GET 요청을 수행하여 해당 응답에 대한 다른 형태의 표현을 얻을 수 있습니다. 대안 선택은 사용자 에이전트에 의해 자동으로 수행되거나 생성된\(아마도 하이퍼텍스트\) 메뉴에서 선택하는 사용자에 의해 수동으로 수행될 수 있습니다.

위의 내용은 일반적으로 리소스 표현이 아닌 응답 표현을 나타냅니다. 대체 표현은 해당 대안이 제공되는 응답이 대상 리소스의 표현이라는 의미\(예: GET 요청에 대한 200\(OK\) 응답\)이거나 다음과 같은 의미를 갖는 경우에만 대상 리소스의 표현으로 간주됩니다. 대상 리소스에 대한 대체 표현에 대한 링크 제공\(예: GET 요청에 대한 300\(복수 선택\) 응답\)

서버는 대안 목록 이외의 초기 표현을 보내지 않기로 선택할 수 있으며 이에 따라 사용자 에이전트에 의한 반응적 협상이 선호됨을 나타낼 수 있습니다. 예를 들어, 300\(다중 선택\) 및 406\(허용되지 않음\) 상태 코드에 대한 응답에 나열된 대안에는 사용자 또는 사용자 에이전트가 선택을 통해 반응할 수 있도록 사용 가능한 표현에 대한 정보가 포함됩니다.

반응적 협상은 응답이 일반적으로 사용되는 차원\(예: 유형, 언어 또는 인코딩\)에 따라 다를 때, 원서버가 요청 검사에서 사용자 에이전트의 기능을 결정할 수 없을 때, 일반적으로 공개 캐시를 사용하여 배포할 때 유리합니다. 서버 부하를 줄이고 네트워크 사용량을 줄입니다.

반응적 협상은 대안 목록을 사용자 에이전트에 전송한다는 단점이 있습니다. 이는 헤더 섹션에서 전송되는 경우 사용자 인식 대기 시간을 저하시키고 대안 표현을 얻기 위해 두 번째 요청이 필요합니다. 또한, 이 사양은 자동 선택을 지원하는 메커니즘을 정의하지 않지만 이러한 메커니즘이 확장으로 개발되는 것을 방지하지는 않습니다.

---
## **4.  Request Methods**
---
### **4.1.  Overview**

요청 메소드 토큰은 요청 의미의 기본 소스입니다. 이는 클라이언트가 이 요청을 한 목적과 클라이언트가 성공적인 결과로 기대하는 바를 나타냅니다.

요청 메소드의 의미는 추가 의미가 메소드와 충돌하지 않는 경우 요청에 존재할 때 일부 헤더 필드의 의미\(섹션 5\)에 의해 더욱 특수화될 수 있습니다. 예를 들어, 클라이언트는 조건부 요청 헤더 필드\(5.2절\)를 보내 요청된 작업을 대상 리소스\(\[RFC7232\]\)의 현재 상태에 따라 조건부로 만들 수 있습니다.

```text
     method = token
```

HTTP는 원래 분산 객체 시스템에 대한 인터페이스로 사용할 수 있도록 설계되었습니다. 요청 메소드는 식별된 객체에 대해 정의된 메소드를 호출하는 것이 의미를 적용하는 것과 거의 동일한 방식으로 대상 리소스에 의미를 적용하는 것으로 구상되었습니다. 메소드 토큰은 메소드 이름이 대소문자를 구분하는 객체 기반 시스템에 대한 게이트웨이로 사용될 수 있으므로 대소문자를 구분합니다.

분산 개체와 달리 HTTP의 표준화된 요청 방법은 리소스별로 다르지 않습니다. 왜냐하면 균일한 인터페이스가 네트워크 기반 시스템\[REST\]에서 더 나은 가시성과 재사용을 제공하기 때문입니다. 일단 정의되면 표준화된 방법은 모든 리소스에 적용될 때 동일한 의미를 가져야 하지만 각 리소스는 해당 의미가 구현되거나 허용되는지 여부를 자체적으로 결정합니다.

이 사양은 다음 표에 설명된 대로 HTTP에서 일반적으로 사용되는 여러 가지 표준화된 메서드를 정의합니다. 관례적으로 표준화된 방법은 모두 대문자 US-ASCII 문자로 정의됩니다.

```text
   +---------+-------------------------------------------------+-------+
   | Method  | Description                                     | Sec.  |
   +---------+-------------------------------------------------+-------+
   | GET     | Transfer a current representation of the target | 4.3.1 |
   |         | resource.                                       |       |
   | HEAD    | Same as GET, but only transfer the status line  | 4.3.2 |
   |         | and header section.                             |       |
   | POST    | Perform resource-specific processing on the     | 4.3.3 |
   |         | request payload.                                |       |
   | PUT     | Replace all current representations of the      | 4.3.4 |
   |         | target resource with the request payload.       |       |
   | DELETE  | Remove all current representations of the       | 4.3.5 |
   |         | target resource.                                |       |
   | CONNECT | Establish a tunnel to the server identified by  | 4.3.6 |
   |         | the target resource.                            |       |
   | OPTIONS | Describe the communication options for the      | 4.3.7 |
   |         | target resource.                                |       |
   | TRACE   | Perform a message loop-back test along the path | 4.3.8 |
   |         | to the target resource.                         |       |
   +---------+-------------------------------------------------+-------+
```

모든 범용 서버는 GET 및 HEAD 메소드를 지원해야 합니다. 다른 모든 방법은 선택사항입니다.\(MUST, MAY\)

이 사양의 범위를 벗어나는 추가 메서드는 HTTP에서 사용하도록 표준화되었습니다. 이러한 모든 방법은 섹션 8.1에 정의된 대로 IANA가 관리하는 "HTTP\(Hypertext Transfer Protocol\) 방법 레지스트리" 내에 등록되어야 합니다.

대상 리소스에서 허용하는 메서드 집합은 Allow 헤더 필드\(섹션 7.4.1\)에 나열될 수 있습니다. 그러나 허용되는 메서드 집합은 동적으로 변경될 수 있습니다. 원서버가 인식할 수 없거나 구현하지 않은 요청 메서드가 수신되면 원서버는 501\(구현되지 않음\) 상태 코드로 응답해야 합니다. 원서버에 알려져 있지만 대상 리소스에 허용되지 않는 요청 방법이 수신되면 원서버는 405\(Method Not Allowed\) 상태 코드로 응답해야 합니다.\(SHOULD, SHOULD\)

---
### **4.2.  Common Method Properties**
---
#### **4.2.1.  Safe Methods**

요청 메소드는 정의된 의미가 기본적으로 읽기 전용인 경우 "안전한" 것으로 간주됩니다. 즉, 클라이언트는 대상 리소스에 안전한 방법을 적용한 결과 원본 서버의 상태 변경을 요청하지도 예상하지도 않습니다. 마찬가지로, 안전한 방법을 합리적으로 사용한다고 해서 원본 서버에 피해나 재산 손실 또는 비정상적인 부담이 발생할 것으로 예상되지는 않습니다.

안전한 메서드에 대한 이러한 정의는 잠재적으로 해로울 수 있는 동작, 완전히 읽기 전용이 아니거나 안전한 메서드를 호출하는 동안 부작용을 일으키는 동작을 구현에 포함하는 것을 방지하지 않습니다. 그러나 중요한 것은 내담자가 그러한 추가적인 행위를 요구한 것이 아니므로 이에 대해 책임을 질 수 없다는 점이다. 예를 들어, 대부분의 서버는 방법에 관계없이 모든 응답이 완료될 때 로그 파일에 액세스하기 위해 요청 정보를 추가하며 이는 로그 저장소가 가득 차서 서버가 중단되더라도 안전한 것으로 간주됩니다. 마찬가지로, 웹에서 광고를 선택하여 시작된 안전한 요청은 광고 계정에 비용을 청구하는 부작용이 있는 경우가 많습니다.

본 사양에서 정의한 요청 메소드 중 GET, HEAD, OPTIONS, TRACE 메소드는 안전하다고 정의되어 있다.

안전한 방법과 안전하지 않은 방법을 구별하는 목적은 자동화된 검색 프로세스\(스파이더\)와 캐시 성능 최적화\(프리페칭\)가 해를 끼칠 염려 없이 작동하도록 하는 것입니다. 또한 사용자 에이전트는 잠재적으로 신뢰할 수 없는 콘텐츠를 처리할 때 안전하지 않은 메서드의 자동화된 사용에 대해 적절한 제약 조건을 적용할 수 있습니다.

사용자 에이전트는 사용자에게 잠재적인 작업을 제시할 때 안전한 방법과 안전하지 않은 방법을 구별해야 합니다. 따라서 사용자는 요청되기 전에 안전하지 않은 작업을 인식할 수 있습니다.\(SHOULD\)

유효한 요청 URI 내의 매개변수가 작업을 선택하는 효과를 갖도록 리소스가 구성되면 해당 작업이 요청 메서드 의미 체계와 일치하는지 확인하는 것은 리소스 소유자의 책임입니다. 예를 들어, 웹 기반 콘텐츠 편집 소프트웨어에서는 "page?do=delete"와 같은 쿼리 매개변수 내의 작업을 사용하는 것이 일반적입니다. 이러한 리소스의 목적이 안전하지 않은 작업을 수행하는 것이라면 리소스 소유자는 안전한 요청 방법을 사용하여 액세스할 때 해당 작업을 비활성화하거나 허용하지 않아야 합니다. 그렇게 하지 않으면 자동화된 프로세스가 링크 유지 관리, 미리 가져오기, 검색 색인 구축 등을 위해 모든 URI 참조에 대해 GET을 수행할 때 불행한 부작용이 발생합니다.\(MUST\)

---
#### **4.2.2.  Idempotent Methods**

해당 메소드를 사용하는 여러 개의 동일한 요청이 서버에 미치는 의도된 효과가 단일 요청에 대한 효과와 동일한 경우 요청 메소드는 "멱등성"으로 간주됩니다. 본 사양에 정의된 요청 방법 중 PUT, DELETE 및 안전한 요청 방법은 멱등성을 갖습니다.

안전의 정의와 마찬가지로 멱등성 속성은 사용자가 요청한 항목에만 적용됩니다. 서버는 자유롭게 각 요청을 별도로 기록하거나 개정 제어 기록을 유지하거나 각 멱등성 요청에 대해 다른 비멱등성 부작용을 구현할 수 있습니다.

멱등적 방법은 클라이언트가 서버의 응답을 읽을 수 있기 전에 통신 오류가 발생하는 경우 요청이 자동으로 반복될 수 있다는 점에서 구별됩니다. 예를 들어, 클라이언트가 PUT 요청을 보내고 응답이 수신되기 전에 기본 연결이 닫히면 클라이언트는 새 연결을 설정하고 멱등성 요청을 다시 시도할 수 있습니다. 요청을 반복하면 원래 요청이 성공하더라도 응답이 다를 수 있지만 의도한 것과 동일한 효과가 있다는 것을 알고 있습니다.

---
#### **4.2.3.  Cacheable Methods**

요청 메소드는 "캐시 가능"으로 정의되어 해당 메소드에 대한 응답이 향후 재사용을 위해 저장될 수 있음을 나타냅니다. 특정 요구 사항은 \[RFC7234\]를 참조하세요. 일반적으로 현재 또는 신뢰할 수 있는 응답에 의존하지 않는 안전한 메서드는 캐시 가능한 것으로 정의됩니다. 이 사양에서는 GET, HEAD 및 POST를 캐시 가능한 것으로 정의하지만 압도적인 대다수의 캐시 구현은 GET 및 HEAD만 지원합니다.

---
### **4.3.  Method Definitions**
---
#### **4.3.1.  GET**

GET 메소드는 대상 리소스에 대해 현재 선택된 표현의 전송을 요청합니다. GET은 정보 검색의 기본 메커니즘이자 거의 모든 성능 최적화의 초점입니다. 따라서 사람들이 HTTP를 통해 식별 가능한 정보를 검색한다고 말할 때 일반적으로 GET 요청을 하는 것을 의미합니다.

리소스 식별자를 원격 파일 시스템 경로 이름으로 생각하고 표현을 해당 파일 내용의 복사본으로 생각하기 쉽습니다. 실제로 구현되는 리소스 수는 이 정도입니다\(관련 보안 고려 사항은 섹션 9.1 참조\). 그러나 실제로는 그러한 제한이 없습니다. 리소스에 대한 HTTP 인터페이스는 콘텐츠 개체 트리, 다양한 데이터베이스 레코드에 대한 프로그래밍 방식 보기 또는 다른 정보 시스템에 대한 게이트웨이로 구현될 가능성이 높습니다. URI 매핑 메커니즘이 파일 시스템에 연결되어 있는 경우에도 원본 서버는 파일을 직접 전송하는 대신 요청을 입력으로 사용하여 파일을 실행하고 출력을 표현으로 보내도록 구성될 수 있습니다. 그럼에도 불구하고 원본 서버만이 각 리소스가 어떻게 작동하는지 알아야 합니다.

식별자는 구현에 해당하며 각 구현이 GET에 대한 응답으로 대상 리소스의 현재 표현을 선택하고 보내는 방법에 해당합니다.

클라이언트는 요청에 Range 헤더 필드\(\[RFC7233\]\)를 전송하여 GET의 의미를 "범위 요청"으로 변경하여 선택한 표현의 일부만 전송하도록 요청할 수 있습니다.

GET 요청 메시지 내의 페이로드에는 정의된 의미가 없습니다. GET 요청에 페이로드 본문을 보내면 일부 기존 구현이 요청을 거부할 수 있습니다.

GET 요청에 대한 응답은 캐시 가능합니다. 캐시는 Cache-Control 헤더 필드\(\[RFC7234\]의 섹션 5.2\)에 달리 표시되지 않는 한 후속 GET 및 HEAD 요청을 충족하기 위해 이를 사용할 수 있습니다.\(MAY\)

---
#### **4.3.2.  HEAD**

HEAD 메소드는 서버가 응답에 메시지 본문을 보내면 안 된다는 점을 제외하면 GET과 동일합니다\(즉, 응답은 헤더 섹션의 끝에서 종료됩니다\). 서버는 페이로드 헤더 필드\(섹션 3.3\)가 생략될 수 있다는 점을 제외하고 HEAD 요청에 대한 응답으로 요청이 GET인 경우 전송했을 것과 동일한 헤더 필드를 전송해야 합니다. 이 방법은 표현 데이터를 전송하지 않고 선택한 표현에 대한 메타데이터를 얻는 데 사용할 수 있으며 하이퍼텍스트 링크의 유효성, 접근성 및 최근 수정을 테스트하는 데 자주 사용됩니다.\(MUST NOT, SHOULD\)

HEAD 요청 메시지 내의 페이로드에는 정의된 의미가 없습니다. HEAD 요청에 대해 페이로드 본문을 보내면 일부 기존 구현이 요청을 거부할 수 있습니다.

HEAD 요청에 대한 응답은 캐시 가능합니다. 캐시는 Cache-Control 헤더 필드\(\[RFC7234\]의 섹션 5.2\)에 달리 표시되지 않는 한 후속 HEAD 요청을 충족하기 위해 이를 사용할 수 있습니다. HEAD 응답은 GET에 대해 이전에 캐시된 응답에 영향을 미칠 수도 있습니다. \[RFC7234\]의 섹션 4.3.5를 참조하세요.\(MAY\)

---
#### **4.3.3.  POST**

POST 메서드는 대상 리소스가 리소스 고유의 특정 의미에 따라 요청에 포함된 표현을 처리하도록 요청합니다. 예를 들어 POST는 다음 기능에 사용됩니다.

```text
   o  Providing a block of data, such as the fields entered into an HTML
      form, to a data-handling process;

   o  Posting a message to a bulletin board, newsgroup, mailing list,
      blog, or similar group of articles;
```

o 아직 원본 서버에서 식별되지 않은 새로운 리소스를 생성합니다. 그리고

o 자원의 기존 표현에 데이터를 추가합니다.

원서버는 POST 요청 처리 결과에 따라 적절한 상태 코드를 선택하여 응답 의미를 나타냅니다. 이 사양에 정의된 거의 모든 상태 코드는 POST에 대한 응답으로 수신될 수 있습니다\(예외: 206\(부분 콘텐츠\), 304\(수정되지 않음\) 및 416\(범위가 만족되지 않음\)\).

POST 요청을 성공적으로 처리한 결과 원서버에 하나 이상의 리소스가 생성된 경우 원서버는 생성된 기본 리소스에 대한 식별자를 제공하는 Location 헤더 필드가 포함된 201\(Created\) 응답을 보내야 합니다\(7.1절\). .2\) 및 새 리소스를 참조하면서 요청 상태를 설명하는 표현입니다.\(SHOULD\)

POST 요청에 대한 응답은 명시적인 신선도 정보를 포함하는 경우에만 캐시할 수 있습니다\(\[RFC7234\]의 섹션 4.2.1 참조\). 그러나 POST 캐싱은 널리 구현되지 않습니다. 원서버가 클라이언트가 나중에 GET에서 재사용할 수 있는 방식으로 POST 결과를 캐시할 수 있기를 원하는 경우, 원서버는 결과와 Content-Location을 포함하는 200\(OK\) 응답을 보낼 수 있습니다. POST의 유효 요청 URI\(섹션 3.1.4.2\)와 동일한 값을 갖는 헤더 필드입니다.\(MAY\)

POST 처리 결과가 기존 리소스의 표현과 동일할 경우 원서버는 Location 필드에 기존 리소스 식별자가 포함된 303\(See Other\) 응답을 전송하여 사용자 에이전트를 해당 리소스로 리디렉션할 수 있습니다\(MAY\). 이는 사용자 에이전트에 리소스 식별자를 제공하고 공유 캐싱에 더 적합한 방법을 통해 표현을 전송하는 이점이 있지만 사용자 에이전트에 아직 캐시된 표현이 없는 경우 추가 요청이 필요합니다.\(MAY\)

---
#### **4.3.4.  PUT**

PUT 메서드는 대상 리소스의 상태가 생성되거나 요청 메시지 페이로드에 포함된 표현으로 정의된 상태로 대체되도록 요청합니다. 주어진 표현의 성공적인 PUT은 동일한 대상 리소스에 대한 후속 GET이 200\(OK\) 응답으로 전송되는 동등한 표현을 초래할 것임을 제안합니다. 그러나 그렇다고 보장할 수는 없습니다.

후속 GET이 수신되기 전에 대상 리소스가 다른 사용자 에이전트에 의해 병렬로 작동되거나 원본 서버에 의해 동적 처리될 수 있으므로 이러한 상태 변경은 관찰 가능합니다. 성공적인 응답은 원서버에서 처리할 때 사용자 에이전트의 의도가 달성되었음을 의미합니다.

대상 리소스에 현재 표현이 없고 PUT가 성공적으로 표현을 생성한 경우 원서버는 201\(생성됨\) 응답을 전송하여 사용자 에이전트에 알려야 합니다. 대상 리소스에 현재 표현이 있고 해당 표현이 포함된 표현의 상태에 따라 성공적으로 수정된 경우 원서버는 성공적인 완료를 나타내기 위해 200\(OK\) 또는 204\(No Content\) 응답을 보내야 합니다. 요청.\(MUST, MUST\)

원서버는 PUT 요청에서 수신된 인식되지 않은 헤더 필드를 무시해야 합니다\(즉, 리소스 상태의 일부로 저장하지 마십시오\).\(SHOULD\)

원서버는 PUT 표현이 PUT에 의해 변경될 수 없거나 변경되지 않을 대상 리소스에 대해 서버가 갖는 모든 제약 조건과 일치하는지 확인해야 합니다. 이는 원본 서버가 GET 응답에 대한 표현 메타데이터 값을 설정하기 위해 URI와 관련된 내부 구성 정보를 사용할 때 특히 중요합니다. PUT 표현이 대상 리소스와 일치하지 않는 경우 원서버는 표현을 변환하거나 리소스 구성을 변경하여 이를 일관되게 만들거나 표현이 부적합한 이유를 설명하기에 충분한 정보가 포함된 적절한 오류 메시지로 응답해야 합니다. 409\(충돌\) 또는 415\(지원되지 않는 미디어 유형\) 상태 코드가 제안되며, 후자는 Content-Type 값에 대한 제약 조건과 관련이 있습니다.\(SHOULD, SHOULD\)

예를 들어 대상 리소스가 항상 "text/html"의 Content-Type을 갖도록 구성되고 PUT 표현의 Content-Type이 "image/jpeg"인 경우 원본 서버는 다음 중 하나를 수행해야 합니다.

```text
   a.  reconfigure the target resource to reflect the new media type;
```

비. PUT 표현을 새로운 리소스 상태로 저장하기 전에 리소스의 형식과 일치하는 형식으로 변환합니다. 또는,

씨. 대상 리소스가 "text/html"로 제한되어 있음을 나타내는 415\(지원되지 않는 미디어 유형\) 응답으로 요청을 거부합니다. 아마도 새 표현에 적합한 대상이 될 다른 리소스에 대한 링크가 포함될 수 있습니다.

HTTP는 사용자 에이전트 요청의 의도와 원서버 응답의 의미로 표현할 수 있는 것 이상으로 PUT 메서드가 원서버의 상태에 어떻게 영향을 미치는지 정확하게 정의하지 않습니다. 어떤 의미에서든 HTTP를 통해 제공되는 인터페이스를 넘어서는 리소스가 무엇인지 정의하지 않습니다. 리소스 상태가 어떻게 "저장"되는지, 리소스 상태 변경으로 인해 이러한 스토리지가 어떻게 변경될 수 있는지, 원본 서버가 리소스 상태를 표현으로 변환하는 방법을 정의하지 않습니다. 일반적으로 리소스 인터페이스 뒤에 있는 모든 구현 세부 사항은 서버에 의해 의도적으로 숨겨집니다.

요청의 표현 데이터가 본문\(즉, 리소스의 새로운 표현 데이터는 PUT 요청에서 수신된 표현 데이터와 동일하며 유효성 검사기 필드 값은 새로운 표현을 반영합니다. 이 요구 사항을 통해 사용자 에이전트는 PUT의 결과로 메모리에 있는 표현 본문이 현재 상태로 유지되어 원본 서버에서 다시 검색할 필요가 없고 응답에서 새 유효성 검사기가 수신되었음을 알 수 있습니다. 실수로 덮어쓰는 것을 방지하기 위해 향후 조건부 요청에 사용할 수 있습니다\(섹션 5.2\).\(MUST NOT\)

POST와 PUT 메소드 간의 근본적인 차이점은 포함된 표현의 의도가 다르기 때문에 강조됩니다. POST 요청의 대상 리소스는 리소스 자체 의미에 따라 포함된 표현을 처리하기 위한 반면, PUT 요청의 포함된 표현은 대상 리소스의 상태를 대체하는 것으로 정의됩니다. 따라서 PUT의 의도는 멱등성이 있고 중개자에게 표시됩니다. 비록 정확한 효과는 원본 서버에서만 알 수 있습니다.

PUT 요청을 올바르게 해석하려면 사용자 에이전트가 어떤 대상 리소스가 필요한지 알고 있다고 가정합니다. 상태 변경 요청을 수신한 후 클라이언트를 대신하여 적절한 URI를 선택하는 서비스는 PUT가 아닌 POST 메서드를 사용하여 구현되어야 합니다. 원서버가 요청된 PUT 상태를 대상 리소스로 변경하지 않고 대신 리소스가 다른 URI로 이동된 경우와 같이 다른 리소스에 적용하기를 원하는 경우 원서버는 적절한 3xx를 보내야 합니다. \(리디렉션\) 응답; 그런 다음 사용자 에이전트는 요청을 리디렉션할지 여부를 자체적으로 결정할 수 있습니다.\(SHOULD, MUST\)

대상 리소스에 적용된 PUT 요청은 다른 리소스에 부작용을 일으킬 수 있습니다. 예를 들어 기사에는 각 특정 버전\(다른 리소스\)을 식별하는 URI와 별개인 "현재 버전"\(리소스\)을 식별하기 위한 URI가 있을 수 있습니다.

한 시점에서 현재 버전 리소스와 동일한 상태를 공유했습니다\). 따라서 "현재 버전" URI에 대한 PUT 요청이 성공하면 대상 리소스의 상태를 변경하는 것 외에도 새 버전 리소스가 생성될 수 있으며 관련 리소스 간에 링크가 추가될 수도 있습니다.

주어진 대상 리소스에 대한 PUT를 허용하는 원서버는 페이로드가 부분 콘텐츠일 가능성이 높으므로 Content-Range 헤더 필드\(\[RFC7233\]의 섹션 4.2\)를 포함하는 PUT 요청에 400\(잘못된 요청\) 응답을 보내야 합니다. 이는 실수로 전체 표현으로 PUT되었습니다. 부분 콘텐츠 업데이트는 더 큰 리소스의 일부와 겹치는 상태로 별도로 식별된 리소스를 대상으로 하거나 부분 업데이트에 대해 특별히 정의된 다른 방법\(예: \[RFC5789\]에 정의된 PATCH 방법\)을 사용하여 가능합니다.\(MUST\)

PUT 메서드에 대한 응답은 캐시할 수 없습니다. 성공적인 PUT 요청이 유효한 요청 URI에 대해 하나 이상의 저장된 응답이 있는 캐시를 통과하는 경우 저장된 응답은 무효화됩니다\(\[RFC7234\]의 섹션 4.4 참조\).

---
#### **4.3.5.  DELETE**

DELETE 메소드는 원본 서버가 대상 리소스와 현재 기능 간의 연결을 제거하도록 요청합니다. 실제로 이 방법은 UNIX의 rm 명령과 유사합니다. 즉, 이전에 연관된 정보가 삭제된다는 기대보다는 원본 서버의 URI 매핑에 대한 삭제 작업을 표현합니다.

대상 리소스에 하나 이상의 현재 표현이 있는 경우 해당 표현은 원서버에 의해 파기되거나 삭제되지 않을 수 있으며, 관련 저장소는 리소스의 성격과 원서버에 의한 구현에 전적으로 따라 회수될 수도 있고 그렇지 않을 수도 있습니다\( 이는 이 사양의 범위를 벗어납니다.\) 마찬가지로 데이터베이스 또는 게이트웨이 연결과 같은 DELETE의 결과로 리소스의 다른 구현 측면을 비활성화하거나 보관해야 할 수도 있습니다. 일반적으로 원본 서버는 삭제를 수행하기 위해 규정된 메커니즘이 있는 리소스에 대해서만 DELETE를 허용한다고 가정합니다.

DELETE 메소드를 허용하는 리소스는 상대적으로 적습니다. 이 메소드의 주요 용도는 사용자가 그 효과에 대해 특정 방향을 갖는 원격 저작 환경입니다. 예를 들어 이전에 PUT 요청을 사용하여 생성되었거나 POST 요청에 대한 201\(Created\) 응답 후 Location 헤더 필드를 통해 식별된 리소스는 해당 DELETE 요청이 해당 작업을 취소하도록 허용할 수 있습니다. 마찬가지로, 구현하는 사용자 정의 사용자 에이전트 구현

원격 작업을 위해 HTTP를 사용하는 개정 제어 클라이언트와 같은 저작 기능은 서버의 URI 공간이 버전 저장소에 대응하도록 제작되었다는 가정을 기반으로 DELETE를 사용할 수 있습니다.

DELETE 메소드가 성공적으로 적용된 경우, 원서버는 작업이 성공할 가능성이 있지만 아직 실행되지 않은 경우 202\(Accepted\) 상태 코드를 보내야 하고, 작업이 실행되었으며 더 이상 실행되지 않은 경우 204\(No Content\) 상태 코드를 보내야 합니다. 정보가 제공되거나, 작업이 실행되고 응답 메시지에 상태를 설명하는 표현이 포함된 경우 200\(OK\) 상태 코드가 제공됩니다.\(SHOULD\)

DELETE 요청 메시지 내의 페이로드에는 정의된 의미가 없습니다. DELETE 요청에 대해 페이로드 본문을 보내면 일부 기존 구현이 요청을 거부할 수 있습니다.

DELETE 메소드에 대한 응답은 캐시할 수 없습니다. DELETE 요청이 유효한 요청 URI에 대해 하나 이상의 저장된 응답이 있는 캐시를 통과하는 경우 저장된 응답은 무효화됩니다\(\[RFC7234\]의 섹션 4.4 참조\).

---
#### **4.3.6.  CONNECT**

CONNECT 메소드는 수신자가 요청 대상으로 식별된 대상 원본 서버에 대한 터널을 설정하도록 요청하고, 성공할 경우 터널이 닫힐 때까지 양방향으로 패킷을 블라인드 전달하도록 동작을 제한합니다. 터널은 일반적으로 하나 이상의 프록시를 통해 종단 간 가상 연결을 생성하는 데 사용되며, 이는 TLS\(전송 계층 보안, \[RFC5246\]\)를 사용하여 보호될 수 있습니다.

CONNECT는 프록시에 대한 요청에만 사용됩니다. CONNECT 요청을 수신한 원서버는 연결이 설정되었음을 나타내기 위해 2xx\(성공\) 상태 코드로 응답할 수 있습니다. 그러나 대부분의 원본 서버는 CONNECT를 구현하지 않습니다.\(MAY\)

CONNECT 요청을 보내는 클라이언트는 요청 대상의 권한 형식을 보내야 합니다\(\[RFC7230\]의 섹션 5.3\). 즉, 요청 대상은 콜론으로 구분된 터널 대상의 호스트 이름과 포트 번호로만 구성됩니다. 예를 들어,\(MUST\)

```text
     CONNECT server.example.com:80 HTTP/1.1
     Host: server.example.com:80
```

수신자 프록시는 요청 대상에 직접 연결하거나, 다른 프록시를 사용하도록 구성된 경우 CONNECT 요청을 다음 인바운드 프록시로 전달하여 터널을 설정할 수 있습니다. 2xx\(성공\) 응답은 발신자\(및 모든

인바운드 프록시\)는 성공적인 응답의 헤더 섹션을 끝내는 빈 줄 바로 뒤에 터널 모드로 전환합니다. 해당 빈 줄 이후에 수신된 데이터는 요청 대상으로 식별된 서버에서 온 것입니다. 성공적인 응답 이외의 응답은 터널이 아직 형성되지 않았으며 연결이 여전히 HTTP에 의해 관리된다는 것을 나타냅니다.

터널 중개자는 한쪽이 연결을 닫았음을 감지하면 터널이 닫힙니다. 중개자는 닫힌 쪽에서 다른 쪽으로 온 미해결 데이터를 전송하려고 시도하고 두 연결을 모두 닫은 다음 전달되지 않은 나머지 데이터를 삭제해야 합니다.\(MUST\)

프록시 인증을 사용하여 터널을 생성할 수 있는 권한을 설정할 수 있습니다. 예를 들어,

```text
     CONNECT server.example.com:80 HTTP/1.1
     Host: server.example.com:80
     Proxy-Authorization: basic aGVsbG86d29ybGQ=
```

임의의 서버에 대한 터널을 설정하는 데에는 상당한 위험이 있습니다. 특히 대상이 웹 트래픽용이 아닌 잘 알려져 있거나 예약된 TCP 포트인 경우 더욱 그렇습니다. 예를 들어 요청 대상 "example.com:25"에 대한 CONNECT는 프록시가 SMTP 트래픽용으로 예약된 포트에 연결하도록 제안합니다. 허용되는 경우 프록시를 속여 스팸 이메일을 전달하도록 할 수 있습니다. CONNECT를 지원하는 프록시는 알려진 포트의 제한된 집합이나 안전한 요청 대상의 구성 가능한 화이트리스트로 사용을 제한해야 합니다.\(SHOULD\)

서버는 CONNECT에 대한 2xx\(성공\) 응답으로 Transfer-Encoding 또는 Content-Length 헤더 필드를 전송해서는 안 됩니다. 클라이언트는 CONNECT에 대한 성공적인 응답으로 수신된 모든 Content-Length 또는 Transfer-Encoding 헤더 필드를 무시해야 합니다.\(MUST NOT, MUST\)

CONNECT 요청 메시지 내의 페이로드에는 정의된 의미가 없습니다. CONNECT 요청에 대해 페이로드 본문을 보내면 일부 기존 구현이 요청을 거부할 수 있습니다.

CONNECT 메소드에 대한 응답은 캐시할 수 없습니다.

---
#### **4.3.7.  OPTIONS**

OPTIONS 메소드는 원본 서버나 중간 중개자에서 대상 리소스에 사용할 수 있는 통신 옵션에 대한 정보를 요청합니다. 이 방법을 사용하면 클라이언트는 리소스 작업을 암시하지 않고 리소스 또는 서버 기능과 관련된 옵션 및/또는 요구 사항을 결정할 수 있습니다.

요청 대상\(\[RFC7230\]의 섹션 5.3\)으로 별표\("\*"\)가 있는 OPTIONS 요청은 특정 리소스가 아닌 일반적으로 서버에 적용됩니다. 서버의 통신 옵션은 일반적으로 리소스에 따라 달라지므로 "\*" 요청은 "ping" 또는 "no-op" 유형의 방법으로만 유용합니다. 클라이언트가 서버의 기능을 테스트하도록 허용하는 것 외에는 아무 것도 수행하지 않습니다. 예를 들어, 이는 프록시의 HTTP/1.1 적합성\(또는 적합성 부족\)을 테스트하는 데 사용될 수 있습니다.

request-target이 별표가 아닌 경우 OPTIONS 요청은 대상 리소스와 통신할 때 사용 가능한 옵션에 적용됩니다.

OPTIONS에 대한 성공적인 응답을 생성하는 서버는 이 사양에서 정의되지 않은 잠재적 확장을 포함하여 서버에 의해 구현되고 대상 리소스에 적용 가능한 선택적 기능\(예: 허용\)을 나타낼 수 있는 모든 헤더 필드를 보내야 합니다. 응답 페이로드\(있는 경우\)는 기계 또는 사람이 읽을 수 있는 표현으로 통신 옵션을 설명할 수도 있습니다. 이러한 표현에 대한 표준 형식은 이 사양에 의해 정의되지 않지만 향후 HTTP 확장에 의해 정의될 수 있습니다. 응답으로 페이로드 본문이 전송되지 않는 경우 서버는 값이 "0"인 Content-Length 필드를 생성해야 합니다.\(SHOULD, MUST\)

클라이언트는 요청 체인의 특정 수신자를 대상으로 OPTIONS 요청에 Max-Forwards 헤더 필드를 보낼 수 있습니다\(섹션 5.1.2 참조\). 요청이 Max-Forwards 필드와 함께 수신되지 않는 한 프록시는 요청을 전달하는 동안 Max-Forwards 헤더 필드를 생성해서는 안 됩니다.\(MAY, MUST NOT\)

페이로드 본문을 포함하는 OPTIONS 요청을 생성하는 클라이언트는 표현 미디어 유형을 설명하는 유효한 Content-Type 헤더 필드를 보내야 합니다. 이 사양은 이러한 페이로드에 대한 용도를 정의하지 않지만 향후 HTTP 확장에서는 OPTIONS 본문을 사용하여 대상 리소스에 대해 더 자세한 쿼리를 수행할 수 있습니다.\(MUST\)

OPTIONS 메서드에 대한 응답은 캐시할 수 없습니다.

---
#### **4.3.8.  TRACE**

TRACE 메소드는 요청 메시지의 원격 애플리케이션 수준 루프백을 요청합니다. 요청의 최종 수신자는 아래에 설명된 일부 필드를 제외하고 수신된 메시지를 Content-Type이 "message/http"인 200\(OK\) 응답의 메시지 본문으로 클라이언트에 다시 반영해야 합니다\(8.3.1절\). \[RFC7230\]\). 최종 수신자는 원본 서버이거나 요청에서 Max-Forwards 값 0\(5.1.2절\)을 수신한 첫 번째 서버입니다.\(SHOULD\)

클라이언트는 응답에 의해 공개될 수 있는 민감한 데이터를 포함하는 TRACE 요청에서 헤더 필드를 생성해서는 안 됩니다. 예를 들어 사용자 에이전트가 TRACE 요청에 저장된 사용자 자격 증명 \[RFC7235\] 또는 쿠키 \[RFC6265\]를 보내는 것은 어리석은 일입니다. 요청의 최종 수신자는 응답 본문을 생성할 때 민감한 데이터를 포함할 가능성이 있는 모든 요청 헤더 필드를 제외해야 합니다\(SHOULD\).\(MUST NOT, SHOULD\)

TRACE를 통해 클라이언트는 요청 체인의 다른 쪽 끝에서 수신되는 내용을 확인하고 해당 데이터를 테스트 또는 진단 정보에 사용할 수 있습니다. Via 헤더 필드\(\[RFC7230\]의 섹션 5.7.1\)의 값은 요청 체인의 추적 역할을 하기 때문에 특히 중요합니다. Max-Forwards 헤더 필드를 사용하면 클라이언트가 요청 체인의 길이를 제한할 수 있으며, 이는 무한 루프에서 메시지를 전달하는 프록시 체인을 테스트하는 데 유용합니다.

클라이언트는 TRACE 요청에 메시지 본문을 보내면 안 됩니다.\(MUST NOT\)

TRACE 메서드에 대한 응답은 캐시할 수 없습니다.

---
## **5.  Request Header Fields**

클라이언트는 요청 헤더 필드를 보내 요청 컨텍스트에 대한 추가 정보를 제공하고, 대상 리소스 상태에 따라 요청을 조건부로 만들고, 선호하는 응답 형식을 제안하고, 인증 자격 증명을 제공하거나, 예상되는 요청 처리를 수정합니다. 이러한 필드는 프로그래밍 언어 메서드 호출의 매개 변수와 유사한 요청 수정자 역할을 합니다.

---
### **5.1.  Controls**

컨트롤은 요청의 특정 처리를 지시하는 요청 헤더 필드입니다.

```text
   +-------------------+--------------------------+
   | Header Field Name | Defined in...            |
   +-------------------+--------------------------+
   | Cache-Control     | Section 5.2 of [RFC7234] |
   | Expect            | Section 5.1.1            |
   | Host              | Section 5.4 of [RFC7230] |
   | Max-Forwards      | Section 5.1.2            |
   | Pragma            | Section 5.4 of [RFC7234] |
   | Range             | Section 3.1 of [RFC7233] |
   | TE                | Section 4.3 of [RFC7230] |
   +-------------------+--------------------------+
```

---
#### **5.1.1.  Expect**

요청의 "Expect" 헤더 필드는 이 요청을 적절하게 처리하기 위해 서버에서 지원해야 하는 특정 동작\(기대\) 집합을 나타냅니다. 이 사양에서 정의한 유일한 기대치는 100-continue입니다.

```text
     Expect  = "100-continue"
```

Expect 필드 값은 대소문자를 구분하지 않습니다.

100-continue 이외의 Expect 필드 값을 수신한 서버는 417\(Expectation Failed\) 상태 코드로 응답하여 예상치 못한 기대치를 충족할 수 없음을 나타낼 수 있습니다.\(MAY\)

100-continue 기대는 클라이언트가 이 요청에서 \(아마도 큰\) 메시지 본문을 보내려고 하고 요청 라인과 헤더 필드가 즉각적인 응답을 유발하기에 충분하지 않은 경우 100\(Continue\) 중간 응답을 받기를 원한다는 것을 수신자에게 알립니다. 성공, 리디렉션 또는 오류 응답. 이를 통해 클라이언트는 실제로 메시지 본문을 보내기 전에 메시지 본문을 보내는 것이 가치가 있다는 표시를 기다릴 수 있습니다. 이는 메시지 본문이 크거나 클라이언트가 오류가 발생할 가능성이 있다고 예상할 때\(예: 상태를 보낼 때\) 효율성을 향상시킬 수 있습니다. -사전에 검증된 인증 정보 없이 처음으로 방법을 변경함\).

예를 들어 다음으로 시작하는 요청은

```text
     PUT /somewhere/fun HTTP/1.1
     Host: origin.example.com
     Content-Type: video/h264
     Content-Length: 1234567890987
     Expect: 100-continue
```

클라이언트가 불필요한 데이터 전송으로 파이프를 채우기 시작하기 전에 원본 서버가 401\(인증되지 않음\) 또는 405\(메소드 허용되지 않음\)과 같은 오류 메시지로 즉시 응답할 수 있습니다.

클라이언트 요구 사항:

o 클라이언트는 메시지 본문을 포함하지 않는 요청에서 100-continue 기대치를 생성해서는 안 됩니다.\(MUST NOT\)

o 요청 메시지 본문을 보내기 전에 100\(Continue\) 응답을 기다리는 클라이언트는 100-continue 기대치를 포함하는 Expect 헤더 필드를 보내야 합니다.\(MUST\)

o 100 연속 기대치를 보내는 클라이언트는 특정 시간 동안 기다릴 필요가 없습니다. 그러한 클라이언트는 아직 응답을 받지 못한 경우에도 메시지 본문을 계속해서 보낼 수 있습니다. 또한 100\(Continue\) 응답은 HTTP/1.0 중개자를 통해 보낼 수 없으므로 이러한 클라이언트는 메시지 본문을 보내기 전에 무기한 대기해서는 안 됩니다.\(MAY, SHOULD NOT\)

o 100 연속 기대가 포함된 요청에 대한 응답으로 417\(예상 실패\) 상태 코드를 수신한 클라이언트는 100 연속 기대 없이 해당 요청을 반복해야 합니다. 417 응답은 단지 응답 체인이 기대를 지원하지 않는다는 것을 나타낼 뿐이기 때문입니다. 예를 들어 HTTP/1.0 서버를 통과합니다.\(SHOULD\)

서버 요구 사항:

o HTTP/1.0 요청에서 100-continue 기대치를 수신하는 서버는 해당 기대치를 무시해야 합니다.\(MUST\)

o 서버는 해당 요청에 대한 메시지 본문의 일부 또는 전체를 이미 수신했거나 프레이밍에 메시지 본문이 없음이 표시된 경우 100\(계속\) 응답 전송을 생략할 수 있습니다.\(MAY\)

o 100\(계속\) 응답을 보내는 서버는 연결이 조기에 닫히지 않는 한 메시지 본문이 수신되고 처리되면 궁극적으로 최종 상태 코드를 보내야 합니다.\(MUST\)

o 전체 메시지 본문을 읽기 전에 최종 상태 코드로 응답하는 서버는 연결을 닫을 것인지 아니면 요청 메시지를 계속 읽고 삭제할 것인지 해당 응답에 표시해야 합니다\(\[RFC7230\]의 섹션 6.6 참조\).\(SHOULD\)

원서버는 HTTP/1.1\(또는 그 이상\) 요청 라인과 100 연속 예상을 포함하고 요청 메시지 본문이 뒤따를 것임을 나타내는 완전한 헤더 섹션을 수신하면 최종 상태 코드가 포함된 즉각적인 응답을 보내야 합니다. 요청 라인과 헤더 필드만 검사하여 해당 상태를 확인할 수 있거나 즉시 100\(계속\) 응답을 보내 클라이언트가 요청의 메시지 본문을 보내도록 권장합니다. 원본 서버는 100\(계속\) 응답을 보내기 전에 메시지 본문을 기다려서는 안 됩니다.\(MUST, MUST NOT\)

프록시는 HTTP/1.1\(또는 그 이상\) 요청 라인과 100 연속 기대치를 포함하고 요청 메시지 본문이 뒤따를 것임을 나타내는 완전한 헤더 섹션을 수신하면 다음과 같은 경우 최종 상태 코드와 함께 즉각적인 응답을 보내야 합니다. 해당 상태는 요청 라인과 헤더 필드만 검사하여 확인하거나 다음을 보내 원본 서버로 요청 전달을 시작할 수 있습니다.\(MUST\)

해당 요청 라인과 헤더 섹션을 다음 인바운드 서버로 보냅니다. 프록시가 \(구성 또는 과거 상호작용을 통해\) 다음 인바운드 서버가 HTTP/1.0만 지원한다고 믿는 경우, 프록시는 클라이언트가 메시지 본문 전송을 시작하도록 권장하기 위해 즉시 100\(계속\) 응답을 생성할 수 있습니다.\(MAY\)

- 참고: Expect 헤더 필드는 임시 100\(계속\) 응답을 요청하는 수단과 반드시 ​​이해해야 하는 확장을 표시하기 위한 일반 메커니즘으로 HTTP/1.1 \[RFC2068\]이 처음 게시된 후 추가되었습니다. 그러나 확장 메커니즘은 클라이언트에서 사용되지 않았으며 반드시 이해해야 할 요구 사항이 많은 서버에서 구현되지 않아 확장 메커니즘이 쓸모 없게 되었습니다. 이 사양에서는 100-continue의 정의와 처리를 단순화하기 위해 확장 메커니즘을 제거했습니다.

---
#### **5.1.2.  Max-Forwards**

"Max-Forwards" 헤더 필드는 요청이 프록시에 의해 전달되는 횟수를 제한하기 위해 TRACE\(섹션 4.3.8\) 및 OPTIONS\(섹션 4.3.7\) 요청 메서드가 포함된 메커니즘을 제공합니다. 이는 클라이언트가 중간 체인에서 실패하거나 반복되는 것으로 보이는 요청을 추적하려고 할 때 유용할 수 있습니다.

```text
     Max-Forwards = 1*DIGIT
```

Max-Forwards 값은 이 요청 메시지가 전달될 수 있는 남은 횟수를 나타내는 10진수 정수입니다.

Max-Forwards 헤더 필드가 포함된 TRACE 또는 OPTIONS 요청을 수신하는 각 중개자는 요청을 전달하기 전에 해당 값을 확인하고 업데이트해야 합니다. 수신된 값이 0인 경우 중개자는 요청을 전달해서는 안 됩니다. 대신 중개자는 최종 수신자로 응답해야 합니다. 수신된 Max-Forwards 값이 0보다 큰 경우 중개자는 a\) 수신된 값에서 1만큼 감소하거나 b\) 중 작은 필드 값을 사용하여 전달된 메시지에서 업데이트된 Max-Forwards 필드를 생성해야 합니다. Max-Forwards에 대한 수신자의 최대 지원 값입니다.\(MUST, MUST NOT, MUST\)

수신자는 다른 요청 방법으로 수신된 Max-Forwards 헤더 필드를 무시할 수 있습니다.\(MAY\)

---
### **5.2.  Conditionals**

HTTP 조건부 요청 헤더 필드 \[RFC7232\]를 사용하면 클라이언트가 대상 리소스의 상태에 전제 조건을 설정할 수 있으므로 전제 조건이 false로 평가되면 메서드 의미론에 해당하는 작업이 적용되지 않습니다. 다음으로 정의된 각 전제조건은

이 사양은 대상 리소스의 이전 표현에서 얻은 일련의 유효성 검사기와 선택한 표현에 대한 현재 유효성 검사기 상태 간의 비교로 구성됩니다\(섹션 7.2\). 따라서 이러한 전제 조건은 클라이언트가 알고 있는 특정 상태 이후 대상 리소스의 상태가 변경되었는지 여부를 평가합니다. 이러한 평가의 효과는 \[RFC7232\]의 섹션 5에 정의된 대로 메서드 의미론과 조건부 선택에 따라 달라집니다.

```text
   +---------------------+--------------------------+
   | Header Field Name   | Defined in...            |
   +---------------------+--------------------------+
   | If-Match            | Section 3.1 of [RFC7232] |
   | If-None-Match       | Section 3.2 of [RFC7232] |
   | If-Modified-Since   | Section 3.3 of [RFC7232] |
   | If-Unmodified-Since | Section 3.4 of [RFC7232] |
   | If-Range            | Section 3.2 of [RFC7233] |
   +---------------------+--------------------------+
```

---
### **5.3.  Content Negotiation**

다음 요청 헤더 필드는 섹션 3.4.1에 정의된 대로 응답 콘텐츠의 사전 협상에 참여하기 위해 사용자 에이전트에 의해 전송됩니다. 이러한 필드에 전송된 기본 설정은 대상 리소스 표현, 오류 또는 처리 상태 표현, 심지어 프로토콜 내에 나타날 수 있는 기타 텍스트 문자열까지 포함하여 응답의 모든 콘텐츠에 적용됩니다.

```text
   +-------------------+---------------+
   | Header Field Name | Defined in... |
   +-------------------+---------------+
   | Accept            | Section 5.3.2 |
   | Accept-Charset    | Section 5.3.3 |
   | Accept-Encoding   | Section 5.3.4 |
   | Accept-Language   | Section 5.3.5 |
   +-------------------+---------------+
```

---
#### **5.3.1.  Quality Values**

사전 협상을 위한 많은 요청 헤더 필드는 "q"\(대소문자 구분 안 함\)라는 공통 매개변수를 사용하여 관련 콘텐츠 종류에 대한 선호도에 상대적인 "가중치"를 할당합니다. 이 가중치를 "품질 값"\(또는 "qvalue"\)이라고 합니다. 리소스에 대해 선택할 수 있는 다양한 표현의 상대적 품질에 가중치를 할당하기 위해 서버 구성 내에서 동일한 매개변수 이름이 자주 사용되기 때문입니다.

가중치는 0\~1 범위의 실수로 정규화됩니다. 여기서 0.001은 가장 선호되지 않고 1은 가장 선호됩니다. 값 0은 "허용되지 않음"을 의미합니다. "q" 매개변수가 없으면 기본 가중치는 1입니다.

```text
     weight = OWS ";" OWS "q=" qvalue
     qvalue = ( "0" [ "." 0*3DIGIT ] )
            / ( "1" [ "." 0*3("0") ] )
```

qvalue의 발신자는 소수점 이하 3자리 이상을 생성해서는 안 됩니다. 이러한 값의 사용자 구성은 동일한 방식으로 제한되어야 합니다.\(MUST NOT\)

---
#### **5.3.2.  Accept**

"Accept" 헤더 필드는 사용자 에이전트가 허용 가능한 응답 미디어 유형을 지정하는 데 사용할 수 있습니다. Accept 헤더 필드는 인라인 이미지에 대한 요청의 경우처럼 요청이 원하는 유형의 작은 집합으로 구체적으로 제한된다는 것을 나타내는 데 사용될 수 있습니다.

```text
     Accept = #( media-range [ accept-params ] )

     media-range    = ( "*/*"
                      / ( type "/" "*" )
                      / ( type "/" subtype )
                      ) *( OWS ";" OWS parameter )
     accept-params  = weight *( accept-ext )
     accept-ext = OWS ";" OWS token [ "=" ( token / quoted-string ) ]
```

별표 "\*" 문자는 미디어 유형을 범위로 그룹화하는 데 사용됩니다. "\*/\*"는 모든 미디어 유형을 나타내고 "type/\*"은 해당 유형의 모든 하위 유형을 나타냅니다. 미디어 범위에는 해당 범위에 적용할 수 있는 미디어 유형 매개변수가 포함될 수 있습니다.

각 미디어 범위 뒤에는 0개 이상의 적용 가능한 미디어 유형 매개변수\(예: charset\), 상대적 가중치를 나타내는 선택적 "q" 매개변수\(섹션 5.3.1\), 0개 이상의 확장 매개변수가 올 수 있습니다. 확장명\(accept-ext\)이 있는 경우 "q" 매개변수가 필요합니다. 두 매개변수 세트 사이의 구분자 역할을 하기 때문입니다.

- 참고: 미디어 유형 매개변수와 확장 매개변수 승인을 구분하기 위해 "q" 매개변수 이름을 사용하는 것은 역사적 관행 때문입니다. 이렇게 하면 "q"라는 미디어 유형 매개변수가 미디어 범위와 함께 사용되는 것을 방지할 수 있지만 IANA에 "q" 매개변수가 없기 때문에 이러한 이벤트가 발생할 가능성은 거의 없습니다.

미디어 유형 레지스트리 및 모든 미디어 유형의 드문 사용

- Accept의 매개변수. 향후 미디어 유형에서는 "q"라는 매개변수를 등록하지 않는 것이 좋습니다.

예

```text
     Accept: audio/*; q=0.2, audio/basic
```

"나는 오디오/기본을 선호하지만 품질이 80% 인하된 후 사용할 수 있는 최고 오디오 유형이면 나에게 보내주십시오"로 해석됩니다.

Accept 헤더 필드가 없는 요청은 사용자 에이전트가 응답으로 모든 미디어 유형을 수락한다는 것을 의미합니다. 요청에 헤더 필드가 있고 응답에 사용 가능한 표현 중 허용되는 것으로 나열된 미디어 유형이 없는 경우 원본 서버는 406\(허용되지 않음\) 응답을 보내 헤더 필드를 존중하거나 헤더를 무시할 수 있습니다. 필드는 콘텐츠 협상 대상이 아닌 것처럼 응답을 처리합니다.

좀 더 정교한 예는 다음과 같습니다.

```text
     Accept: text/plain; q=0.5, text/html,
             text/x-dvi; q=0.8, text/x-c
```

구두로 말하면 "text/html 및 text/x-c는 똑같이 선호되는 미디어 유형이지만, 존재하지 않으면 text/x-dvi 표현을 보내고, 존재하지 않으면 text/를 보냅니다. 일반 표현".

미디어 범위는 보다 구체적인 미디어 범위나 특정 미디어 유형으로 재정의될 수 있습니다. 특정 유형에 둘 이상의 미디어 범위가 적용되는 경우 가장 구체적인 참조가 우선적으로 적용됩니다. 예를 들어,

```text
     Accept: text/*, text/plain, text/plain;format=flowed, */*
```

다음과 같은 우선순위를 갖습니다:

```text
   1.  text/plain;format=flowed

   2.  text/plain

   3.  text/*

   4.  */*
```

특정 유형과 관련된 미디어 유형 품질 요소는 해당 유형과 일치하는 우선순위가 가장 높은 미디어 범위를 찾아 결정됩니다. 예를 들어,

```text
     Accept: text/*;q=0.3, text/html;q=0.7, text/html;level=1,
             text/html;level=2;q=0.4, */*;q=0.5
```

다음 값이 연결됩니다.

```text
   +-------------------+---------------+
   | Media Type        | Quality Value |
   +-------------------+---------------+
   | text/html;level=1 | 1             |
   | text/html         | 0.7           |
   | text/plain        | 0.3           |
   | image/jpeg        | 0.5           |
   | text/html;level=2 | 0.4           |
   | text/html;level=3 | 0.7           |
   +-------------------+---------------+
```

참고: 사용자 에이전트에는 특정 미디어 범위에 대한 기본 품질 값 세트가 제공될 수 있습니다. 그러나 사용자 에이전트가 다른 렌더링 에이전트와 상호 작용할 수 없는 폐쇄형 시스템이 아닌 이상 이 기본 설정은 사용자가 구성할 수 있어야 합니다.

---
#### **5.3.3.  Accept-Charset**

"Accept-Charset" 헤더 필드는 텍스트 응답 콘텐츠에서 허용되는 문자 세트를 나타내기 위해 사용자 에이전트에 의해 전송될 수 있습니다. 이 필드를 사용하면 보다 포괄적이거나 특수 목적의 문자 집합을 이해할 수 있는 사용자 에이전트가 해당 문자 집합의 정보를 표현할 수 있는 원본 서버에 해당 기능을 알릴 수 있습니다.

```text
     Accept-Charset = 1#( ( charset / "*" ) [ weight ] )
```

문자 집합 이름은 섹션 3.1.1.2에 정의되어 있습니다. 사용자 에이전트는 섹션 5.3.1에 정의된 대로 해당 문자 세트에 대한 사용자의 상대적 선호도를 나타내기 위해 품질 값을 각 문자 세트와 연관시킬 수 있습니다. 예는 다음과 같습니다\(MAY\)

```text
     Accept-Charset: iso-8859-5, unicode-1-1;q=0.8
```

Accept-Charset 필드에 있는 특수 값 "\*"는 Accept-Charset 필드의 다른 곳에서 언급되지 않은 모든 문자 세트와 일치합니다. Accept-Charset 필드에 "\*"가 없으면 필드에 명시적으로 언급되지 않은 모든 문자 세트는 클라이언트에 "허용되지 않는" 것으로 간주됩니다.

Accept-Charset 헤더 필드가 없는 요청은 사용자 에이전트가 응답으로 모든 문자 세트를 수락한다는 것을 의미합니다. 대부분의 범용 사용자 에이전트는 특별히 명시하지 않는 한 Accept-Charset을 보내지 않습니다.

지원되는 문자 집합의 자세한 목록을 사용하면 서버가 사용자 에이전트의 요청 특성\(섹션 9.7\)을 통해 개인을 더 쉽게 식별할 수 있기 때문에 그렇게 하도록 구성되었습니다.

요청에 Accept-Charset 헤더 필드가 있고 응답에 사용 가능한 표현 중 허용 가능한 것으로 나열된 문자 세트가 없는 경우 원본 서버는 406\(허용되지 않음\) 응답을 보내 헤더 필드를 수락할 수 있습니다. 또는 리소스가 콘텐츠 협상 대상이 아닌 것처럼 처리하여 헤더 필드를 무시합니다.

---
#### **5.3.4.  Accept-Encoding**

"Accept-Encoding" 헤더 필드는 응답에서 허용되는 응답 콘텐츠 코딩\(섹션 3.1.2.1\)을 나타내기 위해 사용자 에이전트에서 사용할 수 있습니다. "ID" 토큰은 인코딩이 선호되지 않는 경우 통신하기 위해 "인코딩 없음"의 동의어로 사용됩니다.

```text
     Accept-Encoding  = #( codings [ weight ] )
     codings          = content-coding / "identity" / "*"
```

각 코딩 값에는 섹션 5.3.1에 정의된 대로 해당 인코딩에 대한 선호도를 나타내는 관련 품질 값이 제공될 수 있습니다. Accept-Encoding 필드의 별표 "\*" 기호는 헤더 필드에 명시적으로 나열되지 않은 사용 가능한 콘텐츠 코딩과 일치합니다.\(MAY\)

예를 들어,

```text
     Accept-Encoding: compress, gzip
     Accept-Encoding:
     Accept-Encoding: *
     Accept-Encoding: compress;q=0.5, gzip;q=1.0
     Accept-Encoding: gzip;q=1.0, identity; q=0.5, *;q=0
```

Accept-Encoding 헤더 필드가 없는 요청은 사용자 에이전트에 콘텐츠 코딩과 관련된 기본 설정이 없음을 의미합니다. 이를 통해 서버는 응답에서 모든 콘텐츠 코딩을 사용할 수 있지만 사용자 에이전트가 모든 인코딩을 올바르게 처리할 수 있다는 의미는 아닙니다.

서버는 다음 규칙을 사용하여 주어진 표현에 대한 콘텐츠 코딩이 허용되는지 여부를 테스트합니다.

1. 요청에 Accept-Encoding 필드가 없으면 사용자 에이전트는 모든 콘텐츠 코딩을 허용하는 것으로 간주합니다.

2. 표현에 콘텐츠 코딩이 없으면

- "identity"에 대한 보다 구체적인 항목 없이 "identity;q=0" 또는 "\*;q=0"을 나타내는 Accept-Encoding 필드에 의해 특별히 제외되지 않는 한 기본적으로 허용됩니다.

3. 표현의 콘텐츠 코딩이 다음 중 하나인 경우

- Accept-Encoding 필드에 나열된 콘텐츠 코딩인 경우 qvalue 0이 동반되지 않는 한 허용됩니다. \(섹션 5.3.1에 정의된 대로 qvalue 0은 "허용되지 않음"을 의미합니다.\)

4. 여러 콘텐츠 코딩이 허용되는 경우 0이 아닌 가장 높은 q값을 가진 허용 가능한 콘텐츠 코딩이 선호됩니다.

비어 있는 결합된 필드 값이 있는 Accept-Encoding 헤더 필드는 사용자 에이전트가 응답으로 콘텐츠 코딩을 원하지 않음을 의미합니다. Accept-Encoding 헤더 필드가 요청에 존재하고 응답에 대해 사용 가능한 표현 중 어느 것도 허용 가능한 것으로 나열된 콘텐츠 코딩을 갖지 않는 경우, 원서버는 콘텐츠 코딩 없이 응답을 보내야 합니다\(SHOULD\).\(SHOULD\)

- 참고: 대부분의 HTTP/1.0 애플리케이션은 콘텐츠 코딩과 관련된 qvalue를 인식하거나 따르지 않습니다. 이는 qvalue가 작동하지 않을 수 있으며 x-gzip 또는 x-compress에서 허용되지 않음을 의미합니다.

---
#### **5.3.5.  Accept-Language**

"Accept-Language" 헤더 필드는 사용자 에이전트가 응답에서 선호하는 자연어 세트를 나타내는 데 사용할 수 있습니다. 언어 태그는 섹션 3.1.3.1에 정의되어 있습니다.

```text
     Accept-Language = 1#( language-range [ weight ] )
     language-range  =
               <language-range, see [RFC4647], Section 2.1>
```

각 언어 범위에는 섹션 5.3.1에 정의된 대로 해당 범위에 지정된 언어에 대한 사용자 선호도의 추정치를 나타내는 관련 품질 값이 제공될 수 있습니다. 예를 들어,

```text
     Accept-Language: da, en-gb;q=0.8, en;q=0.7
```

"나는 덴마크어를 선호하지만 영국식 영어와 다른 유형의 영어도 허용합니다"를 의미합니다.

Accept-Language 헤더 필드가 없는 요청은 사용자 에이전트가 응답으로 모든 언어를 수락한다는 것을 의미합니다. 헤더 필드가 요청에 존재하고 응답에 사용 가능한 표현 중 일치하는 언어 태그가 없는 경우 원서버는 응답을 마치 헤더 필드인 것처럼 처리하여 헤더 필드를 무시할 수 있습니다.

콘텐츠 협상이 적용되지 않거나 406\(허용되지 않음\) 응답을 전송하여 헤더 필드를 준수하지 않습니다. 그러나 후자는 권장되지 않습니다. 그렇게 하면 사용자가 사용할 수 있는 콘텐츠\(예: 번역 소프트웨어 사용\)에 액세스하지 못할 수 있기 때문입니다.

일부 수신자는 언어 태그가 나열되는 순서를 내림차순 우선순위 표시로 취급합니다. 특히 동일한 품질 값이 할당된 태그의 경우\(q=1과 동일한 값은 없습니다\). 그러나 이 동작은 신뢰할 수 없습니다. 일관성과 상호 운용성을 최대화하기 위해 많은 사용자 에이전트는 각 언어 태그에 고유한 품질 값을 할당하는 동시에 품질이 낮은 순서로 나열합니다. 언어 우선순위 목록에 대한 추가 논의는 \[RFC4647\]의 섹션 2.3에서 확인할 수 있습니다.

매칭을 위해 \[RFC4647\]의 섹션 3에서는 여러 매칭 방식을 정의합니다. 구현에서는 요구 사항에 가장 적합한 일치 방식을 제공할 수 있습니다. "기본 필터링" 체계\(\[RFC4647\], 섹션 3.3.1\)는 이전에 \[RFC2616\]의 섹션 14.4에서 HTTP에 대해 정의된 일치 체계와 동일합니다.

모든 요청에서 사용자의 완전한 언어 기본 설정과 함께 Accept-Language 헤더 필드를 보내는 것은 사용자의 개인 정보 보호 기대에 어긋날 수 있습니다\(섹션 9.7\).

명료성은 개별 사용자에 따라 크게 달라지기 때문에 사용자 에이전트는 언어 선호도에 대한 사용자 제어를 허용해야 합니다\(사용자 에이전트 자체 구성을 통해 또는 사용자가 제어할 수 있는 시스템 설정을 기본값으로 설정하여\). 사용자에게 이러한 제어를 제공하지 않는 사용자 에이전트는 Accept-Language 헤더 필드를 보내서는 안 됩니다.\(MUST NOT\)

- 참고: 사용자 에이전트는 기본 설정을 지정할 때 사용자에게 지침을 제공해야 합니다. 사용자는 위에 설명된 언어 매칭의 세부 사항에 거의 익숙하지 않기 때문입니다. 예를 들어, 사용자는 "en-gb"를 선택하면 영국 영어를 사용할 수 없는 경우 모든 종류의 영어 문서가 제공될 것이라고 가정할 수 있습니다. 이러한 경우 사용자 에이전트는 더 나은 일치 동작을 위해 목록에 "en"을 추가하도록 제안할 수 있습니다.

---
### **5.4.  Authentication Credentials**

\[RFC7235\]에 정의된 대로 인증 자격 증명을 전달하는 데 두 개의 헤더 필드가 사용됩니다. 사용자 인증을 위한 다양한 사용자 정의 메커니즘은 \[RFC6265\]에 정의된 대로 쿠키 헤더 필드를 이 목적으로 사용합니다.

```text
   +---------------------+--------------------------+
   | Header Field Name   | Defined in...            |
   +---------------------+--------------------------+
   | Authorization       | Section 4.2 of [RFC7235] |
   | Proxy-Authorization | Section 4.4 of [RFC7235] |
   +---------------------+--------------------------+
```

---
### **5.5.  Request Context**

다음 요청 헤더 필드는 요청 뒤에 있는 사용자, 사용자 에이전트 및 리소스에 대한 정보를 포함하여 요청 컨텍스트에 대한 추가 정보를 제공합니다.

```text
   +-------------------+---------------+
   | Header Field Name | Defined in... |
   +-------------------+---------------+
   | From              | Section 5.5.1 |
   | Referer           | Section 5.5.2 |
   | User-Agent        | Section 5.5.3 |
   +-------------------+---------------+
```

---
#### **5.5.1.  From**

"From" 헤더 필드에는 요청하는 사용자 에이전트를 제어하는 ​​인간 사용자의 인터넷 이메일 주소가 포함되어 있습니다. 주소는 \[RFC5322\] 섹션 3.4의 "사서함"에 정의된 대로 컴퓨터에서 사용할 수 있어야 합니다.

```text
     From    = mailbox

     mailbox = <mailbox, see [RFC5322], Section 3.4>
```

예는 다음과 같습니다:

```text
     From: webmaster@example.org
```

From 헤더 필드는 로봇이 아닌 사용자 에이전트에서는 거의 전송되지 않습니다. 사용자 에이전트는 사용자의 명시적인 구성 없이 From 헤더 필드를 전송해서는 안 됩니다. 이는 사용자의 개인 정보 보호 이익이나 해당 사이트의 보안 정책과 충돌할 수 있기 때문입니다.\(SHOULD NOT\)

로봇 사용자 에이전트는 로봇이 과도하거나 원치 않거나 유효하지 않은 요청을 보내는 경우와 같이 서버에서 문제가 발생하는 경우 로봇 실행 담당자에게 연락할 수 있도록 유효한 From 헤더 필드를 보내야 합니다.\(SHOULD\)

서버는 액세스 제어 또는 인증을 위해 From 헤더 필드를 사용해서는 안 됩니다. 왜냐하면 대부분의 수신자는 필드 값이 공개 정보라고 가정하기 때문입니다.\(SHOULD NOT\)

---
#### **5.5.2.  Referer**

"Referer" \[sic\] 헤더 필드를 사용하면 사용자 에이전트는 대상 URI를 얻은 리소스에 대한 URI 참조를 지정할 수 있습니다\(즉, 필드 이름의 철자가 틀리더라도 "referrer"\). 사용자 에이전트는 Referer 필드 값을 생성할 때 URI 참조 \[RFC3986\]의 조각 및 userinfo 구성 요소를 포함해서는 안 됩니다\(MUST NOT\).\(MUST NOT\)

```text
     Referer = absolute-URI / partial-URI
```

Referer 헤더 필드를 사용하면 서버가 간단한 분석, 로깅, 최적화된 캐싱 등을 위해 다른 리소스에 대한 백링크를 생성할 수 있습니다. 또한 유지 관리를 위해 더 이상 사용되지 않거나 잘못 입력된 링크를 찾을 수 있습니다. 일부 서버는 다른 사이트의 링크를 거부하거나\(소위 "딥 링크"\) 사이트 간 요청 위조\(CSRF\)를 제한하는 수단으로 Referer 헤더 필드를 사용하지만 모든 요청에 ​​이를 포함하는 것은 아닙니다.

```text
   Example:

     Referer: http://www.example.org/hypertext/Overview.html
```

대상 URI가 자체 URI\(예: 사용자 키보드의 입력 또는 사용자 북마크/즐겨찾기 내의 항목\)가 없는 소스에서 획득된 경우 사용자 에이전트는 반드시 Referer 필드를 제외하거나 "about:blank" 값입니다.\(MUST\)

Referer 필드에는 사용자의 요청 컨텍스트 또는 검색 기록에 대한 정보가 공개될 가능성이 있습니다. 이는 참조 리소스의 식별자가 개인 정보\(예: 계정 이름\) 또는 기밀로 간주되는 리소스를 공개하는 경우 개인정보 보호 문제가 될 수 있습니다\( 예를 들어 방화벽 뒤 또는 보안 서비스 내부\). 대부분의 범용 사용자 에이전트는 참조 리소스가 로컬 "파일" 또는 "데이터" URI인 경우 Referer 헤더 필드를 보내지 않습니다. 사용자 에이전트는 참조 페이지가 보안 프로토콜로 수신된 경우 보안되지 않은 HTTP 요청에서 Referer 헤더 필드를 보내서는 안 됩니다. 추가 보안 고려 사항은 섹션 9.4를 참조하세요.\(MUST NOT\)

일부 중개자는 나가는 요청에서 Referer 헤더 필드를 무차별적으로 제거하는 것으로 알려져 있습니다. 이는 CSRF 공격에 대한 보호를 방해하는 불행한 부작용을 가져오며, 이는 사용자에게 훨씬 더 해로울 수 있습니다. Referer의 정보 공개를 제한하려는 중개자 및 사용자 에이전트 확장은 내부 도메인 이름을 가명으로 바꾸거나 쿼리 및/또는 경로 구성 요소를 자르는 등 특정 편집으로 변경을 제한해야 합니다. 필드 값이 요청 대상과 동일한 체계 및 호스트를 공유하는 경우 중개자는 Referer 헤더 필드를 수정하거나 삭제해서는 안 됩니다.\(SHOULD NOT\)

---
#### **5.5.3.  User-Agent**

"User-Agent" 헤더 필드에는 요청을 시작한 사용자 에이전트에 대한 정보가 포함되어 있습니다. 이 정보는 보고된 상호 운용성 문제의 범위를 식별하는 데 도움을 주고, 특정 사용자 에이전트 제한을 피하기 위해 응답을 조정하거나 해결하고, 분석을 위해 서버에서 자주 사용됩니다. 브라우저 또는 운영 체제 사용과 관련하여. 사용자 에이전트는 특별히 그렇게 하지 않도록 구성하지 않는 한 각 요청에 User-Agent 필드를 보내야 합니다\(SHOULD\).\(SHOULD\)

```text
     User-Agent = product *( RWS ( product / comment ) )
```

User-Agent 필드 값은 하나 이상의 제품 식별자로 구성되며, 각각 뒤에는 0개 이상의 주석\(\[RFC7230\] 섹션 3.2\)이 따르며, 이는 함께 사용자 에이전트 소프트웨어와 그 중요한 하위 제품을 식별합니다. 관례적으로 제품 식별자는 사용자 에이전트 소프트웨어를 식별하는 중요성의 내림차순으로 나열됩니다. 각 제품 식별자는 이름과 선택적 버전으로 구성됩니다.

```text
     product         = token ["/" product-version]
     product-version = token
```

발신자는 생성된 제품 식별자를 제품을 식별하는 데 필요한 것으로 제한해야 합니다. 발신자는 제품 식별자 내에 광고 또는 기타 중요하지 않은 정보를 생성해서는 안 됩니다. 발신자는 버전 식별자가 아닌 제품 버전에서 정보를 생성해서는 안 됩니다\(즉, 동일한 제품 이름의 연속 버전은 제품 식별자의 제품 버전 부분에서만 달라야 합니다\).\(MUST NOT, SHOULD NOT\)

```text
   Example:

     User-Agent: CERN-LineMode/2.15 libwww/2.17b3
```

사용자 에이전트는 불필요하게 세분화된 세부정보가 포함된 User-Agent 필드를 생성해서는 안 되며 제3자가 하위 제품을 추가하는 것을 제한해야 합니다. 지나치게 길고 상세한 User-Agent 필드 값은 요청 대기 시간을 증가시키고 사용자가 원하는 대로 사용자가 식별될 위험\("지문 인식"\)을 나타냅니다.\(SHOULD NOT\)

마찬가지로 구현에서는 호환성을 선언하기 위해 다른 구현의 제품 토큰을 사용하지 않는 것이 좋습니다. 이는 필드의 목적을 우회하기 때문입니다. 사용자 에이전트가 다른 사용자 에이전트로 가장하는 경우 수신자는 사용 중인 실제 사용자 에이전트에 대해 제대로 작동하지 않더라도 사용자가 식별된 사용자 에이전트에 맞게 조정된 응답을 의도적으로 보고 싶어한다고 가정할 수 있습니다.

---
## **6.  Response Status Codes**

상태 코드 요소는 요청을 이해하고 만족시키려는 시도의 결과를 제공하는 3자리 정수 코드입니다.

HTTP 상태 코드는 확장 가능합니다. HTTP 클라이언트는 등록된 모든 상태 코드의 의미를 이해할 필요는 없지만, 그러한 이해는 분명히 바람직합니다. 그러나 클라이언트는 첫 번째 숫자로 표시된 모든 상태 코드의 클래스를 이해해야 하며, 인식할 수 없는 상태 코드를 해당 클래스의 x00 상태 코드와 동일한 것으로 처리해야 합니다. 단, 수신자는 다음과 같은 응답을 캐시하면 안 됩니다. 인식할 수 없는 상태 코드입니다.\(MUST NOT\)

예를 들어 클라이언트가 인식할 수 없는 상태 코드 471을 수신하면 클라이언트는 요청에 문제가 있다고 가정하고 응답을 400\(잘못된 요청\) 상태 코드를 받은 것처럼 처리할 수 있습니다. 응답 메시지에는 일반적으로 상태를 설명하는 표현이 포함됩니다.

상태 코드의 첫 번째 숫자는 응답 클래스를 정의합니다. 마지막 두 자리에는 분류 역할이 없습니다. 첫 번째 숫자에는 5개의 값이 있습니다.

o 1xx\(정보\): 요청이 수신되었으며 프로세스가 계속됩니다.

o 2xx\(성공\): 요청이 성공적으로 수신되었습니다.

- 이해하고 받아들인다.

o 3xx\(리디렉션\): 요청을 완료하려면 추가 조치를 취해야 합니다.

o 4xx\(클라이언트 오류\): 요청에 잘못된 구문이 포함되어 있거나 처리할 수 없습니다.

o 5xx\(서버 오류\): 서버가 명백히 유효한 요청을 이행하지 못했습니다.

---
### **6.1.  Overview of Status Codes**

아래 나열된 상태 코드는 본 사양, \[RFC7232\]의 섹션 4, \[RFC7233\]의 섹션 4 및 \[RFC7235\]의 섹션 3에 정의되어 있습니다. 여기에 나열된 이유 문구는 권장 사항일 뿐이며 프로토콜에 영향을 주지 않고 해당 지역의 문구로 대체될 수 있습니다.

기본적으로 캐시 가능으로 정의된 상태 코드\(예: 이 사양에서는 200, 203, 204, 206, 300, 301, 404, 405, 410, 414 및 501\)가 있는 응답은 경험적 만료가 있는 캐시에서 재사용될 수 있습니다. 그렇지 않으면 메서드 정의 또는 명시적 캐시 제어 \[RFC7234\]로 표시됩니다. 다른 모든 상태 코드는 기본적으로 캐시할 수 없습니다.

```text
   +------+-------------------------------+--------------------------+
   | Code | Reason-Phrase                 | Defined in...            |
   +------+-------------------------------+--------------------------+
   | 100  | Continue                      | Section 6.2.1            |
   | 101  | Switching Protocols           | Section 6.2.2            |
   | 200  | OK                            | Section 6.3.1            |
   | 201  | Created                       | Section 6.3.2            |
   | 202  | Accepted                      | Section 6.3.3            |
   | 203  | Non-Authoritative Information | Section 6.3.4            |
   | 204  | No Content                    | Section 6.3.5            |
   | 205  | Reset Content                 | Section 6.3.6            |
   | 206  | Partial Content               | Section 4.1 of [RFC7233] |
   | 300  | Multiple Choices              | Section 6.4.1            |
   | 301  | Moved Permanently             | Section 6.4.2            |
   | 302  | Found                         | Section 6.4.3            |
   | 303  | See Other                     | Section 6.4.4            |
   | 304  | Not Modified                  | Section 4.1 of [RFC7232] |
   | 305  | Use Proxy                     | Section 6.4.5            |
   | 307  | Temporary Redirect            | Section 6.4.7            |
   | 400  | Bad Request                   | Section 6.5.1            |
   | 401  | Unauthorized                  | Section 3.1 of [RFC7235] |
   | 402  | Payment Required              | Section 6.5.2            |
   | 403  | Forbidden                     | Section 6.5.3            |
   | 404  | Not Found                     | Section 6.5.4            |
   | 405  | Method Not Allowed            | Section 6.5.5            |
   | 406  | Not Acceptable                | Section 6.5.6            |
   | 407  | Proxy Authentication Required | Section 3.2 of [RFC7235] |
   | 408  | Request Timeout               | Section 6.5.7            |
   | 409  | Conflict                      | Section 6.5.8            |
   | 410  | Gone                          | Section 6.5.9            |
   | 411  | Length Required               | Section 6.5.10           |
   | 412  | Precondition Failed           | Section 4.2 of [RFC7232] |
   | 413  | Payload Too Large             | Section 6.5.11           |
   | 414  | URI Too Long                  | Section 6.5.12           |
   | 415  | Unsupported Media Type        | Section 6.5.13           |
   | 416  | Range Not Satisfiable         | Section 4.4 of [RFC7233] |
   | 417  | Expectation Failed            | Section 6.5.14           |
   | 426  | Upgrade Required              | Section 6.5.15           |
   | 500  | Internal Server Error         | Section 6.6.1            |
   | 501  | Not Implemented               | Section 6.6.2            |
   | 502  | Bad Gateway                   | Section 6.6.3            |
   | 503  | Service Unavailable           | Section 6.6.4            |
   | 504  | Gateway Timeout               | Section 6.6.5            |
   | 505  | HTTP Version Not Supported    | Section 6.6.6            |
   +------+-------------------------------+--------------------------+
```

이 목록은 완전한 것이 아닙니다. 다른 사양에 정의된 확장 상태 코드는 포함되지 않습니다. 상태 코드의 전체 목록은 IANA에서 관리합니다. 자세한 내용은 섹션 8.2를 참조하세요.

---
### **6.2.  Informational 1xx**

상태 코드의 1xx\(정보\) 클래스는 요청된 작업을 완료하고 최종 응답을 보내기 전에 연결 상태 또는 요청 진행 상황을 전달하기 위한 임시 응답을 나타냅니다. 1xx 응답은 상태 줄\(헤더 섹션의 끝을 알리는 빈 줄\) 뒤의 첫 번째 빈 줄로 종료됩니다. HTTP/1.0은 1xx 상태 코드를 정의하지 않았으므로 서버는 HTTP/1.0 클라이언트에 1xx 응답을 보내서는 안 됩니다.\(MUST NOT\)

클라이언트는 최종 응답을 기대하지 않더라도 최종 응답 이전에 수신된 하나 이상의 1xx 응답을 구문 분석할 수 있어야 합니다. 사용자 에이전트는 예상치 못한 1xx 응답을 무시할 수 있습니다.\(MUST, MAY\)

프록시 자체가 1xx 응답 생성을 요청하지 않는 한 프록시는 1xx 응답을 전달해야 합니다. 예를 들어 프록시가 요청을 전달할 때 "Expect: 100-continue" 필드를 추가하면 해당 100\(Continue\) 응답을 전달할 필요가 없습니다.\(MUST\)

---
#### **6.2.1.  100 Continue**

100\(계속\) 상태 코드는 요청의 초기 부분이 수신되었으며 서버에서 아직 거부되지 않았음을 나타냅니다. 서버는 요청이 완전히 수신되어 조치를 취한 후에 최종 응답을 보내려고 합니다.

요청에 100-continue 기대치를 포함하는 Expect 헤더 필드가 포함되어 있는 경우, 100 응답은 섹션 5.1.1에 설명된 대로 서버가 요청 페이로드 본문을 수신하기를 원한다는 것을 나타냅니다. 클라이언트는 요청을 계속 보내고 100 응답을 삭제해야 합니다.

요청에 100-continue 기대치를 포함하는 Expect 헤더 필드가 포함되어 있지 않은 경우 클라이언트는 이 임시 응답을 간단히 삭제할 수 있습니다.

---
#### **6.2.2.  101 Switching Protocols**

101\(스위칭 프로토콜\) 상태 코드는 서버가 업그레이드 헤더 필드\(\[RFC7230\]의 섹션 6.7\)를 통해 이 연결에서 사용되는 애플리케이션 프로토콜의 변경을 이해하고 클라이언트의 요청을 준수할 의사가 있음을 나타냅니다. 서버

101 응답을 종료하는 빈 줄 바로 뒤에 어떤 프로토콜로 전환될 것인지를 나타내는 응답에서 업그레이드 헤더 필드를 생성해야 합니다\(MUST\).\(MUST\)

서버는 프로토콜 전환이 유리한 경우에만 프로토콜 전환에 동의한다고 가정합니다. 예를 들어, 최신 버전의 HTTP로 전환하는 것은 이전 버전보다 유리할 수 있으며, 실시간 동기 프로토콜로 전환하는 것은 이러한 기능을 사용하는 리소스를 전달할 때 유리할 수 있습니다.

---
### **6.3.  Successful 2xx**

상태 코드의 2xx\(성공\) 클래스는 클라이언트의 요청이 성공적으로 수신, 이해 및 승인되었음을 나타냅니다.

---
#### **6.3.1.  200 OK**

200\(OK\) 상태 코드는 요청이 성공했음을 나타냅니다. 200 응답으로 전송되는 페이로드는 요청 방법에 따라 다릅니다. 이 사양에 정의된 메서드의 경우 페이로드의 의도된 의미는 다음과 같이 요약될 수 있습니다.

```text
   GET  a representation of the target resource;

   HEAD  the same representation as GET, but without the representation
      data;

   POST  a representation of the status of, or results obtained from,
      the action;

   PUT, DELETE  a representation of the status of the action;

   OPTIONS  a representation of the communications options;
```

최종 서버가 수신한 요청 메시지의 표현을 추적합니다.

CONNECT에 대한 응답 외에도 200 응답에는 항상 페이로드가 있지만 원본 서버는 길이가 0인 페이로드 본문을 생성할 수 있습니다. 페이로드가 필요하지 않은 경우 원본 서버는 대신 204\(콘텐츠 없음\)를 보내야 합니다. CONNECT의 경우 성공적인 결과는 200 응답 헤더 섹션 바로 다음에 시작되는 터널이므로 페이로드가 허용되지 않습니다.\(MAY\)

200 응답은 기본적으로 캐시 가능합니다. 즉, 메서드 정의나 명시적 캐시 제어로 달리 지정되지 않는 한\(\[RFC7234\]의 섹션 4.2.2 참조\)

---
#### **6.3.2.  201 Created**

201\(생성됨\) 상태 코드는 요청이 이행되어 하나 이상의 새 리소스가 생성되었음을 나타냅니다. 요청에 의해 생성된 기본 리소스는 응답의 Location 헤더 필드로 식별되거나 Location 필드가 수신되지 않은 경우 유효한 요청 URI로 식별됩니다.

201 응답 페이로드는 일반적으로 생성된 리소스를 설명하고 이에 대한 링크를 제공합니다. 201 응답에서 ETag 및 Last-Modified와 같은 유효성 검사기 헤더 필드의 의미와 목적에 대한 논의는 섹션 7.2를 참조하세요.

---
#### **6.3.3.  202 Accepted**

202\(수락됨\) 상태 코드는 요청 처리가 승인되었지만 처리가 완료되지 않았음을 나타냅니다. 요청이 실제로 처리될 때 허용되지 않을 수 있으므로 결국에는 요청이 실행될 수도 있고 실행되지 않을 수도 있습니다. HTTP에는 비동기 작업에서 상태 코드를 다시 보내는 기능이 없습니다.

202 응답은 의도적으로 비커밋입니다. 그 목적은 프로세스가 완료될 때까지 서버에 대한 사용자 에이전트의 연결이 지속될 필요 없이 서버가 다른 프로세스\(아마도 하루에 한 번만 실행되는 배치 지향 프로세스\)에 대한 요청을 수락할 수 있도록 하는 것입니다. 이 응답과 함께 전송된 표현은 요청의 현재 상태를 설명하고 사용자에게 요청이 언제 이행될지에 대한 추정치를 제공할 수 있는 상태 모니터를 가리켜야 합니다\(또는 포함해야 합니다\).

---
#### **6.3.4.  203 Non-Authoritative Information**

203\(Non-Authoritative Information\) 상태 코드는 요청이 성공했지만 포함된 페이로드가 변환 프록시\(\[RFC7230\]의 섹션 5.7.2\)에 의해 원본 서버의 200\(OK\) 응답의 페이로드에서 수정되었음을 나타냅니다. 이 상태 코드를 사용하면 변환이 적용되었을 때 프록시가 수신자에게 알릴 수 있습니다. 해당 지식이 콘텐츠에 관한 이후 결정에 영향을 미칠 수 있기 때문입니다. 예를 들어, 콘텐츠에 대한 향후 캐시 유효성 검사 요청은 동일한 요청 경로\(동일한 프록시를 통해\)를 통해서만 적용될 수 있습니다.

203 응답은 214 변환 적용 경고 코드\(\[RFC7234\]의 섹션 5.5\)와 유사하며, 이는 모든 상태 코드의 응답에 적용할 수 있다는 장점이 있습니다.

203 응답은 기본적으로 캐시 가능합니다. 즉, 메서드 정의나 명시적 캐시 제어로 달리 지정되지 않는 한\(\[RFC7234\]의 섹션 4.2.2 참조\)

---
#### **6.3.5.  204 No Content**

204\(콘텐츠 없음\) 상태 코드는 서버가 요청을 성공적으로 이행했으며 응답 페이로드 본문에 보낼 추가 콘텐츠가 없음을 나타냅니다. 응답 헤더 필드의 메타데이터는 요청된 작업이 적용된 후 대상 리소스와 선택한 표현을 참조합니다.

예를 들어, PUT 요청에 대한 응답으로 204 상태 코드가 수신되고 응답에 ETag 헤더 필드가 포함된 경우 PUT가 성공한 것이며 ETag 필드 값에는 해당 대상 리소스의 새 표현에 대한 엔터티 태그가 포함됩니다.

204 응답을 통해 서버는 작업이 대상 리소스에 성공적으로 적용되었음을 나타내는 동시에 사용자 에이전트가 현재 "문서 보기"\(있는 경우\)에서 벗어날 필요가 없음을 암시합니다. 서버는 사용자 에이전트가 자체 인터페이스에 따라 사용자에게 성공에 대한 일부 표시를 제공하고 활성 표현에 대한 응답으로 새 메타데이터나 업데이트된 메타데이터를 적용한다고 가정합니다.

예를 들어, 204 상태 코드는 "저장" 작업에 해당하는 문서 편집 인터페이스에서 일반적으로 사용됩니다. 따라서 저장되는 문서는 사용자가 편집할 수 있는 상태로 유지됩니다. 또한 분산 버전 제어 시스템 내에서와 같이 자동화된 데이터 전송이 널리 보급될 것으로 예상되는 인터페이스와 함께 자주 사용됩니다.

204 응답은 메시지 본문을 포함할 수 없기 때문에 헤더 필드 뒤의 첫 번째 빈 줄로 종료됩니다.

204 응답은 기본적으로 캐시 가능합니다. 즉, 메서드 정의나 명시적 캐시 제어로 달리 지정되지 않는 한\(\[RFC7234\]의 섹션 4.2.2 참조\)

---
#### **6.3.6.  205 Reset Content**

205\(콘텐츠 재설정\) 상태 코드는 서버가 요청을 이행했으며 사용자 에이전트가 요청을 전송하게 만든 "문서 보기"를 원본 서버에서 수신한 원래 상태로 재설정하기를 원한다는 것을 나타냅니다.

이 응답은 사용자가 데이터 입력을 지원하는 콘텐츠\(양식, 메모장, 캔버스 등\)를 수신하고 해당 공간에 데이터를 입력하거나 조작하는 일반적인 데이터 입력 사용 사례를 지원하기 위한 것입니다.

입력된 데이터가 요청에 제출되도록 한 다음 사용자가 다른 입력 작업을 쉽게 시작할 수 있도록 다음 입력에 대해 데이터 입력 메커니즘이 재설정됩니다.

205 상태 코드는 추가 콘텐츠가 제공되지 않음을 의미하므로 서버는 205 응답에서 페이로드를 생성해서는 안 됩니다. 즉, 서버는 205 응답에 대해 다음 중 하나를 수행해야 합니다. a\) 값이 0인 Content-Length 헤더 필드를 포함하여 응답에 대한 길이가 0인 본문을 나타냅니다. b\) 청크 값을 갖는 Transfer-Encoding 헤더 필드와 길이가 0인 단일 청크로 구성된 메시지 본문을 포함하여 응답에 대한 길이가 0인 페이로드를 나타냅니다. 또는 c\) 헤더 섹션을 종료하는 빈 줄을 보낸 후 즉시 연결을 닫습니다.\(MUST NOT, MUST\)

---
### **6.4.  Redirection 3xx**

상태 코드의 3xx\(리디렉션\) 클래스는 요청을 이행하기 위해 사용자 에이전트가 추가 조치를 취해야 함을 나타냅니다. Location 헤더 필드\(Section 7.1.2\)가 제공되면 사용자 에이전트는 특정 상태 코드가 이해되지 않는 경우에도 Location 필드 값이 참조하는 URI로 요청을 자동으로 리디렉션할 수 있습니다. 사용자가 안전하지 않은 요청을 리디렉션하기를 원하지 않을 수 있으므로 섹션 4.2.1에 정의된 대로 안전하지 않은 것으로 알려진 방법에 대해 자동 리디렉션을 주의해서 수행해야 합니다.\(MAY\)

리디렉션에는 여러 유형이 있습니다.

1. 상태 코드 301\(영구적으로 이동됨\), 302\(발견\) 및 307\(임시 리디렉션\)에서와 같이 위치 필드에서 제공하는 대로 리소스가 다른 URI에서 사용 가능함을 나타내는 리디렉션입니다.

2. 300\(다중 선택\) 상태 코드에서와 같이 각각 원래 요청 대상을 나타낼 수 있는 일치하는 리소스에 대한 선택을 제공하는 리디렉션입니다.

3. 303\(기타 참조\) 상태 코드와 같이 요청에 대한 간접적인 응답을 나타낼 수 있는 위치 필드로 식별되는 다른 리소스로 리디렉션합니다.

4. 304\(수정되지 않음\) 상태 코드와 같이 이전에 캐시된 결과로 리디렉션됩니다.

- 참고: HTTP/1.0에서는 첫 번째 유형의 리디렉션에 대해 상태 코드 301\(영구적으로 이동됨\) 및 302\(발견\)가 정의되었습니다\(\[RFC1945\], 섹션 9.3\). 초기 사용자 에이전트는 리디렉션 대상에 적용되는 방법이 동일한지 여부에 따라 분할됩니다.

- 원래 요청이거나 GET으로 다시 작성됩니다. HTTP는 원래 301 및 302\(CERN의 원래 구현과 일치하기 위해\)에 대한 전자 의미 체계를 정의하고 후자 의미 체계와 일치하기 위해 303\(기타 참조\)을 정의했지만, 일반적인 관행은 점차적으로 301 및 302에 대한 후자 의미 체계로 수렴되었습니다. HTTP/1.1의 첫 번째 개정판에는 다양한 관행의 영향을 받지 않고 이전 의미를 나타내기 위해 307\(임시 리디렉션\)이 추가되었습니다. 10년이 지난 후에도 대부분의 사용자 에이전트는 여전히 301 및 302에 대한 메소드 재작성을 수행합니다. 따라서 이 사양은 원래 요청이 POST일 때 해당 동작을 준수하도록 만듭니다.

클라이언트는 주기적 리디렉션\(즉, "무한" 리디렉션 루프\)을 감지하고 개입해야 합니다.\(SHOULD\)

- 참고: 이 사양의 이전 버전에서는 최대 5개의 리디렉션을 권장했습니다\(\[RFC2068\], 섹션 10.3\). 콘텐츠 개발자는 일부 클라이언트가 이러한 고정된 제한을 구현할 수 있다는 점을 알고 있어야 합니다.

---
#### **6.4.1.  300 Multiple Choices**

300\(다중 선택\) 상태 코드는 대상 리소스에 각각 고유한 보다 구체적인 식별자가 있는 둘 이상의 표현이 있고 대안에 대한 정보가 제공되어 사용자\(또는 사용자 에이전트\)가 다음을 통해 선호하는 표현을 선택할 수 있음을 나타냅니다. 요청을 해당 식별자 중 하나 이상으로 리디렉션합니다. 즉, 서버는 사용자 에이전트가 필요에 가장 적합한 표현을 선택하기 위해 반응적 협상에 참여하기를 원합니다\(섹션 3.4\).

서버가 선호하는 선택을 갖고 있는 경우, 서버는 선호하는 선택의 URI 참조를 포함하는 Location 헤더 필드를 생성해야 합니다\(SHOULD\). 사용자 에이전트는 자동 리디렉션을 위해 위치 필드 값을 사용할 수 있습니다.\(SHOULD, MAY\)

HEAD 이외의 요청 방법의 경우 서버는 사용자 또는 사용자 에이전트가 가장 선호하는 것을 선택할 수 있는 표현 메타데이터 및 URI 참조 목록을 포함하는 300 응답에서 페이로드를 생성해야 합니다\(SHOULD\). 사용자 에이전트는 제공된 미디어 유형을 이해하는 경우 해당 목록에서 자동으로 선택할 수 있습니다. HTTP는 페이로드 정의와 직교를 유지하려고 하기 때문에 자동 선택을 위한 특정 형식은 이 사양에서 정의되지 않습니다. 실제로 표현은 공유 디자인이나 콘텐츠 협상에 의해 결정된 대로 사용자 에이전트가 허용할 수 있다고 생각되는 쉽게 구문 분석되는 형식이나 일반적으로 허용되는 일부 하이퍼텍스트 형식으로 제공됩니다.\(SHOULD, MAY\)

300 응답은 기본적으로 캐시 가능합니다. 즉, 메서드 정의나 명시적 캐시 제어로 달리 지정되지 않는 한\(\[RFC7234\]의 섹션 4.2.2 참조\)

- 참고: 300 상태 코드에 대한 원래 제안에서는 URI 헤더 필드를 200, 300 및 406 응답에 사용할 수 있고 HEAD 메서드에 대한 응답으로 전송될 수 있는 대체 표현 목록을 제공하는 것으로 정의했습니다. 그러나 배포 부족과 구문에 대한 불일치로 인해 URI와 대체\(후속 제안\)가 모두 이 사양에서 제외되었습니다. 배포는 닭과 달걀의 문제이지만 각각 "대체" 관계를 갖는 일련의 링크 헤더 필드 \[RFC5988\]를 사용하여 목록을 전달할 수 있습니다.

---
#### **6.4.2.  301 Moved Permanently**

301\(영구적으로 이동됨\) 상태 코드는 대상 리소스에 새로운 영구 URI가 할당되었으며 이 리소스에 대한 향후 참조는 포함된 URI 중 하나를 사용해야 함을 나타냅니다. 링크 편집 기능이 있는 클라이언트는 가능한 경우 유효한 요청 URI에 대한 참조를 서버에서 보낸 하나 이상의 새 참조에 자동으로 다시 연결해야 합니다.

서버는 새로운 영구 URI에 대한 기본 URI 참조를 포함하는 응답에서 Location 헤더 필드를 생성해야 합니다\(SHOULD\). 사용자 에이전트는 자동 리디렉션을 위해 위치 필드 값을 사용할 수 있습니다. 서버의 응답 페이로드에는 일반적으로 새 URI에 대한 하이퍼링크가 포함된 짧은 하이퍼텍스트 메모가 포함되어 있습니다.\(SHOULD, MAY\)

- 참고: 역사적인 이유로 사용자 에이전트는 후속 요청에 대해 요청 방법을 POST에서 GET으로 변경할 수 있습니다. 이 동작이 바람직하지 않은 경우 307\(임시 리디렉션\) 상태 코드를 대신 사용할 수 있습니다.\(MAY\)

301 응답은 기본적으로 캐시 가능합니다. 즉, 메서드 정의나 명시적 캐시 제어로 달리 지정되지 않는 한\(\[RFC7234\]의 섹션 4.2.2 참조\)

---
#### **6.4.3.  302 Found**

302\(Found\) 상태 코드는 대상 리소스가 일시적으로 다른 URI 아래에 있음을 나타냅니다. 때때로 리디렉션이 변경될 수 있으므로 클라이언트는 향후 요청에 대해 유효한 요청 URI를 계속 사용해야 합니다.

서버는 다른 URI에 대한 URI 참조를 포함하는 응답에 Location 헤더 필드를 생성해야 합니다\(SHOULD\). 사용자 에이전트는 자동 리디렉션을 위해 위치 필드 값을 사용할 수 있습니다. 서버의 응답 페이로드에는 일반적으로 다른 URI에 대한 하이퍼링크가 포함된 짧은 하이퍼텍스트 메모가 포함되어 있습니다.\(SHOULD, MAY\)

- 참고: 역사적인 이유로 사용자 에이전트는 후속 요청에 대해 요청 방법을 POST에서 GET으로 변경할 수 있습니다. 이 동작이 바람직하지 않은 경우 307\(임시 리디렉션\) 상태 코드를 대신 사용할 수 있습니다.\(MAY\)

---
#### **6.4.4.  303 See Other**

303\(기타 참조\) 상태 코드는 원래 요청에 대한 간접적인 응답을 제공하기 위한 Location 헤더 필드의 URI에 표시된 대로 서버가 사용자 에이전트를 다른 리소스로 리디렉션하고 있음을 나타냅니다. 사용자 에이전트는 리디렉션될 수도 있는 해당 URI\(HTTP를 사용하는 경우 GET 또는 HEAD 요청\)를 대상으로 하는 검색 요청을 수행하고 최종 결과를 원래 요청에 대한 응답으로 제시할 수 있습니다. Location 헤더 필드의 새 URI는 유효한 요청 URI와 동일한 것으로 간주되지 않습니다.

이 상태 코드는 모든 HTTP 메서드에 적용 가능합니다. 이는 사용자 에이전트를 선택한 리소스로 리디렉션하기 위해 POST 작업의 출력을 허용하는 데 주로 사용됩니다. 이렇게 하면 POST 응답에 해당하는 정보가 리소스와 관계없이 별도로 식별, 북마크 및 캐시될 수 있는 형식으로 제공되기 때문입니다. 원래 요청.

GET 요청에 대한 303 응답은 원본 서버에 HTTP를 통해 서버가 전송할 수 있는 대상 리소스에 대한 표현이 없음을 나타냅니다. 그러나 위치 필드 값은 대상 리소스를 설명하는 리소스를 참조하므로 다른 리소스에 대한 검색 요청을 하면 원래 대상 리소스를 나타낸다는 것을 암시하지 않고 수신자에게 유용한 표현이 생성될 수 있습니다. 무엇을 표현할 수 있는지, 어떤 표현이 적절한지, 무엇이 유용한 설명이 될 수 있는지에 대한 질문에 대한 대답은 HTTP의 범위를 벗어납니다.

HEAD 요청에 대한 응답을 제외하고 303 응답 표현에는 Location 헤더 필드에 제공된 동일한 URI 참조에 대한 하이퍼링크가 있는 짧은 하이퍼텍스트 메모가 포함되어야 합니다.

---
#### **6.4.5.  305 Use Proxy**

305\(프록시 사용\) 상태 코드는 이 사양의 이전 버전에서 정의되었으며 현재는 더 이상 사용되지 않습니다\(부록 B\).

---
#### **6.4.6.  306 (Unused)**

306 상태 코드는 이 사양의 이전 버전에서 정의되었으며 더 이상 사용되지 않으며 해당 코드는 예약되어 있습니다.

---
#### **6.4.7.  307 Temporary Redirect**

307\(임시 리디렉션\) 상태 코드는 대상 리소스가 일시적으로 다른 URI 아래에 상주하며 사용자 에이전트가 해당 URI로 자동 리디렉션을 수행하는 경우 요청 방법을 변경해서는 안 된다는 것을 나타냅니다. 리디렉션은 시간이 지남에 따라 변경될 수 있으므로 클라이언트는 향후 요청에 대해 원래의 유효한 요청 URI를 계속 사용해야 합니다.\(MUST NOT\)

서버는 다른 URI에 대한 URI 참조를 포함하는 응답에 Location 헤더 필드를 생성해야 합니다\(SHOULD\). 사용자 에이전트는 자동 리디렉션을 위해 위치 필드 값을 사용할 수 있습니다. 서버의 응답 페이로드에는 일반적으로 다른 URI에 대한 하이퍼링크가 포함된 짧은 하이퍼텍스트 메모가 포함되어 있습니다.\(SHOULD, MAY\)

- 참고: 이 상태 코드는 요청 방법을 POST에서 GET으로 변경할 수 없다는 점을 제외하면 302\(Found\)와 유사합니다. 이 사양에서는 301\(영구적으로 이동됨\)에 해당하는 항목을 정의하지 않습니다\(그러나 \[RFC7238\]에서는 이 목적을 위해 상태 코드 308\(영구 리디렉션\)을 정의합니다\).

---
### **6.5.  Client Error 4xx**

상태 코드의 4xx\(클라이언트 오류\) 클래스는 클라이언트에 오류가 있는 것 같음을 나타냅니다. HEAD 요청에 응답할 때를 제외하고 서버는 오류 상황에 대한 설명과 그것이 일시적인지 영구적인지 여부를 포함하는 표현을 보내야 합니다. 이러한 상태 코드는 모든 요청 방법에 적용 가능합니다. 사용자 에이전트는 포함된 모든 표현을 사용자에게 표시해야 합니다.\(SHOULD, SHOULD\)

---
#### **6.5.1.  400 Bad Request**

400\(잘못된 요청\) 상태 코드는 클라이언트 오류로 인식되는 원인\(예: 잘못된 요청 구문, 잘못된 요청 메시지 프레이밍 또는 사기성 요청 라우팅\)으로 인해 서버가 요청을 처리할 수 없거나 처리하지 않을 것임을 나타냅니다.

---
#### **6.5.2.  402 Payment Required**

402\(결제 필요\) 상태 코드는 향후 사용을 위해 예약되어 있습니다.

---
#### **6.5.3.  403 Forbidden**

403\(금지됨\) 상태 코드는 서버가 요청을 이해했지만 승인을 거부했음을 나타냅니다. 요청이 금지된 이유를 공개하려는 서버는 응답 페이로드\(있는 경우\)에 해당 이유를 설명할 수 있습니다.

요청에 인증 자격 증명이 제공된 경우 서버는 액세스 권한을 부여하기에 충분하지 않은 것으로 간주합니다. 클라이언트는 동일한 자격 증명을 사용하여 요청을 자동으로 반복해서는 안 됩니다. 클라이언트는 새 자격 증명이나 다른 자격 증명을 사용하여 요청을 반복할 수 있습니다. 그러나 자격 증명과 관련 없는 이유로 요청이 금지될 수 있습니다.\(SHOULD NOT, MAY\)

금지된 대상 리소스의 현재 존재를 "숨기려는" 원서버는 대신 404\(찾을 수 없음\) 상태 코드로 응답할 수 있습니다.\(MAY\)

---
#### **6.5.4.  404 Not Found**

404\(찾을 수 없음\) 상태 코드는 원본 서버가 대상 리소스에 대한 현재 표현을 찾지 못했거나 해당 표현이 존재한다는 사실을 공개할 의사가 없음을 나타냅니다. 404 상태 코드는 이러한 표현 부족이 일시적인지 영구적인지를 나타내지 않습니다. 원본 서버가 아마도 일부 구성 가능한 수단을 통해 조건이 영구적일 가능성이 있다는 것을 알고 있는 경우 404보다 410\(사라짐\) 상태 코드가 선호됩니다.

404 응답은 기본적으로 캐시 가능합니다. 즉, 메서드 정의나 명시적 캐시 제어로 달리 지정되지 않는 한\(\[RFC7234\]의 섹션 4.2.2 참조\)

---
#### **6.5.5.  405 Method Not Allowed**

405\(Method Not Allowed\) 상태 코드는 요청 라인에서 수신된 메소드가 원본 서버에 알려져 있지만 대상 리소스에서는 지원되지 않음을 나타냅니다. 원본 서버는 대상 리소스의 현재 지원되는 메서드 목록을 포함하는 405 응답에서 Allow 헤더 필드를 생성해야 합니다.\(MUST\)

405 응답은 기본적으로 캐시 가능합니다. 즉, 메서드 정의나 명시적 캐시 제어로 달리 지정되지 않는 한\(\[RFC7234\]의 섹션 4.2.2 참조\)

---
#### **6.5.6.  406 Not Acceptable**

406\(허용되지 않음\) 상태 코드는 요청\(섹션 5.3\)에서 수신된 사전 협상 헤더 필드에 따라 대상 리소스에 사용자 에이전트가 허용할 수 있는 현재 표현이 없으며 서버가 이를 원하지 않음을 나타냅니다. 기본 표현을 제공합니다.

서버는 사용 가능한 표현 특성 목록과 사용자 또는 사용자 에이전트가 가장 적절한 것을 선택할 수 있는 해당 리소스 식별자가 포함된 페이로드를 생성해야 합니다\(SHOULD\). 사용자 에이전트는 해당 목록에서 가장 적절한 선택을 자동으로 선택할 수 있습니다. 그러나 이 사양은 섹션 6.4.1에 설명된 대로 자동 선택에 대한 표준을 정의하지 않습니다.\(SHOULD, MAY\)

---
#### **6.5.7.  408 Request Timeout**

408\(요청 시간 초과\) 상태 코드는 서버가 대기할 준비가 된 시간 내에 완전한 요청 메시지를 받지 못했음을 나타냅니다. 408은 서버가 계속 기다리지 않고 연결을 닫기로 결정했음을 의미하므로 서버는 응답으로 "닫기" 연결 옵션\(\[RFC7230\]의 섹션 6.1\)을 보내야 합니다. 클라이언트가 전송 중인 미해결 요청이 있는 경우 클라이언트는 새 연결에서 해당 요청을 반복할 수 있습니다.\(SHOULD, MAY\)

---
#### **6.5.8.  409 Conflict**

409\(충돌\) 상태 코드는 대상 리소스의 현재 상태와의 충돌로 인해 요청을 완료할 수 없음을 나타냅니다. 이 코드는 사용자가 충돌을 해결하고 요청을 다시 제출할 수 있는 상황에서 사용됩니다. 서버는 사용자가 충돌의 원인을 인식할 수 있을 만큼 충분한 정보를 포함하는 페이로드를 생성해야 합니다\(SHOULD\).\(SHOULD\)

PUT 요청에 대한 응답으로 충돌이 발생할 가능성이 가장 높습니다. 예를 들어, 버전 관리가 사용되고 PUT 중인 표현에 이전\(제3자\) 요청에 의해 생성된 것과 충돌하는 리소스에 대한 변경 사항이 포함된 경우 원본 서버는 409 응답을 사용하여 해당 작업을 완료할 수 없음을 나타낼 수 있습니다. 요구. 이 경우 응답 표현에는 개정 기록을 기반으로 차이점을 병합하는 데 유용한 정보가 포함될 수 있습니다.

---
#### **6.5.9.  410 Gone**

410\(Gone\) 상태 코드는 원본 서버에서 대상 리소스에 대한 액세스가 더 이상 가능하지 않으며 이 상태가 영구적일 가능성이 있음을 나타냅니다. 원본 서버가 그렇지 않은 경우

상태가 영구적인지 여부를 알거나 판단할 수 있는 시설이 없는 경우에는 상태 코드 404\(찾을 수 없음\)를 대신 사용해야 합니다.

410 응답은 주로 리소스를 의도적으로 사용할 수 없으며 서버 소유자가 해당 리소스에 대한 원격 링크를 제거하기를 원한다는 사실을 수신자에게 알려 웹 유지 관리 작업을 지원하기 위한 것입니다. 이러한 이벤트는 제한된 시간 동안 진행되는 판촉 서비스 및 원본 서버 사이트와 더 이상 연결되지 않은 개인에게 속한 리소스에 대해 일반적입니다. 영구적으로 사용할 수 없는 모든 리소스를 "사라짐"으로 표시하거나 일정 기간 동안 표시를 유지할 필요는 없습니다. 이는 서버 소유자의 재량에 달려 있습니다.

410 응답은 기본적으로 캐시 가능합니다. 즉, 메서드 정의나 명시적 캐시 제어로 달리 지정되지 않는 한\(\[RFC7234\]의 섹션 4.2.2 참조\)

---
#### **6.5.10.  411 Length Required**

411\(길이 필요\) 상태 코드는 서버가 정의된 Content-Length\(\[RFC7230\]의 섹션 3.3.2\) 없이 요청 수락을 거부함을 나타냅니다. 클라이언트는 요청 메시지에 메시지 본문의 길이를 포함하는 유효한 Content-Length 헤더 필드를 추가하는 경우 요청을 반복할 수 있습니다.\(MAY\)

---
#### **6.5.11.  413 Payload Too Large**

413\(페이로드가 너무 큼\) 상태 코드는 요청 페이로드가 서버가 처리할 의사가 있거나 처리할 수 있는 것보다 크기 때문에 서버가 요청 처리를 거부하고 있음을 나타냅니다. 서버는 클라이언트가 요청을 계속하는 것을 방지하기 위해 연결을 닫을 수 있습니다.\(MAY\)

조건이 일시적인 경우 서버는 Retry-After 헤더 필드를 생성하여 그것이 일시적임을 나타내고 클라이언트가 몇 시간 후에 다시 시도할 수 있는지를 나타내야 합니다.\(SHOULD\)

---
#### **6.5.12.  414 URI Too Long**

414\(URI 너무 김\) 상태 코드는 요청 대상\(\[RFC7230\]의 섹션 5.3\)이 서버가 해석하려는 것보다 길기 때문에 서버가 요청 서비스를 거부하고 있음을 나타냅니다. 이 드문 상황은 클라이언트가 긴 쿼리 정보가 포함된 POST 요청을 GET 요청으로 부적절하게 변환한 경우, 클라이언트가 리디렉션의 "블랙홀"\(예: 다음을 가리키는 리디렉션된 URI 접두사\)에 빠진 경우에만 발생할 가능성이 높습니다. 자체 접미사\) 또는 서버가 잠재적인 보안 허점을 악용하려는 클라이언트의 공격을 받고 있는 경우입니다.

414 응답은 기본적으로 캐시 가능합니다. 즉, 메서드 정의나 명시적 캐시 제어로 달리 지정되지 않는 한\(\[RFC7234\]의 섹션 4.2.2 참조\)

---
#### **6.5.13.  415 Unsupported Media Type**

415\(지원되지 않는 미디어 유형\) 상태 코드는 페이로드가 대상 리소스에서 이 메서드가 지원하지 않는 형식이기 때문에 원본 서버가 요청 서비스를 거부하고 있음을 나타냅니다. 형식 문제는 요청에 표시된 Content-Type 또는 Content-Encoding 때문이거나 데이터를 직접 검사한 결과일 수 있습니다.

---
#### **6.5.14.  417 Expectation Failed**

417\(예상 실패\) 상태 코드는 요청의 Expect 헤더 필드\(섹션 5.1.1\)에 제공된 기대가 인바운드 서버 중 하나 이상에서 충족될 수 없음을 나타냅니다.

---
#### **6.5.15.  426 Upgrade Required**

426\(업그레이드 필요\) 상태 코드는 서버가 현재 프로토콜을 사용하여 요청 수행을 거부하지만 클라이언트가 다른 프로토콜로 업그레이드한 후에는 기꺼이 수행할 수 있음을 나타냅니다. 서버는 필요한 프로토콜을 나타내기 위해 426 응답으로 업그레이드 헤더 필드를 전송해야 합니다\(\[RFC7230\]의 섹션 6.7\).\(MUST\)

```text
   Example:

     HTTP/1.1 426 Upgrade Required
     Upgrade: HTTP/3.0
     Connection: Upgrade
     Content-Length: 53
     Content-Type: text/plain
```

이 서비스를 사용하려면 HTTP/3.0 프로토콜을 사용해야 합니다.

---
### **6.6.  Server Error 5xx**

상태 코드의 5xx\(서버 오류\) 클래스는 서버가 오류가 발생했거나 요청된 메서드를 수행할 수 없음을 인식하고 있음을 나타냅니다. HEAD 요청에 응답할 때를 제외하고 서버는 오류 상황에 대한 설명과 그것이 일시적인지 영구적인지 여부를 포함하는 표현을 보내야 합니다.\(SHOULD\)

상태. 사용자 에이전트는 포함된 모든 표현을 사용자에게 표시해야 합니다\(SHOULD\). 이러한 응답 코드는 모든 요청 방법에 적용 가능합니다.\(SHOULD\)

---
#### **6.6.1.  500 Internal Server Error**

500\(내부 서버 오류\) 상태 코드는 서버가 요청을 이행하지 못하게 하는 예상치 못한 상황에 직면했음을 나타냅니다.

---
#### **6.6.2.  501 Not Implemented**

501\(구현되지 않음\) 상태 코드는 서버가 요청을 이행하는 데 필요한 기능을 지원하지 않음을 나타냅니다. 이는 서버가 요청 방법을 인식하지 못하고 어떤 리소스에도 이를 지원할 수 없는 경우에 적합한 응답입니다.

501 응답은 기본적으로 캐시 가능합니다. 즉, 메서드 정의나 명시적 캐시 제어로 달리 지정되지 않는 한\(\[RFC7234\]의 섹션 4.2.2 참조\)

---
#### **6.6.3.  502 Bad Gateway**

502\(잘못된 게이트웨이\) 상태 코드는 서버가 게이트웨이 또는 프록시 역할을 하는 동안 요청을 이행하려고 시도하는 동안 액세스한 인바운드 서버로부터 잘못된 응답을 받았음을 나타냅니다.

---
#### **6.6.4.  503 Service Unavailable**

503\(서비스를 사용할 수 없음\) 상태 코드는 일시적인 과부하 또는 예정된 유지 관리로 인해 서버가 현재 요청을 처리할 수 없음을 나타냅니다. 이는 약간의 지연 후에 완화될 가능성이 높습니다. 서버는 요청을 재시도하기 전에 클라이언트가 기다려야 할 적절한 시간을 제안하기 위해 Retry-After 헤더 필드\(섹션 7.1.3\)를 보낼 수 있습니다.\(MAY\)

- 참고: 503 상태 코드가 존재한다고 해서 서버가 과부하 상태일 때 이를 사용해야 한다는 의미는 아닙니다. 일부 서버는 단순히 연결을 거부할 수도 있습니다.

---
#### **6.6.5.  504 Gateway Timeout**

504\(게이트웨이 시간 초과\) 상태 코드는 서버가 게이트웨이 또는 프록시 역할을 하는 동안 요청을 완료하기 위해 액세스해야 하는 업스트림 서버로부터 적시에 응답을 받지 못했음을 나타냅니다.

---
#### **6.6.6.  505 HTTP Version Not Supported**

505\(HTTP 버전은 지원되지 않음\) 상태 코드는 서버가 요청 메시지에 사용된 HTTP의 주요 버전을 지원하지 않거나 지원을 거부함을 나타냅니다. 서버는 이 오류 메시지 외에 \[RFC7230\]의 섹션 2.6에 설명된 대로 클라이언트와 동일한 주요 버전을 사용하여 요청을 완료할 수 없거나 완료할 의사가 없음을 나타냅니다. 서버는 해당 버전이 지원되지 않는 이유와 해당 서버에서 지원하는 다른 프로토콜을 설명하는 505 응답에 대한 표현을 생성해야 합니다.\(SHOULD\)

---
## **7.  Response Header Fields**

응답 헤더 필드를 사용하면 서버는 상태 표시줄에 있는 것 외에 응답에 대한 추가 정보를 전달할 수 있습니다. 이러한 헤더 필드는 서버, 대상 리소스에 대한 추가 액세스 또는 관련 리소스에 대한 정보를 제공합니다.

각 응답 헤더 필드에는 정의된 의미가 있지만 일반적으로 정확한 의미는 요청 메서드 및/또는 응답 상태 코드의 의미에 따라 더욱 구체화될 수 있습니다.

---
### **7.1.  Control Data**

응답 헤더 필드는 상태 코드를 보완하고, 캐싱을 지시하거나, 클라이언트에게 다음에 이동할 위치를 지시하는 제어 데이터를 제공할 수 있습니다.

```text
   +-------------------+--------------------------+
   | Header Field Name | Defined in...            |
   +-------------------+--------------------------+
   | Age               | Section 5.1 of [RFC7234] |
   | Cache-Control     | Section 5.2 of [RFC7234] |
   | Expires           | Section 5.3 of [RFC7234] |
   | Date              | Section 7.1.1.2          |
   | Location          | Section 7.1.2            |
   | Retry-After       | Section 7.1.3            |
   | Vary              | Section 7.1.4            |
   | Warning           | Section 5.5 of [RFC7234] |
   +-------------------+--------------------------+
```

---
#### **7.1.1.  Origination Date**
---
##### **7.1.1.1.  Date/Time Formats**

1995년 이전에는 서버에서 타임스탬프를 전달하기 위해 일반적으로 사용되는 세 가지 형식이 있었습니다. 이전 구현과의 호환성을 위해 세 가지 모두 여기에 정의되어 있습니다. 선호되는 형식은 인터넷 메시지 형식\[RFC5322\]에서 사용되는 날짜 및 시간 사양의 고정 길이 및 단일 영역 하위 집합입니다.

```text
     HTTP-date    = IMF-fixdate / obs-date
```

선호되는 형식의 예는 다음과 같습니다.

```text
     Sun, 06 Nov 1994 08:49:37 GMT    ; IMF-fixdate
```

더 이상 사용되지 않는 두 가지 형식의 예는 다음과 같습니다.

```text
     Sunday, 06-Nov-94 08:49:37 GMT   ; obsolete RFC 850 format
     Sun Nov  6 08:49:37 1994         ; ANSI C's asctime() format
```

HTTP 헤더 필드의 타임스탬프 값을 구문 분석하는 수신자는 세 가지 HTTP 날짜 형식을 모두 수락해야 합니다. 발신자가 HTTP 날짜로 정의된 하나 이상의 타임스탬프를 포함하는 헤더 필드를 생성할 때 발신자는 해당 타임스탬프를 IMF-fixdate 형식으로 생성해야 합니다.\(MUST, MUST\)

HTTP-date 값은 UTC\(협정 세계시\)의 인스턴스로 시간을 나타냅니다. 처음 두 형식은 UTC 이름의 전신인 그리니치 표준시의 세 글자 약어인 "GMT"로 UTC를 나타냅니다. asctime 형식의 값은 UTC로 간주됩니다. 로컬 시계에서 HTTP 날짜 값을 생성하는 발신자는 NTP\(\[RFC5905\]\) 또는 유사한 프로토콜을 사용하여 시계를 UTC에 동기화해야 합니다.

```text
   Preferred format:

     IMF-fixdate  = day-name "," SP date1 SP time-of-day SP GMT
     ; fixed length/zone/capitalization subset of the format
     ; see Section 3.3 of [RFC5322]

     day-name     = %x4D.6F.6E ; "Mon", case-sensitive
                  / %x54.75.65 ; "Tue", case-sensitive
                  / %x57.65.64 ; "Wed", case-sensitive
                  / %x54.68.75 ; "Thu", case-sensitive
                  / %x46.72.69 ; "Fri", case-sensitive
                  / %x53.61.74 ; "Sat", case-sensitive
                  / %x53.75.6E ; "Sun", case-sensitive

     date1        = day SP month SP year
                  ; e.g., 02 Jun 1982

     day          = 2DIGIT
     month        = %x4A.61.6E ; "Jan", case-sensitive
                  / %x46.65.62 ; "Feb", case-sensitive
                  / %x4D.61.72 ; "Mar", case-sensitive
                  / %x41.70.72 ; "Apr", case-sensitive
                  / %x4D.61.79 ; "May", case-sensitive
                  / %x4A.75.6E ; "Jun", case-sensitive
                  / %x4A.75.6C ; "Jul", case-sensitive
                  / %x41.75.67 ; "Aug", case-sensitive
                  / %x53.65.70 ; "Sep", case-sensitive
                  / %x4F.63.74 ; "Oct", case-sensitive
                  / %x4E.6F.76 ; "Nov", case-sensitive
                  / %x44.65.63 ; "Dec", case-sensitive
     year         = 4DIGIT

     GMT          = %x47.4D.54 ; "GMT", case-sensitive

     time-of-day  = hour ":" minute ":" second
                  ; 00:00:00 - 23:59:60 (leap second)

     hour         = 2DIGIT
     minute       = 2DIGIT
     second       = 2DIGIT

   Obsolete formats:

     obs-date     = rfc850-date / asctime-date

     rfc850-date  = day-name-l "," SP date2 SP time-of-day SP GMT
     date2        = day "-" month "-" 2DIGIT
                  ; e.g., 02-Jun-82

     day-name-l   = %x4D.6F.6E.64.61.79    ; "Monday", case-sensitive
            / %x54.75.65.73.64.61.79       ; "Tuesday", case-sensitive
            / %x57.65.64.6E.65.73.64.61.79 ; "Wednesday", case-sensitive
            / %x54.68.75.72.73.64.61.79    ; "Thursday", case-sensitive
            / %x46.72.69.64.61.79          ; "Friday", case-sensitive
            / %x53.61.74.75.72.64.61.79    ; "Saturday", case-sensitive
            / %x53.75.6E.64.61.79          ; "Sunday", case-sensitive

     asctime-date = day-name SP date3 SP time-of-day SP year
     date3        = month SP ( 2DIGIT / ( SP 1DIGIT ))
                  ; e.g., Jun  2
```

HTTP 날짜는 대소문자를 구분합니다. 발신자는 문법에 SP로 특별히 포함된 것 이상으로 HTTP 날짜에 추가 공백을 생성해서는 안 됩니다. 일 이름, 일, 월, 연도 및 시간의 의미는 해당 이름\(\[RFC5322\], 섹션 3.3\)을 사용하여 인터넷 메시지 형식 구성에 대해 정의된 것과 동일합니다.\(MUST NOT\)

두 자리 연도를 사용하는 rfc850-date 형식의 타임스탬프 값 수신자는 미래 50년 이상으로 보이는 타임스탬프를 마지막 두 자리가 동일한 과거의 가장 최근 연도를 나타내는 것으로 해석해야 합니다. .\(MUST\)

타임스탬프 값의 수신자는 필드 정의에 의해 달리 제한되지 않는 한 타임스탬프 구문 분석에 강력하도록 권장됩니다. 예를 들어 메시지는 인터넷 메시지 형식에 정의된 날짜 및 시간 사양을 생성할 수 있는 HTTP가 아닌 소스에서 HTTP를 통해 전달되는 경우가 있습니다.

- 참고: 날짜/시간 스탬프 형식에 대한 HTTP 요구 사항은 프로토콜 스트림 내에서의 사용에만 적용됩니다. 구현에서는 사용자 표시, 요청 로깅 등에 이러한 형식을 사용할 필요가 없습니다.

---
##### **7.1.1.2.  Date**

"Date" 헤더 필드는 메시지가 시작된 날짜와 시간을 나타내며 \[RFC5322\] 섹션 3.6.1에 정의된 Origination Date Field\(orig-date\)와 동일한 의미를 갖습니다. 필드 값은 섹션 7.1.1.1에 정의된 HTTP 날짜입니다.

```text
     Date = HTTP-date
```

예는 다음과 같습니다

```text
     Date: Tue, 15 Nov 1994 08:12:31 GMT
```

Date 헤더 필드가 생성되면 발신자는 메시지 생성 날짜 및 시간에 대해 사용 가능한 최상의 근사치로 해당 필드 값을 생성해야 합니다. 이론적으로 날짜는 페이로드가 생성되기 직전의 순간을 나타내야 합니다. 실제로 날짜는 메시지 생성 중 언제든지 생성될 수 있습니다.\(SHOULD\)

원서버는 협정 세계시\(UTC\)에서 현재 인스턴스의 합리적인 근사치를 제공할 수 있는 시계가 없는 경우 Date 헤더 필드를 전송해서는 안 됩니다\(MUST NOT\). 응답이 상태 코드의 1xx\(정보\) 또는 5xx\(서버 오류\) 클래스에 있는 경우 원서버는 Date 헤더 필드를 보낼 수 있습니다. 다른 모든 경우에는 원본 서버가 Date 헤더 필드를 보내야 합니다.\(MUST NOT, MAY, MUST\)

Date 헤더 필드 없이 응답 메시지를 수신하는 시계를 가진 수신자는 수신된 시간을 기록해야 하며, 해당 Date 헤더 필드가 캐시되거나 다운스트림으로 전달되는 경우 메시지의 헤더 섹션에 추가해야 합니다.\(MUST\)

사용자 에이전트는 요청에 Date 헤더 필드를 보낼 수 있지만 일반적으로 서버에 유용한 정보를 전달한다고 생각되지 않는 한 그렇게 하지 않습니다. 예를 들어, 서버가 사용자 에이전트와 서버 시계 간의 차이를 기반으로 사용자 요청 해석을 조정할 것으로 예상되는 경우 HTTP의 사용자 정의 애플리케이션은 날짜를 전달할 수 있습니다.\(MAY\)

---
#### **7.1.2.  Location**

"Location" 헤더 필드는 일부 응답에서 응답과 관련된 특정 리소스를 참조하는 데 사용됩니다. 관계 유형은 요청 방법과 상태 코드 의미의 조합으로 정의됩니다.

```text
     Location = URI-reference
```

필드 값은 단일 URI 참조로 구성됩니다. 상대 참조 형식\(\[RFC3986\], 섹션 4.2\)을 갖는 경우 최종 값은 유효한 요청 URI\(\[RFC3986\], 섹션 5\)에 대해 이를 확인하여 계산됩니다.

201\(생성됨\) 응답의 경우 위치 값은 요청에 의해 생성된 기본 리소스를 나타냅니다. 3xx\(리디렉션\) 응답의 경우 위치 값은 요청을 자동으로 리디렉션하기 위해 선호하는 대상 리소스를 나타냅니다.

3xx\(리디렉션\) 응답에 제공된 위치 값에 조각 구성 요소가 없는 경우 사용자 에이전트는 해당 값이 요청 대상을 생성하는 데 사용된 URI 참조의 조각 구성 요소를 상속하는 것처럼 리디렉션을 처리해야 합니다\(즉, 리디렉션은 다음을 상속합니다\). 원본 참조의 조각\(있는 경우\).\(MUST\)

예를 들어, URI 참조 "http://www.example.org/\~tim"에 대해 생성된 GET 요청은 헤더 필드를 포함하는 303\(기타 참조\) 응답으로 이어질 수 있습니다.

```text
     Location: /People.html#tim

   which suggests that the user agent redirect to
   "http://www.example.org/People.html#tim"
```

마찬가지로, URI 참조 "http://www.example.org/index.html#larry"에 대해 생성된 GET 요청은 헤더 필드를 포함하는 301\(영구적으로 이동됨\) 응답을 생성할 수 있습니다.

```text
     Location: http://www.example.net/index.html
```

이는 사용자 에이전트가 원래 조각 식별자를 유지하면서 "http://www.example.net/index.html#larry"로 리디렉션되도록 제안합니다.

위치 값의 조각 식별자가 적절하지 않은 상황이 있습니다. 예를 들어 201\(Created\) 응답의 Location 헤더 필드는 생성된 리소스에 특정한 URI를 제공해야 합니다.

- 참고: 일부 수신자는 유효한 URI 참조가 아닌 위치 필드에서 복구를 시도합니다. 이 사양은 이러한 처리를 요구하거나 정의하지 않지만 견고성을 위해 이를 허용합니다.

- 참고: Content-Location 헤더 필드\(섹션 3.1.4.2\)는 Content-Location이 포함된 표현에 해당하는 가장 구체적인 리소스를 참조한다는 점에서 Location과 다릅니다. 따라서 응답에 Location 및 Content-Location 헤더 필드가 모두 포함될 수 있습니다.

---
#### **7.1.3.  Retry-After**

서버는 후속 요청을 하기 전에 사용자 에이전트가 기다려야 하는 시간을 나타내기 위해 "Retry-After" 헤더 필드를 보냅니다. 503\(서비스를 사용할 수 없음\) 응답과 함께 전송되는 경우 Retry-After는 클라이언트가 서비스를 사용할 수 없을 것으로 예상되는 기간을 나타냅니다. 3xx\(리디렉션\) 응답과 함께 전송되는 경우 Retry-After는 리디렉션된 요청을 발행하기 전에 사용자 에이전트가 기다려야 하는 최소 시간을 나타냅니다.

이 필드의 값은 HTTP 날짜이거나 응답 수신 후 지연되는 시간\(초\)일 수 있습니다.

```text
     Retry-After = HTTP-date / delay-seconds
```

지연 초 값은 음이 아닌 십진수 정수로, 시간을 초 단위로 나타냅니다.

```text
     delay-seconds  = 1*DIGIT
```

그 사용의 두 가지 예는 다음과 같습니다

```text
     Retry-After: Fri, 31 Dec 1999 23:59:59 GMT
     Retry-After: 120
```

후자의 예에서는 지연 시간이 2분입니다.

---
#### **7.1.4.  Vary**

응답의 "Vary" 헤더 필드는 메서드, Host 헤더 필드 및 요청 대상을 제외하고 요청 메시지의 어떤 부분이 이 응답을 선택하고 표시하기 위한 원본 서버의 프로세스에 영향을 미칠 수 있는지 설명합니다. 값은 단일 별표\("\*"\) 또는 헤더 필드 이름 목록\(대소문자 구분 안 함\)으로 구성됩니다.

```text
     Vary = "*" / 1#field-name
```

"\*"의 Vary 필드 값은 메시지 구문 외부의 요소\(예: 클라이언트의 네트워크 주소\)를 포함하여 요청에 관한 모든 것이 응답 표현을 선택하는 데 역할을 할 수 있음을 나타냅니다. 수신자는 요청을 원본 서버로 전달하지 않고는 이 응답이 이후 요청에 적합한지 여부를 결정할 수 없습니다. 프록시는 "\*" 값을 사용하여 Vary 필드를 생성해서는 안 됩니다.\(MUST NOT\)

쉼표로 구분된 이름 목록으로 구성된 Vary 필드 값은 선택 헤더 필드로 알려진 명명된 요청 헤더 필드가 표현을 선택하는 역할을 가질 수 있음을 나타냅니다. 잠재적인 선택 헤더 필드는 이 사양에 정의된 필드로 제한되지 않습니다.

예를 들어, 다음을 포함하는 응답

```text
     Vary: accept-encoding, accept-language
```

원본 서버가 이 응답의 콘텐츠를 선택하는 동안 요청의 Accept-Encoding 및 Accept-Language 필드\(또는 필드 부족\)를 결정 요인으로 사용했을 수 있음을 나타냅니다.

원본 서버는 다음 두 가지 목적으로 필드 목록과 함께 Vary를 보낼 수 있습니다.

1. 이후 요청이 원래 요청\(\[RFC7234\]의 섹션 4.1\)과 나열된 필드에 대해 동일한 값을 갖지 않는 한 이후 요청을 충족하기 위해 이 응답을 사용해서는 안 된다는 점을 캐시 수신자에게 알리기 위해. 즉, Vary는 새 요청을 저장된 캐시 항목과 일치시키는 데 필요한 캐시 키를 확장합니다.\(MUST NOT\)

2. 이 응답은 콘텐츠 협상\(섹션 5.3\)의 적용을 받으며, 나열된 헤더 필드에 추가 매개변수가 제공되는 경우 후속 요청에서 다른 표현이 전송될 수 있음을 사용자 에이전트 수신자에게 알리기 위해\(선제적 협상\)

원서버는 표현을 선택하기 위한 알고리즘이 메서드 및 요청 대상 이외의 요청 메시지의 측면에 따라 다를 때 Vary 헤더 필드를 보내야 합니다. 단, 차이를 초과할 수 없거나 원서버가 의도적으로 캐시 투명성을 방지하도록 구성한 경우는 예외입니다. . 예를 들어, 사용자 간 재사용은 필드 정의\(\[RFC7235\]의 섹션 4.2\)에 의해 제한되므로 Vary에서 Authorization 필드 이름을 보낼 필요가 없습니다. 마찬가지로 원본 서버는 Vary가 캐싱에 미치는 영향의 성능 비용보다 차이가 덜 중요하다고 간주하는 경우 Vary를 대체하기 위해 Cache-Control 지시문\(\[RFC7234\]의 섹션 5.2\)을 사용할 수 있습니다.\(SHOULD\)

---
### **7.2.  Validator Header Fields**

유효성 검사기 헤더 필드는 선택한 표현에 대한 메타데이터를 전달합니다\(섹션 3\). 안전한 요청에 대한 응답에서 유효성 검사기 필드는 응답을 처리하는 동안 원본 서버가 선택한 표현을 설명합니다. 상태 코드 의미에 따라 특정 응답에 대해 선택된 표현이 반드시 응답 페이로드로 포함된 표현과 동일하지는 않습니다.

상태 변경 요청에 대한 성공적인 응답에서 유효성 검사기 필드는 요청 처리 결과로 이전에 선택한 표현을 대체한 새로운 표현을 설명합니다.

예를 들어, 201\(생성됨\) 응답의 ETag 헤더 필드는 새로 생성된 리소스 표현의 엔터티 태그를 전달하므로 "업데이트 손실" 문제\[RFC7232\]를 방지하기 위해 이후 조건부 요청에 사용할 수 있습니다.

```text
   +-------------------+--------------------------+
   | Header Field Name | Defined in...            |
   +-------------------+--------------------------+
   | ETag              | Section 2.3 of [RFC7232] |
   | Last-Modified     | Section 2.2 of [RFC7232] |
   +-------------------+--------------------------+
```

---
### **7.3.  Authentication Challenges**

인증 문제는 클라이언트가 향후 요청에서 인증 자격 증명을 제공하는 데 사용할 수 있는 메커니즘을 나타냅니다.

```text
   +--------------------+--------------------------+
   | Header Field Name  | Defined in...            |
   +--------------------+--------------------------+
   | WWW-Authenticate   | Section 4.1 of [RFC7235] |
   | Proxy-Authenticate | Section 4.3 of [RFC7235] |
   +--------------------+--------------------------+
```

---
### **7.4.  Response Context**

나머지 응답 헤더 필드는 이후 요청에서 잠재적으로 사용할 수 있는 대상 리소스에 대한 추가 정보를 제공합니다.

```text
   +-------------------+--------------------------+
   | Header Field Name | Defined in...            |
   +-------------------+--------------------------+
   | Accept-Ranges     | Section 2.3 of [RFC7233] |
   | Allow             | Section 7.4.1            |
   | Server            | Section 7.4.2            |
   +-------------------+--------------------------+
```

---
#### **7.4.1.  Allow**

"Allow" 헤더 필드에는 대상 리소스에서 지원하는 것으로 알려진 메서드 집합이 나열됩니다. 이 필드의 목적은 엄격하게 리소스와 관련된 유효한 요청 방법을 수신자에게 알리는 것입니다.

```text
     Allow = #method
```

사용 예:

```text
     Allow: GET, HEAD, PUT
```

허용되는 실제 메소드 세트는 각 요청 시 원본 서버에 의해 정의됩니다. 원본 서버는 405\(허용되지 않는 방법\) 응답에서 허용 필드를 생성해야 하며 다른 응답에서도 그렇게 할 수 있습니다. 비어 있는 허용 필드 값은 리소스가 메서드를 허용하지 않음을 나타냅니다. 이는 리소스가 구성에 의해 일시적으로 비활성화된 경우 405 응답에서 발생할 수 있습니다.\(MUST\)

프록시는 Allow 헤더 필드를 수정해서는 안 됩니다. 일반 메시지 처리 규칙에 따라 처리하기 위해 표시된 모든 메서드를 이해할 필요는 없습니다.\(MUST NOT\)

---
#### **7.4.2.  Server**

"Server" 헤더 필드에는 요청을 처리하기 위해 원본 서버에서 사용하는 소프트웨어에 대한 정보가 포함되어 있습니다. 이 소프트웨어는 보고된 상호 운용성 문제의 범위를 식별하는 데 도움을 주고 특정 서버 제한을 ​​피하기 위해 요청을 조정하거나 해결하기 위해 클라이언트에서 자주 사용됩니다. 서버 또는 운영 체제 사용에 관한 분석을 위해. 원서버는 응답에 서버 필드를 생성할 수 있습니다.\(MAY\)

```text
     Server = product *( RWS ( product / comment ) )
```

서버 필드 값은 하나 이상의 제품 식별자로 구성되며, 각각 뒤에는 0개 이상의 주석\(\[RFC7230\]의 섹션 3.2\)이 따르며, 이는 원본 서버 소프트웨어와 그 중요한 하위 제품을 함께 식별합니다. 관례적으로 제품 식별자는 원본 서버 소프트웨어를 식별하는 중요성의 내림차순으로 나열됩니다. 각 제품 식별자는 섹션 5.5.3에 정의된 대로 이름과 선택적 버전으로 구성됩니다.

```text
   Example:

     Server: CERN/3.0 libwww/2.17
```

원본 서버는 불필요하게 세분화된 세부 정보가 포함된 서버 필드를 생성해서는 안 되며 제3자가 하위 제품을 추가하는 것을 제한해야 합니다. 지나치게 길고 상세한 서버 필드 값은 응답 대기 시간을 늘리고 잠재적으로 공격자가 알려진 보안 허점을 찾아 악용하는 것을 \(약간\) 더 쉽게 만들 수 있는 내부 구현 세부 정보를 노출할 수 있습니다.\(SHOULD NOT\)

---
## **8.  IANA Considerations**
---
### **8.1.  Method Registry**

```text
   The "Hypertext Transfer Protocol (HTTP) Method Registry" defines the
   namespace for the request method token (Section 4).  The method
   registry has been created and is now maintained at
   <http://www.iana.org/assignments/http-methods>.
```

---
#### **8.1.1.  Procedure**

HTTP 메소드 등록에는 다음 필드가 포함되어야 합니다.\(MUST\)

```text
   o  Method Name (see Section 4)

   o  Safe ("yes" or "no", see Section 4.2.1)

   o  Idempotent ("yes" or "no", see Section 4.2.2)
```

o 사양 텍스트에 대한 포인터

이 네임스페이스에 추가할 값에는 IETF 검토가 필요합니다\(\[RFC5226\], 섹션 4.1 참조\).

---
#### **8.1.2.  Considerations for New Methods**

표준화된 방법은 일반적입니다. 즉, 특정 미디어 유형, 리소스 종류 또는 애플리케이션뿐만 아니라 모든 리소스에 잠재적으로 적용할 수 있습니다. 따라서 직교 기술은 직교 사양을 받을 자격이 있기 때문에 단일 응용 프로그램이나 데이터 형식에 국한되지 않는 문서에 새로운 방법을 등록하는 것이 좋습니다.

메시지 구문 분석\(\[RFC7230\]의 섹션 3.3\)은 메서드 의미 체계\(HEAD에 대한 응답 제외\)와 독립적이어야 하므로 새 메서드 정의는 구문 분석 알고리즘을 변경하거나 요청 또는 응답에서 메시지 본문의 존재를 금지할 수 없습니다. 메시지. 새 메서드 정의에서는 값이 "0"인 Content-Length 헤더 필드를 요구하여 길이가 0인 메시지 본문만 허용되도록 지정할 수 있습니다.

새로운 메서드 정의는 안전한지\(섹션 4.2.1\), 멱등성\(섹션 4.2.2\), 캐시 가능한지\(섹션 4.2.3\), 페이로드 본문에 어떤 의미가 있는 경우 페이로드 본문과 연관되는지를 나타내야 합니다. 요청 및 메소드가 헤더 필드 또는 상태 코드 의미를 어떻게 개선하는지에 대해 설명합니다. 새로운 메소드가 캐시 가능하다면 그 정의는 캐시가 응답을 저장하고 이를 사용하여 후속 요청을 충족할 수 있는 방법과 조건을 설명해야 합니다. 새로운 메서드는 조건부로 만들 수 있는지\(섹션 5.2\), 그렇다면 조건이 false일 때 서버가 어떻게 응답하는지 설명해야 합니다. 마찬가지로, 새로운 방법이 부분 응답 의미론\(\[RFC7233\]\)에 어느 정도 사용될 수 있다면 이 방법도 문서화해야 합니다.

- 참고: "M-"으로 시작하는 메서드 이름을 정의하지 마세요. 해당 접두사가 \[RFC2774\]에 의해 할당된 의미를 갖는 것으로 잘못 해석될 수 있기 때문입니다.

---
#### **8.1.3.  Registrations**

"HTTP\(Hypertext Transfer Protocol\) 메소드 레지스트리"가 아래 등록으로 채워졌습니다.

```text
   +---------+------+------------+---------------+
   | Method  | Safe | Idempotent | Reference     |
   +---------+------+------------+---------------+
   | CONNECT | no   | no         | Section 4.3.6 |
   | DELETE  | no   | yes        | Section 4.3.5 |
   | GET     | yes  | yes        | Section 4.3.1 |
   | HEAD    | yes  | yes        | Section 4.3.2 |
   | OPTIONS | yes  | yes        | Section 4.3.7 |
   | POST    | no   | no         | Section 4.3.3 |
   | PUT     | no   | yes        | Section 4.3.4 |
   | TRACE   | yes  | yes        | Section 4.3.8 |
   +---------+------+------------+---------------+
```

---
### **8.2.  Status Code Registry**

```text
   The "Hypertext Transfer Protocol (HTTP) Status Code Registry" defines
   the namespace for the response status-code token (Section 6).  The
   status code registry is maintained at
   <http://www.iana.org/assignments/http-status-codes>.
```

이 섹션은 이전에 \[RFC2817\]의 섹션 7.1에 정의된 HTTP 상태 코드에 대한 등록 절차를 대체합니다.

---
#### **8.2.1.  Procedure**

등록에는 다음 필드가 포함되어야 합니다.\(MUST\)

```text
   o  Status Code (3 digits)

   o  Short Description
```

o 사양 텍스트에 대한 포인터

HTTP 상태 코드 네임스페이스에 추가할 값에는 IETF 검토가 필요합니다\(\[RFC5226\], 섹션 4.1 참조\).

---
#### **8.2.2.  Considerations for New Status Codes**

현재 상태 코드로 정의되지 않은 응답에 대해 의미를 표현해야 하는 경우 새로운 상태 코드를 등록할 수 있습니다. 상태 코드는 일반적입니다. 이는 특정 미디어 유형, 리소스 종류 또는 HTTP 애플리케이션뿐만 아니라 모든 리소스에 잠재적으로 적용 가능합니다. 따라서 단일 애플리케이션에만 국한되지 않는 문서에 새 상태 코드를 등록하는 것이 좋습니다.

새로운 상태 코드는 섹션 6에 정의된 범주 중 하나에 속해야 합니다. 기존 파서가 응답 메시지를 처리할 수 있도록 하기 위해 새 상태 코드는 길이가 0인 페이로드 본문을 요구할 수 있지만 페이로드를 허용하지 않을 수 없습니다.

아직 널리 배포되지 않은 새로운 상태 코드에 대한 제안은 해당 코드가 등록될 것이라는 명확한 합의가 있을 때까지 해당 코드에 대한 특정 번호를 할당하지 않아야 합니다. 대신, 초기 초안에서는 "4NN" 또는 "3N0" .. "3N9"와 같은 표기법을 사용하여 조기에 숫자를 사용하지 않고 제안된 상태 코드의 클래스를 나타낼 수 있습니다.

새로운 상태 코드의 정의는 해당 상태 코드를 포함하는 응답\(예: 요청 헤더 필드 및/또는 메소드의 조합\)을 발생시키는 요청 조건과 응답 헤더 필드에 대한 종속성\(예: 무엇을 수행해야 하는지\)을 설명해야 합니다. 필드가 필수인지, 의미를 수정할 수 있는 필드가 무엇인지, 새 상태 코드와 함께 사용할 때 더 구체화되는 헤더 필드 의미가 무엇인지 등을 설명합니다.

새로운 상태 코드의 정의는 캐시 가능한지 여부를 지정해야 합니다. 발생하는 응답에 명시적인 최신 정보가 있는 경우 모든 상태 코드가 캐시될 수 있습니다. 그러나 캐시 가능으로 정의된 상태 코드는 명시적인 최신 정보 없이 캐시될 수 있습니다. 마찬가지로, 상태 코드의 정의는 캐시 동작에 제약을 둘 수 있습니다. 자세한 내용은 \[RFC7234\]를 참조하세요.

마지막으로, 새로운 상태 코드의 정의는 페이로드가 식별된 리소스와 암시적인 연관성을 가지고 있는지 여부를 나타내야 합니다\(섹션 3.1.4.1\).

---
#### **8.2.3.  Registrations**

상태 코드 레지스트리가 아래 등록으로 업데이트되었습니다.

```text
   +-------+-------------------------------+----------------+
   | Value | Description                   | Reference      |
   +-------+-------------------------------+----------------+
   | 100   | Continue                      | Section 6.2.1  |
   | 101   | Switching Protocols           | Section 6.2.2  |
   | 200   | OK                            | Section 6.3.1  |
   | 201   | Created                       | Section 6.3.2  |
   | 202   | Accepted                      | Section 6.3.3  |
   | 203   | Non-Authoritative Information | Section 6.3.4  |
   | 204   | No Content                    | Section 6.3.5  |
   | 205   | Reset Content                 | Section 6.3.6  |
   | 300   | Multiple Choices              | Section 6.4.1  |
   | 301   | Moved Permanently             | Section 6.4.2  |
   | 302   | Found                         | Section 6.4.3  |
   | 303   | See Other                     | Section 6.4.4  |
   | 305   | Use Proxy                     | Section 6.4.5  |
   | 306   | (Unused)                      | Section 6.4.6  |
   | 307   | Temporary Redirect            | Section 6.4.7  |
   | 400   | Bad Request                   | Section 6.5.1  |
   | 402   | Payment Required              | Section 6.5.2  |
   | 403   | Forbidden                     | Section 6.5.3  |
   | 404   | Not Found                     | Section 6.5.4  |
   | 405   | Method Not Allowed            | Section 6.5.5  |
   | 406   | Not Acceptable                | Section 6.5.6  |
   | 408   | Request Timeout               | Section 6.5.7  |
   | 409   | Conflict                      | Section 6.5.8  |
   | 410   | Gone                          | Section 6.5.9  |
   | 411   | Length Required               | Section 6.5.10 |
   | 413   | Payload Too Large             | Section 6.5.11 |
   | 414   | URI Too Long                  | Section 6.5.12 |
   | 415   | Unsupported Media Type        | Section 6.5.13 |
   | 417   | Expectation Failed            | Section 6.5.14 |
   | 426   | Upgrade Required              | Section 6.5.15 |
   | 500   | Internal Server Error         | Section 6.6.1  |
   | 501   | Not Implemented               | Section 6.6.2  |
   | 502   | Bad Gateway                   | Section 6.6.3  |
   | 503   | Service Unavailable           | Section 6.6.4  |
   | 504   | Gateway Timeout               | Section 6.6.5  |
   | 505   | HTTP Version Not Supported    | Section 6.6.6  |
   +-------+-------------------------------+----------------+
```

---
### **8.3.  Header Field Registry**

HTTP 헤더 필드는 \[BCP90\]에 정의된 대로 <http://www.iana.org/locationments/message-headers\>에 위치한 "메시지 헤더" 레지스트리 내에 등록됩니다.

---
#### **8.3.1.  Considerations for New Header Fields**

헤더 필드는 메시지, 페이로드, 대상 리소스 또는 연결\(예: 제어 데이터\)에 대한 데이터를 전달하는 데 사용할 수 있는 키:값 쌍입니다. HTTP 메시지의 헤더 필드 구문에 대한 일반적인 정의는 \[RFC7230\]의 섹션 3.2를 참조하세요.

헤더 필드 이름에 대한 요구 사항은 \[BCP90\]에 정의되어 있습니다.

새 필드를 정의하는 사양 작성자는 이름을 최대한 짧게 유지하고 헤더 필드가 인터넷에서 절대 사용되지 않는 한 이름 앞에 "X-"를 붙이지 않는 것이 좋습니다. \("X-" 접두사 관용구는 실제로 광범위하게 오용되었습니다. 접두사는 개인 이름이 새로 등록된 이름과 충돌하지 않도록 보장하므로 독점 소프트웨어 또는 인트라넷 처리 내에서 이름 충돌을 피하기 위한 메커니즘으로만 사용되도록 의도되었습니다. 인터넷 이름\(자세한 내용은 \[BCP178\] 참조\).

새로운 헤더 필드 값은 일반적으로 필요에 따라 \[RFC7230\]의 섹션 7에 정의된 확장을 사용하여 ABNF\(\[RFC5234\]\)를 사용하여 정의된 구문을 가지며 일반적으로 US-ASCII 문자 범위로 제한됩니다. 더 넓은 범위의 문자가 필요한 헤더 필드는 \[RFC5987\]에 정의된 것과 같은 인코딩을 사용할 수 있습니다.

원시 필드 값의 선행 및 후행 공백은 필드 구문 분석 시 제거됩니다\(\[RFC7230\]의 섹션 3.2.4\). 값의 선행 또는 후행 공백이 중요한 필드 정의는 quoted-string\(\[RFC7230\]의 섹션 3.2.6\)과 같은 컨테이너 구문을 사용해야 합니다.

쉼표\(","\)는 필드 값 사이의 일반 구분 기호로 사용되므로 필드 값에 허용되는 경우 주의해서 처리해야 합니다. 일반적으로 쉼표가 포함될 수 있는 구성 요소는 인용 문자열 ABNF 생성을 사용하여 큰따옴표로 보호됩니다.

예를 들어 텍스트 날짜와 URI\(둘 중 하나에 쉼표가 포함될 수 있음\)는 다음과 같은 필드 값으로 안전하게 전달될 수 있습니다.

```text
     Example-URI-Field: "http://example.com/a.html,foo",
                        "http://without-a-comma.example.com/"
     Example-Date-Field: "Sat, 04 May 1996", "Wed, 14 Sep 2005"
```

큰따옴표 구분 기호는 거의 항상 인용 문자열 생성에 사용됩니다. 큰따옴표 안에 다른 구문을 사용하면 불필요한 혼란이 발생할 수 있습니다.

많은 헤더 필드는 명명된 매개변수\(예: 섹션 3.1.1.5에 정의된 Content-Type\)를 포함하는 형식\(대소문자 구분 없음\)을 사용합니다. 매개 변수 값에 대해 따옴표 없는\(토큰\) 구문과 따옴표 붙은\(따옴표 붙은 문자열\) 구문을 모두 허용하면 수신자가 기존 구문 분석기 구성 요소를 사용할 수 있습니다. 두 가지 형식을 모두 허용하는 경우 매개변수 값의 의미는 사용된 구문과 독립적이어야 합니다\(예를 들어 섹션 3.1.1.1의 미디어 유형에 대한 매개변수 처리에 대한 참고 사항을 참조하세요\).

새로운 헤더 필드를 정의하는 사양 작성자는 다음을 문서화하는 것을 고려하는 것이 좋습니다.

o 필드가 단일 값인지 아니면 목록일 수 있는지 여부\(쉼표로 구분, \[RFC7230\]의 섹션 3.2 참조\).

- 목록 구문을 사용하지 않는 경우 필드가 여러 번 나타나는 메시지를 처리하는 방법을 문서화합니다\(합리적인 기본값은 필드를 무시하는 것이지만 이것이 항상 올바른 선택은 아닐 수도 있음\).

- 필드 정의가 목록 구문을 허용하지 않음에도 불구하고 중개자 및 소프트웨어 라이브러리는 여러 헤더 필드 인스턴스를 단일 필드로 결합할 수 있습니다. 강력한 형식을 사용하면 수신자가 이러한 상황을 발견할 수 있습니다\(좋은 예: 쉼표는 인용된 문자열 안에만 나타날 수 있으므로 "Content-Type", 나쁜 예: "위치", 쉼표는 URI 내부에 나타날 수 있음\).

o 헤더 필드를 사용할 수 있는 조건은 무엇입니까? 예를 들어, 응답이나 요청에서만, 모든 메시지에서, 특정 요청 방법에 대한 응답에서만 등.

o 필드가 원본 서버에 의해 저장되어야 하는지 여부

- PUT 요청 시 이를 이해합니다.

o 필드 의미가 기존 요청 방법이나 상태 코드와 같은 컨텍스트에 의해 추가로 정제되는지 여부.

o 연결 헤더 필드에 field-name을 나열하는 것이 적절한지 여부\(즉, 헤더 필드가 홉별\(hop-by-hop\)인 경우, \[RFC7230\]의 섹션 6.1 참조\)

o 중개자가 필드 값을 삽입, 삭제 또는 수정할 수 있는 조건은 무엇입니까?

o Vary 응답 헤더 필드에 field-name을 나열하는 것이 적절한지 여부\(예: 요청 헤더 필드가 원서버의 콘텐츠 선택 알고리즘에 의해 사용되는 경우, 섹션 7.1.4 참조\).

o 헤더 필드가 예고편에서 유용하거나 허용 가능한지 여부\(\[RFC7230\]의 섹션 4.1 참조\).

o 헤더 필드가 리디렉션 전반에 걸쳐 유지되어야 하는지 여부.

o 개인 정보 보호 관련 데이터 공개와 같은 추가 보안 고려 사항이 도입되는지 여부.

---
#### **8.3.2.  Registrations**

"메시지 헤더" 레지스트리가 다음 영구 등록으로 업데이트되었습니다.

```text
   +-------------------+----------+----------+-----------------+
   | Header Field Name | Protocol | Status   | Reference       |
   +-------------------+----------+----------+-----------------+
   | Accept            | http     | standard | Section 5.3.2   |
   | Accept-Charset    | http     | standard | Section 5.3.3   |
   | Accept-Encoding   | http     | standard | Section 5.3.4   |
   | Accept-Language   | http     | standard | Section 5.3.5   |
   | Allow             | http     | standard | Section 7.4.1   |
   | Content-Encoding  | http     | standard | Section 3.1.2.2 |
   | Content-Language  | http     | standard | Section 3.1.3.2 |
   | Content-Location  | http     | standard | Section 3.1.4.2 |
   | Content-Type      | http     | standard | Section 3.1.1.5 |
   | Date              | http     | standard | Section 7.1.1.2 |
   | Expect            | http     | standard | Section 5.1.1   |
   | From              | http     | standard | Section 5.5.1   |
   | Location          | http     | standard | Section 7.1.2   |
   | Max-Forwards      | http     | standard | Section 5.1.2   |
   | MIME-Version      | http     | standard | Appendix A.1    |
   | Referer           | http     | standard | Section 5.5.2   |
   | Retry-After       | http     | standard | Section 7.1.3   |
   | Server            | http     | standard | Section 7.4.2   |
   | User-Agent        | http     | standard | Section 5.5.3   |
   | Vary              | http     | standard | Section 7.1.4   |
   +-------------------+----------+----------+-----------------+
```

위 등록에 대한 변경 관리자는 "IETF\(iesg@ietf.org\) - Internet Engineering Task Force"입니다.

---
### **8.4.  Content Coding Registry**

```text
   The "HTTP Content Coding Registry" defines the namespace for content
   coding names (Section 4.2 of [RFC7230]).  The content coding registry
   is maintained at <http://www.iana.org/assignments/http-parameters>.
```

---
#### **8.4.1.  Procedure**

콘텐츠 코딩 등록에는 다음 필드가 포함되어야 합니다.\(MUST\)

```text
   o  Name

   o  Description
```

o 사양 텍스트에 대한 포인터

콘텐츠 코딩의 이름은 인코딩 변환이 동일하지 않는 한\(\[RFC7230\]의 섹션 4.2에 정의된 압축 코딩의 경우처럼\) 전송 코딩의 이름\(\[RFC7230\]의 섹션 4\)과 겹쳐서는 안 됩니다.\(MUST NOT\)

이 네임스페이스에 추가할 값은 IETF 검토\(\[RFC5226\]의 섹션 4.1 참조\)가 필요하며 이 섹션에 정의된 콘텐츠 코딩의 목적을 준수해야 합니다.\(MUST\)

---
#### **8.4.2.  Registrations**

"HTTP 콘텐츠 코딩 레지스트리"가 아래 등록으로 업데이트되었습니다.

```text
   +----------+----------------------------------------+---------------+
   | Name     | Description                            | Reference     |
   +----------+----------------------------------------+---------------+
   | identity | Reserved (synonym for "no encoding" in | Section 5.3.4 |
   |          | Accept-Encoding)                       |               |
   +----------+----------------------------------------+---------------+
```

---
## **9.  Security Considerations**

이 섹션은 개발자, 정보 제공자 및 사용자에게 HTTP 의미 체계 및 인터넷을 통해 정보를 전송하는 데 사용되는 HTTP 의미와 관련된 알려진 보안 문제를 알리기 위한 것입니다. 메시지 구문, 구문 분석 및 라우팅과 관련된 고려 사항은 \[RFC7230\]의 섹션 9에서 논의됩니다.

아래 고려 사항 목록은 완전한 것이 아닙니다. HTTP 의미론과 관련된 대부분의 보안 문제는 서버 측 애플리케이션\(HTTP 인터페이스 뒤의 코드\) 보안, 사용자 에이전트 보안에 관한 것입니다.

프로토콜의 보안보다는 HTTP를 통해 수신된 페이로드 처리 또는 일반적인 인터넷의 안전한 사용을 의미합니다. 다양한 조직에서는 웹 애플리케이션 보안에 대한 최신 연구\(예: \[OWASP\]\)에 대한 주제 정보와 링크를 유지 관리합니다.

---
### **9.1.  Attacks Based on File and Path Names**

원본 서버는 효과적인 요청 URI에서 리소스 표현으로의 매핑을 관리하기 위해 로컬 파일 시스템을 자주 사용합니다. 대부분의 파일 시스템은 악성 파일이나 경로 이름으로부터 보호하도록 설계되지 않았습니다. 따라서 원본 서버는 요청 대상을 파일, 폴더 또는 디렉터리에 매핑할 때 시스템에 특별한 의미를 갖는 이름에 액세스하지 않아야 합니다.

예를 들어 UNIX, Microsoft Windows 및 기타 운영 체제는 ".."를 경로 구성 요소로 사용하여 현재 디렉터리 수준보다 높은 디렉터리 수준을 나타내며 특별히 명명된 경로나 파일 이름을 사용하여 시스템 장치에 데이터를 보냅니다. 다른 유형의 스토리지 시스템에도 유사한 명명 규칙이 있을 수 있습니다. 마찬가지로, 로컬 저장 시스템은 유효하지 않거나 예상치 못한 문자를 처리할 때, 분해된 문자를 재구성할 때, 대소문자를 구분하지 않는 이름의 대소문자 정규화를 처리할 때 보안보다 사용자 친화성을 선호하는 성가신 경향이 있습니다.

이러한 특수 이름을 기반으로 한 공격은 서비스 거부\(예: 서버에 COM 포트에서 읽도록 지시\) 또는 제공되지 않을 구성 및 소스 파일 공개에 초점을 맞추는 경향이 있습니다.

---
### **9.2.  Attacks Based on Command, Code, or Query Injection**

원본 서버는 시스템 서비스 식별, 데이터베이스 항목 선택 또는 데이터 소스 선택 수단으로 URI 내의 매개변수를 사용하는 경우가 많습니다. 그러나 요청으로 수신된 데이터는 신뢰할 수 없습니다. 공격자는 명령 호출, 언어 해석기 또는 데이터베이스를 통해 전달될 때 명령, 코드 또는 쿼리로 잘못 해석될 수 있는 데이터를 포함하도록 요청 데이터 요소\(메서드, 요청 대상, 헤더 필드 또는 본문\)를 구성할 수 있습니다. 상호 작용.

예를 들어, SQL 주입은 요청 대상 또는 헤더 필드\(예: 호스트, 참조자 등\)의 일부에 추가 쿼리 언어가 삽입되는 일반적인 공격입니다. 수신된 데이터가 SELECT 문 내에서 직접 사용되는 경우 쿼리 언어는 단순 문자열 값 대신 데이터베이스 명령으로 해석될 수 있습니다. 이러한 유형의 구현 취약점은 예방하기가 쉽지만 매우 일반적입니다.

일반적으로 리소스 구현은 명령으로 처리되거나 해석되는 컨텍스트에서 요청 데이터의 사용을 피해야 합니다. 매개변수는 신뢰할 수 없는 데이터에 대해 준비되지 않은 인터페이스를 통해 전달되기보다는 고정 문자열과 비교되어 해당 비교 결과에 따라 작동되어야 합니다. 고정된 매개변수를 기반으로 하지 않은 수신된 데이터는 잘못 해석되는 것을 방지하기 위해 신중하게 필터링하거나 인코딩해야 합니다.

요청 데이터를 저장하고 나중에 처리할 때\(예: 로그 파일, 모니터링 도구 내에서 또는 포함된 스크립트를 허용하는 데이터 형식에 포함될 때\) 유사한 고려 사항이 적용됩니다.

---
### **9.3.  Disclosure of Personal Information**

클라이언트는 리소스와 상호 작용하기 위해 사용자가 제공한 정보\(예: 사용자 이름, 위치, 메일 주소, 비밀번호, 암호화 키 등\)와 사용자의 검색 활동에 대한 정보를 포함하여 대량의 개인 정보에 접근하는 경우가 많습니다. 시간\(예: 기록, 북마크 등\) 구현에서는 의도하지 않은 개인 정보 공개를 방지해야 합니다.

---
### **9.4.  Disclosure of Sensitive Information in URIs**

URI는 보안 리소스를 식별하는 경우에도 보안이 아닌 공유를 위한 것입니다. URI는 종종 디스플레이에 표시되고, 페이지가 인쇄될 때 템플릿에 추가되며, 보호되지 않은 다양한 책갈피 목록에 저장됩니다. 따라서 민감하거나 개인 식별이 가능하거나 공개 위험이 있는 정보를 URI에 포함시키는 것은 현명하지 않습니다.

서비스 작성자는 민감한 데이터 제출을 위해 GET 기반 양식을 피해야 합니다. 해당 데이터가 요청 대상에 배치되기 때문입니다. 많은 기존 서버, 프록시 및 사용자 에이전트는 제3자가 볼 수 있는 위치에 요청 대상을 기록하거나 표시합니다. 이러한 서비스는 대신 POST 기반 양식 제출을 사용해야 합니다.

Referer 헤더 필드는 요청이 발생한 컨텍스트에 대해 대상 사이트에 알려주므로 사용자의 즉각적인 검색 기록에 대한 정보와 참조 리소스의 URI에서 찾을 수 있는 개인 정보를 공개할 가능성이 있습니다. Referer 헤더 필드에 대한 제한 사항은 일부 보안 고려 사항을 다루기 위해 섹션 5.5.2에 설명되어 있습니다.

---
### **9.5.  Disclosure of Fragment after Redirects**

URI 참조 내에서 사용되는 조각 식별자는 요청으로 전송되지 않지만 구현자는 사용자 에이전트와 응답의 결과로 실행되는 모든 확장 프로그램 또는 스크립트에 해당 식별자가 표시된다는 점을 인식해야 합니다. 특히 리디렉션이 발생하고 원래 요청의 조각 식별자가 위치의 새 참조\(섹션 7.1.2\)에 의해 상속되면 이는 한 사이트의 조각을 다른 사이트에 공개하는 효과가 있을 수 있습니다. 첫 번째 사이트가 개인 정보를 조각으로 사용하는 경우 해당 상속을 차단하기 위해 다른 사이트로의 리디렉션에 \(아마도 비어 있는\) 조각 구성 요소가 포함되어 있는지 확인해야 합니다.

---
### **9.6.  Disclosure of Product Information**

User-Agent\(섹션 5.5.3\), Via\(\[RFC7230\]의 섹션 5.7.1\) 및 서버\(섹션 7.4.2\) 헤더 필드는 종종 해당 발신자의 소프트웨어 시스템에 대한 정보를 공개합니다. 이론적으로 이는 공격자가 알려진 보안 허점을 악용하기 더 쉽게 만들 수 있습니다. 실제로 공격자는 사용 중인 명백한 소프트웨어 버전에 관계없이 모든 잠재적인 허점을 시도하는 경향이 있습니다.

네트워크 방화벽을 통해 포털 역할을 하는 프록시는 방화벽 뒤의 호스트를 식별할 수 있는 헤더 정보 전송과 관련하여 특별한 예방 조치를 취해야 합니다. Via 헤더 필드를 사용하면 중개자가 민감한 시스템 이름을 가명으로 바꿀 수 있습니다.

---
### **9.7.  Browser Fingerprinting**

브라우저 핑거프린팅은 고유한 특성 세트를 통해 시간이 지남에 따라 특정 사용자 에이전트를 식별하는 일련의 기술입니다. 이러한 특성에는 TCP 동작, 기능 및 스크립팅 환경과 관련된 정보가 포함될 수 있지만 여기서 특히 흥미로운 점은 HTTP를 통해 통신할 수 있는 일련의 고유한 특성입니다. 핑거프린팅은 사용자가 다른 형태의 데이터 수집\(예: 쿠키\)에 대해 가질 수 있는 해당 제어 없이 시간이 지남에 따라 사용자 에이전트의 동작을 추적할 수 있기 때문에 개인 정보 보호 문제로 간주됩니다. 많은 범용 사용자 에이전트\(예: 웹 브라우저\)는 지문을 줄이기 위한 조치를 취했습니다.

지문 채취를 활성화할 만큼 충분히 고유한 정보를 서버에 공개할 수 있는 요청 헤더 필드가 많이 있습니다. From 헤더 필드가 가장 명확하지만 From은 사용자가 자체 식별을 원하는 경우에만 전송될 것으로 예상됩니다. 마찬가지로 쿠키 헤더 필드도 의도적으로

재식별이 가능하도록 설계되었으므로 지문 인식 문제는 사용자 에이전트 구성에 의해 쿠키가 비활성화되거나 제한되는 상황에만 적용됩니다.

User-Agent 헤더 필드에는 일반적으로 다른 특성과 결합될 때 특정 장치를 고유하게 식별하는 데 충분한 정보가 포함될 수 있습니다. 특히 사용자 에이전트가 사용자 시스템이나 확장에 대한 과도한 세부 정보를 보내는 경우 더욱 그렇습니다. 그러나 사용자가 가장 기대하지 않는 고유 정보의 소스는 Accept, Accept-Charset, Accept-Encoding 및 Accept-Language 헤더 필드를 포함한 사전 협상\(섹션 5.3\)입니다.

지문 채취 문제 외에도 Accept-Language 헤더 필드를 자세히 사용하면 사용자가 비공개 성격으로 간주할 수 있는 정보가 드러날 수 있습니다. 예를 들어, 특정 언어 세트를 이해하는 것은 특정 인종 그룹의 구성원과 밀접한 상관관계가 있을 수 있습니다. 이러한 개인 정보 손실을 제한하는 접근 방식은 사용자 에이전트가 허용 목록에 있는 사이트를 제외하고 Accept-Language 전송을 생략하는 것입니다. 아마도 언어 협상이 유용할 수 있음을 나타내는 Vary 헤더 필드를 감지한 후 상호 작용을 통해 가능합니다.

개인 정보 보호를 강화하기 위해 프록시를 사용하는 환경에서 사용자 에이전트는 사전 협상 헤더 필드를 보내는 데 보수적이어야 합니다. 높은 수준의 헤더 필드 구성 가능성을 제공하는 범용 사용자 에이전트는 너무 많은 세부 정보가 제공될 경우 발생할 수 있는 개인 정보 보호 손실에 대해 사용자에게 알려야 합니다. 극단적인 개인 정보 보호 조치로서 프록시는 릴레이된 요청에서 사전 협상 헤더 필드를 필터링할 수 있습니다.

---
## **10.  Acknowledgments**

\[RFC7230\]의 섹션 10을 참조하세요.

---
## **11.  References**
---
### **11.1.  Normative References**

\[RFC2045\] Freed, N. 및 N. Borenstein, "다목적 인터넷 메일 확장\(MIME\) 1부: 인터넷 메시지 본문 형식", RFC 2045, 1996년 11월.

\[RFC2046\] Freed, N. 및 N. Borenstein, "다목적 인터넷 메일 확장\(MIME\) 2부: 미디어 유형", RFC 2046, 1996년 11월.

\[RFC2119\] Bradner, S., "요구 사항 수준을 나타내기 위해 RFC에서 사용할 핵심 단어", BCP 14, RFC 2119, 1997년 3월.

\[RFC3986\] Berners-Lee, T., Fielding, R. 및 L. Masinter, "Uniform Resource Identifier\(URI\): 일반 구문", STD 66, RFC 3986, 2005년 1월.

\[RFC4647\] 필립스, A., Ed. 및 M. Davis, Ed., "언어 태그 일치", BCP 47, RFC 4647, 2006년 9월.

\[RFC5234\] Crocker, D., Ed. 및 P. Overell, "구문 사양을 위한 보강된 BNF: ABNF", STD 68, RFC 5234, 2008년 1월.

\[RFC5646\] Phillips, A., Ed. 및 M. Davis, Ed., "언어 식별을 위한 태그", BCP 47, RFC 5646, 2009년 9월.

\[RFC6365\] Hoffman, P. 및 J. Klensin, "다음에서 사용되는 용어

- IETF의 국제화", BCP 166, RFC 6365, 2011년 9월.

\[RFC7230\] Fielding, R., Ed. 및 J. Reschke, Ed., "하이퍼텍스트 전송 프로토콜\(HTTP/1.1\): 메시지 구문 및 라우팅", RFC 7230, 2014년 6월.

\[RFC7232\] Fielding, R., Ed. 및 J. Reschke, Ed., "Hypertext Transfer Protocol\(HTTP/1.1\): 조건부 요청", RFC 7232, 2014년 6월.

\[RFC7233\] Fielding, R., Ed., Lafon, Y., Ed. 및 J. Reschke, Ed., "하이퍼텍스트 전송 프로토콜\(HTTP/1.1\): 범위 요청", RFC 7233, 2014년 6월.

\[RFC7234\] Fielding, R., Ed., Nottingham, M., Ed. 및 J. Reschke, Ed., "하이퍼텍스트 전송 프로토콜\(HTTP/1.1\): 캐싱", RFC 7234, 2014년 6월.

\[RFC7235\] Fielding, R., Ed. 및 J. Reschke, Ed., "하이퍼텍스트 전송 프로토콜\(HTTP/1.1\): 인증", RFC 7235, 2014년 6월.

---
### **11.2.  Informative References**

\[BCP13\] Freed, N., Klensin, J. 및 T. Hansen, "미디어 유형 사양 및 등록 절차", BCP 13, RFC 6838, 2013년 1월.

\[BCP178\] Saint-Andre, P., Crocker, D. 및 M. Nottingham,

- "애플리케이션 프로토콜에서 "X-" 접두사 및 유사 구문 사용 중단", BCP 178, RFC 6648, 2012년 6월.

\[BCP90\] Klyne, G., Nottingham, M. 및 J. Mogul, "메시지 헤더 필드 등록 절차", BCP 90, RFC 3864, 2004년 9월.

```text
   [OWASP]    van der Stock, A., Ed., "A Guide to Building Secure Web
              Applications and Web Services", The Open Web Application
              Security Project (OWASP) 2.0.1, July 2005,
              <https://www.owasp.org/>.

   [REST]     Fielding, R., "Architectural Styles and the Design of
              Network-based Software Architectures",
              Doctoral Dissertation, University of California, Irvine,
              September 2000,
              <http://roy.gbiv.com/pubs/dissertation/top.htm>.
```

\[RFC1945\] Berners-Lee, T., Fielding, R. 및 H. Nielsen, "Hypertext Transfer Protocol -- HTTP/1.0", RFC 1945, 1996년 5월.

\[RFC2049\] Freed, N. 및 N. Borenstein, "다목적 인터넷 메일 확장\(MIME\) 5부: 적합성 기준 및 예", RFC 2049, 1996년 11월.

\[RFC2068\] Fielding, R., Gettys, J., Mogul, J., Nielsen, H. 및 T. Berners-Lee, "하이퍼텍스트 전송 프로토콜 - HTTP/1.1", RFC 2068, 1997년 1월.

\[RFC2295\] Holtman, K. 및 A. Mutz, "HTTP의 투명한 콘텐츠 협상", RFC 2295, 1998년 3월.

\[RFC2388\] Masinter, L., "양식에서 값 반환: multipart/form-data", RFC 2388, 1998년 8월.

\[RFC2557\] Palme, F., Hopmann, A., Shelness, N. 및 E. Stefferud, "HTML\(MHTML\)과 같은 집계 문서의 MIME 캡슐화", RFC 2557, 1999년 3월.

\[RFC2616\] Fielding, R., Gettys, J., Mogul, J., Frystyk, H.,

- Masinter, L., Leach, P. 및 T. Berners-Lee, "Hypertext Transfer Protocol -- HTTP/1.1", RFC 2616, 1999년 6월.

\[RFC2774\] Frystyk, H., Leach, P. 및 S. Lawrence, "HTTP

- 확장 프레임워크", RFC 2774, 2000년 2월.

\[RFC2817\] Khare, R. 및 S. Lawrence, "HTTP/1.1 내에서 TLS로 업그레이드", RFC 2817, 2000년 5월.

\[RFC2978\] Freed, N. 및 J. Postel, "IANA 문자 집합 등록 절차", BCP 19, RFC 2978, 2000년 10월.

\[RFC5226\] Narten, T. 및 H. Alvestrand, "RFC에서 IANA 고려 사항 섹션 작성 지침", BCP 26, RFC 5226, 2008년 5월.

\[RFC5246\] Dierks, T. 및 E. Rescorla, "TLS\(전송 계층 보안\) 프로토콜 버전 1.2", RFC 5246, 2008년 8월.

```text
   [RFC5322]  Resnick, P., "Internet Message Format", RFC 5322,
              October 2008.
```

\[RFC5789\] Dusseault, L. 및 J. Snell, "HTTP에 대한 패치 방법", RFC 5789, 2010년 3월.

\[RFC5905\] Mills, D., Martin, J., Ed., Burbank, J. 및 W. Kasch, "네트워크 시간 프로토콜 버전 4: 프로토콜 및 알고리즘 사양", RFC 5905, 2010년 6월.

\[RFC5987\] Reschke, J., "HTTP\(Hypertext Transfer Protocol\) 헤더 필드 매개변수에 대한 문자 세트 및 언어 인코딩", RFC 5987, 2010년 8월.

```text
   [RFC5988]  Nottingham, M., "Web Linking", RFC 5988, October 2010.

   [RFC6265]  Barth, A., "HTTP State Management Mechanism", RFC 6265,
              April 2011.
```

\[RFC6266\] Reschke, J., "HTTP\(하이퍼텍스트 전송 프로토콜\)에서 콘텐츠 처리 헤더 필드 사용", RFC 6266, 2011년 6월.

```text
   [RFC7238]  Reschke, J., "The Hypertext Transfer Protocol (HTTP)
              Status Code 308 (Permanent Redirect)", RFC 7238,
              June 2014.
```

---
# **Appendix A.  Differences between HTTP and MIME**

HTTP/1.1은 인터넷 메시지 형식\[RFC5322\] 및 다목적 인터넷 메일 확장\(MIME\) \[RFC2045\]에 대해 정의된 많은 구성을 사용하여 메시지 본문이 확장 가능한 헤더 필드와 함께 개방형 다양한 표현으로 전송될 수 있도록 합니다. 그러나 RFC 2045는 이메일에만 중점을 두고 있습니다. HTTP 애플리케이션에는 이메일과 다른 많은 특성이 있습니다. 따라서 HTTP에는 MIME과 다른 기능이 있습니다. 이러한 차이점은 바이너리 연결에 대한 성능을 최적화하고, 새로운 미디어 유형을 더 자유롭게 사용할 수 있도록 하며, 날짜 비교를 더 쉽게 만들고, 일부 초기 HTTP 서버 및 클라이언트의 관행을 인정하기 위해 신중하게 선택되었습니다.

이 부록에서는 HTTP가 MIME과 다른 특정 영역을 설명합니다. 엄격한 MIME 환경을 오가는 프록시와 게이트웨이는 이러한 차이점을 인식하고 필요한 경우 적절한 변환을 제공해야 합니다.

---
### **A.1.  MIME-Version**

HTTP는 MIME 호환 프로토콜이 아닙니다. 그러나 메시지에는 메시지를 구성하는 데 사용된 MIME 프로토콜 버전을 나타내는 단일 MIME-Version 헤더 필드가 포함될 수 있습니다. MIME-Version 헤더 필드의 사용은 메시지가 MIME 프로토콜\(\[RFC2045\]에 정의된 대로\)을 완전히 준수함을 나타냅니다. 발신자는 HTTP 메시지를 엄격한 MIME 환경으로 내보낼 때 \(가능한 경우\) 완전한 적합성을 보장할 책임이 있습니다.

---
### **A.2.  Conversion to Canonical Form**

MIME에서는 \[RFC2049\]의 섹션 4에 설명된 대로 전송되기 전에 인터넷 메일 본문 부분을 표준 형식으로 변환해야 합니다. 이 문서의 섹션 3.1.1.3은 HTTP를 통해 전송될 때 "텍스트" 미디어 유형의 하위 유형에 허용되는 형식을 설명합니다. \[RFC2046\]에서는 "텍스트" 유형의 콘텐츠가 줄 바꿈을 CRLF로 나타내도록 요구하고 줄 바꿈 시퀀스 외부에서 CR 또는 LF의 사용을 금지합니다. HTTP에서는 CRLF, Bare CR 및 Bare LF를 사용하여 텍스트 내용 내에서 줄 바꿈을 나타낼 수 있습니다.

HTTP에서 엄격한 MIME 환경으로의 프록시 또는 게이트웨이는 이 문서의 섹션 3.1.1.3에 설명된 텍스트 미디어 유형 내의 모든 줄 바꿈을 RFC 2049 표준 형식의 CRLF로 변환해야 합니다. 그러나 이는 Content-Encoding의 존재와 HTTP가 CR 및 LF를 각각 나타내기 위해 옥텟 13 및 10을 사용하지 않는 일부 문자 세트의 사용을 허용한다는 사실로 인해 복잡해질 수 있습니다.

원본 콘텐츠가 이미 정식 형식인 경우를 제외하고 변환하면 원본 콘텐츠에 적용된 모든 암호화 체크섬이 중단됩니다. 따라서 HTTP에서 이러한 체크섬을 사용하는 모든 콘텐츠에는 표준 형식을 사용하는 것이 좋습니다.

---
### **A.3.  Conversion of Date Formats**

HTTP/1.1은 날짜 비교 프로세스를 단순화하기 위해 제한된 날짜 형식 집합\(섹션 7.1.1.1\)을 사용합니다. 다른 프로토콜의 프록시와 게이트웨이는 메시지에 있는 모든 Date 헤더 필드가 HTTP/1.1 형식 중 하나를 준수하는지 확인하고 필요한 경우 날짜를 다시 작성해야 합니다.

---
### **A.4.  Conversion of Content-Encoding**

MIME에는 HTTP/1.1의 Content-Encoding 헤더 필드와 동일한 개념이 포함되어 있지 않습니다. 이는 미디어 유형에 대한 수정자 역할을 하기 때문에 HTTP에서 MIME 호환 프로토콜로의 프록시 및 게이트웨이는 메시지를 전달하기 전에 Content-Type 헤더 필드의 값을 변경하거나 표현을 디코딩해야 합니다. \(인터넷 메일에 대한 Content-Type의 일부 실험적 응용 프로그램에서는 Content-Encoding과 동등한 기능을 수행하기 위해 ";conversions=<content-coding\>"이라는 media-type 매개 변수를 사용했습니다. 그러나 이 매개 변수는 MIME 표준의 일부가 아닙니다. \).

---
### **A.5.  Conversion of Content-Transfer-Encoding**

HTTP는 MIME의 Content-Transfer-Encoding 필드를 사용하지 않습니다. MIME 호환 프로토콜에서 HTTP로의 프록시 및 게이트웨이는 응답 메시지를 HTTP 클라이언트에 전달하기 전에 모든 콘텐츠 전송 인코딩을 제거해야 합니다.

HTTP에서 MIME 호환 프로토콜까지의 프록시와 게이트웨이는 메시지가 해당 프로토콜의 안전한 전송을 위해 올바른 형식과 인코딩으로 되어 있는지 확인하는 일을 담당합니다. 여기서 "안전한 전송"은 사용 중인 프로토콜의 제한 사항에 따라 정의됩니다. 이러한 프록시 또는 게이트웨이는 대상 프로토콜을 통한 안전한 전송 가능성을 높이는 경우 적절한 콘텐츠 전송 인코딩으로 데이터를 변환하고 레이블을 지정해야 합니다.

---
### **A.6.  MHTML and Line Length Limitations**

MHTML \[RFC2557\] 구현과 코드를 공유하는 HTTP 구현은 MIME 줄 길이 제한을 인식해야 합니다. HTTP에는 이러한 제한이 없으므로 HTTP는 긴 줄을 접지 않습니다. HTTP에 의해 전송되는 MHTML 메시지는 행 길이 제한, 접기, 정규화 등을 포함하여 MHTML의 모든 규칙을 따릅니다. HTTP는 메시지 본문을 다음과 같이 전송하기 때문입니다.

페이로드이며 "multipart/byteranges" 유형\(\[RFC7233\]의 부록 A\)을 제외하고 여기에 포함될 수 있는 콘텐츠나 MIME 헤더 행을 해석하지 않습니다.

---
# **Appendix B.  Changes from RFC 2616**

이 개정판의 주요 변경 사항은 본질적으로 편집적인 것입니다. 즉, 메시징 구문을 추출하고 HTTP 의미 체계를 핵심 기능, 조건부 요청, 부분 요청, 캐싱 및 인증에 대한 별도의 문서로 분할하는 것입니다. 요구사항을 명확하게 목표로 삼도록 적합성 언어가 개정되었으며 표현과 페이로드, 리소스와 표현을 구별하기 위해 용어가 개선되었습니다.

```text
   A new requirement has been added that semantics embedded in a URI be
   disabled when those semantics are inconsistent with the request
   method, since this is a common cause of interoperability failure.
   (Section 2)

   An algorithm has been added for determining if a payload is
   associated with a specific identifier.  (Section 3.1.4.1)

   The default charset of ISO-8859-1 for text media types has been
   removed; the default is now whatever the media type definition says.
   Likewise, special treatment of ISO-8859-1 has been removed from the
   Accept-Charset header field.  (Section 3.1.1.3 and Section 5.3.3)

   The definition of Content-Location has been changed to no longer
   affect the base URI for resolving relative URI references, due to
   poor implementation support and the undesirable effect of potentially
   breaking relative links in content-negotiated resources.
   (Section 3.1.4.2)

   To be consistent with the method-neutral parsing algorithm of
   [RFC7230], the definition of GET has been relaxed so that requests
   can have a body, even though a body has no meaning for GET.
   (Section 4.3.1)

   Servers are no longer required to handle all Content-* header fields
   and use of Content-Range has been explicitly banned in PUT requests.
   (Section 4.3.4)

   Definition of the CONNECT method has been moved from [RFC2817] to
   this specification.  (Section 4.3.6)

   The OPTIONS and TRACE request methods have been defined as being
   safe.  (Section 4.3.7 and Section 4.3.8)

   The Expect header field's extension mechanism has been removed due to
   widely-deployed broken implementations.  (Section 5.1.1)

   The Max-Forwards header field has been restricted to the OPTIONS and
   TRACE methods; previously, extension methods could have used it as
   well.  (Section 5.1.2)

   The "about:blank" URI has been suggested as a value for the Referer
   header field when no referring URI is applicable, which distinguishes
   that case from others where the Referer field is not sent or has been
   removed.  (Section 5.5.2)

   The following status codes are now cacheable (that is, they can be
   stored and reused by a cache without explicit freshness information
   present): 204, 404, 405, 414, 501.  (Section 6)

   The 201 (Created) status description has been changed to allow for
   the possibility that more than one resource has been created.
   (Section 6.3.2)

   The definition of 203 (Non-Authoritative Information) has been
   broadened to include cases of payload transformations as well.
   (Section 6.3.4)

   The set of request methods that are safe to automatically redirect is
   no longer closed; user agents are able to make that determination
   based upon the request method semantics.  The redirect status codes
   301, 302, and 307 no longer have normative requirements on response
   payloads and user interaction.  (Section 6.4)

   The status codes 301 and 302 have been changed to allow user agents
   to rewrite the method from POST to GET.  (Sections 6.4.2 and 6.4.3)

   The description of the 303 (See Other) status code has been changed
   to allow it to be cached if explicit freshness information is given,
   and a specific definition has been added for a 303 response to GET.
   (Section 6.4.4)

   The 305 (Use Proxy) status code has been deprecated due to security
   concerns regarding in-band configuration of a proxy.  (Section 6.4.5)

   The 400 (Bad Request) status code has been relaxed so that it isn't
   limited to syntax errors.  (Section 6.5.1)

   The 426 (Upgrade Required) status code has been incorporated from
   [RFC2817].  (Section 6.5.15)

   The target of requirements on HTTP-date and the Date header field
   have been reduced to those systems generating the date, rather than
   all systems sending a date.  (Section 7.1.1)

   The syntax of the Location header field has been changed to allow all
   URI references, including relative references and fragments, along
   with some clarifications as to when use of fragments would not be
   appropriate.  (Section 7.1.2)

   Allow has been reclassified as a response header field, removing the
   option to specify it in a PUT request.  Requirements relating to the
   content of Allow have been relaxed; correspondingly, clients are not
   required to always trust its value.  (Section 7.4.1)

   A Method Registry has been defined.  (Section 8.1)

   The Status Code Registry has been redefined by this specification;
   previously, it was defined in Section 7.1 of [RFC2817].
   (Section 8.2)

   Registration of content codings has been changed to require IETF
   Review.  (Section 8.4)
```

Content-Disposition 헤더 필드는 이제 \[RFC6266\]에 의해 정의되었으므로 제거되었습니다.

Content-MD5 헤더 필드는 부분 응답과 관련하여 일관되지 않게 구현되었기 때문에 제거되었습니다.

---
# **Appendix C.  Imported ABNF**

\[RFC5234\]의 부록 B.1에 정의된 대로 다음 핵심 규칙이 참조로 포함됩니다: ALPHA\(문자\), CR\(캐리지 리턴\), CRLF\(CR LF\), CTL\(컨트롤\), DIGIT\(십진수 0-9\) , DQUOTE\(큰따옴표\), HEXDIG\(16진수 0-9/A-F/a-f\), HTAB\(가로 탭\), LF\(줄 바꿈\), OCTET\(8비트 데이터 시퀀스\), SP\(공백\) 및 VCHAR\( 표시되는 모든 US-ASCII 문자\).

아래 규칙은 \[RFC7230\]에 정의되어 있습니다.

```text
     BWS           = <BWS, see [RFC7230], Section 3.2.3>
     OWS           = <OWS, see [RFC7230], Section 3.2.3>
     RWS           = <RWS, see [RFC7230], Section 3.2.3>
     URI-reference = <URI-reference, see [RFC7230], Section 2.7>
     absolute-URI  = <absolute-URI, see [RFC7230], Section 2.7>
     comment       = <comment, see [RFC7230], Section 3.2.6>
     field-name    = <comment, see [RFC7230], Section 3.2>
     partial-URI   = <partial-URI, see [RFC7230], Section 2.7>

     quoted-string = <quoted-string, see [RFC7230], Section 3.2.6>
     token         = <token, see [RFC7230], Section 3.2.6>
```

---
# **Appendix D.  Collected ABNF**

아래 수집된 ABNF에서 목록 규칙은 \[RFC7230\]의 섹션 1.2에 따라 확장됩니다.

```text
   Accept = [ ( "," / ( media-range [ accept-params ] ) ) *( OWS "," [
    OWS ( media-range [ accept-params ] ) ] ) ]
   Accept-Charset = *( "," OWS ) ( ( charset / "*" ) [ weight ] ) *( OWS
    "," [ OWS ( ( charset / "*" ) [ weight ] ) ] )
   Accept-Encoding = [ ( "," / ( codings [ weight ] ) ) *( OWS "," [ OWS
    ( codings [ weight ] ) ] ) ]
   Accept-Language = *( "," OWS ) ( language-range [ weight ] ) *( OWS
    "," [ OWS ( language-range [ weight ] ) ] )
   Allow = [ ( "," / method ) *( OWS "," [ OWS method ] ) ]

   BWS = <BWS, see [RFC7230], Section 3.2.3>

   Content-Encoding = *( "," OWS ) content-coding *( OWS "," [ OWS
    content-coding ] )
   Content-Language = *( "," OWS ) language-tag *( OWS "," [ OWS
    language-tag ] )
   Content-Location = absolute-URI / partial-URI
   Content-Type = media-type

   Date = HTTP-date

   Expect = "100-continue"
```

보낸 사람 = 사서함

```text
   GMT = %x47.4D.54 ; GMT

   HTTP-date = IMF-fixdate / obs-date

   IMF-fixdate = day-name "," SP date1 SP time-of-day SP GMT

   Location = URI-reference

   Max-Forwards = 1*DIGIT

   OWS = <OWS, see [RFC7230], Section 3.2.3>

   RWS = <RWS, see [RFC7230], Section 3.2.3>
   Referer = absolute-URI / partial-URI
   Retry-After = HTTP-date / delay-seconds

   Server = product *( RWS ( product / comment ) )

   URI-reference = <URI-reference, see [RFC7230], Section 2.7>
   User-Agent = product *( RWS ( product / comment ) )

   Vary = "*" / ( *( "," OWS ) field-name *( OWS "," [ OWS field-name ]
    ) )

   absolute-URI = <absolute-URI, see [RFC7230], Section 2.7>
   accept-ext = OWS ";" OWS token [ "=" ( token / quoted-string ) ]
   accept-params = weight *accept-ext
   asctime-date = day-name SP date3 SP time-of-day SP year

   charset = token
   codings = content-coding / "identity" / "*"
   comment = <comment, see [RFC7230], Section 3.2.6>
   content-coding = token

   date1 = day SP month SP year
   date2 = day "-" month "-" 2DIGIT
   date3 = month SP ( 2DIGIT / ( SP DIGIT ) )
   day = 2DIGIT
   day-name = %x4D.6F.6E ; Mon
    / %x54.75.65 ; Tue
    / %x57.65.64 ; Wed
    / %x54.68.75 ; Thu
    / %x46.72.69 ; Fri
    / %x53.61.74 ; Sat
    / %x53.75.6E ; Sun
   day-name-l = %x4D.6F.6E.64.61.79 ; Monday
    / %x54.75.65.73.64.61.79 ; Tuesday
    / %x57.65.64.6E.65.73.64.61.79 ; Wednesday
    / %x54.68.75.72.73.64.61.79 ; Thursday
    / %x46.72.69.64.61.79 ; Friday
    / %x53.61.74.75.72.64.61.79 ; Saturday
    / %x53.75.6E.64.61.79 ; Sunday
   delay-seconds = 1*DIGIT

   field-name = <comment, see [RFC7230], Section 3.2>

   hour = 2DIGIT

   language-range = <language-range, see [RFC4647], Section 2.1>
   language-tag = <Language-Tag, see [RFC5646], Section 2.1>

   mailbox = <mailbox, see [RFC5322], Section 3.4>
   media-range = ( "*/*" / ( type "/*" ) / ( type "/" subtype ) ) *( OWS
    ";" OWS parameter )

   media-type = type "/" subtype *( OWS ";" OWS parameter )
   method = token
   minute = 2DIGIT
   month = %x4A.61.6E ; Jan
    / %x46.65.62 ; Feb
    / %x4D.61.72 ; Mar
    / %x41.70.72 ; Apr
    / %x4D.61.79 ; May
    / %x4A.75.6E ; Jun
    / %x4A.75.6C ; Jul
    / %x41.75.67 ; Aug
    / %x53.65.70 ; Sep
    / %x4F.63.74 ; Oct
    / %x4E.6F.76 ; Nov
    / %x44.65.63 ; Dec

   obs-date = rfc850-date / asctime-date

   parameter = token "=" ( token / quoted-string )
   partial-URI = <partial-URI, see [RFC7230], Section 2.7>
   product = token [ "/" product-version ]
   product-version = token
   quoted-string = <quoted-string, see [RFC7230], Section 3.2.6>
   qvalue = ( "0" [ "." *3DIGIT ] ) / ( "1" [ "." *3"0" ] )

   rfc850-date = day-name-l "," SP date2 SP time-of-day SP GMT

   second = 2DIGIT
   subtype = token

   time-of-day = hour ":" minute ":" second
   token = <token, see [RFC7230], Section 3.2.6>
   type = token

   weight = OWS ";" OWS "q=" qvalue

   year = 4DIGIT
```

---
# **Index**

```text
   1
      1xx Informational (status code class)  50

   2
      2xx Successful (status code class)  51

   3
      3xx Redirection (status code class)  54

   4
      4xx Client Error (status code class)  58

   5
      5xx Server Error (status code class)  62

   1
      100 Continue (status code)  50
      100-continue (expect value)  34
      101 Switching Protocols (status code)  50

   2
      200 OK (status code)  51
      201 Created (status code)  52
      202 Accepted (status code)  52
      203 Non-Authoritative Information (status code)  52
      204 No Content (status code)  53
      205 Reset Content (status code)  53

   3
      300 Multiple Choices (status code)  55
      301 Moved Permanently (status code)  56
      302 Found (status code)  56
      303 See Other (status code)  57
      305 Use Proxy (status code)  58
      306 (Unused) (status code)  58
      307 Temporary Redirect (status code)  58

   4
      400 Bad Request (status code)  58
      402 Payment Required (status code)  59
      403 Forbidden (status code)  59
      404 Not Found (status code)  59
      405 Method Not Allowed (status code)  59
      406 Not Acceptable (status code)  59
      408 Request Timeout (status code)  60
      409 Conflict (status code)  60

      410 Gone (status code)  60
      411 Length Required (status code)  61
      413 Payload Too Large (status code)  61
      414 URI Too Long (status code)  61
      415 Unsupported Media Type (status code)  62
      417 Expectation Failed (status code)  62
      426 Upgrade Required (status code)  62

   5
      500 Internal Server Error (status code)  63
      501 Not Implemented (status code)  63
      502 Bad Gateway (status code)  63
      503 Service Unavailable (status code)  63
      504 Gateway Timeout (status code)  63
      505 HTTP Version Not Supported (status code)  64
```

ㅏ

- Accept 헤더 필드 38 Accept-Charset 헤더 필드 40 Accept-Encoding 헤더 필드 41 Accept-Language 헤더 필드 42 Allow 헤더 필드 72

```text
   C
      cacheable  24
      compress (content coding)  11
      conditional request  36
      CONNECT method  30
      content coding  11
      content negotiation  6
      Content-Encoding header field  12
      Content-Language header field  13
      Content-Location header field  15
      Content-Transfer-Encoding header field  89
      Content-Type header field  10

   D
      Date header field  67
      deflate (content coding)  11
      DELETE method  29

   E
      Expect header field  34
```

에프

- 헤더 필드 44에서

G

- GET 메소드 24 문법 Accept 38 Accept-Charset 40 Accept-Encoding 41 accept-ext 38 Accept-Language 42 accept-params 38 허용 72 asctime-date 66 charset 9 코딩 41 content-coding 11 Content-Encoding 12 Content-Language 13 Content -위치 15 콘텐츠 유형 10 날짜 67 날짜1 65 일 65 요일 이름 65 요일 이름-l 65 지연 초 69 예상 34 시작 44 GMT 65 시간 65 HTTP 날짜 65 IMF-수정 날짜 65 언어 범위 42 언어 태그 13 위치 68 Max-Forwards 36 미디어 범위 38 미디어 유형 8 방법 21분 65 월 65 obs-date 66 매개변수 8 제품 46 제품 버전 46 qvalue 38 Referer 45 Retry-After 69 rfc850-date 66 초 65

```text
         Server  73
         subtype  8
         time-of-day  65
         type  8
         User-Agent  46
         Vary  70
         weight  38
         year  65
      gzip (content coding)  11

   H
      HEAD method  25

   I
      idempotent  23

   L
      Location header field  68

   M
      Max-Forwards header field  36
      MIME-Version header field  89

   O
      OPTIONS method  31

   P
      payload  17
      POST method  25
      PUT method  26

   R
      Referer header field  45
      representation  7
      Retry-After header field  69

   S
      safe  22
      selected representation  7, 71
      Server header field  73
      Status Codes Classes
         1xx Informational  50
         2xx Successful  51
         3xx Redirection  54
         4xx Client Error  58
         5xx Server Error  62

   T
      TRACE method  32

   U
      User-Agent header field  46

   V
      Vary header field  70

   X
      x-compress (content coding)  11
      x-gzip (content coding)  11
```

---
# **Authors' Addresses**

```text
   Roy T. Fielding (editor)
   Adobe Systems Incorporated
   345 Park Ave
   San Jose, CA  95110
   USA

   EMail: fielding@gbiv.com
   URI:   http://roy.gbiv.com/

   Julian F. Reschke (editor)
   greenbytes GmbH
   Hafenweg 16
   Muenster, NW  48155
   Germany

   EMail: julian.reschke@greenbytes.de
   URI:   http://greenbytes.de/tech/webdav/
```
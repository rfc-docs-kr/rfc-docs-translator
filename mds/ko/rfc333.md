

```text
Network Working Group                                       Bob Bressler
Request for Comments: 333                           MIT/Dynamic Modeling
NIC # 9926                                                    Dan Murphy
Category: C9 (experimentation)                                 BBN/TENEX
Obsoletes: 62                                                Dave Walden
Updates: none                                                    BBN/IMP
                                                             15 May 1972

        A PROPOSED EXPERIMENT WITH A MESSAGE SWITCHING PROTOCOL
```

---
# **CONTENTS**

```text
   Introduction ..................................................  1
   Some Background ...............................................  2
   References ....................................................  3
   MSP Specification .............................................  4
   Issue .........................................................  8
   Message Header ................................................ 10
   Examples ...................................................... 15
   TELNET ........................................................ 16
   The Information Operator ...................................... 16
   Unique Port Numbers ........................................... 20
   Flow Chart .................................................... 23
   MSP Variations ................................................ 25
   Appendix ...................................................... 26
```

---
# **INTRODUCTION**

MSP\(메시지 전환 프로토콜\)는 해당 포트 간에 메시지를 전환하는 기능을 가진 시스템입니다.

예를 들어, 각 인터페이스 메시지 프로세서에는 MSP 구현이 있습니다. 우리는 컴퓨터 운영 체제에서 통신 네트워크를 효과적으로 활용하려면 MSP에 대한 더 나은 이해가 필요하다고 믿습니다. 특히 우리는 ARPANET\(ARPA 컴퓨터 네트워크\)에 구현된 NCP\(네트워크 제어 프로그램\)가 네트워킹의 통신 측면을 적절하게 강조하지 않는다고 생각합니다. 즉, 시스템 측의 특정 거부감을 반영합니다. 사람들은 우리가 "스트림 지향"이라고 부르는 것에서 벗어나려고 합니다. 우리는 현재 NCP를 이용한 네트워크 개발과 별도로 MSP를 고려한 NCP 수준 소프트웨어 설계를 다시 생각해 볼 것을 제안합니다.

이 노트의 목적은 MSP를 중심으로 ARPANET에서 가장 낮은 수준의 호스트-호스트 프로토콜을 구성하는 방법과 이 구성이 호스트 소프트웨어 구현에 어떻게 영향을 미칠 것인지를 스케치하는 것입니다.

---
# **SOME BACKGROUND**

지난 몇 주 동안 여러 ARPA 네트워크 호스트 컴퓨터에서 라인 스위칭 개념이 아닌 메시지 스위칭 개념을 기반으로 한 프로토콜을 따르는 NCP를 실험적으로 구현할 가능성에 대해 상당한 비공식적 논의가 있었습니다. \(NIC 문서 8246, ARPA 네트워크용 호스트/호스트 프로토콜의 6페이지 첫 번째 단락에 있는 괄호 문장 참조\) 이 토론에 참여한 사람은 Bob Bressler\(MIT/Dynamic Modeling\) Steve Crocker\(ARPA\), Will Crowther\(BBN/IMP\), Tom Knight\(MIT/AI\), Alex McKenzie\(BBN/IMP\), Bob Metcalfe\(MIT/Dynamic\)입니다. 모델링\), Dan Murphy\(BBN/TENEX\), Jon Postel\(UCLA/NMC\) 및 Dave Walden\(BBN/IMP\).

이 토론 중에 몇 가지 흥미로운 점과 결론이 도출되었습니다.

1. Bressler는 Dynamic Modeling PDP-10을 위한 메시지 교환 프로세스 간 통신 시스템을 구현하고 이를 확장하여 Dynamic Modeling PDP-10과 AI PDP-10의 프로세스 간 프로세스 간 통신에 사용할 수 있습니다. 그는 그것이 자신의 NCP보다 훨씬 작은 규모라고 보고했습니다.

1. Murphy는 메시지 전환을 기반으로 하는 호스트/호스트 프로토콜이 실험적으로 구현될 수 있으며 실험을 위해 남겨둔 링크 중 일부를 사용하여 실제 호스트/호스트 프로토콜과 병렬로 실행될 수 있다고 언급했습니다. 또한 Murphy는 이 실험적인 메시지 전환 프로토콜이 TENEX에서 구현되면 수많은 \(TENEX\) 사이트가 쉽게 실험에 참여할 수 있다고 언급했습니다.

1. Bressler가 메시지 전환 프로토콜\*을 지정하는 데 약간의 노력을 기울여야 하며 이 사양이 상대적으로 구현하기 쉬워 보인다면 Murphy와 Bressler는 이를 구현하기 위한 자원을 찾기 위해 진지한 시도를 해야 한다는 것이 토론자들의 합의입니다. 두 개의 BBN TENEX와 MIT 동적 모델링 및 AI 기계에 대한 실험 프로토콜입니다.

1. MSP는 메시지 스위칭 프로토콜\(Message Switching Protocol\)의 약어로 선택되었으며 링크 192-195는 MSP 실험에 사용하도록 예약되었습니다.

```text
   -------------
   *This note fulfills any obligation Bressler may have incurred to
   produce an MSP specification.
```

우리는 이 실험과 관련하여 네트워크 실무 그룹의 의견과 제안을 요청합니다. 그러나 의견과 제안을 매우 높이 평가하지만 이는 제한된 실험이고 ARPA 네트워크의 현재 호스트/호스트 프로토콜을 대체하는 프로토콜을 지정하려는 시도가 아니기 때문에 제안을 임의로 거부할 수 있습니다.

---
# **REFERENCES**

다음 참고 자료를 숙지하면 이 노트의 나머지 부분을 읽는 데 도움이 될 것입니다.

- 1\) NIC 문서 8246, ARPA 네트워크용 호스트/호스트 프로토콜

- 2\) Telnet 프로토콜의 NIC 문서 9348

```text
      3) NIC document 7101, OFFICIAL INITIAL CONNECTION PROTOCOL,
         DOCUMENT # 2
```

- 4\) 리소스 공유 컴퓨터 네트워크의 프로세스 간 통신 시스템, CACM, 1972년 4월.

참고문헌 4는 RFC 62의 개정판입니다. 우리는 독자가 현재 RFC를 읽기 전에 참고문헌 4를 숙지할 것을 적극 권장합니다. 참고문헌 4의 재판본이 부록으로 첨부되어 있습니다.

---
# **MSP SPECIFICATION**

우리의 MSP는 본질적으로 네 번째 참조의 섹션 3에 설명된 프로세스 간 통신 시스템을 일반화한 것입니다. \(이제 참조 4의 섹션 3에 제시된 프로세스 간 통신 시스템을 언급해야 한다면 이를 "IPC"라고 부르겠습니다.\) MSP를 사용하여 통신하는 두 프로세스의 경우 전송하려는 프로세스는 어떤 의미에서 실행되어야 합니다. SEND와 수신을 원하는 프로세스는 어떤 의미에서 RECEIVE를 실행해야 합니다. SEND 및 RECEIVE는 사실상 어딘가에서 랑데뷰하고 전송이 허용됩니다. RECEIVE를 사용하면 FROM-TO-PORT-ID, TO-PORT-ID 및 RENDEZVOUS HOST가 지정됩니다. SEND를 사용하면 from-port-id, to-port-id, 랑데부 호스트 및 \(아마도\) 전송될 일부 데이터가 지정됩니다. SEND 및 RECEIVE를 사용하여 SENDER PROCESS에서 RECEIVER PROCESS로 메시지를 보내는 것은 다음과 같이 이루어집니다. 송신자 프로세스는 OUT-MESSAGE와 지정된 데이터를 SEND에서 랑데뷰 호스트로 지정된 호스트로 전송하도록 하는 SEND를 실행합니다. 동시에\(반드시 동시에는 아니지만\) 수신자 프로세스는 IN-MESSAGE가 RECEIVE에서 랑데부 호스트로 지정된 호스트로 전송되도록 하는 RECEIVE를 실행합니다. Rendezvous Host에서는 OUT 메시지와 IN 메시지가 RENDEZVOUS TABLE이라는 테이블에 입력됩니다. to-port-id, from-port-id 및 rendezvous Host와 일치하는 OUT 메시지와 IN 메시지가 감지되면 세 가지 작업이 수행됩니다. 1\) OUT 메시지와 데이터가 호스트로 전달됩니다. 2\) IN-메시지는 OUT-메시지의 소스인 호스트로 전달되고, 3\) IN-메시지와 OUT-메시지와 데이터는 랑데부 테이블에서 삭제됩니다. 랑데부 호스트에서.

랑데부 호스트가 송신 호스트 또는 수신 호스트이기도 하면 프로세스가 크게 단순화됩니다. 이러한 시퀀스를 열거하는 특정 알고리즘은 이 노트의 뒷부분에 나와 있습니다.

기본 개념을 명확히 하기 위해 SND, RCV 및 RNDZ라는 이름을 부여할 세 개의 호스트와 관련된 사례를 살펴보겠습니다. 호스트 SND에서 프로세스 S는 전송을 수행하고 호스트 RCV에서는 프로세스 R이 수신을 수행합니다. 둘 다 호스트 RNDZ에서 랑데뷰를 지정합니다.

```text
+--------------------+     +----------+     +--------------------+
|HOST SND            |     |          |     |HOST RCV            |
|                    |     |          |     |                    |
|                    |     |          |     |                    |
|       (PROCESS)    |     +----------+     |                    |
|       (   S   )    |         HOST         |                    |
|              \     |         RNDZ         |          (PROCESS) |
|              [DATA]|                      |          (  R    ) |
+--------------------+                      +--------------------+
```

---
# **Process S now executes a SEND with**

from-port-id = S, to-port-id = R, rendezvous-Host = RNDZ.

---
# **Host SND then creates a table entry in its rendezvous table.**

```text
+-----------------------------------+
|HOST SND            MSP   _ _ _    |
|           ------------->|_ _ _|   |
|         /        ^      |_ _ _| <-|-------RENDEZVOUS
|        /         |      |_ _ _|   |         TABLE
|(PROCESS)         |                |
|(   S   )         +-- SEND (from=S to=R; rend=RNDZ)
|        \                          |
|         [DATA]                    |
+-----------------------------------+
```

---
# **Host SND now sends an "OUT" message with S's data to Host RNDZ.**

```text
  HOST SND                               HOST RNDZ
+------------+                    +---------------------------+
|         MSP|  "OUT" + DATA      |MSP  _____  RENDEZVOUS     |
|            |--------------------|--> |_ _ _| TABLE          |
|            |  from=S; to=R      | \  |_ _ _|                |
|            |                    |  \ |_ _ _|                |
+------------+                    |   \             __        |
                                  |    \---------->|  | DATA  |
                                  |                |__|BUFFER |
                                  |                           |
                                  +---------------------------+
```

동시에 호스트 RCV에서 R을 처리하면 from-port-id = S, to-port-id = R 및 rendezvous-Host = RNDZ를 사용하여 RECEIVE를 실행합니다. 위와 같이 호스트 RCV는 랑데부 테이블에 테이블 항목을 생성하고 "IN" 메시지를 호스트 RNDZ로 보냅니다\(다음 그림 참조\).

\(이제 중간 호스트의 버퍼링에 대해 당황하지 마십시오. 당황할 시간은 나머지 주장을 읽고 이해한 후에입니다.\)

```text
     HOST RNDZ                          HOST RCV
+------------------------+       +-----------------------+
|                 MSP    |       |  MSP                  |
|       TABLE    _____   |       |   _____  TABLE        |
|             +-|_ _ _|  |  "IN" |  |_ _ _|              |
|             | |_ _ _|<-|----------|_ _ _|<-\           |RECEIVE
|             | |_ _ _|  |       |  |_ _ _|   \       <--|(from=S
|             |          |       |             \         |  to=R
|            _V_         |       |              \        | rend=RNDZ)
|    BUFFER |   |        |       |             (PROCESS) |
|           |___|        |       |             (   R   ) |
+------------------------+       +-----------------------+
```

이제 호스트 RNDZ는 호스트 SND의 "OUT"과 RCV의 R의 "IN"이 서로 일치하므로 호스트 RNDZ가 세 가지 작업을 수행함을 확인합니다.

1. "IN을 호스트 SND\(from-port-id = S, to-port-id = R, rendezvous-Host = RNDZ\)로 전송합니다.

1. "OUT" 및 버퍼링된 데이터를 호스트 RCV로 보냅니다\(from-port-id = S, to-port-id = R, rendezvous-Host =RNDZ\).

1. 테이블에서 항목을 지웁니다.

```text
   HOST SND                                           HOST RCV
   +------------------+        +------------+         +-------------+
   |                  |        |   TABLE    |         |             |
   |   TABLE  ___     |  "IN"  |    ___     |  "OUT"  |   ___  TABLE|
   |         |___|    |        |   |___|    |  + DATA |  |_ _|      |
   |         |___|<---|--------|---|___|----|---------|->|_ _|      |
   |         |___|    |        |   |___|    |         |  |_ _|      |
   | ( S )            |        +------------+         |        ( R )|
   |                  |          HOST RNDZ            |             |
   +------------------+                               +-------------+
```

호스트 RCV는 "OUT" 및 DATA를 가져오고 해당 테이블에서 일치하는 항목을 찾습니다. R을 처리할 데이터를 제공하고 해당 테이블에서 항목을 지웁니다.

호스트 SND는 테이블의 항목과 일치하는 "IN"을 얻고 해당 항목을 지웁니다. 이 메시지는 결합된 승인 역할을 하며 프로세스 S로 전달될 수 있습니다.

이제 전송이 완료되었습니다.

원격 랑데부 호스트를 지정하는 송신자와 수신자 프로세스 중 하나 또는 둘 다에 의해 네 가지 중요한 다른 종류의 전송이 이루어질 수 있습니다. 이는 다음 네 개의 그림에 설명되어 있습니다. 그림에서 교차된 선이나 평행한 점선은 랑데뷰를 표시하는 데 사용됩니다. "교차된 랑데부" 장소는 그림에 표시된 전송 유형 간의 중요한 차이점입니다. 원은 프로세스를 나타냅니다. 직사각형은 만남의 테이블입니다.

그림에는 "\(IN\)" 및 "\(OUT\)" 메시지가 프로세스로 전달되는 모습도 나와 있습니다. 괄호는 "IN"과 "OUT"이 개념적으로만 프로세스에 전달된다는 것을 나타내는 데 사용됩니다. 실제로 일어나는 일은 구현에 따라 다릅니다. SEND 또는 RECEIVE를 실행할 때 프로세스가 차단되면 프로세스가 활성화되어 추가 정보가 제공되지 않을 수 있습니다. 프로세스가 중단되어 IN의 to-port-id 또는 OUT의 from-port-id와 같은 일부 정보가 전달될 수 있습니다. 프로세스에는 실제로 완전한 IN 또는 OUT 메시지가 전달될 수 있습니다.

```text
      ------         _________           ------
     (      )       |         |         (      )
     (      ) SEND  |         | RECEIVE (      )
     (      )------>|--+  +---|<--------(      )
     (      )       |   \/    |         (      )
     (      ) (IN)  |   /\    |  (OUT)  (      )
     (      )<------|--+   +--|-------->(      )
     (______)       |_________| +DATA   (______)

     |<------------- Host K ------------------>|
```

- 보낸 사람의 호스트와의 만남

```text
      ----         _______               ______          ----
     (    )       |       |             |      |        (    )
     (    ) SEND  |       |      IN     |      | RECEIVE(    )
     (    )------>|-+  +--|<------------|------|<-------(    )
     (    )       |  \/   |             |      |        (    )
     (    ) (IN)  |  /\   |  OUT+DATA   |      | (OUT)  (    )
     (    )<------|-+  +--|------------>|------|------->(    )
     (____)       |_______|             |______| +DATA  (____)

     |<---- Host K ------>|<-- Network-->|<----- Host L ----->|
```

- 보낸 사람의 호스트와의 만남

```text
      ----         ______                _______          ----
     (    )       |      |              |       |        (    )
     (    ) SEND  |      |   OUT+DATA   |       | RECEIVE(    )
     (    )------>|------|------------->|-+  +--|<-------(    )
     (    )       |      |              |  \/   |        (    )
     (    ) (IN)  |      |      IN      |  /\   | (OUT)  (    )
     (    )<------|------|<-------------|-+  +--|------->(    )
     (    )       |      |              |       | +DATA  (    )
     (____)       |______|              |______ |        (____)

     |<---- Host K ----->|<-- Network-->|<----- Host L ----->|
```

- 수신자의 호스트와의 만남

```text
  ----         ______            _______            ______         ----
 (    )       |      |          |       |          |      |       (    )
 (    ) SEND  |      | OUT+DATA |       |    IN    |      |RECEIVE(    )
 (    )------>|------|--------->|-+  +--|<---------|------|<------(    )
 (    )       |      |          |  \/   |          |      |       (    )
 (    ) (IN)  |      |    IN    |  /\   |OUT+DATA  |      | (OUT) (    )
 (    )<------|------|<---------|-+  +--|--------->|------|------>(    )
 (    )       |      |          |       |          |      | +DATA (    )
 (____)       |______|          |______ |          |______|       (____)

 |<---- Host K ----->|<--Net-->|<-Host->|<--Net-->|<----- Host L ----->|
                                   M
```

- 중간 호스트와의 만남

---
# **ISSUES**
---
## **Timeouts.**

시간 초과 문제는 매우 까다로운 문제입니다. 일관된 시간 초과 시스템은 모든 것을 단순화하고 경합을 없애줍니다. 그러나 많은 호스트는 시간 초과, 특히 기간이 지정된 시간 초과를 사용하는 것을 꺼리거나 사용할 수 없습니다.

이러한 시간 초과가 없으면 시간 초과 시 IN 또는 OUT의 소스로 돌아가는 부정적인 승인이 필요할 수 있습니다. 그러나 이것은 이제 경주로 이어집니다.

부정적인 승인\(FLUSH 메시지라고 함\)은 호스트가 다음을 의미하기 위해 사용할 수 있습니다.

1. 내 테이블에는 자리가 없어요

1. 더 이상 사용 가능한 버퍼 공간이 없거나

1. 더 이상 테이블 항목/버퍼를 유지하고 싶지 않습니다.

- 일반적으로 우리는 호스트가 메시지를 보관하는 것이 더 이상 편리하지 않을 때마다 호스트가 IN 또는 OUT+ 데이터를 버릴 수 있어야 한다고 믿습니다. 이는 메시지 도착 즉시 이루어질 수 있습니다. 예를 들어, 호스트가 사용자 버퍼가 없는 트래픽을 버퍼링하기를 원하지 않는 경우입니다. 시간 초과 대신 프로세스가 SEND 또는 RECEIVE를 발행할 때마다 일치하는 RECEIVE 또는 SEND를 발행하여 이를 되돌릴 수 있습니다.

---
# **Blocking the Process After a Send or Receive.**

- 이것은 구현에 따라 달라지는 질문입니다. 일반적으로 SEND 이후 프로세스를 차단하는 것은 좋은 생각이 아니라고 생각합니다. 왜냐하면 다른 포트에 다른 작업을 수행하거나 심지어 RECEIVE를 수행하려고 할 수도 있기 때문입니다. 실제로 통신 프로세스가 자신이 수행하는 작업을 알고 있는 한 동일한 포트에 두 개 이상의 SEND를 수행하는 프로세스에서 본질적으로 잘못된 것은 없습니다. 물론 일부 통신 프로세스에서는 동일한 포트 간에 여러 개의 동시 메시지가 전송되는 것을 금지합니다. 예를 들어 TELNET에서는 이를 금지할 수 있습니다. 그러나 대역폭 증가 등의 이유로 두 프로세스는 여러 개의 동시 메시지를 원할 수도 있습니다. 이 경우 메시지 순서에 대해 걱정하는 것은 프로세스에 달려 있다고 생각합니다. 그러나 프로세스에서 메시지 순서를 관리하기를 원하는 사용자에게는 BBN 보고서 1822의 부록 F에 문서화된 IMP/Very Distant Host 인터페이스에 사용되는 방법을 참조합니다.

---
# **Message Buffering**

- 메시지 버퍼링과 관련하여 몇 가지 언급할 가치가 있는 사항이 있습니다. 첫째, 대부분의 OUT에는 아마도 데이터가 수반될 것입니다. 따라서 일반적으로 수신자 프로세스가 교체될 수 있으므로 수신자 호스트 모니터는 일부 데이터를 어딘가에 버퍼링할 준비가 되어 있어야 합니다. 필요한 버퍼링 양을 최소화하기 위해 모니터는 IMP의 이전 트래픽이 디스크나 드럼에 기록될 때까지 IMP의 추가 트래픽을 거부할 수 있습니다. 또는 모니터는 IMP에서 트래픽이 들어올 때 채워지는 메모리의 모니터 영역에 적은 수의 버퍼를 가질 수 있으며, 이 버퍼는 수신자 프로세스가 교체될 때 수신자 프로세스가 이전에 요청한 버퍼와 교체됩니다. RECEIVE가 더 긴 메시지 길이를 지정하지 않는 경우 길이가 최대 서브넷 메시지 크기보다 작을 수 있습니다. 물론 이는 강제될 수 있습니다. 마지막으로 메시지 크기에 주목하세요.

- receive-port-id 등은 IMP에서 들어오는 첫 144비트에서 사용할 수 있습니다. 메시지의 나머지 부분을 읽을 버퍼를 결정하기 전에 이 내용을 읽는 것이 유용할 수 있습니다.

---
# **Positive Acknowledgments**

- 시스템에는 특정 형태의 승인이 내장되어 있습니다. 수신 프로세스가 RECEIVE를 수행한 시점에 대한 정보는 항상 사용할 수 있습니다. 송신 호스트는 수신 호출이 발행될 때 "IN" 수신을 보장받습니다.

- 추가 형태의 승인 및 검증은 첫 번째 사용자 수준에서 구현될 수 있으며 고급 프로토콜은 아마도 그러한 루틴의 라이브러리를 개발할 것입니다.

---
# **MESSAGE HEADER**

- 다음 섹션에서는 호스트 대 호스트 메시지의 특정 형식과 주어진 메시지에 대한 적절한 응답을 설명하는 알고리즘을 다룹니다.

- 각 메시지는 다음 필드를 포함하는 144비트 헤더로 시작됩니다.

1. BBN 보고서 1822에 지정된 HOST-TO-IMP 리더\(32비트\)

1. 포트 ID\(즉, 메시지를 수신하는 포트의 ID\)\(24비트\)

```text
      3. MSG TYPE (8 bits) IN, OUT, FLUSH, etc.
```

1. 포트 ID\(즉, ID 또는 메시지를 보내는 포트\)에서\(24비트\)

```text
      5. initiating Host's table position (8 bits) see below.
```

1. HOST는 이 메시지\(8비트\)를 "소싱"합니다. 아래를 참조하세요.

```text
      7. RENDEZVOUS HOST (8 bits)
```

1. 데이터의 비트 수\(16비트\)

헤더 형식은 항목 크기가 단어 크기보다 큰 경우를 제외하고 16, 32, 36비트 단어가 있는 컴퓨터에서 데이터 항목이 단어 경계를 넘지 않도록 배열되었습니다. 단어 내의 실제 바이트 배열은 이러한 세 가지 단어 크기에 대한 다음 그림에 표시됩니다. 36비트 호스트의 경우 바이트 4와 13\(0부터 번호 매기기\)이 사용되지 않습니다. 2바이트 및 3바이트 항목은 지원되지 않습니다.

16비트 시스템의 포트 ID를 제외하고 크로스 워드 경계입니다. 패킹 및 언패킹 용이성에 대한 이러한 관심은 일반적인 편의를 위해 주어졌으며 특히 호스트는 메시지의 나머지 부분이 어디로 가야 하는지 결정하기 위해 인터럽트 수준에서 헤더를 검사하기를 원할 수 있습니다.

```text
   +-------------+-------------+
0  |  HOST/IMP   | DESTINATION |
   |   FLAGS     |             |
   +-------------+-------------+
1  |   LINK      | /////////// |
   |             | /////////// |
   +-------------+-------------+
2  | /////////// |             |
   | /////////// |             |
   +-------------+             |
3  |        TO PORT ID         |
   |                           |
   +-------------+-------------+
4  |  MESSAGE    |             |
   |   TYPE      |             |
   +-------------+             |
5  |        FROM PORT ID       |
   |                           |
   +-------------+-------------+
6  |  TABLE      | /////////// |
   |  POSITION   | /////////// |
   +-------------+-------------+
7  |  SOURCE     | RENDEZVOUS  |
   |   HOST      |   HOST      |
   +-------------+-------------+
8  |        BIT COUNT          |
   |                           |
   +-------------+-------------+
   |                           |
9  |           DATA            |
   //                         //
   |                           |
   +-------------+-------------+

         16-bit Host Format

   +-------------+
   |             |            ////////// = unused
   |             |            //////////
   +-------------+
       8 bits

   0             8            16            24            32     36
   +-------------+-------------+-------------+-------------+------+
0  | HOST/IMP    |   FOREIGN   |    LINK     | ////////////////// |
   |  FLAGS      |   HOST      |             | ////////////////// |
   +------+------+-------------+-------------+-------+-----+------+
1  | //// |        TO PORT ID                        |  MESSAGE   |
   | //// |                                          |   TYPE     |
   +------+------+-------------+-------------+-------------+------+
2  |               FROM PORT ID              |   TABLE     | //// |
   |                                         |   POSITION  | //// |
   +------+-------------+-------------+------+-------------+------+
3  | //// |   SOURCE    | RENDEZVOUS  |          BIT COUNT        |
   | //// |    HOST     |  HOST       |                           |
   +------+-------------+-------------+---------------------------+
   |                                                              |
4  |                                                              |
   //                          DATA                              //
   |                                                              |
   |                                                              |
   +-------------+-------------+-------------+-------------+------+

                         36-bit Host Format

   +-------------+-------------+-------------+-------------+
0  | HOST/IMP    |   FOREIGN   |    LINK     | /////////// |
   |  FLAGS      |   HOST      |             | /////////// |
   +-------------+-------------+-------------+-------------+
1  | /////////// |             TO PORT ID                  |
   |             |                                         |
   +-------------+-------------+-------------+-------------+
2  |  MESSAGE    |             FROM PORT ID                |
   |   TYPE      |                                         |
   +-------------+-------------+-------------+-------------+
3  |  TABLE      | /////////// |  SOURCE     | RENDEZVOUS  |
   |  POSITION   | /////////// |   HOST      |   HOST      |
   +-------------+-------------+-------------+-------------+
   |        BIT COUNT          |                           |
   |                           |                           |
   +-------------+-------------+                           |
   |                                                       |
   //                   DATA                              //
   |                                                       |
   +-------------+-------------+-------------+-------------+

                         32-bit Host Format
```

Host/IMP 리더 내의 필드는 NCP 프로그래머에게 이미 익숙하지만 이 필드에 대해 언급할 가치가 있는 두 가지 사항이 있습니다. 첫째, 목적지 필드에는 원래 랑데부 호스트의 번호가 포함되어 있습니다. 중간 사이트에서 랑데뷰한 후 대상 필드에는 랑데뷰한 메시지의 소스가 포함됩니다. 둘째, MSP 실험의 링크 필드에는 링크 번호 192-195만 포함될 수 있습니다. 우리는 MSP를 사용하여 전송될 수 있는 모든 메시지 중에서 이 4개 링크의 합리적인 할당을 파악하는 데 시간을 들이지 않았습니다. 한 가지 대안은 링크를 순환하여 두 호스트 사이의 "파이프" 대역폭을 늘리는 것입니다. 당분간은 이 문제에 대한 추가 고려가 이루어질 때까지 사이트의 각 호스트가 모든 통신에 하나의 \(고유\) 링크를 사용하는 것이 좋습니다.

이제 메시지 유형 필드에 표시해야 하는 메시지 유형은 거의 없습니다. SEND 또는 OUT 메시지에는 메시지 유형 2를, RECEIVE 또는 IN 메시지에는 메시지 3을 제안합니다. FLUSH가 사용되는 경우 메시지 유형 4는 FLUSH 메시지입니다.

랑데부 호스트 필드에는 설명이 필요하지 않습니다. 단, 랑데뷰가 발생한 후에는 해당 필드가 불필요하고 다른 용도로 사용될 수 있습니다.

비트 수는 OUT 메시지의 데이터 비트 수 또는 IN 메시지의 입력 버퍼\(헤더 제외\) 크기입니다. 따라서 송신자 프로세스는 IN 메시지를 수신할 때 IN 메시지 비트 카운트를 통해 수신자 프로세스가 OUT 메시지의 데이터 중 얼마나 많은 양을 승인했는지 알 수 있으며, 원하는 경우 이 지식을 사용하여 메시지의 나머지 부분을 재전송할 수 있습니다. 랑데뷰 후에는 OUT 비트 수가 IN 비트 수보다 크더라도 메시지의 모든 데이터를 IN 메시지의 소스에서 전송하는 것이 좋습니다. 따라서 수신자 호스트에서 모니터는 너무 길기 때문에 메시지를 폐기하고, 수신자 프로세스가 IN을 수행한 비트 수를 수신자 프로세스로 보내고 나머지는 버리는 옵션\(원하는 경우\)을 갖습니다. 또는 나머지 비트를 대기열에 추가하고 수신자 프로세스가 요청할 수 있는 비트가 더 있음을 수신자 프로세스에 어떻게든 알립니다.

to- 및 from-port-id 필드는 24비트 숫자입니다. 이 크기는 팁을 돕기 위해 선택되었습니다. 포트 ID의 처음 8비트는 이 포트 ID가 생성된 호스트의 번호여야 합니다. 포트가 사용되는 호스트일 필요는 없습니다. 이는 랑데뷰가 중간 사이트에서 발생하고 포트가 사이트에서 사이트로 이동할 수 있기 때문에 필요합니다. 처음 8비트가 모두 0인 모든 포트 ID는 네트워크 전체에서 사용하도록 예약하는 것이 좋습니다. 특히 24비트가 모두 0인 포트 ID는 "ANY"를 의미하는 데 사용됩니다. 이를 통해 다음과 같은 옵션이 제공됩니다.

- 모든 항목에서 특정 항목까지 수신

- 특정에서 특정으로 수신

- 특정 항목에서 임의 항목으로 보내기

```text
       and  SEND from SPECIFIC to SPECIFIC
```

이러한 옵션의 사용 예는 아래에 나와 있습니다.

우리가 생각하는 다른 옵션\(RECEIVE to ANY\) 및 \(SEND from ANY\)은 쓸모가 없지만 금지하지는 않습니다. 우리는 랑데뷰 호스트를 명시적으로 지정하지 않은 경우 사용자 시스템 호출에서 ANY 포트 ID를 사용하면 다음과 같이 기본 랑데뷰 사이트에 영향을 미칠 것이라고 믿습니다.

- 모든 사람으로부터 수신 - 수신자의 랑데부

- 특정 사람으로부터 수신 - 보낸 사람의 랑데부

- SEND to ANY--발신자의 랑데부

- 특정으로 보내기--발신자의 랑데부

호스트가 원하는 대로 ID의 덜 중요한 16비트를 사용할 수 있습니다. 예를 들어, 8비트는 프로세스 ID로 사용될 수 있고 8비트는 지정된 프로세스 내에서 채널 사양으로 사용될 수 있습니다. 각 호스트는 잘 알려진 포트와 같은 특별한 용도를 위해 중간 8비트가 모두 0인 포트 ID를 예약하는 것이 좋습니다.

인터럽트 수준에서 비용이 많이 드는 테이블 검색을 방지하기 위해 테이블 ​​위치 필드가 포함되었습니다. IN 및 OUT을 보내는 호스트는 IN 또는 OUT과 관련된 SEND 또는 RECEIVE의 랑데부 테이블 위치를 테이블 위치 필드에 넣습니다. 중간 호스트 랑데부에서는 일치하는 IN 및 OUT의 테이블 위치 필드가 교환되므로 메시지가 반대편 끝에 도착할 때 일치하는 SEND 및 RECEIVE를 빠르게 찾을 수 있습니다. MSP는 랑데뷰에서 교환을 수행해야 하지만, 물론 MSP는 IN 또는 OUT을 처음 전송할 때 테이블 위치 필드를 채울 필요가 없습니다. 이 경우 IN 또는 OUT에 도착하는 정보는 의미가 없습니다. 그러면 일반적인 알고리즘은 이 필드에 지정된 테이블 위치를 확인하고 실패할 경우 전체 테이블을 검색하는 것입니다.

소스 필드는 원래 이러한 메시지를 보내는 MSP에 의해 IN 및 OUT에 채워집니다. 랑데부에서 각 메시지의 소스는 최종 호스트로 전달되는 메시지에 보존됩니다. IN 또는 OUT이 프로세스에 도착하면 프로세스는 다음을 사용할 수 있습니다.

랑데부 호스트에 대한 이해를 업데이트하기 위한 소스 정보\(예: 대상 호스트와 랑데부 호스트가 다른 경우\)

---
# **EXAMPLES**
---
# **The typical example.**

우리는 포트와 발신자의 랑데부 사이의 사양을 사용하여 일반적으로 통신이 발생하는 것을 상상합니다. 예를 들어, TIP는 아마도 이 방법을 사용하여 다른 호스트로 전송하고 TIP가 요청할 때까지 다른 호스트로부터 확실히 수신할 것입니다. 이 "일반적인" 방법에서는 모니터가 도착하는 IN 메시지의 비트 수를 보고 이를 할당으로 사용한 다음 정확한 길이의 OUT 메시지를 시뮬레이션할 수도 있습니다.

---
# **The logging example**

수신자에서의 랑데부와 함께 SEND to SPECIFIC 및 RECEIVE from ANY의 예를 고려하십시오. 이 방법은 잘 알려진 to-port가 있는 일부 로깅 수신자 프로세스에서 사용될 수 있습니다. 예를 들어, 네트워크 전체의 여러 프로세스에서 통계가 전송되는 측정 프로그램입니다.

---
# **The program library example**

주어진 시간 공유 시스템 내에 네트워크의 모든 프로세스에서 사용할 수 있는 특정 라이브러리 루틴이 있다고 가정합니다. 라이브러리 프로세스에는 잘 알려진 포트에 항상 보류 중인 RECEIVE from ANY가 있습니다. 결국 일부 프로세스는 라이브러리 프로세스의 잘 알려진 포트로 메시지를 보냅니다. 이 메시지에는 처리할 데이터, 답변을 보내는 데 사용할 포트 및 금액이 포함됩니다. 라이브러리 프로세스는 돈의 일부를 가져와 보류 중인 RECEIVE from ANY가 있는 회계 프로세스의 잘 알려진 포트로 보냅니다. 그런 다음 라이브러리 프로세스는 데이터를 처리하고 이미 보류 중인 RECEIVE from SPECIFIC이 있는 대상에서 랑데뷰하는 SEND to SPECIFIC 메시지를 사용하여 서비스를 요청한 프로세스로 응답을 다시 보냅니다. 물론, 이 메시지에는 답변 외에도 요청 프로세스에서 발생하는 모든 변경 사항이 반환됩니다.

---
# **A comment**

우리의 예에서 볼 수 있듯이, 포트를 이동하는 것이 바람직할 때 가장 큰 이점이 있기 때문에 중간 호스트에서의 랑데뷰는 거의 수행되지 않을 것이라고 생각합니다\(이에 대한 논의는 참조 4 참조\). 우리는 모든 호스트가 다음 사항을 제공하는 것을 보고 싶습니다.

\(빈약한\) 이 목적을 위한 버퍼링 양이지만 필요하지는 않습니다. 이런 종류의 버퍼링을 약간 제공하는 것은 그리 어렵지 않습니다. 특히 호스트는 처리할 수 없는 메시지를 버릴 수 있기 때문입니다.

\(이 페이지는 며칠 내에 MSP 하의 텔넷에 대한 더 나은 설명으로 대체될 예정입니다--DCW\)

---
# **TELNET**

두 개의 양방향 통신 경로\(하나는 데이터용, 다른 하나는 제어용\)를 유지하는 한 쌍의 Telnet 프로그램을 가정해 보겠습니다. 또한 편의상 포트 ID가 다음과 같다고 가정하겠습니다.

- WRITE-Control-ID가 N인 경우 --

```text
         READ-CONTROL-ID=N+1,

         WRITE-DATA=N+2,

         READ-DATA=N+3.
```

초기 상태는 READ-FROM-ANY 보류 상태로 앉아 있는 Telnet 서버입니다.

사용자 Telnet은 이제 SERVER의 WRITE-Control-ID의 PORT-ID를 포함하는 데이터 필드와 함께 SEND-TO-SPECIFIC을 발행합니다. 이 메시지는 사용자 Telnet의 WRITE-Control-ID에서 전송됩니다.

따라서 모든 포트 ID는 Telnet 사용자가 지정하므로 원하는 경우 번호 하나만 기억하고 나머지는 파생하면 됩니다. 사용자 Telnet이 제공한 포트 ID에는 호스트 ID와 ID를 고유하게 만드는 기타 정보가 포함되어 있으므로 고유성이 유지됩니다.

이제 이러한 통신 경로가 설정되었으므로 두 프로세스는 설정된 Telnet 프로토콜에 따라 데이터 및 제어 정보를 교환할 수 있습니다.

---
# **THE INFORMATION OPERATOR**

메시지 스위칭 프로토콜 자체는 포트 ID 사용에 대해 고정된 요구 사항을 부과하지 않으며 프로세스 식별 문제는 통신에 사용되는 수단과 다소 분리되어 있습니다. 그러나 이는 프로세스 간 통신의 전체 문제 중 상당 부분을 차지하므로 여기서는 프로세스 식별을 처리하는 기능인 정보 운영자를 지정합니다.

프로세스 식별 체계의 한 가지 목표는 프로세스가 고유성을 보장하고 사용자에게 의미 있는 정보를 포함할 수 있는 자체 식별자를 선택할 수 있는 수단을 제공하는 것입니다. 효율성 문제로 인해 포트 ID 자체가 이 목적을 달성할 만큼 충분히 커지지 못합니다. 효율성 문제는 제쳐두고, 프로세스가 자신을 식별하기 위해 임의 길이의 문자열을 사용하도록 허용하는 것이 이상적인 것으로 보입니다. 예를 들어 사용자가 프로세스 식별 문자열에 자신의 이름을 포함하는 규칙을 따르면 고유성을 쉽게 보장할 수 있습니다. 또한 이름의 나머지 부분은 사용자에게 분명한 이점과 편의성을 제공하면서 사용과 관련된 의미를 갖도록 선택할 수 있습니다.

한 가지 해결책은 기호 식별자가 모든 메시지가 아닌 일부 초기 통신 단계에서만 사용되는 규칙을 확립하는 것입니다. 즉, 프로세스는 처음에는 기호 식별자를 사용하여 서로를 식별하지만 동시에 모든 후속 메시지에 사용되는 로컬 포트 ​​식별자를 교환합니다.

이 기능을 제공하는 수단은 "정보 운영자"라고 불리는 다수의 호스트\(예: 모든 서버 호스트\) 각각에 프로세스를 구축하는 것입니다. 이 프로세스의 기능은 기호 식별 문자열과 포트 ID를 연결하는 것입니다. 프로세스는 정보 운영자에게 자신 및/또는 외부 프로세스를 식별할 수 있으며 외부 프로세스의 포트 ID를 요청할 수 있습니다. 기호식 식별 문자열은 프로세스에 의해 선택되며 의미 있는 정보를 포함할 만큼 충분히 길다\(예: LOGGER, MURPHY-TESTPROG\).

로컬 또는 원격 프로세스를 통해 정보 운영자와의 통신은 일반 MSP 기능을 통해 이루어집니다. 정보 운영자는 잘 알려진 포트에서 항상 RECEIVE ANY 미결제를 보유합니다. 이것은 일반적으로 존재하는 유일하게 잘 알려진 포트일 수 있습니다. 이 포트에서 수신된 메시지에는 다음 매개변수가 포함됩니다.

1. 통신이 필요한 외부 프로세스를 식별하는 문자열입니다.

1. 호출 프로세스를 식별하는 문자열입니다.

```text
      3. Calling process' port number.
```

1. 지연 사양.

이러한 매개변수의 형식은 그림 4에 나와 있습니다. 경우에 따라 하나 이상의 인수가 null이 됩니다. 메시지를 받은 후, 정보 운영자는 어떤 경우에는 원하는 정보나 실패 통지를 제공하는 호출 프로세스의 포트 번호로 SEND SPECIFIC을 수행합니다.

다음 두 가지 경우는 정보 운영자의 모든 기능을 포괄하는 것으로 보입니다. 이는 MSP의 SEND/RECEIVE SPECIFIC ANY 사례에 해당합니다.

1. 서로의 특정 신원을 각각 알고 있는 두 프로세스가 통신을 원합니다. 각각은 정보 운영자에게 SEND SPECIFIC을 수행하여 매개변수 1-2를 제공하며 이 경우 기본 지연 사양은 WAIT입니다. 정보 운영자가 두 번째 메시지를 수신하고 일치하는 항목이 있음을 확인하면 각 프로세스에 다른 프로세스의 포트 ID를 보내고 해당 테이블에서 문자열과 포트 ID를 모두 삭제합니다. 외부 포트 번호를 예상하여 각각 RECEIVE SPECIFIC을 수행한 두 프로세스는 포트 번호와 기본 MSP 기능만 사용하여 통신할 수 있습니다.

1. 일종의 일반 서비스나 정보를 제공하고 해당 이름과 프로토콜을 광고하기 위한 프로세스가 설정됩니다. 이 프로세스는 첫 번째\(아마도 유일한\) 메시지 트랜잭션\(예: 앞서 설명한 라이브러리 프로세스\)에 대해 뛰어난 SEND 또는 RECEIVE ANY를 유지하려고 합니다. 이러한 프로세스의 대부분은 처음에는 수신자이지만 SEND가 미해결 상태로 남아 있을 수 있고 강제 프로세스가 진행되어 정보를 가져올 수 있는 경우가 몇 가지 있을 수 있습니다. 두 경우 모두 서비스 프로세스는 로컬 기호 ID와 로컬 포트 ​​ID를 제공하는 정보 운영자에게 SEND SPECIFIC을 수행합니다. 외부 기호 ID는 null이고 기본 지연 사양은 NO-WAIT입니다. 그건,

```text
         INFO ( -, local ID, local port)
```

- 정보 교환원은 이 정보를 테이블에 입력하지만 호출자에게 아무것도 반환하지 않습니다. 호출자는 비즈니스를 기다리기 위해 SEND/RECEIVE ANY를 계속 수행합니다. 다른 프로세스가 광고된 서비스를 사용하려고 하면 로거에게 서비스 프로세스의 포트 ID를 요청합니다.

```text
         INFO (service ID, -, local port)
```

- 로컬 심볼릭 ID를 지정할 필요가 없으며 기본 지연 사양은 NO-WAIT입니다. 정보 운영자는 서비스 프로세스의 포트 ID를 호출자의 로컬 포트로 보내고 향후 호출자를 위해 테이블 ​​항목을 유지합니다. 서비스 프로세스만

- 항목 삭제를 요청할 수 있습니다. 이 호출 당시 정보 운영자가 서비스 ID를 알지 못했다면 즉시 실패 표시, 즉 0을 반환합니다.

통신 프로세스는 일반적으로 한쪽 또는 다른 쪽의 로컬 정보 운영자를 사용하며 MSP의 랑데부 호스트와 마찬가지로 이는 사전에 합의됩니다. 서비스 프로세스는 일반적으로 로컬 사이트에서 정보 운영자를 사용하고 이에 따라 사용자 프로세스는 서비스 프로세스를 사용할 수 있을 것으로 예상되는 사이트에서 정보 운영자를 호출합니다. 물론 다른 사이트에서는 정보 운영자를 사용하는 데 제한이 없으며 일부 소규모 및/또는 게으른 서버는 서비스 프로세스 ID에 대해 다른 호스트를 사용할 수 있습니다. 두 명 이상의 정보 운영자가 동일한 서비스 프로세스에 대한 항목을 갖는 것은 문제가 되지 않으며 실제로 이는 네트워크의 한 위치에만 존재하고 수시로 이동할 수 있는 특별한 유형의 서비스 프로세스에 매우 바람직할 수 있습니다. .

프로세스는 자신의 로컬 포트 ​​번호를 지정하며 각 시스템은 사용자 프로세스가 이를 수행하는 데 도움이 되는 몇 가지 방법을 제공해야 합니다. 예를 들어 TENEX에서는 작업 내에 할당된 다른 번호와 연결된 작업 번호를 사용할 수 있습니다. 정보 운영자는 통신자 중 하나 또는 둘 다와 다른 호스트에서 실행될 것이며 해당 호스트의 고유 번호가 무엇인지 알 수 없기 때문에 포트 번호를 제공할 수 없습니다. 어떤 경우에는 프로세스가 "고유 번호 프로세스"\(아래 설명\)에 로컬 포트 ​​ID를 요청하고 정보 운영자를 통해 이를 알려줍니다.

실제로는 세계에서 유일하게 "잘 알려진" 포트가 정보 운영자라는 규칙에 몇 가지 예외가 있을 수 있습니다. 이러한 예외는 LOGGER와 같이 많은 호스트에 공통적인 프로세스이거나 특히 자주 사용되는 프로세스입니다. 이러한 경우 고유한 포트 번호는 관리 명령에 의해 할당되고 기록되어 모든 사용자에게 게시됩니다.

기호 식별 문자열은 널\(모두 0으로 이루어진 바이트\)로 끝나는 1\~39\(임의의 최대값\) ASCII 문자로 지정됩니다. 문자는 상위 비트가 0으로 설정된 8비트 바이트의 7비트 ASCII입니다. 인수가 필요하지 않은 경우 널 문자열\(첫 번째 바이트는 널임\)이 사용됩니다.

---
# **Format of Information Operator Messages**
---
# **To Information Operator: A stream of 8-bit bytes.**

```text
+------+--//---+------+------+--//---+------+------+-------+-------+
|char 0| 1// n | null |char 0| 1// n | null | port | number| delay |
|      |  //   |      |      |  //   |      |      |       |spec   |
+------+--//---+------+------+--//---+------+------+-------+-------+
 \                   /\                     /\             /\      /
  \_________________/  \___________________/  \___________/  \____/
      PARAMETER 1         PARAMETER 2           PARAMETER 3  PARAMETER
                                                             4
   Parameters given:
```

1. 통신이 필요한 외부 프로세스를 식별하는 문자열입니다. \(1\~39자 또는 null\)

1. 호출 프로세스를 식별하는 문자열입니다. \(1\~39자 또는 null\)

```text
      3. Calling process' port number.

      4. Delay specification:

            0=default
            1=wait for match
            2=don't wait for match
```

---
# **From Information Operator: 3 8-bit bytes.**

```text
   +--------|-------|-------+
   | byte 0 |   1   |   2   |
   +--------|-------|-------+
```

성공하면 요청된 외부 포트의 포트 번호\(24비트\), 실패하면 0입니다.

---
# **UNIQUE PORT NUMBERS**

고유한 포트 번호의 존재는 MSP 작동에 필수적입니다. 예를 들어, 두 개의 통신 프로세스가 중간 사이트에서 메시지 랑데뷰를 지정할 때 프로세스는 동일한 사이트에서 메시지 랑데뷰를 지정한 다른 프로세스에 의해 사용되지 않는 수신 포트와 발신 포트를 지정할 수 있어야 합니다. 잘못된 목적지로 배달되었습니다. 우리는 이 노트의 앞부분에서 고유한 포트 번호를 제공하는 방법을 언급했습니다. 이 방법은 24비트 포트 번호 공간을 분리된 세그먼트로 분할하고 네트워크의 각 호스트에 하나의 세그먼트를 제공하는 것입니다.

고유한 포트 ID를 "생성"하기 위해 호출될 때 배포합니다. 따라서 각 24비트 호스트 번호는 두 가지 주요 부분으로 구성됩니다. 처음 8비트는 포트 ID를 "생성하는" 호스트의 번호가 되며 다음 16비트는 생성하는 호스트가 원하는 방식으로 사용될 수 있습니다. 이는 각 호스트에 배포할 2^16 포트 번호를 제공하며, 각 호스트는 포트 번호 공간의 세그먼트를 고유한 방식으로 배포해야 하는 부담을 갖게 됩니다. 가운데 8비트가 0인 포트 번호를 생성하는 호스트 시스템의 잘 알려진 포트용으로 예약하는 규칙을 권장합니다. 이전 섹션에서 이미 처음 8비트가 0인 포트 번호를 네트워크 전체 사용을 위해 예약하고 특히 24비트가 모두 0인 포트 번호는 ANY를 의미하는 데 사용하도록 권장했습니다.

각 호스트에는 배포할 포트 번호가 2\~16개만 있으므로 일반적으로 포트 번호는 프로세스에서 장기간\(예: 몇 주, 몇 달\) 보유하고 사용할 수 없습니다. 보다 일반적으로 호스트는 호스트 시스템이 다운될 때마다 호스트가 배포한 모든 포트 번호를 암시적으로 "복수"하고 시스템이 다시 시작될 때 필요에 따라 포트 번호를 다시 배포합니다. 즉, 포트 번호는 일반적으로 그렇지 않습니다. 물론 특정 호스트는 정보 연산자에 등록된 포트 번호가 나타날 때마다 여러 표준 프로세스\(예: FORTRAN 컴파일러\)에 동일한 포트 번호를 부여하는 것으로 보일 수 있습니다. 시스템의 변동에도 불구하고 일정하게 유지되는 경우가 많습니다.

일반적으로 각 호스트가 장기간 고유한 상태를 유지하도록 보장할 수 있는 포트 번호를 임의의 사용자 프로세스에 배포할 수 없다는 사실에도 불구하고 장기적인 고유 포트 제공에 대한 요구는 여전히 존재합니다. 숫자. 어떤 사람들에게는 정보 운영자를 통과하는 절차가 연결을 만드는 데 너무 많은 느낌을 줍니다. 이러한 사람들은 여러 가지 이유로 자신의 프로세스가 오랜 기간 동안 식별자가 일정하게 유지되는 포트를 통해 통신할 수 있도록 허용해야 한다고 주장합니다. 따라서 네트워크의 한두 곳에서 장기간 고유번호 서비스를 제공하면 좋을 것 같습니다. 이 서비스를 제공하는 프로세스를 고유 번호 프로세스라고 부르겠습니다. 고유 번호 프로세스는 고유 포트 번호 공간의 한 세그먼트\(예를 들어 첫 번째 8비트가 377-8과 동일한 모든 포트 번호\)를 여기에 할당합니다. 이 프로세스에는 로컬 랑데부가 지정된 잘 알려진 포트에서 보류 중인 SEND-to-ANY가 있습니다. 어떤 프로세스가 항상 사용되지 않거나 번호가 다시 주어질 때까지 의존할 수 있는 고유 번호를 원할 경우 고유 번호 프로세스의 잘 알려진 포트를 지정하는 RECEIVE-from-SPECIFIC을 보내고 다음에서 랑데부를 보냅니다. 고유번호 프로세스의 호스트입니다. 고유 번호 프로세스의 보류 중인 SEND-to-ANY에는 고유 번호가 포함됩니다. 또한 고유 번호 프로세스에는 RECEIVE-from-이 있습니다.

ANY는 항상 로컬 랑데부가 지정된 다른 잘 알려진 포트에서 보류 중입니다. 이 포트에서 고유 번호 프로세스는 프로세스가 돌려주는 고유 번호를 받습니다. 고유 번호 프로세스는 파일 시스템과 같은 일부 장기 저장 매체에 각 고유 번호의 상태\(사용 가능 또는 사용 중\)를 나타내는 2\~16비트 길이의 비트 테이블을 유지 관리합니다. 고유 번호 프로세스는 고유 번호를 제공하는 각 프로세스에 대한 일부 정보를 유지하여 고유 번호 공급이 고갈되면 프로세스에서 이를 반환하도록 요청할 수 있습니다.

정보 운영자에게 기호명과 함께 등록된 프로세스 ID 중 일부는 고유번호 프로세스에서 얻은 장기 고유번호일 수 있다는 점은 이미 언급한 바 있다. 또한 프로세스에 대한 기본 액세스 권한을 얻는 데 사용되는 포트 번호\(이전 섹션에서 프로세스 ID라고 함\) 외에 임의의 포트 번호는 저장 공간이 부족한 것 외에는 아무 이유도 없는 것으로 보인다는 점을 언급해야 합니다. 포트 번호와 기호 식별은 정보 운영자에게 등록될 수 없습니다. 예를 들어, BBN-FORTRAN이라는 이름과 단일 포트 번호를 등록하는 대신 기호 식별자가 BBN-FORTRAN-Control-TELETYPE, BBN-FORTRAN-INPUT-FILE, BBN-FORTRAN-LISTING-인 포트 번호를 등록할 수 있습니다. 파일 및 BBN-FORTRAN-BINARY-OUTPUT-FILE. 이는 아마도 운영 체제 내의 표준 관행과 상충될 수 있지만 통신이 프로세스가 아닌 포트를 통해 수행된다는 참조 4의 철학과 일치합니다.

이제 지금까지 무시되었으며 참조 4에서만 언급된 포트 보호 문제에 대해 살펴보겠습니다. 우리는 이 문제에 대해 별로 깊이 생각하지 않았습니다. 그러나 포트 보호를 위한 한 가지 메커니즘은 매우 간단해 보입니다. 이 메커니즘의 핵심은 PPP\(포트 보호 프로세스\)라고 부르는 각 호스트의 프로세스입니다. PPP는 호스트에 존재하는 모든 프로세스의 목록과 각 프로세스에 대해 프로세스가 "합법적으로" 획득한 모든 포트의 수를 유지 관리합니다. 프로세스가 SEND 또는 RECEIVE를 수행할 때마다 모니터는 PPP를 확인하여 프로세스가 사용할 권한이 있는 포트 번호를 지정했는지 확인합니다. 즉, 합법적으로 취득한 것입니다. PPP에는 잘 알려진 포트에 항상 보류 중인 일부 RECEIVE가 있습니다. 한 프로세스가 다른 프로세스에 포트를 전달하려고 하면 첫 번째 프로세스는 보낼 포트 번호, 두 번째 프로세스가 있는 호스트 번호, 두 번째 프로세스가 있는 포트를 지정하는 메시지를 PPP에 보냅니다. 포트 등을 수신할 것으로 예상됩니다. PPP는 첫 번째 프로세스에 전송하려는 포트가 있는지 여부를 테이블에서 조회합니다. 그렇다면 대상 사이트의 PPP에 메시지를 보냅니다. 메시지에는 전송될 포트 번호와 대상 프로세스의 RECEIVE 포트 번호가 포함됩니다. 대상 PPP는 프로세스에 해당 테이블이 있는지 여부를 확인합니다.

RECEIVE 포트가 있고, 그렇다면 새 포트를 프로세스에 전달하고 해당 테이블을 업데이트하여 프로세스가 이제 새 포트를 소유하고 있음을 나타냅니다. PPP에 대한 메시지는 포트 사본 전송, 포트 삭제 등을 선택적으로 지정할 수 있습니다. PPP에는 아마도 각 프로세스, 특히 통신에 사용되는 포트의 프로세스에 대해 내장된 합법적인 포트가 있을 것입니다. PPP. 정확한 사양을 위해서는 개발이 필요하지만 이는 어렵지 않습니다\(참조 4의 \(3\),\(6\), \(7\) 참조\). 우리가 보는 주요 어려움은 모니터의 현재 보호 시스템을 완전히 대체하지 않고 모든 RECEIVE 또는 SEND에 대해 모니터로 PPP 테이블을 효율적으로 검사하는 것입니다.

---
# **FLOW CHART**

다음 섹션에서는 대부분의 MSP에 대한 흐름도를 설명합니다. SEND 및 RECEIVE라는 로컬 프로세스에 의해 이루어진 호출과 IN 및 OUT이라는 NET을 통해 들어오는 메시지가 구별됩니다. 지역 랑데뷰를 통한 통화\(또는 메시지\)와 해외 랑데뷰 호스트를 통한 통화\(또는 메시지\) 간에는 추가적인 차이가 있습니다.

코드가 매우 유사하므로 구별할 필요는 없지만 명확성을 위해 포함됩니다.

MSP에는 다음 항목에 대한 테이블 조항이 있다고 가정합니다.

- 메시지 소스 랑데뷰 호스트 FROM-PORT-ID TO-PORT-ID 테이블 위치 메시지 데이터의 종류 사용자 프로세스에 대한 크기 및 위치 데이터

사용자가 보내기 또는 받기를 수행합니다.

A. 랑데부는 외국 호스트에 있습니다

1. 적절한 테이블 데이터를 저장합니다.

1. 랑데부 호스트에게 메시지 보내기

- ㅏ. 보내기: 출력 + 데이터

```text
         b. RECEIVE: IN
```

B. Rendezvous는 로컬입니다. 테이블에서 항목을 찾으세요.

1. 항목을 찾을 수 없음: 적절한 데이터로 항목을 만듭니다.

1. 테이블에 일치하는 항목이 있습니다.

- ㅏ. RECEIVE: 사용자에게 데이터를 제공합니다.

```text
         b. Send a message to the other host (as specified by the source
            field of the original msg)

            1)SEND: OUT+DATA
            2)RECEIVE: IN
```

- 씨. 거래가 완료되었다는 사실을 사용자에게 알립니다.

```text
         d. Clear table entry
```

일치하는 항목에 대해 NET 검색 테이블을 통해 IN이 수신됩니다.

A. 일치하는 항목이 없습니다. 적절한 데이터로 항목을 생성하세요.

B. 일치하는 항목이 있습니다.

1. 로컬 SEND로 인해 진입한 경우

- ㅏ. IN 소스로 "OUT \_ DATA"를 보냅니다.

-ㄴ. 사용자에게 거래 사실을 알립니다.

```text
         c. Clear table entry
```

1. 세 번째 호스트로 네트 작동을 통해 수신된 OUT으로 인해 항목이 발생했습니다.

- ㅏ. 테이블 항목을 생성한 사이트로 IN 보내기

-ㄴ. IN을 보내는 사이트로 OUT + DATA\(이전에 버퍼링된\)를 보냅니다.

```text
         c. Clear table entry
```

OUT + DATA는 일치하는 항목에 대해 NET 검색 테이블을 통해 수신됩니다.

A. 일치하는 항목이 없습니다.

```text
      1. buffer data

      2. create appropriate table information
```

B. 일치하는 항목이 발견되었습니다.

1. 로컬에서 실행된 RECEIVE로 인해 테이블 ​​항목이 발생했습니다.

- ㅏ. 사용자에게 데이터를 제공하고 그 존재를 알려줍니다.

-ㄴ. 일치하는 "IN"을 "OUT" 소스로 보냅니다.

- 씨. 테이블에서 항목 제거

1. NET을 통해 "IN"을 수신하여 테이블 항목이 발생했으므로 당사가 제3자 호스트 역할을 하고 있습니다.

- ㅏ. 테이블에 저장된 호스트에 "OUT + DATA"를 보냅니다.

-ㄴ. "OUT"이 방금 도착한 호스트에 "IN"을 보냅니다.

---
# **MSP VARIATIONS**

현재 MSP에 도달하는 동안 고려한 다른 MSP 중 일부를 아는 것이 독자에게 흥미로울 수 있습니다.

우리가 고려한 가장 간단한 것은 대상 호스트에서 수행되는 모든 랑데뷰를 기반으로 하는 MSP입니다. 발신자 프로세스는 OUT 메시지와 데이터를 대상 호스트로 보냅니다. 수신자 프로세스는 수신자 호스트에 머무르는 IN을 수행합니다. OUT 및 RECEIVE 랑데뷰와 데이터는 수신자 프로세스로 전달됩니다. 이제 전송이 완료되었습니다. 단, 이 MSP의 일부 변형에서는 승인이 발신자 프로세스로 전송됩니다. 이 MSP에는 몇 가지 단점이 있습니다. 가장 간단한 공식에서 RECEIVE는 OUT+ 데이터가 도착할 때 기다려야 했습니다. 그렇지 않으면 출력 데이터가 버려졌습니다. 이로 인해 SEND 및 RECEIVE의 타이밍이 너무 엄격하게 제한됩니다. 특히 보낸 사람과 받는 사람 프로세스가 서로 떨어져 있을 수 있기 때문입니다. 그러나 IN이 먼저 도착하도록 허용하고 RECEIVE와 일치할 때까지 유지해야 하는 경우 모니터는 일반 데이터를 포함한 모든 경우에 불확실한 양의 데이터를 버퍼링해야 합니다. 더욱이, 목적지에서의 집결을 모든 것을 기반으로 하면 항구 이동 과정이 어려워진다.

우리가 고려한 다음으로 간단한 MSP는 참조 4의 IPC였습니다. 이는 상대적으로 흔하지 않은 경우를 처리하기 위해 두 개의 특수 메시지를 사용하여 소스 호스트에서 수행되는 거의 모든 랑데뷰를 기반으로 한다는 점에서 위에 설명된 MSP와 정반대로 작동합니다. 랑데부는 목적지나 중간 호스트에서 이루어져야 합니다. 이 시스템과 그 장점 및 단점은 참고 자료에서 매우 길게 논의됩니다.

Crowther가 제안한 MSP의 세 번째 변형은 지정된 랑데부 호스트에서 OUT 및 IN 랑데부가 IN의 소스로 전송되고 IN이 소스의 소스로 전송된다는 점에서 현재 MSP와 동일합니다. OUT이지만 데이터는 OUT과 함께 전송되지 않습니다. 대신, OUT이 마침내 IN의 소스에 도달하면 수신자 호스트에서 소스 호스트로 데이터 전송을 요청하는 또 다른 메시지가 전송됩니다. 이 데이터 요청 메시지에 대한 응답으로 최종적으로 데이터가 목적지로 전송됩니다. 이 시스템에 대한 우리의 주요 반대는 대칭성이 부족하다는 것입니다. 그러나 프로세스가 입력 버퍼를 설정하지 않은 데이터를 버퍼링하기 위해 호스트가 필요하지 않으며 아마도 그러한 이유로 MSP보다 더 나은 시스템이라는 것을 인식합니다. 우리는 제시하고 있습니다.

우리가 고려한 마지막 MSP 변형에서는 SEND 또는 RECEIVE와 OUT 또는 IN 간의 차이가 삭제되었습니다. 이 경우 TRANSFER를 호출하는 하나의 메시지만 사용됩니다. 프로세스가 TRANSFER를 실행할 때 입력 버퍼, 출력 버퍼, 둘 다 지정하거나 둘 다 지정하지 않을 수 있습니다. 통신하려는 두 프로세스는 모두 동일한 포트 ID와 동일한 랑데부 호스트를 지정하는 TRANSFER를 실행합니다. TRANSFER는 랑데부 호스트에서 랑데뷰하는 출력 버퍼가 지정된 경우 TRANSFER 메시지와 데이터를 생성합니다. 랑데부가 발생하면 TRANSFER 메시지와 해당 데이터가 교차되고 각각은 다른 메시지의 소스로 전송됩니다. 이 시스템은 프로세스가 SEND 또는 RECEIVE를 수행해야 하는지 알 수 없도록 허용하며 \(아마도\) 이 노트에 제시된 MSP를 훌륭하게 일반화한 것입니다. 예를 들어, 두 프로세스는 이 시스템을 사용하여 데이터를 교환할 수 있거나, 두 프로세스가 데이터 없는 TRANSFER를 전송하여 서로를 방해할 수 있습니다. MSP의 이러한 변형은 Steve Crocker의 제안을 발전시킨 것입니다. 단점은 \(1\) 의도하지 않은 매칭이 발생할 가능성이 높다는 점, \(2\) 만남의 장소 선정이 더 복잡하다는 점, \(3\) 생각하기 힘든 점 등이다.

---
# **APPENDIX**

리소스 공유 컴퓨터 네트워크의 프로세스 간 통신을 위한 시스템입니다. Communications of the ACM, 1972년 4월. 이 문서의 재인쇄에 대한 허가는 컴퓨터 기계 협회\(Association for Computing Machinery\)의 허가를 받아 부여되었습니다. \[RFC 333의 재발행 버전에서는 생략되었습니다.\]

NB 다음 문서의 섹션 4의 아이디어는 섹션 3-DCW에서 개발된 아이디어에 결코 중요하지 않습니다.

```text
         [ This RFC was put into machine readable form for entry ]
            [ into the online RFC archives by Via Genie 3/00  ]
```
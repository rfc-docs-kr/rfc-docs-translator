

```text
﻿

Internet Engineering Task Force (IETF)                     T. Pauly, Ed.
Request for Comments: 9484                                    Apple Inc.
Updates: 9298                                                D. Schinazi
Category: Standards Track                              A. Chernyakhovsky
ISSN: 2070-1721                                               Google LLC
                                                            M. Kühlewind
                                                           M. Westerlund
                                                                Ericsson
                                                            October 2023

                          Proxying IP in HTTP
```

---
# **Abstract**

이 문서에서는 HTTP에서 IP 패킷을 프록시하는 방법을 설명합니다. 이 프로토콜은 HTTP의 UDP 프록시와 유사하지만 임의의 IP 패킷 전송을 허용합니다. 보다 구체적으로, 이 문서는 HTTP 클라이언트가 IP 프록시 역할을 하는 HTTP 서버를 통해 IP 터널을 생성할 수 있도록 하는 프로토콜을 정의합니다. 이 문서는 RFC 9298을 업데이트합니다.

---
# **Status of This Memo**

이것은 인터넷 표준 추적 문서입니다.

이 문서는 IETF\(Internet Engineering Task Force\)의 제품입니다. 이는 IETF 커뮤니티의 합의를 나타냅니다. 공개 검토를 받았으며 IESG\(Internet Engineering Steering Group\)의 출판 승인을 받았습니다. 인터넷 표준에 대한 자세한 내용은 RFC 7841의 섹션 2에서 확인할 수 있습니다.

이 문서의 현재 상태, 정오표, 피드백 제공 방법에 대한 정보는 https://www.rfc-editor.org/info/rfc9484에서 얻을 수 있습니다.

---
# **Copyright Notice**

Copyright \(c\) 2023 IETF Trust 및 문서 작성자로 확인된 사람. 판권 소유.

이 문서는 이 문서의 발행일에 유효한 BCP 78 및 IETF 문서에 관한 IETF 트러스트의 법적 조항\(https://trustee.ietf.org/license-info\)의 적용을 받습니다. 이 문서와 관련된 귀하의 권리 및 제한 사항을 설명하므로 이 문서를 주의 깊게 검토하십시오. 이 문서에서 추출한 코드 구성요소는 Trust Legal Provisions의 섹션 4.e에 설명된 대로 개정된 BSD 라이센스 텍스트를 포함해야 하며 개정된 BSD 라이센스에 설명된 대로 보증 없이 제공됩니다.

---
# **Table of Contents**

```text
   1.  Introduction
   2.  Conventions and Definitions
   3.  Configuration of Clients
   4.  Tunnelling IP over HTTP
     4.1.  IP Proxy Handling
     4.2.  HTTP/1.1 Request
     4.3.  HTTP/1.1 Response
     4.4.  HTTP/2 and HTTP/3 Requests
     4.5.  HTTP/2 and HTTP/3 Responses
     4.6.  Limiting Request Scope
     4.7.  Capsules
       4.7.1.  ADDRESS_ASSIGN Capsule
       4.7.2.  ADDRESS_REQUEST Capsule
       4.7.3.  ROUTE_ADVERTISEMENT Capsule
     4.8.  IPv6 Extension Headers
   5.  Context Identifiers
   6.  HTTP Datagram Payload Format
   7.  IP Packet Handling
     7.1.  Link Operation
     7.2.  Routing Operation
       7.2.1.  Error Signalling
   8.  Examples
     8.1.  Remote Access VPN
     8.2.  Site-to-Site VPN
     8.3.  IP Flow Forwarding
     8.4.  Proxied Connection Racing
   9.  Extensibility Considerations
   10. Performance Considerations
     10.1.  MTU Considerations
     10.2.  ECN Considerations
     10.3.  Differentiated Services Considerations
   11. Security Considerations
   12. IANA Considerations
     12.1.  HTTP Upgrade Token Registration
     12.2.  MASQUE URI Suffixes Registry Creation
     12.3.  Updates to masque Well-Known URI Registration
     12.4.  HTTP Capsule Types Registrations
   13. References
     13.1.  Normative References
     13.2.  Informative References
   Acknowledgments
   Authors' Addresses
```

---
## **1.  Introduction**

HTTP는 대상에 대한 TCP \[TCP\] 터널을 생성하기 위한 CONNECT 메서드\(\[HTTP\]의 섹션 9.3.6 참조\)와 UDP \[CONNECT-UDP\]에 대한 유사한 메커니즘을 제공합니다. 그러나 이러한 메커니즘은 다른 IP 프로토콜\[IANA-PN\]을 터널링하거나 IP 헤더의 필드를 전달할 수 없습니다.

이 문서에서는 HTTP를 통해 IP 특정 프록시 역할을 하는 HTTP 서버를 통해 IP를 터널링하기 위한 프로토콜을 설명합니다. 이는 원격 액세스 VPN, 사이트 간 VPN, 보안 지점 간 통신 또는 범용 패킷 터널링과 같은 다양한 사용 사례에 사용될 수 있습니다.

IP 프록시는 UDP 프록시 \[CONNECT-UDP\]와 유사하게 작동하며, 프록시 자체는 선택적으로 트래픽 목적지를 포함하는 절대 URL로 식별됩니다. 클라이언트는 섹션 3에 설명된 대로 URI 템플릿 \[TEMPLATE\]을 사용하여 이러한 URL을 생성합니다.

이 프로토콜은 HTTP 데이터그램 \[HTTP-DGRAM\]을 사용하여 모든 기존 버전의 HTTP를 지원합니다. HTTP/2\[HTTP/2\] 또는 HTTP/3\[HTTP/3\]을 사용하는 경우 \[EXT-CONNECT2\] 및 \[EXT-CONNECT3\]에 설명된 대로 HTTP 확장 CONNECT를 사용합니다. HTTP/1.x \[HTTP/1.1\]을 사용하는 경우 \[HTTP\]의 7.8항에 정의된 대로 HTTP 업그레이드를 사용합니다.

이 문서는 "masque" 잘 알려진 URI를 변경하기 위해 \[CONNECT-UDP\]를 업데이트합니다. 섹션 12.3을 참조하세요.

---
## **2.  Conventions and Definitions**

키워드 "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY" 및 "OPTIONAL" "는 BCP 14 \[RFC2119\] \[RFC8174\]에 설명된 대로 여기에 표시된 것처럼 모두 대문자로 표시되는 경우에만 해석됩니다.\(MUST NOT\)

이 문서에서는 "IP 프록시"라는 용어를 사용하여 IP 프록시 요청에 응답하는 HTTP 서버를 나타냅니다. "클라이언트"라는 용어는 HTTP 의미로 사용됩니다. 클라이언트는 IP 프록시 요청을 구성합니다. 클라이언트와 IP 프록시 사이에 HTTP 중개자\(\[HTTP\]의 섹션 3.7에 정의된 대로\)가 있는 경우 이를 이 문서에서는 "중개자"라고 합니다. "IP 프록시 엔드포인트"라는 용어는 클라이언트와 IP 프록시를 모두 의미합니다.

이 문서는 \[QUIC\]의 용어를 사용합니다. 이 문서가 프로토콜 유형을 정의하는 경우 정의 형식은 \[QUIC\] 섹션 1.3의 표기법을 사용합니다. 이 사양은 \[QUIC\] 섹션 16의 가변 길이 정수 인코딩을 사용합니다. 가변 길이 정수 값은 필요한 최소 바이트 수로 인코딩할 필요가 없습니다.

사용 중인 HTTP 버전이 멀티플렉싱 스트림\(예: HTTP/1.1\)을 지원하지 않는 경우 이 문서에서 "스트림"에 대한 참조는 전체 연결을 나타냅니다.

---
## **3.  Configuration of Clients**

클라이언트는 URI 템플릿 \[TEMPLATE\]을 통해 HTTP를 통한 IP 프록시를 사용하도록 구성됩니다. URI 템플릿에는 "target"과 "ipproto"라는 두 가지 변수가 포함될 수 있습니다. 섹션 4.6을 참조하세요. 변수가 자체 식별되거나 구문에서 제외될 수 있도록 템플릿을 정의할 때 변수의 선택성을 고려해야 합니다.\(MAY\)

예는 다음과 같습니다.

```text
   https://example.org/.well-known/masque/ip/{target}/{ipproto}/
   https://proxy.example.org:4443/masque/ip?t={target}&i={ipproto}
   https://proxy.example.org:4443/masque/ip{?target,ipproto}
   https://masque.example.org/?user=bob

                      Figure 1: URI Template Examples
```

URI 템플릿에는 다음 요구 사항이 적용됩니다.

\* URI 템플릿은 레벨 3 템플릿 이하여야 합니다.\(MUST\)

\* URI 템플릿은 절대 형식이어야 하며 비어 있지 않은 체계, 권한 및 경로 구성 요소를 포함해야 합니다.\(MUST\)

\* URI 템플릿의 경로 구성 요소는 슬래시 "/"로 시작해야 합니다.\(MUST\)

\* 모든 템플릿 변수는 반드시 URI의 경로 또는 쿼리 구성 요소 내에 있어야 합니다.\(MUST\)

\* URI 템플릿은 "target"과 "ipproto"라는 두 변수를 포함할 수 있으며 다른 변수를 포함할 수도 있습니다. "target" 또는 "ipproto" 변수가 포함된 경우 해당 값은 비어 있으면 안 됩니다. 대신 클라이언트는 "\*"를 사용하여 와일드카드 또는 기본 설정 없음 값을 나타낼 수 있습니다. 섹션 4.6을 참조하세요.\(MAY, MUST NOT\)

\* URI 템플릿은 ASCII가 아닌 유니코드 문자를 포함해서는 안 되며 0x21-0x7E 범위의 ASCII 문자만 포함해야 합니다\(퍼센트 인코딩이 허용된다는 점에 유의하세요. \[URI\]의 섹션 2.1 참조\).\(MUST NOT\)

\* URI 템플릿은 예약된 확장\("+" 연산자\), 조각 확장\("#" 연산자\), 점 접두사가 있는 레이블 확장, 슬래시 접두사가 있는 경로 세그먼트 확장, 세미콜론 접두사가 있는 경로 스타일 매개변수 확장을 사용해서는 안 됩니다. .\(MUST NOT\)

클라이언트는 위의 요구 사항을 검증해야 합니다. 그러나 클라이언트는 이러한 특정 유효성 검사가 부족한 범용 URI 템플릿 구현을 사용할 수 있습니다. 클라이언트가 URI 템플릿이 위의 요구 사항 중 하나라도 충족하지 않는다는 것을 감지하면 해당 구성을 거부하고 요청을 IP 프록시로 보내지 않고 중단해야 합니다.\(SHOULD, MUST\)

UDP 프록시와 마찬가지로 IP 프록시에 대한 일부 클라이언트 구성에서는 사용자가 프록시 호스트 및 프록시 포트만 구성하도록 허용합니다. 이러한 제한이 있는 클라이언트는 "https://$PROXY\_HOST:$PROXY\_PORT/.well-known/masque/ ip/{target}/{ipproto}/"로 정의된 기본 템플릿을 사용하여 IP 프록시 기능에 액세스하려고 시도할 수 있습니다. 여기서 $PROXY\_HOST 및 $PROXY\_PORT는 각각 IP 프록시의 구성된 호스트 및 포트입니다. IP 프록시 배포는 해당 클라이언트와 상호 운용해야 하는 경우 이 위치에서 서비스를 제공해야 합니다\(SHOULD\).\(MAY, SHOULD\)

---
## **4.  Tunnelling IP over HTTP**

HTTP를 통한 IP 터널 협상을 허용하기 위해 이 문서에서는 "connect-ip" HTTP 업그레이드 토큰을 정의합니다. 결과 IP 터널은 섹션 6에 정의된 형식의 HTTP 데이터그램과 함께 캡슐 프로토콜\(\[HTTP-DGRAM\]의 섹션 3.2 참조\)을 사용합니다.

단일 HTTP 스트림과 연결된 IP 터널을 시작하기 위해 클라이언트는 "connect-ip" 업그레이드 토큰이 포함된 요청을 발행합니다.

IP 프록시 요청을 보낼 때 클라이언트는 요청의 경로와 쿼리를 결정하기 위해 URI 템플릿 확장을 수행해야 합니다. 섹션 3을 참조하세요.\(MUST\)

캡슐 프로토콜\(\[HTTP-DGRAM\]의 섹션 3.2 참조\)의 정의 덕분에 IP 프록시 요청은 메시지 내용을 전달하지 않습니다. 마찬가지로 성공적인 IP 프록시 응답도 메시지 내용을 전달하지 않습니다.

HTTP를 통한 IP 프록시는 기밀성, 무결성 및 인증을 제공하기 위해 TLS나 QUIC 암호화 또는 다른 동등한 암호화 프로토콜을 통해 작동되어야 합니다.\(MUST\)

---
### **4.1.  IP Proxy Handling**

IP 프록시 요청을 받으면:

\* 수신자가 다른 HTTP 서버를 사용하도록 구성된 경우 요청을 다른 HTTP 서버로 전달하여 중개자 역할을 합니다. 요청 인코딩이 버전에 따라 다르기 때문에 중개자가 요청을 수신하는 데 사용된 것과 다른 HTTP 버전을 사용하여 요청을 전달할 경우 요청을 다시 인코딩해야 할 수도 있습니다\(아래 참조\).

\* 그렇지 않으면 수신자가 IP 프록시 역할을 합니다. IP 프록시는 IP 프록시 요청을 거부하도록 선택할 수 있습니다. 그렇지 않으면 요청 헤더에서 재구성한 URI에서 선택적 "target" 및 "ipproto" 변수를 추출하고 해당 백분율 인코딩을 디코딩한 다음 IP 터널을 설정합니다.

IP 프록시는 디코딩된 "target" 및 "ipproto" 변수가 섹션 4.6의 요구 사항을 충족하는지 여부를 검증해야 합니다. 그렇지 않은 경우 IP 프록시는 요청을 잘못된 형식으로 처리해야 합니다. \[HTTP/2\]의 섹션 8.1.1 및 \[HTTP/3\]의 섹션 4.1.2를 참조하세요. "대상" 변수가 DNS 이름인 경우 IP 프록시는 HTTP 요청에 응답하기 전에 DNS 확인\(A 및/또는 AAAA 레코드를 통해 해당 IPv4 및/또는 IPv6 주소를 얻기 위해\)을 수행해야 합니다. 이 프로세스 중에 오류가 발생하면 IP 프록시는 요청을 거부해야 하며 적절한 프록시 상태 헤더 필드 \[PROXY-STATUS\]를 사용하여 세부 정보를 보내야 합니다. 예를 들어 DNS 확인이 오류를 반환하는 경우 프록시는 \[PROXY-STATUS\] 섹션 2.3.2의 dns\_error 프록시 오류 유형을 사용할 수 있습니다.\(MUST, MUST, MUST, MUST\)

IP 전달 터널의 수명은 IP 프록시 요청 스트림과 연결되어 있습니다. IP 프록시는 요청 스트림이 열려 있는 동안 IP 전달 터널과 관련된 모든 IP 주소 및 경로 할당을 유지해야 합니다. IP 프록시는 비활성 기간으로 인해 터널을 해체하도록 선택할 수 있지만 그렇게 할 때는 요청 스트림을 닫아야 합니다.\(MUST, MUST\)

성공적인 IP 프록시 응답\(섹션 4.3 및 4.5에 정의됨\)은 IP 프록시가 IP 터널을 설정했으며 IP 페이로드를 프록시할 의향이 있음을 나타냅니다. 성공적인 IP 프록시 응답 이외의 모든 응답은 요청이 실패했음을 나타냅니다. 따라서 클라이언트는 요청을 중단해야 합니다.\(MUST\)

성공적인 IP 프록시 응답과 함께 IP 프록시는 캡슐을 보내 주소를 할당하고 클라이언트에 경로를 광고할 수 있습니다\(섹션 4.7\). 클라이언트는 네트워크 간 라우팅을 위해 IP 프록시에 주소를 할당하고 경로를 광고할 수도 있습니다.

---
### **4.2.  HTTP/1.1 Request**

HTTP/1.1\[HTTP/1.1\]을 사용하는 경우 IP 프록시 요청은 다음 요구 사항을 충족합니다.

\* 메소드는 "GET"이어야 합니다.\(MUST\)

\* 요청에는 IP 프록시의 호스트와 선택적 포트가 포함된 단일 Host 헤더 필드가 포함되어야 합니다.\(MUST\)

\* 요청에는 값이 "Upgrade"인 연결 헤더 필드가 포함되어야 합니다\(이 요구 사항은 \[HTTP\]의 섹션 7.6.1에 따라 대소문자를 구분하지 않습니다\).\(MUST\)

\* 요청에는 값이 "connect-ip"인 업그레이드 헤더 필드가 포함되어야 합니다.\(MUST\)

이러한 제한 사항을 준수하지 않는 IP 프록시 요청은 잘못된 형식입니다. 이러한 잘못된 요청의 수신자는 반드시 오류로 응답해야 하며 400\(잘못된 요청\) 상태 코드를 사용해야 합니다.\(MUST\)

예를 들어, 클라이언트가 URI 템플릿 "https://example.org/.well-known/masque/ip/{target}/{ipproto}/"로 구성되어 있고 대상 없이 IP 전달 터널을 열려고 하거나 프로토콜 제한으로 인해 다음 요청을 보낼 수 있습니다.

```text
   GET https://example.org/.well-known/masque/ip/*/*/ HTTP/1.1
   Host: example.org
   Connection: Upgrade
   Upgrade: connect-ip
   Capsule-Protocol: ?1

                     Figure 2: Example HTTP/1.1 Request
```

---
### **4.3.  HTTP/1.1 Response**

서버는 다음 요구 사항에 응답하여 성공적인 IP 프록시 응답을 나타냅니다.

\* 응답의 HTTP 상태 코드는 101\(스위칭 프로토콜\)이어야 합니다.\(MUST\)

\* 응답에는 값이 "Upgrade"인 연결 헤더 필드가 포함되어야 합니다\(이 요구 사항은 \[HTTP\]의 섹션 7.6.1에 따라 대소문자를 구분하지 않습니다\).\(MUST\)

\* 응답에는 값이 "connect-ip"인 단일 업그레이드 헤더 필드가 포함되어야 합니다.\(MUST\)

\* 응답은 Capsule Protocol을 시작하는 HTTP 응답의 요구 사항을 충족해야 합니다. \[HTTP-DGRAM\]의 섹션 3.2를 참조하세요.\(MUST\)

이러한 요구 사항 중 하나라도 충족되지 않으면 클라이언트는 이 프록시 시도를 실패한 것으로 처리하고 연결을 닫아야 합니다.\(MUST\)

예를 들어 서버는 다음과 같이 응답할 수 있습니다.

```text
   HTTP/1.1 101 Switching Protocols
   Connection: Upgrade
   Upgrade: connect-ip
   Capsule-Protocol: ?1

                    Figure 3: Example HTTP/1.1 Response
```

---
### **4.4.  HTTP/2 and HTTP/3 Requests**

HTTP/2\[HTTP/2\] 또는 HTTP/3\[HTTP/3\]을 사용하는 경우 IP 프록시 요청은 HTTP 확장 CONNECT를 사용합니다. 이를 위해서는 서버가 \[EXT-CONNECT2\] 및 \[EXT-CONNECT3\]에 지정된 대로 HTTP 설정을 보내야 하며 해당 요청은 다음 요구 사항에 따라 HTTP 의사 헤더 필드를 사용해야 합니다.

\* :method 의사 헤더 필드는 "CONNECT"여야 합니다.\(MUST\)

\* :protocol 의사 헤더 필드는 "connect-ip"여야 합니다.\(MUST\)

\* :authority 의사 헤더 필드는 IP 프록시의 권한을 포함해야 합니다.\(MUST\)

\* :path 및 :scheme 의사 헤더 필드는 비어 있으면 안 됩니다. 해당 값은 URI 템플릿 확장 프로세스가 완료된 후 URI 템플릿의 구성표와 경로를 포함해야 합니다. 섹션 3을 참조하세요. URI 템플릿의 변수는 전체 터널 IP 패킷 전달 요청이나 특정 프록시 흐름 요청과 같은 요청 범위를 결정할 수 있습니다. 섹션 4.6을 참조하세요.\(MUST NOT, MUST\)

이러한 제한 사항을 준수하지 않는 IP 프록시 요청은 잘못된 형식입니다. \[HTTP/2\]의 섹션 8.1.1 및 \[HTTP/3\]의 섹션 4.1.2를 참조하세요.

예를 들어, 클라이언트가 URI 템플릿 "https://example.org/.well-known/masque/ip/{target}/{ipproto}/"로 구성되어 있고 대상 없이 IP 전달 터널을 열려고 하거나 프로토콜 제한으로 인해 다음 요청을 보낼 수 있습니다.

```text
   HEADERS
   :method = CONNECT
   :protocol = connect-ip
   :scheme = https
   :path = /.well-known/masque/ip/*/*/
   :authority = example.org
   capsule-protocol = ?1

                 Figure 4: Example HTTP/2 or HTTP/3 Request
```

---
### **4.5.  HTTP/2 and HTTP/3 Responses**

서버는 다음 요구 사항에 응답하여 성공적인 IP 프록시 응답을 나타냅니다.

\* 응답의 HTTP 상태 코드는 2xx여야 합니다.

- \(성공\) 범위.\(MUST\)

\* 응답은 Capsule Protocol을 시작하는 HTTP 응답의 요구 사항을 충족해야 합니다. \[HTTP-DGRAM\]의 섹션 3.2를 참조하세요.\(MUST\)

이러한 요구 사항 중 하나라도 충족되지 않으면 클라이언트는 이 프록시 시도를 실패한 것으로 처리하고 요청을 중단해야 합니다. 예를 들어, 3xx 범위의 모든 상태 코드는 실패로 처리되어 클라이언트가 요청을 중단하게 만듭니다.\(MUST\)

예를 들어 서버는 다음과 같이 응답할 수 있습니다.

```text
   HEADERS
   :status = 200
   capsule-protocol = ?1

                Figure 5: Example HTTP/2 or HTTP/3 Response
```

---
### **4.6.  Limiting Request Scope**

대상 호스트를 지정해야 하는 UDP 프록시 요청과 달리 IP 프록시 요청을 사용하면 엔드포인트가 임의의 IP 패킷을 모든 호스트에 보낼 수 있습니다. 클라이언트는 요청에 매개변수를 추가하여 지정된 요청을 특정 IP 접두사 또는 IP 프로토콜로 제한하도록 선택할 수 있습니다. IP 프록시가 요청의 범위가 대상 접두사 또는 프로토콜로 지정되었음을 알게 되면 이 정보를 활용하여 리소스 할당을 최적화할 수 있습니다. 예를 들어, IP 프록시는 서로 다른 접두사 및/또는 서로 다른 프로토콜로 범위가 지정된 두 개의 IP 프록시 요청에 동일한 공용 IP 주소를 할당할 수 있습니다.

요청 범위는 클라이언트가 URI 템플릿의 "target" 및 "ipproto" 변수를 통해 IP 프록시에 표시합니다. 섹션 3을 참조하십시오. "target" 및 "ipproto" 변수는 모두 선택 사항입니다. 포함되지 않은 경우 와일드카드 값 "\*"을 포함하는 것으로 간주됩니다.

표적:

- 변수 "target"에는 클라이언트가 패킷을 프록시하려는 특정 호스트의 호스트 이름 또는 IP 접두사가 포함됩니다. "target" 변수가 지정되지 않거나 해당 값이 "\*"인 경우 클라이언트는 허용되는 호스트와의 통신을 요청하는 것입니다. "target"은 DNS 이름, IPv6 접두사 및 IPv4 접두사 사용을 지원합니다. IPv6 범위 주소 지정 영역 식별자 \[IPv6-ZONE-ID\]는 지원되지 않습니다. 대상이 IP 접두사\(IP 주소 뒤에 선택적으로 백분율로 인코딩된 슬래시와 접두사 길이\(비트\)가 옴\)인 경우 요청은 단일 IP 버전만 지원합니다. 대상이 호스트 이름인 경우 IP 프록시는 클라이언트에 광고할 경로를 결정하기 위해 DNS 확인을 수행해야 합니다. IP 프록시는 요청된 호스트 이름에 대해 확인되고 IP 프록시에 액세스할 수 있으며 IP 프록시가 할당된 주소도 보내는 주소 계열에 속하는 모든 주소에 대한 경로를 포함하는 ROUTE\_ADVERTISEMENT 캡슐을 보내야 합니다.\(SHOULD\)

이프로토:

- 변수 "ipproto"에는 인터넷 프로토콜 번호가 포함되어 있습니다. "할당된 인터넷 프로토콜 번호" IANA 레지스트리 \[IANA-PN\]에 정의된 목록을 참조하세요. 존재하는 경우 클라이언트가 이 요청에 대해 특정 IP 프로토콜만 프록시하기를 원함을 지정합니다. 값이 "\*"이거나 변수가 포함되지 않은 경우 클라이언트는 모든 IP 프로토콜을 사용하도록 요청하는 것입니다. "ipproto" 변수에 표시된 IP 프로토콜은 HTTP 데이터그램\(가장 바깥쪽 IP 헤더\)으로 직접 전송되는 IP 헤더에 포함되는 허용 가능한 다음 헤더 값을 나타냅니다. 이 필드의 값에 관계없이 ICMP 트래픽은 항상 허용됩니다.

\[URI\]의 IPv6address, IPv4address 및 reg-name이라는 용어를 사용하여 "target" 및 "ipproto" 변수는 \[ABNF\]의 표기법을 사용하여 그림 6의 형식을 준수해야 합니다. 추가로:\(MUST\)

\* "대상"에 IPv6 리터럴 또는 접두사가 포함된 경우 콜론\(":"\)은 백분율로 인코딩되어야 합니다. 예를 들어 대상 호스트가 "2001:db8::42"인 경우 URI에서 "2001%3Adb8%3A%3A42"로 인코딩됩니다.\(MUST\)

\* 존재하는 경우 "target"의 IP 접두사 길이 앞에는 백분율로 인코딩된 슬래시\("/"\): "%2F"가 와야 합니다. IP 접두사 길이는 0과 IP 주소 길이\(비트 포함\) 사이의 10진수를 나타내야 합니다.\(MUST, MUST\)

\* "대상"이 IP 접두사를 포함하고 접두사 길이가 IP 주소의 비트 길이보다 엄격하게 작은 경우 접두사 길이에 포함되지 않는 IP 주소의 하위 비트는 모두 0으로 설정되어야 합니다.\(MUST\)

\* "ipproto"는 0에서 255 사이의 10진수 정수 또는 와일드카드 값 "\*"을 나타내야 합니다.\(MUST\)

```text
   target = IPv6prefix / IPv4prefix / reg-name / "*"
   IPv6prefix = IPv6address ["%2F" 1*3DIGIT]
   IPv4prefix = IPv4address ["%2F" 1*2DIGIT]
   ipproto = 1*3DIGIT / "*"

                   Figure 6: URI Template Variable Format
```

IP 프록시는 클라이언트가 제공한 범위 정보를 사용하여 액세스 제어를 수행할 수 있습니다. 즉, 클라이언트가 범위에 포함된 대상에 액세스할 권한이 없으면 IP 프록시는 즉시 요청을 거부할 수 있습니다.\(MAY\)

---
### **4.7.  Capsules**

이 문서는 엔드포인트가 IP 구성 정보를 교환할 수 있도록 하는 여러 가지 새로운 캡슐 유형을 정의합니다. 두 엔드포인트 모두 이러한 새 캡슐을 원하는 만큼 보낼 수 있습니다.\(MAY\)

---
#### **4.7.1.  ADDRESS_ASSIGN Capsule**

ADDRESS\_ASSIGN 캡슐\(캡슐 유형 0x01\)을 사용하면 엔드포인트가 피어에 IP 주소 또는 접두사 목록을 할당할 수 있습니다. 모든 캡슐에는 현재 수신기에 할당된 IP 접두사의 전체 목록이 포함되어 있습니다. 이러한 주소 중 하나는 이 캡슐의 수신자가 보낸 IP 패킷의 소스 주소로 사용될 수 있습니다.

```text
   ADDRESS_ASSIGN Capsule {
     Type (i) = 0x01,
     Length (i),
     Assigned Address (..) ...,
   }

                  Figure 7: ADDRESS_ASSIGN Capsule Format
```

ADDRESS\_ASSIGN 캡슐에는 0개 이상의 할당된 주소 시퀀스가 ​​포함되어 있습니다.

```text
   Assigned Address {
     Request ID (i),
     IP Version (8),
     IP Address (32..128),
     IP Prefix Length (8),
   }

                     Figure 8: Assigned Address Format
```

각 할당된 주소에는 다음 필드가 포함됩니다.

요청 ID:

- 가변 길이 정수로 인코딩된 요청 식별자입니다. 이 주소 할당이 주소 요청\(섹션 4.7.2 참조\)에 대한 응답인 경우 이 필드는 요청의 해당 필드 값을 포함해야 합니다. 그렇지 않으면 이 필드는 0이 됩니다.\(MUST, MUST\)

IP 버전:

- 이 주소 할당의 IP 버전은 부호 없는 8비트 정수로 인코딩됩니다. 4 또는 6이어야 합니다.\(MUST\)

IP 주소:

- 할당된 IP 주소. IP 버전 필드의 값이 4인 경우 IP 주소 필드의 길이는 32비트여야 합니다. IP 버전 필드의 값이 6인 경우 IP 주소 필드의 길이는 128비트여야 합니다.\(MUST, MUST\)

IP 접두사 길이:

- 할당되는 접두사를 정의하는 데 사용되는 IP 주소의 비트 수이며 부호 없는 8비트 정수로 인코딩됩니다. 이는 IP 주소 필드의 길이\(비트\)보다 작거나 같아야 합니다. 접두사 길이가 IP 주소 길이와 같으면 이 캡슐의 수신자는 단일 소스 주소에서 패킷을 보낼 수 있습니다. 접두사 길이가 IP 주소 길이보다 작으면 이 캡슐의 수신자는 접두사에 속하는 모든 소스 주소에서 패킷을 보낼 수 있습니다. 접두어 길이가 IP 주소의 길이\(비트\)보다 엄격하게 작은 경우 접두어 길이에 포함되지 않는 IP 주소 필드의 하위 비트는 모두 0으로 설정되어야 합니다.\(MUST, MUST\)

수신 시 캡슐 필드 중 하나라도 잘못된 형식인 경우 캡슐 수신자는 \[HTTP-DGRAM\]의 섹션 3.3에 정의된 오류 처리 절차를 따라야 합니다.\(MUST\)

ADDRESS\_ASSIGN 캡슐에 이전에 다른 ADDRESS\_ASSIGN 캡슐에서 전송된 주소가 포함되어 있지 않으면 해당 주소가 제거되었음을 나타냅니다. ADDRESS\_ASSIGN 캡슐은 비어 있을 수도 있으며 이는 모든 주소가 제거되었음을 나타냅니다.

HTTP의 일부 IP 프록시 배포에서는 자체 패킷에 어떤 소스 주소를 설정할지 알기 전에 엔드포인트에 피어가 주소를 할당해야 합니다. 예를 들어 원격 액세스 VPN의 경우\(섹션 8.1\) 클라이언트는 사용할 주소를 알 때까지 IP 패킷을 보낼 수 없습니다. 이러한 배포에서 주소 할당을 기대하는 엔드포인트는 ADDRESS\_REQUEST 캡슐을 보내야 합니다. 예를 들어 정적 주소를 사용하여 대역 외로 구성된 경우와 같이 끝점에 주소 할당이 필요하지 않은 경우에는 필요하지 않습니다.\(MUST\)

ADDRESS\_ASSIGN 캡슐은 일반적으로 ADDRESS\_REQUEST 캡슐에 대한 응답으로 전송되지만 엔드포인트는 프롬프트 없이 ADDRESS\_ASSIGN 캡슐을 보낼 수 있습니다.\(MAY\)

---
#### **4.7.2.  ADDRESS_REQUEST Capsule**

ADDRESS\_REQUEST 캡슐\(캡슐 유형 0x02\)을 사용하면 엔드포인트가 피어로부터 IP 주소 할당을 요청할 수 있습니다. 캡슐을 사용하면 엔드포인트가 할당될 주소에 대한 기본 설정을 선택적으로 나타낼 수 있습니다.

```text
   ADDRESS_REQUEST Capsule {
     Type (i) = 0x02,
     Length (i),
     Requested Address (..) ...,
   }

                  Figure 9: ADDRESS_REQUEST Capsule Format
```

ADDRESS\_REQUEST 캡슐에는 하나 이상의 요청된 주소 시퀀스가 ​​포함되어 있습니다.

```text
   Requested Address {
     Request ID (i),
     IP Version (8),
     IP Address (32..128),
     IP Prefix Length (8),
   }

                    Figure 10: Requested Address Format
```

각 요청된 주소에는 다음 필드가 포함됩니다.

요청 ID:

- 가변 길이 정수로 인코딩된 요청 식별자입니다. 이는 이 특정 주소 요청의 식별자입니다. 특정 엔드포인트의 각 요청은 서로 다른 식별자를 전달합니다. 요청 ID는 엔드포인트에서 재사용되어서는 안 되며 0이 되어서도 안 됩니다.\(MUST NOT\)

IP 버전:

- 부호 없는 8비트 정수로 인코딩된 이 주소 요청의 IP 버전입니다. 4 또는 6이어야 합니다.\(MUST\)

IP 주소:

- 요청된 IP 주소. IP 버전 필드의 값이 4인 경우 IP 주소 필드의 길이는 32비트여야 합니다. IP 버전 필드의 값이 6인 경우 IP 주소 필드의 길이는 128비트여야 합니다.\(MUST, MUST\)

IP 접두사 길이:

- 부호 없는 8비트 정수로 인코딩된 비트 단위로 요청된 IP 접두사의 길이입니다. IP 주소 필드의 길이\(비트\)보다 작거나 같아야 합니다. 접두어 길이가 IP 주소의 길이\(비트\)보다 엄격하게 작은 경우 접두어 길이에 포함되지 않는 IP 주소 필드의 하위 비트는 모두 0으로 설정되어야 합니다.\(MUST, MUST\)

IP 주소가 모두 0인 경우\(0.0.0.0 또는 ::\) 이는 발신자가 해당 주소 계열의 주소를 요청하지만 특정 주소에 대한 기본 설정이 없음을 나타냅니다. 해당 시나리오에서 접두사 길이는 요청하는 접두사 길이에 대한 발신자의 선호도를 계속 나타냅니다.

수신 시 캡슐 필드 중 하나라도 잘못된 형식인 경우 캡슐 수신자는 \[HTTP-DGRAM\]의 섹션 3.3에 정의된 오류 처리 절차를 따라야 합니다.\(MUST\)

ADDRESS\_REQUEST 캡슐을 수신하면 엔드포인트는 하나 이상의 IP 주소를 피어에 할당한 다음 ADDRESS\_ASSIGN 캡슐로 응답하여 피어에게 할당을 알려야 합니다. 각 요청 주소에 대해 ADDRESS\_REQUEST 캡슐의 수신자는 일치하는 요청 ID가 있는 할당 주소로 응답해야 합니다. 요청된 주소가 할당된 경우 할당된 주소 응답의 IP 주소 및 IP 접두사 길이 필드는 할당된 값으로 설정되어야 합니다. 요청된 주소가 할당되지 않은 경우 IP 주소는 모두 0이어야 하며 IP 접두사 길이는 주소가 할당되지 않았음을 나타내는 최대 길이\(0.0.0.0/32 또는 ::/128\)여야 합니다. 이러한 주소 거부는 후속 ADDRESS\_ASSIGN 캡슐에 포함되어서는 안 됩니다. 요청 ID와 일치하지 않는 다른 할당된 주소 항목도 동일한 ADDRESS\_ASSIGN 응답에 포함될 수 있습니다.\(SHOULD, MUST, MUST, MUST, SHOULD NOT\)

엔드포인트가 요청된 주소가 0개 포함된 ADDRESS\_REQUEST 캡슐을 수신하는 경우 IP 프록시 요청 스트림을 중단해야 합니다.\(MUST\)

요청된 주소의 순서에는 어떤 의미도 포함되지 않습니다. 마찬가지로 요청 ID는 고유 식별자로만 사용됩니다. 우선순위나 중요성을 전달하지 않습니다.

---
#### **4.7.3.  ROUTE_ADVERTISEMENT Capsule**

ROUTE\_ADVERTISEMENT 캡슐\(캡슐 유형 0x03\)을 사용하면 엔드포인트가 트래픽을 일련의 IP 주소 범위로 라우팅할 의사가 있음을 피어와 통신할 수 있습니다. 이는 발신자가 각 주소 범위에 대한 기존 경로를 가지고 있음을 나타내며 ROUTE\_ADVERTISEMENT 캡슐의 수신자가 HTTP 데이터그램에서 이러한 범위 중 하나에 대해 IP 패킷을 보내는 경우 캡슐 발신자가 기존 경로를 따라 이를 전달할 것임을 피어에게 알립니다. . 주소 범위 중 하나에 있는 모든 주소는 이 캡슐의 수신자가 보낸 IP 패킷의 대상 주소로 사용될 수 있습니다.

```text
   ROUTE_ADVERTISEMENT Capsule {
     Type (i) = 0x03,
     Length (i),
     IP Address Range (..) ...,
   }

               Figure 11: ROUTE_ADVERTISEMENT Capsule Format
```

ROUTE\_ADVERTISEMENT 캡슐에는 0개 이상의 IP 주소 범위 시퀀스가 ​​포함되어 있습니다.

```text
   IP Address Range {
     IP Version (8),
     Start IP Address (32..128),
     End IP Address (32..128),
     IP Protocol (8),
   }

                     Figure 12: IP Address Range Format
```

각 IP 주소 범위에는 다음 필드가 포함됩니다.

IP 버전:

- 이 범위의 IP 버전은 부호 없는 8비트 정수로 인코딩됩니다. 4 또는 6이어야 합니다.\(MUST\)

시작 IP 주소 및 끝 IP 주소:

- 알려진 범위의 시작 및 끝 IP 주소를 포함합니다. IP 버전 필드의 값이 4인 경우 이 필드의 길이는 32비트입니다. IP 버전 필드의 값이 6인 경우 이 필드의 길이는 128비트입니다. 시작 IP 주소는 종료 IP 주소보다 작거나 같아야 합니다.\(MUST, MUST, MUST\)

IP 프로토콜:

- 이 범위로 전송될 수 있는 트래픽의 인터넷 프로토콜 번호는 부호 없는 8비트 정수로 인코딩됩니다. 값이 0이면 모든 프로토콜이 허용됩니다. 값이 0이 아닌 경우 HTTP 데이터그램\(가장 바깥쪽 IP 헤더\)으로 직접 전송되는 IP 헤더에 포함되어 허용되는 다음 헤더 값을 나타냅니다. 이 필드의 값에 관계없이 ICMP 트래픽은 항상 허용됩니다.

수신 시 캡슐 필드 중 하나라도 잘못된 형식인 경우 캡슐 수신자는 \[HTTP-DGRAM\]의 섹션 3.3에 정의된 오류 처리 절차를 따라야 합니다.\(MUST\)

ROUTE\_ADVERTISEMENT 캡슐을 수신하면 엔드포인트는 라우팅 테이블에 항목을 설치하는 등 피어가 라우팅하려는 항목\(로컬 정책에 따라\)에 관한 로컬 상태를 업데이트할 수 있습니다.\(MAY\)

각 ROUTE\_ADVERTISEMENT에는 주소 범위의 전체 목록이 포함됩니다. 여러 ROUTE\_ADVERTISEMENT 캡슐이 한 방향으로 전송되는 경우 각 ROUTE\_ADVERTISEMENT 캡슐이 이전 캡슐보다 우선합니다. 즉, 주어진 주소 범위가 이전 캡슐에 있었지만 가장 최근에 수신된 ROUTE\_ADVERTISEMENT 캡슐에 해당 주소 범위가 포함되어 있지 않은 경우 수신자는 해당 범위가 철회된 것으로 간주합니다.

동일한 IP 프로토콜을 사용하는 여러 범위가 겹치는 경우 일부 라우팅 테이블 구현에서는 이를 거부할 수 있습니다. 중복을 방지하기 위해 범위가 정렬됩니다. 이는 발신자에게 부담을 주고 수신자의 확인을 훨씬 간단하게 만듭니다. 동일한 ROUTE\_ADVERTISEMENT 캡슐에서 IP 주소 범위 A가 IP 주소 범위 B보다 앞에 있는 경우 다음 요구 사항을 따라야 합니다.\(MUST\)

\* A의 IP 버전은 B의 IP 버전보다 낮거나 같아야 합니다.\(MUST\)

\* A와 B의 IP 버전이 동일한 경우 A의 IP 프로토콜은 B의 IP 프로토콜보다 작거나 같아야 합니다.\(MUST\)

\* A와 B의 IP 버전과 IP 프로토콜이 모두 동일한 경우 A의 끝 IP 주소는 B의 시작 IP 주소보다 엄격히 작아야 합니다.\(MUST\)

엔드포인트가 이러한 요구 사항을 충족하지 않는 ROUTE\_ADVERTISEMENT 캡슐을 수신하면 IP 프록시 요청 스트림을 중단해야 합니다.\(MUST\)

IP 프로토콜을 0으로 설정하면 모든 프로토콜이 허용된다는 의미이므로 위의 요구 사항에 따라 하나의 IP 프로토콜이 0으로 설정되고 다른 하나의 IP 프로토콜이 0이 아닌 경우 두 경로가 겹칠 수 있습니다. 엔드포인트는 그런 방식으로 겹치는 경로가 포함된 ROUTE\_ADVERTISEMENT 캡슐을 전송해서는 안 됩니다. 이 요구 사항을 검증하는 것은 선택 사항이지만 엔드포인트가 위반을 감지하면 IP 프록시 요청 스트림을 중단해야 합니다.\(MUST NOT, MUST\)

---
### **4.8.  IPv6 Extension Headers**

요청 범위 지정\(섹션 4.6 참조\)과 ROUTE\_ADVERTISEMENT 캡슐\(섹션 4.7.3 참조\) 모두 인터넷 프로토콜 번호를 사용합니다. 이 숫자는 상위 계층\(\[IPv6\]의 섹션 2에 정의된 대로 TCP 및 UDP를 포함하는 예 포함\)과 IPv6 확장 헤더\(\[IPv6\]의 섹션 4에 정의된 대로 조각 및 옵션 헤더를 포함하는 예\)를 모두 나타냅니다. IP 프록시는 확장 헤더에 사용되는 프로토콜 번호 범위에 대한 요청을 거부할 수 있습니다. 패킷을 수신하면 인터넷 프로토콜 번호에 의한 범위 지정 또는 라우팅을 지원하는 구현은 범위 지정 규칙과 일치하는 가장 바깥쪽의 비확장 인터넷 프로토콜 번호를 찾기 위해 확장 체인을 따라 이동해야 합니다. ROUTE\_ADVERTISEMENT 캡슐은 인터넷 프로토콜 번호 0을 사용하여 모든 프로토콜이 허용됨을 나타냅니다. IPv6 홉별 옵션 헤더\(\[IPv6\]의 섹션 4.3\)로 경로를 제한하지 않습니다.\(MAY, MUST\)

---
## **5.  Context Identifiers**

이 문서에 정의된 HTTP에서 IP를 프록시하는 메커니즘을 사용하면 향후 확장이 IP 페이로드와 다른 의미를 전달하는 HTTP 데이터그램을 교환할 수 있습니다. 이러한 확장 중 일부는 추가 데이터로 IP 페이로드를 늘리거나 IP 헤더 필드를 압축할 수 있는 반면 다른 확장은 IP 페이로드와 완전히 별개인 데이터를 교환할 수 있습니다. 이를 달성하기 위해 IP 프록시 요청 스트림과 관련된 모든 HTTP 데이터그램은 컨텍스트 ID 필드로 시작합니다. 섹션 6을 참조하세요.

컨텍스트 ID는 62비트 정수\(0 \~ 2^62-1\)입니다. 컨텍스트 ID는 가변 길이 정수로 인코딩됩니다. \[QUIC\]의 섹션 16을 참조하세요. 컨텍스트 ID 값 0은 IP 페이로드용으로 예약된 반면, 0이 아닌 값은 동적으로 할당됩니다. 0이 아닌 짝수 컨텍스트 ID는 클라이언트에서 할당되고, 홀수 컨텍스트 ID는 프록시 할당됩니다. 컨텍스트 ID 네임스페이스는 특정 HTTP 요청에 연결되어 있습니다. 동일한 숫자 값을 가진 컨텍스트 ID가 잠재적으로 다른 의미 체계를 사용하여 개별 요청에 동시에 할당될 수 있습니다. 컨텍스트 ID는 주어진 HTTP 요청 내에서 다시 할당되어서는 안 되지만 순서에 관계없이 할당될 수 있습니다. 엔드포인트 간의 동기화 필요성을 피하기 위해 짝수 및 홀수 컨텍스트 ID 사용에 대한 컨텍스트 ID 할당 제한이 존재합니다. 그러나 일단 컨텍스트 ID가 할당되면 해당 제한 사항은 컨텍스트 ID 사용에 적용되지 않습니다. 처음에 할당한 엔드포인트와 관계없이 클라이언트나 IP 프록시에서 사용할 수 있습니다.\(MUST NOT\)

등록은 엔드포인트가 피어에게 주어진 컨텍스트 ID의 의미와 형식을 알리는 작업입니다. 이 문서는 등록 방법을 정의하지 않습니다. 향후 확장은 HTTP 헤더 필드 또는 캡슐을 사용하여 컨텍스트 ID를 등록할 수 있습니다. 사용되는 방법에 따라 아직 등록되지 않은 컨텍스트 ID로 데이터그램을 수신할 수도 있습니다. 예를 들어, 이는 전송 중에 데이터그램을 포함하는 패킷과 등록 메시지를 포함하는 패킷의 재정렬로 인해 발생할 수 있습니다.\(MAY\)

---
## **6.  HTTP Datagram Payload Format**

IP 프록시 요청 스트림과 연관될 때 HTTP 데이터그램의 HTTP 데이터그램 페이로드 필드\(\[HTTP-DGRAM\] 참조\)는 그림 13에 정의된 형식을 갖습니다. HTTP 데이터그램이 QUIC DATAGRAM 프레임을 사용하여 인코딩되면 컨텍스트 ID 필드가 정의됩니다. 아래는 QUIC DATAGRAM 프레임 페이로드의 시작 부분에 있는 Quarter Stream ID 필드 바로 뒤에 있습니다.

```text
   IP Proxying HTTP Datagram Payload {
     Context ID (i),
     Payload (..),
   }

                Figure 13: IP Proxying HTTP Datagram Format
```

IP 프록싱 HTTP 데이터그램 페이로드에는 다음 필드가 포함되어 있습니다.

컨텍스트 ID:

- 컨텍스트 ID 값을 포함하는 가변 길이 정수입니다. 알 수 없는 컨텍스트 ID를 전달하는 HTTP/3 데이터그램이 수신되면 수신자는 해당 데이터그램을 자동으로 삭제하거나 해당 컨텍스트 ID의 등록을 기다리는 동안 일시적으로\(왕복 순서에 따라\) 버퍼링해야 합니다.\(MUST\)

유효 탑재량:

- 의미가 이전 필드의 값에 따라 달라지는 데이터그램의 페이로드입니다. 이 필드는 비어 있을 수 있습니다.

IP 패킷은 컨텍스트 ID가 0으로 설정된 HTTP 데이터그램을 사용하여 인코딩됩니다. 컨텍스트 ID가 0으로 설정되면 페이로드 필드에는 전체 IP 패킷\(IP 버전 필드부터 IP 페이로드의 마지막 바이트까지\)이 포함됩니다.

---
## **7.  IP Packet Handling**

이 문서는 개념적으로 IP 링크인 터널링 메커니즘을 정의합니다. 그러나 링크는 IP 라우터에 연결되므로 구현은 IP 라우터의 책임 중 일부를 커널과 같은 다른 구현에 위임하지 않는 경우 처리해야 할 수도 있습니다.

---
### **7.1.  Link Operation**

이 문서에 설명된 IP 전달 터널은 IPv6 주소 지정 아키텍처 의미 \[IPv6-ADDR\]에서 완전한 기능을 갖춘 "인터페이스"가 아닙니다. 특히 IPv6 링크-로컬 주소가 반드시 필요한 것은 아닙니다. 또한 IPv6 상태 비저장 자동 구성 또는 라우터 광고 메시지는 이러한 인터페이스에서 사용되지 않으며 이웃 검색도 마찬가지입니다.

HTTP/2 또는 HTTP/3을 사용할 때 클라이언트는 IP 프록시 요청에 대한 응답을 받기 전에 낙관적으로 프록시된 IP 패킷 전송을 시작할 수 있습니다. 그러나 요청에 실패하여 응답하는 경우 IP 프록시에서 해당 패킷을 처리하지 못할 수 있다는 점에 유의하세요. 또는 요청 전에 IP 프록시가 데이터그램을 수신한 경우. 패킷이 터널을 통해 전송될 수 있는지 확인하려면 수신 주소와 경로가 필요하므로 클라이언트가 가정한 것과 다른 주소 지정 또는 라우팅 정보를 제공하기로 선택한 경우 IP 프록시가 이러한 낙관적 패킷을 삭제할 수 있습니다.\(MAY\)

예를 들어, QUIC 패킷이 두 개 이상의 QUIC DATAGRAM 프레임을 전달할 수 있기 때문에 여러 개의 프록시된 IP 패킷이 동일한 외부 패킷에 캡슐화될 수 있습니다. DATAGRAM 캡슐이 여러 QUIC 또는 TCP 패킷에 걸쳐 분할될 수 있으므로 프록시된 IP 패킷이 여러 외부 패킷에 걸쳐 있을 수도 있습니다.

---
### **7.2.  Routing Operation**

이 섹션의 요구 사항은 일반적으로 IP 라우터에 적용되는 요구 사항을 반복한 것이며 라우팅을 위해 외부 소프트웨어를 사용하는 IP 프록시 구현에는 적용되지 않을 수도 있습니다.

엔드포인트가 IP 패킷이 포함된 HTTP 데이터그램을 수신하면 패킷의 IP 헤더를 구문 분석하고 로컬 정책 확인\(예: 소스 주소 유효성 검사\)을 수행하고 라우팅 테이블을 확인하여 아웃바운드 인터페이스를 선택한 다음 IP 패킷을 보냅니다. 해당 인터페이스를 사용하거나 로컬 애플리케이션에 전달합니다. 엔드포인트는 수신된 패킷을 전달하는 대신 삭제하도록 선택할 수도 있습니다. 수신된 IP 패킷이 정확성이나 정책 확인에 실패하는 경우 이는 IP 프록시에 관한 한 프로토콜 위반이 아니라 전달 오류입니다. 섹션 7.2.1을 참조하세요. IP 프록시 엔드포인트는 자신이 전달하는 IP 패킷에 대해 추가 필터링 정책을 구현할 수 있습니다.\(MAY\)

다른 방향에서는 엔드포인트가 IP 패킷을 수신하면 패킷이 IP 터널에 매핑된 경로와 일치하는지 확인하고 HTTP 데이터그램을 통해 패킷을 전송하기 전에 위와 동일한 전달 확인을 수행합니다.

IP 프록시 엔드포인트가 서로 다른 링크 간에 IP 패킷을 전달할 때 캡슐화 시 IP 홉 수\(또는 TTL\)가 감소하지만 캡슐화 해제 시에는 감소하지 않습니다. 즉, IP 패킷이 HTTP 데이터그램으로 전송되기 직전에 Hop Count가 감소됩니다. 이는 라우팅 루프가 있는 경우 무한 루프를 방지하고 IPsec \[IPSEC\]의 선택 사항과 일치합니다. 이는 IP 프록시 끝점 자체에서 생성된 IP 패킷에는 적용되지 않습니다.

구현자는 링크-로컬 트래픽이 수신된 IP 프록시 인터페이스 이상으로 전달되지 않도록 해야 합니다. 또한 IP 프록시 끝점은 링크 로컬 멀티캐스트 주소로 향하는 패킷에 적절하게 응답해야 합니다.

IPv6에서는 모든 링크의 MTU가 최소 1280바이트\[IPv6\]여야 합니다. HTTP의 IP 프록시는 HTTP 데이터그램으로 IP 패킷을 전달하고 그 패킷은 조각화될 수 없는 QUIC 데이터그램 프레임\[DGRAM\]으로 전송될 수 있으므로 IP 터널의 MTU는 IP 프록시가 수행하는 QUIC 연결의 MTU에 의해 제한될 수 있습니다. 이상 운영 중입니다. 이로 인해 IPv6 최소 링크 MTU가 위반되는 상황이 발생할 수 있습니다. 라우터로 작동하고 IPv6를 지원하는 IP 프록시 엔드포인트는 IP 터널 링크 MTU가 최소 1280바이트인지 확인해야 합니다\(즉, 페이로드가 최소 1280바이트인 HTTP 데이터그램을 보낼 수 있음\). 이는 다양한 기술을 사용하여 수행할 수 있습니다.\(MUST\)

\* 두 IP 프록시 엔드포인트가 모두 HTTP를 확실히 알고 있는 경우

- 중개자가 사용되지 않는 경우 엔드포인트는 IP 프록시가 실행되는 외부 QUIC 연결의 QUIC INITIAL 패킷을 채울 수 있습니다. \(QUIC 버전 1을 사용한다고 가정하면 오버헤드는 유형에 1바이트, 최대 연결 ID 길이에 20바이트, 최대 패킷 번호 길이에 4바이트, DATAGRAM 프레임 유형에 1바이트, 최대 분기에 8바이트입니다. 스트림 ID, 0 컨텍스트 ID용 1바이트, AEAD\(Authenticated Encryption with Associated Data\) 인증 태그용 16바이트, 총 51바이트의 오버헤드에 대해 이는 QUIC INITIAL 패킷을 1331바이트 이상으로 패딩하는 데 해당합니다.\)

\* IP 프록시 끝점은 링크 MTU를 확인하고 응답을 받지 못할 경우 터널을 해제하기 위해 1232바이트의 데이터가 포함된 ICMPv6 에코 요청을 보낼 수도 있습니다. 종단점에 이전 기술이 충분하다는 것을 보장하는 대역 외 수단이 없으면 이 방법을 사용해야 합니다. 엔드포인트가 피어의 IPv6 주소를 모르는 경우 ICMPv6 에코 요청을 링크-로컬 모든 노드 멀티캐스트 주소\(ff02::1\)로 보낼 수 있습니다.\(MUST\)

엔드포인트가 IPv6 패킷을 전달하기 위해 QUIC DATAGRAM 프레임을 사용하고 있고 QUIC MTU가 너무 낮아서 1280바이트 전송을 허용할 수 없음을 감지한 경우 IP 프록싱 요청 스트림을 중단해야 합니다.\(MUST\)

---
#### **7.2.1.  Error Signalling**

IP 프록시 엔드포인트는 IP 패킷을 다른 네트워크 인터페이스로 전달하는 경우가 많기 때문에 전달 프로세스의 오류를 처리해야 합니다. 예를 들어 엔드포인트에 대상 주소에 대한 경로가 없거나 정책에 따라 대상 접두사를 거부하도록 구성된 경우 또는 나가는 링크의 MTU가 전달할 패킷의 크기보다 작은 경우 전달이 실패할 수 있습니다. . 이러한 시나리오에서 IP 프록시 끝점은 ICMP 패킷을 생성하고 HTTP 데이터그램을 사용하여 전송함으로써 피어에 전달 오류를 알리기 위해 ICMP \[ICMP\] \[ICMPv6\]를 사용해야 합니다.\(SHOULD\)

엔드포인트는 보낼 가장 적절한 ICMP 오류를 자유롭게 선택할 수 있습니다. IP 프록시와 관련된 몇 가지 예는 다음과 같습니다.

\* 유효하지 않은 소스 주소의 경우, 코드 5, "소스 주소 실패 수신/송신 정책"과 함께 연결할 수 없는 대상\(\[ICMPv6\]의 섹션 3.1\)을 보냅니다.

\* 라우팅할 수 없는 대상 주소의 경우 코드 0, "대상으로의 경로 없음" 또는 코드 1, "관리적으로 금지된 대상과의 통신"과 함께 대상 도달 불가능\(\[ICMPv6\] 섹션 3.1\)을 보냅니다.

\* 나가는 링크의 MTU에 맞지 않는 패킷의 경우 Packet Too Big\(\[ICMPv6\]의 섹션 3.2\)을 보냅니다.

이러한 오류를 수신하려면 엔드포인트가 ICMP 패킷을 수신할 준비를 해야 합니다. IP 프록시를 통해 IP 흐름을 여는 클라이언트와 같이 엔드포인트가 ROUTE\_ADVERTISEMENT 캡슐을 보내지 않는 경우 이러한 오류를 수신하려면 피어에서 프록시된 ICMP 패킷을 처리해야 합니다. ICMP 메시지는 IP 프록시 피어의 주소와 다른 소스 주소에서 시작될 수 있으며 범위 지정이 사용 중인 경우 대상 외부에서도 시작될 수 있습니다\(섹션 4.6 참조\).\(SHOULD\)

---
## **8.  Examples**

HTTP의 IP 프록시는 IP 패킷 프록시 및 터널링의 이점을 누릴 수 있는 다양한 사용 사례를 가능하게 합니다. 이러한 예는 HTTP에서 IP 프록시를 사용할 수 있는 몇 가지 방법을 설명하는 데 도움이 되도록 제공됩니다.

---
### **8.1.  Remote Access VPN**

다음 예에서는 클라이언트가 로컬 주소 세트를 수신하고 IP 프록시를 통해 모든 원격 호스트에 보낼 수 있는 지점-네트워크 VPN 설정을 보여줍니다. 이러한 VPN 설정은 전체 터널 또는 분할 터널일 수 있습니다.

```text
   +--------+ IP A          IP B +--------+           +---> IP D
   |        +--------------------+   IP   | IP C      |
   | Client | IP Subnet C <--> ? |  Proxy +-----------+---> IP E
   |        +--------------------+        |           |
   +--------+                    +--------+           +---> IP ...

                        Figure 14: VPN Tunnel Setup
```

이 경우 클라이언트는 요청에 범위를 지정하지 않습니다. IP 프록시는 클라이언트에 IPv4 주소\(192.0.2.11\)와 모든 IPv4 주소\(0.0.0.0/0\)의 전체 터널 경로를 할당합니다. 그런 다음 클라이언트는 할당된 주소를 소스 주소로 사용하여 모든 IPv4 호스트에 보낼 수 있습니다.

\[\[ 클라이언트에서 \]\] \[\[ IP 프록시에서 \]\]

```text
   SETTINGS
     H3_DATAGRAM = 1

                                 SETTINGS
                                   ENABLE_CONNECT_PROTOCOL = 1
                                   H3_DATAGRAM = 1

   STREAM(44): HEADERS
   :method = CONNECT
   :protocol = connect-ip
   :scheme = https
   :path = /vpn
   :authority = proxy.example.com
   capsule-protocol = ?1

                                 STREAM(44): HEADERS
                                 :status = 200
                                 capsule-protocol = ?1

   STREAM(44): DATA
   Capsule Type = ADDRESS_REQUEST
   (Request ID = 1
    IP Version = 4
    IP Address = 0.0.0.0
    IP Prefix Length = 32)

                                 STREAM(44): DATA
                                 Capsule Type = ADDRESS_ASSIGN
                                 (Request ID = 1
                                  IP Version = 4
                                  IP Address = 192.0.2.11
                                  IP Prefix Length = 32)

                                 STREAM(44): DATA
                                 Capsule Type = ROUTE_ADVERTISEMENT
                                 (IP Version = 4
                                  Start IP Address = 0.0.0.0
                                  End IP Address = 255.255.255.255
                                  IP Protocol = 0) // Any

   DATAGRAM
   Quarter Stream ID = 11
   Context ID = 0
   Payload = Encapsulated IP Packet

                                 DATAGRAM
                                 Quarter Stream ID = 11
                                 Context ID = 0
                                 Payload = Encapsulated IP Packet

                     Figure 15: VPN Full-Tunnel Example
```

분할 터널 VPN\(클라이언트가 특정 프라이빗 서브넷 세트에만 액세스할 수 있는 경우\)의 설정은 매우 유사합니다. 이 경우 공지된 경로는 0.0.0.0/0이 아닌 192.0.2.0/24로 제한됩니다.

\[\[ 클라이언트에서 \]\] \[\[ IP 프록시에서 \]\]

```text
                                 STREAM(44): DATA
                                 Capsule Type = ADDRESS_ASSIGN
                                 (Request ID = 0
                                  IP Version = 4
                                  IP Address = 192.0.2.42
                                  IP Prefix Length = 32)

                                 STREAM(44): DATA
                                 Capsule Type = ROUTE_ADVERTISEMENT
                                 (IP Version = 4
                                  Start IP Address = 192.0.2.0
                                  End IP Address = 192.0.2.41
                                  IP Protocol = 0) // Any
                                 (IP Version = 4
                                  Start IP Address = 192.0.2.43
                                  End IP Address = 192.0.2.255
                                  IP Protocol = 0) // Any

                    Figure 16: VPN Split-Tunnel Example
```

---
### **8.2.  Site-to-Site VPN**

다음 예에서는 네트워크의 모든 컴퓨터가 통신할 수 있도록 지점 네트워크를 회사 네트워크에 연결하는 방법을 보여줍니다. 이 예에서 IP 프록시 클라이언트는 지점 네트워크 192.0.2.0/24에 연결되고, IP ​​프록시는 회사 네트워크 203.0.113.0/24에 연결됩니다. 지점 네트워크에는 해당 서브넷에 있는 컴퓨터의 유지 관리 요청만 허용하는 레거시 클라이언트가 있으므로 IP 프록시는 해당 서브넷의 IP 주소로 프로비저닝됩니다.

```text
   192.0.2.1 <--+   +--------+             +-------+   +---> 203.0.113.9
                |   |        +-------------+  IP   |   |
   192.0.2.2 <--+---+ Client | IP Proxying | Proxy +---+---> 203.0.113.8
                |   |        +-------------+       |   |
   192.0.2.3 <--+   +--------+             +-------+   +---> 203.0.113.7

                    Figure 17: Site-to-Site VPN Example
```

이 경우 클라이언트는 요청에 범위를 지정하지 않습니다. IP 프록시는 클라이언트에 IPv4 주소\(203.0.113.100\)와 회사 네트워크\(203.0.113.0/24\)에 대한 분할 터널 경로를 할당합니다. 클라이언트는 IP 프록시에 IPv4 주소\(192.0.2.200\)와 지점 네트워크\(192.0.2.0/24\)에 대한 분할 터널 경로를 할당합니다. 이를 통해 두 네트워크의 호스트가 서로 통신할 수 있고 IP 프록시가 지점의 레거시 호스트에서 유지 관리를 수행할 수 있습니다. IP 프록시 엔드포인트는 전달된 패킷을 캡슐화할 때 IP 홉 수\(또는 TTL\)를 감소시키므로 해당 필드를 255로 설정해야 하는 프로토콜은 작동하지 않습니다.

\[\[ 클라이언트에서 \]\] \[\[ IP 프록시에서 \]\]

```text
   SETTINGS
     H3_DATAGRAM = 1

                                 SETTINGS
                                   ENABLE_CONNECT_PROTOCOL = 1
                                   H3_DATAGRAM = 1

   STREAM(44): HEADERS
   :method = CONNECT
   :protocol = connect-ip
   :scheme = https
   :path = /corp
   :authority = proxy.example.com
   capsule-protocol = ?1

                                 STREAM(44): HEADERS
                                 :status = 200
                                 capsule-protocol = ?1

   STREAM(44): DATA
   Capsule Type = ADDRESS_ASSIGN
   (Request ID = 0
   IP Version = 4
   IP Address = 192.0.2.200
   IP Prefix Length = 32)

   STREAM(44): DATA
   Capsule Type = ROUTE_ADVERTISEMENT
   (IP Version = 4
   Start IP Address = 192.0.2.0
   End IP Address = 192.0.2.255
   IP Protocol = 0) // Any

                                 STREAM(44): DATA
                                 Capsule Type = ADDRESS_ASSIGN
                                 (Request ID = 0
                                  IP Version = 4
                                  IP Address = 203.0.113.100
                                  IP Prefix Length = 32)

                                 STREAM(44): DATA
                                 Capsule Type = ROUTE_ADVERTISEMENT
                                 (IP Version = 4
                                  Start IP Address = 203.0.113.0
                                  End IP Address = 203.0.113.255
                                  IP Protocol = 0) // Any

   DATAGRAM
   Quarter Stream ID = 11
   Context ID = 0
   Payload = Encapsulated IP Packet

                                 DATAGRAM
                                 Quarter Stream ID = 11
                                 Context ID = 0
                                 Payload = Encapsulated IP Packet

                Figure 18: Site-to-Site VPN Capsule Example
```

---
### **8.3.  IP Flow Forwarding**

다음 예에서는 클라이언트가 SCTP\(스트림 제어 전송 프로토콜\)\(IP 프로토콜 132\)를 사용하여 target.example.com에 대한 전달 터널을 설정하도록 요청하고 단일 로컬 주소와 원격 주소를 수신하는 IP 흐름 전달 설정을 보여줍니다. 패킷 전송에 사용됩니다. ICMP, ESP\(Encapslating Security Payload\) 등과 같은 기존 HTTP 방법으로 쉽게 프록시되지 않는 다른 IP 프로토콜에도 유사한 접근 방식을 사용할 수 있습니다.

```text
   +--------+ IP A         IP B +--------+
   |        +-------------------+   IP   | IP C
   | Client |    IP C <--> D    |  Proxy +---------> IP D
   |        +-------------------+        |
   +--------+                   +--------+

                       Figure 19: Proxied Flow Setup
```

이 경우 클라이언트는 요청 범위에 대상 호스트 이름과 인터넷 프로토콜 번호를 모두 지정하여 단일 호스트와만 통신해야 함을 나타냅니다. IP 프록시는 클라이언트를 대신하여 DNS 확인을 수행하고 클라이언트에 전체 IP 주소를 할당하는 대신 클라이언트에 대한 특정 아웃바운드 소켓을 할당할 수 있습니다. 이 점에서 요청은 일반적인 CONNECT 프록시 요청과 유사합니다.

IP 프록시는 클라이언트\(2001:db8:1234::a\)에 단일 IPv6 주소를 할당하고 SCTP로 범위가 지정된 단일 IPv6 호스트\(2001:db8:3456::b\)에 대한 경로를 할당합니다. 클라이언트는 원격 호스트에 SCTP IP 패킷을 보내고 받을 수 있습니다.

\[\[ 클라이언트에서 \]\] \[\[ IP 프록시에서 \]\]

```text
   SETTINGS
     H3_DATAGRAM = 1

                                 SETTINGS
                                   ENABLE_CONNECT_PROTOCOL = 1
                                   H3_DATAGRAM = 1

   STREAM(44): HEADERS
   :method = CONNECT
   :protocol = connect-ip
   :scheme = https
   :path = /proxy?target=target.example.com&ipproto=132
   :authority = proxy.example.com
   capsule-protocol = ?1

                                 STREAM(44): HEADERS
                                 :status = 200
                                 capsule-protocol = ?1

                                 STREAM(44): DATA
                                 Capsule Type = ADDRESS_ASSIGN
                                 (Request ID = 0
                                  IP Version = 6
                                  IP Address = 2001:db8:1234::a
                                  IP Prefix Length = 128)

                                 STREAM(44): DATA
                                 Capsule Type = ROUTE_ADVERTISEMENT
                                 (IP Version = 6
                                  Start IP Address = 2001:db8:3456::b
                                  End IP Address = 2001:db8:3456::b
                                  IP Protocol = 132)

   DATAGRAM
   Quarter Stream ID = 11
   Context ID = 0
   Payload = Encapsulated SCTP/IP Packet

                                 DATAGRAM
                                 Quarter Stream ID = 11
                                 Context ID = 0
                                 Payload = Encapsulated SCTP/IP Packet

                    Figure 20: Proxied SCTP Flow Example
```

---
### **8.4.  Proxied Connection Racing**

다음 예는 Happy Eyeballs \[HEv2\]에 정의된 대로 IP 프록시를 통한 연결 설정 경주를 제어하기 위해 클라이언트가 IP 프록시를 통해 UDP 패킷을 프록시하는 설정을 보여줍니다. 이 예는 프록시된 흐름의 변형이지만 IP 수준 프록시가 TCP 및 UDP에 대해서도 새로운 기능을 활성화할 수 있는 방법을 강조합니다.

```text
   +--------+ IP A         IP B +--------+ IP C
   |        +-------------------+        |<------------> IP E
   | Client |  IP C <--> E      |   IP   |
   |        |     D <--> F      |  Proxy |
   |        +-------------------+        |<------------> IP F
   +--------+                   +--------+ IP D

                 Figure 21: Proxied Connection Racing Setup
```

프록시된 흐름과 마찬가지로 클라이언트는 요청 범위에서 대상 호스트 이름과 인터넷 프로토콜 번호를 모두 지정합니다. IP 프록시가 클라이언트를 대신하여 DNS 확인을 수행하면 다양한 원격 주소 옵션을 별도의 경로로 클라이언트에 보낼 수 있습니다. 또한 클라이언트에 IPv4 및 IPv6 주소가 모두 할당되어 있는지 확인할 수도 있습니다.

IP 프록시는 IPv4 주소\(192.0.2.3\)와 IPv6 주소\(2001:db8:1234::a\)를 클라이언트에 할당할 뿐만 아니라 IPv4 경로\(198.51.100.2\)와 IPv6 경로\(2001:db8\)도 할당합니다. :3456::b\)는 UDP 범위의 대상 호스트 이름의 확인된 주소를 나타냅니다. 클라이언트는 UDP IP 패킷을 IP 프록시 주소 중 하나로 보내고 수신하여 IP 프록시를 통해 Happy Eyeballs를 활성화할 수 있습니다.

\[\[ 클라이언트에서 \]\] \[\[ IP 프록시에서 \]\]

```text
   SETTINGS
     H3_DATAGRAM = 1

                                 SETTINGS
                                   ENABLE_CONNECT_PROTOCOL = 1
                                   H3_DATAGRAM = 1

   STREAM(44): HEADERS
   :method = CONNECT
   :protocol = connect-ip
   :scheme = https
   :path = /proxy?target=target.example.com&ipproto=17
   :authority = proxy.example.com
   capsule-protocol = ?1

                                 STREAM(44): HEADERS
                                 :status = 200
                                 capsule-protocol = ?1

                                 STREAM(44): DATA
                                 Capsule Type = ADDRESS_ASSIGN
                                 (Request ID = 0
                                  IP Version = 4
                                  IP Address = 192.0.2.3
                                  IP Prefix Length = 32),
                                 (Request ID = 0
                                  IP Version = 6
                                  IP Address = 2001:db8::1234:1234
                                  IP Prefix Length = 128)

                                 STREAM(44): DATA
                                 Capsule Type = ROUTE_ADVERTISEMENT
                                 (IP Version = 4
                                  Start IP Address = 198.51.100.2
                                  End IP Address = 198.51.100.2
                                  IP Protocol = 17),
                                 (IP Version = 6
                                  Start IP Address = 2001:db8:3456::b
                                  End IP Address = 2001:db8:3456::b
                                  IP Protocol = 17)
   ...

   DATAGRAM
   Quarter Stream ID = 11
   Context ID = 0
   Payload = Encapsulated IPv6 Packet

   DATAGRAM
   Quarter Stream ID = 11
   Context ID = 0
   Payload = Encapsulated IPv4 Packet

                Figure 22: Proxied Connection Racing Example
```

---
## **9.  Extensibility Considerations**

HTTP의 IP 프록시 확장은 이 메커니즘에 대한 동작 변경을 정의할 수 있습니다. 이러한 확장은 필요한 경우 구성 정보를 교환하기 위해 새로운 캡슐 유형을 정의해야 합니다\(SHOULD\). 확장 캡슐이 ADDRESS\_ASSIGN 캡슐 이전에 전송되고 ADDRESS\_ASSIGN 캡슐이 구문 분석될 때까지 적용되지 않도록 지정하기 위해 주소 지정을 수정하는 확장에 대해 권장됩니다. 이를 통해 주소 할당을 수정하여 원자적으로 작동할 수 있습니다. 마찬가지로, 라우팅을 수정하는 확장은 ROUTE\_ADVERTISEMENT 캡슐과 관련하여 유사하게 동작해야 합니다\(SHOULD\).\(SHOULD, SHOULD, SHOULD\)

---
## **10.  Performance Considerations**

버스트 트래픽은 종종 시간적으로 상관된 패킷 손실로 이어질 수 있습니다. 결과적으로 이는 터널 내부에서 실행되는 프로토콜의 혼잡 컨트롤러로부터 최적이 아닌 응답으로 이어질 수 있습니다. 이를 방지하려면 IP 프록시 엔드포인트는 IP 트래픽의 버스트 증가를 방지하기 위해 노력해야 합니다. 하드웨어 오프로드를 활용하는 데 필요한 최소량 이상으로 일괄 처리를 늘리기 위해 패킷을 대기열에 넣어서는 안 됩니다.\(SHOULD NOT\)

터널 내부에서 실행되는 프로토콜이 혼잡 제어\(예: \[TCP\] 또는 \[QUIC\]\)를 사용하는 경우 프록시된 트래픽에는 중첩된 혼잡 컨트롤러가 두 개 이상 발생합니다. 터널링된 패킷이 QUIC DATAGRAM 프레임을 사용하여 전송되면 외부 HTTP 연결은 IP 패킷을 캡슐화하는 QUIC DATAGRAM 프레임만 포함하는 패킷에 대한 정체 제어를 비활성화할 수 있습니다. 구현자는 \[UDP-USAGE\] 섹션 3.1.11의 지침을 읽으면 도움이 될 것입니다.\(MAY\)

터널 내부에서 실행되는 프로토콜이 손실 복구\(예: \[TCP\] 또는 \[QUIC\]\)를 사용하고 외부 HTTP 연결이 TCP를 통해 실행되는 경우 프록시된 트래픽에는 최소한 두 개의 중첩된 손실 복구 메커니즘이 발생합니다. 두 경우 모두 동일한 데이터를 독립적으로 재전송할 수 있으므로 성능이 저하될 수 있습니다. 이를 방지하려면 HTTP/3을 통해 IP 프록시를 수행하여 QUIC DATAGRAM 프레임 활용을 허용해야 합니다.\(SHOULD\)

---
### **10.1.  MTU Considerations**

QUIC 데이터그램 확장 \[DGRAM\]과 함께 HTTP/3을 사용하는 경우 IP 패킷은 QUIC DATAGRAM 프레임으로 전송됩니다. 이러한 프레임은 조각화될 수 없으므로 QUIC 연결 구성 및 경로 MTU\(PMTU\)에 의해 결정된 지정된 길이까지만 패킷을 전달할 수 있습니다. 엔드포인트가 QUIC DATAGRAM 프레임을 사용하고 있고 QUIC DATAGRAM 프레임 내부에 맞지 않는 터널을 통해 IP 패킷을 라우팅하려고 시도하는 경우 IP 프록시는 DATAGRAM 캡슐에 있는 IP 패킷을 전송해서는 안 됩니다. - DPLPMTUD\(Datagram Packetization Layer PMTU Discovery\)와 같은 방법이 \[DPLPMTUD\]에 의존하는 최종 불안정성 특성. 이 시나리오에서 엔드포인트는 IP 패킷을 삭제하고 삭제된 패킷의 발신자에게 ICMP 패킷이 너무 큼\(ICMP Packet Too Big\) 메시지를 보내야 합니다. \[ICMPv6\]의 섹션 3.2를 참조하세요.\(SHOULD NOT, SHOULD\)

---
### **10.2.  ECN Considerations**

IP 프록시 요청 스트림이 포함된 연결이 있는 IP 프록시 엔드포인트가 정체 제어를 비활성화하는 경우 해당 외부 연결에 대한 ECN\(명시적 혼잡 알림\) \[ECN\] 지원 신호를 보낼 수 없습니다. 즉, QUIC 발신자는 혼잡 제어 외부에 있는 QUIC 패킷에 대해 Not ECN-Capable Transport\(Not-ECT\) 코드 포인트로 모든 IP 헤더를 표시해야 합니다. 피어가 혼잡 제어를 비활성화하지 않았을 수 있으므로 엔드포인트는 QUIC ACK\_ECN 프레임 또는 TCP ECN-Echo\(ECE\) 비트를 통해 ECN 피드백을 계속 보고할 수 있습니다.\(MUST\)

반대로, 외부 정체에 대한 정체 제어가 비활성화되지 않은 경우, 외부 연결이 ECN을 사용하는 경우 정체 알림에 올바르게 반응하기 때문에 내부 IP 헤더와 외부 IP 헤더 간에 ECN 마크 전송에 대한 \[ECN-TUNNEL\]의 지침이 적용되지 않습니다. 내부 트래픽은 외부 연결에서 사용 중인지 여부와 관계없이 ECN을 사용할 수도 있습니다.

---
### **10.3.  Differentiated Services Considerations**

터널링된 IP 패킷에는 특정 홉별 동작을 요청하기 위해 트래픽 클래스 IP 헤더 필드에 DSCP\(Differentiated Services Code Points\)\[DSCP\]가 설정되어 있을 수 있습니다. IP 프록시 엔드포인트가 차별화된 서비스 도메인의 일부로 구성된 경우 이러한 표시를 기반으로 트래픽 차별화를 구현할 수 있습니다. 그러나 HTTP를 사용하면 IP 프록시 끝점 사이의 경로에서 터널링된 IP 패킷을 차별화하여 처리할 수 있는 가능성이 제한될 수 있습니다.\(MAY\)

HTTP 연결이 정체 제어되는 경우 서로 다른 DSCP로 패킷을 표시하면 패킷 간의 순서가 변경될 수 있으며 결과적으로 기본 전송 연결의 정체 컨트롤러 성능이 저하될 수 있습니다. 터널링된 패킷이 외부 연결에 의해 정체 제어를 받는 경우 이러한 상황을 방지하려면 전달 동작과 동일하지 않은 DSCP 표시를 전달하지 않아야 합니다. 이 시나리오에서 IP 프록시 끝점은 내부 IP 헤더의 DSCP 필드를 이 패킷을 전달하는 패킷의 외부 IP 헤더로 복사해서는 안 됩니다. 대신 애플리케이션은 각 DSCP에 대해 하나씩 프록시에 대한 별도의 연결을 사용해야 합니다. 이 문서에서는 요청 범위를 특정 DSCP 값으로 지정하는 방법을 정의하지 않습니다. 이러한 지원은 향후 확장에 맡겨집니다.\(MUST NOT\)

터널링된 패킷이 QUIC 데이터그램을 사용하고 외부 연결에 의한 정체 제어를 받지 않는 경우 IP 프록시 끝점은 터널링된 트래픽의 DSCP 필드 값을 외부 IP 헤더로 변환할 수 있습니다. IP 프록시 끝점은 동일한 DSCP 표시 또는 동등한 트래픽 클래스가 없는 한 여러 내부 패킷을 동일한 외부 패킷으로 통합해서는 안 됩니다. DSCP 값을 변환하는 기능은 동일한 차별화 서비스 도메인에 속하는 터널 수신 및 송신에 따라 달라집니다.\(MAY, MUST NOT\)

---
## **11.  Security Considerations**

터널 범위가 특정 호스트로 지정되었는지 여부에 관계없이 임의의 클라이언트가 임의의 호스트로의 전송을 허용하는 터널을 설정하도록 허용하면 상당한 위험이 있습니다. 악의적인 행위자는 이 기능을 악용하여 트래픽을 전송하고 해당 트래픽이 IP 프록시에 귀속되도록 할 수 있습니다. IP 프록시를 지원하는 HTTP 서버는 인증된 사용자에게만 사용을 제한해야 합니다. 배포에 따라 가능한 인증 메커니즘에는 IP 프록시 끝점 간의 상호 TLS, HTTP 인증 헤더\[HTTP\]를 통한 HTTP 기반 인증 또는 심지어 전달자 토큰이 포함됩니다. 프록시는 인증된 사용자에 대한 정책을 시행하여 클라이언트 동작을 더욱 제한하거나 남용 가능성을 처리할 수 있습니다. 예를 들어, 프록시는 프록시를 통해 지나치게 많은 양의 트래픽을 전송하는 개별 클라이언트의 속도를 제한할 수 있습니다. 또 다른 예로, 프록시는 지리적 위치와 같은 특정 클라이언트 속성을 기반으로 클라이언트에 대한 주소\(접두사\) 할당을 제한할 수 있습니다.\(SHOULD\)

주소 할당은 엔드포인트에 개인정보 보호에 영향을 미칠 수 있습니다. 예를 들어 프록시가 인증된 클라이언트 수에 따라 주소 공간을 분할한 다음 각 클라이언트에 고유한 주소 범위를 할당하는 경우 대상 호스트는 이 정보를 사용하여 IP 패킷이 동일한 클라이언트에 해당하는 시기를 결정할 수 있습니다. 특정 프록시 배포에서는 이러한 추적 벡터를 피하는 것이 중요할 수 있습니다. 프록시는 가능한 경우 지속적인 클라이언트별 주소\(접두사\) 할당을 피해야 합니다\(SHOULD\).\(SHOULD\)

서비스 거부 공격의 경우 전송된 트래픽에서 IP 소스 주소를 위조하는 것이 일반적이었습니다. 이 메커니즘을 구현하면 그러한 공격이 용이해지지 않도록 해야 합니다. 특히 엔드포인트가 해당 피어가 지정된 접두사에서만 IP 패킷을 보낼 수 있다는 것을 알고 있는 시나리오가 있습니다. 예를 들어, 이는 대역 외 구성 정보를 통해 또는 허용된 접두사가 ADDRESS\_ASSIGN 캡슐을 통해 공유되는 경우 발생할 수 있습니다. 이러한 시나리오에서 엔드포인트는 소스 주소 스푸핑을 방지하기 위해 \[BCP38\]의 권장 사항을 따라야 합니다.\(MUST\)

요청 범위를 제한하면\(섹션 4.6 참조\) 요청 범위가 서로 다른 인터넷 프로토콜 번호로 지정되는 경우 두 클라이언트가 프록시의 외부 IP 주소 중 하나를 공유할 수 있습니다. 프록시가 해당 외부 IP 주소로 향하는 ICMP 패킷을 수신하면 이를 클라이언트에 다시 전달할 수 있는 옵션이 있습니다. 그러나 이러한 ICMP 패킷 중 일부는 ICMP 응답을 트리거한 원래 IP 패킷의 일부를 전달합니다. 이러한 패킷을 전달하면 실수로 한 클라이언트의 트래픽에 대한 정보가 다른 클라이언트로 유출될 수 있습니다. 이를 방지하려면 공유 외부 IP 주소에서 ICMP를 전달하는 프록시는 ICMP 패킷에 포함된 호출 패킷을 검사하고 범위가 호출 패킷과 일치하는 클라이언트에게만 ICMP 패킷을 전달해야 합니다.\(MUST\)

구현자는 \[TUNNEL-SECURITY\]의 지침을 읽으면 도움이 됩니다. 일부 IPv6 확장 헤더\(예: \[ROUTING-HDR\]\)에는 알려진 위험이 있으므로 구현자는 IPv6 확장 헤더 처리에 관한 최신 지침을 따라야 합니다.

내부 패킷에서 외부 패킷으로 DSCP 표시를 전송하면\(섹션 10.3 참조\) IP 프록시 끝점 사이의 경로 관찰자에게 종단 간 흐름 수준 정보가 노출됩니다. 이는 잠재적으로 단일 엔드투엔드 흐름을 노출할 수 있습니다. 따라서 개인 정보가 민감한 상황에서 DSCP를 사용하는 것은 권장되지 않습니다.\(SHOULD NOT\)

IP 패킷의 기회주의적 전송\(섹션 7.1 참조\)은 HTTP/1.x에서 허용되지 않습니다. 서버가 HTTP 업그레이드를 거부하고 IP 패킷을 후속 HTTP 요청으로 구문 분석하여 요청 밀수 공격을 허용할 수 있기 때문입니다. \[낙관적\]을 참조하세요. 특히 HTTP/2 또는 3에서 HTTP/1.1로 요청을 다시 인코딩하는 중개자는 성공적인 IP 프록시 응답을 구문 분석할 때까지 수신된 캡슐을 전달해서는 안 됩니다.\(MUST NOT\)

---
## **12.  IANA Considerations**
---
### **12.1.  HTTP Upgrade Token Registration**

```text
   IANA has registered "connect-ip" in the "HTTP Upgrade Tokens"
   registry maintained at <https://www.iana.org/assignments/http-
   upgrade-tokens>.
```

값: connect-ip 설명: IP 페이로드 프록시 예상 버전 토큰: 없음 참조: RFC 9484

---
### **12.2.  MASQUE URI Suffixes Registry Creation**

IANA는 <https://www.iana.org/locationments/masque\>에서 유지 관리되는 "MASQUE URI Suffixes" 레지스트리를 만들었습니다. 등록 정책은 전문가 검토입니다. \[IANA 정책\]의 섹션 4.5를 참조하세요. 이 새로운 레지스트리는 "/.well-known/masque/"로 시작하는 경로에서 "masque" 바로 뒤에 오는 경로 세그먼트를 관리합니다. "Well-Known URI" 레지스트리에 "masque"를 등록하려면 <https://www.iana.org/locationments/well-known-uris\>를 참조하세요.

이 새 레지스트리에는 세 개의 열이 포함되어 있습니다.

경로 세그먼트: 토큰에 허용되는 문자만 포함하는 ASCII 문자열입니다. \[HTTP\]의 섹션 5.6.2를 참조하세요. 이 레지스트리의 항목은 모두 이 열에 고유한 항목을 가지고 있어야 합니다. 설명: 항목에 대한 설명입니다. 참조: 항목의 사용을 정의하는 선택적 참조입니다.\(MUST\)

레지스트리의 초기 항목은 다음과 같습니다.

```text
                +==============+==============+===========+
                | Path Segment | Description  | Reference |
                +==============+==============+===========+
                | udp          | UDP Proxying | RFC 9298  |
                +--------------+--------------+-----------+
                | ip           | IP Proxying  | RFC 9484  |
                +--------------+--------------+-----------+

                   Table 1: MASQUE URI Suffixes Registry
```

이 레지스트리에 대해 지정된 전문가는 전문가가 \(1\) 요청된 경로 세그먼트가 기존 또는 예상되는 향후 IETF 작업과 충돌하지 않고 \(2\) 사용 사례가 프록시와 관련이 있다고 믿는 한 모든 요청을 승인해야 한다는 점을 권고받습니다.

---
### **12.3.  Updates to masque Well-Known URI Registration**

```text
   IANA has updated the entry for the "masque" URI suffix in the "Well-
   Known URIs" registry maintained at <https://www.iana.org/assignments/
   well-known-uris>.
```

IANA는 이 문서를 포함하도록 "참조" 필드를 업데이트했으며 "관련 정보" 필드를 "하위 접미사 할당에 대해서는 <https://www.iana.org/locationments/masque\>에서 레지스트리를 참조하십시오."로 대체했습니다. .

---
### **12.4.  HTTP Capsule Types Registrations**

```text
   IANA has added the following values to the "HTTP Capsule Types"
   registry maintained at <https://www.iana.org/assignments/masque>.

                      +=======+=====================+
                      | Value | Capsule Type        |
                      +=======+=====================+
                      | 0x01  | ADDRESS_ASSIGN      |
                      +-------+---------------------+
                      | 0x02  | ADDRESS_REQUEST     |
                      +-------+---------------------+
                      | 0x03  | ROUTE_ADVERTISEMENT |
                      +-------+---------------------+

                           Table 2: New Capsules
```

이러한 모든 새 항목은 해당 필드에 대해 다음 값을 사용합니다.

```text
   Status:  permanent
   Reference:  RFC 9484
   Change Controller:  IETF
   Contact:  masque@ietf.org
   Notes:  None
```

---
## **13.  References**
---
### **13.1.  Normative References**

```text
   [ABNF]     Crocker, D., Ed. and P. Overell, "Augmented BNF for Syntax
              Specifications: ABNF", STD 68, RFC 5234,
              DOI 10.17487/RFC5234, January 2008,
              <https://www.rfc-editor.org/info/rfc5234>.

   [BCP38]    Ferguson, P. and D. Senie, "Network Ingress Filtering:
              Defeating Denial of Service Attacks which employ IP Source
              Address Spoofing", BCP 38, RFC 2827, DOI 10.17487/RFC2827,
              May 2000, <https://www.rfc-editor.org/info/rfc2827>.

   [DGRAM]    Pauly, T., Kinnear, E., and D. Schinazi, "An Unreliable
              Datagram Extension to QUIC", RFC 9221,
              DOI 10.17487/RFC9221, March 2022,
              <https://www.rfc-editor.org/info/rfc9221>.

   [DSCP]     Nichols, K., Blake, S., Baker, F., and D. Black,
              "Definition of the Differentiated Services Field (DS
              Field) in the IPv4 and IPv6 Headers", RFC 2474,
              DOI 10.17487/RFC2474, December 1998,
              <https://www.rfc-editor.org/info/rfc2474>.

   [ECN]      Ramakrishnan, K., Floyd, S., and D. Black, "The Addition
              of Explicit Congestion Notification (ECN) to IP",
              RFC 3168, DOI 10.17487/RFC3168, September 2001,
              <https://www.rfc-editor.org/info/rfc3168>.

   [EXT-CONNECT2]
              McManus, P., "Bootstrapping WebSockets with HTTP/2",
              RFC 8441, DOI 10.17487/RFC8441, September 2018,
              <https://www.rfc-editor.org/info/rfc8441>.

   [EXT-CONNECT3]
              Hamilton, R., "Bootstrapping WebSockets with HTTP/3",
              RFC 9220, DOI 10.17487/RFC9220, June 2022,
              <https://www.rfc-editor.org/info/rfc9220>.

   [HTTP]     Fielding, R., Ed., Nottingham, M., Ed., and J. Reschke,
              Ed., "HTTP Semantics", STD 97, RFC 9110,
              DOI 10.17487/RFC9110, June 2022,
              <https://www.rfc-editor.org/info/rfc9110>.

   [HTTP-DGRAM]
              Schinazi, D. and L. Pardue, "HTTP Datagrams and the
              Capsule Protocol", RFC 9297, DOI 10.17487/RFC9297, August
              2022, <https://www.rfc-editor.org/info/rfc9297>.

   [HTTP/1.1] Fielding, R., Ed., Nottingham, M., Ed., and J. Reschke,
              Ed., "HTTP/1.1", STD 99, RFC 9112, DOI 10.17487/RFC9112,
              June 2022, <https://www.rfc-editor.org/info/rfc9112>.

   [HTTP/2]   Thomson, M., Ed. and C. Benfield, Ed., "HTTP/2", RFC 9113,
              DOI 10.17487/RFC9113, June 2022,
              <https://www.rfc-editor.org/info/rfc9113>.

   [HTTP/3]   Bishop, M., Ed., "HTTP/3", RFC 9114, DOI 10.17487/RFC9114,
              June 2022, <https://www.rfc-editor.org/info/rfc9114>.

   [IANA-POLICY]
              Cotton, M., Leiba, B., and T. Narten, "Guidelines for
              Writing an IANA Considerations Section in RFCs", BCP 26,
              RFC 8126, DOI 10.17487/RFC8126, June 2017,
              <https://www.rfc-editor.org/info/rfc8126>.

   [ICMP]     Postel, J., "Internet Control Message Protocol", STD 5,
              RFC 792, DOI 10.17487/RFC0792, September 1981,
              <https://www.rfc-editor.org/info/rfc792>.

   [ICMPv6]   Conta, A., Deering, S., and M. Gupta, Ed., "Internet
              Control Message Protocol (ICMPv6) for the Internet
              Protocol Version 6 (IPv6) Specification", STD 89,
              RFC 4443, DOI 10.17487/RFC4443, March 2006,
              <https://www.rfc-editor.org/info/rfc4443>.

   [IPv6]     Deering, S. and R. Hinden, "Internet Protocol, Version 6
              (IPv6) Specification", STD 86, RFC 8200,
              DOI 10.17487/RFC8200, July 2017,
              <https://www.rfc-editor.org/info/rfc8200>.

   [IPv6-ZONE-ID]
              Carpenter, B., Cheshire, S., and R. Hinden, "Representing
              IPv6 Zone Identifiers in Address Literals and Uniform
              Resource Identifiers", RFC 6874, DOI 10.17487/RFC6874,
              February 2013, <https://www.rfc-editor.org/info/rfc6874>.

   [PROXY-STATUS]
              Nottingham, M. and P. Sikora, "The Proxy-Status HTTP
              Response Header Field", RFC 9209, DOI 10.17487/RFC9209,
              June 2022, <https://www.rfc-editor.org/info/rfc9209>.

   [QUIC]     Iyengar, J., Ed. and M. Thomson, Ed., "QUIC: A UDP-Based
              Multiplexed and Secure Transport", RFC 9000,
              DOI 10.17487/RFC9000, May 2021,
              <https://www.rfc-editor.org/info/rfc9000>.

   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", BCP 14, RFC 2119,
              DOI 10.17487/RFC2119, March 1997,
              <https://www.rfc-editor.org/info/rfc2119>.

   [RFC8174]  Leiba, B., "Ambiguity of Uppercase vs Lowercase in RFC
              2119 Key Words", BCP 14, RFC 8174, DOI 10.17487/RFC8174,
              May 2017, <https://www.rfc-editor.org/info/rfc8174>.

   [TCP]      Eddy, W., Ed., "Transmission Control Protocol (TCP)",
              STD 7, RFC 9293, DOI 10.17487/RFC9293, August 2022,
              <https://www.rfc-editor.org/info/rfc9293>.

   [TEMPLATE] Gregorio, J., Fielding, R., Hadley, M., Nottingham, M.,
              and D. Orchard, "URI Template", RFC 6570,
              DOI 10.17487/RFC6570, March 2012,
              <https://www.rfc-editor.org/info/rfc6570>.

   [URI]      Berners-Lee, T., Fielding, R., and L. Masinter, "Uniform
              Resource Identifier (URI): Generic Syntax", STD 66,
              RFC 3986, DOI 10.17487/RFC3986, January 2005,
              <https://www.rfc-editor.org/info/rfc3986>.
```

---
### **13.2.  Informative References**

```text
   [CONNECT-UDP]
              Schinazi, D., "Proxying UDP in HTTP", RFC 9298,
              DOI 10.17487/RFC9298, August 2022,
              <https://www.rfc-editor.org/info/rfc9298>.

   [DPLPMTUD] Fairhurst, G., Jones, T., Tüxen, M., Rüngeler, I., and T.
              Völker, "Packetization Layer Path MTU Discovery for
              Datagram Transports", RFC 8899, DOI 10.17487/RFC8899,
              September 2020, <https://www.rfc-editor.org/info/rfc8899>.

   [ECN-TUNNEL]
              Briscoe, B., "Tunnelling of Explicit Congestion
              Notification", RFC 6040, DOI 10.17487/RFC6040, November
              2010, <https://www.rfc-editor.org/info/rfc6040>.

   [HEv2]     Schinazi, D. and T. Pauly, "Happy Eyeballs Version 2:
              Better Connectivity Using Concurrency", RFC 8305,
              DOI 10.17487/RFC8305, December 2017,
              <https://www.rfc-editor.org/info/rfc8305>.

   [IANA-PN]  IANA, "Protocol Numbers",
              <https://www.iana.org/assignments/protocol-numbers>.

   [IPSEC]    Kent, S. and K. Seo, "Security Architecture for the
              Internet Protocol", RFC 4301, DOI 10.17487/RFC4301,
              December 2005, <https://www.rfc-editor.org/info/rfc4301>.

   [IPv6-ADDR]
              Hinden, R. and S. Deering, "IP Version 6 Addressing
              Architecture", RFC 4291, DOI 10.17487/RFC4291, February
              2006, <https://www.rfc-editor.org/info/rfc4291>.

   [OPTIMISTIC]
              Schwartz, B. M., "Security Considerations for Optimistic
              Use of HTTP Upgrade", Work in Progress, Internet-Draft,
              draft-schwartz-httpbis-optimistic-upgrade-00, 21 August
              2023, <https://datatracker.ietf.org/doc/html/draft-
              schwartz-httpbis-optimistic-upgrade-00>.

   [PROXY-REQS]
              Chernyakhovsky, A., McCall, D., and D. Schinazi,
              "Requirements for a MASQUE Protocol to Proxy IP Traffic",
              Work in Progress, Internet-Draft, draft-ietf-masque-ip-
              proxy-reqs-03, 27 August 2021,
              <https://datatracker.ietf.org/doc/html/draft-ietf-masque-
              ip-proxy-reqs-03>.

   [ROUTING-HDR]
              Abley, J., Savola, P., and G. Neville-Neil, "Deprecation
              of Type 0 Routing Headers in IPv6", RFC 5095,
              DOI 10.17487/RFC5095, December 2007,
              <https://www.rfc-editor.org/info/rfc5095>.

   [TUNNEL-SECURITY]
              Krishnan, S., Thaler, D., and J. Hoagland, "Security
              Concerns with IP Tunneling", RFC 6169,
              DOI 10.17487/RFC6169, April 2011,
              <https://www.rfc-editor.org/info/rfc6169>.

   [UDP-USAGE]
              Eggert, L., Fairhurst, G., and G. Shepherd, "UDP Usage
              Guidelines", BCP 145, RFC 8085, DOI 10.17487/RFC8085,
              March 2017, <https://www.rfc-editor.org/info/rfc8085>.
```

---
# **Acknowledgments**

이 방법의 설계는 \[PROXY-REQS\]에 관한 MASQUE 실무 그룹의 토론에서 영감을 받았습니다. 저자는 피드백을 주신 토론 참가자들에게 감사를 표하고 싶습니다. 또한 Mike Bishop, Lucas Pardue 및 Alejandro Sedeño가 문서에 대한 귀중한 피드백을 제공했습니다.

클라이언트 구성의 텍스트 대부분은 \[CONNECT-UDP\]의 해당 텍스트를 기반으로 합니다.

---
# **Authors' Addresses**

```text
   Tommy Pauly (editor)
   Apple Inc.
   Email: tpauly@apple.com
```

David Schinazi Google LLC 1600 Amphitheatre Parkway Mountain View, CA 94043 United States of America 이메일: dschinazi.ietf@gmail.com

```text
   Alex Chernyakhovsky
   Google LLC
   Email: achernya@google.com

   Mirja Kühlewind
   Ericsson
   Email: mirja.kuehlewind@ericsson.com

   Magnus Westerlund
   Ericsson
   Email: magnus.westerlund@ericsson.com
```
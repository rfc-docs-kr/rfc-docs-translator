

```text
Internet Engineering Task Force (IETF)                    H. Schulzrinne
Request for Comments: 7826                           Columbia University
Obsoletes: 2326                                                   A. Rao
Category: Standards Track                                          Cisco
ISSN: 2070-1721                                              R. Lanphier

                                                           M. Westerlund
                                                                Ericsson
                                                     M. Stiemerling, Ed.
                                University of Applied Sciences Darmstadt
                                                           December 2016

                Real-Time Streaming Protocol Version 2.0
```

---
# **Abstract**

이 각서는 RFC 2326에 정의된 RTSP 버전 1.0을 폐기하는 RTSP\(Real-Time Streaming Protocol\) 버전 2.0을 정의합니다.

RTSP는 실시간 속성을 사용하여 데이터 전달을 설정하고 제어하기 위한 애플리케이션 계층 프로토콜입니다. RTSP는 오디오 및 비디오와 같은 실시간 데이터의 제어된 온디맨드 전달을 가능하게 하는 확장 가능한 프레임워크를 제공합니다. 데이터 소스에는 실시간 데이터 피드와 저장된 클립이 모두 포함될 수 있습니다. 이 프로토콜은 여러 데이터 전달 세션을 제어하기 위한 것입니다. UDP, 멀티캐스트 UDP 및 TCP와 같은 전달 채널을 선택하기 위한 수단을 제공합니다. RTP\(RFC 3550\)를 기반으로 전달 메커니즘을 선택하는 수단을 제공합니다.

---
# **Status of This Memo**

이것은 인터넷 표준 추적 문서입니다.

이 문서는 IETF\(Internet Engineering Task Force\)의 제품입니다. 이는 IETF 커뮤니티의 합의를 나타냅니다. 공개 검토를 받았으며 IESG\(Internet Engineering Steering Group\)의 출판 승인을 받았습니다. 인터넷 표준에 대한 자세한 내용은 RFC 7841의 섹션 2에서 확인할 수 있습니다.

이 문서의 현재 상태, 정오표, 피드백 제공 방법에 대한 정보는 http://www.rfc-editor.org/info/rfc7826에서 얻을 수 있습니다.

---
# **Copyright Notice**

Copyright \(c\) 2016 IETF Trust 및 문서 작성자로 확인된 사람. 판권 소유.

이 문서는 이 문서의 발행일에 유효한 BCP 78 및 IETF 문서에 관한 IETF 트러스트의 법적 조항\(http://trustee.ietf.org/license-info\)의 적용을 받습니다. 이 문서와 관련된 귀하의 권리 및 제한 사항을 설명하므로 이 문서를 주의 깊게 검토하십시오. 이 문서에서 추출한 코드 구성 요소는 Trust Legal Provisions의 섹션 4.e에 설명된 대로 Simplified BSD License 텍스트를 포함해야 하며 Simplified BSD License에 설명된 대로 보증 없이 제공됩니다.

이 문서에는 2008년 11월 10일 이전에 공개되거나 공개된 IETF 문서 또는 IETF 기고문의 자료가 포함될 수 있습니다. 이 자료의 일부에 대한 저작권을 제어하는 ​​사람은 해당 자료의 수정을 허용할 권리를 IETF 트러스트에 부여하지 않았을 수 있습니다. IETF 표준 프로세스 외부. 이러한 자료의 저작권을 관리하는 사람으로부터 적절한 라이센스를 얻지 않고 이 문서는 IETF 표준 프로세스 외부에서 수정할 수 없으며 IETF 표준 프로세스 외부에서 이 문서의 파생물을 생성할 수 없습니다. RFC로 게시하거나 영어 이외의 언어로 번역합니다.

---
# **Table of Contents**

```text
   1. Introduction ...................................................10
   2. Protocol Overview ..............................................11
      2.1. Presentation Description ..................................12
      2.2. Session Establishment .....................................12
      2.3. Media Delivery Control ....................................14
      2.4. Session Parameter Manipulations ...........................15
      2.5. Media Delivery ............................................16
           2.5.1. Media Delivery Manipulations .......................16
      2.6. Session Maintenance and Termination .......................19
      2.7. Extending RTSP ............................................20
   3. Document Conventions ...........................................21
      3.1. Notational Conventions ....................................21
      3.2. Terminology ...............................................21
   4. Protocol Parameters ............................................25
      4.1. RTSP Version ..............................................25
      4.2. RTSP IRI and URI ..........................................25
      4.3. Session Identifiers .......................................28
      4.4. Media-Time Formats ........................................28
           4.4.1. SMPTE-Relative Timestamps ..........................28
           4.4.2. Normal Play Time ...................................29
           4.4.3. Absolute Time ......................................30
      4.5. Feature Tags ..............................................31
      4.6. Message Body Tags .........................................32
      4.7. Media Properties ..........................................32
           4.7.1. Random Access and Seeking ..........................33
           4.7.2. Retention ..........................................34
           4.7.3. Content Modifications ..............................34
           4.7.4. Supported Scale Factors ............................34
           4.7.5. Mapping to the Attributes ..........................35
   5. RTSP Message ...................................................35
      5.1. Message Types .............................................36
      5.2. Message Headers ...........................................36
      5.3. Message Body ..............................................37
      5.4. Message Length ............................................37
   6. General-Header Fields ..........................................37
   7. Request ........................................................39
      7.1. Request Line ..............................................40
      7.2. Request-Header Fields .....................................42
   8. Response .......................................................43
      8.1. Status-Line ...............................................43
           8.1.1. Status Code and Reason Phrase ......................43
      8.2. Response Headers ..........................................47
   9. Message Body ...................................................47
      9.1. Message Body Header Fields ................................48
      9.2. Message Body ..............................................49
      9.3. Message Body Format Negotiation ...........................49
   10. Connections ...................................................50
      10.1. Reliability and Acknowledgements .........................50
      10.2. Using Connections ........................................51
      10.3. Closing Connections ......................................54
      10.4. Timing Out Connections and RTSP Messages .................56
      10.5. Showing Liveness .........................................57
      10.6. Use of IPv6 ..............................................58
      10.7. Overload Control .........................................58
   11. Capability Handling ...........................................60
      11.1. Feature Tag: play.basic ..................................62
   12. Pipelining Support ............................................62
   13. Method Definitions ............................................63
      13.1. OPTIONS ..................................................65
      13.2. DESCRIBE .................................................66
      13.3. SETUP ....................................................68
           13.3.1. Changing Transport Parameters .....................71
      13.4. PLAY .....................................................72
           13.4.1. General Usage .....................................72
           13.4.2. Aggregated Sessions ...............................77
           13.4.3. Updating Current PLAY Requests ....................78
           13.4.4. Playing On-Demand Media ...........................81
           13.4.5. Playing Dynamic On-Demand Media ...................81
           13.4.6. Playing Live Media ................................81
           13.4.7. Playing Live with Recording .......................82
           13.4.8. Playing Live with Time-Shift ......................83
      13.5. PLAY_NOTIFY ..............................................83
           13.5.1. End-of-Stream .....................................84
           13.5.2. Media-Properties-Update ...........................86
           13.5.3. Scale-Change ......................................87
      13.6. PAUSE ....................................................89
      13.7. TEARDOWN .................................................92
           13.7.1. Client to Server ..................................92
           13.7.2. Server to Client ..................................93
      13.8. GET_PARAMETER ............................................94
      13.9. SET_PARAMETER ............................................96
      13.10. REDIRECT ................................................98
   14. Embedded (Interleaved) Binary Data ...........................101
   15. Proxies ......................................................103
      15.1. Proxies and Protocol Extensions .........................104
      15.2. Multiplexing and Demultiplexing of Messages .............105
   16. Caching ......................................................106
      16.1. Validation Model ........................................107
           16.1.1. Last-Modified Dates ..............................108
           16.1.2. Message Body Tag Cache Validators ................108
           16.1.3. Weak and Strong Validators .......................108
           16.1.4. Rules for When to Use Message Body Tags
                   and Last-Modified Dates ..........................110
           16.1.5. Non-validating Conditionals ......................112
      16.2. Invalidation after Updates or Deletions .................112
   17. Status Code Definitions ......................................113
      17.1. Informational 1xx .......................................113
           17.1.1. 100 Continue .....................................113
      17.2. Success 2xx .............................................113
           17.2.1. 200 OK ...........................................113
      17.3. Redirection 3xx .........................................113
           17.3.1. 300 ..............................................114
           17.3.2. 301 Moved Permanently ............................114
           17.3.3. 302 Found ........................................114
           17.3.4. 303 See Other ....................................115
           17.3.5. 304 Not Modified .................................115
           17.3.6. 305 Use Proxy ....................................115
      17.4. Client Error 4xx ........................................116
           17.4.1. 400 Bad Request ..................................116
           17.4.2. 401 Unauthorized .................................116
           17.4.3. 402 Payment Required .............................116
           17.4.4. 403 Forbidden ....................................116
           17.4.5. 404 Not Found ....................................116
           17.4.6. 405 Method Not Allowed ...........................117
           17.4.7. 406 Not Acceptable ...............................117
           17.4.8. 407 Proxy Authentication Required ................117
           17.4.9. 408 Request Timeout ..............................117
           17.4.10. 410 Gone ........................................118
           17.4.11. 412 Precondition Failed .........................118
           17.4.12. 413 Request Message Body Too Large ..............118
           17.4.13. 414 Request-URI Too Long ........................118
           17.4.14. 415 Unsupported Media Type ......................119
           17.4.15. 451 Parameter Not Understood ....................119
           17.4.16. 452 Illegal Conference Identifier ...............119
           17.4.17. 453 Not Enough Bandwidth ........................119
           17.4.18. 454 Session Not Found ...........................119
           17.4.19. 455 Method Not Valid in This State ..............119
           17.4.20. 456 Header Field Not Valid for Resource .........119
           17.4.21. 457 Invalid Range ...............................120
           17.4.22. 458 Parameter Is Read-Only ......................120
           17.4.23. 459 Aggregate Operation Not Allowed .............120
           17.4.24. 460 Only Aggregate Operation Allowed ............120
           17.4.25. 461 Unsupported Transport .......................120
           17.4.26. 462 Destination Unreachable .....................120
           17.4.27. 463 Destination Prohibited ......................120
           17.4.28. 464 Data Transport Not Ready Yet ................121
           17.4.29. 465 Notification Reason Unknown .................121
           17.4.30. 466 Key Management Error ........................121
           17.4.31. 470 Connection Authorization Required ...........121
           17.4.32. 471 Connection Credentials Not Accepted .........121
           17.4.33. 472 Failure to Establish Secure Connection ......121
      17.5. Server Error 5xx ........................................122
           17.5.1. 500 Internal Server Error ........................122
           17.5.2. 501 Not Implemented ..............................122
           17.5.3. 502 Bad Gateway ..................................122
           17.5.4. 503 Service Unavailable ..........................122
           17.5.5. 504 Gateway Timeout ..............................123
           17.5.6. 505 RTSP Version Not Supported ...................123
           17.5.7. 551 Option Not Supported .........................123
           17.5.8. 553 Proxy Unavailable ............................123
   18. Header Field Definitions .....................................124
      18.1. Accept ..................................................134
      18.2. Accept-Credentials ......................................135
      18.3. Accept-Encoding .........................................135
      18.4. Accept-Language .........................................136
      18.5. Accept-Ranges ...........................................137
      18.6. Allow ...................................................138
      18.7. Authentication-Info .....................................138
      18.8. Authorization ...........................................138
      18.9. Bandwidth ...............................................139
      18.10. Blocksize ..............................................140
      18.11. Cache-Control ..........................................140
      18.12. Connection .............................................143
      18.13. Connection-Credentials .................................143
      18.14. Content-Base ...........................................144
      18.15. Content-Encoding .......................................145
      18.16. Content-Language .......................................145
      18.17. Content-Length .........................................146
      18.18. Content-Location .......................................146
      18.19. Content-Type ...........................................148
      18.20. CSeq ...................................................148
      18.21. Date ...................................................150
      18.22. Expires ................................................151
      18.23. From ...................................................151
      18.24. If-Match ...............................................152
      18.25. If-Modified-Since ......................................152
      18.26. If-None-Match ..........................................153
      18.27. Last-Modified ..........................................154
      18.28. Location ...............................................154
      18.29. Media-Properties .......................................154
      18.30. Media-Range ............................................156
      18.31. MTag ...................................................157
      18.32. Notify-Reason ..........................................158
      18.33. Pipelined-Requests .....................................158
      18.34. Proxy-Authenticate .....................................159
      18.35. Proxy-Authentication-Info ..............................159
      18.36. Proxy-Authorization ....................................159
      18.37. Proxy-Require ..........................................160
      18.38. Proxy-Supported ........................................160
      18.39. Public .................................................161
      18.40. Range ..................................................162
      18.41. Referrer ...............................................164
      18.42. Request-Status .........................................164
      18.43. Require ................................................165
      18.44. Retry-After ............................................166
      18.45. RTP-Info ...............................................167
      18.46. Scale ..................................................169
      18.47. Seek-Style .............................................170
      18.48. Server .................................................171
      18.49. Session ................................................172
      18.50. Speed ..................................................173
      18.51. Supported ..............................................174
      18.52. Terminate-Reason .......................................175
      18.53. Timestamp ..............................................175
      18.54. Transport ..............................................176
      18.55. Unsupported ............................................183
      18.56. User-Agent .............................................184
      18.57. Via ....................................................184
      18.58. WWW-Authenticate .......................................185
   19. Security Framework ...........................................185
      19.1. RTSP and HTTP Authentication ............................185
           19.1.1. Digest Authentication ............................186
      19.2. RTSP over TLS ...........................................187
      19.3. Security and Proxies ....................................188
           19.3.1. Accept-Credentials ...............................189
           19.3.2. User-Approved TLS Procedure ......................190
   20. Syntax .......................................................192
      20.1. Base Syntax .............................................193
      20.2. RTSP Protocol Definition ................................195
           20.2.1. Generic Protocol Elements ........................195
           20.2.2. Message Syntax ...................................198
           20.2.3. Header Syntax ....................................201
      20.3. SDP Extension Syntax ....................................209
   21. Security Considerations ......................................209
      21.1. Signaling Protocol Threats ..............................210
      21.2. Media Stream Delivery Threats ...........................213
           21.2.1. Remote DoS Attack ................................215
           21.2.2. RTP Security Analysis ............................216
   22. IANA Considerations ..........................................217
      22.1. Feature Tags ............................................218
           22.1.1. Description ......................................218
           22.1.2. Registering New Feature Tags with IANA ...........218
           22.1.3. Registered Entries ...............................219
      22.2. RTSP Methods ............................................219
           22.2.1. Description ......................................219
           22.2.2. Registering New Methods with IANA ................219
           22.2.3. Registered Entries ...............................220
      22.3. RTSP Status Codes .......................................220
           22.3.1. Description ......................................220
           22.3.2. Registering New Status Codes with IANA ...........220
           22.3.3. Registered Entries ...............................221
      22.4. RTSP Headers ............................................221
           22.4.1. Description ......................................221
           22.4.2. Registering New Headers with IANA ................221
           22.4.3. Registered Entries ...............................222
      22.5. Accept-Credentials ......................................223
           22.5.1. Accept-Credentials Policies ......................223
           22.5.2. Accept-Credentials Hash Algorithms ...............224
      22.6. Cache-Control Cache Directive Extensions ................224
      22.7. Media Properties ........................................225
           22.7.1. Description ......................................225
           22.7.2. Registration Rules ...............................226
           22.7.3. Registered Values ................................226
      22.8. Notify-Reason Values ....................................226
           22.8.1. Description ......................................226
           22.8.2. Registration Rules ...............................226
           22.8.3. Registered Values ................................227
      22.9. Range Header Formats ....................................227
           22.9.1. Description ......................................227
           22.9.2. Registration Rules ...............................227
           22.9.3. Registered Values ................................228
      22.10. Terminate-Reason Header ................................228
           22.10.1. Redirect Reasons ................................228
           22.10.2. Terminate-Reason Header Parameters ..............229
      22.11. RTP-Info Header Parameters .............................229
           22.11.1. Description .....................................229
           22.11.2. Registration Rules ..............................229
           22.11.3. Registered Values ...............................230
      22.12. Seek-Style Policies ....................................230
           22.12.1. Description .....................................230
           22.12.2. Registration Rules ..............................230
           22.12.3. Registered Values ...............................230
      22.13. Transport Header Registries ............................231
           22.13.1. Transport Protocol Identifier ...................231
           22.13.2. Transport Modes .................................233
           22.13.3. Transport Parameters ............................233
      22.14. URI Schemes ............................................234
           22.14.1. The "rtsp" URI Scheme ...........................234
           22.14.2. The "rtsps" URI Scheme ..........................235
           22.14.3. The "rtspu" URI Scheme ..........................237
      22.15. SDP Attributes .........................................238
      22.16. Media Type Registration for text/parameters ............238
   23. References ...................................................240
      23.1. Normative References ....................................240
      23.2. Informative References ..................................245
   Appendix A. Examples .............................................248
      A.1. Media on Demand (Unicast) ................................248
      A.2. Media on Demand Using Pipelining .........................251
      A.3. Secured Media Session for On-Demand Content ..............254
      A.4. Media on Demand (Unicast) ................................257
      A.5. Single-Stream Container Files ............................260
      A.6. Live Media Presentation Using Multicast ..................263
      A.7. Capability Negotiation ...................................264
   Appendix B. RTSP Protocol State Machine ..........................265
      B.1. States ...................................................266
      B.2. State Variables ..........................................266
      B.3. Abbreviations ............................................266
      B.4. State Tables .............................................267
   Appendix C. Media-Transport Alternatives .........................272
      C.1. RTP ......................................................272
        C.1.1. AVP ..................................................272
        C.1.2. AVP/UDP ..............................................273
        C.1.3. AVPF/UDP .............................................274
        C.1.4. SAVP/UDP .............................................275
        C.1.5. SAVPF/UDP ............................................277
        C.1.6. RTCP Usage with RTSP .................................278
      C.2. RTP over TCP .............................................279
        C.2.1. Interleaved RTP over TCP .............................280
        C.2.2. RTP over Independent TCP .............................280
      C.3. Handling Media-Clock Time Jumps in the RTP Media Layer ...284
      C.4. Handling RTP Timestamps after PAUSE ......................287
      C.5. RTSP/RTP Integration  ....................................290
      C.6. Scaling with RTP .........................................290
      C.7. Maintaining NPT Synchronization with RTP Timestamps ......290
      C.8. Continuous Audio .........................................290
      C.9. Multiple Sources in an RTP Session .......................290
      C.10. Usage of SSRCs and the RTCP BYE Message during an RTSP
            Session .................................................290
      C.11. Future Additions ........................................291
   Appendix D. Use of SDP for RTSP Session Descriptions .............292
      D.1. Definitions  .............................................292
        D.1.1. Control URI ..........................................292
        D.1.2. Media Streams ........................................294
        D.1.3. Payload Type(s) ......................................294
        D.1.4. Format-Specific Parameters ...........................294
        D.1.5. Directionality of Media Stream .......................295
        D.1.6. Range of Presentation ................................295
        D.1.7. Time of Availability .................................296
        D.1.8. Connection Information ...............................297
        D.1.9. Message Body Tag .....................................297
      D.2. Aggregate Control Not Available ..........................298
      D.3. Aggregate Control Available ..............................298
      D.4. Grouping of Media Lines in SDP ...........................299
      D.5. RTSP External SDP Delivery ...............................300
   Appendix E. RTSP Use Cases .......................................300
      E.1. On-Demand Playback of Stored Content .....................300
      E.2. Unicast Distribution of Live Content .....................302
      E.3. On-Demand Playback Using Multicast .......................303
      E.4. Inviting an RTSP Server into a Conference ................303
      E.5. Live Content Using Multicast .............................304
   Appendix F. Text Format for Parameters ...........................305
   Appendix G. Requirements for Unreliable Transport of RTSP ........305
   Appendix H. Backwards-Compatibility Considerations ...............306
      H.1. Play Request in Play State ...............................307
      H.2. Using Persistent Connections .............................307
   Appendix I. Changes ..............................................307
      I.1. Brief Overview ...........................................308
      I.2. Detailed List of Changes .................................309
   Acknowledgements .................................................316
   Contributors  ....................................................317
   Authors' Addresses ...............................................318
```

---
## **1.  Introduction**

이 메모는 실시간 스트리밍 프로토콜\(RTSP 2.0\) 버전 2.0을 정의합니다. RTSP 2.0은 일반적으로 스트리밍 미디어와 같은 실시간 속성을 사용하여 데이터 전달을 설정하고 제어하기 위한 애플리케이션 계층 프로토콜입니다. 예를 들어 스트리밍 미디어는 주문형 비디오 또는 오디오 라이브 스트리밍입니다. 간단히 말해서 RTSP는 멀티미디어 서버에 대한 "네트워크 원격 제어" 역할을 합니다.

이 프로토콜은 RTSP 2.0 클라이언트와 서버 사이에서 작동하지만 클라이언트와 서버 사이에 배치된 프록시 사용도 지원합니다. 클라이언트는 미디어에 대한 설명을 요청하거나 외부에서 제공되는 미디어 설명을 사용하여 서버에 스트리밍 미디어에 대한 정보를 요청할 수 있습니다. 미디어 전달 프로토콜은 미디어 설명에 설명된 미디어 스트림을 설정하는 데 사용됩니다. 그런 다음 클라이언트는 미디어 재생, 일시 중지 또는 완전히 중지를 요청할 수 있습니다. 요청된 미디어는 서버에서 클라이언트로 시간 동기화된 스트림으로 전달되는 여러 오디오 및 비디오 스트림으로 구성될 수 있습니다.

RTSP 2.0은 RTSP 1.0 \[RFC2326\]을 대체하며 이 문서는 해당 사양을 폐기합니다. 이 프로토콜은 RTSP 1.0을 기반으로 하지만 기본 버전 협상 메커니즘 외에는 이전 버전과 호환되지 않습니다. 두 문서 간의 변경 사항은 부록 I에 나열되어 있습니다. RTSP 2.0이 RTSP 1.0과 역호환되지 않는 데에는 여러 가지 이유가 있습니다. 주요 내용 중 일부는 다음과 같습니다.

```text
   o  Most headers that needed to be extensible did not define the
      allowed syntax, preventing safe deployment of extensions;

   o  the changed behavior of the PLAY method when received in Play
      state;
```

o 확장성 모델과 그 메커니즘의 변경된 동작; 그리고

o 일부 헤더의 구문이 변경되었습니다.

작은 업데이트가 너무 많아서 설명과 일관된 동작을 가능하게 하려면 버전을 변경해야 했습니다. RTSP 1.0을 설치하지 않은 새로운 사용 사례를 위해 RTSP를 구현하는 사람은 RTSP 1.0 불일치를 처리할 필요가 없도록 RTSP 2.0만 구현해야 합니다.

이 문서는 다음과 같이 구성되어 있습니다. 비공식적인 방식으로 프로토콜 작동 및 기능에 대한 개요로 시작됩니다. 그런 다음 사용되는 용어 정의 및 문서 규칙은 다음과 같습니다.

소개되었습니다. 그 뒤에는 실제 RTSP 2.0 핵심 프로토콜 사양이 나옵니다. 부록에서는 핵심 RTSP 사양의 일부는 아니지만 일부 사용을 활성화하는 데 여전히 중요한 일부 기능을 설명하고 정의합니다. 그 중 RTP 사용법은 부록 C에 정의되어 있고, RTSP를 사용한 SDP\(Session Description Protocol\) 사용법은 부록 D에 정의되어 있으며, "텍스트/매개변수" 파일 형식 부록 F는 세 가지 표준 사양 부록입니다. 다른 부록에는 변경 사항, 사용 사례, 다양한 고려 사항 또는 동기를 논의하는 여러 정보 부분이 포함되어 있습니다.

---
## **2.  Protocol Overview**

이 섹션에서는 RTSP 2.0 프로토콜의 다양한 메커니즘에 대한 유익한 개요를 제공하여 독자가 모든 특정 세부 사항을 살펴보기 전에 높은 수준의 이해를 제공합니다. 본 설명 및 이후 섹션과 충돌하는 경우 이후 섹션이 우선 적용됩니다. RTSP에 대해 고려되는 사용 사례에 대한 자세한 내용은 부록 E를 참조하세요.

RTSP 2.0은 먼저 콘텐츠 리소스\(미디어\)를 포함하는 컨텍스트를 설정한 다음 공급자에서 소비자로의 이러한 콘텐츠 리소스 전달을 제어하는 ​​양방향 요청 및 응답 프로토콜입니다. RTSP는 세션 설정, 미디어 전달 제어 및 아래 설명된 확장성 모델의 세 가지 기본 부분으로 구성됩니다. 이 프로토콜은 클라이언트 제어 실시간 미디어 전달을 위한 완전한 솔루션을 제공하기 위해 기존 기능에 대한 몇 가지 가정을 기반으로 합니다.

RTSP는 바이너리 메시지 본문을 포함할 수 있는 텍스트 기반 메시지, 요청 및 응답을 사용합니다. RTSP 요청은 메서드, 프로토콜, 버전 및 작업할 리소스를 식별하는 메서드 줄로 시작됩니다. 리소스는 URI로 식별되며 URI의 호스트 이름 부분은 RTSP 클라이언트가 RTSP 서버의 IPv4 또는 IPv6 주소를 확인하는 데 사용됩니다. 메소드 행 다음에는 여러 RTSP 헤더가 있습니다. 이러한 줄은 두 개의 연속 CRLF\(캐리지 리턴 줄 바꿈\) 문자 쌍으로 끝납니다. 메시지 본문\(있는 경우\)은 두 개의 CRLF 문자 쌍 뒤에 오며, 본문 길이는 메시지 헤더로 설명됩니다. RTSP 응답은 비슷하지만 프로토콜과 버전, 그 뒤에 상태 코드와 이유 문구가 있는 응답 줄로 시작합니다. RTSP 메시지는 클라이언트와 서버 간의 안정적인 전송 프로토콜을 통해 전송됩니다. RTSP 2.0에서는 클라이언트와 서버가 RTSP 메시지에 대한 필수 전송으로 TCP 및 TCP를 통한 TLS를 구현해야 합니다.

---
### **2.1.  Presentation Description**

RTSP는 멀티미디어 프리젠테이션 및 콘텐츠에 대한 액세스를 제공하기 위해 존재하지만 사용되는 미디어 유형이나 실제 미디어 전달 프로토콜에 대해서는 불가지론적입니다. 클라이언트가 완전한 시스템을 구현할 수 있도록 하기 위해 프레젠테이션 및 전달 프로토콜을 설명하기 위한 RTSP 외부 메커니즘이 사용됩니다. RTSP는 이 설명이 완전히 대역 외로 전달되거나 DESCRIBE 메서드\(13.2절\)를 사용하는 클라이언트 요청에 대한 응답으로 데이터 개체로 전달된다고 가정합니다.

프리젠테이션 설명에 일반적으로 포함되어야 하는 매개변수는 다음과 같습니다.

```text
   o  The number of media streams;

   o  the resource identifier for each media stream/resource that is to
      be controlled by RTSP;

   o  the protocol that will be used to deliver each media stream;

   o  the transport protocol parameters that are not negotiated or vary
      with each client;
```

o 클라이언트가 수신 시 미디어를 올바르게 디코딩할 수 있도록 하는 미디어 인코딩 정보; 그리고

o 집합 제어 자원 식별자.

RTSP는 자체 URI 체계\("rtsp" 및 "rtsps"\)를 사용하여 공통 제어 하에 있는 미디어 리소스 및 집계를 참조합니다\(섹션 4.2 참조\).

이 사양은 프레젠테이션 설명을 위해 SDP \[RFC4566\]를 사용하는 방법을 부록 D에 설명합니다.

---
### **2.2.  Session Establishment**

RTSP 클라이언트는 사용 가능한 미디어 스트림, 사용되는 미디어 전달 프로토콜, 미디어 스트림의 리소스 식별자를 결정하기 위해 프레젠테이션 설명을 사용한 후 RTSP 세션 설정을 요청할 수 있습니다. RTSP 세션은 공통 미디어 전달 제어를 받는 하나 이상의 미디어 리소스로 구성된 클라이언트와 서버 간의 공통 컨텍스트입니다.

클라이언트는 SETUP 메서드\(13.3절\)를 사용하여 서버에 요청을 보내 RTSP 세션을 생성합니다. SETUP 요청의 Transport 헤더\(18.54절\)에 클라이언트는 모든 항목도 포함합니다.

미디어 전달 프로토콜이 작동할 수 있도록 하는 데 필요한 전송 매개변수입니다. 여기에는 프리젠테이션 설명에 의해 사전 설정되었지만 모든 미들박스가 미디어 전달 프로토콜을 올바르게 처리하는 데 필요한 매개변수가 포함됩니다. 요청의 전송 헤더에는 서버가 선택할 수 있는 우선순위 목록의 미디어 전달에 대한 여러 대안이 포함될 수 있습니다. 이러한 대안은 일반적으로 프레젠테이션 설명의 정보를 기반으로 합니다.

SETUP 요청을 받으면 서버는 미디어 리소스가 사용 가능한지, 전송 매개변수 사양 중 하나 이상이 허용되는지 여부를 결정합니다. 성공하면 RTSP 세션 컨텍스트가 생성되고 관련 매개변수 및 상태가 저장됩니다. RTSP 세션에 대한 식별자가 생성되고 세션 헤더의 응답에 포함됩니다\(18.49절\). SETUP 응답에는 선택된 대안과 관련 매개변수를 지정하는 전송 헤더가 포함되어 있습니다.

기존 RTSP 세션을 참조하지만 새로운 미디어 리소스를 식별하는 SETUP 요청은 통합 세션에 이미 존재하는 미디어 리소스와 함께 공통 제어 하에 해당 미디어 리소스를 추가하라는 요청입니다. 클라이언트는 이것이 멀티미디어 콘텐츠 컨테이너 내의 RTSP 제어 하에 있는 모든 미디어 리소스에 대해 작동할 것으로 예상할 수 있습니다. 그러나 서버는 다양한 콘텐츠 컨테이너의 리소스 집계를 거부할 가능성이 높습니다. RTSP 세션에 단일 미디어 스트림만 포함되어 있는 경우에도 RTSP 세션은 집계 제어 URI에서 참조될 수 있습니다.

집계된 RTSP 세션의 세션 설정 시 추가 왕복을 방지하기 위해 RTSP 2.0은 파이프라인 요청을 지원합니다. 즉, 클라이언트는 먼저 요청이 완료될 때까지 기다리지 않고 여러 요청을 연속적으로 보낼 수 있습니다. 클라이언트는 Pipelined-Requests 헤더\(18.33절\)에서 클라이언트가 선택한 식별자를 사용하여 마치 세션 식별자가 포함된 것처럼 여러 요청을 함께 바인딩하도록 서버에 지시합니다.

SETUP 응답은 또한 몇 가지 다른 헤더에서 설정된 세션에 대한 추가 정보를 제공합니다. Media-Properties 헤더\(18.29절\)에는 미디어 전달 제어를 수행하고 사용자 인터페이스를 구성할 때 유용한 집계에 적용되는 여러 속성이 포함되어 있습니다. Accept-Ranges 헤더\(섹션 18.5\)는 서버가 이러한 미디어 리소스에 대해 지원하는 범위 형식에 대해 클라이언트에 알립니다. Media-Range 헤더\(18.30절\)는 클라이언트에게 현재 사용 가능한 미디어의 시간 범위를 알려줍니다.

---
### **2.3.  Media Delivery Control**

RTSP 세션을 설정한 후 클라이언트는 미디어 전달 제어를 시작할 수 있습니다. 기본 조작은 PLAY 메소드\(13.4절\)를 사용하는 "재생 시작"과 PAUSE 메소드\(13.6절\)를 사용하는 "재생 일시정지\(일시 정지\)"입니다. PLAY를 사용하면 서버가 미디어를 전달해야 하는 시작 미디어 위치를 선택할 수도 있습니다. 위치 지정은 다양한 시간 형식을 지원하는 Range 헤더\(섹션 18.40\)를 사용하여 수행됩니다. 일반 재생 시간\(NPT\)\(섹션 4.4.2\), Society of Motion Picture and Television Engineers\(SMPTE\) 타임스탬프\(섹션 4.4.1\) , 절대 시간\(섹션 4.4.3\). 또한 Range 헤더를 사용하면 클라이언트가 배달이 종료되어야 하는 위치를 지정할 수 있으므로 특정 간격이 배달될 수 있습니다.

미디어 콘텐츠 내 위치 지정/검색 지원은 콘텐츠의 미디어 속성에 따라 다릅니다. 콘텐츠는 주문형, 라이브, 동시 녹화 라이브 등 다양한 유형으로 존재합니다. 이러한 범주 내에서도 콘텐츠가 생성되고 배포되는 방식에 차이가 있으며, 이는 재생을 위해 콘텐츠에 액세스하는 방법에 영향을 미칩니다. RTSP 세션에 적용 가능한 속성은 Media-Properties 헤더\(섹션 18.29\)를 사용하여 SETUP 응답에서 서버에 의해 제공됩니다. 이는 하나 또는 여러 개의 독립적인 속성을 사용하여 표현됩니다. 첫 번째 속성은 Random-Access로, 위치 지정이 가능한지 여부와 세부 수준을 나타냅니다. 또 다른 측면은 세션 수명 동안 콘텐츠가 변경되는지 여부입니다. 주문형 콘텐츠는 처음부터 완전히 제공되지만 라이브 스트림이 녹화되면 세션이 진행됨에 따라 액세스 가능한 콘텐츠의 길이가 늘어납니다. RTSP 이외의 프로토콜에 의해 동적으로 구축된 콘텐츠도 있으므로 세션 중에 단계적으로 변경되지만 지속적이지는 않을 수도 있습니다. 또한, 콘텐츠를 녹화할 때 완전한 콘텐츠가 유지되지 않고, 예를 들어 마지막 1시간만 유지되는 경우가 있다. 이러한 모든 속성으로 인해 아래에서 설명할 메커니즘이 필요하게 됩니다.

클라이언트가 임의 액세스를 허용하는 주문형 콘텐츠에 액세스할 때 클라이언트는 콘텐츠의 시작과 끝 사이에 있는 모든 지점에 대해 PLAY 요청을 실행할 수 있습니다. 서버는 요청된 지점 이전에 가장 가까운 임의 액세스 지점에서 미디어를 전달하고 이를 PLAY 응답에 표시합니다. 클라이언트가 PAUSE를 실행하면 전달이 중단되고 서버가 중지된 지점이 응답으로 다시 보고됩니다. 클라이언트는 나중에 Range 헤더 없이 PLAY 요청을 보내 재개할 수 있습니다. 서버가 콘텐츠의 끝이나 요청된 범위를 전달하여 PLAY 요청을 완료하려고 하면 서버는 이를 나타내는 PLAY\_NOTIFY 요청\(13.5절\)을 보냅니다.

녹화 등 추가 기능 없이 라이브 콘텐츠를 재생할 경우 클라이언트는 PLAY 요청을 보낸 후 서버로부터 라이브 미디어를 수신합니다. 서버가 콘텐츠를 저장하지 않고 세션 소스에서만 전달하므로 이러한 콘텐츠를 찾는 것은 불가능합니다. 따라서 클라이언트가 PAUSE 요청을 보내거나 세션을 종료하거나 콘텐츠가 종료될 때까지 전달이 계속됩니다.

녹화 중인 라이브 세션의 경우 클라이언트는 녹화가 어떻게 진행되는지 추적해야 합니다. 세션이 설정되면 클라이언트는 Media-Range 헤더에서 현재 녹음 기간을 학습합니다. 녹화가 진행 중이기 때문에 시간이 지날수록 콘텐츠가 직접적으로 늘어납니다. 따라서 PLAY 요청에 대한 각 서버의 응답에는 현재 Media-Range 헤더가 포함됩니다. 또한 서버는 PLAY\_NOTIFY 요청에서 현재 미디어 범위를 정기적으로\(약 5분마다\) 전송해야 합니다\(13.5.2절\). 라이브 전송이 종료되면 서버는 업데이트된 미디어 속성과 함께 PLAY\_NOTIFY 요청을 보내 콘텐츠가 녹화된 라이브 세션이 아닌 주문형 콘텐츠가 되었음을 나타내야 합니다. 요청에는 최종 미디어 범위도 포함됩니다. 라이브 전송이 계속되는 동안 클라이언트는 NPT 시간 표시 기호 "지금"을 사용하여 현재 라이브 지점을 재생하도록 요청하거나 해당 지점에 대한 명시적인 범위 요청을 통해 사용 가능한 콘텐츠의 특정 지점을 요청할 수 있습니다. 요청된 지점이 사용 가능한 간격을 벗어나는 경우 서버는 사용 가능한 가장 가까운 지점, 즉 시작 또는 끝으로 위치를 조정합니다.

녹음의 특별한 경우는 녹음이 특정 기간보다 오래 유지되지 않는 경우입니다. 따라서 라이브 전달이 계속됨에 따라 클라이언트는 예를 들어 "지금"부터 "지금"까지 - 1시간을 포함하는 이동 창 내에서 모든 미디어에 액세스할 수 있습니다. 콘텐츠 내의 특정 지점에서 일시 중지된 클라이언트는 더 이상 콘텐츠를 검색하지 못할 수 있습니다. 클라이언트가 일시 중지 지점을 다시 시작하기 전에 너무 오래 기다리면 콘텐츠를 더 이상 사용하지 못할 수 있습니다. 이 경우 일시 정지 지점은 사용 가능한 미디어에서 가장 가까운 지점으로 조정됩니다.

---
### **2.4.  Session Parameter Manipulations**

세션에는 서버나 클라이언트가 세션이나 콘텐츠를 처리하는 방법, 기능하는 방법 또는 세션이 얼마나 잘 작동하는지에 대한 피드백에 영향을 미치는 추가 상태나 기능이 있을 수 있습니다. 이러한 확장은 본 사양에 정의되어 있지 않지만 다양한 확장에서 다룰 수 있습니다. RTSP에는 클라이언트나 서버에서 매개변수 값을 검색하고 설정하는 두 가지 방법이 있습니다: GET\_PARAMETER\(섹션 13.8\) 및 SET\_PARAMETER\(섹션 13.9\). 이러한 메소드는 적절한 형식의 메시지 본문에 매개변수를 전달합니다. GET\_PARAMETER 메소드로 상태를 쿼리하기 위해 헤더를 사용할 수도 있습니다. 로서

예를 들어, 시간 진행 세션에 대한 현재 미디어 범위를 알아야 하는 클라이언트는 GET\_PARAMETER 메서드를 사용하고 미디어 범위를 포함할 수 있습니다. 또한 RTP-Info\(18.45절\)와 Range\(18.40절\)의 조합을 사용하여 동기화 정보를 요청할 수 있습니다.

RTSP 2.0에는 헤더나 매개변수 및 해당 형식을 협상하기 위한 강력한 메커니즘이 없습니다. 그러나 응답에는 지원되지 않는 요청 헤더 또는 매개변수가 표시됩니다. 어떤 기능을 사용할 수 있는지에 대한 사전 결정은 세션 설명과 같은 대역 외 메커니즘을 통해 또는 기능 태그 사용을 통해 수행되어야 합니다\(섹션 4.5\).

---
### **2.5.  Media Delivery**

이 문서는 UDP \[RFC768\], TCP \[RFC793\] 또는 RTSP 연결을 통해 RTP \[RFC3550\]을 통해 미디어가 전달되는 방법을 지정합니다. 필요에 따라 향후 추가 프로토콜이 지정될 수 있습니다.

RTP를 미디어 전달 프로토콜로 사용하려면 제대로 작동하려면 몇 가지 추가 정보가 필요합니다. PLAY 응답에는 클라이언트가 다양한 RTP 세션에서 다양한 소스를 동기화하는 방법을 안정적이고 시기 적절하게 전달할 수 있는 정보가 포함되어 있습니다. 또한 RTP 타임스탬프와 콘텐츠 시간 규모 간의 매핑을 제공합니다. 서버가 클라이언트에게 미디어 전달 완료를 알리고자 할 때 클라이언트에게 PLAY\_NOTIFY 요청을 보냅니다. PLAY\_NOTIFY 요청에는 각 스트림의 마지막 RTP 시퀀스 번호를 포함하여 스트림 끝에 대한 정보가 포함되어 있으므로 클라이언트가 버퍼를 원활하게 비울 수 있습니다.

---
#### **2.5.1.  Media Delivery Manipulations**

RTSP의 기본 재생 기능을 사용하면 요청된 다양한 콘텐츠를 콘텐츠 작성자가 의도한 속도로 클라이언트에 전달할 수 있습니다. 그러나 RTSP는 두 가지 방법으로 클라이언트에 대한 전달을 조작할 수도 있습니다.

규모: 재생 시간 단위당 전달된 미디어 콘텐츠 시간의 비율입니다.

속도: 벽시계 시간 단위당 전달된 재생 시간의 비율입니다.

둘 다 시간 단위당 미디어 전달에 영향을 줍니다. 그러나 두 개의 독립적인 시간 척도를 조작하고 효과를 결합할 수 있습니다.

Scale\(18.46절\)은 시간 단위당 재생되어야 하는 콘텐츠 시간 단위의 양을 변경하므로 빨리 감기 또는 슬로우 모션 제어에 사용됩니다. Scale \> 1.0은 빨리 감기를 의미합니다. 예를 들어 scale = 2.0이면 매 재생 시마다 2초의 콘텐츠가 재생됩니다. 배율 = 1.0은 배율이 지정되지 않은 경우, 즉 콘텐츠의 원래 속도로 재생되는 경우 사용되는 기본값입니다. 0에서 1.0 사이의 배율 값은 느린 동작을 제공합니다. 배율은 음수일 수 있어 일반 속도\(scale = -1.0\), 빨리 뒤로\(scale < -1.0\) 또는 뒤로 느린 동작\(-1.0 < scale < 0\)으로 역방향 재생을 허용합니다. Scale = 0은 일시 중지와 같으며 허용되지 않습니다.

대부분의 경우 규모의 실현은 클라이언트가 실제로 재생할 수 있도록 서버 측에서 미디어를 조작하는 것을 의미합니다. 이러한 미디어 조작의 성격과 필요한 시기는 미디어 유형에 따라 크게 달라집니다. 두 가지 일반적인 미디어 유형인 오디오와 비디오를 고려해 보겠습니다.

오디오 재생 속도를 수정하는 것은 매우 어렵습니다. 일반적으로 음성의 높낮이와 속도를 변경하여 명료도를 유지하면서 2배 이하의 요소만 가능합니다. 리샘플링을 통해 재생 속도를 조작하려고 하면 음악의 음조가 맞지 않게 됩니다. 이는 잘 알려진 문제이며 오디오는 일반적으로 음소거되거나 현재 재생 지점을 따라잡기 위해 건너뛰기를 사용하여 짧은 세그먼트로 재생됩니다.

비디오의 경우 렌더링 기능이 특정 프레임 속도로 제한되는 경우가 많지만 프레임 속도를 조작하는 것이 가능합니다. 또한 디코딩 시 허용되는 비트 전송률, 인코딩에 사용되는 구조, 프레임 간의 종속성 및 렌더링 장치의 기타 기능으로 인해 가능한 조작이 제한됩니다. 따라서 기본적인 빨리 감기 기능은 특정 프레임 하위 집합을 선택하여 구현되는 경우가 많습니다.

매체 제한으로 인해 가능한 스케일 값은 일반적으로 실현 가능한 스케일 비율 세트로 제한됩니다. 클라이언트가 가능한 배율 값 중에서 선택할 수 있도록 하기 위해 RTSP는 콘텐츠에 대해 지원되는 배율 비율을 알릴 수 있습니다. 진행 중인 세션 중에 변경될 수 있고 콘텐츠 내 위치에 따라 변경될 수 있는 집계 또는 동적 콘텐츠를 지원하기 위해 현재 사용 중인 미디어 속성 및 배율을 업데이트하는 메커니즘이 존재합니다.

속도\(18.50절\)는 주어진 벽시계 기간에 전달되는 재생 타임라인의 양에 영향을 줍니다. 기본값은 속도 = 1이며 이는 미디어가 소비되는 것과 동일한 속도로 전달함을 의미합니다. 속도 \> 1은 수신자가 정기적으로 콘텐츠를 소비하는 것보다 더 빠르게 콘텐츠를 얻는다는 것을 의미합니다. 속도 < 1은 배송 속도가 느리다는 의미입니다.

일반 미디어 단가보다 0 이하의 속도 값은 의미가 없으며 허용되지 않습니다. 이 메커니즘은 두 가지 일반적인 기능을 가능하게 합니다. 하나는 클라이언트 측 크기 조정 작업입니다. 즉, 클라이언트가 모든 프레임을 수신하고 로컬에서 재생을 조정합니다. 두 번째는 미디어 버퍼링을 위한 전달 제어입니다. 1.0 이상의 속도를 지정하면 클라이언트는 버퍼에 있는 재생 시간을 필요에 맞는 수준까지 늘릴 수 있습니다.

순진한 속도 구현은 미디어의 전송 일정에만 영향을 미치며 필요한 대역폭에도 분명한 영향을 미칩니다. 이로 인해 데이터 속도는 속도 요소에 비례하게 됩니다. 속도 = 1.5, 즉 일반 전송보다 50% 빠르면 데이터 전송 속도가 50% 증가합니다. 지원 여부는 기본 네트워크 경로에 따라 다릅니다. 규모는 새로운 재생 일정의 콘텐츠 조작으로 인해 필요한 대역폭에 어느 정도 영향을 미칠 수도 있습니다. 예를 들어 독립적으로 디코딩 가능한 인트라 프레임만 미디어 스트림에 포함되는 빨리 감기가 있습니다. 이렇게 인트라 프레임만 사용하면 대부분의 프레임이 예측을 사용하여 인코딩되는 프레임 수가 동일한 일반 시퀀스에 비해 데이터 속도가 크게 증가합니다.

데이터 전송률의 이러한 잠재적인 증가는 미디어 발신자에서 처리해야 합니다. 클라이언트는 미디어가 특정 방식으로 전달되도록 요청했으며 이를 존중해야 합니다. 그러나 미디어 발신자는 발신자와 수신자 사이의 네트워크 경로가 결과 미디어 스트림을 처리할 수 없는 경우 무시할 수 없습니다. 이 경우 미디어 스트림은 경로의 사용 가능한 리소스에 맞게 조정되어야 합니다. 이로 인해 미디어 품질이 저하될 수 있습니다.

비트 전송률 적응의 필요성은 속도 의미론과 관련하여 특히 문제가 됩니다. 목표가 버퍼를 채우는 것이라면 클라이언트는 품질 저하를 감수하면서 이를 수행하는 것을 원하지 않을 수 있습니다. 클라이언트가 로컬 플레이아웃을 변경하려는 경우 실제로 요청된 속도를 준수해야 할 수도 있습니다. 이 문제를 해결하기 위해 Speed는 두 경우 모두 지원될 수 있도록 범위를 사용합니다. 서버는 사용 가능한 대역폭과 호환되는 범위 내에서 가능한 가장 높은 속도 값을 사용하도록 요청됩니다. 서버가 범위 내에서 속도 값을 유지할 수 있는 한 미디어 품질은 변경되지 않으며 대신 사용 가능한 대역폭에 따라 실제 전송 속도를 수정하고 이를 응답의 속도 값에 반영합니다. 그러나 이것이 가능하지 않은 경우 서버는 대신 최저 속도 값과 사용 가능한 대역폭을 존중하도록 미디어 품질을 수정해야 합니다.

이 기능을 사용하면 로컬 확장 구현에서 좁은 범위 또는 하한이 상한과 동일한 범위를 사용하여 서버가 전송 시간에 관계없이 요청된 양의 미디어 시간을 배달해야 하는지 식별할 수 있습니다. 사용 가능한 경로 대역폭에 맞게 미디어 품질을 조정해야 합니다. 버퍼 채우기의 경우 1.0 - 2.5와 같이 합리적인 범위와 공칭 미디어 속도 1.0의 하한을 갖는 범위를 사용하는 것이 적합합니다. 클라이언트가 버퍼를 줄이려는 경우 1.0 미만의 상한을 지정하여 서버가 명목 미디어 속도보다 느리게 전송하도록 할 수 있습니다.

---
### **2.6.  Session Maintenance and Termination**

설정된 세션 컨텍스트는 클라이언트가 활성 상태를 표시하도록 하여 활성 상태로 유지됩니다. 이는 두 가지 주요 방법으로 수행됩니다.

o 미디어 전송 프로토콜 연결 유지. RTP를 사용할 때 RTCP\(RTP Control Protocol\)를 사용할 수 있습니다.

o 세션 컨텍스트를 참조하는 모든 RTSP 요청.

섹션 10.5에서는 활성 상태를 더 자세히 표시하는 방법을 논의합니다. 클라이언트가 설정된 세션 제한 시간 값\(일반적으로 60초\) 이상 활성 상태를 표시하지 못하는 경우 서버는 컨텍스트를 종료할 수 있습니다. 세션 헤더에 timeout 매개변수를 포함시켜 서버에서 다른 값을 선택할 수 있습니다.

세션 컨텍스트는 일반적으로 클라이언트가 집계된 제어 URI를 참조하는 서버에 TEARDOWN 요청\(13.7절\)을 보내는 방식으로 종료됩니다. 개별 미디어 리소스는 해당 특정 미디어 리소스를 참조하는 TEARDOWN 요청에 의해 세션 컨텍스트에서 제거될 수 있습니다. 세션 컨텍스트에서 모든 미디어 리소스가 제거되면 세션 컨텍스트가 종료됩니다.

클라이언트는 서버에서 허용하는 경우 세션을 무기한으로 유지할 수 있습니다. 그러나 클라이언트는 미디어 전달 활동이 없는 오랜 시간이 지나면 세션 컨텍스트를 해제하는 것이 좋습니다. 클라이언트는 나중에 필요한 경우 세션 컨텍스트를 다시 설정할 수 있습니다. 연장된 기간을 구성하는 기간은 클라이언트, 서버 및 사용법에 따라 다릅니다. 세션 제한 시간 값이 10회 경과하기 전에 클라이언트가 세션을 종료하는 것이 좋습니다. 서버는 연결 유지 이상의 클라이언트 활동 없이 한 세션 시간 초과 기간 후에 세션을 종료할 수 있습니다. 서버가 세션 컨텍스트를 종료할 때 이유를 나타내는 TEARDOWN 요청을 전송하여 종료합니다.

서버는 유지 관리에 필요할 수 있으므로 클라이언트에게 세션을 해제하고 대체 서버에서 다시 설정하도록 요청할 수도 있습니다. 이는 REDIRECT 메서드\(13.10절\)를 사용하여 수행됩니다. Terminate-Reason 헤더\(18.52절\)는 시기와 이유를 나타내는 데 사용됩니다. Location 헤더는 사용 가능한 대체 서버가 있는 경우 연결해야 하는 위치를 나타냅니다. 기한이 만료되면 서버는 서비스 제공을 중단합니다. 깔끔하게 종료하려면 클라이언트가 마감일 이전에 세션 종료를 시작해야 합니다. 서버에 리디렉션할 다른 서버가 없고 유지 관리를 위해 세션을 닫으려는 경우 Terminate-Reason 헤더와 함께 TEARDOWN 메서드를 사용해야 합니다.

---
### **2.7.  Extending RTSP**

RTSP는 다양한 방향의 확장을 지원하는 매우 다재다능한 프로토콜입니다. 이 핵심 사양에도 선택적으로 구현할 수 있는 여러 기능 블록이 포함되어 있습니다. 프로토콜 배포에 대한 사용 사례와 요구 사항에 따라 구현되는 부분이 결정되어야 합니다. 확장을 허용하면 RTSP가 추가 사용 사례를 처리할 수 있습니다. 그러나 확장은 프로토콜의 상호 운용성에 영향을 미칩니다. 따라서 구조화된 방식으로 추가할 수 있는 것이 중요합니다.

클라이언트는 OPTIONS 메서드\(13.1절\)와 Supported 헤더\(18.51절\)를 사용하여 서버의 기능을 배울 수 있습니다. 또한 새로운 방법을 사용하여 시도했지만 실패할 수도 있고 Require\(섹션 18.43\) 또는 Proxy-Require\(섹션 18.37\) 헤더를 사용하여 특정 기능이 지원되도록 요구할 수도 있습니다.

RTSP 자체는 세 가지 방법으로 확장될 수 있습니다. 여기에는 지원되는 변경 규모가 증가하는 순서대로 나열되어 있습니다.

o 수신자가 이러한 매개변수를 안전하게 무시할 수 있는 한 헤더와 같은 새 매개변수를 사용하여 기존 방법을 확장할 수 있습니다. 메서드 확장이 지원되지 않을 때 클라이언트가 부정 승인을 필요로 하는 경우 확장에 해당하는 태그가 Require 또는 Proxy-Require 헤더 필드에 추가될 수 있습니다.

o 새로운 방법이 추가될 수 있습니다. 메시지 수신자가 요청을 이해하지 못하는 경우 발신자가 이 방법을 다시 사용하지 않도록 오류 코드 501\(구현되지 않음\)으로 응답해야 합니다. 클라이언트는 OPTIONS 메소드를 사용하여 서버가 지원하는 메소드에 대해 문의할 수도 있습니다. 서버는 Public 응답 헤더를 사용하여 지원하는 메서드를 나열해야 합니다.

o 프로토콜의 새 버전을 정의하여 거의 모든 측면\(프로토콜 버전 번호의 위치 제외\)을 변경할 수 있습니다. 프로토콜의 새 버전은 표준 추적 문서를 통해 등록되어야 합니다.

기본 기능 검색 메커니즘은 특정 기능에 대한 지원을 검색하고 요청을 수행할 때 기능을 사용할 수 있는지 확인하는 데 사용할 수 있습니다. 이에 대한 자세한 설명은 11절을 참조하십시오.

핵심 프로토콜에 대한 확장 외에도 세션 설정 시 새로운 미디어 전달 프로토콜이 추가되고 협상될 수 있습니다. 특정 유형의 프로토콜 조작은 SET\_PARAMETER 및 GET\_PARAMETER를 사용하는 매개변수 형식을 통해 수행할 수 있습니다.

---
## **3.  Document Conventions**
---
### **3.1.  Notational Conventions**

이 문서에 명시된 모든 메커니즘은 \[RFC5234\]에 자세히 설명된 ABNF\(Augmented Backus-Naur form\)와 산문으로 설명되어 있습니다.

들여쓰기된 단락은 유익한 배경과 동기를 제공하는 데 사용됩니다. 이는 사양 공식화에 참여하지 않은 독자에게 RTSP의 상황이 왜 그런 것인지에 대한 이해를 제공하기 위한 것입니다.

키워드 "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY" 및 "OPTIONAL" "는 \[RFC2119\]에 설명된 대로 해석됩니다.\(MUST NOT\)

"지정되지 않음"이라는 단어는 본 명세서에서 정의되지 않은 기능이나 특징을 나타내는 데 사용됩니다. 이러한 기능은 RTSP 확장 사양에서 추가 정의 없이는 표준화된 방식으로 사용할 수 없습니다.

---
### **3.2.  Terminology**

집계 제어: 일반적으로 서버에서 유지 관리하는 단일 타임라인을 사용하여 여러 스트림을 제어하는 ​​개념입니다. 예를 들어 클라이언트는 영화의 오디오와 비디오를 동시에 제어하기 위해 단일 재생 또는 일시 중지 메시지를 발행할 때 집계 제어를 사용합니다. 집합적으로 제어되는 세션을 "집계된 세션"이라고 합니다.

집계 제어 URI: 집계된 세션을 참조하고 제어하기 위해 RTSP 요청에 사용되는 URI입니다. 항상 그런 것은 아니지만 일반적으로 세션 설명에 지정된 프레젠테이션 URI에 해당합니다. 자세한 내용은 섹션 13.3을 참조하세요.

클라이언트: 클라이언트는 미디어 서버로부터 미디어 서비스를 요청하는 사람입니다.

연결: 통신을 위해 두 프로그램 사이에 설정된 전송 계층 가상 회선입니다.

컨테이너 파일: 함께 재생할 때 프레젠테이션을 구성하는 경우가 많은 여러 미디어 스트림을 포함할 수 있는 파일입니다. 컨테이너 파일의 개념은 프로토콜에 포함되어 있지 않습니다. 그러나 RTSP 서버는 이러한 파일 내의 미디어 스트림에 대한 종합적인 제어를 제공할 수 있습니다.

연속 미디어: 소스와 싱크 사이에 타이밍 관계가 있는 데이터입니다. 즉, 싱크는 소스에 존재했던 타이밍 관계를 재현해야 합니다. 연속 미디어의 가장 일반적인 예로는 오디오와 모션 비디오가 있습니다. 연속 미디어는 소스와 싱크 사이에 "긴밀한" 타이밍 관계가 있는 실시간\(대화형 또는 대화형\)이거나 관계가 덜 엄격한 스트리밍일 수 있습니다.

기능 태그: 특정 기능 집합, 즉 기능을 나타내는 태그입니다.

IRI: 국제화된 자원 식별자는 URI와 유사하지만 US-ASCII만이 아닌 전체 범용 문자 집합\(유니코드/ISO 10646\)의 문자를 허용합니다. 자세한 내용은 \[RFC3987\]을 참조하세요.

라이브: 라이브 프레젠테이션 또는 세션은 미디어 전달과 동시에 발생하는 이벤트에서 미디어를 생성합니다. 라이브 세션에는 바인딩되지 않거나 느슨하게 정의된 기간이 있는 경우가 많으며 검색 작업이 불가능할 수 있습니다.

미디어 초기화: 데이터 유형 또는 코덱별

- 초기화. 여기에는 클럭 속도, 색상 테이블 등이 포함됩니다. 미디어 스트림 재생을 위해 클라이언트에 필요한 모든 전송 독립적 정보는 스트림 설정의 미디어 초기화 단계에서 발생합니다.

미디어 매개변수: 스트림 전달 전이나 도중에 변경될 수 있는 미디어 유형에 특정한 매개변수입니다.

미디어 서버: 하나 이상의 미디어 스트림에 대한 미디어 전달 서비스를 제공하는 서버입니다. 프레젠테이션 내의 다양한 미디어 스트림은 다양한 미디어 서버에서 시작될 수 있습니다. 미디어 서버는 프레젠테이션이 호출되는 호스트와 동일한 호스트에 있을 수도 있고 다른 호스트에 있을 수도 있습니다.

\(미디어\) 스트림: 단일 미디어 인스턴스\(예: 오디오 스트림, 비디오 스트림, 단일 화이트보드 또는 공유 애플리케이션 그룹\)입니다. RTP를 사용할 때 스트림은 RTP 세션 내의 미디어 소스에서 생성된 모든 RTP 및 RTCP 패킷으로 구성됩니다.

메시지: 섹션 20에 정의된 구문과 일치하는 구조화된 옥텟 시퀀스로 구성되고 RTSP 에이전트 간의 전송을 통해 전송되는 RTSP 통신의 기본 단위입니다. 메시지는 요청이거나 응답입니다.

메시지 본문: 메시지\(요청 또는 응답\)의 페이로드로 전송되는 정보입니다. 메시지 본문은 섹션 9에 설명된 대로 메시지 본문 헤더 형태의 메타정보와 임의 개수의 데이터 옥텟 형태의 콘텐츠로 구성됩니다.

비집합 제어: 단일 미디어 스트림을 제어합니다.

프리젠테이션: 클라이언트에게 완전한 미디어 피드로 제공되고 아래 정의된 프리젠테이션 설명으로 설명되는 하나 이상의 스트림 세트입니다. 둘 이상의 미디어 스트림이 포함된 프레젠테이션은 통합 제어 하에 RTSP에서 처리되는 경우가 많습니다.

프레젠테이션 설명: 프레젠테이션 설명에는 인코딩 집합, 네트워크 주소, 콘텐츠에 대한 정보 등 프레젠테이션 내의 하나 이상의 미디어 스트림에 대한 정보가 포함됩니다. SDP\(\[RFC4566\]\)와 같은 다른 IETF 프로토콜에서는 프레젠테이션에 "세션"이라는 용어를 사용합니다. 프레젠테이션 설명은 SDP 형식을 포함하되 이에 국한되지 않는 다양한 형식을 취할 수 있습니다.

응답: 요청에 대한 RTSP 응답입니다. RTSP 메시지의 한 유형입니다. HTTP 응답을 의미하는 경우 명시적으로 표시됩니다.

요청: RTSP 요청입니다. RTSP 메시지의 한 유형입니다. HTTP 요청을 의미하는 경우 명시적으로 표시됩니다.

요청-URI: 요청이 수행될 리소스를 나타내기 위해 요청에 사용되는 URI입니다.

RTSP 에이전트: RTSP 클라이언트, RTSP 서버 또는 RTSP 프록시입니다. 이 사양에는 요청을 보내거나 응답을 받는 기능과 같이 이 세 가지 엔터티에 공통적인 많은 기능이 있습니다. 이 용어는 이들 세 가지 엔터티 모두에 적용할 수 있는 기능을 설명할 때 사용됩니다.

RTSP 세션: RTSP의 주요 제어 방법이 작동하는 상태 저장 추상화입니다. RTSP 세션은 공통 컨텍스트입니다. 클라이언트의 요청에 따라 생성 및 유지 관리되며 클라이언트나 서버에 의해 삭제될 수 있습니다. 이는 성공적인 SETUP 요청 완료 시\(200 OK 응답이 전송될 때\) RTSP 서버에 의해 설정되며 해당 시점에 세션 식별자로 레이블이 지정됩니다. 세션은 서버에 의해 시간 초과되거나 TEARDOWN 요청에 의해 명시적으로 제거될 때까지 존재합니다. RTSP 세션은 상태 저장 엔터티입니다. RTSP 서버는 대부분의 상태 전환이 클라이언트 요청에 의해 트리거되는 명시적인 세션 상태 시스템\(부록 B 참조\)을 유지합니다. 세션의 존재는 세션의 미디어 스트림 및 해당 전송 메커니즘에 대한 상태의 존재를 의미합니다. 특정 세션에는 하나 이상의 미디어 스트림이 연결될 수 있습니다. RTSP 서버는 세션을 사용하여 여러 미디어 스트림에 대한 제어를 집계합니다.

원본 서버: 특정 리소스가 상주하는 서버입니다.

탐색: 콘텐츠 타임라인의 특정 지점부터 재생을 요청합니다.

전송 초기화: 클라이언트와 서버 간의 전송 정보\(예: 포트 번호, 전송 프로토콜\) 협상입니다.

URI: 범용 자원 식별자. \[RFC3986\]을 참조하세요. RTSP에 사용되는 URI는 일반적으로 리소스 위치를 제공하는 URL입니다. URL은 URI의 하위 집합이므로 RTSP URI가 URL이 아닌 경우도 처리하기 위해 URI라고 합니다.

URL: Universal Resource Locator는 이름이나 해당 리소스의 다른 속성으로 리소스를 식별하는 대신 기본 액세스 메커니즘을 통해 리소스를 식별하는 URI입니다.

---
## **4.  Protocol Parameters**
---
### **4.1.  RTSP Version**

이 사양은 RTSP 버전 2.0을 정의합니다.

RTSP는 "<major\>.<minor\>" 번호 지정 체계를 사용하여 프로토콜 버전을 나타냅니다. 프로토콜 버전 관리 정책은 보낸 사람이 해당 통신을 통해 얻은 기능보다는 추가 RTSP 통신을 이해할 수 있는 메시지 형식과 용량을 표시할 수 있도록 하기 위한 것입니다. 통신 동작에 영향을 주지 않거나 확장 가능한 필드 값에만 추가되는 메시지 구성 요소를 추가하는 경우 버전 번호는 변경되지 않습니다.

<minor\> 번호는 일반 메시지 구문 분석 알고리즘을 변경하지 않지만 메시지 의미를 추가하고 보낸 사람의 추가 기능을 암시할 수 있는 프로토콜 추가 기능에 대한 변경 사항이 있을 때 증가됩니다. <major\> 번호는 프로토콜 내의 메시지 형식이 변경되면 증가됩니다. RTSP 메시지의 버전은 메시지 첫 번째 줄의 RTSP-Version 필드로 표시됩니다. 메이저 및 마이너 숫자는 별도의 정수로 처리되어야 하며 각각은 한 자리보다 높게 증가할 수 있습니다. 따라서 RTSP/2.4는 RTSP/2.13보다 낮은 버전이고 RTSP/12.3보다 낮습니다. 선행 0은 전송되지 않으며 수신자는 이를 무시해야 합니다.\(MUST, MUST NOT\)

---
### **4.2.  RTSP IRI and URI**

RTSP 2.0은 세 가지 URI 체계 "rtsp", "rtsps" 및 "rtspu"를 정의하고 등록하거나 업데이트합니다. 마지막 "rtspu"의 사용법은 RTSP 2.0에서 지정되지 않았으며 RTSP 1.0에서 정의된 URI 체계를 등록하기 위해 여기에서 정의되었습니다. "rtspu" 체계는 신뢰할 수 없는 전송 수단\(RTSP 1.0의 UDP\)을 통한 RTSP 메시지의 지정되지 않은 전송을 나타냅니다. RTSP 서버는 "rtspu" URI 체계를 전달하는 요청에 대해 "rtspu" 체계가 구현되지 않았음을 나타내는 오류 코드\(501\)로 응답해야 합니다.\(MUST\)

"rtsp" 및 "rtsps" URI 구문의 세부 사항이 RTSP 1.0에서 변경되었습니다. 이러한 변경 사항에는 다음이 추가됩니다.

o \[RFC3986\]에 정의된 메커니즘을 통해 호스트 부분 및 향후 IP 리터럴에서 IPv6 리터럴을 지원합니다.

o "/"로 시작할 필요가 없는 RTSP 요소에 사용할 새로운 상대 형식입니다.

둘 다 상호 운용성에 큰 영향을 주어서는 안 됩니다. RTSP URI에 IPv6 리터럴이 필요한 경우 해당 RTSP 서버는 IPv6를 지원해야 하며 RTSP 1.0은 완전한 IPv6 지원 프로토콜이 아닙니다. RTSP 1.0 클라이언트가 URI를 처리하려고 시도하는 경우 URI는 허용된 구문과 일치하지 않으며 유효하지 않은 것으로 간주되어 처리가 중지됩니다. 이는 분명히 리소스에 도달하지 못한 것입니다. 그러나 서버와 클라이언트 모두에서 RTSP 2.0 지원이 필요했기 때문에 이는 의미 문제가 아닙니다. 따라서 클라이언트와 서버 간에 RTSP 버전이 일치하지 않는 경우 이후 단계에서만 오류가 발생합니다. 요청-URI는 절대 URI여야 하므로 두 번째 변경은 RTSP 메시지 헤더 내에서만 발생합니다. 따라서 이러한 사용은 에이전트가 RTSP 2.0 메시지를 수락하고 처리를 시작한 후에만 발생하며 RTSP 1.0만 사용하는 에이전트는 이러한 유형의 상대 URI를 구문 분석할 필요가 없습니다.

이 사양은 또한 웹 페이지, 사용자 인터페이스, 종이 등에서 RTSP 리소스 식별자 및 위치 지정자로 사용할 수 있는 RTSP IRI \[RFC3987\]의 형식을 정의합니다. 그러나 RTSP 요청 메시지 형식은 절대 URI 형식의 사용만 허용합니다. RTSP IRI 형식은 \[RFC3987\]에 정의된 대로 IRI를 URI로 변환하는 규칙과 변환을 사용해야 합니다. 이를 통해 RTSP 2.0 사양과 일치하고 요청에 사용하기에 적합한 URI가 RTSP IRI에서 생성될 수 있습니다.\(MUST\)

RTSP IRI와 URI는 모두 \[RFC3986\] 및 \[RFC3987\]에 정의된 일반 구문과 비교하여 구문이 제한되어 있습니다.

o 절대 URI에는 권한 부분이 필요합니다. 즉, 호스트 ID를 제공해야 합니다.\(MUST\)

o 경로 요소의 매개변수 앞에는 예약된 구분 기호 ";"가 붙습니다.

모든 URI \[RFC3986\] 및 IRI \[RFC3987\]의 "구성표" 및 "호스트" 부분은 대소문자를 구분하지 않습니다. RTSP URI 및 IRI의 다른 모든 부분은 대소문자를 구분하며 대소문자를 매핑해서는 안 됩니다.\(MUST NOT\)

조각 식별자는 \[RFC3986\]의 섹션 3.5 및 4.3에 정의된 대로 사용됩니다. 즉, 조각은 요청자에 의해 IRI에서 제거되고 요청-URI에는 포함되지 않습니다. 사용자 에이전트는 요청과 관련된 미디어 유형을 기반으로 조각의 값을 해석해야 합니다. 즉, DESCRIBE 요청에 대한 응답의 Content-Type 헤더에 표시된 미디어 유형입니다.

모든 URI 쿼리 문자열의 구문은 지정되지 않으며 응답자\(일반적으로 서버\)에 따라 다릅니다. 요청자의 관점에서 쿼리는 불투명한 문자열이므로 그렇게 처리되어야 합니다.

쿼리가 포함된 상대 URI는 RFC 3986의 상대 URI 처리 규칙으로 인해 처리하기 어렵습니다. 상대 URI를 사용하여 경로 요소를 변경하면 쿼리가 제거됩니다. 즉, 상대 부분에 쿼리가 포함되어야 함을 의미합니다. .

URI 체계 "rtsp"에서는 명령이 신뢰할 수 있는 프로토콜\(인터넷, TCP 내\)을 통해 실행되어야 하는 반면, 체계 "rtsps"는 보안 전송\(TLS \[RFC5246\]\)을 사용하여 신뢰할 수 있는 전송을 식별합니다. 섹션 19를 참조하세요.

"rtsp" 체계의 경우 URI의 권한 부분에 포트 번호가 제공되지 않으면 포트 번호 554를 사용해야 합니다. "rtsps" 체계의 경우 URI 포트 번호의 권한 부분에 포트 번호가 제공되지 않으면 TCP 포트 322를 사용해야 합니다.\(MUST, MUST\)

프리젠테이션 또는 스트림은 URI \[RFC3986\]의 문자 세트 및 이스케이프 규칙을 사용하여 텍스트 미디어 식별자로 식별됩니다. URI는 스트림 또는 스트림 집합을 참조할 수 있습니다. 즉, 프레젠테이션. 따라서 섹션 13에 설명된 요청은 전체 프리젠테이션 또는 프리젠테이션 내의 개별 스트림에 적용될 수 있습니다. 일부 요청 방법은 프레젠테이션이 아닌 스트림에만 적용될 수 있으며 그 반대의 경우도 마찬가지입니다.

예를 들어 RTSP URI는 다음과 같습니다.

```text
      rtsp://media.example.com:554/twister/audiotrack
```

호스트 media.example.com의 포트 554에 대한 TCP 연결을 통해 발행된 RTSP 요청을 통해 제어될 수 있는 프리젠테이션 "twister" 내의 오디오 스트림을 식별할 수 있습니다.

또한 RTSP URI는 다음과 같습니다.

```text
      rtsp://media.example.com:554/twister
```

오디오 및 비디오 스트림으로 구성될 수 있지만 임의 미디어 리디렉터와 같은 다른 것일 수도 있는 프레젠테이션 "트위스터"를 식별합니다.

- 이는 URI에서 스트림을 참조하는 표준 방법을 의미하지 않습니다. 프레젠테이션 설명은 프레젠테이션의 계층적 관계와 개별 스트림에 대한 URI를 정의합니다. 프레젠테이션 설명에서는 스트림 이름을 "a.mov"로 지정하고 전체 프레젠테이션 이름을 "b.mov"로 지정할 수 있습니다.

RTSP URI의 경로 구성 요소는 클라이언트에게 불투명하며 서버의 특정 파일 시스템 구조를 암시하지 않습니다.

- 이 분리를 통해 간단히 URI의 구성표를 대체함으로써 RTSP가 아닌 미디어 제어 프로토콜과 함께 프레젠테이션 설명을 사용할 수 있습니다.

---
### **4.3.  Session Identifiers**

세션 식별자는 8\~128자 길이의 문자열입니다. 세션 식별자는 암호화 방식으로 무작위로 만드는 방법을 사용하여 생성되어야 합니다\(\[RFC4086\] 참조\). 세션 식별자에는 128비트의 엔트로피, 즉 고품질 생성기의 약 22문자가 포함되는 것이 권장됩니다\(섹션 21 참조\). 그러나 세션 식별자는 클라이언트, 서버 및 신뢰할 수 있는 프록시에 의해 기밀로 유지되지 않는 한 세션 하이재킹에 대한 보안을 제공하지 않습니다.\(MUST, SHOULD\)

---
### **4.4.  Media-Time Formats**

RTSP는 현재 아래에 정의된 세 가지 미디어 시간 형식을 지원합니다. 나중에 추가 시간 형식을 지정할 수 있습니다. 이러한 시간 형식은 Range 헤더\(18.40절\)와 함께 사용되어 재생을 요청하고 어떤 미디어 위치 프로토콜 요청이 실제로 발생하거나 발생했는지 지정할 수 있습니다. 또한 Media-Range 헤더\(18.30절\)를 사용하여 미디어 속성을 설명하는 데에도 사용됩니다. 정규화되지 않은 형식 식별자는 지원되는 시간 형식을 선언하기 위해 Accept-Ranges 헤더\(18.5절\)에서 자체적으로 사용되며 응답에 사용되는 시간 형식을 요청하기 위해 Range 헤더\(18.40절\)에서도 사용됩니다.

---
#### **4.4.1.  SMPTE-Relative Timestamps**

타임스탬프는 SMPTE\(Society of Motion Picture and Television Engineers\) 사양에서 파생된 형식을 사용할 수 있으며 미디어 클립 시작 부분에 고정된 시간 오프셋을 표현할 수 있습니다. 상대 타임스탬프는 프레임 수준 액세스 정확도를 위해 SMPTE 시간 코드\[SMPTE-TC\]로 표현됩니다. 시간 코드의 형식은 다음과 같습니다.

```text
      hours:minutes:seconds:frames.subframes
```

클립의 시작 부분에 원점이 있습니다. 기본 SMPTE 형식은 초당 29.97 프레임의 프레임 속도를 갖는 "SMPTE 30 드롭" 형식입니다. "smpte-type"을 사용하여 다른 SMPTE 코드\(예: "SMPTE 25"\)를 지원할 수 있습니다. SMPTE 30의 경우 시간 값의 "프레임" 필드는 0부터 29까지의 값을 가정할 수 있습니다. 초당 30과 29.97 프레임 사이의 차이는 매 분의 처음 두 프레임 인덱스\(값 00과 01\)를 삭제하여 처리됩니다. 10분마다. 프레임과 서브프레임 값이 0인 경우 생략될 수 있다. 서브프레임은 프레임의 100분의 1 단위로 측정됩니다.\(MAY\)

```text
   Examples:

     smpte=10:12:33:20-
     smpte=10:07:33-
     smpte=10:07:00-10:07:33:05.01
     smpte-25=10:07:00-10:07:33:05.01
```

---
#### **4.4.2.  Normal Play Time**

NPT\(Normal Play Time\)는 프레젠테이션 시작을 기준으로 한 스트림 절대 위치를 나타냅니다. 타임스탬프는 두 부분으로 구성됩니다. 필수 첫 번째 부분은 초 단위로만 표시되거나 시간, 분, 초 단위로 표시될 수 있습니다. 선택적 두 번째 부분은 소수점과 소수점 숫자로 구성되며 초의 분수를 나타냅니다.

프레젠테이션의 시작은 0.0초에 해당합니다. 음수 값은 정의되지 않습니다.

특수 상수 "now"는 라이브 이벤트의 현재 순간으로 정의됩니다. 라이브 이벤트에만 사용할 수 있으며 주문형\(즉, 라이브가 아닌\) 콘텐츠에는 사용하면 안 됩니다.\(MUST NOT\)

NPT는 디지털 저장 매체 명령 및 제어\(DSMb;CC\) \[ISO.13818-6.1995\]에 정의되어 있습니다.

- 직관적으로 NPT는 시청자가 프로그램과 연관시키는 시계입니다. DVD 플레이어에 디지털 방식으로 표시되는 경우가 많습니다. NPT는 일반 재생 모드\(스케일 = 1\)에 있을 때 정상적으로 진행되고, 빠른 스캔 앞으로\(높은 포지티브 스케일 비율\)에 있을 때 더 빠른 속도로 진행되고, 스캔 리버스\(네거티브 스케일 비율\)에 있을 때 감소하며 일시 정지 모드에서 고정됩니다. NPT는 \(논리적으로\) SMPTE 시간 코드와 동일합니다.

```text
   Examples:

     npt=123.45-125
     npt=12:05:35.3-
     npt=now-
```

구문은 ISO 8601 \[ISO.8601.2000\]을 기반으로 하며 프레젠테이션 시작 이후 경과된 시간을 표현하며 두 가지 다른 표기법이 허용됩니다.

o npt-hhmmss 표기법은 시간, 분, 초\(hh\) 사이의 구분 기호로 콜론\(":"\)을 사용하여 날짜 형식\(\[ISO.8601.2000\]의 섹션 5.3.1.1\)의 ISO 8601 확장된 완전한 표현을 사용합니다. :mm:ss\). 시간 카운터는 0\~24시간으로 제한되지 않습니다. 최대 19개의 시간 숫자가 허용됩니다.

- \* ISO 8601 시간 형식의 요구 사항에 따라 시, 분, 초가 모두 있어야 하며, 분과 초에는 두 자리 숫자가 사용되고 시간에는 최소 두 자리 숫자가 사용되어야 합니다. 7분 0초의 NPT는 "00:07:00"으로 표시되고, 392시간 0분 6초의 NPT는 "392:00:06"으로 표시됩니다.\(MUST\)

- \* RTSP 1.0에서는 구현이 실패하지 않도록 하기 위해 선행 0 없이 npt-hhmmss 표기법에서 NPT를 허용했습니다. 이전 버전과의 호환성을 위해 모든 RTSP 2.0 구현은 앞에 0이 없는 NPT 값, 시간, 분 또는 초 수신을 지원해야 합니다.\(MUST\)

o npt-sec 표기법은 1\~19자리 숫자를 사용하여 시간을 초 단위로 표현합니다.

두 표기법 모두 \[ISO.8601.2000\]의 섹션 5.3.1.3에 지정된 대로 최대 9자리를 사용하고 "."만 허용하는 소수점 이하 초를 허용합니다. \(마침표\)를 소수 구분 기호로 사용합니다.

npt-sec 표기법은 자동 생성에 최적화되어 있습니다. npt-hhmmss 표기법은 인간 독자가 사용하도록 최적화되었습니다. "now" 상수를 사용하면 클라이언트가 저장된 버전이나 시간 지연된 버전이 아닌 라이브 피드를 받도록 요청할 수 있습니다. 이 경우에는 절대 시간이나 영 시간이 적합하지 않기 때문에 이것이 필요합니다.

---
#### **4.4.3.  Absolute Time**

절대 시간은 ISO 8601 \[ISO.8601.2000\]을 기반으로 하는 타임스탬프를 사용하여 표현됩니다. 날짜는 구분 기호 없이 기본 형식\(YYYYMMDD\)으로 달력 날짜를 완전히 표현한 것입니다\(\[ISO.8601.2000\]의 섹션 5.2.1.1에 따름\). 시간은 \[ISO.8601.2000\]의 섹션 5.3.1.1에 지정된 대로 완전한 표현 기본 형식\(hhmmss\)으로 제공되며, "."가 필요한 섹션 5.3.1.3 다음에 초의 소수 부분을 허용합니다. \(마침표\)를 소수 구분 기호로 사용하고 자릿수를 9개 이하로 제한합니다. 표현된 시간은 UTC\(GMT\)를 사용해야 합니다. 즉, 시간대 오프셋이 허용되지 않습니다. 전체 날짜 및 시간 사양은 다음과 같습니다.\(MUST\)

8자리 날짜, "T", 6자리 시간 값, 선택적으로 마침표, 1\~9초의 소수 부분, "Z"로 끝납니다\(예: YYYYMMDDThhmmss.ssZ\).

- "인터넷의 날짜 및 시간: 타임스탬프" \[RFC3339\]를 사용하지 않고 이 시간 형식을 사용하는 이유는 역사적입니다. 우리는 RTSP 1.0에 지정된 형식을 계속 사용합니다. RFC 3339에서 제기된 동기는 ISO 8601에서 선택한 이유에 적용됩니다. 그러나 이 경우에는 다르고 훨씬 더 제한적인 선택이 적용되었습니다.

다음은 미디어 시간 형식의 세 가지 예입니다. 첫째, 1996년 11월 8일 14시 37분 20 1/4초\(UTC\) 10분 5초 동안 재생되는 시작 시간에 대한 시계 형식 범위 요청입니다. 2014년 12월 24일 15시 00분에 대한 Media-Properties 헤더의 "Time-Limited" UTC 속성, 마지막으로 2013년 6월 18일 16시 12분에 대한 Terminate-Reason 헤더 "시간" 속성 56초:

```text
     clock=19961108T143720.25Z-19961108T144725.25Z
     Time-Limited=20141224T1500Z
     time=20130618T161256Z
```

---
### **4.5.  Feature Tags**

기능 태그는 RTSP에서 기능을 지정하는 데 사용되는 고유 식별자입니다. 이러한 태그는 Require\(섹션 18.43\), Proxy-Require\(섹션 18.37\), Proxy-Supported\(섹션 18.38\), Supported\(섹션 18.51\) 및 Unsupported\(섹션 18.55\) 헤더 필드에 사용됩니다.

기능 태그 정의는 적용되는 클라이언트, 서버 또는 프록시의 조합을 나타내야 합니다.\(MUST\)

새로운 RTSP 기능 태그 작성자는 기능 태그 앞에 역방향 도메인 이름을 붙이거나\(예: "com.example.mynewfeature"는 "example.com"에서 발명가에게 연락할 수 있는 기능에 적합한 이름입니다\) 등록해야 합니다. IANA\(Internet Assigned Numbers Authority\)가 포함된 새로운 기능 태그입니다. \(섹션 22, "IANA 고려 사항" 참조\)

기능 태그의 사용법은 기능 처리를 다루는 섹션 11에서 자세히 설명합니다.

---
### **4.6.  Message Body Tags**

메시지 본문 태그는 동일한 리소스\(예: 캐시\)의 두 메시지 본문을 비교하거나 리디렉션 후 설정을 최적화하는 데 사용되는 불투명 문자열입니다. 메시지 본문 태그는 MTag 헤더\(섹션 18.31 참조\) 또는 SDP\(부록 D.1.9 참조\)로 전달될 수 있습니다. MTag는 HTTP/1.1의 ETag와 유사합니다\(\[RFC2068\]의 섹션 3.11 참조\).

메시지 본문 태그는 특정 리소스와 연결된 모든 메시지 본문의 모든 버전에서 고유해야 합니다. 주어진 메시지 본문 태그 값은 다른 URI에 대한 요청으로 얻은 메시지 본문에 사용될 수 있습니다. 서로 다른 URI에 대한 요청으로 얻은 메시지 본문과 함께 동일한 메시지 본문 태그 값을 사용한다고 해서 해당 메시지 본문이 동등하다는 의미는 아닙니다.\(MUST, MAY\)

메시지 본문 태그는 일부 메서드를 조건부로 만들기 위해 RTSP에서 사용됩니다. 메서드는 헤더를 포함하여 조건부로 만들어집니다. If-Match 및 If-None-Match 헤더에 대한 정보는 각각 섹션 18.24 및 섹션 18.26을 참조하세요. RTSP 메시지 본문 태그는 전체 프레젠테이션, 즉 프레젠테이션 설명과 개별 미디어 스트림 모두에 적용됩니다. 따라서 메시지 본문 태그를 사용하면 리디렉션 후 설정 시 If-Match 헤더를 사용하여 동일한 세션 설명이 새 위치의 미디어에 적용되는지 확인할 수 있습니다.

---
### **4.7.  Media Properties**

RTSP 서버가 미디어를 처리할 때 전달 및 재생을 위해 미디어 인스턴스가 가질 수 있는 다양한 속성을 고려하는 것이 중요합니다. 이 사양은 프로토콜 작업에서 아래 나열된 미디어 속성을 고려합니다. 이는 지원되는 여러 사용법 간의 차이점에서 파생됩니다.

주문형: RTSP 세션 수명 동안 변경되지 않고 세션 생성 시 알려진 고정\(지정\) 기간이 있는 미디어입니다. 인코딩이나 품질 등 표현 방식이 변경되더라도 미디어의 내용은 변경되지 않을 것으로 예상됩니다. 일반적으로 미디어 내에서 검색, 즉 모든 범위를 요청할 수 있습니다.

동적 주문형: 이는 RTSP 세션에 대한 미디어 설정의 실제 콘텐츠를 조작하기 위해 외부 방법을 사용하는 주문형 사례의 변형입니다. 대표적인 예가 재생목록으로 정의된 콘텐츠입니다.

라이브: 라이브 미디어는 지속 시간을 알 수도 있고 알 수 없는 진행 중인 콘텐츠 스트림\(예: 방송 TV\)을 나타냅니다. 검색할 수 없으며 현재 제공되는 콘텐츠에만 액세스할 수 있습니다.

녹화 포함 라이브: 라이브 세션의 콘텐츠를 저장 및 유지하고 이미 녹화된 콘텐츠의 일부 내에서 무작위 액세스 전달을 허용하는 서버측 기능과 결합된 라이브 스트림입니다. 미디어 스트림의 실제 동작은 미디어 스트림의 보존 정책에 따라 크게 달라집니다. 서버가 전체 미디어 스트림을 캡처할 수 있거나 보존할 양에 제한이 있습니다. 미디어 범위는 세션이 진행됨에 따라 동적으로 변경됩니다. 녹화에 사용할 수 있는 저장 용량이 제한된 서버의 경우 일반적으로 새 데이터를 사용할 수 있고 이전 데이터가 삭제되는 동안 앞으로 이동하는 슬라이딩 창이 있습니다.

위의 용도를 처리하기 위해 적절한 값을 가진 다음 미디어 속성이 지정됩니다.

---
#### **4.7.1.  Random Access and Seeking**

무작위 액세스는 콘텐츠 내에서 언제든지\(즉시\) 미디어를 지정하고 전달받을 수 있는 기능으로, "검색"이라고 하는 작업입니다. Media-Properties 헤더는 미디어 리소스가 임의 액세스를 수행하는 일반적인 기능을 나타냅니다.

무작위 접근\(Random-Access\): 미디어는 미디어 내의 수많은 지점 중 어느 지점에서나 검색 가능합니다. 미디어 인코딩 제한으로 인해 특정 지점에 도달하지 못할 수 있지만 가까운 지점 탐색이 가능합니다. 랜덤 액세스 포인트 사이의 최악의 거리를 표현하기 위해 부동 소수점 수\(초\)가 제공될 수 있습니다.

Beginning-Only: 콘텐츠의 시작 부분까지만 검색이 가능합니다.

탐색 없음: 탐색이 전혀 불가능합니다.

Media-Properties 헤더에 표시된 것처럼 임의 액세스가 가능한 경우 검색 시 실제 동작 정책은 Seek-Style 헤더\(18.47절\)를 사용하여 제어할 수 있습니다.

---
#### **4.7.2.  Retention**

미디어에서는 가능한 프로토콜 작업을 제한하기 위해 다음 보존 정책을 사용합니다.

무제한: RTSP 세션이 존재하는 동안 미디어는 제거되지 않습니다.

시간 제한: 지정된 벽시계 시간 이전에는 미디어가 제거되지 않습니다. 그 이후에는 더 이상 사용할 수도 있고 사용하지 못할 수도 있습니다.

시간 기간: 미디어\(조각 또는 단위 기준\)가 지정된 기간 동안 유지됩니다.

---
#### **4.7.3.  Content Modifications**

미디어 콘텐츠와 타임라인은 다양한 유형이 될 수 있습니다. 주문형 사전 제작 콘텐츠, 시간이 지남에 따라 생성되는 라이브 소스, 재생 중에 동적으로 변경되거나 재구성되는 콘텐츠 등이 있습니다. 따라서 컨텐츠 수정을 위한 미디어 속성이 필요하며 다음과 같은 초기값을 정의합니다.

불변: 인코딩이나 품질과 같은 표현이 변경되더라도 미디어의 내용은 변경되지 않습니다.

동적: 재생 목록과 같은 외부 방법이나 트리거로 인해 콘텐츠가 변경될 수 있지만 이는 명시적인 업데이트를 통해 공지됩니다.

시간 진행: 시간이 지남에 따라 새로운 콘텐츠를 사용할 수 있게 됩니다. 콘텐츠도 유지되면 시작 지점과 현재 사용 가능한 지점 사이의 모든 항목에 액세스할 수 있으므로 시간이 더 길어집니다. 미디어 서버가 보존을 위해 슬라이딩 윈도우 정책을 사용하는 경우 시간이 지남에 따라 시작 지점도 변경됩니다.

---
#### **4.7.4.  Supported Scale Factors**

특정 미디어 콘텐츠 항목은 미디어를 전달할 때 제한된 세트 또는 범위의 배율만 지원하는 경우가 많습니다. 클라이언트가 전체 콘텐츠 또는 현재 위치가 지원하는 크기 조정 작업의 값 또는 범위를 알 수 있도록 지원되는 값 또는 범위가 포함된 목록을 포함하는 미디어 속성 속성이 정의됩니다. 속성 이름은 "Scale"입니다. "Scales" 속성은 분할된 조각으로 구성된 콘텐츠 또는 대역 외 메커니즘에 의해 동적으로 업데이트되는 콘텐츠로 인해 콘텐츠의 어느 지점에서나 업데이트될 수 있습니다.

---
#### **4.7.5.  Mapping to the Attributes**

이 섹션에서는 위의 사용법을 속성 및 해당 값에 매핑하는 방법의 예를 보여줍니다.

온디맨드의 예:

- 무작위 액세스: Random-Access=5.0, 콘텐츠 수정: 불변, 보존: 무제한 또는 시간 제한.

동적 온디맨드의 예:

- 무작위 액세스: Random-Access=3.0, 콘텐츠 수정: 동적, 보존: 무제한 또는 시간 제한.

라이브의 예:

- 랜덤 액세스: 탐색 없음, 콘텐츠 수정: 시간-진행, 보유: Time-Duration=0.0

녹음이 포함된 라이브의 예:

- 랜덤 액세스: Random-Access=3.0, 콘텐츠 수정: Time- Progressing, 보유: Time-Duration=7200.0

---
## **5.  RTSP Message**

RTSP는 RFC 3629 \[RFC3629\]에 따라 UTF-8 인코딩의 ISO 10646 문자 집합을 사용하는 텍스트 기반 프로토콜입니다. 라인은 CRLF로 종료되어야 합니다.\(MUST\)

- 텍스트 기반 프로토콜을 사용하면 자체 설명 방식으로 선택적 매개변수를 더 쉽게 추가할 수 있습니다. 매개변수 개수와 명령 빈도가 낮기 때문에 처리 효율성은 문제가 되지 않습니다. 텍스트 기반 프로토콜을 주의 깊게 사용하면 Python, PHP, Perl 및 TCL과 같은 스크립팅 언어로 연구 프로토타입을 쉽게 구현할 수도 있습니다.

ISO 10646 문자 집합은 문자 집합 전환을 방지하지만 US-ASCII가 사용되는 동안에는 응용 프로그램에 표시되지 않습니다. 이는 RTCP \[RFC3550\]의 텍스트 필드에 사용되는 인코딩이기도 합니다.

요청에는 메소드, 메소드가 작동 중인 객체, 메소드를 추가로 설명하는 매개변수가 포함됩니다. 별도로 명시하지 않는 한 메서드는 멱등성을 갖습니다. 또한 방법은 미디어 서버에서 상태 유지 관리가 거의 또는 전혀 필요하지 않도록 설계되었습니다.

---
### **5.1.  Message Types**

RTSP 메시지는 클라이언트에서 서버로 또는 서버에서 클라이언트로의 요청과 반대 방향의 응답입니다. 요청\(Section 7\) 및 응답\(Section 8\) 메시지는 본문\(메시지의 페이로드\)을 전송하기 위해 RFC 5322 \[RFC5322\]의 일반 메시지 형식을 기반으로 하는 형식을 사용합니다. 두 가지 유형의 메시지 모두 시작 줄, 0개 이상의 헤더 필드\("헤더"라고도 함\), 헤더 끝을 나타내는 빈 줄\(예: CRLF 앞에 아무것도 없는 줄\) 및 데이터로 구성됩니다. 메시지 본문의 아래 ABNF \[RFC5234\]는 단지 설명을 위한 것입니다. 형식적인 메시지 사양은 섹션 20.2.2에 나와 있습니다.

```text
   generic-message = start-line
                   *(rtsp-header CRLF)
                     CRLF
                   [ message-body-data ]
   start-line = Request-Line / Status-Line
```

견고성을 위해 에이전트는 요청 라인 또는 상태 라인이 예상되는 수신된 빈 라인을 무시해야 합니다. 즉, 에이전트가 메시지 시작 부분에서 프로토콜 스트림을 읽고 먼저 CRLF를 여러 개 수신하는 경우 모든 CRLF를 무시해야 합니다.\(MUST, MUST\)

---
### **5.2.  Message Headers**

RTSP 헤더 필드\(섹션 18 참조\)에는 일반 헤더, 요청 헤더, 응답 헤더 및 메시지 본문 헤더 필드가 포함됩니다.

필드 이름이 다른 헤더 필드가 수신되는 순서는 중요하지 않습니다. 그러나 일반 헤더 필드를 먼저 보낸 다음 요청 헤더 또는 응답 헤더 필드를 보내고 메시지 본문 헤더 필드로 끝나는 것이 "좋은 습관"입니다.

동일한 field-name을 가진 여러 헤더 필드는 해당 헤더 필드의 전체 field-value가 쉼표로 구분된 목록으로 정의된 경우에만 메시지에 존재할 수 있습니다. 메시지의 의미를 변경하지 않고 여러 헤더 필드를 하나의 "필드-이름: 필드-값" 쌍으로 결합하는 것이 가능해야 하며, 각 후속 필드 값을 첫 번째 필드에 추가하고 각각을 쉼표로 구분해야 합니다. 따라서 동일한 field-name을 가진 헤더 필드가 수신되는 순서는 결합된 필드 값의 해석에 중요합니다. 따라서 프록시는 메시지가 전달될 때 이러한 필드 값의 순서를 변경해서는 안 됩니다.\(MAY, MUST, MUST NOT\)

알 수 없는 메시지 헤더는 RTSP 서버 또는 클라이언트에 의해 무시되어야 합니다\(헤더를 넘어 다음 프로토콜 요소로 건너뛰고 오류를 일으키지 않음\). RTSP 프록시는 알 수 없는 메시지 헤더를 전달해야 합니다. RTSP 에이전트가 해석해야 하는 이 사양 외부에서 정의된 메시지 헤더는 기능 태그\(섹션 4.5\)를 사용해야 하며 이를 적절한 Require\(섹션 18.43\) 또는 Proxy-Require\(섹션 18.37\) 헤더에 포함해야 합니다.\(MUST, MUST\)

---
### **5.3.  Message Body**

RTSP 메시지의 메시지 본문\(있는 경우\)은 요청 또는 응답과 관련된 특정 리소스에 대한 추가 정보를 전달하는 데 사용됩니다. 메시지 본문의 예로는 SDP 메시지가 있습니다.

요청이나 응답에 메시지 본문이 있다는 것은 Content-Length 헤더\(섹션 18.17 참조\)와 Content-Type 헤더\(섹션 18.19 참조\)를 포함하여 표시되어야 합니다. 특정 메서드\(메서드 정의\(섹션 13\) 참조\)의 사양이 메시지 본문 전송을 허용하지 않는 경우 메시지 본문은 요청이나 응답에 포함되어서는 안 됩니다. 예상하지 못한 메시지 본문이 메시지에 수신된 경우, 메시지 본문 데이터는 폐기되어야 합니다. 이는 향후 확장에서 메시지 본문의 선택적 사용을 정의할 수 있도록 하기 위한 것입니다.\(MUST, MUST NOT, SHOULD\)

---
### **5.4.  Message Length**

메시지 본문이 포함되지 않은 RTSP 메시지는 헤더 필드 뒤의 첫 번째 빈 줄로 종료됩니다\(참고: 빈 줄은 CRLF 앞에 아무것도 없는 줄입니다.\). 메시지 본문이 포함된 RTSP 메시지에서는 빈 줄 뒤에 메시지 본문이 옵니다. 해당 본문의 길이는 Content-Length 헤더\(섹션 18.17\)의 값에 따라 결정됩니다. 헤더의 값은 메시지 본문의 길이\(옥텟\)를 나타냅니다. 이 헤더 필드가 없으면 값은 0으로 간주됩니다. 즉, 메시지에 메시지 본문이 없는 것입니다. HTTP 메시지와 달리 RTSP 메시지는 메시지 본문이 포함될 때마다 Content-Length 헤더를 포함해야 합니다. RTSP는 HTTP/1.1 "청크" 전송 코딩을 지원하지 않습니다\(\[RFC7230\]의 섹션 4.1 참조\).\(MUST\)

- 반환된 프리젠테이션 설명의 적당한 길이가 주어지면 서버는 동적으로 생성되더라도 항상 길이를 결정할 수 있어야 하므로 청크 분할 전송 인코딩이 필요하지 않습니다.

---
## **6.  General-Header Fields**

일반 헤더는 요청과 응답 모두에 사용될 수 있는 헤더입니다. 일반 헤더는 표 1에 나열되어 있습니다.

```text
                  +--------------------+----------------+
                  | Header Name        | Defined in     |
                  +--------------------+----------------+
                  | Accept-Ranges      | Section 18.5   |
                  |                    |                |
                  | Cache-Control      | Section 18.11  |
                  |                    |                |
                  | Connection         | Section 18.12  |
                  |                    |                |
                  | CSeq               | Section 18.20  |
                  |                    |                |
                  | Date               | Section 18.21  |
                  |                    |                |
                  | Media-Properties   | Section 18.29  |
                  |                    |                |
                  | Media-Range        | Section 18.30  |
                  |                    |                |
                  | Pipelined-Requests | Section 18.33  |
                  |                    |                |
                  | Proxy-Supported    | Section 18.38  |
                  |                    |                |
                  | Range              | Section 18.40  |
                  |                    |                |
                  | RTP-Info           | Section 18.45  |
                  |                    |                |
                  | Scale              | Section 18.46  |
                  |                    |                |
                  | Seek-Style         | Section 18.47  |
                  |                    |                |
                  | Server             | Section 18.48  |
                  |                    |                |
                  | Session            | Section 18.49  |
                  |                    |                |
                  | Speed              | Section 18.50  |
                  |                    |                |
                  | Supported          | Section 18.51  |
                  |                    |                |
                  | Timestamp          | Section 18.53  |
                  |                    |                |
                  | Transport          | Section 18.54  |
                  |                    |                |
                  | User-Agent         | Section 18.56  |
                  |                    |                |
                  | Via                | Section 18.57  |
                  +--------------------+----------------+

                 Table 1: The General Headers Used in RTSP
```

---
## **7.  Request**

요청 메시지는 클라이언트에서 서버로 또는 서버에서 클라이언트로 요청 방향에 관계없이 아래에 설명된 형식을 사용합니다.

```text
   o  Request line, containing the method to be applied to the resource,
      the identifier of the resource, and the protocol version in use;

   o  Zero or more Header lines, which can be of the following types:
      general-headers (Section 6), request-headers (Section 7.2), or
      message body headers (Section 9.1);

   o  One empty line (CRLF) to indicate the end of the header section;
```

o 선택적으로 하나 이상의 줄로 구성된 메시지 본문. 옥텟 단위의 메시지 본문 길이는 Content-Length 메시지 헤더로 표시됩니다.

---
### **7.1.  Request Line**

요청 라인은 요청에 대한 주요 정보\(방법, 리소스, RTSP 버전 사용\)를 제공합니다. 본 사양에서 정의한 방법은 표 2에 나열되어 있습니다.

```text
                    +---------------+----------------+
                    | Method        | Defined in     |
                    +---------------+----------------+
                    | DESCRIBE      | Section 13.2   |
                    |               |                |
                    | GET_PARAMETER | Section 13.8   |
                    |               |                |
                    | OPTIONS       | Section 13.1   |
                    |               |                |
                    | PAUSE         | Section 13.6   |
                    |               |                |
                    | PLAY          | Section 13.4   |
                    |               |                |
                    | PLAY_NOTIFY   | Section 13.5   |
                    |               |                |
                    | REDIRECT      | Section 13.10  |
                    |               |                |
                    | SETUP         | Section 13.3   |
                    |               |                |
                    | SET_PARAMETER | Section 13.9   |
                    |               |                |
                    | TEARDOWN      | Section 13.7   |
                    +---------------+----------------+

                         Table 2: The RTSP Methods
```

RTSP 요청 라인의 구문은 다음과 같습니다.

```text
      <Method> SP <Request-URI> SP <RTSP-Version> CRLF
```

참고: 이 구문은 RTSP의 향후 버전에서 자유롭게 변경할 수 없습니다. 이 줄은 메시지의 RTSP 버전을 나타내기 때문에 이전 RTSP 구현에서 구문 분석 가능한 상태로 유지되어야 합니다.

HTTP/1.1 \[RFC7230\]과 달리 RTSP 요청은 절대 경로가 아닌 절대 RTSP URI\(구성표, 호스트 및 포트 포함\)\(섹션 4.2 참조\)를 통해 리소스를 식별합니다.

- HTTP/1.1에서는 서버가 절대 URI를 이해해야 하지만 클라이언트는 호스트 요청 헤더를 사용해야 합니다. 이는 순전히 HTTP/1.0 서버와의 하위 호환성을 위해 필요하며 RTSP에는 적용되지 않는 고려 사항입니다.

Request-URI 부분에서 절대 URI 대신 별표 "\*"를 사용하여 요청이 특정 리소스가 아닌 서버 또는 프록시 자체에 적용되고 요청 방법이 반드시 필요하지 않은 경우에만 허용됨을 나타낼 수 있습니다. 자원에 적용합니다.

예를 들어:

```text
      OPTIONS * RTSP/2.0
```

이 형식의 OPTIONS는 요청을 처음 수신하는 서버 또는 프록시의 기능을 결정합니다. 개입하는 프록시의 기능에 관계없이 특정 서버의 기능을 결정해야 하는 경우 서버 주소가 포함된 절대 URI를 사용하여 서버 주소를 명시적으로 지정해야 합니다.

예를 들어:

```text
      OPTIONS rtsp://example.com RTSP/2.0
```

---
### **7.2.  Request-Header Fields**

표 3의 RTSP 헤더는 요청의 세부 사항을 수정하기 위해 요청 헤더로 요청에 포함될 수 있습니다.

```text
                 +---------------------+----------------+
                 | Header              | Defined in     |
                 +---------------------+----------------+
                 | Accept              | Section 18.1   |
                 |                     |                |
                 | Accept-Credentials  | Section 18.2   |
                 |                     |                |
                 | Accept-Encoding     | Section 18.3   |
                 |                     |                |
                 | Accept-Language     | Section 18.4   |
                 |                     |                |
                 | Authorization       | Section 18.8   |
                 |                     |                |
                 | Bandwidth           | Section 18.9   |
                 |                     |                |
                 | Blocksize           | Section 18.10  |
                 |                     |                |
                 | From                | Section 18.23  |
                 |                     |                |
                 | If-Match            | Section 18.24  |
                 |                     |                |
                 | If-Modified-Since   | Section 18.25  |
                 |                     |                |
                 | If-None-Match       | Section 18.26  |
                 |                     |                |
                 | Notify-Reason       | Section 18.32  |
                 |                     |                |
                 | Proxy-Authorization | Section 18.36  |
                 |                     |                |
                 | Proxy-Require       | Section 18.37  |
                 |                     |                |
                 | Referrer            | Section 18.41  |
                 |                     |                |
                 | Request-Status      | Section 18.42  |
                 |                     |                |
                 | Require             | Section 18.43  |
                 |                     |                |
                 | Terminate-Reason    | Section 18.52  |
                 +---------------------+----------------+
```

- 표 3: RTSP 요청 헤더

자세한 헤더 정의는 섹션 18에 나와 있습니다.

새로운 요청 헤더가 정의될 ​​수 있습니다. 요청 수신자가 요청 헤더를 이해해야 하는 경우 요청은 헤더 처리를 보장하기 위해 Require 또는 Proxy-Require 헤더에 해당 기능 태그를 포함해야 합니다.\(MUST\)

---
## **8.  Response**

요청 메시지를 수신하고 해석한 후 수신자는 RTSP 응답 메시지로 응답합니다. 일반적으로 최종 응답은 하나만 있습니다. 응답 코드 클래스 1xx를 사용하는 응답은 최종 응답 메시지 이전에 하나 이상의 응답을 보낼 수 있는 유일한 클래스입니다.\(MAY\)

유효한 응답 코드와 함께 사용할 수 있는 방법은 표 4에 나열되어 있습니다.

---
### **8.1.  Status-Line**

응답 메시지의 첫 번째 줄은 프로토콜 버전, 숫자 상태 코드, 상태 코드와 관련된 텍스트 문구로 구성된 상태 줄입니다. 각 요소는 SP 문자로 구분됩니다. 최종 CRLF 시퀀스를 제외하고 CR 또는 LF는 허용되지 않습니다.

```text
   <RTSP-Version> SP <Status-Code> SP <Reason Phrase> CRLF
```

---
#### **8.1.1.  Status Code and Reason Phrase**

Status-Code 요소는 요청을 이해하고 만족시키려는 시도의 3자리 정수 결과 코드입니다. 이러한 코드는 섹션 17에 완전히 정의되어 있습니다. 이유 문구는 상태 코드에 대한 간단한 텍스트 설명을 제공하기 위한 것입니다. 상태 코드는 오토마타에서 사용하기 위한 것이며 이유 문구는 인간 사용자를 위한 것입니다. 클라이언트는 이유 문구를 검사하거나 표시할 필요가 없습니다.

상태 코드의 첫 번째 숫자는 응답 클래스를 정의합니다. 마지막 두 자리에는 분류 역할이 없습니다. 첫 번째 숫자에는 5개의 값이 있습니다.

```text
   1xx:  Informational - Request received, continuing process
```

2xx: 성공 - 작업이 성공적으로 수신되고 이해되었으며 수락되었습니다.

```text
   3rr:  Redirection - Further action needs to be taken in order to
         complete the request (3rr rather than 3xx is used as 304 is
         excluded; see Section 17.3)
```

4xx: 클라이언트 오류 - 요청에 잘못된 구문이 포함되어 있거나 처리할 수 없습니다.

5xx: 서버 오류 - 서버가 명백히 유효한 요청을 이행하지 못했습니다.

RTSP 2.0에 대해 정의된 숫자 상태 코드의 개별 값과 해당 이유 문구 세트의 예가 표 4에 나와 있습니다. 여기에 나열된 이유 문구는 권장 사항일 뿐입니다. 프로토콜에 영향을 주지 않고 지역적으로 동등한 것으로 대체될 수 있습니다. RTSP는 대부분의 HTTP/1.1 \[RFC2068\] 상태 코드를 채택한 다음 x50에서 시작하는 RTSP 관련 상태 코드를 추가하여 RTSP로 가져오는 것이 바람직한 향후 HTTP 상태 코드와의 충돌을 방지합니다. 이러한 모든 코드는 RTSP에 따라 다르며 RTSP에는 상태 코드에 대해 HTTP와 별도의 자체 레지스트리가 있습니다.

RTSP 상태 코드는 확장 가능합니다. RTSP 응용 프로그램은 등록된 모든 상태 코드의 의미를 이해할 필요는 없지만, 그러한 이해가 분명히 바람직합니다. 그러나 애플리케이션은 첫 번째 숫자로 표시된 모든 상태 코드의 클래스를 이해해야 하며, 인식할 수 없는 모든 응답을 해당 클래스의 x00 상태 코드와 동일한 것으로 처리해야 합니다. 단, 알 수 없는 3xx 코드는 예외로 처리해야 합니다. 302\(발견됨\). 해당 예외가 발생하는 이유는 상태 코드 300\(HTTP의 다중 선택\)이 RTSP에 대해 정의되지 않았기 때문입니다. 인식할 수 없는 상태 코드가 있는 응답은 캐시되어서는 안 됩니다. 예를 들어, 클라이언트가 인식할 수 없는 상태 코드 431을 수신하면 요청에 문제가 있다고 안전하게 가정하고 응답을 400 상태 코드를 수신한 것처럼 처리할 수 있습니다. 그러한 경우, 사용자 에이전트는 응답과 함께 반환된 메시지 본문을 사용자에게 제시해야 합니다. 왜냐하면 해당 메시지 본문에는 비정상적인 상태를 설명하는 사람이 읽을 수 있는 정보가 포함될 가능성이 높기 때문입니다.\(MUST, MUST NOT, SHOULD\)

```text
   +------+---------------------------------+--------------------------+
   | Code | Reason                          | Method                   |
   +------+---------------------------------+--------------------------+
   | 100  | Continue                        | all                      |
   |      |                                 |                          |
   | 200  | OK                              | all                      |
   |      |                                 |                          |
   | 301  | Moved Permanently               | all                      |
   |      |                                 |                          |
   | 302  | Found                           | all                      |
   |      |                                 |                          |
   | 303  | See Other                       | n/a                      |
   |      |                                 |                          |
   | 304  | Not Modified                    | all                      |
   |      |                                 |                          |

   | 305  | Use Proxy                       | all                      |
   |      |                                 |                          |
   | 400  | Bad Request                     | all                      |
   |      |                                 |                          |
   | 401  | Unauthorized                    | all                      |
   |      |                                 |                          |
   | 402  | Payment Required                | all                      |
   |      |                                 |                          |
   | 403  | Forbidden                       | all                      |
   |      |                                 |                          |
   | 404  | Not Found                       | all                      |
   |      |                                 |                          |
   | 405  | Method Not Allowed              | all                      |
   |      |                                 |                          |
   | 406  | Not Acceptable                  | all                      |
   |      |                                 |                          |
   | 407  | Proxy Authentication Required   | all                      |
   |      |                                 |                          |
   | 408  | Request Timeout                 | all                      |
   |      |                                 |                          |
   | 410  | Gone                            | all                      |
   |      |                                 |                          |
   | 412  | Precondition Failed             | DESCRIBE, SETUP          |
   |      |                                 |                          |
   | 413  | Request Message Body Too Large  | all                      |
   |      |                                 |                          |
   | 414  | Request-URI Too Long            | all                      |
   |      |                                 |                          |
   | 415  | Unsupported Media Type          | all                      |
   |      |                                 |                          |
   | 451  | Parameter Not Understood        | SET_PARAMETER,           |
   |      |                                 | GET_PARAMETER            |
   |      |                                 |                          |
   | 452  | reserved                        | n/a                      |
   |      |                                 |                          |
   | 453  | Not Enough Bandwidth            | SETUP                    |
   |      |                                 |                          |
   | 454  | Session Not Found               | all                      |
   |      |                                 |                          |
   | 455  | Method Not Valid in This State  | all                      |
   |      |                                 |                          |
   | 456  | Header Field Not Valid for      | all                      |
   |      | Resource                        |                          |
   |      |                                 |                          |
   | 457  | Invalid Range                   | PLAY, PAUSE              |
   |      |                                 |                          |
   | 458  | Parameter Is Read-Only          | SET_PARAMETER            |
   |      |                                 |                          |

   | 459  | Aggregate Operation Not Allowed | all                      |
   |      |                                 |                          |
   | 460  | Only Aggregate Operation        | all                      |
   |      | Allowed                         |                          |
   |      |                                 |                          |
   | 461  | Unsupported Transport           | all                      |
   |      |                                 |                          |
   | 462  | Destination Unreachable         | all                      |
   |      |                                 |                          |
   | 463  | Destination Prohibited          | SETUP                    |
   |      |                                 |                          |
   | 464  | Data Transport Not Ready Yet    | PLAY                     |
   |      |                                 |                          |
   | 465  | Notification Reason Unknown     | PLAY_NOTIFY              |
   |      |                                 |                          |
   | 466  | Key Management Error            | all                      |
   |      |                                 |                          |
   | 470  | Connection Authorization        | all                      |
   |      | Required                        |                          |
   |      |                                 |                          |
   | 471  | Connection Credentials Not      | all                      |
   |      | Accepted                        |                          |
   |      |                                 |                          |
   | 472  | Failure to Establish Secure     | all                      |
   |      | Connection                      |                          |
   |      |                                 |                          |
   | 500  | Internal Server Error           | all                      |
   |      |                                 |                          |
   | 501  | Not Implemented                 | all                      |
   |      |                                 |                          |
   | 502  | Bad Gateway                     | all                      |
   |      |                                 |                          |
   | 503  | Service Unavailable             | all                      |
   |      |                                 |                          |
   | 504  | Gateway Timeout                 | all                      |
   |      |                                 |                          |
   | 505  | RTSP Version Not Supported      | all                      |
   |      |                                 |                          |
   | 551  | Option Not Supported            | all                      |
   |      |                                 |                          |
   | 553  | Proxy Unavailable               | all                      |
   +------+---------------------------------+--------------------------+

          Table 4: Status Codes and Their Usage with RTSP Methods
```

---
### **8.2.  Response Headers**

응답 헤더를 사용하면 요청 수신자가 상태 표시줄에 배치할 수 없는 응답에 대한 추가 정보를 전달할 수 있습니다. 이 헤더는 서버에 대한 정보와 Request-URI로 식별된 리소스에 대한 추가 액세스에 대한 정보를 제공합니다. 현재 응답 헤더로 분류된 모든 헤더는 표 5에 나열되어 있습니다.

```text
                +------------------------+----------------+
                | Header                 | Defined in     |
                +------------------------+----------------+
                | Authentication-Info    | Section 18.7   |
                |                        |                |
                | Connection-Credentials | Section 18.13  |
                |                        |                |
                | Location               | Section 18.28  |
                |                        |                |
                | MTag                   | Section 18.31  |
                |                        |                |
                | Proxy-Authenticate     | Section 18.34  |
                |                        |                |
                | Public                 | Section 18.39  |
                |                        |                |
                | Retry-After            | Section 18.44  |
                |                        |                |
                | Unsupported            | Section 18.55  |
                |                        |                |
                | WWW-Authenticate       | Section 18.58  |
                +------------------------+----------------+

                    Table 5: The RTSP Response Headers
```

응답 헤더 이름은 프로토콜 버전이 변경되는 경우에만 안정적으로 확장될 수 있습니다. 그러나 요청에 기능 태그를 사용하면 응답 당사자가 응답 수신자의 기능을 알 수 있습니다. 통신의 모든 당사자가 이를 응답 헤더로 인식하는 경우 새 헤더 또는 실험적 헤더에 응답 헤더의 의미가 부여될 수 있습니다. 응답에서 인식할 수 없는 헤더는 무시해야 합니다.\(MUST\)

---
## **9.  Message Body**

일부 요청 및 응답 메시지에는 요청 메서드나 응답 상태 코드에 의해 달리 제한되지 않는 한 메시지 본문이 포함됩니다. 메시지 본문은 콘텐츠 데이터 자체로 구성됩니다\(섹션 5.3 참조\).

SET\_PARAMETER 및 GET\_PARAMETER 요청과 응답, 그리고 이 사양에 정의된 DESCRIBE 응답에는 메시지 본문이 있을 수 있습니다. 메시지 본문의 목적은 각 경우에 정의됩니다. 모든 4xx 및 5xx 응답에는 추가 응답 정보를 전달하는 메시지 본문이 있을 수도 있습니다. 일반적으로 메시지 본문은 RTSP 2.0 요청이나 응답에 첨부될 수 있지만 메시지 본문의 내용은 수신자에 의해 무시될 수 있습니다. 이 사양에 대한 확장은 포함 요구를 포함하여 메시지 본문의 목적과 내용을 지정할 수 있습니다.\(MAY, MAY\)

이 섹션에서 보낸 사람과 받는 사람은 모두 메시지 본문을 보내고 받는 사람에 따라 클라이언트나 서버를 나타냅니다.

---
### **9.1.  Message Body Header Fields**

메시지 본문 헤더 필드는 메시지 본문의 콘텐츠 데이터에 대한 메타정보를 정의합니다. 메시지 본문 헤더 필드는 표 6에 나열되어 있습니다.

```text
                   +------------------+----------------+
                   | Header           | Defined in     |
                   +------------------+----------------+
                   | Allow            | Section 18.6   |
                   |                  |                |
                   | Content-Base     | Section 18.14  |
                   |                  |                |
                   | Content-Encoding | Section 18.15  |
                   |                  |                |
                   | Content-Language | Section 18.16  |
                   |                  |                |
                   | Content-Length   | Section 18.17  |
                   |                  |                |
                   | Content-Location | Section 18.18  |
                   |                  |                |
                   | Content-Type     | Section 18.19  |
                   |                  |                |
                   | Expires          | Section 18.22  |
                   |                  |                |
                   | Last-Modified    | Section 18.27  |
                   +------------------+----------------+
```

- 표 6: RTSP 메시지 본문 헤더

확장 헤더 메커니즘을 사용하면 프로토콜을 변경하지 않고도 추가 메시지 본문 헤더 필드를 정의할 수 있지만 이러한 필드를 수신자가 인식할 수 있다고 가정할 수는 없습니다. 인식할 수 없는 헤더 필드는 수신자가 무시하고 프록시에 의해 전달되어야 합니다.\(MUST\)

---
### **9.2.  Message Body**

메시지 본문이 있는 RTSP 메시지에는 Content-Type 및 Content-Length 헤더가 포함되어야 합니다. 메시지 본문이 메시지에 포함된 경우 해당 콘텐츠 데이터의 데이터 유형은 Content-Type 및 Content-Encoding 헤더 필드를 통해 결정됩니다.\(MUST\)

Content-Type은 기본 데이터의 미디어 유형을 지정합니다. 기본 미디어 형식은 없으며 본문에 사용되는 실제 형식은 Content-Type 헤더에 명시적으로 명시되어야 합니다. 명시적이고 항상 정확한 정보와 함께 Content-Type 헤더를 포함하도록 요구함으로써 본문 콘텐츠에 대한 경험적 기반 해석에서 많은 함정을 피할 수 있습니다. HTTP와 이메일의 사용자 경험은 이러한 경험적 방법에 의존함으로써 어려움을 겪었습니다.

Content-Encoding은 일반적으로 데이터 압축을 위해 요청된 리소스의 속성인 데이터에 적용되는 추가 콘텐츠 코딩을 나타내는 데 사용될 수 있습니다. 기본 인코딩은 'identity'입니다. 즉, 메시지 본문이 변환되지 않습니다.

메시지의 Content-Length는 옥텟 단위로 측정된 콘텐츠의 길이입니다.

---
### **9.3.  Message Body Format Negotiation**

메시지 본문의 콘텐츠 형식은 Content-Type 헤더\(섹션 18.19\)를 사용하여 제공됩니다. 요청의 응답자가 사용해야 하는 미디어 유형을 결정할 수 있도록 요청자는 지원되는 미디어 유형 또는 응답에 적합한 미디어 유형 범위를 식별하기 위해 요청에 Accept 헤더\(18.1절\)를 포함할 수 있습니다. 응답자가 지정된 형식을 지원하지 않는 경우 요청 응답은 406\(허용되지 않음\) 오류 코드가 됩니다.

메시지 본문이 있는 요청에 사용될 수 있는 미디어 유형은 기능 태그, 사양 요구 사항 또는 시행 착오를 통해 결정되어야 합니다. 응답자가 메시지 본문의 미디어 유형을 지원하지 않으면 415\(지원되지 않는 미디어 유형\)로 응답하기 때문에 시행착오가 작동합니다.

지원되는 형식과 해당 협상은 메서드 및 방향\(요청 또는 응답 본문\)별로 개별적으로 수행됩니다. 요청 및 응답의 메시지 본문으로 사용하기 위한 특정 미디어 유형 지원에 대한 요구 사항도 방법별 및 방향별로 지정되어야 합니다.\(MUST\)

---
## **10.  Connections**

RTSP 메시지는 전송 연결을 사용하여 RTSP 에이전트와 프록시 간에 전송됩니다. 이 전송 연결은 TCP 또는 TCP/TLS를 사용합니다. 이 전송 연결을 이 문서에서는 "연결" 또는 "RTSP 연결"이라고 합니다.

RTSP 요청은 아래 나열된 두 가지 연결 시나리오를 사용하여 전송될 수 있습니다.

```text
   o  persistent - a transport connection is used for several request/
      response transactions;
```

o 일시적 - 각 단일 요청/응답 트랜잭션에 전송 연결이 사용됩니다.

RFC 2326은 UDP와 같은 전송 프로토콜을 통해 비연결 모드에서 RTSP 메시지를 전송하기 위한 선택적 메커니즘을 지정하려고 시도했습니다. 그러나 상호 운용 가능한 구현을 허용할 만큼 자세하게 지정되지 않았습니다. 복잡성과 범위를 줄이기 위한 시도와 관심 부족으로 인해 RTSP 2.0은 UDP 또는 기타 비연결 전송 프로토콜을 통한 RTSP 지원 메커니즘을 정의하려고 시도하지 않습니다. 이것의 부작용은 멀티캐스트 환경에서 특정 수신기와 연결을 설정할 수 없기 때문에 RTSP 요청을 멀티캐스트 그룹으로 전송해서는 안 된다는 것입니다.\(MUST NOT\)

비연결 전송 시나리오에만 관련된 것처럼 보일 수 있는 CSeq 헤더\(18.20절\)와 같은 특정 RTSP 헤더는 여전히 유지되며 이 사양에 따라 구현되어야 합니다. CSeq의 경우 요청이 파이프라인인 경우 요청에 대한 응답을 일치시키는 데 매우 유용합니다\(섹션 12 참조\). 또한 단일 TCP 연결에서 여러 클라이언트 요청을 집계할 때 다양한 요청을 추적하는 프록시에 유용합니다.\(MUST\)

---
### **10.1.  Reliability and Acknowledgements**

RTSP 메시지는 신뢰할 수 있는 전송 프로토콜을 사용하여 전송되므로 RTSP 수준에서 재전송하면 안 됩니다. 대신 구현은 기본 전송에 의존해야 합니다.\(MUST NOT\)

신뢰성을 제공합니다. RTSP 구현은 기본 전송 프로토콜로부터 메시지 수신 확인 표시를 사용하여 RTSP 동작을 최적화할 수 있습니다.

- TCP와 같은 기본 신뢰할 수 있는 전송과 RTSP 애플리케이션이 모두 요청을 재전송하는 경우 각 패킷 손실 또는 메시지 손실로 인해 두 번의 재전송이 발생할 수 있습니다. 첫 번째 시도가 수신기에 도달하기 전에는 전송 스택이 애플리케이션 계층 재전송을 전달하지 않기 때문에 일반적으로 수신기는 애플리케이션 계층 재전송을 활용할 수 없습니다. 혼잡으로 인해 패킷 손실이 발생한 경우 서로 다른 계층에서 여러 번 재전송하면 혼잡이 악화됩니다.

RTSP 요청에 대한 승인 부족은 아래 설명된 연결 시간 초과 고려 사항의 제약 조건 내에서 처리되어야 합니다\(섹션 10.4\).

---
### **10.2.  Using Connections**

TCP 전송은 영구 연결\(여러 메시지 교환용\)과 임시 연결\(단일 메시지 교환용\) 모두에 사용될 수 있습니다. 이 사양의 구현은 TCP를 통한 RTSP를 지원해야 합니다. RTSP URI 체계\(섹션 4.2\)를 통해 클라이언트는 서버에 접속할 포트를 지정할 수 있으며, 명시적으로 지정되지 않은 경우 사용할 기본 포트를 정의합니다.\(MUST\)

등록된 기본 포트\(예: 554\(rtsp\) 및 322\(rtsp\)\) 외에도 대체 포트 8554가 등록되어 있습니다. RTSP 서버가 기본 포트를 사용할 수 없는 경우 이 포트는 등록되지 않은 포트에 비해 몇 가지 이점을 제공할 수 있습니다. 이점에는 사전 구성된 보안 정책은 물론 네트워크 모니터링 도구의 분류자가 포함될 수 있습니다.

URI로 식별되는 특정 리소스에 액세스하기 위해 TCP 연결을 여는 RTSP 클라이언트는 URI의 호스트 및 포트 부분에서 파생된 IP 주소와 포트를 사용합니다. IP 주소는 URI에 제공된 명시적 주소이거나 URI에서 호스트 이름의 A 및 AAAA 레코드 DNS 조회를 수행할 때 제공된 주소 중 하나입니다.

서버는 영구 연결과 임시 연결을 모두 처리해야 합니다.\(MUST\)

- 일시적인 연결은 내결함성을 위한 메커니즘을 촉진합니다. 또한 애플리케이션 계층 이동성을 허용합니다. 임시 연결을 지원하는 서버-클라이언트 쌍은

- TCP 연결이 끊어졌습니다. 예를 들어 NAT 시간 초과로 인해 발생합니다. 클라이언트가 TCP 연결이 끊어진 것을 발견하면 다시 통신해야 할 때 새 연결을 설정할 수 있습니다.

여러 RTSP 세션에 대한 메시지를 포함하여 서버와 클라이언트 간의 모든 트랜잭션에 영구 연결을 사용하는 것이 좋습니다. 그러나 몇 번의 메시지 교환 후에는 지속적인 연결이 닫힐 수 있습니다. 예를 들어, 클라이언트는 세션에서 초기 SETUP 및 PLAY 메시지 교환을 위해 영구 연결을 사용한 다음 연결을 닫을 수 있습니다. 나중에 클라이언트가 세션에 대한 PAUSE와 같은 새 요청을 보내려고 하면 새 연결이 열립니다. 이 연결은 일시적이거나 지속적일 수 있습니다.\(SHOULD, MAY\)

RTSP 에이전트는 하나의 연결을 사용하여 동일한 서버에서 여러 RTSP 세션을 처리할 수 있습니다. RTSP 에이전트는 특정 지점에서 RTSP 세션당 둘 이상의 연결을 사용해서는 안 됩니다.\(MAY, MUST NOT\)

- 언제든지 하나의 연결만 사용하면 서버-클라이언트 요청이 어떤 연결로 전송되어야 하는지에 대한 혼란을 피할 수 있습니다. 여러 RTSP 세션에 대해 단일 연결을 사용하면 서버가 서버의 연결 리소스에 대해 더 적은 상태를 유지할 수 있으므로 복잡성이 줄어듭니다. 특정 RTSP 세션에 대해 한 번에 두 개 이상의 연결을 사용하지 않으면 연결 리소스 낭비를 방지하고 서버가 각 RTSP 세션에 대해 가장 최근에 사용된 클라이언트-서버 연결만 현재 유효한 서버-클라이언트 연결로 추적할 수 있습니다. .

RTSP를 사용하면 서버가 클라이언트에 요청을 보낼 수 있습니다. 그러나 이는 클라이언트가 서버와 지속적인 연결을 설정하는 경우에만 지원될 수 있습니다. 서버와 클라이언트 사이에 지속적인 연결이 존재하지 않는 경우 신호 채널 부족으로 인해 서버는 강제로 RTSP 메시지를 자동으로 폐기할 수 있으며 클라이언트에 알리지 않고 RTSP 세션을 삭제할 수도 있습니다. 이러한 경우의 예로는 서버가 RTSP 세션에 대한 REDIRECT 요청을 클라이언트에 보내려고 하지만 클라이언트에 도달할 수 없기 때문에 그렇게 할 수 없는 경우입니다. 현재 서버에 연결되어 있지 않은 클라이언트에 요청을 보내려고 시도하는 서버는 요청을 폐기해야 합니다.\(MUST\)

- 클라이언트와 서버 간의 지속적인 연결이 없으면 미디어 서버가 클라이언트에 연결할 수 있는 안정적인 방법이 없습니다. 서버-클라이언트 연결 설정이 실패할 가능성이 높기 때문에 서버는 연결 설정을 시도조차 하지 않습니다.

서버-클라이언트 요청 대기열 처리가 고려되었습니다.

- 그러나 클라이언트가 보류 중인 요청과 관련된 요청을 먼저 발행하지 않고 특정 RTSP 세션과 관련된 요청의 합법적인 수신자로 새로운 연결을 설정하는 클라이언트에 권한을 부여하는 것이 어떻게 가능한지에 대한 보안 문제가 존재합니다. 따라서 그러한 요청은 더욱 지연되고 유용성이 떨어지게 될 가능성이 높습니다.

클라이언트 및 서버 요청 전송은 비동기 이벤트일 수 있습니다. 교착 상태를 방지하려면 클라이언트와 서버 모두 동시에 요청을 보내고 받을 수 있어야 합니다. RTSP 응답은 피어 RTSP 에이전트 자체 요청 뒤에 전송, 수신 또는 처리를 위해 대기열에 추가될 수 있으므로 모든 RTSP 에이전트는 처리되지 않은 메시지를 처리하는 특정 기능을 보유해야 합니다. 잠재적인 문제는 피어가 처리했음에도 불구하고 처리되지 않은 요청이 시간 초과될 수 있다는 것입니다. 이는 RTSP 에이전트가 처리 중이지만 완료하는 데 시간이 걸리는 여러 요청 뒤의 대기열에 응답이 있기 때문일 수 있습니다. 이 문제를 방지하려면 RTSP 에이전트는 모든 응답 메시지가 수신 즉시 처리될 수 있도록 들어오는 메시지를 로컬로 버퍼링해야 합니다. 응답이 요청과 분리되어 처리를 위해 직접 전달되는 경우 결과를 즉시 사용할 수 있을 뿐만 아니라 해당 미해결 요청과 관련된 상태도 해제될 수 있습니다. 그러나 수신 RTSP 에이전트에서 여러 요청을 버퍼링하면 리소스가 소비되고 에이전트에 대한 리소스 고갈 공격이 가능해집니다. 따라서 이 버퍼는 불합리한 요청 수나 전체 메시지 크기가 수신 에이전트의 자원을 소비하는 것을 허용하지 않도록 제한되어야 합니다. 대부분의 API에서 수신 에이전트가 TCP 소켓 읽기를 중지하면 TCP 창이 고정되어 부하가 예상보다 클 때 송신 에이전트에 버퍼링이 강제로 적용됩니다. 그러나 RTSP 메시지 크기와 빈도는 향후 프로토콜 확장에 따라 변경될 수 있으므로 에이전트는 잠재적인 공격에 대해 더 엄격한 측정을 수행하는 데 주의해야 합니다. 공격을 받으면 RTSP 에이전트는 TCP 연결을 닫고 해당 TCP 연결과 관련된 상태를 해제할 수 있습니다.\(MUST\)

무엇이 합리적인지에 대한 지침을 제공하기 위해 다음 지침이 제공됩니다. 다음을 권장합니다:\(SHOULD\)

```text
   o  an RTSP agent should not have more than 10 outstanding requests
      per RTSP session;
```

o RTSP 에이전트에는 RTSP 세션과 관련되지 않거나 RTSP 세션 생성을 요청하는 미해결 요청이 10개 이상 있어서는 안 됩니다.

위의 내용을 고려하여 클라이언트는 가능할 때마다 지속적인 연결을 사용하는 것이 좋습니다. 지속적인 연결을 지원하는 클라이언트는 요청을 "파이프라인"할 수 있습니다\(섹션 12 참조\).\(SHOULD, MAY\)

RTSP 에이전트는 프록시에 대한 동일한 연결을 통해 서버 또는 클라이언트 컨텍스트 등 여러 다른 대상으로 요청을 보낼 수 있습니다. 그런 다음 프록시는 프록시-에이전트 연결을 통해 메시지를 다른 대상으로 분기합니다. 여러 요청이 처리되지 않은 경우 요청 에이전트는 연결에서 보낸 순서와 비교하여 순서가 다른 응답을 수신할 준비가 되어 있어야 합니다. 각 대상에 대한 여러 메시지 간의 순서는 유지됩니다. 그러나 다른 대상의 응답 순서는 다를 수 있습니다.\(MUST\)

- 그 이유는 헤드 오브 라인 블로킹 상황을 피하기 위함입니다. 일련의 요청에서 초기 미해결 요청이 하나의 대상에서 처리되는 데 시간이 걸릴 수 있습니다. 동시에 요청 순서에서 나중에 나온 다른 대상의 응답이 프록시에 도착했을 수 있습니다. 따라서 순서가 잘못된 응답을 허용하면 프록시가 이 응답을 버퍼링하도록 강제하지 않고 대신 가능한 한 빨리 전달합니다. 이는 각 개별 대상으로 전송된 메시지가 요청 대상에서 처리되는 순서에 영향을 미치지 않습니다.

이 시나리오는 프록시와 관련된 두 가지 경우에 발생할 수 있습니다. 첫 번째는 클라이언트가 공통 클라이언트-프록시 연결을 사용하여 다른 서버의 세션에 대한 요청을 보내는 것입니다. 두 번째는 프록시가 다른 연결 클라이언트를 위해 생성한 공통 전송 연결을 통해 서버에서 보내는 REDIRECT와 같은 서버-클라이언트 요청을 위한 것입니다.

---
### **10.3.  Closing Connections**

클라이언트는 연결을 통해 관리되는 RTSP 세션에 대해 처리되지 않은 요청/응답 트랜잭션이 없을 때 언제든지 연결을 닫을 수 있습니다. 그러나 서버는 연결을 통해 관리되는 모든 RTSP 세션이 시간 초과될 때까지 연결을 닫아서는 안 됩니다\(18.49절\). 서버는 연결을 통해 제어되는 마지막 RTSP 세션에 대한 세션 수준 TEARDOWN 요청에 응답한 후 즉시 연결을 닫아서는 안 됩니다. 대신, 서버는 클라이언트가 TEARDOWN을 수신하고 이에 따라 조치를 취할 때까지 합리적인 시간 동안 기다려야 합니다.\(MAY, SHOULD NOT, SHOULD NOT\)

응답한 다음 연결 닫기를 시작합니다. 서버는 연결을 닫기 전에 TEARDOWN 응답을 보낸 후 최소 10초를 기다려야 합니다.\(SHOULD\)

- 이는 클라이언트가 마지막 연결을 끊은 후 기존 연결에서 새 세션에 대해 SETUP을 실행할 시간을 갖기 위한 것입니다. 10초는 클라이언트가 서버에 메시지를 전달할 수 있는 충분한 기회를 제공해야 합니다.

서버는 오류 코드가 있는 요청에 응답한 결과로 직접 연결을 닫아서는 안 됩니다.\(SHOULD NOT\)

- 460\(집계 작업만 허용됨\)\(섹션 17.4.24\)과 같은 특정 오류 응답은 콘텐츠 또는 기타 요인과 관련하여 서버 기능을 협상하는 데 사용됩니다. 이러한 경우 서버가 오류 응답에 대한 연결을 닫는 것은 비효율적입니다. 또한 이러한 동작으로 인해 고급 또는 특수 유형의 요청이 구현되지 않거나 새로운 기능을 테스트할 때 클라이언트에 추가 오버헤드가 발생하게 됩니다. 반면, 오류 응답을 보낸 후에도 연결을 열어두면 서비스 거부\(DoS\) 보안 위험이 발생할 수 있습니다\(섹션 21\).

서버는 불완전한 메시지를 수신하고 메시지가 합리적인 시간 내에 완료되지 않은 경우 연결을 닫을 수 있습니다. 서버는 메시지가 완료되거나 메시지의 다음 부분이 도착할 때까지\(전송과 클라이언트가 아직 살아 있다는 표시\) 최소 10초 동안 기다리는 것이 좋습니다. 공격을 받고 있거나 해당 이벤트 중에 리소스가 부족하다고 생각하는 서버는 더 짧은 시간 제한을 사용하는 것을 고려할 수 있습니다.\(MAY, SHOULD, MAY\)

클라이언트가 새 요청을 보내려고 하는 동안 서버가 연결을 닫으면 클라이언트는 현재 연결을 닫고 새 연결을 설정한 다음 새 연결을 통해 요청을 보내야 합니다.

RTSP 메시지는 연결을 종료함으로써 종료되어서는 안 됩니다. 이러한 메시지는 수신자에 의해 불완전한 것으로 간주되어 폐기될 수 있습니다. RTSP 메시지는 섹션 5에 정의된 대로 적절하게 종료됩니다.\(SHOULD NOT, MAY\)

---
### **10.4.  Timing Out Connections and RTSP Messages**

요청 수신자\(응답자\)는 TCP와 같은 신뢰할 수 있는 전송이 사용되는 경우에도 적시에 요청에 응답해야 합니다. 마찬가지로, 요청을 보낸 사람\(요청자\)은 응답자가 요청에 따라 작업을 수행하지 않을 것이라고 결론을 내리기 전에 응답을 위한 충분한 시간을 기다려야 합니다.\(SHOULD, SHOULD\)

응답자는 5초 이내에 모든 요청에 ​​응답해야 합니다. 응답자가 요청 처리에 5초 이상 걸릴 것임을 인식하면 가능한 한 빨리 100\(계속\) 응답을 보내야 합니다. 이후 요청자에게 최종 응답을 보낼 준비가 될 때까지 5초마다 100개의 응답을 계속 보내야 합니다. 100 응답을 보낸 후 응답자는 요청의 성공 또는 실패를 나타내는 최종 응답을 보내야 합니다.\(SHOULD, SHOULD, SHOULD, MUST\)

요청자는 응답자가 요청에 응답하지 않을 것이라고 결론을 내리기 전에 응답을 위해 최소 10초를 기다려야 합니다. 100 응답을 받은 후 요청자는 추가 응답을 계속 기다려야 합니다. 응답을 받지 못한 채 10초 이상이 경과하면 요청자는 응답자가 응답이 없다고 가정하고 TCP 연결을 닫아 연결을 중단할 수 있습니다.\(SHOULD, SHOULD, MAY\)

어떤 경우에는 여러 RTSP 세션이 동일한 전송 연결을 공유합니다. 요청을 포기하고 연결을 닫으면 다른 세션에 심각한 영향을 미칠 수 있습니다. 우선, 요청을 처리하는 데 오랜 시간이 걸리기 때문에 다른 RTSP 요청이 대기열에 추가되었을 수 있습니다. 둘째, 해당 세션은 서버-클라이언트 요청을 수신할 가능성도 상실합니다. 이러한 상황을 완화하려면 RTSP 클라이언트 또는 서버는 새 연결을 설정하고 대기열에 있거나 이 새 연결에서 응답을 받지 못한 요청을 보내야 합니다. 셋째, RTSP 서버가 특정 RTSP 세션에 유효한 연결을 알 수 있도록 하기 위해 RTSP 에이전트는 해당 RTSP 세션에 대해 다른 요청이 즉시 전송되지 않는 경우 이전의 각 RTSP 세션에 대해 연결 유지 요청을 보내야 합니다. 연결. 연결 유지 요청은 일반적으로 이 에이전트가 이 RTSP 세션에 관심이 있음을 서버에 알리기 위한 세션 헤더가 있는 SET\_PARAMETER입니다.\(SHOULD, SHOULD\)

요청자는 응답자와의 연결에서 상당한 전송 지연이 발생하는 경우 응답을 위해 10초 이상 기다려야 합니다. 요청자는 RTSP 요청의 타임스탬프 헤더\(18.53절\)를 사용하여 요청/응답 주기의 왕복 시간\(RTT\)을 결정할 수 있습니다.\(SHOULD\)

- 10초 대기를 선택한 이유는 다음과 같습니다. 기본값으로 작동하더라도 TCP가 몇 번의 재전송을 수행할 시간을 제공합니다. 사용자가 프로세스 자체를 포기할 수 없을 만큼 짧습니다. 그러나 특정 유형의 네트워크에서는 10초가 공격적일 수 있다는 점에 유의해야 합니다. 1xx 메시지의 5초 값은 요청자 측에서 시간 초과가 발생하기 전에 성공적으로 전달될 수 있는 합당한 기회를 제공하는 시간 초과의 절반입니다.

---
### **10.5.  Showing Liveness**

RTSP에서는 클라이언트가 주기적으로 서버에 활성 상태를 표시해야 합니다. 그렇지 않으면 서버가 세션 상태를 종료할 수 있습니다. 여러 가지 다른 프로토콜 메커니즘에는 클라이언트의 활성 증명이 포함됩니다. 이러한 메커니즘은 서버에 대한 세션 헤더가 있는 RTSP 요청입니다. 미디어 데이터 전송에 RTP 및 RTCP가 사용되고 전송이 설정된 경우 RTCP 메시지는 활성 상태를 증명합니다. 또는 RTSP 클라이언트의 활성 상태를 나타낼 수 있는 기타 사용된 미디어 전송 프로토콜을 통해. 클라이언트가 활성 메시지 전송을 시도하기 전에 제한 시간의 마지막 순간까지 기다리지 않는 것이 좋습니다. RTSP 메시지는 패킷 손실 및 TCP 재전송으로 인해 수신자에게 안전하게 도착하는 데 다소 시간이 걸릴 수 있습니다. 다른 작업을 수행하기 위해 발행되는 RTSP 요청 간의 활성 상태를 표시하려면 선호도 내림차순으로 다음 메커니즘을 사용할 수 있습니다.\(SHOULD\)

RTCP: RTP가 미디어 전송에 사용되는 경우 RTCP를 사용해야 합니다. RTCP를 사용하여 전송 통계를 보고하는 경우 반드시 연결 유지 기능도 수행해야 합니다. 서버는 클라이언트가 서버의 RTP 발신자 소스\(동기화 소스\(SSRC\)\)에 대해 보고한다는 사실과 함께 네트워크 주소 및 포트를 기준으로 클라이언트를 결정할 수 있습니다. RTCP 사용의 단점은 서버 도달에 대한 통계적 보장만 제공한다는 것입니다. 그러나 잘못된 클라이언트 시간 초과 가능성은 너무 낮아 대부분의 경우 무시할 수 있습니다. 예를 들어, 시간 제한이 60초이고 RTCP 메시지에 충분한 비트 전송률이 할당되어 평균 5초마다 클라이언트에서 서버로 메시지를 보내는 세션이 있다고 가정합니다. 해당 클라이언트는 패킷 손실이 5%인 네트워크의 경우 해당 세션의 시간 초과 간격인 2.4\*E-16 내에 활성 상태를 확인하지 못할 확률이 있습니다. 시간 초과가 더 짧고, 패킷 손실이 훨씬 높거나, RTCP 대역폭이 작은 세션도 아래 메커니즘 중 하나 이상을 구현해야 합니다\(SHOULD\).\(SHOULD, SHOULD\)

SET\_PARAMETER: 연결 유지를 위해 SET\_PARAMETER를 사용할 때 본문을 포함해서는 안 됩니다. 이 방법은 연결 유지만을 수행하기 위한 요청에 사용하도록 권장되는 RTSP 방법입니다. RTSP 서버는 클라이언트가 항상 이 메커니즘을 사용할 수 있도록 SET\_PARAMETER 메서드를 지원해야 합니다.\(SHOULD NOT, SHOULD, MUST\)

GET\_PARAMETER: 연결 유지를 위해 GET\_PARAMETER를 사용할 때 서버의 구현 지원에 따라 본문을 포함해서는 안 됩니다. OPTIONS 메서드를 사용하여 메서드 지원이 있는지 확인하거나 간단히 시도해 보세요.\(SHOULD NOT\)

옵션: 이 방법도 사용할 수 있지만 서버가 불필요한 처리를 더 많이 수행하고 작업에 필요한 것보다 더 큰 응답을 초래하게 됩니다. 그 이유는 Public 및 Allow 헤더를 올바르게 채우기 위해 서버가 미디어 리소스와 관련된 기능을 결정해야 하기 때문입니다.

세션 헤더\(18.49절\)의 시간 초과 매개변수는 SETUP 응답에 포함될 수 있으며 요청에는 포함되어서는 안 됩니다. 서버는 이를 사용하여 활동 부족으로 인해 세션을 닫기 전에 서버가 RTSP 명령 또는 기타 수명 징후 사이에서 대기할 준비가 된 시간을 클라이언트에 나타냅니다\(부록 B 참조\). 시간 초과는 초 단위로 측정되며 기본값은 60초입니다. 세션 시간 초과 길이는 설정된 세션에서 변경되어서는 안 됩니다.\(MUST NOT, MUST NOT\)

---
### **10.6.  Use of IPv6**

RTSP 1.0에는 명시적 IPv6 \[RFC2460\] 지원이 없습니다. RTSP 2.0은 명시적인 IPv6 지원을 위해 업데이트되었습니다. RTSP 2.0 구현은 URI 및 RTSP 헤더의 리터럴 IPv6 주소를 이해해야 합니다. 일반 URI 형식은 리터럴 IP 주소의 향후 새 버전을 예상하지만 이러한 새 버전을 사용하려면 RTSP 사양\(예: 전송 헤더의 주소 필드\(섹션 18.54\)\)에 대한 다른 수정이 필요합니다.\(MUST\)

---
### **10.7.  Overload Control**

RTSP의 과부하는 서버와 프록시에 요청 처리를 완료하는 데 필요한 리소스가 부족할 때 발생할 수 있습니다. 프록시 및 서버에서 이러한 과부하 상황을 부적절하게 처리하면 RTSP 배포 작업에 영향을 미치고 상황을 악화시킬 수 있습니다. RTSP는 503\(서비스를 사용할 수 없음\) 응답\(섹션 17.5.4\)을 정의하여 서버와 프록시가 요청하는 프록시와 RTSP 클라이언트에게 과부하 상황에 대해 알릴 수 있도록 합니다. 와 함께

Retry-After 헤더\(18.44절\)를 통해 서버나 프록시는 요청 엔터티가 프록시나 서버에 다른 요청을 보낼 수 있는 이후의 시간을 나타낼 수 있습니다.

이러한 503개 답변에는 두 가지 범위가 있습니다. 첫 번째 범위는 설정된 RTSP 세션을 위한 것으로, 503 응답을 초래하는 요청과 응답 자체에는 과부하가 발생한 세션을 식별하는 세션 헤더가 포함됩니다. 이 응답은 이 특정 세션에만 적용됩니다. 다른 범위는 요청-URI의 호스트로 식별되는 일반 RTSP 서버입니다. Retry-After 헤더가 포함된 503 응답은 새 RTSP 세션을 생성하기 위한 SETUP 요청을 포함하여 해당 서버와 관련된 세션이 아닌 모든 요청에 ​​적용됩니다.

과부하 상황의 또 다른 범위는 RTSP 프록시입니다. RTSP 프록시가 오버로드되었거나 요청을 처리할 수 없거나 사용할 수 없음을 알리기 위해 553 응답 코드가 "프록시를 사용할 수 없음"이라는 의미로 정의되었습니다. 서버와 마찬가지로 기존 RTSP 세션과 관련된 요청과 새 세션 생성 요청 또는 일반 프록시 요청 사이에는 응답 범위가 구분됩니다.

단순히 503\(서비스 사용 불가\) 및 553\(프록시 사용 불가\) 응답 코드를 구현하고 사용하는 것만으로는 과부하 상황을 적절하게 처리하는 데 충분하지 않습니다. 예를 들어, 단순한 접근 방식은 Retry-After 헤더를 고정 값으로 설정하여 503 응답을 보내는 것입니다. 그러나 이로 인해 여러 RTSP 클라이언트가 대략 동시에 프록시나 서버에 요청을 보내 다시 과부하 상황이 발생하는 상황이 발생할 수 있습니다. 또 다른 상황은 "이전" 과부하 상황이 아직 해결되지 않은 경우입니다. 즉, Retry-After 헤더에 표시된 길이가 너무 짧아서 과부하 상황이 가라앉지 않는 경우입니다.

과부하 상황의 RTSP 서버 또는 프록시는 현재 로드 상황을 염두에 두고 Retry-After 헤더 값을 신중하게 선택해야 합니다. 서버의 현재 로드에 비례하여 시간 초과 기간을 늘려야 합니다. 즉, 작업 로드가 증가하면 표시된 비가용성 기간이 길어집니다. Retry-After 헤더의 동일한 값을 요청하는 모든 프록시 및 클라이언트에 전송하는 것이 아니라 Retry-After 헤더의 평균 값에 변형을 추가하는 것이 필수입니다.\(MUST, MUST\)

부하 분산 RTSP 프록시를 사용하는 경우 더 복잡한 경우가 발생할 수 있습니다. 이는 요청을 처리하기 위해 RTSP 서버 집합 중에서 선택하는 데 RTSP 프록시가 사용되거나 특정 서버 이름에 대해 여러 서버 주소를 사용할 수 있는 경우입니다. 프록시나 클라이언트는 RTSP 서버나 프록시 중 하나로부터 503\(서비스를 사용할 수 없음\) 또는 553\(프록시를 사용할 수 없음\) 응답 코드를 받을 수 있습니다.

시간 초과\(서버가 요청 메시지를 처리할 수 없는 경우\) 프록시 또는 클라이언트는 다른 주소나 구성된 프록시를 다시 시도하지만 해당 주소로부터 503\(서비스를 사용할 수 없음\) 또는 553\(프록시를 사용할 수 없음\) 응답이나 TCP 시간 초과를 수신할 수도 있습니다. RTSP 서버/프록시/주소 중 어느 것도 요청을 처리할 수 없는 상황에서 RTSP 에이전트는 RTSP 서버에 새 요청을 보낼 수 있을 때까지 기다려야 합니다. 특정 주소에 대한 추가 요청은 수신된 Retry-After 헤더에 따라 지연되어야 합니다. 응답이 수신되지 않았거나 TCP 시간 초과가 발생한 주소의 경우 초기 대기 타이머를 5초로 설정해야 합니다. 타이머의 평균값이 30분으로 설정될 수 있는 경우 값이 30분을 초과할 때까지 추가 연결 실패 또는 응답 수신에 대해 해당 타이머를 두 배로 늘려야 합니다. 각 스케줄링마다 타이머에 동일한 값을 설정하는 것이 아니라 평균값에 변형을 추가하여 평균값의 0.5\~1.5배 범위 내에서 임의의 값을 선택하는 것이 필수입니다.\(MUST, SHOULD, MUST, MUST\)

---
## **11.  Capability Handling**

이 섹션에서는 RTSP를 확장할 수 있는 사용 가능한 기능 처리 메커니즘에 대해 설명합니다. 이 버전의 프로토콜 확장은 기본적으로 두 가지 방법으로 수행됩니다. 첫째, 새로운 헤더를 추가할 수 있습니다. 둘째, 새로운 메소드를 추가할 수 있습니다. 기능 처리 메커니즘은 두 경우를 모두 처리하도록 설계되었습니다.

메서드가 추가되면 관련 당사자는 OPTIONS 메서드를 사용하여 해당 메서드가 지원되는지 확인할 수 있습니다. 이는 상대방에게 OPTIONS 요청을 발행하여 수행됩니다. URI에 따라 특정 미디어 리소스, 일반적으로 전체 서버 또는 단순히 다음 홉과 관련하여 적용됩니다. OPTIONS 응답에는 표시된 리소스에 대해 지원되는 모든 메서드를 선언하는 공개 헤더가 포함되어야 합니다.\(MUST\)

클라이언트가 단순히 메소드를 시도할 수 있으므로 메소드 지원을 검색하기 위해 OPTIONS를 사용할 필요는 없습니다. 요청 수신자가 메서드를 지원하지 않는 경우 메서드가 구현되지 않았거나\(501\) 리소스에 적용되지 않음\(405\)을 나타내는 오류 코드로 응답합니다. 두 검색 방법 중 선택은 서비스 요구 사항에 따라 달라집니다.

기능 태그는 새로운 방법이 아닌 기능 추가를 처리하기 위해 정의됩니다. 각 기능 태그는 특정 기능 블록을 나타냅니다. 기능 태그가 나타내는 기능의 양은 크게 다를 수 있습니다. 예를 들어 기능 태그는 단일 RTSP 헤더가 제공하는 기능을 나타낼 수 있습니다. 또 다른 기능 태그는 재생 구현을 위한 최소 미디어 전달을 나타내는 "play.basic" 기능 태그\(11.1절\)와 같이 훨씬 더 많은 기능을 나타낼 수 있습니다.

기능 태그는 클라이언트, 서버 또는 프록시가 원하는 서비스를 달성하는 데 필요한 기능을 지원하는지 여부를 결정하는 데 사용됩니다. 기능 태그 지원을 확인하기 위해 여러 가지 헤더를 사용할 수 있습니다. 각 헤더는 아래에 설명되어 있습니다.

지원됨: 이 헤더는 일반적으로 클라이언트와 서버 모두에 있고 특정 리소스에 종속되지 않는 전체 기능 세트를 결정하는 데 사용됩니다. 의도된 사용법은 지원되는 기능을 사용하기 전에 결정하는 것입니다. 어떤 메소드에든 사용할 수 있지만 구현되는 모든 메소드를 동시에 결정하므로 OPTIONS가 가장 적합합니다. 요청을 보낼 때 요청자는 지원되는 모든 기능 태그를 포함하여 모든 기능을 선언합니다. 이로 인해 수신자는 요청자의 기능 지원을 학습하게 됩니다. 그러면 수신기는 응답에 해당 기능 세트를 포함시킵니다.

Proxy-Supported: 이 헤더는 Supported 헤더와 비슷한 방식으로 사용되지만 클라이언트나 서버의 지원 기능을 제공하는 대신 요청자와 응답자 모두에게 모든 구성원이 일반적으로 지원하는 공통 기능에 대한 보기를 제공합니다. 클라이언트와 서버 사이의 프록시 체인 리소스에 의존하지 않습니다. Supported 헤더가 존재할 때마다 프록시는 이 헤더를 추가해야 하지만 프록시는 요청자와 독립적으로 이를 추가할 수도 있습니다.

필수: 이 헤더는 요청을 올바르게 수행하기 위해 엔드포인트, 즉 클라이언트 또는 서버가 기능을 이해해야 하는 모든 요청에 ​​포함될 수 있습니다. 예를 들어, 이는 미디어 전달을 올바르게 설정할 수 있도록 서버가 특정 매개변수를 이해해야 하는 SETUP 요청일 수 있습니다. 이 매개변수를 무시하면 원하는 효과를 얻을 수 없으며 허용되지 않습니다. 따라서 Require가 포함된 요청을 수신하는 엔드포인트는 이해하지 못하고 요청을 수행하지 않는 모든 기능을 부정적으로 승인해야 합니다. 기능이 지원되지 않는 경우의 응답은 551\(옵션이 지원되지 않음\)입니다. 또한 지원되지 않는 기능은 응답의 Unsupported 헤더에 제공됩니다.\(MUST\)

Proxy-Require: 이 헤더는 프록시에만 적용되고 엔드포인트에는 적용되지 않는다는 점을 제외하면 Require와 동일한 목적과 동작을 갖습니다. 프록시와 엔드포인트 모두에서 지원해야 하는 기능은 Require 및 Proxy-Require 헤더에 모두 포함되어야 합니다.

지원되지 않음: 이 헤더는 551\(옵션이 지원되지 않음\) 오류 응답에 사용되어 지원되지 않는 기능을 나타냅니다. 이러한 응답은 하나 이상의 기능이 지원되지 않는 Require 또는 Proxy-Require 헤더 사용의 결과일 뿐입니다. 이 정보를 통해 요청자는 어떤 기능이 지원되지 않는지 알 수 있으므로 상황을 최대한 활용할 수 있습니다.

---
### **11.1.  Feature Tag: play.basic**

미디어 재생 설정 및 제어를 위해 이 사양의 모든 규범적인 부분을 지원하는 구현에서는 "play.basic" 기능 태그를 사용하여 이 지원을 나타냅니다. 부록\(문자로 시작\)은 부록이 필수 부록으로 기본 섹션에 명시적으로 지정되지 않는 한 기능 태그에 포함된 기능의 일부가 아닙니다.

- 참고: 이 기능 태그는 RTP와 같은 미디어 전달 프로토콜을 요구하지 않습니다.

- RTSP 1.0에는 최소한의 구현 부분이 있었습니다. 그러나 이는 나머지 사양과 일치하지 않았습니다. 따라서 play.basic의 기능을 명시적으로 열거하기보다는 이 사양을 전체적으로 받아들여야 하며 규범적으로 필수로 정의된 필수 기능이 포함되어야 합니다.

---
## **12.  Pipelining Support**

파이프라이닝은 요청 에이전트가 둘 이상의 요청을 처리하지 않고 동일한 영구 연결을 통해 전송할 수 있도록 하여 요청/응답 프로토콜의 성능을 향상시키는 일반적인 방법입니다. 요청의 상대적 순서가 중요한 RTSP의 경우 요청 순서를 유지하는 것이 중요합니다. 이 때문에 응답 에이전트는 들어오는 요청을 전송 순서대로 처리해야 합니다. 전송 순서는 CSeq 헤더와 해당 시퀀스 번호에 의해 결정될 수 있습니다. TCP의 경우 두 에이전트 사이의 배달 순서는 보내는 순서와 동일합니다. 동일한 에이전트의 다음 요청을 처리하기 전에 요청 처리도 완료되어야 합니다. 응답은 요청이 처리된 순서대로 전송되어야 합니다.\(MUST, MUST, MUST\)

RTSP 2.0은 RTSP 1.0의 기능 이상으로 파이프라인 지원을 확장했습니다. 주요 개선 사항으로, 이제 미디어 전달 설정 및 시작과 관련된 모든 요청을 Pipelined-Request 헤더에 표시되는 파이프라인으로 처리할 수 있습니다\(섹션 18.33 참조\). 이 헤더를 사용하면 클라이언트는 두 개 이상의 요청이 첫 번째 요청과 동일한 RTSP 세션 컨텍스트에서 처리되도록 요청할 수 있습니다.

만듭니다. 즉, 클라이언트는 단일 응답을 기다릴 필요 없이 두 개 이상의 미디어 스트림을 설정한 다음 재생하도록 요청할 수 있습니다. 이렇게 하면 RTSP 세션의 초기 시작 시간이 최소한 하나의 RTT만큼 빨라집니다.

파이프라인 요청이 하나 이상의 이전 요청의 성공적인 완료를 기반으로 구축되는 경우 요청자는 모든 요청이 예상대로 실행되었는지 확인해야 합니다. 일반적인 예로는 2개의 SETUP 요청과 1개의 PLAY 요청이 있습니다. SETUP 요청 중 하나가 예기치 않게 실패하는 경우에도 PLAY 요청은 성공적으로 실행될 수 있습니다. 그러나 결과 프리젠테이션은 두 개가 아닌 단일 미디어만 재생되므로 요청 클라이언트가 예상한 것과 다릅니다. 이 경우 클라이언트는 PAUSE 요청을 보내고 실패한 SETUP 요청을 수정한 다음 재생을 요청할 수 있습니다.

---
## **13.  Method Definitions**

메소드는 Request-URI에 의해 식별된 자원에 대해 수행될 작업을 나타냅니다. 메소드 이름은 대소문자를 구분합니다. 미래에는 새로운 방법이 정의될 수 있습니다. 메서드 이름은 $ 문자\(10진수 36\)로 시작해서는 안 되며 섹션 20의 ABNF \[RFC5234\]에 정의된 토큰이어야 합니다. 메서드는 표 7에 요약되어 있습니다.\(MUST NOT\)

```text
    +---------------+-----------+--------+-------------+-------------+
    | method        | direction | object | Server req. | Client req. |
    +---------------+-----------+--------+-------------+-------------+
    | DESCRIBE      | C -> S    | P,S    | recommended | recommended |
    |               |           |        |             |             |
    | GET_PARAMETER | C -> S    | P,S    | optional    | optional    |
    |               |           |        |             |             |
    |               | S -> C    | P,S    | optional    | optional    |
    |               |           |        |             |             |
    | OPTIONS       | C -> S    | P,S    | required    | required    |
    |               |           |        |             |             |
    |               | S -> C    | P,S    | optional    | optional    |
    |               |           |        |             |             |
    | PAUSE         | C -> S    | P,S    | required    | required    |
    |               |           |        |             |             |
    | PLAY          | C -> S    | P,S    | required    | required    |
    |               |           |        |             |             |
    | PLAY_NOTIFY   | S -> C    | P,S    | required    | required    |
    |               |           |        |             |             |
    | REDIRECT      | S -> C    | P,S    | optional    | required    |
    |               |           |        |             |             |
    | SETUP         | C -> S    | S      | required    | required    |
    |               |           |        |             |             |
    | SET_PARAMETER | C -> S    | P,S    | required    | optional    |
    |               |           |        |             |             |
    |               | S -> C    | P,S    | optional    | optional    |
    |               |           |        |             |             |
    | TEARDOWN      | C -> S    | P,S    | required    | required    |
    |               |           |        |             |             |
    |               | S -> C    | P      | required    | required    |
    +---------------+-----------+--------+-------------+-------------+
```

- 표 7: RTSP 방법 개요

- 표 7에 대한 참고 사항: 이 표에는 RTSP 방법, 방향 및 작동하는 개체\(P: 프리젠테이션, S: 스트림\)가 포함되어 있습니다. 또한 서버 또는 클라이언트 구현이 필수\(필수\), 권장 또는 선택인지 여부를 나타냅니다.

- 표 7에 대한 추가 참고 사항: GET\_PARAMETER는 선택 사항입니다. 예를 들어, 매개 변수 없이 미디어를 전달하도록 완전한 기능을 갖춘 서버를 구축할 수 있습니다. 그러나 SET\_PARAMETER는 필수입니다. 즉, 서버에 대해 구현하려면 필수입니다. 이는 연결 유지에 사용되기 때문입니다. PAUSE는 전체 세션을 종료하지 않고 Play 상태를 떠날 수 있는 유일한 방법이기 때문에 필요합니다.

RTSP 에이전트가 특정 방법을 지원하지 않는 경우 501\(구현되지 않음\) 응답 코드를 반환해야 하며\(MUST\) 요청하는 RTSP 에이전트는 주어진 에이전트/리소스 조합에 대해 이 방법을 다시 시도해서는 안 됩니다. 주요 기능이 기록 또는 감사이고 어떤 방식으로든 전송 또는 미디어 처리를 수정하지 않는 RTSP 프록시는 알 수 없는 방법으로 RTSP 메시지를 전달할 수 있습니다. 프록시는 Via 헤더 추가와 같은 최소한의 필수 처리를 수행해야 합니다.\(MUST, MAY\)

---
### **13.1.  OPTIONS**

RTSP OPTIONS 메서드의 의미는 \[RFC7231\]의 4.3.7절에 설명된 HTTP OPTIONS 메서드의 의미와 유사합니다. 그러나 RTSP에서 OPTIONS는 클라이언트가 서버에 요청을 보낼 수 있고 그 반대의 경우도 가능하다는 점에서 양방향입니다. 클라이언트는 OPTIONS 요청을 보내는 기능을 구현해야 하며, 서버 또는 프록시는 OPTIONS 요청에 응답하는 기능을 구현해야 합니다. 이 "반드시 구현해야 하는" 기능 외에도 클라이언트, 서버 및 프록시는 OPTIONS 요청 전송과 요청에 대한 응답 생성 모두에 대한 지원을 제공할 수 있습니다.\(MUST, MUST\)

OPTIONS 요청은 언제든지 발행될 수 있습니다. 이러한 요청은 세션 상태를 수정하지 않습니다. 그러나 세션 수명이 연장될 수 있습니다\(아래 참조\). OPTIONS 요청의 URI는 요청 범위와 해당 응답을 결정합니다. 요청-URI가 특정 호스트의 특정 미디어 리소스를 참조하는 경우 범위는 표시된 RTSP 에이전트가 해당 미디어 리소스에 대해 지원하는 메서드 집합으로 제한됩니다. 호스트 주소만 있는 요청-URI는 특정 미디어에 관계없이 지정된 RTSP 에이전트의 일반 기능으로 범위를 제한합니다. Request-URI가 별표\("\*"\)인 경우 범위는 다음 홉\(즉, 요청 보낸 사람과 직접 통신하는 RTSP 에이전트\)의 일반 기능으로 제한됩니다.

요청 범위에 관계없이 공개 헤더는 항상 OPTIONS 응답에 포함되어야 하며 응답 RTSP 에이전트가 지원하는 메서드를 나열해야 합니다. 또한 요청의 범위가 미디어 리소스로 제한되는 경우 메서드 집합이 Public 헤더의 집합과 완전히 일치하지 않는 한 해당 리소스에 허용되는 메서드 집합을 열거하기 위해 Allow 헤더를 응답에 포함해야 합니다. . 주어진 리소스를 사용할 수 없는 경우 RTSP 에이전트는 3rr 또는 4xx와 같은 적절한 응답 코드를 반환해야 합니다\(SHOULD\). 응답하는 RTSP 에이전트가 지원하는 기능 세트를 쿼리하기 위한 요청에 Supported 헤더가 포함될 수 있습니다.\(MUST, MUST, SHOULD, MAY\)

OPTIONS 메서드를 사용하면 RTSP 세션을 활성 상태로 유지할 수 있습니다. 그러나 이는 세션 유지 신호 전달에 선호되는 방식은 아닙니다. 섹션 18.49를 참조하세요. RTSP 세션을 유지하기 위한 OPTIONS 요청에는 관련 세션 식별자와 함께 세션 헤더가 포함되어야 합니다. 이러한 요청은 또한 요청-URI로 미디어 또는 집계된 제어 URI를 사용해야 합니다.\(MUST, SHOULD\)

```text
   Example:

     C->S:  OPTIONS rtsp://server.example.com RTSP/2.0
            CSeq: 1
            User-Agent: PhonyClient/1.2
            Proxy-Require: gzipped-messages
            Supported: play.basic

     S->C:  RTSP/2.0 200 OK
            CSeq: 1
            Public: DESCRIBE, SETUP, TEARDOWN, PLAY, PAUSE, OPTIONS
            Supported: play.basic, setup.rtp.rtcp.mux, play.scale
            Server: PhonyServer/1.1
```

Proxy-Require의 "gzipped-messages" 기능 태그는 가상의 기능입니다.

---
### **13.2.  DESCRIBE**

DESCRIBE 메소드는 서버에서 프리젠테이션이나 미디어 객체의 설명을 검색하는 데 사용됩니다. DESCRIBE 요청의 Request-URI는 관심 있는 미디어 리소스를 식별합니다. 클라이언트는 자신이 이해하는 설명 형식을 나열하기 위해 요청에 Accept 헤더를 포함할 수 있습니다. DESCRIBE 메소드 요청이 성공적으로 이행될 수 있는 경우 서버는 요청된 리소스에 대한 설명으로 응답하고 응답의 메시지 본문에 설명을 반환해야 합니다. DESCRIBE 응답-응답 쌍은 RTSP의 미디어 초기화 단계를 구성합니다.\(MAY, MUST\)

DESCRIBE 응답은 그것이 설명하는 리소스에 대한 모든 미디어 초기화 정보를 포함해야 합니다. 서버는 설명 지점을 다른 서버에 가짐으로써 미디어 간접 전달 수단으로 DESCRIBE 응답을 사용해서는 안 됩니다. 대신 3rr 응답을 사용하는 것이 권장됩니다.\(SHOULD, SHOULD NOT\)

- DESCRIBE 응답이 설명하는 스트림 집합에 대한 모든 미디어 초기화 정보를 포함하도록 하고 미디어 간접 참조에 DESCRIBE를 사용하지 않도록 함으로써 다른 접근 방식으로 인해 발생할 수 있는 루핑 문제를 피할 수 있습니다.

```text
   Example:

     C->S: DESCRIBE rtsp://server.example.com/fizzle/foo RTSP/2.0
           CSeq: 312
           User-Agent: PhonyClient/1.2
           Accept: application/sdp, application/example

     S->C: RTSP/2.0 200 OK
           CSeq: 312
           Date: Thu, 23 Jan 1997 15:35:06 GMT
           Server: PhonyServer/1.1
           Content-Base: rtsp://server.example.com/fizzle/foo/
           Content-Type: application/sdp
           Content-Length: 358

           v=0
           o=MNobody 2890844526 2890842807 IN IP4 192.0.2.46
           s=SDP Seminar
           i=A Seminar on the session description protocol
           u=http://www.example.com/lectures/sdp.ps
           e=seminar@example.com (Seminar Management)
           c=IN IP4 0.0.0.0
           a=control:*
           t=2873397496 2873404696
           m=audio 3456 RTP/AVP 0
           a=control:audio
           m=video 2232 RTP/AVP 31
           a=control:video
```

미디어 초기화는 모든 RTSP 기반 시스템의 요구 사항이지만 RTSP 사양에는 DESCRIBE 메서드를 통해 수행해야 한다고 명시되어 있지 않습니다. RTSP 클라이언트가 초기화 정보를 수신할 수 있는 세 가지 방법이 있습니다.

o RTSP DESCRIBE 요청을 통해

o 다른 프로토콜\(HTTP, 이메일 첨부 등\)을 통해

o 어떤 형태의 사용자 인터페이스를 통해

클라이언트가 대체 소스로부터 유효한 설명을 얻은 경우 클라이언트는 동일한 미디어에 대해 DESCRIBE 요청을 발행하지 않고 초기화 목적으로 이 설명을 사용할 수 있습니다. 클라이언트는 MTag를 사용하여 프레젠테이션 설명의 유효성을 검사하거나 세션 설정이 유효한지 조건으로 설정해야 합니다.\(MAY\)

최소 서버가 DESCRIBE 메서드를 지원하는 것이 권장되며, 최소 클라이언트가 사용자 인터페이스에서 미디어 초기화 파일을 받아들이는 "도우미 응용 프로그램" 역할을 하는 기능이나 운영 환경에 적합한 다른 수단을 지원하는 것이 좋습니다. 클라이언트.\(SHOULD\)

---
### **13.3.  SETUP**

아래 설명에서는 해당 세션이 생성되었을 때 특정 세션과 관련된 프로토콜 상태 머신의 다음 상태를 사용합니다. 상태 전환은 프로토콜 상호 작용에 의해 구동됩니다. 상태 머신에 대한 추가 정보는 부록 B를 참조하십시오.

```text
   Init: Initial state.  No session exists.
```

준비됨: 세션이 재생을 시작할 준비가 되었습니다.

재생: 세션이 재생 중입니다. 즉, S-\>C 방향으로 미디어 스트림 데이터를 전송합니다.

URI에 대한 SETUP 요청은 스트리밍 미디어에 사용될 전송 메커니즘을 지정합니다. SETUP 메소드는 RTSP 세션을 생성하고 이미 설정된 미디어 스트림의 전송 매개변수를 변경하는 두 가지 경우에 사용될 수 있습니다. SETUP은 Init, Ready 및 Play의 세 가지 상태 모두에서 사용되어 전송 매개변수를 변경할 수 있습니다. 또한 Init 및 Ready를 사용하여 RTSP 세션을 생성할 수도 있습니다. 세션에 미디어 리소스를 추가하기 위해 재생 상태에서 SETUP 메서드를 사용하는 방법은 지정되지 않습니다.

Transport 헤더\(18.54절 참조\)는 데이터 전송을 위해 클라이언트가 수용할 수 있는 미디어 전송 매개변수를 지정합니다. 응답에는 서버에서 선택한 전송 매개변수가 포함됩니다. 이를 통해 클라이언트는 선호도에 따라 내림차순으로 허용되는 전송 메커니즘과 매개변수를 열거할 수 있으므로 서버는 가장 적절한 것을 선택할 수 있습니다. 사용된 세션 설명 형식을 통해 클라이언트는 서버에 선택 사항으로 제공되는 제한된 수의 구성을 선택할 수 있을 것으로 예상됩니다. 모든 전송 관련 매개변수는 전송 헤더에 포함되어야 합니다. 방화벽이나 NAT와 같은 미들박스로 인해 이 목적으로 다른 헤더를 사용하는 것은 권장되지 않습니다.\(MUST\)

개입하는 방화벽의 이점을 위해 클라이언트는 알려진 전송 매개변수를 표시해야 합니다. 예를 들어 서버가 고정 멀티캐스트 주소를 대상으로 광고하는 경우 이러한 매개변수에 영향을 미치지 않더라도 클라이언트는 반드시 알려진 전송 매개변수를 표시해야 합니다.\(MUST\)

- SETUP에는 모든 전송 초기화 정보가 포함되어 있으므로 방화벽 및 기타 중간 네트워크 장치\(이 정보가 필요함\)는 미디어 초기화를 위해 예약된 DESCRIBE 응답을 구문 분석하는 더 힘든 작업을 수행하지 않습니다.

클라이언트는 Range 헤더에서 지원되는 모든 단위 형식을 나타내는 Accept-Ranges 헤더를 요청에 포함해야 합니다. 이를 통해 서버는 요청 범위가 없는 PLAY 응답과 같은 향후 세션 관련 응답에서 어떤 형식을 사용할 수 있는지 알 수 있습니다. 클라이언트가 프레젠테이션에 필요한 시간 형식을 지원하지 않는 경우 서버는 456\(리소스에 대해 유효하지 않은 헤더 필드\)을 사용하여 응답해야 하며 리소스에 대해 지원되는 범위 단위 형식과 함께 Accept-Ranges 헤더를 포함해야 합니다.\(MUST, MUST\)

SETUP 응답에서 서버는 이 미디어 리소스에 사용할 수 있는 시간 형식을 나타내기 위해 Accept-Ranges 헤더\(섹션 18.5 참조\)를 포함해야 합니다.\(MUST\)

SETUP 200 OK 응답에는 Media-Properties 헤더가 포함되어야 합니다\(섹션 18.29 참조\). Media-Properties 헤더의 매개변수 조합은 세션에 존재하는 콘텐츠의 특성을 나타냅니다\(섹션 4.7 참조\). 예를 들어, 타임 시프팅이 포함된 라이브 스트림은 다음과 같이 표시됩니다.\(MUST\)

o Random-Access로 설정된 Random-Access,

o 시간 진행으로 설정된 콘텐츠 수정, 그리고

o 보존 기간은 시간-지속 시간\(특정 기록 창 시간 값 포함\)으로 설정됩니다.

미디어가 Time-Progressing인 경우 SETUP 200 OK 응답에는 Media-Range 헤더\(섹션 18.30 참조\)가 포함되어야 합니다.\(MUST\)

SETUP의 기본 예:

```text
     C->S: SETUP rtsp://example.com/foo/bar/baz.rm RTSP/2.0
           CSeq: 302
           Transport: RTP/AVP;unicast;dest_addr=":4588"/":4589",
                      RTP/AVP/TCP;unicast;interleaved=0-1
           Accept-Ranges: npt, clock
           User-Agent: PhonyClient/1.2

     S->C: RTSP/2.0 200 OK
           CSeq: 302
           Date: Thu, 23 Jan 1997 15:35:06 GMT
           Server: PhonyServer/1.1
           Session: QKyjN8nt2WqbWw4tIYof52;timeout=60
           Transport: RTP/AVP;unicast;dest_addr="192.0.2.53:4588"/
                      "192.0.2.53:4589"; src_addr="198.51.100.241:6256"/
                      "198.51.100.241:6257"; ssrc=2A3F93ED
           Accept-Ranges: npt
           Media-Properties: Random-Access=3.2, Time-Progressing,
                             Time-Duration=3600.0
           Media-Range: npt=0-2893.23
```

위의 예에서 클라이언트는 미디어 리소스 "rtsp://example.com/foo/bar/baz.rm"을 포함하는 RTSP 세션을 생성하려고 합니다. 클라이언트가 허용하는 전송 매개변수는 RTSP 설정 연결이 시작되는 주소의 클라이언트 포트 4588 및 4589에서 수신되는 RTP/AVP/UDP\(기본값은 UDP\)이거나 RTSP 제어 채널에 인터리브된 RTP/AVP입니다. 서버는 RTP/AVP/UDP 전송을 선택하고 RTP 및 RTCP를 보내고 받을 주소와 포트, 그리고 서버에서 사용할 RTP SSRC를 추가합니다.

서버에 대한 SETUP 요청에 세션 식별자나 기존 세션 컨텍스트를 참조하는 Pipelined-Requests 헤더가 포함되어 있지 않은 한, 서버는 성공적인 SETUP 요청에 대한 응답으로 세션 식별자를 생성해야 합니다. 후자의 경우 서버는 이 SETUP 요청을 기존 세션\(집합 세션\)에 묶거나 459\(집합 작업이 허용되지 않음\) 오류 코드를 반환해야 합니다\(섹션 17.4.23 참조\). 집계된 세션을 제어하려면 집계 제어 URI를 사용해야 합니다. 이 URI는 집합에 포함된 개별 미디어 스트림의 스트림 제어 URI와 달라야 합니다\(집합된 세션에 대해서는 섹션 13.4.2를 참조하고 특정 URI에 대해서는 부록 D.1.1을 참조하십시오\). 서버가 집계 제어를 지원하고 세션에 대해 집계 제어가 필요한 경우 집계 제어 URI는 세션 설명에 의해 지정됩니다.\(MUST, MUST, MUST, MUST\)

그러나 집계된 제어가 제공되는 경우에도 클라이언트는 집계된 제어에서 세션을 설정하지 않도록 선택할 수 있습니다. 세션 설명에 집계 제어 URI가 지정되지 않은 경우 일반적으로 집계되지 않은 제어를 사용해야 함을 나타냅니다.\(MAY\)

집계된 제어 URI가 제공되지 않은 집계의 미디어 스트림 설정이 지정되지 않았습니다.

- 세션 ID가 세션의 집계 제어를 위한 충분한 정보를 전달하는 경우도 있지만 제어 URI를 통해 문제의 리소스를 쉽게 식별할 수 있는 SET\_PARAMETER와 같은 일부 메서드에서는 집계 제어 URI가 여전히 중요합니다. 집계 제어 URI는 요청을 적절한 서버로 라우팅할 수 있는 프록시와 요청이 작동 중인 실제 리소스를 기록하는 데 유용한 로깅에도 유용합니다.

세션은 TEARDOWN 요청에 의해 제거되거나 서버에 의해 시간 초과될 때까지 존재합니다. 서버는 특정 시간 초과 기간 내에 클라이언트로부터 활성 신호를 입증하지 못한 세션을 제거할 수 있습니다. 기본 시간 초과 값은 60초입니다. 서버는 이를 다른 값으로 설정하고 SETUP 응답에 있는 세션 헤더의 시간 초과 필드에 이를 표시할 수 있습니다. 자세한 내용은 섹션 18.49를 참조하세요. RTSP 세션의 활성 징후에는 해당 세션에 대한 ID가 포함된 세션 헤더가 포함된 클라이언트의 모든 RTSP 요청과 RTP가 기본 미디어 스트림을 전송하는 데 사용되는 경우 RTCP 발신자 또는 수신자 보고서가 포함됩니다. 예를 들어 RTCP 발신자 보고서는 서버가 회의 세션에 초대되는 세션에서 수신될 수 있으므로 활성 표시기로 유효합니다.\(MAY, MAY\)

어떤 이유로든 세션에 대한 SETUP 요청이 실패하는 경우 세션 상태는 물론 관련 스트림에 대한 전송 및 기타 매개변수는 마치 SETUP 요청이 서버에서 수신되지 않은 것처럼 해당 값에서 변경되지 않은 상태로 유지되어야 합니다.\(MUST\)

---
#### **13.3.1.  Changing Transport Parameters**

클라이언트는 서버가 허용할 수 있는 전송 매개변수를 변경하기 위해 이미 설정되었거나 세션에서 재생되는 스트림에 대해 SETUP 요청을 발행할 수 있습니다. 매개변수 변경을 허용하지 않는 경우 오류 455\(이 상태에서는 유효하지 않은 메소드\)로 응답해야 합니다. 전송 매개변수 변경을 지원하는 이유에는 애플리케이션 계층 이동성과 유연성을 허용하여 가능한 최상의 전송을 활용할 수 있도록 하는 것이 포함됩니다. 서버가 Play 상태에 있는 동안 전송 매개변수를 변경하려고 할 때 클라이언트가 455 오류를 수신하면 SETUP 요청을 다시 발행하기 전에 PAUSE를 사용하여 서버를 준비 상태로 전환하려고 시도할 수 있습니다. 그것도 실패하면,\(MAY, MUST, MAY\)

전송 매개변수를 변경하려면 클라이언트가 영향을 받은 미디어를 TEARDOWN한 다음 다시 설정해야 합니다. 집계된 세션의 경우 모든 미디어를 동시에 해체하지 않으면 새 세션이 생성되지 않습니다.

모든 전송 매개변수는 변경될 수 있습니다. 그러나 예상되는 주요 용도는 인터리브 TCP 모드에서 UDP로 또는 그 반대로 전환하는 것과 같이 전송 프로토콜을 완전히 변경하거나 배달 주소를 변경하는 것입니다.\(MAY\)

재생 상태에 있는 동안 전송 매개변수를 변경하라는 요청에 대한 SETUP 응답에서 서버는 새로운 전송 매개변수가 사용될 지점을 나타내기 위해 Range 헤더를 포함해야 합니다. 또한 RTP가 전달에 사용되는 경우 서버는 변경이 발생할 타임스탬프와 RTP 시퀀스 번호를 나타내기 위해 RTP-Info 헤더도 포함해야 합니다. RTP-Info와 Range가 모두 응답에 포함된 경우 Range 헤더의 "rtp\_time" 매개 변수와 시작 지점은 해당 시간에 대한 것이어야 합니다. 즉, 올바른 동기화 정보를 보장하기 위해 PLAY와 동일한 방식으로 사용되어야 합니다. 사용 가능.\(MUST, MUST, MUST\)

Play 상태에서 발생한 전송 매개변수 변경으로 인해 동기화 관련 정보가 변경된 경우\(예: RTP SSRC 변경\), 서버는 SETUP 응답에 필요한 동기화 정보를 포함해야 합니다. 그러나 서버는 가능하다면 동기화 정보 변경을 피해야 합니다\(SHOULD\).\(MUST, SHOULD\)

---
### **13.4.  PLAY**

이 섹션에서는 집계된 세션과 다양한 사용 시나리오에서 PLAY 메서드의 일반적인 사용법을 설명합니다.

---
#### **13.4.1.  General Usage**

PLAY 메소드는 SETUP에 지정된 메커니즘을 통해 데이터 전송을 시작하고 미디어의 어느 부분을 재생해야 하는지 서버에 지시합니다. PLAY 요청은 세션이 Ready 또는 Play 상태일 때 유효합니다. PLAY 요청에는 요청이 적용되는 세션을 나타내는 세션 헤더가 포함되어야 합니다.\(MUST\)

PLAY 요청을 수신하면 서버는 미디어 리소스 제한 내에서 Seek-Style 헤더\(18.47절\)에 따라 수신된 Range 헤더에 지정된 범위의 시작 부분에 일반 재생 시간을 배치해야 합니다. 주어진 경우 범위 끝까지, 새로운 PLAY 요청이 수신될 때까지, PAUSE 요청\(13.5절\)이 수신될 때까지 또는 미디어 끝에 도달할 때까지 스트림 데이터를 전달해야 합니다. 범위가 없는 경우\(MUST, MUST\)

헤더가 PLAY 요청에 있으면 서버는 현재 일시 중지 지점부터 미디어 끝까지 재생해야 합니다. 일시 중지 지점은 세션 시작 시 미디어 시작 부분으로 기본 설정됩니다. 시간이 지남에 따라 보존되지 않는 미디어의 경우 일시 중지 지점은 항상 NPT "현재", 즉 현재 전달 지점과 동일하게 설정됩니다. 일시 중지 지점은 PAUSE 메서드를 통해 미디어의 특정 지점으로 설정될 수도 있습니다. 섹션 13.6을 참조하세요. 현재 재생 중인 미디어의 일시 중지 지점은 현재 미디어 위치와 같습니다. 시간 제한 보존 기능이 있는 시간 진행 미디어의 경우 일시 중지 지점이 서버에서 유지한 것보다 오래된 위치를 나타내는 경우 일시 중지 지점은 가장 오래 유지된 위치로 이동됩니다.\(MUST\)

유효한 범위 값은 콘텐츠 유형에 따라 다릅니다. 시간이 진행되지 않는 콘텐츠의 경우 지정된 범위가 집계 내 미디어의 일부이면 범위 값이 유효합니다. 즉, 집계에 대한 유효한 미디어 범위는 집계에 있는 모든 미디어 구성 요소의 통합입니다. 주어진 범위 값이 미디어 외부를 가리키는 경우 응답은 457\(잘못된 범위\) 오류 코드여야 하며 미디어의 유효한 범위와 함께 Media-Range 헤더\(섹션 18.30\)를 포함해야 합니다. 클라이언트가 유지되는 콘텐츠보다 먼저 시작 지점을 요청하는 시간 진행 콘텐츠를 제외하고 시작 지점은 가장 오래 유지된 콘텐츠로 조정됩니다. 미디어 앞쪽 가장자리를 넘어서는 시작 지점의 경우, 즉 "현재"에 대한 현재 값을 넘어서는 경우 서버는 시작 값을 현재 앞쪽 가장자리로 조정해야 합니다. Range 헤더의 중지 지점 값은 현재 미디어 가장자리를 넘어갈 수 있습니다. 이 경우 서버는 요청된\(및 조정된\) 시작 지점에서 제공된 중지 지점 중 첫 번째 지점이나 미디어의 끝까지 미디어를 전달해야 합니다. 특정 시작 지점부터 미디어 끝까지 재생하려는 경우 암시적 중지 지점이 있는 Range 헤더를 사용하는 것이 권장됩니다.\(MUST, MUST, MUST, SHOULD\)

클라이언트가 명시적으로 Range 헤더를 사용하거나 미디어 끝의 일시 중지 지점을 사용하여 암시적으로 미디어 끝에서 재생을 시작하도록 요청하는 경우 457\(잘못된 범위\) 오류가 전송되고 Media-Range 헤더를 포함해야 합니다. \(18.30항\). Range 헤더도 응답에 포함되어야 하며 세션이 준비 상태인 경우 미디어에 일시 중지 지점을 전달한다는 것이 아래에 명시되어 있습니다. 이는 일시 중지 지점 또는 요청된 시작 지점이 미디어의 시작 부분에 있고 Scale 헤더\(섹션 18.46\)가 음수 값\(뒤로 재생\)으로 포함된 경우에도 적용됩니다.\(MUST\)

임의 액세스 속성이 있는 미디어의 경우 클라이언트는 서버가 사용해야 하는 시작점 선택 정책을 나타낼 수 있습니다. 이는 PLAY에 Seek-Style 헤더\(섹션 18.47\)를 포함하여 수행됩니다.

요구. 적용된 탐색 스타일은 미디어가 실제로 전달되는 지점을 나타내도록 조정되므로 Range 헤더의 내용에 영향을 미칩니다.

처음부터 미디어를 재생하려는 클라이언트는 시작 부분을 가리키는 Range 헤더\(예: "npt=0-"\)와 함께 PLAY 요청을 보내야 합니다. Range 헤더 없이 PLAY 요청이 수신되고 미디어 전달이 마지막에 중지된 경우 서버는 457\(잘못된 범위\) 오류 응답으로 응답해야 합니다. 해당 응답에서 현재 일시 중지 지점은 Range 헤더에 포함되어야 합니다.\(MUST, SHOULD, MUST\)

이 사양의 모든 범위 지정자는 암시적 시작점이 있는 범위를 허용합니다\(예: "npt=-30"\). PLAY 요청에 사용될 때 서버는 이를 현재 일시 중지 지점부터 Range 헤더에 지정된 종료 시간에 끝나는 전달을 시작하거나 재개하라는 요청으로 처리합니다. 일시정지 지점이 지정된 종료 값보다 이후에 위치하는 경우 457\(잘못된 범위\) 응답이 반환되어야 합니다.\(MUST\)

아래 예에서는 10초부터 25초까지 재생합니다. 또한 표시된 시작 지점 이전의 첫 번째 임의 액세스 지점에서 미디어를 전달하도록 서버에 요청합니다.

```text
     C->S: PLAY rtsp://audio.example.com/audio RTSP/2.0
           CSeq: 835
           Session: ULExwZCXh2pd0xuFgkgZJW
           Range: npt=10-25
           Seek-Style: RAP
           User-Agent: PhonyClient/1.2
```

요청에 Range 헤더가 없더라도 서버는 모든 PLAY 응답에 Range 헤더를 포함해야 합니다. 응답은 포함된 요청의 Range 헤더와 동일한 형식을 사용해야 합니다. 요청에 Range 헤더가 없으면 세션 내의 이전 PLAY 요청에 사용된 형식을 사용해야 합니다. 이전 요청에 형식이 표시되지 않은 경우 서버는 미디어에서 지원하고 SETUP 요청의 Accept-Ranges 헤더에 표시된 모든 시간 형식을 사용할 수 있습니다. 미디어에서 지원하는 경우 NPT를 사용하는 것이 좋습니다.\(MUST, MUST, SHOULD, MAY, SHOULD\)

PLAY 요청에 대한 오류 응답의 경우 서버의 응답은 현재 세션 상태에 따라 달라집니다. 세션이 준비 상태인 경우 현재 일시 중지 지점은 일시 중지 지점을 명시적 시작 지점으로, 암시적 중지 지점을 사용하여 Range 헤더를 사용하여 반환됩니다. 제한된 보존으로 인해 일시 중지 지점이 실시간으로 이동하는 시간 진행 콘텐츠의 경우 현재 일시 중지 지점이 반환됩니다. Play 상태의 세션의 경우 현재 플레이아웃 지점과

범위 요청의 나머지 부분이 반환됩니다. 0초보다 긴 보존 기간을 가진 모든 미디어의 경우 현재 유효한 Media-Range 헤더도 응답에 포함되어야 합니다.\(MUST\)

PLAY 응답에는 동기화 정보를 전달하는 헤더가 포함될 수 있습니다. 필요한 정보는 미디어 전송 형식에 따라 달라지므로 헤더와 그 사용법을 지정하는 추가 규칙이 필요합니다. RTP의 경우 RTP-Info 헤더가 지정되고\(섹션 18.45 참조\) 다음 예에서 사용됩니다.\(MAY\)

다음은 클라이언트가 3.52초부터 끝까지 미디어를 요청하는 단일 오디오 스트림에 대한 간단한 예입니다. 서버는 실제 재생 시간\(3.51\)과 함께 10ms 전의 200 OK 응답과 RTP 스택에 필요한 매개변수가 포함된 RTP-Info 헤더를 보냅니다.

```text
   C->S: PLAY rtsp://example.com/audio RTSP/2.0
         CSeq: 836
         Session: ULExwZCXh2pd0xuFgkgZJW
         Range: npt=3.52-
         User-Agent: PhonyClient/1.2

   S->C: RTSP/2.0 200 OK
         CSeq: 836
         Date: Thu, 23 Jan 1997 15:35:06 GMT
         Server: PhonyServer/1.0
         Range: npt=3.51-324.39
         Seek-Style: First-Prior
             Session: ULExwZCXh2pd0xuFgkgZJW
         RTP-Info:url="rtsp://example.com/audio"
            ssrc=0D12F123:seq=14783;rtptime=2345962545

   S->C: RTP Packet TS=2345962545 => NPT=3.51
         Media duration=0.16 seconds
```

서버는 전달될 실제 시작점으로 응답합니다. 미디어 소스에 대해 요청된 범위를 유효한 프레임 경계에 맞춰 정렬해야 하는 경우 요청된 범위와 다를 수 있습니다. 일부 미디어 스트림은 전체적으로 더 이른 지점에서 전달되어야 할 수도 있습니다. 또한 일부 미디어 형식은 개별 데이터 단위당 지속 시간이 매우 깁니다. 따라서 클라이언트가 데이터 단위를 구문 분석하고 시작할 위치를 선택해야 할 수도 있습니다. 서버는 또한 Seek-Style 헤더를 포함하여 실제 시작점을 선택하는 데 사용하는 정책을 표시해야 합니다.\(MUST\)

다음 예에서 클라이언트는 요청된 재생 시간까지 계속해서 늘어나는 첫 번째 미디어 패킷을 수신합니다. 따라서 3시 52분에서 7시 5분 사이의 시간을 사용자에게 렌더링할지 아니면 건너뛸지 여부는 클라이언트가 결정합니다. 대부분의 경우 해당 기간을 렌더링하지 않는 것이 가장 적합할 것입니다.

```text
   C->S: PLAY rtsp://example.com/audio RTSP/2.0
         CSeq: 836
         Session: ZGGyCJOs8xaLkdNK2dmxQO
         Range: npt=7.05-
         User-Agent: PhonyClient/1.2

   S->C: RTSP/2.0 200 OK
         CSeq: 836
         Date: Thu, 23 Jan 1997 15:35:06 GMT
         Server: PhonyServer/1.0
             Session: ZGGyCJOs8xaLkdNK2dmxQO
         Range: npt=3.52-
         Seek-Style: First-Prior
         RTP-Info:url="rtsp://example.com/audio"
            ssrc=0D12F123:seq=14783;rtptime=2345962545

   S->C: RTP Packet TS=2345962545 => NPT=3.52
         Duration=4.15 seconds
```

원하는 범위를 재생한 후에도 프레젠테이션은 준비 상태로 변경되지 않으며 미디어 전달이 중지됩니다. 스트림을 준비 상태로 전환해야 하는 경우 PAUSE 요청을 발행해야 합니다. 스트림이 아직 Play 상태에 있는 동안 PLAY 요청은 적법하며 중간 PAUSE 요청 없이 발행될 수 있습니다. 이러한 요청은 현재 PLAY 작업을 요청된 새 작업으로 대체해야 합니다. 즉, 요청이 준비 상태에서 수신된 것과 동일한 방식으로 처리되어야 합니다. Range 헤더의 범위에 암시적 시작 시간\("-endtime"\)이 있는 경우 서버는 지정된 끝점까지 현재 위치부터 계속 재생해야 합니다. 이는 이전 요청이 아닌 다른 지점으로 끝을 변경하는 데 유용합니다.\(MUST, MUST, MUST\)

다음 예에서는 SMPTE 시간 코드 0:10:20부터 클립 끝까지 전체 프레젠테이션을 재생합니다. 참고: RTP-Info 헤더는 여러 줄로 나누어졌으며, 그 다음 줄은 구문에서 허용하는 대로 공백으로 시작됩니다.

```text
   C->S: PLAY rtsp://audio.example.com/twister.en RTSP/2.0
         CSeq: 833
         Session: N465Wvsv0cjUy6tLqINkcf
         Range: smpte=0:10:20-
         User-Agent: PhonyClient/1.2

   S->C: RTSP/2.0 200 OK
         CSeq: 833
         Date: Thu, 23 Jan 1997 15:35:06 GMT
         Session: N465Wvsv0cjUy6tLqINkcf
         Server: PhonyServer/1.0
         Range: smpte=0:10:22-0:15:45
         Seek-Style: Next
         RTP-Info:url="rtsp://example.com/twister.en"
            ssrc=0D12F123:seq=14783;rtptime=2345962545
```

라이브 프레젠테이션의 녹화물을 재생하려면 시계 단위를 사용하는 것이 바람직할 수 있습니다.

```text
   C->S: PLAY rtsp://audio.example.com/meeting.en RTSP/2.0
         CSeq: 835
         Session: N465Wvsv0cjUy6tLqINkcf
         Range: clock=19961108T142300Z-19961108T143520Z
         User-Agent: PhonyClient/1.2

   S->C: RTSP/2.0 200 OK
         CSeq: 835
         Date: Thu, 23 Jan 1997 15:35:06 GMT
         Session: N465Wvsv0cjUy6tLqINkcf
         Server: PhonyServer/1.0
         Range: clock=19961108T142300Z-19961108T143520Z
         Seek-Style: Next
         RTP-Info:url="rtsp://example.com/meeting.en"
            ssrc=0D12F123:seq=53745;rtptime=484589019
```

---
#### **13.4.2.  Aggregated Sessions**

PLAY 요청은 단일 미디어 스트림을 제어하는 ​​세션과 여러 미디어 스트림을 제어하는 ​​집계 세션에서 작동할 수 있습니다.

집계된 세션에서 PLAY 요청은 집계된 제어 URI를 포함해야 합니다. 클라이언트 PLAY 요청-URI가 단일 미디어에 대한 것인 경우 서버는 460 오류\(집계 작업만 허용됨\)로 응답해야 합니다. 집합의 미디어는 동기화되어 재생되어야 합니다. 클라이언트가 미디어를 개별적으로 제어하려는 경우 각 미디어에 대해 별도의 RTSP 세션을 사용해야 합니다.\(MUST, MUST, MUST\)

초기 SETUP 요청\(세션 생성\) 뒤에 하나 이상의 추가 SETUP 요청이 뒤따르는 집계된 세션의 경우, 응답을 기다리지 않고 추가 SETUP 요청 후에 PLAY 요청이 파이프라인될 수 있습니다\(섹션 12\). 이 절차를 통해 세션 설정 시작부터 미디어 재생이 하나의 RTT로 시작될 때까지의 지연을 줄일 수 있습니다. 그러나 클라이언트는 이 절차를 사용하면 PLAY 처리 시, 즉 파이프라인에서 PLAY 요청 이전의 모든 요청을 처리한 후 설정된 서버 상태가 재생된다는 점을 알아야 합니다. 이 상태는 이전 요청 중 하나라도 실패하여 의도한 상태가 아닐 수 있습니다. 클라이언트는 해당 요청의 응답을 기반으로 이를 쉽게 결정할 수 있습니다. 실패할 경우 클라이언트는 PAUSE를 사용하여 미디어 재생을 중지하고 다른 PLAY 요청을 발행하기 전에 의도한 상태를 다시 설정하려고 시도할 수 있습니다.\(MAY\)

---
#### **13.4.3.  Updating Current PLAY Requests**

클라이언트는 스트림이 Play 상태에 있는 동안 PLAY 요청을 발행하여 요청을 업데이트할 수 있습니다.

준비 상태의 PLAY 요청과 비교할 때 중요한 차이점은 현재 재생 지점을 처리하고 요청의 Range 헤더가 구성되는 방식입니다. 세션은 미디어를 적극적으로 재생하고 있으며 재생 지점이 이동하므로 요청이 적용되는 정확한 시간을 예측하기 어렵습니다. PLAY 헤더가 나타나는 방식에 따라 전체 교체 또는 연속이라는 두 가지 다른 경우가 존재합니다. 전체 교체는 첫 번째 범위 사양에 명시적인 시작 값\(예: "npt=45-" 또는 "npt=45-60"\)을 갖도록 하여 신호를 보냅니다. 이 경우 서버는 현재 재생 지점에서 재생을 중지한 다음 전달을 시작합니다. Range 헤더에 따른 미디어입니다. 이는 클라이언트가 먼저 PAUSE를 보낸 다음 일시 중지 지점을 기반으로 하지 않는 새로운 PLAY 요청을 보내는 것과 같습니다. 연속의 경우 첫 번째 범위 지정자는 암시적 시작점과 명시적 중지 값\(Z\)을 갖습니다\(예: "npt=-60"\). 이는 이 PLAY 요청 이전에 재생되는 범위 지정자를 변환해야 함을 나타냅니다\( X to Y\)를 \(X to Z\)로 변환하고 원래 재생된 요청인 것처럼 계속합니다. 현재 전달 지점이 중지 지점을 벗어나면 서버는 즉시 전달을 일시 중지해야 합니다. 요청이 성공적으로 완료되었으므로 200 OK 응답으로 응답합니다. 실제 중지 지점을 나타내기 위해 스트림 끝이 포함된 PLAY\_NOTIFY도 전송됩니다. 일시정지 지점은 요청된 정지 지점으로 설정됩니다.\(MUST, MUST\)

다음은 이 동작의 예입니다. 서버는 10\~15 범위의 재생 요청을 받았습니다. 새 PLAY 요청이 이전 요청보다 4초 후에 서버에 도착하면 적용됩니다.

서버는 여전히 첫 번째 범위\(10-15\)를 재생합니다. 서버는 현재 재생을 25초로 변경합니다. 즉, 동등한 단일 요청은 "범위: npt=10-25"를 사용하는 PLAY입니다.

```text
     C->S: PLAY rtsp://example.com/fizzle/foo RTSP/2.0
           CSeq: 834
           Session: apzA8LnjQ5KWTdw0kUkiRh
           Range: npt=10-15
           User-Agent: PhonyClient/1.2

     S->C: RTSP/2.0 200 OK
           CSeq: 834
           Date: Thu, 23 Jan 1997 15:35:06 GMT
           Session: apzA8LnjQ5KWTdw0kUkiRh
           Server: PhonyServer/1.0
           Range: npt=10-15
           Seek-Style: Next
           RTP-Info:url="rtsp://example.com/fizzle/audiotrack"
                   ssrc=0D12F123:seq=5712;rtptime=934207921,
                   url="rtsp://example.com/fizzle/videotrack"
                   ssrc=789DAF12:seq=57654;rtptime=2792482193

     C->S: PLAY rtsp://example.com/fizzle/foo RTSP/2.0
           CSeq: 835
           Session: apzA8LnjQ5KWTdw0kUkiRh
           Range: npt=-25
           User-Agent: PhonyClient/1.2

     S->C: RTSP/2.0 200 OK
           CSeq: 835
           Date: Thu, 23 Jan 1997 15:35:09 GMT
           Session: apzA8LnjQ5KWTdw0kUkiRh
           Server: PhonyServer/1.0
           Range: npt=14-25
           Seek-Style: Next
           RTP-Info:url="rtsp://example.com/fizzle/audiotrack"
                   ssrc=0D12F123:seq=5712;rtptime=934239921,
                   url="rtsp://example.com/fizzle/videotrack"
                   ssrc=789DAF12:seq=57654;rtptime=2792842193
```

재생 상태에 있는 동안 PLAY 요청의 일반적인 용도는 미디어 규모를 변경하는 것입니다\(예: 빨리 감기 또는 빨리 되감기 시작 또는 종료\). 클라이언트는 이 섹션 위에서 설명한 대로 계속되거나 완전히 교체되는 업데이트 PLAY 요청을 발행할 수 있습니다. 다음은 중지 지점을 제공하지 않고 빨리 감기\(크기 = 2\)를 요청한 다음 빨리 감기에서 일반 재생\(크기 = 1\)으로 변경하는 클라이언트의 예입니다. 두 번째 PLAY에서는

요청 시 시간은 서버가 현재 재생하는 위치\(npt=now-\)로 명시적으로 설정되고 서버는 새 스케일이 실제로 적용되는 실제 재생 지점\(npt=02:17:27.144-\)으로 응답합니다.

```text
     C->S: PLAY rtsp://example.com/fizzle/foo RTSP/2.0
           CSeq: 2034
           Session: apzA8LnjQ5KWTdw0kUkiRh
           Range: npt=now-
           Scale: 2.0
           User-Agent: PhonyClient/1.2

     S->C: RTSP/2.0 200 OK
           CSeq: 2034
           Date: Thu, 23 Jan 1997 15:35:06 GMT
           Session: apzA8LnjQ5KWTdw0kUkiRh
           Server: PhonyServer/1.0
           Range: npt=02:17:21.394-
           Seek-Style: Next
           Scale: 2.0
           RTP-Info:url="rtsp://example.com/fizzle/audiotrack"
                   ssrc=0D12F123:seq=5712;rtptime=934207921,
                   url="rtsp://example.com/fizzle/videotrack"
                   ssrc=789DAF12:seq=57654;rtptime=2792482193
```

\[빨리 감기로 재생하고 이제 크기로 돌아가기 = 1\]

```text
     C->S: PLAY rtsp://example.com/fizzle/foo RTSP/2.0
           CSeq: 2035
           Session: apzA8LnjQ5KWTdw0kUkiRh
           Range: npt=now-
           Scale: 1.0
           User-Agent: PhonyClient/1.2

     S->C: RTSP/2.0 200 OK
           CSeq: 2035
           Date: Thu, 23 Jan 1997 15:35:09 GMT
           Session: apzA8LnjQ5KWTdw0kUkiRh
           Server: PhonyServer/1.0
           Range: npt=02:17:27.144-
           Seek-Style: Next
           Scale: 1.0
           RTP-Info:url="rtsp://example.com/fizzle/audiotrack"
                   ssrc=0D12F123:seq=5712;rtptime=934239921,
                   url="rtsp://example.com/fizzle/videotrack"
                   ssrc=789DAF12:seq=57654;rtptime=2792842193
```

---
#### **13.4.4.  Playing On-Demand Media**

주문형 미디어는 다음과 같은 경우 SETUP 응답의 Media-Properties 헤더 내용으로 표시됩니다\(섹션 18.29 참조\).

```text
   o  the Random Access property is set to Random-Access;

   o  the Content Modifications property is set to Immutable;
```

o 보존 속성이 무제한 또는 시간 제한으로 설정되어 있습니다.

주문형 미디어 재생은 섹션 13.4.1에 설명된 일반적인 사용법을 따릅니다.

---
#### **13.4.5.  Playing Dynamic On-Demand Media**

동적 주문형 미디어는 다음과 같은 경우 SETUP 응답의 Media-Properties 헤더 내용으로 표시됩니다\(섹션 18.29 참조\).

```text
   o  the Random Access property is set to Random-Access;

   o  the Content Modifications property is set to Dynamic;
```

o 보존 속성이 무제한 또는 시간 제한으로 설정되어 있습니다.

주문형 미디어 재생은 미디어가 변경되지 않는 한 섹션 13.4.1에 설명된 일반적인 사용법을 따릅니다.

클라이언트가 재생 상태의 미디어 리소스 변경에 대해 알 수 있는 방법에는 두 가지가 있습니다. 첫 번째는 클라이언트가 Notify-Reason 헤더가 media-properties-update로 설정된 PLAY\_NOTIFY 요청을 수신한다는 것입니다\(섹션 13.5.2 참조\). Media-Range 헤더가 PLAY\_NOTIFY 요청에 있는 경우 클라이언트는 Media-Range 헤더 값을 사용하여 추가 작업을 결정할 수 있습니다. 두 번째 방법은 클라이언트가 본문 없이 Media-Range 헤더를 포함하여 GET\_PARAMETER 요청을 발행하는 것입니다. 200 OK 응답에는 현재 Media-Range 헤더가 포함되어야 합니다\(섹션 18.30 참조\).\(MUST\)

---
#### **13.4.6.  Playing Live Media**

라이브 미디어는 다음과 같은 경우 SETUP 응답의 Media-Properties 헤더 내용으로 표시됩니다\(섹션 18.29 참조\).

```text
   o  the Random Access property is set to No-Seeking;

   o  the Content Modifications property is set to Time-Progressing;
```

o Retention 속성의 Time-Duration은 0.0으로 설정됩니다.

라이브 미디어의 경우 SETUP 200 OK 응답에는 Media-Range 헤더가 포함되어야 합니다\(섹션 18.30 참조\).\(MUST\)

클라이언트는 Range 헤더 없이 PLAY 요청을 보낼 수 있습니다. 요청에 Range 헤더가 포함된 경우 "현재"를 나타내는 기호 값을 사용해야 합니다. NPT의 경우 해당 범위 지정은 "npt=now-"입니다. 서버는 응답에 Range 헤더를 포함해야 하며, 이는 기호 값이 아닌 명시적인 시간 값을 나타내야 합니다. 즉, 응답에 "npt=now-"를 사용할 수 없습니다. 대신, 세션 시작 이후의 시간을 개방 간격으로 표시하는 것이 좋습니다\(예: "npt=96.23-"\). 해당 시간에 대한 절대 시간 값\(시계\)이 제공될 수 있습니다\(예: "clock=20030213T143205Z-"\). 절대 시간 형식은 클라이언트가 Accept-Ranges 헤더를 사용하여 이에 대한 지원을 표시한 경우에만 사용할 수 있습니다.\(MAY, MUST, MUST, MAY\)

---
#### **13.4.7.  Playing Live with Recording**

특정 미디어 서버는 클라이언트에게 라이브 세션 녹음 서비스를 제공할 수 있습니다. 이 녹화는 일반적으로 미디어 세션 시작 부분부터 이루어집니다. 클라이언트는 지금부터 미디어 세션 시작 사이에 미디어에 무작위로 액세스할 수 있습니다. 녹화가 포함된 이 라이브 미디어는 다음과 같은 경우 SETUP 응답의 Media-Properties 헤더 내용으로 표시됩니다\(섹션 18.29 참조\).

```text
   o  the Random Access property is set to Random-Access;

   o  the Content Modifications property is set to Time-Progressing;
```

o 보존 속성이 Time-Limited 또는 Unlimited로 설정되어 있습니다.

SETUP 200 OK 응답에는 이러한 유형의 미디어에 대한 Media-Range 헤더\(섹션 18.30 참조\)가 포함되어야 합니다. 녹화가 포함된 라이브 미디어의 경우 Range 헤더는 미디어의 현재 전달 지점을 나타내고 Media-Range 헤더는 현재 시간 주변에서 현재 사용 가능한 미디어 창을 나타냅니다. 이 창에서는 과거에 녹화된 콘텐츠\(미디어에 현재 시간에 표시됨\) 또는 미래에 녹화된 콘텐츠\(미디어에 현재 시간에 표시됨\)를 다룰 수 있습니다. 서버는 창의 요청된 테두리에 맞게 배달 지점을 조정합니다. 클라이언트가 녹음 창 외부에 있는 전달 지점을 요청하는 경우\(예: 요청한 지점이 너무 먼 과거인 경우\) 서버는 녹음에서 가장 오래된 지점을 선택합니다. 클라이언트가 녹음이 포함된 라이브 미디어를 전달하는 동안 1.0\(일반 재생 속도\)이 아닌 스케일\(섹션 18.46\) 값으로 전달을 요청하는 경우 섹션 13.5.3의 고려 사항이 적용됩니다.\(MUST\)

---
#### **13.4.8.  Playing Live with Time-Shift**

특정 미디어 서버는 클라이언트에게 타임시프트 서비스를 제공할 수 있습니다. 이 타임 시프트는 과거의 고정 간격, 즉 슬라이딩 윈도우 기록 메커니즘을 기록하지만 이 간격을 지나지는 않습니다. 클라이언트는 지금부터 해당 간격까지 미디어에 무작위로 액세스할 수 있습니다. 녹화가 포함된 이 라이브 미디어는 다음과 같은 경우 SETUP 응답의 Media-Properties 헤더 내용으로 표시됩니다\(섹션 18.29 참조\).

```text
   o  the Random Access property is set to Random-Access;

   o  the Content Modifications property is set to Time-Progressing;
```

o Retention 속성은 Time-Duration으로 설정되고 기록 간격\(\>0\)을 나타내는 값이 설정됩니다.

SETUP 200 OK 응답에는 이러한 유형의 미디어에 대한 Media-Range 헤더\(섹션 18.30 참조\)가 포함되어야 합니다. 녹화가 포함된 라이브 미디어의 경우 Range 헤더는 미디어의 현재 시간을 나타내고 Media-Range 헤더는 현재 시간 주변의 창을 나타냅니다. 이 창에서는 과거에 녹화된 콘텐츠\(미디어에 현재 시간에 표시됨\) 또는 미래에 녹화된 콘텐츠\(미디어에 현재 시간에 표시됨\)를 다룰 수 있습니다. 클라이언트가 녹음 창 외부에 있는 재생 지점을 요청하는 경우\(예를 들어 너무 오래 전에 요청한 경우\) 서버는 재생 지점을 창의 요청된 테두리로 조정합니다. 서버는 녹음에서 가장 오래된 범위를 선택합니다. 클라이언트가 타임 시프트로 라이브 미디어를 전달하는 동안 1.0\(일반 재생 속도\) 이외의 배율\(18.46항\) 값을 사용하여 전달을 요청하는 경우 섹션 13.5.3의 고려 사항이 적용됩니다.\(MUST\)

---
### **13.5.  PLAY_NOTIFY**

PLAY\_NOTIFY 메서드는 클라이언트에 Play 상태의 세션에 대한 비동기 이벤트를 알리기 위해 서버에서 실행됩니다. 세션 헤더는 PLAY\_NOTIFY 요청에 표시되어야 하며 요청 범위를 나타냅니다. PLAY\_NOTIFY 요청을 보내려면 서버와 클라이언트 간의 지속적인 연결이 필요합니다. 그렇지 않으면 서버가 이 요청 메서드를 클라이언트에 보낼 방법이 없습니다.\(MUST\)

PLAY\_NOTIFY 요청은 Session 헤더를 전달하고 지정된 세션에만 적용되므로 종단 간\(즉, 서버에서 클라이언트로\) 범위를 갖습니다. 클라이언트는 즉시 서버에 응답을 반환해야 합니다.\(SHOULD\)

PLAY\_NOTIFY 요청은 알림 범위에 따라 집계 제어 URI와 개별 미디어 리소스 URI를 모두 사용할 수 있습니다. 이 범위는 집계된 세션에 대해 중요한 차이점을 가질 수 있으며, PLAY\_NOTIFY 요청의 각 이유는 해석을 지정하고 집계된 제어 URI 또는 ​​개별 URI가 요청에 사용될 수 있는지 여부를 지정해야 합니다.\(MAY\)

PLAY\_NOTIFY 요청은 Notify-Reason 헤더 값에 따라 메시지 본문과 함께 사용될 수 있습니다. 메시지 본문이 사용되는 경우 각 Notify-Reason에 대한 특정 섹션에 설명되어 있습니다. 그러나 현재 메시지 본문 사용을 허용하는 Notify-Reason은 없습니다. 이 경우 메시지 본문을 사용하려는 새로운 Notify-Reasons를 추가할 때 몇 가지 제한 사항을 준수해야 합니다. 서버는 모든 유형의 메시지 본문을 보낼 수 있지만 클라이언트가 수신된 메시지 본문을 이해할 수 있는지는 보장되지 않습니다. . 이는 DESCRIBE\(섹션 13.2 참조\)와 관련이 있습니다. 그러나 이 특별한 경우 클라이언트는 Accept 헤더를 사용하여 허용 가능한 메시지 본문을 명시할 수 있습니다. PLAY\_NOTIFY의 경우 서버는 클라이언트가 어떤 메시지 본문을 이해하는지 알 수 없습니다.

Notify-Reason 헤더\(18.32절 참조\)는 서버가 PLAY\_NOTIFY 요청을 보내는 이유를 지정합니다. 이는 확장 가능하며 향후 새로운 이유가 추가될 수 있습니다\(섹션 22.8 참조\). 클라이언트가 알림 이유를 이해하지 못하는 경우 465\(알림 이유 알 수 없음\)\(섹션 17.4.29\) 오류 코드로 응답해야 합니다. 이 문서는 서버가 다음 유형의 Notify-Reason 값과 함께 PLAY\_NOTIFY를 보내는 방법을 정의합니다.\(MUST\)

```text
   o  end-of-stream (see Section 13.5.1);

   o  media-properties-update (see Section 13.5.2);

   o  scale-change (see Section 13.5.3).
```

---
#### **13.5.1.  End-of-Stream**

Notify-Reason 헤더가 end-of-stream으로 설정된 PLAY\_NOTIFY 요청은 PLAY 요청이 완료되었거나 거의 완료되었으며 미디어 스트림 전달이 종료되었음을 나타냅니다. 서버가 Play 상태가 아니면 요청을 발행해서는 안 됩니다. 미디어 스트림 전달 알림의 끝은 현재 제공되는 PLAY 요청이 성공적으로 완료되었음을 나타내거나 일부 오류로 인해 요청을 완료하지 못했음을 나타내는 데 사용될 수 있습니다. Request-Status 헤더\(18.42절\)는 알림이 어떤 요청에 대한 것인지와 그 완료 상태를 나타내기 위해 포함되어야 합니다. 메시지 응답 상태 코드\(8.1.1절\)는 PLAY 요청이 어떻게 완료되었는지 나타내는 데 사용됩니다. PLAY\_NOTIFY의 발신자는 업데이트된 PLAY\_NOTIFY를 발행할 수 있습니다.\(MUST NOT, MUST, MAY\)

PLAY\_NOTIFY가 잘못된 정보로 전송되었습니다. 예를 들어, 스트림의 끝 부분에 도달하기 전에 PLAY\_NOTIFY가 발행되었지만 일부 오류가 발생하여 이전에 전송된 PLAY\_NOTIFY에 스트림이 끝나는 잘못된 시간이 포함되었습니다. 이 경우 올바른 완료 상태와 모든 추가 정보를 포함하여 새로운 PLAY\_NOTIFY를 전송해야 합니다.\(MUST\)

스트림 끝으로 설정된 Notify-Reason 헤더가 있는 PLAY\_NOTIFY 요청은 스케일 값이 1이 아닌 경우 Range 헤더와 Scale 헤더를 포함해야 합니다. Range 헤더는 전송이 타임스케일로 끝나는 스트림의 지점을 나타냅니다. 요청이 이행되기 위해 PLAY 응답에서 서버가 사용한 것입니다. 서버는 Range 헤더에 "now" 상수를 사용해서는 안 됩니다. 적절한 시간 척도에서 실제 숫자 끝 위치를 사용해야 합니다. 마지막 미디어 패킷을 전송하기 전에 스트림 끝 알림이 발행되면 이는 Range 헤더의 종료 시간이 클라이언트가 수신하는 미디어의 현재 시간을 초과하기 때문에 분명해집니다\(예: "npt=- 15"\(npt가 현재 14.2초인 경우\) 미디어 시간 척도가 뒤로 이동하거나 기본 속도가 아닌 경우 이를 분명하게 알 수 있도록 Scale 헤더가 포함됩니다. 스트림 종료 알림은 클라이언트가 새 PLAY 요청을 보내는 것을 막지 않습니다.\(MUST, MUST NOT\)

RTP가 미디어 전송으로 사용되는 경우 RTP-Info 헤더가 포함되어야 하며 RTP-Info 헤더는 시퀀스 매개변수의 마지막 시퀀스 번호를 나타내야 합니다.\(MUST\)

미디어 리소스가 통합적으로 제어되는 RTSP 세션의 경우 미디어 리소스는 일반적으로 거의 동시에 종료되지만 몇 백 밀리초 단위의 작은 차이가 있을 수 있습니다. 이러한 경우 집계된 제어를 받는 RTSP 세션은 단일 PLAY\_NOTIFY 요청만 보내야 합니다\(SHOULD\). PLAY\_NOTIFY 요청에서 집계 제어 URI를 사용하여 RTSP 서버는 이것이 세션 내의 모든 미디어 리소스에 적용됨을 나타냅니다. 미디어 전달을 위해 RTP가 사용되는 경우 모든 미디어 리소스에 해당 RTP-Info가 포함되어야 합니다. 하나 이상의 미디어 리소스가 집계된 세션의 다른 리소스보다 훨씬 짧은 기간을 갖는 경우 서버는 개별 미디어 리소스 URI를 사용하여 스트림 끝 알림을 보내 에이전트에 이에 대한 미디어가 더 이상 없음을 나타낼 수 있습니다. 현재 활성 PLAY 요청과 관련된 특정 미디어 리소스. 이러한 경우 나머지 미디어 리소스가 스트림 끝에 오면 더 이상 리소스가 남아 있지 않음을 나타내기 위해 집계 제어 URI를 사용하여 PLAY\_NOTIFY 요청을 보내야 합니다.\(SHOULD, MAY, MUST\)

스트림 끝으로 설정된 Notify-Reason 헤더가 있는 PLAY\_NOTIFY 요청은 메시지 본문을 전달해서는 안 됩니다.\(MUST NOT\)

이 요청 예시는 클라이언트에게 향후 스트림 종료 이벤트에 대해 알립니다.

```text
     S->C: PLAY_NOTIFY rtsp://example.com/fizzle/foo RTSP/2.0
           CSeq: 854
           Notify-Reason: end-of-stream
           Request-Status: cseq=853 status=200 reason="OK"
           Range: npt=-145
           RTP-Info:url="rtsp://example.com/fizzle/foo/audio"
              ssrc=0D12F123:seq=14783;rtptime=2345962545,
              url="rtsp://example.com/fizzle/video"
              ssrc=789DAF12:seq=57654;rtptime=2792482193
           Session: CDtUJfDQXJWtJ7Iqua2xOi
           Date: Mon, 08 Mar 2010 13:37:16 GMT

     C->S: RTSP/2.0 200 OK
           CSeq: 854
           User-Agent: PhonyClient/1.2
           Session: CDtUJfDQXJWtJ7Iqua2xOi
```

---
#### **13.5.2.  Media-Properties-Update**

Notify-Reason 헤더가 media-properties-update로 설정된 PLAY\_NOTIFY 요청은 지정된 세션\(섹션 18.29 참조\)에 대한 미디어 속성의 업데이트 또는 Media-Range 헤더에 표시된 대로 재생할 수 있는 사용 가능한 미디어 범위를 나타냅니다\( 섹션 18.30\). Notify-Reason 헤더가 media-properties-update로 설정된 PLAY\_NOTIFY 요청은 Media-Properties 및 Date 헤더를 포함해야 하며 Media-Range 헤더를 포함해야 합니다. Media-Properties 헤더에는 세션 범위가 있습니다. 따라서 집계된 세션의 경우 PLAY\_NOTIFY 요청은 집계된 제어 URI를 사용해야 합니다.\(MUST, MUST\)

이 알림은 재생 미디어 범위에 사용 가능한 범위가 벽시계 시간에 따라 어떻게 진행되는지에 대한 추정 기준을 변경하는 이벤트가 발생할 때마다 시간이 진행되는 미디어에 대해 전송되어야 합니다. 또한 클라이언트 추정의 장기적인 안정성을 보장하고 클라이언트에 의한 시계 왜곡 감지를 허용하기 위해 서버가 시간 진행 콘텐츠에 대해 약 5분마다 이러한 알림을 보내는 것이 좋습니다. 알림 간격은 1분 이상 2시간 미만이어야 합니다. 방금 설명한 이유로 인해 요청에는 현재 미디어 기간을 제공하는 Media-Range 헤더와 현재 재생 지점 및 요청 범위의 나머지 부분을 나타내는 Range 헤더가 포함되어야 합니다.\(MUST, SHOULD, MUST\)

- 5분마다 업데이트를 보내는 것이 권장되는 이유는 시계 오차 문제 때문입니다. 5분 후에는 미디어 재생 및 동기화에 사용되지 않고 사용자가 사용할 수 있는 콘텐츠를 결정하는 데만 사용되므로 시계 오차가 너무 커져서는 안 됩니다.

Media-Properties-update로 설정된 Notify-Reason 헤더가 있는 PLAY\_NOTIFY 요청은 메시지 본문을 전달해서는 안 됩니다.\(MUST NOT\)

```text
    S->C: PLAY_NOTIFY rtsp://example.com/fizzle/foo RTSP/2.0
           Date: Tue, 14 Apr 2008 15:48:06 GMT
           CSeq: 854
           Notify-Reason: media-properties-update
           Session: CDtUJfDQXJWtJ7Iqua2xOi
           Media-Properties: Time-Progressing,
                 Time-Limited=20080415T153919.36Z, Random-Access=5.0
           Media-Range: npt=00:00:00-01:37:21.394
           Range: npt=01:15:49.873-

     C->S: RTSP/2.0 200 OK
           CSeq: 854
           User-Agent: PhonyClient/1.2
           Session: CDtUJfDQXJWtJ7Iqua2xOi
```

---
#### **13.5.3.  Scale-Change**

클라이언트가 1.0\(정상 재생 속도\)이 아닌 스케일\(18.46절\) 값을 사용하여 전달을 요청하는 경우 서버는 재생 시간당 미디어 시간의 비율을 강제로 변경해야 할 수 있습니다. 일부 보존이 있는 시간 진행 미디어의 경우\(예: 서버가 이미 전송된 콘텐츠를 저장함\) 1보다 큰 배율 값으로 재생을 요청하는 클라이언트가 미디어의 프런트 엔드를 따라잡을 수 있습니다. 그러면 서버는 scale = 1에서만 콘텐츠를 사용할 수 있게 되므로 1보다 큰 규모의 콘텐츠를 계속 제공할 수 없습니다. 또 다른 경우는 scale < 1이고 미디어 보존 기간이 Time-Duration으로 제한되는 경우입니다. 이 경우 전달 지점은 사용 가능한 가장 오래된 미디어 장치에 도달할 수 있으며 사용 가능한 미디어가 없으므로 이 규모에서 추가 재생이 불가능해집니다. 클라이언트에서 미디어가 손실되는 것을 방지하려면 미디어가 스토리지 버퍼에서 제거되는 것과 동일한 속도\(일반적으로 규모 = 1.0\)로 배율을 조정해야 합니다.

또 다른 경우는 콘텐츠 자체가 분할된 조각으로 구성되거나 동적으로 업데이트되는 경우입니다. 이러한 경우 서버는 지원되는 배율 값\(배율 = 1.0과 다름\)에서 다른 배율 값으로 변경해야 할 수 있습니다. 이 경우 서버는 가장 가까운 값을 선택하고

클라이언트에게 무엇을 선택했는지 알려줍니다. 이러한 경우 미디어 속성도 전송되어 지원되는 배율 값을 업데이트합니다. 이를 통해 클라이언트는 사용되는 배율 값을 조정할 수 있습니다.

위의 경우 재생에 미치는 영향을 최소화하려면 서버는 재생 속성을 수정하고, 크기를 지원 가능한 값으로 설정하고, 미디어를 계속 전달해야 합니다. 이 수정을 수행할 때 Notify-Reason 헤더가 "scale-change"로 설정된 PLAY\_NOTIFY 메시지를 보내야 합니다. 요청에는 변경 사항이 적용된 미디어 시간이 포함된 Range 헤더, 사용 중인 새 값이 포함된 Scale 헤더, 적용되는 세션에 대한 식별자가 포함된 Session 헤더, 서버 벽시계 시간이 포함된 Date 헤더가 포함되어야 합니다. 변화의. 시간이 지남에 따라 진행되는 콘텐츠의 경우 이 시점의 Media-Range 및 Media-Properties 헤더도 포함되어야 합니다. 지원되는 배율 값\("Scales"\)을 변경하는 콘텐츠로 인해 배율 변경이 발생한 경우 Media-Properties 헤더를 포함해야 합니다.\(MUST, MUST, MUST, MUST, MUST\)

RTP를 사용하여 전달되는 미디어 스트림의 경우 RTP-Info 헤더도 포함되어야 합니다. 해당 미디어의 변경 지점에 해당하는 값과 선택적으로 시퀀스 번호를 포함하는 rtptime 매개변수를 포함해야 합니다.\(MUST, MUST\)

집계된 세션에 대한 PLAY\_NOTIFY 요청은 요청에서 집계된 제어 URI를 사용해야 합니다. 집계된 세션의 규모 변경은 집계의 일부인 모든 미디어 스트림에 적용됩니다.\(MUST\)

Notify-Reason 헤더가 "Scale-Change"로 설정된 PLAY\_NOTIFY 요청은 메시지 본문을 전달해서는 안 됩니다.\(MUST NOT\)

```text
     S->C: PLAY_NOTIFY rtsp://example.com/fizzle/foo RTSP/2.0
           Date: Tue, 14 Apr 2008 15:48:06 GMT
           CSeq: 854
           Notify-Reason: scale-change
           Session: CDtUJfDQXJWtJ7Iqua2xOi
           Media-Properties: Time-Progressing,
                 Time-Limited=20080415T153919.36Z, Random-Access=5.0
           Media-Range: npt=00:00:00-01:37:21.394
           Range: npt=01:37:21.394-
           Scale: 1
           RTP-Info: url="rtsp://example.com/fizzle/foo/audio"
               ssrc=0D12F123:rtptime=2345962545,
               url="rtsp://example.com/fizzle/foo/videotrack"
               ssrc=789DAF12:seq=57654;rtptime=2792482193

     C->S: RTSP/2.0 200 OK
           CSeq: 854
           User-Agent: PhonyClient/1.2
           Session: CDtUJfDQXJWtJ7Iqua2xOi
```

---
### **13.6.  PAUSE**

PAUSE 요청으로 인해 스트림 전달이 즉시 중단됩니다. PAUSE 요청은 집계된 세션에 대해 집계된 제어 URI를 사용하여 모든 미디어가 중지되도록 하거나 집계되지 않은 세션에 대한 미디어 URI를 사용하여 이루어져야 합니다. 집계된 세션에서 PAUSE 요청으로 단일 미디어를 음소거하려는 모든 시도는 460\(집계 작업만 허용됨\) 오류로 응답해야 합니다. 재생을 재개한 후에는 트랙의 동기화가 유지되어야 합니다. 모든 서버 리소스는 유지되지만 서버는 SETUP 메시지에 있는 Session 헤더의 timeout 매개변수로 지정된 기간 동안 일시 중지된 후 세션을 닫고 리소스를 해제할 수 있습니다.\(MUST, MUST, MUST, MAY\)

```text
   Example:

     C->S: PAUSE rtsp://example.com/fizzle/foo RTSP/2.0
           CSeq: 834
           Session: OoOUPyUwt0VeY9fFRHuZ6L
           User-Agent: PhonyClient/1.2

     S->C: RTSP/2.0 200 OK
           CSeq: 834
           Date: Thu, 23 Jan 1997 15:35:06 GMT
                   Session: OoOUPyUwt0VeY9fFRHuZ6L
           Range: npt=45.76-75.00
```

PAUSE 요청은 메시지 수신 즉시 스트림 전달을 중단하고 일시 중지 지점은 프레젠테이션의 현재 지점으로 설정됩니다. 미디어 스트림의 일시 중지 지점을 유지해야 합니다. Range 헤더가 없는 후속 PLAY 요청은 일시 중지 지점에서 재개되고 미디어가 끝날 때까지 재생됩니다.

PAUSE 요청 후의 일시 중지 지점은 PLAY 요청 범위 중 아직 재생되지 않은 항목과 함께 Range 헤더를 추가하여 클라이언트에 반환되어야 합니다. 무작위 액세스 속성이 있는 미디어의 경우 범위 요청 재생을 재개하려면 PAUSE 응답의 Range 헤더를 포함하고 PLAY 요청의 Next 정책과 함께 Seek-Style 헤더를 포함하면 됩니다. 시간이 진행되고 보존 기간=0인 미디어의 경우 미디어 전달을 다시 시작하기 위한 후속 PLAY 요청은 PAUSE에 대한 응답에 제공된 응답이 아닌 "npt=now-"를 사용해야 합니다.\(MUST, MUST\)

```text
     C->S: PLAY rtsp://example.com/fizzle/foo RTSP/2.0
           CSeq: 834
           Session: OccldOFFq23KwjYpAnBbUr
           Range: npt=10-30
           User-Agent: PhonyClient/1.2

     S->C: RTSP/2.0 200 OK
           CSeq: 834
           Date: Thu, 23 Jan 1997 15:35:06 GMT
           Server: PhonyServer/1.0
           Range: npt=10-30
           Seek-Style: First-Prior
           RTP-Info:url="rtsp://example.com/fizzle/audiotrack"
                   ssrc=0D12F123:seq=5712;rtptime=934207921,
                   url="rtsp://example.com/fizzle/videotrack"
                   ssrc=4FAD8726:seq=57654;rtptime=2792482193
           Session: OccldOFFq23KwjYpAnBbUr
```

11초 후, 즉 프레젠테이션 시작 21초 후:

```text
     C->S: PAUSE rtsp://example.com/fizzle/foo RTSP/2.0
           CSeq: 835
           Session: OccldOFFq23KwjYpAnBbUr
           User-Agent: PhonyClient/1.2

     S->C: RTSP/2.0 200 OK
           CSeq: 835
           Date: 23 Jan 1997 15:35:17 GMT
           Server: PhonyServer/1.0
           Range: npt=21-30
           Session: OccldOFFq23KwjYpAnBbUr
```

클라이언트가 PAUSE 요청을 발행하고 서버가 확인하고 준비 상태로 들어가는 경우, 플레이어가 또 다른 PAUSE를 발행하는 경우 적절한 서버 응답은 여전히 ​​200 OK입니다. 200 OK 응답에는 현재 일시 중지 지점이 있는 Range 헤더가 포함되어야 합니다. 아래 예를 참조하세요.\(MUST\)

```text
     C->S: PAUSE rtsp://example.com/fizzle/foo RTSP/2.0
           CSeq: 834
           Session: OccldOFFq23KwjYpAnBbUr
           User-Agent: PhonyClient/1.2

     S->C: RTSP/2.0 200 OK
           CSeq: 834
           Session: OccldOFFq23KwjYpAnBbUr
           Date: Thu, 23 Jan 1997 15:35:06 GMT
           Range: npt=45.76-98.36

     C->S: PAUSE rtsp://example.com/fizzle/foo RTSP/2.0
           CSeq: 835
           Session: OccldOFFq23KwjYpAnBbUr
           User-Agent: PhonyClient/1.2

     S->C: RTSP/2.0 200 OK
           CSeq: 835
           Session: OccldOFFq23KwjYpAnBbUr
           Date: 23 Jan 1997 15:35:07 GMT
           Range: npt=45.76-98.36
```

---
### **13.7.  TEARDOWN**
---
#### **13.7.1.  Client to Server**

TEARDOWN 클라이언트-서버 요청은 지정된 URI에 대한 스트림 전달을 중지하고 이와 관련된 리소스를 해제합니다. TEARDOWN 요청은 집계된 URI 또는 ​​미디어 제어 URI에서 수행될 수 있습니다. 단, 현재 상태에 따라 일부 제한사항이 적용됩니다. TEARDOWN 요청에는 요청이 적용되는 세션을 나타내는 세션 헤더가 포함되어야 합니다. TEARDOWN 요청에는 Terminate-Reason 헤더가 포함되어서는 안 됩니다.\(MUST, MUST NOT\)

집계된 제어 URI 또는 ​​집계되지 않은 제어 하의 세션\(단일 미디어 세션\)의 미디어 URI를 사용하는 TEARDOWN은 모든 상태\(준비 및 재생\)에서 수행될 수 있습니다. 요청이 성공하면 미디어 전달이 즉시 중단되고 세션 상태가 파기되어야 합니다. 이는 응답에 세션 헤더가 없음을 통해 표시되어야 합니다.\(MAY, MUST, MUST\)

집계된 세션에서 미디어 URI를 사용하는 TEARDOWN은 준비 상태에서만 수행할 수 있습니다. 이러한 요청은 세션에서 표시된 미디어 스트림 및 관련 리소스만 제거합니다. 요청이 완료된 후 세션에는 단일 미디어만 포함되므로 세션이 비집계 제어로 돌아갈 수 있습니다. TEARDOWN 요청을 처리한 후에 존재할 세션은 해당 TEARDOWN 요청에 대한 응답으로 세션 헤더를 포함해야 합니다.\(MUST\)

따라서 Session 헤더의 존재는 세션이 아직 존재하거나 제거되었는지 응답 수신자에게 알려줍니다.

```text
   Example:

     C->S: TEARDOWN rtsp://example.com/fizzle/foo RTSP/2.0
           CSeq: 892
           Session: OccldOFFq23KwjYpAnBbUr
           User-Agent: PhonyClient/1.2

     S->C: RTSP/2.0 200 OK
           CSeq: 892
           Server: PhonyServer/1.0
```

---
#### **13.7.2.  Server to Client**

서버는 서버에서 클라이언트 방향으로 TEARDOWN 요청을 보내 서버가 진행 중인 세션을 강제로 종료했음을 나타낼 수 있습니다. 이는 백업을 사용할 수 없는 서버 유지 관리 또는 세션이 장기간 비활성 상태인 등 여러 가지 이유로 발생할 수 있습니다. 이유는 Terminate-Reason 헤더\(섹션 18.52\)에 제공됩니다.

RTSP 클라이언트가 장기간 동안 비활성 상태인 RTSP 세션을 유지한 경우 서버는 리소스를 회수할 수 있습니다. 이는 Terminate-Reason을 "Session-Timeout"으로 설정하여 TEARDOWN 요청을 발행하여 수행됩니다. 이는 클라이언트가 두 번 이상의 세션 시간 초과 기간\(18.49절\) 동안 RTSP 세션에서 비활성 상태였을 때 수행될 수 있습니다. 그러나 서버는 세션 시간 초과 기간의 10배에 해당하는 비활성 기간이 지날 때까지 이 작업을 수행하지 않는 것이 좋습니다. 이 연장된 비활성 기간을 실제로 구성하는 것은 RTSP 서버 운영자의 몫입니다. 운영자는 이 구성을 수행할 때 제공되는 콘텐츠가 무엇인지, 그리고 이것이 장기간 비활성 상태에 대해 무엇을 의미하는지 고려해야 합니다.\(MAY, SHOULD NOT\)

서버가 설정된 세션에 대한 서비스 제공을 중지해야 하고 REDIRECT 요청에서 가리킬 서버가 없는 경우 TEARDOWN을 사용하여 세션을 종료해야 합니다. 이 방법은 복구 불가능한 내부 오류가 발생하고 서버가 세션을 종료하는 것 외에 다른 옵션이 없는 경우에도 사용할 수 있습니다.\(MUST\)

TEARDOWN 요청은 세션 집계 제어 URI에서만 이루어져야 하며\(즉, 세션 집계인 경우 개별 미디어 스트림을 종료하는 것이 허용되지 않음\) Session 및 Terminate-Reason 헤더를 포함해야 합니다. 요청은 세션 헤더에서 식별된 세션에만 적용됩니다. 서버는 "user-msg" 매개변수를 사용하여 클라이언트 사용자에게 보내는 메시지를 포함할 수 있습니다.\(MUST\)

TEARDOWN 요청은 세션 헤더 없이 와일드카드 URI "\*"에서 수행될 수도 있습니다. 이러한 요청의 범위는 다음 홉\(즉, 서버와 직접 통신하는 RTSP 에이전트\)으로 제한되며, 다음 홉 RTSP 에이전트와 서버 간의 RTSP 연결에도 적용됩니다. 이 요청은 연결을 통해 관리되고 있는 모든 세션과 보류 중인 요청이 종료되었음을 나타냅니다. 모든 개입 프록시는 나열된 순서대로 다음을 모두 수행해야 합니다.\(SHOULD\)

1. TEARDOWN 요청에 응답

2. 요청 서버에서 제어 채널 연결을 끊습니다.

```text
   3.  pass the TEARDOWN request to each applicable client (typically
       those clients with an active session or an unanswered request)
```

- 참고: 프록시는 클라이언트로부터 TEARDOWN 응답을 수락할 책임이 있습니다. 이러한 응답은 리디렉션 시 원본 서버나 대상 서버로 전달되어서는 안 됩니다.\(MUST NOT\)

---
### **13.8.  GET_PARAMETER**

GET\_PARAMETER 요청은 URI에 지정된 프리젠테이션이나 스트림에 대해 지정된 매개변수의 값을 검색합니다. 요청에 세션 헤더가 있는 경우 매개변수 값은 지정된 세션 컨텍스트에서 검색되어야 합니다. 검색할 매개변수를 지정하는 방법에는 두 가지가 있습니다.\(MUST\)

첫 번째 접근 방식에는 이 목적으로 사용할 수 있도록 정의된 헤더가 포함됩니다. 이 목적을 위한 헤더는 값 검색을 나타낼 때 가짜 데이터를 지정하지 않아도 되도록 비어 있거나 제거된 값 부분을 허용해야 합니다. 요청이 성공적으로 완료되었다는 사실은 응답에 입력된 값을 통해서도 분명하게 알 수 있습니다. GET\_PARAMETER를 사용하여 현재 값을 검색하는 데 사용할 수 있는 이 사양의 헤더는 다음과 같습니다. 나중에 추가 헤더를 지정할 수 있습니다.\(MAY\)

```text
   o  Accept-Ranges

   o  Media-Range

   o  Media-Properties

   o  Range

   o  RTP-Info
```

다른 방법은 검색하려는 매개변수를 나열하는 메시지 본문을 지정하는 것입니다. Content-Type 헤더\(섹션 18.19\)는 메시지 본문의 형식을 지정하는 데 사용됩니다. 요청 수신자가 메시지 본문에 사용된 미디어 유형을 지원하지 않는 경우 오류 코드 415\(지원되지 않는 미디어 유형\)를 사용하여 응답해야 합니다. GET\_PARAMETER 요청에 대한 응답자는 응답 요청의 미디어 유형을 사용해야 합니다. 메시지 본문 협상에 관한 추가 고려 사항은 섹션 9.3을 참조하세요.\(MUST, MUST\)

GET\_PARAMETER 요청에 대한 응답 지원을 구현하는 RTSP 에이전트는 "텍스트/매개변수" 형식\(부록 F\)을 구현해야 합니다. 이는 알려진 매개변수 형식 중 하나 이상을 구현하여 매개변수 형식 협상 실패를 방지하기 위한 것입니다.\(MUST\)

메시지 본문 내에 지정된 매개변수는 요청을 수신하는 에이전트가 모두 이해해야 합니다. 하나 이상의 매개변수가 이해되지 않으면 이해되지 않은 매개변수를 나열하는 본문을 포함하여 451\(매개변수 이해 안 됨\)을 전송해야 합니다. 모든 매개변수를 이해하면 해당 값이 채워지고 응답 메시지 본문에 반환됩니다.\(MUST\)

이 메서드는 메시지 본문이나 연결 유지를 위해 매개 변수를 요청하는 헤더 없이도 사용할 수 있습니다. 성공적인 요청에 대해 연결 유지 타이머가 업데이트되었습니다. 즉, 200 OK 응답이 수신되었습니다. 그러한 요청에 존재하는 필수 헤더가 아닐 수도 있고 처리되지 않았을 수도 있습니다. 일반적으로 헤더에 채워진 값이 있으면 헤더가 처리되었음을 나타냅니다. 그러나 이를 판단하기 어려운 경우에는 기능 태그와 Require 헤더를 사용하는 것이 좋습니다. 이러한 이유로 검색할 매개변수를 헤더를 사용하는 것보다 본문에 전송하는 것이 일반적으로 더 쉽습니다.

```text
   Example:

     S->C: GET_PARAMETER rtsp://example.com/fizzle/foo RTSP/2.0
           CSeq: 431
           User-Agent: PhonyClient/1.2
           Session: OccldOFFq23KwjYpAnBbUr
           Content-Length: 26
           Content-Type: text/parameters

           packets_received
           jitter

     C->S: RTSP/2.0 200 OK
           CSeq: 431
           Session: OccldOFFq23KwjYpAnBbUr
           Server: PhonyServer/1.1
           Date: Mon, 08 Mar 2010 13:43:23 GMT
           Content-Length: 38
           Content-Type: text/parameters

           packets_received: 10
           jitter: 0.3838
```

---
### **13.9.  SET_PARAMETER**

이 메소드는 URI에 의해 지정된 프리젠테이션 또는 스트림에 대한 매개변수 값 또는 매개변수 세트의 설정을 요청합니다. 요청에 세션 헤더가 있는 경우 매개변수 값은 지정된 세션 컨텍스트에서 검색되어야 합니다. 이 메소드는 메시지 본문 없이도 사용될 수 있습니다. 이는 연결 유지 타이머를 업데이트할 목적으로만 보낸 요청에 사용하는 것이 권장되는 방법입니다. 이 요청이 성공하면, 즉 200 OK 응답이 수신되면 연결 유지 타이머가 업데이트된 것입니다. 그러한 요청에 존재하는 필수 헤더가 아닐 수도 있고 처리되지 않았을 수도 있습니다. 클라이언트가 그러한 헤더가 처리되었는지 확인할 수 있도록 하려면 기능 태그와 Require 헤더를 사용해야 합니다. 이러한 이유로 헤더를 사용하는 대신 매개변수를 본문으로 전송하는 것이 권장됩니다.\(MUST, MAY, SHOULD, SHOULD\)

메시지 본문을 사용하여 설정하려는 매개변수를 나열하는 경우 Content-Type 헤더\(섹션 18.19\)를 사용하여 메시지 본문의 형식을 지정합니다. 요청 수신자가 메시지 본문에 사용된 미디어 유형을 지원하지 않는 경우 오류 코드 415\(지원되지 않는 미디어 유형\)를 사용하여 응답해야 합니다. 메시지 본문 협상에 관한 추가 고려 사항은 섹션 9.3을 참조하세요. SET\_PARAMETER 요청에 대한 응답자는 응답 요청의 미디어 유형을 사용해야 합니다. 메시지 본문 협상에 관한 추가 고려 사항은 섹션 9.3을 참조하세요.\(MUST, MUST\)

SET\_PARAMETER 요청에 응답하기 위한 지원을 구현하는 RTSP 에이전트는 텍스트/매개변수 형식\(부록 F\)을 구현해야 합니다. 이는 알려진 매개변수 형식 중 하나 이상을 구현하여 매개변수 형식 협상 실패를 방지하기 위한 것입니다.\(MUST\)

클라이언트가 특정 요청이 실패한 이유를 확인할 수 있도록 요청에 단일 매개변수만 포함하는 것이 좋습니다. 요청에 여러 매개변수가 포함된 경우 서버는 모든 매개변수가 성공적으로 설정될 수 있는 경우에만 요청에 대해 조치를 취해야 합니다. 서버는 매개변수가 동일한 값으로 반복적으로 설정되도록 허용해야 하지만\(MUST\) 매개변수 값 변경을 허용하지 않을 수 있습니다. 요청 수신자가 매개변수를 이해하지 못하거나 찾을 수 없는 경우 오류 451\(매개변수를 이해하지 못함\)을 사용해야 합니다. 매개변수 변경이 허용되지 않는 경우 오류 코드는 458\(매개변수는 읽기 전용\)입니다. 응답 본문에는 오류가 있는 매개변수만 포함되어야 합니다. 그렇지 않으면 본문을 반환해서는 안 됩니다. 응답 본문은 응답 요청의 미디어 유형을 사용해야 합니다.\(SHOULD, MUST, MUST, MUST, MUST, MUST NOT, MUST\)

참고: 미디어 스트림의 전송 매개변수는 SETUP 명령으로만 설정해야 합니다.\(MUST\)

- 전송 매개변수 설정을 SETUP으로 제한하는 것은 경계 RTSP 프록시에 연결된 방화벽을 위한 것입니다.

- 매개변수는 보다 의미 있는 오류 표시가 있을 수 있도록 세분화된 방식으로 분할됩니다. 그러나 원자성 설정이 필요한 경우 여러 매개변수 설정을 허용하는 것이 합리적일 수 있습니다. 카메라가 동시에 올바른 각도로 기울어지지 않는 한 카메라가 패닝되는 것을 클라이언트가 원하지 않는 장치 제어를 상상해 보십시오.

```text
   Example:

     C->S: SET_PARAMETER rtsp://example.com/fizzle/foo RTSP/2.0
           CSeq: 421
           User-Agent: PhonyClient/1.2
           Session: iixT43KLc
           Date: Mon, 08 Mar 2010 14:45:04 GMT
           Content-length: 20
           Content-type: text/parameters

           barparam: barstuff

     S->C: RTSP/2.0 451 Parameter Not Understood
           CSeq: 421
           Session: iixT43KLc
           Server: PhonyServer/1.0
           Date: Mon, 08 Mar 2010 14:44:56 GMT
           Content-length: 20
           Content-type: text/parameters

           barparam: barstuff
```

---
### **13.10.  REDIRECT**

REDIRECT 메소드는 제공된 서비스가 종료되고 대신 해당 서비스를 제공할 수 있는 위치를 클라이언트에 알리기 위해 서버에서 발행됩니다. 이는 여러 가지 이유로 발생할 수 있습니다. 하나는 서비스 제공을 중단해야 할 정도로 서버가 관리되고 있다는 것입니다. 따라서 클라이언트는 요청-URI가 나타내는 리소스에 액세스하려면 다른 서버 위치에 연결해야 합니다.

REDIRECT 요청은 클라이언트에게 요청 이유를 알리기 위한 Terminate-Reason 헤더\(18.52절\)를 포함해야 합니다. 이유와 관련된 추가 매개변수도 포함될 수 있습니다. 여기서의 목적은 서버 관리자가 RTSP 서버를 제어하여 종료할 수 있도록 하는 것입니다. 이를 위해서는 서버와 연관된 상태를 가진 모든 엔터티를 알리고 이 서버에서 대체 서버로 제어된 마이그레이션을 수행하는 데 충분한 시간이 필요합니다.\(MUST\)

Session 헤더가 있는 REDIRECT 요청은 종단 간\(즉, 서버에서 클라이언트로\) 범위를 가지며 지정된 세션에만 적용됩니다. 다른 종단 간 세션이 남아 있는 동안 개입하는 프록시는 제어 채널의 연결을 끊어서는 안 됩니다. REQUIRED Location 헤더에는 클라이언트가 다시 연결해야 하는 리소스를 가리키는 완전한 절대 URI가 포함되어야 합니다. 구체적으로는 위치\(SHOULD NOT, MUST\)

호스트와 포트만 포함하면 안 됩니다. 클라이언트는 종단 간 세션이 설정된 경우에만 세션 헤더가 포함된 REDIRECT 요청을 받을 수 있습니다.\(MUST NOT\)

클라이언트는 서버와 통신하거나 연결이 설정된 경우 언제든지 세션 헤더 없이 REDIRECT 요청을 받을 수 있습니다. 이러한 요청의 범위는 다음 홉\(즉, 서버와 직접 통신하는 RTSP 에이전트\)으로 제한되며 제어되는 모든 세션뿐만 아니라 다음 홉 RTSP 에이전트와 서버 간의 연결에도 적용됩니다. 세션 헤더가 없는 REDIRECT 요청은 연결을 통해 관리되는 모든 세션과 보류 중인 요청을 리디렉션해야 함을 나타냅니다. 그러한 요청에 포함된 경우 위치 헤더에는 RTSP 에이전트가 다시 연결해야 하는 서버의 호스트 주소와 선택적 포트 번호만 포함된 절대 URI가 포함되어야 합니다. 모든 개입 프록시는 나열된 순서대로 다음을 모두 수행해야 합니다.\(MUST, SHOULD, SHOULD\)

1. REDIRECT 요청에 응답

2. 요청 서버에서 제어 채널 연결을 끊습니다.

3. 주어진 호스트 주소의 서버에 연결

```text
   4.  pass the REDIRECT request to each applicable client (typically
       those clients with an active session or an unanswered request)
```

- 참고: 프록시는 클라이언트로부터 REDIRECT 응답을 수락할 책임이 있습니다. 이러한 응답은 원래 서버나 리디렉션된 서버로 전달되어서는 안 됩니다.\(MUST NOT\)

세션 또는 모든 세션을 종료해야 하고 리디렉션할 대체 서버가 없는 서버는 대신 TEARDOWN 요청을 사용해야 합니다.\(MUST\)

Terminate-Reason "time" 매개변수가 REDIRECT 요청에 포함되지 않은 경우 클라이언트는 즉시 리디렉션을 수행하고 서버에 응답을 반환해야 합니다. 서버는 세션이 종료된 것으로 간주하고 성공적인\(2xx\) 응답을 받은 후 관련 상태를 해제할 수 있습니다. 서버는 응답 수신 시 신호 연결을 닫을 수 있으며, 클라이언트는 2xx 응답을 보낸 후 신호 연결을 닫아야 합니다. 이에 대한 예외는 클라이언트가 주어진 신호 연결에 의해 관리되는 서버에 여러 세션을 가지고 있는 경우입니다. 이 경우 클라이언트는 신호 연결에 의해 관리되는 모든 세션에 대한 REDIRECT 요청을 수신하고 응답할 때 연결을 닫아야 합니다.\(MUST, SHOULD, SHOULD\)

Terminate-Reason 헤더 "time" 매개변수는 리디렉션이 발생해야 하는 벽시계 시간을 나타내는 데 사용될 수 있습니다. 클라이언트가 서버와 시간을 동기화하지 않고 리디렉션 시간을 결정할 수 있도록 하려면 서버는 요청에 Date 헤더를 포함해야 합니다. 클라이언트는 리디렉션 타임라인이 종료되기 전에 세션을 종료하고 연결을 닫아야 합니다. 서버는 마감 시간에 도달하면 단순히 서비스 제공을 중단하거나 나머지 세션에 TEARDOWN 요청을 발행할 수 있습니다.\(MUST, MUST, MAY\)

REDIRECT 요청이 섹션 10.4의 규칙에 따라 시간 초과되면 서버는 요청에 의해 리디렉션되는 세션 또는 전송 연결을 종료할 수 있습니다. 이는 REDIRECT 요청에 대한 응답을 거부하는 잘못된 클라이언트에 대한 보호 장치입니다. 이 조치는 REDIRECT 요청 수신을 승인하지 않는 인센티브를 제거합니다.\(MAY\)

REDIRECT 요청이 처리된 후 요청-URI로 식별된 리소스에 대한 미디어를 계속 수신하려는 클라이언트는 지정된 호스트와의 새 세션을 설정해야 합니다. Location 헤더에 제공된 URI가 유효한 리소스 URI인 경우 클라이언트는 URI에 대한 DESCRIBE 요청을 발행해야 합니다.\(SHOULD\)

- 참고: Location 헤더가 나타내는 미디어 리소스는 동일할 수도 있고, 약간 다를 수도 있고, 완전히 다를 수도 있습니다. 이것이 새로운 DESCRIBE 요청이 발행되어야 하는 이유입니다.\(SHOULD\)

Location 헤더에 호스트 주소만 포함된 경우 클라이언트는 새 서버의 미디어가 이전 서버의 미디어와 동일하다고 가정할 수 있습니다. 즉, 이전 세션의 모든 미디어 구성 정보는 호스트 주소를 제외하고 여전히 유효합니다. 그러나 가정을 검증하기 위한 수단으로 MTag 식별자를 사용하는 조건부 SETUP을 사용하는 것이 권장됩니다.\(SHOULD\)

이 예제 요청은 지정된 절대 시간에 이 세션의 트래픽을 새 서버로 리디렉션합니다.

```text
     S->C: REDIRECT rtsp://example.com/fizzle/foo RTSP/2.0
           CSeq: 732
           Location: rtsp://s2.example.com:8001/fizzle/foo
           Terminate-Reason: Server-Admin ;time=19960213T143205Z
           Session: uZ3ci0K+Ld-M
           Date: Thu, 13 Feb 1996 14:30:43 GMT

     C->S: RTSP/2.0 200 OK
           CSeq: 732
           User-Agent: PhonyClient/1.2
           Session: uZ3ci0K+Ld-M
```

---
## **14.  Embedded (Interleaved) Binary Data**

예를 들어 UDP를 통한 RTP 트래픽을 차단하는 네트워크 주소 변환기와 함께 네트워크 측의 특정 요구 사항을 충족하려면 RTSP 메시지와 미디어 스트림 데이터를 인터리브해야 할 수도 있습니다. 이러한 인터리빙은 클라이언트와 서버 작업을 복잡하게 하고 추가 오버헤드를 부과하므로 필요하지 않는 한 일반적으로 피해야 합니다. 또한 헤드 오브 라인 차단으로 인해 문제가 발생할 수 있습니다. 인터리브된 바이너리 데이터는 RTSP가 TCP를 통해 전달되는 경우에만 사용해야 합니다. RTSP 메시지 내에서는 인터리브된 데이터가 허용되지 않습니다.\(SHOULD\)

RTP 패킷과 같은 스트림 데이터는 ASCII 달러 기호\(십진수 36\) 뒤에 1옥텟 채널 식별자와 캡슐화된 이진 데이터의 길이가 네트워크 옥텟 순서의 이진, 2옥텟 부호 없는 정수로 캡슐화됩니다\(부록 \[RFC791\]의 B\). 스트림 데이터는 CRLF 없이 바로 뒤따르지만 상위 계층 프로토콜 헤더를 포함합니다. 각 달러 기호 블록은 정확히 하나의 상위 계층 프로토콜 데이터 단위\(예: 하나의 RTP 패킷\)를 포함해야 합니다.\(MUST\)

- 이 메커니즘은 일반 점보 IPv4 및 IPv6 패킷의 최대 페이로드 크기와 일치하는 65535 옥텟보다 큰 PDU를 지원하지 않습니다. 사용하려는 미디어 전달 프로토콜이 그보다 더 큰 PDU를 가지고 있는 경우 내장된 바이너리 데이터를 지원하려면 PDU 조각화 메커니즘의 정의가 필요합니다.

```text
       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      | "$" = 36      | Channel ID    | Length in octets              |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      : Binary data (Length according to Length field)                :
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

             Figure 1: Embedded Interleaved Binary Data Format
```

채널 식별자는 인터리브 매개변수\(18.54절\)를 사용하여 전송 헤더에 정의됩니다.

전송 선택이 RTP인 경우 RTCP 메시지도 TCP 연결을 통해 서버에 의해 인터리브됩니다. RTCP 메시지의 사용은 전송 헤더의 인터리브 매개변수에 두 번째 채널을 포함하는 간격을 포함하여 표시됩니다\(섹션 18.54 참조\). RTCP를 사용하는 경우 패킷은 사용 가능한 첫 번째 채널에서 전송되어야 합니다.\(MUST\)

이는 RTP 채널보다 높습니다. 채널은 양방향으로 동일한 채널 ID를 사용합니다. 따라서 RTCP 트래픽은 두 번째 채널에서 양방향으로 전송됩니다.

- 두 개 이상의 스트림이 이러한 방식으로 인터리브되는 경우 동기화를 위해 RTCP가 필요한 경우가 있습니다. 또한 이는 네트워크 구성에서 필요할 때 RTSP 연결\(TCP 또는 TCP/TLS\)을 통해 RTP/RTCP 패킷을 터널링하고 가능한 경우 UDP로 전송하는 편리한 방법을 제공합니다.

```text
     C->S: SETUP rtsp://example.com/bar.file RTSP/2.0
           CSeq: 2
           Transport: RTP/AVP/TCP;unicast;interleaved=0-1
           Accept-Ranges: npt, smpte, clock
           User-Agent: PhonyClient/1.2

     S->C: RTSP/2.0 200 OK
           CSeq: 2
           Date: Thu, 05 Jun 1997 18:57:18 GMT
           Transport: RTP/AVP/TCP;unicast;interleaved=5-6
           Session: OccldOFFq23KwjYpAnBbUr
           Accept-Ranges: npt
           Media-Properties: Random-Access=0.2, Immutable, Unlimited

     C->S: PLAY rtsp://example.com/bar.file RTSP/2.0
           CSeq: 3
           Session: OccldOFFq23KwjYpAnBbUr
           User-Agent: PhonyClient/1.2

     S->C: RTSP/2.0 200 OK
           CSeq: 3
           Session: OccldOFFq23KwjYpAnBbUr
           Date: Thu, 05 Jun 1997 18:57:19 GMT
           RTP-Info: url="rtsp://example.com/bar.file"
             ssrc=0D12F123:seq=232433;rtptime=972948234
           Range: npt=0-56.8
           Seek-Style: RAP

     S->C: $005{2 octet length}{"length" octets data, w/RTP header}
     S->C: $005{2 octet length}{"length" octets data, w/RTP header}
     S->C: $006{2 octet length}{"length" octets  RTCP packet}
```

---
## **15.  Proxies**

RTSP 프록시는 클라이언트와 서버 사이에 위치한 RTSP 에이전트입니다. 프록시는 수행하려는 작업에 따라 클라이언트와 서버의 역할을 모두 맡을 수 있습니다. RTSP 프록시는 두 개의 전송 계층 연결을 사용합니다. 하나는 RTSP 클라이언트에서 RTSP 프록시로, 다른 하나는 RTSP 프록시에서 RTSP 서버로 연결됩니다. 프록시는 여러 가지 이유로 도입되었습니다. 아래 나열된 항목은 종종 결합됩니다.

캐싱 프록시: 이 유형의 프록시는 서버 및 연결의 작업 부하를 줄이는 데 사용됩니다. 설명 및 미디어 스트림\(예: 프리젠테이션\)을 캐시함으로써 프록시는 클라이언트에 콘텐츠를 제공할 수 있지만 콘텐츠가 캐시되고 오래되지 않은 후에는 서버에서 요청하지 않고 콘텐츠를 제공할 수 있습니다. 섹션 16을 참조하십시오. 이 유형의 프록시는 RTSP 엔드포인트 기능, 즉 Proxy-Require가 요구하는 것 외에 Require 헤더에서 식별된 기능도 이해해야 합니다.

번역기 프록시: 이 유형의 프록시는 RTSP 클라이언트가 외부 네트워크의 서버 및 콘텐츠에 액세스하거나 클라이언트에서 지원하지 않는 콘텐츠 인코딩을 사용하여 액세스하도록 하는 데 사용됩니다. 프록시는 주소, 프로토콜 또는 인코딩의 필요한 변환을 수행합니다. 이러한 유형의 프록시는 RTSP 엔드포인트 기능, 즉 Proxy-Require가 요구하는 것 외에 Require 헤더에서 식별되는 기능도 이해해야 합니다.

액세스 프록시: 이 유형의 프록시는 RTSP 클라이언트가 외부 네트워크의 서버에 액세스할 수 있도록 하는 데 사용됩니다. 따라서 이 프록시는 개인 주소 공간과 공용 인터넷 등 두 도메인 사이의 경계에 배치됩니다. 프록시는 필요한 번역, 일반적으로 주소를 수행합니다. 이러한 유형의 프록시는 미디어가 클라이언트에 도달하기 전에 미디어를 변환을 수행하는 제어된 게이트웨이나 자체로 리디렉션하는 데 필요합니다.

보안 프록시: 이 유형의 프록시는 RTSP 관련 보안 기능을 용이하게 하는 데 사용됩니다. 예를 들어, 방화벽이 있는 네트워크의 경우 보안 프록시는 보호된 네트워크의 클라이언트가 외부 측의 미디어 스트림에 액세스하려고 할 때 방화벽에 필요한 핀홀이 열리도록 요청합니다. 이 프록시는 서버와 클라이언트 사이의 미디어를 리디렉션하지 않고도 해당 기능을 수행할 수 있습니다. 그러나 개인 주소 공간을 사용한 배포에서는 이 프록시가 액세스 프록시와 결합될 가능성이 높습니다. 이 프록시의 기능은 일반적으로 미디어 전송의 모든 측면을 이해하는 것과 밀접하게 연관되어 있습니다.

감사 프록시: RTSP 프록시는 네트워크 소유자에게 RTSP 세션에 대한 로깅 및 감사 지점을 제공할 수도 있습니다\(예: 직원의 네트워크 사용을 추적하는 기업의 경우\). 이러한 유형의 프록시는 미디어 전송에 자신이나 다른 노드를 삽입하지 않고도 해당 기능을 수행할 수 있습니다. 이 프록시 유형은 클라이언트의 요청을 방해하지 않으므로 알 수 없는 방법도 허용할 수 있습니다.

RTSP 2.0을 사용하면 클라이언트가 프록시에서 연결 설정에 사용되는 인증서 체인을 승인할 수 있으므로 TLS와의 보안 통신을 사용할 때 모든 유형의 프록시를 사용할 수도 있습니다. 섹션 19.3.2를 참조하세요. 그러나 해당 신뢰 모델은 모든 배포 유형에 적합하지 않을 수 있습니다. 이러한 경우 보안 세션은 프록시를 우회합니다.

액세스 프록시는 가정이나 소규모 사무실 장비와 같이 정기적으로 유지 관리될 것으로 예상되지 않는 NAT 및 방화벽과 같은 장비에 사용해서는 안 됩니다. 이러한 경우에는 RTSP 2.0 \[RFC7825\]에 정의된 NAT 통과 절차를 사용하는 것이 좋습니다. 이러한 권장 사항을 적용하는 이유는 새로운 미디어 전송 프로토콜이나 프로필, 새로운 매개 변수 등을 생성하는 RTSP 확장이 유지 관리되지 않는 프록시에서 실패할 수 있기 때문입니다. 이는 RTSP의 향후 개발 및 사용을 방해할 수 있습니다.\(SHOULD NOT\)

---
### **15.1.  Proxies and Protocol Extensions**

새로운 RTSP 확장을 개발할 때는 항상 프록시의 존재를 고려해야 합니다. 대부분의 프록시 유형은 해당 확장이 있는 경우 올바르게 작동하려면 새로운 방법을 구현해야 합니다. 새로운 헤더가 도입될 수 있으며 이전 프록시에 의해 차단되지 않습니다. 그러나 이 헤더와 해당 기능이 프록시에서 이해되어야 하는지 아니면 단순히 전달될 수 있는지 고려하는 것이 중요합니다. 헤더를 이해해야 하는 경우 기능을 나타내는 기능 태그가 Proxy-Require 헤더에 포함되어야 합니다. 다음은 헤더를 이해해야 하는지 분석하기 위한 지침입니다. Transport 헤더와 해당 매개변수는 확장 가능하므로 올바른 해석을 보장하기 위해 프록시에 대한 처리 규칙이 필요합니다.\(MUST\)

프록시가 헤더를 이해해야 하는지 여부는 프록시가 다양한 기능을 제공하기 때문에 결정하기 쉽지 않습니다. 헤더를 이해해야 하는지 평가할 때 기능을 세 가지 주요 범주로 나눌 수 있습니다.

미디어 수정: 캐싱 및 변환기 프록시는 실제 미디어를 수정하므로 미디어가 렌더링되는 방식에 영향을 미치는 서버로 전달되는 요청도 이해해야 합니다. 따라서 이러한 유형의 프록시는 서버측 기능도 이해해야 합니다.

전송 수정: 액세스 및 보안 프록시는 모두 핀홀을 열거나 외부 헤더\(예: IP, UDP 또는 TCP\)를 변환하기 위해 미디어 전송이 수행되는 방식을 이해해야 합니다.

수정하지 않음: 감사 프록시는 Via 헤더를 삽입하는 것 외에 다른 방법으로 메시지를 수정하지 않는다는 점에서 특별합니다. 이를 통해 이 유형은 다양한 유형의 알려지지 않은 메서드, 헤더 또는 헤더 매개변수가 포함된 RTSP 메시지를 전달할 수 있습니다.

확장이 "전송 수정" 유형의 프록시로 이해되어야 하는 경우 확장은 프록시에 대해 구현되도록 필수로 분류되어야 합니다.

---
### **15.2.  Multiplexing and Demultiplexing of Messages**

RTSP 프록시는 클라이언트에서 RTSP 서버로 여러 RTSP 세션을 다중화해야 할 수도 있습니다. 이를 위해서는 여러 클라이언트의 RTSP 요청이 RTSP 서버로 나가는 요청에 대한 공통 연결로 다중화되고, 돌아오는 길에 응답이 서버에서 클라이언트별 응답으로 역다중화되어야 합니다. 프로토콜 수준에서 이를 위해서는 요청 및 응답 메시지가 양방향으로 처리되어야 하며, 프록시와 서버 간에 교환되는 요청/응답 쌍이 어느 클라이언트\(또는 클라이언트 요청\)에 매핑되는지를 연관시키는 메커니즘이 필요합니다.

이러한 요청 다중화 및 응답 다중화는 CSeq 헤더 필드를 사용하여 수행됩니다. 프록시는 서버에 대한 요청과 서버의 응답에서 CSeq를 다시 작성하고 어떤 CSeq가 어떤 클라이언트에 매핑되는지 기억해야 합니다. 또한 프록시는 각 클라이언트와 관련된 메시지의 순서가 유지되는지 확인해야 합니다. 섹션 18.20에서는 요청과 응답을 다시 작성하는 방법을 정의합니다.

---
## **16.  Caching**

HTTP에서는 요청/응답 쌍이 캐시됩니다. RTSP는 그 점에서 크게 다릅니다. DESCRIBE에서 반환된 프레젠테이션 설명을 제외하고 응답은 캐시할 수 없습니다. \(DESCRIBE 및 GET\_PARAMETER 이외의 것에 대한 응답은 데이터를 반환하지 않으므로 이러한 요청에 대한 캐싱은 실제로 문제가 되지 않습니다.\) 그러나 일반적으로 RTSP와 관련하여 대역 외로 전달되는 지속적인 미디어 데이터의 경우 바람직합니다. 세션 설명과 함께 캐시됩니다.

SETUP 또는 PLAY 요청을 받으면 프록시는 연속 미디어 콘텐츠와 해당 설명의 최신 복사본이 있는지 확인합니다. SETUP 또는 DESCRIBE 요청을 각각 발행하고 Last-Modified 헤더를 캐시된 복사본의 헤더와 비교하여 복사본이 최신인지 확인할 수 있습니다. 복사본이 최신이 아닌 경우 SETUP 전송 매개변수를 적절하게 수정하고 요청을 원본 서버로 전달합니다. PLAY 또는 PAUSE와 같은 후속 제어 명령은 수정되지 않은 프록시를 전달합니다. 프록시는 지속적인 미디어 데이터를 클라이언트에 전달하는 동시에 나중에 재사용할 수 있도록 로컬 복사본을 만들 수도 있습니다. 캐시의 정확한 허용 동작은 섹션 18.11에 설명된 캐시 응답 지시문에 의해 제공됩니다. 캐시는 현재 요청자에게 스트림을 제공하고 있는 경우 모든 DESCRIBE 요청에 응답해야 합니다. 스트림 설명의 하위 수준 세부 정보가 원본 서버에서 변경되었을 수 있기 때문입니다.\(MUST\)

RTSP 캐시는 "컷스루\(cut-through\)" 종류에 속합니다. 캐시는 원본 서버에서 전체 리소스를 검색하는 대신 클라이언트로 전달되는 스트리밍 데이터를 단순히 복사합니다. 따라서 추가 대기 시간이 발생하지 않습니다.

클라이언트에게는 RTSP 프록시 캐시가 일반 미디어 서버처럼 나타납니다. 미디어 원본 서버에는 RTSP 프록시 캐시가 클라이언트처럼 나타납니다. HTTP 캐시가 캐시하는 개체에 대한 콘텐츠 유형, 콘텐츠 언어 등을 저장해야 하는 것처럼 미디어 캐시는 프레젠테이션 설명을 저장해야 합니다. 일반적으로 캐시는 프레젠테이션 설명에서 모든 전송 참조\(예: 멀티캐스트 정보\)를 제거합니다. 이는 캐시에서 클라이언트로의 데이터 전달과 독립적이기 때문입니다. 인코딩에 대한 정보는 동일하게 유지됩니다. 캐시가 캐시된 미디어 데이터를 변환할 수 있다면 캐시가 제공할 수 있는 모든 인코딩 가능성을 갖춘 새로운 프레젠테이션 설명을 생성하게 됩니다.

---
### **16.1.  Validation Model**

캐시에 클라이언트 요청에 대한 응답으로 사용하려는 오래된 항목이 있는 경우 먼저 원본 서버\(또는 새로운 응답이 있는 중간 캐시\)를 확인하여 캐시된 항목을 여전히 사용할 수 있는지 확인해야 합니다. . 이를 캐시 항목의 "검증"이라고 합니다. 캐시된 항목이 양호할 경우 전체 응답을 재전송하는 오버헤드를 지불하지 않고 동시에 캐시된 항목이 유효하지 않은 경우 추가 왕복으로 인한 오버헤드를 지불하지 않기 위해 RTSP는 조건부 방법의 사용을 지원합니다.

조건부 방법을 지원하는 주요 프로토콜 기능은 "캐시 유효성 검사기"와 관련된 기능입니다. 원본 서버가 전체 응답을 생성하면 캐시 항목과 함께 보관되는 일종의 유효성 검사기를 연결합니다. 클라이언트\(사용자 에이전트 또는 프록시 캐시\)가 캐시 항목이 있는 리소스에 대해 조건부 요청을 하면 요청에 연결된 유효성 검사기가 포함됩니다.

그런 다음 서버는 요청된 리소스에 대한 현재 유효성 검사기와 비교하여 해당 유효성 검사기를 확인하고 일치하는 경우\(섹션 16.1.3 참조\) 메시지 본문 없이 특수 상태 코드\(보통 304\(수정되지 않음\)\)로 응답합니다. 그렇지 않으면 전체 응답\(메시지 본문 포함\)을 반환합니다. 따라서 유효성 검사기가 일치하는 경우 전체 응답 전송을 방지하고 일치하지 않는 경우 추가 왕복을 방지합니다.

RTSP에서 조건부 요청은 암시적으로 메서드\(보통 DESCRIBE 또는 SETUP\)를 조건부로 전환하는 특수 헤더\(유효성 검사기 포함\)를 전달한다는 점을 제외하면 동일한 리소스에 대한 일반 요청과 완전히 동일해 보입니다.

프로토콜에는 캐시 검증 조건에 대한 긍정적인 의미와 부정적인 의미가 모두 포함됩니다. 즉, 유효성 검사기가 일치하는 경우에만 메서드를 수행하도록 요청하거나 유효성 검사기가 일치하지 않는 경우에만 메서드를 수행하도록 요청할 수 있습니다.

- 참고: 유효성 검사기가 없는 응답은 캐시 지시문에 의해 명시적으로 금지되지 않는 한 캐시되고 만료될 때까지 캐시에서 제공될 수 있습니다\(섹션 18.11 참조\). 그러나 캐시에 리소스에 대한 유효성 검사기가 없으면 조건부 검색을 수행할 수 없습니다. 즉, 만료된 후에는 새로 고칠 수 없습니다.

서버와 캐시 간의 전송 용량에 따라 조정되는 미디어 스트림은 캐싱을 더욱 어렵게 만듭니다. 서버는 적응하는 미디어 스트림의 캐싱을 보는 방법을 고려해야 하며 잠재적으로 캐시에 그러한 스트림을 캐시하지 않도록 지시해야 합니다.

---
#### **16.1.1.  Last-Modified Dates**

Last-Modified 헤더\(섹션 18.27\) 값은 캐시 유효성 검사기로 자주 사용됩니다. 간단히 말해서 캐시 항목이 Last-Modified 시간 이후에 생성된 경우 캐시 항목이 유효한 것으로 간주됩니다.

---
#### **16.1.2.  Message Body Tag Cache Validators**

메시지 본문 태그인 MTag 응답 헤더 필드 값은 "불투명" 캐시 유효성 검사기를 제공합니다. 이를 통해 수정 날짜를 저장하는 것이 불편하거나 RTSP 날짜 값의 1초 해상도가 충분하지 않거나 원본 서버가 수정 사용으로 인해 발생할 수 있는 특정 역설을 피하려는 상황에서 보다 안정적인 유효성 검사를 허용할 수 있습니다. 날짜.

메시지 본문 태그는 섹션 4.6에 설명되어 있습니다.

---
#### **16.1.3.  Weak and Strong Validators**

원본 서버와 캐시는 두 유효성 검사기를 비교하여 동일한 엔터티를 나타내는지 아니면 다른 엔터티를 나타내는지 결정하므로 일반적으로 메시지 본문\(예: 프레젠테이션 설명\) 또는 관련 메시지 본문 헤더가 어떤 방식으로든 변경되면 관련 유효성 검사기도 변경됩니다. 이것이 사실이라면 이 검증인은 "강력한 검증인"입니다. 메시지 본문\(예: 프레젠테이션 설명\) 또는 관련 메시지 본문 헤더는 더 나은 이해를 위해 엔터티로 명명됩니다.

그러나 서버가 엔터티 변경의 중요하지 않은 측면이 아닌 의미상 중요한 변경에 대해서만 유효성 검사기를 변경하는 것을 선호하는 경우가 있을 수 있습니다. 리소스가 변경될 때 항상 변경되지 않는 유효성 검사기는 "약한 유효성 검사기"입니다.

메시지 본문 태그는 일반적으로 강력한 유효성 검사기이지만 프로토콜은 메시지 본문 태그를 "약함"으로 태그 지정하는 메커니즘을 제공합니다. 강력한 유효성 검사기는 엔터티의 비트가 변경될 때마다 변경되는 반면 약한 값은 엔터티의 의미가 변경될 때마다 변경되는 것으로 생각할 수 있습니다. 또는 강력한 유효성 검사기를 특정 엔터티에 대한 식별자의 일부로 생각할 수 있는 반면 약한 유효성 검사기는 의미상 동일한 엔터티 집합에 대한 식별자의 일부로 생각할 수 있습니다.

- 참고: 강력한 유효성 검사기의 한 가지 예는 엔터티가 변경될 때마다 안정적인 저장소에서 증가하는 정수입니다.

- 엔터티의 수정 시간을 1초 단위로 표현하면 리소스가 1초 동안 두 번 수정될 수 있으므로 약한 유효성 검사기가 될 수 있습니다.

- 약한 유효성 검사기에 대한 지원은 선택 사항입니다. 그러나 약한 유효성 검사기를 사용하면 동등한 객체를 보다 효율적으로 캐싱할 수 있습니다.

유효성 검사기의 "사용"은 클라이언트가 요청을 생성하고 유효성 검사 헤더 필드에 유효성 검사기를 포함할 때 또는 서버가 두 유효성 검사기를 비교할 때입니다.

강력한 유효성 검사기는 어떤 상황에서도 사용할 수 있습니다. 약한 유효성 검사기는 엔터티의 정확한 동일성에 의존하지 않는 컨텍스트에서만 사용할 수 있습니다. 예를 들어 두 종류 모두 전체 엔터티의 조건부 DESCRIBE에 사용할 수 있습니다. 그러나 하위 범위 검색에는 강력한 유효성 검사기만 사용할 수 있습니다. 그렇지 않으면 클라이언트가 내부적으로 일관성이 없는 엔터티로 끝날 수 있기 때문입니다.

클라이언트는 약하거나 강력한 유효성 검사기로 DESCRIBE 요청을 발행할 수 있습니다. 클라이언트는 다른 형태의 요청에 약한 유효성 검사기를 사용해서는 안 됩니다.\(MAY, MUST NOT\)

RTSP가 유효성 검사기에 정의하는 유일한 기능은 비교입니다. 비교 컨텍스트에서 약한 유효성 검사기 사용을 허용하는지 여부에 따라 두 가지 유효성 검사기 비교 함수가 있습니다.

o 강력한 비교 기능: 동등하다고 간주되기 위해서는 두 검증자가 모든 면에서 동일해야 하며 둘 다 약해서는 안 됩니다.\(MUST NOT\)

o 약한 비교 기능: 동등하다고 간주되기 위해서는 두 검증자가 모든 면에서 동일해야 하지만 둘 중 하나 또는 둘 다 결과에 영향을 주지 않고 "약함"으로 태그될 수 있습니다.\(MUST\)

메시지 본문 태그는 명시적으로 약한 태그로 지정되지 않는 한 강력합니다.

요청에서 유효성 검사기로 사용되는 Last-Modified 시간은 다음 규칙을 사용하여 강력하다고 추론할 수 없는 한 암시적으로 약합니다.

o 검증자는 원서버에 의해 해당 엔터티에 대한 실제 현재 검증자와 비교됩니다.

o 해당 원서버는 연관된 엔터티가 제시된 검증자가 다루는 두 번째 기간 동안 두 번 이상 변경되지 않았다는 것을 확실하게 알고 있습니다.

```text
   OR
```

o 클라이언트가 관련 엔터티에 대한 캐시 항목을 갖고 있기 때문에 If-Modified-Since에서 유효성 검사기가 클라이언트에 의해 사용되려고 합니다.

o 해당 캐시 항목에는 원본 서버가 원래 응답을 보낸 시간을 제공하는 날짜 값이 포함되어 있습니다.

o 표시된 최종 수정 시간은 날짜 값보다 최소 60초 전입니다.

```text
   OR
```

o 검증자는 중간 캐시에 의해 엔터티의 캐시 항목에 저장된 검증자와 비교됩니다.

o 해당 캐시 항목에는 원본 서버가 원래 응답을 보낸 시간을 제공하는 날짜 값이 포함되어 있습니다.

o 표시된 최종 수정 시간은 날짜 값보다 최소 60초 전입니다.

이 방법은 동일한 초 동안 원본 서버에서 두 개의 서로 다른 응답을 보냈지만 둘 다 동일한 Last-Modified 시간을 가졌다면 해당 응답 중 적어도 하나는 Last-Modified와 동일한 Date 값을 갖는다는 사실에 의존합니다. 시간. 임의의 60초 제한은 응답을 준비하는 동안 Date 및 Last-Modified 값이 다른 시계 또는 다소 다른 시간에 생성될 가능성을 방지합니다. 60초가 너무 짧다고 판단되는 경우 구현에서는 60초보다 큰 값을 사용할 수 있습니다.\(MAY\)

클라이언트가 Last-Modified 시간만 있고 불투명 유효성 검사기가 없는 값에 대해 하위 범위 검색을 수행하려는 경우 여기에 설명된 의미에서 Last-Modified 시간이 강한 경우에만 이 작업을 수행할 수 있습니다.\(MAY\)

---
#### **16.1.4.  Rules for When to Use Message Body Tags and Last-Modified Dates**

이 문서는 다양한 유효성 검사기 유형을 사용해야 하는 시기와 목적에 관해 원본 서버, 클라이언트 및 캐시에 대한 일련의 규칙 및 권장 사항을 채택합니다.

```text
   RTSP origin servers:
```

o 메시지 본문 태그 유효성 검사기를 생성하는 것이 가능하지 않은 한 메시지 본문 태그 유효성 검사기를 보내야 합니다\(SHOULD\).\(SHOULD\)

o 성능 고려 사항이 약한 메시지 본문 태그의 사용을 지원하거나 강력한 메시지 본문 태그를 보내는 것이 실행 불가능한 경우 강력한 메시지 본문 태그 대신 약한 메시지 본문 태그를 보낼 수 있습니다.\(MAY\)

o If-Modified-Since 헤더에서 이 날짜를 사용함으로써 발생할 수 있는 의미 투명성의 붕괴 위험으로 인해 심각한 문제가 발생하지 않는 한, 전송이 가능한 경우 Last-Modified 값을 전송해야 합니다. 즉, RTSP 원본 서버에서 선호되는 동작은 강력한 메시지 본문 태그와 Last-Modified 값을 모두 보내는 것입니다.\(SHOULD\)

합법적이려면 관련 엔터티 값이 어떤 방식으로든 변경될 때마다 강력한 메시지 본문 태그가 변경되어야 합니다. 약한 메시지 본문 태그는 연관된 엔터티가 의미상 중요한 방식으로 변경될 때마다 변경되어야 합니다.\(MUST, SHOULD\)

- 참고: 의미상 투명한 캐싱을 제공하기 위해 원서버는 두 개의 서로 다른 엔터티에 대해 특정 강력한 메시지 본문 태그 값을 재사용하거나 의미상으로 서로 다른 두 엔터티에 대해 특정 약한 메시지 본문 태그 값을 재사용하는 것을 피해야 합니다. 캐시 항목은 만료 시간에 관계없이 임의로 오랜 기간 동안 지속될 수 있으므로 캐시가 과거 어느 시점에 얻은 유효성 검사기를 사용하여 항목의 유효성을 다시 검사하지 않을 것이라고 기대하는 것은 부적절할 수 있습니다.\(MUST\)

```text
   RTSP clients:
```

o 원본 서버에서 메시지 본문 태그를 제공한 경우 캐시 조건부 요청\(If-Match 또는 If-None-Match 사용\)에서 해당 메시지 본문 태그를 사용해야 합니다.\(MUST\)

o 원본 서버가 Last-Modified 값만 제공한 경우 비하위 범위 캐시 조건부 요청에서 해당 값을 사용해야 합니다\(If-Modified-Since 사용\).\(SHOULD\)

o 원본 서버에서 메시지 본문 태그와 Last-Modified 값을 모두 제공한 경우 캐시 조건부 요청에서 두 유효성 검사기를 모두 사용해야 합니다.\(SHOULD\)

RTSP 원본 서버는 Last-Modified 날짜\(예: If-Modified-Since 헤더\)와 하나 이상의 메시지 본문 태그\(예: If-Match\)를 모두 포함하는 조건부 요청을 수신하면

If-None-Match 또는 If-Range 헤더 필드\)를 캐시 유효성 검사기로 사용하는 경우 요청의 모든 조건부 헤더 필드와 일치하지 않는 한 응답 상태 304\(수정되지 않음\)를 반환해서는 안 됩니다.\(MUST NOT\)

- 참고: 이러한 규칙의 기본 원칙은 RTSP 서버와 클라이언트가 응답 및 요청에서 사용할 수 있는 중복되지 않는 정보를 최대한 많이 전송해야 한다는 것입니다. 이 정보를 수신하는 RTSP 시스템은 수신하는 검증자에 대해 가장 보수적인 가정을 합니다.

---
#### **16.1.5.  Non-validating Conditionals**

메시지 본문 태그 뒤에 있는 원칙은 서비스 작성자만이 적절한 캐시 유효성 검사 메커니즘을 선택할 수 있을 만큼 리소스의 의미를 잘 알고 있으며 옥텟 동일성보다 더 복잡한 유효성 검사기 비교 기능의 사양은 웜 캔을 열 수 있다는 것입니다. 따라서 다른 헤더의 비교는 캐시 항목의 유효성을 검사할 목적으로 사용되지 않습니다.

---
### **16.2.  Invalidation after Updates or Deletions**

원본 서버의 리소스에 대해 수행된 특정 방법의 영향으로 인해 하나 이상의 기존 캐시 항목이 불투명하게 무효화될 수 있습니다. 즉, 계속해서 "최신" 상태를 유지하더라도 원본 서버가 해당 리소스에 대한 새 요청에 대해 반환하는 내용을 정확하게 반영하지 않습니다.

RTSP에서는 이러한 모든 캐시 항목이 유효하지 않은 것으로 표시되도록 보장할 수 있는 방법이 없습니다. 예를 들어, 원본 서버에서 변경을 야기한 요청이 캐시 항목이 저장된 프록시를 통과하지 않았을 수 있습니다. 그러나 몇 가지 규칙은 잘못된 동작의 가능성을 줄이는 데 도움이 됩니다.

이 섹션에서 "엔티티 무효화"라는 문구는 캐시가 해당 엔터티의 모든 인스턴스를 저장소에서 제거하거나 이를 "유효하지 않음"으로 표시하고 후속 응답에 대한 응답으로 반환되기 전에 필수 재검증이 필요함을 의미합니다. 요구.

일부 RTSP 방법은 캐시가 엔터티를 무효화하도록 해야 합니다. 이는 Request-URI 또는 ​​Location 또는 Content-Location 헤더\(있는 경우\)에서 참조하는 엔터티입니다. 이러한 방법은 다음과 같습니다.\(MUST\)

```text
   o  DESCRIBE

   o  SETUP
```

DoS 공격을 방지하기 위해 Location 또는 Content-Location 헤더의 URI를 기반으로 한 무효화는 호스트 부분이 Request-URI와 동일한 경우에만 수행되어야 합니다.\(MUST\)

이해하지 못하는 메소드에 대한 요청을 통과하는 캐시는 Request-URI가 참조하는 모든 엔터티를 무효화해야 합니다.\(SHOULD\)

---
## **17.  Status Code Definitions**

해당되는 경우 HTTP 상태 코드\(\[RFC7231\]의 섹션 6 참조\)가 재사용됩니다. 어떤 요청에 의해 어떤 상태 코드가 반환될 수 있는지 목록을 보려면 섹션 8.1의 표 4를 참조하세요. 모든 오류 메시지\(4xx 및 5xx\)는 오류에 대한 추가 정보가 포함된 본문을 반환할 수 있습니다.\(MAY\)

---
### **17.1.  Informational 1xx**
---
#### **17.1.1.  100 Continue**

요청 에이전트는 요청을 계속해야 합니다. 이 임시 응답은 요청 에이전트에게 요청의 초기 부분이 수신되었으며 응답 에이전트가 아직 거부하지 않았음을 알리는 데 사용됩니다. 요청 에이전트는 요청의 나머지 부분을 전송하여 계속해야 하며, 요청이 이미 완료된 경우 계속해서 최종 응답을 기다려야 합니다\(섹션 10.4 참조\). 응답 에이전트는 요청이 완료된 후 최종 응답을 보내야 합니다.\(SHOULD, SHOULD, MUST\)

---
### **17.2.  Success 2xx**

이 상태 코드 클래스는 에이전트의 요청이 성공적으로 수신되고, 이해되고, 수락되었음을 나타냅니다.

---
#### **17.2.1.  200 OK**

요청이 성공했습니다. 응답과 함께 반환되는 정보는 요청에 사용된 방법에 따라 달라집니다.

---
### **17.3.  Redirection 3xx**

"3xx" 표기는 리디렉션을 위한 300부터 399까지의 응답 코드를 나타냅니다. 리디렉션에 사용되는 모든 3xx 코드\(예: 304 제외\)를 나타내기 위해 "3rr" 표기법을 사용합니다. 여기에는 적절했을 2xx 응답 코드 대신 304 응답 코드가 표시됩니다. 304는 RTSP 1.0 \[RFC2326\]에서도 사용되었습니다.

RTSP 내에서 리디렉션은 로드 밸런싱을 위해 사용되거나 스트림 요청을 위상적으로 에이전트에 더 가까운 서버로 리디렉션하는 데 사용될 수 있습니다. 위상적 근접성을 결정하는 메커니즘은 이 사양의 범위를 벗어납니다.

3rr 코드는 모든 요청에 ​​응답하는 데 사용될 수 있습니다. Location 헤더는 모든 3rr 응답에 포함되어야 합니다. 세션이 설정되기 전, 즉 DESCRIBE 또는 SETUP에 대한 응답으로 필요한 경우 사용하는 것이 권장됩니다. 그러나 서버가 에이전트에 REDIRECT 요청을 보낼 수 없는 경우 서버는 3rr 응답을 사용하여 설정된 세션이 있는 에이전트에게 세션 리디렉션의 필요성을 알려야 할 수도 있습니다. 설정된 세션과 관련된 요청에 대해 3rr 응답이 수신되면 에이전트는 해당 세션에 대한 TEARDOWN 요청을 보내야 하며 위치에 표시된 리소스를 사용하여 세션을 다시 설정할 수 있습니다.\(MAY, MUST, SHOULD, MAY, SHOULD\)

Location 헤더가 응답에 사용되는 경우 에이전트가 리디렉션되는 미디어 리소스를 가리키는 절대 URI를 포함해야 합니다. URI에는 호스트 이름만 포함되어서는 안 됩니다.\(MUST NOT\)

알 수 없는 3rr 상태 코드가 수신된 경우 에이전트는 302 응답 코드가 수신된 것처럼 동작해야 합니다\(17.3.3절\).\(SHOULD\)

---
#### **17.3.1.  300**

300 응답 코드는 RTSP 2.0에서 사용되지 않습니다.

---
#### **17.3.2.  301 Moved Permanently**

요청된 리소스는 영구적으로 이동되었으며 이제 Location 헤더에서 제공하는 URI에 상주합니다. 사용자 에이전트는 지정된 URI로 자동으로 리디렉션되어야 합니다. 이 응답에는 메시지 본문이 포함되어서는 안 됩니다. Location 헤더는 응답에 포함되어야 합니다.\(SHOULD, MUST NOT, MUST\)

---
#### **17.3.3.  302 Found**

요청된 리소스는 Location 헤더에 제공된 URI에 일시적으로 상주합니다. 이 응답은 로드 밸런싱과 같은 다양한 유형의 임시 리디렉션에 사용하기 위한 것입니다. 이러한 경우 서버는 이유 문구를 "발견됨"보다 더 의미 있는 것으로 설정하는 것이 좋습니다. Location 헤더는 응답에 포함되어야 합니다. 사용자 에이전트는 지정된 URI로 자동으로 리디렉션되어야 합니다. 이 응답에는 메시지 본문이 포함되어서는 안 됩니다.\(SHOULD, MUST, SHOULD, MUST NOT\)

이 예에서는 클라이언트가 다른 서버로 리디렉션되는 것을 보여줍니다.

```text
     C->S: SETUP rtsp://example.com/fizzle/foo RTSP/2.0
           CSeq: 2
           Transport: RTP/AVP/TCP;unicast;interleaved=0-1
           Accept-Ranges: npt, smpte, clock
           User-Agent: PhonyClient/1.2

     S->C: RTSP/2.0 302 Try Other Server
           CSeq: 2
           Location: rtsp://s2.example.com:8001/fizzle/foo
```

---
#### **17.3.4.  303 See Other**

이 상태 코드는 RTSP 2.0에서 사용되어서는 안 됩니다. 그러나 RTSP 1.0 \[RFC2326\]에서는 허용되었습니다.\(MUST NOT\)

---
#### **17.3.5.  304 Not Modified**

에이전트가 조건부 DESCRIBE 또는 SETUP\(섹션 18.25 및 18.26 참조\)을 수행했고 요청된 리소스가 수정되지 않은 경우 서버는 304 응답을 보내야 합니다. 이 응답에는 메시지 본문이 포함되어서는 안 됩니다.\(SHOULD, MUST NOT\)

응답에는 다음 헤더 필드가 포함되어야 합니다.\(MUST\)

```text
   o  Date
```

o MTag 또는 Content-Location\(헤더가 동일한 요청에 대한 200 응답으로 전송된 경우\)

o 필드 값이 동일한 변형에 대한 이전 응답에서 전송된 값과 다를 수 있는 경우 만료 및 캐시 제어.

이 응답은 DESCRIBE 및 SETUP 요청에 대해 독립적입니다. 즉, DESCRIBE에 대한 304 응답은 리소스 내용이 변경되지 않았음을 의미하지 않으며\(세션 설명만\) SETUP에 대한 304 응답은 리소스 설명이 변경되지 않음을 의미하지 않습니다. MTag 및 If-Match 헤더\(18.24절\)는 이러한 방식으로 DESCRIBE 및 SETUP을 연결하는 데 사용될 수 있습니다.

---
#### **17.3.6.  305 Use Proxy**

요청된 리소스는 반드시 포함되어야 하는 Location 헤더에 의해 제공되는 프록시를 통해 액세스되어야 합니다. Location 헤더 필드 값은 프록시의 URI를 제공합니다. 수신자는 프록시를 통해 이 단일 요청을 반복해야 합니다. 305 응답은 원본 서버에서만 생성되어야 합니다.\(MUST, MUST\)

---
### **17.4.  Client Error 4xx**
---
#### **17.4.1.  400 Bad Request**

잘못된 구문으로 인해 에이전트가 요청을 이해할 수 없습니다. 에이전트는 수정 없이 요청을 반복해서는 안 됩니다. 요청에 CSeq 헤더가 없으면 에이전트는 응답에 CSeq를 포함해서는 안 됩니다.\(SHOULD NOT, MUST NOT\)

---
#### **17.4.2.  401 Unauthorized**

요청에는 HTTP 인증 메커니즘 \[RFC7235\]을 사용한 사용자 인증이 필요합니다. 오류 코드의 사용법은 \[RFC7235\] 및 Digest \[RFC7616\]와 같은 적용 가능한 HTTP 인증 체계에 정의되어 있습니다. 응답에는 요청된 리소스에 적용 가능한 챌린지를 포함하는 WWW-Authenticate 헤더\(18.58절\) 필드가 포함됩니다. 에이전트는 적절한 Authorization 헤더 필드를 사용하여 요청을 반복할 수 있습니다. 요청에 인증 자격 증명이 이미 포함된 경우 401 응답은 해당 자격 증명에 대한 인증이 거부되었음을 나타냅니다. 401 응답에 이전 응답과 동일한 챌린지가 포함되어 있고 사용자 에이전트가 이미 한 번 이상 인증을 시도한 경우 해당 메시지 본문에 관련 진단 정보가 포함될 수 있으므로 응답에 제공된 메시지 본문이 사용자에게 표시되어야 합니다. .\(SHOULD\)

---
#### **17.4.3.  402 Payment Required**

이 코드는 향후 사용을 위해 예약되어 있습니다.

---
#### **17.4.4.  403 Forbidden**

상담원이 요청을 이해했지만 이행을 거부했습니다. 승인은 도움이 되지 않으며 요청을 반복해서는 안 됩니다. 에이전트가 요청이 이행되지 않은 이유를 공개하려는 경우 메시지 본문에 거부 이유를 설명해야 합니다. 에이전트가 이 정보를 에이전트에게 제공하지 않으려면 상태 코드 404\(찾을 수 없음\)를 대신 사용할 수 있습니다.\(SHOULD NOT, SHOULD\)

---
#### **17.4.5.  404 Not Found**

에이전트가 Request-URI와 일치하는 항목을 찾지 못했습니다. 상태가 일시적인지 영구적인지에 대한 표시는 없습니다. 410\(Gone\) 상태 코드는 에이전트가 내부적으로 구성 가능한 메커니즘을 통해 이전 리소스를 영구적으로 사용할 수 없고 전달 주소가 없다는 것을 알고 있는 경우 사용해야 합니다.\(SHOULD\)

이 상태 코드는 상담원이 요청이 거부된 정확한 이유를 밝히고 싶지 않거나 적용할 수 있는 다른 응답이 없을 때 일반적으로 사용됩니다.

---
#### **17.4.6.  405 Method Not Allowed**

요청에 지정된 방법은 요청-URI로 식별된 리소스에 허용되지 않습니다. 응답에는 요청된 리소스에 대한 유효한 메서드 목록이 포함된 Allow 헤더가 포함되어야 합니다. 이 상태 코드는 요청이 SETUP 중에 표시되지 않은 방법을 사용하려고 시도하는 경우에도 사용됩니다.\(MUST\)

---
#### **17.4.7.  406 Not Acceptable**

요청에 의해 식별된 리소스는 요청에서 전송된 Accept 헤더에 따라 허용되지 않는 콘텐츠 특성을 가진 응답 메시지 본문만 생성할 수 있습니다.

응답에는 사용 가능한 메시지 본문 특성 목록과 사용자 또는 사용자 에이전트가 가장 적합한 것을 선택할 수 있는 위치가 포함된 메시지 본문이 포함되어야 합니다. 메시지 본문 형식은 Content-Type 헤더 필드에 지정된 미디어 유형으로 지정됩니다. 사용자 에이전트의 형식과 기능에 따라 가장 적절한 선택이 자동으로 수행될 수 있습니다. 그러나 본 사양에서는 이러한 자동 선택에 대한 어떠한 기준도 정의하지 않습니다.\(SHOULD, MAY\)

응답을 받아들일 수 없는 경우 사용자 에이전트는 추가 데이터 수신을 일시적으로 중단하고 사용자에게 추가 작업에 대한 결정을 문의해야 합니다.\(SHOULD\)

---
#### **17.4.8.  407 Proxy Authentication Required**

이 코드는 401\(Unauthorized\)\(섹션 17.4.2\)과 유사하지만 클라이언트가 먼저 프록시를 통해 자신을 인증해야 함을 나타냅니다. 이 오류 코드의 사용법은 \[RFC7235\] 및 다이제스트 \[RFC7616\]와 같은 적용 가능한 HTTP 인증 체계에 정의되어 있습니다. 프록시는 요청된 리소스에 대해 프록시에 적용 가능한 챌린지를 포함하는 Proxy-Authenticate 헤더 필드\(18.34절\)를 반환해야 합니다.\(MUST\)

---
#### **17.4.9.  408 Request Timeout**

에이전트가 대기할 준비가 된 시간 내에 에이전트가 요청을 생성하지 않았습니다. 에이전트는 나중에 수정 없이 요청을 반복할 수 있습니다.\(MAY\)

---
#### **17.4.10.  410 Gone**

요청한 리소스를 더 이상 서버에서 사용할 수 없으며 전달 주소를 알 수 없습니다. 이 상태는 영구적인 것으로 간주될 것으로 예상됩니다. 서버가 조건이 영구적인지 여부를 알 수 없거나 결정할 수 있는 기능이 없는 경우 상태 코드 404\(찾을 수 없음\)를 대신 사용해야 합니다. 달리 명시하지 않는 한 이 응답은 캐시 가능합니다.\(SHOULD\)

410 응답은 주로 수신자에게 리소스를 의도적으로 사용할 수 없으며 서버 소유자가 해당 리소스에 대한 원격 링크를 제거하기를 원한다는 사실을 알려 저장소 유지 관리 작업을 지원하기 위한 것입니다. 이러한 이벤트는 제한된 시간 동안 진행되는 판촉 서비스 및 더 이상 서버 사이트에서 근무하지 않는 개인에게 속한 리소스에 대해 일반적입니다. 영구적으로 사용할 수 없는 모든 리소스를 "사라짐"으로 표시하거나 일정 기간 동안 표시를 유지할 필요는 없습니다. 이는 서버 소유자의 재량에 달려 있습니다.

---
#### **17.4.11.  412 Precondition Failed**

하나 이상의 'if-' 요청 헤더 필드에 제공된 전제 조건이 에이전트에서 테스트될 때 false로 평가되었습니다. 'if-' 헤더에 대해서는 If-Match 섹션 18.24, If-Modified- Since 섹션 18.25 및 If-None-Match 섹션 18.26을 참조하세요. 이 응답 코드를 사용하면 에이전트는 현재 리소스 메타 정보\(헤더 필드 데이터\)에 전제 조건을 적용하여 요청된 메서드가 의도한 리소스 이외의 리소스에 적용되는 것을 방지할 수 있습니다.

---
#### **17.4.12.  413 Request Message Body Too Large**

요청 메시지 본문이 에이전트가 처리할 의사가 있거나 처리할 수 있는 것보다 크기 때문에 에이전트가 요청 처리를 거부하고 있습니다. 에이전트는 요청 에이전트가 요청을 계속하는 것을 방지하기 위해 연결을 닫을 수 있습니다.\(MAY\)

조건이 일시적인 경우 에이전트는 Retry-After 헤더 필드를 포함하여 그것이 일시적이라는 것과 요청 에이전트가 몇 시간 후에 다시 시도할 수 있는지를 나타내야 합니다.\(SHOULD\)

---
#### **17.4.13.  414 Request-URI Too Long**

요청-URI가 에이전트가 해석할 수 있는 것보다 길기 때문에 응답 에이전트가 요청 서비스를 거부합니다. 이 드문 상황은 에이전트가 긴 쿼리 정보가 포함된 요청을 사용한 경우, 에이전트가 리디렉션의 URI "블랙홀"\(예: 자신의 접미사를 가리키는 리디렉션된 URI 접두사\)로 내려간 경우에만 발생할 가능성이 높습니다. 또는 에이전트가 공격을 받고 있을 때

요청-URI를 읽거나 조작하기 위해 고정 길이 버퍼를 사용하는 일부 에이전트에 존재하는 보안 허점을 악용하려는 에이전트에 의해 발생합니다.

---
#### **17.4.14.  415 Unsupported Media Type**

요청의 메시지 본문이 요청된 메서드에 대해 요청한 리소스에서 지원하지 않는 형식이기 때문에 서버가 요청 서비스를 거부하고 있습니다.

---
#### **17.4.15.  451 Parameter Not Understood**

요청 수신자가 요청에 포함된 매개변수를 하나 이상 지원하지 않습니다. 이 오류 메시지를 반환할 때 에이전트는 문제가 되는 매개변수가 포함된 메시지 본문을 반환해야 합니다.\(SHOULD\)

---
#### **17.4.16.  452 Illegal Conference Identifier**

이 상태 코드는 RTSP 2.0에서 사용되어서는 안 됩니다. 그러나 RTSP 1.0 \[RFC2326\]에서는 허용되었습니다.\(MUST NOT\)

---
#### **17.4.17.  453 Not Enough Bandwidth**

대역폭이 부족하여 요청이 거부되었습니다. 예를 들어 리소스 예약 실패로 인해 발생할 수 있습니다.

---
#### **17.4.18.  454 Session Not Found**

세션 헤더의 RTSP 세션 식별자가 누락되었거나 유효하지 않거나 시간이 초과되었습니다.

---
#### **17.4.19.  455 Method Not Valid in This State**

에이전트는 현재 상태에서는 이 요청을 처리할 수 없습니다. 오류 복구를 가능하게 하려면 응답에 Allow 헤더가 포함되어야 합니다.\(MUST\)

---
#### **17.4.20.  456 Header Field Not Valid for Resource**

대상 에이전트가 필수 요청 헤더에 대해 작업을 수행할 수 없습니다. 예를 들어 PLAY 요청에 Range 헤더 필드가 포함되어 있지만 스트림이 검색을 허용하지 않는 경우입니다. 이 오류 메시지는 리소스에 대해 Range의 시간 형식을 사용할 수 없는 경우를 지정하는 데에도 사용될 수 있습니다. 이 경우 허용되는 형식을 에이전트에 알리기 위해 Accept-Ranges 헤더가 반환되어야 합니다.\(MUST\)

---
#### **17.4.21.  457 Invalid Range**

주어진 범위 값이 범위를 벗어났습니다\(예: 프레젠테이션 끝을 넘어섰습니다\).

---
#### **17.4.22.  458 Parameter Is Read-Only**

SET\_PARAMETER로 설정할 매개변수는 읽을 수는 있지만 수정할 수는 없습니다. 이 오류 메시지를 반환할 때 발신자는 문제가 되는 매개변수가 포함된 메시지 본문을 반환해야 합니다.\(SHOULD\)

---
#### **17.4.23.  459 Aggregate Operation Not Allowed**

요청된 메서드는 집계\(프레젠테이션\) URI이므로 해당 URI에 적용되지 않을 수 있습니다. 이 메서드는 미디어 URI에 적용될 수 있습니다.

---
#### **17.4.24.  460 Only Aggregate Operation Allowed**

요청된 메서드는 집계 제어\(프레젠테이션\) URI가 아니기 때문에 문제의 URI에 적용되지 않을 수 있습니다. 이 메서드는 집계 제어 URI에 적용될 수 있습니다.

---
#### **17.4.25.  461 Unsupported Transport**

전송 필드에 지원되는 전송 사양이 포함되어 있지 않습니다.

---
#### **17.4.26.  462 Destination Unreachable**

에이전트 주소에 연결할 수 없어 데이터 전송 채널을 설정할 수 없습니다. 이 오류는 에이전트가 전송 필드에 유효하지 않은 dest\_addr 매개변수를 배치하려고 시도한 결과일 가능성이 높습니다.

---
#### **17.4.27.  463 Destination Prohibited**

서버에서 해당 에이전트 주소에 대한 접근을 금지하여 데이터 전송 채널이 설정되지 않았습니다. 이 오류는 에이전트가 전송 헤더의 dest\_addr 매개변수를 사용하여 미디어 트래픽을 다른 대상으로 리디렉션하려고 시도한 결과일 가능성이 높습니다.

---
#### **17.4.28.  464 Data Transport Not Ready Yet**

미디어 대상에 대한 데이터 전송 채널이 아직 데이터를 전달할 준비가 되어 있지 않습니다. 그러나 응답 에이전트는 여전히 어느 시점에서는 데이터 전송 채널이 설정될 것으로 예상합니다. 그러나 이로 인해 462\(대상에 연결할 수 없음\)와 같은 영구적인 오류가 발생할 수 있습니다.

이 오류가 발생할 수 있는 예는 클라이언트가 미디어 데이터를 전달하기 위해 협상된 TCP 연결이 성공적으로 설정되었는지 확인하기 전에\(이 사양을 위반하여\) PLAY 요청을 서버에 보내는 경우입니다. 서버는 이 오류 코드를 사용하여 연결 설정 완료 실패로 인해 요청한 작업을 수행할 수 없음을 나타냅니다.

---
#### **17.4.29.  465 Notification Reason Unknown**

이는 클라이언트가 클라이언트에 알려지지 않은 Notify-Reason 헤더\(섹션 18.32\)와 함께 PLAY\_NOTIFY\(섹션 13.5\)를 수신했음을 나타냅니다.

---
#### **17.4.30.  466 Key Management Error**

이는 요청과 함께 사용되는 키 관리 기능에 오류가 있음을 나타냅니다. 예를 들어, 부록 C.1.4.1에 따라 MIKEY\(Multimedia Internet KEYing\) \[RFC3830\]을 사용하면 이 오류가 발생할 수 있습니다.

---
#### **17.4.31.  470 Connection Authorization Required**

보안 연결을 시도하려면 계속하기 전에 사용자 또는 클라이언트 인증이 필요합니다. 다음 홉의 인증서는 Accept-Credentials 헤더의 이 응답에 포함됩니다.

---
#### **17.4.32.  471 Connection Credentials Not Accepted**

여러 연결을 통해 보안 연결을 수행할 때 사용된 정책에 대해 허용되지 않는 자격 증명으로 인해 중개자가 다음 홉에 대한 연결과 요청 수행을 거부했습니다.

---
#### **17.4.33.  472 Failure to Establish Secure Connection**

프록시가 다음 홉 RTSP 에이전트에 대한 보안 연결을 설정하지 못했습니다. 이는 주로 TLS 핸드셰이크의 치명적인 실패\(예: 에이전트가 암호화 제품군을 허용하지 않음\)로 인해 발생합니다.

---
### **17.5.  Server Error 5xx**

숫자 "5"로 시작하는 응답 상태 코드는 서버가 오류가 발생했거나 요청을 수행할 수 없음을 인식하는 경우를 나타냅니다. 서버는 오류 상황에 대한 설명과 그것이 일시적인지 영구적인지 여부를 포함하는 메시지 본문을 포함해야 합니다. 사용자 에이전트는 포함된 메시지 본문을 사용자에게 표시해야 합니다. 이러한 응답 코드는 모든 요청 방법에 적용 가능합니다.\(SHOULD, SHOULD\)

---
#### **17.5.1.  500 Internal Server Error**

에이전트가 요청을 이행하지 못하게 하는 예상치 못한 상황에 직면했습니다.

---
#### **17.5.2.  501 Not Implemented**

에이전트가 요청을 이행하는 데 필요한 기능을 지원하지 않습니다. 이는 에이전트가 요청 방법을 인식하지 못하고 어떤 리소스에도 이를 지원할 수 없는 경우에 적합한 응답입니다.

---
#### **17.5.3.  502 Bad Gateway**

에이전트가 게이트웨이 또는 프록시 역할을 하는 동안 요청을 이행하려고 시도하는 동안 액세스한 업스트림 에이전트로부터 잘못된 응답을 받았습니다.

---
#### **17.5.4.  503 Service Unavailable**

일시적인 과부하 또는 서버 점검으로 인해 현재 서버에서 요청을 처리할 수 없습니다. 이는 이것이 약간의 지연 후에 완화될 일시적인 상태라는 것을 의미합니다. 알려진 경우 지연 길이는 Retry-After 헤더에 표시될 수 있습니다. Retry-After가 제공되지 않으면 에이전트는 500 응답과 마찬가지로 응답을 처리해야 합니다. 에이전트는 Retry-After 헤더에 길이가 주어지면 그 길이를 준수해야 합니다.\(MAY, SHOULD, MUST\)

- 참고: 503 상태 코드가 존재한다고 해서 서버가 과부하될 때 이를 사용해야 한다는 의미는 아닙니다. 일부 서버는 단순히 전송 연결을 거부하기를 원할 수도 있습니다.

응답 범위는 요청에 따라 다릅니다. 요청이 기존 RTSP 세션과 관련된 경우 오버로드 응답의 범위는 이 개별 RTSP 세션입니다. 요청이 특정 세션이 아니거나 RTSP 세션을 형성하려는 의도인 경우 요청-URI의 호스트 이름으로 식별되는 RTSP 서버에 적용됩니다.

---
#### **17.5.5.  504 Gateway Timeout**

에이전트는 프록시 역할을 하는 동안 요청을 완료하기 위해 액세스해야 하는 URI 또는 ​​일부 다른 보조 서버\(예: DNS\)로 지정된 업스트림 에이전트로부터 적시에 응답을 받지 못했습니다.

---
#### **17.5.6.  505 RTSP Version Not Supported**

에이전트는 요청 메시지에 사용된 RTSP 버전을 지원하지 않거나 지원을 거부합니다. 에이전트는 이 오류 메시지 외에는 에이전트와 동일한 주요 버전을 사용하여 요청을 완료할 수 없거나 완료할 의사가 없음을 나타냅니다. 응답에는 해당 버전이 지원되지 않는 이유와 해당 에이전트가 지원하는 다른 프로토콜을 설명하는 메시지 본문이 포함되어야 합니다.\(SHOULD\)

---
#### **17.5.7.  551 Option Not Supported**

필수 또는 프록시 필수 필드에 제공된 기능 태그가 지원되지 않았습니다. 지원되지 않는 기능을 나타내는 Unsupported 헤더가 반환되어야 합니다.\(MUST\)

---
#### **17.5.8.  553 Proxy Unavailable**

일시적인 과부하 또는 프록시 유지 관리로 인해 현재 프록시가 요청을 처리할 수 없습니다. 이는 이것이 약간의 지연 후에 완화될 일시적인 상태라는 것을 의미합니다. 알려진 경우 지연 길이는 Retry-After 헤더에 표시될 수 있습니다. Retry-After가 제공되지 않으면 에이전트는 500 응답과 마찬가지로 응답을 처리해야 합니다. 에이전트는 Retry-After 헤더에 제공된 경우 길이를 존중해야 합니다.\(MAY, SHOULD, MUST\)

- 참고: 553 상태 코드가 존재한다고 해서 프록시가 오버로드될 때 이를 사용해야 한다는 의미는 아닙니다. 일부 프록시는 단순히 연결을 거부할 수도 있습니다.

응답 범위는 요청에 따라 다릅니다. 요청이 기존 RTSP 세션과 관련된 경우 오버로드 응답의 범위는 이 개별 RTSP 세션입니다. 요청이 세션과 관련이 없거나 RTSP 세션을 형성하려는 경우 이 프록시에 대한 모든 요청에 ​​적용됩니다.

---
## **18.  Header Field Definitions**

```text
       +---------------+----------------+--------+---------+------+
       | method        | direction      | object | acronym | Body |
       +---------------+----------------+--------+---------+------+
       | DESCRIBE      | C -> S         | P,S    | DES     | r    |
       |               |                |        |         |      |
       | GET_PARAMETER | C -> S, S -> C | P,S    | GPR     | R,r  |
       |               |                |        |         |      |
       | OPTIONS       | C -> S, S -> C | P,S    | OPT     |      |
       |               |                |        |         |      |
       | PAUSE         | C -> S         | P,S    | PSE     |      |
       |               |                |        |         |      |
       | PLAY          | C -> S         | P,S    | PLY     |      |
       |               |                |        |         |      |
       | PLAY_NOTIFY   | S -> C         | P,S    | PNY     | R    |
       |               |                |        |         |      |
       | REDIRECT      | S -> C         | P,S    | RDR     |      |
       |               |                |        |         |      |
       | SETUP         | C -> S         | S      | STP     |      |
       |               |                |        |         |      |
       | SET_PARAMETER | C -> S, S -> C | P,S    | SPR     | R,r  |
       |               |                |        |         |      |
       | TEARDOWN      | C -> S         | P,S    | TRD     |      |
       |               |                |        |         |      |
       |               | S -> C         | P      | TRD     |      |
       +---------------+----------------+--------+---------+------+
```

이 표는 RTSP 방법, 해당 방향 및 작동하는 개체\(P: 프레젠테이션, S: 스트림\)에 대한 개요입니다. "본체"는 메소드가 본체를 운반할 수 있는지 여부와 그 방향을 나타냅니다. R = 요청, r=응답. 참고: 상태 4xx 및 5xx에 대한 모든 오류 메시지에는 본문을 전달할 수 있습니다.

- 표 8: RTSP 방법 개요

헤더 필드의 일반 구문은 섹션 5.2에서 다룹니다. 이 섹션에는 의미 및 사용법에 대한 참고 사항과 함께 전체 헤더 필드 세트가 나열되어 있습니다. 헤더 필드의 구문 정의는 섹션 20.2.3에 나와 있습니다. 각 헤더 필드의 예가 제공됩니다.

메소드 및 프록시 처리와 관련된 헤더 필드에 대한 정보는 그림 2, 3, 4 및 5에 요약되어 있습니다.

"where" 열은 헤더 필드가 사용될 수 있는 요청 및 응답 유형을 설명합니다. 이 열의 값은 다음과 같습니다.

```text
   R:                header field may only appear in requests;

   r:                header field may only appear in responses;

   2xx, 4xx, etc.:   numerical value or range indicates response codes
                     with which the header field can be used;
```

c: 헤더 필드가 요청에서 응답으로 복사됩니다.

G: 헤더 필드는 일반 헤더이며 요청과 응답 모두에 존재할 수 있습니다.

참고: 일반 헤더는 항상 "where" 열에 "G" 값을 사용하지 않습니다. 이는 헤더가 응답과 요청에 적용될 수 있는 시점의 차이 때문입니다. 이러한 차이가 있는 경우 두 개의 서로 다른 행을 사용하여 표현됩니다. 하나는 "where"가 "R"이고 다른 하나는 "r"입니다.

"프록시" 열은 프록시가 헤더 필드에서 수행할 수 있는 작업을 설명합니다. 빈 프록시 열은 프록시가 해당 헤더를 변경해서는 안 된다는 것을 나타내며, 허용되는 모든 작업은 명시적으로 명시됩니다.\(MUST NOT\)

a: 프록시는 헤더 필드가 없는 경우 헤더 필드를 추가하거나 연결할 수 있습니다.

m: 프록시는 기존 헤더 필드 값을 수정할 수 있습니다.

d: 프록시는 헤더 필드 값을 삭제할 수 있습니다.

r: 프록시는 헤더 필드를 읽을 수 있어야 합니다. 따라서 이 헤더 필드는 암호화될 수 없습니다.

나머지 열은 메소드의 헤더 필드 존재와 관련됩니다. 축약된 메소드 이름은 표 8에 따릅니다.

c: 조건부; 헤더 필드의 요구 사항은 메시지의 컨텍스트에 따라 달라집니다.

m: 헤더 필드는 필수입니다.

m\*: 헤더 필드는 전송되어야 하지만 에이전트는 해당 헤더 필드 없이 메시지를 수신할 준비가 되어 있어야 합니다.\(SHOULD\)

o: 헤더 필드는 선택 사항입니다.

\*: 메시지 본문이 비어 있지 않으면 헤더 필드가 있어야 합니다. 자세한 내용은 섹션 18.17, 18.19 및 5.3을 참조하십시오.\(MUST\)

-: 헤더 필드를 적용할 수 없습니다.

"선택적"은 에이전트가 요청 또는 응답에 헤더 필드를 포함할 수 있음을 의미합니다. 그러한 헤더를 수신할 때 에이전트의 동작은 다양합니다. 일부의 경우 헤더 필드를 무시할 수 있습니다. 다른 경우에는 헤더 처리 요청입니다. 이는 메소드와 헤더 설명에 의해 규제됩니다. 처리가 필요한 헤더의 예로는 섹션 18.43 및 18.37에서 설명한 Require 및 Proxy-Require 헤더 필드가 있습니다. 요청에는 "필수" 헤더 필드가 있어야 하며 요청을 수신하는 에이전트가 이를 이해해야 합니다. 응답에는 필수 응답 헤더 필드가 있어야 하며, 응답 처리 시 헤더 필드를 이해해야 합니다. "해당 사항 없음"은 헤더 필드가 요청에 있어서는 안 된다는 의미입니다. 실수로 요청에 포함된 경우 요청을 받는 에이전트는 이를 무시해야 합니다. 마찬가지로, 응답에 대해 "해당 없음"이라고 표시된 헤더 필드는 에이전트가 응답에 헤더 필드를 배치해서는 안 되며 에이전트가 응답의 헤더 필드를 무시해야 함을 의미합니다.\(MAY, MUST, MUST, MUST NOT, MUST, MUST NOT\)

RTSP 에이전트는 이해되지 않는 확장 헤더를 무시해야 합니다.\(MUST\)

From 및 Location 헤더 필드에는 URI가 포함되어 있습니다. URI에 쉼표\('\) 또는 세미콜론\(;\)이 포함된 경우 URI는 큰따옴표\("\)로 묶어야 합니다. 모든 URI 매개변수는 이러한 따옴표 안에 포함됩니다. URI가 큰따옴표로 묶이지 않은 경우 세미콜론으로 구분된 모든 매개변수는 매개변수는 URI 매개변수가 아닌 헤더 매개변수입니다.\(MUST\)

```text
   +-------------------+------+------+----+----+-----+-----+-----+-----+
   | Header            |Where |Proxy |DES | OPT| STP | PLY | PSE | TRD |
   +-------------------+------+------+----+----+-----+-----+-----+-----+
   | Accept            | R    |      | o  | -  | -   | -   | -   | -   |
   | Accept-           | R    | rm   | o  | o  | o   | o   | o   | o   |
   | Credentials       |      |      |    |    |     |     |     |     |
   | Accept-Encoding   | R    | r    | o  | -  | -   | -   | -   | -   |
   | Accept-Language   | R    | r    | o  | -  | -   | -   | -   | -   |
   | Accept-Ranges     | G    | r    | -  | -  | m   | -   | -   | -   |
   | Accept-Ranges     | 456  | r    | -  | -  | -   | m   | -   | -   |
   | Allow             | r    | am   | c  | c  | c   | -   | -   | -   |
   | Allow             | 405  | am   | m  | m  | m   | m   | m   | m   |
   | Authentication-   | r    |      | o  | o  | o   | o   | o   | o/- |
   | Info              |      |      |    |    |     |     |     |     |
   | Authorization     | R    |      | o  | o  | o   | o   | o   | o/- |
   | Bandwidth         | R    |      | o  | o  | o   | o   | -   | -   |
   | Blocksize         | R    |      | o  | -  | o   | o   | -   | -   |
   | Cache-Control     | G    | r    | o  | -  | o   | -   | -   | -   |
   | Connection        | G    | ad   | o  | o  | o   | o   | o   | o   |
   | Connection-       | 470, | ar   | o  | o  | o   | o   | o   | o   |
   | Credentials       | 407  |      |    |    |     |     |     |     |
   | Content-Base      | r    |      | o  | -  | -   | -   | -   | -   |
   | Content-Base      | 4xx, |      | o  | o  | o   | o   | o   | o   |
   |                   | 5xx  |      |    |    |     |     |     |     |
   | Content-Encoding  | R    | r    | -  | -  | -   | -   | -   | -   |
   | Content-Encoding  | r    | r    | o  | -  | -   | -   | -   | -   |
   | Content-Encoding  | 4xx, | r    | o  | o  | o   | o   | o   | o   |
   |                   | 5xx  |      |    |    |     |     |     |     |
   | Content-Language  | R    | r    | -  | -  | -   | -   | -   | -   |
   | Content-Language  | r    | r    | o  | -  | -   | -   | -   | -   |
   | Content-Language  | 4xx, | r    | o  | o  | o   | o   | o   | o   |
   |                   | 5xx  |      |    |    |     |     |     |     |
   | Content-Length    | r    | r    | *  | -  | -   | -   | -   | -   |
   | Content-Length    | 4xx, | r    | *  | *  | *   | *   | *   | *   |
   |                   | 5xx  |      |    |    |     |     |     |     |
   | Content-Location  | r    | r    | o  | -  | -   | -   | -   | -   |
   | Content-Location  | 4xx, | r    | o  | o  | o   | o   | o   | o   |
   |                   | 5xx  |      |    |    |     |     |     |     |
   | Content-Type      | r    | r    | *  | -  | -   | -   | -   | -   |
   | Content-Type      | 4xx, | ar   | *  | *  | *   | *   | *   | *   |
   |                   | 5xx  |      |    |    |     |     |     |     |
   | CSeq              | Gc   | rm   | m  | m  | m   | m   | m   | m   |
   | Date              | G    | am   | o/*| o/*| o/* | o/* | o/* | o/* |
   | Expires           | r    | r    | o  | -  | o   | -   | -   | -   |
   | From              | R    | r    | o  | o  | o   | o   | o   | o   |
   | If-Match          | R    | r    | -  | -  | o   | -   | -   | -   |
   | If-Modified-Since | R    | r    | o  | -  | o   | -   | -   | -   |
   | If-None-Match     | R    | r    | o  | -  | o   | -   | -   | -   |

   | Last-Modified     | r    | r    | o  | -  | o   | -   | -   | -   |
   | Location          | 3rr  |      | m  | m  | m   | m   | m   | m   |
   +-------------------+------+------+----+----+-----+-----+-----+-----+
   | Header            |Where |Proxy |DES | OPT| STP | PLY | PSE | TRD |
   +-------------------+------+------+----+----+-----+-----+-----+-----+

     Figure 2: Overview of RTSP Header Fields (A-L) Related to Methods
            DESCRIBE, OPTIONS, SETUP, PLAY, PAUSE, and TEARDOWN

   +------------------+---------+-----+----+----+----+-----+-----+-----+
   | Header           | Where   |Proxy|DES |OPT |STP | PLY | PSE | TRD |
   +------------------+---------+-----+----+----+----+-----+-----+-----+
   | Media-Properties | r       |     | -  | -  | m  | o   | o   | -   |
   | Media-Range      | r       |     | -  | -  | c  | c   | c   | -   |
   | MTag             | r       | r   | o  | -  | o  | -   | -   | -   |
   | Pipelined-       | G       | amd | -  | o  | o  | o   | o   | o   |
   | Requests         |         | r   |    |    |    |     |     |     |
   | Proxy-           | 407     | amr | m  | m  | m  | m   | m   | m   |
   | Authenticate     |         |     |    |    |    |     |     |     |
   | Proxy-           | r       | amd | o  | o  | o  | o   | o   | o/- |
   | Authentication-  |         | r   |    |    |    |     |     |     |
   | Info             |         |     |    |    |    |     |     |     |
   | Proxy-           | R       | rd  | o  | o  | o  | o   | o   | o   |
   | Authorization    |         |     |    |    |    |     |     |     |
   | Proxy-Require    | R       | ar  | o  | o  | o  | o   | o   | o   |
   | Proxy-Require    | r       | r   | c  | c  | c  | c   | c   | c   |
   | Proxy-Supported  | R       | amr | c  | c  | c  | c   | c   | c   |
   | Proxy-Supported  | r       |     | c  | c  | c  | c   | c   | c   |
   | Public           | r       | amr | -  | m  | -  | -   | -   | -   |
   | Public           | 501     | amr | m  | m  | m  | m   | m   | m   |
   | Range            | R       |     | -  | -  | -  | o   | -   | -   |
   | Range            | r       |     | -  | -  | c  | m   | m   | -   |
   | Referrer         | R       |     | o  | o  | o  | o   | o   | o   |
   | Request-Status   | R       |     | -  | -  | -  | -   | -   | -   |
   | Require          | R       |     | o  | o  | o  | o   | o   | o   |
   | Retry-After      | 3rr,503 |     | o  | o  | o  | o   | o   | -   |
   |                  | ,553    |     |    |    |    |     |     |     |
   | Retry-After      | 413     |     | o  | -  | -  | -   | -   | -   |
   | RTP-Info         | r       |     | -  | -  | c  | c   | -   | -   |
   | Scale            | R       | r   | -  | -  | -  | o   | -   | -   |
   | Scale            | r       | amr | -  | -  | c  | c   | c   | -   |
   | Seek-Style       | R       |     | -  | -  | -  | o   | -   | -   |
   | Seek-Style       | r       |     | -  | -  | -  | m   | -   | -   |
   | Server           | R       | r   | -  | o  | -  | -   | -   | o   |
   | Server           | r       | r   | o  | o  | o  | o   | o   | o   |
   | Session          | R       | r   | -  | o  | o  | m   | m   | m   |
   | Session          | r       | r   | -  | c  | m  | m   | m   | o   |
   | Speed            | R       | admr| -  | -  | -  | o   | -   | -   |
   | Speed            | r       | admr| -  | -  | -  | c   | -   | -   |
   | Supported        | R       | r   | o  | o  | o  | o   | o   | o   |
   | Supported        | r       | r   | c  | c  | c  | c   | c   | c   |
   | Terminate-Reason | R       | r   | -  | -  | -  | -   | -   | -/o |
   | Timestamp        | R       | admr| o  | o  | o  | o   | o   | o   |
   | Timestamp        | c       | admr| m  | m  | m  | m   | m   | m   |
   | Transport        | G       | mr  | -  | -  | m  | -   | -   | -   |
   | Unsupported      | r       |     | c  | c  | c  | c   | c   | c   |
   | User-Agent       | R       |     | m* | m* | m* | m*  | m*  | m*  |

   | Via              | R       | amr | c  | c  | c  | c   | c   | c   |
   | Via              | r       | amr | c  | c  | c  | c   | c   | c   |
   | WWW-Authenticate | 401     |     | m  | m  | m  | m   | m   | m   |
   +------------------+---------+-----+----+----+----+-----+-----+-----+
   | Header           | Where   |Proxy|DES |OPT |STP | PLY | PSE | TRD |
   +------------------+---------+-----+----+----+----+-----+-----+-----+

     Figure 3: Overview of RTSP Header Fields (M-W) Related to Methods
            DESCRIBE, OPTIONS, SETUP, PLAY, PAUSE, and TEARDOWN

   +---------------------------+-------+-------+-----+-----+-----+-----+
   | Header                    | Where | Proxy | GPR | SPR | RDR | PNY |
   +---------------------------+-------+-------+-----+-----+-----+-----+
   | Accept-Credentials        | R     | rm    | o   | o   | o   | -   |
   | Accept-Encoding           | R     | r     | o   | o   | o   | -   |
   | Accept-Language           | R     | r     | o   | o   | o   | -   |
   | Accept-Ranges             | G     | rm    | o   | -   | -   | -   |
   | Allow                     | 405   | amr   | m   | m   | m   | m   |
   | Authentication-Info       | r     |       | o/- | o/- | -   | -   |
   | Authorization             | R     |       | o   | o   | o   | -   |
   | Bandwidth                 | R     |       | -   | o   | -   | -   |
   | Blocksize                 | R     |       | -   | o   | -   | -   |
   | Cache-Control             | G     | r     | o   | o   | -   | -   |
   | Connection                | G     |       | o   | o   | o   | o   |
   | Connection-Credentials    | 470,  | ar    | o   | o   | o   | -   |
   |                           | 407   |       |     |     |     |     |
   | Content-Base              | R     |       | o   | o   | -   | o   |
   | Content-Base              | r     |       | o   | o   | -   | -   |
   | Content-Base              | 4xx,  |       | o   | o   | o   | o   |
   |                           | 5xx   |       |     |     |     |     |
   | Content-Encoding          | R     | r     | o   | o   | -   | o   |
   | Content-Encoding          | r     | r     | o   | o   | -   | -   |
   | Content-Encoding          | 4xx,  | r     | o   | o   | o   | o   |
   |                           | 5xx   |       |     |     |     |     |
   | Content-Language          | R     | r     | o   | o   | -   | o   |
   | Content-Language          | r     | r     | o   | o   | -   | -   |
   | Content-Language          | 4xx,  | r     | o   | o   | o   | o   |
   |                           | 5xx   |       |     |     |     |     |
   | Content-Length            | R     | r     | *   | *   | -   | *   |
   | Content-Length            | r     | r     | *   | *   | -   | -   |
   | Content-Length            | 4xx,  | r     | *   | *   | *   | *   |
   |                           | 5xx   |       |     |     |     |     |
   | Content-Location          | R     |       | o   | o   | -   | o   |
   | Content-Location          | r     |       | o   | o   | -   | -   |
   | Content-Location          | 4xx,  |       | o   | o   | o   | o   |
   |                           | 5xx   |       |     |     |     |     |
   | Content-Type              | R     |       | *   | *   | -   | *   |
   | Content-Type              | r     |       | *   | *   | -   | -   |
   | Content-Type              | 4xx,  |       | *   | *   | *   | *   |
   |                           | 5xx   |       |     |     |     |     |
   | CSeq                      | R,c   | mr    | m   | m   | m   | m   |
   | Date                      | R     | a     | o/* | o/* | m   | o/* |
   | Date                      | r     | am    | o/* | o/* | o/* | o/* |
   | Expires                   | r     | r     | -   | -   | -   | -   |
   | From                      | R     | r     | o   | o   | o   | -   |
   | If-Match                  | R     | r     | -   | -   | -   | -   |
   | If-Modified-Since         | R     | am    | o   | -   | -   | -   |
   | If-None-Match             | R     | am    | o   | -   | -   | -   |

   | Last-Modified             | R     | r     | -   | -   | -   | -   |
   | Last-Modified             | r     | r     | o   | -   | -   | -   |
   | Location                  | 3rr   |       | m   | m   | m   | -   |
   | Location                  | R     |       | -   | -   | m   | -   |
   +---------------------------+-------+-------+-----+-----+-----+-----+
   | Header                    | Where | Proxy | GPR | SPR | RDR | PNY |
   +---------------------------+-------+-------+-----+-----+-----+-----+

     Figure 4: Overview of RTSP Header Fields (A-L) Related to Methods
          GET_PARAMETER, SET_PARAMETER, REDIRECT, and PLAY_NOTIFY

 +---------------------------+---------+-------+-----+-----+-----+-----+
 | Header                    |  Where  | Proxy | GPR | SPR | RDR | PNY |
 +---------------------------+---------+-------+-----+-----+-----+-----+
 | Media-Properties          | R       | amr   | o   | -   | -   | c   |
 | Media-Properties          | r       | mr    | c   | -   | -   | -   |
 | Media-Range               | R       |       | o   | -   | -   | c   |
 | Media-Range               | r       |       | c   | -   | -   | -   |
 | MTag                      | r       | r     | o   | -   | -   | -   |
 | Notify-Reason             | R       |       | -   | -   | -   | m   |
 | Pipelined-Requests        | R       | amdr  | o   | o   | -   | -   |
 | Proxy-Authenticate        | 407     | amdr  | m   | m   | m   | -   |
 | Proxy-Authentication-Info | r       | amdr  | o/- | o/- | -   | -   |
 | Proxy-Authorization       | R       | amdr  | o   | o   | o   | -   |
 | Proxy-Require             | R       | ar    | o   | o   | o   | -   |
 | Proxy-Supported           | R       | amr   | c   | c   | c   | -   |
 | Proxy-Supported           | r       |       | c   | c   | c   | -   |
 | Public                    | 501     | admr  | m   | m   | m   | -   |
 | Range                     | R       |       | o   | -   | -   | m   |
 | Range                     | r       |       | c   | -   | -   | -   |
 | Referrer                  | R       |       | o   | o   | o   | -   |
 | Request-Status            | R       | mr    | -   | -   | -   | c   |
 | Require                   | R       | r     | o   | o   | o   | o   |
 | Retry-After               | 3rr,503,|       | o   | o   | -   | -   |
 |                           | 553     |       |     |     |     |     |
 | Retry-After               | 413     |       | o   | o   | -   | -   |
 | RTP-Info                  | R       | r     | o   | -   | -   | C   |
 | RTP-Info                  | r       | r     | c   | -   | -   | -   |
 | Scale                     | G       |       | c   | -   | c   | c   |
 | Seek-Style                | G       |       | -   | -   | -   | -   |
 | Server                    | R       | r     | o   | o   | o   | o   |
 | Server                    | r       | r     | o   | o   | -   | -   |
 | Session                   | R       | r     | o   | o   | o   | m   |
 | Session                   | r       | r     | c   | c   | o   | m   |
 | Speed                     | G       |       | -   | -   | -   | -   |
 | Supported                 | R       | r     | o   | o   | o   | -   |
 | Supported                 | r       | r     | c   | c   | c   | -   |
 | Terminate-Reason          | R       | r     | -   | -   | m   | -   |
 | Timestamp                 | R       | adrm  | o   | o   | o   | o   |
 | Timestamp                 | c       | adrm  | m   | m   | m   | m   |
 | Transport                 | G       | mr    | -   | -   | -   | -   |
 | Unsupported               | r       | arm   | c   | c   | c   | c   |
 | User-Agent                | R       | r     | m*  | m*  | -   | -   |
 | User-Agent                | r       | r     | m*  | m*  | m*  | m*  |
 | Via                       | R       | amr   | c   | c   | c   | c   |

 | Via                       | r       | amr   | c   | c   | c   | c   |
 | WWW-Authenticate          | 401     |       | m   | m   | m   | -   |
 +---------------------------+---------+-------+-----+-----+-----+-----+
 | Header                    |  Where  | Proxy | GPR | SPR | RDR | PNY |
 +---------------------------+---------+-------+-----+-----+-----+-----+

     Figure 5: Overview of RTSP Header Fields (M-W) Related to Methods
          GET_PARAMETER, SET_PARAMETER, REDIRECT, and PLAY_NOTIFY
```

---
### **18.1.  Accept**

Accept 요청 헤더 필드는 DESCRIBE 요청에 대한 응답에 허용되는 특정 프리젠테이션 설명 및 매개변수 미디어 유형 \[RFC6838\]을 지정하는 데 사용될 수 있습니다.

구문은 섹션 20.2.3을 참조하세요.

별표 "\*" 문자는 미디어 유형을 범위로 그룹화하는 데 사용됩니다. "\*/\*"는 모든 미디어 유형을 나타내고 "type/\*"은 해당 유형의 모든 하위 유형을 나타냅니다. 범위에는 일반적으로 해당 범위에 적용할 수 있는 미디어 유형 매개변수가 포함될 수 있습니다.\(MAY\)

각 미디어 유형 또는 범위 뒤에는 상대적인 품질 요소를 나타내기 위해 "q" 매개변수로 시작하는 하나 이상의 accept- 매개변수가 올 수 있습니다. 첫 번째 "q" 매개변수\(있는 경우\)는 미디어 유형이나 범위의 매개변수를 accept-params에서 분리합니다. 품질 요소를 사용하면 사용자 또는 사용자 에이전트는 0에서 1까지의 qvalue 척도를 사용하여 해당 미디어 유형에 대한 상대적인 선호도를 나타낼 수 있습니다\(\[RFC7231\]의 섹션 5.3.1\). 기본값은 q=1입니다.\(MAY\)

사용 예:

```text
     Accept: application/example ;q=0.7, application/sdp
```

요청 에이전트가 기본 1.0 등급을 통해 미디어 유형 application/sdp를 선호하지만 품질 등급이 0.7인 application/example 미디어 유형도 허용함을 나타냅니다.

Accept 헤더 필드가 없으면 클라이언트가 모든 미디어 유형을 수락하는 것으로 간주됩니다. Accept 헤더 필드가 존재하고 서버가 결합된 Accept 필드 값에 따라 허용 가능한 응답을 보낼 수 없는 경우 서버는 406\(허용되지 않음\) 응답을 보내야 합니다.\(SHOULD\)

---
### **18.2.  Accept-Credentials**

Accept-Credentials 헤더는 신뢰할 수 있는 중개자에게 프록시 또는 서버에 대한 추가 보안 연결을 처리하는 방법을 나타내는 데 사용되는 요청 헤더입니다. 서버-클라이언트 요청에 포함되어서는 안 됩니다. 이 헤더의 사용법은 섹션 19를 참조하세요.\(MUST NOT\)

요청에서 헤더에는 요청자가 선택한 자격 증명을 승인하기 위한 방법\(사용자, 프록시 또는 임의\)이 포함되어야 합니다. 프록시가 각 추가 홉을 승인하는 사용자의 역할을 수행하기 위해 이를 "사용자"로 변경할 수 있는 경우 "프록시"가 아닌 한, 메서드는 프록시에 의해 변경되어서는 안 됩니다. 메서드가 "User"인 경우 헤더에는 클라이언트가 수락하는 자격 증명이 0개 이상 포함되어 있습니다. "사용자" 방법을 사용할 때 헤더에는 프록시를 통해 RTSP 서버에 대한 첫 번째 RTSP 요청에 자격 증명이 없을 수 있습니다. 이는 클라이언트가 아직 수락할 자격 증명을 받지 못했기 때문입니다. 각 자격 증명은 프록시 또는 서버를 식별하는 하나의 URI, 해시 알고리즘 식별자, \[RFC4648\]의 섹션 4에 따라 Base64에서 해당 에이전트의 ASN.1 DER 인코딩 인증서\[RFC5280\]에 대한 해시로 구성되어야 하며 여기서 패딩 비트는 0으로 설정됩니다. 모든 RTSP 클라이언트와 프록시는 DER로 인코딩된 인증서의 해시 계산을 위해 SHA-256 \[FIPS180-4\] 알고리즘을 구현해야 합니다. SHA-256 알고리즘은 "sha-256" 토큰으로 식별됩니다.\(MUST, MUST NOT, MUST, MUST\)

다른 해시 알고리즘을 허용하려는 의도는 여기가 아닌 다른 곳에서는 구현되지 않은 알고리즘의 향후 폐기를 가능하게 하는 것입니다. 따라서 이 목적을 위한 미래 알고리즘의 정의는 극히 제한될 예정입니다. 대체 알고리즘에 대한 지원이 존재하는지 확인하기 위해 기능 태그를 사용할 수 있습니다.

```text
   Example:

   Accept-Credentials:User
     "rtsps://proxy2.example.com/";sha-256;exaIl9VMbQMOFGClx5rXnPJKVNI=,
     "rtsps://server.example.com/";sha-256;lurbjj5khhB0NhIuOXtt4bBRH1M=
```

---
### **18.3.  Accept-Encoding**

Accept-Encoding 요청 헤더 필드는 Accept와 유사하지만 콘텐츠 코딩\(섹션 18.15 참조\), 즉 응답에서 허용되는 gzip 압축과 같은 메시지 본문의 변환 코딩을 제한합니다.

서버는 다음 규칙을 사용하여 Accept-Encoding 필드에 따라 콘텐츠 코딩이 허용되는지 여부를 테스트합니다.

```text
   1.  If the content-coding is one of the content-codings listed in the
       Accept-Encoding field, then it is acceptable, unless it is
       accompanied by a qvalue of 0.  (As defined in Section 5.3.1 of
       [RFC7231], a qvalue of 0 means "not acceptable.")
```

2. Accept-Encoding 필드의 특수 "\*" 기호는 헤더 필드에 명시적으로 나열되지 않은 사용 가능한 모든 콘텐츠 코딩과 일치합니다.

3. 여러 콘텐츠 코딩이 허용되는 경우 0이 아닌 가장 높은 q값을 가진 허용 가능한 콘텐츠 코딩이 선호됩니다.

4. "identity" 콘텐츠 코딩은 항상 허용됩니다. 즉, Accept-Encoding 필드에 "identity;q=0"이 포함되거나 필드에 "\*;q=0"이 포함되어 있기 때문에 특별히 거부되지 않는 한 전혀 변환이 없습니다. "ID" 콘텐츠 코딩을 명시적으로 포함하지 않습니다. Accept-Encoding 필드 값이 비어 있으면 "ID" 인코딩만 허용됩니다.

요청에 Accept-Encoding 필드가 있고 서버가 Accept-Encoding 헤더에 따라 허용 가능한 응답을 보낼 수 없는 경우 서버는 406\(허용되지 않음\) 상태 코드와 함께 오류 응답을 보내야 합니다.\(SHOULD\)

요청에 Accept-Encoding 필드가 없으면 서버는 클라이언트가 모든 콘텐츠 코딩을 수락할 것이라고 가정할 수 있습니다. 이 경우 "ID"가 사용 가능한 콘텐츠 코딩 중 하나인 경우 서버는 다른 콘텐츠 코딩이 클라이언트에 의미가 있다는 추가 정보가 없는 한 "ID" 콘텐츠 코딩을 사용해야 합니다.\(MAY, SHOULD\)

---
### **18.4.  Accept-Language**

Accept-Language 요청 헤더 필드는 Accept와 유사하지만 요청에 대한 응답으로 선호되는 자연어 세트를 제한합니다. 지정된 언어는 프레젠테이션 설명\(응답 메시지 본문\) 및 이유 문구에 적용되지만 미디어 콘텐츠에는 적용되지 않습니다.

언어 태그는 다른 인간에게 정보를 전달하기 위해 인간이 말하거나, 쓰거나, 전달하는 자연어를 식별합니다. 컴퓨터 언어는 명시적으로 제외됩니다. RTSP 2.0 언어 태그의 구문과 레지스트리는 \[RFC5646\]에 정의된 것과 동일합니다.

각 언어 범위에는 해당 범위에 지정된 언어에 대한 사용자 선호도의 추정치를 나타내는 관련 품질 값이 제공될 수 있습니다. 품질 값의 기본값은 "q=1"입니다. 예를 들어:\(MAY\)

```text
      Accept-Language: da, en-gb;q=0.8, en;q=0.7
```

"나는 덴마크어를 선호하지만 영국식 영어와 다른 유형의 영어도 허용합니다."라는 의미입니다. 언어 범위는 전체 태그와 정확히 같거나 태그의 접두사\(즉, ABNF의 기본 태그\)와 정확히 같으면 언어 태그와 일치합니다. 즉, 기본 태그 다음의 문자는 "-"입니다. Accept-Language 필드에 있는 특수 범위 "\*"는 Accept-Language 필드에 있는 다른 범위와 일치하지 않는 모든 태그와 일치합니다.

- 참고: 접두사 일치 규칙을 사용한다고 해서 사용자가 특정 태그가 있는 언어를 이해하면 이 사용자가 해당 태그가 있는 모든 언어도 이해할 것이라는 것이 항상 사실인 방식으로 언어 태그가 언어에 할당된다는 의미는 아닙니다. 이 태그가 접두사인 태그입니다. 접두사 규칙은 이 경우 접두사 태그의 사용을 허용합니다.

언어를 선택하는 과정에서 각 언어 태그에는 자격 요소가 할당됩니다. 즉, 클라이언트가 지원하는 언어가 실제로 서버에서 지원되는지 여부와 해당 언어가 어떤 "기본 설정" 수준을 달성하는지를 나타냅니다. 해당 필드에서 언어 태그와 일치하는 가장 긴 언어 범위의 품질 값\(q-value\)이 특정 언어 태그에 대한 자격 요소로 할당됩니다. 필드의 언어 범위가 태그와 일치하지 않으면 할당된 언어 자격 요소는 0입니다. 요청에 Accept-Language 헤더가 없으면 서버는 모든 언어가 동일하게 허용된다고 가정해야 합니다. Accept-Language 헤더가 있는 경우 0보다 큰 자격 요소가 할당된 모든 언어가 허용됩니다.\(SHOULD\)

---
### **18.5.  Accept-Ranges**

Accept-Ranges 일반 헤더 필드를 사용하면 Range 헤더에서 지원되는 형식을 표시할 수 있습니다. 클라이언트는 PLAY 및 PAUSE 응답과 REDIRECT 요청에서 수신될 때 허용되는 형식을 나타내기 위해 SETUP 요청에 헤더를 포함해야 합니다. 서버는 Request-URI에 의해 표시된 리소스에 대해 지원되는 형식을 나타내기 위해 SETUP 응답과 456\(리소스에 유효하지 않은 헤더 필드\) 오류 응답에 헤더를 포함해야 합니다. 헤더는 GET\_PARAMETER 요청 및 응답 쌍에 포함될 수 있습니다. GET\_PARAMETER 요청에는 세션 헤더가 포함되어 있어야 합니다.\(MUST, MUST, MAY, MUST\)

요청과 관련된 세션 컨텍스트입니다. 요청자와 응답자는 각각 Range 형식에 관한 능력을 표시합니다.

```text
      Accept-Ranges: npt, smpte, clock
```

구문은 섹션 20.2.3에 정의되어 있습니다.

---
### **18.6.  Allow**

메시지 본문 허용 헤더 필드에는 요청-URI로 식별된 리소스가 지원하는 방법이 나열됩니다. 이 필드의 목적은 리소스와 관련된 유효한 메서드의 전체 집합을 수신자에게 알리는 것입니다. Allow 헤더 필드는 405\(Method Not Allowed\) 응답에 있어야 합니다. Allow 헤더는 헤더의 내용이 Public 헤더에 나열된 것과 정확히 동일한 메서드를 포함하지 않는 모든 OPTIONS 응답에도 있어야 합니다.\(MUST, MUST\)

리소스에 허용된 방법이 이 메모에 정의된 전체 방법 집합과 다른 경우 Allow 메시지 본문 헤더도 SETUP 및 DESCRIBE 응답에 포함되어야 합니다.\(MUST\)

사용 예:

```text
      Allow: SETUP, PLAY, SET_PARAMETER, DESCRIBE
```

---
### **18.7.  Authentication-Info**

Authentication-Info 응답 헤더는 서버가 응답 메시지에서 성공적인 HTTP 인증 \[RFC7235\]에 관한 일부 정보를 전달하는 데 사용됩니다. 헤더의 정의는 \[RFC7615\]에 있으며 적용 가능한 모든 HTTP 인증 체계는 Digest \[RFC7616\]와 같은 다른 RFC에 나타납니다. 이 헤더는 클라이언트에서 서버로의 요청과 관련된 응답 메시지에만 사용해야 합니다.\(MUST\)

---
### **18.8.  Authorization**

HTTP \[RFC7235\]의 인증 메커니즘을 사용하여 서버에 자신을 인증하려는 RTSP 클라이언트는 일반적으로\(반드시 그런 것은 아니지만\) 401 응답을 받은 후 요청에 Authorization 요청 헤더 필드를 포함하여 인증을 수행합니다. Authorization 필드 값은 요청 중인 리소스 영역에 대한 사용자 에이전트의 인증 정보가 포함된 자격 증명으로 구성됩니다. 헤더의 정의는 다음과 같습니다.

\[RFC7235\] 및 적용 가능한 모든 HTTP 인증 체계는 다이제스트 \[RFC7616\] 및 기본 \[RFC7617\]과 같은 다른 RFC에 나타납니다. 이 헤더는 클라이언트-서버 요청에만 사용해야 합니다.\(MUST\)

요청이 인증되고 영역이 지정된 경우 동일한 자격 증명이 이 영역 내의 다른 모든 요청에 ​​대해 유효해야 합니다\(인증 체계 자체가 챌린지 값에 따라 달라지는 자격 증명이나 동기화된 시계를 사용하는 것과 같은 달리 요구하지 않는다고 가정\). . 각 클라이언트-서버 요청은 정보와 함께 Authorization 헤더를 포함하여 개별적으로 승인되어야 합니다.\(SHOULD, MUST\)

공유 캐시\(섹션 16 참조\)가 Authorization 필드를 포함하는 요청을 수신하면 다음 특정 예외 중 하나가 유지되지 않는 한 다른 요청에 대한 응답으로 해당 응답을 반환해서는 안 됩니다.\(MUST NOT\)

1. 응답에 "max-age" 캐시 지시문이 포함된 경우 캐시는 후속 요청에 응답할 때 해당 응답을 사용할 수 있습니다. 그러나 \(지정된 최대 수명이 지난 경우\) 프록시 캐시는 원본 서버가 새 요청을 인증할 수 있도록 새 요청의 요청 헤더를 사용하여 먼저 원본 서버에서 캐시를 재검증해야 합니다. \(이것은 max-age에 대해 정의된 동작입니다.\) 응답에 "max-age=0"이 포함된 경우 프록시는 재사용하기 전에 항상 이를 재검증해야 합니다.\(MAY, MUST, MUST\)

2. 응답에 "must-revalidate" 캐시 제어 지시문이 포함된 경우 캐시는 후속 요청에 응답할 때 해당 응답을 사용할 수 있습니다. 그러나 응답이 오래되면 모든 캐시는 원본 서버가 새 요청을 인증할 수 있도록 새 요청의 요청 헤더를 사용하여 원본 서버에서 먼저 이를 재검증해야 합니다.\(MAY, MUST\)

3. 응답에 "public" 캐시 지시문이 포함된 경우 후속 요청에 대한 응답으로 반환될 수 있습니다.\(MAY\)

---
### **18.9.  Bandwidth**

대역폭 요청 헤더 필드는 클라이언트가 사용할 수 있는 예상 대역폭을 설명하며 양의 정수로 표시되고 초당 킬로비트 단위로 측정됩니다. 클라이언트가 사용할 수 있는 대역폭은 이동성, 혼잡 등으로 인해 RTSP 세션 중에 변경될 수 있습니다.

예를 들어, 첫 번째 홉이 병목 현상을 일으키지 않기 때문에 클라이언트는 사용 가능한 대역폭을 정확하게 확인하지 못할 수 있습니다. 이러한 경우는 LAN\(근거리 통신망\)이 병목 현상이 아닌 대신 LAN의 인터넷 액세스 링크가 병목 현상을 일으키는 경우입니다.

동일한 LAN에 있지 않습니다. 따라서 WLAN 또는 이더넷 네트워크의 링크 속도는 일반적으로 사용 가능한 대역폭을 추정하는 기준이 아닙니다. 모뎀이나 연결 지원 장치에 직접 연결된 셀룰러 장치 또는 기타 장치는 병목 현상 대역폭과 RTSP 제어 미디어에 대한 합리적인 공유 비율을 더 정확하게 추정할 수 있습니다. 클라이언트는 병목 현상을 공유하는 다른 트래픽도 고려해야 합니다. 예를 들어 RTSP 및 해당 미디어 스트림에 특정 부분만 할당하면 됩니다. 대역폭 병목 현상에 대한 정확하고 명시적인 정보를 가지고 있는 클라이언트만 이 헤더를 사용하는 것이 좋습니다.\(SHOULD\)

이 헤더는 적절한 혼잡 제어를 대체하지 않습니다. 이는 초기 추정치를 제공하고 선택한 컨텐츠가 전혀 전달될 수 있는지 대략적으로 판단하는 방법일 뿐입니다.

```text
   Example:

     Bandwidth: 62360
```

---
### **18.10.  Blocksize**

Blocksize 요청 헤더 필드는 클라이언트에서 미디어 서버로 전송되어 서버에 특정 미디어 패킷 크기를 요청합니다. 이 패킷 크기에는 IP, UDP 또는 RTP와 같은 하위 계층 헤더가 포함되지 않습니다. 서버는 요청된 것보다 작은 블록 크기를 자유롭게 사용할 수 있습니다. 서버는 이 패킷 크기를 최소 미디어별 블록 크기의 가장 가까운 배수로 자르거나 필요한 경우 미디어별 크기로 재정의할 수 있습니다. 블록 크기는 옥텟으로 측정된 양의 십진수여야 합니다. 서버는 값이 구문적으로 유효하지 않은 경우에만 오류\(4xx\)를 반환합니다.\(MAY, MUST\)

---
### **18.11.  Cache-Control**

Cache-Control 일반 헤더 필드는 요청/응답 체인을 따라 모든 캐싱 메커니즘을 따라야 하는 지시어를 지정하는 데 사용됩니다.\(MUST\)

캐시 지시어는 요청/응답 체인을 따라 모든 수신자에게 적용될 수 있으므로 해당 애플리케이션에 대한 중요성에 관계없이 프록시 또는 게이트웨이 애플리케이션을 통해 전달되어야 합니다. 특정 캐시에 대해 캐시 지시어를 지정할 수 없습니다.\(MUST\)

Cache-Control은 DESCRIBE, GET\_PARAMETER, SET\_PARAMETER, SETUP 요청과 응답에만 지정되어야 합니다. 참고: 캐시 제어는 RTSP 메시지에 대한 응답 캐싱만을 관리하는 것이 아니라 다음으로 식별되는 미디어 스트림에도 적용됩니다.

SETUP 요청입니다. RTSP 요청은 일반적으로 캐시할 수 없습니다. 자세한 내용은 섹션 16을 참조하십시오. 다음은 Cache-Control 헤더에 포함될 수 있는 캐시 지시어에 대한 설명입니다.

no-cache: 미디어 스트림이나 RTSP 응답이 어디에도 캐시되어서는 안 된다는 것을 나타냅니다. 이를 통해 원본 서버는 클라이언트 요청에 대해 오래된 응답을 반환하도록 구성된 캐시에 의한 캐싱도 방지할 수 있습니다. 참고: 콘텐츠 캐싱을 방지하는 보안 기능은 없습니다.\(MUST NOT\)

공개: 미디어 스트림 또는 RTSP 응답이 있음을 나타냅니다.

- 어떤 캐시로도 캐시 가능합니다.

private: 미디어 스트림 또는 RTSP 응답이 단일 사용자를 위한 것이며 공유 캐시에 의해 캐시되어서는 안 된다는 것을 나타냅니다. 개인\(비공유\) 캐시는 미디어 스트림을 캐시할 수 있습니다.\(MUST NOT\)

no-transform: 중간 캐시\(프록시\)는 특정 스트림의 미디어 유형을 변환하는 데 유용할 수 있습니다. 예를 들어, 프록시는 캐시 공간을 절약하거나 느린 링크의 트래픽 양을 줄이기 위해 비디오 형식을 변환할 수 있습니다. 그러나 이러한 변환이 특정 종류의 애플리케이션용 스트림에 적용된 경우 심각한 운영 문제가 발생할 수 있습니다. 예를 들어, 의료 영상, 과학 데이터 분석 및 종단 간 인증을 사용하는 응용 프로그램은 모두 원본 미디어 스트림 또는 RTSP 응답과 비트 단위로 동일한 스트림 수신에 의존합니다. 따라서 응답에 no-transform 지시문이 포함된 경우 중간 캐시나 프록시는 스트림이나 응답의 인코딩을 변경해서는 안 됩니다. HTTP와 달리 RTSP는 이 시점에서 부분적인 변환\(예: 다른 언어로의 번역 허용\)을 제공하지 않습니다.\(MUST NOT\)

캐시된 경우에만: 네트워크 연결이 매우 좋지 않은 경우와 같이 클라이언트는 캐시가 현재 저장한 미디어 스트림 또는 RTSP 응답만 반환하고 원본 서버로부터 이러한 응답을 수신하지 않기를 원할 수 있습니다. 이를 위해 클라이언트는 요청에 only-if-cached 지시문을 포함할 수 있습니다. 캐시가 이 지시어를 수신하면 캐시된 미디어 스트림을 사용하여 응답하거나 요청의 다른 제약 조건과 일치하는 응답을 사용하거나 504\(Gateway Timeout\) 상태로 응답해야 합니다. 그러나 캐시 그룹이 내부 연결이 양호한 통합 시스템으로 운영되는 경우 그러한 요청은 해당 캐시 그룹 내에서 전달될 수 있습니다.\(SHOULD, MAY\)

max-stale: 클라이언트가 만료 시간을 초과한 미디어 스트림 또는 RTSP 응답을 기꺼이 수락함을 나타냅니다. max-stale에 값이 할당되면 클라이언트는 만료 시간을 지정된 초 수만큼 초과하지 않은 응답을 기꺼이 수락합니다. max-stale에 값이 할당되지 않으면 클라이언트는 모든 연령의 오래된 응답을 기꺼이 받아들입니다.

min-fresh: 클라이언트가 신선도 수명이 현재 수명에 지정된 시간\(초\)을 더한 것 이상인 미디어 스트림 또는 RTSP 응답을 기꺼이 수락함을 나타냅니다. 즉, 클라이언트는 최소한 지정된 시간\(초\) 동안 여전히 신선한 응답을 원합니다.

must-revalidate: 캐시가 수신한 SETUP 응답에 must-revalidate 지시문이 있는 경우 해당 캐시는 원본 서버에서 먼저 재검증하지 않고 후속 요청에 응답하기 위해 캐시 항목이 오래 된 후에 캐시 항목을 사용해서는 안 됩니다. 즉, 원본 서버의 만료에만 근거하여 캐시된 응답이 오래된 경우 캐시는 매번 엔드투엔드 재검증을 수행해야 합니다.\(MUST NOT\)

Proxy-revalidate: Proxy-revalidate 지시어는 비공유 사용자 에이전트 캐시에 적용되지 않는다는 점을 제외하고 must-revalidate 지시어와 동일한 의미를 갖습니다. 인증된 요청에 대한 응답에서 사용자의 캐시가 응답을 저장하고 나중에 재검증할 필요 없이 응답을 반환하도록 허용하는 동시에\(해당 사용자가 이미 한 번 인증했기 때문에\) 많은 사용자에게 서비스를 제공하는 프록시를 요구하는 데 사용할 수 있습니다. 매번 재검증합니다\(각 사용자가 인증되었는지 확인하기 위해\). 이러한 인증된 응답에도 캐시를 허용하려면 "public" 캐시 지시문이 필요합니다.

max-age: 중간 캐시가 max-age=0 지시문을 통해 자체 캐시 항목을 재검증하도록 강제되고 클라이언트가 요청에 자체 유효성 검사기를 제공한 경우 제공된 유효성 검사기는 현재 유효성 검사기와 다를 수 있습니다. 캐시 항목과 함께 저장됩니다. 이 경우 캐시는 의미 투명성에 영향을 주지 않고 자체 요청을 할 때 두 유효성 검사기를 사용할 수 있습니다.\(MAY\)

- 단, 검증인의 선택에 따라 성능에 영향을 미칠 수 있습니다. 가장 좋은 접근 방식은 중간 캐시가 요청 시 자체 유효성 검사기를 사용하는 것입니다. 서버가 304\(수정되지 않음\)로 응답하면 캐시는 이제 검증된 복사본을 200\(OK\) 응답으로 클라이언트에 반환할 수 있습니다. 그러나 서버가 새로운 메시지 본문과 캐시 유효성 검사기로 응답하는 경우

- 중간 캐시는 강력한 비교 기능을 사용하여 반환된 유효성 검사기를 클라이언트의 요청에 제공된 유효성 검사기와 비교할 수 있습니다. 클라이언트의 유효성 검사기가 원본 서버의 유효성 검사기와 같으면 중간 캐시는 단순히 304\(수정되지 않음\)를 반환합니다. 그렇지 않으면 200\(OK\) 응답과 함께 새 메시지 본문을 반환합니다.

---
### **18.12.  Connection**

연결 일반 헤더 필드를 사용하면 발신자는 특정 연결에 대해 원하는 옵션을 지정할 수 있습니다. 추가 연결을 통해 프록시에 의해 전달되어서는 안 됩니다.\(MUST NOT\)

RTSP 2.0 프록시는 메시지가 전달되기 전에 연결 헤더 필드를 구문 분석해야 하며, 이 필드의 각 연결 토큰에 대해 연결 토큰과 동일한 이름을 가진 메시지에서 헤더 필드를 제거해야 합니다. 연결 옵션은 해당 추가 헤더 필드가 아닌 연결 헤더 필드에 연결 토큰이 있음으로 표시됩니다. 해당 연결 옵션과 관련된 매개변수가 없으면 추가 헤더 필드가 전송되지 않을 수 있기 때문입니다.\(MUST\)

연결 헤더에 나열된 메시지 헤더는 Cache-Control과 같은 종단 간 헤더를 포함해서는 안 됩니다.\(MUST NOT\)

RTSP 2.0은 보낸 사람이 응답 완료 후 연결이 닫힐 것이라는 신호를 보내는 "닫기" 연결 옵션을 정의합니다. 예를 들어 "연결: 요청 또는 응답 헤더 필드에서 닫기"는 현재 요청/응답이 완료된 후 연결이 "지속적"\(10.2절\)으로 간주되어서는 안 된다는 것을 나타냅니다.\(SHOULD NOT\)

RTSP 메시지에서 연결 옵션 "close"의 사용은 서버가 복구할 수 없어 연결을 닫아야 한다고 판단할 때의 오류 메시지로 제한되어야 합니다. 그 이유는 클라이언트가 유효한 메시지를 보내는 한 연결을 무기한으로 계속 사용할 수 있기 때문입니다.\(SHOULD\)

---
### **18.13.  Connection-Credentials**

Connection-Credentials 응답 헤더는 요청자의 승인이 필요한 다음 홉에 대한 자격 증명 체인을 전달하는 데 사용됩니다. 서버-클라이언트 응답에만 사용해야 합니다.\(MUST\)

RTSP 응답의 Connection-Credentials 헤더에는 중개자가 안전하게 연결해야 하는 다음 홉의 자격 증명 정보\(인증 체인을 제공하는 인증서 목록 형식\)가 포함되어 있어야 합니다. 헤더는 반드시\(MUST, MUST\)

다음 홉\(프록시 또는 서버\)의 URI와 DER로 인코딩된 X.509v3 인증서 시퀀스를 포함하는 Base64로 인코딩된\(\[RFC4648\]의 섹션 4에 따라 패딩 비트가 0으로 설정됨\) 이진 구조를 포함합니다. RFC5280\].

이진 구조는 16비트 부호 없는 정수로 포함된 인증서 수\(NR\_CERTS\)로 시작됩니다. 그 뒤에는 각 DER로 인코딩된 인증서의 크기\(옥텟\)를 제공하는 16비트 부호 없는 정수의 NR\_CERTS 번호가 옵니다. 그 뒤에는 DER로 인코딩된 X.509v3 인증서의 NR\_CERTS 번호가 시퀀스\(체인\)로 옵니다. 이 형식은 그림 6에 예시되어 있습니다. 프록시 또는 서버의 인증서가 구조에서 가장 먼저 와야 합니다. 다음 각 인증서는 이전 인증서를 직접 인증해야 합니다. 인증서 유효성 검사에서는 루트 키를 독립적으로 배포해야 하기 때문에 루트 인증 기관을 지정하는 자체 서명된 인증서는 선택적으로 체인에서 생략될 수 있습니다. 단, 어떤 경우든 이를 검증하기 위해 원격 측이 이미 인증서를 소유하고 있어야 한다는 가정하에 가능합니다.

```text
   Example:

   Connection-Credentials:"rtsps://proxy2.example.com/";MIIDNTCC...
```

여기서 MIIDNTCC...는 다음 구조의 Base64 인코딩입니다.

```text
        0                   1                   2                   3
        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |  Number of certificates       | Size of certificate #1        |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       | Size of certificate #2        | Size of certificate #3        |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       : DER Encoding of Certificate #1                                :
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       : DER Encoding of Certificate #2                                :
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       : DER Encoding of Certificate #3                                :
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

그림 6: 연결 자격 증명 헤더 인증서의 형식 예

---
### **18.14.  Content-Base**

Content-Base 메시지 본문 헤더 필드는 메시지 본문 내의 상대 URI를 확인하기 위한 기본 URI를 지정하는 데 사용될 수 있습니다.

```text
   Content-Base: rtsp://media.example.com/movie/twister/
```

Content-Base 필드가 없는 경우 메시지 본문의 기본 URI는 해당 Content-Location\(Content-Location URI가 절대 URI인 경우\) 또는 요청을 시작하는 데 사용된 URI에 따라 우선 순위에 따라 정의됩니다. . 그러나 메시지 본문 내 콘텐츠의 기본 URI는 해당 메시지 본문 내에서 재정의될 수 있습니다.

---
### **18.15.  Content-Encoding**

Content-Encoding 메시지 본문 헤더 필드는 미디어 유형의 수정자로 사용됩니다. 존재하는 경우 해당 값은 메시지 본문에 어떤 추가 콘텐츠 코딩이 적용되었는지, 따라서 Content-Type 헤더 필드에서 참조하는 미디어 유형을 얻기 위해 어떤 디코딩 메커니즘을 적용해야 하는지를 나타냅니다. Content-Encoding은 기본 미디어 유형의 ID를 잃지 않고 문서를 압축하는 데 주로 사용됩니다.

콘텐츠 코딩은 요청-URI로 식별되는 메시지 본문의 특성입니다. 일반적으로 메시지 본문은 이 인코딩으로 저장되며 렌더링 또는 유사한 사용 전에만 디코딩됩니다. 그러나 메시지에 "no-transform" 캐시 지시문이 존재하지 않는 한, RTSP 프록시는 수신자가 새로운 코딩을 수용할 수 있는 것으로 알려진 경우 콘텐츠 코딩을 수정할 수 있습니다.\(MAY\)

메시지 본문의 콘텐츠 코딩이 "ID"가 아닌 경우 메시지에는 사용된 비식별 콘텐츠 코딩을 나열하는 Content-Encoding 메시지 본문 헤더가 포함되어야 합니다.\(MUST\)

요청 메시지의 메시지 본문 내용 코딩이 원서버에서 허용되지 않는 경우 서버는 상태 코드 415\(지원되지 않는 미디어 유형\)로 응답해야 합니다.\(SHOULD\)

여러 인코딩이 메시지 본문에 적용된 경우 콘텐츠 코딩은 적용된 순서대로 처음부터 끝까지 왼쪽에서 오른쪽으로 나열되어야 합니다. 인코딩 매개변수에 대한 추가 정보는 이 사양에 정의되지 않은 다른 헤더 필드에서 제공될 수 있습니다.\(MUST, MAY\)

---
### **18.16.  Content-Language**

Content-Language 메시지 본문 헤더 필드는 포함된 메시지 본문에 대한 대상 독자의 자연어를 설명합니다. 이는 메시지 본문 내에서 사용되는 모든 언어와 동일하지 않을 수도 있습니다.

언어 태그는 섹션 18.4에 언급되어 있습니다. Content-Language의 주요 목적은 사용자가 자신이 선호하는 언어에 따라 엔터티를 식별하고 구별할 수 있도록 하는 것입니다. 따라서 본문 내용이 덴마크어를 읽을 수 있는 청중만을 대상으로 하는 경우 해당 필드는 다음과 같습니다.

```text
      Content-Language: da
```

Content-Language가 지정되지 않은 경우 기본값은 콘텐츠가 모든 언어 사용자를 대상으로 하는 것입니다. 이는 보낸 사람이 해당 내용을 자연어에 특정한 것으로 간주하지 않거나 어떤 언어에 대한 것인지 보낸 사람이 알지 못함을 의미할 수 있습니다.

여러 청중을 대상으로 하는 콘텐츠의 경우 여러 언어가 나열될 수 있습니다. 예를 들어, 원본 마오리어와 영어 버전으로 동시에 제시된 "와이탕이 조약"의 번역은 다음을 요구합니다.\(MAY\)

```text
      Content-Language: mi, en
```

그러나 메시지 본문 내에 여러 언어가 있다고 해서 그것이 여러 언어 사용자를 대상으로 한다는 의미는 아닙니다. 예를 들어 "라틴어 첫 수업"과 같은 초보자용 언어 입문서는 분명히 영어를 읽을 수 있는 청중이 사용하도록 의도된 것입니다. 이 경우 Content-Language에는 "en"만 포함됩니다.

Content-Language는 모든 미디어 유형에 적용될 수 있으며 텍스트 문서에만 국한되지 않습니다.\(MAY\)

---
### **18.17.  Content-Length**

Content-Length 메시지 본문 헤더 필드에는 비트 옥텟 단위로 RTSP 메시지의 메시지 본문 길이\(즉, 마지막 헤더 다음에 오는 이중 CRLF 뒤\)가 포함됩니다. HTTP와 달리 RTSP 메시지의 헤더 부분을 넘어 메시지 본문을 전달하는 모든 메시지에 포함되어야 합니다. 누락된 경우 기본값은 0으로 간주됩니다. 0보다 크거나 같은 모든 Content-Length는 유효한 값입니다.\(MUST\)

---
### **18.18.  Content-Location**

Content-Location 메시지 본문 헤더 필드는 요청된 리소스의 URI와 별도의 위치에서 해당 본문에 액세스할 수 있는 경우 메시지에 포함된 메시지 본문에 대한 리소스 위치를 제공하는 데 사용될 수 있습니다. 서버는 응답 메시지 본문에 해당하는 변형에 대한 Content-Location을 제공해야 합니다. 특히 리소스에 여러 변형이 있는 경우\(MAY, SHOULD\)

이와 연관되어 있고 해당 엔터티가 실제로 개별적으로 액세스할 수 있는 별도의 위치를 ​​갖고 있는 경우 서버는 반환되는 특정 변형에 대한 콘텐츠 위치를 제공해야 합니다.\(SHOULD\)

예를 들어, RTSP 클라이언트가 주어진 리소스\(예: "rtsp://a.example.com/movie/Plan9FromOuterSpace"\)에 대해 DESCRIBE 요청을 수행하는 경우 서버는 User-Agent 헤더와 같은 추가 정보를 사용할 수 있습니다. , 에이전트의 기능을 결정합니다. 그러면 서버는 해당 클래스의 RTSP 에이전트에 맞게 조정된 미디어 설명을 반환합니다. 에이전트가 수신하는 특정 설명을 나타내기 위해 리소스 식별자\("rtsp://a.example.com/movie/Plan9FromOuterSpace/FullHD.sdp"\)가 Content-Location에 제공됩니다. 설명은 여전히 ​​유효한 응답입니다. 일반 리소스 식별자로, 아래에 설명된 대로 디버깅과 캐시 작업을 모두 가능하게 합니다.

Content-Location 값은 원래 요청된 URI를 대체하지 않습니다. 이는 요청 당시 이 특정 변형에 해당하는 리소스의 위치에 대한 설명일 뿐입니다. 특정 변형의 소스를 식별하려는 경우 향후 요청은 Content-Location URI를 Request-URI로 지정할 수 있습니다. 이는 RTSP 에이전트가 조건부 요청을 통해 리소스 변형이 현재인지 확인하려는 경우 유용합니다.\(MAY\)

캐시는 검색에 사용된 URI와 다른 Content-Location을 가진 메시지 본문이 해당 Content-Location URI에 대한 이후 요청에 응답하는 데 사용될 수 있다고 가정할 수 없습니다. 그러나 Content-Location을 사용하면 단일 요청 리소스에서 검색된 여러 변형을 구별할 수 있습니다.

Content-Location이 상대 URI인 경우 상대 URI는 Request-URI를 기준으로 해석됩니다.

Content-Location은 경우에 따라 세션 설명 형식에 있는 상대 URI에 대한 기본 URI를 파생하는 데 사용될 수 있습니다. Content-Location을 사용할 때는 이 점을 고려해야 합니다. 해당 문제를 고려할 필요를 피하는 가장 쉬운 방법은 Content-Location이 포함될 때마다 Content-Base를 포함하는 것입니다.

또한 콘텐츠 위치와 함께 미디어 태그를 사용할 때 다른 콘텐츠 위치 URI에서 제공되더라도 버전마다 다른 MTag를 갖는 것이 중요합니다. 이는 동일한 요청 URI에 대한 응답으로 여전히 다양한 콘텐츠 변형이 제공되었기 때문입니다.

또한 대부분의 경우 DESCRIBE 및 SETUP 요청에 사용되는 URI는 다릅니다. DESCRIBE Content-Location 응답에 제공된 URI는 SETUP 요청에 직접 사용할 수 없습니다. 대신 미디어 리소스 URI를 파생하는 단계가 필요합니다. 여기에는 일반적으로 미디어 설명의 상대 URI\(예: SDP의 a=control 속성\)를 기본 URI와 결합하여 SETUP 요청에 필요한 절대 URI를 생성하는 작업이 포함됩니다.

---
### **18.19.  Content-Type**

Content-Type 메시지 본문 헤더는 수신자에게 전송된 메시지 본문의 미디어 유형을 나타냅니다. RTSP에 적합한 콘텐츠 유형은 실제로 표현 설명 및 매개변수 값 유형으로 제한될 가능성이 높습니다.

---
### **18.20.  CSeq**

CSeq 일반 헤더 필드는 RTSP 요청/응답 쌍의 시퀀스 번호\(정수\)를 지정합니다. 이 필드는 모든 요청과 응답에 있어야 합니다. RTSP 에이전트는 열려 있는 메시지 전송 채널이 있는 각 응답자에 대해 일련의 시퀀스 번호를 유지합니다. 에이전트가 특정 RTSP 메시지 전송에서 발생하는 각각의 새로운 RTSP 요청에 대해 CSeq 값은 1씩 증가해야 합니다. 초기 시퀀스 번호는 임의의 숫자일 수 있습니다. 그러나 0부터 시작하는 것이 좋습니다. 각 시퀀스 번호 시리즈는 각 요청자와 응답자 간에 고유합니다. 즉, 클라이언트는 서버에 대한 요청에 대해 하나의 시리즈를 갖고 서버는 클라이언트에 요청을 보낼 때 다른 시리즈를 갖습니다. 각 요청자와 응답자는 소켓 주소\(IP 주소 및 포트 번호\), 즉 TCP 연결 방향별로 식별됩니다. 재전송된 모든 요청에는 원본과 동일한 시퀀스 번호가 포함되어야 합니다. 즉, 동일한 요청의 재전송에 대해 시퀀스 번호가 증가되지 않습니다. 요청을 수신하는 RTSP 에이전트는 시퀀스 번호 순서대로 특정 전송에 도착하는 요청을 처리해야 합니다. 응답은 생성된 순서대로 전송됩니다. RTSP 응답은 해당 요청에 나타난 것과 동일한 시퀀스 번호를 가져야 합니다. 응답을 수신하는 RTSP 에이전트는 전송한 요청 순서와 비교하여 순서가 뒤바뀐 응답을 수신할 수 있습니다. 따라서 에이전트는 해당 요청과 쌍을 이루기 위해 응답의 시퀀스 번호를 사용해야 합니다.\(MUST, MUST, SHOULD, MUST, MUST, MUST, MAY, MUST\)

- 시퀀스 번호의 주요 목적은 요청에 대한 응답을 매핑하는 것입니다.

- 각각의 새로운 요청에 대해 1씩 증가하는 시퀀스 번호를 사용해야 하는 요구 사항은 순차적 전달을 제공하지 않거나 신뢰할 수 없는 프로토콜을 통한 RTSP 메시지 전송의 향후 사양을 지원하기 위한 것입니다.

- 초기 시퀀스 번호와 관련된 위의 규칙은 불필요하게 느슨해 보일 수 있습니다. 그 이유는 기존 구현의 몇 가지 일반적인 동작을 충족시키기 위한 것입니다. 여러 개의 안정적인 연결을 순차적으로 사용할 때 특정 서버와 연결하는 클라이언트에 대해 단일 시퀀스 번호 시리즈를 사용하는 것이 가장 쉬울 수 있습니다. 따라서 초기 시퀀스 번호는 이전 요청 수에 따라 임의적일 수 있습니다. 신뢰할 수 없는 전송의 경우 첫 번째 요청의 손실을 감지하려면 더 엄격한 정의나 기타 솔루션이 필요합니다.

- 여러 순차 전송 연결을 사용하는 경우 시퀀스 번호의 범위는 개별 전송 연결과 해당 5개의 튜플에 지정되므로 순서대로 처리를 보장하는 프로토콜 메커니즘이 없습니다. 따라서 동일한 RTSP 세션과 관련하여 처리되지 않은 요청 및 이전에 발송된 요청이 있는 전송 연결이 이미 존재하는 동일한 호스트에 대해 새 전송 연결을 여는 데 잠재적인 문제가 있습니다.

RTSP 프록시도 위의 규칙을 따라야 합니다. 이는 여러 클라이언트의 요청을 서버 또는 다음 홉 프록시를 향한 단일 전송으로 집계하는 프록시가 위의 규칙을 충족하면서 해당 전송에서 통합 시퀀스를 형성하기 위해 이러한 요청의 번호를 다시 지정해야 함을 의미합니다. 자체 요청을 내보내지 않고 일부 에이전트의 요청을 이행할 수 있는 프록시\(예: 캐시에서 요청을 이행하는 캐싱 프록시\)도 특정 대상에 대해 수신된 요청 수가 동일하지 않을 수 있으므로 번호를 다시 매길 필요가 있습니다. 해당 대상 에이전트를 향해 내보낸 요청 수입니다. 번호를 다시 매겨야 하는 프록시는 요청을 보낸 사람에게 다시 전달하기 전에 수신된 응답에 대해 원래 시퀀스 번호로 해당 번호 다시 매기기를 수행해야 합니다.

- 클라이언트가 프록시에 연결되어 해당 전송을 사용하여 여러 서버에 요청을 보내면 순서가 잘못된 응답을 받을 가능성이 매우 높은 상황이 발생합니다. 이는 프록시가 프록시에서 클라이언트 요청을 전달할 서버로 별도의 전송을 설정하기 때문입니다. 응답이 다른 서버에서 도착하면 클라이언트의 원래 시퀀스 번호 순서가 아니라 프록시에 도착하는 순서대로 클라이언트에 전달되어 처리될 수 있습니다. 이는 다른 서버의 느린 요청 처리로 인해 일부 세션의 요청이 차단되는 것을 방지하기 위한 것입니다.

---
### **18.21.  Date**

Date 일반 헤더 필드는 메시지가 시작된 날짜와 시간을 나타냅니다. RTSP 메시지에 Date 헤더를 포함하는 경우 다음 규칙을 따릅니다.

```text
   o  An RTSP message, sent by either the client or the server,
      containing a body MUST include a Date header, if the sending host
      has a clock;

   o  Clients and servers are RECOMMENDED to include a Date header in
      all other RTSP messages, if the sending host has a clock;
```

o 서버에 현재 시간의 합리적인 근사치를 제공할 수 있는 시계가 없는 경우 서버의 응답에는 날짜 헤더 필드가 포함되어서는 안 됩니다. 이 경우 다음 규칙을 따라야 합니다. 일부 원서버 구현에는 사용 가능한 시계가 없을 수 있습니다. 시계가 없는 원서버는 Expires 또는 Last-Modified 값을 응답에 할당해서는 안 됩니다\(MUST NOT\). 단, 이러한 값이 신뢰할 수 있는 시계를 가진 시스템이나 사용자에 의해 리소스와 연결되지 않은 한은 아닙니다. 서버 구성 시간이나 그 이전에 과거의 것으로 알려진 Expires 값을 할당할 수 있습니다\(이는 각 리소스에 대해 별도의 Expires 값을 저장하지 않고 응답의 "사전 만료"를 허용합니다\).\(MUST NOT, MUST, MUST NOT, MAY\)

Date 헤더 필드가 없는 수신 메시지는 해당 수신자가 메시지를 캐시할 경우 해당 수신자에 의해 해당 필드가 할당되어야 합니다. 클록이 없는 RTSP 구현은 사용할 때마다 응답을 재검증하지 않고 응답을 캐시해서는 안 됩니다\(MUST NOT\). RTSP 캐시, 특히 공유 캐시는 NTP\(Network Time Protocol\) \[RFC5905\]와 같은 메커니즘을 사용하여 시계를 신뢰할 수 있는 외부 표준과 동기화해야 합니다.\(MUST, MUST NOT, SHOULD\)

Date 헤더로 전송된 \[RFC5322\]의 섹션 3.3에 지정된 전체 날짜인 RTSP 날짜는 메시지 생성 이후의 날짜와 시간을 나타내서는 안 됩니다. 구현 시 합리적으로 정확한 날짜 및 시간을 생성할 수 있는 수단이 없는 경우를 제외하고는 메시지 생성 날짜 및 시간에 대해 사용 가능한 가장 가까운 근사치를 나타내야 합니다\(SHOULD\). 이론적으로 날짜는 메시지 본문이 생성되기 직전의 순간을 나타내야 합니다. 실제로 날짜는 메시지 생성 중 의미 값에 영향을 주지 않고 언제든지 생성될 수 있습니다.\(SHOULD NOT, SHOULD\)

- 참고: RTSP 2.0 날짜 형식은 RFC 5322에서 전체 날짜 형식으로 정의됩니다. 이 형식은 RTSP 1.0에서 사용되는 RFC 1123의 날짜 형식보다 더 유연합니다. 따라서 구현에서는 RFC 5322에서 권장하는 대로 단일 공백을 구분 기호로 사용하고 더 이상 사용되지 않는 형식 수신을 지원해야 합니다.

- 또한 구문을 사용하면 날짜 끝에 설명을 추가할 수 있습니다.

---
### **18.22.  Expires**

Expires 메시지 본문 헤더 필드는 설명이나 미디어 스트림이 오래된 것으로 간주되어야 하는 날짜와 시간을 제공합니다. 해석은 방법에 따라 다릅니다.

DESCRIBE 응답: Expires 헤더는 프레젠테이션 설명\(본문\)이 오래된 것으로 간주되어야 하는 날짜와 시간을 나타냅니다.\(SHOULD\)

SETUP 응답: Expires 헤더는 미디어 스트림이 오래된 것으로 간주되어야 하는 날짜와 시간을 나타냅니다.\(SHOULD\)

오래된 캐시 항목은 원본 서버\(또는 메시지 본문의 새로운 복사본이 있는 중간 캐시\)에서 먼저 유효성을 검사하지 않는 한 캐시\(프록시 캐시 또는 사용자 에이전트 캐시\)에서 반환되어서는 안 됩니다. 만료 모델에 대한 자세한 내용은 섹션 16을 참조하세요.

Expires 필드가 있다고 해서 원래 리소스가 해당 시점, 이전 또는 이후에 변경되거나 존재하지 않게 된다는 의미는 아닙니다.

형식은 RTSP-date에 정의된 절대 날짜 및 시간입니다. 그 사용 예는 다음과 같습니다.

```text
     Expires: Wed, 23 Jan 2013 15:36:52 +0000
```

RTSP 2.0 클라이언트와 캐시는 다른 유효하지 않은 날짜 형식, 특히 "0" 값을 포함하는 형식을 과거에 발생한\(즉, 이미 만료된\) 것으로 처리해야 합니다.\(MUST\)

응답을 "이미 만료됨"으로 표시하려면 원서버는 Date 헤더 값과 동일한 Expires 날짜를 사용해야 합니다. 응답을 "만료되지 않음"으로 표시하려면 원서버는 응답이 전송된 시점으로부터 약 1년 후의 만료 날짜를 사용해야 합니다. RTSP 2.0 서버는 앞으로 1년 이상 남은 만료 날짜를 보내서는 안 됩니다.\(SHOULD, SHOULD NOT\)

---
### **18.23.  From**

From 요청 헤더 필드가 제공되면 요청 사용자 에이전트를 제어하는 ​​인간 사용자의 인터넷 이메일 주소를 포함해야 합니다. 주소는 \[RFC1123\]의 "mailbox"에 정의된 대로 컴퓨터에서 사용할 수 있어야 합니다.\(SHOULD, SHOULD\)

이 헤더 필드는 로깅 목적으로 그리고 유효하지 않거나 원치 않는 요청의 소스를 식별하는 수단으로 사용될 수 있습니다. 안전하지 않은 형태의 액세스 보호로 사용해서는 안 됩니다. 이 필드의 해석은 수행된 방법에 대한 책임을 수락하는 지정된 사람을 대신하여 요청이 수행된다는 것입니다. 특히 로봇 에이전트는 수신 측에서 문제가 발생할 경우 로봇 실행 책임자에게 연락할 수 있도록 이 헤더를 포함해야 합니다.\(MAY, SHOULD NOT, SHOULD\)

이 필드의 인터넷 이메일 주소는 요청을 발행한 인터넷 호스트와 별개일 수 있습니다. 예를 들어, 요청이 프록시를 통해 전달되면 원래 발급자의 주소를 사용해야 합니다.\(MAY, SHOULD\)

클라이언트는 사용자의 승인 없이 From 헤더 필드를 전송해서는 안 됩니다. 이는 사용자의 개인 정보 보호 이익이나 해당 사이트의 보안 정책과 충돌할 수 있기 때문입니다. 사용자는 요청하기 전에 언제든지 이 필드의 값을 비활성화, 활성화 및 수정할 수 있는 것이 좋습니다.\(SHOULD NOT\)

---
### **18.24.  If-Match**

If-Match 요청 헤더 필드는 프리젠테이션 설명이 수신된 방식에 관계없이 프리젠테이션 설명의 무결성을 보장하는 데 특히 유용합니다. 프레젠테이션 설명은 RTSP 외부 수단\(HTTP 등\)이나 DESCRIBE 메시지를 통해 가져올 수 있습니다. RTSP를 통해 프레젠테이션 설명을 검색하는 경우 서버 구현은 DESCRIBE 메시지 시간과 SETUP 메시지 시간 사이에 설명의 무결성을 보장합니다. SETUP 요청의 If-Match 헤더 부분에 세션 설명에 제공된 MTag를 포함함으로써 클라이언트는 설정된 리소스가 설명과 일치하는지 확인합니다. MTag 유효성 검사가 실패한 If-Match 헤더가 있는 SETUP 요청은 412\(전제 조건 실패\)를 사용하여 응답을 생성해야 합니다.\(MUST\)

이 유효성 검사는 세션이 한 서버에서 다른 서버로 리디렉션된 경우에도 매우 유용합니다.

---
### **18.25.  If-Modified-Since**

If-Modified-Since 요청 헤더 필드는 DESCRIBE 및 SETUP 메소드와 함께 사용되어 조건부로 만듭니다. 이 필드에 지정된 시간 이후 요청된 변형이 수정되지 않은 경우 서버에서 설명이 반환되지 않거나\(DESCRIBE\) 스트림이 설정되지 않습니다\(SETUP\). 대신, 304\(수정되지 않음\) 응답은 메시지 본문 없이 반환되어야 합니다.\(MUST\)

필드의 예는 다음과 같습니다.

```text
     If-Modified-Since: Sat, 29 Oct 1994 19:43:31 GMT
```

---
### **18.26.  If-None-Match**

이 요청 헤더는 하나 이상의 메시지 본문 태그와 함께 사용되어 DESCRIBE 요청을 조건부로 만들 수 있습니다. 이전에 리소스에서 얻은 하나 이상의 메시지 본문이 있는 클라이언트는 If-None-Match 헤더 필드에 연결된 메시지 본문 태그 목록을 포함하여 해당 엔터티 중 최신 엔터티가 없음을 확인할 수 있습니다. 이 기능의 목적은 최소한의 트랜잭션 오버헤드로 캐시된 정보를 효율적으로 업데이트할 수 있도록 하는 것입니다. 특별한 경우로 "\*" 값은 리소스의 현재 엔터티와 일치합니다.

메시지 본문 태그 중 하나라도 해당 리소스에 대한 유사한 DESCRIBE 요청\(If-None-Match 헤더 없이\)에 대한 응답으로 반환되었을 메시지 본문의 메시지 본문 태그와 일치하는 경우 또는 "\*"가 제공된 경우 해당 리소스에 대한 현재 엔터티가 존재하는 경우 리소스의 수정 날짜가 요청의 If-Modified-Since 헤더 필드에 제공된 날짜와 일치하지 않기 때문에 그렇게 해야 하는 경우를 제외하고 서버는 요청된 메서드를 수행해서는 안 됩니다. 대신 요청 방법이 DESCRIBE인 경우 서버는 일치하는 메시지 본문 중 하나의 캐시 관련 헤더 필드\(특히 MTag\)를 포함하여 304\(수정되지 않음\) 응답으로 응답해야 합니다. 다른 모든 요청 방법의 경우 서버는 412\(전제 조건 실패\) 상태로 응답해야 합니다.\(MUST NOT, SHOULD, MUST\)

두 개의 메시지 본문 태그가 일치하는지 확인하는 방법에 대한 규칙은 섹션 16.1.3을 참조하세요.

일치하는 메시지 본문 태그가 없으면 서버는 If-None-Match 헤더 필드가 존재하지 않는 것처럼 요청된 방법을 수행할 수 있지만 요청의 If-Modified-Since 헤더 필드도 무시해야 합니다. 즉, 일치하는 메시지 본문 태그가 없으면 서버는 304\(수정되지 않음\) 응답을 반환해서는 안 됩니다.\(MUST, MUST NOT\)

요청이 If-None-Match 헤더 필드 없이 2xx 또는 304 상태 이외의 결과를 초래한다면 If-None-Match 헤더는 무시되어야 합니다. \(If-Modified-Since와 If-None-Match가 동일한 요청에 나타날 때 서버 동작에 대한 설명은 섹션 16.1.4를 참조하세요.\)\(MUST\)

If-None-Match 헤더 필드와 If-Match 헤더 필드가 모두 있는 요청의 결과는 지정되지 않으며 불법적인 요청으로 간주되어야 합니다.\(MUST\)

---
### **18.27.  Last-Modified**

Last-Modified 메시지 본문 헤더 필드는 원서버가 프레젠테이션 설명이나 미디어 스트림이 마지막으로 수정되었다고 믿는 날짜와 시간을 나타냅니다. DESCRIBE 메소드의 경우 헤더 필드는 미디어 스트림의 SETUP에 대한 설명의 마지막 수정 날짜 및 시간을 나타냅니다.

원서버는 서버의 메시지 발생 시간보다 이후의 최종 수정 날짜를 보내서는 안 됩니다. 리소스의 마지막 수정이 미래의 시간을 나타내는 경우 서버는 해당 날짜를 메시지 발생 날짜로 바꿔야 합니다.\(MUST NOT, MUST\)

원서버는 응답의 Date 값을 생성하는 시간에 최대한 가까운 메시지 본문의 Last-Modified 값을 얻어야 합니다\(SHOULD\). 이를 통해 수신자는 특히 응답이 생성되는 시간 근처에 메시지 본문이 변경되는 경우 메시지 본문의 수정 시간을 정확하게 평가할 수 있습니다.\(SHOULD\)

RTSP 서버는 가능할 때마다 Last-Modified를 전송해야 합니다.\(SHOULD\)

---
### **18.28.  Location**

위치 응답 헤더 필드는 요청 완료 또는 새 리소스 식별을 위해 요청 URI가 아닌 다른 위치로 수신자를 리디렉션하는 데 사용됩니다. 3rr 응답의 경우 위치는 리소스로의 자동 리디렉션을 위한 서버의 기본 URI를 나타내야 합니다. 필드 값은 단일 절대 URI로 구성됩니다.\(SHOULD\)

참고: Content-Location 헤더 필드\(18.18절\)는 Content-Location이 요청에 포함된 메시지 본문의 원래 위치를 식별한다는 점에서 Location과 다릅니다. 따라서 응답에 Location 및 Content-Location 모두에 대한 헤더 필드가 포함될 수 있습니다. 또한 일부 메서드의 캐시 요구 사항은 섹션 16.2를 참조하세요.

---
### **18.29.  Media-Properties**

이 일반 헤더는 SETUP 응답 또는 PLAY\_NOTIFY 요청에 사용되어 현재 RTSP 세션에 적용 가능한 미디어 속성을 나타냅니다. PLAY\_NOTIFY는 언제든지 이러한 속성을 수정하는 데 사용될 수 있습니다. 그러나 클라이언트는 새로운 미디어 속성과 관련된 작업이 적용되기 전에 업데이트를 수신해야 합니다. 집계된 세션의 경우 Media-Properties 헤더가 각 SETUP 응답에 반환됩니다. 최신 응답에서 수신된 헤더는 응답에 적용되는 헤더입니다.\(MAY, SHOULD\)

이 시점부터 향후 업데이트까지 전체 세션. 세션에 대한 현재 미디어 속성을 쿼리하기 위해 세션 헤더가 포함된 서버에 대한 GET\_PARAMETER 요청에 헤더가 값 없이 포함될 수 있습니다. 응답자는 현재 세션의 미디어 속성을 포함해야 합니다.\(MAY, MUST\)

이 헤더로 표현되는 미디어 속성은 RTSP 세션의 모든 미디어에 적용 가능한 속성입니다. 집계된 세션의 경우 헤더는 결합된 미디어 속성을 나타냅니다. 결과적으로 미디어 집합으로 인해 미디어 속성이 변경될 수 있으며 그에 따라 후속 SETUP 응답에 포함된 Media-Properties 헤더의 내용도 변경될 수 있습니다.\(MAY\)

헤더에는 요청의 RTSP URI에 표시된 대로 현재 설정된 미디어 또는 미디어 집합에 적용할 수 있는 속성 값 목록이 포함되어 있습니다. 헤더 내에서는 순서가 적용되지 않습니다. 속성 값은 특정 직교 속성을 처리하는 단일 그룹에 배치되어야 합니다. 여러 속성을 표현하는 값이나 그룹은 사용하면 안 됩니다. 표현될 수 있는 속성 목록은 언제든지 확장될 수 있습니다. 알 수 없는 속성 값은 무시되어야 합니다.\(SHOULD NOT, MAY, MUST\)

이 사양은 다음 네 가지 그룹과 해당 속성 값을 정의합니다.

```text
   Random Access:
```

- Random-Access: 랜덤 액세스가 가능함을 나타냅니다. 선택적으로 미디어의 임의 액세스 지점 두 개 사이의 가장 긴 기간을 나타내는 부동 소수점 값\(초\)을 포함할 수 있습니다.

- 시작만: 탐색이 시작으로만 제한됩니다.

- 탐색 없음: 탐색이 불가능합니다.

```text
   Content Modifications:
```

- 불변: RTSP 세션 수명 동안 콘텐츠가 변경되지 않습니다.

- 동적: 외부 방법이나 트리거에 따라 내용이 변경될 수 있습니다.

- 시간 진행: 벽시계 시간이 진행됨에 따라 액세스 가능한 미디어가 진행됩니다.

```text
   Retention:
```

- 무제한: RTSP 세션 기간 동안 콘텐츠가 유지됩니다.

- 시간 제한: 콘텐츠는 최소한 지정된 벽시계 시간까지 유지됩니다. 시간은 섹션 4.4.3에 지정된 절대 시간 형식으로 제공되어야 합니다.

- 기간: 각 개별 미디어 단위는 최소한 지정된 기간 동안 보존됩니다. 이 정의를 사용하면 시간 기반 슬라이딩 윈도우를 사용하여 데이터를 유지할 수 있습니다. 지속 시간은 초 단위의 부동 소수점 숫자로 표시됩니다. 값 0.0은 시간이 진행되는 세션에서 데이터가 유지되지 않음을 나타내므로 유효합니다.

```text
   Supported Scale:
```

- 척도: 콘텐츠가 임의 순서로 지원하는 하나 이상의 소수 값 또는 척도 값 범위를 따옴표로 묶어 쉼표로 구분한 목록입니다. 범위에는 콜론으로 구분된 시작 및 중지 값이 있습니다. 범위는 콘텐츠가 배율 값의 세부적인 선택을 지원함을 나타냅니다. 세밀한 조정을 통해 최소한 척도 값의 1/10만큼 작은 단계를 허용합니다. 서버가 주어진 스케일 값에 응답하여 요청된 값에서 스케일 단위의 10분의 1 미만, 즉 0.1 미만의 실제 스케일로 콘텐츠를 생성할 수 있는 경우 콘텐츠의 세분화된 선택을 지원하는 것으로 간주됩니다. 음수 값이 지원됩니다. 값 0은 의미가 없으며 사용해서는 안 됩니다.\(MUST NOT\)

주문형 콘텐츠 및 녹화가 없는 라이브 스트림에 대한 이 헤더의 예는 다음과 같습니다.

```text
   On-demand:
   Media-Properties: Random-Access=2.5, Unlimited, Immutable,
        Scales="-20, -10, -4, 0.5:1.5, 4, 8, 10, 15, 20"
```

녹화/타임시프트 없는 라이브 스트림: 미디어 속성: 탐색 없음, 시간 진행, 시간 지속 시간=0.0

---
### **18.30.  Media-Range**

Media-Range 일반 헤더는 RTSP 메시지 전송 시 미디어 범위를 제공하는 데 사용됩니다. 이 헤더는 SETUP 응답, 시간이 진행되는 미디어에 대한 PLAY 및 PAUSE 응답, 동적 미디어에 대한 변경 후 PLAY 및 PAUSE 응답 및 전송된 PLAY\_NOTIFY 요청에 포함되어야 합니다.\(MUST\)

미디어 속성 업데이트로 인해. 범위 사양이 없는 Media-Range 헤더는 현재 범위를 요청하기 위해 서버에 대한 GET\_PARAMETER 요청에 포함될 수 있습니다. 이 경우 서버는 응답을 보낼 때 현재 범위를 포함해야 합니다.\(MAY, MUST\)

헤더에는 미디어를 설정할 때 Accept-Ranges 헤더\(섹션 18.5\)에 표시된 대로 미디어에 지원되는 모든 시간 형식에 대한 범위 사양이 포함되어야 합니다. 서버는 비연속적인 범위를 갖는 미디어를 나타내기 위해 주어진 시간 형식에 대해 둘 이상의 범위 사양을 포함할 수 있습니다. 범위 사양은 값이 가장 낮거나 시작 시간이 가장 빠른 범위부터 순서를 지정해야 하며, 값이 점점 높아지거나 시작 시간이 늦어지는 범위가 그 뒤를 따릅니다.\(MUST, MAY, MUST\)

시간 진행 속성이 있는 미디어의 경우 Media-Range 헤더 값은 발행된 특정 시점에만 유효합니다. 벽시계가 발전함에 따라 미디어 범위도 발전할 것입니다. 그러나 미디어 시간은 벽시계 시간\(클럭 왜곡 제외\)과 직접적인 관계로 진행되므로 합리적으로 정확한 미디어 범위 추정이 계산될 수 있다고 가정해야 합니다.

---
### **18.31.  MTag**

MTag 응답 헤더는 DESCRIBE, GET\_PARAMETER 또는 SETUP 응답에 포함될 수 있습니다. DESCRIBE 응답으로 반환된 메시지 본문 태그\(섹션 4.6\)와 SETUP의 태그는 프레젠테이션, 즉 반환된 세션 설명과 미디어 스트림을 모두 참조합니다. 이를 통해 SETUP 요청 시 미디어 리소스에 대한 올바른 세션 설명이 있는지 확인할 수 있습니다. 다만, 어느 한 부분을 변경하면 모든 부분이 무효가 된다는 단점이 있습니다.\(MAY\)

MTag가 메시지 본문 내부\(예: SDP의 "a=mtag" 속성 내\)와 응답 메시지 모두에 제공되는 경우 두 태그는 모두 동일해야 합니다. 캐시가 콘텐츠 검사 없이 MTag를 사용할 수 있도록 MTag를 주로 RTSP 응답 메시지에 제공하는 것이 좋습니다. 그러나 HTTP 등을 사용하여 RTSP 외부에 배포되는 세션 설명의 경우 부록 D.1.9에 지정된 대로 세션 설명에 메시지 본문 태그를 포함해야 합니다.\(MUST, SHOULD\)

SETUP 및 DESCRIBE 요청은 If-Match\(섹션 18.24\) 및 If-None-Match\(섹션 18.26\) 헤더를 사용하여 MTag에 따라 조건부로 생성될 수 있습니다.

---
### **18.32.  Notify-Reason**

Notify-Reason 응답 헤더는 PLAY\_NOTIFY 메소드에서만 사용됩니다. 서버가 비동기 PLAY\_NOTIFY 요청을 보낸 이유를 나타냅니다\(섹션 13.5 참조\).

---
### **18.33.  Pipelined-Requests**

Pipelined-Requests 일반 헤더는 이전 요청에 의해 생성된 컨텍스트에서 요청이 실행되어야 함을 나타내는 데 사용됩니다. 이 헤더의 주요 용도는 첫 번째 요청 이후의 추가 SETUP 요청이 세션 ID가 요청 에이전트로 다시 전송될 때까지 기다릴 필요가 없도록 SETUP 요청의 파이프라인을 허용하는 것입니다. 헤더에는 요청을 보내는 데 사용되는 영구 연결에 의해 범위가 지정되는 고유 식별자가 포함되어 있습니다.

Pipelined-Requests가 포함된 요청을 수신하면 응답 에이전트는 현재 영구 연결에 대한 Pipelined-Requests 식별자와 RTSP 세션 ID 사이에 바인딩이 존재하는지 찾아야 합니다. 바인딩이 존재하는 경우 수신된 요청은 발견된 세션 ID가 있는 세션 헤더를 포함하는 것과 동일한 방식으로 처리됩니다. 매핑이 없고 요청에 세션 헤더가 포함되어 있지 않은 경우 응답 에이전트는 세션 생성 요청\(즉, SETUP\)이 성공적으로 완료되면 바인딩을 생성해야 합니다. 요청이 RTSP 세션 생성에 실패한 경우 바인딩을 생성해서는 안 됩니다. 요청에 Session 헤더와 Pipelined-Requests 헤더가 모두 포함된 경우 Pipelined-Requests 헤더를 무시해야 합니다.\(MUST, MUST, MUST NOT, MUST\)

참고: 위의 정의에 따르면, 새로운 고유 Pipelined-Requests 헤더를 포함하는 최소한 첫 번째 요청은 SETUP 요청이어야 합니다\(프로토콜이 세션을 생성하는 새로운 방법으로 확장되지 않는 한\). 첫 번째 이후 추가 SETUP 요청이나 RTSP 세션 컨텍스트를 사용하는 모든 유형의 요청에는 Pipelined-Requests 헤더가 포함될 수 있습니다.

Pipelined-Requests 헤더가 포함된 요청에 응답할 때 서버는 세션 컨텍스트에 대한 바인딩이 존재할 때 Session 헤더도 포함해야 합니다. 세션 식별자를 알고 있는 RTSP 에이전트는 어떤 요청에서도 Pipelined-Requests 헤더를 사용해서는 안 되며 세션 헤더만 사용해야 합니다. 이는 세션 식별자로서 파이프라인 요청 식별자가 아닌 TCP 연결과 같은 전송 컨텍스트 전반에 걸쳐 지속됩니다.\(MUST, SHOULD NOT\)

Pipelined-Requests 헤더와 함께 요청을 보내는 RTSP 에이전트는 전송 컨텍스트 내에서 이전에 사용되지 않은 고유 식별자를 사용할 책임이 있습니다. 현재는 TCP 연결만 이러한 전송 컨텍스트로 정의됩니다. 서버는 반드시\(MUST\)

해당 세션이 종료되면 Pipelined-Requests 식별자와 세션에 대한 바인딩을 삭제합니다. 이전 명령에도 불구하고 RTSP 에이전트는 더 나은 오류 처리 및 로깅을 위해 식별자를 재사용하지 않는 것이 좋습니다.\(SHOULD\)

RTSP 프록시는 지속적인 연결에 대한 요청 집계를 허용하기 위해 들어오는 요청의 파이프라인 요청 식별자 값을 나가는 요청으로 변환해야 할 수도 있습니다.

---
### **18.34.  Proxy-Authenticate**

프록시 인증 응답 헤더 필드는 407\(프록시 인증 필요\) 응답의 일부로 포함되어야 합니다. field-value는 이 Request-URI의 프록시에 적용할 수 있는 인증 체계와 매개변수를 나타내는 챌린지로 구성됩니다. 헤더의 정의는 \[RFC7235\]에 있으며 적용 가능한 모든 HTTP 인증 체계는 Digest \[RFC7616\] 및 Basic \[RFC7617\]과 같은 다른 RFC에 나타납니다.\(MUST\)

HTTP 액세스 인증 프로세스는 \[RFC7235\]에 설명되어 있습니다. 이 헤더는 클라이언트-서버 요청과 관련된 응답 메시지에만 사용해야 합니다.\(MUST\)

---
### **18.35.  Proxy-Authentication-Info**

Proxy-Authentication-Info 응답 헤더는 프록시가 다이제스트 체계 \[RFC7616\]와 같은 일부 인증 체계의 메시지 응답에서 성공적인 인증에 관한 일부 정보를 프록시에 전달하는 데 사용됩니다. 헤더의 정의는 \[RFC7615\]에 있으며 적용 가능한 HTTP 인증 체계는 다른 RFC에 나와 있습니다. 이 헤더는 클라이언트-서버 요청과 관련된 응답 메시지에만 사용해야 합니다. 이 헤더에는 홉별 범위가 있습니다.\(MUST\)

---
### **18.36.  Proxy-Authorization**

Proxy-Authorization 요청 헤더 필드를 사용하면 클라이언트는 인증이 필요한 프록시에 대해 자신\(또는 해당 사용자\)을 식별할 수 있습니다. Proxy-Authorization 필드 값은 요청되는 자원의 프록시 또는 영역에 대한 사용자 에이전트의 인증 정보를 포함하는 자격 증명으로 구성됩니다. 헤더의 정의는 \[RFC7235\]에 있으며 적용 가능한 모든 HTTP 인증 체계는 Digest \[RFC7616\] 및 Basic \[RFC7617\]과 같은 다른 RFC에 나타납니다.

HTTP 액세스 인증 프로세스는 \[RFC7235\]에 설명되어 있습니다. Authorization과 달리 Proxy-Authorization 헤더 필드는 다음 홉 프록시에만 적용됩니다. 이 헤더는 클라이언트-서버 요청에만 사용해야 합니다.\(MUST\)

---
### **18.37.  Proxy-Require**

Proxy-Require 요청 헤더 필드는 프록시가 반드시 지원해야 하는 프록시 관련 기능을 나타내는 데 사용됩니다. 프록시가 지원하지 않는 모든 Proxy-Require 헤더 기능은 Unsupported 헤더를 사용하여 클라이언트에 대해 프록시에 의해 부정적으로 승인되어야 합니다. 프록시는 응답에 551\(옵션이 지원되지 않음\) 상태 코드를 사용해야 합니다. Proxy-Require에 포함된 모든 기능 태그는 엔드포인트\(서버 또는 클라이언트\)에 적용되지 않습니다. 프록시와 서버 모두에서 기능을 지원하려면 태그가 Require 헤더에도 포함되어야 합니다.\(MUST, MUST, MUST\)

이 메시지의 메커니즘과 사용 예에 ​​대한 자세한 내용은 섹션 18.43을 참조하세요. 기능에 프록시 지원이 필요한 경우를 고려해야 하는 경우 프록시 섹션\(섹션 15.1\)의 논의를 참조하세요.

사용 예:

```text
      Proxy-Require: play.basic
```

---
### **18.38.  Proxy-Supported**

프록시 지원 일반 헤더 필드는 기능 태그를 사용하여 프록시에서 지원하는 모든 확장을 열거합니다. 헤더는 전달 프록시가 지원하는 확장의 교차점을 전달합니다. Proxy-Supported 헤더는 프록시의 모든 요청에 ​​포함될 수 있습니다. Supported 헤더가 요청에 있는 경우 프록시에 의해 추가되어야 합니다. 요청에 있는 경우 수신자는 응답에서 수신된 Proxy-Supported 헤더를 복사해야 합니다.\(MAY, MUST, MUST\)

Proxy-Supported 헤더 필드에는 섹션 4.5에 설명된 대로 프록시에 적용할 수 있는 기능 태그 목록이 포함되어 있습니다. 목록은 프록시가 이해하는 모든 기능 태그의 교차점입니다. 교차를 달성하기 위해 Proxy-Supported 헤더를 추가하는 프록시에는 자신이 이해하는 모든 프록시 기능 태그가 포함됩니다. 헤더가 포함된 요청을 수신하는 모든 프록시는 목록을 확인하고 지원하지 않는 기능 태그를 제거해야 합니다. 응답에 있는 Proxy-Supported 헤더는 프록시에 의해 수정되어서는 안 됩니다. 이러한 기능 태그는 프록시 체인이 일반적으로 지원하는 태그이며 요청 리소스에만 국한되지 않습니다.\(MUST, MUST NOT\)

```text
   Example:

     C->P1: OPTIONS rtsp://example.com/ RTSP/2.0
            Supported: foo, bar, blech
            User-Agent: PhonyClient/1.2

    P1->P2: OPTIONS rtsp://example.com/ RTSP/2.0
            Supported: foo, bar, blech
            Proxy-Supported: proxy-foo, proxy-bar, proxy-blech
            Via: 2.0 pro.example.com

    P2->S:  OPTIONS rtsp://example.com/ RTSP/2.0
            Supported: foo, bar, blech
            Proxy-Supported: proxy-foo, proxy-blech
            Via: 2.0 pro.example.com, 2.0 prox2.example.com

     S->C:  RTSP/2.0 200 OK
            Supported: foo, bar, baz
            Proxy-Supported: proxy-foo, proxy-blech
            Public: OPTIONS, SETUP, PLAY, PAUSE, TEARDOWN
            Via: 2.0 pro.example.com, 2.0 prox2.example.com
```

---
### **18.39.  Public**

공용 응답 헤더 필드에는 응답 보낸 사람이 지원하는 메서드 집합이 나열됩니다. 이 헤더는 보낸 사람의 일반적인 기능에 적용되며 유일한 목적은 보낸 사람의 기능을 받는 사람에게 나타내는 것입니다. 나열된 방법은 요청-URI에 적용되거나 적용되지 않을 수 있습니다. Allow 헤더 필드\(섹션 18.6\)는 특정 URI에 허용되는 메서드를 나타내는 데 사용될 수 있습니다.\(MAY\)

사용 예:

```text
      Public: OPTIONS, SETUP, PLAY, PAUSE, TEARDOWN
```

응답의 송신자와 수신자 사이에 프록시가 있는 경우, 개입하는 각 프록시는 공개 헤더 필드를 수정하여 해당 프록시를 통해 지원되지 않는 모든 메소드를 제거해야 합니다. 결과 Public 헤더 필드에는 보낸 사람의 메서드와 중간 프록시가 통과할 수 있는 메서드의 교차 부분이 포함됩니다.\(MUST\)

- 일반적으로 프록시는 모든 방법이 송신 RTSP 에이전트에서 수신 RTSP 에이전트로 투명하게 전달되도록 허용해야 하지만 특정 프록시에서는 이것이 바람직하지 않은 경우가 있을 수 있습니다. 공개 응답 헤더 필드 수정

- 개입 프록시는 요청 보낸 사람이 프록시 체인을 통해 대상 에이전트에서 사용할 수 있는 방법을 나타내는 정확한 응답을 받도록 보장합니다.

---
### **18.40.  Range**

Range 일반 헤더는 PLAY\(섹션 13.4\), PAUSE\(섹션 13.6\), SETUP\(섹션 13.3\) 및 PLAY\_NOTIFY\(섹션 13.5\) 요청 및 응답의 시간 범위를 지정합니다. 세션이 포함된 형식의 재생 상태인지 준비 상태인지에 관계없이 현재 미디어 위치를 요청하는 값이 없고 범위 형식만 사용하여 클라이언트에서 서버로 보내는 GET\_PARAMETER 요청에 포함될 수 있습니다. 범위 형식을 지원하는 경우 서버는 현재 재생 지점 또는 일시 중지 지점을 범위의 시작으로 응답해야 합니다. 이전 PLAY 요청에서 명시적인 중지 지점이 사용된 경우 해당 값이 중지 지점으로 포함됩니다. 서버가 현재 1이 아닌 스케일 값과 같이 Range 헤더의 해석에 영향을 미치는 모든 유형의 미디어 재생 조작을 받고 있는 경우 완전한 정보를 제공하기 위해 Scale 헤더를 포함하여 해당 사실도 GET\_PARAMETER 응답에 포함되어야 합니다. .\(MAY, MUST\)

범위는 여러 단위로 지정할 수 있습니다. 이 사양은 smpte\(섹션 4.4.1\), npt\(섹션 4.4.2\) 및 clock\(섹션 4.4.3\) 범위 단위를 정의합니다. 옥텟 범위\(바이트 범위\)\(\[RFC7233\]의 섹션 2.1 참조\) 및 기타 확장 단위를 사용할 수 있지만 해당 동작은 일반적으로 RTSP에서 의미가 없으므로 지정되지 않습니다. Range 헤더를 지원하는 서버는 NPT 범위 형식을 이해해야 하며 SMPTE 범위 형식을 이해해야 합니다. Range 헤더가 이해되지 않는 시간 형식으로 전송되는 경우 수신자는 456\(리소스에 대해 유효하지 않은 헤더 필드\)을 반환해야 하며 주어진 리소스에 대해 지원되는 시간 형식을 나타내는 Accept-Ranges 헤더를 포함해야 합니다.\(MAY, MUST, SHOULD\)

```text
   Example:

     Range: clock=19960213T143205Z-
```

Range 헤더에는 단일 범위 형식의 범위가 포함되어 있습니다. 범위는 시작점을 포함하지만 끝점을 제외하고 시작점과 끝점이 있는 반쯤 열린 간격입니다. 범위는 시작점과 끝점에 대한 명시적인 값으로 완전히 지정되거나 시작점이나 끝점이 암시적으로 지정될 수 있습니다. 암시적 시작 지점은 세션의 일시 중지 지점을 나타내며, 일시 중지 지점이 설정되지 않은 경우 콘텐츠의 시작을 나타냅니다. 암시적 끝점은 콘텐츠의 끝을 나타냅니다. 암시적 시작의 사용법

동일한 Range 헤더에는 끝점이 허용되지 않습니다. 그러나 Range 헤더를 생략하면 일시 중지 지점\(또는 시작\)부터 콘텐츠가 끝날 때까지라는 의미를 갖습니다.

- 언급한 대로 범위 헤더는 반 개방 간격을 정의합니다. A-B의 범위는 정확히 A 시간에 시작하지만 B 직전에 끝납니다. 비디오 또는 오디오 프레임과 같은 미디어 단위의 시작 시간만 관련됩니다. 예를 들어 비디오 프레임이 40ms마다 생성된다고 가정합니다. 10.0-10.1 범위에는 10.0 이상에서 시작하는 비디오 프레임이 포함되며, 간격을 넘어 지속되더라도 10.08에서 시작하는 비디오 프레임이 포함됩니다. 반면에 10.0-10.08 범위는 10.08의 프레임을 제외합니다.

- NPT 시간 척도의 "현재"와 암시적 시작 값 간의 차이에 유의하십시오. 암시적 값은 현재 일시 중지 지점을 참조하는 반면 "지금"은 현재 시간을 나타냅니다. 녹음\(일부 또는 전체 시간 동안 유지\)이 포함된 시간 진행 세션에서 일시 중지 지점은 세션 시작 2분일 수 있지만 현재는 세션 시작 1시간일 수 있습니다.

기본적으로 범위 간격은 증가하며 두 번째 포인트가 첫 번째 포인트보다 큽니다.

```text
   Example:

       Range: npt=10-15
```

그러나 Scale 헤더\(섹션 18.46 참조\)가 음수 스케일 값을 나타내는 경우 범위 간격도 줄어들 수 있습니다. 예를 들어, 역방향 재생이 필요한 경우입니다.

```text
   Example:

       Scale: -1
       Range: npt=15-10
```

감소하는 범위는 위에서 설명한 대로 여전히 반 개방 구간입니다. 따라서 범위 A-B의 경우 A는 닫혀 있고 B는 열려 있습니다. 위의 예에서 15는 닫혀 있고 10은 열려 있습니다. 이 규칙의 예외는 B=0이 감소하는 범위에 있는 경우입니다. 이 경우 범위는 양쪽 끝에서 닫혀 있습니다. 그렇지 않으면 NPT 및 SMPTE와 같은 개념이 있는 형식의 역방향 재생에서 0에 도달할 방법이 없습니다.

```text
   Example:

       Scale: -1
       Range: npt=15-0
```

이 범위에서는 15와 0이 모두 닫혀 있습니다.

Scale 헤더에 해당 음수 값이 없는 감소 범위 간격은 유효하지 않습니다.

---
### **18.41.  Referrer**

Referrer 요청 헤더 필드를 사용하면 클라이언트는 서버의 이익을 위해 요청 URI를 얻은 리소스의 주소\(URI\)를 지정할 수 있습니다. URI는 일반적으로 HTTP를 통해 검색되는 프레젠테이션 설명의 URI를 나타냅니다. Referrer 요청 헤더를 사용하면 서버가 관심, 로깅, 최적화된 캐싱 등을 위해 리소스에 대한 백링크 목록을 생성할 수 있습니다. 또한 유지 관리를 위해 오래되었거나 잘못 입력된 링크를 추적할 수 있습니다. 사용자 키보드의 입력과 같이 자체 URI가 없는 소스에서 Request-URI를 얻은 경우 Referrer 필드를 전송해서는 안 됩니다.\(MUST NOT\)

field-value가 상대 URI인 경우 Request-URI를 기준으로 해석되어야 합니다. URI에는 조각 식별자가 포함되어서는 안 됩니다.\(SHOULD, MUST NOT\)

링크의 소스는 개인 정보이거나 개인 정보 소스를 공개할 수 있으므로 추천자 필드 전송 여부를 사용자가 선택할 수 있도록 하는 것이 좋습니다. 예를 들어 스트리밍 클라이언트에는 공개/익명 토글 스위치가 있을 수 있으며, 이를 통해 추천자 및 보낸 사람 정보 전송을 각각 활성화/비활성화할 수 있습니다.

참조 페이지가 보안 프로토콜로 전송된 경우 클라이언트는 \(비보안\) RTSP 요청에 리퍼러 헤더 필드를 포함해서는 안 됩니다.\(SHOULD NOT\)

---
### **18.42.  Request-Status**

이 요청 헤더는 PLAY\(섹션 13.4\)와 같이 완료하는 데 시간이 걸리는 요청의 최종 결과를 나타내는 데 사용됩니다. PLAY 요청이 성공 또는 실패했는지 보고하기 위해 스트림 종료 이유와 함께 PLAY\_NOTIFY\(섹션 13.5\)로 전송됩니다. 헤더는 보고된 요청에 사용된 CSeq 번호와 세션 ID를 사용하여 보고한 요청에 대한 참조를 전달합니다. CSeq 번호가 전송 연결에 의해 범위가 지정된다는 사실로 인해 이는 명확성이 보장되지 않습니다. 요청을 보내는 에이전트

사용되는 모든 순차 전송에서 단조롭게 증가하는 카운터를 사용하여 문제를 줄일 수 있습니다. 헤더는 숫자 상태 코드\(섹션 8.1.1에 따름\)와 사람이 읽을 수 있는 이유 문구를 모두 제공합니다.

```text
   Example:
   Request-Status: cseq=63 status=500 reason="Media data unavailable"
```

CSeq 헤더의 번호를 다시 매기는 프록시는 요청을 다음 홉 에이전트에 전달할 때 이 헤더에 있는 cseq 매개변수의 해당 재매핑을 수행해야 합니다.

---
### **18.43.  Require**

요청 헤더 필요 필드는 에이전트가 다른 엔드포인트가 이 요청과 관련하여 필요한 기능을 지원하는지 확인하는 데 사용됩니다. 또한 다른 엔드포인트가 특정 기능을 지원하는지 쿼리하는 데에도 사용할 수 있습니다. 그러나 이 목적에서는 Supported 일반 헤더\(섹션 18.51\)를 사용하는 것이 훨씬 더 효과적입니다. Require 헤더에 나열된 기능 태그 중 요청을 수신하는 서버나 클라이언트가 지원하지 않는 경우 오류 코드 551\(옵션이 지원되지 않음\)을 사용하여 요청에 응답해야 하며 해당 기능 태그를 나열하는 Unsupported 헤더를 포함해야 합니다. 지원되지 않습니다. 이 헤더는 프록시에는 적용되지 않습니다. 프록시와 관련된 동일한 기능에 대해서는 미디어 수정 프록시를 제외하고 Proxy-Require 헤더\(섹션 18.37\)를 참조하세요. 미디어 수정 프록시는 서버와 매우 유사한 방식으로 미디어를 처리하는 특성으로 인해 클라이언트에 올바르게 서비스를 제공하기 위해 서버의 기능도 이해해야 합니다.\(MUST\)

- 이는 양측이 모든 기능을 이해하면 클라이언트-서버 상호 작용이 지체 없이 진행되고, 기능이 이해되지 않는 경우에만 속도가 느려지도록 하기 위한 것입니다\(아래 예 참조\). 잘 일치하는 클라이언트-서버 쌍의 경우 상호 작용이 빠르게 진행되어 협상 메커니즘에 필요한 왕복 시간이 절약됩니다. 또한 클라이언트가 서버가 이해하지 못하는 기능을 요구할 때 상태 모호성을 제거합니다.

```text
   Example (Not complete):

   C->S:   SETUP rtsp://server.com/foo/bar/baz.rm RTSP/2.0
           CSeq: 302
           Require: funky-feature
           Funky-Parameter: funkystuff

   S->C:   RTSP/2.0 551 Option not supported
           CSeq: 302
           Unsupported: funky-feature
```

이 예에서 "funky-feature"는 가상의 Funky-Parameter 필드가 필요함을 클라이언트에 나타내는 기능 태그입니다. "funky-feature"와 Funky-Parameter 사이의 관계는 RTSP 교환을 통해 전달되지 않습니다. 왜냐하면 해당 관계는 "funky-feature"의 불변 속성이므로 모든 교환을 통해 전송되어서는 안 되기 때문입니다.

프록시 및 기타 중개 장치는 이 헤더를 무시해야 합니다. 특정 확장이 중간 장치의 지원을 요구하는 경우, 확장은 대신 Proxy-Require 필드에 태그를 지정해야 합니다\(섹션 18.37 참조\). 기능에 프록시 지원이 필요한 경우를 고려해야 하는 경우 프록시 섹션\(섹션 15.1\)의 논의를 참조하세요.\(MUST\)

---
### **18.44.  Retry-After**

Retry-After 응답 헤더 필드는 503\(서비스를 사용할 수 없음\) 또는 553\(프록시를 사용할 수 없음\) 응답과 함께 사용하여 요청 클라이언트가 서비스를 사용할 수 없는 기간을 나타낼 수 있습니다. 이 필드는 리디렉션된 요청을 발행하기 전에 사용자 에이전트가 기다려야 하는 최소 시간을 나타내기 위해 3rr\(리디렉션\) 응답과 함께 사용될 수도 있습니다. 제한이 일시적인 경우 413\(요청 메시지 본문이 너무 큼\)을 사용하는 응답에는 Retry-After 헤더도 포함될 수 있습니다. 이 필드의 값은 RTSP 날짜이거나 응답 시간 이후의 정수\(십진수\)일 수 있습니다.\(MAY, MAY\)

```text
   Example:

   Retry-After: Fri, 31 Dec 1999 23:59:59 GMT
   Retry-After: 120
```

후자의 예에서는 지연 시간이 2분입니다.

---
### **18.45.  RTP-Info**

RTP-Info 일반 헤더 필드는 PLAY 및 GET\_PARAMETER 응답 또는 PLAY\_NOTIFY 및 GET\_PARAMETER 요청에서 RTP 관련 매개변수를 설정하는 데 사용됩니다. RTP를 전송 프로토콜로 사용하는 스트림의 경우 RTP-Info 헤더는 PLAY에 대한 200 응답의 일부여야 합니다.\(SHOULD\)

RTP-에 대한 PLAY 응답에서 RTP-Info 제외

- 전송된 미디어로 인해 클라이언트는 RTCP를 사용하여 미디어 스트림을 동기화해야 합니다. RTCP가 손실될 수 있고 특히 적시에 도착할 필요가 없으므로 이는 부정적인 영향을 미칠 수 있습니다. 또한 검색이 발생한 패킷을 클라이언트에 알리는 기능도 영향을 받습니다.

RTP-Info는 전송 매개변수를 변경할 때 동기화 정보를 제공하기 위해 SETUP 응답에 포함될 수 있습니다\(섹션 13.3 참조\). RTP-Info 헤더와 Range 헤더는 현재 재생 지점과 해당 RTP 동기화 정보를 요청하는 값 없이 클라이언트에서 서버로의 GET\_PARAMETER 요청에 포함될 수 있습니다. RTP-Info 헤더가 요청에 포함되면 Range 헤더도 포함되어야 합니다. 서버 응답에는 Range 헤더와 RTP-Info 헤더가 모두 포함되어야 합니다. 세션이 Play 상태에 있는 경우 Range 헤더의 값은 현재 재생 지점과 해당 RTP-Info 값으로 채워져야 합니다. 서버가 다른 상태에 있으면 RTP-Info 헤더에 값이 포함되지 않습니다. 헤더는 스트림 끝의 Notify-Reason과 함께 PLAY\_NOTIFY 요청에 포함되어 스트림 끝에 대한 RTP 정보를 제공합니다.\(MAY, MAY, MUST, MUST, MUST\)

헤더에는 다음 매개변수가 포함될 수 있습니다.

url: 다음 RTP 매개변수가 해당하는 스트림 URI를 나타냅니다. 이 URI는 이 미디어 스트림에 대한 SETUP 요청에 사용된 것과 동일해야 합니다. 모든 상대 URI는 요청-URI를 기본 URI로 사용해야 합니다. 이 매개변수는 반드시 존재해야 합니다.\(MUST, MUST, MUST\)

ssrc: 제공된 RTP 타임스탬프와 시퀀스 번호가 적용되는 SSRC입니다. 이 매개변수는 반드시 존재해야 합니다.\(MUST\)

seq: 요청의 직접적인 결과인 스트림의 첫 번째 패킷의 시퀀스 번호를 나타냅니다. 이를 통해 클라이언트는 탐색 시 패킷을 우아하게 처리할 수 있습니다. 클라이언트는 이 값을 사용하여 검색 이전에 발생한 패킷과 검색 이후에 발생한 패킷을 구별합니다. 클라이언트는 패킷 손실이나 재정렬로 인해 표시된 시퀀스 번호의 패킷을 수신하지 못하고 대신 더 높은 시퀀스 번호의 패킷을 수신할 수 있다는 점에 유의하십시오. 이 매개변수는 존재하는 것이 좋습니다.\(SHOULD\)

rtptime: Range 응답 헤더의 시작 시간 값에 해당하는 RTP 타임스탬프 값을 나타내야 하며, 명시적으로 제공되지 않은 경우 암시된 시작 지점을 나타내야 합니다. 클라이언트는 이 값을 사용하여 RTP 시간과 NPT 또는 기타 미디어 시간 척도의 매핑을 계산합니다. 미디어 간 동기화가 이루어지도록 하려면 이 매개변수가 있어야 합니다. 수신된 RTP 패킷이 동기화를 설정하는 데 사용된 매개변수의 값과 동일한 RTP 타임스탬프 값을 가져야 한다는 요구 사항은 없습니다.\(MUST, SHOULD\)

- RTCP를 통해 RTP 타임스탬프에서 NTP 형식 타임스탬프\(벽시계\)로의 매핑이 가능합니다. 그러나 이 정보는 RTP 타임스탬프에서 미디어 시계 시간\(NPT 등\)으로의 매핑을 생성하는 데 충분하지 않습니다. 또한 이 정보를 필요한 시간\(시작 시 또는 검색 후 즉시\)에 사용할 수 있고 안정적으로 전달되도록 하기 위해 이 매핑은 RTSP 제어 채널에 배치됩니다.

오랫동안 중단 없이 드리프트를 보상하기 위해

- 프레젠테이션에서 RTSP 클라이언트는 초기 RTCP 발신자 보고서를 사용하여 매핑을 수행하고 이후 보고서를 사용하여 매핑에 대한 드리프트를 확인하여 NPT를 NTP에 추가로 매핑해야 합니다.

```text
   Example:

   Range:npt=3.25-15
   RTP-Info:url="rtsp://example.com/foo/audio" ssrc=0A13C760:seq=45102;
            rtptime=12345678,url="rtsp://example.com/foo/video"
            ssrc=9A9DE123:seq=30211;rtptime=29567112
```

오디오가 16kHz RTP 타임스탬프 클럭을 사용하고 비디오가 90kHz RTP 타임스탬프 클럭을 사용한다고 가정합니다. 그런 다음 미디어 동기화는 다음과 같은 방식으로 설명됩니다.

```text
   NPT    3.0---3.1---3.2-X-3.3---3.4---3.5---3.6
   Audio               PA A
   Video                  V    PV
```

X: 범위 헤더의 NPT 시간 값 = 3.25. A: RTP-Info 헤더의 오디오에 대한 RTP 타임스탬프 값\(12345678\). V: RTP-Info 헤더의 비디오에 대한 RTP 타임스탬프 값\(29567112\). PA: NPT = \(12344878 - A\) / 16000 + 3.25 = 3.2에 해당하는 12344878의 RTP 타임스탬프를 전달하는 RTP 오디오 패킷 PV: NPT = \(29573412 - V\)에 해당하는 29573412의 RTP 타임스탬프를 전달하는 RTP 비디오 패킷 / 90000 + 3.25 = 3.32

---
### **18.46.  Scale**

Scale 일반 헤더는 재생 중인 미디어 리소스에 대해 요청되거나 사용된 보기 속도를 나타냅니다. 배율 값 1은 일반적인 앞으로 보기 속도로 정상적으로 재생됨을 나타냅니다. 1이 아닌 경우, 해당 값은 일반 시청률에 대한 비율에 해당합니다. 예를 들어 값 2는 일반 시청률의 두 배\("빨리 감기"\)를 나타내고 값 0.5는 일반 시청률의 절반을 나타냅니다. 즉, 값이 2일수록 재생시간의 2배만큼 컨텐츠 시간이 늘어나게 됩니다. 경과된\(벽시계\) 시간 1초마다 2초의 콘텐츠 시간이 전달됩니다. 음수 값은 반대 방향을 나타냅니다. 특정 미디어 전송의 경우 일관되게 작동하려면 특정 고려 사항이 필요할 수 있습니다. RTP가 이를 처리하는 방법에 대한 설명은 부록 C.1을 참조하세요.

전송된 데이터 속도는 다른 스케일 값을 선택하여 변경되어서는 안 됩니다. 결과 비트 전송률은 scale = 1에 대한 콘텐츠의 명목 비트 전송률에 합리적으로 가까워야 합니다. 서버는 비트 전송률 제약 조건을 충족해야 할 때 데이터를 적극적으로 조작해야 합니다. 규모 변경 구현은 서버 및 미디어 유형에 따라 다릅니다. 비디오의 경우 서버는 예를 들어 키 프레임 또는 선택한 프레임만 전달할 수 있습니다. 오디오의 경우 피치를 유지하면서 오디오 시간 규모를 조정할 수도 있고, 바람직하지 않게 오디오 조각을 전달하거나 오디오를 완전히 음소거할 수도 있습니다.\(SHOULD NOT\)

서버와 콘텐츠는 지원하는 배율 값의 범위를 제한할 수 있습니다. 지원되는 값은 Media-Properties 헤더\(섹션 18.29\)로 표시됩니다. 클라이언트는 지원될 요청 값만 나타내야 합니다\(SHOULD\). 그러나 콘텐츠가 진행됨에 따라 값이 변경될 수 있으므로 요청이 도착했을 때 요청한 값이 더 이상 유효하지 않을 수 있습니다. 따라서 요청에서 지원되지 않는 값은 오류를 생성하지 않으며 서버가 가장 가까운 값을 선택하도록 강제합니다. 응답에는 항상 서버가 선택한 실제 스케일 값이 포함되어야 합니다.\(SHOULD, MUST\)

서버가 확장 기능을 구현하지 않으면 Scale 헤더를 반환하지 않습니다. PLAY에 대한 확장 작업을 지원하는 서버는 "play.scale" 기능 태그를 사용하여 이를 나타내야 합니다.\(MUST\)

역방향 재생에 대한 음수 스케일을 나타낼 때 Range 헤더는 섹션 18.40에 설명된 대로 감소하는 범위를 나타내야 합니다.\(MUST\)

정상 속도의 3.5배로 역방향 재생의 예:

```text
     Scale: -3.5
     Range: npt=15-10
```

---
### **18.47.  Seek-Style**

클라이언트가 미디어에 대한 무작위 액세스를 수행하기 위해 Range 헤더와 함께 PLAY 요청을 보낼 때 클라이언트는 서버가 요청 범위 이전에 첫 번째 미디어 샘플을 선택할지 또는 첫 번째 무작위 액세스 포인트를 선택할지 알 수 없습니다. 사용 사례에 따라 클라이언트의 선호도가 높을 수 있습니다. 이 기본 설정을 표현하고 서버가 실제로 해당 기본 설정에 따라 어떻게 작동했는지에 대한 정보를 클라이언트에 제공하기 위해 Seek-Style 일반 헤더가 정의됩니다.

Seek-Style은 임의 액세스 속성이 있는 미디어 스트림에 대한 클라이언트의 선호도를 나타내기 위해 모든 PLAY 요청에 포함될 수 있는 일반 헤더입니다. 서버는 어떤 정책이 적용되었는지 나타내기 위해 임의 액세스 속성이 있는 미디어에 대한 모든 PLAY 응답에 항상 헤더를 포함해야 합니다. 알려지지 않은 탐색 스타일 정책을 수신한 서버는 이를 무시하고 서버 기본 정책을 선택해야 합니다. 알 수 없는 정책을 수신한 클라이언트는 이를 무시해야 하며 Range 헤더와 미디어 동기화 정보를 기반으로 서버가 수행한 작업을 확인해야 합니다.\(MAY, MUST, MUST, MUST\)

이 사양은 요청할 수 있는 다음 탐색 정책을 정의합니다\(섹션 4.7.1 참조\).

RAP: RAP\(Random Access Point\)는 미디어 집합체에 존재하는 가장 가까운 이전 임의 액세스 지점을 찾아서 전달하도록 서버에 요청하는 동작입니다. RAP를 요청하면 미디어 디코더에서 전체 미디어 상태가 설정될 수 있는 지점에서 모든 미디어가 전달되므로 미디어 품질이 최고가 됩니다.

CoRAP: 조건부 무작위 액세스 포인트\(CoRAP\)는 위 RAP 동작의 변형입니다. 이 정책은 주로 미디어의 임의 액세스 지점 사이에 거리가 더 먼 경우를 위한 것입니다. CoRAP은 현재 일시정지 지점보다 요청된 시작 지점에 더 가까운 Random Access Point가 있다는 조건이 충족되면 RAP 정책을 사용합니다. 그렇지 않으면 검색이 수행되지 않고 현재 일시 정지 지점부터 재생이 계속됩니다. 이 정책은 전송이 계속되면 일시 중지 이전에 존재했던 미디어 상태를 사용할 수 있다고 가정합니다. 클라이언트나 서버가 이것이 사실이 아니라는 것을 알고 있다면 RAP 정책을 사용해야 합니다. 즉, 클라이언트가 현재 일시 정지 지점 이전의 시작 지점을 요청하는 경우 대부분의 경우 일시 정지 이전에 전달된 미디어와 요청한 미디어 유닛에 유효한 디코딩 종속성 체인이 존재하지 않습니다. 서버가 임의 액세스 포인트를 검색한 경우 서버는 Seek-Style 헤더에 CoRAP 정책을 반환하고 선택한 RAP의 위치를 ​​반영하도록 Range 헤더를 조정해야 합니다. 랜덤 액세스 포인트가 더 멀리 떨어져 있고 서버가 계속하기로 선택한 경우\(MUST\)

- 현재 일시 중지 지점부터 Seek-Style 헤더에 "Next" 정책을 포함해야 하며 Range 헤더 시작 지점을 현재 일시 중지 지점으로 조정해야 합니다.\(MUST\)

First-Prior: 요청된 시간보다 먼저 재생 시간이 있는 미디어 장치부터 First-Prior 정책이 전달되기 시작합니다. 개별 미디어의 경우 요청 시 계속 렌더링되는 미디어 단위만 포함됩니다. 연속 미디어의 경우 해당 범위의 요청된 시작 시간 동안 렌더링되는 미디어입니다.

다음: 범위의 제공된 시작 시간 이후의 다음 미디어 단위입니다. 연속 프레임 미디어의 경우 이는 제공된 시간 이후의 첫 번째 다음 프레임을 의미하고 개별 미디어의 경우 제공된 시간 이후에 렌더링될 첫 번째 단위를 의미합니다. 이 경우의 주요 용도는 클라이언트가 특정 지점까지의 모든 미디어를 보유하고 있다는 것을 알고 완전한 중단 없는 미디어 재생이 이루어질 수 있도록 계속해서 전달하기를 원하는 경우입니다. 이러한 시나리오의 예는 브로드캐스트/멀티캐스트 전달에서 유니캐스트 기반 전달로 전환하는 것입니다. 이 정책은 클라이언트의 명시적인 요청에만 사용해야 합니다.\(MUST\)

이러한 표현된 기본 설정은 시작 시간이나 미디어 품질을 최적화하기 위해 존재합니다. "다음" 정책은 클라이언트가 최소한의 중복으로 미디어를 요청할 수 있도록 Range 헤더의 일반적인 정의를 깨뜨립니다. 그러나 일부는 집계된 세션에서 여전히 발생할 수 있습니다. RAP와 First-Prior는 모두 요청된 범위 및 앞으로 미디어를 제공해야 하는 요구 사항을 충족합니다. 그러나 RAP를 사용하지 않는 한 예측 방법을 사용하는 많은 미디어 코덱의 미디어 품질은 이미 버퍼링되었거나 다른 사이드 채널을 통해 추가 데이터를 사용할 수 없는 한 심각하게 저하될 수 있습니다.

---
### **18.48.  Server**

서버 일반 헤더 필드에는 요청을 생성하거나 처리하기 위해 원본 서버에서 사용하는 소프트웨어에 대한 정보가 포함됩니다. 이 필드에는 서버와 중요한 하위 제품을 식별하는 여러 제품 토큰과 설명이 포함될 수 있습니다. 제품 토큰은 응용 프로그램을 식별하는 데 중요한 순서대로 나열됩니다.

```text
   Example:

   Server: PhonyServer/1.0
```

응답이 프록시를 통해 전달되는 경우 프록시 애플리케이션은 서버 응답 헤더를 수정해서는 안 됩니다. 대신 Via 필드\(섹션 18.57\)를 포함해야 합니다. 응답이 프록시에 의해 생성된 경우 프록시 애플리케이션은 이전에 서버에서 반환한 대로 서버 응답 헤더를 반환해야 합니다.\(MUST NOT, SHOULD, MUST\)

---
### **18.49.  Session**

세션 일반 헤더 필드는 RTSP 세션을 식별합니다. 성공적인 SETUP 요청의 결과로 서버에서 RTSP 세션이 생성되고 응답으로 세션 식별자가 클라이언트에 제공됩니다. RTSP 세션은 TEARDOWN 또는 REDIRECT에 의해 파괴되거나 서버에 의해 시간 초과될 때까지 존재합니다.

세션 식별자는 서버에 의해 선택되며\(섹션 4.3 참조\) SETUP 응답으로 반환되어야 합니다. 클라이언트가 세션 식별자를 수신하면 해당 세션과 관련된 모든 요청에 ​​이를 포함해야 합니다. 이는 세션 헤더가 PLAY, PAUSE, PLAY\_NOTIFY 및 TEARDOWN 메소드를 사용하여 요청에 포함되어야 함을 의미합니다. SETUP, OPTIONS, SET\_PARAMETER, GET\_PARAMETER 및 REDIRECT에 포함될 수 있습니다. DESCRIBE에 포함되어서는 안 됩니다. 이러한 요청이 파이프라인이고 세션 식별자가 아직 알려지지 않은 경우 세션 헤더는 PLAY, PAUSE, TEARDOWN, SETUP, OPTIONS SET\_PARAMETER 및 GET\_PARAMETER 메서드에 포함되어서는 안 됩니다.\(MUST, MUST, MUST, MAY, MUST NOT, MUST NOT\)

RTSP 응답에서 세션 헤더는 SETUP, PLAY, PAUSE 및 PLAY\_NOTIFY 메소드에 포함되어야 하며 TEARDOWN 및 REDIRECT 메소드에 포함될 수 있습니다. 다음 메소드의 요청에 포함된 경우 OPTIONS, GET\_PARAMETER 및 SET\_PARAMETER 응답에도 포함되어야 합니다. DESCRIBE 응답에 포함되어서는 안 됩니다.\(MUST, MUST, MUST NOT\)

세션 식별자는 전송 세션 또는 연결 전체에서 RTSP 세션을 식별합니다. 특정 세션에 대한 RTSP 요청은 다양한 URI\(프레젠테이션 및 미디어 URI\)를 사용할 수 있습니다. 특정 메서드에 어떤 URI가 허용되는지에 대한 세션에 따라 제한 사항이 있다는 점에 유의하세요. 그러나 동일한 클라이언트의 동일한 URI에 대한 여러 "사용자" 세션에서는 서로 다른 세션 식별자를 사용해야 합니다.

- 동일한 클라이언트에서 오는 동일한 URI에 대한 여러 배달 요청을 구별하려면 세션 식별자가 필요합니다.

세션 식별자가 유효하지 않은 경우 응답 454\(세션을 찾을 수 없음\)가 반환되어야 합니다.\(MUST\)

헤더에는 세션 시간 초과 기간에 대한 매개변수가 포함될 수 있습니다. 명시적으로 제공되지 않은 경우 이 값은 60초로 설정됩니다. 이는 세션 연결 유지가 필요한 빈도에 영향을 미치므로 30초보다 작은 값은 권장되지 않습니다. 그러나 기본값보다 큰 값은 비활성이지만 장기간 세션을 설정한 RTSP 애플리케이션에 유용할 수 있습니다.\(MAY\)

- 너무 자주 발생하지 않고 요청/응답 타이밍 변화에 대한 민감도가 낮은 연결 유지 메시지가 발생하므로 60초 값을 세션 시간 초과 값으로 선택했습니다. 시간 초과 값을 30초 미만으로 줄이면 해당 요청/응답 시간 초과가 세션 시간 초과의 중요한 부분이 됩니다. 또한 60초 값을 사용하면 클라이언트 오류가 발생할 경우 커밋된 서버 리소스를 합리적으로 신속하게 복구할 수 있습니다.

---
### **18.50.  Speed**

Speed ​​일반 헤더 필드는 지정된 속도로 미디어 스트림을 제공하려는 서버의 능력과 희망에 따라 전달 시간 단위당 특정 양의 명목 미디어 시간을 전달하도록 서버에 요청합니다. 클라이언트는 하한 및 상한이 있는 지정된 범위 내에 있도록 전송 속도를 요청합니다. 서버는 범위 내에서 가능한 최고 속도로 제공해야 하지만 기본 네트워크 경로가 결과 전송 데이터 속도를 지원할 수 있는 상한보다 빠르지는 않습니다. 주어진 범위 내의 속도 값이 제공될 수 있는 한 서버는 미디어 품질을 수정해서는 안 됩니다. 서버가 하한에 의해 제공되는 속도 값으로 미디어를 전달할 수 없는 경우에만 미디어 품질이 저하됩니다.\(MUST, MUST NOT\)

서버에 의한 속도 기능 구현은 선택 사항입니다. 서버는 기능 태그인 play.speed를 통해 지원을 나타낼 수 있습니다. 응답에 Speed ​​헤더가 없다는 것은 이 기능이 지원되지 않는다는 의미입니다.\(MAY\)

속도 매개변수 값은 양의 십진수 값으로 표현됩니다. 예를 들어 값 2.0은 데이터가 평소보다 두 배 빠르게 전달된다는 것을 나타냅니다. 속도 값 0은 유효하지 않습니다. 범위는 "하한 - 상한" 형식으로 지정됩니다. 하한값은 상한값보다 작거나 같을 수 있습니다. 모든 속도를 지원하지 못할 수도 있습니다. 따라서 서버는 요청된 값을 지원되는 가장 가까운 값으로 수정할 수 있습니다. 실제 지원되는 속도가 응답에 포함되어야 합니다. 그러나 사용 사례는 다양할 수 있으며 0.7-0.8, 0.3-2.0, 1.0-2.5 및 2.5-2.5와 같은 속도 값 범위에는 모두 용도가 있습니다.\(MAY, MUST\)

```text
   Example:

     Speed: 1.0-2.5
```

이 헤더를 사용하면 데이터 전달에 사용되는 대역폭이 변경됩니다. 이는 더 높거나 낮은 속도로 프레젠테이션을 전달해야 하는 특정 상황에서 사용하기 위한 것입니다. 주요 사용 사례는 버퍼 작업 또는 로컬 규모 작업입니다. 구현자는 세션의 대역폭이 사전에\(RTSP 이외의 수단으로\) 협상될 수 있으므로 재협상이 필요할 수 있다는 점을 명심해야 합니다. Speed ​​작업을 수행하려면 서버는 네트워크 경로가 결과 비트 전송률을 지원할 수 있는지 확인해야 합니다. 따라서 미디어 전송은 서버가 사용 가능한 비트 전송률에 반응하고 적응할 수 있도록 피드백을 지원해야 합니다.

---
### **18.51.  Supported**

Supported 일반 헤더는 기능 태그를 사용하여 클라이언트 또는 서버에서 지원하는 모든 확장을 열거합니다. 헤더에는 메시지 전송 클라이언트 또는 서버에서 지원하는 확장이 포함됩니다. Supported 헤더는 모든 요청에 ​​포함될 수 있습니다. 요청에 있는 경우 수신자는 해당 Supported 헤더로 응답해야 합니다. Supported 헤더는 4xx 및 5xx 응답에도 포함되어 있습니다.\(MAY, MUST\)

Supported 헤더에는 클라이언트나 서버가 이해하는 섹션 4.5에 설명된 기능 태그 목록이 포함되어 있습니다. 이러한 기능 태그는 서버나 클라이언트가 일반적으로 지원하는 태그이며 요청 리소스에만 국한되지 않습니다.

```text
   Example:

     C->S:  OPTIONS rtsp://example.com/ RTSP/2.0
            Supported: foo, bar, blech
            User-Agent: PhonyClient/1.2

     S->C:  RTSP/2.0 200 OK
            Supported: bar, blech, baz
```

---
### **18.52.  Terminate-Reason**

Terminate-Reason 요청 헤더를 사용하면 서버는 REDIRECT 또는 TEARDOWN 요청을 보낼 때 세션 종료 이유와 추가 정보를 제공할 수 있습니다. 이 사양은 리디렉션에 대한 세 가지 이유를 식별하며 향후 확장될 수 있습니다.

서버-관리자: 서버를 잠시 종료해야 합니다.

- 관리상의 이유.

세션 시간 초과: 클라이언트 세션이 오랜 기간 동안 활성 상태로 유지되었으며 서버는 이 세션과 관련된 리소스를 회수해야 한다고 결정했습니다.

Internal-Error 복구가 불가능한 내부 오류가 발생하여 서버가 강제로 세션을 종료했습니다.

서버는 리디렉션에 대한 정보가 포함된 추가 매개변수를 제공할 수 있습니다. 이 사양은 다음을 정의합니다.

time: 서버가 서비스 제공을 중지하는 벽시계 시간을 제공합니다.

user-msg: 서버에서 사용자에게 보내는 메시지가 포함된 UTF-8 텍스트 문자열입니다. 이 메시지는 사용자에게 표시되어야 합니다.\(SHOULD\)

---
### **18.53.  Timestamp**

Timestamp 일반 헤더는 에이전트가 요청을 보낸 시기를 설명합니다. 타임스탬프 값은 에이전트에게만 중요하며 모든 시간 척도를 사용할 수 있습니다. 응답 에이전트는 정확히 동일한 값을 에코해야 하며 이에 대한 정확한 정보가 있는 경우 요청을 수신한 후 경과된 시간\(초\)을 나타내는 부동 소수점 숫자를 추가할 수 있습니다. 타임스탬프는 신뢰할 수 없는 프로토콜을 통해 실행될 때 재전송에 대한 시간 초과 값을 조정할 수 있도록 에이전트가 응답 에이전트에 대한 왕복 시간을 계산하는 데 사용할 수 있습니다. 또한 신뢰할 수 없는 RTSP 전송에 대한 재전송 모호성을 해결합니다.\(MUST\)

현재 사양은 RTSP 메시지의 안정적인 전송만을 제공합니다. Timestamp 일반 헤더는 프로토콜이 향후에 신뢰할 수 없는 전송을 사용하도록 확장되는 경우에 지정됩니다.

---
### **18.54.  Transport**

Transport 일반 헤더는 사용할 전송 프로토콜을 나타내고 대상 주소, 압축, 멀티캐스트 TTL\(time-to-live\) 및 단일 스트림에 대한 대상 포트와 같은 매개변수를 구성합니다. 프리젠테이션 설명에 의해 아직 결정되지 않은 값을 설정합니다.

Transport 요청 헤더에는 여러 전송 사양 항목의 형태로 클라이언트가 허용하는 전송 옵션 목록이 포함될 수 있습니다. 전송 사양은 쉼표로 구분되어 선호도 내림차순으로 나열됩니다. 각 전송 사양은 전송 프로토콜 식별자와 세미콜론으로 구분된 매개변수로 구성됩니다. 전송 요청 헤더에는 동일한 전송 프로토콜 식별자를 사용하는 여러 전송 사양이 포함될 수 있습니다. 서버는 실제로 선택된 값\(있는 경우\)을 나타내기 위해 응답에 전송 응답 헤더를 반환해야 합니다. 전송 사양이 지원되지 않으면 전송 헤더가 반환되지 않으며 응답은 상태 코드 461\(지원되지 않는 전송\)\(섹션 17.4.25\)을 사용해야 합니다. 요청에 둘 이상의 전송 사양이 있는 경우 서버는 실제로 선택된 단일 전송 사양\(전송 사양\)을 반환해야 합니다\(있는 경우\). 클라이언트가 프레젠테이션 설명에서 가능한 구성에 대한 지침을 받게 되므로 전송 사양 항목 수는 제한될 것으로 예상됩니다.\(MAY, MAY, MUST, MUST, MUST\)

전송 헤더는 전송 매개변수를 변경하기 위해 후속 SETUP 요청에도 사용될 수 있습니다. 서버는 기존 스트림의 매개변수 변경을 거부할 수 있습니다.\(MAY, MAY\)

전송 프로토콜 식별자는 각 전송 사양에 대해 사용할 전송 프로토콜과 관련 규칙을 정의합니다. 각 전송 프로토콜 식별자는 발생해야 하는 매개변수를 정의합니다. 추가적인 선택적 매개변수가 발생할 수 있습니다. 이러한 유연성은 매개 변수가 다를 수 있고 RTSP 에이전트에 다른 옵션을 제공할 수 있기 때문에 제공됩니다. 전송 사양에는 주어진 매개변수 중 하나만 포함될 수 있습니다. 매개변수는 이름과 선택적으로 값 문자열로 구성됩니다. 매개변수는 순서에 관계없이 제공될 수 있습니다. 또한 전송 사양에는 유니캐스트 또는 멀티캐스트 전송 유형 매개변수만 포함될 수 있습니다. 전송 프로토콜 식별자와 모든 매개변수는 전송 사양에서 이해되어야 합니다. 그렇지 않은 경우 전송 사양을 무시해야 합니다. 전송 사양\(예: 액세스 프록시 또는 보안 프록시\)을 사용하거나 수정하는 모든 유형의 RTSP 프록시는 알 수 없는 매개변수가 있는 사양을 제거해야 합니다.\(MAY, MAY, MUST, MUST\)

RTSP 메시지를 전달하기 전에. 그 결과 남은 전송 사양이 없으면 프록시는 전송 헤더 없이 461\(지원되지 않는 전송\)\(섹션 17.4.25\) 응답을 보내야 합니다.\(MUST\)

- 전송 헤더는 단일 미디어 스트림을 설명하는 것으로 제한됩니다. \(RTSP는 여러 스트림을 단일 엔터티로 제어할 수도 있습니다.\) 다양한 세션 설명 형식에 의존하는 대신 이를 RTSP의 일부로 만들면 방화벽 설계가 크게 단순화됩니다.

전송 프로토콜 식별자의 일반 구문은 슬래시로 구분된 토큰 목록입니다.

```text
   Value1/Value2/Value3...
```

RTP 전송의 경우 다음 형식을 취합니다.

```text
   RTP/profile/lower-transport.
```

"lower-transport" 매개변수의 기본값은 프로필에 따라 다릅니다. RTP/AVP의 경우 기본값은 UDP입니다.

유니캐스트 전송을 위해 미디어가 배달되어야 하는 위치를 지정하는 방법에는 두 가지가 있습니다.

dest\_addr: 이 매개변수와 해당 값의 존재는 미디어 전송에 필요한 대상 주소\(IP 흐름의 호스트 주소 및 포트 쌍\)를 나타냅니다.

dest\_addr 없음: dest\_addr 매개변수가 없다는 것은 서버가 RTSP 메시지가 시작된 동일한 주소로 미디어를 보내야 함을 나타냅니다.\(MUST\)

미디어가 전달될 위치를 나타내는 방법 선택은 사용 사례에 따라 다릅니다. 경우에 따라 허용되는 유일한 방법은 명시적인 주소 표시를 사용하지 않고 서버가 RTSP 메시지의 소스에 미디어를 전달하도록 하는 것입니다.

멀티캐스트의 경우 주소를 지정하는 여러 가지 방법이 있지만 유니캐스트와 비교하여 작동 방식이 다릅니다.

클라이언트가 선택한 주소가 있는 dest\_addr: 미디어를 전달할 실제 멀티캐스트 그룹에 대한 TTL\(범위\)과 같은 주소 및 관련 매개변수입니다. RTSP 서버가 기존 멀티캐스트 그룹에서 DoS 공격자로 사용될 수 있으므로 이 방법에는 해결해야 하는 보안 관련 사항\(섹션 21\)이 있습니다.

세션 설명 정보를 사용하는 dest\_addr: 전송 헤더에 포함된 정보는 모두 세션 설명\(예: SDP "c=" 및 "m=" 행\)에서 나올 수 있습니다. 이는 멀티캐스트 그룹 및 범위를 선택하는 것이 세션 공급자이기 때문에 이전 방법의 일부 보안 문제를 완화합니다. 클라이언트는 세션 설명에 정보가 있는 경우 해당 정보를 포함해야 합니다.\(MUST\)

No dest\_addr: 요청에 명시적인 멀티캐스트 그룹이 없을 때의 동작이 정의되지 않았습니다.

RTSP 프록시는 주의가 필요합니다. 미디어가 프록시를 통해 라우팅되는 것을 원하지 않는 경우 프록시는 대상 표시를 도입해야 합니다.

다음은 전송과 관련된 구성 매개변수입니다.

```text
   General parameters:
```

유니캐스트/멀티캐스트: 이 매개변수는 상호 배타적입니다.

- 유니캐스트 또는 멀티캐스트 전달이 시도되는지 여부를 나타냅니다. 두 값 중 하나를 지정해야 합니다. 유니캐스트와 멀티캐스트 전송을 모두 처리할 수 있는 클라이언트는 각각에 대해 별도의 매개변수가 있는 두 개의 전체 전송 사양을 포함하여 이러한 기능을 표시해야 합니다.\(MUST\)

레이어: 이 미디어 스트림에 사용될 멀티캐스트 레이어 수입니다. 레이어는 dest\_addr 주소에서 시작하여 연속적인 주소로 전송됩니다. 매개변수가 포함되지 않은 경우 기본값은 단일 레이어입니다.

dest\_addr: 하나 이상의 주소 사양을 포함할 수 있는 일반 대상 주소 매개변수입니다. 프로토콜/프로필/하위 전송의 각 조합에는 해당 주소 사양의 형식과 해석이 정의되어 있어야 합니다. RTP/AVP/UDP 및 RTP/AVP/TCP의 경우 주소 사양은 호스트 주소와 포트를 포함하는 튜플입니다. 전송 사양당 하나의 대상 매개변수만 사용됩니다. 단일 미디어를 여러 엔터티에 배포하기 위해 여러 대상을 사용하는 방법은 지정되지 않습니다.

- RTSP 요청을 시작하는 클라이언트는 튜플의 일부로 호스트 주소를 사용하여 스트림 수신자의 대상 주소를 지정할 수 있습니다. 대상 주소가 지정되면 수신자는 요청을 보낸 사람과 다른 당사자일 수 있습니다. 원격 제어 DoS 공격의 무의식적인 가해자가 되는 것을 방지하려면 서버는 반드시 보안 검사\(섹션 21.2.1 참조\)를 수행하고 로그를 기록해야 합니다.\(MAY, MUST\)

- 클라이언트가 서버에서 선택하지 않은 수신자 주소로 미디어 스트림을 보내는 것을 허용하기 전에 이러한 시도를 합니다. 구현 시 신뢰할 수 있는 클라이언트 식별 수단으로 TCP를 사용할 수 없습니다. 서버가 튜플의 호스트 주소 부분 설정을 허용하지 않으면 463\(대상 금지\)을 반환해야 합니다.\(MUST\)

- 대상 포트만 지정하려는 경우 튜플의 호스트 주소 부분은 비어 있을 수 있습니다\(예: ":58044"\). dest\_addr 매개변수가 있는 전송 헤더를 포함하는 요청에 대한 응답에는 서버가 실제로 사용하는 전체 대상 주소가 포함되어야 합니다. 서버는 프로토콜에서 요구하지 않는 한 응답 시 요청에 이미 존재하는 주소 정보를 제거해서는 안 됩니다.\(MAY, SHOULD, MUST NOT\)

src\_addr: 하나 이상의 주소 사양을 포함할 수 있는 일반 소스 주소 매개변수입니다. 프로토콜/프로필/하위 전송의 각 조합에는 해당 주소 사양의 형식과 해석이 정의되어 있어야 합니다. RTP/AVP/UDP 및 RTP/AVP/TCP의 경우 주소 사양은 호스트 주소와 포트를 포함하는 튜플입니다.

- RTSP 메시지가 전송된 주소가 아닌 다른 주소에서 미디어 패킷을 전송하는 경우 서버에서 이 매개변수를 지정해야 합니다. 이를 통해 클라이언트는 소스 주소를 확인하고 RTP가 사용되는 경우 RTCP 피드백 패킷에 대한 대상 주소를 제공할 수 있습니다. src\_addr 매개변수에 표시된 주소는 미디어 스트림의 데이터 패킷 전송 및 수신 모두에 사용되어야 합니다. 주된 이유는 세 가지입니다. 첫째, 포트와 소스 주소를 표시하면 수신자가 패킷의 출처를 알 수 있습니다. 둘째, 트래픽이 NAT 바인딩을 통해 대칭적으로 흐를 때 NAT 통과가 크게 단순화됩니다. 셋째, 특정 NAT 통과 메커니즘은 수신자에서 발신자로 소위 "바인딩 패킷"을 보낼 주소와 포트를 알아야 하므로 발신자-수신자 패킷 흐름이 사용할 수 있는 NAT에서 주소 바인딩을 생성합니다.\(MUST, SHOULD\)

이 정보는 SDP를 통해서도 제공될 수 있습니다.

- 그러나 이는 미디어 초기화라기보다는 전송 기능에 가깝기 때문에 이 정보에 대한 신뢰할 수 있는 소스는 SETUP 응답에 있어야 합니다.

모드: 모드 매개변수는 이 세션에 대해 지원되는 방법을 나타냅니다. 현재 정의된 유효한 값은 "PLAY"입니다. 제공되지 않은 경우 기본값은 "PLAY"입니다. "RECORD" 값은 RFC 2326에 정의되어 있습니다. 이 사양에서는 지정되지 않았지만 예약되어 있습니다. RECORD 및 기타 값은 나중에 지정될 수 있습니다.

interleaved: 인터리브 매개변수는 섹션 14에 정의된 메커니즘을 사용하여 제어 스트림에서 사용되는 프로토콜에 관계없이 미디어 스트림을 제어 스트림과 혼합하는 것을 의미합니다. 인수는 $ 블록에서 사용할 채널 번호를 제공합니다\(섹션 14 참조\). \) 반드시 존재해야 합니다. 이 매개변수는 미디어 스트림에 대한 전송 선택이 이를 요구하는 경우\(예: RTCP가 있는 RTP의 경우\) interleaved=4-5와 같이 간격으로 지정될 수 있습니다. 요청에 제공된 채널 번호는 사용할 채널 번호에 대해 클라이언트에서 서버로 전달되는 지침일 뿐입니다. 서버는 응답에 유효한 채널 번호를 설정할 수 있습니다. 선언된 채널은 양방향이므로 양쪽 최종 당사자 모두 지정된 채널에서 데이터를 보낼 수 있습니다. 이러한 사용법의 한 가지 예는 서버와 클라이언트가 모두 동일한 채널에서 RTCP 패킷을 보내는 RTCP에 사용되는 두 번째 채널입니다.\(MUST, MAY, MAY, MAY\)

- 이를 통해 RTP/RTCP는 UDP에서 수행되는 방식과 유사하게 처리될 수 있습니다. 즉, 한 채널은 RTP용이고 다른 채널은 RTCP용입니다.

MIKEY: 이 매개변수는 전송과 함께 사용됩니다.

- 보안 컨텍스트 설정을 위해 MIKEY \[RFC3830\]을 활용할 수 있는 사양입니다. 지금까지는 SRTP 기반 RTP 프로파일인 SAVP 및 SAVPF만이 MIKEY를 활용할 수 있었으며 이는 부록 C.1.4.1에 정의되어 있습니다. 이 매개변수는 요청 메시지와 응답 메시지 모두에 포함될 수 있습니다. 바이너리 MIKEY 메시지는 매개변수의 값 부분에 포함되기 전에 Base64로 인코딩\[RFC4648\]되어야 합니다. 여기서 인코딩은 RFC 4648 섹션 4의 정의를 준수하고 패딩 비트는 0으로 설정됩니다.\(MUST\)

```text
   Multicast-specific:
```

ttl: IPv4에 대한 멀티캐스트 TTL\(time-to-live\)입니다. 요청에 포함된 값은 클라이언트가 서버에 사용하도록 요청하는 TTL 값을 나타냅니다. 응답에는 서버에서 실제로 사용 중인 값이 반환됩니다. 서버는 어떤 값이 합리적인지, 그리고 이 값을 설정할 수 있는 사용자의 권한을 고려해야 합니다. 범위 지정은 IPv6 멀티캐스트 주소 \[RFC4291\]의 일부이므로 IPv6에는 해당 기능이 필요하지 않습니다.

```text
   RTP-specific:
```

이러한 매개변수는 미디어 전송 프로토콜이 RTP인 경우에만 사용할 수 있습니다.\(MAY\)

ssrc: SETUP 응답에 포함된 ssrc 매개변수는 미디어 서버가 스트림 내의 RTP 패킷에 사용할 RTP SSRC \[RFC3550\] 값을 나타냅니다. 값은 슬래시로 구분된 SSRC 값의 시퀀스로 표현되며, 각 SSRC는 8자리 16진수 값으로 표현됩니다.

- ssrc 매개변수는 요청에 지정되어서는 안 됩니다. SETUP 요청에서 ssrc 매개변수를 지정하는 기능은 RTP \[RFC3550\] 사양과 호환되지 않으므로 더 이상 사용되지 않습니다. 매개변수가 SETUP 요청의 전송 헤더에 포함된 경우 서버는 이를 무시하고 스트림에 적합한 SSRC를 선택해야 합니다. 서버는 응답의 전송 헤더에 ssrc 매개변수를 설정해야 합니다.\(MUST NOT, SHOULD, SHOULD\)

RTCP-mux: 단일 기본 전송 스트림/흐름에서 RTP 및 RTCP 다중화\[RFC5761\] 사용을 협상하는 데 사용됩니다. SETUP 요청에 이 매개변수가 있으면 클라이언트의 지원을 나타내며 서버가 RTP 및 RTCP 다중화를 사용해야 합니다. 클라이언트는 전송 헤더 사양에 하나의 전송 스트림만 포함해야 합니다. RTP/RTCP 다중화 사용 여부를 서버에 선택할 수 있게 하려면 두 가지 다른 전송 헤더 사양이 포함되어야 합니다.\(MUST\)

아래에 정의된 매개변수 설정 및 연결은 하위 수준 전송의 미디어 전송 프로토콜이 연결 지향\(예: TCP\)인 경우에만 사용할 수 있습니다. 그러나 RTSP 연결을 통해 데이터를 인터리빙할 때는 이러한 매개변수를 사용하면 안 됩니다.\(MAY, MUST NOT\)

setup: 클라이언트는 SETUP 요청의 Transport 라인에 있는 setup 매개변수를 사용하여 TCP 연결에서 수행하려는 역할을 나타냅니다. 이 매개변수는 \[RFC4145\]에서 채택되었습니다. RTP/AVP/TCP 비인터리브 전송에서 이 매개변수의 사용은 부록 C.2.2에서 논의됩니다. 아래 논의는 구문 문제에 국한됩니다. 클라이언트는 설정 매개변수에 대해 다음 값을 지정할 수 있습니다.

- 활성: 클라이언트가 나가는 연결을 시작합니다.

- 수동: 클라이언트가 들어오는 연결을 수락합니다.

actpass: 클라이언트가 수신을 기꺼이 수락합니다.

- 연결 또는 나가는 연결을 시작합니다.

- 클라이언트가 설정 값을 지정하지 않으면 "활성" 값으로 간주됩니다.

- 설정 매개변수가 "active"로 설정된 클라이언트 SETUP 요청에 대한 응답으로 서버의 2xx 응답은 전송 헤더 라인에서 설정 매개변수를 "passive"로 할당해야 합니다.\(MUST\)

- 설정 매개변수가 "passive"로 설정된 클라이언트 SETUP 요청에 대한 응답으로 서버의 2xx 응답은 전송 헤더 라인에서 설정 매개변수를 "active"로 할당해야 합니다.\(MUST\)

- 설정 매개변수가 "actpass"로 설정된 클라이언트 SETUP 요청에 대한 응답으로 서버의 2xx 응답은 전송 헤더 라인에서 설정 매개변수를 "active" 또는 "passive"로 할당해야 합니다.\(MUST\)

- 설정을 위한 "holdconn" 값은 RTSP 사용에 대해 정의되지 않았으며 전송 라인에 표시되어서는 안 됩니다.\(MUST NOT\)

연결: 클라이언트는 SETUP 요청의 Transport 헤더에 있는 전송 사양 부분에 있는 연결 매개변수를 사용하여 클라이언트와 서버 간의 기존 연결을 재사용하는 것에 대한 클라이언트의 선호도를 나타냅니다. 이 경우 클라이언트는 "connection" 매개변수를 "existing"으로 설정합니다. "\) 또는 클라이언트와 서버 사이에 새로운 연결 생성을 요청합니다\(이 경우 클라이언트는 "connection" 매개변수를 "new"로 설정합니다\). 일반적으로 클라이언트는 URL에 대한 첫 번째 SETUP 요청에 "new" 값을 사용하고 URL에 대한 후속 SETUP 요청에 "existing" 값을 사용합니다.

클라이언트 SETUP 요청이 "새" 값을 할당하는 경우

- "연결", 서버 응답은 전송 라인의 "연결"에 "새" 값도 할당해야 합니다.\(MUST\)

- 클라이언트 SETUP 요청이 "기존" 값을 "연결"에 할당하는 경우 서버 응답은 재량에 따라 전송 라인의 "연결"에 "기존" 또는 "새" 값을 할당해야 합니다.\(MUST\)

- 모든 SETUP 요청\(초기 및 후속\)에 대해 "연결"의 기본값은 "기존"입니다.

전송 프로토콜, 프로필 및 하위 전송의 조합을 정의해야 합니다. 다양한 조합이 부록 C에 정의되어 있습니다.

다음은 멀티캐스트 또는 유니캐스트를 처리하는 기능을 광고하고 멀티캐스트를 선호하는 클라이언트를 보여주는 사용 예입니다. 이는 유니캐스트 전용 스트림이므로 서버는 유니캐스트에 대한 적절한 전송 매개변수로 응답합니다.

```text
     C->S: SETUP rtsp://example.com/foo/bar/baz.rm RTSP/2.0
           CSeq: 302
           Transport: RTP/AVP;multicast;mode="PLAY",
               RTP/AVP;unicast;dest_addr="192.0.2.5:3456"/
               "192.0.2.5:3457";mode="PLAY"
           Accept-Ranges: npt, smpte, clock
           User-Agent: PhonyClient/1.2

     S->C: RTSP/2.0 200 OK
           CSeq: 302
           Date: Fri, 20 Dec 2013 10:20:32 +0000
           Session: rQi1hBrGlFdiYld241FxUO
           Transport: RTP/AVP;unicast;dest_addr="192.0.2.5:3456"/
              "192.0.2.5:3457";src_addr="192.0.2.224:6256"/
              "192.0.2.224:6257";mode="PLAY"
           Accept-Ranges: npt
           Media-Properties: Random-Access=0.6, Dynamic,
                             Time-Limited=20081128T165900
```

---
### **18.55.  Unsupported**

지원되지 않는 응답 헤더에는 응답하는 RTSP 에이전트가 지원하지 않는 기능이 나열되어 있습니다. Proxy-Require 필드\(18.37절\)를 통해 기능이 지정된 경우, 클라이언트와 서버 사이의 경로에 프록시가 있으면 프록시는 상태 코드 551\(옵션이 아님\)이 포함된 응답 메시지를 보내야 합니다. 지원됨\). 요청은 전달되어서는 안 됩니다.\(MUST, MUST NOT\)

사용 예는 섹션 18.43을 참조하세요.

---
### **18.56.  User-Agent**

User-Agent 일반 헤더 필드에는 요청을 시작하거나 응답을 생성하는 사용자 에이전트에 대한 정보가 포함됩니다. 이는 통계 목적, 프로토콜 위반 추적 및 특정 사용자 에이전트 제한을 피하기 위한 응답 맞춤화를 위한 사용자 에이전트 자동 인식을 위한 것입니다. 사용자 에이전트는 요청에 이 필드를 포함해야 합니다. 필드에는 에이전트와 사용자 에이전트의 중요한 부분을 구성하는 하위 제품을 식별하는 여러 제품 토큰과 설명이 포함될 수 있습니다. 일반적으로 제품 토큰은 응용 프로그램을 식별하는 데 중요한 순서대로 나열됩니다.\(SHOULD\)

```text
   Example:

   User-Agent: PhonyClient/1.2
```

---
### **18.57.  Via**

Via 일반 헤더 필드는 요청 시 사용자 에이전트와 서버 사이, 응답 시 원서버와 클라이언트 사이의 중간 프로토콜과 수신자를 나타내기 위해 프록시에서 사용해야 합니다. 이 필드는 메시지 전달을 추적하고, 요청 루프를 방지하고, 요청/응답 체인을 따라 모든 보낸 사람의 프로토콜 기능을 식별하는 데 사용됩니다.\(MUST\)

Via 필드의 여러 값 각각은 메시지를 전달한 각 프록시를 나타냅니다. 각 수신자는 전달 애플리케이션의 순서에 따라 최종 결과가 정렬되도록 정보를 추가해야 합니다. 따라서 클라이언트나 서버에서 발생하는 메시지에는 Via 헤더가 포함되지 않습니다. 첫 번째 프록시 또는 기타 중간자는 헤더와 해당 정보를 필드에 추가합니다. 추가 중간체는 추가 필드 값을 추가합니다. 그 결과 서버는 클라이언트-서버 요청에서 중간체 체인을 보게 되고 클라이언트는 응답 메시지에서 전체 체인을 보게 됩니다.\(MUST\)

프록시\(예: 액세스 프록시 또는 번역기 프록시\)는 기본적으로 개인/보호 영역 내의 호스트 이름과 포트를 전달해서는 안 됩니다. 이 정보는 명시적으로 활성화된 경우에만 전파되어야 합니다. 활성화되지 않은 경우 방화벽/NAT 뒤에 있는 호스트의 수신을 해당 호스트에 대한 적절한 가명으로 대체해야 합니다.\(SHOULD NOT, SHOULD, SHOULD\)

내부 구조를 숨기기 위한 강력한 개인 정보 보호 요구 사항이 있는 조직의 경우 프록시는 동일한 전송 프로토콜 값을 가진 Via 헤더 필드 항목의 정렬된 하위 시퀀스를 단일 항목으로 결합할 수 있습니다. 애플리케이션은 서로 다른 수신 프로토콜 값을 가진 항목을 결합해서는 안 됩니다.\(MAY, MUST NOT\)

---
### **18.58.  WWW-Authenticate**

WWW-Authenticate 헤더는 \[RFC7235\]에 지정되어 있습니다. 사용법은 Digest \[RFC7616\] 및 Basic \[RFC7617\]과 같이 사용되는 인증 체계에 따라 다릅니다. WWW-인증 응답 헤더 필드는 401\(인증되지 않음\) 응답 메시지에 포함되어야 합니다. field-value는 Request-URI에 적용할 수 있는 인증 체계와 매개변수를 나타내는 하나 이상의 챌린지로 구성됩니다. 이 헤더는 클라이언트에서 서버로의 요청과 관련된 응답 메시지에만 사용해야 합니다.\(MUST, MUST\)

HTTP 액세스 인증 프로세스는 섹션 19.1의 일부 설명과 함께 \[RFC7235\]에 설명되어 있습니다. 사용자 에이전트는 WWW-Authenticate 필드 값에 둘 이상의 챌린지가 포함될 수 있으므로 구문 분석 시 특별한 주의를 기울이는 것이 좋습니다. 또는 둘 이상의 WWW-Authenticate 헤더 필드가 제공되는 경우 챌린지 자체의 내용에 쉼표가 포함될 수 있습니다. 별도의 인증 매개변수 목록입니다.

---
## **19.  Security Framework**

RTSP 보안 프레임워크는 두 가지 상위 수준 구성 요소, 즉 HTTP 인증을 기반으로 하는 순수 인증 메커니즘과 RTSP와 독립적인 TLS 기반 메시지 전송 보호로 구성됩니다. RTSP 서버와 HTTP 서버 간의 구문 및 사용법이 유사하기 때문에 HTTP 보안이 상당 부분 재사용됩니다.

---
### **19.1.  RTSP and HTTP Authentication**

RTSP와 HTTP는 공통 인증 체계를 공유합니다. 따라서 \[RFC7235\]에 지정된 것과 동일한 프레임워크를 따릅니다. RTSP는 \[RFC7235\]에서 정의를 가져와 해당 RTSP 오류 코드\(401 및 407\)와 헤더\(WWW-Authenticate, Authorization, Proxy-Authenticate, Proxy-Authorization\)를 사용합니다. 서버는 기본 \[RFC7617\] 및 다이제스트 \[RFC7616\] 인증 체계를 모두 구현해야 합니다. 클라이언트는 클라이언트 인증을 요구하는 서버가 해당 기능이 있음을 신뢰할 수 있도록 기본 및 다이제스트 인증 체계를 모두 구현해야 합니다. 다이제스트 인증 체계를 구현하는 경우 아래 섹션 19.1.1에 지정된 추가 고려 사항을 따라야 합니다.\(SHOULD, MUST, MUST\)

HTTP 인증만으로는 완전한 RTSP 메시지 보안이 제공되지 않는다는 점을 강조해야 합니다. 따라서 TLS를 사용해야 합니다. 섹션 19.2를 참조하세요. 기본 인증 체계를 사용하는 Authorization 헤더를 포함하는 모든 RTSP 메시지는 기밀 보호가 활성화된 TLS 연결, 즉 NULL 암호화가 아닌 TLS 연결을 사용해야 합니다.\(SHOULD, MUST\)

클라이언트와 서버 사이에 일련의 프록시가 있는 경우 각 프록시는 개별적으로 클라이언트나 이전 프록시에 자체 인증을 요청할 수 있습니다. 이는 Proxy-Authenticate\(섹션 18.34\), Proxy-Authorization\(섹션 18.36\) 및 Proxy-Authentication-Info\(섹션 18.35\) 헤더를 사용하여 수행됩니다. 이러한 헤더는 홉별 헤더이며 현재 연결 및 홉으로만 범위가 지정됩니다. 따라서 프록시 체인이 존재하는 경우 다른 프록시에 연결되는 프록시는 다음 프록시에 대해 권한을 부여하기 위해 클라이언트 역할을 해야 합니다. WWW-Authenticate\(섹션 18.58\), Authorization\(섹션 18.8\) 및 Authentication-Info\(섹션 18.7\) 헤더는 종단 간이며 프록시에 의해 수정되어서는 안 됩니다.\(MUST NOT\)

이 인증 메커니즘은 현재 정의된 클라이언트-서버 요청에만 작동합니다. 이로 인해 TLS 기반 통신 컨텍스트 외부의 서버-클라이언트 요청이 클라이언트에 대한 메시지 삽입 공격에 더 취약해집니다. 존재하는 서버-클라이언트 방법에 따라 하이재킹\(REDIRECT\), 서비스 거부\(TEARDOWN 및 PLAY\_NOTIFY\) 또는 결과가 불확실한 공격\(SET\_PARAMETER\) 등 잠재적인 위험은 다양합니다.

---
#### **19.1.1.  Digest Authentication**

이 섹션에서는 HTTP Digest 인증 체계를 RTSP에 적용하는 데 필요한 수정 및 설명을 설명합니다. RTSP 체계 사용법은 HTTP \[RFC7616\]와 거의 완전히 동일합니다. 이러한 수정 사항은 SIP 2.0 \[RFC3261\]\(섹션 22.4\)에 정의된 절차를 기반으로 하지만 RFC 2617 대신 RFC 7235, RFC 7616 및 RFC 7615를 사용하도록 업데이트되었습니다.

다이제스트 인증은 \[RFC7615\]에 정의된 두 개의 추가 헤더인 Authentication-Info 및 Proxy-Authentication-Info를 사용합니다. 다이제스트 인증 규칙은 \[RFC7616\]에 정의된 규칙을 따르며 "HTTP/1.1"은 "RTSP/2.0"으로 대체되며 다음 차이점도 있습니다.

1. URI 매개변수가 RTSP에 대한 요청 URI 형식, 즉 ABNF 요소인 Request-URI\(섹션 20.2.1 참조\)를 사용한다는 차이점과 함께 참조 문서에 지정된 ABNF를 사용합니다. 도메인 매개변수는 절대 및 상대 URI에 대해 RTSP-URI-Ref 요소를 사용합니다.

2. MTag를 사용하는 경우 ETag를 MTag로 대체하면 ETag를 기반으로 nonce를 선택하는 예제 절차가 작동할 수 있습니다.

3. 다이제스트 인증 방식에서 메시지 무결성 보장을 위한 A2 값 계산에 대한 설명으로 구현자는 엔터티 본문이 비어 있을 때\(즉, RTSP 메시지에 메시지 본문이 없을 때\) 다음의 해시가 있다고 가정해야 합니다. 메시지 본문은 빈 문자열의 해시 또는 H\(entity-body\), 예 MD5\(""\) = "d41d8cd98f00b204e9800998ecf8427e"로 확인됩니다.

---
### **19.2.  RTSP over TLS**

RTSP 에이전트는 이 섹션과 다음 섹션 19.3에 정의된 대로 TLS를 통해 RTSP를 구현해야 합니다. RTSP는 HTTP에 대해 지정된 TLS \[RFC5246\] 사용과 관련하여 동일한 지침을 따라야 합니다. \[RFC2818\]을 참조하세요. TLS를 통한 RTSP는 URI 수준과 포트 수준 모두에서 보안되지 않은 RTSP와 구분됩니다. URI에서 "rtsp" 체계 식별자를 사용하는 대신 TLS를 통해 RTSP 신호를 보내는 데 "rtsps" 체계 식별자를 사용해야 합니다. "rtsps" 체계를 사용하는 URI에 포트가 제공되지 않으면 TCP/IP를 통한 TLS에 포트 322를 사용해야 합니다.\(MUST, MUST, MUST, MUST\)

클라이언트가 서버에 대해 안전하지 않은 채널을 설정하려고 시도하고\("rtsp" URI 사용\) 리소스에 대한 정책에 보안 채널이 필요한 경우 서버는 301 리디렉션 응답 코드를 전송하여 클라이언트를 보안 서비스로 리디렉션해야 합니다. 올바른 위치 URI\("rtsps" 구성표 사용\)와 함께. 사용자 또는 클라이언트는 구성표를 "rtsp"에서 "rtsps"로 변경하여 보안되지 않은 URI를 보안 URI로 업그레이드할 수 있습니다. "rtsps"에 대한 지원을 구현하는 서버는 이를 허용해야 합니다.\(MUST, MAY, MUST\)

TLS는 상호 인증을 허용한다는 점에 유의해야 합니다\(서버 및 클라이언트 인증서를 모두 사용하는 경우\). 그러나 TLS가 사용되는 가장 일반적인 방법 중 하나는 서버측 인증만 제공하는 것입니다\(종종 클라이언트 인증서를 피하기 위해\). 그런 다음 HTTP 인증 외에 TLS를 사용하여 전송 보안과 서버 인증을 제공하고, HTTP 인증은 클라이언트를 인증하는 데 사용됩니다.

RTSP에는 RTSP 세션 수명 동안 클라이언트와 서버 간에 TCP 세션을 유지할 수 있는 가능성이 포함되어 있습니다. TCP 세션을 유지하는 것이 TCP에 대한 추가 설정 시간뿐만 아니라 TLS에 대한 추가 설정 시간을 절약하기 위해 편리할 수 있습니다\(TLS가 재개 기능을 사용하더라도 거의 2번의 추가 왕복이 발생합니다\). 그러나 TLS를 사용하는 경우 이러한 동작으로 인해 TCP 및 RTSP뿐만 아니라 TLS에 대해서도 서버에 추가 활성 상태가 발생합니다. 이는 DoS 공격에 대한 취약성을 증가시킬 수 있습니다.

다른 리소스\(URI\)에 대해 TCP 및 TLS 상태를 재사용하는 경우 잠재적인 보안 취약점이 존재합니다. 두 개의 서로 다른 호스트 이름이 동일한 IP 주소를 가리키는 경우 해당 서버에 대한 TCP/TLS 연결을 재사용하는 것이 바람직할 수 있습니다. 이 경우 TCP/TLS 연결이 있는 RTSP 에이전트는 연결과 관련된 서버 인증서에 RTSP 요청이 발행될 리소스에 대한 URI에 있는 호스트 이름과 일치하는 SubjectAltName이 있는지 확인해야 합니다.\(MUST\)

이러한 권장 사항 외에도 섹션 19.3에서는 프록시와 함께 TLS 사용에 대한 추가 권장 사항을 제공합니다.

---
### **19.3.  Security and Proxies**

프록시의 본질은 종종 "중간자" 역할을 하는 반면, 보안은 종종 프록시의 존재를 방지하는 것입니다. 이 섹션에서는 클라이언트가 RTSP 에이전트 간에 보안 전송\(TLS\)을 적용하는 경우에도 프록시를 사용할 수 있는 가능성을 제공합니다. TLS 프록시 메커니즘은 인증서를 사용하여 서버 및 프록시 식별을 허용합니다. 그러나 인증서를 기반으로 클라이언트를 식별할 수는 없습니다. 클라이언트는 아래에 지정된 절차를 사용하거나 서버에 직접 TLS 연결\(프록시 우회\)을 사용하는 것 중에서 선택해야 합니다. 선택은 정책에 따라 달라질 수 있습니다.

일반적으로 프록시에는 투명 프록시\(클라이언트가 인식하지 못함\)와 불투명 프록시\(클라이언트가 인식함\)의 두 가지 범주가 있습니다. 이 메모는 불투명 RTSP 프록시, 즉 RTSP 클라이언트 및 RTSP 서버에 표시되는 프록시만 지정합니다. 프록시 기반 인프라에서는 클라이언트와 서버 모두 RTSP 메시지를 올바르게 처리하기 위해 프록시를 신뢰할 수 있는 신뢰 모델이 필요합니다. 프록시를 신뢰하려면 클라이언트와 서버도 프록시를 인식해야 합니다. 따라서 투명 프록시는 일반적으로 신뢰할 수 있는 것으로 간주될 수 없으며 보안과 잘 작동하지 않습니다\(전송 계층에서만 작동하지 않는 한\). 이 섹션의 나머지 부분에서 "프록시"에 대한 참조는 RTSP 메시지를 검사하거나 조작하는 불투명 프록시를 의미합니다.

HTTP 인증은 프록시를 가정하여 구축되었으며 클라이언트-서버 인증 외에도 사용자-프록시 인증 및 프록시-프록시/서버 인증을 제공할 수 있습니다.

TLS가 적용되고 프록시가 사용되는 경우 클라이언트는 RTSP 서버에 연결할 때 프록시 주소에 연결됩니다. 이는 TLS의 경우 클라이언트가 최종 서버가 아닌 프록시 서버를 인증한다는 것을 의미합니다. 클라이언트가 서버를 확인할 때 주의하세요.

TLS의 인증서를 사용하려면 프록시의 인증서 메시지에 표시된 프록시의 신원과 비교하여 프록시의 신원\(URI 또는 ​​기타 알려진 신원\)을 확인해야 합니다.\(MUST\)

문제는 클라이언트가 수락한 프록시의 경우 프록시에 다음 홉 인증서를 수락해야 하는 근거에 대한 정보를 제공해야 한다는 것입니다. 프록시와 사용자 모두 이에 대한 규칙을 가질 수 있으며 사용자는 원하는 동작을 선택할 수 있어야 합니다. 이 경우를 처리하기 위해 Accept-Credentials 헤더\(섹션 18.2 참조\)가 사용됩니다. 여기서 클라이언트는 중간 프록시와 서버를 인증하는 데 사용되는 인증서 체인을 다시 릴레이하도록 프록시 또는 프록시에 요청할 수 있습니다. 프록시가 신뢰할 수 있는 것으로 간주된다는 가정은 사용자에게 체인의 다음 에이전트를 수락해야 하는지 여부에 대한 각 신뢰할 수 있는 프록시에 대한 정책을 시행할 수 있는 가능성을 제공합니다. 그러나 모든 배포가 중간 프록시와 서버를 인증하는 데 사용되는 인증서 체인을 반환하는 것은 아닙니다. 이러한 배포의 운영자는 클라이언트로부터 해당 토폴로지를 숨길 수 있습니다. 클라이언트는 프록시 작업에 대해 전혀 알 수 없다는 점에 유의해야 합니다. 프록시를 신뢰할 수 있더라도 여전히 불완전한 인증서 체인을 반환할 수 있습니다.

RTSP 요청에 "rtsps" URI가 포함된 경우 프록시는 다음 홉에 TLS를 사용해야 합니다. TLS는 리소스와 최종 서버가 TLS를 사용할 필요가 없더라도 중간 링크\(예: 클라이언트와 프록시 간 또는 프록시와 프록시 간\)에 적용될 수 있습니다. 클라이언트가 서버에 도달하기 위해 사용하는 프록시 체인과 해당 TLS 세션에는 상응하는 보안이 있어야 합니다. 따라서 프록시는 다음 홉 TLS 연결을 시작할 때 수신 TLS 연결 암호 제품군 목록을 사용해야 하며, 프록시가 지원하지 않는 암호 제품군을 제거해야만 수정됩니다. 프록시와 다음 홉 프록시 또는 서버 간의 암호 그룹 불일치로 인해 프록시가 TLS 연결을 설정하지 못하는 경우 이는 오류 코드 472\(보안 연결 설정 실패\)를 사용하여 표시됩니다.\(MUST, MAY, MUST, MUST\)

---
#### **19.3.1.  Accept-Credentials**

클라이언트는 Accept-Credentials 헤더를 사용하여 간단한 권한 부여 정책을 중간 프록시에 배포할 수 있습니다. 클라이언트에는 프록시가 서버/다음 프록시 인증서를 처리하는 방법을 지정하는 Accept-Credentials 헤더가 포함되어 있습니다. 현재 세 가지 방법이 정의되어 있습니다.

모두: "any"를 사용하면 프록시\(또는 프록시\)는 제시된 모든 인증서를 수락해야 합니다. 물론 이는 권장되는 사용 옵션은 아니지만 특정 상황\(예: 테스트\)에서는 유용할 수 있습니다.\(MUST\)

프록시: "프록시" 방법의 경우 프록시\(또는 프록시\)는 자체 정책을 사용하여 인증서를 검증하고 이를 수락할지 여부를 결정해야 합니다. 이는 사용자가 프록시와 강한 신뢰 관계를 갖고 있는 경우에 편리합니다. 강력한 신뢰 관계가 존재할 수 있는 이유는 개인/회사 프록시이거나 프록시에 대역 외 정책 구성 메커니즘이 있기 때문입니다.\(MUST\)

사용자: "사용자" 방법의 경우 프록시\(또는 프록시\)는 인증을 위해 다음 홉에 대한 자격 증명 정보를 클라이언트에 보내야 합니다. 그런 다음 클라이언트는 프록시가 인증서를 수락해야 하는지 여부를 결정할 수 있습니다. 자세한 내용은 섹션 19.3.2를 참조하세요.\(MUST\)

Accept-Credentials 헤더가 클라이언트의 RTSP 요청에 포함되지 않은 경우 "프록시" 방법을 기본값으로 사용해야 합니다. "프록시" 이외의 방법을 사용하려면 클라이언트의 모든 RTSP 요청에 Accept-Credentials 헤더가 포함되어야 합니다. 이는 프록시가 서로 다른 RTSP 메시지 사이에서 항상 TLS 상태나 사용자의 이전 기본 설정을 유지한다고 가정할 수 없기 때문입니다\(특히 메시지 간의 시간 간격이 긴 경우\).\(MUST, MUST\)

"Any" 및 "Proxy" 방법을 사용하면 프록시는 각 방법에 정의된 대로 정책을 적용합니다. 정책이 다음 홉의 자격 증명을 허용하지 않는 경우 프록시는 상태 코드 471\(연결 자격 증명이 허용되지 않음\)을 사용하여 메시지로 응답해야 합니다.\(MUST\)

서버에서 클라이언트로 향하는 RTSP 요청에는 Accept-Credentials 헤더가 포함되어서는 안 됩니다. 비보안 통신의 경우 이러한 요청 가능성은 클라이언트 연결 설정 여부에 따라 달라집니다. 그러나 서버-클라이언트 요청이 TLS 보안 채널을 통해 설정된 세션과 관련된 경우 TLS 보안 연결을 통해 전송되어야 합니다. 해당 보안 연결은 마지막 클라이언트-서버 요청에서도 사용된 연결이어야 합니다. 서버가 요청을 보내려고 할 때 그러한 전송 연결이 존재하지 않으면 서버는 메시지를 폐기해야 합니다.\(MUST NOT, MUST, MUST, MUST\)

추가 정책을 정의하고 등록할 수 있지만 이는 주의해서 수행해야 합니다.\(MAY\)

---
#### **19.3.2.  User-Approved TLS Procedure**

"사용자" 방법의 경우 각 프록시는 각 RTSP 요청에 대해 다음 절차를 수행해야 합니다.\(MUST\)

o 아직 존재하지 않는 경우 TLS 세션을 다음 홉으로 설정합니다\(즉, TLS 핸드셰이크를 실행하지만 RTSP 요청을 보내지 않음\).

o TLS 세션에 대한 피어 인증서 체인을 추출합니다.

o 일치하는 ID와 피어 인증서의 해시가 Accept-Credentials 헤더에 있는지 확인하십시오. 있는 경우 메시지를 다음 홉으로 보내고 이 절차를 완료합니다. 그렇지 않은 경우 다음 단계로 이동하십시오.

o 프록시는 470 또는 407 응답 코드로 RTSP 요청에 응답합니다. 407 응답 코드는 프록시가 사용자 또는 클라이언트로부터 사용자 및 연결 인증을 모두 요구할 때 사용될 수 있습니다. 이 메시지에서 프록시는 다음 홉의 ID 및 인증서와 함께 Connection-Credentials 헤더를 포함해야 합니다\(섹션 18.13 참조\).\(MAY, MUST\)

클라이언트는 Connection-Credentials 헤더가 포함된 470\(연결 권한 부여 필요\) 또는 407\(프록시 인증 필요\) 응답을 수신하면 인증서를 수락할지 여부를 결정해야 합니다\(그렇게 할 수 없는 경우 사용자에게 문의해야 함\). 도메인 이름 대신 다음 홉 URI 및 인증서에 IP 주소를 사용하면 사용자가 다음 홉을 승인해야 하는지 여부를 결정하기가 매우 어렵습니다. 프록시는 도메인 이름을 사용하여 URI와 인증서에서 자신을 식별하는 것이 좋습니다. 인증서가 승인되면 클라이언트는 RTSP 요청을 다시 보내야 합니다. 해당 요청에서 클라이언트는 체인의 모든 신뢰할 수 있는 프록시에 대한 DER 인코딩 인증서에 대한 해시를 포함하는 Accept-Credentials 헤더를 포함해야 합니다.\(MUST, SHOULD\)

```text
   Example:

   C->P: SETUP rtsps://test.example.org/secret/audio RTSP/2.0
         CSeq: 2
         Transport: RTP/AVP;unicast;dest_addr="192.0.2.5:4588"/
                    "192.0.2.5:4589"
         Accept-Ranges: npt, smpte, clock
         Accept-Credentials: User

   P->C: RTSP/2.0 470 Connection Authorization Required
         CSeq: 2
         Connection-Credentials: "rtsps://test.example.org";
         MIIDNTCCAp...

   C->P: SETUP rtsps://test.example.org/secret/audio RTSP/2.0
         CSeq: 3
         Transport: RTP/AVP;unicast;dest_addr="192.0.2.5:4588"/
                    "192.0.2.5:4589"
         Accept-Credentials: User "rtsps://test.example.org";sha-256;
         dPYD7txpoGTbAqZZQJ+vaeOkyH4=
         Accept-Ranges: npt, smpte, clock

   P->S: SETUP rtsps://test.example.org/secret/audio RTSP/2.0
         CSeq: 3
         Transport: RTP/AVP;unicast;dest_addr="192.0.2.5:4588"/
                    "192.0.2.5:4589"
         Via: RTSP/2.0 proxy.example.org
         Accept-Credentials: User "rtsps://test.example.org";sha-256;
         dPYD7txpoGTbAqZZQJ+vaeOkyH4=
         Accept-Ranges: npt, smpte, clock
```

이 프로세스의 한 가지 의미는 보안 RTSP 메시지에 대한 연결이 첫 번째 메시지에 대해 훨씬 더 많은 왕복 시간을 소요할 수 있다는 것입니다. 각 홉에 대한 승인 프로세스로 인해 다음 홉에 연결되는 프록시와 클라이언트 간의 완전한 추가 메시지 교환이 이루어집니다. 그러나 각 메시지에 요청자가 수락하는 프록시 체인이 포함되어 있는 경우 나머지 메시지 교환이 지연되어서는 안 됩니다. 각 프록시에 상태를 구축하는 대신 각 요청에 자격 증명을 포함하는 절차를 수행하면 해지 절차가 필요하지 않습니다.

---
## **20.  Syntax**

RTSP 구문은 RFC 5234 \[RFC5234\]에 정의된 ABNF\(Augmented Backus-Naur Form\)에 설명되어 있습니다. RFC 5234에 있는 기본 정의를 사용합니다.

RFC 5234의 섹션 2.3에 지정된 대로 ABNF 문자열\(예: "Accept"\)은 대소문자를 구분하지 않습니다.

RTSP 구문은 UTF-8 인코딩\[RFC3629\]의 ISO 10646 문자 집합을 사용합니다.

---
### **20.1.  Base Syntax**

연속 줄이 공백이나 가로 탭으로 시작하는 경우 RTSP 헤더 값을 여러 줄로 접을 수 있습니다. 접기를 포함한 모든 선형 공백은 SP와 동일한 의미를 갖습니다. 수신자는 필드 값을 해석하거나 메시지 다운스트림을 전달하기 전에 모든 선형 공백을 단일 SP로 바꿀 수 있습니다. SWS 구성은 선형 공백이 선택 사항일 때, 일반적으로 토큰과 구분 기호 사이에 사용됩니다.\(MAY\)

헤더 이름을 나머지 값과 분리하기 위해 콜론이 사용됩니다. 콜론은 위의 규칙에 따라 앞에 공백을 허용하지만 줄바꿈은 허용하지 않고 뒤에 공백\(줄바꿈 포함\)을 허용합니다. HCOLON은 이 구성을 정의합니다.

```text
   OCTET           =  %x00-FF ; any 8-bit sequence of data
   CHAR            =  %x01-7F ; any US-ASCII character (octets 1 - 127)
   UPALPHA         =  %x41-5A ; any US-ASCII uppercase letter "A".."Z"
   LOALPHA         =  %x61-7A ; any US-ASCII lowercase letter "a".."z"
   ALPHA           =  UPALPHA / LOALPHA
   DIGIT           =  %x30-39 ; any US-ASCII digit "0".."9"
   CTL             =  %x00-1F / %x7F  ; any US-ASCII control character
                      ; (octets 0 - 31) and DEL (127)
   CR              =  %x0D ; US-ASCII CR, carriage return (13)
   LF              =  %x0A  ; US-ASCII LF, linefeed (10)
   SP              =  %x20  ; US-ASCII SP, space (32)
   HT              =  %x09  ; US-ASCII HT, horizontal-tab (9)
   BACKSLASH       =  %x5C  ; US-ASCII backslash (92)
   CRLF            =  CR LF
   LWS             =  [CRLF] 1*( SP / HT ) ; Line-breaking whitespace
   SWS             =  [LWS] ; Separating whitespace
   HCOLON          =  *( SP / HT ) ":" SWS
   TEXT            =  %x20-7E / %x80-FF  ; any OCTET except CTLs
   tspecials       =  "(" / ")" / "<" / ">" / "@"
                   /  "," / ";" / ":" / BACKSLASH / DQUOTE
                   /  "/" / "[" / "]" / "?" / "="
                   /  "{" / "}" / SP / HT
   token           =  1*(%x21 / %x23-27 / %x2A-2B / %x2D-2E / %x30-39
                   /  %x41-5A / %x5E-7A / %x7C / %x7E)
                      ; 1*<any CHAR except CTLs or tspecials>
   quoted-string   =  ( DQUOTE *qdtext DQUOTE )

   qdtext          = %x20-21 / %x23-5B / %x5D-7E / quoted-pair
                   / UTF8-NONASCII
                   ; No DQUOTE and no "\"
   quoted-pair     = "\\" / ( "\" DQUOTE )
   ctext           =  %x20-27 / %x2A-7E
                   /  %x80-FF  ; any OCTET except CTLs, "(" and ")"
   generic-param   =  token [ EQUAL gen-value ]
   gen-value       =  token / host / quoted-string

   safe            =  "$" / "-" / "_" / "." / "+"
   extra           =  "!" / "*" / "'" / "(" / ")" / ","
   rtsp-extra      =  "!" / "*" / "'" / "(" / ")"

   HEX             =  DIGIT / "A" / "B" / "C" / "D" / "E" / "F"
                   /  "a" / "b" / "c" / "d" / "e" / "f"
   LHEX            =  DIGIT /  "a" / "b" / "c" / "d" / "e" / "f"
                      ; lowercase "a-f" Hex
   reserved        =  ";" / "/" / "?" / ":" / "@" / "&" / "="

   unreserved      =  ALPHA / DIGIT / safe / extra
   rtsp-unreserved  =  ALPHA / DIGIT / safe / rtsp-extra

   base64          =  *base64-unit [base64-pad]
   base64-unit     =  4base64-char
   base64-pad      =  (2base64-char "==") / (3base64-char "=")
   base64-char     =  ALPHA / DIGIT / "+" / "/"
   SLASH    =  SWS "/" SWS ; slash
   EQUAL    =  SWS "=" SWS ; equal
   LPAREN   =  SWS "(" SWS ; left parenthesis
   RPAREN   =  SWS ")" SWS ; right parenthesis
   COMMA    =  SWS "," SWS ; comma
   SEMI     =  SWS ";" SWS ; semicolon
   COLON    =  SWS ":" SWS ; colon
   MINUS    =  SWS "-" SWS ; minus/dash
   LDQUOT   =  SWS DQUOTE ; open double quotation mark
   RDQUOT   =  DQUOTE SWS ; close double quotation mark
   RAQUOT   =  ">" SWS ; right angle quote
   LAQUOT   =  SWS "<" ; left angle quote

   TEXT-UTF8char    =  %x21-7E / UTF8-NONASCII
   UTF8-NONASCII    = UTF8-2 / UTF8-3 / UTF8-4
   UTF8-1           = <As defined in RFC 3629>
   UTF8-2           = <As defined in RFC 3629>
   UTF8-3           = <As defined in RFC 3629>
   UTF8-4           = <As defined in RFC 3629>
   UTF8-tail        = <As defined in RFC 3629>

   POS-FLOAT        = 1*12DIGIT ["." 1*9DIGIT]
   FLOAT            = ["-"] POS-FLOAT
```

---
### **20.2.  RTSP Protocol Definition**
---
#### **20.2.1.  Generic Protocol Elements**

```text
   RTSP-IRI       =  schemes ":" IRI-rest
   IRI-rest       =  ihier-part [ "?" iquery ]
   ihier-part     =  "//" iauthority ipath-abempty
   RTSP-IRI-ref   =  RTSP-IRI / irelative-ref
   irelative-ref  =  irelative-part [ "?" iquery ]
   irelative-part =  "//" iauthority ipath-abempty
                     / ipath-absolute
                     / ipath-noscheme
                     / ipath-empty

   iauthority     =  < As defined in RFC 3987>
   ipath          =  ipath-abempty   ; begins with "/" or is empty
                     / ipath-absolute  ; begins with "/" but not "//"
                     / ipath-noscheme  ; begins with a non-colon segment
                     / ipath-rootless  ; begins with a segment
                     / ipath-empty     ; zero characters

   ipath-abempty   =  *( "/" isegment )
   ipath-absolute  =  "/" [ isegment-nz *( "/" isegment ) ]
   ipath-noscheme  =  isegment-nz-nc *( "/" isegment )
   ipath-rootless  =  isegment-nz *( "/" isegment )
   ipath-empty     =  0<ipchar>
```

isegment = \*ipchar \[";" \*ipchar\] isegment-nz = 1\*ipchar \[";" \*ipchar\] / ";" \*ipchar isegment-nz-nc = \(1\*ipchar-nc \[";" \*ipchar-nc\]\) / ";" \*ipchar-nc ; 콜론 ":"이 없는 길이가 0이 아닌 세그먼트; 경로 내부에는 매개변수\(;로 구분\)가 없습니다.

```text
   ipchar         =  iunreserved / pct-encoded / sub-delims / ":" / "@"
   ipchar-nc      =  iunreserved / pct-encoded / sub-delims / "@"
                     ; sub-delims is different from RFC 3987
                     ; not including ";"

   iquery         =  < As defined in RFC 3987>
   iunreserved    =  < As defined in RFC 3987>
   pct-encoded    =  < As defined in RFC 3987>

   RTSP-URI       =  schemes ":" URI-rest
   RTSP-REQ-URI   =  schemes ":" URI-req-rest
   RTSP-URI-Ref   =  RTSP-URI / RTSP-Relative
   RTSP-REQ-Ref   =  RTSP-REQ-URI / RTSP-REQ-Rel
   schemes        =  "rtsp" / "rtsps" / scheme
   scheme         =  < As defined in RFC 3986>
   URI-rest       =  hier-part [ "?" query ]
   URI-req-rest   =  hier-part [ "?" query ]
                     ; Note fragment part not allowed in requests
   hier-part      =  "//" authority path-abempty

   RTSP-Relative  =  relative-part [ "?" query ]
   RTSP-REQ-Rel   =  relative-part [ "?" query ]
   relative-part  =  "//" authority path-abempty
                     / path-absolute
                     / path-noscheme
                     / path-empty

   authority      =  < As defined in RFC 3986>
   query          =  < As defined in RFC 3986>

   path           =  path-abempty    ; begins with "/" or is empty
                     / path-absolute ; begins with "/" but not "//"
                     / path-noscheme ; begins with a non-colon segment
                     / path-rootless ; begins with a segment
                     / path-empty    ; zero characters

   path-abempty   =  *( "/" segment )
   path-absolute  =  "/" [ segment-nz *( "/" segment ) ]
   path-noscheme  =  segment-nz-nc *( "/" segment )
   path-rootless  =  segment-nz *( "/" segment )
   path-empty     =  0<pchar>
```

세그먼트 = \*pchar \[";" \*pchar\] 세그먼트-nz = \( 1\*pchar \[";" \*pchar\]\) / \(";" \*pchar\) 세그먼트-nz-nc = \( 1\*pchar-nc \[";" \*pchar-nc\]\) / \(";" \*pchar-nc\) ; 콜론 ":"이 없는 길이가 0이 아닌 세그먼트; 경로 내부에는 매개변수\(;로 구분\)가 없습니다.

```text
   pchar          =  unreserved / pct-encoded / sub-delims / ":" / "@"
   pchar-nc       =  unreserved / pct-encoded / sub-delims / "@"

   sub-delims     =  "!" / "$" / "&" / "'" / "(" / ")"
                     / "*" / "+" / "," / "="
                     ; sub-delims is different from RFC 3986/3987
                     ; not including ";"

   smpte-range        =  smpte-type [EQUAL smpte-range-spec]
                         ; See section 4.4
   smpte-range-spec   =  ( smpte-time "-" [ smpte-time ] )
                      /  ( "-" smpte-time )
   smpte-type         =  "smpte" / "smpte-30-drop"
                      /  "smpte-25" / smpte-type-extension
                      ; other timecodes may be added
   smpte-type-extension  =  "smpte" token
   smpte-time         =  1*2DIGIT ":" 1*2DIGIT ":" 1*2DIGIT
                         [ ":" 1*2DIGIT [ "." 1*2DIGIT ] ]

   npt-range        =  "npt" [EQUAL npt-range-spec]
   npt-range-spec   =  ( npt-time "-" [ npt-time ] ) / ( "-" npt-time )
   npt-time         =  "now" / npt-sec / npt-hhmmss / npt-hhmmss-comp
   npt-sec          =  1*19DIGIT [ "." 1*9DIGIT ]
   npt-hhmmss       =  npt-hh ":" npt-mm ":" npt-ss [ "." 1*9DIGIT ]
   npt-hh           =  2*19DIGIT   ; any positive number
   npt-mm           =  2*2DIGIT  ; 0-59
   npt-ss           =  2*2DIGIT  ; 0-59
   npt-hhmmss-comp  =  npt-hh-comp ":" npt-mm-comp ":" npt-ss-comp
                       [ "." 1*9DIGIT ] ; Compatibility format
   npt-hh-comp      =  1*19DIGIT   ; any positive number
   npt-mm-comp      =  1*2DIGIT  ; 0-59
   npt-ss-comp      =  1*2DIGIT  ; 0-59

   utc-range        =  "clock" [EQUAL utc-range-spec]
   utc-range-spec   =  ( utc-time "-" [ utc-time ] ) / ( "-" utc-time )
   utc-time         =  utc-date "T" utc-clock "Z"
   utc-date         =  8DIGIT
   utc-clock        =  6DIGIT [ "." 1*9DIGIT ]

   feature-tag       =  token

   session-id        =  1*256( ALPHA / DIGIT / safe )

   extension-header  =  header-name HCOLON header-value
   header-name       =  token
   header-value      =  *(TEXT-UTF8char / LWS)
```

---
#### **20.2.2.  Message Syntax**

```text
   RTSP-message  = Request / Response  ; RTSP/2.0 messages

   Request       = Request-Line
                   *((general-header
                   /  request-header
                   /  message-body-header) CRLF)
                   CRLF
                   [ message-body-data ]

   Response     = Status-Line
                  *((general-header
                  /  response-header
                  /  message-body-header) CRLF)
                  CRLF
                  [ message-body-data ]

   Request-Line = Method SP Request-URI SP RTSP-Version CRLF

   Status-Line  = RTSP-Version SP Status-Code SP Reason-Phrase CRLF

   Method  =  "DESCRIBE"
           /  "GET_PARAMETER"
           /  "OPTIONS"
           /  "PAUSE"
           /  "PLAY"
           /  "PLAY_NOTIFY"
           /  "REDIRECT"
           /  "SETUP"
           /  "SET_PARAMETER"
           /  "TEARDOWN"
           /  extension-method

   extension-method  =  token

   Request-URI  =  "*" / RTSP-REQ-URI
   RTSP-Version =  "RTSP/" 1*DIGIT "." 1*DIGIT

   message-body-data = 1*OCTET

   Status-Code  =  "100"  ; Continue
                /  "200"  ; OK
                /  "301"  ; Moved Permanently
                /  "302"  ; Found
                /  "303"  ; See Other
                /  "304"  ; Not Modified
                /  "305"  ; Use Proxy
```

/ "400" ; 잘못된 요청

- / "401" ; 승인되지 않음 / "402" ; 결제 필요 / "403" ; 금지됨 / "404" ; 찾을 수 없음 / "405" ; 메소드가 허용되지 않음 / "406" ; 허용되지 않음 / "407" ; 프록시 인증 필요 / "408" ; 요청 시간 초과 / "410" ; 사라짐 / "412" ; 전제 조건 실패 / "413" ; 요청 메시지 본문이 너무 큼 / "414" ; 요청-URI가 너무 김 / "415" ; 지원되지 않는 미디어 유형 / "451" ; 매개변수를 이해할 수 없음 / "452" ; 예약됨 / "453" ; 대역폭이 충분하지 않음 / "454" ; 세션을 찾을 수 없음 / "455" ; 이 상태에서는 메서드가 유효하지 않습니다. / "456" ; 자원/"457"에 대한 헤더 필드가 유효하지 않습니다. 잘못된 범위 / "458" ; 매개변수는 읽기 전용 / "459"입니다. 집계 작업이 허용되지 않음 / "460" ; 집계 작업만 허용됨 / "461" ; 지원되지 않는 전송 / "462" ; 목적지에 도달할 수 없음 / "463" ; 목적지 금지 / "464" ; 데이터 전송이 아직 준비되지 않음 / "465" ; 통지 이유 알 수 없음 / "466" ; 키 관리 오류 / "470" ; 연결 인증 필요 / "471" ; 연결 자격 증명이 허용되지 않음 / "472" ; 보안 연결 설정 실패 / "500" ; 내부 서버 오류 / "501" ; 구현되지 않음 / "502" ; 잘못된 게이트웨이 / "503" ; 서비스를 이용할 수 없음 / "504" ; 게이트웨이 시간 초과 / "505" ; RTSP 버전은 지원되지 않음 / "551" ; 옵션이 지원되지 않음 / "553" ; 프록시를 사용할 수 없음/확장 코드

```text
   extension-code  =  3DIGIT

   Reason-Phrase   =  1*(TEXT-UTF8char / HT / SP)

   rtsp-header     = general-header
                   / request-header
                   / response-header
                   / message-body-header
```

일반 헤더 = 허용 범위

- / 캐시 제어 / 연결 / CSeq / 날짜 / 미디어 속성 / 미디어 범위 / 파이프라인 요청 / 프록시 지원 / 범위 / RTP 정보 / 규모 / 검색 스타일 / 서버 / 세션 / 속도 / 지원 / 타임스탬프 / 전송 / 사용자 에이전트 / 경유 / 확장 헤더

요청 헤더 = 수락

- / 자격 증명 수락 / 인코딩 수락 / 언어 수락 / 승인 / 대역폭 / 블록 크기 / 보낸 사람 / If-Match / If-Modified-Since / If-None-Match / Notify-Reason / 프록시 승인 / 프록시 필요 / 추천자 / 요청 상태 / 요구 / 종료 이유 / 확장 헤더

```text
   response-header  =  Authentication-Info
                    /  Connection-Credentials
                    /  Location
                    /  MTag
                    /  Proxy-Authenticate
                    /  Proxy-Authentication-Info
                    /  Public
                    /  Retry-After
                    /  Unsupported
                    /  WWW-Authenticate
                    /  extension-header

   message-body-header    =  Allow
                    /  Content-Base
                    /  Content-Encoding
                    /  Content-Language
                    /  Content-Length
                    /  Content-Location
                    /  Content-Type
                    /  Expires
                    /  Last-Modified
                    /  extension-header
```

---
#### **20.2.3.  Header Syntax**

```text
   Accept            =  "Accept" HCOLON
                        [ accept-range *(COMMA accept-range) ]
   accept-range      =  media-type-range [SEMI accept-params]
   media-type-range  =  ( "*/*"
                        / ( m-type SLASH "*" )
                        / ( m-type SLASH m-subtype )
                       ) *( SEMI m-parameter )
   accept-params     =  "q" EQUAL qvalue *(SEMI generic-param )
   qvalue            =  ( "0" [ "." *3DIGIT ] )
                     /  ( "1" [ "." *3("0") ] )
   Accept-Credentials =  "Accept-Credentials" HCOLON cred-decision
   cred-decision     =  ("User" [LWS cred-info])
                     /  "Proxy"
                     /  "Any"
                     /  (token [LWS 1*header-value])
                                     ; For future extensions
   cred-info         =  cred-info-data *(COMMA cred-info-data)

   cred-info-data    =  DQUOTE RTSP-REQ-URI DQUOTE SEMI hash-alg
                        SEMI base64
   hash-alg          =  "sha-256" / extension-alg
   extension-alg     =  token
   Accept-Encoding   =  "Accept-Encoding" HCOLON

                        [ encoding *(COMMA encoding) ]
   encoding          =  codings [SEMI accept-params]
   codings           =  content-coding / "*"
   content-coding    =  "identity" / token
   Accept-Language   =  "Accept-Language" HCOLON
                        language *(COMMA language)
   language          =  language-range [SEMI accept-params]
   language-range    =  language-tag / "*"
   language-tag      =  primary-tag *( "-" subtag )
   primary-tag       =  1*8ALPHA
   subtag            =  1*8ALPHA
   Accept-Ranges     =  "Accept-Ranges" HCOLON acceptable-ranges
   acceptable-ranges =  (range-unit *(COMMA range-unit))
   range-unit        =  "npt" / "smpte" / "smpte-30-drop" / "smpte-25"
                        / "clock" / extension-format
   extension-format  =  token
   Allow             =  "Allow" HCOLON Method *(COMMA Method)
   Authentication-Info = "Authentication-Info" HCOLON auth-param-list
   auth-param-list   =  <As the Authentication-Info element in RFC 7615>
   Authorization     =  "Authorization" HCOLON credentials
   credentials       =  <As defined by RFC 7235>

   Bandwidth         =  "Bandwidth" HCOLON 1*19DIGIT

   Blocksize         =  "Blocksize" HCOLON 1*9DIGIT

   Cache-Control     =  "Cache-Control" HCOLON cache-directive
                        *(COMMA cache-directive)
   cache-directive   =  cache-rqst-directive
                     /  cache-rspns-directive

   cache-rqst-directive =  "no-cache"
                        /  "max-stale" [EQUAL delta-seconds]
                        /  "min-fresh" EQUAL delta-seconds
                        /  "only-if-cached"
                        /  cache-extension

   cache-rspns-directive =  "public"
                            /  "private"
                            /  "no-cache"
                            /  "no-transform"
                            /  "must-revalidate"
                            /  "proxy-revalidate"
                            /  "max-age" EQUAL delta-seconds
                            /  cache-extension

   cache-extension   =  token [EQUAL (token / quoted-string)]
   delta-seconds     =  1*19DIGIT

   Connection         =  "Connection" HCOLON connection-token
                         *(COMMA connection-token)
   connection-token   =  "close" / token

   Connection-Credentials = "Connection-Credentials" HCOLON cred-chain
   cred-chain         =  DQUOTE RTSP-REQ-URI DQUOTE SEMI base64

   Content-Base       =  "Content-Base" HCOLON RTSP-URI
   Content-Encoding   =  "Content-Encoding" HCOLON
                         content-coding *(COMMA content-coding)
   Content-Language   =  "Content-Language" HCOLON
                         language-tag *(COMMA language-tag)
   Content-Length     =  "Content-Length" HCOLON 1*19DIGIT
   Content-Location   =  "Content-Location" HCOLON RTSP-REQ-Ref
   Content-Type       =  "Content-Type" HCOLON media-type
   media-type         =  m-type SLASH m-subtype *(SEMI m-parameter)
   m-type             =  discrete-type / composite-type
   discrete-type      =  "text" / "image" / "audio" / "video"
                      /  "application" / extension-token
   composite-type   =  "message" / "multipart" / extension-token
   extension-token  =  ietf-token / x-token
   ietf-token       =  token
   x-token          =  "x-" token
   m-subtype        =  extension-token / iana-token
   iana-token       =  token
   m-parameter      =  m-attribute EQUAL m-value
   m-attribute      =  token
   m-value          =  token / quoted-string

   CSeq           =  "CSeq" HCOLON cseq-nr
   cseq-nr        =  1*9DIGIT
   Date           =  "Date" HCOLON RTSP-date
   RTSP-date      =  date-time ;
   date-time      =  <As defined in RFC 5322>
   Expires        =  "Expires" HCOLON RTSP-date
   From           =  "From" HCOLON from-spec
   from-spec      =  ( name-addr / addr-spec ) *( SEMI from-param )
   name-addr      =  [ display-name ] LAQUOT addr-spec RAQUOT
   addr-spec      =  RTSP-REQ-URI / absolute-URI
   absolute-URI   =  < As defined in RFC 3986>
   display-name   =  *(token LWS) / quoted-string
   from-param     =  tag-param / generic-param
   tag-param      =  "tag" EQUAL token
   If-Match       =  "If-Match" HCOLON ("*" / message-tag-list)
   message-tag-list =  message-tag *(COMMA message-tag)
   message-tag      =  [ weak ] opaque-tag
   weak             =  "W/"
   opaque-tag       =  quoted-string

   If-Modified-Since  =  "If-Modified-Since" HCOLON RTSP-date
   If-None-Match    =  "If-None-Match" HCOLON ("*" / message-tag-list)
   Last-Modified    =  "Last-Modified" HCOLON RTSP-date
   Location         =  "Location" HCOLON RTSP-REQ-URI
   Media-Properties = "Media-Properties" HCOLON [media-prop-list]
   media-prop-list  = media-prop-value *(COMMA media-prop-value)
   media-prop-value = ("Random-Access" [EQUAL POS-FLOAT])
                    / "Beginning-Only"
                    / "No-Seeking"
                    / "Immutable"
                    / "Dynamic"
                    / "Time-Progressing"
                    / "Unlimited"
                    / ("Time-Limited" EQUAL utc-time)
                    / ("Time-Duration" EQUAL POS-FLOAT)
                    / ("Scales" EQUAL scale-value-list)
                    / media-prop-ext
   media-prop-ext   = token [EQUAL (1*rtsp-unreserved / quoted-string)]
   scale-value-list = DQUOTE scale-entry *(COMMA scale-entry) DQUOTE
   scale-entry      = scale-value / (scale-value COLON scale-value)
   scale-value      = FLOAT
   Media-Range      = "Media-Range" HCOLON [ranges-list]
   ranges-list      =  ranges-spec *(COMMA ranges-spec)
   MTag             =  "MTag" HCOLON message-tag
   Notify-Reason    = "Notify-Reason" HCOLON Notify-Reas-val
   Notify-Reas-val  = "end-of-stream"
                    / "media-properties-update"
                    / "scale-change"
                    / Notify-Reason-extension
   Notify-Reason-extension  = token
   Pipelined-Requests = "Pipelined-Requests" HCOLON startup-id
   startup-id  = 1*8DIGIT

   Proxy-Authenticate =  "Proxy-Authenticate" HCOLON challenge-list
   challenge-list     = <As defined by the WWW-Authenticate in RFC 7235>
   Proxy-Authentication-Info = "Proxy-Authentication-Info" HCOLON
                         auth-param-list
   Proxy-Authorization = "Proxy-Authorization" HCOLON credentials
   Proxy-Require      =  "Proxy-Require" HCOLON feature-tag-list
   feature-tag-list   =  feature-tag *(COMMA feature-tag)
   Proxy-Supported    =  "Proxy-Supported" HCOLON [feature-tag-list]

   Public             =  "Public" HCOLON Method *(COMMA Method)

   Range              =  "Range" HCOLON ranges-spec

   ranges-spec        =  npt-range / utc-range / smpte-range
                      /  range-ext

   range-ext          =  extension-format [EQUAL range-value]
   range-value        =  1*(rtsp-unreserved / quoted-string / ":" )

   Referrer           =  "Referrer" HCOLON (absolute-URI / RTSP-URI-Ref)
   Request-Status     =  "Request-Status" HCOLON req-status-info
   req-status-info    =  cseq-info LWS status-info LWS reason-info
   cseq-info          =  "cseq" EQUAL cseq-nr
   status-info        =  "status" EQUAL Status-Code
   reason-info        =  "reason" EQUAL DQUOTE Reason-Phrase DQUOTE
   Require            =  "Require" HCOLON feature-tag-list

   RTP-Info         =  "RTP-Info" HCOLON [rtsp-info-spec
                       *(COMMA rtsp-info-spec)]
   rtsp-info-spec   =  stream-url 1*ssrc-parameter
   stream-url       =  "url" EQUAL DQUOTE RTSP-REQ-Ref DQUOTE
   ssrc-parameter   =  LWS "ssrc" EQUAL ssrc HCOLON
                       ri-parameter *(SEMI ri-parameter)
   ri-parameter     =  ("seq" EQUAL 1*5DIGIT)
                    /  ("rtptime" EQUAL 1*10DIGIT)
                    /  generic-param

   Retry-After      =  "Retry-After" HCOLON (RTSP-date / delta-seconds)
   Scale            =  "Scale" HCOLON scale-value
   Seek-Style       =  "Seek-Style" HCOLON Seek-S-values
   Seek-S-values    =  "RAP"
                    /  "CoRAP"
                    /  "First-Prior"
                    /  "Next"
                    /  Seek-S-value-ext
   Seek-S-value-ext =  token

   Server           =  "Server" HCOLON ( product / comment )
                       *(LWS (product / comment))
   product          =  token [SLASH product-version]
   product-version  =  token
   comment          =  LPAREN *( ctext / quoted-pair) RPAREN

   Session          =  "Session" HCOLON session-id
                       [ SEMI "timeout" EQUAL delta-seconds ]

   Speed            =  "Speed" HCOLON lower-bound MINUS upper-bound
   lower-bound      =  POS-FLOAT
   upper-bound      =  POS-FLOAT

   Supported        =  "Supported" HCOLON [feature-tag-list]

   Terminate-Reason      =  "Terminate-Reason" HCOLON TR-Info
   TR-Info              =  TR-Reason *(SEMI TR-Parameter)
   TR-Reason            =  "Session-Timeout"
                        /  "Server-Admin"
                        /  "Internal-Error"
                        /  token
   TR-Parameter         =  TR-time / TR-user-msg / generic-param
   TR-time              =  "time" EQUAL utc-time
   TR-user-msg          =  "user-msg" EQUAL quoted-string

   Timestamp        =  "Timestamp" HCOLON timestamp-value [LWS delay]
   timestamp-value  =  *19DIGIT [ "." *9DIGIT ]
   delay            =  *9DIGIT [ "." *9DIGIT ]

   Transport        =  "Transport" HCOLON transport-spec
                       *(COMMA transport-spec)
   transport-spec   =  transport-id *trns-parameter
   transport-id     =  trans-id-rtp / other-trans
   trans-id-rtp     =  "RTP/" profile ["/" lower-transport]
                       ; no LWS is allowed inside transport-id
   other-trans      =  token *("/" token)

   profile           = "AVP" / "SAVP" / "AVPF" / "SAVPF" / token
   lower-transport   = "TCP" / "UDP" / token
   trns-parameter    = (SEMI ( "unicast" / "multicast" ))
                     / (SEMI "interleaved" EQUAL channel ["-" channel])
                     / (SEMI "ttl" EQUAL ttl)
                     / (SEMI "layers" EQUAL 1*DIGIT)
                     / (SEMI "ssrc" EQUAL ssrc *(SLASH ssrc))
                     / (SEMI "mode" EQUAL mode-spec)
                     / (SEMI "dest_addr" EQUAL addr-list)
                     / (SEMI "src_addr" EQUAL addr-list)
                     / (SEMI "setup" EQUAL contrans-setup)
                     / (SEMI "connection" EQUAL contrans-con)
                     / (SEMI "RTCP-mux")
                     / (SEMI "MIKEY" EQUAL MIKEY-Value)
                     / (SEMI trn-param-ext)
   contrans-setup    = "active" / "passive" / "actpass"
   contrans-con      = "new" / "existing"
   trn-param-ext     = par-name [EQUAL trn-par-value]
   par-name          = token
   trn-par-value     = *(rtsp-unreserved / quoted-string)
   ttl               = 1*3DIGIT ; 0 to 255
   ssrc              = 8HEX
   channel           = 1*3DIGIT ; 0 to 255
   MIKEY-Value       = base64
   mode-spec         = ( DQUOTE mode *(COMMA mode) DQUOTE )
   mode              = "PLAY" / token
   addr-list         = quoted-addr *(SLASH quoted-addr)
   quoted-addr       = DQUOTE (host-port / extension-addr) DQUOTE
   host-port         = ( host [":" port] )
                     / ( ":" port )
   extension-addr    = 1*qdtext
   host              = < As defined in RFC 3986>
   port              = < As defined in RFC 3986>

   Unsupported     = "Unsupported" HCOLON feature-tag-list
   User-Agent      = "User-Agent" HCOLON ( product / comment )
                     *(LWS (product / comment))
   Via             = "Via" HCOLON via-parm *(COMMA via-parm)
   via-parm        = sent-protocol LWS sent-by *( SEMI via-params )
   via-params      = via-ttl / via-maddr
                   / via-received / via-extension
   via-ttl         = "ttl" EQUAL ttl
   via-maddr       = "maddr" EQUAL host
   via-received    = "received" EQUAL (IPv4address / IPv6address)
   IPv4address     = < As defined in RFC 3986>
   IPv6address     = < As defined in RFC 3986>
   via-extension   = generic-param
   sent-protocol   = protocol-name SLASH protocol-version
                     SLASH transport-prot
   protocol-name   = "RTSP" / token
   protocol-version = token
   transport-prot  = "UDP" / "TCP" / "TLS" / other-transport
   other-transport = token
   sent-by         = host [ COLON port ]

   WWW-Authenticate = "WWW-Authenticate" HCOLON challenge-list
```

---
### **20.3.  SDP Extension Syntax**

이 섹션에서는 RTSP에 대해 정의된 SDP 확장을 ABNF에서 정의합니다. 텍스트의 확장 정의는 부록 D를 참조하세요.

```text
   control-attribute   =  "a=control:" *SP RTSP-REQ-Ref CRLF

   a-range-def         =  "a=range:" ranges-spec CRLF

   a-mtag-def          =  "a=mtag:" message-tag CRLF
```

---
## **21.  Security Considerations**

RTSP 및 그 사용과 관련된 보안 고려 사항 및 위협은 신호 프로토콜 자체에 대한 고려 사항과 미디어 스트림 전달과 관련된 문제로 나눌 수 있습니다. 그러나 보안 위협 완화와 관련하여 미디어 스트림 전달에 따른 위협은 실제로 신호 프로토콜의 메커니즘을 통해 완화될 수 있습니다.

이 문서에는 프로토콜에 대한 보안 솔루션을 정의하는 여러 장과 부록이 있습니다. 이 섹션은 아래 위협을 논의할 때 참조됩니다. 그러나 독자는 미디어 보안의 특정 측면을 달성하기 위해 보안 프레임워크\(섹션 19\)와 SRTP 및 해당 키 관리 사용 방법에 대한 사양\(부록 C.1.4\)에 특별한 주의를 기울여야 합니다.

---
### **21.1.  Signaling Protocol Threats**

이 섹션에서는 신호 프로토콜과 관련된 문제에 중점을 둡니다. RTSP 서버와 HTTP 서버 간의 구문 및 사용법이 유사하기 때문에 \[RFC7230\], \[RFC7231\], \[RFC7232\], \[RFC7233\], \[RFC7234\] 및 \[RFC7235\]에 설명된 보안 고려 사항도 적용됩니다.

구체적으로 다음 사항에 유의하시기 바랍니다.

서버 로그 정보의 남용: 서버는 사용자의 미디어 소비 패턴이나 관심 주제를 식별할 수 있는 사용자 요청에 대한 개인 데이터를 저장할 수 있는 위치에 있습니다. 이 정보는 본질적으로 명백히 기밀이며 특정 국가에서는 해당 정보의 처리가 법률에 의해 제한될 수 있습니다. 로그 정보는 안전하게 저장되어야 하며 분석을 위해서는 적절한 지침을 따라야 합니다. 추가 지침은 \[RFC7230\]의 섹션 9.8을 참조하세요.

민감한 정보의 전송: URI 및 헤더 내용, 특히 Server, Via, Referrer 및 From 헤더와 같이 RTSP 메시지로 전송되는 정보가 HTTP에서 사용될 때보다 덜 민감할 수 있다고 믿을 이유가 없습니다. . 따라서 데이터 개인 정보 보호 및 사용자 개인 정보 보호에 관한 모든 예방 조치는 RTSP 클라이언트, 서버 및 프록시 구현자에게 적용됩니다. 자세한 내용은 \[RFC7231\]의 섹션 9.3-9.6을 참조하세요.

```text
         The RTSP methods defined in this document are primarily used to
         establish and control the delivery of the media data
         represented by the URI; thus, the RTSP message bodies are
         generally less sensitive than the ones in HTTP.  Where HTTP
         bodies could contain, for example, your medical records, in
         RTSP, the sensitive video of your medical operation would be in
         the media stream over the media-transport protocol, not in the
         RTSP message.  Still, one has to take note of what potential
         sensitive information is included in RTSP.  The protection of
         the media data is separate, can be applied directly between
         client and server, and is dependent on the media-transport
         protocol in use.  See Section 21.2 for further discussion.
         This possibility for separation of security between media-
```

- 리소스 콘텐츠 및 신호 프로토콜은 프록시를 사용하는 RTSP 신호에 대한 홉별 보안을 사용할 때 미디어 콘텐츠 노출 위험을 완화합니다\(19.3절\).

파일 및 경로 이름 기반 공격: RTSP URI는 반드시 파일 시스템 의미를 가질 필요는 없는 불투명 핸들이지만 많은 구현에서는 요청-URI의 일부를 파일 시스템 호출로 직접 변환할 것으로 예상됩니다. 이러한 경우 파일 시스템은 경로 구성 요소의 ".." 검사와 같이 \[RFC7231\]의 섹션 9.1에 설명된 예방 조치를 따라야 합니다.\(SHOULD\)

개인 정보: RTSP 클라이언트는 HTTP 클라이언트와 동일한 정보\(사용자 이름, 위치 등\)에 접근하는 경우가 많으므로 똑같이 민감해야 합니다. 추가 권장 사항은 \[RFC7230\]의 섹션 9.8, \[RFC7231\]의 섹션 9.3-9.7 및 \[RFC7234\]의 섹션 8을 참조하세요.

Accept 헤더에 연결된 개인 정보 보호 문제: "Accept" 헤더의 유사한 사용법이 HTTP와 마찬가지로 RTSP에도 존재하므로 해당 사용과 관련하여 \[RFC7231\]의 섹션 9.4에 설명된 동일한 주의 사항을 따라야 합니다.

권한 설정: RTSP는 클라이언트가 미디어 스트림에 대한 권한 있는 소스와 어떻게 통신하는지에 대한 질문을 HTTP와 공유합니다\(\[RFC7230\]의 섹션 9.1\). 사용된 DNS 서버, 통신 보안, 중간자 가능성, RTSP 프록시에 대한 신뢰 등은 모두 클라이언트가 요청에 대해 신뢰할 수 없는 응답을 받았을 가능성에 영향을 미칩니다. 클라이언트가 신뢰할 수 있는 응답을 수신하는지 확인하는 것은 어려운 일이지만, RTSP 신호\(rtsps\)에 보안 통신을 사용하면 서버가 TLS 핸드셰이크에서 호스트 이름 ID 어설션을 제공할 수 있으므로 상당히 단순화됩니다.

위치 헤더 및 스푸핑: 단일 서버가 서로를 신뢰하지 않는 여러 조직을 지원하는 경우 해당 조직의 제어 하에 생성된 응답에서 Content-Location 헤더 필드의 값을 확인하여 신뢰하지 않는지 확인해야 합니다. 권한이 없는 리소스를 무효화합니다\(\[RFC2616\]의 섹션 15.4 참조\).\(MUST\)

이 글을 쓰는 현재 HTTP 사양\(\[RFC7230\], \[RFC7231\], \[RFC7232\], \[RFC7233\], \[RFC7234\] 및 \[RFC7235\]\)의 권장 사항과 이전 관련 RFC \[RFC2068\]의 권장 사항 외에도 \] \[RFC2616\], 향후 HTTP 사양은 보안 문제에 대한 추가 지침을 제공할 수 있습니다.

다음은 RTSP 구현에 대한 추가 고려 사항입니다.

세션 하이재킹: 전송 계층 연결과 RTSP 세션 사이에는 관계가 없거나 거의 없기 때문에 악의적인 클라이언트가 의심하지 않는 서버의 다른 클라이언트에 영향을 줄 수 있는 임의 세션 식별자를 사용하여 요청을 발행할 수 있습니다. 이를 완화하기 위해 서버는 이러한 종류의 공격 가능성을 최소화하기 위해 대규모의 무작위 비순차적 세션 식별자를 사용해야 합니다. 그러나 RTSP 신호가 TLS를 사용하여 항상 기밀로 보호되지 않는 한 경로상의 공격자가 세션을 하이재킹할 수 있습니다. 세션 하이재킹을 방지하기 위한 또 다른 선택은 클라이언트 인증을 사용하고 세션을 생성하는 인증된 클라이언트만 해당 세션에 액세스하도록 허용하는 것입니다.\(MUST\)

인증: 서버는 기본 인증과 다이제스트 \[RFC2617\] 인증을 모두 구현해야 합니다. 제어 메시지에 대해 더 엄격한 보안이 필요한 환경에서는 전송 계층 메커니즘 TLS \[RFC5246\]를 사용해야 합니다.\(SHOULD, SHOULD\)

의심스러운 행동: 보안 위험으로 간주되는 행동 인스턴스를 감지하면 RTSP 서버는 오류 코드 403\(금지됨\)을 반환해야 합니다. RTSP 서버는 또한 서버의 약점과 진입점을 조사하려는 시도를 인식해야 하며 로컬 보안 정책을 위반하는 것으로 간주되는 클라이언트의 추가 요청을 임의로 연결 해제하고 무시할 수 있습니다.\(SHOULD, SHOULD\)

프록시를 통한 TLS: 다중 다리에서 TLS를 연결하는 가능성\(섹션 19.3\)을 사용하는 경우 실제로 신뢰 모델을 알고 있어야 합니다. 이 절차를 수행하려면 서버 경로의 모든 프록시 부분에 대한 신뢰가 필요합니다. 지금까지 연결된 프록시가 올바르게 작동하고 신뢰를 충족한다고 가정하여 연결하는 프록시가 식별됩니다. 허용되는 프록시는 중간에 있는 사람이며 TLS 연결을 통해 진행되는 모든 작업에 액세스할 수 있습니다. 따라서 해당 신뢰 모델이 실제 애플리케이션에서 수용 가능한지 고려하는 것이 중요합니다. 실제 신뢰 모델에 대한 추가 논의는 섹션 19.3에 있습니다. 사용된 미디어 전송 프로토콜과 해당 보안 메커니즘에 보안 속성에 어떤 차이가 있는지 확인하는 것이 중요합니다. SRTP와 부록 C.1.4.1에 정의된 MIKEY 기반 키 설정을 사용하면 프록시에 키를 공개하지 않고도 미디어 키 설정을 엔드 투 엔드로 수행할 수 있습니다.

리소스 고갈: RTSP는 상태 저장 프로토콜이고 서버에서 리소스 사용량을 설정하므로 DoS 공격을 수행하기 위해 이러한 리소스를 초과 예약하여 서버를 공격할 가능성이 분명합니다. 이 공격은 진행 중인 세션에 대한 공격일 수도 있고 다른 사람이 세션을 설정하는 것을 방지할 수도 있습니다. RTSP 에이전트에는 단일 피어가 막대한 양의 리소스를 소비하는 것을 방지하는 메커니즘이 필요합니다. 이를 방지하는 방법은 에이전트의 역할과 능력, 정책에 따라 다양합니다. 각 구현에서는 이 위협을 완화하기 위한 방법과 정책을 신중하게 고려해야 합니다. 섹션 10.7에는 연결 처리에 관한 권장 사항이 있습니다.

위의 위협과 고려 사항으로 인해 프로토콜에 내장되거나 사용되는 일련의 보안 기능 및 메커니즘이 탄생했습니다. 신호 프로토콜은 보안 프레임워크\(섹션 19\)에 정의된 두 가지 보안 기능, 즉 HTTP 인증을 사용한 클라이언트 인증과 신호 메시지의 TLS 기반 전송 보호에 의존합니다. RTSP 에이전트는 이 두 가지 메커니즘을 모두 구현해야 합니다.

다양한 보안 완화가 프로토콜에 설계되었으며 사양이 작성된 대로 구현되면 인스턴스화됩니다. 예를 들어 클라이언트 인증을 사용하지 않을 때 무작위로 생성된 세션 식별자에 충분한 양의 엔트로피를 보장하여 세션 위험을 최소화합니다. 납치. 클라이언트 인증을 사용하면 액세스 가능한 세션의 범위를 이 클라이언트 ID가 생성한 세션으로 지정하여 하이재킹에 대한 보호가 크게 향상됩니다. 위의 위협 중 일부는 RTSP 기능 구현 자체에서 이를 완화하기 위해 어떤 정책과 전략을 사용할지 고려해야 할 정도입니다.

---
### **21.2.  Media Stream Delivery Threats**

RTSP가 미디어 스트림 전달을 설정하고 제어한다는 사실로 인해 미디어 스트림과 관련된 일련의 보안 문제가 발생합니다. 이 섹션에서는 일반적인 위협을 분석하려고 시도합니다. 그러나 RTP와 같은 미디어 스트림 전송 프로토콜을 선택하면 위협과 이를 완화하기 위해 존재하는 메커니즘에 약간의 차이가 발생합니다. 따라서 RTSP에서 사용할 수 있는 새로운 미디어 스트림 전송 및 전달 프로토콜의 각 사양에는 자체 보안 분석이 필요하다는 것이 중요해졌습니다. 이 섹션에는 RTP에 대한 섹션이 포함되어 있습니다.

미디어 스트림 전달 자체로 인한 일반적인 위협 세트는 다음과 같습니다.

집중형 서비스 거부 공격\(Concentrated Denial-of-Service Attack\): 이 프로토콜은 미디어 스트림이 DoS 공격의 망치 역할을 하는 원격 제어 DoS 공격 기회를 제공합니다. 섹션 21.2.1을 참조하십시오.

미디어 기밀성: 미디어 전달에는 모든 유형의 콘텐츠가 포함될 수 있으며 일반적으로 기밀 유지 측면에서 이 콘텐츠가 얼마나 민감한지 판단하는 것은 불가능합니다. 따라서 모든 미디어 전달 프로토콜은 실제 미디어 콘텐츠의 기밀성을 제공하는 방법을 제공해야 한다는 강력한 요구 사항이 있습니다. 미디어 수준 기밀성 외에도 신호에 사용된 리소스 식별자는 사람이 이해할 수 있는 이름을 가질 수 있거나 공격자가 사용할 수 있으므로 공격자에게 노출되지 않아 사용자가 수신한 콘텐츠를 확인할 수 있다는 것이 중요해졌습니다. . 따라서 신호 프로토콜은 미디어 리소스와 관련된 모든 정보에 대한 기밀 보호도 제공해야 합니다.

미디어 무결성 및 인증: 공격자가 RTSP 서버에서 전송된 미디어 스트림을 공격자의 생성 또는 선택 중 하나로 대체하는 데 관심을 갖는 데에는 대상에 대한 신용을 떨어뜨리거나 대상에 대한 잘못된 정보 등 여러 가지 이유가 있습니다. 따라서 미디어 프로토콜이 소스 인증과 무결성을 확인하고 미디어 스트림에 대한 재생 공격을 방지하는 메커니즘을 제공하는 것이 중요합니다.

멀티캐스트 범위: RTSP를 사용하여 멀티캐스트 네트워크로의 미디어 전송을 제어하는 ​​경우 전달 범위를 고려해야 합니다. RTSP는 IPv4에 대한 이 범위를 표시하기 위해 TTL 전송 헤더 매개변수를 지원합니다. IPv6에는 범위 경계에 대해 다른 메커니즘이 있습니다. 그러나 이러한 범위 제어는 너무 크게 설정되어 의도한 범위를 벗어나 미디어를 배포할 수 있다는 위험이 있습니다.

아래\(섹션 21.2.2\)에는 RTP 기반 미디어 전송에 대한 보안 고려 사항에 대한 프로토콜별 분석이 포함되어 있습니다. 해당 섹션에서는 RTP를 통한 미디어 전달을 지원하는 RTSP 에이전트에 대한 보안 기능 구현에 대한 요구 사항을 명확하게 설명합니다.

---
#### **21.2.1.  Remote DoS Attack**

공격자는 SETUP 요청에서 하나 이상의 IP 주소를 대상으로 지정하여 트래픽 흐름을 시작할 수 있습니다. 이 경우 공격자의 IP 주소가 알려질 수 있지만 추가 공격을 방지하거나 공격자의 신원을 확인하는 데 항상 유용한 것은 아닙니다. 따라서 RTSP 서버는 지정된 대상 주소가 다른 보안 메커니즘을 통해 미디어 수신을 허용하는 것을 서버가 확인한 경우 RTSP 시작 트래픽 흐름에 대해 클라이언트가 지정한 대상만 허용해야 합니다. 일반성이 높아지는 순서대로 허용되는 보안 메커니즘은 다음과 같습니다.\(MUST\)

```text
   o  Verification of the client's identity against a database of known
      users using RTSP authentication mechanisms (preferably Digest
      authentication or stronger)
```

o 특히 사용자 신원을 고려하여 미디어 대상으로 동의한 주소 목록

o 미디어 경로 기반 검증

서버는 요청 발신자가 스트림을 수신자에게 전달하도록 권한을 부여하는 메커니즘이 시스템에 존재하지 않는 한 대상 필드 설정을 허용해서는 안 됩니다. 이 인증은 미디어 수신자\(대상\) 자체에 의해 수행되고 자격 증명이 서버에 전달되는 것이 좋습니다. 그러나 수신자 주소가 멀티캐스트 그룹이거나 수신자가 대역 외 방식으로 서버와 통신할 수 없는 경우와 같은 특정 경우에는 이것이 불가능할 수 있습니다. 이러한 경우 서버는 요청 발신자가 수신자에게 스트림 전달을 요청하기 위한 적절한 자격 증명을 가지고 있는지 확인하기 위해 서버 상주 인증 목록과 같은 다른 방법을 선택할 수 있습니다.\(SHOULD NOT\)

유니캐스트 기반 전달에 적합한 미디어의 승인에 필요한 검증을 수행하는 한 가지 솔루션은 \[RFC7825\]에 설명된 ICE\(Interactive Connectivity Deployment\) \[RFC5245\] 기반의 NAT 통과 방법입니다. 이 메커니즘은 임의의 비밀번호와 사용자 이름을 사용하므로 의도치 않게 유효한 미디어 대상으로 표시될 가능성이 매우 낮습니다. 또한 서버는 STUN\(Session Traversal Utilities for NAT\) \[RFC5389\]에 대상이 다시 반향하는 쿠키\(임의의 자료로 구성됨\)를 요청합니다. 따라서 이 솔루션은 경로를 벗어난 공격자가 STUN 검사를 스푸핑하는 것을 방지합니다. 이로 인해 이 솔루션은 STUN 요청이 공격 대상으로 이동하여 응답을 위조하는 것을 볼 수 있는 경로상의 공격자에게만 취약해집니다.

멀티캐스트 주소로의 전달을 위해서는 이 메모에 명시되지 않은 다른 솔루션이 필요합니다.

---
#### **21.2.2.  RTP Security Analysis**

RTP는 일반적으로 사용되는 미디어 전송 프로토콜이며 RTSP 1.0 구현을 위한 가장 일반적인 선택이었습니다. 핵심 RTP 프로토콜은 오랫동안 사용되어 왔으며 잘 알려진 보안 속성을 가지고 있으며 RTP 보안 고려 사항\(\[RFC3550\]의 섹션 9\)을 검토할 필요가 있습니다. RTSP의 맥락에서 RTP 사용의 관점에서 다음 속성에 유의해야 합니다.

스트림 추가: RTP는 각 RTP 세션에서 여러 동시 미디어 스트림을 지원합니다. 일부 사용 사례에는 미디어 스트림과 해당 식별자의 비동기식 추가 및 제거에 대한 지원이 필요하므로 공격자는 프로토콜 설계에 따라 재생되도록 의도된 세션 컨텍스트에 추가 미디어 스트림을 쉽게 삽입할 수 있습니다. 또 다른 위협 벡터는 다수의 SSRC 식별자를 동시에 사용하는 등 RTP 세션 수신기의 리소스를 소진시키는 DoS 중 하나입니다. 이에 대한 강력한 완화 방법은 RTP 세션으로 들어오는 모든 패킷 흐름을 암호화 방식으로 인증하도록 하는 것입니다. 세션 컨텍스트에서 추가 미디어 스트림을 차단하는 것과 같은 약한 완화는 특정 RTP 확장이나 RTP 재전송\[RFC4588\]과 같은 여러 미디어 스트림에 의존하는 사용 사례를 방지하는 것 외에도 쉽게 DoS 취약점으로 이어집니다.

위조된 피드백: 내장된 RTCP는 몇 가지 다른 유형의 공격에 대해 넓은 공격 표면을 제공합니다. 한 가지 방법은 대량의 패킷 손실을 나타내는 RTCP 피드백을 미디어 발신자에게 전송하여 발신자로부터 미디어 비트 전송률 적응 응답을 트리거하여 미디어 품질을 낮추고 잠재적으로 미디어 스트림을 종료하는 것입니다. 또 다른 공격은 많은 SSRC 식별자를 사용하여 대규모 상태 테이블을 생성하고 RTCP 관련 처리 요구를 증가시켜 수신기에 대한 리소스 고갈 공격을 수행하는 것입니다.

RTP/RTCP 확장: RTP 및 RTCP 확장은 일반적으로 DoS 공격 또는 서비스 중단을 위한 추가 도구, 때로는 매우 강력한 도구를 제공합니다. 예를 들어 코드 제어 메시지 \[RFC5104\] RTCP 확장을 사용하면 비트 전송률을 낮은 값으로 잠그고 인트라 프레임을 요청하여 비디오 품질을 저하시킬 수 있습니다.

섹션 21.2의 위의 일반적인 논의와 이 섹션의 RTP 관련 논의를 고려하면 보호를 위해 강력한 보안 메커니즘이 지원되어야 한다는 것이 분명합니다.

RTP. 따라서 본 사양에서는 미디어 스트림을 처리하고 RTP를 사용하여 미디어 스트림 전송이 완료되는 모든 RTSP 에이전트에 대한 RTP 보안 기능에 대해 다음과 같은 요구 사항을 갖습니다.

RTP를 지원하는 RTSP 에이전트는 보안 RTP\(SRTP\) \[RFC3711\] 및 SAVP를 구현해야 합니다. 또한 AVPF가 구현된 경우 SAVPF \[RFC5124\]도 지원되어야 합니다. 이 사양에는 RFC 3711에서 필수 구현으로 지정된 것\(예: AES-CM 및 HMAC-SHA1\) 이외의 추가 암호화 변환 또는 구성 값이 필요하지 않습니다. 구현해야 하는 기본 키 관리 메커니즘은 MIKEY 키 설정\(부록 C.1.4.1\)에 정의된 것입니다. MIKEY 구현은 MIKEY-RSA-R 모드 \[RFC4738\]에 필요한 기능과 지원되는 SRTP 변환 및 매개변수를 협상하는 데 필요한 SRTP 매개변수 협상을 구현해야 합니다.\(MUST, MUST, MUST, MUST\)

---
## **22.  IANA Considerations**

이 섹션에서는 IANA에서 설정하고 유지 관리하는 RTSP 2.0용 레지스트리에 대해 설명합니다. 이러한 레지스트리는 RTSP 1.0에 대한 기존 레지스트리와 별개입니다. 각 레지스트리에는 필수 콘텐츠, 등록 절차 및 이 문서가 등록하는 항목에 대한 설명이 있습니다. RTSP 확장에 대한 자세한 내용은 섹션 2.7을 참조하세요. 또한 본 문서에는 세 가지 SDP 속성이 등록되어 있습니다.

RTSP 1.0용으로 만들어진 레지스트리 또는 레지스트리 항목은 RTSP 2.0으로 이동되지 않습니다. RTSP 1.0 및 RTSP 2.0의 레지스트리 및 항목은 독립적입니다. RTSP 2.0에도 레지스트리 또는 레지스트리 항목이 필요한 경우 아래에 정의된 절차를 따라 레지스트리에 레지스트리 또는 항목을 할당해야 합니다.\(MUST\)

항목을 등록하는 방법을 설명하는 섹션에서는 \[RFC5226\]에 설명된 일부 등록 정책, 즉 "선착순", "전문가 검토", "사양 필요" 및 "표준 조치"를 사용합니다.

등록소에 연락 담당자가 필요한 경우 작성자\(Magnus Westerlund <magnus.westerlund@ericsson.com\>을 기본으로 함\)가 이 문서에서 생성된 모든 항목에 대한 연락 담당자입니다.

IANA는 모든 등록 요청에 대해 다음 정보를 요청합니다.

o 의도한 레지스트리에서 지정한 규칙에 따라 등록할 항목의 이름

```text
   o  Indication of who has change control over the feature (for
      example, the IETF, ISO, ITU-T, other international standardization
      bodies, a consortium, a particular company or group of companies,
      or an individual)
```

o 가능한 경우 추가 설명에 대한 참조\(선호도 내림차순\), RFC, 출판된 표준, 출판된 논문, 특허 출원, 기술 보고서, 문서화된 소스 코드 또는 컴퓨터 설명서

```text
   o  For proprietary features, contact information (postal and email
      address)
```

---
### **22.1.  Feature Tags**
---
#### **22.1.1.  Description**

클라이언트와 서버가 RTSP 사양의 어떤 부분과 기능, 그리고 해당 사양이 구현하는 향후 확장을 결정하려고 하면 네임스페이스가 필요합니다. 이 레지스트리에는 특정 기능을 나타내는 명명된 항목이 포함되어 있습니다.

기능 태그의 사용법은 섹션 11과 섹션 13.1에 설명되어 있습니다.

---
#### **22.1.2.  Registering New Feature Tags with IANA**

기능 태그 등록은 선착순 \[RFC5226\] 기준으로 수행됩니다.

기능 태그의 레지스트리 항목에는 다음 정보가 있습니다.

o 기능 태그의 이름

- \* 등록자가 해당 기능이 독점임을 나타내는 경우 IANA는 공급업체 이름의 "접두사" 부분을 요청해야 합니다. 그러면 이름은 공급업체 접두사 뒤에 "."이 붙게 됩니다. 그 뒤에 제공된 기능 이름의 나머지 부분이 옵니다.

- \* 해당 기능이 독점적이지 않은 경우 IANA는 이름에 대한 접두사를 수집할 필요가 없습니다.

o 기능 태그가 나타내는 내용을 한 문단으로 설명

```text
   o  The applicability (server, client, proxy, or some combination)
```

o 해당되는 경우 사양에 대한 참조

기능 태그 이름\(공급업체 접두사 포함\)에는 공백이나 제어 문자가 아닌 문자가 포함될 수 있습니다. 기능 태그에는 길이 제한이 없습니다.

독점 기능을 설명하는 공급업체 태그의 예는 다음과 같습니다.

```text
         vendorA.specfeat01

         vendorA.specfeat02
```

---
#### **22.1.3.  Registered Entries**

본 명세서에서는 다음과 같은 기능 태그를 정의하고 등록한다. 변경 제어는 IETF에 속합니다.

play.basic: 이 메모에 정의된 핵심 RTSP 사양에 따른 전달 및 재생 작업 구현입니다. 클라이언트, 서버 및 프록시에 적용됩니다. 섹션 11.1을 참조하십시오.

play.scale: 미디어 재생을 위한 크기 조정 작업을 지원합니다. 서버에만 적용됩니다. 섹션 18.46을 참조하십시오.

play.speed: 미디어 전달을 위한 속도 기능을 지원합니다. 서버에만 적용됩니다. 섹션 18.50을 참조하십시오.

setup.rtp.rtcp.mux: 부록 C.1.6.4에 설명된 대로 RTP 및 RTCP 다중화 지원. 클라이언트와 서버, 미디어 캐싱 프록시 모두에 적용됩니다.

IANA 레지스트리는 각 기능 태그에 대한 이름, 설명 및 참조가 포함된 테이블입니다.

---
### **22.2.  RTSP Methods**
---
#### **22.2.1.  Description**

방법은 섹션 13에 설명되어 있습니다. 새로운 방법으로 프로토콜을 확장하면 완전히 새로운 기능이 가능해집니다.

---
#### **22.2.2.  Registering New Methods with IANA**

새로운 방법은 프로토콜의 동작과 목적을 근본적으로 바꿀 수 있기 때문에 표준 조치 \[RFC5226\]를 통해 등록됩니다.

새로운 RTSP 방식에 대한 사양은 다음 항목으로 구성됩니다.

o 메소드에 대한 ABNF 규칙을 따르는 메소드 이름.

o 해당 메소드를 사용하는 요청이 수행하는 작업과 예상되는 응답에 대한 명확한 사양. 방법이 사용되는 방향: C-\>S, S-\>C 또는 둘 다. 헤더 사용이 메서드의 동작과 효과를 수정하는 방법입니다.

o 요청 또는/및 응답의 메서드와 함께 사용하도록 허용된 IANA 등록 헤더를 지정하는 목록 또는 테이블. 목록이나 표는 섹션 18의 표 형식을 따라야 합니다.\(SHOULD\)

o 해당 방법이 네트워크 프록시와 어떻게 관련되는지 설명하십시오.

---
#### **22.2.3.  Registered Entries**

이 사양인 RFC 7826은 DESCRIBE, GET\_PARAMETER, OPTIONS, PAUSE, PLAY, PLAY\_NOTIFY, REDIRECT, SETUP, SET\_PARAMETER 및 TEARDOWN의 10가지 메서드를 등록합니다. 레지스트리의 초기 테이블은 아래와 같습니다.

```text
   Method         Directionality           Reference
   -----------------------------------------------------
   DESCRIBE       C->S                     RFC 7826
   GET_PARAMETER  C->S, S->C               RFC 7826
   OPTIONS        C->S, S->C               RFC 7826
   PAUSE          C->S                     RFC 7826
   PLAY           C->S                     RFC 7826
   PLAY_NOTIFY    S->C                     RFC 7826
   REDIRECT       S->C                     RFC 7826
   SETUP          C->S                     RFC 7826
   SET_PARAMETER  C->S, S->C               RFC 7826
   TEARDOWN       C->S, S->C               RFC 7826
```

---
### **22.3.  RTSP Status Codes**
---
#### **22.3.1.  Description**

상태 코드는 RTSP 응답 메시지에서 정보를 전달하는 데 사용되는 세 자리 숫자입니다. 섹션 8을 참조하십시오. 숫자 공간은 제한되어 있으므로 공간을 채우지 않도록 주의해야 합니다.

---
#### **22.3.2.  Registering New Status Codes with IANA**

새로운 상태 코드 등록은 IETF Review \[RFC5226\]의 정책을 따릅니다. 상태 코드가 필요한 새로운 RTSP 기능은 먼저 x50-x99 범위에 등록되어야 합니다. RTSP에 HTTP 확장을 채택하는 경우를 제외하고는 범위가 가득 찬 경우에만 x00-x49 범위에서 등록을 해야 합니다. 이는 관련 상태 코드의 번호를 다시 매길 필요 없이 RTSP에 HTTP 확장을 채택할 수 있도록 하기 위해 수행됩니다. 새 상태 코드에 대한 사양에는 다음이 포함되어야 합니다.

o 등록된 번호.

o 상태 코드의 의미와 코드 송신자와 수신자의 예상되는 동작에 대한 설명.

---
#### **22.3.3.  Registered Entries**

RFC 7826\(이 문서\)은 섹션 20.2.2의 "확장 코드"\(향후 확장에 허용되는 구문 정의\)를 제외하고 ABNF 항목 "상태 코드"에 정의된 번호가 지정된 상태 코드를 등록합니다.

---
### **22.4.  RTSP Headers**
---
#### **22.4.1.  Description**

새 헤더를 지정하면 하나 이상의 메서드가 다양한 방식으로 향상될 수 있습니다. 알 수 없는 헤더는 수신 에이전트에서 무시됩니다. 새로운 헤더가 특정 기능에 필수적인 경우 해당 기능에 대한 기능 태그를 생성하고 기능 태그를 전달하는 Require 헤더를 포함하여 상대방이 사용하도록 요구할 수 있습니다.

---
#### **22.4.2.  Registering New Headers with IANA**

전문가 검토 정책 \[RFC5226\]에 따라 등록할 수 있습니다. 사양을 제공하는 것이 좋습니다. RFC 또는 표준 개발 조직의 기타 사양을 제공하는 것이 좋습니다. 등록 요청의 최소 정보는 헤더 이름과 연락처 정보입니다.

전문 검토자는 등록 요청에 다음 정보가 포함되어 있는지 확인합니다.

o 헤더의 이름.

o 헤더 구문의 ABNF 사양.

o 헤더가 사용될 수 있는 시기를 지정하는 목록 또는 테이블,

- 모든 방법, 요청 또는 응답, 방향\(C-\>S 또는 S-\>C\)을 포함합니다.

o 프록시가 헤더를 처리하는 방법.

o 헤더의 목적에 대한 설명.

---
#### **22.4.3.  Registered Entries**

RFC 7826의 섹션 18에 지정된 모든 헤더가 등록되었습니다. 레지스트리에는 헤더 이름과 참조가 포함됩니다.

또한, 다른 규격에서 정의하고 있는 다음과 같은 레거시 RTSP 헤더는 아래 목록에 따라 헤더 이름, 참조로 등록됩니다. 참고: 이러한 참조는 레거시 상태로 인해 위의 등록 규칙을 모두 충족하지 못할 수도 있습니다.

o \[TS-26234\]에 정의된 x-wap-profile. x-wap-profile 요청 헤더에는 요청 에이전트의 장치 기능 프로필에 대한 하나 이상의 절대 URL이 포함되어 있습니다.

o \[TS-26234\]에 정의된 x-wap-profile-diff. x-wap-profile-diff 요청 헤더에는 장치 기능 프로필의 하위 집합이 포함되어 있습니다.

o \[TS-26234\]에 정의된 x-wap-profile-warning. x-wap-profile- 경고는 x-wap-profile 및 x-를 사용하여 설명한 대로 서버가 장치 기능 프로필과 관련하여 터미널 요청을 어느 정도까지 일치시킬 수 있었는지 설명하는 오류 코드가 포함된 응답 헤더입니다. wap-profile-diff 헤더.

o \[TS-26234\]에 정의된 x-predecbufsize. 이 응답 헤더는 TS 26.234 Annex G 가상 사전 디코더 버퍼 크기를 RTSP 에이전트에 제공합니다.

o \[TS-26234\]에 정의된 x-initpredecbuf기간. 이 응답 헤더는 TS 26.234 Annex G 가상의 사전 디코더 버퍼링 기간을 RTSP 에이전트에 제공합니다.

o \[TS-26234\]에 정의된 x-initpostdecbuf기간. 이 응답 헤더는 RTSP 에이전트에 TS 26.234 Annex G 포스트 디코더 버퍼링 기간을 제공합니다.

o \[TS-26234\]에 정의된 3gpp-videopostdecbufsize. 이 응답 헤더는 H.264\(AVC\) 비디오 스트림에 사용할 수 있는 TS 26.234 정의 포스트 디코더 버퍼 크기를 RTSP 에이전트에 제공합니다.

o \[TS-26234\]에 정의된 3GPP-Link-Char. 이 요청 헤더는 라디오 인터페이스에서 결정된 RTSP 클라이언트의 링크 특성을 RTSP 서버에 제공합니다. 제공할 수 있는 정보는 보장된 비트레이트, 최대 비트레이트, 최대 전송 지연입니다.

o \[TS-26234\]에 정의된 3GPP 적응. 이 일반 헤더는 PSS\(Packet-Switch Streaming Service\)에 지정된 비트 전송률 적응 솔루션의 일부입니다. RTSP 클라이언트의 버퍼 크기와 대상 버퍼 수준을 서버에 제공하고 응답은 지원 및 값을 확인하는 데 사용됩니다.

o \[TS-26234\]에 정의된 3GPP-QoE-Metrics. 이 일반 헤더는 PSS RTSP 에이전트가 클라이언트가 수집하여 서버에 보고해야 하는 경험 품질 측정항목을 협상하는 데 사용됩니다.

o \[TS-26234\]에 정의된 3GPP-QoE 피드백. 이 요청 헤더는 PSS를 지원하는 RTSP 클라이언트가 경험 품질 측정에서 수집된 측정항목의 실제 값을 보고하는 데 사용됩니다.

"x-"의 사용은 권장되지 않지만 목록의 위 헤더는 설명 이전에 정의되었습니다.\(SHOULD NOT\)

---
### **22.5.  Accept-Credentials**

보안 프레임워크의 TLS 연결 메커니즘에는 등록 가능한 두 개의 엔터티가 있습니다.

---
#### **22.5.1.  Accept-Credentials Policies**

이 레지스트리는 클라이언트를 대신하여 아웃바운드 TLS 연결을 설정할 때 RTSP 프록시가 TLS 인증서를 처리하고 확인하기 위한 정책을 위한 것입니다. 19.3.1절에서는 인증서 처리 방법에 대한 세 가지 정책을 지정합니다. 추가 정책이 정의될 수 있습니다. 등록은 Standards Action \[RFC5226\]을 통해 이루어집니다. 다음 정보를 포함하려면 등록 요청이 필요합니다.

o 정책의 이름.

o 정책이 다음을 처리하는 방법을 설명하는 텍스트입니다.

- 인증서.

o 연락 담당자.

이 사양은 다음 값을 등록합니다.

Any: 프록시가 수신된 모든 것을 수락하도록 요구하는 정책입니다.

-     자격증.

프록시: 프록시가 자체 정책을 적용하는 정책입니다.

- 어떤 인증서가 허용되는지 결정합니다.

사용자: 인증서가 프록시 체인을 통해 클라이언트로 전달되어야 하므로 사용자가 인증서를 수락할지 거부할지 결정할 수 있도록 하는 정책입니다.

---
#### **22.5.2.  Accept-Credentials Hash Algorithms**

Accept-Credentials 헤더\(섹션 18.2 참조\)는 허용된 엔터티의 DER 레코드를 해싱하기 위한 다른 알고리즘의 사용을 허용합니다. 향후 알고리즘의 등록은 극히 드물 것으로 예상되며 상호 운용성 문제를 일으킬 수도 있습니다. 따라서 새로운 알고리즘 등록 기준을 의도적으로 높게 설정한 것입니다.

새로운 해시 알고리즘을 등록하려면 표준 조치 \[RFC5226\]가 필요합니다. 등록은 다음 요구 사항을 충족해야 합니다.

o "토큰" ABNF 요구 사항을 충족하는 알고리즘 식별자.

o 알고리즘의 정의를 제공하십시오.

등록된 값은 다음과 같습니다.

```text
   Hash Alg. ID   Reference
   ------------------------
   sha-256        RFC 7826
```

---
### **22.6.  Cache-Control Cache Directive Extensions**

Cache-Control 헤더에 보낼 수 있는 캐시 지시문이 많이 있습니다. 이러한 캐시 지시문에 대한 레지스트리는 IANA에 의해 설정되었습니다. 이 레지스트리에 새로 등록하려면 표준 조치 또는 IESG 승인 \[RFC5226\]이 필요합니다. 등록 요청에는 다음 정보가 포함되어야 합니다.

o 캐시 지시어의 이름.

o 허용되는 경우 매개변수 값의 정의.

o 요청 또는 응답 지시문인 경우 사양.

o RTSP 제어 미디어 스트림에 캐시 지시문이 사용되는 방법을 설명하는 텍스트입니다.

o 연락 담당자.

이 사양은 다음 값을 등록합니다.

```text
      no-cache:

      public:

      private:

      no-transform:

      only-if-cached:

      max-stale:

      min-fresh:

      must-revalidate:

      proxy-revalidate:

      max-age:
```

레지스트리에는 지시문의 이름과 참조가 포함되어 있습니다.

---
### **22.7.  Media Properties**
---
#### **22.7.1.  Description**

RTSP에 의해 제어되는 미디어 스트림은 다양한 속성을 가질 수 있습니다. 사양을 작성할 때 염두에 둔 사용 사례를 포괄하는 데 필요한 미디어 속성이 정의됩니다. 그러나 추가적인 혁신으로 인해 여기에 지정된 속성에서 다루지 않는 속성을 가진 새로운 사용 사례나 미디어 스트림이 탄생할 것으로 예상할 수 있습니다. 따라서 새로운 미디어 속성을 지정할 수 있습니다. 새로운 미디어 속성에는 이 속성의 동작을 올바르게 지정하기 위해 상당한 양의 새로운 정의가 필요할 수 있으므로 기준을 높게 설정했습니다.

---
#### **22.7.2.  Registration Rules**

새로운 미디어 속성 등록은 사양 필수 정책 \[RFC5226\]에 따라 수행됩니다. 전문 검토자는 등록 요청이 다음 요구 사항을 충족하는지 확인합니다.

o "media-prop-ext" 정의를 충족하는 미디어 속성 값 이름의 ABNF 정의가 포함됩니다.

o 어떤 미디어 속성 그룹에 속해 있는지에 대한 정의 또는 새 그룹을 정의하는 내용이 포함됩니다.

o 이러한 변경으로 인한 RTSP 동작의 모든 변경 사항에 대한 설명이 포함되어 있습니다.

o 등록을 위한 담당자가 기재되어 있습니다.

---
#### **22.7.3.  Registered Values**

이 사양은 섹션 18.29에 나열된 10개의 값을 등록합니다. 레지스트리에는 속성 그룹, 미디어 속성 이름 및 참조가 포함되어 있습니다.

---
### **22.8.  Notify-Reason Values**
---
#### **22.8.1.  Description**

Notify-Reason 값은 알림이 전송된 이유를 나타내는 데 사용됩니다. 각 이유에는 알림에 포함될 수 있거나 포함되어야 하는 헤더 및 정보에 대한 관련 규칙이 있습니다. 상호 운용 가능한 사용을 활성화하려면 새로운 알림 동작을 지정해야 합니다. 따라서 각각의 새 값을 지정해야 합니다.

---
#### **22.8.2.  Registration Rules**

새로운 Notify-Reason 값 등록은 사양 필수 정책 \[RFC5226\]을 따릅니다. 전문 검토자는 요청이 다음 요구 사항을 충족하는지 확인합니다.

o "Notify-Reason-extension" 정의를 충족하는 Notify-Reason 값 이름의 ABNF 정의가 포함됩니다.

o 요청 및 응답에 어떤 헤더를 포함해야 하는지, 헤더를 언제 보내야 하는지, 헤더가 서버 클라이언트 상태에 미치는 영향에 대한 설명이 명확합니다.

o 등록을 위한 담당자가 기재되어 있습니다.

---
#### **22.8.3.  Registered Values**

이 사양은 Notify-Reasval ABNF, 섹션 20.2.3에 정의된 세 가지 값을 등록합니다.

end-of-stream: 이 Notify-Reason 값은 미디어 스트림의 끝을 나타냅니다.

media-properties-update: 이 Notify-Reason 값을 사용하면 서버는 재생 중에 미디어 속성이 변경되었음을 나타낼 수 있습니다.

scale-change: 이 Notify-Reason 값을 사용하면 서버는 미디어 규모의 변경 사항을 클라이언트에 알릴 수 있습니다.

레지스트리에는 이름, 설명 및 참조가 포함됩니다.

---
### **22.9.  Range Header Formats**
---
#### **22.9.1.  Description**

Range 헤더\(18.40절\)는 다양한 범위 형식을 허용합니다. 이러한 범위 형식에는 Accept-Range 헤더\(섹션 18.5\)에 사용되는 식별자도 필요합니다. 새로운 범위 형식이 등록될 수 있지만 상호 운용성이 더 어려워지므로 조정이 적용되어야 합니다.

---
#### **22.9.2.  Registration Rules**

등록은 사양 요구 정책 \[RFC5226\]을 따릅니다. 전문 검토자는 요청이 다음 요구 사항을 충족하는지 확인합니다.

o "range-ext" 정의를 충족하는 범위 형식의 ABNF 정의가 포함됩니다.

o "확장 형식" 정의에 따라 Accept-Ranges 헤더에 사용되는 범위 형식 식별자가 정의됩니다.

o 음수 척도를 사용할 때 범위를 처리하는 방법에 대한 규칙이 포함되어 있습니다.

o 등록을 위한 담당자가 기재되어 있습니다.

---
#### **22.9.3.  Registered Values**

레지스트리에는 Range 헤더 형식 식별자, 범위 형식 이름 및 참조가 포함되어 있습니다. 본 사양에서는 다음과 같은 값을 등록합니다.

```text
   npt:  Normal Play Time

   clock:  UTC Absolute Time format

   smpte:  SMPTE Timestamps

   smpte-30-drop:  SMPTE Timestamps 29.97 Frames/sec (30 Hz with Drop)

   smpte-25:  SMPTE Timestamps 25 Frames/sec
```

---
### **22.10.  Terminate-Reason Header**

Terminate-Reason 헤더\(섹션 18.52\)에는 확장을 위한 두 개의 레지스트리가 있습니다.

---
#### **22.10.1.  Redirect Reasons**

이 레지스트리에는 Terminate-Reason 헤더\(섹션 18.52\)에 포함될 수 있는 세션 종료 이유가 포함되어 있습니다. 등록은 전문가 검토 정책 \[RFC5226\]을 따릅니다. 전문 검토자는 등록 요청에 다음 정보가 포함되어 있는지 확인합니다.

o 값은 Terminate-Reason ABNF를 따릅니다. 즉, 토큰이어야 합니다.

o 사양은 클라이언트가 이러한 리디렉션 이유를 수신할 때 따라야 할 절차에 대한 정의를 제공합니다.

o 연락 담당자

이 사양은 세 가지 값을 등록합니다.

```text
   o  Session-Timeout

   o  Server-Admin

   o  Internal-Error
```

레지스트리에는 리디렉션 이유의 이름과 참조가 포함되어 있습니다.

---
#### **22.10.2.  Terminate-Reason Header Parameters**

이 레지스트리에는 이유 외에 Terminate-Reason 헤더\(섹션 18.52\)에 포함될 수 있는 매개 변수가 포함되어 있습니다. 등록은 사양 요구 정책 \[RFC5226\]에 따라 이루어집니다. 전문 검토자는 등록 요청에 다음이 포함되어 있는지 확인합니다.

o 매개변수 이름.

o RTSP 2.0에서 허용하는 구문을 따르는 매개변수

-  사양.

o 사양에 대한 참조.

o 연락 담당자.

이 사양은 다음을 등록합니다.

```text
   o  time

   o  user-msg
```

레지스트리에는 종료 이유 이름과 참조가 포함되어 있습니다.

---
### **22.11.  RTP-Info Header Parameters**
---
#### **22.11.1.  Description**

RTP-Info 헤더\(18.45절\)는 RTP 스트림의 특정 지점에 대한 정보가 포함된 하나 이상의 매개변수 값 쌍을 전달합니다. RTP 확장이나 새로운 용도에는 새로운 유형의 정보가 필요할 수 있습니다. 필요할 수 있는 RTP 정보는 충분히 일반적일 가능성이 높으며 상호 운용성을 극대화하기 위해 사양 요구 정책에 따라 신규 등록이 이루어집니다.

---
#### **22.11.2.  Registration Rules**

새로운 RTP-Info 값 등록은 사양 필수 \[RFC5226\] 정책을 따릅니다. 전문 심사자는 등록 요청에 다음 정보가 포함되어 있는지 확인합니다.

o "generic-param" 정의를 충족하는 ABNF 정의.

o 사양에 대한 참조.

o 등록을 위한 연락 담당자.

---
#### **22.11.3.  Registered Values**

이 사양은 다음 매개변수 값 쌍을 등록합니다.

```text
   o  url

   o  ssrc

   o  seq

   o  rtptime
```

레지스트리에는 매개변수 이름과 참조가 포함되어 있습니다.

---
### **22.12.  Seek-Style Policies**
---
#### **22.12.1.  Description**

탐색 스타일 정책은 미디어 콘텐츠 내 위치가 주어졌을 때 RTSP 에이전트가 미디어 콘텐츠에서 탐색하는 방법을 정의합니다. 새로운 탐색 정책이 등록될 수 있습니다. 그러나 이들 중 상당수가 구현을 상당히 복잡하게 만듭니다. 알 수 없는 정책의 영향은 서버가 알 수 없는 정책을 따르지 않고 대신 서버 기본 정책을 사용한다는 것입니다.

---
#### **22.12.2.  Registration Rules**

새로운 Seek-Style 정책 등록은 사양 요구 정책 \[RFC5226\]을 따릅니다. 전문 검토자는 등록 요청이 다음 요구 사항을 충족하는지 확인합니다.

o "Seek-S-value-ext" 정의를 충족하는 Seek-Style 정책 이름의 ABNF 정의가 있습니다.

o 간단한 설명이 포함되어 있습니다.

o 등록을 위한 연락 담당자를 나열합니다.

o 요청 및 응답에 어떤 헤더를 포함해야 하는지, 언제 전송해야 하는지, 서버-클라이언트 상태에 미치는 영향에 대한 설명이 포함됩니다.

---
#### **22.12.3.  Registered Values**

이 사양은 네 가지 값\(이름 - 간단한 설명\)을 등록합니다.

o RAP - 요청된 시작 위치 이전 또는 요청된 시작 위치에서 가장 가까운 무작위 액세스 포인트를 사용합니다.

o CoRAP - 조건부 랜덤 액세스 포인트는 RAP와 유사하지만 RAP가 현재 일시 중지 지점보다 요청된 시작 위치 이전에 더 가까운 경우에만 해당됩니다.

o First-Prior - First-Prior 정책은 요청된 시작 위치보다 먼저 재생 시간이 있는 미디어 장치로 전달을 시작합니다.

o 다음 - 제공된 시작 위치 이후의 다음 미디어 장치입니다.

레지스트리에는 Seek-Style 정책의 이름, 설명 및 참조가 포함되어 있습니다.

---
### **22.13.  Transport Header Registries**

전송 헤더\(18.54절\)에는 향후 확장 가능성이 있는 여러 매개변수가 포함되어 있습니다. 따라서 이에 대한 레지스트리는 아래에 정의되어 있습니다.

---
#### **22.13.1.  Transport Protocol Identifier**

전송 프로토콜 사양은 전송 프로토콜의 일부 조합을 나타내는 전송 프로토콜 식별자와 식별된 프로토콜 사양과 함께 사용하는 데 필요하거나 선택적인 전송 헤더 매개변수로 구성됩니다. 이 레지스트리에는 등록된 전송 프로토콜 식별자에 사용되는 식별자가 포함되어 있습니다.

매개변수 전송 프로토콜 식별자에 대한 등록은 사양 필수 정책 \[RFC5226\]을 따릅니다. 전문 검토자는 등록 요청이 다음 요구 사항을 충족하는지 확인합니다.

o 주소와 이메일이 있는 연락 담당자 또는 조직.

o "transport-id" 섹션 20.2.3의 ABNF 구문 정의를 따르는 값 정의.

o 등록된 값이 RTSP에서 사용되는 방법, 사용되는 기본 전송 프로토콜 및 필수 전송 헤더 매개변수를 설명하는 설명 텍스트입니다.

레지스트리에는 프로토콜 ID 문자열과 참조가 포함되어 있습니다.

이 사양은 다음 값을 등록합니다.

RTP/AVP: UDP를 통한 "최소 제어를 통한 오디오 및 비디오 회의용 RTP 프로필"\[RFC3551\]과 함께 미디어 전송을 위해 RTP \[RFC3550\] 프로토콜을 사용합니다. 사용법은 RFC 7826, 부록 C.1에 설명되어 있습니다.

RTP/AVP/UDP: RTP/AVP와 동일합니다.

RTP/AVPF: UDP를 통한 "RTCP 기반 피드백\(RTP/AVPF\)을 위한 확장 RTP 프로필"\[RFC4585\]과 함께 미디어 전송을 위해 RTP \[RFC3550\] 프로토콜을 사용합니다. 사용법은 RFC 7826, 부록 C.1에 설명되어 있습니다.

RTP/AVPF/UDP: RTP/AVPF와 동일합니다.

RTP/SAVP: UDP를 통한 "SRTP\(Secure Real-time Transport Protocol\)" \[RFC3711\]와 함께 미디어 전송을 위해 RTP \[RFC3550\] 프로토콜을 사용합니다. 사용법은 RFC 7826, 부록 C.1에 설명되어 있습니다.

RTP/SAVP/UDP: RTP/SAVP와 동일합니다.

RTP/SAVPF: UDP를 통한 "RTCP\(실시간 전송 제어 프로토콜\) 기반 피드백\(RTP/SAVPF\)을 위한 확장 보안 RTP 프로필"\[RFC5124\]과 함께 미디어 전송을 위해 RTP \[RFC3550\] 프로토콜을 사용합니다. 사용법은 RFC 7826, 부록 C.1에 설명되어 있습니다.

RTP/SAVPF/UDP: RTP/SAVPF와 동일합니다.

RTP/AVP/TCP: TCP를 통한 "최소 제어로 오디오 및 비디오 회의를 위한 RTP 프로필"\[RFC3551\]과 함께 미디어 전송을 위해 RTP \[RFC3550\] 프로토콜을 사용합니다. 사용법은 RFC 7826, 부록 C.2.2에 설명되어 있습니다.

RTP/AVPF/TCP: TCP를 통한 "RTCP\(실시간 전송 제어 프로토콜\) 기반 피드백\(RTP/AVPF\)용 확장 RTP 프로필"\[RFC4585\]과 함께 미디어 전송을 위한 RTP \[RFC3550\] 프로토콜을 사용합니다. 사용법은 RFC 7826, 부록 C.2.2에 설명되어 있습니다.

RTP/SAVP/TCP: TCP를 통한 "SRTP\(Secure Real-time Transport Protocol\)" \[RFC3711\]와 함께 미디어 전송을 위해 RTP \[RFC3550\] 프로토콜을 사용합니다. 사용법은 RFC 7826, 부록 C.2.2에 설명되어 있습니다.

RTP/SAVPF/TCP: TCP를 통한 "RTCP\(실시간 전송 제어 프로토콜\) 기반 피드백\(RTP/SAVPF\)용 확장 보안 RTP 프로필"\[RFC5124\]과 함께 미디어 전송을 위한 RTP \[RFC3550\] 프로토콜 사용 . 사용법은 RFC 7826, 부록 C.2.2에 설명되어 있습니다.

---
#### **22.13.2.  Transport Modes**

전송 모드는 전송 헤더\(섹션 18.54\) 매개변수입니다. 이는 미디어 전송의 일반적인 모드를 식별하는 데 사용됩니다. 등록된 PLAY 값은 미디어가 서버에서 클라이언트로 흐르는 PLAYBACK 모드를 정의합니다.

전송 매개변수 모드 등록은 표준 조치 정책 \[RFC5226\]을 따릅니다. 등록 요청은 다음 요구 사항을 충족해야 합니다.

o ABNF "토큰" 정의 섹션 20.2.3을 따르는 값 정의.

o 등록된 값이 RTSP에서 어떻게 사용되는지 설명하는 텍스트입니다.

이 사양은 하나의 값을 등록합니다.

```text
   PLAY: See RFC 7826.
```

레지스트리에는 전송 모드 값과 참조가 포함되어 있습니다.

---
#### **22.13.3.  Transport Parameters**

전송 매개변수는 기능적인 전송을 설정하기 위해 전송 프로토콜 식별자 외에 필요한 추가 정보를 제공하기 위해 전송 헤더의 전송 사양\(18.54절\)에 사용되는 다양한 매개변수입니다.

Transport 헤더에 포함될 수 있는 매개변수 등록은 사양 요구 정책 \[RFC5226\]을 따릅니다. 전문 검토자는 등록 요청이 다음 요구 사항을 충족하는지 확인합니다.

o "토큰" ABNF 정의 뒤에 오는 전송 매개변수 이름.

o 매개변수가 값을 취하는 경우 "trn-par-value" 섹션 20.2.3의 ABNF 정의를 따르는 값 정의.

o 등록된 값이 RTSP에서 어떻게 사용되는지 설명하는 텍스트입니다.

이 사양은 섹션 18.54에 정의된 모든 전송 매개변수를 등록합니다. 다음은 해당 목록의 사본입니다.

```text
   o  unicast

   o  multicast

   o  interleaved

   o  ttl

   o  layers

   o  ssrc

   o  mode

   o  dest_addr

   o  src_addr

   o  setup

   o  connection

   o  RTCP-mux

   o  MIKEY
```

레지스트리에는 전송 매개변수 이름과 참조가 포함되어 있습니다.

---
### **22.14.  URI Schemes**

이 사양은 두 개의 URI 체계를 업데이트합니다. 하나는 이전에 등록된 "rtsp"이고 다른 하나는 레지스트리에 누락된 "rtspu"입니다\(이전에는 RTSP 1.0 \[RFC2326\]에서만 정의됨\). 하나의 새로운 URI 체계인 "rtsps"도 등록되었습니다. 이러한 URI 체계는 이 메모에서 생성되지 않은 기존 레지스트리\("URI\(Uniform Resource Identifier\) ​​체계"\)에 등록되어 있습니다. 등록은 \[RFC7595\]를 따릅니다.

---
#### **22.14.1.  The "rtsp" URI Scheme**

```text
   URI scheme name:  rtsp

   Status:  Permanent
```

URI 체계 구문: RFC 7826의 섹션 20.2.1을 참조하세요.

URI 체계 의미: rtsp 체계는 RTSP\(실시간 스트리밍 프로토콜\)를 사용하여 액세스할 수 있는 리소스를 나타내는 데 사용됩니다. RTSP는 URI로 식별된 리소스에 대해 다양한 작업을 허용하지만 주요 목적은 리소스를 클라이언트에 스트리밍으로 전달하는 것입니다. 그러나 현재 정의된 작업은 DESCRIBE, GET\_PARAMETER, OPTIONS, PLAY, PLAY\_NOTIFY, PAUSE, REDIRECT, SETUP, SET\_PARAMETER 및 TEARDOWN입니다.

인코딩 고려 사항: 이 체계의 IRI는 정의되어 있으며 RTSP 내에서 사용될 때 RTSP URI로 인코딩되어야 합니다. 해당 인코딩은 RFC 3987에 따라 수행됩니다.

이 URI 체계 이름을 사용하는 애플리케이션/프로토콜: RTSP 1.0\(RFC 2326\), RTSP 2.0\(RFC 7826\).

상호 운용성 고려 사항: RTSP 1.0과 2.0 간에 수행되는 URI 구문의 확장으로 인해 상호 운용성 문제가 발생할 수 있습니다. 변경 사항은 다음과 같습니다.

- RFC 3986에 정의된 메커니즘을 통해 호스트 부분 및 향후 IP 리터럴에서 IPv6 리터럴을 지원합니다.

- "/"로 시작할 필요가 없는 RTSP 요소에 사용할 새로운 상대 형식입니다.

- 위의 변경 사항은 RFC 7826의 섹션 4.2에 자세히 설명된 상호 운용성에 영향을 미치지 않아야 합니다.

보안 고려 사항: RFC 3986의 섹션 7에서 식별된 모든 보안 위협은 이 체계에도 적용됩니다. 이 체계를 활용하는 모든 구현에서는 이를 검토하고 고려해야 합니다.

```text
   Contact:  Magnus Westerlund, magnus.westerlund@ericsson.com

   Author/Change controller:  IETF
```

참조: RFC 2326, RFC 3986, RFC 3987 및 RFC 7826

---
#### **22.14.2.  The "rtsps" URI Scheme**

```text
   URI scheme name:  rtsps

   Status:  Permanent
```

URI 체계 구문: RFC 7826의 섹션 20.2.1을 참조하세요.

URI 체계 의미: rtsps 체계는 TLS를 통한 RTSP\(Real-Time Streaming Protocol\) 사용을 통해 액세스 가능한 리소스를 나타내는 데 사용됩니다. RTSP는 URI로 식별된 리소스에 대해 다양한 작업을 허용하지만 주요 목적은 리소스를 클라이언트에 스트리밍으로 전달하는 것입니다. 그러나 현재 정의된 작업은 DESCRIBE, GET\_PARAMETER, OPTIONS, PLAY, PLAY\_NOTIFY, PAUSE, REDIRECT, SETUP, SET\_PARAMETER 및 TEARDOWN입니다.

인코딩 고려 사항: 이 체계의 IRI는 정의되어 있으며 RTSP 내에서 사용될 때 RTSP URI로 인코딩되어야 합니다. 해당 인코딩은 RFC 3987에 따라 수행됩니다.

이 URI 체계 이름을 사용하는 애플리케이션/프로토콜: RTSP 1.0\(RFC 2326\), RTSP 2.0\(RFC 7826\).

상호 운용성 고려 사항: "rtsps" 체계는 RTSP 1.0에 대해 공식적으로 정의된 적이 없습니다. 그러나 RTSP 1.0의 실제 배포에서는 널리 사용되었습니다. 따라서 이 섹션에서는 지정되지 않은 RTSP 1.0 "rtsps" 구성표와 RTSP 2.0 정의 사이의 변경 사항에 대해 논의합니다. RTSP 1.0과 2.0 사이에서 수행되는 URI 구문의 확장으로 인해 상호 운용성 문제가 발생할 수 있습니다. 변경 사항은 다음과 같습니다.

- RFC 3986에 정의된 메커니즘을 통해 호스트 부분 및 향후 IP 리터럴에서 IPv6 리터럴을 지원합니다.

- "/"로 시작할 필요가 없는 RTSP 요소에 사용할 새로운 상대 형식입니다.

- 위의 변경 사항은 RFC 7826의 섹션 4.2에 자세히 설명된 상호 운용성에 영향을 미치지 않아야 합니다.

보안 고려 사항: RFC 3986의 섹션 7에서 식별된 모든 보안 위협은 이 체계에도 적용됩니다. 이 체계를 활용하는 모든 구현에서는 이를 검토하고 고려해야 합니다.

```text
   Contact:  Magnus Westerlund, magnus.westerlund@ericsson.com

   Author/Change controller:  IETF
```

참조: RFC 2326, RFC 3986, RFC 3987 및 RFC 7826

---
#### **22.14.3.  The "rtspu" URI Scheme**

```text
   URI scheme name:  rtspu

   Status:  Permanent
```

URI 체계 구문: RFC 2326의 섹션 3.2를 참조하세요.

URI 체계 의미: rtspu 체계는 신뢰할 수 없는 데이터그램 전송을 통해 RTSP\(실시간 스트리밍 프로토콜\)를 사용하여 액세스할 수 있는 리소스를 나타내는 데 사용됩니다. RTSP는 URI로 식별된 리소스에 대해 다양한 작업을 허용하지만 주요 목적은 리소스를 클라이언트에 스트리밍으로 전달하는 것입니다. 그러나 현재 정의된 작업은 DESCRIBE, GET\_PARAMETER, OPTIONS, REDIRECT,PLAY, PLAY\_NOTIFY, PAUSE, SETUP, SET\_PARAMETER 및 TEARDOWN입니다.

인코딩 고려사항: 이 체계는 US-ASCII 레퍼토리 외부의 문자와 함께 사용하기 위한 것이 아닙니다.

이 URI 체계 이름을 사용하는 애플리케이션/프로토콜: RTSP 1.0\(RFC 2326\).

상호 운용성 고려 사항: UDP를 통한 RTSP 전송 메커니즘 정의에는 상호 운용성 문제가 있습니다. 이로 인해 이 체계를 사용하는 데 문제가 발생합니다.

보안 고려 사항: RFC 3986의 섹션 7에서 식별된 모든 보안 위협은 이 체계에도 적용됩니다. 이 체계를 활용하는 모든 구현에서는 이를 검토하고 고려해야 합니다.

```text
   Contact:  Magnus Westerlund, magnus.westerlund@ericsson.com

   Author/Change controller:  IETF

   References:  RFC 2326
```

---
### **22.15.  SDP Attributes**

이 사양은 IANA에 등록된 세 가지 SDP \[RFC4566\] 속성을 정의합니다.

```text
   SDP Attribute ("att-field"):
```

속성 이름: 범위

- 긴 형식: 미디어 범위 속성 이름 유형: att-field 속성 유형: 세션 및 미디어 레벨 모두 대상 문자 집합: 아니요 목적: RFC 7826 참조: RFC 2326, RFC 7826 값: ABNF 정의를 참조하세요.

속성 이름: 제어

- 긴 형식: RTSP 제어 URI 이름 유형: att-field 속성 유형: 세션 및 미디어 수준 모두 문자 세트 대상: 아니요 목적: RFC 7826 참조: RFC 2326, RFC 7826 값: 절대 또는 상대 URI.

```text
        Attribute name:     mtag
        Long form:          Message Tag
        Type of name:       att-field
        Type of attribute:  both session and media level
        Subject to charset: No
        Purpose:            RFC 7826
        Reference:          RFC 7826
        Values:             See ABNF definition
```

---
### **22.16.  Media Type Registration for text/parameters**

```text
   Type name:  text

   Subtype name:  parameters

   Required parameters:
```

선택 매개변수: charset: charset 매개변수는 매개변수 값의 인코딩에 적용 가능합니다. 'charset' 매개변수가 없는 경우 기본 문자 세트는 UTF-8입니다.

```text
   Encoding considerations:  8bit
```

보안 고려 사항: 이 형식은 모든 유형의 정보를 전달할 수 있습니다.

- 매개변수. 일부에는 개인 정보 보호, 기밀성 또는 무결성 요구 사항과 같은 보안 요구 사항이 있을 수 있습니다. 이 형식에는 보안 보호 기능이 내장되어 있지 않습니다. 사용을 위해 TLS를 사용하여 서버와 클라이언트 간의 전송을 보호할 수 있습니다. 그러나 hop-by-hop 보안이 사용되는 경우 매개변수를 사용하여 프록시도 신뢰할 수 있는지 고려해야 합니다. 파일 시스템에 파일로 저장하는 경우 S/MIME \[RFC5751\]과 같은 객체 보안을 포함한 매개변수 요구 사항과 관련하여 필요한 예방 조치를 취해야 합니다.

상호 운용성 고려 사항: 이 미디어 유형은 \[RFC2326\]에서 가상의 예로 언급되었지만 공식적으로 지정되지는 않았습니다. 이로 인해 공식적인 정의와 일치하지 않는 미디어 유형이 사용되었습니다.

```text
   Published specification:  RFC 7826, Appendix F.
```

이 미디어 유형을 사용하는 애플리케이션: RTSP를 사용하고 RTSP GET\_PARAMETER 및 SET\_PARAMETER 메서드를 사용하여 읽고 설정하기를 좋아하는 추가 매개변수가 있는 애플리케이션입니다.

```text
   Additional information:

   Magic number(s):  N/A

   File extension(s):  N/A

   Macintosh file type code(s):  N/A

   Person & email address to contact for further information:
      Magnus Westerlund (magnus.westerlund@ericsson.com)

   Intended usage:   Common
```

이용제한 : 없음

```text
   Author:  Magnus Westerlund (magnus.westerlund@ericsson.com)

   Change controller:  IETF

   Addition Notes:
```

---
## **23.  References**
---
### **23.1.  Normative References**

```text
   [FIPS180-4]
              National Institute of Standards and Technology (NIST),
              "Federal Information Processing Standards Publication:
              Secure Hash Standard (SHS)", DOI 10.6028/NIST.FIPS.180-4,
              August 2015, <http://nvlpubs.nist.gov/nistpubs/FIPS/
              NIST.FIPS.180-4.pdf>.

   [RFC768]   Postel, J., "User Datagram Protocol", STD 6, RFC 768,
              DOI 10.17487/RFC0768, August 1980,
              <http://www.rfc-editor.org/info/rfc768>.

   [RFC793]   Postel, J., "Transmission Control Protocol", STD 7,
              RFC 793, DOI 10.17487/RFC0793, September 1981,
              <http://www.rfc-editor.org/info/rfc793>.

   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", BCP 14, RFC 2119,
              DOI 10.17487/RFC2119, March 1997,
              <http://www.rfc-editor.org/info/rfc2119>.

   [RFC2460]  Deering, S. and R. Hinden, "Internet Protocol, Version 6
              (IPv6) Specification", RFC 2460, DOI 10.17487/RFC2460,
              December 1998, <http://www.rfc-editor.org/info/rfc2460>.

   [RFC2616]  Fielding, R., Gettys, J., Mogul, J., Frystyk, H.,
              Masinter, L., Leach, P., and T. Berners-Lee, "Hypertext
              Transfer Protocol -- HTTP/1.1", RFC 2616,
              DOI 10.17487/RFC2616, June 1999,
              <http://www.rfc-editor.org/info/rfc2616>.

   [RFC2617]  Franks, J., Hallam-Baker, P., Hostetler, J., Lawrence, S.,
              Leach, P., Luotonen, A., and L. Stewart, "HTTP
              Authentication: Basic and Digest Access Authentication",
              RFC 2617, DOI 10.17487/RFC2617, June 1999,
              <http://www.rfc-editor.org/info/rfc2617>.

   [RFC2818]  Rescorla, E., "HTTP Over TLS", RFC 2818,
              DOI 10.17487/RFC2818, May 2000,
              <http://www.rfc-editor.org/info/rfc2818>.

   [RFC3550]  Schulzrinne, H., Casner, S., Frederick, R., and V.
              Jacobson, "RTP: A Transport Protocol for Real-Time
              Applications", STD 64, RFC 3550, DOI 10.17487/RFC3550,
              July 2003, <http://www.rfc-editor.org/info/rfc3550>.

   [RFC3551]  Schulzrinne, H. and S. Casner, "RTP Profile for Audio and
              Video Conferences with Minimal Control", STD 65, RFC 3551,
              DOI 10.17487/RFC3551, July 2003,
              <http://www.rfc-editor.org/info/rfc3551>.

   [RFC3629]  Yergeau, F., "UTF-8, a transformation format of ISO
              10646", STD 63, RFC 3629, DOI 10.17487/RFC3629, November
              2003, <http://www.rfc-editor.org/info/rfc3629>.

   [RFC3711]  Baugher, M., McGrew, D., Naslund, M., Carrara, E., and K.
              Norrman, "The Secure Real-time Transport Protocol (SRTP)",
              RFC 3711, DOI 10.17487/RFC3711, March 2004,
              <http://www.rfc-editor.org/info/rfc3711>.

   [RFC3830]  Arkko, J., Carrara, E., Lindholm, F., Naslund, M., and K.
              Norrman, "MIKEY: Multimedia Internet KEYing", RFC 3830,
              DOI 10.17487/RFC3830, August 2004,
              <http://www.rfc-editor.org/info/rfc3830>.

   [RFC3986]  Berners-Lee, T., Fielding, R., and L. Masinter, "Uniform
              Resource Identifier (URI): Generic Syntax", STD 66,
              RFC 3986, DOI 10.17487/RFC3986, January 2005,
              <http://www.rfc-editor.org/info/rfc3986>.

   [RFC3987]  Duerst, M. and M. Suignard, "Internationalized Resource
              Identifiers (IRIs)", RFC 3987, DOI 10.17487/RFC3987,
              January 2005, <http://www.rfc-editor.org/info/rfc3987>.

   [RFC4086]  Eastlake 3rd, D., Schiller, J., and S. Crocker,
              "Randomness Requirements for Security", BCP 106, RFC 4086,
              DOI 10.17487/RFC4086, June 2005,
              <http://www.rfc-editor.org/info/rfc4086>.

   [RFC4291]  Hinden, R. and S. Deering, "IP Version 6 Addressing
              Architecture", RFC 4291, DOI 10.17487/RFC4291, February
              2006, <http://www.rfc-editor.org/info/rfc4291>.

   [RFC7595]  Thaler, D., Ed., Hansen, T., and T. Hardie, "Guidelines
              and Registration Procedures for URI Schemes", BCP 35, RFC
              7595, DOI 10.17487/RFC7595, June 2015, <http://www.rfc-
              editor.org/info/rfc7595>.

   [RFC4566]  Handley, M., Jacobson, V., and C. Perkins, "SDP: Session
              Description Protocol", RFC 4566, DOI 10.17487/RFC4566,
              July 2006, <http://www.rfc-editor.org/info/rfc4566>.

   [RFC4571]  Lazzaro, J., "Framing Real-time Transport Protocol (RTP)
              and RTP Control Protocol (RTCP) Packets over Connection-
              Oriented Transport", RFC 4571, DOI 10.17487/RFC4571, July
              2006, <http://www.rfc-editor.org/info/rfc4571>.

   [RFC4585]  Ott, J., Wenger, S., Sato, N., Burmeister, C., and J. Rey,
              "Extended RTP Profile for Real-time Transport Control
              Protocol (RTCP)-Based Feedback (RTP/AVPF)", RFC 4585,
              DOI 10.17487/RFC4585, July 2006,
              <http://www.rfc-editor.org/info/rfc4585>.

   [RFC4648]  Josefsson, S., "The Base16, Base32, and Base64 Data
              Encodings", RFC 4648, DOI 10.17487/RFC4648, October 2006,
              <http://www.rfc-editor.org/info/rfc4648>.

   [RFC4738]  Ignjatic, D., Dondeti, L., Audet, F., and P. Lin, "MIKEY-
              RSA-R: An Additional Mode of Key Distribution in
              Multimedia Internet KEYing (MIKEY)", RFC 4738,
              DOI 10.17487/RFC4738, November 2006,
              <http://www.rfc-editor.org/info/rfc4738>.

   [RFC5124]  Ott, J. and E. Carrara, "Extended Secure RTP Profile for
              Real-time Transport Control Protocol (RTCP)-Based Feedback
              (RTP/SAVPF)", RFC 5124, DOI 10.17487/RFC5124, February
              2008, <http://www.rfc-editor.org/info/rfc5124>.

   [RFC5226]  Narten, T. and H. Alvestrand, "Guidelines for Writing an
              IANA Considerations Section in RFCs", BCP 26, RFC 5226,
              DOI 10.17487/RFC5226, May 2008,
              <http://www.rfc-editor.org/info/rfc5226>.

   [RFC5234]  Crocker, D., Ed. and P. Overell, "Augmented BNF for Syntax
              Specifications: ABNF", STD 68, RFC 5234,
              DOI 10.17487/RFC5234, January 2008,
              <http://www.rfc-editor.org/info/rfc5234>.

   [RFC5246]  Dierks, T. and E. Rescorla, "The Transport Layer Security
              (TLS) Protocol Version 1.2", RFC 5246,
              DOI 10.17487/RFC5246, August 2008,
              <http://www.rfc-editor.org/info/rfc5246>.

   [RFC5280]  Cooper, D., Santesson, S., Farrell, S., Boeyen, S.,
              Housley, R., and W. Polk, "Internet X.509 Public Key
              Infrastructure Certificate and Certificate Revocation List
              (CRL) Profile", RFC 5280, DOI 10.17487/RFC5280, May 2008,
              <http://www.rfc-editor.org/info/rfc5280>.

   [RFC5322]  Resnick, P., Ed., "Internet Message Format", RFC 5322,
              DOI 10.17487/RFC5322, October 2008,
              <http://www.rfc-editor.org/info/rfc5322>.

   [RFC5646]  Phillips, A., Ed. and M. Davis, Ed., "Tags for Identifying
              Languages", BCP 47, RFC 5646, DOI 10.17487/RFC5646,
              September 2009, <http://www.rfc-editor.org/info/rfc5646>.

   [RFC5751]  Ramsdell, B. and S. Turner, "Secure/Multipurpose Internet
              Mail Extensions (S/MIME) Version 3.2 Message
              Specification", RFC 5751, DOI 10.17487/RFC5751, January
              2010, <http://www.rfc-editor.org/info/rfc5751>.

   [RFC5761]  Perkins, C. and M. Westerlund, "Multiplexing RTP Data and
              Control Packets on a Single Port", RFC 5761,
              DOI 10.17487/RFC5761, April 2010,
              <http://www.rfc-editor.org/info/rfc5761>.

   [RFC5888]  Camarillo, G. and H. Schulzrinne, "The Session Description
              Protocol (SDP) Grouping Framework", RFC 5888,
              DOI 10.17487/RFC5888, June 2010,
              <http://www.rfc-editor.org/info/rfc5888>.

   [RFC6838]  Freed, N., Klensin, J., and T. Hansen, "Media Type
              Specifications and Registration Procedures", BCP 13,
              RFC 6838, DOI 10.17487/RFC6838, January 2013,
              <http://www.rfc-editor.org/info/rfc6838>.

   [RFC7230]  Fielding, R., Ed. and J. Reschke, Ed., "Hypertext Transfer
              Protocol (HTTP/1.1): Message Syntax and Routing",
              RFC 7230, DOI 10.17487/RFC7230, June 2014,
              <http://www.rfc-editor.org/info/rfc7230>.

   [RFC7231]  Fielding, R., Ed. and J. Reschke, Ed., "Hypertext Transfer
              Protocol (HTTP/1.1): Semantics and Content", RFC 7231,
              DOI 10.17487/RFC7231, June 2014,
              <http://www.rfc-editor.org/info/rfc7231>.

   [RFC7232]  Fielding, R., Ed. and J. Reschke, Ed., "Hypertext Transfer
              Protocol (HTTP/1.1): Conditional Requests", RFC 7232,
              DOI 10.17487/RFC7232, June 2014,
              <http://www.rfc-editor.org/info/rfc7232>.

   [RFC7233]  Fielding, R., Ed., Lafon, Y., Ed., and J. Reschke, Ed.,
              "Hypertext Transfer Protocol (HTTP/1.1): Range Requests",
              RFC 7233, DOI 10.17487/RFC7233, June 2014,
              <http://www.rfc-editor.org/info/rfc7233>.

   [RFC7234]  Fielding, R., Ed., Nottingham, M., Ed., and J. Reschke,
              Ed., "Hypertext Transfer Protocol (HTTP/1.1): Caching",
              RFC 7234, DOI 10.17487/RFC7234, June 2014,
              <http://www.rfc-editor.org/info/rfc7234>.

   [RFC7235]  Fielding, R., Ed. and J. Reschke, Ed., "Hypertext Transfer
              Protocol (HTTP/1.1): Authentication", RFC 7235,
              DOI 10.17487/RFC7235, June 2014,
              <http://www.rfc-editor.org/info/rfc7235>.

   [RFC7615]  Reschke, J., "HTTP Authentication-Info and Proxy-
              Authentication-Info Response Header Fields", RFC 7615,
              DOI 10.17487/RFC7615, September 2015,
              <http://www.rfc-editor.org/info/rfc7615>.

   [RFC7616]  Shekh-Yusef, R., Ed., Ahrens, D., and S. Bremer, "HTTP
              Digest Access Authentication", RFC 7616,
              DOI 10.17487/RFC7616, September 2015,
              <http://www.rfc-editor.org/info/rfc7616>.

   [RFC7617]  Reschke, J., "The 'Basic' HTTP Authentication Scheme",
              RFC 7617, DOI 10.17487/RFC7617, September 2015,
              <http://www.rfc-editor.org/info/rfc7617>.

   [RFC7825]  Goldberg, J., Westerlund, M., and T. Zeng, "A Network
              Address Translator (NAT) Traversal Mechanism for Media
              Controlled by Real-Time Streaming Protocol (RTSP)",
              RFC 7825, DOI 10.17487/RFC7825, December 2016,
              <http://www.rfc-editor.org/info/rfc7825>.
```

\[RTP-회로 차단기\]

- Perkins, C. 및 V. Singh, "멀티미디어 혼잡 제어: 유니캐스트 RTP 세션용 회로 차단기", 진행 중인 작업, 초안-ietf-avtcore-rtp-circuit-breakers-13, 2016년 2월.

```text
   [SMPTE-TC] Society of Motion Picture and Television Engineers, "ST
              12-1:2008 For Television -- Time and Control Code",
              DOI 10.5594/SMPTE.ST12-1.2008, February 2008,
              <http://ieeexplore.ieee.org/servlet/
              opac?punumber=7289818>.

   [TS-26234] 3rd Generation Partnership Project (3GPP), "Transparent
              end-to-end Packet-switched Streaming Service (PSS);
              Protocols and codecs", Technical Specification 26.234,
              Release 13, September 2015,
              <http://www.3gpp.org/DynaReport/26234.htm>.
```

---
### **23.2.  Informative References**

```text
   [ISO.13818-6.1995]
              International Organization for Standardization,
              "Information technology -- Generic coding of moving
              pictures and associated audio information - part 6:
              Extension for DSM-CC", ISO Draft Standard 13818-6:1998,
              October 1998,
              <http://www.iso.org/iso/home/store/catalogue_tc/
              catalogue_detail.htm?csnumber=25039>.
```

\[ISO.8601.2000\]

- 국제 표준화 기구, "데이터 요소 및 교환 형식 - 정보 교환 - 날짜 및 시간 표현", ISO/IEC 표준 8601, 2000년 12월.

```text
   [RFC791]   Postel, J., "Internet Protocol", STD 5, RFC 791,
              DOI 10.17487/RFC0791, September 1981,
              <http://www.rfc-editor.org/info/rfc791>.

   [RFC1123]  Braden, R., Ed., "Requirements for Internet Hosts -
              Application and Support", STD 3, RFC 1123,
              DOI 10.17487/RFC1123, October 1989,
              <http://www.rfc-editor.org/info/rfc1123>.

   [RFC2068]  Fielding, R., Gettys, J., Mogul, J., Frystyk, H., and T.
              Berners-Lee, "Hypertext Transfer Protocol -- HTTP/1.1",
              RFC 2068, DOI 10.17487/RFC2068, January 1997,
              <http://www.rfc-editor.org/info/rfc2068>.

   [RFC2326]  Schulzrinne, H., Rao, A., and R. Lanphier, "Real Time
              Streaming Protocol (RTSP)", RFC 2326,
              DOI 10.17487/RFC2326, April 1998,
              <http://www.rfc-editor.org/info/rfc2326>.

   [RFC2663]  Srisuresh, P. and M. Holdrege, "IP Network Address
              Translator (NAT) Terminology and Considerations",
              RFC 2663, DOI 10.17487/RFC2663, August 1999,
              <http://www.rfc-editor.org/info/rfc2663>.

   [RFC2974]  Handley, M., Perkins, C., and E. Whelan, "Session
              Announcement Protocol", RFC 2974, DOI 10.17487/RFC2974,
              October 2000, <http://www.rfc-editor.org/info/rfc2974>.

   [RFC3261]  Rosenberg, J., Schulzrinne, H., Camarillo, G., Johnston,
              A., Peterson, J., Sparks, R., Handley, M., and E.
              Schooler, "SIP: Session Initiation Protocol", RFC 3261,
              DOI 10.17487/RFC3261, June 2002,
              <http://www.rfc-editor.org/info/rfc3261>.

   [RFC3264]  Rosenberg, J. and H. Schulzrinne, "An Offer/Answer Model
              with Session Description Protocol (SDP)", RFC 3264,
              DOI 10.17487/RFC3264, June 2002,
              <http://www.rfc-editor.org/info/rfc3264>.

   [RFC3339]  Klyne, G. and C. Newman, "Date and Time on the Internet:
              Timestamps", RFC 3339, DOI 10.17487/RFC3339, July 2002,
              <http://www.rfc-editor.org/info/rfc3339>.

   [RFC4145]  Yon, D. and G. Camarillo, "TCP-Based Media Transport in
              the Session Description Protocol (SDP)", RFC 4145,
              DOI 10.17487/RFC4145, September 2005,
              <http://www.rfc-editor.org/info/rfc4145>.

   [RFC4567]  Arkko, J., Lindholm, F., Naslund, M., Norrman, K., and E.
              Carrara, "Key Management Extensions for Session
              Description Protocol (SDP) and Real Time Streaming
              Protocol (RTSP)", RFC 4567, DOI 10.17487/RFC4567, July
              2006, <http://www.rfc-editor.org/info/rfc4567>.

   [RFC4588]  Rey, J., Leon, D., Miyazaki, A., Varsa, V., and R.
              Hakenberg, "RTP Retransmission Payload Format", RFC 4588,
              DOI 10.17487/RFC4588, July 2006,
              <http://www.rfc-editor.org/info/rfc4588>.

   [RFC4855]  Casner, S., "Media Type Registration of RTP Payload
              Formats", RFC 4855, DOI 10.17487/RFC4855, February 2007,
              <http://www.rfc-editor.org/info/rfc4855>.

   [RFC4856]  Casner, S., "Media Type Registration of Payload Formats in
              the RTP Profile for Audio and Video Conferences",
              RFC 4856, DOI 10.17487/RFC4856, February 2007,
              <http://www.rfc-editor.org/info/rfc4856>.

   [RFC5104]  Wenger, S., Chandra, U., Westerlund, M., and B. Burman,
              "Codec Control Messages in the RTP Audio-Visual Profile
              with Feedback (AVPF)", RFC 5104, DOI 10.17487/RFC5104,
              February 2008, <http://www.rfc-editor.org/info/rfc5104>.

   [RFC5245]  Rosenberg, J., "Interactive Connectivity Establishment
              (ICE): A Protocol for Network Address Translator (NAT)
              Traversal for Offer/Answer Protocols", RFC 5245,
              DOI 10.17487/RFC5245, April 2010,
              <http://www.rfc-editor.org/info/rfc5245>.

   [RFC5389]  Rosenberg, J., Mahy, R., Matthews, P., and D. Wing,
              "Session Traversal Utilities for NAT (STUN)", RFC 5389,
              DOI 10.17487/RFC5389, October 2008,
              <http://www.rfc-editor.org/info/rfc5389>.

   [RFC5583]  Schierl, T. and S. Wenger, "Signaling Media Decoding
              Dependency in the Session Description Protocol (SDP)",
              RFC 5583, DOI 10.17487/RFC5583, July 2009,
              <http://www.rfc-editor.org/info/rfc5583>.

   [RFC5905]  Mills, D., Martin, J., Ed., Burbank, J., and W. Kasch,
              "Network Time Protocol Version 4: Protocol and Algorithms
              Specification", RFC 5905, DOI 10.17487/RFC5905, June 2010,
              <http://www.rfc-editor.org/info/rfc5905>.

   [RFC6298]  Paxson, V., Allman, M., Chu, J., and M. Sargent,
              "Computing TCP's Retransmission Timer", RFC 6298,
              DOI 10.17487/RFC6298, June 2011,
              <http://www.rfc-editor.org/info/rfc6298>.
```

\[스티븐스98\]

- Stevens, W., Fenner, B. 및 A. Rudoff, "유닉스 네트워킹 프로그래밍, 1권: 소켓 네트워킹 API\(3판\)", 1998.

---
# **Appendix A.  Examples**

이 섹션에는 RTSP를 사용하는 가능한 방법을 설명하기 위한 여러 가지 예가 포함되어 있습니다. 예제는 RTSP의 기능 작동 방식을 이해하는 데도 도움이 될 수 있습니다. 그러나 이는 예시일 뿐이며 다른 섹션의 규범 및 구문 설명이 우선한다는 점을 기억하세요. 또한 많은 예제가 여러 줄로 나누어져 있으며, 다음 줄은 구문에서 허용하는 대로 공백으로 시작됩니다.

---
### **A.1.  Media on Demand (Unicast)**

이는 컨테이너 파일에 저장된 미디어의 주문형 미디어 스트리밍의 예입니다. 이 예의 목적에 따라 컨테이너 파일은 동일한 최종 사용자 프리젠테이션과 관련된 여러 연속 미디어 유형이 존재하는 저장 엔터티입니다. 실제로 컨테이너 파일은 RTSP로 제어되는 미디어 스트림인 각 구성 요소를 포함하는 RTSP 프레젠테이션을 나타냅니다. 컨테이너 파일은 이러한 프레젠테이션을 저장하는 데 널리 사용되는 수단입니다. 구성 요소는 독립적인 스트림으로 전송되지만 서버 측에서는 해당 스트림에 대한 공통 컨텍스트를 유지하는 것이 바람직합니다.

- 이를 통해 서버는 단일 저장소 핸들을 쉽게 열어 둘 수 있습니다. 또한 서버에서 스트림 우선순위를 지정하는 경우 모든 스트림을 동일하게 처리할 수 있습니다.

프리젠테이션 작성자는 결합된 미디어 프리젠테이션의 예술적 효과를 보존하기 위해 클라이언트가 스트림을 선택적으로 검색하는 것을 방지하기를 원할 수도 있습니다. 마찬가지로, 이렇게 긴밀하게 바인딩된 프레젠테이션에서는 집계 URI를 사용하는 단일 제어 메시지를 통해 모든 스트림을 제어할 수 있는 것이 바람직합니다.

다음은 단일 RTSP 세션을 사용하여 여러 스트림을 제어하는 ​​예입니다. 또한 집계 URI의 사용을 보여줍니다. 컨테이너 파일에서는 호스트나 대부분의 경로 요소처럼 컨테이너가 배포될 때 유지되지 않는 URI 부분을 작성하지 않는 것이 바람직합니다. 따라서 이 예에서는 전달된 SDP에서 "\*" 및 상대 URI도 사용합니다.

또한 Expires 헤더는 유효 기간의 즉각적인 만료를 나타내는 날짜와 동일한 값으로 설정되므로 이 SDP\(프레젠테이션 설명\)는 캐시할 수 없습니다.

클라이언트 C는 미디어 서버 M에 프레젠테이션을 요청합니다. 동영상은 컨테이너 파일에 저장됩니다. 클라이언트가 컨테이너 파일에 대한 RTSP URI를 얻었습니다.

```text
   C->M: DESCRIBE rtsp://example.com/twister.3gp RTSP/2.0
         CSeq: 1
         User-Agent: PhonyClient/1.2

   M->C: RTSP/2.0 200 OK
         CSeq: 1
         Server: PhonyServer/1.0
         Date: Fri, 20 Dec 2013 10:20:32 +0000
         Content-Type: application/sdp
         Content-Length: 271
         Content-Base: rtsp://example.com/twister.3gp/
         Expires: Fri, 20 Dec 2013 12:20:32 +0000
```

v=0

- o=- 2890844256 2890842807 IN IP4 198.51.100.5 s=RTSP 세션 i=RTSP 세션 사용 예 e=adm@example.com c=IN IP4 0.0.0.0 a=control: \* a=range:npt=00: 00:00-00:10:34.10 t=0 0 m=오디오 0 RTP/AVP 0 a=컨트롤: trackID=1 m=비디오 0 RTP/AVP 26 a=컨트롤: trackID=4

```text
   C->M: SETUP rtsp://example.com/twister.3gp/trackID=1 RTSP/2.0
         CSeq: 2
         User-Agent: PhonyClient/1.2
         Require: play.basic
         Transport: RTP/AVP;unicast;dest_addr=":8000"/":8001"
         Accept-Ranges: npt, smpte, clock

   M->C: RTSP/2.0 200 OK
         CSeq: 2
         Server: PhonyServer/1.0
         Transport: RTP/AVP;unicast; ssrc=93CB001E;
                    dest_addr="192.0.2.53:8000"/"192.0.2.53:8001";
                    src_addr="198.51.100.5:9000"/"198.51.100.5:9001"
         Session: OccldOFFq23KwjYpAnBbUr
         Expires: Fri, 20 Dec 2013 12:20:33 +0000
         Date: Fri, 20 Dec 2013 10:20:33 +0000
         Accept-Ranges: npt
         Media-Properties: Random-Access=0.02, Immutable, Unlimited

   C->M: SETUP rtsp://example.com/twister.3gp/trackID=4 RTSP/2.0
         CSeq: 3
         User-Agent: PhonyClient/1.2
         Require: play.basic
         Transport: RTP/AVP;unicast;dest_addr=":8002"/":8003"
         Session: OccldOFFq23KwjYpAnBbUr
         Accept-Ranges: npt, smpte, clock

   M->C: RTSP/2.0 200 OK
         CSeq: 3
         Server: PhonyServer/1.0
         Transport: RTP/AVP;unicast; ssrc=A813FC13;
                    dest_addr="192.0.2.53:8002"/"192.0.2.53:8003";
                    src_addr="198.51.100.5:9002"/"198.51.100.5:9003";

         Session: OccldOFFq23KwjYpAnBbUr
         Expires: Fri, 20 Dec 2013 12:20:33 +0000
         Date: Fri, 20 Dec 2013 10:20:33 +0000
         Accept-Range: NPT
         Media-Properties: Random-Access=0.8, Immutable, Unlimited

   C->M: PLAY rtsp://example.com/twister.3gp/ RTSP/2.0
         CSeq: 4
         User-Agent: PhonyClient/1.2
         Range: npt=30-
         Seek-Style: RAP
         Session: OccldOFFq23KwjYpAnBbUr

   M->C: RTSP/2.0 200 OK
         CSeq: 4
         Server: PhonyServer/1.0
         Date: Fri, 20 Dec 2013 10:20:34 +0000
         Session: OccldOFFq23KwjYpAnBbUr
         Range: npt=30-634.10
         Seek-Style: RAP
         RTP-Info: url="rtsp://example.com/twister.3gp/trackID=4"
            ssrc=0D12F123:seq=12345;rtptime=3450012,
           url="rtsp://example.com/twister.3gp/trackID=1"
            ssrc=4F312DD8:seq=54321;rtptime=2876889

   C->M: PAUSE rtsp://example.com/twister.3gp/ RTSP/2.0
         CSeq: 5
         User-Agent: PhonyClient/1.2
         Session: OccldOFFq23KwjYpAnBbUr

   # Pause happens 0.87 seconds after starting to play

   M->C: RTSP/2.0 200 OK
         CSeq: 5
         Server: PhonyServer/1.0
         Date: Fri, 20 Dec 2013 10:20:35 +0000
         Session: OccldOFFq23KwjYpAnBbUr
         Range: npt=30.87-634.10

   C->M: PLAY rtsp://example.com/twister.3gp/ RTSP/2.0
         CSeq: 6
         User-Agent: PhonyClient/1.2
         Range: npt=30.87-634.10
         Seek-Style: Next
         Session: OccldOFFq23KwjYpAnBbUr

   M->C: RTSP/2.0 200 OK
         CSeq: 6
         Server: PhonyServer/1.0
         Date: Fri, 20 Dec 2013 10:22:13 +0000
         Session: OccldOFFq23KwjYpAnBbUr
         Range: npt=30.87-634.10
         Seek-Style: Next
         RTP-Info: url="rtsp://example.com/twister.3gp/trackID=4"
            ssrc=0D12F123:seq=12555;rtptime=6330012,
           url="rtsp://example.com/twister.3gp/trackID=1"
            ssrc=4F312DD8:seq=55021;rtptime=3132889

   C->M: TEARDOWN rtsp://example.com/twister.3gp/ RTSP/2.0
         CSeq: 7
         User-Agent: PhonyClient/1.2
         Session: OccldOFFq23KwjYpAnBbUr

   M->C: RTSP/2.0 200 OK
         CSeq: 7
         Server: PhonyServer/1.0
         Date: Fri, 20 Dec 2013 10:31:53 +0000
```

---
### **A.2.  Media on Demand Using Pipelining**

이 예는 기본적으로 위의 예\(부록 A.1\)이지만 이제 파이프라이닝을 활용하여 설정 속도를 높입니다. 미디어가 흐르기 시작할 때까지 두 번의 왕복 시간만 필요합니다. 우선, 어떤 미디어 리소스를 설정해야 하는지 결정하기 위해 세션 설명을 검색합니다. 두 번째 단계에서는 필요한 SETUP 요청과 PLAY 요청을 보내 미디어 전달을 시작합니다.

클라이언트 C는 미디어 서버 M에 프레젠테이션을 요청합니다. 동영상은 컨테이너 파일에 저장됩니다. 클라이언트가 컨테이너 파일에 대한 RTSP URI를 얻었습니다.

```text
   C->M: DESCRIBE rtsp://example.com/twister.3gp RTSP/2.0
         CSeq: 1
         User-Agent: PhonyClient/1.2

   M->C: RTSP/2.0 200 OK
         CSeq: 1
         Server: PhonyServer/1.0
         Date: Fri, 20 Dec 2013 10:20:32 +0000
         Content-Type: application/sdp
         Content-Length: 271
         Content-Base: rtsp://example.com/twister.3gp/
         Expires: Fri, 20 Dec 2013 12:20:32 +0000
```

v=0

- o=- 2890844256 2890842807 IN IP4 192.0.2.5 s=RTSP 세션 i=RTSP 세션 사용 예 e=adm@example.com c=IN IP4 0.0.0.0 a=control: \* a=range:npt=00: 00:00-00:10:34.10 t=0 0 m=오디오 0 RTP/AVP 0 a=컨트롤: trackID=1 m=비디오 0 RTP/AVP 26 a=컨트롤: trackID=4

```text
   C->M: SETUP rtsp://example.com/twister.3gp/trackID=1 RTSP/2.0
         CSeq: 2
         User-Agent: PhonyClient/1.2
         Require: play.basic
         Transport: RTP/AVP;unicast;dest_addr=":8000"/":8001"
         Accept-Ranges: npt, smpte, clock
         Pipelined-Requests: 7654

   C->M: SETUP rtsp://example.com/twister.3gp/trackID=4 RTSP/2.0
         CSeq: 3
         User-Agent: PhonyClient/1.2
         Require: play.basic
         Transport: RTP/AVP;unicast;dest_addr=":8002"/":8003"
         Accept-Ranges: npt, smpte, clock
         Pipelined-Requests: 7654

   C->M: PLAY rtsp://example.com/twister.3gp/ RTSP/2.0
         CSeq: 4
         User-Agent: PhonyClient/1.2
         Range: npt=0-
         Seek-Style: RAP
         Pipelined-Requests: 7654

   M->C: RTSP/2.0 200 OK
         CSeq: 2
         Server: PhonyServer/1.0
         Transport: RTP/AVP;unicast;
                    dest_addr="192.0.2.53:8000"/"192.0.2.53:8001";
                    src_addr="198.51.100.5:9000"/"198.51.100.5:9001";
                    ssrc=93CB001E
         Session: OccldOFFq23KwjYpAnBbUr
         Expires: Fri, 20 Dec 2013 12:20:32 +0000
         Date: Fri, 20 Dec 2013 10:20:32 +0000
         Accept-Ranges: npt
         Pipelined-Requests: 7654
         Media-Properties: Random-Access=0.2, Immutable, Unlimited

   M->C: RTSP/2.0 200 OK
         CSeq: 3
         Server: PhonyServer/1.0
         Transport: RTP/AVP;unicast;
                    dest_addr="192.0.2.53:8002"/"192.0.2.53:8003;
                    src_addr="198.51.100.5:9002"/"198.51.100.5:9003";
                    ssrc=A813FC13
         Session: OccldOFFq23KwjYpAnBbUr
         Expires: Sat, 21 Dec 2013 10:20:32 +0000
         Date: Fri, 20 Dec 2013 10:20:32 +0000
         Accept-Range: NPT
         Pipelined-Requests: 7654
         Media-Properties: Random-Access=0.8, Immutable, Unlimited

   M->C: RTSP/2.0 200 OK
         CSeq: 4
         Server: PhonyServer/1.0
         Date: Fri, 20 Dec 2013 10:20:32 +0000
         Session: OccldOFFq23KwjYpAnBbUr
         Range: npt=0-623.10
         Seek-Style: RAP
         RTP-Info: url="rtsp://example.com/twister.3gp/trackID=4"
            ssrc=0D12F123:seq=12345;rtptime=3450012,
           url="rtsp://example.com/twister.3gp/trackID=1"
            ssrc=4F312DD8:seq=54321;rtptime=2876889
         Pipelined-Requests: 7654
```

---
### **A.3.  Secured Media Session for On-Demand Content**

이 예는 기본적으로 위의 예\(부록 A.2\)이지만 보안 미디어 전달을 얻기 위한 SRTP 암호화 컨텍스트 설정을 포함합니다. 우선, 클라이언트는 이를 안전하지 않게 가져오려고 시도하지만 서버는 RTSP 메시지에 대한 보안 연결 사용에 대한 요구 사항을 나타내는 URI로 리디렉션합니다. 클라이언트는 TCP/TLS 연결을 설정하고 세션 설명을 검색하여 설정해야 하는 미디어 리소스를 결정합니다. 이 세션 설명에서는 보안 미디어\(SRTP\)가 표시됩니다. 다음 단계에서 클라이언트는 MIKEY 메시지를 포함하여 필요한 SETUP 요청을 보냅니다. 이는 미디어 전달을 시작하기 위한 PLAY 요청으로 파이프라인됩니다.

클라이언트 C는 미디어 서버 M에 프레젠테이션을 요청합니다. 동영상은 컨테이너 파일에 저장됩니다. 클라이언트가 컨테이너 파일에 대한 RTSP URI를 얻었습니다.

참고: 아래 MIKEY 메시지는 유효한 MIKEY 메시지가 아니며 MIKEY 메시지가 이동하는 위치를 나타내는 Base64로 인코딩된 무작위 데이터입니다.

```text
   C->M: DESCRIBE rtsp://example.com/twister.3gp RTSP/2.0
         CSeq: 1
         User-Agent: PhonyClient/1.2

   M->C: RTSP/2.0 301 Moved Permanently
         CSeq: 1
         Server: PhonyServer/1.0
         Date: Fri, 20 Dec 2013 10:25:32 +0000
         Location: rtsps://example.com/twister.3gp
```

C-\>M: TCP/TLS 연결을 설정하고 서버를 확인합니다.

- example.com을 나타내는 인증서입니다. 아래의 모든 RTSP 메시지에 사용됩니다.

```text
   C->M: DESCRIBE rtsps://example.com/twister.3gp RTSP/2.0
         CSeq: 2
         User-Agent: PhonyClient/1.2

   M->C: RTSP/2.0 200 OK
         CSeq: 2
         Server: PhonyServer/1.0
         Date: Fri, 20 Dec 2013 10:25:33 +0000
         Content-Type: application/sdp
         Content-Length: 271
         Content-Base: rtsps://example.com/twister.3gp/
         Expires: Fri, 20 Dec 2013 12:25:33 +0000
```

v=0

- o=- 2890844256 2890842807 IN IP4 192.0.2.5 s=RTSP 세션 i=RTSP 세션 사용 예 e=adm@example.com c=IN IP4 0.0.0.0 a=control: \* a=range:npt=00: 00:00-00:10:34.10 t=0 0 m=오디오 0 RTP/SAVP 0 a=제어: trackID=1 m=비디오 0 RTP/SAVP 26 a=제어: trackID=4

```text
   C->M: SETUP rtsps://example.com/twister.3gp/trackID=1 RTSP/2.0
         CSeq: 3
         User-Agent: PhonyClient/1.2
         Require: play.basic
         Transport: RTP/SAVP;unicast;dest_addr=":8000"/":8001";
            MIKEY=VGhpcyBpcyB0aGUgZmlyc3Qgc3RyZWFtcyBNSUtFWSBtZXNzYWdl
         Accept-Ranges: npt, smpte, clock
         Pipelined-Requests: 7654

   C->M: SETUP rtsps://example.com/twister.3gp/trackID=4 RTSP/2.0
         CSeq: 4
         User-Agent: PhonyClient/1.2
         Require: play.basic
         Transport: RTP/SAVP;unicast;dest_addr=":8002"/":8003";
            MIKEY=TUlLRVkgZm9yIHN0cmVhbSB0d2lzdGVyLjNncC90cmFja0lEPTQ=
         Accept-Ranges: npt, smpte, clock
         Pipelined-Requests: 7654

   C->M: PLAY rtsps://example.com/twister.3gp/ RTSP/2.0
         CSeq: 5
         User-Agent: PhonyClient/1.2
         Range: npt=0-
         Seek-Style: RAP
         Pipelined-Requests: 7654

   M->C: RTSP/2.0 200 OK
         CSeq: 3
         Server: PhonyServer/1.0
         Transport: RTP/SAVP;unicast;
            dest_addr="192.0.2.53:8000"/"192.0.2.53:8001";
            src_addr="198.51.100.5:9000"/"198.51.100.5:9001";
            ssrc=93CB001E;
            MIKEY=TUlLRVkgUmVzcG9uc2UgdHdpc3Rlci4zZ3AvdHJhY2tJRD0x
         Session: OccldOFFq23KwjYpAnBbUr
         Expires: Fri, 20 Dec 2013 12:25:34 +0000
         Date: Fri, 20 Dec 2013 10:25:34 +0000
         Accept-Ranges: npt
         Pipelined-Requests: 7654
         Media-Properties: Random-Access=0.2, Immutable, Unlimited

   M->C: RTSP/2.0 200 OK
         CSeq: 4
         Server: PhonyServer/1.0
         Transport: RTP/SAVP;unicast;
            dest_addr="192.0.2.53:8002"/"192.0.2.53:8003;
            src_addr="198.51.100.5:9002"/"198.51.100.5:9003";
            ssrc=A813FC13;
            MIKEY=TUlLRVkgUmVzcG9uc2UgdHdpc3Rlci4zZ3AvdHJhY2tJRD00
         Session: OccldOFFq23KwjYpAnBbUr
         Expires: Fri, 20 Dec 2013 12:25:34 +0000
         Date: Fri, 20 Dec 2013 10:25:34 +0000
         Accept-Range: NPT
         Pipelined-Requests: 7654
         Media-Properties: Random-Access=0.8, Immutable, Unlimited

   M->C: RTSP/2.0 200 OK
         CSeq: 5
         Server: PhonyServer/1.0
         Date: Fri, 20 Dec 2013 10:25:34 +0000
         Session: OccldOFFq23KwjYpAnBbUr
         Range: npt=0-623.10
         Seek-Style: RAP
         RTP-Info: url="rtsps://example.com/twister.3gp/trackID=4"
            ssrc=0D12F123:seq=12345;rtptime=3450012,
           url="rtsps://example.com/twister.3gp/trackID=1"
            ssrc=4F312DD8:seq=54321;rtptime=2876889;
         Pipelined-Requests: 7654
```

---
### **A.4.  Media on Demand (Unicast)**

몇 가지를 더 수정한 주문형 미디어의 또 다른 예는 다음과 같습니다. 클라이언트 C는 서로 다른 두 미디어 서버 A\(audio.example.com\)와 V\(video.example.com\)에서 배포된 영화를 요청합니다. 미디어 설명은 웹 서버 W에 저장됩니다. 미디어 설명에는 사용 가능한 코덱과 프로토콜 스택을 포함하여 프레젠테이션과 모든 스트림에 대한 설명이 포함됩니다.

이 예에서 클라이언트는 영화의 마지막 부분에만 관심이 있습니다.

```text
   C->W: GET /twister.sdp HTTP/1.1
         Host: www.example.com
         Accept: application/sdp

   W->C: HTTP/1.1 200 OK
         Date: Wed, 23 Jan 2013 15:35:06 GMT
         Content-Type: application/sdp
         Content-Length: 278
         Expires: Thu, 24 Jan 2013 15:35:06 GMT
```

v=0

- o=- 2890844526 2890842807 IN IP4 198.51.100.5 s=RTSP 세션 e=adm@example.com c=IN IP4 0.0.0.0 a=range:npt=00:00:00-01:49:34 t=0 0 m=오디오 0 RTP/AVP 0 a=control:rtsp://audio.example.com/twister/audio.en m=비디오 0 RTP/AVP 31 a=control:rtsp://video.example.com/twister /동영상

```text
   C->A: SETUP rtsp://audio.example.com/twister/audio.en RTSP/2.0
         CSeq: 1
         User-Agent: PhonyClient/1.2
         Transport: RTP/AVP/UDP;unicast;dest_addr=":3056"/":3057",
                    RTP/AVP/TCP;unicast;interleaved=0-1
         Accept-Ranges: npt, smpte, clock

   A->C: RTSP/2.0 200 OK
         CSeq: 1
         Session: OccldOFFq23KwjYpAnBbUr
         Transport: RTP/AVP/UDP;unicast;
                    dest_addr="192.0.2.53:3056"/"192.0.2.53:3057";
                    src_addr="198.51.100.5:5000"/"198.51.100.5:5001"
         Date: Wed, 23 Jan 2013 15:35:12 +0000
         Server: PhonyServer/1.0
         Expires: Thu, 24 Jan 2013 15:35:12 +0000
         Cache-Control: public
         Accept-Ranges: npt, smpte
         Media-Properties: Random-Access=0.02, Immutable, Unlimited

   C->V: SETUP rtsp://video.example.com/twister/video RTSP/2.0
         CSeq: 1
         User-Agent: PhonyClient/1.2
         Transport: RTP/AVP/UDP;unicast;
                    dest_addr="192.0.2.53:3058"/"192.0.2.53:3059",
                    RTP/AVP/TCP;unicast;interleaved=0-1
         Accept-Ranges: npt, smpte, clock

   V->C: RTSP/2.0 200 OK
         CSeq: 1
         Session: P5it3pMo6xHkjUcDrNkBjf
         Transport: RTP/AVP/UDP;unicast;
            dest_addr="192.0.2.53:3058"/"192.0.2.53:3059";
            src_addr="198.51.100.5:5002"/"198.51.100.5:5003"
         Date: Wed, 23 Jan 2013 15:35:12 +0000
         Server: PhonyServer/1.0
         Cache-Control: public
         Expires: Thu, 24 Jan 2013 15:35:12 +0000
         Accept-Ranges: npt, smpte
         Media-Properties: Random-Access=1.2, Immutable, Unlimited

   C->V: PLAY rtsp://video.example.com/twister/video RTSP/2.0
         CSeq: 2
         User-Agent: PhonyClient/1.2
         Session: P5it3pMo6xHkjUcDrNkBjf
         Range: smpte=0:10:00-

   V->C: RTSP/2.0 200 OK
         CSeq: 2
         Session: P5it3pMo6xHkjUcDrNkBjf
         Range: smpte=0:10:00-1:49:23
         Seek-Style: First-Prior
         RTP-Info: url="rtsp://video.example.com/twister/video"
                   ssrc=A17E189D:seq=12312232;rtptime=78712811
         Server: PhonyServer/2.0
         Date: Wed, 23 Jan 2013 15:35:13 +0000

   C->A: PLAY rtsp://audio.example.com/twister/audio.en RTSP/2.0
         CSeq: 2
         User-Agent: PhonyClient/1.2
         Session: OccldOFFq23KwjYpAnBbUr
         Range: smpte=0:10:00-

   A->C: RTSP/2.0 200 OK
         CSeq: 2
         Session: OccldOFFq23KwjYpAnBbUr
         Range: smpte=0:10:00-1:49:23
         Seek-Style: First-Prior
         RTP-Info: url="rtsp://audio.example.com/twister/audio.en"
                   ssrc=3D124F01:seq=876655;rtptime=1032181
         Server: PhonyServer/1.0
         Date: Wed, 23 Jan 2013 15:35:13 +0000

   C->A: TEARDOWN rtsp://audio.example.com/twister/audio.en RTSP/2.0
         CSeq: 3
         User-Agent: PhonyClient/1.2
         Session: OccldOFFq23KwjYpAnBbUr

   A->C: RTSP/2.0 200 OK
         CSeq: 3
         Server: PhonyServer/1.0
         Date: Wed, 23 Jan 2013 15:36:52 +0000

   C->V: TEARDOWN rtsp://video.example.com/twister/video RTSP/2.0
         CSeq: 3
         User-Agent: PhonyClient/1.2
         Session: P5it3pMo6xHkjUcDrNkBjf

   V->C: RTSP/2.0 200 OK
         CSeq: 3
         Server: PhonyServer/2.0
         Date: Wed, 23 Jan 2013 15:36:52 +0000
```

오디오 및 비디오 트랙이 약간 다른 시간에 시작되고 시간이 지남에 따라 서로 표류할 수 있는 두 개의 다른 서버에 있더라도 클라이언트는 PLAY에서 수신된 RTP-Info 및 Range를 사용하여 두 미디어의 초기 동기화를 수행할 수 있습니다. 응답. 두 서버의 시간이 동기화된 경우 RTCP 패킷을 사용하여 동기화를 유지할 수도 있습니다.

---
### **A.5.  Single-Stream Container Files**

일부 RTSP 서버는 모든 파일을 "컨테이너 파일"인 것처럼 처리할 수 있지만 다른 서버는 이러한 개념을 지원하지 않을 수 있습니다. 이 때문에 클라이언트는 일관된 URI가 항상 사용될 수 있다고 가정하기보다는 요청-URI에 대한 세션 설명에 명시된 규칙을 사용해야 합니다. 다음은 멀티 스트림 서버가 단일 스트림 파일이 제공될 것으로 예상하는 방법의 예입니다.

```text
   C->S: DESCRIBE rtsp://foo.example.com/test.wav RTSP/2.0
         Accept: application/x-rtsp-mh, application/sdp
         CSeq: 1
         User-Agent: PhonyClient/1.2

   S->C: RTSP/2.0 200 OK
         CSeq: 1
         Content-base: rtsp://foo.example.com/test.wav/
         Content-type: application/sdp
         Content-length: 163
         Server: PhonyServer/1.0
         Date: Wed, 23 Jan 2013 15:36:52 +0000
         Expires: Thu, 24 Jan 2013 15:36:52 +0000
```

v=0

- o=- 872653257 872653257 IN IP4 192.0.2.5 s=mu-law 웨이브 파일 i=오디오 테스트 c=IN IP4 0.0.0.0 t=0 0 a=제어: \* m=오디오 0 RTP/AVP 0 a=제어: 스트림ID=0

```text
   C->S: SETUP rtsp://foo.example.com/test.wav/streamid=0 RTSP/2.0
         Transport: RTP/AVP/UDP;unicast;
            dest_addr=":6970"/":6971";mode="PLAY"
         CSeq: 2
         User-Agent: PhonyClient/1.2
         Accept-Ranges: npt, smpte, clock

   S->C: RTSP/2.0 200 OK
         Transport: RTP/AVP/UDP;unicast;
             dest_addr="192.0.2.53:6970"/"192.0.2.53:6971";
             src_addr="198.51.100.5:6970"/"198.51.100.5:6971";
             mode="PLAY";ssrc=EAB98712
         CSeq: 2
         Session: NYkqQYKk0bb12BY3goyoyO
         Expires: Thu, 24 Jan 2013 15:36:52 +0000
         Server: PhonyServer/1.0
         Date: Wed, 23 Jan 2013 15:36:52 +0000
         Accept-Ranges: npt
         Media-Properties: Random-Access=0.5, Immutable, Unlimited

   C->S: PLAY rtsp://foo.example.com/test.wav/ RTSP/2.0
         CSeq: 3
         User-Agent: PhonyClient/1.2
         Session: NYkqQYKk0bb12BY3goyoyO

   S->C: RTSP/2.0 200 OK
         CSeq: 3
         Server: PhonyServer/1.0
         Date: Wed, 23 Jan 2013 15:36:52 +0000
         Session: NYkqQYKk0bb12BY3goyoyO
         Range: npt=0-600
         Seek-Style: RAP
         RTP-Info: url="rtsp://foo.example.com/test.wav/streamid=0"
            ssrc=0D12F123:seq=981888;rtptime=3781123
```

SETUP 명령에서 다른 URI를 확인한 다음 PLAY 명령에서 집계 URI로 다시 전환하십시오. 이는 집계 제어가 가능한 여러 스트림이 있는 경우 완전히 의미가 있지만 스트림 수가 1개인 특수한 경우에는 직관적이지 않습니다. 그러나 서버는 SDP에서 집계된 제어 URI를 선언했습니다. 그러므로 이것은 합법적입니다.

이 경우 서버는 다음과 같이 비집합 해석을 사용하고 개별 미디어 URI를 사용하는 구현을 허용해야 합니다.

```text
   C->S: PLAY rtsp://example.com/test.wav/streamid=0 RTSP/2.0
         CSeq: 3
         User-Agent: PhonyClient/1.2
         Session: NYkqQYKk0bb12BY3goyoyO
```

---
### **A.6.  Live Media Presentation Using Multicast**

미디어 서버 M은 멀티캐스트 주소와 포트를 선택합니다. 여기서 웹 서버는 전체 설명에 대한 포인터만 포함하고 미디어 서버 M은 전체 설명을 유지한다고 가정합니다.

```text
   C->W: GET /sessions.html HTTP/1.1
         Host: www.example.com

   W->C: HTTP/1.1 200 OK
         Content-Type: text/html

         <html>
           ...
           <a href "rtsp://live.example.com/concert/audio">
              Streamed Live Music performance </a>
           ...
         </html>

   C->M: DESCRIBE rtsp://live.example.com/concert/audio RTSP/2.0
         CSeq: 1
         Supported: play.basic, play.scale
         User-Agent: PhonyClient/1.2

   M->C: RTSP/2.0 200 OK
         CSeq: 1
         Content-Type: application/sdp
         Content-Length: 183
         Server: PhonyServer/1.0
         Date: Wed, 23 Jan 2013 15:36:52 +0000
         Supported: play.basic

         v=0
         o=- 2890844526 2890842807 IN IP4 192.0.2.5
         s=RTSP Session
         t=0 0
         m=audio 3456 RTP/AVP 0
         c=IN IP4 233.252.0.54/16
         a=control: rtsp://live.example.com/concert/audio
         a=range:npt=0-

   C->M: SETUP rtsp://live.example.com/concert/audio RTSP/2.0
         CSeq: 2
         Transport: RTP/AVP;multicast;
              dest_addr="233.252.0.54:3456"/"233.252.0.54:3457";ttl=16
         Accept-Ranges: npt, smpte, clock
         User-Agent: PhonyClient/1.2

   M->C: RTSP/2.0 200 OK
         CSeq: 2
         Server: PhonyServer/1.0
         Date: Wed, 23 Jan 2013 15:36:52 +0000
         Transport: RTP/AVP;multicast;
              dest_addr="233.252.0.54:3456"/"233.252.0.54:3457";ttl=16
              ;ssrc=4D12AB92/0DF876A3
         Session: qHj4jidpmF6zy9v9tNbtxr
         Accept-Ranges: npt, clock
         Media-Properties: No-Seeking, Time-Progressing, Time-Duration=0

   C->M: PLAY rtsp://live.example.com/concert/audio RTSP/2.0
         CSeq: 3
         Session: qHj4jidpmF6zy9v9tNbtxr
         User-Agent: PhonyClient/1.2

   M->C: RTSP/2.0 200 OK
         CSeq: 3
         Server: PhonyServer/1.0
         Date: Wed, 23 Jan 2013 15:36:52 +0000
         Session: qHj4jidpmF6zy9v9tNbtxr
         Seek-Style: Next
         Range:npt=1256-
         RTP-Info: url="rtsp://live.example.com/concert/audio"
                   ssrc=0D12F123:seq=1473; rtptime=80000
```

---
### **A.7.  Capability Negotiation**

이 예에서는 클라이언트와 서버가 특수 기능\(이 경우 "play.scale"\)을 지원하는 기능을 결정하는 방법을 보여줍니다. 서버는 클라이언트 요청과 포함된 Supported 헤더를 통해 클라이언트가 RTSP 2.0을 지원하고 RTSP의 재생 시간 조정 기능도 지원한다는 사실을 알게 됩니다. 서버의 응답에는 클라이언트에 대한 다음 기능 관련 정보가 포함됩니다. 기본 미디어 전달 기능\(play.basic\), 콘텐츠 시간 확장의 확장 기능\(play.scale\) 및 하나의 "example.com" 독점 기능\(com.example.flight\)을 지원합니다. 또한 클라이언트는 표시된 리소스에 대해 서버에서 지원하는 방법\(공개 헤더\)을 학습합니다.

```text
   C->S: OPTIONS rtsp://media.example.com/movie/twister.3gp RTSP/2.0
         CSeq: 1
         Supported: play.basic, play.scale
         User-Agent: PhonyClient/1.2

   S->C: RTSP/2.0 200 OK
         CSeq: 1
         Public:OPTIONS,SETUP,PLAY,PAUSE,TEARDOWN,DESCRIBE,GET_PARAMETER
         Allow: OPTIONS, SETUP, PLAY, PAUSE, TEARDOWN, DESCRIBE
         Server: PhonyServer/2.0
         Supported: play.basic, play.scale, com.example.flight
```

클라이언트가 SETUP 요청을 보낼 때 Require 헤더를 포함하여 이 세션에 대해 play.scale 기능 지원이 필요하다는 것을 서버에 알립니다.

```text
   C->S: SETUP rtsp://media.example.com/twister.3gp/trackID=1 RTSP/2.0
         CSeq: 3
         User-Agent: PhonyClient/1.2
         Transport: RTP/AVP/UDP;unicast;
                    dest_addr="192.0.2.53:3056"/"192.0.2.53:3057",
                    RTP/AVP/TCP;unicast;interleaved=0-1
         Require: play.scale
         Accept-Ranges: npt, smpte, clock
         User-Agent: PhonyClient/1.2

   S->C: RTSP/2.0 200 OK
         CSeq: 3
         Session: OccldOFFq23KwjYpAnBbUr
         Transport: RTP/AVP/UDP;unicast;
            dest_addr="192.0.2.53:3056"/"192.0.2.53:3057";
            src_addr="198.51.100.5:5000"/"198.51.100.5:5001"
         Server: PhonyServer/2.0
         Accept-Ranges: npt, smpte
         Media-Properties: Random-Access=0.8, Immutable, Unlimited
```

---
# **Appendix B.  RTSP Protocol State Machine**

RTSP 세션 상태 시스템은 RTSP 세션 초기화부터 RTSP 세션 종료까지 프로토콜의 동작을 설명합니다. 이것을 서버의 상태로 생각하고 클라이언트가 보내거나 받은 RTSP 메시지를 기반으로 서버의 상태가 무엇이라고 생각하는지 추적해야 한다고 보는 것이 가장 쉬운 방법일 것입니다. 따라서 대부분의 경우 아래 상태 테이블은 다음과 같이 읽을 수 있습니다. 클라이언트가 X를 수행하고 전제 조건을 충족한다고 가정하면 \(서버\) 상태가 새 상태로 이동하고 표시된 응답이 반환됩니다. 그러나 서버-클라이언트 알림이나 요청도 있습니다. 여기서 작업은 무엇을 설명하는지

알림 또는 요청이 발생할 것인지, 그 요구 사항, 서버가 응답을 받은 후 어떤 새로운 상태가 발생하게 될 것인지, 그리고 작업에 대한 클라이언트의 응답을 설명하는 것입니다.

상태 머신은 세션별로 정의되며 RTSP 세션 식별자로 고유하게 식별됩니다. 세션에는 상태에 따라 하나 이상의 미디어 스트림이 포함될 수 있습니다. 단일 미디어 스트림이 세션의 일부인 경우 집계되지 않은 제어를 받습니다. 둘 이상이 세션의 일부인 경우 통합 제어됩니다.

아래 상태 머신은 프로토콜 동작에 대한 유익한 설명입니다. 본 사양의 이전 부분과 모호한 경우 이전 부분의 설명이 우선합니다.

---
### **B.1.  States**

상태 머신에는 아래에 설명된 세 가지 상태가 포함되어 있습니다. 각 상태마다 허용되는 요청 및 이벤트와 이로 인해 상태가 변경되는지 여부를 보여주는 테이블이 있습니다.

```text
   Init: Initial state, no session exists.
```

준비됨: 세션이 재생을 시작할 준비가 되었습니다.

재생: 세션이 재생 중입니다. 즉, S-\>C 방향으로 미디어 스트림 데이터를 전송합니다.

---
### **B.2.  State Variables**

상태 머신의 이러한 표현이 작동하려면 상태 이상의 것이 필요합니다. 소수의 변수도 필요하며 이에 대한 설명은 아래에 나와 있습니다.

NRM: 이 세션의 일부인 미디어 스트림 수입니다.

RP: 재개 지점, 재생을 계속하라는 요청이 재개되는 프레젠테이션 타임라인의 지점입니다. 변수의 시간 형식은 필수가 아닙니다.

---
### **B.3.  Abbreviations**

상태 테이블을 더 간결하게 만들기 위해 아래에 설명된 여러 약어가 사용됩니다.

IFI: 구현된 경우.

```text
   md:   Media
```

PP: 일시 중지 지점\(Pause Point\), 프레젠테이션이 일시 중지된 프레젠테이션 타임라인의 지점입니다.

Prs: 프레젠테이션, 완전한 멀티미디어 프레젠테이션입니다.

RedP: 리디렉션 지점, REDIRECT가 발생하도록 지정된 프레젠테이션 타임라인의 지점입니다.

```text
   SES:  Session.
```

---
### **B.4.  State Tables**

이 섹션에는 각 주에 대한 표가 포함되어 있습니다. 테이블에는 이 상태가 작동하도록 허용된 모든 요청과 이벤트가 포함되어 있습니다. 메소드 이름인 이벤트는 별도의 언급이 없는 한 클라이언트에서 서버 방향\(C-\>S\)으로 지정된 메소드를 사용하여 요청합니다. 어떤 경우에는 하나 이상의 필수 조건이 존재합니다. 대응 열은 어떤 유형의 대응 조치를 수행해야 하는지 알려줍니다. 이벤트에 대해 요청 가능한 작업에는 응답 코드\(예: 200\), 응답에 포함되어야 하는 헤더, 상태 변수 설정 또는 기타 세션 관련 매개변수 설정이 포함됩니다. 새로운 상태 열은 상태 기계가 어떤 상태로 변경되는지 알려줍니다.

요구 사항을 충족하는 유효한 요청에 대한 응답은 응답 열에 달리 명시되지 않는 한 일반적으로 2xx\(SUCCESS\)입니다. 예외사항에 대해서는 응답란에 따라 응답을 주어야 합니다. 요청이 요구 사항을 충족하지 않거나, 오류가 있거나, 다른 유형의 오류가 발생하는 경우 적절한 응답 코드가 전송됩니다. 응답 코드가 4xx이면 세션 상태가 변경되지 않습니다. 응답 코드가 3rr이면 세션이 종료되고 상태가 Init로 변경됩니다. 응답 코드 304에서는 상태가 변경되지 않습니다. 그러나 3rr 응답을 사용할 수 있는 경우에는 제한이 있습니다. 5xx 응답은 오류를 복구할 수 없는 경우를 제외하고는 세션 상태를 변경하지 않습니다. 복구할 수 없는 오류로 인해 세션이 종료됩니다. 일반적인 경우 복구할 수 없는 오류인지 여부를 확인할 수 없는 경우 클라이언트에서 테스트를 수행해야 합니다. 5xx 이후의 다음 요청이 454\(Session Not Found\)로 응답되는 경우 클라이언트는 세션이 종료되었음을 알 수 있습니다. 섹션 10.4에 정의된 시간 내에 응답할 수 없는 요청 메시지의 경우 100 응답을 보내야 합니다.

클라이언트의 활동이 감지되지 않으면 서버는 SETUP 응답에 지정된 시간이 지나면 세션 시간을 초과합니다. 따라서 Init를 제외한 모든 상태에 대해 시간 초과 이벤트가 존재합니다.

NRM = 1인 경우 프레젠테이션 URI는 미디어 URI 또는 ​​지정된 프레젠테이션 URI와 동일합니다. NRM \> 1의 경우 프레젠테이션 URI는 세션의 일부인 미디어가 아니어야 합니다. 이는 모든 주에 적용됩니다.

```text
   +---------------+-----------------+---------------------------------+
   | Event         | Prerequisite    | Response                        |
   +---------------+-----------------+---------------------------------+
   | DESCRIBE      | Needs REDIRECT  | 3rr, Redirect                   |
   |               |                 |                                 |
   | DESCRIBE      |                 | 200, Session description        |
   |               |                 |                                 |
   | OPTIONS       | Session ID      | 200, Reset session timeout      |
   |               |                 | timer                           |
   |               |                 |                                 |
   | OPTIONS       |                 | 200                             |
   |               |                 |                                 |
   | SET_PARAMETER | Valid parameter | 200, change value of parameter  |
   |               |                 |                                 |
   | GET_PARAMETER | Valid parameter | 200, return value of parameter  |
   +---------------+-----------------+---------------------------------+

                Table 9: Non-State-Machine Changing Events
```

표 9의 방법은 상태 머신이나 상태 변수에 아무런 영향을 미치지 않습니다. 그러나 일부 메소드는 다른 세션 관련 매개변수를 변경합니다\(예: 본문에 지정된 매개변수를 설정하는 SET\_PARAMETER\). 또한 세션 헤더를 허용하는 이러한 모든 메서드는 세션의 연결 유지 타이머도 업데이트합니다.

```text
   +------------------+----------------+-----------+-------------------+
   | Action           | Requisite      | New State | Response          |
   +------------------+----------------+-----------+-------------------+
   | SETUP            |                | Ready     | NRM=1, RP=0.0     |
   |                  |                |           |                   |
   | SETUP            | Needs Redirect | Init      | 3rr Redirect      |
   |                  |                |           |                   |
   | S -> C: REDIRECT | No Session hdr | Init      | Terminate all SES |
   +------------------+----------------+-----------+-------------------+

                           Table 10: State: Init
```

상태 머신의 초기 상태\(표 10\)는 올바른 SETUP 요청을 처리해야만 남을 수 있습니다. 표에서 볼 수 있듯이 두 가지 상태 변수도 올바른 요청에 의해 설정됩니다. 또한 이 표는 경우에 따라 올바른 SETUP이 3rr 응답에 의해 다른 URI나 서버로 리디렉션될 수 있음을 보여줍니다.

```text
   +-------------+------------------------+---------+------------------+
   | Action      | Requisite              | New     | Response         |
   |             |                        | State   |                  |
   +-------------+------------------------+---------+------------------+
   | SETUP       | New URI                | Ready   | NRM +=1          |
   |             |                        |         |                  |
   | SETUP       | URI Setup prior        | Ready   | Change transport |
   |             |                        |         | param            |
   |             |                        |         |                  |
   | TEARDOWN    | Prs URI,               | Init    | No session hdr,  |
   |             |                        |         | NRM = 0          |
   |             |                        |         |                  |
   | TEARDOWN    | md URI,NRM=1           | Init    | No Session hdr,  |
   |             |                        |         | NRM = 0          |
   |             |                        |         |                  |
   | TEARDOWN    | md URI,NRM>1           | Ready   | Session hdr, NRM |
   |             |                        |         | -= 1             |
   |             |                        |         |                  |
   | PLAY        | Prs URI, No range      | Play    | Play from RP     |
   |             |                        |         |                  |
   | PLAY        | Prs URI, Range         | Play    | According to     |
   |             |                        |         | range            |
   |             |                        |         |                  |
   | PLAY        | md URI, NRM=1, Range   | Play    | According to     |
   |             |                        |         | range            |
   |             |                        |         |                  |
   | PLAY        | md URI, NRM=1          | Play    | Play from RP     |
   |             |                        |         |                  |
   | PAUSE       | Prs URI                | Ready   | Return PP        |
   |             |                        |         |                  |
   | SC:REDIRECT | Terminate-Reason       | Ready   | Set RedP         |
   |             |                        |         |                  |
   | SC:REDIRECT | No Terminate-Reason    | Init    | Session is       |
   |             | time parameter         |         | removed          |
   |             |                        |         |                  |
   | Timeout     |                        | Init    |                  |
   |             |                        |         |                  |
   | RedP        |                        | Init    | TEARDOWN of      |
   | reached     |                        |         | session          |
   +-------------+------------------------+---------+------------------+

                          Table 11: State: Ready
```

준비 상태\(표 11\)에서 일부 작업은 세션의 미디어 스트림\(NRM\) 수, 즉 집계 또는 비집계 제어에 따라 달라집니다. 준비 상태의 SETUP 요청은 세션에 미디어 스트림을 하나 더 추가하거나 미디어 스트림\(동일한 URI\)이 이미 세션의 일부인 경우

전송 매개변수. TEARDOWN은 요청-URI와 세션 내의 미디어 스트림 수에 따라 달라집니다. Request-URI가 프레젠테이션 URI인 경우 전체 세션이 해제됩니다. TEARDOWN 요청에 미디어 URI가 사용되고 세션에 둘 이상의 미디어가 있는 경우 세션은 유지되고 세션 헤더가 응답에 반환됩니다. 미디어 URI로 TEARDOWN을 수행할 때 세션에 단일 미디어 스트림만 남아 있으면 세션이 제거됩니다. 미디어 스트림을 해체한 후 남은 미디어 스트림 수에 따라 새 상태가 결정됩니다.

```text
   +----------------+-----------------------+--------+-----------------+
   | Action         | Requisite             | New    | Response        |
   |                |                       | State  |                 |
   +----------------+-----------------------+--------+-----------------+
   | PAUSE          | Prs URI               | Ready  | Set RP to       |
   |                |                       |        | present point   |
   |                |                       |        |                 |
   | End of media   | All media             | Play   | Set RP = End of |
   |                |                       |        | media           |
   |                |                       |        |                 |
   | End of range   |                       | Play   | Set RP = End of |
   |                |                       |        | range           |
   |                |                       |        |                 |
   | PLAY           | Prs URI, No range     | Play   | Play from       |
   |                |                       |        | present point   |
   |                |                       |        |                 |
   | PLAY           | Prs URI, Range        | Play   | According to    |
   |                |                       |        | range           |
   |                |                       |        |                 |
   | SC:PLAY_NOTIFY |                       | Play   | 200             |
   |                |                       |        |                 |
   | SETUP          | New URI               | Play   | 455             |
   |                |                       |        |                 |
   | SETUP          | md URI                | Play   | 455             |
   |                |                       |        |                 |
   | SETUP          | md URI, IFI           | Play   | Change          |
   |                |                       |        | transport param.|
   |                |                       |        |                 |
   | TEARDOWN       | Prs URI               | Init   | No session hdr  |
   |                |                       |        |                 |
   | TEARDOWN       | md URI,NRM=1          | Init   | No Session hdr, |
   |                |                       |        | NRM=0           |
   |                |                       |        |                 |
   | TEARDOWN       | md URI                | Play   | 455             |
   |                |                       |        |                 |
   | SC:REDIRECT    | Terminate Reason with | Play   | Set RedP        |
   |                | Time parameter        |        |                 |
   |                |                       |        |                 |
   | SC:REDIRECT    |                       | Init   | Session is      |
   |                |                       |        | removed         |
   |                |                       |        |                 |
   | RedP reached   |                       | Init   | TEARDOWN of     |
   |                |                       |        | session         |
   |                |                       |        |                 |
   | Timeout        |                       | Init   | Stop Media      |
   |                |                       |        | playout         |
   +----------------+-----------------------+--------+-----------------+
                           Table 12: State: Play
```

재생 상태 테이블\(표 12\)에는 작업을 위해 프레젠테이션 URI\(Prs URI로 표시됨\)가 필요한 여러 요청이 포함되어 있습니다\(즉, 프레젠테이션 URI가 요청-URI로 사용되어야 함\). 이는 둘 이상의 미디어 스트림이 있는 세션에서 집계되지 않은 스트림 제어가 제외되기 때문입니다.

클라이언트와 서버 간의 불일치를 방지하기 위해 자동 상태 전환이 방지됩니다. 예를 들어 모든 미디어 재생이 완료되었지만 세션이 여전히 재생 상태로 유지되는 "미디어 종료" 이벤트에서 이러한 현상을 확인할 수 있습니다. 상태를 준비로 변경하려면 명시적인 PAUSE 요청을 보내야 합니다. "RedP 도달" 및 "PP 도달"에 자동 전환이 있는 것처럼 보일 수 있습니다. 그러나 이러한 작업은 수행되기 전에 요청되고 승인됩니다. 전환이 발생하는 시간은 Terminate-Reason 헤더의 시간 매개변수와 Range 헤더를 각각 확인하여 알 수 있습니다. 클라이언트가 이러한 전환에 가까운 시간에 요청을 보내는 경우 상태가 변경되거나 변경되지 않을 수 있으므로 오류 메시지 수신을 준비해야 합니다.

---
# **Appendix C.  Media-Transport Alternatives**

이 섹션에서는 프로토콜, 프로필 및 하위 전송의 특정 조합이 사용되는 방법을 정의합니다. 여기에는 전송 헤더의 소스 및 대상 주소 매개변수인 "src\_addr" 및 "dest\_addr"의 사용이 포함됩니다.

---
### **C.1.  RTP**

이 섹션에서는 RTP 프로토콜 \[RFC3550\]과 관련하여 RTSP의 상호 작용을 정의합니다. 또한 RTP와 관련하여 필요한 모든 미디어 전송 신호를 정의합니다.

사용 가능한 RTP 프로필 및 하위 계층 전송은 사용 가능한 조합을 알리는 규칙과 함께 아래에 설명되어 있습니다.

---
#### **C.1.1.  AVP**

다양한 하위 계층 전송 프로토콜을 통한 미디어 전송을 위해 RTP를 사용할 때 "최소 제어를 통한 오디오 및 비디오 회의용 RTP 프로필"\[RFC3551\]의 사용은 RTSP와 관련하여 아래에 정의되어 있습니다.

이 문서에는 그러한 사례 중 하나가 정의되어 있습니다: 섹션 14에 정의된 내장\(인터리브\) 바이너리 데이터의 사용입니다. 이 방법의 사용법은 "인터리브" 매개변수를 포함하여 표시됩니다.

내장된 바이너리 데이터를 사용하는 경우 "src\_addr" 및 "dest\_addr"을 사용하면 안 됩니다. 이 주소 지정 및 다중화는 채널 번호 및 인터리브 매개변수를 사용하여 정의된 대로 사용됩니다.\(MUST NOT\)

---
#### **C.1.2.  AVP/UDP**

이 부분에서는 \[RFC3551\]에 정의된 "최소 제어를 사용하는 오디오 및 비디오 회의를 위한 RTP 프로필" 프로파일에 따라 하위 전송 계층 UDP \[RFC768\]를 통해 RTP \[RFC3550\]를 보내는 방법을 설명합니다. RTP/AVP/UDP 구현은 RTCP\(부록 C.1.6\)를 구현해야 합니다. 이 프로필에는 미디어 스트림당 하나 또는 두 개의 단방향 또는 양방향 UDP 흐름이 필요합니다. 첫 번째 UDP 흐름은 RTP용이고 두 번째 UDP 흐름은 RTCP용입니다. RTP와 RTCP의 다중화\(부록 C.1.6.4\)를 사용할 수 있으며, 이 경우 두 부분 모두에 단일 UDP 흐름이 사용됩니다. RTSP 메시지가 UDP \[RFC768\]와 같은 신뢰할 수 없는 전송 프로토콜을 통해 전송되는 경우 섹션 14에 따라 RTSP 메시지에 RTP 데이터를 삽입하면 안 됩니다.\(MUST, MAY, SHOULD NOT\)

RTP/UDP 및 RTCP/UDP 흐름은 전송 헤더의 "src\_addr" 및 "dest\_addr" 매개변수를 사용하여 설정할 수 있습니다.

RTSP PLAY 모드에서는 클라이언트에서 서버로의 RTP 패킷 전송이 지정되지 않습니다. 이러한 RTP 패킷과 관련된 동작은 향후 정의될 수 있습니다.\(MAY\)

"src\_addr" 및 "dest\_addr" 매개변수는 미디어 전달 및 재생 모드\(예: Mode=PLAY\)에 대해 다음과 같은 방식으로 사용됩니다.

o "src\_addr" 및 "dest\_addr" 매개변수에는 1개 또는 2개의 주소 사양이 포함되어야 합니다. RTP 및 RTCP 다중화가 협상되는 경우에도 두 개의 주소 사양이 제공될 수 있습니다.\(MUST, MAY\)

o RTP/AVP/UDP 또는 RTP/AVP/TCP에 대한 각 주소 사양에는 다음 중 하나가 포함되어야 합니다.\(MUST\)

- \* 주소와 포트 번호 모두 또는

- \* 주소가 없는 포트 번호입니다.

o 매개변수 중 하나에 제공된 첫 번째 주소 사양은 RTP 스트림에 적용됩니다. 두 번째 사양이 있는 경우 RTCP 스트림에 적용됩니다. 단, RTP와 RTCP 멀티플렉싱이 협상되어 RTP와 RTCP가 모두 첫 번째 사양을 사용하는 경우는 예외입니다.

o 서버에서 클라이언트로의 RTP/UDP 패킷은 "dest\_addr" 매개변수의 첫 번째 주소 사양에 의해 지정된 주소와 포트로 전송되어야 합니다.\(MUST\)

o 서버에서 클라이언트로의 RTCP/UDP 패킷은 "dest\_addr" 매개변수의 두 번째 주소 사양에 의해 지정된 주소와 포트로 전송되어야 합니다. 단, RTP 및 RTCP 멀티플렉싱이 협상되지 않은 경우 RTCP는 반드시 다음으로 전송되어야 합니다. 첫 번째 주소 지정. 두 번째 쌍이 지정되지 않고 RTP 및 RTCP 다중화가 협상되지 않은 경우 RTCP는 전송되어서는 안 됩니다.\(MUST, MUST NOT\)

o 클라이언트에서 서버로의 RTCP/UDP 패킷은 "src\_addr" 매개변수의 두 번째 주소 사양에 의해 지정된 주소와 포트로 전송되어야 합니다. 단, RTP 및 RTCP 멀티플렉싱이 협상되지 않은 경우 RTCP는 다음으로 전송되어야 합니다. 첫 번째 주소 지정. 두 번째 쌍이 지정되지 않고 RTP 및 RTCP 다중화가 협상되지 않은 경우 RTCP는 전송되어서는 안 됩니다.\(MUST, MUST NOT\)

o 클라이언트에서 서버로의 RTP/UDP 패킷은 "src\_addr" 매개변수의 첫 번째 주소 사양에 의해 지정된 주소와 포트로 전송되어야 합니다.\(MUST\)

o RTP 및 RTCP 패킷은 해당 수신기 포트에서 전송되어야 합니다. 즉, 서버의 RTCP 패킷은 "src\_addr" 매개변수 두 번째 주소 포트 쌍에서 전송되어야 합니다. 단, RTP 및 RTCP 다중화가 협상된 경우 첫 번째 주소 포트는 제외됩니다. 쌍이 사용됩니다.\(SHOULD\)

---
#### **C.1.3.  AVPF/UDP**

RTP 프로필 "RTCP 기반 피드백\(RTP/AVPF\)을 위한 확장된 RTP 프로필"\[RFC4585\]은 RTP를 사용하는 세션에서 RTP 프로필로 사용될 수 있습니다. AVP에 대해 정의된 모든 항목은 AVPF에도 적용되어야 합니다.\(MAY, MUST\)

AVPF의 사용법은 사용된 미디어 초기화 프로토콜로 표시됩니다. SDP의 경우 RTP/AVPF 프로필이 포함된 미디어 라인\("m="\)으로 표시됩니다. 해당 SDP에는 보고 간격 및 사용되는 피드백 메시지와 관련하여 AVPF 세션을 구성하는 추가 AVPF 관련 SDP 속성도 포함될 수 있습니다\[RFC4585\]. 이 구성을 따라야 합니다.\(MAY, MUST\)

---
#### **C.1.4.  SAVP/UDP**

RTP 프로필 "SRTP\(Secure Real-time Transport Protocol\)" \[RFC3711\]는 RTP를 사용하는 RTSP 세션에서 사용할 수 있는 RTP 프로필\(SAVP\)입니다. AVP에 대해 정의된 모든 항목은 SAVP에도 적용되어야 합니다.\(MAY, MUST\)

SRTP를 사용하려면 보안 컨텍스트를 설정해야 합니다. 별도의 신호가 없는 한 기본 키 관리는 부록 C.1.4.1에 정의된 대로 RSA-R 모드에서 MIKEY여야 하며 "SDP\(세션 설명 프로토콜\) 및 실시간 스트리밍 프로토콜에 대한 키 관리 확장\( RTSP\)" \[RFC4567\]. 그 이유는 RFC 4567이 SDP에서 초기 MIKEY 메시지를 전송하기 때문에 DESCRIBE 메소드의 사용이 필요하고 서버가 키 관리가 필요할 수 있다는 예상으로 DESCRIBE를 수행하는 클라이언트의 상태를 유지하도록 강제하기 때문입니다.\(MUST\)

MIKEY는 RTSP 메시지에 홉별 TLS 보안을 사용하는 경우에도 키 자료 내용의 기밀성을 유지하면서 RTSP 메시지에 포함될 수 있으므로 RTSP 세션 내에서 SRTP 암호화 컨텍스트를 설정하기 위한 기본 방법으로 선택됩니다. . 이 방법은 RTSP 메시지의 파이프라인도 지원합니다.

---
##### **C.1.4.1.  MIKEY Key Establishment**

SRTP 암호화 컨텍스트를 설정하기 위해 MIKEY \[RFC3830\]를 사용하는 이 방법은 클라이언트의 SETUP 요청에서 시작되고 SETUP에 대한 서버의 응답은 MIKEY 응답을 전달합니다. 이를 통해 암호화 컨텍스트 설정이 보호되는 미디어 스트림 설정과 동시에 발생하도록 보장합니다. MIKEY의 RSA-R 모드 \[RFC4738\]를 사용하면 클라이언트가 개시자가 될 수 있으며 서버가 실제 미디어 스트림에 따라 매개변수를 설정할 수 있습니다.

SRTP 암호화 컨텍스트 설정은 다음 프로세스에 따라 수행됩니다.

1. 클라이언트는 미디어 설명 형식\(예: SDP\)에서 SAVP 또는 SAVPF를 사용해야 하는지 결정합니다. 다른 키 관리 방법이 명시적으로 신호되지 않으면 MIKEY는 여기에 정의된 대로 사용됩니다. RTSP와 함께 SRTP를 사용하는 것은 이 섹션에 정의된 대로 키가 설정된 MIKEY로만 정의됩니다. 향후 문서에서는 RTSP 구현이 사용될 다른 주요 메커니즘을 나타내는 SDP를 처리하는 방법을 정의할 수 있습니다. 이러한 사양의 필요성에는 이 문서 내 RTSP 2.0에서 사용하도록 정의되지 않은 \[RFC4567\]이 포함됩니다.\(MUST\)

2. 클라이언트는 RTSP 메시지에 대한 TLS 연결을 직접적으로 또는 서버와 홉별로 설정해야 합니다. hop-by-hop TLS 보안이 사용되는 경우 사용자 방법은 Accept-Credentials 헤더에 표시되어야 합니다. hop-by-hop을 사용하면 프록시가 중간에 사람으로 삽입될 수 있습니다. 이는 Connection-Credentials 헤더에 있는 서버가 아닌 인증서 중 하나를 제공하는 프록시에 의한 MIKEY 교환에서도 발생할 수 있습니다. 따라서 클라이언트는 서버 인증서의 유효성을 검사해야 합니다.\(MUST, MUST, MUST\)

3. 클라이언트는 직접 TLS 연결에서 서버의 인증서를 검색하거나 Connection-Credentials 헤더에서 홉별로 검색합니다. 그런 다음 클라이언트는 서버 인증서가 유효하고 서버에 속하는지 확인합니다.

4. 클라이언트는 \[RFC4738\]에 지정된 대로 유니캐스트 모드에서 RSA-R 모드를 사용하여 MIKEY 개시자 메시지를 구성합니다. 클라이언트는 TLS와 MIKEY에 대해 동일한 인증서를 사용하여 서버가 두 가지를 함께 바인딩할 수 있도록 해야 합니다. 클라이언트의 인증서는 MIKEY 메시지에 포함되어야 합니다. 클라이언트는 메시지에 SRTP 기능을 표시해야 합니다.\(SHOULD, MUST, MUST\)

5. 이전 단계의 MIKEY 메시지는 base64로 인코딩\[RFC4648\]되어 SETUP 요청에서 SRTP 기반 프로파일\(SAVP, SAVPF\)을 지정하는 전송 사양에 포함된 MIKEY 매개변수의 값이 됩니다. .

6. MIKEY 매개변수를 만나는 모든 프록시는 이를 수정 없이 전달해야 합니다. 전송 사양을 이해하는 데 필요한 프록시는 SRTP로 보호되는 미디어 스트림에 대한 기본 키잉을 활성화하기 위해 MIKEY가 있는 SAVP/SAVPF를 이해해야 합니다. 그러한 프록시가 MIKEY를 사용하여 SAVP/SAVPF를 지원하지 않는 경우 전체 전송 사양을 폐기합니다. 대부분의 프록시 유형은 MIKEY를 사용하여 SAVP 및 SAVPF를 쉽게 지원할 수 있습니다. 클라이언트가 MIKEY를 사용하여 SAVP/SAVPF를 지원하지 않는 프록시를 발견하는 경우 클라이언트는 해당 프록시 우회를 시도해야 합니다.\(MUST\)

7. 서버는 SETUP 요청을 받으면 클라이언트가 여러 전송 사양을 포함하는 경우 사용할 전송 사양을 결정해야 합니다. 어떤 전송 사양이 지원되고 선호되는지 결정할 때 서버는 MIKEY 메시지를 디코딩하여 내장된 SRTP 매개변수를 고려해야 합니다. 모든 전송 사양에 SRTP가 필요하지만 MIKEY 매개변수 또는 기타 지원되는 키잉 방법이 포함되지 않은 경우 서버는 403\(금지됨\)으로 응답해야 합니다.\(SHOULD, MUST\)

8. 응답이 생성되면 다음과 같은 결과가 발생할 수 있습니다.

- \* SRTP 및 MIKEY를 사용하지 않는 전송 사양을 선택했습니다. 따라서 응답에는 MIKEY 매개변수가 포함되지 않습니다.

- \* SRTP와 MIKEY를 사용하는 전송 사양을 선택했지만 MIKEY 처리 중 오류가 발생했습니다. 이 경우 RTSP 오류 응답 코드 466\(키 관리 오류\)을 사용해야 합니다. 오류를 설명하는 MIKEY 메시지가 포함될 수 있습니다.\(MUST, MAY\)

- \* SRTP와 MIKEY를 이용한 전송 스펙을 선택하고 MIKEY 응답 메시지를 생성할 수 있다. 서버는 클라이언트가 둘을 함께 바인딩할 수 있도록 TLS와 MIKEY에 동일한 인증서를 사용해야 합니다. 다른 인증서가 사용되는 경우 MIKEY 메시지에 포함되어야 합니다. 봉투 키 캐시 유형을 '캐시'로 설정하고 단일 봉투 키가 클라이언트에 보내는 모든 MIKEY 메시지에 재사용되는 것이 권장됩니다. 해당 메시지는 SETUP 응답에서 선택된 단일 전송 사양의 MIKEY 매개변수 부분에 포함됩니다. 서버는 클라이언트가 지원하는 범위 내에서 이 미디어 스트림에 대해 선호되는 SRTP 매개변수를 설정합니다.\(SHOULD, MUST, SHOULD\)

9. 서버는 SETUP 응답을 클라이언트에 다시 전송합니다.

10. 클라이언트는 SETUP 응답을 수신하고 응답 코드가 성공적인 요청을 나타내는 경우 MIKEY 메시지를 디코딩하고 MIKEY 응답의 매개변수에서 SRTP 암호화 컨텍스트를 설정합니다.

위의 방법에서 클라이언트의 ID가 인증에 필요하지 않고 보안 목표가 단지 RTSP 신호 클라이언트가 SRTP 보안 컨텍스트를 수신하는 클라이언트와 동일하다는 것을 확인하는 것인 경우 클라이언트 인증서는 자체 서명될 수 있습니다.

---
#### **C.1.5.  SAVPF/UDP**

RTP 프로필 "RTCP\(실시간 전송 제어 프로토콜\) 기반 피드백\(RTP/SAVPF\)을 위한 확장 보안 RTP 프로필"\[RFC5124\]은 RTP를 사용하는 RTSP 세션에서 사용할 수 있는 RTP 프로필\(SAVPF\)입니다. AVPF에 대해 정의된 모든 항목은 SAVPF에도 적용되어야 합니다.\(MAY, MUST\)

SRTP를 사용하려면 암호화 컨텍스트를 설정해야 합니다. 해당 보안 연결을 설정하는 기본 메커니즘은 부록 C.1.4.1에 정의된 대로 RTSP와 함께 MIKEY\[RFC3830\]를 사용하는 것입니다.

---
#### **C.1.6.  RTCP Usage with RTSP**

RTCP는 아래 설명된 것처럼 미디어 전송을 위해 RTP가 구현될 때 여러 용도로 사용됩니다. 따라서 RTSP 에이전트가 RTP를 처리하는 경우 RTCP가 지원되어야 합니다.\(MUST\)

---
##### **C.1.6.1.  Media Synchronization**

RTCP는 미디어 동기화 및 클럭 드리프트 보상을 제공합니다. 초기 미디어 동기화는 RTP-Info 헤더에서 가능합니다. 그러나 미디어 스트림 간의 클럭 드리프트를 처리하려면 RTCP가 필요합니다.

---
##### **C.1.6.2.  RTSP Session Keep-Alive**

RTSP 클라이언트에서 RTSP 서버로의 RTCP 트래픽은 연결 유지 기능을 수행해야 합니다. 이를 위해서는 수신된 RTCP 패킷을 클라이언트가 관련 RTSP 세션이 유지되기를 원한다는 표시로 사용하기 위해 RTP를 지원하는 RTSP 서버가 필요합니다.\(MUST\)

---
##### **C.1.6.3.  Bitrate Adaption**

RTCP 수신기 보고서와 클라이언트의 추가 피드백은 RTP가 UDP를 통해 전송되는 모든 경우에 대해 전송을 통해 사용되는 비트 전송률을 조정하는 데 사용해야 합니다. 예약된 리소스가 없는 RTP 발신자는 사용 가능한 리소스의 공정한 분배 이상을 사용해서는 안 됩니다. 이는 사용된 비트 전송률을 단기간\(몇 초\)으로 비교하고 RTP 발신자가 동일한 경로에서 TCP 발신자가 평균적으로 달성하는 것과 비슷한 비트 전송률로 전송하도록 조정하여 결정할 수 있습니다.\(MUST, MUST NOT\)

구현의 적응 메커니즘이 잘 정의된 외부 엔벨로프를 갖도록 보장하기 위해 UDP와 같은 비혼잡 제어 유니캐스트 전송 프로토콜을 사용하는 모든 구현은 "멀티미디어 혼잡 제어: 유니캐스트 RTP 세션용 회로 차단기" \[RTP-CIRCUIT- 차단기\].\(MUST\)

---
##### **C.1.6.4.  RTP and RTCP Multiplexing**

RTSP는 \[RFC5761\]에 설명된 대로 RTP 및 RTCP 다중화 사용을 협상하는 데 사용될 수 있습니다. 이를 통해 서버와 클라이언트는 RTP 및 RTCP를 사용할 때 미디어 스트림당 두 개가 아닌 하나의 기본 전송 스트림만 요구함으로써 세션에 필요한 리소스의 양을 줄일 수 있습니다. 이는 NAT를 통해 작동할 때 서버 포트 소비와 필요한 상태 및 연결 유지 작업을 줄입니다\[RFC2663\].

RTP 및 RTCP 멀티플렉싱을 고려하여 콘텐츠를 준비해야 하며 주로 사용된 RTP 페이로드 유형이 RTCP 패킷 유형에 사용되는 유형과 충돌하지 않도록 해야 합니다. 이 옵션은 RTP 페이로드 유형이 서버에 의해 다시 매핑될 수 있고 세션 설명에 올바르게 반영되지 않는 한 콘텐츠의 명시적인 지원이 필요할 수 있습니다. 그 외에도 이 기능을 지원하면 적은 비용으로 많은 이점을 얻을 수 있습니다.

콘텐츠와 서버가 RTP 및 RTCP 멀티플렉싱을 지원하는 경우 세션 설명에 이를 표시하는 것이 좋습니다\(예: SDP 속성 "a=rtcp-mux" 사용\). SDP 메시지에 미디어 스트림에 대한 "a=rtcp-mux" 속성이 포함되어 있는 경우 서버는 RTP 및 RTCP 다중화를 지원해야 합니다. 클라이언트가 표시하거나 원하는 경우 "RTCP-mux"를 사용하려는 모든 전송 사양에 전송 매개변수 "RTCP-mux"를 포함할 수 있습니다. 서버는 "RTCP-mux"를 지원하는지 여부를 표시합니다. 서버와 클라이언트는 RTP 및 RTCP 다중화를 지원해야 합니다.\(MUST, SHOULD\)

기능 교환을 위해 RTP 및 RTCP 다중화를 위한 RTSP 기능 태그가 "setup.rtp.rtcp.mux"로 정의됩니다.

RTP 및 RTCP 멀티플렉싱을 사용하는 동안 협상 실패 위험을 최소화하기 위해 여기에 몇 가지 권장 사항이 제공됩니다. 세션 설명에 명시적인 지원 표시\(SDP의 "a=rtcp-mux"\)가 포함된 경우 RTSP 에이전트는 단일 "dest\_addr" 매개변수 주소 사양만 사용하여 전송 사양으로 SETUP 요청을 안전하게 생성할 수 있습니다. 그러한 명시적인 표시가 제공되지 않으면 RTSP 서버의 Supported 헤더에 "setup.rtp.rtcp.mux" 기능 태그가 제공되거나 SETUP 요청의 필수 헤더에 포함된 기능 태그가 있더라도 미디어 리소스 RTP 및 RTCP 멀티플렉싱을 지원하지 않을 수 있습니다. 따라서 성공적인 협상 가능성을 최대화하기 위해 RTSP 에이전트는 모든 미디어 리소스 집합에 대한 SETUP 요청의 첫 번째 또는 첫 번째 세트\(파이프라인이 사용되는 경우\)에 두 개의 "dest\_addr" 매개변수 주소 사양을 포함하는 것이 좋습니다. 이렇게 하면 RTSP 서버가 RTP 및 RTCP 다중화를 허용하고 첫 번째 주소 사양만 사용하거나 그렇지 않은 경우 두 사양을 모두 사용할 수 있습니다. RTSP 에이전트는 RTP 및 RTCP 다중화 사용에 대한 성공적인 협상에 대한 응답을 받은 후 두 번째 주소 사양과 관련된 리소스를 해제할 수 있습니다.

---
### **C.2.  RTP over TCP**

TCP를 통한 RTP 전송은 두 가지 방법, 즉 \[RFC4571\]을 사용하는 독립적인 TCP 연결을 통해 수행되거나 RTSP 연결에서 인터리브되어 수행될 수 있습니다. 두 경우 모두 프로토콜은 "rtp"여야 하고 하위 계층은 TCP여야 합니다. 프로필은 위에 지정된 것\(AVP, AVPF, SAVP 또는 SAVPF\) 중 하나일 수 있습니다.\(MUST\)

---
#### **C.2.1.  Interleaved RTP over TCP**

섹션 14에 명시된 대로 RTSP 연결을 통해 전송되는 내장\(인터리브\) 바이너리 데이터의 사용이 가능합니다. 인터리브 바이너리 데이터의 선언된 조합을 사용할 때 RTSP 메시지는 반드시 TCP를 통해 전송되어야 합니다. TLS는 사용될 수도 있고 사용되지 않을 수도 있습니다. TLS를 사용하는 경우 RTSP 메시지와 바이너리 데이터가 모두 TLS로 보호됩니다.\(MUST\)

그러나 이로 인해 모든 미디어 스트림이 프록시를 통과하게 된다는 점을 고려해야 합니다. 독립적인 TCP 연결을 사용하면 이러한 문제를 피할 수 있습니다.

---
#### **C.2.2.  RTP over Independent TCP**

이 섹션에서는 "Framing Real-time Transport Protocol \(RTP\) and RTP Control Protocol \(RTCP\) Packets over Connection-Oriented Transport" \[RFC4571\]에 따라 하위 계층 전송 TCP \[RFC793\]를 통한 RTP \[RFC3550\] 전송은 다음과 같습니다. 설명했습니다. 이 섹션에서는 RTSP와 함께 작동하도록 SIP/SDP \[RFC4145\] 내에서 RTP over TCP를 사용하기 위한 지침을 적용합니다.

클라이언트는 SETUP 요청의 전송 라인에 인터리브 매개변수 없이 RTP/AVP/TCP 전송 옵션을 지정하여 독립 TCP를 통한 RTP 지원을 코딩합니다. 이 전송 옵션은 "unicast" 매개변수를 포함해야 합니다.\(MUST\)

클라이언트가 RTCP와 함께 RTP를 사용하려는 경우 "dest\_addr" 매개변수에 두 개의 주소 사양이 포함되어야 합니다. 클라이언트가 RTCP 없이 RTP를 사용하려는 경우 "dest\_addr" 매개변수에 하나의 주소 사양이 포함됩니다. 클라이언트가 단일 전송 흐름에서 RTP 및 RTCP를 다중화하려는 경우\(부록 C.1.6.4 참조\) "RTCP-mux" 전송 매개변수 외에 "dest\_addr" 매개변수에 하나 또는 두 개의 주소 사양이 포함됩니다. 서버나 콘텐츠가 RTP 및 RTCP 다중화를 지원할 수 없는 경우 성공적인 협상을 용이하게 하기 위해 두 가지 주소 사양이 허용됩니다. dest\_addr 포트의 순서 규칙은 RTP/AVP/UDP 규칙을 따릅니다.

클라이언트가 TCP 연결 시작 시 활성 역할을 수행하려는 경우 전송 라인의 설정 매개변수\(18.54절 참조\)를 "활성"으로 설정하거나 활성이 기본값이므로 설정 매개변수를 생략할 수 있습니다. 클라이언트가 활성 역할을 신호하는 경우 "dest\_addr" 매개변수의 주소 사양에 있는 포트는 9\(폐기 포트\)로 설정되어야 합니다.\(MAY, MUST\)

클라이언트가 TCP 연결 시작에서 수동적 역할을 수행하려는 경우 전송 라인의 설정 매개변수를 "수동"으로 설정해야 합니다. 클라이언트가 활성 또는\(MUST\)

수동적 역할을 수행하려면 전송 라인의 설정 매개변수를 "actpass"로 설정해야 합니다. 두 경우 모두, RTP에 대한 "dest\_addr" 매개변수의 주소 지정 포트 값은 클라이언트가 RTP에 대한 TCP 연결을 수신할 것으로 예상하는 TCP 포트 번호로 설정되어야 하며, RTCP에 대한 "dest\_addr" 주소 지정 포트 값은 반드시 클라이언트가 RTCP에 대한 TCP 연결을 수신할 것으로 예상하는 TCP 포트 번호로 설정됩니다. 클라이언트가 단일 전송 흐름에서 RTP와 RTCP를 다중화하려는 경우 이 섹션의 앞부분에서 언급한 것처럼 "RTCP-mux" 매개변수가 포함되고 하나 또는 두 개의 "dest\_addr" 매개변수 주소 사양이 포함됩니다.\(MUST, MUST\)

인터리브되지 않은 RTP/AVP/TCP SETUP 요청을 수신한 경우 서버가 이 요청된 옵션을 수락하기로 결정한 경우 2xx 응답에는 RTP/AVP/TCP를 지정하는 전송 옵션이 포함되어야 합니다\(인터리브 매개변수 및 유니캐스트 사용 없음\). 매개변수\). "dest\_addr" 매개변수 값은 대상 주소\(포트만\)가 제공되지 않는 한 클라이언트 요청의 매개변수 값에서 에코되어야 합니다. 이 경우 서버는 포트 번호가 변경되지 않은 RTSP TCP 연결의 소스 주소를 포함할 수 있습니다.\(MUST, MUST\)

또한 서버 응답은 연결 설정에서 서버가 수행할 역할을 나타내기 위해 전송 라인의 설정 매개변수를 설정해야 합니다. 허용되는 값은 "active"\(클라이언트가 설정을 "passive" 또는 "actpass"로 설정한 경우\) 및 "passive"\(클라이언트가 설정을 "active" 또는 "actpass"로 설정한 경우\)입니다.\(MUST\)

서버가 설정을 "passive"로 설정한 경우 응답의 "src\_addr"은 서버가 RTP에 대한 TCP 연결을 수신할 포트를 나타내야 하며\(클라이언트가 두 개의 "dest\_addr"을 지정하여 RTCP에 대한 TCP 연결을 요청한 경우\) " 주소 사양\) TCP/RTCP 연결. 서버가 설정을 "active"로 설정하는 경우 "src\_addr" 주소 사양에 지정된 포트는 9로 설정되어야 합니다. 서버는 섹션 18.54의 지침에 따라 "ssrc" 매개변수를 사용할 수 있습니다. 클라이언트가 단일 주소 사양만을 지시한 경우나 서버가 RTP 및 RTCP 다중화를 요청하여 수락한 경우 서버는 하나의 주소 사양만 설정합니다. "src\_addr"의 포트 순서는 RTP/AVP/UDP 규칙을 따릅니다.\(MUST, MUST, MAY\)

서버는 수동적 역할 수행을 지원해야 하며\(MUST\) 활성 역할 수행을 지원할 수 있습니다. 공용 IP 주소가 있는 서버는 수동적 역할을 수행하므로 NAT 및 방화벽 뒤의 클라이언트가 외부로 적극적으로 연결하여 서버에 성공적으로 연결할 수 있는 가능성이 더 높아집니다. 따라서 클라이언트가 적극적인 역할을 맡는 것이 좋습니다.\(MUST, SHOULD\)

인터리빙되지 않은 RTP/AVP/TCP 미디어 스트림에 대한 SETUP 방법에 대한 2xx 응답을 전송\(수신\)한 후 활성 당사자는 가능한 한 빨리 TCP 연결을 시작해야 합니다. 클라이언트는 세션에 대해 SETUP을 사용하여 협상된 모든 TCP 연결을 설정하기 전에 PLAY 요청을 보내면 안 됩니다. 서버가 아직 모든 TCP 연결을 설정하지 않은 세션에서 PLAY 요청을 수신하는 경우, 서버는 464\(Data Transport Not Ready Yet\)\(섹션 17.4.28\) 오류 코드를 사용하여 응답해야 합니다.\(SHOULD, MUST NOT, MUST\)

인터리빙되지 않은 RTP/AVP/TCP를 통해 전송되는 미디어 리소스에 대한 PLAY 요청이 발생하면 미디어는 RTP TCP 연결을 통해 서버에서 클라이언트로 흐르기 시작하고 RTCP 패킷은 RTCP TCP 연결을 통해 양방향으로 흐릅니다. RTP 및 RTCP 멀티플렉싱이 협상되지 않은 경우; 이 경우 RTP와 RTCP는 공통 TCP 연결을 통해 흐릅니다. RTP/UDP의 경우와 마찬가지로 RTP 전용 TCP 세션의 클라이언트-서버 트래픽은 이 메모에서 지정되지 않습니다. 이러한 연결을 통해 이동하는 패킷은 섹션 14에 정의된 RTSP 연결을 통해 RTP를 인터리빙하기 위해 정의된 프레이밍이 아니라 \[RFC4571\]에 정의된 프로토콜을 사용하여 프레이밍되어야 합니다.\(MUST\)

RTP/AVP/TCP를 통해 전송되는 미디어에 대한 성공적인 PAUSE 요청은 연결을 닫지 않고 연결을 통한 패킷 흐름을 일시 중지합니다. 성공적인 TEARDOWN 요청은 RTP 및 RTCP에 대한 TCP 연결이 RTSP 클라이언트에 의해 가능한 한 빨리 종료된다는 신호를 보냅니다.

RTP/AVP/TCP 전송 사양을 사용하여 RTSP 세션에 이미 설정된 URI를 사용하는 후속 SETUP 요청은 다음과 같은 방식으로 모호할 수 있습니다. 클라이언트가 URI에 대한 RTP 또는 RTCP에 대한 새 TCP 연결을 열려고 합니까? 클라이언트가 기존 TCP 연결을 계속 사용하기를 원합니까? 클라이언트는 의도를 명확하게 하기 위해 전송 라인에서 "connection" 매개변수\(섹션 18.54에 정의됨\)를 사용해야 합니다\(새 연결이 필요한 경우 "connection"을 "new"로 설정하고 "connection"을 "existing"으로 설정\). 기존 연결을 사용하려는 경우\). 새로운 연결에 대한 SETUP 요청에 대한 2xx 응답 후, 당사자는 길 잃은 RTP 또는 RTCP 패킷이 도착할 때까지 적절한 기간을 기다린 후 기존 연결을 닫아야 합니다.\(SHOULD\)

SRTP\(즉, SAVP 또는 SAVPF 프로필\)를 사용하려면 보안 연결을 설정해야 합니다. 해당 보안 연결을 설정하는 기본 메커니즘은 부록 C.1.4.1에 정의된 대로 RTSP와 함께 MIKEY\[RFC3830\]를 사용하는 것입니다.

아래에서는 "Media on Demand"\(부록 A.1\) 예제를 재작성한 버전에서 인터리브되지 않은 RTP/AVP/TCP 사용을 보여줍니다.

```text
      C->M: DESCRIBE rtsp://example.com/twister.3gp RTSP/2.0
            CSeq: 1
            User-Agent: PhonyClient/1.2

      M->C: RTSP/2.0 200 OK
            CSeq: 1
            Server: PhonyServer/1.0
            Date: Wed, 23 Jan 2013 15:36:52 +0000
            Content-Type: application/sdp
            Content-Length: 227
            Content-Base: rtsp://example.com/twister.3gp/
            Expires: Thu, 24 Jan 2013 15:36:52 +0000
```

v=0

- o=- 2890844256 2890842807 IN IP4 198.51.100.34 s=RTSP 세션 i=RTSP 세션 사용 예 e=adm@example.com c=IN IP4 0.0.0.0 a=control: \* a=range:npt=00: 00:00-00:10:34.10 t=0 0 m=오디오 0 RTP/AVP 0 a=제어: trackID=1

```text
      C->M: SETUP rtsp://example.com/twister.3gp/trackID=1 RTSP/2.0
            CSeq: 2
            User-Agent: PhonyClient/1.2
            Require: play.basic
            Transport: RTP/AVP/TCP;unicast;dest_addr=":9"/":9";
                       setup=active;connection=new
            Accept-Ranges: npt, smpte, clock

      M->C: RTSP/2.0 200 OK
            CSeq: 2
            Server: PhonyServer/1.0
            Transport: RTP/AVP/TCP;unicast;
                       dest_addr=":9"/":9";
                       src_addr="198.51.100.5:53478"/"198.51.100:54091";
                       setup=passive;connection=new;ssrc=93CB001E
            Session: OccldOFFq23KwjYpAnBbUr
            Expires: Thu, 24 Jan 2013 15:36:52 +0000
            Date: Wed, 23 Jan 2013 15:36:52 +0000
            Accept-Ranges: npt
            Media-Properties: Random-Access=0.8, Immutable, Unlimited

      C->M: TCP Connection Establishment x2

      C->M: PLAY rtsp://example.com/twister.3gp/ RTSP/2.0
            CSeq: 4
            User-Agent: PhonyClient/1.2
            Range: npt=30-
            Session: OccldOFFq23KwjYpAnBbUr

      M->C: RTSP/2.0 200 OK
            CSeq: 4
            Server: PhonyServer/1.0
            Date: Wed, 23 Jan 2013 15:36:54 +0000
            Session: OccldOFFq23KwjYpAnBbUr
            Range: npt=30-623.10
            Seek-Style: First-Prior
            RTP-Info:  url="rtsp://example.com/twister.3gp/trackID=1"
               ssrc=4F312DD8:seq=54321;rtptime=2876889
```

---
### **C.3.  Handling Media-Clock Time Jumps in the RTP Media Layer**

RTSP를 사용하면 미디어 클라이언트가 미디어 프리젠테이션의 선택된 비연속 섹션을 제어하고 RTP 미디어 계층\[RFC3550\]을 사용하여 해당 스트림을 렌더링할 수 있습니다. 두 가지 경우가 발생합니다. 첫 번째는 새로운 PLAY 요청이 기존의 진행 중인 요청을 대체하고 새 요청으로 인해 미디어가 급증하는 경우입니다. 이는 RTP 계층에서 지속적인 미디어 스트림을 생성해야 합니다. 클라이언트는 완료된 PLAY 요청에 즉시 새로운 PLAY 요청을 보낼 수도 있습니다. 이로 인해 미디어 계층에 약간의 간격이 발생합니다. 아래 텍스트에서는 두 가지 경우를 모두 살펴보겠습니다.

진행 중인 PLAY 요청을 대체하는 PLAY 요청을 사용하면 RTP 스트림을 렌더링하는 미디어 계층이 미디어 시계 시간의 점프에 영향을 받지 않고 지속적으로 그렇게 할 수 있습니다. 새 미디어 범위에 대한 RTP 타임스탬프는 이전 요청의 이전 미디어 범위와 연속되도록 설정됩니다. 새 범위의 첫 번째 패킷에 대한 RTP 시퀀스 번호는 이전 범위의 마지막 패킷 다음의 패킷이 됩니다. 즉, 단조롭게 증가합니다. 목표는 미디어 렌더링 계층이 미디어 시계의 점프에 걸쳐 중단이나 재구성 없이 작동할 수 있도록 하는 것입니다. 이는 임의 액세스 속성이 있는 미디어에 대한 교체된 PLAY 요청의 모든 경우에 가능해야 합니다. 이 경우 프레임이나 유사한 미디어 종속 구조를 정렬하는 데 주의가 필요합니다.

미디어 시계 시간의 점프가 완료된 PLAY 작업 이후에 도착하는 RTSP 신호 작업의 결과인 경우 요청 타이밍으로 인해 해당 미디어가 비연속적이 됩니다. 서버는 미디어를 보낼 수 없게 되어 미디어가 적시에 도착하고 미디어 스트림이 계속되도록 타임스탬프를 계속 전달합니다. 이러한 상황에서 서버는 RTP 스트림을 생성합니다.

미디어의 RTP 타임라인에 공백이 있습니다. 미디어에 프레임 구조가 있는 경우 다음 프레임의 타임스탬프를 이전 구조와 정렬하면 이 미디어를 렌더링하는 부담이 줄어듭니다. 간격은 서버가 미디어를 제공하지 않은 시간\(예: 미디어 스트림 끝 또는 PAUSE 요청과 새 PLAY 요청 사이의 시간\)을 나타내야 합니다. 이러한 경우 RTP 시퀀스 번호는 일반적으로 간격에 따라 단조롭게 증가합니다.

라이브 스트림과 같이 임의 액세스 속성이 없는 미디어를 사용하는 RTSP 세션의 경우 미디어 클럭 점프는 일반적으로 이에 상응하는 긴 전달 일시 중지로 인해 발생합니다. RTP 타임스탬프는 일시 중지된 전달 기간에 정비례하여 증가합니다. 또한 이 경우 RTP 시퀀스 번호는 다음 패킷 번호여야 합니다. 그렇지 않은 경우 RTCP 패킷 손실 보고는 일시 중지 시점과 나중에 재개하는 시점 사이에 수신되지 않은 모든 패킷을 손실로 표시합니다. 이로 인해 혼잡 회피 메커니즘이 트리거될 수 있습니다. 단조롭게 증가하는 RTP 시퀀스 번호에 대한 위 권장 사항에서 허용되는 예외는 실시간 미디어 스트림이며 중계될 가능성이 있습니다. 이 경우 클라이언트가 전달을 재개하면 현재 서버 자체에 전달되고 있는 미디어를 가져옵니다. 유니캐스트를 통해 여러 사용자에게 라이브 스트림을 기본적으로 전달하는 이러한 유형의 경우 RTP 시퀀스 번호를 개별적으로 다시 작성하는 것은 상당한 부담이 됩니다. 이미 미디어를 캐시하거나 타임 시프팅을 수행하는 솔루션의 경우 재작성으로 인한 부담은 미미합니다.

미디어 시계 시간의 점프를 처리할 때 목표는 제공된 스트림이 RTP 타임스탬프 또는 시퀀스 번호에 공백 없이 연속되는 것입니다. 그러나 어떤 이유로든 전달이 중단된 경우 재개 시 RTP 타임스탬프는 반드시 전달이 중단된 기간을 나타내야 합니다. RTP 시퀀스 번호는 일반적으로 다음 숫자여야 합니다\(예: 단조롭게 증가하는 모듈로 65536\). Time-Progressing 및 Time-Duration=0.0 속성을 가진 미디어 리소스의 경우 서버는 RTP 시퀀스 번호 점프로 인해 RTP 미디어 스트림을 생성할 수 있습니다. 클라이언트는 먼저 전달을 중단했다가 나중에 다시 시작합니다\(PAUSE 및 나중에 PLAY\). 그러나 이 예외를 활용하는 서버는 불연속성의 일부인 모든 패킷에 대한 손실 보고서를 포함할 가능성이 있는 결과 RTCP 수신기 보고서를 고려해야 합니다. 권장되는 경우에도 클라이언트는 플레이를 재개할 때 서버가 정렬된다는 사실에 의존할 수 없습니다. RTP-Info 헤더는 각 경우에 서버가 어떻게 작동하는지에 대한 정보를 제공합니다.\(MUST, MUST, MAY, SHOULD\)

- RTSP 클라이언트가 RTP 미디어 에이전트와 통신할 수 있다고 가정할 수는 없습니다. 둘은 독립적인 프로세스일 수 있기 때문입니다. RTP 타임스탬프가 NPT와 동일한 간격을 표시하는 경우 미디어 에이전트는 프레젠테이션에 일시 중지가 있다고 가정합니다. NPT의 점프가 충분히 크면 RTP 타임스탬프가 롤오버되고 미디어가

- 에이전트는 이후의 패킷이 방금 재생된 패킷의 중복이라고 믿을 수 있습니다. RTP 타임스탬프 점프가 있으면 이를 기반으로 하는 RTCP 측정에도 영향을 미칩니다.

예를 들어 RTP 타임스탬프 주파수가 8000Hz, 패킷화 간격이 100ms, 초기 시퀀스 번호와 타임스탬프가 0이라고 가정합니다.

```text
      C->S: PLAY rtsp://example.com/fizzle RTSP/2.0
        CSeq: 4
        Session: ymIqLXufHkMHGdtENdblWK
        Range: npt=10-15
        User-Agent: PhonyClient/1.2

      S->C: RTSP/2.0 200 OK
        CSeq: 4
        Session: ymIqLXufHkMHGdtENdblWK
        Range: npt=10-15
        RTP-Info: url="rtsp://example.com/fizzle/audiotrack"
                  ssrc=0D12F123:seq=0;rtptime=0
```

후속 RTP 데이터 스트림은 아래와 같습니다.

```text
      S -> C: RTP packet - seq = 0,  rtptime = 0,     NPT time = 10s
      S -> C: RTP packet - seq = 1,  rtptime = 800,   NPT time = 10.1s
       . . .
      S -> C: RTP packet - seq = 49, rtptime = 39200, NPT time = 14.9s
```

요청된 전달이 완료되면 서버는 PLAY\_NOTIFY를 보냅니다.

```text
        S->C: PLAY_NOTIFY rtsp://example.com/fizzle RTSP/2.0
              CSeq: 5
              Notify-Reason: end-of-stream
              Request-Status: cseq=4 status=200 reason="OK"
              Range: npt=-15
              RTP-Info:url="rtsp://example.com/fizzle/audiotrack"
                 ssrc=0D12F123:seq=49;rtptime=39200
              Session: ymIqLXufHkMHGdtENdblWK

        C->S: RTSP/2.0 200 OK
              CSeq: 5
              User-Agent: PhonyClient/1.2
```

플레이 범위가 완료되면 클라이언트는 새로운 NPT에서 플레이를 요청합니다.

```text
   C->S: PLAY rtsp://example.com/fizzle RTSP/2.0
         CSeq: 6
         Session: ymIqLXufHkMHGdtENdblWK
         Range: npt=18-20
         User-Agent: PhonyClient/1.2

   S->C: RTSP/2.0 200 OK
         CSeq: 6
         Session: ymIqLXufHkMHGdtENdblWK
         Range: npt=18-20
         RTP-Info: url="rtsp://example.com/fizzle/audiotrack"
                   ssrc=0D12F123:seq=50;rtptime=40100
```

후속 RTP 데이터 스트림은 아래와 같습니다.

```text
      S->C: RTP packet - seq = 50, rtptime = 40100, NPT time = 18s
      S->C: RTP packet - seq = 51, rtptime = 40900, NPT time = 18.1s
       . . .
      S->C: RTP packet - seq = 69, rtptime = 55300, NPT time = 19.9s
```

이 예에서는 먼저 NPT 10\~15가 재생된 다음 클라이언트는 서버에 앞으로 건너뛰고 NPT 18\~20을 재생하도록 요청합니다. 첫 번째 세그먼트는 시퀀스 번호 0\~49와 타임스탬프 0\~39,200이 있는 RTP 패킷으로 표시됩니다. 두 번째 세그먼트는 시퀀스 번호 50\~69, 타임스탬프 40,100\~55,200의 RTP 패킷으로 구성됩니다. NPT에는 간격이 있지만 RTP 데이터 스트림의 시퀀스 번호 공간에는 간격이 없습니다.

위의 예에서는 두 번째 재생 요청을 수행하는 데 걸리는 시간\(이 경우 12.5ms\(100/8000\)\)으로 인해 RTP 타임스탬프 간격이 존재합니다.

---
### **C.4.  Handling RTP Timestamps after PAUSE**

RTSP 세션에서 PAUSE/PLAY 상호 작용 중에 RTP 전송이 중단된 기간은 각 RTP 스트림의 RTP 타임스탬프에 반영되어야 합니다. PAUSE 요청이 수신되기 전 마지막 RTP 패킷이 전송된 시점과 후속 PLAY 요청이 수신된 후 첫 번째 RTP 패킷이 전송된 시점부터 경과된 시간으로 각 RTP 스트림에 대해 지속 시간을 계산할 수 있습니다. 기간에는 발생한 모든 지연 시간과 요청을 완료하는 데 필요한 처리 시간이 포함됩니다.\(MUST\)

- RFC 3550 \[RFC3550\]에서는 "각 장치\[패킷\]에 대한 RTP 타임스탬프는 해당 장치가 가상 프리젠테이션 타임라인에서 현재 상태가 되는 벽시계 시간과 관련됩니다"라고 명시합니다.

- \[RFC3550\]의 요구사항을 만족시키기 위해서는 RTP 타임스탬프 공간이 실시간으로 지속적으로 증가해야 합니다. 이는 저장된 미디어에 최적이 아니지만 RTP 및 RTCP가 의도한 대로 작동하려면 필요합니다. 연속적인 RTP 타임스탬프 공간을 사용하면 저장된 미디어와 라이브 미디어 모두에 대해 동일한 타임스탬프 모델이 가능하고 두 가지 유형의 미디어를 단일 제어로 통합할 수 있는 더 나은 기회가 제공됩니다.

예를 들어 클록 주파수가 8000Hz, 패킷화 간격이 100ms, 초기 시퀀스 번호와 타임스탬프가 0이라고 가정합니다.

```text
   C->S: PLAY rtsp://example.com/fizzle RTSP/2.0
         CSeq: 4
         Session: ymIqLXufHkMHGdtENdblWK
         Range: npt=10-15

         User-Agent: PhonyClient/1.2

   S->C: RTSP/2.0 200 OK
         CSeq: 4
         Session: ymIqLXufHkMHGdtENdblWK
         Range: npt=10-15
         RTP-Info: url="rtsp://example.com/fizzle/audiotrack"
                   ssrc=0D12F123:seq=0;rtptime=0
```

후속 RTP 데이터 스트림은 아래와 같습니다.

```text
      S -> C: RTP packet - seq = 0, rtptime = 0,    NPT time = 10s
      S -> C: RTP packet - seq = 1, rtptime = 800,  NPT time = 10.1s
      S -> C: RTP packet - seq = 2, rtptime = 1600, NPT time = 10.2s
      S -> C: RTP packet - seq = 3, rtptime = 2400, NPT time = 10.3s
```

그런 다음 클라이언트는 PAUSE 요청을 보냅니다.

```text
   C->S: PAUSE rtsp://example.com/fizzle RTSP/2.0
         CSeq: 5
         Session: ymIqLXufHkMHGdtENdblWK
         User-Agent: PhonyClient/1.2

   S->C: RTSP/2.0 200 OK
         CSeq: 5
         Session: ymIqLXufHkMHGdtENdblWK
         Range: npt=10.4-15
```

20초가 경과한 후 클라이언트가 PLAY 요청을 보냅니다. 또한 서버가 요청을 처리하는 데 15ms가 필요합니다.

```text
   C->S: PLAY rtsp://example.com/fizzle RTSP/2.0
         CSeq: 6
         Session: ymIqLXufHkMHGdtENdblWK
         User-Agent: PhonyClient/1.2

   S->C: RTSP/2.0 200 OK
         CSeq: 6
         Session: ymIqLXufHkMHGdtENdblWK
         Range: npt=10.4-15
         RTP-Info: url="rtsp://example.com/fizzle/audiotrack"
                   ssrc=0D12F123:seq=4;rtptime=164400
```

후속 RTP 데이터 스트림은 아래와 같습니다.

```text
      S -> C: RTP packet - seq = 4, rtptime = 164400, NPT time = 10.4s
      S -> C: RTP packet - seq = 5, rtptime = 165200, NPT time = 10.5s
      S -> C: RTP packet - seq = 6, rtptime = 166000, NPT time = 10.6s
```

먼저 NPT 10\~10.3이 재생된 다음 서버에서 PAUSE를 수신합니다. 20초 후에 서버는 처리하는 데 15ms가 걸리는 PLAY를 수신합니다. 세션이 일시 중지된 기간은 이 PLAY 요청 이후 전송된 RTP 패킷의 RTP 타임스탬프에 반영됩니다.

클라이언트는 RTSP Range 헤더와 RTP-Info 헤더를 사용하여 프레젠테이션의 NPT 시간을 RTP 타임스탬프와 매핑할 수 있습니다.

참고: RFC 2326 \[RFC2326\]에서는 이 사항이 명확하게 정의되지 않았으며 흔히 오해되었습니다. 그러나 RTSP 2.0의 경우 이는 올바르게 처리되며 예외 처리가 필요하지 않을 것으로 예상됩니다.

추가 참고: PLAY 요청을 발행할 때 올바른 미디어 디코딩 및 일반적인 지터 버퍼 처리를 보장하기 위해 일부 상태를 재설정해야 할 수도 있습니다.

---
### **C.5.  RTSP/RTP Integration**

특정 데이터 유형의 경우 RTSP 계층과 RTP 계층 간의 긴밀한 통합이 필요합니다. 이는 결코 위의 제한 사항을 배제하지 않습니다. 결합된 RTSP/RTP 미디어 클라이언트는 RTP-Info 필드를 사용하여 들어오는 RTP 패킷이 탐색 전이나 후 또는 PAUSE 전이나 후에 전송되었는지 확인해야 합니다.

---
### **C.6.  Scaling with RTP**

스케일링\(섹션 18.46 참조\)의 경우 RTP 타임스탬프는 렌더링 타이밍과 일치해야 합니다. 예를 들어 초당 30프레임으로 녹화된 비디오를 2배율과 1배속\(섹션 18.50\)으로 재생할 때 서버는 프레임당 3,000의 일반 타임스탬프 간격으로 비디오 패킷을 유지하고 전달하기 위해 매초마다 프레임을 삭제합니다. NPT는 각 비디오 프레임마다 1/15초씩 증가합니다.

- 참고: 위의 스케일링은 이를 지원하기 위한 미디어 코덱 또는 미디어 스트림에 대한 요구 사항을 적용합니다. 예를 들어 모션 JPEG 또는 기타 비예측 비디오 코딩을 사용하면 위의 예를 더 쉽게 처리할 수 있습니다.

---
### **C.7.  Maintaining NPT Synchronization with RTP Timestamps**

클라이언트는 재배치 후 도착하는 첫 번째 패킷의 RTP 타임스탬프 값을 확인하여 NPT의 올바른 표시를 유지할 수 있습니다. RTP-Info\(18.45절\) 헤더의 시퀀스 매개변수는 다음 세그먼트의 첫 번째 시퀀스 번호를 제공합니다.

---
### **C.8.  Continuous Audio**

연속 오디오의 경우 서버는 새로운 PLAY 요청 서비스 시작 시 또는 타임라인 점프 시 RTP 마커 비트를 설정해야 합니다. 이를 통해 클라이언트는 재생 지연 적응을 수행할 수 있습니다.\(SHOULD\)

---
### **C.9.  Multiple Sources in an RTP Session**

미디어 스트림에는 둘 이상의 SSRC가 전송될 수 있습니다. 이런 일이 발생하면 모든 소스가 동시에 렌더링될 것으로 예상됩니다.\(MAY\)

---
### **C.10.  Usage of SSRCs and the RTCP BYE Message during an RTSP Session**

RTCP BYE 메시지는 해당 SSRC의 사용 종료를 나타냅니다. 모든 소스가 RTP 세션을 종료하면 대부분의 경우 RTP 세션이 종료된 것으로 간주됩니다. 따라서 클라이언트나 서버는 RTCP를 보내면 안 됩니다.\(MUST NOT\)

SSRC 사용이 완료될 때까지 BYE 메시지를 보냅니다. 서버는 RTP 세션이 종료될 때까지 SSRC를 계속 사용해야 합니다. SSRC 사용을 연장하면 해당 SSRC와 연관된 설정된 동기화 컨텍스트를 사용하여 PLAY 응답이 늦더라도 후속 PLAY 요청을 동기화할 수 있습니다.\(SHOULD\)

미디어를 전송하는 SSRC와의 SSRC 충돌은 일반적으로 미디어 발신자가 RTP 사양\[RFC3550\]에 따라 SSRC를 변경하도록 강제하기 때문에 결과도 발생합니다. 그러나 RTSP 서버는 클라이언트가 변경되는지 기다렸다가 확인하여 충돌을 해결하여 영향을 최소화할 수 있습니다. 미디어 발신자로서 SSRC 변경으로 인해 동기화 컨텍스트가 손실되고 모든 수신자가 동기화된 재생을 수행하기 전에 동기화가 필요한 모든 미디어에 대한 RTCP 발신자 보고를 기다려야 합니다. 이러한 이유로 인해 세션에 참여하는 클라이언트는 서버가 ssrc 전송 헤더 매개변수에 표시하는 것과 동일한 SSRC를 선택하지 않도록 주의해야 합니다. 전송 헤더에 신호된 SSRC는 반드시 피해야 합니다. RTP 또는 RTCP 메시지를 보내기 전에 충돌을 감지한 클라이언트는 또한 새로운 SSRC를 선택해야 합니다.\(MUST, MUST\)

---
### **C.11.  Future Additions**

미디어 전달 및 하위 전송과 관련된 향후 프로토콜이나 프로필을 RTSP에 쉽게 추가할 수 있도록 하는 것이 목표입니다. 이 섹션에서는 충족해야 하는 필수 단계를 제공합니다.

RTSP와 함께 사용할 새 프로토콜이나 프로필을 추가할 때 다음 사항을 고려해야 합니다.

o 프로토콜이나 프로필은 이를 나타내는 이름 태그를 정의해야 합니다. 전송 헤더 사양에서 사용할 수 있으려면 이 태그가 ABNF "토큰"이어야 합니다.

o 이 확장을 위한 프로토콜, 프로필 및 하위 계층 전송의 유용한 조합을 정의해야 합니다. 각 조합에 대해 Transport 헤더에서 사용할 필수 매개변수를 선언합니다.

o 새로운 미디어 프로토콜의 경우 RTSP와의 상호 작용을 해결해야 합니다. 한 가지 중요한 요소는 미디어 동기화입니다. 이 정보를 전달하려면 RTP 정보와 유사한 새 헤더가 필요할 수 있습니다.

o 특히 내장된 혼잡 제어가 없는 전송이 사용되는 경우 미디어의 혼잡 제어에 관해 논의가 필요합니다.

새 속성을 등록하는 방법에 대한 자세한 내용은 IANA 고려 사항 섹션\(섹션 22\)을 참조하세요.

---
# **Appendix D.  Use of SDP for RTSP Session Descriptions**

세션 설명 프로토콜\(SDP, \[RFC4566\]\)은 RTSP의 스트림이나 프리젠테이션을 설명하는 데 사용될 수 있습니다. 이 설명은 일반적으로 서버에서 클라이언트로의 URI에 대한 DESCRIBE 요청에 대한 응답으로 반환되거나 HTTP를 통해 서버에서 클라이언트로 수신됩니다.

이 부록에서는 SDP 파일이 RTSP 세션의 작동을 결정하는 방법을 설명합니다. 따라서 SDP의 해석은 구성되는 SDP 수신기의 맥락에서 수행된다는 점을 지적할 가치가 있습니다. 이는 SAP \[RFC2974\]와 동일합니다. 이는 각 SDP가 이를 제공하는 에이전트의 컨텍스트에서 해석되는 SDP 제안/응답 \[RFC3264\]과 다릅니다.

SDP는 클라이언트가 사람의 안내 없이 동시에 렌더링할 여러 미디어 스트림과 대안 집합\(예: 서로 다른 언어로 사용되는 두 개의 오디오 스트림\)을 구별할 수 있는 메커니즘을 제공하지 않습니다. "SDP\(Session Description Protocol\) 그룹화 프레임워크"\[RFC5888\]에 있는 SDP 확장은 어느 정도 이러한 기능을 제공합니다. 부록 D.4에서는 RTSP용 SDP 미디어 회선 그룹화 사용법을 설명합니다.

---
### **D.1.  Definitions**

이 부록에 사용된 "세션 수준", "미디어 수준"이라는 용어와 기타 키/속성 이름 및 값은 SDP \[RFC4566\]에 정의된 대로 사용됩니다.

---
#### **D.1.1.  Control URI**

"a=control" 속성은 제어 URI를 전달하는 데 사용됩니다. 이 속성은 세션 및 미디어 설명 모두에 사용됩니다. 개별 미디어에 사용되는 경우 해당 특정 미디어 스트림을 제어하는 ​​데 사용되는 URI를 나타냅니다. 세션 수준에서 발견된 경우 속성은 집계 제어를 위한 URI\(프레젠테이션 URI\)를 나타냅니다. 세션 수준 URI는 미디어 수준 URI와 달라야 합니다. 세션 수준 제어 속성의 존재는 통합 제어에 대한 지원으로 해석되어야 합니다. 프레젠테이션에 단일 미디어 스트림만 포함되지 않는 한 제어 속성은 미디어 수준에 있어야 합니다. 이 경우 속성은 세션 수준에만 존재할 수 있으며 해당 단일 미디어 스트림에도 적용될 수 있습니다.\(MUST, MUST, MUST\)

속성에 대한 ABNF는 섹션 20.3에 정의되어 있습니다.

```text
   Example:

     a=control:rtsp://example.com/foo
```

이 속성은 RFC 3986 \[RFC3986\]에 명시된 규칙 및 규칙에 따라 상대 또는 절대 URI를 포함할 수 있습니다. 구현에서는 다음 순서로 기본 URI를 찾아야 합니다.\(MAY, MUST\)

```text
   1.  the RTSP Content-Base field;

   2.  the RTSP Content-Location field;
```

3. RTSP 요청-URI.

이 속성에 별표\(\*\)만 포함된 경우 URI는 빈 내장 URI인 것처럼 처리되어야 합니다. 따라서 전체 기본 URI를 상속합니다.\(MUST\)

- 참고: RFC 2326은 상대 URI 처리에 대해 매우 명확하지 않았으며 이 문서 게시 시점의 여러 RTSP 1.0 구현에서는 결과 URI를 결정하기 위한 RFC 3986 처리를 수행하지 않았습니다. 대신 간단한 연결이 일반적입니다. 이 문제를 완전히 방지하려면 SDP에서 절대 URI를 사용하는 것이 좋습니다.

컨테이너 파일의 SDP에 대한 URI 처리에는 특별한 고려가 필요합니다. 예를 들어 컨테이너 파일에 "rtsp://example.com/container.mp4"라는 URI가 있다고 가정해 보겠습니다. 또한 이 URI가 기본 URI이고 절대 미디어 수준 URI\("rtsp://example.com/container.mp4/trackID=2"\)가 있다고 가정해 보겠습니다. RFC 3986 \[RFC3986\]에 따라 위의 주어진 미디어 URI로 확인되는 상대 미디어 수준 URI는 "container.mp4/trackID=2"입니다. 일반적으로 컨테이너 파일의 서버 로컬 이름을 사용하여 컨테이너 파일 내에 저장된 SDP를 포함하거나 수정해야 하는 것은 바람직하지 않습니다. 이를 방지하려면 후행 슬래시를 포함하는 데 사용되는 기본 URI\(예: "rtsp://example.com/container.mp4/"\)를 수정할 수 있습니다. 이 경우 미디어의 상대 URI는 "trackID=2"만 있으면 됩니다. 그러나 이는 SDP에서 "\*"를 사용하면 후행 슬래시가 포함된 제어 URI가 생성된다는 의미이기도 합니다\(예: "rtsp://example.com/container.mp4/"\).

- 참고: 위의 TrackID 사용은 표준화된 형식이 아니지만 컨테이너 파일 내의 특정 미디어 부분을 나타내기 위해 여러 서버 공급업체에서 사용하는 TrackID, Track\_ID, StreamID와 같은 여러 유사한 문자열 중 하나의 예입니다.

---
#### **D.1.2.  Media Streams**

"m=" 필드는 스트림을 열거하는 데 사용됩니다. 지정된 모든 스트림이 적절한 동기화를 통해 렌더링될 것으로 예상됩니다. 세션이 멀티캐스트를 통해 진행되는 경우 표시된 포트 번호를 수신에 사용해야 합니다. 클라이언트는 전송 헤더를 통해 대상 포트를 재정의하려고 시도할 수 있습니다. 서버는 이를 허용할 수 있습니다. 응답은 이것이 허용되는지 여부를 나타냅니다. 세션이 유니캐스트인 경우 포트 번호는 사용할 수신기 포트에 대해 서버가 클라이언트에 권장하는 번호입니다. 클라이언트는 여전히 SETUP 요청에 수신자 포트를 포함해야 합니다. 클라이언트는 이 권장 사항을 무시할 수 있습니다. 서버에 기본 설정이 없으면 포트 번호 값을 0으로 설정해야 합니다.\(SHOULD, MAY, MAY, MUST, MAY, SHOULD\)

"m=" 행에는 미디어 스트림에 사용될 전송 프로토콜, 프로필 및 하위 계층에 대한 정보가 포함되어 있습니다. RTSP와 함께 사용하기 위해서는 전송, 프로파일 및 RTP/AVP/UDP와 같은 하위 계층의 조합이 정의되어야 합니다. 현재 정의된 조합은 부록 C에서 논의됩니다. 추가 조합을 지정할 수 있습니다.\(MAY\)

```text
   Example:

     m=audio 0 RTP/AVP 31
```

---
#### **D.1.3.  Payload Type(s)**

페이로드 유형은 "m=" 줄에 지정됩니다. 페이로드 유형이 RFC 3551 \[RFC3551\]의 정적 페이로드 유형인 경우 다른 정보가 필요하지 않을 수 있습니다. 동적 페이로드 유형인 경우 미디어 속성 "rtpmap"을 사용하여 미디어가 무엇인지 지정합니다. "rtpmap" 속성 내의 "인코딩 이름"은 \[RFC4856\]에 지정된 것, \[RFC4855\]에 따라 IANA에 등록된 미디어 유형 또는 SDP \[RFC4566\]에 지정된 실험적 인코딩 중 하나일 수 있습니다. 코덱별 매개변수는 이 필드에 지정되지 않고 아래 설명된 "fmtp" 속성에 지정됩니다.

서버에서 지원하려면 RTP 및 RTCP 다중화\[RFC5761\]를 고려하기 위해 사용되는 RTP 페이로드 유형 번호를 선택해야 할 수도 있습니다.

---
#### **D.1.4.  Format-Specific Parameters**

형식별 매개변수는 "fmtp" 미디어 속성을 사용하여 전달됩니다. "fmtp" 속성의 구문은 속성이 참조하는 인코딩에 따라 다릅니다. 참고로 일부는

형식별 매개변수는 "fmtp" 매개변수 외부에 지정될 수 있습니다. 예를 들어 대부분의 오디오 인코딩의 "ptime" 속성과 같습니다.

---
#### **D.1.5.  Directionality of Media Stream**

SDP 속성 "a=sendrecv", "a=recvonly" 및 "a=sendonly"는 세션 내에서 미디어 스트림 흐름 방향에 대한 지침을 제공합니다. RTSP를 사용하는 경우 RTSP DESCRIBE 또는 HTTP, FTP, 이메일과 같은 다양한 RTSP 외부 방법을 사용하여 SDP를 클라이언트에 전달할 수 있습니다. 이를 기반으로 SDP는 RTSP 클라이언트가 전체 세션을 보는 방법에 적용됩니다. 따라서 RTSP 서버에서 클라이언트로 전달되는 미디어 스트림에는 "a=recvonly" 속성이 부여됩니다.

RTSP 클라이언트에 제공된 SDP의 "a=recvonly"는 미디어 전달이 RTSP 서버에서 클라이언트 방향으로만 발생함을 나타냅니다. 방향성 속성\("a=recvonly", "a=sendonly", "a=sendrecv"\)이 부족한 RTSP 클라이언트에 제공된 SDP는 "a=sendrecv"를 갖는 것으로 해석됩니다. 이 글을 쓰는 시점에는 RTSP 클라이언트에서 서버로 향하는 미디어 트래픽에 적합한 RTSP 모드가 없습니다. 따라서 이 문서에 정의된 PLAY 모드를 사용할 때 모든 RTSP SDP는 "a=recvonly" 속성을 가져야 합니다. 클라이언트-서버 방향의 미디어에 대해 향후 모드가 정의되면 "a=sendonly" 또는 "a=sendrecv"의 사용이 의도된 미디어 방향을 나타내는 데 적합해질 수 있습니다.\(SHOULD\)

---
#### **D.1.6.  Range of Presentation**

"a=range" 속성은 저장된 세션 또는 개별 미디어의 전체 시간 범위를 정의합니다. 검색할 수 없는 라이브 세션은 아래와 같이 표시될 수 있습니다. 반면 라이브 세션의 길이는 "t=" 및 "r=" SDP 매개변수에서 추론할 수 있습니다.

속성은 세션 및 미디어 수준 속성입니다. 동일한 기간의 미디어 스트림을 포함하는 프리젠테이션의 경우 범위 속성은 세션 수준에서만 사용해야 합니다. 길이가 다른 경우 범위 속성은 모든 미디어에 대해 미디어 수준에서 제공되어야 하며 세션 수준에서 제공되어서는 안 됩니다. 속성이 미디어 수준과 세션 수준 모두에 존재하는 경우 미디어 수준 값을 사용해야 합니다.\(SHOULD, MUST, MUST\)

참고: 일반적으로 모든 미디어에서 전체 기간 동안 사용할 수 있는 미디어가 없더라도 모든 미디어에 대해 동일한 길이를 지정합니다. 그러나 이를 위해서는 서버가 해당 범위 내에서 PLAY 요청을 수락해야 합니다.

서버는 콘텐츠에 대해 SDP에 제시된 것과 일치하는 RTSP 범위\(섹션 18.40 참조\) 값을 제공하도록 주의를 기울여야 합니다. 요청 시 제공되는 미디어 클립과 같은 비동적 콘텐츠의 값이 일관되지 않을 이유가 없습니다. 클라이언트가 Range 헤더와 함께 PLAY 요청을 사용하는 경우 SDP와 서버에서 처리하는 콘텐츠의 실제 값이 일치하지 않으면 457 "잘못된 범위"와 같은 일부 오류가 발생할 수 있습니다. 콘텐츠의 길이가 동적이고 SDP에서 올바른 값을 제공하는 것이 불가능한 경우 서버는 이를 검색할 수 없는 콘텐츠로 설명하는 것이 좋습니다\(아래 참조\). 서버는 Range 헤더의 올바른 값을 사용하여 PLAY 요청에 대한 응답에서 해당 속성을 재정의할 수 있습니다.\(MUST, MAY\)

단위가 먼저 지정되고 그 뒤에 값 범위가 지정됩니다. 단위와 해당 값은 섹션 4.4.1, 섹션 4.4.2 및 섹션 4.4.3에 정의되어 있으며 추가 형식으로 확장될 수 있습니다. 모든 개방형 범위\(시작-\), 즉 중지 범위가 없는 기간은 지정되지 않으며 이 속성이 재정의되지 않는 한 검색할 수 없는 콘텐츠로 간주되어야 합니다. 서로 다른 시계 형식을 전달하는 여러 인스턴스가 세션 또는 미디어 수준에 포함될 수 있습니다.\(MAY, MUST, MAY\)

속성에 대한 ABNF는 섹션 20.3에 정의되어 있습니다.

```text
   Examples:

     a=range:npt=0-34.4368
     a=range:clock=19971113T211503Z-19971113T220300Z
     Non-seekable stream of unknown duration:
     a=range:npt=0-
```

---
#### **D.1.7.  Time of Availability**

"t=" 필드는 SDP가 유효한 시기를 정의합니다. 주문형 콘텐츠의 경우 서버는 설명이 유효함을 보장하는 중지 시간 값과 DESCRIBE 요청이 수신된 시간과 같거나 그 이전의 시작 시간을 표시해야 합니다. 또한 시작 및 중지 시간을 0으로 표시할 수도 있습니다. 이는 세션이 항상 사용 가능함을 의미합니다.\(SHOULD, MAY\)

라이브 유형의 세션\(예: 특정 시작 시간, 알 수 없는 중지 시간, 검색할 수 없는 경우\)의 경우 "t=" 및 "r=" 필드를 사용하여 이벤트 시작 시간을 표시해야 합니다. 정지 시간은 라이브 이벤트가 그 시간에 종료되도록 제공되어야 하며, 동시에 먼 미래에도 여전히 불필요하지 않습니다.\(SHOULD, SHOULD\)

---
#### **D.1.8.  Connection Information**

RTSP와 함께 사용되는 SDP에서 "c=" 필드에는 미디어 스트림의 대상 주소가 포함됩니다. 멀티캐스트 주소가 지정된 경우 클라이언트는 TTL과 같은 추가 매개변수를 포함하여 모든 SETUP 요청에서 이 주소를 대상 주소로 사용해야 합니다. 주문형 유니캐스트 스트림 및 일부 멀티캐스트 스트림의 경우 클라이언트가 SETUP 요청을 통해 대상 주소를 지정하여 지정된 주소를 재정의할 수 있습니다. 클라이언트가 대상 주소를 지정해야 하는 고정된 대상 주소가 없는 스트림을 식별하려면 "c=" 필드를 null 값으로 설정해야 합니다. "IP4" 유형의 주소의 경우 이 값은 "0.0.0.0"이어야 합니다. "IP6" 유형의 경우 이 값은 "0:0:0:0:0:0:0:0"이어야 합니다\("::"로 쓸 수도 있음\). 즉, RFC 4291에 따라 지정되지 않은 주소입니다. RFC4291\].\(SHOULD, MAY, SHOULD, MUST\)

---
#### **D.1.9.  Message Body Tag**

선택적 "a=mtag" 속성은 세션 설명의 버전을 식별합니다. 클라이언트에게는 불투명합니다. SETUP 요청은 이 속성 값이 현재 설명의 값과 여전히 일치하는 경우에만 세션 설정을 허용하기 위해 If-Match 필드\(섹션 18.24 참조\)에 이 식별자를 포함할 수 있습니다. 속성 값은 불투명하며 SDP 속성 값 내에서 허용되는 모든 문자를 포함할 수 있습니다.

속성에 대한 ABNF는 섹션 20.3에 정의되어 있습니다.

```text
   Example:

     a=mtag:"158bb3e7c7fd62ce67f12b533f06b83a"
```

"o=" 필드가 동일한 내용을 제공한다고 주장할 수도 있습니다.

- 기능성. 그러나 이는 동일한 미디어 콘텐츠에 대해 SDP 이외의 여러 세션 설명 유형을 지원해야 하는 서버에 제약을 가하는 방식으로 수행됩니다.

---
### **D.2.  Aggregate Control Not Available**

프레젠테이션이 집계 제어를 지원하지 않는 경우 세션 수준 "a=control" 속성이 지정되지 않습니다. 여러 미디어 섹션이 지정된 SDP의 경우 각 섹션에는 "a=control" 속성을 통해 지정된 자체 제어 URI가 있습니다.

```text
   Example:
```

v=0 o=- 2890844256 2890842807 IN IP4 192.0.2.56 s=웹페이지에서 왔습니다 e=adm@example.com c=IN IP4 0.0.0.0 t=0 0 m=video 8002 RTP/AVP 31 a=control :rtsp://audio.example.com/movie.aud m=audio 8004 RTP/AVP 3 a=control:rtsp://video.example.com/movie.vid

설명에서 제어 URI의 위치는 클라이언트가 audio.example.com 및 video.example.com 서버에 대해 별도의 RTSP 제어 세션을 설정한다는 것을 의미합니다.

RTSP가 아닌 수단을 통해 미디어 클라이언트에 전달되더라도 SDP 파일에는 완전한 미디어 초기화 정보가 포함되는 것이 좋습니다. 클라이언트가 DESCRIBE를 통해 더 자세한 미디어 스트림 정보를 요청해야 함을 나타내는 메커니즘이 없기 때문에 이는 필요합니다.

---
### **D.3.  Aggregate Control Available**

이 시나리오에서 서버에는 전체적으로 제어할 수 있는 여러 스트림이 있습니다. 이 경우 스트림 URI를 지정하는 데 사용되는 미디어 수준 "a=control" 속성과 집계 제어를 위한 요청 URI로 사용되는 세션 수준 "a=control" 속성이 모두 있습니다. . 미디어 수준 URI가 상대인 경우 위의 부록 D.1.1에 따라 절대 URI로 확인됩니다.

```text
   Example:

   C->M: DESCRIBE rtsp://example.com/movie RTSP/2.0
         CSeq: 1
         User-Agent: PhonyClient/1.2

   M->C: RTSP/2.0 200 OK
         CSeq: 1
         Date: Wed, 23 Jan 2013 15:36:52 +0000
         Expires: Wed, 23 Jan 2013 16:36:52 +0000
         Content-Type: application/sdp
         Content-Base: rtsp://example.com/movie/
         Content-Length: 227
```

v=0

- o=- 2890844256 2890842807 IN IP4 192.0.2.211 s=I 포함 i=<추가 정보\> e=adm@example.com c=IN IP4 0.0.0.0 a=control:\* t=0 0 m=video 8002 RTP/ AVP 31 a=컨트롤:트랙ID=1 m=오디오 8004 RTP/AVP 3 a=컨트롤:트랙ID=2

이 예에서 클라이언트는 서버에 대한 단일 RTSP 세션을 설정하는 것이 좋으며 URI rtsp://example.com/movie/trackID=1 및 rtsp://example.com/movie/trackID=2를 사용합니다. 비디오 및 오디오 스트림을 각각 설정합니다. "\*"로 해석되는 URI rtsp://example.com/movie/는 전체 프레젠테이션\(영화\)을 제어합니다.

클라이언트는 집계 개체 내의 모든 스트림에 대해 SETUP 요청을 발행할 필요가 없습니다. 서버는 클라이언트가 스트림의 하위 집합만 요청할 수 있도록 허용해야 합니다.

---
### **D.4.  Grouping of Media Lines in SDP**

일부 미디어 유형의 경우 립싱크나 SVC\(Scalable Video Codec\) \[RFC5583\]와 같은 다양한 미디어 구성 요소 간의 관계를 표현하는 것이 바람직합니다. 이 관계는 \[RFC5888\]에 설명된 대로 미디어 라인을 그룹화하여 SDP 수준에서 표현되며 RTSP에 노출될 수 있습니다.

RTSP의 경우 SDP를 통해 수신된 그룹화된 미디어를 처리하는 방법을 아는 것이 중요합니다. 즉, 미디어가 집합적으로 제어되는 경우\(부록 D.3 참조\) 또는 집합적인 제어를 사용할 수 없는 경우\(부록 D.2 참조\) .

클라이언트가 전체 프레젠테이션 또는 단일 미디어를 제어할 수 있는 기능을 제공하려면 그룹화된 미디어를 총체적 제어로 처리하는 것이 좋습니다.\(SHOULD\)

---
### **D.5.  RTSP External SDP Delivery**

세션 설명이 RTSP 외부\(예: HTTP 또는 이메일\)를 통해 클라이언트에 전달될 때 고려해야 할 몇 가지 사항이 있습니다.

우선, SDP에는 절대 URI가 포함되어야 합니다. 대부분의 경우 배달이 기본 URI를 올바르게 전달하지 않기 때문에 상대 URI가 작동하지 않기 때문입니다.

SDP 세션 가용성 정보\(예: "t=" 및 "r="\) 작성을 신중하게 고려해야 합니다. DESCRIBE 메소드로 SDP를 가져오면 해당 SDP가 유효할 확률이 매우 높습니다. 그러나 다른 방법을 사용하여 배포된 SDP의 경우에도 마찬가지입니다. 따라서 SDP 게시자는 섹션 4.2의 SDP 사양 \[RFC4566\]의 가용성에 대한 권장 사항을 주의 깊게 따라야 합니다.

---
# **Appendix E.  RTSP Use Cases**

이 부록에서는 RTSP의 가장 중요하고 고려되는 사용 사례를 설명합니다. 필요한 모든 기능이 존재하는지 확인하는 것과 관련하여 중요도 내림차순으로 나열되어 있습니다. 이 사양은 처음 두 가지의 사용만을 완전히 지원합니다. 또한 처음 두 가지 경우에는 확장 없이는 지원되지 않는 특별한 경우나 예외가 있습니다\(예: 제어 에이전트\(클라이언트\)의 주소가 아닌 주소로 미디어 전달 리디렉션\).

---
### **E.1.  On-Demand Playback of Stored Content**

RTSP 지원 서버는 클라이언트로 스트리밍하기에 적합한 콘텐츠를 저장합니다. 저장된 콘텐츠를 재생하려는 클라이언트는 RTSP를 사용하여 원하는 콘텐츠를 전달하는 데 필요한 미디어 전송을 설정합니다. 그런 다음 RTSP는 콘텐츠의 실제 전송\(재생\)을 시작, 중지 및 조작하는 데 사용됩니다. 콘텐츠에 필요한 설명 및 동기화 정보를 제공하려면 RTSP도 필요합니다.

위의 개략적인 설명은 RTSP가 수행해야 하는 여러 기능으로 나눌 수 있습니다.

프레젠테이션 설명: 프레젠테이션\(콘텐츠\)에 대한 초기화 정보를 제공합니다. 예를 들어 콘텐츠에 필요한 미디어 코덱이 있습니다. 중요한 기타 정보로는 프레젠테이션에 포함된 미디어 스트림 수, 미디어 스트림에 사용되는 전송 프로토콜, 이러한 미디어 스트림에 대한 식별자 등이 있습니다. 이 정보는 콘텐츠 설정이 가능하고 클라이언트가 콘텐츠를 사용할 수 있는지 확인하기 전에 필요합니다.

- 이 정보는 RTSP를 사용하여 전송될 필요가 없습니다. 다른 외부 프로토콜을 사용하여 전송 표시 설명을 전송할 수 있습니다. 두 가지 좋은 예는 HTTP \[RFC7230\] 또는 이메일을 사용하여 SDP \[RFC4566\]와 같은 프레젠테이션 설명을 가져오거나 받는 것입니다.

설정: 프레젠테이션의 미디어 스트림 중 일부 또는 전부를 설정합니다. 설정 자체는 미디어 전송을 위한 프로토콜과 주소 및 포트와 같은 프로토콜에 필요한 매개변수를 선택하는 것으로 구성됩니다.

전송 제어: 필요한 미디어 스트림이 설정된 후 클라이언트는 서버에 콘텐츠 전송을 시작하도록 요청할 수 있습니다. 클라이언트는 임의의 시간에 콘텐츠 전송을 시작하거나 중지할 수 있어야 합니다. 또한 클라이언트는 프레젠테이션 타임라인의 어느 시점에서나 전송을 시작할 수 있어야 합니다.

동기화: RTP \[RFC3550\]와 같은 미디어 전송 프로토콜의 경우 RTSP 내에서 동기화 정보를 전달하는 것이 유리할 수 있습니다. 이는 프로토콜 자체 내에서 미디어 간 동기화가 부족하거나 동기화가 설정되기 전 잠재적인 지연\(RTCP를 사용할 때 RTP의 경우\) 때문일 수 있습니다.

종료: 설정된 컨텍스트를 종료합니다.

이 사용 사례에는 작동 방식에 대한 여러 가지 가정이 있습니다. 이것들은:

주문형 콘텐츠: 콘텐츠는 서버에 저장되며, 사용 가능하도록 의도된 기간 동안 언제든지 액세스할 수 있습니다.

독립 세션: 서버는 프레젠테이션 타임라인의 서로 다른 지점에 있는 동일한 콘텐츠를 포함하여 여러 클라이언트에 동시에 서비스를 제공할 수 있습니다.

유니캐스트 전송: 각 개별 클라이언트의 콘텐츠는 유니캐스트 트래픽을 사용하여 클라이언트로 전송됩니다.

미디어 트래픽을 트래픽을 제어하는 ​​에이전트가 아닌 다른 대상으로 리디렉션하는 것도 가능합니다. 그러나 대상이 이를 승인하는지 확인하는 적절한 메커니즘 없이 이를 허용하면 분산 DoS\(DDoS\)가 허용됩니다.

---
### **E.2.  Unicast Distribution of Live Content**

이 사용 사례는 위의 주문형 콘텐츠 사례\(부록 E.1 참조\)와 유사하지만 차이점은 콘텐츠 자체의 특성입니다. 라이브 콘텐츠는 소스에서 사용 가능해지면 지속적으로 배포됩니다. 즉, 주문형과의 주요 차이점은 콘텐츠가 서버에 제공되기 전에 콘텐츠 배포를 시작한다는 것입니다.

대부분의 경우 라이브 콘텐츠 소비자는 "지금" 실제로 일어나는 일에만 관심이 있습니다. 즉, 방송 TV와 매우 유사합니다. 그러나 이 경우에는 사용자에게 브로드캐스트나 멀티캐스트 채널이 존재하지 않고, 대신 서버가 서버와 클라이언트 간의 유니캐스트 트래픽을 사용하여 동일한 콘텐츠를 여러 수신자에게 보내는 배포 노드 역할을 한다고 가정합니다. 이 유니캐스트 트래픽과 전송 매개변수는 각 수신 클라이언트에 대해 개별적으로 협상됩니다.

라이브 콘텐츠의 또 다른 측면은 콘텐츠가 다루는 이벤트 기간 동안에만 사용할 수 있기 때문에 가용성 시간이 매우 제한되는 경우가 많다는 것입니다. 이러한 라이브 콘텐츠의 예로는 2시간 동안 지속되고 미리 결정된 시간에 시작되는 음악 콘서트가 있을 수 있습니다. 따라서 라이브 콘텐츠를 언제, 얼마나 오랫동안 이용할 수 있는지 공지할 필요가 있습니다.

경우에 따라 라이브 콘텐츠를 제공하는 서버는 클라이언트가 스트림을 일시 중지하고 일시 중지된 지점에서 다시 시작하거나 라이브 지점보다 이전 지점에서 계속해서 "되감기"하고 재생할 수 있도록 콘텐츠의 일부 또는 전부를 저장할 수 있습니다. 따라서 이 사용 사례는 스트림의 라이브 지점 이외의 곳에서의 재생, 1.0 이외의 스케일을 사용한 재생 등을 반드시 배제하지는 않습니다.

---
### **E.3.  On-Demand Playback Using Multicast**

RTSP를 사용하여 미디어가 멀티캐스트 그룹에 전달되도록 요청할 수 있습니다. 세션을 설정하는 엔터티\(컨트롤러\)는 언제 어떤 미디어가 그룹에 전달되는지 제어합니다. 이 사용 사례에는 멀티캐스트 그룹을 플러딩하여 DoS 공격이 발생할 가능성이 있습니다. 따라서 그룹이 실제로 RTSP 서버의 트래픽을 수락한다는 것을 나타내는 메커니즘이 필요합니다.

이 사용 사례에서 열린 문제는 멀티캐스트 또는 브로드캐스트를 수신하는 모든 수신기가 수신기를 구성하는 세션 프리젠테이션을 수신하도록 보장하는 방법입니다. 이 사양은 이 문제를 해결하기 위해 외부 솔루션에 의존해야 합니다.

---
### **E.4.  Inviting an RTSP Server into a Conference**

컨퍼런스 또는 그룹 세션이 설정된 경우 RTSP 서버가 미디어를 전체 그룹에 배포하도록 할 수 있습니다. 그룹으로의 전송은 단일 참가자 또는 회의 리더가 제어할 때 가장 간단합니다. 공유 제어가 가능할 수도 있지만 추가 조사와 확장이 필요할 수 있습니다.

이 사용 사례에서는 모든 참가자에게 미디어를 재분배하는 멀티캐스트 또는 컨퍼런스 포커스가 있다고 가정합니다.

이 사용 사례는 다음과 같은 시나리오를 처리할 수 있도록 고안되었습니다. 회의 리더 또는 참가자\(이하 "컨트롤러"라고 함\)가 그룹과 공유하려는 RTSP 서버에 사전 저장된 콘텐츠를 가지고 있습니다. 컨트롤러는 이 콘텐츠에 대해 스트리밍 서버에서 RTSP 세션을 설정하고 콘텐츠에 대한 세션 설명을 검색합니다. 미디어 콘텐츠의 대상은 공유 멀티캐스트 그룹 또는 컨퍼런스 포커스로 설정됩니다. 컨트롤러는 원하는 경우 회의 그룹에 대한 미디어 전송을 시작하고 중지할 수 있습니다.

이 사용 사례에는 RTSP에 대한 핵심 사양으로 해결되지 않은 몇 가지 문제가 있습니다.

DoS: RTSP 서버가 DoS 공격에 무의식적으로 참여하는 것을 방지하려면 서버가 대상의 미디어 승인을 확인할 수 있어야 합니다. 수신된 미디어의 승인을 확인하는 메커니즘은 아직 존재하지 않습니다. 대신 통제된 환경에서 작동하도록 만들 수 있는 정책만 사용할 수 있습니다.

그룹의 모든 참가자에게 프레젠테이션 설명 배포: 미디어 수신기가 콘텐츠를 올바르게 디코딩할 수 있도록 하려면 미디어 구성 정보가 모든 참가자에게 안정적으로 배포되어야 합니다. 이를 위해서는 외부 프로토콜의 지원이 필요할 가능성이 높습니다.

- 세션 제어 전달: 참가자 간에 RTSP 세션 제어를 전달하려면 외부 프로토콜에서 상태 정보를 교환하고 RTSP 세션을 제어하는 ​​사람에 대한 플로어 제어를 일부 지원해야 합니다.

---
### **E.5.  Live Content Using Multicast**

가장 간단한 형태의 이 사용 사례에서는 RTSP를 전혀 사용할 필요가 없습니다. 이것이 바로 SAP \[RFC2974\] 및 SDP를 통해 발표된 멀티캐스트 회의가 처리하도록 의도된 것입니다. 그러나 멀티캐스트 세션에 대한 액세스 제어와 같은 고급 기능이 필요한 사용 사례에서는 세션 설정에 RTSP를 사용할 수 있습니다.

암호화\(암호화\) 액세스 제어를 사용하여 라이브 멀티캐스트 미디어 세션에 참여하려는 클라이언트는 다음과 같은 방법으로 RTSP를 사용할 수 있습니다. 세션 소스는 세션을 알리고 관심 있는 모든 사람에게 RTSP URI를 제공합니다. 클라이언트는 서버에 연결하고 프레젠테이션 설명을 요청하여 미디어 수신을 위한 구성을 허용합니다. 이 단계에서는 클라이언트가 보안 전송 및 원하는 인증 수준을 사용할 수 있습니다. 예를 들어 청구 또는 액세스 제어의 경우입니다. RTSP 링크를 사용하면 여러 서버 간의 로드 밸런싱도 가능합니다.

이것이 유일한 목표라면 단순히 HTTP를 사용하여 달성할 수 있습니다. 그러나 발신자가 세션의 각 개별 수신자를 추적하고 키 업데이트 또는 기타 정보를 수신자별로 배포하기 위한 사이드 채널로 세션을 사용하기를 원하며 전체 수신자 세트가 다음과 같은 경우에는 가능합니다. 세션 시작 전에 알려지지 않은 경우 RTSP가 제공하는 상태 설정이 도움이 될 수 있습니다. 이 경우 클라이언트는 RTSP 서버와 함께 이 멀티캐스트 그룹에 대한 RTSP 세션을 설정합니다. RTSP 서버는 미디어를 전송하지 않고 대신 멀티캐스트 그룹을 가리킵니다. 클라이언트와 서버는 수신자가 세션에 참여하는 동안 세션을 활성 상태로 유지할 수 있으므로 예를 들어 서버가 클라이언트에 업데이트를 푸시할 수 있습니다.

이 사용 사례는 서버-클라이언트 푸시 메커니즘에 대한 일부 확장 없이는 구현되지 않을 가능성이 높습니다. 여기서 적절한 확장을 갖춘 PLAY\_NOTIFY 메서드\(13.5절 참조\)는 분명한 이점을 제공할 수 있습니다.

---
# **Appendix F.  Text Format for Parameters**

"텍스트/매개변수" 유형의 리소스는 1\) 매개변수 목록\(쿼리용\) 또는 2\) 매개변수 및 관련 값 목록\(매개변수 응답 또는 설정용\)으로 구성됩니다. 목록의 각 항목은 한 줄의 텍스트입니다. 매개변수는 콜론으로 값과 구분됩니다. 매개변수 이름은 US-ASCII 표시 문자만 사용해야 하며 값은 UTF-8 텍스트 문자열이어야 합니다. 미디어 유형 등록 양식은 섹션 22.16에 있습니다.\(MUST\)

이 형식에는 잠재적인 상호 운용성 문제가 있습니다. RFC 2326에서 이름이 지정되었지만 구문을 암시하는 예제에 사용된 경우에도 정의되지 않았습니다. 이 형식은 목적과 일치하며 해당 구문은 제공된 예제를 지원합니다. 그러나 값 부분에서 UTF-8을 허용함으로써 더 나아갑니다. 따라서 UTF-8 문자열 사용이 지원되지 않을 수 있습니다. 그러나 개별 매개변수가 정의되지 않았으므로 구현 애플리케이션은 대역 외 합의를 갖거나 어쨌든 기능 태그를 사용하여 엔드포인트가 매개변수를 지원하는지 확인해야 합니다.

"텍스트/매개변수" 콘텐츠에 대한 ABNF \[RFC5234\] 문법은 다음과 같습니다.

```text
   file             = *((parameter / parameter-value) CRLF)
   parameter        = 1*visible-except-colon
   parameter-value  = parameter *WSP ":" value
   visible-except-colon = %x21-39 / %x3B-7E    ; VCHAR - ":"
   value            = *(TEXT-UTF8char / WSP)
   TEXT-UTF8char    = <as defined in Section 20.1>
   WSP              = <See RFC 5234> ; Space or HTAB
   VCHAR            = <See RFC 5234>
   CRLF             = <See RFC 5234>
```

---
# **Appendix G.  Requirements for Unreliable Transport of RTSP**

이 부록은 RTSP 1.0 \[RFC2326\]에 정의된 대로 신뢰할 수 없는 전송을 통해 RTSP 메시지를 구현하려는 사용자를 위한 지침을 제공합니다. RFC 2326은 "rtspu" URI 체계를 정의하고 UDP를 통한 RTSP 메시지 전송에 대한 몇 가지 기본 정보를 제공했습니다. 적어도 하나의 상업적 구현이 있었고 그와의 호환성이 유지되어야 하므로 여기에 정보가 제공됩니다.

상호 운용 가능한 구현을 위해서는 다음 사항을 고려해야 합니다.

o 요청은 수신자에 의해 승인되어야 합니다. 확인이 없으면 보낸 사람은 RTT\(왕복 시간\) 시간 초과 후 동일한 메시지를 다시 보낼 수 있습니다. 승인 부족으로 인한 모든 재전송에는 원래 요청과 동일한 시퀀스 번호가 있어야 합니다.

o RTT는 초기 왕복 값이 500ms인 TCP\(RFC 6298\) \[RFC6298\]에서와 같이 추정할 수 있습니다. 구현에서는 마지막 RTT 측정값을 향후 연결을 위한 초기 값으로 캐시할 수 있습니다.

o 타임스탬프 헤더\(섹션 18.53\)는 다음을 방지하는 데 사용됩니다.

- 재전송 모호성 문제 \[Stevens98\].

o 서버의 UDP를 통한 RTSP에 등록된 기본 포트는 554입니다.

o RTSP 메시지는 8비트 깨끗한 하위 계층 전송 프로토콜을 통해 전달될 수 있습니다.

o RTSP 메시지는 비트 오류에 취약하므로 비트 오류가 발생해서는 안 됩니다.

o 소스 인증 또는 적어도 RTSP 메시지가 동일한 엔터티에서 온 것인지 확인하는 것이 매우 중요해집니다. TCP보다 UDP와 같은 신뢰할 수 없는 프로토콜을 사용하는 RTSP 메시지 전송의 경우 세션 하이재킹이 훨씬 더 쉬울 수 있기 때문입니다.

신뢰할 수 없는 RTSP 메시지 처리에 주로 사용되며 유지 관리되는 두 개의 RTSP 헤더가 있습니다.

o CSeq: 섹션 18.20을 참조하세요. 신뢰할 수 있는 전송이 사용되는지 또는 신뢰할 수 없는 전송이 사용되는지 여부에 관계없이 요청과 응답을 일치시키기 위해 CSeq 헤더도 필요하다는 점에 유의해야 합니다.

```text
   o  Timestamp: See Section 18.53
```

---
# **Appendix H.  Backwards-Compatibility Considerations**

이 섹션에는 RFC 2326 \[RFC2326\]에 따라 구현되는 클라이언트 또는 서버와의 하위 호환성 문제에 대한 참고 사항이 포함되어 있습니다. RTSP 1.0을 구현하기 위한 요구 사항은 없습니다. 실제로 이 문서에서는 상호 운용 가능한 방식으로 수행하기 어렵기 때문에 이를 권장하지 않습니다.

RTSP 2.0을 구현하는 서버는 "RTSP/2.0"의 RTSP 버전 값을 포함하는 요청에 대한 모든 응답에 "RTSP/2.0"의 RTSP 버전을 포함해야 합니다. 서버가 RTSP 1.0 요청을 수신하고 RFC 2326을 지원하기로 선택한 경우 RTSP 1.0 응답으로 응답할 수 있습니다. 서버가 RFC 2326을 지원하지 않기로 선택한 경우 505\(RTSP 버전은 지원되지 않음\) 상태 코드로 응답해야 합니다. 서버는 RTSP 2.0 응답으로 RTSP 1.0 요청에 응답해서는 안 됩니다.\(MUST, MAY, MUST, MUST NOT\)

RTSP 2.0을 구현하는 클라이언트는 "RTSP/2.0"의 RTSP 버전과 함께 OPTIONS 요청을 사용하여 서버가 RTSP 2.0을 지원하는지 여부를 확인할 수 있습니다. 서버가 RTSP 버전 "RTSP/1.0" 또는 상태 코드 505\(RTSP 버전 지원되지 않음\)로 응답하는 경우 클라이언트는 RFC 2326 지원을 선택하면 RTSP 1.0 요청을 사용해야 합니다.\(MAY\)

---
### **H.1.  Play Request in Play State**

Play 상태에서 Play가 수신될 때 서버의 동작이 변경되었습니다\(13.4절\). RFC 2326에서는 현재 재생이 완료될 때까지 새 PLAY 요청이 대기열에 추가됩니다. 이제 새로운 PLAY 요청은 이전 요청을 대체하여 즉시 적용됩니다.

---
### **H.2.  Using Persistent Connections**

RFC 2326의 일부 서버 구현은 연결과 RTSP 세션 간의 일대일 관계를 유지합니다. 이러한 구현에서는 클라이언트가 서버와 통신하기 위해 지속적인 연결을 사용해야 하며, 클라이언트가 연결을 닫으면 서버는 RTSP 세션을 제거할 수 있습니다. 1.0도 지원하는 RTSP 2.0 클라이언트가 1.0 서버에 연결되는 경우 이는 주목할 가치가 있습니다.

---
# **Appendix I.  Changes**

이 부록에는 정보 제공을 위해 RTSP 1.0 \[RFC2326\]과 RTSP 2.0 간의 차이점이 간략하게 나열되어 있습니다. RTSP 2.0 구현자의 경우 이 메모를 주의 깊게 읽고 RTSP 1.0에서 RTSP 2.0으로 조정하기 위해 아래 변경 사항 목록에 의존하지 않는 것이 좋습니다. RTSP 2.0은 RTSP 1.0 \[RFC2326\]과 하위 호환되도록 설계되지 않았기 때문입니다. 버전 협상 메커니즘 이외의 것.

---
### **I.1.  Brief Overview**

RTSP 1.0과 비교하여 RTSP 2.0에서는 다음 프로토콜 요소가 제거되었습니다.

```text
   o  the RECORD and ANNOUNCE methods and all related functionality
      (including 201 (Created) and 250 (Low On Storage Space) status
      codes);

   o  the use of UDP for RTSP message transport (due to missing interest
      and to broken specification);
```

o Play 상태에서 연결 유지를 위해 PLAY 메서드를 사용합니다.

RTSP 1.0과 비교하여 RTSP 2.0에서는 다음 프로토콜 요소가 추가되거나 변경되었습니다.

```text
   o  RTSP session TEARDOWN from the server to the client;

   o  IPv6 support;

   o  extended IANA registries (e.g., transport headers parameters,
      transport-protocol, profile, lower-transport, and mode);

   o  request pipelining for quick session start-up;

   o  fully reworked state machine;

   o  RTSP messages now use URIs rather than URLs;

   o  incorporated much of related HTTP text ([RFC2616]) in this memo,
      compared to just referencing the sections in HTTP, to avoid
      ambiguities;

   o  the REDIRECT method was expanded and diversified for different
      situations;

   o  Includes a new section about how to set up different media-
      transport alternatives and their profiles in addition to lower-
      layer protocols.  This caused the appendix on RTP interaction to
      be moved to the new section instead of being in the part that
      describes RTP.  The section also includes guidelines what to
      consider when writing usage guidelines for new protocols and
      profiles;
```

o 비동기 알림 메소드 PLAY\_NOTIFY를 추가했습니다. 이 메서드는 RTSP 서버에서 재생 상태에 있는 동안 클라이언트에게 세션 변경 사항을 비동기적으로 알리는 데 사용됩니다. 제한된 범위 내에서 이는 녹음용이 아닌 RTSP 1.0의 일부 ANNOUNCE 구현과 유사합니다.

---
### **I.2.  Detailed List of Changes**

RTSP 2.0을 정의할 때 RTSP 1.0\(RFC 2326\)에 다음과 같은 변경 사항이 적용되었습니다. 이 목록에는 문구의 사소한 변경이나 인쇄상의 오류 수정이 반영되지 않았습니다.

o 최소 구현 섹션이 삭제되었습니다. 대신, 사양의 주요 부분은 RTSP 2.0의 핵심을 정의합니다.

o 전송 헤더가 다음과 같이 변경되었습니다.

- \* 확장이 가능하고 알 수 없는 매개변수로 인해 서버가 전송 사양을 무시하게 된다는 점을 정의하기 위해 ABNF가 변경되었습니다.

- \* 이전 버전과의 호환성 문제를 방지하려면 모든 확장 또는 새 매개변수에는 Require 헤더와 결합된 기능 태그를 사용해야 합니다.

- \* 모드 매개변수의 구문 모호성이 해결되었습니다.

- \* ";" 구문 오류 멀티캐스트 및 유니캐스트에 대한 문제가 해결되었습니다.

- \* 두 개의 새로운 주소 지정 매개변수\(src\_addr 및 dest\_addr\)가 정의되었습니다. 이는 "port", "client\_port", "server\_port", "destination" 및 "source" 매개변수를 대체합니다.

- \* 모든 주소 필드에 IPv6 명시적 주소에 대한 지원이 포함되었습니다.

- \* ";"를 포함하는 URI 정의를 처리하려면 또는 ",", 인용된 URI 형식이 도입되었으며 필수입니다.

- \* 전송 헤더 매개변수, 전송 프로토콜, 프로파일, 하위 전송 및 모드에 대한 IANA 레지스트리가 정의되었습니다.

- \* 전송 헤더의 인터리브 매개변수 텍스트가 더욱 엄격해졌으며 공식적인 요구 사항 수준을 사용합니다. 인터리빙된 채널은 대칭이며 채널 번호를 설정하는 것은 서버라는 점도 명확해졌습니다.

- \* 전송 매개변수 SSRC가 포함된 요청을 사용하여 클라이언트가 특정 RTP SSRC를 사용하도록 서버에 요청할 수 없다는 것이 명확해졌습니다.

- \* SSRC의 구문 정의가 8HEX를 요구하도록 명확해졌습니다. 또한 이 버전을 지원하는 클라이언트에 대해 여러 값을 허용하도록 확장되었습니다.

- \* 서버가 수행해야 하는 보안 예방 조치와 관련하여 전송 헤더의 "dest\_addr" 매개변수에 대한 텍스트를 명확히 했습니다.

o 범위 형식이 다음과 같이 변경되었습니다.

- \* NPT 형식에는 이제 사용해야 하는 초기 NPT 식별자가 제공되었습니다.

- \* 이제 모든 형식은 "npt=-10" 유형의 초기 개방형 형식을 지원하며 GET\_PARAMETER 요청과 함께 사용할 수 있도록 "범위: smpte" 범위만 형식화합니다.

- \* npt-hhmmss 표기법은 이제 ISO 8601을 더욱 엄격하게 따릅니다.

o RTSP 메시지 처리가 다음과 같이 변경되었습니다.

- \* 이제 RTSP 메시지는 URL이 아닌 URI를 사용합니다.

- \* CSeq 헤더 누락으로 인한 4xx 메시지는 CSeq 헤더 없이 반환되어야 함을 명확히 했습니다.

- \* 300\(복수 선택\) 응답 코드가 제거되었습니다.

- \* 타임아웃된 RTSP 메시지 처리 방법에 대한 규칙이 추가되었습니다.

- \* 빠른 세션 시작을 허용하는 확장된 파이프라이닝 규칙.

- \* 응답이 순서대로 도착하지 않는 경우를 포함하여 시퀀스 번호 매기기 및 시퀀스 번호의 프록시 처리가 정의되었습니다.

o HTTP 참조가 첫 번째 RFC 2616 및 2617로 업데이트된 다음 RFC 7230-7235로 업데이트되었습니다. 대부분의 텍스트는 복사된 후 이 사양에 맞게 RTSP에 맞게 변경되었습니다. Public 및 Content-Base 헤더도 RFC 2068에서 가져와서 RTSP 사양에 정의되어 있습니다. HTTP 설명으로 인해 RTSP에 대해 알려진 효과:

\* Content-Encoding 헤더에는 다음 유형의 인코딩이 포함될 수 있습니다.

-     "신원".

o 상태 머신 섹션이 완전히 재작성되었습니다. 이제 더 자세한 내용이 포함되어 있으며 사용된 모델에 대해서도 더 명확해졌습니다.

o 여러 레지스트리와 해당 규칙을 포함하는 IANA 섹션이 포함되었습니다. 이를 통해 IANA를 사용하여 RTSP 확장을 추적할 수 있습니다.

o RTSP 메시지 전송이 다음과 같이 변경되었습니다.

- \* RTSP 메시지 전송을 위한 UDP 사용은 관심 없음 및 사양 위반으로 인해 더 이상 사용되지 않습니다.

- \* TCP 연결 처리 방법에 대한 규칙이 명확해졌습니다. 이제 서버가 상당한 시간 동안 사용되지 않은 경우가 아니면 TCP 연결을 닫아서는 안 된다는 것이 분명해졌습니다.

- \* 서버와 클라이언트가 영구 연결을 사용해야 하는 강력한 권장 사항도 추가되었습니다.

- \* 이제 내결함성을 제공하는 비지속적 연결을 처리하기 위해 서버에 대한 요구 사항이 있습니다.

- \* RTSP에 대한 연결:닫기 사용에 대한 문구가 추가되었습니다.

- \* 다음 홉에 대한 프록시의 TLS 연결을 승인하는 체계를 포함하여 RTSP 메시지에 대해 지정된 TLS 사용.

o 헤더 관련 변경 사항은 다음과 같습니다.

- \* Accept-Range 응답 헤더가 추가되었습니다. 이 헤더는 리소스에 사용할 수 있는 범위 형식을 명시합니다.

- \* Cache-Control 헤더에 대한 누락된 정의를 수정했습니다. 또한 max-stale 및 min-fresh 매개변수에 대한 누락된 델타 초가 구문 정의에 추가되었습니다.

- \* 새로운 RTSP 요청마다 값이 1씩 증가하도록 CSeq 헤더에 요구 사항을 추가합니다. 0에서 시작하라는 권장 사항도 추가되었습니다.

- \* 메시지 본문이 있는 모든 메시지에 날짜 헤더를 사용해야 하고 서버가 항상 이를 포함해야 한다는 요구 사항이 추가되었습니다.

- \* 정의된 대로 작동할 수 없기 때문에 활성화될 시기를 나타내기 위해 Scale 헤더와 함께 Range 헤더를 사용할 가능성을 제거했습니다. 또한 응답에 Scale 헤더가 없으면 헤더에 대한 지원이 부족함을 나타내는 규칙이 추가되었습니다. 확장된 재생을 위한 기능 태그가 정의되었습니다.

- \* 지원 및 사용될 실제 속도를 나타내려면 이제 Speed ​​헤더에 응답해야 합니다. 기능 태그가 정의됩니다. 혼잡 제어에 대한 참고 사항도 추가되었습니다.

- \* Supported 헤더는 RTSP의 기능 협상을 돕기 위해 SIP \[RFC3261\]에서 차용되었습니다.

- \* 타임스탬프 헤더를 사용하여 재전송 모호성을 해결할 수 있음을 명확히 했습니다.

- \* 세션 헤더 텍스트가 연결 유지 및 사용 방법에 대한 설명으로 확장되었습니다. 이제 RTSP 내에서 연결 유지가 필요한 경우에만 SET\_PARAMETER를 사용하는 것이 좋습니다.

- \* PAUSE 응답에서 일시정지 지점을 표시하기 위해 Range 헤더 형식을 사용하는 방법이 명확해졌습니다.

- \* 상대 RTP-정보 URI가 요청-URI를 기본 URI로 사용한다는 점을 명확히 했습니다. 또한 사용된 URI는 SETUP 요청에 사용된 URI여야 함을 명시했습니다. 이제 URI도

- 인용이 필요합니다. 헤더는 제공된 RTP 타임스탬프 및 시퀀스 번호 값에 대한 SSRC도 표현합니다.

- \* PLAY 응답에 항상 Range가 있어야 한다는 텍스트가 추가되었습니다. 실시간 스트림의 경우 무엇을 전송해야 하는지 명시했습니다.

- \* 헤더 테이블은 SIP에서 빌린 구조를 사용하여 업데이트되었습니다. 이러한 테이블은 훨씬 더 많은 정보를 전달하며 사용 가능한 헤더에 대한 좋은 개요를 제공해야 합니다.

- \* 메시지 본문이 있는 모든 메시지에는 Content-Length 헤더가 있어야 한다는 점이 명확해졌습니다. 이는 RFC 2326의 경우이지만 잘못 해석될 수 있습니다.

- \* ETag가 MTag로 이름이 변경되었습니다.

- \* MTag 관련 기능을 해결하기 위해 MTag 및 If-None-Match 헤더가 RTSP 작업과 관련하여 필요한 설명과 함께 HTTP에서 추가되었습니다.

- \* 사용 부족으로 인해 HTTP에서 공용 헤더가 제거되었으므로 HTTP\(RFC 2068 \[RFC2068\]\)에서 공용 헤더를 가져왔습니다. 공개는 RTSP에서 매우 자주 사용됩니다.

- \* 공개 헤더를 채우기 위한 규칙을 명확히 하여 체인에 있는 모든 RTSP 에이전트 기능의 교차점입니다.

\* 현재 목록을 나열하기 위해 Media-Range 헤더를 추가했습니다.

- 미디어 범위의 가용성.

- \* PLAY\_NOTIFY 요청을 보낼 때 이유를 제공하기 위해 Notify-Reason 헤더를 추가했습니다.

- \* 탐색 작업이 수행되어야 하는 방법을 지시하고 알리기 위해 새로운 헤더 탐색 스타일이 정의되었습니다.

o 프로토콜 구문이 다음과 같이 변경되었습니다.

- \* 모든 ABNF 정의는 RFC 5234 \[RFC5234\]에 정의된 규칙에 따라 업데이트되며 별도의 섹션\(섹션 20\)에 수집되었습니다.

- \* User-Agent 및 Server 헤더의 ABNF가 수정되었습니다.

- \* RTSP 세션에 대한 소개의 일부 정의가 변경되었습니다.

- \* 프로토콜은 완전히 IPv6를 지원하도록 만들어졌습니다.

- \* CHAR 규칙이 NULL을 제외하도록 변경되었습니다.

o 상태 코드가 다음과 같이 변경되었습니다.

- \* 상태 코드 303\(기타 참조\)은 RTSP에서 사용하는 것이 적합하지 않으므로 더 이상 사용되지 않습니다.

- \* 정의되지 않은 상태 코드 411 "길이 필요"가 완전히 제거되었습니다.

- \* 응답 451\(매개변수를 이해하지 못함\) 및 458\(매개변수는 읽기 전용\)을 보낼 때 응답 본문에는 문제가 되는 매개변수가 포함되어야 합니다.

- \* 3rr 리디렉션 상태 코드를 수신할 수 있는 시기에 대한 설명이 추가되었습니다. 여기에는 설정된 세션 내 요청의 결과로 3rr을 받는 것이 포함됩니다. 이는 이전의 지정되지 않은 동작에 대한 설명을 제공합니다.

- \* 201\(생성됨\) 및 250\(저장 공간 부족\) 상태 코드는 녹화에만 관련되어 더 이상 사용되지 않으므로 제거되었습니다.

- \* 몇 가지 새로운 상태 코드가 정의되었습니다: 464\(데이터 전송이 아직 준비되지 않음\), 465\(알림 이유 알 수 없음\), 470\(연결 인증 필요\), 471\(연결 자격 증명이 허용되지 않음\) 및 472\(보안 연결 설정 실패\) .

o 다음 기능은 프로토콜에서 더 이상 사용되지 않습니다.

- \* 대기열 재생을 사용합니다.

- \* Play 상태에서 keep-alive를 위해 PLAY 메소드를 사용합니다.

- \* RECORD 및 ANNOUNCE 방법 및 모든 관련 기능. 일부 구문이 제거되었습니다.

- \* Range 헤더의 시간 매개변수를 사용하여 시간에 따른 메서드 실행을 사용할 수 있습니다.

- \* rtspu 작동 방식에 대한 설명은 핵심 사양의 일부가 아니며 외부 설명이 필요합니다. 여기에는 그것이 존재한다는 것만 언급되며 운송에 대한 일부 요구 사항이 제공됩니다.

o 방법과 관련하여 다음과 같은 변경 사항이 적용되었습니다.

- \* Public 및 Allow 헤더 사용과 관련하여 OPTIONS 메서드가 명확해졌습니다.

- \* 연결 유지 및 본문 없이 사용을 위한 SET\_PARAMETER 사용법을 명확히 설명하는 텍스트를 추가했습니다.

- \* 이제 PLAY 메소드는 집계된 제어를 위한 세션을 생성하는 초기 요청에 이어 하나 이상의 SETUP 요청을 파이프라인하여 파이프라인할 수 있습니다.

- \* REDIRECT가 상황에 맞게 확장되고 다양해졌습니다.

- \* 새로운 메소드 PLAY\_NOTIFY를 추가했습니다. 이 방법은 RTSP 서버에서 클라이언트에게 세션 변경 사항을 비동기적으로 알리는 데 사용됩니다.

o 다양한 미디어 전송 대안과 해당 프로필, 하위 계층 프로토콜을 설정하는 방법에 대한 새 섹션을 작성했습니다. 이로 인해 RTP 상호 작용에 대한 부록이 RTP를 설명하는 부분이 아닌 새로운 섹션으로 이동되었습니다. 새 섹션에는 새 프로토콜 및 프로필에 대한 사용 지침을 작성할 때 고려해야 할 지침도 포함되어 있습니다.

o RTP 전송을 위한 독립적인 TCP 연결 설정 및 사용이 지정되었습니다.

o 기능이 지원되는지 확인하기 위해 사용 가능한 메커니즘을 설명하는 "기능 처리"라는 새 섹션을 추가했습니다. 옵션 태그의 이름을 기능 태그로 바꾸었습니다.

o 사양에 실제 텍스트를 기고한 사람들이 포함된 기여자 섹션을 추가했습니다.

o RTSP의 주요 사용 사례를 설명하는 "사용 사례" 섹션을 추가했습니다.

o a=range의 사용법과 이 헤더로 검색할 수 없는 라이브 콘텐츠를 표시하는 방법을 명확히 했습니다.

o 라이브 콘텐츠에 대한 PLAY의 특수 동작을 지정하는 텍스트입니다.

o RTSP의 보안 기능이 명확해졌습니다.

- \* 기본 및 다이제스트 지원이 모두 필요한 HTTP 기반 인증이 명확해졌습니다.

- \* TLS 지원이 의무화되었습니다.

- \* RTP를 구현하는 경우 SRTP 및 정의된 MIKEY 기반 키 교환이 지원되어야 합니다.

- \* 다양한 사소한 완화가 논의되거나 프로토콜 변경으로 이어졌습니다.

---
# **Acknowledgements**

본 각서는 \[RFC2326\]에 정의된 제안 표준 RTSP 버전 1.0의 개정판인 RTSP 버전 2.0을 정의합니다. RFC 2326의 작성자는 Henning Schulzrinne, Anup Rao 및 Robert Lanphier입니다.

RTSP 버전 1.0과 RTSP 버전 2.0은 모두 HTTP/1.1의 형식과 설명을 차용합니다.

Robert Sparks와 특히 Elwyn Davies는 IETF Last Call에서 매우 귀중하고 자세한 리뷰를 제공하여 문서를 크게 개선하고 특히 일관성과 관련된 많은 문제를 해결했습니다.

이 문서는 MMUSIC WG에 참여하는 모든 분들의 의견으로부터 큰 도움을 받았습니다. 이미 언급된 사람들 외에도 다음 개인이 이 사양에 기여했습니다.

라훌 아가르왈, 클라우디오 알로키오, 제프 아야스, 밀코 보이치, 토르스텐 브라운, 브렌트 브라우닝, 브루스 버터필드, 스티브 캐스너, 모린 체셔, 최진항, 프란시스코 코르테스, 엘윈 데이비스, 스펜서 도킨스, 켈리 자한다리, 마틴 던스뮤어, 아드리안 파렐, 스티븐 파렐 , Ross Finlayson, Eric Fleischman, Jay Geagan, Andy Grignon, Christian Groves, V. Guruprasad, Peter Haight, Mark Handley, Brad Hefta-Gaub, Volker Hilt, John K. Ho, Patrick Hoffman, Go Hori, Philipp Hoschka, Anne Jones , Ingemar Johansson, 김재환, Anders Klemets, Ruth Lang, Barry Leiba, Stephanie Leif, Jonathan Lennox, Eduardo F. Llach, Chris Lonvick, Xavier Marjou, Thomas Marshall, Rob McCool, Martti Mela, David Oran, Joerg Ott, 조 팔라스, 마리아 파파도풀리, 수잘 파텔, 에마 파트키, 알라구 페리얀난, 콜린 퍼킨스, 페카 페시, 이고르 플로트니코프, 피트 레스닉, 피터 세인트 안드레, 홀거 슈미트, 조나단 서전트, 피나키 샤, 데이비드 싱어, 라이어 시온, 제프 스미스, Alexander Sokolsky, Dale Stammen, John Francis Stracke, Geetha Srikantan, Scott Taylor, David Walker, Stephan Wenger, Dale R. Worley, 윤병조, 특히 Flemming Andreasen.

---
# **Contributors**

다음 사람들은 사양에 포함된 서면 기여를 했습니다.

o Tom Marshall은 3rr 상태 코드 사용에 대한 텍스트를 기고했습니다.

o Thomas Zheng은 PLAY 응답에서 Range 사용에 대한 텍스트를 제공하고 PLAY\_NOTIFY 메서드의 이전 버전을 제안했습니다.

o Sean Sheedy는 RTSP 메시지 및 연결의 시간 초과 동작, 463\(대상 금지\) 상태 코드에 대한 텍스트를 제공하고 PLAY\_NOTIFY 메서드의 이전 버전을 제안했습니다.

o Greg Sherwood는 PLAY\_NOTIFY 방법의 이전 버전을 제안했습니다.

o Fredrik Lindholm이 RTSP 보안에 관한 텍스트를 기고했습니다.

- 프레임워크.

o John Lazzaro는 독립 TCP를 통한 RTP에 대한 텍스트를 기고했습니다.

o Aravind Narasimhan은 "Media-Transport Alternatives"\(부록 C\)를 다시 작성하고 사양의 여러 위치에서 편집 기능을 개선함으로써 기여했습니다.

o Torbjorn Einarsson은 텍스트 편집을 일부 개선했습니다.

---
# **Authors' Addresses**

헤닝 슐츠린 컬럼비아 대학교 1214 Amsterdam Avenue New York, NY 10027 미국

```text
   Email: schulzrinne@cs.columbia.edu
```

아누프 라오 Cisco 미국

```text
   Email: anrao@cisco.com
```

Rob Lanphier 샌프란시스코, 캘리포니아 미국

```text
   Email: robla@robla.net

   Magnus Westerlund
   Ericsson
   Faeroegatan 2
   Stockholm  SE-164 80
   Sweden

   Email: magnus.westerlund@ericsson.com
```

Martin Stiemerling \(편집자\) 응용과학대학교 다름슈타트 Haardtring 100 64295 다름슈타트 독일

```text
   Email: mls.ietf@gmail.com
   URI:   http://www.stiemerling.org
```
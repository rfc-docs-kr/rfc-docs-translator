

```text
Network Working Group                                   F. Baker, Editor
Request for Comments: 1812                                 Cisco Systems
Obsoletes: 1716, 1009                                          June 1995
Category: Standards Track

                 Requirements for IP Version 4 Routers
```

---
# **Status of this Memo**

이 문서는 인터넷 커뮤니티를 위한 인터넷 표준 추적 프로토콜을 지정하고 개선을 위한 토론 및 제안을 요청합니다. 이 프로토콜의 표준화 상태 및 상태에 대해서는 "Internet Official Protocol Standards"\(STD 1\) 최신판을 참조하십시오. 이 메모의 배포는 무제한입니다.

---
# **PREFACE**

이 문서는 역사적인 라우터 요구 사항 문서인 RFC 1716의 업데이트 버전입니다. 해당 RFC는 작업 그룹에 들어간 중요한 작업을 보존했지만 IESG가 이를 현재 표준으로 간주할 수 있도록 현재 기술을 적절하게 설명하지 못했습니다.

현재 편집자는 문서를 최신 상태로 유지하여 조달 사양 및 구현자에 대한 지침으로 유용하도록 요청받았습니다. 이 점에서 그는 자신보다 먼저 간 사람들의 어깨 위에 당당하게 서 있으며 전문적인 텍스트 기고자에게 크게 의존합니다. 모든 신용은 그들의 것입니다. 오류는 그의 것입니다.

이 문서의 내용과 형식은 대부분 실무 그룹의 의장이자 문서의 원 편집자이자 저자인 Philip Almquist에 의해 작성되었습니다. 이는 이전 편집자인 Frank Kastenholz의 노력에도 크게 기인합니다. 그들의 노력이 없었다면 이 문서는 존재하지 않았을 것입니다.

---
# **Table of Contents**

```text
   1. INTRODUCTION ........................................    6
   1.1 Reading this Document ..............................    8
   1.1.1 Organization .....................................    8
   1.1.2 Requirements .....................................    9
   1.1.3 Compliance .......................................   10
   1.2 Relationships to Other Standards ...................   11
   1.3 General Considerations .............................   12
   1.3.1 Continuing Internet Evolution ....................   12
   1.3.2 Robustness Principle .............................   13
   1.3.3 Error Logging ....................................   14
   1.3.4 Configuration ....................................   14
   1.4 Algorithms .........................................   16
   2. INTERNET ARCHITECTURE ...............................   16
   2.1 Introduction .......................................   16
   2.2 Elements of the Architecture .......................   17
   2.2.1 Protocol Layering ................................   17
   2.2.2 Networks .........................................   19
   2.2.3 Routers ..........................................   20
   2.2.4 Autonomous Systems ...............................   21
   2.2.5 Addressing Architecture ..........................   21
   2.2.5.1 Classical IP Addressing Architecture ...........   21
   2.2.5.2 Classless Inter Domain Routing (CIDR) ..........   23
   2.2.6 IP Multicasting ..................................   24
   2.2.7 Unnumbered Lines and Networks Prefixes ...........   25
   2.2.8 Notable Oddities .................................   26
   2.2.8.1 Embedded Routers ...............................   26
   2.2.8.2 Transparent Routers ............................   27
   2.3 Router Characteristics .............................   28
   2.4 Architectural Assumptions ..........................   31
   3. LINK LAYER ..........................................   32
   3.1 INTRODUCTION .......................................   32
   3.2 LINK/INTERNET LAYER INTERFACE ......................   33
   3.3 SPECIFIC ISSUES ....................................   34
   3.3.1 Trailer Encapsulation ............................   34
   3.3.2 Address Resolution Protocol - ARP ................   34
   3.3.3 Ethernet and 802.3 Coexistence ...................   35
   3.3.4 Maximum Transmission Unit - MTU ..................   35
   3.3.5 Point-to-Point Protocol - PPP ....................   35
   3.3.5.1 Introduction ...................................   36
   3.3.5.2 Link Control Protocol (LCP) Options ............   36
   3.3.5.3 IP Control Protocol (IPCP) Options .............   38
   3.3.6 Interface Testing ................................   38
   4. INTERNET LAYER - PROTOCOLS ..........................   39
   4.1 INTRODUCTION .......................................   39
   4.2 INTERNET PROTOCOL - IP .............................   39
   4.2.1 INTRODUCTION .....................................   39
   4.2.2 PROTOCOL WALK-THROUGH ............................   40
   4.2.2.1 Options: RFC 791 Section 3.2 ...................   40
   4.2.2.2 Addresses in Options: RFC 791 Section 3.1 ......   42
   4.2.2.3 Unused IP Header Bits: RFC 791 Section 3.1 .....   43
   4.2.2.4 Type of Service: RFC 791 Section 3.1 ...........   44
   4.2.2.5 Header Checksum: RFC 791 Section 3.1 ...........   44
   4.2.2.6 Unrecognized Header Options: RFC 791,
           Section 3.1 ....................................   44
   4.2.2.7 Fragmentation: RFC 791 Section 3.2 .............   45
   4.2.2.8 Reassembly: RFC 791 Section 3.2 ................   46
   4.2.2.9 Time to Live: RFC 791 Section 3.2 ..............   46
   4.2.2.10 Multi-subnet Broadcasts: RFC 922 ..............   47
   4.2.2.11 Addressing: RFC 791 Section 3.2 ...............   47
   4.2.3 SPECIFIC ISSUES ..................................   50
   4.2.3.1 IP Broadcast Addresses .........................   50
   4.2.3.2 IP Multicasting ................................   50
   4.2.3.3 Path MTU Discovery .............................   51
   4.2.3.4 Subnetting .....................................   51
   4.3 INTERNET CONTROL MESSAGE PROTOCOL - ICMP ...........   52
   4.3.1 INTRODUCTION .....................................   52
   4.3.2 GENERAL ISSUES ...................................   53
   4.3.2.1 Unknown Message Types ..........................   53
   4.3.2.2 ICMP Message TTL ...............................   53
   4.3.2.3 Original Message Header ........................   53
   4.3.2.4 ICMP Message Source Address ....................   53
   4.3.2.5 TOS and Precedence .............................   54
   4.3.2.6 Source Route ...................................   54
   4.3.2.7 When Not to Send ICMP Errors ...................   55
   4.3.2.8 Rate Limiting ..................................   56
   4.3.3 SPECIFIC ISSUES ..................................   56
   4.3.3.1 Destination Unreachable ........................   56
   4.3.3.2 Redirect .......................................   57
   4.3.3.3 Source Quench ..................................   57
   4.3.3.4 Time Exceeded ..................................   58
   4.3.3.5 Parameter Problem ..............................   58
   4.3.3.6 Echo Request/Reply .............................   58
   4.3.3.7 Information Request/Reply ......................   59
   4.3.3.8 Timestamp and Timestamp Reply ..................   59
   4.3.3.9 Address Mask Request/Reply .....................   61
   4.3.3.10 Router Advertisement and Solicitations ........   62
   4.4 INTERNET GROUP MANAGEMENT PROTOCOL - IGMP ..........   62
   5. INTERNET LAYER - FORWARDING .........................   63
   5.1 INTRODUCTION .......................................   63
   5.2 FORWARDING WALK-THROUGH ............................   63
   5.2.1 Forwarding Algorithm .............................   63
   5.2.1.1 General ........................................   64
   5.2.1.2 Unicast ........................................   64
   5.2.1.3 Multicast ......................................   65
   5.2.2 IP Header Validation .............................   67
   5.2.3 Local Delivery Decision ..........................   69
   5.2.4 Determining the Next Hop Address .................   71
   5.2.4.1 IP Destination Address .........................   72
   5.2.4.2 Local/Remote Decision ..........................   72
   5.2.4.3 Next Hop Address ...............................   74
   5.2.4.4 Administrative Preference ......................   77
   5.2.4.5 Load Splitting .................................   79
   5.2.5 Unused IP Header Bits: RFC-791 Section 3.1 .......   79
   5.2.6 Fragmentation and Reassembly:  RFC-791,
         Section 3.2 ......................................   80
   5.2.7 Internet Control Message Protocol - ICMP .........   80
   5.2.7.1 Destination Unreachable ........................   80
   5.2.7.2 Redirect .......................................   82
   5.2.7.3 Time Exceeded ..................................   84
   5.2.8 INTERNET GROUP MANAGEMENT PROTOCOL - IGMP ........   84
   5.3 SPECIFIC ISSUES ....................................   85
   5.3.1 Time to Live (TTL) ...............................   85
   5.3.2 Type of Service (TOS) ............................   86
   5.3.3 IP Precedence ....................................   87
   5.3.3.1 Precedence-Ordered Queue Service ...............   88
   5.3.3.2 Lower Layer Precedence Mappings ................   89
   5.3.3.3 Precedence Handling For All Routers ............   90
   5.3.4 Forwarding of Link Layer Broadcasts ..............   92
   5.3.5 Forwarding of Internet Layer Broadcasts ..........   92
   5.3.5.1 Limited Broadcasts .............................   93
   5.3.5.2 Directed Broadcasts ............................   93
   5.3.5.3 All-subnets-directed Broadcasts ................   94
   5.3.5.4  Subnet-directed Broadcasts ....................   94
   5.3.6 Congestion Control ...............................   94
   5.3.7 Martian Address Filtering ........................   96
   5.3.8 Source Address Validation ........................   97
   5.3.9 Packet Filtering and Access Lists ................   97
   5.3.10 Multicast Routing ...............................   98
   5.3.11 Controls on Forwarding ..........................   98
   5.3.12 State Changes ...................................   99
   5.3.12.1 When a Router Ceases Forwarding ...............   99
   5.3.12.2 When a Router Starts Forwarding ...............  100
   5.3.12.3 When an Interface Fails or is Disabled ........  100
   5.3.12.4 When an Interface is Enabled ..................  100
   5.3.13 IP Options ......................................  101
   5.3.13.1 Unrecognized Options ..........................  101
   5.3.13.2 Security Option ...............................  101
   5.3.13.3 Stream Identifier Option ......................  101
   5.3.13.4 Source Route Options ..........................  101
   5.3.13.5 Record Route Option ...........................  102
   5.3.13.6 Timestamp Option ..............................  102
   6. TRANSPORT LAYER .....................................  103
   6.1 USER DATAGRAM PROTOCOL - UDP .......................  103
   6.2 TRANSMISSION CONTROL PROTOCOL - TCP ................  104
   7. APPLICATION LAYER - ROUTING PROTOCOLS ...............  106
   7.1 INTRODUCTION .......................................  106
   7.1.1 Routing Security Considerations ..................  106
   7.1.2 Precedence .......................................  107
   7.1.3 Message Validation ...............................  107
   7.2 INTERIOR GATEWAY PROTOCOLS .........................  107
   7.2.1 INTRODUCTION .....................................  107
   7.2.2 OPEN SHORTEST PATH FIRST - OSPF ..................  108
   7.2.3 INTERMEDIATE SYSTEM TO  INTERMEDIATE  SYSTEM  -
         DUAL IS-IS .......................................  108
   7.3  EXTERIOR GATEWAY PROTOCOLS ........................  109
   7.3.1  INTRODUCTION ....................................  109
   7.3.2 BORDER GATEWAY PROTOCOL - BGP ....................  109
   7.3.2.1 Introduction ...................................  109
   7.3.2.2 Protocol Walk-through ..........................  110
   7.3.3 INTER-AS ROUTING WITHOUT AN  EXTERIOR  PROTOCOL
         ..................................................  110
   7.4 STATIC ROUTING .....................................  111
   7.5 FILTERING OF ROUTING INFORMATION ...................  112
   7.5.1 Route Validation .................................  113
   7.5.2 Basic Route Filtering ............................  113
   7.5.3 Advanced Route Filtering .........................  114
   7.6 INTER-ROUTING-PROTOCOL INFORMATION EXCHANGE ........  114
   8. APPLICATION LAYER - NETWORK  MANAGEMENT  PROTOCOLS
      .....................................................  115
   8.1 The Simple Network Management Protocol - SNMP ......  115
   8.1.1 SNMP Protocol Elements ...........................  115
   8.2 Community Table ....................................  116
   8.3 Standard MIBS ......................................  118
   8.4 Vendor Specific MIBS ...............................  119
   8.5 Saving Changes .....................................  120
   9. APPLICATION LAYER - MISCELLANEOUS PROTOCOLS .........  120
   9.1 BOOTP ..............................................  120
   9.1.1 Introduction .....................................  120
   9.1.2 BOOTP Relay Agents ...............................  121
   10. OPERATIONS AND MAINTENANCE .........................  122
   10.1 Introduction ......................................  122
   10.2 Router Initialization .............................  123
   10.2.1 Minimum Router Configuration ....................  123
   10.2.2 Address and Prefix Initialization ...............  124
   10.2.3 Network Booting using BOOTP and TFTP ............  125
   10.3 Operation and Maintenance .........................  126
   10.3.1 Introduction ....................................  126
   10.3.2 Out Of Band Access ..............................  127
   10.3.2 Router O&M Functions ............................  127
   10.3.2.1 Maintenance - Hardware Diagnosis ..............  127
   10.3.2.2 Control - Dumping and Rebooting ...............  127
   10.3.2.3 Control - Configuring the Router ..............  128
   10.3.2.4 Net Booting of System Software ................  128
   10.3.2.5 Detecting and responding to misconfiguration
            ...............................................  129
   10.3.2.6 Minimizing Disruption .........................  130
   10.3.2.7 Control - Troubleshooting Problems ............  130
   10.4 Security Considerations ...........................  131
   10.4.1 Auditing and Audit Trails .......................  131
   10.4.2 Configuration Control ...........................  132
   11. REFERENCES .........................................  133
   APPENDIX A. REQUIREMENTS FOR SOURCE-ROUTING HOSTS ......  145
   APPENDIX B. GLOSSARY ...................................  146
   APPENDIX C. FUTURE DIRECTIONS ..........................  152
   APPENDIX D. Multicast Routing Protocols ................  154
   D.1 Introduction .......................................  154
   D.2 Distance  Vector  Multicast  Routing  Protocol  -
       DVMRP ..............................................  154
   D.3 Multicast Extensions to OSPF - MOSPF ...............  154
   D.4 Protocol Independent Multicast - PIM ...............  155
   APPENDIX E Additional Next-Hop  Selection  Algorithms
        ...................................................  155
   E.1. Some Historical Perspective .......................  155
   E.2. Additional Pruning Rules ..........................  157
   E.3 Some Route Lookup Algorithms .......................  159
   E.3.1 The Revised Classic Algorithm ....................  159
   E.3.2 The Variant Router Requirements Algorithm ........  160
   E.3.3 The OSPF Algorithm ...............................  160
   E.3.4 The Integrated IS-IS Algorithm ...................  162
   Security Considerations ................................  163
   APPENDIX F: HISTORICAL ROUTING PROTOCOLS ...............  164
   F.1 EXTERIOR GATEWAY PROTOCOL - EGP ....................  164
   F.1.1 Introduction .....................................  164
   F.1.2 Protocol Walk-through ............................  165
   F.2 ROUTING INFORMATION PROTOCOL - RIP .................  167
   F.2.1 Introduction .....................................  167
   F.2.2 Protocol Walk-Through ............................  167
   F.2.3 Specific Issues ..................................  172
   F.3 GATEWAY TO GATEWAY PROTOCOL - GGP ..................  173
   Acknowledgments ........................................  173
   Editor's Address .......................................  175
```

---
## **1. INTRODUCTION**

이 메모는 RFC 1716, "인터넷 게이트웨이 요구 사항"\(\[INTRO:1\]\)을 대체합니다.

이 메모는 인터넷 프로토콜 제품군의 네트워크 계층 전달 기능을 수행하는 장치에 대한 요구 사항을 정의하고 논의합니다. 인터넷 커뮤니티에서는 일반적으로 이러한 장치를 IP 라우터 또는 간단히 라우터라고 부릅니다. OSI 커뮤니티에서는 이러한 장치를 중간 시스템이라고 부릅니다. 많은 오래된 인터넷 문서에서는 이러한 장치를 게이트웨이라고 부르는데, 최근에는 애플리케이션 게이트웨이와의 혼동을 피하기 위해 이 이름이 널리 사용되지 않습니다.

IP 라우터는 라우터가 스위칭 프로세스의 일부로 IP 프로토콜 헤더를 검사한다는 점에서 다른 종류의 패킷 스위칭 장치와 구별될 수 있습니다. 일반적으로 메시지가 수신된 링크 계층 헤더를 제거하고 IP 헤더를 수정하며 재전송을 위해 링크 계층 헤더를 대체합니다.

이 메모의 작성자는 독자와 마찬가지로 많은 라우터가 두 개 이상의 프로토콜을 지원한다는 점을 인식하고 있습니다. 앞으로 인터넷의 점점 더 많은 부분에서 다중 프로토콜 제품군에 대한 지원이 필요할 것입니다. 그러나 이 메모에서는 TCP/IP 이외의 프로토콜 제품군에 대한 인터넷 요구 사항을 지정하려고 시도하지 않습니다.

이 문서는 인터넷에 연결된 라우터가 사용해야 하는 표준 프로토콜을 열거하고, 이러한 프로토콜의 현재 사양을 설명하는 RFC 및 기타 문서를 참조로 통합합니다. 참조 문서의 오류를 수정하고 구현자를 위한 추가 논의 및 지침을 추가합니다.

각 프로토콜에 대해 이 메모에는 명시적인 요구 사항, 권장 사항 및 옵션 세트도 포함되어 있습니다. 독자는 이 메모의 요구 사항 목록 자체가 불완전하다는 점을 이해해야 합니다. 인터넷 프로토콜 라우터에 대한 전체 요구 사항은 기본적으로 표준 프로토콜 사양 문서에 정의되어 있으며 이 메모에는 수정 사항, 수정 사항 및 보충 사항이 포함되어 있습니다.

이 메모는 인터넷 호스트 RFC 요구 사항\(\[INTRO:2\] 및 \[INTRO:3\]\)과 함께 읽어야 합니다. 인터넷 호스트와 라우터는 모두 IP 데이터그램을 생성하고 이를 대상으로 하는 IP 데이터그램을 수신할 수 있어야 합니다. 인터넷 호스트와 라우터의 주요 차이점은 라우터는 전달 알고리즘을 구현하는 반면 인터넷 호스트에는 전달 기능이 필요하지 않다는 것입니다. 라우터 역할을 하는 모든 인터넷 호스트는 이 메모에 포함된 요구 사항을 준수해야 합니다.

개방형 시스템 상호 연결의 목표는 라우터가 필요할 때 인터넷 호스트로 올바르게 작동해야 한다는 것입니다. 이를 달성하기 위해 이 메모는 그러한 경우에 대한 지침을 제공합니다. 문서 업데이트를 단순화하고 용이하게 하기 위해 이 메모는 호스트 요구 사항에 대한 논의가 \[INTRO:2\] 및 \[INTRO:3\]과 중복되는 것을 피하고 해당 문서의 관련 요구 사항을 참조로 통합합니다. 어떤 경우에는 \[INTRO:2\] 및 \[INTRO:3\]에 명시된 요구 사항이 이 문서로 대체됩니다.

RFC를 주의 깊게 읽은 후 생성된 프로토콜의 선의의 구현은 이 메모의 요구 사항과 사소한 면에서만 달라야 합니다. 이러한 구현을 생성하려면 인터넷 기술 커뮤니티와의 상호 작용이 필요한 경우가 많으며 올바른 통신 소프트웨어 엔지니어링 관행을 따라야 합니다. 대부분의 경우 이 문서의 요구 사항은 이미 표준 프로토콜 문서에 명시되거나 암시되어 있으므로 여기에 포함시키는 것은 어떤 의미에서는 중복됩니다. 과거의 일부 구현이 잘못된 선택을 하여 상호 운용성, 성능 및/또는 견고성에 문제를 일으켰기 때문에 포함되었습니다.

이 메모에는 다양한 요구 사항 및 권장 사항에 대한 토론과 설명이 포함되어 있습니다. 단순한 요구 사항 목록은 다음과 같은 이유로 위험할 수 있습니다.

o 일부 필수 기능은 다른 기능보다 더 중요하며 일부 기능은 선택 사항입니다.

o 일부 기능은 일부 라우터 애플리케이션에서는 중요하지만 다른 애플리케이션에서는 관련이 없습니다.

o 제한된 상황에 맞게 설계된 특정 공급업체 제품이 다른 사양을 사용하도록 선택할 수 있는 타당한 이유가 있을 수 있습니다.

그러나 인터넷의 다양성과 복잡성 전반에 걸쳐 임의 라우터 상호 운용이라는 일반적인 목표를 충족하려면 이 메모의 사양을 따라야 합니다. 대부분의 현재 구현은 일부 사소하고 일부 주요한 다양한 방식으로 이러한 요구 사항을 충족하지 못하지만 이 사양은 우리가 나아가야 할 이상적인 사양입니다.

이러한 요구 사항은 현재 인터넷 아키텍처 수준을 기반으로 합니다. 이 메모는 추가 설명을 제공하거나 사양이 계속 발전하는 영역에 대한 추가 정보를 포함하기 위해 필요에 따라 업데이트됩니다.

---
## **1.1 Reading this Document**
---
### **1.1.1 Organization**

이 메모는 \[INTRO:2\] 및 \[INTRO:3\]에서 사용되는 계층화된 조직을 에뮬레이트합니다. 따라서 2장에서는 인터넷 아키텍처에서 발견되는 계층을 설명합니다. 3장은 링크 레이어를 다룬다. 4장과 5장은 인터넷 계층 프로토콜과 전달 알고리즘을 다루고 있습니다. 6장에서는 전송 계층을 다룹니다. 상위 계층 프로토콜은 7장, 8장, 9장으로 구분됩니다. 7장에서는 라우터가 서로 라우팅 정보를 교환하는 데 사용하는 프로토콜에 대해 설명합니다. 8장에서는 네트워크 관리에 대해 설명합니다. 9장에서는 다른 상위 계층 프로토콜에 대해 설명합니다. 마지막 장에서는 운영 및 유지 관리 기능을 다룹니다. 이 조직은 호스트 요구 사항 RFC와의 단순성, 명확성 및 일관성을 위해 선택되었습니다. 이 메모의 부록에는 참고 문헌, 용어집 및 향후 라우터 표준 방향에 대한 몇 가지 추측이 포함되어 있습니다.

```text
  In describing the requirements, we assume that an implementation
  strictly mirrors the layering of the protocols.  However, strict
  layering is an imperfect model, both for the protocol suite and for
  recommended implementation approaches.  Protocols in different layers
  interact in complex and sometimes subtle ways, and particular
```

기능에는 종종 여러 레이어가 포함됩니다. 구현에는 다양한 디자인 선택이 있으며 그 중 다수는 엄격한 계층화를 창의적으로 깨는 것과 관련됩니다. 모든 구현자는 \[INTRO:4\] 및 \[INTRO:5\]를 읽어야 합니다.

이 메모의 각 주요 섹션은 다음 하위 섹션으로 구성됩니다.

```text
  (1) Introduction
```

\(2\) 프로토콜 검토\(Protocol Walk-Through\) - 프로토콜 사양 문서를 섹션별로 검토하여 오류를 수정하고, 모호하거나 잘못 정의된 요구 사항을 명시하고, 추가 설명이나 설명을 제공합니다.

\(3\) 특정 문제 - 연습에 포함되지 않은 프로토콜 설계 및 구현 문제를 논의합니다.

이 메모의 많은 개별 주제 아래에는 토론 또는 구현이라는 라벨이 붙은 괄호 자료가 있습니다. 이 자료는 이전 요구 사항 텍스트에 대한 정당성, 설명 또는 설명을 제공하기 위한 것입니다. 구현 자료에는 구현자가 고려할 수 있는 제안된 접근 방식이 포함되어 있습니다. DISCUSSION 및 IMPLEMENTATION 섹션은 표준의 일부가 아닙니다.

---
### **1.1.2 Requirements**

이 메모에서 각 특정 요구 사항의 중요성을 정의하는 데 사용되는 단어는 대문자로 표시됩니다. 이 단어들은 다음과 같습니다:

o MUST 이 단어는 해당 항목이 사양의 절대 요구 사항임을 의미합니다. 이러한 요구 사항을 위반하는 것은 근본적인 오류입니다. 정당화되는 경우는 없습니다.\(MUST\)

o 반드시 구현해야 함\(MUST IMPLEMENT\) 이 문구는 이 사양에서 항목을 구현해야 하지만 기본적으로 활성화할 필요는 없음을 의미합니다.\(MUST\)

o MUST NOT 이 문구는 품목이 사양을 절대적으로 금지한다는 의미입니다.\(MUST NOT\)

```text
  o SHOULD
     This word means that there may exist valid reasons in particular
     circumstances to ignore this item, but the full implications should
     be understood and the case carefully weighed before choosing a

     different course.
```

o SHOULD IMPLEMENT 이 문구는 SHOULD와 의미가 유사하지만 특정 기능을 제공하도록 권장하지만 기본적으로 활성화하도록 반드시 권장하지는 않는 경우에 사용됩니다.\(SHOULD\)

o SHOULD NOT 이 문구는 설명된 동작이 허용되거나 유용할 때 특정 상황에서 타당한 이유가 있을 수 있음을 의미합니다. 그렇더라도 이 레이블로 설명된 동작을 구현하기 전에 전체 의미를 이해하고 사례를 신중하게 검토해야 합니다.\(SHOULD NOT\)

o MAY 이 단어는 이 항목이 실제로 선택 사항임을 의미합니다. 한 공급업체는 특정 시장에서 요구하거나 제품을 향상시키기 때문에 해당 항목을 포함하도록 선택할 수 있습니다. 다른 판매자가 동일한 항목을 생략할 수 있습니다.\(MAY\)

---
### **1.1.3 Compliance**

일부 요구 사항은 모든 라우터에 적용됩니다. 다른 요구사항은 특정 기능이나 프로토콜을 구현하는 요구사항에만 적용됩니다. 다음 단락에서 관련이란 모든 라우터에 적용되는 요구 사항과 라우터가 구현한 기능 및 프로토콜 집합으로 인해 특정 라우터에 적용되는 요구 사항 집합을 의미합니다.

모든 관련 요구 사항이 이 메모에 직접 명시되어 있는 것은 아닙니다. 이 메모의 다양한 부분은 호스트 요구 사항 사양의 참조 섹션인 \[INTRO:2\] 및 \[INTRO:3\]을 통합합니다. 이 메모의 준수 여부를 판단하기 위해 관련 요구사항이 이 메모에 직접 명시되어 있는지 아니면 단순히 해당 문서 중 하나에서 참조로 통합되었는지는 중요하지 않습니다.

구현이 관련 MUST, MUST IMPLEMENT 및 MUST NOT 요구 사항을 모두 충족하는 경우 조건부 준수라고 합니다. 구현이 조건부로 준수되고 관련 SHOULD, SHOULD IMPLEMENT 및 SHOULD NOT 요구 사항을 모두 충족하는 경우 무조건 준수한다고 합니다. 구현은 조건부 준수가 아닌 경우 준수하지 않습니다\(즉, 관련 MUST, MUST IMPLEMENT 또는 MUST NOT 요구 사항 중 하나 이상을 충족하지 못함\).\(MUST NOT, SHOULD NOT, MUST NOT\)

```text
  This specification occasionally indicates that an implementation
  SHOULD implement a management variable, and that it SHOULD have a
  certain default value.  An unconditionally compliant implementation
```

기본 동작을 구현하고, 다른 동작이 구현된 경우 변수를 구현합니다. 조건부 준수 구현은 변수의 기본 설정이 무엇인지, 또는 변수 구현이 없는 경우 어떻게 해석될 수 있는지 명확하게 문서화합니다. 변수 구현에 실패하고 다른 동작을 선택하는 구현은 규정을 준수하지 않습니다.

SHOULD 및 SHOULD NOT 요구 사항에 대해 라우터는 라우터가 요구 사항에 지정된 것과 다르게 작동하도록 하는 구성 옵션을 제공할 수 있습니다. 이러한 구성 옵션이 있다고 해서 옵션에 기본 설정이 있고 해당 설정으로 인해 라우터가 필요한 방식으로 작동하는 경우 무조건 준수에 대한 라우터의 주장이 무효화되지는 않습니다.\(SHOULD NOT\)

마찬가지로 라우터는 이 메모에서 명시적으로 금지한 경우를 제외하고 요구 사항을 위반해야 하거나 위반해서는 안 되는 옵션을 제공할 수 있습니다. 그러한 옵션을 제공하는 라우터는 해당 옵션 각각에 라우터가 이 메모의 요구 사항을 준수하도록 하는 기본 설정이 있는 경우에만 \(완전히 또는 조건부로\) 규격을 준수합니다. 이 메모의 작성자는 시장 현실을 알고 있지만 그러한 옵션 제공을 강력히 권장한다는 점에 유의하십시오. 요구 사항에는 MUST 또는 MUST NOT이라는 라벨이 붙어 있습니다. 해당 분야의 전문가가 요구 사항이 인터넷의 상호 운용성 또는 적절한 기능에 특히 중요하다고 판단했기 때문입니다. 공급업체는 이러한 규칙을 위반하는 옵션을 제공하는 데 따른 고객 지원 비용을 신중하게 평가해야 합니다.\(MUST NOT, MUST NOT\)

물론 이 메모는 IP 라우터의 완전한 사양이 아니라 OSI 세계에서 프로파일이라고 부르는 것에 더 가깝습니다. 예를 들어, 이 메모에서는 여러 프로토콜을 구현해야 합니다. 프로토콜 사양의 대부분 내용이 이 메모에서 반복되지는 않지만 구현자는 그럼에도 불구하고 해당 사양에 따라 프로토콜을 구현해야 합니다.

---
## **1.2 Relationships to Other Standards**

프로토콜 사양 및 표준화 상태를 확인하는 데 도움이 되는 몇 가지 참고 문서가 있습니다.

o 인터넷 공식 프로토콜 표준

- 이 문서는 인터넷 표준 프로세스를 설명하고 프로토콜의 표준 상태를 나열합니다. 이 글을 쓰는 시점에서 이 문서의 최신 버전은 STD 1, RFC 1780, \[ARCH:7\]입니다. 이 문서는 정기적으로 재발행됩니다. 항상 RFC 저장소를 참조하고 이 문서의 최신 버전을 사용해야 합니다.

o 할당된 번호

- 이 문서에는 다양한 프로토콜에 사용되는 매개변수의 할당된 값이 나열되어 있습니다. 예를 들어 IP 프로토콜 코드, TCP 포트 번호, Telnet 옵션 코드, ARP 하드웨어 유형 및 터미널 유형 이름이 나열됩니다. 이 글을 쓰는 시점에서 이 문서의 현재 버전은 STD 2, RFC 1700, \[INTRO:7\]입니다. 이 문서는 정기적으로 재발행됩니다. 항상 RFC 저장소를 참조하고 이 문서의 최신 버전을 사용해야 합니다.

o 호스트 요구 사항

- 이 문서 쌍은 호스트에 적용되는 사양을 검토하고 모호성에 대한 지침과 설명을 제공합니다. 이 요구 사항은 이 메모에 달리 지정된 경우를 제외하고 라우터에도 적용됩니다. 이 글을 쓰는 시점에서 이 문서의 최신 버전은 RFC 1122 및 RFC 1123\(STD 3\), \[INTRO:2\] 및 \[INTRO:3\]입니다.

o 라우터 요구 사항\(이전의 게이트웨이 요구 사항\)

- 이 메모요.

이 문서는 각기 다른 시기에 개정되고 업데이트됩니다. 이러한 문서 간에 차이가 있는 경우 가장 최근 문서가 우선해야 합니다.

이러한 문서와 기타 인터넷 프로토콜 문서는 다음에서 얻을 수 있습니다.

```text
                               The InterNIC
                              DS.INTERNIC.NET
                  InterNIC Directory and Database Service
                             info@internic.net
                              +1-908-668-6587
                       URL: http://ds.internic.net/
```

---
## **1.3 General Considerations**

인터넷 소프트웨어 공급업체가 배웠고 새로운 공급업체가 진지하게 고려해야 할 몇 가지 중요한 교훈이 있습니다.

---
### **1.3.1 Continuing Internet Evolution**

인터넷의 엄청난 성장으로 인해 대용량 데이터그램 기반 패킷 통신 시스템의 관리 및 확장 문제가 드러났습니다. 이러한 문제는 해결되고 있으며 그 결과 이 ​​메모에 설명된 사양이 지속적으로 발전할 것입니다. 새로운 라우팅 프로토콜, 알고리즘 및 아키텍처가 지속적으로 개발되고 있습니다. 새로운 인터넷 계층 프로토콜과 기존 프로토콜에 대한 수정 사항도 지속적으로 고안되고 있습니다. 라우터는 인터넷에서 중요한 역할을 하며, 그 수는

인터넷에 배포된 라우터의 수는 호스트 수보다 훨씬 적습니다. 따라서 공급업체는 라우터 표준이 호스트 표준보다 훨씬 더 빠르게 계속해서 발전할 것이라고 예상해야 합니다. 공급업체와 네트워크 운영을 담당하는 조직이 이 계획에 광범위하게 참여하므로 이러한 변경 사항은 신중하게 계획되고 제어됩니다.

개발, 진화 및 수정은 오늘날 컴퓨터 네트워크 프로토콜의 특징이며 이러한 상황은 몇 년 동안 지속될 것입니다. 인터넷 프로토콜 제품군\(또는 기타 프로토콜 제품군!\)용 컴퓨터 통신 소프트웨어를 개발한 후 사양 변경에 맞게 해당 소프트웨어를 유지 관리 및 업데이트하지 못하는 공급업체는 고객에게 불만족스러운 흔적을 남길 것입니다. 인터넷은 대규모 통신 네트워크이며, 사용자들은 이를 통해 지속적으로 접촉하고 있습니다. 경험에 따르면 공급업체 소프트웨어의 결함에 대한 지식은 인터넷 기술 커뮤니티를 통해 빠르게 전파됩니다.

---
### **1.3.2 Robustness Principle**

프로토콜의 모든 계층에는 견고성과 상호 운용성 측면에서 엄청난 이점을 가져올 수 있는 일반 규칙\(Jon Postel의 \[TRANS:2\] 참조\)이 있습니다.

무슨 일을 하든 보수적으로 행동하세요.

- 다른 사람으로부터 받아들이는 데 있어서 자유로워지세요.

```text
   Software should be written to deal with every conceivable error, no
   matter how unlikely.  Eventually a packet will come in with that
   particular combination of errors and attributes, and unless the
   software is prepared, chaos can ensue.  It is best to assume that the
   network is filled with malevolent entities that will send packets
   designed to have the worst possible effect.  This assumption will
   lead to suitably protective design.  The most serious problems in the
   Internet have been caused by unforeseen mechanisms triggered by low
   probability events; mere human malice would never have taken so
   devious a course!
```

변화에 대한 적응성은 모든 수준의 라우터 소프트웨어에 설계되어야 합니다. 간단한 예로, 특정 헤더 필드\(예: 유형 필드, 포트 번호 또는 오류 코드\)에 대한 값의 열거를 포함하는 프로토콜 사양을 고려하십시오. 이 열거는 불완전한 것으로 가정해야 합니다. 프로토콜 사양이 4개의 가능한 오류 코드를 정의하는 경우 다섯 번째 코드가 정의될 ​​때 소프트웨어가 중단되어서는 안 됩니다. 정의되지 않은 코드가 기록될 수 있지만 이로 인해 오류가 발생해서는 안 됩니다.

원칙의 두 번째 부분도 마찬가지로 중요합니다. 호스트나 다른 라우터의 소프트웨어에는 합법적이지만 모호한 프로토콜 기능을 활용하는 것을 현명하지 못하게 만드는 결함이 포함될 수 있습니다. 명백하고 단순한 것에서 멀리 벗어나는 것은 다른 곳에서 바람직하지 않은 결과를 초래하지 않도록 하는 것은 현명하지 않습니다. 이에 따라 오작동하는 호스트를 조심해야 합니다. 라우터 소프트웨어는 오작동하는 호스트가 있어도 살아남을 수 있도록 준비해야 합니다. 인터넷에서 라우터의 중요한 기능은 해당 호스트가 공유 통신 시설에 가할 수 있는 중단의 양을 제한하는 것입니다.

---
### **1.3.3 Error Logging**

인터넷에는 각각 많은 프로토콜과 프로토콜 계층을 구현하는 매우 다양한 시스템이 포함되어 있으며 이들 중 일부에는 인터넷 프로토콜 소프트웨어에 버그와 잘못된 기능이 포함되어 있습니다. 복잡성, 다양성, 기능 분포로 인해 문제 진단이 매우 어려운 경우가 많습니다.

라우터에 오류가 있거나 이상한 이벤트를 기록하기 위해 세심하게 설계된 기능이 포함되어 있으면 문제 진단에 도움이 됩니다. 오류가 기록될 때 가능한 한 많은 진단 정보를 포함하는 것이 중요합니다. 특히, 오류를 일으킨 패킷의 헤더를 기록해 두는 것이 유용한 경우가 많습니다. 그러나 오류 로깅이 엄청난 양의 리소스를 소비하거나 라우터 작동을 방해하지 않도록 주의해야 합니다.

비정상적이지만 무해한 프로토콜 이벤트가 오류 로깅 파일을 오버플로하는 경향이 있습니다. 이는 순환 로그를 사용하거나 알려진 오류를 진단하는 동안에만 로깅을 활성화하여 방지할 수 있습니다. 중복된 연속 메시지를 필터링하고 계산하는 것이 유용할 수 있습니다. 잘 작동하는 것으로 보이는 전략 중 하나는 다음 두 가지 모두에 적용되는 것입니다.

o 항상 이상을 계산하고 관리 프로토콜을 통해 해당 계산에 접근할 수 있도록 합니다\(8장 참조\). o 매우 다양한 이벤트의 로깅을 선택적으로 활성화할 수 있습니다. 예를 들어 모든 것을 기록하거나 호스트 X에 대한 모든 것을 기록하는 것이 유용할 수 있습니다.

이 주제는 \[MGT:5\]에서 자세히 논의됩니다.

---
### **1.3.4 Configuration**

이상적인 세상에서 라우터는 구성하기 쉽고 아마도 완전히 자체 구성될 수도 있습니다. 그러나 현실 세계의 실제 경험에 따르면 이는 불가능한 목표이며, 구성을 쉽게 만들려는 공급업체의 많은 시도는 실제로 고객에게 방지하기보다 더 큰 슬픔을 안겨줍니다. 극단적인 예로,

구성 정보가 전혀 필요하지 않고 패킷 라우팅을 시작하도록 설계된 라우터는 잘못된 매개변수를 선택하게 되어 불행하게도 연결된 네트워크에 심각한 문제를 일으킬 가능성이 거의 확실합니다.

이 메모에서는 매개변수가 구성 가능한 옵션이어야 하는 경우가 많습니다. 여기에는 몇 가지 이유가 있습니다. 몇몇 경우에는 현재 최상의 값에 대해 불확실성이나 불일치가 있으며 향후 권장 값을 업데이트해야 할 수도 있습니다. 다른 경우에는 값이 실제로 외부 요인\(예: 통신 부하 분산, 근처 네트워크의 속도 및 토폴로지\)에 따라 달라지며 자체 조정 알고리즘을 사용할 수 없거나 충분하지 않을 수 있습니다. 어떤 경우에는 관리 요구 사항으로 인해 구성 가능성이 필요합니다.

마지막으로, 소스 없이 배포되고 인터넷의 여러 부분에서 지속되는 오래되거나 잘못된 프로토콜 구현과 통신하려면 일부 구성 옵션이 필요합니다. 이러한 결함이 있는 시스템과 올바른 시스템이 공존하도록 하려면 관리자가 때때로 올바른 시스템을 잘못 구성해야 합니다. 이 문제는 결함이 있는 시스템이 폐기됨에 따라 점차적으로 해결되지만 공급업체가 무시할 수는 없습니다.

매개변수를 구성 가능해야 한다고 말할 때 부팅할 때마다 해당 값을 구성 파일에서 명시적으로 읽어오도록 요구하지는 않습니다. 많은 매개변수에 대해 가장 특이한 상황을 제외한 모든 상황에 적합한 하나의 값이 있습니다. 이러한 경우 명시적으로 설정되지 않은 경우 매개변수의 기본값이 해당 값으로 설정되는 것이 합리적입니다.

이 메모는 어떤 경우에는 그러한 기본값에 대한 특정 값을 요구합니다. 기본값 선택은 구성 항목이 결함이 있는 기존 시스템의 수용을 제어할 때 민감한 문제입니다. 인터넷이 성공적으로 통합되어 상호 운용성을 완성하려면 구현에 내장된 기본값이 잘못된 구현을 수용하기 위한 잘못된 구성이 아니라 공식 프로토콜을 구현해야 합니다. 마케팅 고려 사항으로 인해 일부 공급업체가 잘못된 구성 기본값을 선택하게 되었지만 표준을 준수하는 기본값을 선택하도록 공급업체에 촉구합니다.

마지막으로 공급업체는 모든 구성 매개변수, 해당 매개변수의 한계 및 효과에 대한 적절한 문서를 제공해야 합니다.

---
## **1.4 Algorithms**

이 메모의 여러 위치에는 라우터가 따라야 하는 특정 알고리즘이 지정되어 있습니다. 이러한 알고리즘은 본질적으로 라우터에 필요하지 않습니다. 라우터는 이 문서에 작성된 대로 각 알고리즘을 구현할 필요가 없습니다. 오히려 구현은 지정된 알고리즘의 엄격한 문자 그대로 구현과 동일한 동작을 외부 세계에 제시해야 합니다.

알고리즘은 좋은 구현자가 구현하는 방식과 다른 방식으로 설명됩니다. 설명을 위해 간결성, 명확성 및 구현 세부 사항과의 독립성을 강조하는 스타일이 선택되었습니다. 좋은 구현자는 이러한 알고리즘과 동일한 결과를 생성하지만 더 효율적이거나 덜 일반적일 수 있는 알고리즘 및 구현 방법을 선택합니다.

효율적인 라우터 구현 기술은 이 메모의 범위를 벗어납니다.

---
## **2. INTERNET ARCHITECTURE**

이 장에는 요구 사항이 포함되어 있지 않습니다. 그러나 여기에는 인터넷과 라우터의 일반적인 아키텍처에 대한 유용한 배경 정보가 포함되어 있습니다.

인터넷 아키텍처 및 지원 프로토콜 제품군에 대한 일반적인 배경 및 논의는 DDN 프로토콜 핸드북 \[ARCH:1\]에서 찾을 수 있습니다. 배경 지식은 \[ARCH:2\], \[ARCH:3\] 및 \[ARCH:4\]를 참조하세요. 인터넷 아키텍처와 프로토콜은 \[ARCH:5\] 및 \[ARCH:6\]과 같이 점점 더 많은 교과서에서 다루어지고 있습니다.

---
## **2.1 Introduction**

인터넷 시스템은 인터넷 프로토콜을 사용하여 호스트 컴퓨터 간의 통신을 지원하는 상호 연결된 여러 패킷 네트워크로 구성됩니다. 이러한 프로토콜에는 IP\(인터넷 프로토콜\), ICMP\(인터넷 제어 메시지 프로토콜\), IGMP\(인터넷 그룹 관리 프로토콜\) 및 이에 의존하는 다양한 전송 및 애플리케이션 프로토콜이 포함됩니다. 섹션 \[1.2\]에 설명된 대로 인터넷 엔지니어링 운영 그룹은 모든 인터넷 프로토콜을 나열하는 공식 프로토콜 메모를 정기적으로 발표합니다.

모든 인터넷 프로토콜은 기본 데이터 전송 메커니즘으로 IP를 사용합니다. IP는 데이터그램 또는 비연결형 인터네트워크 서비스이며 주소 지정, 서비스 유형 사양,

조각화와 재조립, 그리고 보안. ICMP와 IGMP는 구조적으로 IP에 계층화되어 있지만 IP의 필수 부분으로 간주됩니다. ICMP는 오류 보고, 흐름 제어, 첫 번째 홉 라우터 리디렉션 및 기타 유지 관리 및 제어 기능을 제공합니다. IGMP는 호스트와 라우터가 IP 멀티캐스트 그룹에 가입하고 탈퇴할 수 있는 메커니즘을 제공합니다.

엔드엔드 재전송, 재시퀀싱 및 연결 제어를 제공하는 TCP\(전송 제어 프로토콜\)와 같은 전송 계층 프로토콜을 통해 인터넷 프로토콜 제품군에서 안정적인 데이터 전달이 제공됩니다. 전송 계층 비연결 서비스는 UDP\(사용자 데이터그램 프로토콜\)에 의해 제공됩니다.

---
## **2.2 Elements of the Architecture**
---
### **2.2.1 Protocol Layering**

인터넷 시스템을 사용하여 통신하려면 호스트는 인터넷 프로토콜 제품군을 구성하는 계층화된 프로토콜 세트를 구현해야 합니다. 호스트는 일반적으로 각 계층에서 최소한 하나의 프로토콜을 구현해야 합니다.

인터넷 아키텍처에 사용되는 프로토콜 계층은 다음과 같습니다 \[ARCH:7\]:

o 애플리케이션 계층

- 응용 프로그램 계층은 인터넷 프로토콜 제품군의 최상위 계층입니다. 일부 응용 프로그램 계층 프로토콜에는 일부 내부 하위 계층이 포함되어 있지만 인터넷 제품군은 응용 프로그램 계층을 더 이상 세분화하지 않습니다. 인터넷 제품군의 응용 프로그램 계층은 본질적으로 OSI 참조 모델 \[ARCH:8\]의 상위 두 계층\(프레젠테이션 및 응용 프로그램\)의 기능을 결합합니다. 인터넷 프로토콜 제품군의 애플리케이션 계층에는 OSI 참조 모델의 세션 계층에 속하는 기능 중 일부도 포함되어 있습니다.

- 애플리케이션 계층 프로토콜은 사용자에게 직접 서비스를 제공하는 사용자 프로토콜과 공통 시스템 기능을 제공하는 지원 프로토콜의 두 가지 범주로 구분됩니다. 가장 일반적인 인터넷 사용자 프로토콜은 다음과 같습니다.

```text
      - Telnet (remote login)
      - FTP (file transfer)
      - SMTP (electronic mail delivery)
```

- 기타 표준화된 사용자 프로토콜과 개인 사용자 프로토콜이 많이 있습니다.

- 호스트 이름 매핑, 부팅 및 관리에 사용되는 지원 프로토콜에는 SNMP, BOOTP, TFTP, DNS\(Domain Name System\) 프로토콜 및 다양한 라우팅 프로토콜이 포함됩니다.

- 라우터와 관련된 애플리케이션 계층 프로토콜은 이 메모의 7, 8, 9장에서 논의됩니다.

o 전송 계층

- 전송 계층은 종단 간 통신 서비스를 제공합니다. 이 계층은 OSI의 세션 계층 설정 및 삭제 기능 중 일부도 통합한다는 점을 제외하면 OSI 참조 모델의 전송 계층과 거의 동일합니다.

- 현재 두 가지 기본 전송 계층 프로토콜이 있습니다.

```text
      - Transmission Control Protocol (TCP)
      - User Datagram Protocol (UDP)
```

- TCP는 종단 간 신뢰성, 재배열 및 흐름 제어를 제공하는 안정적인 연결 지향 전송 서비스입니다. UDP는 비연결\(데이터그램\) 전송 서비스입니다. 다른 전송 프로토콜은 연구 커뮤니티에서 개발되었으며 공식 인터넷 전송 프로토콜 세트는 향후 확장될 수 있습니다.

- 라우터와 관련된 전송 계층 프로토콜은 6장에서 논의됩니다.

o 인터넷 계층

- 모든 인터넷 전송 프로토콜은 인터넷 프로토콜\(IP\)을 사용하여 소스 호스트에서 대상 호스트로 데이터를 전달합니다. IP는 종단 간 전달을 보장하지 않는 비연결 또는 데이터그램 인터네트워크 서비스입니다. IP 데이터그램은 손상되거나, 중복되거나, 순서가 잘못되었거나, 전혀 도착하지 않은 상태로 대상 호스트에 도착할 수 있습니다. IP 위의 계층은 필요할 때 안정적인 전달 서비스를 담당합니다. IP 프로토콜에는 주소 지정, 서비스 유형 사양, 조각화 및 재조립, 보안에 대한 규정이 포함됩니다.

- IP의 데이터그램 또는 연결 없는 특성은 인터넷 아키텍처의 기본적이고 특징적인 특징입니다.

- ICMP\(Internet Control Message Protocol\)는 구조적으로 IP에 계층화되어 있지만 IP의 필수 부분으로 간주되는 제어 프로토콜입니다. 이는 IP를 사용하여 데이터를 엔드 투 엔드로 전달합니다. ICMP는 오류 보고, 정체 보고 및 첫 번째 홉 라우터 리디렉션을 제공합니다.

- IGMP\(인터넷 그룹 관리 프로토콜\)는 IP 멀티캐스팅을 위한 동적 호스트 그룹을 설정하는 데 사용되는 인터넷 계층 프로토콜입니다.

- 인터넷 계층 프로토콜 IP, ICMP 및 IGMP는 4장에서 논의됩니다.

o 링크 레이어

- 직접 연결된 네트워크에서 통신하려면 호스트는 해당 네트워크에 인터페이스하는 데 사용되는 통신 프로토콜을 구현해야 합니다. 우리는 이것을 링크 계층 프로토콜이라고 부릅니다.

- 일부 오래된 인터넷 문서에서는 이 계층을 네트워크 계층이라고 부르지만 OSI 참조 모델의 네트워크 계층과 동일하지 않습니다.

- 이 계층에는 인터넷 계층 아래와 물리 계층\(메시지를 인코딩하고 전송하는 일반적으로 전기적 또는 광학적 미디어 연결\) 위의 모든 항목이 포함됩니다. 그 책임은 메시지를 정확하게 전달하는 것이며, 그 중 구별되지 않습니다.

- 이 계층의 프로토콜은 일반적으로 인터넷 표준화 범위를 벗어납니다. 인터넷은 가능할 때마다 \(의도적으로\) 기존 표준을 사용합니다. 따라서 인터넷 링크 계층 표준은 일반적으로 특정 링크 계층 프로토콜을 통해 IP 패킷을 전송하기 위한 주소 확인 및 규칙만 다룹니다. 인터넷 링크 계층 표준은 3장에서 논의됩니다.

---
### **2.2.2 Networks**

인터넷 시스템을 구성하는 네트워크는 패킷\(무연결\) 전송만 제공해야 합니다. IP 서비스 사양에 따르면 데이터그램은 순서가 잘못 전달되거나, 손실되거나 복제되거나, 오류가 포함될 수 있습니다.

IP\(예: TCP\)를 사용하는 프로토콜의 합리적인 성능을 위해서는 네트워크 손실률이 매우 낮아야 합니다. 연결 지향 서비스를 제공하는 네트워크에서 가상 회선이 제공하는 추가적인 신뢰성은 시스템의 종단 견고성을 향상시키지만 인터넷 운영에는 필요하지 않습니다.

구성 네트워크는 일반적으로 두 가지 클래스로 나눌 수 있습니다.

```text
     o Local-Area Networks (LANs)
        LANs may have a variety of designs.  LANs normally cover a small
        geographical area (e.g., a single building or plant site) and
        provide high bandwidth with low delays.  LANs may be passive
```

- \(이더넷과 유사\) 또는 활성 상태일 수 있습니다\(예: ATM\).

o 광역 네트워크\(WAN\)

- 지리적으로 분산된 호스트와 LAN은 장거리 네트워크라고도 하는 광역 네트워크로 상호 연결됩니다. 이러한 네트워크는 회선과 패킷 스위치의 복잡한 내부 구조를 가질 수도 있고 지점 간 회선만큼 단순할 수도 있습니다.

---
### **2.2.3 Routers**

인터넷 모델에서 구성 네트워크는 라우터 또는 IP 라우터라고 하는 IP 데이터그램 전달자에 의해 함께 연결됩니다. 이 문서에서 라우터라는 용어의 모든 사용은 IP 라우터와 동일합니다. 많은 오래된 인터넷 문서에서는 라우터를 게이트웨이로 지칭합니다.

역사적으로 라우터는 범용 CPU에서 실행되는 패킷 교환 소프트웨어로 구현되었습니다. 그러나 맞춤형 하드웨어 개발 비용이 저렴해지고 더 높은 처리량이 요구됨에 따라 특수 목적 하드웨어가 점점 보편화되고 있습니다. 이 사양은 구현 방법에 관계없이 라우터에 적용됩니다.

라우터는 IP 서브넷 또는 번호가 지정되지 않은 지점 간 회선으로 표시되는 두 개 이상의 논리적 인터페이스에 연결됩니다\(섹션 \[2.2.7\]에서 설명\). 따라서 최소한 하나의 물리적 인터페이스가 있습니다. IP 데이터그램을 전달하려면 일반적으로 라우터가 다음 홉 라우터 또는 \(최종 홉의 경우\) 대상 호스트의 주소와 관련 인터페이스를 선택해야 합니다. 중계 또는 전달이라고 하는 이 선택은 라우터 내의 경로 데이터베이스에 따라 달라집니다. 경로 데이터베이스는 라우팅 테이블 또는 전달 테이블이라고도 합니다. "라우터"라는 용어는 이 경로 데이터베이스를 구축하는 과정에서 유래되었습니다. 라우팅 프로토콜과 구성은 라우팅이라는 프로세스에서 상호 작용합니다.

라우팅 데이터베이스는 인터넷 시스템의 현재 토폴로지를 반영하기 위해 동적으로 유지되어야 합니다. 라우터는 일반적으로 다른 라우터와의 분산 라우팅 및 연결 가능성 알고리즘에 참여하여 이를 수행합니다.

라우터는 데이터그램 전송만 제공하며 라우팅 유연성과 견고성을 위해 이 서비스를 유지하는 데 필요한 상태 정보를 최소화하려고 합니다.

패킷 교환 장치는 링크 계층에서도 작동할 수 있습니다. 이러한 장치를 일반적으로 브리지라고 합니다. 브리지로 연결된 네트워크 세그먼트는 단일 IP 서브넷을 형성하는 동일한 IP 네트워크 접두사를 공유합니다. 이러한 다른 장치는 이 범위를 벗어납니다.

```text
   document.
```

---
### **2.2.4 Autonomous Systems**

AS\(자율 시스템\)는 일련의 경로로 상호 연결된 하위 네트워크\(호스트가 연결된\) 모음으로 구성된 네트워크 토폴로지의 연결된 세그먼트입니다. 서브네트워크와 라우터는 단일 운영 및 유지 관리\(O&M\) 조직의 통제를 받을 것으로 예상됩니다. AS 내에서 라우터는 하나 이상의 내부 라우팅 프로토콜과 때로는 여러 메트릭 세트를 사용할 수 있습니다. AS는 일관성 있는 내부 라우팅 계획의 모습과 AS를 통해 도달할 수 있는 목적지에 대한 일관된 그림을 다른 AS에게 제시할 것으로 예상됩니다. AS는 자율 시스템 번호로 식별됩니다.

AS의 개념은 인터넷 라우팅에서 중요한 역할을 합니다\(섹션 7.1 참조\).

---
### **2.2.5 Addressing Architecture**

IP 데이터그램은 32비트 소스 및 대상 주소를 전달하며, 각 주소는 구성 네트워크 접두어와 해당 네트워크의 호스트 번호라는 두 부분으로 분할됩니다. 상징적으로:

```text
      IP-address ::= { <Network-prefix>, <Host-number> }
```

최종적으로 데이터그램을 전달하려면 경로의 마지막 라우터가 IP 주소의 호스트 번호\(또는 나머지\) 부분을 호스트의 링크 계층 주소에 매핑해야 합니다.

---
#### **2.2.5.1 Classical IP Addressing Architecture**

다른 곳 \[INTERNET:2\]에 잘 문서화되어 있지만 네트워크 접두어의 역사적 사용을 설명하는 것은 유용합니다. 이를 설명하기 위해 개발된 언어는 이 문서와 다른 문서에서 사용되며 많은 프로토콜 뒤에 있는 사고에 스며들고 있습니다.

가장 간단한 기존 네트워크 접두사는 클래스 A, B, C, D 또는 E 네트워크 접두사입니다. 이러한 주소 범위는 주소의 최상위 비트 값을 관찰하여 식별되며 주소를 간단한 접두사 및 호스트 번호 필드로 나눕니다. 이는 \[인터넷:18\]에 설명되어 있습니다. 간단히 말해서 분류는 다음과 같습니다.

- 0xxx - 클래스 A - 표준 8비트 접두사가 있는 범용 유니캐스트 주소 10xx - 클래스 B - 표준 16비트 접두사가 있는 범용 유니캐스트 주소

- 110x - 클래스 C - 표준 24비트 접두사가 있는 범용 유니캐스트 주소 1110 - 클래스 D - IP 멀티캐스트 주소 - 28비트 접두사, 집계 불가능 1111 - 클래스 E - 실험용으로 예약됨

이 간단한 개념은 서브넷 개념으로 확장되었습니다. 이는 조직 내에서 상호 연결된 LAN 구조의 임의적 복잡성을 허용하는 동시에 할당된 네트워크 접두사 및 라우팅 복잡성의 폭발적인 증가로부터 인터넷 시스템을 보호하기 위해 도입되었습니다. 서브넷은 인터넷 시스템에 대한 다단계 계층적 라우팅 구조를 제공합니다. \[INTERNET:2\]에 설명된 서브넷 확장은 인터넷 아키텍처의 필수 부분입니다. 기본 아이디어는 <Host-number\> 필드를 서브넷 번호와 해당 서브넷의 실제 호스트 번호라는 두 부분으로 분할하는 것입니다.

```text
      IP-address ::=
        { <Network-number>, <Subnet-number>, <Host-number> }
```

조직 내의 상호 연결된 물리적 네트워크는 동일한 네트워크 접두사를 사용하지만 다른 서브넷 번호를 사용합니다. 이러한 서브넷 네트워크의 서브넷 간 구별은 일반적으로 해당 네트워크 외부에서 볼 수 없습니다. 따라서 나머지 인터넷에서의 라우팅은 IP 대상 주소의 <Network-prefix\> 부분만 사용합니다. 네트워크 외부의 라우터는 <Network-prefix\> 및 <Host-number\>를 32비트 IP 주소의 해석되지 않은 나머지 부분으로 함께 처리합니다. 서브넷 네트워크 내에서 라우터는 확장 네트워크 접두사를 사용합니다.

```text
      { <Network-number>, <Subnet-number> }
```

이 확장된 네트워크 번호를 포함하는 비트 위치는 역사적으로 서브넷 마스크라고 하는 32비트 마스크로 표시되었습니다. <Subnet-number\> 비트는 연속적이어야 하며 <Network-number\>와 <Host-number\> 필드 사이에 있어야 합니다. 최신 프로토콜은 서브넷 마스크가 아니라 접두사 길이를 참조합니다. 주소의 "접두사" 부분은 최상위 비트가 모두 1이고 나머지는 0인 서브넷 마스크에 의해 선택되는 부분입니다. 접두사의 길이는 서브넷 마스크의 접두사 길이와 같습니다. 이 문서에서는 모든 서브넷 마스크가 접두사 길이로 표현 가능하다고 가정합니다.\(SHOULD\)

서브넷 메커니즘의 발명가들은 조직 네트워크의 각 부분이 단 하나의 서브넷 번호만을 가질 것이라고 가정했습니다. 실제로 여러 서브넷이 단일 물리적 케이블을 공유하는 것이 필요하거나 유용한 것으로 입증된 경우가 많습니다. 이러한 이유로 라우터는 동일한 네트워크에서 여러 서브넷을 구성할 수 있어야 합니다.

물리적 인터페이스를 분리하고 \(라우팅 또는 전달 관점에서\) 마치 별개의 물리적 인터페이스인 것처럼 처리합니다.

---
#### **2.2.5.2 Classless Inter Domain Routing (CIDR)**

인터넷의 폭발적인 성장으로 인해 주소 할당 정책을 검토하게 되었습니다. 범용\(클래스 A, B, C\) 네트워크의 기존 사용 방식은 IP의 32비트 주소 공간을 더 잘 활용하기 위해 수정되었습니다. CIDR\(클래스 없는 도메인 간 라우팅\)\[INTERNET:15\]은 이러한 추가 효율성을 달성하기 위해 현재 인터넷 백본에 배포되고 있는 방법입니다. CIDR은 임의 크기의 네트워크에 대한 배포 및 라우팅에 따라 달라집니다. 이 모델에서 호스트와 라우터는 인터넷에서의 주소 지정 사용에 대해 어떠한 가정도 하지 않습니다. 클래스 D\(IP 멀티캐스트\) 및 클래스 E\(실험\) 주소 공간은 기본적으로 할당 정책이지만 보존됩니다.

정의에 따르면 CIDR은 세 가지 요소로 구성됩니다.

o 위상적으로 중요한 주소 할당 o 네트워크 계층 도달 가능성 정보를 집계할 수 있는 라우팅 프로토콜 o 일관된 전달 알고리즘\("최장 일치"\).

네트워크와 서브넷의 사용은 이제 역사적이지만 이를 설명하는 데 사용된 언어는 현재에도 여전히 사용되고 있습니다. 이는 보다 다루기 쉬운 네트워크 접두사 개념으로 대체되었습니다. 네트워크 접두사는 정의에 따라 시스템 집합을 정의하는 주소의 더 중요한 끝에 있는 연속 비트 집합입니다. 호스트 번호는 해당 시스템 중에서 선택합니다. 모든 인터넷이 네트워크 접두사를 균일하게 사용해야 한다는 요구 사항은 없습니다. 라우팅 정보를 축소하려면 인터넷을 주소 지정 도메인으로 나누는 것이 유용합니다. 이러한 도메인 내에서는 구성 네트워크에 대한 자세한 정보를 사용할 수 있습니다. 그 외부에는 공통 네트워크 접두사만 광고됩니다.

기존 IP 주소 지정 아키텍처는 주소와 서브넷 마스크를 사용하여 네트워크 접두사와 호스트 번호를 구별했습니다. 네트워크 접두사를 사용하면 접두사의 비트 수를 나타내는 것으로 충분합니다. 두 표현 모두 공통적으로 사용됩니다. 구조적으로 올바른 서브넷 마스크는 접두사 길이 설명을 사용하여 나타낼 수 있습니다. 이는 가능한 모든 비트 패턴의 하위 집합으로 구성됩니다.

o 더 중요한 끝에 있는 연속적인 1 문자열, o 덜 중요한 끝에 있는 연속적인 0의 문자열, o 중간에 비트가 없습니다.

라우터는 항상 경로를 네트워크 접두사로 처리해야 하며 해당 모델과 일치하지 않는 구성 및 라우팅 정보를 거부해야 합니다.\(SHOULD\)

```text
      IP-address ::= { <Network-prefix>, <Host-number> }
```

CIDR 사용의 효과는 라우팅 테이블의 주소 접두사와 연관된 대상 집합이 하위 집합 관계를 나타낼 수 있다는 것입니다. 더 작은 목적지 집합\(긴 접두사\)을 설명하는 경로는 더 큰 목적지 집합\(더 짧은 접두사\)을 설명하는 경로보다 더 구체적이라고 합니다. 마찬가지로, 더 큰 목적지 세트\(더 짧은 접두사\)를 설명하는 경로는 더 작은 목적지 세트\(더 긴 접두사\)를 설명하는 경로보다 덜 구체적이라고 합니다. 라우터는 트래픽을 전달할 때 가장 구체적으로 일치하는 경로\(가장 긴 일치 네트워크 접두사\)를 사용해야 합니다.

---
### **2.2.6 IP Multicasting**

IP 멀티캐스팅은 링크 계층 멀티캐스트를 IP 인터넷으로 확장한 것입니다. IP 멀티캐스트를 사용하면 단일 데이터그램을 모든 호스트에 보내지 않고도 여러 호스트에 주소를 지정할 수 있습니다. 확장된 경우 이러한 호스트는 다른 주소 도메인에 상주할 수 있습니다. 이 호스트 모음을 멀티캐스트 그룹이라고 합니다. 각 멀티캐스트 그룹은 클래스 D IP 주소로 표시됩니다. 그룹으로 전송된 IP 데이터그램은 유니캐스트 IP 트래픽에 제공되는 것과 동일한 최선의 전달 방식으로 각 그룹 구성원에게 전달됩니다. 데이터그램의 송신자 자체가 대상 그룹의 구성원일 필요는 없습니다.

IP 멀티캐스트 그룹 멤버십의 의미는 \[INTERNET:4\]에 정의되어 있습니다. 이 문서에서는 호스트와 라우터가 멀티캐스트 그룹에 가입하고 탈퇴하는 방법을 설명합니다. 또한 IP 멀티캐스트 그룹 멤버십을 모니터링하는 프로토콜인 IGMP\(인터넷 그룹 관리 프로토콜\)를 정의합니다.

IP 멀티캐스트 데이터그램 전달은 정적 라우팅 정보나 멀티캐스트 라우팅 프로토콜을 통해 수행됩니다. IP 멀티캐스트 데이터그램을 전달하는 장치를 멀티캐스트 라우터라고 합니다. IP 유니캐스트를 전달할 수도 있고 전달하지 않을 수도 있습니다. 멀티캐스트 데이터그램은 소스 주소와 대상 주소를 기반으로 전달됩니다. IP 멀티캐스트 패킷의 전달은 섹션 \[5.2.1\]에서 더 자세히 설명됩니다. 부록 D에서는 멀티캐스트 라우팅 프로토콜에 대해 설명합니다.

---
### **2.2.7 Unnumbered Lines and Networks Prefixes**

일반적으로 IP 호스트 또는 라우터의 각 네트워크 인터페이스에는 고유한 IP 주소가 있습니다. 이는 모든 지점 간 링크에 IP 네트워크 접두어를 강제로 할당하므로 부족한 IP 주소 공간을 비효율적으로 사용할 수 있습니다.

이러한 문제를 해결하기 위해 많은 사람들이 무번호 점대점선\(Unnumbered Point to Point Line\) 개념을 제안하고 구현해왔습니다. 번호가 지정되지 않은 지점 간 회선에는 연결된 네트워크 접두사가 없습니다. 결과적으로 번호가 지정되지 않은 지점 간 회선에 연결된 네트워크 인터페이스에는 IP 주소가 없습니다.

IP 아키텍처는 전통적으로 모든 인터페이스에 IP 주소가 있다고 가정했기 때문에 이러한 번호가 지정되지 않은 인터페이스는 몇 가지 흥미로운 딜레마를 야기합니다. 예를 들어, 일부 IP 옵션\(예: Record Route\)은 라우터가 인터페이스 주소를 옵션에 삽입해야 한다고 지정하지만 번호가 지정되지 않은 인터페이스에는 IP 주소가 없습니다. 더 근본적인 것은\(5장에서 살펴보겠지만\) 경로에는 다음 홉 라우터의 IP 주소가 포함되어 있다는 것입니다. 라우터는 이 IP 주소가 라우터가 연결된 IP\(서브\)네트에 있을 것으로 예상합니다. 물론 유일한 연결이 번호가 지정되지 않은 점대점 선인 경우 해당 가정은 위반됩니다.

이러한 어려움을 해결하기 위해 두 가지 계획이 고안되었습니다. 첫 번째 방식은 번호가 지정되지 않은 지점 간 회선으로 연결된 두 개의 라우터가 실제로 두 개의 라우터가 아니라 함께 단일 가상 라우터를 구성하는 두 개의 하프 라우터임을 나타냅니다. 번호가 지정되지 않은 지점 간 회선은 기본적으로 가상 라우터의 내부 버스로 간주됩니다. 가상 라우터의 두 부분은 정확히 단일 라우터처럼 작동하는 방식으로 활동을 조정해야 합니다.

이 체계는 IP 아키텍처와 잘 어울리지만 두 가지 중요한 단점이 있습니다. 첫 번째는 번호가 지정되지 않은 단일 지점 간 회선의 일반적인 경우를 처리하지만 라우터 메시 및 번호가 지정되지 않은 지점 간 회선의 경우를 처리하기 위해 쉽게 확장할 수 없다는 것입니다. 두 번째 단점은 하프 라우터 간의 상호 작용이 필연적으로 복잡하고 표준화되지 않아 번호가 지정되지 않은 지점 간 회선을 사용하는 여러 공급업체의 장비 연결을 효과적으로 불가능하게 한다는 것입니다.

이러한 단점 때문에 이 메모는 여러 번 발명되었지만 아마도 원래 Phil Karn에 의한 것으로 추정되는 대체 체계를 채택했습니다. 이 방식에서는 번호가 지정되지 않은 지점 간 회선이 있는 라우터도 이 메모에서 router-id라고 하는 특수 IP 주소를 갖습니다. 라우터 ID는 다음 중 하나입니다.

라우터의 IP 주소\(라우터에는 하나 이상의 IP 주소가 필요함\) 이 라우터 ID는 번호가 지정되지 않은 모든 인터페이스의 IP 주소인 것처럼 사용됩니다.

---
### **2.2.8 Notable Oddities**
---
#### **2.2.8.1 Embedded Routers**

라우터는 IP 라우터 기능 전용인 독립형 컴퓨터 시스템일 수 있습니다. 또는 두 개 이상의 네트워크에 대한 연결을 지원하는 호스트 운영 체제 내에 라우터 기능을 내장할 수도 있습니다. 라우터 코드가 내장된 운영 체제의 가장 잘 알려진 예는 Berkeley BSD 시스템입니다. 내장된 라우터 기능을 사용하면 네트워크 구축이 쉬워지는 것처럼 보이지만 여기에는 숨겨진 함정이 많이 있습니다.

\(1\) 호스트에 단일 구성 네트워크 인터페이스만 있는 경우 라우터 역할을 해서는 안 됩니다.

- 예를 들어, 동일한 네트워크에서 브로드캐스트 패킷이나 데이터그램을 무료로 전달하는 라우터 코드가 내장된 호스트는 종종 패킷 사태를 유발합니다.

\(2\) \(멀티홈\) 호스트가 라우터 역할을 하는 경우 이 문서에 포함된 라우터 요구 사항을 따릅니다.

- 예를 들어, 라우팅 프로토콜 문제와 라우터 제어 및 모니터링 문제는 독립형 라우터와 마찬가지로 내장형 라우터에서도 어렵고 중요합니다.

- 인터넷 라우터 요구 사항 및 사양은 운영 체제 변경과 관계없이 변경될 수 있습니다. 인터넷에 내장된 라우터를 운영하는 행정부는 라우터 코드를 유지하고 업데이트할 것을 강력히 권고합니다. 이를 위해서는 라우터 소스 코드가 필요할 수 있습니다.

\(3\) 호스트가 내장된 라우터 코드를 실행하면 인터넷 인프라의 일부가 됩니다. 따라서 소프트웨어나 구성의 오류는 다른 호스트 간의 통신을 방해할 수 있습니다. 결과적으로 호스트 관리자는 일부 자율성을 상실해야 합니다.

- 대부분의 경우 호스트 관리자는 운영 체제에 내장된 라우터 코드를 비활성화해야 합니다. 이러한 이유로 내장된 라우터 기능을 비활성화하는 것은 간단해야 합니다.

\(4\) 내장된 라우터 코드를 실행하는 호스트가 다른 서비스에 동시에 사용될 경우 두 가지 사용 모드에 대한 운영 및 유지 관리 요구 사항이 충돌할 수 있습니다.

- 예를 들어, 라우터 O&M은 많은 경우 운영 센터에서 원격으로 수행됩니다. 이를 위해서는 호스트 관리자가 일반적으로 배포를 원하지 않는 권한 있는 시스템 액세스가 필요할 수 있습니다.

---
#### **2.2.8.2 Transparent Routers**

인터넷에는 근거리 네트워크와 광역\(또는 장거리\) 네트워크를 상호 연결하는 두 가지 기본 모델이 있습니다. 첫 번째에서는 LAN에 네트워크 접두사가 할당되고 인터넷의 모든 라우터는 해당 네트워크로 라우팅하는 방법을 알아야 합니다. 두 번째에서는 근거리 통신망이 광역 통신망의 주소 공간\(일부\)을 공유합니다. 이 두 번째 모델을 지원하는 라우터를 주소 공유 라우터 또는 투명 라우터라고 합니다. 이 메모의 초점은 첫 번째 모델을 지원하는 라우터에 있지만 투명 라우터의 사용을 배제하려는 의도는 아닙니다.

투명 라우터의 기본 아이디어는 해당 라우터 뒤에 있는 근거리 통신망의 호스트가 라우터 앞의 광역 네트워크의 주소 공간을 공유한다는 것입니다. 특정 상황에서는 이는 매우 유용한 접근 방식이며 이러한 제한 사항은 심각한 단점을 나타내지 않습니다.

앞과 뒤의 단어는 이 접근 방식의 한계 중 하나를 나타냅니다. 이 상호 연결 모델은 지리적으로\(및 위상적으로\) 제한된 스텁 환경에만 적합합니다. 광역 네트워크의 네트워크 수준 주소 지정에는 어떤 형태의 논리적 주소 지정이 필요합니다. 로컬 환경의 IP 주소는 광역 네트워크의 몇 가지\(일반적으로 하나\) 물리적 주소에 매핑됩니다. 이 매핑은 광역 네트워크 전체에서 사용되는 { IP 주소 <-\> 네트워크 주소 } 매핑과 일관된 방식으로 발생합니다.

멀티호밍은 하나의 광역 네트워크에서 가능하지만 인터페이스가 지리적으로 또는 위상적으로 분리된 경우 라우팅 문제가 발생할 수 있습니다. 두 개 이상의 광역 네트워크에서의 멀티호밍은 주소 혼동으로 인해 문제가 됩니다.

투명 라우터가 일반 광역 네트워크 서비스를 완전히 에뮬레이트할 수 없는 경우 동일한 네트워크인 것처럼 보이는 다른 호스트에서 호스트가 보는 동작은 다를 수 있습니다. 예를 들어, ARPANET은 오프라인인 호스트로 전송하려는 시도에 대한 응답으로 Destination Dead 표시를 제공하는 링크 계층 프로토콜을 사용했습니다. 그러나 두 노드 사이에 투명 라우터가 있는 경우

ARPANET 및 이더넷, ARPANET의 호스트는 이더넷 호스트에 대한 Destination Dead 표시를 수신하지 않습니다.

---
## **2.3 Router Characteristics**

인터넷 라우터는 다음 기능을 수행합니다.

\(1\) 인터넷 프로토콜\(IP\), 인터넷 제어 메시지 프로토콜\(ICMP\) 및 필요에 따라 기타 프로토콜을 포함하여 이 문서에 지정된 특정 인터넷 프로토콜을 준수합니다.

\(2\) 둘 이상의 패킷 네트워크에 인터페이스합니다. 연결된 각 네트워크에 대해 라우터는 해당 네트워크에 필요한 기능을 구현해야 합니다. 이러한 기능에는 일반적으로 다음이 포함됩니다.

```text
        o Encapsulating and decapsulating the IP datagrams with the
           connected network framing (e.g., an Ethernet header and
           checksum),

        o Sending and receiving IP datagrams up to the maximum size
           supported by that network, this size is the network's Maximum
           Transmission Unit or MTU,

        o Translating the IP destination address into an appropriate
           network-level address for the connected network (e.g., an
           Ethernet hardware address), if needed, and
```

- o 네트워크 흐름 제어 및 오류 표시\(있는 경우\)에 응답합니다.

```text
        See chapter 3 (Link Layer).
```

\(3\) 인터넷 데이터그램을 수신하고 전달합니다. 이 과정에서 중요한 이슈는 버퍼 관리, 혼잡 제어, 공정성이다.

- o 오류 조건을 인식하고 필요에 따라 ICMP 오류 및 정보 메시지를 생성합니다.

- o 수명 필드가 0에 도달한 데이터그램을 삭제합니다.

- o 다음 네트워크의 MTU에 맞추기 위해 필요한 경우 데이터그램을 조각화합니다.

- 자세한 내용은 4장\(인터넷 계층 - 프로토콜\) 및 5장\(인터넷 계층 - 전달\)을 참조하세요.

\(4\) 라우팅 데이터베이스의 정보를 기반으로 각 IP 데이터그램의 다음 홉 대상을 선택합니다. 자세한 내용은 5장\(인터넷 계층 - 전달\)을 참조하십시오.

\(5\) \(일반적으로\) 동일한 자율 시스템의 다른 라우터와 함께 분산 라우팅 및 도달 가능성 알고리즘을 수행하기 위해 내부 게이트웨이 프로토콜\(IGP\)을 지원합니다. 또한 일부 라우터는 다른 자율 시스템과 토폴로지 정보를 교환하기 위해 외부 게이트웨이 프로토콜\(EGP\)을 지원해야 합니다. 자세한 내용은 7장\(애플리케이션 계층 - 라우팅 프로토콜\)을 참조하세요.

\(6\) 로딩, 디버깅, 상태 보고, 예외 보고 및 제어를 포함한 네트워크 관리 및 시스템 지원 기능을 제공합니다. 자세한 내용은 8장\(응용 프로그램 계층 - 네트워크 관리 프로토콜\) 및 10장\(운영 및 유지 관리\)을 참조하십시오.

라우터 공급업체는 특정 라우터 제품의 성능, 복잡성 및 기능에 대해 다양한 선택권을 갖습니다. 인터넷 시스템이 동일하지도 않고 완전히 연결되어 있지도 않다는 점을 관찰하는 것이 도움이 될 수 있습니다. 기술과 지리상의 이유로 글로벌 상호 연결 시스템과 가장자리 주변의 LAN으로 성장하고 있습니다. 이러한 주변 LAN은 점점 더 긴밀하게 상호 연결되고 있으므로 주변 LAN에 대한 요구 사항이 줄어들고 라우터 요구 사항이 더 까다로워집니다.

o 글로벌 상호 연결 시스템은 여러 자율 시스템\(AS\)의 라우터가 연결된 다수의 광역 네트워크로 구성됩니다. 시스템에 직접 연결된 호스트는 상대적으로 적습니다.

o 대부분의 호스트는 LAN에 연결되어 있습니다. 많은 조직에는 로컬 라우터로 상호 연결된 LAN 클러스터가 있습니다. 이러한 각 클러스터는 하나 이상의 지점에서 라우터를 통해 글로벌 상호 연결 시스템으로 연결됩니다. LAN이 한 지점에만 연결된 경우 LAN을 스텁 네트워크라고 합니다.

글로벌 상호 연결 시스템의 라우터에는 일반적으로 다음이 필요합니다.

o 고급 라우팅 및 전달 알고리즘

- 이러한 라우터에는 매우 동적이고 처리 및 통신 부담을 최소화하며 서비스 유형 라우팅을 제공하는 라우팅 알고리즘이 필요합니다. 혼잡은 아직 완전히 해결되지 않은 문제입니다\(섹션 \[5.3.6\] 참조\). 연구 커뮤니티가 이러한 문제에 대해 적극적으로 노력하고 있으므로 이러한 분야의 개선이 예상됩니다.

```text
   o High Availability
```

- 이러한 라우터는 하루 24시간, 주 7일 서비스를 제공할 정도로 신뢰성이 높아야 합니다. 장비 및 소프트웨어 결함은 광범위한\(때로는 글로벌\) 영향을 미칠 수 있습니다. 장애가 발생하면 신속하게 복구해야 합니다. 어떤 환경에서든 라우터는 매우 견고해야 하며 네트워크 리소스의 극심한 정체 또는 장애 조건 하에서 성능이 저하된 상태에서도 작동할 수 있어야 합니다.

```text
   o Advanced O&M Features
```

- 인터넷 라우터는 일반적으로 무인 모드로 작동합니다. 일반적으로 중앙 집중식 모니터링 센터에서 원격으로 작동됩니다. 트래픽과 기타 이벤트를 모니터링 및 측정하고 오류를 진단하기 위한 정교한 수단을 제공해야 합니다.

```text
   o High Performance
```

- 오늘날 인터넷의 장거리 회선은 가장 빈번하게 전이중 56KBPS, DS1\(1.544Mbps\) 또는 DS3\(45Mbps\) 속도를 사용합니다. 반이중 다중 액세스 미디어인 LAN은 일반적으로 이더넷\(10Mbps\)이며, 정도는 덜하지만 FDDI\(100Mbps\)도 있습니다. 그러나 네트워크 미디어 기술은 지속적으로 발전하고 있으며 앞으로도 더 빠른 속도가 가능할 것으로 예상됩니다.

LAN 주변부\(예: 캠퍼스 네트워크\)에 사용되는 라우터에 대한 요구 사항은 로컬 네트워크의 요구 사항에 따라 크게 달라집니다. 이는 여러 공급업체에서 경쟁적으로 조달하고 내부 조직\(예: 캠퍼스 컴퓨팅 센터\)에서 운영하는 고성능 또는 중간 성능 장치일 수 있습니다. 이러한 라우터의 설계에서는 지연 및 서비스 유형에 민감한 리소스 관리와 함께 낮은 평균 대기 시간과 우수한 버스트 성능을 강조해야 합니다. 이러한 환경에서는 덜 공식적인 O&M이 있을 수 있지만 덜 중요하지는 않습니다. 네트워크가 더욱 복잡해지고 상호 연결됨에 따라 매우 동적인 라우팅 메커니즘에 대한 요구가 더욱 중요해질 것입니다. 사용자는 글로벌 상호 연결의 속도로 인해 로컬 연결에서 더 많은 것을 요구하게 됩니다.

네트워크가 성장하고 더 많은 네트워크가 오래된 장비를 단계적으로 폐기할 만큼 노후화됨에 따라 라우터가 다른 공급업체의 라우터와 상호 운용되는 것이 점점 더 중요해지고 있습니다.

인터넷 시스템이 완전히 상호 연결되어 있지 않더라도 시스템의 많은 부분에는 중복 연결이 필요합니다. 풍부한 연결성을 통해 통신 회선 및 라우터 장애에도 안정적인 서비스가 가능하며, 이를 통해 서비스 향상도 가능합니다.

인터넷 경로를 단축하고 추가 용량을 제공합니다. 불행하게도 이러한 더욱 풍부한 토폴로지는 특정 대상에 대한 최상의 경로를 선택하는 것을 훨씬 더 어렵게 만들 수 있습니다.

---
## **2.4 Architectural Assumptions**

현재 인터넷 아키텍처는 통신 시스템에 대한 일련의 가정을 기반으로 합니다. 라우터와 가장 관련된 가정은 다음과 같습니다.

o 인터넷은 네트워크의 네트워크입니다.

- 각 호스트는 특정 네트워크에 직접 연결됩니다. 인터넷과의 연결은 단지 개념적일 뿐입니다. 동일한 네트워크에 있는 두 호스트는 멀리 있는 네트워크에 있는 호스트와 통신하는 데 사용하는 것과 동일한 프로토콜 집합을 사용하여 서로 통신합니다.

```text
   o Routers do not keep connection state information.
```

- 통신 시스템의 견고성을 향상시키기 위해 라우터는 상태 비저장으로 설계되어 각 IP 패킷을 다른 패킷과 독립적으로 전달합니다. 결과적으로, 중간에 존재하는 라우터와 네트워크의 장애에도 불구하고 중복된 경로를 활용하여 견고한 서비스를 제공할 수 있습니다.

- 종단 간 흐름 제어 및 신뢰성에 필요한 모든 상태 정보는 호스트, 전송 계층 또는 응용 프로그램에서 구현됩니다. 따라서 모든 연결 제어 정보는 통신의 끝점과 같은 위치에 있으므로 끝점에 오류가 발생한 경우에만 손실됩니다. 라우터는 패킷을 삭제하거나 네트워크 지연을 증가시키는 등 간접적으로만 메시지 흐름을 제어합니다.

- 향후 프로토콜 개발로 인해 라우터에 더 많은 상태가 포함될 수 있습니다. 이는 특히 멀티캐스트 라우팅, 리소스 예약 및 흐름 기반 전달에서 발생할 가능성이 높습니다.

o 라우팅 복잡성은 라우터에 있어야 합니다.

- 라우팅은 복잡하고 어려운 문제이므로 호스트가 아닌 라우터에 의해 수행되어야 합니다. 중요한 목표는 인터넷 라우팅 아키텍처의 불가피한 발전으로 인한 변경으로부터 호스트 소프트웨어를 보호하는 것입니다.

o 시스템은 광범위한 네트워크 변화를 허용해야 합니다.

- 인터넷 설계의 기본 목표는 대역폭, 지연, 패킷 손실, 패킷 재정렬, 최대 패킷 크기 등 광범위한 네트워크 특성을 허용하는 것입니다. 또 다른 목표는 여전히 사용 가능한 대역폭을 사용하여 개별 네트워크, 라우터 및 호스트의 오류에 대한 견고성입니다. 마지막으로 목표는 완전한 개방형 시스템 상호 연결입니다. 즉, 인터넷 라우터는 다양한 인터넷 경로에서 다른 라우터 또는 인터넷 호스트와 강력하고 효과적으로 상호 운용할 수 있어야 합니다.

- 때때로 구현자는 덜 야심찬 목표를 위해 설계했습니다. 예를 들어, LAN 환경은 일반적으로 인터넷 전체보다 훨씬 더 온화합니다. LAN은 패킷 손실과 지연이 적고 패킷 순서를 바꾸지 않습니다. 일부 공급업체는 단순한 LAN 환경에는 적합하지만 일반적인 상호 운용에는 적합하지 않은 구현을 현장에 적용했습니다. 공급업체는 제한된 LAN 시장 내에서 이러한 제품이 경제적이라고 정당화합니다. 그러나 격리된 LAN은 오랫동안 격리된 상태로 유지되는 경우가 거의 없습니다. 그들은 곧 서로 연결되고, 조직 전체의 인터넷에 연결되고, 궁극적으로는 글로벌 인터넷 시스템에 연결됩니다. 결국 고객이나 공급업체 모두 불완전하거나 표준 이하의 라우터를 사용할 수 없습니다.

- 이 문서의 요구 사항은 전체 기능을 갖춘 라우터를 위해 설계되었습니다. 완벽하게 호환되는 라우터를 인터넷의 거의 모든 부분에서 사용할 수 있도록 의도되었습니다.

---
## **3. LINK LAYER**

\[소개:1\]은 링크 계층 표준\(다양한 링크 계층을 통한 IP, ARP 등\)을 다루지만 이 문서에서는 링크 계층 자료가 별도의 링크 계층 요구 사항 문서에서 다루어질 것으로 예상합니다. 링크 계층 요구 사항 문서는 호스트와 라우터 모두에 적용 가능합니다. 따라서 이 문서는 링크 계층 문제를 다루는 \[INTRO:1\] 부분을 폐기하지 않습니다.

---
## **3.1 INTRODUCTION**

라우터는 기본적으로 다른 종류의 인터넷 시스템과 동일한 링크 계층 프로토콜 요구 사항을 갖습니다. 이러한 요구 사항은 인터넷 게이트웨이 요구 사항\[소개:1\]의 3장에 나와 있습니다. 라우터는 요구 사항을 준수해야 하며 권장 사항을 준수해야 합니다. 해당 문서의 일부 자료는 다소 오래된 것이므로 몇 가지 추가 요구 사항 및 설명이 아래에 포함되어 있습니다.\(MUST\)

논의

- 인터넷 커뮤니티에서는 이 장과 \[소개:1\]의 "인터넷 계층 프로토콜"이라는 제목의 장을 대체하는 인터넷 링크 계층 표준에 대한 요구 사항을 만들 것으로 예상됩니다.

---
## **3.2 LINK/INTERNET LAYER INTERFACE**

이 문서에서는 링크 레이어와 상위 레이어 간의 인터페이스를 지정하려고 시도하지 않습니다. 그러나 이 문서의 다른 부분, 특히 5장에서는 이 레이어 경계를 넘어 다양한 종류의 정보를 전달해야 한다는 점에 유의하세요.

이 섹션에서는 다음 정의를 사용합니다.

```text
   o Source physical address
```

- 소스 물리적 주소는 패킷을 수신한 호스트 또는 라우터의 링크 계층 주소입니다.

```text
   o Destination physical address
```

- 목적지 물리 주소는 패킷이 전송된 링크 계층 주소입니다.

수신된 각 패킷에 대해 링크 계층에서 인터네트워크 계층으로 전달되어야 하는 정보는 다음과 같습니다.

```text
   (1) The IP packet [5.2.2],

   (2) The length of the data portion (i.e., not including the Link-
        Layer framing) of the Link Layer frame [5.2.2],
```

\(3\) IP 패킷이 수신된 물리적 인터페이스의 ID \[5.2.3\]

\(4\) 패킷의 목적지 물리적 주소를 링크 계층 유니캐스트, 브로드캐스트 또는 멀티캐스트로 분류\[4.3.2\], \[5.3.4\].

또한 링크 계층은 다음도 제공해야 합니다.

\(5\) 소스 물리적 주소.

전송된 각 패킷에 대해 인터네트워크 계층에서 링크 계층으로 전달되어야 하는 정보는 다음과 같습니다.

\(1\) IP 패킷 \[5.2.1\]

\(2\) IP 패킷의 길이 \[5.2.1\]

\(3\) 목적지 물리적 인터페이스 \[5.2.1\]

\(4\) 다음 홉 IP 주소 \[5.2.1\]

또한, 인터네트워크 계층은 다음도 제공해야 합니다.

\(5\) Link Layer 우선순위 값 \[5.3.3.2\]

Link Layer는 또한 전송하려는 패킷이 Link Layer 우선순위 관련 오류를 발생시키는 경우 Internetwork Layer에 이를 알려야 합니다\[5.3.3.3\].

---
## **3.3 SPECIFIC ISSUES**
---
### **3.3.1 Trailer Encapsulation**

10메가비트 이더넷에 연결할 수 있는 라우터는 \[LINK:1\]에 설명된 트레일러 캡슐화를 사용하여 캡슐화된 이더넷 패킷을 수신하고 전달할 수 있습니다. 그러나 라우터는 캡슐화된 트레일러 패킷을 생성해서는 안 됩니다. 라우터는 \[INTRO:2\]에 설명된 메커니즘을 사용하여 패킷의 즉각적인 대상이 트레일러 캡슐화된 패킷을 기꺼이 받아들일 수 있는지를 먼저 확인하지 않고는 트레일러 캡슐화된 패킷을 시작해서는 안 됩니다\(MUST NOT\). 라우터는 \(이러한 메커니즘을 사용하여\) 트레일러 캡슐화된 패킷을 수락하는 데 동의해서는 안 됩니다.\(MAY, SHOULD NOT, MUST NOT, SHOULD NOT\)

---
### **3.3.2 Address Resolution Protocol - ARP**

ARP를 구현하는 라우터는 반드시 준수해야 하며 \[INTRO:2\]의 요구 사항을 무조건 준수해야 합니다.\(MUST\)

링크 계층은 대상에 대한 ARP 캐시 항목이 없기 때문에 IP에 대상 도달 불가능 오류를 보고해서는 안 됩니다. ARP 요청/응답 시퀀스를 수행하는 동안 짧은 수의 데이터그램까지 대기열에 추가해야 하며, 이것이 효과가 없는 것으로 판명된 경우에만 대기열에 있는 데이터그램 중 하나에 대상에 도달할 수 없다고 응답해야 합니다.\(MUST NOT\)

라우터는 다른 호스트나 라우터의 링크 계층 주소가 브로드캐스트 또는 멀티캐스트 주소라고 주장하는 ARP 응답을 믿어서는 안 됩니다.\(MUST\)

---
### **3.3.3 Ethernet and 802.3 Coexistence**

10메가비트 이더넷에 연결할 수 있는 라우터는 반드시 준수해야 하며 \[INTRO:2\]의 이더넷 요구 사항을 무조건 준수해야 합니다.\(MUST\)

---
### **3.3.4 Maximum Transmission Unit - MTU**

각 논리적 인터페이스의 MTU는 인터페이스의 적법한 MTU 범위 내에서 구성 가능해야 합니다.\(MUST\)

많은 링크 계층 프로토콜은 전송될 수 있는 최대 프레임 크기를 정의합니다. 이러한 경우 라우터는 링크 계층 프로토콜에서 허용하는 것보다 더 큰 프레임 전송을 허용하는 MTU 설정을 허용해서는 안 됩니다. 그러나 라우터는 MTU보다 큰 경우에도 최대 프레임 크기만큼 큰 패킷을 수신할 의향이 있어야 합니다.\(MUST NOT, SHOULD\)

논의

- 이는 각 물리적 인터페이스의 MTU를 구성할 수 있어야 하는 \[INTRO:2\]에 의해 호스트에 적용되는 것보다 더 엄격한 요구 사항입니다.

- 네트워크가 링크 계층의 최대 프레임 크기보다 작은 MTU를 사용하는 경우 라우터는 잘못 구성되고 불완전하게 초기화된 호스트로부터 MTU보다 큰 패킷을 수신할 수 있습니다. 견고성 원칙은 라우터가 가능하다면 이러한 패킷을 성공적으로 수신해야 함을 나타냅니다.

---
### **3.3.5 Point-to-Point Protocol - PPP**

\[INTRO:1\]과 달리 인터넷에는 \[LINK:2\], \[LINK:3\], \[LINK:4\]에 정의된 지점 간 프로토콜\(PPP\)이라는 표준 지점 간 회선 프로토콜이 있습니다. , 및 \[링크:5\].

지점 간 인터페이스는 지점 간 회선을 통해 데이터를 전송하도록 설계된 인터페이스입니다. 이러한 인터페이스에는 전화, 임대, 전용 또는 직통 회선\(2선 또는 4선\)이 포함되며 ISDN과 같은 다중화 인터페이스의 가상 회선이나 지점 간 채널을 사용할 수 있습니다. 이들은 일반적으로 동기식 또는 비동기식 클록킹을 사용하는 표준화된 모뎀이나 비트 직렬 인터페이스\(예: RS-232, RS-449 또는 V.35\)를 사용합니다. 다중화 인터페이스에는 특별한 물리적 인터페이스가 있는 경우가 많습니다.

범용 직렬 인터페이스는 지점 간 회선과 동일한 물리적 미디어를 사용하지만 지점 간 연결은 물론 링크 계층 네트워크의 사용도 지원합니다. 링크 계층 네트워크\(예: X.25 또는 프레임 릴레이\)는 대체 IP 링크 계층 사양을 사용합니다.

지점 간 또는 범용 직렬 인터페이스를 구현하는 라우터는 PPP를 구현해야 합니다.\(MUST\)

PPP는 라우터의 모든 범용 직렬 인터페이스에서 지원되어야 합니다. 라우터는 회선이 PPP 이외의 지점간 회선 프로토콜을 사용하도록 구성되도록 허용할 수 있습니다. 지점 간 인터페이스는 활성화될 때 기본적으로 PPP를 사용하도록 설정하거나 활성화하기 전에 링크 계층 프로토콜의 구성을 요구해야 합니다. 범용 직렬 인터페이스는 활성화되기 전에 링크 계층 프로토콜의 구성을 요구해야 합니다\(SHOULD\).\(MUST, MAY, SHOULD, SHOULD\)

---
#### **3.3.5.1 Introduction**

이 섹션에서는 동기 또는 비동기 링크를 통해 PPP를 사용하는 다른 라우터와의 상호 운용성을 보장할 수 있도록 라우터 구현자에게 지침을 제공합니다.

구현자가 옵션 협상 메커니즘의 의미를 이해하는 것이 중요합니다. 옵션은 로컬 장치가 전송하려는 내용이 아니라 원격 피어로부터 수락할 내용을 원격 피어에 표시하는 수단입니다. 로컬 장치가 허용할 수 있다고 명시한 옵션 집합의 범위 내에서 전송하는 것이 가장 편리한 것을 결정하는 것은 원격 피어의 몫입니다. 따라서 원격 피어가 LCP 구성 요청\(CR\)에 표시된 모든 옵션을 ACK하는 것은 원격 피어가 이러한 옵션을 지원하지 않는 경우에도 완벽하게 허용되며 정상입니다. 다시 말하지만, 옵션은 각 장치가 전송할 내용이 아니라 수락할 내용을 피어에게 알려주는 단순한 메커니즘입니다.

---
#### **3.3.5.2 Link Control Protocol (LCP) Options**

PPP LCP\(링크 제어 프로토콜\)는 협상할 수 있는 다양한 옵션을 제공합니다. 이러한 옵션에는 주소 및 제어 필드 압축, 프로토콜 필드 압축, 비동기 문자 맵, MRU\(최대 수신 단위\), LQM\(링크 품질 모니터링\), 매직 넘버\(루프백 감지용\), PAP\(암호 인증 프로토콜\), CHAP\(Challenge Handshake 인증 프로토콜\) 및 32비트 FCS\(프레임 검사 시퀀스\).

라우터는 동기 또는 비동기 링크에서 주소/제어 필드 압축을 사용할 수 있습니다. 라우터는 동기 또는 비동기 링크에서 프로토콜 필드 압축을 사용할 수 있습니다. 이러한 압축을 받아들일 수 있음을 나타내는 라우터는 압축되지 않은 PPP 헤더 정보도 받아들일 수 있어야 합니다.\(MAY, MAY, MUST\)

논의

- 이 옵션은 PPP 헤더의 모양을 제어합니다. 일반적으로 PPP 헤더는 주소, 제어 필드, 프로토콜 필드로 구성됩니다. 지점 간 라인의 주소는 0xFF이며 "브로드캐스트"를 나타냅니다. 제어 필드는 "번호가 없는 정보"를 나타내는 0x03입니다. 프로토콜 식별자는 프레임의 데이터 영역 내용을 나타내는 2바이트 값입니다. 시스템이 주소 및 제어 필드 압축을 협상하는 경우 헤더 앞에 이러한 필드가 있거나 없는 PPP 프레임을 허용한다는 것을 피어에게 알립니다. 이는 해당 필드가 제거된 프레임을 보낼 것이라는 의미는 아닙니다.

- 협상 시 프로토콜 필드 압축은 이것이 합법적일 때 시스템이 1바이트로 압축된 프로토콜 필드를 수신할 의사가 있음을 나타냅니다. 발신자가 그렇게 해야 한다는 요구 사항은 없습니다.

- 주소/제어 필드 압축 사용은 숫자 모드\(신뢰할 수 있는\) PPP 사용과 일치하지 않습니다.

구현

- 일부 하드웨어는 가변 길이 헤더 정보를 제대로 처리하지 못합니다. 이러한 경우 원격 피어가 전체 PPP 헤더를 보내는 것이 가장 합리적입니다. 구현에서는 주소/제어 필드 및 프로토콜 필드 압축 옵션을 원격 피어에 보내지 않음으로써 이를 보장할 수 있습니다. 원격 피어가 압축된 헤더를 수신할 수 있다고 표시한 경우에도 로컬 라우터가 압축된 헤더를 보낼 필요는 없습니다.

라우터는 비동기 PPP 링크에 대한 ACCM\(비동기 제어 문자 맵\)을 협상해야 하지만 동기 링크에 대한 ACCM을 협상해서는 안 됩니다. 라우터가 동기 링크를 통해 ACCM을 협상하려는 시도를 수신하는 경우 반드시 옵션을 확인하고 무시해야 합니다.\(MUST, MUST\)

논의

- 동기식 및 비동기식 작업 모드를 모두 제공하고 동일한 코드를 사용하여 옵션 협상을 구현하는 구현이 있습니다. 이 상황에서는 한쪽 끝이나 다른 쪽 끝이 동기 링크에서 ACCM 옵션을 보낼 수 있습니다.

라우터는 MRU\(최대 수신 단위\)를 적절하게 협상해야 합니다. 시스템이 1,500바이트보다 작은 MRU를 협상하더라도 1,500바이트 프레임을 수신할 수 있어야 합니다.\(SHOULD, MUST\)

라우터는 링크 품질 모니터링\(LQM\) 옵션을 협상하고 활성화해야 합니다.\(SHOULD\)

논의

- 본 메모에는 링크 품질의 적정성을 판단하는 정책이 명시되어 있지 않습니다. 그러나 라우터가 실패한 링크를 비활성화하는 것이 중요합니다\(섹션 \[3.3.6\] 참조\).

라우터는 루프백 감지를 위한 매직 넘버 옵션을 구현하고 협상해야 합니다.\(SHOULD\)

라우터는 인증 옵션\(PAP - 비밀번호 인증 프로토콜 및/또는 CHAP - Challenge Handshake 인증 프로토콜\)을 지원할 수 있습니다.\(MAY\)

라우터는 16비트 CRC 프레임 검사 시퀀스\(FCS\)를 지원해야 하며\(MUST\) 32비트 CRC를 지원할 수 있습니다.\(MUST\)

---
#### **3.3.5.3 IP Control Protocol (IPCP) Options**

라우터는 IP 주소 협상을 수행하도록 제안할 수 있습니다. 라우터는 피어로부터 IP 주소 협상을 수행하는 거부\(REJect\)를 수락해야 합니다.\(MAY, MUST\)

19,200 BPS 이하의 링크 속도에서 작동하는 라우터는 Van Jacobson 헤더 압축을 구현하고 수행해야 합니다. VJ 압축을 구현하는 라우터는 이를 활성화하거나 비활성화하는 관리 제어를 구현해야 합니다.\(SHOULD, SHOULD\)

---
### **3.3.6 Interface Testing**

라우터에는 라우팅 소프트웨어가 패킷 전송에 물리적 인터페이스를 사용할 수 있는지 여부를 결정할 수 있는 메커니즘이 있어야 합니다. 제한된 이웃 집합에 대해 영구 가상 회선이 열리는 다중화 인터페이스에서 라우터는 가상 회선이 실행 가능한지 여부도 확인할 수 있어야 합니다. 라우터에는 라우팅 소프트웨어가 물리적 인터페이스의 품질을 판단할 수 있는 메커니즘이 있어야 합니다. 라우터에는 관리 작업으로 인해 물리적 인터페이스가 패킷을 보낼 수 있게 되거나 사용할 수 없게 될 때 라우팅 소프트웨어에 알리는 메커니즘이 있어야 합니다. 라우터에는 어떤 이유로든 링크 수준 인터페이스가 사용 가능하거나 사용할 수 없게 되었음을 감지할 때 라우팅 소프트웨어에 알리는 메커니즘이 있어야 합니다.\(MUST, SHOULD, MUST, MUST\)

논의

- 라우터가 네트워크 연결이 제대로 작동하는지 확인하기 위한 실행 가능한 메커니즘을 갖는 것이 중요합니다. 링크 손실을 감지하지 못하거나 문제 감지 시 적절한 조치를 취하지 못하면 블랙홀이 발생할 수 있습니다.

- 네트워크 연결 문제를 감지하는 데 사용할 수 있는 메커니즘은 사용 중인 링크 계층 프로토콜과 인터페이스 하드웨어에 따라 상당히 다릅니다. 이는 링크 계층 제약 조건 내에서 오류를 감지하는 기능을 최대화하는 것입니다.

---
## **4. INTERNET LAYER - PROTOCOLS**
---
## **4.1 INTRODUCTION**

이 장과 5장에서는 인터넷 계층에서 사용되는 프로토콜인 IP, ICMP 및 IGMP에 대해 설명합니다. 전달은 라우터를 논의하는 문서에서 분명히 중요한 주제이기 때문에 5장은 전달과 직접적으로 관련된 프로토콜 측면으로 제한됩니다. 현재 장에는 인터넷 계층 프로토콜에 대한 나머지 논의가 포함되어 있습니다.

---
## **4.2 INTERNET PROTOCOL - IP**
---
### **4.2.1 INTRODUCTION**

라우터는 \[INTERNET:1\]에 정의된 대로 IP 프로토콜을 구현해야 합니다. 또한 필수 확장인 서브넷\(\[INTERNET:2\]에 정의됨\), IP 브로드캐스트\(\[INTERNET:3\]에 정의됨\) 및 클래스 없는 도메인 간 라우팅\(CIDR, \[INTERNET:15\]에 정의됨\)을 구현해야 합니다.\(MUST, MUST\)

라우터 구현자는 "인터넷 프로토콜 - IP"라는 제목의 \[소개:2\] 섹션을 준수하는 것을 고려할 필요가 없습니다. 해당 섹션은 이 문서에서 완전히 복제되거나 대체되기 때문입니다. 라우터는 \[소개:2\]의 IP와 관련된 "특정 문제" 섹션의 요구 사항을 준수해야 하며 무조건 준수해야 합니다.\(MUST\)

다음에서 특정 경우에 지정된 작업은 수신된 데이터그램을 자동으로 삭제하는 것입니다. 이는 데이터그램이 추가 처리 없이 삭제되고 결과적으로 라우터가 ICMP 오류 메시지\(섹션 \[4.3\] 참조\)를 보내지 않음을 의미합니다. 그러나 문제 진단을 위해 라우터는 자동으로 폐기된 데이터그램의 내용을 포함하여 오류를 기록하는 기능\(섹션 \[1.3.3\] 참조\)을 제공해야 하며 폐기된 데이터그램 수를 계산해야 합니다.\(SHOULD\)

---
### **4.2.2 PROTOCOL WALK-THROUGH**

RFC 791 \[INTERNET:1\]은 인터넷 프로토콜에 대한 사양입니다.

---
#### **4.2.2.1 Options: RFC 791 Section 3.2**

라우터 자체가 수신한 데이터그램에서 IP 계층은 자신이 이해하는 IP 옵션을 해석하고 상위 계층 프로토콜에서 사용할 수 있도록 나머지는 변경하지 않고 보존해야 합니다.\(MUST\)

상위 계층 프로토콜에는 보내는 데이터그램에 IP 옵션을 설정하거나 받는 데이터그램에 있는 IP 옵션을 검사하는 기능이 필요할 수 있습니다. 이 문서의 뒷부분에서는 상위 계층 프로토콜에 필요한 특정 IP 옵션 지원에 대해 설명합니다.

논의

- 이 메모나 \[INTRO:2\]는 수신기가 동일한 IP 헤더에서 여러 옵션을 처리해야 하는 순서를 정의하지 않습니다. 여러 옵션이 포함된 데이터그램을 생성하는 호스트와 라우터는 소스 경로 옵션과 결합할 때 특정 옵션의 의미가 모호해진다는 점을 인식해야 합니다.

특정 IP 옵션에 대한 요구 사항은 다음과 같습니다.

```text
   (a) Security Option
```

- 일부 환경에서는 생성되거나 수신되는 모든 패킷에 보안 옵션이 필요합니다. 라우터는 \[INTERNET:5\]에 설명된 개정된 보안 옵션을 구현해야 합니다.\(SHOULD\)

논의

- \[INTERNET:1\] 및 RFC 1038\(\[INTERNET:16\]\)에 설명된 보안 옵션은 더 이상 사용되지 않습니다.

```text
   (b) Stream Identifier Option
```

- 이 옵션은 더 이상 사용되지 않습니다. 라우터는 라우터가 생성한 데이터그램에 이 옵션을 배치해서는 안 됩니다. 이 옵션은 라우터가 수신한 데이터그램에서 무시되어야 합니다.\(SHOULD NOT, MUST\)

```text
   (c) Source Route Options
```

- 라우터는 소스 경로의 최종 목적지 역할을 할 수 있어야 합니다. 라우터가 완전한 소스 경로가 포함된 패킷을 수신하면 패킷은 최종 목적지에 도달한 것입니다. 이러한 옵션에서 포인터는 IP 헤더의 마지막 필드와 대상 주소 너머를 가리킵니다.\(MUST\)

- 라우터 주소를 지정합니다. 수신된 옵션\(기록된 경로\)은 전송 계층\(또는 ICMP 메시지 처리\)으로 전달되어야 합니다.\(MUST\)

- 일반적으로 소스 라우팅 데이터그램에 대한 올바른 응답은 동일한 경로를 통과합니다. 라우터는 전송 프로토콜과 애플리케이션이 수신된 데이터그램에서 소스 경로를 역전할 수 있는 수단을 제공해야 합니다. 이 역방향 소스 경로는 라우터가 정책 제약을 인식하지 못하는 경우 발생하는 데이터그램에 삽입되어야 합니다\(자세한 내용은 \[INTRO:2\] 참조\). 그러나 라우터가 정책을 인식하는 경우 다른 경로를 선택할 수도 있습니다.\(MUST, MUST, MAY\)

- 라우터의 일부 애플리케이션에서는 사용자가 소스 경로를 입력할 수 있어야 할 수도 있습니다.\(MAY\)

- 라우터는 여러 소스 경로 옵션을 포함하는 데이터그램을 생성해서는 안 됩니다. 여러 소스 경로 옵션이 포함된 패킷을 전달하라는 요청을 받은 경우 라우터가 수행해야 하는 작업은 섹션 \[5.2.4.1\]에 설명되어 있습니다.\(MUST NOT\)

- 소스 경로 옵션이 생성되면\(라우터가 소스 라우팅 데이터그램을 시작하거나 특수 필터의 결과로 소스 경로 옵션을 삽입할 때 발생함\) 역방향으로 생성되더라도 올바르게 구성되어야 합니다. 소스 호스트를 잘못 포함하는 기록된 경로\(아래 설명의 사례 \(B\) 참조\)\(MUST\)

논의

- 소스 라우팅 데이터그램이 소스 \_S에서 라우터 G1, G2, Gn을 통해 대상 D로 라우팅된다고 가정합니다. 소스 S는 G1의 IP 주소를 대상 주소로 사용하고 데이터그램을 대상까지 나머지 경로로 가져오기 위한 소스 경로 옵션을 사용하여 데이터그램을 구성합니다. 그러나 S가 보낸 데이터그램의 소스 경로 옵션이 \(A\)인지 \(B\)인지에 대한 사양에는 모호성이 있습니다.

```text
      (A): {>>G2, G3, ... Gn, D} <--- CORRECT

      (B): {S, >>G2, G3, ... Gn, D} <---- WRONG
```

- \(여기서 \>\>는 포인터를 나타냄\) \(A\)가 전송되면 D에서 수신된 데이터그램에는 S와 D가 IP 소스 및 대상 주소인 {G1, G2, ... Gn \>\>} 옵션이 포함됩니다. \(B\)가 전송된 경우 D에서 수신된 데이터그램에는 S와 D가 동일한 IP 소스 및 대상 주소로 다시 포함되지만 옵션은 다음과 같습니다. {S, G1, ...Gn \>\>}; 즉, 원래 호스트는 경로의 첫 번째 홉이 됩니다.

```text
   (d) Record Route Option
```

- 라우터는 라우터에서 생성된 데이터그램의 경로 기록 옵션을 지원할 수 있습니다.\(MAY\)

```text
   (e) Timestamp Option
```

라우터는 데이터그램의 타임스탬프 옵션을 지원할 수 있습니다\(MAY\).

- 라우터에서 시작되었습니다. 다음 규칙이 적용됩니다.\(MAY\)

- o 타임스탬프 옵션을 포함하는 데이터그램을 생성할 때 라우터는 다음과 같은 경우 옵션에 타임스탬프를 기록해야 합니다.\(MUST\)

- - 인터넷 주소 필드가 미리 지정되지 않았거나 - 미리 지정된 첫 번째 주소는 데이터그램이 전송되는 논리적 인터페이스의 IP 주소\(또는 데이터그램이 번호가 지정되지 않은 인터페이스를 통해 전송되는 경우 라우터의 라우터 ID\)입니다. 상호 작용\).

- o 라우터 자체가 타임스탬프 옵션을 포함하는 데이터그램을 수신하는 경우 라우터는 처리를 위해 옵션을 전송 계층이나 ICMP에 전달하기 전에 타임스탬프 옵션에 현재 시간을 삽입해야 합니다\(옵션에 공간이 있는 경우\). . 공간이 없으면 라우터는 옵션에서 오버플로 횟수를 늘려야 합니다.\(MUST, MUST\)

- o 타임스탬프 값은 \[INTRO:2\]에 정의된 규칙을 따라야 합니다.\(MUST\)

구현

- 타임스탬프 옵션에 포함된 타임스탬프의 유용성을 최대화하려면 삽입된 타임스탬프는 가능한 한 패킷이 라우터에 도착한 시간과 가까워야 합니다. 라우터에서 시작된 데이터그램의 경우 삽입된 타임스탬프는 데이터그램이 전송을 위해 링크 계층으로 전달된 시간과 최대한 가까워야 합니다.

- 타임스탬프 옵션은 비표준 시간 시계의 사용을 허용하지만, 비동기화 시계를 사용하면 타임 스탬프의 유용성이 제한됩니다. 따라서 라우터는 시계 동기화를 위해 네트워크 시간 프로토콜을 구현하는 것이 좋습니다.

---
#### **4.2.2.2 Addresses in Options: RFC 791 Section 3.1**

라우터는 레코드 경로, 엄격한 소스 및 레코드 경로, 느슨한 소스 및 레코드 경로 또는 타임스탬프 옵션에 주소를 삽입하도록 요청됩니다. 라우터가 해당 옵션에 자신의 주소를 삽입할 때 해당 옵션이 있는 논리적 인터페이스의 IP 주소를 사용해야 합니다.\(MUST\)

패킷이 전송되고 있습니다. 출력 인터페이스에 IP 주소가 없기 때문에\(즉, 번호가 지정되지 않은 인터페이스\) 이 규칙을 따를 수 없는 경우 라우터는 대신 라우터 ID를 삽입해야 합니다. 라우터의 router-id는 라우터의 IP 주소 중 하나입니다. 라우터 ID는 시스템 기준으로 또는 링크별로 지정할 수 있습니다. 라우터 ID로 사용되는 라우터의 주소는 네트워크 관리자가 변경하지 않는 한 \(재부팅 후에도\) 변경되어서는 안 됩니다. 관련 관리 변경 사항에는 router-id로 사용되는 IP 주소가 더 이상 라우터의 IP 주소 중 하나가 되지 않도록 라우터 재구성이 포함됩니다. 번호가 지정되지 않은 여러 개의 인터페이스가 있는 라우터는 여러 개의 라우터 ID를 가질 수 있습니다. 번호가 지정되지 않은 각 인터페이스는 특정 라우터 ID와 연결되어야 합니다. 이 연결은 라우터를 재구성하지 않고는 \(재부팅 후에도\) 변경되어서는 안 됩니다.\(MUST, MUST NOT, MAY, MUST, MUST NOT\)

논의

- 이 사양은 IP 주소가 하나도 없는 라우터를 허용하지 않습니다. 라우터가 지점 간 링크에만 연결되어 있는 경우에도 \[8\]장의 관리 효율성 요구 사항을 충족하려면 라우터에 IP 주소가 필요하기 때문에 우리는 이것을 심각한 제한으로 간주하지 않습니다.

```text
   IMPLEMENTATION
```

- 이 요구 사항을 충족하는 라우터 ID를 선택하는 한 가지 가능한 방법은 라우터에 할당된 숫자로 가장 작은\(또는 가장 큰\) IP 주소\(주소를 32비트 정수로 처리\)를 사용하는 것입니다.

---
#### **4.2.2.3 Unused IP Header Bits: RFC 791 Section 3.1**

IP 헤더에는 두 개의 예약된 비트가 포함되어 있습니다. 하나는 서비스 유형 바이트에 있고 다른 하나는 플래그 필드에 있습니다. 라우터는 라우터에서 생성된 데이터그램에서 이러한 비트 중 하나를 1로 설정해서는 안 됩니다. 라우터는 단지 이러한 예약된 비트 중 하나 이상이 0이 아닌 값을 갖는다는 이유만으로 패킷을 삭제\(수신 또는 전달 거부\)해서는 안 됩니다. 즉, 라우터는 s 비트의 값을 확인해서는 안 됩니다.\(MUST NOT, MUST NOT\)

논의

- IP 프로토콜의 향후 개정판에서는 이러한 사용되지 않은 비트를 활용할 수 있습니다. 이러한 규칙은 인터넷의 모든 라우터를 동시에 업그레이드하지 않고도 이러한 개정판을 배포할 수 있도록 하기 위한 것입니다.

---
#### **4.2.2.4 Type of Service: RFC 791 Section 3.1**

IP 헤더의 서비스 유형 바이트는 우선순위 필드\(상위 3비트\), 관례적으로 서비스 유형 또는 TOS\(다음 4비트\)라고 불리는 필드, 예약된 비트\( 낮은 순서 비트\).

예약된 비트를 관리하는 규칙은 섹션 \[4.2.2.3\]에 설명되어 있습니다.

TOS 필드와 그 사용에 대한 보다 광범위한 논의는 \[ROUTE:11\]에서 찾을 수 있습니다.

IP 우선순위 필드에 대한 설명은 섹션 \[5.3.3\]으로 대체됩니다. RFC 795, 서비스 매핑은 더 이상 사용되지 않으며 구현해서는 안 됩니다.\(SHOULD NOT\)

---
#### **4.2.2.5 Header Checksum: RFC 791 Section 3.1**

섹션 \[5.2.2\]에 명시된 대로 라우터는 수신된 모든 패킷의 IP 체크섬을 확인해야 하며 유효하지 않은 체크섬이 포함된 메시지를 폐기해야 합니다. 라우터는 이 체크섬 확인을 비활성화하는 수단을 제공해서는 안 됩니다.\(MUST, MUST NOT\)

IP 헤더에 대한 유일한 변경 사항이 TTL\(Time to Live\)일 때 라우터는 증분식 IP 헤더 체크섬 업데이트를 사용할 수 있습니다. 이렇게 하면 라우터가 감지하지 못한 IP 헤더 손상 가능성을 줄일 수 있습니다. 체크섬을 점진적으로 업데이트하는 방법에 대한 설명은 \[INTERNET:6\]을 참조하세요.\(MAY\)

구현

- 광범위한 구현 힌트를 포함하여 IP 체크섬에 대한 보다 광범위한 설명은 \[INTERNET:6\] 및 \[INTERNET:7\]에서 찾을 수 있습니다.

---
#### **4.2.2.6 Unrecognized Header Options: RFC 791 Section 3.1**

라우터는 인식하지 못하는 IP 옵션을 무시해야 합니다. 이 요구 사항의 결과는 라우터가 옵션 목록 끝 옵션과 작업 없음 옵션을 구현해야 한다는 것입니다. 둘 다 명시적인 길이를 포함하지 않기 때문입니다.\(MUST, MUST\)

논의

- 향후 모든 IP 옵션에는 명시적인 길이가 포함됩니다.

---
#### **4.2.2.7 Fragmentation: RFC 791 Section 3.2**

\[INTERNET:1\]에 설명된 대로 조각화는 라우터에서 지원되어야 합니다.\(MUST\)

라우터가 IP 데이터그램을 조각화할 때 조각 수를 최소화해야 합니다. 라우터가 IP 데이터그램을 조각화할 때 조각을 순서대로 보내야 합니다. 다른 IP 조각보다 상당히 작은 하나의 IP 조각을 생성할 수 있는 조각화 방법으로 인해 첫 번째 IP 조각이 더 작아질 수 있습니다.\(SHOULD, SHOULD, MAY\)

논의

- 인터넷에서 일반적으로 사용되는 여러 조각화 기술이 있습니다. 하나는 IP 데이터그램을 IP 조각으로 분할하는 것입니다. 첫 번째 조각은 MTU 크기이고 다른 조각은 거의 동일한 크기로 MTU보다 작습니다. 그 이유는 두 가지입니다. 시퀀스의 첫 번째 IP 조각은 호스트 간 현재 경로의 유효 MTU가 되며, 다음 IP 조각의 크기는 IP 데이터그램의 추가 조각화를 최소화하도록 지정됩니다. 또 다른 기술은 \[INTERNET:1\]에 설명된 대로 IP 데이터그램을 MTU 크기의 IP 조각으로 분할하는 것입니다. 마지막 조각은 더 작은 조각입니다.

- TCP/IP의 일부 구현에서 사용되는 일반적인 트릭은 IP 데이터그램이 라우터를 통해 이동할 때 IP 데이터그램을 576바이트 이하의 IP 조각으로 조각화하는 것입니다. 이는 결과 IP 조각이 추가 조각화 없이 경로의 나머지 부분을 통과할 수 있도록 하기 위한 것입니다. 하지만 이렇게 하면 하나의 IP 데이터그램으로 재조립해야 할 IP 조각 수가 더 많아지기 때문에 대상 호스트에 더 많은 부하가 발생합니다. 또한 MTU가 한 번만 변경되고 576바이트보다 훨씬 크게 유지되는 네트워크에서는 효율적이지 않습니다. MTU가 2048인 IEEE 802.5 네트워크 또는 MTU가 1500인 이더넷 네트워크와 같은 LAN 네트워크를 예로 들 수 있습니다.

- 논의된 또 다른 조각화 기술은 IP 데이터그램을 다음 홉 네트워크의 MTU보다 작거나 같은 크기를 갖는 거의 동일한 크기의 IP 조각으로 분할하는 것이었습니다. 이는 경로 아래의 추가 조각화로 인해 발생하는 조각 수를 최소화하고 각 조각에 대해 동일한 지연을 보장하기 위한 것입니다.

- 라우터는 가능한 최소한의 IP 조각을 생성해야 합니다.\(SHOULD\)

느린 기계를 가지고 작업하면 우리는 다음과 같은 사실을 믿게 됩니다.

- 메시지를 조각화하는 데 필요한 작은 IP 조각을 먼저 보내는 것은 느린 인터페이스를 가진 호스트가 모든 조각을 수신할 가능성을 최대화합니다.

---
#### **4.2.2.8 Reassembly: RFC 791 Section 3.2**

\[INTRO:2\]의 해당 섹션에 지정된 대로 라우터는 자신에게 전달하는 데이터그램의 재조립을 지원해야 합니다.\(MUST\)

---
#### **4.2.2.9 Time to Live: RFC 791 Section 3.2**

라우터에서 시작되거나 수신된 패킷에 대한 TTL\(Time to Live\) 처리는 \[INTRO:2\]에 의해 관리됩니다. 이 섹션은 규정을 변경하지 않습니다. 그러나 \[INTRO:2\]의 IP 프로토콜 섹션의 나머지 부분이 다시 작성되었으므로 이 섹션도 마찬가지입니다.

특히 라우터는 패킷을 전달할 때를 제외하고는 패킷의 TTL을 확인해서는 안 됩니다.\(MUST NOT\)

라우터는 TTL\(Time-to-Live\) 값이 0인 데이터그램을 시작하거나 전달해서는 안 됩니다.\(MUST NOT\)

라우터는 TTL이 0 또는 1로 수신되었다는 이유만으로 데이터그램을 폐기해서는 안 됩니다. 그것이 라우터에 대한 것이고 그렇지 않으면 유효한 경우, 라우터는 그것을 수신하려고 시도해야 합니다.\(MUST NOT\)

라우터가 보낸 메시지에서 IP 계층은 전송 계층이 전송되는 모든 데이터그램의 TTL 필드를 설정할 수 있는 수단을 제공해야 합니다. 고정 TTL 값이 사용되는 경우 구성 가능해야 합니다. 이 숫자는 일반적인 인터넷 직경을 초과해야 하며, 현재 통념에 따르면 성장을 허용하려면 인터넷 직경의 두 배를 초과해야 합니다. 현재 제안된 값은 일반적으로 할당된 번호 RFC에 게시됩니다. TTL 필드에는 TCP 세그먼트의 수명을 제한하고\(RFC 793 \[TCP:1\], p. 28 참조\) 인터넷 라우팅 루프를 종료하는 두 가지 기능이 있습니다. TTL은 초 단위의 시간이지만, 각 라우터는 TTL 필드를 최소한 1만큼 줄여야 하므로 홉 수의 일부 속성도 가지고 있습니다.\(MUST, MUST, SHOULD\)

TTL 만료는 라우터에 의해 데이터그램이 삭제되도록 의도되었지만 대상 호스트에서는 삭제되지 않았습니다. 따라서 데이터그램을 전달하여 라우터 역할을 하는 호스트는 TTL에 대한 라우터의 규칙을 따라야 합니다.

상위 계층 프로토콜은 일부 인터넷 리소스에 대한 "범위 확장" 검색을 구현하기 위해 TTL을 설정하려고 할 수 있습니다. 이는 일부 진단 도구에서 사용되며, 예를 들어 IP 멀티캐스팅을 사용하여 특정 클래스의 "가장 가까운" 서버를 찾는 데 유용할 것으로 예상됩니다. 특정 전송 프로토콜은 최대 데이터그램 수명에 대한 자체 TTL 경계를 지정하려고 할 수도 있습니다.

고정된 기본값은 최소한 인터넷 "직경", 즉 가능한 가장 긴 경로에 비해 충분히 커야 합니다. 합리적인 가치는

지속적인 인터넷 성장을 허용하기 위해 직경이 약 두 배입니다. 이 글을 쓰는 시점에서 미국을 통과하는 메시지는 15\~20개의 라우터를 통과하는 경우가 많습니다. 이는 기본 TTL 값이 40을 초과한다고 주장하며 64가 일반적인 값입니다.

---
#### **4.2.2.10 Multi-subnet Broadcasts: RFC 922**

모든 서브넷 브로드캐스트\(\[INTERNET:3\]에서는 다중 서브넷 브로드캐스트라고 함\)는 더 이상 사용되지 않습니다. 섹션 \[5.3.5.3\]을 참조하십시오.

---
#### **4.2.2.11 Addressing: RFC 791 Section 3.2**

2.2.5.1에서 언급한 바와 같이, 이제 IP 주소에는 클래스 A부터 클래스 E까지 5가지 클래스가 있습니다. 클래스 D 주소는 IP 멀티캐스팅\[INTERNET:4\]에 사용되는 반면, 클래스 E 주소는 실험용으로 예약되어 있습니다. 클래스 A, B, C 주소 간의 구별은 더 이상 중요하지 않습니다. 해당 클래스에 대한 역사적 관심만 있는 일반화된 유니캐스트 네트워크 접두사로 사용됩니다.

IP 멀티캐스트 주소는 호스트 그룹을 나타내는 28비트 논리 주소이며 영구적이거나 일시적일 수 있습니다. 영구 멀티캐스트 주소는 Internet Assigned Number Authority \[INTRO:7\]에 의해 할당되는 반면 임시 주소는 임시 그룹에 동적으로 할당될 수 있습니다. 그룹 멤버십은 IGMP \[INTERNET:4\]를 사용하여 동적으로 결정됩니다.

이제 IP 주소에 대해 다음 표기법을 사용하여 범용 유니캐스트 IP 주소에 대한 중요한 특수 사례를 요약합니다.

```text
    { <Network-prefix>, <Host-number> }
```

모두 1비트를 포함하는 필드에 대한 표기법 -1과 모두 0비트를 포함하는 필드에 대한 표기법 0입니다.

```text
   (a) { 0, 0 }
```

- 이 네트워크의 이 호스트입니다. 라우터는 이 주소를 초기화 절차의 일부로 소스 주소로 사용할 수 있다는 점을 제외하고\(예: 라우터가 구성 정보를 로드하기 위해 BOOTP를 사용하는 경우\) 라우터에 의해 소스 주소로 사용되어서는 안 됩니다.\(MUST NOT\)

- 로컬 전달\(섹션 \[5.2.3\] 참조\)을 위해 수신되는 소스 주소가 {0,0}인 수신 데이터그램은 라우터가 관련 프로토콜을 구현하고 해당 프로토콜이 취해야 할 적절한 조치를 명확하게 정의하는 경우 수락되어야 합니다. 그렇지 않으면 라우터는 소스 주소가 {0, 0}인 로컬로 전달된 데이터그램을 자동으로 삭제해야 합니다.\(MUST, MUST\)

논의

- 일부 프로토콜은 소스 주소가 { 0, 0 }인 수신된 데이터그램에 응답하여 수행할 특정 작업을 정의합니다. 두 가지 예는 BOOTP 및 ICMP 마스크 요청입니다. 이러한 프로토콜의 올바른 작동은 소스 주소가 {0, 0}인 데이터그램을 수신하는 능력에 따라 달라지는 경우가 많습니다. 그러나 대부분의 프로토콜의 경우 소스 주소가 {0,0}인 데이터그램은 잘못 구성된 호스트나 라우터에 의해 생성되었을 수 있으므로 무시하는 것이 가장 좋습니다. 따라서 라우터가 {0, 0} 소스 주소를 가진 주어진 데이터그램을 처리하는 방법을 알고 있다면 라우터는 이를 수락해야 합니다. 그렇지 않으면 라우터는 이를 폐기해야 합니다.\(MUST, MUST\)

{0, 0 }의 비표준 사용에 대해서는 섹션 \[4.2.3.1\]을 참조하세요.

```text
   (b) { 0, <Host-number> }
```

- 이 네트워크에 지정된 호스트입니다. 라우터가 자신의 IP 주소를 학습하는 초기화 절차의 일부로 이를 소스 주소로 사용할 수 있다는 점을 제외하고는 라우터에 의해 전송되어서는 안 됩니다.\(MUST NOT\)

```text
   (c) { -1, -1 }
```

- 제한된 방송. 소스 주소로 사용하면 안 됩니다.\(MUST NOT\)

- 이 대상 주소를 가진 데이터그램은 연결된 물리적 네트워크의 모든 호스트와 라우터에서 수신되지만 해당 네트워크 외부로 전달되지는 않습니다.

```text
   (d) { <Network-prefix>, -1 }
```

- 직접 방송 - 지정된 네트워크 접두사로 전달되는 방송입니다. 소스 주소로 사용하면 안 됩니다. 라우터는 네트워크 지향 브로드캐스트 패킷을 생성할 수 있습니다. 라우터는 네트워크 지향 브로드캐스트 패킷을 수신해야 합니다. 그러나 라우터에는 이러한 패킷의 수신을 방지하는 구성 옵션이 있을 수 있습니다. 이러한 옵션은 기본적으로 수신 허용으로 설정되어야 합니다.\(MUST NOT, MAY, MUST, MUST\)

```text
    (e) { 127, <any> }
```

- 내부 호스트 루프백 주소. 이 형식의 주소는 호스트 외부에 표시되어서는 안 됩니다.\(MUST NOT\)

<Network-prefix\>는 해당 값이 장치가 연결된 라우팅 도메인에서 고유하도록 관리적으로 할당됩니다.

IP 주소는 위에 나열된 특별한 경우를 제외하고 <Host-number\> 또는 <Network-prefix\> 필드에 대해 0 또는 -1 값을 갖는 것이 허용되지 않습니다. 이는 각 필드의 길이가 최소 2비트임을 의미합니다.

논의

- 이 문서의 이전 버전에서는 서브넷 번호가 0이나 -1이 아니어야 하며 길이가 최소 2비트여야 한다고 명시했습니다. CIDR 세계에서 서브넷 번호는 분명히 네트워크 접두사의 확장이며 나머지 접두사 없이는 해석될 수 없습니다. 따라서 서브넷 번호에 대한 이러한 제한은 CIDR 관점에서 의미가 없으며 무시해도 됩니다.

브로드캐스트 주소에 대한 자세한 내용은 섹션 \[4.2.3.1\]을 참조하세요.

라우터가 데이터그램을 생성할 때 IP 소스 주소는 자신의 IP 주소 중 하나여야 합니다\(그러나 브로드캐스트 또는 멀티캐스트 주소는 아님\). 유일한 예외는 초기화 중입니다.\(MUST\)

대부분의 경우 브로드캐스트 또는 멀티캐스트 대상으로 주소가 지정된 데이터그램은 마치 라우터의 IP 주소 중 하나로 주소가 지정된 것처럼 처리됩니다. 즉 말하자면:

o 라우터는 브로드캐스트 대상 주소가 있는 모든 패킷을 정상적으로 수신하고 처리해야 합니다.\(MUST\)

o 라우터는 라우터가 수신을 요청한 멀티캐스트 대상 주소로 전송된 모든 패킷을 정상적으로 수신하고 처리해야 합니다.\(MUST\)

특정 대상 주소라는 용어는 호스트의 해당 로컬 IP 주소를 의미합니다. 특정 대상 주소는 헤더에 브로드캐스트 또는 멀티캐스트 주소가 포함되지 않는 한 IP 헤더의 대상 주소로 정의됩니다. 이 경우 특정 대상은 데이터그램이 도착한 물리적 인터페이스에 할당된 IP 주소입니다.

라우터는 이 섹션의 규칙에 따라 유효하지 않은 IP 소스 주소를 포함하는 수신된 데이터그램을 자동으로 폐기해야 합니다. 이 검증은 IP 계층 또는 \(해당되는 경우\) 전송 계층의 각 프로토콜에 의해 수행될 수 있습니다. 라우터가 폐기하는 모든 데이터그램과 마찬가지로 폐기된 데이터그램도 계산되어야 합니다.\(MUST, SHOULD\)

논의

- 잘못된 주소가 지정된 데이터그램은 유니캐스트 데이터그램의 링크 계층 브로드캐스트로 인해 발생하거나 혼동되거나 잘못 구성된 다른 라우터나 호스트로 인해 발생할 수 있습니다.

---
### **4.2.3 SPECIFIC ISSUES**
---
#### **4.2.3.1 IP Broadcast Addresses**

역사적인 이유로 IP 패킷이 IP 브로드캐스트임을 나타내는 데 사용되는 여러 IP 주소\(일부 표준 및 일부 아님\)가 있습니다. 라우터

\(1\) 255.255.255.255 또는 { <Network-prefix\>, -1 }로 주소가 지정된 IP 브로드캐스트 패킷으로 처리해야 합니다.\(MUST\)

\(2\) 0.0.0.0 또는 { <Network-prefix\>, 0 }으로 주소가 지정된 모든 패킷을 수신하면 자동으로 폐기해야 합니다\(즉, 라우터의 애플리케이션에 전달하지도 마세요\). 이러한 패킷이 자동으로 폐기되지 않으면 IP 브로드캐스트로 처리되어야 합니다\(섹션 \[5.3.5\] 참조\). 이러한 패킷 수신을 허용하는 구성 옵션이 있을 수 있습니다. 이 옵션은 기본적으로 해당 항목을 삭제해야 합니다.\(SHOULD, MUST, MAY, SHOULD\)

\(3\) \(기본적으로\) 제한된 브로드캐스트 주소를 사용해야 합니다.

- \(255.255.255.255\) 연결된 \(서브\)네트워크를 대상으로 하는 IP 브로드캐스트를 시작하는 경우\(섹션 \[4.3.3.9\]에 설명된 대로 ICMP 주소 마스크 응답을 보내는 경우는 제외\). 라우터는 제한된 브로드캐스트를 수신해야 합니다.\(SHOULD, MUST\)

\(4\) 0.0.0.0 또는 {로 주소가 지정된 데이터그램을 시작해서는 안 됩니다.

- <네트워크 접두사\>, 0 }. \(관련 1s 형식 브로드캐스트를 사용하는 대신\) 이러한 패킷의 생성을 허용하는 구성 옵션이 있을 수 있습니다. 이 옵션은 기본적으로 생성하지 않도록 설정해야 합니다.\(SHOULD NOT, MAY, SHOULD\)

논의

- 두 번째 글머리 기호에서 라우터에 해당 네트워크 접두사에 대한 인터페이스가 없는 경우 라우터는 분명히 { <Network-prefix\>, 0 } 형식의 주소를 인식할 수 없습니다. 이 경우 라우터의 관점에서 보면 해당 패킷은 IP 브로드캐스트 패킷이 아니기 때문에 두 번째 항목의 규칙이 적용되지 않습니다.

---
#### **4.2.3.2 IP Multicasting**

IP 라우터는 \[INTRO:2\]에 지정된 대로 IP 멀티캐스팅과 관련된 호스트 요구 사항을 충족해야 합니다. IP 라우터는 연결된 모든 네트워크에서 로컬 IP 멀티캐스팅을 지원해야 합니다. IP 멀티캐스트 주소에서 링크 계층 주소로의 매핑이 지정된 경우\(다양한 IP-over-xxx 사양 참조\) 해당 매핑을 사용해야 하며 대신 링크 계층 브로드캐스트를 사용하도록 구성할 수 있습니다. 지점 간 링크 및 기타 모든 인터페이스에서 멀티캐스트는 링크 계층 브로드캐스트로 캡슐화됩니다. 을지 지하다\(SHOULD, SHOULD, SHOULD\)

로컬 IP 멀티캐스팅에는 멀티캐스트 데이터그램 시작, 멀티캐스트 그룹 가입, 멀티캐스트 데이터그램 수신 및 멀티캐스트 그룹 탈퇴가 포함됩니다. 이는 IGMP를 포함한 모든 \[INTERNET:4\]에 대한 지원을 의미합니다\(섹션 \[4.4\] 참조\).

논의

- \[INTERNET:4\]에는 IP 멀티캐스팅을 위한 호스트 확장이 있지만 호스트와 라우터 모두 모든 IP 시스템에 적용됩니다. 특히, 라우터는 멀티캐스트 그룹에 가입할 수 있으므로 IGMP의 호스트 부분을 수행하여 연결된 네트워크에 있을 수 있는 모든 멀티캐스트 라우터\(그 자체가 멀티캐스트 라우터인지 여부에 관계없이\)에 그룹 멤버십을 보고하는 것이 옳습니다.

- 일부 라우터 프로토콜은 IP 멀티캐스팅\(예: OSPF \[ROUTE:1\]\)에 대한 지원을 특별히 요구하거나 이를 권장할 수 있습니다\(예: ICMP Router Discovery \[INTERNET:13\]\).

---
#### **4.2.3.3 Path MTU Discovery**

조각화를 제거하거나 최소화하려면 원본에서 대상까지의 경로를 따라 경로 MTU가 무엇인지 아는 것이 바람직합니다. 경로 MTU는 경로에 있는 각 홉의 최소 MTU입니다. \[INTERNET:14\]에서는 임의 인터넷 경로의 최대 전송 단위\(MTU\)를 동적으로 검색하는 기술을 설명합니다. \[INTERNET:14\]를 지원하지 않는 라우터를 통과하는 경로의 경우 이 기술은 올바른 경로 MTU를 검색하지 못할 수 있지만 항상 경로만큼 정확하고 많은 경우 더 정확한 경로 MTU를 선택합니다. 이전 기술이나 현재 관행에 의해 선택되는 MTU입니다.

라우터가 IP 데이터그램을 생성할 때, 데이터그램의 크기를 제한하기 위해 \[INTERNET:14\]에 설명된 방식을 사용해야 합니다. 데이터그램 목적지까지의 라우터 경로가 경로 MTU 정보를 제공하는 라우팅 프로토콜에서 학습된 경우 \[INTERNET:14\]에 설명된 방식이 계속 사용되지만 라우팅 프로토콜의 경로 MTU 정보는 다음과 같이 초기 추측으로 사용되어야 합니다. 경로 MTU 및 경로 MTU의 상한으로 사용됩니다.\(SHOULD, SHOULD\)

---
#### **4.2.3.4 Subnetting**

특정 상황에서는 서브넷 네트워크의 일부가 아닌 경로를 통해서만 상호 연결되는 특정 네트워크의 서브넷을 지원하는 것이 바람직할 수 있습니다. 이를 불연속 하위 네트워크 지원이라고 합니다.

```text
   Routers MUST support discontiguous subnetworks.
```

구현

- 기존 IP 네트워크에서는 이를 달성하기가 매우 어려웠습니다. CIDR 네트워크에서는 자연스러운 부산물입니다. 따라서 라우터는 서브넷 아키텍처에 대해 가정을 해서는 안 되며, 각 경로를 일반화된 네트워크 접두사로 처리해야 합니다.\(SHOULD NOT\)

토론 최근 인터넷은 엄청난 속도로 성장하고 있습니다. 이는 IP 주소 지정 기술에 심각한 부담을 주고 있습니다. 이 변형의 주요 요인은 엄격한 IP 주소 클래스 경계입니다. 이로 인해 네트워크 접두사의 크기를 효율적으로 조정하고 여러 네트워크 접두사를 단일 경로 알림으로 집계하기가 어렵습니다. IP 주소의 엄격한 클래스 경계를 ​​제거하고 각 경로를 일반화된 네트워크 접두사로 처리함으로써 이러한 부담을 크게 줄일 수 있습니다.

- 현재 이를 수행하기 위한 기술은 CIDR\(Classless Inter Domain Routing\) \[INTERNET:15\]입니다.

유사한 이유로, 주어진 네트워크 접두사와 연관된 주소 블록은 서로 다른 크기의 하위 블록으로 분할될 수 있으므로 하위 블록과 연관된 네트워크 접두사의 길이가 달라집니다. 예를 들어, 네트워크 접두어 길이가 8비트인 블록 내에서 한 하위 블록은 16비트 네트워크 접두어를 갖고, 다른 하위 블록은 18비트 네트워크 접두어를 가지며, 세 번째 하위 블록은 14비트 네트워크 접두어를 가질 수 있습니다.

라우터는 인터페이스 구성과 라우팅 데이터베이스 모두에서 가변 길이 네트워크 접두사를 지원해야 합니다.\(MUST\)

---
## **4.3 INTERNET CONTROL MESSAGE PROTOCOL - ICMP**
---
### **4.3.1 INTRODUCTION**

ICMP는 IP에 대한 라우팅, 진단 및 오류 기능을 제공하는 보조 프로토콜입니다. \[인터넷:8\]에 설명되어 있습니다. 라우터는 ICMP를 지원해야 합니다.\(MUST\)

ICMP 메시지는 다음 섹션에서 설명하는 두 가지 클래스로 그룹화됩니다.

```text
   ICMP error messages:

   Destination Unreachable     Section 4.3.3.1
   Redirect                    Section 4.3.3.2
   Source Quench               Section 4.3.3.3
   Time Exceeded               Section 4.3.3.4
   Parameter Problem           Section 4.3.3.5

   ICMP query messages:
   Echo                        Section 4.3.3.6
   Information                 Section 4.3.3.7
   Timestamp                   Section 4.3.3.8
   Address Mask                Section 4.3.3.9
   Router Discovery            Section 4.3.3.10
```

일반적인 ICMP 요구 사항 및 논의는 다음 섹션에 있습니다.

---
### **4.3.2 GENERAL ISSUES**
---
#### **4.3.2.1 Unknown Message Types**

알 수 없는 유형의 ICMP 메시지가 수신되면 ICMP 사용자 인터페이스로 전달되거나\(라우터에 있는 경우\) 자동으로 삭제되어야 합니다\(라우터에 없는 경우\).\(MUST\)

---
#### **4.3.2.2 ICMP Message TTL**

ICMP 메시지를 생성할 때 라우터는 TTL을 초기화해야 합니다. ICMP 응답의 TTL은 응답을 트리거한 패킷에서 가져오면 안 됩니다.\(MUST\)

---
#### **4.3.2.3 Original Message Header**

역사적으로 모든 ICMP 오류 메시지에는 인터넷 헤더와 오류를 발생시킨 데이터그램의 최소 처음 8개 데이터 바이트가 포함되어 있습니다. IP-in-IP 터널링 및 기타 기술의 사용으로 인해 이는 더 이상 적합하지 않습니다. 따라서 ICMP 데이터그램은 ICMP 데이터그램의 길이가 576바이트를 초과하지 않고 가능한 한 많은 원본 데이터그램을 포함해야 합니다. 반환된 IP 헤더\(및 사용자 데이터\)는 오류가 감지되기 ​​전에 수행된 전달에서 일반적으로 수행된 IP 헤더에 대한 수정 사항을 라우터가 취소할 필요가 없다는 점을 제외하고는 수신된 것과 동일해야 합니다\(예: TTL 감소 또는 옵션 업데이트\). 섹션 \[4.3.3.5\]의 요구 사항이 어떤 경우에는 이 요구 사항을 대체한다는 점에 유의하십시오\(즉, 매개 변수 문제 메시지의 경우 문제가 수정된 필드에 있는 경우 라우터는 수정을 취소해야 합니다\). 섹션 \[4.3.3.5\] 참조\).\(SHOULD, MUST\)

---
#### **4.3.2.4 ICMP Message Source Address**

이 문서에서 달리 지정하는 경우를 제외하고 라우터에서 생성된 ICMP 메시지의 IP 소스 주소는 ICMP 메시지가 전송되는 물리적 인터페이스와 연결된 IP 주소 중 하나여야 합니다. 인터페이스에 IP 주소가 없는 경우\(MUST\)

이와 연관되어 있으면 라우터의 router-id\(섹션 \[5.2.5\] 참조\)가 대신 사용됩니다.

---
#### **4.3.2.5 TOS and Precedence**

ICMP 오류 메시지는 TOS 비트를 ICMP 오류 메시지 전송을 유발한 패킷의 TOS 비트와 동일한 값으로 설정해야 합니다. 단, 해당 값으로 설정하면 ICMP 오류 메시지가 즉시 삭제될 수 없기 때문입니다. 목적지로 라우팅됩니다. 그렇지 않으면 ICMP 오류 메시지는 일반\(즉, 0\) TOS와 함께 전송되어야 합니다. ICMP 응답 메시지의 TOS 비트는 응답을 유발한 ICMP 요청의 TOS 비트와 동일한 값으로 설정되어야 합니다.\(SHOULD, MUST, SHOULD\)

ICMP Source Quench 오류 메시지가 전송되는 경우 IP Precedence 필드는 ICMP Source Quench 메시지 전송을 유발한 패킷의 IP Precedence 필드와 동일한 값으로 설정되어야 합니다. 기타 모든 ICMP 오류 메시지\(대상 도달 불가, 리디렉션, 시간 초과 및 매개변수 문제\)의 우선순위 값은 6\(인터넷 제어\) 또는 7\(네트워크 제어\)로 설정되어야 합니다. 이러한 오류 메시지에 대한 IP 우선순위 값은 설정 가능합니다.\(MUST, SHOULD, MAY\)

ICMP 응답 메시지에는 응답을 유발한 ICMP 요청의 IP 우선 순위 필드와 동일한 값으로 설정된 IP 우선 순위 필드가 있어야 합니다.\(MUST\)

---
#### **4.3.2.6 Source Route**

ICMP 오류 메시지 전송을 유발하는 패킷에 원본 경로 옵션이 포함되어 있는 경우 ICMP 오류 메시지에는 경로 포인터 앞 부분을 반전하여 생성된 동일한 유형\(엄격 또는 느슨함\)의 원본 경로 옵션도 포함되어야 합니다. ICMP 오류 메시지가 원래 패킷의 소스 경로 옵션에 대해 불평하는 ICMP 매개변수 문제이거나 라우터가 ICMP 오류 메시지 전달을 방지하는 정책을 인식하지 않는 한 원래 패킷의 소스 경로 옵션에 기록됩니다.\(SHOULD\)

논의

- 미국 국방부 보안 옵션\(\[INTERNET:5\]에 정의됨\)을 사용하는 환경에서는 ICMP 메시지에 보안 옵션이 포함되어야 할 수도 있습니다. 이 주제에 대한 자세한 정보는 국방통신국에서 얻을 수 있습니다.

---
#### **4.3.2.7 When Not to Send ICMP Errors**

ICMP 오류 메시지는 다음 수신의 결과로 전송되어서는 안 됩니다.\(MUST NOT\)

o ICMP 오류 메시지, 또는

o 섹션 \[5.2.2\]에 설명된 IP 헤더 검증 테스트에 실패한 패킷\(해당 섹션에서 ICMP 오류 메시지 전송을 특별히 허용하는 경우는 제외\), 또는

o IP 브로드캐스트 또는 IP 멀티캐스트 주소로 향하는 패킷, 또는

o 링크 계층 브로드캐스트 또는 멀티캐스트로 전송된 패킷, 또는

o 소스 주소의 네트워크 접두사가 0이거나 유효하지 않은 소스 주소\(섹션 \[5.3.7\]에 정의됨\)인 패킷, 또는

o 첫 번째 조각 이외의 데이터그램 조각\(즉, IP 헤더의 조각 오프셋이 0이 아닌 패킷\).

또한 이 메모에 패킷이 자동으로 폐기되어야 한다고 명시되어 있는 경우에는 ICMP 오류 메시지를 전송해서는 안 됩니다.\(MUST NOT\)

참고: 이러한 제한 사항은 ICMP 오류 메시지 전송에 대한 이 문서의 다른 요구 사항보다 우선합니다.

논의

- 이 규칙은 브로드캐스트 패킷에 대한 응답으로 ICMP 오류 메시지를 반환하는 라우터나 호스트로 인해 발생하는 브로드캐스트 폭풍을 방지하는 것을 목표로 합니다. 예를 들어, 존재하지 않는 포트에 대한 브로드캐스트 UDP 패킷은 해당 대상 포트에 대한 클라이언트가 없는 모든 장치에서 ICMP 대상 연결할 수 없는 데이터그램의 홍수를 유발할 수 있습니다. 대규모 이더넷에서는 충돌로 인해 네트워크가 1초 이상 쓸모 없게 될 수 있습니다.

- 연결된 네트워크에서 브로드캐스트되는 모든 패킷은 IP 대상으로 유효한 IP 브로드캐스트 주소를 가져야 합니다\(섹션 \[5.3.4\] 및 \[소개:2\] 참조\). 그러나 일부 장치는 이 규칙을 위반합니다. 따라서 브로드캐스트 패킷을 확실히 탐지하려면 라우터는 IP 계층 주소뿐만 아니라 링크 계층 브로드캐스트도 확인해야 합니다.

구현+ 이를 위해서는 링크 계층 브로드캐스트 패킷이 수신되었을 때 링크 계층이 IP 계층에 알려야 합니다. 섹션 \[3.1\]을 참조하세요.

---
#### **4.3.2.8 Rate Limiting**

ICMP Source Quench 메시지를 보내는 라우터는 메시지가 생성될 수 있는 속도를 제한할 수 있어야 합니다. 라우터는 또한 다른 종류의 ICMP 오류 메시지\(대상 도달 불가, 리디렉션, 시간 초과, 매개변수 문제\)를 보내는 속도를 제한할 수 있어야 합니다. 속도 제한 매개변수는 라우터 구성의 일부로 설정 가능해야 합니다\(SHOULD\). 제한이 적용되는 방식\(예: 라우터별 또는 인터페이스별\)은 구현자의 재량에 달려 있습니다.\(MUST, SHOULD, SHOULD\)

```text
   DISCUSSION
      Two problems for a router sending ICMP error message are:
      (1) The consumption of bandwidth on the reverse path, and
      (2) The use of router resources (e.g., memory, CPU time)
```

- 이러한 문제를 해결하기 위해 라우터는 ICMP 오류 메시지를 생성하는 빈도를 제한할 수 있습니다. 비슷한 이유로 라우터는 ICMP 에코 응답과 같은 다른 종류의 메시지가 생성되는 빈도를 제한할 수 있습니다.

구현

- ICMP 메시지 전송 속도를 제한하기 위해 다양한 메커니즘이 사용되거나 제안되었습니다.

- \(1\) 개수 기반 - 예를 들어 전체 N개의 삭제된 패킷마다 또는 지정된 소스 호스트별로 ICMP 오류 메시지를 보냅니다. 이 메커니즘은 ICMP Source Quench에 적합할 수 있지만 다른 유형의 ICMP 메시지에는 적합하지 않을 수 있습니다.

- \(2\) 타이머 기반 - 예를 들어 ICMP 오류 메시지를 지정된 소스 호스트 또는 전체에 T 밀리초당 최대 한 번 보냅니다.

- \(3\) 대역폭 기반 - 예를 들어 ICMP 메시지가 특정 인터페이스를 통해 전송되는 속도를 연결된 네트워크 대역폭의 일부로 제한합니다.

---
### **4.3.3 SPECIFIC ISSUES**
---
#### **4.3.3.1 Destination Unreachable**

라우터가 패킷에 지정된 대상에 대한 경로가 전혀 없기 때문에\(기본 경로 없음 포함\) 패킷을 전달할 수 없는 경우 라우터는 대상 도달 불가능, 코드 0\(네트워크 도달 불가능\) ICMP 메시지를 생성해야 합니다. 라우터에 패킷에 지정된 대상 네트워크에 대한 경로가 있지만 경로에 지정된 TOS가 기본 TOS\(0000\)도 아니고 라우터가 라우팅하려고 시도하는 패킷의 TOS도 아닌 경우\(MUST\)

라우터는 목적지 도달 불가능, 코드 11\(TOS에 대한 네트워크 도달 불가능\) ICMP 메시지를 생성해야 합니다.\(MUST\)

패킷이 라우터에 직접 연결된 네트워크의 호스트로 전달되고\(즉, 라우터가 마지막 홉 라우터임\) 라우터가 대상 호스트에 대한 경로가 없다고 확인한 경우 라우터는 다음을 수행해야 합니다. 목적지 도달 불가능, 코드 1\(호스트 도달 불가능\) ICMP 메시지를 생성합니다. 라우터에 직접 연결된 네트워크에 있는 호스트로 패킷을 전달해야 하는데 대상으로 가는 경로에 패킷에서 요청한 TOS와 동일한 TOS가 없거나 라우터가 패킷을 전달할 수 없는 경우 기본 TOS\(0000\)인 경우 라우터는 목적지 도달 불가능, 코드 12\(TOS에 대한 호스트 도달 불가능\) ICMP 메시지를 생성해야 합니다.\(MUST, MUST\)

논의

- 라우터가 대상에 대한 경로\(기본 경로 포함\)가 전혀 없는 경우 연결할 수 없는 "일반" 호스트/네트워크를 생성하려는 의도입니다. 라우터에 대상까지의 경로가 하나 이상 있지만 해당 경로 중 어느 것도 허용 가능한 TOS가 없으면 라우터는 "TOS에 연결할 수 없음" 메시지를 생성합니다.

---
#### **4.3.3.2 Redirect**

ICMP 리디렉션 메시지는 특정 트래픽에 대해 다른 다음 홉 라우터를 사용해야 함을 로컬 호스트에 알리기 위해 생성됩니다.

\[INTRO:2\]와는 반대로, 라우터가 라우팅 프로토콜을 실행 중이거나 라우터 및 패킷이 전달되는 인터페이스에서 전달이 활성화된 경우 라우터는 라우터에서 시작된 패킷의 경로를 선택할 때 ICMP 리디렉션을 무시할 수 있습니다. 전송 중입니다.\(MAY\)

---
#### **4.3.3.3 Source Quench**

라우터는 ICMP Source Quench 메시지를 생성해서는 안 됩니다. 섹션 \[4.3.2\]에 명시된 대로 Source Quench 메시지를 생성하는 라우터는 메시지가 생성되는 속도를 제한할 수 있어야 합니다.\(SHOULD NOT, MUST\)

논의

- 연구에 따르면 Source Quench는 네트워크 대역폭을 소비하지만 혼잡에 대한 효과가 없고 불공평한 해결책이라고 합니다. 예를 들어 \[인터넷:9\] 및 \[인터넷:10\]을 참조하세요. 섹션 \[5.3.6\]에서는 라우터가 과부하 및 네트워크 혼잡을 처리하는 방법에 대한 현재 생각을 논의합니다.

라우터는 수신하는 모든 ICMP Source Quench 메시지를 무시할 수 있습니다.\(MAY\)

논의

- 라우터 자체는 다른 라우터나 호스트로 전송된 패킷의 결과로 Source Quench를 수신할 수 있습니다. 이러한 데이터그램은 예를 들어 다른 라우터로 전송된 EGP 업데이트이거나 호스트로 전송된 텔넷 스트림일 수 있습니다. 패킷이 전송되는 속도를 제어하여 IP 계층이 Source Quench에 직접 응답하도록 하는 메커니즘이 제안되었습니다\(\[INTERNET:11\], \[INTERNET:12\]\). 그러나 이 제안은 현재 실험적이며 권장되지 않습니다.

---
#### **4.3.3.4 Time Exceeded**

라우터가 패킷을 전달하고 패킷의 TTL 필드가 0으로 감소되면 섹션 \[5.2.3.8\]의 요구 사항이 적용됩니다.

라우터가 라우터로 향하는 패킷을 재조립할 때 인터넷 호스트 역할을 합니다. 따라서 \[소개:2\]의 재조립 요구 사항이 적용됩니다.

라우터가 Time Exceeded 메시지를 수신하면\(즉, 라우터로 향하는 경우\) \[INTRO:2\]를 준수해야 합니다.\(MUST\)

---
#### **4.3.3.5 Parameter Problem**

라우터는 다른 ICMP 메시지에서 구체적으로 다루지 않는 오류에 대해 매개변수 문제 메시지를 생성해야 합니다. 포인터 필드에 표시된 바이트를 포함하는 IP 헤더 필드 또는 IP 옵션은 이 ICMP 메시지와 함께 반환된 IP 헤더에 변경되지 않은 상태로 포함되어야 합니다. 섹션 \[4.3.2\]에서는 이 요구 사항에 대한 예외를 정의합니다.\(MUST, MUST\)

매개변수 문제 메시지의 새로운 변형이 \[INTRO:2\]에 정의되었습니다. 코드 1 = 필수 옵션이 누락되었습니다.

논의

- 이 변종은 현재 군사 커뮤니티에서 보안 옵션 누락을 위해 사용되고 있습니다.

---
#### **4.3.3.6 Echo Request/Reply**

라우터는 라우터로 전송된 에코 요청을 수신하고 해당 에코 응답을 보내는 ICMP 에코 서버 기능을 구현해야 합니다. 라우터는 적어도 최대 576개의 ICMP 에코 요청 데이터그램과 연결된 모든 네트워크의 MTU를 수신, 재조립 및 에코하도록 준비해야 합니다.\(MUST, MUST\)

에코 서버 기능은 IP 브로드캐스트 또는 IP 멀티캐스트 주소로 지정된 ICMP 에코 요청에 응답하지 않도록 선택할 수 있습니다.\(MAY\)

라우터에는 활성화된 경우 라우터가 모든 ICMP 에코 요청을 자동으로 무시하도록 하는 구성 옵션이 있어야 합니다. 제공되는 경우 이 옵션은 기본적으로 응답 허용으로 설정되어야 합니다.\(MUST\)

논의

- 브로드캐스트 및 멀티캐스트 에코 요청에 대한 응답에 대한 중립 조항은 \[INTRO:2\]의 "에코 요청/응답" 섹션에서 파생됩니다.

섹션 \[10.3.3\]에 설명된 대로 라우터는 진단 목적으로 에코 요청을 보내고 에코 응답을 수신하기 위한 사용자/애플리케이션 계층 인터페이스도 구현해야 합니다. 모든 ICMP 에코 응답 메시지는 이 인터페이스로 전달되어야 합니다.\(MUST, MUST\)

ICMP 에코 응답의 IP 소스 주소는 해당 ICMP 에코 요청 메시지의 특정 대상 주소와 동일해야 합니다.\(MUST\)

ICMP 에코 요청으로 수신된 데이터는 결과 에코 응답에 완전히 포함되어야 합니다.\(MUST\)

ICMP 에코 요청에서 레코드 경로 및/또는 타임스탬프 옵션이 수신된 경우 이 옵션\(이러한 옵션\)은 현재 라우터를 포함하고 에코 응답 메시지의 IP 헤더에 잘림 없이 포함되도록 업데이트되어야 합니다. 따라서 기록된 경로는 전체 왕복 여행에 대한 것입니다.\(SHOULD\)

ICMP 에코 요청에서 소스 경로 옵션이 수신된 경우 라우터가 메시지 전달을 방지하는 정책을 인식하지 않는 한 반환 경로를 반전하고 에코 응답 메시지에 대한 소스 경로 옵션으로 사용해야 합니다.\(MUST\)

---
#### **4.3.3.7 Information Request/Reply**

라우터는 이러한 메시지를 생성하거나 이에 응답해서는 안 됩니다.\(SHOULD NOT\)

논의

- 정보 요청/응답 쌍은 디스크가 없는 워크스테이션과 같은 자체 구성 시스템을 지원하여 부팅 시 IP 네트워크 접두어를 검색할 수 있도록 하기 위한 것입니다. 그러나 이러한 메시지는 이제 더 이상 사용되지 않습니다. RARP 및 BOOTP 프로토콜은 호스트가 자신의 IP 주소를 검색할 수 있는 더 나은 메커니즘을 제공합니다.

---
#### **4.3.3.8 Timestamp and Timestamp Reply**

라우터는 타임스탬프와 타임스탬프 응답을 구현할 수 있습니다. 구현된 경우:\(MAY\)

o ICMP 타임스탬프 서버 기능은 수신된 모든 타임스탬프 메시지에 대해 타임스탬프 응답을 반환해야 합니다. 지연의 변동성을 최소화하도록 설계해야 합니다\(SHOULD\).\(MUST, SHOULD\)

o IP 브로드캐스트 또는 IP에 대한 ICMP 타임스탬프 요청 메시지

- 멀티캐스트 주소는 자동으로 폐기될 수 있습니다.\(MAY\)

o ICMP 타임스탬프 응답의 IP 소스 주소는 해당 타임스탬프 요청 메시지의 특정 대상 주소와 동일해야 합니다.\(MUST\)

o ICMP 타임스탬프 요청에서 소스 경로 옵션이 수신된 경우 라우터가 메시지 전달을 방지하는 정책을 인식하지 않는 한 반환 경로는 반드시 반전되어 타임스탬프 응답 메시지에 대한 소스 경로 옵션으로 사용해야 합니다.\(MUST\)

o 레코드 경로 및/또는 타임스탬프 옵션이

- 타임스탬프 요청, 이 옵션은 현재 라우터를 포함하고 타임스탬프 응답 메시지의 IP 헤더에 포함되도록 업데이트되어야 합니다.\(SHOULD\)

o 라우터가 타임스탬프 요청 메시지를 보내기 위한 애플리케이션 계층 인터페이스를 제공하는 경우 들어오는 타임스탬프 응답 메시지는 ICMP 사용자 인터페이스까지 전달되어야 합니다.\(MUST\)

타임스탬프 값\(표준 값\)의 기본 형식은 세계 표준시\(Universal Time\) 자정 이후의 밀리초입니다. 그러나 이 값을 밀리초 분해능으로 제공하는 것은 어려울 수 있습니다. 예를 들어, 많은 시스템은 회선 주파수\(초당 50\~60회\)에서만 업데이트되는 클럭을 사용합니다. 따라서 표준 값에는 일부 위도가 허용됩니다.

\(a\) 표준 값은 초당 최소 16회 업데이트되어야 합니다\(즉, 값의 최대 6개 하위 비트가 정의되지 않을 수 있음\).\(MUST\)

\(b\) 표준 값의 정확도는 운영자가 설정한 CPU 시계의 정확도와 유사해야 합니다. 즉, 몇 분 내에 정확해야 합니다.\(MUST\)

구현

- 두 번째 조건을 충족하려면 라우터가 부팅되거나 다시 시작될 때 라우터가 일부 시간 서버를 쿼리해야 할 수 있습니다. 이 목적으로 UDP 시간 서버 프로토콜을 사용하는 것이 좋습니다. 보다 발전된 구현에서는 NTP\(Network Time Protocol\)를 사용하여 거의 밀리초에 가까운 시계 동기화를 달성합니다. 그러나 이는 필수 사항이 아닙니다.

---
#### **4.3.3.9 Address Mask Request/Reply**

라우터는 ICMP 주소 마스크 요청 메시지 수신 및 ICMP 주소 마스크 응답 메시지 응답에 대한 지원을 구현해야 합니다. 이러한 메시지는 \[INTERNET:2\]에 정의되어 있습니다.\(MUST\)

라우터는 라우터가 해당 인터페이스에 대한 주소 마스크 요청에 응답할 수 있는지 여부를 지정하는 각 논리적 인터페이스에 대한 구성 옵션을 가져야 합니다. 이 옵션은 기본적으로 응답 허용으로 설정되어야 합니다. 라우터는 올바른 주소 마스크를 알기 전에 주소 마스크 요청에 응답해서는 안 됩니다.\(MUST, MUST NOT\)

라우터는 소스 주소가 0.0.0.0이고 여러 논리적 인터페이스와 연결된 물리적 인터페이스에 도착하는 주소 마스크 요청에 응답해서는 안 되며 해당 인터페이스의 주소 마스크는 모두 동일하지 않습니다.\(MUST NOT\)

라우터는 포함된 정보가 라우터의 주소 마스크 지식과 일치하는지 여부를 결정하기 위해 수신한 모든 ICMP 주소 마스크 응답을 검사해야 합니다. ICMP 주소 마스크 응답에 오류가 있는 것으로 나타나면 라우터는 주소 마스크와 보낸 사람의 IP 주소를 기록해야 합니다. 라우터는 올바른 주소 마스크를 결정하기 위해 ICMP 주소 마스크 응답의 내용을 사용해서는 안 됩니다.\(SHOULD, SHOULD, MUST NOT\)

호스트가 부팅될 때 라우터가 다운되면 호스트는 주소 마스크를 학습할 수 없기 때문에 라우터는 자체 주소 마스크를 구성한 후 각 논리 인터페이스에서 불필요한 ICMP 주소 마스크 응답을 브로드캐스트할 수 있습니다. 그러나 이 기능은 가변 길이 주소 마스크를 사용하는 환경에서는 위험할 수 있습니다. 따라서 이 기능이 구현되면 다음 중 하나에 해당하는 논리적 인터페이스를 통해 불필요한 주소 마스크 응답을 브로드캐스트해서는 안 됩니다.\(MAY, MUST NOT\)

o 무료 주소 마스크 응답을 보내도록 구성되지 않았습니다. 각 논리적 인터페이스에는 이를 제어하는 ​​구성 매개변수가 있어야 하며, 해당 매개변수는 기본적으로 불필요한 주소 마스크 응답을 보내지 않도록 설정해야 합니다.\(MUST\)

o 포함된\(동일하지는 않은\) 네트워크 접두사 및 물리적 인터페이스를 공유합니다.

IP 브로드캐스트 주소의 { <Network-prefix\>, -1 } 형식은 브로드캐스트 주소 마스크 응답에 사용해야 합니다.\(MUST\)

논의

- 주소 마스크에 대해 의도적으로 호스트에 거짓말을 하는 일부 사이트에서는 라우터를 통한 주소 마스크 응답 전송을 비활성화하는 기능이 필요합니다. 이에 대한 필요성은 사라질 것으로 예상됩니다.

- 점점 더 많은 호스트가 호스트 요구 사항 표준을 준수하게 됩니다.

- 위의 두 번째 항목과 사용할 IP 브로드캐스트 주소에 대한 요구 사항은 모두 동일한 물리적 네트워크에서 여러 IP 네트워크 접두사가 사용 중일 때 문제를 방지하기 위한 것입니다.

---
#### **4.3.3.10 Router Advertisement and Solicitations**

IP 라우터는 라우터가 IP 멀티캐스트 또는 IP 브로드캐스트 주소 지정을 지원하는 모든 연결된 네트워크에서 ICMP 라우터 검색 프로토콜\[INTERNET:13\]의 라우터 부분을 지원해야 합니다. 구현에는 지정된 기본값과 함께 라우터에 대해 지정된 모든 구성 변수가 포함되어야 합니다.\(MUST, MUST\)

논의

- 라우터는 ICMP 라우터 검색 프로토콜의 호스트 부분을 구현하는 데 필요하지 않지만 IP 전달이 비활성화된 동안\(즉, 호스트로 작동하는 경우\) 작업에 유용할 수 있습니다.

토론 호스트가 RIP 버전 1을 라우터 검색 프로토콜로 사용하는 것이 매우 일반적입니다. 이러한 호스트는 RIP 트래픽을 수신하고 해당 트래픽에서 추출된 정보를 사용하여 라우터를 검색하고 지정된 대상에 대한 첫 번째 홉 라우터로 사용할 라우터를 결정합니다. 이 동작은 권장되지 않지만 여전히 일반적이므로 구현자는 이에 대해 알고 있어야 합니다.

---
## **4.4 INTERNET GROUP MANAGEMENT PROTOCOL - IGMP**

IGMP \[INTERNET:4\]는 특정 멀티캐스트 그룹에서 호스트의 멤버십을 설정하기 위해 단일 물리적 네트워크의 호스트와 멀티캐스트 라우터 간에 사용되는 프로토콜입니다. 멀티캐스트 라우터는 멀티캐스트 라우팅 프로토콜과 함께 이 정보를 사용하여 인터넷을 통한 IP 멀티캐스트 전달을 지원합니다.

라우터는 IGMP의 호스트 부분을 구현해야 합니다.\(SHOULD\)

---
## **5. INTERNET LAYER - FORWARDING**
---
## **5.1 INTRODUCTION**

이 섹션에서는 패킷 전달 프로세스에 대해 설명합니다.

---
## **5.2 FORWARDING WALK-THROUGH**

IP에는 포워딩 기능에 대한 별도의 규격이 없습니다. 대신 인터넷 계층 프로토콜\(\[INTERNET:1\], \[INTERNET:2\], \[INTERNET:3\], \[INTERNET:8\] 및 \[ROUTE:11\]\)에 대한 프로토콜 사양이 전달에 적용됩니다.

---
### **5.2.1 Forwarding Algorithm**

기본 프로토콜 문서 중 전달 알고리즘을 자세히 설명하는 문서가 없으므로 여기에 제시합니다. 이것은 단지 일반적인 개요일 뿐이며 혼잡 처리와 같은 이후 섹션에서 다루는 중요한 세부 사항을 생략합니다.

구현이 섹션 \[5.2.1.1\], \[5.2.1.2\] 및 \[5.2.1.3\]에 제공된 알고리즘을 정확하게 따를 필요는 없습니다. 라우터 소프트웨어 작성 시 가장 어려운 점은 라우터가 패킷을 전달할 수 있는 속도를 최대화하는 동시에 알고리즘과 동일한 효과를 달성하는 것입니다. 이를 수행하는 방법에 대한 자세한 내용은 라우터 아키텍처에 크게 의존하기 때문에 이 문서의 범위를 벗어납니다. 대신에 우리는 단지 단계들 사이의 순서 의존성을 지적할 뿐입니다:

\(1\) 라우터는 헤더의 내용을 기반으로 모든 작업을 수행하기 전에 섹션 \[5.2.2\]에 설명된 대로 IP 헤더를 확인해야 합니다. 이를 통해 라우터는 다른 리소스를 소비하기 전에 잘못된 패킷을 감지하고 삭제할 수 있습니다.\(MUST\)

\(2\) 특정 IP 옵션을 처리하려면 라우터가 해당 IP 주소를 옵션에 삽입해야 합니다. 섹션 \[5.2.4\]에서 설명한 대로 삽입된 주소는 패킷이 전송되는 논리적 인터페이스의 주소이거나 패킷이 번호가 지정되지 않은 인터페이스를 통해 전송되는 경우 라우터의 라우터 ID여야 합니다. 따라서 이러한 옵션 처리는 출력 인터페이스가 선택될 때까지 완료될 수 없습니다.\(MUST\)

\(3\) 라우터는 \[4.2.2.9\]절에서 언급한 이유로 인해 패킷이 라우터 자체로 전달되어야 하는지 여부를 확인하기 전에 TTL을 확인하고 감소시킬 수 없습니다.

\(4\) 보다 일반적으로, 패킷이 라우터에 로컬로 전달될 때 IP 헤더는 어떤 방식으로든 수정되어서는 안 됩니다\(단,\(MUST NOT\)

- 라우터는 IP 헤더의 타임스탬프 옵션에 타임스탬프를 삽입해야 할 수도 있습니다. 따라서 라우터는 패킷이 로컬로 라우터에 전달될지 여부를 결정하기 전에 실행 취소할 준비가 되어 있지 않은 방식으로 IP 헤더를 업데이트할 수 없습니다.

---
#### **5.2.1.1 General**

이 섹션에서는 일반적인 전달 알고리즘을 다룹니다. 이 알고리즘은 유니캐스트, 멀티캐스트, 브로드캐스트 등 전달되는 모든 형태의 패킷에 적용됩니다.

\(1\) 라우터는 링크 계층으로부터 IP 패킷\(섹션 \[3.1\]에 설명된 추가 정보 포함\)을 수신합니다.

\(2\) 라우터는 \[5.2.2\]절에 설명된 대로 IP 헤더를 검증합니다. 단계 \(4\)에서 로컬 전달을 위해 대기열에 들어갈 IP 조각을 제외하고는 IP 리어셈블리가 수행되지 않습니다.

\(3\) 라우터는 모든 IP 옵션 처리의 대부분을 수행합니다. 섹션 \[5.2.4\]에 설명된 대로 일부 IP 옵션은 라우팅 결정이 이루어진 후 추가 처리가 필요합니다.

\(4\) 라우터는 IP의 대상 IP 주소를 검사합니다.

- 섹션 \[5.2.3\]에 설명된 대로 IP 데이터그램을 계속 처리하는 방법을 결정하는 데이터그램. 세 가지 가능성이 있습니다:

- o IP 데이터그램은 라우터로 향하고 로컬 전달을 위해 대기열에 있어야 하며 필요한 경우 리어셈블리를 수행해야 합니다.

- o IP 데이터그램은 라우터로 향하지 않으며 전달을 위해 대기열에 있어야 합니다.

- o IP 데이터그램은 전달을 위해 대기열에 있어야 하지만 \(사본\)도 로컬 전달을 위해 대기열에 있어야 합니다.

---
#### **5.2.1.2 Unicast**

로컬 전달 사례는 \[INTRO:2\]에서 잘 다루어지기 때문에 다음에서는 IP 데이터그램이 전달을 위해 대기열에 있다고 가정합니다. 대상이 IP 유니캐스트 주소인 경우:

\(5\) 전달자는 일반적으로 라우터의 라우팅 테이블에서 패킷의 대상을 조회하여 패킷의 다음 홉 IP 주소를 결정합니다. 이 절차는 섹션 \[5.2.4\]에 자세히 설명되어 있습니다. 이 절차는 또한 어떤 네트워크를 결정합니다.

- 패킷을 전송하려면 인터페이스를 사용해야 합니다.

\(6\) 포워더는 패킷 전달이 허용되는지 확인합니다. 섹션 \[5.3.7\] 및 섹션 \[5.3.4\]에 설명된 대로 소스 및 대상 주소는 유효해야 합니다. 라우터가 섹션 \[5.3.9\]에 설명된 것과 같은 전달에 대한 관리 제약을 지원하는 경우 해당 제약은 다음과 같아야 합니다. 만족하는.

\(7\) 포워더는 섹션 \[5.3.1\]에 설명된 대로 패킷의 TTL을 \(최소 1만큼\) 감소시키고 확인합니다.

\(8\) 포워더는 3단계에서 완료할 수 없는 IP 옵션 처리를 수행합니다.

\(9\) 포워더는 섹션 \[4.2.2.7\]에 설명된 대로 필요한 IP 조각화를 수행합니다. 이 단계는 아웃바운드 인터페이스 선택\(5단계\) 후에 발생하므로 동일한 데이터그램의 모든 조각이 동일한 인터페이스 밖으로 전송됩니다.

\(10\) 전달자는 패킷의 다음 홉에 대한 링크 계층 주소를 결정합니다. 이를 수행하는 메커니즘은 링크 계층에 따라 다릅니다\(3장 참조\).

\(11\) 포워더는 적절한 링크 계층 프레임에 IP 데이터그램\(또는 그 조각 각각\)을 캡슐화하고 이를 5단계에서 선택한 인터페이스의 출력을 위해 대기열에 넣습니다.

\(12\) 포워더는 섹션 \[4.3.3.2\]에 설명된 대로 필요한 경우 ICMP 리디렉션을 보냅니다.

---
#### **5.2.1.3 Multicast**

대상이 IP 멀티캐스트인 경우 다음 단계가 수행됩니다.

IP 유니캐스트 전달과 IP 멀티캐스트 전달 간의 주요 차이점은 다음과 같습니다.

o IP 멀티캐스트는 일반적으로 데이터그램의 소스 및 대상 IP 주소를 기반으로 전달됩니다.

o IP 멀티캐스트는 확장 링 검색을 사용합니다.

o IP 멀티캐스트는 링크 수준 멀티캐스트로 전달됩니다.

o IP 멀티캐스트 데이터그램에 대한 응답으로 ICMP 오류가 전송되지 않습니다.

IP 멀티캐스트 전달은 아직 다소 실험적입니다. 따라서 아래 제시된 알고리즘은 필수 사항은 아니며 예시로만 제공됩니다.

\(5a\) 데이터그램 헤더에 있는 IP 소스 및 대상 주소를 기반으로 라우터는 데이터그램이 전달을 위한 적절한 인터페이스에서 수신되었는지 여부를 결정합니다. 그렇지 않은 경우 데이터그램은 자동으로 삭제됩니다. 적절한 수신 인터페이스를 결정하는 방법은 사용 중인 멀티캐스트 라우팅 알고리즘에 따라 다릅니다. 가장 간단한 알고리즘 중 하나인 역방향 경로 전달\(RPF\)에서 적절한 인터페이스는 유니캐스트를 데이터그램 소스로 다시 전달하는 데 사용되는 인터페이스입니다.

\(6a\) 데이터그램 헤더에 있는 IP 소스 및 대상 주소를 기반으로 라우터는 데이터그램의 나가는 인터페이스를 결정합니다. IP 멀티캐스트의 확장 링 검색\(\[INTERNET:4\] 참조\)을 구현하려면 각 발신 인터페이스에 대해 최소 TTL 값이 지정됩니다. 멀티캐스트 데이터그램의 복사본은 각 인터페이스에 나머지 단계를 개별적으로 적용하여 최소 TTL 값이 데이터그램 헤더의 TTL 값보다 작거나 같은 각 나가는 인터페이스로 전달됩니다.

\(7a\) 라우터는 패킷의 TTL을 1씩 감소시킵니다.

\(8a\) 포워더는 \(3\) 단계에서 완료할 수 없는 IP 옵션 처리를 수행합니다.

\(9a\) 포워더는 섹션 \[4.2.2.7\]에 설명된 대로 필요한 IP 조각화를 수행합니다.

\(10a\) 전달자는 링크 수준 캡슐화에 사용할 링크 계층 주소를 결정합니다. 이를 수행하는 메커니즘은 링크 계층에 따라 다릅니다. LAN에서는 데이터그램의 IP 멀티캐스트 주소에 대한 알고리즘 변환으로 링크 수준 멀티캐스트 또는 브로드캐스트가 선택됩니다. 자세한 내용은 다양한 IP-over-xxx 사양을 참조하세요.

\(11a\) 포워더는 적절한 링크 계층 프레임에 패킷\(또는 그 조각 각각\)을 캡슐화하고 적절한 인터페이스에서 출력하기 위해 대기열에 넣습니다.

---
### **5.2.2 IP Header Validation**

라우터가 IP 패킷을 처리하기 전에 패킷의 IP 헤더에 대해 다음과 같은 기본 유효성 검사를 수행하여 헤더가 의미가 있는지 확인해야 합니다. 패킷이 다음 테스트 중 하나라도 실패하면 반드시 자동으로 폐기되어야 하며 오류가 기록되어야 합니다.\(MUST, MUST\)

\(1\) 링크 계층에서 보고하는 패킷 길이는 최소 길이의 합법적인 IP 데이터그램\(20바이트\)을 담을 수 있을 만큼 커야 합니다.

\(2\) IP 체크섬이 정확해야 합니다.

\(3\) IP 버전 번호는 4여야 합니다. 버전 번호가 4가 아닌 경우 패킷은 IPng 또는 ST-II와 같은 다른 버전의 IP일 수 있습니다.

\(4\) IP 헤더 길이 필드는 최소 길이의 합법적인 IP 데이터그램\(20바이트 = 5워드\)을 보유할 만큼 충분히 커야 합니다.

\(5\) IP 총 길이 필드는 IP 헤더 길이 필드에 지정된 길이의 IP 데이터그램 헤더를 담을 수 있을 만큼 충분히 커야 합니다.

라우터에는 이러한 테스트를 비활성화할 수 있는 구성 옵션이 있어서는 안 됩니다.\(MUST NOT\)

패킷이 두 번째 및 세 번째 테스트를 통과하면 IP 헤더 길이 필드가 최소 4이고 링크 계층에서 보고된 IP 총 길이 필드와 패킷 길이가 모두 최소 16인 경우 위의 규칙에도 불구하고 라우터는 다음을 수행할 수 있습니다. ICMP 매개변수 문제 메시지로 응답합니다. 이 메시지의 포인터는 IP 헤더 길이 필드\(네 번째 테스트에 실패한 경우\) 또는 IP 전체 길이 필드\(다섯 번째 테스트에 실패한 경우\)를 가리킵니다. 그러나 여전히 패킷을 폐기해야 하며\(MUST\) 오류를 기록해야 합니다\(SHOULD\).\(MAY, MUST\)

이러한 규칙\(및 이 전체 문서\)은 인터넷 프로토콜 버전 4에만 적용됩니다. 이러한 규칙은 라우터가 다른 버전의 IP를 지원하는 것을 금지하는 것으로 해석되어서는 안 됩니다. 더욱이, 라우터가 실제로 패킷을 IP의 다른 버전으로 분류할 수 있다면 이 메모의 맥락에서 해당 패킷을 오류 패킷으로 처리해서는 안 됩니다.

구현

- 헤더가 유효하지 않은 이유를 확인하는 것이 항상 가능한 것은 아니지만 오류 보고 목적으로 바람직합니다. 가능한 이유는 네 가지입니다.

- o 링크 계층이 IP 헤더를 잘랐습니다.

- o 데이터그램이 표준 IP 버전\(버전 4\)이 아닌 IP 버전을 사용하고 있습니다.

- o IP 헤더가 전송 중에 손상되었습니다.

- o 발신자가 불법 IP 헤더를 생성했습니다.

- 나열된 순서대로 검사를 수행하는 것이 바람직할 것입니다. 왜냐하면 이 순서가 오류의 원인을 정확하게 분류할 가능성이 가장 높기 때문입니다. 오류 보고를 위해 이러한 테스트에 실패한 패킷에 IPng 또는 ST-II를 나타내는 IP 버전 번호가 있는지 확인하는 것이 바람직할 수도 있습니다. 이는 해당 사양에 따라 처리되어야 합니다.

추가적으로, 라우터는 링크 레이어에 의해 보고된 패킷 길이가 적어도 패킷의 IP 헤더에 기록된 IP 총 길이만큼 큰지 확인해야 합니다. 패킷이 잘린 것으로 나타나면 패킷을 폐기해야 하며 오류를 기록해야 하며 라우터는 포인터가 IP 총 길이 필드를 가리키는 ICMP 매개변수 문제 메시지로 응답해야 합니다.\(SHOULD, MUST\)

논의

- 데이터 손상과 관련된 상위 계층 프로토콜은 패킷 데이터가 최종 목적지에 도달할 때 잘림을 감지하므로 라우터가 프로토콜 정확성을 유지하기 위해 위에서 제안한 검사를 수행할 필요는 없습니다. 그러나 이 확인을 통해 라우터는 경로에서 패킷을 자르는 홉을 결정하는 작업을 상당히 단순화할 수 있습니다. 또한 다운스트림 시스템이 패킷을 처리할 필요가 없다는 점에서 라우터의 다운스트림 리소스 지출도 줄어듭니다.

마지막으로 IP 헤더의 대상 주소가 라우터 주소 중 하나가 아닌 경우 라우터는 패킷에 Strict Source and Record Route 옵션이 포함되어 있지 않은지 확인해야 합니다. 패킷이 이 테스트에 실패하면\(엄격한 소스 경로 옵션이 포함된 경우\) 라우터는 오류를 기록해야 하며 문제가 되는 패킷의 IP 대상 주소를 가리키는 포인터를 사용하여 ICMP 매개변수 문제 오류로 응답해야 합니다.\(SHOULD, SHOULD\)

논의

- 어떤 사람들은 라우터가 매개변수 문제 메시지 대신 Bad Source Route 메시지로 응답해야 한다고 제안할 수도 있습니다. 그러나 패킷이 이 테스트에 실패하면 일반적으로 다음을 나타냅니다.

- 이전 홉 라우터에 의한 프로토콜 오류. 반면 잘못된 소스 경로는 소스 호스트가 네트워크를 통해 존재하지 않거나 끊어진 경로를 요청했음을 나타냅니다.

---
### **5.2.3 Local Delivery Decision**

라우터는 IP 패킷을 수신할 때 패킷의 주소가 라우터로 지정되는지\(로컬로 전달되어야 하는지\) 또는 패킷이 다른 시스템으로 지정되는지\(전달자가 처리해야 하는지\) 결정해야 합니다. 특정 IP 브로드캐스트와 IP 멀티캐스트가 모두 로컬로 전달되고 전달되는 하이브리드 사례도 있습니다. 라우터는 다음 규칙을 사용하여 이 세 가지 경우 중 어느 경우가 적용되는지 결정해야 합니다.\(MUST\)

o 만료되지 않은 소스 경로 옵션은 포인터 값이 소스 경로의 마지막 항목 이후를 가리키지 않는 옵션입니다. 패킷에 만료되지 않은 소스 경로 옵션이 포함되어 있으면 옵션의 포인터는 포인터가 옵션의 마지막 주소를 지나도록 지정되거나 다음 주소가 라우터 자체 주소 중 하나가 아닐 때까지 전진됩니다. 후자\(정상\)의 경우 아래 규칙에 관계없이 패킷이 전달됩니다\(로컬로 전달되지 않음\).

o 패킷은 로컬로 전달되며 다음과 같은 경우 전달 대상으로 고려되지 않습니다.

- - 패킷의 대상 주소가 라우터의 IP 주소 중 하나와 정확히 일치합니다.

- - 패킷의 대상 주소가 제한된 브로드캐스트 주소\({-1, -1}\)이거나

- - 패킷의 대상은 전달되지 않는 IP 멀티캐스트 주소\(예: 224.0.0.1 또는 224.0.0.2\)이고 \(적어도\) 패킷이 도착한 물리적 인터페이스와 연결된 논리적 인터페이스 중 하나는 대상 멀티캐스트 그룹.

o 다음과 같은 경우 패킷이 전달자에게 전달되고 로컬로 전달됩니다.

- - 패킷의 대상 주소가 라우터의 논리적 인터페이스 중 하나 이상을 주소 지정하지만 패킷이 도착한 물리적 인터페이스와 연결된 논리적 인터페이스 중 어느 것도 주소를 지정하지 않는 IP 브로드캐스트 주소입니다.

- - 패킷의 대상은 전달이 허용되는 IP 멀티캐스트 주소\(224.0.0.1 및 224.0.0.2와 달리\)이며 \(적어도\) 패킷이 도착한 물리적 인터페이스와 연결된 논리적 인터페이스 중 하나는 대상 멀티캐스트 그룹

o 패킷의 대상 주소가 패킷이 도착한 물리적 인터페이스와 연결된 논리적 인터페이스 중 하나 이상을 주소 지정하는 IP 브로드캐스트 주소\(제한된 브로드캐스트 주소 제외\)인 경우 패킷은 로컬로 전달됩니다. 패킷이 도착한 링크가 유니캐스트와 다르게 브로드캐스트를 캡슐화하지 않는 IP 캡슐화를 사용하지 않는 한\(예: 다른 링크 계층 대상 주소 사용\) 패킷도 전달자에게 전달됩니다.

o 다른 모든 경우에는 패킷이 전달자에게 전달됩니다.

논의

- 네 번째 글머리 기호의 마지막 문장에 있는 요구 사항의 목적은 동일한 물리적 케이블의 다른 네트워크 접두사로 직접 방송을 처리하는 것입니다. 일반적으로 이는 예상대로 작동합니다. 발신자는 브로드캐스트를 링크 계층 유니캐스트로 라우터에 보냅니다. 라우터는 유니캐스트로 도착했음을 기록하므로 보낸 사람이 보낸 것과 다른 네트워크 접두어로 향해야 합니다. 따라서 라우터는 이를 도착했던 것과 동일한\(물리적\) 인터페이스로 브로드캐스트하는 링크 계층으로 안전하게 보낼 수 있습니다. 그러나 라우터가 패킷이 링크 계층 유니캐스트로 수신되었는지 여부를 알 수 없는 경우 이 문장은 라우터가 안전하지 않지만 옳은 일을 하는 것이 아니라 안전하지만 잘못된 일을 한다는 것을 보장합니다.

구현

- \[5.3.4\]절에서 설명한 것처럼 Link Layer 브로드캐스트로 수신된 패킷은 일반적으로 전달되지 않습니다. 해당 섹션의 규칙으로 인해 나중에 폐기할 전달자 패킷을 전달하지 않는 것이 유리할 수 있습니다.

- 일부 링크 계층\(하드웨어 또는 드라이버의 특수 코드로 인해\)은 전송하는 모든 링크 계층 브로드캐스트 및 멀티캐스트의 복사본을 라우터에 전달할 수 있습니다. 이 기능을 사용하면 패킷을 전달자에게 전달하고 로컬로 전달해야 하는 경우의 구현을 단순화할 수 있습니다. 왜냐하면 패킷을 전달하면 라우터가 자동으로 패킷 복사본을 수신하여 로컬로 전달할 수 있기 때문입니다. 이러한 상황에서는 수신된 루프백 패킷을 수신된 일반 패킷으로 취급하는 것을 방지하기 위해 주의를 기울여야 합니다\(그리고 전달 규칙 등의 적용을 받음\).

- 그러한 링크 계층이 없더라도 전달 및 로컬 전달을 위해 대기열에 넣기 위해 전체 패킷의 복사본을 만드는 것은 물론 거의 필요하지 않습니다. 그러나 조각에 주의를 기울여야 합니다. 왜냐하면 재조립은 로컬로 전달된 패킷에 대해 수행되지만 전달된 패킷에는 없습니다. 간단한 방법 중 하나는 라우터의 출력 큐에 있는 각 패킷에 패킷이 전송된 후 로컬 전달을 위해 큐에 넣어야 하는지 여부를 나타내는 플래그를 연결하는 것입니다.

---
### **5.2.4 Determining the Next Hop Address**

라우터가 패킷을 전달할 때 목적지로 직접 보낼 수 있는지, 아니면 다른 라우터를 통해 전달해야 하는지를 결정해야 합니다. 후자의 경우 사용할 라우터를 결정해야 합니다. 이 섹션에서는 이러한 결정이 이루어지는 방법을 설명합니다.

이 섹션에서는 다음 정의를 사용합니다.

o LSRR - IP 느슨한 소스 및 레코드 경로 옵션

o SSRR - IP 엄격한 소스 및 레코드 경로 옵션

o 소스 경로 옵션 - LSRR 또는 SSRR

o 최종 대상 주소 - 패킷이 전송되는 위치: 소스 라우팅 패킷의 소스 경로에 있는 마지막 주소 또는 소스 라우팅되지 않은 패킷의 IP 헤더에 있는 대상 주소

o 인접 - IP 라우터를 통하지 않고 도달 가능

o 다음 홉 주소 - 다음에 패킷을 보내야 하는 인접한 호스트 또는 라우터의 IP 주소

o IP 대상 주소 - 소스 라우팅 패킷을 제외하고 최종 대상 주소로, 소스 경로에 지정된 다음 주소입니다.

o 즉시 대상 - 노드, 시스템, 라우터, 최종 시스템 또는 IP 대상 주소로 주소가 지정된 모든 것.

---
#### **5.2.4.1 IP Destination Address**

```text
   If:
```

o IP 헤더의 대상 주소는 라우터의 주소 중 하나입니다.

o 패킷에는 소스 경로 옵션이 포함되어 있습니다.

o 소스 경로 옵션의 포인터가 옵션 끝을 지나 가리키지 않습니다.

다음 IP 대상 주소는 해당 옵션의 포인터가 가리키는 주소입니다. 만약에:

o IP 헤더의 대상 주소는 라우터의 주소 중 하나입니다.

o 패킷에는 소스 경로 옵션이 포함되어 있습니다.

o 소스 경로 옵션의 포인터가 옵션 끝을 가리킵니다.

그런 다음 메시지는 메시지를 분석하는 시스템으로 전달됩니다.

라우터는 패킷 처리 방법을 결정할 때 최종 대상 주소\(소스 경로 옵션의 마지막 주소\)가 아닌 IP 대상 주소를 사용해야 합니다.\(MUST\)

데이터그램에 둘 이상의 소스 경로 옵션이 나타나는 것은 오류입니다. 그러한 데이터그램을 수신하면 패킷을 폐기하고 포인터가 두 번째 소스 경로 옵션의 시작 부분을 가리키는 ICMP 매개변수 문제 메시지로 응답해야 합니다.\(SHOULD\)

---
#### **5.2.4.2 Local/Remote Decision**

섹션 \[5.2.3\]에 지정된 규칙에 따라 IP 패킷을 전달해야 한다고 결정한 후에는 직접 대상에 직접 액세스할 수 있는지 결정하기 위해 다음 알고리즘을 사용해야 합니다\(\[인터넷:2\] 참조\).\(MUST\)

\(1\) IP 주소가 할당되지 않은 각 네트워크 인터페이스\(섹션 \[2.2.7\]에 설명된 번호가 없는 라인\)에 대해 라인의 다른 쪽 끝의 라우터 ID를 IP 대상 주소와 비교합니다. 정확히 동일하면 이 인터페이스를 통해 패킷을 전송할 수 있습니다.

논의

- 즉, 회선의 원격 끝에 있는 라우터나 호스트는 패킷의 대상이거나 소스 라우팅 패킷의 소스 경로의 다음 단계입니다.

\(2\) 첫 번째 단계에서 네트워크 인터페이스를 선택하지 않은 경우 라우터에 할당된 각 IP 주소에 대해:

\(a\) 인터페이스에서 사용되는 네트워크 접두사를 격리합니다.

구현

- 이 작업의 결과는 일반적으로 초기화 중에 계산되어 저장됩니다.

\(b\) 패킷의 IP 대상 주소에서 해당 비트 세트를 분리합니다.

\(c\) 결과 네트워크 접두사를 비교합니다. 서로 동일할 경우 해당 네트워크 인터페이스를 통해 패킷을 전송할 수 있습니다.

\(3\) 대상이 번호가 지정되지 않은 인터페이스의 이웃 라우터 ID도 아니고 직접 연결된 네트워크 접두사의 구성원도 아닌 경우 IP 대상은 다른 라우터를 통해서만 액세스할 수 있습니다. 라우터와 다음 홉 IP 주소의 선택은 \[5.2.4.3\]절에서 설명된다. 라우터도 아닌 호스트의 경우 이는 구성된 기본 라우터일 수 있습니다.

IETF \[ARCH:9, NRHP\]에서 진행 중인 작업에서는 여러 IP \(서브\)네트워크가 동일한 링크 계층 네트워크에 오버레이되는 경우와 같은 몇 가지 경우를 고려합니다. 정책 제한을 제외하면 공통 링크 계층 네트워크를 사용하는 호스트와 라우터는 동일한 IP\(서브\)네트워크에 있지 않더라도 적절한 정보가 있으면 직접 통신할 수 있습니다. NHRP\(Next Hop Routing Protocol\)를 사용하면 IP 엔터티가 이러한 링크 계층 네트워크를 원격 대상을 향해 통과하는 데 사용할 "최적" 링크 계층 주소를 결정할 수 있습니다.

\(4\) 선택한 "다음 홉"이 NHRP를 사용하도록 구성된 인터페이스를 통해 연결할 수 있는 경우 다음 추가 단계가 적용됩니다.

\(a\) IP 대상 주소를 NHRP 캐시의 대상 주소와 비교합니다. 주소가 캐시에 있으면 해당 캐시 링크 계층 주소로 데이터그램을 보냅니다. \(b\) 주소가 캐시에 없으면 IP 대상 주소를 포함하는 NHRP 요청 패킷을 구성합니다. 이 메시지는 해당 인터페이스에 대해 구성된 NHRP 서버로 전송됩니다. 이는 라우터 자체에서 논리적으로 별도의 프로세스 또는 엔터티일 수 있습니다.

\(c\) NHRP 서버는 데이터그램과 후속 데이터그램을 동일한 대상으로 전송하는 데 사용할 적절한 링크 계층 주소로 응답합니다. 시스템은 NHRP 응답을 기다리는 동안 데이터그램을 전통적인 "다음 홉" 라우터로 전송할 수 있습니다.\(MAY\)

---
#### **5.2.4.3 Next Hop Address**

편집자+댓글

- 라우터는 이전 섹션의 알고리즘을 적용하여 IP 대상 주소가 인접해 있는지 확인합니다. 그렇다면 다음 홉 주소는 IP 대상 주소와 동일합니다. 그렇지 않으면 패킷이 즉시 대상에 도달하기 위해 다른 라우터를 통해 전달되어야 합니다. 이 라우터의 선택이 이 섹션의 주제입니다.

- 패킷에 SSRR이 포함된 경우 라우터는 패킷을 폐기하고 ICMP Bad Source Route 오류로 응답해야 합니다. 그렇지 않으면 라우터는 라우팅 테이블에서 IP 대상 주소를 조회하여 적절한 다음 홉 주소를 결정합니다.\(MUST\)

논의

- IP 사양에 따라 엄격한 소스 경로는 패킷이 통과해야 하는 노드 순서를 지정해야 합니다. 패킷은 소스 경로의 한 노드에서 다음 노드로 이동해야 하며 중간 네트워크만 통과해야 합니다. 따라서 라우터가 소스 경로의 다음 단계에 인접하지 않으면 소스 경로를 이행할 수 없습니다. 따라서 라우터는 ICMP Bad Source Route 오류로 인해 이를 거부합니다.

다음 홉 선택 프로세스의 목표는 라우터의 FIB\(Forwarding Information Base\) 항목을 검사하고 FIB에서 사용 가능한 경로 중에서 패킷에 대한 최상의 경로\(있는 경우\)를 선택하는 것입니다.

개념적으로 모든 경로 조회 알고리즘은 FIB의 전체 내용으로 구성된 후보 경로 집합으로 시작됩니다. 알고리즘은 세트에서 경로를 삭제하는 일련의 단계로 구성됩니다. 이러한 단계를 정리 규칙이라고 합니다. 일반적으로 알고리즘이 종료되면 세트에는 정확히 하나의 경로가 남습니다. 세트가 비어 있으면 대상에 도달할 수 없기 때문에 패킷이 삭제됩니다. 세트에 둘 이상의 경로가 남아 있으면 알고리즘이 종료될 수도 있습니다. 이 경우, 라우터는 그 중 하나만 남기고 모두 임의로 폐기할 수도 있고, 가장 최근에 사용된 경로를 선택하여 "부하 분할"을 수행할 수도 있습니다.

규칙 3\(약한 TOS\)을 제외하고, 라우터는 패킷의 다음 홉을 선택할 때 다음 정리 규칙을 사용해야 합니다. 만약\(MUST\)

라우터는 다음 홉 결정을 내릴 때 TOS를 고려하므로 규칙 3은 아래 표시된 순서대로 적용되어야 합니다. 이러한 규칙은 제시된 순서대로 FIB에 \(개념적으로\) 적용되어야 합니다. \(일부 역사적 관점, 추가 가지치기 규칙 및 기타 사용 중인 일반적인 알고리즘에 대해서는 부록 E를 참조하세요.\)\(MUST\)

논의

- 섹션 \[5.3.2\]에서 규칙 3은 라우터가 전달 결정을 내릴 때 TOS만 고려해야 한다는 점에서 선택 사항입니다.\(SHOULD\)

\(1\) 기본 매치

- 이 규칙은 패킷의 IP 대상 주소 이외의 대상으로 향하는 모든 경로를 삭제합니다. 예를 들어, 패킷의 IP 대상 주소가 10.144.2.5인 경우 이 단계에서는 네트워크 128.12.0.0/16에 대한 경로를 삭제하지만 네트워크 접두사 10.0.0.0/8 및 10.144.0.0/16에 대한 모든 경로는 유지합니다. 기본 경로.

- 보다 정확하게는 각 경로에 Route.dest라는 대상 속성과 Route.length라는 해당 접두사 길이가 있어 Route.dest의 어느 비트가 중요한지 지정한다고 가정합니다. 전달되는 패킷의 IP 대상 주소는 ip.dest입니다. 이 규칙은 Route.dest와 ip.dest의 가장 중요한 Route.length 비트가 동일한 경로를 제외하고 후보 집합에서 모든 경로를 삭제합니다.

예를 들어, 패킷의 IP 대상 주소가 다음과 같은 경우

- 10.144.2.5이고 네트워크 접두사 10.144.1.0/24, 10.144.2.0/24 및 10.144.3.0/24가 있는 경우 이 규칙은 10.144.2.0/24만 유지합니다. 이는 접두사가 패킷의 IP 대상 주소에 있는 해당 비트와 동일한 값을 갖는 유일한 경로입니다.

\(2\) 최장 경기

- Longest Match는 위에서 설명한 Basic Match를 개선한 것입니다. 기본 일치 정리를 수행한 후 알고리즘은 나머지 경로를 검사하여 가장 큰 Route.length 값을 갖는 경로를 결정합니다. 이 외에는 모두 폐기됩니다.

예를 들어, 패킷의 IP 대상 주소가 다음과 같은 경우

- 10.144.2.5이고 네트워크 접두사 10.144.2.0/24, 10.144.0.0/16 및 10.0.0.0/8이 있는 경우 접두사 길이가 가장 길기 때문에 이 규칙은 첫 번째\(10.144.2.0/24\)만 유지합니다.

\(3\) 약한 TOS

- 각 경로에는 Route.tos라는 서비스 속성 유형이 있으며, 이 속성의 가능한 값은 IP 헤더의 TOS 필드에 사용된 값과 동일하다고 가정됩니다. TOS 정보를 배포하는 라우팅 프로토콜은 FIB에 추가하는 경로에서 Route.tos를 적절하게 채웁니다. 다른 라우팅 프로토콜의 경로는 기본 TOS\(0000\)가 있는 것처럼 처리됩니다. 라우팅되는 패킷의 IP 헤더에 있는 TOS 필드를 ip.tos라고 합니다.

- 후보 경로 집합을 검사하여 Route.tos = ip.tos인 경로가 포함되어 있는지 확인합니다. 그렇다면, Route.tos = ip.tos인 경로를 제외한 모든 경로는 폐기됩니다. 그렇지 않은 경우, Route.tos = 0000인 경로를 제외한 모든 경로는 후보 경로 집합에서 삭제됩니다.

- 약한 TOS 기반 라우팅에 대한 추가 논의는 \[ROUTE:11\]에서 확인할 수 있습니다.

논의

- 이 규칙의 효과는 패킷에서 요청된 TOS와 일치하는 TOS가 있는 경로만 선택하는 것입니다. 그러한 경로가 존재하지 않으면 기본 TOS가 있는 경로가 고려됩니다. 패킷에서 요청된 TOS가 아닌 기본 TOS가 아닌 경로는 해당 경로가 패킷 대상으로 이동하는 유일한 사용 가능한 경로인 경우에도 사용되지 않습니다.

\(4\) 최고의 지표

- 각 경로에는 Route.metric이라는 메트릭 속성과 Route.domain이라는 라우팅 도메인 식별자가 있습니다. 후보 경로 집합의 각 구성원은 집합의 다른 구성원과 비교됩니다. 두 경로에 대해 Route.domain이 동일하고 다른 경로와 비교할 때 Route.metric이 한 경로에 대해 엄격하게 열등한 경우 열등한 메트릭을 가진 경로는 세트에서 삭제됩니다. 열등 여부는 일반적으로 간단한 산술 비교를 통해 결정되지만 일부 프로토콜에는 더 복잡한 비교가 필요한 구조화된 측정 항목이 있을 수 있습니다.

\(5\) 벤더 정책

- 공급업체 정책은 이전에 나열된 규칙이 가능한 경로 중에서 선택하기에는 종종 부적절하다는 사실을 보완하기 위한 일종의 포괄적인 정책입니다. 공급업체 정책 정리 규칙은 공급업체별로 매우 다릅니다. 섹션 \[5.2.4.4\]을 참조하십시오.

```text
     This algorithm has two distinct disadvantages.  Presumably, a
     router implementor might develop techniques to deal with these
```

단점을 제거하고 공급업체 정책 정리 규칙의 일부로 만듭니다.

\(1\) IS-IS 및 OSPF 경로 클래스는 직접 처리되지 않습니다.

\(2\) 서비스 유형\(예: MTU\) 이외의 경로 속성은 무시됩니다.

TOS가 지원되는 방식에 결함이 있다는 점도 주목할 가치가 있습니다. TOS 값이 0이 아닌 패킷을 전달할 때 TOS를 지원하는 라우팅 프로토콜이 암묵적으로 선호됩니다.

기본 일치 및 가장 긴 일치 가지치기 규칙은 여러 특정 유형의 경로 처리를 일반화합니다. 이러한 경로는 다음과 같은 선호도 내림차순으로 선택됩니다.

\(1\) 호스트 경로: 특정 엔드 시스템으로의 경로입니다.

\(2\) 계층적 네트워크 접두사 경로: 특정 네트워크 접두사에 대한 경로입니다. FIB에는 서로를 포함하는 네트워크 접두사에 대한 여러 경로가 포함될 수 있습니다\(한 접두사는 추가 비트가 있는 다른 접두사입니다\). 접두사 길이가 줄어드는 순서대로 선택됩니다.

\(5\) 기본 경로: 명시적인 경로가 없는 모든 네트워크에 대한 경로입니다. 정의에 따르면 접두사 길이가 0인 경로입니다.

정리 규칙을 적용한 후 경로 집합이 비어 있는 경우\(즉, 경로를 찾을 수 없음\) 패킷을 폐기해야 하며 적절한 ICMP 오류가 생성되어야 합니다\(IP 대상 주소가 소스 경로에서 나온 경우 ICMP 잘못된 소스 경로\). 그렇지 않으면 섹션 \[4.3.3.1\]에 설명된 대로 ICMP 대상 호스트 도달 불가능 또는 대상 네트워크 도달 불가능 중 어느 것이 적절합니까?\(MUST\)

---
#### **5.2.4.4 Administrative Preference**

공급업체 정책 정리 규칙에 대해 제안된 메커니즘 중 하나는 간단한 우선 순위 지정 알고리즘인 관리 기본 설정을 사용하는 것입니다. 아이디어는 선택해야 할 경로의 우선순위를 수동으로 지정하는 것입니다.

```text
     Each route has associated with it a preference value, based on
     various attributes of the route (specific mechanisms for assignment
     of preference values are suggested below).  This preference value
     is an integer in the range [0..255], with zero being the most
     preferred and 254 being the least preferred.  255 is a special
```

이는 해당 경로를 절대 사용해서는 안 된다는 의미입니다. 공급업체 정책 정리 규칙의 첫 번째 단계는 가장 선호하는 경로를 제외한 모든 경로를 삭제합니다\(그리고 기본 설정 값이 255인 경로는 항상 삭제합니다\).

이 정책은 라우팅 루프를 생성하는 데 쉽게 오용될 수 있다는 점에서 안전하지 않습니다. 어떤 프로토콜도 라우터에 대해 구성된 기본 설정이 이웃에 구성된 기본 설정과 일치하도록 보장하지 않으므로 네트워크 관리자는 기본 설정을 구성할 때 주의를 기울여야 합니다.

o 주소 일치

- 지정된 대상 집합 중 하나에 대한 모든 경로\(동일한 라우팅 도메인에서 학습된\)에 단일 기본 설정 값을 할당할 수 있으면 유용합니다. 여기서 대상 집합은 지정된 네트워크 접두사와 일치하는 모든 대상입니다.

o 노선 등급

- 구별을 유지하는 라우팅 프로토콜의 경우 특정 경로 클래스\(지역 내, 지역 간, 외부 및 내부\)를 갖는 모든 경로\(동일한 라우팅 도메인에서 학습\)에 단일 기본 설정 값을 할당할 수 있는 것이 유용합니다. 측정항목 또는 외부 측정항목이 있는 외부\).

o 인터페이스

- 패킷이 라우터의 특정 논리적 인터페이스\(일반적으로 논리적 인터페이스는 일대일 매핑\)로 라우팅되도록 하는 모든 경로\(특정 라우팅 도메인에서 학습\)에 단일 기본 설정 값을 할당할 수 있으면 유용합니다. 단, IP 주소가 여러 개인 네트워크 인터페이스에는 이와 연결된 여러 논리 인터페이스가 있다는 점은 제외\).

o 소스 라우터

- 라우터 집합에서 학습된 모든 경로\(동일한 라우팅 도메인에서 학습됨\)에 단일 기본 설정 값을 할당할 수 있으면 유용합니다. 여기서 라우터 집합은 업데이트가 일치하는 소스 주소를 갖는 라우터 집합입니다. 지정된 네트워크 접두사.

```text
     o Originating AS
        For routing protocols which provide the information, it is
        useful to be able to assign a single preference value to all
        routes (learned from a particular routing domain) which
        originated in another particular routing domain.  For BGP
        routes, the originating AS is the first AS listed in the route's
        AS_PATH attribute.  For OSPF external routes, the originating AS
        may be considered to be the low order 16 bits of the route's
```

- 태그의 자동 비트가 설정되어 있고 태그의 경로 길이가 3이 아닌 경우 외부 경로 태그입니다.

o 외부 경로 태그

- 외부 경로 태그가 지정된 값 목록과 일치하는 모든 OSPF 외부 경로\(동일한 라우팅 도메인에서 학습됨\)에 단일 기본 설정 값을 할당할 수 있으면 유용합니다. 외부 경로 태그에는 구조화된 값이 포함될 수 있으므로 태그의 특정 하위 필드를 일치시키는 기능을 제공하는 것이 유용할 수 있습니다.

o AS 경로

- AS 경로가 지정된 값 집합과 "일치"하는 모든 BGP 경로\(동일한 라우팅 도메인에서 학습됨\)에 단일 기본 설정 값을 할당할 수 있으면 유용할 수 있습니다. 어떤 종류의 일치 항목이 가장 유용한지는 아직 명확하지 않습니다. 간단한 옵션은 경로의 AS\_PATH 속성 어디에서나 특정 AS 번호가 나타나는\(또는 나타나지 않는\) 모든 경로의 일치를 허용하는 것입니다. 보다 일반적이지만 다소 어려운 대안은 AS 경로가 지정된 정규식과 일치하는 모든 경로를 일치시키는 것을 허용하는 것입니다.

---
#### **5.2.4.5 Load Splitting**

다음 홉 선택 프로세스가 끝나면 여러 경로가 여전히 남아 있을 수 있습니다. 이 경우 라우터에는 여러 가지 옵션이 있습니다. 일부 경로를 임의로 삭제할 수 있습니다. 동등하다고 간주되지 않는 라우팅 도메인의 경로 메트릭을 비교하여 후보 경로 수를 줄일 수 있습니다. 두 개 이상의 경로를 유지하고 로드 분할 메커니즘을 사용하여 경로 간에 트래픽을 나눌 수 있습니다. 아마도 옵션의 상대적 장점에 대해 말할 수 있는 유일한 것은 로드 분할이 어떤 상황에서는 유용하지만 다른 상황에서는 유용하지 않다는 것입니다. 따라서 로드 분할을 구현하는 현명한 구현자는 네트워크 관리자가 비활성화할 수 있는 방법도 제공할 것입니다. 그것.

---
### **5.2.5 Unused IP Header Bits: RFC-791 Section 3.1**

IP 헤더에는 서비스 유형 필드와 플래그 필드에 예약된 여러 비트가 포함되어 있습니다. 라우터는 단지 이러한 예약된 비트 중 하나 이상이 0이 아닌 값을 갖는다는 이유만으로 패킷을 삭제해서는 안 됩니다.\(MUST NOT\)

라우터는 이러한 예약된 비트의 값을 무시하고 변경되지 않은 상태로 통과해야 합니다. 라우터가 패킷을 조각화하는 경우 이러한 비트를 각 조각에 복사해야 합니다.\(MUST, MUST\)

논의

- IP 프로토콜의 향후 개정판에서는 이러한 사용되지 않은 비트를 활용할 수 있습니다. 이러한 규칙은 인터넷의 모든 라우터를 동시에 업그레이드하지 않고도 이러한 개정판을 배포할 수 있도록 하기 위한 것입니다.

---
### **5.2.6 Fragmentation and Reassembly: RFC-791 Section 3.2**

섹션 \[4.2.2.7\]에서 논의된 것처럼 라우터는 IP 단편화를 지원해야 합니다.\(MUST\)

라우터는 데이터그램을 전달하기 전에 데이터그램을 재조립해서는 안 됩니다.\(MUST NOT\)

논의

- 몇몇 사람들은 라우터에 의한 전송 데이터그램 재조립이 성능을 향상시킬 수 있는 일부 토폴로지가 있을 수 있다고 제안했습니다. 조각이 대상까지 다른 경로를 취할 수 있다는 사실로 인해 이러한 기능을 안전하게 사용할 수 없습니다.

- 이 섹션의 어떤 내용도 라우터에 의해 링크 계층 기능으로 수행되는 조각화 또는 재조립을 제어하거나 제한하는 것으로 해석되어서는 안 됩니다.

- 마찬가지로 IP 데이터그램이 다른 IP 데이터그램에 캡슐화되면\(예: 터널링됨\) 해당 데이터그램이 조각화되고 원본 데이터그램을 전달하려면 조각을 다시 조립해야 합니다. 이 섹션은 이를 배제하지 않습니다.

---
### **5.2.7 Internet Control Message Protocol - ICMP**

ICMP에 대한 일반 요구 사항은 섹션 \[4.3\]에서 논의되었습니다. 이 섹션에서는 라우터에서만 전송되는 ICMP 메시지에 대해 설명합니다.

---
#### **5.2.7.1 Destination Unreachable**

ICMP 목적지 도달 불가 메시지는 목적지\(또는 다음 홉\)에 도달할 수 없거나 서비스를 사용할 수 없기 때문에 전달할 수 없는 패킷에 대한 응답으로 라우터에서 전송됩니다. 이러한 경우의 예로는 호스트에 존재하지 않아 ARP 요청에 응답하지 않는 호스트로 주소가 지정된 메시지, 라우터에 유효한 경로가 없는 네트워크 접두사로 주소가 지정된 메시지가 포함됩니다.

라우터는 ICMP 목적지 도달 불가 메시지를 생성할 수 있어야 하며\(MUST\) 메시지가 생성되는 이유와 가장 근접하게 일치하는 응답 코드를 선택해야 합니다\(SHOULD\).\(MUST\)

다음 코드는 \[INTERNET:8\] 및 \[INTRO:2\]에 정의되어 있습니다.

```text
   0 = Network Unreachable - generated by a router if a forwarding path
        (route) to the destination network is not available;

   1 = Host Unreachable - generated by a router if a forwarding path
        (route) to the destination host on a directly connected network
        is not available (does not respond to ARP);

   2 = Protocol Unreachable - generated if the transport protocol
        designated in a datagram is not supported in the transport layer
        of the final destination;

   3 = Port Unreachable - generated if the designated transport protocol
        (e.g., UDP) is unable to demultiplex the datagram in the
        transport layer of the final destination but has no protocol
        mechanism to inform the sender;

   4 = Fragmentation Needed and DF Set - generated if a router needs to
        fragment a datagram but cannot since the DF flag is set;

   5 = Source Route Failed - generated if a router cannot forward a
        packet to the next hop in a source route option;

   6 = Destination Network Unknown - This code SHOULD NOT be generated
        since it would imply on the part of the router that the
        destination network does not exist (net unreachable code 0
        SHOULD be used in place of code 6);

   7 = Destination Host Unknown - generated only when a router can
        determine (from link layer advice) that the destination host
        does not exist;

   11 = Network Unreachable For Type Of Service - generated by a router
        if a forwarding path (route) to the destination network with the
        requested or default TOS is not available;
```

12 = 서비스 유형에 대해 호스트에 연결할 수 없음 - 대상으로의 경로가 데이터그램에서 요청한 TOS 또는 기본 TOS\(0\)와 일치하지 않기 때문에 라우터가 패킷을 전달할 수 없는 경우 생성됩니다.

이에 따라 다음과 같은 추가 코드가 정의됩니다.

```text
   13 = Communication Administratively Prohibited - generated if a
        router cannot forward a packet due to administrative filtering;
```

14 = 호스트 우선순위 위반. 소스/대상 호스트의 특정 조합에 대해 요청된 우선순위가 허용되지 않음을 나타내기 위해 첫 번째 홉 라우터가 호스트로 전송합니다.

```text
        network, upper layer protocol, and source/destination port;

   15 = Precedence cutoff in effect.  The network operators have imposed
        a minimum level of precedence required for operation, the
        datagram was sent with a precedence below this level;
```

참고: \[INTRO:2\]는 격리된 소스 호스트에 대해 코드 8을 정의했습니다. 라우터는 코드 8을 생성해서는 안 됩니다. 코드 0\(네트워크 도달 불가능\)과 1\(호스트 도달 불가능\) 중 적절한 것이 대신 사용되어야 합니다. \[INTRO:2\]는 또한 관리적으로 금지된 대상 네트워크와의 통신을 위한 코드 9와 관리적으로 금지된 대상 호스트와의 통신을 위한 코드 10을 정의했습니다. 이 코드는 미군 기관에서 사용하는 엔드투엔드 암호화 장치에서 사용하기 위한 것입니다. 라우터는 관리상 패킷을 필터링하는 경우 새로 정의된 코드 13\(관리적으로 금지된 통신\)을 사용해야 합니다.\(SHOULD NOT, SHOULD\)

라우터에는 코드 13\(관리적으로 금지된 통신\) 메시지가 생성되지 않도록 하는 구성 옵션이 있을 수 있습니다. 이 옵션을 활성화하면 관리상 전달이 금지되어 삭제된 패킷에 대한 응답으로 ICMP 오류 메시지가 전송되지 않습니다.\(MAY\)

마찬가지로 라우터에는 코드 14\(호스트 우선 순위 위반\) 및 코드 15\(우선 순위 차단 적용\) 메시지가 생성되지 않도록 하는 구성 옵션이 있을 수 있습니다. 이 옵션을 활성화하면 우선 순위 위반으로 인해 삭제된 패킷에 대한 응답으로 ICMP 오류 메시지가 전송되지 않습니다.\(MAY\)

라우터는 동일한 대상 네트워크의 다른 호스트에 연결할 수 있을 때마다 호스트 도달 불가능 또는 대상 호스트 알 수 없는 코드를 사용해야 합니다. 그렇지 않으면 소스 호스트가 네트워크의 모든 호스트에 연결할 수 없다고 잘못 결론을 내릴 수 있으며 실제로는 그렇지 않을 수도 있습니다.\(MUST\)

\[인터넷:14\]에서는 코드 4\(조각화 필요 및 DF 세트\)를 포함하는 대상 도달 불가 메시지 형식을 약간 수정한 것을 설명합니다. 라우터는 Code 4 Destination Unreachable 메시지를 생성할 때 이 수정된 형식을 사용해야 합니다.\(MUST\)

---
#### **5.2.7.2 Redirect**

ICMP 리디렉션 메시지는 특정 트래픽 클래스에 대해 다른 다음 홉 라우터를 사용해야 함을 로컬 호스트에 알리기 위해 생성됩니다.

라우터는 네트워크에 대한 리디렉션 또는 네트워크에 대한 리디렉션 및 서비스 유형 메시지\(코드 0 및 2\)를 생성해서는 안 됩니다.\(MUST NOT\)

\[인터넷:8\]. 라우터는 호스트에 대한 리디렉션 메시지\(코드 1\)를 생성할 수 있어야 하며 \[INTERNET:8\]에 지정된 서비스 유형 및 호스트 메시지에 대한 리디렉션\(코드 3\)을 생성할 수 있어야 합니다.\(MUST\)

논의

- 직접 연결된 네트워크가 서브넷으로 구성되지 않은 경우\(전통적인 의미에서\) 라우터는 일반적으로 지정된 원격 네트워크의 모든 호스트에 적용되는 네트워크 리디렉션을 생성할 수 있습니다. 호스트 리디렉션 대신 네트워크를 사용하면 네트워크 트래픽과 호스트 라우팅 테이블 저장소를 약간 절약할 수 있습니다. 그러나 절감 효과는 크지 않으며 서브넷은 네트워크 리디렉션을 해석하는 데 사용되는 서브넷 마스크에 대해 모호성을 만듭니다. CIDR 환경에서는 네트워크 리디렉션을 사용할 수 있는 경우를 정확하게 지정하기가 어렵습니다. 따라서 라우터는 호스트\(또는 호스트 및 서비스 유형\) 리디렉션만 보내야 합니다.

코드 3\(호스트 및 서비스 유형에 대한 리디렉션\) 메시지는 리디렉션을 유발하는 패킷에 라우터가 선택한 경로가 요청된 TOS에 \(부분적으로\) 의존하는 대상이 있는 경우 생성됩니다.

코드 3 리디렉션\(호스트 및 서비스 유형\)을 생성할 수 있는 라우터에는 코드 3 리디렉션을 대체할 코드 1\(호스트\) 리디렉션을 활성화하는 구성 옵션\(기본값은 켜짐\)이 있어야 합니다. 라우터는 그렇게 구성되어 있는 경우 코드 3 리디렉션 대신 코드 1 리디렉션을 보내야 합니다.\(MUST, MUST\)

라우터가 코드 3 리디렉션을 생성할 수 없는 경우 코드 3 리디렉션이 필요한 상황에서 코드 1 리디렉션을 생성해야 합니다.\(MUST\)

라우터는 다음 조건이 모두 충족되지 않는 한 리디렉션 메시지를 생성해서는 안 됩니다.\(MUST NOT\)

o 패킷이 수신된 것과 동일한 물리적 인터페이스로 전달되고 있습니다.

o 패킷의 IP 소스 주소는 다음 홉 IP 주소와 동일한 논리 IP\(서브\)네트워크에 있고,

o 패킷에 IP 소스 경로 옵션이 포함되어 있지 않습니다.

ICMP 리디렉션에 사용되는 소스 주소는 대상 주소와 동일한 논리\(서브\)네트에 속해야 합니다.\(MUST\)

라우팅 프로토콜\(정적 경로 제외\)을 사용하는 라우터는 패킷을 전달할 때 ICMP 리디렉션에서 학습된 경로를 고려해서는 안 됩니다. 라우터가 라우팅 프로토콜을 사용하지 않는 경우 라우터는 다음을 가질 수 있습니다.\(MUST NOT, MAY\)

설정된 경우 라우터가 패킷을 전달할 때 ICMP 리디렉션을 통해 학습된 경로를 고려할 수 있도록 허용하는 구성입니다.

논의

- ICMP 리디렉션은 라우터가 라우팅 정보를 호스트에 전달하는 메커니즘입니다. 라우터는 다른 메커니즘을 사용하여 라우팅 정보를 학습하므로 리디렉션을 따를 이유가 없습니다. 라우터의 다른 정보와 모순되는 리디렉션을 믿으면 라우팅 루프가 발생할 가능성이 높습니다.

- 반면, 라우터가 라우터 역할을 하지 않는 경우에는 호스트가 요구하는 동작을 준수해야 합니다.\(MUST\)

---
#### **5.2.7.3 Time Exceeded**

라우터는 만료된 TTL 필드로 인해 패킷을 삭제할 때 시간 초과 메시지 코드 0\(전송 중\)을 생성해야 합니다. 라우터는 해당 인터페이스에서 이러한 메시지의 생성을 비활성화하는 인터페이스별 옵션을 가질 수 있지만 해당 옵션은 기본적으로 메시지 생성을 허용해야 합니다.\(MUST, MUST\)

---
### **5.2.8 INTERNET GROUP MANAGEMENT PROTOCOL - IGMP**

IGMP \[INTERNET:4\]는 특정 멀티캐스트 그룹에서 호스트의 멤버십을 설정하기 위해 단일 물리적 네트워크의 호스트와 멀티캐스트 라우터 간에 사용되는 프로토콜입니다. 멀티캐스트 라우터는 멀티캐스트 라우팅 프로토콜과 함께 이 정보를 사용하여 인터넷을 통한 IP 멀티캐스트 전달을 지원합니다.

라우터는 IGMP의 멀티캐스트 라우터 부분을 구현해야 합니다\(SHOULD\).\(SHOULD\)

---
## **5.3 SPECIFIC ISSUES**
---
### **5.3.1 Time to Live (TTL)**

IP 헤더의 TTL\(Time-to-Live\) 필드는 데이터그램의 수명을 제한하는 타이머로 정의됩니다. 8비트 필드이고 단위는 초입니다. 패킷을 처리하는 각 라우터\(또는 기타 모듈\)는 경과 시간이 1초보다 훨씬 짧더라도 TTL을 최소한 1씩 줄여야 합니다. 이런 경우가 매우 많기 때문에 TTL은 데이터그램이 인터넷을 통해 얼마나 멀리 전파될 수 있는지에 대한 사실상 홉 수 제한입니다.\(MUST\)

라우터가 패킷을 전달할 때 TTL을 최소한 1만큼 줄여야 합니다. 1초 이상 패킷을 보유하는 경우 매초마다 TTL을 1씩 줄일 수 있습니다.\(MUST, MAY\)

TTL이 0\(또는 그 이하\)으로 감소하면 패킷을 폐기해야 하며, 대상이 멀티캐스트 주소가 아닌 경우 라우터는 ICMP 시간 초과 메시지, 코드 0\(TTL Exceeded in Transit\) 메시지를 소스로 보내야 합니다. 라우터는 단지 패킷의 최종 목적지로 가는 경로에 있는 다른 라우터가 TTL을 0으로 감소시킬 것이라고 예측할 수 있기 때문에 TTL이 0이 아닌 IP 유니캐스트 또는 브로드캐스트 패킷을 폐기해서는 안 됩니다. 그러나 라우터는 IP 멀티캐스트의 확장 링 검색 알고리즘을 보다 효율적으로 구현하기 위해 IP 멀티캐스트에 대해 그렇게 할 수 있습니다\(\[INTERNET:4\] 참조\).\(MUST, MUST NOT, MAY\)

논의

- IP TTL은 다소 정신분열적으로 홉 수 제한과 시간 제한으로 사용됩니다. 홉 카운트 기능은 라우팅 문제로 인해 패킷이 네트워크에서 무한 루프되도록 하여 네트워크를 붕괴시키지 않도록 하는 데 매우 중요합니다. 시간 제한 기능은 안정적인 데이터 전송을 보장하기 위해 TCP와 같은 전송 프로토콜에서 사용됩니다. 현재의 많은 구현에서는 TTL을 순수한 홉 수로 취급하며 인터넷 커뮤니티의 일부에서는 시간 제한 기능이 필요한 전송 프로토콜에 의해 대신 수행되어야 한다는 강한 정서가 있습니다.

- 이 사양에서 우리는 시간 제한 기능이 선택 사항이어야 한다는 라우터 공급업체 간의 강한 믿음을 마지못해 따르기로 결정했습니다. 그들은 시간 제한 기능의 구현이 현재 일반적으로 구현되지 않을 정도로 어렵다고 주장했습니다. 그들은 또한 이 지름길로 인해 TCP가 데이터를 손상시키는 문서화된 사례가 부족하다는 점을 지적했습니다. 문서화되지 않은 사례가 많았습니다\).

- 확장 링 검색과 같은 IP 멀티캐스트 개념은 TTL이 순수 홉 수로 처리되지 않으면 예상대로 작동하지 않을 수 있습니다. Traceroute의 경우에도 마찬가지입니다.

- Traceroute 진단 도구가 이에 의존하기 때문에 ICMP 시간 초과 메시지가 필요합니다.

따라서 절충안은 심각한 손상을 입히는 것, 그렇지 않은 경우 사이에 있습니다.

- 두 가지 매우 유용한 도구를 제거하고 전혀 발생하지 않을 수 있는 매우 드물고 일시적인 데이터 전송 문제를 방지합니다. 우리는 도구를 보존하기로 결정했습니다.

---
### **5.3.2 Type of Service (TOS)**

- IP 헤더의 서비스 유형 바이트는 우선순위 필드\(상위 3비트\), 관례적으로 서비스 유형 또는 "TOS\(다음 4비트\)라고 불리는 필드, 예약된 필드의 세 가지 섹션으로 나뉩니다. 비트\(낮은 순서 비트\) 예약된 비트를 관리하는 규칙은 섹션 \[4.2.2.3\]에 설명되어 있습니다. 우선 순위 필드는 섹션 \[5.3.3\]에서 논의됩니다. TOS 필드와 그 사용에 대한 보다 광범위한 논의는 다음과 같습니다. \[ROUTE:11\]에서 찾았습니다.

- 라우터는 패킷 전달 방법을 결정할 때 패킷의 IP 헤더에 있는 TOS 필드를 고려해야 합니다. 이 섹션의 나머지 부분에서는 이 요구 사항을 준수하는 라우터에 적용되는 규칙을 설명합니다.\(SHOULD\)

- 라우터는 라우팅 테이블의 각 경로에 대해 TOS 값을 유지해야 합니다. TOS를 지원하지 않는 라우팅 프로토콜을 통해 학습된 경로에는 TOS 0\(기본 TOS\)이 할당되어야 합니다.\(MUST, MUST\)

- 목적지까지의 경로를 선택하려면 라우터는 다음과 동등한 알고리즘을 사용해야 합니다.\(MUST\)

- \(1\) 라우터는 라우팅 테이블에서 대상까지 사용 가능한 모든 경로를 찾습니다\(섹션 \[5.2.4\] 참조\).

- \(2\) 아무것도 없으면 목적지에 도달할 수 없기 때문에 라우터는 패킷을 삭제합니다. 섹션 \[5.2.4\]을 참조하십시오.

- \(3\) 해당 경로 중 하나 이상이 패킷에 지정된 TOS와 정확히 일치하는 TOS를 갖는 경우 라우터는 최상의 메트릭을 가진 경로를 선택합니다.

- \(4\) 그렇지 않으면 라우터는 TOS가 0인 경로를 찾는 것을 제외하고 위 단계를 반복합니다.

- \(5\) 위에서 선택한 경로가 없으면 목적지에 도달할 수 없기 때문에 라우터는 패킷을 삭제합니다. 라우터는 적절한 코드\(서비스 유형으로 네트워크에 연결할 수 없음\(코드 11\) 또는 서비스 유형으로 호스트에 연결할 수 없음\(코드 12\)\)\)를 지정하는 ICMP 대상에 연결할 수 없음 오류를 반환합니다.

논의

- 과거에는 TOS가 거의 사용되지 않았지만 이제 호스트의 사용은 인터넷 호스트 RFC 요구 사항\(\[INTRO:2\] 및 \[INTRO:3\]\)에 따라 의무화됩니다. 라우터의 TOS 지원은 미래에는 필수 사항이 될 수 있지만, 더 많은 경험을 얻고 그 이점과 비용을 더 잘 판단할 수 있을 때까지 지금은 반드시 지원해야 합니다.\(MUST\)

- 다양한 사람들이 TOS가 전달 기능의 다른 측면에 영향을 미쳐야 한다고 제안했습니다. 예를 들어:

- \(1\) 라우터는 출력 대기열의 다른 패킷보다 먼저 낮은 지연 비트가 설정된 패킷을 배치할 수 있습니다.

- \(2\) 라우터는 패킷을 강제로 폐기해야 하며 높은 신뢰성 비트가 설정된 패킷 폐기를 방지하려고 시도할 수 있습니다.

- 이러한 아이디어는 \[INTERNET:17\]에서 더 자세히 탐색되었지만 아직 이 영역에서 요구 사항을 충족할 수 있는 체계에 대한 경험이 충분하지 않습니다.

---
### **5.3.3 IP Precedence**

- 이 섹션에서는 라우터의 IP 우선 순위 필드를 적절하게 처리하기 위한 요구 사항과 지침을 지정합니다. 우선 순위는 다양한 트래픽 흐름의 상대적 중요성을 기반으로 네트워크에서 리소스를 할당하는 방식입니다. IP 사양은 다양한 유형의 트래픽에 대해 이 필드에 사용되는 특정 값을 정의합니다.

- 라우터의 우선순위 처리를 위한 기본 메커니즘은 우선순위 큐 서비스와 우선순위 기반 혼잡 제어 및 링크 계층 우선순위 기능 선택을 모두 포함하는 우선적 자원 할당입니다. 라우터는 또한 자신이 발생하는 라우팅, 관리 및 제어 트래픽에 대한 IP 우선순위를 선택합니다. IP 우선 순위 및 구현에 대한 보다 광범위한 논의는 \[앞으로:6\]을 참조하세요.

- 이 섹션에서 설명한 대로 우선 순위 대기열 서비스에는 전달 프로세스용 대기열과 나가는 링크용 대기열이 포함되지만 이에 국한되지는 않습니다. 다음과 같이 의도됩니다.

- 우선 순위를 지원하는 라우터는 패킷 버퍼나 링크 계층 연결과 같은 유한 자원 할당과 관련된 처리 지점에서 우선 순위 표시를 사용해야 합니다. 이러한 점의 집합은 구현에 따라 다릅니다.

논의

- 우선순위 필드는 원래 대규모 트래픽 급증이나 네트워크에 대한 큰 손상이 내재된 위협으로 간주되는 DOD 시스템에서 사용하기 위해 제공되었지만 많은 비군사적 IP 네트워크에 유용한 응용 프로그램이 있습니다. 최근 몇 년 동안 네트워크의 트래픽 처리 용량이 크게 증가했지만 사용자의 트래픽 생성 능력도 증가하여 네트워크 과부하 상황이 여전히 발생하는 경우가 있습니다. IP 기반 라우팅 및 관리 프로토콜이 인터넷의 성공적인 운영에 더욱 중요해졌기 때문에 과부하는 네트워크에 두 가지 추가 위험을 초래합니다.

- \(1\) 지연이 높으면 라우팅 프로토콜 패킷이 손실될 수 있습니다. 이로 인해 라우팅 프로토콜이 토폴로지 변경 사항을 잘못 추론하고 이 잘못된 정보를 다른 라우터에 전파할 수 있습니다. 이로 인해 경로가 진동할 수 있을 뿐만 아니라 다른 라우터에 추가적인 처리 부담이 가해질 수도 있습니다.

- \(2\) 높은 지연은 과부하 상태를 발생시킨 네트워크 문제를 분석하고 수정하거나 완화하기 위한 네트워크 관리 도구의 사용을 방해할 수 있습니다.

- 우선순위 메커니즘을 구현하고 적절하게 사용하면 이러한 문제가 모두 완화됩니다.

---
#### **5.3.3.1 Precedence-Ordered Queue Service**

라우터는 우선순위 대기열 서비스를 구현해야 합니다\(SHOULD\). 우선순위 대기열 서비스는 \(논리적\) 링크의 출력을 위해 패킷이 선택되면 해당 링크에 대해 대기열에 있는 가장 높은 우선순위의 패킷이 전송된다는 것을 의미합니다. 우선순위 대기열 서비스를 구현하는 라우터에는 인터넷 계층에서 우선순위 대기열 서비스를 억제하는 구성 옵션도 있어야 합니다.\(SHOULD, MUST\)

모든 라우터는 엄격한 우선 순위 이외의 다른 정책 기반 처리량 관리 절차를 구현할 수 있지만 이를 억제하도록 구성할 수 있어야 합니다\(즉, 엄격한 순서 사용\).\(MUST\)

섹션 \[5.3.6\]에 자세히 설명된 것처럼 우선순위 큐 서비스를 구현하는 라우터는 혼잡 제어 목적으로 높은 우선순위 패킷을 폐기하기 전에 낮은 우선순위 패킷을 폐기합니다.

선점\(패킷 처리 또는 전송 중단\)은 인터넷 계층의 기능으로 간주되지 않습니다. 다른 계층의 일부 프로토콜은 선점 기능을 제공할 수 있습니다.

---
#### **5.3.3.2 Lower Layer Precedence Mappings**

우선순위 큐잉을 구현하는 라우터는 반드시 구현해야 하며, 다른 라우터는 하위 계층 우선순위 매핑을 구현해야 합니다.\(MUST\)

하위 계층 우선순위 매핑을 구현하는 라우터:

o 그러한 기능이 정의된 링크 레이어에 대한 링크 레이어 우선순위 메커니즘에 IP 우선순위를 매핑할 수 있어야 합니다.\(MUST\)

o 모든 IP 트래픽에 대해 링크 계층의 기본 우선순위 처리를 선택하는 구성 옵션이 있어야 합니다.\(MUST\)

o 각 인터페이스의 링크 계층 우선순위 값에 대한 IP 우선순위 값의 특정 비표준 매핑을 구성할 수 있어야 합니다.\(SHOULD\)

논의

- 일부 연구에서는 일부 링크 계층 프로토콜의 우선 순위 기능의 작동 가능성에 대해 의문을 제기하고 일부 네트워크에는 링크 계층 우선 순위 메커니즘의 구현이 잘못되었을 수 있습니다. 그러한 문제가 네트워크에 나타날 경우를 대비하여 탈출 메커니즘을 제공하는 것이 현명한 것 같습니다.

- 한편, 멀티미디어 대역폭 예약이나 저지연 서비스 등 특수 서비스 구현을 위해 새로운 큐잉 전략을 활용하는 제안도 있다. 특별 서비스와 이를 지원하는 대기열 전략은 현재 연구 주제이며 표준화 과정에 있습니다.

- 구현자는 DOD 네트워크에서 사용되는 TCP/IP 시스템에 대한 DOD 정책에 따라 IP 우선순위의 올바른 링크 계층 매핑이 필요하다는 점을 고려할 수 있습니다. 이러한 요구 사항은 모든 사용자에게 더 나은 인터넷 서비스를 제공하기 위해 우선 순위 기능의 사용을 장려\(강제하지는 않음\)하기 위한 것이므로, 우선 순위 대기열 서비스를 지원하는 라우터는 요청된 서비스 유형에 관계없이 기본적으로 엄격한 우선 순위를 유지해야 합니다. .

---
#### **5.3.3.3 Precedence Handling For All Routers**

라우터\(우선순위 대기열 서비스 사용 여부\):

\(1\) 관리상 다르게 구성되지 않는 한 모든 우선 순위 수준의 수신 트래픽을 정상적으로 수락하고 처리해야 합니다.\(MUST\)

\(2\) 특정 트래픽 소스별로 우선 순위 수준의 사용을 관리적으로 제한하기 위해 유효성 검사 필터를 구현할 수 있습니다. 제공된 경우 이 필터는 목적지 도달 불가, 리디렉션, 시간 초과 및 매개변수 문제와 같은 종류의 ICMP 오류 메시지를 필터링하거나 차단해서는 안 됩니다. 이 필터가 제공되면 이 필터에도 주소별 패킷 필터링에 필요한 절차가 필요합니다.\(MAY, MUST NOT\)

논의

- 특정 소스/대상 IP 주소 쌍, 특정 프로토콜, 특정 포트 등에 우선순위 필터링이 적용되어야 합니다.

코드 14가 있는 ICMP 목적지 도달 불가 메시지는 구성 선택에 의해 억제되지 않는 한 검증 필터에 의해 패킷이 삭제될 때 전송되어야 합니다.\(SHOULD\)

\(3\) 라우터가 지정된 수준 미만의 우선순위로 트래픽을 거부하거나 삭제하도록 설정할 수 있는 차단 기능을 구현할 수 있습니다. 이 기능은 관리 작업이나 일부 구현 종속 휴리스틱에 의해 활성화될 수 있지만 사람의 개입 없이 작동하는 휴리스틱 메커니즘을 비활성화하는 구성 옵션이 있어야 합니다. 코드 15가 있는 ICMP 목적지 도달 불가 메시지는 구성 선택에 의해 억제되지 않는 한 차단 기능에 의해 패킷이 삭제될 때 전송되어야 합니다.\(MAY, MUST, SHOULD\)

- 라우터는 우선순위 차단으로 인해 IP 우선순위가 6\(인터넷 제어\) 또는 7\(네트워크 제어\)인 데이터그램 전달을 거부해서는 안 됩니다. 그러나 우선순위가 높은 트래픽을 필터링하기 위해 우선순위 차단과 함께 다른 기준을 사용할 수도 있습니다.\(MUST NOT\)

논의

- 무제한 우선순위 차단으로 인해 라우팅 및 제어 트래픽이 의도치 않게 차단될 수 있습니다. 일반적인 경우 호스트 트래픽은 5\(CRITIC/ECP\) 이하의 값으로 제한되어야 합니다. 이는 필수 사항이 아니며 특정 시스템에서는 정확하지 않을 수 있습니다.

\(4\) 발생하지 않은 패킷의 우선순위 설정을 변경해서는 안 됩니다.\(MUST NOT\)

\(5\) 지원되는 각 라우팅 또는 관리 프로토콜에 사용할 고유한 우선 순위 값을 구성할 수 있어야 합니다\(사용해야 하는 우선 순위 값을 지정하는 OSPF와 같은 프로토콜은 제외\).\(SHOULD\)

\(6\) 각 피어 주소에 대해 독립적으로 라우팅 또는 관리 트래픽 우선 순위 값을 구성할 수 있습니다.\(MAY\)

\(7\) 제공된 경우 링크 계층 우선순위 관련 오류 표시에 적절하게 응답해야 합니다. 구성 선택에 의해 억제되지 않는 한, 우선 순위 관련 조건으로 인해 링크가 패킷을 받아들일 수 없기 때문에 패킷이 삭제될 때 코드 15가 포함된 ICMP 대상 도달 불가 메시지가 전송되어야 합니다.\(MUST, SHOULD\)

논의

- \(3\)에서 설명한 우선순위 차단 메커니즘은 다소 논란의 여지가 있다. 컷오프의 영향을 받는 영역의 토폴로지 위치에 따라 전송 트래픽은 라우팅 프로토콜에 의해 컷오프 영역으로 전달될 수 있으며, 여기서 전송 트래픽은 삭제됩니다. 이는 단절의 영향을 받지 않는 다른 경로가 통신 지점 사이에 존재하는 경우에만 문제가 됩니다. 이 문제를 방지하기 위해 제안된 방법에는 과부하 조건에서도 모든 우선 순위 수준에 최소 대역폭을 제공하거나 라우팅 프로토콜에서 차단 정보를 전파하는 것이 포함됩니다. 이 문제에 대해 널리 받아들여지고 구현된 해결책이 없는 경우, 대중교통 네트워크에서 차단 메커니즘을 활성화할 때 큰 주의가 권장됩니다.

- 전송 계층 릴레이는 위의 \(4\)에서 금지된 기능을 합법적으로 제공할 수 있습니다. 우선 순위 수준을 변경하면 TCP 및 기타 프로토콜과 미묘한 상호 작용이 발생할 수 있습니다. 올바른 디자인은 중요한 작업입니다.

- \(5\)와 \(6\)\(그리고 섹션 \[4.3.2\]의 ICMP 메시지의 IP 우선 순위에 대한 논의\)의 의도는 이 라우터가 IP 우선 순위 비트에 대해 작동하는지 여부에 관계없이 IP 우선 순위 비트를 적절하게 설정해야 한다는 것입니다. 다른 방법으로. 향후 라우팅 프로토콜 및 네트워크 관리 프로토콜 사양에서는 해당 프로토콜에서 보낸 메시지에 대해 IP 우선 순위를 설정하는 방법이 지정될 것으로 예상됩니다.

- \(7\)에 대한 적절한 응답은 사용 중인 링크 계층 프로토콜에 따라 다릅니다. 일반적으로 라우터는 일정 기간 동안 해당 대상으로 공격적인 트래픽을 보내려는 시도를 중지해야 합니다.

- 코드 15\(요청된 우선순위에 대해 서비스를 사용할 수 없음\)와 함께 ICMP 목적지 도달 불가 메시지를 트래픽 소스에 반환해야 합니다. 또한 한동안 선점된 링크 계층 연결을 다시 설정하려고 시도해서는 안 됩니다.

---
### **5.3.4 Forwarding of Link Layer Broadcasts**

대부분의 링크 계층 프로토콜\(PPP 제외\)에서 IP 패킷을 캡슐화하면 수신기는 링크 계층 프로토콜 헤더\(가장 일반적으로 링크 계층 대상 주소\)를 검사하여 브로드캐스트와 멀티캐스트를 유니캐스트와 구별할 수 있습니다. 링크 계층 브로드캐스트를 참조하는 이 섹션의 규칙은 브로드캐스트를 구별할 수 있는 링크 계층 프로토콜에만 적용됩니다. 마찬가지로 링크 계층 멀티캐스트를 참조하는 규칙은 멀티캐스트를 구별할 수 있는 링크 계층 프로토콜에만 적용됩니다.

라우터는 IP 멀티캐스트 주소로 전달되지 않는 한 링크 계층 브로드캐스트로 수신한 패킷을 전달해서는 안 됩니다. 후자의 경우 효과적인 멀티캐스트 서비스가 부족하여 링크 계층 브로드캐스트가 사용되었다고 추정할 수 있습니다.\(MUST NOT\)

라우터는 패킷의 대상 주소가 IP 멀티캐스트 주소가 아닌 한 링크 계층 멀티캐스트로 수신한 모든 패킷을 전달해서는 안 됩니다.\(MUST NOT\)

라우터는 링크 계층 브로드캐스트를 통해 수신되었지만 IP 멀티캐스트 또는 IP 브로드캐스트 대상 주소를 지정하지 않은 패킷을 자동으로 폐기해야 합니다\(SHOULD\).\(SHOULD\)

라우터가 링크 계층 브로드캐스트로 패킷을 보낼 때 IP 대상 주소는 합법적인 IP 브로드캐스트 또는 IP 멀티캐스트 주소여야 합니다.\(MUST\)

---
### **5.3.5 Forwarding of Internet Layer Broadcasts**

IP 브로드캐스트 주소에는 두 가지 주요 유형이 있습니다. 한정방송과 연출방송. 또한 직접 브로드캐스트에는 세 가지 하위 유형이 있습니다. 지정된 네트워크 접두사로 전달되는 브로드캐스트, 지정된 하위 네트워크로 전달되는 브로드캐스트, 지정된 네트워크의 모든 서브넷으로 전달되는 브로드캐스트입니다. 라우터에 의한 브로드캐스트 분류는 브로드캐스트 주소와 대상 네트워크의 서브넷 구조에 대한 라우터의 이해\(있는 경우\)에 따라 달라집니다. 동일한 브로드캐스트는 라우터에 따라 다르게 분류됩니다.

제한된 IP 브로드캐스트 주소는 모두 1인 것으로 정의됩니다: { -1, -1 } 또는 255.255.255.255.

네트워크 접두사 지향 브로드캐스트는 IP 주소의 네트워크 접두사와 올원의 로컬 부분 또는 {<Network-prefix\>, -1 }로 구성됩니다. 예를 들어 클래스 A 넷 브로드캐스트 주소는 net.255.255.255이고 클래스 B 넷 브로드캐스트 주소는 net.net.255.255이며 클래스 C 넷 브로드캐스트 주소는 net.net.net.255입니다. 여기서 net은 네트워크 주소.

all-subnets-directed-broadcast는 CIDR 환경에서 잘 정의되지 않았으며 이 메모의 버전 1에서는 더 이상 사용되지 않습니다.

섹션 \[4.2.3.1\]에 설명된 대로 라우터는 특정 비표준 IP 브로드캐스트 주소를 만날 수 있습니다.

o 0.0.0.0은 제한된 브로드캐스트 주소의 더 이상 사용되지 않는 형식입니다.

o { <Network-prefix\>, 0 }은 네트워크 접두사 지정 브로드캐스트 주소의 더 이상 사용되지 않는 형식입니다.

해당 섹션에 설명된 대로 이러한 주소로 주소가 지정된 패킷은 자동으로 폐기되어야 하지만, 그렇지 않은 경우 설명된 브로드캐스트 주소의 오래되지 않은 형식으로 주소가 지정된 패킷에 적용되는 동일한 규칙에 따라 처리되어야 합니다. 위에. 이러한 규칙은 다음 몇 섹션에서 설명됩니다.\(MUST\)

---
#### **5.3.5.1 Limited Broadcasts**

제한된 방송은 전달되어서는 안 됩니다. 제한된 방송은 폐기되어서는 안 됩니다. 제한된 방송으로 충분할 경우 직접 방송 대신 제한된 방송을 전송할 수 있으며 전송해야 합니다.\(MUST NOT, MUST NOT, SHOULD\)

논의

- 일부 라우터에는 다른 서버에 요청\(유니캐스트 또는 직접 브로드캐스트\)을 다시 보내는 방식으로 작동하는 UDP 서버가 포함되어 있습니다. 이 요구 사항은 그러한 서버를 금지하는 것으로 해석되어서는 안 됩니다. 그러나 이러한 서버를 잘못 구성하면 쉽게 패킷 루핑이 발생할 수 있습니다. 따라서 이러한 서버의 공급자는 설정을 주의 깊게 문서화하고 전송되는 패킷의 TTL을 주의 깊게 고려하는 것이 좋습니다.

---
#### **5.3.5.2 Directed Broadcasts**

라우터는 원격 네트워크 또는 연결된 비서브넷 네트워크를 대상으로 하는 모든 유효한 지향 브로드캐스트를 네트워크 접두사 지향 브로드캐스트로 분류해야 합니다. CIDR의 관점에서 이러한 주소는 네트워크 접두사 내의 호스트 주소로 나타납니다. 우리는 그러한 네트워크 접두어의 호스트 부분 검사를 배제합니다. 경로가 있고 우선 정책이 없으면 라우터는 네트워크 접두사 지정 브로드캐스트를 전달해야 합니다. 네트워크 접두사 지향 브로드캐스트\(MAY\)\(MUST, MUST, MAY\)

전송됩니다.

라우터에는 인터페이스에서 네트워크 접두사 지향 브로드캐스트 수신을 비활성화하는 옵션이 있을 수 있으며\(MAY\) 네트워크 접두사 지향 브로드캐스트 전달을 비활성화하는 옵션이 있어야 합니다\(MUST\). 이러한 옵션은 기본적으로 네트워크 접두사 지정 브로드캐스트의 수신 및 전달을 허용해야 합니다\(MUST\).\(MUST, MUST\)

논의

- 직접 방송을 전달하느냐 안 전달하느냐에 대한 논란이 있어왔습니다. 이 메모에서 우리는 목적지 네트워크 접두사에 대한 라우터의 지식에 따라 전달 결정을 내렸습니다. 라우터는 이러한 지식 없이는 메시지가 유니캐스트인지 아니면 직접 브로드캐스트인지 결정할 수 없습니다. 메시지 전달 여부 결정은 정의에 따라 마지막 홉 라우터에서만 가능합니다.

---
#### **5.3.5.3 All-subnets-directed Broadcasts**

이 메모의 첫 번째 버전에서는 기존 네트워크 번호의 모든 서브넷에 직접 방송을 배포하는 알고리즘을 설명했습니다. 이 알고리즘은 "깨진" 것으로 명시되었으며 특정 실패 사례가 지정되었습니다.

전통적인 IP 네트워크 번호가 의미가 없는 CIDR 라우팅 도메인에서는 모든 서브넷 지향 브로드캐스트 개념도 의미가 없습니다. 실무 그룹이 아는 바로는 이 시설은 결코 구현되거나 배치되지 않았으며 이제 역사의 쓰레기통으로 옮겨졌습니다.

---
#### **5.3.5.4  Subnet-directed Broadcasts**

이 메모의 첫 번째 버전에는 서브넷 지향 브로드캐스트를 처리하는 절차가 자세히 설명되어 있습니다. CIDR 라우팅 도메인에서 이는 net-dlected-broadcast와 구별할 수 없습니다. 따라서 두 개는 섹션 \[5.3.5.2 직접 방송\]에서 함께 처리되며 네트워크 접두사 직접 방송으로 보아야 합니다.

---
### **5.3.6 Congestion Control**

네트워크의 정체는 리소스\(일반적으로 대역폭 또는 CPU 시간\)에 대한 수요가 용량을 초과하는 조건으로 느슨하게 정의됩니다. 혼잡 회피는 수요가 용량을 초과하는 것을 방지하려고 시도하는 반면, 혼잡 복구는 작동 상태를 복원하려고 시도합니다. 라우터가 이 두 메커니즘 모두에 기여하는 것이 가능합니다. 문제를 연구하는데 많은 노력을 기울였습니다. 독자는 작업에 대한 조사를 위해 \[FORWARD:2\]를 읽어 보시기 바랍니다. 해당 주제에 관한 중요한 논문은 다음과 같습니다.

\[앞으로:3\], \[앞으로:4\], \[앞으로:5\], \[앞으로:10\], \[앞으로:11\], \[앞으로:12\], \[앞으로:13\], \[앞으로:14\] 및 \[ 인터넷:10\] 등이 있습니다.

\[FORWARD:5\]에 설명된 것과 같이 호스트가 합리적인 혼잡 정책을 사용할 때 라우터가 최대 순간 수요를 처리하기 위해 사용할 수 있어야 하는 스토리지 양은 링크 대역폭과 흐름의 경로 지연을 곱한 함수입니다. 링크를 사용하므로 이 대역폭\*지연 제품이 증가함에 따라 저장 공간도 증가해야 합니다. 저장 용량과 폐기 확률을 연관시키는 정확한 함수는 알려져 있지 않습니다.

라우터가 저장 용량을 초과하는 패킷을 수신하면 \(법령이 아닌 정의에 따라\) 해당 패킷이나 다른 패킷을 폐기해야 합니다. 어떤 패킷을 폐기할지에 대해서는 많은 연구 주제가 있지만 불행히도 지금까지 합의가 거의 이루어지지 않았습니다. 현재까지 가장 좋은 지혜는 링크를 가장 많이 사용하는 데이터 스트림에서 패킷을 폐기하는 것입니다. 그러나 트래픽의 우선 순위, 활성 대역폭 예약 및 해당 패킷 선택과 관련된 복잡성을 포함하여 다양한 추가 요소가 관련될 수 있습니다.

라우터는 방금 수신한 패킷을 삭제할 수 있습니다. 이는 가장 단순하지만 최선의 정책은 아닙니다. 이상적으로는 적용 가능한 서비스 품질 정책에서 허용하는 경우 라우터는 링크를 가장 심하게 남용하는 세션 중 하나에서 패킷을 선택해야 합니다. FIFO 대기열을 사용하는 데이터그램 환경에서 권장되는 정책은 대기열에서 무작위로 선택된 패킷을 삭제하는 것입니다\(\[FORWARD:5\] 참조\). 공정한 대기열을 사용하는 라우터에서 동등한 알고리즘은 가장 긴 대기열 또는 가장 큰 가상 시간을 사용하는 대기열에서 삭제하는 것입니다\(\[FORWARD:13\] 참조\). 라우터는 이러한 알고리즘을 사용하여 삭제할 패킷을 결정할 수 있습니다.\(MAY, MAY\)

라우터가 적격 패킷 풀에서 삭제할 패킷을 선택하는 폐기 정책\(예: Random Drop\)을 구현하는 경우:

o 우선순위 대기열 서비스인 경우\(섹션에 설명됨\)

- \[5.3.3.1\]\)이 구현되고 활성화된 경우, 라우터는 폐기되지 않는 패킷보다 IP 우선순위가 높은 패킷을 폐기해서는 안 됩니다.\(MUST NOT\)

o 라우터는 이전 규칙을 위반하는 경우를 제외하고 IP 헤더가 신뢰성 최대화 TOS를 요청하는 패킷을 보호할 수 있습니다.\(MAY\)

o 라우터는 데이터그램의 조각을 삭제하면 데이터그램의 모든 조각이 재전송되도록 하여 혼잡을 증가시킬 수 있다는 이론에 따라 조각화된 IP 패킷을 보호할 수 있습니다.\(MAY\)

```text
      source.
```

o 라우팅 교란이나 관리 기능 중단을 방지하기 위해 라우터는 라우팅 제어, 링크 제어 또는 네트워크 관리에 사용되는 패킷이 폐기되지 않도록 보호할 수 있습니다. 전용 라우터\(예: 범용 호스트, 터미널 서버 등이 아닌 라우터\)는 소스 또는 대상이 라우터 자체인 패킷을 보호하여 이 규칙에 근접할 수 있습니다.\(MAY\)

혼잡 제어의 고급 방법에는 공정성 개념이 포함되므로 패킷 손실로 인해 불이익을 받는 '사용자'가 혼잡에 가장 큰 기여를 한 사람이 됩니다. 대역폭 혼잡 제어를 처리하기 위해 어떤 메커니즘이 구현되더라도, 라우터가 CPU 혼잡을 겪지 않도록 소비되는 CPU 노력을 충분히 작게 하는 것이 중요합니다.

섹션 \[4.3.3.3\]에 설명된 대로 이 문서는 라우터가 폐기 중인 패킷의 발신자에게 Source Quench를 전송해서는 안 된다고 권장합니다. ICMP Source Quench는 매우 약한 메커니즘이므로 라우터가 이를 전송할 필요가 없으며 호스트 소프트웨어는 이를 정체 표시기로만 사용해서는 안 됩니다.\(SHOULD NOT\)

---
### **5.3.7 Martian Address Filtering**

IP 소스 주소는 4.2.2.11 또는 5.3.7에 정의된 특수 IP 주소이거나 유니캐스트 주소가 아닌 경우 유효하지 않습니다.

IP 대상 주소는 4.2.3.1에서 불법 대상으로 정의된 주소 중 하나이거나 클래스 E 주소\(255.255.255.255 제외\)인 경우 유효하지 않습니다.

라우터는 유효하지 않은 IP 소스 주소 또는 네트워크 0의 소스 주소를 가진 패킷을 전달해서는 안 됩니다. 라우터는 루프백 인터페이스를 통한 경우를 제외하고 네트워크 127의 소스 주소를 가진 모든 패킷을 전달해서는 안 됩니다. 라우터는 다음을 가질 수 있습니다. 네트워크 관리자가 이러한 검사를 비활성화할 수 있도록 하는 스위치입니다. 그러한 스위치가 제공되면 기본적으로 검사를 수행해야 합니다\(MUST\).\(SHOULD NOT, SHOULD NOT, MAY, MUST\)

라우터는 유효하지 않은 IP 대상 주소 또는 네트워크 0의 대상 주소가 있는 패킷을 전달해서는 안 됩니다. 라우터는 루프백 인터페이스를 통하는 경우를 제외하고 네트워크 127의 대상 주소가 있는 모든 패킷을 전달해서는 안 됩니다. 라우터는 다음을 가질 수 있습니다. 네트워크 관리자가 이러한 검사를 비활성화할 수 있도록 하는 스위치입니다. 그러한 스위치가 제공되면 기본적으로 검사를 수행해야 합니다\(MUST\).\(SHOULD NOT, SHOULD NOT, MAY, MUST\)

라우터가 이러한 규칙으로 인해 패킷을 폐기하는 경우 최소한 IP 소스 주소, IP 대상 주소를 기록해야 합니다.\(SHOULD\)

문제는 소스 주소, 패킷이 수신된 물리적 인터페이스, 패킷이 수신된 호스트 또는 라우터의 링크 계층 주소에 있었습니다.

---
### **5.3.8 Source Address Validation**

라우터는 패킷의 소스 주소와 패킷이 수신된 논리적 인터페이스에 대한 전달 테이블의 비교를 기반으로 트래픽을 필터링하는 기능을 구현해야 합니다. 이 필터링이 활성화된 경우, 패킷이 수신된 인터페이스가 소스 주소에 포함된 주소에 도달하기 위해 패킷을 전달하는 인터페이스가 아닌 경우 라우터는 패킷을 자동으로 폐기해야 합니다. 간단히 말하면, 라우터가 특정 인터페이스를 통해 이 주소가 포함된 패킷을 라우팅하지 않는 경우 해당 주소가 이 인터페이스에서 읽은 패킷에 소스 주소로 나타나면 해당 주소를 믿어서는 안 됩니다.\(SHOULD, MUST\)

이 기능이 구현되면 기본적으로 비활성화되어야 합니다.\(MUST\)

논의

- 이 기능은 일부 상황에서 유용한 보안 개선을 제공할 수 있지만 경로가 비대칭인 상황에서는 유효한 패킷을 잘못 삭제할 수 있습니다.

---
### **5.3.9 Packet Filtering and Access Lists**

보안을 제공하거나 네트워크 일부를 통해 트래픽을 제한하는 수단으로 라우터는 선택적으로 패킷을 전달\(또는 필터링\)하는 기능을 제공해야 합니다. 이 기능이 제공되는 경우 패킷 필터링은 모든 패킷을 전달하거나 소스 및 대상 접두사를 기반으로 선택적으로 전달하도록 구성 가능해야 하며 다른 메시지 속성을 필터링할 수 있습니다. 각 소스 및 대상 주소는 임의의 접두사 길이 지정을 허용해야 합니다\(SHOULD\).\(SHOULD, SHOULD, SHOULD\)

논의

- 이 기능은 경계 외부의 시스템이 경계 내부의 시스템과 특정 프로토콜을 교환하는 것이 허용되지 않거나 통신할 수 있는 시스템이 제한되는 개인 정보 보호 조치를 제공할 수 있습니다. 또한 경계 외부의 시스템이 경계 내부의 시스템으로 가장하고 해당 시스템과의 세션을 모방하는 특정 종류의 보안 위반을 방지하는 데도 도움이 될 수 있습니다.

지원되는 경우 라우터는 다음 중 하나를 허용하도록 구성되어야 합니다.\(SHOULD\)

o 포함 목록 - 전달될 메시지 정의 목록의 지정 또는

o 제외 목록 - 전달되지 않을 메시지 정의 목록의 사양입니다.

이 맥락에서 "메시지 정의"는 소스 및 대상 네트워크 접두사를 지정하며 IP 프로토콜 유형 또는 TCP 포트 번호와 같은 기타 식별 정보를 포함할 수 있습니다.

라우터는 포함 목록이나 제외 목록 지정 또는 기타 동등한 제어 중에서 선택할 수 있는 구성 스위치를 제공할 수 있습니다.\(MAY\)

모든 주소와 일치하는 값\(예: 키워드 any, 마스크가 모두 0인 주소 또는 길이가 0인 네트워크 접두사\)은 소스 및/또는 대상 주소로 허용되어야 합니다.\(MUST\)

주소 쌍 외에도 라우터는 전송 및/또는 애플리케이션 프로토콜과 소스 및 대상 포트의 모든 조합을 지정할 수 있습니다.\(MAY\)

라우터는 패킷이 자동으로 폐기되도록 허용해야 합니다\(즉, ICMP 오류 메시지가 전송되지 않고 폐기됨\).\(MUST\)

라우터는 패킷이 폐기될 때 적절한 ICMP 도달 불가능 메시지가 전송되도록 허용해야 합니다\(SHOULD\). ICMP 메시지는 대상에 도달할 수 없는 이유로 통신 관리상 금지\(코드 13\)를 지정해야 합니다.\(SHOULD, SHOULD\)

라우터는 지정을 허용하는 주소 쌍, 프로토콜 유형 및 포트의 각 조합에 대해 ICMP 대상 도달 불가능 메시지\(코드 13\) 전송을 허용해야 합니다.\(SHOULD\)

라우터는 전달되지 않은 패킷의 개수를 계산하고 선택적으로 로깅을 허용해야 합니다.\(SHOULD\)

---
### **5.3.10 Multicast Routing**

IP 라우터는 정적 멀티캐스트 경로 또는 멀티캐스트 라우팅 프로토콜\(예: DVMRP \[ROUTE:9\]\)에 의해 동적으로 결정된 경로를 기반으로 IP 멀티캐스트 패킷의 전달을 지원해야 합니다. IP 멀티캐스트 패킷을 전달하는 라우터를 멀티캐스트 라우터라고 합니다.\(SHOULD\)

---
### **5.3.11 Controls on Forwarding**

각 물리적 인터페이스에 대해 라우터에는 해당 인터페이스에서 전달이 활성화되는지 여부를 지정하는 구성 옵션이 있어야 합니다. 인터페이스 전달이 비활성화되면 라우터는 다음을 수행합니다.\(SHOULD\)

o 해당 인터페이스에서 수신되었지만 라우터로 주소가 지정되지 않은 모든 패킷을 자동으로 폐기해야 합니다.\(MUST\)

o 라우터에서 시작된 데이터그램을 제외하고 해당 인터페이스 밖으로 패킷을 보내면 안 됩니다.\(MUST NOT\)

o 인터페이스를 통한 경로의 가용성을 라우팅 프로토콜을 통해 발표해서는 안 됩니다.\(MUST NOT\)

논의

- 이 기능을 사용하면 네트워크 관리자는 기본적으로 인터페이스를 끌 수 있지만 네트워크 관리에는 액세스할 수 있습니다.

- 이상적으로는 이 제어가 물리적 인터페이스보다는 논리적 인터페이스에 적용됩니다. 논리적 인터페이스와 물리적 인터페이스 간의 일대일 대응 없이 패킷이 도착하는 논리적 인터페이스를 라우터에서 확인할 수 있는 알려진 방법이 없기 때문에 그럴 수 없습니다.

---
### **5.3.12 State Changes**

라우터 작동 중에 인터페이스가 실패하거나 수동으로 비활성화되거나 라우터에서 사용할 수 있게 될 수 있습니다. 마찬가지로 특정 인터페이스나 전체 라우터에 대해 전달이 비활성화되거나 \(재\)활성화될 수 있습니다. 이러한 전환은 일반적으로 흔하지 않지만 라우터가 이를 올바르게 처리하는 것이 중요합니다.

---
#### **5.3.12.1 When a Router Ceases Forwarding**

라우터가 전달을 중단하면 제3자 경로를 제외한 모든 경로 광고를 중지해야 합니다. 라우팅 도메인의 다른 라우터로부터 계속해서 경로를 수신하고 사용할 수 있습니다. 전달 데이터베이스가 유지되는 경우 라우터는 전달 데이터베이스의 경로 타이밍을 중단해서는 안 됩니다. 다른 라우터로부터 수신된 경로가 기억되는 경우 라우터는 기억된 경로의 타이밍을 중단해서는 안 됩니다. 전달이 활성화된 경우와 마찬가지로 전달이 비활성화된 동안 타이머가 만료되는 모든 경로를 삭제해야 합니다.\(MUST, MAY, MUST NOT, MUST NOT, MUST\)

논의

- 라우터가 전달을 중단하면 본질적으로 라우터로서의 역할이 중단됩니다. 이는 여전히 호스트이며 호스트 요구 사항 \[소개:2\]의 모든 요구 사항을 따라야 합니다. 그러나 라우터는 여전히 하나 이상의 라우팅 도메인의 수동 구성원일 수 있습니다. 따라서 라우팅 도메인의 다른 라우터를 수신하여 전달 데이터베이스를 유지 관리할 수 있습니다. 그러나 자체적으로 전달을 수행하지 않으므로 전달 데이터베이스의 경로를 광고할 수 없습니다. 이 규칙의 유일한 예외는 라우터가 다음을 사용하는 경로를 광고하는 경우입니다.

- 다른 라우터\(이 라우터는 광고하도록 요청됨\)

라우터는 전달할 수 없는 패킷의 발신자에게 ICMP 대상 도달 불가능\(호스트 도달 불가능\) 메시지를 보낼 수 있습니다. ICMP 리디렉션 메시지를 보내면 안 됩니다.\(MAY, SHOULD NOT\)

논의

- 연결할 수 없는 ICMP 대상\(호스트에 연결할 수 없음\)을 보내는 것은 라우터 작업입니다. 이 메시지는 호스트가 보내서는 안 됩니다. 호스트 규칙에 대한 이러한 예외는 패킷이 가능한 최단 시간 내에 다시 라우팅되고 블랙홀이 방지되도록 허용됩니다.

---
#### **5.3.12.2 When a Router Starts Forwarding**

라우터가 전달을 시작하면 일반적으로 라우팅 정보를 교환하는 모든 라우터에 새로운 라우팅 정보를 신속하게 전송해야 합니다.\(SHOULD\)

---
#### **5.3.12.3 When an Interface Fails or is Disabled**

인터페이스가 실패하거나 비활성화된 경우 라우터는 해당 인터페이스를 사용하는 전달 데이터베이스의 모든 경로 광고를 제거하고 중지해야 합니다. 해당 인터페이스를 사용하는 모든 정적 경로를 비활성화해야 합니다. 동일한 대상 및 TOS에 대한 다른 경로가 라우터에 의해 학습되거나 기억되는 경우 라우터는 최상의 대체 경로를 선택하고 이를 전달 데이터베이스에 추가해야 합니다. 라우터는 인터페이스를 사용할 수 없기 때문에 전달할 수 없는 모든 패킷에 대한 응답으로 ICMP 대상 도달 불가능 또는 ICMP 리디렉션 메시지를 적절하게 보내야 합니다\(SHOULD\).\(MUST, MUST, MUST, SHOULD\)

---
#### **5.3.12.4 When an Interface is Enabled**

사용할 수 없었던 인터페이스를 사용할 수 있게 되면 라우터는 해당 인터페이스를 사용하는 모든 고정 경로를 다시 활성화해야 합니다. 해당 인터페이스를 사용하는 경로가 라우터에 의해 학습된 경우 이러한 경로는 다른 모든 학습된 경로와 함께 평가되어야 하며 라우터는 전달 데이터베이스에 어떤 경로를 배치해야 하는지 결정해야 합니다. 구현자는 이 결정이 내려지는 방법에 대한 추가 정보를 위해 Chapter \[7\], 애플리케이션 계층 - 라우팅 프로토콜을 참조합니다.\(MUST, MUST\)

라우터는 일반적으로 라우팅 정보를 교환하는 모든 라우터에 새로운 라우팅 정보를 신속하게 전송해야 합니다.\(SHOULD\)

---
### **5.3.13 IP Options**

Record Route 및 Timestamp와 같은 여러 옵션에는 패킷을 전달할 때 라우터가 주소를 삽입하는 슬롯이 포함되어 있습니다. 그러나 각 옵션에는 슬롯 수가 제한되어 있으므로 라우터는 해당 주소를 삽입할 수 있는 여유 슬롯이 없다는 것을 알게 될 수 있습니다. 아래 나열된 요구 사항은 라우터가 주소를 삽입할 슬롯이 남아 있지 않은 옵션에 주소를 삽입하도록 요구하는 것으로 해석되어서는 안 됩니다. 섹션 \[5.2.5\]에서는 라우터가 옵션에 삽입할 주소를 선택하는 방법을 설명합니다.

5.3.13.1 인식되지 않은 옵션 전달된 패킷의 인식되지 않은 IP 옵션은 변경되지 않은 채 통과되어야 합니다.\(MUST\)

---
#### **5.3.13.2 Security Option**

일부 환경에서는 모든 패킷에 보안 옵션이 필요합니다. 그러한 요구 사항은 이 문서와 IP 표준 사양의 범위를 벗어납니다. 그러나 \[INTERNET:1\] 및 \[INTERNET:16\]에 설명된 보안 옵션은 더 이상 사용되지 않습니다. 라우터는 \[INTERNET:5\]에 설명된 개정된 보안 옵션을 구현해야 합니다.\(SHOULD\)

논의

- 여러 보안 수준을 갖춘 네트워크에서 사용하도록 고안된 라우터는 IPSO\(RFC-1108\) 레이블을 기반으로 하는 패킷 필터링을 지원해야 합니다. 이 지원을 구현하려면 라우터는 라우터 관리자가 각 인터페이스에서 민감도 하한\(예: 미분류\)과 민감도 상한\(예: 비밀\)을 모두 구성할 수 있도록 허용해야 합니다. 두 가지 제한이 동일한 경우는 일반적이지만 항상 그런 것은 아닙니다\(예: 단일 레벨 인터페이스\). IPSO 필터에 의해 범위를 벗어난 것으로 포착된 패킷은 자동으로 삭제되어야 하며 카운터는 IPSO 레이블 범위를 벗어났기 때문에 삭제된 패킷 수를 기록해야 합니다.

---
#### **5.3.13.3 Stream Identifier Option**

이 옵션은 더 이상 사용되지 않습니다. 라우터가 전달하는 패킷에 스트림 식별자 옵션이 있는 경우 해당 옵션을 무시하고 변경 없이 통과해야 합니다.\(MUST\)

---
#### **5.3.13.4 Source Route Options**

라우터는 전달된 패킷의 소스 경로 옵션에 대한 지원을 구현해야 합니다. 라우터는 활성화되면 모든 소스 라우팅 패킷이 삭제되도록 하는 구성 옵션을 구현할 수 있습니다. 그러나 이러한 옵션은 기본적으로 활성화되어서는 안 됩니다.\(MUST, MAY, MUST NOT\)

논의

- 인터넷을 통해 경로 데이터그램을 소싱하는 기능은 다양한 네트워크 진단 도구에 중요합니다. 그러나 소스 라우팅은 네트워크 내에서 관리 및 보안 제어를 우회하는 데 사용될 수 있습니다. 특히, 패킷 필터링과 같은 다른 방법 대신 관리적 분리를 제공하기 위해 라우팅 테이블을 조작하는 경우 소스 라우팅 패킷을 통해 취약할 수 있습니다.

편집자+댓글

- 패킷 필터링은 소스 라우팅 경로의 마지막 구간에 있는 라우터를 제외한 모든 라우터에 적용되는 경우 소스 라우팅에 의해 무효화될 수도 있습니다. 경로나 패킷 필터 모두 보안을 위한 완전한 솔루션을 구성하지 않습니다.

---
#### **5.3.13.5 Record Route Option**

라우터는 전달된 패킷에서 경로 기록 옵션을 지원해야 합니다.\(MUST\)

라우터는 활성화된 경우 라우터가 전달된 패킷의 경로 기록 옵션을 무시\(즉, 변경 없이 통과\)하도록 하는 구성 옵션을 제공할 수 있습니다. 제공되는 경우 이러한 옵션은 기본적으로 기록 경로를 활성화해야 합니다\(MUST\). 이 옵션은 라우터 자체가 수신한 데이터그램의 경로 기록 옵션 처리에 영향을 주어서는 안 됩니다\(특히 ICMP 에코 요청의 경로 기록 옵션은 여전히 ​​섹션 \[4.3.3.6\]에 따라 처리됩니다\).\(MAY, MUST\)

논의

- Record Route는 네트워크의 토폴로지에 대한 정보를 노출시키기 때문에 보안 문제가 있다고 생각하는 사람들이 있습니다. 따라서 이 문서에서는 이를 비활성화할 수 있습니다.

---
#### **5.3.13.6 Timestamp Option**

라우터는 전달된 패킷에서 타임스탬프 옵션을 지원해야 합니다. 타임스탬프 값은 \[INTRO:2\]에 지정된 규칙을 따라야 합니다.\(MUST, MUST\)

플래그 필드 = 3\(타임스탬프 및 미리 지정된 주소\)인 경우, 미리 지정된 다음 주소가 라우터의 IP 주소와 일치하면 라우터는 타임스탬프를 추가해야 합니다. 미리 지정된 주소가 패킷이 도착한 인터페이스의 주소이거나 패킷이 전송될 인터페이스의 주소일 필요는 없습니다.\(MUST\)

구현

- 타임스탬프 옵션에 포함된 타임스탬프의 유용성을 최대화하려면 삽입된 타임스탬프가 가능한 한 패킷이 도착한 시간과 거의 일치하는 것이 좋습니다.

- 라우터. 라우터에서 시작된 데이터그램의 경우 삽입된 타임스탬프는 데이터그램이 전송을 위해 네트워크 계층으로 전달된 시간과 최대한 가까워야 합니다.

라우터는 플래그 워드가 0\(타임스탬프만\) 또는 1\(타임스탬프 및 IP 주소 등록\)로 설정된 경우 전달된 데이터그램의 타임스탬프 옵션을 무시\(즉, 변경되지 않은 상태로 통과\)하도록 하는 구성 옵션을 제공할 수 있습니다. \). 제공되는 경우 이러한 옵션은 기본적으로 꺼짐으로 설정되어야 합니다\(즉, 라우터는 타임스탬프를 무시하지 않습니다\). 이 옵션은 라우터 자체가 수신한 데이터그램의 타임스탬프 옵션 처리에 영향을 주지 않습니다. 특히 라우터는 라우터가 수신한 데이터그램의 타임스탬프 옵션에 타임스탬프를 삽입하며 ICMP 에코 요청의 타임스탬프 옵션은 섹션에 따라 계속 처리됩니다. \[4.3.3.6\]\).\(MAY, MUST\)

논의

- Record Route 옵션과 마찬가지로 Timestamp 옵션도 네트워크 토폴로지에 대한 정보를 표시할 수 있습니다. 어떤 사람들은 이것이 보안 문제라고 생각합니다.

---
## **6. TRANSPORT LAYER**

라우터는 라우터가 지원하는 응용 프로그램 계층 프로토콜을 지원하는 데 필요한 프로토콜을 제외하고 전송 계층 프로토콜을 구현하는 데 필요하지 않습니다. 실제로 이는 대부분의 라우터가 TCP\(전송 제어 프로토콜\)와 UDP\(사용자 데이터그램 프로토콜\)를 모두 구현한다는 것을 의미합니다.

---
## **6.1 USER DATAGRAM PROTOCOL - UDP**

UDP\(사용자 데이터그램 프로토콜\)는 \[TRANS:1\]에 지정됩니다.

UDP를 구현하는 라우터는 다음을 제외하고 \[INTRO:2\]의 요구 사항을 준수해야 하며 무조건 준수해야 합니다.\(MUST\)

o 이 사양은 다양한 프로토콜 계층 간의 인터페이스를 지정하지 않습니다. 따라서 라우터가 지원하는 응용 프로그램 계층 프로토콜의 적절한 기능을 위해 준수가 필요한 경우를 제외하고 라우터의 인터페이스는 \[INTRO:2\]를 준수할 필요가 없습니다.

o \[INTRO:2\]와 달리 애플리케이션은 UDP 체크섬 생성을 비활성화해서는 안 됩니다.\(SHOULD NOT\)

논의

- 특정 응용 프로그램 프로토콜에서는 수신하는 UDP 데이터그램에 UDP 체크섬이 포함되어야 한다고 요구할 수 있지만 수신된 UDP 데이터그램에 UDP 체크섬이 포함되어야 한다는 일반적인 요구 사항은 없습니다. 물론 수신된 데이터그램에 UDP 체크섬이 있는 경우 체크섬을 확인해야 하며 체크섬이 올바르지 않으면 데이터그램을 폐기해야 합니다.

---
## **6.2 TRANSMISSION CONTROL PROTOCOL - TCP**

TCP\(전송 제어 프로토콜\)는 \[TRANS:2\]에 지정됩니다.

TCP를 구현하는 라우터는 다음을 제외하고 \[INTRO:2\]의 요구 사항을 준수해야 하며 무조건 준수해야 합니다.\(MUST\)

o 이 사양은 다양한 프로토콜 계층 간의 인터페이스를 지정하지 않습니다. 따라서 라우터는 \[INTRO:2\]의 다음 요구 사항을 준수할 필요가 없습니다\(라우터가 지원하는 응용 프로그램 계층 프로토콜의 적절한 기능을 위해 준수가 필요한 경우는 제외\).

푸시 사용: RFC-793 섹션 2.8:

- 수신된 PSH 플래그를 애플리케이션 계층에 전달하는 것은 이제 선택 사항입니다.\(MAY\)

긴급 지침: RFC-793 섹션 3.1:

- TCP는 긴급 포인터를 수신하고 이전에 보류 중인 긴급 데이터가 없었을 때마다 또는 긴급 포인터가 데이터 스트림에서 발전할 때마다 애플리케이션 계층에 비동기식으로 알려야 합니다. 애플리케이션이 연결에서 읽어야 할 긴급 데이터의 양을 알거나 적어도 더 긴급한 데이터를 읽어야 할지 여부를 판단할 수 있는 방법이 있어야 합니다.\(MUST, MUST\)

TCP 연결 실패:

- 애플리케이션은 특정 연결에 대한 R2 값을 설정할 수 있어야 합니다. 예를 들어, 대화형 애플리케이션은 R2를 '무한대'로 설정하여 사용자가 연결을 끊을 시기를 제어할 수 있습니다.\(MUST\)

TCP 멀티호밍:

- 멀티홈 호스트의 애플리케이션이 TCP 연결을 적극적으로 열 때 로컬 IP 주소를 지정하지 않으면 TCP는 \(첫 번째\) SYN을 보내기 전에 IP 계층에 로컬 IP 주소를 선택하도록 요청해야 합니다. 섹션 3.4의 GET\_SRCADDR\(\) 함수를 참조하세요.\(MUST\)

IP 옵션:

- 애플리케이션은 TCP 연결을 적극적으로 열 때 소스 경로를 지정할 수 있어야 하며 이는 데이터그램에서 수신된 소스 경로보다 우선해야 합니다.\(MUST\)

o 비슷한 이유로 라우터는 \[소개:2\]의 요구 사항을 준수할 필요가 없습니다.

o \[INTRO:2\]의 최대 세그먼트 크기 옵션에 관한 요구 사항은 다음과 같이 수정됩니다. MTU 검색의 호스트 부분을 구현하는 라우터\(이 메모의 섹션 \[4.2.3.3\]에서 논의됨\)는 536을 기본값으로 사용합니다. 경로 MTU를 알 수 없는 경우에만 MSS를 보냅니다. 경로 MTU가 알려진 경우 SendMSS의 기본값은 경로 MTU - 40입니다.

o \[INTRO:2\]의 최대 세그먼트 크기 옵션에 관한 요구 사항은 다음과 같이 수정됩니다. ICMP 대상 도달 불가 코드 11 및 12는 추가 소프트 오류 조건입니다. 따라서 이러한 메시지로 인해 TCP가 연결을 중단해서는 안 됩니다.\(MUST NOT\)

논의

- 특히 라우터의 TCP 구현은 \[INTRO:2\]의 다음 요구 사항을 준수해야 한다는 점에 유의해야 합니다.

- o 구성 가능한 TTL을 제공합니다. \[수명: RFC-793 섹션 3.9\]

- o 연결 유지가 사용되는 경우 연결 유지 동작을 구성하기 위한 인터페이스를 제공합니다. \[TCP 연결 유지\]

- o 오류 보고 메커니즘과 이를 관리하는 기능을 제공합니다. \[비동기 보고서\]

- o 서비스 유형 지정. \[서비스 유형\]

- 적용되는 일반적인 패러다임은 특정 인터페이스가 라우터 외부에 표시되면 인터페이스에 대한 모든 요구 사항을 따라야 한다는 것입니다. 예를 들어, 라우터가 텔넷 기능을 제공하는 경우 외부 네트워크로 라우팅될 가능성이 있는 트래픽을 생성하게 됩니다. 따라서 서비스 유형을 올바르게 설정할 수 있어야 합니다. 그렇지 않으면 텔넷 트래픽이 통과하지 못할 수 있습니다.

---
## **7. APPLICATION LAYER - ROUTING PROTOCOLS**
---
## **7.1 INTRODUCTION**

기술적, 관리적, 때로는 정치적인 이유로 인터넷 라우팅 시스템은 내부 라우팅과 외부 라우팅이라는 두 가지 구성 요소로 구성됩니다. 이 문서의 섹션 2.2.4에 정의된 자율 시스템\(AS\)의 개념은 내부에서 외부 라우팅으로 변경되는 라우터 세트를 정의할 수 있으므로 내부 라우팅과 외부 라우팅을 분리하는 데 핵심적인 역할을 합니다. 라우팅이 발생합니다. IP 데이터그램은 목적지에 도달하기 위해 둘 이상의 자율 시스템의 라우터를 통과해야 할 수 있으며, 자율 시스템은 그러한 전달을 허용하기 위해 서로 토폴로지 정보를 제공해야 합니다. 내부 게이트웨이 프로토콜\(IGP\)은 AS 내에서 라우팅 정보를 배포하는 데 사용됩니다\(즉, AS 내 라우팅\). 외부 게이트웨이 프로토콜은 AS 간 라우팅 정보\(즉, AS 간 라우팅\)를 교환하는 데 사용됩니다.

---
### **7.1.1 Routing Security Considerations**

라우팅은 견고성 원칙\(받아들일 때 자유로워야 함\)이 적용되지 않는 몇 안 되는 곳 중 하나입니다. 라우터는 다른 라우팅 시스템에서 라우팅 데이터를 받아들이는 데 상대적으로 의심스러워야 합니다.

라우터는 가장 신뢰할 수 있는 소스부터 가장 신뢰도가 낮은 소스까지 라우팅 정보 소스의 순위를 매기고 가장 신뢰할 수 있는 소스로부터 특정 대상에 대한 라우팅 정보를 먼저 수락하는 기능을 제공해야 합니다. 이는 EGP 및 다양한 내부 라우팅 프로토콜을 사용하는 원래의 코어/스텁 자율 시스템 라우팅 모델에 암시되어 있습니다. 중앙의 신뢰할 수 있는 핵심이 사라지면서 이는 더욱 중요해졌습니다.\(SHOULD\)

라우터는 명백히 유효하지 않은 경로\(예: net 127의 경로\)를 필터링하는 메커니즘을 제공해야 합니다.\(SHOULD\)

라우터는 기본적으로 자신이 사용하거나 신뢰하지 않거나 유효하다고 간주하지 않는 라우팅 데이터를 재배포해서는 안 됩니다. 드문 경우지만 의심스러운 정보를 재배포해야 할 수도 있지만 이는 일부 인간 기관의 직접적인 중재 하에서만 이루어져야 합니다.\(MUST NOT\)

라우터는 누구로부터든 라우팅 데이터를 받아들이는 것에 대해 최소한 약간의 편집증적이어야 하며, 다른 당사자가 제공한 라우팅 정보를 배포할 때는 특히 주의해야 합니다. 구체적인 지침은 아래를 참조하세요.

---
### **7.1.2 Precedence**

특정 라우팅 프로토콜에 대한 사양이 달리 지정하는 경우를 제외하고, 라우터는 자신이 발생하는 라우팅 트래픽을 전달하는 IP 데이터그램에 대한 IP 우선 순위 값을 6\(인터네트워크 제어\)으로 설정해야 합니다.\(SHOULD\)

논의

- 매우 적은 예외가 있는 라우팅 트래픽은 모든 네트워크에서 가장 높은 우선순위 트래픽이어야 합니다. 시스템의 라우팅 트래픽이 통과할 수 없는 경우 다른 방법으로는 통과할 수 없습니다.

---
### **7.1.3 Message Validation**

P2P 인증에는 여러 테스트가 포함됩니다. 과거에는 메시지 비밀번호와 명시적으로 허용되는 이웃 목록을 적용하여 경로 데이터베이스의 견고성을 향상시켰습니다. 라우터는 유효한 라우팅 이웃을 명시적으로 나열할 수 있는 관리 제어를 구현해야 합니다. 라우터는 이를 지원하는 라우팅 프로토콜에 대해 P2P 인증을 구현해야 합니다.\(SHOULD, SHOULD\)

라우터는 소스 주소와 메시지가 수신되는 인터페이스를 기반으로 라우팅 이웃을 검증해야 합니다. 직접 연결된 서브넷의 이웃은 서브넷이 있는 인터페이스나 번호가 지정되지 않은 인터페이스를 통해 라우터와 통신하도록 제한되어야 합니다. 다른 인터페이스에서 수신된 메시지는 자동으로 삭제되어야 합니다.\(SHOULD, SHOULD\)

논의

- 이 기본 테스트를 통해 보안 위반 및 수많은 라우팅 문제를 피할 수 있습니다.

---
## **7.2 INTERIOR GATEWAY PROTOCOLS**
---
### **7.2.1 INTRODUCTION**

IGP\(Interior Gateway Protocol\)는 특정 AS의 다양한 라우터 간에 라우팅 정보를 배포하는 데 사용됩니다. 특정 IGP를 구현하는 데 사용되는 알고리즘과 관계없이 다음 기능을 수행해야 합니다.

\(1\) AS 내부 토폴로지 변경에 대한 신속한 대응

\(2\) 회로 플래핑으로 인해 지속적인 라우팅 업데이트가 발생하지 않도록 하는 메커니즘을 제공합니다.

\(3\) 루프 없는 라우팅으로의 빠른 수렴 제공

```text
   (4) Utilize minimal bandwidth
```

\(5\) 부하 분할이 가능하도록 동일한 비용 경로 제공

\(6\) 라우팅 업데이트 인증 수단 제공

오늘날 인터넷에서 사용되는 현재 IGP는 거리 벡터 또는 링크 상태 알고리즘을 기반으로 하는 특징이 있습니다.

이 섹션에서는 가장 일반적으로 사용되는 IGP와 향후 널리 사용될 수 있는 최근 개발된 프로토콜을 포함하여 여러 IGP에 대해 자세히 설명합니다. AS 내 라우팅에 사용하기 위한 다양한 프로토콜이 인터넷 커뮤니티에 존재합니다.

모든 라우팅 프로토콜\(정적 경로 제외\)을 구현하는 라우터는 OSPF를 구현해야 합니다\(섹션 \[7.2.2\] 참조\). 라우터는 추가 IGP를 구현할 수 있습니다.\(MUST, MAY\)

---
### **7.2.2 OPEN SHORTEST PATH FIRST - OSPF**

SPF\(Shortest Path First\) 기반 라우팅 프로토콜은 Dijkstra의 최단 경로 알고리즘을 기반으로 하는 링크 상태 알고리즘 클래스입니다. SPF 기반 알고리즘은 ARPANET이 시작된 이래로 존재해 왔지만 최근에야 IP와 OSI 커뮤니티 모두에서 인기를 얻었습니다. SPF 기반 시스템에서 각 라우터는 플러딩이라는 프로세스를 통해 전체 토폴로지 데이터베이스를 얻습니다. 플러딩은 정보의 안정적인 전송을 보장합니다. 그런 다음 각 라우터는 데이터베이스에서 SPF 알고리즘을 실행하여 IP 라우팅 테이블을 구축합니다. OSPF 라우팅 프로토콜은 SPF 알고리즘을 구현한 것입니다. 현재 버전인 OSPF 버전 2는 \[ROUTE:1\]에 지정되어 있습니다. OSPF 버전 1을 설명하는 RFC-1131은 더 이상 사용되지 않습니다.

이 메모의 섹션 \[8.3\]을 준수하려면 OSPF를 구현하는 라우터는 OSPF MIB \[MGT:14\]를 구현해야 합니다.\(MUST\)

---
### **7.2.3 INTERMEDIATE SYSTEM TO INTERMEDIATE SYSTEM - DUAL IS-IS**

ANSI\(American National Standards Institute\) X3S3.3 위원회는 도메인 내 라우팅 프로토콜을 정의했습니다. 이 프로토콜의 제목은 중간 시스템 대 중간 시스템 라우팅 교환 프로토콜입니다.

IP 네트워크에 대한 적용은 \[ROUTE:2\]에 정의되어 있으며 이중 IS-IS\(또는 때로는 통합 IS-IS\)라고 합니다. IS-IS는 링크 상태\(SPF\) 라우팅 알고리즘을 기반으로 하며 이 프로토콜 클래스의 모든 장점을 공유합니다.

---
## **7.3  EXTERIOR GATEWAY PROTOCOLS**
---
### **7.3.1  INTRODUCTION**

외부 게이트웨이 프로토콜은 특정 자율 시스템 내부의 네트워크 집합에 대한 연결 가능성 정보를 인접 자율 시스템과 교환하기 위해 자율 시스템 간 라우팅에 사용됩니다.

AS 간 라우팅 분야는 Internet Engineering Task Force 내부의 현재 연구 주제입니다. 섹션 \[부록 F.1\]에 설명된 외부 게이트웨이 프로토콜\(EGP\)은 전통적으로 AS 간 프로토콜로 선택되었지만 이제는 역사적입니다. BGP\(Border Gateway Protocol\)는 EGP의 많은 제한 사항을 제거하므로 인기가 급속히 높아지고 있습니다. AS 간 라우팅 프로토콜을 구현하는 데 라우터가 필요하지 않습니다. 그러나 라우터가 EGP를 구현하는 경우 BGP도 구현해야 합니다. 외부 게이트웨이 프로토콜로 설계되지는 않았지만 RIP\(\[7.2.4\] 참조\)는 때때로 AS 간 라우팅에 사용됩니다.\(MUST\)

---
### **7.3.2 BORDER GATEWAY PROTOCOL - BGP**
---
#### **7.3.2.1 Introduction**

BGP-4\(Border Gateway Protocol\)는 다른 BGP 스피커와 네트워크 연결 가능성 정보를 교환하는 AS 간 라우팅 프로토콜입니다. 네트워크 정보에는 트래픽이 해당 네트워크에 도달하기 위해 전송해야 하는 AS의 전체 목록이 포함됩니다. 그런 다음 이 정보를 사용하여 루프 없는 경로를 보장할 수 있습니다. 이 정보는 라우팅 루프를 제거하고 AS 수준에서 일부 정책 결정을 시행할 수 있는 AS 연결 그래프를 구성하는 데 충분합니다.

BGP는 \[ROUTE:4\]에 의해 정의됩니다. \[ROUTE:5\]는 인터넷에서 BGP의 올바른 사용법을 지정하고 몇 가지 유용한 구현 힌트와 지침을 제공합니다. \[ROUTE:12\] 및 \[ROUTE:13\]은 유용한 추가 정보를 제공합니다.

이 메모의 섹션 \[8.3\]을 준수하려면 BGP를 구현하는 라우터가 BGP MIB \[MGT:15\]를 구현해야 합니다.

BGP를 사용하여 시행할 수 있는 일련의 정책 결정을 특성화하려면 AS가 자신이 사용하는 경로만 이웃 AS에 알리는 규칙에 초점을 맞춰야 합니다. 이 규칙은 현재 인터넷 전반에 걸쳐 일반적으로 사용되는 홉별 라우팅 패러다임을 반영합니다. 일부 정책은 홉별 라우팅 패러다임에서 지원할 수 없으므로 다음과 같은 기술이 필요합니다.

시행할 소스 라우팅. 예를 들어, BGP는 트래픽이 이웃 AS에서 발생하는 트래픽과 다른 경로를 취하도록 의도하는 하나의 AS가 이웃 AS로 트래픽을 보내는 것을 활성화하지 않습니다. 반면에 BGP는 홉별 라우팅 패러다임을 준수하는 모든 정책을 지원할 수 있습니다.

BGP 구현자는 \[ROUTE:5\]의 섹션 6에 설명된 권장 사항을 따르는 것이 좋습니다.

---
#### **7.3.2.2 Protocol Walk-through**

BGP는 매우 복잡한 라우팅 정책을 지원하지만\(예를 들어 \[ROUTE:5\]의 섹션 4.2 참조\) 모든 BGP 구현자가 그러한 정책을 지원할 필요는 없습니다. 그러나 최소한 BGP 구현은 다음과 같습니다.

\(1\) AS가 인접한 AS에 대한 BGP 학습 경로 공지를 제어할 수 있도록 허용해야 합니다\(SHOULD\). 구현은 최소한 단일 네트워크의 세분성으로 이러한 제어를 지원해야 합니다\(SHOULD\). 구현은 또한 자율 시스템의 세분성으로 이러한 제어를 지원해야 하며, 여기서 자율 시스템은 경로를 시작한 자율 시스템이거나 로컬 시스템\(인접 자율 시스템\)에 경로를 광고한 자율 시스템일 수 있습니다.\(SHOULD, SHOULD, SHOULD\)

\(2\) AS가 대상보다 특정 경로를 선호하도록 허용해야 합니다\(두 개 이상의 경로를 사용할 수 있는 경우\). 이러한 기능은 시스템 관리자가 자율 시스템에 가중치를 할당할 수 있도록 허용하고 가중치가 가장 낮은 경로를 선택하는 경로 선택 프로세스를 만들어 구현해야 합니다\(경로의 가중치는 AS\_PATH 경로 속성에 있는 모든 AS의 가중치 합계로 정의됨\). 해당 경로와 연결됨\).\(SHOULD, SHOULD\)

\(3\) AS가 AS\_PATH 경로 속성에 특정 AS가 포함된 경로를 무시하도록 허용해야 합니다\(SHOULD\). 이러한 기능은 \(2\)에 설명된 기술을 사용하고 해당 AS에 대한 가중치로 무한대를 할당하여 구현할 수 있습니다. 경로 선택 프로세스에서는 가중치가 무한대인 경로를 무시해야 합니다.\(SHOULD\)

---
### **7.3.3 INTER-AS ROUTING WITHOUT AN EXTERIOR PROTOCOL**

두 개의 개별 표준 내부 라우팅 프로토콜 간에 표준 외부 라우팅 프로토콜을 사용하지 않고도 두 자율 시스템 또는 라우팅 도메인 간에 라우팅 정보를 교환하는 것이 가능합니다. 이를 수행하는 가장 일반적인 방법은 두 프로세스 간에 경로 정보를 교환하여 경계 라우터 중 하나에서 두 내부 프로토콜을 독립적으로 실행하는 것입니다.

EGP에서 IGP로의 정보 교환과 마찬가지로, 적절한 제어 없이 단일 라우터에 있는 두 IGP 간의 라우팅 정보 교환은 라우팅 루프가 생성될 수 있습니다.

---
## **7.4 STATIC ROUTING**

정적 라우팅은 특정 대상에 대한 라우터의 다음 홉을 명시적으로 정의하는 수단을 제공합니다. 라우터는 목적지에 대한 정적 경로를 정의하기 위한 수단을 제공해야 하며, 여기서 목적지는 네트워크 접두어로 정의됩니다. 메커니즘은 또한 각 정적 경로에 대해 메트릭을 지정할 수 있도록 허용해야 합니다\(SHOULD\).\(SHOULD, SHOULD\)

동적 라우팅 프로토콜을 지원하는 라우터는 사용된 라우팅 프로토콜에 유효한 모든 메트릭을 사용하여 정적 경로를 정의할 수 있도록 허용해야 합니다. 라우터는 라우팅 프로토콜을 통해 전파되거나 전파되지 않을 수 있는 고정 경로 목록을 사용자가 지정할 수 있는 기능을 제공해야 합니다. 또한 라우터는 정보를 활용할 수 있는 라우팅 프로토콜을 지원하는 경우 다음 추가 정보를 지원해야 합니다\(SHOULD\). 그들은:\(MUST, MUST, SHOULD\)

```text
   o TOS,

   o Subnet Mask, or

   o Prefix Length, or
```

o 경로를 가져올 수 있는 특정 라우팅 프로토콜과 관련된 메트릭입니다.

논의

- 우리는 주어진 라우팅 프로토콜에 유용한 것만 지원하면 된다고 생각합니다. TOS가 필요하기 때문에 공급업체가 사용되지 않는 다른 부분을 구현하도록 요구해서는 안 됩니다.

- 라우터가 동적 경로보다 정적 경로를 선호하는지\(또는 그 반대\) 또는 충돌하는 정적 경로와 동적 경로 사이를 선택하는 데 관련 메트릭이 사용되는지 여부는 각 정적 경로에 대해 구성 가능해야 합니다.\(SHOULD\)

- 라우터는 지원하는 각 라우팅 도메인에 대한 정적 경로에 메트릭이 할당되도록 허용해야 합니다. 이러한 각 메트릭은 특정 라우팅 도메인에 명시적으로 할당되어야 합니다. 예를 들어:\(MUST, MUST\)

```text
           route 10.0.0.0/8 via 192.0.2.3 rip metric 3

           route 10.21.0.0/16 via 192.0.2.4 ospf inter-area metric 27

           route 10.22.0.0/16 via 192.0.2.5 egp 123 metric 99
```

논의

- 이상적으로는 정적 경로가 메트릭이 아닌 기본 설정 값을 가져야 한다고 제안되었습니다\(메트릭은 동일한 라우팅 도메인에 있는 다른 경로의 메트릭과만 비교할 수 있기 때문에 정적 경로의 메트릭은 다른 경로의 메트릭과만 비교할 수 있음\). 정적 경로\). 이는 정적 경로에 실제로 메트릭이 있고 해당 메트릭을 사용하여 특정 동적 경로가 동일한 대상에 대한 정적 경로를 재정의하는지 여부를 결정하는 일부 현재 구현과 반대됩니다. 따라서 이 문서에서는 선호도 대신 메트릭이라는 용어를 사용합니다.

- 이 기술은 본질적으로 정적 경로를 RIP 경로 또는 OSPF 경로\(또는 메트릭 도메인에 따라 무엇이든\)로 만듭니다. 따라서 해당 도메인의 경로 조회 알고리즘이 적용됩니다. 그러나 이는 정적 경로를 동적 라우팅 도메인으로 강제 변환해도 라우터가 경로를 동적 라우팅 도메인으로 재배포하는 권한을 부여하지 않는다는 점에서 경로 누출이 아닙니다.

- 특정 라우팅 도메인에 포함되지 않은 고정 경로의 경우 경로 조회 알고리즘은 다음과 같습니다.

```text
      (1) Basic match

      (2) Longest match

      (3) Weak TOS (if TOS supported)

      (4) Best metric (where metric are implementation-defined)
```

- 마지막 단계는 필요하지 않을 수 있지만 하나의 인터페이스를 통한 기본 고정 경로와 대체 인터페이스를 통한 보조 고정 경로를 갖고, 기본 경로에 대한 인터페이스가 대체 경로인 경우 대체 경로로 장애 조치를 수행하려는 경우에 유용합니다. 실패합니다.

---
## **7.5 FILTERING OF ROUTING INFORMATION**

네트워크 내의 각 라우터는 전달 데이터베이스에 포함된 정보를 기반으로 전달 결정을 내립니다. 간단한 네트워크에서는 데이터베이스의 내용이 정적으로 구성될 수 있습니다. 네트워크가 더욱 복잡해짐에 따라 전달 데이터베이스의 동적 업데이트에 대한 필요성이 네트워크의 효율적인 운영에 매우 중요해졌습니다.

네트워크를 통한 데이터 흐름을 최대한 효율적으로 유지하려면 라우터가 전달 데이터베이스를 구축하는 데 사용하는 정보의 전파를 제어하는 ​​메커니즘을 제공해야 합니다. 이 제어는 어떤 소스를 선택하는 형식을 취합니다.

라우팅 정보는 신뢰할 수 있어야 하며 믿을 정보를 선택해야 합니다. 결과 전달 데이터베이스는 사용 가능한 라우팅 정보의 필터링된 버전입니다.

효율성 외에도 라우팅 정보 전파를 제어하면 부정확하거나 잘못된 라우팅 정보의 확산을 방지하여 불안정성을 줄일 수 있습니다.

어떤 경우에는 로컬 정책에 따라 전체 라우팅 정보가 널리 전파되지 않도록 요구할 수도 있습니다.

이러한 필터링 요구 사항은 SPF 기반이 아닌 프로토콜에만 적용됩니다. 따라서 거리 벡터 프로토콜을 구현하지 않는 라우터에는 전혀 적용되지 않습니다.

---
### **7.5.1 Route Validation**

라우터는 업데이트를 수신한 라우팅 프로토콜이 해당 값을 사용하여 특수 경로\(예: 기본 경로\)를 인코딩하지 않는 한 이 메모의 사양을 위반하는 경로를 광고하는 모든 라우팅 업데이트를 오류로 기록해야 합니다.\(SHOULD\)

---
### **7.5.2 Basic Route Filtering**

라우팅 정보를 필터링하면 라우터가 수신한 패킷을 전달하는 데 사용하는 경로를 제어할 수 있습니다. 라우터는 수신하는 라우팅 정보의 소스와 신뢰하는 경로를 선택해야 합니다. 따라서 라우터는 다음을 지정하는 기능을 제공해야 합니다.\(MUST\)

o 라우팅 정보가 허용되는 논리적 인터페이스와 각 논리적 인터페이스에서 허용되는 경로.

o 논리적 인터페이스에 모든 경로가 광고되는지 아니면 기본 경로만 광고되는지 여부.

일부 라우팅 프로토콜은 논리적 인터페이스를 라우팅 정보의 소스로 인식하지 않습니다. 그러한 경우 라우터는 다음을 지정하는 기능을 제공해야 합니다.\(MUST\)

o 다른 라우터 라우팅 정보가 허용됩니다.

예를 들어, 하나 이상의 리프 네트워크를 더 큰 네트워크의 주요 부분이나 백본에 연결하는 라우터를 가정합니다. 각 리프 네트워크에는 들어오고 나가는 경로가 하나만 있으므로 라우터는 간단히 기본 경로를 해당 네트워크에 보낼 수 있습니다. 리프 네트워크를 메인 네트워크에 알립니다.

---
### **7.5.3 Advanced Route Filtering**

네트워크의 토폴로지가 더욱 복잡해짐에 따라 더욱 복잡한 경로 필터링에 대한 필요성이 대두됩니다. 따라서 라우터는 각 라우팅 프로토콜에 대해 독립적으로 지정하는 기능을 제공해야 합니다.\(SHOULD\)

o 어떤 논리적 인터페이스 또는 라우터 라우팅 정보\(경로\)가 수락될 것인지, 그리고 어떤 경로가 서로의 라우터 또는 논리적 인터페이스로부터 믿어질 것인지,

o 어떤 경로가 어떤 논리적 인터페이스를 통해 전송될 것인지, 그리고

o 사용 중인 라우팅 프로토콜에서 지원하는 경우 라우팅 정보가 전송될 라우터.

많은 상황에서 위의 첫 번째 글머리 기호에 나열된 단순한 믿거나 믿지 않는 선택 대신 다른 라우터에서 수신된 라우팅 정보에 신뢰성 순서를 할당하는 것이 바람직합니다. 라우터는 다음을 지정하는 기능을 제공할 수 있습니다.\(MAY\)

o 수신된 각 경로에 할당할 신뢰도 또는 선호도. 각 경로와 관련된 라우팅 메트릭에 관계없이 신뢰도가 낮은 경로보다 신뢰도가 높은 경로가 선택됩니다.

라우터가 기본 설정 할당을 지원하는 경우 라우터는 선호하지 않는 경로를 자사 정보로 전파해서는 안 됩니다. 경로를 전파하는 데 사용되는 라우팅 프로토콜이 자사 정보와 제3자 정보의 구별을 지원하지 않는 경우 라우터는 선호하지 않는 경로를 전파해서는 안 됩니다.\(MUST NOT, MUST NOT\)

논의

- 예를 들어, 라우터가 라우터 R로부터 네트워크 C로의 경로를 수신하고 라우터 S로부터 동일한 네트워크로의 경로를 수신한다고 가정합니다. 라우터 R이 라우터 S보다 더 신뢰할 수 있는 것으로 간주되면 네트워크 C로 향하는 트래픽은 라우터 R로 전달됩니다. 라우터 S로부터 수신된 경로

라우터가 사용하지 않는 경로\(위 예에서는 라우터 S\)에 대한 라우팅 정보를 다른 라우터로 전달해서는 안 됩니다.\(MUST NOT\)

---
## **7.6 INTER-ROUTING-PROTOCOL INFORMATION EXCHANGE**

독립적인 IP 라우팅 프로세스가 동일한 라우터에서 실행될 수 있는 경우 라우터는 별도의 IP 내부 라우팅 프로토콜 간에 라우팅 정보를 교환할 수 있어야 합니다. 라우터는 두 개의 개별 내부 라우팅 간에 라우팅 정보를 양방향으로 교환하도록 라우터가 구성된 경우 라우팅 루프를 피하기 위한 몇 가지 메커니즘을 제공해야 합니다.\(MUST, MUST\)

프로세스. 라우터는 독립적인 라우팅 프로세스에서 경로를 선택하기 위한 몇 가지 우선순위 메커니즘을 제공해야 합니다\(MUST\). 라우터는 관리 경계를 넘어 사용될 때 IGP-IGP 교환에 대한 관리 제어를 제공해야 합니다\(SHOULD\).\(MUST, SHOULD\)

라우터는 네트워크별로 측정항목을 변환하거나 변환하기 위한 몇 가지 메커니즘을 제공해야 합니다\(SHOULD\). 라우터\(또는 라우팅 프로토콜\)는 IGP로 가져온 외부 경로의 전역 우선순위를 허용할 수 있습니다.\(SHOULD, MAY\)

논의

- 서로 다른 IGP는 서로 다른 측정항목을 사용하므로 한 프로토콜의 정보를 다른 형식의 측정항목을 사용하여 다른 프로토콜에 도입할 때 일부 변환 기술이 필요합니다. 일부 IGP는 동일한 라우터 또는 라우터 집합 내에서 여러 인스턴스를 실행할 수 있습니다. 이 경우 메트릭 정보는 정확하게 보존되거나 번역될 수 있습니다.

사이의 번역에는 적어도 두 가지 기술이 있습니다.

- 다른 라우팅 프로세스. 정적\(또는 도달 가능성\) 접근 방식은 한 IGP에 있는 경로 알림의 존재를 사용하여 지정된 메트릭을 사용하여 다른 IGP에 경로 알림을 생성합니다. 변환 또는 테이블 형식 접근 방식은 한 IGP의 메트릭을 사용하여 함수\(예: 상수 추가\) 또는 테이블 조회를 통해 다른 IGP에 메트릭을 생성합니다.

- 피드백을 제한하는 제어 메커니즘이 없으면 라우팅 정보의 양방향 교환은 위험합니다. 이는 거리 벡터 라우팅 프로토콜이 분할 지평선 기술로 해결해야 하고 EGP가 제3자 규칙으로 해결해야 하는 것과 동일한 문제입니다. 라우팅 루프는 테이블 또는 허용/거부 경로 목록을 사용하여 명시적으로 방지하거나 분할 지평선 규칙, 제3자 금지 규칙 또는 경로 태그 지정 메커니즘을 사용하여 암시적으로 피할 수 있습니다. 공급업체는 네트워크 운영자가 보다 쉽게 ​​관리할 수 있도록 가능한 경우 암시적 기술을 사용하는 것이 좋습니다.

---
## **8. APPLICATION LAYER - NETWORK MANAGEMENT PROTOCOLS**

이 장은 \[소개:3\]의 "원격 관리"에 명시된 모든 요구 사항보다 우선합니다.

---
## **8.1 The Simple Network Management Protocol - SNMP**
---
### **8.1.1 SNMP Protocol Elements**

라우터는 SNMP\[MGT:3\]로 관리할 수 있어야 합니다. SNMP는 전송 및 네트워크 프로토콜로 UDP/IP를 사용하여 작동해야 합니다. 다른 것들도 지원될 수 있습니다\(예: \[MGT:25, MGT:26, MGT:27 및 MGT:28\] 참조\). SNMP\(MUST, MUST, MAY\)

관리 작업은 마치 SNMP가 라우터 자체에 구현된 것처럼 작동해야 합니다. 특히, 관리 작업은 라우터의 인터페이스에 할당된 IP 주소에 SNMP 관리 요청을 보내서 영향을 받아야 합니다. 실제 관리 작업은 라우터 또는 라우터용 프록시에 의해 수행될 수 있습니다.\(MUST, MUST\)

논의

- 이 표현은 프록시 장치가 패킷 대상 주소 필드에 라우터의 IP 주소 중 하나가 있는 SNMP 패킷에 응답하는 프록시에 의한 관리를 허용하거나, SNMP가 라우터 자체에 직접 구현되어 패킷을 수신하고 응답하는 것을 허용하기 위한 것입니다. 적절한 방법으로 그들에게.

- 관리 작업을 라우터의 IP 주소 중 하나로 전송할 수 있는 것이 중요합니다. 네트워크 문제를 진단할 때 사용 가능한 라우터를 식별하는 유일한 방법은 라우터의 IP 주소 중 하나일 수 있습니다. 아마도 다른 라우터의 라우팅 테이블을 조사하여 얻을 수 있습니다.

모든 SNMP 작업\(get, get-next, get-response, set 및 트랩\)을 구현해야 합니다.\(MUST\)

라우터는 SNMP 트랩 메시지 생성 속도를 제한하는 메커니즘을 제공해야 합니다. 라우터는 \[MGT:5\]에 설명된 비동기 경고 관리 알고리즘을 통해 이 메커니즘을 제공할 수 있습니다.\(MUST, MAY\)

논의

- 트랩 속도 제한의 필요성에 대한 일반적인 합의가 있지만 이를 가장 잘 달성하는 방법에 대해서는 아직 합의가 이루어지지 않았습니다. 인용된 참고문헌은 실험적인 것으로 간주됩니다.

---
## **8.2 Community Table**

이 사양의 목적을 위해 라우터에 추상적인 '커뮤니티 테이블'이 있다고 가정합니다. 이 테이블에는 여러 항목이 포함되어 있으며 각 항목은 특정 커뮤니티에 대한 것이며 해당 커뮤니티의 속성을 완전히 정의하는 데 필요한 매개변수가 포함되어 있습니다. 물론 추상 커뮤니티 테이블의 실제 구현 방법은 구현에 따라 다릅니다.

라우터의 커뮤니티 테이블은 최소한 하나의 항목을 허용해야 하며\(MUST\) 최소한 두 개의 항목을 허용해야 합니다\(SHOULD\).\(MUST\)

논의

- 수용인원이 0인 커뮤니티 테이블은 쓸모가 없습니다. 이는 라우터가 어떤 커뮤니티도 인식하지 못하므로 모든 SNMP 작업이 거부된다는 의미입니다.

- 따라서 하나의 항목은 테이블의 최소 유용 크기입니다. 두 개의 항목이 있으면 한 항목은 읽기 전용 액세스로 제한되고 다른 항목은 쓰기 기능을 가질 수 있습니다.

라우터는 사용자가 SNMP 커뮤니티 테이블의 항목을 수동으로\(즉, SNMP를 사용하지 않고\) 검사, 추가, 삭제 및 변경할 수 있도록 허용해야 합니다. 사용자는 커뮤니티 이름을 설정하거나 MIB 보기를 구성할 수 있어야 합니다. 사용자는 커뮤니티를 읽기 전용\(즉, SET를 허용하지 않음\) 또는 읽기-쓰기\(즉, SET를 허용함\)로 구성할 수 있어야 합니다.\(MUST, MUST, MUST\)

트랩이 사용되는 경우 사용자는 각 커뮤니티 또는 MIB 보기에 대해 알림이 전송되는 IP 주소를 하나 이상 정의할 수 있어야 합니다. 이러한 주소는 커뮤니티 또는 MIB 보기 기반으로 정의할 수 있어야 합니다. 커뮤니티 또는 MIB 보기 기반으로 알림을 활성화하거나 비활성화하는 것이 가능해야 합니다\(SHOULD\).\(MUST, SHOULD, SHOULD\)

라우터는 특정 커뮤니티에 대해 유효한 네트워크 관리자 목록을 지정하는 기능을 제공해야 합니다\(SHOULD\). 활성화된 경우 라우터는 목록에 대해 SNMP 데이터그램의 소스 주소를 확인해야 하며 주소가 나타나지 않으면 데이터그램을 폐기해야 합니다. 데이터그램이 폐기되면 라우터는 SNMP 인증 실패에 적절한 모든 조치를 취해야 합니다.\(SHOULD, MUST, MUST\)

논의

- 이는 다소 제한된 인증 시스템이지만 다양한 형태의 패킷 필터링과 결합되어 보안을 강화할 수 있는 작은 수단을 제공할 수 있습니다.

커뮤니티 테이블은 비휘발성 저장소에 저장되어야 합니다.\(MUST\)

커뮤니티 테이블의 초기 상태에는 커뮤니티 이름 문자열이 공개이고 읽기 전용 액세스인 하나의 항목이 포함되어야 합니다. 이 항목의 기본 상태는 트랩을 전송해서는 안 됩니다. 구현된 경우 이 항목은 관리자가 변경하거나 삭제할 때까지 커뮤니티 테이블에 남아 있어야 합니다.\(SHOULD, MUST NOT, MUST\)

논의

- 기본적으로 이 커뮤니티에는 트랩이 전송되지 않습니다. 트랩 PDU는 유니캐스트 IP 주소로 전송됩니다. 이 주소는 어떤 방식으로든 라우터에 구성되어야 합니다. 구성이 이루어지기 전에는 그런 주소가 없는데 누구에게 트랩을 보내야 할까요? 따라서 공개 커뮤니티로의 트랩 전송은 기본적으로 비활성화되어 있습니다. 물론 이는 라우터가 작동되면 관리 작업에 의해 변경될 수 있습니다.

---
## **8.3 Standard MIBS**

라우터 구성과 관련된 모든 MIBS가 구현됩니다. 재치있게 말하자면:

o MIB-II\[MGT:2\]의 시스템, 인터페이스, IP, ICMP 및 UDP 그룹을 구현해야 합니다.\(MUST\)

o 인터페이스 확장 MIB \[MGT:18\]를 구현해야 합니다.\(MUST\)

o IP 전달 테이블 MIB \[MGT:20\]을 구현해야 합니다.\(MUST\)

o 라우터가 TCP\(예: Telnet용\)를 구현하는 경우 MIB-II \[MGT:2\]의 TCP 그룹을 구현해야 합니다.\(MUST\)

o 라우터가 EGP를 구현하는 경우 MIB-II\[MGT:2\]의 EGP 그룹을 구현해야 합니다.\(MUST\)

o 라우터가 OSPF를 지원하는 경우 OSPF MIB \[MGT:14\]를 구현해야 합니다.\(MUST\)

o 라우터가 BGP를 지원하는 경우 BGP MIB\[MGT:15\]를 구현해야 합니다.\(MUST\)

o 라우터에 이더넷, 802.3 또는 StarLan 인터페이스가 있는 경우 이더넷 유사 MIB\[MGT:6\]를 구현해야 합니다.\(MUST\)

o 라우터에 802.4 인터페이스가 있는 경우 802.4 MIB\[MGT:7\]를 구현해야 합니다.\(MUST\)

o 라우터에 802.5 인터페이스가 있는 경우 802.5 MIB\[MGT:8\]를 구현해야 합니다.\(MUST\)

o 라우터에 ANSI SMT 7.3을 구현하는 FDDI 인터페이스가 있는 경우 FDDI MIB \[MGT:9\]를 구현해야 합니다.\(MUST\)

o 라우터에 ANSI SMT 6.2를 구현하는 FDDI 인터페이스가 있는 경우 FDDI MIB \[MGT:29\]를 구현해야 합니다.\(MUST\)

o 라우터에 RS-232, V.10, V.11, V.35, V.36 또는 RS-422/423/449와 같은 V.24 신호를 사용하는 인터페이스가 있는 경우 RS-232 \[ MGT:10\] MIB를 구현해야 합니다.\(MUST\)

o 라우터에 T1/DS1 인터페이스가 있는 경우 T1/DS1 MIB \[MGT:16\]을 구현해야 합니다.\(MUST\)

o 라우터에 T3/DS3 인터페이스가 있는 경우 T3/DS3 MIB\[MGT:17\]를 구현해야 합니다.\(MUST\)

o 라우터에 SMDS 인터페이스가 있는 경우 SMDS 인터페이스 프로토콜 MIB \[MGT:19\]를 구현해야 합니다.\(MUST\)

o 라우터가 해당 인터페이스를 통해 PPP를 지원하는 경우 PPP MIB \[MGT:11\], \[MGT:12\] 및 \[MGT:13\]을 구현해야 합니다.\(MUST\)

o 라우터가 RIP 버전 2를 지원하는 경우 RIP 버전 2 MIB\[MGT:21\]를 구현해야 합니다.\(MUST\)

o 라우터가 해당 인터페이스를 통해 X.25를 지원하는 경우 X.25 MIB\[MGT:22, MGT:23 및 MGT:24\]를 구현해야 합니다.\(MUST\)

---
## **8.4 Vendor Specific MIBS**

인터넷 표준 및 실험적 MIB는 네트워크 요소에서 사용할 수 있는 통계, 상태, 구성 및 제어 정보의 전체 범위를 다루지 않습니다. 그럼에도 불구하고 이 정보는 매우 유용합니다. 라우터\(및 기타 네트워크 장치\) 공급업체는 일반적으로 이 정보를 다루는 MIB 확장을 개발했습니다. 이러한 MIB 확장을 공급업체별 MIB라고 합니다.

라우터용 공급업체별 MIB는 구현된 표준 및 실험적 MIB를 통해 사용할 수 없는 모든 통계, 상태, 구성 및 제어 정보에 대한 액세스를 제공해야 합니다. 이 정보는 모니터링 및 제어 작업 모두에 사용할 수 있어야 합니다.\(MUST, MUST\)

논의

- 이 요구 사항의 목적은 콘솔을 통해 수행할 수 있는 모든 작업을 SNMP를 통해 라우터에서 수행할 수 있는 기능을 제공하는 것입니다. SNMP가 작동하려면 최소한의 구성이 필요합니다\(예: 라우터에 IP 주소가 있어야 함\). 이 초기 구성은 SNMP를 통해 수행할 수 없습니다. 그러나 초기 구성이 완료되면 네트워크 관리를 통해 모든 기능을 사용할 수 있어야 합니다.

공급업체는 모든 공급업체별 MIB 변수에 대한 사양을 제공해야 합니다. 이러한 사양은 SMI \[MGT:1\]을 준수해야 하며 설명은 \[MGT:4\]에 지정된 형식이어야 합니다.\(SHOULD, MUST\)

논의

- 사용자가 공급업체별 MIB를 사용할 수 있도록 하는 것이 필요합니다. 이 정보가 없으면 사용자는 공급업체별 매개변수에 액세스할 수 있도록 네트워크 관리 시스템을 구성할 수 없습니다. 그러면 이러한 매개변수는 쓸모가 없게 됩니다.

- ne 2 MIB 사양의 형식도 지정됩니다. MIB 사양을 읽고 네트워크 관리 스테이션에 필요한 테이블을 생성하는 파서를 사용할 수 있습니다. 이러한 파서는 일반적으로 표준 MIB 사양 형식만 이해합니다.

---
## **8.5 Saving Changes**

SNMP에 의해 변경된 매개변수는 비휘발성 저장소에 저장될 수 있습니다.\(MAY\)

논의

- 이 요구사항이 'MAY'인 이유:\(MAY\)

- o 비휘발성 저장소의 정확한 물리적 특성은 이 문서에 명시되어 있지 않습니다. 따라서 매개변수는 NVRAM/EEPROM, 로컬 플로피 또는 하드 디스크, 일부 TFTP 파일 서버 또는 BOOTP 서버 등에 저장될 수 있습니다. 이 정보가 TFTP를 통해 검색되는 파일에 있다고 가정합니다. 이 경우, 라우터의 구성 매개변수에 대한 변경 사항은 구성 파일을 보유하고 있는 파일 서버로 다시 전파되어야 합니다. 또는 SNMP 작업을 파일 서버로 전달한 다음 변경 사항을 어떻게든 라우터에 전파해야 합니다. 이 문제에 대한 답은 명확하지 않은 것 같습니다.

- 이는 또한 사용 가능한 TFTP 서버를 보유하는 것보다 구성 정보를 보유하는 호스트에 더 많은 요구 사항을 부여하므로 공급업체가 잠재 고객이 사용 가능한 적합한 호스트를 보유할 것이라고 가정하는 것은 아마도 안전하지 않을 것입니다.

- o 변경된 매개변수를 비휘발성 저장소에 커밋하는 시기는 여전히 논쟁의 여지가 있는 문제입니다. 어떤 사람들은 모든 변경 사항을 즉시 커밋하는 것을 선호합니다. 다른 사람들은 명시적인 명령이 있을 때만 비휘발성 저장소에 대한 변경 사항을 커밋하는 것을 선호합니다.

---
## **9. APPLICATION LAYER - MISCELLANEOUS PROTOCOLS**

라우터가 구현하는 모든 추가 애플리케이션 프로토콜에 대해 라우터는 반드시 준수해야 하며 \[INTRO:3\]의 관련 요구 사항을 무조건 준수해야 합니다.\(MUST\)

---
## **9.1 BOOTP**
---
### **9.1.1 Introduction**

BOOTP\(Bootstrap Protocol\)는 부팅 호스트가 사용자 없이 동적으로 스스로 구성할 수 있도록 하는 UDP/IP 기반 프로토콜입니다.

감독. BOOTP는 할당된 IP 주소, 부팅 서버 호스트의 IP 주소, 메모리에 로드되어 실행될 파일 이름\(\[APPL:1\]\)을 호스트에 알리는 수단을 제공합니다. 로컬 접두사 ​​길이 또는 서브넷 마스크, 로컬 시간 오프셋, 기본 라우터 주소 및 다양한 인터넷 서버 주소와 같은 기타 구성 정보도 BOOTP\(\[APPL:2\]\)를 사용하여 호스트와 통신할 수 있습니다.

---
### **9.1.2 BOOTP Relay Agents**

많은 경우 BOOTP 클라이언트와 관련 BOOTP 서버는 동일한 IP \(하위\) 네트워크에 상주하지 않습니다. 이러한 경우 클라이언트와 서버 간에 BOOTP 메시지를 전송하려면 타사 에이전트가 필요합니다. 이러한 에이전트를 원래 BOOTP 전달 에이전트라고 했습니다. 그러나 라우터의 IP 전달 기능과의 혼동을 피하기 위해 대신 BOOTP 중계 에이전트라는 이름을 채택했습니다.

논의

- BOOTP 중계 에이전트는 라우터의 일반적인 IP 포워딩 기능과 구별되는 작업을 수행합니다. 라우터는 일반적으로 네트워크 간 IP 데이터그램을 다소 투명하게 전환하지만 BOOTP 중계 에이전트는 BOOTP 메시지를 최종 목적지로 수신한 다음 결과적으로 새로운 BOOTP 메시지를 생성하는 것이 더 적절하다고 생각할 수 있습니다. BOOTP 메시지를 일반 패킷처럼 단순히 전달한다는 개념에 저항해야 합니다.

이 릴레이-에이전트 기능은 클라이언트와 서버를 상호 연결하는 라우터에 가장 편리하게 위치해 있습니다\(클라이언트 \(서브\)네트에 직접 연결된 호스트에 위치할 수도 있음\).

라우터는 BOOTP 중계 에이전트 기능을 제공할 수 있습니다. 그렇다면 \[APPL:3\]의 사양을 준수해야 합니다.\(MAY, MUST\)

섹션 \[5.2.3\]에서는 패킷이 로컬로\(라우터로\) 전달되는 상황을 논의했습니다. UDP 대상 포트 번호가 BOOTPS\(67\)인 로컬로 전달된 모든 UDP 메시지는 라우터의 논리적 BOOTP 중계 에이전트에 의한 특수 처리를 위해 고려됩니다.

섹션 \[4.2.2.11\] 및 \[5.3.7\]에서는 유효하지 않은 IP 소스 주소에 대해 논의했습니다. 이러한 규칙에 따라 라우터는 IP 소스 주소가 0.0.0.0인 수신된 데이터그램을 전달해서는 안 됩니다. 그러나 BOOTP 릴레이 에이전트를 지원하는 라우터는 IP 소스 주소가 0.0.0.0인 릴레이 에이전트 BOOTREQUEST 메시지에 대한 로컬 전달을 수락해야 합니다.\(MUST\)

---
## **10. OPERATIONS AND MAINTENANCE**

```text
   This chapter supersedes any requirements of [INTRO:3] relating to
   "Extensions to the IP Module."
```

운영 및 유지 관리\(O&M\) 활동을 지원하는 시설은 모든 라우터 구현의 필수적인 부분을 구성합니다. 이러한 기능은 상호 운용성과 직접적인 관련이 없는 것처럼 보이지만 라우터가 상호 운용되도록 해야 하고 그렇지 않은 경우 문제를 추적해야 하는 네트워크 관리자에게 필수적입니다. 이 장에는 라우터 초기화와 네트워크 관리자가 네트워크를 보호하고 계산하는 데 도움이 되는 기능에 대한 논의도 포함되어 있습니다.

---
## **10.1 Introduction**

라우터 O&M에는 다음과 같은 종류의 활동이 포함됩니다.

o 라우터 프로세서, 네트워크 인터페이스 또는 연결된 네트워크, 모뎀 또는 통신 회선의 하드웨어 문제를 진단합니다.

```text
   o Installing new hardware

   o Installing new software.
```

o 충돌 후 라우터를 다시 시작하거나 재부팅합니다.

o 라우터 구성\(또는 재구성\).

o 정체, 라우팅 루프, 잘못된 IP 주소, 블랙홀, 패킷 사태, 오작동하는 호스트 등의 인터넷 문제를 감지하고 진단합니다.

o 일시적으로\(예: 통신 회선 문제를 우회하기 위해\) 또는 영구적으로 네트워크 토폴로지를 변경합니다.

o 라우터 및 연결된 네트워크의 상태와 성능을 모니터링합니다.

o \(상호\)네트워크 계획에 사용하기 위한 트래픽 통계 수집.

o 적절한 벤더 및 통신 전문가와 함께 위 활동을 조정합니다.

라우터와 연결된 통신 회선은 중앙 집중식 O&M 조직에 의해 시스템으로 운영되는 경우가 많습니다. 이 조직은 \(상호\)네트워크 운영 센터\(NOC\)를 유지하여 다음과 같은 업무를 수행할 수 있습니다.

O&M 기능. 라우터는 NOC와 동일한 네트워크에 연결되지 않을 수 있으므로 라우터는 인터넷 경로를 통해 NOC에서 원격 제어 및 모니터링을 지원하는 것이 중요합니다. 네트워크 오류로 인해 일시적으로 네트워크 액세스가 불가능해질 수 있으므로 많은 NOC에서는 라우터의 콘솔 포트에 연결된 전화 접속 모뎀과 같은 대체 수단을 통해 네트워크 관리를 위해 라우터에 액세스할 수 있어야 한다고 주장합니다.

인터넷을 통과하는 IP 패킷은 종종 둘 이상의 NOC의 통제하에 있는 라우터를 사용하므로 인터넷 문제 진단에는 종종 둘 이상의 NOC 직원의 협력이 필요합니다. 경우에 따라 둘 이상의 NOC에서 동일한 라우터를 모니터링해야 할 수도 있지만, 과도한 모니터링은 라우터 성능에 영향을 미칠 수 있으므로 필요한 경우에만 모니터링해야 합니다.

NOC에서 모니터링에 사용할 수 있는 도구는 광범위한 정교함을 포괄할 수 있습니다. 현재 구현에는 전체 라우터 시스템의 다중 창, 동적 디스플레이가 포함됩니다. 미래에는 자동 문제 진단을 위한 AI 기술의 활용이 제안됩니다.

여기에서 논의되는 라우터 O&M 시설은 인터넷 관리의 크고 어려운 문제의 일부일 뿐입니다. 이러한 문제는 여러 관리 조직뿐만 아니라 여러 프로토콜 계층에도 영향을 미칩니다. 예를 들어, 인터넷 아키텍처 진화의 현재 단계에서는 호스트 TCP 구현과 라우터 시스템의 최종 IP 수준 정체 사이에 강한 결합이 있습니다\[OPER:1\]. 따라서 정체 문제를 진단하려면 호스트의 TCP 통계를 모니터링해야 하는 경우가 있습니다. 현재 인터넷 관리, 특히 라우터 O&M 분야에서 수많은 R&D 노력이 진행 중입니다. 이러한 R&D 노력은 이미 라우터 O&M에 대한 표준을 만들어냈습니다. 이는 공급업체의 창의성이 크게 기여할 수 있는 영역이기도 합니다.

---
## **10.2 Router Initialization**
---
### **10.2.1 Minimum Router Configuration**

라우터가 패킷을 전달하기 전에 충족해야 하는 최소 조건 집합이 있습니다. 라우터는 다음 중 하나를 제외하고 물리적 인터페이스에서 전달을 활성화해서는 안 됩니다.\(MUST NOT\)

\(1\) 라우터는 해당 물리적 ​​인터페이스와 연관된 하나 이상의 논리적 인터페이스의 IP 주소 및 연관된 서브넷 마스크 또는 네트워크 접두사 길이를 알고 있습니다.

\(2\) 라우터는 해당 인터페이스가 번호가 지정되지 않은 인터페이스임을 알고 해당 라우터 ID를 알고 있습니다.

이러한 매개변수는 명시적으로 구성되어야 합니다.\(MUST\)

o 라우터는 IP 주소, 접두사 길이 또는 라우터 ID에 대해 공장에서 구성된 기본값을 사용해서는 안 됩니다.\(MUST NOT\)

o 라우터는 구성되지 않은 인터페이스가 번호가 지정되지 않은 인터페이스라고 가정해서는 안 됩니다.\(MUST NOT\)

논의

- 라우터가 공급업체에서 설치한 인터페이스 기본 주소와 함께 배송되는 경우가 있습니다. 어떤 경우에는 이로 인해 라우터가 이러한 기본 주소를 활성 네트워크에 광고하게 되었습니다.

---
### **10.2.2 Address and Prefix Initialization**

라우터는 IP 주소와 주소 마스크 또는 접두사 길이를 정적으로 구성하고 비휘발성 저장소에 저장할 수 있도록 허용해야 합니다.\(MUST\)

```text
   A router MAY obtain its IP addresses and their corresponding address
   masks dynamically as a side effect of the system initialization
   process (see Section 10.2.3]);
```

동적 방법이 제공되는 경우 특정 라우터에서 사용할 방법 선택을 구성할 수 있어야 합니다.\(MUST\)

\[4.2.2.11\]에서 설명한 바와 같이 IP 주소는 <Host-number\> 또는 <Network-prefix\> 필드에 0 또는 -1 값을 갖는 것이 허용되지 않습니다. 따라서 라우터는 IP 주소 또는 주소 마스크가 위의 필드 중 하나가 0 또는 -1 값을 갖도록 하는 값으로 설정되도록 허용해서는 안 됩니다.\(SHOULD NOT\)

논의

- 임의의 주소 마스크를 사용하여 라우팅이 모호한 상황을 만드는 것이 가능합니다\(즉, 서로 다르지만 동일하게 특정한 서브넷 마스크를 가진 두 경로가 특정 대상 주소와 일치하는 경우\). 이는 네트워크 접두사 사용에 대한 가장 강력한 주장 중 하나이며, 연속되지 않은 서브넷 마스크 사용이 허용되지 않는 이유입니다.

라우터는 자신이 설치하는 모든 주소 마스크에 대해 다음을 확인해야 합니다.\(SHOULD\)

o 마스크는 모두 1도 아니고 모두 0도 아닙니다\(접두사 길이는 0도 아니고 32도 아닙니다\).

o 주소의 네트워크 접두사 부분에 해당하는 비트는 모두 1로 설정됩니다.

o 네트워크 접두사에 해당하는 비트는 연속적입니다.

논의

- 경로와 관련된 마스크는 서브넷 마스크라고도 불리며, 이 테스트를 적용해서는 안 됩니다.

---
### **10.2.3 Network Booting using BOOTP and TFTP**

라우터가 네트워크에서 어떻게 부팅될 수 있고 부팅되어야 하는지에 대해 많은 논의가 있었습니다. 이러한 논의는 BOOTP와 TFTP를 중심으로 진행되었습니다. 현재 네트워크에서 TFTP로 부팅하는 라우터가 있습니다. 부팅 이미지를 로드해야 하는 서버를 찾는 데 BOOTP를 사용할 수 없는 이유는 없습니다.

BOOTP는 최종 시스템을 부팅하는 데 사용되는 프로토콜이며 라우터와 함께 사용하려면 약간의 확장이 필요합니다. 라우터가 BOOTP를 사용하여 현재 부팅 호스트를 찾는 경우 첫 번째 인터페이스의 하드웨어 주소와 함께 BOOTP 요청을 보내야 합니다. 또는 이전에 다르게 구성된 경우 다른 인터페이스의 하드웨어 주소 또는 입력할 다른 번호와 함께 BOOTP 요청을 보내야 합니다. BOOTP 패킷의 하드웨어 주소 필드에 있습니다. 이는 하드웨어 주소가 없는 라우터\(예: 동기 회선 전용 라우터\)가 부트로드 검색을 위해 BOOTP를 사용할 수 있도록 하기 위한 것입니다. 그런 다음 TFTP를 사용하여 BOOTP 응답에서 찾은 이미지를 검색할 수 있습니다. 사용할 구성된 인터페이스나 번호가 없는 경우 라우터는 BOOTP 서버에서 일치하는 항목을 찾을 때까지 인터페이스 하드웨어 주소를 순환할 수 있습니다.\(MAY\)

라우터는 BOOTP를 통해 학습된 매개변수를 로컬 비휘발성 저장소에 저장하는 기능을 구현해야 합니다. 라우터는 네트워크를 통해 로드된 시스템 이미지를 안정적인 로컬 저장소에 저장하는 기능을 구현할 수 있습니다.\(SHOULD, MAY\)

라우터에는 원격 사용자가 라우터에 새 부팅 이미지를 가져오도록 요청할 수 있는 기능이 있을 수 있습니다. 요청에 포함된 위치, 마지막 부팅 이미지 서버에서 새 부팅 이미지를 가져오는 것과 BOOTP를 사용하여 서버를 찾는 것 사이에는 차이가 있어야 합니다.\(MAY\)

---
## **10.3 Operation and Maintenance**
---
### **10.3.1 Introduction**

라우터에서 O&M 기능을 수행하기 위한 다양한 모델이 있습니다. 극단적인 경우에는 O&M 기능이 로컬에서만\(예: 라우터 시스템에 연결된 터미널에서\) 실행될 수 있는 로컬 전용 모델이 있습니다. 다른 극단적인 경우, 완전 원격 모델에서는 최소한의 기능만 로컬에서 수행\(예: 강제 부팅\)할 수 있으며 대부분의 O&M은 NOC에서 원격으로 수행됩니다. NOC 직원이 텔넷 프로토콜을 사용하여 라우터에 호스트로 로그인하여 로컬에서도 호출할 수 있는 기능을 수행할 수 있는 중간 모델이 있습니다. 로컬 전용 모델은 일부 라우터 설치에 적합할 수 있지만 일반적으로 NOC의 원격 작동이 필요하므로 대부분의 라우터에는 원격 O&M 제공이 필요합니다.

원격 O&M 기능은 제어 에이전트\(프로그램\)를 통해 수행될 수 있습니다. 직접 접근 방식에서는 라우터가 표준 인터넷 프로토콜\(예: SNMP, UDP 또는 TCP\)을 사용하여 NOC에서 직접 원격 O&M 기능을 지원합니다. 간접적인 접근 방식에서는 제어 에이전트가 이러한 프로토콜을 지원하고 독점 프로토콜을 사용하여 라우터 자체를 제어합니다. 두 가지 접근 방식 모두 허용되지만 직접적인 접근 방식이 선호됩니다. 상당한 추가 투자가 필요한 특수 호스트 하드웨어 및/또는 소프트웨어의 사용은 권장되지 않습니다. 그럼에도 불구하고 일부 공급업체에서는 라우터가 포함된 네트워크의 통합 부분으로 제어 에이전트를 제공하기로 선택할 수 있습니다. 이 경우, 인터넷 프로토콜 및 경로를 사용하고 로컬 에이전트 터미널과 관련하여 동등한 기능을 사용하여 원격 사이트에서 제어 에이전트를 작동할 수 있는 수단이 필요합니다.

공급업체가 제공하는 제어 에이전트 및 기타 NOC 소프트웨어 도구는 표준 운영 체제에서 사용자 프로그램으로 작동하는 것이 바람직합니다. 라우터와의 통신을 위해 표준 인터넷 프로토콜인 UDP 및 TCP를 사용하면 이를 촉진할 수 있습니다.

원격 라우터 모니터링 및 \(특히\) 원격 라우터 제어는 해결해야 할 중요한 액세스 제어 문제를 나타냅니다. 또한 이러한 기능을 위한 라우터 리소스 사용을 제어할 때도 주의를 기울여야 합니다. 예를 들어, 라우터 모니터링이 라우터 CPU 시간의 일부 제한된 부분 이상을 차지하도록 하는 것은 바람직하지 않습니다. 반면, O&M 기능은 라우터가 혼잡할 때 실행될 수 있도록 우선순위를 받아야 합니다. 왜냐하면 종종 O&M이 가장 필요한 때이기 때문입니다.

---
### **10.3.2 Out Of Band Access**

라우터는 대역 외\(OOB\) 액세스를 지원해야 합니다. OOB 액세스는 대역 내 액세스와 동일한 기능을 제공해야 합니다\(SHOULD\). 이 액세스는 무단 액세스를 방지하기 위해 액세스 제어를 구현해야 합니다.\(MUST, SHOULD, SHOULD\)

논의

- 이 대역외 액세스를 통해 NOC는 네트워크 액세스를 사용할 수 없는 시간 동안 격리된 라우터에 액세스할 수 있습니다.

- 대역외 접속은 네트워크 관리자에게 중요한 관리 도구입니다. 이를 통해 네트워크 연결과 관계없이 장비에 액세스할 수 있습니다. 이러한 접근을 달성하는 방법에는 여러 가지가 있습니다. 어느 것을 사용하든 액세스가 네트워크 연결과 독립적이라는 것이 중요합니다. 대역 외 액세스의 예로는 라우터에 대한 전화 접속 액세스를 제공하는 모뎀에 연결된 직렬 포트가 있습니다.

OOB 액세스가 동일한 기능을 제공하는 것이 중요합니다.

- 대역 내 액세스 기능. 대역 내 액세스 또는 기존 네트워크 연결을 통한 장비 액세스는 제한적입니다. 대부분의 경우 관리자는 장비에 연결할 수 없는 이유를 파악하기 위해 장비에 연결해야 하기 때문입니다. 대역 내 액세스는 라우터를 구성하고 보다 미묘한 문제를 해결하는 데 여전히 매우 중요합니다.

---
### **10.3.2 Router O&M Functions**
---
#### **10.3.2.1 Maintenance - Hardware Diagnosis**

각 라우터는 로컬 하드웨어 유지 관리를 위해 독립형 장치로 작동해야 합니다\(SHOULD\). 현장 도구만 사용하여 라우터 사이트에서 진단 프로그램을 실행할 수 있는 수단을 사용할 수 있어야 합니다. 라우터는 오류가 발생한 경우 진단을 실행할 수 있어야 합니다\(SHOULD\). 제안된 하드웨어 및 소프트웨어 진단에 대해서는 섹션 \[10.3.3\]을 참조하십시오.\(SHOULD, SHOULD, SHOULD\)

---
#### **10.3.2.2 Control - Dumping and Rebooting**

라우터는 네트워크 관리자가 라우터를 다시 로드, 중지 및 다시 시작할 수 있도록 대역 내 및 대역 외 메커니즘을 모두 포함해야 합니다. 라우터에는 소프트웨어나 하드웨어 결함으로 인해 라우터가 중단될 경우 라우터를 자동으로 재부팅하는 메커니즘\(예: 감시 타이머\)도 포함되어야 합니다.\(MUST, SHOULD\)

라우터는 라우터 메모리\(및/또는 충돌 후 벤더 디버깅에 유용한 기타 상태\)의 내용을 덤프하고 이를 로컬의 안정적인 저장 장치에 저장하는 메커니즘을 구현해야 합니다.\(SHOULD\)

라우터에 저장하거나 TFTP와 같은 업라인 덤프 메커니즘을 통해 다른 호스트에 저장합니다\(\[OPER:2\], \[INTRO:3\] 참조\).

---
#### **10.3.2.3 Control - Configuring the Router**

모든 라우터에는 설정해야 할 구성 매개변수가 있습니다. 라우터를 재부팅하지 않고도 매개변수를 업데이트할 수 있어야 합니다. 최악의 경우 다시 시작해야 할 수도 있습니다. 라우터를 재부팅하지 않고 매개변수를 변경하는 것이 불가능한 경우가 있을 수 있습니다\(예: 인터페이스의 IP 주소 변경\). 이러한 경우 라우터와 주변 네트워크의 중단을 최소화하도록 주의를 기울여야 합니다.\(SHOULD\)

네트워크를 통해 수동 또는 자동으로 라우터를 구성하는 방법이 있어야 합니다. 라우터는 호스트나 다른 라우터에서 매개변수를 업로드하거나 다운로드할 수 있어야 합니다. 매개변수 형식과 사람이 편집할 수 있는 형식 사이를 변환하기 위한 수단이 애플리케이션 프로그램이나 라우터 기능으로 제공되어야 합니다. 라우터에는 구성을 위한 일종의 안정적인 저장소가 있어야 합니다. 라우터는 RARP, ICMP 주소 마스크 응답과 같은 프로토콜을 믿어서는 안 되며 BOOTP를 믿어서는 안 됩니다.\(SHOULD, SHOULD, SHOULD, SHOULD, SHOULD NOT\)

논의

- 향후 RARP, ICMP 주소 마스크 응답, BOOTP 및 기타 메커니즘이 라우터의 자동 구성을 허용하는 데 필요할 수 있다는 점에 유의할 필요가 있습니다. 나중에 라우터가 자동으로 구성될 수도 있지만 여기서의 목적은 자동 구성이 보다 철저하게 테스트될 때까지 프로덕션 환경에서 이러한 관행을 권장하지 않는 것입니다. 의도는 자동 구성을 모두 억제하는 것이 아닙니다. 라우터가 자동으로 구성을 가져오도록 예상되는 경우 라우터가 이러한 내용이 나타날 때 이를 믿고 구성을 가져온 후에는 이를 무시하는 것이 현명할 수 있습니다.

---
#### **10.3.2.4 Net Booting of System Software**

- 라우터는 시스템 이미지를 PROM, NVRAM 또는 디스크와 같은 로컬 비휘발성 저장소에 보관해야 합니다. 또한 호스트나 다른 라우터에서 네트워크를 통해 시스템 소프트웨어를 로드할 수도 있습니다.\(SHOULD, MAY\)

- 시스템 이미지를 로컬 비휘발성 저장소에 보관할 수 있는 라우터는 네트워크를 통해 시스템 이미지를 부팅하도록 구성할 수 있습니다. 이 옵션을 제공하는 라우터는 네트워크를 통해 시스템 이미지를 부팅할 수 없는 경우 비휘발성 로컬 저장소에서 시스템 이미지를 부팅하도록 구성할 수 있어야 합니다.\(MAY, SHOULD\)

논의

- 라우터가 스스로 나타나서 실행될 수 있는 것이 중요합니다. NVRAM은 대규모 네트워크에서 사용되는 라우터를 위한 특별한 솔루션일 수 있습니다. 왜냐하면 PROM을 변경하는 것은 다수의 또는 지리적으로 분산된 라우터를 담당하는 네트워크 관리자에게 상당한 시간이 소요될 수 있기 때문입니다. 라우터가 PROM을 설치하는 것보다 더 빨리 버그 수정이나 새로운 기능을 얻을 수 있는 쉬운 방법이 있어야 하기 때문에 시스템 이미지를 네트워크 부팅할 수 있는 것이 중요합니다. 또한 라우터에 PROM 대신 NVRAM이 있는 경우 이미지를 넷부팅한 다음 NVRAM에 넣습니다.

- 라우터는 잘못된 이미지를 감지하고 방지하기 위해 로드된 모든 이미지에 대해 기본적인 일관성 검사를 수행해야 합니다.\(SHOULD\)

라우터는 실행 중인 소프트웨어에 따라 다양한 구성을 구별할 수도 있습니다. 구성 명령이 한 소프트웨어 버전에서 다른 소프트웨어 버전으로 변경되는 경우 라우터가 소프트웨어와 호환되는 구성을 사용할 수 있다면 도움이 될 것입니다.\(MAY\)

---
#### **10.3.2.5 Detecting and responding to misconfiguration**

잘못된 구성을 감지하고 이에 대응하기 위한 메커니즘이 있어야 합니다. 명령이 잘못 실행되면 라우터는 오류 메시지를 표시해야 합니다. 라우터는 잘못된 형식의 명령을 올바른 것처럼 받아들여서는 안 됩니다.\(MUST, SHOULD, SHOULD NOT\)

논의

- 오류를 감지할 수 없는 경우가 있습니다. 명령의 형식은 올바르지만 네트워크 측면에서는 올바르지 않습니다. 이는 라우터에 의해 감지될 수 있지만 불가능할 수도 있습니다.

잘못된 구성의 또 다른 형태는 라우터가 연결된 네트워크의 잘못된 구성입니다. 라우터는 네트워크의 잘못된 구성을 감지할 수 있습니다. 라우터는 이러한 결과를 라우터나 호스트의 파일에 기록할 수 있으므로 네트워크 관리자는 네트워크에 문제가 있을 수 있음을 확인할 수 있습니다.\(MAY, MAY\)

논의

- 이러한 잘못된 구성의 예로는 문제의 라우터와 동일한 주소를 가진 다른 라우터 또는 잘못된 주소 마스크를 가진 라우터가 있을 수 있습니다. 라우터가 이러한 문제를 감지한 경우 라우터가 상황을 해결하려고 시도하는 것은 아마도 최선의 방법이 아닐 것입니다. 이는 득보다 실이 더 클 수 있습니다.

---
#### **10.3.2.6 Minimizing Disruption**

라우터 구성 변경은 네트워크에 미치는 영향을 최소화해야 합니다\(SHOULD\). 라우터에 간단한 변경이 있을 때 라우팅 테이블을 불필요하게 플러시해서는 안 됩니다. 라우터가 여러 라우팅 프로토콜을 실행하는 경우 하나의 라우팅 프로토콜을 중지하면 하나의 네트워크가 둘 이상의 라우팅 프로토콜에 의해 학습되는 경우를 제외하고는 다른 라우팅 프로토콜을 방해해서는 안 됩니다.\(SHOULD, SHOULD NOT, SHOULD NOT\)

논의

- 네트워크 사용자가 최상의 연결성을 얻을 수 있도록 네트워크를 운영하는 것이 네트워크 관리자의 목표입니다. 단순한 구성 변경을 위해 라우터를 다시 로드하면 라우팅이 중단될 수 있으며 궁극적으로 네트워크와 해당 사용자가 중단될 수 있습니다. 예를 들어 라우팅 테이블이 불필요하게 플러시되면 기본 경로는 물론 네트워크 내 사이트에 대한 특정 경로도 손실됩니다. 이러한 종류의 중단으로 인해 사용자는 상당한 다운타임을 겪게 됩니다. 이 섹션의 목적은 가능하면 이러한 중단을 피해야 함을 지적하는 것입니다.

---
#### **10.3.2.7 Control - Troubleshooting Problems**

- \(1\) 라우터는 대역 내 네트워크 액세스를 제공해야 하지만\(섹션 \[8.2\]에서 요구하는 경우 제외\) 보안 고려 사항을 위해 이 액세스는 기본적으로 비활성화되어야 합니다. 공급업체는 모든 대역 내 액세스의 기본 상태를 문서화해야 합니다. 이 액세스는 무단 액세스를 방지하기 위해 액세스 제어를 구현해야 합니다.\(MUST, MUST, SHOULD\)

논의

- 대역 내 액세스는 주로 라우터의 영구 작동 상태에 영향을 줄 수도 있고 그렇지 않을 수도 있는 일반 네트워크 프로토콜을 통한 액세스를 의미합니다. 여기에는 Telnet/RLOGIN 콘솔 액세스 및 SNMP 작업이 포함되지만 이에 국한되지는 않습니다.

- 이것은 기본적으로 운영되는 부대와 보안이 필요한 부대 사이의 논쟁 지점이었습니다. 라우터에 대한 자동 액세스는 보안을 위협할 수 있지만, 연결하자마자 네트워크를 통해 액세스할 수 있는 라우터를 보유하는 것이 고객에게 더 중요할 수 있습니다. 적어도 한 공급업체는 외부 콘솔 액세스 없이 라우터를 제공하며 이에 따라 다릅니다. 구성을 완료하기 위해 네트워크를 통해 라우터에 액세스할 수 있어야 합니다.

- 대역 내 액세스가 기본적으로 활성화되어 있는지 여부는 공급업체가 결정합니다. 그러나 고객에게 잠재적인 불안감을 알리는 것도 공급업체의 책임입니다.

- \(2\) 라우터는 ICMP 에코를 시작하는 기능을 제공해야 합니다. 다음 옵션을 구현해야 합니다.\(MUST, SHOULD\)

```text
           o Choice of data patterns

           o Choice of packet size

           o Record route
```

- 다음과 같은 추가 옵션을 구현할 수도 있습니다.\(MAY\)

```text
           o Loose source route

           o Strict source route

           o Timestamps
```

- \(3\) 라우터는 추적 경로를 시작하는 기능을 제공해야 합니다. 추적 경로가 제공되면 제3자 추적 경로를 구현해야 합니다.\(SHOULD, SHOULD\)

위의 세 가지 시설 각각\(구현된 경우\)에는 승인되지 않은 사람의 남용을 방지하기 위해 접근 제한이 적용되어야 합니다.\(SHOULD\)

---
## **10.4 Security Considerations**
---
### **10.4.1 Auditing and Audit Trails**

감사 및 청구는 네트워크 운영자에게 골칫거리이지만 네트워크 보안 담당자와 요금 지불 담당자가 가장 많이 요청하는 두 가지 기능입니다. 보안 측면에서 감사는 리소스의 가치보다 더 많은 비용을 들이지 않고 네트워크 작동을 유지하고 리소스를 남용으로부터 보호하는 데 도움이 되는 경우 바람직합니다.

```text
   (1) Configuration Changes
```

- 라우터는 운영자의 이니셜과 변경 시간을 기록하는 것만큼 간단한 일이라도 라우터의 구성 변경을 감사하는 방법을 제공해야 합니다.\(SHOULD\)

논의

- 구성 변경 로깅\(구성 변경자, 변경 내용, 시기\)은 특히 트래픽이 갑자기 알래스카를 통과하여 도시를 가로지르는 경우에 매우 유용합니다. 이전 구성으로 되돌리는 기능도 마찬가지입니다.

```text
      (2) Packet Accounting
```

- 공급업체는 호스트 또는 네트워크 쌍 간의 트래픽 수준을 추적하는 시스템 제공을 강력히 고려해야 합니다. 이 정보의 수집을 특정 호스트 또는 네트워크 쌍으로 제한하는 메커니즘도 강력히 권장됩니다.

논의

- 위에서 설명한 호스트 트래픽 매트릭스를 통해 네트워크 운영자는 다른 통계에서는 명확하지 않은 트래픽 추세를 엿볼 수 있습니다. 또한 연결된 네트워크의 구조를 조사하는 호스트나 네트워크\(예: 연결된 네트워크의 네트워크 주소 범위에 있는 모든 IP 주소로 패킷을 보내려고 하는 단일 외부 호스트\)를 식별할 수 있습니다.

```text
      (3) Security Auditing
```

- 라우터는 다음을 포함하여 보안 관련 실패 또는 위반을 감사하는 방법을 제공해야 합니다.\(MUST\)

```text
           o Authorization Failures: bad passwords, invalid SNMP
              communities, invalid authorization tokens,

           o Violations of Policy Controls: Prohibited Source Routes,
              Filtered Destinations, and

           o Authorization Approvals: good passwords - Telnet in-band
              access, console access.
```

- 라우터는 그러한 감사를 제한하거나 비활성화하는 방법을 제공해야 하지만 감사는 기본적으로 켜져 있어야 합니다. 가능한 감사 방법에는 위반이 있는 경우 콘솔에 위반 나열, 내부적으로 로깅 또는 계산, SNMP 트랩 메커니즘 또는 Unix 로깅 메커니즘을 통해 원격 보안 서버에 로깅 등이 포함됩니다. 라우터는 이러한 보고 메커니즘 중 적어도 하나를 구현해야 하며, 둘 이상을 구현할 수도 있습니다.\(MUST, MUST\)

---
### **10.4.2 Configuration Control**

공급업체는 라우터에 대한 소프트웨어/펌웨어 로드 생성 시 올바른 구성 제어 방법을 사용해야 할 책임이 있습니다. 특히 공급업체가 인터넷을 통해 검색할 수 있는 업데이트와 로드를 제공하는 경우 공급업체는 로드에 대한 체크섬 확인을 통해 고객이 로드가 유효한지 확인할 수 있는 방법도 제공해야 합니다.

논의

- 현재 많은 공급업체가 인터넷을 통해 소프트웨어 제품에 대한 긴급 업데이트를 제공하고 있습니다. 이는 좋은 추세이며 권장되어야 하지만 구성 제어 프로세스에 취약점이 있습니다.

공급업체가 고객이 Telnet 세션 등을 통해 원격으로 라우터의 구성 매개변수를 변경할 수 있는 기능을 제공하는 경우, 해당 기능은 구성 가능해야 하며 기본값은 꺼짐으로 설정되어야 합니다. 라우터는 원격 재구성을 허용하기 전에 유효한 인증을 요구해야 합니다\(SHOULD\). 이 인증 절차는 네트워크를 통해 인증 비밀을 전송해서는 안 됩니다. 예를 들어, 텔넷이 구현된 경우 공급업체는 Kerberos, S-Key 또는 유사한 인증 절차를 구현해야 합니다.\(SHOULD, SHOULD, SHOULD NOT, SHOULD\)

논의

- 적절하게 식별된 네트워크 운영자가 라우터를 조작할 수 있도록 허용해야 합니다. 다른 사람이 그렇게 하도록 허용하는 것은 어리석은 일입니다.

라우터에는 문서화되지 않은 백도어 액세스 및 마스터 비밀번호가 있어서는 안 됩니다. 공급업체는 제품이 고객에게 배포되기 전에 디버깅 또는 제품 개발을 위해 추가된 액세스가 삭제되도록 해야 합니다.\(MUST NOT, MUST\)

논의

- 공급업체는 고객이 의도적으로\(예: 대역 내 액세스\) 코드에 존재하는 취약점을 인식하도록 할 책임이 있습니다. 의도적이든 아니든 트랩 도어, 백도어 및 마스터 비밀번호는 상대적으로 안전한 라우터를 운영 네트워크의 주요 문제로 만들 수 있습니다. 가정된 운영상의 이점은 잠재적인 문제와 일치하지 않습니다.

---
## **11. REFERENCES**

구현자는 인터넷 프로토콜 표준이 때때로 업데이트된다는 점을 알고 있어야 합니다. 이러한 참조는 이 글을 쓰는 시점에서 최신이지만, 신중한 구현자는 항상 RFC 색인의 최신 버전을 확인하여 RFC가 업데이트되거나 다른 최신 RFC로 대체되지 않았는지 확인해야 합니다. 참조 \[INTRO:6\]에서는 현재 RFC 색인을 얻는 다양한 방법을 설명합니다.

APPL:1.

- Croft, B. 및 J. Gilmore, "부트스트랩 프로토콜\(BOOTP\)", RFC 951, Stanford University, Sun Microsystems, 1985년 9월.

애플:2.

- Alexander, S. 및 R. Droms, "DHCP 옵션 및 BOOTP 공급업체 확장", RFC 1533, Lachman Technology, Inc., Bucknell University, 1993년 10월.

애플:3.

- Wimer, W., "부트스트랩 프로토콜에 대한 설명 및 확장", RFC 1542, Carnegie Mellon University, 1993년 10월.

```text
   ARCH:1.
        DDN Protocol Handbook, NIC-50004, NIC-50005, NIC-50006 (three
        volumes), DDN Network Information Center, SRI International,
        Menlo Park, California, USA, December 1985.
```

아치:2.

- V. Cerf 및 R. Kahn, "패킷 네트워크 상호 통신을 위한 프로토콜", IEEE Transactions on Communication, 1974년 5월. \[ARCH:1\]에도 포함되어 있습니다.

아치:3.

- J. Postel, C. Sunshine 및 D. Cohen, "The ARPA Internet Protocol", 컴퓨터 네트워크, 5권, 4호, 1981년 7월. \[ARCH:1\]에도 포함되어 있습니다.

아치:4.

- B. Leiner, J. Postel, R. Cole 및 D. Mills, :The DARPA Internet Protocol Suite", INFOCOM '85 회보, IEEE, 워싱턴 DC, 1985년 3월. 추가 자료: IEEE Communications Magazine, 1985년 3월 또한 University of Southern California의 Information Sciences Institute에서 기술 보고서 ​​ISI-RS-85-153으로 제공됩니다.

아치:5.

- D. Comer, "TCP/IP 1권과의 인터네트워킹: 원리, 프로토콜 및 아키텍처", Prentice Hall, Englewood Cliffs, NJ, 1991.

아치:6.

- W. Stallings, "컴퓨터 통신 표준 핸드북 3권: TCP/IP 프로토콜 제품군", Macmillan, New York, NY, 1990.

```text
   ARCH:7.
        Postel, J., "Internet Official Protocol Standards", STD 1, RFC
        1780, Internet Architecture Board, March 1995.

   ARCH:8.
        Information processing systems - Open Systems Interconnection -
        Basic Reference Model, ISO 7489, International Standards
        Organization, 1984.
```

아치:9

- R. Braden, J. Postel, Y. Rekhter, "공유 미디어를 위한 인터넷 아키텍처 확장", 1994년 5월 20일

```text
   FORWARD:1.
        IETF CIP Working Group (C. Topolcic, Editor), "Experimental
        Internet Stream Protocol", Version 2 (ST-II), RFC 1190, October
        1990.
```

앞으로:2.

- Mankin, A. 및 K. Ramakrishnan, 편집자, "Gateway Congestion Control Survey", RFC 1254, MITRE, Digital Equipment Corporation, 1991년 8월.

앞으로:3.

- J. Nagle, "무한 저장 장치를 갖춘 패킷 스위치에서", IEEE Transactions on Communications, 볼륨 COM-35, 4호, 1987년 4월.

앞으로:4.

- R. Jain, K. Ramakrishnan 및 D. Chiu, "무연결 네트워크 계층을 사용하는 컴퓨터 네트워크의 혼잡 방지", 기술 보고서 ​​DEC-TR-506, Digital Equipment Corporation.

앞으로:5.

- V. Jacobson, "혼잡 방지 및 제어", SIGCOMM '88 간행물, 컴퓨팅 기계 협회, 1988년 8월.

앞으로:6.

- W. Barns, "국방부 데이터 네트워크의 우선순위 및 우선순위 액세스 구현", 기술 보고서 ​​MTR-91W00029, The Mitre Corporation, 미국 버지니아주 맥클린, 1991년 7월.

앞으로:7

- Fang, Chen, Hutchins, "흐름 제어가 있거나 없는 ATM을 통한 TCP 성능 시뮬레이션 결과", ATM 포럼 프레젠테이션, 1993년 11월 15일.

앞으로:8

- V. Paxson, S. Floyd "광역 교통: 포아송 모델링의 실패", SIGCOMM '94의 짧은 버전.

앞으로:9

- Leland, Taqqu, Willinger 및 Wilson, "이더넷 트래픽의 자기 유사성", SIGCOMM '93 회보, 1993년 9월.

앞으로:10

- S. Keshav "흐름 제어에 대한 제어 이론적 접근 방식", SIGCOMM 91, 페이지 3-16

앞으로:11

-K.K. Ramakrishnan 및 R. Jain, "컴퓨터 네트워크의 혼잡 회피를 위한 이진 피드백 체계", 컴퓨터 시스템의 ACM 트랜잭션, 8권, 2번, 1980년.

앞으로:12

- H. Kanakia, P. Mishara 및 A. Reibman\]. "실시간 패킷 비디오 전송을 위한 적응형 혼잡 제어 방식", ACM SIGCOMM 1994 회보, 페이지 20-31, 캘리포니아주 샌프란시스코, 1993년 9월.

앞으로:13

- A. Demers, S. Keshav, S. Shenker, "공정한 대기열 알고리즘 분석 및 시뮬레이션", 93페이지 1-12

앞으로:14

- Clark, D., Shenker, S. 및 L. Zhang, "통합 서비스 패킷 네트워크에서 실시간 애플리케이션 지원: 아키텍처 및 메커니즘", 92페이지 14-26

```text
   INTERNET:1.
        Postel, J., "Internet Protocol", STD 5, RFC 791, USC/Information
        Sciences Institute, September 1981.
```

인터넷:2.

- Mogul, J. 및 J. Postel, "인터넷 표준 서브넷 절차", STD 5, RFC 950, Stanford, USC/Information Sciences Institute, 1985년 8월.

인터넷:3.

- Mogul, J., "서브넷이 있는 상태에서 인터넷 데이터그램 방송", STD 5, RFC 922, 스탠포드 대학교, 1984년 10월.

인터넷:4.

- Deering, S., "IP 멀티캐스팅을 위한 호스트 확장", STD 5, RFC 1112, 스탠포드 대학교, 1989년 8월.

인터넷:5.

- Kent, S., "인터넷 프로토콜에 대한 미국 국방부 보안 옵션", RFC 1108, BBN Communications, 1991년 11월.

인터넷:6.

- Braden, R., Borman, D. 및 C. Partridge, "인터넷 체크섬 계산", RFC 1071, USC/정보 과학 연구소, Cray Research, BBN Communications, 1988년 9월.

인터넷:7.

- Mallory T. 및 A. Kullberg, "인터넷 체크섬의 증분 업데이트", RFC 1141, BBN Communications, 1990년 1월.

```text
   INTERNET:8.
        Postel, J., "Internet Control Message Protocol", STD 5, RFC 792,
        USC/Information Sciences Institute, September 1981.
```

인터넷:9.

- A. Mankin, G. Hollingsworth, G. Reichlen, K. Thompson, R. Wilder 및 R. Zahavi, "인터넷 성능 평가 - FY89", 기술 보고서 ​​MTR-89W00216, MITRE Corporation, 1990년 2월.

인터넷:10.

- G. Finn, "무연결 혼잡 제어 알고리즘", Computer Communications Review, 19권, 5호, Association for Computing Machinery, 1989년 10월.

인터넷:11.

- Prue, W. 및 J. Postel, "SQuID\(Source Quench에 의한 지연\)", RFC 1016, USC/정보 과학 연구소, 1987년 8월.

인터넷:12.

- McKenzie, A., "SQuID에 대한 일부 의견", RFC 1018, BBN Labs, 1987년 8월.

```text
   INTERNET:13.
        Deering, S., "ICMP Router Discovery Messages", RFC 1256, Xerox
        PARC, September 1991.
```

인터넷:14.

- Mogul J. 및 S. Deering, "Path MTU Discovery", RFC 1191, DECWRL, 스탠포드 대학교, 1990년 11월.

인터넷:15

- Fuller, V., Li, T., Yu, J. 및 K. Varadhan, "클래스 없는 도메인 간 라우팅\(CIDR\): 주소 할당 및 집계 전략" RFC 1519, BARRNet, cisco, Merit, OARnet, 9월 1993.

```text
   INTERNET:16
        St.  Johns, M., "Draft Revised IP Security Option", RFC 1038,
        IETF, January 1988.
```

인터넷:17

- Prue, W. 및 J. Postel, "IP 링크에 대한 서비스 유형을 제공하는 대기열 알고리즘", RFC 1046, USC/정보 과학 연구소, 1988년 2월.

```text
   INTERNET:18
        Postel, J., "Address Mappings", RFC 796, USC/Information
        Sciences Institute, September 1981.
```

소개:1.

- Braden, R. 및 J. Postel, "인터넷 게이트웨이 요구 사항", STD 4, RFC 1009, USC/정보 과학 연구소, 1987년 6월.

소개:2.

- 인터넷 엔지니어링 태스크 포스\(R. Braden, 편집자\), "인터넷 호스트에 대한 요구 사항 - 통신 계층", STD 3, RFC 1122, USC/Information Sciences Institute, 1989년 10월.

소개:3.

- 인터넷 엔지니어링 태스크 포스\(R. Braden, 편집자\), "인터넷 호스트에 대한 요구 사항 - 응용 프로그램 및 지원", STD 3, RFC 1123, USC/Information Sciences Institute, 1989년 10월.

소개:4.

- Clark, D., "프로토콜 구현의 모듈화 및 효율성", RFC 817, MIT 컴퓨터 과학 연구소, 1982년 7월.

소개:5.

- Clark, D., "업콜을 사용한 시스템 구조화", 10차 ACM SOSP 간행물, 1985년 12월.

소개:6.

- Jacobsen, O. 및 J. Postel, "프로토콜 문서 순서 정보", RFC 980, SRI, USC/정보 과학 연구소, 1986년 3월.

소개:7.

- Reynolds, J. 및 J. Postel, "할당된 번호", STD 2, RFC 1700, USC/정보 과학 연구소, 1994년 10월. 이 문서는 정기적으로 업데이트되고 새 번호로 재발행됩니다. 가지고 있는 버전이 아직 최신인지 가끔 확인하는 것이 좋습니다.

소개:8.

- DoD 신뢰할 수 있는 컴퓨터 시스템 평가 기준, DoD 간행물 5200.28-STD, 미국 국방부, 1985년 12월.

소개:9

- Malkin, G. 및 T. LaQuey Parker, 편집자, "인터넷 사용자 용어집", FYI 18, RFC 1392, Xylogics, Inc., UTexas, 1993년 1월.

링크:1.

- Leffler, S. 및 M. Karels, "트레일러 캡슐화", RFC 893, University of California at Berkeley, 1984년 4월.

```text
   LINK:2
        Simpson, W., "The Point-to-Point Protocol (PPP)", STD 51, RFC
        1661, Daydreamer July 1994.

   LINK:3
        McGregor, G., "The PPP Internet Protocol Control Protocol
        (IPCP)", RFC 1332, Merit May 1992.
```

링크:4

- Lloyd, B. 및 W. Simpson, "PPP 인증 프로토콜", RFC 1334, L&A, Daydreamer, 1992년 5월.

```text
   LINK:5
        Simpson, W., "PPP Link Quality Monitoring", RFC 1333,
        Daydreamer, May 1992.
```

MGT:1.

- Rose, M. 및 K. McCloghrie, "TCP/IP 기반 인터넷의 관리 정보 구조 및 식별", STD 16, RFC 1155, Performance Systems International, Hughes LAN Systems, 1990년 5월.

MGT:2.

- McCloghrie, K. 및 M. Rose\(편집자\), "TCP/IP 기반 인터넷의 관리 정보 기반: MIB-II", STD 16, RFC 1213, Hughes LAN Systems, Inc., Performance Systems International, 1991년 3월 .

MGT:3.

- Case, J., Fedor, M., Schoffstall, M. 및 J. Davin, "간단한 네트워크 관리 프로토콜", STD 15, RFC 1157, SNMP 연구, Performance Systems International, MIT 컴퓨터 과학 연구소, 1990년 5월.

MGT:4.

- Rose, M. 및 K. McCloghrie\(편집자\), "간결한 MIB 정의를 향하여", STD 16, RFC 1212, Performance Systems International, Hughes LAN Systems, 1991년 3월.

MGT:5.

- Steinberg, L., "비동기적으로 생성된 경고 관리 기술", RFC 1224, IBM Corporation, 1991년 5월.

MGT:6.

- Kastenholz, F., "이더넷 유사 인터페이스 유형에 대한 관리 개체 정의", RFC 1398, FTP Software, Inc., 1993년 1월.

MGT:7.

- McCloghrie, K. 및 R. Fox "IEEE 802.4 토큰 버스 MIB", RFC 1230, Hughes LAN Systems, Inc., Synoptics, Inc., 1991년 5월.

MGT:8.

- McCloghrie, K., Fox R. 및 E. Decker, "IEEE 802.5 Token Ring MIB", RFC 1231, Hughes LAN Systems, Inc., Synoptics, Inc., cisco Systems, Inc., 1993년 2월.

MGT:9.

- Case, J. 및 A. Rijsinghani, "FDDI 관리 정보 베이스", RFC 1512, The University of Tennesse 및 SNMP Research, Digital Equipment Corporation, 1993년 9월.

MGT:10.

- Stewart, B., 편집자 "RS-232와 유사한 하드웨어 장치에 대한 관리 개체 정의", RFC 1317, Xyplex, Inc., 1992년 4월.

MGT:11.

- Kastenholz, F., "지점 간 프로토콜의 링크 제어 프로토콜에 대한 관리 개체 정의", RFC 1471, FTP Software, Inc., 1992년 6월.

MGT:12.

- Kastenholz, F., "지점 간 프로토콜의 보안 프로토콜에 대한 관리 개체 정의", RFC 1472, FTP Software, Inc., 1992년 6월.

MGT:13.

- Kastenholz, F., "지점 간 프로토콜의 IP 네트워크 제어 프로토콜에 대한 관리 개체 정의", RFC 1473, FTP Software, Inc., 1992년 6월.

MGT:14.

- Baker, F. 및 R. Coltun, "OSPF 버전 2 관리 정보 베이스", RFC 1253, ACC, 컴퓨터 과학 센터, 1991년 8월.

MGT:15.

- Willis, S. 및 J. Burruss, "Border Gateway Protocol\(버전 3\)에 대한 관리 개체 정의", RFC 1269, Wellfleet Communications Inc., 1991년 10월.

MGT:16.

- Baker, F. 및 J. Watt, "DS1 및 E1 인터페이스 유형에 대한 관리 개체 정의", RFC 1406, Advanced Computer Communications, Newbridge Networks Corporation, 1993년 1월.

MGT:17.

- Cox, T. 및 K. Tesink, 편집자 "DS3/E3 인터페이스 유형에 대한 관리 개체 정의", RFC 1407, Bell Communications Research, 1993년 1월.

MGT:18.

- McCloghrie, K., "일반 인터페이스 MIB 확장", RFC 1229, Hughes LAN Systems, 1992년 8월.

MGT:19.

- Cox, T. 및 K. Tesink, "SIP 인터페이스 유형에 대한 관리 개체 정의", RFC 1304, Bell Communications Research, 1992년 2월.

```text
   MGT:20
        Baker, F., "IP Forwarding Table MIB", RFC 1354, ACC, July 1992.
```

MGT:21.

- Malkin, G. 및 F. Baker, "RIP 버전 2 MIB 확장", RFC 1724, Xylogics, Inc., Cisco Systems, 1994년 11월

MGT:22.

- Throop, D., "X.25 패킷 계층을 위한 SNMP MIB 확장", RFC 1382, Data General Corporation, 1992년 11월.

MGT:23.

- Throop, D. 및 F. Baker, "X.25 LAPB용 SNMP MIB 확장", RFC 1381, Data General Corporation, ACC, 1992년 11월.

MGT:24.

- Throop, D. 및 F. Baker, "X.25를 통한 다중 프로토콜 상호 연결을 위한 SNMP MIB 확장", RFC 1461, Data General Corporation, 1993년 5월.

MGT:25.

- Rose, M., "OSI를 통한 SNMP", RFC 1418, Dover Beach Consulting, Inc., 1993년 3월.

MGT:26.

- Minshall, G. 및 M. Ritter, "AppleTalk를 통한 SNMP", RFC 1419, Novell, Inc., Apple Computer, Inc., 1993년 3월.

MGT:27.

- Bostock, S., "IPX를 통한 SNMP", RFC 1420, Novell, Inc., 1993년 3월.

MGT:28.

- Schoffstall, M., Davin, C., Fedor, M. 및 J. Case, "이더넷을 통한 SNMP", RFC 1089, Rensselaer Polytechnic Institute, MIT 컴퓨터 과학 연구소, NYSERNet, Inc., University of Tennessee at Knoxville , 1989년 2월.

```text
   MGT:29.
        Case, J., "FDDI Management Information Base", RFC 1285, SNMP
        Research, Incorporated, January 1992.
```

운영:1.

- Nagle, J., "IP/TCP 인터네트워크의 혼잡 제어", RFC 896, FACC, 1984년 1월.

```text
   OPER:2.
        Sollins, K., "TFTP Protocol (revision 2)", RFC 1350, MIT, July
        1992.

   ROUTE:1.
        Moy, J., "OSPF Version 2", RFC 1583, Proteon, March 1994.
```

경로:2.

- Callon, R., "TCP/IP 및 이중 환경의 라우팅을 위한 OSI IS-IS 사용", RFC 1195, DEC, 1990년 12월.

```text
   ROUTE:3.
        Hedrick, C., "Routing Information Protocol", RFC 1058, Rutgers
        University, June 1988.
```

경로:4.

- Lougheed, K. 및 Y. Rekhter, "BGP-3\(Border Gateway Protocol 3\)", RFC 1267, cisco, T.J. Watson 연구 센터, IBM Corp., 1991년 10월.

경로:5.

- Gross, P 및 Y. Rekhter, "인터넷에서 경계 게이트웨이 프로토콜 적용", RFC 1772, T.J. Watson 연구 센터, IBM Corp., MCI, 1995년 3월.

```text
   ROUTE:6.
        Mills, D., "Exterior Gateway Protocol Formal Specification", RFC
        904, UDEL, April 1984.

   ROUTE:7.
        Rosen, E., "Exterior Gateway Protocol (EGP)", RFC 827, BBN,
        October 1982.
```

경로:8.

- Seamonson, L 및 E. Rosen, "STUB" "외부 게이트웨이 프로토콜", RFC 888, BBN, 1984년 1월.

경로:9.

- Waitzman, D., Partridge, C. 및 S. Deering, "거리 벡터 멀티캐스트 라우팅 프로토콜", RFC 1075, BBN, Stanford, 1988년 11월.

경로:10.

- Deering, S., 인터네트워크 및 확장 LAN의 멀티캐스트 라우팅, '88 논문집, 컴퓨팅 기계 협회, 1988년 8월.

경로:11.

- Almquist, P., "인터넷 프로토콜 제품군의 서비스 유형", RFC 1349, 컨설턴트, 1992년 7월.

경로:12.

- Rekhter, Y., "BGP 프로토콜 경험", RFC 1266, T.J. Watson 연구 센터, IBM Corp., 1991년 10월.

```text
   ROUTE:13.
        Rekhter, Y., "BGP Protocol Analysis", RFC 1265, T.J. Watson
        Research Center, IBM Corp., October 1991.

   TRANS:1.
        Postel, J., "User Datagram Protocol", STD 6, RFC 768,
        USC/Information Sciences Institute, August 1980.

   TRANS:2.
        Postel, J., "Transmission Control Protocol", STD 7, RFC 793,
        USC/Information Sciences Institute, September 1981.
```

---
# **APPENDIX A. REQUIREMENTS FOR SOURCE-ROUTING HOSTS**

아래에 주어진 제한에 따라 호스트는 소스 경로의 데이터그램을 다음 지정된 홉으로 전달하여 소스 경로에서 중간 홉 역할을 할 수 있습니다.\(MAY\)

그러나 이 라우터와 같은 기능을 수행할 때 호스트는 소스 라우팅 데이터그램을 전달하는 라우터에 대한 모든 관련 규칙을 준수해야 합니다\[INTRO:2\]. 여기에는 다음과 같은 특정 조항이 포함됩니다.\(MUST\)

\(가\) TTL

- TTL 필드는 감소되어야 하며 \[INTRO:2\]의 라우터에 대해 지정된 대로 데이터그램은 폐기되어야 합니다.\(MUST\)

\(B\) ICMP 대상에 연결할 수 없음

- 호스트는 다음 코드를 사용하여 대상 도달 불가능 메시지를 생성할 수 있어야 합니다. 4\(조각화가 필요하지만 DF 세트\) 소스 라우팅 데이터그램을 대상 네트워크에 맞게 조각화할 수 없는 경우; 5\(소스 경로 실패\) 소스 라우팅 데이터그램을 전달할 수 없는 경우\(예: 라우팅 문제로 인해 또는 엄격한 소스 경로의 다음 홉이 연결된 네트워크에 있지 않기 때문\)\(MUST\)

\(C\) IP 소스 주소

- 전달되는 소스 라우팅 데이터그램은 전달 호스트의 IP 주소 중 하나가 아닌 소스 주소를 가질 수 있습니다\(일반적으로 그럴 것입니다\).\(MAY\)

\(D\) 경로 기록 옵션

- Record Route 옵션을 포함하는 소스 라우팅 데이터그램을 전달하는 호스트는 공간이 있는 경우 해당 옵션을 업데이트해야 합니다.\(MUST\)

\(E\) 타임스탬프 옵션

- 타임스탬프 옵션을 포함하는 소스 라우팅 데이터그램을 전달하는 호스트는 이 옵션에 대한 규칙에 따라 해당 옵션에 현재 타임스탬프를 추가해야 합니다.\(MUST\)

소스 라우팅된 데이터그램의 호스트 전달을 제한하는 규칙을 정의하기 위해 다음 홉이 데이터그램이 도착한 것과 동일한 물리적 인터페이스를 통과하는 경우 로컬 소스 라우팅이라는 용어를 사용합니다. 그렇지 않으면 비로컬 소스 라우팅입니다.

호스트는 제한 없이 로컬 소스 라우팅을 수행할 수 있습니다.

비로컬 소스 라우팅을 지원하는 호스트에는 전달을 비활성화하도록 구성 가능한 스위치가 있어야 하며 이 스위치는 기본적으로 비활성화되어야 합니다.\(MUST\)

호스트는 비로컬 전달을 제한하는 구성 가능한 정책 필터\[INTRO:2\]에 대한 모든 라우터 요구 사항을 충족해야 합니다.\(MUST\)

호스트가 불완전한 소스 경로가 있는 데이터그램을 수신했지만 어떤 이유로 이를 전달하지 않는 경우, 호스트는 데이터그램 자체가 ICMP 오류 메시지가 아닌 한 ICMP 목적지 도달 불가능\(코드 5, 소스 경로 실패\) 메시지를 반환해야 합니다.\(SHOULD\)

---
# **APPENDIX B. GLOSSARY**

이 부록은 이 메모에 사용된 특정 용어를 정의합니다. 또한 관심을 가질 수 있는 몇 가지 일반적인 목적의 용어를 정의합니다. 보다 일반적인 정의 세트는 \[소개:9\]를 참조하세요.

자율 시스템\(AS\)

- 자율 시스템\(AS\)은 일련의 경로로 상호 연결된 하위 네트워크\(호스트가 연결된\) 모음으로 구성된 네트워크 토폴로지의 연결된 세그먼트입니다. 서브네트워크와 라우터는 단일 운영 및 유지 관리\(O&M\) 조직의 통제를 받을 것으로 예상됩니다. AS 내에서 라우터는 하나 이상의 내부 라우팅 프로토콜과 때로는 여러 메트릭 세트를 사용할 수 있습니다. AS는 일관성 있는 내부 라우팅 계획의 모습과 AS를 통해 도달할 수 있는 목적지에 대한 일관된 그림을 다른 AS에게 제공할 것으로 예상됩니다. AS는 자율 시스템 번호로 식별됩니다. 연결된 네트워크 라우터가 인터페이스되는 네트워크 접두사는 로컬 네트워크 또는 해당 라우터의 하위 네트워크라고도 합니다. 그러나 이러한 용어는 혼동을 일으킬 수 있으므로 이 문서에서는 연결된 네트워크라는 용어를 사용합니다.

연결된 \(하위\)네트워크

- 연결된 \(서브\)네트워크는 라우터가 인터페이스되는 IP 서브네트워크이거나, 연결된 네트워크가 서브넷화되지 않은 경우 연결된 네트워크입니다. 연결된 네트워크를 참조하세요.

데이터그램

- 한 쌍의 인터넷 모듈 간에 전송되는 단위입니다. 데이터그램이라고 하는 데이터는 소스에서 대상까지 전달됩니다. 인터넷 프로토콜은 안정적인 통신 시설을 제공하지 않습니다. 종단 간 또는 홉별 승인은 없습니다. 오류가 없으며 재전송이 없습니다. 흐름 제어가 없습니다. IP를 참조하세요.

기본 경로

- 라우팅 테이블에 명시적으로 나열되지 않은 네트워크 접두사로 주소가 지정된 데이터를 전달하는 데 사용되는 라우팅 테이블 항목입니다.

밀집 모드

- 멀티캐스트 전달에서는 두 가지 패러다임이 가능합니다. 밀도 모드 전달에서 네트워크 멀티캐스트는 라우터가 멀티캐스트 라우팅에 의해 지시되지 않는 한 수신된 인터페이스를 제외한 모든 인터페이스에 데이터 링크 계층 멀티캐스트로 전달됩니다. 이웃. 스파스 모드를 참조하세요.

EGP

- 외부 게이트웨이 프로토콜\(Exterior Gateway Protocol\) 자율 시스템을 연결하는 게이트웨이\(라우터\)에 라우팅 정보를 분배하는 프로토콜. IGP를 참조하세요.

EGP-2

- Exterior Gateway Protocol version 2 인터넷 상에서 Autonomous System 간의 트래픽을 처리하기 위해 개발된 EGP 라우팅 프로토콜입니다.

전달자

- 라우터 인터페이스 간 패킷 전환을 담당하는 라우터 내의 논리적 엔터티입니다. 또한 포워더는 로컬 배달을 위해 패킷을 대기열에 넣을지, 다른 인터페이스로 전송하기 위해 패킷을 대기열에 넣을지, 또는 두 가지 모두를 결정합니다.

전송

- 전달은 라우터가 수신한 각 패킷에 대해 라우터가 거치는 프로세스입니다. 패킷은 라우터에 의해 소비될 수도 있고, 라우터의 하나 이상의 인터페이스에 출력되거나, 둘 다에 출력될 수도 있습니다. 전달에는 패킷을 어떻게 처리할지 결정하고 \(가능한\) 출력 또는 내부 소비를 위해 대기열에 넣는 프로세스가 포함됩니다.

전달 정보 베이스\(FIB\)

- 이 문서에서는 IP 데이터그램을 전달하는 데 필요한 정보가 포함된 테이블을 전달 정보 베이스라고 합니다. 최소한 여기에는 도달 가능한 각 대상 네트워크 접두사에 대한 인터페이스 식별자와 다음 홉 정보가 포함됩니다.

파편

- 너무 커서 출력 네트워크를 통해 전체를 보낼 수 없는 상위 계층 패킷의 일부를 나타내는 IP 데이터그램입니다.

범용 직렬 인터페이스

- 정확히 두 시스템을 연결할 수 있는 물리적 매체이므로 점대점 회선으로 구성할 수 있을 뿐만 아니라 X.25 또는 프레임 릴레이와 같은 프로토콜을 사용하여 링크 계층 네트워킹을 지원하도록 구성할 수도 있습니다. 링크 계층 네트워크는 다른 시스템을 스위치에 연결하고 상위 통신 계층은 연결에서 가상 회선을 다중화합니다. 점대점 선을 참조하세요.

IGP

- Interior Gateway Protocol AS\(Autonomous System\)로 라우팅 정보를 분배하는 프로토콜. EGP를 참조하세요.

인터페이스 IP 주소

- 라우터의 특정 인터페이스에 할당된 IP 주소 및 네트워크 접두사 길이입니다.

인터넷 주소

- 인터넷에서 호스트를 식별하는 할당된 번호입니다. 이는 IP 주소와 접두사 길이의 두 부분으로 구성됩니다. 접두사 길이는 네트워크 접두사를 구성하는 주소의 가장 구체적인 비트 수를 나타냅니다.

IP

- 인터넷 프로토콜 인터넷의 네트워크 계층 프로토콜입니다. 이는 RFC 791에 정의된 패킷 교환, 데이터그램 프로토콜입니다. IP는 안정적인 통신 기능을 제공하지 않습니다. 즉, 홉별 승인의 종단간이 없습니다.

IP 데이터그램

- IP 데이터그램은 인터넷 프로토콜의 종단 간 전송 단위입니다. IP 데이터그램은 IP 헤더와 모든 상위 계층 데이터\(예: TCP, UDP, ICMP 등\)로 구성됩니다. IP 데이터그램은 메시지가 뒤따르는 IP 헤더입니다.

- IP 데이터그램은 완전한 IP 종단 간 전송 단위입니다. IP 데이터그램은 하나 이상의 IP 조각으로 구성됩니다.

- 본 메모에서 비수식어인 데이터그램은 IP 데이터그램을 의미하는 것으로 이해되어야 합니다.

IP 조각

- IP 조각은 IP 데이터그램의 구성 요소입니다. IP 조각은 IP 헤더와 원본 IP 데이터그램의 상위 계층 전체 또는 일부로 구성됩니다.

- 하나 이상의 IP 조각이 단일 IP 데이터그램으로 구성됩니다.

- 본 메모에서 Fragment라는 비한정 용어는 IP Fragment를 의미하는 것으로 이해되어야 합니다.

IP 패킷

- IP 데이터그램 또는 IP 조각.

- 본 메모에서 한정되지 않은 용어인 패킷은 일반적으로 IP 패킷을 의미하는 것으로 이해되어야 합니다.

논리적 \[네트워크\] 인터페이스

- 논리적 \[네트워크\] 인터페이스는 연결된 네트워크에 대한 고유한 IP 주소로 구별되는 논리적 경로로 정의됩니다.

화성 필터링

- 잘못된 소스 또는 대상 주소가 포함된 패킷은 화성인 것으로 간주되어 폐기됩니다.

MTU\(최대 전송 단위\)

- 논리적 인터페이스를 통해 전송 또는 수신할 수 있는 가장 큰 패킷의 크기입니다. 이 크기에는 IP 헤더가 포함되지만 링크 계층 헤더 또는 프레이밍의 크기는 포함되지 않습니다.

멀티캐스트

- 여러 호스트를 대상으로 하는 패킷입니다. 방송을 참조하세요.

멀티캐스트 주소

- 여러 호스트가 인식할 수 있는 특수한 유형의 주소입니다.

- 멀티캐스트 주소는 기능 주소 또는 그룹 주소라고도 합니다.

네트워크 접두사

- 시스템 집합을 나타내는 IP 주소 부분입니다. 이는 주소와 서브넷 마스크를 논리적으로 AND하거나 \(동등하게\) 주소의 가장 중요한 <prefix-length\> 비트에 포함되지 않은 주소 비트를 0으로 설정하여 IP 주소에서 선택됩니다.

유래

- 패킷은 두 가지 이유 중 하나로 라우터에 의해 전송될 수 있습니다: 1\) 패킷이 수신되어 전달되고 있거나 2\) 라우터 자체가 전송용 패킷\(예: 경로 광고\)을 생성했습니다. 라우터가 전송을 위해 생성하는 패킷은 라우터에서 시작된다고 합니다.

패킷

- 패킷은 인터넷 계층과 링크 계층 사이의 인터페이스를 통해 전달되는 데이터 단위입니다. 여기에는 IP 헤더와 데이터가 포함됩니다. 패킷은 완전한 IP 데이터그램일 수도 있고 IP 데이터그램의 단편일 수도 있습니다.

길

- 패킷이 특정 라우터에서 특정 대상 호스트로 통과하는 라우터 및 \(하위\)네트워크의 순서입니다. 경로는 단방향입니다. 주어진 호스트 쌍 사이의 두 방향에서 서로 다른 경로를 갖는 것은 드문 일이 아닙니다.

물리적 네트워크

- 물리적 네트워크는 링크 계층에서 연속적인 네트워크\(또는 인터넷의 일부\)입니다. 내부 구조\(있는 경우\)는 인터넷 계층에 투명합니다.

- 이 메모에서 브리지나 리피터와 같은 장치를 사용하여 연결된 여러 미디어 구성 요소는 이러한 장치가 IP에 투명하므로 단일 물리적 네트워크로 간주됩니다.

물리적 네트워크 인터페이스

- 이것은 연결된 네트워크에 대한 물리적 인터페이스이며 \(아마도 고유한\) 링크 계층 주소를 가지고 있습니다. 단일 라우터의 여러 물리적 네트워크 인터페이스는 동일한 링크 계층 주소를 공유할 수 있지만 주소는 동일한 물리적 네트워크의 여러 라우터에 대해 고유해야 합니다.

점대점 선

- 정확히 두 시스템을 연결할 수 있는 물리적 매체입니다. 본 문서에서는 IP 엔터티를 연결하는 데 사용될 때만 해당 회선을 참조하는 데 사용됩니다. 범용 직렬 인터페이스를 참조하세요.

라우터

- 여러 네트워크를 연결하는 특수 목적의 전용 컴퓨터입니다. 라우터는 전달이라는 프로세스를 통해 이러한 네트워크 간에 패킷을 전환합니다. 이 프로세스는 패킷이 최종 목적지에 전달될 수 있을 때까지 여러 라우터에 의해 단일 패킷에 대해 여러 번 반복될 수 있습니다. 즉, 패킷이 목적지에 도달할 때까지 라우터에서 라우터로, 라우터로 패킷을 전환합니다.

RPF

- 역방향 경로 전달\(Reverse Path Forwarding\) - 브로드캐스트 및 멀티캐스트 패킷에 대한 다음 홉을 추론하는 데 사용되는 방법입니다.

조용히 폐기

- 이 메모는 라우터가 수신된 패킷\(또는 데이터그램\)을 자동으로 폐기해야 하는 몇 가지 경우를 지정합니다. 이는 라우터가 추가 처리 없이 패킷을 폐기해야 하며 결과적으로 라우터가 ICMP 오류 메시지\(섹션 \[4.3.2\] 참조\)를 보내지 않음을 의미합니다. 그러나 문제 진단을 위해 라우터는 자동으로 폐기된 패킷의 내용을 포함하여 오류를 기록하는 기능\(섹션 \[1.3.3\] 참조\)을 제공해야 하며 통계 카운터에 이벤트를 기록해야 합니다.

조용히 무시

- 라우터가 오류 로그나 일부 네트워크 관리 프로토콜을 통해 오류 보고서를 생성하고 오류의 원인을 삭제하거나 무시하는 것 외에 아무런 조치도 취하지 않으면 오류나 조건을 자동으로 무시한다고 합니다. 특히 라우터는 ICMP 오류 메시지를 생성하지 않습니다.

스파스 모드

- 멀티캐스트 전달에서는 두 가지 패러다임이 가능합니다. 스파스 모드 전달에서는 네트워크 계층 멀티캐스트 데이터그램이 이를 요청한 라우터와 호스트에 데이터 링크 계층 멀티캐스트 프레임으로 전달됩니다. 초기 전달 상태는 네트워크의 어떤 부분도 데이터를 원하지 않는다고 가정한다는 점에서 밀집 모드와 반대입니다. 밀집 모드를 참조하세요.

특정 목적지 주소

- 헤더에 IP 브로드캐스트 또는 IP 멀티캐스트 주소가 포함되어 있지 않은 경우 이는 IP 헤더의 대상 주소로 정의됩니다. 이 경우 특정 대상은 패킷이 도착한 물리적 인터페이스에 할당된 IP 주소입니다.

서브넷

- 네트워크의 다른 부분과 네트워크 주소를 공유하고 서브넷 번호로 구별되는 물리적으로 독립된 네트워크일 수 있는 네트워크의 일부입니다. 서브넷은 네트워크와 인터넷의 관계와 같습니다.

서브넷 번호

- 서브넷을 지정하는 인터넷 주소의 일부. 인터넷 라우팅 목적에서는 무시되지만 인트라넷 라우팅에는 사용됩니다.

TOS

- 서비스 유형 전송 계층 또는 애플리케이션이 네트워크 계층에서 기대하는 신뢰성 정도를 나타내는 IP 헤더의 필드입니다.

TTL

- TTL\(Time To Live\) 패킷이 유효한 것으로 간주되는 기간을 나타내는 IP 헤더의 필드입니다. 홉 수와 타이머 값의 조합입니다.

---
# **APPENDIX C. FUTURE DIRECTIONS**

이 부록에는 이 문서의 향후 개정판에서 다루고자 하는 작업이 나열되어 있습니다.

라우터 요구 사항을 준비하면서 우리는 몇 가지 다른 아키텍처 문제를 우연히 발견했습니다. 이들 각각은 문서에서 어느 정도 다루어지지만 여전히 IP 아키텍처에서 공개 문제로 분류되어야 합니다.

여기에 제시된 대부분의 주제는 일반적으로 기술이 아직 상대적으로 새롭고 커뮤니티가 여전히 운영 경험을 얻고 있기 때문에 특정 요구 사항을 개발하는 것이 적절하지 않은 영역을 나타냅니다.

다른 주제는 진행 중인 연구 영역을 나타내며 신중한 개발자가 면밀히 모니터링할 영역을 나타냅니다.

```text
   (1) SNMP Version 2

   (2) Additional SNMP MIBs
```

\(7\) 라우팅 프로토콜 간 경로 유출에 대한 보다 자세한 요구사항

```text
   (8) Router system security

   (9) Routing protocol security
```

\(10\) 인터네트워크 프로토콜 계층 보안. 이 문서를 작성한 원래 작업 이후 IP 보안을 개선하기 위한 광범위한 작업이 진행되었습니다. 이 보안 작업이 여기에 포함되어야 합니다.

```text
   (12) Load Splitting
```

\(13\) 다른 경로를 따라 조각 보내기

\(15\) 동일한 와이어에 있는 여러 논리\(서브\)네트. 라우터

- 요구 사항에는 이에 대한 지원이 필요하지 않습니다. 우리는 규칙의 표현을 올바르게 작성하기 위해 신중하게 수행해야 하는 아키텍처 부분\(예: 직접 방송 전달 및 리디렉션 발행\)을 식별하려고 시도했습니다.

일이 발생하고 논리적으로 명확하게 구별하려고 노력했습니다.

- 물리적 인터페이스의 인터페이스. 그러나 우리는 이 문제를 자세히 연구하지 않았으며 동일한 와이어에 여러 논리 \(서브\)네트가 있는 경우 문서의 모든 규칙이 정확하다고 확신할 수 없습니다.

\(15\) 혼잡 제어 및 자원 관리. IETF 전문가\(Mankin 및 Ramakrishnan\)의 조언에 따라 우리는 Source Quench를 더 이상 사용하지 않으며\(해서는 안 됨\) 구체적인 내용은 거의 언급하지 않았습니다\(섹션 5.3.6\).\(SHOULD NOT\)

\(16\) 라우터와 호스트 모두에 공통적인 링크 계층 요구 사항 문서를 개발합니다.

\(17\) 공통 PPP LQM 알고리즘 개발.

\(18\) 물리적 네트워크 MTU, 링크 계층 우선순위 값에 대한 IP 우선순위 매핑 등과 같이 계층 간에 전달되는 기타 정보\(섹션 \[3.2\] 이상\)를 조사합니다.

\(19\) 주소 확인이 실패하면 링크 계층이 IP에 이를 알려야 합니까\(링크 계층 우선 순위 값 문제가 있을 때 IP에 알리는 것처럼\)?

\(20\) 모든 라우터는 DNS 확인자를 구현해야 합니까?

\(21\) 라우터를 구성할 때 IP 주소를 사용할 수 있는 모든 곳에서 인간 사용자가 호스트 이름을 사용할 수 있어야 합니까? Ping과 Traceroute에서도요?

\(22\) 다음 홉에 대한 Almquist의 초안 반추와 경로 누출에 대한 반추는 검토되고, 최신 상태로 업데이트되고, 게시되어야 합니다.

\(23\) 우선순위를 위한 리디렉션 메시지가 필요한지 여부를 결정하기 위한 조사가 필요합니다. 그렇지 않은 경우 서비스 유형 리디렉션이 허용됩니까?

\(24\) RIPv2, RIP+CIDR ​​및 가변 길이 네트워크 접두사.

```text
   (25) BGP-4 CIDR is going to be important, and everyone is betting on
        BGP-4.  We can't avoid mentioning it.  Probably need to describe
        the differences between BGP-3 and BGP-4, and explore upgrade
        issues...
```

\(26\) 느슨한 소스 경로 모바일 IP 및 일부 멀티캐스팅에는 이것이 필요할 수 있습니다. 아마도 SHOULD로 격상되어야 할 것입니다\(Fred에 따르면\).\(SHOULD\)

```text
        Baker's Suggestion).
```

---
# **APPENDIX D. Multicast Routing Protocols**

멀티캐스팅은 인터넷 프로토콜 제품군 내에서 비교적 새로운 기술입니다. 아직 널리 배포되거나 일반적으로 사용되지는 않습니다. 그러나 그 중요성은 앞으로 더욱 커질 것으로 예상됩니다.

이 부록에서는 인터넷을 통한 멀티캐스트 라우팅을 위해 조사 중인 일부 기술에 대해 설명합니다.

부지런한 구현자는 멀티캐스트 기능을 적절하게 개발하기 위해 이 분야의 개발 상황을 따라잡을 것입니다.

이 부록은 어떠한 표준이나 요구 사항도 명시하지 않습니다.

---
## **D.1 Introduction**

멀티캐스트 라우팅 프로토콜을 사용하면 TCP/IP 인터넷을 통해 IP 멀티캐스트 데이터그램을 전달할 수 있습니다. 일반적으로 이러한 알고리즘은 소스 및 대상 주소를 기반으로 데이터그램을 전달합니다. 또한 데이터그램을 여러 멀티캐스트 그룹 구성원에게 전달해야 할 수도 있으며, 때로는 데이터그램을 복제하여 여러 인터페이스로 보내야 할 수도 있습니다.

멀티캐스트 라우팅 프로토콜의 상태는 IP 유니캐스트 전달에 사용할 수 있는 프로토콜보다 덜 개발되었습니다. TCP/IP에 대한 세 가지 실험적인 멀티캐스트 라우팅 프로토콜이 문서화되었습니다. 각각은 멀티캐스트 그룹 멤버십을 모니터링하기 위해 IGMP 프로토콜\(섹션 \[4.4\]에서 설명\)을 사용합니다.

---
## **D.2 Distance Vector Multicast Routing Protocol - DVMRP**

\[ROUTE:9\]에 문서화된 DVMRP는 거리 벡터 또는 Bellman-Ford 기술을 기반으로 합니다. 멀티캐스트 데이터그램만 라우팅하며 단일 자치 시스템 내에서 라우팅합니다. DVMRP는 \[ROUTE:10\]에 설명된 Truncated Reverse Path Broadcasting 알고리즘을 구현한 것입니다. 또한 멀티캐스트 라우팅이 불가능한 IP 도메인을 통한 IP 멀티캐스트 터널링을 지정합니다.

---
## **D.3 Multicast Extensions to OSPF - MOSPF**

현재 개발 중인 MOSPF는 OSPF에 대한 이전 버전과 호환되는 추가 기능으로 자율 시스템 내에서 IP 멀티캐스트와 유니캐스트를 모두 전달할 수 있습니다. MOSPF 라우터는 라우팅 도메인 내에서 OSPF 라우터와 혼합될 수 있으며 유니캐스트 전달에서 상호 운용됩니다. OSPF는 링크 상태 또는 SPF 기반 프로토콜입니다.

MOSPF 라우터는 그룹 구성원을 정확히 찾아내는 링크 상태 광고를 추가함으로써 멀티캐스트 데이터그램의 경로를 데이터그램 소스에 뿌리를 둔 트리로 계산할 수 있습니다. 그런 다음 그룹 구성원을 포함하지 않는 분기를 삭제하여 불필요한 데이터그램 전달 홉을 제거할 수 있습니다.

---
## **D.4 Protocol Independent Multicast - PIM**

현재 개발 중인 PIM은 기존 유니캐스트 인프라를 통해 실행되는 멀티캐스트 라우팅 프로토콜입니다. PIM은 조밀한 그룹 멤버십과 희박한 그룹 멤버십을 모두 제공합니다. 희소 그룹에 대해 명시적인 조인 모델을 사용한다는 점에서 다른 프로토콜과 다릅니다. 조인은 공유 트리에서 발생하며 소스별 트리로 전환할 수 있습니다. 대역폭이 풍부하고 그룹 구성원이 밀집된 경우 모든 링크에서 데이터를 넘치게 하고 나중에 그룹 구성원이 없는 예외 사례를 제거하여 오버헤드를 줄일 수 있습니다.

---
# **APPENDIX E Additional Next-Hop Selection Algorithms**

섹션 \[5.2.4.3\]에서는 라우터가 패킷의 다음 홉을 선택할 때 사용해야 하는 알고리즘을 지정합니다.

이 부록은 다음 홉 선택 문제에 대한 역사적 관점을 제공합니다. 또한 인터넷에서 찾을 수 있는 몇 가지 추가 가지치기 규칙과 다음 홉 선택 알고리즘을 제시합니다.

이 부록은 Philip Almquist의 이전 미출판 작품에서 발췌한 자료를 제공합니다. 다음 홉에 대한 반추.

이 부록은 어떠한 표준이나 요구 사항도 명시하지 않습니다.

---
### **E.1. Some Historical Perspective**

라우터가 라우팅 결정을 내리는 방법에 대한 "고전적인 모델"이라고 불리는 것부터 시작하여 주제의 역사를 간략하게 검토하는 것이 유용합니다. 이 모델은 IP 이전 모델입니다. 이 모델에서 라우터는 RIP와 같은 단일 라우팅 프로토콜을 사용합니다. 프로토콜은 라우터의 FIB\(Forwarding Information Base\) 내용을 완전히 결정합니다. 경로 조회 알고리즘은 간단합니다. 라우터는 FIB에서 대상 속성이 패킷의 대상 주소의 네트워크 접두사 부분과 정확히 일치하는 경로를 찾습니다. 발견되면 사용됩니다. 아무것도 발견되지 않으면 목적지에 도달할 수 없습니다. 라우팅 프로토콜은 각 대상에 대해 최대 하나의 경로를 유지하므로 동일한 대상과 일치하는 경로가 여러 개 있을 때 어떻게 해야 하는지에 대한 문제가 발생할 수 없습니다.

수년에 걸쳐 이 클래식 모델은 작은 방식으로 개선되었습니다. 기본 경로, 서브넷 및 호스트 경로의 배포를 통해 어떤 의미에서 대상과 일치하는 라우팅 테이블 항목을 두 개 이상 가질 수 있게 되었습니다. 이는 경로의 계층 구조가 있다는 합의에 의해 쉽게 해결되었습니다. 즉, 호스트 경로는 서브넷 경로보다 선호되고, 서브넷 경로는 넷 경로보다 서브넷 경로가 기본 경로보다 넷 경로가 선호되어야 합니다.

가변 길이 서브넷 마스크\(가변 길이 네트워크 접두사\)를 지원하는 기술이 배포되면서 설명이 조금 더 복잡해졌지만 일반적인 접근 방식은 동일하게 유지되었습니다. 네트워크 접두사는 아키텍처를 의식적으로 단순화하고 정규화하기 위해 도입되었습니다. 이제 네트워크 접두사 경로에 대한 각 경로에는 이와 관련된 접두사 길이가 있다고 말합니다. 이 접두어 길이는 접두어의 비트 수를 나타냅니다. 이는 기존 서브넷 마스크를 사용하여 표현할 수도 있습니다. 경로의 네트워크 접두사에 있는 각 중요한 비트가 패킷의 대상 주소에 있는 해당 비트와 일치하지 않으면 경로를 사용하여 패킷을 라우팅할 수 없습니다. 마스크에 더 많은 비트가 설정된 경로가 마스크에 더 적은 비트가 설정된 경로보다 선호됩니다. 이는 위에서 설명한 경로 계층 구조를 일반화한 것일 뿐이며, 이 메모의 나머지 부분에서는 가장 긴 일치 항목을 선호하여 경로를 선택하는 것으로 언급됩니다.

클래식 모델이 확장된 또 다른 방법은 라우팅 프로토콜이 라우팅 테이블의 내용을 완전히 제어할 수 있다는 개념을 약간 완화하는 것입니다. 먼저 정적 경로가 도입되었습니다. 처음으로 동일한 목적지로 가는 두 개의 경로\(동적 경로 하나, 정적 경로 하나\)를 동시에 갖는 것이 가능해졌습니다. 이런 일이 발생하면 라우터에는 정적 경로 또는 동적 경로가 선호되는지 여부를 결정하는 정책\(어떤 경우에는 구성 가능하고 다른 경우에는 라우터 소프트웨어 작성자가 선택\)이 있어야 합니다. 그러나 이 정책은 가장 긴 일치 항목이 사용할 경로를 고유하게 결정하지 못하는 경우에만 순위 결정 수단으로 사용되었습니다. 따라서 예를 들어 정책이 동적 경로보다 정적 경로를 선호하더라도 정적 기본 경로는 동적 네트워크 경로보다 선호되지 않습니다.

고전적인 모델은 도메인 간 라우팅 프로토콜이 발명되었을 때 더욱 강화되어야 했습니다. 전통적인 라우팅 프로토콜은 "내부 게이트웨이 프로토콜"\(IGP\)이라고 불리게 되었고, 각 인터넷 사이트에는 "외부 게이트웨이"라는 이상한 새로운 짐승이 있었습니다. 당시 인터넷 백본을 구성함\) 동시에 해당 사이트의 다른 라우터에 IGP를 전달했습니다. 두 프로토콜 모두 라우터의 라우팅 테이블 내용을 결정하려고 했습니다. 이론적으로 이로 인해 라우터는 세 개의

\(EGP, IGP 및 고정\)을 동일한 대상으로 라우팅합니다. 당시 인터넷 토폴로지로 인해 EGP 경로보다 IGP 경로를 선호하는 정책이 라우터에 가장 적합하다는 점은 거의 논쟁의 여지 없이 해결되었습니다. 그러나 가장 긴 일치의 신성함은 의심의 여지가 없습니다. IGP에서 학습된 기본 경로는 학습된 EGP의 네트 경로보다 결코 선호되지 않습니다.

인터넷 토폴로지와 그에 따른 인터넷 라우팅은 그 이후로 상당히 발전했지만, 이 고전 모델의 약간 강화된 버전은 오늘날까지 인터넷에서 그대로 남아 있습니다\(BGP가 EGP를 대체했다는 점 제외\). 개념적으로\(그리고 종종 구현 시\) 각 라우터에는 라우팅 테이블과 하나 이상의 라우팅 프로토콜 프로세스가 있습니다. 이러한 각 프로세스는 원하는 항목을 추가할 수 있으며 생성된 항목을 삭제하거나 수정할 수 있습니다. 패킷을 라우팅할 때 라우터는 연결을 끊는 정책 메커니즘으로 강화된 가장 긴 일치를 사용하여 최상의 경로를 선택합니다. 이 증강된 클래식 모델은 우리에게 많은 도움이 되었지만 다음과 같은 몇 가지 단점이 있습니다.

o 서비스 품질 및 MTU와 같은 경로 특성을 무시합니다\(고려하도록 확장될 수 있음\).

o 순수 최장 일치와 다른 경로 조회 알고리즘이 필요한 라우팅 프로토콜\(예: OSPF 및 통합 IS-IS\)을 지원하지 않습니다.

o 동점 결정 메커니즘이 무엇이어야 하는지에 대한 확고한 합의가 이루어지지 않았습니다. 라우터가 항상 네트워크 관리자가 "올바른" 경로로 간주하는 경로를 선택하는 방식으로 타이 브레이킹 메커니즘을 구성하는 것이 불가능하지는 않더라도 어려운 것으로 밝혀진 경우가 많습니다.

---
### **E.2. Additional Pruning Rules**

- 섹션 \[5.2.4.3\]에서는 FIB에서 경로를 선택하는 데 사용할 몇 가지 가지치기 규칙을 정의했습니다. 사용할 수 있는 다른 규칙도 있습니다.

o OSPF 경로 클래스

- 영역이 있거나 내부 경로와 외부 경로를 구분하는 라우팅 프로토콜은 경로를 계산하는 데 사용되는 정보 유형에 따라 경로를 클래스로 나눕니다. 경로는 사용 가능한 클래스가 없는 경우를 제외하고 항상 가장 선호하는 클래스에서 선택됩니다. 이 경우 두 번째로 선호되는 클래스에서 경로가 선택됩니다. OSPF에서 클래스\(가장 선호되는 것부터 가장 덜 선호되는 순서대로\)는 영역 내, 영역 간, 외부 유형 1\(내부 메트릭이 있는 외부 경로\) 및 외부 유형 2입니다. 추가적인 주름으로,

- 라우터는 지역 내 경로를 사용하여 어떤 주소에 액세스할 수 있는지 알도록 구성되며, 지역 내 경로를 사용할 수 없는 경우에도 해당 목적지에 도달하기 위해 지역 간 또는 외부 경로를 사용하지 않습니다.

보다 정확하게는 각 경로에 클래스가 있다고 가정합니다.

- 라우팅 프로토콜에 의해 할당되는 Route.class라는 속성. 후보 경로 집합을 검사하여 Route.class = intra-area에 대한 경로가 포함되어 있는지 확인합니다. 그렇다면, Route.class = intra-area인 경로를 제외한 모든 경로는 폐기됩니다. 그렇지 않으면 라우터는 패킷의 목적지가 로컬 영역에 구성된 주소 범위 내에 속하는지 확인합니다. 그렇다면 전체 후보 경로 집합이 삭제됩니다. 그렇지 않으면 후보 경로 집합을 검사하여 Route.class = inter-area에 대한 경로가 포함되어 있는지 확인합니다. 그렇다면, Route.class = inter-area인 경로를 제외한 모든 경로는 폐기됩니다. 그렇지 않으면 후보 경로 집합을 검사하여 Route.class = type 1 external에 대한 경로가 포함되어 있는지 확인합니다. 그렇다면 Route.class = type 1 external인 경로를 제외한 모든 경로가 삭제됩니다.

o IS-IS 경로 클래스

- IS-IS 경로 클래스는 OSPF와 동일하게 작동합니다. 그러나 통합 IS-IS에 의해 정의된 클래스 집합은 다르므로 IS-IS 경로 클래스와 OSPF 경로 클래스 간에 일대일 매핑이 없습니다. 통합 IS-IS에서 사용되는 경로 클래스는 가장 선호되는 것부터 가장 덜 선호되는 것 순으로 지역 내, 지역 간 및 외부입니다.

- 통합 IS-IS 내부 클래스는 OSPF 내부 클래스와 동일합니다. 마찬가지로 통합 IS-IS 외부 클래스는 OSPF의 유형 2 외부 클래스와 동일합니다. 그러나 통합 IS-IS는 내부 메트릭을 사용하여 영역 간 경로와 외부 경로를 구분하지 않습니다. 둘 다 영역 간 경로로 간주됩니다. 따라서 OSPF는 내부 메트릭이 있는 외부 경로보다 진정한 영역 간 경로를 선호하는 반면 통합 IS-IS는 두 가지 유형의 경로에 동일한 우선 순위를 제공합니다.

o IDPR 정책

- 정책의 특정 사례. IETF의 도메인 간 정책 라우팅 작업 그룹은 인터넷에서 진정한 정책 기반 라우팅을 지원하기 위해 IDPR\(도메인 간 정책 라우팅\)이라는 라우팅 프로토콜을 고안하고 있습니다. IDPR 프로토콜에서 제공하는 경로를 사용하려면 헤더 특성의 특정 조합\(예: 소스 및 대상 주소의 특정 조합 또는 특수 IDPR 소스 경로 옵션\)이 있는 패킷이 필요합니다. 따라서 다른 정책 정리 규칙과 달리 IDPR 정책은 다음과 같아야 합니다.

- 기본 일치를 제외한 다른 가지치기 규칙보다 먼저 적용됩니다.

- 특히 IDPR 정책은 전달되는 패킷을 검사하여 해당 특성이 정책 기반 경로를 사용하여 전달되어야 하는지 확인합니다. 그렇다면 IDPR 정책은 IDPR 프로토콜에서 제공하지 않는 모든 경로를 삭제합니다.

---
## **E.3 Some Route Lookup Algorithms**

- 이 섹션에서는 현재 사용 중이거나 제안된 여러 경로 조회 알고리즘을 검토합니다. 각각은 사용하는 가지치기 규칙의 순서를 제공하여 설명됩니다. 각 알고리즘의 강점과 약점이 제시됩니다.

---
### **E.3.1 The Revised Classic Algorithm**

- 개정된 클래식 알고리즘은 \[E.1\]절에서 논의한 전통적인 알고리즘의 형태이다. 이 알고리즘의 단계는 다음과 같습니다.

```text
      1.  Basic match
      2.  Longest match
      3.  Best metric
      4.  Policy
```

- 일부 구현에서는 정책 단계를 생략합니다. 경로에 비교할 수 없는 메트릭이 있을 수 있는 경우에만 필요하기 때문입니다\(다른 라우팅 도메인에서 학습했기 때문입니다\).

- 이 알고리즘의 장점은 다음과 같습니다.

- \(1\) 널리 시행되고 있다.

- \(2\) 정책 단계\(구현자가 임의로 복잡하게 만들 수 있음\)를 제외하면 알고리즘은 이해하고 구현하기가 간단합니다.

```text
      Its disadvantages are:
```

- \(1\) IS-IS 또는 OSPF 경로 클래스를 처리하지 않으므로 통합 IS-IS 또는 OSPF에 사용할 수 없습니다.

- \(2\) TOS나 기타 경로 속성을 처리하지 않습니다.

- \(3\) 정책 메커니즘은 어떤 방식으로든 표준화되지 않았으므로 구현에 따라 달라지는 경우가 많습니다. 이로 인해 구현자\(적절한 정책 메커니즘을 고안해야 함\)와 사용자\(사용 방법을 배워야 함\)에게 추가 작업이 발생합니다.

- 메커니즘. 표준화된 메커니즘이 없기 때문에 여러 공급업체의 라우터에 대해 일관된 구성을 구축하기가 어렵습니다. 이는 다중 공급업체 상호 운용성을 실질적으로 크게 방해합니다.

- \(4\) 현재 공급업체가 제공하는 독점 정책 메커니즘은 인터넷의 복잡한 부분에서는 종종 부적절합니다.

- \(5\) 알고리즘은 일반적으로 사용 가능한 문서나 표준에 기록되지 않았습니다. 사실상 이는 인터넷 민속의 일부입니다.

---
### **E.3.2 The Variant Router Requirements Algorithm**

- 일부 라우터 요구 사항 작업 그룹 구성원은 섹션 \[5.2.4.3\]에 설명된 알고리즘의 약간 변형을 제안했습니다. 이 변형에서는 요청된 서비스 유형을 일치시키는 것이 가능한 한 많은 대상 주소를 일치시키는 것보다 덜 중요한 것이 아니라 더 중요한 것으로 간주됩니다. 예를 들어, 이 알고리즘은 기본 서비스 유형이 있는 네트워크 경로보다 올바른 서비스 유형이 있는 기본 경로를 선호하는 반면, \[5.2.4.3\]의 알고리즘은 반대 선택을 합니다.

- 알고리즘의 단계는 다음과 같습니다.

```text
      1.  Basic match
      2.  Weak TOS
      3.  Longest match
      4.  Best metric
      5.  Policy
```

- 이 알고리즘과 일반 라우터 요구 사항 알고리즘 지지자들 사이의 논쟁은 각 측이 자신의 알고리즘이 상대방의 알고리즘보다 더 간단하고 직관적인 라우팅으로 이어지는 사례를 보여줄 수 있음을 시사합니다. 이 변형에는 \[5.2.4.3\]에 지정된 알고리즘과 동일한 장단점이 있습니다. 단, 가장 긴 일치 항목을 잘라내기 전에 약한 TOS를 잘라내면 이 알고리즘이 표준 라우터 요구 사항보다 OSPF 및 통합 IS-IS와의 호환성이 떨어집니다. 연산.

---
### **E.3.3 The OSPF Algorithm**

- OSPF는 한 가지 중요한 차이점을 제외하고 라우터 요구 사항 알고리즘과 사실상 동일한 알고리즘을 사용합니다. OSPF는 OSPF 경로 클래스를 고려합니다.

- 알고리즘은 다음과 같습니다.

```text
      1.  Basic match
      2.  OSPF route class
      3.  Longest match
      4.  Weak TOS
      5.  Best metric
      6.  Policy
```

- 서비스 지원 유형이 항상 존재하는 것은 아닙니다. 존재하지 않으면 물론 네 번째 단계는 생략됩니다.

- 이 알고리즘은 개정된 클래식 알고리즘에 비해 몇 가지 장점이 있습니다.

- \(1\) 서비스 라우팅 유형을 지원합니다.

- \(2\) 단순히 인터넷 민속의 일부가 아닌 규칙이 기록되어 있습니다.

- \(3\) \(분명히\) OSPF와 함께 작동합니다.

- 그러나 이 알고리즘은 개정된 클래식 알고리즘의 몇 가지 단점도 유지합니다.

- \(1\) 서비스 유형\(예: MTU\) 이외의 경로 속성은 무시됩니다.

- \(2\) 수정된 클래식 알고리즘에서와 마찬가지로 정책 단계의 세부 사항\(또는 존재 여부\)은 구현자의 재량에 달려 있습니다.

- OSPF 알고리즘에는 또 다른 단점도 있습니다\(개정된 클래식 알고리즘에서는 공유되지 않음\). OSPF 내부\(영역 내 또는 영역 간\) 경로는 OSPF 경로가 대상 주소의 더 적은 비트와 일치하는 경우에도 항상 다른 라우팅 프로토콜에서 학습된 경로보다 우수한 것으로 간주됩니다. 이는 일부 네트워크에서는 부적절한 정책 결정입니다.

- 마지막으로, OSPF 알고리즘의 TOS 지원은 0이 아닌 TOS 값을 가진 패킷을 전달할 때 TOS를 지원하는 라우팅 프로토콜이 암묵적으로 선호된다는 점에서 결함이 있다는 점에 주목할 가치가 있습니다. 이는 경우에 따라 적절하지 않을 수 있습니다.

---
### **E.3.4 The Integrated IS-IS Algorithm**

통합 IS-IS는 OSPF 알고리즘과 유사하지만 완전히 동일하지는 않은 알고리즘을 사용합니다. 통합 IS-IS는 다른 경로 클래스 세트를 사용하며 서비스 유형 처리에 있어서 약간 다릅니다. 알고리즘은 다음과 같습니다.

```text
   1.  Basic Match
   2.  IS-IS Route Classes
   3.  Longest Match
   4.  Weak TOS
   5.  Best Metric
   6.  Policy
```

통합 IS-IS는 약한 TOS를 사용하지만 프로토콜은 IP 헤더의 TOS 필드에 대해 가능한 값 중 작은 특정 하위 집합에 대한 경로만 전달할 수 있습니다. TOS 필드에 다른 값이 포함된 패킷은 기본 TOS를 사용하여 라우팅됩니다.

서비스 지원 유형은 선택 사항입니다. 비활성화되면 네 번째 단계가 생략됩니다. OSPF와 마찬가지로 사양에는 정책 단계가 포함되지 않습니다.

이 알고리즘은 개정된 클래식 알고리즘에 비해 몇 가지 장점이 있습니다.

\(1\) 서비스 라우팅 유형을 지원합니다. \(2\) 그 규칙은 단순히 인터넷 민속의 일부가 아니라 기록되어 있습니다. \(3\) \(분명히\) 통합 IS-IS와 함께 작동합니다.

그러나 이 알고리즘은 개정된 클래식 알고리즘의 몇 가지 단점도 유지합니다.

\(1\) 서비스 유형\(예: MTU\) 이외의 경로 속성은 무시됩니다. \(2\) 개정된 클래식 알고리즘에서와 마찬가지로 정책 단계의 세부 사항\(또는 존재 여부\)은 구현자의 재량에 달려 있습니다. \(3\) IS-IS 경로 클래스와 OSPF 경로 클래스의 차이로 인해 OSPF에서는 작동하지 않습니다. 또한 IS-IS는 가능한 TOS 값의 하위 집합만 지원하기 때문에 통합 IS-IS 알고리즘의 일부 명백한 구현은 OSPF의 TOS 해석을 지원하지 않습니다.

통합 IS-IS 알고리즘에는 또 다른 단점도 있습니다\(수정된 클래식 알고리즘에서는 공유되지 않음\). IS-IS 내부\(지역 내 또는 지역 간\) 경로는 항상 다음과 같은 것으로 간주됩니다.

IS-IS 경로가 대상 주소의 더 적은 비트와 일치하고 요청된 서비스 유형을 제공하지 않는 경우에도 다른 라우팅 프로토콜에서 학습된 경로보다 우수합니다. 이는 모든 경우에 적절하지 않을 수 있는 정책 결정입니다.

마지막으로 통합 IS-IS 알고리즘의 TOS 지원에는 OSPF 알고리즘에서 지적된 것과 동일한 결함이 있다는 점은 주목할 가치가 있습니다.

---
# **Security Considerations**

이 문서의 초점은 보안보다는 상호 운용성에 있지만, 분명히 이 문서에는 네트워크 보안에 영향을 미치는 많은 섹션이 있습니다.

보안은 사람마다 다른 의미를 갖습니다. 라우터의 관점에서 볼 때 보안은 자체 네트워크의 작동을 유지하고 인터넷 전체를 건강하게 유지하는 데 도움이 되는 모든 것입니다. 이 문서의 목적에 따라 우리가 관심을 갖는 보안 서비스는 처음 두 가지에 적용되는 서비스 거부, 무결성 및 인증입니다. 보안 서비스로서의 개인 정보 보호는 중요하지만 적어도 이 문서의 날짜 현재로서는 라우터의 주변적인 문제일 뿐입니다.

이 문서의 여러 위치에는 보안 고려 사항이라는 제목의 섹션이 있습니다. 이 섹션에서는 논의 중인 일반 주제에 적용되는 특정 고려 사항을 논의합니다.

이 문서에서는 이렇게 하면 라우터/네트워크가 안전해질 것이라고 말하는 경우가 거의 없습니다. 아마도 이것은 좋은 생각이라고 말하고 있으며, 그렇게 하면 인터넷과 로컬 시스템의 보안이 전반적으로 향상될 수 있습니다.

불행하게도 이것은 현재로서는 최첨단 기술입니다. 라우터와 관련된 네트워크 프로토콜 중 합리적인 내장 보안 기능을 갖춘 경우는 거의 없습니다. 업계와 프로토콜 설계자는 이러한 문제로 인해 계속해서 어려움을 겪고 있습니다. 진전이 있지만 BGP 및 OSPF 라우팅 프로토콜에서 사용할 수 있는 P2P 인증과 같은 작은 초기 단계에 불과합니다.

특히 이 문서에서는 네트워크 보안 개발 및 강화에 대한 현재 연구에 대해 설명합니다. 이 글을 쓰는 시점\(1993년 12월\) 현재 진행 중인 특정 연구, 개발 및 엔지니어링 분야는 IP 보안, SNMP 보안 및 일반 인증 기술입니다.

위의 모든 사항에도 불구하고 공급업체와 사용자 모두 라우터 보안을 개선하기 위해 할 수 있는 일이 있습니다. 공급업체는 다음을 수행해야 합니다.

신뢰할 수 있는 컴퓨터 시스템 해석 \[소개:8\] 사본을 얻으십시오. 공급업체가 이러한 지침에 따른 공식 검증을 위해 장치를 제출하지 않기로 결정한 경우에도 이 간행물은 컴퓨팅 장치에 대한 일반적인 보안 설계 및 사례에 대한 훌륭한 지침을 제공합니다.

---
# **APPENDIX F: HISTORICAL ROUTING PROTOCOLS**

특정 라우팅 프로토콜은 인터넷에서 일반적이지만 이 문서의 작성자는 양심상 해당 프로토콜의 사용을 권장할 수 없습니다. 이는 올바르게 작동하지 않기 때문이 아니라 설계에서 가정한 인터넷의 특성\(간단한 라우팅, 정책 없음, 공통 관리 하의 단일 "코어 라우터" 네트워크, 제한된 복잡성 또는 제한된 네트워크 직경\)이 속성이 아니기 때문입니다. 오늘날 인터넷의. 여전히 이를 사용하는 인터넷 부분은 일반적으로 복잡성이 제한된 제한된 "비주얼" 도메인입니다.

이 섹션에는 선의로 실행에 관한 수집된 지혜가 기록되어 있습니다.

---
## **F.1 EXTERIOR GATEWAY PROTOCOL - EGP**
---
### **F.1.1 Introduction**

EGP\(외부 게이트웨이 프로토콜\)는 동일하거나 다른 자치 시스템의 라우터 간에 연결 가능성 정보를 교환하는 데 사용되는 EGP를 지정합니다. EGP 업데이트 메시지의 거리 필드에 대한 표준 해석\(즉, 메트릭\)이 없기 때문에 EGP는 라우팅 프로토콜로 간주되지 않습니다. 따라서 거리는 동일한 AS의 라우터 간에만 비교할 수 있습니다. 그러나 이는 이웃 라우터와 이웃이 아닌 라우터에 대한 경로 모두에 대한 고품질 연결 가능성 정보를 제공하도록 설계되었습니다.

EGP는 \[ROUTE:6\]에 의해 정의됩니다. 구현자는 \[ROUTE:7\] 및 \[ROUTE:8\]도 읽고 싶어할 것입니다. 유용한 설명과 배경 자료가 포함되어 있기 때문입니다.

논의

- 현재 EGP 사양에는 심각한 제한 사항이 있으며, 가장 중요한 것은 라우터가 라우터의 자율 시스템 내에서 연결할 수 있는 네트워크만 광고하도록 제한하는 제한 사항입니다. 타사 EGP 정보 전파에 대한 이러한 제한은 장기간 지속되는 라우팅 루프를 방지하기 위한 것입니다. 이는 EGP를 2단계 계층 구조로 효과적으로 제한합니다.

- RFC-975는 EGP 사양의 일부가 아니므로 무시해야 합니다.

---
### **F.1.2 Protocol Walk-through**

```text
      Indirect Neighbors: RFC-888, page 26
```

- EGP 구현에는 간접 이웃 지원이 포함되어야 합니다.\(MUST\)

```text
      Polling Intervals: RFC-904, page 10
```

- Hello 명령 재전송 간격과 Poll 재전송 간격은 구성 가능해야 하지만 최소값이 정의되어야 합니다.\(MUST\)

- 구현이 Hello 명령 및 Poll 명령에 응답하는 간격은 구성 가능해야 하지만 최소값이 정의되어야 합니다.\(MUST\)

```text
      Network Reachability: RFC-904, page 15
```

구현은 기본적으로 다른 자율 시스템의 외부 라우터 목록을 제공하지 않도록 설정해야 합니다\(MUST\). 업데이트 응답/표시 패킷에는 해당 라우터를 통해 도달할 수 있는 네트워크와 함께 내부 라우터 목록만 포함되어야 합니다. 그러나 구현에서는 외부 목록을 제공할 수 있는 구성 옵션을 제공하도록 선택할 수 있습니다. 구현은 다른 자율 시스템의 라우터가 제공하는 외부 목록을 통해 학습된 라우터를 외부 목록에 포함해서는 안 됩니다. 구현은 네트워크를 학습한 자율 시스템으로 다시 보내서는 안 됩니다. 즉, 자율 시스템 수준에서 수평 분할을 수행해야 합니다.\(MUST, MAY, MUST NOT, MUST NOT, MUST\)

네트워크 도달성 업데이트에서 255개 이상의 내부 라우터 또는 255개 이상의 외부 라우터를 지정해야 하는 경우 나열할 수 없는 라우터에서 연결할 수 있는 네트워크는 나열된 라우터 중 하나의 목록에 병합되어야 합니다. 이 목적을 위해 나열된 라우터 중 어느 것이 선택되는지는 사용자가 구성할 수 있어야 하지만, 생성되는 EGP 업데이트의 소스 주소를 기본값으로 설정해야 합니다.\(MUST, SHOULD\)

EGP 업데이트에는 일련의 네트워크 번호 블록이 포함되어 있으며, 각 블록에는 특정 라우터를 통해 특정 거리에서 연결할 수 있는 네트워크 번호 목록이 포함되어 있습니다. 특정 라우터를 통해 특정 거리에서 255개 이상의 네트워크에 연결할 수 있는 경우 해당 네트워크는 여러 블록으로 분할됩니다\(모두 동일한 거리를 가짐\). 마찬가지로 특정 라우터를 통해 연결할 수 있는 네트워크를 나열하는 데 255개가 넘는 블록이 필요한 경우 업데이트에 모든 블록을 포함하는 데 필요한 만큼 라우터의 주소가 나열됩니다.

---
# **Unsolicited Updates: RFC-904, page 16**

네트워크가 피어와 공유되는 경우 구현은 소스 네트워크가 공유 네트워크인 경우 Up 상태로 진입할 때 원치 않는 업데이트를 보내야 합니다\(MUST\).\(MUST\)

---
# **Neighbor Reachability: RFC-904, page 6, 13-15**

j 및 k\(인접 임계값 상향 및 하향 임계값\) 값을 설명하는 6페이지의 표는 올바르지 않습니다. 여기에 올바르게 재현되었습니다.

```text
      Name    Active  Passive Description
      -----------------------------------------------
       j         3       1    neighbor-up threshold
       k         1       0    neighbor-down threshold
```

수동 모드의 k 값도 RFC-904, 14페이지에서 잘못 지정되었습니다. 괄호 안의 값은 다음과 같아야 합니다.

```text
      (j = 1, k = 0, and T3/T1 = 4)
```

최적화로서 구현은 Poll이 예정되어 있을 때 Hello 명령을 보내는 것을 자제할 수 있습니다. 구현이 그렇게 하는 경우 이 최적화를 비활성화하기 위한 사용자 구성 가능 옵션을 제공해야 합니다\(SHOULD\).\(SHOULD\)

---
# **Abort timer: RFC-904, pages 6, 12, 13**

EGP 구현에는 중단 타이머에 대한 지원이 포함되어야 합니다\(RFC-904의 섹션 4.1.4에 설명되어 있음\). 구현은 유휴 상태에서 중단 타이머를 사용하여 프로토콜 시스템을 다시 시작하기 위한 시작 이벤트를 자동으로 발행해야 합니다\(SHOULD\). 권장 값은 심각한 오류\(관리적으로 금지됨, 프로토콜 위반 및 매개변수 문제\)에 대한 P4이고 기타 모든 오류에 대한 P5입니다. 중단 타이머는 중지 이벤트가 수동으로 시작된 경우\(예: 네트워크 관리 프로토콜을 통해\) 시작되어서는 안 됩니다.\(MUST, SHOULD, SHOULD NOT\)

---
# **Cease command received in Idle state: RFC-904, page 13**

EGP 상태 머신이 Idle 상태에 있으면 Cease-ack 응답으로 Cease 명령에 응답해야 합니다.\(MUST\)

---
# **Hello Polling Mode: RFC-904, page 11**

EGP 구현에는 능동 및 수동 폴링 모드에 대한 지원이 모두 포함되어야 합니다.\(MUST\)

---
# **Neighbor Acquisition Messages: RFC-904, page 18**

언급한 대로 Hello 및 Poll 간격은 요청 및 확인 메시지에만 나타나야 합니다. 따라서 EGP Neighbor Acquisition 메시지의 길이는 요청 또는 확인 메시지의 경우 14바이트이고 거부, 중지 또는 중지 승인 메시지의 경우 10바이트입니다. 구현은 거부, 중지 또는 중지 승인 메시지에 대해 14바이트를 전송해서는 안 되지만\(MUST\) 이러한 메시지에 대해 14바이트를 전송하는 구현을 허용해야 합니다\(MUST\).\(MUST NOT\)

---
# **Sequence Numbers: RFC-904, page 10**

S와 동일하지 않은 시퀀스 번호로 수신된 응답 또는 표시 패킷은 폐기되어야 합니다. 전송 시퀀스 번호 S는 Poll 명령이 전송되기 직전에 증가해야 하며 다른 시간에는 증가하지 않아야 합니다.\(MUST, MUST\)

---
## **F.2 ROUTING INFORMATION PROTOCOL - RIP**
---
### **F.2.1 Introduction**

RIP는 \[ROUTE:3\]에 지정됩니다. RIP는 여전히 인터넷에서 매우 중요하지만 정교한 애플리케이션에서는 위에서 설명한 것과 같은 최신 IGP로 대체되고 있습니다. RIP를 구현하는 라우터는 CIDR 경로를 지원하므로 RIP 버전 2 \[ROUTE:?\]를 구현해야 합니다. 비정기적 액세스 네트워킹이 사용 중인 경우 RIP를 구현하는 라우터는 Demand RIP \[ROUTE:?\]를 구현해야 합니다.\(SHOULD, SHOULD\)

RIP의 또 다른 일반적인 용도는 라우터 검색 프로토콜입니다. 섹션 \[4.3.3.10\]에서는 이 주제를 간략하게 다룹니다.

---
### **F.2.2 Protocol Walk-Through**

토폴로지 변경 처리: \[ROUTE:3\], 11페이지

- RIP 구현은 경로 시간 초과를 위한 수단을 제공해야 합니다. 메시지가 때때로 손실되므로 구현 시 누락된 단일 업데이트를 기반으로 경로를 무효화해서는 안 됩니다\(MUST NOT\).\(MUST, MUST NOT\)

- 구현은 기본적으로 경로를 무효화하기 전에 업데이트 간격의 6배를 기다려야 합니다. 라우터에는 이 값을 변경할 수 있는 구성 옵션이 있을 수 있습니다.\(MUST, MAY\)

논의

- RIP 자율 시스템의 모든 라우터가 경로 무효화를 위해 유사한 시간 초과 값을 사용하는 것이 라우팅 안정성에 중요하므로 구현 시 RIP 사양에 지정된 시간 초과 값을 기본값으로 설정하는 것이 중요합니다.

- 그러나 패킷 손실이 거의 발생하지 않는 환경에서는 해당 시간 초과 값이 너무 보수적입니다. 이러한 환경에서 네트워크 관리자는 장애로부터 더 빠른 복구를 촉진하기 위해 시간 초과 기간을 줄일 수 있기를 원할 수 있습니다.

구현

- 라우터가 시간 초과 후 즉시 경로를 무효화하는 요구 사항을 충족하기 위해 사용할 수 있는 매우 간단한 메커니즘이 있습니다. 라우터는 시간 초과된 경로가 있는지 확인하기 위해 라우팅 테이블을 스캔할 때마다 아직 시간 초과되지 않은 가장 최근에 업데이트된 경로의 수명도 기록합니다. 시간 초과 기간에서 이 기간을 빼면 라우터가 시간 초과된 경로에 대해 테이블을 다시 스캔해야 할 때까지의 시간이 제공됩니다.

---
# **Split Horizon: [ROUTE:3], page 14-15**

RIP의 구현은 학습된 라우터로 전송된 업데이트에 경로를 포함함으로써 발생하는 문제를 피하기 위해 사용되는 체계인 분할 지평선을 구현해야 합니다.\(MUST\)

RIP의 구현은 해당 라우터로 전송된 라우터에서 학습된 경로를 포함하지만 메트릭을 무한대로 설정하는 분할 지평선의 변형인 분할 지평선의 변형인 분할 지평선을 포이즌 역방향으로 구현해야 합니다. 포이즌드 리버스\(Poisoned Reverse\)를 사용하여 분할 지평선을 구현함으로써 발생할 수 있는 라우팅 오버헤드로 인해 구현에는 포이즌드 리버스\(Poisoned Reverse\)가 유효한지 여부를 선택하는 옵션이 포함될 수 있습니다\(MAY\). 구현은 무한한 메트릭으로 역방향 경로를 보내는 시간을 제한해야 합니다.\(SHOULD, MAY, SHOULD\)

구현

- 다음 각 알고리즘을 사용하여 경로에 포이디드 리버스가 적용되는 시간을 제한할 수 있습니다. 첫 번째 알고리즘은 더 복잡하지만 필요한 경우에만 포이즌된 역방향을 제한하는 보다 철저한 작업을 수행합니다.

- 두 알고리즘의 목표는 이전 경로가 동일한 출력 인터페이스를 사용했다고 확신할 수 없는 한 마지막 경로 수명\(일반적으로 180초\) 동안 경로가 변경된 모든 대상에 대해 포이즌 리버스가 수행되도록 하는 것입니다. 경로 수명은 RIP가 오래된 경로를 부실하다고 선언하기 전에 유지하는 시간이기 때문에 사용됩니다.

- 다음 알고리즘에 사용되는 시간 간격\(및 파생 변수\)은 다음과 같습니다.

- 화 업데이트 타이머; RIP 업데이트 사이의 시간\(초\)입니다. 일반적으로 기본값은 30초입니다.

- Rl 경로 수명\(초\)입니다. 이는 업데이트가 필요하지 않고 경로가 양호하다고 추정되는 시간입니다. 일반적으로 기본값은 180초입니다.

- Ul 업데이트 손실; RIP가 경로를 삭제하기 전에 경로를 언급하지 않거나 손실되어야 하는 연속 업데이트 수입니다. Ul은 \(Rl/Tu\)+1로 계산됩니다. +1은 ifcounter가 처음으로 감소하는 시간이 초기화된 후 Tu 초보다 작다는 사실을 설명하기 위한 것입니다. 일반적으로 Ul은 7:\(180/30\)+1입니다.

- In 목적지를 새로 학습했을 때 ifcounter에 설정할 값입니다. 이 값은 Ul-4입니다. 여기서 4는 RIP의 가비지 수집 타이머/30입니다.

- 첫 번째 알고리즘은 다음과 같습니다.

- - 각 대상과 연관된 카운터는 아래 ifcounter라고 합니다. 목적지의 ifcounter가 0보다 큰 모든 경로에 대해 포이즌 리버스가 수행됩니다.

- - 일반\(트리거되지 않거나 요청에 대한 응답으로\) 업데이트가 전송된 후 0이 아닌 모든 ifcounter가 1씩 감소합니다.

- - 목적지까지의 경로가 생성되면 해당 ifcounter가 다음과 같이 설정됩니다.

- - 새 경로가 유효한 경로를 대체하고 이전 경로가 다른\(논리적\) 출력 인터페이스를 사용한 경우 ifcounter는 Ul로 설정됩니다.

- - 새 경로가 오래된 경로를 대체하고 이전 경로가 다른\(논리적\) 출력 인터페이스를 사용한 경우 ifcounter는 MAX\(0, Ul - INT\(경로가 오래된 경로의 초/Ut\)로 설정됩니다.

- - 목적지까지의 이전 경로가 없는 경우 ifcounter가 In으로 설정됩니다.

- - 그렇지 않으면 ifcounter가 0으로 설정됩니다.

- - RIP는 또한 아래의 재설정 타이머라고 하는 타이머를 유지 관리합니다. 재설정 타이머가 만료되지 않을 때마다\(ifcounter 값에 관계없이\) 모든 경로에서 포이즌 리버스가 수행됩니다.

- - RIP가 시작, 재시작, 재설정되거나 라우팅 테이블이 지워지면 재설정 타이머가 R1초 내에 꺼지도록 설정됩니다.

- 두 번째 알고리즘은 다음을 제외하고 첫 번째 알고리즘과 동일합니다.

- - ifcounter를 0이 아닌 값으로 설정하는 규칙이 항상 Rl/Tu로 설정되도록 변경되었습니다.

- - 재설정 타이머가 제거되었습니다.

```text
 Triggered updates: [ROUTE:3], page 15-16; page 29
```

- 트리거된 업데이트\(플래시 업데이트라고도 함\)는 라우터가 경로를 추가 또는 삭제하거나 메트릭을 변경할 때 라우터의 이웃에게 즉시 알리는 메커니즘입니다. 라우터는 경로가 삭제되거나 메트릭이 증가할 때 트리거된 업데이트를 보내야 합니다. 라우터는 경로가 추가되거나 메트릭이 감소할 때 트리거된 업데이트를 보낼 수 있습니다.\(MUST, MAY\)

- 트리거된 업데이트는 과도한 라우팅 오버헤드를 유발할 수 있으므로 구현에서는 트리거된 업데이트의 빈도를 제한하기 위해 다음 메커니즘을 사용해야 합니다.\(MUST\)

- \(1\) 라우터는 트리거된 업데이트를 보낼 때 타이머를 향후 1\~5초 사이의 임의 시간으로 설정합니다. 라우터는 이 타이머가 만료되기 전에 추가로 트리거된 업데이트를 생성해서는 안 됩니다.

- \(2\) 라우터가 이 간격 동안 트리거 업데이트를 생성하는 경우 트리거 업데이트가 필요함을 나타내는 플래그를 설정합니다. 라우터는 원하는 트리거 업데이트도 기록합니다.

- \(3\) 트리거 업데이트 타이머가 만료되면 라우터는 트리거 업데이트 플래그를 확인합니다. 플래그가 설정되면 라우터는 기록된 모든 변경 사항을 포함하는 단일 트리거 업데이트를 보냅니다. 그런 다음 라우터는 플래그를 지우고 트리거된 업데이트가 전송되었으므로 이 알고리즘을 다시 시작합니다.

- \(4\) 정기적인 업데이트가 전송될 때마다 플래그도 지워집니다.

- 트리거된 업데이트는 가장 최근의 정기\(비트리거된\) 업데이트 이후 변경된 모든 경로를 포함해야 합니다. 트리거된 업데이트는 가장 최근의 정기 업데이트 이후 변경되지 않은 경로를 포함해서는 안 됩니다.\(SHOULD, MUST NOT\)

논의

- 최근 변경되었는지 여부에 관계없이 모든 경로를 보내는 것은 트리거된 업데이트에서 허용되지 않습니다. 그렇지 않으면 많은 인터넷 라우팅 테이블의 엄청난 크기로 인해 트리거된 업데이트에서 상당한 대역폭이 낭비될 수 있기 때문입니다.

---
# **Use of UDP: [ROUTE:3], page 18-19.**

IP 브로드캐스트 주소로 전송된 RIP 패킷의 초기 TTL은 1로 설정되어야 합니다.\(SHOULD\)

이 메모의 섹션 \[6.1\]을 준수하려면 라우터는 자신이 생성한 RIP 패킷에서 UDP 체크섬을 사용해야 하며 유효하지 않은 UDP 체크섬으로 수신된 RIP 패킷을 폐기해야 하지만 수신된 RIP 패킷이 UDP를 포함하지 않는다는 이유만으로 폐기해서는 안 됩니다. 체크섬.\(MUST NOT\)

---
# **Addressing Considerations: [ROUTE:3], page 22**

RIP 구현은 호스트 경로를 지원해야 합니다. 그렇지 않은 경우에는 \(\[ROUTE:3\]의 27페이지에 설명된 대로\) 수신된 업데이트의 호스트 경로를 무시해야 합니다. 라우터는 무시된 호스트 경로를 기록할 수 있습니다.\(SHOULD, MUST, MAY\)

특수 주소 0.0.0.0은 기본 경로를 설명하는 데 사용됩니다. 기본 경로는 최후의 수단\(즉, 특정 네트에 대한 경로가 라우팅 테이블에 존재하지 않는 경우\)으로 사용됩니다. 라우터는 주소 0.0.0.0에 대한 RIP 항목을 생성할 수 있어야 합니다.\(MUST\)

---
# **Input Processing - Response: [ROUTE:3], page 26**

업데이트를 처리할 때 다음 유효성 검사를 수행해야 합니다.\(MUST\)

o 응답은 UDP 포트 520에서 이루어져야 합니다.\(MUST\)

o 유효한 것으로 간주되려면 소스 주소가 직접 연결된 서브넷\(또는 서브넷이 아닌 직접 연결된 네트워크\)에 있어야 합니다.\(MUST\)

o 소스 주소는 라우터 주소 중 하나가 되어서는 안 됩니다.\(MUST NOT\)

논의

- 일부 네트워크, 미디어 및 인터페이스에서는 송신 노드가 브로드캐스트하는 패킷을 수신할 수 있습니다. 라우터는 자신의 패킷을 유효한 라우팅 업데이트로 받아들이고 처리해서는 안 됩니다. 마지막 요구 사항은 라우터가 자체 라우팅 업데이트를 수락하고 처리하는 것을 방지합니다\(네트워크의 다른 라우터에서 보낸 것으로 가정\).

수신된 메트릭이 다음 경험적 방법을 따르는 경우를 제외하고 기존 메트릭과 동일한 경우 구현은 기존 경로를 대체해서는 안 됩니다.\(MUST NOT\)

구현은 위의 상황을 처리하기 위해 다음 경험적 방법을 구현하도록 선택할 수 있습니다. 일반적으로 둘 다 동일한 메트릭으로 광고되는 경우 한 라우터에서 다른 라우터로 네트워크 경로를 변경하는 것은 쓸모가 없습니다. 그러나 라우터 중 하나가 광고하는 경로가 시간 초과되는 중일 수 있습니다. 경로가 시간 초과될 때까지 기다리는 대신 지정된 시간이 경과한 후에 새 경로를 사용할 수 있습니다. 이 경험적 방법이 구현되면 새 경로가 설치되기 전에 만료 지점의 절반 이상을 기다려야 합니다.\(MAY, MUST\)

---
### **F.2.3 Specific Issues**
---
# **RIP Shutdown**

RIP 구현은 다음 단계를 사용하여 정상적인 종료를 제공해야 합니다.\(SHOULD\)

\(1\) 입력 처리가 종료되고,

\(2\) 4개의 업데이트가 2초에서 4초 사이의 무작위 간격으로 생성됩니다. 이러한 업데이트에는 이전에 발표된 모든 경로가 포함되지만 일부 메트릭이 변경됩니다. 무한대의 메트릭으로 발표된 경로는 이 메트릭을 계속 사용해야 합니다. 무한하지 않은 메트릭으로 발표된 경로는 메트릭 15\(무한대 - 1\)로 발표되어야 합니다.

논의

- 위에 사용된 측정항목은 실제로 16\(무한대\)이어야 합니다. 15로 설정하는 것은 RIP 프로토콜을 도청하는 특정 오래된 호스트를 손상시키는 것을 방지하는 데 어려움을 겪습니다. 이러한 호스트는 호스트가 대상에 대한 경로가 없는 동안 연결에서 데이터그램을 보내려고 하면 \(잘못으로\) TCP 연결을 중단합니다\(RIP가 호스트를 선택하는 동안 호스트에 경로가 없는 기간이 몇 초만 지속되는 경우에도 마찬가지\). 목적지까지의 대체 경로\).

---
# **RIP Split Horizon and Static Routes**

수평 분할은 기본적으로 정적 경로에 적용되어야 합니다\(SHOULD\). 구현은 정적 경로별로 분할 지평선이 이 경로에 적용되지 않아야 함을 지정하는 방법을 제공해야 합니다\(SHOULD\).\(SHOULD, SHOULD\)

---
## **F.3 GATEWAY TO GATEWAY PROTOCOL - GGP**

게이트웨이 대 게이트웨이 프로토콜은 더 이상 사용되지 않는 것으로 간주되므로 구현해서는 안 됩니다.\(SHOULD NOT\)

---
# **Acknowledgments**

```text
   O that we now had here
   But one ten thousand of those men in England
   That do no work to-day!
```

그 사람이 그렇게 바라는 게 뭐죠? 내 사촌 웨스트모어랜드요? 아니, 나의 아름다운 사촌이여. 만약 우리가 죽을 운명이라면, 우리는 나라를 잃을 준비가 되어 있습니다. 그리고 살기 위해서는 사람이 적을수록 명예는 더 커집니다. 하나님의 뜻! 나는 당신에게 기도합니다. 한 사람도 더 이상 바라지 마십시오. Jove에 따르면 나는 금을 탐내지 않으며 내 비용을 먹는 사람도 신경 쓰지 않습니다. 사람들이 내 옷을 입어도 나는 그리워하지 않습니다. 그러한 외적인 것들은 내 욕망에 거하지 않습니다. 그러나 명예를 탐하는 것이 죄라면, 나는 살아있는 가장 불쾌한 영혼입니다. 아니, 믿음이여, 영국 출신의 남자가 있기를 바라지 마세요. 신의 평화가 있기를! 나는 한 사람이 더 많은 명예를 나에게서 공유할 만큼 큰 명예를 잃지 않을 것입니다. 내가 가진 최고의 희망을 위해. 아, 더 이상 바라지 마세요! 차라리 웨스트모어랜드여, 내 호스트를 통해 이 싸움에 참여할 용기가 없는 사람은 떠나게 하라고 선포하십시오. 그의 여권이 만들어지고 호송을 위한 면류관이 그의 주머니에 넣어질 것입니다. 우리는 그의 교제를 두려워하여 우리와 함께 죽는 그 사람과 함께 죽지 않을 것입니다. 이 날은 크리스피안의 축제라고 불립니다. 이 날을 살아남아 무사히 집으로 돌아온 사람은 그 날이 명명될 때 발끝으로 서서 크리스피안의 이름으로 그를 깨울 것입니다. 오늘을 살고 늙어가는 사람은 매년 철야에 이웃을 잔치하며 '내일은 성 크리스피안'이라고 말할 것입니다. 그런 다음 그는 소매를 벗기고 흉터를 보여줄 것입니다. 그리고 '크리핀 시절에 내가 겪었던 상처들'이라고 말해주세요. 늙은이들은 잊어버리나니 모든 것이 잊혀지리라 그러나 그는 그 날 그가 행한 공적을 유익하게 기억할 것이요 그러면 우리의 이름도 그러하리라 그의 입에는 해리 왕, 베드포드와 엑서터, 워릭과 탤벗, 솔즈베리와 글로스터,

갓 기억되는 흐르는 컵에 들어가십시오. 이 이야기는 선한 사람이 자기 아들에게 가르칠 것이다. 그리고 Crispin Crispian은 결코 지나치지 않을 것입니다. 오늘부터 세상이 끝날 때까지, 그러나 그 안에 있는 우리는 기억될 것입니다. 우리는 소수, 우리는 행복한 소수, 우리는 형제들의 무리입니다. 오늘 나와 함께 피를 흘리는 사람은 내 형제가 될 것이다. 그가 결코 그렇게 악할지라도, 오늘은 그의 상태를 온화하게 할 것입니다: 그리고 지금 침대에 누워 있는 영국의 신사들은 자신들이 여기에 없었다고 스스로 저주받았다고 생각할 것입니다. 그리고 성 크리스핀의 날에 우리와 함께 싸웠던 사람들이 말하는 동안 그들의 남성다움을 값싸게 간직할 것입니다.

```text
                                   -- William Shakespeare
```

이 메모는 IETF의 라우터 요구 사항 워킹 그룹의 산물입니다. 이와 같은 메모는 여기에 나열할 수 있는 것보다 더 많은 사람들의 작업이 필요합니다. 인터넷 커뮤니티의 다양한 공급업체, 네트워크 관리자 및 기타 전문가들이 이 메모의 품질을 향상시키기 위해 시간과 지혜를 기꺼이 기부했습니다. 편집자는 그들 모두에게 진심으로 감사를 표하고 싶습니다.

현 편집자는 또한 이 문서의 원 편집자에게 진심 어린 감사와 감사의 말씀을 전하고 싶습니다. 필립 알름퀴스트. Philip의 작업이 없었다면, 원 편집자이자 작업 그룹의 의장으로서 이 문서는 제작되지 않았을 것입니다. 그는 또한 이전 편집자인 Frank Kastenholz에게도 깊은 감사를 표하고 싶습니다. Frank는 정보 모음에서 IP 기술에 대한 유용한 설명으로 원본 문서를 변경했습니다. 즉, 1991년 기술의 "스냅샷"입니다. 1994년 기술의 이 스냅샷이 그만큼 명확하기를 바랄 뿐입니다.

Philip Almquist, Jeffrey Burgan, Frank Kastenholz 및 Cathy Wittbrodt는 각각 이 메모의 주요 장을 썼습니다. 문서에 주요 공헌을 한 다른 사람들로는 Bill Barns, Steve Deering, Kent England, Jim Forster, Martin Gross, Jeff Honig, Steve Knowles, Yoni Malachi, Michael Reilly 및 Walt Wimer가 있습니다.

추가 텍스트는 Andy Malis, Paul Traina, Art Berggreen, John Cavanaugh, Ross Callon, John Lekashman, Brian Lloyd, Gary Malkin, Milo Medin, John Moy, Craig Partridge, Stephanie Price, Yakov Rekhter, Steve Senum, Richard Smith, Frank가 제공했습니다. 솔렌스키\(Solensky\), 리치 윈디\(Rich Woundy\) 등 의도치 않게 간과된 사람들입니다.

이 메모의 텍스트 중 일부는 이전 문서에서 \(뻔뻔스럽게도\) 표절되었습니다. 특히 Bob Braden과 호스트의 RFC-1122가 가장 유명합니다.

요구 사항 작업 그룹 및 Bob Braden과 Jon Postel의 RFC-1009. 이들 초기 작가들의 작업은 감사하게도 인정받고 있습니다.

Jim Forster는 초기 회의에서 라우터 요구 사항 실무 그룹의 공동 의장이었으며 그룹이 좋은 시작을 하는 데 중요한 역할을 했습니다. Jon Postel, Bob Braden, Walt Prue도 그룹의 첫 회의에 앞서 좋은 조언을 풍부하게 제공하여 성공에 기여했습니다. 나중에 Phill Gross, Vint Cerf 및 Noel Chiappa는 모두 귀중한 조언과 지원을 제공했습니다.

Mike St. Johns는 워킹 그룹과 보안 커뮤니티의 상호 작용을 조정했으며 Frank Kastenholz는 워킹 그룹과 네트워크 관리 영역의 상호 작용을 조정했습니다. 앨리슨 맨킨\(Allison Mankin\)과 K.K. Ramakrishnan은 혼잡 제어 및 자원 할당 문제에 대한 전문 지식을 제공했습니다.

여기에 나열되거나 언급될 수 있는 것보다 더 많은 사람들이 전자 메일을 통해 또는 회의에 참석하여 라우터 요구 사항 작업 그룹의 심의에 참여했습니다. 그러나 경로 선택과 경로 유출이라는 어려운 문제를 해결하기 위한 Ross Callon과 Vince Fuller의 노력은 특히 높이 평가됩니다.

편집자는 1994년 스냅샷을 제작하는 데 필요한 시간을 할애할 수 있도록 허락해 준 고용주인 Cisco Systems에 감사를 표합니다.

---
# **Editor's Address**

이 문서의 현재 편집자의 주소는 다음과 같습니다.

```text
      Fred Baker
      Cisco Systems
      519 Lado Drive
      Santa Barbara, California 93111
      USA

      Phone:+1 805-681-0115

      EMail: fred@cisco.com
```
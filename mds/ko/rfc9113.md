

```text
﻿

Internet Engineering Task Force (IETF)                   M. Thomson, Ed.
Request for Comments: 9113                                       Mozilla
Obsoletes: 7540, 8740                                   C. Benfield, Ed.
Category: Standards Track                                     Apple Inc.
ISSN: 2070-1721                                                June 2022

                                 HTTP/2
```

---
# **Abstract**

이 사양은 HTTP 버전 2\(HTTP/2\)라고 하는 HTTP\(Hypertext Transfer Protocol\) 의미의 최적화된 표현을 설명합니다. HTTP/2를 사용하면 필드 압축을 도입하고 동일한 연결에서 여러 동시 교환을 허용함으로써 네트워크 리소스를 보다 효율적으로 사용하고 대기 시간을 줄일 수 있습니다.

이 문서는 RFC 7540 및 8740을 폐기합니다.

---
# **Status of This Memo**

이것은 인터넷 표준 추적 문서입니다.

이 문서는 IETF\(Internet Engineering Task Force\)의 산물입니다. 이는 IETF 커뮤니티의 합의를 나타냅니다. 공개 검토를 받았으며 IESG\(Internet Engineering Steering Group\)의 게시 승인을 받았습니다. 인터넷 표준에 대한 추가 정보는 RFC 7841의 섹션 2에서 확인할 수 있습니다.

이 문서의 현재 상태, 정오표, 피드백 제공 방법에 대한 정보는 https://www.rfc-editor.org/info/rfc9113에서 확인할 수 있습니다.

---
# **Copyright Notice**

Copyright \(c\) 2022 IETF Trust 및 문서 작성자로 식별된 사람. 판권 소유.

이 문서에는 이 문서 발행일에 유효한 BCP 78 및 IETF 문서와 관련된 IETF Trust의 법적 조항\(https://trustee.ietf.org/license-info\)이 적용됩니다. 이 문서에 관한 귀하의 권리와 제한 사항이 설명되어 있으므로 이 문서를 주의 깊게 검토하십시오. 이 문서에서 추출된 코드 구성 요소는 신뢰 법률 조항의 섹션 4.e에 설명된 대로 개정된 BSD 라이센스 텍스트를 포함해야 하며 개정된 BSD 라이센스에 설명된 대로 보증 없이 제공됩니다.

---
# **Table of Contents**

```text
   1.  Introduction
   2.  HTTP/2 Protocol Overview
     2.1.  Document Organization
     2.2.  Conventions and Terminology
   3.  Starting HTTP/2
     3.1.  HTTP/2 Version Identification
     3.2.  Starting HTTP/2 for "https" URIs
     3.3.  Starting HTTP/2 with Prior Knowledge
     3.4.  HTTP/2 Connection Preface
   4.  HTTP Frames
     4.1.  Frame Format
     4.2.  Frame Size
     4.3.  Field Section Compression and Decompression
       4.3.1.  Compression State
   5.  Streams and Multiplexing
     5.1.  Stream States
       5.1.1.  Stream Identifiers
       5.1.2.  Stream Concurrency
     5.2.  Flow Control
       5.2.1.  Flow-Control Principles
       5.2.2.  Appropriate Use of Flow Control
       5.2.3.  Flow-Control Performance
     5.3.  Prioritization
       5.3.1.  Background on Priority in RFC 7540
       5.3.2.  Priority Signaling in This Document
     5.4.  Error Handling
       5.4.1.  Connection Error Handling
       5.4.2.  Stream Error Handling
       5.4.3.  Connection Termination
     5.5.  Extending HTTP/2
   6.  Frame Definitions
     6.1.  DATA
     6.2.  HEADERS
     6.3.  PRIORITY
     6.4.  RST_STREAM
     6.5.  SETTINGS
       6.5.1.  SETTINGS Format
       6.5.2.  Defined Settings
       6.5.3.  Settings Synchronization
     6.6.  PUSH_PROMISE
     6.7.  PING
     6.8.  GOAWAY
     6.9.  WINDOW_UPDATE
       6.9.1.  The Flow-Control Window
       6.9.2.  Initial Flow-Control Window Size
       6.9.3.  Reducing the Stream Window Size
     6.10. CONTINUATION
   7.  Error Codes
   8.  Expressing HTTP Semantics in HTTP/2
     8.1.  HTTP Message Framing
       8.1.1.  Malformed Messages
     8.2.  HTTP Fields
       8.2.1.  Field Validity
       8.2.2.  Connection-Specific Header Fields
       8.2.3.  Compressing the Cookie Header Field
     8.3.  HTTP Control Data
       8.3.1.  Request Pseudo-Header Fields
       8.3.2.  Response Pseudo-Header Fields
     8.4.  Server Push
       8.4.1.  Push Requests
       8.4.2.  Push Responses
     8.5.  The CONNECT Method
     8.6.  The Upgrade Header Field
     8.7.  Request Reliability
     8.8.  Examples
       8.8.1.  Simple Request
       8.8.2.  Simple Response
       8.8.3.  Complex Request
       8.8.4.  Response with Body
       8.8.5.  Informational Responses
   9.  HTTP/2 Connections
     9.1.  Connection Management
       9.1.1.  Connection Reuse
     9.2.  Use of TLS Features
       9.2.1.  TLS 1.2 Features
       9.2.2.  TLS 1.2 Cipher Suites
       9.2.3.  TLS 1.3 Features
   10. Security Considerations
     10.1.  Server Authority
     10.2.  Cross-Protocol Attacks
     10.3.  Intermediary Encapsulation Attacks
     10.4.  Cacheability of Pushed Responses
     10.5.  Denial-of-Service Considerations
       10.5.1.  Limits on Field Block Size
       10.5.2.  CONNECT Issues
     10.6.  Use of Compression
     10.7.  Use of Padding
     10.8.  Privacy Considerations
     10.9.  Remote Timing Attacks
   11. IANA Considerations
     11.1.  HTTP2-Settings Header Field Registration
     11.2.  The h2c Upgrade Token
   12. References
     12.1.  Normative References
     12.2.  Informative References
   Appendix A.  Prohibited TLS 1.2 Cipher Suites
   Appendix B.  Changes from RFC 7540
   Acknowledgments
   Contributors
   Authors' Addresses
```

---
## **1.  Introduction**

하이퍼텍스트 전송 프로토콜\(HTTP, \[HTTP\]\)을 사용하는 애플리케이션의 성능은 각 HTTP 버전이 기본 전송을 사용하는 방식 및 전송이 작동하는 조건과 연결됩니다.

여러 동시 요청을 수행하면 대기 시간이 줄어들고 애플리케이션 성능이 향상될 수 있습니다. HTTP/1.0에서는 주어진 TCP \[TCP\] 연결에서 한 번에 하나의 요청만 처리되도록 허용했습니다. HTTP/1.1 \[HTTP/1.1\]은 요청 파이프라인을 추가했지만 이는 요청 동시성을 부분적으로만 해결했으며 여전히 애플리케이션 계층 헤드 오브 라인 차단 문제를 겪고 있습니다. 따라서 HTTP/1.0 및 HTTP/1.1 클라이언트는 서버에 대한 다중 연결을 사용하여 동시 요청을 수행합니다.

또한 HTTP 필드는 반복적이고 장황한 경우가 많아 불필요한 네트워크 트래픽을 유발할 뿐만 아니라 초기 TCP 정체 창이 빠르게 채워지는 원인이 됩니다. 이로 인해 새 TCP 연결에서 여러 요청이 이루어질 때 과도한 대기 시간이 발생할 수 있습니다.

HTTP/2는 기본 연결에 대한 HTTP 의미 체계의 최적화된 매핑을 정의하여 이러한 문제를 해결합니다. 특히, 동일한 연결에서 메시지 인터리빙을 허용하고 HTTP 필드에 효율적인 코딩을 사용합니다. 또한 요청의 우선순위를 지정하여 더 중요한 요청을 더 빠르게 완료하고 성능을 더욱 향상시킬 수 있습니다.

결과 프로토콜은 HTTP/1.x에 비해 더 적은 수의 TCP 연결을 사용할 수 있으므로 네트워크에 더 친숙합니다. 이는 다른 흐름 및 수명이 긴 연결과의 경쟁이 줄어들고 결과적으로 사용 가능한 네트워크 용량의 활용도가 높아진다는 것을 의미합니다. 그러나 이 프로토콜에서는 TCP HOL 차단이 해결되지 않습니다.

마지막으로, HTTP/2는 이진 메시지 프레이밍을 사용하여 메시지를 보다 효율적으로 처리할 수도 있습니다.

이 문서는 RFC 7540 및 8740을 폐기합니다. 부록 B에는 주목할만한 변경 사항이 나열되어 있습니다.

---
## **2.  HTTP/2 Protocol Overview**

HTTP/2는 HTTP 의미 체계에 최적화된 전송을 제공합니다. HTTP/2는 HTTP의 모든 핵심 기능을 지원하지만 HTTP/1.1보다 더 효율적인 것을 목표로 합니다.

HTTP/2는 TCP 연결\(\[TCP\]\)을 통해 실행되는 연결 지향 애플리케이션 계층 프로토콜입니다. 클라이언트는 TCP 연결 개시자입니다.

HTTP/2의 기본 프로토콜 단위는 프레임입니다\(4.1절\). 각 프레임 유형은 서로 다른 용도로 사용됩니다. 예를 들어 HEADERS 및 DATA 프레임은 HTTP 요청 및 응답의 기초를 형성합니다\(섹션 8.1\). SETTINGS, WINDOW\_UPDATE 및 PUSH\_PROMISE와 같은 다른 프레임 유형은 다른 HTTP/2 기능을 지원하는 데 사용됩니다.

요청의 다중화는 각 HTTP 요청/응답 교환을 자체 스트림과 연결함으로써 달성됩니다\(섹션 5\). 스트림은 대체로 서로 독립적이므로 차단되거나 중단된 요청이나 응답이 다른 스트림의 진행을 방해하지 않습니다.

멀티플렉싱의 효과적인 사용은 흐름 제어 및 우선 순위에 따라 달라집니다. 흐름 제어\(5.2절\)는 전송되는 데이터를 수신기가 처리할 수 있는 데이터로 제한하여 다중화된 스트림을 효율적으로 사용할 수 있도록 보장합니다. 우선순위 지정\(섹션 5.3\)은 제한된 리소스가 가장 효과적으로 사용되도록 보장합니다. 이번 HTTP/2 개정판은 \[RFC7540\]의 우선순위 신호 체계를 더 이상 사용하지 않습니다.

연결에 사용되는 HTTP 필드에는 대량의 중복 데이터가 포함될 수 있으므로 이를 포함하는 프레임이 압축됩니다\(섹션 4.3\). 이는 일반적인 경우 요청 크기에 특히 유리한 영향을 미치므로 많은 요청을 하나의 패킷으로 압축할 수 있습니다.

마지막으로, HTTP/2는 서버가 클라이언트에 응답을 푸시할 수 있는 새로운 선택적 상호 작용 모드를 추가합니다\(섹션 8.4\). 이는 서버가 클라이언트에 필요하다고 예상하는 데이터를 서버가 추측적으로 클라이언트에 보낼 수 있도록 하여 잠재적인 대기 시간 이득과 일부 네트워크 사용량을 절충할 수 있도록 하기 위한 것입니다. 서버는 PUSH\_PROMISE 프레임으로 보내는 요청을 합성하여 이를 수행합니다. 그런 다음 서버는 별도의 스트림에서 합성 요청에 대한 응답을 보낼 수 있습니다.

---
### **2.1.  Document Organization**

HTTP/2 사양은 네 부분으로 나뉩니다.

\* HTTP/2 시작\(섹션 3\)에서는 HTTP/2 연결이 시작되는 방법을 다룹니다.

\* 프레임\(섹션 4\) 및 스트림\(섹션 5\) 레이어는 HTTP/2 프레임이 다중화된 스트림으로 구조화되고 형성되는 방식을 설명합니다.

\* 프레임\(Section 6\) 및 오류\(Section 7\) 정의에는 HTTP/2에서 사용되는 프레임 및 오류 유형에 대한 세부 정보가 포함됩니다.

\* HTTP 매핑\(8장\) 및 추가 요구 사항\(9장\)에서는 프레임과 스트림을 사용하여 HTTP 의미 체계를 표현하는 방법을 설명합니다.

프레임 및 스트림 계층 개념 중 일부는 HTTP와 격리되어 있지만 이 사양은 완전히 일반적인 프레임 계층을 정의하지는 않습니다. 프레임 및 스트림 계층은 HTTP의 요구 사항에 맞게 조정됩니다.

---
### **2.2.  Conventions and Terminology**

핵심 단어 "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY" 및 "OPTIONAL 이 문서의 "는 여기에 표시된 대로 모두 대문자로 표시되는 경우에만 BCP 14 \[RFC2119\] \[RFC8174\]에 설명된 대로 해석됩니다.

모든 숫자 값은 네트워크 바이트 순서로 되어 있습니다. 달리 명시하지 않는 한 값은 부호가 없습니다. 리터럴 값은 적절하게 10진수 또는 16진수로 제공됩니다. 16진수 리터럴에는 10진수 리터럴과 구별하기 위해 접두사 "0x"가 붙습니다.

이 사양은 RFC 9000 \[QUIC\]의 섹션 1.3에 설명된 규칙을 사용하여 이진 형식을 설명합니다. 이 형식은 네트워크 바이트 순서를 사용하며 높은 값의 비트가 낮은 값의 비트 앞에 나열된다는 점에 유의하세요.

다음 용어가 사용됩니다.

클라이언트: HTTP/2 연결을 시작하는 엔드포인트입니다. 클라이언트는 HTTP 요청을 보내고 HTTP 응답을 받습니다.

연결: 두 끝점 간의 전송 계층 연결입니다.

연결 오류: 전체 HTTP/2 연결에 영향을 미치는 오류입니다.

끝점: 연결의 클라이언트 또는 서버입니다.

프레임: HTTP/2 연결 내에서 가장 작은 통신 단위로, 프레임 유형에 따라 구성된 가변 길이 옥텟 시퀀스와 헤더로 구성됩니다.

피어: 엔드포인트입니다. 특정 엔드포인트를 논의할 때 "피어"는 주요 논의 주제와 멀리 떨어져 있는 엔드포인트를 나타냅니다.

수신자: 프레임을 수신하는 엔드포인트입니다.

송신자: 프레임을 전송하는 엔드포인트입니다.

서버: HTTP/2 연결을 수락하는 엔드포인트입니다. 서버는 HTTP 요청을 받고 HTTP 응답을 보냅니다.

스트림: HTTP/2 연결 내 프레임의 양방향 흐름입니다.

스트림 오류: 개별 HTTP/2 스트림의 오류입니다.

마지막으로 "게이트웨이", "중개자", "프록시" 및 "터널"이라는 용어는 \[HTTP\]의 섹션 3.7에 정의되어 있습니다. 중개자는 서로 다른 시간에 클라이언트와 서버 역할을 모두 수행합니다.

메시지 본문에 적용되는 "콘텐츠"라는 용어는 \[HTTP\]의 섹션 6.4에 정의되어 있습니다.

---
## **3.  Starting HTTP/2**

HTTP 요청을 생성하는 구현에서는 서버가 HTTP/2를 지원하는지 여부를 검색해야 합니다.

HTTP/2는 HTTP/1.1 \[HTTP/1.1\]과 동일한 기본 포트 번호를 사용하여 \[HTTP\]의 섹션 4.2에 정의된 "http" 및 "https" URI 체계를 사용합니다. 이러한 URI에는 업스트림 서버\(클라이언트가 연결을 설정하려는 직접적인 피어\)가 지원하는 HTTP 버전에 대한 표시가 포함되어 있지 않습니다.

HTTP/2 지원을 결정하는 방법은 "http"와 "https" URI에 따라 다릅니다. "https" URI 검색은 섹션 3.2에 설명되어 있습니다. "http" URI에 대한 HTTP/2 지원은 대역 외 수단을 통해서만 검색할 수 있으며 섹션 3.3에 설명된 대로 지원에 대한 사전 지식이 필요합니다.

---
### **3.1.  HTTP/2 Version Identification**

이 문서에 정의된 프로토콜에는 두 가지 식별자가 있습니다. 둘 중 하나를 기반으로 연결을 생성한다는 것은 이 문서에 설명된 전송, 프레이밍 및 메시지 의미 체계의 사용을 의미합니다.

\* 문자열 "h2"는 HTTP/2가 TLS\(전송 계층 보안\)를 사용하는 프로토콜을 식별합니다. 섹션 9.2를 참조하세요. 이 식별자는 TLS ALPN\(Application-Layer Protocol Negotiation\) 확장 \[TLS-ALPN\] 필드와 TLS를 통한 HTTP/2가 식별되는 모든 위치에서 사용됩니다.

- "h2" 문자열은 2옥텟 시퀀스\(0x68, 0x32\)로 ALPN 프로토콜 식별자로 직렬화됩니다.

\* "h2c" 문자열은 이전에 HTTP 업그레이드 메커니즘의 업그레이드 헤더 필드\(\[HTTP\]의 섹션 7.8\)에서 사용하기 위한 토큰으로 사용되었습니다. 이 사용법은 널리 배포된 적이 없으며 이 문서에서는 더 이상 사용되지 않습니다. "h2c"로의 업그레이드에 사용된 HTTP2-Settings 헤더 필드에도 동일하게 적용됩니다.

---
### **3.2.  Starting HTTP/2 for "https" URIs**

"https" URI에 요청하는 클라이언트는 ALPN 확장자 \[TLS-ALPN\]와 함께 TLS \[TLS13\]를 사용합니다.

TLS를 통한 HTTP/2는 "h2" 프로토콜 식별자를 사용합니다. "h2c" 프로토콜 식별자는 클라이언트에 의해 전송되거나 서버에 의해 선택되어서는 안 됩니다. "h2c" 프로토콜 식별자는 TLS를 사용하지 않는 프로토콜을 설명합니다.

TLS 협상이 완료되면 클라이언트와 서버 모두 연결 서문을 보내야 합니다\(섹션 3.4\).

---
### **3.3.  Starting HTTP/2 with Prior Knowledge**

클라이언트는 다른 방법을 통해 특정 서버가 HTTP/2를 지원한다는 것을 알 수 있습니다. 예를 들어, 서버가 HTTP/2를 지원한다는 사실을 알고 클라이언트를 구성할 수 있습니다.

서버가 HTTP/2를 지원한다는 것을 알고 있는 클라이언트는 TCP 연결을 설정하고 연결 서문\(섹션 3.4\)과 HTTP/2 프레임을 보낼 수 있습니다. 서버는 연결 머리말의 존재 여부를 통해 이러한 연결을 식별할 수 있습니다. 이는 일반 텍스트 TCP를 통한 HTTP/2 연결 설정에만 영향을 미칩니다. TLS를 통한 HTTP/2 연결은 TLS\[TLS-ALPN\]의 프로토콜 협상을 사용해야 합니다.

마찬가지로 서버는 연결 서문을 보내야 합니다\(섹션 3.4\).

추가 정보가 없으면 HTTP/2에 대한 사전 지원은 특정 서버가 향후 연결을 위해 HTTP/2를 지원할 것이라는 강력한 신호가 아닙니다. 예를 들어 서버 구성이 변경되거나, 클러스터링된 서버의 인스턴스 간에 구성이 다르거나, 네트워크 조건이 변경될 수 있습니다.

---
### **3.4.  HTTP/2 Connection Preface**

HTTP/2에서 각 끝점은 사용 중인 프로토콜의 최종 확인으로 연결 서문을 보내고 HTTP/2 연결에 대한 초기 설정을 구성해야 합니다. 클라이언트와 서버는 각각 다른 연결 서문을 보냅니다.

클라이언트 연결 머리말은 24옥텟의 시퀀스로 시작하며, 16진수 표기법은 다음과 같습니다.

```text
     0x505249202a20485454502f322e300d0a0d0a534d0d0a0d0a
```

즉, 연결 머리말은 "PRI \* HTTP/2.0\r\n\r\nSM\r\n\r\n" 문자열로 시작됩니다. 이 시퀀스 뒤에는 비어 있을 수 있는 SETTINGS 프레임\(6.5절\)이 와야 합니다. 클라이언트는 클라이언트 연결 서문을 연결의 첫 번째 애플리케이션 데이터 옥텟으로 보냅니다.

- | 참고: 클라이언트 연결 머리말은 큰 | HTTP/1.1 또는 HTTP/1.0 서버 및 중개자의 비율 | 추가 프레임을 처리하려고 시도하지 마십시오. | \[TALKING\]에서 제기된 우려 사항을 해결하지 마십시오.

서버 연결 서문은 서버가 HTTP/2 연결에서 보내는 첫 번째 프레임이어야 하는 잠재적으로 비어 있는 SETTINGS 프레임\(6.5절\)으로 구성됩니다.

연결 서문의 일부로 피어로부터 수신된 SETTINGS 프레임은 연결 서문을 보낸 후 반드시 승인되어야 합니다\(섹션 6.5.3 참조\).

불필요한 대기 시간을 피하기 위해 클라이언트는 서버 연결 서문을 수신할 때까지 기다리지 않고 클라이언트 연결 서문을 보낸 후 즉시 서버에 추가 프레임을 보낼 수 있습니다. 그러나 서버 연결 서문 SETTINGS 프레임에는 클라이언트가 서버와 통신하는 방법을 필연적으로 변경하는 설정이 포함될 수 있다는 점에 유의하는 것이 중요합니다. SETTINGS 프레임을 수신하면 클라이언트는 설정된 모든 설정을 준수해야 합니다. 일부 구성에서는 클라이언트가 추가 프레임을 보내기 전에 서버가 SETTINGS를 전송하여 이 문제를 피할 수 있는 기회를 제공할 수 있습니다.

클라이언트와 서버는 유효하지 않은 연결 서문을 PROTOCOL\_ERROR 유형의 연결 오류\(섹션 5.4.1\)로 처리해야 합니다. GOAWAY 프레임\(6.8절\)은 이 경우 생략될 수 있습니다. 잘못된 머리말은 피어가 HTTP/2를 사용하지 않음을 나타내기 때문입니다.

---
## **4.  HTTP Frames**

HTTP/2 연결이 설정되면 엔드포인트는 프레임 교환을 시작할 수 있습니다.

---
### **4.1.  Frame Format**

모든 프레임은 고정된 9옥텟 헤더로 시작하고 그 뒤에 가변 길이 프레임 페이로드가 옵니다.

```text
   HTTP Frame {
     Length (24),
     Type (8),

     Flags (8),

     Reserved (1),
     Stream Identifier (31),

     Frame Payload (..),
   }

                           Figure 1: Frame Layout
```

프레임 헤더의 필드는 다음과 같이 정의됩니다.

길이: 옥텟 단위의 부호 없는 24비트 정수로 표현되는 프레임 페이로드의 길이입니다. 수신자가 SETTINGS\_MAX\_FRAME\_SIZE에 대해 더 큰 값을 설정하지 않는 한 2^14\(16,384\)보다 큰 값은 전송되어서는 안 됩니다.

- 프레임 헤더의 9옥텟은 이 값에 포함되지 않습니다.

유형: 프레임의 8비트 유형입니다. 프레임 유형은 프레임의 형식과 의미를 결정합니다. 이 문서에 정의된 프레임은 섹션 6에 나열되어 있습니다. 구현에서는 알 수 없는 유형의 프레임을 무시하고 폐기해야 합니다.

플래그: 프레임 유형에 특정한 부울 플래그용으로 예약된 8비트 필드입니다.

- 플래그에는 표시된 프레임 유형에 특정한 의미가 할당됩니다. 사용되지 않는 플래그는 특정 프레임 유형에 대해 정의된 의미가 없는 플래그입니다. 사용되지 않은 플래그는 수신 시 무시되어야 하며 전송 시에는 설정되지 않은 상태\(0x00\)로 남아 있어야 합니다.

예약됨: 예약된 1비트 필드입니다. 이 비트의 의미는 정의되지 않았으며 전송할 때 비트가 설정되지 않은 상태\(0x00\)로 유지되어야 하고 수신할 때 무시되어야 합니다.

스트림 식별자: 부호 없는 31비트 정수로 표현되는 스트림 식별자\(섹션 5.1.1 참조\)입니다. 0x00 값은 개별 스트림이 아닌 전체적으로 연결과 연관된 프레임용으로 예약되어 있습니다.

프레임 페이로드의 구조와 내용은 전적으로 프레임 유형에 따라 달라집니다.

---
### **4.2.  Frame Size**

프레임 페이로드의 크기는 수신기가 SETTINGS\_MAX\_FRAME\_SIZE 설정에서 알리는 최대 크기에 의해 제한됩니다. 이 설정은 2^14\(16,384\)에서 2^24-1\(16,777,215\)옥텟 사이의 값을 가질 수 있습니다.

모든 구현은 최대 2^14 옥텟 길이의 프레임과 9옥텟 프레임 헤더\(섹션 4.1\)를 수신하고 최소한 처리할 수 있어야 합니다\(MUST\). 프레임 크기를 기술할 때 프레임 헤더의 크기는 포함되지 않습니다.

- | 참고: PING\(6.7절\)과 같은 특정 프레임 유형은 | 허용되는 프레임 페이로드 데이터 양에 대한 추가 제한.

프레임이 SETTINGS\_MAX\_FRAME\_SIZE에 정의된 크기를 초과하거나, 프레임 유형에 정의된 제한을 초과하거나, 필수 프레임 데이터를 포함하기에는 너무 작은 경우 엔드포인트는 FRAME\_SIZE\_ERROR 오류 코드를 전송해야 합니다. 전체 연결 상태를 변경할 수 있는 프레임의 프레임 크기 오류는 연결 오류로 처리되어야 합니다\(5.4.1절\). 여기에는 필드 블록\(4.3절\)\(즉, HEADERS, PUSH\_PROMISE 및 CONTINUATION\)을 전달하는 모든 프레임, SETTINGS 프레임 및 스트림 식별자가 0인 모든 프레임이 포함됩니다.

엔드포인트는 프레임에서 사용 가능한 모든 공간을 사용할 의무가 없습니다. 허용되는 최대 크기보다 작은 프레임을 사용하면 응답성을 향상시킬 수 있습니다. 대형 프레임을 전송하면 시간에 민감한 프레임\(예: RST\_STREAM, WINDOW\_UPDATE 또는 PRIORITY\) 전송이 지연될 수 있으며, 대형 프레임 전송으로 인해 차단되면 성능에 영향을 미칠 수 있습니다.

---
### **4.3.  Field Section Compression and Decompression**

필드 섹션 압축은 필드 라인 세트\(\[HTTP\]의 섹션 5.2\)를 압축하여 필드 블록을 형성하는 프로세스입니다. 필드 섹션 압축 해제는 필드 블록을 필드 라인 세트로 디코딩하는 프로세스입니다. HTTP/2 필드 섹션 압축 및 압축 풀기에 대한 자세한 내용은 \[COMPRESSION\]에 정의되어 있으며, 역사적인 이유로 이러한 프로세스를 헤더 압축 및 압축 풀기라고 합니다.

각 필드 블록은 단일 필드 섹션의 압축된 필드 라인을 모두 전달합니다. 헤더 섹션에는 필드 줄과 동일한 형식을 사용하는 의사 헤더 필드\(섹션 8.3\) 형식의 메시지와 관련된 제어 데이터도 포함됩니다.

- | 참고: RFC 7540 \[RFC7540\]에서는 "헤더 블록"이라는 용어를 사용했습니다. | 보다 일반적인 "필드 블록"입니다.

필드 블록은 요청, 응답, 약속된 요청 및 푸시된 응답에 대한 제어 데이터와 헤더 섹션을 전달합니다\(섹션 8.4 참조\). PUSH\_PROMISE\(6.6절\) 프레임에 포함된 임시 응답 및 요청을 제외한 모든 메시지에는 선택적으로 트레일러 섹션을 전달하는 필드 블록이 포함될 수 있습니다.

필드 섹션은 필드 라인의 모음입니다. 필드 블록의 각 필드 라인은 단일 값을 전달합니다. 그런 다음 직렬화된 필드 블록은 필드 블록 조각이라고 하는 하나 이상의 옥텟 시퀀스로 나뉩니다. 첫 번째 필드 블록 조각은 HEADERS\(섹션 6.2\) 또는 PUSH\_PROMISE\(섹션 6.6\)의 프레임 페이로드 내에서 전송되며, 각 프레임 뒤에는 후속 필드 블록 조각을 전달하기 위한 CONTINUATION\(섹션 6.10\) 프레임이 뒤따를 수 있습니다.

쿠키 헤더 필드 \[COOKIE\]는 HTTP 매핑에 의해 특별히 처리됩니다\(섹션 8.2.3 참조\).

수신 엔드포인트는 조각을 연결하여 필드 블록을 재조립한 다음 블록의 압축을 풀어 필드 섹션을 재구성합니다.

전체 필드 섹션은 다음 중 하나로 구성됩니다.

\* END\_HEADERS 플래그가 설정된 단일 HEADERS 또는 PUSH\_PROMISE 프레임, 또는

\* END\_HEADERS 플래그가 설정되지 않은 HEADERS 또는 PUSH\_PROMISE 프레임과 마지막 CONTINUATION 프레임에 END\_HEADERS 플래그가 설정된 하나 이상의 CONTINUATION 프레임.

각 필드 블록은 개별 단위로 처리됩니다. 필드 블록은 다른 유형이나 다른 스트림의 인터리빙된 프레임 없이 연속적인 프레임 시퀀스로 전송되어야 합니다. HEADERS 또는 CONTINUATION 프레임 시퀀스의 마지막 프레임에는 END\_HEADERS 플래그가 설정되어 있습니다. PUSH\_PROMISE 또는 CONTINUATION 프레임 시퀀스의 마지막 프레임에는 END\_HEADERS 플래그가 설정되어 있습니다. 이를 통해 필드 블록이 단일 프레임과 논리적으로 동일해질 수 있습니다.

필드 블록 조각은 HEADERS, PUSH\_PROMISE 또는 CONTINUATION 프레임의 프레임 페이로드로만 전송될 수 있습니다. 이러한 프레임은 수신자가 유지 관리하는 압축 컨텍스트를 수정할 수 있는 데이터를 전달하기 때문입니다. HEADERS, PUSH\_PROMISE 또는 CONTINUATION 프레임을 수신하는 엔드포인트는 프레임이 삭제되더라도 필드 블록을 재조립하고 압축 해제를 수행해야 합니다. 수신기는 필드 블록의 압축을 풀지 않는 경우 COMPRESSION\_ERROR 유형의 연결 오류\(섹션 5.4.1\)로 연결을 종료해야 합니다.

필드 블록의 디코딩 오류는 COMPRESSION\_ERROR 유형의 연결 오류\(섹션 5.4.1\)로 처리되어야 합니다.

---
#### **4.3.1.  Compression State**

필드 압축은 상태 저장입니다. 각 끝점에는 연결의 모든 필드 블록을 인코딩하고 디코딩하는 데 사용되는 HPACK 인코더 컨텍스트와 HPACK 디코더 컨텍스트가 있습니다. \[COMPRESSION\]의 섹션 4는 각 컨텍스트의 기본 상태인 동적 테이블을 정의합니다.

동적 테이블에는 HPACK 디코더에 의해 설정되는 최대 크기가 있습니다. 엔드포인트는 SETTINGS\_HEADER\_TABLE\_SIZE 설정을 사용하여 HPACK 디코더 컨텍스트에서 선택한 크기를 전달합니다. 섹션 6.5.2를 참조하세요. 연결이 설정되면 두 끝점의 HPACK 디코더 및 인코더에 대한 동적 테이블 크기는 SETTINGS\_HEADER\_TABLE\_SIZE 설정의 초기 값인 4,096바이트에서 시작됩니다.

SETTINGS\_HEADER\_TABLE\_SIZE를 사용하여 설정된 최대값에 대한 변경 사항은 엔드포인트가 설정을 승인할 때 적용됩니다\(섹션 6.5.3\). 해당 끝점의 HPACK 인코더는 디코더에서 설정한 최대값까지 임의의 크기로 동적 테이블을 설정할 수 있습니다. HPACK 인코더는 동적 테이블 크기 업데이트 명령\(\[COMPRESSION\]의 섹션 6.3\)을 사용하여 동적 테이블의 크기를 선언합니다.

엔드포인트가 동적 테이블의 현재 크기보다 최대값을 줄이는 SETTINGS\_HEADER\_TABLE\_SIZE에 대한 변경을 승인하면 해당 HPACK 인코더는 동적 테이블을 다음 크기보다 작은 크기로 설정하는 동적 테이블 크기 업데이트 명령을 사용하여 다음 필드 블록을 시작해야 합니다. 감소된 최대값과 같습니다. \[압축\]의 섹션 4.2를 참조하세요. 엔드포인트는 적합한 동적 테이블 크기 업데이트 명령으로 시작하지 않는 경우 COMPRESSION\_ERROR 유형의 연결 오류\(섹션 5.4.1\)로 최대 동적 테이블 크기 감소에 대한 승인을 따르는 필드 블록을 처리해야 합니다.

- | 구현자는 | SETTINGS\_HEADER\_TABLE\_SIZE는 광범위하게 상호 운용되지 않습니다. 사용 | 연결 서문을 사용하여 초기 값 아래로 | 4,096의 값이 다소 더 잘 지원되지만 | 일부 구현에서는 실패합니다.

---
## **5.  Streams and Multiplexing**

"스트림"은 HTTP/2 연결 내에서 클라이언트와 서버 간에 교환되는 독립적인 양방향 프레임 시퀀스입니다. 스트림에는 몇 가지 중요한 특성이 있습니다.

\* 단일 HTTP/2 연결에는 여러 스트림의 프레임을 인터리브하는 끝점과 함께 동시에 열려 있는 여러 스트림이 포함될 수 있습니다.

\* 스트림은 일방적으로 설정 및 사용되거나 두 엔드포인트에서 공유될 수 있습니다.

\* 스트림은 어느 끝점에서나 닫힐 수 있습니다.

\* 프레임이 전송되는 순서는 중요합니다. 수신자는 수신된 순서대로 프레임을 처리합니다. 특히 HEADERS 및 DATA 프레임의 순서는 의미상 중요합니다.

\* 스트림은 정수로 식별됩니다. 스트림 식별자는 스트림을 시작하는 엔드포인트에 의해 스트림에 할당됩니다.

---
### **5.1.  Stream States**

스트림의 수명주기는 그림 2에 나와 있습니다.

```text
                                +--------+
                        send PP |        | recv PP
                       ,--------+  idle  +--------.
                      /         |        |         \
                     v          +--------+          v
              +----------+          |           +----------+
              |          |          | send H /  |          |
       ,------+ reserved |          | recv H    | reserved +------.
       |      | (local)  |          |           | (remote) |      |
       |      +---+------+          v           +------+---+      |
       |          |             +--------+             |          |
       |          |     recv ES |        | send ES     |          |
       |   send H |     ,-------+  open  +-------.     | recv H   |
       |          |    /        |        |        \    |          |
       |          v   v         +---+----+         v   v          |
       |      +----------+          |           +----------+      |
       |      |   half-  |          |           |   half-  |      |
       |      |  closed  |          | send R /  |  closed  |      |
       |      | (remote) |          | recv R    | (local)  |      |
       |      +----+-----+          |           +-----+----+      |
       |           |                |                 |           |
       |           | send ES /      |       recv ES / |           |
       |           |  send R /      v        send R / |           |
       |           |  recv R    +--------+   recv R   |           |
       | send R /  `----------->|        |<-----------'  send R / |
       | recv R                 | closed |               recv R   |
       `----------------------->|        |<-----------------------'
                                +--------+

                          Figure 2: Stream States
```

send: 끝점은 이 프레임을 보냅니다. recv: 끝점은 이 프레임을 받습니다. H: HEADERS 프레임\(암묵적인 CONTINUATION 프레임 포함\) ES: END\_STREAM 플래그 R: RST\_STREAM 프레임 PP: PUSH\_PROMISE 프레임\(암묵적 CONTINUATION 프레임 포함\); 상태 전환은 약속된 스트림을 위한 것입니다.

이 다이어그램은 스트림 상태 전환과 이러한 전환에만 영향을 미치는 프레임 및 플래그를 보여줍니다. 이와 관련하여 CONTINUATION 프레임은 상태 전환을 초래하지 않습니다. 그들은 실제로 따르는 HEADERS 또는 PUSH\_PROMISE의 일부입니다. 상태 전환을 위해 END\_STREAM 플래그는 이를 포함하는 프레임에 대한 별도의 이벤트로 처리됩니다. END\_STREAM 플래그가 설정된 HEADERS 프레임은 두 가지 상태 전환을 일으킬 수 있습니다.

두 엔드포인트 모두 프레임이 전송 중일 때 다를 수 있는 스트림 상태에 대한 주관적인 보기를 갖습니다. 엔드포인트는 스트림 생성을 조정하지 않습니다. 두 끝점 중 하나에서 일방적으로 생성됩니다. 상태 불일치로 인한 부정적인 결과는 RST\_STREAM을 보낸 후 "닫힌" 상태로 제한되며, 여기서 닫힌 후 얼마 동안 프레임이 수신될 수 있습니다.

스트림에는 다음과 같은 상태가 있습니다.

유휴: 모든 스트림이 "유휴" 상태에서 시작됩니다.

- 이 상태에서는 다음 전환이 유효합니다.

- \* HEADERS 프레임을 클라이언트로 보내거나 HEADERS 프레임을 서버로 수신하면 스트림이 "개방"됩니다. 스트림 식별자는 섹션 5.1.1에 설명된 대로 선택됩니다. 동일한 HEADERS 프레임으로 인해 스트림이 즉시 "반 폐쇄"될 수도 있습니다.

- \* 다른 스트림에서 PUSH\_PROMISE 프레임을 보내면 나중에 사용하기 위해 식별된 유휴 스트림이 예약됩니다. 예약된 스트림의 스트림 상태가 "예약됨\(로컬\)"으로 전환됩니다. 서버만이 PUSH\_PROMISE 프레임을 보낼 수 있습니다.

- \* 다른 스트림에서 PUSH\_PROMISE 프레임을 수신하면 나중에 사용하기 위해 식별되는 유휴 스트림이 예약됩니다. 예약된 스트림의 스트림 상태가 "예약됨\(원격\)"으로 전환됩니다. 클라이언트만 PUSH\_PROMISE 프레임을 수신할 수 있습니다.

- \* PUSH\_PROMISE 프레임은 유휴 스트림에서 전송되지 않지만 약속된 스트림 ID 필드에서 새로 예약된 스트림을 참조합니다.

- \* 더 높은 값의 스트림 식별자로 스트림을 열면 스트림이 즉시 "닫힌" 상태로 전환됩니다. 이 전환은 다이어그램에 표시되지 않습니다.

- 이 상태의 스트림에서 HEADERS 또는 PRIORITY 이외의 프레임을 수신하는 것은 PROTOCOL\_ERROR 유형의 연결 오류\(섹션 5.4.1\)로 처리되어야 합니다. 섹션 5.1.1에 설명된 대로 이 스트림이 서버에 의해 시작되면 HEADERS 프레임 수신도 PROTOCOL\_ERROR 유형의 연결 오류\(섹션 5.4.1\)로 처리되어야 합니다.

예약됨\(로컬\): "예약됨\(로컬\)" 상태의 스트림은 PUSH\_PROMISE 프레임을 전송하여 약속된 스트림입니다. PUSH\_PROMISE 프레임은 스트림을 원격 피어에 의해 시작된 개방형 스트림과 연결하여 유휴 스트림을 예약합니다\(섹션 8.4 참조\).

- 이 상태에서는 다음과 같은 전환만 가능합니다.

- \* 끝점은 HEADERS 프레임을 보낼 수 있습니다. 이로 인해 스트림이 "반쯤 닫힌\(원격\)" 상태로 열립니다.

- \* 두 끝점 모두 RST\_STREAM 프레임을 보내 스트림을 "닫게" 할 수 있습니다. 그러면 스트림 예약이 해제됩니다.

- 엔드포인트는 이 상태에서 HEADERS, RST\_STREAM 또는 PRIORITY 이외의 어떤 유형의 프레임도 전송해서는 안 됩니다.

- 이 상태에서는 PRIORITY 또는 WINDOW\_UPDATE 프레임이 수신될 수 있습니다. 이 상태의 스트림에서 RST\_STREAM, PRIORITY 또는 WINDOW\_UPDATE 이외의 모든 유형의 프레임을 수신하는 것은 PROTOCOL\_ERROR 유형의 연결 오류\(섹션 5.4.1\)로 처리되어야 합니다.

예약됨\(원격\): "예약됨\(원격\)" 상태의 스트림이 원격 피어에 의해 예약되었습니다.

- 이 상태에서는 다음과 같은 전환만 가능합니다.

- \* HEADERS 프레임을 수신하면 스트림이 "반 폐쇄\(로컬\)"로 전환됩니다.

- \* 두 끝점 모두 RST\_STREAM 프레임을 보내 스트림을 "닫게" 할 수 있습니다. 그러면 스트림 예약이 해제됩니다.

- 엔드포인트는 이 상태에서 RST\_STREAM, WINDOW\_UPDATE 또는 PRIORITY 이외의 어떤 유형의 프레임도 전송해서는 안 됩니다.

- 이 상태의 스트림에서 HEADERS, RST\_STREAM 또는 PRIORITY 이외의 모든 유형의 프레임을 수신하는 것은 PROTOCOL\_ERROR 유형의 연결 오류\(섹션 5.4.1\)로 처리되어야 합니다.

open: "open" 상태의 스트림은 두 피어 모두에서 모든 유형의 프레임을 보내는 데 사용될 수 있습니다. 이 상태에서 송신 피어는 공지된 스트림 수준 흐름 제어 제한\(섹션 5.2\)을 준수합니다.

- 이 상태에서 양쪽 끝점 중 하나는 END\_STREAM 플래그가 설정된 프레임을 보낼 수 있으며, 이로 인해 스트림이 "반 닫힘" 상태 중 하나로 전환됩니다. END\_STREAM 플래그를 보내는 엔드포인트로 인해 스트림 상태가 "반 폐쇄\(로컬\)"가 됩니다. END\_STREAM 플래그를 수신하는 엔드포인트는 스트림 상태를 "반 폐쇄\(원격\)"로 만듭니다.

- 두 끝점 모두 이 상태에서 RST\_STREAM 프레임을 보내 즉시 "닫힘"으로 전환되도록 할 수 있습니다.

반 폐쇄\(로컬\): "반 폐쇄\(로컬\)" 상태의 스트림은 WINDOW\_UPDATE, PRIORITY 및 RST\_STREAM 이외의 프레임을 전송하는 데 사용할 수 없습니다.

- END\_STREAM 플래그가 설정된 프레임이 수신되거나 피어 중 하나가 RST\_STREAM 프레임을 보낼 때 스트림은 이 상태에서 "닫힌" 상태로 전환됩니다.

- 엔드포인트는 이 상태에서 모든 유형의 프레임을 수신할 수 있습니다. 흐름 제어 프레임을 계속 수신하려면 WINDOW\_UPDATE 프레임을 사용하여 흐름 제어 크레딧을 제공해야 합니다. 이 상태에서 수신자는 END\_STREAM 플래그가 설정된 프레임이 전송된 후 짧은 기간 동안 도착할 수 있는 WINDOW\_UPDATE 프레임을 무시할 수 있습니다.

- 이 상태에서는 PRIORITY 프레임을 수신할 수 있습니다.

반 폐쇄\(원격\): "반 폐쇄\(원격\)"인 스트림은 더 이상 피어에서 프레임을 보내는 데 사용되지 않습니다. 이 상태에서는 엔드포인트가 더 이상 수신자 흐름 제어 창을 유지할 의무가 없습니다.

- 엔드포인트가 이 상태의 스트림에 대해 WINDOW\_UPDATE, PRIORITY 또는 RST\_STREAM 이외의 추가 프레임을 수신하는 경우 STREAM\_CLOSED 유형의 스트림 오류\(섹션 5.4.2\)로 응답해야 합니다.

- "반 폐쇄\(원격\)"인 스트림은 엔드포인트에서 모든 유형의 프레임을 보내는 데 사용될 수 있습니다. 이 상태에서 엔드포인트는 공지된 스트림 수준 흐름 제어 제한\(섹션 5.2\)을 계속 관찰합니다.

- 스트림은 END\_STREAM 플래그가 설정된 프레임을 보내거나 피어 중 하나가 RST\_STREAM 프레임을 보낼 때 이 상태에서 "닫힌" 상태로 전환될 수 있습니다.

닫힘: "닫힘" 상태는 최종 상태입니다.

- 엔드포인트가 END\_STREAM 플래그가 설정된 프레임을 보내고 받은 후 스트림은 "닫힌" 상태로 들어갑니다. 엔드포인트가 RST\_STREAM 프레임을 보내거나 받은 후에도 스트림은 "닫힌" 상태로 들어갑니다.

- 엔드포인트는 닫힌 스트림에서 PRIORITY 이외의 프레임을 보내면 안 됩니다. 엔드포인트는 아래에 명시된 경우를 제외하고 닫힌 스트림에서 다른 유형의 프레임 수신을 STREAM\_CLOSED 유형의 연결 오류\(섹션 5.4.1\)로 처리할 수 있습니다.

- END\_STREAM 플래그가 설정된 프레임 또는 RST\_STREAM 프레임을 전송하는 엔드포인트는 피어가 스트림을 닫는 프레임을 수신하고 처리하기 전에 해당 피어로부터 WINDOW\_UPDATE 또는 RST\_STREAM 프레임을 수신할 수 있습니다.

- "개방" 또는 "반 폐쇄\(로컬\)" 상태인 스트림에서 RST\_STREAM 프레임을 보내는 엔드포인트는 모든 유형의 프레임을 수신할 수 있습니다. 피어는 RST\_STREAM 프레임을 처리하기 전에 이러한 프레임을 전송하거나 전송하기 위해 대기열에 넣었을 수 있습니다. 엔드포인트는 이 상태에서 수신하는 모든 프레임을 최소한으로 처리한 다음 삭제해야 합니다\(MUST\). 이는 HEADERS 및 PUSH\_PROMISE 프레임에 대한 헤더 압축 상태를 업데이트하는 것을 의미합니다. PUSH\_PROMISE 프레임을 수신하면 PUSH\_PROMISE 프레임이 닫힌 스트림에서 수신되는 경우에도 약속된 스트림이 "예약\(원격\)" 상태가 됩니다. 또한 DATA 프레임의 내용은 연결 흐름 제어 창에 포함됩니다.

- 엔드포인트는 "닫힌" 상태에 있는 모든 스트림에 대해 이 최소 처리를 수행할 수 있습니다. 엔드포인트는 다른 신호를 사용하여 스트림이 "닫힌" 상태에 들어가도록 하는 프레임을 피어가 수신했는지 감지하고 PRIORITY 이외의 프레임 수신을 PROTOCOL\_ERROR 유형의 연결 오류\(섹션 5.4.1\)로 처리할 수 있습니다. 엔드포인트는 피어가 이를 구동하기 위해 종료 신호를 수신했음을 나타내는 프레임을 사용할 수 있습니다. 엔드포인트는 이러한 목적으로 타이머를 사용해서는 안 됩니다. 예를 들어, 스트림을 닫은 후 SETTINGS 프레임을 보내는 엔드포인트는 설정 승인을 받은 후 해당 스트림의 DATA 프레임 수신을 오류로 안전하게 처리할 수 있습니다. 사용될 수 있는 다른 것들은 PING 프레임, 스트림을 닫은 후 생성된 스트림에서 데이터 수신 또는 스트림을 닫은 후 생성된 요청에 대한 응답입니다.

더 구체적인 규칙이 없는 경우 구현에서는 상태 설명에서 명시적으로 허용되지 않은 프레임 수신을 PROTOCOL\_ERROR 유형의 연결 오류\(5.4.1절\)로 처리해야 합니다. PRIORITY는 모든 스트림 상태에서 전송 및 수신될 수 있습니다.

이 섹션의 규칙은 이 문서에 정의된 프레임에만 적용됩니다. 의미를 알 수 없는 프레임 수신은 해당 프레임을 보내고 받는 조건도 알 수 없으므로 오류로 처리할 수 없습니다. 섹션 5.5를 참조하세요.

HTTP 요청/응답 교환에 대한 상태 전환의 예는 섹션 8.8에서 찾을 수 있습니다. 서버 푸시에 대한 상태 전환의 예는 섹션 8.4.1 및 8.4.2에서 찾을 수 있습니다.

---
#### **5.1.1.  Stream Identifiers**

스트림은 부호 없는 31비트 정수로 식별됩니다. 클라이언트가 시작한 스트림은 홀수 스트림 식별자를 사용해야 합니다. 서버에 의해 시작된 것은 짝수 스트림 식별자를 사용해야 합니다. 연결 제어 메시지에는 스트림 식별자 0\(0x00\)이 사용됩니다. 스트림 식별자 0은 새 스트림을 설정하는 데 사용할 수 없습니다.

새로 설정된 스트림의 식별자는 시작 엔드포인트가 열거나 예약한 모든 스트림보다 수치적으로 커야 합니다. 이는 HEADERS 프레임을 사용하여 열린 스트림과 PUSH\_PROMISE를 사용하여 예약된 스트림을 제어합니다. 예상치 못한 스트림 식별자를 수신한 엔드포인트는 PROTOCOL\_ERROR 유형의 연결 오류\(섹션 5.4.1\)로 응답해야 합니다.

HEADERS 프레임은 프레임 헤더의 스트림 식별자로 식별되는 클라이언트 시작 스트림을 "유휴"에서 "열림"으로 전환합니다. PUSH\_PROMISE 프레임은 프레임 페이로드의 약속된 스트림 ID 필드로 식별되는 서버 시작 스트림을 "유휴"에서 "예약\(로컬\)" 또는 "예약\(원격\)"으로 전환합니다. 스트림이 "유휴" 상태에서 전환되면 더 낮은 값의 스트림 식별자를 사용하는 피어에 의해 열렸을 수 있는 "유휴" 상태의 모든 스트림이 즉시 "폐쇄"로 전환됩니다. 즉, 엔드포인트는 스트림 식별자를 건너뛸 수 있으며, 그 결과 건너뛴 스트림이 즉시 닫힙니다.

스트림 식별자는 재사용할 수 없습니다. 수명이 긴 연결로 인해 엔드포인트에서 사용 가능한 스트림 식별자 범위가 소진될 수 있습니다. 새 스트림 식별자를 설정할 수 없는 클라이언트는 새 스트림에 대한 새 연결을 설정할 수 있습니다. 새로운 스트림 식별자를 설정할 수 없는 서버는 클라이언트가 새로운 스트림에 대해 새로운 연결을 열도록 강제로 GOAWAY 프레임을 보낼 수 있습니다.

---
#### **5.1.2.  Stream Concurrency**

피어는 SETTINGS 프레임 내에서 SETTINGS\_MAX\_CONCURRENT\_STREAMS 매개변수\(섹션 6.5.2 참조\)를 사용하여 동시에 활성 스트림 수를 제한할 수 있습니다. 최대 동시 스트림 설정은 각 엔드포인트에 따라 다르며 설정을 수신하는 피어에만 적용됩니다. 즉, 클라이언트는 서버가 시작할 수 있는 최대 동시 스트림 수를 지정하고, 서버는 클라이언트가 시작할 수 있는 최대 동시 스트림 수를 지정합니다.

"열림" 상태 또는 "반 닫힘" 상태 중 하나에 있는 스트림은 엔드포인트가 열 수 있도록 허용된 최대 스트림 수에 포함됩니다. 이 세 가지 상태의 스트림은 SETTINGS\_MAX\_CONCURRENT\_STREAMS 설정에 공지된 제한에 포함됩니다. "예약됨" 상태의 스트림은 스트림 제한에 포함되지 않습니다.

엔드포인트는 피어가 설정한 제한을 초과해서는 안 됩니다. 광고된 동시 스트림 제한을 초과하게 만드는 HEADERS 프레임을 수신하는 엔드포인트는 이를 PROTOCOL\_ERROR 또는 REFUSED\_STREAM 유형의 스트림 오류\(섹션 5.4.2\)로 처리해야 합니다. 오류 코드 선택에 따라 엔드포인트가 자동 재시도를 활성화할지 여부가 결정됩니다\(자세한 내용은 섹션 8.7 참조\).

SETTINGS\_MAX\_CONCURRENT\_STREAMS 값을 현재 열린 스트림 수보다 낮은 값으로 줄이려는 엔드포인트는 새 값을 초과하는 스트림을 닫거나 스트림이 완료되도록 허용할 수 있습니다.

---
### **5.2.  Flow Control**

멀티플렉싱에 스트림을 사용하면 TCP 연결 사용에 대한 경합이 발생하여 스트림이 차단됩니다. 흐름 제어 방식은 동일한 연결의 스트림이 서로 파괴적으로 간섭하지 않도록 보장합니다. 흐름 제어는 개별 스트림과 전체 연결 모두에 사용됩니다.

HTTP/2는 WINDOW\_UPDATE 프레임\(6.9절\)을 사용하여 흐름 제어를 제공합니다.

---
#### **5.2.1.  Flow-Control Principles**

HTTP/2 스트림 흐름 제어는 프로토콜 변경 없이 다양한 흐름 제어 알고리즘을 사용할 수 있도록 하는 것을 목표로 합니다. HTTP/2의 흐름 제어에는 다음과 같은 특징이 있습니다.

1. 흐름 제어는 연결에 따라 다릅니다. HTTP/2 흐름 제어는 전체 종단 간 경로가 아닌 단일 홉의 끝점 사이에서 작동합니다.

1. 흐름 제어는 WINDOW\_UPDATE 프레임을 기반으로 합니다. 수신기는 스트림과 전체 연결에서 수신할 준비가 된 옥텟 수를 알립니다. 이는 신용 기반 제도입니다.

1. 흐름 제어는 수신기에서 제공하는 전체 제어를 통해 방향성을 갖습니다. 수신기는 각 스트림과 전체 연결에 대해 원하는 창 크기를 설정하도록 선택할 수 있습니다. 발신자는 수신자가 부과한 흐름 제어 제한을 준수해야 합니다. 클라이언트, 서버 및 중개자는 모두 독립적으로 흐름 제어 창을 수신자로 광고하고 전송할 때 피어가 설정한 흐름 제어 제한을 준수합니다.

1. 흐름 제어 창의 초기 값은 새 스트림과 전체 연결 모두에 대해 65,535옥텟입니다.

1. 프레임 유형은 흐름 제어가 프레임에 적용되는지 여부를 결정합니다. 이 문서에 지정된 프레임 중 DATA 프레임만 흐름 제어 대상입니다. 다른 모든 프레임 유형은 알려진 흐름 제어 창에서 공간을 소비하지 않습니다. 이렇게 하면 중요한 제어 프레임이 흐름 제어에 의해 차단되지 않습니다.

1. 끝점은 자체 흐름 제어를 비활성화하도록 선택할 수 있지만 끝점은 피어의 흐름 제어 신호를 무시할 수 없습니다.

1. HTTP/2는 WINDOW\_UPDATE 프레임\(6.9절\)의 형식과 의미만 정의합니다. 이 문서는 수신자가 이 프레임을 전송할 시기나 전송하는 값을 결정하는 방법을 규정하지 않으며, 발신자가 패킷 전송을 선택하는 방법도 지정하지 않습니다. 구현에서는 필요에 맞는 알고리즘을 선택할 수 있습니다.

또한 구현에서는 요청 및 응답 전송의 우선순위를 지정하고, 요청에 대한 HOL 차단을 방지하는 방법을 선택하고, 새로운 스트림 생성을 관리하는 일도 담당합니다. 이에 대한 알고리즘 선택은 모든 흐름 제어 알고리즘과 상호 작용할 수 있습니다.

---
#### **5.2.2.  Appropriate Use of Flow Control**

흐름 제어는 리소스 제약 조건 하에서 작동하는 엔드포인트를 보호하기 위해 정의됩니다. 예를 들어 프록시는 많은 연결 간에 메모리를 공유해야 하며 느린 업스트림 연결과 빠른 다운스트림 연결을 가질 수도 있습니다. 흐름 제어는 수신자가 하나의 스트림에서 데이터를 처리할 수 없지만 동일한 연결에서 다른 스트림을 계속 처리하려는 경우를 해결합니다.

이 기능이 필요하지 않은 배포에서는 최대 크기\(2^31-1\)의 흐름 제어 창을 광고할 수 있으며 데이터가 수신될 때 WINDOW\_UPDATE 프레임을 전송하여 이 창을 유지할 수 있습니다. 이는 해당 수신기에 대한 흐름 제어를 효과적으로 비활성화합니다. 반대로 발신자는 항상 수신자가 알리는 흐름 제어 창의 적용을 받습니다.

제한된 리소스\(예: 메모리\)가 있는 배포에서는 흐름 제어를 사용하여 피어가 사용할 수 있는 메모리 양을 제한할 수 있습니다. 그러나 대역폭 \* 지연 곱\(\[RFC7323\] 참조\)에 대한 지식 없이 흐름 제어가 활성화된 경우 사용 가능한 네트워크 리소스가 최적이 아닌 사용으로 이어질 수 있습니다.

현재 대역폭 \* 지연 곱을 완전히 인식하더라도 흐름 제어 구현이 어려울 수 있습니다. 엔드포인트는 데이터를 사용할 수 있게 되는 즉시 TCP 수신 버퍼에서 HTTP/2 프레임을 읽고 처리해야 합니다. 즉시 읽지 못하면 WINDOW\_UPDATE와 같은 중요한 프레임을 읽고 조치를 취하지 않을 때 교착 상태가 발생할 수 있습니다. HTTP/2 흐름 제어는 리소스 약속을 제한하므로 프레임 읽기는 엔드포인트를 리소스 고갈 공격에 즉시 노출시키지 않습니다.

---
#### **5.2.3.  Flow-Control Performance**

엔드포인트가 해당 피어가 이 연결에서 피어의 대역폭 \* 지연 곱보다 큰 사용 가능한 흐름 제어 창 공간을 항상 가지고 있는지 확인할 수 없는 경우 수신 처리량은 HTTP/2 흐름 제어에 의해 제한됩니다. 이로 인해 성능이 저하됩니다.

적시에 WINDOW\_UPDATE 프레임을 보내면 성능이 향상될 수 있습니다. 엔드포인트는 수신 처리량을 개선해야 하는 필요성과 리소스 고갈 위험을 관리해야 하는 필요성 사이의 균형을 유지하기를 원하며 창 크기 관리 전략을 정의할 때 섹션 10.5를 주의 깊게 참고해야 합니다.

---
### **5.3.  Prioritization**

HTTP/2와 같은 다중화 프로토콜에서는 대역폭 및 계산 리소스를 스트림에 할당하는 우선순위를 정하는 것이 좋은 성능을 얻는 데 중요할 수 있습니다. 우선순위 체계가 좋지 않으면 HTTP/2의 성능이 저하될 수 있습니다. TCP 계층에 병렬 처리가 없으면 성능은 HTTP/1.1보다 훨씬 나쁠 수 있습니다.

좋은 우선순위 지정 체계는 리소스 내용, 리소스가 상호 연관되는 방식, 해당 리소스가 피어에서 사용되는 방식과 같은 상황별 지식을 적용함으로써 이점을 얻습니다. 특히 클라이언트는 서버 우선순위 지정과 관련된 요청 우선순위에 대한 지식을 보유할 수 있습니다. 이러한 경우 클라이언트가 우선순위 정보를 제공하도록 하면 성능이 향상될 수 있습니다.

---
#### **5.3.1.  Background on Priority in RFC 7540**

RFC 7540은 요청의 우선순위를 알리기 위한 풍부한 시스템을 정의했습니다. 그러나 이 시스템은 복잡하고 균일하게 구현되지 않았습니다.

유연한 계획은 고객이 채택된 접근 방식의 일관성이 거의 없이 매우 다양한 방식으로 우선순위를 표현할 수 있음을 의미했습니다. 서버의 경우 체계에 대한 일반 지원을 구현하는 것이 복잡했습니다. 클라이언트와 서버 모두에서 우선순위 구현이 고르지 않았습니다. 많은 서버 배포에서는 요청 처리의 우선순위를 정할 때 클라이언트 신호를 무시했습니다.

즉, RFC 7540 \[RFC7540\]의 우선순위 신호는 성공적이지 않았습니다.

---
#### **5.3.2.  Priority Signaling in This Document**

이번 HTTP/2 업데이트는 RFC 7540 \[RFC7540\]에 정의된 우선순위 신호를 더 이상 사용하지 않습니다. 우선순위 신호와 관련된 텍스트의 대부분은 이 문서에 포함되지 않습니다. 프레임 필드에 대한 설명과 필수 처리 중 일부는 이 문서의 구현이 RFC 7540에 설명된 우선순위 신호를 사용하는 구현과 상호 운용 가능하도록 유지됩니다.

RFC 7540 우선순위 체계에 대한 자세한 설명은 \[RFC7540\]의 섹션 5.3에 남아 있습니다.

많은 경우 좋은 성능을 얻기 위해서는 신호 우선순위 정보가 필요합니다. 신호 우선순위 정보가 중요한 경우 엔드포인트는 \[HTTP-PRIORITY\]에 설명된 체계와 같은 대체 체계를 사용하는 것이 좋습니다.

RFC 7540의 우선순위 신호는 널리 채택되지 않았지만 더 나은 정보가 없는 경우에도 RFC 7540이 제공하는 정보는 여전히 유용할 수 있습니다. HEADERS 또는 PRIORITY 프레임에서 우선순위 신호를 수신하는 엔드포인트는 해당 정보를 적용함으로써 이점을 얻을 수 있습니다. 특히, 이러한 신호를 소비하는 구현은 대안이 없을 때 이러한 우선순위 신호를 폐기해도 이점을 얻지 못합니다.

서버는 우선순위 신호가 없는 경우 요청의 우선순위를 결정할 때 다른 상황별 정보를 사용해야 합니다. 서버는 신호가 전혀 없다는 것을 클라이언트가 기능을 구현하지 않았다는 표시로 해석할 수 있습니다. \[RFC7540\]의 섹션 5.3.5에 설명된 기본값은 대부분의 조건에서 성능이 좋지 않은 것으로 알려져 있으며 의도적으로 사용할 가능성이 없습니다.

---
### **5.4.  Error Handling**

HTTP/2 프레이밍은 두 가지 종류의 오류를 허용합니다.

\* 전체 연결을 사용할 수 없게 만드는 오류 조건은 연결 오류입니다.

\* 개별 스트림의 오류는 스트림 오류입니다.

오류 코드 목록은 섹션 7에 포함되어 있습니다.

엔드포인트에서 여러 오류를 발생시키는 프레임이 발생할 수 있습니다. 구현은 처리 중에 여러 오류를 발견할 수 있지만 결과적으로 최대 하나의 스트림과 하나의 연결 오류를 보고해야 합니다.

특정 스트림에 대해 보고된 첫 번째 스트림 오류로 인해 해당 스트림의 다른 오류가 보고되지 않습니다. 이에 비해 프로토콜은 여러 GOAWAY 프레임을 허용하지만 엔드포인트는 정상적인 종료 중에 오류가 발생하지 않는 한 한 가지 유형의 연결 오류만 보고해야 합니다. 이런 일이 발생하면 엔드포인트는 NO\_ERROR를 포함하는 이전 GOAWAY에 더해 새로운 오류 코드와 함께 추가 GOAWAY 프레임을 보낼 수도 있습니다.

엔드포인트가 여러 가지 다른 오류를 감지하면 해당 오류 중 하나를 보고하도록 선택할 수 있습니다. 프레임이 연결 오류를 일으키는 경우 해당 오류를 보고해야 합니다. 또한 엔드포인트는 오류 조건을 감지할 때 적용 가능한 오류 코드를 사용할 수 있습니다. 보다 구체적인 오류 코드 대신 일반 오류 코드\(예: PROTOCOL\_ERROR 또는 INTERNAL\_ERROR\)를 항상 사용할 수 있습니다.

---
#### **5.4.1.  Connection Error Handling**

연결 오류는 프레임 계층의 추가 처리를 방해하거나 연결 상태를 손상시키는 오류입니다.

연결 오류가 발생한 엔드포인트는 먼저 피어로부터 성공적으로 수신한 마지막 스트림의 스트림 식별자가 포함된 GOAWAY 프레임\(6.8절\)을 보내야 합니다. GOAWAY 프레임에는 연결이 종료되는 이유를 나타내는 오류 코드\(섹션 7\)가 포함되어 있습니다. 오류 조건에 대해 GOAWAY 프레임을 보낸 후 끝점은 TCP 연결을 닫아야 합니다.

GOAWAY가 수신 엔드포인트에서 안정적으로 수신되지 않을 가능성이 있습니다. 연결 오류가 발생한 경우 GOAWAY는 연결이 종료되는 이유에 대해 피어와 통신하기 위한 최선의 시도만 제공합니다.

엔드포인트는 언제든지 연결을 종료할 수 있습니다. 특히 엔드포인트는 스트림 오류를 연결 오류로 처리하도록 선택할 수 있습니다. 상황이 허용한다면 엔드포인트는 연결을 종료할 때 GOAWAY 프레임을 보내야 합니다.

---
#### **5.4.2.  Stream Error Handling**

스트림 오류는 다른 스트림의 처리에 영향을 주지 않는 특정 스트림과 관련된 오류입니다.

스트림 오류를 감지한 엔드포인트는 오류가 발생한 스트림의 스트림 식별자가 포함된 RST\_STREAM 프레임\(6.4절\)을 보냅니다. RST\_STREAM 프레임에는 오류 유형을 나타내는 오류 코드가 포함되어 있습니다.

RST\_STREAM은 끝점이 스트림에서 보낼 수 있는 마지막 프레임입니다. RST\_STREAM 프레임을 전송하는 피어는 원격 피어가 전송했거나 전송을 위해 대기열에 넣은 모든 프레임을 수신할 준비가 되어 있어야 합니다. 이러한 프레임은 연결 상태\(예: 필드 섹션 압축\(섹션 4.3\) 또는 흐름 제어를 위해 유지되는 상태\)을 수정하는 경우를 제외하고 무시할 수 있습니다.

일반적으로 엔드포인트는 모든 스트림에 대해 두 개 이상의 RST\_STREAM 프레임을 보내면 안 됩니다. 그러나 엔드포인트는 왕복 시간 이상이 지난 후 닫힌 스트림에서 프레임을 수신하는 경우 추가 RST\_STREAM 프레임을 보낼 수 있습니다. 이 동작은 오작동하는 구현을 처리하는 데 허용됩니다.

루핑을 피하기 위해 엔드포인트는 RST\_STREAM 프레임에 대한 응답으로 RST\_STREAM을 보내면 안 됩니다.

---
#### **5.4.3.  Connection Termination**

스트림이 "열림" 또는 "반 닫힘" 상태에 있는 동안 TCP 연결이 닫히거나 재설정되면 영향을 받는 스트림을 자동으로 재시도할 수 없습니다\(자세한 내용은 섹션 8.7 참조\).

---
### **5.5.  Extending HTTP/2**

HTTP/2는 프로토콜 확장을 허용합니다. 이 섹션에 설명된 제한 내에서 프로토콜 확장을 사용하여 추가 서비스를 제공하거나 프로토콜의 모든 측면을 변경할 수 있습니다. 확장은 단일 HTTP/2 연결 범위 내에서만 유효합니다.

이는 이 문서에 정의된 프로토콜 요소에 적용됩니다. 이는 새로운 메소드, 상태 코드 또는 필드 정의와 같은 HTTP 확장을 위한 기존 옵션에 영향을 미치지 않습니다\(\[HTTP\]의 섹션 16 참조\).

확장에서는 새로운 프레임 유형\(섹션 4.1\), 새 설정\(섹션 6.5\) 또는 새 오류 코드\(섹션 7\)를 사용할 수 있습니다. 이러한 확장점을 관리하기 위한 레지스트리는 \[RFC7540\]의 섹션 11에 정의되어 있습니다.

구현 시 모든 확장 가능한 프로토콜 요소에서 알 수 없거나 지원되지 않는 값을 무시해야 합니다\(MUST\). 구현 시 알 수 없거나 지원되지 않는 유형이 있는 프레임을 삭제해야 합니다\(MUST\). 이는 사전 합의나 협상 없이 확장 프로그램에서 이러한 확장 포인트를 안전하게 사용할 수 있음을 의미합니다. 그러나 필드 블록\(4.3절\) 중간에 나타나는 확장 프레임은 허용되지 않습니다. 이는 PROTOCOL\_ERROR 유형의 연결 오류\(섹션 5.4.1\)로 처리되어야 합니다.

확장은 이 문서에 정의된 프로토콜 요소나 확장 메커니즘이 정의되지 않은 요소를 변경하는 것을 피해야 합니다\(SHOULD\). 여기에는 프레임 레이아웃 변경, 프레임이 HTTP 메시지로 구성되는 방식에 대한 추가 또는 변경\(섹션 8.1\), 의사 헤더 필드 정의 또는 호환 엔드포인트가 연결로 처리할 수 있는 프로토콜 요소에 대한 변경이 포함됩니다. 오류\(섹션 5.4.1\).

기존 프로토콜 요소나 상태를 변경하는 확장은 사용하기 전에 반드시 협상되어야 합니다. 예를 들어, HEADERS 프레임의 레이아웃을 변경하는 확장은 피어가 이것이 허용된다는 긍정적인 신호를 제공할 때까지 사용할 수 없습니다. 이 경우 수정된 레이아웃이 적용되는 시기를 조정하는 것도 필요할 수 있습니다. 예를 들어, DATA 프레임 이외의 프레임을 흐름 제어로 처리하려면 두 끝점이 모두 이해해야 하는 의미 체계의 변경이 필요하므로 이는 협상을 통해서만 수행될 수 있습니다.

이 문서에서는 확장 사용을 협상하기 위한 특정 방법을 요구하지는 않지만 해당 목적으로 설정\(섹션 6.5.2\)을 사용할 수 있음을 언급합니다. 두 피어 모두 확장을 사용할 의사가 있음을 나타내는 값을 설정하면 확장을 사용할 수 있습니다. 확장 협상에 설정이 사용되는 경우 확장이 처음에 비활성화되는 방식으로 초기 값을 정의해야 합니다.

---
## **6.  Frame Definitions**

이 사양은 각각 고유한 8비트 유형 코드로 식별되는 다양한 프레임 유형을 정의합니다. 각 프레임 유형은 전체 연결 또는 개별 스트림 연결을 설정하고 관리하는 데 있어 고유한 목적을 제공합니다.

특정 프레임 유형의 전송은 연결 상태를 변경할 수 있습니다. 엔드포인트가 연결 상태에 대한 동기화된 보기를 유지하지 못하면 연결 내에서 성공적인 통신이 더 이상 불가능합니다. 따라서 엔드포인트가 특정 프레임의 사용으로 인해 상태가 어떻게 영향을 받는지에 대해 공유된 이해를 갖는 것이 중요합니다.

---
### **6.1.  DATA**

DATA 프레임\(유형=0x00\)은 스트림과 관련된 임의의 가변 길이 옥텟 시퀀스를 전달합니다. 예를 들어, 하나 이상의 DATA 프레임은 HTTP 요청 또는 응답 메시지 내용을 전달하는 데 사용됩니다.

DATA 프레임에는 패딩도 포함될 수 있습니다. 메시지 크기를 모호하게 하기 위해 DATA 프레임에 패딩을 추가할 수 있습니다. 패딩은 보안 기능입니다. 섹션 10.7을 참조하세요.

```text
   DATA Frame {
     Length (24),
     Type (8) = 0x00,

     Unused Flags (4),
     PADDED Flag (1),
     Unused Flags (2),
     END_STREAM Flag (1),

     Reserved (1),
     Stream Identifier (31),

     [Pad Length (8)],
     Data (..),
     Padding (..2040),
   }

                        Figure 3: DATA Frame Format
```

길이, 유형, 사용되지 않은 플래그, 예약됨 및 스트림 식별자 필드는 섹션 4에 설명되어 있습니다. DATA 프레임에는 다음과 같은 추가 필드가 포함되어 있습니다.

패드 길이\(Pad Length\): 프레임 패딩 길이를 옥텟 단위로 포함하는 8비트 필드입니다. 이 필드는 조건부이며 PADDED 플래그가 설정된 경우에만 존재합니다.

데이터: 애플리케이션 데이터. 데이터의 양은 존재하는 다른 필드의 길이를 뺀 프레임 페이로드의 나머지 부분입니다.

패딩\(Padding\): 애플리케이션 의미 값이 포함되지 않은 패딩 옥텟입니다. 전송 시 패딩 옥텟은 0으로 설정되어야 합니다. 수신기는 패딩을 확인할 의무는 없지만 0이 아닌 패딩을 PROTOCOL\_ERROR 유형의 연결 오류\(섹션 5.4.1\)로 처리할 수 있습니다.

DATA 프레임은 다음 플래그를 정의합니다.

PADDED\(0x08\): 설정된 경우 PADDED 플래그는 패드 길이 필드와 해당 필드가 설명하는 패딩이 있음을 나타냅니다.

END\_STREAM\(0x01\): 설정되면 END\_STREAM 플래그는 이 프레임이 엔드포인트가 식별된 스트림에 대해 보내는 마지막 프레임임을 나타냅니다. 이 플래그를 설정하면 스트림이 "반 폐쇄" 상태 또는 "폐쇄" 상태 중 하나로 전환됩니다\(섹션 5.1\).

- | 참고: 전송 후 스트림 폐쇄를 학습하는 엔드포인트 | 모든 데이터는 |를 사용하여 STREAM 프레임을 전송하여 스트림을 닫을 수 있습니다. 길이가 0인 데이터 필드와 END\_STREAM 플래그가 설정되었습니다. 이것은 | | 이 경우 END\_STREAM 플래그가 HEADERS 프레임에 나타납니다. 참조 | 섹션 8.1.

DATA 프레임은 스트림과 연결되어야 합니다. 스트림 식별자 필드가 0x00인 DATA 프레임이 수신되면 수신자는 PROTOCOL\_ERROR 유형의 연결 오류\(섹션 5.4.1\)로 응답해야 합니다.

DATA 프레임은 흐름 제어의 적용을 받으며 스트림이 "열림" 또는 "반 닫힘\(원격\)" 상태일 때만 전송될 수 있습니다. Pad Length 및 Padding 필드가 있는 경우 이를 포함하여 전체 DATA 프레임 페이로드가 흐름 제어에 포함됩니다. 스트림이 "개방" 또는 "반 폐쇄\(로컬\)" 상태가 아닌 DATA 프레임이 수신된 경우 수신자는 STREAM\_CLOSED 유형의 스트림 오류\(섹션 5.4.2\)로 응답해야 합니다.

패딩 옥텟의 총 개수는 패드 길이 필드의 값에 따라 결정됩니다. 패딩 길이가 프레임 페이로드 길이 이상인 경우 수신자는 이를 PROTOCOL\_ERROR 유형의 연결 오류\(섹션 5.4.1\)로 처리해야 합니다.

- | 참고: 프레임 크기는 |를 사용하여 1옥텟씩 늘릴 수 있습니다. 값이 0인 패드 길이 필드를 포함합니다.

---
### **6.2.  HEADERS**

HEADERS 프레임\(유형=0x01\)은 스트림을 여는 데 사용되며\(5.1절\) 추가로 필드 블록 조각을 전달합니다. 이름에도 불구하고 HEADERS 프레임은 헤더 섹션이나 트레일러 섹션을 전달할 수 있습니다. HEADERS 프레임은 "유휴", "예약됨\(로컬\)", "열림" 또는 "반 닫힘\(원격\)" 상태의 스트림에서 전송될 수 있습니다.

```text
   HEADERS Frame {
     Length (24),
     Type (8) = 0x01,

     Unused Flags (2),
     PRIORITY Flag (1),
     Unused Flag (1),
     PADDED Flag (1),
     END_HEADERS Flag (1),
     Unused Flag (1),
     END_STREAM Flag (1),

     Reserved (1),
     Stream Identifier (31),

     [Pad Length (8)],
     [Exclusive (1)],
     [Stream Dependency (31)],
     [Weight (8)],
     Field Block Fragment (..),
     Padding (..2040),
   }

                       Figure 4: HEADERS Frame Format
```

길이, 유형, 사용되지 않은 플래그, 예약됨 및 스트림 식별자 필드는 섹션 4에 설명되어 있습니다. HEADERS 프레임 페이로드에는 다음과 같은 추가 필드가 있습니다.

패드 길이\(Pad Length\): 프레임 패딩 길이를 옥텟 단위로 포함하는 8비트 필드입니다. 이 필드는 PADDED 플래그가 설정된 경우에만 존재합니다.

독점: 단일 비트 플래그입니다. 이 필드는 PRIORITY 플래그가 설정된 경우에만 존재합니다. HEADERS 프레임의 우선순위 신호는 더 이상 사용되지 않습니다. 섹션 5.3.2를 참조하세요.

스트림 종속성: 31비트 스트림 식별자입니다. 이 필드는 PRIORITY 플래그가 설정된 경우에만 존재합니다.

가중치: 부호 없는 8비트 정수입니다. 이 필드는 PRIORITY 플래그가 설정된 경우에만 존재합니다.

필드 블록 조각: 필드 블록 조각\(섹션 4.3\).

패딩\(Padding\): 애플리케이션 의미 값이 포함되지 않은 패딩 옥텟입니다. 전송 시 패딩 옥텟은 0으로 설정되어야 합니다. 수신기는 패딩을 확인할 의무는 없지만 0이 아닌 패딩을 PROTOCOL\_ERROR 유형의 연결 오류\(섹션 5.4.1\)로 처리할 수 있습니다.

HEADERS 프레임은 다음 플래그를 정의합니다.

PRIORITY\(0x20\): 설정된 경우 PRIORITY 플래그는 Exclusive, Stream 종속성 및 Weight 필드가 있음을 나타냅니다.

PADDED\(0x08\): 설정된 경우 PADDED 플래그는 패드 길이 필드와 해당 필드가 설명하는 패딩이 있음을 나타냅니다.

END\_HEADERS\(0x04\): 설정되면 END\_HEADERS 플래그는 이 프레임이 전체 필드 블록\(섹션 4.3\)을 포함하고 다음에는 CONTINUATION 프레임이 없음을 나타냅니다.

- END\_HEADERS 플래그가 설정되지 않은 HEADERS 프레임 뒤에는 동일한 스트림에 대한 CONTINUATION 프레임이 와야 합니다. 수신기는 다른 유형의 프레임 또는 다른 스트림의 프레임 수신을 PROTOCOL\_ERROR 유형의 연결 오류\(5.4.1절\)로 처리해야 합니다.

END\_STREAM\(0x01\): 설정되면 END\_STREAM 플래그는 필드 블록\(섹션 4.3\)이 식별된 스트림에 대해 끝점이 보내는 마지막 블록임을 나타냅니다.

- END\_STREAM 플래그가 설정된 HEADERS 프레임은 스트림의 끝을 알립니다. 그러나 END\_STREAM 플래그가 설정된 HEADERS 프레임 뒤에는 동일한 스트림의 CONTINUATION 프레임이 올 수 있습니다. 논리적으로 CONTINUATION 프레임은 HEADERS 프레임의 일부입니다.

HEADERS 프레임의 프레임 페이로드에는 필드 블록 조각이 포함되어 있습니다\(섹션 4.3\). HEADERS 프레임에 맞지 않는 필드 블록은 CONTINUATION 프레임에서 계속됩니다\(6.10절\).

HEADERS 프레임은 스트림과 연결되어야 합니다. 스트림 식별자 필드가 0x00인 HEADERS 프레임이 수신되면 수신자는 PROTOCOL\_ERROR 유형의 연결 오류\(섹션 5.4.1\)로 응답해야 합니다.

HEADERS 프레임은 섹션 4.3에 설명된 대로 연결 상태를 변경합니다.

패딩 옥텟의 총 개수는 패드 길이 필드의 값에 따라 결정됩니다. 패딩 길이가 프레임 페이로드 길이 이상인 경우 수신자는 이를 PROTOCOL\_ERROR 유형의 연결 오류\(섹션 5.4.1\)로 처리해야 합니다.

- | 참고: 프레임 크기는 |를 사용하여 1옥텟씩 늘릴 수 있습니다. 값이 0인 패드 길이 필드를 포함합니다.

---
### **6.3.  PRIORITY**

PRIORITY 프레임\(유형=0x02\)은 더 이상 사용되지 않습니다. 섹션 5.3.2를 참조하세요. PRIORITY 프레임은 유휴 스트림이나 닫힌 스트림을 포함한 모든 스트림 상태에서 전송될 수 있습니다.

```text
   PRIORITY Frame {
     Length (24) = 0x05,
     Type (8) = 0x02,

     Unused Flags (8),

     Reserved (1),
     Stream Identifier (31),

     Exclusive (1),
     Stream Dependency (31),
     Weight (8),
   }

                      Figure 5: PRIORITY Frame Format
```

길이, 유형, 사용되지 않은 플래그, 예약됨 및 스트림 식별자 필드는 섹션 4에 설명되어 있습니다. PRIORITY 프레임의 프레임 페이로드에는 다음과 같은 추가 필드가 포함됩니다.

독점: 단일 비트 플래그입니다.

스트림 종속성: 31비트 스트림 식별자입니다.

가중치: 부호 없는 8비트 정수입니다.

PRIORITY 프레임은 플래그를 정의하지 않습니다.

PRIORITY 프레임은 항상 스트림을 식별합니다. PRIORITY 프레임이 스트림 식별자 0x00으로 수신되면 수신자는 PROTOCOL\_ERROR 유형의 연결 오류\(섹션 5.4.1\)로 응답해야 합니다.

PRIORITY 프레임을 보내거나 받는 것은 스트림의 상태에 영향을 미치지 않습니다\(섹션 5.1\). PRIORITY 프레임은 "idle" 또는 "closed"를 포함한 모든 상태의 스트림에서 전송될 수 있습니다. 단일 필드 블록을 구성하는 연속 프레임 간에는 PRIORITY 프레임을 보낼 수 없습니다\(섹션 4.3\).

길이가 5옥텟이 아닌 PRIORITY 프레임은 FRAME\_SIZE\_ERROR 유형의 스트림 오류\(5.4.2절\)로 처리되어야 합니다.

---
### **6.4.  RST_STREAM**

RST\_STREAM 프레임\(유형=0x03\)을 사용하면 스트림을 즉시 종료할 수 있습니다. RST\_STREAM은 스트림 취소를 요청하거나 오류 조건이 발생했음을 나타내기 위해 전송됩니다.

```text
   RST_STREAM Frame {
     Length (24) = 0x04,
     Type (8) = 0x03,

     Unused Flags (8),

     Reserved (1),
     Stream Identifier (31),

     Error Code (32),
   }

                     Figure 6: RST_STREAM Frame Format
```

길이, 유형, 사용되지 않은 플래그, 예약됨 및 스트림 식별자 필드는 섹션 4에 설명되어 있습니다. 또한 RST\_STREAM 프레임에는 오류 코드를 식별하는 단일 부호 없는 32비트 정수가 포함되어 있습니다\(섹션 7\). 오류 코드는 스트림이 종료되는 이유를 나타냅니다.

RST\_STREAM 프레임은 플래그를 정의하지 않습니다.

RST\_STREAM 프레임은 참조된 스트림을 완전히 종료하고 "닫힌" 상태로 들어가게 합니다. 스트림에서 RST\_STREAM을 수신한 후 수신자는 PRIORITY를 제외하고 해당 스트림에 대한 추가 프레임을 보내서는 안 됩니다. 그러나 RST\_STREAM을 전송한 후 전송 끝점은 RST\_STREAM이 도착하기 전에 피어가 전송했을 수 있는 스트림에서 전송된 추가 프레임을 수신하고 처리할 준비를 해야 합니다.

RST\_STREAM 프레임은 스트림과 연결되어야 합니다. RST\_STREAM 프레임이 스트림 식별자 0x00으로 수신되면 수신자는 이를 PROTOCOL\_ERROR 유형의 연결 오류\(5.4.1절\)로 처리해야 합니다.

RST\_STREAM 프레임은 "유휴" 상태의 스트림에 대해 전송되어서는 안 됩니다. 유휴 스트림을 식별하는 RST\_STREAM 프레임이 수신되면 수신자는 이를 PROTOCOL\_ERROR 유형의 연결 오류\(섹션 5.4.1\)로 처리해야 합니다.

4옥텟이 아닌 길이의 RST\_STREAM 프레임은 FRAME\_SIZE\_ERROR 유형의 연결 오류\(5.4.1절\)로 처리되어야 합니다.

---
### **6.5.  SETTINGS**

SETTINGS 프레임\(유형=0x04\)은 피어 동작에 대한 기본 설정 및 제약 조건과 같이 엔드포인트의 통신 방식에 영향을 미치는 구성 매개변수를 전달합니다. SETTINGS 프레임은 해당 설정 수신을 확인하는 데에도 사용됩니다. 개별적으로 SETTINGS 프레임의 구성 매개변수를 "설정"이라고 합니다.

설정은 협상되지 않습니다. 이는 수신 피어가 사용하는 송신 피어의 특성을 설명합니다. 동일한 설정에 대해 서로 다른 값을 각 피어에서 알릴 수 있습니다. 예를 들어 클라이언트는 초기 흐름 제어 창을 높게 설정하는 반면 서버는 리소스를 절약하기 위해 더 낮은 값을 설정할 수 있습니다.

SETTINGS 프레임은 연결 시작 시 두 끝점 모두에서 전송되어야 하며 연결 ​​수명 동안 어느 한 끝점에서 언제든지 보낼 수 있습니다. 구현은 이 사양에 정의된 모든 설정을 지원해야 합니다.

SETTINGS 프레임의 각 매개변수는 해당 매개변수의 기존 값을 대체합니다. 설정은 나타나는 순서대로 처리되며 SETTINGS 프레임의 수신자는 각 설정의 현재 값 이외의 상태를 유지할 필요가 없습니다. 따라서 SETTINGS 매개변수의 값은 수신기에 표시되는 마지막 값입니다.

SETTINGS 프레임은 수신 피어에 의해 승인됩니다. 이를 활성화하기 위해 SETTINGS 프레임은 ACK 플래그를 정의합니다.

ACK\(0x01\): 설정된 경우 ACK 플래그는 이 프레임이 피어의 SETTINGS 프레임 수신 및 적용을 확인했음을 나타냅니다. 이 비트가 설정되면 SETTINGS 프레임의 프레임 페이로드가 비어 있어야 합니다. ACK 플래그가 설정되고 길이 필드 값이 0이 아닌 SETTINGS 프레임의 수신은 FRAME\_SIZE\_ERROR 유형의 연결 오류\(섹션 5.4.1\)로 처리되어야 합니다. 자세한 내용은 섹션 6.5.3\("설정 동기화"\)을 참조하세요.

SETTINGS 프레임은 항상 연결에 적용되며 단일 스트림에는 적용되지 않습니다. SETTINGS 프레임의 스트림 식별자는 0\(0x00\)이어야 합니다. 엔드포인트가 스트림 식별자 필드가 0x00이 아닌 SETTINGS 프레임을 수신하는 경우 엔드포인트는 PROTOCOL\_ERROR 유형의 연결 오류\(섹션 5.4.1\)로 응답해야 합니다.

SETTINGS 프레임은 연결 상태에 영향을 미칩니다. 형식이 잘못되었거나 불완전한 SETTINGS 프레임은 PROTOCOL\_ERROR 유형의 연결 오류\(섹션 5.4.1\)로 처리되어야 합니다.

6 옥텟의 배수가 아닌 길이를 가진 SETTINGS 프레임은 FRAME\_SIZE\_ERROR 유형의 연결 오류\(섹션 5.4.1\)로 처리되어야 합니다.

---
#### **6.5.1.  SETTINGS Format**

SETTINGS 프레임의 프레임 페이로드는 0개 이상의 설정으로 구성되며, 각 설정은 부호 없는 16비트 설정 식별자와 부호 없는 32비트 값으로 구성됩니다.

```text
   SETTINGS Frame {
     Length (24),
     Type (8) = 0x04,

     Unused Flags (7),
     ACK Flag (1),

     Reserved (1),
     Stream Identifier (31) = 0,

     Setting (48) ...,
   }

   Setting {
     Identifier (16),
     Value (32),
   }

                      Figure 7: SETTINGS Frame Format
```

길이, 유형, 사용되지 않은 플래그, 예약 및 스트림 식별자 필드는 섹션 4에 설명되어 있습니다. SETTINGS 프레임의 프레임 페이로드에는 설정 필드가 여러 개 포함되어 있으며 각 필드는 다음으로 구성됩니다.

식별자: 16비트 설정 식별자입니다. 섹션 6.5.2를 참조하세요.

값: 설정에 대한 32비트 값입니다.

---
#### **6.5.2.  Defined Settings**

다음 설정이 정의됩니다.

SETTINGS\_HEADER\_TABLE\_SIZE \(0x01\): 이 설정을 사용하면 발신자가 필드 블록을 디코딩하는 데 사용되는 압축 테이블의 최대 크기를 옥텟 단위로 원격 끝점에 알릴 수 있습니다. 인코더는 필드 블록 내부의 압축 형식과 관련된 신호를 사용하여 이 값과 같거나 작은 크기를 선택할 수 있습니다\(\[COMPRESSION\] 참조\). 초기값은 4,096 옥텟입니다.

SETTINGS\_ENABLE\_PUSH\(0x02\): 이 설정은 서버 푸시를 활성화하거나 비활성화하는 데 사용할 수 있습니다. 서버는 0 값으로 설정된 이 매개변수를 수신하는 경우 PUSH\_PROMISE 프레임을 전송해서는 안 됩니다. 섹션 8.4를 참조하세요. 이 매개변수를 0으로 설정하고 이를 승인한 클라이언트는 PUSH\_PROMISE 프레임 수신을 PROTOCOL\_ERROR 유형의 연결 오류\(5.4.1절\)로 처리해야 합니다.

- SETTINGS\_ENABLE\_PUSH의 초기 값은 1입니다. 클라이언트의 경우 이 값은 PUSH\_PROMISE 프레임을 수신할 의향이 있음을 나타냅니다. 서버의 경우 이 초기 값은 아무런 영향을 미치지 않으며 값 0과 동일합니다. 0 또는 1 이외의 모든 값은 PROTOCOL\_ERROR 유형의 연결 오류\(섹션 5.4.1\)로 처리되어야 합니다.

- 서버는 이 값을 명시적으로 1로 설정해서는 안 됩니다. 서버는 SETTINGS 프레임을 보낼 때 이 설정을 생략하도록 선택할 수 있지만, 서버가 값을 포함하는 경우에는 0이어야 합니다. 클라이언트는 SETTINGS 프레임 수신을 처리해야 합니다. PROTOCOL\_ERROR 유형의 연결 오류\(섹션 5.4.1\)로 SETTINGS\_ENABLE\_PUSH를 1로 설정합니다.

SETTINGS\_MAX\_CONCURRENT\_STREAMS \(0x03\): 이 설정은 보낸 사람이 허용할 최대 동시 스트림 수를 나타냅니다. 이 제한은 방향성이 있습니다. 즉, 발신자가 수신자에게 생성을 허용하는 스트림 수에 적용됩니다. 처음에는 이 값에 제한이 없습니다. 병렬성을 불필요하게 제한하지 않도록 이 값은 100보다 작지 않은 것이 좋습니다.

- SETTINGS\_MAX\_CONCURRENT\_STREAMS의 값 0은 엔드포인트에서 특수한 것으로 처리되어서는 안 됩니다. 값이 0이면 새 스트림이 생성되지 않습니다. 그러나 이는 활성 스트림으로 인해 소진된 모든 제한에 대해서도 발생할 수 있습니다. 서버는 짧은 기간 동안에만 0 값을 설정해야 합니다. 서버가 요청을 수락하지 않으려면 연결을 닫는 것이 더 적절합니다.

SETTINGS\_INITIAL\_WINDOW\_SIZE \(0x04\): 이 설정은 스트림 수준 흐름 제어를 위한 발신자의 초기 창 크기\(옥텟 단위\)를 나타냅니다. 초기 값은 2^16-1\(65,535\) 옥텟입니다.

- 이 설정은 모든 스트림의 창 크기에 영향을 미칩니다\(섹션 6.9.2 참조\).

- 최대 흐름 제어 창 크기인 2^31-1을 초과하는 값은 FLOW\_CONTROL\_ERROR 유형의 연결 오류\(섹션 5.4.1\)로 처리되어야 합니다.

SETTINGS\_MAX\_FRAME\_SIZE \(0x05\): 이 설정은 발신자가 수신하려는 최대 프레임 페이로드의 크기를 옥텟 단위로 나타냅니다.

- 초기값은 2^14\(16,384\) 옥텟입니다. 엔드포인트가 광고하는 값은 이 초기 값과 최대 허용 프레임 크기\(2^24-1 또는 16,777,215 옥텟\) 사이에 있어야 합니다. 이 범위를 벗어나는 값은 PROTOCOL\_ERROR 유형의 연결 오류\(섹션 5.4.1\)로 처리되어야 합니다.

SETTINGS\_MAX\_HEADER\_LIST\_SIZE \(0x06\): 이 권고 설정은 발신자가 수락할 준비가 된 최대 필드 섹션 크기를 옥텟 단위로 피어에게 알립니다. 값은 옥텟 단위의 이름 및 값 길이와 각 필드 라인에 대한 32옥텟의 오버헤드를 포함하여 압축되지 않은 필드 라인 크기를 기반으로 합니다.

- 특정 요청에 대해 광고된 것보다 낮은 한도가 적용될 수 있습니다. 이 설정의 초기값은 무제한입니다.

알 수 없거나 지원되지 않는 식별자가 포함된 SETTINGS 프레임을 수신하는 엔드포인트는 해당 설정을 무시해야 합니다.

---
#### **6.5.3.  Settings Synchronization**

SETTINGS의 대부분의 값은 피어가 변경된 매개변수 값을 수신하고 적용한 시기를 이해하는 데 도움이 되거나 이해가 필요합니다. 이러한 동기화 시점을 제공하기 위해 ACK 플래그가 설정되지 않은 SETTINGS 프레임의 수신자는 수신 즉시 업데이트된 설정을 최대한 빨리 적용해야 합니다. SETTINGS 프레임은 수신된 순서대로 승인됩니다.

SETTINGS 프레임의 값은 나타나는 순서대로 처리되어야 하며 값 사이에는 다른 프레임 처리가 없습니다. 지원되지 않는 설정은 무시해야 합니다. 모든 값이 처리되면 수신자는 즉시 ACK 플래그가 설정된 SETTINGS 프레임을 내보내야 합니다. ACK 플래그가 설정된 SETTINGS 프레임을 수신하면 변경된 설정을 보낸 사람은 적용된 가장 오래되고 승인되지 않은 SETTINGS 프레임의 값을 신뢰할 수 있습니다.

SETTINGS 프레임의 발신자가 합리적인 시간 내에 승인을 받지 못한 경우 SETTINGS\_TIMEOUT 유형의 연결 오류\(섹션 5.4.1\)가 발생할 수 있습니다. 시간 제한을 설정할 때 피어에서의 처리 지연을 어느 정도 허용해야 합니다. 엔드포인트 간의 왕복 시간만을 기준으로 하는 시간 초과로 인해 허위 오류가 발생할 수 있습니다.

---
### **6.6.  PUSH_PROMISE**

PUSH\_PROMISE 프레임\(유형=0x05\)은 보낸 사람이 시작하려는 스트림에 앞서 피어 엔드포인트에 알리는 데 사용됩니다. PUSH\_PROMISE 프레임에는 엔드포인트가 스트림에 대한 추가 컨텍스트를 제공하는 필드 섹션과 함께 생성하려는 스트림의 서명되지 않은 31비트 식별자가 포함되어 있습니다. 섹션 8.4에는 PUSH\_PROMISE 프레임 사용에 대한 철저한 설명이 포함되어 있습니다.

```text
   PUSH_PROMISE Frame {
     Length (24),
     Type (8) = 0x05,

     Unused Flags (4),
     PADDED Flag (1),
     END_HEADERS Flag (1),
     Unused Flags (2),

     Reserved (1),
     Stream Identifier (31),

     [Pad Length (8)],
     Reserved (1),
     Promised Stream ID (31),
     Field Block Fragment (..),
     Padding (..2040),
   }

                    Figure 8: PUSH_PROMISE Frame Format
```

길이, 유형, 사용되지 않은 플래그, 예약됨 및 스트림 식별자 필드는 섹션 4에 설명되어 있습니다. PUSH\_PROMISE 프레임 페이로드에는 다음과 같은 추가 필드가 있습니다.

패드 길이\(Pad Length\): 프레임 패딩 길이를 옥텟 단위로 포함하는 8비트 필드입니다. 이 필드는 PADDED 플래그가 설정된 경우에만 존재합니다.

약속된 스트림 ID: PUSH\_PROMISE에 의해 예약된 스트림을 식별하는 부호 없는 31비트 정수입니다. 약속된 스트림 식별자는 발신자가 보낸 다음 스트림에 대해 유효한 선택이어야 합니다\(섹션 5.1.1의 "새 스트림 식별자" 참조\).

필드 블록 조각: 요청 제어 데이터와 헤더 섹션을 포함하는 필드 블록 조각\(섹션 4.3\)입니다.

패딩\(Padding\): 애플리케이션 의미 값이 포함되지 않은 패딩 옥텟입니다. 전송 시 패딩 옥텟은 0으로 설정되어야 합니다. 수신기는 패딩을 확인할 의무는 없지만 0이 아닌 패딩을 PROTOCOL\_ERROR 유형의 연결 오류\(섹션 5.4.1\)로 처리할 수 있습니다.

PUSH\_PROMISE 프레임은 다음 플래그를 정의합니다:

PADDED\(0x08\): 설정된 경우 PADDED 플래그는 패드 길이 필드와 해당 필드가 설명하는 패딩이 있음을 나타냅니다.

END\_HEADERS\(0x04\): 설정되면 END\_HEADERS 플래그는 이 프레임이 전체 필드 블록\(섹션 4.3\)을 포함하고 다음에는 CONTINUATION 프레임이 없음을 나타냅니다.

- END\_HEADERS 플래그가 설정되지 않은 PUSH\_PROMISE 프레임 뒤에는 동일한 스트림에 대한 CONTINUATION 프레임이 와야 합니다. 수신기는 다른 유형의 프레임 또는 다른 스트림의 프레임 수신을 PROTOCOL\_ERROR 유형의 연결 오류\(5.4.1절\)로 처리해야 합니다.

PUSH\_PROMISE 프레임은 "개방" 또는 "반 폐쇄\(원격\)" 상태인 피어 시작 스트림에서만 전송되어야 합니다. PUSH\_PROMISE 프레임의 스트림 식별자는 연결된 스트림을 나타냅니다. 스트림 식별자 필드가 0x00 값을 지정하는 경우 수신자는 PROTOCOL\_ERROR 유형의 연결 오류\(섹션 5.4.1\)로 응답해야 합니다.

약속된 스트림을 약속된 순서대로 사용할 필요는 없습니다. PUSH\_PROMISE는 나중에 사용하기 위해 스트림 식별자만 예약합니다.

피어 끝점의 SETTINGS\_ENABLE\_PUSH 설정이 0으로 설정된 경우 PUSH\_PROMISE는 전송되어서는 안 됩니다. 이 설정을 설정하고 승인을 받은 끝점은 PUSH\_PROMISE 프레임의 수신을 PROTOCOL\_ERROR 유형의 연결 오류\(섹션 5.4.1\)로 처리해야 합니다. .

PUSH\_PROMISE 프레임의 수신자는 약속된 스트림 식별자를 참조하는 RST\_STREAM을 PUSH\_PROMISE의 보낸 사람에게 반환하여 약속된 스트림을 거부하도록 선택할 수 있습니다.

PUSH\_PROMISE 프레임은 두 가지 방법으로 연결 상태를 수정합니다. 첫째, 필드 블록\(섹션 4.3\)을 포함하면 필드 섹션 압축을 위해 유지되는 상태가 잠재적으로 수정됩니다. 둘째, PUSH\_PROMISE는 나중에 사용하기 위해 스트림을 예약하여 약속된 스트림이 "예약됨\(로컬\)" 또는 "예약됨\(원격\)" 상태가 되도록 합니다. 송신자는 해당 스트림이 "개방형" 또는 "반 폐쇄형\(원격\)"이 아닌 한 스트림에서 PUSH\_PROMISE를 전송해서는 안 됩니다. 발신자는 약속된 스트림이 새로운 스트림 식별자에 대한 유효한 선택인지 확인해야 합니다\(5.1.1절\). 즉, 약속된 스트림은 "유휴" 상태에 있어야 합니다.

PUSH\_PROMISE는 스트림을 예약하므로 PUSH\_PROMISE 프레임을 무시하면 스트림 상태가 불확실해집니다. 수신자는 "개방" 또는 "반 폐쇄\(로컬\)"가 아닌 스트림에서 PUSH\_PROMISE 수신을 PROTOCOL\_ERROR 유형의 연결 오류\(5.4.1절\)로 처리해야 합니다. 그러나 관련 스트림에서 RST\_STREAM을 보낸 엔드포인트는 RST\_STREAM 프레임이 수신되고 처리되기 전에 생성되었을 수 있는 PUSH\_PROMISE 프레임을 처리해야 합니다.

수신자는 불법 스트림 식별자\(섹션 5.1.1\)를 약속하는 PUSH\_PROMISE의 수신을 PROTOCOL\_ERROR 유형의 연결 오류\(섹션 5.4.1\)로 처리해야 합니다. 불법 스트림 식별자는 현재 "유휴" 상태가 아닌 스트림에 대한 식별자입니다.

패딩 옥텟의 총 개수는 패드 길이 필드의 값에 따라 결정됩니다. 패딩 길이가 프레임 페이로드 길이 이상인 경우 수신자는 이를 PROTOCOL\_ERROR 유형의 연결 오류\(섹션 5.4.1\)로 처리해야 합니다.

- | 참고: 프레임 크기는 |를 사용하여 1옥텟씩 늘릴 수 있습니다. 값이 0인 패드 길이 필드를 포함합니다.

---
### **6.7.  PING**

PING 프레임\(유형=0x06\)은 발신자의 최소 왕복 시간을 측정하고 유휴 연결이 여전히 작동하는지 확인하는 메커니즘입니다. PING 프레임은 모든 엔드포인트에서 전송될 수 있습니다.

```text
   PING Frame {
     Length (24) = 0x08,
     Type (8) = 0x06,

     Unused Flags (7),
     ACK Flag (1),

     Reserved (1),
     Stream Identifier (31) = 0,

     Opaque Data (64),
   }

                        Figure 9: PING Frame Format
```

길이, 유형, 사용되지 않은 플래그, 예약됨 및 스트림 식별자 필드는 섹션 4에 설명되어 있습니다.

프레임 헤더 외에도 PING 프레임은 프레임 페이로드에 8옥텟의 불투명 데이터를 포함해야 합니다. 발신자는 선택한 값을 포함하고 해당 옥텟을 어떤 방식으로든 사용할 수 있습니다.

ACK 플래그를 포함하지 않는 PING 프레임의 수신자는 응답으로 ACK 플래그가 설정된 PING 프레임을 동일한 프레임 페이로드와 함께 전송해야 합니다. PING 응답에는 다른 프레임보다 높은 우선순위가 부여되어야 합니다.

PING 프레임은 다음 플래그를 정의합니다.

ACK\(0x01\): 설정되면 ACK 플래그는 이 PING 프레임이 PING 응답임을 나타냅니다. 엔드포인트는 PING 응답에서 이 플래그를 설정해야 합니다. 엔드포인트는 이 플래그가 포함된 PING 프레임에 응답해서는 안 됩니다.

PING 프레임은 개별 스트림과 연결되지 않습니다. PING 프레임이 0x00이 아닌 스트림 식별자 필드 값으로 수신되면 수신자는 PROTOCOL\_ERROR 유형의 연결 오류\(섹션 5.4.1\)로 응답해야 합니다.

8이 아닌 길이 필드 값을 가진 PING 프레임의 수신은 FRAME\_SIZE\_ERROR 유형의 연결 오류\(섹션 5.4.1\)로 처리되어야 합니다.

---
### **6.8.  GOAWAY**

GOAWAY 프레임\(유형=0x07\)은 연결 종료를 시작하거나 심각한 오류 상태를 알리는 데 사용됩니다. GOAWAY를 사용하면 엔드포인트가 이전에 설정된 스트림의 처리를 계속 완료하면서 새 스트림 수락을 정상적으로 중지할 수 있습니다. 이를 통해 서버 유지 관리와 같은 관리 작업이 가능해집니다.

새로운 스트림을 시작하는 엔드포인트와 GOAWAY 프레임을 보내는 원격 피어 사이에는 고유한 경쟁 조건이 있습니다. 이 경우를 처리하기 위해 GOAWAY에는 이 연결의 전송 끝점에서 처리되었거나 처리될 수 있는 마지막 피어 시작 스트림의 스트림 식별자가 포함됩니다. 예를 들어, 서버가 GOAWAY 프레임을 보내는 경우 식별된 스트림은 클라이언트가 시작한 가장 높은 번호의 스트림입니다.

GOAWAY가 전송되면 스트림에 포함된 마지막 스트림 식별자보다 높은 식별자가 있는 경우 송신자는 수신자가 시작한 스트림에서 전송된 프레임을 무시합니다. GOAWAY 프레임의 수신기는 새로운 스트림에 대해 새로운 연결이 설정될 수 있더라도 연결에서 추가 스트림을 열어서는 안 됩니다.

GOAWAY의 수신자가 GOAWAY 프레임에 표시된 것보다 더 높은 스트림 식별자를 가진 스트림에 데이터를 보낸 경우 해당 스트림은 처리되지 않거나 처리되지 않습니다. GOAWAY 프레임의 수신자는 스트림을 전혀 생성되지 않은 것처럼 처리하여 나중에 새 연결에서 해당 스트림을 재시도할 수 있습니다.

엔드포인트는 연결을 닫기 전에 항상 GOAWAY 프레임을 보내야 원격 피어가 스트림이 부분적으로 처리되었는지 여부를 알 수 있습니다. 예를 들어, HTTP 클라이언트가 서버가 연결을 닫는 것과 동시에 POST를 보내는 경우, 서버가 어떤 스트림을 가질 수 있는지 나타내기 위해 GOAWAY 프레임을 보내지 않으면 서버가 해당 POST 요청 처리를 시작했는지 여부를 클라이언트는 알 수 없습니다. 행동했습니다.

엔드포인트는 오작동하는 피어에 대해 GOAWAY를 보내지 않고 연결을 닫도록 선택할 수 있습니다.

GOAWAY 프레임은 연결 종료 직후에 발생하지 않을 수 있습니다. 더 이상 연결을 사용하지 않는 GOAWAY 수신기는 연결을 종료하기 전에 GOAWAY 프레임을 보내야 합니다.

```text
   GOAWAY Frame {
     Length (24),
     Type (8) = 0x07,

     Unused Flags (8),

     Reserved (1),
     Stream Identifier (31) = 0,

     Reserved (1),
     Last-Stream-ID (31),
     Error Code (32),
     Additional Debug Data (..),
   }

                       Figure 10: GOAWAY Frame Format
```

길이, 유형, 사용되지 않은 플래그, 예약됨 및 스트림 식별자 필드는 섹션 4에 설명되어 있습니다.

GOAWAY 프레임은 플래그를 정의하지 않습니다.

GOAWAY 프레임은 특정 스트림이 아닌 연결에 적용됩니다. 엔드포인트는 0x00 이외의 스트림 식별자를 가진 GOAWAY 프레임을 PROTOCOL\_ERROR 유형의 연결 오류\(5.4.1절\)로 처리해야 합니다.

GOAWAY 프레임의 마지막 스트림 식별자에는 GOAWAY 프레임의 송신자가 어떤 조치를 취했거나 아직 조치를 취할 수 있는 가장 높은 번호의 스트림 식별자가 포함됩니다. 식별된 스트림까지의 모든 스트림이 어떤 방식으로든 처리되었을 수 있습니다. 스트림이 처리되지 않은 경우 마지막 스트림 식별자는 0으로 설정될 수 있습니다.

- | 참고: 이 맥락에서 "처리된"은 | 스트림이 소프트웨어의 상위 계층으로 전달되었습니다. | 결과적으로 어떤 조치를 취했을 수도 있습니다.

GOAWAY 프레임 없이 연결이 종료되면 마지막 스트림 식별자가 사실상 가능한 가장 높은 스트림 식별자가 됩니다.

연결이 닫히기 전에 완전히 닫히지 않은 더 낮거나 같은 번호의 식별자가 있는 스트림에서는 HTTP GET, PUT 또는 DELETE와 같은 멱등성 작업을 제외하고 요청, 트랜잭션 또는 프로토콜 활동을 다시 시도하는 것이 불가능합니다. 더 높은 번호의 스트림을 사용하는 모든 프로토콜 활동은 새 연결을 사용하여 안전하게 재시도할 수 있습니다.

마지막 스트림 식별자보다 작거나 같은 번호의 스트림에 대한 활동은 여전히 ​​성공적으로 완료될 수 있습니다. GOAWAY 프레임의 송신자는 진행 중인 모든 스트림이 완료될 때까지 연결을 "열린" 상태로 유지하면서 GOAWAY 프레임을 전송하여 연결을 정상적으로 종료할 수 있습니다.

상황이 바뀌면 엔드포인트는 여러 GOAWAY 프레임을 보낼 수 있습니다. 예를 들어, 정상적인 종료 중에 NO\_ERROR와 함께 GOAWAY를 보내는 엔드포인트는 이후에 연결을 즉시 종료해야 하는 조건에 직면할 수 있습니다. 수신된 마지막 GOAWAY 프레임의 마지막 스트림 식별자는 어떤 스트림이 작동되었을 수 있는지 나타냅니다. 피어가 이미 다른 연결에서 처리되지 않은 요청을 재시도했을 수 있으므로 엔드포인트는 마지막 스트림 식별자에서 보내는 값을 늘려서는 안 됩니다.

요청을 재시도할 수 없는 클라이언트는 서버가 연결을 닫을 때 진행 중인 모든 요청을 잃게 됩니다. 이는 HTTP/2를 사용하여 클라이언트에 서비스를 제공하지 않는 중개자의 경우 특히 그렇습니다. 연결을 정상적으로 종료하려고 시도하는 서버는 마지막 스트림 식별자가 2^31-1로 설정되고 NO\_ERROR 코드가 포함된 초기 GOAWAY 프레임을 보내야 합니다. 이는 종료가 임박했으며 추가 요청 시작이 금지됨을 클라이언트에 알립니다. 진행 중인 스트림 생성을 위한 시간\(최소 1회 왕복 시간\)을 허용한 후 서버는 업데이트된 마지막 스트림 식별자가 포함된 또 다른 GOAWAY 프레임을 보낼 수 있습니다. 이렇게 하면 요청 손실 없이 연결을 완전히 종료할 수 있습니다.

GOAWAY 프레임을 보낸 후 송신자는 식별된 마지막 스트림보다 높은 식별자를 사용하여 수신자가 시작한 스트림에 대한 프레임을 삭제할 수 있습니다. 그러나 연결 상태를 변경하는 프레임을 완전히 무시할 수는 없습니다. 예를 들어 HEADERS, PUSH\_PROMISE 및 CONTINUATION 프레임은 필드 섹션 압축을 위해 유지되는 상태가 일관되도록 보장하기 위해 최소한으로 처리되어야 합니다\(섹션 4.3 참조\). 마찬가지로 DATA 프레임은 연결 흐름 제어 창에 대해 계산되어야 합니다. 이러한 프레임을 처리하지 못하면 흐름 제어 또는 필드 섹션 압축 상태가 비동기화될 수 있습니다.

GOAWAY 프레임에는 연결을 닫는 이유를 포함하는 32비트 오류 코드\(섹션 7\)도 포함되어 있습니다.

엔드포인트는 GOAWAY 프레임의 프레임 페이로드에 불투명 데이터를 추가할 수 있습니다. 추가 디버그 데이터는 진단 목적으로만 사용되며 의미론적 값을 전달하지 않습니다. 디버그 정보에는 보안 또는 개인 정보 보호에 민감한 데이터가 포함될 수 있습니다. 기록되거나 지속적으로 저장된 디버그 데이터에는 무단 액세스를 방지하기 위한 적절한 보호 장치가 있어야 합니다.

---
### **6.9.  WINDOW_UPDATE**

WINDOW\_UPDATE 프레임\(유형=0x08\)은 흐름 제어를 구현하는 데 사용됩니다. 개요는 섹션 5.2를 참조하세요.

흐름 제어는 각 개별 스트림과 전체 연결의 두 가지 수준에서 작동합니다.

두 가지 유형의 흐름 제어 모두 홉 단위, 즉 두 끝점 사이에서만 이루어집니다. 중개자는 종속 연결 간에 WINDOW\_UPDATE 프레임을 전달하지 않습니다. 그러나 수신자의 데이터 전송 제한으로 인해 흐름 제어 정보가 원래 발신자에게 간접적으로 전파될 수 있습니다.

흐름 제어는 흐름 제어 대상으로 식별된 프레임에만 적용됩니다. 이 문서에 정의된 프레임 유형 중 여기에는 DATA 프레임만 포함됩니다. 흐름 제어에서 면제되는 프레임은 수신자가 프레임 처리에 리소스를 할당할 수 없는 경우를 제외하고 반드시 승인되고 처리되어야 합니다. 수신자는 프레임을 수락할 수 없는 경우 FLOW\_Control\_ERROR 유형의 스트림 오류\(5.4.2절\) 또는 연결 오류\(5.4.1절\)로 응답할 수 있습니다.

```text
   WINDOW_UPDATE Frame {
     Length (24) = 0x04,
     Type (8) = 0x08,

     Unused Flags (8),

     Reserved (1),
     Stream Identifier (31),

     Reserved (1),
     Window Size Increment (31),
   }

                   Figure 11: WINDOW_UPDATE Frame Format
```

길이, 유형, 사용되지 않은 플래그, 예약됨 및 스트림 식별자 필드는 섹션 4에 설명되어 있습니다. WINDOW\_UPDATE 프레임의 프레임 페이로드는 예약된 비트 1개에 보낸 사람이 사용할 수 있는 옥텟 수를 나타내는 부호 없는 31비트 정수입니다. 기존 흐름 제어 창에 추가로 전송합니다. 흐름 제어 창의 법적 증분 범위는 1\~2^31-1\(2,147,483,647\)옥텟입니다.

WINDOW\_UPDATE 프레임은 플래그를 정의하지 않습니다.

WINDOW\_UPDATE 프레임은 스트림 또는 전체 연결에 특정할 수 있습니다. 전자의 경우 프레임의 스트림 식별자는 영향을 받은 스트림을 나타냅니다. 후자에서 값 "0"은 전체 연결이 프레임의 주제임을 나타냅니다.

수신자는 흐름 제어 창 증분이 0인 WINDOW\_UPDATE 프레임의 수신을 PROTOCOL\_ERROR 유형의 스트림 오류\(5.4.2절\)로 처리해야 합니다. 연결 흐름 제어 창의 오류는 연결 오류\(섹션 5.4.1\)로 처리되어야 합니다.

WINDOW\_UPDATE는 END\_STREAM 플래그가 설정된 프레임을 보낸 피어에 의해 전송될 수 있습니다. 이는 수신자가 "반 폐쇄\(원격\)" 또는 "폐쇄" 상태의 스트림에서 WINDOW\_UPDATE 프레임을 수신할 수 있음을 의미합니다. 수신기는 이를 오류로 처리해서는 안 됩니다\(섹션 5.1 참조\).

흐름 제어 프레임을 수신하는 수신기는 수신기가 이를 연결 오류\(섹션 5.4.1\)로 처리하지 않는 한 항상 연결 흐름 제어 창에 대한 기여도를 고려해야 합니다. 이는 프레임에 오류가 있는 경우에도 필요합니다. 송신자는 흐름 제어 창을 향해 프레임을 계산하지만, 수신자가 그렇지 않으면 송신자와 수신자의 흐름 제어 창이 달라질 수 있습니다.

4옥텟이 아닌 길이의 WINDOW\_UPDATE 프레임은 FRAME\_SIZE\_ERROR 유형의 연결 오류\(섹션 5.4.1\)로 처리되어야 합니다.

---
#### **6.9.1.  The Flow-Control Window**

HTTP/2의 흐름 제어는 모든 스트림에서 각 발신자가 유지하는 창을 사용하여 구현됩니다. 흐름 제어 창은 보낸 사람이 전송하도록 허용된 데이터 옥텟 수를 나타내는 간단한 정수 값입니다. 따라서 그 크기는 수신기의 버퍼링 용량을 측정한 것입니다.

스트림 흐름 제어 창과 연결 흐름 제어 창이라는 두 가지 흐름 제어 창을 적용할 수 있습니다. 송신자는 수신자가 광고한 흐름 제어 창 중 하나에서 사용 가능한 공간을 초과하는 길이의 흐름 제어 프레임을 전송해서는 안 됩니다. END\_STREAM 플래그가 설정된 길이가 0인 프레임\(즉, 빈 DATA 프레임\)은 흐름 제어 창에 사용 가능한 공간이 없는 경우 전송될 수 있습니다.

흐름 제어 계산의 경우 9옥텟 프레임 헤더는 계산되지 않습니다.

흐름 제어 프레임을 전송한 후 전송자는 전송된 프레임의 길이만큼 두 창에서 사용 가능한 공간을 줄입니다.

프레임 수신자는 데이터를 소비하고 흐름 제어 창에서 공간을 확보할 때 WINDOW\_UPDATE 프레임을 보냅니다. 스트림 및 연결 수준 흐름 제어 창에 대해 별도의 WINDOW\_UPDATE 프레임이 전송됩니다. 매우 작은 증분으로 WINDOW\_UPDATE 프레임을 보내는 것을 방지하기 위해 수신기에 메커니즘을 마련하는 것이 좋습니다. \[RFC1122\]의 섹션 4.2.3.3을 참조하세요.

WINDOW\_UPDATE 프레임을 수신한 송신자는 프레임에 지정된 양만큼 해당 창을 업데이트합니다.

발신자는 흐름 제어 창이 2^31-1 옥텟을 초과하도록 허용해서는 안 됩니다. 송신자가 흐름 제어 창이 이 최대값을 초과하게 만드는 WINDOW\_UPDATE를 수신하면 적절하게 스트림이나 연결을 종료해야 합니다. 스트림의 경우 발신자는 오류 코드 FLOW\_Control\_ERROR와 함께 RST\_STREAM을 보냅니다. 연결의 경우 FLOW\_Control\_ERROR 오류 코드가 포함된 GOAWAY 프레임이 전송됩니다.

송신자의 흐름 제어 프레임과 수신자의 WINDOW\_UPDATE 프레임은 서로 완전히 비동기적입니다. 이 속성을 사용하면 수신자가 송신자가 유지한 창 크기를 적극적으로 업데이트하여 스트림이 중단되는 것을 방지할 수 있습니다.

---
#### **6.9.2.  Initial Flow-Control Window Size**

HTTP/2 연결이 처음 설정되면 초기 흐름 제어 창 크기가 65,535옥텟인 새 스트림이 생성됩니다. 연결 흐름 제어 창도 65,535옥텟입니다. 두 끝점 모두 SETTINGS 프레임에 SETTINGS\_INITIAL\_WINDOW\_SIZE 값을 포함하여 새 스트림의 초기 창 크기를 조정할 수 있습니다. 연결 흐름 제어 창은 WINDOW\_UPDATE 프레임을 통해서만 변경할 수 있습니다.

SETTINGS\_INITIAL\_WINDOW\_SIZE 값을 설정하는 SETTINGS 프레임을 수신하기 전에 엔드포인트는 흐름 제어 프레임을 보낼 때 기본 초기 창 크기만 사용할 수 있습니다. 마찬가지로 연결 흐름 제어 창은 WINDOW\_UPDATE 프레임이 수신될 때까지 기본 초기 창 크기를 기반으로 설정됩니다.

아직 활성화되지 않은 스트림에 대한 흐름 제어 창을 변경하는 것 외에도 SETTINGS 프레임은 활성 흐름 제어 창이 있는 스트림\(즉, "개방" 또는 "절반" 상태의 스트림\)에 대한 초기 흐름 제어 창 크기를 변경할 수 있습니다. -폐쇄\(원격\)' 상태\). SETTINGS\_INITIAL\_WINDOW\_SIZE 값이 변경되면 수신자는 새 값과 이전 값의 차이로 유지하는 모든 스트림 흐름 제어 창의 크기를 조정해야 합니다.

SETTINGS\_INITIAL\_WINDOW\_SIZE를 변경하면 흐름 제어 창에서 사용 가능한 공간이 음수가 될 수 있습니다. 발신자는 음의 흐름 제어 창을 추적해야 하며\(MUST\) 흐름 제어 창을 양으로 만드는 WINDOW\_UPDATE 프레임을 수신할 때까지 새로운 흐름 제어 프레임을 보내서는 안 됩니다.

예를 들어 클라이언트가 연결 설정 시 즉시 60KB를 보내고 서버가 초기 창 크기를 16KB로 설정한 경우 클라이언트는 SETTINGS 프레임 수신 시 사용 가능한 흐름 제어 창을 -44KB로 다시 계산합니다. 클라이언트는 WINDOW\_UPDATE 프레임이 창을 양수로 복원할 때까지 음수 흐름 제어 창을 유지합니다. 그 후에 클라이언트는 전송을 재개할 수 있습니다.

SETTINGS 프레임은 연결 흐름 제어 창을 변경할 수 없습니다.

엔드포인트는 흐름 제어 창이 최대 크기를 초과하게 만드는 SETTINGS\_INITIAL\_WINDOW\_SIZE에 대한 변경을 FLOW\_Control\_ERROR 유형의 연결 오류\(섹션 5.4.1\)로 처리해야 합니다.

---
#### **6.9.3.  Reducing the Stream Window Size**

현재 크기보다 작은 흐름 제어 창을 사용하려는 수신기는 새 SETTINGS 프레임을 보낼 수 있습니다. 그러나 송신자는 SETTINGS 프레임을 처리하기 전에 하한을 초과하는 데이터를 보낼 수 있으므로 수신자는 이 창 크기를 초과하는 데이터를 수신할 준비를 해야 합니다.

초기 흐름 제어 창 크기를 줄이는 SETTINGS 프레임을 보낸 후 수신기는 흐름 제어 제한을 초과하는 스트림을 계속 처리할 수 있습니다. 스트림이 계속되도록 허용한다고 해서 수신기가 흐름 제어 창을 위해 예약한 공간을 즉시 줄이는 것은 허용되지 않습니다. 송신자가 전송을 재개하려면 WINDOW\_UPDATE 프레임이 필요하기 때문에 이러한 스트림의 진행도 중단될 수 있습니다. 대신 수신자는 영향을 받은 스트림에 대해 FLOW\_Control\_ERROR 오류 코드와 함께 RST\_STREAM을 보낼 수 있습니다.

---
### **6.10.  CONTINUATION**

CONTINUATION 프레임\(유형=0x09\)은 필드 블록 조각의 시퀀스를 계속하는 데 사용됩니다\(섹션 4.3\). 이전 프레임이 동일한 스트림에 있고 END\_HEADERS 플래그가 설정되지 않은 HEADERS, PUSH\_PROMISE 또는 CONTINUATION 프레임인 한 원하는 수의 CONTINUATION 프레임을 보낼 수 있습니다.

```text
   CONTINUATION Frame {
     Length (24),
     Type (8) = 0x09,

     Unused Flags (5),
     END_HEADERS Flag (1),
     Unused Flags (2),

     Reserved (1),
     Stream Identifier (31),

     Field Block Fragment (..),
   }

                    Figure 12: CONTINUATION Frame Format
```

길이, 유형, 사용되지 않은 플래그, 예약 및 스트림 식별자 필드는 섹션 4에 설명되어 있습니다. CONTINUATION 프레임 페이로드에는 필드 블록 조각\(섹션 4.3\)이 포함되어 있습니다.

CONTINUATION 프레임은 다음 플래그를 정의합니다.

END\_HEADERS\(0x04\): 설정되면 END\_HEADERS 플래그는 이 프레임이 필드 블록을 끝낸다는 것을 나타냅니다\(섹션 4.3\).

- END\_HEADERS 플래그가 설정되지 않은 경우 이 프레임 뒤에는 다른 CONTINUATION 프레임이 와야 합니다. 수신기는 다른 유형의 프레임 또는 다른 스트림의 프레임 수신을 PROTOCOL\_ERROR 유형의 연결 오류\(5.4.1절\)로 처리해야 합니다.

CONTINUATION 프레임은 섹션 4.3에 정의된 대로 연결 상태를 변경합니다.

CONTINUATION 프레임은 스트림과 연결되어야 합니다. CONTINUATION 프레임이 스트림 식별자 필드 0x00으로 수신되면 수신자는 PROTOCOL\_ERROR 유형의 연결 오류\(5.4.1절\)로 응답해야 합니다.

CONTINUATION 프레임 앞에는 END\_HEADERS 플래그가 설정되지 않은 HEADERS, PUSH\_PROMISE 또는 CONTINUATION 프레임이 와야 합니다. 이 규칙 위반을 관찰한 수신자는 PROTOCOL\_ERROR 유형의 연결 오류\(섹션 5.4.1\)로 응답해야 합니다.

---
## **7.  Error Codes**

오류 코드는 RST\_STREAM 및 GOAWAY 프레임에서 스트림 또는 연결 오류의 원인을 전달하는 데 사용되는 32비트 필드입니다.

오류 코드는 공통 코드 공간을 공유합니다. 일부 오류 코드는 스트림이나 전체 연결에만 적용되며 다른 컨텍스트에서는 정의된 의미가 없습니다.

다음 오류 코드가 정의됩니다.

NO\_ERROR \(0x00\): 관련 조건이 오류의 결과가 아닙니다. 예를 들어 GOAWAY에는 연결의 정상적인 종료를 나타내기 위해 이 코드가 포함될 수 있습니다.

PROTOCOL\_ERROR\(0x01\): 끝점이 불특정 프로토콜 오류를 감지했습니다. 이 오류는 보다 구체적인 오류 코드를 사용할 수 없는 경우에 사용됩니다.

INTERNAL\_ERROR \(0x02\): 엔드포인트에 예상치 못한 내부 오류가 발생했습니다.

FLOW\_CONTROL\_ERROR \(0x03\): 엔드포인트가 해당 피어가 흐름 제어 프로토콜을 위반했음을 감지했습니다.

SETTINGS\_TIMEOUT\(0x04\): 엔드포인트가 SETTINGS 프레임을 보냈지만 적시에 응답을 받지 못했습니다. 섹션 6.5.3\("설정 동기화"\)을 참조하십시오.

STREAM\_CLOSED \(0x05\): 엔드포인트는 스트림이 절반 닫힌 후 프레임을 수신했습니다.

FRAME\_SIZE\_ERROR \(0x06\): 엔드포인트가 잘못된 크기의 프레임을 수신했습니다.

REFUSED\_STREAM\(0x07\): 엔드포인트는 애플리케이션 처리를 수행하기 전에 스트림을 거부했습니다\(자세한 내용은 섹션 8.7 참조\).

CANCEL\(0x08\): 엔드포인트는 이 오류 코드를 사용하여 스트림이 더 이상 필요하지 않음을 나타냅니다.

COMPRESSION\_ERROR \(0x09\): 엔드포인트가 연결에 대한 필드 섹션 압축 컨텍스트를 유지할 수 없습니다.

CONNECT\_ERROR \(0x0a\): CONNECT 요청\(8.5절\)에 대한 응답으로 설정된 연결이 재설정되었거나 비정상적으로 종료되었습니다.

ENHANCE\_YOUR\_CALM\(0x0b\): 엔드포인트가 피어가 과도한 로드를 생성할 수 있는 동작을 보이고 있음을 감지했습니다.

INADEQUATE\_SECURITY \(0x0c\): 기본 전송에 최소 보안 요구 사항을 충족하지 않는 속성이 있습니다\(섹션 9.2 참조\).

HTTP\_1\_1\_REQUIRED\(0x0d\): 엔드포인트에서는 HTTP/2 대신 HTTP/1.1을 사용해야 합니다.

알 수 없거나 지원되지 않는 오류 코드는 특별한 동작을 트리거해서는 안 됩니다. 이는 구현에 의해 INTERNAL\_ERROR와 동등한 것으로 처리될 수 있습니다.

---
## **8.  Expressing HTTP Semantics in HTTP/2**

HTTP/2는 HTTP 메시지 추상화\(\[HTTP\]의 섹션 6\)의 인스턴스화입니다.

---
### **8.1.  HTTP Message Framing**

클라이언트는 이전에 사용되지 않은 스트림 식별자\(섹션 5.1.1\)를 사용하여 새 스트림에 대한 HTTP 요청을 보냅니다. 서버는 요청과 동일한 스트림에서 HTTP 응답을 보냅니다.

HTTP 메시지\(요청 또는 응답\)는 다음으로 구성됩니다.

1. 헤더 섹션을 포함하는 하나의 HEADERS 프레임\(다음에 0개 이상의 CONTINUATION 프레임이 옴\)\(\[HTTP\]의 섹션 6.3 참조\)

1. 메시지 내용을 포함하는 0개 이상의 DATA 프레임\(\[HTTP\]의 섹션 6.4 참조\)

1. 선택적으로, 존재하는 경우 트레일러 섹션을 포함하는 하나의 HEADERS 프레임\(다음에 0개 이상의 CONTINUATION 프레임이 옵니다\)\(\[HTTP\]의 섹션 6.5 참조\).

응답에 대해서만 서버는 최종 응답을 포함하는 HEADERS 프레임 전에 임시 응답을 얼마든지 보낼 수 있습니다. 임시 응답은 제어 데이터와 임시\(1xx\) HTTP 응답의 헤더 섹션을 포함하는 HEADERS 프레임\(0개 이상의 CONTINUATION 프레임이 뒤따를 수 있음\)으로 구성됩니다\(\[HTTP\]의 섹션 15 참조\). 정보 상태 코드를 전달하는 END\_STREAM 플래그가 설정된 HEADERS 프레임의 형식이 잘못되었습니다\(8.1.1절\).

시퀀스의 마지막 프레임에는 END\_STREAM 플래그가 포함되어 있으며, 이는 END\_STREAM 플래그가 설정된 HEADERS 프레임 뒤에 필드 블록의 나머지 조각을 전달하는 CONTINUATION 프레임이 올 수 있음을 나타냅니다.

\(모든 스트림의\) 다른 프레임은 HEADERS 프레임과 뒤따르는 CONTINUATION 프레임 사이에 발생해서는 안 됩니다.

HTTP/2는 DATA 프레임을 사용하여 메시지 콘텐츠를 전달합니다. \[HTTP/1.1\]의 7.1절에 정의된 청크 전송 인코딩은 HTTP/2에서 사용할 수 없습니다. 섹션 8.2.2를 참조하세요.

트레일러 필드는 스트림을 종료하는 필드 블록으로 전달됩니다. 즉, 트레일러 필드는 HEADERS 프레임으로 시작하고 그 뒤에 0개 이상의 CONTINUATION 프레임이 오는 시퀀스로 구성됩니다. 여기서 HEADERS 프레임에는 END\_STREAM 플래그가 포함됩니다. 예고편에는 의사 헤더 필드\(섹션 8.3\)가 포함되어서는 안 됩니다. 트레일러의 의사 헤더 필드를 수신하는 엔드포인트는 요청 또는 응답을 잘못된 형식으로 처리해야 합니다\(8.1.1절\).

요청을 여는 HEADERS 프레임을 수신한 후 또는 최종\(비정보\) 상태 코드를 수신한 후 END\_STREAM 플래그가 설정되지 않은 HEADERS 프레임을 수신하는 엔드포인트는 해당 요청 또는 응답을 잘못된 형식으로 처리해야 합니다\(8.1.1절\).

HTTP 요청/응답 교환은 단일 스트림을 완전히 소비합니다. 요청은 스트림을 "열림" 상태로 만드는 HEADERS 프레임으로 시작됩니다. 요청은 END\_STREAM 플래그가 설정된 프레임으로 끝나며, 이로 인해 스트림이 클라이언트에 대해서는 "반 폐쇄\(로컬\)", 서버에 대해서는 "반 폐쇄\(원격\)"가 됩니다. 응답 스트림은 HEADERS 프레임에서 0개 이상의 임시 응답으로 시작하고 최종 상태 코드를 포함하는 HEADERS 프레임이 이어집니다.

HTTP 응답은 서버가 END\_STREAM 플래그가 설정된 프레임\(필드 블록을 완료하는 데 필요한 CONTINUATION 프레임 포함\)을 전송하거나 클라이언트가 수신한 후에 완료됩니다. 응답이 전송 및 수신되지 않은 요청 부분에 의존하지 않는 경우 클라이언트가 전체 요청을 보내기 전에 서버는 완전한 응답을 보낼 수 있습니다. 이것이 사실인 경우, 서버는 완전한 응답\(즉, END\_STREAM 플래그가 설정된 프레임\)을 보낸 후 NO\_ERROR 오류 코드와 함께 RST\_STREAM을 전송하여 클라이언트가 오류 없이 요청 전송을 중단하도록 요청할 수 있습니다. 클라이언트는 RST\_STREAM 수신의 결과로 응답을 폐기하면 안 되지만\(MUST NOT\), 클라이언트는 다른 이유로 항상 재량에 따라 응답을 폐기할 수 있습니다.

---
#### **8.1.1.  Malformed Messages**

잘못된 요청 또는 응답은 HTTP/2 프레임의 유효한 시퀀스이지만 관련 없는 프레임, 금지된 필드 또는 의사 헤더 필드, 필수 의사 헤더 필드의 부재, 대문자 포함으로 인해 유효하지 않은 요청 또는 응답입니다. 필드 이름 또는 유효하지 않은 필드 이름 및/또는 값\(특정 상황에서는 섹션 8.2 참조\)

메시지 콘텐츠를 포함하는 요청 또는 응답에는 콘텐츠 길이 헤더 필드가 포함될 수 있습니다. 메시지에 콘텐츠가 없는 것으로 정의되지 않는 한, 콘텐츠 길이 헤더 필드의 값이 콘텐츠를 구성하는 DATA 프레임 페이로드 길이의 합과 같지 않은 경우에도 요청 또는 응답의 형식이 잘못된 것입니다. 예를 들어 204 또는 304 응답에는 HEAD 요청에 대한 응답과 마찬가지로 콘텐츠가 포함되어 있지 않습니다. \[HTTP\]의 섹션 6.4.1에 설명된 대로 콘텐츠가 없는 것으로 정의된 응답은 DATA 프레임에 콘텐츠가 포함되어 있지 않더라도 0이 아닌 콘텐츠 길이 헤더 필드를 가질 수 있습니다.

HTTP 요청이나 응답을 처리하는 중개자\(즉, 터널 역할을 하지 않는 중개자\)는 잘못된 요청이나 응답을 전달해서는 안 됩니다. 잘못된 형식의 요청이나 감지된 응답은 PROTOCOL\_ERROR 유형의 스트림 오류\(섹션 5.4.2\)로 처리되어야 합니다.

잘못된 요청의 경우 서버는 스트림을 닫거나 재설정하기 전에 HTTP 응답을 보낼 수 있습니다. 클라이언트는 잘못된 응답을 수락해서는 안 됩니다.

점진적으로 메시지를 처리하는 엔드포인트는 요청이나 응답이 잘못된 형식임을 식별하기 전에 일부 처리를 수행했을 수 있습니다. 예를 들어, 완전한 요청을 받지 않고도 정보 제공 또는 404 상태 코드를 생성하는 것이 가능할 수 있습니다. 마찬가지로 중개자는 오류를 감지하기 전에 불완전한 메시지를 전달할 수도 있습니다. 서버는 요청의 나머지 부분이 올바른지 여부에 응답이 의존하지 않는 경우 전체 요청을 수신하기 전에 최종 응답을 생성할 수 있습니다.

이러한 요구 사항은 HTTP에 대한 여러 유형의 일반적인 공격으로부터 보호하기 위한 것입니다. 허용하면 구현이 이러한 취약점에 노출될 수 있으므로 의도적으로 엄격합니다.

---
### **8.2.  HTTP Fields**

HTTP 필드\(\[HTTP\]의 섹션 5\)는 HPACK \[COMPRESSION\]으로 압축된 HEADERS, CONTINUATION 및 PUSH\_PROMISE 프레임의 HTTP/2에 의해 전달됩니다.

HTTP/2 메시지를 구성할 때 필드 이름은 소문자로 변환되어야 합니다.

---
#### **8.2.1.  Field Validity**

HTTP의 필드 이름과 값 정의는 HPACK이 전달할 수 있는 일부 문자를 금지합니다. HTTP/2 구현은 각각 \[HTTP\]의 섹션 5.1과 5.5의 정의에 따라 필드 이름과 값의 유효성을 검사해야 하며, 금지된 문자를 포함하는 메시지를 잘못된 형식으로 처리해야 합니다\(섹션 8.1.1\).

필드 유효성 검사 실패는 요청 밀수 공격에 악용될 수 있습니다. 특히, 검증되지 않은 필드는 캐리지 리턴\(CR\), 줄 바꿈\(LF\) 및 COLON과 같은 문자가 구분 기호로 사용되는 HTTP/1.1 \[HTTP/1.1\]을 사용하여 메시지가 전달될 때 공격을 활성화할 수 있습니다. 구현에서는 필드 이름과 값에 대해 다음과 같은 최소한의 유효성 검사를 수행해야 합니다.

\* 필드 이름에는 0x00-0x20, 0x41-0x5a 또는 0x7f-0xff\(모든 범위 포함\) 범위의 문자가 포함되어서는 안 됩니다. 이는 특히 표시되지 않는 모든 ASCII 문자, ASCII SP\(0x20\) 및 대문자\('A' \~ 'Z', ASCII 0x41 \~ 0x5a\)를 제외합니다.

\* 단일 콜론으로 시작하는 이름을 갖는 의사 헤더 필드\(섹션 8.3\)를 제외하고, 필드 이름에는 콜론\(ASCII COLON, 0x3a\)이 포함되어서는 안 됩니다.

\* 필드 값은 모든 위치에 0 값\(ASCII NUL, 0x00\), 줄 바꿈\(ASCII LF, 0x0a\) 또는 캐리지 리턴\(ASCII CR, 0x0d\)을 포함해서는 안 됩니다.

\* 필드 값은 ASCII 공백 문자\(ASCII SP 또는 HTAB, 0x20 또는 0x09\)로 시작하거나 끝나서는 안 됩니다.

- | 참고: | \[HTTP\] 섹션 5.1 및 5.5의 정의에는 | 필드 이름에 대문자가 포함되어 있지 않은지 추가 확인 | 문자.

이러한 조건을 위반하는 필드를 포함하는 요청 또는 응답은 잘못된 형식으로 처리되어야 합니다\(8.1.1절\). 특히, 메시지를 전달할 때 필드를 처리하지 않는 중개자는 위에 금지된 것으로 나열된 값을 포함하는 필드를 전달해서는 안 됩니다.

요청 메시지가 이러한 요구 사항 중 하나를 위반하는 경우 구현은 더 적합한 상태 코드가 정의되거나 상태 코드가 전송될 수 없는 경우를 제외하고 400\(잘못된 요청\) 상태 코드\(\[HTTP\]의 섹션 15.5.1 참조\)를 생성해야 합니다\(SHOULD\). 예를 들어 트레일러 필드에서 오류가 발생했기 때문입니다.

- | 참고: | 해당 필드 정의에 대한 요청이 | 발생하지 않습니다. 기형이다; 위의 요구 사항은 일반 | \[HTTP\]의 섹션 5에 정의된 필드 구문입니다.

---
#### **8.2.2.  Connection-Specific Header Fields**

HTTP/2는 연결별 헤더 필드를 나타내기 위해 연결 헤더 필드\(\[HTTP\]의 섹션 7.6.1\)를 사용하지 않습니다. 이 프로토콜에서는 연결별 메타데이터가 다른 수단으로 전달됩니다. 엔드포인트는 연결별 헤더 필드를 포함하는 HTTP/2 메시지를 생성해서는 안 됩니다. 여기에는 연결 헤더 필드와 \[HTTP\]의 섹션 7.6.1에 연결별 의미가 있는 것으로 나열된 필드\(즉, 프록시 연결, 연결 유지, 전송 인코딩 및 업그레이드\)가 포함됩니다. 연결별 헤더 필드를 포함하는 모든 메시지는 잘못된 형식으로 처리되어야 합니다\(8.1.1절\).

이에 대한 유일한 예외는 HTTP/2 요청에 존재할 수 있는 TE 헤더 필드입니다. 이 경우 "트레일러" 이외의 값을 포함하면 안 됩니다.

HTTP/1.x 메시지를 HTTP/2로 변환하는 중개자는 \[HTTP\]의 섹션 7.6.1에 설명된 대로 연결별 헤더 필드를 제거해야 합니다. 그렇지 않으면 메시지가 다른 HTTP/2 엔드포인트에 의해 잘못된 형식으로 처리됩니다\(섹션 8.1\). .1\).

- | 참고: HTTP/2는 의도적으로 다른 버전으로의 업그레이드를 지원하지 않습니다. | 규약. 섹션 3에 설명된 핸드셰이크 방법은 | 대체 사용을 협상하기에 충분하다고 생각됨 | 프로토콜.

---
#### **8.2.3.  Compressing the Cookie Header Field**

쿠키 헤더 필드 \[COOKIE\]는 세미콜론\(";"\)을 사용하여 쿠키 쌍\(또는 "부스러기"\)을 구분합니다. 이 헤더 필드에는 여러 값이 포함되어 있지만 쉼표\(","\)를 구분 기호로 사용하지 않으므로 쿠키 쌍이 여러 필드 줄로 전송되는 것을 방지합니다\(\[HTTP\]의 섹션 5.2 참조\). 개별 쿠키 쌍을 업데이트하면 HPACK 테이블에 저장된 모든 필드 행이 무효화되므로 압축 효율성이 크게 저하될 수 있습니다.

더 나은 압축 효율성을 허용하기 위해 쿠키 헤더 필드는 각각 하나 이상의 쿠키 쌍이 있는 별도의 헤더 필드로 분할될 수 있습니다. 압축 해제 후 여러 개의 쿠키 헤더 필드가 있는 경우 이러한 필드는 HTTP/2가 아닌 컨텍스트로 전달되기 전에 0x3b, 0x20\(ASCII 문자열 ";"\)의 2옥텟 구분 기호를 사용하여 단일 옥텟 문자열로 연결되어야 합니다. HTTP/1.1 연결 또는 일반 HTTP 서버 애플리케이션으로 사용됩니다.

따라서 쿠키 헤더 필드의 다음 두 목록은 의미상 동일합니다.

```text
   cookie: a=b; c=d; e=f

   cookie: a=b
   cookie: c=d
   cookie: e=f
```

---
### **8.3.  HTTP Control Data**

HTTP/2는 ':' 문자\(ASCII 0x3a\)로 시작하는 특수 의사 헤더 필드를 사용하여 메시지 제어 데이터를 전달합니다\(\[HTTP\]의 섹션 6.2 참조\).

의사 헤더 필드는 HTTP 헤더 필드가 아닙니다. 엔드포인트는 이 문서에 정의된 것 이외의 의사 헤더 필드를 생성해서는 안 됩니다. 확장은 추가 의사 헤더 필드의 사용을 협상할 수 있습니다. 섹션 5.5를 참조하세요.

의사 헤더 필드는 해당 필드가 정의된 컨텍스트에서만 유효합니다. 요청에 대해 정의된 의사 헤더 필드는 응답에 나타나서는 안 됩니다. 응답에 대해 정의된 의사 헤더 필드는 요청에 나타나서는 안 됩니다. 의사 헤더 필드는 트레일러 섹션에 표시되어서는 안 됩니다. 엔드포인트는 정의되지 않았거나 유효하지 않은 의사 헤더 필드가 포함된 요청이나 응답을 잘못된 형식으로 처리해야 합니다\(섹션 8.1.1\).

모든 의사 헤더 필드는 모든 일반 필드 행 앞에 있는 필드 블록에 나타나야 합니다. 일반 필드 라인 뒤의 필드 블록에 나타나는 의사 헤더 필드를 포함하는 모든 요청 또는 응답은 잘못된 형식으로 처리되어야 합니다\(8.1.1절\).

동일한 의사 헤더 필드 이름은 필드 블록에 두 번 이상 나타나서는 안 됩니다. 반복되는 의사 헤더 필드 이름을 포함하는 HTTP 요청 또는 응답에 대한 필드 블록은 잘못된 형식으로 처리되어야 합니다\(8.1.1절\).

---
#### **8.3.1.  Request Pseudo-Header Fields**

HTTP/2 요청에 대해 다음 의사 헤더 필드가 정의됩니다.

\* ":method" 의사 헤더 필드에는 HTTP 메서드\(\[HTTP\]의 섹션 9\)가 포함됩니다.

\* ":scheme" 의사 헤더 필드에는 요청 대상의 구성표 부분이 포함됩니다. 이 체계는 요청을 직접 생성할 때 대상 URI\(\[RFC3986\]의 섹션 3.1\)에서 가져오거나 변환된 요청의 체계\(예: \[HTTP/1.1\]의 섹션 3.3 참조\)에서 가져옵니다. CONNECT 요청에 대해서는 스키마가 생략됩니다\(섹션 8.5\).

- ":scheme"은 "http" 및 "https" 구성 URI로 제한되지 않습니다. 프록시나 게이트웨이는 HTTP가 아닌 체계에 대한 요청을 변환하여 HTTP를 사용하여 HTTP가 아닌 서비스와 상호 작용할 수 있습니다.

\* ":authority" 의사 헤더 필드는 대상 URI\(\[HTTP\]의 섹션 7.1\)의 권한 부분\(\[RFC3986\]의 섹션 3.2\)을 전달합니다. HTTP/2 요청의 수신자는 ":authority"가 존재하는 경우 대상 URI를 결정하기 위해 Host 헤더 필드를 사용해서는 안 됩니다.

- HTTP/2 요청을 직접 생성하는 클라이언트는 전달할 권한 정보가 없는 한\(이 경우 ":authority"를 생성해서는 안 됨\) ":authority" 의사 헤더 필드를 사용하여 권한 정보를 전달해야 합니다.

- 클라이언트는 ":authority" 의사 헤더 필드와 다른 Host 헤더 필드를 사용하여 요청을 생성해서는 안 됩니다. 서버는 ":authority" 의사 헤더 필드의 엔터티와 다른 엔터티를 식별하는 Host 헤더 필드가 포함된 요청을 잘못된 형식으로 처리해야 합니다\(SHOULD\). 필드 값을 비교하려면 정규화해야 합니다\(\[RFC3986\]의 섹션 6.2 참조\). 원서버는 모든 정규화 방법을 적용할 수 있는 반면, 다른 서버는 두 필드의 체계 기반 정규화\(\[RFC3986\]의 섹션 6.2.3 참조\)를 수행해야 합니다.

- HTTP/2를 통해 요청을 전달하는 중개자는 원래 요청의 대상 URI에 권한 정보가 포함되지 않은 경우를 제외하고 원래 요청의 제어 데이터에서 권한 정보를 사용하여 ":authority" 의사 헤더 필드를 구성해야 합니다\(이 경우 ":authority"를 생성해서는 안 됩니다.\) Host 헤더 필드가 이 정보의 유일한 소스는 아닙니다. \[HTTP\]의 섹션 7.2를 참조하세요.

- Host 헤더 필드\(HTTP/1.1 요청을 구성하는 데 필요할 수 있음\)를 생성해야 하는 중개자는 ":authority" 의사 헤더 필드의 값을 Host 필드의 값으로 사용해야 합니다. 요청 대상을 변경합니다. 이는 HTTP 라우팅의 잠재적인 취약점을 방지하기 위해 기존 호스트 필드를 대체합니다.

- HTTP/2를 통해 요청을 전달하는 중개자는 모든 호스트 헤더 필드를 유지할 수 있습니다.

- CONNECT 또는 별표 형식 OPTIONS 요청의 요청 대상에는 권한 정보가 포함되지 않습니다. \[HTTP\]의 섹션 7.1 및 7.2를 참조하세요.

- ":authority"는 "http" 또는 "https" 구성 URI에 대해 더 이상 사용되지 않는 userinfo 하위 구성 요소를 포함해서는 안 됩니다.

\* ":path" 의사 헤더 필드에는 대상 URI의 경로 및 쿼리 부분이 포함됩니다\(절대 경로 생성 및 선택적으로 '?' 문자 뒤에 쿼리 생성; \[HTTP\]의 섹션 4.1 참조\). 별표 형식의 요청\(OPTIONS용\)에는 ":path" 의사 헤더 필드에 '\*' 값이 포함됩니다.

- 이 의사 헤더 필드는 "http" 또는 "https" URI에 대해 비어 있어서는 안 됩니다. 경로 구성 요소를 포함하지 않는 "http" 또는 "https" URI는 '/' 값을 포함해야 합니다. 이 규칙의 예외는 다음과 같습니다.

- 경로 구성 요소를 포함하지 않는 "http" 또는 "https" URI에 대한 OPTIONS 요청 여기에는 값이 '\*'인 ":path" 의사 헤더 필드가 포함되어야 합니다\(\[HTTP\]의 섹션 7.1 참조\).

- CONNECT 요청\(섹션 8.5\), 여기서 ":path" 의사 헤더 필드는 생략됩니다.

모든 HTTP/2 요청은 CONNECT 요청\(8.5절\)이 아닌 한 ":method", ":scheme" 및 ":path" 의사 헤더 필드에 대해 정확히 하나의 유효한 값을 포함해야 합니다. 필수 의사 헤더 필드를 생략하는 HTTP 요청의 형식이 잘못되었습니다\(섹션 8.1.1\).

개별 HTTP/2 요청에는 프로토콜 버전에 대한 명시적인 표시기가 없습니다. 모든 HTTP/2 요청은 암시적으로 "2.0"의 프로토콜 버전을 갖습니다\(\[HTTP\]의 섹션 6.2 참조\).

---
#### **8.3.2.  Response Pseudo-Header Fields**

HTTP/2 응답의 경우 HTTP 상태 코드 필드를 전달하는 단일 ":status" 의사 헤더 필드가 정의됩니다\(\[HTTP\]의 섹션 15 참조\). 이 의사 헤더 필드는 중간 응답을 포함한 모든 응답에 포함되어야 합니다. 그렇지 않으면 응답 형식이 잘못되었습니다\(8.1.1절\).

HTTP/2 응답에는 암시적으로 "2.0"의 프로토콜 버전이 있습니다.

---
### **8.4.  Server Push**

HTTP/2를 사용하면 서버는 이전 클라이언트가 시작한 요청과 관련하여 클라이언트에 응답\(해당 "약속된" 요청과 함께\)을 선제적으로 전송\(또는 "푸시"\)할 수 있습니다.

서버 푸시는 서버가 수신한 요청에 따를 요청을 예측하여 왕복을 제거함으로써 서버가 클라이언트 인식 성능을 향상시킬 수 있도록 설계되었습니다. 예를 들어, HTML에 대한 요청 뒤에는 해당 페이지에서 참조하는 스타일시트 및 스크립트에 대한 요청이 뒤따르는 경우가 많습니다. 이러한 요청이 푸시되면 클라이언트는 HTML에서 해당 요청에 대한 참조를 수신하고 별도의 요청을 발행할 때까지 기다릴 필요가 없습니다.

실제로 서버 푸시는 캐싱, 콘텐츠 협상, 사용자 행동 등의 요소를 고려하여 클라이언트가 추가 요청을 할 것인지 서버가 정확하게 예측해야 하기 때문에 효과적으로 사용하기 어렵습니다. 예측 오류는 연결의 추가 데이터가 나타내는 기회 비용으로 인해 성능 저하로 이어질 수 있습니다. 특히 상당한 양의 데이터를 푸시하면 더 중요한 응답에 경합 문제가 발생할 수 있습니다.

클라이언트는 서버 푸시를 비활성화하도록 요청할 수 있지만 이는 각 홉에 대해 독립적으로 협상됩니다. SETTINGS\_ENABLE\_PUSH 설정을 0으로 설정하여 서버 푸시가 비활성화되었음을 나타낼 수 있습니다.

약속된 요청은 안전해야 하며\(\[HTTP\]의 섹션 9.2.1 참조\) 캐시 가능해야 합니다\(\[HTTP\]의 섹션 9.2.3 참조\). 약속된 요청에는 콘텐츠나 예고편 섹션이 포함될 수 없습니다. 캐시할 수 없거나 안전한 것으로 알려지지 않았거나 요청 콘텐츠가 있음을 나타내는 약속된 요청을 수신하는 클라이언트는 PROTOCOL\_ERROR 유형의 스트림 오류\(섹션 5.4.2\)로 약속된 스트림을 재설정해야 합니다. 클라이언트가 새로 정의된 메서드를 안전한 것으로 인식하지 못하는 경우 약속된 스트림이 재설정될 수 있습니다.

캐시 가능한 푸시된 응답\(\[CACHING\]의 섹션 3 참조\)은 HTTP 캐시를 구현하는 경우 클라이언트에 의해 저장될 수 있습니다. 푸시된 응답은 약속된 스트림 식별자로 식별된 스트림이 여전히 열려 있는 동안 원서버에서 성공적으로 검증된 것으로 간주됩니다\(예: "no-cache" 캐시 응답 지시문이 있는 경우, \[CACHING\]의 섹션 5.2.2.4 참조\).

캐시할 수 없는 푸시된 응답은 HTTP 캐시에 저장되어서는 안 됩니다. 애플리케이션에서 별도로 사용할 수 있습니다.

서버는 ":authority" 의사 헤더 필드에 서버가 권한을 부여하는 값을 포함해야 합니다\(섹션 10.1 참조\). 클라이언트는 서버가 권한을 부여하지 않은 PUSH\_PROMISE를 PROTOCOL\_ERROR 유형의 스트림 오류\(5.4.2절\)로 처리해야 합니다.

중개자는 서버로부터 푸시를 수신하고 이를 클라이언트에 전달하지 않도록 선택할 수 있습니다. 즉, 푸시된 정보를 어떻게 활용하느냐는 그 중개자에게 달려있습니다. 마찬가지로 중개자는 서버에서 어떤 조치도 취하지 않고 클라이언트에 추가 푸시를 수행하도록 선택할 수 있습니다.

클라이언트는 푸시할 수 없습니다. 따라서 서버는 PUSH\_PROMISE 프레임 수신을 PROTOCOL\_ERROR 유형의 연결 오류\(5.4.1절\)로 처리해야 합니다. 서버는 SETTINGS\_ENABLE\_PUSH 설정을 0 이외의 값으로 설정할 수 없습니다\(섹션 6.5.2 참조\).

---
#### **8.4.1.  Push Requests**

서버 푸시는 서버가 요청에 응답하는 것과 의미상 동일합니다. 그러나 이 경우 해당 요청은 서버에서 PUSH\_PROMISE 프레임으로도 전송됩니다.

PUSH\_PROMISE 프레임에는 제어 데이터가 포함된 필드 블록과 서버가 요청에 속성을 부여하는 전체 요청 헤더 필드 세트가 포함되어 있습니다. 메시지 내용이 포함된 요청에는 응답을 푸시할 수 없습니다.

약속된 요청은 항상 클라이언트의 명시적인 요청과 연결됩니다. 서버에서 보낸 PUSH\_PROMISE 프레임은 해당 명시적 요청의 스트림을 통해 전송됩니다. PUSH\_PROMISE 프레임에는 서버에서 사용할 수 있는 스트림 식별자 중에서 선택된 약속된 스트림 식별자도 포함됩니다\(섹션 5.1.1 참조\).

PUSH\_PROMISE 및 후속 CONTINUATION 프레임의 헤더 필드는 유효하고 완전한 요청 헤더 필드 세트여야 합니다\(8.3.1절\). 서버는 ":method" 의사 헤더 필드에 안전하고 캐시 가능한 메소드를 포함해야 합니다. 클라이언트가 완전하고 유효한 헤더 필드 집합을 포함하지 않는 PUSH\_PROMISE를 수신하거나 ":method" 의사 헤더 필드가 안전하지 않은 메서드를 식별하는 경우 약속된 스트림에서 스트림 오류로 응답해야 합니다\(5.4절\). .2\) PROTOCOL\_ERROR 유형.

서버는 약속된 응답을 참조하는 프레임을 보내기 전에 PUSH\_PROMISE\(6.6절\) 프레임을 보내야 합니다. 이렇게 하면 클라이언트가 PUSH\_PROMISE 프레임을 수신하기 전에 요청을 보내는 경합을 방지할 수 있습니다.

예를 들어 서버가 여러 이미지 파일에 대한 링크가 포함된 문서에 대한 요청을 받고 서버가 해당 추가 이미지를 클라이언트에 푸시하기로 선택한 경우 이미지 링크가 포함된 DATA 프레임보다 PUSH\_PROMISE 프레임을 보내면 클라이언트가 이를 수행할 수 있습니다. 포함된 링크를 발견하기 전에 리소스가 푸시되는지 확인합니다. 마찬가지로 서버가 필드 블록에서 참조하는 리소스\(예: 링크 헤더 필드\)를 푸시하는 경우 헤더를 보내기 전에 PUSH\_PROMISE를 보내면 클라이언트가 해당 리소스를 요청하지 않도록 할 수 있습니다.

PUSH\_PROMISE 프레임은 클라이언트에 의해 전송되어서는 안 됩니다.

PUSH\_PROMISE 프레임은 클라이언트가 시작한 모든 스트림에서 서버에 의해 전송될 수 있지만 스트림은 서버에 대해 "개방" 또는 "반 폐쇄\(원격\)" 상태여야 합니다. PUSH\_PROMISE 프레임은 응답을 구성하는 프레임과 함께 배치되지만 단일 필드 블록을 구성하는 HEADERS 및 CONTINUATION 프레임과 함께 배치될 수는 없습니다.

PUSH\_PROMISE 프레임을 보내면 새 스트림이 생성되고 스트림이 서버에 대해서는 "예약\(로컬\)" 상태로, 클라이언트에 대해서는 "예약\(원격\)" 상태가 됩니다.

---
#### **8.4.2.  Push Responses**

PUSH\_PROMISE 프레임을 보낸 후 서버는 약속된 스트림 식별자를 사용하는 서버 시작 스트림에 대한 응답\(8.3.2절\)으로 푸시된 응답을 전달하기 시작할 수 있습니다. 서버는 이 스트림을 사용하여 섹션 8.1에 정의된 것과 동일한 프레임 시퀀스를 사용하여 HTTP 응답을 전송합니다. 이 스트림은 초기 HEADERS 프레임이 전송된 후 클라이언트에 대해 "절반 폐쇄"됩니다\(섹션 5.1\).

클라이언트가 PUSH\_PROMISE 프레임을 수신하고 푸시된 응답을 수락하기로 선택하면 클라이언트는 약속된 스트림이 닫힐 때까지 약속된 응답에 대한 요청을 발행해서는 안 됩니다.

어떤 이유로든 클라이언트가 서버로부터 푸시된 응답을 수신하고 싶지 않다고 결정하거나 서버가 약속된 응답 전송을 시작하는 데 너무 오랜 시간이 걸리는 경우 클라이언트는 CANCEL 또는 REFUSED\_STREAM을 사용하여 RST\_STREAM 프레임을 보낼 수 있습니다. 코드를 작성하고 푸시된 스트림의 식별자를 참조합니다.

클라이언트는 SETTINGS\_MAX\_CONCURRENT\_STREAMS 설정을 사용하여 서버가 동시에 푸시할 수 있는 응답 수를 제한할 수 있습니다. SETTINGS\_MAX\_CONCURRENT\_STREAMS 값을 0으로 알리면 서버가 응답을 푸시하는 데 필요한 스트림을 열 수 없습니다. 그러나 예약된 스트림은 동시 스트림 제한에 포함되지 않기 때문에 서버가 PUSH\_PROMISE 프레임을 사용하여 스트림을 예약하는 것을 막지는 못합니다. 푸시된 리소스를 수신하지 않으려는 클라이언트는 원치 않는 예약 스트림을 재설정하거나 SETTINGS\_ENABLE\_PUSH를 0으로 설정해야 합니다.

푸시된 응답을 수신하는 클라이언트는 서버가 권한이 있는지\(섹션 10.1 참조\) 또는 푸시된 응답을 제공한 프록시가 해당 요청에 대해 구성되었는지 확인해야 합니다. 예를 들어, example.com DNS-ID\(\[RFC6125\] 참조\)에 대해서만 인증서를 제공하는 서버는 <https://www.example.org/doc\>에 대한 응답을 푸시하는 것이 허용되지 않습니다.

PUSH\_PROMISE 스트림에 대한 응답은 HEADERS 프레임으로 시작합니다. 이 프레임은 스트림을 서버의 경우 "반 폐쇄\(원격\)" 상태로, 클라이언트의 경우 "반 폐쇄\(로컬\)" 상태로 즉시 전환하고 프레임으로 끝납니다. 스트림을 "닫힌" 상태로 만드는 END\_STREAM 플래그가 설정되어 있습니다.

- | 참고: 클라이언트는 END\_STREAM 플래그 | 서버 푸시로 설정되었습니다.

---
### **8.5.  The CONNECT Method**

CONNECT 메소드\(\[HTTP\]의 섹션 9.3.6\)는 HTTP 연결을 원격 호스트에 대한 터널로 변환하는 데 사용됩니다. CONNECT는 주로 "https" 리소스와 상호 작용할 목적으로 원본 서버와 TLS 세션을 설정하기 위해 HTTP 프록시와 함께 사용됩니다.

HTTP/2에서 CONNECT 메서드는 전체 연결을 터널로 변환하는 대신 단일 HTTP/2 스트림을 통해 원격 호스트에 대한 터널을 설정합니다. CONNECT 헤더 섹션은 섹션 8.3.1\("의사 헤더 필드 요청"\)에 정의된 대로 구성되지만 몇 가지 차이점이 있습니다. 구체적으로:

\* ":method" 의사 헤더 필드는 CONNECT로 설정됩니다.

\* ":scheme" 및 ":path" 의사 헤더 필드는 생략되어야 합니다.

\* ":authority" 의사 헤더 필드에는 연결할 호스트와 포트가 포함되어 있습니다\(CONNECT 요청의 request-target의 Authority 형식과 동일합니다. \[HTTP/1.1\]의 섹션 3.2.3 참조\).

이러한 제한 사항을 준수하지 않는 CONNECT 요청은 잘못된 형식입니다\(8.1.1절\).

CONNECT를 지원하는 프록시는 ":authority" 의사 헤더 필드에 식별된 호스트 및 포트에 대한 TCP 연결\[TCP\]을 설정합니다. 이 연결이 성공적으로 설정되면 프록시는 \[HTTP\]의 섹션 9.3.6에 정의된 대로 2xx 시리즈 상태 코드가 포함된 HEADERS 프레임을 클라이언트에 보냅니다.

각 피어가 보낸 초기 HEADERS 프레임 이후의 모든 후속 DATA 프레임은 TCP 연결에서 전송된 데이터에 해당합니다. 클라이언트가 보낸 모든 DATA 프레임의 프레임 페이로드는 프록시에 의해 TCP 서버로 전송됩니다. TCP 서버로부터 수신된 데이터는 프록시에 의해 DATA 프레임으로 조립됩니다. DATA 또는 스트림 관리 프레임\(RST\_STREAM, WINDOW\_UPDATE 및 PRIORITY\) 이외의 프레임 유형은 연결된 스트림에서 전송되어서는 안 되며 수신된 경우 스트림 오류\(섹션 5.4.2\)로 처리되어야 합니다.

두 피어 모두 TCP 연결을 닫을 수 있습니다. DATA 프레임의 END\_STREAM 플래그는 TCP FIN 비트와 동일한 것으로 처리됩니다. 클라이언트는 END\_STREAM 플래그가 설정된 프레임을 수신한 후 END\_STREAM 플래그가 설정된 DATA 프레임을 보낼 것으로 예상됩니다. END\_STREAM 플래그가 설정된 DATA 프레임을 수신하는 프록시는 마지막 TCP 세그먼트에 FIN 비트가 설정된 첨부 데이터를 보냅니다. FIN 비트가 설정된 TCP 세그먼트를 수신하는 프록시는 END\_STREAM 플래그가 설정된 DATA 프레임을 보냅니다. 마지막 TCP 세그먼트나 DATA 프레임은 비어 있을 수 있습니다.

RST\_STREAM으로 TCP 연결 오류가 표시됩니다. 프록시는 RST 비트가 설정된 TCP 세그먼트 수신을 포함하여 TCP 연결의 모든 오류를 CONNECT\_ERROR 유형의 스트림 오류\(섹션 5.4.2\)로 처리합니다. 이에 따라 프록시는 스트림 또는 HTTP/2 연결에서 오류를 감지한 경우 RST 비트가 설정된 TCP 세그먼트를 보내야 합니다.

---
### **8.6.  The Upgrade Header Field**

HTTP/2는 101\(스위칭 프로토콜\) 정보 상태 코드\(\[HTTP\]의 섹션 15.2.2\)를 지원하지 않습니다.

101\(스위칭 프로토콜\)의 의미는 다중화 프로토콜에 적용되지 않습니다. 확장된 CONNECT \[RFC8441\]를 사용하여 유사한 기능을 활성화할 수 있으며, 다른 프로토콜은 HTTP/2가 사용 협상에 사용하는 것과 동일한 메커니즘을 사용할 수 있습니다\(섹션 3 참조\).

---
### **8.7.  Request Reliability**

일반적으로 HTTP 클라이언트는 오류의 성격을 판단할 수단이 없기 때문에 오류 발생 시 비멱등성 요청을 재시도할 수 없습니다\(\[HTTP\]의 섹션 9.2.2 참조\). 오류가 발생하기 전에 일부 서버 처리가 발생했을 수 있으며, 이로 인해 요청을 다시 시도하면 바람직하지 않은 결과가 발생할 수 있습니다.

HTTP/2는 요청이 처리되지 않았음을 클라이언트에 보장하기 위한 두 가지 메커니즘을 제공합니다.

\* GOAWAY 프레임은 처리되었을 수 있는 가장 높은 스트림 번호를 나타냅니다. 따라서 더 높은 숫자의 스트림에 대한 요청은 재시도해도 안전하다는 것이 보장됩니다.

\* REFUSED\_STREAM 오류 코드는 RST\_STREAM 프레임에 포함되어 처리가 발생하기 전에 스트림이 닫히고 있음을 나타낼 수 있습니다. 재설정 스트림을 통해 전송된 모든 요청은 안전하게 재시도될 수 있습니다.

처리되지 않은 요청은 실패하지 않았습니다. 클라이언트는 멱등성이 없는 방법을 사용하는 경우에도 자동으로 재시도할 수 있습니다.

서버는 해당 사실을 보장할 수 없는 한 스트림이 처리되지 않았음을 표시해서는 안 됩니다. 스트림에 있는 프레임이 모든 스트림에 대해 애플리케이션 계층으로 전달되는 경우 REFUSED\_STREAM은 해당 스트림에 사용되어서는 안 되며 GOAWAY 프레임에는 주어진 스트림 식별자보다 크거나 같은 스트림 식별자가 포함되어야 합니다.

이러한 메커니즘 외에도 PING 프레임은 클라이언트가 연결을 쉽게 테스트할 수 있는 방법을 제공합니다. 일부 미들박스\(예: 네트워크 주소 변환기 또는 로드 밸런서\)가 자동으로 연결 바인딩을 삭제하기 때문에 유휴 상태인 연결이 끊어질 수 있습니다. PING 프레임을 사용하면 클라이언트는 요청을 보내지 않고도 연결이 여전히 활성 상태인지 안전하게 테스트할 수 있습니다.

---
### **8.8.  Examples**

이 섹션에서는 HTTP/1.1 요청 및 응답과 동등한 HTTP/2 요청 및 응답을 보여줍니다.

---
#### **8.8.1.  Simple Request**

HTTP GET 요청에는 제어 데이터와 메시지 내용이 없는 요청 헤더가 포함되어 있으므로 단일 HEADERS 프레임으로 전송되고, 그 뒤에 직렬화된 요청 헤더 필드 블록이 포함된 0개 이상의 CONTINUATION 프레임이 옵니다. 다음의 HEADERS 프레임에는 END\_HEADERS 및 END\_STREAM 플래그가 모두 설정되어 있습니다. CONTINUATION 프레임은 전송되지 않습니다.

```text
     GET /resource HTTP/1.1           HEADERS
     Host: example.org          ==>     + END_STREAM
     Accept: image/jpeg                 + END_HEADERS
                                          :method = GET
                                          :scheme = https
                                          :authority = example.org
                                          :path = /resource
                                          host = example.org
                                          accept = image/jpeg
```

---
#### **8.8.2.  Simple Response**

마찬가지로 제어 데이터와 응답 헤더만 포함하는 응답은 응답 헤더 필드의 직렬화된 블록을 포함하는 HEADERS 프레임\(역시 0개 이상의 CONTINUATION 프레임이 뒤따름\)으로 전송됩니다.

```text
     HTTP/1.1 304 Not Modified        HEADERS
     ETag: "xyzzy"              ==>     + END_STREAM
     Expires: Thu, 23 Jan ...           + END_HEADERS
                                          :status = 304
                                          etag = "xyzzy"
                                          expires = Thu, 23 Jan ...
```

---
#### **8.8.3.  Complex Request**

제어 데이터와 메시지 내용이 포함된 요청 헤더를 포함하는 HTTP POST 요청은 하나의 HEADERS 프레임으로 전송되고, 그 뒤에는 요청 헤더가 포함된 0개 이상의 CONTINUATION 프레임이 오고, 마지막 CONTINUATION\(또는 HEADERS\)과 함께 하나 이상의 DATA 프레임이 옵니다. END\_HEADERS 플래그가 설정된 프레임과 END\_STREAM 플래그가 설정된 최종 DATA 프레임:

```text
     POST /resource HTTP/1.1          HEADERS
     Host: example.org          ==>     - END_STREAM
     Content-Type: image/jpeg           - END_HEADERS
     Content-Length: 123                  :method = POST
                                          :authority = example.org
                                          :path = /resource
     {binary data}                        :scheme = https

                                      CONTINUATION
                                        + END_HEADERS
                                          content-type = image/jpeg
                                          host = example.org
                                          content-length = 123

                                      DATA
                                        + END_STREAM
                                      {binary data}
```

특정 필드 라인에 기여하는 데이터는 필드 블록 조각 간에 분산될 수 있습니다. 이 예에서 필드 라인을 프레임에 할당하는 것은 단지 예시일 뿐입니다.

---
#### **8.8.4.  Response with Body**

제어 데이터와 메시지 내용이 포함된 응답 헤더를 포함하는 응답은 HEADERS 프레임으로 전송되고, 그 뒤에는 0개 이상의 CONTINUATION 프레임, 하나 이상의 DATA 프레임이 옵니다. 시퀀스의 마지막 DATA 프레임에는 END\_STREAM 플래그가 설정되어 있습니다.

```text
     HTTP/1.1 200 OK                  HEADERS
     Content-Type: image/jpeg   ==>     - END_STREAM
     Content-Length: 123                + END_HEADERS
                                          :status = 200
     {binary data}                        content-type = image/jpeg
                                          content-length = 123

                                      DATA
                                        + END_STREAM
                                      {binary data}
```

---
#### **8.8.5.  Informational Responses**

101이 아닌 1xx 상태 코드를 사용하는 정보 응답은 HEADERS 프레임으로 전송되고 그 뒤에는 0개 이상의 CONTINUATION 프레임이 이어집니다.

요청 또는 응답 필드 블록과 모든 DATA 프레임이 전송된 후 트레일러 섹션이 필드 블록으로 전송됩니다. 트레일러 섹션을 구성하는 필드 블록을 시작하는 HEADERS 프레임에는 END\_STREAM 플래그가 설정되어 있습니다.

다음 예에는 Expect 헤더 필드에 "100-continue" 토큰이 포함된 요청에 대한 응답으로 전송되는 100\(Continue\) 상태 코드와 트레일러 섹션이 모두 포함되어 있습니다.

```text
     HTTP/1.1 100 Continue            HEADERS
     Extension-Field: bar       ==>     - END_STREAM
                                        + END_HEADERS
                                          :status = 100
                                          extension-field = bar

     HTTP/1.1 200 OK                  HEADERS
     Content-Type: image/jpeg   ==>     - END_STREAM
     Transfer-Encoding: chunked         + END_HEADERS
     Trailer: Foo                         :status = 200
                                          content-type = image/jpeg
     123                                  trailer = Foo
     {binary data}
     0                                DATA
     Foo: bar                           - END_STREAM
                                      {binary data}

                                      HEADERS
                                        + END_STREAM
                                        + END_HEADERS
                                          foo = bar
```

---
## **9.  HTTP/2 Connections**

이 섹션에서는 상호 운용성을 향상시키고 알려진 보안 취약점에 대한 노출을 줄이거나 구현 변형 가능성을 줄이는 HTTP의 속성을 간략하게 설명합니다.

---
### **9.1.  Connection Management**

HTTP/2 연결은 지속적입니다. 최상의 성능을 위해 클라이언트는 서버와의 추가 통신이 필요하지 않다고 판단되거나\(예: 사용자가 특정 웹 페이지에서 다른 곳으로 이동할 때\) 서버가 연결을 닫을 때까지 연결을 닫지 않을 것으로 예상됩니다.

클라이언트는 지정된 호스트 및 포트 쌍에 대해 둘 이상의 HTTP/2 연결을 열어서는 안 됩니다. 여기서 호스트는 URI, 선택된 대체 서비스\[ALT-SVC\] 또는 구성된 프록시에서 파생됩니다.

클라이언트는 사용 가능한 스트림 식별자 공간을 거의 소진하는 연결을 대체하거나\(섹션 5.1.1\), TLS 연결에 대한 키 자료를 새로 고치거나, 오류가 발생한 연결을 대체하기 위해\(섹션 5.1.1\) 대체 연결로 추가 연결을 생성할 수 있습니다. 5.4.1\).

클라이언트는 서로 다른 서버 이름 표시\[TLS-EXT\] 값을 사용하거나 서로 다른 TLS 클라이언트 인증서를 제공하기 위해 동일한 IP 주소 및 TCP 포트에 대한 여러 연결을 열 수 있지만 동일한 구성으로 여러 연결을 생성하는 것을 피해야 합니다\(SHOULD\).

서버는 가능한 한 오랫동안 열린 연결을 유지하는 것이 좋지만 필요한 경우 유휴 연결을 종료하는 것이 허용됩니다. 두 엔드포인트 중 하나가 전송 계층 TCP 연결을 닫기로 선택한 경우 종료 엔드포인트는 먼저 GOAWAY\(6.8절\) 프레임을 보내야 합니다. 그러면 두 엔드포인트가 이전에 전송된 프레임이 처리되었는지 여부를 안정적으로 결정하고 필요한 나머지 작업을 정상적으로 완료하거나 종료할 수 있습니다.

---
#### **9.1.1.  Connection Reuse**

직접적으로 또는 CONNECT 메서드\(8.5절\)를 사용하여 생성된 터널을 통해 원서버에 이루어진 연결은 여러 다른 URI 권한 구성 요소가 있는 요청에 재사용될 수 있습니다. 원본 서버가 권한을 갖고 있는 한 연결은 재사용될 수 있습니다\(10.1절\). TLS가 없는 TCP 연결의 경우 이는 동일한 IP 주소로 확인된 호스트에 따라 달라집니다.

"https" 리소스의 경우 연결 재사용은 URI의 호스트에 유효한 인증서가 있는지 여부에 따라 달라집니다. 서버가 제공하는 인증서는 클라이언트가 URI의 호스트에 대한 새 TLS 연결을 형성할 때 수행하는 모든 검사를 충족해야 합니다. 단일 인증서를 사용하여 여러 원본에 대한 권한을 설정할 수 있습니다. \[HTTP\]의 섹션 4.3에서는 클라이언트가 서버가 URI에 대해 권한이 있는지 여부를 결정하는 방법을 설명합니다.

일부 배포에서는 여러 원본에 대한 연결을 재사용하면 요청이 잘못된 원본 서버로 전달될 수 있습니다. 예를 들어 TLS 종료는 TLS 서버 이름 표시\[TLS-EXT\] 확장을 사용하여 원본 서버를 선택하는 미들박스에 의해 수행될 수 있습니다. 이는 서버가 권한을 갖고 있더라도 클라이언트가 의도한 요청 대상이 아닌 서버에 요청을 보낼 수 있음을 의미합니다.

클라이언트가 연결을 재사용하는 것을 원하지 않는 서버는 요청에 대한 응답으로 421\(잘못된 요청\) 상태 코드를 전송하여 요청에 대한 권한이 없음을 나타낼 수 있습니다\(\[HTTP\]의 섹션 15.5.20 참조\).

HTTP/2를 통해 프록시를 사용하도록 구성된 클라이언트는 단일 연결을 통해 요청을 해당 프록시로 전달합니다. 즉, 프록시를 통해 전송된 모든 요청은 프록시에 대한 연결을 재사용합니다.

---
### **9.2.  Use of TLS Features**

HTTP/2 구현은 TLS를 통한 HTTP/2에 대해 TLS 버전 1.2\[TLS12\] 이상을 사용해야 합니다. \[TLSBCP\]의 일반 TLS 사용 지침을 따라야 하며 HTTP/2에 특정한 몇 가지 추가 제한 사항을 준수해야 합니다.

TLS 구현은 TLS에 대한 SNI\(서버 이름 표시\) \[TLS-EXT\] 확장을 지원해야 합니다. 서버가 도메인 이름 \[DNS-TERMS\]으로 식별되는 경우 대상 호스트를 나타내는 대체 메커니즘이 사용되지 않는 한 클라이언트는 server\_name TLS 확장을 보내야 합니다.

TLS 1.3 \[TLS13\]을 협상하는 HTTP/2 배포에 대한 요구 사항은 섹션 9.2.3에 포함되어 있습니다. TLS 1.2 배포에는 섹션 9.2.1 및 9.2.2의 요구 사항이 적용됩니다. 구현에서는 준수하는 기본값을 제공하도록 권장되지만 배포는 궁극적으로 준수에 대한 책임이 있음이 인식됩니다.

---
#### **9.2.1.  TLS 1.2 Features**

이 섹션에서는 HTTP/2와 함께 사용할 수 있는 TLS 1.2 기능 세트에 대한 제한 사항을 설명합니다. 배포 제한으로 인해 이러한 제한 사항이 충족되지 않으면 TLS 협상이 실패하지 못할 수도 있습니다. 엔드포인트는 INADEQUATE\_SECURITY 유형의 연결 오류\(섹션 5.4.1\)로 인해 이러한 TLS 요구 사항을 충족하지 않는 HTTP/2 연결을 즉시 종료할 수 있습니다.

TLS 1.2를 통한 HTTP/2 배포는 압축을 비활성화해야 합니다. TLS 압축으로 인해 다른 방법으로는 공개되지 않는 정보가 노출될 수 있습니다\[RFC3749\]. HTTP/2는 컨텍스트를 더 잘 인식하여 성능, 보안 또는 기타 이유로 사용하기에 더 적합한 압축 기능을 제공하므로 일반 압축은 필요하지 않습니다.

TLS 1.2를 통한 HTTP/2 배포는 재협상을 비활성화해야 합니다. 엔드포인트는 TLS 재협상을 PROTOCOL\_ERROR 유형의 연결 오류\(섹션 5.4.1\)로 처리해야 합니다. 재협상을 비활성화하면 기본 암호화 제품군이 암호화할 수 있는 메시지 수 제한으로 인해 오랫동안 지속되는 연결을 사용할 수 없게 될 수 있습니다.

엔드포인트는 재협상을 사용하여 핸드셰이크에서 제공되는 클라이언트 자격 증명에 대한 기밀 보호를 제공할 수 있지만 모든 재협상은 연결 서문을 보내기 전에 이루어져야 합니다. 서버는 연결 설정 직후 재협상 요청을 확인하는 경우 클라이언트 인증서를 요청해야 합니다\(SHOULD\).

이는 특정 보호 리소스에 대한 요청에 대한 응답으로 재협상이 사용되는 것을 효과적으로 방지합니다. 향후 사양에서는 이 사용 사례를 지원하는 방법을 제공할 수 있습니다. 또는 서버는 HTTP\_1\_1\_REQUIRED 유형의 오류\(5.4절\)를 사용하여 클라이언트가 재협상을 지원하는 프로토콜을 사용하도록 요청할 수 있습니다.

구현은 임시 유한 필드 DHE\(Diffie-Hellman\)\(\[TLS12\]의 섹션 8.1.2\)를 사용하는 암호화 제품군에 대해 최소 2048비트의 임시 키 교환 크기를 지원해야 하며, 임시 타원 곡선 Diffie-Hellman을 사용하는 암호화 제품군에 대해 224비트를 지원해야 합니다. \(ECDHE\) \[RFC8422\]. 클라이언트는 최대 4096비트의 DHE 크기를 허용해야 합니다. 엔드포인트는 하한보다 작은 키 크기 협상을 INADEQUATE\_SECURITY 유형의 연결 오류\(섹션 5.4.1\)로 처리할 수 있습니다.

---
#### **9.2.2.  TLS 1.2 Cipher Suites**

TLS 1.2를 통한 HTTP/2 배포에서는 부록 A에 나열된 금지된 암호화 제품군을 사용해서는 안 됩니다.

엔드포인트는 금지된 암호화 제품군 중 하나가 협상되는 경우 INADEQUATE\_SECURITY 유형의 연결 오류\(섹션 5.4.1\)를 생성하도록 선택할 수 있습니다. 금지된 암호 제품군을 사용하도록 선택한 배포에서는 잠재적 피어 집합이 해당 암호 제품군을 허용하는 것으로 알려지지 않은 경우 연결 오류가 발생할 위험이 있습니다.

구현 시 금지되지 않은 암호 제품군 협상에 대한 반응으로 이 오류를 생성해서는 안 됩니다. 결과적으로 클라이언트가 금지되지 않은 암호화 제품군을 제공하는 경우 HTTP/2와 함께 해당 암호화 제품군을 사용할 준비를 해야 합니다.

금지된 암호 제품군 목록에는 TLS 1.2에서 필수로 지정하는 암호 제품군이 포함되어 있습니다. 즉, TLS 1.2 배포에는 허용되는 암호 제품군의 교차하지 않는 집합이 있을 수 있습니다. TLS 핸드셰이크 실패를 일으키는 이 문제를 방지하려면 TLS 1.2를 사용하는 HTTP/2 배포는 P-256 타원 곡선\[RFC8422\]과 함께 TLS\_ECDHE\_RSA\_WITH\_AES\_128\_GCM\_SHA256\[TLS-ECDHE\]을 지원해야 합니다.

클라이언트는 HTTP/2를 지원하지 않는 서버에 대한 연결을 허용하기 위해 금지된 암호화 제품군 지원을 광고할 수 있습니다. 이를 통해 서버는 HTTP/2에서 금지된 암호화 제품군을 사용하여 HTTP/1.1을 선택할 수 있습니다. 그러나 이로 인해 애플리케이션 프로토콜과 암호 제품군이 독립적으로 선택된 경우 HTTP/2가 금지된 암호 제품군과 협상될 수 있습니다.

---
#### **9.2.3.  TLS 1.3 Features**

TLS 1.3에는 이전 버전에서는 사용할 수 없는 다양한 기능이 포함되어 있습니다. 이 섹션에서는 이러한 기능의 사용에 대해 설명합니다.

HTTP/2 서버는 핸드셰이크 후 TLS 1.3 CertificateRequest 메시지를 보내면 안 됩니다. HTTP/2 클라이언트는 TLS 핸드셰이크 후 CertificateRequest 메시지를 PROTOCOL\_ERROR 유형의 연결 오류\(섹션 5.4.1\)로 처리해야 합니다.

클라이언트가 "post\_handshake\_auth" TLS 확장을 제공한 경우에도 사후 핸드셰이크 인증 금지가 적용됩니다. 핸드셰이크 후 인증 지원은 ALPN\[TLS-ALPN\]과 독립적으로 광고될 수 있습니다. 클라이언트는 다른 프로토콜에서 사용할 수 있는 기능을 제공할 수 있지만 확장 기능이 포함되었다고 해서 HTTP/2 내에서 지원된다는 의미는 아닙니다.

\[TLS13\]은 HTTP/2와 직접적인 상호 작용이 없기 때문에 사용할 수 있는 다른 핸드셰이크 후 메시지인 NewSessionTicket 및 KeyUpdate를 정의합니다. 새로운 유형의 TLS 메시지 사용이 애플리케이션 계층 프로토콜과의 상호 작용에 의존하지 않는 한 해당 TLS 메시지는 핸드셰이크가 완료된 후에 전송될 수 있습니다.

\[RFC8470\]의 지침을 준수하는 경우 TLS 초기 데이터를 사용하여 요청을 보낼 수 있습니다. 클라이언트는 모든 서버 설정에 대한 초기 값을 가정하여 초기 데이터로 요청을 보냅니다.

---
## **10.  Security Considerations**

이 프로토콜의 많은 보안 속성을 제공하려면 TLS를 사용해야 합니다. 이 섹션의 많은 주장은 섹션 9.2에 설명된 대로 TLS가 사용되지 않는 한 유지되지 않습니다.

---
### **10.1.  Server Authority**

HTTP/2는 서버가 주어진 응답을 제공할 권한이 있는지 여부를 결정하기 위해 HTTP 권한 정의에 의존합니다\(\[HTTP\]의 섹션 4.3 참조\). 이는 "http" URI 체계에 대한 로컬 이름 확인과 "https" 체계에 대한 인증된 서버 ID에 의존합니다.

---
### **10.2.  Cross-Protocol Attacks**

교차 프로토콜 공격에서 공격자는 클라이언트가 다른 프로토콜을 이해하는 서버를 향해 한 프로토콜로 트랜잭션을 시작하도록 합니다. 공격자는 트랜잭션이 두 번째 프로토콜에서 유효한 트랜잭션으로 표시되도록 할 수 있습니다. 웹 컨텍스트의 기능과 결합하여 개인 네트워크에서 제대로 보호되지 않는 서버와 상호 작용하는 데 사용할 수 있습니다.

HTTP/2용 ALPN 식별자를 사용하여 TLS 핸드셰이크를 완료하는 것은 프로토콜 간 공격에 대한 충분한 보호로 간주될 수 있습니다. ALPN은 서버가 다른 TLS 기반 프로토콜에 대한 공격을 방지하는 HTTP/2를 진행할 의사가 있다는 긍정적인 표시를 제공합니다.

TLS의 암호화는 공격자가 일반 텍스트 프로토콜에 대한 프로토콜 간 공격에 사용될 수 있는 데이터를 제어하기 어렵게 만듭니다.

HTTP/2의 일반 텍스트 버전은 프로토콜 간 공격에 대해 최소한의 보호 기능을 제공합니다. 연결 머리말\(섹션 3.4\)에는 HTTP/1.1 서버를 혼동하도록 설계된 문자열이 포함되어 있지만 다른 프로토콜에 대해서는 특별한 보호 기능이 제공되지 않습니다.

---
### **10.3.  Intermediary Encapsulation Attacks**

HPACK은 다른 HTTP 버전에서 구분 기호로 처리될 수 있는 필드 이름과 값의 인코딩을 허용합니다. HTTP/2 요청 또는 응답을 변환하는 중개자는 메시지를 다른 HTTP 버전으로 변환하기 전에 섹션 8.2의 규칙에 따라 필드의 유효성을 검사해야 합니다. 잘못된 구분 기호가 포함된 필드를 번역하면 수신자가 메시지를 잘못 해석하게 되어 공격자가 이를 악용할 수 있습니다.

섹션 8.2에는 의사 헤더 필드의 유효성 검사에 대한 특정 규칙이 포함되어 있지 않습니다. 이러한 필드의 값을 사용하는 경우 추가 유효성 검사가 필요합니다. 이는 ":scheme", ":authority" 및 ":path"가 결합되어 단일 URI 문자열 \[RFC3986\]을 형성하는 경우 특히 중요합니다. 요청 라인을 구성하기 위해 해당 URI 또는 ​​":path"가 ":method"와 결합될 때 비슷한 문제가 발생할 수 있습니다\(\[HTTP/1.1\]의 섹션 3에서처럼\). 입력 값이 완전히 검증되지 않으면 단순 연결은 안전하지 않습니다.

중개자는 다른 이유로 잘못된 필드 이름이나 값이 포함된 필드, 특히 \[HTTP\] 섹션 5의 HTTP ABNF 문법을 따르지 않는 필드를 거부할 수 있습니다. 섹션 8.2에서 요구하는 최소값 이외의 필드 검증을 수행하지 않는 중개자는 잘못된 필드 이름이나 값이 포함된 메시지를 전달할 수 있습니다.

전달하기 전에 제거가 필요한 필드를 수신하는 중개자\(\[HTTP\]의 섹션 7.6.1 참조\)는 메시지를 전달할 때 해당 헤더 필드를 제거하거나 교체해야 합니다. 또한 중개자는 메시지의 형식이 올바른지 확인하기 위해 Content-Length 필드가 포함된 메시지를 전달할 때 주의를 기울여야 합니다\(섹션 8.1.1\). 이렇게 하면 메시지가 어느 시점에서든 HTTP/1.1로 변환되면 프레임이 올바르게 지정됩니다.

---
### **10.4.  Cacheability of Pushed Responses**

푸시된 응답에는 클라이언트의 명시적인 요청이 없습니다. 요청은 PUSH\_PROMISE 프레임에서 서버에 의해 제공됩니다.

Push된 응답에 대한 캐싱은 Cache-Control 헤더 필드에 원본 서버가 제공하는 지침에 따라 가능합니다. 그러나 단일 서버가 둘 이상의 테넌트를 호스팅하는 경우 문제가 발생할 수 있습니다. 예를 들어, 서버는 여러 사용자에게 각각 URI 공간의 작은 부분을 제공할 수 있습니다.

여러 테넌트가 동일한 서버에서 공간을 공유하는 경우 해당 서버는 테넌트가 권한이 없는 리소스 표현을 푸시할 수 없도록 해야 합니다. 이를 시행하지 않으면 테넌트가 캐시에서 제공되는 표현을 제공하여 권한 있는 테넌트가 제공하는 실제 표현을 재정의할 수 있습니다.

원본 서버가 신뢰할 수 없는 푸시된 응답\(섹션 10.1 참조\)을 사용하거나 캐시해서는 안 됩니다.

---
### **10.5.  Denial-of-Service Considerations**

HTTP/2 연결은 HTTP/1.1 연결보다 작동하기 위해 더 많은 리소스를 요구할 수 있습니다. 필드 섹션 압축과 흐름 제어는 모두 더 많은 양의 상태에 대한 약속에 따라 달라집니다. 이러한 기능을 설정하면 해당 기능에 대한 메모리 할당이 엄격하게 제한됩니다.

PUSH\_PROMISE 프레임 수는 동일한 방식으로 제한되지 않습니다. 서버 푸시를 수락하는 클라이언트는 "예약\(원격\)" 상태가 되도록 허용하는 스트림 수를 제한해야 합니다. 과도한 수의 서버 푸시 스트림은 ENHANCE\_YOUR\_CALM 유형의 스트림 오류\(섹션 5.4.2\)로 처리될 수 있습니다.

다수의 HTTP/2 구현이 서비스 거부 \[NFLX-2019-002\]에 취약한 것으로 밝혀졌습니다. 다음은 구현이 서비스 거부 공격을 받을 수 있는 알려진 방법 목록입니다.

\* 미해결 아웃바운드 프레임을 비효율적으로 추적하면 공격자가 많은 수의 프레임을 전송 대기열에 추가할 수 있는 경우 과부하가 발생할 수 있습니다. 피어는 여러 기술 중 하나를 사용하여 많은 수의 프레임을 생성할 수 있습니다.

- WINDOW\_UPDATE 프레임의 흐름 제어에 작은 증분을 제공하면 발신자가 많은 수의 DATA 프레임을 생성할 수 있습니다.

- PING 프레임에 응답하려면 엔드포인트가 필요합니다.

```text
      -  Each SETTINGS frame requires acknowledgment.
```

- 잘못된 요청\(또는 서버 푸시\)으로 인해 피어가 응답으로 RST\_STREAM 프레임을 보낼 수 있습니다.

\* 공격자는 HTTP/2 계층에서 대량의 흐름 제어 크레딧을 제공할 수 있지만 TCP 계층에서는 크레딧을 보류하여 프레임이 전송되지 않도록 할 수 있습니다. TCP 제한을 고려하지 않고 전송할 프레임을 구성하고 기억하는 엔드포인트는 리소스가 고갈될 수 있습니다.

\* 많은 수의 작거나 빈 프레임을 남용하여 피어가 프레임 헤더를 처리하는 데 시간을 소비하게 할 수 있습니다. 스트림 끝에서 빈 DATA 또는 CONTINUATION 프레임을 보내는 것과 같이 작은 프레임의 일부 사용은 완전히 합법적이므로 여기서 주의가 필요합니다.

\* SETTINGS 프레임을 남용하여 피어가 추가 처리 시간을 소비하게 할 수도 있습니다. 이는 무의미하게 설정을 변경하거나, 정의되지 않은 여러 설정을 보내거나, 동일한 프레임에서 동일한 설정을 여러 번 변경함으로써 수행될 수 있습니다.

\* PRIORITY 프레임을 사용하여 우선순위 재설정을 처리하려면 상당한 처리 시간이 필요할 수 있으며 많은 PRIORITY 프레임이 전송되면 과부하가 발생할 수 있습니다.

\* 필드 섹션 압축은 공격자가 처리 리소스를 낭비할 기회도 제공합니다. 잠재적인 남용에 대한 자세한 내용은 \[압축\]의 섹션 7을 참조하세요.

\* SETTINGS의 한도는 즉시 줄일 수 없으므로 엔드포인트는 새로운 한도를 초과할 수 있는 피어의 동작에 노출됩니다. 특히 연결을 설정한 직후 서버에서 설정한 제한은 클라이언트에 알려지지 않으며 명백한 프로토콜 위반 없이 초과될 수 있습니다.

설정 변경, 작은 프레임, 필드 섹션 압축 등 서비스 거부에 악용될 수 있는 대부분의 기능은 합법적인 용도로 사용됩니다. 이러한 기능은 불필요하게 또는 과도하게 사용될 때만 부담이 됩니다.

이러한 기능의 사용을 모니터링하지 않는 엔드포인트는 서비스 거부 위험에 노출됩니다. 구현에서는 이러한 기능의 사용을 추적하고 사용에 대한 제한을 설정해야 합니다\(SHOULD\). 엔드포인트는 의심스러운 활동을 ENHANCE\_YOUR\_CALM 유형의 연결 오류\(섹션 5.4.1\)로 처리할 수 있습니다.

---
#### **10.5.1.  Limits on Field Block Size**

큰 필드 블록\(섹션 4.3\)으로 인해 구현이 많은 양의 상태를 커밋할 수 있습니다. 라우팅에 중요한 필드 라인은 필드 블록의 끝 부분에 나타날 수 있으며, 이는 필드가 최종 목적지로 스트리밍되는 것을 방지합니다. 캐시 정확성 보장과 같은 이러한 순서 및 기타 이유는 엔드포인트가 전체 필드 블록을 버퍼링해야 할 수도 있음을 의미합니다. 필드 블록의 크기에는 엄격한 제한이 없으므로 일부 엔드포인트는 필드 블록에 사용 가능한 많은 양의 메모리를 커밋해야 할 수 있습니다.

엔드포인트는 SETTINGS\_MAX\_HEADER\_LIST\_SIZE를 사용하여 압축되지 않은 필드 블록의 크기에 적용될 수 있는 제한을 피어에게 알릴 수 있습니다. 이 설정은 단지 권고사항이므로 엔드포인트는 이 제한을 초과하는 필드 블록을 보내도록 선택할 수 있으며 요청이나 응답이 잘못된 형식으로 처리될 위험이 있습니다. 이 설정은 연결에만 적용되므로 모든 요청이나 응답에서 알 수 없는 더 낮은 제한이 있는 홉이 발생할 수 있습니다. 중개자는 다른 동료가 제시한 값을 전달하여 이 문제를 방지하려고 시도할 수 있지만 반드시 그렇게 해야 할 필요는 없습니다.

처리할 수 있는 것보다 더 큰 필드 블록을 수신하는 서버는 HTTP 431\(요청 헤더 필드가 너무 큼\) 상태 코드 \[RFC6585\]를 보낼 수 있습니다. 클라이언트는 처리할 수 없는 응답을 삭제할 수 있습니다. 연결이 닫히지 않는 한 일관된 연결 상태를 보장하기 위해 필드 블록을 처리해야 합니다.

---
#### **10.5.2.  CONNECT Issues**

CONNECT 메서드를 사용하면 프록시에 불균형적인 로드가 생성될 수 있습니다. 왜냐하면 스트림 생성은 TCP 연결 생성 및 유지 관리에 비해 상대적으로 저렴하기 때문입니다. 나가는 TCP 연결이 TIME\_WAIT 상태로 유지되므로 프록시는 CONNECT 요청을 전달하는 스트림을 닫은 후에도 TCP 연결을 위한 일부 리소스를 유지할 수도 있습니다. 따라서 프록시는 SETTINGS\_MAX\_CONCURRENT\_STREAMS에만 의존하여 CONNECT 요청에 사용되는 리소스를 제한할 수 없습니다.

---
### **10.6.  Use of Compression**

압축을 사용하면 공격자가 제어하는 ​​데이터와 동일한 컨텍스트에서 비밀 데이터를 압축할 때 공격자가 비밀 데이터를 복구할 수 있습니다. HTTP/2는 필드 라인의 압축을 가능하게 합니다\(섹션 4.3\). 다음 우려 사항은 HTTP 압축 콘텐츠 코딩\(\[HTTP\]의 섹션 8.4.1\) 사용에도 적용됩니다.

웹의 특성을 이용하는 압축에 대한 명백한 공격이 있습니다\(예: \[BREACH\]\). 공격자는 다양한 일반 텍스트가 포함된 여러 요청을 유도하여 각각의 결과 암호문 길이를 관찰합니다. 그러면 비밀에 대한 추측이 정확할 경우 길이가 더 짧아집니다.

보안 채널에서 통신하는 구현은 각 데이터 소스에 대해 별도의 압축 사전이 사용되지 않는 한 기밀 데이터와 공격자가 제어하는 ​​데이터를 모두 포함하는 콘텐츠를 압축해서는 안 됩니다. 데이터 소스를 안정적으로 결정할 수 없는 경우 압축을 사용하면 안 됩니다. TLS에서 제공하는 것과 같은 일반 스트림 압축은 HTTP/2와 함께 사용하면 안 됩니다\(섹션 9.2 참조\).

헤더 필드의 압축에 관한 추가 고려 사항은 \[COMPRESSION\]에 설명되어 있습니다.

---
### **10.7.  Use of Padding**

HTTP/2 내의 패딩은 TLS \[TLS13\]에서 제공하는 것과 같은 범용 패딩을 대체하기 위한 것이 아닙니다. 중복된 패딩은 역효과를 낳을 수도 있습니다. 올바른 적용은 채워지는 데이터에 대한 구체적인 지식이 있는지 여부에 따라 달라질 수 있습니다.

압축에 의존하는 공격을 완화하려면 대응책으로 패딩을 사용하는 것보다 압축을 비활성화하거나 제한하는 것이 더 나을 수 있습니다.

패딩은 프레임 콘텐츠의 정확한 크기를 모호하게 하는 데 사용될 수 있으며 HTTP 내의 특정 공격을 완화하기 위해 제공됩니다. 예를 들어 압축된 콘텐츠에 공격자가 제어하는 ​​일반 텍스트와 비밀 데이터가 모두 포함된 공격\(예: \[BREACH\]\)이 있습니다.

패딩을 사용하면 즉시 명백해 보이는 것보다 보호 효과가 떨어질 수 있습니다. 기껏해야 패딩은 공격자가 관찰해야 하는 프레임 수를 늘려 공격자가 길이 정보를 추론하는 것을 더 어렵게 만들 뿐입니다. 잘못 구현된 패딩 방식은 쉽게 패배할 수 있습니다. 특히, 예측 가능한 분포를 갖는 무작위 패딩은 보호 기능을 거의 제공하지 않습니다. 마찬가지로 프레임 페이로드를 고정 크기로 패딩하면 프레임 페이로드 크기가 고정 크기 경계를 넘을 때 정보가 노출됩니다. 이는 공격자가 일반 텍스트를 제어할 수 있는 경우 가능할 수 있습니다.

중개자는 DATA 프레임에 대한 패딩을 유지해야 하지만 HEADERS 및 PUSH\_PROMISE 프레임에 대한 패딩을 삭제할 수 있습니다. 중개자가 프레임 패딩 양을 변경하는 유효한 이유는 패딩이 제공하는 보호 기능을 향상시키기 위한 것입니다.

---
### **10.8.  Privacy Considerations**

HTTP/2의 여러 특성은 관찰자에게 시간이 지남에 따라 단일 클라이언트 또는 서버의 작업을 상호 연관시킬 수 있는 기회를 제공합니다. 여기에는 설정 값, 흐름 제어 창 관리 방식, 우선순위가 스트림에 할당되는 방식, 자극에 대한 반응 타이밍, 설정에 의해 제어되는 기능 처리 등이 포함됩니다.

이것이 행동에 관찰 가능한 차이를 생성하는 한, \[PRIVACY\]의 섹션 3.2에 정의된 대로 특정 클라이언트를 지문 채취하기 위한 기초로 사용될 수 있습니다.

단일 TCP 연결을 사용하는 HTTP/2의 기본 설정을 통해 사이트에서 사용자 활동의 상관 관계를 확인할 수 있습니다. 다양한 출처에 대한 연결을 재사용하면 해당 출처를 추적할 수 있습니다.

PING 및 SETTINGS 프레임은 즉각적인 응답을 요구하므로 엔드포인트에서 피어에 대한 대기 시간을 측정하는 데 사용할 수 있습니다. 이는 특정 시나리오에서 개인 정보 보호에 영향을 미칠 수 있습니다.

---
### **10.9.  Remote Timing Attacks**

원격 타이밍 공격은 비밀을 사용하는 요청을 처리할 때 서버가 소요하는 시간의 변화를 관찰하여 서버에서 비밀을 추출합니다. HTTP/2는 동시 요청 생성 및 처리를 지원하므로 공격자가 요청 처리가 시작되는 시점을 더 효과적으로 제어할 수 있습니다. 여러 HTTP/2 요청이 동일한 IP 패킷 또는 TLS 레코드에 포함될 수 있습니다. 따라서 HTTP/2는 요청 전달의 가변성을 제거하고 요청 순서와 응답 전달만 타이밍 가변성의 원인으로 남겨 원격 타이밍 공격을 보다 효율적으로 만들 수 있습니다.

처리 시간이 비밀 값에 좌우되지 않도록 하는 것이 모든 형태의 타이밍 공격에 대한 최선의 방어입니다.

---
## **11.  IANA Considerations**

이 HTTP/2 개정판은 \[RFC7540\]에 정의된 HTTP2-Settings 헤더 필드와 h2c 업그레이드 토큰을 더 이상 사용되지 않는 것으로 표시합니다.

\[RFC7540\]의 섹션 11에서는 PRI HTTP 메서드와 함께 h2 및 h2c ALPN 식별자를 등록했습니다. RFC 7540은 또한 프레임 유형, 설정 및 오류 코드에 대한 레지스트리를 설정했습니다. 이러한 등록 및 레지스트리는 HTTP/2에 적용되지만 이 문서에서 다시 정의되지는 않습니다.

IANA는 이 문서를 참조하기 위해 다음 레지스트리에서 RFC 7540에 대한 참조를 업데이트했습니다. "TLS ALPN\(Application-Layer Protocol Negotiation\) 프로토콜 ID", "HTTP/2 프레임 유형", "HTTP/2 설정", "HTTP/2 오류 코드' 및 'HTTP 메소드 레지스트리'를 참조하세요. PRI 방법 등록이 섹션 3.4를 참조하도록 업데이트되었습니다. 다른 모든 섹션 번호는 변경되지 않았습니다.

IANA는 RFC 7540에서 실험용으로 예약된 "HTTP/2 프레임 유형" 및 "HTTP/2 설정" 레지스트리 부분에 대한 정책을 변경했습니다. 레지스트리의 이러한 부분은 나머지 부분과 동일한 정책에 따라 작동해야 합니다. 각 레지스트리.

---
### **11.1.  HTTP2-Settings Header Field Registration**

이 섹션에서는 "HTTP\(Hypertext Transfer Protocol\) 필드 이름 레지스트리"의 \[RFC7540\] 섹션 11.5에 의해 등록된 HTTP2-Settings 헤더 필드를 더 이상 사용되지 않음으로 표시합니다. 이 기능은 제거되었습니다. 섹션 3.1을 참조하세요. \[HTTP\]의 섹션 18.4에서 요구하는 세부 정보를 포함하도록 등록이 업데이트됩니다.

```text
   Field Name:  HTTP2-Settings

   Status:  obsoleted
```

참조: \[RFC7540\]의 섹션 3.2.1

설명: 더 이상 사용되지 않음; 이 문서의 섹션 11.1을 참조하세요.

---
### **11.2.  The h2c Upgrade Token**

이 섹션에서는 "HTTP\(Hypertext Transfer Protocol\) 업그레이드 토큰 레지스트리"의 \[RFC7540\] 섹션 11.8에 의해 등록된 h2c 업그레이드 토큰을 더 이상 사용되지 않는 것으로 기록합니다. 이 기능은 제거되었습니다. 섹션 3.1을 참조하세요. 등록이 다음과 같이 업데이트됩니다.

```text
   Value:  h2c

   Description:  (OBSOLETE) Hypertext Transfer Protocol version 2
      (HTTP/2)

   Expected Version Tokens:  None
```

참조: 이 문서의 섹션 3.1

---
## **12.  References**
---
### **12.1.  Normative References**

```text
   [CACHING]  Fielding, R., Ed., Nottingham, M., Ed., and J. Reschke,
              Ed., "HTTP Caching", STD 98, RFC 9111,
              DOI 10.17487/RFC9111, June 2022,
              <https://www.rfc-editor.org/info/rfc9111>.

   [COMPRESSION]
              Peon, R. and H. Ruellan, "HPACK: Header Compression for
              HTTP/2", RFC 7541, DOI 10.17487/RFC7541, May 2015,
              <https://www.rfc-editor.org/info/rfc7541>.

   [COOKIE]   Barth, A., "HTTP State Management Mechanism", RFC 6265,
              DOI 10.17487/RFC6265, April 2011,
              <https://www.rfc-editor.org/info/rfc6265>.

   [HTTP]     Fielding, R., Ed., Nottingham, M., Ed., and J. Reschke,
              Ed., "HTTP Semantics", STD 97, RFC 9110,
              DOI 10.17487/RFC9110, June 2022,
              <https://www.rfc-editor.org/info/rfc9110>.

   [QUIC]     Iyengar, J., Ed. and M. Thomson, Ed., "QUIC: A UDP-Based
              Multiplexed and Secure Transport", RFC 9000,
              DOI 10.17487/RFC9000, May 2021,
              <https://www.rfc-editor.org/info/rfc9000>.

   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", BCP 14, RFC 2119,
              DOI 10.17487/RFC2119, March 1997,
              <https://www.rfc-editor.org/info/rfc2119>.

   [RFC3986]  Berners-Lee, T., Fielding, R., and L. Masinter, "Uniform
              Resource Identifier (URI): Generic Syntax", STD 66,
              RFC 3986, DOI 10.17487/RFC3986, January 2005,
              <https://www.rfc-editor.org/info/rfc3986>.

   [RFC8174]  Leiba, B., "Ambiguity of Uppercase vs Lowercase in RFC
              2119 Key Words", BCP 14, RFC 8174, DOI 10.17487/RFC8174,
              May 2017, <https://www.rfc-editor.org/info/rfc8174>.

   [RFC8422]  Nir, Y., Josefsson, S., and M. Pegourie-Gonnard, "Elliptic
              Curve Cryptography (ECC) Cipher Suites for Transport Layer
              Security (TLS) Versions 1.2 and Earlier", RFC 8422,
              DOI 10.17487/RFC8422, August 2018,
              <https://www.rfc-editor.org/info/rfc8422>.

   [RFC8470]  Thomson, M., Nottingham, M., and W. Tarreau, "Using Early
              Data in HTTP", RFC 8470, DOI 10.17487/RFC8470, September
              2018, <https://www.rfc-editor.org/info/rfc8470>.

   [TCP]      Postel, J., "Transmission Control Protocol", STD 7,
              RFC 793, DOI 10.17487/RFC0793, September 1981,
              <https://www.rfc-editor.org/info/rfc793>.

   [TLS-ALPN] Friedl, S., Popov, A., Langley, A., and E. Stephan,
              "Transport Layer Security (TLS) Application-Layer Protocol
              Negotiation Extension", RFC 7301, DOI 10.17487/RFC7301,
              July 2014, <https://www.rfc-editor.org/info/rfc7301>.

   [TLS-ECDHE]
              Rescorla, E., "TLS Elliptic Curve Cipher Suites with SHA-
              256/384 and AES Galois Counter Mode (GCM)", RFC 5289,
              DOI 10.17487/RFC5289, August 2008,
              <https://www.rfc-editor.org/info/rfc5289>.

   [TLS-EXT]  Eastlake 3rd, D., "Transport Layer Security (TLS)
              Extensions: Extension Definitions", RFC 6066,
              DOI 10.17487/RFC6066, January 2011,
              <https://www.rfc-editor.org/info/rfc6066>.

   [TLS12]    Dierks, T. and E. Rescorla, "The Transport Layer Security
              (TLS) Protocol Version 1.2", RFC 5246,
              DOI 10.17487/RFC5246, August 2008,
              <https://www.rfc-editor.org/info/rfc5246>.

   [TLS13]    Rescorla, E., "The Transport Layer Security (TLS) Protocol
              Version 1.3", RFC 8446, DOI 10.17487/RFC8446, August 2018,
              <https://www.rfc-editor.org/info/rfc8446>.

   [TLSBCP]   Sheffer, Y., Holz, R., and P. Saint-Andre,
              "Recommendations for Secure Use of Transport Layer
              Security (TLS) and Datagram Transport Layer Security
              (DTLS)", BCP 195, RFC 7525, DOI 10.17487/RFC7525, May
              2015, <https://www.rfc-editor.org/info/rfc7525>.
```

---
### **12.2.  Informative References**

```text
   [ALT-SVC]  Nottingham, M., McManus, P., and J. Reschke, "HTTP
              Alternative Services", RFC 7838, DOI 10.17487/RFC7838,
              April 2016, <https://www.rfc-editor.org/info/rfc7838>.

   [BREACH]   Gluck, Y., Harris, N., and A. Prado, "BREACH: Reviving the
              CRIME Attack", 12 July 2013,
              <https://breachattack.com/resources/
              BREACH%20-%20SSL,%20gone%20in%2030%20seconds.pdf>.

   [DNS-TERMS]
              Hoffman, P., Sullivan, A., and K. Fujiwara, "DNS
              Terminology", BCP 219, RFC 8499, DOI 10.17487/RFC8499,
              January 2019, <https://www.rfc-editor.org/info/rfc8499>.

   [HTTP-PRIORITY]
              Oku, K. and L. Pardue, "Extensible Prioritization Scheme
              for HTTP", RFC 9218, DOI 10.17487/RFC9218, June 2022,
              <https://www.rfc-editor.org/info/rfc9218>.

   [HTTP/1.1] Fielding, R., Ed., Nottingham, M., Ed., and J. Reschke,
              Ed., "HTTP/1.1", STD 99, RFC 9112, DOI 10.17487/RFC9112,
              June 2022, <https://www.rfc-editor.org/info/rfc9112>.

   [NFLX-2019-002]
              Netflix, "HTTP/2 Denial of Service Advisory", 13 August
              2019, <https://github.com/Netflix/security-
              bulletins/blob/master/advisories/third-party/2019-002.md>.

   [PRIVACY]  Cooper, A., Tschofenig, H., Aboba, B., Peterson, J.,
              Morris, J., Hansen, M., and R. Smith, "Privacy
              Considerations for Internet Protocols", RFC 6973,
              DOI 10.17487/RFC6973, July 2013,
              <https://www.rfc-editor.org/info/rfc6973>.

   [RFC1122]  Braden, R., Ed., "Requirements for Internet Hosts -
              Communication Layers", STD 3, RFC 1122,
              DOI 10.17487/RFC1122, October 1989,
              <https://www.rfc-editor.org/info/rfc1122>.

   [RFC3749]  Hollenbeck, S., "Transport Layer Security Protocol
              Compression Methods", RFC 3749, DOI 10.17487/RFC3749, May
              2004, <https://www.rfc-editor.org/info/rfc3749>.

   [RFC6125]  Saint-Andre, P. and J. Hodges, "Representation and
              Verification of Domain-Based Application Service Identity
              within Internet Public Key Infrastructure Using X.509
              (PKIX) Certificates in the Context of Transport Layer
              Security (TLS)", RFC 6125, DOI 10.17487/RFC6125, March
              2011, <https://www.rfc-editor.org/info/rfc6125>.

   [RFC6585]  Nottingham, M. and R. Fielding, "Additional HTTP Status
              Codes", RFC 6585, DOI 10.17487/RFC6585, April 2012,
              <https://www.rfc-editor.org/info/rfc6585>.

   [RFC7323]  Borman, D., Braden, B., Jacobson, V., and R.
              Scheffenegger, Ed., "TCP Extensions for High Performance",
              RFC 7323, DOI 10.17487/RFC7323, September 2014,
              <https://www.rfc-editor.org/info/rfc7323>.

   [RFC7540]  Belshe, M., Peon, R., and M. Thomson, Ed., "Hypertext
              Transfer Protocol Version 2 (HTTP/2)", RFC 7540,
              DOI 10.17487/RFC7540, May 2015,
              <https://www.rfc-editor.org/info/rfc7540>.

   [RFC8441]  McManus, P., "Bootstrapping WebSockets with HTTP/2",
              RFC 8441, DOI 10.17487/RFC8441, September 2018,
              <https://www.rfc-editor.org/info/rfc8441>.

   [RFC8740]  Benjamin, D., "Using TLS 1.3 with HTTP/2", RFC 8740,
              DOI 10.17487/RFC8740, February 2020,
              <https://www.rfc-editor.org/info/rfc8740>.

   [TALKING]  Huang, L., Chen, E., Barth, A., Rescorla, E., and C.
              Jackson, "Talking to Yourself for Fun and Profit", 2011,
              <https://www.adambarth.com/papers/2011/huang-chen-barth-
              rescorla-jackson.pdf>.
```

---
# **Appendix A.  Prohibited TLS 1.2 Cipher Suites**

HTTP/2 구현은 TLS 1.2를 사용하는 다음 암호 그룹의 협상을 INADEQUATE\_SECURITY 유형의 연결 오류\(섹션 5.4.1\)로 처리할 수 있습니다.

```text
   *  TLS_NULL_WITH_NULL_NULL
   *  TLS_RSA_WITH_NULL_MD5
   *  TLS_RSA_WITH_NULL_SHA
   *  TLS_RSA_EXPORT_WITH_RC4_40_MD5
   *  TLS_RSA_WITH_RC4_128_MD5
   *  TLS_RSA_WITH_RC4_128_SHA
   *  TLS_RSA_EXPORT_WITH_RC2_CBC_40_MD5
   *  TLS_RSA_WITH_IDEA_CBC_SHA
   *  TLS_RSA_EXPORT_WITH_DES40_CBC_SHA
   *  TLS_RSA_WITH_DES_CBC_SHA
   *  TLS_RSA_WITH_3DES_EDE_CBC_SHA
   *  TLS_DH_DSS_EXPORT_WITH_DES40_CBC_SHA
   *  TLS_DH_DSS_WITH_DES_CBC_SHA
   *  TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA
   *  TLS_DH_RSA_EXPORT_WITH_DES40_CBC_SHA
   *  TLS_DH_RSA_WITH_DES_CBC_SHA
   *  TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA
   *  TLS_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA
   *  TLS_DHE_DSS_WITH_DES_CBC_SHA
   *  TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA
   *  TLS_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA
   *  TLS_DHE_RSA_WITH_DES_CBC_SHA
   *  TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA
   *  TLS_DH_anon_EXPORT_WITH_RC4_40_MD5
   *  TLS_DH_anon_WITH_RC4_128_MD5
   *  TLS_DH_anon_EXPORT_WITH_DES40_CBC_SHA
   *  TLS_DH_anon_WITH_DES_CBC_SHA
   *  TLS_DH_anon_WITH_3DES_EDE_CBC_SHA
   *  TLS_KRB5_WITH_DES_CBC_SHA
   *  TLS_KRB5_WITH_3DES_EDE_CBC_SHA
   *  TLS_KRB5_WITH_RC4_128_SHA
   *  TLS_KRB5_WITH_IDEA_CBC_SHA
   *  TLS_KRB5_WITH_DES_CBC_MD5
   *  TLS_KRB5_WITH_3DES_EDE_CBC_MD5
   *  TLS_KRB5_WITH_RC4_128_MD5
   *  TLS_KRB5_WITH_IDEA_CBC_MD5
   *  TLS_KRB5_EXPORT_WITH_DES_CBC_40_SHA
   *  TLS_KRB5_EXPORT_WITH_RC2_CBC_40_SHA
   *  TLS_KRB5_EXPORT_WITH_RC4_40_SHA
   *  TLS_KRB5_EXPORT_WITH_DES_CBC_40_MD5
   *  TLS_KRB5_EXPORT_WITH_RC2_CBC_40_MD5
   *  TLS_KRB5_EXPORT_WITH_RC4_40_MD5
   *  TLS_PSK_WITH_NULL_SHA
   *  TLS_DHE_PSK_WITH_NULL_SHA
   *  TLS_RSA_PSK_WITH_NULL_SHA
   *  TLS_RSA_WITH_AES_128_CBC_SHA
   *  TLS_DH_DSS_WITH_AES_128_CBC_SHA
   *  TLS_DH_RSA_WITH_AES_128_CBC_SHA
   *  TLS_DHE_DSS_WITH_AES_128_CBC_SHA
   *  TLS_DHE_RSA_WITH_AES_128_CBC_SHA
   *  TLS_DH_anon_WITH_AES_128_CBC_SHA
   *  TLS_RSA_WITH_AES_256_CBC_SHA
   *  TLS_DH_DSS_WITH_AES_256_CBC_SHA
   *  TLS_DH_RSA_WITH_AES_256_CBC_SHA
   *  TLS_DHE_DSS_WITH_AES_256_CBC_SHA
   *  TLS_DHE_RSA_WITH_AES_256_CBC_SHA
   *  TLS_DH_anon_WITH_AES_256_CBC_SHA
   *  TLS_RSA_WITH_NULL_SHA256
   *  TLS_RSA_WITH_AES_128_CBC_SHA256
   *  TLS_RSA_WITH_AES_256_CBC_SHA256
   *  TLS_DH_DSS_WITH_AES_128_CBC_SHA256
   *  TLS_DH_RSA_WITH_AES_128_CBC_SHA256
   *  TLS_DHE_DSS_WITH_AES_128_CBC_SHA256
   *  TLS_RSA_WITH_CAMELLIA_128_CBC_SHA
   *  TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA
   *  TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA
   *  TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA
   *  TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA
   *  TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA
   *  TLS_DHE_RSA_WITH_AES_128_CBC_SHA256
   *  TLS_DH_DSS_WITH_AES_256_CBC_SHA256
   *  TLS_DH_RSA_WITH_AES_256_CBC_SHA256
   *  TLS_DHE_DSS_WITH_AES_256_CBC_SHA256
   *  TLS_DHE_RSA_WITH_AES_256_CBC_SHA256
   *  TLS_DH_anon_WITH_AES_128_CBC_SHA256
   *  TLS_DH_anon_WITH_AES_256_CBC_SHA256
   *  TLS_RSA_WITH_CAMELLIA_256_CBC_SHA
   *  TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA
   *  TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA
   *  TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA
   *  TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA
   *  TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA
   *  TLS_PSK_WITH_RC4_128_SHA
   *  TLS_PSK_WITH_3DES_EDE_CBC_SHA
   *  TLS_PSK_WITH_AES_128_CBC_SHA
   *  TLS_PSK_WITH_AES_256_CBC_SHA
   *  TLS_DHE_PSK_WITH_RC4_128_SHA
   *  TLS_DHE_PSK_WITH_3DES_EDE_CBC_SHA
   *  TLS_DHE_PSK_WITH_AES_128_CBC_SHA
   *  TLS_DHE_PSK_WITH_AES_256_CBC_SHA
   *  TLS_RSA_PSK_WITH_RC4_128_SHA
   *  TLS_RSA_PSK_WITH_3DES_EDE_CBC_SHA
   *  TLS_RSA_PSK_WITH_AES_128_CBC_SHA
   *  TLS_RSA_PSK_WITH_AES_256_CBC_SHA
   *  TLS_RSA_WITH_SEED_CBC_SHA
   *  TLS_DH_DSS_WITH_SEED_CBC_SHA
   *  TLS_DH_RSA_WITH_SEED_CBC_SHA
   *  TLS_DHE_DSS_WITH_SEED_CBC_SHA
   *  TLS_DHE_RSA_WITH_SEED_CBC_SHA
   *  TLS_DH_anon_WITH_SEED_CBC_SHA
   *  TLS_RSA_WITH_AES_128_GCM_SHA256
   *  TLS_RSA_WITH_AES_256_GCM_SHA384
   *  TLS_DH_RSA_WITH_AES_128_GCM_SHA256
   *  TLS_DH_RSA_WITH_AES_256_GCM_SHA384
   *  TLS_DH_DSS_WITH_AES_128_GCM_SHA256
   *  TLS_DH_DSS_WITH_AES_256_GCM_SHA384
   *  TLS_DH_anon_WITH_AES_128_GCM_SHA256
   *  TLS_DH_anon_WITH_AES_256_GCM_SHA384
   *  TLS_PSK_WITH_AES_128_GCM_SHA256
   *  TLS_PSK_WITH_AES_256_GCM_SHA384
   *  TLS_RSA_PSK_WITH_AES_128_GCM_SHA256
   *  TLS_RSA_PSK_WITH_AES_256_GCM_SHA384
   *  TLS_PSK_WITH_AES_128_CBC_SHA256
   *  TLS_PSK_WITH_AES_256_CBC_SHA384
   *  TLS_PSK_WITH_NULL_SHA256
   *  TLS_PSK_WITH_NULL_SHA384
   *  TLS_DHE_PSK_WITH_AES_128_CBC_SHA256
   *  TLS_DHE_PSK_WITH_AES_256_CBC_SHA384
   *  TLS_DHE_PSK_WITH_NULL_SHA256
   *  TLS_DHE_PSK_WITH_NULL_SHA384
   *  TLS_RSA_PSK_WITH_AES_128_CBC_SHA256
   *  TLS_RSA_PSK_WITH_AES_256_CBC_SHA384
   *  TLS_RSA_PSK_WITH_NULL_SHA256
   *  TLS_RSA_PSK_WITH_NULL_SHA384
   *  TLS_RSA_WITH_CAMELLIA_128_CBC_SHA256
   *  TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA256
   *  TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA256
   *  TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA256
   *  TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA256
   *  TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA256
   *  TLS_RSA_WITH_CAMELLIA_256_CBC_SHA256
   *  TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA256
   *  TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA256
   *  TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA256
   *  TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA256
   *  TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA256
   *  TLS_EMPTY_RENEGOTIATION_INFO_SCSV
   *  TLS_ECDH_ECDSA_WITH_NULL_SHA
   *  TLS_ECDH_ECDSA_WITH_RC4_128_SHA
   *  TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA
   *  TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA
   *  TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA
   *  TLS_ECDHE_ECDSA_WITH_NULL_SHA
   *  TLS_ECDHE_ECDSA_WITH_RC4_128_SHA
   *  TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA
   *  TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA
   *  TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA
   *  TLS_ECDH_RSA_WITH_NULL_SHA
   *  TLS_ECDH_RSA_WITH_RC4_128_SHA
   *  TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA
   *  TLS_ECDH_RSA_WITH_AES_128_CBC_SHA
   *  TLS_ECDH_RSA_WITH_AES_256_CBC_SHA
   *  TLS_ECDHE_RSA_WITH_NULL_SHA
   *  TLS_ECDHE_RSA_WITH_RC4_128_SHA
   *  TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA
   *  TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA
   *  TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA
   *  TLS_ECDH_anon_WITH_NULL_SHA
   *  TLS_ECDH_anon_WITH_RC4_128_SHA
   *  TLS_ECDH_anon_WITH_3DES_EDE_CBC_SHA
   *  TLS_ECDH_anon_WITH_AES_128_CBC_SHA
   *  TLS_ECDH_anon_WITH_AES_256_CBC_SHA
   *  TLS_SRP_SHA_WITH_3DES_EDE_CBC_SHA
   *  TLS_SRP_SHA_RSA_WITH_3DES_EDE_CBC_SHA
   *  TLS_SRP_SHA_DSS_WITH_3DES_EDE_CBC_SHA
   *  TLS_SRP_SHA_WITH_AES_128_CBC_SHA
   *  TLS_SRP_SHA_RSA_WITH_AES_128_CBC_SHA
   *  TLS_SRP_SHA_DSS_WITH_AES_128_CBC_SHA
   *  TLS_SRP_SHA_WITH_AES_256_CBC_SHA
   *  TLS_SRP_SHA_RSA_WITH_AES_256_CBC_SHA
   *  TLS_SRP_SHA_DSS_WITH_AES_256_CBC_SHA
   *  TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256
   *  TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384
   *  TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256
   *  TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384
   *  TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256
   *  TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384
   *  TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256
   *  TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384
   *  TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256
   *  TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384
   *  TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256
   *  TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384
   *  TLS_ECDHE_PSK_WITH_RC4_128_SHA
   *  TLS_ECDHE_PSK_WITH_3DES_EDE_CBC_SHA
   *  TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA
   *  TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA
   *  TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA256
   *  TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA384
   *  TLS_ECDHE_PSK_WITH_NULL_SHA
   *  TLS_ECDHE_PSK_WITH_NULL_SHA256
   *  TLS_ECDHE_PSK_WITH_NULL_SHA384
   *  TLS_RSA_WITH_ARIA_128_CBC_SHA256
   *  TLS_RSA_WITH_ARIA_256_CBC_SHA384
   *  TLS_DH_DSS_WITH_ARIA_128_CBC_SHA256
   *  TLS_DH_DSS_WITH_ARIA_256_CBC_SHA384
   *  TLS_DH_RSA_WITH_ARIA_128_CBC_SHA256
   *  TLS_DH_RSA_WITH_ARIA_256_CBC_SHA384
   *  TLS_DHE_DSS_WITH_ARIA_128_CBC_SHA256
   *  TLS_DHE_DSS_WITH_ARIA_256_CBC_SHA384
   *  TLS_DHE_RSA_WITH_ARIA_128_CBC_SHA256
   *  TLS_DHE_RSA_WITH_ARIA_256_CBC_SHA384
   *  TLS_DH_anon_WITH_ARIA_128_CBC_SHA256
   *  TLS_DH_anon_WITH_ARIA_256_CBC_SHA384
   *  TLS_ECDHE_ECDSA_WITH_ARIA_128_CBC_SHA256
   *  TLS_ECDHE_ECDSA_WITH_ARIA_256_CBC_SHA384
   *  TLS_ECDH_ECDSA_WITH_ARIA_128_CBC_SHA256
   *  TLS_ECDH_ECDSA_WITH_ARIA_256_CBC_SHA384
   *  TLS_ECDHE_RSA_WITH_ARIA_128_CBC_SHA256
   *  TLS_ECDHE_RSA_WITH_ARIA_256_CBC_SHA384
   *  TLS_ECDH_RSA_WITH_ARIA_128_CBC_SHA256
   *  TLS_ECDH_RSA_WITH_ARIA_256_CBC_SHA384
   *  TLS_RSA_WITH_ARIA_128_GCM_SHA256
   *  TLS_RSA_WITH_ARIA_256_GCM_SHA384
   *  TLS_DH_RSA_WITH_ARIA_128_GCM_SHA256
   *  TLS_DH_RSA_WITH_ARIA_256_GCM_SHA384
   *  TLS_DH_DSS_WITH_ARIA_128_GCM_SHA256
   *  TLS_DH_DSS_WITH_ARIA_256_GCM_SHA384
   *  TLS_DH_anon_WITH_ARIA_128_GCM_SHA256
   *  TLS_DH_anon_WITH_ARIA_256_GCM_SHA384
   *  TLS_ECDH_ECDSA_WITH_ARIA_128_GCM_SHA256
   *  TLS_ECDH_ECDSA_WITH_ARIA_256_GCM_SHA384
   *  TLS_ECDH_RSA_WITH_ARIA_128_GCM_SHA256
   *  TLS_ECDH_RSA_WITH_ARIA_256_GCM_SHA384
   *  TLS_PSK_WITH_ARIA_128_CBC_SHA256
   *  TLS_PSK_WITH_ARIA_256_CBC_SHA384
   *  TLS_DHE_PSK_WITH_ARIA_128_CBC_SHA256
   *  TLS_DHE_PSK_WITH_ARIA_256_CBC_SHA384
   *  TLS_RSA_PSK_WITH_ARIA_128_CBC_SHA256
   *  TLS_RSA_PSK_WITH_ARIA_256_CBC_SHA384
   *  TLS_PSK_WITH_ARIA_128_GCM_SHA256
   *  TLS_PSK_WITH_ARIA_256_GCM_SHA384
   *  TLS_RSA_PSK_WITH_ARIA_128_GCM_SHA256
   *  TLS_RSA_PSK_WITH_ARIA_256_GCM_SHA384
   *  TLS_ECDHE_PSK_WITH_ARIA_128_CBC_SHA256
   *  TLS_ECDHE_PSK_WITH_ARIA_256_CBC_SHA384
   *  TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_CBC_SHA256
   *  TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_CBC_SHA384
   *  TLS_ECDH_ECDSA_WITH_CAMELLIA_128_CBC_SHA256
   *  TLS_ECDH_ECDSA_WITH_CAMELLIA_256_CBC_SHA384
   *  TLS_ECDHE_RSA_WITH_CAMELLIA_128_CBC_SHA256
   *  TLS_ECDHE_RSA_WITH_CAMELLIA_256_CBC_SHA384
   *  TLS_ECDH_RSA_WITH_CAMELLIA_128_CBC_SHA256
   *  TLS_ECDH_RSA_WITH_CAMELLIA_256_CBC_SHA384
   *  TLS_RSA_WITH_CAMELLIA_128_GCM_SHA256
   *  TLS_RSA_WITH_CAMELLIA_256_GCM_SHA384
   *  TLS_DH_RSA_WITH_CAMELLIA_128_GCM_SHA256
   *  TLS_DH_RSA_WITH_CAMELLIA_256_GCM_SHA384
   *  TLS_DH_DSS_WITH_CAMELLIA_128_GCM_SHA256
   *  TLS_DH_DSS_WITH_CAMELLIA_256_GCM_SHA384
   *  TLS_DH_anon_WITH_CAMELLIA_128_GCM_SHA256
   *  TLS_DH_anon_WITH_CAMELLIA_256_GCM_SHA384
   *  TLS_ECDH_ECDSA_WITH_CAMELLIA_128_GCM_SHA256
   *  TLS_ECDH_ECDSA_WITH_CAMELLIA_256_GCM_SHA384
   *  TLS_ECDH_RSA_WITH_CAMELLIA_128_GCM_SHA256
   *  TLS_ECDH_RSA_WITH_CAMELLIA_256_GCM_SHA384
   *  TLS_PSK_WITH_CAMELLIA_128_GCM_SHA256
   *  TLS_PSK_WITH_CAMELLIA_256_GCM_SHA384
   *  TLS_RSA_PSK_WITH_CAMELLIA_128_GCM_SHA256
   *  TLS_RSA_PSK_WITH_CAMELLIA_256_GCM_SHA384
   *  TLS_PSK_WITH_CAMELLIA_128_CBC_SHA256
   *  TLS_PSK_WITH_CAMELLIA_256_CBC_SHA384
   *  TLS_DHE_PSK_WITH_CAMELLIA_128_CBC_SHA256
   *  TLS_DHE_PSK_WITH_CAMELLIA_256_CBC_SHA384
   *  TLS_RSA_PSK_WITH_CAMELLIA_128_CBC_SHA256
   *  TLS_RSA_PSK_WITH_CAMELLIA_256_CBC_SHA384
   *  TLS_ECDHE_PSK_WITH_CAMELLIA_128_CBC_SHA256
   *  TLS_ECDHE_PSK_WITH_CAMELLIA_256_CBC_SHA384
   *  TLS_RSA_WITH_AES_128_CCM
   *  TLS_RSA_WITH_AES_256_CCM
   *  TLS_RSA_WITH_AES_128_CCM_8
   *  TLS_RSA_WITH_AES_256_CCM_8
   *  TLS_PSK_WITH_AES_128_CCM
   *  TLS_PSK_WITH_AES_256_CCM
   *  TLS_PSK_WITH_AES_128_CCM_8
   *  TLS_PSK_WITH_AES_256_CCM_8
```

- | 참고: 이 목록은 등록된 TLS | \[RFC7540\]이 개발되었을 때의 암호 제품군입니다. 이 목록에는 | 임시 키 교환을 제공하지 않는 암호화 제품군 | 및 TLS null, 스트림 또는 블록을 기반으로 하는 것 | 암호 유형\(\[TLS12\]의 섹션 6.2.3에 정의됨\). | 이러한 속성을 가진 추가 암호 제품군은 | 한정된; 이는 명시적으로 금지되지 않습니다.

자세한 내용은 섹션 9.2.2를 참조하세요.

---
# **Appendix B.  Changes from RFC 7540**

이번 개정에는 다음과 같은 실질적인 변경 사항이 포함되어 있습니다.

\* TLS 1.3의 사용은 이 문서가 더 이상 사용되지 않는 \[RFC8740\]을 기반으로 정의되었습니다.

\* RFC 7540에 정의된 우선순위 체계는 더 이상 사용되지 않습니다. PRIORITY 프레임의 형식과 HEADERS 프레임의 우선 순위 필드에 대한 정의는 유지되었으며 PRIORITY 프레임을 보내고 받을 수 있는 시기를 관리하는 규칙도 있지만 이러한 필드의 의미는 RFC 7540에만 설명되어 있습니다. RFC 7540에서 성공하지 못했습니다. \[HTTP-PRIORITY\]에서 더 간단한 신호를 사용하는 것이 좋습니다.

\* HTTP/1.1 업그레이드 메커니즘은 더 이상 사용되지 않으며 이 문서에 더 이상 지정되지 않습니다. 일반 텍스트 HTTP/2 사용자가 대신 사전 지식 구현을 사용하기로 선택했기 때문에 널리 배포되지 않았습니다.

\* 필드 이름 및 값에 대한 유효성 검사 범위가 좁아졌습니다. 중개자에게 필수인 검증을 정확하게 정의하고, 400 시리즈 상태 코드 전송을 장려하도록 요청에 대한 오류 보고를 수정했습니다.

\* 실험용으로 예약된 설정 및 프레임 유형에 대한 코드 포인트 범위를 이제 일반 용도로 사용할 수 있습니다.

\* 금지된 연결별 헤더 필드가 보다 정확하고 포괄적으로 식별됩니다.

\* 호스트와 ":authority"는 더 이상 동의하지 않을 수 있습니다.

\* 설정 변경 후 동적 테이블 크기 업데이트 지침을 보내는 규칙은 섹션 4.3.1에 명시되어 있습니다.

편집상의 변경 사항도 포함됩니다. 특히, 용어 및 문서 구조의 변경은 핵심 HTTP 의미 체계\[HTTP\] 업데이트에 따른 것입니다. 이제 이러한 문서에는 421 상태 코드 또는 연결 병합과 같이 RFC 7540에서 처음 정의된 일부 개념이 포함되어 있습니다.

---
# **Acknowledgments**

이 문서에 대한 중요한 의견은 수년 동안 HTTP 작업 그룹에 기여한 많은 사람들의 공로입니다. \[RFC7540\]에는 기여에 대해 감사를 표할 만한 더 광범위한 사람들의 목록이 포함되어 있습니다.

---
# **Contributors**

Mike Belshe와 Roberto Peon은 이 문서의 기반이 되는 텍스트를 작성했습니다.

---
# **Authors' Addresses**

```text
   Martin Thomson (editor)
   Mozilla
   Australia
   Email: mt@lowentropy.net

   Cory Benfield (editor)
   Apple Inc.
   Email: cbenfield@apple.com
```
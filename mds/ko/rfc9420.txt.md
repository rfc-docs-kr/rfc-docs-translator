

```text
﻿

Internet Engineering Task Force (IETF)                         R. Barnes
Request for Comments: 9420                                         Cisco
Category: Standards Track                                  B. Beurdouche
ISSN: 2070-1721                                          Inria & Mozilla
                                                               R. Robert
                                                             Phoenix R&D
                                                             J. Millican
                                                          Meta Platforms
                                                                E. Omara
                                                                        
                                                          K. Cohn-Gordon
                                                    University of Oxford
                                                               July 2023

              The Messaging Layer Security (MLS) Protocol
```

---
# **Abstract**

메시징 응용 프로그램은 종단간 보안 메커니즘을 점점 더 많이 사용하여 메시지 전달에 관련된 서버가 아닌 통신하는 끝점에서만 메시지에 액세스할 수 있도록 합니다. 이러한 보호를 제공하기 위해 키를 설정하는 것은 두 명 이상의 클라이언트가 키에 동의해야 하지만 동시에 온라인 상태가 아닐 수 있는 그룹 채팅 설정에서 어려운 일입니다. 이 문서에서는 2에서 수천에 이르는 그룹에 대해 FS\(Forward Secrecy\) 및 PCS\(Post Compromise Security\)를 사용하여 효율적인 비동기 그룹 키 설정을 제공하는 키 설정 프로토콜을 지정합니다.

---
# **Status of This Memo**

이것은 인터넷 표준 추적 문서입니다.

이 문서는 IETF\(Internet Engineering Task Force\)의 제품입니다. 이는 IETF 커뮤니티의 합의를 나타냅니다. 공개 검토를 받았으며 IESG\(Internet Engineering Steering Group\)의 출판 승인을 받았습니다. 인터넷 표준에 대한 자세한 내용은 RFC 7841의 섹션 2에서 확인할 수 있습니다.

이 문서의 현재 상태, 오류 및 이에 대한 피드백 제공 방법에 대한 정보는 https://www.rfc-editor.org/info/rfc9420에서 얻을 수 있습니다.

---
# **Copyright Notice**

Copyright \(c\) 2023 IETF Trust 및 문서 작성자로 확인된 사람. 판권 소유.

이 문서는 이 문서의 발행일에 유효한 BCP 78 및 IETF 문서에 관한 IETF 트러스트의 법적 조항\(https://trustee.ietf.org/license-info\)의 적용을 받습니다. 이 문서와 관련된 귀하의 권리 및 제한 사항을 설명하므로 이 문서를 주의 깊게 검토하십시오. 이 문서에서 추출한 코드 구성요소는 Trust Legal Provisions의 섹션 4.e에 설명된 대로 개정된 BSD 라이센스 텍스트를 포함해야 하며 개정된 BSD 라이센스에 설명된 대로 보증 없이 제공됩니다.

---
# **Table of Contents**

```text
   1.  Introduction
   2.  Terminology
     2.1.  Presentation Language
       2.1.1.  Optional Value
       2.1.2.  Variable-Size Vector Length Headers
   3.  Protocol Overview
     3.1.  Cryptographic State and Evolution
     3.2.  Example Protocol Execution
     3.3.  External Joins
     3.4.  Relationships between Epochs
   4.  Ratchet Tree Concepts
     4.1.  Ratchet Tree Terminology
       4.1.1.  Ratchet Tree Nodes
       4.1.2.  Paths through a Ratchet Tree
     4.2.  Views of a Ratchet Tree
   5.  Cryptographic Objects
     5.1.  Cipher Suites
       5.1.1.  Public Keys
       5.1.2.  Signing
       5.1.3.  Public Key Encryption
     5.2.  Hash-Based Identifiers
     5.3.  Credentials
       5.3.1.  Credential Validation
       5.3.2.  Credential Expiry and Revocation
       5.3.3.  Uniquely Identifying Clients
   6.  Message Framing
     6.1.  Content Authentication
     6.2.  Encoding and Decoding a Public Message
     6.3.  Encoding and Decoding a Private Message
       6.3.1.  Content Encryption
       6.3.2.  Sender Data Encryption
   7.  Ratchet Tree Operations
     7.1.  Parent Node Contents
     7.2.  Leaf Node Contents
     7.3.  Leaf Node Validation
     7.4.  Ratchet Tree Evolution
     7.5.  Synchronizing Views of the Tree
     7.6.  Update Paths
     7.7.  Adding and Removing Leaves
     7.8.  Tree Hashes
     7.9.  Parent Hashes
       7.9.1.  Using Parent Hashes
       7.9.2.  Verifying Parent Hashes
   8.  Key Schedule
     8.1.  Group Context
     8.2.  Transcript Hashes
     8.3.  External Initialization
     8.4.  Pre-Shared Keys
     8.5.  Exporters
     8.6.  Resumption PSK
     8.7.  Epoch Authenticators
   9.  Secret Tree
     9.1.  Encryption Keys
     9.2.  Deletion Schedule
   10. Key Packages
     10.1.  KeyPackage Validation
   11. Group Creation
     11.1.  Required Capabilities
     11.2.  Reinitialization
     11.3.  Subgroup Branching
   12. Group Evolution
     12.1.  Proposals
       12.1.1.  Add
       12.1.2.  Update
       12.1.3.  Remove
       12.1.4.  PreSharedKey
       12.1.5.  ReInit
       12.1.6.  ExternalInit
       12.1.7.  GroupContextExtensions
       12.1.8.  External Proposals
     12.2.  Proposal List Validation
     12.3.  Applying a Proposal List
     12.4.  Commit
       12.4.1.  Creating a Commit
       12.4.2.  Processing a Commit
       12.4.3.  Adding Members to the Group
   13. Extensibility
     13.1.  Additional Cipher Suites
     13.2.  Proposals
     13.3.  Credential Extensibility
     13.4.  Extensions
     13.5.  GREASE
   14. Sequencing of State Changes
   15. Application Messages
     15.1.  Padding
     15.2.  Restrictions
     15.3.  Delayed and Reordered Application Messages
   16. Security Considerations
     16.1.  Transport Security
     16.2.  Confidentiality of Group Secrets
     16.3.  Confidentiality of Sender Data
     16.4.  Confidentiality of Group Metadata
       16.4.1.  GroupID, Epoch, and Message Frequency
       16.4.2.  Group Extensions
       16.4.3.  Group Membership
     16.5.  Authentication
     16.6.  Forward Secrecy and Post-Compromise Security
     16.7.  Uniqueness of Ratchet Tree Key Pairs
     16.8.  KeyPackage Reuse
     16.9.  Delivery Service Compromise
     16.10. Authentication Service Compromise
     16.11. Additional Policy Enforcement
     16.12. Group Fragmentation by Malicious Insiders
   17. IANA Considerations
     17.1.  MLS Cipher Suites
     17.2.  MLS Wire Formats
     17.3.  MLS Extension Types
     17.4.  MLS Proposal Types
     17.5.  MLS Credential Types
     17.6.  MLS Signature Labels
     17.7.  MLS Public Key Encryption Labels
     17.8.  MLS Exporter Labels
     17.9.  MLS Designated Expert Pool
     17.10. The "message/mls" Media Type
   18. References
     18.1.  Normative References
     18.2.  Informative References
   Appendix A.  Protocol Origins of Example Trees
   Appendix B.  Evolution of Parent Hashes
   Appendix C.  Array-Based Trees
   Appendix D.  Link-Based Trees
   Contributors
   Authors' Addresses
```

---
## **1.  Introduction**

서로에게 암호화된 메시지를 보내려는 사용자 그룹은 공유 대칭 암호화 키를 파생시키는 방법이 필요합니다. 두 당사자의 경우 이 문제가 철저히 연구되었으며 Double Ratchet이 공통 솔루션 \[DoubleRatchet\] \[Signal\]으로 등장했습니다. Double Ratchet을 구현하는 채널은 세분화된 순방향 비밀성과 사후 손상 보안을 누리지만 그럼에도 불구하고 저대역폭 네트워크에서 많이 사용하기에 충분히 효율적입니다.

크기가 2보다 큰 그룹의 경우 일반적인 전략은 기존 1:1 보안 채널을 통해 대칭 "발신자 키"를 배포한 다음 각 구성원이 자신의 발신자 키로 암호화된 그룹에 메시지를 보내는 것입니다. 한편으로 발신자 키를 사용하면 개별 메시지의 쌍별 전송에 비해 효율성이 향상되고 순방향 보안이 제공됩니다\(해시 래칫 추가\). 반면에 발신자 키로 손상 후 보안을 달성하는 것은 어렵기 때문에 그룹 크기의 제곱으로 확장되는 많은 키 업데이트 메시지가 필요합니다. 보낸 사람 키를 알게 된 공격자는 종종 해당 구성원의 메시지를 무한정 수동적으로 도청할 수 있습니다. 새 발신자 키를 생성하고 배포하면 해당 발신자에 대한 일종의 사후 보안 보안이 제공됩니다. 그러나 그룹 크기에 따라 선형적으로 확장되는 계산 및 통신 리소스가 필요합니다.

이 문서에서는 순방향 보안 및 손상 후 보안을 통해 비동기 그룹 키잉을 가능하게 하는 트리 구조 기반 프로토콜을 설명합니다. "비동기 래칫 트리"\[ART\]에 대한 이전 작업을 기반으로 여기에 제시된 프로토콜은 트리 구조에 대한 비동기 키 캡슐화 메커니즘을 사용합니다. 이 메커니즘을 통해 그룹 구성원은 그룹 크기의 로그로 확장되는 비용으로 공유 키를 파생하고 업데이트할 수 있습니다.

---
## **2.  Terminology**

키워드 "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY" 및 "OPTIONAL" "는 BCP 14 \[RFC2119\] \[RFC8174\]에 설명된 대로 여기에 표시된 것처럼 모두 대문자로 표시되는 경우에만 해석됩니다.\(MUST NOT\)

클라이언트: 이 프로토콜을 사용하여 다른 클라이언트와 공유 암호화 상태를 설정하는 에이전트입니다. 클라이언트는 보유한 암호화 키로 정의됩니다.

그룹: 그룹은 주어진 시간에 공통 비밀 값을 공유하는 클라이언트의 논리적 모음을 나타냅니다. 그 상태는 각 시대가 이전 시대에 의존하는 시대의 선형 시퀀스로 표현됩니다.

에포크\(Epoch\): 인증된 특정 클라이언트 집합이 공유 암호화 상태를 유지하는 그룹의 상태입니다.

구성원: 그룹의 공유 상태에 포함되어 그룹의 비밀에 액세스할 수 있는 클라이언트입니다.

키 패키지: 해당 클라이언트를 암호화하는 데 사용할 수 있는 HPKE\(하이브리드 공개 키 암호화\) \[RFC9180\] 공개 키를 포함하여 클라이언트의 ID 및 기능을 설명하는 서명된 개체입니다. 다른 클라이언트는 클라이언트의 KeyPackage를 사용하여 클라이언트를 새 그룹에 소개할 수 있습니다.

그룹 컨텍스트: 그룹의 공유된 공개 상태를 요약하는 개체입니다. 그룹 컨텍스트는 일반적으로 새 구성원이 그룹에 가입할 수 있도록 제공되는 서명된 GroupInfo 메시지로 배포됩니다.

서명 키: 메시지 발신자를 인증하는 데 사용되는 서명 키 쌍입니다.

제안: 구성원 추가 또는 제거와 같이 그룹에 대한 변경을 제안하는 메시지입니다.

커밋: 일련의 제안에서 제안된 그룹에 대한 변경 사항을 구현하는 메시지입니다.

PublicMessage: 보낸 사람이 서명하고 특정 시대의 그룹 구성원에서 오는 것으로 인증되었지만 암호화되지 않은 MLS 프로토콜 메시지입니다.

PrivateMessage: 보낸 사람이 서명한 MLS 프로토콜 메시지로, 특정 시대의 그룹 구성원에서 오는 것으로 인증되고 해당 시대의 그룹 구성원에게 기밀이 되도록 암호화됩니다.

핸드셰이크 메시지: 애플리케이션 데이터와 달리 MLS 제안 또는 커밋 개체를 전달하는 PublicMessage 또는 PrivateMessage입니다.

애플리케이션 메시지: 애플리케이션 데이터를 전달하는 PrivateMessage.

트리 계산에 특정한 용어는 섹션 4.1에 설명되어 있습니다.

일반적으로 대칭 값은 "키" 또는 "비밀"이라고도 합니다. 두 용어 모두 클라이언트에게 기밀로 유지되어야 하는 값을 나타냅니다. 개별 값에 레이블을 지정할 때 일반적으로 추가 비밀 값을 파생하는 데 사용되는 값을 나타내기 위해 "비밀"을 사용하고 HMAC\(해시 메시지 인증 코드\) 또는 AEAD\(관련 데이터로 인증된 암호화\) 알고리즘.\(MUST\)

PublicMessage 및 PrivateMessage 형식은 섹션 6에 정의되어 있습니다. 순방향 보안 및 손상 후 보안과 같은 보안 개념은 섹션 16에 정의되어 있습니다.

섹션 13.5에 자세히 설명된 대로 MLS는 확장성을 유지하기 위해 "GREASE\(Generate Random Extensions And Sustain Extensibility\)" 접근 방식을 사용합니다. 여기서 발신자는 수신자가 알 수 없는 값을 무시해야 하는 필드에 임의의 값을 삽입합니다. 이 목적을 위한 특정 "GREASE 값"은 적절한 IANA 레지스트리에 등록됩니다.

---
### **2.1.  Presentation Language**

프로토콜 메시지의 구조를 설명하기 위해 TLS 프레젠테이션 언어\[RFC8446\]를 사용합니다. 기본 구문 외에도 두 가지 추가 기능, 즉 필드를 선택적으로 사용할 수 있는 기능과 벡터가 가변 크기 길이 헤더를 가질 수 있는 기능을 추가합니다.

---
#### **2.1.1.  Optional Value**

선택적 값은 존재 신호 옥텟으로 인코딩되며, 존재하는 경우 값 자체가 뒤따릅니다. 디코딩할 때 0 또는 1 이외의 값을 가진 프레즌스 옥텟은 잘못된 형식으로 거부되어야 합니다\(MUST\).\(MUST\)

```text
   struct {
       uint8 present;
       select (present) {
           case 0: struct{};
           case 1: T value;
       };
   } optional<T>;
```

---
#### **2.1.2.  Variable-Size Vector Length Headers**

TLS 프리젠테이션 언어에서 벡터는 길이가 접두어로 붙은 일련의 인코딩된 요소로 인코딩됩니다. 길이 필드는 인코딩된 요소 시퀀스의 최소 및 최대 길이를 지정하여 고정된 크기를 설정합니다.

MLS에는 크기가 상당한 범위에 따라 달라지는 여러 벡터가 있습니다. 따라서 고정 크기 길이 필드를 사용하는 대신 \[RFC9000\]의 섹션 16에 설명된 가변 길이 정수 인코딩을 사용하여 가변 크기 길이를 사용합니다. 여기서는 최소 크기 인코딩이 필요하다는 점만 다릅니다. 최소값과 최대값을 표시하는 대신 벡터 설명에는 단순히 V가 포함됩니다. 예를 들면 다음과 같습니다.

```text
   struct {
       uint32 fixed<0..255>;
       opaque variable<V>;
   } StructWithVectors;
```

이러한 벡터는 0바이트에서 2^30바이트 길이의 값을 나타낼 수 있습니다. 가변 길이 정수 인코딩은 정수 인코딩 길이의 밑이 2인 로그를 바이트 단위로 인코딩하기 위해 첫 번째 바이트의 최상위 2비트를 예약합니다. 정수 값은 전체 값이 네트워크 바이트 순서가 되도록 나머지 비트에서 인코딩됩니다. 인코딩된 값은 값을 나타내는 데 필요한 최소 비트 수를 사용해야 합니다. 디코딩할 때 필요한 것보다 더 많은 비트를 사용하는 값은 잘못된 형식으로 처리되어야 합니다.\(MUST, MUST\)

이는 정수가 1, 2 또는 4바이트로 인코딩되고 각각 6, 14 또는 30비트 값을 인코딩할 수 있음을 의미합니다.

```text
          +========+=========+=============+=======+============+
          | Prefix | Length  | Usable Bits | Min   | Max        |
          +========+=========+=============+=======+============+
          | 00     | 1       | 6           | 0     | 63         |
          +--------+---------+-------------+-------+------------+
          | 01     | 2       | 14          | 64    | 16383      |
          +--------+---------+-------------+-------+------------+
          | 10     | 4       | 30          | 16384 | 1073741823 |
          +--------+---------+-------------+-------+------------+
          | 11     | invalid | -           | -     | -          |
          +--------+---------+-------------+-------+------------+

                   Table 1: Summary of Integer Encodings
```

접두사 "11"로 시작하는 벡터는 유효하지 않으며 거부되어야 합니다.\(MUST\)

예를 들어:

\* 4바이트 길이 값 0x9d7f3e7d는 494878333으로 디코딩됩니다.

\* 2바이트 길이 값 0x7bbd는 15293으로 디코딩됩니다.

\* 싱글바이트 길이 값 0x25는 37로 디코딩됩니다.

다음 그림은 \[RFC9000\]에 제공된 의사 코드를 조정하여 최소 길이 인코딩에 대한 검사를 추가합니다.

```text
   ReadVarint(data):
     // The length of variable-length integers is encoded in the
     // first two bits of the first byte.
     v = data.next_byte()
     prefix = v >> 6
     if prefix == 3:
       raise Exception('invalid variable length integer prefix')

     length = 1 << prefix

     // Once the length is known, remove these bits and read any
     // remaining bytes.
     v = v & 0x3f
     repeat length-1 times:
       v = (v << 8) + data.next_byte()

     // Check if the value would fit in half the provided length.
     if prefix >= 1 && v < (1 << (8*(length/2) - 2)):
       raise Exception('minimum encoding was not used')

     return v
```

벡터 길이에 가변 크기 정수를 사용하면 벡터가 최대 2^30바이트까지 매우 커질 수 있습니다. 구현 시 벡터가 사용 가능한 스토리지를 오버플로하지 않도록 주의해야 합니다. 잠재적인 상호 운용성 문제의 디버깅을 용이하게 하기 위해 구현은 이러한 오버플로 조건이 발생할 때 명확한 오류를 제공해야 합니다\(SHOULD\).\(SHOULD\)

---
## **3.  Protocol Overview**

MLS는 \[MLS-ARCH\]에 설명된 컨텍스트에서 작동하도록 설계되었습니다. 특히 다음과 같은 서비스가 제공되는 것으로 가정합니다.

\* 그룹 구성원이 다른 그룹 구성원이 제시한 자격 증명을 인증할 수 있게 해주는 인증 서비스\(AS\).

\* 프로토콜의 참가자 간에 MLS 메시지를 라우팅하는 배달 서비스\(DS\).

MLS는 신뢰할 수 있는 AS를 가정하지만 대체로 신뢰할 수 없는 DS를 가정합니다. 섹션 16.10은 AS의 손상 또는 오작동의 영향을 설명합니다. MLS는 DS가 손상된 경우에도 그룹 데이터의 기밀성과 무결성을 보호하도록 설계되었습니다. 일반적으로 DS는 메시지를 안정적으로 전달하는 것으로만 예상됩니다. 섹션 16.9는 DS의 손상 또는 오작동의 영향을 설명합니다.

MLS의 핵심 기능은 지속적인 그룹 인증 키 교환\(AKE\)입니다. 다른 인증된 키 교환 프로토콜\(예: TLS\)과 마찬가지로 프로토콜의 참가자는 공통 비밀 값에 동의하고 각 참가자는 다른 참가자의 신원을 확인할 수 있습니다. 그 비밀은 MLS 프레이밍 계층을 사용하여 그룹의 한 참가자에서 다른 참가자에게 보낸 메시지를 보호하는 데 사용하거나 다른 프로토콜과 함께 사용하기 위해 내보낼 수 있습니다. MLS는 프로토콜에 2명 이상의 참가자가 있을 수 있다는 의미에서 그룹 AKE를 제공하고 프로토콜의 참가자 집합이 시간이 지남에 따라 변경될 수 있다는 의미에서 연속적인 그룹 AKE를 제공합니다.

MLS의 핵심 구성 원칙은 \_groups\_ 및 \_epochs\_입니다. 그룹은 주어진 시간에 공통 비밀 값을 공유하는 클라이언트의 논리적 모음을 나타냅니다. 그룹의 역사는 시대의 선형 시퀀스로 나뉩니다. 각 epoch에서 인증된 \_members\_ 집합은 해당 epoch의 그룹 구성원에게만 알려진 \_epoch secret\_에 동의합니다. 그룹에 포함된 구성원 집합은 한 에포크에서 다음 에포크로 변경될 수 있으며 MLS는 현재 에포크의 구성원만 에포크 암호에 액세스할 수 있도록 합니다. epoch 비밀에서 구성원은 메시지 암호화, 그룹 구성원 인증 등을 위한 추가 공유 비밀을 파생합니다.

MLS 그룹의 생성자는 프로토콜 상호 작용 없이 일방적으로 그룹의 첫 번째 시대를 만듭니다. 그 후 그룹 구성원은 MLS 메시지를 교환하여 한 시대에서 다른 시대로 공유된 암호화 상태를 발전시킵니다.

\* \_KeyPackage\_ 개체는 클라이언트의 기능을 설명하고 클라이언트를 그룹에 추가하는 데 사용할 수 있는 키를 제공합니다.

\* \_제안\_ 메시지는 구성원 추가 또는 제거와 같은 다음 에포크에서 변경해야 할 사항을 제안합니다.

\* \_Commit\_ 메시지는 제안 모음을 구현하도록 그룹 구성원에게 지시함으로써 새로운 시대를 시작합니다.

\* \_Welcome\_ 메시지는 그룹에 새 구성원이 추가되었거나 자신을 그룹에 추가하려는 에포크에 대한 상태를 초기화하기 위한 정보를 그룹에 제공합니다.

KeyPackage 및 Welcome 메시지는 그룹을 시작하거나 새 구성원을 소개하는 데 사용되므로 그룹 구성원과 아직 그룹에 속하지 않은 클라이언트 간에 교환됩니다. 클라이언트는 DS를 통해 KeyPackage를 게시하므로 다른 클라이언트가 이를 그룹에 추가할 수 있습니다. 그룹 구성원이 그룹에 새 구성원을 추가하려는 경우 새 구성원의 KeyPackage를 사용하여 추가하고 새 구성원이 로컬 상태를 초기화할 수 있는 환영 메시지를 구성합니다.

제안 및 커밋 메시지는 그룹의 한 구성원에서 다른 구성원에게 전송됩니다. MLS는 그룹 내에서 메시지를 보내기 위한 공통 프레이밍 계층을 제공합니다. \_PublicMessage\_는 암호화되지 않은 제안 및 커밋 메시지에 대한 발신자 인증을 제공합니다. \_PrivateMessage\_는 제안/커밋 메시지와 애플리케이션 데이터 모두에 대한 암호화 및 인증을 제공합니다.

---
### **3.1.  Cryptographic State and Evolution**

MLS의 핵심에 있는 암호화 상태는 세 가지 책임 영역으로 나뉩니다.

```text
                          .-    ...    -.
                         |               |
                         |       |       |
                         |       |       | Key Schedule
                         |       V       |
                         |  epoch_secret |
.                        |       |       |                             .
|\ Ratchet               |       |       |                     Secret /|
| \ Tree                 |       |       |                      Tree / |
|  \                     |       |       |                          /  |
|   \                    |       V       |                         /   |
|    +--> commit_secret --> epoch_secret --> encryption_secret -->+    |
|   /                    |       |       |                         \   |
|  /                     |       |       |                          \  |
| /                      |       |       |                           \ |
|/                       |       |       |                            \|
'                        |       V       |                             '
                         |  epoch_secret |
                         |       |       |
                         |       |       |
                         |       V       |
                         |               |
                          '-    ...    -'

              Figure 1: Overview of MLS Group Evolution
```

\* 그룹 구성원을 나타내는 \_래칫 트리\_는 그룹 구성원이 서로를 인증하고 메시지를 그룹의 하위 집합으로 효율적으로 암호화하는 방법을 제공합니다. 각 시대에는 고유한 래칫 트리가 있습니다. 그것은 \_key schedule\_을 시드합니다.

\* \_key schedule\_은 epoch에서 epoch로 진행하는 데 사용되는 키 파생 체인\(주로 \_init\_secret\_ 및 \_epoch\_secret\_ 사용\)과 다양한 기타 비밀의 파생을 설명합니다\(표 4 참조\). 예를 들어:

- - epoch에 대한 비밀 트리를 초기화하는 데 사용되는 \_encryption secret\_입니다.

- - 다른 프로토콜이 MLS를 일반 인증 그룹 키 교환으로 활용할 수 있도록 허용하는 \_exporter secret\_.

- - 하위 그룹 또는 후속 그룹을 생성할 때와 같이 구성원이 그룹의 멤버 자격을 증명하는 데 사용할 수 있는 \_재개 비밀\_입니다.

\* 메시지 암호화 및 인증을 위해 그룹 구성원이 사용하는 공유 비밀을 나타내는 키 일정에서 파생된 \_비밀 트리\_입니다. 각 시대에는 고유한 비밀 트리가 있습니다.

그룹의 각 구성원은 그룹 상태의 이러한 구성 요소에 대한 부분 보기를 유지 관리합니다. MLS 메시지는 이러한 보기를 초기화하고 그룹이 에포크 간에 전환할 때 동기화 상태를 유지하는 데 사용됩니다.

각각의 새로운 시대는 Commit 메시지로 시작됩니다. 커밋은 그룹의 기존 구성원에게 일련의 제안을 적용하여 래칫 트리의 보기를 업데이트하도록 지시하고 업데이트된 래칫 트리를 사용하여 그룹에 새로운 엔트로피를 배포합니다. 이 새로운 엔트로피는 새로운 시대의 구성원에게만 제공되며 제거된 구성원에게는 제공되지 않습니다. 따라서 커밋은 epoch secret이 현재 epoch의 멤버에게 기밀이라는 속성을 유지합니다.

하나 이상의 구성원을 그룹에 추가하는 각 커밋에 대해 하나 이상의 해당 환영 메시지가 있습니다. 각 환영 메시지는 새 구성원에게 주요 일정 및 래칫 트리의 보기를 초기화하는 데 필요한 정보를 제공하여 이러한 보기가 이 시대에 그룹의 다른 구성원이 보유한 보기와 일치하도록 합니다.

---
### **3.2.  Example Protocol Execution**

그룹의 수명에는 세 가지 주요 작업이 있습니다.

```text
   *  Adding a member, initiated by a current member;
```

\* 트리에서 구성원을 나타내는 키 업데이트 그리고

\* 회원 탈퇴.

이러한 각 작업은 해당 유형\(추가/업데이트/제거\)의 메시지를 전송하여 "제안"됩니다. 그러나 그룹에 새로운 엔트로피를 제공하기 위해 Commit 메시지가 전송될 때까지 그룹의 상태는 변경되지 않습니다. 이 섹션에서는 각 제안이 즉시 커밋되는 것을 보여주지만 고급 배포 사례에서는 애플리케이션이 여러 제안을 한 번에 커밋하기 전에 수집할 수 있습니다. 아래 그림에서는 Proposal 및 Commit 메시지를 직접 보여 주지만 실제로는 PublicMessage 또는 PrivateMessage 개체에 캡슐화되어 전송됩니다.

그룹을 초기화하기 전에 클라이언트는 DS에서 제공하는 디렉터리에 KeyPackage를 게시합니다\(그림 2 참조\).

```text
                                                    Delivery Service
                                                            |
                                                  .--------' '--------.
                                                 |                     |
                                                                 Group
  A                B                C            Directory       Channel
  |                |                |                |              |
  | KeyPackageA    |                |                |              |
  +------------------------------------------------->|              |
  |                |                |                |              |
  |                | KeyPackageB    |                |              |
  |                +-------------------------------->|              |
  |                |                |                |              |
  |                |                | KeyPackageC    |              |
  |                |                +--------------->|              |
  |                |                |                |              |

    Figure 2: Clients A, B, and C publish KeyPackages to the directory
```

그림 3은 이러한 사전 게시된 KeyPackages를 사용하여 그룹을 만드는 방법을 보여줍니다. 클라이언트 A가 클라이언트 B와 C로 그룹을 만들고자 할 때, 먼저 자신만을 포함하는 그룹 상태를 초기화하고 B와 C에 대한 KeyPackages를 다운로드합니다. 각 구성원에 대해 A는 해당 구성원을 추가하기 위해 추가 제안 및 커밋 메시지를 생성한 다음 두 메시지를 그룹에 브로드캐스트합니다. 또한 클라이언트 A는 환영 메시지를 생성하여 새 구성원에게 직접 보냅니다\(그룹에 보낼 필요 없음\). A는 배달 서비스로부터 Commit 메시지를 받은 후에야 새 구성원의 추가를 반영하도록 상태를 업데이트합니다.

A가 상태를 업데이트하고 새 구성원이 환영을 처리하고 다른 모든 그룹 구성원이 커밋을 처리하면 그룹 구성원에게만 알려진 그룹 비밀을 포함하여 그룹 상태에 대한 일관된 표현을 갖게 됩니다. 새 구성원은 새 메시지를 읽고 그룹에 보낼 수 있지만 그룹에 추가되기 전에 보낸 메시지에는 액세스할 수 없습니다.

```text
                                                                  Group
   A              B              C          Directory            Channel
   |              |              |              |                   |
   |         KeyPackageB, KeyPackageC           |                   |
   |<-------------------------------------------+                   |
   |              |              |              |                   |
   |              |              |              | Add(A->AB)        |
   |              |              |              | Commit(Add)       |
   +--------------------------------------------------------------->|
   |              |              |              |                   |
   |  Welcome(B)  |              |              |                   |
   +------------->|              |              |                   |
   |              |              |              |                   |
   |              |              |              | Add(A->AB)        |
   |              |              |              | Commit(Add)       |
   |<---------------------------------------------------------------+
   |              |              |              |                   |
   |              |              |              |                   |
   |              |              |              | Add(AB->ABC)      |
   |              |              |              | Commit(Add)       |
   +--------------------------------------------------------------->|
   |              |              |              |                   |
   |              |  Welcome(C)  |              |                   |
   +---------------------------->|              |                   |
   |              |              |              |                   |
   |              |              |              | Add(AB->ABC)      |
   |              |              |              | Commit(Add)       |
   |<---------------------------------------------------------------+
   |              |<------------------------------------------------+
   |              |              |              |                   |

          Figure 3: Client A creates a group with clients B and C
```

그룹 구성원의 후속 추가는 동일한 방식으로 진행됩니다. 그룹의 모든 구성원은 새 클라이언트용 KeyPackage를 다운로드하고, 현재 그룹이 상태를 업데이트하는 데 사용할 Add 및 Commit 메시지를 브로드캐스트하고, 새 클라이언트가 상태를 초기화하고 그룹에 가입하는 데 사용할 수 있는 환영 메시지를 보낼 수 있습니다.

메시지의 순방향 비밀성과 사후 손상 보안을 강화하기 위해 각 구성원은 그룹에 자신을 나타내는 키를 주기적으로 업데이트합니다. 구성원은 커밋\(아마도 제안 없이\)을 보내거나 다른 구성원이 커밋한 업데이트 메시지를 보내서 이를 수행합니다\(그림 4 참조\). 그룹의 다른 구성원이 이러한 메시지를 처리하면 그룹의 비밀은 트리에서 보낸 사람의 리프에 해당하는 비밀을 손상시킨 공격자에게 알려지지 않습니다. 그림 4에 표시된 시나리오의 끝에서 그룹은 A와 B 모두에 대해 사후 보안을 갖습니다.

업데이트 메시지는 그룹이 활성화되어 있는 한 일정한 시간 간격으로 전송되어야 하며 업데이트하지 않는 구성원은 결국 그룹에서 제거되어야 합니다. 업데이트 사이의 적절한 시간을 결정하는 것은 애플리케이션에 맡겨져 있습니다. 업데이트를 보내는 목적은 침해 창을 사전에 제한하는 것이므로 일반적으로 올바른 빈도는 밀리초가 아니라 몇 시간 또는 며칠 정도입니다. 예를 들어, 응용 프로그램은 구성원이 다른 구성원으로부터 메시지를 받은 후 응용 프로그램 메시지를 보낼 때마다 또는 응용 프로그램 메시지가 전송되지 않은 경우 매일 업데이트를 보낼 수 있습니다.\(SHOULD\)

MLS 아키텍처는 MLS가 보안 전송을 통해 작동할 것을 권장합니다\(\[MLS-ARCH\]의 섹션 7.1 참조\). 이러한 전송 프로토콜은 일반적으로 동일한 네트워크를 공유하는 다른 애플리케이션에 대한 MLS 사용 애플리케이션의 영향을 관리하는 혼잡 제어와 같은 기능을 제공합니다. 애플리케이션은 특히 위의 권장 사항을 따르지 않는 경우\(예: 대신 UDP를 통해 직접 MLS 전송\) 네트워크 정체와 같은 문제를 일으킬 속도로 MLS 메시지를 전송하지 않도록 주의해야 합니다.

```text
                                                             Group
   A              B     ...      Z          Directory        Channel
   |              |              |              |              |
   |              | Update(B)    |              |              |
   |              +------------------------------------------->|
   |              |              |              | Update(B)    |
   |<----------------------------------------------------------+
   |              |<-------------------------------------------+
   |              |              |<----------------------------+
   |              |              |              |              |
   | Commit(Upd)  |              |              |              |
   +---------------------------------------------------------->|
   |              |              |              | Commit(Upd)  |
   |<----------------------------------------------------------+
   |              |<-------------------------------------------+
   |              |              |<----------------------------+
   |              |              |              |              |

        Figure 4: Client B proposes to update its key, and client A
                            commits the proposal
```

구성원은 그림 5와 같이 유사한 방식으로 그룹에서 제거됩니다. 그룹의 모든 구성원은 Commit 메시지가 뒤따르는 Remove 제안을 보낼 수 있습니다. Commit 메시지는 제거된 구성원을 제외한 그룹의 모든 구성원에게 새로운 엔트로피를 제공합니다. 이 새로운 엔트로피는 제거된 멤버에게 알려지지 않도록 새로운 epoch의 epoch secret에 추가됩니다. 이것은 어떤 구성원이 실제로 다른 구성원을 퇴거시킬 수 있다는 것을 반드시 의미하지는 않습니다. 그룹은 이러한 기본 메커니즘 위에 액세스 제어 정책을 적용할 수 있습니다.

```text
                                                             Group
   A              B     ...      Z          Directory       Channel
   |              |              |              |              |
   |              |              | Remove(B)    |              |
   |              |              | Commit(Rem)  |              |
   |              |              +---------------------------->|
   |              |              |              |              |
   |              |              |              | Remove(B)    |
   |              |              |              | Commit(Rem)  |
   |<----------------------------------------------------------+
   |              |<-------------------------------------------+
   |              |              |<----------------------------+
   |              |              |              |              |

             Figure 5: Client Z removes client B from the group
```

이 섹션의 흐름은 예시입니다. 애플리케이션은 다른 방식으로 메시지 흐름을 배열할 수 있습니다. 예를 들어:

\* 환영 메시지는 신규 참여자에게 반드시 직접 보낼 필요는 없습니다. 새 참여자에게 암호화되기 때문에 응용 프로그램이 그룹의 브로드캐스트 채널에만 액세스할 수 있는 경우와 같이 더 광범위하게 배포될 수 있습니다.

\* 제안 메시지는 모든 그룹 구성원에게 즉시 보낼 필요가 없습니다. 커밋을 생성하기 전에 커미터가 사용할 수 있어야 하고 커밋을 처리하기 전에 다른 구성원이 사용할 수 있어야 합니다.

\* Commit의 발신자는 상태를 진행하기 전에 자신의 Commit을 다시 수신하기 위해 반드시 기다릴 필요는 없습니다. 예를 들어 오케스트레이션 서버의 약속을 기반으로 하는 커밋이 그룹에 의해 적용되는 다음 커밋이 될 것이라는 점만 알면 됩니다.

---
### **3.3.  External Joins**

새 구성원을 그룹에 추가하기 위한 환영 기반 흐름 외에도 새 구성원이 "외부 커밋"을 통해 가입하는 것도 가능합니다. 이 메커니즘은 기존 구성원이 새 구성원에 대한 KeyPackage를 가지고 있지 않을 때 사용할 수 있습니다. 예를 들어 기존 구성원에게 권한을 요청하지 않고 새 구성원이 가입할 수 있는 "열린" 그룹의 경우입니다.

그림 6은 외부 조인에 대한 일반적인 메시지 흐름을 보여줍니다. 새 구성원이 이러한 방식으로 그룹에 가입할 수 있도록 하기 위해 그룹\(A, B\)의 구성원은 그룹에 대한 GroupContext와 비밀을 암호화하는 데 사용할 수 있는 공개 키를 포함하는 GroupInfo 개체를 게시합니다. 그룹의 기존 구성원. 새 구성원 Z가 가입을 원할 때 그들은 GroupInfo 개체를 다운로드하고 이를 사용하여 Z를 그룹에 추가하는 특수 형식의 커밋을 형성합니다\(섹션 12.4.3.2 참조\). 그룹의 기존 구성원은 일반 커밋과 유사한 방식으로 이 외부 커밋을 처리하여 Z가 이제 그룹의 구성원인 새로운 시대로 진행합니다.

```text
                                                             Group
   A              B              Z          Directory        Channel
   |              |              |              |              |
   | GroupInfo    |              |              |              |
   +------------------------------------------->|              |
   |              |              | GroupInfo    |              |
   |              |              |<-------------+              |
   |              |              |              |              |
   |              |              | Commit(ExtZ) |              |
   |              |              +---------------------------->|
   |              |              |              | Commit(ExtZ) |
   |<----------------------------------------------------------+
   |              |<-------------------------------------------+
   |              |              |<----------------------------+
   |              |              |              |              |

       Figure 6: Client A publishes a GroupInfo object, and Client Z
                         uses it to join the group
```

---
### **3.4.  Relationships between Epochs**

그룹에는 단일 선형 에포크 시퀀스가 ​​있습니다. 그룹과 시대는 일반적으로 서로 독립적입니다. 그러나 때때로 그룹 내에서 또는 그룹 간에 암호화 방식으로 epoch를 연결하는 것이 유용할 수 있습니다. MLS는 한 epoch에서 추출된 엔트로피를 미래 epoch에 주입할 수 있도록 각 epoch에서 재개 PSK\(사전 공유 키\)를 파생합니다. PSK를 삽입하려는 그룹 구성원은 삽입할 PSK를 설명하는 PreSharedKey 제안\(섹션 12.1.4\)을 발행합니다. 이 제안이 확정되면 해당 PSK는 섹션 8.4에 설명된 대로 주요 일정에 통합됩니다.

이러한 방식으로 에포크를 연결하면 새 에포크에 들어가는 구성원이 재개 키가 추출된 에포크 동안 그룹의 구성원인 경우에만 키에 동의하도록 보장할 수 있습니다.

MLS는 새 그룹을 기존 그룹에 연결하는 두 가지 방법을 지원합니다\(그림 7 및 8 참조\). 재초기화는 하나의 그룹을 닫고 매개변수가 다른 동일한 구성원으로 구성된 새 그룹을 만듭니다. 분기는 원래 그룹 참가자의 하위 집합으로 새 그룹을 시작합니다\(원래 그룹에 영향을 주지 않음\). 두 경우 모두 새 그룹은 재개 PSK를 통해 이전 그룹에 연결됩니다.

```text
   epoch_A_[n-1]
        |
        |
        |<-- ReInit
        |
        V
   epoch_A_[n]           epoch_B_[0]
        .                     |
        .  PSK(usage=reinit)  |
        .....................>|
                              |
                              V
                         epoch_B_[1]

                      Figure 7: Reinitializing a Group

   epoch_A_[n]           epoch_B_[0]
        |                     |
        |  PSK(usage=branch)  |
        |....................>|
        |                     |
        V                     V
   epoch_A_[n+1]         epoch_B_[1]
```

- 그림 8: 그룹 분기

애플리케이션은 재개 PSK를 사용하여 다른 방식으로 에포크를 연결하도록 선택할 수도 있습니다. 예를 들어, 그림 9는 epoch n의 재개 PSK가 epoch n+k에 주입되는 경우를 보여줍니다. 이는 업데이트 또는 커밋으로 인해 구성원의 키가 변경된 것과 관계없이 epoch n+k의 그룹 구성원이 epoch n의 구성원이기도 ​​했음을 보여줍니다.

```text
   epoch_A_[n]
        |
        |  PSK(usage=application)
        |.....................
        |                    .
        |                    .
       ...                  ...
        |                    .
        |                    .
        V                    .
   epoch_A_[n+k-1]           .
        |                    .
        |                    .
        |<....................
        |
        V
   epoch_A_[n+k]
```

- 그림 9: 이전 Epoch에서 엔트로피 재주입

---
## **4.  Ratchet Tree Concepts**

이 프로토콜은 클라이언트 그룹 간에 공유 비밀을 도출하기 위해 "래칫 트리"를 사용합니다. 래칫 트리는 그룹의 변경 사항을 반영하도록 비밀을 효율적으로 업데이트할 수 있는 방식으로 그룹 구성원 간의 비밀 및 키 쌍 배열입니다.

래칫 트리를 사용하면 그룹의 하위 집합에 대한 새 엔트로피를 암호화하여 그룹이 구성원을 효율적으로 제거할 수 있습니다. 래칫 트리는 공유 키를 전체 그룹의 하위 그룹에 할당하므로 예를 들어 그룹의 한 구성원을 제외한 모든 구성원을 암호화하려면 N-1 암호화 대신 하위 트리에 대한 log\(N\) 암호화만 필요합니다. 각 참가자에게 개별적으로 암호화합니다\(여기서 N은 그룹의 구성원 수\).

이 제거 작업을 통해 MLS는 손상 후 보안을 효율적으로 달성할 수 있습니다. 업데이트 제안 또는 전체 커밋 메시지에서 멤버의 이전\(손상 가능성이 있는\) 표현이 그룹에서 효율적으로 제거되고 새로 생성된 인스턴스로 대체됩니다.

---
### **4.1.  Ratchet Tree Terminology**

트리는 \_nodes\_로 구성됩니다. 자식이 없으면 노드는 \_leaf\_입니다. 그렇지 않으면 \_parent\_입니다. 트리의 모든 부모는 정확히 두 개의 자식, 즉 \_left\_ 자식과 \_right\_ 자식을 가집니다. 노드는 부모가 없는 경우 트리의 \_루트\_이고 자식과 부모가 모두 있는 경우 \_중간\_입니다. 노드의 \_descendants\_는 해당 노드의 자식 및 해당 자식의 자손입니다. 노드가 트리 루트의 자손이거나 노드 자체가 트리의 루트인 경우 우리는 트리가 노드를 \_포함\_한다고 말합니다. 노드는 동일한 부모를 공유하는 경우 \_형제\_입니다.

트리의 \_subtree\_는 모든 노드\(하위 트리의 \_head\_\)와 그 자손이 제공하는 트리입니다. 트리 또는 하위 트리의 \_size\_는 포함된 리프 노드의 수입니다. 주어진 부모 노드의 경우 \_왼쪽 하위 트리\_는 왼쪽 자식을 머리로 하는 하위 트리이고 \_오른쪽 하위 트리\_는 오른쪽 자식을 머리로 하는 하위 트리입니다.

이 프로토콜에 사용된 모든 트리는 완벽한 이진 트리입니다. 즉, 2^d가 모두 동일한 깊이 d에 있는 완전한 균형 이진 트리입니다. 이 구조는 주어진 깊이 d에 대해 고유합니다.

구현이 메모리에서 래칫 트리를 나타낼 수 있는 여러 가지 방법이 있습니다. 왼쪽 균형 이진 트리\(여기에 사용된 전체 트리 포함\)의 편리한 속성은 배열의 노드 인덱스를 기반으로 노드 관계가 계산된 노드 배열로 표시될 수 있다는 것입니다. 연결된 노드 개체를 기반으로 하는 보다 전통적인 표현도 사용할 수 있습니다. 부록 C와 D는 이러한 표현에서 MLS에 필요한 트리 작업을 구현하는 방법에 대한 세부 정보를 제공합니다. MLS는 구현의 래칫 트리 내부 표현에 대한 요구 사항을 두지 않습니다. 구현은 올바른 프로토콜 메시지를 생성하는 한 트리 표현 및 관련 알고리즘을 사용할 수 있습니다.

---
#### **4.1.1.  Ratchet Tree Nodes**

래칫 트리의 각 리프 노드에는 왼쪽에서 0부터 시작하여 오른쪽에서 2^d - 1까지 \_index\_\(또는 \_leaf index\_\)가 지정됩니다\(2^d 리프가 있는 트리의 경우\). 2^d개의 리프가 있는 트리에는 부모 노드를 포함하여 2^\(d+1\) - 1개의 노드가 있습니다.

래칫 트리의 각 노드는 \_blank\_\(값 없음\)이거나 일부 관련 데이터가 있는 HPKE 공개 키를 보유합니다.

```text
   *  A public key (for the HPKE scheme in use; see Section 5.1)

   *  A credential (only for leaf nodes; see Section 5.3)

   *  An ordered list of "unmerged" leaves (see Section 4.2)
```

\* 노드가 마지막으로 변경된 시점을 기준으로 노드의 부모에 대한 특정 정보의 해시\(7.9절 참조\).

섹션 4.2에서 설명한 것처럼 서로 다른 구성원은 트리의 노드에 있는 공개 키에 해당하는 개인 키 집합의 서로 다른 하위 집합을 알고 있습니다. 부모 노드에 해당하는 개인 키는 해당 노드의 자손인 리프 노드의 구성원에게만 알려집니다. 리프 노드에 해당하는 개인 키는 해당 리프 노드의 멤버만 알 수 있습니다. 리프 노드의 구성원이 조상 노드에 해당하는 개인 키를 모르는 경우 리프 노드는 조상 노드 중 하나에 대해 \_병합되지\_ 않습니다.

노드가 비어 있거나 채워져 있는지 여부에 관계없이 모든 노드에는 해당 노드 아래의 하위 트리 내용을 요약하는 해당 \_hash\_가 있습니다. 이러한 해시를 계산하는 규칙은 섹션 7.8에 설명되어 있습니다.

노드의 \_해상도\_는 노드의 비어 있지 않은 모든 자손을 집합적으로 포함하는 비어 있지 않은 노드의 정렬된 목록입니다. 루트의 확인에는 그룹의 모든 노드를 암호화하는 데 집합적으로 필요한 키 집합이 포함됩니다. 노드의 해상도는 사실상 노드 아래에서 가장 가까운 비어 있지 않은 노드의 깊이 우선, 왼쪽 우선 열거입니다.

\* 비어 있지 않은 노드의 해상도는 노드 자체와 병합되지 않은 리프 목록\(있는 경우\)으로 구성됩니다.

\* 빈 리프 노드의 해상도는 빈 리스트입니다.

\* 빈 중간 노드의 해상도는 왼쪽 자식의 해상도와 오른쪽 자식의 해상도를 순서대로 연결한 결과입니다.

예를 들어, \_ 문자는 빈 노드를 나타내고 병합되지 않은 리프는 대괄호 안에 표시되는 다음 하위 트리를 고려하십시오.

```text
                  ...
                  /
                 _
           ______|______
          /             \
         X[B]            _
       __|__           __|__
      /     \         /     \
     _       _       Y       _
    / \     / \     / \     / \
   A   B   _   D   E   F   _   H

   0   1   2   3   4   5   6   7

             Figure 10: A Tree with Blanks and Unmerged Leaves
```

이 트리에서 위의 모든 규칙이 적용되는 것을 볼 수 있습니다.

\* 노드 X의 해상도는 리스트 \[X, B\]입니다.

\* 리프 2 또는 리프 6의 해상도는 빈 리스트\[\]입니다.

\* 최상위 노드의 해상도는 \[X, B, Y, H\] 목록입니다.

---
#### **4.1.2.  Paths through a Ratchet Tree**

루트의 \_직접 경로\_는 빈 목록입니다. 다른 노드의 직접 경로는 부모의 직접 경로와 함께 해당 노드의 부모를 연결한 것입니다.

노드의 \_copath\_는 루트를 제외한 직접 경로에 있는 모든 노드의 형제 목록과 연결된 노드의 형제입니다.

리프 노드 L의 \_필터링된 직접 경로\_는 노드의 직접 경로이며, L의 copath에 있는 자식이 빈 해상도를 갖는 모든 노드가 제거됩니다\(copath 자식의 병합되지 않은 리프는 해상도에 포함된다는 점을 명심\). 노드의 키 쌍으로 암호화하는 것은 비copath 자식으로 암호화하는 것과 같기 때문에 제거된 노드에는 자체 키 쌍이 필요하지 않습니다.

예를 들어, 다음 트리를 고려하십시오\(빈 노드는 \_로 표시되지만 참조용 레이블도 지정됨\).

```text
                 W = root
                 |
           .-----+-----.
          /             \
         _=U             Y
         |               |
       .-+-.           .-+-.
      /     \         /     \
     T       _=V     X       _=Z
    / \     / \     / \     / \
   A   B   _   _   E   F   G   _=H

   0   1   2   3   4   5   6   7

       Figure 11: A Complete Tree with Five Members, with Labels for
                             Blank Parent Nodes
```

이 트리에서 리프 노드에 대한 직접 경로, 공동 경로 및 필터링된 직접 경로는 다음과 같습니다.

```text
          +======+=============+=========+======================+
          | Node | Direct path | Copath  | Filtered Direct Path |
          +======+=============+=========+======================+
          | A    | T, U, W     | B, V, Y | T, W                 |
          +------+-------------+---------+----------------------+
          | B    | T, U, W     | A, V, Y | T, W                 |
          +------+-------------+---------+----------------------+
          | E    | X, Y, W     | F, Z, U | X, Y, W              |
          +------+-------------+---------+----------------------+
          | F    | X, Y, W     | E, Z, U | X, Y, W              |
          +------+-------------+---------+----------------------+
          | G    | Z, Y, W     | H, X, U | Y, W                 |
          +------+-------------+---------+----------------------+

                                  Table 2
```

---
### **4.2.  Views of a Ratchet Tree**

우리는 일반적으로 각 참가자가 모든 노드의 공개 키 및 리프 노드와 관련된 자격 증명을 포함하여 그룹 래칫 트리의 공개 상태에 대한 완전하고 최신 보기를 유지한다고 가정합니다.

MLS 그룹의 어떤 참가자도 트리의 모든 노드와 관련된 개인 키를 알지 못합니다. 대신 각 구성원은 알고 있는 개인 키의 하위 집합을 결정하는 트리의 리프에 할당됩니다. 해당 리프에 저장된 자격 증명은 구성원이 제공한 자격 증명입니다.

특히 MLS는 \_tree invariant\_를 유지하는 방식으로 구성원의 트리 보기를 유지합니다.

| 트리의 노드에 대한 개인 키는 | 노드의 하위 트리에 해당 구성원의 리프가 포함된 경우에만 그룹화합니다.

즉, 노드가 비어 있지 않으면 공개 키를 보유합니다. 해당 개인 키는 해당 노드 아래의 리프를 점유하는 구성원에게만 알려집니다.

반대의 의미는 사실이 아닙니다. 멤버는 상위 중간 노드의 개인 키를 모를 수 있습니다. 이러한 구성원은 중간 노드에서 \_unmerged\_ 리프를 갖습니다. 중간 노드로 암호화하려면 노드의 공개 키와 그 아래 병합되지 않은 모든 리프의 공개 키를 암호화해야 합니다. 리프를 추가하는 과정에서 트리에서 상위에 있는 모든 노드의 개인 키에 액세스할 수 없기 때문에 리프는 처음 추가될 때 모든 조상과 관련하여 병합 해제됩니다. 리프는 섹션 7.4에 설명된 대로 노드의 개인 키를 받을 때 "병합"됩니다.

예를 들어 오른쪽 두 구성원 위의 노드가 비어 있는 네 구성원 그룹\(A, B, C, D\)을 고려하십시오. \(A가 B, C, D로 그룹을 만들었다면 이런 모습일 것입니다.\) 그러면 트리의 공개 상태와 각 참가자가 보유한 트리의 개인 키 보기는 다음과 같습니다. 여기서 \_ 빈 노드를 나타냅니다. ? 알 수 없는 개인 키를 나타내고 pk\(X\)는 개인 키 X에 해당하는 공개 키를 나타냅니다.

```text
            Public Tree
   ============================
               pk(ABCD)
             /          \
       pk(AB)            _
        / \             / \
   pk(A)   pk(B)   pk(C)   pk(D)

    Private @ A       Private @ B       Private @ C       Private @ D
   =============     =============     =============     =============
        ABCD              ABCD              ABCD              ABCD
       /   \             /   \             /   \             /   \
     AB      _         AB      _         ?       _         ?       _
    / \     / \       / \     / \       / \     / \       / \     / \
   A   ?   ?   ?     ?   B   ?   ?     ?   ?   C   ?     ?   ?   ?   D
```

트리 불변이 어떻게 적용되는지 주목하십시오. 각 구성원은 자신의 리프만 알고 있고 개인 키 AB는 A와 B만 알고 있으며 개인 키 ABCD는 네 구성원 모두에게 알려져 있습니다. 이것은 또한 또 다른 중요한 점을 설명합니다. 멤버의 리프에서 루트까지의 경로에 "구멍"이 있을 수 있습니다. 여기서 멤버는 지정된 노드 위와 아래 모두에서 키를 알고 있지만 해당 노드에 대해서는 그렇지 않습니다. D의 경우.

---
## **5.  Cryptographic Objects**
---
### **5.1.  Cipher Suites**

각 MLS 세션은 그룹 키 계산에 사용할 다음 프리미티브를 지정하는 단일 암호화 제품군을 사용합니다.

```text
   *  HPKE parameters:

      -  A Key Encapsulation Mechanism (KEM)

      -  A Key Derivation Function (KDF)
```

- - AEAD\(Authenticated Encryption with Associated Data\) 암호화 알고리즘

\* 해시 알고리즘

\* 메시지 인증 코드\(MAC\) 알고리즘

\* 서명 알고리즘

MLS는 공개 키 암호화에 HPKE를 사용합니다\[RFC9180\]. 암호 제품군의 KEM과 연결된 DeriveKeyPair 기능은 옥텟 문자열을 HPKE 키 쌍에 매핑합니다. HPKE에서와 마찬가지로 MLS는 AEAD 알고리즘이 별도의 암호문 및 태그가 아닌 AEAD 암호화\(\[RFC5116\]에 따라\)에서 단일 암호문 출력을 생성한다고 가정합니다.

암호 그룹은 CipherSuite 유형으로 표시됩니다. 암호 스위트는 섹션 17.1에 정의되어 있습니다.

---
#### **5.1.1.  Public Keys**

HPKE 공개 키는 기본 프로토콜에 의해 정의된 형식의 불투명 값입니다\(자세한 내용은 \[RFC9180\]의 섹션 4 참조\).

```text
   opaque HPKEPublicKey<V>;
```

서명 공개 키는 마찬가지로 암호 그룹의 서명 체계에 의해 정의된 형식의 불투명 값으로 표시됩니다.

```text
   opaque SignaturePublicKey<V>;
```

EdDSA\(Edwards-curve Digital Signature Algorithm\) 서명 체계\(Ed25519 또는 Ed448\)를 사용하는 암호 제품군의 경우 공개 키는 \[RFC8032\]에 지정된 형식입니다.

NIST 곡선\(P-256, P-384 또는 P-521\)과 함께 ECDSA\(Elliptic Curve Digital Signature Algorithm\)를 사용하는 암호 제품군의 경우 공개 키는 \[RFC8446\]에 정의된 대로 인코딩된 UncompressedPointRepresentation 구조체로 표시됩니다.

---
#### **5.1.2.  Signing**

그룹의 암호화 제품군에 지정된 서명 알고리즘은 그룹 내에서 메시지 서명에 사용되는 필수 알고리즘입니다. 트리의 리프에 있는 자격 증명에 지정된 서명 알고리즘과 동일해야 합니다\(새 구성원을 추가하는 데 사용되는 KeyPackages의 리프 노드 정보 포함\).\(MUST\)

이 문서에 사용된 서명은 \[RFC8446\]에 지정된 대로 인코딩됩니다. 특히 ECDSA 서명은 DER로 인코딩되며 EdDSA 서명은 \[RFC8032\]에 명시된 대로 R과 S의 연결로 정의됩니다.

MLS에서 사용되는 서로 다른 서명을 명확하게 하기 위해 각 서명된 값에는 아래와 같이 레이블이 접두사로 붙습니다.

```text
   SignWithLabel(SignatureKey, Label, Content) =
       Signature.Sign(SignatureKey, SignContent)

   VerifyWithLabel(VerificationKey, Label, Content, SignatureValue) =
       Signature.Verify(VerificationKey, SignContent, SignatureValue)
```

여기서 SignContent는 다음과 같이 지정됩니다.

```text
   struct {
       opaque label<V>;
       opaque content<V>;
   } SignContent;
```

그리고 해당 필드는 다음과 같이 설정됩니다.

```text
   label = "MLS 1.0 " + Label;
   content = Content;
```

Signature.Sign 및 Signature.Verify 함수는 서명 알고리즘에 의해 정의됩니다. MLS 확장에 그룹 구성원의 서명이 필요한 경우 고유한 레이블을 사용하여 SignWithLabel 구성을 재사용해야 합니다. 이러한 레이블의 충돌을 방지하기 위해 IANA 레지스트리는 섹션 17.6에 정의되어 있습니다.

---
#### **5.1.3.  Public Key Encryption**

서명과 마찬가지로 MLS는 다른 목적으로 생성된 암호문 간의 혼동을 피하기 위해 암호화 작업에 레이블과 컨텍스트를 포함합니다. 이 레이블 및 컨텍스트를 포함한 암호화 및 암호 해독은 다음과 같이 수행됩니다.

```text
   EncryptWithLabel(PublicKey, Label, Context, Plaintext) =
     SealBase(PublicKey, EncryptContext, "", Plaintext)

   DecryptWithLabel(PrivateKey, Label, Context, KEMOutput, Ciphertext) =
     OpenBase(KEMOutput, PrivateKey, EncryptContext, "", Ciphertext)
```

여기서 EncryptContext는 다음과 같이 지정됩니다.

```text
   struct {
     opaque label<V>;
     opaque context<V>;
   } EncryptContext;
```

그리고 해당 필드는 다음과 같이 설정됩니다.

```text
   label = "MLS 1.0 " + Label;
   context = Context;
```

SealBase 및 OpenBase 기능은 \[RFC9180\]의 섹션 6.1\(모드로 "Base" 포함\)에 정의되어 있으며 그룹의 암호 제품군에서 지정한 HPKE 알고리즘을 사용합니다. MLS 확장에 HPKE 암호화 작업이 필요한 경우 고유 레이블을 사용하여 EncryptWithLabel 구성을 재사용해야 합니다. 이러한 레이블의 충돌을 방지하기 위해 IANA 레지스트리는 섹션 17.7에 정의되어 있습니다.

---
### **5.2.  Hash-Based Identifiers**

일부 MLS 메시지는 해시로 다른 MLS 개체를 참조합니다. 예를 들어 환영 메시지는 환영받는 구성원의 KeyPackages를 참조하고 커밋은 그들이 다루는 제안을 참조합니다. 이러한 식별자는 다음과 같이 계산됩니다.

```text
   opaque HashReference<V>;

   HashReference KeyPackageRef;
   HashReference ProposalRef;

   MakeKeyPackageRef(value)
     = RefHash("MLS 1.0 KeyPackage Reference", value)

   MakeProposalRef(value)
     = RefHash("MLS 1.0 Proposal Reference", value)

   RefHash(label, value) = Hash(RefHashInput)
```

여기서 RefHashInput은 다음과 같이 정의됩니다.

```text
   struct {
     opaque label<V>;
     opaque value<V>;
   } RefHashInput;
```

그리고 해당 필드는 다음과 같이 설정됩니다.

```text
   label = label;
   value = value;
```

KeyPackageRef의 경우 값 입력은 인코딩된 KeyPackage이고 KeyPackage에 지정된 암호화 제품군이 사용되는 KDF를 결정합니다. ProposalRef의 경우 값 입력은 제안을 전달하는 AuthenticatedContent입니다. 후자의 두 경우에서 KDF는 그룹의 암호 제품군에 의해 결정됩니다.

---
### **5.3.  Credentials**

그룹의 각 구성원은 구성원에 대한 하나 이상의 ID를 제공하고 이를 구성원의 서명 키와 연결하는 자격 증명을 제시합니다. ID 및 서명 키는 그룹에 사용 중인 인증 서비스에서 확인합니다.

애플리케이션 수준에서 사용할 식별자를 결정하는 것은 애플리케이션에 달려 있습니다. 예를 들어 X509Credential의 인증서는 해당 subjectAltName 확장자의 여러 도메인 이름 또는 이메일 주소를 증명할 수 있습니다. 응용 프로그램은 이 모든 것을 사용자에게 표시하도록 결정할 수 있습니다. 또는 "원하는" 도메인 이름이나 전자 메일 주소를 알고 있는 경우 원하는 식별자가 증명된 항목에 있는지 확인할 수 있습니다. \[RFC6125\]의 용어를 사용하면 자격 증명은 "제시된 식별자"를 제공하며 인증된 클라이언트에 대한 "참조 식별자"\(있는 경우\)를 제공하는 것은 애플리케이션에 달려 있습니다.

```text
   // See the "MLS Credential Types" IANA registry for values
   uint16 CredentialType;

   struct {
       opaque cert_data<V>;
   } Certificate;

   struct {
       CredentialType credential_type;
       select (Credential.credential_type) {
           case basic:
               opaque identity<V>;

           case x509:
               Certificate certificates<V>;
       };
   } Credential;
```

"기본" 자격 증명은 추가 정보가 없는 ID의 단순한 주장입니다. 인코딩된 ID의 형식은 애플리케이션에서 정의합니다.

X.509 자격 증명의 경우 인증서 필드의 각 항목은 단일 DER 인코딩 X.509 인증서를 나타냅니다. 첫 번째 항목\(인증서\[0\]\)이 최종 엔터티 인증서가 되도록 체인이 정렬됩니다. end-entity 인증서의 subjectPublicKeyInfo에 인코딩된 공개 키는 이 자격 증명을 포함하는 LeafNode의 signature\_key와 동일해야 합니다. 체인은 지원되는 피어가 이미 소유한 것으로 알려진 리프가 아닌 인증서를 생략할 수 있습니다\(MAY\).\(MUST, MAY\)

---
#### **5.3.1.  Credential Validation**

MLS를 사용하는 응용 프로그램은 그룹의 각 구성원에 대해 허용되는 식별자를 지정해야 합니다. 즉, \[RFC6125\]에서 TLS에 대해 설명하는 모델에 따라 애플리케이션은 그룹 구성원에 대한 "참조 식별자" 목록을 유지 관리하고 자격 증명은 "제시된 식별자"를 제공합니다. 그룹의 구성원은 먼저 구성원의 자격 증명이 제시된 일부 식별자를 합법적으로 나타내는지 확인한 다음 구성원에 대한 참조 식별자가 제시된 식별자에 의해 인증되는지 확인하여 인증됩니다.

이러한 기능을 수행하는 시스템 부분을 총칭하여 인증 서비스\(AS\)\[MLS-ARCH\]라고 합니다. AS가 자격 증명의 제시된 식별자가 구성원의 LeafNode에 있는 signature\_key 필드와 올바르게 연결되어 있고 이러한 식별자가 구성원의 참조 식별자와 일치하는지 확인할 때 구성원의 자격 증명은 AS로 \_검증되었다고 합니다.

새로운 자격 증명이 그룹에 도입될 때마다 AS로 유효성을 검사해야 합니다. 특히 프로토콜의 다음 이벤트에서:\(MUST\)

\* 구성원이 그룹에 새 구성원을 추가하기 위해 추가 제안에서 사용할 KeyPackage를 받는 경우

\* 구성원이 환영 또는 외부 커밋을 통해 그룹에 가입하는 데 사용할 GroupInfo 개체를 받는 경우

\* 멤버가 그룹에 멤버를 추가하는 추가 제안을 받은 경우

\* 구성원이 자신의 새로운 자격 증명을 가진 LeafNode의 업데이트 제안을 받은 경우

\* 구성원이 해당 LeafNode에 커미터에 대한 새 자격 증명이 있는 UpdatePath로 커밋을 수신하는 경우

\* 그룹에 external\_senders 확장자가 추가된 경우

\* 기존 external\_senders 확장자가 업데이트된 경우

위의 업데이트 및 커밋 사례와 같이 구성원의 자격 증명이 교체되는 경우 AS는 새 자격 증명에 제시된 식별자 집합이 이전 자격 증명에 제시된 식별자 집합에 대한 계승자로서 유효한지 확인해야 합니다. 응용 프로그램의 정책에 따라.\(MUST\)

---
#### **5.3.2.  Credential Expiry and Revocation**

일부 자격 증명 체계에서 유효한 자격 증명은 특정 시점 이후에 "만료"되거나 무효화될 수 있습니다. 예를 들어 각 X.509 인증서에는 인증서가 유효하지 않은 시간을 나타내는 notAfter 필드가 있습니다.

만료된 자격 증명은 섹션 5.3.1의 유효성 검사 요구 사항에 따라 운영 문제를 일으킬 수 있습니다. 애플리케이션은 이러한 영향을 완화하기 위해 인증 서비스 정책에 대한 일부 운영 사례 및 적응을 적용할 수 있습니다.

일반적으로 새 참여자가 그룹에서 만료된 자격 증명을 거부하는 것과 같은 운영상의 문제를 방지하기 위해 이러한 자격 증명을 사용하는 응용 프로그램은 그룹에서 사용 중인 모든 자격 증명이 항상 유효한 정도까지 보장해야 합니다.

구성원이 자신의 자격 증명이 만료되었거나 곧 만료됨을 알게 되면 유효한 자격 증명으로 교체하는 업데이트 또는 커밋을 발행해야 합니다. 이러한 이유로 회원은 업데이트 또는 커밋의 자격 증명이 유효한 경우 자격이 만료된 멤버가 발행한 업데이트 제안 및 커밋을 수락해야 합니다.\(SHOULD\)

마찬가지로, 클라이언트가 과거에 보낸 메시지를 처리할 때\(예: 오프라인 상태에서 그룹과 동기화\) 클라이언트는 자격 증명이 만료된 구성원의 서명을 수락해야 합니다. 보냈습니다.\(SHOULD\)

구성원이 다른 구성원의 자격 증명이 만료된 것을 발견하면 해당 구성원을 제거하는 제거를 발행할 수 있습니다. 예를 들어, 응용 프로그램은 트리에서 만료된 자격 증명을 확인하고 Commit에 해당 구성원에 대한 제거 제안을 포함하기 위해 Commit 발행을 준비하는 구성원을 요구할 수 있습니다. 그룹 트리가 DS에 알려진 상황에서 DS는 트리에서 만료된 자격 증명을 모니터링하고 외부 제거 제안을 발행할 수도 있습니다.

일부 자격 증명 체계에서는 자격 증명을 취소할 수도 있습니다. 철회는 이전에 유효한 자격 증명이 무효화된다는 점에서 만료와 유사합니다. 따라서 위의 고려 사항 대부분은 취소된 자격 증명에도 적용됩니다. 그러나 응용 프로그램은 자격 증명이 만료된 구성원을 업데이트할 시간을 허용하면서 자격 증명이 취소된 구성원을 제거하는 등 취소된 자격 증명을 다르게 취급하기를 원할 수 있습니다.

---
#### **5.3.3.  Uniquely Identifying Clients**

MLS 구현은 아마도 다른 클라이언트와 관련하여 프로토콜 작업을 요청하는 방법\(예: 클라이언트 제거\)을 응용 프로그램에 제공할 것입니다. 이러한 기능은 일부 식별자를 사용하여 다른 클라이언트를 참조해야 합니다. MLS 클라이언트에는 작동 속성이 다른 몇 가지 유형의 식별자가 있습니다.

프로토콜 내부적으로 그룹 구성원은 리프 인덱스로 고유하게 식별됩니다. 그러나 리프 인덱스는 주어진 epoch의 멤버를 참조하는 경우에만 유효합니다. 동일한 리프 인덱스는 후속 epoch에서 다른 구성원을 나타내거나 전혀 구성원을 나타내지 않을 수 있습니다.

그룹의 클라이언트가 제공하는 자격 증명은 클라이언트에 대한 애플리케이션 수준 식별자를 인증합니다. 그러나 이러한 식별자는 클라이언트를 고유하게 식별하지 못할 수 있습니다. 예를 들어 사용자가 MLS 그룹에 모두 있는 여러 장치를 가지고 있는 경우 해당 장치의 클라이언트는 모두 사용자의 응용 프로그램 계층 식별자를 나타낼 수 있습니다.

필요한 경우 응용 프로그램은 application\_id 확장자를 사용하여 LeafNode 개체의 확장 필드에 응용 프로그램별 식별자를 추가할 수 있습니다.

```text
   opaque application_id<V>;
```

그러나 애플리케이션은 인증 서비스에 의해 인증된 것처럼 application\_id 확장의 데이터에 의존해서는 안 되며 제시된 식별자가 고유하지 않은 경우를 정상적으로 처리해야 합니다\(SHOULD\).\(MUST NOT\)

---
## **6.  Message Framing**

핸드셰이크 및 애플리케이션 메시지는 공통 프레이밍 구조를 사용합니다. 이 프레이밍은 암호화를 제공하여 그룹 내 기밀성을 보장하고 발신자를 인증하기 위한 서명을 제공합니다.

대부분의 프로토콜에서 메시지는 AuthenticatedContent 객체의 형태로 처리됩니다. 이러한 구조에는 메시지 자체의 내용과 보낸 사람을 인증하는 정보가 포함됩니다\(섹션 6.1 참조\). 신뢰할 수 없는 채널\(그룹 구성원 인증 또는 AEAD 암호화\)을 통해 이러한 메시지를 전송하는 데 필요한 추가 보호는 AuthenticatedContent를 PublicMessage 또는 PrivateMessage 메시지로 인코딩하여 추가한 다음 MLSMessage로 보낼 수 있습니다. 마찬가지로 이러한 보호는 PublicMessage 또는 PrivateMessage를 AuthenticatedContent 개체로 디코딩할 때 \(멤버십 확인 또는 AEAD 암호 해독을 통해\) 적용됩니다.

PrivateMessage는 서명되고 암호화된 메시지를 나타내며 메시지 내용과 관련 메타데이터를 모두 보호합니다. PublicMessage는 암호화되지 않고 서명만 된 메시지를 나타냅니다. 애플리케이션은 반드시 PrivateMessage를 사용하여 애플리케이션 메시지를 암호화하고 PrivateMessage를 사용하여 핸드셰이크 메시지를 인코딩해야 하지만 전달 서비스가 그러한 메시지를 검사해야 하는 경우 PublicMessage 개체로 인코딩된 핸드셰이크 메시지를 전송할 수 있습니다\(MAY\).\(MUST\)

```text
   enum {
       reserved(0),
       mls10(1),
       (65535)
   } ProtocolVersion;

   enum {
       reserved(0),
       application(1),
       proposal(2),
       commit(3),
       (255)
   } ContentType;

   enum {
       reserved(0),
       member(1),
       external(2),
       new_member_proposal(3),
       new_member_commit(4),
       (255)
   } SenderType;

   struct {
       SenderType sender_type;
       select (Sender.sender_type) {
           case member:
               uint32 leaf_index;
           case external:
               uint32 sender_index;
           case new_member_commit:
           case new_member_proposal:
               struct{};
       };
   } Sender;

   // See the "MLS Wire Formats" IANA registry for values
   uint16 WireFormat;

   struct {
       opaque group_id<V>;
       uint64 epoch;
       Sender sender;
       opaque authenticated_data<V>;

       ContentType content_type;
       select (FramedContent.content_type) {
           case application:
             opaque application_data<V>;
           case proposal:
             Proposal proposal;
           case commit:
             Commit commit;
       };
   } FramedContent;

   struct {
       ProtocolVersion version = mls10;
       WireFormat wire_format;
       select (MLSMessage.wire_format) {
           case mls_public_message:
               PublicMessage public_message;
           case mls_private_message:
               PrivateMessage private_message;
           case mls_welcome:
               Welcome welcome;
           case mls_group_info:
               GroupInfo group_info;
           case mls_key_package:
               KeyPackage key_package;
       };
   } MLSMessage;
```

그룹에 속하지 않은 발신자의 메시지는 PublicMessage로 전송됩니다. 자세한 내용은 섹션 12.1.8 및 12.4.3.2를 참조하십시오.

다음 구조는 평문 또는 암호문으로 전송되는 데이터를 완전히 설명하는 데 사용됩니다.

```text
   struct {
       WireFormat wire_format;
       FramedContent content;
       FramedContentAuthData auth;
   } AuthenticatedContent;
```

다음 그림은 이 섹션에서 설명하는 다양한 구조가 서로 어떻게 관련되어 있는지, 이를 생성하고 소비하는 데 사용되는 상위 수준 작업을 보여줍니다.

```text
       Proposal        Commit     Application Data
          |              |              |
          +--------------+--------------+
                         |
                         V
                  FramedContent
                      |  |                -.
             +--------+  |                  |
             |           |                  |
             V           |                  +-- Asymmetric
   FramedContentAuthData |                  |   Sign / Verify
             |           |                  |
             +--------+  |                  |
                      |  |                  |
                      V  V                -'
                AuthenticatedContent
                         |                -.
                +--------+--------+         |
                |                 |         +-- Symmetric
                V                 V         |   Protect / Unprotect
          PublicMessage    PrivateMessage -'
                |                 |
                |                 |  Welcome  KeyPackage  GroupInfo
                |                 |     |          |          |
                +-----------------+-----+----------+----------+
                                  |
                                  V
                              MLSMessage

                 Figure 12: Relationships among MLS Objects
```

---
### **6.1.  Content Authentication**

FramedContent는 FramedContentAuthData 구조를 사용하여 인증됩니다.

```text
   struct {
       ProtocolVersion version = mls10;
       WireFormat wire_format;
       FramedContent content;
       select (FramedContentTBS.content.sender.sender_type) {
           case member:
           case new_member_commit:
               GroupContext context;
           case external:
           case new_member_proposal:
               struct{};
       };
   } FramedContentTBS;

   opaque MAC<V>;

   struct {
       /* SignWithLabel(., "FramedContentTBS", FramedContentTBS) */
       opaque signature<V>;
       select (FramedContent.content_type) {
           case commit:
               /*
                 MAC(confirmation_key,
                     GroupContext.confirmed_transcript_hash)
               */
               MAC confirmation_tag;
           case application:
           case proposal:
               struct{};
       };
   } FramedContentAuthData;
```

서명은 "FramedContentTBS" 레이블이 있는 SignWithLabel을 사용하여 계산되며 메시지 내용을 포함하는 내용과 이 메시지에 사용될 전송 형식이 포함됩니다. 보낸 사람의 sender\_type이 구성원인 경우 콘텐츠는 현재 epoch의 GroupContext도 포함하므로 서명이 지정된 그룹 및 epoch에 고유합니다.

발신자는 발신자의 sender\_type에 따라 다음 서명 키에 해당하는 개인 키를 사용해야 합니다.\(MUST\)

\* member: 래칫 트리에서 leaf\_index가 나타내는 인덱스의 LeafNode에 포함된 서명 키.

\* external: external\_senders 그룹 컨텍스트 확장에서 sender\_index가 나타내는 색인의 서명 키\(12.1.8.1절 참조\). 메시지의 content\_type은 반드시 제안이어야 하고 proposal\_type은 외부 발신자에게 허용되는 값이어야 합니다.\(MUST\)

\* new\_member\_commit: 커밋 경로의 LeafNode에 있는 서명 키\(섹션 12.4.3.2 참조\). 메시지의 content\_type은 커밋이어야 합니다.\(MUST\)

\* new\_member\_proposal: 외부 추가 제안에 포함된 KeyPackage의 LeafNode에 있는 서명 키입니다. 메시지의 content\_type은 반드시 제안이어야 하고 제안의 proposal\_type은 반드시 추가되어야 합니다.\(MUST\)

MLSMessage의 수신자는 위에서 설명한 것처럼 보낸 사람의 sender\_type에 따라 키로 서명을 확인해야 합니다.\(MUST\)

확인 태그 값은 그룹 구성원이 그룹의 동일한 상태에 도달했음을 확인합니다. FramedContentAuthData는 signature 및 Confirmation\_tag 필드가 모두 유효할 때 유효하다고 합니다.

---
### **6.2.  Encoding and Decoding a Public Message**

인증되었지만 암호화되지 않은 메시지는 PublicMessage 구조를 사용하여 인코딩됩니다.

```text
   struct {
       FramedContent content;
       FramedContentAuthData auth;
       select (PublicMessage.content.sender.sender_type) {
           case member:
               MAC membership_tag;
           case external:
           case new_member_commit:
           case new_member_proposal:
               struct{};
       };
   } PublicMessage;
```

PublicMessage 개체의 Membership\_tag 필드는 발신자의 그룹 구성원 자격을 인증합니다. 회원이 보낸 메시지의 경우 다음 값으로 설정해야 합니다.\(MUST\)

```text
   struct {
     FramedContentTBS content_tbs;
     FramedContentAuthData auth;
   } AuthenticatedContentTBM;

   membership_tag = MAC(membership_key, AuthenticatedContentTBM)
```

PublicMessage를 AuthenticatedContent로 디코딩할 때 애플리케이션은 Membership\_tag를 확인하고 FramedContentAuthData가 유효한지 확인해야 합니다.\(MUST\)

---
### **6.3.  Encoding and Decoding a Private Message**

인증되고 암호화된 메시지는 PrivateMessage 구조를 사용하여 인코딩됩니다.

```text
   struct {
       opaque group_id<V>;
       uint64 epoch;
       ContentType content_type;
       opaque authenticated_data<V>;
       opaque encrypted_sender_data<V>;
       opaque ciphertext<V>;
   } PrivateMessage;
```

encryption\_sender\_data 및 ciphertext는 SenderData 및 PrivateMessageContent 구조를 입력으로 사용하여 사용 중인 암호 제품군에서 지정한 AEAD 기능을 사용하여 암호화됩니다.

---
#### **6.3.1.  Content Encryption**

암호화할 콘텐츠는 PrivateMessageContent 구조로 인코딩됩니다.

```text
   struct {
       select (PrivateMessage.content_type) {
           case application:
             opaque application_data<V>;

           case proposal:
             Proposal proposal;

           case commit:
             Commit commit;
       };

       FramedContentAuthData auth;
       opaque padding[length_of_padding];
   } PrivateMessageContent;
```

패딩 필드는 보낸 사람이 먼저 콘텐츠\(select를 통해\)와 auth 필드를 인코딩한 다음 선택한 수의 0바이트를 추가하여 설정합니다. 수신자는 먼저 콘텐츠와 auth 필드를 디코딩하여 PrivateMessage.ciphertext에서 디코딩된 일반 텍스트의 패딩 필드를 식별합니다. 패딩 필드는 일반 텍스트의 나머지 옥텟으로 구성됩니다. 패딩 필드는 모두 0바이트로 채워져야 합니다. 수신자는 패딩 필드에 0이 아닌 바이트가 없는지 확인해야 하며 이 확인이 실패하면 둘러싸는 PrivateMessage가 잘못된 형식으로 거부되어야 합니다. 이 검사는 패딩 프로세스가 결정적임을 확인하므로 예를 들어 패딩을 비밀 채널로 사용할 수 없습니다.\(MUST, MUST\)

MLS 키 일정에서 보낸 사람은 그룹의 각 구성원에 대한 핸드셰이크 및 응용 프로그램 메시지에 대해 두 개의 고유한 키 래칫을 만듭니다. 메시지를 암호화할 때 보낸 사람은 자신의 구성원에 대해 파생된 래칫을 보고 메시지의 콘텐츠 유형에 따라 핸드셰이크 래칫 또는 애플리케이션 래칫에서 사용되지 않는 세대를 선택합니다. 래칫의 이 세대는 임시 nonce 및 키를 파생시키는 데 사용됩니다.

암호화 작업에 사용하기 전에 nonce는 재사용을 방지하기 위해 새로운 임의 값과 XOR 처리됩니다. 키 일정이 nonce를 결정적으로 생성하기 때문에 클라이언트는 키 일정의 위치에 대해 지속적인 상태를 유지해야 합니다. 이 지속적인 상태가 손실되거나 손상되면 클라이언트는 이미 사용된 생성을 재사용하여 키/nonce 쌍을 재사용할 수 있습니다.\(MUST\)

이러한 상황을 피하기 위해 메시지 발신자는 새로운 임의의 4바이트 "재사용 보호" 값을 생성하고 암호화에 nonce를 사용하기 전에 키 일정에서 nonce의 처음 4바이트와 XOR해야 합니다. 발신자는 발신자 데이터 개체의 reuse\_guard 필드에 재사용 가드를 포함해야 합니다. 그래야 메시지 수신자가 암호 해독에 사용할 nonce를 계산하는 데 사용할 수 있습니다.\(MUST, MUST\)

```text
   +-+-+-+-+---------...---+
   |   Key Schedule Nonce  |
   +-+-+-+-+---------...---+
              XOR
   +-+-+-+-+---------...---+
   | Guard |       0       |
   +-+-+-+-+---------...---+
              ===
   +-+-+-+-+---------...---+
   | Encrypt/Decrypt Nonce |
   +-+-+-+-+---------...---+
```

암호화에 대한 AAD\(추가 인증 데이터\) 입력에는 키와 nonce를 식별하는 데 사용되는 값과 함께 다음 형식의 개체가 포함됩니다.

```text
   struct {
       opaque group_id<V>;
       uint64 epoch;
       ContentType content_type;
       opaque authenticated_data<V>;
   } PrivateContentAAD;
```

PrivateMessageContent를 디코딩할 때 애플리케이션은 FramedContentAuthData가 유효한지 확인해야 합니다.\(MUST\)

어떤 인증 데이터를 제공하고 주어진 메시지\(있는 경우\)에 추가할 패딩의 양을 결정하는 것은 애플리케이션에 달려 있습니다. AAD 및 암호문의 전체 크기는 \[CFRG-AEAD-LIMITS\]에서 그룹의 AEAD 알고리즘에 대해 설정된 제한 내에 맞아야 합니다.\(MUST\)

---
#### **6.3.2.  Sender Data Encryption**

콘텐츠 암호화를 위한 키를 조회하는 데 사용되는 "발신자 데이터"는 sender\_data\_secret 및 암호화된 콘텐츠 샘플에서 파생된 키 및 nonce를 사용하여 암호 제품군의 AEAD로 암호화됩니다. 암호화되기 전에 보낸 사람 데이터는 다음 형식의 개체로 인코딩됩니다.

```text
   struct {
       uint32 leaf_index;
       uint32 generation;
       opaque reuse_guard[4];
   } SenderData;
```

Sender 개체에서 SenderData 개체를 구성할 때 발신자는 Sender.sender\_type이 구성원인지 확인하고 SenderData.leaf\_index에 대해 Sender.leaf\_index를 사용해야 합니다.\(MUST\)

재사용\_가드 필드는 섹션 6.3.1에 설명된 대로 상태 손실 또는 손상의 경우 nonce 재사용을 방지하는 데 사용되는 새로운 임의 값을 포함합니다.

AEAD에 제공된 키와 nonce는 이전 섹션에서 생성된 암호문의 첫 번째 KDF.Nh 바이트의 KDF로 계산됩니다. 암호문의 길이가 KDF.Nh보다 작으면 전체 암호문이 사용됩니다. 의사 코드에서 키와 nonce는 다음과 같이 파생됩니다.

```text
   ciphertext_sample = ciphertext[0..KDF.Nh-1]

   sender_data_key = ExpandWithLabel(sender_data_secret, "key",
                         ciphertext_sample, AEAD.Nk)
   sender_data_nonce = ExpandWithLabel(sender_data_secret, "nonce",
                         ciphertext_sample, AEAD.Nn)
```

SenderData 암호문의 AAD는 PrivateMessage의 처음 세 필드입니다.

```text
   struct {
       opaque group_id<V>;
       uint64 epoch;
       ContentType content_type;
   } SenderDataAAD;
```

메시지 해독의 일부로 SenderData 구조를 구문 분석할 때 수신자는 leaf\_index 필드에 표시된 리프 인덱스가 비어 있지 않은 노드를 식별하는지 확인해야 합니다.\(MUST\)

---
## **7.  Ratchet Tree Operations**

에포크에 대한 래칫 트리는 해당 에포크의 그룹 구성원을 설명하고 그룹의 하위 집합을 암호화하는 데 사용할 수 있는 공개 키 암호화\(HPKE\) 키와 구성원을 인증하는 정보를 제공합니다. 한 시대에서 다음 시대로 그룹의 구성원에 대한 변경 사항을 반영하기 위해 래칫 트리에 해당 변경 사항이 적용됩니다. 이 섹션에서는 트리의 내용과 필요한 작업에 대해 설명합니다.

---
### **7.1.  Parent Node Contents**

4.1.1절에서 설명한 것처럼 래칫 트리의 노드에는 개별 구성원\(리프 노드의 경우\) 또는 그룹의 하위 그룹\(부모 노드의 경우\)을 설명하는 여러 유형의 데이터가 포함됩니다. 상위 노드가 더 간단합니다.

```text
   struct {
       HPKEPublicKey encryption_key;
       opaque parent_hash<V>;
       uint32 unmerged_leaves<V>;
   } ParentNode;
```

encryption\_key 필드에는 자손 중 잎에 있는 구성원만 개인 키를 보유하는 HPKE 공개 키가 포함되어 있습니다. parent\_hash 필드는 섹션 7.9에 설명된 대로 이 노드의 부모 노드의 해시를 포함합니다. unmerged\_leaves 필드는 트리의 모든 잎 사이의 인덱스에 따라 병합되지 않은 이 상위 노드 아래의 잎을 나열합니다. unmerged\_leaves 벡터의 항목은 오름차순으로 정렬되어야 합니다.\(MUST\)

---
### **7.2.  Leaf Node Contents**

트리의 리프 노드는 해당 클라이언트가 서명한 그룹의 개별 클라이언트 모양에 대한 모든 세부 정보를 설명합니다. 또한 그룹에 클라이언트를 추가하는 데 필요한 정보를 저장하기 위해 클라이언트 KeyPackage 개체에 사용됩니다.

```text
   enum {
       reserved(0),
       key_package(1),
       update(2),
       commit(3),
       (255)
   } LeafNodeSource;

   struct {
       ProtocolVersion versions<V>;
       CipherSuite cipher_suites<V>;
       ExtensionType extensions<V>;
       ProposalType proposals<V>;
       CredentialType credentials<V>;
   } Capabilities;

   struct {
       uint64 not_before;
       uint64 not_after;
   } Lifetime;

   // See the "MLS Extension Types" IANA registry for values
   uint16 ExtensionType;

   struct {
       ExtensionType extension_type;
       opaque extension_data<V>;
   } Extension;

   struct {
       HPKEPublicKey encryption_key;
       SignaturePublicKey signature_key;
       Credential credential;
       Capabilities capabilities;

       LeafNodeSource leaf_node_source;
       select (LeafNode.leaf_node_source) {
           case key_package:
               Lifetime lifetime;

           case update:
               struct{};

           case commit:
               opaque parent_hash<V>;
       };

       Extension extensions<V>;
       /* SignWithLabel(., "LeafNodeTBS", LeafNodeTBS) */
       opaque signature<V>;
   } LeafNode;

   struct {
       HPKEPublicKey encryption_key;
       SignaturePublicKey signature_key;
       Credential credential;
       Capabilities capabilities;

       LeafNodeSource leaf_node_source;
       select (LeafNodeTBS.leaf_node_source) {
           case key_package:
               Lifetime lifetime;

           case update:
               struct{};

           case commit:
               opaque parent_hash<V>;
       };

       Extension extensions<V>;

       select (LeafNodeTBS.leaf_node_source) {
           case key_package:
               struct{};

           case update:
               opaque group_id<V>;
               uint32 leaf_index;

           case commit:
               opaque group_id<V>;
               uint32 leaf_index;
       };
   } LeafNodeTBS;
```

encryption\_key 필드에는 이 리프를 점유하는 구성원\(또는 KeyPackage 개체에 있는 LeafNode의 경우 KeyPackage 발급자\)만이 개인 키를 보유하는 HPKE 공개 키가 포함되어 있습니다. signature\_key 필드에는 구성원의 공개 서명 키가 포함됩니다. 자격 증명 필드에는 섹션 5.3에 설명된 대로 구성원의 신원과 제공된 서명 키를 모두 인증하는 정보가 포함되어 있습니다.

기능 필드는 프로토콜 버전, 암호화 제품군, 자격 증명 유형, 기본이 아닌 제안 유형 및 기본이 아닌 확장 유형을 포함하여 클라이언트가 지원하는 프로토콜 기능을 나타냅니다. 다음 제안 및 확장 유형은 "기본"으로 간주되며 나열되지 않아야 합니다.\(MUST NOT\)

```text
   *  Proposal types:

      -  0x0001 - add

      -  0x0002 - update

      -  0x0003 - remove

      -  0x0004 - psk

      -  0x0005 - reinit

      -  0x0006 - external_init

      -  0x0007 - group_context_extensions

   *  Extension types:

      -  0x0001 - application_id

      -  0x0002 - ratchet_tree

      -  0x0003 - required_capabilities

      -  0x0004 - external_pub

      -  0x0005 - external_senders
```

기능 개체의 다른 필드에 대한 기본값은 없습니다. 클라이언트는 지원하는 각 매개변수의 모든 값을 나열해야 합니다.\(MUST\)

LeafNode의 확장 필드에 나타나는 기본이 아닌 확장의 유형은 기능 필드의 확장 필드에 포함되어야 하며 LeafNode에서 사용되는 자격 증명 유형은 기능 필드의 자격 증명 필드에 포함되어야 합니다.\(MUST\)

섹션 13에서 논의한 바와 같이, 능력치의 알 수 없는 값은 반드시 무시되어야 하며, 능력치 필드의 생성자는 다른 클라이언트가 알 수 없는 값을 올바르게 무시할 수 있도록 임의의 GREASE 값을 포함해야 합니다\(SHOULD\).\(MUST\)

leaf\_node\_source 필드는 이 LeafNode가 어떻게 트리에 추가되었는지를 나타냅니다. 이 신호는 그룹의 다른 구성원에게 리프 노드가 평생 또는 parent\_hash를 가져야 하는지 여부와 group\_id가 서명에 컨텍스트로 추가되는지 여부를 알려줍니다. 이러한 필드는 LeafNode를 생성하는 클라이언트가 항상 모든 필드를 계산할 수 있는 것은 아니기 때문에 선택적으로 포함됩니다. 예를 들어 KeyPackage는 클라이언트가 함께 사용할 그룹을 알기 전에 생성되므로 서명이 group\_id에 바인딩될 수 없습니다.

미리 게시된 KeyPackage를 기반으로 리프가 트리에 추가된 경우 수명 필드는 클라이언트가 LeafNode가 유효한 것으로 간주하는 시간을 나타냅니다. 이 시간은 Unix 시대\(1970-01-01T00:00:00Z\) 이후 초 단위로 측정된 절대 시간으로 표시됩니다. 애플리케이션은 LeafNode에 허용되는 최대 총 수명을 정의하고 총 수명이 이 기간보다 긴 모든 LeafNode를 거부해야 합니다. LeafNode가 유효한 수명을 가지고 있는지에 대한 의견 불일치를 피하기 위해 그룹의 클라이언트는 시간 동기화를 유지해야 합니다\(예: 네트워크 시간 프로토콜 \[RFC5905\] 사용\).\(MUST, SHOULD\)

커밋 메시지를 통해 리프 노드가 트리에 삽입된 경우 parent\_hash 필드에는 이 리프 노드에 대한 부모 해시가 포함됩니다\(섹션 7.9 참조\).

LeafNodeTBS 구조는 LeafNode의 서명 위의 필드를 포함합니다. 또한 그룹 컨텍스트에서 리프 노드가 생성된 경우\(업데이트 및 커밋 사례\) 그룹의 그룹 ID가 시그니처에 컨텍스트로 추가됩니다.

그룹의 래칫 트리에 저장된 LeafNode 개체는 트리의 진화에 따라 업데이트됩니다. LeafNode 콘텐츠의 각 수정은 서명의 변경으로 반영되어야 합니다. 이를 통해 다른 구성원은 특히 그룹에 새로 가입하는 경우 언제든지 LeafNode의 유효성을 확인할 수 있습니다.\(MUST\)

---
### **7.3.  Leaf Node Validation**

LeafNode의 유효성은 다음 단계에서 확인해야 합니다.

\* LeafNode가 KeyPackage에 다운로드되면 클라이언트를 그룹에 추가하는 데 사용되기 전에

\* 추가, 업데이트 또는 커밋 메시지에서 그룹 구성원이 LeafNode를 수신한 경우

\* 클라이언트가 래칫 트리를 확인할 때\(예: 그룹에 가입할 때 또는 Commit 처리 후\)

클라이언트는 다음 단계를 사용하여 LeafNode의 유효성을 확인합니다.

\* 섹션 5.3.1에 설명된 대로 LeafNode의 자격 증명이 유효한지 확인합니다.

\* 다음을 사용하여 LeafNode의 서명이 유효한지 확인합니다.

-signature\_key.

\* LeafNode가 그룹의 노드와 호환되는지 확인하십시오.

- 매개변수. GroupContext에 required\_capabilities 확장이 있는 경우 필수 확장, 제안 및 자격 증명 유형이 LeafNode의 기능 필드에 나열되어야 합니다.\(MUST\)

\* 자격 증명 유형이 각 구성원의 LeafNode의 기능 필드에 지정된 대로 그룹의 모든 구성원에 의해 지원되고 이 LeafNode의 기능 필드가 다른 구성원이 현재 사용 중인 모든 자격 증명 유형에 대한 지원을 나타내는지 확인합니다.

\* 수명 필드 확인:

- - 클라이언트가 보내는 메시지\(예: Proposal 또는 Commit\)에 LeafNode가 나타나면 클라이언트는 현재 시간이 수명 필드 범위 내에 있는지 확인해야 합니다.\(MUST\)

- - 대신 LeafNode가 클라이언트가 수신하는 메시지\(예: 제안, 커밋 또는 클라이언트가 가입하는 그룹의 래칫 트리\)에 나타나면 클라이언트가 현재 시간이 수명 필드의 범위. \(메시지가 전송된 시점과 수신된 시점 사이에 LeafNode가 만료되었을 수 있으므로 이 검사는 필수가 아닙니다.\)\(SHOULD\)

\* Extensions 필드의 각 확장에 대한 ID가 LeafNode의 capability.extensions 필드에 나열되어 있는지 확인하여 LeafNode의 확장이 지원되는지 확인합니다.

\* leaf\_node\_source 필드를 확인합니다.

- LeafNode가 KeyPackage에 나타나면 다음을 확인하십시오.

- leaf\_node\_source는 key\_package로 설정됩니다.

- - 업데이트 제안에 LeafNode가 나타나는 경우, leaf\_node\_source가 업데이트로 설정되고 encryption\_key가 업데이트 제안으로 대체되는 리프 노드의 encryption\_key와 다른 공개 키를 나타내는지 확인합니다.

- 의 leaf\_node 값에 LeafNode가 나타나는 경우

- 커밋에서 UpdatePath, leaf\_node\_source가 커밋으로 설정되어 있는지 확인합니다.

\* 다음 필드가 그룹 구성원 간에 고유한지 확인합니다.

```text
      -  signature_key

      -  encryption_key
```

---
### **7.4.  Ratchet Tree Evolution**

구성원이 에포크 변경\(즉, 커밋, 섹션 12.4 참조\)을 시작할 때마다 순방향 보안 및 손상 후 보안을 유지하기 위해 잎의 키 쌍과 잎의 직접 경로에 있는 노드의 키 쌍을 새로 고쳐야 할 수 있습니다.

에포크 변경을 시작하는 구성원은 다음 절차를 사용하여 새로운 키 쌍을 생성합니다. 이 절차는 섹션 7.6에 설명된 대로 그룹 구성원이 다른 그룹 구성원에게 새로운 비밀 키를 효율적으로 전달할 수 있도록 설계되었습니다.

구성원은 다음과 같이 직접 경로를 따라 노드를 업데이트합니다.

\* 리프에서 루트까지의 직접 경로에 있는 모든 노드를 비웁니다.

\* 리프에 대한 새로운 HPKE 키 쌍을 생성합니다.

\* 다음과 같이 리프의 필터링된 직접 경로에 있는 각 노드에 대해 하나씩 경로 암호 시퀀스를 생성합니다. 이 설정에서 path\_secret\[0\]은 필터링된 직접 경로의 첫 번째 부모 노드, path\_secret\[1\]은 두 번째 부모 노드 등을 나타냅니다.

```text
   path_secret[0] is sampled at random
   path_secret[n] = DeriveSecret(path_secret[n-1], "path")
```

\* HPKE 키 쌍\(node\_priv,node\_pub\)의 시퀀스를 다음과 같이 리프의 직접 경로에 있는 각 노드에 대해 하나씩 계산합니다.

```text
   node_secret[n] = DeriveSecret(path_secret[n], "node")
   node_priv[n], node_pub[n] = KEM.DeriveKeyPair(node_secret[n])
```

노드 암호는 임시 중간 암호로 파생되므로 각 암호는 하나의 알고리즘에만 사용됩니다. 경로 암호는 DeriveSecret에 대한 입력으로 사용되고 노드 암호는 DeriveKeyPair에 대한 입력으로 사용됩니다.

예를 들어, C가 Z에 병합되지 않은 리프인 4명의 구성원이 있는 그룹이 있다고 가정합니다.

```text
         Y
         |
       .-+-.
      /     \
     X       Z[C]
    / \     / \
   A   B   C   D

   0   1   2   3
```

- 그림 13: 하나의 병합되지 않은 리프가 있는 전체 트리

멤버 B가 이후에 비밀 "leaf\_secret"을 기반으로 UpdatePath를 생성하면 다음과 같은 경로 비밀 시퀀스가 ​​생성됩니다.

```text
   path_secret[1] ---> node_secret[1] -------> node_priv[1], node_pub[1]

        ^
        |
        |
   path_secret[0] ---> node_secret[0] -------> node_priv[0], node_pub[0]

        ^
        |
        |
   leaf_secret ------> leaf_node_secret --+--> leaf_priv, leaf_pub
                                              |                   |
                                               '-------. .-------'
                                                        |
                                                    leaf_node

       Figure 14: Derivation of Ratchet Tree Keys along a Direct Path
```

UpdatePath를 적용한 후 트리의 구조는 다음과 같습니다.

```text
   node_priv[1] --------> Y'
                          |
                        .-+-.
                       /     \
   node_priv[0] ----> X'      Z[C]
                     / \     / \
                    A   B   C   D
                        ^
   leaf_priv -----------+
                    0   1   2   3
```

- 그림 15: 래칫 트리에 키 배치

---
### **7.5.  Synchronizing Views of the Tree**

새로운 키 자료를 생성하고 이를 적용하여 섹션 7.4에 설명된 대로 로컬 트리 상태를 업데이트한 후 생성기는 Commit 메시지에서 그룹의 다른 구성원에게 이 업데이트를 브로드캐스트합니다. 발신자의. 보다 구체적으로, 구성원이 트리에 대한 변경 사항을 커밋할 때\(예: 구성원을 추가하거나 제거하기 위해\) 해당 리프의 필터링된 직접 경로에 있는 중간 노드에 대한 공개 키 집합과 암호화된 경로 암호를 포함하는 UpdatePath를 전송합니다. 그룹의 다른 구성원은 이 값을 사용하여 트리 보기를 업데이트하고 트리 복사본을 발신자의 트리 복사본에 맞춥니다.

UpdatePath에는 루트를 포함하여 발신자 리프의 필터링된 직접 경로에 있는 각 노드에 대한 다음 정보가 포함됩니다.

\* 노드의 공개 키

\* 노드에 해당하는 경로 비밀의 하나 이상의 암호화된 사본

주어진 노드에 대한 경로 비밀 값은 부모의 업데이트되지 않은 자식, 즉 발신자 리프 노드의 공동 경로에 있는 자식을 기반으로 하는 하위 트리로 암호화됩니다. 업데이트되지 않은 자식의 확인에서 각 공개 키에 대한 경로 비밀의 암호화가 하나씩 있습니다.

그룹의 구성원은 다음과 같이 필터링된 직접 경로를 따라 리프 노드 및 노드에 대한 새 값을 계산하여 직접 경로를 업데이트합니다.

1. 발신자 리프의 직접 경로를 따라 모든 노드를 비웁니다.

2. 발신자의 필터링된 직접 경로에 있는 노드에 대한 업데이트된 경로 비밀 및 공개 키를 계산합니다.

- \* 섹션 7.4에 정의된 대로 필터링된 직접 경로와 동일한 길이의 경로 암호 시퀀스를 생성합니다.

- \* 필터링된 직접 경로의 각 노드에 대해 노드의 공개 키를 해당 경로 비밀 path\_secret\[n\]에서 파생된 node\_pub\[n\] 값으로 바꿉니다.

3. 필터링된 직접 경로와 발신자의 리프 노드를 따라 노드에 대한 새 부모 해시를 계산합니다.

4. 발신자의 리프 노드를 업데이트합니다.

- \* 커밋할 leaf\_node\_source를 설정합니다.

- \* encryption\_key를 새로 샘플링된 키 쌍의 공개 키로 설정합니다.

- \* 상위 해시를 리프의 상위 해시로 설정합니다.

- \* 새 내용으로 리프 노드를 다시 서명합니다.

새 리프 노드는 그룹의 기존 리프 노드를 효과적으로 업데이트하므로 업데이트 제안에 사용된 LeafNodes와 동일한 제한을 준수해야 합니다\(leaf\_node\_source 제외\). 애플리케이션은 리프 노드에 대한 다른 변경 사항을 지정할 수 있습니다\(예: 새 서명 키, 업데이트된 기능 또는 다른 확장 제공\).\(MUST, MAY\)

그런 다음 구성원은 그룹에 대한 경로 비밀을 \_암호화합니다\_. 구성원의 필터링된 직접 경로에 있는 각 노드에 대해 구성원은 다음 단계를 수행합니다.

1. 발신자의 copath에 있는 노드의 자식\(발신자의 직접 경로에 없는 자식\)의 해상도를 계산합니다. 동일한 커밋에 추가된 모든 새 멤버\(추가 제안에서\)는 이 해결에서 제외되어야 합니다.\(MUST\)

2. 분석의 각 노드에 대해 섹션 7.6에 정의된 대로 분석 노드의 공개 키를 사용하여 직접 경로 노드의 경로 비밀을 암호화합니다.

UpdatePath 수신자는 해당 단계를 수행합니다. 먼저 수신자는 \_UpdatePath를 트리\_로 병합합니다.

1. 발신자 리프의 직접 경로에 있는 모든 노드를 비웁니다.

2. 발신자 리프의 필터링된 직접 경로에 있는 모든 노드에 대해,

- \* UpdatePath에서 공개키를 공개키로 설정합니다.

- \* 병합되지 않은 리프 목록을 빈 목록으로 설정합니다.

3. 보낸 사람의 필터링된 직접 경로에 있는 노드의 부모 해시를 계산하고 리프 노드의 parent\_hash 필드가 필터링된 직접 경로의 첫 번째 노드에 대한 부모 해시와 일치하는지 확인합니다.

- \* 이러한 해시는 루트에서 리프까지 계산되므로 각 해시는 그 위에 있는 모든 비어 있지 않은 노드를 통합합니다. 루트 노드에는 항상 부모 해시에 대한 길이가 0인 해시가 있습니다.

둘째, 수신자는 \_경로 비밀을 해독합니다\_:

1. 수신자가 업데이트되지 않은 자식의 하위 트리에 있는 필터링된 직접 경로에서 노드를 식별합니다.

2. 수신자가 개인 키를 가지고 있는 copath 노드의 해상도에서 노드를 식별합니다.

3. 해결 노드의 개인 키를 사용하여 copath 노드의 부모에 대한 경로 암호를 해독합니다.

4. 위에서 설명한 알고리즘을 사용하여 발신자의 필터링된 직접 경로에서 해당 노드의 조상에 대한 경로 암호를 유도합니다.

5. 경로 비밀에서 노드 비밀과 노드 키 쌍을 파생시킵니다.

6. 파생된 공개 키가 동일한지 확인합니다.

- UpdatePath에서 전송된 해당 공개 키.

7. 파생된 개인 키를 해당 래칫 트리 노드에 저장합니다.

예를 들어 섹션 7.4에 설명된 예제 업데이트를 전달하기 위해 노드 B의 구성원은 다음 값을 전송합니다.

```text
   +=============+====================================================+
   | Public Key  | Ciphertext(s)                                      |
   +=============+====================================================+
   | node_pub[1] | E(pk(Z), path_secret[1]), E(pk(C), path_secret[1]) |
   +-------------+----------------------------------------------------+
   | node_pub[0] | E(pk(A), path_secret[0])                           |
   +-------------+----------------------------------------------------+

                                 Table 3
```

이 표에서 node\_pub\[i\] 값은 node\_secret\[i\]에서 파생된 공개 키를 나타내고, pk\(X\)는 노드 X의 현재 공개 키를 나타내며, E\(K, S\)는 경로 비밀의 공개 키 암호화를 나타냅니다. S에서 공개 키 K로\(HPKE 사용\).

노드 A의 수신자는 E\(pk\(A\), path\_secret\[0\]\)를 해독하여 path\_secret\[0\]를 얻은 다음 이를 사용하여 path\_secret\[1\] 및 결과 노드 암호와 키 쌍을 파생합니다. 따라서 A는 트리 불변성에 따라 노드 X' 및 Y'에 대한 개인 키를 갖게 됩니다.

마찬가지로 노드 D의 수신자는 E\(pk\(Z\), path\_secret\[1\]\)를 해독하여 path\_secret\[1\]을 얻은 다음 이를 사용하여 노드 Y'에 대한 노드 암호 및 키 쌍을 파생합니다. 트리 불변성을 유지하기 위해 필요에 따라 노드 D는 X'가 D의 조상이 아니므로 노드 X'에 대한 개인 키를 수신하지 않습니다.

업데이트를 처리한 후 각 수신자는 특히 다음과 같은 오래된 키 자료를 삭제해야 합니다.\(MUST\)

\* 업데이트된 각 노드 키 쌍을 파생시키는 데 사용되는 경로 비밀 및 노드 비밀.

\* 업데이트로 대체된 각 오래된 노드 키 쌍.

---
### **7.6.  Update Paths**

섹션 12.4에서 설명한 것처럼 각 Commit 메시지에는 발신자의 필터링된 직접 경로에 대한 새 LeafNode 및 부모 노드 집합과 함께 UpdatePath가 선택적으로 포함될 수 있습니다. 각 상위 노드에 대해 UpdatePath에는 새 공개 키와 암호화된 경로 비밀이 포함됩니다. 상위 노드는 필터링된 직접 경로와 동일한 순서로 유지됩니다.

```text
   struct {
       opaque kem_output<V>;
       opaque ciphertext<V>;
   } HPKECiphertext;

   struct {
       HPKEPublicKey encryption_key;
       HPKECiphertext encrypted_path_secret<V>;
   } UpdatePathNode;

   struct {
       LeafNode leaf_node;
       UpdatePathNode nodes<V>;
   } UpdatePath;
```

각 UpdatePathNode에 대해 해당 copath 노드의 해결은 현재 Commit의 일부로 추가된 모든 새 리프 노드를 제외해야 합니다. encryption\_path\_secret 벡터의 길이는 각 암호문이 각 해결 노드에 대한 암호화인 copath 노드\(새 리프 노드 제외\)의 해상도 길이와 같아야 합니다.\(MUST, MUST\)

HPKECiphertext 값은 다음과 같이 암호화 및 해독됩니다.

```text
   (kem_output, ciphertext) =
     EncryptWithLabel(node_public_key, "UpdatePathNode",
                      group_context, path_secret)

   path_secret =
     DecryptWithLabel(node_private_key, "UpdatePathNode",
                      group_context, kem_output, ciphertext)
```

여기서 node\_public\_key는 경로 비밀이 암호화된 노드의 공개 키이고, group\_context는 그룹에 대한 임시 GroupContext 개체이며, EncryptWithLabel 함수는 섹션 5.1.3에 정의된 대로입니다.

---
### **7.7.  Adding and Removing Leaves**

위에서 설명한 트리에 대한 경로 기반 업데이트 외에도 그룹 구성원에 대한 변경 사항을 반영하기 위해 트리의 리프를 추가하고 제거해야 합니다\(섹션 12.1.1 및 12.1.3 참조\). 나무는 항상 가득 차 있기 때문에 잎을 추가하거나 제거하는 것은 나무의 깊이를 늘리거나 줄이는 것과 일치하여 잎의 수가 두 배가 되거나 반으로 줄어듭니다. 이러한 작업은 트리 \_extending\_ 및 \_truncating\_이라고도 합니다.

리프는 항상 트리의 오른쪽 가장자리에서 추가 및 제거됩니다. 트리의 크기를 늘려야 할 때 새로운 빈 루트 노드가 추가되는데, 왼쪽 하위 트리는 기존 트리이고 오른쪽 하위 트리는 완전히 비어 있는 새 하위 트리입니다. 이 작업은 일반적으로 그룹에 구성원을 추가할 때 수행됩니다.

```text
                     _ <-- new blank root                    _
                   __|__                                   __|__
                  /     \                                 /     \
     X    ===>   X       _ <-- new blank subtree ===>    X       _
    / \         / \     / \                             / \     / \
   A   B       A   B   _   _                           A   B   C   _
                                                               ^
                                                               |
                                                  new member --+

       Figure 16: Extending the Tree to Make Room for a Third Member
```

트리의 오른쪽 하위 트리에 더 이상 비어 있지 않은 노드가 없으면 안전하게 제거할 수 있습니다. 트리의 루트와 오른쪽 하위 트리는 삭제됩니다\(루트 노드가 비어 있는지 여부\). 루트의 왼쪽 자식이 새 루트 노드가 되고 왼쪽 하위 트리가 새 트리가 됩니다. 이 작업은 일반적으로 그룹에서 구성원을 제거한 후에 수행됩니다.

```text
                  Y                  Y
                __|__              __|__
               /     \            /     \
              X       _   ===>   X       _   ==>   X <-- new root
             / \     / \        / \     / \       / \
            A   B   C   _      A   B   _   _     A   B
                    ^
                    |
   removed member --+
```

- 그림 17: 멤버 C 제거 후 청소

배열 기반 및 링크 기반 트리에서 이러한 작업을 위한 구체적인 알고리즘은 부록 C 및 D에 제공됩니다. 구체적인 알고리즘은 비표준입니다. 구현은 내부 표현에서 올바른 트리를 생성하는 모든 알고리즘을 사용할 수 있습니다.

---
### **7.8.  Tree Hashes**

MLS는 트리의 서로 다른 속성을 인증하기 위해 두 가지 방법으로 트리의 내용을 해시합니다. \_트리 해시\_는 이 섹션에서 정의되고 \_부모 해시\_는 섹션 7.9에서 정의됩니다.

래칫 트리의 각 노드에는 해당 노드 아래의 하위 트리를 요약하는 트리 해시가 있습니다. 루트의 트리 해시는 그룹이 전체 트리에 동의하는지 확인하기 위해 GroupContext에서 사용됩니다. 트리 해시는 리프에서 루트까지 재귀적으로 계산됩니다.

```text
   P --> th(P)
         ^ ^
        /   \
       /     \
   th(L)     th(R)
```

- 그림 18: 트리 해시 구성

개별 노드의 트리 해시는 노드 유형에 따라 LeafNodeHashInput 또는 ParentNodeHashInput을 포함할 수 있는 노드의 TreeHashInput 개체의 해시입니다. LeafNodeHashInput 개체에는 leaf\_index 및 LeafNode\(있는 경우\)가 포함됩니다. ParentNodeHashInput 개체에는 ParentNode\(있는 경우\)와 노드의 왼쪽 및 오른쪽 자식에 대한 트리 해시가 포함됩니다. 상위 노드와 리프 노드 모두에 대해 노드가 비어 있으면 선택적 노드 값이 없어야 하고 노드에 값이 포함되어 있으면 존재해야 합니다.\(MUST\)

```text
   enum {
       reserved(0),
       leaf(1),
       parent(2),
       (255)
   } NodeType;

   struct {
     NodeType node_type;
     select (TreeHashInput.node_type) {
       case leaf:   LeafNodeHashInput leaf_node;
       case parent: ParentNodeHashInput parent_node;
     };
   } TreeHashInput;

   struct {
       uint32 leaf_index;
       optional<LeafNode> leaf_node;
   } LeafNodeHashInput;

   struct {
       optional<ParentNode> parent_node;
       opaque left_hash<V>;
       opaque right_hash<V>;
   } ParentNodeHashInput;
```

전체 트리의 트리 해시는 루트 노드의 트리 해시에 해당하며 리프 노드에서 시작하여 재귀적으로 계산됩니다.

---
### **7.9.  Parent Hashes**

트리 해시는 특정 시점의 트리 상태를 요약하지만 부모 해시는 트리의 키가 채워진 방식에 대한 정보를 캡처합니다.

클라이언트가 커밋을 보내 그룹을 변경하면 필터링된 직접 경로를 따라 노드에 새 키를 할당하는 UpdatePath를 포함할 수 있습니다. 클라이언트가 UpdatePath\(섹션 7.5에 정의됨\)를 계산할 때 UpdatePath가 적용된 후 트리의 상태를 요약하는 상위 해시를 계산하고 서명합니다. 이러한 요약은 하나의 UpdatePath에 설정된 노드가 이후 UpdatePath에 의해 재설정될 때 루트에 더 가까운 체인 부분을 덮어쓸 수 있도록 루트에서 구성원의 리프까지 체인으로 구성됩니다.

```text
                        ph(Q)
                        /
                       /
                      V
   P.public_key --> ph(P)
                    / ^
                   /   \
                  V     \
      N.parent_hash     th(S)
```

- 그림 19: 상위 해시에 대한 입력

결과적으로 각 구성원의 리프에 있는 상위 해시에 대한 서명은 해당 리프가 UpdatePath에서 마지막으로 변경된 이후 변경되지 않은 트리의 하위 트리에 효과적으로 서명합니다. 그룹에 합류하는 새 구성원은 이러한 부모 해시를 사용하여 트리의 부모 노드가 외부 공격자가 선택한 것이 아니라 그룹 구성원에 의해 설정되었는지 확인합니다. 이것이 어떻게 작동하는지에 대한 예는 부록 B를 참조하십시오.

비어 있지 않은 부모 노드 P와 자식 D 및 S\("부모", "직접 경로" 및 "형제"에 대해\)가 있는 래칫 트리를 고려하십시오. D 및 P는 리프 노드 L의 직접 경로에 있습니다\(" 잎"\):

```text
            ...
            /
           P
         __|__
        /     \
       D       S
      / \     / \
    ... ... ... ...
    /
   L

           Figure 20: Nodes Involved in a Parent Hash Computation
```

P의 상위 해시는 UpdatePath 개체가 노드 D\(및 P\)를 통과하는 리프 L의 경로를 따라 래칫 트리에 적용될 때마다 변경됩니다. 새로운 "P의 부모 해시\(copath 자식 S 포함\)"는 P의 ParentHashInput 구조체를 해싱하여 얻습니다.

```text
   struct {
       HPKEPublicKey encryption_key;
       opaque parent_hash<V>;
       opaque original_sibling_tree_hash<V>;
   } ParentHashInput;
```

encryption\_key 필드에는 P의 HPKE 공개 키가 포함되어 있습니다. P가 루트이면 parent\_hash 필드는 길이가 0인 옥텟 문자열로 설정됩니다. 그렇지 않으면 parent\_hash는 리프 L의 필터링된 직접 경로에서 P 이후 다음 노드의 부모 해시입니다. 이런 식으로 P의 부모 해시는 P에서 루트까지의 경로에서 비어 있지 않은 각 노드의 새 HPKE 공개 키를 수정합니다. P에서 루트까지의 경로에는 P의 부모 해시에 의해 고정되지 않은 일부 빈 노드가 포함될 수 있습니다. 그러나 HPKE 키가 있는 각 노드의 경우 이 키는 P의 상위 해시로 고정됩니다.

마지막으로 original\_sibling\_tree\_hash는 다음과 같이 수정된 래칫 트리에서 S의 트리 해시입니다. P.unmerged\_leaves의 각 리프 L에 대해 L을 비우고 모든 부모 노드의 unmerged\_leaves 세트에서 제거합니다.

original\_sibling\_tree\_hash가 P 업데이트 간에 변경되지 않는지 확인합니다. 이 속성은 프로토콜의 정확성에 중요합니다.

original\_sibling\_tree\_hash는 부모 해시가 아니라 S의 트리 해시입니다. ParentHashInput의 parent\_hash 필드는 P 위의 노드에 대한 정보를 캡처합니다. original\_sibling\_tree\_hash는 업데이트되지 않는 S 아래의 하위 트리\(따라서 섹션 7.5에 따라 P에 대한 경로 비밀이 암호화되는 하위 트리\)에 대한 정보를 캡처합니다.

예를 들어, 다음 트리에서:

```text
                 W [F]
           ______|_____
          /             \
         U               Y [F]
       __|__           __|__
      /     \         /     \
     T       _       _       _
    / \     / \     / \     / \
   A   B   C   D   E   F   G   _

          Figure 21: A Tree Illustrating Parent Hash Computations
```

P = W 및 S = Y인 경우 original\_sibling\_tree\_hash는 다음 트리의 트리 해시입니다.

```text
         Y
       __|__
      /     \
     _       _
    / \     / \
   E   _   G   _
```

W.unmerged\_leaves는 F를 포함하므로 F는 Y.unmerged\_leaves에서 비워지고 제거됩니다.

P가 마지막으로 업데이트된 이후 S의 트리 해시가 변경되지 않은 경우 재계산이 필요하지 않습니다. 이는 Commit 자체가 P를 재설정하기 때문에 UpdatePath가 P를 통과하는 Commit을 계산하거나 처리하는 경우입니다. P.unmerged\_leaves의 항목 중 어느 것도 S 아래의 하위 트리에 없으면\(따라서 비어 있는 리프가 없는 경우\) S의 원래 트리 해시는 현재 트리에 있는 S의 트리 해시입니다.

노드의 원래 트리 해시를 다시 계산해야 하는 경우 중간 트리 해시를 캐싱하여 하위 트리가 여러 부모 해시에 포함될 때 하위 트리에 대해 다시 계산하지 않도록 하여 재계산의 효율성을 높일 수 있습니다. 하위 트리와 병합되지 않은 부모 잎의 교차가 이전 계산에서와 동일하면 하위 트리 해시를 재사용할 수 있습니다.

---
#### **7.9.1.  Using Parent Hashes**

ParentNode 개체 및 leaf\_node\_source가 커밋으로 설정된 LeafNode 개체에서 parent\_hash 필드의 값은 해당 노드 위의 비어 있지 않은 다음 부모 노드\(필터링된 직접 경로의 다음 노드\)의 부모 해시입니다. 그림 20의 노드 레이블을 사용하면 D의 parent\_hash 필드는 공동 경로 자식 S가 있는 P의 부모 해시와 같습니다. 노드 D가 리프 노드인 경우에도 마찬가지입니다.

LeafNode의 parent\_hash 필드는 구성원이 서명합니다. 따라서 이러한 LeafNode의 서명은 LeafNode의 다른 내용 외에도 그룹 구성원이 래칫 트리에 도입한 키와 해당 비밀 키가 누구에게 전송되었는지를 증명합니다. 이렇게 하면 악의적인 내부자가 내부자에게 HPKE 비밀 키가 알려져 있지만 내부자에게 D에 뿌리를 둔 하위 트리의 리프가 할당되지 않은 노드 D로 인공 래칫 트리를 구성하는 것을 방지할 수 있습니다. 실제로 이러한 래칫 트리는 트리를 위반합니다. 불변.

---
#### **7.9.2.  Verifying Parent Hashes**

상위 해시는 프로토콜의 두 지점에서 확인됩니다. 그룹에 가입할 때와 커밋을 처리할 때입니다.

노드 D의 상위 해시는 다음 기준이 유지되는 경우 상위 노드 P에 대해 유효합니다. 여기서 C와 S는 P의 자식\("자식" 및 "형제"\)이며, C는 D의 직접 경로에 있는 자식\(아마도 D 자체\)이고 S는 다른 자식입니다.

\* D는 트리에서 P의 자손입니다.

\* D의 parent\_hash 필드는 공동 경로 자식 S가 있는 P의 부모 해시와 같습니다.

\* D는 C의 분해능에 있고 P의 교차점

- C 아래의 하위 트리가 있는 unmerged\_leaves는 D가 제거된 C의 해상도와 같습니다.

이러한 검사는 D와 P가 동시에 업데이트되었는지\(동일한 UpdatePath에서\), 그리고 이들 사이의 노드가 필터링된 직접 경로에서 생략되었기 때문에 UpdatePath의 이웃인지 확인합니다.

부모 노드 P는 이러한 방식으로 리프 노드에 다시 연결될 수 있는 경우 "부모-해시 유효"입니다. 즉, 리프 노드 L과 P\_N = P가 되는 일련의 부모 노드 P\_1, ..., P\_N이 있고 체인의 각 단계가 부모 해시에 의해 인증되면 L의 부모 해시는 P\_1에 대해 유효합니다. , P\_1의 상위 해시는 P\_2와 관련하여 유효합니다.

그룹에 가입할 때 새 구성원은 공백이 아닌 각 부모 노드 P가 부모 해시가 유효한지 인증해야 합니다. 이는 리프에서 체인을 구축하고 비어 있지 않은 모든 부모 노드가 정확히 하나의 체인으로 덮여 있는지 확인하여 "상향식"으로 수행하거나 비어 있지 않은 각 부모 노드의 자손이 정확히 하나 있는지 확인하여 "하향식"으로 수행할 수 있습니다. 부모 노드가 부모-해시 유효한 노드.\(MUST\)

UpdatePath를 포함하는 Commit 메시지를 처리할 때 클라이언트는 커미터의 새 리프에 대한 parent\_hash의 예상 값을 다시 계산하고 제공된 leaf\_node의 parent\_hash 값과 일치하는지 확인해야 합니다. 트리에 병합된 후 UpdatePath의 노드는 커미터의 리프에서 루트까지 상위-해시 체인을 형성합니다.\(MUST\)

---
## **8.  Key Schedule**

그룹 키는 그룹의 암호 제품군에 대한 KDF의 Extract 및 Expand 기능과 아래에 정의된 기능을 사용하여 파생됩니다.

```text
   ExpandWithLabel(Secret, Label, Context, Length) =
       KDF.Expand(Secret, KDFLabel, Length)

   DeriveSecret(Secret, Label) =
       ExpandWithLabel(Secret, Label, "", KDF.Nh)
```

여기서 KDFLabel은 다음과 같이 지정됩니다.

```text
   struct {
       uint16 length;
       opaque label<V>;
       opaque context<V>;
   } KDFLabel;
```

그리고 해당 필드는 다음과 같이 설정됩니다.

```text
   length = Length;
   label = "MLS 1.0 " + Label;
   context = Context;
```

KDF.Nh 값은 KDF.Extract의 출력 크기\(바이트\)입니다. 아래 다이어그램에서:

\* KDF.Extract는 상단에서 salt 인수를, 왼쪽에서 IKM\(Input Keying Material\) 인수를 가져옵니다.

\* DeriveSecret은 들어오는 화살표에서 Secret 인수를 가져옵니다.

\* 0은 길이가 KDF.Nh인 모두 0인 바이트 문자열을 나타냅니다.

핸드셰이크 메시지를 처리할 때 클라이언트는 다음 정보를 결합하여 새로운 epoch secret을 도출합니다.

\* 이전 시대의 초기 비밀

\* 현재 epoch의 커밋 시크릿

\* 현재 시대의 GroupContext 객체

이러한 입력이 주어지면 다음 다이어그램과 같이 epoch에 대한 비밀 파생이 진행됩니다.

```text
                    init_secret_[n-1]
                          |
                          |
                          V
    commit_secret --> KDF.Extract
                          |
                          |
                          V
                  ExpandWithLabel(., "joiner", GroupContext_[n], KDF.Nh)
                          |
                          |
                          V
                     joiner_secret
                          |
                          |
                          V
psk_secret (or 0) --> KDF.Extract
                          |
                          |
                          +--> DeriveSecret(., "welcome")
                          |    = welcome_secret
                          |
                          V
                  ExpandWithLabel(., "epoch", GroupContext_[n], KDF.Nh)
                          |
                          |
                          V
                     epoch_secret
                          |
                          |
                          +--> DeriveSecret(., <label>)
                          |    = <secret>
                          |
                          V
                    DeriveSecret(., "init")
                          |
                          |
                          V
                    init_secret_[n]

                   Figure 22: The MLS Key Schedule
```

다양한 목적을 위해 epoch secret에서 여러 값이 파생됩니다.

```text
    +==================+=====================+=======================+
    | Label            | Secret              | Purpose               |
    +==================+=====================+=======================+
    | "sender data"    | sender_data_secret  | Deriving keys to      |
    |                  |                     | encrypt sender data   |
    +------------------+---------------------+-----------------------+
    | "encryption"     | encryption_secret   | Deriving message      |
    |                  |                     | encryption keys (via  |
    |                  |                     | the secret tree)      |
    +------------------+---------------------+-----------------------+
    | "exporter"       | exporter_secret     | Deriving exported     |
    |                  |                     | secrets               |
    +------------------+---------------------+-----------------------+
    | "external"       | external_secret     | Deriving the external |
    |                  |                     | init key              |
    +------------------+---------------------+-----------------------+
    | "confirm"        | confirmation_key    | Computing the         |
    |                  |                     | confirmation MAC for  |
    |                  |                     | an epoch              |
    +------------------+---------------------+-----------------------+
    | "membership"     | membership_key      | Computing the         |
    |                  |                     | membership MAC for a  |
    |                  |                     | PublicMessage         |
    +------------------+---------------------+-----------------------+
    | "resumption"     | resumption_psk      | Proving membership in |
    |                  |                     | this epoch (via a PSK |
    |                  |                     | injected later)       |
    +------------------+---------------------+-----------------------+
    | "authentication" | epoch_authenticator | Confirming that two   |
    |                  |                     | clients have the same |
    |                  |                     | view of the group     |
    +------------------+---------------------+-----------------------+

                      Table 4: Epoch-Derived Secrets
```

external\_secret은 전체 그룹이 개인 키를 보유하는 HPKE 키 쌍을 파생시키는 데 사용됩니다.

```text
   external_priv, external_pub = KEM.DeriveKeyPair(external_secret)
```

비구성원이 외부 커밋을 사용하여 그룹에 가입할 수 있도록 공개 키 external\_pub를 GroupInfo 구조체의 일부로 게시할 수 있습니다.

---
### **8.1.  Group Context**

그룹의 각 구성원은 그룹의 상태를 요약하는 GroupContext 개체를 유지 관리합니다.

```text
   struct {
       ProtocolVersion version = mls10;
       CipherSuite cipher_suite;
       opaque group_id<V>;
       uint64 epoch;
       opaque tree_hash<V>;
       opaque confirmed_transcript_hash<V>;
       Extension extensions<V>;
   } GroupContext;
```

이 상태의 필드에는 다음 의미 체계가 있습니다.

\* cipher\_suite는 그룹에서 사용하는 암호 제품군입니다.

\* group\_id 필드는 그룹에 대한 애플리케이션 정의 식별자입니다.

\* epoch 필드는 그룹의 현재 버전을 나타냅니다.

\* tree\_hash 필드에는 섹션 7.8에 설명된 대로 그룹의 래칫 트리 내용에 대한 약속과 그룹 구성원의 자격 증명이 포함됩니다.

\* Confirmed\_transcript\_hash 필드에는 이 상태로 이어진 메시지에 대한 실행 해시가 포함되어 있습니다.

\* 확장 필드에는 모든 프로토콜의 세부 정보가 포함됩니다.

- 그룹에 적용되는 확장자.

새 구성원이 그룹에 추가되면 그룹의 기존 구성원이 새 구성원에게 환영 메시지를 제공합니다. 환영 메시지는 새 구성원이 GroupContext를 초기화하는 데 필요한 정보를 제공합니다.

그룹에 대한 다른 변경 사항은 그룹 상태에 다른 영향을 미칩니다. 이러한 영향은 섹션 12.1의 해당 하위 섹션에 설명되어 있습니다. 다음 일반 규칙이 적용됩니다.

\* group\_id 필드는 상수입니다.

\* epoch 필드는 처리되는 커밋 메시지마다 하나씩 증가합니다.

\* 현재 트리와 자격 증명을 나타내도록 tree\_hash가 업데이트됩니다.

\* Confirmed\_transcript\_hash 필드는 아래 설명된 대로 Commit 메시지를 인코딩하는 AuthenticatedContent에 대한 데이터로 업데이트됩니다.

\* GroupContextExtensions 제안이 커밋되면 확장 필드가 변경됩니다.

---
### **8.2.  Transcript Hashes**

MLS에서 계산된 트랜스크립트 해시는 그룹에서 전송된 모든 제안 및 커밋 메시지에 대해 실행 중인 해시를 나타냅니다. 커밋 메시지가 직접 포함됩니다. 제안 메시지는 이를 적용한 커밋을 통해 간접적으로 포함됩니다. 두 유형의 메시지는 전송된 AuthenticatedContent 개체를 해싱하여 포함됩니다.

성적표 해시는 두 개의 개별 해시로 구성됩니다.

\* 가장 최근 Commit의 서명을 포함하여 Commit 메시지의 전체 기록에 대한 기록을 나타내는 Confirmed\_transcript\_hash.

\* 확인된 성적표 해시와 가장 최근 Commit의 Confirmation\_tag를 포함하는 interim\_transcript\_hash.

새 구성원은 GroupInfo 구조체의 Confirmation\_tag 필드를 사용하여 임시 성적표 해시를 계산하지만 기존 구성원은 직접 계산할 수 있습니다.

각 Commit 메시지는 둘러싸는 AuthenticatedContent를 통해 이러한 해시를 업데이트합니다. AuthenticatedContent 구조체는 ConfirmedTranscriptHashInput 및 InterimTranscriptHashInput으로 분할됩니다. 전자는 확인된 성적표 해시를 업데이트하는 데 사용되고 후자는 중간 성적표 해시를 업데이트하는 데 사용됩니다.

```text
   struct {
       WireFormat wire_format;
       FramedContent content; /* with content_type == commit */
       opaque signature<V>;
   } ConfirmedTranscriptHashInput;

   struct {
       MAC confirmation_tag;
   } InterimTranscriptHashInput;

   confirmed_transcript_hash_[0] = ""; /* zero-length octet string */
   interim_transcript_hash_[0] = ""; /* zero-length octet string */

   confirmed_transcript_hash_[epoch] =
       Hash(interim_transcript_hash_[epoch - 1] ||
           ConfirmedTranscriptHashInput_[epoch]);

   interim_transcript_hash_[epoch] =
       Hash(confirmed_transcript_hash_[epoch] ||
           InterimTranscriptHashInput_[epoch]);
```

이 표기법에서 ConfirmedTranscriptHashInput\_\[epoch\] 및 InterimTranscriptHashInput\_\[epoch\]는 epoch 번호 epoch로 epoch를 시작한 커밋을 기반으로 합니다. \(이 커밋의 epoch필드는 이전 epoch 내에서 전송되므로 epoch - 1\`로 설정됩니다.\)

기록 해시 ConfirmedTranscriptHashInput\_\[epoch\]는 이 Commit의 Confirmation\_tag 필드에 대한 Confirmed\_transcript\_hash 입력으로 사용됩니다. 따라서 각 커밋은 최신 커밋의 확인 태그를 제외하고 해당 지점까지 커밋의 전체 기록을 확인합니다.

```text
                                                             ...

                                                              |
                                                              |
                                                              V
                                                     +-----------------+
                                                     |  interim_[N-1]  |
                                                     +--------+--------+
                                                              |
     .--------------.         +------------------+            |
    |  Ratchet Tree  |        | wire_format      |            |
    |  Key Schedule  |<-------+ content          |            |
     '-------+------'         |   epoch = N-1    +------------+
             |                |   commit         |            |
             V                | signature        |            V
 +------------------------+   +------------------+   +-----------------+
 |  confirmation_key_[N]  +-->| confirmation_tag |<--+  confirmed_[N]  |
 +------------------------+   +--------+---------+   +--------+--------+
                                       |                      |
                                       |                      V
                                       |             +-----------------+
                                       +------------>|   interim_[N]   |
                                                     +--------+--------+
                                                              |
     .--------------.         +------------------+            |
    |  Ratchet Tree  |        | wire_format      |            |
    |  Key Schedule  |<-------+ content          |            |
     '-------+------'         |   epoch = N      +------------+
             |                |   commit         |            |
             V                | signature        |            V
 +------------------------+   +------------------+   +-----------------+
 | confirmation_key_[N+1] +-->| confirmation_tag |<--+ confirmed_[N+1] |
 +------------------------+   +--------+---------+   +--------+--------+
                                       |                      |
                                       |                      V
                                       |             +-----------------+
                                       +------------>|  interim_[N+1]  |
                                                     +--------+--------+
                                                              |
                                                              V

                                                             ...
```

그림 23: 두 번의 에포크 변경을 통한 성적표 해시의 진화

---
### **8.3.  External Initialization**

위에서 설명한 KDF 호출을 통해 새 시대를 초기화하는 것 외에도 MLS 그룹은 이전 시대의 외부 키 쌍을 사용하여 비대칭 상호 작용을 통해 새 시대를 초기화할 수도 있습니다. 새 구성원이 외부 커밋을 통해 가입할 때 수행됩니다.

이 과정에서 조이너는 HPKE 내보내기 방법을 사용하여 새로운 init\_secret 값을 그룹에 보냅니다. 그런 다음 조이너는 GroupInfo 및 외부 커밋에 제공된 정보와 함께 해당 init\_secret을 사용하여 새 에포크에 대한 주요 일정의 복사본을 초기화합니다.

```text
   kem_output, context = SetupBaseS(external_pub, "")
   init_secret = context.export("MLS 1.0 external init secret", KDF.Nh)
```

그룹의 구성원은 ExternalInit 제안에서 kem\_output을 수신하고 해당 계산을 수행하여 init\_secret 값을 검색합니다.

```text
   context = SetupBaseR(kem_output, external_priv, "")
   init_secret = context.export("MLS 1.0 external init secret", KDF.Nh)
```

---
### **8.4.  Pre-Shared Keys**

공유 그룹 비밀을 생성하는 대역 외 메커니즘이 이미 있는 그룹은 MLS 그룹 비밀 계산에 이 외부 엔트로피를 통합하기 위해 MLS 키 일정에 이를 주입할 수 있습니다.

외부 PSK를 삽입하면 구성원 전체에서 전체 업데이트를 실행하는 데 비용이 너무 많이 드는 경우 또는 외부 그룹 키 설정 메커니즘이 기존 또는 양자 공격자에 대해 더 강력한 보안을 제공하는 경우 보안을 개선할 수 있습니다.

PSK는 업데이트와 다른 수명을 가질 수 있으므로 Commit 메시지와 동일한 순방향 비밀성 또는 손상 후 보안 보장을 반드시 제공하지는 않습니다. 항상 새로 생성되는 업데이트 또는 커밋에 의해 트리에 채워진 키 쌍과 달리 PSK는 미리 배포되고 저장될 수 있습니다. 이로 인해 배포 및 저장 과정에서 PSK가 손상될 수 있는 위험이 있습니다. 따라서 그룹이 PSK를 주입하여 얻는 보안은 PSK의 엔트로피와 손상 위험에 따라 달라집니다. 이러한 요소는 이 문서의 범위를 벗어나지만 PSK에 의존하는 애플리케이션 설계자는 고려해야 합니다.

MLS의 각 PSK에는 프로비저닝 방법을 지정하는 유형이 있습니다. 외부 PSK는 애플리케이션에서 제공하는 반면 재개 PSK는 MLS 키 일정에서 파생되며 이전 에포크에서 구성원의 참여를 인증해야 하는 경우에 사용됩니다.

주요 일정에 하나 이상의 PSK를 삽입하는 것은 두 가지 방식으로 신호를 받습니다. 기존 구성원은 Commit에서 다루는 PreSharedKey 제안을 통해 알림을 받고 Commit에 추가된 새 구성원은 Commit에 해당하는 환영 메시지의 GroupSecrets 개체를 통해 알립니다. . 기존 구성원과 새 구성원이 주요 일정에 동일한 PSK 입력을 계산하도록 하려면 Commit 및 GroupSecret 개체가 동일한 순서로 동일한 PSK 집합을 나타내야 합니다.\(MUST\)

```text
   enum {
     reserved(0),
     external(1),
     resumption(2),
     (255)
   } PSKType;

   enum {
     reserved(0),
     application(1),
     reinit(2),
     branch(3),
     (255)
   } ResumptionPSKUsage;

   struct {
     PSKType psktype;
     select (PreSharedKeyID.psktype) {
       case external:
         opaque psk_id<V>;

       case resumption:
         ResumptionPSKUsage usage;
         opaque psk_group_id<V>;
         uint64 psk_epoch;
     };
     opaque psk_nonce<V>;
   } PreSharedKeyID;
```

클라이언트가 PSK를 그룹에 주입할 때마다 PreSharedKeyID의 psk\_nonce는 길이 KDF.Nh의 새로운 임의 값으로 설정되어야 합니다. 여기서 KDF는 PSK가 주입되는 그룹의 암호 제품군에 대한 KDF입니다. 이렇게 하면 PSK를 여러 번 사용하더라도 키 일정에 입력되는 값이 매번 달라집니다.\(MUST\)

PreSharedKey 제안 또는 psks 필드가 설정된 GroupSecrets 개체가 포함된 Commit을 수신하면 수신 클라이언트는 각각 Commit 또는 psks 필드에 나열된 순서대로 키 일정에 포함합니다. 재개 PSK의 경우 PSK는 PreSharedKeyID 개체에 지정된 그룹 및 에포크의 resumption\_psk로 정의됩니다. 특히 psk\_secret은 다음과 같이 계산됩니다.

```text
   struct {
       PreSharedKeyID id;
       uint16 index;
       uint16 count;
   } PSKLabel;

   psk_extracted_[i] = KDF.Extract(0, psk_[i])
   psk_input_[i] = ExpandWithLabel(psk_extracted_[i], "derived psk",
                     PSKLabel, KDF.Nh)

   psk_secret_[0] = 0
   psk_secret_[i] = KDF.Extract(psk_input_[i-1], psk_secret_[i-1])
   psk_secret     = psk_secret_[n]
```

여기서 0은 길이 KDF.Nh의 모두 0인 벡터를 나타냅니다. PSKLabel의 index 필드는 psk 배열의 PSK 인덱스에 해당하는 반면 count 필드에는 총 PSK 수가 포함됩니다. 즉, PSK는 다음과 같이 KDF.Extract 호출\(다이어그램에서 간결함을 위해 "Extract"로 표시됨\)과 함께 연결됩니다.

```text
                   0                               0    = psk_secret_[0]
                   |                               |
                   V                               V
  psk_[0]   --> Extract --> ExpandWithLabel --> Extract = psk_secret_[1]
                                                   |
                   0                               |
                   |                               |
                   V                               V
  psk_[1]   --> Extract --> ExpandWithLabel --> Extract = psk_secret_[2]
                                                   |
                   0                              ...
                   |                               |
                   V                               V
  psk_[n-1] --> Extract --> ExpandWithLabel --> Extract = psk_secret_[n]

        Figure 24: Computation of a PSK Secret from a Set of PSKs
```

특히 주어진 커밋에 PreSharedKey 제안이 없는 경우 결과 psk\_secret은 모두 0인 벡터인 psk\_secret\_\[0\]입니다.

---
### **8.5.  Exporters**

기본 MLS 키 일정은 애플리케이션에서 MLS 외부에서 사용할 새 비밀을 파생시키는 데 사용할 수 있는 exporter\_secret을 제공합니다.

```text
   MLS-Exporter(Label, Context, Length) =
          ExpandWithLabel(DeriveSecret(exporter_secret, Label),
                            "exported", Hash(Context), Length)
```

응용 프로그램은 비밀의 의도된 목적을 식별하는 고유 레이블을 MLS-Exporter에 제공해야 합니다\(SHOULD\). 이는 동일한 암호가 생성되어 서로 다른 두 위치에서 사용되는 것을 방지하는 데 도움이 됩니다. 다른 애플리케이션에서 동일한 레이블이 사용되는 것을 방지하기 위해 이러한 레이블에 대한 IANA 레지스트리가 17.8절에 정의되어 있습니다.\(SHOULD\)

내보낸 값은 exporter\_secret이 파생된 그룹 에포크에 바인딩되므로 그룹의 특정 상태를 반영합니다.

커밋이 처리된 후 내보낸 값을 생성하는 응용 프로그램이 해당 값을 새로 고치는 것이 좋습니다\(RECOMMENDED\).\(SHOULD\)

---
### **8.6.  Resumption PSK**

기본 MLS 키 일정은 한 에포크에서 다른 에포크로 엔트로피를 주입하기 위한 PSK로 사용되는 resumption\_psk를 제공합니다. 이 기능은 섹션 11.2 및 11.3에 설명된 재초기화 및 분기 프로세스에 사용되지만 애플리케이션에서 다른 목적으로 사용할 수도 있습니다.

재개 PSK의 일부 사용은 과거 시대의 PSK 사용을 요구할 수 있습니다. 애플리케이션은 resumation\_psk가 저장될 수 있는 과거 에포크 수에 대한 상한을 지정해야 합니다\(SHOULD\).\(SHOULD\)

---
### **8.7.  Epoch Authenticators**

기본 MLS 키 일정은 에포크당 epoch\_authenticator를 제공합니다. 활성 공격자가 그룹의 한 구성원을 사칭하는 경우 해당 클라이언트가 계산한 epoch\_authenticator는 다른 그룹 구성원이 계산한 것과 다릅니다.

이 속성은 구성원의 서명 키가 손상된 경우에도 효과적인 가장 공격에 대한 방어를 구성하는 데 사용할 수 있습니다. 간단한 예로, MLS 그룹에 있는 클라이언트의 사용자가 직접 만나서 적절한 사용자 인터페이스를 사용하여 epoch 인증자 값이 동일한지 확실하게 확인하면 각 사용자는 다른 사용자가 그렇지 않다는 것을 확신할 수 있습니다. 현재 시대에 가장. 하지만 시대가 바뀌면 바로 이 확인 작업을 다시 수행해야 합니다. 그룹의 상태가 변경되어 공격자가 도입되었을 수 있습니다.

보다 일반적으로 MLS 그룹의 구성원이 epoch\_authenticator를 사용하여 구체적인 인증 보호를 얻으려면 일부 보조 프로토콜\(예: 위의 대면 프로토콜\)에서 사용해야 합니다. 그러면 해당 프로토콜의 세부 정보에 따라 MLS 그룹에 제공되는 특정 인증 보호가 결정됩니다.

---
## **9.  Secret Tree**

암호화 키 및 nonce 생성을 위해 키 일정은 루트의 encryption\_secret에서 시작하여 그룹의 래칫 트리와 동일한 구조로 비밀 트리를 파생합니다. 비밀 트리의 각 리프는 래칫 트리의 해당 리프와 동일한 그룹 구성원과 연결됩니다.

N이 비밀 트리의 부모 노드인 경우 N의 자식 비밀은 다음과 같이 정의됩니다\(여기서 left\(N\) 및 right\(N\)은 N의 자식을 나타냄\).

```text
   tree_node_[N]_secret
           |
           |
           +--> ExpandWithLabel(., "tree", "left", KDF.Nh)
           |    = tree_node_[left(N)]_secret
           |
           +--> ExpandWithLabel(., "tree", "right", KDF.Nh)
                = tree_node_[right(N)]_secret

     Figure 25: Derivation of Secrets from Parent to Children within a
                                Secret Tree
```

비밀 트리의 리프에 있는 비밀은 섹션 9.1에 설명된 대로 단일 사용 키와 nonce의 시퀀스가 ​​파생되는 두 개의 대칭 해시 래칫을 시작하는 데 사용됩니다. 각 래칫의 루트는 다음과 같이 계산됩니다.

```text
   tree_node_[N]_secret
           |
           |
           +--> ExpandWithLabel(., "handshake", "", KDF.Nh)
           |    = handshake_ratchet_secret_[N]_[0]
           |
           +--> ExpandWithLabel(., "application", "", KDF.Nh)
                = application_ratchet_secret_[N]_[0]

     Figure 26: Initialization of the Hash Ratchets from the Leaves of
                               a Secret Tree
```

---
### **9.1.  Encryption Keys**

섹션 6에 설명된 대로 MLS는 세 가지 유형의 정보를 암호화합니다.

```text
   *  Metadata (sender information)

   *  Handshake messages (Proposal and Commit)

   *  Application messages
```

콘텐츠 암호화를 위해 키를 조회하는 데 사용되는 발신자 정보는 AEAD로 암호화되며 여기서 키와 nonce는 sender\_data\_secret과 암호화된 메시지 콘텐츠 샘플에서 파생됩니다.

핸드셰이크 및 애플리케이션 메시지의 경우 "발신자 래칫"을 통해 일련의 키가 파생됩니다. 각 발신자는 자신의 발신자 래칫을 가지고 있으며 래칫을 따라가는 각 단계를 "세대"라고 합니다.

다음 그림은 구성원 D가 전송에 사용할 핸드셰이크 및 응용 프로그램 래칫과 처음 두 개의 응용 프로그램 키 및 nonce가 있는 4인조 그룹의 비밀 트리를 보여줍니다.

```text
          G
          |
        .-+-.
       /     \
      E       F
     / \     / \
    A   B   C   D
               / \
             HR0  AR0--+--K0
                   |   |
                   |   +--N0
                   |
                  AR1--+--K1
                   |   |
                   |   +--N1
                   |
                  AR2
```

- 그림 27: 4인조 그룹의 Secret Tree

발신자 래칫은 섹션 9에 설명된 대로 비밀 트리에서 파생된 발신자별 기본 비밀에서 시작합니다. 기본 비밀은 일련의 키와 논스를 생성하는 대칭 해시 래칫을 시작합니다. 발신자는 시퀀스에서 j번째 키/논스 쌍을 사용하여 해당 에포크 동안 보내는 j번째 메시지를 암호화\(AEAD 사용\)합니다. 각 키/nonce 쌍은 둘 이상의 메시지를 암호화하는 데 사용되어서는 안 됩니다\(MUST NOT\).\(MUST NOT\)

래칫의 키, nonce 및 비밀은 DeriveTreeSecret을 사용하여 파생됩니다. 주어진 호출의 컨텍스트는 래칫의 현재 위치로 구성됩니다.

```text
   DeriveTreeSecret(Secret, Label, Generation, Length) =
       ExpandWithLabel(Secret, Label, Generation, Length)
```

여기서 Generation은 big endian uint32로 인코딩됩니다.

```text
   ratchet_secret_[N]_[j]
         |
         +--> DeriveTreeSecret(., "nonce", j, AEAD.Nn)
         |    = ratchet_nonce_[N]_[j]
         |
         +--> DeriveTreeSecret(., "key", j,  AEAD.Nk)
         |    = ratchet_key_[N]_[j]
         |
         V
   DeriveTreeSecret(., "secret", j, KDF.Nh)
   = ratchet_secret_[N]_[j+1]
```

여기서 AEAD.Nn 및 AEAD.Nk는 암호 그룹에 의해 정의된 AEAD 체계에 대한 nonce 및 키의 바이트 길이를 나타냅니다.

---
### **9.2.  Deletion Schedule**

보안에 민감한 모든 값은 \_소비\_되는 즉시 삭제하는 것이 중요합니다. 민감한 값 S는 다음과 같은 경우 \_소비됨\_이라고 합니다.

\* S는 메시지를 암호화하거나 \(성공적으로\) 해독하는 데 사용되었습니다.

\* S에서 파생된 키, nonce 또는 비밀이 소비되었습니다. \(이는 DeriveSecret 및 ExpandWithLabel을 통해 파생된 값에 적용됩니다.\)

여기서 S는 init\_secret, commit\_secret, epoch\_secret 또는 encryption\_secret일 수 있으며 비밀 트리 또는 래칫 중 하나의 비밀일 수 있습니다.

그룹 구성원이 값을 사용하는 즉시 해당 값\(의 모든 표현\)을 즉시 삭제해야 합니다. 이는 과거 메시지에 대한 순방향 비밀성을 보장하는 데 중요합니다. 구성원은 잘못된 메시지 전달을 처리하기 위해 합리적인 시간 동안 사용되지 않은 값을 유지할 수 있습니다.\(MUST, MAY\)

예를 들어, 그룹 구성원이 어떤 epoch n에서 리프 노드 L의 래칫에서 j번째 키와 nonce를 사용하여 애플리케이션 메시지를 암호화하거나 \(성공적으로\) 해독한다고 가정합니다. 그런 다음 해당 구성원에 대해 최소한 다음 값이 사용되었으며 삭제해야 합니다.\(MUST\)

\* commit\_secret, joiner\_secret, epoch\_secret 및

- 해당 epoch n의 encryption\_secret 및 이전 epoch n-1의 init\_secret,

\* 노드 L이 있는 루트에서 리프까지의 경로에 있는 비밀 트리의 모든 노드 비밀,

\* 노드 L의 애플리케이션 데이터 래칫에 있는 첫 번째 j개의 비밀 및

\* application\_ratchet\_nonce\_\[L\]\_\[j\] 및

- application\_ratchet\_key\_\[L\]\_\[j\].

구체적으로 그림 27에 표시된 비밀 트리를 고려하십시오. 클라이언트 A, B 또는 C는 세대 0의 메시지를 수신하지 않고\(예: 주문 배송\). 이 경우 다음 값이 사용됩니다.

\* 메시지를 해독하는 데 사용되는 키 K1 및 nonce N1

\* 응용 프로그램 래칫 비밀 AR1 및 AR0

```text
   *  The tree secrets D, F, and G (recall that G is the
      encryption_secret for the epoch)
```

\* 현재 epoch에 대한 epoch\_secret, commit\_secret, psk\_secret 및 joiner\_secret

다른 값은 유지될 수 있습니다\(사용되지 않음\).

\* 순서가 잘못된 메시지의 암호 해독을 위한 K0 및 N0

- 0세대

\* 추가 메시지 암호 해독 키 및 nonce 파생을 위한 AR2

\* D의 핸드셰이크 메시지 보호를 위한 HR0

\* 발신자 A, B, C가 사용하는 비밀을 도출하기 위한 E와 C

---
## **10.  Key Packages**

그룹에 대한 클라이언트의 비동기 추가를 용이하게 하기 위해 클라이언트는 사용자에 대한 공개 정보를 제공하는 KeyPackage 개체를 미리 게시할 수 있습니다. KeyPackage 개체는 다음을 지정합니다.

1. 클라이언트가 지원하는 프로토콜 버전 및 암호 제품군,

2. 다른 사람이 이 클라이언트에 대한 환영 메시지를 암호화하는 데 사용할 수 있는 공개 키\("초기 키"\)

3. 이 클라이언트를 나타내기 위해 트리에 추가되어야 하는 리프 노드의 내용.

KeyPackage는 한 번만 사용하도록 되어 있으며 "마지막 수단" KeyPackage의 경우를 제외하고 재사용해서는 안 됩니다\(16.8절 참조\). 클라이언트는 여러 암호 제품군을 지원하기 위해 여러 KeyPackage를 생성하고 게시할 수 있습니다\(MAY\).\(SHOULD NOT, MAY\)

init\_key의 값은 cipher\_suite에 의해 정의된 비대칭 암호화 체계에 대한 공개 키여야 하며 이 클라이언트가 생성한 KeyPackage 세트 간에 고유해야 합니다. 마찬가지로, leaf\_node 필드는 encryption\_key 및 signature\_key 필드를 모두 포함하여 암호화 제품군에 대해 유효해야 합니다\(MUST\). 전체 구조는 클라이언트의 서명 키를 사용하여 서명됩니다. 잘못된 서명 필드가 있는 KeyPackage 개체는 형식이 잘못된 것으로 간주해야 합니다.\(MUST, MUST, MUST\)

서명은 "KeyPackageTBS" 레이블과 서명 필드를 제외한 모든 필드를 포함하는 Content 입력이 있는 SignWithLabel 함수에 의해 계산됩니다.

```text
   struct {
       ProtocolVersion version;
       CipherSuite cipher_suite;
       HPKEPublicKey init_key;
       LeafNode leaf_node;
       Extension extensions<V>;
       /* SignWithLabel(., "KeyPackageTBS", KeyPackageTBS) */
       opaque signature<V>;
   } KeyPackage;

   struct {
       ProtocolVersion version;
       CipherSuite cipher_suite;
       HPKEPublicKey init_key;
       LeafNode leaf_node;
       Extension extensions<V>;
   } KeyPackageTBS;
```

클라이언트가 MLSMessage 개체 내에서 운반되는 KeyPackage를 수신하면 KeyPackage의 버전 필드가 MLSMessage의 버전 필드와 동일한 값을 갖는지 확인해야 합니다. KeyPackage의 버전 필드는 그룹의 다른 구성원이 추가 제안에서 KeyPackage를 수신할 때 의도한 버전의 명시적 신호를 그룹의 다른 구성원에게 제공합니다.\(MUST\)

leaf\_node.capabilities 필드는 클라이언트에서 지원하는 프로토콜 버전, 암호화 제품군, 자격 증명 유형 및 기본이 아닌 제안/확장 유형을 나타냅니다. \(섹션 7.2에서 논의된 바와 같이, 이 문서에 정의된 일부 제안 및 확장 유형은 "기본값"으로 간주되므로 나열되지 않습니다.\) 이 정보는 MLS 세션 설정이 설명된 매개변수에 대한 다운그레이드 공격으로부터 안전하도록 합니다\(섹션 11에서 논의됨\). \), 여전히 KeyPackage당 하나의 버전과 하나의 암호화 제품군만 광고합니다.

KeyPackage에 있는 LeafNode의 leaf\_node.leaf\_node\_source 필드는 key\_package로 설정되어야 합니다.\(MUST\)

extensions 또는 leaf\_node.extensions 필드에 포함된 확장은 leaf\_node.capabilities 필드에 포함되어야 합니다. 섹션 13에서 논의한 바와 같이 KeyPackage.extensions의 알 수 없는 확장은 무시해야 하며 KeyPackage 객체의 생성자는 다른 클라이언트가 알 수 없는 확장을 올바르게 무시할 수 있도록 임의의 GREASE 확장을 포함해야 합니다\(SHOULD\).\(MUST, MUST\)

---
### **10.1.  KeyPackage Validation**

KeyPackage의 유효성은 몇 가지 단계에서 확인해야 합니다.

\* KeyPackage가 클라이언트를 그룹에 추가하는 데 사용되기 전에 그룹 구성원이 다운로드한 경우

\* Add 메시지에서 그룹 구성원이 KeyPackage를 수신한 경우

클라이언트는 다음 단계를 사용하여 KeyPackage의 유효성을 확인합니다.

\* 암호화 제품군 및 프로토콜 버전이

- KeyPackage는 GroupContext의 것과 일치합니다.

\* Section 7.3에 따라 KeyPackage의 leaf\_node가 KeyPackage에 유효한지 확인하십시오.

\* leaf\_node.credential의 공개 키를 사용하여 KeyPackage의 서명이 유효한지 확인합니다.

\* leaf\_node.encryption\_key의 값이 init\_key 필드의 값과 다른지 확인합니다.

---
## **11.  Group Creation**

그룹은 항상 "작성자"라는 단일 구성원으로 만들어집니다. 그런 다음 일반적인 추가/커밋 메커니즘을 사용하여 다른 구성원을 그룹에 추가합니다.

그룹 생성자는 그룹 ID, 암호 그룹 및 그룹의 초기 확장자를 설정해야 합니다. 생성자가 생성 시 다른 구성원을 추가하려는 경우 추가할 구성원에 대한 KeyPackages를 가져오고 구성원의 기능에 따라 암호화 제품군 및 확장을 선택해야 합니다. 다운그레이드 공격으로부터 보호하기 위해 생성자는 이러한 KeyPackages의 기능 정보를 사용하여 선택한 버전과 암호화 제품군이 모든 구성원이 지원하는 최상의 옵션인지 확인해야 합니다.\(SHOULD, MUST\)

배달 서비스의 도움 없이도 정직한 그룹 생성자가 동일한 그룹 ID를 생성할 가능성이 매우 낮은 방식으로 그룹 ID를 구성해야 합니다\(SHOULD\). 예를 들어 그룹 ID를 KDF.Nh 크기의 새로 생성된 무작위 값으로 만들면 됩니다. 배달 서비스는 이전에 사용된 ID로 새 그룹의 생성을 거부하여 그룹 ID가 전역적으로 고유하도록 시도할 수 있습니다\(MAY\).\(SHOULD, MAY\)

그룹을 초기화하려면 그룹 생성자는 다음 단계를 수행해야 합니다.\(MUST\)

\* 다음 초기 값으로 1인 그룹을 초기화합니다.

- - Ratchet 트리: 단일 노드가 있는 트리, HPKE 공개 키 및 작성자에 대한 자격 증명을 포함하는 리프 노드

- - 그룹 ID: 생성자가 설정한 값

```text
      -  Epoch: 0
```

- - 트리 해시: 위 래칫 트리의 루트 해시

- - 확인된 성적표 해시: 길이가 0인 옥텟 문자열

- - 획기적인 비밀: KDF.Nh 크기의 새로운 임의 값

- - 확장: 작성자가 선택한 모든 값

\* 임시 성적표 해시 계산:

- - 섹션 8에 설명된 대로 epoch에 대한 Confirmation\_key를 파생합니다.

- 공백에 대해 Confirmation\_tag를 계산합니다.

- 6.1절에 설명된 대로 Confirmation\_key를 사용하여 Confirmed\_transcript\_hash.

- 업데이트된 interim\_transcript\_hash를

- 8.2절에 설명된 Confirm\_transcript\_hash 및 Confirmation\_tag.

이 시점에서 작성자의 상태는 완전히 초기화된 키 일정, 기록 해시 등이 있는 1인 그룹을 나타냅니다. 이 그룹 상태에 대한 제안 및 커밋은 제안 추가 및 커밋과 같은 그룹의 다른 상태와 마찬가지로 생성될 수 있습니다. 그룹에 다른 구성원을 추가합니다. 외부 조인을 용이하게 하기 위해 이 그룹 상태에 대한 GroupInfo 개체를 게시할 수도 있습니다.

생성자 이외의 구성원은 환영 메시지\(섹션 12.4.3.1 참조\)를 보내거나 외부 Commit\(섹션 12.4.3.2 참조\)을 전송하여 가입합니다.

원칙적으로 위의 프로세스는 생성자가 직접 트리를 생성하고 첫 번째 epoch의 epoch secret에 대해 임의의 값을 선택하도록 함으로써 간소화될 수 있습니다. 예를 들어 잘못된 임의성이 도입될 수 있는 불필요한 선택을 제거하기 때문에 위의 단계를 따릅니다. 여기에서 작성자가 선택하는 유일한 항목은 자체 KeyPackage와 Commit이 빌드되는 리프 비밀입니다.

---
### **11.1.  Required Capabilities**

그룹 구성은 그룹의 클라이언트에 대한 특정 요구 사항을 부과합니다. 최소한 그룹의 모든 구성원은 사용 중인 암호화 제품군 및 프로토콜 버전을 지원해야 합니다. GroupContext에 required\_capabilities 확장을 포함하여 추가 요구 사항을 부과할 수 있습니다.

```text
   struct {
       ExtensionType extension_types<V>;
       ProposalType proposal_types<V>;
       CredentialType credential_types<V>;
   } RequiredCapabilities;
```

이 확장은 그룹의 모든 구성원이 지원해야 하는 확장, 제안 및 자격 증명 유형을 나열합니다. 이 문서에 정의된 "기본" 제안 및 확장 유형은 모든 클라이언트에 의해 구현되는 것으로 간주되며 안전하게 사용하기 위해 RequiredCapabilities에 나열될 필요가 없습니다. 자격 증명 유형에는 해당되지 않습니다.

새 구성원의 경우 커밋 추가를 적용하는 동안 기존 구성원이 필수 기능에 대한 지원을 적용합니다. 기존 회원들은 이미 규정을 준수하고 있어야 합니다. 그룹의 확장이 업데이트되더라도 이것이 계속되는 경우를 보장하기 위해 현재 모든 구성원이 지원하지 않는 기본이 아닌 기능을 요구하는 required\_capabilities 확장이 포함된 GroupContextExtensions 제안은 유효하지 않은 것으로 간주됩니다.

---
### **11.2.  Reinitialization**

그룹은 동일한 구성원 및 다른 매개 변수를 사용하여 새 그룹을 만들고 재개 PSK를 통해 이전 그룹에 연결하여 다시 초기화할 수 있습니다. 그룹 구성원은 다음 단계를 사용하여 그룹을 다시 초기화합니다.

1. 이전 그룹의 구성원이 ReInit 제안을 보냅니다\(참조

- 섹션 12.1.5\).

2. 이전 그룹의 구성원이 ReInit 제안을 다루는 커밋을 보냅니다.

3. 이전 그룹의 구성원은 ReInit와 일치하는 새 그룹을 설정하고 환영 메시지를 보내는 초기 커밋을 만듭니다.

- \* 환영 메시지에 있는 GroupContext 객체의 version, cipher\_suite, group\_id 및 extensions 필드는 ReInit 제안의 해당 필드와 동일해야 합니다. 환영 메시지의 에포크는 반드시 1이어야 합니다.\(MUST, MUST\)

- \* 환영 메시지는 사용 reinit와 함께 재개 유형의 PreSharedKeyID를 지정해야 합니다. 여기서 group\_id 필드는 이전 그룹과 일치하고 epoch 필드는 ReInit를 포함하는 커밋 후 에포크를 나타냅니다.\(MUST\)

이 세 단계는 동일한 그룹 구성원 또는 다른 구성원이 수행할 수 있습니다. 예를 들어 그룹 구성원이 인라인 ReInit 제안\(1단계 및 2단계\)과 함께 Commit를 보낸 후 오프라인 상태가 되면 다른 그룹 구성원이 대신 그룹을 다시 만들 수 있습니다. 이러한 유연성은 그룹이 2단계와 3단계 사이에 끼이는 상황을 방지합니다.

사용 reinit가 포함된 재개 PSK는 다른 컨텍스트에서 사용해서는 안 됩니다\(MUST NOT\). 유형 재개 및 사용 재초기화를 포함하는 PreSharedKey 제안은 유효하지 않은 것으로 간주해야 합니다\(MUST\).\(MUST NOT, MUST\)

---
### **11.3.  Subgroup Branching**

이전 그룹과 동일한 매개변수를 사용하여 기존 그룹 구성원의 하위 집합에서 새 그룹을 형성할 수 있습니다.

구성원은 다음 단계를 수행하여 하위 그룹을 만들 수 있습니다.

1. 하위 그룹에 포함되어야 하는 각 그룹 구성원에 대한 새 KeyPackage를 가져옵니다.

2. 새 그룹을 설정하고 사용 분기가 있는 재개 유형의 PreSharedKey 제안을 포함하는 초기 커밋 메시지를 만듭니다. 키 재사용을 방지하기 위해 PreSharedKeyID 개체에 포함된 psk\_nonce는 길이 KDF.Nh의 임의로 샘플링된 nonce여야 합니다.\(MUST\)

3. 하위 그룹 구성원에게 해당 환영 메시지를 보냅니다.

사용 분기가 있는 재개 유형의 PreSharedKey를 포함하는 환영 메시지를 수신하는 클라이언트는 다음을 확인하여 새 그룹이 참조 그룹에서 분기된 하위 그룹을 반영하는지 확인해야 합니다.\(MUST\)

\* 환영 메시지의 version 및 cipher\_suite 값은 기존 그룹에서 사용하던 것과 동일합니다.

\* 환영 메시지의 에포크는 반드시 1이어야 합니다.\(MUST\)

\* 새 하위 그룹의 각 LeafNode는 원래 그룹의 일부 LeafNode와 일치해야 합니다. 이 컨텍스트에서 한 쌍의 LeafNode는 각각의 자격 증명이 제공하는 식별자가 애플리케이션에서 동등한 것으로 간주되는 경우 "일치"한다고 합니다.\(MUST\)

사용 분기가 있는 재개 PSK는 다른 컨텍스트에서 사용하면 안 됩니다\(MUST NOT\). 유형 재개 및 사용 분기가 있는 PreSharedKey 제안은 유효하지 않은 것으로 간주해야 합니다\(MUST\).\(MUST NOT, MUST\)

---
## **12.  Group Evolution**

그룹의 수명 동안 구성원이 변경될 수 있으며 기존 구성원은 손상 후 보안을 달성하기 위해 키를 변경하려고 할 수 있습니다. MLS에서 이러한 각 변경은 두 단계 프로세스로 수행됩니다.

1. 변경 제안은 제안 메시지를 통해 그룹에 전달됩니다.

2. 그룹의 구성원 또는 새 구성원이 하나 이상의 제안된 변경 사항을 적용하는 Commit 메시지를 브로드캐스트합니다.

Proposal과 Commit이 동일한 구성원에 의해 전송되는 경우 커밋에 제안을 전송하여 이 두 단계를 결합할 수 있습니다.

따라서 그룹은 Commit 메시지가 전송되고 처리될 때마다 하나의 암호화 상태에서 다른 암호화 상태로 발전합니다. 이러한 상태를 "에포크"라고 하며 8옥텟 에포크 값으로 그룹의 상태 간에 고유하게 식별됩니다. 새 그룹이 초기화되면 초기 상태 에포크는 0x0000000000000000입니다. 상태 전환이 발생할 때마다 에포크 번호가 1씩 증가합니다.

---
### **12.1.  Proposals**

제안은 유형을 나타내는 제안 구조를 통해 FramedContent에 포함됩니다.

```text
   // See the "MLS Proposal Types" IANA registry for values
   uint16 ProposalType;

   struct {
       ProposalType proposal_type;
       select (Proposal.proposal_type) {
           case add:                      Add;
           case update:                   Update;
           case remove:                   Remove;
           case psk:                      PreSharedKey;
           case reinit:                   ReInit;
           case external_init:            ExternalInit;
           case group_context_extensions: GroupContextExtensions;
       };
   } Proposal;
```

제안이 포함된 FramedContent를 수신할 때 클라이언트는 FramedContentAuthData 내부의 서명을 확인해야 하며 둘러싸는 FramedContent의 epoch 필드가 현재 GroupContext 개체의 epoch 필드와 동일한지 확인해야 합니다. 검증에 성공하면 나중에 Commit 메시지에서 해시\(ProposalOrRef 객체로\)로 검색할 수 있는 방식으로 제안을 캐시해야 합니다.\(MUST\)

---
#### **12.1.1.  Add**

추가 제안은 지정된 KeyPackage가 있는 클라이언트가 그룹에 추가되도록 요청합니다.

```text
   struct {
       KeyPackage key_package;
   } Add;
```

섹션 10.1에 따라 KeyPackage가 유효하지 않은 경우 추가 제안이 유효하지 않습니다.

Commit 메시지에 포함된 후 Add가 적용됩니다. 제안 목록에서 추가 위치에 따라 새 구성원이 추가될 리프 노드가 결정됩니다. Commit에서 첫 번째 추가의 경우 해당 새 구성원이 트리의 가장 왼쪽 빈 잎에 배치되고 두 번째 추가의 경우 오른쪽에 다음 빈 잎이 배치됩니다. 빈 잎이 없으면 트리가 다음으로 확장됩니다. 권리.

\* 새 구성원에 대한 리프 L을 식별합니다. 트리에 빈 리프가 있는 경우 L은 가장 왼쪽의 빈 리프입니다. 그렇지 않으면 트리는 섹션 7.7에서 설명한 대로 오른쪽으로 확장되고 L은 가장 왼쪽의 새 빈 리프에 할당됩니다.

\* 리프 L에서 루트까지의 경로를 따라 비어 있지 않은 각 중간 노드에 대해 노드의 unmerged\_leaves 목록에 L의 리프 인덱스를 추가합니다.

\* Add에서 KeyPackage의 leaf\_node 필드에 포함된 LeafNode 개체를 포함하는 새 노드로 리프 노드 L을 설정합니다.

---
#### **12.1.2.  Update**

업데이트 제안은 트리에 새 리프를 추가하는 대신 트리에서 보낸 사람의 리프 노드를 대체한다는 차이점이 있는 추가와 유사한 메커니즘입니다.

```text
   struct {
       LeafNode leaf_node;
   } Update;
```

7.3절에 따라 업데이트 제안에 대해 LeafNode가 유효하지 않은 경우 업데이트 제안이 유효하지 않습니다.

그룹의 구성원은 다음 단계를 수행하여 업데이트 메시지를 적용합니다.

\* 보낸 사람의 LeafNode를 업데이트 제안에 포함된 것으로 교체합니다.

\* 발신자의 리프에서 루트까지의 경로를 따라 중간 노드를 비웁니다.

---
#### **12.1.3.  Remove**

제거 제안은 리프 인덱스가 제거된 구성원을 그룹에서 제거하도록 요청합니다.

```text
   struct {
       uint32 removed;
   } Remove;
```

제거된 필드가 비어 있지 않은 리프 노드를 식별하지 않는 경우 제거 제안은 유효하지 않습니다.

그룹 구성원은 다음 단계를 수행하여 제거 메시지를 적용합니다.

\* 제거된 리프 노드 일치를 식별합니다. L을 이 리프 노드라고 합니다.

\* 리프 노드 L을 빈 노드로 교체합니다.

\* L에서 루트까지의 경로를 따라 중간 노드를 비웁니다.

\* 오른쪽 하위 트리에 비어 있지 않은 리프 노드가 하나 이상 있을 때까지 오른쪽 하위 트리를 제거하여 트리를 자릅니다. 가장 오른쪽의 비어 있지 않은 리프에 인덱스 L이 있는 경우 2^d 리프가 있는 트리가 됩니다. 여기서 d는 2^d \> L인 가장 작은 값입니다.

---
#### **12.1.4.  PreSharedKey**

PreSharedKey 제안은 시대를 앞당기는 과정에서 키 일정에 사전 공유 키를 주입하도록 요청하는 데 사용할 수 있습니다.

```text
   struct {
       PreSharedKeyID psk;
   } PreSharedKey;
```

다음 중 하나라도 해당되면 PreSharedKey 제안이 유효하지 않습니다.

\* PreSharedKey 제안은 그룹 재초기화의 일부로 처리되지 않으며\(섹션 11.2 참조\) PreSharedKeyID의 psktype은 재개로 설정되고 사용은 재초기화로 설정됩니다.

\* PreSharedKey 제안은 하위 그룹 분기 작업의 일부로 처리되지 않으며\(섹션 11.3 참조\) PreSharedKeyID의 psktype은 재개로 설정되고 사용은 분기로 설정됩니다.

\* psk\_nonce의 길이는 KDF.Nh가 아닙니다.

psk\_nonce는 무작위로 샘플링되어야 합니다. 하나 이상의 PreSharedKey 제안을 포함하는 커밋 메시지를 처리할 때 그룹 구성원은 섹션 8.4에 설명된 대로 psk\_secret을 파생합니다. 여기서 PSK의 순서는 커밋의 PreSharedKey 제안 순서에 해당합니다.\(MUST\)

---
#### **12.1.5.  ReInit**

ReInit 제안은 예를 들어 버전 번호를 높이거나 암호 그룹을 변경하기 위해 다른 매개변수로 그룹을 다시 초기화하라는 요청을 나타냅니다. 재초기화는 완전히 새로운 그룹을 만들고 이전 그룹을 종료하여 수행됩니다.

```text
   struct {
       opaque group_id<V>;
       ProtocolVersion version;
       CipherSuite cipher_suite;
       Extension extensions<V>;
   } ReInit;
```

버전 필드가 현재 그룹의 버전보다 낮은 경우 ReInit 제안이 유효하지 않습니다.

그룹의 구성원은 커미터가 섹션 11.2의 기준에 따라 ReInit와 일치하는 환영 메시지를 보낼 때까지 기다리면서 ReInit 제안을 적용합니다.

---
#### **12.1.6.  ExternalInit**

ExternalInit 제안은 외부 커밋을 사용하여 그룹에 가입하려는 새 구성원이 사용합니다. 이 제안은 해당 컨텍스트에서만 사용할 수 있습니다.

```text
   struct {
     opaque kem_output<V>;
   } ExternalInit;
```

그룹의 구성원은 섹션 8.3에 설명된 대로 계산된 초기화 비밀을 사용하여 다음 epoch를 초기화하여 ExternalInit 메시지를 적용합니다. kem\_output 필드에는 필수 KEM 출력이 포함되어 있습니다.

---
#### **12.1.7.  GroupContextExtensions**

GroupContextExtensions 제안은 그룹에 대한 GroupContext의 확장 목록을 업데이트하는 데 사용됩니다.

```text
   struct {
     Extension extensions<V>;
   } GroupContextExtensions;
```

GroupContextExtensions 제안은 required\_capabilities 확장을 포함하고 그룹의 일부 구성원이 일부 필수 기능\(동일한 커밋에 추가된 기능 포함, 제거된 기능 제외\)을 지원하지 않는 경우 유효하지 않습니다.

그룹 구성원은 다음 단계에 따라 GroupContextExtensions 제안을 적용합니다.

\* 그룹의 GroupContext 개체에서 기존 확장을 모두 제거하고 제안의 확장 목록으로 바꿉니다. \(이것은 병합이 아닌 전체 교체입니다. 확장은 제안 발신자가 새 목록에 포함하는 경우에만 이월됩니다.\)

GroupContext가 업데이트되면 주요 일정을 통해 Confirmation\_tag에 포함되면 그룹의 모든 구성원이 사용 중인 확장에 동의함을 확인할 수 있습니다.

---
#### **12.1.8.  External Proposals**

두 가지 경우에 그룹 외부에 있는 당사자가 제안을 구성하고 그룹에 보낼 수 있습니다. 외부 SenderType으로 표시된 한 가지 경우는 그룹 외부의 엔터티가 그룹에 제안을 제출할 수 있도록 허용합니다. 예를 들어, 자동화된 서비스는 오랫동안 활동하지 않은 그룹 구성원을 제거하거나 실제 팀을 대표하는 그룹에 새로 고용된 직원을 추가할 것을 제안할 수 있습니다. 외부 발신자는 MLS 버전 또는 암호화 제품군에 관한 변경된 정책을 시행하기 위해 ReInit 제안을 보낼 수 있습니다.

외부 SenderType을 사용하려면 서명자가 그룹 내의 클라이언트에 사전 프로비저닝되어야 하며 external\_senders 확장이 그룹의 GroupContext에 있는 경우에만 사용할 수 있습니다.

new\_member\_proposal SenderType으로 표시되는 다른 경우는 그룹의 기존 구성원이 새로운 조인자 자체\(기존 구성원이 아님\)가 보낸 추가 제안이 승인되었는지 독립적으로 확인할 수 있는 경우에 유용합니다. 승인되지 않은 외부 제안은 유효하지 않은 것으로 간주됩니다.

발신자가 PrivateMessage 개체를 구성하는 데 필요한 키를 가지고 있지 않기 때문에 외부 제안은 반드시 PublicMessage 개체로 보내야 합니다.\(MUST\)

일부 유형의 제안은 외부 발신자가 보낼 수 없습니다. 이 문서에 정의된 제안 유형 중 다음 유형만 외부 발신자가 보낼 수 있습니다.

```text
   *  add

   *  remove

   *  psk

   *  reinit

   *  group_context_extensions
```

위의 제안 유형 이외의 제안 유형을 포함하는 외부 발신자의 메시지는 형식이 잘못된 것으로 간주하여 거부해야 합니다\(MUST\). 미래에 정의된 새로운 제안 유형은 외부 발신자가 보낼 수 있는지 여부를 정의해야 합니다. "MLS 제안 유형" 레지스트리\(섹션 17.4\)의 "Ext" 열은 이 속성을 반영합니다.\(MUST, MUST\)

---
##### **12.1.8.1.  External Senders Extension**

external\_senders 확장은 외부 제안을 그룹에 보낼 수 있는 발신자의 자격 증명 및 서명 키를 포함하는 그룹 컨텍스트 확장입니다.

```text
   struct {
     SignaturePublicKey signature_key;
     Credential credential;
   } ExternalSender;

   ExternalSender external_senders<V>;
```

---
### **12.2.  Proposal List Validation**

커밋을 생성하는 그룹 구성원과 커밋을 처리하는 그룹 구성원은 커밋이 외부인지 여부에 따라 다음 절차 중 하나를 사용하여 커밋된 제안 목록이 유효한지 확인해야 합니다. 제안 목록이 유효하지 않은 경우 Commit 메시지는 유효하지 않은 것으로 거부되어야 합니다.\(MUST, MUST\)

일반, 즉 외부 커밋이 아닌 커밋의 경우 다음 중 하나가 발생하면 목록이 유효하지 않습니다.

\* 섹션 12.1에 명시된 바와 같이 유효하지 않은 개별 제안이 포함되어 있습니다.

\* 커미터가 생성한 업데이트 제안을 포함합니다.

\* 커미터를 제거하는 Remove 제안을 포함합니다.

\* 동일한 리프에 적용되는 여러 업데이트 및/또는 제거 제안을 포함합니다. 커미터가 그러한 제안을 여러 번 받은 경우 받은 제거를 선호하거나 제거가 없는 경우 가장 최근 업데이트를 선호해야 합니다.\(SHOULD\)

\* 애플리케이션에 따라 동일한 클라이언트를 나타내는 KeyPackages\(예: 동일한 서명 키\)를 포함하는 여러 추가 제안을 포함합니다.

\* 그룹에서 일치하는 클라이언트를 제거하는 목록에 Remove 제안이 없는 한 애플리케이션에 따라 이미 그룹에 있는 클라이언트를 나타내는 KeyPackage와 함께 Add 제안을 포함합니다.

\* 동일한 PreSharedKeyID를 참조하는 여러 PreSharedKey 제안을 포함합니다.

```text
   *  It contains multiple GroupContextExtensions proposals.
```

\* 다른 제안과 함께 ReInit 제안을 포함합니다. 커미터가 epoch 중에 다른 제안을 받은 경우 ReInit 제안보다 이를 선호하여 ReInit를 재전송하고 후속 epoch에 적용할 수 있도록 해야 합니다.\(SHOULD\)

\* ExternalInit 제안을 포함합니다.

\* 커밋을 처리할 그룹의 일부 구성원이 지원하지 않는 기본 제안 유형이 아닌 제안이 포함되어 있습니다\(즉, 커밋에 의해 추가되거나 제거되는 구성원은 제안 유형을 지원할 필요가 없습니다\).

\* 커밋을 처리한 후 래칫 트리는 특히 섹션 7.3에 따라 유효하지 않은 리프 노드를 포함하는 경우 유효하지 않습니다.

응용 프로그램은 예를 들어 구성원을 추가하기 위해 응용 프로그램 수준 권한을 요구하거나 기본이 아닌 제안 유형과 관련된 규칙과 같은 추가 규칙으로 위의 절차를 확장할 수 있습니다.

외부 커밋의 경우 목록에 다음 제안만 포함된 경우\(반드시 이 순서는 아님\) 목록이 유효합니다.

```text
   *  Exactly one ExternalInit
```

\* 참여자가 자신의 이전 버전을 제거하는 최대 하나의 제거 제안. 제거 제안이 있는 경우 외부 커밋의 경로 필드에 있는 LeafNode는 제거된 리프에 대한 업데이트의 LeafNode와 동일한 기준을 충족해야 합니다\(섹션 12.1.2 참조\). 특히, LeafNode의 자격 증명은 제거된 참가자에 대해 애플리케이션에서 허용되는 일련의 식별자를 제시해야 합니다.\(MUST, MUST\)

\* 0개 이상의 PreSharedKey 제안

```text
   *  No other proposals
```

미래에 정의된 제안 유형은 새로운 유형의 제안과 관련된 고려 사항을 통합하기 위해 위의 유효성 검사 논리를 업데이트할 수 있습니다.

---
### **12.3.  Applying a Proposal List**

각 제안 유형을 정의하는 위의 섹션에서는 각 개별 제안이 적용되는 방법을 설명합니다. 커밋을 생성하거나 처리할 때 클라이언트는 제안 목록을 래칫 트리 및 GroupContext에 적용합니다. 고객은 목록에 있는 제안을 다음 순서로 적용해야 합니다.\(MUST\)

\* GroupContextExtensions 제안이 있는 경우 그룹에 대한 GroupContext의 extensions 필드를 제안 내용으로 바꿉니다. 이 목록의 다른 제안을 평가할 때 새로운 확장을 사용해야 합니다. 예를 들어 GroupContextExtensions 제안이 required\_capabilities 확장을 추가하는 경우 모든 추가 제안은 해당 기능에 대한 지원을 나타내야 합니다.\(MUST\)

\* 임의의 순서로 래칫 트리에 업데이트 제안을 적용합니다.

\* 제거 제안을 임의의 순서로 래칫 트리에 적용합니다.

\* 목록에 나타나는 순서대로 래칫 트리에 추가 제안을 적용합니다.

\* PreSharedKey 제안에 대한 PSK 비밀을 목록에 나타나는 순서대로 찾아보십시오. 그런 다음 이러한 암호는 나중에 커밋 처리에서 주요 일정을 진행하는 데 사용됩니다.

\* ExternalInit 제안이 있는 경우 나중에 커밋 처리에서 사용할 init\_secret을 파생하는 데 사용합니다.

\* ReInit 제안이 있는 경우 커밋 처리에서 나중에 적용하기 위해 해당 매개 변수를 기록합니다.

미래에 정의된 제안 유형은 새로운 유형의 제안 적용을 수용하기 위해 위의 단계를 조정하는 방법을 지정해야 합니다\(MUST\).\(MUST\)

---
### **12.4.  Commit**

커밋 메시지는 제안 모음을 기반으로 그룹의 새 시대를 시작합니다. 제안을 적용하고 주요 일정을 진행하여 그룹의 상태에 대한 표현을 업데이트하도록 그룹 구성원에게 지시합니다.

Commit에서 다루는 각 제안은 값 또는 참조로 적용할 제안을 식별하는 ProposalOrRef 값에 포함됩니다. 커미터의 새 제안을 참조하는 커밋은 값으로 포함될 수 있습니다. 이전에 보낸 제안서\(커미터 포함\)의 커밋은 참조로 보낼 수 있습니다. 참조로 전송된 제안은 제안이 전송된 AuthenticatedContent 개체의 해시를 포함하여 지정됩니다\(섹션 5.2 참조\).

```text
   enum {
     reserved(0),
     proposal(1),
     reference(2),
     (255)
   } ProposalOrRefType;

   struct {
     ProposalOrRefType type;
     select (ProposalOrRef.type) {
       case proposal:  Proposal proposal;
       case reference: ProposalRef reference;
     };
   } ProposalOrRef;

   struct {
       ProposalOrRef proposals<V>;
       optional<UpdatePath> path;
   } Commit;
```

에포크 내에서 하나 이상의 유효한 제안을 관찰한 그룹 구성원은 애플리케이션 데이터를 보내기 전에 Commit 메시지를 보내야 합니다. 예를 들어, epoch 중에 제거가 제안된 모든 구성원이 응용 프로그램 데이터가 전송되기 전에 실제로 제거되도록 합니다.\(MUST\)

커밋의 발신자와 수신자는 커밋된 제안 목록이 섹션 12.2에 지정된 대로 유효한지 확인해야 합니다. 예를 들어 목록에 동일한 구성원에 대한 업데이트 및 제거가 포함되어 있거나 발신자가 새 사용자를 추가할 수 있는 애플리케이션 수준 권한이 없는 경우 추가가 포함된 경우 목록이 유효하지 않습니다.\(MUST\)

Commit의 발신자는 제안 유형에 대한 규칙과 애플리케이션 정책에 따라 유효한 제안 목록이 되는 한 현재 에포크 동안 수신한 모든 제안을 포함해야 합니다\(SHOULD\).\(SHOULD\)

제안의 비동기 특성으로 인해 커밋 수신자는 현재 epoch 내에 전송된 모든 유효한 제안이 다음 커밋에서 참조되도록 강제해서는 안 됩니다\(SHOULD NOT\). 유효한 제안이 다음 Commit에서 생략되고 해당 제안이 현재 epoch에서 여전히 유효한 경우 제안 발신자는 현재 epoch를 반영하도록 업데이트한 후 제안을 다시 보낼 수 있습니다.\(SHOULD NOT, MAY\)

그룹의 구성원은 제안을 전혀 참조하지 않는 Commit을 보낼 수 있으며 따라서 빈 제안 벡터를 갖게 됩니다. 이러한 커밋은 직접 경로를 따라 발신자의 리프와 노드를 재설정하고 커밋 발신자와 관련하여 순방향 보안 및 사후 손상 보안을 제공합니다. 업데이트 제안은 이 작업의 "게으른" 버전으로 간주될 수 있으며 여기서 리프 변경 사항과 중간 노드만 비워집니다.\(MAY\)

기본적으로 Commit의 경로 필드는 반드시 채워져야 합니다. 경로 필드는 \(a\) 적어도 하나의 제안을 다루고 \(b\) Commit에서 다루는 제안 중 어느 것도 "경로 필수" 유형이 아닌 경우 생략될 수 있습니다. 제안 유형은 UpdatePath가 제공하는 순방향 비밀성 및 사후 보안 보장을 요구하는 방식으로 그룹 구성원을 변경할 수 없는 경우 경로가 필요합니다. 경로가 필요하지 않은 이 문서에 정의된 유일한 제안 유형은 다음과 같습니다.\(MUST, MAY\)

```text
   *  add

   *  psk

   *  reinit
```

새로운 제안 유형은 경로가 필요한지 여부를 명시해야 합니다. 제안 유형의 인스턴스에 경로가 필요한 경우 제안 유형에 경로가 필요합니다. 제안 유형의 이 속성은 섹션 17.4에 정의된 "MLS 제안 유형" 레지스트리의 "경로 필수" 필드에 반영됩니다.\(MUST\)

업데이트 및 제거 제안은 경로가 필요한 제안의 가장 명확한 예입니다. 제거된 구성원 또는 업데이트된 구성원의 이전 모양을 제거하려면 UpdatePath가 필요합니다.

의사 코드에서 Commit의 경로 필드 유효성을 검사하는 논리는 다음과 같습니다.

```text
   pathRequiredTypes = [
       update,
       remove,
       external_init,
       group_context_extensions
   ]

   pathRequired = false

   for proposal in commit.proposals:
       pathRequired = pathRequired ||
                      (proposal.msg_type in pathRequiredTypes)

   if len(commit.proposals) == 0 || pathRequired:
       assert(commit.path != null)
```

요약하면 Commit은 용도가 다른 세 가지 구성을 가질 수 있습니다.

1. 그룹에 대한 커미터의 기여를 업데이트하고 커미터와 관련하여 PCS를 제공하는 제안을 참조하지 않는 "빈" 커밋.

2. 경로가 필요하지 않고 경로가 비어 있는 제안을 참조하는 "부분" Commit. 이러한 커밋은 커미터에 대한 PCS를 제공하지 않습니다.

3. 모든 유형의 제안을 참조하는 "전체" 커밋으로, 커미터 및 업데이트된 멤버에 대해 제거된 멤버 및 PCS와 관련하여 FS를 제공합니다.

---
#### **12.4.1.  Creating a Commit**

커밋을 생성하거나 처리할 때 클라이언트는 그룹의 래칫 트리 및 GroupContext를 업데이트합니다. 이러한 값은 현재 에포크를 반영하는 "이전" 상태에서 Commit에 의해 시작된 새 에포크를 반영하는 "새" 상태로 진행됩니다. 커밋에 UpdatePath가 포함되면 제안 및 UpdatePath로 인한 변경 사항을 반영하지만 이전에 확인된 기록 해시를 사용하는 "임시" 그룹 컨텍스트가 구성됩니다.

그룹의 구성원은 다음 단계를 수행하여 커밋 메시지와 해당 환영 메시지를 동시에 생성합니다.

\* 커밋할 제안 목록이 섹션 12.2에 지정된 대로 유효한지 확인합니다.

\* 현재 에포크 동안 받은 제안에서 채워진 제안 필드와 경로 필드가 비어 있는 초기 Commit 개체를 구성합니다.

\* 섹션 12.3에 정의된 대로 이전 래칫 트리 및 GroupContext에 제안 목록을 적용하여 새 래칫 트리 및 GroupContext를 만듭니다.

\* 경로 필드를 채울지 여부 결정: Commit\(위 참조\)에 있는 제안에 따라 경로 필드가 필요한 경우 반드시 채워야 합니다. 그렇지 않으면 발신자는 재량에 따라 경로 필드를 생략할 수 있습니다.\(MUST, MAY\)

\* 경로 필드를 채우는 경우:

- - 이것이 외부 커밋인 경우 새 래칫 트리에서 보낸 사람에게 가장 왼쪽의 빈 리프 노드를 할당합니다. 새 래칫 트리에 빈 리프 노드가 없으면 섹션 7.7에 정의된 대로 트리를 오른쪽으로 확장하고 가장 왼쪽의 새 빈 리프를 발신자에게 할당합니다.

- 래칫 트리에서 보낸 사람의 직접 경로를 다음과 같이 업데이트합니다.

- 섹션 7.5에 설명되어 있습니다. commit\_secret을 UpdatePath에 대해 파생된 마지막 경로 암호 값\(path\_secret\[n\]\)에서 파생된 값 path\_secret\[n+1\]로 정의합니다.

- - 다음 값을 포함하는 임시 GroupContext 개체를 구성합니다.

- o group\_id: 기존 GroupContext와 동일

- o epoch: 새로운 epoch의 epoch 번호

- o tree\_hash: 새 래칫 트리의 트리 해시

- o Confirmed\_transcript\_hash: 기존 GroupContext와 동일

```text
         o  extensions: The new GroupContext extensions (possibly
            updated by a GroupContextExtensions proposal)
```

- - HPKE 암호화를 위한 컨텍스트로 임시 그룹 컨텍스트를 사용하여 섹션 7.5에 설명된 대로 그룹에 대한 트리 업데이트로 인한 경로 비밀을 암호화합니다.

- - 보낸 사람의 필터링된 직접 경로를 따라 보낸 사람의 새 리프 노드와 새 공개 키 및 암호화된 경로 비밀을 포함하는 UpdatePath를 만듭니다. 커밋의 경로 필드에 이 UpdatePath를 할당합니다.

\* 경로 필드를 채우지 않는 경우: Commit의 경로 필드를 null 옵션으로 설정합니다. commit\_secret을 길이 KDF.Nh\(path\_secret 값과 동일한 길이\)의 모두 0인 벡터로 정의합니다.

\* 섹션 8.4에 지정된 대로 psk\_secret을 파생합니다. 여기에서 파생의 PSK 순서는 제안 벡터의 PreSharedKey 제안 순서에 해당합니다.

\* Commit 개체를 포함하는 FramedContent 개체를 생성합니다. 이전 GroupContext를 컨텍스트로 사용하여 FramedContent에 서명합니다.

- - FramedContent를 사용하여 확인된 성적표 해시를 업데이트하고 새 GroupContext를 업데이트합니다.

- - 이전 epoch의 init\_secret, 이전 단계에서 정의된 commit\_secret 및 psk\_secret, 새 GroupContext를 사용하여 새 epoch의 새 joiner\_secret, welcome\_secret, epoch\_secret 및 파생된 비밀을 계산합니다.

- - Confirmation\_tag 값을 계산하기 위해 새 에포크에 대해 Confirmation\_key를 사용합니다.

- - 새로 확인된 성적표 해시와 FramedContentAuthData의 Confirmation\_tag를 사용하여 중간 성적표 해시를 계산합니다.

\* 이전 시대의 키를 사용하여 AuthenticatedContent 개체를 보호합니다.

- - PublicMessage로 인코딩하는 경우 Membership\_key를 사용하여 Membership\_tag 값을 계산합니다.

- - PrivateMessage로 인코딩하는 경우 보낸 사람의 핸드셰이크 래칫에서 sender\_data\_secret 및 다음\(키, nonce\) 쌍을 사용하여 메시지를 암호화합니다.

\* 새로운 상태를 반영하는 GroupInfo 구성:

- - 새 상태를 반영하도록 group\_id, epoch, tree, Confirmed\_transcript\_hash, interim\_transcript\_hash 및 group\_context\_extensions 필드를 설정합니다.

- Confirmation\_tag 필드를

- FramedContentAuthData 개체의 해당 필드.

- - 응용 프로그램에서 정의한 대로 다른 확장을 추가합니다.

- 선택적으로 에 설명된 대로 외부 키 쌍을 파생합니다.

- 섹션 8. \(외부 커밋에 필요, 섹션 12.4.3.2 참조\).

- - 구성원의 개인 서명 키를 사용하여 GroupInfo에 서명합니다.

- - joiner\_secret에서 파생된 키와 nonce를 사용하여 GroupInfo를 암호화합니다. 새로운 시대에 대해\(12.4.3.1절 참조\).

\* 그룹의 각 새 구성원에 대해:

- - 새 멤버의 리프 노드와 커밋을 보내는 멤버의 트리에서 가장 낮은 공통 조상을 식별합니다.

- - 위의 경로 필드가 채워진 경우: 공통 조상 노드에 해당하는 경로 암호를 계산합니다.

- - 현재 epoch에 대한 init\_secret과 경로 암호\(있는 경우\)를 캡슐화하는 EncryptedGroupSecrets 개체를 계산합니다.

\* 암호화된 하나 이상의 환영 메시지 구성

- GroupInfo 개체, 암호화된 키 패키지 및 Commit에 제안이 포함된 모든 PSK. psk의 순서는 제안 벡터의 PreSharedKey 제안 순서와 동일해야 합니다. 섹션 12.4.3.1에서 설명한 것처럼 커미터는 구성할 환영 메시지 수를 자유롭게 선택할 수 있습니다. 그러나 이 단계에서 생성된 환영 메시지 세트는 Commit에 추가된 모든 새 멤버를 포함해야 합니다.\(MUST, MUST\)

\* ReInit 제안이 Commit의 일부인 경우 커미터는 ReInit 제안에 지정된 매개 변수와 원래 그룹과 동일한 구성원으로 새 그룹을 생성해야 합니다. 환영 메시지에는 다음 매개변수와 함께 PreSharedKeyID가 포함되어야 합니다.\(MUST, MUST\)

```text
      -  psktype: resumption

      -  usage: reinit
```

- - group\_id: 현재 그룹의 그룹 ID

- - epoch: 이 Commit 이후에 그룹이 있게 될 epoch

---
#### **12.4.2.  Processing a Commit**

그룹 구성원은 다음 단계를 수행하여 Commit 메시지를 적용합니다.

\* 둘러싸는 FramedContent의 epoch 필드가 현재 GroupContext 객체의 epoch 필드와 같은지 확인하십시오.

\* 현재 에포크의 키를 사용하여 커밋 보호를 해제합니다.

- 메시지가 PublicMessage로 인코딩된 경우

- Membership\_key를 사용하는 회원 MAC.

- - 메시지가 PrivateMessage로 인코딩된 경우 생성 필드에 표시된 발신자의 해시 래칫 단계에서 sender\_data\_secret 및 \(key, nonce\) 쌍을 사용하여 메시지를 해독합니다.

\* 섹션 6.1에 설명된 대로 FramedContent 메시지의 서명을 확인합니다.

\* 섹션 12.2의 규칙에 따라 제안 벡터가 유효한지 확인하십시오.

\* 제안 벡터의 모든 PreSharedKey 제안이 사용 가능한지 확인합니다.

\* 섹션 12.3에 정의된 대로 이전 래칫 트리 및 GroupContext에 제안 목록을 적용하여 새 래칫 트리 및 GroupContext를 만듭니다.

\* 제안 벡터에 업데이트 또는 제거 제안이 포함되어 있거나 비어 있는 경우 경로 값이 채워져 있는지 확인하십시오. 그렇지 않으면 경로 값을 생략할 수 있습니다.\(MAY\)

\* 경로 값이 채워진 경우 유효성을 검사하고 트리에 적용합니다.

- - 이것이 외부 커밋인 경우 새 래칫 트리에서 보낸 사람에게 가장 왼쪽의 빈 리프 노드를 할당합니다. 새 래칫 트리에 빈 리프 노드가 없으면 새 래칫 트리 오른쪽에 빈 리프를 추가하고 발신자에게 할당합니다.

- - 섹션 7.3에 지정된 대로 LeafNode를 검증합니다. leaf\_node\_source 필드는 커밋으로 설정되어야 합니다.\(MUST\)

- - LeafNode의 encryption\_key 값이 커미터의 현재 리프 노드와 다른지 확인합니다.

- - UpdatePath의 공개 키가 새 래칫 트리의 노드에 나타나지 않는지 확인합니다.

- - 섹션 7.5에 설명된 대로 UpdatePath를 새 래칫 트리에 병합합니다.

- - 다음 값을 포함하는 임시 GroupContext 개체를 구성합니다.

- o group\_id: 기존 GroupContext와 동일

- o epoch: 새로운 epoch의 epoch 번호

- o tree\_hash: 새 래칫 트리의 트리 해시

- o Confirmed\_transcript\_hash: 기존 GroupContext와 동일

```text
         o  extensions: The new GroupContext extensions (possibly
            updated by a GroupContextExtensions proposal)
```

- - HPKE 암호 해독을 위한 컨텍스트로 임시 GroupContext를 사용하여 섹션 7.5에 설명된 대로 UpdatePath에 대한 경로 비밀을 암호 해독합니다.

- - commit\_secret을 UpdatePath에 대해 파생된 마지막 경로 암호 값\(path\_secret\[n\]\)에서 파생된 path\_secret\[n+1\] 값으로 정의합니다.

\* 경로 값이 채워지지 않은 경우 commit\_secret을 길이 KDF.Nh\(path\_secret 값과 동일한 길이\)의 모두 0인 벡터로 정의합니다.

\* 새로운 커밋을 사용하여 확인 및 중간 기록 해시를 업데이트하고 새로운 GroupContext를 생성합니다.

\* 섹션 8.4에 지정된 대로 psk\_secret을 파생합니다. 여기에서 파생의 PSK 순서는 제안 벡터의 PreSharedKey 제안 순서에 해당합니다.

\* 이전 epoch의 init\_secret, 이전 단계에서 정의된 commit\_secret 및 psk\_secret, 새 GroupContext를 사용하여 새 epoch의 새 joiner\_secret, welcome\_secret, epoch\_secret 및 파생된 비밀을 계산합니다.

\* 새 에포크에 대해 Confirmation\_key를 사용하여

- 아래에 설명된 대로 이 메시지에 대한 확인 태그를 확인하고 FramedContentAuthData 개체의 Confirmation\_tag 필드와 동일한지 확인합니다.

\* 위의 검사가 성공하면 새 GroupContext 개체를 그룹의 현재 상태로 간주합니다.

\* 커밋에 ReInit 제안이 포함된 경우 클라이언트는 그룹을 사용하여 더 이상 메시지를 보내면 안 됩니다. 대신 섹션 11.2의 요구 사항을 충족하는 커미터의 환영 메시지를 기다려야 합니다.\(MUST NOT, MUST\)

클라이언트는 그룹에서 자신을 제거하는 유효한 Commit 메시지를 수신할 준비가 되어 있어야 합니다. 이 경우 클라이언트는 그룹에서 더 이상 메시지를 보낼 수 없으며 그룹 상태와 비밀 트리를 즉시 삭제해야 합니다. \(클라이언트는 이전 시대의 늦은 메시지를 해독하기 위해 짧은 시간 동안 비밀 트리를 유지할 수 있습니다.\)\(SHOULD\)

---
#### **12.4.3.  Adding Members to the Group**

새 구성원은 그룹 구성원이 추가하거나 외부 커밋을 통해 자신을 추가하는 두 가지 방법으로 그룹에 가입할 수 있습니다. 두 경우 모두 새 구성원은 로컬 그룹 상태를 부트스트랩하기 위한 정보가 필요합니다.

```text
   struct {
       GroupContext group_context;
       Extension extensions<V>;
       MAC confirmation_tag;
       uint32 signer;
       /* SignWithLabel(., "GroupInfoTBS", GroupInfoTBS) */
       opaque signature<V>;
   } GroupInfo;
```

group\_context 필드는 그룹의 현재 상태를 나타냅니다. 확장 필드를 사용하면 보낸 사람이 새 참여자에게 유용할 수 있는 추가 데이터를 제공할 수 있습니다. Confirmation\_tag는 현재 epoch를 시작한 Commit의 확인 태그 또는 epoch 0의 경우 그룹 생성 시 계산된 확인 태그를 나타냅니다\(섹션 11 참조\). \(두 경우 모두 GroupInfo 생성자는 확인 태그를 MAC\(confirmation\_key, Confirmed\_transcript\_hash\)로 다시 계산할 수 있습니다.\)

섹션 13에서 설명한 것처럼 GroupInfo.extensions의 알 수 없는 확장은 무시해야 하며 GroupInfo 객체의 작성자는 다른 클라이언트가 알 수 없는 확장을 올바르게 무시하도록 돕기 위해 일부 임의의 GREASE 확장을 포함해야 합니다\(SHOULD\). 그러나 GroupInfo.group\_context.extensions의 확장은 새 결합자에 의해 지원되어야 합니다.\(MUST, MUST\)

신규 회원은 group\_id가 현재 참여하고 있는 그룹 중에서 고유한지 확인해야 합니다.\(MUST\)

신규 회원 또한 리프 인덱스 서명자와 래칫 트리의 리프 노드에서 가져온 공개 키를 사용하여 서명을 확인해야 합니다. 서명은 서명 위의 GroupInfo에 있는 모든 필드를 구성하는 다음 구조를 포함합니다.\(MUST\)

```text
   struct {
       GroupContext group_context;
       Extension extensions<V>;
       MAC confirmation_tag;
       uint32 signer;
   } GroupInfoTBS;
```

---
##### **12.4.3.1.  Joining via Welcome Message**

커밋 메시지 발신자는 제안 추가를 통해 추가된 각 새 멤버에게 환영 메시지를 보낼 책임이 있습니다. 환영 메시지의 형식을 사용하면 여러 새 구성원에 대해 단일 환영 메시지를 암호화할 수 있습니다. 주어진 커밋에 대해 얼마나 많은 환영 메시지를 생성할지 결정하는 것은 커미터에게 달려 있습니다. 커미터는 모든 새 구성원에 대해 암호화된 하나의 환영, 각 새 구성원에 대한 다른 환영 또는 새 구성원 배치에 대한 환영 메시지를 만들 수 있습니다\(응용 프로그램에 대해 잘 작동하는 일부 일괄 처리 체계에 따라\). 환영을 만들고 처리하는 프로세스는 주어진 환영이 암호화되는 새 구성원 집합을 제외하고는 모든 경우에 동일합니다.

환영 메시지는 커밋 메시지 적용 후 그룹의 현재 상태를 새 구성원에게 제공합니다. 새 구성원은 Commit 메시지를 해독하거나 확인할 수 없지만 Commit 메시지에 의해 시작된 시대에 참여하는 데 필요한 비밀을 갖게 됩니다.

동일한 환영 메시지를 여러 새 구성원에게 보낼 수 있도록 하기 위해 그룹을 설명하는 정보는 새 에포크에 대한 joiner\_secret에서 파생된 대칭 키 및 nonce로 암호화됩니다. 그러면 joiner\_secret이 HPKE를 사용하여 각각의 새 구성원에 대해 암호화됩니다. 동일한 암호화된 패키지에서 커미터는 커미터와 새 구성원 모두의 직접 경로에 포함된 가장 낮은\(리프에 가장 가까운\) 노드에 대한 경로 암호를 전송합니다. 이를 통해 새 구성원은 해당 Commit에 의해 재설정되는 직접 경로의 노드에 대한 개인 키를 계산할 수 있습니다.

환영 메시지의 발신자가 수신 구성원이 epoch\_secret 파생에 PSK를 포함하기를 원하는 경우 사용할 PSK를 나타내는 psks 필드를 채울 수 있습니다.

```text
   struct {
     opaque path_secret<V>;
   } PathSecret;

   struct {
     opaque joiner_secret<V>;
     optional<PathSecret> path_secret;
     PreSharedKeyID psks<V>;
   } GroupSecrets;

   struct {
     KeyPackageRef new_member;
     HPKECiphertext encrypted_group_secrets;
   } EncryptedGroupSecrets;

   struct {
     CipherSuite cipher_suite;
     EncryptedGroupSecrets secrets<V>;
     opaque encrypted_group_info<V>;
   } Welcome;
```

환영 메시지를 처리하는 클라이언트는 그룹의 래칫 트리 사본이 필요합니다. 이 트리는 ratchet\_tree 유형의 확장으로 환영 메시지에 제공될 수 있습니다. 그렇지 않은 경우\(예: 배달 서비스의 캐싱 서비스에서 제공\) 클라이언트는 환영을 처리하기 전에 트리를 다운로드해야 합니다.\(MUST\)

환영 메시지를 수신하면 클라이언트는 다음 단계를 사용하여 이를 처리합니다.

\* cipher\_suite 필드에 표시된 해시를 사용하여 new\_member 값이 이 클라이언트의 KeyPackages 중 하나에 해당하는 secrets 배열의 항목을 식별합니다. 해당 필드가 없거나 KeyPackage에 표시된 암호 그룹이 환영 메시지의 암호 그룹과 일치하지 않으면 오류를 반환합니다.

\* 참조된 KeyPackage의 init\_key에 해당하는 암호 그룹 및 개인 키 init\_key\_priv가 나타내는 알고리즘으로 encryption\_group\_secrets 값을 해독합니다.

```text
   encrypted_group_secrets =
     EncryptWithLabel(init_key, "Welcome",
                      encrypted_group_info, group_secrets)

   group_secrets =
     DecryptWithLabel(init_key_priv, "Welcome",
                      encrypted_group_info, kem_output, ciphertext)
```

\* PreSharedKeyID가 GroupSecret의 일부이고 클라이언트가 해당 PSK를 소유하지 않은 경우 오류를 반환합니다. 또한 PreSharedKeyID에 사용 재개 또는 분기가 포함된 재개 유형이 있는 경우 해당 PSK가 유일한 것인지 확인하십시오.

\* 복호화된 GroupSecrets 개체의 joiner\_secret 및 GroupSecrets에 지정된 PSK에서 welcome\_secret을 파생한 다음 welcome\_key 및 welcome\_nonce를 파생합니다. 키와 nonce를 사용하여 encryption\_group\_info 필드를 해독합니다.

```text
   welcome_nonce = ExpandWithLabel(welcome_secret, "nonce", "", AEAD.Nn)
   welcome_key = ExpandWithLabel(welcome_secret, "key", "", AEAD.Nk)
```

\* GroupInfo 개체의 서명을 확인합니다. 서명 입력은 서명 필드를 제외한 GroupInfo 개체의 모든 필드로 구성됩니다. 공개 키는 리프 인덱스 서명자가 있는 래칫 트리의 LeafNode에서 가져옵니다. 노드가 비어 있거나 서명 확인에 실패하면 오류를 반환합니다.

\* 클라이언트가 현재 참여하고 있는 그룹 중에서 group\_id가 고유한지 확인합니다.

\* GroupInfo의 cipher\_suite가

- KeyPackage의 cipher\_suite.

\* 래칫 트리의 무결성을 확인합니다.

- - 래칫 트리의 트리 해시가 GroupInfo의 tree\_hash 필드와 일치하는지 확인합니다.

- - 비어 있지 않은 각 부모 노드에 대해 섹션 7.9.2에 설명된 대로 "부모-해시 유효"인지 확인합니다.

- 비어 있지 않은 각 리프 노드에 대해 다음과 같이 LeafNode의 유효성을 검사합니다.

- 섹션 7.3에 설명되어 있습니다.

- - 비어 있지 않은 각 상위 노드와 노드의 unmerged\_leaves 필드에 있는 각 항목에 대해:

- o 항목이 부모 노드의 자손인 비어 있지 않은 리프 노드를 나타내는지 확인합니다.

- o 리프 노드와 상위 노드 사이의 비어 있지 않은 모든 중간 노드에도 unmerged\_leaves에 리프 노드에 대한 항목이 있는지 확인합니다.

- o 상위 노드의 암호화 키가 트리의 다른 노드에 나타나지 않는지 확인합니다.

\* LeafNode가 KeyPackage에 있는 것과 동일한 리프를 식별합니다. 해당 필드가 없으면 오류를 반환합니다. my\_leaf가 트리에서 이 리프를 나타내도록 합니다.

\* GroupInfo 개체의 정보를 사용하여 새 그룹 상태를 구성합니다.

- 그룹의 GroupContext를 초기화합니다.

- GroupInfo 개체의 group\_context 필드입니다.

- - 노드의 공개 키에 해당하는 개인 키로 리프 my\_leaf를 업데이트합니다. 여기서 my\_leaf는 위에 정의된 대로 래칫 트리에서 새 구성원의 리프 노드입니다.

- - GroupSecret 개체에 path\_secret 값이 설정되어 있는 경우: 리프 노드 my\_leaf와 리프 인덱스 GroupInfo.signer가 있는 멤버 노드의 최하위 공통 조상을 식별합니다. 이 노드의 개인 키를 path\_secret에서 파생된 개인 키로 설정하십시오.

- - 공통 조상의 각 부모에 대해 트리의 루트까지 새로운 경로 비밀을 도출하고, 경로 비밀에서 파생된 비밀키로 노드에 대한 비밀키를 설정한다. 개인 키는 노드의 공개 키에 해당하는 개인 키여야 합니다.\(MUST\)

\* GroupSecrets 개체의 joiner\_secret을 사용하여 현재 epoch에 대한 epoch 암호 및 기타 파생된 암호를 생성합니다.

\* 새로운 상태의 확인된 성적표 해시를 GroupInfo의 Confirmed\_transcript\_hash 값으로 설정합니다.

\* 파생된 확인 키와 GroupInfo에서 checked\_transcript\_hash를 사용하여 GroupInfo에서 확인 태그를 확인합니다.

\* 확인된 성적표 해시 및 확인 태그를 사용하여 새 상태에서 중간 성적표 해시를 계산합니다.

\* 사용 reinit 또는 분기가 있는 재개 유형이 있는 PreSharedKeyID가 사용된 경우 GroupInfo의 epoch 필드가 1인지 확인합니다.

- - 사용 reinit의 경우 참조된 그룹에 대한 마지막 커밋에 ReInit 제안이 포함되어 있고 GroupInfo의 group\_id, version, cipher\_suite 및 group\_context.extensions 필드가 ReInit 제안과 일치하는지 확인합니다. 또한 애플리케이션에 따라 이전 그룹의 모든 구성원이 새 그룹의 구성원이기도 ​​하는지 확인합니다.

- - 사용 분기의 경우 애플리케이션에 따라 새 그룹의 버전 및 cipher\_suite가 이전 그룹의 버전 및 cipher\_suite와 일치하고 새 그룹의 구성원이 이전 그룹 구성원의 하위 집합을 구성하는지 확인합니다.

---
##### **12.4.3.2.  Joining via External Commits**

외부 커밋은 기존 멤버가 추가 제안을 참조하는 커밋을 발행하기 위해 온라인에 접속할 필요 없이 새 멤버\(그룹의 멤버가 되고자 하는 외부 당사자\)가 자신을 그룹에 추가하는 메커니즘입니다.

그룹의 기존 구성원이 외부 커밋을 수락할지 또는 거부할지 여부는 다른 핸드셰이크 메시지에 적용되는 것과 동일한 규칙을 따릅니다.

새 구성원은 그룹의 현재 에포크에 대한 다음 정보에 액세스할 수 있는 경우 외부 Commit을 생성하고 발행할 수 있습니다.

```text
   *  group ID

   *  epoch ID

   *  cipher suite

   *  public tree hash

   *  confirmed transcript hash
```

\* 가장 최근 커밋 확인 태그

```text
   *  group extensions

   *  external public key
```

즉, 외부 커밋을 통해 그룹에 가입하려면 새 구성원은 extensions 필드에 external\_pub 확장자가 있는 GroupInfo가 필요합니다.

```text
   struct {
       HPKEPublicKey external_pub;
   } ExternalPub;
```

따라서 그룹의 구성원은 GroupInfo 개체를 사용할 수 있도록 하여 새 클라이언트가 가입하도록 할 수 있습니다. GroupInfo 개체는 에포크에 따라 다르므로 그룹이 진행됨에 따라 업데이트해야 합니다. 특히 각 GroupInfo 개체는 하나의 외부 조인에 사용할 수 있습니다. 외부 조인으로 인해 에포크가 변경되기 때문입니다.

tree\_hash 필드는 환영 메시지에서와 같은 방식으로 사용됩니다. 전체 트리는 ratchet\_tree 확장을 통해 포함될 수 있습니다\(섹션 12.4.3.3 참조\).

GroupInfo의 정보는 일반적으로 공개 정보가 아니지만 응용 프로그램은 외부 커밋을 허용하기 위해 새 구성원이 사용할 수 있도록 선택할 수 있습니다.

원칙적으로 외부 커밋은 일반 커밋처럼 작동합니다. 그러나 해당 콘텐츠는 다음과 같은 특정 요구 사항을 충족해야 합니다.

\* 외부 커밋은 경로 필드를 포함해야 합니다\(따라서 "전체" 커밋임\). 조이너는 가장 왼쪽의 자유 리프 노드에 추가되며\(마치 추가 제안으로 추가된 것처럼\) 경로는 해당 리프 노드를 기준으로 계산됩니다.\(MUST\)

\* Commit은 외부 참여자가 그룹 내에서 전송된 제안의 유효성을 결정할 수 없기 때문에 참조에 의한 제안을 포함해서는 안 됩니다.\(MUST NOT\)

\* 외부 커밋은 새 멤버가 서명해야 합니다. 특히 둘러싸는 AuthenticatedContent의 서명은 경로 필드의 leaf\_node에 있는 자격 증명에 대한 공개 키를 사용하여 확인해야 합니다.\(MUST, MUST\)

\* 커밋을 처리할 때 기존 구성원과 신규 구성원 모두 섹션 8.3에 설명된 대로 외부 초기화 비밀을 사용해야 합니다.\(MUST\)

\* 외부 커밋을 캡슐화하는 AuthenticatedContent의 발신자 유형은 new\_member\_commit이어야 합니다.\(MUST\)

외부 커밋에는 발신자를 그룹에 추가하는 "가입" 커밋과 구성원의 이전 모습을 새 모양으로 대체하는 "재동기화" 커밋의 두 가지 "종류"가 있습니다.

"재동기화" 작업을 통해 구성원의 서명 개인 키를 손상시킨 공격자가 그룹에 자신을 소개하고 단일 커밋에서 이전의 합법적인 구성원을 제거할 수 있습니다. 재동기화 없이도 이 작업을 계속 수행할 수 있지만 두 가지 작업이 필요합니다. 즉, 참여를 위한 외부 커밋과 이전 모양을 제거하기 위한 두 번째 커밋이 필요합니다. 이러한 구분이 두드러지는 애플리케이션은 제거를 포함하는 외부 커밋을 허용하지 않거나 그룹의 이전 에포크에서 참여 멤버의 존재를 보여주는 "재초기화" PSK 제안을 포함하는 경우에만 그러한 재동기화 커밋을 허용하도록 선택할 수 있습니다. 후자의 접근 방식을 사용하면 공격자는 PSK와 서명 키를 손상시켜야 하지만 응용 프로그램은 계속해서 재동기화하지 않는 구성원이 필요한 PSK를 갖도록 해야 합니다.

---
##### **12.4.3.3.  Ratchet Tree Extension**

기본적으로 GroupInfo 메시지는 결합자에게 그룹 래칫 트리의 해시만 제공합니다. 핸드셰이크 메시지를 처리하거나 생성하려면 결합자는 다른 소스에서 래칫 트리의 복사본을 가져와야 합니다. \(예를 들어 DS는 캐시된 복사본을 제공할 수 있습니다.\) GroupInfo 메시지에 트리 해시가 포함된다는 것은 트리의 무결성을 유지하기 위해 래칫 트리의 소스를 신뢰할 필요가 없음을 의미합니다.

응용 프로그램이 이러한 외부 소스를 제공하지 않으려는 경우 래칫 트리의 전체 공개 상태는 다음 형식의 ratchet\_tree 개체를 포함하는 ratchet\_tree 유형의 확장으로 제공될 수 있습니다.

```text
   struct {
       NodeType node_type;
       select (Node.node_type) {
           case leaf:   LeafNode leaf_node;
           case parent: ParentNode parent_node;
       };
   } Node;

   optional<Node> ratchet_tree<V>;
```

ratchet\_tree 벡터의 각 항목은 트리의 노드에 대한 값 또는 빈 노드에 대한 선택적 null을 제공합니다.

노드는 래칫 트리의 왼쪽에서 오른쪽 순회에 의해 지정된 순서대로 나열됩니다. 각 노드는 왼쪽 하위 트리와 오른쪽 하위 트리 사이에 나열됩니다. \(이는 부록 C에 설명된 배열 기반 트리에 대해 지정된 것과 동일한 순서입니다.\)

트리에 2^d 잎이 있으면 2^\(d+1\) - 1 노드가 있습니다. ratchet\_tree 벡터는 논리적으로 이 수의 항목을 갖지만 발신자는 마지막 비어 있지 않은 노드 다음에 공백 노드를 포함해서는 안 됩니다. 수신자는 ratchet\_tree의 마지막 노드가 비어 있지 않은지 확인한 다음 가능한 최소 공백 값 수를 추가하여 2^\(d+1\) - 1 형식의 길이가 될 때까지 트리를 오른쪽으로 확장해야 합니다. \(분명히 이것은 실제로 메모리의 구조를 변경하는 것과는 반대로 필요할 때 빈 노드를 합성하여 "가상"으로 수행될 수 있습니다.\)\(MUST NOT, MUST\)

트리의 잎은 배열의 짝수 항목에 저장됩니다\(배열 위치 2\*L에 인덱스 L이 있는 잎\). 트리의 루트 노드는 배열의 2^d - 1 위치에 있습니다. 다음 알고리즘과 같이 루트의 왼쪽과 오른쪽에 있는 하위 배열에 대해 동일한 계산을 수행하여 중간 상위 노드를 식별할 수 있습니다.

```text
   # Assuming a class Node that has left and right members
   def subtree_root(nodes):
       # If there is only one node in the array, return it
       if len(nodes) == 1:
           return Node(nodes[0])

       # Otherwise, the length of the array MUST be odd
       if len(nodes) % 2 == 0:
           raise Exception("Malformed node array {}", len(nodes))

       # Identify the root of the subtree
       d = 0
       while (2**(d+1)) < len(nodes):
          d += 1
       R = 2**d - 1
       root = Node(nodes[R])
       root.left = subtree_root(nodes[:R])
       root.right = subtree_root(nodes[(R+1):])
       return root
```

\(이것은 부록 C에 설명된 배열 기반 트리 표현과 동일한 노드 순서입니다. 해당 섹션의 알고리즘은 이 확장을 다른 표현으로 디코딩하는 것을 단순화하는 데 사용될 수 있습니다.\)

예를 들어, 6개의 비어 있지 않은 리프가 있는 다음 트리는 \[A, W, B, X, C, \_, D, Y, E, Z, F\]의 11개 요소 배열로 표시됩니다. 위의 디코딩 절차는 다음과 같이 하위 트리 루트를 식별합니다\(R을 사용하여 하위 트리 루트를 나타냄\).

```text
                 Y
                 |
           .-----+-----.
          /             \
         X               _
         |               |
       .-+-.           .-+-.
      /     \         /     \
     W       _       Z       _
    / \     / \     / \     / \
   A   B   C   D   E   F   _   _

                       1
   0 1 2 3 4 5 6 7 8 9 0
   <-----------> R <----------->
   <---> R <--->   <---> R <--->
   - R -   - R -   - R -   - R -
```

- 그림 28: 6개 구성원 트리의 왼쪽에서 오른쪽 순회

GroupInfo 메시지에 ratchet\_tree 확장이 있어도 그룹의 GroupContext 확장이 변경되지 않습니다. 제공된 래칫 트리는 단순히 클라이언트에 의해 저장되고 MLS 작업에 사용됩니다.

이 확장이 환영 메시지에 제공되지 않으면 클라이언트는 Commit 메시지를 생성하거나 처리하기 전에 다른 채널을 통해 래칫 트리를 가져와야 합니다. 애플리케이션은 이 대역 외 채널에 제안 및 커밋 메시지에 제공되는 보호와 동일한 보안 보호가 제공되는지 확인해야 합니다. 예를 들어 제안 및 커밋 메시지를 암호화하는 애플리케이션은 MLS 채널을 통해 교환된 키를 사용하여 암호화된 래칫 트리를 배포할 수 있습니다.

클라이언트가 트리를 얻는 방법에 관계없이 클라이언트는 MLS 작업에 트리를 사용하기 전에 래칫 트리의 루트 해시가 GroupContext의 tree\_hash와 일치하는지 확인해야 합니다.\(MUST\)

---
## **13.  Extensibility**

기본 MLS 프로토콜은 몇 가지 방법으로 확장할 수 있습니다. 새로운 암호화 알고리즘을 사용할 수 있도록 새로운 암호화 제품군을 추가할 수 있습니다. 새로운 유형의 제안을 사용하여 에포크 내에서 새로운 작업을 수행할 수 있습니다. 확장 필드를 사용하여 프로토콜에 추가 정보를 추가할 수 있습니다. 이 섹션에서는 광범위한 상호 운용성을 보장하는 데 필요한 이러한 확장성 메커니즘에 대한 몇 가지 제약 사항에 대해 설명합니다.

---
### **13.1.  Additional Cipher Suites**

섹션 5.1에서 설명한 것처럼 MLS를 사용하면 그룹의 참가자가 그룹 내에서 사용되는 암호화 알고리즘을 협상할 수 있습니다. 이 확장성은 시간이 지남에 따라 프로토콜의 보안을 유지하는 데 중요합니다\[RFC7696\]. 또한 공통 암호 제품군을 지원하지 않는 클라이언트로 인해 상호 운용성 실패의 위험이 있습니다.

섹션 17.1에 정의된 암호 그룹 레지스트리는 이 점에서 균형을 맞추려고 시도합니다. 한편으로 레지스트리에 대한 기본 정책은 틈새 응용 프로그램에 다른 암호가 필요한 경우 표준 작업의 필요성을 피하기 위해 설계된 상당히 낮은 기준인 사양 필요입니다. 반면에 암호가 레지스트리에서 권장 필드를 설정하기 위한 더 높은 기준\(표준 작업\)이 있습니다. 이 높은 기준은 부분적으로 새로운 암호 제품군의 상호 운용성 영향을 고려하기 위한 것입니다.

MLS 암호 그룹은 MLS 버전과 독립적으로 정의되므로 원칙적으로 동일한 암호 그룹을 여러 버전에서 사용할 수 있습니다. MLS의 새 버전을 정의하는 표준 작업은 새 버전이 기존 암호화 제품군과 호환되는 것이 바람직한지 또는 새 버전이 일부 암호화 제품군을 배제해야 하는지 여부를 고려해야 합니다. 예를 들어 새 버전은 허용된 TLS 암호 집합을 제한하는 HTTP/2의 예를 따를 수 있습니다\(\[RFC9113\]의 섹션 9.2.2 참조\).

---
### **13.2.  Proposals**

제안 세트가 확장 가능하기 때문에 커밋 메시지에는 확장 필드가 없습니다. 섹션 12.4에서 논의된 바와 같이, 커밋을 처리할 그룹의 모든 구성원이 제안 유형을 지원하지 않는 한 기본 제안 유형이 아닌 제안은 커밋에 포함되어서는 안 됩니다\(MUST NOT\).\(MUST NOT\)

---
### **13.3.  Credential Extensibility**

MLS가 의미 있는 인증을 제공하도록 하기 위해서는 각 구성원이 서로의 일부 ID 정보를 인증할 수 있는 것이 중요합니다. ID 정보는 Credentials에 인코딩되므로 구성원이 호환되는 자격 증명 유형을 사용하도록 보장하여 이 속성이 제공됩니다.

그룹에서 사용할 수 있는 자격 증명의 유일한 유형은 래칫 트리에서 각 LeafNode의 기능 필드에 지정된 대로 그룹의 모든 구성원이 지원하는 자격 증명 유형입니다. 애플리케이션은 섹션 17.5의 레지스트리에서 할당되지 않은 식별자를 선택하고 기존 그룹에 대한 업데이트 제안 또는 새 그룹에 추가된 KeyPackage에서 게시된 LeafNode의 자격 증명 유형에 대한 지원을 표시하여 새 자격 증명 유형을 도입할 수 있습니다. 그룹의 모든 구성원이 자격 증명 유형에 대한 지원을 나타내면 구성원은 새 자격 증명으로 LeafNodes를 사용할 수 있습니다. 응용 프로그램은 그룹의 GroupContext에 required\_capabilities 확장을 추가하여 특정 자격 증명 유형이 항상 지원되도록 강제할 수 있습니다. 그러면 이를 지원하지 않는 그룹에 구성원이 추가되지 않습니다.

MLS에 대한 향후 확장에서 회원이 둘 이상의 자격 증명을 제시하도록 허용하는 것이 유용할 수 있습니다. 예를 들어 이러한 자격 증명은 다른 기관에서 증명한 다른 특성을 나타낼 수 있습니다. 이 섹션의 시작 부분에 언급된 일반 원칙과 일치하려면 이러한 확장은 각 구성원이 서로 다른 구성원에 대해 일부 ID를 인증할 수 있도록 해야 합니다. 각 구성원 쌍\(Alice, Bob\)에 대해 Alice는 Bob이 지원하는 유형의 자격 증명을 하나 이상 제공해야 합니다.

---
### **13.4.  Extensions**

이 프로토콜에는 TLS\[RFC8446\]에 있는 것과 유사한 확장 매개변수 협상을 위한 메커니즘이 포함되어 있습니다. TLS에서 확장 협상은 일대일입니다. 클라이언트는 ClientHello 메시지에서 확장을 제공하고 서버는 ServerHello 및 EncryptedExtensions 메시지에서 확장이 있는 세션에 대한 선택을 표현합니다. MLS에서 확장은 다음 위치에 나타납니다.

\* KeyPackages에서 클라이언트와 관련된 추가 정보를 기술하기 위해

```text
   *  In LeafNodes, to describe additional information about the client
      or its participation in the group (once in the ratchet tree)
```

\* GroupInfo에서 그룹의 새 구성원에게 그룹에서 사용 중인 매개 변수를 알리고 그룹에 가입하는 데 필요한 추가 세부 정보를 제공합니다.

\* GroupContext 개체에서 그룹의 모든 구성원이 사용 중인 매개변수에 대해 동일한 보기를 갖도록 보장

즉, 응용 프로그램은 GroupContext 확장을 사용하여 그룹의 모든 구성원이 일련의 매개 변수에 동의하는지 확인할 수 있습니다. 클라이언트는 LeafNode의 기능 필드에서 매개변수에 대한 지원을 나타냅니다. 그룹의 새 구성원은 GroupInfo 개체의 group\_context 필드에 있는 extensions 필드를 통해 그룹의 GroupContext 확장에 대해 알립니다. GroupInfo 개체의 extensions 필드\(group\_context 필드 외부\)는 그룹에 가입하는 데 사용되는 새 참여자에게 추가 매개변수를 제공하는 데 사용할 수 있습니다.

이 확장 메커니즘은 안전하고 앞으로 호환되는 확장 협상을 허용하도록 설계되었습니다. 이것이 작동하려면 구현이 확장 가능한 필드를 올바르게 처리해야 합니다.\(MUST\)

\* KeyPackage를 게시하는 클라이언트는 광고된 모든 매개변수를 지원해야 합니다. 그렇지 않으면 다른 클라이언트가 해당 매개변수 중 하나를 선택하여 상호 운용하지 못할 수 있습니다.\(MUST\)

\* KeyPackage 객체를 처리하는 클라이언트는 모든 것을 무시해야 합니다.

- LeafNode의 기능 필드에 있는 인식할 수 없는 값과 확장 및 leaf\_node.extensions 필드에 있는 모든 알 수 없는 확장. 그렇지 않으면 최신 클라이언트와 상호 운용되지 않을 수 있습니다.\(MUST\)

\* GroupInfo 객체를 처리하는 클라이언트는 모든 것을 무시해야 합니다.

- 확장자 필드에 인식되지 않는 확장자가 있습니다.\(MUST\)

\* 확장자 목록을 포함하는 모든 필드는 주어진 유형의 확장자를 두 개 이상 가질 수 없습니다\(MUST NOT\).\(MUST NOT\)

\* 그룹에 새 구성원을 추가하는 클라이언트는 새 구성원의 LeafNode가 그룹의 확장과 호환되는지 확인해야 합니다. 기능 필드는 GroupContext의 각 확장에 대한 지원을 나타내야 합니다.\(MUST, MUST\)

\* 그룹에 가입하는 클라이언트는 그룹에 대한 GroupContext의 모든 확장을 지원하는지 확인해야 합니다. 그렇지 않으면 둘러싸는 GroupInfo 메시지를 유효하지 않은 것으로 취급하고 그룹에 가입하지 않아야 합니다.\(MUST, MUST\)

후자의 두 가지 요구 사항은 그룹에서 사용 중인 확장이 그룹의 모든 구성원에 의해 지원되어야 한다는 의미에서 모든 MLS GroupContext 확장이 필수임을 의미합니다.\(MUST\)

추가 확장을 활성화하기 위해 GroupContextExtensions 제안을 보내거나\(섹션 12.1.7\) 그룹을 다시 초기화하여\(섹션 11.2\) 그룹의 매개변수를 변경할 수 있습니다.

---
### **13.5.  GREASE**

섹션 13.4에 설명된 대로 클라이언트는 특정 매개변수에 대해 알 수 없는 값을 무시해야 합니다. 다른 클라이언트가 이 동작을 구현하도록 돕기 위해 클라이언트는 \[RFC8701\]에 설명된 "임의 확장 생성 및 확장성 유지" 또는 GREASE 접근 방식을 따를 수 있습니다. MLS의 맥락에서 이것은 KeyPackage, LeafNode 또는 GroupInfo 개체를 생성하는 클라이언트가 메시지를 처리하는 올바르게 구현된 클라이언트에서 무시할 특정 필드에 임의의 값을 포함한다는 것을 의미합니다. 알 수 없는 코드 포인트를 잘못 거부하는 클라이언트는 이러한 메시지를 처리하지 못하여 클라이언트를 수정해야 한다는 신호를 구현자에게 제공합니다.

다음 필드를 생성할 때 MLS 클라이언트는 이러한 GREASE 값에서 선택한 임의의 값을 포함해야 합니다\(SHOULD\).\(SHOULD\)

```text
   *  LeafNode.capabilities.cipher_suites

   *  LeafNode.capabilities.extensions

   *  LeafNode.capabilities.proposals

   *  LeafNode.capabilities.credentials

   *  LeafNode.extensions

   *  KeyPackage.extensions

   *  GroupInfo.extensions
```

KeyPackage 및 GroupInfo 확장의 경우 GREASE 확장의 extension\_data는 올바르게 구현된 수신자에 의해 무시되기 때문에 발신자가 선택한 내용을 가질 수 있습니다. 예를 들어 발신자는 임의 크기의 임의 데이터로 이러한 확장을 채울 수 있습니다.\(MAY\)

LeafNode.extensions에 추가된 모든 GREASE 값은 LeafNode.capabilities.extensions에 반영되어야 합니다. 섹션 7.3에 설명된 LeafNode 유효성 검사 프로세스에서는 이 두 필드가 일치해야 하기 때문입니다.

GREASE 값은 다음 필드에 보내서는 안 됩니다. 이러한 필드 중 하나에서 지원되지 않는 값\(GREASE 값 포함\)이 포함된 메시지가 거부되기 때문입니다.\(MUST NOT\)

```text
   *  Proposal.proposal_type

   *  Credential.credential_type

   *  GroupContext.extensions

   *  GroupContextExtensions.extensions
```

GREASE에 대해 예약된 값은 섹션 17의 다양한 레지스트리에 등록되었습니다. 이것은 GREASE와 실제 미래 값 간의 충돌을 방지합니다. 다음 값은 각 레지스트리에 예약되어 있습니다. \(값 0xFAFA는 개인 사용 범위에 속합니다.\) 이 값은 위에 나열된 필드에만 나타나야 하며, 예를 들어 제안의 proposal\_type 필드에는 나타나지 않아야 합니다. 클라이언트는 이러한 값을 수신할 때 이러한 값을 처리하는 방법에 대한 특별한 처리 규칙을 구현해서는 안 됩니다. 이는 확장성 실패를 감지하는 유틸리티를 무효화하기 때문입니다.\(MUST, MUST NOT\)

GREASE 값은 지원되지 않는 값을 처리하기 위한 일반 논리를 사용하여 처리해야 합니다. 상호 지원 기능을 식별하기 위해 기능 목록을 비교할 때 클라이언트는 GREASE 값 없이 실제로 지원되는 기능만 포함하는 목록으로 자신의 기능을 나타내야 합니다. 즉, GREASE 값을 포함하는 목록은 다른 클라이언트에게만 전송됩니다. 클라이언트 자체 기능의 표현에는 GREASE 값이 포함되어서는 안 됩니다\(MUST NOT\).\(MUST, MUST, MUST NOT\)

---
## **14.  Sequencing of State Changes**

각 Commit 메시지는 주변을 둘러싼 FramedContent의 epoch 필드로 표시되는 지정된 시작 상태를 전제로 합니다. Commit 메시지가 암시하는 변경 사항이 다른 상태에서 시작되면 결과가 올바르지 않습니다.

이러한 시퀀싱의 필요성은 그룹 구성원이 Commit 메시지를 보낼 때마다 그룹의 최신 상태를 기반으로 하는 한 문제가 되지 않습니다. 그러나 실제로는 두 구성원이 동일한 상태를 기반으로 Commit 메시지를 동시에 생성할 위험이 있습니다.

애플리케이션에는 동일한 에포크에 대한 커밋 메시지 충돌을 해결하기 위한 확립된 방법이 있어야 합니다. 충돌하는 메시지가 처음부터 발생하는 것을 방지하거나 한 시대에 전송된 여러 Commit 중 어떤 것이 정식인지 결정하는 규칙을 개발하여 이를 수행할 수 있습니다. 선택한 접근 방식은 분기 또는 이전 그룹 상태가 메모리에 유지되는 시간을 최소화해야 하며 순방향 비밀성을 보장하는 데 더 이상 필요하지 않으면 즉시 삭제해야 합니다.\(MUST, MUST\)

커밋 메시지의 생성은 클라이언트의 상태를 수정해서는 안 됩니다. 클라이언트는 커밋 메시지에 의해 암시된 변경 사항이 다른 커밋과 충돌하는지 여부를 당시에 알지 못하기 때문입니다. 마찬가지로 Commit에 해당하는 환영 메시지는 Commit이 수락되었다는 것이 분명해질 때까지 새로운 참여자에게 전달되어서는 안 됩니다.\(MUST NOT, MUST NOT\)

메시지가 순서대로 유지되는 방법에 관계없이 충분히 바쁜 그룹에서 특정 구성원은 항상 다른 구성원에게 지기 때문에 Commit 메시지를 보낼 수 없는 위험이 있습니다. 이것이 실질적인 문제인 정도는 응용 프로그램의 역학에 따라 달라집니다.

---
## **15.  Application Messages**

핸드셰이크 메시지의 기본 목적은 인증된 그룹 키 교환을 클라이언트에 제공하는 것입니다. 그룹 구성원 간에 전송되는 응용 프로그램 메시지를 보호하기 위해 키 일정에서 제공하는 encryption\_secret을 사용하여 메시지 암호화를 위한 nonce 및 키 시퀀스를 파생합니다. 모든 epoch는 키 일정을 앞으로 이동하여 섹션 9에 설명된 대로 각 구성원에 대한 nonce 및 키의 새로운 대칭 래칫 세트와 함께 새로운 비밀 트리 생성을 트리거합니다.

각 클라이언트는 자신이 그룹 구성원인 동안 각 에포크에 대한 주요 일정의 자체 로컬 복사본을 유지 관리합니다. 필요에 따라 새 키, nonce 및 비밀을 파생하고 이전 키는 사용하자마자 삭제합니다.

그룹 식별자와 에포크를 통해 수신자는 어떤 그룹 비밀이 사용되어야 하고 어떤 epoch\_secret에서 다른 비밀 계산을 시작해야 하는지 알 수 있습니다. 발신자 식별자와 콘텐츠 유형은 비밀 트리에서 사용할 대칭 래칫을 식별하는 데 사용됩니다. 생성 카운터는 암호화 또는 암호 해독에 필요한 nonce 및 키를 생성하기 위해 래칫이 반복되는 정도를 결정합니다.

---
### **15.1.  Padding**

애플리케이션 메시지는 암호화된 트래픽을 통한 트래픽 분석 기술에 대한 저항을 제공하기 위해 채워질 수 있습니다\[CLINIC\] \[HCJ16\]. MLS는 기존 웹 서버보다 많은 암호문에서 동일한 페이로드를 덜 자주 전달할 수 있지만 여전히 공격자에게 공격을 시작하기에 충분한 정보를 제공할 수 있습니다. 앨리스가 밥에게 "언제 영화 보러 갈까?\(MAY\)

PrivateMessageContent의 패딩 필드 길이는 메시지 암호화 시 보낸 사람이 선택할 수 있습니다. 보낸 사람은 패딩을 사용하여 그룹 외부의 공격자가 암호화된 콘텐츠의 크기를 추측할 수 있는 능력을 줄일 수 있습니다. 그러나 MLS 메시지를 전달하는 데 사용되는 전송에는 최대 메시지 크기가 있을 수 있으므로 패딩 체계는 주어진 배포 시나리오에 존재하는 그러한 제한을 초과하여 메시지 크기가 증가하는 것을 피해야 합니다.\(SHOULD\)

---
### **15.2.  Restrictions**

각 시대 동안 발신자는 \[CFRG-AEAD-LIMITS\]를 사용하는 AEAD 체계의 보안 범위에서 허용하는 것보다 더 많은 데이터를 암호화하면 안 됩니다\(MUST NOT\).\(MUST NOT\)

핸드셰이크 메시지를 통해 그룹을 변경할 때마다 새 encryption\_secret도 설정됩니다. 따라서 이 변경 사항은 새 애플리케이션 메시지를 암호화하기 전에 적용해야 합니다. 이는 그룹에서 제거된 사용자가 더 이상 메시지를 받을 수 없도록 하고 \(잠재적으로\) 과거 상태 손상에도 불구하고 향후 메시지의 기밀성과 신뢰성을 복구하는 데 모두 필요합니다.\(MUST\)

---
### **15.3.  Delayed and Reordered Application Messages**

각 애플리케이션 메시지에는 그룹 식별자, 에포크 및 생성 카운터가 포함되어 있으므로 클라이언트는 메시지를 순서 없이 수신할 수 있습니다. 메시지가 잘못된 순서로 수신되면 클라이언트는 수신된 생성 카운터와 일치하도록 발신자 래칫을 앞으로 이동합니다. 래칫에서 사용하지 않은 논스 및 키 쌍은 잠재적으로 저장되어 지연되거나 재정렬된 메시지를 해독하는 데 사용할 수 있습니다.

애플리케이션은 보낸 사람에 대해 사용하지 않은 논스 및 키 쌍을 보관하는 기간과 보관할 최대 수에 대한 정책을 정의해야 합니다\(SHOULD\). 이는 섹션 9.2에 정의된 삭제 일정에 따라 이러한 비밀이 삭제되도록 하는 것 외에도 추가됩니다. 애플리케이션은 또한 클라이언트가 새 메시지에 대한 응답으로 래칫을 앞으로 움직일 최대 단계 수를 제한하는 정책을 정의해야 합니다\(SHOULD\). 수신된 마지막 메시지보다 너무 높은 생성 카운터로 수신된 메시지는 거부됩니다. 이렇게 하면 수신자가 과도한 수의 키 파생을 수행하도록 요구하여 서비스 거부 공격이 발생하는 것을 방지할 수 있습니다. 예를 들어 악의적인 그룹 구성원은 새 에포크가 시작될 때 generation = 0xffffffff인 메시지를 보낼 수 있으며 수신자는 위에서 설명한 유형의 제한을 적용하지 않는 한 수십억 개의 키 파생을 수행해야 합니다.\(SHOULD, SHOULD\)

---
## **16.  Security Considerations**

MLS의 보안 목표는 \[MLS-ARCH\]에 설명되어 있습니다. 완전한 보안 분석은 이 문서의 범위를 벗어나지만 여기서 프로토콜이 높은 수준에서 목표를 달성하는 방법을 설명합니다. \[MLS-ARCH\]의 보안 고려 사항 섹션은 자세한 보안 분석에 대한 일부 인용을 제공합니다.

---
### **16.1.  Transport Security**

MLS 메시지는 메시지 수준에서 보호되기 때문에 그룹 상태의 기밀성과 무결성은 전송 중에 보호되는 메시지에 의존하지 않습니다. 그러나 전송 중인 메시지를 관찰할 수 있는 공격자는 잠재적인 그룹 구성원을 포함하여 그룹 상태에 대해 알 수 있습니다\(아래 섹션 16.4.3 참조\). 이러한 공격자는 그룹에 서비스 거부 공격을 가하거나 전송 중인 메시지를 선택적으로 제거하여 새 구성원을 제외할 수도 있습니다. 이러한 형태의 공격을 방지하기 위해 모든 MLS 메시지는 TLS\[RFC8446\] 또는 QUIC\[RFC9000\]과 같은 보안 전송을 통해 전달되는 것이 좋습니다.\(SHOULD\)

---
### **16.2.  Confidentiality of Group Secrets**

그룹 비밀은 부분적으로 래칫 트리의 출력에서 ​​파생됩니다. 래칫 트리는 그룹의 각 구성원을 트리의 리프에 할당하고 다음 속성을 유지하여 작동합니다. 트리에 있는 노드의 개인 키는 노드의 하위 트리에서 리프가 할당된 그룹의 구성원에게만 알려져 있습니다. 이를 \_tree invariant\_라고 하며, 그룹 구성원 수에 대수적인 여러 암호문을 사용하여 한 명을 제외한 모든 그룹 구성원을 암호화할 수 있습니다.

한 명을 제외한 모든 구성원을 효율적으로 암호화하는 기능을 통해 구성원을 그룹에서 안전하게 제거할 수 있습니다. 또한 구성원이 이전 개인 키를 더 이상 새 메시지를 해독하는 데 사용할 수 없도록 키 쌍을 회전할 수 있습니다.

---
### **16.3.  Confidentiality of Sender Data**

PrivateMessage 프레이밍은 섹션 6.3.2에 설명된 대로 암호화된 메시지를 보낸 그룹 구성원을 식별하는 "발신자 데이터"를 암호화합니다. QUIC 헤더 보호 체계\[RFC9001\], 섹션 5.4와 마찬가지로 이 체계는 \[NAN\]에서 분석된 HN1 구성의 변형입니다. 암호문의 샘플은 sender\_data\_secret과 결합되어 발신자 데이터의 AEAD 암호화에 사용되는 키 및 nonce를 도출합니다.

```text
   (key, nonce) = PRF(sender_data_secret, sample)
   encrypted_sender_data =
     AEAD.Seal(key, nonce, sender_data_aad, sender_data)
```

이 구성과 \[NAN\]에 설명된 HN1의 유일한 차이점은 \(1\) 인증되지 않은 암호화 대신 인증된 암호화를 사용하고 \(2\) 임시값 자체 대신 임시값을 파생시키는 데 사용되는 정보를 보호한다는 것입니다.

sender\_data\_secret은 콘텐츠 암호화 키와 구별되기 때문에 발신자 데이터 암호화 체계는 \[NAN\]에 정의된 AE2 보안을 달성하므로 발신자 데이터의 기밀성을 보장합니다.

동일한 sender\_data\_secret 및 ciphertext 샘플을 두 번 이상 사용하면 AEAD\(key, nonce\) 쌍을 재사용하여 발신자 데이터 보호를 손상시킬 위험이 있습니다. 예를 들어 많은 AEAD 체계에서 키와 nonce를 재사용하면 두 일반 텍스트의 배타적 OR이 드러납니다. AEAD 알고리즘의 암호문 출력이 무작위 데이터와 구별할 수 없다고 가정하면\(즉, AEAD는 \[NAN\] 구문에서 AE1-보안\) 두 암호문 샘플이 동일할 확률은 대략 2^\(-L/2\)입니다. 즉, 생일 바인딩.

이 문서에 정의된 암호 그룹에 대한 AEAD 알고리즘은 모두 이 속성을 제공합니다. 샘플의 크기는 암호 그룹의 해시 함수에 따라 다르지만 모든 경우에 충돌 확률은 2^-128 이하입니다. 미래의 모든 암호 제품군은 AE1 보안 AEAD 알고리즘을 사용해야 합니다.\(MUST\)

---
### **16.4.  Confidentiality of Group Metadata**

MLS는 메시지 내의 일부 메시지 및 필드에 기밀 보호를 제공하지 않습니다.

```text
   *  KeyPackage messages

   *  GroupInfo messages
```

\* 환영 메시지의 암호화되지 않은 부분

\* PublicMessage 메시지로 전송된 모든 제안 또는 커밋 메시지

\* PrivateMessage 메시지의 암호화되지 않은 헤더 필드

\* 암호화된 Welcome 및 PrivateMessage 메시지의 길이

그룹의 래칫 트리를 새 구성원에게 기밀로 배포하기 위해 MLS가 제공하는 유일한 메커니즘은 그것을 ratchet\_tree 확장으로 환영 메시지에 보내는 것입니다. 응용 프로그램이 다른 방식으로 트리를 배포하는 경우 보안은 해당 응용 프로그램 메커니즘에 따라 달라집니다.

이러한 필드를 관찰하는 당사자는 그룹의 특정 속성을 추론할 수 있습니다.

```text
   *  Group ID
```

\* 현재 에포크 및 에포크 변경 빈도

\* 에포크 내의 메시지 빈도

```text
   *  Group extensions

   *  Group membership
```

그룹 외부 당사자에게 노출되는 메타데이터의 양과 이러한 당사자가 그룹의 속성을 추론할 수 있는 능력은 다음과 같은 DS 설계의 여러 측면에 따라 달라집니다.

\* KeyPackage가 배포되는 방식

\* 래칫 트리 분포 방식

\* 장래의 외부 참여자가 그룹에 대한 GroupInfo 개체를 가져오는 방법

\* Proposal 및 Commit 메시지를 PublicMessage로 보낼지 PrivateMessage로 보낼지 여부

이 섹션의 나머지 부분에서는 그룹의 위 속성이 지정된 응용 프로그램에서 노출되거나 보호되는 방법을 이해하기 위한 지침으로 보호되지 않은 그룹 메시지에 반영되는 방식에 주목합니다.

---
#### **16.4.1.  GroupID, Epoch, and Message Frequency**

MLS는 DS에서 메시지의 그룹 ID와 에포크를 보호하는 메커니즘을 제공하지 않으므로 그룹 ID와 메시지 빈도 및 에포크 변경은 DS의 검사로부터 보호되지 않습니다. 그러나 이를 수정하면 암호 해독에 실패합니다.

---
#### **16.4.2.  Group Extensions**

그룹의 확장은 먼저 그룹 생성자가 설정한 다음 GroupContextExtensions 제안에 의해 업데이트됩니다. PublicMessage로 전송된 GroupContextExtensions 제안은 그룹의 확장을 유출합니다.

새 구성원은 GroupInfo 개체를 통해 그룹의 확장을 학습합니다. 새 구성원이 환영 메시지를 통해 가입하면 환영 메시지의 암호화가 GroupInfo 메시지를 보호합니다. 새 구성원이 외부 조인을 통해 조인하는 경우 GroupInfo 개체가 제공되어야 합니다. 이 GroupInfo 개체의 보호는 응용 프로그램에 달려 있습니다. 그룹 및 새 참여자에게 기밀이 아닌 채널을 통해 전송되는 경우 그룹의 확장이 누출됩니다.

---
#### **16.4.3.  Group Membership**

각 구성원의 LeafNode에는 구성원의 암호 키, 구성원의 ID에 대한 정보가 포함된 자격 증명 및 기타 식별자가 포함되어 있기 때문에 그룹 구성원은 래칫 트리로 직접 표시됩니다. 그룹 외부에 그룹의 래칫 트리를 노출하는 애플리케이션도 그룹의 구성원 자격을 유출합니다.

그룹 구성원에 대한 변경은 제안 추가 및 제거를 통해 이루어집니다. 이러한 제안이 PublicMessage로 전송되면 해당 그룹 구성원의 변경 사항에 대한 정보가 유출됩니다. 이러한 모든 변경 사항을 보는 당사자는 그룹 구성원을 재구성할 수 있습니다.

환영 메시지에는 환영 메시지가 암호화된 각 KeyPackage의 해시가 포함됩니다. 당사자가 KeyPackage 풀에 액세스할 수 있고 환영 메시지를 관찰하면 새 구성원을 나타내는 KeyPackage를 식별할 수 있습니다. 당사자가 환영을 그룹과 연관시킬 수도 있는 경우 당사자는 식별된 새 구성원이 해당 그룹에 추가되었음을 유추할 수 있습니다.

이러한 정보 유출은 래칫 트리에서 구성원의 LeafNode 내용에 의해 구성원이 드러나는 정도까지만 그룹의 구성원임을 나타냅니다. 경우에 따라 이메일 주소와 같은 식별자를 증명하는 자격 증명으로 인해 매우 직접적일 수 있습니다. 응용 프로그램은 예를 들어 익명 자격 증명을 사용하고 자주 회전하는 암호화 및 서명 키를 사용하여 덜 식별되도록 구성원의 리프 노드를 구성할 수 있습니다.

---
### **16.5.  Authentication**

우리가 제공하는 인증의 첫 번째 형식은 그룹 구성원이 그룹 구성원 중 한 명이 보낸 메시지를 확인할 수 있다는 것입니다. 암호화된 메시지의 경우 메시지가 그룹 암호에서 파생된 키 아래의 AEAD로 암호화되기 때문에 이것이 보장됩니다. 일반 텍스트 메시지의 경우 이는 그룹 비밀에서 파생된 키 아래 메시지를 통해 MAC을 구성하는 Membership\_tag를 사용하여 보장됩니다.

인증의 두 번째 형식은 그룹 구성원이 그룹의 특정 구성원이 보낸 메시지를 확인할 수 있다는 것입니다. 이는 보낸 사람의 서명 키에서 각 메시지의 디지털 서명으로 보장됩니다.

그룹 구성원이 보유한 서명 키는 활성 공격에 대한 MLS 보안에 매우 중요합니다. 구성원의 서명 키가 손상된 경우 공격자는 구성원을 가장하는 LeafNode 및 KeyPackage를 생성할 수 있습니다. 애플리케이션에 따라 공격자가 손상된 구성원의 ID로 그룹에 가입할 수 있습니다. 예를 들어 그룹이 외부 당사자가 외부 커밋을 통해 참여할 수 있도록 한 경우 구성원의 서명 키를 손상시킨 공격자는 외부 커밋을 사용하여 자신을 그룹에 삽입할 수 있습니다. "재동기화" 스타일의 외부 커밋을 사용하여 그룹에서 손상된 구성원을 교체합니다.

애플리케이션은 사전 공유 키를 사용하여 서명 키 손상 위험을 완화할 수 있습니다. 그룹에서 참여자가 자격 증명으로 인증하는 것 외에도 PSK를 알아야 하는 경우 가장 공격을 실행하기 위해 공격자는 관련 PSK와 피해자의 서명 키를 손상시켜야 합니다. 이러한 완화의 대가는 애플리케이션이 그룹의 적법한 구성원이 필요한 PSK를 갖도록 보장하는 일부 외부 조정을 필요로 한다는 것입니다.

---
### **16.6.  Forward Secrecy and Post-Compromise Security**

순방향 보안 및 사후 손상 보안은 수명이 긴 MLS 그룹의 중요한 보안 개념입니다. 순방향 비밀성은 특정 시점에 전송된 메시지가 나중에 그룹 구성원의 손상에 직면하여 안전함을 의미합니다. 손상 후 보안이란 그룹 구성원이 과거 어느 시점에 손상되었더라도 메시지가 안전함을 의미합니다.

```text
                      Compromise
                          |
                          |
                     |    V    |
   ------------------|---------|------------------------->
                     |         |                     Time
   <-----------------|         |---------------->
     Forward Secrecy |         | Post-Compromise
                     |         |   Security

          Figure 29: Forward Secrecy and Post-Compromise Security
```

래칫 트리에서 리프 키를 정기적으로 업데이트하는 구성원에 의해 에포크 사이에 사후 손상 보안이 제공됩니다. 리프 키를 업데이트하면 그룹 비밀이 이전에 개인 키가 손상된 공개 키로 계속 암호화되는 것을 방지할 수 있습니다. 업데이트 제안을 보내면 다른 구성원이 커밋에 포함할 때까지 PCS가 달성되지 않습니다. 멤버는 섹션 12.4에 설명된 대로 자신의 커밋을 보내고 경로 필드를 채워 즉각적인 PCS를 달성할 수 있습니다. 명확하게 말하면, 이러한 모든 경우에 PCS 보증은 발신자가 커밋을 생성할 때가 아니라 그룹 구성원이 관련 커밋을 처리할 때 적용됩니다.

래칫 트리의 이전 버전에서 개인 키를 삭제하여 에포크 간의 순방향 보안을 제공합니다. 이렇게 하면 이전 그룹 비밀이 다시 파생되는 것을 방지할 수 있습니다. 메시지를 암호화하거나 해독하는 데 사용된 메시지 암호화 키를 삭제하여 한 시대 내에서 순방향 보안이 제공됩니다. 그룹 비밀 및 메시지 암호화 키는 그룹에서 공유됩니다. 따라서 구성원이 이러한 키를 삭제하지 않는 한 비밀 유지에 대한 위험이 있습니다. 이는 구성원이 오랫동안 오프라인 상태인 경우 특히 위험합니다. 애플리케이션에는 너무 오랫동안 오프라인 상태인\(즉, 일정 기간 내에 키를 변경하지 않은\) 그룹 구성원을 퇴거시키는 메커니즘이 있어야 합니다\(SHOULD\).\(SHOULD\)

또한 새 그룹은 해당 개인 키가 손상된 이전 KeyPackage를 통해 구성원이 새 그룹에 추가된 경우 이전에 손상된 키\(손상 후 보안과 마찬가지로\)를 사용할 위험이 있습니다. 이 위험은 클라이언트가 정기적으로 새 KeyPackage를 생성하고 이를 배달 서비스에 업로드하도록 하여 완화할 수 있습니다. 이렇게 하면 새 그룹에 구성원을 추가하는 데 사용되는 키 자료가 더 신선하고 손상될 가능성이 적습니다.

---
### **16.7.  Uniqueness of Ratchet Tree Key Pairs**

래칫 트리 노드의 encryption\_key 및 signature\_key 필드에 저장된 암호화 및 서명 키는 서로 구별되어야 합니다. 예를 들어 두 구성원의 리프 노드에 동일한 서명 키가 있는 경우 그룹 내 서명이 제공하는 데이터 원본 인증 속성이 저하됩니다.\(MUST\)

추가 제안, 업데이트 제안 또는 Commit의 경로 필드에서 트리에 추가될 때 각 리프 노드를 명시적으로 확인하여 리프 노드의 키 고유성을 보장합니다. 자세한 내용은 섹션 7.3, 12.2 및 12.4.2에서 확인할 수 있습니다. 부모 노드에서 암호화 키의 고유성은 UpdatePath의 키가 트리의 다른 곳에서 발견되지 않는지 확인하여 보장됩니다\(섹션 12.4.2 참조\).

---
### **16.8.  KeyPackage Reuse**

KeyPackage는 한 번만 사용하도록 되어 있습니다. 즉, KeyPackage가 해당 클라이언트를 그룹에 도입하는 데 사용되면 KeyPackage 게시 시스템에서 삭제해야 합니다. KeyPackage를 재사용하면 재생 공격이 발생할 수 있습니다.\(SHOULD\)

애플리케이션은 서비스 거부 공격을 방지하기 위해 "마지막 수단" KeyPackage의 재사용을 허용할 수 있습니다\(MAY\). 클라이언트를 새 그룹에 추가하려면 KeyPackage가 필요하므로 공격자는 사용 가능한 모든 KeyPackage를 소진하여 클라이언트가 새 그룹에 추가되지 않도록 할 수 있습니다. 이러한 서비스 거부 공격을 방지하기 위해 KeyPackage 게시 시스템은 특히 인증되지 않은 경우 KeyPackage 요청 속도를 제한해야 합니다.\(MAY, SHOULD\)

---
### **16.9.  Delivery Service Compromise**

MLS는 DS가 손상된 경우에도 그룹 데이터의 기밀성과 무결성을 보호하도록 설계되었습니다. 그러나 손상된 DS는 여전히 일부 공격을 실행할 수 있습니다. 메시지를 위조할 수는 없지만 선택적으로 메시지를 지연시키거나 제거할 수 있습니다. 경우에 따라 발신자별 생성 카운터의 간격을 감지하여 관찰할 수 있지만 항상 공격과 메시지 손실을 구분할 수는 없습니다. 또한 DS는 그룹 구성원과의 메시지를 영구적으로 차단할 수 있습니다. 이것은 다른 구성원이 항상 감지할 수 있는 것은 아닙니다. 응용 프로그램이 DS를 사용하여 동시 커밋 간의 충돌을 해결하는 경우\(섹션 14 참조\) DS가 적용되는 커밋에 영향을 미칠 수 있으며 멤버가 커밋을 적용하지 못하도록 하는 지점까지 가능합니다.

이러한 기능을 종합하면 잠재적으로 DS가 구성원의 상태를 손상시킨 공격자와 공모하여 공격자를 잠그고 구성원의 리프를 새 것으로 업데이트하는 구성원의 유효한 업데이트 및 커밋 메시지를 억제하여 PCS를 물리칠 수 있습니다. 타협하지 않는 상태. SenderData.generation 값 외에도 MLS는 손실 감지를 애플리케이션에 맡깁니다.

---
### **16.10.  Authentication Service Compromise**

인증 서비스 손상은 배달 서비스 손상보다 훨씬 더 심각합니다. 손상된 AS는 선택한 서명 키와 ID 쌍에 대한 바인딩을 주장할 수 있으므로 지정된 사용자를 가장할 수 있습니다. 이 기능은 AS가 해당 사용자인 것처럼 새 그룹에 가입할 수 있도록 하기에 충분합니다. 애플리케이션 아키텍처에 따라 손상된 AS가 예를 들어 동일한 사용자와 연결된 새 장치인 것처럼 기존 사용자로 그룹에 가입하도록 허용하는 것으로도 충분할 수 있습니다. 응용 프로그램이 CONIKS\[CONIKS\] 또는 키 투명성\[KT\]과 같은 투명성 메커니즘을 사용하는 경우 최종 사용자가 AS에 의한 이러한 종류의 오작동을 감지할 수 있습니다. 예를 들어 서로의 키에 서명함으로써 사용자가 소유한 다양한 클라이언트가 서로를 보증하는 방식을 구성하는 것도 가능합니다.

---
### **16.11.  Additional Policy Enforcement**

DS 및 AS는 추가 보안 속성을 얻기 위해 MLS 작업에 추가 정책을 적용할 수도 있습니다. 예를 들어 MLS를 사용하면 모든 참가자가 그룹 구성원을 추가하거나 제거할 수 있습니다. DS는 특정 구성원만 이러한 작업을 수행하도록 허용하는 정책을 시행할 수 있습니다. MLS는 그룹의 모든 구성원을 인증합니다. DS는 특정 유형의 자격 증명을 가진 클라이언트만 허용되도록 하는 데 도움이 될 수 있습니다. MLS는 서비스 거부에 대한 고유한 보호 기능을 제공하지 않습니다. DS는 이러한 위험을 완화하기 위해 속도 제한을 적용할 수도 있습니다.

---
### **16.12.  Group Fragmentation by Malicious Insiders**

그룹의 악의적인 구성원이 잘못된 UpdatePath를 만들어 그룹을 "분할"할 수 있습니다. UpdatePath는 그룹 래칫 트리의 서로 다른 하위 트리에 대한 일련의 경로 비밀을 암호화한다는 점을 상기하십시오. 이러한 경로 비밀은 섹션 7.4에 설명된 순서대로 파생되어야 하지만 UpdatePath 구문을 사용하면 보낸 사람이 임의의 관련 없는 비밀을 암호화할 수 있습니다. 구문은 또한 주어진 노드에 대한 암호화된 경로 암호가 해당 노드에 대해 제공된 공개 키와 일치한다고 보장하지 않습니다.

이러한 두 유형의 손상으로 인해 그룹의 일부 구성원에 대한 Commit 처리가 실패합니다. 노드의 공개 키가 경로 비밀과 일치하지 않으면 해당 경로 비밀을 해독하는 구성원은 이 불일치를 기반으로 커밋을 거부합니다. 어떤 지점에서 경로 비밀 시퀀스가 ​​올바르지 않으면 해당 지점 이전의 노드를 해독할 수 있는 구성원은 일치하지 않는 노드에 대해 UpdatePath에 있는 것과 다른 공개 키를 계산하므로 커밋도 실패합니다. 응용 프로그램은 실패한 커밋이 보고되는 메커니즘을 제공해야 하므로 오류를 스스로 인식할 수 없는 그룹 구성원이 필요한 경우 그룹을 다시 초기화할 수 있습니다.\(SHOULD\)

그러나 이러한 오류 보고 메커니즘이 있더라도 구성원이 잘못된 커밋으로 인해 그룹에서 잠길 수 있습니다. 잘못된 커밋은 그룹의 특정 구성원만 인식할 수 있으므로 비동기 애플리케이션에서는 커밋에서 오류를 감지할 수 있는 모든 구성원이 오프라인 상태일 수 있습니다. 이러한 경우 Commit은 그룹에서 수락되며 결과 상태는 추가 Commit의 기반으로 사용될 수 있습니다. 영향을 받은 구성원이 다시 온라인 상태가 되면 첫 번째 커밋을 거부하므로 그룹을 따라잡을 수 없습니다. 이러한 구성원은 외부 커밋으로 자신을 다시 추가하거나 그룹을 처음부터 다시 초기화해야 합니다.

애플리케이션은 그룹이 커밋을 승인된 것으로 간주하기 전에 커밋의 성공적인 처리를 승인하도록 그룹의 특정 구성원을 요구함으로써 이러한 위험을 해결할 수 있습니다. Commit이 올바른 형식인지 확인하는 데 필요한 최소 승인 세트는 UpdatePath의 노드당 하나의 구성원, 즉 UpdatePath의 노드에 해당하는 copath 노드에 뿌리를 둔 각 하위 트리의 하나의 승인으로 구성됩니다. MLS는 이러한 확인을 위한 기본 제공 메커니즘을 제공하지 않지만 응용 프로그램 계층에서 추가할 수 있습니다.

---
## **17.  IANA Considerations**

IANA는 다음 레지스트리를 생성했습니다.

```text
   *  MLS Cipher Suites (Section 17.1)

   *  MLS Wire Formats (Section 17.2)

   *  MLS Extension Types (Section 17.3)

   *  MLS Proposal Types (Section 17.4)

   *  MLS Credential Types (Section 17.5)

   *  MLS Signature Labels (Section 17.6)

   *  MLS Public Key Encryption Labels (Section 17.7)

   *  MLS Exporter Labels (Section 17.8)
```

이러한 모든 레지스트리는 "Messaging Layer Security" 그룹 레지스트리 표제 아래에 있으며 사양 필수 정책 \[RFC8126\]을 통해 할당됩니다. MLS 지정 전문가\(DE\)에 대한 추가 정보는 섹션 17.9를 참조하십시오.

---
### **17.1.  MLS Cipher Suites**

암호화 제품군은 프로토콜 버전과 사용해야 하는 암호화 알고리즘 세트의 조합입니다.

암호 그룹 이름은 명명 규칙을 따릅니다.

```text
   CipherSuite MLS_LVL_KEM_AEAD_HASH_SIG = VALUE;
```

여기서 VALUE는 16비트 정수로 표시됩니다.

```text
   uint16 CipherSuite;

             +===========+==================================+
             | Component | Contents                         |
             +===========+==================================+
             | LVL       | The security level (in bits)     |
             +-----------+----------------------------------+
             | KEM       | The KEM algorithm used for HPKE  |
             |           | in ratchet tree operations       |
             +-----------+----------------------------------+
             | AEAD      | The AEAD algorithm used for HPKE |
             |           | and message protection           |
             +-----------+----------------------------------+
             | HASH      | The hash algorithm used for HPKE |
             |           | and the MLS transcript hash      |
             +-----------+----------------------------------+
             | SIG       | The signature algorithm used for |
             |           | message authentication           |
             +-----------+----------------------------------+

                                 Table 5
```

레지스트리의 열은 다음과 같습니다.

\* 값: 암호 그룹의 숫자 값

\* 이름: 암호 그룹의 이름

\* 권장: IETF에서 이 암호화 제품군에 대한 지원을 권장하는지 여부. 유효한 값은 아래 설명된 대로 "Y", "N" 및 "D"입니다. "Recommended" 열의 기본값은 "N"입니다. 권장 항목을 "Y" 또는 "D"로 설정하거나 현재 값이 "Y" 또는 "D"인 항목을 변경하려면 표준 조치\[RFC8126\]가 필요합니다.

- - Y: IETF에서 해당 항목이 RECOMMENDED라는 합의가 있음을 나타냅니다. 이는 관련된 메커니즘이 정의된 목적에 적합하다는 것을 의미할 뿐입니다. 해당 메커니즘의 적용 가능성을 이해하려면 메커니즘에 대한 문서를 주의 깊게 읽어야 합니다. IETF는 적용 가능성이 제한된 메커니즘을 권장할 수 있지만 메커니즘의 제한 사항이나 사용에 필요한 제약 사항을 설명하는 적용 가능성 설명을 제공합니다.\(SHOULD\)

- - N: 항목이 IETF에서 평가되지 않았으며 IETF가 관련 메커니즘의 적합성에 대해 언급하지 않았음을 나타냅니다. 이것은 반드시 메커니즘에 결함이 있음을 의미하는 것이 아니라 합의가 존재하지 않는다는 것을 의미합니다. IETF는 적용 가능성이나 사용 제한이 제한적이라는 이유로 항목을 "N"으로 표시하는 데 동의할 수 있습니다.

- - D: 항목이 권장되지 않으며 사용하지 않아야 하거나 사용해서는 안 됨을 나타냅니다. 이 표시는 취약한 암호화 알고리즘이나 배포 시 상호 운용성 문제를 일으킬 수 있는 메커니즘과 같이 사용할 경우 문제를 일으킬 수 있는 메커니즘을 식별하는 데 사용할 수 있습니다.\(MUST NOT\)

\* 참조: 이 암호 스위트가 정의된 문서

```text
   Initial contents:

   +========+===================================================+=+====+
   | Value  |Name                                               |R|Ref |
   +========+===================================================+=+====+
   | 0x0000 |RESERVED                                           |-|RFC |
   |        |                                                   | |9420|
   +--------+---------------------------------------------------+-+----+
   | 0x0001 |MLS_128_DHKEMX25519_AES128GCM_SHA256_Ed25519       |Y|RFC |
   |        |                                                   | |9420|
   +--------+---------------------------------------------------+-+----+
   | 0x0002 |MLS_128_DHKEMP256_AES128GCM_SHA256_P256            |Y|RFC |
   |        |                                                   | |9420|
   +--------+---------------------------------------------------+-+----+
   | 0x0003 |MLS_128_DHKEMX25519_CHACHA20POLY1305_SHA256_Ed25519|Y|RFC |
   |        |                                                   | |9420|
   +--------+---------------------------------------------------+-+----+
   | 0x0004 |MLS_256_DHKEMX448_AES256GCM_SHA512_Ed448           |Y|RFC |
   |        |                                                   | |9420|
   +--------+---------------------------------------------------+-+----+
   | 0x0005 |MLS_256_DHKEMP521_AES256GCM_SHA512_P521            |Y|RFC |
   |        |                                                   | |9420|
   +--------+---------------------------------------------------+-+----+
   | 0x0006 |MLS_256_DHKEMX448_CHACHA20POLY1305_SHA512_Ed448    |Y|RFC |
   |        |                                                   | |9420|
   +--------+---------------------------------------------------+-+----+
   | 0x0007 |MLS_256_DHKEMP384_AES256GCM_SHA384_P384            |Y|RFC |
   |        |                                                   | |9420|
   +--------+---------------------------------------------------+-+----+
   | 0x0A0A |GREASE                                             |Y|RFC |
   |        |                                                   | |9420|
   +--------+---------------------------------------------------+-+----+
   | 0x1A1A |GREASE                                             |Y|RFC |
   |        |                                                   | |9420|
   +--------+---------------------------------------------------+-+----+
   | 0x2A2A |GREASE                                             |Y|RFC |
   |        |                                                   | |9420|
   +--------+---------------------------------------------------+-+----+
   | 0x3A3A |GREASE                                             |Y|RFC |
   |        |                                                   | |9420|
   +--------+---------------------------------------------------+-+----+
   | 0x4A4A |GREASE                                             |Y|RFC |
   |        |                                                   | |9420|
   +--------+---------------------------------------------------+-+----+
   | 0x5A5A |GREASE                                             |Y|RFC |
   |        |                                                   | |9420|
   +--------+---------------------------------------------------+-+----+
   | 0x6A6A |GREASE                                             |Y|RFC |
   |        |                                                   | |9420|
   +--------+---------------------------------------------------+-+----+
   | 0x7A7A |GREASE                                             |Y|RFC |
   |        |                                                   | |9420|
   +--------+---------------------------------------------------+-+----+
   | 0x8A8A |GREASE                                             |Y|RFC |
   |        |                                                   | |9420|
   +--------+---------------------------------------------------+-+----+
   | 0x9A9A |GREASE                                             |Y|RFC |
   |        |                                                   | |9420|
   +--------+---------------------------------------------------+-+----+
   | 0xAAAA |GREASE                                             |Y|RFC |
   |        |                                                   | |9420|
   +--------+---------------------------------------------------+-+----+
   | 0xBABA |GREASE                                             |Y|RFC |
   |        |                                                   | |9420|
   +--------+---------------------------------------------------+-+----+
   | 0xCACA |GREASE                                             |Y|RFC |
   |        |                                                   | |9420|
   +--------+---------------------------------------------------+-+----+
   | 0xDADA |GREASE                                             |Y|RFC |
   |        |                                                   | |9420|
   +--------+---------------------------------------------------+-+----+
   | 0xEAEA |GREASE                                             |Y|RFC |
   |        |                                                   | |9420|
   +--------+---------------------------------------------------+-+----+
   | 0xF000 |Reserved for Private Use                           |-|RFC |
   | -      |                                                   | |9420|
   | 0xFFFF |                                                   | |    |
   +--------+---------------------------------------------------+-+----+

                   Table 6: MLS Extension Types Registry
```

GREASE가 아닌 모든 암호화 제품군은 HMAC \[RFC2104\]를 MAC 기능으로 사용하며 암호화 제품군마다 다른 해시를 사용합니다. HPKE 프리미티브\[RFC9180\], HMAC 해시 함수 및 TLS 서명 체계\[RFC8446\]에 대한 암호 그룹의 매핑은 다음과 같습니다.

```text
    +======+======+========+========+========+========================+
    |Value |KEM   | KDF    | AEAD   | Hash   | Signature              |
    +======+======+========+========+========+========================+
    |0x0001|0x0020| 0x0001 | 0x0001 | SHA256 | ed25519                |
    +------+------+--------+--------+--------+------------------------+
    |0x0002|0x0010| 0x0001 | 0x0001 | SHA256 | ecdsa_secp256r1_sha256 |
    +------+------+--------+--------+--------+------------------------+
    |0x0003|0x0020| 0x0001 | 0x0003 | SHA256 | ed25519                |
    +------+------+--------+--------+--------+------------------------+
    |0x0004|0x0021| 0x0003 | 0x0002 | SHA512 | ed448                  |
    +------+------+--------+--------+--------+------------------------+
    |0x0005|0x0012| 0x0003 | 0x0002 | SHA512 | ecdsa_secp521r1_sha512 |
    +------+------+--------+--------+--------+------------------------+
    |0x0006|0x0021| 0x0003 | 0x0003 | SHA512 | ed448                  |
    +------+------+--------+--------+--------+------------------------+
    |0x0007|0x0011| 0x0002 | 0x0002 | SHA384 | ecdsa_secp384r1_sha384 |
    +------+------+--------+--------+--------+------------------------+

                                  Table 7
```

MLS 성적표 해시에 사용되는 해시는 암호 그룹 이름에서 참조되는 해시입니다. 위에 정의된 암호 그룹에서 "SHA256", "SHA384" 및 "SHA512"는 각각 \[SHS\]에 정의된 SHA-256, SHA-384 및 SHA-512 함수를 나타냅니다.

섹션 13.1의 일반 요구 사항 외에도 향후 암호 제품군은 섹션 16.3의 요구 사항을 충족해야 합니다.\(MUST\)

클라이언트가 페더레이션된 환경에서 상호 운용할 수 있는 가능성을 높이려면 암호화 제품군의 수를 낮게 유지하는 것이 좋습니다. 따라서 암호 제품군에는 현대적이지만 잘 확립된 알고리즘만 포함됩니다. 요구 사항에 따라 클라이언트는 두 가지 보안 수준\(대략 128비트 및 256비트\) 중에서 선택할 수 있습니다. 보안 수준 내에서 클라이언트는 더 빠른 X25519/X448 곡선과 Diffie-Hellman 키 협상을 위해 FIPS 140-2를 준수하는 곡선 중에서 선택할 수 있습니다. 클라이언트는 예를 들어 성능상의 이유로 ChaCha20Poly1305 또는 AES-GCM을 선택할 수도 있습니다. ChaCha20Poly1305는 FIPS 140-2에 나열되지 않았기 때문에 FIPS 140-2를 준수하는 곡선과 쌍을 이루지 않습니다. 대칭 암호화 알고리즘 및 해시 함수의 보안 수준은 곡선의 보안 수준과 쌍을 이룹니다.

MLS 1.0의 필수 구현 암호 제품군은 MLS\_128\_DHKEMX25519\_AES128GCM\_SHA256\_Ed25519로, 키 교환에는 Curve25519, HPKE에는 AES-128-GCM, SHA2-256을 통한 HKDF, 서명에는 Ed25519를 사용합니다. MLS 클라이언트는 이 암호화 제품군을 구현해야 합니다.\(MUST\)

---
### **17.2.  MLS Wire Formats**

"MLS Wire Formats" 레지스트리는 MLS에서 보낼 수 있는 메시지 유형에 대한 식별자를 나열합니다. 연결 형식 필드의 너비는 2바이트이므로 유효한 연결 형식 값은 0x0000에서 0xFFFF 범위에 있습니다.

```text
   Template:
```

\* 값: 와이어 형식의 숫자 값

\* 이름: 와이어 형식의 이름

\* 권장: 17.1절과 동일

\* 참조: 이 와이어 형식이 정의된 문서

```text
   Initial contents:

       +=================+==========================+===+==========+
       | Value           | Name                     | R | Ref      |
       +=================+==========================+===+==========+
       | 0x0000          | RESERVED                 | - | RFC 9420 |
       +-----------------+--------------------------+---+----------+
       | 0x0001          | mls_public_message       | Y | RFC 9420 |
       +-----------------+--------------------------+---+----------+
       | 0x0002          | mls_private_message      | Y | RFC 9420 |
       +-----------------+--------------------------+---+----------+
       | 0x0003          | mls_welcome              | Y | RFC 9420 |
       +-----------------+--------------------------+---+----------+
       | 0x0004          | mls_group_info           | Y | RFC 9420 |
       +-----------------+--------------------------+---+----------+
       | 0x0005          | mls_key_package          | Y | RFC 9420 |
       +-----------------+--------------------------+---+----------+
       | 0xF000 - 0xFFFF | Reserved for Private Use | - | RFC 9420 |
       +-----------------+--------------------------+---+----------+

                     Table 8: MLS Wire Formats Registry
```

---
### **17.3.  MLS Extension Types**

"MLS 확장 유형" 레지스트리는 MLS 프로토콜에 대한 확장에 대한 식별자를 나열합니다. 확장 유형 필드는 2바이트이므로 유효한 확장 유형 값은 0x0000에서 0xFFFF 범위에 있습니다.

```text
   Template:
```

\* 값: 내선 유형의 숫자 ​​값

\* 이름: 확장자 유형의 이름

\* 메시지: 다음 목록에서 가져온 확장 프로그램이 나타날 수 있는 메시지:

```text
      -  KP: KeyPackage objects

      -  LN: LeafNode objects

      -  GC: GroupContext objects

      -  GI: GroupInfo objects
```

\* 권장: 17.1절과 동일

\* 참조: 이 확장이 정의된 문서

```text
   Initial contents:

     +==========+=======================+============+===+==========+
     | Value    | Name                  | Message(s) | R | Ref      |
     +==========+=======================+============+===+==========+
     | 0x0000   | RESERVED              | N/A        | - | RFC 9420 |
     +----------+-----------------------+------------+---+----------+
     | 0x0001   | application_id        | LN         | Y | RFC 9420 |
     +----------+-----------------------+------------+---+----------+
     | 0x0002   | ratchet_tree          | GI         | Y | RFC 9420 |
     +----------+-----------------------+------------+---+----------+
     | 0x0003   | required_capabilities | GC         | Y | RFC 9420 |
     +----------+-----------------------+------------+---+----------+
     | 0x0004   | external_pub          | GI         | Y | RFC 9420 |
     +----------+-----------------------+------------+---+----------+
     | 0x0005   | external_senders      | GC         | Y | RFC 9420 |
     +----------+-----------------------+------------+---+----------+
     | 0x0A0A   | GREASE                | KP, GI, LN | Y | RFC 9420 |
     +----------+-----------------------+------------+---+----------+
     | 0x1A1A   | GREASE                | KP, GI, LN | Y | RFC 9420 |
     +----------+-----------------------+------------+---+----------+
     | 0x2A2A   | GREASE                | KP, GI, LN | Y | RFC 9420 |
     +----------+-----------------------+------------+---+----------+
     | 0x3A3A   | GREASE                | KP, GI, LN | Y | RFC 9420 |
     +----------+-----------------------+------------+---+----------+
     | 0x4A4A   | GREASE                | KP, GI, LN | Y | RFC 9420 |
     +----------+-----------------------+------------+---+----------+
     | 0x5A5A   | GREASE                | KP, GI, LN | Y | RFC 9420 |
     +----------+-----------------------+------------+---+----------+
     | 0x6A6A   | GREASE                | KP, GI, LN | Y | RFC 9420 |
     +----------+-----------------------+------------+---+----------+
     | 0x7A7A   | GREASE                | KP, GI, LN | Y | RFC 9420 |
     +----------+-----------------------+------------+---+----------+
     | 0x8A8A   | GREASE                | KP, GI, LN | Y | RFC 9420 |
     +----------+-----------------------+------------+---+----------+
     | 0x9A9A   | GREASE                | KP, GI, LN | Y | RFC 9420 |
     +----------+-----------------------+------------+---+----------+
     | 0xAAAA   | GREASE                | KP, GI, LN | Y | RFC 9420 |
     +----------+-----------------------+------------+---+----------+
     | 0xBABA   | GREASE                | KP, GI, LN | Y | RFC 9420 |
     +----------+-----------------------+------------+---+----------+
     | 0xCACA   | GREASE                | KP, GI, LN | Y | RFC 9420 |
     +----------+-----------------------+------------+---+----------+
     | 0xDADA   | GREASE                | KP, GI, LN | Y | RFC 9420 |
     +----------+-----------------------+------------+---+----------+
     | 0xEAEA   | GREASE                | KP, GI, LN | Y | RFC 9420 |
     +----------+-----------------------+------------+---+----------+
     | 0xF000 - | Reserved for Private  | N/A        | - | RFC 9420 |
     | 0xFFFF   | Use                   |            |   |          |
     +----------+-----------------------+------------+---+----------+

                  Table 9: MLS Extension Types Registry
```

---
### **17.4.  MLS Proposal Types**

"MLS 제안 유형" 레지스트리는 MLS 그룹 변경에 대해 만들 수 있는 제안 유형에 대한 식별자를 나열합니다. 확장 유형 필드는 2바이트이므로 유효한 확장 유형 값은 0x0000에서 0xFFFF 범위에 있습니다.

```text
   Template:
```

\* 값: 제안 유형의 숫자 ​​값

\* 이름: 제안 유형의 이름

\* 권장: 17.1절과 동일

```text
   *  External: Whether a proposal of this type may be sent by an
      external sender (see Section 12.1.8)

   *  Path Required: Whether a Commit covering a proposal of this type
      is required to have its path field populated (see Section 12.4)
```

\* 참조: 이 확장이 정의된 문서

```text
   Initial contents:

    +==========+==========================+===+=====+======+==========+
    | Value    | Name                     | R | Ext | Path | Ref      |
    +==========+==========================+===+=====+======+==========+
    | 0x0000   | RESERVED                 | - | -   | -    | RFC 9420 |
    +----------+--------------------------+---+-----+------+----------+
    | 0x0001   | add                      | Y | Y   | N    | RFC 9420 |
    +----------+--------------------------+---+-----+------+----------+
    | 0x0002   | update                   | Y | N   | Y    | RFC 9420 |
    +----------+--------------------------+---+-----+------+----------+
    | 0x0003   | remove                   | Y | Y   | Y    | RFC 9420 |
    +----------+--------------------------+---+-----+------+----------+
    | 0x0004   | psk                      | Y | Y   | N    | RFC 9420 |
    +----------+--------------------------+---+-----+------+----------+
    | 0x0005   | reinit                   | Y | Y   | N    | RFC 9420 |
    +----------+--------------------------+---+-----+------+----------+
    | 0x0006   | external_init            | Y | N   | Y    | RFC 9420 |
    +----------+--------------------------+---+-----+------+----------+
    | 0x0007   | group_context_extensions | Y | Y   | Y    | RFC 9420 |
    +----------+--------------------------+---+-----+------+----------+
    | 0x0A0A   | GREASE                   | Y | -   | -    | RFC 9420 |
    +----------+--------------------------+---+-----+------+----------+
    | 0x1A1A   | GREASE                   | Y | -   | -    | RFC 9420 |
    +----------+--------------------------+---+-----+------+----------+
    | 0x2A2A   | GREASE                   | Y | -   | -    | RFC 9420 |
    +----------+--------------------------+---+-----+------+----------+
    | 0x3A3A   | GREASE                   | Y | -   | -    | RFC 9420 |
    +----------+--------------------------+---+-----+------+----------+
    | 0x4A4A   | GREASE                   | Y | -   | -    | RFC 9420 |
    +----------+--------------------------+---+-----+------+----------+
    | 0x5A5A   | GREASE                   | Y | -   | -    | RFC 9420 |
    +----------+--------------------------+---+-----+------+----------+
    | 0x6A6A   | GREASE                   | Y | -   | -    | RFC 9420 |
    +----------+--------------------------+---+-----+------+----------+
    | 0x7A7A   | GREASE                   | Y | -   | -    | RFC 9420 |
    +----------+--------------------------+---+-----+------+----------+
    | 0x8A8A   | GREASE                   | Y | -   | -    | RFC 9420 |
    +----------+--------------------------+---+-----+------+----------+
    | 0x9A9A   | GREASE                   | Y | -   | -    | RFC 9420 |
    +----------+--------------------------+---+-----+------+----------+
    | 0xAAAA   | GREASE                   | Y | -   | -    | RFC 9420 |
    +----------+--------------------------+---+-----+------+----------+
    | 0xBABA   | GREASE                   | Y | -   | -    | RFC 9420 |
    +----------+--------------------------+---+-----+------+----------+
    | 0xCACA   | GREASE                   | Y | -   | -    | RFC 9420 |
    +----------+--------------------------+---+-----+------+----------+
    | 0xDADA   | GREASE                   | Y | -   | -    | RFC 9420 |
    +----------+--------------------------+---+-----+------+----------+
    | 0xEAEA   | GREASE                   | Y | -   | -    | RFC 9420 |
    +----------+--------------------------+---+-----+------+----------+
    | 0xF000 - | Reserved for Private Use | - | -   | -    | RFC 9420 |
    | 0xFFFF   |                          |   |     |      |          |
    +----------+--------------------------+---+-----+------+----------+

                   Table 10: MLS Proposal Types Registry
```

---
### **17.5.  MLS Credential Types**

"MLS 자격 증명 유형" 레지스트리는 MLS 프로토콜에서 인증에 사용할 수 있는 자격 증명 유형에 대한 식별자를 나열합니다. 자격 증명 유형 필드의 너비는 2바이트이므로 유효한 자격 증명 유형 값의 범위는 0x0000에서 0xFFFF까지입니다.

```text
   Template:
```

\* 값: 자격 증명 유형의 숫자 ​​값

\* 이름: 자격 증명 유형의 이름

\* 권장: 17.1절과 동일

\* 참조: 이 자격 증명이 정의된 문서

```text
   Initial contents:

       +=================+==========================+===+==========+
       | Value           | Name                     | R | Ref      |
       +=================+==========================+===+==========+
       | 0x0000          | RESERVED                 | - | RFC 9420 |
       +-----------------+--------------------------+---+----------+
       | 0x0001          | basic                    | Y | RFC 9420 |
       +-----------------+--------------------------+---+----------+
       | 0x0002          | x509                     | Y | RFC 9420 |
       +-----------------+--------------------------+---+----------+
       | 0x0A0A          | GREASE                   | Y | RFC 9420 |
       +-----------------+--------------------------+---+----------+
       | 0x1A1A          | GREASE                   | Y | RFC 9420 |
       +-----------------+--------------------------+---+----------+
       | 0x2A2A          | GREASE                   | Y | RFC 9420 |
       +-----------------+--------------------------+---+----------+
       | 0x3A3A          | GREASE                   | Y | RFC 9420 |
       +-----------------+--------------------------+---+----------+
       | 0x4A4A          | GREASE                   | Y | RFC 9420 |
       +-----------------+--------------------------+---+----------+
       | 0x5A5A          | GREASE                   | Y | RFC 9420 |
       +-----------------+--------------------------+---+----------+
       | 0x6A6A          | GREASE                   | Y | RFC 9420 |
       +-----------------+--------------------------+---+----------+
       | 0x7A7A          | GREASE                   | Y | RFC 9420 |
       +-----------------+--------------------------+---+----------+
       | 0x8A8A          | GREASE                   | Y | RFC 9420 |
       +-----------------+--------------------------+---+----------+
       | 0x9A9A          | GREASE                   | Y | RFC 9420 |
       +-----------------+--------------------------+---+----------+
       | 0xAAAA          | GREASE                   | Y | RFC 9420 |
       +-----------------+--------------------------+---+----------+
       | 0xBABA          | GREASE                   | Y | RFC 9420 |
       +-----------------+--------------------------+---+----------+
       | 0xCACA          | GREASE                   | Y | RFC 9420 |
       +-----------------+--------------------------+---+----------+
       | 0xDADA          | GREASE                   | Y | RFC 9420 |
       +-----------------+--------------------------+---+----------+
       | 0xEAEA          | GREASE                   | Y | RFC 9420 |
       +-----------------+--------------------------+---+----------+
       | 0xF000 - 0xFFFF | Reserved for Private Use | - | RFC 9420 |
       +-----------------+--------------------------+---+----------+

                  Table 11: MLS Credential Types Registry
```

---
### **17.6.  MLS Signature Labels**

섹션 5.1.2에 정의된 SignWithLabel 기능은 서로 다른 컨텍스트에서 서명 간의 혼동 위험을 방지합니다. 각 컨텍스트에는 서명에 통합되는 고유한 레이블이 할당됩니다. "MLS 서명 레이블" 레지스트리는 이 문서에 정의된 레이블을 기록하고 확장자가 MLS의 다른 곳에서 사용되는 동일한 서명 키를 사용하여 다른 유형의 서명을 추가하는 경우 추가 레이블을 등록할 수 있도록 합니다.

```text
   Template:
```

\* Label: Label 매개변수로 사용할 문자열

- SignWithLabel

\* 권장: 17.1절과 동일

\* 참조: 이 레이블이 정의된 문서

```text
   Initial contents:

                   +====================+===+==========+
                   | Label              | R | Ref      |
                   +====================+===+==========+
                   | "FramedContentTBS" | Y | RFC 9420 |
                   +--------------------+---+----------+
                   | "LeafNodeTBS"      | Y | RFC 9420 |
                   +--------------------+---+----------+
                   | "KeyPackageTBS"    | Y | RFC 9420 |
                   +--------------------+---+----------+
                   | "GroupInfoTBS"     | Y | RFC 9420 |
                   +--------------------+---+----------+

                       Table 12: MLS Signature Labels
                                  Registry
```

---
### **17.7.  MLS Public Key Encryption Labels**

섹션 5.1.3에 정의된 EncryptWithLabel 기능은 서로 다른 컨텍스트에서 서로 다른 목적으로 생성된 암호문 간의 혼동 위험을 방지합니다. 각 컨텍스트에는 서명에 통합되는 고유한 레이블이 할당됩니다. "MLS 공개 키 암호화 레이블" 레지스트리는 이 문서에 정의된 레이블을 기록하고 확장이 MLS의 다른 곳에서 사용되는 동일한 HPKE 키를 사용하여 다른 유형의 공개 키 암호화를 추가하는 경우 추가 레이블을 등록할 수 있도록 합니다.

```text
   Template:
```

\* Label: Label 매개변수로 사용할 문자열

-EncryptWithLabel

\* 권장: 17.1절과 동일

\* 참조: 이 레이블이 정의된 문서

```text
   Initial contents:

                    +==================+===+==========+
                    | Label            | R | Ref      |
                    +==================+===+==========+
                    | "UpdatePathNode" | Y | RFC 9420 |
                    +------------------+---+----------+
                    | "Welcome"        | Y | RFC 9420 |
                    +------------------+---+----------+

                          Table 13: MLS Public Key
                         Encryption Labels Registry
```

---
### **17.8.  MLS Exporter Labels**

섹션 8.5에 정의된 내보내기 기능을 사용하면 애플리케이션이 MLS 키 일정에서 키 자료를 파생할 수 있습니다. TLS 내보내기 \[RFC8446\]와 마찬가지로 MLS 내보내기는 서로 다른 응용 프로그램의 내보내기 사용을 구별하기 위해 레이블을 사용합니다. "MLS 내보내기 레이블" 레지스트리를 사용하면 응용 프로그램이 충돌을 방지하기 위해 사용을 등록할 수 있습니다.

```text
   Template:
```

\* Label: MLS-Exporter에 Label 매개변수로 사용할 문자열

\* 권장: 17.1절과 동일

\* 참조: 이 레이블이 정의된 문서

레지스트리는 핵심 프로토콜이 아닌 응용 프로그램에서 사용하기 위한 것이므로 초기 내용이 없습니다. 아래 표는 레지스트리의 열 레이아웃만 표시하기 위한 것입니다.

```text
                    +=======+=============+===========+
                    | Label | Recommended | Reference |
                    +=======+=============+===========+
                    | (N/A) | (N/A)       | (N/A)     |
                    +-------+-------------+-----------+

                       Table 14: MLS Exporter Labels
                                  Registry
```

---
### **17.9.  MLS Designated Expert Pool**

사양 필수 \[RFC8126\] 레지스트리 요청은 하나 이상의 MLS DE의 조언에 따라 MLS 지정 전문가\(DE\) 메일링 리스트 <mailto:mls-reg-review@ietf.org\>에서 3주 검토 기간 후에 등록됩니다. . 그러나 게시 전에 값을 할당할 수 있도록 MLS DE는 그러한 사양이 게시될 것이라는 점에 만족하면 등록을 승인할 수 있습니다.

검토를 위해 MLS DE의 메일링 리스트로 보낸 등록 요청은 적절한 제목을 사용해야 합니다\(예: "MLS Bar 레지스트리에 값 등록 요청"\).\(SHOULD\)

검토 기간 내에 MLS DE는 등록 요청을 승인하거나 거부하고 이 결정을 MLS DE의 메일링 리스트 및 IANA에 전달합니다. 거부에는 설명과 해당하는 경우 요청을 성공적으로 수행하는 방법에 대한 제안이 포함되어야 합니다\(SHOULD\). 21일 이상의 기간 동안 결정되지 않은 등록 요청은 <mailto:iesg@ietf.org\> 메일링 리스트를 사용하여 해결을 위해 IESG의 주의를 끌 수 있습니다.\(SHOULD\)

MLS DE가 적용해야 하는 기준에는 제안된 등록이 기존 기능을 복제하는지 여부, 일반적인 적용 가능성 또는 단일 애플리케이션에만 유용한지 여부 및 등록 설명이 명확한지 여부를 결정하는 것이 포함됩니다. 예를 들어 암호 그룹 등록의 경우 MLS DE는 섹션 17.1에 있는 권고를 적용합니다.\(SHOULD\)

IANA는 MLS DE의 레지스트리 업데이트만 수락해야 하며 모든 등록 요청을 MLS DE의 메일링 리스트로 전달해야 합니다\(SHOULD\).\(MUST\)

등록 결정에 대한 폭넓은 정보를 검토할 수 있도록 이 사양을 사용하여 다양한 애플리케이션의 관점을 나타낼 수 있는 여러 MLS DE를 임명하는 것이 좋습니다. 등록 결정이 특정 MLS DE에 대한 이해 상충을 야기하는 것으로 인식될 수 있는 경우 해당 MLS DE는 다른 MLS DE의 판단을 따라야 합니다.\(SHOULD\)

---
### **17.10.  The "message/mls" Media Type**

이 문서는 다른 프로토콜\(예: HTTP \[RFC9113\]\)이 MLS 메시지를 전달할 수 있도록 "message" 레지스트리에 "message/mls" 미디어 유형을 등록합니다.

```text
   Type name:  message

   Subtype name:  mls

   Required parameters:  none

   Optional parameters:  version
```

- version: 문자열 <major\>.<minor\>로 표현되는 MLS 프로토콜 버전. 생략하면 버전은 MLS ProtocolVersion mls10에 해당하는 "1.0"입니다. 어떤 이유로 미디어 유형 매개변수의 버전 번호가 프로토콜에 포함된 ProtocolVersion과 다른 경우 프로토콜이 우선합니다.

인코딩 고려 사항: MLS 메시지는 TLS 표현 언어\[RFC8446\]를 사용하여 표현됩니다. 따라서 MLS 메시지는 이진 데이터로 취급되어야 합니다.

보안 고려 사항: MLS는 임의의 하위 계층 프로토콜을 통해 전송되도록 설계된 암호화된 메시징 계층입니다. 이 문서\(RFC 9420\)의 보안 고려 사항도 적용됩니다.

```text
   Interoperability considerations:  N/A

   Published specification:  RFC 9420
```

이 미디어 유형을 사용하는 애플리케이션: MLS 기반 메시징

- 애플리케이션

```text
   Fragment identifier considerations:  N/A

   Additional information:
```

이 유형의 사용되지 않는 별칭 이름: 해당 없음

- Magic number\(s\): N/A 파일 확장자: N/A Macintosh 파일 유형 코드: N/A

추가 정보를 위해 연락할 사람 및 이메일 주소: IETF MLS Working Group <mailto:mls@ietf.org\>

```text
   Intended usage:  COMMON
```

사용 제한: 해당 없음

```text
   Author:  IETF MLS Working Group

   Change controller:  IETF
```

---
## **18.  References**
---
### **18.1.  Normative References**

```text
   [RFC2104]  Krawczyk, H., Bellare, M., and R. Canetti, "HMAC: Keyed-
              Hashing for Message Authentication", RFC 2104,
              DOI 10.17487/RFC2104, February 1997,
              <https://www.rfc-editor.org/info/rfc2104>.

   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", BCP 14, RFC 2119,
              DOI 10.17487/RFC2119, March 1997,
              <https://www.rfc-editor.org/info/rfc2119>.

   [RFC8126]  Cotton, M., Leiba, B., and T. Narten, "Guidelines for
              Writing an IANA Considerations Section in RFCs", BCP 26,
              RFC 8126, DOI 10.17487/RFC8126, June 2017,
              <https://www.rfc-editor.org/info/rfc8126>.

   [RFC8174]  Leiba, B., "Ambiguity of Uppercase vs Lowercase in RFC
              2119 Key Words", BCP 14, RFC 8174, DOI 10.17487/RFC8174,
              May 2017, <https://www.rfc-editor.org/info/rfc8174>.

   [RFC8446]  Rescorla, E., "The Transport Layer Security (TLS) Protocol
              Version 1.3", RFC 8446, DOI 10.17487/RFC8446, August 2018,
              <https://www.rfc-editor.org/info/rfc8446>.

   [RFC9180]  Barnes, R., Bhargavan, K., Lipp, B., and C. Wood, "Hybrid
              Public Key Encryption", RFC 9180, DOI 10.17487/RFC9180,
              February 2022, <https://www.rfc-editor.org/info/rfc9180>.
```

---
### **18.2.  Informative References**

```text
   [ART]      Cohn-Gordon, K., Cremers, C., Garratt, L., Millican, J.,
              and K. Milner, "On Ends-to-Ends Encryption: Asynchronous
              Group Messaging with Strong Security Guarantees", Version
              2.3, DOI 10.1145/3243734.3243747, March 2020,
              <https://eprint.iacr.org/2017/666.pdf>.

   [CFRG-AEAD-LIMITS]
              Günther, F., Thomson, M., and C. A. Wood, "Usage Limits on
              AEAD Algorithms", Work in Progress, Internet-Draft, draft-
              irtf-cfrg-aead-limits-07, 31 May 2023,
              <https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-
              aead-limits-07>.

   [CLINIC]   Miller, B., Huang, L., Joseph, A., and J. Tygar, "I Know
              Why You Went to the Clinic: Risks and Realization of HTTPS
              Traffic Analysis", Privacy Enhancing Technologies, pp.
              143-163, DOI 10.1007/978-3-319-08506-7_8, 2014,
              <https://doi.org/10.1007/978-3-319-08506-7_8>.

   [CONIKS]   Melara, M. S., Blankstein, A., Bonneau, J., Felten, E. W.,
              and M. J. Freedman, "CONIKS: Bringing Key Transparency to
              End Users", Proceedings of the 24th USENIX Security
              Symposium, ISBN 978-1-939133-11-3, August 2015,
              <https://www.usenix.org/system/files/conference/
              usenixsecurity15/sec15-paper-melara.pdf>.

   [DoubleRatchet]
              Cohn-Gordon, K., Cremers, C., Dowling, B., Garratt, L.,
              and D. Stebila, "A Formal Security Analysis of the Signal
              Messaging Protocol", 2017 IEEE European Symposium on
              Security and Privacy (EuroS&P),
              DOI 10.1109/eurosp.2017.27, April 2017,
              <https://doi.org/10.1109/eurosp.2017.27>.

   [HCJ16]    Husák, M., Čermák, M., Jirsík, T., and P. Čeleda, "HTTPS
              traffic analysis and client identification using passive
              SSL/TLS fingerprinting", EURASIP Journal on Information
              Security, Vol. 2016, Issue 1,
              DOI 10.1186/s13635-016-0030-7, February 2016,
              <https://doi.org/10.1186/s13635-016-0030-7>.

   [KT]       "Key Transparency Design Doc", commit fb0f87f, June 2020,
              <https://github.com/google/keytransparency/blob/master/
              docs/design.md>.

   [MLS-ARCH] Beurdouche, B., Rescorla, E., Omara, E., Inguva, S., and
              A. Duric, "The Messaging Layer Security (MLS)
              Architecture", Work in Progress, Internet-Draft, draft-
              ietf-mls-architecture-10, 16 December 2022,
              <https://datatracker.ietf.org/doc/html/draft-ietf-mls-
              architecture-10>.

   [NAN]      Bellare, M., Ng, R., and B. Tackmann, "Nonces Are Noticed:
              AEAD Revisited", Advances in Cryptology - CRYPTO 2019, pp.
              235-265, DOI 10.1007/978-3-030-26948-7_9, August 2019,
              <https://doi.org/10.1007/978-3-030-26948-7_9>.

   [RFC5116]  McGrew, D., "An Interface and Algorithms for Authenticated
              Encryption", RFC 5116, DOI 10.17487/RFC5116, January 2008,
              <https://www.rfc-editor.org/info/rfc5116>.

   [RFC5905]  Mills, D., Martin, J., Ed., Burbank, J., and W. Kasch,
              "Network Time Protocol Version 4: Protocol and Algorithms
              Specification", RFC 5905, DOI 10.17487/RFC5905, June 2010,
              <https://www.rfc-editor.org/info/rfc5905>.

   [RFC6125]  Saint-Andre, P. and J. Hodges, "Representation and
              Verification of Domain-Based Application Service Identity
              within Internet Public Key Infrastructure Using X.509
              (PKIX) Certificates in the Context of Transport Layer
              Security (TLS)", RFC 6125, DOI 10.17487/RFC6125, March
              2011, <https://www.rfc-editor.org/info/rfc6125>.

   [RFC7696]  Housley, R., "Guidelines for Cryptographic Algorithm
              Agility and Selecting Mandatory-to-Implement Algorithms",
              BCP 201, RFC 7696, DOI 10.17487/RFC7696, November 2015,
              <https://www.rfc-editor.org/info/rfc7696>.

   [RFC8032]  Josefsson, S. and I. Liusvaara, "Edwards-Curve Digital
              Signature Algorithm (EdDSA)", RFC 8032,
              DOI 10.17487/RFC8032, January 2017,
              <https://www.rfc-editor.org/info/rfc8032>.

   [RFC8701]  Benjamin, D., "Applying Generate Random Extensions And
              Sustain Extensibility (GREASE) to TLS Extensibility",
              RFC 8701, DOI 10.17487/RFC8701, January 2020,
              <https://www.rfc-editor.org/info/rfc8701>.

   [RFC9000]  Iyengar, J., Ed. and M. Thomson, Ed., "QUIC: A UDP-Based
              Multiplexed and Secure Transport", RFC 9000,
              DOI 10.17487/RFC9000, May 2021,
              <https://www.rfc-editor.org/info/rfc9000>.

   [RFC9001]  Thomson, M., Ed. and S. Turner, Ed., "Using TLS to Secure
              QUIC", RFC 9001, DOI 10.17487/RFC9001, May 2021,
              <https://www.rfc-editor.org/info/rfc9001>.

   [RFC9113]  Thomson, M., Ed. and C. Benfield, Ed., "HTTP/2", RFC 9113,
              DOI 10.17487/RFC9113, June 2022,
              <https://www.rfc-editor.org/info/rfc9113>.

   [SHS]      National Institute of Standards and Technology (NIST),
              "Secure Hash Standard (SHS)", FIPS PUB 180-4,
              DOI 10.6028/NIST.FIPS.180-4, August 2015,
              <https://doi.org/10.6028/NIST.FIPS.180-4>.

   [Signal]   Perrin(ed), T. and M. Marlinspike, "The Double Ratchet
              Algorithm", Revision 1, November 2016,
              <https://www.signal.org/docs/specifications/
              doubleratchet/>.
```

---
# **Appendix A.  Protocol Origins of Example Trees**

MLS의 프로토콜 작업은 일반적으로 한 번에 전체 직접 경로에 영향을 미치는 특정 형태의 래칫 트리를 생성합니다. 이 섹션에서는 이 문서의 다양한 예제 트리를 생성할 수 있는 프로토콜 작업에 대해 설명합니다.

그림 11의 트리를 구성하려면 다음을 수행하십시오.

\* A는 B, ..., G로 그룹을 만듭니다.

\* F는 X, Y 및 W를 설정하여 빈 커밋을 보냅니다.

\* G는 C와 D를 제거하고 V, U를 비우고 Y와 W를 설정합니다.

\* B는 T와 W를 설정하여 빈 커밋을 보냅니다.

그림 10의 트리를 구성하려면:

\* A는 B, ..., H 및 이 하위 트리 외부의 일부 구성원으로 그룹을 만듭니다.

\* F는 빈 커밋을 보내고 Y와 그 조상을 설정합니다.

\* D는 B와 C를 제거하며 다음과 같은 효과가 있습니다.

- - B와 C의 직접 경로 비우기

- - X, 최상위 노드 및 D의 직접 경로에 있는 추가 노드를 설정합니다.

\* 이 하위 트리 외부의 누군가가 G를 제거하여 G의 직접 경로를 차단합니다.

\* A는 부분 커밋으로 B에 새 멤버를 추가하고 B는 X에서 병합되지 않은 것으로 추가합니다.

그림 13의 트리를 구성하려면 다음을 수행하십시오.

\* A는 B, C, D로 그룹을 만듭니다.

\* B는 X와 Y를 설정하여 전체 커밋을 보냅니다.

\* D는 C를 제거하고 Z와 Y를 설정합니다.

\* B는 전체 커밋으로 C에 새 멤버를 추가합니다.

- - Add 제안은 C를 Z와 Y에서 병합되지 않은 것으로 추가합니다.

- - Commit의 경로는 X와 Y를 재설정하여 Y의 병합되지 않은 잎을 지웁니다.

그림 21의 트리를 구성하려면 다음을 수행하십시오.

\* A는 B, ..., G로 그룹을 만듭니다.

\* A는 전체 Commit에서 F를 제거하고 T, U 및 W를 설정합니다.

\* E는 Y와 W를 설정하여 빈 커밋을 보냅니다.

\* A는 부분 커밋에서 F에 새 멤버를 추가하고 F는 Y와 W에서 병합되지 않은 것으로 추가합니다.

---
# **Appendix B.  Evolution of Parent Hashes**

상위 해시가 유지되는 방식을 더 잘 이해하기 위해 소그룹에서 어떻게 진화하는지 자세히 살펴보겠습니다. 다음 작업 순서를 고려하십시오.

1. A는 새 그룹을 초기화합니다.

2. A는 전체 Commit이 있는 그룹에 B를 추가합니다.

3. B는 전체 Commit이 있는 그룹에 C와 D를 추가합니다.

4. C는 빈 커밋을 보냅니다.

```text
                             Y                   Y'
                             |                   |
                           .-+-.               .-+-.
      ==>         ==>     /     \     ==>     /     \
             X           X'      _=Z         X'      Z'
            / \         / \     / \         / \     / \
   A       A   B       A   B   C   D       A   B   C   D

     Figure 30: Building a Four-Member Tree to Illustrate Parent Hashes
```

그런 다음 노드와 관련된 부모 해시는 다음과 같이 업데이트됩니다\(여기서 부모 해시에는 속기 ph, 트리 해시에는 th, 원래 형제 트리 해시에는 osth를 사용함\).

1. A가 B를 추가: X를 설정

```text
       *  A.parent_hash = ph(X) = H(X, ph="", osth=th(B))
```

2. B는 C, D를 추가합니다: B', X' 및 Y를 설정합니다.

```text
       *  X'.parent_hash = ph(Y) = H(Y, ph="", osth=th(Z)), where th(Z)
          covers (C, _, D)

       *  B'.parent_hash = ph(X') = H(X', ph=X'.parent_hash, osth=th(A))

   3.  C sends empty Commit: set C', Z', Y'

       *  Z'.parent_hash = ph(Y') = H(Y', ph="", osth=th(X')), where
          th(X') covers (A, X', B')

       *  C'.parent_hash = ph(Z') = H(Z', ph=Z'.parent_hash, osth=th(D))
```

새 구성원이 가입하면 다음 부모 해시 값이 있는 트리를 받고 표시된 부모 해시 유효성 관계를 계산합니다.

```text
   +======+======================================+=====================+
   | Node | Parent Hash Value                    | Valid?              |
   +======+======================================+=====================+
   | A    | H(X, ph="", osth=th(B))              | No, B changed       |
   +------+--------------------------------------+---------------------+
   | B'   | H(X', ph=X'.parent_hash, osth=th(A)) | Yes                 |
   +------+--------------------------------------+---------------------+
   | C'   | H(Z', ph=Z'.parent_hash, osth=th(D)) | Yes                 |
   +------+--------------------------------------+---------------------+
   | D    | (none, never sent an UpdatePath)     | N/A                 |
   +------+--------------------------------------+---------------------+
   | X'   | H(Y, ph="", osth=th(Z))              | No, Y and Z         |
   |      |                                      | changed             |
   +------+--------------------------------------+---------------------+
   | Z'   | H(Y', ph="", osth=th(X'))            | Yes                 |
   +------+--------------------------------------+---------------------+

                                  Table 15
```

즉, 조이너는 트리에서 다음과 같은 경로-해시 링크를 찾습니다.

```text
          Y'
          |
          +-.
             \
      X'      Z'
       \     /
    A   B'  C'  D
```

- 그림 31: 상위-해시 링크는 비어 있지 않은 모든 상위 노드를 리프에 연결합니다.

이러한 체인은 트리에서 비어 있지 않은 모든 부모 노드를 집합적으로 포함하므로 트리는 부모-해시 유효합니다.

이 트리는 유효하지만 유효하지 않은 상위-해시 링크를 포함합니다. 예를 들어 클라이언트가 Y'에서 하향식으로 상위 해시를 확인하는 경우 X'에는 Y'에 대한 잘못된 상위 해시가 있지만 Z'에는 유효한 상위 해시가 있음을 발견할 수 있습니다. 마찬가지로 클라이언트가 상향식으로 확인하는 경우 B'의 체인이 X'에서 Y'로의 유효하지 않은 링크로 끝나는 것을 발견할 것입니다. 이러한 유효하지 않은 링크는 여러 클라이언트가 커밋한 자연스러운 결과입니다.

또한 트리 해시와 상위 해시가 상호 작용하는 방식에 유의하십시오. 노드 C'의 부모 해시에는 노드 D의 트리 해시가 포함됩니다. 노드 Z'의 부모 해시에는 노드 A와 B'\(B'의 부모 해시 포함\)를 포함하는 X'의 트리 해시가 포함됩니다. 트리 해시와 상위 해시는 서로 의존하지만 종속 관계는 절대 순환 종속이 없도록 구성됩니다.

새 구성원이 그룹에 대한 트리를 처음 받는 특별한 경우\(예: 래칫 트리 GroupInfo 확장 섹션 12.4.3.3\) 부모 해시는 트리 표현으로 표현되지만 트리 해시는 그럴 필요가 없습니다. 대신 새 구성원은 트리의 모든 노드에 대한 트리 해시를 다시 계산하여 이것이 GroupInfo 개체의 트리 해시와 일치하는지 확인합니다. 트리가 유효한 경우 이러한 방식으로 계산된 하위 트리 해시는 상위 해시 유효성 검사에 필요한 입력과 정렬됩니다\(병합되지 않은 리프를 설명하기 위해 재계산이 필요한 경우 제외\).

---
# **Appendix C.  Array-Based Trees**

완전한 균형 트리를 사용하는 한 가지 이점은 단순한 평면 배열 표현을 허용한다는 것입니다. 이 표현에서 리프 노드는 짝수 노드이며 n번째 리프는 2\*n입니다. 중간 노드는 홀수 노드에 보관됩니다. 예를 들어 잎이 8개인 트리의 구조는 다음과 같습니다.

```text
                              X
                              |
                    .---------+---------.
                   /                     \
                  X                       X
                  |                       |
              .---+---.               .---+---.
             /         \             /         \
            X           X           X           X
           / \         / \         / \         / \
          /   \       /   \       /   \       /   \
         X     X     X     X     X     X     X     X

   Node: 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14

   Leaf: 0     1     2     3     4     5     6     7

          Figure 32: An Eight-Member Tree Represented as an Array
```

이를 통해 메모리에서 복잡한 구조를 유지하지 않고 인덱스를 조작하기만 하면 트리 노드 간의 관계를 계산할 수 있습니다. 기본 규칙은 부모 및 자식 노드 인덱스의 상위 비트가 다음과 같은 관계를 갖는다는 것입니다\(여기서 x는 임의의 비트 문자열임\).

```text
   parent=01x => left=00x, right=10x
```

노드 관계는 암시적이므로 트리의 오른쪽 가장자리에 노드를 추가하고 제거하는 알고리즘은 매우 간단합니다. 배열에 N개의 노드가 있는 경우:

\* 추가: 배열 끝에 N + 1개의 빈 값을 추가합니다.

\* 제거: 배열을 첫 번째\(N-1\)/2 항목으로 자릅니다.

다음 Python 코드는 MLS에 배열 기반 트리를 사용하는 데 필요한 트리 계산을 보여줍니다.

```text
   # The exponent of the largest power of 2 less than x. Equivalent to:
   #   int(math.floor(math.log(x, 2)))
   def log2(x):
       if x == 0:
           return 0

       k = 0
       while (x >> k) > 0:
           k += 1
       return k-1

   # The level of a node in the tree. Leaves are level 0, their parents
   # are level 1, etc. If a node's children are at different levels,
   # then its level is the max level of its children plus one.
   def level(x):
       if x & 0x01 == 0:
           return 0

       k = 0
       while ((x >> k) & 0x01) == 1:
           k += 1
       return k

   # The number of nodes needed to represent a tree with n leaves.
   def node_width(n):
       if n == 0:
           return 0
       else:
           return 2*(n - 1) + 1

   # The index of the root node of a tree with n leaves.
   def root(n):
       w = node_width(n)
       return (1 << log2(w)) - 1

   # The left child of an intermediate node.
   def left(x):
       k = level(x)
       if k == 0:
           raise Exception('leaf node has no children')

       return x ^ (0x01 << (k - 1))

   # The right child of an intermediate node.
   def right(x):
       k = level(x)
       if k == 0:
           raise Exception('leaf node has no children')

       return x ^ (0x03 << (k - 1))

   # The parent of a node.
   def parent(x, n):
       if x == root(n):
           raise Exception('root node has no parent')

       k = level(x)
       b = (x >> (k + 1)) & 0x01
       return (x | (1 << k)) ^ (b << (k + 1))

   # The other child of the node's parent.
   def sibling(x, n):
       p = parent(x, n)
       if x < p:
           return right(p)
       else:
           return left(p)

   # The direct path of a node, ordered from leaf to root.
   def direct_path(x, n):
       r = root(n)
       if x == r:
           return []

       d = []
       while x != r:
           x = parent(x, n)
           d.append(x)
       return d

   # The copath of a node, ordered from leaf to root.
   def copath(x, n):
       if x == root(n):
           return []

       d = direct_path(x, n)
       d.insert(0, x)
       d.pop()
       return [sibling(y, n) for y in d]

   # The common ancestor of two nodes is the lowest node that is in the
   # direct paths of both leaves.
   def common_ancestor_semantic(x, y, n):
       dx = set([x]) | set(direct_path(x, n))
       dy = set([y]) | set(direct_path(y, n))
       dxy = dx & dy
       if len(dxy) == 0:
           raise Exception('failed to find common ancestor')

       return min(dxy, key=level)

   # The common ancestor of two nodes is the lowest node that is in the
   # direct paths of both leaves.
   def common_ancestor_direct(x, y, _):
       # Handle cases where one is an ancestor of the other
       lx, ly = level(x)+1, level(y)+1
       if (lx <= ly) and (x>>ly == y>>ly):
         return y
       elif (ly <= lx) and (x>>lx == y>>lx):
         return x

       # Handle other cases
       xn, yn = x, y
       k = 0
       while xn != yn:
          xn, yn = xn >> 1, yn >> 1
          k += 1
       return (xn << k) + (1 << (k-1)) - 1
```

---
# **Appendix D.  Link-Based Trees**

구현은 래칫 트리를 "링크 기반" 표현으로 저장하도록 선택할 수 있습니다. 여기서 각 노드는 부모 및/또는 자식에 대한 참조를 저장합니다\(위에서 제안한 배열 기반 표현과 달리 이러한 관계는 노드 간의 관계에서 계산됩니다. ' 배열의 인덱스\). 이러한 구현은 새 구성원을 추가하기 위해 트리가 확장되거나 구성원이 제거될 때 잘리므로 트리의 균형 잡힌 구조를 유지하기 위해 이러한 링크를 업데이트해야 합니다.

다음 코드 스니펫은 이러한 알고리즘을 Python에서 구현하는 방법을 보여줍니다.

```text
   class Node:
       def __init__(self, value, left=None, right=None):
           self.value = value    # Value of the node
           self.left = left      # Left child node
           self.right = right    # Right child node

       @staticmethod
       def blank_subtree(depth):
           if depth == 1:
               return Node(None)

           L = Node.blank_subtree(depth-1)
           R = Node.blank_subtree(depth-1)
           return Node(None, left=L, right=R)

       def empty(self):
           L_empty = (self.left == None) or self.left.empty()
           R_empty = (self.right == None) or self.right.empty()
           return (self.value == None) and L_empty and R_empty

   class Tree:
       def __init__(self):
           self.depth = 0    # Depth of the tree
           self.root = None  # Root node of the tree, initially empty

       # Add a blank subtree to the right
       def extend(self):
           if self.depth == 0:
               self.depth = 1
               self.root = Node(None)

           L = self.root
           R = Node.blank_subtree(self.depth)
           self.root = Node(None, left=L, right=R)
           self.depth += 1

       # Truncate the right subtree
       def truncate(self):
           if self.root == None:
               return

           if not self.root.right.empty():
               raise Exception("Cannot truncate non-blank subtree")

           self.depth -= 1
           self.root = self.root.left
```

---
# **Contributors**

```text
   Joel Alwen
   Amazon
   Email: alwenjo@amazon.com

   Karthikeyan Bhargavan
   Inria
   Email: karthikeyan.bhargavan@inria.fr

   Cas Cremers
   CISPA
   Email: cremers@cispa.de

   Alan Duric
   Wire
   Email: alan@wire.com

   Britta Hale
   Naval Postgraduate School
   Email: britta.hale@nps.edu

   Srinivas Inguva
   Email: singuva@yahoo.com

   Konrad Kohbrok
   Phoenix R&D
   Email: konrad.kohbrok@datashrine.de

   Albert Kwon
   MIT
   Email: kwonal@mit.edu

   Tom Leavy
   Amazon
   Email: tomleavy@amazon.com

   Brendan McMillion
   Email: brendanmcmillion@gmail.com

   Marta Mularczyk
   Amazon
   Email: mulmarta@amazon.com

   Eric Rescorla
   Mozilla
   Email: ekr@rtfm.com
```

Michael Rosenberg Trail of Bits 이메일: michael.rosenberg@trailofbits.com

```text
   Théophile Wallez
   Inria
   Email: theophile.wallez@inria.fr
```

Thyla van der Merwe Royal Holloway, University of London 이메일: tjvdmerwe@gmail.com

---
# **Authors' Addresses**

```text
   Richard Barnes
   Cisco
   Email: rlb@ipv.sx

   Benjamin Beurdouche
   Inria & Mozilla
   Email: ietf@beurdouche.com

   Raphael Robert
   Phoenix R&D
   Email: ietf@raphaelrobert.com

   Jon Millican
   Meta Platforms
   Email: jmillican@meta.com

   Emad Omara
   Email: emad.omara@gmail.com
```

Katriel Cohn-Gordon University of Oxford 이메일: me@katriel.co.uk


```text
Network Working Group                Audio-Video Transport Working Group
Request for Comments: 1889                                H. Schulzrinne
Category: Standards Track                                      GMD Fokus
                                                               S. Casner
                                                  Precept Software, Inc.
                                                            R. Frederick
                                         Xerox Palo Alto Research Center
                                                             V. Jacobson
                                   Lawrence Berkeley National Laboratory
                                                            January 1996

          RTP: A Transport Protocol for Real-Time Applications
```

---
# **Status of this Memo**

이 문서는 인터넷 커뮤니티를 위한 인터넷 표준 추적 프로토콜을 지정하고 개선을 위한 토론 및 제안을 요청합니다. 이 프로토콜의 표준화 상태 및 상태에 대해서는 "Internet Official Protocol Standards"\(STD 1\) 최신판을 참조하십시오. 이 메모의 배포는 무제한입니다.

---
# **Abstract**

이 각서는 실시간 전송 프로토콜인 RTP에 대해 설명합니다. RTP는 멀티캐스트 또는 유니캐스트 네트워크 서비스를 통해 오디오, 비디오 또는 시뮬레이션 데이터와 같은 실시간 데이터를 전송하는 애플리케이션에 적합한 종단 간 네트워크 전송 기능을 제공합니다. RTP는 자원 예약을 다루지 않으며 실시간 서비스에 대한 서비스 품질을 보장하지 않습니다. 데이터 전송은 제어 프로토콜\(RTCP\)에 의해 강화되어 대규모 멀티캐스트 네트워크로 확장 가능한 방식으로 데이터 전달을 모니터링하고 최소한의 제어 및 식별 기능을 제공합니다. RTP 및 RTCP는 기본 전송 및 네트워크 계층과 독립적으로 설계되었습니다. 이 프로토콜은 RTP 수준 변환기 및 믹서의 사용을 지원합니다.

---
# **Table of Contents**

```text
   1.         Introduction ........................................    3
   2.         RTP Use Scenarios ...................................    5
   2.1        Simple Multicast Audio Conference ...................    5
   2.2        Audio and Video Conference ..........................    6
   2.3        Mixers and Translators ..............................    6
   3.         Definitions .........................................    7
   4.         Byte Order, Alignment, and Time Format ..............    9
   5.         RTP Data Transfer Protocol ..........................   10
   5.1        RTP Fixed Header Fields .............................   10
   5.2        Multiplexing RTP Sessions ...........................   13
   5.3        Profile-Specific Modifications to the RTP Header.....   14
   5.3.1      RTP Header Extension ................................   14
   6.         RTP Control Protocol -- RTCP ........................   15
   6.1        RTCP Packet Format ..................................   17
   6.2        RTCP Transmission Interval ..........................   19
   6.2.1      Maintaining the number of session members ...........   21
   6.2.2      Allocation of source description bandwidth ..........   21
   6.3        Sender and Receiver Reports .........................   22
   6.3.1      SR: Sender report RTCP packet .......................   23
   6.3.2      RR: Receiver report RTCP packet .....................   28
   6.3.3      Extending the sender and receiver reports ...........   29
   6.3.4      Analyzing sender and receiver reports ...............   29
   6.4        SDES: Source description RTCP packet ................   31
   6.4.1      CNAME: Canonical end-point identifier SDES item .....   32
   6.4.2      NAME: User name SDES item ...........................   34
   6.4.3      EMAIL: Electronic mail address SDES item ............   34
   6.4.4      PHONE: Phone number SDES item .......................   34
   6.4.5      LOC: Geographic user location SDES item .............   35
   6.4.6      TOOL: Application or tool name SDES item ............   35
   6.4.7      NOTE: Notice/status SDES item .......................   35
   6.4.8      PRIV: Private extensions SDES item ..................   36
   6.5        BYE: Goodbye RTCP packet ............................   37
   6.6        APP: Application-defined RTCP packet ................   38
   7.         RTP Translators and Mixers ..........................   39
   7.1        General Description .................................   39
   7.2        RTCP Processing in Translators ......................   41
   7.3        RTCP Processing in Mixers ...........................   43
   7.4        Cascaded Mixers .....................................   44
   8.         SSRC Identifier Allocation and Use ..................   44
   8.1        Probability of Collision ............................   44
   8.2        Collision Resolution and Loop Detection .............   45
   9.         Security ............................................   49
   9.1        Confidentiality .....................................   49
   9.2        Authentication and Message Integrity ................   50
   10.        RTP over Network and Transport Protocols ............   51
   11.        Summary of Protocol Constants .......................   51
   11.1       RTCP packet types ...................................   52
   11.2       SDES types ..........................................   52
   12.        RTP Profiles and Payload Format Specifications ......   53
   A.         Algorithms ..........................................   56
   A.1        RTP Data Header Validity Checks .....................   59
   A.2        RTCP Header Validity Checks .........................   63
   A.3        Determining the Number of RTP Packets Expected and
              Lost ................................................   63
   A.4        Generating SDES RTCP Packets ........................   64
   A.5        Parsing RTCP SDES Packets ...........................   65
   A.6        Generating a Random 32-bit Identifier ...............   66
   A.7        Computing the RTCP Transmission Interval ............   68
   A.8        Estimating the Interarrival Jitter ..................   71
   B.         Security Considerations .............................   72
   C.         Addresses of Authors ................................   72
   D.         Bibliography ........................................   73
```

---
## **1.  Introduction**

이 각서는 대화형 오디오 및 비디오와 같은 실시간 특성을 가진 데이터에 대한 엔드투엔드 전달 서비스를 제공하는 실시간 전송 프로토콜\(RTP\)을 지정합니다. 이러한 서비스에는 페이로드 유형 식별, 시퀀스 번호 지정, 타임스탬프 및 배달 모니터링이 포함됩니다. 애플리케이션은 일반적으로 UDP 위에서 RTP를 실행하여 멀티플렉싱 및 체크섬 서비스를 활용합니다. 두 프로토콜 모두 전송 프로토콜 기능의 일부를 제공합니다. 그러나 RTP는 다른 적절한 기본 네트워크 또는 전송 프로토콜과 함께 사용될 수 있습니다\(섹션 10 참조\). RTP는 기본 네트워크에서 제공하는 경우 멀티캐스트 배포를 사용하여 여러 대상으로의 데이터 전송을 지원합니다.

RTP 자체는 적시 전달을 보장하거나 기타 서비스 품질 보장을 제공하는 메커니즘을 제공하지 않지만 이를 위해 하위 계층 서비스에 의존합니다. 이는 전달을 보장하거나 잘못된 전달을 방지하지 않으며, 기본 네트워크가 안정적이고 패킷을 순서대로 전달한다고 가정하지도 않습니다. RTP에 포함된 시퀀스 번호를 사용하면 수신자가 보낸 사람의 패킷 시퀀스를 재구성할 수 있지만, 시퀀스 번호는 패킷을 순서대로 디코딩할 필요 없이 비디오 디코딩 등에서 패킷의 적절한 위치를 결정하는 데 사용될 수도 있습니다.

RTP는 주로 다중 참가자 멀티미디어 회의의 요구 사항을 충족하도록 설계되었지만 특정 응용 프로그램에만 국한되지는 않습니다. 지속적인 데이터 저장, 대화형 분산 시뮬레이션, 활성 배지, 제어 및 측정 애플리케이션에도 RTP를 적용할 수 있습니다.

이 문서는 밀접하게 연결된 두 부분으로 구성된 RTP를 정의합니다.

- o 실시간 속성을 가진 데이터를 전달하기 위한 실시간 전송 프로토콜\(RTP\).

```text
        o the RTP control protocol (RTCP), to monitor the quality of
         service and to convey information about the participants in an
         on-going session. The latter aspect of RTCP may be sufficient
         for "loosely controlled" sessions, i.e., where there is no
         explicit membership control and set-up, but it is not
         necessarily intended to support all of an application's control
         communication requirements.  This functionality may be fully or
         partially subsumed by a separate session control protocol,
```

- 이는 이 문서의 범위를 벗어납니다.

RTP는 Clark과 Tennenhouse가 제안한 애플리케이션 수준 프레이밍 및 통합 계층 처리 원칙을 따르는 새로운 스타일의 프로토콜을 나타냅니다. 즉, RTP는 특정 애플리케이션에 필요한 정보를 제공하기 위해 가변적이며 별도의 계층으로 구현되기보다는 애플리케이션 처리에 통합되는 경우가 많습니다. RTP는 의도적으로 완전하지 않은 프로토콜 프레임워크입니다. 이 문서에서는 RTP가 적합한 모든 애플리케이션에서 공통적으로 사용될 것으로 예상되는 기능을 지정합니다. 프로토콜을 보다 일반적으로 만들거나 구문 분석이 필요한 옵션 메커니즘을 추가하여 추가 기능을 수용할 수 있는 기존 프로토콜과 달리 RTP는 필요에 따라 헤더에 대한 수정 및/또는 추가를 통해 맞춤화되도록 고안되었습니다. 예제는 섹션 5.3과 6.3.3에 나와 있습니다.

따라서 이 문서 외에도 특정 애플리케이션에 대한 RTP의 전체 사양에는 하나 이상의 동반 문서가 필요합니다\(섹션 12 참조\).

- o 페이로드 유형 코드 세트와 페이로드 형식\(예: 미디어 인코딩\)에 대한 매핑을 정의하는 프로필 사양 문서. 프로필은 특정 응용 프로그램 클래스에 특정한 RTP에 대한 확장이나 수정을 정의할 수도 있습니다. 일반적으로 응용 프로그램은 하나의 프로필에서만 작동합니다. 오디오 및 비디오 데이터에 대한 프로필은 동반 RFC TBD에서 찾을 수 있습니다.

- o 오디오 또는 비디오 인코딩과 같은 특정 페이로드가 RTP로 전달되는 방법을 정의하는 페이로드 형식 사양 문서.

구현을 위한 실시간 서비스 및 알고리즘에 대한 논의와 일부 RTP 설계 결정에 대한 배경 논의는 \[2\]에서 확인할 수 있습니다.

```text
   Several RTP applications, both experimental and commercial, have
   already been implemented from draft specifications. These
   applications include audio and video tools along with diagnostic
   tools such as traffic monitors. Users of these tools number in the
   thousands.  However, the current Internet cannot yet support the full
   potential demand for real-time services. High-bandwidth services
   using RTP, such as video, can potentially seriously degrade the
   quality of service of other network services. Thus, implementors
   should take appropriate precautions to limit accidental bandwidth
   usage. Application documentation should clearly outline the
   limitations and possible operational impact of high-bandwidth real-
```

인터넷의 시간 서비스 및 기타 네트워크 서비스.

---
## **2.  RTP Use Scenarios**

다음 섹션에서는 RTP 사용의 몇 가지 측면을 설명합니다. 예제는 RTP의 용도를 제한하지 않고 RTP를 사용하는 애플리케이션의 기본 작동을 설명하기 위해 선택되었습니다. 이 예에서 RTP는 IP 및 UDP 위에 전달되며, Internet-Draftdraft-ietf-avt-profile에 지정된 오디오 및 비디오 프로필에 의해 설정된 규칙을 따릅니다.

---
## **2.1 Simple Multicast Audio Conference**

IETF의 실무 그룹은 음성 통신을 위해 인터넷의 IP 멀티캐스트 서비스를 사용하여 최신 프로토콜 초안을 논의하기 위해 회의를 갖습니다. 일부 할당 메커니즘을 통해 작업 그룹 의장은 멀티캐스트 그룹 주소와 포트 쌍을 얻습니다. 한 포트는 오디오 데이터에 사용되고 다른 포트는 제어\(RTCP\) 패킷에 사용됩니다. 이 주소와 포트 정보는 의도된 참가자에게 배포됩니다. 개인 정보 보호가 필요한 경우 섹션 9.1에 지정된 대로 데이터 및 제어 패킷을 암호화할 수 있으며, 이 경우 암호화 키도 생성 및 배포되어야 합니다. 이러한 할당 및 배포 메커니즘의 정확한 세부 사항은 RTP의 범위를 벗어납니다.

각 회의 참가자가 사용하는 오디오 회의 애플리케이션은 20ms 정도의 작은 단위로 오디오 데이터를 전송합니다. 오디오 데이터의 각 청크 앞에는 RTP 헤더가 옵니다. RTP 헤더와 데이터는 차례로 UDP 패킷에 포함됩니다. RTP 헤더는 각 패킷에 포함된 오디오 인코딩 유형\(예: PCM, ADPCM 또는 LPC\)을 나타냅니다. 예를 들어 낮은 대역폭을 통해 연결된 새 참가자를 수용하기 위해 발신자가 회의 중에 인코딩을 변경할 수 있습니다. 네트워크 정체 표시에 연결하거나 반응합니다.

다른 패킷 네트워크와 마찬가지로 인터넷은 때때로 패킷을 잃어버리거나 재정렬하고 다양한 시간만큼 지연시킵니다. 이러한 손상에 대처하기 위해 RTP 헤더에는 수신기가 소스에서 생성된 타이밍을 재구성할 수 있도록 하는 타이밍 정보와 시퀀스 번호가 포함되어 있으므로 이 예에서는 오디오 청크가 20ms마다 스피커에서 연속적으로 재생됩니다. 이 타이밍 재구성은 회의에서 RTP 패킷의 각 소스에 대해 별도로 수행됩니다. 시퀀스 번호는 수신기에서 손실되는 패킷 수를 추정하는 데 사용될 수도 있습니다.

실무 그룹 구성원은 컨퍼런스 중에 참여하고 나가기 때문에 언제든지 누가 참여하고 있는지, 오디오 데이터를 얼마나 잘 수신하고 있는지 아는 것이 유용합니다. 그 목적을 위해,

회의에 있는 오디오 응용 프로그램의 각 인스턴스는 수신 보고서와 RTCP\(제어\) 포트의 사용자 이름을 주기적으로 멀티캐스트합니다. 수신 보고서는 현재 화자가 얼마나 잘 수신되고 있는지를 나타내며 적응형 인코딩을 제어하는 ​​데 사용될 수 있습니다. 사용자 이름 외에도 제어 대역폭 제한에 따라 기타 식별 정보가 포함될 수도 있습니다. 사이트는 회의에서 나갈 때 RTCP BYE 패킷\(섹션 6.5\)을 보냅니다.

---
## **2.2 Audio and Video Conference**

회의에서 오디오 및 비디오 미디어가 모두 사용되는 경우 별도의 RTP 세션으로 전송됩니다. RTCP 패킷은 두 개의 서로 다른 UDP 포트 쌍 및/또는 멀티캐스트 주소를 사용하여 각 미디어에 대해 전송됩니다. 두 세션에 참여하는 사용자가 세션을 연결할 수 있도록 두 세션에 모두 RTCP 패킷에서 동일한 고유\(정규\) 이름을 사용해야 한다는 점을 제외하면 오디오 세션과 비디오 세션 사이에는 RTP 수준에서 직접적인 결합이 없습니다.

이러한 분리의 한 가지 동기는 컨퍼런스의 일부 참가자가 선택한 경우 하나의 매체만 받을 수 있도록 허용하는 것입니다. 자세한 설명은 섹션 5.2에 나와 있습니다. 분리에도 불구하고 두 세션의 RTCP 패킷에 전달된 타이밍 정보를 사용하여 소스 오디오 및 비디오의 동기화된 재생을 달성할 수 있습니다.

---
## **2.3 Mixers and Translators**

지금까지 우리는 모든 사이트가 동일한 형식의 미디어 데이터를 수신하기를 원한다고 가정했습니다. 그러나 이것이 항상 적절한 것은 아닙니다. 한 영역의 참가자가 고속 네트워크 액세스를 사용하는 대부분의 회의 참가자와 저속 링크를 통해 연결되는 경우를 생각해 보십시오. 모든 사람에게 더 낮은 대역폭, 낮은 품질의 오디오 인코딩을 사용하도록 강요하는 대신 믹서라고 하는 RTP 수준 릴레이를 낮은 대역폭 영역 근처에 배치할 수 있습니다. 이 믹서는 수신 오디오 패킷을 재동기화하여 발신자가 생성한 일정한 20ms 간격을 재구성하고, 이렇게 재구성된 오디오 스트림을 단일 스트림으로 혼합하고, 오디오 인코딩을 낮은 대역폭으로 변환하고, 낮은 대역폭 패킷 스트림을 낮은 대역폭을 통해 전달합니다. 속도 링크. 이러한 패킷은 단일 수신자에게 유니캐스트되거나 여러 수신자에게 다른 주소로 멀티캐스트될 수 있습니다. RTP 헤더에는 수신기에서 올바른 화자 표시가 제공될 수 있도록 혼합기에서 혼합 패킷에 기여한 소스를 식별하는 수단이 포함되어 있습니다.

오디오 컨퍼런스의 의도된 참가자 중 일부는 고대역폭 링크로 연결될 수 있지만 IP 멀티캐스트를 통해 직접 연결되지 않을 수 있습니다. 예를 들어, 그들은 뒤에 있을 수 있습니다.

어떤 IP 패킷도 통과시키지 못하게 하는 애플리케이션 수준 방화벽입니다. 이러한 사이트의 경우 혼합이 필요하지 않을 수 있으며, 이 경우 변환기라고 하는 다른 유형의 RTP 수준 릴레이를 사용할 수 있습니다. 두 개의 변환기가 방화벽 양쪽에 하나씩 설치되어 있으며, 외부 변환기는 보안 연결을 통해 수신된 모든 멀티캐스트 패킷을 방화벽 내부의 변환기로 전달합니다. 방화벽 내부의 변환기는 이를 사이트 내부 네트워크로 제한된 멀티캐스트 그룹에 멀티캐스트 패킷으로 다시 보냅니다.

혼합기와 변환기는 다양한 목적으로 설계될 수 있습니다. 예를 들어 개별 비디오 스트림에서 개별 사람의 이미지 크기를 조정하고 이를 하나의 비디오 스트림으로 합성하여 그룹 장면을 시뮬레이션하는 비디오 믹서가 있습니다. 변환의 다른 예로는 IP/UDP만 사용하는 호스트 그룹을 ST-II만 이해하는 호스트 그룹에 연결하거나 재동기화나 믹싱 없이 개별 소스의 비디오 스트림을 패킷 단위로 인코딩 변환하는 것이 있습니다. 혼합기 및 변환기의 작동에 대한 자세한 내용은 섹션 7에 나와 있습니다.

---
## **3.  Definitions**

RTP 페이로드: RTP가 패킷으로 전송하는 데이터\(예: 오디오 샘플 또는 압축된 비디오 데이터\)입니다. 페이로드 형식과 해석은 이 문서의 범위를 벗어납니다.

RTP 패킷: 고정 RTP 헤더, 비어 있을 수 있는 기여 소스 목록\(아래 참조\) 및 페이로드 데이터로 구성된 데이터 패킷입니다. 일부 기본 프로토콜에서는 정의할 RTP 패킷의 캡슐화가 필요할 수 있습니다. 일반적으로 기본 프로토콜의 한 패킷에는 단일 RTP 패킷이 포함되지만 캡슐화 방법에 따라 허용되는 경우 여러 RTP 패킷이 포함될 수도 있습니다\(섹션 10 참조\).

RTCP 패킷: RTP 데이터 패킷과 유사한 고정 헤더 부분과 RTCP 패킷 유형에 따라 달라지는 구조적 요소로 구성된 제어 패킷입니다. 형식은 섹션 6에 정의되어 있습니다. 일반적으로 여러 RTCP 패킷은 기본 프로토콜의 단일 패킷에 복합 RTCP 패킷으로 함께 전송됩니다. 이는 각 RTCP 패킷의 고정 헤더에 있는 길이 필드에 의해 활성화됩니다.

포트: "주어진 호스트 컴퓨터 내의 여러 대상을 구별하기 위해 전송 프로토콜이 사용하는 추상화입니다. TCP/IP 프로토콜은 작은 양의 정수를 사용하여 포트를 식별합니다." \[3\] OSI 전송 계층에서 사용되는 전송 선택기\(TSEL\)는 포트와 동일합니다. RTP는 세션의 RTP 및 RTCP 패킷을 다중화하는 포트와 같은 일부 메커니즘을 제공하기 위해 하위 계층 프로토콜에 의존합니다.

전송 주소: 전송 수준 끝점을 식별하는 네트워크 주소와 포트의 조합\(예: IP 주소 및 UDP 포트\)입니다. 패킷은 소스 전송 주소에서 대상 전송 주소로 전송됩니다.

RTP 세션: 참가자 집합 간의 연결

- RTP와 통신합니다. 각 참가자에 대해 세션은 특정 대상 전송 주소 쌍\(하나의 네트워크 주소와 RTP 및 RTCP용 포트 쌍\)으로 정의됩니다. 대상 전송 주소 쌍은 IP 멀티캐스트의 경우처럼 모든 참가자에게 공통일 수도 있고, 개별 유니캐스트 네트워크 주소에 공통 포트 쌍을 더한 경우처럼 각 참가자마다 다를 수도 있습니다. 멀티미디어 세션에서 각 매체는 자체 RTCP 패킷과 함께 별도의 RTP 세션으로 전달됩니다. 여러 RTP 세션은 서로 다른 포트 번호 쌍 및/또는 서로 다른 멀티캐스트 주소로 구별됩니다.

동기화 소스\(SSRC\): 네트워크 주소에 종속되지 않도록 RTP 헤더에 전달되는 32비트 숫자 SSRC 식별자로 식별되는 RTP 패킷 스트림의 소스입니다. 동기화 소스의 모든 패킷은 동일한 타이밍 및 시퀀스 번호 공간의 일부를 형성하므로 수신기는 재생을 위해 동기화 소스별로 패킷을 그룹화합니다. 동기화 소스의 예로는 마이크나 카메라 또는 RTP 믹서\(아래 참조\)와 같은 신호 소스에서 파생된 패킷 스트림의 발신자가 포함됩니다. 동기화 소스는 시간이 지남에 따라 오디오 인코딩과 같은 데이터 형식을 변경할 수 있습니다. SSRC 식별자는 특정 RTP 세션 내에서 전역적으로 고유하도록 무작위로 선택된 값입니다\(섹션 8 참조\). 참가자는 멀티미디어 세션의 모든 RTP 세션에 대해 동일한 SSRC 식별자를 사용할 필요가 없습니다. SSRC 식별자의 바인딩은 RTCP를 통해 제공됩니다\(섹션 6.4.1 참조\). 참가자가 하나의 RTP 세션에서 여러 스트림을 생성하는 경우\(예: 별도의 비디오 카메라에서\) 각 스트림은 서로 다른 SSRC로 식별되어야 합니다.

기여 소스\(CSRC\): RTP 믹서에 의해 생성된 결합 스트림에 기여한 RTP 패킷 스트림의 소스입니다\(아래 참조\). 믹서는 특정 패킷 생성에 기여한 소스의 SSRC 식별자 목록을 해당 패킷의 RTP 헤더에 삽입합니다. 이 목록을 CSRC 목록이라고 합니다. 예제 응용 프로그램은 믹서가 발신 패킷을 생성하기 위해 음성이 결합된 모든 발화자를 나타내는 오디오 회의입니다. 모든 오디오 패킷에 동일한 SSRC 식별자\(믹서의 식별자\)가 포함되어 있더라도 수신기는 현재 발화자를 나타낼 수 있습니다.

최종 시스템: RTP 패킷으로 전송할 콘텐츠를 생성하거나 수신된 RTP 패킷의 콘텐츠를 소비하는 애플리케이션입니다. 최종 시스템은 특정 RTP 세션에서 하나 이상의 동기화 소스 역할을 할 수 있지만 일반적으로 하나만 가능합니다.

믹서: 하나 이상의 소스로부터 RTP 패킷을 수신하고 데이터 형식을 변경하고 어떤 방식으로든 패킷을 결합한 다음 새 RTP 패킷을 전달하는 중간 시스템입니다. 여러 입력 소스 간의 타이밍은 일반적으로 동기화되지 않으므로 믹서는 스트림 간의 타이밍을 조정하고 결합된 스트림에 대한 자체 타이밍을 생성합니다. 따라서 믹서에서 발생하는 모든 데이터 패킷은 믹서를 동기화 소스로 갖는 것으로 식별됩니다.

변환기: 동기화 소스 식별자를 그대로 유지하면서 RTP 패킷을 전달하는 중간 시스템입니다. 변환기의 예로는 혼합 없이 인코딩을 변환하는 장치, 멀티캐스트에서 유니캐스트로 복제기, 방화벽의 애플리케이션 수준 필터 등이 있습니다.

모니터: 에서 보낸 RTCP 패킷을 수신하는 응용 프로그램입니다.

- RTP 세션 참가자, 특히 수신 보고서는 배포 모니터링, 결함 진단 및 장기 통계를 위한 현재 서비스 품질을 추정합니다. 모니터 기능은 세션에 참여하는 애플리케이션에 내장될 가능성이 높지만, 달리 참여하지 않고 RTP 데이터 패킷을 보내거나 받지 않는 별도의 애플리케이션일 수도 있습니다. 이를 타사 모니터라고 합니다.

비RTP는 사용 가능한 서비스를 제공하기 위해 RTP 외에 필요할 수 있는 프로토콜 및 메커니즘을 의미합니다. 특히 멀티미디어 회의의 경우 회의 제어 응용 프로그램은 암호화를 위한 멀티캐스트 주소와 키를 배포하고, 사용할 암호화 알고리즘을 협상하고, RTP 페이로드 유형 값과 RTP 페이로드 유형 값 사이의 동적 매핑을 정의할 수 있습니다. 사전 정의된 페이로드 유형 값. 간단한 응용 프로그램의 경우 전자 메일이나 회의 데이터베이스를 사용할 수도 있습니다. 그러한 프로토콜과 메커니즘의 사양은 이 문서의 범위를 벗어납니다.

---
## **4.  Byte Order, Alignment, and Time Format**

모든 정수 필드는 네트워크 바이트 순서, 즉 최상위 바이트\(옥텟\)부터 전달됩니다. 이 바이트 순서는 일반적으로 빅엔디안으로 알려져 있습니다. 전송 순서는 \[4\]에서 자세히 설명한다. 달리 명시하지 않는 한, 숫자 상수는 10진수\(기본 10\)로 표시됩니다.

모든 헤더 데이터는 자연 길이에 맞춰 정렬됩니다. 즉, 16비트 필드는 짝수 오프셋에 정렬되고, 32비트 필드는 4로 나눌 수 있는 오프셋에 정렬됩니다. 패딩으로 지정된 옥텟의 값은 0입니다.

벽시계 시간\(절대 시간\)은 NTP\(Network Time Protocol\)의 타임스탬프 형식을 사용하여 표시되며, 이는 1900년 1월 1일 UTC 0시를 기준으로 한 초 단위입니다\[5\]. 전체 해상도 NTP 타임스탬프는 처음 32비트에 정수 부분이 있고 마지막 32비트에 소수 부분이 있는 64비트 부호 없는 고정 소수점 숫자입니다. 보다 간결한 표현이 적합한 일부 필드에서는 중간 32비트만 사용됩니다. 즉, 정수 부분의 하위 16비트와 소수 부분의 상위 16비트입니다. 정수 부분의 상위 16비트는 독립적으로 결정되어야 합니다.

---
## **5.  RTP Data Transfer Protocol**
---
## **5.1 RTP Fixed Header Fields**

- RTP 헤더의 형식은 다음과 같습니다.

```text
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |V=2|P|X|  CC   |M|     PT      |       sequence number         |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                           timestamp                           |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |           synchronization source (SSRC) identifier            |
   +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
   |            contributing source (CSRC) identifiers             |
   |                             ....                              |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

처음 12개의 옥텟은 모든 RTP 패킷에 존재하는 반면 CSRC 식별자 목록은 믹서에 의해 삽입될 때만 존재합니다. 필드의 의미는 다음과 같습니다.

버전\(V\): 2비트

- 이 필드는 RTP 버전을 식별합니다. 이 사양에서 정의한 버전은 2입니다. \(값 1은 RTP의 첫 번째 초안 버전에서 사용되며 값 0은 "vat" 오디오 도구에 처음 구현된 프로토콜에서 사용됩니다.\)

패딩\(P\): 1비트

- 패딩 비트가 설정된 경우 패킷의 끝에는 패킷의 일부가 아닌 하나 이상의 추가 패딩 옥텟이 포함됩니다.

- 페이로드. 패딩의 마지막 옥텟에는 무시해야 하는 패딩 옥텟 수의 개수가 포함됩니다. 고정된 블록 크기를 가진 일부 암호화 알고리즘이나 하위 계층 프로토콜 데이터 단위에서 여러 RTP 패킷을 전달하기 위해 패딩이 필요할 수 있습니다.

확장자\(X\): 1비트

- 확장 비트가 설정된 경우 고정 헤더 뒤에는 섹션 5.3.1에 정의된 형식을 사용하여 정확히 하나의 헤더 확장이 옵니다.

CSRC 카운트\(CC\): 4비트

- CSRC 수에는 고정 헤더 뒤에 오는 CSRC 식별자의 수가 포함됩니다.

마커\(M\): 1비트

- 마커의 해석은 프로필에 의해 정의됩니다. 이는 프레임 경계와 같은 중요한 이벤트를 패킷 스트림에 표시할 수 있도록 하기 위한 것입니다. 프로필은 추가 마커 비트를 정의하거나 페이로드 유형 필드의 비트 수를 변경하여 마커 비트가 없음을 지정할 수 있습니다\(섹션 5.3 참조\).

페이로드 유형\(PT\): 7비트

- 이 필드는 RTP 페이로드의 형식을 식별하고 애플리케이션에 의한 해석을 결정합니다. 프로필은 페이로드 유형 코드와 페이로드 형식의 기본 정적 매핑을 지정합니다. 추가 페이로드 유형 코드는 비RTP 수단을 통해 동적으로 정의될 수 있습니다\(섹션 3 참조\). 오디오 및 비디오에 대한 초기 기본 매핑 세트는 동반 프로필 Internet-Draftdraft-ietf-avt-profile에 지정되며 할당 번호 RFC \[6\]의 향후 버전에서 확장될 수 있습니다. RTP 발신자는 언제든지 단일 RTP 페이로드 유형을 내보냅니다. 이 필드는 별도의 미디어 스트림을 다중화하기 위한 것이 아닙니다\(섹션 5.2 참조\).

시퀀스 번호: 16비트

- 시퀀스 번호는 RTP 데이터 패킷이 전송될 때마다 1씩 증가하며, 수신기에서 패킷 손실을 감지하고 패킷 순서를 복원하는 데 사용될 수 있습니다. 시퀀스 번호의 초기 값은 소스 자체가 암호화되지 않더라도 패킷이 암호화하는 변환기를 통해 흐를 수 있기 때문에 암호화에 대한 알려진 일반 텍스트 공격을 더 어렵게 만들기 위해 무작위\(예측 불가능\)입니다. 예측할 수 없는 숫자를 선택하는 기술은 \[7\]에서 설명합니다.

타임스탬프: 32비트

- 타임스탬프는 RTP 데이터 패킷의 첫 번째 옥텟의 샘플링 순간을 반영합니다. 샘플링 순간을 도출해야 합니다.

- 동기화 및 지터 계산을 허용하기 위해 시간에 따라 단조롭고 선형적으로 증가하는 클록에서\(섹션 6.3.1 참조\) 클럭의 해상도는 원하는 동기화 정확도와 패킷 도착 지터 측정에 충분해야 합니다\(비디오 프레임당 1틱은 일반적으로 충분하지 않습니다\). 클록 주파수는 페이로드로 전달되는 데이터 형식에 따라 달라지며 형식을 정의하는 프로필 또는 페이로드 형식 사양에 정적으로 지정되거나 비RTP 수단을 통해 정의된 페이로드 형식에 대해 동적으로 지정될 수 있습니다. RTP 패킷이 주기적으로 생성되는 경우 시스템 시계를 읽는 것이 아니라 샘플링 시계에서 결정된 명목 샘플링 순간이 사용됩니다. 예를 들어 고정 속도 오디오의 경우 타임스탬프 클럭은 각 샘플링 기간마다 1씩 증가할 수 있습니다. 오디오 응용 프로그램이 입력 장치에서 160 샘플링 기간에 해당하는 블록을 읽는 경우 블록이 패킷으로 전송되는지 또는 무음으로 삭제되는지 여부에 관계없이 해당 블록마다 타임스탬프가 160씩 증가합니다.

타임스탬프의 초기 값은 시퀀스 번호와 마찬가지로 무작위입니다. 여러 개의 연속적인 RTP 패킷이 \(논리적으로\) 동시에 생성되는 경우\(예: 동일한 비디오 프레임에 속하는 경우\) 동일한 타임스탬프를 가질 수 있습니다. 연속적인 RTP 패킷에는 MPEG 보간된 비디오 프레임의 경우처럼 데이터가 샘플링된 순서대로 전송되지 않는 경우 단조롭지 않은 타임스탬프가 포함될 수 있습니다. \(전송된 패킷의 시퀀스 번호는 여전히 단조롭습니다.\)

SSRC: 32비트

- SSRC 필드는 동기화 소스를 식별합니다. 이 식별자는 동일한 RTP 세션 내의 두 동기화 소스가 동일한 SSRC 식별자를 갖지 않도록 무작위로 선택됩니다. 무작위 식별자를 생성하는 알고리즘의 예는 부록 A.6에 나와 있습니다. 여러 소스가 동일한 식별자를 선택할 확률은 낮지만 모든 RTP 구현은 충돌을 감지하고 해결할 준비가 되어 있어야 합니다. 섹션 8에서는 SSRC 식별자의 고유성을 기반으로 충돌을 해결하고 RTP 수준 전달 루프를 감지하는 메커니즘과 함께 충돌 확률을 설명합니다. 소스가 소스 전송 주소를 변경하는 경우 루프 소스로 해석되지 않도록 새 SSRC 식별자도 선택해야 합니다.

CSRC 목록: 0\~15개 항목, 각각 32비트

- CSRC 목록은 이 패킷에 포함된 페이로드에 대한 기여 소스를 식별합니다. 식별자의 수는 CC 필드에 의해 제공됩니다. 기여 소스가 15개를 초과하는 경우 15개만 식별할 수 있습니다. CSRC 식별자는 다음과 같습니다.

- 기여 소스의 SSRC 식별자를 사용하여 믹서에 의해 삽입됩니다. 예를 들어, 오디오 패킷의 경우 패킷을 생성하기 위해 함께 혼합된 모든 소스의 SSRC 식별자가 나열되어 수신기에서 올바른 발화자를 표시할 수 있습니다.

---
## **5.2 Multiplexing RTP Sessions**

효율적인 프로토콜 처리를 위해서는 통합 계층 처리 설계 원칙\[1\]에서 설명한 것처럼 다중화 지점의 수를 최소화해야 합니다. RTP에서는 RTP 세션을 정의하는 대상 전송 주소\(네트워크 주소 및 포트 번호\)에 의해 다중화가 제공됩니다. 예를 들어, 별도로 인코딩된 오디오 및 비디오 미디어로 구성된 원격 회의에서 각 미디어는 자체 대상 전송 주소를 사용하여 별도의 RTP 세션에서 전달되어야 합니다. 오디오 및 비디오가 단일 RTP 세션으로 전달되고 페이로드 유형 또는 SSRC 필드를 기반으로 역다중화되는 것은 아닙니다. 페이로드 유형은 다르지만 동일한 SSRC를 사용하여 패킷을 인터리브하면 몇 가지 문제가 발생합니다.

- 1. 세션 중에 하나의 페이로드 유형이 전환된 경우 이전 값 중 어떤 값이 새 값으로 대체되었는지 식별할 수 있는 일반적인 방법이 없습니다.

- 2. SSRC는 단일 타이밍 및 시퀀스 번호 공간을 식별하기 위해 정의됩니다. 여러 페이로드 유형을 인터리빙하려면 미디어 클럭 속도가 다른 경우 다른 타이밍 공간이 필요하며 어떤 페이로드 유형이 패킷 손실을 겪었는지 알려면 다른 시퀀스 번호 공간이 필요합니다.

- 3. RTCP 발신자 및 수신자 보고서\(섹션 6.3 참조\)는 SSRC당 하나의 타이밍 및 시퀀스 번호 공간만 설명할 수 있으며 페이로드 유형 필드를 전달하지 않습니다.

- 4. RTP 믹서는 호환되지 않는 미디어의 인터리빙된 스트림을 하나의 스트림으로 결합할 수 없습니다.

- 5. 하나의 RTP 세션에서 여러 미디어를 전달하는 것은 다음을 배제합니다: 적절한 경우 다른 네트워크 경로 또는 네트워크 리소스 할당의 사용; 원하는 경우 미디어의 하위 집합 수신\(예: 비디오가 사용 가능한 대역폭을 초과하는 경우 오디오만 수신\) 다른 미디어에 대해 별도의 프로세스를 사용하는 수신기 구현은 별도의 RTP 세션을 사용하면 단일 또는 다중 프로세스 구현을 허용합니다.

각 매체에 대해 서로 다른 SSRC를 사용하지만 동일한 RTP 세션에서 전송하면 처음 세 가지 문제는 피할 수 있지만 마지막 두 가지 문제는 피할 수 없습니다.

---
## **5.3 Profile-Specific Modifications to the RTP Header**

기존 RTP 데이터 패킷 헤더는 RTP가 지원할 수 있는 모든 애플리케이션 클래스에서 공통적으로 필요한 기능 세트에 대해 완전한 것으로 간주됩니다. 그러나 ALF 설계 원칙에 따라 헤더는 프로필 사양에 정의된 수정 또는 추가를 통해 조정될 수 있으며 동시에 프로필 독립적인 모니터링 및 기록 도구가 작동할 수 있습니다.

- o 마커 비트 및 페이로드 유형 필드는 프로필별 정보를 전달하지만 많은 응용 프로그램에서 필요할 것으로 예상되고 그렇지 않으면 이를 유지하기 위해 다른 32비트 단어를 추가해야 할 수 있으므로 고정 헤더에 할당됩니다. 이러한 필드를 포함하는 옥텟은 예를 들어 더 많거나 더 적은 마커 비트를 사용하여 다양한 요구 사항에 맞게 프로필에 의해 재정의될 수 있습니다. 마커 비트가 있는 경우 프로필 독립적 모니터가 패킷 손실 패턴과 마커 비트 간의 상관 관계를 관찰할 수 있으므로 옥텟의 최상위 비트에 위치해야 합니다.

- o 비디오 인코딩과 같은 특정 페이로드 형식에 필요한 추가 정보는 패킷의 페이로드 섹션에 포함되어야 합니다. 이는 페이로드 섹션의 시작 부분에 항상 존재하는 헤더에 있거나 데이터 패턴에서 예약된 값으로 표시될 수 있습니다.

- o 특정 애플리케이션 클래스에 페이로드 형식과 관계없이 추가 기능이 필요한 경우 해당 애플리케이션이 작동하는 프로필은 기존 고정 헤더의 SSRC 필드 바로 뒤에 추가 고정 필드를 정의해야 합니다. 이러한 애플리케이션은 추가 필드에 신속하고 직접적으로 액세스할 수 있는 반면 프로필 독립적인 모니터나 레코더는 처음 12옥텟만 해석하여 RTP 패킷을 계속 처리할 수 있습니다.

모든 프로필에 공통적으로 추가 기능이 필요한 것으로 밝혀지면 고정 헤더를 영구적으로 변경하기 위해 새 버전의 RTP를 정의해야 합니다.

---
### **5.3.1 RTP Header Extension**

RTP 데이터 패킷 헤더에 추가 정보를 전달해야 하는 새로운 페이로드 형식 독립적 기능을 개별 구현에서 실험할 수 있도록 확장 메커니즘이 제공됩니다. 이 메커니즘은 확장되지 않은 다른 상호 운용 구현에서 헤더 확장을 무시할 수 있도록 설계되었습니다.

이 헤더 확장은 제한된 용도로만 사용됩니다. 이 메커니즘의 대부분의 잠재적인 용도는 이전 섹션에서 설명한 방법을 사용하여 다른 방법으로 수행하는 것이 더 좋습니다. 예를 들어 고정 헤더에 대한 프로필별 확장은 조건부도 아니고 가변 위치도 아니기 때문에 처리 비용이 저렴합니다. 특정 페이로드 형식에 필요한 추가 정보는 이 헤더 확장을 사용해서는 안 되며 패킷의 페이로드 섹션에 전달되어야 합니다.

```text
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |      defined by profile       |           length              |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                        header extension                       |
   |                             ....                              |
```

RTP 헤더의 X 비트가 1이면 가변 길이 헤더 확장이 CSRC 목록\(있는 경우\) 뒤에 RTP 헤더에 추가됩니다. 헤더 확장에는 4옥텟 확장 헤더를 제외한 확장의 32비트 단어 수를 계산하는 16비트 길이 필드가 포함되어 있습니다\(따라서 0은 유효한 길이입니다\). RTP 데이터 헤더에는 단일 확장자만 추가할 수 있습니다. 여러 상호 운용 구현이 서로 다른 헤더 확장을 독립적으로 실험하도록 허용하거나 특정 구현이 두 가지 이상의 헤더 확장 유형을 실험할 수 있도록 허용하기 위해 헤더 확장의 처음 16비트는 식별자 또는 매개변수를 구별하기 위해 열려 있습니다. 이러한 16비트의 형식은 구현이 작동하는 프로필 사양에 의해 정의됩니다. 이 RTP 사양은 헤더 확장 자체를 정의하지 않습니다.

---
## **6.  RTP Control Protocol -- RTCP**

RTCP\(RTP 제어 프로토콜\)는 데이터 패킷과 동일한 배포 메커니즘을 사용하여 세션의 모든 참가자에게 제어 패킷을 주기적으로 전송하는 것을 기반으로 합니다. 기본 프로토콜은 UDP와 별도의 포트 번호를 사용하는 등 데이터 및 제어 패킷의 다중화를 제공해야 합니다. RTCP는 네 가지 기능을 수행합니다.

- 1. 주요 기능은 데이터 배포 품질에 대한 피드백을 제공하는 것입니다. 이는 전송 프로토콜로서 RTP 역할의 필수적인 부분이며 다른 전송 프로토콜의 흐름 및 혼잡 제어 기능과 관련되어 있습니다. 피드백은 적응형 인코딩 제어에 직접적으로 유용할 수 있지만\[8,9\], IP를 사용한 실험

- 멀티캐스팅은 배포의 결함을 진단하기 위해 수신기로부터 피드백을 받는 것도 중요하다는 것을 보여주었습니다. 모든 참가자에게 수신 피드백 보고서를 보내면 문제를 관찰하는 사람이 해당 문제가 로컬인지 글로벌인지 평가할 수 있습니다. IP 멀티캐스트와 같은 배포 메커니즘을 사용하면 세션에 별도로 참여하지 않는 네트워크 서비스 공급자와 같은 엔터티가 피드백 정보를 수신하고 제3자 모니터 역할을 하여 네트워크 문제를 진단하는 것도 가능합니다. 이 피드백 기능은 아래 섹션 6.3에 설명된 RTCP 발신자 및 수신자 보고서에 의해 수행됩니다.

- 2. RTCP는 표준 이름 또는 CNAME\(섹션 6.4.1\)이라고 하는 RTP 소스에 대한 지속적인 전송 수준 식별자를 전달합니다. 충돌이 발견되거나 프로그램이 다시 시작되면 SSRC 식별자가 변경될 수 있으므로 수신자는 각 참가자를 추적하기 위해 CNAME을 요구합니다. 또한 수신기는 오디오와 비디오를 동기화하기 위해 관련 RTP 세션 세트에서 지정된 참가자의 여러 데이터 스트림을 연결하기 위해 CNAME이 필요합니다.

- 3. 처음 두 기능에서는 모든 참가자가 RTCP 패킷을 보내야 하므로 RTP가 많은 참가자로 확장되도록 속도를 제어해야 합니다. 각 참가자가 자신의 제어 패킷을 다른 모든 참가자에게 보내도록 함으로써 각 참가자는 독립적으로 참가자 수를 관찰할 수 있습니다. 이 숫자는 섹션 6.2에 설명된 대로 패킷이 전송되는 속도를 계산하는 데 사용됩니다.

- 4. 네 번째 선택 기능은 최소한의 세션 제어 정보\(예: 사용자 인터페이스에 표시되는 참가자 식별 정보\)를 전달하는 것입니다. 이는 참가자가 멤버십 제어나 매개변수 협상 없이 들어오고 나가는 "느슨하게 제어되는" 세션에 유용할 가능성이 높습니다. RTCP는 모든 참가자에게 접근할 수 있는 편리한 채널 역할을 하지만 애플리케이션의 모든 제어 통신 요구 사항을 반드시 지원할 것으로 예상되는 것은 아닙니다. 이 문서의 범위를 벗어나는 더 높은 수준의 세션 제어 프로토콜이 필요할 수 있습니다.

기능 1-3은 RTP가 IP 멀티캐스트 환경에서 사용될 때 필수이며 모든 환경에 권장됩니다. RTP 애플리케이션 설계자는 유니캐스트 모드에서만 작동할 수 있고 더 큰 수로 확장할 수 없는 메커니즘을 피하는 것이 좋습니다.

---
## **6.1 RTCP Packet Format**

이 사양은 다양한 제어 정보를 전달하는 여러 RTCP 패킷 유형을 정의합니다.

SR: 활성 발신자인 참가자의 전송 및 수신 통계에 대한 발신자 보고서

RR: 활성 발신자가 아닌 참가자의 수신 통계에 대한 수신자 보고서

```text
   SDES: Source description items, including CNAME
```

BYE: 참여 종료를 나타냅니다.

```text
   APP: Application specific functions
```

각 RTCP 패킷은 RTP 데이터 패킷과 유사한 고정 부분으로 시작하고 패킷 유형에 따라 가변 길이일 수 있지만 항상 32비트 경계에서 끝나는 구조적 요소가 뒤따릅니다. RTCP 패킷을 "스택 가능"하게 만들기 위해 고정 부분의 정렬 요구 사항과 길이 필드가 포함됩니다. 여러 RTCP 패킷은 중간 구분 기호 없이 연결되어 하위 계층 프로토콜\(예: UDP\)의 단일 패킷으로 전송되는 복합 RTCP 패킷을 형성할 수 있습니다. 하위 계층 프로토콜은 복합 패킷의 끝을 결정하기 위해 전체 길이를 제공할 것으로 예상되므로 복합 패킷에 개별 RTCP 패킷의 명시적인 개수는 없습니다.

복합 패킷의 각 개별 RTCP 패킷은 패킷의 순서나 조합에 대한 요구 사항 없이 독립적으로 처리될 수 있습니다. 그러나 프로토콜의 기능을 수행하기 위해서는 다음과 같은 제약이 적용됩니다.

- o 수신 통계\(SR 또는 RR\)는 대역폭 제약이 통계의 해상도를 최대화할 수 있는 만큼 자주 전송되어야 하므로 주기적으로 전송되는 각 복합 RTCP 패킷에는 보고 패킷이 포함되어야 합니다.

- o 새로운 수신자는 소스를 식별하고 립싱크와 같은 목적으로 미디어 연결을 시작하기 위해 가능한 한 빨리 소스에 대한 CNAME을 수신해야 하므로 각 복합 RTCP 패킷에는 SDES CNAME도 포함되어야 합니다.

```text
        o The number of packet types that may appear first in the
         compound packet should be limited to increase the number of
         constant bits in the first word and the probability of
         successfully validating RTCP packets against misaddressed RTP
```

- 데이터 패킷 또는 기타 관련 없는 패킷.

따라서 모든 RTCP 패킷은 최소 두 개의 개별 패킷으로 구성된 복합 패킷으로 전송되어야 하며 다음 형식이 권장됩니다.

암호화 접두어: 복합 패킷이 암호화되는 경우에만 전송된 모든 복합 패킷에 대해 다시 그려진 임의의 32비트 수량으로 접두어가 붙습니다.

SR 또는 RR: 복합 패킷의 첫 번째 RTCP 패킷은 부록 A.2에 설명된 대로 헤더 검증을 용이하게 하기 위해 항상 보고 패킷이어야 합니다. 이는 데이터가 전송되거나 수신되지 않은 경우에도 마찬가지입니다. 이 경우 빈 RR이 전송되고, 복합 패킷의 유일한 다른 RTCP 패킷이 BYE인 경우에도 마찬가지입니다.

추가 RR: 수신 통계가 보고되는 소스 수가 31개\(하나의 SR 또는 RR 패킷에 맞는 수\)를 초과하는 경우 추가 RR 패킷이 초기 보고 패킷 뒤에 와야 합니다.

SDES: CNAME 항목을 포함하는 SDES 패킷은 각 복합 RTCP 패킷에 포함되어야 합니다. 대역폭 제약에 따라 특정 애플리케이션에 필요한 경우 다른 소스 설명 항목이 선택적으로 포함될 수 있습니다\(섹션 6.2.2 참조\).

BYE 또는 APP: 아직 정의되지 않은 유형을 포함하여 다른 RTCP 패킷 유형은 BYE가 지정된 SSRC/CSRC와 함께 전송된 마지막 패킷이어야 한다는 점을 제외하고 어떤 순서로든 따를 수 있습니다. 패킷 유형이 두 번 이상 나타날 수 있습니다.

패킷 오버헤드를 상쇄하기 위해 변환기와 혼합기는 가능할 때마다 전달하는 여러 소스의 개별 RTCP 패킷을 하나의 복합 패킷으로 결합하는 것이 좋습니다\(섹션 7 참조\). 믹서에 의해 생성될 수 있는 RTCP 복합 패킷의 예가 그림 1에 나와 있습니다. 복합 패킷의 전체 길이가 네트워크 경로의 최대 전송 단위\(MTU\)를 초과하는 경우 여러 개의 더 짧은 복합 패킷으로 분할될 수 있습니다. 기본 프로토콜의 별도 패킷으로 전송됩니다. 각 복합 패킷은 SR 또는 RR 패킷으로 시작해야 합니다.

구현에서는 유형을 알 수 없는 들어오는 RTCP 패킷을 무시할 수 있습니다. 추가 RTCP 패킷 유형은 IANA\(Internet Assigned Numbers Authority\)에 등록될 수 있습니다.

---
## **6.2 RTCP Transmission Interval**

```text
   if encrypted: random 32-bit integer
    |
    |[------- packet -------][----------- packet -----------][-packet-]
    |
    |             receiver reports          chunk        chunk
    V                                    item  item     item  item
   --------------------------------------------------------------------
   |R[SR|# sender #site#site][SDES|# CNAME PHONE |#CNAME LOC][BYE##why]
   |R[  |# report #  1 #  2 ][    |#             |#         ][   ##   ]
   |R[  |#        #    #    ][    |#             |#         ][   ##   ]
   |R[  |#        #    #    ][    |#             |#         ][   ##   ]
   --------------------------------------------------------------------
   |<------------------  UDP packet (compound packet) --------------->|

   #: SSRC/CSRC

              Figure 1: Example of an RTCP compound packet
```

RTP는 소수의 참가자부터 수천 명에 이르는 세션 규모에 걸쳐 애플리케이션이 자동으로 확장될 수 있도록 설계되었습니다. 예를 들어 오디오 회의에서는 한 번에 한두 사람만 발언하므로 데이터 트래픽은 본질적으로 자체적으로 제한됩니다. 따라서 멀티캐스트 배포를 사용하면 특정 링크의 데이터 속도가 참가자 수에 관계없이 상대적으로 일정하게 유지됩니다. 그러나 제어 트래픽은 자체적으로 제한되지 않습니다. 각 참가자의 수신 보고서가 일정한 속도로 전송되면 제어 트래픽은 참가자 수에 따라 선형적으로 증가합니다. 따라서 비율을 축소해야 합니다.

각 세션에 대해 데이터 트래픽은 참가자 간에 분배되는 "세션 대역폭"이라는 집합적 제한을 받는다고 가정됩니다. 이 대역폭은 예약되어 네트워크에 의해 제한이 적용되거나 합리적인 공유일 수 있습니다. 세션 대역폭은 세션에 사용 가능한 네트워크 대역폭에 대한 사전 지식이나 일부 비용 또는 사전 지식을 기반으로 선택될 수 있습니다. 이는 미디어 인코딩과 다소 독립적이지만 인코딩 선택은 세션 대역폭에 의해 제한될 수 있습니다. 세션 대역폭 매개 변수는 세션 관리 응용 프로그램이 미디어 응용 프로그램을 호출할 때 제공될 것으로 예상되지만 미디어 응용 프로그램은 세션에 대해 선택된 인코딩에 대한 단일 보낸 사람 데이터 대역폭을 기반으로 기본값을 설정할 수도 있습니다. 또한 애플리케이션은 멀티캐스트 범위 규칙이나 기타 기준에 따라 대역폭 제한을 적용할 수도 있습니다.

제어 및 데이터 트래픽에 대한 대역폭 계산에는 리소스 예약 시스템이 알아야 하는 하위 계층 전송 및 네트워크 프로토콜\(예: UDP 및 IP\)이 포함됩니다. 응용 프로그램은 이러한 프로토콜 중 어떤 프로토콜이 사용 중인지 알 것으로 예상할 수도 있습니다. 패킷이 이동하면서 다른 링크 수준 헤더로 캡슐화되므로 링크 수준 헤더는 계산에 포함되지 않습니다.

제어 트래픽은 세션 대역폭의 알려진 작은 부분으로 제한되어야 합니다. 즉, 데이터를 전달하는 전송 프로토콜의 주요 기능이 손상되지 않도록 작습니다. 자원 예약 프로토콜에 부여된 대역폭 사양에 제어 트래픽이 포함될 수 있도록 하고, 각 참가자가 독립적으로 자신의 점유율을 계산할 수 있도록 알려져 있습니다. RTCP에 할당된 세션 대역폭의 비율을 5%로 고정하는 것이 좋습니다. 간격 계산에서 이 상수와 기타 상수의 값은 중요하지 않지만 세션의 모든 참가자는 동일한 값을 사용해야 동일한 간격이 계산됩니다. 따라서 이러한 상수는 특정 프로필에 대해 고정되어야 합니다.

부록 A.7에 설명된 알고리즘은 위에 설명된 목표를 충족하도록 설계되었습니다. 참가자들에게 허용되는 제어 트래픽 대역폭을 나누기 위해 복합 RTCP 패킷 전송 간격을 계산합니다. 이를 통해 애플리케이션은 예를 들어 모든 참가자의 식별이 중요한 소규모 세션에 대해 빠른 응답을 제공하면서도 대규모 세션에 자동으로 적응할 수 있습니다. 알고리즘에는 다음과 같은 특성이 포함되어 있습니다.

- o 발신자는 제어 트래픽 대역폭의 최소 1/4을 집합적으로 할당하므로 수신자는 많지만 발신자 수가 적은 세션에서 새로 참여하는 참가자는 발신 사이트에 대한 CNAME을 더 빨리 받을 수 있습니다.

- o 참가자 수가 적고 트래픽이 대법칙에 따라 원활하게 처리되지 않을 때 RTCP 패킷 버스트가 허용 대역폭을 초과하는 것을 방지하려면 계산된 RTCP 패킷 간 간격이 최소 5초보다 커야 합니다. 숫자.

- o RTCP 패킷 사이의 간격은 모든 참가자의 의도하지 않은 동기화를 피하기 위해 계산된 간격의 \[0.5,1.5\]배 범위에서 무작위로 변경됩니다\[10\]. 세션에 참가한 후 전송된 첫 번째 RTCP 패킷도 애플리케이션이 여러 사이트에서 동시에 시작되는 경우\(예: 세션 알림에 의해 시작되는 경우\) 최소 RTCP 간격의 절반만큼 무작위로 지연됩니다.

- o 전달되는 제어 정보 양의 변화에 ​​자동으로 적응하기 위해 수신 및 전송된 모든 패킷을 포함하여 평균 복합 RTCP 패킷 크기의 동적 추정이 계산됩니다.

이 알고리즘은 모든 참가자가 전송하도록 허용된 세션에 사용될 수 있습니다. 이 경우 세션 대역폭 매개변수는 개별 발신자의 대역폭과 참가자 수를 곱한 것이며 RTCP 대역폭은 그 5%입니다.

---
### **6.2.1 Maintaining the number of session members**

RTCP 패킷 간격 계산은 세션에 참여하는 사이트 수의 추정치에 따라 달라집니다. 새로운 사이트가 들리면 개수에 추가되고 각 항목에 대한 항목이 SSRC 또는 CSRC 식별자\(섹션 8.2 참조\)로 색인된 테이블에 생성되어 이를 추적합니다. 새 SSRC를 전달하는 여러 패킷이 수신될 때까지 새 항목은 유효한 것으로 간주되지 않을 수 있습니다\(부록 A.1 참조\). 해당 SSRC 식별자가 포함된 RTCP BYE 패킷이 수신되면 테이블에서 항목이 삭제될 수 있습니다.

참가자는 적은 수의 RTCP 보고 간격\(5개 제안\) 동안 RTP 또는 RTCP 패킷이 수신되지 않은 경우 다른 사이트를 비활성으로 표시하거나 아직 유효하지 않은 경우 삭제할 수 있습니다. 이는 패킷 손실에 대해 어느 정도 견고성을 제공합니다. 이 시간 초과가 제대로 작동하려면 모든 사이트에서 RTCP 보고 간격에 대해 대략 동일한 값을 계산해야 합니다.

사이트가 검증되면 나중에 비활성으로 표시되는 경우 해당 사이트의 상태는 계속 유지되어야 하며 해당 사이트는 일반적인 네트워크 파티션에 걸쳐 있을 만큼 충분한 기간 동안 RTCP 대역폭을 공유하는 총 사이트 수에 계속 포함되어야 합니다. . 이는 파티션이 복구될 때 RTCP 보고 간격이 너무 작아 과도한 트래픽을 방지하기 위한 것입니다. 30분의 제한 시간이 권장됩니다. 이는 RTCP 보고 간격이 유용하게 확장될 것으로 예상되는 가장 큰 값\(약 2\~5분\)의 5배보다 여전히 큽니다.

---
### **6.2.2 Allocation of source description bandwidth**

이 사양은 NAME\(개인 이름\) 및 EMAIL\(이메일 주소\)과 같은 필수 CNAME 항목 외에도 여러 소스 설명\(SDES\) 항목을 정의합니다. 또한 새로운 애플리케이션별 RTCP 패킷 유형을 정의하는 수단도 제공합니다. 응용 프로그램은 이 추가 정보에 제어 대역폭을 할당할 때 주의를 기울여야 합니다. 수신 보고서와 CNAME이 전송되는 속도가 느려지고 프로토콜 성능이 저하되기 때문입니다. RTCP의 20% 이하를 권장합니다.

단일 참가자에게 할당된 대역폭은 추가 정보를 전달하는 데 사용됩니다. 또한 모든 SDES 항목이 모든 애플리케이션에 포함되어야 하는 것은 아닙니다. 포함된 항목에는 유틸리티에 따라 대역폭의 일부가 할당되어야 합니다. 이러한 부분을 동적으로 추정하는 대신 백분율을 항목의 일반적인 길이를 기반으로 보고 간격 수로 정적으로 변환하는 것이 좋습니다.

예를 들어, 애플리케이션은 CNAME, NAME 및 EMAIL만 보내고 다른 것은 보내지 않도록 설계될 수 있습니다. NAME은 애플리케이션의 사용자 인터페이스에 지속적으로 표시되는 반면 EMAIL은 요청된 경우에만 표시되므로 EMAIL보다 훨씬 더 높은 우선순위가 부여될 수 있습니다. 모든 RTCP 간격마다 CNAME 항목이 포함된 RR 패킷과 SDES 패킷이 전송됩니다. 최소 간격으로 작동하는 소규모 세션의 경우 평균적으로 5초마다 실행됩니다. 세 번째 간격\(15초\)마다 하나의 추가 항목이 SDES 패킷에 포함됩니다. 8번 중 7번은 NAME 항목이 되고, 8번마다\(2분\) EMAIL 항목이 됩니다.

예를 들어 각 매체에 대한 RTP 세션으로 구성된 멀티미디어 회의에서와 같이 각 참가자에 대한 공통 CNAME을 통한 애플리케이션 간 바인딩을 사용하여 여러 애플리케이션이 동시에 작동하는 경우 추가 SDES 정보가 하나의 RTP 세션에서만 전송될 수 있습니다. 다른 세션은 CNAME 항목만 전달합니다.

---
## **6.3 Sender and Receiver Reports**

RTP 수신자는 수신자가 발신자인지 여부에 따라 두 가지 형식 중 하나를 취할 수 있는 RTCP 보고 패킷을 사용하여 수신 품질 피드백을 제공합니다. 패킷 유형 코드 외에 발신자 보고서\(SR\)와 수신자 보고서\(RR\) 양식의 유일한 차이점은 발신자 보고서에 활성 발신자가 사용할 수 있는 20바이트 발신자 정보 섹션이 포함되어 있다는 것입니다. 사이트가 마지막 보고서나 이전 보고서를 발행한 이후 간격 동안 데이터 패킷을 전송한 경우 SR이 발행되고, 그렇지 않으면 RR이 발행됩니다.

SR 및 RR 형식 모두 0개 이상의 수신 보고 블록을 포함하며, 이는 이 수신기가 마지막 보고 이후 RTP 데이터 패킷을 수신한 각 동기화 소스에 대해 하나씩 포함됩니다. CSRC 목록에 나열된 기여 소스에 대한 보고서는 발행되지 않습니다. 각 수신 보고서 블록은 해당 블록에 표시된 특정 소스로부터 수신된 데이터에 대한 통계를 제공합니다. 최대 31개의 수신 보고 블록이 SR 또는 RR 패킷에 적합하므로 추가 RR 패킷은 필요에 따라 초기 SR 또는 RR 패킷 뒤에 스택되어 마지막 보고 이후 간격 동안 청취된 모든 소스에 대한 수신 보고를 포함할 수 있습니다.

다음 섹션에서는 두 보고서의 형식, 응용 프로그램에 추가 피드백 정보가 필요한 경우 프로필별 방식으로 확장할 수 있는 방법 및 보고서를 사용할 수 있는 방법을 정의합니다. 번역자와 혼합자의 수신 보고에 대한 자세한 내용은 섹션 7에 나와 있습니다.

---
### **6.3.1 SR: Sender report RTCP packet**

```text
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|V=2|P|    RC   |   PT=SR=200   |             length            | header
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                         SSRC of sender                        |
+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
|              NTP timestamp, most significant word             | sender
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ info
|             NTP timestamp, least significant word             |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                         RTP timestamp                         |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                     sender's packet count                     |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                      sender's octet count                     |
+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
|                 SSRC_1 (SSRC of first source)                 | report
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ block
| fraction lost |       cumulative number of packets lost       |   1
-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|           extended highest sequence number received           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                      interarrival jitter                      |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                         last SR (LSR)                         |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                   delay since last SR (DLSR)                  |
+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
|                 SSRC_2 (SSRC of second source)                | report
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ block
:                               ...                             :   2
+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
|                  profile-specific extensions                  |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

보낸 사람 보고서 패킷은 세 개의 섹션으로 구성되며 정의된 경우 네 번째 프로필별 확장 섹션이 뒤따를 수도 있습니다. 첫 번째 섹션인 헤더의 길이는 8옥텟입니다. 필드의 의미는 다음과 같습니다.

버전\(V\): 2비트

- RTP 데이터 패킷과 RTCP 패킷이 동일한 RTP 버전을 식별합니다. 이 사양에서 정의한 버전은 2입니다.

패딩\(P\): 1비트

- 패딩 비트가 설정된 경우 이 RTCP 패킷에는 제어 정보의 일부가 아닌 추가 패딩 옥텟이 끝에 포함됩니다. 패딩의 마지막 옥텟은 무시해야 하는 패딩 옥텟 수를 나타냅니다. 블록 크기가 고정된 일부 암호화 알고리즘에서는 패딩이 필요할 수 있습니다. 복합 RTCP 패킷에서는 복합 패킷이 전체적으로 암호화되므로 마지막 개별 패킷에만 패딩이 필요합니다.

수신 보고 수\(RC\): 5비트

- 이 패킷에 포함된 수신 보고 블록의 수입니다. 0 값이 유효합니다.

패킷 유형\(PT\): 8비트

- 이를 RTCP SR 패킷으로 식별하기 위한 상수 200을 포함합니다.

길이: 16비트

- 헤더와 패딩을 포함하여 32비트 단어에서 1을 뺀 이 RTCP 패킷의 길이입니다. \(1의 오프셋은 0을 유효한 길이로 만들고 복합 RTCP 패킷을 검색할 때 가능한 무한 루프를 방지하는 반면, 32비트 단어를 계산하면 4의 배수에 대한 유효성 검사를 방지합니다.\)

SSRC: 32비트

- 이 SR 패킷의 발신자에 대한 동기화 소스 식별자입니다.

두 번째 섹션인 발신자 정보는 길이가 20옥텟이며 모든 발신자 보고 패킷에 있습니다. 이 발신자의 데이터 전송을 요약합니다. 필드의 의미는 다음과 같습니다.

NTP 타임스탬프: 64비트

- 해당 수신기에 대한 왕복 전파를 측정하기 위해 다른 수신기의 수신 보고서에 반환된 타임스탬프와 함께 사용할 수 있도록 이 보고서가 전송된 벽시계 시간을 나타냅니다. 수신기는 타임스탬프의 측정 정확도가 NTP 타임스탬프의 해상도보다 훨씬 낮은 수준으로 제한될 수 있다는 점을 예상해야 합니다. 타임스탬프의 측정 불확실성은 알려지지 않을 수 있으므로 표시되지 않습니다. 경과 시간을 추적할 수 있지만 벽시계 시간에 대한 개념이 없는 발신자는 가입 이후 경과 시간을 사용할 수 있습니다.

- 대신 세션. 이는 68년 미만으로 가정되므로 상위 비트는 0이 됩니다. 경과된 벽시계 시간을 추정하기 위해 샘플링 시계를 사용하는 것이 허용됩니다. 벽시계나 경과 시간에 대한 개념이 없는 발신자는 NTP 타임스탬프를 0으로 설정할 수 있습니다.

RTP 타임스탬프: 32비트

- NTP 타임스탬프\(위\)와 동일한 시간에 해당하지만 데이터 패킷의 RTP 타임스탬프와 동일한 단위 및 동일한 무작위 오프셋을 갖습니다. 이 대응은 NTP 타임스탬프가 동기화된 소스에 대한 미디어 내 및 미디어 간 동기화에 사용될 수 있으며 미디어 독립적 수신기에서 공칭 RTP 클록 주파수를 추정하는 데 사용될 수 있습니다. 대부분의 경우 이 타임스탬프는 인접한 데이터 패킷의 RTP 타임스탬프와 동일하지 않습니다. 오히려 샘플링 순간에 벽시계 시간을 주기적으로 확인하여 유지되는 RTP 타임스탬프 카운터와 실시간 사이의 관계를 사용하여 해당 NTP 타임스탬프에서 계산됩니다.

발신자의 패킷 수: 32비트

- 전송 시작부터 이 SR 패킷이 생성된 시간까지 보낸 사람이 전송한 총 RTP 데이터 패킷 수입니다. 발신자가 SSRC 식별자를 변경하면 카운트가 재설정됩니다.

발신자의 옥텟 수: 32비트

- 전송 시작부터 이 SR 패킷이 생성된 시간까지 발신자가 RTP 데이터 패킷에 전송한 페이로드 옥텟\(즉, 헤더 또는 패딩을 포함하지 않음\)의 총 개수입니다. 발신자가 SSRC 식별자를 변경하면 카운트가 재설정됩니다. 이 필드는 평균 페이로드 데이터 속도를 추정하는 데 사용할 수 있습니다.

세 번째 섹션에는 마지막 보고 이후 이 발신자가 들은 다른 소스의 수에 따라 0개 이상의 수신 보고 블록이 포함됩니다. 각 수신 보고 블록은 단일 동기화 소스로부터의 RTP 패킷 수신에 대한 통계를 전달합니다. 충돌로 인해 소스가 SSRC 식별자를 변경할 때 수신기는 통계를 전달하지 않습니다. 이러한 통계는 다음과 같습니다.

SSRC\_n\(소스 식별자\): 32비트

- 이 수신 보고 블록의 정보가 속하는 소스의 SSRC 식별자입니다.

손실된 분수: 8비트

- 이전 SR 또는 RR 패킷이 전송된 이후 손실된 소스 SSRC\_n의 RTP 데이터 패킷 비율\(고정 값으로 표시됨\)

- 필드의 왼쪽 가장자리에 이진 포인트가 있는 포인트 번호입니다. \(이는 손실 부분에 256을 곱한 후 정수 부분을 취하는 것과 같습니다.\) 이 부분은 다음 단락에 정의된 대로 손실된 패킷 수를 예상되는 패킷 수로 나눈 값으로 정의됩니다. 구현은 부록 A.3에 나와 있습니다. 중복으로 인해 손실이 음수인 경우 손실된 부분은 0으로 설정됩니다. 수신자는 마지막 패킷 수신 이후 손실된 패킷이 있는지 여부를 알 수 없으며, 마지막 보고 간격 동안 전송된 해당 소스의 모든 패킷이 손실된 경우 소스에 대해 발행된 수신 보고 블록이 없다는 점에 유의하십시오.

손실된 패킷의 누적 수: 24비트

- 수신 시작 이후 손실된 소스 SSRC\_n의 총 RTP 데이터 패킷 수입니다. 이 숫자는 예상되는 패킷 수에서 실제로 수신된 패킷 수를 뺀 값으로 정의됩니다. 여기서 수신된 패킷 수에는 지연되었거나 중복된 패킷이 포함됩니다. 따라서 늦게 도착하는 패킷은 손실된 것으로 간주되지 않으며 중복된 패킷이 있는 경우 손실이 음수가 될 수 있습니다. 예상되는 패킷 수는 다음에 정의된 것처럼 수신된 확장된 마지막 시퀀스 번호에서 수신된 초기 시퀀스 번호를 뺀 값으로 정의됩니다. 이는 부록 A.3에 표시된 대로 계산될 수 있습니다.

수신된 확장된 가장 높은 시퀀스 번호: 32비트

- 하위 16비트는 소스 SSRC\_n에서 RTP 데이터 패킷으로 수신된 가장 높은 시퀀스 번호를 포함하고, 가장 중요한 16비트는 해당 시퀀스 번호 사이클 수로 해당 시퀀스 번호를 확장합니다. 이는 부록 A의 알고리즘에 따라 유지될 수 있습니다. .1. 동일한 세션 내의 서로 다른 수신자는 시작 시간이 크게 다를 경우 시퀀스 번호에 대해 서로 다른 확장을 생성합니다.

도착 간 지터: 32비트

- 타임스탬프 단위로 측정되고 부호 없는 정수로 표현되는 RTP 데이터 패킷 도착 간격 시간의 통계적 변동 추정치입니다. 도착간 지터 J는 한 쌍의 패킷에 대해 송신자와 비교하여 수신자에서의 패킷 간격 차이 D의 평균 편차\(평활화된 절대값\)로 정의됩니다. 아래 방정식에서 볼 수 있듯이 이는 두 패킷의 "상대 전송 시간" 차이와 동일합니다. 상대 전송 시간은 패킷의 RTP 타임스탬프와 도착 시 수신자의 시계 간의 차이이며 동일한 단위로 측정됩니다.

Si가 패킷 i의 RTP 타임스탬프이고 Ri가 패킷 i에 대한 RTP 타임스탬프 단위의 도착 시간인 경우 두 패킷 i와 j에 대해 D는 다음과 같이 표현될 수 있습니다.

```text
                 D(i,j)=(Rj-Ri)-(Sj-Si)=(Rj-Sj)-(Ri-Si)
```

도착 간 지터는 다음 공식에 따라 각 데이터 패킷 i가 소스 SSRC\_n에서 수신될 때 해당 패킷과 이전 패킷 i-1의 차이 D를 도착 순서대로\(반드시 순서대로일 필요는 없음\) 사용하여 연속적으로 계산됩니다.

```text
                    J=J+(|D(i-1,i)|-J)/16
```

수신 보고서가 발행될 때마다 J의 현재 값이 샘플링됩니다.

프로필에 독립적인 모니터가 다양한 구현에서 나오는 보고서를 유효하게 해석할 수 있도록 지터 계산이 여기에 규정되어 있습니다. 이 알고리즘은 최적의 1차 추정기이며 이득 매개변수 1/16은 합리적인 수렴률을 유지하면서 우수한 잡음 감소 비율을 제공합니다\[11\]. 샘플 구현은 부록 A.8에 나와 있습니다.

마지막 SR 타임스탬프\(LSR\): 32비트

- 소스 SSRC\_n에서 가장 최근의 RTCP 발신자 보고\(SR\) 패킷의 일부로 수신된 NTP 타임스탬프\(섹션 4에 설명됨\)의 64비트 중 중간 32비트입니다. 아직 SR이 수신되지 않은 경우 필드는 0으로 설정됩니다.

마지막 SR 이후 지연\(DLSR\): 32비트

- 소스 SSRC\_n에서 마지막 SR 패킷을 수신한 후 이 수신 보고 블록을 보내는 사이의 지연\(1/65536초 단위로 표시\)입니다. SSRC\_n으로부터 아직 SR 패킷이 수신되지 않은 경우 DLSR 필드는 0으로 설정됩니다.

SSRC\_r은 이 수신자 보고서를 발행하는 수신자를 나타냅니다. 소스 SSRC\_n은 이 수신 보고 블록이 수신되는 시간 A를 기록하여 SSRC\_r에 대한 라운드 전파 지연을 계산할 수 있습니다. 마지막 SR 타임스탬프\(LSR\) 필드를 사용하여 총 왕복 시간 A-LSR을 계산한 다음 이 필드를 빼서 왕복 전파 지연을 \(A-LSR - DLSR\)로 유지합니다. 이는 그림 2에 설명되어 있습니다.

일부 링크에는 매우 비대칭적인 지연이 있지만 이는 클러스터 수신기까지의 거리를 대략적으로 측정하는 데 사용될 수 있습니다.

---
### **6.3.2 RR: Receiver report RTCP packet**

```text
   [10 Nov 1995 11:33:25.125]           [10 Nov 1995 11:33:36.5]
   n                 SR(n)              A=b710:8000 (46864.500 s)
   ---------------------------------------------------------------->
                      v                 ^
   ntp_sec =0xb44db705 v               ^ dlsr=0x0005.4000 (    5.250s)
   ntp_frac=0x20000000  v             ^  lsr =0xb705:2000 (46853.125s)
     (3024992016.125 s)  v           ^
   r                      v         ^ RR(n)
   ---------------------------------------------------------------->
                          |<-DLSR->|
                           (5.250 s)

   A     0xb710:8000 (46864.500 s)
   DLSR -0x0005:4000 (    5.250 s)
   LSR  -0xb705:2000 (46853.125 s)
   -------------------------------
   delay 0x   6:2000 (    6.125 s)

           Figure 2: Example for round-trip time computation

 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|V=2|P|    RC   |   PT=RR=201   |             length            | header
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                     SSRC of packet sender                     |
+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
|                 SSRC_1 (SSRC of first source)                 | report
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ block
| fraction lost |       cumulative number of packets lost       |   1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|           extended highest sequence number received           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                      interarrival jitter                      |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                         last SR (LSR)                         |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                   delay since last SR (DLSR)                  |
+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
|                 SSRC_2 (SSRC of second source)                | report
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ block
:                               ...                             :   2
+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
|                  profile-specific extensions                  |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

RR\(Receiver Report\) 패킷의 형식은 패킷 유형 필드에 상수 201이 포함되어 있고 보낸 사람 정보의 5개 단어가 생략된 점을 제외하면 SR 패킷의 형식과 동일합니다\(NTP 및 RTP 타임스탬프와 보낸 사람의 패킷 및 옥텟 수\). 나머지 필드는 SR 패킷과 동일한 의미를 갖습니다.

보고할 데이터 전송 또는 수신이 없는 경우 빈 RR 패킷\(RC = 0\)이 복합 RTCP 패킷의 선두에 배치됩니다.

---
### **6.3.3 Extending the sender and receiver reports**

프로필은 발신자 또는 수신자에 대해 정기적으로 보고해야 하는 추가 정보가 있는 경우 발신자 보고서 및 수신자에 대한 프로필 또는 애플리케이션별 확장을 정의해야 합니다. 이 방법은 오버헤드가 덜 필요하므로 다른 RTCP 패킷 유형을 정의하는 것보다 우선적으로 사용해야 합니다.

```text
        o fewer octets in the packet (no RTCP header or SSRC field);
```

- o 해당 프로필에서 실행되는 응용 프로그램은 수신 보고 후 직접 액세스할 수 있는 위치에서 확장 필드를 항상 예상하도록 프로그래밍되므로 구문 분석이 더 간단하고 빠릅니다.

추가 발신자 정보가 필요한 경우 발신자 보고서 확장에 먼저 포함되어야 하지만 수신자 보고서에는 표시되지 않습니다. 수신자에 대한 정보가 포함되는 경우 해당 데이터는 기존 수신 보고 블록 배열과 평행한 블록 배열로 구성될 수 있습니다. 즉, 블록 수는 RC 필드로 표시됩니다.

---
### **6.3.4 Analyzing sender and receiver reports**

수신 품질 피드백은 송신자뿐만 아니라 다른 수신자 및 타사 모니터에게도 유용할 것으로 예상됩니다. 발신자는 피드백을 기반으로 전송 내용을 수정할 수 있습니다. 수신자는 문제가 지역적인지, 지역적인지 또는 세계적인지 여부를 판단할 수 있습니다. 네트워크 관리자는 RTCP 패킷만 수신하고 해당 RTP 데이터 패킷은 수신하지 않는 프로필 독립적 모니터를 사용하여 멀티캐스트 배포에 대한 네트워크 성능을 평가할 수 있습니다.

누적 개수는 발신자 정보와 수신자 보고서 블록 모두에서 사용되므로 두 보고서 간의 차이를 계산하여 단기 및 장기 기간에 걸쳐 측정을 수행하고 보고서 손실에 대한 복원력을 제공할 수 있습니다. 수신된 마지막 두 보고서의 차이를 사용하여 최근 배포 품질을 추정할 수 있습니다. NTP 타임스탬프는 다음과 같습니다.

두 보고서 간의 간격에 따른 이러한 차이로부터 비율을 계산할 수 있도록 포함되었습니다. 해당 타임스탬프는 데이터 인코딩의 클럭 속도와 무관하므로 인코딩 및 프로필에 독립적인 품질 모니터를 구현하는 것이 가능합니다.

계산 예로는 두 개의 수신 보고서 사이의 간격에 따른 패킷 손실률이 있습니다. 손실된 누적 패킷 수의 차이는 해당 간격 동안 손실된 수를 나타냅니다. 수신된 확장된 마지막 시퀀스 번호의 차이는 해당 간격 동안 예상되는 패킷 수를 제공합니다. 이 둘의 비율은 해당 간격 동안의 패킷 손실 비율입니다. 두 보고서가 연속적인 경우 이 비율은 손실된 부분 필드와 같아야 하지만 그렇지 않은 경우에는 그렇지 않습니다. 초당 손실률은 손실 비율을 초 단위로 표시되는 NTP 타임스탬프의 차이로 나누어 얻을 수 있습니다. 수신된 패킷 수는 예상되는 패킷 수에서 손실된 수를 뺀 값입니다. 예상되는 패킷 수는 손실 추정치의 통계적 타당성을 판단하는 데 사용될 수도 있습니다. 예를 들어 손실된 패킷 5개 중 1개는 1000개 중 200개보다 중요성이 낮습니다.

발신자 정보를 통해 타사 모니터는 데이터를 수신하지 않고도 일정 간격 동안 평균 페이로드 데이터 속도와 평균 패킷 속도를 계산할 수 있습니다. 이 둘의 비율을 취하면 평균 페이로드 크기가 제공됩니다. 패킷 손실이 패킷 크기와 무관하다고 가정할 수 있는 경우 특정 수신기에서 수신한 패킷 수에 평균 페이로드 크기\(또는 해당 패킷 크기\)를 곱하면 해당 수신기에서 사용할 수 있는 명백한 처리량이 제공됩니다.

보고서 간의 차이를 사용하여 장기 패킷 손실 측정을 허용하는 누적 개수 외에도 손실 비율 필드는 단일 보고서에서 단기 측정을 제공합니다. 이는 수신 상태 정보가 모든 수신자에 대해 유지되지 않을 정도로 세션 크기가 확장되거나 특정 수신자로부터 하나의 보고서만 수신될 만큼 보고서 간의 간격이 길어질수록 더욱 중요해집니다.

도착간 지터 필드는 네트워크 정체에 대한 두 번째 단기 측정값을 제공합니다. 패킷 손실은 지속적인 정체를 추적하고, 지터 측정은 일시적인 정체를 추적합니다. 지터 측정은 패킷 손실로 이어지기 전에 정체를 나타낼 수 있습니다. 도착간 지터 필드는 보고 당시의 지터의 스냅샷일 뿐이므로 시간이 지남에 따라 하나의 수신기 또는 단일 네트워크 내에서 여러 수신기로부터의 여러 보고서를 분석해야 할 수도 있습니다.

---
## **6.4 SDES: Source description RTCP packet**

```text
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|V=2|P|    SC   |  PT=SDES=202  |             length            | header
+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
|                          SSRC/CSRC_1                          | chunk
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+   1
|                           SDES items                          |
|                              ...                              |
+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
|                          SSRC/CSRC_2                          | chunk
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+   2
|                           SDES items                          |
|                              ...                              |
+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
```

SDES 패킷은 헤더와 0개 이상의 청크로 구성된 3단계 구조이며, 각 청크는 해당 청크에서 식별된 소스를 설명하는 항목으로 구성됩니다. 항목은 다음 섹션에서 개별적으로 설명됩니다.

버전\(V\), 패딩\(P\), 길이:

- SR 패킷에 대해 설명된 것과 같습니다\(섹션 6.3.1 참조\).

패킷 유형\(PT\): 8비트

- 이를 RTCP SDES 패킷으로 식별하기 위한 상수 202가 포함되어 있습니다.

소스 카운트\(SC\): 5비트

- 이 SDES 패킷에 포함된 SSRC/CSRC 청크 수입니다. 0 값은 유효하지만 쓸모가 없습니다.

각 청크는 SSRC/CSRC 식별자와 SSRC/CSRC에 대한 정보를 전달하는 0개 이상의 항목 목록으로 구성됩니다. 각 청크는 32비트 경계에서 시작됩니다. 각 항목은 8비트 유형 필드, 텍스트 길이를 설명하는 8비트 옥텟 수\(따라서 이 2옥텟 헤더는 포함되지 않음\) 및 텍스트 자체로 구성됩니다. 텍스트는 255옥텟을 초과할 수 없지만 이는 RTCP 대역폭 소비를 제한해야 하는 필요성과 일치합니다.

텍스트는 ISO 표준 10646 \[12,13\]의 Annex F에 지정된 UTF-2 인코딩에 따라 인코딩됩니다. 이 인코딩은 UTF-8 또는 UTF-FSS라고도 합니다. 이는 "파일 시스템 안전 UCS 변환 형식\(FSS\_UTF\)", X/Open 예비 사양, 문서 번호 P316 및 유니코드 기술 보고서 ​​#4에 설명되어 있습니다. US-ASCII는 이 인코딩의 하위 집합이며 추가 인코딩이 필요하지 않습니다. 그만큼

다중 옥텟 인코딩의 존재 여부는 문자의 최상위 비트를 1의 값으로 설정하여 표시됩니다.

항목은 연속적입니다. 즉, 항목이 32비트 경계에 개별적으로 채워지지 않습니다. 일부 다중 옥텟 인코딩에는 널 옥텟이 포함되어 있으므로 텍스트는 널로 끝나지 않습니다. 각 청크의 항목 목록은 하나 이상의 null 옥텟으로 종료됩니다. 첫 번째는 항목 유형 0으로 해석되어 목록의 끝을 나타내고 나머지는 필요에 따라 다음 32비트 경계까지 채워집니다. . 항목이 없는 청크\(4개의 널 옥텟\)는 유효하지만 쓸모가 없습니다.

최종 시스템은 자체 소스 식별자\(고정 RTP 헤더의 SSRC와 동일\)가 포함된 하나의 SDES 패킷을 보냅니다. 믹서는 SDES 정보를 수신하는 각 기여 소스에 대한 청크를 포함하는 하나의 SDES 패킷을 보내거나, 그러한 소스가 31개보다 많은 경우 위 형식의 여러 완전한 SDES 패킷을 보냅니다\(섹션 7 참조\).

현재 정의된 SDES 항목은 다음 섹션에서 설명됩니다. CNAME 항목만 필수입니다. 여기에 표시된 일부 항목은 특정 프로필에만 유용할 수 있지만 항목 유형은 공유 사용을 촉진하고 프로필 독립적인 응용 프로그램을 단순화하기 위해 모두 하나의 공통 공간에서 할당됩니다. IANA에 유형 번호를 등록하여 추가 항목을 프로필에 정의할 수 있습니다.

---
### **6.4.1 CNAME: Canonical end-point identifier SDES item**

```text
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |    CNAME=1    |     length    | user and domain name         ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

CNAME 식별자에는 다음과 같은 속성이 있습니다.

- o 무작위로 할당된 SSRC 식별자는 충돌이 발견되거나 프로그램이 다시 시작되는 경우 변경될 수 있으므로 CNAME 항목은 SSRC 식별자에서 일정하게 유지되는 소스 식별자에 대한 바인딩을 제공해야 합니다.

- o SSRC 식별자와 마찬가지로 CNAME 식별자도 하나의 RTP 세션 내의 모든 참가자 간에 고유해야 합니다.

- o 관련 RTP 세션 세트에서 한 참가자가 사용하는 여러 미디어 도구에 걸쳐 바인딩을 제공하려면 해당 참가자에 대해 CNAME을 수정해야 합니다.

- o 제3자 모니터링을 용이하게 하려면 CNAME은 프로그램이나 사람이 소스를 찾는 데 적합해야 합니다.

따라서 CNAME은 알고리즘에 따라 파생되어야 하며 가능하면 수동으로 입력하면 안 됩니다. 이러한 요구 사항을 충족하려면 프로필이 대체 구문이나 의미를 지정하지 않는 한 다음 형식을 사용해야 합니다. CNAME 항목은 "user@host" 형식이어야 하며, 단일 사용자 시스템에서처럼 사용자 이름을 사용할 수 없는 경우 "host" 형식이어야 합니다. 두 형식 모두에서 "호스트"는 RFC 1034 \[14\], RFC 1035 \[15\] 및 RFC 1123의 섹션 2.1에 지정된 규칙에 따라 형식이 지정된 실시간 데이터가 발생하는 호스트의 정규화된 도메인 이름입니다. \[16\]; 또는 RTP 통신에 사용되는 인터페이스의 호스트 숫자 주소에 대한 표준 ASCII 표현입니다. 예를 들어, IP 버전 4 주소의 표준 ASCII 표현은 점으로 구분된 쿼드라고도 알려진 "점으로 구분된 십진수"입니다. 다른 주소 유형에는 상호 고유한 ASCII 표현이 있어야 합니다. 정규화된 도메인 이름은 인간 관찰자에게 더 편리하며 추가로 NAME 항목을 보낼 필요가 없지만 일부 운영 환경에서는 안정적으로 얻는 것이 어렵거나 불가능할 수 있습니다. 이러한 환경에서 실행될 수 있는 응용 프로그램은 주소의 ASCII 표현을 대신 사용해야 합니다.

예를 들어 다중 사용자 시스템의 경우 "doe@sleepy.megacorp.com" 또는 "doe@192.0.2.89"입니다. 사용자 이름이 없는 시스템의 예는 "sleepy.megacorp.com" 또는 "192.0.2.89"입니다.

사용자 이름은 "finger" 또는 "talk"와 같은 프로그램에서 사용할 수 있는 형식이어야 합니다. 즉, 일반적으로 개인 이름이 아닌 로그인 이름입니다. 호스트 이름은 참가자의 전자 메일 주소와 반드시 동일할 필요는 없습니다.

응용 프로그램이 사용자가 하나의 호스트에서 여러 소스를 생성하도록 허용하는 경우 이 구문은 각 소스에 대한 고유 식별자를 제공하지 않습니다. 이러한 애플리케이션은 소스를 추가로 식별하기 위해 SSRC에 의존해야 하거나 해당 애플리케이션의 프로필이 CNAME 식별자에 대한 추가 구문을 지정해야 합니다.

각 애플리케이션이 CNAME을 독립적으로 생성하는 경우 결과 CNAME은 관련 RTP 세션 집합의 한 참가자에게 속한 여러 미디어 도구에 바인딩을 제공하는 데 필요한 것과 동일하지 않을 수 있습니다. 미디어 간 바인딩이 필요한 경우 각 도구의 CNAME을 조정 도구를 통해 외부에서 동일한 값으로 구성해야 할 수도 있습니다.

애플리케이션 작성자는 RFC 1597\[17\]에서 제안된 Net-10 할당과 같은 개인 네트워크 주소 할당이 전역적으로 고유하지 않은 네트워크 주소를 생성할 수 있다는 점을 알고 있어야 합니다. 이것은

개인 주소가 있고 공용 인터넷에 직접 IP 연결이 없는 호스트가 RTP 수준 변환기를 통해 RTP 패킷을 공용 인터넷으로 전달하는 경우 고유하지 않은 CNAME이 발생합니다. \(RFC 1627 \[18\]도 참조하십시오.\) 이 경우를 처리하기 위해 애플리케이션은 고유한 CNAME을 구성하는 수단을 제공할 수 있지만 개인 주소가 공개되지 않도록 유지하기 위해 필요한 경우 CNAME을 개인 주소에서 공용 주소로 변환하는 부담은 변환기에게 있습니다. 노출된.

---
### **6.4.2 NAME: User name SDES item**

```text
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |     NAME=2    |     length    | common name of source        ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

이는 소스를 설명하는 데 사용되는 실제 이름입니다\(예: "John Doe, Bit Recycler, Megacorp"\). 사용자가 원하는 어떤 형태로든 가능합니다. 회의와 같은 애플리케이션의 경우 이 이름 형식은 참가자 목록에 표시하는 데 가장 적합할 수 있으므로 CNAME 이외의 항목 중 가장 자주 전송될 수 있습니다. 프로필은 그러한 우선순위를 설정할 수 있습니다. NAME 값은 적어도 세션 기간 동안 일정하게 유지되어야 합니다. 세션의 모든 참가자 간에 고유하다고 의존해서는 안 됩니다.

---
### **6.4.3 EMAIL: Electronic mail address SDES item**

```text
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |    EMAIL=3    |     length    | email address of source      ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

이메일 주소는 RFC 822 \[19\]에 따라 형식화됩니다\(예: "John.Doe@megacorp.com"\). EMAIL 값은 세션 기간 동안 일정하게 유지되어야 합니다.

---
### **6.4.4 PHONE: Phone number SDES item**

```text
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |    PHONE=4    |     length    | phone number of source       ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

전화번호는 국제 접속 코드 대신 더하기 기호를 사용하여 형식화되어야 합니다. 예를 들어 미국 전화번호의 경우 '+1 908 555 1212'입니다.

---
### **6.4.5 LOC: Geographic user location SDES item**

```text
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |     LOC=5     |     length    | geographic location of site  ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

응용 분야에 따라 이 항목에 적합한 세부 수준이 다릅니다. 컨퍼런스 애플리케이션의 경우 "Murray Hill, New Jersey"와 같은 문자열이면 충분할 수 있지만 활성 배지 시스템의 경우 "Room 2A244, AT&T BL MH"와 같은 문자열이 적절할 수 있습니다. 세부사항의 정도는 구현 및/또는 사용자에게 달려 있지만 형식과 내용은 프로필에 의해 규정될 수 있습니다. LOC 값은 모바일 호스트를 제외하고 세션 기간 동안 일정하게 유지될 것으로 예상됩니다.

---
### **6.4.6 TOOL: Application or tool name SDES item**

```text
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |     TOOL=6    |     length    | name/version of source appl. ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

스트림을 생성하는 애플리케이션의 이름과 버전을 제공하는 문자열입니다\(예: "videotool 1.2"\). 이 정보는 디버깅 목적으로 유용할 수 있으며 메일러 또는 메일 시스템 버전 SMTP 헤더와 유사합니다. TOOL 값은 세션 기간 동안 일정하게 유지되어야 합니다.

---
### **6.4.7 NOTE: Notice/status SDES item**

```text
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |     NOTE=7    |     length    | note about the source        ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

이 항목에 대해 다음 의미 체계가 제안되지만 이러한 의미 체계 또는 다른 의미 체계는 프로필에 의해 명시적으로 정의될 수 있습니다. 참고 항목은 소스의 현재 상태를 설명하는 일시적인 메시지\(예: "통화 중이므로 통화할 수 없음"\)를 위한 것입니다. 또는 세미나 중에 이 항목을 사용하여 강연 제목을 전달할 수도 있습니다. 이는 예외적인 정보를 전달하는 데에만 사용해야 하며 모든 참가자가 일상적으로 포함해서는 안 됩니다. 이렇게 하면 수신 보고서와 CNAME이 전송되는 속도가 느려지고 프로토콜 성능이 저하될 수 있기 때문입니다. 특히, 포함되어서는 안 된다.

사용자 구성 파일의 항목으로 사용되거나 오늘의 견적처럼 자동으로 생성되지 않습니다.

NOTE 항목은 활성화된 동안 표시하는 것이 중요할 수 있으므로 NAME과 같은 CNAME이 아닌 다른 항목이 전송되는 속도가 줄어들어 NOTE 항목이 RTCP 대역폭의 해당 부분을 차지할 수 있습니다. 일시적인 메시지가 비활성화되면 NOTE 항목은 동일한 반복 속도로 여러 번 계속 전송되어야 하지만 수신자에게 신호를 보내기 위해 길이가 0인 문자열을 사용해야 합니다. 그러나 수신기는 반복 속도의 작은 배수 또는 20-30 RTCP 간격 동안 수신되지 않은 경우 NOTE 항목을 비활성 상태로 고려해야 합니다.

---
### **6.4.8 PRIV: Private extensions SDES item**

```text
      0                   1                   2                   3
      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |     PRIV=8    |     length    | prefix length | prefix string...
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    ...              |                  value string                ...
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

이 항목은 실험적 또는 애플리케이션별 SDES 확장을 정의하는 데 사용됩니다. 항목에는 길이-문자열 쌍으로 구성된 접두사가 포함되어 있으며 그 뒤에는 항목의 나머지 부분을 채우고 원하는 정보를 전달하는 값 문자열이 옵니다. 접두사 길이 필드의 길이는 8비트입니다. 접두사 문자열은 이 애플리케이션이 수신할 수 있는 다른 PRIV 항목과 관련하여 고유하도록 PRIV 항목을 정의하는 사람이 선택한 이름입니다. 응용 프로그램 작성자는 필요한 경우 응용 프로그램 이름과 추가 하위 유형 식별을 사용하도록 선택할 수 있습니다. 또는 다른 사람들이 자신이 나타내는 엔터티를 기반으로 이름을 선택한 다음 해당 엔터티 내에서 이름 사용을 조정하는 것이 좋습니다.

접두사는 항목의 총 길이인 255옥텟 내에서 일부 공간을 사용하므로 접두사는 최대한 짧게 유지해야 합니다. 이 시설과 제한된 RTCP 대역폭에 과부하가 걸려서는 안 됩니다. 이는 모든 애플리케이션의 모든 제어 통신 요구 사항을 충족하기 위한 것이 아닙니다.

SDES PRIV 접두사는 IANA에 의해 등록되지 않습니다. PRIV 항목의 일부 형식이 일반적인 유용성이 입증된 경우 대신 IANA에 등록된 일반 SDES 항목 유형을 할당하여 접두사가 필요하지 않도록 해야 합니다. 이는 사용을 단순화하고 전송 효율성을 높입니다.

---
## **6.5 BYE: Goodbye RTCP packet**

```text
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |V=2|P|    SC   |   PT=BYE=203  |             length            |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                           SSRC/CSRC                           |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   :                              ...                              :
   +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
   |     length    |               reason for leaving             ... (opt)
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

BYE 패킷은 하나 이상의 소스가 더 이상 활성 상태가 아님을 나타냅니다.

버전\(V\), 패딩\(P\), 길이:

- SR 패킷에 대해 설명된 것과 같습니다\(섹션 6.3.1 참조\).

패킷 유형\(PT\): 8비트

- 이를 RTCP BYE 패킷으로 식별하기 위한 상수 203을 포함합니다.

소스 카운트\(SC\): 5비트

- 이 BYE 패킷에 포함된 SSRC/CSRC 식별자의 수입니다. 카운트 값 0은 유효하지만 쓸모가 없습니다.

믹서가 BYE 패킷을 수신하면 믹서는 SSRC/CSRC 식별자를 변경하지 않고 BYE 패킷을 전달합니다. 믹서가 종료되면 믹서는 자신이 처리하는 모든 기여 소스와 자체 SSRC 식별자를 나열하는 BYE 패킷을 보내야 합니다. 선택적으로, BYE 패킷에는 8비트 옥텟 수와 그 뒤에 이탈 이유\(예: "카메라 오작동" 또는 "RTP 루프 감지"\)를 나타내는 많은 옥텟 텍스트가 포함될 수 있습니다. 문자열은 SDES에 대해 설명된 것과 동일한 인코딩을 갖습니다. 문자열이 패킷을 다음 32비트 경계까지 채우는 경우 문자열은 null로 끝나지 않습니다. 그렇지 않은 경우 BYE 패킷은 널 옥텟으로 채워집니다.

---
## **6.6 APP: Application-defined RTCP packet**

```text
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |V=2|P| subtype |   PT=APP=204  |             length            |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                           SSRC/CSRC                           |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                          name (ASCII)                         |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                   application-dependent data                 ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

APP 패킷은 패킷 유형 값 등록을 요구하지 않고 새로운 애플리케이션과 새로운 기능이 개발됨에 따라 실험적으로 사용하기 위한 것입니다. 인식할 수 없는 이름을 가진 APP 패킷은 무시되어야 합니다. 테스트 후 더 넓은 사용이 정당화되면 하위 유형 및 이름 필드 없이 각 APP 패킷을 재정의하고 RTCP 패킷 유형을 사용하여 인터넷 할당 번호 기관에 등록하는 것이 좋습니다.

버전\(V\), 패딩\(P\), 길이:

- SR 패킷에 대해 설명된 것과 같습니다\(섹션 6.3.1 참조\).

하위 유형: 5비트

- APP 패킷 세트를 하나의 고유한 이름으로 정의하거나 애플리케이션 종속 데이터에 대해 정의할 수 있도록 하위 유형으로 사용할 수 있습니다.

패킷 유형\(PT\): 8비트

- 이를 RTCP APP 패킷으로 식별하기 위한 상수 204가 포함되어 있습니다.

이름: 4옥텟

- 이 애플리케이션이 수신할 수 있는 다른 APP 패킷과 관련하여 고유하도록 APP 패킷 세트를 정의하는 사람이 선택한 이름입니다. 응용 프로그램 작성자는 응용 프로그램 이름을 사용하도록 선택한 다음 응용 프로그램에 대한 새 패킷 유형을 정의하려는 다른 사용자에게 하위 유형 값 할당을 조정할 수 있습니다. 또는 다른 사람들이 자신이 나타내는 엔터티를 기반으로 이름을 선택한 다음 해당 엔터티 내에서 이름 사용을 조정하는 것이 좋습니다. 이름은 4개의 ASCII 문자 시퀀스로 해석되며 대문자와 소문자는 별개로 처리됩니다.

애플리케이션 종속 데이터: 가변 길이

- 애플리케이션 종속 데이터는 APP 패킷에 나타날 수도 있고 나타나지 않을 수도 있습니다. 이는 RTP 자체가 아닌 애플리케이션에 의해 해석됩니다. 길이는 32비트의 배수여야 합니다.

---
## **7.  RTP Translators and Mixers**

최종 시스템 외에도 RTP는 RTP 수준에서 "중간 시스템"으로 간주될 수 있는 "번역기" 및 "믹서" 개념을 지원합니다. 이 지원이 프로토콜에 약간의 복잡성을 추가하기는 하지만 인터넷에서 멀티캐스트 오디오 및 비디오 응용 프로그램을 사용한 실험을 통해 이러한 기능에 대한 필요성이 명확하게 확립되었습니다. 섹션 2.3에 제시된 변환기 및 믹서의 사용 예는 방화벽과 낮은 대역폭 연결의 존재에서 비롯되며 둘 다 남아 있을 가능성이 높습니다.

---
## **7.1 General Description**

RTP 변환기/믹서는 두 개 이상의 전송 수준 "클라우드"를 연결합니다. 일반적으로 각 클라우드는 공통 네트워크 및 전송 프로토콜\(예: IP/UDP\), 멀티캐스트 주소 또는 유니캐스트 주소 쌍, 전송 수준 대상 포트로 정의됩니다. \(IP 버전 4에서 IP 버전 6까지의 네트워크 수준 프로토콜 변환기는 RTP에 보이지 않게 클라우드 내에 존재할 수 있습니다.\) 하나의 시스템은 여러 RTP 세션에 대한 변환기 또는 혼합기 역할을 할 수 있지만 각 시스템은 논리적으로 별도의 실체.

변환기나 믹서를 설치할 때 루프 생성을 방지하려면 다음 규칙을 준수해야 합니다.

- o 하나의 RTP 세션에 참여하는 변환기 및 혼합기에 의해 연결된 각 클라우드는 이러한 매개변수\(프로토콜, 주소, 포트\) 중 적어도 하나에서 다른 모든 클라우드와 구별되거나 네트워크 수준에서 다른 클라우드와 격리되어야 합니다. .

- o 첫 번째 규칙의 파생물은 전달될 소스 세트를 분할하지 않는 한 여러 변환기 또는 혼합기가 병렬로 연결되어서는 안 된다는 것입니다.

마찬가지로, 하나 이상의 RTP 변환기 또는 혼합기를 통해 통신할 수 있는 모든 RTP 최종 시스템은 동일한 SSRC 공간을 공유합니다. 즉, SSRC 식별자는 이러한 모든 최종 시스템 중에서 고유해야 합니다. 섹션 8.2에서는 SSRC 식별자를 고유하게 유지하고 루프를 감지하는 충돌 해결 알고리즘을 설명합니다.

다양한 목적과 응용 분야에 맞게 설계된 다양한 종류의 변환기와 혼합기가 있을 수 있습니다. 몇 가지 예로는 암호화 추가 또는 제거, 데이터 인코딩 또는 기본 프로토콜 변경, 멀티캐스트 주소와 하나 이상의 유니캐스트 주소 간 복제 등이 있습니다. 변환기와 믹서의 차이점은 변환기는 서로 다른 소스의 데이터 스트림을 개별적으로 통과하는 반면 믹서는 이를 결합하여 하나의 새로운 스트림을 형성한다는 것입니다.

변환기: SSRC 식별자를 그대로 유지하여 RTP 패킷을 전달합니다. 이를 통해 모든 소스의 패킷이 동일한 변환기를 통과하고 변환기의 네트워크 소스 주소를 전달하더라도 수신자가 개별 소스를 식별할 수 있습니다. 일부 종류의 변환기는 데이터를 그대로 전달하지만 다른 변환기는 데이터 인코딩을 변경하여 RTP 데이터 페이로드 유형 및 타임스탬프를 변경할 수도 있습니다. 여러 데이터 패킷이 하나로 다시 인코딩되거나 그 반대로 인코딩되는 경우 변환기는 나가는 패킷에 새 시퀀스 번호를 할당해야 합니다. 들어오는 패킷 스트림의 손실로 인해 나가는 시퀀스 번호에 해당 간격이 발생할 수 있습니다. 수신기는 원본 소스에서 어떤 페이로드 유형이나 전송 주소가 사용되었는지 다른 방법으로 알지 않는 한 번역기의 존재를 감지할 수 없습니다.

믹서: 하나 이상의 소스로부터 RTP 데이터 패킷 스트림을 수신하고, 데이터 형식을 변경하고, 어떤 방식으로든 스트림을 결합한 다음 결합된 스트림을 전달합니다. 여러 입력 소스 간의 타이밍은 일반적으로 동기화되지 않으므로 믹서는 스트림 간의 타이밍을 조정하고 결합된 스트림에 대한 자체 타이밍을 생성하므로 이것이 동기화 소스입니다. 따라서 믹서가 전달하는 모든 데이터 패킷에는 믹서 자체의 SSRC 식별자가 표시됩니다. 혼합 패킷에 기여하는 원래 소스의 ID를 보존하기 위해 믹서는 SSRC 식별자를 패킷의 고정 RTP 헤더 다음에 있는 CSRC 식별자 목록에 삽입해야 합니다. 자체적으로 일부 패킷의 기여 소스이기도 한 믹서는 해당 패킷의 CSRC 목록에 자체 SSRC 식별자를 명시적으로 포함해야 합니다.

일부 애플리케이션의 경우 믹서가 CSRC 목록에서 소스를 식별하지 않는 것이 허용될 수 있습니다. 그러나 이로 인해 해당 소스와 관련된 루프를 감지할 수 없는 위험이 발생합니다.

오디오와 같은 응용 분야에서 변환기에 비해 믹서가 갖는 장점은 입력 측에서 여러 소스가 활성화되어 있는 경우에도 출력 대역폭이 하나의 소스로 제한된다는 것입니다. 이는 낮은 대역폭 링크에 중요할 수 있습니다. 단점은 출력 측의 수신기가 어떤 소스가 전송되는지 제어할 수 없다는 것입니다.

믹서의 원격 제어를 위해 일부 메커니즘이 구현되지 않은 경우 통과되거나 음소거됩니다. 믹서에 의한 동기화 정보 재생성은 수신기가 원본 스트림의 미디어 간 동기화를 수행할 수 없음을 의미하기도 합니다. 멀티미디어 믹서가 그것을 할 수 있다.

```text
         [E1]                                    [E6]
          |                                       |
    E1:17 |                                 E6:15 |
          |                                       |   E6:15
          V  M1:48 (1,17)         M1:48 (1,17)    V   M1:48 (1,17)
         (M1)-------------><T1>-----------------><T2>-------------->[E7]
          ^                 ^     E4:47           ^   E4:47
     E2:1 |           E4:47 |                     |   M3:89 (64,45)
          |                 |                     |
         [E2]              [E4]     M3:89 (64,45) |
                                                  |        legend:
   [E3] --------->(M2)----------->(M3)------------|        [End system]
          E3:64        M2:12 (64)  ^                       (Mixer)
                                   | E5:45                 <Translator>
                                   |
                                  [E5]          source: SSRC (CSRCs)
                                                ------------------->

 Figure 3: Sample RTP network with end systems, mixers and translators
```

SSRC 및 CSRC 식별자에 미치는 영향을 설명하기 위해 혼합기 및 변환기 모음이 그림 3에 표시되어 있습니다. 그림에서 말단 시스템은 직사각형\(E\)으로, 변환기는 삼각형\(T\)으로, 믹서는 타원\(M\)으로 표시됩니다. "M1: 48\(1,17\)" 표기는 M1의 \(임의\) SSRC 값 48과 E1 및 E2 패킷의 SSRC 식별자에서 복사된 두 개의 CSRC 식별자 1과 17로 식별되는 믹서 M1에서 발생하는 패킷을 나타냅니다. .

---
## **7.2 RTCP Processing in Translators**

수정된 데이터 패킷을 전달하는 것 외에도 변환기와 혼합기는 RTCP 패킷도 처리해야 합니다. 대부분의 경우 최종 시스템에서 수신한 복합 RTCP 패킷을 분리하여 SDES 정보를 집계하고 SR 또는 RR 패킷을 수정합니다. 이 정보의 재전송은 패킷 도착이나 변환기나 믹서 자체의 RTCP 간격 타이머에 의해 트리거될 수 있습니다.

데이터 패킷을 수정하지 않는 변환기\(예: 멀티캐스트 주소와 유니캐스트 주소 사이만 복제하는 변환기\)는 단순히 수정되지 않은 RTCP 패킷을 전달할 수도 있습니다. ㅏ

어떤 방식으로든 페이로드를 변환하는 변환기는 데이터의 특성과 수신 품질을 반영하도록 SR 및 RR 정보에서 해당 변환을 수행해야 합니다. 이러한 변환기는 단순히 RTCP 패킷을 전달해서는 안 됩니다. 일반적으로 변환기는 서로 다른 소스의 SR 및 RR 패킷을 하나의 패킷으로 집계하면 안 됩니다. 그렇게 하면 LSR 및 DLSR 필드를 기반으로 하는 전파 지연 측정의 정확도가 감소하기 때문입니다.

SR 송신자 정보: 변환기는 자체 송신자 정보를 생성하지 않고, 한 클라우드에서 수신된 SR 패킷을 다른 클라우드로 전달합니다. SSRC는 그대로 유지되지만 번역에 필요한 경우 보낸 사람 정보를 수정해야 합니다. 변환기가 데이터 인코딩을 변경하는 경우 "발신자의 바이트 수" 필드를 변경해야 합니다. 여러 데이터 패킷을 하나의 출력 패킷으로 결합하는 경우 "발신자의 패킷 수" 필드를 변경해야 합니다. 타임스탬프 빈도를 변경하는 경우 SR 패킷의 "RTP 타임스탬프" 필드를 변경해야 합니다.

SR/RR 수신 보고서 블록: 변환기는 한 클라우드에서 수신된 수신 보고서를 다른 클라우드로 전달합니다. 이는 데이터의 반대 방향으로 흐른다는 점에 유의하세요. SSRC는 그대로 유지됩니다. 변환기가 여러 데이터 패킷을 하나의 출력 패킷으로 결합하여 시퀀스 번호를 변경하는 경우 패킷 손실 필드와 "확장된 마지막 시퀀스 번호" 필드에 대한 역 조작을 수행해야 합니다. 이는 복잡할 수 있습니다. 극단적인 경우 수신 보고서를 번역할 의미 있는 방법이 없을 수 있으므로 번역가는 수신 보고서를 전혀 전달하지 않거나 자체 수신을 기반으로 종합 보고서를 전달할 수도 있습니다. 일반적인 규칙은 특정 번역에 적합한 작업을 수행하는 것입니다.

번역가는 자체 SSRC 식별자를 요구하지 않지만, 수신한 내용에 대한 보고서를 보낼 목적으로 하나를 할당하도록 선택할 수 있습니다. 수신 보고서는 일반적으로 모든 참가자에게 멀티캐스트되므로 이는 연결된 모든 클라우드로 전송되며, 각각은 해당 클라우드로 전송된 데이터 스트림의 변환에 해당합니다.

SDES: 번역자는 일반적으로 SDES를 변경하지 않고 전달합니다.

- 한 클라우드에서 다른 클라우드로 정보를 수신하지만, 예를 들어 대역폭이 제한되는 경우 CNAME SDES가 아닌 정보를 필터링하기로 결정할 수 있습니다. SSRC 식별자 충돌 감지가 작동하려면 CNAME을 전달해야 합니다. 자체 RR 패킷을 생성하는 변환기는 해당 RR 패킷을 보내는 동일한 클라우드에 자신에 대한 SDES CNAME 정보를 보내야 합니다.

BYE: 변환기는 BYE 패킷을 변경 없이 전달합니다. 자체 SSRC가 있는 변환기는 패킷 전달을 중단하려는 경우 해당 SSRC 식별자를 사용하여 BYE 패킷을 생성해야 합니다.

```text
   APP:  Translators forward APP packets unchanged.
```

---
## **7.3 RTCP Processing in Mixers**

믹서는 자체적으로 새로운 데이터 스트림을 생성하므로 SR 또는 RR 패킷을 전혀 통과하지 않고 대신 양쪽에 대한 새로운 정보를 생성합니다.

SR 송신자 정보: 믹서는 송신자를 통과하지 않습니다.

- 소스 스트림의 특성이 믹스에서 손실되기 때문에 믹스되는 소스의 정보입니다. 믹서는 동기화 소스로서 혼합 데이터 스트림에 대한 송신자 정보를 포함하는 자체 SR 패킷을 생성하여 혼합 스트림과 동일한 방향으로 보냅니다.

SR/RR 수신 보고 블록: 믹서는 각 클라우드의 소스에 대해 자체 수신 보고서를 생성하여 동일한 클라우드로만 보냅니다. 이러한 수신 보고서를 다른 클라우드로 보내지 않으며 소스가 SSRC가 아니기 때문에\(오직 CSRC만\) 한 클라우드에서 다른 클라우드로 수신 보고서를 전달하지 않습니다.

SDES: 혼합기는 일반적으로 한 클라우드에서 다른 클라우드로 수신하는 SDES 정보를 변경 없이 전달하지만, 예를 들어 대역폭이 제한되는 경우 CNAME이 아닌 SDES 정보를 필터링하기로 결정할 수도 있습니다. SSRC 식별자 충돌 감지가 작동하려면 CNAME을 전달해야 합니다. \(믹서에서 생성된 CSRC 목록의 식별자는 최종 시스템에서 생성된 SSRC 식별자와 충돌할 수 있습니다.\) 믹서는 SR 또는 RR 패킷을 보내는 동일한 클라우드에 자신에 대한 SDES CNAME 정보를 보내야 합니다.

믹서는 SR 또는 RR 패킷을 전달하지 않으므로 일반적으로 복합 RTCP 패킷에서 SDES 패킷을 추출합니다. 오버헤드를 최소화하기 위해 SDES 패킷의 청크를 단일 SDES 패킷으로 집계한 다음 믹서에서 발생하는 SR 또는 RR 패킷에 쌓일 수 있습니다. RTCP 패킷 속도는 믹서의 양쪽에서 다를 수 있습니다.

CSRC 식별자를 삽입하지 않는 믹서는 SDES CNAME 전달을 삼가할 수도 있습니다. 이 경우 두 클라우드의 SSRC 식별자 공간은 독립적입니다. 앞서 언급했듯이 이 작동 모드에서는 루프를 감지할 수 없는 위험이 발생합니다.

BYE: 믹서는 BYE 패킷을 전달해야 합니다. 패킷 전달을 중단하려는 경우 자체 SSRC 식별자를 사용하여 BYE 패킷을 생성해야 합니다.

APP: 믹서에 의한 APP 패킷 처리는 애플리케이션별로 다릅니다.

---
## **7.4 Cascaded Mixers**

RTP 세션에는 그림 3에 표시된 대로 믹서 및 변환기 모음이 포함될 수 있습니다. 그림의 M2 및 M3와 같이 두 개의 믹서가 계단식으로 연결된 경우 믹서에서 수신한 패킷은 이미 혼합되었을 수 있으며 여러 개의 CSRC 목록이 포함될 수 있습니다. 식별자. 두 번째 믹서는 이미 혼합된 입력 패킷의 CSRC 식별자와 혼합되지 않은 입력 패킷의 SSRC 식별자를 사용하여 발신 패킷에 대한 CSRC 목록을 구축해야 합니다. 이는 그림에서 M3:89\(64,45\)로 표시된 믹서 M3의 출력 아크에 표시됩니다. 계단식으로 연결되지 않은 믹서의 경우와 마찬가지로 결과 CSRC 목록에 15개 이상의 식별자가 있으면 나머지는 포함될 수 없습니다.

---
## **8.  SSRC Identifier Allocation and Use**

RTP 헤더와 RTCP 패킷의 다양한 필드에 전달되는 SSRC 식별자는 RTP 세션 내에서 전역적으로 고유해야 하는 임의의 32비트 숫자입니다. 동일한 네트워크에 있거나 동시에 시작하는 참가자가 동일한 번호를 선택할 가능성이 없도록 번호를 신중하게 선택하는 것이 중요합니다.

주소가 고유하지 않을 수 있으므로 식별자로 로컬 네트워크 주소\(예: IPv4 주소\)를 사용하는 것만으로는 충분하지 않습니다. RTP 변환기와 혼합기는 서로 다른 주소 공간을 가진 여러 네트워크 간의 상호 운용을 가능하게 하기 때문에 두 공간 내의 주소에 대한 할당 패턴은 무작위 할당에서 발생하는 것보다 훨씬 더 높은 충돌 비율을 초래할 수 있습니다.

하나의 호스트에서 실행되는 여러 소스도 충돌할 수 있습니다.

또한 상태를 신중하게 초기화하지 않고 단순히 Random\(\)을 호출하여 SSRC 식별자를 얻는 것만으로는 충분하지 않습니다. 무작위 식별자를 생성하는 방법의 예는 부록 A.6에 나와 있습니다.

---
## **8.1 Probability of Collision**

식별자는 무작위로 선택되므로 둘 이상의 소스가 동일한 번호를 선택할 가능성이 있습니다. 예를 들어 일부 세션 관리 이벤트에 의해 자동으로 트리거되는 경우와 같이 모든 소스가 동시에 시작될 때 충돌이 가장 높은 확률로 발생합니다. N이 소스의 개수이고 L이 식별자의 길이\(여기서는 32비트\)라면 두 소스가

독립적으로 동일한 값을 선택하면 큰 N \[20\]에 대해 1 - exp\(-N\*\*2 / 2\*\*\(L+1\)\)로 근사화될 수 있습니다. N=1000의 경우 확률은 대략 10\*\*-4입니다.

일반적인 충돌 확률은 위의 최악의 경우보다 훨씬 낮습니다. 하나의 새로운 소스가 다른 모든 소스에 이미 고유 식별자가 있는 RTP 세션에 참가하면 충돌 가능성은 공간에서 사용되는 숫자의 일부일 뿐입니다. 다시 말하면, N이 소스의 개수이고 L이 식별자의 길이라면 충돌 확률은 N/2\*\*L입니다. N=1000의 경우 확률은 대략 2\*10\*\*-7입니다.

새로운 소스가 첫 번째 패킷\(데이터 또는 제어\)을 보내기 전에 다른 참가자로부터 패킷을 수신할 수 있으므로 충돌 가능성이 더욱 줄어듭니다. 새 소스가 SSRC 식별자를 통해 다른 참가자를 추적하는 경우 첫 번째 패킷을 전송하기 전에 새 소스는 해당 식별자가 수신된 것과 충돌하지 않는지 확인하거나 다시 선택할 수 있습니다.

---
## **8.2 Collision Resolution and Loop Detection**

SSRC 식별자 충돌 가능성은 낮지만 모든 RTP 구현은 충돌을 감지하고 이를 해결하기 위한 적절한 조치를 취할 준비가 되어 있어야 합니다. 소스가 언제든지 다른 소스가 자신과 동일한 SSRC 식별자를 사용하고 있음을 발견하면 이전 식별자에 대해 RTCP BYE 패킷을 보내고 다른 임의의 식별자를 선택해야 합니다. 수신자가 두 개의 다른 소스가 충돌하고 있음을 발견한 경우, 서로 다른 소스 전송 주소 또는 CNAME에서 이를 감지할 수 있으면 한 쪽의 패킷을 보관하고 다른 쪽의 패킷을 삭제할 수 있습니다. 두 소스는 사태가 지속되지 않도록 충돌을 해소할 것으로 예상된다.

무작위 식별자는 각 RTP 세션마다 전역적으로 고유하게 유지되므로 믹서나 변환기에 의해 발생할 수 있는 루프를 감지하는 데에도 사용할 수 있습니다. 루프는 다음 예와 같이 수정되지 않거나 혼합될 수 있는 데이터 및 제어 정보의 중복을 발생시킵니다.

- o 변환기가 직접 또는 변환기 체인을 통해 패킷을 수신한 동일한 멀티캐스트 그룹으로 패킷을 잘못 전달할 수 있습니다. 이 경우 동일한 패킷이 여러 번 나타나며 다른 네트워크 소스에서 시작됩니다.

```text
        o Two translators incorrectly set up in parallel, i.e., with the
         same multicast groups on both sides, would both forward packets
         from one multicast group to the other. Unidirectional
```

- 번역자는 두 장의 사본을 제작합니다. 양방향 변환기는 루프를 형성합니다.

- o 믹서는 직접적으로 또는 다른 믹서나 변환기를 통해 패킷을 수신하는 동일한 전송 대상으로 전송하여 루프를 닫을 수 있습니다. 이 경우 소스는 데이터 패킷의 SSRC와 혼합 데이터 패킷의 CSRC로 모두 표시될 수 있습니다.

소스는 자신의 패킷이 루핑되고 있거나 다른 소스의 패킷이 루핑되고 있음\(타사 루프\)을 발견할 수 있습니다.

소스 식별자의 무작위 선택에서 루프와 충돌로 인해 패킷은 동일한 SSRC 식별자로 도착하지만 소스 전송 주소는 달라집니다. 이는 패킷을 발생시킨 최종 시스템이나 중간 시스템의 주소일 수 있습니다. 결과적으로 소스가 소스 전송 주소를 변경하는 경우 루프 소스로 해석되지 않도록 새 SSRC 식별자도 선택해야 합니다. 변환기 또는 믹서의 반대쪽에서 발생하는 루프 또는 충돌은 모든 패킷 복사본이 변환기 또는 믹서를 통과하는 경우 소스 전송 주소를 사용하여 감지할 수 없습니다. 그러나 두 RTCP SDES 패킷의 청크에 동일한 내용이 포함되어 있으면 충돌이 여전히 감지될 수 있습니다. SSRC 식별자이지만 CNAME이 다릅니다.

이러한 충돌을 감지하고 해결하려면 RTP 구현에 아래 설명된 것과 유사한 알고리즘이 포함되어야 합니다. 설정된 소스와 충돌하는 새로운 소스 또는 루프의 패킷을 무시합니다. 이전 식별자에 대해 RTCP BYE를 보내고 새 식별자를 선택하여 참가자 자신의 SSRC 식별자와의 충돌을 해결합니다. 그러나 참가자 자신의 패킷 루프로 인해 충돌이 발생한 경우 알고리즘은 새 식별자를 한 번만 선택한 다음 루프 소스 전송 주소의 패킷을 무시합니다. 이는 BYE 패킷의 홍수를 방지하는 데 필요합니다.

이 알고리즘은 소스의 RTP 및 RTCP 패킷 모두에 대해 동일한 소스 전송 주소에 따라 달라집니다. 이 제약 조건을 충족하지 않는 응용 프로그램을 지원하려면 알고리즘을 수정해야 합니다.

이 알고리즘은 소스 식별자에 의해 인덱싱된 테이블을 유지하고 식별자가 \(처음\) 수신된 소스 전송 주소와 해당 소스에 대한 다른 상태를 포함해야 합니다. 데이터 또는 제어 패킷에 수신된 각 SSRC 또는 CSRC 식별자는 해당 데이터 또는 제어 정보를 처리하기 위해 이 테이블에서 조회됩니다. 제어 패킷의 경우 자체 SSRC가 있는 각 요소\(예: SDES 청크\)에는 별도의 조회가 필요합니다. \(수신 보고 블록의 SSRC는 예외입니다.\) SSRC 또는 CSRC가 아닌 경우

발견되면 새 항목이 생성됩니다. 이러한 테이블 항목은 해당 SSRC를 통해 RTCP BYE 패킷이 수신되거나 비교적 오랜 시간 동안 패킷이 도착하지 않은 경우 제거됩니다\(섹션 6.2.1 참조\).

참가자 자신의 데이터 패킷 루프를 추적하려면 충돌하는 것으로 밝혀진 소스 전송 주소\(식별자가 아님\)의 별도 목록을 유지해야 합니다. 이는 짧은 목록이어야 하며 일반적으로 비어 있어야 합니다. 이 목록의 각 요소는 소스 주소와 가장 최근에 충돌하는 패킷이 수신된 시간을 저장합니다. 10 RTCP 보고 간격 동안 해당 소스로부터 충돌하는 패킷이 도착하지 않으면 목록에서 요소가 제거될 수 있습니다\(섹션 6.2 참조\).

표시된 알고리즘의 경우 소스 식별자 테이블에는 참가자 자신의 소스 식별자와 상태가 포함되어 있다고 가정합니다. 참가자 자신의 소스 식별자에 대해 먼저 별도의 비교를 수행하도록 알고리즘을 재구성할 수 있습니다.

- 소스 식별자 테이블에서 SSRC 또는 CSRC 식별자를 찾을 수 없는 경우: 그런 다음 소스 전송 주소와 SSRC 또는 CSRC를 다른 상태와 함께 저장하는 새 항목을 만듭니다. 계속해서 일반 처리를 진행하세요.

```text
       (identifier is found in the table)
```

패킷의 소스 전송 주소가 일치하는 경우

- 이 식별자에 대한 테이블 항목에 저장된 것: 그런 다음 일반 처리를 계속합니다.

```text
       (an identifier collision or a loop is indicated)
```

소스 식별자가 참가자 자신의 것이 아닌 경우:

- 그런 다음 소스 식별자가 테이블 항목의 CNAME과 다른 CNAME 항목을 포함하는 RTCP SDES 청크에서 나온 경우: 그런 다음 \(선택적으로\) 제3자 충돌을 계산합니다. ELSE\(선택 사항\)는 타사 루프를 계산합니다. 데이터 패킷 또는 제어 요소의 처리를 중단합니다.

```text
       (a collision or loop of the participant's own data)
```

소스 전송 주소가 목록에서 발견된 경우

- 충돌하는 주소: 소스 식별자가 CNAME 항목을 포함하는 RTCP SDES 청크에서 나온 것이 아니거나 해당 CNAME이 참가자 자신의 것인 경우:

- 그런 다음 \(선택적으로\) 루프된 자체 트래픽 발생을 계산합니다. 충돌하는 주소 목록 항목에 현재 시간을 표시합니다. 데이터 패킷 또는 제어 요소의 처리를 중단합니다. 충돌 발생을 기록합니다. 충돌하는 주소 목록에 새 항목을 만들고 현재 시간을 표시합니다. 이전 SSRC 식별자를 사용하여 RTCP BYE 패킷을 보냅니다. 새로운 식별자를 선택하세요. 이전 SSRC에 처리 중인 패킷의 소스 전송 주소를 추가하여 소스 식별자 테이블에 새 항목을 만듭니다. 계속해서 일반 처리를 진행하세요.

이 알고리즘에서는 새로 충돌하는 소스 주소의 패킷은 무시되고 원래 소스의 패킷은 유지됩니다. \(원본 소스가 믹서를 통하고 나중에 동일한 소스가 직접 수신되는 경우 믹스의 다른 소스가 손실되지 않는 한 수신기는 전환하는 것이 좋습니다.\) 오랜 기간 동안 원래 소스에서 패킷이 도착하지 않는 경우 테이블 항목의 시간이 초과되고 새 소스가 인계받을 수 있습니다. 이는 원래 소스가 충돌을 감지하고 새 소스 식별자로 이동하는 경우 발생할 수 있지만 일반적인 경우 RTCP BYE 패킷이 원래 소스에서 수신되어 시간 초과를 기다리지 않고 상태를 삭제합니다.

충돌로 인해 새로운 SSRC 식별자가 선택되면 먼저 소스 식별자 테이블에서 후보 식별자를 조회하여 다른 소스에서 이미 사용 중인지 확인해야 합니다. 그렇다면 다른 후보를 생성하고 프로세스를 반복해야 합니다.

멀티캐스트 대상으로의 데이터 패킷 루프로 인해 심각한 네트워크 플러딩이 발생할 수 있습니다. 모든 믹서와 변환기는 루프를 끊을 수 있도록 여기에 있는 것과 같은 루프 감지 알고리즘을 구현해야 합니다. 이렇게 하면 초과 트래픽이 원본 트래픽의 중복 복사본 1개 이하로 제한되어 루프의 원인을 찾아 수정할 수 있도록 세션이 계속될 수 있습니다. 그러나 믹서나 변환기가 루프를 적절하게 중단하지 못하고 트래픽 수준이 높아지는 극단적인 경우에는 최종 시스템이 데이터 전송을 중단하거나 패킷을 완전히 제어해야 할 수도 있습니다. 이 결정은 애플리케이션에 따라 달라질 수 있습니다. 오류 상태는 적절하게 표시되어야 합니다. 길고 임의적인 시간\(분 단위\)이 지난 후 주기적으로 전송이 다시 시도될 수 있습니다.

---
## **9.  Security**

하위 계층 프로토콜은 결국 인증, 무결성 및 기밀성을 포함하여 RTP 애플리케이션에 필요할 수 있는 모든 보안 서비스를 제공할 수 있습니다. 이러한 서비스는 최근 IP에 지정되었습니다. RTP를 사용할 것으로 예상되는 초기 오디오 및 비디오 애플리케이션에서는 기밀성 서비스에 대한 필요성이 잘 확립되어 있으므로 하위 계층 서비스를 사용할 수 있을 때까지 RTP 및 RTCP와 함께 사용하기 위해 다음 섹션에서 기밀성 서비스를 정의합니다. 이 서비스에 대한 프로토콜의 오버헤드는 낮으므로 이 서비스가 향후 하위 계층 서비스에 의해 폐기되는 경우 페널티는 최소화됩니다.

대안으로, 보증되는 경우 향후 RTP에 대해 다른 서비스, 다른 서비스 구현 및 기타 알고리즘이 정의될 수 있습니다. 여기에 제시된 선택 사항은 상호 운용 가능한 보안 애플리케이션의 구현을 단순화하고 구현자에게 지침을 제공하기 위한 것입니다. 여기에 제시된 방법이 특정 보안 요구에 적합하다는 주장은 없습니다. 프로필은 애플리케이션이 제공해야 하는 서비스와 알고리즘을 지정하고 적절한 사용에 대한 지침을 제공할 수 있습니다.

키 배포 및 인증서는 이 문서의 범위를 벗어납니다.

---
## **9.1 Confidentiality**

기밀성은 의도된 수신자만이 수신된 패킷을 디코딩할 수 있음을 의미합니다. 다른 경우에는 패킷에 유용한 정보가 포함되어 있지 않습니다. 콘텐츠의 기밀성은 암호화를 통해 달성됩니다.

RTP 또는 RTCP의 암호화가 필요한 경우 단일 하위 계층 패킷의 전송을 위해 캡슐화되는 모든 옥텟은 하나의 단위로 암호화됩니다. RTCP의 경우 알려진 일반 텍스트 공격을 방지하기 위해 암호화하기 전에 32비트 난수를 장치 앞에 추가합니다. RTP의 경우 시퀀스 번호와 타임스탬프 필드가 임의 오프셋으로 초기화되므로 접두사가 필요하지 않습니다.

RTCP의 경우 복합 RTCP 패킷을 두 개의 하위 계층 패킷으로 분할하여 하나는 암호화되고 다른 하나는 일반 전송되도록 허용됩니다. 예를 들어, 암호화 키에 접근할 수 없는 타사 모니터를 수용하기 위해 수신 보고서가 암호화되지 않은 상태로 전송되는 동안 SDES 정보가 암호화될 수 있습니다. 그림 4에 설명된 이 예에서는 모든 복합 RTCP 패킷이 SR 또는 RR 패킷으로 시작한다는 요구 사항을 충족하기 위해 보고가 없는\(및 암호화된\) RR 패킷에 SDES 정보를 추가해야 합니다.

```text
                 UDP packet                        UDP packet
   -------------------------------------  -------------------------
   [32-bit ][       ][     #           ]  [    # sender # receiver]
   [random ][  RR   ][SDES # CNAME, ...]  [ SR # report # report  ]
   [integer][(empty)][     #           ]  [    #        #         ]
   -------------------------------------  -------------------------
                 encrypted                       not encrypted
```

```text
   #: SSRC

           Figure 4: Encrypted and non-encrypted RTCP packets
```

암호화 여부와 올바른 키 사용 여부는 수신자가 헤더 또는 페이로드 유효성 검사를 통해 확인합니다. RTP 및 RTCP 헤더에 대한 유효성 검사의 예는 부록 A.1 및 A.2에 나와 있습니다.

기본 암호화 알고리즘은 RFC 1423 \[21\]의 섹션 1.1에 설명된 대로 CBC\(암호 블록 체인\) 모드의 DES\(데이터 암호화 표준\) 알고리즘입니다. 단, 8옥텟의 배수에 대한 패딩은 P에 대해 설명된 대로 표시됩니다. 섹션 5.1의 비트. RTP 헤더에 또는 복합 RTCP 패킷의 무작위 접두사에 의해 무작위 값이 제공되기 때문에 초기화 벡터는 0입니다. CBC 초기화 벡터 사용에 대한 자세한 내용은 \[22\]를 참조하세요. 암호화를 지원하는 구현에서는 상호 운용성을 최대화하기 위해 항상 CBC 모드에서 DES 알고리즘을 기본값으로 지원해야 합니다. 이 방법을 선택한 이유는 인터넷에서 작동 중인 실험적인 오디오 및 비디오 도구에 사용하는 것이 쉽고 실용적이라는 것이 입증되었기 때문입니다. 다른 암호화 알고리즘은 RTP가 아닌 수단을 통해 세션에 대해 동적으로 지정될 수 있습니다.

위에서 설명한 RTP 수준의 암호화 대신 프로필은 암호화된 인코딩에 대한 추가 페이로드 유형을 정의할 수 있습니다. 이러한 인코딩은 패딩 및 암호화의 기타 측면을 처리하는 방법을 지정해야 합니다. 이 방법을 사용하면 원하는 애플리케이션의 헤더를 그대로 두고 데이터만 암호화할 수 있습니다. 이는 암호 해독과 디코딩을 모두 처리하는 하드웨어 장치에 특히 유용할 수 있습니다.

---
## **9.2 Authentication and Message Integrity**

인증 및 메시지 무결성은 현재 RTP 사양에 정의되어 있지 않습니다. 이러한 서비스는 키 관리 인프라 없이는 직접적으로 실현 가능하지 않기 때문입니다. 향후에는 하위 계층 프로토콜을 통해 인증 및 무결성 서비스가 제공될 것으로 예상됩니다.

---
## **10.  RTP over Network and Transport Protocols**

이 섹션에서는 특정 네트워크 및 전송 프로토콜 내에서 RTP 패킷을 전달하는 것과 관련된 문제를 설명합니다. 이 사양 외부의 프로토콜별 정의로 대체되지 않는 한 다음 규칙이 적용됩니다.

RTP는 기본 프로토콜을 사용하여 RTP 데이터 및 RTCP 제어 스트림의 역다중화를 제공합니다. UDP 및 유사한 프로토콜의 경우 RTP는 짝수 포트 번호를 사용하고 해당 RTCP 스트림은 그 다음으로 높은\(홀수\) 포트 번호를 사용합니다. 애플리케이션에 RTP 포트로 사용하기 위해 홀수 번호가 제공되는 경우 이 번호를 다음으로 낮은\(짝수\) 번호로 바꿔야 합니다.

RTP 데이터 패킷에는 길이 필드나 기타 설명이 포함되어 있지 않으므로 RTP는 기본 프로토콜을 사용하여 길이 표시를 제공합니다. RTP 패킷의 최대 길이는 기본 프로토콜에 의해서만 제한됩니다.

메시지\(패킷\)가 아닌 연속 옥텟 스트림의 추상화를 제공하는 기본 프로토콜에서 RTP 패킷을 전달하려면 프레이밍 메커니즘을 제공하기 위해 RTP 패킷의 캡슐화를 정의해야 합니다. 기본 프로토콜에 패딩이 포함되어 RTP 페이로드의 범위를 확인할 수 없는 경우에도 프레이밍이 필요합니다. 프레이밍 메커니즘은 여기에 정의되어 있지 않습니다.

프로파일은 UDP 패킷과 같은 하나의 하위 계층 프로토콜 데이터 단위에서 여러 RTP 패킷을 전달할 수 있도록 프레이밍을 제공하는 프로토콜에서 RTP가 전달되는 경우에도 사용할 프레이밍 방법을 지정할 수 있습니다. 하나의 네트워크 또는 전송 패킷에서 여러 RTP 패킷을 전달하면 헤더 오버헤드가 줄어들고 서로 다른 스트림 간의 동기화가 단순화될 수 있습니다.

---
## **11.  Summary of Protocol Constants**

이 섹션에는 이 사양에 정의된 상수의 요약 목록이 포함되어 있습니다.

RTP 페이로드 유형\(PT\) 상수는 이 문서가 아닌 프로필에 정의됩니다. 그러나 마커 비트와 페이로드 유형을 포함하는 RTP 헤더의 옥텟은 부록에 설명된 헤더 검증 절차를 위해 RTP 패킷을 RTCP SR 및 RR 패킷 유형과 구별하기 위해 예약된 값 200 및 201\(10진수\)을 피해야 합니다. A.1. 본 사양에 표시된 1개의 마커 비트와 7비트 페이로드 유형 필드의 표준 정의에 대해 이러한 제한은 페이로드 유형 72 및 73이 예약되어 있음을 의미합니다.

---
## **11.1 RTCP packet types**

```text
   abbrev.    name                   value
   SR         sender report            200
   RR         receiver report          201
   SDES       source description       202
   BYE        goodbye                  203
   APP        application-defined      204
```

이러한 유형 값은 RTP 패킷 또는 기타 관련 없는 패킷과 비교하여 RTCP 패킷의 향상된 헤더 유효성 검사를 위해 200-204 범위에서 선택되었습니다. RTCP 패킷 유형 필드를 RTP 헤더의 해당 옥텟과 비교할 때 이 범위는 마커 비트가 1\(보통 데이터 패킷에 없음\)이고 표준 페이로드 유형 필드의 상위 비트가 1인 것에 해당합니다\( 왜냐하면 정적 페이로드 유형은 일반적으로 하위 절반에 정의되어 있기 때문입니다. 이 범위는 또한 모두 0과 모두 1이 일반적인 데이터 패턴이기 때문에 수치적으로 0과 255 사이의 어느 정도 거리를 두고 선택되었습니다.

모든 복합 RTCP 패킷은 SR 또는 RR로 시작해야 하므로 이러한 코드는 RTCP 유효성 검사에서 마스크와 값을 사용하여 최대 비트 수를 테스트할 수 있도록 짝수/홀수 쌍으로 선택되었습니다.

다른 상수는 IANA에 의해 할당됩니다. 실험자는 실험에 필요한 번호를 등록하고, 필요하지 않은 번호는 등록을 취소하는 것이 좋습니다.

---
## **11.2 SDES types**

```text
   abbrev.    name                              value
   END        end of SDES list                      0
   CNAME      canonical name                        1
   NAME       user name                             2
   EMAIL      user's electronic mail address        3
   PHONE      user's phone number                   4
   LOC        geographic user location              5
   TOOL       name of application or tool           6
   NOTE       notice about the source               7
   PRIV       private extensions                    8
```

다른 상수는 IANA에 의해 할당됩니다. 실험자는 실험에 필요한 번호를 등록하고, 필요하지 않은 번호는 등록을 취소하는 것이 좋습니다.

---
## **12.  RTP Profiles and Payload Format Specifications**

특정 애플리케이션에 대한 RTP의 전체 사양에는 여기에 설명된 프로필 및 페이로드 형식 사양이라는 두 가지 유형의 동반 문서가 하나 이상 필요합니다.

RTP는 요구 사항이 다소 다른 다양한 애플리케이션에 사용될 수 있습니다. 이러한 요구 사항에 적응할 수 있는 유연성은 기본 프로토콜 사양에서 다중 선택을 허용한 다음 적절한 선택을 선택하거나 별도의 프로필 문서에서 특정 환경 및 응용 프로그램 클래스에 대한 확장을 정의함으로써 제공됩니다. 일반적으로 응용 프로그램은 하나의 프로필에서만 작동하므로 어떤 프로필이 사용 중인지 명시적으로 표시되지 않습니다. 오디오 및 비디오 애플리케이션에 대한 프로필은 함께 제공되는 Internet-Draftdraft-ietf-avt-profile에서 찾을 수 있습니다.

두 번째 유형의 동반 문서는 페이로드 형식 사양으로, H.261로 인코딩된 비디오와 같은 특정 종류의 페이로드 데이터가 RTP에서 전달되어야 하는 방식을 정의합니다. 이 문서의 제목은 일반적으로 "XYZ 오디오/비디오 인코딩을 위한 RTP 페이로드 형식"입니다. 페이로드 형식은 여러 프로필에서 유용할 수 있으므로 특정 프로필과 독립적으로 정의될 수 있습니다. 그런 다음 프로필 문서는 필요한 경우 해당 형식의 기본 매핑을 페이로드 유형 값에 할당하는 일을 담당합니다.

이 사양 내에서 프로필 내에서 가능한 정의를 위해 다음 항목이 식별되었지만 이 목록이 완전한 것은 아닙니다.

RTP 데이터 헤더: 마커 비트와 페이로드 유형 필드를 포함하는 RTP 데이터 헤더의 옥텟은 다양한 요구 사항에 맞게 프로필에 의해 재정의될 수 있습니다\(예: 더 많거나 더 적은 마커 비트 사용\)\(섹션 5.3\).

페이로드 유형: 페이로드 유형 필드가 포함되어 있다고 가정하면 프로필은 일반적으로 페이로드 형식 집합\(예: 미디어 인코딩\)과 해당 형식을 페이로드 유형 값에 대한 기본 정적 매핑을 정의합니다. 일부 페이로드 형식은 별도의 페이로드 형식 사양을 참조하여 정의될 수 있습니다. 정의된 각 페이로드 유형에 대해 프로필은 사용할 RTP 타임스탬프 클럭 속도를 지정해야 합니다\(섹션 5.1\).

RTP 데이터 헤더 추가: 페이로드 유형과 관계없이 프로필의 애플리케이션 클래스 전체에 일부 추가 기능이 필요한 경우 고정 RTP 데이터 헤더에 추가 필드를 추가할 수 있습니다\(섹션 5.3\).

RTP 데이터 헤더 확장: RTP 데이터 헤더 확장 구조의 처음 16비트의 내용은 해당 메커니즘의 사용이 구현별 확장에 대한 프로파일\(5.3.1절\)에서 허용되는 경우 정의되어야 합니다.

RTCP 패킷 유형: 새로운 애플리케이션 클래스별 RTCP 패킷 유형을 정의하고 IANA에 등록할 수 있습니다.

RTCP 보고 간격: 프로필은 RTCP 보고 간격 계산에 사용되는 상수에 대해 섹션 6.2에 제안된 값이 사용되도록 지정해야 합니다. 이는 세션 대역폭의 RTCP 비율, 최소 보고 간격, 발신자와 수신자 간의 대역폭 분할입니다. 프로필은 확장 가능한 방식으로 작동하는 것으로 입증된 경우 대체 값을 지정할 수 있습니다.

SR/RR 확장: 발신자 또는 수신자에 대해 정기적으로 보고해야 하는 추가 정보가 있는 경우 RTCP SR 및 RR 패킷에 대해 확장 섹션을 정의할 수 있습니다\(Section 6.3.3\).

SDES 사용: 프로필은 전송되거나 완전히 제외될 RTCP SDES 항목에 대한 상대적 우선순위를 지정할 수 있습니다\(섹션 6.2.2\). CNAME 항목에 대한 대체 구문 또는 의미\(섹션 6.4.1\) LOC 항목의 형식\(6.4.5절\) NOTE 항목의 의미 및 사용\(6.4.7절\) 또는 IANA에 등록할 새로운 SDES 항목 유형.

보안: 프로필은 어떤 보안 서비스와

- 알고리즘은 애플리케이션에 의해 제공되어야 하며 적절한 사용에 대한 지침을 제공할 수 있습니다\(섹션 9\).

문자열-키 매핑: 프로필은 사용자가 제공한 암호 또는 암호 문구가 암호화 키에 매핑되는 방법을 지정할 수 있습니다.

기본 프로토콜: RTP 패킷을 전달하기 위해 특정 기본 네트워크 또는 전송 계층 프로토콜을 사용해야 할 수도 있습니다.

전송 매핑: 섹션 10에 정의된 표준 매핑 외에 UDP 포트와 같은 전송 수준 주소에 대한 RTP 및 RTCP의 매핑이 지정될 수 있습니다.

캡슐화: RTP 패킷의 캡슐화는 여러 RTP 데이터 패킷이 하나의 하위 계층 패킷으로 전달되도록 허용하거나 아직 그렇게 하지 않은 기본 프로토콜을 통해 프레이밍을 제공하도록 정의될 수 있습니다\(섹션 10\).

모든 애플리케이션에 새 프로필이 필요할 것으로 예상되지는 않습니다. 하나의 응용 프로그램 클래스 내에서 각 응용 프로그램은 일반적으로 하나의 프로필에서만 실행되므로 응용 프로그램 간의 상호 운용을 용이하게 하기 위해 새 프로필을 만드는 것보다 기존 프로필을 확장하는 것이 더 좋습니다. 추가 페이로드 유형 값 또는 RTCP 패킷 유형의 정의와 같은 간단한 확장은 이를 인터넷 할당 번호 관리 기관\(Internet Assigned Numbers Authority\)을 통해 등록하고 해당 설명을 프로필에 대한 부록이나 페이로드 형식 사양에 게시하여 수행할 수 있습니다.

---
## **A.  Algorithms**

우리는 RTP 발신자 및 수신자 알고리즘 측면에 대한 C 코드의 예를 제공합니다. 특정 운영 환경에서는 더 빠르거나 다른 장점이 있는 다른 구현 방법이 있을 수 있습니다. 이러한 구현 노트는 정보 제공 목적으로만 제공되며 RTP 사양을 명확히 하기 위한 것입니다.

모든 예에는 다음 정의가 사용됩니다. 명확성과 간결성을 위해 구조 정의는 32비트 빅엔디안\(가장 중요한 옥텟 우선\) 아키텍처에만 유효합니다. 비트 필드는 추가 패딩 없이 빅엔디안 비트 순서로 촘촘하게 채워져 있다고 가정합니다. 이식 가능한 구현을 구성하려면 수정이 필요합니다.

```text
   /*
    * rtp.h  --  RTP header file (RFC XXXX)
    */
   #include <sys/types.h>

   /*
    * The type definitions below are valid for 32-bit architectures and
    * may have to be adjusted for 16- or 64-bit architectures.
    */
   typedef unsigned char  u_int8;
   typedef unsigned short u_int16;
   typedef unsigned int   u_int32;
   typedef          short int16;

   /*
    * Current protocol version.
    */
   #define RTP_VERSION    2

   #define RTP_SEQ_MOD (1<<16)
   #define RTP_MAX_SDES 255      /* maximum text length for SDES */

   typedef enum {
       RTCP_SR   = 200,
       RTCP_RR   = 201,
       RTCP_SDES = 202,
       RTCP_BYE  = 203,
       RTCP_APP  = 204
   } rtcp_type_t;

   typedef enum {
       RTCP_SDES_END   = 0,
       RTCP_SDES_CNAME = 1,

       RTCP_SDES_NAME  = 2,
       RTCP_SDES_EMAIL = 3,
       RTCP_SDES_PHONE = 4,
       RTCP_SDES_LOC   = 5,
       RTCP_SDES_TOOL  = 6,
       RTCP_SDES_NOTE  = 7,
       RTCP_SDES_PRIV  = 8
   } rtcp_sdes_type_t;

   /*
    * RTP data header
    */
   typedef struct {
       unsigned int version:2;   /* protocol version */
       unsigned int p:1;         /* padding flag */
       unsigned int x:1;         /* header extension flag */
       unsigned int cc:4;        /* CSRC count */
       unsigned int m:1;         /* marker bit */
       unsigned int pt:7;        /* payload type */
       u_int16 seq;              /* sequence number */
       u_int32 ts;               /* timestamp */
       u_int32 ssrc;             /* synchronization source */
       u_int32 csrc[1];          /* optional CSRC list */
   } rtp_hdr_t;

   /*
    * RTCP common header word
    */
   typedef struct {
       unsigned int version:2;   /* protocol version */
       unsigned int p:1;         /* padding flag */
       unsigned int count:5;     /* varies by packet type */
       unsigned int pt:8;        /* RTCP packet type */
       u_int16 length;           /* pkt len in words, w/o this word */
   } rtcp_common_t;

   /*
    * Big-endian mask for version, padding bit and packet type pair
    */
   #define RTCP_VALID_MASK (0xc000 | 0x2000 | 0xfe)
   #define RTCP_VALID_VALUE ((RTP_VERSION << 14) | RTCP_SR)

   /*
    * Reception report block
    */
   typedef struct {
       u_int32 ssrc;             /* data source being reported */
       unsigned int fraction:8;  /* fraction lost since last SR/RR */

       int lost:24;              /* cumul. no. pkts lost (signed!) */
       u_int32 last_seq;         /* extended last seq. no. received */
       u_int32 jitter;           /* interarrival jitter */
       u_int32 lsr;              /* last SR packet from this source */
       u_int32 dlsr;             /* delay since last SR packet */
   } rtcp_rr_t;

   /*
    * SDES item
    */
   typedef struct {
       u_int8 type;              /* type of item (rtcp_sdes_type_t) */
       u_int8 length;            /* length of item (in octets) */
       char data[1];             /* text, not null-terminated */
   } rtcp_sdes_item_t;

   /*
    * One RTCP packet
    */
   typedef struct {
       rtcp_common_t common;     /* common header */
       union {
           /* sender report (SR) */
           struct {
               u_int32 ssrc;     /* sender generating this report */
               u_int32 ntp_sec;  /* NTP timestamp */
               u_int32 ntp_frac;
               u_int32 rtp_ts;   /* RTP timestamp */
               u_int32 psent;    /* packets sent */
               u_int32 osent;    /* octets sent */
               rtcp_rr_t rr[1];  /* variable-length list */
           } sr;

           /* reception report (RR) */
           struct {
               u_int32 ssrc;     /* receiver generating this report */
               rtcp_rr_t rr[1];  /* variable-length list */
           } rr;

           /* source description (SDES) */
           struct rtcp_sdes {
               u_int32 src;      /* first SSRC/CSRC */
               rtcp_sdes_item_t item[1]; /* list of SDES items */
           } sdes;

           /* BYE */
           struct {
               u_int32 src[1];   /* list of sources */

               /* can't express trailing text for reason */
           } bye;
       } r;
   } rtcp_t;

   typedef struct rtcp_sdes rtcp_sdes_t;

   /*
    * Per-source state information
    */
   typedef struct {
       u_int16 max_seq;        /* highest seq. number seen */
       u_int32 cycles;         /* shifted count of seq. number cycles */
       u_int32 base_seq;       /* base seq number */
       u_int32 bad_seq;        /* last 'bad' seq number + 1 */
       u_int32 probation;      /* sequ. packets till source is valid */
       u_int32 received;       /* packets received */
       u_int32 expected_prior; /* packet expected at last interval */
       u_int32 received_prior; /* packet received at last interval */
       u_int32 transit;        /* relative trans time for prev pkt */
       u_int32 jitter;         /* estimated jitter */
       /* ... */
   } source;
```

---
## **A.1 RTP Data Header Validity Checks**

RTP 수신자는 수신 패킷에서 RTP 헤더의 유효성을 확인해야 합니다. 왜냐하면 해당 패킷이 암호화되었을 수 있거나 주소가 잘못 지정된 다른 애플리케이션에서 왔을 수 있기 때문입니다. 마찬가지로, 암호화가 활성화된 경우 헤더 유효성 검사는 수신 패킷이 올바르게 해독되었는지 확인하는 데 필요합니다. 하지만 헤더 유효성 검사 실패\(예: 알 수 없는 페이로드 유형\)가 반드시 암호 해독 실패를 의미하는 것은 아닐 수도 있습니다.

이전에 들어본 적이 없는 소스의 RTP 데이터 패킷에 대해서는 약한 유효성 검사만 가능합니다.

```text
        o RTP version field must equal 2.
```

- o 페이로드 유형을 알아야 하며, 특히 SR 또는 RR과 동일해서는 안 됩니다.

- o P 비트가 설정된 경우 패킷의 마지막 옥텟에는 유효한 옥텟 수가 포함되어야 하며, 특히 총 패킷 길이에서 헤더 크기를 뺀 값보다 작아야 합니다.

```text
        o The X bit must be zero if the profile does not specify that
         the header extension mechanism may be used. Otherwise, the
```

- 확장 길이 필드는 전체 패킷 크기에서 고정 헤더 길이와 패딩을 뺀 값보다 작아야 합니다.

- o 패킷 길이는 CC 및 페이로드 유형과 일치해야 합니다\(페이로드의 길이가 알려진 경우\).

마지막 세 가지 검사는 다소 복잡하고 항상 가능한 것은 아니며 총 몇 비트에 불과한 처음 두 가지 검사만 남깁니다. 패킷의 SSRC 식별자가 이전에 수신된 식별자인 경우 패킷은 유효할 가능성이 높으며 시퀀스 번호가 예상 범위에 있는지 확인하면 추가 유효성 검사가 제공됩니다. SSRC 식별자가 이전에 확인되지 않은 경우 해당 식별자를 전달하는 데이터 패킷 중 소수가 연속 시퀀스 번호와 함께 도착할 때까지 유효하지 않은 것으로 간주될 수 있습니다.

아래 표시된 루틴 update\_seq는 MIN\_SEQUENTIAL 패킷이 순서대로 수신된 후에만 소스가 유효하다고 선언되도록 보장합니다. 또한 새로 수신된 패킷의 시퀀스 번호 seq를 검증하고 s가 가리키는 구조에서 패킷 소스의 시퀀스 상태를 업데이트합니다.

새로운 소스가 처음으로 들리는 경우, 즉 해당 SSRC 식별자가 테이블에 없고\(섹션 8.2 참조\) 소스별 상태가 할당되면 s-\>probation을 다음 수로 설정해야 합니다. 유효한 소스를 선언하기 전에 필요한 순차 패킷\(매개변수 MIN\_SEQUENTIAL \) 및 seq-1로 초기화된 s-\>max\_seq s-\>검증은 소스를 아직 유효하지 않은 것으로 표시하므로 긴 시간 초과가 아닌 짧은 시간 초과 후에 상태가 폐기될 수 있습니다. 섹션 6.2.1에서 논의되었습니다.

소스가 유효한 것으로 간주된 후 시퀀스 번호가 s-\>max\_seq보다 MAX\_DROPOUT보다 크지 않고 뒤의 MAX\_MISORDER보다 크지 않으면 유효한 것으로 간주됩니다. 새 시퀀스 번호가 RTP 시퀀스 번호 범위\(16비트\)의 모듈로 max\_seq보다 앞에 있지만 max\_seq보다 작은 경우 순환되고 시퀀스 번호 주기의 \(이동된\) 수가 증가합니다. 유효한 시퀀스 번호를 나타내기 위해 값 1이 반환됩니다.

그렇지 않으면 유효성 검사가 실패했음을 나타내기 위해 값 0이 반환되고 잘못된 시퀀스 번호가 저장됩니다. 수신된 다음 패킷이 다음으로 높은 시퀀스 번호를 전달하는 경우 확장된 드롭아웃 또는 소스 재시작으로 인해 발생한 것으로 추정되는 새 패킷 시퀀스의 유효한 시작으로 간주됩니다. 여러 개의 전체 시퀀스 번호 주기가 누락되었을 수 있으므로 패킷 손실 통계가 재설정됩니다.

매개변수의 일반적인 값은 50패킷/초에서 최대 오더링 시간 2초와 최대 오더링 시간을 기준으로 표시됩니다.

1분 탈락. 드롭아웃 매개변수 MAX\_DROPOUT은 재시작 후 새 시퀀스 번호가 재시작 전의 시퀀스 번호에 대해 허용 가능한 범위에 속하지 않을 합리적인 확률을 제공하기 위해 16비트 시퀀스 번호 공간의 작은 부분이어야 합니다.

```text
   void init_seq(source *s, u_int16 seq)
   {
       s->base_seq = seq - 1;
       s->max_seq = seq;
       s->bad_seq = RTP_SEQ_MOD + 1;
       s->cycles = 0;
       s->received = 0;
       s->received_prior = 0;
       s->expected_prior = 0;
       /* other initialization */
   }

   int update_seq(source *s, u_int16 seq)
   {
       u_int16 udelta = seq - s->max_seq;
       const int MAX_DROPOUT = 3000;
       const int MAX_MISORDER = 100;
       const int MIN_SEQUENTIAL = 2;

       /*
        * Source is not valid until MIN_SEQUENTIAL packets with
        * sequential sequence numbers have been received.
        */
       if (s->probation) {
           /* packet is in sequence */
           if (seq == s->max_seq + 1) {
               s->probation--;
               s->max_seq = seq;
               if (s->probation == 0) {
                   init_seq(s, seq);
                   s->received++;
                   return 1;
               }
           } else {
               s->probation = MIN_SEQUENTIAL - 1;
               s->max_seq = seq;
           }
           return 0;
       } else if (udelta < MAX_DROPOUT) {
           /* in order, with permissible gap */
           if (seq < s->max_seq) {
               /*

                * Sequence number wrapped - count another 64K cycle.
                */
               s->cycles += RTP_SEQ_MOD;
           }
           s->max_seq = seq;
       } else if (udelta <= RTP_SEQ_MOD - MAX_MISORDER) {
           /* the sequence number made a very large jump */
           if (seq == s->bad_seq) {
               /*
                * Two sequential packets -- assume that the other side
                * restarted without telling us so just re-sync
                * (i.e., pretend this was the first packet).
                */
               init_seq(s, seq);
           }
           else {
               s->bad_seq = (seq + 1) & (RTP_SEQ_MOD-1);
               return 0;
           }
       } else {
           /* duplicate or reordered packet */
       }
       s->received++;
       return 1;
   }
```

유효성 검사는 두 개 이상의 패킷을 순서대로 요구하여 더욱 강력하게 수행될 수 있습니다. 단점은 더 많은 수의 초기 패킷이 삭제되고 높은 패킷 손실률로 인해 유효성 검사가 불가능할 수 있다는 것입니다. 그러나 RTCP 헤더 유효성 검사가 상대적으로 강력하기 때문에 RTCP 패킷이 데이터 패킷보다 먼저 소스로부터 수신되면 순서대로 두 개의 패킷만 필요하도록 개수를 조정할 수 있습니다. 몇 초 동안 초기 데이터 손실이 허용될 수 있는 경우 애플리케이션은 해당 소스에서 유효한 RTCP 패킷이 수신될 때까지 해당 소스의 모든 데이터 패킷을 삭제하도록 선택할 수 있습니다.

애플리케이션 및 인코딩에 따라 알고리즘은 추가 검증을 위해 페이로드 형식에 대한 추가 지식을 활용할 수 있습니다. 타임스탬프 증분이 모든 패킷에 대해 동일한 페이로드 유형의 경우 시퀀스 번호 차이를 사용하여 동일한 소스에서 수신된 이전 패킷에서 타임스탬프 값을 예측할 수 있습니다\(페이로드 유형에 변화가 없다고 가정\).

새로 수신된 RTP 데이터 패킷의 헤더에 있는 처음 4옥텟은 시퀀스 번호가 하나 늘렸습니다.

마찬가지로, 일반적으로 한 번에 하나의 소스에서 데이터를 수신하는 애플리케이션에서 더 빠른 SSRC 조회를 위해 단일 항목 캐시를 사용할 수 있습니다.

---
## **A.2 RTCP Header Validity Checks**

RTCP 패킷에는 다음 검사를 적용할 수 있습니다.

```text
        o RTP version field must equal 2.
```

- o 복합 패킷의 첫 번째 RTCP 패킷의 페이로드 유형 필드는 SR 또는 RR과 동일해야 합니다.

- o 복합 RTCP 패킷의 첫 번째 패킷에 대한 패딩 비트\(P\)는 0이어야 합니다. 왜냐하면 마지막 패킷에만 패딩이 필요할 수 있기 때문입니다.

- o 개별 RTCP 패킷의 길이 필드의 합은 수신된 복합 RTCP 패킷의 전체 길이와 같아야 합니다. 이것은 상당히 강력한 검사입니다.

아래 코드 조각은 이러한 모든 검사를 수행합니다. 알 수 없는 패킷 유형이 있을 수 있으므로 무시해야 하므로 후속 패킷에 대해서는 패킷 유형을 확인하지 않습니다.

```text
       u_int32 len;        /* length of compound RTCP packet in words */
       rtcp_t *r;          /* RTCP header */
       rtcp_t *end;        /* end of compound RTCP packet */

       if ((*(u_int16 *)r & RTCP_VALID_MASK) != RTCP_VALID_VALUE) {
           /* something wrong with packet format */
       }
       end = (rtcp_t *)((u_int32 *)r + len);

       do r = (rtcp_t *)((u_int32 *)r + r->common.length + 1);
       while (r < end && r->common.version == 2);

       if (r != end) {
           /* something wrong with packet format */
       }
```

---
## **A.3 Determining the Number of RTP Packets Expected and Lost**

패킷 손실률을 계산하려면 아래 코드에서 포인터 s를 통해 참조되는 구조체 소스에 정의된 소스별 상태 정보를 사용하여 각 소스에서 예상되고 실제로 수신된 패킷 수를 알아야 합니다. 수신된 패킷 수는 지연되거나 중복된 패킷을 포함하여 도착하는 패킷의 수입니다.

패킷. 예상되는 패킷 수는 수신된 가장 높은 시퀀스 번호\( s-\>max\_seq \)와 수신된 첫 번째 시퀀스 번호\( s-\>base\_seq \) 간의 차이로 수신기에서 계산할 수 있습니다. 시퀀스 번호는 16비트에 불과하고 순환하므로 시퀀스 번호 순환의 \(이동된\) 수\( s-\>cycles \)로 가장 높은 시퀀스 번호를 확장해야 합니다. 수신된 패킷 수와 사이클 수는 모두 부록 A.1의 RTP 헤더 유효성 확인 루틴을 통해 유지됩니다.

```text
       extended_max = s->cycles + s->max_seq;
       expected = extended_max - s->base_seq + 1;
```

손실된 패킷 수는 예상되는 패킷 수에서 실제로 수신된 패킷 수를 뺀 값으로 정의됩니다.

```text
       lost = expected - s->received;
```

이 숫자는 24비트로 전달되므로 0으로 돌아가는 대신 0xffffff로 고정되어야 합니다.

마지막 보고 간격\(이전 SR 또는 RR 패킷이 전송된 이후\) 동안 손실된 패킷의 비율은 간격 전체의 예상 패킷 수와 수신된 패킷 수의 차이에서 계산됩니다. 여기서 Expected\_prior 및 received\_prior는 이전 수신 보고가 전송되었을 때 저장된 값입니다. 생성됨:

```text
       expected_interval = expected - s->expected_prior;
       s->expected_prior = expected;
       received_interval = s->received - s->received_prior;
       s->received_prior = s->received;
       lost_interval = expected_interval - received_interval;
       if (expected_interval == 0 || lost_interval <= 0) fraction = 0;
       else fraction = (lost_interval << 8) / expected_interval;
```

결과 분수는 왼쪽 가장자리에 이진 소수점이 있는 8비트 고정 소수점 숫자입니다.

---
## **A.4 Generating SDES RTCP Packets**

이 함수는 배열 유형, 값 및 길이 b에 제공된 argc 항목으로 구성된 버퍼 b에 하나의 SDES 청크를 빌드합니다.

```text
   char *rtp_write_sdes(char *b, u_int32 src, int argc,
                        rtcp_sdes_type_t type[], char *value[],
                        int length[])
   {
       rtcp_sdes_t *s = (rtcp_sdes_t *)b;
       rtcp_sdes_item_t *rsp;

       int i;
       int len;
       int pad;

       /* SSRC header */
       s->src = src;
       rsp = &s->item[0];

       /* SDES items */
       for (i = 0; i < argc; i++) {
           rsp->type = type[i];
           len = length[i];
           if (len > RTP_MAX_SDES) {
               /* invalid length, may want to take other action */
               len = RTP_MAX_SDES;
           }
           rsp->length = len;
           memcpy(rsp->data, value[i], len);
           rsp = (rtcp_sdes_item_t *)&rsp->data[len];
       }

       /* terminate with end marker and pad to next 4-octet boundary */
       len = ((char *) rsp) - b;
       pad = 4 - (len & 0x3);
       b = (char *) rsp;
       while (pad--) *b++ = RTCP_SDES_END;

       return b;
   }
```

---
## **A.5 Parsing RTCP SDES Packets**

이 함수는 SSRC 식별자가 제공된 세션 멤버에 대한 정보에 대한 포인터를 찾기 위해 find\_member\(\) 함수를 호출하고 해당 멤버에 대한 새 SDES 정보를 저장하기 위해 member\_sdes\(\) 함수를 호출하여 SDES 패킷을 구문 분석합니다. 이 함수는 RTCP 패킷의 헤더에 대한 포인터를 기대합니다.

```text
   void rtp_read_sdes(rtcp_t *r)
   {
       int count = r->common.count;
       rtcp_sdes_t *sd = &r->r.sdes;
       rtcp_sdes_item_t *rsp, *rspn;
       rtcp_sdes_item_t *end = (rtcp_sdes_item_t *)
                               ((u_int32 *)r + r->common.length + 1);
       source *s;

       while (--count >= 0) {

           rsp = &sd->item[0];
           if (rsp >= end) break;
           s = find_member(sd->src);

           for (; rsp->type; rsp = rspn ) {
               rspn = (rtcp_sdes_item_t *)((char*)rsp+rsp->length+2);
               if (rspn >= end) {
                   rsp = rspn;
                   break;
               }
               member_sdes(s, rsp->type, rsp->data, rsp->length);
           }
           sd = (rtcp_sdes_t *)
                ((u_int32 *)sd + (((char *)rsp - (char *)sd) >> 2)+1);
       }
       if (count >= 0) {
           /* invalid packet format */
       }
   }
```

---
## **A.6 Generating a Random 32-bit Identifier**

다음 서브루틴은 RFC 1321\[23\]에 게시된 MD5 루틴을 사용하여 임의의 32비트 식별자를 생성합니다. 시스템 루틴은 모든 운영 체제에 존재하지 않을 수 있지만 어떤 종류의 정보가 사용될 수 있는지에 대한 힌트 역할을 해야 합니다. 적절할 수 있는 다른 시스템 호출은 다음과 같습니다.

```text
        o getdomainname() ,

        o getwd() , or

        o getrusage()
```

"라이브" 비디오 또는 오디오 샘플도 난수의 좋은 소스이지만 꺼진 마이크나 눈이 먼 카메라를 소스로 사용하지 않도록 주의해야 합니다\[7\].

RTCP 기간\(부록 A.7 참조\)을 생성하는 난수 생성기에 대한 초기 시드를 생성하고, 시퀀스 번호 및 타임스탬프에 대한 초기 값을 생성하고, SSRC 값을 생성하려면 이 루틴이나 유사한 루틴을 사용하는 것이 좋습니다. 이 루틴은 CPU를 많이 사용하기 때문에 예측 가능성이 문제가 되지 않으므로 RTCP 기간을 생성하는 데 직접 사용하는 것은 부적절합니다. 이 루틴은 유형 인수에 다른 값이 제공되지 않는 한 시스템 시계 값이 변경될 때까지 반복 호출에 대해 동일한 결과를 생성합니다.

```text
   /*
    * Generate a random 32-bit quantity.
    */
   #include <sys/types.h>   /* u_long */
   #include <sys/time.h>    /* gettimeofday() */
   #include <unistd.h>      /* get..() */
   #include <stdio.h>       /* printf() */
   #include <time.h>        /* clock() */
   #include <sys/utsname.h> /* uname() */
   #include "global.h"      /* from RFC 1321 */
   #include "md5.h"         /* from RFC 1321 */

   #define MD_CTX MD5_CTX
   #define MDInit MD5Init
   #define MDUpdate MD5Update
   #define MDFinal MD5Final

   static u_long md_32(char *string, int length)
   {
       MD_CTX context;
       union {
           char   c[16];
           u_long x[4];
       } digest;
       u_long r;
       int i;

       MDInit (&context);
       MDUpdate (&context, string, length);
       MDFinal ((unsigned char *)&digest, &context);
       r = 0;
       for (i = 0; i < 3; i++) {
           r ^= digest.x[i];
       }
       return r;
   }                               /* md_32 */

   /*
    * Return random unsigned 32-bit quantity. Use 'type' argument if you
    * need to generate several different values in close succession.
    */
   u_int32 random32(int type)
   {
       struct {
           int     type;
           struct  timeval tv;
           clock_t cpu;

           pid_t   pid;
           u_long  hid;
           uid_t   uid;
           gid_t   gid;
           struct  utsname name;
       } s;

       gettimeofday(&s.tv, 0);
       uname(&s.name);
       s.type = type;
       s.cpu  = clock();
       s.pid  = getpid();
       s.hid  = gethostid();
       s.uid  = getuid();
       s.gid  = getgid();

       return md_32((char *)&s, sizeof(s));
   }                               /* random32 */
```

---
## **A.7 Computing the RTCP Transmission Interval**

다음 함수는 RTCP 패킷 전송 사이의 시간을 초 단위로 반환합니다. 하나의 복합 RTCP 패킷을 보낸 후 호출하여 다음 패킷이 전송될 때까지의 지연 시간을 계산해야 합니다. 또한 이 함수는 패킷을 즉시 보내는 대신 시작 시 첫 번째 RTCP 패킷을 보내기 전의 지연을 계산하기 위해 호출되어야 합니다. 이는 예를 들어 세션 알림의 결과로 인해 여러 사이트에서 동시에 애플리케이션이 시작되는 경우 RTCP 패킷의 버스트를 방지합니다.

매개변수의 의미는 다음과 같습니다.

rtcp\_bw: 대상 RTCP 대역폭, 즉 이 세션의 모든 구성원이 RTCP 패킷에 사용할 총 대역폭\(초당 옥텟\)입니다. 이는 시작 시 애플리케이션에 제공되는 "세션 대역폭" 매개변수의 5%여야 합니다.

발신자: 이 RTCP 패킷에 대한 수신자 보고서 구성을 통해 알려진 마지막 보고서를 보낸 이후 활성 발신자 수입니다. 이 간격 동안 보낸 경우 우리 자신도 포함됩니다.

회원: 다음을 포함한 예상 세션 회원 수입니다.

- 우리 자신. RTP 또는 RTCP 패킷 수신을 통해 새 세션 구성원을 발견하면 증가하고 세션 구성원이 RTCP BYE를 통해 떠나거나 상태가 시간 초과되면 감소합니다\(30분 권장\). 첫 번째 호출에서 이 매개변수의 값은 1이어야 합니다.

we\_sent: 마지막 두 RTCP 간격 동안 데이터를 보낸 경우 true인 플래그입니다. 플래그가 true이면 방금 보낸 복합 RTCP 패킷에 SR 패킷이 포함되어 있는 것입니다.

packet\_size: 네트워크 캡슐화를 포함하여 방금 전송된 복합 RTCP 패킷의 크기\(옥텟\)입니다\(예: UDP over IP의 경우 28옥텟\).

avg\_rtcp\_size: 복합 RTCP 패킷 크기 추정기에 대한 포인터입니다. 방금 전송된 패킷에 대해 이 함수에 의해 초기화 및 업데이트되었으며 세션의 다른 참가자로부터 수신된 모든 RTCP 패킷에 대해 RTCP 수신 루틴의 동일한 코드 줄에 의해 업데이트되었습니다.

초기: 첫 번째 보고서가 전송되어야 할 때까지의 시간을 계산하기 위해 시작 시 첫 번째 호출에 대해 true인 플래그입니다.

```text
   #include <math.h>
```

double rtcp\_interval\(int 멤버,

- int senders, double rtcp\_bw, int we\_sent, int packet\_size, int \*avg\_rtcp\_size, intinitial\) { /\* \* 이 사이트의 RTCP 패킷 간 최소 시간\(초\)입니다. \* 이번에는 세션이 \* 작거나 대수의 법칙이 트래픽을 원활하게 \* 돕는 데 도움이 되지 않을 때 보고서가 '뭉쳐지는' 것을 방지합니다. 또한 \* 네트워크 파티션과 같은 일시적인 중단 중에 보고 간격이 터무니없이 작아지는 것을 방지합니다. \*/ double const RTCP\_MIN\_TIME = 5.; /\* \* 활성 발신자 간에 공유될 RTCP 대역폭의 비율입니다. \(이 부분은 하나 또는 두 명의 활성 발신자가 있는 일반적인 \* 세션에서 계산된 보고 시간이 \* 우리가 수신자 보고를 불필요하게 느리게 하지 않도록 \* 최소 보고 시간과 대략 동일하도록 선택되었습니다.\) \* 수신자 비율은 1이어야 합니다\(발신자 비율\). \*/ double const RTCP\_SENDER\_BW\_FRACTION = 0.25; 이중 const RTCP\_RCVR\_BW\_FRACTION = \(1-RTCP\_SENDER\_BW\_FRACTION\); /\* \* 저역 통과 필터에 대한 이득\(평활 상수\)

```text
        * estimates the average RTCP packet size (see Cadzow reference).
        */
       double const RTCP_SIZE_GAIN = (1./16.);

       double t;                   /* interval */
       double rtcp_min_time = RTCP_MIN_TIME;
       int n;                      /* no. of members for computation */

       /*
        * Very first call at application start-up uses half the min
        * delay for quicker notification while still allowing some time
        * before reporting for randomization and to learn about other
        * sources so the report interval will converge to the correct
        * interval more quickly.  The average RTCP size is initialized
        * to 128 octets which is conservative (it assumes everyone else
        * is generating SRs instead of RRs: 20 IP + 8 UDP + 52 SR + 48
        * SDES CNAME).
        */
       if (initial) {
           rtcp_min_time /= 2;
           *avg_rtcp_size = 128;
       }

       /*
        * If there were active senders, give them at least a minimum
        * share of the RTCP bandwidth.  Otherwise all participants share
        * the RTCP bandwidth equally.
        */
       n = members;
       if (senders > 0 && senders < members * RTCP_SENDER_BW_FRACTION) {
           if (we_sent) {
               rtcp_bw *= RTCP_SENDER_BW_FRACTION;
               n = senders;
           } else {
               rtcp_bw *= RTCP_RCVR_BW_FRACTION;
               n -= senders;
           }
       }

       /*
        * Update the average size estimate by the size of the report
        * packet we just sent.
        */
       *avg_rtcp_size += (packet_size - *avg_rtcp_size)*RTCP_SIZE_GAIN;
```

/\*

- \* 유효 사이트 수 x 평균 패킷 크기는 \* 각 사이트에서 보고서를 보낼 때 전송된 총 옥텟 수입니다.

```text
        * Dividing this by the effective bandwidth gives the time
        * interval over which those packets must be sent in order to
        * meet the bandwidth target, with a minimum enforced.  In that
        * time interval we send one report so this time is also our
        * average time between reports.
        */
       t = (*avg_rtcp_size) * n / rtcp_bw;
       if (t < rtcp_min_time) t = rtcp_min_time;

       /*
        * To avoid traffic bursts from unintended synchronization with
        * other sites, we then pick our actual next report interval as a
        * random number uniformly distributed between 0.5*t and 1.5*t.
        */
       return t * (drand48() + 0.5);
   }
```

---
## **A.8 Estimating the Interarrival Jitter**

아래 코드 조각은 수신 보고서의 도착 간 지터 필드에 삽입될 RTP 데이터 도착 간 시간의 통계적 분산 추정치를 계산하기 위해 섹션 6.3.1에 제공된 알고리즘을 구현합니다. 입력은 수신 패킷의 타임스탬프인 r-\>ts 와 동일한 단위로 된 현재 시간인 Arrival 입니다. 다음은 소스에 대한 상태를 나타냅니다. s-\>transit은 이전 패킷의 상대적 전송 시간을 보유하고 s-\>jitter는 추정된 지터를 보유합니다. 수신 보고서의 지터 필드는 타임스탬프 단위로 측정되어 부호 없는 정수로 표현되지만 지터 추정치는 부동 소수점으로 유지됩니다. 각 데이터 패킷이 도착하면 지터 추정치가 업데이트됩니다.

```text
       int transit = arrival - r->ts;
       int d = transit - s->transit;
       s->transit = transit;
       if (d < 0) d = -d;
       s->jitter += (1./16.) * ((double)d - s->jitter);
```

이 멤버에 대해 수신 보고 블록\(rr이 가리키는\)이 생성되면 현재 지터 추정치가 반환됩니다.

```text
       rr->jitter = (u_int32) s->jitter;
```

또는 지터 추정치를 정수로 유지하면서 반올림 오류를 줄이기 위해 크기를 조정할 수도 있습니다. 마지막 줄을 제외하고 계산은 동일합니다.

```text
       s->jitter += d - ((s->jitter + 8) >> 4);
```

이 경우 수신 보고서에 대한 견적은 다음과 같이 샘플링됩니다.

```text
       rr->jitter = s->jitter >> 4;
```

---
## **B.  Security Considerations**

RTP는 기본 프로토콜과 동일한 보안 책임을 안고 있습니다. 예를 들어 사기꾼은 소스 또는 대상 네트워크 주소를 위조하거나 헤더 또는 페이로드를 변경할 수 있습니다. RTCP 내에서 CNAME 및 NAME 정보는 다른 참가자를 가장하는 데 사용될 수 있습니다. 또한 RTP는 IP 멀티캐스트를 통해 전송될 수 있는데, 이는 전송자가 전송된 데이터의 모든 수신자를 알 수 있는 직접적인 수단을 제공하지 않으므로 개인 정보 보호를 측정할 수 없습니다. 옳든 아니든 사용자는 전통적인 형태의 네트워크 통신보다 오디오 및 비디오 통신의 개인 정보 보호 문제에 더 민감할 수 있습니다\[24\]. 따라서 RTP와 함께 보안 메커니즘을 사용하는 것이 중요합니다. 이러한 메커니즘은 섹션 9에서 논의됩니다.

RTP 수준 변환기 또는 혼합기를 사용하여 RTP 트래픽이 방화벽 뒤의 호스트에 도달하도록 허용할 수 있습니다. 이 문서의 범위를 벗어나는 적절한 방화벽 보안 원칙 및 관행은 이러한 장치의 설계 및 설치와 방화벽 뒤에서 사용하기 위한 RTP 애플리케이션 승인 시 따라야 합니다.

---
## **C. Authors' Addresses**

```text
   Henning Schulzrinne
   GMD Fokus
   Hardenbergplatz 2
   D-10623 Berlin
   Germany

   EMail: schulzrinne@fokus.gmd.de

   Stephen L. Casner
   Precept Software, Inc.
   21580 Stevens Creek Boulevard, Suite 207
   Cupertino, CA 95014
   United States

   EMail: casner@precept.com

   Ron Frederick
   Xerox Palo Alto Research Center
   3333 Coyote Hill Road
   Palo Alto, CA 94304
   United States

   EMail: frederic@parc.xerox.com

   Van Jacobson
   MS 46a-1121
   Lawrence Berkeley National Laboratory
   Berkeley, CA 94720
   United States

   EMail: van@ee.lbl.gov
```

---
# **Acknowledgments**

이 각서는 Stephen Casner가 의장을 맡은 IETF 오디오/비디오 전송 실무 그룹 내 논의를 바탕으로 작성되었습니다. 현재 프로토콜은 네트워크 음성 프로토콜 및 패킷 비디오 프로토콜\(Danny Cohen 및 Randy Cole\)과 vat 애플리케이션\(Van Jacobson 및 Steve McCanne\)에 의해 구현된 프로토콜에서 유래되었습니다. Christian Huitema는 무작위 식별자 생성기에 대한 아이디어를 제공했습니다.

---
## **D.  Bibliography**

\[1\] D. D. Clark 및 D. L. Tennenhouse, "신세대 프로토콜에 대한 아키텍처 고려 사항", SIGCOMM Symposium on Communications Architectures and Protocols\(펜실베이니아 필라델피아\), pp. 200-208, IEEE, 1990년 9월. 컴퓨터 통신 리뷰, Vol. 1990년 9월 20\(4\).

\[2\] H. Schulzrinne, "음성 및 화상 회의와 기타 다중 참가자 실시간 애플리케이션을 위한 전송 프로토콜 설계 문제", 진행 중인 작업.

\[3\] D. E. Comer, TCP/IP를 이용한 인터네트워킹, vol. 1. 뉴저지 주 잉글우드 클리프: 프렌티스 홀, 1991년.

```text
   [4] Postel, J., "Internet Protocol", STD 5, RFC 791, USC/Information
       Sciences Institute, September 1981.

   [5] Mills, D., "Network Time Protocol Version 3", RFC 1305, UDEL,
       March 1992.
```

\[6\] Reynolds, J. 및 J. Postel, "할당된 번호", STD 2, RFC 1700, USC/정보 과학 연구소, 1994년 10월.

\[7\] Eastlake, D., Crocker, S., J. Schiller, "무작위성"

- 보안에 대한 권장 사항", RFC 1750, DEC, Cybercash, MIT, 1994년 12월.

\[8\] J.-C. Bolot, T. Turletti 및 I. Wakeman, "인터넷의 멀티캐스트 비디오 배포를 위한 확장 가능한 피드백 제어", 통신 아키텍처 및 프로토콜에 관한 SIGCOMM 심포지엄\(영국 런던\), 페이지 58-67, ACM, 8월. 1994.

\[9\] I. Busse, B. Deffner 및 H. Schulzrinne, "RTP 기반 멀티미디어 애플리케이션의 동적 QoS 제어", Computer Communications, 1996년 1월.

\[10\] S. Floyd 및 V. Jacobson, "주기적인 라우팅 메시지의 동기화", 통신 아키텍처 및 프로토콜에 관한 SIGCOMM 심포지엄\(D. P. Sidhu, ed.\), \(캘리포니아주 샌프란시스코\), pp. 33-44, ACM, 1993년 9월. \[25\]에도 있음.

\[11\] J. A. Cadzow, 디지털 신호 처리 및 데이터 분석의 기초 뉴욕, 뉴욕: Macmillan, 1987.

\[12\] 국제 표준 기구, "ISO/IEC DIS 10646-1:1993 정보 기술 - 범용 다중 옥텟 코드 문자 집합\(UCS\) - 파트 I: 아키텍처 및 기본 다국어 평면," 1993.

\[13\] 유니코드 컨소시엄, 유니코드 표준 뉴욕, 뉴욕: Addison-Wesley, 1991.

\[14\] Mockapetris, P., "도메인 이름 - 개념 및 시설", STD 13, RFC 1034, USC/정보 과학 연구소, 1987년 11월.

\[15\] Mockapetris, P., "도메인 이름 - 구현 및 사양", STD 13, RFC 1035, USC/정보 과학 연구소, 1987년 11월.

\[16\] Braden, R., "인터넷 호스트 요구 사항 - 응용 프로그램 및 지원", STD 3, RFC 1123, 인터넷 엔지니어링 태스크 포스, 1989년 10월.

\[17\] Rekhter, Y., Moskowitz, R., Karrenberg, D. 및 G. de Groot, "개인 인터넷에 대한 주소 할당", RFC 1597, T.J. Watson 연구 센터, IBM Corp., Chrysler Corp., RIPE NCC, 1994년 3월.

\[18\] Lear, E., Fair, E., Crocker, D. 및 T. Kessler, "유해한 것으로 간주되는 네트워크 10\(일부 관행은 성문화해서는 안 됨\)", RFC 1627, Silicon Graphics, Inc., Apple Computer , Inc., Silicon Graphics, Inc., 1994년 7월.

\[19\] Crocker, D., "ARPA 인터넷 문자 메시지 형식에 대한 표준", STD 11, RFC 822, UDEL, 1982년 8월.

\[20\] W. Feller, 확률 이론 및 그 응용 소개, 1권, vol. 1. 뉴욕, 뉴욕: John Wiley and Sons, 3판, 1968.

\[21\] Balenson, D., "인터넷 전자 메일의 개인 정보 보호 강화: 파트 III: 알고리즘, 모드 및 식별자", RFC 1423, TIS, IAB IRTF PSRG, IETF PEM WG, 1993년 2월.

\[22\] V. L. Voydock 및 S. T. Kent, "고수준 네트워크 프로토콜의 보안 메커니즘", ACM Computing Surveys, vol. 15, pp. 135--171, 1983년 6월.

\[23\] Rivest, R., "MD5 메시지 다이제스트 알고리즘", RFC 1321, MIT 컴퓨터 과학 연구소 및 RSA 데이터 보안, Inc., 1992년 4월.

\[24\] S. Stubblebine, "멀티미디어 회의를 위한 보안 서비스", 제16차 전국 컴퓨터 보안 회의\(메릴랜드주 볼티모어\), pp. 391--395, 1993년 9월.

\[25\] S. Floyd 및 V. Jacobson, "주기적인 라우팅 메시지의 동기화," 네트워킹의 IEEE/ACM 트랜잭션, vol. 2, pp. 122-136, 1994년 4월.
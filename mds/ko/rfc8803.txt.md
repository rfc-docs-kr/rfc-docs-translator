

```text
﻿

Internet Engineering Task Force (IETF)               O. Bonaventure, Ed.
Request for Comments: 8803                                      Tessares
Category: Experimental                                 M. Boucadair, Ed.
ISSN: 2070-1721                                                   Orange
                                                           S. Gundavelli
                                                                   Cisco
                                                                  S. Seo
                                                           Korea Telecom
                                                              B. Hesmans
                                                                Tessares
                                                               July 2020

                       0-RTT TCP Convert Protocol
```

---
# **Abstract**

이 문서에서는 다중 경로 TCP와 같은 TCP 확장 배포를 지원하기 위해 전송 변환기라고 하는 응용 프로그램 프록시를 지정합니다. 전송 변환기는 하나 이상의 TCP 확장에 대한 변환 서비스를 제공할 수 있습니다. 변환 서비스는 0-RTT TCP 변환 프로토콜\(Convert\)을 통해 제공됩니다.

이 프로토콜은 프록시되지 않은 연결에 비해 프로토콜로 인해 추가 지연이 발생하지 않으므로 0-RTT\(Zero Round-Trip Time\) 변환 서비스를 제공합니다. 또한 변환 프로토콜에는 캡슐화가 필요하지 않습니다\(터널 없음\).

이 사양에서는 전송 변환기가 호스트에 명시적으로 구성되어 있는 명시적 모델을 가정합니다. 샘플 적용 가능성 사용 사례로서 이 문서에서는 변환 프로토콜이 다중 경로 TCP에 적용되는 방법을 지정합니다.

---
# **Status of This Memo**

이 문서는 인터넷 표준 추적 사양이 아닙니다. 시험, 실험 구현 및 평가를 위해 게시됩니다.

이 문서는 인터넷 커뮤니티를 위한 실험 프로토콜을 정의합니다. 이 문서는 IETF\(Internet Engineering Task Force\)의 산물입니다. 이는 IETF 커뮤니티의 합의를 나타냅니다. 공개 검토를 받았으며 IESG\(Internet Engineering Steering Group\)의 게시 승인을 받았습니다. IESG가 승인한 모든 문서가 모든 수준의 인터넷 표준에 대한 후보는 아닙니다. RFC 7841의 섹션 2를 참조하세요.

이 문서의 현재 상태, 정오표, 피드백 제공 방법에 대한 정보는 https://www.rfc-editor.org/info/rfc8803에서 얻을 수 있습니다.

---
# **Copyright Notice**

Copyright \(c\) 2020 IETF Trust 및 문서 작성자로 확인된 사람. 판권 소유.

이 문서는 이 문서의 발행일에 유효한 BCP 78 및 IETF 문서에 관한 IETF 트러스트의 법적 조항\(https://trustee.ietf.org/license-info\)의 적용을 받습니다. 이 문서와 관련된 귀하의 권리 및 제한 사항을 설명하므로 이 문서를 주의 깊게 검토하십시오. 이 문서에서 추출한 코드 구성 요소는 Trust Legal Provisions의 섹션 4.e에 설명된 대로 Simplified BSD License 텍스트를 포함해야 하며 Simplified BSD License에 설명된 대로 보증 없이 제공됩니다.

---
# **Table of Contents**

```text
   1.  Introduction
     1.1.  The Problem
     1.2.  Network-Assisted Connections: The Rationale
     1.3.  Applicability Scope
   2.  Conventions and Definitions
   3.  Differences with SOCKSv5
   4.  Architecture and Behaviors
     4.1.  Functional Elements
     4.2.  Theory of Operation
     4.3.  Data Processing at the Transport Converter
     4.4.  Address Preservation vs. Address Sharing
       4.4.1.  Address Preservation
       4.4.2.  Address/Prefix Sharing
   5.  Sample Examples
     5.1.  Outgoing Converter-Assisted Multipath TCP Connections
     5.2.  Incoming Converter-Assisted Multipath TCP Connection
   6.  The Convert Protocol (Convert)
     6.1.  The Convert Fixed Header
     6.2.  Convert TLVs
       6.2.1.  Generic Convert TLV Format
       6.2.2.  Summary of Supported Convert TLVs
       6.2.3.  The Info TLV
       6.2.4.  Supported TCP Extensions TLV
       6.2.5.  Connect TLV
       6.2.6.  Extended TCP Header TLV
       6.2.7.  The Cookie TLV
       6.2.8.  Error TLV
   7.  Compatibility of Specific TCP Options with the Conversion
           Service
     7.1.  Base TCP Options
     7.2.  Window Scale (WS)
     7.3.  Selective Acknowledgments
     7.4.  Timestamp
     7.5.  Multipath TCP
     7.6.  TCP Fast Open
     7.7.  TCP-AO
   8.  Interactions with Middleboxes
   9.  Security Considerations
     9.1.  Privacy & Ingress Filtering
     9.2.  Authentication and Authorization Considerations
     9.3.  Denial of Service
     9.4.  Traffic Theft
     9.5.  Logging
   10. IANA Considerations
     10.1.  Convert Service Name
     10.2.  The Convert Protocol (Convert) Parameters
       10.2.1.  Convert Versions
       10.2.2.  Convert TLVs
       10.2.3.  Convert Error Messages
   11. References
     11.1.  Normative References
     11.2.  Informative References
   Appendix A.  Example Socket API Changes to Support the 0-RTT TCP
           Convert Protocol
     A.1.  Active Open (Client Side)
     A.2.  Passive Open (Converter Side)
   Acknowledgments
   Contributors
   Authors' Addresses
```

---
## **1.  Introduction**
---
### **1.1.  The Problem**

TCP와 같은 전송 프로토콜은 정기적으로 발전합니다\[RFC7414\]. TCP는 다양한 방식으로 개선되었습니다. 초기 창 크기 변경\[RFC6928\] 또는 혼잡 제어 방식 수정과 같은 일부 개선 사항은 클라이언트와 서버에 독립적으로 적용될 수 있습니다. 선택적 승인\[RFC2018\] 또는 큰 창\[RFC7323\]과 같은 기타 개선 사항에는 새로운 TCP 옵션이 필요하거나 TCP 헤더에서 일부 필드의 의미를 변경해야 합니다. 인터넷에서 실제로 사용하려면 이러한 수정 사항을 클라이언트와 서버 모두에 배포해야 합니다. 후자 클래스의 TCP 확장에 대한 경험에 따르면 배포에 수년이 걸릴 수 있습니다. Fukuda는 \[Fukuda2011\]에서 선택적 승인, 창 크기 조정 및 TCP 타임스탬프의 배포를 보여주는 10년간의 측정 결과를 보고합니다. \[ANRW17\]에서는 TCP Fast Open\(TFO\) \[RFC7413\]이 아직 널리 배포되지 않았음을 보여주는 측정에 대해 설명합니다.

클라이언트\(또는 서버\)에서 사용되는 전송 스택이 서버\(또는 클라이언트\)에서 실행되는 전송 스택보다 더 빠른 속도로 업그레이드될 수 있는 상황이 있습니다. 이러한 상황에서 클라이언트\(또는 서버\)는 일반적으로 서버\(또는 클라이언트\)가 아직 업그레이드되지 않은 경우에도 향상된 전송 프로토콜 기능의 이점을 원할 것입니다. 이러한 기능을 활용하려면 네트워크의 일부 지원이 중요합니다. 예를 들어, 성능 강화 프록시\[RFC3135\] 및 기타 서비스 기능은 특정 특성을 가진 링크를 통해 TCP 성능을 향상시키는 솔루션으로 배포되었습니다.

TCP 확장의 최근 예로는 MPTCP\(Multipath TCP\) \[RFC8684\] 또는 tcpcrypt \[RFC8548\]가 있습니다. 이러한 확장은 무선 장치와 같이 클라이언트에게 흥미로운 기능을 제공합니다. 다중 경로 TCP를 사용하면 이러한 장치는 결합 목적, 더 빠른 핸드오버 또는 더 나은 복원력을 위해 WLAN\(무선 근거리 통신망\) 및 셀룰러 네트워크를 원활하게 사용할 수 있습니다. 불행하게도 광범위한 클라이언트와 서버 모두에 이러한 확장을 배포하는 것은 여전히 ​​어렵습니다.

최근에는 새로 고안된 클라이언트와 다중 경로 TCP 프록시를 사용하여 기존 4G\(LTE\) 연결의 글로벌 범위에 대한 5G 결합 실험이 수행되었습니다. 다중 경로 TCP에 의존하는 5G 및 4G 결합이 대역폭을 증가시키더라도 중간 노드가 모바일 코어 내부에 있는지 외부에 있는지에 관계없이 최종 호스트 간의 대기 시간을 완전히 최소화하는 것도 중요합니다. 차세대 모바일 네트워크를 위한 URLLC\(Ultra-Reliable Low Latency Communication\)를 처리하려면 다중 경로 TCP와 ATSSS\(Access Traffic Steering, Switching, Splitting\)를 제공하는 데 사용되는 프록시 메커니즘을 최적화해야 합니다. 대기 시간 \[TS23501\].

---
### **1.2.  Network-Assisted Connections: The Rationale**

이 문서에서는 Transport Converter라는 애플리케이션 프록시를 지정합니다. 전송 변환기는 TCP 확장의 배포를 지원하고 특히 클라이언트에게 이러한 확장의 이점을 제공하기 위해 네트워크 운영자가 설치하는 기능입니다. 전송 변환기는 하나 이상의 TCP 확장에 대한 변환 서비스를 제공할 수 있습니다. 변환 서비스에 적합한 TCP 확장은 배포에 따라 다릅니다. 변환 서비스는 변환기의 특정 TCP 포트 번호를 사용하는 애플리케이션 계층 프로토콜인 0-RTT TCP 변환 프로토콜\(Convert\)을 통해 제공됩니다.

Convert 프로토콜은 프록시되지 않은 연결에 비해 프로토콜로 인해 추가 지연이 발생하지 않으므로 0-RTT\(Zero Round-Trip Time\) 변환 서비스를 제공합니다. 특히, 변환 프로토콜은 변환 서비스를 사용하기 전에 추가 신호 설정 지연이 필요하지 않습니다. 변환 프로토콜은 캡슐화가 필요하지 않습니다\(터널 없음\).

Transport Converter는 \[RFC1919\]의 섹션 3에 그려진 주요 단계를 준수합니다. 특히 전송 변환기는 다음을 달성합니다.

```text
   *  Listening for Client sessions;

   *  Receiving the address of the Server from the Client;

   *  Setting up a session to the Server;

   *  Relaying control messages and data between the Client and the
      Server;
```

\* 로컬 정책에 따라 액세스 제어를 수행합니다.

네트워크 지원 변환 서비스의 주요 장점은 엔드포인트 간 경로의 하위 집합에서 새로운 TCP 확장을 사용할 수 있도록 하여 이러한 확장의 배포를 장려한다는 것입니다. 또한 전송 변환기를 사용하면 클라이언트와 서버가 전체 경로를 따라 기본 지원을 위해 TCP 확장을 직접 협상할 수 있습니다.

변환 프로토콜은 0-RTT 변환 서비스를 제공하는 일반적인 메커니즘입니다. 샘플 적용 가능성 사용 사례로서 이 문서에서는 변환 프로토콜이 다중 경로 TCP에 적용되는 방법을 지정합니다. 모든 잠재적 전환 서비스의 포괄적인 목록을 제공하는 것은 이 문서의 범위를 벗어납니다. 적용 문서는 향후 정의될 수 있습니다.

이 문서에서는 모든 트래픽이 네트워크 지원 변환 서비스에 적합하다고 가정하지 않습니다. 일련의 정책에 따라 트래픽의 하위 집합만 전송 변환기로 전달됩니다. 이러한 정책과 정책이 엔드포인트에 전달되는 방식은 범위를 벗어납니다. 또한, 필요한 TCP 확장을 이미 지원하는 서버에 직접 연결하기 위해 전송 변환기를 우회하는 것도 가능합니다.

이 문서에서는 클라이언트가 하나 이상의 전송 변환기 목록으로 구성되는 명시적 모델을 가정합니다\(정적으로 또는 \[DHC-CONVERTER\]와 같은 프로토콜을 통해\). 구성 수단은 이 문서의 범위를 벗어납니다.

전송 변환기를 사용한다는 것은 클라이언트와 서버 간에 종단 간 전송 연결이 없음을 의미합니다. 이는 \[RFC3135\]의 섹션 4에서 논의된 것과 같은 일부 시나리오에서 잠재적으로 문제를 일으킬 수 있습니다. 이러한 문제 중 일부는 적용되지 않을 수 있습니다. 예를 들어 전송 변환기는 네트워크 오류\(65\) 또는 대상에 연결할 수 없음\(97\) 오류 메시지\(섹션 6.2.8\)를 통해 오류 문제가 발생했음을 클라이언트에 알릴 수 있습니다. 클라이언트는 이에 따라 반응할 수 있습니다. 엔드포인트 또는 해당 네트워크 관리자는 Transport Converter 서비스가 제공하는 이점과 위험을 평가할 수 있습니다. 이것이 전송 변환기 기능이 엔드포인트에서 명시적으로 요청되어야 하는 이유 중 하나입니다.

이 문서는 다음과 같이 구성되어 있습니다.

- 섹션 3에서는 잘 알려진 SOCKS 프로토콜과 0-RTT TCP 변환 프로토콜 간의 차이점에 대한 간략한 개요를 제공합니다.

- 섹션 4에서는 전송 변환기의 작동에 대해 간략하게 설명합니다.

- 섹션 5에는 전반적인 동작을 설명하기 위한 일련의 샘플 예제가 포함되어 있습니다.

- 섹션 6에서는 변환 프로토콜에 대해 설명합니다.

- 섹션 7에서는 전송 변환기를 사용하여 다양한 TCP 확장을 지원하는 방법에 대해 설명합니다.

- 섹션 8에서는 미들박스와의 상호작용에 대해 논의합니다.

- 섹션 9에서는 보안 고려 사항에 중점을 둡니다.

- 부록 A에서는 TCP 스택이 이 문서에 설명된 프로토콜을 지원하는 방법을 설명합니다.

---
### **1.3.  Applicability Scope**

이 문서에 지정된 0-RTT TCP 변환 프로토콜은 단일 관리 도메인 배포 모델에서 사용해야 합니다. 즉, 클라이언트에게 연결 서비스를 제공하는 주체는 제3자 네트워크를 통한 전송 없이 Transport Converter를 소유하고 운영하는 주체이기도 합니다.\(MUST\)

향후 제3자에 의한 전송 변환기 배포는 특히 불법적인 트래픽 가로채기\(섹션 9.4\)를 방지하기 위해 섹션 9.2의 상호 인증 요구 사항을 준수해야 합니다.\(MUST\)

---
## **2.  Conventions and Definitions**

키워드 "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY" 및 "OPTIONAL" "는 BCP 14 \[RFC2119\] \[RFC8174\]에 설명된 대로 여기에 표시된 것처럼 모두 대문자로 표시되는 경우에만 해석됩니다.\(MUST NOT\)

---
## **3.  Differences with SOCKSv5**

여러 IETF 프로토콜은 프록시 서비스를 제공하며, SOCKSv5 프로토콜\[RFC1928\]인 0-RTT TCP 변환 프로토콜에 가장 가깝습니다. 이 프로토콜은 이미 일부 셀룰러 네트워크에서 다중 경로 TCP를 배포하는 데 사용되었습니다\(\[RFC8041\]의 섹션 2.2\).

SOCKS 클라이언트는 SOCKS 프록시에 대한 연결을 생성하고 인증 정보를 교환하며 대상 서버의 IP 주소와 포트 번호를 나타냅니다. 이 시점에서 SOCKS 프록시는 대상 서버에 대한 연결을 생성하고 프록시된 두 연결 사이의 모든 데이터를 중계합니다. SOCKSv5\(인증 없음\) 기반 구현의 작동은 그림 1에 설명되어 있습니다.

```text
   Client                SOCKS Proxy               Server
      |                       |                       |
      | --------------------> |                       |
      |         SYN           |                       |
      | <-------------------- |                       |
      |       SYN+ACK         |                       |
      | --------------------> |                       |
      |         ACK           |                       |
      |                       |                       |
      | --------------------> |                       |
      |Version=5, Auth Methods|                       |
      | <-------------------- |                       |
      |       Method          |                       |
      | --------------------> |                       |
      |Auth Request (unless "No auth" method negotiated)
      | <-------------------- |                       |
      |     Auth Response     |                       |
      | --------------------> |                       |
      | Connect Server:Port   | --------------------> |
      |                       |          SYN          |
      |                       | <-------------------- |
      |                       |        SYN+ACK        |
      | <-------------------- |                       |
      |      Succeeded        |                       |
      | --------------------> |                       |
      |       Data1           |                       |
      |                       | --------------------> |
      |                       |         Data1         |
      |                       | <-------------------- |
      |                       |         Data2         |
      | <-------------------- |                       |
      |          Data2        |                       |
                            ...

     Figure 1: Establishment of a TCP Connection through a SOCKS Proxy
                           without Authentication
```

SOCKS를 사용하는 경우 클라이언트와 서버 간의 "엔드 투 엔드" 연결은 SOCKS 프록시에 함께 붙어 있는 두 개의 TCP 연결 시퀀스가 ​​됩니다. SOCKS 클라이언트와 서버는 클라이언트-프록시 연결의 바이트스트림 시작 부분에서 제어 정보를 교환합니다. 그런 다음 SOCKS 프록시는 대상 서버와의 연결을 생성한 다음 애플리케이션\(클라이언트\)이 SOCKS 프록시로 보낸 모든 바이트가 서버로 전달되고 그 반대로 전달되도록 두 연결을 함께 연결합니다.

변환 프로토콜은 업스트림 연결과 다운스트림 연결 간에 데이터를 중계하는 TCP 프록시에도 사용되지만 SOCKSv5에는 중요한 차이점이 있습니다. 첫 번째 차이점은 0-RTT TCP 변환 프로토콜이 초기 RTT 동안 모든 제어 정보를 교환한다는 것입니다. 이는 최종 목적지를 향해 다운스트림 연결을 설정하기 전에 두 번 이상의 왕복 시간이 필요한 SOCKS에 비해 연결 설정 지연을 줄입니다. 오늘날의 인터넷에서 대기 시간은 중요한 지표이며 대기 시간을 줄이기 위해 다양한 프로토콜이 조정되었습니다\[LOW-LATENCY\]. 최근 제안된 SOCKS 확장은 이러한 지연을 줄이기 위해 TFO\(TCP Fast Open\) 옵션 \[INTAREA-SOCKS\]을 활용합니다.

두 번째 차이점은 변환 프로토콜이 TCP 확장을 명시적으로 고려한다는 것입니다. 변환 프로토콜을 사용하여 클라이언트는 지정된 TCP 확장이 대상 서버에서 지원되는지 여부를 알 수 있습니다. 이를 통해 서버가 필요한 TCP 확장을 지원할 때 클라이언트가 전송 변환기를 우회할 수 있습니다. SOCKSv5 \[RFC1928\]이나 제안된 SOCKSv6 \[INTAREA-SOCKS\] 모두 이러한 기능을 제공하지 않습니다.

세 번째 차이점은 전송 변환기는 다운스트림 연결이 서버에서 이미 승인된 경우에만 클라이언트가 시작한 연결 설정을 확인한다는 것입니다. 서버가 전송 변환기의 연결 설정 시도를 거부하면 클라이언트의 업스트림 연결도 거부됩니다. 이 기능은 서버의 가용성을 확인하거나 서버 선택에 대한 힌트로 연결 시간을 사용하는 애플리케이션에 중요합니다 \[RFC8305\].

네 번째 차이점은 0-RTT TCP 변환 프로토콜에서는 클라이언트가 DNS 이름이 아닌 대상 서버의 IP 주소/포트 번호만 지정할 수 있다는 것입니다. 우리는 SOCKS \[RFC1928\]에서와 같이 IP 주소 대신 원격 피어의 DNS 이름을 포함하는 대체 설계를 평가했습니다. 그러나 이 디자인은 DNS 확인 요청을 처리하고 관리하기 위해 전송 변환기에 추가 로드와 지연 증가를 유발하기 때문에 채택되지 않았습니다. 변환기에서의 이름 확인이 실패할 수 있거나\(예: \[RFC6731\]의 섹션 2.1에서 논의된 개인 이름\) 클라이언트의 확인 라이브러리에서 반환되는 이름\(예: \[RFC6731\]의 섹션 2.2\)과 일치하지 않을 수 있습니다.

---
## **4.  Architecture and Behaviors**
---
### **4.1.  Functional Elements**

변환 프로토콜은 세 가지 기능 요소를 고려합니다.

```text
   *  Clients

   *  Transport Converters

   *  Servers
```

전송 변환기는 하나의 업스트림 연결을 통해 하나의 다운스트림 연결로 또는 그 반대로 교환된 모든 데이터를 프록시하는 네트워크 기능입니다\(그림 2\). 따라서 전송 변환기는 하나의 업스트림 연결을 해당 다운스트림 연결에 연결하는 상태를 유지합니다.

Transport Converter의 양쪽\(외부 영역, 내부 영역\)에서 연결을 시작할 수 있습니다.

```text
                              |
                              :
                              |
                        +------------+
   Client <- upstream ->| Transport  |<- downstream -> Server
            connection  | Converter  |   connection
                        +------------+
                              |
               Internal realm : External realm
                              |

     Figure 2: A Transport Converter Proxies Data between Pairs of TCP
                                Connections
```

"클라이언트"는 내부 영역의 전송 변환기에 도달할 수 있는 호스트에 내장된 소프트웨어 인스턴스를 나타냅니다. "클라이언트"는 전송 변환기를 통해 연결\(나가는 연결이라고 함\)을 시작할 수 있습니다. 또한 "클라이언트"는 전송 변환기를 통해 들어오는 연결\(들어오는 연결이라고 함\)을 수락할 수 있습니다.

Transport Converter는 독립형 장치에 내장되거나 라우터에서 서비스로 활성화될 수 있습니다. 이러한 기능이 활성화되는 방식은 배포에 따라 다릅니다.

아키텍처에서는 하나 이상의 전송 변환기와 상호 작용하기 위해 클라이언트 호스트에 새 소프트웨어가 설치된다고 가정합니다. 또한 이 아키텍처에서는 특정 서버에서 지원하지 않는 경우에도 새로운 TCP 확장을 사용할 수 있습니다.

클라이언트는 이 문서의 범위를 벗어나는 수단을 통해 하나 이상의 전송 변환기의 이름 및/또는 주소와 이들이 지원하는 TCP 확장을 사용하여 구성됩니다. 구성된 전송 변환기 목록 중에서 전송 변환기를 선택하는 절차는 이 문서의 범위를 벗어납니다.

이 설계의 이점 중 하나는 업스트림 및 다운스트림 연결에서 다양한 전송 프로토콜 확장을 사용할 수 있다는 것입니다. 이는 특히 서버에서 널리 지원될 때까지 새로운 TCP 확장의 배포를 권장합니다.

아키텍처는 서버 측에서 어떤 것도 요구하지 않습니다.

SOCKS와 마찬가지로 이 아키텍처는 클라이언트와 서버 간의 엔드투엔드 TLS 연결\[RFC8446\]을 방해하지 않습니다\(그림 3\). 즉, Converter가 있는 경우 종단 간 TLS가 지원됩니다.

```text
       Client             Transport                Server
          |               Converter                  |
          |                   |                      |
          /==========================================\
         |            End-to-end TLS                  |
          \==========================================/
```

\* 클라이언트 간에 교환되는 TLS 메시지

- 서버가 표시되지 않습니다.

```text
             Figure 3: End-to-end TLS via a Transport Converter
```

종단 간 TLS 연결 외에도 변환 메시지를 교환하기 위해 클라이언트-변환기 연결 구간에서 TLS를 사용하는 것과 관련된 특정 고려 사항을 자세히 설명하는 것은 이 문서의 범위를 벗어납니다. 특히, \(1\) \[RFC8446\]의 섹션 2.3에서 논의된 0-RTT 데이터 모드가 재생 시 안전한지 여부에 대한 평가 및 \(2\) 해당 사용을 위한 프로파일 사양\(\[RFC8446\]의 부록 E.5\)이 범위.

---
### **4.2.  Theory of Operation**

높은 수준에서 전송 변환기의 목적은 피어가 이 확장을 지원하지 않더라도 경로의 하위 집합에서 특정 확장\(예: 다중 경로 TCP\)을 사용할 수 있도록 허용하는 것입니다. 이는 클라이언트가 전송 변환기와 다중 경로 TCP 연결\(Multipath TCP 연결에 속하는 패킷은 "==="로 표시됨\)을 시작하는 반면 전송 변환기는 서버와의 TCP 연결을 사용하는 그림 4에 설명되어 있습니다.

```text
       Client             Transport                Server
          |               Converter                  |
          |                   |                      |
          |==================>|--------------------->|
          |                   |                      |
          |<==================|<---------------------|
          |                   |                      |
         Multipath TCP packets     TCP packets

       Figure 4: An Example of 0-RTT Network-Assisted Outgoing MPTCP
                                 Connection
```

Transport Converter를 통해 설정된 연결에 속하는 패킷은 클라이언트와 서버 간에 직접 교환되는 패킷과 다른 경로를 따를 수 있습니다. 배포 시 특정 목적지에 도달하는 데 사용되는 전송 변환기의 위치를 ​​신중하게 선택하여 추가 지연 가능성을 최소화해야 합니다.

연결을 설정할 때 클라이언트는 로컬 정책에 따라 서버에 직접 연결하거나\(예: 서버를 향해 TCP SYN 전송\) 전송 변환기를 통해 연결을 생성할 수 있습니다. 후자의 경우\(즉, 변환 서비스가 사용됨\) 클라이언트는 Transport Converter를 향한 연결을 시작하고 연결 설정 패킷 내에서 서버의 IP 주소와 포트 번호를 나타냅니다. 이렇게 하면 전송 변환기가 추가 지연 없이 해당 서버에 대한 연결을 즉시 시작할 수 있습니다. 전송 변환기는 클라이언트에 연결을 확인하기 전에 서버가 연결 설정에 동의한다는 확인을 받을 때까지 기다립니다.

클라이언트는 연결 설정 지연을 최소화하기 위해 전송 변환기로 전송된 SYN의 페이로드에 서버의 대상 주소와 포트 번호를 배치합니다. Transport Converter는 함께 결합된 두 가지 연결을 유지합니다.

\* 업스트림 연결은 클라이언트와 전송 변환기 간의 연결입니다.

\* 다운스트림 연결은 전송 변환기와 서버 간의 연결입니다.

업스트림\(또는 다운스트림\) 연결을 통해 전송 변환기가 수신한 모든 사용자 데이터는 다운스트림\(또는 업스트림\) 연결을 통해 프록시됩니다.

그림 5는 전송 변환기를 통해 클라이언트가 나가는 TCP 연결을 설정하는 것을 보여줍니다.

- | 참고: 그림 5\(및 문서의 | 다른 그림\)의 괄호 안에 표시된 정보는 프로토콜 변환 | 섹션 6에 설명된 메시지입니다.

```text
                           Transport
       Client              Converter              Server
          |                   |                      |
          |SYN [->Server:port]|         SYN          |
          |------------------>|--------------------->|
          |<------------------|<---------------------|
          |    SYN+ACK [ ]    |        SYN+ACK       |
          |        ...        |          ...         |
```

- 그림 5: 전송 변환기를 통해 나가는 TCP 연결 설정

클라이언트는 전송 변환기로 향하는 SYN을 보냅니다. 이 SYN의 페이로드에는 서버의 주소와 포트 번호가 포함됩니다. 전송 변환기는 이 SYN에 즉시 응답하지 않습니다. 먼저 대상 서버를 향한 TCP 연결을 생성하려고 시도합니다. 이 업스트림 연결이 성공하면 전송 변환기는 SYN+ACK를 반환하여 클라이언트에 대한 연결 설정을 확인하고 바이트스트림의 첫 번째 바이트에는 서버와 협상된 TCP 옵션에 대한 정보가 포함됩니다. 또한 이 연결에 대한 상태 항목이 인스턴스화됩니다. 이 상태 항목은 변환기에서 연결에 속하는 후속 메시지를 처리하는 데 사용됩니다.

전송 변환기를 통해 인터넷에서 클라이언트로 연결을 설정할 수도 있습니다\(그림 6\). 이는 일반적으로 클라이언트가 특정 포트 번호를 수신하는 애플리케이션 서버를 호스팅하는 경우입니다. 변환기는 원격 호스트로부터 들어오는 SYN을 수신하면 해당 SYN의 대상 IP 주소와 대상 포트 번호에 대한 변환 서비스를 제공할 수 있는지 확인합니다. 전송 변환기는 예를 들어 원격 호스트와 클라이언트 사이의 경로에 있거나 클라이언트에 대한 주소 공유 서비스를 제공하기 때문에 이 SYN을 수신합니다\(\[RFC6269\]의 섹션 2\). 검사가 실패하면 변환기는 패킷을 자동으로 무시합니다. 확인이 성공하면 변환기는 자체 주소에서 구성된 TCP 옵션을 사용하여 클라이언트를 향한 TCP 연결을 시작하려고 시도합니다. 이 연결 시도에 해당하는 SYN에서 Transport Convert는 원격 호스트의 소스 주소와 포트 번호를 나타내는 TLV 메시지를 삽입합니다. 이 연결을 위해 변환기가 전송 세션 항목을 생성합니다. 그런 다음 SYN+ACK 및 ACK가 클라이언트, 변환기 및 원격 호스트 간에 교환되어 연결 설정을 확인합니다. 변환기는 전송 세션 항목을 사용하여 연결에 속한 패킷을 프록시합니다.

```text
     Transport              Remote
       Client              Converter             Host (RH)
          |                   |                      |
          |SYN [<-RH IP@:port]|         SYN          |
          |<------------------|<---------------------|
          |------------------>|--------------------->|
          |    SYN+ACK [ ]    |        SYN+ACK       |
          |        ...        |          ...         |
```

- 그림 6: 전송 변환기를 통해 들어오는 TCP 연결 설정

표준 TCP\(\[RFC0793\]의 섹션 3.4\)는 SYN 패킷이 페이로드 내부에 데이터를 전달하는 것을 허용하지만 3방향 핸드셰이크가 완료될 때까지 수신자가 이를 애플리케이션에 전달하는 것을 금지합니다. 애플리케이션이 TCP 핸드셰이크에서 데이터를 교환할 수 있도록 이 사양은 TCP Fast Open \[RFC7413\]과 유사한 접근 방식을 따르므로 SYN 패킷의 데이터가 전송 변환기 애플리케이션에 전달되도록 허용하여 제약 조건을 제거합니다.

\[RFC7413\]에서 논의된 것처럼 TCP 의미론에 대한 이러한 변경은 두 가지 문제를 제기합니다. 첫째, 중복된 SYN은 TCP에 의존하는 애플리케이션에 문제를 일으킬 수 있습니다. 특정 응용 프로그램이 영향을 받는지 여부는 해당 응용 프로그램 프로토콜의 세부 사항에 따라 다릅니다. 둘째, TCP는 SYN Flooding 공격\[RFC4987\]으로 어려움을 겪고 있습니다. TFO는 쿠키를 포함하는 TCP Fast Open 옵션을 사용하여 재생을 허용할 수 있는 응용 프로그램에 대한 이 두 가지 문제를 해결합니다. 그러나 이 옵션을 활용하면 제한된 TCP 헤더의 공간이 소모됩니다. 또한 \[RFC7413\]의 섹션 7.3에 명시된 대로 주소가 스푸핑될 수 없고 전송 변환기가 일련의 전송만 제공하는 네트워크와 같은 추가 보안 위험을 생성하지 않고 SYN 패킷의 페이로드를 허용할 수 있는 상황이 있습니다. 이 주소로 식별되는 호스트입니다.

이러한 이유로 이 사양에서는 클라이언트가 전송 변환기를 향해 연결 설정 패킷을 보낼 때 TCP Fast Open 옵션의 사용을 요구하지 않습니다. 변환 프로토콜에는 TCP 헤더의 공간을 소비하지 않고 TCP Fast Open 옵션과 유사한 보호를 제공하는 선택적 쿠키 TLV가 포함되어 있습니다. 또한 이 설계를 통해 \[RFC7413\]보다 긴 쿠키를 사용할 수 있습니다.

어떤 이유로든\(과도한 재전송, RST 세그먼트 수신 등\) 다운스트림\(또는 업스트림\) 연결이 실패하는 경우 변환기는 업스트림\(또는 다운스트림\) 연결을 강제로 해제하여 반응합니다. 특히 하드 오류를 나타내는 ICMP 오류 메시지가 다운스트림 연결에서 수신되면 변환기는 클라이언트에 전송하는 대상 도달 불가 오류 TLV\(섹션 6.2.8 참조\)에서 해당 ICMP 메시지의 코드 필드를 에코합니다. 다운스트림 연결에서 소프트 오류를 ​​나타내는 ICMP 오류 메시지가 수신되면 변환기는 해당 데이터가 확인되거나 연결 시간이 초과될 때까지 해당 데이터를 재전송합니다. ICMP 소프트 오류와 하드 오류의 분류는 \[RFC5461\]의 표 1에 나와 있습니다.

업스트림 연결이 FIN 세그먼트 교환으로 끝나는 경우에도 동일한 추론이 적용됩니다. 이 경우 변환기는 FIN 세그먼트를 사용하여 다운스트림 연결도 종료합니다. FIN 세그먼트 교환으로 다운스트림 연결이 종료되면 변환기는 업스트림 연결의 정상적인 종료를 시작해야 합니다.

---
### **4.3.  Data Processing at the Transport Converter**

섹션 4.2에서 언급했듯이 전송 변환기는 업스트림 연결\(즉, 클라이언트와 전송 변환기 사이\)과 다운스트림 연결\(즉, 전송 변환기와 서버 사이\) 사이에서 TCP 프록시 역할을 합니다.

제어 메시지\(즉, 섹션 6에서 논의된 변환 메시지\)는 두 TCP 연결 사이에서 프록시를 수행할 수 있도록 전송 변환기에 상태\(전송 세션 항목이라고 함\)를 설정합니다.

전송 변환기는 전송 세션 항목을 사용하여 연결에 속한 패킷을 프록시합니다. TCP 연결을 위한 전송 세션 항목의 구현 예가 그림 7에 나와 있습니다.

```text
                      (C,c) <--> (T,t), (S,s), Lifetime

              Figure 7: An Example of Transport Session Entry

   Where:
```

\* C와 c는 클라이언트가 업스트림 연결을 위해 사용하는 소스 IP 주소와 소스 포트 번호입니다.

\* S와 s는 서버의 IP 주소와 포트 번호입니다.

\* T 및 t는 전송 변환기가 연결을 프록시하기 위해 사용하는 소스 IP 주소 및 소스 포트 번호입니다.

\* 수명은 변환기가 할당한 항목의 남은 수명을 추적하는 타이머입니다. 타이머가 만료되면 항목이 삭제됩니다.

클라이언트는 변환 서비스에 적합한 연결에 바인딩된 패킷을 프로비저닝된 전송 변환기 및 대상 포트 번호로 보냅니다. 이는 제어 메시지와 데이터 모두에 적용됩니다. 추가 정보는 섹션 6에 설명된 대로 변환 메시지를 통해 클라이언트에 의해 전송 변환기에 제공됩니다. 사용자 데이터는 SYN 또는 비SYN 메시지에 포함될 수 있습니다. 사용자 데이터는 변환 메시지\(섹션 6.1\)의 변환 고정 헤더로 인해 전송 변환기에 의한 변환 TLV와 명확하게 구별됩니다. 이러한 변환 TLV는 전송 변환으로 향하므로 두 연결 사이를 프록시할 때 전송 변환기에 의해 제거됩니다.

클라이언트와 전송 변환기 간의 기존 연결에 속하는 패킷을 수신하면 변환기는 해당 전송 세션 항목에 저장된 정보를 사용하여 사용자 데이터를 서버로 프록시합니다. 예를 들어, 그림 7을 참조하면 전송 변환기는 소스 전송 주소로 \(T,t\)를 사용하고 대상 전송 주소로 \(S,s\)를 사용하여 다운스트림 \(C,c\)에서 수신된 데이터를 프록시합니다.

서버에서 전송된 데이터에 대해서도 비슷한 프로세스가 발생합니다. 변환기는 TCP 프록시 역할을 하며 전송 세션 항목에 저장된 정보를 기반으로 클라이언트에 데이터를 보냅니다. 변환기는 업스트림 연결을 다운스트림 연결과 바인딩하는 데 사용되는 상태 항목과 수명을 연결합니다.

클라이언트와 전송 변환기 사이에 다중 경로 TCP가 사용되면 변환기는 각 다중 경로 TCP 연결에 대해 더 많은 상태\(예: 하위 흐름에 대한 정보\)를 유지합니다. 위에 설명된 절차는 변환기가 서브플로우의 설정/종료를 관리하고 설정된 패킷 중에서 패킷을 예약해야 한다는 점을 제외하면 계속 적용됩니다. 이러한 작업은 다중 경로 TCP 구현의 일부입니다. 이는 바이트스트림 시작 부분의 변환 메시지만 처리하는 변환 프로토콜과 독립적입니다.

전송 변환기는 주소 보존 모드\(즉, 변환기가 소스 IP 주소\(예: C==T\)를 다시 쓰지 않음\) 또는 주소 공유 모드\(즉, 전송 변환기가 서비스하는 모든 클라이언트 간에 주소 풀을 공유함\)에서 작동할 수 있습니다. 변환기\(즉, C!=T\)\); 자세한 내용은 섹션 4.4를 참조하세요. Transport Converter에서 사용할 동작은 배포에 따라 다릅니다. 주소 공유 모드가 활성화된 경우 전송 변환기는 \[RFC6888\]의 REQ-2를 준수해야 하며, 이는 "페어링됨"\(\[RFC4787\]의 섹션 4.1에 정의된 대로\)의 기본 "IP 주소 풀링" 동작을 의미해야 합니다. . 이 동작은 소스 주소가 일정하게 유지되는 데 의존하는 애플리케이션이 중단되는 것을 방지하기 위한 것입니다.\(MUST\)

---
### **4.4.  Address Preservation vs. Address Sharing**

전송 변환기에는 나가는 패킷의 소스 주소 처리와 관련하여 채택할 동작에 대한 지침이 제공됩니다. 다음 하위 섹션에서는 설명을 위해 두 가지 배포 모델을 설명합니다. 권장 사항을 작성하는 것은 이 문서의 범위를 벗어납니다.

---
#### **4.4.1.  Address Preservation**

이 모델에서 전송 변환기에 의해 서버로 프록시된 패킷의 가시적 소스 IP 주소는 최종 호스트\(클라이언트\)의 IP 주소입니다. 전송 변환기에는 전용 IP 주소 풀이 제공되지 않지만 전송 변환기는 클라이언트와 서버 사이의 경로에 있습니다.

다중 경로 TCP의 경우 전송 변환기는 초기 하위 흐름을 설정할 때 클라이언트가 사용하는 소스 IP 주소를 유지합니다. 보조 하위 흐름으로 전달되는 데이터는 초기 하위 흐름의 소스 IP 주소를 사용하여 전송 변환기에 의해 프록시됩니다. 주소 보존이 포함된 프록시 다중 경로 TCP 연결의 예가 그림 8에 나와 있습니다.

```text
                                         Transport
          Client                        Converter          Server

           @:C1,C2                        @:Tc                @:S
              ||                            |                  |
              |src:C1     SYN         dst:Tc|src:C1       dst:S|
              |-------MPC [->S:port]------->|-------SYN------->|
              ||                            |                  |
              ||dst:C1                src:Tc|dst:C1       src:S|
              |<---------SYN/ACK------------|<-----SYN/ACK-----|
              ||                            |                  |
              |src:C1                 dst:Tc|src:C1       dst:S|
              |------------ACK------------->|-------ACK------->|
              |                             |                  |
              |src:C2          ...    dst:Tc|       ...        |
              ||<-----Secondary Subflow---->|src:C1       dst:S|
              ||                            |-------data------>|
              |               ..            |    ...           |
```

범례: Tc: 내부 영역의 전송 변환기가 사용하는 IP 주소입니다.

```text
                 Figure 8: Example of Address Preservation
```

전송 변환기는 들어오는 트래픽의 전달 경로에 있어야 합니다. 프록시된 연결과 프록시되지 않은 연결 모두에 동일한\(대상\) IP 주소가 사용되기 때문에 전송 변환기는 패킷에 대해 일치하는 항목이 없는 경우 가로채는 들어오는 패킷을 삭제해서는 안 됩니다. 달리 명시적으로 구성되지 않는 한 이러한 패킷은 로컬 전달 테이블의 지침에 따라 전달됩니다.

---
#### **4.4.2.  Address/Prefix Sharing**

전역 IPv4 주소 풀은 적용할 주소 공유 비율에 대한 가능한 지침과 함께 전송 변환기에 제공됩니다\(\[RFC6269\]의 부록 B 참조\). 따라서 주소는 여러 클라이언트 간에 공유됩니다.

마찬가지로 소스 IPv6 접두사 \[RFC6296\]를 다시 작성하면 들어오는 IPv6 트래픽을 적절한 전송 변환기로 쉽게 리디렉션하는 데 사용할 수 있습니다. 그런 다음 이 목적을 위해 IPv6 접두사 풀이 전송 변환기에 프로비저닝됩니다.

해당 풀의 주소로 향하는 트래픽이 적절한 전송 변환기에 의해 차단되도록 적절한 전달 정책이 시행됩니다. 섹션 4.4.1과 달리 전송 변환기는 활성 전송 세션 항목과 일치하지 않는 수신 패킷을 삭제합니다.

예가 그림 9에 나와 있습니다.

```text
                                        Transport
         Client                         Converter          Server

            @:C                        @:Tc|Te                @:S
             |                             |                  |
             |src:C                  dst:Tc|src:Te       dst:S|
             |-------SYN [->S:port]------->|-------SYN------->|
             |                             |                  |
             |dst:C                  src:Tc|dst:Te       src:S|
             |<---------SYN/ACK------------|<-----SYN/ACK-----|
             |                             |                  |
             |src:C                  dst:Tc|src:Te       dst:S|
             |------------ACK------------->|-------ACK------->|
             |                             |                  |
             |              ...            |    ...           |
```

범례: Tc: 내부 영역의 전송 변환기가 사용하는 IP 주소입니다. Te: 외부 영역의 전송 변환기가 사용하는 IP 주소입니다.

```text
                         Figure 9: Address Sharing
```

---
## **5.  Sample Examples**
---
### **5.1.  Outgoing Converter-Assisted Multipath TCP Connections**

예를 들어 변환 프로토콜이 다중 경로 TCP 배포에 어떻게 도움이 되는지 생각해 보겠습니다. 클라이언트와 전송 변환기 모두 다중 경로 TCP를 지원한다고 가정하지만 서버가 다중 경로 TCP를 지원하는지 여부에 따라 두 가지 다른 경우를 고려합니다.

참고로 다중 경로 TCP 연결은 클라이언트가 전송한 SYN에 MP\_CAPABLE\(MPC\) 옵션을 배치하여 생성됩니다.

그림 10에서는 서버가 다중 경로 TCP를 지원하지 않는 경우 전송 변환기의 작동을 설명합니다.

```text
                           Transport
       Client              Converter              Server
          |SYN, MPC           |                      |
          |[->Server:port]    |         SYN, MPC     |
          |------------------>|--------------------->|
          |<------------------|<---------------------|
          |  SYN+ACK,MPC [.]  |      SYN+ACK         |
          |------------------>|--------------------->|
          |     ACK, MPC      |          ACK         |
          |        ...        |          ...         |
```

- 그림 10: 다중 경로 TCP를 지원하지 않는 서버를 향한 전송 변환기를 통한 다중 경로 TCP 연결 설정

클라이언트는 MP\_CAPABLE 옵션\(그림 10의 MPC\)과 함께 SYN을 전송하여 다중 경로 TCP 연결을 시작하려고 시도합니다. SYN에는 전송 변환기가 추출하여 이 서버에 대한 다중 경로 TCP 연결을 시작하는 데 사용되는 대상 서버의 주소와 포트 번호가 포함됩니다. 서버는 다중 경로 TCP를 지원하지 않으므로 MP\_CAPABLE 옵션이 포함되지 않은 SYN+ACK로 응답합니다. 전송 변환기는 서버와의 연결이 다중 경로 TCP를 지원하지 않음을 확인하고 서버에서 수신한 확장 TCP 헤더를 클라이언트로 반환합니다.

어떤 이유로 TCP 연결이 재설정되면 변환기는 MP\_FASTCLOSE를 전송하여 다중 경로 TCP 연결을 해제합니다. 마찬가지로 다중 경로 TCP 연결이 DATA\_FIN 전송으로 종료되면 변환기는 FIN 세그먼트를 사용하여 TCP 연결을 종료합니다. 참고로 다중 경로 TCP의 경우 RST는 하위 흐름의 범위만 가지며 관련 하위 흐름만 닫고 나머지 하위 흐름에는 영향을 주지 않습니다. 변환기는 다중 경로를 통해 RST를 수신해도 다운스트림 TCP 연결을 종료하지 않습니다. 서브플로우.

그림 11에서는 다중 경로 TCP를 지원하는 서버를 고려합니다. 이 경우 MP\_CAPABLE 옵션을 사용하여 Transport Converter가 보낸 SYN에 응답합니다. 이 SYN+ACK를 수신하면 전송 변환기는 클라이언트에 대한 연결 설정을 확인하고 서버가 다중 경로 TCP를 지원함을 클라이언트에 나타냅니다. 이 정보를 통해 클라이언트는 서버가 다중 경로 TCP를 지원한다는 것을 발견했습니다. 이렇게 하면 클라이언트가 이 서버를 향해 시작하는 후속 다중 경로 TCP 연결에 대해 전송 변환기를 우회할 수 있습니다.

```text
                           Transport
       Client              Converter              Server
          |SYN, MPC           |                      |
          |[->Server:port]    |         SYN, MPC     |
          |------------------>|--------------------->|
          |<------------------|<---------------------|
          |SYN+ACK, MPC       |      SYN+ACK, MPC    |
          |[MPC supported]    |                      |
          |------------------>|--------------------->|
          |     ACK, MPC      |        ACK, MPC      |
          |        ...        |          ...         |
```

- 그림 11: MPTCP 가능 서버를 향한 변환기를 통한 다중 경로 TCP 연결 설정

---
### **5.2.  Incoming Converter-Assisted Multipath TCP Connection**

들어오는 변환기 지원 다중 경로 TCP 연결의 예는 그림 12에 나와 있습니다. 원격 호스트에서 들어오는 연결을 지원하기 위해 클라이언트는 포트 제어 프로토콜\(PCP\) \[RFC6887\]을 사용하여 전송 변환기에 동적 매핑을 생성하도록 지시할 수 있습니다. . 이러한 매핑은 전송 변환기가 클라이언트로 향하는 수신 TCP 연결을 가로채서 다중 경로 TCP 연결로 변환하는 데 사용됩니다.

일반적으로 클라이언트는 내부 IP 주소와 내부 포트 번호에 대한 명시적인 TCP 매핑을 생성하도록 요청하는 PCP 요청을 변환기에 보냅니다. 변환기는 내부 IP 주소, 내부 포트 번호, 외부 IP 주소 및 외부 포트 번호에 대한 TCP 매핑을 생성하여 요청을 수락합니다. 외부 IP 주소, 외부 포트 번호 및 할당된 수명은 PCP 응답을 통해 클라이언트에 다시 반환됩니다. 외부 IP 주소와 외부 포트 번호는 원격 호스트가 변환기를 통해 클라이언트에 대한 TCP 연결을 시작할 수 있도록 대역 외 메커니즘을 사용하여 클라이언트\(또는 사용자\)에 의해 광고됩니다. 외부 정보와 내부 정보가 동일할 수 있다는 점에 유의하세요.

그런 다음 변환기가 들어오는 SYN을 수신하면 매핑 테이블을 확인하여 해당 SYN의 대상 IP 주소 및 대상 포트와 일치하는 활성 매핑이 있는지 확인합니다. 항목이 없으면 변환기는 메시지를 자동으로 무시합니다. 항목이 발견되면 변환기는 MP\_CAPABLE 옵션과 Connect TLV를 SYN 패킷에 삽입하고 원본 IP 주소를 해당 IP 주소 중 하나에 다시 쓰고 최종적으로 대상 IP 주소와 포트 번호를 저장된 정보에 따라 다시 씁니다. 매핑. 그런 다음 SYN+ACK 및 ACK가 클라이언트와 변환기 간에 교환되어 초기 하위 흐름의 설정을 확인합니다. 클라이언트는 일반적인 다중 경로 TCP 절차에 따라 새 하위 흐름을 추가할 수 있습니다.

```text
                           Transport             Remote
       Client              Converter              Host
         |                     |                    |
         |<--------------------|<-------------------|
         |SYN, MPC             |         SYN        |
         |[Remote Host:port]   |                    |
         |-------------------->|------------------->|
         |      SYN+ACK, MPC   |       SYN+ACK      |
         |<--------------------|<-------------------|
         |       ACK, MPC      |           ACK      |
         |        ...          |          ...       |
```

- 그림 12: 전송 변환기를 통해 들어오는 다중 경로 TCP 연결 설정

들어오는 연결\(즉, PCP 메시지를 모방하는 TLV\)을 관리하기 위해 특정 변환 TLV를 정의하는 것은 이 문서의 범위를 벗어납니다. 이러한 TLV는 별도의 문서에서 정의할 수 있습니다.

---
## **6.  The Convert Protocol (Convert)**

이 섹션에서는 클라이언트와 전송 변환기 간에 교환되는 변환 프로토콜\(줄여서 변환\) 메시지를 정의합니다.

전송 변환기는 클라이언트의 변환 메시지에 대해 특정 TCP 포트 번호를 수신합니다. 해당 포트 번호는 관리자가 구성합니다. 정책이 없으면 전송 변환기는 변환 TLV가 없는 SYN을 자동으로 무시해야 합니다.\(SHOULD\)

변환 메시지는 SYN, SYN+ACK 또는 ACK로만 나타날 수 있습니다.

변환 메시지는 바이트스트림의 첫 번째 바이트로 포함되어야 합니다. 모든 변환 메시지는 32비트 길이의 고정 헤더\(섹션 6.1\)로 시작하고 그 뒤에 하나 이상의 변환 TLV\(유형, 길이, 값\)\(섹션 6.2\)가 옵니다.\(MUST\)

초기 SYN 메시지의 페이로드에 사용자 데이터가 포함된 경우\(예: \[RFC7413\] 참조\) SYN을 생성할 때 해당 데이터는 TLV 변환 바로 뒤에 배치되어야 합니다.\(MUST\)

다른 메시지 형식이 필요한 경우 새 TLV를 정의하거나 버전 번호를 추가하여 프로토콜을 확장할 수 있습니다. 향후 버전이 정의되었지만 메시지 형식이 다른 경우 섹션 6.2.8\("지원되지 않는 버전" 참조\)에 정의된 버전 협상 절차는 두 피어가 모두 지원하는 버전에 동의한다는 의미입니다.

- | 구현 참고 사항 1: 여러 구현자가 우려를 표명함 | TFO의 사용에 대해. 참고로 Fast Open Cookie | 오픈 서버에 영향을 미치는 일부 공격 시나리오로부터 보호 | 웹 서버처럼요. 변환 프로토콜은 다르며 | \[RFC7413\]에서 논의된 다양한 보호 방법이 있습니다 | 그러한 공격으로부터. 내부에서 Fast Open Cookie를 사용하는 대신 | 확장된 공간에서 귀중한 공간을 소비하는 TCP 옵션 | TCP 헤더인 변환 프로토콜은 | SYN 페이로드에 배치되는 쿠키입니다. 이는 | 환경에서 Fast Open Cookie와 동일한 수준의 보호 | 그러한 보호가 필요합니다. | | 구현 참고 사항 2: 오류 메시지는 RST에 포함되지 않습니다 | 하지만 바이트스트림으로 전송되었습니다. 구현자는 다음과 같이 표시했습니다. | 일부 플랫폼에서는 클라이언트에서 RST를 처리하는 것이 어려웠습니다. | 이 디자인은 클라이언트 구현을 단순화합니다.

---
### **6.1.  The Convert Fixed Header**

변환 프로토콜은 설정된 각 연결을 통해 클라이언트와 전송 변환기 모두에서 보낸 32비트 길이의 고정 헤더를 사용합니다. 이 헤더는 사용된 프로토콜 버전과 변환 메시지의 길이를 모두 나타냅니다.

클라이언트와 전송 변환기는 그림 13에 표시된 고정 크기 헤더를 바이트스트림의 처음 4바이트로 전송해야 합니다.\(MUST\)

```text
                        1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +---------------+---------------+-------------------------------+
   |  Version      |  Total Length |          Magic Number         |
   +---------------+---------------+-------------------------------+

                    Figure 13: The Convert Fixed Header
```

버전은 8비트 부호 없는 정수 값으로 인코딩됩니다. 이 문서는 버전 1을 지정합니다. 버전 0은 이 문서에 의해 예약되어 있으므로 사용해서는 안 됩니다.\(MUST NOT\)

| 참고: 이 사양의 초기 버전은

- | 전용 포트 번호이지만 IP 주소에만 | 의존합니다. 변환기. |와 함께 버전 필드에 비트가 설정되어 있습니다. 총 길이 필드는 SYN의 데이터를 다음과 같이 잘못 해석하는 것을 방지합니다. TLV를 변환합니다. 특정 | 서비스 포트에서는 해당 제약이 완화되었습니다. 버전 0은 | 작동하지만 기존 구현에서는 이미 버전 1을 사용하고 있습니다. | 버전 0의 사용은 예약된 상태로 유지됩니다.

총 길이는 헤더를 포함하여 변환 메시지에서 소비되는 바이트스트림의 32비트 단어 수입니다. 총 길이도 8비트 부호 없는 정수이므로 해당 메시지는 1020바이트 이상의 데이터를 사용할 수 없습니다. 이는 전송 변환기가 처리해야 하는 바이트 수를 제한합니다. 총 길이 0은 유효하지 않으며 그러한 총 길이를 가진 헤더를 수신하면 연결을 재설정해야 합니다.\(MUST\)

매직 넘버 필드는 0x2263으로 설정되어야 합니다. 이 필드는 변환 TLV에서 애플리케이션이 제공하는 모든 데이터를 명확하게 구별하기 위해 프로토콜을 더욱 강화하기 위한 것입니다.\(MUST\)

총 길이 필드는 바이트스트림 시작 부분에 변환 TLV를 전달하는 32비트 단어의 수를 명확하게 표시합니다.

---
### **6.2.  Convert TLVs**
---
#### **6.2.1.  Generic Convert TLV Format**

변환 프로토콜은 그림 14에 설명된 일반 TLV 형식을 사용하여 인코딩된 가변 길이 메시지를 사용합니다.

변환 프로토콜에서 사용하는 모든 TLV의 길이는 항상 4바이트의 배수입니다. 모든 TLV는 32비트 경계에 정렬됩니다. 모든 TLV 필드는 네트워크 바이트 순서를 사용하여 인코딩됩니다.

```text
                           1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +---------------+---------------+-------------------------------+
      |     Type      |     Length    |             Value  ...        |
      +---------------+---------------+-------------------------------+
      //              ...   (optional) Value                         //
      +---------------------------------------------------------------+

                   Figure 14: Convert Generic TLV Format
```

길이 필드에는 유형, 길이 및 값 필드가 포함됩니다. 32비트 워드 단위로 표현됩니다. 필요한 경우 TLV 길이가 32비트의 배수가 되도록 Value를 0으로 채워야 합니다.\(MUST\)

주어진 TLV는 연결 시 한 번만 나타나야 합니다. 클라이언트가 변환 연결을 통해 동일한 TLV의 두 개 이상의 인스턴스를 수신하는 경우 연결된 TCP 연결을 재설정해야 합니다. 변환기가 변환 연결을 통해 동일한 TLV의 두 개 이상의 인스턴스를 수신하는 경우 잘못된 메시지 오류 TLV를 반환하고 관련 TCP 연결을 닫아야 합니다.\(MUST, MUST, MUST\)

---
#### **6.2.2.  Summary of Supported Convert TLVs**

이 문서에서는 다음과 같은 변환 TLV를 지정합니다.

```text
         +======+======+==========+==============================+
         | Type | Hex  | Length   | Description                  |
         +======+======+==========+==============================+
         | 1    | 0x1  | 1        | Info TLV                     |
         +------+------+----------+------------------------------+
         | 10   | 0xA  | Variable | Connect TLV                  |
         +------+------+----------+------------------------------+
         | 20   | 0x14 | Variable | Extended TCP Header TLV      |
         +------+------+----------+------------------------------+
         | 21   | 0x15 | Variable | Supported TCP Extensions TLV |
         +------+------+----------+------------------------------+
         | 22   | 0x16 | Variable | Cookie TLV                   |
         +------+------+----------+------------------------------+
         | 30   | 0x1E | Variable | Error TLV                    |
         +------+------+----------+------------------------------+
```

- 표 1: 변환 프로토콜에서 사용되는 TLV

유형 0x0은 예약된 값입니다. 클라이언트가 0x0 유형의 TLV를 수신하면 관련 TCP 연결을 재설정해야 합니다. 변환기가 0x0 유형의 TLV를 수신하는 경우 지원되지 않는 메시지 오류 TLV를 반환하고 관련 TCP 연결을 닫아야 합니다.\(MUST, MUST\)

클라이언트는 일반적으로 전송 변환기와 설정된 첫 번째 연결에서 해당 기능을 알아보기 위해 Info TLV\(섹션 6.2.3\)를 보냅니다. 클라이언트가 전송 변환기를 호출할 권한이 있다고 가정하면 후자는 지원되는 TCP 확장 TLV\(6.2.4절\)로 응답합니다.

클라이언트는 Connect TLV\(6.2.5항\)를 사용하여 서버에 대한 연결 설정을 요청할 수 있습니다. 최종 서버와의 연결이 설정되면 전송 변환기는 확장 TCP 헤더 TLV\(섹션 6.2.6\)로 응답합니다. 그렇지 않은 경우 전송 변환기는 오류 TLV\(섹션 6.2.8\)를 반환한 다음 연결을 닫아야 합니다. 전송 변환기는 오류 TLV가 클라이언트에 도달할 수 있도록 오류 감지 후 즉시 RST를 보내서는 안 됩니다. 나중에 설명하는 것처럼 클라이언트는 오류 TLV 수신 여부에 관계없이 RST를 보냅니다.\(MUST, MUST NOT\)

---
#### **6.2.3.  The Info TLV**

Info TLV\(그림 15\)는 Transport Converter가 지원하는 TCP 확장을 요청하기 위해 클라이언트가 보낼 수 있는 선택적 TLV입니다. 일반적으로 클라이언트가 해당 기능을 알아보기 위해 전송 변환기를 사용하여 설정하는 첫 번째 연결에서 전송됩니다. 클라이언트가 전송 변환기를 호출할 자격이 있다고 가정하면 후자는 섹션 6.2.4에 설명된 지원되는 TCP 확장 TLV로 응답합니다.

```text
                        1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +---------------+---------------+-------------------------------+
   |     Type=0x1  |     Length    |             Zero              |
   +---------------+---------------+-------------------------------+

                          Figure 15: The Info TLV
```

---
#### **6.2.4.  Supported TCP Extensions TLV**

지원되는 TCP 확장 TLV\(그림 16\)는 전송 변환기에서 변환 서비스를 제공하는 TCP 옵션을 알리는 데 사용됩니다. 전송 변환기는 나가는 SYN에서 지원하는 TCP 옵션을 이 목록에 포함해야 합니다.\(SHOULD\)

지원되는 각 TCP 옵션은 IANA \[IANA-CONVERT\]에서 관리하는 "TCP\(전송 제어 프로토콜\) 매개변수" 레지스트리에 나열된 해당 TCP 옵션 종류로 인코딩됩니다. 할당되지 않음 필드는 전송 변환기에 의해 0으로 설정되어야 하며 클라이언트에서는 무시되어야 합니다.\(MUST\)

```text
                         1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +---------------+---------------+-------------------------------+
    |     Type=0x15 |     Length    |           Unassigned          |
    +---------------+---------------+-------------------------------+
    |     Kind #1   |     Kind #2   |           ...                 |
    +---------------+---------------+-------------------------------+
    /                              ...                              /
    /                                                               /
    +---------------------------------------------------------------+

                Figure 16: The Supported TCP Extensions TLV
```

\[RFC0793\]에 정의된 TCP 옵션 종류 1과 2는 모든 TCP 구현에서 지원되므로 이 목록에 표시되어서는 안 됩니다.\(MUST NOT\)

지원되는 TCP 확장 목록은 32비트 경계에서 끝나도록 0으로 채워집니다.

예를 들어 전송 변환기가 다중 경로 TCP를 지원하는 경우 Info TLV에 대한 응답으로 반환되는 지원되는 TCP 확장 TLV에 Kind=30이 표시됩니다.

---
#### **6.2.5.  Connect TLV**

Connect TLV\(그림 17\)는 Transport Converter를 통해 연결 설정을 요청하는 데 사용됩니다. 이 연결은 클라이언트로부터 또는 클라이언트로 이루어질 수 있습니다.

원격 피어 포트 및 원격 피어 IP 주소 필드에는 나가는 연결에 대한 서버의 대상 포트 번호와 IP 주소가 포함됩니다. Transport Converter를 통해 서비스되는 클라이언트로 향하는 수신 연결의 경우, 이 필드는 Transport Converter가 서버에서 받은 SYN 패킷의 소스 포트 번호와 IP 주소를 전달합니다.

원격 피어 IP 주소는 IPv6 주소로 인코딩되어야 합니다. IPv4 주소는 \[RFC4291\]에 정의된 IPv4 매핑 IPv6 주소 형식을 사용하여 인코딩되어야 합니다. 또한 원격 피어 IP 주소 필드에는 멀티캐스트, 브로드캐스트 또는 호스트 루프백 주소\[RFC6890\]가 포함되어서는 안 됩니다. 변환기가 유효하지 않은 주소가 포함된 연결 TLV를 수신하는 경우 잘못된 메시지 오류 TLV로 응답하고 관련 TCP 연결을 닫아야 합니다.\(MUST, MUST, MUST NOT, MUST\)

Connect TLV는 길이에 따라 두 가지 유형으로 구분됩니다. \(1\) Base Connect TLV는 길이가 5\(즉, 20바이트\)로 설정되어 있고 원격 주소와 원격 포트를 포함합니다\(그림 17\). 확장 연결 TLV는 20바이트를 초과하며 선택적 TCP 옵션 필드도 포함합니다\(그림 18\). 이 필드는 서버에 대한 특정 TCP 옵션 광고를 요청하는 데 사용됩니다.

```text
                         1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +---------------+---------------+-------------------------------+
    |     Type=0xA  |     Length    |      Remote Peer Port         |
    +---------------+---------------+-------------------------------+
    |                                                               |
    |         Remote Peer IP Address (128 bits)                     |
    |                                                               |
    |                                                               |
    +---------------------------------------------------------------+

                      Figure 17: The Base Connect TLV

                         1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +---------------+---------------+-------------------------------+
    |     Type=0xA  |     Length    |      Remote Peer Port         |
    +---------------+---------------+-------------------------------+
    |                                                               |
    |         Remote Peer IP Address (128 bits)                     |
    |                                                               |
    |                                                               |
    +---------------------------------------------------------------+
    /                          TCP Options (Variable)               /
    /                              ...                              /
    +---------------------------------------------------------------+

                    Figure 18: The Extended Connect TLV
```

TCP 옵션 필드는 TCP 옵션 필드 목록을 전달하는 가변 길이 필드입니다\(그림 19\). 각 TCP 옵션 필드는 2+n 바이트의 블록으로 인코딩됩니다. 여기서 첫 번째 바이트는 TCP 옵션 종류이고 두 번째 바이트는 \[RFC0793\]에 지정된 TCP 옵션의 길이입니다. TCP 옵션 길이의 최소값은 2입니다. 길이 하위 필드를 포함하지 않는 TCP 옵션, 즉 \[RFC0793\]에 정의된 옵션 유형 0\(EOL\) 및 1\(NOP\)은 TCP 옵션 내에 배치되어서는 안 됩니다. Connect TLV의 필드입니다. 선택적 값 필드에는 TCP 옵션의 가변 길이 부분이 포함되어 있습니다. 길이가 2이면 값 필드가 없음을 나타냅니다. TCP 옵션 필드는 항상 0으로 채워진 후 32비트 경계에서 끝납니다.\(MUST NOT\)

```text
                        1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +---------------+---------------+---------------+---------------+
    |  TCPOpt kind  | TCPOpt Length | Value  (opt)  |  ....         |
    +---------------+---------------+---------------+---------------+
    |                             ....                              |
    +---------------------------------------------------------------+
    |                              ...                              |
    +---------------------------------------------------------------+

                      Figure 19: The TCP Options Field
```

기본 연결 TLV를 수신하고 정책\(예: 속도 제한\)이나 리소스 고갈 조건이 없으면 전송 변환기는 포함된 주소와 포트에 대한 연결 설정을 시도합니다. 전송 변환기는 이 연결을 설정하기 위해 기본적으로 로컬 정책에 해당하는 TCP 옵션을 사용해야 합니다.\(MUST\)

확장 연결 TLV를 수신하면 전송 변환기는 먼저 TCP 옵션 필드에 나열된 TCP 옵션을 지원하는지 여부를 확인합니다. 그렇지 않은 경우 "지원되지 않는 TCP 옵션"\(섹션 6.2.8\)으로 설정된 오류 TLV를 반환합니다. 위의 확인이 성공하고 속도 제한 정책이나 리소스 고갈 조건이 없으면 전송 변환기는 포함된 주소와 포트에 대한 연결 설정을 시도해야 합니다. TCP 옵션 하위 필드에 나열된 옵션과 로컬 정책에 따라 사용했을 TCP 옵션을 서버에 보내는 SYN에 포함되어야 합니다. 선택적 값 없이 TCP 옵션 필드에 포함된 TCP 옵션의 경우 전송 변환기는 자체 값을 생성해야 합니다. TCP 옵션 필드에 선택적 값이 포함된 TCP 옵션의 경우 원격 서버로 전송되는 SYN의 전체 옵션을 복사해야 합니다. 이 절차는 TFO를 염두에 두고 설계되었습니다. 특히, 이 절차를 통해 클라이언트와 서버 간에 Fast Open Cookie를 성공적으로 교환할 수 있습니다. 다양한 유형의 TCP 옵션에 대한 자세한 내용은 섹션 7을 참조하세요.\(MUST, MUST, MUST, MUST\)

전송 변환기는 다양한 이유로 Connect TLV 요청을 거부할 수 있습니다\(예: 인증 실패, 리소스 부족, 잘못된 주소 유형 또는 지원되지 않는 TCP 옵션\). 발생한 오류를 나타내는 오류 메시지가 요청 클라이언트에 반환됩니다\(섹션 6.2.8\). 서비스 거부 공격을 방지하려면 클라이언트로 전송되는 오류 메시지의 속도를 제한해야 합니다.\(SHOULD\)

---
#### **6.2.6.  Extended TCP Header TLV**

확장 TCP 헤더 TLV\(그림 20\)는 전송 변환기가 SYN+ACK 패킷에서 서버가 반환한 TCP 옵션을 클라이언트에 반환하는 데 사용됩니다. 클라이언트가 확장 연결 TLV를 전송하고 서버가 연결을 수락한 경우 전송 변환기는 이 TLV를 반환해야 합니다.\(MUST\)

```text
                         1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +---------------+---------------+-------------------------------+
    |     Type=0x14 |     Length    |           Unassigned          |
    +---------------+---------------+-------------------------------+
    /               Returned Extended TCP header                    /
    /                              ...                              /
    +---------------------------------------------------------------+

                   Figure 20: The Extended TCP Header TLV
```

반환된 확장 TCP 헤더 필드는 전송 변환기가 수신한 SYN+ACK에 포함된 TCP 옵션의 복사본입니다.

할당되지 않음 필드는 송신자에 의해 0으로 설정되어야 하고 수신자에 의해 무시되어야 합니다.\(MUST\)

---
#### **6.2.7.  The Cookie TLV**

쿠키 TLV\(그림 21\)는 TCP Fast Open Cookie \[RFC7413\]와 유사한 선택적 TLV입니다. 전송 변환기는 스푸핑된 주소로부터의 공격을 방지하기 위해 클라이언트가 보내는 패킷을 수신할 수 있는지 확인하려고 할 수 있습니다. 이 확인은 예를 들어 클라이언트의 IP 주소에 바인딩된 쿠키를 사용하여 수행할 수 있습니다. 이 쿠키는 이 문서 외부에 있거나 전송 변환기에서 제공하는 수단을 통해 클라이언트에서 구성할 수 있습니다.

선택적 쿠키 TLV를 사용하도록 구성된 전송 변환기는 수신된 SYN의 페이로드에 이 TLV가 있는지 확인해야 합니다. 이 TLV가 존재하는 경우 전송 변환기는 \[RFC7413\]의 섹션 4.1.2에 있는 것과 유사한 방법\(즉, IsCookieValid\)을 통해 쿠키를 검증해야 합니다. 쿠키가 유효하면 연결 설정 절차를 계속할 수 있습니다. 그렇지 않으면 전송 변환기는 "인증되지 않음"으로 설정된 오류 TLV를 반환하고 연결을 닫아야 합니다.\(MUST, MUST, MUST\)

수신된 SYN에 쿠키 TLV가 포함되어 있지 않고 쿠키 유효성 검사가 필요한 경우 전송 변환기는 이 클라이언트 주소에 바인딩된 쿠키를 계산할 수 있습니다. 이러한 경우 전송 변환기는 "Missing Cookie"로 설정된 오류 TLV와 계산된 쿠키를 반환하고 연결을 닫아야 합니다. 클라이언트는 먼저 재설정을 실행하여 연결을 종료함으로써 이 오류에 대응합니다. 또한 수신된 쿠키를 캐시에 저장하고 쿠키 TLV를 포함하는 전송 변환기에 대한 새로운 연결을 다시 설정하려고 시도합니다.\(MAY, MUST\)

쿠키 TLV의 형식은 그림 21에 나와 있습니다.

```text
                         1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +---------------+---------------+-------------------------------+
    |     Type=0x16 |     Length    |             Zero              |
    +---------------+---------------+-------------------------------+
    /                        Opaque  Cookie                         /
    /                              ...                              /
    +---------------------------------------------------------------+

                         Figure 21: The Cookie TLV
```

---
#### **6.2.8.  Error TLV**

오류 TLV\(그림 22\)는 변환 메시지 처리 중에 발생한 일부 오류에 대한 정보를 제공하기 위한 것입니다. 이 TLV는 가변 길이를 갖습니다. 오류 TLV를 수신하면 클라이언트는 관련 연결을 재설정해야 합니다.\(MUST\)

SYN+ACK 또는 ACK에는 오류 TLV가 포함될 수 있습니다.

```text
                         1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +---------------+---------------+----------------+--------------+
    |     Type=0x1E |     Length    |    Error Code  |  Value       |
    +---------------+---------------+----------------+--------------+
    //              ...   (optional) Value                         //
    +---------------------------------------------------------------+

                          Figure 22: The Error TLV
```

변환 메시지를 처리하는 동안 다양한 유형의 오류가 발생할 수 있습니다. 각 오류는 부호 없는 정수로 표시되는 오류 코드로 식별됩니다. 오류 코드의 네 가지 클래스가 정의됩니다.

메시지 유효성 검사 및 처리 오류\(0-31 범위\):

- 유효하지 않은 메시지\(유효한 메시지를 포함하지만 유효하지 않거나 알 수 없는 TLV가 포함됨\)를 수신하면 반환됩니다.

클라이언트 측 오류\(32-63 범위\):

- 클라이언트가 Transport Converter에서 수락할 수 없는 요청을 보냈습니다\(예: 지원되지 않는 작업\).

변환기 측 오류\(64-95 범위\):

- 전송 변환기에서 발생하는 문제\(예: 리소스 부족\)로 인해 클라이언트의 요청을 이행할 수 없습니다.

대상 서버로 인해 발생한 오류\(96-127 범위\):

- 최종 목적지에 도달할 수 없거나 재설정으로 응답되었습니다.

이 문서에는 다음 오류 코드가 정의되어 있습니다.

지원되지 않는 버전\(0\):

- 상대방으로부터 받은 메시지의 고정 헤더에 표시된 버전 번호는 지원되지 않습니다.

- 이 오류 코드는 지원하지 않는 버전 번호가 있는 요청을 수신할 때 피어\(예: Transport Converter\)에 의해 생성되어야 합니다.\(MUST\)

- 값 필드는 피어가 지원하는 버전으로 설정되어야 합니다. 피어가 여러 버전을 지원하는 경우 값 필드에 지원되는 버전 목록이 포함됩니다. 각 버전은 8비트로 인코딩됩니다. 지원되는 버전 목록은 32비트 경계에서 끝나도록 0으로 채워져야 합니다.\(MUST, MUST\)

- 이 오류 코드를 수신하면 원격 피어\(예: 클라이언트\)는 피어가 반환한 버전 중 하나를 지원하는지 확인합니다. 일반적으로 지원되는 가장 높은 버전 번호는 원격 피어가 피어와의 후속 교환에서 사용해야 합니다.\(MUST\)

잘못된 메시지 \(1\):

- 이 오류 코드는 피어로부터 수신된 메시지를 성공적으로 구문 분석하고 확인할 수 없음을 나타내기 위해 전송됩니다.

- 일반적으로 이 오류 코드는 멀티캐스트, 브로드캐스트 또는 루프백 IP 주소를 포함하는 Connect TLV를 수신하는 경우 전송 변환기에 의해 전송됩니다.

- 문제 해결을 쉽게 하려면 값 필드가 그림 23에 설명된 형식을 사용하여 수신된 메시지를 에코해야 합니다. 이 형식을 사용하면 오류를 유발한 메시지의 원래 정렬을 유지할 수 있습니다.\(MUST\)

```text
                            1                   2                   3
        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
       +---------------+---------------+----------------+--------------+
       |     Type=0x1E |     Length    |    Error Code  |  Zeros       |
       +---------------+---------------+----------------+--------------+
       //        Echo the message that triggered the error            //
       +---------------------------------------------------------------+
```

- 그림 23: 메시지 상관관계를 용이하게 하기 위한 오류 TLV

지원되지 않는 메시지\(2\):

- 이 오류 코드는 클라이언트로부터 수신된 메시지 유형이 지원되지 않음을 나타내기 위해 전송됩니다.

- 문제 해결을 쉽게 하려면 값 필드가 그림 23에 표시된 형식을 사용하여 수신된 메시지를 에코해야 합니다.\(MUST\)

누락된 쿠키\(3\):

- 전송 변환기가 스푸핑 공격을 방지하기 위해 쿠키 활용을 요구하고 쿠키 TLV가 변환 메시지에 포함되지 않은 경우 전송 변환기는 이 클라이언트에 대한 쿠키를 계산하는 경우에만 요청 클라이언트에게 이 오류를 반환해야 합니다. 값 필드의 첫 번째 바이트는 0으로 설정되어야 하며 오류 TLV의 나머지 바이트에는 이 클라이언트에 대한 전송 변환기가 계산한 쿠키가 포함됩니다.\(MUST, MUST\)

- 이 오류 코드를 수신한 클라이언트는 수신된 쿠키를 캐시하고 해당 Transport Converter로 전송되는 후속 변환 메시지에 이를 포함해야 합니다.\(SHOULD\)

승인되지 않음 \(32\):

- 이 오류 코드는 전송 변환기가 인증 부족\(예: 관리상 금지, 인증 실패 또는 유효하지 않은 쿠키 TLV\)으로 인해 연결 생성을 거부했음을 나타냅니다. 값 필드는 0으로 설정되어야 합니다.\(MUST\)

- 인증이 실패하여 요청을 성공적으로 처리할 수 없는 경우 전송 변환기에서 이 오류 코드를 전송해야 합니다.\(MUST\)

지원되지 않는 TCP 옵션\(33\):

- 클라이언트가 최종 서버에 알리기 위해 요청한 TCP 옵션은 안전하게 사용할 수 없습니다.

- 값 필드는 지원되지 않는 TCP 옵션의 유형으로 설정됩니다. Connect TLV에 지원되지 않는 TCP 옵션이 여러 개 지정된 경우 지원되지 않는 TCP 옵션 목록이 반환됩니다. 지원되지 않는 TCP 옵션 목록은 32비트 경계에서 끝나도록 0으로 채워져야 합니다.\(MUST\)

리소스 초과\(64\):

- 이 오류는 전송 변환기에 요청을 수행하는 데 필요한 리소스가 부족함을 나타냅니다.

- 이 오류는 새 연결을 처리할 리소스가 충분하지 않은 경우 전송 변환기에 의해 전송되어야 합니다. 전송 변환기는 새로운 프록시 연결을 위해 전송 변환기를 요청하기 전에 클라이언트가 기다려야 하는 제안된 지연\(초\)을 값 필드에 표시할 수 있습니다. 값 0은 최소 30초의 기본 지연에 해당합니다.\(MUST, SHOULD\)

네트워크 장애\(65\):

- 이 오류는 전송 변환기에서 요청을 프록시하는 데 네트워크 오류가 발생했음을 나타냅니다.

전송 변환기는 다음과 같은 경우 이 오류 코드를 보내야 합니다.

- 연결을 프록시하기 위해 전달 문제가 발생했습니다. 전송 변환기는 새로운 프록시 연결을 위해 전송 변환기를 요청하기 전에 클라이언트가 기다려야 하는 제안된 지연\(초\)을 값 필드에 표시할 수 있습니다. 값 0은 최소 30초의 기본 지연에 해당합니다.\(MUST, SHOULD\)

연결 재설정\(96\):

- 이 오류는 최종 목적지가 RST 세그먼트로 응답했음을 나타냅니다. 값 필드는 0으로 설정되어야 합니다.\(MUST\)

목적지에 도달할 수 없음\(97\):

- 이 오류는 전송 변환기가 하드 오류\(예: 대상에 연결할 수 없음, 포트에 연결할 수 없음, 네트워크에 연결할 수 없음\)를 나타내는 ICMP 메시지를 수신했음을 나타냅니다. 값 필드는 수신된 ICMP 메시지의 코드 필드를 반영해야 합니다.\(MUST\)

- 다시 말해, TCP 구현은 IP 계층에서 전달된 ICMP 오류 메시지에 대해 조치를 취하고 해당 ICMP 메시지의 페이로드에 포함된 역다중화 정보를 사용하여 오류를 트리거한 연결로 이를 전달해야 합니다. 이러한 역다중화 문제는 오류가 대역 내로 전송되기 때문에 "대상 도달 불가" 오류 TLV 처리에 적용되지 않습니다. 이러한 이유로 ICMP 메시지의 페이로드는 대상 도달 불가 오류 TLV에 반영되지 않습니다.

표 2에는 다양한 오류 코드가 요약되어 있습니다.

```text
                +=======+======+=========================+
                | Error | Hex  | Description             |
                +=======+======+=========================+
                | 0     | 0x00 | Unsupported Version     |
                +-------+------+-------------------------+
                | 1     | 0x01 | Malformed Message       |
                +-------+------+-------------------------+
                | 2     | 0x02 | Unsupported Message     |
                +-------+------+-------------------------+
                | 3     | 0x03 | Missing Cookie          |
                +-------+------+-------------------------+
                | 32    | 0x20 | Not Authorized          |
                +-------+------+-------------------------+
                | 33    | 0x21 | Unsupported TCP Option  |
                +-------+------+-------------------------+
                | 64    | 0x40 | Resource Exceeded       |
                +-------+------+-------------------------+
                | 65    | 0x41 | Network Failure         |
                +-------+------+-------------------------+
                | 96    | 0x60 | Connection Reset        |
                +-------+------+-------------------------+
                | 97    | 0x61 | Destination Unreachable |
                +-------+------+-------------------------+

                      Table 2: Convert Error Values
```

---
## **7.  Compatibility of Specific TCP Options with the Conversion Service**

이 섹션에서는 배포된 여러 표준 추적 TCP 옵션이 변환 프로토콜을 통해 어떻게 지원될 수 있는지 논의합니다. 다른 TCP 옵션은 다른 문서에서 논의됩니다.

---
### **7.1.  Base TCP Options**

\[RFC0793\]에는 세 가지 TCP 옵션이 처음에 정의되었습니다: 옵션 목록 끝\(Kind=0\), 작업 없음\(Kind=1\) 및 최대 세그먼트 크기\(Kind=2\). 처음 두 옵션은 주로 TCP 헤더를 채우는 데 사용됩니다. 클라이언트가 전송 변환기에게 이러한 옵션을 최종 목적지로 구체적으로 보내도록 요청할 이유가 없습니다.

최대 세그먼트 크기 옵션\(종류=2\)은 호스트가 각 연결을 통해 수신할 수 있는 가장 큰 세그먼트를 나타내는 데 사용됩니다. 이 값은 TCP 연결을 종료하는 스택의 기능입니다. 클라이언트가 특정 최대 세그먼트 크기\(MSS\) 값을 원격 서버에 알리기 위해 전송 변환기를 요청할 이유가 없습니다.

전송 변환기는 Connect TLV에 나타나는 Kind=0, 1 또는 2의 옵션을 무시해야 합니다. 지원되는 TCP 확장 TLV에서 이를 발표해서는 안 됩니다.\(MUST, MUST NOT\)

---
### **7.2.  Window Scale (WS)**

Window Scale\(WS\) 옵션\(Kind=3\)은 \[RFC7323\]에 정의되어 있습니다. MSS 옵션의 경우 연결에 사용되는 창 배율은 연결을 처리하는 TCP 스택에 따라 크게 달라집니다. 전송 변환기가 클라이언트를 대신하여 원격 서버를 향한 TCP 연결을 열 때 스택 구성에 해당하는 배율 인수와 함께 WS 옵션을 사용해야 합니다. 로컬 구성은 프록시 메시지의 WS 옵션이 수신 연결의 배율 인수 기능이 되도록 허용할 수 있습니다.\(SHOULD, MAY\)

배포 관점에서 볼 때 전송 변환기의 클라이언트가 원격 서버에 대한 특정 배율 인수를 사용하여 WS 옵션\(종류=3\)의 활용을 구체적으로 요청하도록 하는 것은 이점이 없습니다. 이러한 이유로 전송 변환기는 Connect TLV에 나타나는 경우 Kind=3 옵션을 무시해야 합니다. 전송 변환기는 지원되는 TCP 확장 TLV에서 WS 옵션\(Kind=3\)을 발표해서는 안 됩니다.\(MUST, MUST NOT\)

---
### **7.3.  Selective Acknowledgments**

\[RFC2018\]에서는 SACK\(Selective Acknowledgement\)를 지원하기 위해 두 가지 서로 다른 TCP 옵션이 정의되었습니다. 첫 번째 SACK-Permitted\(Kind=4\)는 3방향 핸드셰이크 중에 선택적 승인 활용을 협상하는 데 사용됩니다. 두 번째 SACK\(Kind=5\)는 일반 세그먼트 내부에 선택적 승인을 전달합니다.

SACK 허용 옵션\(Kind=4\)은 지원되는 TCP 확장 TLV의 전송 변환기에 의해 광고될 수 있습니다. 이 전송 변환기에 연결된 클라이언트는 Connect TLV에 SACK-Permitted 옵션을 포함할 수 있습니다.\(MAY, MAY\)

3방향 핸드셰이크 중에는 SACK 옵션\(Kind=5\)을 사용할 수 없습니다. 이러한 이유로 전송 변환기는 Connect TLV에 나타나는 경우 Kind=5 옵션을 무시해야 합니다. TCP 지원 확장 TLV에서 이를 발표해서는 안 됩니다.\(MUST, MUST NOT\)

---
### **7.4.  Timestamp**

타임스탬프 옵션 \[RFC7323\]은 TCP 연결 중 타임스탬프 활용을 협상하기 위해 3방향 핸드셰이크 중에 사용될 수 있습니다. 특히 왕복 시간 추정을 개선하고 PAWS\(Protection Against Wrapped Sequences\)를 제공하는 데 사용됩니다. WS 옵션의 경우 타임스탬프는 연결의 속성이며 클라이언트가 원격 서버에 대한 연결을 설정할 때 타임스탬프 옵션을 사용하도록 전송 변환기에 요청할 수 있는 이점은 제한적입니다. 또한 TCP 스택에서 사용되는 타임스탬프는 각 스택마다 다르며 클라이언트가 전송 변환기가 원격 서버에 대한 연결을 설정하는 데 사용할 수 있는 타임스탬프 값을 지정할 수 있게 해도 이점이 없습니다.

전송 변환기는 TCP 지원 확장 TLV에서 타임스탬프 옵션\(종류=8\)을 ​​광고할 수 있습니다. 이 전송 변환기에 연결된 클라이언트는 Connect TLV의 타임스탬프 옵션을 포함할 수 있지만 타임스탬프는 포함하지 않을 수 있습니다.\(MAY, MAY\)

---
### **7.5.  Multipath TCP**

다중 경로 TCP 옵션은 여러 다중 경로 TCP 옵션을 지원하기 위한 하위 유형 필드를 포함하는 하나의 가변 길이 TCP 옵션\(Kind=30\)을 정의하는 \[RFC8684\]에 정의되어 있습니다. 클라이언트가 전송 변환기 \[IETFJ16\]를 통해 다중 경로 TCP를 사용하려는 몇 가지 운영 사용 사례가 있습니다. 그러나 이러한 사용 사례 중 어느 것도 전송 변환기가 원격 서버로 보내야 하는 다중 경로 TCP 옵션의 내용을 클라이언트가 지정하도록 요구하지 않습니다.

다중 경로 TCP 변환 서비스를 지원하는 전송 변환기는 지원되는 TCP 확장 TLV에서 다중 경로 TCP 옵션\(Kind=30\)을 광고해야 합니다. 이 전송 변환기에 의해 서비스되는 클라이언트는 Connect TLV에 다중 경로 TCP 옵션을 포함할 수 있지만 콘텐츠는 없습니다.\(MUST\)

---
### **7.6.  TCP Fast Open**

TCP Fast Open Cookie 옵션\(Kind=34\)은 \[RFC7413\]에 정의되어 있습니다. 전송 변환기에서 지원해야 하는 이 옵션의 두 가지 다른 사용법이 있습니다. TCP Fast Open Cookie 옵션의 첫 번째 활용은 서버에서 쿠키를 요청하는 것입니다. 이 경우 클라이언트는 빈 쿠키와 함께 옵션을 전송하고 서버는 쿠키를 반환합니다. TCP Fast Open Cookie 옵션의 두 번째 활용은 서버에 쿠키를 보내는 것입니다. 이 경우 옵션에는 쿠키가 포함됩니다.

전송 변환기는 지원되는 TCP 확장 TLV에서 TCP Fast Open Cookie 옵션\(Kind=34\)을 광고할 수 있습니다. 전송 변환기가 지원되는 TCP 확장 TLV에서 TCP Fast Open에 대한 지원을 광고한 경우 두 가지 유형의 Connect TLV를 처리할 수 있어야 합니다.\(MAY\)

그러한 전송 변환기가 쿠키를 포함하지 않는 TCP Fast Open Cookie 옵션으로 Connect TLV를 수신하는 경우 원격 서버로 전송되는 SYN에 빈 TCP Fast Open Cookie 옵션을 추가해야 합니다. 원격 서버가 TFO를 지원하는 경우 \[RFC7413\]의 4.1.2절 절차에 따라 SYN-ACK로 응답합니다. 이 SYN-ACK에는 쿠키와 함께 Fast Open 옵션이 포함될 수 있습니다. 변환기가 SYN-ACK를 받으면 쿠키와 함께 Fast Open 옵션을 클라이언트에 전달합니다.\(MUST\)

이러한 전송 변환기가 쿠키가 포함된 TCP Fast Open Cookie 옵션으로 Connect TLV를 수신하는 경우 원격 서버로 전송된 SYN의 TCP Fast Open Cookie 옵션을 복사해야 합니다.\(MUST\)

---
### **7.7.  TCP-AO**

TCP 인증 옵션\(TCP-AO\) \[RFC5925\]은 TCP 연결을 통해 교환되는 모든 패킷을 인증하는 기술을 제공합니다. 이 확장의 특성을 고려할 때 패킷을 종단 간 인증해야 하는 애플리케이션이 연결이 변환기를 통과하기를 원하지 않을 것입니다. 이러한 이유로 전송 변환기에 의한 TCP-AO 지원은 권장되지 않습니다. TCP-AO와 이 문서의 솔루션을 결합하는 것이 타당할 수 있는 유일한 사용 사례는 TCP-AO-NAT 확장 \[RFC6978\]이 사용되는 경우입니다.

전송 변환기는 지원되는 TCP 확장 TLV에서 TCP-AO\(Kind=29\)를 광고해서는 안 됩니다. 전송 변환기가 TCP-AO를 포함하는 연결 TLV를 수신하는 경우 TCP-AO-NAT 옵션이 사용되는 경우를 제외하고 "지원되지 않는 TCP 옵션"으로 설정된 오류 코드와 함께 연결 설정을 거부해야 합니다. 그럼에도 불구하고 TCP-AO-NAT는 실험적이므로 사용법이 현재 정의되어 있지 않으며 사용하기 전에 다른 문서에서 지정해야 합니다.\(MUST NOT, MUST\)

---
## **8.  Interactions with Middleboxes**

Convert 프로토콜은 TCP를 방해하는 미들박스를 포함하지 않는 네트워크에서 사용하도록 설계되었습니다. 이러한 조건에서 네트워크 공급자는 관련된 모든 경로상의 노드가 TCP 신호를 중단하지 않도록 보장한다고 가정합니다\(예: TCP 옵션 제거, 일부 SYN 폐기 등\).

그럼에도 불구하고 강력한 서비스를 허용하기 위해 이 섹션에서는 클라이언트가 미들박스 간섭을 감지하고 이 간섭의 영향을 받는 전송 변환기 사용을 중지할 수 있는 방법을 설명합니다.

인터넷 측정\[IMC11\]에서는 미들박스가 TCP 확장 배포에 영향을 미칠 수 있음을 보여주었습니다. 이 섹션에서는 변환 프로토콜이 메시지를 바이트스트림의 시작 부분에 배치하므로 페이로드를 수정하는 미들박스에 중점을 둡니다.

SYN 페이로드를 제거하는 미들박스를 고려해보세요. 클라이언트는 전송 변환기가 반환한 경우 SYN+ACK의 승인 번호 필드를 살펴봄으로써 이 문제를 감지할 수 있습니다. 클라이언트는 미들박스 간섭을 고려하여 이 전송 변환기 사용을 중지해야 합니다.\(MUST\)

이제 페이로드와 함께 SYN/ACK를 삭제하는 미들박스를 생각해 보세요. 클라이언트는 Transport Converter를 통해 연결을 설정할 수 없습니다. SYN+ACK의 페이로드를 제거하는 미들박스 또는 SYN+ACK\(SYN의 페이로드는 아님\) 다음에 오는 패킷에서 클라이언트가 감지할 수 있습니다. 이는 응답에 유효한 변환 메시지가 없다는 점에서 암시됩니다.

\[RFC7413\]에 설명된 대로 일부 CGN\(Carrier Grade NAT\)은 동일한 최종 호스트에 다른 IP 주소를 할당하는 경우 TFO의 작동에 영향을 미칠 수 있습니다. 이러한 CGN은 변환 프로토콜에서 사용하는 쿠키 유효성 검사의 작동에 영향을 미칠 수 있습니다. 클라이언트와 전송 변환기 사이의 경로에서 활성화된 CGN은 \[RFC6888\]에 정의된 주소 보존을 준수해야 합니다. \[RFC7413\] 섹션 7.1의 토론도 참조하세요.

---
## **9.  Security Considerations**

구현에서는 변환 TLV가 고정 헤더\(섹션 6.1\)의 총 길이로 표시된 경계 내에서 적절하게 프레임화되었는지 확인해야 합니다.\(MUST\)

추가 보안 고려 사항은 다음 하위 섹션에서 설명됩니다.

---
### **9.1.  Privacy & Ingress Filtering**

Transport Converter는 개인정보 관련 정보\(예: 가입자 자격 증명\)에 액세스할 수 있습니다. Transport Converter는 민감한 정보를 로컬 도메인 외부로 유출하지 않도록 설계되었습니다.

네트워크에서의 기능과 위치를 고려할 때 전송 변환기는 처리하는 모든 패킷을 관찰하고 페이로드와 메타데이터를 포함하며 사용자 행동에 대한 일부 트래픽 분석을 프로파일링하고 수행할 수 있는 위치에 있습니다. 전송 변환기는 핵심 IP 라우터\(예: \[RFC1812\]의 섹션 10\)만큼 보호되어야 합니다.\(MUST\)

또한 수신 필터링 정책은 네트워크 경계에서 시행되어야 합니다\[RFC2827\].\(MUST\)

이 문서에서는 모든 네트워크 연결이 동일한 관리 엔터티에 의해 관리된다고 가정합니다. 따라서 이러한 네트워크에 스푸핑 방지 필터를 적용하면 호스트가 스푸핑된 소스 IP 주소로 트래픽을 보내지 않도록 보호할 수 있습니다.

---
### **9.2.  Authentication and Authorization Considerations**

변환 프로토콜은 최종 호스트가 IP 주소로 안전하게 식별될 수 있는 관리 네트워크에서 사용하는 것이 좋습니다. 그러한 제어가 실행되지 않고 보다 개방적인 네트워크 환경이 있는 경우 변환 프로토콜을 사용하기 위해 강력한 상호 인증 체계를 정의해야 합니다.\(SHOULD, MUST\)

상호 인증의 한 가지 가능성은 TLS를 사용하여 클라이언트와 변환기 간에 상호 인증을 수행하는 것입니다. 즉, 클라이언트가 변환기에서 쿠키를 검색할 때 TLS를 사용하고 인증서 기반, 사전 공유 키 기반 \[RFC4279\] 또는 원시 공개 키 기반 클라이언트 인증 \[RFC7250\]을 사용하여 이 연결을 보호합니다. 인증이 성공하면 변환기는 클라이언트에 쿠키를 반환합니다. 후속 연결 메시지는 쿠키 TLV 콘텐츠의 기능으로 승인됩니다. 클라이언트와 전송 변환기 사이의 네트워크 내 공격자는 쿠키를 가로채서 이를 사용하여 변환 서비스에 대한 액세스 권한을 부여받을 수 있습니다. 이러한 공격은 공격자가 클라이언트의 IP 주소를 스푸핑하고 네트워크가 소스 스푸핑된 IP 주소로 패킷을 필터링하지 않는 경우에만 가능합니다.

다양한 네트워크 연결\(전송 변환기 포함\)을 관리하는 운영자는 인증 및 권한 부여 정책을 시행하기 위한 다양한 옵션을 가지고 있습니다. 예를 들어, 승인을 얻는 방법의 전체 목록은 다음과 같습니다.

\* 네트워크 공급자는 다음 사항에 따라 정책을 시행할 수 있습니다.

- 사용자가 TCP 변환기 서비스의 혜택을 받을 수 있는지 확인하기 위한 IMSI\(International Mobile Subscriber Identity\). 인증이 실패하면 PDP\(Packet Data Protocol\) 컨텍스트/전달자가 탑재되지 않습니다. 이 방법은 인증 문제를 위해 전송 변환기와의 상호 작용이 필요하지 않습니다.

\* 네트워크 공급자는 전송 변환기와 통신하도록 승인된 호스트를 제어하기 위해 광대역 네트워크 게이트웨이\(BNG\) 등에서 액세스 제어 목록\(ACL\)을 기반으로 정책을 시행할 수 있습니다. 이러한 ACL은 RADIUS 교환\(예: \[TCPM-CONVERTER\]\)의 결과로 설치될 수 있습니다. 이 방법은 인증 문제를 위해 전송 변환기와의 상호 작용이 필요하지 않습니다.

\* 전송 변환기가 내장된 장치는 지정된 소스 IP 주소에서 수신된 연결이 승인되었는지 여부를 확인하기 위해 AAA 서버를 요청하는 RADIUS 클라이언트를 호스팅할 수도 있습니다\[TCPM-CONVERTER\].

불법 사용자\(예: Transport Converter를 운영하는 동일한 공급자가 관리하지 않는 액세스 네트워크를 사용하는 사용자\)가 Transport Converter 리소스를 오용하는 것을 방지하는 첫 번째 보호 장치는 Transport Converter가 외부 영역에서 수신된 Convert 연결을 거부하는 것입니다. 전송 변환기의 내부 영역에서 수신된 변환 연결만 허용됩니다.

도메인 호스트 간에 네트워크 지원 연결이 허용되지 않는 배포\(예: 헤어핀\)에서는 변환기에 이러한 연결을 삭제하라는 지시가 있을 수 있습니다. 따라서 헤어핀 연결은 "인증되지 않음"으로 설정된 오류 TLV를 반환하여 전송 변환기에 의해 거부됩니다. 그렇지 않은 경우 명시적인 구성이 없으면 변환기에 의해 헤어핀이 활성화됩니다\(그림 24 참조\).

```text
             <===Network Provider===>

      +----+ from X1:x1 to X2':x2'   +-----+ X1':x1'
      | C1 |>>>>>>>>>>>>>>>>>>>>>>>>>>>>>--+---
      +----+                         |  v  |
                                     |  v  |
                                     |  v  |
                                     |  v  |
      +----+ from X1':x1' to X2:x2   |  v  | X2':x2'
      | C2 |<<<<<<<<<<<<<<<<<<<<<<<<<<<<<--+---
      +----+                         +-----+
                                    Converter
```

참고: X2':x2'는 다음과 같을 수 있습니다.

- X2:x2

```text
                       Figure 24: Hairpinning Example
```

---
### **9.3.  Denial of Service**

또 다른 가능한 위험은 증폭 공격입니다. 전송 변환기는 클라이언트로부터 SYN을 수신하면 원격 서버를 향해 SYN을 보내기 때문입니다. 이는 전송 변환기가 보낸 SYN이 클라이언트에서 받은 SYN보다 크거나 전송 변환기가 SYN을 재전송하는 경우 증폭 공격으로 이어질 수 있습니다. 이러한 공격을 완화하려면 전송 변환기는 특정 클라이언트에 대해 보류 중인 요청 수를 제한해야 합니다. 또한 클라이언트로부터 수신한 SYN보다 훨씬 긴 SYN을 원격 서버로 보내는 것을 피해야 합니다. 마지막으로 전송 변환기는 해당 클라이언트로부터 재전송된 SYN을 수신한 후에만 SYN을 서버로 재전송해야 합니다. SYN 플러딩 공격으로부터 보호하기 위한 수단도 활성화되어야 합니다\(예: \[RFC4987\]의 섹션 3\).\(SHOULD, SHOULD, SHOULD\)

클라이언트와 전송 변환기 간의 네트워크 내 공격\(프로토콜 버전을 변경하는 공격 포함\)은 또 다른 위협입니다. 불법 노드가 네트워크에 연결될 수 없도록 보장하는 수단이 구현되어야 합니다.

---
### **9.4.  Traffic Theft**

불법적인 변환기가 경로에 삽입되면 교통 도난의 위험이 있습니다. 실제로 전달 경로에 불법 변환기를 삽입하면 트래픽 가로채기가 허용되므로 호스트에서 발행했거나 호스트로 향하는 민감한 데이터에 대한 액세스를 제공할 수 있습니다. 변환기 검색 및 구성은 이 문서의 범위를 벗어납니다.

---
### **9.5.  Logging**

변환기가 주소 공유 모드\(섹션 4.4.2\)에서 작동하도록 구성된 경우 \[RFC6888\]의 섹션 4에 설명된 로깅 권장 사항을 고려해야 합니다. 주소 공유 환경에서 발생하는 보안 관련 문제는 \[RFC6269\]의 섹션 13에 문서화되어 있습니다.

---
## **10.  IANA Considerations**
---
### **10.1.  Convert Service Name**

```text
   IANA has assigned a service name for the Convert Protocol from the
   "Service Name and Transport Protocol Port Number Registry" available
   at <https://www.iana.org/assignments/service-names-port-numbers>.

   Service Name:            convert
   Port Number:             N/A
   Transport Protocol(s):   TCP
   Description:             0-RTT TCP Convert Protocol
   Assignee:                IESG <iesg@ietf.org>
   Contact:                 IETF Chair <chair@ietf.org>
   Reference:               RFC 8803
```

클라이언트는 도메인의 전송 변환기가 사용하는 IP 주소와 포트 번호를 검색하기 위해 \[RFC2782\]에 정의된 절차를 제공하기 위해 이 서비스 이름을 사용할 수 있습니다.

---
### **10.2.  The Convert Protocol (Convert) Parameters**

IANA는 새로운 "TCP 변환 프로토콜\(변환\) 매개변수" 레지스트리를 만들었습니다.

다음 하위 섹션에서는 "프로토콜 변환\(변환\) 매개변수" 레지스트리 내의 새 레지스트리에 대해 자세히 설명합니다.

지정된 전문가는 \[RFC8126\]의 4.6절에 설명된 대로 적절한 문서의 존재를 확인하고 해당 문서가 영구적이고 공개적으로 이용 가능함을 확인해야 합니다. 지정된 전문가는 또한 요청된 코드 포인트의 목적과 사용의 명확성을 확인해야 합니다.

또한 지정된 전문가가 적용해야 하는 기준에는 제안된 등록이 기존 기능과 중복되는지 여부, 일반적으로 적용 가능한지 또는 개인 용도로만 유용한지 여부, 등록 설명이 명확한지 여부 등이 포함됩니다. 모든 요청은 리뷰 메일링 리스트로 전달되어야 합니다. "TLV 변환" 및 "오류 변환" 하위 레지스트리의 경우 IANA는 지정된 전문가가 제공하는 128-191 범위의 레지스트리 업데이트만 수락해야 합니다. 여러 명의 지정 전문가를 임명하는 것이 좋습니다. 등록 결정이 특정 전문가에게 이해상충을 야기하는 것으로 인식될 수 있는 경우, 해당 전문가는 다른 전문가의 판단을 따라야 합니다.

---
#### **10.2.1.  Convert Versions**

IANA는 "버전 변환" 하위 레지스트리를 만들었습니다. IETF 검토\(\[RFC8126\]의 섹션 4.8\)를 통해 새로운 값이 할당됩니다.

레지스트리의 초기 값은 다음과 같습니다.

```text
                   +=========+=============+===========+
                   | Version | Description | Reference |
                   +=========+=============+===========+
                   | 0       | Reserved    | RFC 8803  |
                   +---------+-------------+-----------+
                   | 1       | Assigned    | RFC 8803  |
                   +---------+-------------+-----------+

                     Table 3: Current Convert Versions
```

---
#### **10.2.2.  Convert TLVs**

IANA는 "TLV 변환" 하위 레지스트리를 만들었습니다. 이 레지스트리에서 값을 할당하는 절차는 다음과 같습니다.

```text
   1-127:    IETF Review

   128-191:  Specification Required

   192-255:  Private Use
```

레지스트리의 초기 값은 다음과 같습니다.

```text
            +======+=============================+===========+
            | Code | Name                        | Reference |
            +======+=============================+===========+
            | 0    | Reserved                    | RFC 8803  |
            +------+-----------------------------+-----------+
            | 1    | Info TLV                    | RFC 8803  |
            +------+-----------------------------+-----------+
            | 10   | Connect TLV                 | RFC 8803  |
            +------+-----------------------------+-----------+
            | 20   | Extended TCP Header TLV     | RFC 8803  |
            +------+-----------------------------+-----------+
            | 21   | Supported TCP Extension TLV | RFC 8803  |
            +------+-----------------------------+-----------+
            | 22   | Cookie TLV                  | RFC 8803  |
            +------+-----------------------------+-----------+
            | 30   | Error TLV                   | RFC 8803  |
            +------+-----------------------------+-----------+

                      Table 4: Initial Convert TLVs
```

---
#### **10.2.3.  Convert Error Messages**

IANA는 "오류 변환" 하위 레지스트리를 만들었습니다. 이 레지스트리의 코드는 오류 유형에 따라 할당됩니다. 네 가지 유형이 정의됩니다. 이러한 각 유형에 대해 다음 범위가 예약되어 있습니다.

0-31: 메시지 검증 및 처리 오류

```text
   32-63:    Client-side errors

   64-95:    Transport Converter-side errors
```

96-127: 대상 서버로 인한 오류

이 하위 레지스트리에서 값을 할당하는 절차는 다음과 같습니다.

```text
   0-127:    IETF Review

   128-191:  Specification Required

   192-255:  Private Use
```

레지스트리의 초기 값은 다음과 같습니다.

```text
              +=======+=========================+===========+
              | Error | Description             | Reference |
              +=======+=========================+===========+
              | 0     | Unsupported Version     | RFC 8803  |
              +-------+-------------------------+-----------+
              | 1     | Malformed Message       | RFC 8803  |
              +-------+-------------------------+-----------+
              | 2     | Unsupported Message     | RFC 8803  |
              +-------+-------------------------+-----------+
              | 3     | Missing Cookie          | RFC 8803  |
              +-------+-------------------------+-----------+
              | 32    | Not Authorized          | RFC 8803  |
              +-------+-------------------------+-----------+
              | 33    | Unsupported TCP Option  | RFC 8803  |
              +-------+-------------------------+-----------+
              | 64    | Resource Exceeded       | RFC 8803  |
              +-------+-------------------------+-----------+
              | 65    | Network Failure         | RFC 8803  |
              +-------+-------------------------+-----------+
              | 96    | Connection Reset        | RFC 8803  |
              +-------+-------------------------+-----------+
              | 97    | Destination Unreachable | RFC 8803  |
              +-------+-------------------------+-----------+

                    Table 5: Initial Convert Error Codes
```

---
## **11.  References**
---
### **11.1.  Normative References**

```text
   [RFC0793]  Postel, J., "Transmission Control Protocol", STD 7,
              RFC 793, DOI 10.17487/RFC0793, September 1981,
              <https://www.rfc-editor.org/info/rfc793>.

   [RFC2018]  Mathis, M., Mahdavi, J., Floyd, S., and A. Romanow, "TCP
              Selective Acknowledgment Options", RFC 2018,
              DOI 10.17487/RFC2018, October 1996,
              <https://www.rfc-editor.org/info/rfc2018>.

   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", BCP 14, RFC 2119,
              DOI 10.17487/RFC2119, March 1997,
              <https://www.rfc-editor.org/info/rfc2119>.

   [RFC2827]  Ferguson, P. and D. Senie, "Network Ingress Filtering:
              Defeating Denial of Service Attacks which employ IP Source
              Address Spoofing", BCP 38, RFC 2827, DOI 10.17487/RFC2827,
              May 2000, <https://www.rfc-editor.org/info/rfc2827>.

   [RFC4291]  Hinden, R. and S. Deering, "IP Version 6 Addressing
              Architecture", RFC 4291, DOI 10.17487/RFC4291, February
              2006, <https://www.rfc-editor.org/info/rfc4291>.

   [RFC4787]  Audet, F., Ed. and C. Jennings, "Network Address
              Translation (NAT) Behavioral Requirements for Unicast
              UDP", BCP 127, RFC 4787, DOI 10.17487/RFC4787, January
              2007, <https://www.rfc-editor.org/info/rfc4787>.

   [RFC4987]  Eddy, W., "TCP SYN Flooding Attacks and Common
              Mitigations", RFC 4987, DOI 10.17487/RFC4987, August 2007,
              <https://www.rfc-editor.org/info/rfc4987>.

   [RFC5925]  Touch, J., Mankin, A., and R. Bonica, "The TCP
              Authentication Option", RFC 5925, DOI 10.17487/RFC5925,
              June 2010, <https://www.rfc-editor.org/info/rfc5925>.

   [RFC6888]  Perreault, S., Ed., Yamagata, I., Miyakawa, S., Nakagawa,
              A., and H. Ashida, "Common Requirements for Carrier-Grade
              NATs (CGNs)", BCP 127, RFC 6888, DOI 10.17487/RFC6888,
              April 2013, <https://www.rfc-editor.org/info/rfc6888>.

   [RFC6890]  Cotton, M., Vegoda, L., Bonica, R., Ed., and B. Haberman,
              "Special-Purpose IP Address Registries", BCP 153,
              RFC 6890, DOI 10.17487/RFC6890, April 2013,
              <https://www.rfc-editor.org/info/rfc6890>.

   [RFC7323]  Borman, D., Braden, B., Jacobson, V., and R.
              Scheffenegger, Ed., "TCP Extensions for High Performance",
              RFC 7323, DOI 10.17487/RFC7323, September 2014,
              <https://www.rfc-editor.org/info/rfc7323>.

   [RFC7413]  Cheng, Y., Chu, J., Radhakrishnan, S., and A. Jain, "TCP
              Fast Open", RFC 7413, DOI 10.17487/RFC7413, December 2014,
              <https://www.rfc-editor.org/info/rfc7413>.

   [RFC8126]  Cotton, M., Leiba, B., and T. Narten, "Guidelines for
              Writing an IANA Considerations Section in RFCs", BCP 26,
              RFC 8126, DOI 10.17487/RFC8126, June 2017,
              <https://www.rfc-editor.org/info/rfc8126>.

   [RFC8174]  Leiba, B., "Ambiguity of Uppercase vs Lowercase in RFC
              2119 Key Words", BCP 14, RFC 8174, DOI 10.17487/RFC8174,
              May 2017, <https://www.rfc-editor.org/info/rfc8174>.

   [RFC8684]  Ford, A., Raiciu, C., Handley, M., Bonaventure, O., and C.
              Paasch, "TCP Extensions for Multipath Operation with
              Multiple Addresses", RFC 8684, DOI 10.17487/RFC8684, March
              2020, <https://www.rfc-editor.org/info/rfc8684>.
```

---
### **11.2.  Informative References**

\[ANRW17\] Trammell, B., Kuehlewind, M., De Vaere, P., Learmonth, I. 및 G. Fairhurst, "PATHspider를 사용한 전송 계층 진화 추적", Applied Networking Research Workshop 2017\(ANRW17\), 2017년 7월 .

```text
   [DHC-CONVERTER]
              Boucadair, M., Jacquenet, C., and T. Reddy.K, "DHCP
              Options for 0-RTT TCP Converters", Work in Progress,
              Internet-Draft, draft-boucadair-tcpm-dhc-converter-03, 7
              October 2019, <https://tools.ietf.org/html/draft-
              boucadair-tcpm-dhc-converter-03>.
```

\[후쿠다2011\]

- Fukuda, K., "종단적 TCP 수동 측정 분석\(단편 논문\)", 트래픽 모니터링 및 분석, TMA 2011, 컴퓨터 과학 강의 노트, vol. 6613, 2011.

```text
   [HOT-MIDDLEBOX13]
              Detal, G., Paasch, C., and O. Bonaventure, "Multipath in
              the Middle(Box)", HotMiddlebox'13,
              DOI 10.1145/2535828.2535829, December 2013,
              <https://inl.info.ucl.ac.be/publications/multipath-
              middlebox>.

   [IANA-CONVERT]
              IANA, "TCP Convert Protocol (Convert) Parameters",
              <https://www.iana.org/assignments/tcp-convert-protocol-
              parameters>.
```

\[IETFJ16\] Bonaventure, O., S. Seo, "다중 경로 TCP 배포", IETF Journal, Vol. 2016년 11월 12일 2호.

```text
   [IMC11]    Honda, K., Nishida, Y., Raiciu, C., Greenhalgh, A.,
              Handley, M., and T. Hideyuki, "Is it still possible to
              extend TCP?", Proceedings of the 2011 ACM SIGCOMM
              conference on Internet measurement conference,
              DOI 10.1145/2068816.2068834, November 2011,
              <https://doi.org/10.1145/2068816.2068834>.

   [INTAREA-SOCKS]
              Olteanu, V. and D. Niculescu, "SOCKS Protocol Version 6",
              Work in Progress, Internet-Draft, draft-olteanu-intarea-
              socks-6-10, 13 July 2020, <https://tools.ietf.org/html/
              draft-olteanu-intarea-socks-6-10>.

   [LOW-LATENCY]
              Arkko, J. and J. Tantsura, "Low Latency Applications and
              the Internet Architecture", Work in Progress, Internet-
              Draft, draft-arkko-arch-low-latency-02, 30 October 2017,
              <https://tools.ietf.org/html/draft-arkko-arch-low-latency-
              02>.

   [MPTCP-PLAIN]
              Boucadair, M., Jacquenet, C., Bonaventure, O., Behaghel,
              D., Secci, S., Henderickx, W., Skog, R., Vinapamula, S.,
              Seo, S., Cloetens, W., Meyer, U., Contreras, L., and B.
              Peirens, "Extensions for Network-Assisted MPTCP Deployment
              Models", Work in Progress, Internet-Draft, draft-
              boucadair-mptcp-plain-mode-10, March 2017,
              <https://tools.ietf.org/html/draft-boucadair-mptcp-plain-
              mode-10>.

   [MPTCP-TRANSPARENT]
              Peirens, B., Detal, G., Barre, S., and O. Bonaventure,
              "Link bonding with transparent Multipath TCP", Work in
              Progress, Internet-Draft, draft-peirens-mptcp-transparent-
              00, 8 July 2016, <https://tools.ietf.org/html/draft-
              peirens-mptcp-transparent-00>.

   [RFC1812]  Baker, F., Ed., "Requirements for IP Version 4 Routers",
              RFC 1812, DOI 10.17487/RFC1812, June 1995,
              <https://www.rfc-editor.org/info/rfc1812>.

   [RFC1919]  Chatel, M., "Classical versus Transparent IP Proxies",
              RFC 1919, DOI 10.17487/RFC1919, March 1996,
              <https://www.rfc-editor.org/info/rfc1919>.

   [RFC1928]  Leech, M., Ganis, M., Lee, Y., Kuris, R., Koblas, D., and
              L. Jones, "SOCKS Protocol Version 5", RFC 1928,
              DOI 10.17487/RFC1928, March 1996,
              <https://www.rfc-editor.org/info/rfc1928>.

   [RFC2782]  Gulbrandsen, A., Vixie, P., and L. Esibov, "A DNS RR for
              specifying the location of services (DNS SRV)", RFC 2782,
              DOI 10.17487/RFC2782, February 2000,
              <https://www.rfc-editor.org/info/rfc2782>.

   [RFC3135]  Border, J., Kojo, M., Griner, J., Montenegro, G., and Z.
              Shelby, "Performance Enhancing Proxies Intended to
              Mitigate Link-Related Degradations", RFC 3135,
              DOI 10.17487/RFC3135, June 2001,
              <https://www.rfc-editor.org/info/rfc3135>.

   [RFC4279]  Eronen, P., Ed. and H. Tschofenig, Ed., "Pre-Shared Key
              Ciphersuites for Transport Layer Security (TLS)",
              RFC 4279, DOI 10.17487/RFC4279, December 2005,
              <https://www.rfc-editor.org/info/rfc4279>.

   [RFC5461]  Gont, F., "TCP's Reaction to Soft Errors", RFC 5461,
              DOI 10.17487/RFC5461, February 2009,
              <https://www.rfc-editor.org/info/rfc5461>.

   [RFC6269]  Ford, M., Ed., Boucadair, M., Durand, A., Levis, P., and
              P. Roberts, "Issues with IP Address Sharing", RFC 6269,
              DOI 10.17487/RFC6269, June 2011,
              <https://www.rfc-editor.org/info/rfc6269>.

   [RFC6296]  Wasserman, M. and F. Baker, "IPv6-to-IPv6 Network Prefix
              Translation", RFC 6296, DOI 10.17487/RFC6296, June 2011,
              <https://www.rfc-editor.org/info/rfc6296>.

   [RFC6731]  Savolainen, T., Kato, J., and T. Lemon, "Improved
              Recursive DNS Server Selection for Multi-Interfaced
              Nodes", RFC 6731, DOI 10.17487/RFC6731, December 2012,
              <https://www.rfc-editor.org/info/rfc6731>.

   [RFC6887]  Wing, D., Ed., Cheshire, S., Boucadair, M., Penno, R., and
              P. Selkirk, "Port Control Protocol (PCP)", RFC 6887,
              DOI 10.17487/RFC6887, April 2013,
              <https://www.rfc-editor.org/info/rfc6887>.

   [RFC6928]  Chu, J., Dukkipati, N., Cheng, Y., and M. Mathis,
              "Increasing TCP's Initial Window", RFC 6928,
              DOI 10.17487/RFC6928, April 2013,
              <https://www.rfc-editor.org/info/rfc6928>.

   [RFC6978]  Touch, J., "A TCP Authentication Option Extension for NAT
              Traversal", RFC 6978, DOI 10.17487/RFC6978, July 2013,
              <https://www.rfc-editor.org/info/rfc6978>.

   [RFC7250]  Wouters, P., Ed., Tschofenig, H., Ed., Gilmore, J.,
              Weiler, S., and T. Kivinen, "Using Raw Public Keys in
              Transport Layer Security (TLS) and Datagram Transport
              Layer Security (DTLS)", RFC 7250, DOI 10.17487/RFC7250,
              June 2014, <https://www.rfc-editor.org/info/rfc7250>.

   [RFC7414]  Duke, M., Braden, R., Eddy, W., Blanton, E., and A.
              Zimmermann, "A Roadmap for Transmission Control Protocol
              (TCP) Specification Documents", RFC 7414,
              DOI 10.17487/RFC7414, February 2015,
              <https://www.rfc-editor.org/info/rfc7414>.

   [RFC8041]  Bonaventure, O., Paasch, C., and G. Detal, "Use Cases and
              Operational Experience with Multipath TCP", RFC 8041,
              DOI 10.17487/RFC8041, January 2017,
              <https://www.rfc-editor.org/info/rfc8041>.

   [RFC8305]  Schinazi, D. and T. Pauly, "Happy Eyeballs Version 2:
              Better Connectivity Using Concurrency", RFC 8305,
              DOI 10.17487/RFC8305, December 2017,
              <https://www.rfc-editor.org/info/rfc8305>.

   [RFC8446]  Rescorla, E., "The Transport Layer Security (TLS) Protocol
              Version 1.3", RFC 8446, DOI 10.17487/RFC8446, August 2018,
              <https://www.rfc-editor.org/info/rfc8446>.

   [RFC8548]  Bittau, A., Giffin, D., Handley, M., Mazieres, D., Slack,
              Q., and E. Smith, "Cryptographic Protection of TCP Streams
              (tcpcrypt)", RFC 8548, DOI 10.17487/RFC8548, May 2019,
              <https://www.rfc-editor.org/info/rfc8548>.

   [TCPM-CONVERTER]
              Boucadair, M. and C. Jacquenet, "RADIUS Extensions for
              0-RTT TCP Converters", Work in Progress, Internet-Draft,
              draft-boucadair-opsawg-tcpm-converter-01, 28 February
              2020, <https://tools.ietf.org/html/draft-boucadair-opsawg-
              tcpm-converter-01>.

   [TS23501]  3GPP (3rd Generation Partnership Project), "Technical
              Specification Group Services and System Aspects; System
              architecture for the 5G System; Stage 2 (Release 16)",
              2019, <https://www.3gpp.org/ftp/Specs/
              archive/23_series/23.501/>.
```

부록 A. 0-RTT TCP 변환 프로토콜을 지원하기 위한 소켓 API 변경 예

---
### **A.1.  Active Open (Client Side)**

클라이언트 측에서 0-RTT 변환기 프로토콜 지원에는 \[RFC7413\]의 부록 A에 식별된 변경 사항 외에 다른 변경 사항이 필요하지 않습니다. 이러한 수정 사항은 이미 여러 TCP 스택에서 지원됩니다.

예를 들어, Linux에서 클라이언트는 아래 예와 같이 MSG\_FASTOPEN 플래그와 함께 sendto를 사용하여 SYN 내에서 0-RTT 변환 메시지를 보낼 수 있습니다.

```text
     s = socket(AF_INET, SOCK_STREAM, 0);

     sendto(s, buffer, buffer_len, MSG_FASTOPEN,
                    (struct sockaddr *) &server_addr, addr_len);
```

Linux TFO의 클라이언트측은 호스트 구성\(sysctl tcp\_fastopen 변수\)에 따라 두 가지 다른 모드로 사용될 수 있습니다.

0x1: \(클라이언트\) 클라이언트의 시작 SYN에서 데이터 전송을 활성화합니다.

0x4: \(클라이언트\) 쿠키 가용성에 관계없이 쿠키 옵션 없이 시작 SYN에서 데이터 전송을 활성화합니다.

이 구성 변수를 0x5로 설정하면 위 코드를 사용하는 Linux 클라이언트는 TFO 옵션을 사용하지 않고 SYN 내부에 데이터를 보냅니다.

---
### **A.2.  Passive Open (Converter Side)**

변환기는 TFO 옵션 활용과 관계없이 SYN 내부의 데이터 수신을 활성화해야 합니다. 이는 전송 변환기 애플리케이션이 Fast Open Cookies에 의존하여 SYN을 보낸 IP 주소의 연결 가능성을 확인할 수 없음을 의미합니다. 이 연결 가능성을 확인하려면 이 문서에 설명된 쿠키 TLV와 같은 다른 기술을 사용해야 합니다.

\[RFC7413\]은 데이터가 포함된 SYN의 수신을 활성화하기 위해 TCP\_FASTOPEN 소켓 옵션의 활용을 제안했습니다. 나중에 \[RFC7413\]의 부록 A에서는 다음과 같이 언급했습니다.

| 전통적으로 accept\(\)는 소켓이 연결된 후에만 반환합니다. | 그러나 Fast Open 연결의 경우 accept\(\)는 | 유효한 Fast Open 쿠키 및 데이터와 SYN을 수행하며 데이터는 | 예를 들어, recvmsg\(\), read\(\)를 통해 읽을 수 있습니다.

0-RTT TCP 변환 프로토콜을 지원하려면 이 동작을 다음과 같이 수정해야 합니다.

| 전통적으로 accept\(\)는 소켓이 연결된 후에만 반환합니다. | 그러나 Fast Open 연결의 경우 accept\(\)는 | 데이터와 SYN을 수행하며 데이터를 읽을 수 있습니다\(예: | Recvmsg\(\), 읽기\(\). | 데이터는 소스의 도달 가능성을 검증할 수 있어야 합니다. | SYN을 처리하고 재생된 SYN도 처리합니다.

Linux 서버 측은 다음 sysctls를 사용하여 구성할 수 있습니다.

0x2: \(서버\) 서버 지원을 활성화합니다. 즉, 3방향 핸드셰이크가 완료되기 전에 SYN 패킷의 데이터가 승인되어 애플리케이션에 전달되도록 허용합니다.

```text
   0x200:  (server) accepts data-in-SYN w/o any cookie option present.
```

그러나 이 구성은 시스템 전체에 적용됩니다. 이는 TFO에 의존하는 다른 애플리케이션이 동일한 장치에 함께 배치되지 않는 일반적인 Transport Converter 배포에 편리합니다.

최근에는 소켓별로 동일한 동작을 제공하기 위해 TCP\_FASTOPEN\_NO\_COOKIE 소켓 옵션이 추가되었습니다. 이를 통해 단일 호스트는 Fast Open Cookie가 필요한 서버와 이를 사용하지 않는 서버를 모두 지원할 수 있습니다.

---
# **Acknowledgments**

문서의 내용에 동의하지 않을 수도 있지만 MPTCP 메일링 리스트에 대한 의견을 통해 솔루션 설계를 여러 번 재고하게 만든 Joe Touch와 Juliusz Chroboczek에게 감사의 말씀을 전하고 싶습니다.

이 문서를 준비하는 데 도움을 준 Raphael Bauduin, Stefano Secci, Anandatirtha Nandugudi 및 Gregory Vander Schueren에게 감사의 말씀을 전하고 싶습니다. Nandini Ganesh는 TFO 및 오류 코드 처리에 대한 귀중한 피드백을 제공했습니다. Yuchung Cheng과 Praveen Balasubramanian은 SYN의 데이터 제공에 대한 논의를 명확하게 하는 데 도움을 주었습니다. Phil Eardley와 Michael Scharf는 텍스트의 다양한 부분을 명확하게 하는 데 도움을 주었습니다. IESG 검토를 담당한 Éric Vyncke, Roman Danyliw, Benjamin Kaduk, Alexey Melnikov에게 감사를 표하고 Security Directorate 검토를 담당한 Christian Huitema에게 감사드립니다.

상세한 AD 검토를 해주신 Mirja Kühlewind에게 많은 감사를 드립니다.

이 문서는 다양한 형태의 다중 경로 TCP 프록시\(\[MPTCP-PLAIN\], \[MPTCP-TRANSPARENT\] 및 \[HOT-MIDDLEBOX13\]\)를 제안한 이전 문서를 기반으로 작성되었습니다.

\[MPTCP-PLAIN\]에서:

귀중한 의견을 주신 Chi Dung Phung, Mingui Zhang, Rao Shoaib, Yoshifumi Nishida 및 Christoph Paasch에게 많은 감사를 드립니다.

IETF 95\(부에노스아이레스\)에서 유익한 토론을 해주신 Ian Farrer, Mikael Abrahamsson, Alan Ford, Dan Wing 및 Sri Gundavelli에게 감사드립니다.

의견을 주신 Pierrick Seite, Yannick Le Goff, Fred Klamm 및 Xavier Grall에게 특별히 감사드립니다.

의견을 주신 Olaf Schleusing, Martin Gysi, Thomas Zasowski, Andreas Burkhard, Silka Simmen, Sandro Berger, Michael Melloul, Jean-Yves Flahaut, Adrien Desportes, Gregory Detal, Benjamin David, Arun Srinivasan 및 Raghavendra Mallya에게도 감사드립니다.

---
# **Contributors**

Bart Peirens는 이 문서의 초기 초안 버전에 기여했습니다.

위에서 언급한 것처럼 이 문서는 이전 두 문서를 기반으로 작성되었습니다.

\[MPTCP-PLAIN\]의 작성자는 다음과 같습니다.

```text
   *  Mohamed Boucadair

   *  Christian Jacquenet

   *  Olivier Bonaventure

   *  Denis Behaghel

   *  Stefano Secci

   *  Wim Henderickx

   *  Robert Skog

   *  Suresh Vinapamula

   *  SungHoon Seo

   *  Wouter Cloetens

   *  Ullrich Meyer

   *  Luis M. Contreras

   *  Bart Peirens
```

\[MPTCP-TRANSPARENT\]의 작성자는 다음과 같습니다.

```text
   *  Bart Peirens

   *  Gregory Detal

   *  Sebastien Barre

   *  Olivier Bonaventure
```

---
# **Authors' Addresses**

```text
   Olivier Bonaventure (editor)
   Tessares
   Avenue Jean Monnet 1
   B-1348 Louvain-la-Neuve
   Belgium

   Email: Olivier.Bonaventure@tessares.net

   Mohamed Boucadair (editor)
   Orange
   Clos Courtel
   35000 Rennes
   France

   Email: mohamed.boucadair@orange.com
```

스리 군다벨리 Cisco 170 West Tasman Drive San Jose, CA 95134 미국

```text
   Email: sgundave@cisco.com
```

서성훈 한국통신 서울시 서초구 태봉로 151 \(06763\)

```text
   Email: sh.seo@kt.com

   Benjamin Hesmans
   Tessares
   Avenue Jean Monnet 1
   B-1348 Louvain-la-Neuve
   Belgium

   Email: Benjamin.Hesmans@tessares.net
```
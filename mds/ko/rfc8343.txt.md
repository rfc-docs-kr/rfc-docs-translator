

```text
Internet Engineering Task Force (IETF)                      M. Bjorklund
Request for Comments: 8343                                Tail-f Systems
Obsoletes: 7223                                               March 2018
Category: Standards Track
ISSN: 2070-1721
```

- 인터페이스 관리를 위한 YANG 데이터 모델

---
# **Abstract**

이 문서는 네트워크 인터페이스 관리를 위한 YANG 데이터 모델을 정의합니다. 인터페이스 유형별 데이터 모델은 이 문서에 정의된 일반 인터페이스 데이터 모델을 확장할 것으로 예상됩니다. 데이터 모델에는 구성 및 시스템 상태에 대한 정의\(상태 정보 및 통계 수집을 위한 카운터\)가 포함됩니다.

이 문서의 YANG 데이터 모델은 RFC 8342에 정의된 NMDA\(Network Management Datastore Architecture\)를 준수합니다.

이 문서는 RFC 7223을 폐기합니다.

---
# **Status of This Memo**

이것은 인터넷 표준 추적 문서입니다.

이 문서는 IETF\(Internet Engineering Task Force\)의 제품입니다. 이는 IETF 커뮤니티의 합의를 나타냅니다. 공개 검토를 받았으며 IESG\(Internet Engineering Steering Group\)의 출판 승인을 받았습니다. 인터넷 표준에 대한 자세한 내용은 RFC 7841의 섹션 2에서 확인할 수 있습니다.

이 문서의 현재 상태, 정오표, 피드백 제공 방법에 대한 정보는 https://www.rfc-editor.org/info/rfc8343에서 얻을 수 있습니다.

---
# **Copyright Notice**

Copyright \(c\) 2018 IETF Trust 및 문서 작성자로 확인된 사람. 판권 소유.

이 문서는 이 문서의 발행일에 유효한 BCP 78 및 IETF 문서에 관한 IETF 트러스트의 법적 조항\(https://trustee.ietf.org/license-info\)의 적용을 받습니다. 이 문서와 관련된 귀하의 권리 및 제한 사항을 설명하므로 이 문서를 주의 깊게 검토하십시오. 이 문서에서 추출한 코드 구성 요소는 Trust Legal Provisions의 섹션 4.e에 설명된 대로 Simplified BSD License 텍스트를 포함해야 하며 Simplified BSD License에 설명된 대로 보증 없이 제공됩니다.

---
# **Table of Contents**

```text
   1. Introduction ....................................................3
      1.1. Summary of Changes from RFC 7223 ...........................3
      1.2. Terminology ................................................3
      1.3. Tree Diagrams ..............................................4
   2. Objectives ......................................................5
   3. Interfaces Data Model ...........................................5
      3.1. The Interface List .........................................6
      3.2. Interface References .......................................8
      3.3. Interface Layering .........................................8
   4. Relationship to the IF-MIB ......................................9
   5. Interfaces YANG Module .........................................10
   6. IANA Considerations ............................................34
   7. Security Considerations ........................................35
   8. References .....................................................36
      8.1. Normative References ......................................36
      8.2. Informative References ....................................37
   Appendix A.  Example: Ethernet Interface Module ...................38
   Appendix B.  Example: Ethernet Bonding Interface Module ...........39
   Appendix C.  Example: VLAN Interface Module .......................40
   Appendix D.  Example: NETCONF <get-config> Reply ..................41
   Appendix E.  Example: NETCONF <get-data> Reply ....................42
   Appendix F.  Examples: Interface Naming Schemes ...................44
     F.1.  Router with Restricted Interface Names ....................44
     F.2.  Router with Arbitrary Interface Names .....................45
     F.3.  Ethernet Switch with Restricted Interface Names ...........46
     F.4.  Generic Host with Restricted Interface Names ..............47
     F.5.  Generic Host with Arbitrary Interface Names ...............48
   Acknowledgments ...................................................49
   Author's Address ..................................................49
```

---
## **1.  Introduction**

이 문서는 네트워크 인터페이스 관리를 위한 YANG 데이터 모델 \[RFC7950\]을 정의합니다. 인터페이스 유형별 데이터 모델은 이 문서에 정의된 일반 인터페이스 데이터 모델을 확장할 것으로 예상됩니다.

네트워크 인터페이스는 많은 인터넷 프로토콜 관리의 핵심입니다. 따라서 인터페이스를 식별, 구성 및 모니터링하는 방법에 대한 공통 데이터 모델을 설정하는 것이 중요합니다.

데이터 모델에는 구성 데이터와 상태 데이터\(통계 수집을 위한 상태 정보 및 카운터\)가 포함됩니다.

이 버전의 인터페이스 데이터 모델은 NMDA\(Network Management Datastore Architecture\) \[RFC8342\]를 지원합니다.

---
### **1.1.  Summary of Changes from RFC 7223**

"config false" 데이터 노드가 있는 "/interfaces-state" 하위 트리는 더 이상 사용되지 않습니다. 이제 모든 "config false" 데이터 노드가 "/interfaces" 하위 트리에 있습니다.

NMDA를 구현하지 않거나 NMDA를 구현하지 않는 클라이언트를 지원하려는 서버는 더 이상 사용되지 않는 "/interfaces-state" 트리를 구현할 수 있습니다.\(MAY\)

---
### **1.2.  Terminology**

키워드 "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY" 및 "OPTIONAL" "는 BCP 14 \[RFC2119\] \[RFC8174\]에 설명된 대로 여기에 표시된 것처럼 모두 대문자로 표시되는 경우에만 해석됩니다.\(MUST NOT\)

이 문서에서는 다음 용어가 사용됩니다.

o 시스템 제어 인터페이스: 명시적으로 구성된 것과 관계없이 시스템이 인터페이스를 생성하고 삭제하는 경우 인터페이스는 시스템 제어 인터페이스라고 합니다. 예를 들어 하드웨어\(예: 라인 카드 또는 핫 플러그형 무선 인터페이스\)가 추가되거나 제거될 때 나타나고 사라지는 물리적 하드웨어를 나타내는 인터페이스가 있습니다. 특정 기능이 활성화된 경우 시스템 제어 인터페이스가 나타날 수도 있습니다\(예: IP 프로토콜 스택이 활성화된 경우 루프백 인터페이스가 나타날 수 있음\).

o 사용자 제어 인터페이스: 의도한 구성에 명시적 인터페이스 구성을 추가하여 인터페이스 생성이 제어되고, 의도된 구성에서 명시적 인터페이스 구성을 제거하여 인터페이스 제거가 제어되는 경우 인터페이스를 사용자 제어라고 합니다. 예를 들어 시스템 제어 이더넷 인터페이스에 구성된 VLAN 인터페이스가 있습니다.

다음 용어는 \[RFC8342\]에 정의되어 있으며 여기서는 재정의되지 않습니다.

```text
   o  client

   o  server

   o  configuration

   o  system state

   o  operational state

   o  intended configuration

   o  running configuration datastore

   o  operational state datastore
```

다음 용어는 \[RFC7950\]에 정의되어 있으며 여기서는 재정의되지 않습니다.

```text
   o  augment

   o  data model

   o  data node
```

---
### **1.3.  Tree Diagrams**

이 문서에 사용된 트리 다이어그램은 \[RFC8340\]에 정의된 표기법을 따릅니다.

---
## **2.  Objectives**

이 섹션에서는 섹션 5에 제시된 모델의 설계 목표 중 일부를 설명합니다.

o 기존 구현은 이 메모에 정의된 인터페이스 데이터 모델을 고유한 기본 데이터 모델에 매핑해야 한다는 것이 인식됩니다. 이러한 매핑을 용이하게 하려면 데이터 모델이 단순해야 합니다.

o 데이터 모델은 다른 기본 모델에 대한 매핑을 요구하지 않고 있는 그대로 사용하기 위해 새로운 구현에 적합해야 합니다.

o 인터페이스에 대한 참조는 최대한 단순해야 합니다.

- 단일 리프 참조를 사용하는 것이 바람직합니다.

o 인터페이스를 식별하기 위해 SNMP\(Simple Network Management Protocol\)에서 사용하는 ifIndex \[RFC2863\]에 대한 매핑이 명확해야 합니다.

o 모델은 인터페이스 계층화를 지원해야 합니다. \(1\) 하나의 인터페이스가 정확히 하나의 다른 인터페이스 위에 계층화되는 단순한 계층화와 \(2\) 하나의 인터페이스가 N개의 다른 인터페이스 집합에서 발생하거나 N개의 인터페이스가 생성되는 더 복잡한 시나리오 모두를 지원해야 합니다. 인터페이스는 다른 인터페이스를 통해 다중화됩니다.

o 데이터 모델은 인터페이스 구성의 사전 프로비저닝을 지원해야 합니다. 즉, 물리적 인터페이스 하드웨어가 장치에 존재하지 않는 인터페이스를 구성하는 것이 가능해야 합니다. 물리적 인터페이스의 동적 추가 및 제거를 지원하는 장치는 사전 프로비저닝도 지원하는 것이 좋습니다.

o 데이터 모델은 논리적 인터페이스뿐만 아니라 물리적 인터페이스도 지원해야 합니다.

o 데이터 모델에는 전송 및 수신된 옥텟과 패킷, 오류가 있는 수신 패킷, 오류로 인해 전송할 수 없는 패킷에 대한 통계를 수집하기 위한 읽기 전용 카운터가 포함되어야 합니다.

---
## **3.  Interfaces Data Model**

이 문서는 더 이상 사용되지 않는 "/interfaces-state" 하위 트리를 제외하고 다음 구조를 갖는 YANG 모듈 "ietf-interfaces"를 정의합니다.

```text
   module: ietf-interfaces
     +--rw interfaces
        +--rw interface* [name]
           +--rw name                        string
           +--rw description?                string
           +--rw type                        identityref
           +--rw enabled?                    boolean
           +--rw link-up-down-trap-enable?   enumeration {if-mib}?
           +--ro admin-status                enumeration {if-mib}?
           +--ro oper-status                 enumeration
           +--ro last-change?                yang:date-and-time
           +--ro if-index                    int32 {if-mib}?
           +--ro phys-address?               yang:phys-address
           +--ro higher-layer-if*            interface-ref
           +--ro lower-layer-if*             interface-ref
           +--ro speed?                      yang:gauge64
           +--ro statistics
              +--ro discontinuity-time    yang:date-and-time
              +--ro in-octets?            yang:counter64
              +--ro in-unicast-pkts?      yang:counter64
              +--ro in-broadcast-pkts?    yang:counter64
              +--ro in-multicast-pkts?    yang:counter64
              +--ro in-discards?          yang:counter32
              +--ro in-errors?            yang:counter32
              +--ro in-unknown-protos?    yang:counter32
              +--ro out-octets?           yang:counter64
              +--ro out-unicast-pkts?     yang:counter64
              +--ro out-broadcast-pkts?   yang:counter64
              +--ro out-multicast-pkts?   yang:counter64
              +--ro out-discards?         yang:counter32
              +--ro out-errors?           yang:counter32
```

---
### **3.1.  The Interface List**

이 문서에 제시된 인터페이스의 데이터 모델은 단순 인터페이스 목록\("/인터페이스/인터페이스"\)을 사용합니다. 목록의 각 인터페이스는 해당 이름으로 식별됩니다. 또한 각 인터페이스에는 필수 "유형" 리프가 있습니다.

"iana-if-type" 모듈 \[RFC7224\]은 IANA가 관리하는 "ifType 정의" 레지스트리의 인터페이스 유형에 대한 YANG ID를 정의합니다.

인터페이스 유형별 데이터 모델은 인터페이스 목록을 확장하고 "유형" 리프를 사용하여 확장을 조건부로 만들 수 있을 것으로 예상됩니다.

이러한 인터페이스 유형별 확장의 예로 다음 YANG 조각을 고려하세요. 더 완전한 예를 보려면 부록 A를 참조하세요.

```text
     import interfaces {
         prefix "if";
     }
     import iana-if-type {
       prefix ianaift;
     }

     augment "/if:interfaces/if:interface" {
         when "if:type = 'ianaift:ethernetCsmacd'";

         container ethernet {
             leaf duplex {
                 ...
             }
         }
     }
```

시스템 제어 인터페이스의 경우 "이름"은 인터페이스의 장치별 이름입니다.

장치가 임의로 이름이 지정된 사용자 제어 인터페이스를 지원하는 경우 서버는 "임의 이름" 기능을 광고합니다. 서버가 이 기능을 광고하지 않는 경우 사용자 제어 인터페이스의 이름은 장치의 명명 체계와 일치해야 합니다. 클라이언트가 그러한 장치의 명명 체계를 배울 수 있는 방법은 이 문서의 범위를 벗어납니다. 예제는 부록 F.1 및 F.2를 참조하세요.\(MUST\)

시스템 제어 인터페이스가 시스템에 의해 작동 상태로 생성되면 시스템은 새 인터페이스와 동일한 이름을 사용하여 의도한 구성의 인터페이스 구성을 적용하려고 시도합니다. 해당 인터페이스 구성이 없거나 구성된 유형이 실제 인터페이스 유형과 일치하지 않는 경우 시스템은 명시적 구성을 적용하지 않고 인터페이스를 생성합니다.

사용자 제어 인터페이스가 생성되면 구성에 따라 인터페이스 이름이 결정됩니다.

운영 체제와 네트워크 인터페이스가 연결되거나 제거될 수 있는 물리적 연결 지점에 따라 구현이 삽입/제거 주기 전반에 걸쳐 시스템 제어 인터페이스에 대해 예측 가능하고 일관된 이름을 제공하는 것이 불가능할 수 있습니다. 초기 삽입. 따라서 이러한 인터페이스에 대한 구성을 제공하는 기능은 구현에 따라 달라지며 모든 경우에 가정할 수는 없습니다.

---
### **3.2.  Interface References**

인터페이스는 서버 내에서 고유한 이름으로 식별됩니다. 이 속성은 다른 YANG 모듈이 인터페이스를 참조해야 할 때 사용해야 하는 "interface-ref" typedef에 캡처됩니다.\(SHOULD\)

---
### **3.3.  Interface Layering**

인터페이스가 다른 인터페이스 위에 계층화되도록 구성하는 방법에 대한 일반적인 메커니즘은 없습니다. 인터페이스 유형별 모델은 하위 계층을 참조하기 위해 "interface-ref" 유형을 사용하여 인터페이스 계층화를 위한 자체 데이터 노드를 정의할 것으로 예상됩니다.

다음은 이러한 노드가 있는 모델의 예입니다. 더 완전한 예를 보려면 부록 B를 참조하세요.

```text
     import interfaces {
         prefix "if";
     }
     import iana-if-type {
       prefix ianaift;
     }

     augment "/if:interfaces/if:interface" {
         when "if:type = 'ianaift:ieee8023adLag'";

         leaf-list slave-if {
             type if:interface-ref;
             must "/if:interfaces/if:interface[if:name = current()]"
                + "/if:type = 'ianaift:ethernetCsmacd'" {
                 description
                     "The type of a slave interface must be
                      'ethernetCsmacd'.";
             }
         }
         // other bonding config params, failover times, etc.
     }
```

인터페이스 계층화는 인터페이스 유형별 모델로 구성되지만 두 개의 일반 상태 데이터 리프 목록인 "higher-layer-if" 및 "lower-layer-if"는 인터페이스 계층화 계층 구조의 읽기 전용 보기를 나타냅니다.

---
## **4.  Relationship to the IF-MIB**

장치가 IF-MIB \[RFC2863\]를 구현하는 경우 작동 상태의 "/interfaces/interface" 목록에 있는 각 항목은 일반적으로 하나의 ifEntry에 매핑됩니다. "if-index" 리프에는 해당 ifEntry의 ifIndex 값이 포함되어야 합니다.\(MUST\)

대부분의 경우 "/interfaces/interface" 항목의 "이름"은 ifName에 매핑됩니다. IF-MIB에서는 두 개의 서로 다른 ifEntries가 동일한 ifName을 가질 수 있습니다. 이 기능을 지원하고 이 문서에 정의된 데이터 모델도 지원하는 장치는 "name" 리프와 ifName 간에 1-1 매핑을 가질 수 없습니다.

"인터페이스"의 구성된 "설명"은 전통적으로 일부 구현에서 ifAlias에 매핑되었습니다. 이 문서에서는 이 매핑을 허용하지만 구현자는 이러한 개체의 값 공간과 지속성의 차이점을 알고 있어야 합니다. 자세한 내용은 섹션 5의 리프 "설명"에 대한 YANG 모듈 정의를 참조하세요.

IF-MIB는 쓰기 가능한 개체인 ifPromiscuousMode도 정의합니다. 이 개체는 일반적으로 SNMP 에이전트에 의해 구성 개체로 구현되지 않으므로 "ietf-interfaces" 모듈에 매핑되지 않습니다.

IF-MIB의 ifMtu 개체는 "ietf-interfaces" 모듈에 매핑되지 않습니다. 인터페이스 유형별 YANG 모듈은 "ietf-interfaces" 모델을 확장하여 인터페이스 유형별 MTU 리프를 제공할 것으로 예상됩니다.

IF-MIB에는 두 가지 버전, 즉 32비트 버전과 64비트 버전으로 존재하는 여러 카운터가 있습니다. 64비트 버전은 20,000,000비트/초 이상의 데이터 속도로 고속 인터페이스를 지원하기 위해 추가되었습니다. 오늘날의 구현은 일반적으로 이러한 고속 인터페이스를 지원합니다. 따라서 이 데이터 모델에는 64비트 카운터만 제공됩니다. 이 모듈을 구현하는 서버와 SNMP 에이전트는 카운터에 대한 액세스를 제공하는 시간 단위가 다를 수 있습니다. 예를 들어, SNMP 구현은 일정 시간 동안 카운터 값을 캐시하는 것이 일반적입니다.

IF-MIB의 ifDescr 및 ifConnectorPresent 객체는 "ietf-interfaces" 모듈에 매핑되지 않습니다.

다음 표에는 IF-MIB의 해당 개체와 함께 YANG 데이터 노드가 나열되어 있습니다.

```text
   +--------------------------------------+----------------------------+
   | YANG data node in                    | IF-MIB object              |
   | /interfaces/interface                |                            |
   +--------------------------------------+----------------------------+
   | name                                 | ifName                     |
   | type                                 | ifType                     |
   | description                          | ifAlias                    |
   | admin-status                         | ifAdminStatus              |
   | oper-status                          | ifOperStatus               |
   | last-change                          | ifLastChange               |
   | if-index                             | ifIndex                    |
   | link-up-down-trap-enable             | ifLinkUpDownTrapEnable     |
   | phys-address                         | ifPhysAddress              |
   | higher-layer-if and lower-layer-if   | ifStackTable               |
   | speed                                | ifSpeed and ifHighSpeed    |
   | discontinuity-time                   | ifCounterDiscontinuityTime |
   | in-octets                            | ifHCInOctets               |
   | in-unicast-pkts                      | ifHCInUcastPkts            |
   | in-broadcast-pkts                    | ifHCInBroadcastPkts        |
   | in-multicast-pkts                    | ifHCInMulticastPkts        |
   | in-discards                          | ifInDiscards               |
   | in-errors                            | ifInErrors                 |
   | in-unknown-protos                    | ifInUnknownProtos          |
   | out-octets                           | ifHCOutOctets              |
   | out-unicast-pkts                     | ifHCOutUcastPkts           |
   | out-broadcast-pkts                   | ifHCOutBroadcastPkts       |
   | out-multicast-pkts                   | ifHCOutMulticastPkts       |
   | out-discards                         | ifOutDiscards              |
   | out-errors                           | ifOutErrors                |
   +--------------------------------------+----------------------------+

                YANG Data Nodes and Related IF-MIB Objects
```

---
## **5.  Interfaces YANG Module**

이 YANG 모듈은 \[RFC6991\]에서 typedef를 가져옵니다.

```text
   <CODE BEGINS> file "ietf-interfaces@2018-02-20.yang"

   module ietf-interfaces {
     yang-version 1.1;
     namespace "urn:ietf:params:xml:ns:yang:ietf-interfaces";
     prefix if;

     import ietf-yang-types {
       prefix yang;
     }

     organization
       "IETF NETMOD (Network Modeling) Working Group";

     contact
       "WG Web:   <https://datatracker.ietf.org/wg/netmod/>
        WG List:  <mailto:netmod@ietf.org>

        Editor:   Martin Bjorklund
                  <mailto:mbj@tail-f.com>";
```

설명

- "이 모듈에는 네트워크 인터페이스 관리를 위한 YANG 정의 컬렉션이 포함되어 있습니다.

- Copyright \(c\) 2018 IETF Trust 및 코드 작성자로 식별된 사람. 판권 소유.

- 수정 여부에 관계없이 소스 및 바이너리 형식의 재배포 및 사용은 IETF 문서와 관련된 IETF Trust 법률 조항 섹션 4.c에 명시된 Simplified BSD 라이센스에 포함된 라이센스 조건에 따라 허용됩니다. \(https://trustee.ietf.org/license-info\).

```text
        This version of this YANG module is part of RFC 8343; see
        the RFC itself for full legal notices.";

     revision 2018-02-20 {
       description
         "Updated to support NMDA.";
       reference
         "RFC 8343: A YANG Data Model for Interface Management";
     }

     revision 2014-05-08 {
       description
         "Initial revision.";
       reference
         "RFC 7223: A YANG Data Model for Interface Management";
     }

     /*
      * Typedefs
      */

     typedef interface-ref {
       type leafref {
         path "/if:interfaces/if:interface/if:name";

       }
       description
         "This type is used by data models that need to reference
          interfaces.";
     }

     /*
      * Identities
      */

     identity interface-type {
       description
         "Base identity from which specific interface types are
          derived.";
     }

     /*
      * Features
      */

     feature arbitrary-names {
       description
         "This feature indicates that the device allows user-controlled
          interfaces to be named arbitrarily.";
     }
     feature pre-provisioning {
       description
         "This feature indicates that the device supports
          pre-provisioning of interface configuration, i.e., it is
          possible to configure an interface whose physical interface
          hardware is not present on the device.";
     }
     feature if-mib {
       description
         "This feature indicates that the device implements
          the IF-MIB.";
       reference
         "RFC 2863: The Interfaces Group MIB";
     }

     /*
      * Data nodes
      */

     container interfaces {
       description
         "Interface parameters.";

       list interface {
         key "name";
```

설명

- "장치의 인터페이스 목록입니다.

- 인터페이스의 상태는 작동 상태에서 이 목록에서 확인할 수 있습니다. 시스템 제어 인터페이스의 구성을 시스템에서 사용할 수 없는 경우\(예: 존재하는 인터페이스 하드웨어가 인터페이스 유형과 일치하지 않는 경우\) 해당 구성은 작동 상태에 표시된 시스템 제어 인터페이스에 적용되지 않습니다. 사용자 제어 인터페이스의 구성을 시스템에서 사용할 수 없는 경우 구성된 인터페이스는 작동 상태에서 인스턴스화되지 않습니다.

```text
            System-controlled interfaces created by the system are
            always present in this list in the operational state,
            whether or not they are configured.";
```

잎 이름 {

- 문자열을 입력하세요. 설명 "인터페이스의 이름입니다.

- 장치는 인터페이스 유형에 따라 이 리프에 허용되는 값을 제한할 수 있습니다. 시스템 제어 인터페이스의 경우 이 리프는 인터페이스의 장치별 이름입니다.\(MAY\)

클라이언트가

- 작동 상태에 존재하지 않는 시스템 제어 인터페이스, 구현이 인터페이스의 사전 프로비저닝을 지원하지 않거나 이름이 시스템에 절대 존재할 수 없는 인터페이스를 참조하는 경우 서버는 요청을 거부할 수 있습니다. 이 경우 NETCONF\(네트워크 구성 프로토콜\) 서버는 오류 태그 '잘못된 값'이 포함된 rpc-error로 응답해야 합니다.\(MAY, MUST\)

- 장치가 인터페이스 구성의 사전 프로비저닝을 지원하는 경우 '사전 프로비저닝' 기능이 광고됩니다.

- 장치가 임의로 명명된 사용자 제어 인터페이스를 허용하는 경우 '임의 이름' 기능이 광고됩니다.

- 구성된 사용자 제어 인터페이스가 시스템에 의해 생성되면 작동 상태에서 동일한 이름으로 인스턴스화됩니다.

```text
              A server implementation MAY map this leaf to the ifName
              MIB object.  Such an implementation needs to use some
              mechanism to handle the differences in size and characters
              allowed between this leaf and ifName.  The definition of
              such a mechanism is outside the scope of this document.";
           reference
             "RFC 2863: The Interfaces Group MIB - ifName";
         }
```

잎 설명 {

- 문자열을 입력하세요. 설명 "인터페이스에 대한 텍스트 설명입니다.

- 서버 구현은 이 리프를 ifAlias ​​MIB 개체에 매핑할 수 있습니다. 이러한 구현에서는 이 리프와 ifAlias ​​간에 허용되는 크기 및 문자의 차이를 처리하기 위해 일부 메커니즘을 사용해야 합니다. 그러한 메커니즘의 정의는 이 문서의 범위를 벗어납니다.\(MAY\)

```text
              Since ifAlias is defined to be stored in non-volatile
              storage, the MIB implementation MUST map ifAlias to the
              value of 'description' in the persistently stored
              configuration.";
           reference
             "RFC 2863: The Interfaces Group MIB - ifAlias";
         }
```

잎 유형 {

- 유형 신원 참조 { 기본 인터페이스 유형; } 필수 true; 설명 "인터페이스의 유형입니다.

인터페이스 항목이 생성되면 서버는 다음을 수행할 수 있습니다.

- 유효한 값으로 유형 리프를 초기화합니다\(예: 인터페이스 이름에서 유형을 파생시킬 수 있는 경우\).\(MAY\)

```text
              If a client tries to set the type of an interface to a
              value that can never be used by the system, e.g., if the
              type is not supported or if the type does not match the

              name of the interface, the server MUST reject the request.
              A NETCONF server MUST reply with an rpc-error with the
              error-tag 'invalid-value' in this case.";
           reference
             "RFC 2863: The Interfaces Group MIB - ifType";
         }
```

리프 활성화 {

- 부울 유형; 기본값은 "참"입니다. 설명 "이 리프에는 구성된 원하는 인터페이스 상태가 포함되어 있습니다.

- IF-MIB를 구현하는 시스템은 RFC 2863에 설명된 대로 ifEntry가 초기화된 후 IF-MIB.ifAdminStatus를 'up' 또는 'down'으로 설정하기 위해 의도된 구성에서 이 리프의 값을 사용합니다.

```text
              Changes in this leaf in the intended configuration are
              reflected in ifAdminStatus.";
           reference
             "RFC 2863: The Interfaces Group MIB - ifAdminStatus";
         }
```

리프 링크 업 다운 트랩 활성화 {

- if-feature if-mib; 유형 열거형 { 열거형 활성화됨 { 값 1; 설명 "장치는 이 인터페이스에 대한 linkUp/linkDown SNMP 알림을 생성합니다."; } 열거형 비활성화됨 { 값 2; 설명 "장치는 이 인터페이스에 대한 linkUp/linkDown SNMP 알림을 생성하지 않습니다."; } } 설명 "이 인터페이스에 대해 linkUp/linkDown SNMP 알림을 생성해야 하는지 여부를 제어합니다.

```text
              If this node is not configured, the value 'enabled' is
              operationally used by the server for interfaces that do
              not operate on top of any other interface (i.e., there are
              no 'lower-layer-if' entries), and 'disabled' otherwise.";
           reference
             "RFC 2863: The Interfaces Group MIB -
                        ifLinkUpDownTrapEnable";
         }
```

리프 관리자 상태 {

- if-feature if-mib; 유형 열거형 { 열거형 { 값 1; 설명 "패킷을 전달할 준비가 되었습니다."; } 열거형 아래로 { 값 2; 설명 "패킷을 전달할 준비가 되지 않았으며 일부 테스트 모드가 아닙니다."; } 열거형 테스트 { 값 3; 설명 "일부 테스트 모드에서."; } } 구성 거짓; 필수 사실; 설명 "인터페이스의 원하는 상태입니다.

```text
              This leaf has the same read semantics as ifAdminStatus.";
           reference
             "RFC 2863: The Interfaces Group MIB - ifAdminStatus";
         }

         leaf oper-status {
           type enumeration {
             enum up {
               value 1;
               description
                 "Ready to pass packets.";
             }
             enum down {
               value 2;
```

설명

- "인터페이스가 어떤 패킷도 전달하지 않습니다."; } 열거형 테스트 { 값 3; 설명 "일부 테스트 모드입니다. 작동 패킷을 전달할 수 없습니다."; } 알 수 없는 열거형 { 값 4; 설명 "어떤 이유로 인해 상태를 확인할 수 없습니다."; } enum 휴면 { 값 5; 설명 "외부 이벤트를 기다리는 중입니다."; } 열거형이 존재하지 않음 { 값 6; 설명 "일부 구성요소\(일반적으로 하드웨어\)가 누락되었습니다."; } enum lower-layer-down { value 7; 설명 "하위 계층 인터페이스 상태로 인해 다운되었습니다."; } } 구성 거짓; 필수 사실; 설명 "인터페이스의 현재 작동 상태입니다.

```text
              This leaf has the same semantics as ifOperStatus.";
           reference
             "RFC 2863: The Interfaces Group MIB - ifOperStatus";
         }

         leaf last-change {
           type yang:date-and-time;
           config false;
           description
             "The time the interface entered its current operational
              state.  If the current state was entered prior to the
              last re-initialization of the local network management
              subsystem, then this node is not present.";

           reference
             "RFC 2863: The Interfaces Group MIB - ifLastChange";
         }

         leaf if-index {
           if-feature if-mib;
           type int32 {
             range "1..2147483647";
           }
           config false;
           mandatory true;
           description
             "The ifIndex value for the ifEntry represented by this
              interface.";
           reference
             "RFC 2863: The Interfaces Group MIB - ifIndex";
         }

         leaf phys-address {
           type yang:phys-address;
           config false;
           description
             "The interface's address at its protocol sub-layer.  For
              example, for an 802.x interface, this object normally
              contains a Media Access Control (MAC) address.  The
              interface's media-specific modules must define the bit
              and byte ordering and the format of the value of this
              object.  For interfaces that do not have such an address
              (e.g., a serial line), this node is not present.";
           reference
             "RFC 2863: The Interfaces Group MIB - ifPhysAddress";
         }

         leaf-list higher-layer-if {
           type interface-ref;
           config false;
           description
             "A list of references to interfaces layered on top of this
              interface.";
           reference
             "RFC 2863: The Interfaces Group MIB - ifStackTable";
         }

         leaf-list lower-layer-if {
           type interface-ref;
           config false;

           description
             "A list of references to interfaces layered underneath this
              interface.";
           reference
             "RFC 2863: The Interfaces Group MIB - ifStackTable";
         }

         leaf speed {
           type yang:gauge64;
           units "bits/second";
           config false;
           description
               "An estimate of the interface's current bandwidth in bits
                per second.  For interfaces that do not vary in
                bandwidth or for those where no accurate estimation can
                be made, this node should contain the nominal bandwidth.
                For interfaces that have no concept of bandwidth, this
                node is not present.";
           reference
             "RFC 2863: The Interfaces Group MIB -
                        ifSpeed, ifHighSpeed";
         }

         container statistics {
           config false;
           description
             "A collection of interface-related statistics objects.";

           leaf discontinuity-time {
             type yang:date-and-time;
             mandatory true;
             description
               "The time on the most recent occasion at which any one or
                more of this interface's counters suffered a
                discontinuity.  If no such discontinuities have occurred
                since the last re-initialization of the local management
                subsystem, then this node contains the time the local
                management subsystem re-initialized itself.";
           }
```

리프 옥텟 {

- 양:counter64;를 입력하세요. 설명 "프레임 문자를 포함하여 인터페이스에서 수신된 총 옥텟 수입니다.

```text
                Discontinuities in the value of this counter can occur
                at re-initialization of the management system and at
                other times as indicated by the value of
                'discontinuity-time'.";
             reference
               "RFC 2863: The Interfaces Group MIB - ifHCInOctets";
           }
```

리프 인-유니캐스트-pkts {

- 양:counter64;를 입력하세요. 설명 "이 하위 계층에서 멀티캐스트 또는 브로드캐스트 주소로 주소가 지정되지 않은, 이 하위 계층에서 상위 \(하위\) 계층으로 전달된 패킷 수입니다.

```text
                Discontinuities in the value of this counter can occur
                at re-initialization of the management system and at
                other times as indicated by the value of
                'discontinuity-time'.";
             reference
               "RFC 2863: The Interfaces Group MIB - ifHCInUcastPkts";
           }
```

리프 인브로드캐스트-pkts {

- 양:counter64;를 입력하세요. 설명 "이 하위 계층에서 더 높은 \(하위\) 계층으로 전달되고 이 하위 계층의 브로드캐스트 주소로 주소가 지정된 패킷 수입니다.

```text
                Discontinuities in the value of this counter can occur
                at re-initialization of the management system and at
                other times as indicated by the value of
                'discontinuity-time'.";
             reference
               "RFC 2863: The Interfaces Group MIB -
                          ifHCInBroadcastPkts";
           }
```

리프 인-멀티캐스트-pkts {

- 양:counter64;를 입력하세요. 설명 "이 하위 계층에서 멀티캐스트 주소로 주소가 지정되고 이 하위 계층에서 상위 \(하위\) 계층으로 전달된 패킷 수입니다. MAC 계층 프로토콜의 경우 여기에는 그룹 주소와 기능 주소가 모두 포함됩니다.

```text
                Discontinuities in the value of this counter can occur
                at re-initialization of the management system and at
                other times as indicated by the value of
                'discontinuity-time'.";
             reference
               "RFC 2863: The Interfaces Group MIB -
                          ifHCInMulticastPkts";
           }
```

버려진 잎 {

- 양:counter32;를 입력하세요. 설명 "상위 계층 프로토콜로 전달되는 것을 방지하기 위해 오류가 감지되지 않았음에도 삭제하도록 선택된 인바운드 패킷 수입니다. 이러한 패킷을 삭제하는 한 가지 가능한 이유는 버퍼 공간을 확보하기 위한 것일 수 있습니다.

```text
                Discontinuities in the value of this counter can occur
                at re-initialization of the management system and at
                other times as indicated by the value of
                'discontinuity-time'.";
             reference
               "RFC 2863: The Interfaces Group MIB - ifInDiscards";
           }
```

리프 오류 {

- 양:counter32;를 입력하세요. 설명 "패킷 지향 인터페이스의 경우 상위 계층 프로토콜로 전달되지 못하게 하는 오류가 포함된 인바운드 패킷 수입니다. 문자 지향 또는 고정 길이 인터페이스의 경우 오류가 포함되어 상위 계층 프로토콜로 전달되지 않는 인바운드 전송 단위의 수입니다. 상위 계층 프로토콜로 전달 가능합니다.

```text
                Discontinuities in the value of this counter can occur
                at re-initialization of the management system and at
                other times as indicated by the value of
                'discontinuity-time'.";
             reference
               "RFC 2863: The Interfaces Group MIB - ifInErrors";
           }

           leaf in-unknown-protos {
             type yang:counter32;
```

설명

- "패킷 지향 인터페이스의 경우 알 수 없거나 지원되지 않는 프로토콜로 인해 해당 인터페이스를 통해 수신된 패킷 수입니다. 프로토콜 다중화를 지원하는 문자 지향 또는 고정 길이 인터페이스의 경우 해당 인터페이스를 통해 수신된 전송 단위 수입니다. 알 수 없거나 지원되지 않는 프로토콜로 인해 삭제된 프로토콜 멀티플렉싱을 지원하지 않는 인터페이스의 경우 이 카운터가 없습니다.

```text
                Discontinuities in the value of this counter can occur
                at re-initialization of the management system and at
                other times as indicated by the value of
                'discontinuity-time'.";
             reference
               "RFC 2863: The Interfaces Group MIB - ifInUnknownProtos";
           }
```

리프 아웃 옥텟 {

- 양:counter64;를 입력하세요. 설명 "프레임 문자를 포함하여 인터페이스에서 전송된 총 옥텟 수입니다.

```text
                Discontinuities in the value of this counter can occur
                at re-initialization of the management system and at
                other times as indicated by the value of
                'discontinuity-time'.";
             reference
               "RFC 2863: The Interfaces Group MIB - ifHCOutOctets";
           }
```

리프 아웃-유니캐스트-pkts {

- 양:counter64;를 입력하세요. 설명 "상위 프로토콜이 전송을 요청했지만 폐기되거나 전송되지 않은 패킷을 포함하여 이 하위 계층의 멀티캐스트 또는 브로드캐스트 주소로 주소가 지정되지 않은 패킷의 총 수입니다.

```text
                Discontinuities in the value of this counter can occur
                at re-initialization of the management system and at
                other times as indicated by the value of
                'discontinuity-time'.";
             reference
               "RFC 2863: The Interfaces Group MIB - ifHCOutUcastPkts";

           }
```

리프 아웃브로드캐스트-pkts {

- 양:counter64;를 입력하세요. 설명 "상위 프로토콜이 전송을 요청하고 이 하위 계층의 브로드캐스트 주소로 주소가 지정된 패킷의 총 수입니다. 폐기되거나 전송되지 않은 패킷도 포함됩니다.

```text
                Discontinuities in the value of this counter can occur
                at re-initialization of the management system and at
                other times as indicated by the value of
                'discontinuity-time'.";
             reference
               "RFC 2863: The Interfaces Group MIB -
                          ifHCOutBroadcastPkts";
           }
```

리프 아웃-멀티캐스트-pkts {

- 양:counter64;를 입력하세요. 설명 "폐기되거나 전송되지 않은 패킷을 포함하여 더 높은 수준의 프로토콜이 전송을 요청하고 이 하위 계층의 멀티캐스트 주소로 주소 지정된 패킷의 총 수입니다. MAC 계층 프로토콜의 경우 여기에는 그룹과 그룹이 모두 포함됩니다. 기능적 주소.

```text
                Discontinuities in the value of this counter can occur
                at re-initialization of the management system and at
                other times as indicated by the value of
                'discontinuity-time'.";
             reference
               "RFC 2863: The Interfaces Group MIB -
                          ifHCOutMulticastPkts";
           }
```

리프 아웃-폐기 {

- 양:counter32;를 입력하세요. 설명 "전송을 방지하기 위해 오류가 감지되지 않았음에도 삭제하도록 선택한 아웃바운드 패킷 수입니다. 이러한 패킷을 삭제하는 한 가지 가능한 이유는 버퍼 공간을 확보하기 위한 것일 수 있습니다.

```text
                Discontinuities in the value of this counter can occur
                at re-initialization of the management system and at
                other times as indicated by the value of
                'discontinuity-time'.";
             reference
               "RFC 2863: The Interfaces Group MIB - ifOutDiscards";
           }
```

리프 아웃 오류 {

- 양:counter32;를 입력하세요. 설명 "패킷 지향 인터페이스의 경우 오류로 인해 전송될 수 없는 아웃바운드 패킷 수입니다. 문자 지향 또는 고정 길이 인터페이스의 경우 오류로 인해 전송될 수 없는 아웃바운드 전송 단위의 수입니다.

```text
                Discontinuities in the value of this counter can occur
                at re-initialization of the management system and at
                other times as indicated by the value of
                'discontinuity-time'.";
             reference
               "RFC 2863: The Interfaces Group MIB - ifOutErrors";
           }
         }

       }
     }

     /*
      * Legacy typedefs
      */

     typedef interface-state-ref {
       type leafref {
         path "/if:interfaces-state/if:interface/if:name";
       }
       status deprecated;
       description
         "This type is used by data models that need to reference
          the operationally present interfaces.";
     }

     /*
      * Legacy operational state data nodes
      */

     container interfaces-state {

       config false;
       status deprecated;
       description
         "Data nodes for the operational state of interfaces.";

       list interface {
         key "name";
         status deprecated;
```

설명

- "장치의 인터페이스 목록입니다.

```text
            System-controlled interfaces created by the system are
            always present in this list, whether or not they are
            configured.";
```

잎 이름 {

- 문자열을 입력하세요. 더 이상 사용되지 않는 상태입니다. 설명 "인터페이스의 이름입니다.

```text
              A server implementation MAY map this leaf to the ifName
              MIB object.  Such an implementation needs to use some
              mechanism to handle the differences in size and characters
              allowed between this leaf and ifName.  The definition of
              such a mechanism is outside the scope of this document.";
           reference
             "RFC 2863: The Interfaces Group MIB - ifName";
         }

         leaf type {
           type identityref {
             base interface-type;
           }
           mandatory true;
           status deprecated;
           description
             "The type of the interface.";
           reference
             "RFC 2863: The Interfaces Group MIB - ifType";
         }

         leaf admin-status {
           if-feature if-mib;
           type enumeration {
             enum up {
               value 1;
```

설명

- "패킷을 전달할 준비가 되었습니다."; } 열거형 아래로 { 값 2; 설명 "패킷을 전달할 준비가 되지 않았으며 일부 테스트 모드가 아닙니다."; } 열거형 테스트 { 값 3; 설명 "일부 테스트 모드에서."; } } 필수 true; 더 이상 사용되지 않는 상태입니다. 설명 "인터페이스의 원하는 상태입니다.

```text
              This leaf has the same read semantics as ifAdminStatus.";
           reference
             "RFC 2863: The Interfaces Group MIB - ifAdminStatus";
         }

         leaf oper-status {
           type enumeration {
             enum up {
               value 1;
               description
                 "Ready to pass packets.";
             }
             enum down {
               value 2;
               description
                 "The interface does not pass any packets.";
             }
             enum testing {
               value 3;
               description
                 "In some test mode.  No operational packets can
                  be passed.";
             }
             enum unknown {
               value 4;
               description
                 "Status cannot be determined for some reason.";
             }
             enum dormant {
```

값 5;

- 설명 "외부 이벤트를 기다리는 중입니다."; } 열거형이 존재하지 않음 { 값 6; 설명 "일부 구성요소\(일반적으로 하드웨어\)가 누락되었습니다."; } enum lower-layer-down { value 7; 설명 "하위 계층 인터페이스 상태로 인해 다운되었습니다."; } } 필수 true; 더 이상 사용되지 않는 상태입니다. 설명 "인터페이스의 현재 작동 상태입니다.

```text
              This leaf has the same semantics as ifOperStatus.";
           reference
             "RFC 2863: The Interfaces Group MIB - ifOperStatus";
         }

         leaf last-change {
           type yang:date-and-time;
           status deprecated;
           description
             "The time the interface entered its current operational
              state.  If the current state was entered prior to the
              last re-initialization of the local network management
              subsystem, then this node is not present.";
           reference
             "RFC 2863: The Interfaces Group MIB - ifLastChange";
         }

         leaf if-index {
           if-feature if-mib;
           type int32 {
             range "1..2147483647";
           }
           mandatory true;
           status deprecated;
           description
             "The ifIndex value for the ifEntry represented by this
              interface.";

           reference
             "RFC 2863: The Interfaces Group MIB - ifIndex";
         }

         leaf phys-address {
           type yang:phys-address;
           status deprecated;
           description
             "The interface's address at its protocol sub-layer.  For
              example, for an 802.x interface, this object normally
              contains a Media Access Control (MAC) address.  The
              interface's media-specific modules must define the bit
              and byte ordering and the format of the value of this
              object.  For interfaces that do not have such an address
              (e.g., a serial line), this node is not present.";
           reference
             "RFC 2863: The Interfaces Group MIB - ifPhysAddress";
         }

         leaf-list higher-layer-if {
           type interface-state-ref;
           status deprecated;
           description
             "A list of references to interfaces layered on top of this
              interface.";
           reference
             "RFC 2863: The Interfaces Group MIB - ifStackTable";
         }

         leaf-list lower-layer-if {
           type interface-state-ref;
           status deprecated;
           description
             "A list of references to interfaces layered underneath this
              interface.";
           reference
             "RFC 2863: The Interfaces Group MIB - ifStackTable";
         }
```

잎 속도 {

- 양:gauge64를 입력하세요. 단위 "비트/초"; 더 이상 사용되지 않는 상태입니다. 설명 "인터페이스의 현재 대역폭 추정치\(초당 비트 수\)입니다. 대역폭이 변하지 않거나 정확한 추정이 불가능한 인터페이스의 경우

```text
                be made, this node should contain the nominal bandwidth.
                For interfaces that have no concept of bandwidth, this
                node is not present.";
           reference
             "RFC 2863: The Interfaces Group MIB -
                        ifSpeed, ifHighSpeed";
         }

         container statistics {
           status deprecated;
           description
             "A collection of interface-related statistics objects.";

           leaf discontinuity-time {
             type yang:date-and-time;
             mandatory true;
             status deprecated;
             description
               "The time on the most recent occasion at which any one or
                more of this interface's counters suffered a
                discontinuity.  If no such discontinuities have occurred
                since the last re-initialization of the local management
                subsystem, then this node contains the time the local
                management subsystem re-initialized itself.";
           }
```

리프 옥텟 {

- 양:counter64;를 입력하세요. 더 이상 사용되지 않는 상태입니다. 설명 "프레임 문자를 포함하여 인터페이스에서 수신된 총 옥텟 수입니다.

```text
                Discontinuities in the value of this counter can occur
                at re-initialization of the management system and at
                other times as indicated by the value of
                'discontinuity-time'.";
             reference
               "RFC 2863: The Interfaces Group MIB - ifHCInOctets";
           }
```

리프 인-유니캐스트-pkts {

- 양:counter64;를 입력하세요. 더 이상 사용되지 않는 상태입니다. 설명 "이 하위 계층에서 멀티캐스트 또는 브로드캐스트 주소로 주소가 지정되지 않은, 이 하위 계층에서 상위 \(하위\) 계층으로 전달된 패킷 수입니다.

```text
                Discontinuities in the value of this counter can occur
                at re-initialization of the management system and at
                other times as indicated by the value of
                'discontinuity-time'.";
             reference
               "RFC 2863: The Interfaces Group MIB - ifHCInUcastPkts";
           }
```

리프 인브로드캐스트-pkts {

- 양:counter64;를 입력하세요. 더 이상 사용되지 않는 상태입니다. 설명 "이 하위 계층에서 더 높은 \(하위\) 계층으로 전달되고 이 하위 계층의 브로드캐스트 주소로 주소가 지정된 패킷 수입니다.

```text
                Discontinuities in the value of this counter can occur
                at re-initialization of the management system and at
                other times as indicated by the value of
                'discontinuity-time'.";
             reference
               "RFC 2863: The Interfaces Group MIB -
                          ifHCInBroadcastPkts";
           }
```

리프 인-멀티캐스트-pkts {

- 양:counter64;를 입력하세요. 더 이상 사용되지 않는 상태입니다. 설명 "이 하위 계층에서 멀티캐스트 주소로 주소가 지정되고 이 하위 계층에서 상위 \(하위\) 계층으로 전달된 패킷 수입니다. MAC 계층 프로토콜의 경우 여기에는 그룹 주소와 기능 주소가 모두 포함됩니다.

```text
                Discontinuities in the value of this counter can occur
                at re-initialization of the management system and at
                other times as indicated by the value of
                'discontinuity-time'.";
             reference
               "RFC 2863: The Interfaces Group MIB -
                          ifHCInMulticastPkts";
           }

           leaf in-discards {
             type yang:counter32;
             status deprecated;
```

설명

- "상위 계층 프로토콜로 전달되지 않도록 오류가 감지되지 않았음에도 삭제하도록 선택된 인바운드 패킷 수입니다. 이러한 패킷을 삭제하는 한 가지 가능한 이유는 버퍼 공간을 확보하기 위한 것일 수 있습니다.

```text
                Discontinuities in the value of this counter can occur
                at re-initialization of the management system and at
                other times as indicated by the value of
                'discontinuity-time'.";
             reference
               "RFC 2863: The Interfaces Group MIB - ifInDiscards";
           }
```

리프 오류 {

- 양:counter32;를 입력하세요. 더 이상 사용되지 않는 상태입니다. 설명 "패킷 지향 인터페이스의 경우 상위 계층 프로토콜로 전달되지 못하게 하는 오류가 포함된 인바운드 패킷 수입니다. 문자 지향 또는 고정 길이 인터페이스의 경우 오류가 포함되어 상위 계층 프로토콜로 전달되지 않는 인바운드 전송 단위의 수입니다. 상위 계층 프로토콜로 전달 가능합니다.

```text
                Discontinuities in the value of this counter can occur
                at re-initialization of the management system and at
                other times as indicated by the value of
                'discontinuity-time'.";
             reference
               "RFC 2863: The Interfaces Group MIB - ifInErrors";
           }
```

리프 인-알 수 없는-프로토스 {

- 양:counter32;를 입력하세요. 더 이상 사용되지 않는 상태입니다. 설명 "패킷 지향 인터페이스의 경우 알 수 없거나 지원되지 않는 프로토콜로 인해 해당 인터페이스를 통해 수신된 패킷 수입니다. 프로토콜 다중화를 지원하는 문자 지향 또는 고정 길이 인터페이스의 경우 인터페이스를 통해 수신된 전송 단위 수입니다. 알 수 없거나 지원되지 않는 프로토콜로 인해 삭제된 프로토콜 멀티플렉싱을 지원하지 않는 인터페이스의 경우 이 카운터가 없습니다.

```text
                Discontinuities in the value of this counter can occur
                at re-initialization of the management system and at
                other times as indicated by the value of
                'discontinuity-time'.";
             reference
               "RFC 2863: The Interfaces Group MIB - ifInUnknownProtos";
           }
```

리프 아웃 옥텟 {

- 양:counter64;를 입력하세요. 더 이상 사용되지 않는 상태입니다. 설명 "프레임 문자를 포함하여 인터페이스에서 전송된 총 옥텟 수입니다.

```text
                Discontinuities in the value of this counter can occur
                at re-initialization of the management system and at
                other times as indicated by the value of
                'discontinuity-time'.";
             reference
               "RFC 2863: The Interfaces Group MIB - ifHCOutOctets";
           }
```

리프 아웃-유니캐스트-pkts {

- 양:counter64;를 입력하세요. 더 이상 사용되지 않는 상태입니다. 설명 "상위 프로토콜이 전송을 요청했지만 폐기되거나 전송되지 않은 패킷을 포함하여 이 하위 계층의 멀티캐스트 또는 브로드캐스트 주소로 주소가 지정되지 않은 패킷의 총 수입니다.

```text
                Discontinuities in the value of this counter can occur
                at re-initialization of the management system and at
                other times as indicated by the value of
                'discontinuity-time'.";
             reference
               "RFC 2863: The Interfaces Group MIB - ifHCOutUcastPkts";
           }

           leaf out-broadcast-pkts {
             type yang:counter64;
             status deprecated;
```

설명

- "폐기되거나 전송되지 않은 패킷을 포함하여 더 높은 수준의 프로토콜이 전송을 요청하고 이 하위 계층의 브로드캐스트 주소로 주소가 지정된 패킷의 총 수입니다.

```text
                Discontinuities in the value of this counter can occur
                at re-initialization of the management system and at
                other times as indicated by the value of
                'discontinuity-time'.";
             reference
               "RFC 2863: The Interfaces Group MIB -
                          ifHCOutBroadcastPkts";
           }
```

리프 아웃-멀티캐스트-pkts {

- 양:counter64;를 입력하세요. 더 이상 사용되지 않는 상태입니다. 설명 "폐기되거나 전송되지 않은 패킷을 포함하여 더 높은 수준의 프로토콜이 전송을 요청하고 이 하위 계층의 멀티캐스트 주소로 주소 지정된 패킷의 총 수입니다. MAC 계층 프로토콜의 경우 여기에는 그룹과 그룹이 모두 포함됩니다. 기능적 주소.

```text
                Discontinuities in the value of this counter can occur
                at re-initialization of the management system and at
                other times as indicated by the value of
                'discontinuity-time'.";
             reference
               "RFC 2863: The Interfaces Group MIB -
                          ifHCOutMulticastPkts";
           }
```

리프 아웃-폐기 {

- 양:counter32;를 입력하세요. 더 이상 사용되지 않는 상태입니다. 설명 "전송을 방지하기 위해 오류가 감지되지 않았음에도 삭제하도록 선택한 아웃바운드 패킷 수입니다. 이러한 패킷을 삭제하는 한 가지 가능한 이유는 버퍼 공간을 확보하기 위한 것일 수 있습니다.

```text
                Discontinuities in the value of this counter can occur
                at re-initialization of the management system and at
                other times as indicated by the value of
                'discontinuity-time'.";
             reference
               "RFC 2863: The Interfaces Group MIB - ifOutDiscards";
           }
```

리프 아웃 오류 {

- 양:counter32;를 입력하세요. 더 이상 사용되지 않는 상태입니다. 설명 "패킷 지향 인터페이스의 경우 오류로 인해 전송될 수 없는 아웃바운드 패킷 수입니다. 문자 지향 또는 고정 길이 인터페이스의 경우 오류로 인해 전송될 수 없는 아웃바운드 전송 단위의 수입니다.

```text
                Discontinuities in the value of this counter can occur
                at re-initialization of the management system and at
                other times as indicated by the value of
                'discontinuity-time'.";
             reference
               "RFC 2863: The Interfaces Group MIB - ifOutErrors";
           }
         }
       }
     }
   }

   <CODE ENDS>
```

---
## **6.  IANA Considerations**

이 문서는 "IETF XML 레지스트리" \[RFC3688\]에 URI를 등록합니다. RFC 3688의 형식에 따라 다음과 같이 등록되었습니다.

```text
     URI: urn:ietf:params:xml:ns:yang:ietf-interfaces
```

등록자 연락처: IESG.

XML: 해당 없음, 요청된 URI는 XML 네임스페이스입니다.

이 문서는 "YANG 모듈 이름" 레지스트리 \[RFC6020\]에 YANG 모듈을 등록합니다.

```text
     name:         ietf-interfaces
     namespace:    urn:ietf:params:xml:ns:yang:ietf-interfaces
     prefix:       if
     reference:    RFC 8343
```

---
## **7.  Security Considerations**

이 문서에 지정된 YANG 모듈은 NETCONF \[RFC6241\] 또는 RESTCONF \[RFC8040\]과 같은 네트워크 관리 프로토콜을 통해 액세스하도록 설계된 데이터에 대한 스키마를 정의합니다. 가장 낮은 NETCONF 계층은 보안 전송 계층이며, 반드시 구현해야 하는 보안 전송은 SSH\(Secure Shell\) \[RFC6242\]입니다. 가장 낮은 RESTCONF 계층은 HTTPS이며, 필수 보안 전송 구현은 TLS \[RFC5246\]입니다.

NETCONF 액세스 제어 모델 \[RFC8341\]은 특정 NETCONF 또는 RESTCONF 사용자에 대한 액세스를 사용 가능한 모든 NETCONF 또는 RESTCONF 프로토콜 작업 및 콘텐츠의 사전 구성된 하위 집합으로 제한하는 수단을 제공합니다.

이 YANG 모듈에는 쓰기/생성/삭제 가능한 여러 데이터 노드가 정의되어 있습니다\(예: 기본값인 config true\). 이러한 데이터 노드는 일부 네트워크 환경에서 민감하거나 취약한 것으로 간주될 수 있습니다. 적절한 보호 없이 이러한 데이터 노드에 대한 쓰기 작업\(예: edit-config\)은 네트워크 작업에 부정적인 영향을 미칠 수 있습니다. 다음은 하위 트리 및 데이터 노드와 해당 민감도/취약성입니다.

/interfaces/interface: 이 목록은 장치에 구성된 인터페이스를 지정합니다. 이 목록에 대한 무단 액세스로 인해 장치가 수신하고 처리해야 하는 패킷을 무시할 수 있습니다.

/interfaces/interface/enabled: 이 리프는 인터페이스 활성화 여부를 제어합니다. 이 리프에 대한 무단 액세스로 인해 장치가 수신하고 처리해야 하는 패킷을 무시할 수 있습니다.

---
## **8.  References**
---
### **8.1.  Normative References**

```text
   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", BCP 14, RFC 2119,
              DOI 10.17487/RFC2119, March 1997,
              <https://www.rfc-editor.org/info/rfc2119>.

   [RFC2863]  McCloghrie, K. and F. Kastenholz, "The Interfaces Group
              MIB", RFC 2863, DOI 10.17487/RFC2863, June 2000,
              <https://www.rfc-editor.org/info/rfc2863>.

   [RFC3688]  Mealling, M., "The IETF XML Registry", BCP 81, RFC 3688,
              DOI 10.17487/RFC3688, January 2004,
              <https://www.rfc-editor.org/info/rfc3688>.

   [RFC5246]  Dierks, T. and E. Rescorla, "The Transport Layer Security
              (TLS) Protocol Version 1.2", RFC 5246,
              DOI 10.17487/RFC5246, August 2008,
              <https://www.rfc-editor.org/info/rfc5246>.

   [RFC6020]  Bjorklund, M., Ed., "YANG - A Data Modeling Language for
              the Network Configuration Protocol (NETCONF)", RFC 6020,
              DOI 10.17487/RFC6020, October 2010,
              <https://www.rfc-editor.org/info/rfc6020>.

   [RFC6241]  Enns, R., Ed., Bjorklund, M., Ed., Schoenwaelder, J., Ed.,
              and A. Bierman, Ed., "Network Configuration Protocol
              (NETCONF)", RFC 6241, DOI 10.17487/RFC6241, June 2011,
              <https://www.rfc-editor.org/info/rfc6241>.

   [RFC6242]  Wasserman, M., "Using the NETCONF Protocol over Secure
              Shell (SSH)", RFC 6242, DOI 10.17487/RFC6242, June 2011,
              <https://www.rfc-editor.org/info/rfc6242>.

   [RFC6991]  Schoenwaelder, J., Ed., "Common YANG Data Types",
              RFC 6991, DOI 10.17487/RFC6991, July 2013,
              <https://www.rfc-editor.org/info/rfc6991>.

   [RFC7950]  Bjorklund, M., Ed., "The YANG 1.1 Data Modeling Language",
              RFC 7950, DOI 10.17487/RFC7950, August 2016,
              <https://www.rfc-editor.org/info/rfc7950>.

   [RFC8040]  Bierman, A., Bjorklund, M., and K. Watsen, "RESTCONF
              Protocol", RFC 8040, DOI 10.17487/RFC8040, January 2017,
              <https://www.rfc-editor.org/info/rfc8040>.

   [RFC8174]  Leiba, B., "Ambiguity of Uppercase vs Lowercase in RFC
              2119 Key Words", BCP 14, RFC 8174, DOI 10.17487/RFC8174,
              May 2017, <https://www.rfc-editor.org/info/rfc8174>.

   [RFC8341]  Bierman, A. and M. Bjorklund, "Network Configuration
              Access Control Model", STD 91, RFC 8341,
              DOI 10.17487/RFC8341, March 2018,
              <https://www.rfc-editor.org/info/rfc8341>.

   [RFC8342]  Bjorklund, M., Schoenwaelder, J., Shafer, P., Watsen, K.,
              and R. Wilton, "Network Management Datastore Architecture
              (NMDA)", RFC 8342, DOI 10.17487/RFC8342, March 2018,
              <https://www.rfc-editor.org/info/rfc8342>.
```

---
### **8.2.  Informative References**

```text
   [RFC7224]  Bjorklund, M., "IANA Interface Type YANG Module",
              RFC 7224, DOI 10.17487/RFC7224, May 2014,
              <https://www.rfc-editor.org/info/rfc7224>.

   [RFC8340]  Bjorklund, M. and L. Berger, Ed., "YANG Tree Diagrams",
              BCP 215, RFC 8340, DOI 10.17487/RFC8340, March 2018,
              <https://www.rfc-editor.org/info/rfc8340>.
```

---
# **Appendix A.  Example: Ethernet Interface Module**

이 섹션에서는 이더넷 인터페이스 모듈을 정의하는 방법에 대한 간단한 예를 제공합니다. 이는 미디어별 구성 매개변수를 일반 인터페이스 목록에 조건부로 추가할 수 있는 방법을 보여줍니다. 또한 작동 상태 매개변수를 작동 인터페이스 목록에 조건부로 추가할 수 있는 방법도 보여줍니다. 이 예는 이더넷 구성을 위한 완전한 모듈로 의도되지 않았습니다.

```text
   module example-ethernet {
     namespace "http://example.com/ethernet";
     prefix "eth";

     import ietf-interfaces {
       prefix if;
     }
     import iana-if-type {
       prefix ianaift;
     }

     // configuration and state parameters for Ethernet interfaces
     augment "/if:interfaces/if:interface" {
       when "if:type = 'ianaift:ethernetCsmacd'";

       container ethernet {
         container transmission {
           choice transmission-params {
             case auto {
               leaf auto-negotiate {
                 type empty;
               }
             }
             case manual {
               container manual {
                 leaf duplex {
                   type enumeration {
                     enum "half";
                     enum "full";
                   }
                 }
                 leaf speed {
                   type enumeration {
                     enum "10Mb";
                     enum "100Mb";
                     enum "1Gb";
                     enum "10Gb";
                   }

                 }
               }
             }
           }
           leaf duplex {
             type enumeration {
               enum "half";
               enum "full";
             }
             config false;
           }
         }
         // other Ethernet-specific params...
       }
     }
   }
```

---
# **Appendix B.  Example: Ethernet Bonding Interface Module**

이 섹션에서는 인터페이스 계층화를 정의하는 방법에 대한 예를 제공합니다. 여러 이더넷 인터페이스를 하나의 논리적 인터페이스로 결합하는 이더넷 결합 인터페이스가 정의됩니다.

```text
   module example-ethernet-bonding {
     namespace "http://example.com/ethernet-bonding";
     prefix "bond";

     import ietf-interfaces {
       prefix if;
     }
     import iana-if-type {
       prefix ianaift;
     }

     augment "/if:interfaces/if:interface" {
       when "if:type = 'ianaift:ieee8023adLag'";

       leaf-list slave-if {
         type if:interface-ref;
         must "/if:interfaces/if:interface[if:name = current()]"
            + "/if:type = 'ianaift:ethernetCsmacd'" {
           description
             "The type of a slave interface must be 'ethernetCsmacd'.";
         }
       }
       leaf bonding-mode {
         type enumeration {
           enum round-robin;

           enum active-backup;
           enum broadcast;
         }
       }
       // other bonding config params, failover times, etc.
     }
   }
```

---
# **Appendix C.  Example: VLAN Interface Module**

이 섹션에서는 VLAN 인터페이스 모듈을 정의하는 방법의 예를 제공합니다.

```text
   module example-vlan {
     namespace "http://example.com/vlan";
     prefix "vlan";

     import ietf-interfaces {
       prefix if;
     }
     import iana-if-type {
       prefix ianaift;
     }

     augment "/if:interfaces/if:interface" {
       when "if:type = 'ianaift:ethernetCsmacd' or
             if:type = 'ianaift:ieee8023adLag'";
       leaf vlan-tagging {
         type boolean;
         default false;
       }
     }

     augment "/if:interfaces/if:interface" {
       when "if:type = 'ianaift:l2vlan'";

       leaf base-interface {
         type if:interface-ref;
         must "/if:interfaces/if:interface[if:name = current()]"
            + "/vlan:vlan-tagging = 'true'" {
           description
             "The base interface must have VLAN tagging enabled.";
         }
       }
       leaf vlan-id {
         type uint16 {
           range "1..4094";
         }

         must "../base-interface" {
           description
             "If a vlan-id is defined, a base-interface must
              be specified.";
         }
       }
     }
   }
```

---
# **Appendix D.  Example: NETCONF <get-config> Reply**

이 섹션에서는 위의 예제 데이터 모델을 구현하는 장치에 대해 실행 중인 구성 데이터 저장소에 대한 NETCONF <get-config\> 요청에 대한 응답의 예를 제공합니다.

```text
   <rpc-reply
       xmlns="urn:ietf:params:xml:ns:netconf:base:1.0"
       message-id="101">
     <data>
       <interfaces
           xmlns="urn:ietf:params:xml:ns:yang:ietf-interfaces"
           xmlns:ianaift="urn:ietf:params:xml:ns:yang:iana-if-type"
           xmlns:vlan="http://example.com/vlan">

         <interface>
           <name>eth0</name>
           <type>ianaift:ethernetCsmacd</type>
           <enabled>false</enabled>
         </interface>

         <interface>
           <name>eth1</name>
           <type>ianaift:ethernetCsmacd</type>
           <enabled>true</enabled>
           <vlan:vlan-tagging>true</vlan:vlan-tagging>
         </interface>

         <interface>
           <name>eth1.10</name>
           <type>ianaift:l2vlan</type>
           <enabled>true</enabled>
           <vlan:base-interface>eth1</vlan:base-interface>
           <vlan:vlan-id>10</vlan:vlan-id>
         </interface>

         <interface>
           <name>lo1</name>
           <type>ianaift:softwareLoopback</type>

           <enabled>true</enabled>
         </interface>

       </interfaces>
     </data>
   </rpc-reply>
```

---
# **Appendix E.  Example: NETCONF <get-data> Reply**

이 섹션에서는 위의 예제 데이터 모델을 구현하는 장치의 작동 상태 데이터 저장소에 대한 NETCONF <get-data\> 요청에 대한 응답의 예를 제공합니다.

이 예에서는 "ietf-origin" \[RFC8342\] 모듈에 정의된 "origin" 주석을 사용합니다.

```text
   <rpc-reply
       xmlns="urn:ietf:params:xml:ns:netconf:base:1.0"
       message-id="101">
     <data xmlns="urn:ietf:params:xml:ns:yang:ietf-netconf-datastores">
       <interfaces
           xmlns="urn:ietf:params:xml:ns:yang:ietf-interfaces"
           xmlns:ianaift="urn:ietf:params:xml:ns:yang:iana-if-type"
           xmlns:vlan="http://example.com/vlan"
           xmlns:or="urn:ietf:params:xml:ns:yang:ietf-origin">

         <interface or:origin="or:intended">
           <name>eth0</name>
           <type>ianaift:ethernetCsmacd</type>
           <enabled>false</enabled>
           <admin-status>down</admin-status>
           <oper-status>down</oper-status>
           <if-index>2</if-index>
           <phys-address>00:01:02:03:04:05</phys-address>
           <statistics>
             <discontinuity-time>
               2013-04-01T03:00:00+00:00
             </discontinuity-time>
             <!-- counters now shown here -->
           </statistics>
         </interface>

         <interface or:origin="or:intended">
           <name>eth1</name>
           <type>ianaift:ethernetCsmacd</type>
           <enabled>true</enabled>
           <admin-status>up</admin-status>
           <oper-status>up</oper-status>

           <if-index>7</if-index>
           <phys-address>00:01:02:03:04:06</phys-address>
           <higher-layer-if>eth1.10</higher-layer-if>
           <statistics>
             <discontinuity-time>
               2013-04-01T03:00:00+00:00
             </discontinuity-time>
             <!-- counters now shown here -->
           </statistics>
           <vlan:vlan-tagging>true</vlan:vlan-tagging>
         </interface>

         <interface or:origin="or:intended">
           <name>eth1.10</name>
           <type>ianaift:l2vlan</type>
           <enabled>true</enabled>
           <admin-status>up</admin-status>
           <oper-status>up</oper-status>
           <if-index>9</if-index>
           <lower-layer-if>eth1</lower-layer-if>
           <statistics>
             <discontinuity-time>
               2013-04-01T03:00:00+00:00
             </discontinuity-time>
             <!-- counters now shown here -->
           </statistics>
           <vlan:base-interface>eth1</vlan:base-interface>
           <vlan:vlan-id>10</vlan:vlan-id>
         </interface>

         <!-- This interface is not configured -->
         <interface or:origin="or:system">
           <name>eth2</name>
           <type>ianaift:ethernetCsmacd</type>
           <admin-status>down</admin-status>
           <oper-status>down</oper-status>
           <if-index>8</if-index>
           <phys-address>00:01:02:03:04:07</phys-address>
           <statistics>
             <discontinuity-time>
               2013-04-01T03:00:00+00:00
             </discontinuity-time>
             <!-- counters now shown here -->
           </statistics>
         </interface>

         <interface or:origin="or:intended">
           <name>lo1</name>

           <type>ianaift:softwareLoopback</type>
           <enabled>true</enabled>
           <admin-status>up</admin-status>
           <oper-status>up</oper-status>
           <if-index>1</if-index>
           <statistics>
             <discontinuity-time>
               2013-04-01T03:00:00+00:00
             </discontinuity-time>
             <!-- counters now shown here -->
           </statistics>
         </interface>

       </interfaces>
     </data>
   </rpc-reply>
```

---
# **Appendix F.  Examples: Interface Naming Schemes**

이 섹션에서는 일부 구현 전략의 예를 제공합니다.

예제에서는 예제 데이터 모델 "example-vlan"\(부록 C 참조\)을 사용하여 사용자 제어 인터페이스를 구성하는 방법을 보여줍니다.

---
### **F.1.  Router with Restricted Interface Names**

이 예에서 라우터는 각각 8개의 포트가 있는 4개의 라인 카드를 지원합니다. 카드 슬롯에는 물리적으로 0부터 3까지 번호가 매겨져 있고, 각 카드의 포트 번호는 0부터 7까지입니다. 각 카드에는 고속 이더넷 또는 기가비트 이더넷 포트가 있습니다.

이러한 물리적 인터페이스의 장치별 이름은 "fastethernet-N/M" 또는 "gigabitethernet-N/M"입니다.

VLAN 인터페이스의 이름은 "<물리적 인터페이스 이름\>.<하위 인터페이스 번호\>" 형식으로 제한됩니다.

운영자는 이 명명 체계를 알고 있다고 가정합니다. 구현에서는 인터페이스 이름을 기반으로 "type" 값을 자동 초기화합니다.

NETCONF 서버는 <hello\> 메시지에서 "임의 이름" 기능을 광고하지 않습니다.

운영자는 다음을 포함하는 <edit-config\>를 전송하여 물리적 인터페이스를 구성할 수 있습니다.

```text
     <interface nc:operation="create">
       <name>fastethernet-1/0</name>
     </interface>
```

서버가 이 요청을 처리할 때 리프 "유형"을 "ianaift:ethernetCsmacd"로 설정합니다. 따라서 클라이언트가 위의 <edit-config\> 바로 다음에 <get-config\>를 수행하면 다음을 얻게 됩니다.

```text
     <interface>
       <name>fastethernet-1/0</name>
       <type>ianaift:ethernetCsmacd</type>
     </interface>
```

클라이언트는 다음을 포함하는 <edit-config\>를 전송하여 VLAN 인터페이스를 구성할 수 있습니다.

```text
     <interface nc:operation="create">
       <name>fastethernet-1/0.10005</name>
       <type>ianaift:l2vlan</type>
       <vlan:base-interface>fastethernet-1/0</vlan:base-interface>
       <vlan:vlan-id>5</vlan:vlan-id>
     </interface>
```

클라이언트가 다음을 포함하는 <edit-config\>를 사용하여 물리적 인터페이스 유형을 변경하려고 시도하는 경우:

```text
     <interface nc:operation="merge">
       <name>fastethernet-1/0</name>
       <type>ianaift:tunnel</type>
     </interface>
```

그러면 새 유형이 이름과 일치하지 않기 때문에 서버는 "잘못된 값" 오류로 응답합니다.

---
### **F.2.  Router with Arbitrary Interface Names**

이 예에서 라우터는 각각 8개의 포트가 있는 4개의 라인 카드를 지원합니다. 카드 슬롯에는 물리적으로 0부터 3까지 번호가 매겨져 있고, 각 카드의 포트 번호는 0부터 7까지입니다. 각 카드에는 고속 이더넷 또는 기가비트 이더넷 포트가 있습니다.

이러한 물리적 인터페이스의 장치별 이름은 "fastethernet-N/M" 또는 "gigabitethernet-N/M"입니다.

구현에서는 사용자 제어 인터페이스 이름을 제한하지 않습니다. 이를 통해 운영자는 인터페이스 구성을 다른 인터페이스에 보다 쉽게 ​​적용할 수 있습니다. 그러나 간접 참조 수준이 추가되면 다른 프로토콜에 있는 인터페이스 이름을 구성 항목에 매핑하는 것이 좀 더 복잡해집니다.

NETCONF 서버는 <hello\> 메시지에 "arbitrary-names" 기능을 광고합니다.

물리적 인터페이스는 부록 F.1과 같이 구성됩니다.

운영자는 다음을 포함하는 <edit-config\>를 전송하여 VLAN 인터페이스를 구성할 수 있습니다.

```text
     <interface nc:operation="create">
       <name>acme-interface</name>
       <type>ianaift:l2vlan</type>
       <vlan:base-interface>fastethernet-1/0</vlan:base-interface>
       <vlan:vlan-id>5</vlan:vlan-id>
     </interface>
```

필요한 경우 운영자는 다음을 포함하는 <edit-config\>를 사용하여 "acme-interface"라는 구성을 다른 물리적 인터페이스로 이동할 수 있습니다.

```text
     <interface nc:operation="merge">
       <name>acme-interface</name>
       <vlan:base-interface>fastethernet-1/1</vlan:base-interface>
     </interface>
```

---
### **F.3.  Ethernet Switch with Restricted Interface Names**

이 예에서 이더넷 스위치에는 각각 간단한 포트 번호로 식별되는 여러 개의 포트가 있습니다.

물리적 인터페이스의 장치별 이름은 물리적 포트 번호와 일치하는 번호입니다.

운영자는 다음을 포함하는 <edit-config\>를 전송하여 물리적 인터페이스를 구성할 수 있습니다.

```text
     <interface nc:operation="create">
       <name>6</name>
     </interface>
```

서버가 이 요청을 처리할 때 리프 "유형"을 "ianaift:ethernetCsmacd"로 설정합니다. 따라서 클라이언트가 위의 <edit-config\> 바로 다음에 <get-config\>를 수행하면 다음을 얻게 됩니다.

```text
     <interface>
       <name>6</name>
       <type>ianaift:ethernetCsmacd</type>
     </interface>
```

---
### **F.4.  Generic Host with Restricted Interface Names**

이 예에서 일반 호스트에는 커널에 의해 명명된 인터페이스가 있습니다. 시스템은 운영 체제에서 인터페이스에 할당한 이름으로 물리적 인터페이스를 식별합니다.

VLAN 인터페이스의 이름은 "<물리적 인터페이스 이름\>:<vlan-번호\>" 형식으로 제한됩니다.

NETCONF 서버는 <hello\> 메시지에서 "임의 이름" 기능을 광고하지 않습니다.

운영자는 다음을 포함하는 <edit-config\>를 전송하여 인터페이스를 구성할 수 있습니다.

```text
     <interface nc:operation="create">
       <name>eth8</name>
     </interface>
```

서버가 이 요청을 처리할 때 리프 "유형"을 "ianaift:ethernetCsmacd"로 설정합니다. 따라서 클라이언트가 위의 <edit-config\> 바로 다음에 <get-config\>를 수행하면 다음을 얻게 됩니다.

```text
     <interface>
       <name>eth8</name>
       <type>ianaift:ethernetCsmacd</type>
     </interface>
```

클라이언트는 다음을 포함하는 <edit-config\>를 전송하여 VLAN 인터페이스를 구성할 수 있습니다.

```text
     <interface nc:operation="create">
       <name>eth8:5</name>
       <type>ianaift:l2vlan</type>
       <vlan:base-interface>eth8</vlan:base-interface>
       <vlan:vlan-id>5</vlan:vlan-id>
     </interface>
```

---
### **F.5.  Generic Host with Arbitrary Interface Names**

이 예에서 일반 호스트에는 커널에 의해 명명된 인터페이스가 있습니다. 시스템은 운영 체제에서 인터페이스에 할당한 이름으로 물리적 인터페이스를 식별합니다.

구현에서는 사용자 제어 인터페이스 이름을 제한하지 않습니다. 이를 통해 운영자는 인터페이스 구성을 다른 인터페이스에 보다 쉽게 ​​적용할 수 있습니다. 그러나 간접 참조 수준이 추가되면 다른 프로토콜에 있는 인터페이스 이름을 구성 항목에 매핑하는 것이 좀 더 복잡해집니다.

NETCONF 서버는 <hello\> 메시지에 "arbitrary-names" 기능을 광고합니다.

물리적 인터페이스는 부록 F.4와 같이 구성됩니다.

운영자는 다음을 포함하는 <edit-config\>를 전송하여 VLAN 인터페이스를 구성할 수 있습니다.

```text
     <interface nc:operation="create">
       <name>acme-interface</name>
       <type>ianaift:l2vlan</type>
       <vlan:base-interface>eth8</vlan:base-interface>
       <vlan:vlan-id>5</vlan:vlan-id>
     </interface>
```

필요한 경우 운영자는 다음을 포함하는 <edit-config\>를 사용하여 "acme-interface"라는 구성을 다른 물리적 인터페이스로 이동할 수 있습니다.

```text
     <interface nc:operation="merge">
       <name>acme-interface</name>
       <vlan:base-interface>eth3</vlan:base-interface>
     </interface>
```

---
# **Acknowledgments**

저자는 유용한 의견을 주신 Alexander Clemm, Per Hedeland, Ladislav Lhotka 및 Juergen Schoenwaelder에게 감사의 말씀을 전하고 싶습니다.

---
# **Author's Address**

```text
   Martin Bjorklund
   Tail-f Systems

   Email: mbj@tail-f.com
```
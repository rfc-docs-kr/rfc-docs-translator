

```text
Network Working Group                                        Bill Duvall
Request for Comments: 2                                              SRI

                            [unknown title]

[page 1 missing]
```

---
# **1 LINKS**

```text
   1a Control Links
```

- 1a1 논리 링크 0은 네트워크의 두 호스트 사이의 제어 링크가 됩니다.

- 1a1a 네트워크의 두 호스트 사이에는 하나의 제어 링크만 존재할 수 있습니다. 따라서 네트워크에 n개의 HOST가 있는 경우 각 HOST에는 n-1개의 제어 링크가 있습니다.

- 1a2 주로 다음과 같은 목적으로 HOST 간 통신에 사용됩니다.

```text
         1a2a Establishing user links

         1a2b Breaking user links
```

- 1a2c 링크 및/또는 링크를 사용하는 프로그램의 상태에 관한 인터럽트 전달

```text
         1a2d Monitor communication
```

- 네트워크의 1a3 Imps는 링크 0에서 전송된 모든 메시지를 자동으로 추적할 수 있습니다.

```text
   1b Primary Links
```

- 1b1 특정 HOST의 사용자는 네트워크의 다른 HOST 각각에 대해 정확히 1개의 기본 링크를 가질 수 있습니다.

- 1b1a 기본 링크는 HOST 사용자와 다른 HOST 간에 설정된 첫 번째 링크여야 합니다.

- 1b1b 기본 링크는 사용자에게 전역적입니다. 즉, 사용자 프로그램이 기본 링크를 열 수 있으며 해당 링크는 특별히 닫힐 때까지 열려 있습니다.

- 1b1c 기본 링크는 원격 HOST에 의해 일반 데이터 전화 또는 직접 회선을 통해 연결된 텔레타이프처럼 처리됩니다. 즉, 원격 HOST는 기본 링크를 일반 텔레타이프 사용자로 간주합니다.

- 1b1d 기본 링크는 \(사용자\) 제어 정보를 원격 호스트에 전달하는 데 사용됩니다. 이는 원격 호스트에 로그인하는 데 사용됩니다\(원격 호스트의 표준 로그인 절차 사용\).

```text
   1c Auxilliary Links
```

- 1c1 사용자 프로그램은 자신과 연결된 호스트의 사용자 프로그램 사이에 보조 링크를 얼마든지 설정할 수 있습니다.

- 1c1a 이 링크는 바이너리 또는 문자 전송에 사용될 수 있습니다.

- 1c1b 보조 링크는 이를 설정하는 하위 시스템에 로컬이므로 해당 하위 시스템이 떠날 때 닫힙니다.

---
# **2 MANIPULATION OF LINKS**

```text
   2a Control links
```

- 2a1 제어 링크는 시스템 로드 시간에 설정됩니다.

- 2a2 제어 링크의 상태는 활성 또는 비활성일 수 있습니다.

2a2a 제어 링크의 상태는 다음을 반영해야 합니다.

- HOST 간의 관계.

```text
   2b Primary Links
```

- 2b1 기본 링크는 모니터에 대한 사용자 또는 임원 호출에 의해 설정됩니다.

- 2b1a 연결하려는 HOST의 네트워크 식별 번호가 호출에 포함되어야 합니다.

- 2b1b 특정 HOST에 대해 두 개 이상의 기본 링크를 설정하려는 시도는 오류로 간주되며 요청이 기본값으로 설정됩니다.

```text
         2b1c Standard Transmission Character Set
```

2b1c1 다음에 대한 표준 문자 집합이 있습니다.

- 기본 링크와 제어 링크를 통한 데이터 전송.

- 2b1c1a 이는 전체\(8비트\) ASCII입니다.

- 2b1d \(링크 가져오기\) HOST A에서 HOST B로 링크를 설정하는 프로토콜은 다음과 같습니다.

- 2b1d1 A는 할당 테이블에서 HOST B에 대해 현재 사용되지 않은 링크를 선택합니다.

- 2b1d2 A는 링크 0을 통해 B에게 링크 연결 메시지를 전송합니다.

- 2b1d3 A는 다음을 기다립니다:

- 2b1d3a B로부터의 해당 링크에 관한 통신

- 2b1d3b 일정 시간 경과

- 2b1d4 링크에 관한 통신이 B로부터 수신되면 다음과 같은지 확인하기 위해 검사됩니다.

- 2b1d4a B로부터의 링크 확인.

- 2b1d4a1 그러면 모니터에서 요청자에게 성공적인 반환이 이루어집니다. 링크 번호가 요청자에게 반환되고 링크가 설정됩니다.

- 2b1d4b 링크 설정을 위한 B의 요청입니다. 이는 B가 A와 독립적으로 A와 동일한 링크를 설정하려고 함을 의미합니다.

- 2b1d4b1 A\(Na\)의 네트워크 ID 번호가 B\(Nb\)의 네트워크 ID 번호보다 크면 A는 요청을 무시하고 B의 링크 확인을 계속 기다립니다.

- 2b1d4b2 반면에 Na<Nb, A:

- 2b1d4b2a B의 링크 설정 요청을 존중합니다.

- 2b1d4b2b 필요에 따라 확인을 보냅니다.

- 2b1d4b2c 자체 요청을 중단하고 할당 프로세스를 반복합니다.

- 2b1d4c 링크에 관한 B의 다른 통신.

- 2b1d4c1 이는 다음 중 하나를 의미하는 오류 조건입니다.

- 2b1d4c1a 할당을 위해 이전에 할당된 링크를 선택하여 A에 오류가 발생했습니다.

- 2b1d4c1b B는 할당되지 않은 링크를 통해 정보를 전송하고 있으며,

- 2b1d4c1c 또는 B에서 A로의 할당에 관한 메시지가 전송 시 왜곡되었습니다.

- 2b1d4c2 이 경우 A의 조치는 다음과 같습니다.

- 2b1d4c2a 시도된 연결에 관해 B에게 링크 연결 해제 메시지를 보냅니다.

- 2b1d4c2b HOST B의 상태를 오류로 간주하고 패닉 루틴\(오류\)에 진입합니다.

- 2b1d5 일정 시간 동안 B로부터 링크에 대한 통신이 수신되지 않으면 HOST B는 오류 상태로 간주됩니다.

- 2b1d5a A에서 B로 링크 연결 해제 메시지가 전송됩니다.

- 2b1d5b 패닉 루틴이 호출되었습니다\(오류\).

```text
   2c Auxilliary Links
```

- 2c1 보조 링크는 사용자 프로그램에서 모니터를 호출하여 설정됩니다.

- 2c1a 요청은 모니터에 대한 원하는 링크에 대한 관련 데이터를 지정해야 합니다.

- 2c1a1 B에 대한 기본 링크의 번호입니다.

- 2c1b 보조 링크에 대한 요청은 각 호스트\(A 및 B\)의 사용자 프로그램에 의해 이루어져야 합니다.

- 2c1c Na \> Nb인 경우 HOST A는 위에 설명된 방식\(getlink\)으로 HOST B에 대한 링크 설정을 진행합니다.

- 2c1d Na<Nb이면 A는 기다립니다.

- 2c1d1 HOST B가 링크를 설정하도록 합니다\(B가 이미 해당 링크를 설정했는지 확인한 후\).

- 2c1d2 지정된 시간 동안 경과합니다.

- 2c1d2a HOST B가 HOST A의 요청에 응답하지 않았음을 의미합니다.

- 2c1d2b HOST A와 B의 프로그램은 타임아웃을 기다리는 시간을 지정할 수 있어야 합니다.

---
# **3 ERROR CHECKING**

3a 소프트웨어 및 하드웨어 버그를 격리하는 데 도움이 되도록 네트워크를 통해 전송된 모든 메시지는 처음에 오류 검사를 거칩니다.

3b 체크섬은 순서에 따라 각 메시지와 연결됩니다.

- 3b1 다음 알고리즘이 사용될 수 있습니다:

- 3b1a 길이 1의 체크섬은 직렬로 검사할 문자열에 연속적인 필드를 추가하고 합계의 가장 낮은 비트 위치에 캐리 비트를 추가하여 형성될 수 있습니다.

```text
              +--------------+
              |              |
              +---FIELD 1----+

          ADD +--------------+
              |              |
              +----FIELD 2---+

            +-+--------------+
            | |              |
            +-+--------------+
              \
               \          +--+
          ADD   CARRY---> |  |
                          +--+

              +--------------+
              |              |
              +----RESULT----+
```

- 3b1a1 이 과정을 접기라고 합니다.

- 3b1a2 추가 후 적절하게 접힌 경우 여러 필드를 추가하고 병렬로 접을 수 있습니다.

```text
              +---------+---------+---------+---------+
              | FIELD 4 | FIELD 3 | FIELD 2 | FIELD 1 |
              +---------+---------+---------+---------+

              +---------+---------+---------+---------+
              | FIELD 8 | FIELD 7 | FIELD 6 | FIELD 5 |
              +---------+---------+---------+---------+
            ADD
            +-+---------+---------+---------+---------+
            | |         |         |         |         |
            +-+---------+---------+---------+---------+
             |      |        |         |         |
             |      |        |         |         v
             |      |        |         |    +---------+
             |      |        |         |    |         |
             |      |        |         |    +---------+
             |      |        |         |
             |      |        |         \    +---------+
             |      |        |          `-> |         |
             |      |        |              +---------+
             |      |        |
             |      |        \              +---------+
             |      |         `-----------> |         |
             |      |                       +---------+
             |      |
             |      \                       +---------+
             |       `--------------------->|         |
             |                              +---------+
             |
             \                                    +---+
              `-----CARRY------------------------>|   |
                                                  +---+
                                  ADD
                                  +---------+---------+
                                  |         |         |
                                  +--CARRY--+---------+
                                       |
                                       \        +-----+
                                    ADD `-----> |     |
                                                +-----+

                                            +---------+
                                            |         |
                                            +-RESULT--+
```

- 3b1a2a 이 체계를 사용하면 n개의 필드가 있는 경우 첫 번째 n-1 필드의 캐리가 자동으로 다음 상위 필드의 낮은 순서 위치에 추가되므로 접기에서는 다음만 추가하면 됩니다. \[n\]개의 결과 필드를 n번째 필드의 캐리에 추가한 다음 해당 추가에서 적절한 크기의 캐리를 추가하고 원하는 횟수만큼 반복하여 결과를 얻습니다.

- 3b1a3 이러한 방식으로 계산된 체크섬은 서로 다른 기계의 단어 길이가 각각 최적으로 사용될 수 있다는 이점이 있습니다.

- 3b1a3a 체크섬 계산을 위해 적절한 길이의 문자열을 선택하고 적절한 체크섬 필드 길이를 선택하면 각 시스템에 대한 체크섬 기술이 상대적으로 최적이 됩니다.

```text
                  3b1a3a1 Field length: 288 bits (lowest common
                  denomenator of (24,32,36)

                  3b1a3a2 Checksum length: 8 bits (convenient field size
                  for all machines)
```

- 3b1b 메시지가 필드 그룹으로 나누어지고 각 그룹이 이러한 방식으로 체크섬을 계산하는 경우 각 그룹의 체크섬을 이동하고 이를 다음 그룹의 체크섬에 \(연속적으로\) 추가하여 순서에 따른 체크섬을 얻을 수 있습니다.

3c 두 개의 HOST가 모든 메시지에 대한 긍정적인 확인을 요구하는 모드로 들어갈 수 있는 기능이 제공됩니다. 이 확인은 제어 링크를 통해 전송됩니다.

---
# **4 MONITOR FUNCTIONS**

```text
   4a Network I/O drivers

      4a1 Input
```

- 4a1a IMP로부터의 입력 메시지.

- 4a1b 메시지에 대한 오류 검사를 수행합니다.

```text
            4a1b1 Verify checksum,
```

- 4a1b2 확인 모드가 적용되는 경우 제어 링크를 통해 "메시지 수신됨" 확인을 보냅니다.

```text
         4a1c (trans)character translation
```

- 4a1c1 IMP에서 문자 번역이 이루어질 가능성이 높습니다.

- 4a1c2 이는 BBN을 통해 더 자세히 조사할 필요가 있습니다.

- 4a1c3 두 가지 주요 고려 사항이 있습니다.

- 4a1c3a 번역은 테이블로 해야 할까요, 아니면 알고리즘으로 해야 할까요?

- 4a1c3a1 처음에는 테이블을 이용하는 것이 가장 좋은 방법인 것 같습니다.

- 4a1c3b 어떤 메시지를 번역해야 하는지 어떻게 결정해야 합니까? 즉, 모든 것을 번역하지 않는 것이 바람직합니까\(예!!\) 그리고 구별하기 위해 어떤 수단을 사용할 수 있습니까?

- 4a1d 헤더를 디코딩하고 소스 및 링크로 식별된 올바른 수신자에게 메시지를 전달합니다.

```text
      4a2 Output

         4a2a Build header

         4a2b Character translation
```

- 4a2b1 출력 번역\(trans\) 섹션 아래의 설명을 참조하세요.

```text
         4a2c Create checksum
```

- 4a2d 링크 상태 확인

- 4a2d1 마지막 메시지가 링크를 통해 전송된 이후 RFNM이 없으면 이를 기다립니다.

- 4a2e IMP에 메시지 전송

- 4a2f 인지 모드가 실행 중인 경우 대기합니다.

- 대상 IMP의 4a2f1 RFNM.

- 4a2f2 제어 라인 0을 통한 대상 HOST의 응답.

```text
   4b Network status
```

- 4b1 네트워크의 다른 HOST 상태 유지

- 4b1a IMP가 다운되면 그의 HOST도 다운된 것으로 간주됩니다.

- 4b2 제어선의 상태를 유지한다.

- 4b3 다른 호스트의 상태 쿼리에 응답합니다.

- 4b4 인터럽트 기반으로 기본 및 보조 링크의 상태를 다른 HOST에 알립니다.

- 4b5 기본 및 보조 링크를 사용하여 프로그램 상태를 다른 HOST에 알립니다.

---
# **5 EXECUTIVE PRIMITIVES**

```text
   5a Primary Links
```

- 5a1 여기에는 HOST 번호가 매개변수로 필요합니다.

```text
         5a1a Establish primary link
```

- 5a1b 제어 텔레타이프를 기본 링크에 연결

- 기본 링크를 통한 5a1c 입력/출력

- 5a1d 기본 링크의 상태 질의

- 5a1d1 이것이 정확히 무엇을 해야 하는지는 모르지만 유용할 것 같습니다.

- 5a1e 기본 링크에서 텔레타이프 제어 연결 끊기

```text
         5a1f Kill primary link

   5b Auxilliary Links.

      5b1 Establish auxilliary link.
```

- 5b1a에는 HOST 번호가 매개변수로 필요합니다.

- 5b1b 파일 인덱스와 유사한 논리적 링크 번호를 반환합니다. 다른 모든 보조 루틴에 매개변수로 전달되는 것은 이 번호입니다.

- 보조 링크를 통한 5b2 입력/출력

```text
      5b3 Interrogate status auxilliary link.
```

- 5b3a 이것이 정확히 무엇을 해야 할지 모르지만 유용할 것 같습니다.

```text
      5b4 Kill auxilliary link.

   5c Special executive functions
```

- 5c1 투명. 링크를 통한 입력/출력

- 5c1a 링크를 통한 블록 I/O 전송을 수행하는 데 사용될 수 있습니다.

- 5c1b 이 인스턴스에서 모니터의 기능은 버퍼를 IMP로 직접 전송하는 것입니다.

- 5c1c At는 어떤 식으로든 수정하지 않습니다.

5c1c1 이는 헤더 및 기타 컨트롤이

- 정보는 버퍼에 있어야 합니다.

- 5c1d 이것의 본래 용도는 네트워크 디버깅을 위한 것입니다.

---
# **6 INITIAL CHECKOUT**

6a 네트워크는 처음에 시뮬레이션된 데이터 전화 모드의 링크를 사용하여 체크아웃됩니다.

- 6a1 모든 메시지의 길이는 한 문자입니다.

- 6a2 링크는 모니터에 투명하며 특별한 실행 프리미티브를 통해 사용자 프로그램에 의해 제어됩니다.

- 6a2a 초기 테스트는 서로 다른 호스트에 있는 두 개의 사용자 프로그램에서 실행됩니다. DDT에서 DDT로.

- 6a2b 전화 링크 또는 이와 유사한 방법으로 병렬 연결됩니다.

- \[ 이 RFC는 항목을 위해 기계 판독 가능한 형식으로 작성되었습니다. \] \[ 온라인 RFC 아카이브에 Robbie Bennet 10/1998 \] \[ 이 RFC는 Kelly Tardif, Viagenie 1999년 10월에 의해 공개되었습니다.\]
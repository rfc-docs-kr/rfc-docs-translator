

```text
﻿

Internet Engineering Task Force (IETF)                  A. Melnikov, Ed.
Request for Comments: 9051                                     Isode Ltd
Obsoletes: 3501                                            B. Leiba, Ed.
Category: Standards Track                         Futurewei Technologies
ISSN: 2070-1721                                              August 2021

        Internet Message Access Protocol (IMAP) - Version 4rev2
```

---
# **Abstract**

IMAP4rev2\(Internet Message Access Protocol Version 4rev2\)를 사용하면 클라이언트가 서버의 전자 메일 메시지에 액세스하고 조작할 수 있습니다.  IMAP4rev2를 사용하면 로컬 폴더와 기능적으로 동일한 방식으로 사서함\(원격 메시지 폴더\)을 조작할 수 있습니다. IMAP4rev2는 오프라인 클라이언트가 서버와 재동기화하는 기능도 제공합니다.

IMAP4rev2에는 사서함 생성, 삭제 및 이름 바꾸기 작업이 포함되어 있습니다. 새 메시지 확인 메시지를 영구적으로 제거합니다. 플래그 설정 및 지우기; RFC 5322, 2045 및 2231에 따라 구문 분석합니다. 수색; 메시지 속성, 텍스트 및 그 일부를 선택적으로 가져오는 것입니다.  IMAP4rev2의 메시지는 숫자를 사용하여 액세스됩니다.  이 번호는 메시지 시퀀스 번호이거나 고유 식별자입니다.

IMAP4rev2는 메일 게시 방법을 지정하지 않습니다. 이 기능은 RFC 6409에 지정된 것과 같은 메일 제출 프로토콜에 의해 처리됩니다.

---
# **Status of This Memo**

이것은 인터넷 표준 추적 문서입니다.

이 문서는 IETF\(Internet Engineering Task Force\)의 산물입니다. 이는 IETF 커뮤니티의 합의를 나타냅니다. 공개 검토를 받았으며 IESG\(Internet Engineering Steering Group\)의 게시 승인을 받았습니다. 인터넷 표준에 대한 추가 정보는 RFC 7841의 섹션 2에서 확인할 수 있습니다.

이 문서의 현재 상태, 정오표, 피드백 제공 방법에 대한 정보는 https://www.rfc-editor.org/info/rfc9051에서 얻을 수 있습니다.

---
# **Copyright Notice**

Copyright \(c\) 2021 IETF Trust 및 문서 작성자로 식별된 사람. 판권 소유.

이 문서에는 이 문서 발행일에 유효한 BCP 78 및 IETF 문서와 관련된 IETF Trust의 법적 조항\(https://trustee.ietf.org/license-info\)이 적용됩니다. 이 문서에 관한 귀하의 권리와 제한 사항이 설명되어 있으므로 이 문서를 주의 깊게 검토하십시오. 이 문서에서 추출된 코드 구성 요소는 신뢰 법률 조항의 섹션 4.e에 설명된 대로 단순화된 BSD 라이센스 텍스트를 포함해야 하며 단순화된 BSD 라이센스에 설명된 대로 보증 없이 제공됩니다.

이 문서에는 2008년 11월 10일 이전에 공개되거나 공개된 IETF 문서 또는 IETF 기여의 자료가 포함될 수 있습니다. 이 자료 중 일부의 저작권을 관리하는 사람은 IETF Trust에 해당 자료의 수정을 허용할 권한을 부여하지 않았을 수 있습니다. IETF 표준 프로세스 외부. 해당 자료의 저작권을 관리하는 사람으로부터 적절한 라이센스를 얻지 않은 경우 이 문서는 IETF 표준 프로세스 외부에서 수정될 수 없으며 해당 문서의 파생물은 형식을 지정하는 경우를 제외하고 IETF 표준 프로세스 외부에서 생성될 수 없습니다. RFC로 출판하거나 영어 이외의 언어로 번역합니다.

---
# **Table of Contents**

```text
   1.  How to Read This Document
     1.1.  Organization of This Document
     1.2.  Conventions Used in This Document
     1.3.  Special Notes to Implementors
   2.  Protocol Overview
     2.1.  Link Level
     2.2.  Commands and Responses
       2.2.1.  Client Protocol Sender and Server Protocol Receiver
       2.2.2.  Server Protocol Sender and Client Protocol Receiver
     2.3.  Message Attributes
       2.3.1.  Message Numbers
       2.3.2.  Flags Message Attribute
       2.3.3.  Internal Date Message Attribute
       2.3.4.  RFC822.SIZE Message Attribute
       2.3.5.  Envelope Structure Message Attribute
       2.3.6.  Body Structure Message Attribute
     2.4.  Message Texts
   3.  State and Flow Diagram
     3.1.  Not Authenticated State
     3.2.  Authenticated State
     3.3.  Selected State
     3.4.  Logout State
   4.  Data Formats
     4.1.  Atom
       4.1.1.  Sequence Set and UID Set
     4.2.  Number
     4.3.  String
       4.3.1.  8-Bit and Binary Strings
     4.4.  Parenthesized List
     4.5.  NIL
   5.  Operational Considerations
     5.1.  Mailbox Naming
       5.1.1.  Mailbox Hierarchy Naming
       5.1.2.  Namespaces
     5.2.  Mailbox Size and Message Status Updates
     5.3.  Response When No Command in Progress
     5.4.  Autologout Timer
     5.5.  Multiple Commands in Progress (Command Pipelining)
   6.  Client Commands
     6.1.  Client Commands - Any State
       6.1.1.  CAPABILITY Command
       6.1.2.  NOOP Command
       6.1.3.  LOGOUT Command
     6.2.  Client Commands - Not Authenticated State
       6.2.1.  STARTTLS Command
       6.2.2.  AUTHENTICATE Command
       6.2.3.  LOGIN Command
     6.3.  Client Commands - Authenticated State
       6.3.1.  ENABLE Command
       6.3.2.  SELECT Command
       6.3.3.  EXAMINE Command
       6.3.4.  CREATE Command
       6.3.5.  DELETE Command
       6.3.6.  RENAME Command
       6.3.7.  SUBSCRIBE Command
       6.3.8.  UNSUBSCRIBE Command
       6.3.9.  LIST Command
       6.3.10. NAMESPACE Command
       6.3.11. STATUS Command
       6.3.12. APPEND Command
       6.3.13. IDLE Command
     6.4.  Client Commands - Selected State
       6.4.1.  CLOSE Command
       6.4.2.  UNSELECT Command
       6.4.3.  EXPUNGE Command
       6.4.4.  SEARCH Command
       6.4.5.  FETCH Command
       6.4.6.  STORE Command
       6.4.7.  COPY Command
       6.4.8.  MOVE Command
       6.4.9.  UID Command
     6.5.  Client Commands - Experimental/Expansion
   7.  Server Responses
     7.1.  Server Responses - Generic Status Responses
       7.1.1.  OK Response
       7.1.2.  NO Response
       7.1.3.  BAD Response
       7.1.4.  PREAUTH Response
       7.1.5.  BYE Response
     7.2.  Server Responses - Server Status
       7.2.1.  ENABLED Response
       7.2.2.  CAPABILITY Response
     7.3.  Server Responses - Mailbox Status
       7.3.1.  LIST Response
       7.3.2.  NAMESPACE Response
       7.3.3.  STATUS Response
       7.3.4.  ESEARCH Response
       7.3.5.  FLAGS Response
     7.4.  Server Responses - Mailbox Size
       7.4.1.  EXISTS Response
     7.5.  Server Responses - Message Status
       7.5.1.  EXPUNGE Response
       7.5.2.  FETCH Response
     7.6.  Server Responses - Command Continuation Request
   8.  Sample IMAP4rev2 Connection
   9.  Formal Syntax
   10. Author's Note
   11. Security Considerations
     11.1.  TLS-Related Security Considerations
     11.2.  STARTTLS Command versus Use of Implicit TLS Port
     11.3.  Client Handling of Unsolicited Responses Not Suitable for
            the Current Connection State
     11.4.  COPYUID and APPENDUID Response Codes
     11.5.  LIST Command and Other Users' Namespace
     11.6.  Use of MD5
     11.7.  Other Security Considerations
   12. IANA Considerations
     12.1.  Updates to IMAP Capabilities Registry
     12.2.  GSSAPI/SASL Service Name
     12.3.  LIST Selection Options, LIST Return Options, and LIST
            Extended Data Items
     12.4.  IMAP Mailbox Name Attributes and IMAP Response Codes
   13. References
     13.1.  Normative References
     13.2.  Informative References
       13.2.1.  Related Protocols
       13.2.2.  Historical Aspects of IMAP and Related Protocols
   Appendix A.  Backward Compatibility with IMAP4rev1
     A.1.  Mailbox International Naming Convention for Compatibility
           with IMAP4rev1
   Appendix B.  Backward Compatibility with BINARY Extension
   Appendix C.  Backward Compatibility with LIST-EXTENDED Extension
   Appendix D.  63-Bit Body Part and Message Sizes
   Appendix E.  Changes from RFC 3501 / IMAP4rev1
   Appendix F.  Other Recommended IMAP Extensions
   Acknowledgements
   Index
   Authors' Addresses
```

---
## **1.  How to Read This Document**
---
### **1.1.  Organization of This Document**

이 문서는 IMAP4rev2 클라이언트 또는 서버 구현자의 관점에서 작성되었습니다.  섹션 2의 프로토콜 개요를 넘어서는 프로토콜의 작동을 이해하려는 사람에게는 최적화되어 있지 않습니다.  섹션 3, 4, 5의 자료는 IMAP4rev2가 작동하는 일반적인 맥락과 정의를 제공합니다.

섹션 6, 7, 9에서는 각각 IMAP 명령, 응답 및 구문을 설명합니다.  이들 사이의 관계는 어느 하나를 개별적으로 이해하는 것이 거의 불가능할 정도입니다.  특히, 명령 섹션에서만 명령 구문을 추론하려고 시도하지 마십시오. 대신 "형식 구문"\(섹션 9\)을 참조하세요.

---
### **1.2.  Conventions Used in This Document**

"협약"은 기본 원칙 또는 절차입니다.  이 섹션에는 문서 규칙이 설명되어 있습니다.

예에서 "C:" 및 "S:"는 각각 클라이언트와 서버에서 보낸 행을 나타냅니다.  각 줄에는 종료 CRLF가 포함되어 있습니다.

핵심 단어 "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY" 및 "OPTIONAL 이 문서의 "는 여기에 표시된 대로 모두 대문자로 표시되는 경우에만 BCP 14 \[RFC2119\] \[RFC8174\]에 설명된 대로 해석됩니다.

"할 수 있다"\("할 수 있다" 아님\)라는 단어는 프로토콜의 선택적 기능과 달리 가능한 상황이나 상황을 나타내는 데 사용됩니다.

"사용자"는 인간 사용자를 나타내는 데 사용되는 반면 "클라이언트"는 사용자가 실행하는 소프트웨어를 나타냅니다.

"연결"은 네트워크 연결의 초기 설정부터 종료까지 클라이언트/서버 상호 작용의 전체 순서를 나타냅니다.

"세션"은 사서함이 선택된 시간\(SELECT 또는 EXAMINE 명령\)부터 선택이 종료되는 시간\(다른 사서함의 SELECT 또는 EXAMINE, CLOSE 명령, UNSELECT 명령 또는 연결 종료\)까지의 클라이언트/서버 상호 작용의 순서를 나타냅니다. .

"암시적 TLS"라는 용어는 TLS 연결을 위해 해당 서버에서 독점적으로 사용되는 특정 TCP 포트에서 TCP 연결이 이루어질 때마다 TLS의 자동 협상을 의미합니다.  "암시적 TLS"라는 용어는 설정된 일반 텍스트 TCP 연결에서 TLS를 명시적으로 협상하기 위해 클라이언트와 서버가 사용하는 IMAP의 STARTTLS 명령 사용과 대조하기 위한 것입니다.

별도로 지정하지 않는 한 문자는 8비트 UTF-8\(7비트 US-ASCII가 하위 집합임\)입니다.  다른 문자 집합은 \[MIME-IMT\]에 설명되고 \[CHARSET\]에 정의된 대로 "CHARSET"을 사용하여 표시됩니다. CHARSET에는 문자 집합을 정의하는 것 외에도 중요한 추가 의미가 있습니다. 자세한 내용은 이 문서를 참조하세요.

IMAP에는 몇 가지 프로토콜 규칙이 있습니다.  이는 엄격하게 IMAP 프로토콜의 일부는 아니지만 일반적으로 허용되는 관행을 반영하는 사양의 측면을 나타냅니다.  구현에서는 이러한 규칙을 인식하고 규칙 구현 여부에 관계없이 충돌을 피해야 합니다.  예를 들어 "&"는 사서함 국제 명명 규칙과 충돌하므로 계층 구분 기호로 사용할 수 없으며 사서함 이름에 "&"를 사용하는 경우에도 영향을 받습니다.

---
### **1.3.  Special Notes to Implementors**

IMAP 프로토콜의 구현자는 이 프로토콜의 복잡성과 상호 운용 가능한 제품을 구축하는 최선의 방법을 이해하는 데 도움이 되도록 이 문서와 함께 IMAP 구현 권장 사항 문서 \[IMAP-IMPLEMENTATION\]를 읽어볼 것을 강력히 권장합니다.

IMAP4rev2는 IMAP4rev1 \[RFC3501\], IMAP2 \[IMAP2\] 및 미공개 IMAP2bis \[IMAP2BIS\] 프로토콜과 상위 호환되도록 설계되었습니다.  IMAP4rev2는 RFC 3501에 설명된 IMAP4rev1 프로토콜 및 \[RFC1730\]에 설명된 IMAP4 프로토콜과 대부분 호환됩니다. \[RFC1730\] 및 \[RFC3501\]에 추가된 특정 기능은 문제가 있는 것으로 판명되어 이후에 제거되거나 더 나은 대안으로 교체된 경우는 예외입니다.  IMAP4rev2가 발전하는 과정에서 이전 프로토콜의 일부 측면은 더 이상 사용되지 않게 되었습니다.  IMAP4rev2 구현이 이전 구현과 함께 사용될 때 발생할 수 있는 사용되지 않는 명령, 응답 및 데이터 형식은 부록 A, E 및 \[IMAP-OBSOLETE\]에 설명되어 있습니다.  IMAP4rev2는 63비트 본문 부분과 메시지 크기를 지원합니다.  BINARY 및 LIST-EXTENDED IMAP 확장과의 IMAP4rev2 호환성은 각각 부록 B 및 C에 설명되어 있습니다.

이전 프로토콜의 가장 일반적인 변형인 IMAP2bis와의 기타 호환성 문제는 \[IMAP-COMPAT\]에서 논의됩니다.  \[IMAP-HISTORICAL\]에 희귀한\(그리고 멸종된 것으로 추정되는\) 변종과의 호환성 문제에 대한 전체 논의가 있습니다. 이 문서는 주로 역사적인 관심사입니다.

IMAP은 원래 이전 \[RFC822\] 표준을 위해 개발되었으므로 결과적으로 IMAP의 "RFC822.SIZE" 가져오기 항목은 이름에 "RFC822"를 포함합니다.  "RFC822"는 업데이트된 \[RFC5322\] 표준에 대한 참조로 해석되어야 합니다.

IMAP4rev2는 메일 게시 방법을 지정하지 않습니다. 이 기능은 \[RFC6409\]에 지정된 것과 같은 메일 제출 프로토콜에 의해 처리됩니다.

---
## **2.  Protocol Overview**
---
### **2.1.  Link Level**

IMAP4rev2 프로토콜은 TCP에서 제공하는 것과 같은 안정적인 데이터 스트림을 가정합니다.  TCP가 사용되면 IMAP4rev2 서버는 포트 143\(일반 텍스트 포트\) 또는 포트 993\(암시적 TLS 포트\)에서 수신 대기합니다.

---
### **2.2.  Commands and Responses**

IMAP4rev2 연결은 클라이언트/서버 네트워크 연결 설정, 서버의 초기 인사말 및 클라이언트/서버 상호 작용으로 구성됩니다.  이러한 클라이언트/서버 상호 작용은 클라이언트 명령, 서버 데이터 및 서버 완료 결과 응답으로 구성됩니다.

클라이언트와 서버가 전송하는 모든 상호 작용은 줄, 즉 CRLF로 끝나는 문자열 형식입니다.  IMAP4rev2 클라이언트 또는 서버의 프로토콜 수신기는 행 또는 그 뒤에 행이 따라오는 알려진 개수가 있는 일련의 옥텟을 읽고 있습니다.

---
#### **2.2.1.  Client Protocol Sender and Server Protocol Receiver**

클라이언트 명령이 작업을 시작합니다.  각 클라이언트 명령에는 "태그"라는 식별자\(일반적으로 짧은 영숫자 문자열, 예: A0001, A0002 등\)가 접두사로 붙습니다.  클라이언트는 각 명령마다 다른 태그를 생성합니다.  더 공식적으로 말하면 클라이언트는 모든 명령에 대해 고유한 태그를 생성해야 하지만 서버는 태그 재사용을 허용해야 합니다.

클라이언트는 이 사양에 설명된 구문을 엄격하게 따라야 합니다.  누락되거나 불필요한 공백이나 인수가 포함된 명령을 보내는 것은 구문 오류입니다.

클라이언트의 줄이 완전한 명령을 나타내지 않는 두 가지 경우가 있습니다.  어떤 경우에는 명령 인수가 옥텟 수로 인용됩니다\(섹션 4.3의 리터럴에 대한 설명 참조\). 다른 경우에는 명령 인수에 서버 피드백이 필요합니다\(섹션 6.2.2의 AUTHENTICATE 명령 참조\).  두 경우 모두 서버는 옥텟\(해당하는 경우\)과 나머지 명령에 대한 준비가 되면 명령 연속 요청 응답을 보냅니다.  이 응답에는 토큰 "+"가 접두어로 붙습니다.

- 참고: 대신 서버가 명령에서 오류를 감지한 경우 명령과 일치하는 태그\(아래 설명 참조\)와 함께 BAD 완료 응답을 보내 명령을 거부하고 클라이언트가 더 이상 명령을 보내지 못하도록 합니다.

- 서버가 다른 명령\(여러 명령이 진행 중인 경우\) 또는 태그가 지정되지 않은 데이터에 대한 완료 응답을 보내는 것도 가능합니다.  두 경우 모두 명령 계속 요청이 여전히 보류 중입니다. 클라이언트는 응답에 대해 적절한 조치를 취하고 서버에서 다른 응답을 읽습니다.  모든 경우에 클라이언트는 새 명령을 시작하기 전에 완전한 명령\(모든 명령 연속 요청 응답 수신 및 명령에 대한 명령 연속 전송 포함\)을 보내야 합니다.

IMAP4rev2 서버의 프로토콜 수신자는 클라이언트로부터 명령줄을 읽고, 명령과 해당 인수를 구문 분석하고, 서버 데이터와 서버 명령 완료 결과 응답을 전송합니다.

---
#### **2.2.2.  Server Protocol Sender and Client Protocol Receiver**

서버에서 클라이언트로 전송되는 데이터와 명령 완료를 나타내지 않는 상태 응답에는 "\*" 토큰이 접두어로 붙으며 태그가 없는 응답이라고 합니다.

서버 데이터는 클라이언트 명령의 결과로 전송되거나 서버에 의해 일방적으로 전송될 수 있습니다.  특정 명령에 의해 생성된 서버 데이터와 일방적으로 전송된 서버 데이터 간에는 구문상 차이가 없습니다.

서버 완료 결과 응답은 작업의 성공 또는 실패를 나타냅니다.  작업을 시작한 클라이언트 명령과 동일한 태그가 지정됩니다.  따라서 둘 이상의 명령이 진행 중인 경우 서버 완료 응답의 태그는 응답이 적용되는 명령을 식별합니다.  가능한 서버 완료 응답에는 OK\(성공을 나타냄\), NO\(실패를 나타냄\) 또는 BAD\(인식할 수 없는 명령 또는 명령 구문 오류와 같은 프로토콜 오류를 나타냄\)의 세 가지 응답이 있습니다.

서버는 이 사양에 설명된 구문을 엄격하게 적용해야 합니다.  누락되거나 불필요한 공백이나 인수를 포함하여\(이에 국한되지 않음\) 프로토콜 구문 오류가 있는 모든 클라이언트 명령은 거부되어야 하며 클라이언트에는 BAD 서버 완료 응답이 제공되어야 합니다.

IMAP4rev2 클라이언트의 프로토콜 수신기는 서버에서 응답 줄을 읽습니다.  그런 다음 태그, "\*" 또는 "+"일 수 있는 응답의 첫 번째 토큰을 기반으로 응답에 대한 조치를 취합니다.

클라이언트는 항상 모든 서버 응답을 수락할 준비가 되어 있어야 합니다. 여기에는 요청되지 않은 서버 데이터가 포함됩니다.  서버 데이터는 클라이언트가 데이터를 요청하기 위해 서버에 명령을 보내는 대신 기억된 복사본을 참조할 수 있도록 기억\(캐시\)되어야 합니다.  특정 서버 데이터의 경우 이 문서의 다른 부분에 지정된 대로 데이터를 기억해야 합니다.

이 주제는 "서버 응답"\(섹션 7 참조\)에서 더 자세히 논의됩니다.

---
### **2.3.  Message Attributes**

메시지 텍스트 외에도 각 메시지에는 이와 관련된 여러 속성이 있습니다.  이러한 속성은 개별적으로 검색하거나 다른 속성이나 메시지 텍스트와 함께 검색할 수 있습니다.

---
#### **2.3.1.  Message Numbers**

IMAP4rev2의 메시지는 UID\(고유 식별자\) 또는 메시지 시퀀스 번호라는 두 숫자 중 하나로 액세스됩니다.

---
##### **2.3.1.1.  Unique Identifier (UID) Message Attribute**

UID는 각 메시지에 할당된 서명되지 않은 0이 아닌 32비트 값이며, 고유 식별자 유효성 값\(아래 참조\)과 함께 사용되면 사서함의 다른 메시지 또는 후속 메시지를 참조해서는 안 되는 64비트 값을 형성합니다. 영원히 같은 이름의 사서함.  고유 식별자는 사서함에서 엄격한 오름차순으로 할당됩니다. 각 메시지가 사서함에 추가되면 이미 사서함에 있는 모든 메시지보다 높은 UID가 할당됩니다.  메시지 시퀀스 번호와 달리 고유 식별자는 반드시 연속적일 필요는 없습니다.

메시지의 고유 식별자는 세션 중에 변경되어서는 안 되며 세션 간에도 변경되어서는 안 됩니다.  세션 간의 고유 식별자 변경은 아래에 설명된 UIDVALIDITY 메커니즘을 사용하여 감지할 수 있어야 합니다.  클라이언트가 이전 세션의 상태를 서버와 다시 동기화하려면 지속적인 고유 식별자가 필요합니다\(예: 연결이 끊어졌거나 오프라인 액세스 클라이언트\[IMAP-MODEL\]\). 이에 대해서는 \[IMAP-DISC\]에서 자세히 설명합니다.

모든 사서함에는 고유 식별자 처리를 지원하는 두 개의 32비트 부호 없는 0이 아닌 값, 즉 다음 고유 식별자 값\(UIDNEXT\)과 고유 식별자 유효성 값\(UIDVALIDITY\)이 연결되어 있습니다.

다음 고유 식별자 값은 사서함의 새 메시지에 할당될 예측 값입니다.  고유 식별자 유효성도 변경되지 않는 한\(아래 참조\) 다음 고유 식별자 값은 다음 두 가지 특성을 가져야 합니다.  첫째, 새 메시지가 메일박스에 추가되지 않는 한 다음 고유 식별자 값은 변경되어서는 안 됩니다. 둘째, 새 메시지가 나중에 삭제되더라도 사서함에 새 메시지가 추가될 때마다 다음 고유 식별자 값을 변경해야 합니다.

- |  참고: 다음 고유 식별자 값은 |  클라이언트가 메시지가 전달되었는지 여부를 확인하는 |  이전 확인 이후 사서함으로 배달됨 |  이 값.  |  모든 메시지에는 이 고유 식별자가 있습니다.  클라이언트는 |  다음 고유한 |를 얻을 때에만 가정합니다.  그 시간 이후에 도착하는 메시지는 |  해당 값보다 크거나 같은 UID를 가집니다.

고유 식별자 유효성 값은 사서함 선택 시 태그가 지정되지 않은 OK 응답의 UIDVALIDITY 응답 코드로 전송됩니다. 이전 세션의 고유 식별자가 이 세션에서 유지되지 않는 경우 고유 식별자 유효성 값은 이전 세션에서 사용된 값보다 커야 합니다.  사용하기에 좋은 UIDVALIDITY 값은 값이 할당될 때 현재 날짜/시간을 32비트로 표현하는 것입니다. 이렇게 하면 값이 고유하고 항상 증가합니다. 또 다른 가능한 대안은 사서함이 생성될 때마다 증가하는 전역 카운터입니다.

- 참고: 이상적으로는 고유 식별자가 항상 유지되어야 합니다. 이 사양에서는 특정 서버 환경에서 지속 실패가 불가피할 수 있다는 점을 인식하고 있지만 이 문제를 방지하는 메시지 저장소 구현 기술을 강력히 권장합니다.  예를 들어:

1. 고유 식별자는 항상 사서함에서 엄격하게 오름차순이어야 합니다.  비 IMAP 에이전트에 의해 물리적 메시지 저장소가 다시 정렬되는 경우 사서함의 고유 식별자는 다시 생성되어야 합니다. 이전의 고유 식별자는 다시 정렬의 결과로 더 이상 엄격하게 오름차순이 아니기 때문입니다.

1. 메시지 저장소에 고유 식별자를 저장하는 메커니즘이 없는 경우 각 세션에서 고유 식별자를 재생성해야 하며 각 세션에는 고유한 UIDVALIDITY 값이 있어야 합니다. 이 상황은 클라이언트 메시지 캐싱에 매우 지장을 줄 수 있습니다.

1. 사서함이 삭제/이름이 바뀌고 나중에 동일한 이름의 새 사서함이 생성되는 경우 서버는 이전 사서함 인스턴스의 고유 식별자를 추적하거나 새 인스턴스에 새 UIDVALIDITY 값을 할당해야 합니다. 사서함의.

1. 사서함 이름, UIDVALIDITY 및 UID의 조합은 해당 서버에서 영구적으로 변경할 수 없는\(또는 삭제된\) 단일 메시지를 참조해야 합니다.  특히 내부 날짜, RFC822.SIZE, 봉투, 본문 구조 및 메시지 텍스트\(모든 BODY\[...\] 페치 데이터 항목\)는 절대로 변경되어서는 안 됩니다.  여기에는 메시지 번호가 포함되지 않으며 STORE 명령\(예: FLAGS\)으로 설정할 수 있는 속성도 포함되지 않습니다.  메시지가 삭제되면 해당 UID는 동일한 UIDVALIDITY 값에서 재사용되어서는 안 됩니다.

---
##### **2.3.1.2.  Message Sequence Number Message Attribute**

메시지 시퀀스 번호는 1부터 사서함에 있는 메시지 수까지의 상대적 위치입니다.  이 위치는 고유 식별자의 오름차순으로 정렬되어야 합니다.  각각의 새 메시지가 추가될 때마다 새 메시지가 추가되기 전 사서함에 있던 메시지 수보다 1 더 큰 메시지 시퀀스 번호가 할당됩니다.

세션 중에 메시지 시퀀스 번호를 다시 할당할 수 있습니다.  예를 들어 메시지가 편지함에서 영구적으로 제거\(말소\)되면 모든 후속 메시지의 메시지 시퀀스 번호가 감소됩니다.  사서함의 메시지 수도 감소합니다.  마찬가지로, 삭제되기 전에 다른 메시지에 한때 보관되었던 메시지 시퀀스 번호가 새 메시지에 할당될 수 있습니다.

사서함의 상대적 위치를 기준으로 메시지에 액세스하는 것 외에도 수학적 계산에 메시지 순서 번호를 사용할 수 있습니다.  예를 들어 태그가 지정되지 않은 "11 EXISTS"가 수신되고 이전에 태그가 지정되지 않은 "8 EXISTS"가 수신된 경우 메시지 시퀀스 번호가 9, 10 및 11인 세 개의 새 메시지가 도착했습니다. 523 메시지 사서함의 UID는 12345이며, ​​정확히 286개의 메시지가 더 작은 UID를 갖고 236개의 메시지가 더 큰 UID를 가지고 있습니다.

---
#### **2.3.2.  Flags Message Attribute**

메시지에는 "플래그"라고 알려진 0개 이상의 명명된 토큰 목록이 있습니다.  플래그는 이 목록에 추가되면 설정되고 제거되면 지워집니다.  IMAP4rev2에는 시스템 플래그와 키워드라는 두 가지 유형의 플래그가 있습니다.  두 유형 중 하나의 플래그는 영구적이거나 세션 전용일 수 있습니다.

시스템 플래그는 본 명세서에서 미리 정의된 플래그 이름으로 "\"로 시작한다.  특정 시스템 플래그\(\Deleted 및 \Seen\)에는 이 문서의 다른 부분에 설명된 특별한 의미가 있습니다.  현재 정의된 시스템 플래그는 다음과 같습니다.

```text
   \Seen         Message has been read

   \Answered     Message has been answered

   \Flagged      Message is "flagged" for urgent/special attention

   \Deleted      Message is "deleted" for removal by later EXPUNGE

   \Draft        Message has not completed composition (marked as a
                 draft).

   \Recent       This flag was in use in IMAP4rev1 and is now
                 deprecated.
```

키워드는 서버 구현에 의해 정의됩니다.  키워드는 "\"로 시작하지 않습니다.  서버는 클라이언트가 메일함에서 새 키워드를 정의하도록 허용할 수 있습니다\(자세한 내용은 PERMANENTFLAGS 응답 코드 설명 참조\).  "$"로 시작하는 일부 키워드도 본 사양에 정의되어 있습니다.

이 문서는 \[RFC3501\]에 원래 정의되지 않았지만 클라이언트 구현에 의해 유용한 것으로 밝혀진 여러 키워드를 정의합니다.  이러한 키워드는 서버 구현에서 지원되어야 합니다\(SEARCH에서 허용되고 APPEND, COPY 및 MOVE 명령에서 허용 및 보존되어야 함\).

$Forwarded - 메시지가 새 메시지에 포함되거나 첨부되어 다른 이메일 주소로 전달되었습니다.  이메일 클라이언트는 메시지를 다른 이메일 주소로 성공적으로 전달할 때 이 키워드를 설정합니다.  이 키워드의 일반적인 사용법은 전달된 메시지에 대해 다른\(또는 추가\) 아이콘을 표시하는 것입니다.  일단 설정된 플래그는 지워져서는 안 됩니다.

$MDNSent - 메시지 처리 알림 \[RFC8098\]이 이 메시지에 대해 생성되어 전송되었습니다.  이 키워드가 사용되는 방법과 클라이언트 및 서버 요구 사항에 대한 자세한 내용은 \[RFC3503\]을 참조하세요.

$Junk - 사용자\(또는 사용자를 대신하는 배달 에이전트\)는 메시지를 확실히 정크\($Junk, 관련 키워드 $NotJunk 참조\)가 포함된 것으로 표시하도록 선택할 수 있습니다.  $Junk 키워드는 원치 않는 메시지를 표시, 그룹화 또는 숨기는 데 사용할 수 있습니다. 이러한 메시지는 나중에 이동되거나 삭제될 수 있습니다.  자세한 내용은 \[IMAP-KEYWORDS-REG\]를 참조하세요.

$NotJunk - 사용자\(또는 사용자를 대신하는 배달 에이전트\)는 메시지를 확실히 정크가 포함되지 않은 것으로 표시하도록 선택할 수 있습니다\($NotJunk, 관련 키워드 $Junk 참조\).  $NotJunk 키워드는 사용자가 보고 싶어하는 메시지를 표시, 그룹화 또는 표시하는 데 사용할 수 있습니다.  자세한 내용은 \[IMAP-KEYWORDS-REG\]를 참조하세요.

$Phishing - $Phishing 키워드는 배달 에이전트가 메시지를 피싱 이메일일 가능성이 높은 것으로 표시하는 데 사용할 수 있습니다.  배달 에이전트가 피싱 이메일로 판단한 메시지도 정크 이메일로 간주되어야 하며 $Junk 플래그 설정 및 메시지를 \Junk 특수 용도 사서함에 배치하는 것을 포함하여 적절한 정크 필터링을 적용해야 합니다\(섹션 7.3 참조\). .1\), 가능한 경우.

- $Phishing 플래그와 $Junk 플래그가 모두 설정된 경우 사용자 에이전트는 사용자에게 추가 경고 메시지를 표시해야 합니다. 또한 사용자 에이전트는 사용자가 메시지 내의 하이퍼링크를 클릭할 때 "이 메시지는 귀하의 개인 정보를 도용하려고 시도했을 수 있습니다."와 같은 경고를 표시할 수 있습니다.

- 사용자 에이전트가 경고를 표시하기 전에 $Phishing 및 $Junk를 모두 설정해야 하는 요구 사항은 $Junk 플래그는 이해하지만 $Phishing 플래그는 이해하지 못하는 기존 클라이언트와의 하위 호환성을 높이기 위한 것입니다.  이는 확장되지 않은 클라이언트가 $Junk 플래그를 제거할 때 확장 클라이언트도 올바른 상태를 표시하기 위한 것입니다.  자세한 내용은 \[IMAP-KEYWORDS-REG\]를 참조하세요.

$Junk와 $NotJunk는 상호 배타적입니다.  메시지에 대해 둘 이상이 설정된 경우 클라이언트는 이를 아무것도 설정되지 않은 것처럼 처리해야 하며 IMAP 서버에서 두 가지 모두 설정을 해제해야 합니다.

기타 등록된 키워드는 "IMAP 및 JMAP 키워드" 레지스트리 \[IMAP-KEYWORDS-REG\]에서 찾을 수 있습니다.  \[RFC5788\]에 지정된 절차를 사용하여 새 키워드를 이 레지스트리에 등록해야 합니다.

플래그는 플래그별로 영구적이거나 세션 전용일 수 있습니다. 영구 플래그는 클라이언트가 메시지 플래그에 영구적으로 추가하거나 제거할 수 있는 플래그입니다. 즉, 동시 및 후속 세션에서는 영구 플래그가 변경됩니다.  세션 플래그에 대한 변경 사항은 해당 세션에서만 유효합니다.

---
#### **2.3.3.  Internal Date Message Attribute**

내부 날짜 메시지 속성은 서버에 있는 메시지의 내부 날짜 및 시간입니다.  이는 \[RFC5322\] 헤더의 날짜 및 시간이 아니라 메시지가 수신된 시간을 반영하는 날짜 및 시간입니다.  \[SMTP\]를 통해 전달된 메시지의 경우 \[SMTP\]에서 정의한 메시지의 최종 전달 날짜 및 시간입니다.  IMAP4rev2 COPY 또는 MOVE 명령으로 생성된 메시지의 경우 이는 소스 메시지의 내부 날짜 속성과 동일해야 합니다.  IMAP4rev2 APPEND 명령으로 생성된 메시지의 경우 이는 APPEND 명령 설명에 지정된 날짜 및 시간이어야 합니다.  다른 모든 경우는 구현이 정의됩니다.

---
#### **2.3.4.  RFC822.SIZE Message Attribute**

RFC822.SIZE는 메시지가 \[RFC5322\] 형식으로 표현될 때 메시지의 옥텟 수입니다.  이 크기는 "FETCH BODY\[\]" 명령의 결과와 일치해야 합니다.  메시지가 내부적으로 다른 형식으로 저장된 경우 서버는 크기를 계산하고 나중에 다시 계산할 필요가 없도록 나중에 사용할 수 있도록 저장하는 경우가 많습니다.

---
#### **2.3.5.  Envelope Structure Message Attribute**

봉투 구조는 메시지의 \[RFC5322\] 헤더를 구문 분석한 표현입니다.  IMAP 봉투 구조는 \[SMTP\] 봉투와 동일하지 않습니다.

---
#### **2.3.6.  Body Structure Message Attribute**

본문 구조는 메시지의 \[MIME-IMB\] 본문 구조 정보를 구문 분석한 표현입니다.

---
### **2.4.  Message Texts**

IMAP4rev2는 메시지의 전체 \[RFC5322\] 텍스트를 가져올 수 있을 뿐만 아니라 전체 메시지 텍스트의 일부를 가져올 수도 있습니다.  구체적으로 \[RFC5322\] 메시지 헤더, \[RFC5322\] 메시지 본문, \[MIME-IMB\] 본문 부분 또는 \[MIME-IMB\] 헤더를 가져오는 것이 가능합니다.

---
## **3.  State and Flow Diagram**

클라이언트와 서버 간의 연결이 설정되면 IMAP4rev2 연결은 네 가지 상태 중 하나가 됩니다.  초기 상태는 서버 인사말에서 식별됩니다.  대부분의 명령은 특정 상태에서만 유효합니다.  연결이 부적절한 상태에 있는 동안 클라이언트가 명령을 시도하는 것은 프로토콜 오류이며, 서버는 BAD 또는 NO\(서버 구현에 따라 다름\) 명령 완료 결과로 응답합니다.

---
### **3.1.  Not Authenticated State**

인증되지 않은 상태에서 클라이언트는 대부분의 명령이 허용되기 전에 인증 자격 증명을 제공해야 합니다.  연결이 사전 인증되지 않은 경우 연결이 시작되면 이 상태로 들어갑니다.

---
### **3.2.  Authenticated State**

인증된 상태에서 클라이언트는 인증되었으며 메시지에 영향을 미치는 명령이 허용되기 전에 액세스할 사서함을 선택해야 합니다.  이 상태는 사전 인증된 연결이 시작될 때, 허용 가능한 인증 자격 증명이 제공되었을 때, 사서함 선택 시 오류가 발생한 후, CLOSE 또는 UNSELECT 명령이 성공한 후에 시작됩니다.

---
### **3.3.  Selected State**

선택 상태에서는 액세스할 사서함이 선택되었습니다.  이 상태는 사서함이 성공적으로 선택되면 시작됩니다.

---
### **3.4.  Logout State**

로그아웃 상태에서는 접속이 종료됩니다.  이 상태는 클라이언트 요청\(LOGOUT 명령을 통해\)의 결과로 입력되거나 클라이언트나 서버 측의 일방적 작업에 의해 입력될 수 있습니다.

클라이언트가 로그아웃 상태를 요청하는 경우 서버는 연결을 닫기 전에 태그가 지정되지 않은 BYE 응답과 태그가 지정된 OK 응답을 LOGOUT 명령에 보내야 합니다. 클라이언트는 연결을 닫기 전에 LOGOUT 명령에 대한 태그된 OK 응답을 읽어야 합니다.

서버는 그렇게 하는 이유가 포함된 태그가 지정되지 않은 BYE 응답을 먼저 보내지 않고 일방적으로 연결을 닫아서는 안 됩니다.  클라이언트는 연결을 일방적으로 종료해서는 안 됩니다. 대신 LOGOUT 명령을 실행해야 합니다.  클라이언트가 일방적으로 연결을 닫은 것을 서버가 감지하면 서버는 태그가 지정되지 않은 BYE 응답을 생략하고 연결을 닫을 수도 있습니다.

```text
                      +----------------------+
                      |connection established|
                      +----------------------+
                                 ||
                                 \/
               +--------------------------------------+
               |          server greeting             |
               +--------------------------------------+
                         || (1)       || (2)        || (3)
                         \/           ||            ||
               +-----------------+    ||            ||
               |Not Authenticated|    ||            ||
               +-----------------+    ||            ||
                || (7)   || (4)       ||            ||
                ||       \/           \/            ||
                ||     +----------------+           ||
                ||     | Authenticated  |<=++       ||
                ||     +----------------+  ||       ||
                ||       || (7)   || (5)   || (6)   ||
                ||       ||       \/       ||       ||
                ||       ||    +--------+  ||       ||
                ||       ||    |Selected|==++       ||
                ||       ||    +--------+           ||
                ||       ||       || (7)            ||
                \/       \/       \/                \/
               +--------------------------------------+
               |               Logout                 |
               +--------------------------------------+
                                 ||
                                 \/
                   +-------------------------------+
                   |both sides close the connection|
                   +-------------------------------+
```

위 다이어그램의 범례:

\(1\) 사전 인증 없이 연결\(OK 인사말\) \(2\) 사전 인증된 연결\(PREAUTH 인사말\) \(3\) 거부된 연결\(BYE 인사말\) \(4\) 성공적인 LOGIN 또는 AUTHENTICATE 명령 \(5\) 성공적인 SELECT 또는 EXAMINE 명령 \(6\) \) CLOSE 또는 UNSELECT 명령, 원치 않는 CLOSED 응답 코드 또는 실패한 SELECT 또는 EXAMINE 명령 \(7\) LOGOUT 명령, 서버 종료 또는 연결 종료

---
## **4.  Data Formats**

IMAP4rev2는 텍스트 명령과 응답을 사용합니다.  IMAP4rev2의 데이터는 원자, 숫자, 문자열, 괄호로 묶인 목록 또는 NIL 등 여러 형식 중 하나일 수 있습니다.  특정 데이터 항목은 두 가지 이상의 형식을 취할 수 있습니다. 예를 들어, "astring" 구문을 사용하여 정의된 데이터 항목은 원자 또는 문자열일 수 있습니다.

---
### **4.1.  Atom**

원자는 하나 이상의 특수 문자가 아닌 문자로 구성됩니다.

---
#### **4.1.1.  Sequence Set and UID Set**

메시지 세트는 메시지 시퀀스 번호나 고유 식별자를 포함하는 시퀀스 세트로 참조될 수 있습니다.  자세한 내용은 섹션 9를 참조하세요.  시퀀스 세트에는 시퀀스 번호 범위\(예: "5:50"\), 특정 시퀀스 번호 열거 또는 위 항목의 조합이 포함될 수 있습니다.  시퀀스 세트는 특수 기호 "\*"를 사용하여 메일함의 최대 시퀀스 번호를 나타낼 수 있습니다.  시퀀스 세트에는 고유 식별자가 포함되지 않습니다.

"UID 세트"는 시퀀스 세트와 유사하지만 메시지 시퀀스 번호 대신 고유 식별자를 사용하고 특수 기호 "\*"를 포함하는 것이 허용되지 않습니다.

---
### **4.2.  Number**

숫자는 하나 이상의 숫자 문자로 구성되며 숫자 값을 나타냅니다.

---
### **4.3.  String**

문자열은 동기화 리터럴, 비동기화 리터럴 또는 인용 문자열의 세 가지 형식 중 하나입니다.  동기화 리터럴 형식은 문자열에 포함될 수 있는 문자에 대한 제한 없이 문자열의 일반적인 형식입니다.  비동기화 리터럴 형식도 일반적인 형식이지만 길이 제한이 있습니다.  인용된 문자열 형식은 리터럴 처리의 오버헤드를 방지하는 대안이지만 사용할 수 있는 문자에 제한이 있습니다.

동기화 리터럴과 비동기화 리터럴 간의 구분이 중요하지 않은 경우 이 문서에서는 "리터럴"이라는 용어만 사용합니다.

동기화 리터럴은 여는 중괄호\("{"\), 옥텟 수, 닫는 중괄호\("}" 형식의 옥텟 수로 접두사로 묶인 0개 이상의 옥텟\(CR 및 LF 포함\) 시퀀스입니다. \) 및 CRLF.  서버에서 클라이언트로 전송되는 리터럴을 동기화하는 경우 CRLF 바로 뒤에 옥텟 데이터가 옵니다. 클라이언트에서 서버로 전송된 리터럴을 동기화하는 경우 클라이언트는 옥텟 데이터\(및 명령의 나머지 부분\)를 보내기 전에 명령 연속 요청\(이 문서의 뒷부분에 설명됨\)을 수신할 때까지 기다려야 합니다.

비동기화 리터럴은 동기화 리터럴의 대체 형식이며 동기화 리터럴이 허용되는 모든 곳에서 클라이언트에서 서버로 사용될 수 있습니다.  비동기화 리터럴 형식은 서버에서 클라이언트로 전송되어서는 안 됩니다.  비동기화 리터럴은 옥텟 수와 닫는 중괄호\("}"\) 사이에 더하기\("+"\)를 사용하여 동기화 리터럴과 구별됩니다.  서버는 비동기화 리터럴에 대한 응답으로 명령 연속 요청을 생성하지 않으며 클라이언트는 비동기화 리터럴의 옥텟을 보내기 전에 기다릴 필요가 없습니다.  IMAP 확장에 달리 지정되지 않는 한, 비동기화 리터럴은 4096 옥텟보다 커서는 안 됩니다.  4096바이트보다 큰 리터럴은 반드시 동기화 리터럴로 전송되어야 합니다.  \(이 문서에 정의된 비동기화 리터럴은 \[RFC7888\]의 LITERAL- 확장에 의해 정의된 비동기화 리터럴과 동일합니다. 4096 옥텟보다 긴 유효하지 않은 비동기화 리터럴을 처리하는 방법과 다음과의 상호 작용에 대한 자세한 내용은 해당 문서를 참조하세요. 다른 IMAP 확장자.\)

따옴표 붙은 문자열은 CR 및 LF를 제외하고 UTF-8로 인코딩된 0개 이상의 유니코드 문자 시퀀스이며 각 끝에 큰따옴표\(<"\>\) 문자가 있습니다.

빈 문자열은 ""\(큰따옴표 사이에 문자가 없는 따옴표 붙은 문자열\), {0} 뒤에 CRLF\(옥텟 수가 0인 동기화 리터럴\) 또는 {0+} 뒤에 CRLF로 표시됩니다. \(옥텟 수가 0인 비동기화 리터럴\)

- 참고: 옥텟 수가 0이더라도 동기화 리터럴을 전송하는 클라이언트는 명령 연속 요청을 수신하기 위해 기다려야 합니다.

---
#### **4.3.1.  8-Bit and Binary Strings**

8비트 텍스트 및 바이너리 메일은 \[MIME-IMB\] 콘텐츠 전송 인코딩을 사용하여 지원됩니다.  IMAP4rev2 구현은 8비트 또는 다중 옥텟 문자를 리터럴로 전송할 수 있지만 \[CHARSET\]이 식별된 경우에만 그렇게 해야 합니다.

IMAP4rev2는 \[I18N-HDRS\]와 호환됩니다.  결과적으로 8비트 콘텐츠가 포함된 헤더 필드 값에 대해 식별된 문자 집합은 UTF-8\[UTF-8\]입니다.  IMAP4rev2 구현은 문자열에 NUL, CR 또는 LF가 포함되지 않는 한 인용 문자열로 된 \[UTF-8\] 텍스트를 허용하고 전송할 수 있습니다\(MUST\).  이는 IMAP4rev1 구현과 다릅니다.

BINARY 콘텐츠 전송 인코딩이 정의되었더라도 BINARY.PEEK\[<section-binary\>\]<<partial\>\> 또는 BINARY\[<section-binary\>에 대한 응답으로 <literal8\>에서 반환되지 않는 한 인코딩되지 않은 바이너리 문자열은 허용되지 않습니다. \]<<부분\>\> FETCH 데이터 항목.  "이진 문자열"은 NUL 문자가 포함된 문자열입니다.  CTL 문자 수가 너무 많은 문자열도 바이너리로 간주될 수 있습니다.  BINARY.PEEK\[...\]/BINARY\[...\] FETCH에 대한 응답으로 반환되지 않는 한, 클라이언트 및 서버 구현은 데이터를 전송하기 전에 바이너리 데이터를 base64와 같은 텍스트 형식으로 인코딩해야 합니다.

---
### **4.4.  Parenthesized List**

데이터 구조는 "괄호로 묶인 목록"으로 표시됩니다. 공백으로 구분되고 각 끝이 괄호로 묶인 일련의 데이터 항목입니다.  괄호로 묶인 목록은 중첩을 나타내기 위해 여러 수준의 괄호를 사용하여 괄호로 묶인 다른 목록을 포함할 수 있습니다.

빈 목록은 \(\)로 표시됩니다. 즉, 구성원이 없는 괄호로 묶인 목록입니다.

---
### **4.5.  NIL**

특수 형식 "NIL"은 빈 문자열 "" 또는 빈 괄호로 묶인 목록\(\)과 구별되는 문자열 또는 괄호로 묶인 목록으로 표시되는 특정 데이터 항목이 존재하지 않음을 나타냅니다.

- |  참고: NIL은 | 형식을 사용하는 데이터 항목에는 절대 사용되지 않습니다.  원자의.  예를 들어, "NIL"이라는 사서함 이름은 |  존재하지 않는 사서함 이름과 달리 NIL이라는 이름이 지정되었습니다.  이것은 |  왜냐하면 메일함은 원자 또는 | 문자열인 "astring" 구문을 사용하기 때문입니다.  끈.  반대로 NIL의 addr-name은 존재하지 않는 |  개인 이름: addr-name이 "nstring" 구문을 사용하기 때문에 |  NIL 또는 문자열이지만 원자는 아닙니다.

```text
   Examples:
```

다음 LIST 응답:

```text
     * LIST () "/" NIL
```

다음과 같습니다:

```text
     * LIST () "/" "NIL"
```

LIST 응답으로 ABNF는 사서함 이름으로 "astring"을 사용하고 있습니다.

그러나 다음과 같은 응답이 있습니다.

```text
     * FETCH 1 (BODY[1] NIL)
```

다음과 동일하지 않습니다:

```text
     * FETCH 1 (BODY[1] "NIL")
```

전자는 본문 부분이 없음을 나타내고, 후자는 "NIL"이라는 세 문자가 포함된 문자열이 포함되어 있음을 의미합니다.

---
## **5.  Operational Considerations**

모든 IMAP4rev2 구현이 올바르게 상호 운용되도록 하기 위해 다음 규칙이 여기에 나열되어 있습니다.

---
### **5.1.  Mailbox Naming**

IMAP4rev2에서는 사서함 이름이 Net-Unicode\[NET-UNICODE\]로 인코딩됩니다\(IMAP4rev1과 다름\).  클라이언트 구현은 Net-Unicode 사서함 이름을 생성하려고 시도할 수 있으며 LIST에서 반환된 8비트 사서함 이름을 \[NET-UNICODE\]로 해석해야 합니다\(MUST\).  서버 구현에서는 Net-Unicode를 준수하지 않는 8비트 사서함 이름 생성을 금지해야 합니다\(MUST\).  그러나 서버는 사서함 생성 전에 비정규화된 UTF-8 사서함 이름을 허용하고 이를 Net-Unicode 요구 사항에 따라 NFC\(Unicode Normalization Form C\)로 변환할 수 있습니다.  이러한 비정규화된 UTF-8 메일함 이름을 허용하도록 선택한 서버는 메일함 이름 매개변수가 있는 모든 IMAP 명령에서 이를 수락해야 합니다. 특히 SELECT <name\>은 <name\>이 비정규화된 UTF-8 사서함 이름인 경우에도 CREATE <name\>을 사용하여 성공적으로 생성된 동일한 사서함을 열어야 합니다.

대소문자를 구분하지 않는 사서함 이름 INBOX는 "이 서버에 있는 이 사용자의 기본 사서함"을 의미하기 위해 예약된 특수 이름입니다.  \(예를 들어 사용자가 개인 네임스페이스에 액세스할 수 없는 경우 등 일부 사용자의 경우 이 특수 이름이 일부 서버에 존재하지 않을 수 있습니다.\) 다른 모든 이름의 해석은 구현에 따라 다릅니다.

특히 이 사양은 INBOX가 아닌 메일함 이름의 대소문자 구분에 대해 어떠한 입장도 취하지 않습니다.  일부 서버 구현은 ASCII 범위에서 대소문자를 완전히 구분합니다. 다른 것들은 새로 생성된 이름의 대소문자를 유지하지만 그렇지 않은 경우에는 대소문자를 구분하지 않습니다. 또 다른 사람들은 특정 사례에 이름을 강요합니다.  클라이언트 구현은 이들 중 하나와 상호 작용할 수 있어야 합니다.

새 사서함 이름을 만들 때 특정 클라이언트 고려 사항이 있습니다.

1. 특수 원자 중 하나인 모든 문자\(섹션 9의 "형식 구문" 참조\)에는 사서함 이름이 인용된 문자열 또는 리터럴로 표시되어야 합니다.

1. CTL 및 기타 그래픽이 아닌 문자는 사용자 인터페이스에서 표현하기 어려우므로 사용하지 않는 것이 가장 좋습니다.  서버는 유니코드 CTL 문자가 포함된 사서함 이름 생성을 거부할 수 있습니다.

1. 목록-와일드카드 문자\("%" 및 "\*"\)는 사서함 이름에 유효하지만 와일드카드 해석과의 충돌로 인해 LIST 명령에서 이러한 사서함 이름을 사용하기가 어렵습니다.

1. 일반적으로 문자\(서버 구현에 의해 결정됨\)는 계층 구조 수준을 구분하기 위해 예약되어 있습니다.

1. 두 문자 "#" 및 "&"는 관례에 따른 의미를 가지며 해당 관례에서 사용되는 경우를 제외하고는 사용하지 않아야 합니다.  각각 섹션 5.1.2.1과 부록 A.1을 참조하세요.

---
#### **5.1.1.  Mailbox Hierarchy Naming**

계층적 사서함 이름을 내보내려는 경우 사서함 이름은 계층 수준을 구분하기 위해 단일 ASCII 문자를 사용하여 왼쪽에서 오른쪽으로 계층적이어야 합니다.  단일 이름 내의 모든 계층 수준에 동일한 계층 구분 문자가 사용됩니다.

---
#### **5.1.2.  Namespaces**

개인 네임스페이스: - 특정 연결에서 인증된 사용자의 개인 범위 내에서 서버가 고려하는 네임스페이스입니다.  일반적으로 인증된 사용자만 개인 네임스페이스의 사서함에 액세스할 수 있습니다.  이는 사용자에게 속하고 사서함에 할당되는 네임스페이스의 일부입니다.  사용자에 대한 INBOX가 존재하는 경우 사용자의 개인 네임스페이스 내에 나타나야 합니다. 일반적인 경우 서버에는 사용자당 하나의 개인 네임스페이스만 있어야 합니다.

다른 사용자의 네임스페이스: - 다른 사용자의 개인 네임스페이스의 사서함으로 구성된 네임스페이스입니다.  다른 사용자의 네임스페이스에 있는 사서함에 액세스하려면 현재 인증된 사용자에게 명시적으로 액세스 권한이 부여되어야 합니다.  예를 들어 관리자가 관리 지원 직원에게 사서함에 대한 액세스 권한을 부여하는 것이 일반적입니다.  일반적인 경우에는 서버의 사용자당 다른 사용자의 네임스페이스가 하나만 있어야 합니다.

공유 네임스페이스: - 사용자 간에 공유하도록 의도된 사서함으로 구성되고 사용자의 개인 네임스페이스 내에 존재하지 않는 네임스페이스입니다.

서버가 사용하는 네임스페이스는 사용자별로 다를 수 있습니다.

---
##### **5.1.2.1.  Historic Mailbox Namespace Naming Convention**

규칙에 따라 "#"으로 시작하는 사서함 이름의 첫 번째 계층 요소는 나머지 이름의 "네임스페이스"를 식별합니다.  이를 통해 각각 고유한 네임스페이스를 갖는 다양한 유형의 사서함 저장소를 명확하게 구분할 수 있습니다.

- 예를 들어, USENET 뉴스그룹에 대한 액세스를 제공하는 구현은 "#news" 네임스페이스를 사용하여 USENET 뉴스그룹 네임스페이스를 다른 사서함의 네임스페이스와 분할할 수 있습니다.  따라서 comp.mail.misc 뉴스 그룹은 "#news.comp.mail.misc"라는 사서함 이름을 가지며 "comp.mail.misc"라는 이름은 다른 개체\(예: 사용자의 개인 사서함\)를 참조할 수 있습니다. .

"#" 문자를 포함하는 네임스페이스는 IMAP URL \[IMAP-URL\] 친화적이지 않으며 URL 내에서 "#" 문자가 %23으로 표시되어야 합니다.  따라서 서버 구현자는 대신 "#" 문자를 포함하지 않는 네임스페이스 접두사 사용을 고려할 수 있습니다.

---
##### **5.1.2.2.  Common Namespace Models**

이 프로토콜의 이전 버전은 기본 서버 네임스페이스를 정의하지 않았습니다.  두 가지 일반적인 네임스페이스 모델이 발전했습니다.

표시되는 기본 네임스페이스가 사용자의 개인 사서함으로만 구성되는 "개인 사서함" 모델.  공유 사서함에 액세스하려면 사용자는 이스케이프 메커니즘을 사용하여 다른 네임스페이스에 접근해야 합니다.

표시되는 기본 네임스페이스에는 사용자가 액세스할 수 있는 다른 사서함과 함께 사용자의 개인 사서함이 포함되는 "완전한 계층 구조" 모델이 있습니다.

---
### **5.2.  Mailbox Size and Message Status Updates**

언제든지 서버는 클라이언트가 요청하지 않은 데이터를 보낼 수 있습니다. 때때로 이 사양 및/또는 확장에서는 이러한 동작이 필요합니다.  예를 들어, 서버 이외의 에이전트는 사서함에 메시지를 추가할 수 있습니다\(예: 새 메시지 전달\). 사서함에 있는 메시지의 플래그를 변경합니다\(예: 여러 에이전트가 동일한 사서함에 동시에 액세스\). 또는 사서함에서 메시지를 제거할 수도 있습니다.  명령을 처리하는 동안 메일함 크기 변경이 관찰되면 서버는 메일함 크기 업데이트를 자동으로 보내야 합니다.  서버는 클라이언트가 그러한 업데이트를 명시적으로 요청할 필요 없이 자동으로 메시지 플래그 업데이트를 보내야 합니다.

동기화 오류를 방지하기 위해 메시지 제거에 대한 클라이언트의 서버 알림에 대한 특별한 규칙이 있습니다. 자세한 내용은 말소 대응 설명\(섹션 7.5.1\)을 참조하세요. 특히 사서함의 메시지 수를 줄이는 EXISTS 응답을 보내는 것은 허용되지 않습니다. EXPUNGE 응답만이 이를 수행할 수 있습니다.

클라이언트가 서버의 데이터 기억에 관해 어떤 구현 결정을 내리든 관계없이 클라이언트 구현은 메일함 크기 업데이트를 기억해야 합니다.  초기 메일박스 선택 이후의 모든 명령이 메일박스의 크기를 반환한다고 가정해서는 안 됩니다.

---
### **5.3.  Response When No Command in Progress**

서버 구현에서는 진행 중인 명령이 없는 동안 태그가 지정되지 않은 응답\(EXUNGE 제외\)을 보내는 것이 허용됩니다.  그러한 응답을 보내는 서버 구현은 흐름 제어 고려 사항을 처리해야 합니다.  특히 \(1\) 데이터 크기가 기본 전송의 사용 가능한 창 크기를 초과하지 않는지 확인하거나 \(2\) 비차단 쓰기를 사용해야 합니다.

---
### **5.4.  Autologout Timer**

서버에 인증 후 세션에 적용되는 비활성 자동 로그아웃 타이머가 있는 경우 해당 타이머의 지속 시간은 최소 30분이어야 합니다.  해당 간격 동안 클라이언트로부터 명령을 수신하면 자동 로그아웃 타이머가 재설정됩니다.

이 사양에는 성공적인 클라이언트 인증 전에 사용되는 자동 로그아웃 타이머에 대한 제한이 없습니다.  특히 서버는 서비스 거부 공격으로부터 자신을 보호하기 위해 단축된 사전 인증 타이머를 사용할 수 있습니다.

---
### **5.5.  Multiple Commands in Progress (Command Pipelining)**

클라이언트는 기본 데이터 스트림에 대한 모호성 규칙\(아래 참조\) 및 흐름 제어 제약 조건에 따라 명령의 완료 결과 응답을 기다리지 않고 다른 명령을 보낼 수 있습니다.  마찬가지로, 서버는 모호성 규칙에 따라 현재 명령을 완료하기 전에 다른 명령 처리를 시작할 수 있습니다.  그러나 모든 명령 연속 요청 응답과 명령 연속은 후속 명령이 시작되기 전에 협상되어야 합니다.

다른 명령의 결과에 영향을 미치는 명령으로 인해 모호성이 발생하는 경우는 예외입니다.  서버가 모호함을 감지하면 클라이언트가 지정한 순서대로 명령을 실행하여 완료해야 합니다.

모호함의 가장 분명한 예는 명령이 다른 명령의 결과에 영향을 미치는 경우입니다.  한 가지 예는 \Seen 플래그를 설정하고 SEARCH UNSEEN 명령을 발생시키는 FETCH입니다.

태그가 지정되지 않은 EXPUNGE 응답을 허용하는 명령\(FETCH, STORE 및 SEARCH 이외의 명령\)에서는 명확하지 않은 모호성이 발생합니다. 태그가 지정되지 않은 EXPUNGE 응답은 후속 명령의 시퀀스 번호를 무효화할 수 있기 때문입니다.  FETCH, STORE 또는 SEARCH 명령의 경우 이러한 명령이 진행 중인 동안에는 서버가 EXPUNGE 응답을 보내는 것이 금지되어 있으므로 이는 문제가 되지 않습니다.  따라서 클라이언트가 FETCH, STORE 또는 SEARCH 이외의 명령을 보내는 경우 메시지 시퀀스 번호가 포함된 명령을 보내기 전에 완료 결과 응답을 기다려야 합니다.

- 참고: UID FETCH, UID STORE 및 UID SEARCH가 진행되는 동안 EXPUNGE 응답이 허용됩니다.  클라이언트가 UID 명령을 보내는 경우 메시지 시퀀스 번호\(UID 검색이 포함될 수 있음\)를 사용하는 명령을 보내기 전에 완료 결과 응답을 기다려야 합니다.  UID SEARCH에 대한 인수의 모든 메시지 시퀀스 번호는 UID SEARCH에서 반환된 태그가 지정되지 않은 EXPUNGE 응답이 적용되기 전의 메시지와 연결됩니다.

예를 들어, 다음과 같은 대기하지 않는 명령 시퀀스는 유효하지 않습니다.

```text
      FETCH + NOOP + STORE

      STORE + COPY + FETCH

      COPY + COPY
```

다음은 대기하지 않는 유효한 명령 시퀀스의 예입니다.

```text
      FETCH + STORE + SEARCH + NOOP

      STORE + COPY + EXPUNGE
```

UID SEARCH + UID SEARCH는 두 번째 UID SEARCH에 메시지 시퀀스 번호가 포함되어 있는지 여부에 따라 대기하지 않는 명령 시퀀스로 유효하거나 유효하지 않을 수 있습니다.

SEARCH 결과 변수\(섹션 6.4.4.1 참조\)를 사용하면 두 명령 간에 직접적인 종속성이 생성됩니다.  이러한 종속 명령을 파이프라인하는 데 대한 추가 고려 사항은 섹션 6.4.4.2를 참조하세요.

---
## **6.  Client Commands**

이 섹션에서는 IMAP4rev2 명령에 대해 설명합니다.  명령은 명령이 허용되는 상태에 따라 구성됩니다.  여러 상태에서 허용되는 명령은 최소 허용 상태에 나열됩니다. 예를 들어 인증된 상태와 선택 상태에서 유효한 명령은 인증된 상태 명령에 나열됩니다.

아래 명령 설명에서 "인수:"로 식별되는 명령 인수는 구문이 아닌 기능으로 설명됩니다.  명령 인수의 정확한 구문은 "형식 구문"\(섹션 9\)에 설명되어 있습니다.

일부 명령은 특정 서버 응답을 반환하게 합니다. 이는 아래 명령 설명에서 "응답:"으로 식별됩니다. 이러한 응답에 대한 정보는 "응답"\(섹션 7\)의 응답 설명을 참조하고, 이러한 응답의 정확한 구문은 "형식 구문"\(섹션 9\)을 참조하세요.  모든 명령의 결과로 서버 데이터가 전송될 수 있습니다.  따라서 서버 데이터가 특별히 필요하지 않은 명령은 "없음" 대신 "이 명령에 대한 특정 응답 없음"을 지정합니다.

명령 설명의 "결과:"는 명령에 대한 태그가 지정된 상태 응답과 이러한 상태 응답의 특별한 해석을 나타냅니다.

연결 상태는 상태 변경으로 문서화된 성공적인 명령에 의해서만 변경됩니다.  거부된 명령\(BAD 응답\)은 연결 상태나 선택한 사서함의 상태를 변경하지 않습니다. 실패한 명령\(NO 응답\)은 일반적으로 SELECT 및 EXAMINE 명령을 제외하고 연결 상태나 선택한 사서함 상태를 변경하지 않습니다.

---
### **6.1.  Client Commands - Any State**

CAPABILITY, NOOP, LOGOUT 명령은 모든 상태에서 유효합니다.

---
#### **6.1.1.  CAPABILITY Command**

```text
   Arguments:    none

   Responses:    REQUIRED untagged response:  CAPABILITY

   Result:       OK -  capability completed
                 BAD -  arguments invalid
```

CAPABILITY 명령은 서버가 지원하는 기능\(예: 서버 동작의 확장 및/또는 수정\) 목록을 요청합니다.  서버는 \(태그가 지정된\) OK 응답 전에 나열된 기능 중 하나로 "IMAP4rev2"와 함께 태그가 지정되지 않은 단일 CAPABILITY 응답을 보내야 합니다.

"AUTH="로 시작하는 기능 이름은 서버가 SASL\(Simple Authentication and Security Layer\) \[SASL\]에 정의된 특정 인증 메커니즘을 지원함을 나타냅니다.  이러한 모든 이름은 정의에 따라 이 사양의 일부입니다.

다른 기능 이름은 이 사양의 확장, 개정 또는 개정을 나타냅니다.  추가 정보는 섹션 7.2.2의 CAPABILITY 응답 문서를 참조하세요.  IMAP4rev1 기능이 광고되지 않으면 이 사양에 정의된 기본 IMAP4rev2 세트 이외의 기능은 해당 기능을 호출하기 위한 명시적인 클라이언트 작업 없이는 활성화되지 않습니다.  IMAP4rev1 및 IMAP4rev2 기능이 모두 광고되는 경우 \[RFC3501\]에 지정된 기본 IMAP4rev1 세트 이외의 기능은 해당 기능을 호출하기 위한 명시적인 클라이언트 작업 없이는 활성화되지 않습니다.

클라이언트 및 서버 구현은 일반 텍스트 포트에서 STARTTLS\(섹션 6.2.1\) 및 LOGINDISABLED 기능을 구현해야 합니다. 클라이언트 및 서버 구현은 일반 텍스트 및 암시적 TLS 포트 모두에서 AUTH=PLAIN\(\[PLAIN\]에 설명됨\) 기능도 구현해야 합니다.  중요한 정보는 보안 고려 사항\(섹션 11\)을 참조하세요.

별도로 지정하지 않는 한, IMAP4rev1에 등록된 모든 확장은 IMAP4rev2에도 유효한 확장입니다.

```text
   Example:

     C: abcd CAPABILITY
     S: * CAPABILITY IMAP4rev2 STARTTLS AUTH=GSSAPI
      LOGINDISABLED
     S: abcd OK CAPABILITY completed
     C: efgh STARTTLS
     S: efgh OK STARTTLS completed
     <TLS negotiation, further commands are under TLS layer>
     C: ijkl CAPABILITY
     S: * CAPABILITY IMAP4rev2 AUTH=GSSAPI AUTH=PLAIN
     S: ijkl OK CAPABILITY completed
```

---
#### **6.1.2.  NOOP Command**

```text
   Arguments:    none
```

응답: 이 명령에 대한 구체적인 응답은 없습니다\(그러나 아래 참조\).

```text
   Result:       OK -  noop completed
                 BAD -  command unknown or arguments invalid
```

NOOP 명령은 항상 성공합니다.  아무것도 하지 않습니다.

모든 명령은 태그가 지정되지 않은 데이터로 상태 업데이트를 반환할 수 있으므로 NOOP 명령을 새 메시지에 대한 주기적인 폴링으로 사용할 수 있으며, 대신 비활성 기간 동안 메시지 상태 업데이트\(IDLE 명령, 섹션 6.3.13 참조\)를 사용해야 합니다. 사서함 상태에 대한 실시간 업데이트가 필요한 경우 NOOP입니다.  NOOP 명령을 사용하여 서버의 비활성 자동 로그아웃 타이머를 재설정할 수도 있습니다.

```text
   Example:

     C: a002 NOOP
     S: a002 OK NOOP completed
        . . .
     C: a047 NOOP
     S: * 22 EXPUNGE
     S: * 23 EXISTS
     S: * 14 FETCH (UID 1305 FLAGS (\Seen \Deleted))
     S: a047 OK NOOP completed
```

---
#### **6.1.3.  LOGOUT Command**

```text
   Arguments:    none

   Responses:    REQUIRED untagged response:  BYE

   Result:       OK -  logout completed
                 BAD -  command unknown or arguments invalid
```

LOGOUT 명령은 클라이언트의 연결이 완료되었음을 서버에 알립니다.  서버는 \(태그된\) OK 응답 전에 BYE 태그 없는 응답을 보낸 다음 네트워크 연결을 닫아야 합니다.

```text
   Example:
```

C: A023 LOGOUT S: \* BYE IMAP4rev2 서버 로그아웃 S: A023 OK LOGOUT 완료 \(서버와 클라이언트 연결 종료\)

---
### **6.2.  Client Commands - Not Authenticated State**

인증되지 않은 상태에서는 AUTHENTICATE 또는 LOGIN 명령을 사용하여 인증을 설정하고 인증된 상태로 들어갑니다.  AUTHENTICATE 명령은 다양한 인증 기술, 개인정보 보호 및 무결성 검사를 위한 일반 메커니즘을 제공하는 반면, LOGIN 명령은 기존 사용자 이름과 일반 텍스트 비밀번호 쌍을 사용하며 개인정보 보호 또는 무결성 검사를 설정하는 수단이 없습니다.

STARTTLS 명령은 세션 개인 정보 보호 및 무결성 검사를 설정하는 대체 형식이지만 자체적으로 인증을 설정하거나 인증된 상태로 들어가지는 않습니다.

서버 구현은 인증을 설정하지 않고도 특정 사서함에 대한 액세스를 허용할 수 있습니다.  이는 \[ANONYMOUS\]에 설명된 ANONYMOUS \[SASL\] 인증자를 통해 수행될 수 있습니다.  이전 규칙은 사용자 ID "anonymous"를 사용하는 LOGIN 명령입니다. 이 경우 서버가 모든 비밀번호를 허용하도록 선택할 수 있지만 비밀번호가 필요합니다.  익명 사용자에 대한 제한은 구현에 따라 다릅니다.

한번 인증\(익명 포함\)된 후에는 미인증 상태로 다시 진입할 수 없습니다.

범용 명령\(CAPABILITY, NOOP 및 LOGOUT\) 외에도 STARTTLS, AUTHENTICATE 및 LOGIN 명령은 인증되지 않은 상태에서 유효합니다.  이러한 명령에 대한 중요한 정보는 보안 고려 사항\(섹션 11\)을 참조하세요.

---
#### **6.2.1.  STARTTLS Command**

```text
   Arguments:    none
```

응답: 이 명령에 대한 구체적인 응답이 없습니다.

```text
   Result:       OK -  starttls completed, begin TLS negotiation
                 NO -  TLS negotiation can't be initiated, due to server
                    configuration error
                 BAD -  STARTTLS received after a successful TLS
                    negotiation or arguments invalid
```

STARTTLS 명령은 일반 텍스트 포트에서만 사용할 수 있습니다. 암시적 TLS 포트에서 STARTTLS 명령이 수신되면 서버는 항상 태그가 지정된 BAD 응답으로 응답해야 합니다.

TLS \[TLS-1.3\] 협상은 서버의 태그가 지정된 OK 응답이 끝나는 CRLF 직후에 시작됩니다.  클라이언트가 STARTTLS 명령을 실행하면 서버 응답이 표시되고 TLS 협상이 완료될 때까지 추가 명령을 실행해서는 안 됩니다.  일부 과거 서버 구현에서는 STARTTLS 처리를 잘못 구현했으며 STARTTLS 일반 텍스트 명령 삽입 취약점\[CERT-555316\]이 포함된 것으로 알려져 있습니다.  이 취약점을 방지하기 위해 서버 구현은 STARTTLS 명령을 시작하는 CRLF 이후 동일한 TCP 버퍼에서 데이터가 수신되는 경우 다음 중 하나를 수행해야 합니다.

1. TCP 버퍼의 추가 데이터는 TLS 핸드셰이크의 시작으로 해석됩니다.  \(데이터가 일반 텍스트로 되어 있으면 TLS 핸드셰이크가 실패하게 됩니다.\)

1. TCP 버퍼의 추가 데이터는 버려집니다.

첫 번째 옵션은 TLS 핸드셰이크 데이터를 사용하여 STARTTLS 명령의 시작을 파이프라인하는 클라이언트에 더 친숙합니다.

TLS 협상이 성공한 후에는 TLS 협상 중에 클라이언트 자격 증명이 제공되더라도 서버는 인증되지 않은 상태로 유지됩니다.  이는 EXTERNAL\(\[SASL\]에 정의됨\)과 같은 인증 메커니즘이 TLS 협상에 의해 결정된 클라이언트 ID를 사용하는 것을 배제하지 않습니다.

TLS가 시작되면 클라이언트는 서버 기능에 대해 캐시된 정보를 폐기해야 하며 CAPABILITY 명령을 다시 실행해야 합니다. 이는 STARTTLS 이전에 기능 목록을 변경하는 활성 공격으로부터 보호하는 데 필요합니다.  서버는 다양한 기능을 광고할 수 있으며, 특히 STARTTLS 명령이 성공한 후에는 STARTTLS 기능을 광고해서는 안 됩니다.

```text
   Example:
```

- C: a001 CAPABILITY S: \* CAPABILITY IMAP4rev2 STARTTLS LOGINDISABLED S: a001 OK CAPABILITY Complete C: a002 STARTTLS S: a002 OK 지금 TLS 협상 시작 <TLS 협상, 추가 명령은 TLS 레이어에 있음\> C: a003 CAPABILITY S: \* CAPABILITY IMAP4rev2 AUTH=PLAIN S: a003 OK 기능 완료 C: a004 AUTHENTICATE PLAIN dGVzdAB0ZXN0AHRlc3Q= S: a004 OK 성공\(tls 보호\)

---
#### **6.2.2.  AUTHENTICATE Command**

```text
   Arguments:    SASL authentication mechanism name

                 OPTIONAL initial response
```

응답: 연속 데이터를 요청할 수 있습니다.

```text
   Result:       OK -  authenticate completed, now in authenticated
                    state
                 NO -  authenticate failure: unsupported authentication
                    mechanism, credentials rejected
                 BAD -  command unknown or arguments invalid,
                    authentication exchange canceled
```

AUTHENTICATE 명령은 서버에 대한 \[SASL\] 인증 메커니즘을 나타냅니다.  서버가 요청된 인증 메커니즘을 지원하는 경우 클라이언트를 인증하고 식별하기 위해 인증 프로토콜 교환을 수행합니다.  또한 후속 프로토콜 상호 작용을 위해 선택적 보안 계층을 협상할 수도 있습니다.  요청된 인증 메커니즘이 지원되지 않는 경우 서버는 태그가 지정된 NO 응답을 전송하여 AUTHENTICATE 명령을 거부해야 합니다.

AUTHENTICATE 명령은 \[SASL\]의 섹션 4에 정의된 선택적 "초기 응답" 기능을 지원합니다.  클라이언트는 이를 사용할 필요가 없습니다.  SASL 메커니즘이 "초기 응답"을 지원하지만 클라이언트가 이를 지정하지 않은 경우 서버는 \[SASL\]의 섹션 3에 지정된 대로 이를 처리합니다.

\[SASL\]의 이 프로토콜 프로파일에 지정된 서비스 이름은 "imap"입니다.

인증 프로토콜 교환은 인증 메커니즘과 관련된 일련의 서버 챌린지 및 클라이언트 응답으로 구성됩니다.  서버 챌린지는 "+" 토큰과 그 뒤에 base64로 인코딩된\(\[RFC4648\]의 섹션 4 참조\) 문자열이 포함된 명령 연속 요청 응답으로 구성됩니다.  클라이언트 응답은 base64로 인코딩된 문자열로 구성된 한 줄로 구성됩니다.  클라이언트가 인증 교환을 취소하려는 경우 단일 "\*"로 구성된 줄을 발행합니다.  서버가 그러한 응답을 수신하거나 유효하지 않은 base64 문자열\(예: base64 알파벳 외부 문자 또는 비터미널 "="\)을 수신하는 경우 태그가 지정된 BAD 응답을 전송하여 AUTHENTICATE 명령을 거부해야 합니다.

다른 클라이언트 응답과 마찬가지로 초기 응답도 base64로 인코딩되어야 합니다.  또한 인용된 문자열이나 리터럴 외부로 전송되어야 합니다.  길이가 0인 초기 응답을 보내려면 클라이언트가 단일 패드 문자\("="\)를 보내야 합니다.  이는 응답이 있지만 길이가 0인 문자열임을 나타냅니다.

초기 응답에서 base64 데이터를 디코딩할 때 디코딩 오류는 일반 SASL 클라이언트 응답\(즉, 태그가 지정된 BAD 응답\)에서처럼 처리되어야 합니다.  특히, 서버는 base64 알파벳에서 명시적으로 허용하지 않는 문자는 물론 문자열 끝\(예: "=AAA\) 이외의 위치에 패드 문자\('='\)를 포함하는 base64 문자 시퀀스를 확인해야 합니다. " 및 "AAA=BBB"는 허용되지 않습니다.

클라이언트가 초기 응답을 지원하지 않는 SASL 메커니즘으로 초기 응답을 사용하는 경우 서버는 태그가 지정된 BAD 응답이 있는 명령을 거부해야 합니다.

\[SASL\] 인증 교환을 통해 보안 계층이 협상되면 클라이언트에 대한 인증 교환을 완료하는 CRLF와 서버에 대한 태그된 OK 응답의 CRLF 직후에 적용됩니다.

클라이언트 및 서버 구현은 AUTHENTICATE 명령 자체를 구현해야 하지만 \[PLAIN\]에 설명된 PLAIN 메커니즘 이외의 인증 메커니즘을 구현할 필요는 없습니다.  또한 보안 계층을 지원하기 위해 인증 메커니즘이 필요하지 않습니다.

- 참고: 서버 구현은 STARTTLS 명령이 협상되지 않았거나 TLS가 암시적 TLS 포트에서 협상되었거나 비밀번호 스누핑으로부터 세션을 보호하는 다른 메커니즘을 제외하고 일반 텍스트 비밀번호 메커니즘을 허용하지 않는 구성을 구현해야 합니다. 제공되었습니다.  서버 사이트는 비밀번호 스누핑에 대한 보호 메커니즘 없이 일반 텍스트 비밀번호 메커니즘을 허용하는 구성을 사용해서는 안 됩니다.  클라이언트 및 서버 구현은 \[RFC4752\], SCRAM-SHA-256/SCRAM-SHA-256-PLUS \[SCRAM-SHA-256\]에 설명된 GSSAPI 메커니즘과 같이 일반 텍스트 비밀번호를 사용하지 않는 추가 \[SASL\] 메커니즘을 구현해야 합니다\(SHOULD\). 메커니즘 및/또는 상호 TLS 인증을 위한 EXTERNAL \[SASL\] 메커니즘.  \(SASL 프레임워크는 2FA\(2단계 인증\)를 지원하는 SASL 메커니즘 생성을 허용하지만 이 문서에서 완전히 권장되는 메커니즘은 없습니다.\)

서버와 클라이언트는 여러 인증 메커니즘을 지원할 수 있습니다. 서버는 클라이언트가 사용할 인증 메커니즘을 알 수 있도록 CAPABILITY 명령에 대한 응답으로 지원되는 인증 메커니즘을 나열해야 합니다.

서버는 기능을 자동으로 전송하기 위해 성공적인 AUTHENTICATE 명령의 태그된 OK 응답에 CAPABILITY 응답 코드를 포함할 수 있습니다.  클라이언트가 이러한 자동 기능을 인식하는 경우 별도의 CAPABILITY 명령을 보낼 필요가 없습니다.  AUTHENTICATE 명령의 일부로 태그가 지정된 OK 응답은 암호화/무결성 검사로 보호되지 않기 때문에 보안 계층이 AUTHENTICATE 명령으로 협상되지 않은 경우에만 이 작업을 수행해야 합니다.  \[SASL\]에서는 이 경우 클라이언트가 CAPABILITY 명령을 다시 발행하도록 요구합니다.  서버는 AUTHENTICATE 명령이 성공한 후 다양한 기능을 광고할 수 있습니다.

AUTHENTICATE 명령이 NO 응답으로 실패하면 클라이언트는 다른 AUTHENTICATE 명령을 발행하여 다른 인증 메커니즘을 시도할 수 있습니다.  또한 LOGIN 명령을 사용하여 인증을 시도할 수도 있습니다\(자세한 내용은 섹션 6.2.3 참조\).  즉, 클라이언트는 최후의 수단으로 LOGIN 명령을 사용하여 선호도가 감소하는 순서로 인증 유형을 요청할 수 있습니다.

인증 교환 중에 클라이언트에서 서버로 전달된 권한 부여 ID는 서버에서 클라이언트가 요청하는 권한을 가진 사용자 이름으로 해석됩니다.

```text
   Example:

     S: * OK [CAPABILITY IMAP4rev2 STARTTLS AUTH=GSSAPI]
      Capabilities
     C: A001 AUTHENTICATE GSSAPI
     S: +
     C: YIIB+wYJKoZIhvcSAQICAQBuggHqMIIB5qADAgEFoQMCAQ6iBw
        MFACAAAACjggEmYYIBIjCCAR6gAwIBBaESGxB1Lndhc2hpbmd0
        b24uZWR1oi0wK6ADAgEDoSQwIhsEaW1hcBsac2hpdmFtcy5jYW
        Mud2FzaGluZ3Rvbi5lZHWjgdMwgdCgAwIBAaEDAgEDooHDBIHA
        cS1GSa5b+fXnPZNmXB9SjL8Ollj2SKyb+3S0iXMljen/jNkpJX
        AleKTz6BQPzj8duz8EtoOuNfKgweViyn/9B9bccy1uuAE2HI0y
        C/PHXNNU9ZrBziJ8Lm0tTNc98kUpjXnHZhsMcz5Mx2GR6dGknb
        I0iaGcRerMUsWOuBmKKKRmVMMdR9T3EZdpqsBd7jZCNMWotjhi
        vd5zovQlFqQ2Wjc2+y46vKP/iXxWIuQJuDiisyXF0Y8+5GTpAL
        pHDc1/pIGmMIGjoAMCAQGigZsEgZg2on5mSuxoDHEA1w9bcW9n
        FdFxDKpdrQhVGVRDIzcCMCTzvUboqb5KjY1NJKJsfjRQiBYBdE
        NKfzK+g5DlV8nrw81uOcP8NOQCLR5XkoMHC0Dr/80ziQzbNqhx
        O6652Npft0LQwJvenwDI13YxpwOdMXzkWZN/XrEqOWp6GCgXTB
        vCyLWLlWnbaUkZdEYbKHBPjd8t/1x5Yg==
     S: + YGgGCSqGSIb3EgECAgIAb1kwV6ADAgEFoQMCAQ+iSzBJoAMC
        AQGiQgRAtHTEuOP2BXb9sBYFR4SJlDZxmg39IxmRBOhXRKdDA0
        uHTCOT9Bq3OsUTXUlk0CsFLoa8j+gvGDlgHuqzWHPSQg==
     C:
     S: + YDMGCSqGSIb3EgECAgIBAAD/////6jcyG4GE3KkTzBeBiVHe
        ceP2CWY0SR0fAQAgAAQEBAQ=
     C: YDMGCSqGSIb3EgECAgIBAAD/////3LQBHXTpFfZgrejpLlLImP
        wkhbfa2QteAQAgAG1yYwE=
     S: A001 OK GSSAPI authentication successful
```

다음 예에서는 초기 응답의 사용을 보여줍니다.

```text
   Example:
```

S: \* OK \[CAPABILITY IMAP4rev2 STARTTLS AUTH=GSSAPI LOGINDISABLED\] 서버 준비됨 C: A01 STARTTLS S: A01 OK STARTTLS 완료 <TLS 협상, 추가 명령은 TLS 레이어 아래에 있음\> C: A02 CAPABILITY S: \* CAPABILITY IMAP4rev2 AUTH=GSSAPI AUTH= 일반 S: A02 OK 기능 완료 C: A03 일반 인증 dGVzdAB0ZXN0AHRlc3Q= S: A03 OK 성공\(tls 보호\)

초기 응답은 선택 사항이므로 초기 응답을 사용하지 않는 다음 협상은 여전히 ​​유효하며 서버에서 지원해야 합니다.

... 클라이언트가 서버에 연결하고 TLS 보호 계층을 협상합니다 ... C: C01 CAPABILITY S: \* CAPABILITY IMAP4rev2 AUTH=PLAIN S: C01 OK Completed C: A01 AUTHENTICATE PLAIN S: + C: dGVzdAB0ZXN0AHRlc3Q= S: A01 OK 성공 \(TLS 보호\)

위의 예에서는 서버의 "+" 뒤에 공백이 있습니다.

다음은 TLS 보호 계층 및 빈 초기 응답에서 SASL EXTERNAL 메커니즘\(\[SASL\]에 정의됨\)을 사용하는 인증 예시입니다.

... 클라이언트가 서버에 연결하고 TLS 보호 계층을 협상합니다 ... C: C01 CAPABILITY S: \* CAPABILITY IMAP4rev2 AUTH=PLAIN AUTH=EXTERNAL S: C01 OK 완료됨 C: A01 AUTHENTICATE EXTERNAL = S: A01 OK 성공\(tls 보호 \)

참고: 서버 챌린지 및 클라이언트 응답 내의 줄 바꿈은 편집상의 명확성을 위한 것이며 실제 인증자가 아닙니다.

---
#### **6.2.3.  LOGIN Command**

```text
   Arguments:    user name

                 password
```

응답: 이 명령에 대한 특정 응답이 없습니다.

```text
   Result:       OK -  login completed, now in authenticated state
                 NO -  login failure: user name or password rejected
                 BAD -  command unknown or arguments invalid
```

LOGIN 명령은 서버에 대해 클라이언트를 식별하고 이 사용자를 인증하는 일반 텍스트 비밀번호를 전달합니다.  LOGIN 명령은 최후의 수단\(AUTHENTICATE 명령을 사용하여 한 번 이상 인증을 시도하고 실패한 후\)을 제외하고는 사용되어서는 안 되며, 클라이언트 구현에는 LOGIN 명령의 자동 사용을 비활성화하는 수단이 있는 것이 좋습니다.

서버는 기능을 자동으로 전송하기 위해 성공적인 LOGIN 명령에 대한 태그된 OK 응답에 CAPABILITY 응답 코드를 포함할 수 있습니다.  클라이언트가 이러한 자동 기능을 인식하는 경우 별도의 CAPABILITY 명령을 보낼 필요가 없습니다.

```text
   Example:

     C: a001 LOGIN SMITH SESAME
     S: a001 OK LOGIN completed
```

참고: 안전하지 않은 네트워크\(예: 인터넷\)에서 LOGIN 명령을 사용하면 네트워크 트래픽을 모니터링하는 사람은 누구나 일반 텍스트 암호를 얻을 수 있으므로 보안상 위험할 수 있습니다.  이러한 이유로 클라이언트는 안전하지 않은 네트워크에서 LOGIN을 사용해서는 안 됩니다.

클라이언트가 암시적 TLS 포트\[RFC8314\]에서 IMAP 서비스에 액세스하지 않거나, STARTTLS 명령이 협상되었거나, 비밀번호 스누핑으로부터 세션을 보호하는 다른 메커니즘이 제공되지 않는 한, 서버 구현은 다음을 알리는 구성을 구현해야 합니다. LOGINDISABLED 기능이 있으며 LOGIN 명령을 허용하지 않습니다.  서버 사이트는 비밀번호 스누핑에 대한 보호 메커니즘 없이 LOGIN 명령을 허용하는 구성을 사용해서는 안 됩니다.  클라이언트 구현은 LOGINDISABLED 기능이 광고되는 경우 LOGIN 명령을 보내서는 안 됩니다.

---
### **6.3.  Client Commands - Authenticated State**

인증된 상태에서는 사서함을 원자적 엔터티로 조작하는 명령이 허용됩니다.  이러한 명령 중 SELECT 및 EXAMINE은 액세스할 사서함을 선택하고 선택된 상태로 들어갑니다.

범용 명령\(CAPABILITY, NOOP 및 LOGOUT\) 외에도 인증된 상태에서는 ENABLE, SELECT, EXAMINE, NAMESPACE, CREATE, DELETE, RENAME, SUBSCRIBE, UNSUBSCRIBE, LIST, STATUS, APPEND 및 명령이 유효합니다. 게으른.

---
#### **6.3.1.  ENABLE Command**

```text
   Arguments:    capability names
```

응답: 이 명령에 대한 특정 응답이 없습니다.

```text
   Result:       OK -  Relevant capabilities enabled
                 BAD -  No arguments, or syntax error in an argument
```

여러 IMAP 확장을 사용하면 서버는 특정 상황에서 이러한 확장과 관련된 원치 않는 응답을 반환할 수 있습니다. 그러나 서버는 클라이언트가 그러한 확장을 지원한다는 것을 알 때까지 원치 않는 응답을 보낼 수 없습니다\(항상 전송될 수 있는 태그가 지정되거나 태그가 지정되지 않은 OK/NO/BAD 응답에 포함된 응답 코드\(섹션 7.1 참조\) 제외\). 확장 응답 데이터를 올바르게 구문 분석하고 처리할 수 있어야 합니다.

ENABLE 명령은 특정 확장을 지원한다는 클라이언트의 명시적인 표시를 제공합니다.  이는 클라이언트가 지원하는 확장이 포함된 간단한 상수 문자열을 보낼 수 있도록 설계되었으며, 서버는 둘 다 지원하는 공유 하위 집합을 활성화합니다.

ENABLE 명령은 기능 이름 목록을 가져와 서버에 명명된 확장을 활성화하도록 요청합니다.  ENABLE을 사용하여 활성화되면 각 확장은 IMAP 연결이 닫힐 때까지 활성 상태로 유지됩니다. 각 인수에 대해 서버는 다음을 수행합니다.

\* 인수가 서버에 알려진 확장이 아닌 경우 서버는 인수를 무시해야 합니다.

\* 인수가 서버에 알려진 확장이고 ENABLE을 사용하여 활성화하는 것이 특별히 허용되지 않는 경우 서버는 인수를 무시해야 합니다.  \(확장에 대해 안다고 해서 반드시 해당 확장을 지원한다는 의미는 아닙니다.\)

\* 인수가 서버에서 지원하고 활성화해야 하는 확장인 경우 서버는 연결 기간 동안 확장을 활성화해야 합니다.  확장 기능이 활성화되면 비활성화할 수 있는 방법이 없습니다.

ENABLE 명령이 성공하면 서버는 위에 지정된 대로 활성화된 모든 확장을 포함하는 태그가 지정되지 않은 ENABLED 응답\(섹션 7.2.1\)을 보내야 합니다.  확장이 활성화되지 않은 경우에도 ENABLED 응답이 전송됩니다.

클라이언트는 서버에서 활성화해야 하는 확장만 포함해야 합니다.  예를 들어 클라이언트는 IMAP4rev1과 IMAP4rev2가 모두 CAPABILITY 응답에 광고될 때 IMAP4rev2 관련 동작을 활성화할 수 있습니다.  향후 RFC가 이 목록에 추가될 수 있습니다.

ENABLE 명령은 사서함을 선택하기 전의 인증된 상태에서만 유효합니다.  클라이언트는 메일함을 선택/검사한 후에는 ENABLE을 발행해서는 안 됩니다. 그러나 서버 구현에서는 연결된 사서함이 선택되지 않았는지 또는 연결 기간 동안 이전에 선택되었는지 확인할 필요가 없습니다.

ENABLE 명령은 한 세션에서 여러 번 실행될 수 있습니다.  그것은 부가적이다. 즉, "ENABLE a b" 뒤에 "ENABLE c"가 오는 것은 단일 명령 "ENABLE a b c"와 동일합니다.  여러 개의 ENABLE 명령이 실행되면 각 해당 ENABLED 응답에는 해당 ENABLE 명령에 의해 활성화된 확장만 포함되어야 합니다. 즉, 위 예의 경우 "ENABLE c"에 대한 ENABLED 응답에는 "a" 또는 "b"가 포함되어서는 안 됩니다.

ENABLE 파이프라인에는 제한이 없습니다.  예를 들어, ENABLE을 전송한 후 즉시 SELECT를 전송하거나 LOGIN을 전송한 후 바로 ENABLE을 전송하는 것이 가능합니다.

서버는 ENABLE 실행의 결과로 CAPABILITY 목록을 변경해서는 안 됩니다. 즉, ENABLE 명령 바로 뒤에 실행된 CAPABILITY 명령은 ENABLE 명령 전에 실행된 CAPABILITY 명령과 동일한 기능을 나열해야 합니다.  이는 다음 예에서 설명됩니다.  아래의 "X-GOOD-IDEA"는 활성화할 수 있는 가상의 확장 기능입니다.

```text
     C: t1 CAPABILITY
     S: * CAPABILITY IMAP4rev2 ID LITERAL+ X-GOOD-IDEA
     S: t1 OK foo
     C: t2 ENABLE CONDSTORE X-GOOD-IDEA
     S: * ENABLED X-GOOD-IDEA
     S: t2 OK foo
     C: t3 CAPABILITY
     S: * CAPABILITY IMAP4rev2 ID LITERAL+ X-GOOD-IDEA
     S: t3 OK foo again
```

다음 예에서 클라이언트는 조건부 저장소\(CONDSTORE\) 확장 \[RFC7162\]을 활성화합니다.

```text
     C: a1 ENABLE CONDSTORE
     S: * ENABLED CONDSTORE
     S: a1 OK Conditional Store enabled

6.3.1.1.  Note to Designers of Extensions That May Use the ENABLE
          Command
```

IMAP 확장 설계자는 좋은 대체 설계가 없는 한 ENABLE이 필요한 확장을 생성하지 않는 것이 좋습니다. 특히, 배포된 서버 응답에 대해 잠재적으로 호환되지 않는 동작 변경을 유발하는\(따라서 ENABLE의 이점을 누리는\) 확장은 그렇지 않은 확장보다 복잡성 비용이 더 높습니다.

---
#### **6.3.2.  SELECT Command**

```text
   Arguments:    mailbox name

   Responses:    REQUIRED untagged responses:  FLAGS, EXISTS, LIST
                 REQUIRED OK untagged responses:  PERMANENTFLAGS,
                    UIDNEXT, UIDVALIDITY

   Result:       OK -  select completed, now in selected state
                 NO -  select failure, now in authenticated state: no
                    such mailbox, can't access mailbox
                 BAD -  command unknown or arguments invalid
```

SELECT 명령은 사서함의 메시지에 액세스할 수 있도록 사서함을 선택합니다.  클라이언트에 OK를 반환하기 전에 서버는 태그가 지정되지 않은 다음 데이터를 클라이언트에 보내야 합니다.  \(개별 응답의 순서는 중요하지 않습니다.\) \[RFC2060\]에 지정된 IMAP4rev1 버전과 같은 이 프로토콜의 이전 버전에는 태그가 지정되지 않은 FLAGS 및 EXISTS 응답과 UIDVALIDITY 응답 코드만 필요했습니다.  이러한 이전 IMAP 버전과의 호환성을 유지해야 하는 클라이언트 구현은 개별 항목에서 설명한 대로 누락된 데이터에 대한 기본 동작을 구현해야 합니다.

FLAGS - 사서함에 정의된 플래그입니다.  자세한 내용은 섹션 7.3.5의 FLAGS 응답 설명을 참조하세요.

<n\> 존재 - 사서함에 있는 메시지 수입니다.  자세한 내용은 섹션 7.4.1의 EXISTS 응답 설명을 참조하세요.

LIST - 서버는 사서함 이름과 함께 LIST 응답을 반환해야 합니다.  사서함 속성 목록은 정확해야 합니다.  서버가 비정규화된 UTF-8 사서함 이름\(섹션 5.1 참조\)을 허용하고 제공된 사서함 이름이 정규화된 버전과 다른 경우 서버는 OLDNAME 확장 데이터 항목과 함께 LIST를 반환해야 합니다.  자세한 내용은 섹션 6.3.9.7을 참조하세요.

OK \[PERMANENTFLAGS \(<플래그 목록\>\)\] - 클라이언트가 영구적으로 변경할 수 있는 메시지 플래그 목록입니다. 이것이 누락된 경우 클라이언트는 모든 플래그가 영구적으로 변경될 수 있다고 가정해야 합니다.

OK \[UIDNEXT <n\>\] - 다음 고유 식별자 값입니다.  자세한 내용은 섹션 2.3.1.1을 참조하십시오.

확인 \[UIDVALIDITY <n\>\] - 고유 식별자 유효성 값입니다.  자세한 내용은 섹션 2.3.1.1을 참조하십시오.

연결에서는 한 번에 하나의 사서함만 선택할 수 있습니다. 여러 사서함에 동시에 액세스하려면 여러 연결이 필요합니다.  SELECT 명령은 새 선택을 시도하기 전에 현재 선택된 사서함을 자동으로 선택 취소합니다. 따라서 사서함을 선택하고 실패한 SELECT 명령을 시도하면 사서함이 선택되지 않습니다.  선택한 사서함을 선택 취소할 때 서버는 현재 선택된 사서함이 닫혀 있을 때 "\[CLOSED\]" 응답 코드와 함께 태그가 지정되지 않은 OK 응답을 반환해야 합니다\(섹션 7.1 참조\).

클라이언트가 사서함을 수정하도록 허용된 경우 서버는 태그가 지정된 OK 응답의 텍스트 앞에 "\[READ-WRITE\]" 응답 코드를 붙여야 합니다.

클라이언트가 메일함을 수정하는 것은 허용되지 않지만 읽기 액세스는 허용된 경우 메일함은 읽기 전용으로 선택되고 서버는 태그가 지정된 OK 응답의 텍스트 앞에 "\[READ-ONLY\]" 응답 코드를 SELECT 앞에 붙여야 합니다. .  SELECT를 통한 읽기 전용 액세스는 특정 읽기 전용 사서함이 사용자별\(전역이 아닌\) 영구 상태 변경을 허용할 수 있다는 점에서 EXAMINE 명령과 다릅니다.  서버 기반 .newsrc 파일에 표시된 Netnews 메시지는 읽기 전용 메일함으로 수정될 수 있는 사용자별 영구 상태의 예입니다.

```text
   Example:

     C: A142 SELECT INBOX
     S: * 172 EXISTS
     S: * OK [UIDVALIDITY 3857529045] UIDs valid
     S: * OK [UIDNEXT 4392] Predicted next UID
     S: * FLAGS (\Answered \Flagged \Deleted \Seen \Draft)
     S: * OK [PERMANENTFLAGS (\Deleted \Seen \*)] Limited
     S: * LIST () "/" INBOX
     S: A142 OK [READ-WRITE] SELECT completed

   Example:

     C: A142 SELECT INBOX
     S: * 172 EXISTS
     S: * OK [UIDVALIDITY 3857529045] UIDs valid
     S: * OK [UIDNEXT 4392] Predicted next UID
     S: * FLAGS (\Answered \Flagged \Deleted \Seen \Draft)
     S: * OK [PERMANENTFLAGS (\Deleted \Seen \*)] Limited
     S: A142 OK [READ-WRITE] SELECT completed
     [...some time later...]
     C: A143 SELECT Drafts
     S: * OK [CLOSED] Previous mailbox is now closed
     S: * 5 EXISTS
     S: * OK [UIDVALIDITY 9877410381] UIDs valid
     S: * OK [UIDNEXT 102] Predicted next UID
     S: * LIST () "/" Drafts
     S: * FLAGS (\Answered \Flagged \Deleted \Seen \Draft)
     S: * OK [PERMANENTFLAGS (\Deleted \Seen \Answered
         \Flagged \Draft \*)] System flags and keywords allowed
     S: A143 OK [READ-WRITE] SELECT completed
```

IMAP4rev1 호환 서버는 IMAP4rev2에서 더 이상 사용되지 않는 태그가 없는 RECENT 응답\(예: "\* 0 RECENT"\)을 보낼 수도 있습니다. 순수 IMAP4rev2 클라이언트는 태그가 지정되지 않은 RECENT 응답을 무시하는 것이 좋습니다.

---
#### **6.3.3.  EXAMINE Command**

```text
   Arguments:    mailbox name

   Responses:    REQUIRED untagged responses:  FLAGS, EXISTS, LIST
                 REQUIRED OK untagged responses:  PERMANENTFLAGS,
                    UIDNEXT, UIDVALIDITY

   Result:       OK -  examine completed, now in selected state
                 NO -  examine failure, now in authenticated state: no
                    such mailbox, can't access mailbox
                 BAD -  command unknown or arguments invalid
```

EXAMINE 명령은 SELECT와 동일하며 동일한 출력을 반환합니다. 그러나 선택한 사서함은 읽기 전용으로 식별됩니다.  사용자별 상태를 포함하여 사서함의 영구 상태에 대한 변경은 허용되지 않습니다.

EXAMINE 명령에 대한 태그가 지정된 OK 응답의 텍스트는 "\[READ-ONLY\]" 응답 코드로 시작해야 합니다.

```text
   Example:

      C: A932 EXAMINE blurdybloop
      S: * 17 EXISTS
      S: * OK [UIDVALIDITY 3857529045] UIDs valid
      S: * OK [UIDNEXT 4392] Predicted next UID
      S: * LIST () "/" blurdybloop
      S: * FLAGS (\Answered \Flagged \Deleted \Seen \Draft)
      S: * OK [PERMANENTFLAGS ()] No permanent flags permitted
      S: A932 OK [READ-ONLY] EXAMINE completed
```

---
#### **6.3.4.  CREATE Command**

```text
   Arguments:    mailbox name

   Responses:    OPTIONAL untagged response:  LIST

   Result:       OK -  create completed
                 NO -  create failure: can't create mailbox with that
                    name
                 BAD -  command unknown or arguments invalid
```

CREATE 명령은 주어진 이름으로 사서함을 만듭니다.  해당 이름의 새 사서함이 생성된 경우에만 OK 응답이 반환됩니다.  기존 메일함을 참조하는 이름으로 INBOX 또는 메일함을 생성하려고 하면 오류가 발생합니다.  생성 중 오류가 발생하면 태그가 지정된 NO 응답이 반환됩니다.  클라이언트가 유효한 Net-Unicode 이름이 아닌 UTF-8 사서함 이름을 만들려고 시도하는 경우 서버는 사서함을 만들기 전에 생성을 거부하거나 이름을 Net-Unicode로 변환해야 합니다.  서버가 이름을 변환\(정규화\)하기로 결정한 경우, OLDNAME 확장 데이터 항목이 포함된 태그 없는 LIST를 반환해야 하며, OLDNAME 값은 제공된 메일박스 이름이고 name 매개변수는 정규화된 메일박스 이름입니다.  \(자세한 내용은 섹션 6.3.9.7을 참조하세요.\)

하나의 IMAP 세션에서 생성된 메일박스는 원치 않는 LIST 응답을 사용하여 다른 IMAP 세션에 알려질 수 있습니다.  서버가 사서함이 생성될 때 자동으로 사서함을 구독하는 경우 영향을 받는 각 구독 사서함 이름에 대한 원치 않는 LIST 응답에는 \Subscribed 특성이 포함되어야 합니다.

사서함 이름에 서버의 계층 구분 문자\(LIST 명령에 의해 서버에서 반환됨\)가 접미사로 붙은 경우 이는 클라이언트가 계층에서 이 이름 아래에 사서함 이름을 만들려는 선언입니다.  이 선언이 필요하지 않은 서버 구현은 선언을 무시해야 합니다\(MUST\).  어떤 경우든 생성된 이름에는 후행 계층 구분 기호가 없습니다.

서버의 계층 구분 문자가 이름의 다른 곳에 나타나면 서버는 CREATE 명령을 성공적으로 완료하는 데 필요한 상위 계층 이름을 생성해야 합니다. 즉, "/"가 계층 구분 문자인 서버에서 "foo/bar/zap"을 생성하려는 시도는 foo/ 및 foo/bar/가 아직 존재하지 않는 경우 생성해야 합니다.

삭제된 사서함과 동일한 이름으로 새 사서함이 생성된 경우 새 사서함의 고유 식별자 유효성 값이 다른 경우를 제외하고 고유 식별자는 사서함의 이전 구현에 사용된 고유 식별자보다 커야 합니다. 자세한 내용은 섹션 6.4.9의 UID 명령 설명을 참조하세요.

```text
   Example:

     C: A003 CREATE owatagusiam/
     S: A003 OK CREATE completed
     C: A004 CREATE owatagusiam/blurdybloop
     S: A004 OK CREATE completed
     C: A005 CREATE NonNormalized
     S: * LIST () "/" "Normalized" ("OLDNAME" ("NonNormalized"))
     S: A005 OK CREATE completed
```

\(마지막 예에서 "NonNormalized"는 NFC가 아닌 정규화된 유니코드 사서함 이름이고 "Normalized"는 NFC 정규화된 버전이라고 가정합니다.\)

- |  참고: 이 예의 해석은 "/" |  LIST에서 계층 구분 기호로 반환되었습니다.  "/"가 |  계층 구분 기호, |라는 이름의 새로운 계층 계층  "blurdybloop"이라는 멤버가 포함된 "owatagusiam"이 생성됩니다. |  그렇지 않으면 동일한 계층 구조 수준에 있는 두 개의 편지함은 |  만들어진.

---
#### **6.3.5.  DELETE Command**

```text
   Arguments:    mailbox name

   Responses:    OPTIONAL untagged response:  LIST

   Result:       OK -  delete completed
                 NO -  delete failure: can't delete mailbox with that
                    name
                 BAD -  command unknown or arguments invalid
```

DELETE 명령은 해당 이름의 사서함을 영구적으로 제거합니다.  사서함이 삭제된 경우에만 태그가 지정된 OK 응답이 반환됩니다.  INBOX나 존재하지 않는 편지함 이름을 삭제하려고 하면 오류가 발생합니다.

DELETE 명령은 하위 계층 이름을 제거해서는 안 됩니다.  예를 들어, 메일함 "foo"에 하위 "foo.bar"가 있는 경우\("."가 계층 구분 문자라고 가정\) "foo"를 제거해도 "foo.bar"는 제거되어서는 안 됩니다.  하위 계층 이름이 있고 \Noselect 사서함 이름 속성도 있는 이름을 삭제하려고 시도하는 것은 오류입니다\(자세한 내용은 LIST 응답 설명\(섹션 7.3.1\) 참조\).

하위 계층 이름이 있고 \Noselect 사서함 이름 특성이 없는 이름을 삭제할 수 있습니다.  서버 구현이 하위 계층 이름이 존재하는 동안 이름 삭제를 허용하지 않는 경우 태그가 지정된 NO 응답을 반환하여 DELETE 명령을 허용하지 않아야 합니다.  NO 응답에는 HASCHILDREN 응답 코드가 포함되어야 합니다.  또는 서버는 DELETE 명령을 허용할 수 있지만 해당 이름에 대해 \Noselect 사서함 이름 속성을 설정합니다.

서버가 OK 응답을 반환하면 해당 사서함의 모든 메시지는 DELETE 명령에 의해 제거됩니다.

삭제된 사서함의 가장 많이 사용된 고유 식별자 값은 새 구현이 다른 고유 식별자 유효성 값을 가지지 않는 한 동일한 이름으로 생성된 새 사서함이 이전 구현의 식별자를 재사용하지 않도록 보존되어야 합니다. 자세한 내용은 섹션 6.4.9의 UID 명령 설명을 참조하세요.

서버가 사서함 이름을 변환\(정규화\)하기로 결정한 경우 "\NonExistent" 속성 및 OLDNAME 확장 데이터 항목이 포함된 태그 없는 LIST를 반환해야 하며, OLDNAME 값은 제공된 사서함 이름이고 name 매개변수는 정규화된 사서함 이름입니다. .  \(자세한 내용은 섹션 6.3.9.7을 참조하세요.\)

하나의 IMAP 세션에서 삭제된 메일박스는 "\NonExistent" 속성을 포함하는 원치 않는 LIST 응답을 사용하여 다른 IMAP 세션에 알려질 수 있습니다.

```text
   Example:

     C: A682 LIST "" *
     S: * LIST () "/" blurdybloop
     S: * LIST (\Noselect) "/" foo
     S: * LIST () "/" foo/bar
     S: A682 OK LIST completed
     C: A683 DELETE blurdybloop
     S: A683 OK DELETE completed
     C: A684 DELETE foo
     S: A684 NO Name "foo" has inferior hierarchical names
     C: A685 DELETE foo/bar
     S: A685 OK DELETE Completed
     C: A686 LIST "" *
     S: * LIST (\Noselect) "/" foo
     S: A686 OK LIST completed
     C: A687 DELETE foo
     S: A687 OK DELETE Completed

   Example:

     C: A82 LIST "" *
     S: * LIST () "." blurdybloop
     S: * LIST () "." foo
     S: * LIST () "." foo.bar
     S: A82 OK LIST completed
     C: A83 DELETE blurdybloop
     S: A83 OK DELETE completed
     C: A84 DELETE foo
     S: A84 OK DELETE Completed
     C: A85 LIST "" *
     S: * LIST () "." foo.bar
     S: A85 OK LIST completed
     C: A86 LIST "" %
     S: * LIST (\Noselect) "." foo
     S: A86 OK LIST completed
```

---
#### **6.3.6.  RENAME Command**

```text
   Arguments:    existing mailbox name

                 new mailbox name

   Responses:    OPTIONAL untagged response:  LIST

   Result:       OK -  rename completed
                 NO -  rename failure: can't rename mailbox with that
                    name, can't rename to mailbox with that name
                 BAD -  command unknown or arguments invalid
```

RENAME 명령은 메일함의 이름을 변경합니다.  태그가 지정된 OK 응답은 사서함 이름이 변경된 경우에만 반환됩니다.  존재하지 않는 편지함 이름에서 또는 이미 존재하는 편지함 이름으로 이름을 바꾸려고 하면 오류입니다.  이름을 바꾸는 동안 오류가 발생하면 태그된 NO 응답이 반환됩니다.

이름에 하위 계층 이름이 있는 경우 하위 계층 이름도 이름을 바꿔야 합니다.  예를 들어, "foo"의 이름을 "zap"으로 바꾸면 "foo/bar"\("/"가 계층 구분 문자라고 가정\)의 이름이 "zap/bar"로 변경됩니다.

서버의 계층 구분 문자가 새 사서함 이름에 나타나면 서버는 RENAME 명령을 성공적으로 완료하는 데 필요한 상위 계층 이름을 만들어야 합니다.  즉, "/"가 해당 네임스페이스의 계층 구분 문자인 서버에서 "foo/bar/zap"의 이름을 "baz/rag/zowie"로 바꾸려는 시도는 "baz/" 및 "baz/"를 생성해야 합니다. rag/"가 아직 존재하지 않는 경우.

이전 사서함 이름의 가장 많이 사용된 고유 식별자 값은 새 구현이 다른 고유 식별자 유효성 값을 가지지 않는 한 동일한 이름으로 생성된 새 사서함이 이전 구현의 식별자를 재사용하지 않도록 보존되어야 합니다. 자세한 내용은 섹션 6.4.9의 UID 명령 설명을 참조하세요.

INBOX 이름 변경은 허용되며 태그된 BAD 응답이 발생하지 않으며 특별한 동작이 있습니다. 즉, INBOX의 모든 메시지를 지정된 이름의 새 메일함으로 이동하고 INBOX를 비워 둡니다.  서버 구현이 INBOX의 하위 계층 이름을 지원하는 경우 INBOX의 이름 변경으로 인해 영향을 받지 않습니다.  \(일부 서버에서는 태그가 지정된 NO 응답을 반환하여 INBOX 이름 변경을 허용하지 않으므로 클라이언트는 이러한 RENAME 명령의 실패를 처리할 수 있어야 합니다.\)

서버가 유효한 Net-Unicode 이름이 아닌 이름을 가진 사서함 생성을 허용하는 경우 서버는 기존 사서함 이름 매개 변수와 새 사서함 이름 매개 변수를 모두 정규화합니다.  이러한 2개 매개변수 중 하나의 정규화된 버전이 해당 제공된 버전과 다른 경우 서버는 OLDNAME 확장 데이터 항목과 함께 태그가 지정되지 않은 LIST 응답을 반환해야 하며, OLDNAME 값은 제공된 기존 메일박스 이름이고 name 매개변수는 정규화된 새 항목입니다. 사서함 이름\(섹션 6.3.9.7 참조\)  이를 통해 클라이언트는 제공된 이름을 정규화된 이름과 연관시킬 수 있습니다.

하나의 IMAP 세션에서 이름이 변경된 사서함은 OLDNAME 확장 데이터 항목이 포함된 원치 않는 LIST 응답을 사용하여 다른 IMAP 세션에 알릴 수 있습니다.

위의 두 경우 모두, 이름이 바뀔 때 서버가 자동으로 사서함을 구독하는 경우 영향을 받는 각 구독 사서함 이름에 대한 원치 않는 LIST 응답에는 \Subscribed 특성이 포함되어야 합니다.  하위 사서함에는 원치 않는 LIST 응답을 보낼 필요가 없습니다.  INBOX 이름 변경에 성공하면 새로운 INBOX가 생성된 것으로 간주됩니다.  이 경우 INBOX에 대해 원치 않는 LIST 응답을 보낼 필요가 없습니다.

```text
   Examples:

     C: A682 LIST "" *
     S: * LIST () "/" blurdybloop
     S: * LIST (\Noselect) "/" foo
     S: * LIST () "/" foo/bar
     S: A682 OK LIST completed
     C: A683 RENAME blurdybloop sarasoop
     S: A683 OK RENAME completed
     C: A684 RENAME foo zowie
     S: A684 OK RENAME Completed
     C: A685 LIST "" *
     S: * LIST () "/" sarasoop
     S: * LIST (\Noselect) "/" zowie
     S: * LIST () "/" zowie/bar
     S: A685 OK LIST completed

     C: Z432 LIST "" *
     S: * LIST () "." INBOX
     S: * LIST () "." INBOX.bar
     S: Z432 OK LIST completed
     C: Z433 RENAME INBOX old-mail
     S: Z433 OK RENAME completed
     C: Z434 LIST "" *
     S: * LIST () "." INBOX
     S: * LIST () "." INBOX.bar
     S: * LIST () "." old-mail
     S: Z434 OK LIST completed
```

사서함 이름을 바꿔도 원래 ​​이름에 대한 구독 정보는 업데이트되지 않습니다.  구독 정보를 동기화 상태로 유지하려면 다음 명령을 순서대로 사용할 수 있습니다.

```text
     C: 1001 RENAME X Y
     C: 1002 SUBSCRIBE Y
     C: 1003 UNSUBSCRIBE X
```

위의 명령 순서는 사서함 X의 하위 사서함에 대한 구독 업데이트를 설명하지 않습니다.

---
#### **6.3.7.  SUBSCRIBE Command**

```text
   Arguments:    mailbox
```

응답: 이 명령에 대한 특정 응답이 없습니다.

```text
   Result:       OK -  subscribe completed
                 NO -  subscribe failure: can't subscribe to that name
                 BAD -  command unknown or arguments invalid
```

SUBSCRIBE 명령은 LIST\(SUBSCRIBED\) 명령에 의해 반환된 서버의 "활성" 또는 "가입" 사서함 집합에 지정된 사서함 이름을 추가합니다.  이 명령은 구독이 성공했거나 사서함이 이미 구독된 경우 태그가 지정된 OK 응답을 반환합니다.

서버는 SUBSCRIBE에 대한 메일함 인수의 유효성을 검사하여 그것이 존재하는지 확인할 수 있습니다.  그러나 해당 이름의 사서함이 더 이상 존재하지 않는 경우에도 구독 목록에서 기존 사서함 이름을 일방적으로 제거해서는 안 됩니다.

- |  참고: 이 요구 사항은 서버 사이트가 |  내용이 만료된 후 잘 알려진 이름\(예: "system-alerts"\)을 가진 메일함을 | 정기적으로 제거합니다.  새로운 콘텐츠가 적절할 때 다시 제작하는 것입니다.

```text
   Example:

     C: A002 SUBSCRIBE #news.comp.mail.mime
     S: A002 OK SUBSCRIBE completed
```

---
#### **6.3.8.  UNSUBSCRIBE Command**

```text
   Arguments:    mailbox name
```

응답: 이 명령에 대한 특정 응답이 없습니다.

```text
   Result:       OK -  unsubscribe completed
                 NO -  unsubscribe failure: can't unsubscribe that name
                 BAD -  command unknown or arguments invalid
```

UNSUBSCRIBE 명령은 LIST\(SUBSCRIBED\) 명령에 의해 반환된 서버의 "활성" 또는 "가입" 사서함 집합에서 지정된 사서함 이름을 제거합니다.  이 명령은 구독 취소에 성공하거나 사서함이 구독되지 않은 경우 태그가 지정된 OK 응답을 반환합니다.

```text
   Example:

     C: A002 UNSUBSCRIBE #news.comp.mail.mime
     S: A002 OK UNSUBSCRIBE completed
```

---
#### **6.3.9.  LIST Command**

```text
   Arguments (basic):
                 reference name
                 mailbox name with possible wildcards

   Arguments (extended):
                 selection options (OPTIONAL)
                 reference name
                 mailbox patterns
                 return options (OPTIONAL)

   Responses:    untagged responses: LIST

   Result:       OK -  list completed
                 NO -  list failure: can't list that reference or
                    mailbox name
                 BAD -  command unknown or arguments invalid
```

LIST 명령은 클라이언트가 사용할 수 있는 모든 사서함 이름의 전체 집합에서 사서함 이름의 하위 집합을 반환합니다.  이름 속성, 계층 구분 기호, 이름 및 가능한 확장 정보를 포함하는 0개 이상의 태그가 지정되지 않은 LIST 응답이 반환됩니다. 자세한 내용은 LIST 응답 설명\(7.3.1절\)을 참조하세요.

LIST 명령은 과도한 지연 없이 신속하게 데이터를 반환해야 합니다. 예를 들어, \Marked 또는 \Unmarked 상태를 계산하거나 다른 처리를 수행하는 데 과도한 문제를 일으키면 안 됩니다. 각 이름을 처리하는 데 1초가 필요하다면 1,200개의 이름 목록을 처리하는 데 20분이 걸립니다!

원래 \[RFC5258\]에 도입된 확장 LIST 명령은 원래 IMAP LIST 명령 이상의 기능을 제공합니다. 다음 조건 중 하나 이상이 참인 경우 확장 구문이 사용됩니다.

1. 명령 이름 뒤의 첫 번째 단어는 괄호로 시작합니다\("LIST 선택 옵션"\).

1. 명령 이름 뒤의 두 번째 단어는 괄호로 시작합니다. 그리고

1. LIST 명령에는 2개 이상의 매개변수가 있습니다\("LIST 반환 옵션"\).

빈\("" 문자열\) 참조 이름 인수는 사서함 이름이 SELECT에 의해 해석됨을 나타냅니다.  반환된 사서함 이름은 제공된 사서함 이름 패턴과 일치해야 합니다.  비어 있지 않은 참조 이름 인수는 사서함 이름 또는 사서함 계층 구조 수준이며 사서함 이름이 해석되는 컨텍스트를 나타냅니다.  클라이언트는 빈 참조 인수를 사용해야 합니다.

기본 구문에서만 빈\("" 문자열\) 사서함 이름 인수는 참조에 제공된 이름의 루트 이름과 계층 구분 기호를 반환하기 위한 특수 요청입니다.  참조가 루트가 아니거나 빈 문자열인 경우 루트로 반환된 값은 빈 문자열일 수 있습니다.  모든 경우에 계층 구분 기호\(또는 계층이 없는 경우 NIL\)가 반환됩니다.  이를 통해 클라이언트는 해당 이름의 사서함이 현재 존재하지 않는 경우에도 계층 구분 기호를 얻을 수 있습니다\(또는 사서함 이름이 단순하다는 것을 알 수 있습니다\).

확장 구문에서는 빈 문자열인 모든 사서함 이름 인수가 무시됩니다.  확장 구문을 사용할 때 빈 사서함 이름에는 특별한 의미가 없습니다.

참조 및 사서함 이름 인수는 왼쪽에서 오른쪽으로의 명확한 계층 구조를 나타내는 정식 형식으로 해석됩니다.  반환된 사서함 이름은 "정식 LIST 패턴"이라고 하는 해석된 형식입니다. 즉, 참조 및 사서함 이름 인수로부터 서버가 내부적으로 구성한 정식 패턴입니다.

- 참고: 참조 인수의 해석은 구현에 따라 정의됩니다.  이는 서버 구현에 "현재 작업 디렉터리" 개념과 현재 작업 디렉터리를 재정의하는 "돌출 문자"라는 개념이 있는지 여부에 따라 달라집니다.

- 예를 들어 UNIX 또는 NT 파일 시스템을 내보내는 서버에서 참조 인수에는 현재 작업 디렉터리가 포함되고, 사서함 이름 인수에는 현재 작업 디렉터리에서 해석된 이름이 포함됩니다.

- 서버 구현에 문자 분리 개념이 없는 경우 표준 형식은 일반적으로 사서함 이름이 추가된 참조 이름입니다.  서버가 네임스페이스 규칙\(섹션 5.1.2.1\)을 구현하는 경우 "#"은 구분 문자이므로 그렇게 처리되어야 합니다.

- 참조 인수가 사서함 계층 구조 수준이 아니거나\(즉, \NoInferiors 이름\) 참조 인수가 계층 구조 구분 기호로 끝나지 않는 경우 구현에 따라 해석됩니다.  예를 들어, "foo/bar" 참조와 "rag/baz"라는 사서함 이름은 "foo/bar/rag/baz", "foo/barrag/baz" 또는 "foo/rag/baz"로 해석될 수 있습니다. .  클라이언트는 사용자의 명시적인 요청이 있는 경우를 제외하고는 그러한 참조 인수를 사용해서는 안 됩니다.  계층적 브라우저는 참조가 메일함 계층 구조의 수준이고 계층 구분 기호로 끝나지 않는 한 참조의 서버 해석에 대해 어떤 가정도 해서는 안 됩니다.

해석된 형식에 포함된 참조 인수의 모든 부분은 해석된 형식의 접두사여야 합니다.  또한 참조 이름 인수와 동일한 형식이어야 합니다.  이 규칙을 사용하면 클라이언트는 반환된 사서함 이름이 참조 인수의 컨텍스트에 있는지 또는 사서함 인수에 대한 내용이 참조 인수를 재정의하는지 확인할 수 있습니다.  이 규칙이 없으면 클라이언트는 명명 컨텍스트를 재정의하는 "돌출" 문자를 포함하여 서버의 명명 의미 체계에 대한 지식을 가지고 있어야 합니다.

다음은 UNIX 기반 서버에서 참조 및 사서함 이름을 해석하는 방법에 대한 몇 가지 예입니다.

```text
            +==============+==============+===================+
            | Reference    | Mailbox Name | Interpretation    |
            +==============+==============+===================+
            | ~smith/Mail/ | foo.*        | ~smith/Mail/foo.* |
            +--------------+--------------+-------------------+
            | archive/     | %            | archive/%         |
            +--------------+--------------+-------------------+
            | #news.       | comp.mail.*  | #news.comp.mail.* |
            +--------------+--------------+-------------------+
            | ~smith/Mail/ | /usr/doc/foo | /usr/doc/foo      |
            +--------------+--------------+-------------------+
            | archive/     | ~fred/Mail/* | ~fred/Mail/*      |
            +--------------+--------------+-------------------+

                                  Table 1
```

위의 처음 세 가지 예는 참조 주장의 맥락에서 해석을 보여줍니다.  "\~smith/Mail"은 "/u2/users/smith/Mail"과 같은 것으로 변환되어서는 안 됩니다. 그렇지 않으면 클라이언트가 해당 해석이 참조의 맥락에 있는지 판단하는 것이 불가능합니다.

문자 "\*"는 와일드카드이며 이 위치에 있는 0개 이상의 문자와 일치합니다.  "%" 문자는 "\*"와 유사하지만 계층 구분 기호와 일치하지 않습니다.  "%" 와일드카드가 사서함 이름 인수의 마지막 문자인 경우 일치하는 계층 구조 수준도 반환됩니다.  이러한 계층 구조 수준이 선택 가능한 사서함이 아닌 경우 \Noselect 사서함 이름 속성과 함께 반환됩니다\(자세한 내용은 LIST 응답 설명\(7.3.1절\) 참조\).

어떤 이유로든 서버에서 허용되지 않는 구문적으로 유효한 패턴은 자동으로 무시되어야 합니다. 즉, LIST 응답이 발생하지 않으며 LIST 명령은 여전히 ​​태그가 지정된 OK 응답을 반환합니다.

선택 옵션은 LIST 작업으로 선택되는 사서함 이름을 제한하도록 서버에 지시합니다.  선택 옵션을 사용하는 경우 반환되는 사서함은 정식 LIST 패턴 목록과 선택 옵션 모두와 일치하는 사서함입니다.  특정 선택 옵션이 특별한 규칙을 제공하지 않는 한 선택 옵션은 누적됩니다. 즉, 사서함 패턴과 일치하는 사서함은 모든 선택 옵션과도 일치하는 경우에만 선택됩니다.  \(특수 규칙이 있는 선택 옵션의 예는 RECURSIVEMATCH 옵션입니다.\)

반환 옵션은 일치하는 각 사서함에 대해 반환되는 정보를 제어합니다.  반환 옵션은 서버가 정식 LIST 패턴 및 선택 옵션과 일치하는 이름 이외의 추가 사서함 이름에 대한 정보를 보고하도록 해서는 안 됩니다.  반환 옵션이 지정되지 않으면 클라이언트는 사서함 속성에 대한 정보만 기대합니다.  서버는 일치하는 사서함에 대한 다른 정보를 반환할 수 있으며 클라이언트는 해당 상황을 처리할 수 있어야 합니다.

초기 선택 옵션과 반환 옵션은 다음 하위 섹션에서 정의되며, 새로운 옵션도 확장에서 정의됩니다.  이 문서에 정의된 초기 옵션은 반드시 지원되어야 합니다.  초기가 아닌 각 옵션은 기능 문자열에 의해 활성화되며\(하나의 기능이 여러 옵션을 활성화할 수 있음\) 클라이언트는 서버가 지원을 광고하지 않은 옵션을 보내서는 안 됩니다.  서버는 BAD 응답으로 인식하지 못하는 옵션에 응답해야 합니다.  클라이언트는 옵션을 두 번 이상 지정해서는 안 됩니다. 그러나 클라이언트가 이를 수행하는 경우 서버는 옵션을 한 번만 수신한 것처럼 작동해야 합니다.  클라이언트가 옵션을 지정하는 순서는 중요하지 않습니다.

일반적으로 RECURSIVEMATCH를 제외한 각 선택 옵션에는 동일한 이름을 가진 해당 반환 옵션이 있습니다.  REMOTE 선택 옵션은 이 점에서 예외적이며 해당 반환 옵션이 없습니다.  이는 반환되는 사서함 집합을 제한하는 것이 아니라 확장하기 때문입니다.  이 사양에 대한 향후 확장에서는 이러한 병렬성을 염두에 두고 해당 선택 및 반환 옵션 쌍을 정의해야 합니다.

서버 구현에서는 특정 상황에서 특정 문자나 이름이 와일드카드와 일치하는 것을 방지함으로써 액세스 가능한 사서함을 와일드카드 문자에서 "숨길" 수 있습니다. 예를 들어 UNIX 기반 서버에서는 첫 번째 "/" 문자가 일치하지 않도록 "\*"의 해석을 제한할 수 있습니다.

이 서버에서 이 사용자에 대해 INBOX를 지원하고 대문자 문자열 "INBOX"가 위에서 설명한 대로 해석된 참조 및 와일드카드가 포함된 사서함 이름 인수와 일치하는 경우 특수 이름 INBOX가 LIST의 출력에 포함됩니다.  INBOX를 생략하는 기준은 SELECT INBOX가 실패를 반환할지 여부입니다. 사용자의 실제 INBOX가 이 서버에 있는지 아니면 다른 서버에 있는지는 중요하지 않습니다.

---
##### **6.3.9.1.  LIST Selection Options**

본 명세서에서 정의된 선택 옵션은 다음과 같다.

SUBSCRIBED - LIST 명령이 기존 사서함 대신 가입된 이름을 나열하도록 합니다.  이는 실제 사서함의 하위 집합인 경우가 많습니다.  이 목록에 존재하지 않는 사서함 이름이 포함될 수도 있습니다.  어떤 경우든 목록에는 정식 목록 패턴과 일치하고 구독되는 사서함 이름이 정확하게 포함되어야 합니다.

- 이 옵션은 사서함 이름이 구독되었음을 나타내는 사서함 속성 "\Subscribed"를 정의합니다.  "\Subscribed" 속성은 반드시 지원되어야 하며 SUBSCRIBED 선택 옵션이 지정된 경우 정확하게 계산되어야 합니다.

- SUBSCRIBED 선택 옵션은 SUBSCRIBED 반환 옵션을 의미합니다\(아래 참조\).

REMOTE - \[RFC2193\]에 설명된 대로 LIST 명령이 로컬 사서함뿐만 아니라 원격 사서함도 표시하도록 합니다.  이 옵션은 RLIST 명령을 대체하고 SUBSCRIBED 선택 옵션과 함께 RLSUB 명령을 대체하기 위한 것입니다.  원격 사서함 개념을 지원하지 않는 서버에서는 이 옵션을 무시할 수 있습니다.

- 이 옵션은 사서함이 원격 사서함임을 나타내는 사서함 특성 "\Remote"를 정의합니다.  REMOTE 옵션이 지정된 경우 "\Remote" 특성을 정확하게 계산해야 합니다.

- REMOTE 선택 옵션은 다른 옵션과 상호 작용이 없습니다. 그 효과는 로컬 사서함 외에 원격 사서함에 다른 옵션\(있는 경우\)을 적용하도록 서버에 지시하는 것입니다.  특히 RECURSIVEMATCH와 상호 작용이 없습니다\(아래 참조\). \(RECURSIVEMATCH\)에 대한 요청도 유효하지 않기 때문에 \(REMOTE RECURSIVEMATCH\)에 대한 요청도 유효하지 않습니다.  \(REMOTE RECURSIVEMATCH SUBSCRIBED\)에 대한 요청은 로컬 및 원격 모두에서 구독된 모든 사서함을 요청합니다.

RECURSIVEMATCH - 서버가 다른 선택 옵션과 일치하지 않지만 일부 하위 사서함이 일치하는 상위 사서함에 대한 정보를 반환하도록 강제합니다.  섹션 6.3.9.6에 설명된 대로 어린이에 대한 정보는 CHILDINFO 확장 데이터 항목에 반환됩니다.

- 참고 1: 상위 사서함이 반환되려면 여전히 표준 LIST 패턴과 일치해야 합니다.

- 참고 2: CHILDINFO 확장 데이터 항목을 반환할 때 하위 메일함이 표준 LIST 패턴과 일치하는지 여부는 중요하지 않습니다.  섹션 6.3.9.8의 예제 9도 참조하세요.

- RECURSIVEMATCH 옵션은 유일한 선택 옵션으로\(또는 REMOTE로만\) 발생해서는 안 됩니다. 이는 다른 선택 옵션도 사용될 때만 의미가 있기 때문입니다.  이러한 경우 서버는 BAD 태그가 지정된 응답을 반환해야 합니다.

- RECURSIVEMATCH 옵션이 지정되더라도 클라이언트는 CHILDINFO 확장 데이터 항목이 반환되고 후속 LIST 명령의 선택 기준을 충족하는 하위 메일박스가 없는 경우를 처리할 수 있어야 합니다. LIST 응답이 전송된 후 클라이언트가 해당 응답에 액세스하기 전에 이름이 변경되었습니다.

---
##### **6.3.9.2.  LIST Return Options**

본 명세서에 정의된 반환 옵션은 다음과 같다.

SUBSCRIBED - LIST 명령이 일치하는 모든 사서함 이름에 대한 구독 상태를 반환하도록 합니다.  "\Subscribed" 속성은 지원되어야 하며 SUBSCRIBED 반환 옵션이 지정된 경우 정확하게 계산되어야 합니다.  또한 다른 모든 메일함 속성은 정확하게 계산되어야 합니다\(이는 \[RFC3501\]에서 사용되지 않는 LSUB 명령의 동작과 다릅니다\).  위의 요구 사항은 결과를 신속하게 반환하기 위한 LIST 명령의 요구 사항\(6.3.9절 참조\)을 무시하지 않는다는 점에 유의하십시오. 즉, 서버 구현은 결과를 빠르고 정확하게 계산해야 합니다.  예를 들어, 서버 구현자는 빠른 액세스 색인을 생성해야 할 수 있습니다.

CHILDREN - \[RFC3348\]에서 원래 제안된 대로 사서함 하위 정보를 요청합니다.  자세한 내용은 아래 섹션 6.3.9.5를 참조하세요.

STATUS - 일치하는 각 사서함에 대해 STATUS 응답을 요청합니다.

- 이 옵션은 STATUS 데이터 항목을 매개변수로 사용합니다.  목록 패턴 및 선택 옵션과 일치하는 각 선택 가능한 메일박스에 대해 서버는 아래에 설명된 일부 경우를 제외하고 태그 없는 LIST 응답과 STATUS 반환 옵션에서 요청된 정보가 포함된 태그 없는 STATUS 응답을 반환해야 합니다.

- 사서함을 선택할 수 없기 때문에 나열된 사서함에 대한 상태 시도가 실패한 경우\(예: "l" 액세스 제어 목록\(ACL\) 권한 \[RFC4314\]이 사서함에 부여되고 "r" 권한이 부여되지 않은 경우\) 또는 사서함을 \NoSelect로 변경하는 LIST와 STATUS 사이의 경합 조건으로 인해\) STATUS 응답은 반환되어서는 안 되며 LIST 응답에는 \NoSelect 속성이 포함되어야 합니다.  이는 서버가 필요한 STATUS 정보를 성공적으로 조회할 때까지 LIST 응답을 버퍼링해야 할 수도 있음을 의미합니다.

- 서버가 STATUS 정보를 조회하는 동안 예상치 못한 문제가 발생하는 경우 해당 STATUS 응답을 삭제할 수 있습니다.  이러한 상황에서도 LIST 명령은 여전히 ​​태그가 지정된 OK 응답을 반환합니다.

- 현재 선택된 메일함의 상태를 얻는 방법에 대한 정보는 섹션 6.3.11의 STATUS 명령에 대한 설명을 참조하십시오.

---
##### **6.3.9.3.  General Principles for Returning LIST Responses**

이 섹션에서는 LIST 응답이 반환되어야 하는지 여부와 응답 수 및 응답에 포함될 수 있는 정보 종류를 결정하기 위해 이 문서의 서버 구현에서 사용할 수 있는 몇 가지 원칙을 간략하게 설명합니다.

1. 표준 LIST 패턴과 일치하는 각 사서함 이름에 대해 최대 하나의 LIST 응답이 반환되어야 합니다.  서버 구현자는 클라이언트가 여러 LIST 응답에서 반환된 사서함 속성과 기타 정보를 조합할 수 있다고 가정해서는 안 됩니다.

1. LIST 명령에 대한 응답에 일치하는 사서함 이름을 포함하는 이유는 두 가지뿐입니다\(서버는 언제든지 원치 않는 응답을 반환할 수 있으며 이러한 응답에는 이 규칙이 적용되지 않습니다\).

- A. 메일함 이름도 선정 기준을 만족합니다.

```text
       B.  The mailbox name doesn't satisfy the selection criteria, but
           it has at least one descendant mailbox name that satisfies
           the selection criteria and that doesn't match the canonical
           LIST pattern.

           For more information on this case, see the CHILDINFO extended
           data item described in Section 6.3.9.6.  Note that the
           CHILDINFO extended data item can only be returned when the
           RECURSIVEMATCH selection option is specified.
```

1. 동일한 LIST 응답에서 반환된 속성은 추가로 처리됩니다.  예를 들어, 다음 응답

```text
        S: * LIST (\Subscribed \NonExistent) "/" "Fruit/Peach"
```

- "과일/복숭아" 메일함은 존재하지 않지만 구독됨을 의미합니다.

---
##### **6.3.9.4.  Additional LIST-Related Requirements on Clients**

모든 클라이언트는 LIST 속성에서 추론할 수 있는 속성을 암시하는 것으로 더 강한 의미로 처리해야 합니다.  \(현재 정의된 속성 목록은 섹션 7.3.1을 참조하십시오.\) 예를 들어 클라이언트는 \HasNoChildren 속성이 서버에서 전송된 것처럼 \NoInferiors 속성의 존재를 처리해야 합니다.

다음 표에는 추론 규칙이 요약되어 있습니다.

```text
                +====================+===================+
                | returned attribute | implied attribute |
                +====================+===================+
                |    \NoInferiors    |   \HasNoChildren  |
                +--------------------+-------------------+
                |    \NonExistent    |     \NoSelect     |
                +--------------------+-------------------+

                                 Table 2
```

---
##### **6.3.9.5.  The CHILDREN Return Option**

CHILDREN 반환 옵션은 단순히 클라이언트가 사서함에 하위 사서함이 포함되어 있는지 여부에 대한 정보를 원한다는 표시입니다. 옵션이 지정되지 않은 경우에도 서버는 이를 제공할 수 있습니다.

많은 IMAP 클라이언트는 사용자가 액세스할 수 있는 사서함의 계층적 보기를 사용자에게 제공합니다.  처음에 전체 사서함 계층 구조를 사용자에게 표시하는 것보다 사서함 계층 구조의 축소된 개요 목록을 사용자에게 표시하는 것이 더 나은 경우가 많습니다\(특히 사서함 수가 많은 경우\). 그런 다음 사용자는 필요에 따라 축소된 개요 계층 구조를 확장할 수 있습니다. 특정 사서함 아래에 하위 사서함이 있음을 나타내기 위해 축소된 계층 구조 내에 시각적 단서\(예: '+''\)를 포함하는 것이 일반적입니다.  시각적 단서를 클릭하면 계층 목록이 확장되어 하위 사서함이 표시됩니다.  CHILDREN 반환 옵션은 클라이언트가 각 사서함 이름에 대해 LIST "" \* 또는 LIST "" %를 실행하지 않고 특정 사서함에 하위 항목이 있는지 여부를 효율적으로 확인할 수 있는 메커니즘을 제공합니다.  CHILDREN 반환 옵션은 LIST 응답 내에서 반드시 반환되어야 하는 두 가지 새로운 속성인 \HasChildren 및 \HasNoChildren을 정의합니다.  이러한 속성은 LIST 명령에 대한 응답으로 반환될 수 있지만 클라이언트가 특히 이 정보를 원한다는 것을 나타내기 위해 CHILDREN 반환 옵션이 제공됩니다.  CHILDREN 반환 옵션이 있는 경우 서버는 계산 비용이 많이 들더라도 이러한 속성을 반환해야 합니다.

\HasChildren - 이 특성이 있으면 사서함에 하위 사서함이 있음을 나타냅니다.  하위 사서함이 있고 사용자가 그 중 어느 것에도 액세스할 수 있는 권한이 없는 경우 서버는 이 특성을 설정해서는 안 됩니다.  이 경우 \HasNoChildren을 사용해야 합니다.  그러나 대부분의 경우 서버는 사용자가 하위 사서함에 액세스할 수 있는지 여부를 효율적으로 계산하지 못할 수 있습니다.  사서함을 처리할 때 사서함의 \HasChildren 특성이 정확해야 하더라도 클라이언트는 사서함이 \HasChildren 특성으로 표시되어 있지만 하위 사서함이 나타나지 않는 상황을 처리할 준비가 되어 있어야 합니다. LIST 명령에 대한 응답입니다.  예를 들어, 서버가 하위 사서함을 나열할 수 있기 전에 다른 클라이언트가 하위 사서함을 삭제하거나 사용자가 액세스 제어를 사용하여 액세스할 수 없도록 만든 경우에 이런 일이 발생할 수 있습니다.

\HasNoChildren - 이 특성이 있으면 사서함에 현재 인증된 사용자가 액세스할 수 있는 하위 사서함이 없음을 나타냅니다.

서버가 동일한 LIST 응답에서 \HasChildren 및 \HasNoChildren 속성을 모두 반환하는 것은 오류입니다.

참고: \HasNoChildren 특성을 \NoInferiors 특성과 혼동해서는 안 됩니다. 이는 현재 하위 사서함이 존재하지 않으며 앞으로도 만들 수 없음을 나타냅니다.

---
##### **6.3.9.6.  CHILDINFO Extended Data Item**

클라이언트가 RECURSIVEMATCH 선택 옵션을 지정하지 않는 한 CHILDINFO 확장 데이터 항목은 반환되어서는 안 됩니다.

LIST 응답의 CHILDINFO 확장 데이터 항목은 해당 항목이 반환되도록 한 선택 기준을 설명하고 사서함에 선택 기준과 일치하는 하위 사서함이 하나 이상 있음을 나타냅니다.

참고: 일부 서버에서는 상위 서버가 없어도 사서함이 존재할 수 있도록 허용합니다.  예를 들어 "Customers/ABC" 사서함은 존재할 수 있지만 "Customers" 사서함은 존재하지 않을 수 있습니다.  RECURSIVEMATCH 선택 옵션이 지정되지 않은 경우 CHILDINFO 확장 데이터 항목이 허용되지 않으므로 이러한 서버는 "\NonExistent\HasChildren" 속성 쌍을 사용하여 선택 기준과 일치하는 하위 사서함이 있음을 클라이언트에 신호를 보내야 합니다.  섹션 6.3.9.8의 예 11을 참조하십시오.

반환된 선택 기준을 통해 클라이언트는 요청된 응답과 원치 않는 응답을 구별할 수 있을 뿐만 아니라 서로 다른 기준을 지정하는 여러 파이프라인 LIST 명령으로 인해 발생한 요청된 응답을 구별할 수 있습니다.

서버는 하나 이상의 일치하는 하위 항목도 반환되지 않는 경우 CHILDINFO와 함께 일치하지 않는 사서함 이름만 반환해야 합니다. 즉, 서버는 중복된 CHILDINFO 응답을 억제해야 합니다.

섹션 6.3.9.8의 예제 8과 10은 현재 CHILDINFO 확장 데이터 항목과 "\HasChildren" 속성 간의 차이점을 보여줍니다.

다음 표에는 "\NonExistent" 특성과 CHILDINFO 간의 상호 작용이 요약되어 있습니다. 첫 번째 열은 상위 사서함이 있는지 여부를 나타냅니다.

```text
     +========+===========+====================+=====================+
     | Exists | Meets the |  Has a child that  | Returned IMAP4rev2/ |
     |        | selection |     meets the      |    LIST-EXTENDED    |
     |        |  criteria | selection criteria |    attributes and   |
     |        |           |                    |      CHILDINFO      |
     +========+===========+====================+=====================+
     |   no   |     no    |         no         |   no LIST response  |
     |        |           |                    |       returned      |
     +--------+-----------+--------------------+---------------------+
     |  yes   |     no    |         no         |   no LIST response  |
     |        |           |                    |       returned      |
     +--------+-----------+--------------------+---------------------+
     |   no   |    yes    |         no         |    (\NonExistent    |
     |        |           |                    |       <attr>)       |
     +--------+-----------+--------------------+---------------------+
     |  yes   |    yes    |         no         |       (<attr>)      |
     +--------+-----------+--------------------+---------------------+
     |   no   |     no    |        yes         |   (\NonExistent) +  |
     |        |           |                    |      CHILDINFO      |
     +--------+-----------+--------------------+---------------------+
     |  yes   |     no    |        yes         |    () + CHILDINFO   |
     +--------+-----------+--------------------+---------------------+
     |   no   |    yes    |        yes         |    (\NonExistent    |
     |        |           |                    | <attr>) + CHILDINFO |
     +--------+-----------+--------------------+---------------------+
     |  yes   |    yes    |        yes         |      (<attr>) +     |
     |        |           |                    |      CHILDINFO      |
     +--------+-----------+--------------------+---------------------+

                                  Table 3
```

여기서 <attr\>은 선택 기준에 해당하는 하나 이상의 속성입니다. 예를 들어 SUBSCRIBED 옵션의 경우 <attr\>은 \Subscribed입니다.

---
##### **6.3.9.7.  OLDNAME Extended Data Item**

OLDNAME 확장 데이터 항목은 사서함 이름이 생성되거나\(CREATE 명령 사용\) 이름이 변경되거나\(RENAME 명령 사용\) 삭제될 때\(DELETE 명령 사용\) 포함됩니다.  \(사서함이 삭제되면 "\NonExistent" 특성도 포함됩니다.\) IMAP 확장은 OLDNAME 확장 데이터 항목이 포함되어야 하는 경우 다른 조건을 지정할 수 있습니다.

서버가 SELECT/EXAMINE, CREATE, RENAME 또는 DELETE에서 비정규화된 사서함 이름\(섹션 5.1 참조\)을 허용하는 경우 제공된 사서함 이름이 결과 정규화된 사서함과 다를 때마다 OLDNAME 확장 데이터 항목을 포함하는 원치 않는 LIST 응답을 반환해야 합니다\(SHOULD\). 이름.  클라이언트 관점에서 이는 이전 단락에 지정된 대로 다른 사용자가 사서함 이름을 바꾸거나 삭제하는 것과 구별할 수 없습니다.

삭제된 사서함은 다음과 같이 공지할 수 있습니다.

```text
     S: * LIST (\NonExistent) "." "INBOX.DeletedMailbox"
```

이름이 변경된 사서함의 예:

```text
     S: * LIST () "/" "NewMailbox" ("OLDNAME" ("OldMailbox"))
```

---
##### **6.3.9.8.  LIST Command Examples**

이 예에서는 기본 LIST 명령의 몇 가지 용도를 보여줍니다.

```text
   Example:

     C: A101 LIST "" ""
     S: * LIST (\Noselect) "/" ""
     S: A101 OK LIST Completed
     C: A102 LIST #news.comp.mail.misc ""
     S: * LIST (\Noselect) "." #news.
     S: A102 OK LIST Completed
     C: A103 LIST /usr/staff/jones ""
     S: * LIST (\Noselect) "/" /
     S: A103 OK LIST Completed
     C: A202 LIST ~/Mail/ %
     S: * LIST (\Noselect) "/" ~/Mail/foo
     S: * LIST () "/" ~/Mail/meetings
     S: A202 OK LIST completed

   Extended examples:
```

1: 첫 번째 예는 다른 예에 사용될 전체 로컬 계층 구조를 보여줍니다.

```text
        C: A01 LIST "" "*"
        S: * LIST (\Marked \NoInferiors) "/" "inbox"
        S: * LIST () "/" "Fruit"
        S: * LIST () "/" "Fruit/Apple"
        S: * LIST () "/" "Fruit/Banana"
        S: * LIST () "/" "Tofu"
        S: * LIST () "/" "Vegetable"
        S: * LIST () "/" "Vegetable/Broccoli"
        S: * LIST () "/" "Vegetable/Corn"
        S: A01 OK done
```

2: 다음 예에서는 구독된 사서함을 볼 수 있습니다.  이는 현재 더 이상 사용되지 않는 <LSUB "" "\*"\>와 유사하지만 동일하지는 않습니다\(LSUB 명령에 대한 자세한 내용은 \[RFC3501\] 참조\). "Fruit/Peach"라는 메일함이 구독되어 있지만 실제로는 존재하지 않습니다\(아마도 구독 중에 삭제되었을 수 있음\).  "Fruit" 사서함은 구독되지 않았지만 구독된 하위 항목이 두 개 있습니다.  "Vegetable" 사서함이 구독되고 두 개의 하위 항목이 있습니다. 그 중 하나도 구독 중입니다.

```text
        C: A02 LIST (SUBSCRIBED) "" "*"
        S: * LIST (\Marked \NoInferiors \Subscribed) "/" "inbox"
        S: * LIST (\Subscribed) "/" "Fruit/Banana"
        S: * LIST (\Subscribed \NonExistent) "/" "Fruit/Peach"
        S: * LIST (\Subscribed) "/" "Vegetable"
        S: * LIST (\Subscribed) "/" "Vegetable/Broccoli"
        S: A02 OK done
```

3: 다음 예에서는 CHILDREN 옵션의 사용을 보여줍니다.  이제 클라이언트는 계층 구조의 두 번째 수준을 나열할 필요 없이 하위 사서함\(하위 사서함\)이 있는 최상위 사서함과 그렇지 않은 사서함을 알 수 있습니다.  \NoInferiors 속성이 이미 이를 암시하고 더 강한 의미를 갖고 있기 때문에 서버가 받은 편지함에 대해 \HasNoChildren 속성을 반환할 필요는 없습니다.

```text
        C: A03 LIST () "" "%" RETURN (CHILDREN)
        S: * LIST (\Marked \NoInferiors) "/" "inbox"
        S: * LIST (\HasChildren) "/" "Fruit"
        S: * LIST (\HasNoChildren) "/" "Tofu"
        S: * LIST (\HasChildren) "/" "Vegetable"
        S: A03 OK done
```

4: 이 예에서는 다른 서버에 있는 더 많은 사서함을 볼 수 있습니다.  이는 <RLIST "" "%"\> 명령과 유사합니다.

```text
        C: A04 LIST (REMOTE) "" "%" RETURN (CHILDREN)
        S: * LIST (\Marked \NoInferiors) "/" "inbox"
        S: * LIST (\HasChildren) "/" "Fruit"
        S: * LIST (\HasNoChildren) "/" "Tofu"
        S: * LIST (\HasChildren) "/" "Vegetable"
        S: * LIST (\Remote \HasNoChildren) "/" "Bread"
        S: * LIST (\HasChildren \Remote) "/" "Meat"
        S: A04 OK done
```

5: 다음 예에서는 또한 다른 서버에 있는 사서함을 포함하도록 서버에 요청합니다.  서버는 구독된 모든 사서함에 대한 정보를 반환합니다.  이는 <RLSUB "" "\*"\> 명령과 유사합니다\(RLSUB에 대한 자세한 내용은 \[RFC2193\] 참조\).  또한 두 가지 선택 옵션이 사용되는 것을 볼 수 있습니다.

```text
        C: A05 LIST (REMOTE SUBSCRIBED) "" "*"
        S: * LIST (\Marked \NoInferiors \Subscribed) "/" "inbox"
        S: * LIST (\Subscribed) "/" "Fruit/Banana"
        S: * LIST (\Subscribed \NonExistent) "/" "Fruit/Peach"
        S: * LIST (\Subscribed) "/" "Vegetable"
        S: * LIST (\Subscribed) "/" "Vegetable/Broccoli"
        S: * LIST (\Remote \Subscribed) "/" "Bread"
        S: A05 OK done
```

6: 다음 예에서는 다른 서버에 있는 사서함을 포함하도록 서버에 요청합니다.  서버는 반환된 모든 사서함에 대한 구독 정보를 반환하라는 요청을 받습니다.  이는 위의 예와 다릅니다.

- 이 명령의 출력은 존재하지 않는 "과일/복숭아"에 대한 LIST 응답을 포함하지 않으므로 이전 예의 출력의 상위 집합이 아닙니다.

```text
        C: A06 LIST (REMOTE) "" "*" RETURN (SUBSCRIBED)
        S: * LIST (\Marked \NoInferiors \Subscribed) "/" "inbox"
        S: * LIST () "/" "Fruit"
        S: * LIST () "/" "Fruit/Apple"
        S: * LIST (\Subscribed) "/" "Fruit/Banana"
        S: * LIST () "/" "Tofu"
        S: * LIST (\Subscribed) "/" "Vegetable"
        S: * LIST (\Subscribed) "/" "Vegetable/Broccoli"
        S: * LIST () "/" "Vegetable/Corn"
        S: * LIST (\Remote \Subscribed) "/" "Bread"
        S: * LIST (\Remote) "/" "Meat"
        S: A06 OK done
```

7: 다음 예에서는 \HasChildren 속성과 CHILDINFO 확장 데이터 항목 간의 차이점을 보여줍니다.

- 다음과 같은 계층 구조가 있다고 가정해 보겠습니다.

```text
        C: C01 LIST "" "*"
        S: * LIST (\Marked \NoInferiors) "/" "inbox"
        S: * LIST () "/" "Foo"
        S: * LIST () "/" "Foo/Bar"
        S: * LIST () "/" "Foo/Baz"
        S: * LIST () "/" "Moo"
        S: C01 OK done
```

- 클라이언트가 RETURN \(CHILDREN\)을 요청하면 다음을 얻습니다.

```text
        C: CA3 LIST "" "%" RETURN (CHILDREN)
        S: * LIST (\Marked \NoInferiors) "/" "inbox"
        S: * LIST (\HasChildren) "/" "Foo"
        S: * LIST (\HasNoChildren) "/" "Moo"
        S: CA3 OK done

        A)  Let's also assume that the mailbox "Foo/Baz" is the only
            subscribed mailbox.  Then we get this result:

             C: C02 LIST (SUBSCRIBED) "" "*"
             S: * LIST (\Subscribed) "/" "Foo/Baz"
             S: C02 OK done

            Now, if the client issues <LIST (SUBSCRIBED) "" "%">, the
            server will return no mailboxes (as the mailboxes "Moo",
            "Foo", and "Inbox" are NOT subscribed).  However, if the
            client issues this:

             C: C04 LIST (SUBSCRIBED RECURSIVEMATCH) "" "%"
             S: * LIST () "/" "Foo" ("CHILDINFO" ("SUBSCRIBED"))
             S: C04 OK done

            (that is, the mailbox "Foo" is not subscribed, but it has a
            child that is), then A1 or A2 occurs.

            A1)  If the mailbox "Foo" had also been subscribed, the last
                 command would return this:

                 C: C04 LIST (SUBSCRIBED RECURSIVEMATCH) "" "%"
                 S: * LIST (\Subscribed) "/" "Foo" ("CHILDINFO"
                     ("SUBSCRIBED"))
                 S: C04 OK done
```

- 아니면 이것도:

```text
                 C: C04 LIST (SUBSCRIBED RECURSIVEMATCH) "" "%"
                 S: * LIST (\Subscribed \HasChildren) "/" "Foo"
                     ("CHILDINFO" ("SUBSCRIBED"))
                 S: C04 OK done

            A2)  If we assume instead that the mailbox "Foo" is not part
                 of the original hierarchy and is not subscribed, the
                 last command will give this result:

                 C: C04 LIST (SUBSCRIBED RECURSIVEMATCH) "" "%"
                 S: * LIST (\NonExistent) "/" "Foo" ("CHILDINFO"
                     ("SUBSCRIBED"))
                 S: C04 OK done

        B)  Now, let's assume that no mailbox is subscribed.  In this
            case, the command <LIST (SUBSCRIBED RECURSIVEMATCH) "" "%">
            will return no responses, as there are no subscribed
            children (even though "Foo" has children).

        C)  And finally, suppose that only the mailboxes "Foo" and "Moo"
            are subscribed.  In that case, we see this result:

             C: C04 LIST (SUBSCRIBED RECURSIVEMATCH) "" "%" RETURN
                 (CHILDREN)
             S: * LIST (\HasChildren \Subscribed) "/" "Foo"
             S: * LIST (\HasNoChildren \Subscribed) "/" "Moo"
             S: C04 OK done

            (which means that the mailbox "Foo" has children, but none
            of them is subscribed).
```

8: 다음 예에서는 하위 사서함이 정식 LIST 패턴과 일치하는지 여부에 관계없이 CHILDINFO 확장 데이터 항목이 반환된다는 것을 보여줍니다.

- 다음과 같은 계층 구조가 있다고 가정해 보겠습니다.

```text
        C: D01 LIST "" "*"
        S: * LIST (\Marked \NoInferiors) "/" "inbox"
        S: * LIST () "/" "foo2"
        S: * LIST () "/" "foo2/bar1"
        S: * LIST () "/" "foo2/bar2"
        S: * LIST () "/" "baz2"
        S: * LIST () "/" "baz2/bar2"
        S: * LIST () "/" "baz2/bar22"
        S: * LIST () "/" "baz2/bar222"
        S: * LIST () "/" "eps2"
        S: * LIST () "/" "eps2/mamba"
        S: * LIST () "/" "qux2/bar2"
        S: D01 OK done
```

- 그리고 다음 사서함이 구독됩니다.

```text
        C: D02 LIST (SUBSCRIBED) "" "*"
        S: * LIST (\Subscribed) "/" "foo2/bar1"
        S: * LIST (\Subscribed) "/" "foo2/bar2"
        S: * LIST (\Subscribed) "/" "baz2/bar2"
        S: * LIST (\Subscribed) "/" "baz2/bar22"
        S: * LIST (\Subscribed) "/" "baz2/bar222"
        S: * LIST (\Subscribed) "/" "eps2"
        S: * LIST (\Subscribed) "/" "eps2/mamba"
        S: * LIST (\Subscribed) "/" "qux2/bar2"
        S: D02 OK done
```

- 클라이언트는 먼저 다음 명령을 실행합니다.

```text
        C: D03 LIST (RECURSIVEMATCH SUBSCRIBED) "" "*2"
        S: * LIST () "/" "foo2" ("CHILDINFO" ("SUBSCRIBED"))
        S: * LIST (\Subscribed) "/" "foo2/bar2"
        S: * LIST (\Subscribed) "/" "baz2/bar2"
        S: * LIST (\Subscribed) "/" "baz2/bar22"
        S: * LIST (\Subscribed) "/" "baz2/bar222"
        S: * LIST (\Subscribed) "/" "eps2" ("CHILDINFO" ("SUBSCRIBED"))
        S: * LIST (\Subscribed) "/" "qux2/bar2"
        S: D03 OK done
```

- 서버는 다음을 포함할 수도 있습니다\(그러나 이는 CHILDINFO가 중복되기 때문에 섹션 6.3.9.6의 제한 사항을 위반합니다\).

```text
        S: * LIST () "/" "baz2" ("CHILDINFO" ("SUBSCRIBED"))
        S: * LIST (\NonExistent) "/" "qux2" ("CHILDINFO" ("SUBSCRIBED"))
```

- CHILDINFO 확장 데이터 항목은 사서함 "foo2", "baz2" 및 "eps2"에 대해 반환됩니다. 왜냐하면 사서함 "foo2"의 경우 구독한 두 하위 항목 중 하나만 패턴과 일치하더라도 모두 구독된 하위 항목이 있기 때문입니다. 사서함 "baz2"의 경우 구독한 모든 하위 항목이 패턴과 일치합니다. 사서함 "eps2"의 경우 구독한 하위 항목 중 패턴과 일치하는 항목이 없습니다.

- 클라이언트가 다음을 발행하는 경우 참고하십시오.

```text
        C: D03 LIST (RECURSIVEMATCH SUBSCRIBED) "" "*"
        S: * LIST () "/" "foo2" ("CHILDINFO" ("SUBSCRIBED"))
        S: * LIST (\Subscribed) "/" "foo2/bar1"
        S: * LIST (\Subscribed) "/" "foo2/bar2"
        S: * LIST () "/" "baz2" ("CHILDINFO" ("SUBSCRIBED"))
        S: * LIST (\Subscribed) "/" "baz2/bar2"
        S: * LIST (\Subscribed) "/" "baz2/bar22"
        S: * LIST (\Subscribed) "/" "baz2/bar222"
        S: * LIST (\Subscribed) "/" "eps2" ("CHILDINFO" ("SUBSCRIBED"))
        S: * LIST (\Subscribed) "/" "eps2/mamba"
        S: * LIST (\Subscribed) "/" "qux2/bar2"
        S: D03 OK done
```

- 사서함 "foo2", "baz2" 및 "eps2"에 대한 LIST 응답에는 여전히 CHILDINFO 확장 데이터 항목이 있습니다. 이 정보가 중복되고 클라이언트가 자체적으로 결정할 수 있더라도 마찬가지입니다.

9: 다음 예에서는 메일박스 패턴에 대한 확장 구문의 사용법을 보여줍니다.  또한 CHILDINFO 확장 데이터 항목이 있다고 해서 반드시 \HasChildren을 의미하는 것은 아니라는 점을 보여줍니다.

```text
        C: a1 LIST "" ("foo")
        S: * LIST () "/" foo
        S: a1 OK done

        C: a2 LIST (SUBSCRIBED) "" "foo/*"
        S: * LIST (\Subscribed \NonExistent) "/" foo/bar
        S: a2 OK done

        C: a3 LIST (SUBSCRIBED RECURSIVEMATCH) "" foo RETURN (CHILDREN)
        S: * LIST (\HasNoChildren) "/" foo ("CHILDINFO" ("SUBSCRIBED"))
        S: a3 OK done
```

10: 다음 예에서는 누락된 사서함 계층 구조 요소를 지원하는 서버가 RECURSIVEMATCH 선택 옵션을 지정하지 않은 클라이언트에 선택 기준과 일치하는 하위 사서함이 있다는 신호를 보내는 방법을 보여줍니다.

```text
        C: a1 LIST (REMOTE) "" *
        S: * LIST () "/" music/rock
        S: * LIST (\Remote) "/" also/jazz
        S: a1 OK done

        C: a2 LIST () "" %
        S: * LIST (\NonExistent \HasChildren) "/" music
        S: a2 OK done

        C: a3 LIST (REMOTE) "" %
        S: * LIST (\NonExistent \HasChildren) "/" music
        S: * LIST (\NonExistent \HasChildren) "/" also
        S: a3 OK done

        C: a3.1 LIST "" (% music/rock)
        S: * LIST () "/" music/rock
        S: a3.1 OK done
```

- "music/rock"은 "music" 아래의 유일한 메일박스이므로 서버가 "music"도 반환할 필요가 없습니다.  그러나 클라이언트는 두 경우를 모두 처리해야 합니다.

11: 다음 예에서는 STATUS 반환 옵션의 사용을 보여줍니다.

```text
        C: A01 LIST "" % RETURN (STATUS (MESSAGES UNSEEN))
        S: * LIST () "."  "INBOX"
        S: * STATUS "INBOX" (MESSAGES 17 UNSEEN 16)
        S: * LIST () "." "foo"
        S: * STATUS "foo" (MESSAGES 30 UNSEEN 29)
        S: * LIST (\NoSelect) "." "bar"
        S: A01 OK List completed.
```

- "bar" 메일함은 선택할 수 없으므로 STATUS 응답이 없습니다.

```text
        C: A02 LIST (SUBSCRIBED RECURSIVEMATCH) "" % RETURN (STATUS
             (MESSAGES))
        S: * LIST (\Subscribed) "."  "INBOX"
        S: * STATUS "INBOX" (MESSAGES 17)
        S: * LIST () "." "foo" (CHILDINFO ("SUBSCRIBED"))
        S: A02 OK List completed.
```

- "foo"에 대한 LIST 응답은 일치하는 하위 항목이 있기 때문에 반환되지만 "foo" 자체는 선택 기준과 일치하지 않기 때문에 STATUS 응답이 반환되지 않습니다.

---
#### **6.3.10.  NAMESPACE Command**

```text
   Arguments:    none

   Responses:    REQUIRED untagged responses:  NAMESPACE

   Result:       OK -  command completed
                 NO -  Can't complete the command
                 BAD -  arguments invalid
```

NAMESPACE 명령을 사용하면 태그가 지정되지 않은 단일 NAMESPACE 응답이 반환됩니다.  태그가 지정되지 않은 NAMESPACE 응답에는 서버가 노출하려는 서버의 개인 네임스페이스, 다른 사용자의 네임스페이스 및 공유 네임스페이스에 대한 접두사 및 계층 구분 기호가 포함되어 있습니다.  응답에는 사용할 수 없는 네임스페이스 클래스에 대한 NIL이 포함됩니다.  네임스페이스 응답 확장 ABNF 비터미널은 확장성을 위해 정의되며 NAMESPACE 응답에 포함될 수 있습니다.

```text
   Example 1:
```

이 예에서 서버는 단일 개인 네임스페이스를 지원합니다.  개인 사서함에는 선행 접두사가 사용되지 않으며 "/"는 계층 구분 기호입니다.

```text
     C: A001 NAMESPACE
     S: * NAMESPACE (("" "/")) NIL NIL
     S: A001 OK NAMESPACE command completed

   Example 2:
```

사용자가 서버에 익명으로 로그온했습니다.  익명 사용자와 연결된 개인 사서함은 없으며 사용자는 다른 사용자의 네임스페이스에 액세스할 수 없습니다.  공유 사서함에 액세스하는 데는 접두사가 필요하지 않으며 계층 구분 기호는 "."입니다.

```text
     C: A001 NAMESPACE
     S: * NAMESPACE NIL NIL (("" "."))
     S: A001 OK NAMESPACE command completed

   Example 3:
```

개인 네임스페이스와 단일 공유 네임스페이스를 포함하는 서버입니다.

```text
     C: A001 NAMESPACE
     S: * NAMESPACE (("" "/")) NIL (("Public Folders/" "/"))
     S: A001 OK NAMESPACE command completed

   Example 4:
```

개인 네임스페이스, 다른 사용자의 네임스페이스 및 여러 공유 네임스페이스를 포함하는 서버입니다.  각 네임스페이스 내에서 사용되는 계층 구분 기호는 다를 수 있습니다.

```text
     C: A001 NAMESPACE
     S: * NAMESPACE (("" "/")) (("~" "/")) (("#shared/" "/")
         ("#public/" "/")("#ftp/" "/")("#news." "."))
     S: A001 OK NAMESPACE command completed
```

접두사 문자열을 사용하면 클라이언트가 자동으로 개인 사서함을 생성하거나 네임스페이스 내에서 사용 가능한 모든 사서함을 나열하는 등의 작업을 수행할 수 있습니다.

```text
   Example 5:
```

개인 사서함 앞에 INBOX라는 접두사가 있고 계층 구분 기호 "."가 있는 개인 네임스페이스만 지원하는 서버입니다.

```text
     C: A001 NAMESPACE
     S: * NAMESPACE (("INBOX." ".")) NIL  NIL
     S: A001 OK NAMESPACE command completed
```

보낸 편지함을 보관할 사서함을 자동으로 생성합니다.

```text
     C: A002 CREATE "INBOX.Sent Mail"
     S: A002 OK CREATE command completed
```

서버는 일반적으로 단일 개인 네임스페이스와 단일 기타 사용자 네임스페이스만 지원하지만 이러한 네임스페이스가 여러 개 있을 수 있는 상황이 있을 수 있으며 클라이언트는 이에 대비해야 합니다.  클라이언트가 특정 메일함을 생성해야 하도록 구성된 경우 메일함을 생성해야 하는 개인 네임스페이스가 무엇인지 확실하지 않은 상황이 있을 수 있습니다. 이러한 상황에서 클라이언트는 사용자가 메일함을 생성할 네임스페이스를 선택하도록 해야 합니다. 사서함에 넣거나 첫 번째 개인 네임스페이스를 사용하세요.

```text
   Example 6:
```

이 예에서 서버는 두 개의 개인 네임스페이스를 지원합니다.  일반 개인 네임스페이스 외에도 사용자에게는 MH 형식 메일 저장소의 사서함에 대한 액세스를 허용하는 추가 개인 네임스페이스가 있습니다.

클라이언트는 사용자가 보낸 모든 메일의 복사본을 \Sent 속성이 있는 사서함에 저장하도록 구성됩니다\(섹션 7.3.1 참조\). 또한 메시지가 사서함에서 삭제된 후 클라이언트는 해당 메시지를 \Trash 특성이 있는 사서함으로 이동하도록 구성됩니다.  서버는 \NonExistent 사서함 특성을 사용하여 해당 사서함이 아직 존재하지 않으며 사서함을 만들 수 있다는 신호를 보냅니다.  일단 생성되면 \Sent 또는 \Trash 목적으로 사용될 수 있으며 서버에는 더 이상 \NonExistent 사서함 특성이 포함되지 않습니다.

이 예는 #mh 네임스페이스를 추가로 설명하기 위해 일부 확장 매개변수를 전달하는 방법을 보여줍니다.  가상의 "X-PARAM" 확장 매개변수를 참조하세요.

```text
     C: A001 NAMESPACE
     S: * NAMESPACE (("" "/")("#mh/" "/" "X-PARAM"
         ("FLAG1" "FLAG2"))) NIL NIL
     S: A001 OK NAMESPACE command completed

     C: A002 LIST (SPECIAL-USE) "" "*"
     S: * LIST (\NonExistent \Archive) "/" Archives
     S: * LIST (\NonExistent \Drafts) "/" Drafts
     S: * LIST (\NonExistent \Junk) "/" Junk
     S: * LIST (\NonExistent \Sent) "/" "Sent Mail"
     S: * LIST (\NonExistent \Trash) "/" "Deleted Items"
     S: A002 OK LIST Completed

     C: A003 LIST (SPECIAL-USE) "#mh/" "*"
     S: * LIST (\NonExistent \Archive) "/" "#mh/Archives"
     S: * LIST (\NonExistent \Drafts) "/" "#mh/Drafts"
     S: * LIST (\NonExistent \Junk) "/" "#mh/Junk"
     S: * LIST (\NonExistent \Sent) "/" "#mh/Sent Mail"
     S: * LIST (\NonExistent \Trash) "/" "#mh/Deleted Items"
     S: A003 OK LIST Completed
```

보낸 메일의 복사본은 하나만 보관하는 것이 좋습니다.  클라이언트가 '보낸 메일' 편지함을 생성하기 위해 어떤 개인 네임스페이스를 사용해야 하는지는 확실하지 않습니다.  사용자에게 네임스페이스를 선택하라는 메시지가 표시되고 '보낸 메일' 사서함은 하나만 생성됩니다.

```text
     C: A004 CREATE "Sent Mail"
     S: A004 OK CREATE command completed
```

클라이언트는 각 네임스페이스에 하나씩 두 개의 '삭제된 항목' 사서함을 유지하도록 설계되었습니다.

```text
     C: A005 CREATE "Delete Items"
     S: A005 OK CREATE command completed

     C: A006 CREATE "#mh/Deleted Items"
     S: A006 OK CREATE command completed
```

다른 사용자의 네임스페이스 접두사 다음 계층 구조의 다음 수준은 <username\>으로 구성되어야 합니다. 여기서 <username\>은 LOGIN 또는 AUTHENTICATE 명령에 따른 사용자 이름입니다.

클라이언트는 현재 인증된 사용자가 사용할 수 있는 다른 사용자의 개인 네임스페이스를 검색하기 위해 다른 사용자의 네임스페이스 접두사에 "%"를 추가하여 LIST 명령을 구성할 수 있습니다.

이러한 LIST 명령에 대한 응답으로 서버는 문제의 사용자에게 개인 사서함에 대한 액세스 권한을 부여하지 않은 사용자 이름을 반환해서는 안 됩니다.

서버는 문제의 사용자에게 명시적으로 액세스 권한을 부여한 사용자의 이름만 포함하는 LIST 응답을 반환할 수 있습니다.

대안으로, 서버는 그러한 LIST 명령에 NO를 반환할 수 있으며, 다른 사용자의 사서함을 나열하기 전에 사용자 이름이 다른 사용자의 네임스페이스 접두사와 함께 포함되도록 요구할 수 있습니다.

```text
   Example 7:
```

현재 로그온한 사용자가 액세스할 수 있는 다른 사용자의 사서함 목록 제공을 지원하는 서버입니다.

```text
     C: A001 NAMESPACE
     S: * NAMESPACE (("" "/")) (("Other Users/" "/")) NIL
     S: A001 OK NAMESPACE command completed

     C: A002 LIST "" "Other Users/%"
     S: * LIST () "/" "Other Users/Mike"
     S: * LIST () "/" "Other Users/Karen"
     S: * LIST () "/" "Other Users/Matthew"
     S: * LIST () "/" "Other Users/Tesa"
     S: A002 OK LIST command completed

   Example 8:
```

현재 로그온한 사용자가 액세스할 수 있는 다른 사용자의 사서함 목록 제공을 지원하지 않는 서버입니다.  클라이언트가 다른 사용자의 네임스페이스 접두사와 함께 다른 사용자의 이름을 포함하는 경우 사서함을 나열할 수 있습니다.

```text
     C: A001 NAMESPACE
     S: * NAMESPACE (("" "/")) (("#Users/" "/")) NIL
     S: A001 OK NAMESPACE command completed
```

이 예에서 현재 로그온한 사용자는 사용자 Mike의 개인 네임스페이스에 액세스할 수 있지만 서버는 LIST 응답에서 이 정보를 표시하지 않도록 선택했습니다.  그러나 사용자 이름 Mike\(사용자 입력을 통해 수신됨\)를 다른 사용자의 네임스페이스 접두사에 추가하면 클라이언트는 사용자 Mike의 개인 사서함 목록을 얻을 수 있습니다.

C: A002 LIST "" "#Users/%" S: A002 NO 요청한 항목을 찾을 수 없습니다.

```text
     C: A003 LIST "" "#Users/Mike/%"
     S: * LIST () "/" "#Users/Mike/INBOX"
     S: * LIST () "/" "#Users/Mike/Foo"
     S: A003 OK LIST command completed.
```

접두사 문자열에는 계층 구분 기호가 포함되지 않을 수 있습니다. 어떤 경우에는 접두사의 일부로 필요하지 않기 때문입니다.

```text
   Example 9:
```

다른 사용자의 사서함 앞에 '\~'를 붙이고 그 뒤에 <username\>을 추가하여 다른 사용자의 네임스페이스에 대한 액세스를 허용하는 서버입니다. 여기서 <username\>은 LOGIN 또는 AUTHENTICATE 명령에 따른 사용자 이름입니다.

```text
     C: A001 NAMESPACE
     S: * NAMESPACE (("" "/")) (("~" "/")) NIL
     S: A001 OK NAMESPACE command completed
```

사용자 표시에 대한 사서함 나열

```text
     C: A002 LIST "" "~mark/%"
     S: * LIST () "/" "~mark/INBOX"
     S: * LIST () "/" "~mark/foo"
     S: A002 OK LIST command completed
```

---
#### **6.3.11.  STATUS Command**

```text
   Arguments:    mailbox name

                 status data item names

   Responses:    REQUIRED untagged responses:  STATUS

   Result:       OK -  status completed
                 NO -  status failure: no status for that name
                 BAD -  command unknown or arguments invalid
```

STATUS 명령은 표시된 사서함의 상태를 요청합니다.  현재 선택된 사서함은 변경되지 않으며 쿼리된 사서함의 메시지 상태에도 영향을 주지 않습니다.

STATUS 명령은 두 번째 IMAP4rev2 연결을 열고 사서함에서 EXAMINE 명령을 수행하여 첫 번째 IMAP4rev2 연결에서 현재 사서함을 선택 취소하지 않고 해당 사서함의 상태를 쿼리하는 대신 사용할 수 있습니다.

LIST 명령과 달리 STATUS 명령은 응답 속도가 빠르다고 보장되지 않습니다.  특정 상황에서는 상당히 느릴 수 있습니다.  일부 구현에서는 서버가 특정 상태 정보를 얻기 위해 내부적으로 사서함을 "읽기 전용"으로 열어야 합니다.  또한 LIST 명령과 달리 STATUS 명령은 와일드카드를 허용하지 않습니다.

- 참고: STATUS 명령은 현재 선택된 사서함이 아닌 사서함의 상태에 액세스하기 위한 것입니다.  STATUS 명령으로 인해 사서함이 내부적으로 열릴 수 있고 이 정보는 선택한 사서함에서 다른 방법으로 사용할 수 있으므로 현재 선택한 사서함에서 STATUS 명령을 사용하면 안 됩니다.  그러나 서버는 선택한 사서함에서 STATUS 명령을 실행할 수 있어야 합니다.  \(이는 STATUS 반환 옵션이 LIST 명령에서 사용될 때 암시적으로 발생할 수도 있습니다.\)

- STATUS 명령은 "선택한 메일함에서 새 메시지 확인" 작업으로 사용되어서는 안 됩니다\(새 메시지 확인을 위한 적절한 방법에 대한 자세한 내용은 섹션 7 및 7.4.1을 참조하십시오\).

- STATUS SIZE\(아래 참조\)는 서버 구현에 따라 상당한 시간이 걸릴 수 있습니다.  클라이언트는 STATUS SIZE를 주의해서 사용해야 합니다.

요청할 수 있는 현재 정의된 상태 데이터 항목은 다음과 같습니다.

MESSAGES - 사서함에 있는 메시지 수입니다.

UIDNEXT - 사서함의 다음 고유 식별자 값입니다.  자세한 내용은 섹션 2.3.1.1을 참조하십시오.

UIDVALIDITY - 사서함의 고유 식별자 유효성 값입니다.  자세한 내용은 섹션 2.3.1.1을 참조하십시오.

UNSEEN - \Seen 플래그가 설정되지 않은 메시지 수입니다.

DELETED - \Deleted 플래그가 설정된 메시지 수입니다.

SIZE - 메일함의 총 크기\(옥텟\)입니다.  이는 정확한 값이어야 하는 것은 아니지만 메일박스에 있는 모든 메시지의 RFC822.SIZE FETCH 메시지 데이터 항목\(섹션 6.4.5 참조\) 값의 합보다 크거나 같아야 합니다.

```text
   Example:

     C: A042 STATUS blurdybloop (UIDNEXT MESSAGES)
     S: * STATUS blurdybloop (MESSAGES 231 UIDNEXT 44292)
     S: A042 OK STATUS completed
```

---
#### **6.3.12.  APPEND Command**

```text
   Arguments:    mailbox name

                 OPTIONAL flag parenthesized list

                 OPTIONAL date/time string

                 message literal

   Responses:    OPTIONAL untagged response:  LIST

   Result:       OK -  append completed
                 NO -  append error: can't append to that mailbox, error
                    in flags or date/time or message text
                 BAD -  command unknown or arguments invalid
```

APPEND 명령은 리터럴 인수를 지정된 대상 사서함의 끝에 새 메시지로 추가합니다.  이 인수는 \[RFC5322\] 또는 \[I18N-HDRS\] 메시지 형식이어야 합니다.  메시지에는 8비트 문자가 허용됩니다.  8비트 데이터를 적절하게 보존할 수 없는 서버 구현은 \[MIME-IMB\] 콘텐츠 전송 인코딩을 사용하여 8비트 APPEND 데이터를 7비트로 역방향으로 변환할 수 있어야 합니다.

- 참고: 초안 메시지와 같이 필수 \[RFC5322\] 헤더 필드가 APPEND에 대한 메시지 리터럴 인수에서 생략되는 예외가 있을 수 있습니다.  그렇게 하는 것의 전체 의미를 이해하고 신중하게 평가해야 합니다.

괄호로 묶인 플래그 목록이 지정되면 플래그는 결과 메시지에 설정되어야 합니다. 그렇지 않으면 결과 메시지의 플래그 목록이 기본적으로 "비어 있음"으로 설정됩니다.

날짜-시간이 지정되면 결과 메시지에 내부 날짜가 설정되어야 합니다. 그렇지 않으면 결과 메시지의 내부 날짜가 기본적으로 현재 날짜 및 시간으로 설정됩니다.

어떤 이유로든 추가가 실패하면 사서함은 APPEND 시도 이전의 상태로 복원되어야 합니다\(변경된 사서함의 UIDNEXT 값을 유지하는 것 제외\). 부분 추가는 허용되지 않습니다.

대상 사서함이 존재하지 않는 경우 서버는 오류를 반환해야 하며 자동으로 사서함을 생성해서는 안 됩니다.  대상 사서함을 만들 수 없다는 것이 확실하지 않은 한 서버는 태그가 지정된 NO 응답 텍스트의 접두사로 응답 코드 "\[TRYCREATE\]"를 보내야 합니다.  이는 CREATE 명령을 시도하고 CREATE가 성공하면 APPEND를 다시 시도할 수 있다는 힌트를 클라이언트에 제공합니다.

APPEND가 성공적으로 완료되면 서버는 아래에 별도로 지정하지 않는 한 APPENDUID 응답 코드\(섹션 7.1 참조\)를 반환합니다.

클라이언트가 메일함에 APPEND할 수 있지만 SELECT 또는 EXAMINE할 수 없도록 설정된 권한이 있는 메일함의 경우 서버는 메일함에 대한 정보를 공개하므로 APPENDUID 응답 코드를 보내서는 안 됩니다.

UIDNOTSTICKY 상태\(섹션 7.1 참조\)가 있는 사서함의 경우 서버는 의미가 없으므로 APPENDUID 응답 코드를 생략할 수 있습니다.

현재 사서함이 선택되어 있으면 일반적인 새 메시지 작업이 발생해야 합니다.  특히 서버는 태그가 지정되지 않은 EXISTS 응답을 통해 즉시 클라이언트에 알려야 합니다.  서버가 그렇게 하지 않으면 클라이언트는 하나 이상의 APPEND 명령 후에 NOOP 명령을 발행할 수 있습니다.

서버가 메일박스 이름을 변환\(정규화\)하기로 결정한 경우, OLDNAME 확장 데이터 항목이 포함된 태그 없는 LIST를 반환해야 하며, OLDNAME 값은 제공된 메일박스 이름이고 name 매개변수는 정규화된 메일박스 이름입니다.  \(자세한 내용은 섹션 6.3.9.7을 참조하세요.\)

```text
   Example:

     C: A003 APPEND saved-messages (\Seen) {326}
     S: + Ready for literal data
     C: Date: Mon, 7 Feb 1994 21:52:25 -0800 (PST)
     C: From: Fred Foobar <foobar@Blurdybloop.example>
     C: Subject: afternoon meeting
     C: To: mooch@owatagu.siam.edu.example
     C: Message-Id: <B27397-0100000@Blurdybloop.example>
     C: MIME-Version: 1.0
     C: Content-Type: TEXT/PLAIN; CHARSET=US-ASCII
     C:
     C: Hello Joe, do you think we can meet at 3:30 tomorrow?
     C:
     S: A003 OK APPEND completed

   Example:

     C: A003 APPEND saved-messages (\Seen) {297+}
     C: Date: Mon, 7 Feb 1994 21:52:25 -0800 (PST)
     C: From: Fred Foobar <foobar@example.com>
     C: Subject: afternoon meeting
     C: To: mooch@example.com
     C: Message-Id: <B27397-0100000@example.com>
     C: MIME-Version: 1.0
     C: Content-Type: TEXT/PLAIN; CHARSET=US-ASCII
     C:
     C: Hello Joe, do you think we can meet at 3:30 tomorrow?
     C:
     S: A003 OK [APPENDUID 38505 3955] APPEND completed
     C: A004 COPY 2:4 meeting
     S: A004 OK [COPYUID 38505 304,319:320 3956:3958] Done
     C: A005 UID COPY 305:310 meeting
     S: A005 OK No matching messages, so nothing copied
     C: A006 COPY 2 funny
     S: A006 OK Done
     C: A007 SELECT funny
     S: * 1 EXISTS
     S: * OK [UIDVALIDITY 3857529045] Validity session-only
     S: * OK [UIDNEXT 2] Predicted next UID
     S: * NO [UIDNOTSTICKY] Non-persistent UIDs
     S: * FLAGS (\Answered \Flagged \Deleted \Seen \Draft)
     S: * OK [PERMANENTFLAGS (\Deleted \Seen)] Limited
     S: * LIST () "." funny
     S: A007 OK [READ-WRITE] SELECT completed
```

이 예에서 A003 및 A004는 메시지에 할당된 UID를 반환하는 사서함에 성공적으로 추가하고 복사하는 것을 보여줍니다. A005는 메시지가 복사되지 않은 예입니다. 이는 A003에서 메시지 2의 UID가 304이고 메시지 3의 UID가 319임을 알 수 있기 때문입니다. 따라서 UID 305\~310은 존재하지 않습니다\(자세한 설명은 섹션 2.3.1.1 참조\).  A006은 COPYUID를 반환하지 않은 복사 중인 메시지의 예입니다. 그리고 예상대로 A007은 해당 사서함이 포함된 메일 ​​저장소가 영구 UID를 지원하지 않음을 보여줍니다.

- |  참고: APPEND 명령은 메시지 전달에 사용되지 않습니다. |  \[SMTP\]를 전송하는 메커니즘을 제공하지 않기 때문입니다 |  봉투 정보.

---
#### **6.3.13.  IDLE Command**

```text
   Arguments:    none

   Responses:    continuation data will be requested; the client sends
                 the continuation data "DONE" to end the command

   Result:       OK -  IDLE completed after client sent "DONE"
                 NO -  failure: the server will not allow the IDLE
                    command at this time
                 BAD -  command unknown or arguments invalid
```

IDLE 명령이 없으면 클라이언트는 선택한 사서함에 대한 변경 사항\(새 메일, 삭제 및 플래그 변경\)을 위해 서버를 폴링해야 합니다.  서버가 업데이트를 클라이언트에 실시간으로 전송하도록 하는 것이 더 바람직한 경우가 많습니다.  이를 통해 사용자는 새 메일을 즉시 볼 수 있습니다.  IDLE 명령을 사용하면 클라이언트는 실시간 업데이트를 받아들일 준비가 되었음을 서버에 알릴 수 있습니다.

IDLE 명령은 클라이언트가 원치 않는 업데이트 메시지를 수락할 준비가 되면 클라이언트에서 서버로 전송됩니다.  서버는 연속\("+"\) 응답을 사용하여 IDLE 명령에 대한 응답을 요청합니다.  IDLE 명령은 클라이언트가 연속에 응답할 때까지 활성 상태로 유지되며, IDLE 명령이 활성 상태인 한 서버는 이제 언제든지 태그가 지정되지 않은 EXISTS, EXPUNGE, FETCH 및 기타 응답을 자유롭게 보낼 수 있습니다.  서버가 원치 않는 FETCH 응답을 보내기로 선택한 경우 UID FETCH 항목을 포함해야 합니다.

IDLE 명령은 클라이언트로부터 "DONE" 연속을 수신하면 종료됩니다. 이러한 응답은 서버의 계속 요청을 만족시킵니다.  이 시점에서 서버는 대기열에 남아 있는 태그가 지정되지 않은 나머지 응답을 보낼 수 있으며 그런 다음 IDLE 명령에 태그가 지정된 응답을 즉시 보내고 다른 명령을 처리할 준비를 해야 합니다.  다른 명령의 경우, 새 명령을 처리하면 모호성 제한에 따라 원치 않는 태그 없는 응답이 전송될 수 있습니다.  클라이언트는 서버가 DONE을 기다리는 동안 명령을 보내면 안 됩니다. 서버는 명령을 연속과 구별할 수 없기 때문입니다.

서버는 IDLE 명령이 실행 중인 경우 클라이언트를 비활성 상태로 간주할 수 있으며, 해당 서버에 비활성 시간 초과가 있는 경우 시간 초과 기간이 끝나면 암묵적으로 클라이언트를 로그오프할 수 있습니다.  따라서 IDLE을 사용하는 클라이언트는 로그오프를 방지하기 위해 IDLE을 종료하고 최소한 29분마다 다시 실행하는 것이 좋습니다.  이를 통해 클라이언트는 30분 간격으로 "폴링"만 필요하더라도 즉시 사서함 업데이트를 받을 수 있습니다.

```text
   Example:

     C: A001 SELECT INBOX
     S: * FLAGS (\Deleted \Seen \Flagged)
     S: * OK [PERMANENTFLAGS (\Deleted \Seen \Flagged)] Limited
     S: * 3 EXISTS
     S: * OK [UIDVALIDITY 1]
     S: * OK [UIDNEXT 1]
     S: * LIST () "/" INBOX
     S: A001 OK [READ-WRITE] SELECT completed
     C: A002 IDLE
     S: + idling
     ...time passes; new mail arrives...
     S: * 4 EXISTS
     C: DONE
     S: A002 OK IDLE terminated
     ...another client expunges message 2 now...
     C: A003 FETCH 4 ALL
     S: * 4 FETCH (...)
     S: A003 OK FETCH completed
     C: A004 IDLE
     S: * 2 EXPUNGE
     S: * 3 EXISTS
     S: + idling
     ...time passes; another client expunges message 3...
     S: * 3 EXPUNGE
     S: * 2 EXISTS
     ...time passes; new mail arrives...
     S: * 3 EXISTS
     C: DONE
     S: A004 OK IDLE terminated
     C: A005 FETCH 3 ALL
     S: * 3 FETCH (...)
     S: A005 OK FETCH completed
     C: A006 IDLE
```

---
### **6.4.  Client Commands - Selected State**

선택된 상태에서는 메일함의 메시지를 조작하는 명령이 허용됩니다.

범용 명령\(CAPABILITY, NOOP 및 LOGOUT\)과 인증된 상태 명령\(SELECT, EXAMINE, NAMESPACE, CREATE, DELETE, RENAME, SUBSCRIBE, UNSUBSCRIBE, LIST, STATUS 및 APPEND\) 외에도 다음 명령이 유효합니다. 선택된 상태: CLOSE, UNSELECT, EXPUNGE, SEARCH, FETCH, STORE, COPY, MOVE 및 UID.

---
#### **6.4.1.  CLOSE Command**

```text
   Arguments:    none
```

응답: 이 명령에 대한 특정 응답이 없습니다.

```text
   Result:       OK -  close completed, now in authenticated state
                 BAD -  command unknown or arguments invalid
```

CLOSE 명령은 현재 선택한 사서함에서 \Deleted 플래그가 설정된 모든 메시지를 영구적으로 제거하고 선택한 상태에서 인증된 상태로 돌아갑니다.  태그가 지정되지 않은 EXPUNGE 응답은 전송되지 않습니다.

사서함이 EXAMINE 명령으로 선택되거나 읽기 전용으로 선택된 경우 메시지가 제거되지 않으며 오류가 발생하지 않습니다.

사서함을 선택한 경우에도 이전에 CLOSE 명령을 실행하지 않고 SELECT, EXAMINE 또는 LOGOUT 명령을 실행할 수 있습니다.  SELECT, EXAMINE 및 LOGOUT 명령은 삭제를 수행하지 않고 현재 선택된 편지함을 암시적으로 닫습니다.  그러나 많은 메시지가 삭제되면 태그가 지정되지 않은 EXPUNGE 응답\(클라이언트가 무시할 수 있음\)이 전송되지 않기 때문에 CLOSE-LOGOUT 또는 CLOSE-SELECT 시퀀스가 ​​EXPUNGE-LOGOUT 또는 EXPUNGE-SELECT보다 상당히 빠릅니다.

```text
   Example:

     C: A341 CLOSE
     S: A341 OK CLOSE completed
```

---
#### **6.4.2.  UNSELECT Command**

```text
   Arguments:    none
```

응답: 이 명령에 대한 특정 응답이 없습니다.

```text
   Result:       OK -  unselect completed, now in authenticated state
                 BAD -  no mailbox selected, or argument supplied but
                    none permitted
```

UNSELECT 명령은 선택한 사서함과 연결된 세션 리소스를 해제하고 서버를 인증된 상태로 되돌립니다. 이 명령은 현재 선택한 사서함에서 메시지가 영구적으로 제거되지 않는다는 점을 제외하고 CLOSE와 동일한 작업을 수행합니다.

```text
   Example:

     C: A342 UNSELECT
     S: A342 OK Unselect completed
```

---
#### **6.4.3.  EXPUNGE Command**

```text
   Arguments:    none

   Responses:    untagged responses:  EXPUNGE

   Result:       OK -  expunge completed
                 NO -  expunge failure: can't expunge (e.g., permission
                    denied)
                 BAD -  command unknown or arguments invalid
```

EXPUNGE 명령은 현재 선택한 사서함에서 \Deleted 플래그가 설정된 모든 메시지를 영구적으로 제거합니다.  클라이언트에 확인을 반환하기 전에 제거된 각 메시지에 대해 태그가 지정되지 않은 EXPUNGE 응답이 전송됩니다.

```text
   Example:

     C: A202 EXPUNGE
     S: * 3 EXPUNGE
     S: * 3 EXPUNGE
     S: * 5 EXPUNGE
     S: * 8 EXPUNGE
     S: A202 OK EXPUNGE completed
```

참고: 이 예에서 메시지 3, 4, 7 및 11에는 \Deleted 플래그가 설정되어 있습니다.  자세한 설명은 말소 대응 설명\(섹션 7.5.1\)을 참조하세요.

---
#### **6.4.4.  SEARCH Command**

```text
   Arguments:    OPTIONAL result specifier

                 OPTIONAL [CHARSET] specification
```

- 검색 기준\(하나 이상\)

```text
   Responses:    OPTIONAL untagged response:  ESEARCH

   Result:       OK -  search completed
                 NO -  search error: can't search that [CHARSET] or
                    criteria
                 BAD -  command unknown or arguments invalid
```

SEARCH 명령은 사서함에서 지정된 검색 기준과 일치하는 메시지를 검색합니다.

SEARCH 명령에는 결과 옵션이 포함될 수 있습니다.  결과 옵션은 태그가 지정되지 않은 ESEARCH 응답에서 검색 기준과 일치하는 메시지에 대해 어떤 종류의 정보가 반환되는지 제어합니다.  결과 옵션이 지정되지 않거나 빈 옵션 목록이 "\(\)"로 지정된 경우 ALL이 가정됩니다\(아래 참조\).  개별 옵션의 순서는 임의적입니다.  개별 옵션에는 괄호 안에 매개변수가 포함될 수 있습니다.  \(그러나 옵션에 항상 숫자나 시퀀스 세트로 표시될 수 있는 필수 매개변수가 있는 경우 옵션 매개변수에는 괄호가 필요하지 않습니다. 자세한 내용은 "형식 구문"\(섹션 9\)을 참조하세요.\) 옵션에는 매개변수가 있으며, 이는 특정 순서의 원자 및/또는 문자열 및/또는 목록으로 구성됩니다.  서버가 지원하는 확장으로 정의되지 않은 모든 옵션은 BAD 응답으로 거부되어야 합니다.

IMAP4rev1은 ESEARCH 응답 대신 SEARCH 응답 \[RFC3501\]을 사용했습니다.  IMAP4rev2만 지원하는 클라이언트는 SEARCH 응답을 무시해야 합니다.

이 문서에서는 다음 결과 옵션을 지정합니다.

MIN - 검색 기준을 충족하는 가장 낮은 메시지 번호/UID를 반환합니다.

- 검색 결과 일치 항목이 없으면 서버는 ESEARCH 응답에 MIN 결과 옵션을 포함해서는 안 됩니다. 그러나 여전히 ESEARCH 응답을 보내야 합니다.

MAX - 검색 기준을 충족하는 가장 높은 메시지 번호/UID를 반환합니다.

- SEARCH 결과가 일치하지 않으면 서버는 ESEARCH 응답에 MAX 결과 옵션을 포함해서는 안 됩니다. 그러나 여전히 ESEARCH 응답을 보내야 합니다.

ALL - 시퀀스 세트 구문을 사용하여 검색 기준을 충족하는 모든 메시지 번호/UID를 반환합니다.  클라이언트는 메시지/UID가 특정 순서로 나열될 것이라고 가정해서는 안 됩니다.

- SEARCH 결과가 일치하지 않으면 서버는 ESEARCH 응답에 ALL 결과 옵션을 포함해서는 안 됩니다. 그러나 여전히 ESEARCH 응답을 보내야 합니다.

COUNT - 검색 기준을 만족하는 메시지 수를 반환합니다. 이 결과 옵션은 항상 ESEARCH 응답에 포함되어야 합니다.

SAVE - 이 옵션은 서버가 SEARCH 또는 UID SEARCH 명령\(SEARCH 기반 명령\(예: SORT 및 THREAD \[RFC5256\]\)\)의 결과를 기억하고 이를 우리가 참조할 내부 변수에 저장하도록 지시합니다. "검색 결과 변수". 클라이언트는 "$" 표시를 사용하여 이 내부 변수의 내용을 참조할 수 있습니다.  서버가 이를 검색 결과 변수의 메시지 목록으로 대체해야 함을 나타내기 위해 메시지 시퀀스나 UID 시퀀스 대신 "$" 표시를 사용할 수 있습니다.  따라서 클라이언트는 최근 기억된 SEARCH 명령의 결과를 다른 명령의 매개변수로 사용할 수 있습니다.  검색 결과 변수의 값이 결정되는 방법, 실행된 다른 명령이 이 값에 미치는 영향, SAVE 반환 옵션이 다른 반환 옵션과 상호 작용하는 방법에 대한 자세한 내용은 섹션 6.4.4.1을 참조하세요.

- 다른 SEARCH 결과 옵션이 없으면 SAVE 결과 옵션은 SEARCH 명령에 의해 반환되었을 ESEARCH 응답도 억제합니다.

참고: 이 문서의 향후 확장을 통해 서버는 단일 확장 SEARCH 명령에 대해 여러 ESEARCH 응답을 반환할 수 있습니다. 그러나 위에 지정된 모든 옵션은 단독으로 또는 조합하여 사용되는 경우 단일 ESEARCH 응답을 생성해야 합니다.  이 보장은 IMAP4rev2 클라이언트의 처리를 단순화합니다.  이 제한을 완화하는 향후 SEARCH 확장은 여러 ESEARCH 응답의 결과를 결합하는 방법을 설명해야 합니다.

검색 기준은 하나 이상의 검색 키로 구성됩니다.

여러 키가 지정된 경우 결과는 해당 키와 일치하는 모든 메시지의 교집합\(AND 함수\)입니다.  예를 들어 DELETED FROM "SMITH" SINCE 1-2-1994는 INTERNALDATE가 1994년 2월 1일 이후인 Smith에서 삭제된 모든 메시지를 나타냅니다. 검색 키는 하나 이상의 검색 키를 괄호로 묶은 목록일 수도 있습니다\(예: OR 및 NOT 키와 함께 사용\).

서버 구현은 TEXT 및 MESSAGE 이외의 터미널 콘텐츠 미디어 유형이 있는 \[MIME-IMB\] 본문 부분을 검색 일치 고려 사항에서 제외할 수 있습니다.

OPTIONAL \[CHARSET\] 사양은 "CHARSET"이라는 단어와 그 뒤에 나오는 레지스트리 \[CHARSET-REG\]의 문자 집합 이름으로 구성됩니다.  검색기준에 나타나는 문자열의 \[CHARSET\]을 나타냅니다.  \[MIME-IMB\] 콘텐츠 전송 인코딩과 \[RFC5322\]/\[MIME-IMB\] 헤더의 \[MIME-HDRS\] 문자열은 텍스트를 비교하기 전에 디코딩되어야 합니다.  서버는 US-ASCII 및 UTF-8 문자 세트를 지원해야 합니다. 다른 CHARSET도 지원될 수 있습니다.  클라이언트는 UTF-8을 사용해야 합니다. CHARSET이 제공되지 않으면 IMAP4rev2 서버는 UTF-8을 가정해야 하므로 CHARSET UTF-8을 선택하는 것은 중복됩니다.  기존 IMAP4rev1 클라이언트와의 향상된 호환성을 위해 허용됩니다.

서버가 지정된 \[CHARSET\]을 지원하지 않는 경우 태그가 지정된 NO 응답\(BAD가 아님\)을 반환해야 합니다.  이 응답에는 서버가 지원하는 CHARSET을 나열할 수 있는 BADCHARSET 응답 코드가 포함되어야 합니다.

문자열을 사용하는 모든 검색 키에서 달리 지정하지 않는 한 문자열이 연결된 텍스트의 하위 문자열인 경우 메시지는 키와 일치합니다.  일치는 ASCII 범위 내의 문자에 대해 대소문자를 구분하지 않아야 합니다\(SHOULD\).  언어를 구분하고 대소문자를 구분하지 않고 검색하려면 \[IMAP-I18N\]을 사용하는 것이 좋습니다.  빈 문자열은 하위 문자열입니다. 이는 메시지에 헤더 필드가 있는지 테스트하기 위해 HEADER 검색을 수행할 때 유용합니다.

정의된 검색 키는 다음과 같습니다.  인수의 정확한 구문 정의는 "형식 구문"\(섹션 9\)을 참조하세요.

<시퀀스 세트\> - 지정된 메시지 시퀀스 번호 세트에 해당하는 메시지 시퀀스 번호가 있는 메시지입니다.

ALL - 사서함의 모든 메시지. ANDing의 기본 초기 키입니다.

ANSWERED - \Answered 플래그가 설정된 메시지입니다.

BCC <string\> - 봉투 구조의 BCC\(Blind Carbon Copy\) 필드에 지정된 문자열을 포함하는 메시지입니다.

BEFORE <date\> - 내부 날짜\(시간 및 시간대 무시\)가 지정된 날짜보다 이전인 메시지입니다.

BODY <string\> - 메시지 본문에 지정된 문자열이 포함된 메시지입니다.  TEXT\(아래 참조\)와 달리 헤더 필드와 일치하지 않습니다.  서버는 이 검색 키에 대해 유연한 일치를 구현할 수 있습니다. 예를 들어 "swim"을 영어 텍스트의 "swam" 및 "swum" 모두에 일치시키거나 전체 단어 일치만 수행하여\(여기서 "swim"은 "swimming"과 일치하지 않음\) \).

CC <string\> - 봉투 구조의 CC 필드에 지정된 문자열을 포함하는 메시지입니다.

DELETED - \Deleted 플래그가 설정된 메시지입니다.

DRAFT - \Draft 플래그가 설정된 메시지입니다.

FLAGGED - \Flagged 플래그가 설정된 메시지입니다.

FROM <string\> - 봉투 구조의 FROM 필드에 지정된 문자열이 포함된 메시지입니다.

HEADER <field-name\> <string\> - 지정된 field-name\(\[RFC5322\]에 정의됨\)이 있는 헤더 필드가 있고 헤더 필드의 텍스트에 지정된 문자열\(콜론 뒤에 오는 내용\)이 포함된 메시지 .  검색할 문자열의 길이가 0인 경우 내용에 관계없이 지정된 field-name을 갖는 헤더 필드가 있는 모든 메시지와 일치합니다.  클라이언트가 최종 사용자가 시작하지 않은 자동 처리에 사용할 수 있으므로 서버는 이 검색 항목에 대해 하위 문자열 검색을 사용해야 합니다.  예를 들어 정확해야 하는 Message-ID 또는 Content-Type 헤더 필드 값을 검색할 때 또는 IMAP 서버가 전혀 알지 못할 수 있는 헤더 필드에서 검색할 때 사용할 수 있습니다.

KEYWORD <플래그\> - 지정된 키워드 플래그가 설정된 메시지입니다.

큰 <n\> - RFC822.SIZE가 지정된 옥텟 수보다 큰 메시지입니다.

NOT <검색 키\> - 지정된 검색 키와 일치하지 않는 메시지입니다.

ON <date\> - 내부 날짜\(시간 및 시간대 무시\)가 지정된 날짜 내에 있는 메시지입니다.

OR <search-key1\> <search-key2\> - 검색 키와 일치하는 메시지입니다.

SEEN - \Seen 플래그가 설정된 메시지입니다.

SENTBEFORE <날짜\> - \[RFC5322\] 날짜: 헤더 필드\(시간 및 시간대 무시\)가 지정된 날짜보다 이전인 메시지입니다.

SENTON <date\> - \[RFC5322\] Date: 헤더 필드\(시간 및 시간대 무시\)가 지정된 날짜 내에 있는 메시지입니다.

SENTSINCE <날짜\> - \[RFC5322\] 날짜: 헤더 필드\(시간 및 시간대 무시\)가 지정된 날짜 이내이거나 이후인 메시지입니다.

SINCE <date\> - 내부 날짜\(시간 및 시간대 무시\)가 지정된 날짜 이내이거나 이후인 메시지입니다.

SMALLER <n\> - RFC822.SIZE가 지정된 옥텟 수보다 작은 메시지입니다.

SUBJECT <string\> - 봉투 구조의 SUBJECT 필드에 지정된 문자열이 포함된 메시지입니다.

TEXT <string\> - 헤더\(MIME 헤더 필드 포함\) 또는 메시지 본문에 지정된 문자열이 포함된 메시지입니다.  서버는 이 검색 키에 대해 유연한 일치를 구현할 수 있습니다. 예를 들어 영어 텍스트의 "swam" 및 "swum" 모두에 "swim"을 일치시키거나 전체 단어 일치만 수행합니다\(여기서 "swim"은 "swimming"과 일치하지 않음\). \).

TO <string\> - 봉투 구조의 TO 필드에 지정된 문자열을 포함하는 메시지입니다.

UID <시퀀스 세트\> - 지정된 고유 식별자 세트에 해당하는 고유 식별자가 있는 메시지입니다.  시퀀스 집합 범위가 허용됩니다.

UNANSWERED - \Answered 플래그가 설정되지 않은 메시지입니다.

UNDELETED - \Deleted 플래그가 설정되지 않은 메시지입니다.

UNDRAFT - \Draft 플래그가 설정되지 않은 메시지입니다.

UNFLAGGED - \Flagged 플래그가 설정되지 않은 메시지입니다.

UNKEYWORD <플래그\> - 지정된 키워드 플래그가 설정되지 않은 메시지입니다.

UNSEEN - \Seen 플래그가 설정되지 않은 메시지입니다.

```text
   Example:

     C: A282 SEARCH RETURN (MIN COUNT) FLAGGED
         SINCE 1-Feb-1994 NOT FROM "Smith"
     S: * ESEARCH (TAG "A282") MIN 2 COUNT 3
     S: A282 OK SEARCH completed

   Example:

     C: A283 SEARCH RETURN () FLAGGED
         SINCE 1-Feb-1994 NOT FROM "Smith"
     S: * ESEARCH (TAG "A283") ALL 2,10:11
     S: A283 OK SEARCH completed

   Example:

     C: A284 SEARCH TEXT "string not in mailbox"
     S: * ESEARCH (TAG "A284")
     S: A284 OK SEARCH completed
     C: A285 SEARCH CHARSET UTF-8 TEXT {12}
     S: + Ready for literal text
     C: отпуск
     S: * ESEARCH (TAG "A285") ALL 43
     S: A285 OK SEARCH completed
```

다음 예에서는 사서함에서 확인되지 않은 첫 번째 메시지를 찾는 방법을 보여줍니다.

```text
   Example:

     C: A284 SEARCH RETURN (MIN) UNSEEN
     S: * ESEARCH (TAG "A284") MIN 4
     S: A284 OK SEARCH completed
```

다음 예에서는 ESEARCH UID 표시기가 있는 경우 ESEARCH 응답의 모든 데이터가 UID를 참조하고 있음을 보여줍니다. 예를 들어 MIN 결과 지정자 뒤에는 UID가 옵니다.

```text
   Example:

     C: A285 UID SEARCH RETURN (MIN MAX) 1:5000
     S: * ESEARCH (TAG "A285") UID MIN 7 MAX 3800
     S: A285 OK SEARCH completed
```

다음 예에서는 삭제된 메시지 수를 반환하는 방법을 보여줍니다.

```text
   Example:

     C: A286 SEARCH RETURN (COUNT) DELETED
     S: * ESEARCH (TAG "A286") COUNT 15
     S: A286 OK SEARCH completed
```

---
##### **6.4.4.1.  SAVE Result Option and SEARCH Result Variable**

SELECT 또는 EXAMINE 명령이 성공적으로 완료되면\(태그된 OK 응답 후\) 현재 검색 결과 변수가 빈 시퀀스로 재설정됩니다.

SAVE 결과 옵션이 포함된 성공적인 SEARCH 명령은 검색 결과 변수의 값을 SEARCH 명령에서 찾은 메시지 목록으로 설정합니다.  예를 들어, 메시지가 발견되지 않으면 검색 결과 변수에 빈 시퀀스가 ​​포함됩니다.

다음 SEARCH 명령은 검색 결과 변수를 변경해서는 안 됩니다.

- 서버가 BAD 태그가 지정된 응답을 반환하도록 하는 SEARCH 명령,

- SAVE 결과 옵션이 없는 SEARCH 명령으로 인해 서버가 NO 태그 응답을 반환하게 되었습니다.

- SAVE 결과 옵션이 없는 성공적인 SEARCH 명령.

서버가 NO 태그 응답을 반환하도록 하는 SAVE 결과 옵션이 포함된 SEARCH 명령은 검색 결과 변수의 값을 빈 시퀀스로 설정합니다.

검색결과 변수에 나열된 메시지가 말소되면 목록에서 자동으로 제거됩니다.  구현자는 서버가 목록을 메시지 번호 목록으로 저장하는 경우 섹션 7.5.1에 ​​설명된 대로 삭제된 메시지에 대해 클라이언트에 알릴 때 서버가 목록을 자동으로 조정해야 한다는 점을 기억해야 합니다.

사서함이 열려 있는 동안 서버가 새 UIDVALIDITY 값을 보내기로 결정하면 검색 변수가 빈 시퀀스로 재설정됩니다.

"$" 표시에 빈 메시지 시퀀스가 ​​포함되어 있더라도 메시지 세트를 매개변수로 받아들이는 모든 명령에서는 유효하지만 일치하지 않는 메시지 목록으로 처리해야 합니다.  예를 들어, "FETCH $" 명령은 태그가 지정된 OK 응답을 반환하고 FETCH 응답은 반환하지 않습니다.  섹션 6.4.4.4의 예제 5도 참조하세요.

SAVE 결과 옵션은 서버가 MIN, MAX, ALL 또는 COUNT 결과 옵션에 해당하는 항목을 반환하는지 여부를 변경하지 않습니다.

SAVE 결과 옵션이 MIN 또는 MAX 결과 옵션과 결합되고 ALL 및 COUNT 결과 옵션이 모두 없는 경우 해당 MIN/MAX가 반환되지만\(검색 결과가 비어 있지 않은 경우\) "$" 표시에는 다음이 포함됩니다. MIN/MAX 반환 항목에 단일 메시지가 반환됩니다.

SAVE 결과 옵션이 MIN 및 MAX 결과 옵션과 결합되고 ALL 및 COUNT 결과 옵션이 모두 없는 경우 "$" 표시에는 MIN/MAX 반환 항목에 반환된 메시지 0개, 메시지 1개 또는 메시지 2개가 포함됩니다. .

SAVE 결과 옵션이 ALL 및/또는 COUNT 결과 옵션과 결합된 경우 "$" 표시에는 항상 SEARCH 또는 UID SEARCH 명령으로 찾은 모든 메시지가 포함됩니다.

다음 표에는 이 섹션에 설명된 ESEARCH 서버 구현에 대한 추가 요구 사항이 요약되어 있습니다.

```text
           +==============================+====================+
           | Combination of Result Option |  "$" Marker Value  |
           +==============================+====================+
           |           SAVE MIN           |        MIN         |
           +------------------------------+--------------------+
           |           SAVE MAX           |        MAX         |
           +------------------------------+--------------------+
           |         SAVE MIN MAX         |     MIN & MAX      |
           +------------------------------+--------------------+
           |          SAVE * [m]          | all found messages |
           +------------------------------+--------------------+

                                  Table 4
```

여기서 '\*'는 "ALL" 및/또는 "COUNT"를 의미하고 '\[m\]'은 선택적인 "MIN" 및/또는 "MAX"를 의미합니다.

구현 참고 사항: 서버 구현자는 "$"가 사용되는 컨텍스트에 따라 IMAP 메시지 시퀀스 또는 UID 시퀀스를 참조할 수 있다는 점에 유의해야 합니다.  예를 들어 "$" 표시는 SEARCH\(SAVE\) 명령의 결과로 설정되어 UID FETCH 명령\(메시지 시퀀스가 ​​아닌 UID 시퀀스를 허용함\)에 대한 매개변수로 사용되거나 "$" 표시로 사용될 수 있습니다. UID SEARCH\(SAVE\) 명령의 결과로 설정될 수 있으며 FETCH 명령\(UID 시퀀스가 ​​아닌 메시지 시퀀스를 허용함\)에 대한 매개변수로 사용될 수 있습니다.  서버 구현은 "$" 표시가 사용되는 컨텍스트에 따라 "$" 표시 값을 메시지 번호 또는 UID에 자동으로 매핑해야 합니다.

---
##### **6.4.4.2.  Multiple Commands in Progress**

SEARCH RETURN\(SAVE\) 명령을 사용하고 "$" 표시를 사용하는 명령을 사용하면 두 명령 사이에 직접적인 종속성이 생성됩니다.  섹션 5.5의 지시에 따라 서버는 수신된 순서대로 두 명령을 실행해야 합니다.

클라이언트는 섹션 5.5에 설명된 대로 모호성을 생성하지 않는 한 "$" 표시를 사용하는 하나 이상의 명령으로 SEARCH RETURN\(SAVE\) 명령을 파이프라인할 수 있습니다.  섹션 6.4.4.4의 예제 7-9에서는 이에 대해 더 자세히 설명합니다.

---
##### **6.4.4.3.  Refusing to Save Search Results**

경우에 따라 서버는 검색\(SAVE\) 결과 저장을 거부할 수 있습니다\(예: 저장된 결과 수가 내부 제한에 도달한 경우\).  이 경우 서버는 섹션 6.4.4.1에 설명된 대로 NOTSAVED 응답 코드가 포함된 태그된 NO 응답을 반환하고 검색 결과 변수를 빈 시퀀스로 설정해야 합니다.

---
##### **6.4.4.4.  Examples Showing Use of the SAVE Result Option**

이 섹션에서만: //로 시작하는 예제의 설명 주석은 프로토콜의 일부가 아닙니다.

1. 다음 예에서는 클라이언트가 SEARCH 명령의 결과를 사용하여 관심 있는 메시지의 헤더를 FETCH하는 방법을 보여줍니다.

```text
       Example 1:

        C: A282 SEARCH RETURN (SAVE) FLAGGED SINCE 1-Feb-1994
            NOT FROM "Smith"
        S: A282 OK SEARCH completed, result saved
        C: A283 FETCH $ (UID INTERNALDATE FLAGS BODY.PEEK[HEADER])
        S: * 2 FETCH (UID 14 ...
        S: * 84 FETCH (UID 100 ...
        S: * 882 FETCH (UID 1115 ...
        S: A283 OK completed
```

- 클라이언트는 다음 두 명령을 파이프라인할 수도 있습니다.

```text
       Example 2:

        C: A282 SEARCH RETURN (SAVE) FLAGGED SINCE 1-Feb-1994
            NOT FROM "Smith"
        C: A283 FETCH $ (UID INTERNALDATE FLAGS BODY.PEEK[HEADER])
        S: A282 OK SEARCH completed
        S: * 2 FETCH (UID 14 ...
        S: * 84 FETCH (UID 100 ...
        S: * 882 FETCH (UID 1115 ...
        S: A283 OK completed
```

1. 다음 예에서는 한 SEARCH 명령의 결과가 다른 SEARCH 명령의 입력으로 사용될 수 있음을 보여줍니다.

```text
       Example 3:

        C: A300 SEARCH RETURN (SAVE) SINCE 1-Jan-2004
            NOT FROM "Smith"
        S: A300 OK SEARCH completed
        C: A301 UID SEARCH UID $ SMALLER 4096
        S: * ESEARCH (TAG "A301") UID ALL 17,900,901
        S: A301 OK completed
```

- 예제 3의 두 번째 명령은 다음으로 대체될 수 있습니다.

```text
        C: A301 UID SEARCH $ SMALLER 4096
```

- 명령의 결과는 동일합니다.

1. 다음 예에서는 OR SEARCH 기준을 사용하여 "$" 표시를 다른 메시지 번호와 결합할 수 있음을 보여줍니다.

```text
       Example 4:

        C: P282 SEARCH RETURN (SAVE) SINCE 1-Feb-1994
            NOT FROM "Smith"
        S: P282 OK SEARCH completed
        C: P283 SEARCH CHARSET UTF-8 (OR $ 1,3000:3021) TEXT {8+}
        C: мать
        S: * ESEARCH (TAG "P283") ALL 882,1102,3003,3005:3006
        S: P283 OK completed
```

1. 다음 예에서는 실패한 SEARCH가 검색 결과 변수를 빈 목록으로 설정하는 것을 보여줍니다.  서버는 KOI8-R 문자셋을 구현하지 않습니다.

```text
       Example 5:

        C: B282 SEARCH RETURN (SAVE) SINCE 1-Feb-1994
            NOT FROM "Smith"
        S: B282 OK SEARCH completed
        C: B283 SEARCH RETURN (SAVE) CHARSET KOI8-R
            (OR $ 1,3000:3021) TEXT {4}
        C: XXXX
        S: B283 NO [BADCHARSET UTF-8] KOI8-R is not supported
       //After this command, the saved result variable contains
       //no messages.  A client that wants to reissue the B283
       //SEARCH command with another CHARSET would have to reissue
       //the B282 command as well.  One possible workaround for
       //this is to include the desired CHARSET parameter
       //in the earliest SEARCH RETURN (SAVE) command in a
       //sequence of related SEARCH commands, to cause
       //the earliest SEARCH in the sequence to fail.
       //A better approach might be to always use CHARSET UTF-8
       //instead.
```

- 참고: 이 문서 형식은 7비트 ASCII 텍스트로 제한되어 있으므로 실제 KOI8-R 데이터를 표시할 수 없습니다.  "XXXX"는 실제 트랜잭션에서 4옥텟의 8비트 데이터에 대한 자리 표시자입니다.

1. 다음 예는 메시지가 없을 때 "$" 표시를 사용하는 것이 오류가 아님을 보여줍니다.

```text
       Example 6:

        C: E282 SEARCH RETURN (SAVE) SINCE 28-Oct-2006
            NOT FROM "Eric"
        C: E283 COPY $ "Other Messages"
       //The "$" contains no messages
        S: E282 OK SEARCH completed
        S: E283 OK COPY completed, nothing copied

       Example 7:

        C: F282 SEARCH RETURN (SAVE) KEYWORD $Junk
        C: F283 COPY $ "Junk"
        C: F284 STORE $ +FLAGS.Silent (\Deleted)
        S: F282 OK SEARCH completed
        S: F283 OK COPY completed
        S: F284 OK STORE completed

       Example 8:

        C: G282 SEARCH RETURN (SAVE) KEYWORD $Junk
        C: G283 SEARCH RETURN (ALL) SINCE 28-Oct-2006
            FROM "Eric"
       // The server can execute the two SEARCH commands
       // in any order, as they don't have any dependency.
       // For example, it may return:
        S: * ESEARCH (TAG "G283") ALL 3:15,27,29:103
        S: G283 OK SEARCH completed
        S: G282 OK SEARCH completed
```

- 다음 예에서는 두 번째 SEARCH RETURN\(SAVE\) 결과가 항상 첫 번째 결과보다 우선함을 보여줍니다.

```text
       Example 9:

        C: H282 SEARCH RETURN (SAVE) KEYWORD $Junk
        C: H283 SEARCH RETURN (SAVE) SINCE 28-Oct-2006
            FROM "Eric"
        S: H282 OK SEARCH completed
        S: H283 OK SEARCH completed
       // At this point "$" would contain results of H283
```

- 다음 예에서는 ESEARCH 결과 옵션의 다양한 조합에 대한 동작 차이를 보여줍니다.

```text
       Example 10:

        C: C282 SEARCH RETURN (ALL) SINCE 12-Feb-2006
            NOT FROM "Smith"
        S: * ESEARCH (TAG "C283") ALL 2,10:15,21
      //$ value hasn't changed
        S: C282 OK SEARCH completed

        C: C283 SEARCH RETURN (ALL SAVE) SINCE 12-Feb-2006
            NOT FROM "Smith"
        S: * ESEARCH (TAG "C283") ALL 2,10:15,21
      //$ value is 2,10:15,21
        S: C283 OK SEARCH completed

        C: C284 SEARCH RETURN (SAVE MIN) SINCE 12-Feb-2006
            NOT FROM "Smith"
        S: * ESEARCH (TAG "C284") MIN 2
      //$ value is 2
        S: C284 OK SEARCH completed

        C: C285 SEARCH RETURN (MAX SAVE MIN) SINCE
            12-Feb-2006 NOT FROM "Smith"
        S: * ESEARCH (TAG "C285") MIN 2 MAX 21
      //$ value is 2,21
        S: C285 OK SEARCH completed

        C: C286 SEARCH RETURN (MAX SAVE MIN COUNT)
            SINCE 12-Feb-2006 NOT FROM "Smith"
        S: * ESEARCH (TAG "C286") MIN 2 MAX 21 COUNT 8
      //$ value is 2,10:15,21
        S: C286 OK SEARCH completed

        C: C286 SEARCH RETURN (ALL SAVE MIN) SINCE
            12-Feb-2006 NOT FROM "Smith"
        S: * ESEARCH (TAG "C286") MIN 2 ALL 2,10:15,21
      //$ value is 2,10:15,21
        S: C286 OK SEARCH completed
```

---
#### **6.4.5.  FETCH Command**

```text
   Arguments:    sequence set

                 message data item names or macro

   Responses:    untagged responses:  FETCH

   Result:       OK -  fetch completed
                 NO -  fetch error: can't fetch that data
                 BAD -  command unknown or arguments invalid
```

FETCH 명령은 메일함의 메시지와 연관된 데이터를 검색합니다.  가져올 데이터 항목은 단일 원자이거나 괄호로 묶인 목록일 수 있습니다.

msg-att-static 규칙의 형식 구문\(섹션 9\)에서 식별되는 대부분의 데이터 항목은 정적이며 특정 메시지에 대해 변경되어서는 안 됩니다.  msg-att-dynamic 규칙의 공식 구문에서 식별된 기타 데이터 항목은 STORE 명령의 결과 또는 외부 이벤트로 인해 변경될 수 있습니다.

- 예를 들어, 클라이언트가 이미 봉투를 알고 있는데 메시지에 대한 ENVELOPE를 수신한 경우 새로 전송된 봉투를 안전하게 무시할 수 있습니다.

일반적으로 사용되는 데이터 항목 세트를 지정하고 데이터 항목 대신 사용할 수 있는 세 가지 매크로가 있습니다.  매크로는 단독으로 사용해야 하며 다른 매크로나 데이터 항목과 함께 사용해서는 안 됩니다.

```text
   ALL
      Macro equivalent to: (FLAGS INTERNALDATE RFC822.SIZE ENVELOPE)

   FAST
      Macro equivalent to: (FLAGS INTERNALDATE RFC822.SIZE)

   FULL
      Macro equivalent to: (FLAGS INTERNALDATE RFC822.SIZE ENVELOPE
      BODY)
```

여러 데이터 항목이 "섹션" 또는 "섹션-바이너리"를 참조합니다.  자세한 정의는 섹션 6.4.5.1을 참조하세요.

가져올 수 있는 현재 정의된 데이터 항목은 다음과 같습니다.

BINARY\[<section-binary\>\]<<partial\>\> - 해당 섹션의 Content-Transfer-Encoding 디코딩을 수행한 후 지정된 섹션을 전송하도록 요청합니다.

- <partial\> 인수가 있는 경우 데이터의 하위 집합이 반환되도록 요청합니다.  부분 FETCH BINARY 명령의 의미는 <partial\> 인수가 DECODED 섹션 데이터를 참조한다는 점을 제외하면 부분 FETCH BODY 명령과 동일합니다.

- 이 데이터 항목은 리프 본문 부분\(multipart/\*, message/rfc822 또는 message/global 이외의 미디어 유형을 갖는 부분\)에 대해서만 요청할 수 있습니다.

BINARY.PEEK\[<section-binary\>\]<<partial\>\> - \Seen 플래그를 암시적으로 설정하지 않는 BINARY\[<section-binary\>\]의 대체 형식입니다.

BINARY.SIZE\[<section-binary\>\] - 섹션의 디코딩된 크기\(즉, 해당 FETCH BINARY 요청에 대한 응답으로 예상되는 크기\)를 요청합니다.

- 참고: 클라이언트 작성자는 일부 서버 구현의 경우 비용이 많이 드는 작업일 수 있다는 점을 주의해야 합니다.  불필요하게 이 요청을 발행하면 서버가 요청이 발행될 때마다 값을 계산해야 하기 때문에 성능이 저하될 수 있습니다.

- 이 데이터 항목은 리프 본문 부분\(multipart/\*, message/rfc822 또는 message/global 이외의 미디어 유형을 갖는 부분\)에 대해서만 요청할 수 있습니다.

BODY - 확장할 수 없는 형태의 BODYSTRUCTURE입니다.

BODY\[<섹션\>\]<<부분\>\> - 특정 본문 섹션의 텍스트입니다.  BODY\[\]가 지정되면\(섹션 지정이 생략됨\) FETCH는 전체 메시지의 \[RFC5322\] 표현을 요청합니다.

- 지정된 텍스트의 하위 문자열을 가져오는 것이 가능합니다.  이는 여는 꺾쇠 괄호\("<"\), 원하는 첫 번째 옥텟의 옥텟 위치, 마침표, 원하는 최대 옥텟 수 및 닫는 꺾쇠 괄호\("\>"\)를 부분 지정자에 추가하여 수행됩니다.  시작 옥텟이 텍스트 끝을 벗어나면 빈 문자열이 반환됩니다.

- 텍스트 끝을 넘어서 읽으려고 시도하는 부분 가져오기는 적절하게 잘립니다.  옥텟 0에서 시작하는 부분 가져오기는 이러한 잘림이 발생하더라도 부분 가져오기로 반환됩니다.

- 참고: 이는 1500옥텟 메시지의 BODY\[\]<0.2048\>가 BODY\[\]가 아닌 리터럴 크기 1500의 BODY\[\]<0\>을 반환한다는 의미입니다.

- 참고: HEADER.FIELDS 또는 HEADER.FIELDS.NOT 부분 지정자의 하위 문자열 가져오기는 헤더를 하위 집합으로 설정한 후 계산됩니다.

- \Seen 플래그는 암시적으로 설정됩니다. 이로 인해 플래그가 변경되면 해당 플래그는 FETCH 응답의 일부로 포함되어야 합니다.

BODY.PEEK\[<섹션\>\]<<부분\>\> - \Seen 플래그를 암시적으로 설정하지 않는 BODY\[<섹션\>\]의 대체 형식입니다.

BODYSTRUCTURE - 메시지의 \[MIME-IMB\] 본문 구조입니다.  이는 \[RFC5322\] 헤더와 \[MIME-IMB\] 헤더의 \[MIME-IMB\] 헤더 필드를 구문 분석하여 서버에서 계산됩니다.  자세한 내용은 섹션 7.5.2를 참조하세요.

ENVELOPE - 메시지의 봉투 구조입니다.  이는 \[RFC5322\] 헤더를 구성 요소 부분으로 구문 분석하고 필요에 따라 다양한 필드를 기본값으로 설정하여 서버에서 계산됩니다.  자세한 내용은 섹션 7.5.2를 참조하세요.

FLAGS - 이 메시지에 대해 설정된 플래그입니다.

INTERNALDATE - 메시지의 내부 날짜입니다.

RFC822.SIZE - 섹션 2.3.4에 정의된 메시지 크기입니다.

UID - 메시지의 고유 식별자입니다.

```text
   Example:

     C: A654 FETCH 2:4 (FLAGS BODY[HEADER.FIELDS (DATE FROM)])
     S: * 2 FETCH ....
     S: * 3 FETCH ....
     S: * 4 FETCH ....
     S: A654 OK FETCH completed
```

---
##### **6.4.5.1.  FETCH Section Specification**

여러 FETCH 데이터 항목이 "섹션" 또는 "섹션-바이너리"를 참조합니다. 섹션 사양은 마침표로 구분된 0개 이상의 부분 지정자 집합입니다.  부품 지정자는 부품 번호이거나 HEADER, HEADER.FIELDS, HEADER.FIELDS.NOT, MIME 및 TEXT 중 하나입니다.  \(숫자가 아닌 부분 지정자는 섹션 사양의 마지막 지정자여야 합니다.\) 빈 섹션 사양은 헤더를 포함한 전체 메시지를 나타냅니다.

모든 메시지에는 최소한 하나의 부품 번호가 있습니다.  MIME을 사용하지 않는 메시지와 다중 부분이 아니고 캡슐화된 메시지가 없는 MIME 메시지는 파트 1만 갖습니다.

다중 부분 메시지에는 메시지에 나타나는 대로 연속적인 부품 번호가 할당됩니다.  특정 부분이 메시지 또는 멀티파트 유형인 경우 해당 부분은 마침표와 중첩된 멀티파트 부분 내의 부품 번호로 표시되어야 합니다.

MESSAGE/RFC822 또는 MESSAGE/GLOBAL 유형의 부분에도 MESSAGE 부분의 본문 부분을 참조하는 중첩된 부분 번호가 있습니다.

HEADER, HEADER.FIELDS, HEADER.FIELDS.NOT 및 TEXT 부분 지정자는 유일한 부분 지정자이거나 숫자 부분 지정자가 MESSAGE/RFC822 유형의 부분을 참조하는 경우 하나 이상의 숫자 부분 지정자가 앞에 올 수 있습니다. 또는 메시지/글로벌. MIME 부분 지정자 앞에는 하나 이상의 숫자 부분 지정자가 와야 합니다.

HEADER, HEADER.FIELDS 및 HEADER.FIELDS.NOT 부분 지정자는 메시지 또는 캡슐화된 \[MIME-IMT\] MESSAGE/RFC822 또는 MESSAGE/GLOBAL 메시지의 \[RFC5322\] 헤더를 참조합니다.  HEADER.FIELDS 및 HEADER.FIELDS.NOT 뒤에는 필드 이름 목록\(\[RFC5322\]에 정의됨\)이 오고 헤더의 하위 집합을 반환합니다.  HEADER.FIELDS에 의해 반환된 하위 집합에는 목록의 이름 중 하나와 일치하는 field-name이 있는 헤더 필드만 포함됩니다. 마찬가지로 HEADER.FIELDS.NOT에서 반환된 하위 집합에는 일치하지 않는 field-name이 있는 헤더 필드만 포함됩니다.  필드 일치는 ASCII 범위에서 대소문자를 구분하지 않지만 그 외에는 정확합니다.  하위 설정은 헤더와 본문 사이의 빈 줄을 구분하는 \[RFC5322\]를 제외하지 않습니다. 본문이나 빈 줄이 없는 메시지의 경우를 제외하고 빈 줄은 모든 헤더 페치에 포함됩니다.

MIME 부분 지정자는 이 부분에 대한 \[MIME-IMB\] 헤더를 참조합니다.

TEXT 부분 지정자는 \[RFC5322\] 헤더를 생략하고 메시지의 텍스트 본문을 참조합니다.

다음은 일부 부분 지정자가 포함된 복잡한 메시지의 예입니다.

```text
     HEADER     ([RFC5322] header of the message)
     TEXT       ([RFC5322] text body of the message) MULTIPART/MIXED
     1          TEXT/PLAIN
     2          APPLICATION/OCTET-STREAM
     3          MESSAGE/RFC822
     3.HEADER   ([RFC5322] header of the message)
     3.TEXT     ([RFC5322] text body of the message) MULTIPART/MIXED
     3.1        TEXT/PLAIN
     3.2        APPLICATION/OCTET-STREAM
     4          MULTIPART/MIXED
     4.1        IMAGE/GIF
     4.1.MIME   ([MIME-IMB] header for the IMAGE/GIF)
     4.2        MESSAGE/RFC822
     4.2.HEADER ([RFC5322] header of the message)
     4.2.TEXT   ([RFC5322] text body of the message) MULTIPART/MIXED
     4.2.1      TEXT/PLAIN
     4.2.2      MULTIPART/ALTERNATIVE
     4.2.2.1    TEXT/PLAIN
     4.2.2.2    TEXT/RICHTEXT
```

---
#### **6.4.6.  STORE Command**

```text
   Arguments:    sequence set

                 message data item name

                 value for message data item

   Responses:    untagged responses:  FETCH

   Result:       OK -  store completed
                 NO -  store error: can't store that data
                 BAD -  command unknown or arguments invalid
```

STORE 명령은 메일함의 메시지와 연관된 데이터를 변경합니다.  일반적으로 STORE는 태그가 지정되지 않은 FETCH 응답으로 업데이트된 데이터 값을 반환합니다.  데이터 항목 이름의 접미사 ".SILENT"는 태그가 지정되지 않은 FETCH를 방지하며 서버는 클라이언트가 업데이트된 값 자체를 결정했거나 업데이트된 값에 관심이 없다고 가정해야 합니다.

- 참고: ".SILENT" 접미사가 사용되었는지 여부에 관계없이 외부 소스에서 메시지 플래그에 대한 변경 사항이 관찰되면 서버는 태그가 지정되지 않은 FETCH 응답을 보내야 합니다.  이는 플래그의 상태가 경쟁 조건 없이 결정된다는 것입니다.

저장될 수 있는 현재 정의된 데이터 항목은 다음과 같습니다.

FLAGS <플래그 목록\> - 메시지의 플래그를 인수로 바꿉니다.  해당 플래그의 FETCH가 완료된 것처럼 플래그의 새 값이 반환됩니다.

FLAGS.SILENT <플래그 목록\> - FLAGS와 동일하지만 새 값을 반환하지 않습니다.

+FLAGS <플래그 목록\> - 메시지 플래그에 인수를 추가합니다.  해당 플래그의 FETCH가 완료된 것처럼 플래그의 새 값이 반환됩니다.

+FLAGS.SILENT <플래그 목록\> - +FLAGS와 동일하지만 새 값을 반환하지 않습니다.

-FLAGS <플래그 목록\> - 메시지 플래그에서 인수를 제거합니다.  해당 플래그의 FETCH가 완료된 것처럼 플래그의 새 값이 반환됩니다.

-FLAGS.SILENT <플래그 목록\> - -FLAGS와 동일하지만 새 값을 반환하지 않습니다.

```text
   Example:

     C: A003 STORE 2:4 +FLAGS (\Deleted)
     S: * 2 FETCH (FLAGS (\Deleted \Seen))
     S: * 3 FETCH (FLAGS (\Deleted))
     S: * 4 FETCH (FLAGS (\Deleted \Flagged \Seen))
     S: A003 OK STORE completed
```

---
#### **6.4.7.  COPY Command**

```text
   Arguments:    sequence set

                 mailbox name
```

응답: 이 명령에 대한 특정 응답이 없습니다.

```text
   Result:       OK -  copy completed
                 NO -  copy error: can't copy those messages or to that
                    name
                 BAD -  command unknown or arguments invalid
```

COPY 명령은 지정된 메시지를 지정된 대상 사서함의 끝에 복사합니다.  메시지의 플래그와 내부 날짜는 복사본에 보존되어야 합니다.

대상 사서함이 존재하지 않으면 서버는 오류를 반환해야 합니다.  사서함을 자동으로 생성해서는 안 됩니다.  대상 사서함을 만들 수 없다는 것이 확실하지 않은 한 서버는 태그가 지정된 NO 응답 텍스트의 접두사로 응답 코드 "\[TRYCREATE\]"를 보내야 합니다.  이는 CREATE 명령을 시도하고 CREATE가 성공하면 COPY를 다시 시도할 수 있다는 힌트를 클라이언트에 제공합니다.

COPY 명령이 어떤 이유로든 실패하는 경우 서버 구현은 대상 사서함을 COPY 시도 이전의 상태로 복원해야 합니다\(UIDNEXT를 증가시킬 수 있는 경우는 제외\). 즉, 부분 복사를 수행하면 안 됩니다.

COPY가 성공적으로 완료되면 서버는 COPYUID 응답 코드를 반환합니다\(섹션 7.1 참조\).  이 요구 사항에 대한 두 가지 예외가 아래에 나열되어 있습니다.

클라이언트가 사서함에 COPY할 수 있지만 SELECT 또는 EXAMINE은 할 수 없도록 권한이 설정된 사서함의 경우 서버는 사서함에 대한 정보를 공개하므로 COPYUID 응답 코드를 보내서는 안 됩니다.

UIDNOTSTICKY 상태\(섹션 7.1 참조\)가 있는 사서함의 경우 서버는 의미가 없으므로 COPYUID 응답 코드를 생략할 수 있습니다.

```text
   Example:

     C: A003 COPY 2:4 MEETING
     S: A003 OK [COPYUID 38505 304,319:320 3956:3958] COPY completed
```

---
#### **6.4.8.  MOVE Command**

```text
   Arguments:    sequence set

                 mailbox name
```

응답: 이 명령에 대한 특정 응답이 없습니다.

```text
   Result:       OK -  move completed
                 NO -  move error: can't move those messages or to that
                    name
                 BAD -  command unknown or arguments invalid
```

MOVE 명령은 지정된 메시지를 지정된 대상 사서함의 끝으로 이동합니다.  메시지의 플래그와 내부 날짜는 보존되어야 합니다.

이는 새 UID를 사용하여 대상 사서함에 새 메시지가 생성되고 원본 메시지가 원본 사서함에서 제거되며 클라이언트에 단일 작업으로 표시됨을 의미합니다.  이는 각 메시지에 대해 다음 순서와 동일한 효과를 갖습니다.

```text
   1.  [UID] COPY

   2.  [UID] STORE +FLAGS.SILENT \DELETED

   3.  UID EXPUNGE
```

MOVE의 효과는 이전 단계와 동일하지만 의미 체계는 동일하지 않습니다. 즉, 해당 단계에서 생성된 중간 상태가 발생하지 않으며 응답 코드가 다릅니다.  특히, COPY 및 EXPUNGE 응답 코드가 반환되더라도 STORE에 대한 응답 코드는 생성되어서는 안 되며, \Deleted 플래그는 어떤 메시지에도 설정되어서는 안 됩니다.

COPY 명령과 달리 메시지 세트의 MOVE는 세트 도중에 실패할 수 있습니다.  명령이 전체 세트를 이동하는 데 성공했는지 여부에 관계없이 각 개별 메시지는 이동되거나 영향을 받지 않아야 합니다.  서버는 각 메시지를 원본 또는 대상 사서함 중 하나 이상에 있는 상태로 두어야 합니다\(메시지가 손실되거나 고아가 될 수 없음\).  서버는 두 사서함 모두에 메시지를 남겨서는 안 됩니다. 부분적인 실패로 인해 여러 개의 중복 메시지가 발생하는 것은 좋지 않습니다.  이는 서버가 명령에 대해 태그된 NO 응답을 반환하는 경우에도 마찬가지입니다.

대상 사서함이 존재하지 않으면 서버는 오류를 반환해야 합니다.  자동으로 사서함을 생성해서는 안 됩니다.  대상 사서함을 만들 수 없다는 것이 확실하지 않은 한 서버는 태그가 지정된 NO 응답 텍스트의 접두사로 응답 코드 "\[TRYCREATE\]"를 보내야 합니다.  이는 CREATE 명령을 시도하고 CREATE가 성공하면 MOVE를 다시 시도할 수 있다는 힌트를 클라이언트에 제공합니다.

MOVE와 COPY의 유사성으로 인해 COPY에 영향을 미치는 확장은 동일한 방식으로 MOVE에 영향을 미칩니다.  섹션 7.1에 나열된 응답 코드와 확장으로 정의된 응답 코드는 COPY에 표시된 대로 전송됩니다.

서버는 MOVE 또는 UID MOVE\(섹션 6.4.9 참조\) 명령에 대한 응답으로 COPYUID를 보냅니다.  COPYUID에 대한 자세한 내용은 섹션 7.1을 참조하세요.  서버가 COPYUID를 반환하지 않도록 허용하는 몇 가지 예외가 섹션 6.4.7에 나열되어 있습니다.

또한 서버는 EXPUNGE 또는 유사한 응답을 보내기 전에 태그가 없는 OK로 COPYUID 응답 코드를 보내야 합니다.  \(섹션 6.4.7에 설명된 대로 태그된 OK에서 COPYUID를 보내는 것은 클라이언트가 먼저 메시지에 대해 EXPUNGE를 수신하고 그 후에 동일한 메시지에 대해 COPYUID를 수신한다는 의미입니다. 해당 시퀀스를 유용하게 처리하는 것은 불필요하게 어려울 수 있습니다.\)

예:

```text
     C: a UID MOVE 42:69 foo
     S: * OK [COPYUID 432432 42:69 1202:1229]
     S: * 22 EXPUNGE
     ...More EXPUNGE responses from the server...
     S: a OK Done
```

동시에 말소된 경우 서버는 관련 없는 말소 응답도 보낼 수 있습니다. 이는 정상적인 IMAP 작업입니다.

현재 선택한 사서함에 메시지를 복사하는 것이 허용되면 현재 선택한 사서함\(즉, 원본 및 대상 사서함이 동일한 경우\)으로 메시지를 이동하는 것이 허용됩니다.

서버는 태그가 지정된 응답 전에 EXPUNGE 응답을 보낼 수 있으므로 클라이언트는 서버가 MOVE를 처리하는 동안 메시지 시퀀스 번호 인수가 포함된 추가 명령을 안전하게 보낼 수 없습니다.

MOVE 및 UID MOVE는 다른 명령과 함께 파이프라인될 수 있지만 주의가 필요합니다.  두 명령 모두 시퀀스 번호를 수정하고 관련되지 않은 EXPUNGE 응답도 허용합니다.  EXPUNGE 응답 이후 원본 메일함에서 다른 메시지의 번호를 다시 매기는 것은 놀라운 일이 될 수 있으며 MOVE 또는 UID MOVE 이후 메시지 시퀀스 번호에 의존하는 명령을 파이프라인하는 것이 안전하지 않게 만듭니다.  마찬가지로 메시지 번호 다시 매기기를 유발할 수 있는 명령을 사용하여 MOVE를 파이프라인할 수 없습니다.  클라이언트와 서버 모두에 대한 요구 사항 처리 및 모호성에 대한 자세한 내용은 섹션 5.5를 참조하세요.

---
#### **6.4.9.  UID Command**

```text
   Arguments:    command name

                 command arguments

   Responses:    untagged responses:  FETCH, ESEARCH, EXPUNGE

   Result:       OK -  UID command completed
                 NO -  UID command error
                 BAD -  command unknown or arguments invalid
```

UID 명령에는 세 가지 형식이 있습니다.  첫 번째 형식에서는 관련 명령에 적합한 인수와 함께 COPY, MOVE, FETCH 또는 STORE 명령을 인수로 사용합니다.  그러나 시퀀스 집합 인수의 숫자는 메시지 시퀀스 번호가 아닌 고유 식별자입니다.  시퀀스 집합 범위는 허용되지만 고유 식별자가 연속적이라는 보장은 없습니다.

존재하지 않는 고유 식별자는 오류 메시지가 생성되지 않고 무시됩니다.  따라서 UID FETCH 명령이 데이터 없이 OK를 반환하거나 UID COPY, UID MOVE 또는 UID STORE가 어떤 작업도 수행하지 않고 OK를 반환하는 것이 가능합니다.

두 번째 형식에서 UID 명령은 작동할 UID 시퀀스 세트를 지정하는 추가 매개변수와 함께 EXPUNGE 명령을 사용합니다. UID EXPUNGE 명령은 \Deleted 플래그 세트와 현재 선택된 사서함의 지정된 시퀀스 세트에 포함된 UID가 모두 있는 모든 메시지를 영구적으로 제거합니다.  메시지에 \Deleted 플래그가 설정되어 있지 않거나 지정된 시퀀스 세트에 포함되지 않은 UID가 있는 경우 영향을 받지 않습니다.

UID EXPUNGE는 연결이 끊어진 클라이언트에 특히 유용합니다.  서버와 다시 동기화할 때 EXPUNGE 대신 UID EXPUNGE를 사용하면 클라이언트가 마지막으로 연결한 시간과 클라이언트가 다시 동기화하는 시간 사이에 다른 클라이언트에 의해 \Deleted로 표시된 메시지를 실수로 제거하지 않도록 할 수 있습니다. .

```text
   Example:

     C: A003 UID EXPUNGE 3000:3002
     S: * 3 EXPUNGE
     S: * 3 EXPUNGE
     S: * 3 EXPUNGE
     S: A003 OK UID EXPUNGE completed
```

세 번째 형식에서 UID 명령은 SEARCH 명령 인수와 함께 SEARCH 명령을 사용합니다.  인수의 해석은 SEARCH와 동일합니다. 그러나 UID SEARCH 명령에 대한 ESEARCH 응답에서 반환된 숫자는 메시지 시퀀스 번호가 아닌 고유 식별자입니다.  또한 해당 ESEARCH 응답에는 UID 표시기가 포함되어야 합니다.  예를 들어, UID SEARCH 1:100 UID 443:557 명령은 두 시퀀스 세트의 교집합, 메시지 시퀀스 번호 범위 1:100 및 UID 범위 443:557에 해당하는 고유 식별자를 반환합니다.

- 참고: 위의 예에서는 UID 범위 443:557이 나타납니다.  존재하지 않는 고유 식별자가 오류 메시지 없이 무시된다는 동일한 설명이 여기에도 적용됩니다.  따라서 UID 443이나 557이 모두 존재하지 않더라도 이 범위는 유효하며 기존 UID 495를 포함합니다.

- 또한 559:\*의 UID 범위에는 559가 할당된 UID 값보다 높은 경우에도 항상 사서함에 있는 마지막 메시지의 UID가 포함됩니다.  이는 범위의 내용이 범위 끝점의 순서와 무관하기 때문입니다.  따라서 끝점 중 하나로 \*가 있는 UID 범위는 사서함이 비어 있지 않은 한 최소한 하나의 메시지\(UID 번호가 가장 높은 메시지\)를 나타냅니다.

태그가 지정되지 않은 FETCH 또는 EXPUNGE 응답에서 "\*" 뒤의 숫자는 UID 명령 응답의 경우에도 고유 식별자가 아니라 항상 메시지 시퀀스 번호입니다.  그러나 서버 구현은 UID가 FETCH에 대한 메시지 데이터 항목으로 지정되었는지 여부에 관계없이 UID 명령으로 인한 FETCH 응답의 일부로 UID 메시지 데이터 항목을 암시적으로 포함해야 합니다.

참고: UID 메시지 데이터 항목을 FETCH 응답의 일부로 포함하는 규칙은 주로 UID를 메시지 데이터 항목으로 포함하지 않는 UID FETCH 명령을 포함하여 UID FETCH 및 UID STORE 명령에 적용됩니다.  다른 UID 명령으로 인해 태그가 지정되지 않은 FETCH가 발생할 가능성은 없지만 이 규칙은 이러한 명령에도 적용됩니다.

```text
   Example:

     C: A999 UID FETCH 4827313:4828442 FLAGS
     S: * 23 FETCH (FLAGS (\Seen) UID 4827313)
     S: * 24 FETCH (FLAGS (\Seen) UID 4827943)
     S: * 25 FETCH (FLAGS (\Seen) UID 4828442)
     S: A999 OK UID FETCH completed
```

---
### **6.5.  Client Commands - Experimental/Expansion**

이 사양의 일부가 아닌 각 명령은 이와 관련된 기능 이름\(섹션 6.1.1 참조\)을 하나 이상 가져야 합니다. \(여러 명령이 동일한 기능 이름과 연관될 수 있습니다.\)

서버 구현은 클라이언트가 관련 실험 명령\(확장 문서에 지정\) 또는 ENABLE 명령\(섹션 6.3.1\)을 실행하여 요청하지 않는 한 태그가 지정되지 않은 추가 응답\(이 사양에 지정되지 않음\)을 전송해서는 안 됩니다.

다음 예에서는 XPIG-LATIN 명령과 XPIG-LATIN 태그가 지정되지 않은 응답을 추가하는 가상의 XPIG-LATIN 기능이 있는지 클라이언트가 확인할 수 있는 방법을 보여줍니다.  \(확장의 경우 명령 이름과 기능 이름이 동일할 필요는 없습니다.\)

```text
   Example:

     C: a441 CAPABILITY
     S: * CAPABILITY IMAP4rev2 XPIG-LATIN
     S: a441 OK CAPABILITY completed
     C: A442 XPIG-LATIN
     S: * XPIG-LATIN ow-nay eaking-spay ig-pay atin-lay
     S: A442 OK XPIG-LATIN ompleted-cay
```

---
## **7.  Server Responses**

서버 응답은 상태 응답, 서버 데이터 및 명령 연속 요청의 세 가지 형태로 제공됩니다.  아래 응답 설명에서 "Contents:"로 식별되는 서버 응답에 포함된 정보는 구문이 아닌 기능으로 설명됩니다.  서버 응답의 정확한 구문은 "형식 구문"\(섹션 9\)에 설명되어 있습니다.

클라이언트는 항상 모든 응답을 수락할 준비가 되어 있어야 합니다.

상태 응답에는 태그가 지정되거나 태그가 지정되지 않을 수 있습니다.  태그가 지정된 상태 응답은 클라이언트 명령의 완료 결과\(OK, NO 또는 BAD 상태\)를 나타내며 명령과 일치하는 태그를 갖습니다.

일부 상태 응답과 모든 서버 데이터에는 태그가 지정되지 않습니다.  태그가 지정되지 않은 응답은 태그 대신 "\*" 토큰으로 표시됩니다. 태그가 지정되지 않은 상태 응답은 서버 인사말 또는 명령 완료를 나타내지 않는 서버 상태\(예: 임박한 시스템 종료 경고\)를 나타냅니다.  역사적 이유로 태그가 지정되지 않은 서버 데이터 응답은 "요청되지 않은 데이터"라고도 합니다. 엄밀히 말하면 일방적인 서버 데이터만 실제로 "요청되지 않은" 데이터입니다.

특정 서버 데이터는 수신 시 클라이언트에 의해 기억되어야 합니다. 이는 해당 데이터의 설명에 명시되어 있습니다.  이러한 데이터는 모든 후속 명령 및 응답\(예: 메시지 생성 또는 파괴를 반영하는 업데이트\)의 해석에 영향을 미치는 중요한 정보를 전달합니다.

다른 서버 데이터는 나중에 참조할 수 있도록 기억해야 합니다. 클라이언트가 데이터를 기억할 필요가 없거나 데이터를 기억하는 데 명확한 목적이 없는 경우\(예: 진행 중인 SEARCH 명령이 없을 때 SEARCH 응답\) 데이터를 무시할 수 있습니다.

일방적으로 태그가 지정되지 않은 서버 데이터의 예는 IMAP 연결이 선택된 상태일 때 발생합니다.  선택된 상태에서 서버는 명령 실행의 일부로 사서함에서 새 메시지를 확인합니다.  일반적으로 이는 모든 명령 실행의 일부입니다. 따라서 새 메시지를 확인하는 데는 NOOP 명령으로 충분합니다.  새 메시지가 발견되면 서버는 사서함의 새 크기를 반영하는 태그가 지정되지 않은 EXISTS 응답을 보냅니다.  동일한 사서함에 대한 다중 동시 액세스를 제공하는 서버 구현은 다른 에이전트가 메시지 플래그의 상태를 변경하거나 메시지를 삭제하는 경우 태그가 지정되지 않은 적절한 일방적 FETCH 및 EXPUNGE 응답도 보내야 합니다\(SHOULD\).

명령 연속 요청 응답은 태그 대신 "+" 토큰을 사용합니다.  이러한 응답은 불완전한 클라이언트 명령을 수락하고 나머지 명령에 대한 준비가 되었음을 나타내기 위해 서버에서 전송됩니다.

---
### **7.1.  Server Responses - Generic Status Responses**

상태 응답은 OK, NO, BAD, PREAUTH 및 BYE입니다.  OK, NO, BAD에 태그를 지정하거나 태그를 지정하지 않을 수 있습니다.  PREAUTH 및 BYE는 항상 태그가 지정되지 않습니다.

상태 응답에는 선택적인 "응답 코드"가 포함될 수 있습니다.  응답 코드는 원자 형태의 대괄호 안의 데이터로 구성되며 그 뒤에 공백과 인수가 올 수 있습니다.  응답 코드에는 OK/NO/BAD 조건 이외의 클라이언트 소프트웨어에 대한 추가 정보 또는 상태 코드가 포함되며, 추가 정보를 기반으로 클라이언트가 수행할 수 있는 특정 작업이 있는 경우 정의됩니다.

현재 정의된 응답 코드는 다음과 같습니다.

ALERT - 사람이 읽을 수 있는 텍스트에는 메시지에 대한 사용자의 주의를 환기시키는 방식으로 사용자에게 표시되는 특별한 경고가 포함되어 있습니다.  TLS 또는 SASL 보안 계층 ​​기밀성이 없는 연결에서 수신된 ALERT 응답 코드의 내용은 클라이언트에서 무시되어야 합니다\(SHOULD\).  표시되는 경우 이러한 경고는 잠재적으로 의심스러운 것으로 명확하게 표시되어야 합니다.  \(일부 기존 클라이언트는 반환된 텍스트를 하이퍼링크하는 것으로 알려져 있으므로 매우 위험합니다.\) TLS/SASL 기밀 계층을 성공적으로 설정한 후 수신된 경고는 사용자에게 표시되어야 합니다.

ALREADYEXISTS - 작업은 CREATE 또는 RENAME 명령이 사서함을 생성하려고 시도하고 해당 이름 중 하나가 이미 있는 경우와 같이 이미 존재하는 항목을 생성하려고 시도합니다.

```text
        C: o356 RENAME this that
        S: o356 NO [ALREADYEXISTS] Mailbox "that" already exists
```

APPENDUID - 대상 사서함의 UIDVALIDITY와 대상 사서함의 추가된 메시지에 할당된 UID가 뒤따라 해당 UID를 사용하여 메시지가 대상 사서함에 추가되었음을 나타냅니다.

- 서버가 \[MULTIAPPEND\] 확장도 지원하고 APPEND 명령에 여러 메시지가 추가된 경우 두 번째 값은 APPEND 명령에서 전송된 순서대로 추가된 메시지에 할당된 UID를 포함하는 UID 세트입니다. .  이 UID 세트에는 외부 UID나 "\*" 기호가 포함될 수 없습니다.

- 참고: 단일 메시지만 추가된 경우 APPENDUID 응답 코드의 UID 설정 형식을 사용해서는 안 됩니다.  특히 서버는 123:123과 같은 범위를 전송해서는 안 됩니다.  이는 \[MULTIAPPEND\]를 지원하지 않는 클라이언트가 UID 세트가 아닌 단일 UID만 기대하기 때문입니다.

- UID는 사서함에서 엄격한 오름차순으로 할당됩니다\(섹션 2.3.1.1 참조\). 12:10 범위는 10:12와 정확히 동일하며 시퀀스 10,11,12를 나타냅니다.

- 이 응답 코드는 APPEND 명령에 대한 태그된 OK 응답으로 반환됩니다.

AUTHENTICATIONFAILED - 서버가 설명할 수 없는 어떤 이유로 인증에 실패했습니다.  일반적으로 여기에는 "알 수 없는 사용자" 및 "잘못된 비밀번호"가 포함됩니다.

- 이는 클라이언트가 AUTHENTICATIONFAILED를 볼 때 문제가 아니었음\(예: UNAVAILABLE\)을 알기 때문에 나중에 동일한 로그인/비밀번호를 다시 시도할 필요가 없다는 점을 제외하면 응답 코드를 보내지 않는 것과 같습니다.

```text
        C: b LOGIN "fred" "foo"
        S: b NO [AUTHENTICATIONFAILED] Authentication failed
```

AUTHORIZATIONFAILED - 인증 ID를 사용하여 인증에 성공했지만 서버는 인증 ID가 요청된 권한 부여 ID로 작동하도록 허용할 수 없거나 허용하지 않습니다.  이는 인증 ID와 권한 부여 ID가 ​​다른 경우에만 적용됩니다.

```text
        C: c1 AUTHENTICATE PLAIN
        [...]
        S: c1 NO [AUTHORIZATIONFAILED] No such authorization-ID

        C: c2 AUTHENTICATE PLAIN
        [...]
        S: c2 NO [AUTHORIZATIONFAILED] Authenticator is not an admin
```

BADCHARSET - 선택적으로 뒤에 괄호로 묶인 문자 세트 목록이 옵니다.  이 구현에서는 지정된 문자 세트를 지원하지 않기 때문에 검색에 실패했습니다.  선택적 문자 집합 목록이 제공되면 이 구현에서 지원되는 문자 집합이 나열됩니다.

CANNOT - 이 작업은 서버의 일부 불변성을 위반하므로 절대 성공할 수 없습니다.

```text
        C: l create "///////"
        S: l NO [CANNOT] Adjacent slashes are not supported
```

기능 - 기능 목록이 뒤따릅니다.  이는 초기 기능 목록을 전송하기 위한 초기 OK 또는 PREAUTH 응답에 나타날 수 있습니다.  LOGIN 또는 AUTHENTICATE 명령에 대한 태그 응답에도 나타날 수 있습니다.  따라서 클라이언트가 이 응답 코드를 인식하고 해당 코드를 수신한 이후 TLS 및/또는 인증 상태에 변경 사항이 없는 경우 별도의 CAPABILITY 명령을 보낼 필요가 없습니다.

CLIENTBUG - 서버가 클라이언트 버그를 감지했습니다.  이는 클라이언트 버그가 무엇인지에 따라 OK, NO, BAD 중 하나와 함께 나타날 수 있습니다.

```text
        C: k1 select "/archive/projects/experiment-iv"
        [...]
        S: k1 OK [READ-ONLY] Done
        C: k2 status "/archive/projects/experiment-iv" (messages)
        [...]
        S: k2 OK [CLIENTBUG] Done
```

CLOSED - CLOSED 응답 코드에는 매개변수가 없습니다.  다른 사서함에서 SELECT 또는 EXAMINE 명령을 사용하여 현재 선택한 사서함이 암시적으로 닫히면 서버는 CLOSED 응답 코드를 반환합니다. CLOSED 응답 코드는 이전에 열었던 사서함\(폐쇄된\)에 대한 응답과 새로 선택한 사서함 사이의 경계 역할을 합니다. CLOSED 응답 코드 이전의 모든 응답은 닫힌 사서함과 관련이 있으며 모든 후속 응답은 새로 열린 사서함과 관련됩니다.

- CLOSE 또는 UNSELECT 명령\(또는 이와 유사한 명령\) 완료 시 CLOSED 응답 코드를 반환할 필요가 없습니다. 이 명령의 목적은 새 사서함을 열지 않고 현재 선택한 사서함을 닫는 것입니다.

CONTACTADMIN - 사용자는 시스템 관리자나 지원 데스크에 문의해야 합니다.

```text
        C: e login "fred" "foo"
        S: e NO [CONTACTADMIN]
```

COPYUID - 대상 사서함의 UIDVALIDITY, 대상 사서함에 복사된 원본 사서함의 메시지 UID를 포함하는 UID 세트, 복사된 메시지에 할당된 UID를 포함하는 다른 UID 세트가 옵니다. \)는 대상 사서함에 있는 메시지가 명시된 UID를 사용하여 대상 사서함에 복사되었음을 나타냅니다.

- 소스 UID 세트는 메시지가 복사된 순서대로 되어 있습니다. 대상 UID 세트는 소스 UID 세트에 해당하며 동일한 순서입니다.  UID 세트 중 어느 것도 관련 없는 UID나 "\*" 기호를 포함할 수 없습니다.

- UID는 사서함에서 엄격한 오름차순으로 할당됩니다\(섹션 2.3.1.1 참조\). 12:10 범위는 10:12와 정확히 동일하며 시퀀스 10,11,12를 나타냅니다.

- 이 응답 코드는 COPY 또는 UID COPY 명령에 대한 태그가 지정된 OK 응답으로 반환되거나 MOVE 또는 UID MOVE 명령에 대한 태그가 지정되지 않은 OK 응답으로 반환됩니다.

손상 - 서버에서 일부 관련 데이터\(예: 사서함\)가 손상되었음을 발견했습니다.  이 응답 코드에는 손상된 내용에 대한 정보가 포함되어 있지 않지만 서버는 해당 정보를 로그 파일에 쓸 수 있습니다.

```text
        C: i select "/archive/projects/experiment-iv"
        S: i NO [CORRUPTION] Cannot open mailbox
```

만료됨 - 인증이 성공했거나 서버에 더 이상 필요한 데이터가 없습니다. 어느 쪽이든 해당 암호를 사용한 액세스는 더 이상 허용되지 않습니다.  클라이언트나 사용자는 새 암호를 받아야 합니다.

```text
        C: d login "fred" "foo"
        S: d NO [EXPIRED] That password isn't valid any more
```

말소 - 다른 사람이 동일한 사서함에 대해 말소를 발행했습니다.  클라이언트는 곧 NOOP를 발행하기를 원할 수 있습니다.  \[IMAP-MULTIACCESS\]에서는 이 주제를 심도 있게 논의합니다.

```text
        C: h search from maria@example.com
        S: * ESEARCH (TAG "h") ALL 1:3,5,8,13,21,42
        S: h OK [EXPUNGEISSUED] Search completed
```

HASCHILDREN - 사서함에 하나 이상의 하위 항목이 있고 서버가 하위 항목이 있는 사서함 삭제를 허용하지 않기 때문에 사서함 삭제 작업이 실패했습니다.

```text
        C: m356 DELETE Notes
        S: o356 NO [HASCHILDREN] Mailbox "Notes" has children
        that need to be deleted first
```

INUSE - 다른 사람이 앉아 있는 가지를 톱질하는 작업이 포함되어 있어 작업이 수행되지 않았습니다.  다른 사람이 이 작업에 필요한 단독 잠금을 보유하고 있을 수도 있고, 다른 사람이 사용하고 있는 리소스\(일반적으로 사서함\)를 삭제하는 작업이 포함될 수도 있습니다.

- 클라이언트가 나중에 다시 시도하면 작업이 성공할 수 있습니다.

```text
        C: g delete "/archive/projects/experiment-iv"
        S: g NO [INUSE] Mailbox in use
```

LIMIT - 단일 메시지의 플래그 수 또는 사서함에 사용되는 플래그 수와 같은 일종의 구현 제한에 대해 작업이 실행되었습니다.

```text
        C: m STORE 42 FLAGS f1 f2 f3 f4 f5 ... f250
        S: m NO [LIMIT] At most 32 flags in one mailbox supported
```

NONEXISTENT - 존재하지 않는 항목을 삭제하려고 시도하는 작업입니다. 이미 존재함\(ALREADYEXISTS\)과 유사합니다.

```text
        C: p RENAME this that
        S: p NO [NONEXISTENT] No such mailbox
```

NOPERM - 액세스 제어 시스템\(예: ACL, \[RFC4314\] 참조\)은 이 사용자가 사서함 선택 또는 생성과 같은 작업을 수행하는 것을 허용하지 않습니다.

```text
        C: f select "/archive/projects/experiment-iv"
        S: f NO [NOPERM] Access denied
```

OVERQUOTA - 작업 후 사용자가 할당량을 초과하게 됩니다.  \(사용자가 이미 할당량을 초과했을 수도 있고 초과하지 않았을 수도 있습니다.\)

- 서버가 OVERQUOTA를 전송하지만 \[RFC2087\]에 정의된 IMAP QUOTA 확장을 지원하지 않는 경우 할당량이 있지만 클라이언트는 할당량이 무엇인지 알 수 없습니다.

```text
        C: n1 uid copy 1:* oldmail
        S: n1 NO [OVERQUOTA] Sorry

        C: n2 uid copy 1:* oldmail
        S: n2 OK [OVERQUOTA] You are now over your soft quota
```

PARSE - 사람이 읽을 수 있는 텍스트는 사서함에 있는 메시지의 \[RFC5322\] 헤더 또는 \[MIME-IMB\] 헤더를 구문 분석하는 중 오류를 나타냅니다.

PERMANENTFLAGS - 뒤에 괄호로 묶인 플래그 목록이 오고 클라이언트가 영구적으로 변경할 수 있는 알려진 플래그를 나타냅니다.  FLAGS 태그가 지정되지 않은 응답에는 있지만 PERMANENTFLAGS 목록에는 없는 플래그는 영구적으로 설정할 수 없습니다.  PERMANENTFLAGS 목록에는 해당 키워드를 사서함에 저장하려고 시도하여 새 키워드를 만들 수 있음을 나타내는 특수 플래그 \*도 포함될 수 있습니다.  클라이언트가 PERMANENTFLAGS 목록에 없는 플래그를 저장하려고 시도하면 서버는 변경 사항을 무시하거나 현재 세션의 나머지 부분에 대해서만 상태 변경 사항을 저장합니다.

- 클라이언트 요청 시 메시지에 새 키워드가 성공적으로 설정된 경우 특수 플래그 \*를 포함하는 서버가 새 PERMANENTFLAGS 응답 코드를 반환할 필요가 없습니다.  그러나 서버에 사서함에 저장할 수 있는 다양한 키워드 수에 대한 제한이 있고 해당 제한에 도달한 경우 서버는 특수 플래그 \* 없이 새로운 PERMANENTFLAGS 응답 코드를 보내야 합니다.

PRIVACYREQUIRED - 데이터 기밀성이 부족하여 작업이 허용되지 않습니다.  TLS를 사용하지 않는 경우 클라이언트는 STARTTLS\(섹션 6.2.1 참조\)를 시도하거나 암시적 TLS 포트에 다시 연결한 다음 작업을 반복할 수 있습니다.

```text
        C: d login "fred" "foo"
        S: d NO [PRIVACYREQUIRED] Connection offers no privacy

        C: d select inbox
        S: d NO [PRIVACYREQUIRED] Connection offers no privacy
```

읽기 전용 - 사서함이 읽기 전용으로 선택되었거나 선택된 동안의 액세스가 읽기-쓰기에서 읽기 전용으로 변경되었습니다.

읽기-쓰기 - 사서함이 읽기-쓰기로 선택되었거나 선택된 동안의 액세스가 읽기 전용에서 읽기-쓰기로 변경되었습니다.

SERVERBUG - 서버 자체에 버그가 발생했거나 자체 불변성 중 하나를 위반했습니다.

```text
        C: j select "/archive/projects/experiment-iv"
        S: j NO [SERVERBUG] This should not happen
```

TRYCREATE - 다른 이유와는 반대로 대상 사서함이 존재하지 않기 때문에 APPEND, COPY 또는 MOVE 시도가 실패합니다.  이는 CREATE 명령으로 사서함을 처음 생성한 경우 작업이 성공할 수 있다는 것을 클라이언트에게 알려주는 힌트입니다.

UIDNEXT - 뒤에 10진수가 오고 다음 고유 식별자 값을 나타냅니다.  자세한 내용은 섹션 2.3.1.1을 참조하십시오.

UIDNOTSTICKY - 선택한 사서함은 영구 UID를 지원하지 않는 메일 저장소에서 지원됩니다. 즉, UIDVALIDITY는 사서함을 선택할 때마다 달라집니다.  결과적으로 이 사서함에 대한 APPEND 또는 COPY는 APPENDUID 또는 COPYUID 응답 코드를 반환하지 않습니다.

- 이 응답 코드는 SELECT 명령에 대한 태그가 지정되지 않은 NO 응답으로 반환됩니다.

- 참고: 서버에는 UIDNOTSTICKY 메일 저장소가 있어서는 안 됩니다. 이 기능은 영구 UID 지원이 기술적으로 불가능한 레거시 메일 저장소를 지원하기 위해 존재합니다.  새 메일 저장소를 설계할 때는 이 문제를 피해야 합니다.

UIDVALIDITY - 뒤에 10진수가 오고 고유 식별자 유효성 값을 나타냅니다.  자세한 내용은 섹션 2.3.1.1을 참조하십시오.

UNAVAILABLE - 하위 시스템이 다운되어 일시적인 오류가 발생했습니다.  예를 들어 인증을 위해 LDAP\(Lightweight Directory Access Protocol\) 또는 Radius 서버를 사용하는 IMAP 서버는 LDAP/Radius 서버가 다운될 때 이 응답 코드를 사용할 수 있습니다.

```text
        C: a LOGIN "fred" "foo"
        S: a NO [UNAVAILABLE] User's backend down for maintenance
```

UNKNOWN-CTE - 서버가 섹션의 콘텐츠 전송 인코딩을 디코딩하는 방법을 모릅니다.

클라이언트 구현은 인식하지 못하는 응답 코드를 무시해야 합니다\(MUST\).

---
#### **7.1.1.  OK Response**

```text
   Contents: 
               OPTIONAL response code
               human-readable text
```

OK 응답은 서버의 정보 메시지를 나타냅니다. 태그가 지정되면 관련 명령이 성공적으로 완료되었음을 나타냅니다.  사람이 읽을 수 있는 텍스트는 정보 메시지로 사용자에게 표시될 수 있습니다.  태그가 지정되지 않은 양식은 정보 전용 메시지를 나타냅니다. 정보의 성격은 응답 코드로 표시될 수 있습니다.

태그가 지정되지 않은 양식은 연결 시작 시 가능한 세 가지 인사말 중 하나로도 사용됩니다.  이는 연결이 아직 인증되지 않았으며 LOGIN 또는 AUTHENTICATE 명령이 필요함을 나타냅니다.

```text
   Example:

     S: * OK IMAP4rev2 server ready
     C: A001 LOGIN fred blurdybloop
     S: * OK [ALERT] System shutdown in 10 minutes
     S: A001 OK LOGIN Completed
```

---
#### **7.1.2.  NO Response**

```text
   Contents: 
               OPTIONAL response code
               human-readable text
```

NO 응답은 서버의 작동 오류 메시지를 나타냅니다.  태그가 지정되면 관련 명령이 성공적으로 완료되지 않았음을 나타냅니다.  태그가 지정되지 않은 양식은 경고를 나타냅니다. 명령은 여전히 ​​성공적으로 완료될 수 있습니다.  사람이 읽을 수 있는 텍스트는 조건을 설명합니다.

```text
   Example:

     C: A222 COPY 1:2 owatagusiam
     S: * NO Disk is 98% full, please delete unnecessary data
     S: A222 OK COPY completed
     C: A223 COPY 3:200 blurdybloop
     S: * NO Disk is 98% full, please delete unnecessary data
     S: * NO Disk is 99% full, please delete unnecessary data
     S: A223 NO COPY failed: disk is full
```

---
#### **7.1.3.  BAD Response**

```text
   Contents: 
               OPTIONAL response code
               human-readable text
```

BAD 응답은 서버의 오류 메시지를 나타냅니다.  태그가 지정되면 클라이언트 명령의 프로토콜 수준 오류를 보고합니다. 태그는 오류를 일으킨 명령을 나타냅니다.  태그가 지정되지 않은 형식은 관련 명령을 확인할 수 없는 프로토콜 수준 오류를 나타냅니다. 내부 서버 오류를 나타낼 수도 있습니다.  사람이 읽을 수 있는 텍스트는 조건을 설명합니다.

```text
   Example:

     C: ...very long command line...
     S: * BAD Command line too long
     C: ...empty line...
     S: * BAD Empty command line
     C: A443 EXPUNGE
     S: * BAD Disk crash, attempting salvage to a new disk!
     S: * OK Salvage successful, no data lost
     S: A443 OK Expunge completed
```

---
#### **7.1.4.  PREAUTH Response**

```text
   Contents: 
               OPTIONAL response code
               human-readable text
```

PREAUTH 응답은 항상 태그가 지정되지 않으며 연결 시작 시 가능한 세 가지 인사말 중 하나입니다.  이는 연결이 이미 외부 수단에 의해 인증되었음을 나타냅니다. 따라서 LOGIN/AUTHENTICATE 명령이 필요하지 않습니다.

PREAUTH는 연결을 인증된 상태로 직접 이동시키기 때문에 클라이언트가 STARTTLS 명령\(섹션 6.2.1\)을 사용하는 것을 효과적으로 방지합니다.  이러한 이유로 PREAUTH 응답은 TLS로 보호되거나\(예: 암시적 TLS 포트\[RFC8314\]\) IPsec과 같은 다른 수단을 통해 보호되는 연결의 서버에서만 반환되어야 합니다.  필수 TLS가 필요한 클라이언트는 보호되지 않은 포트에서 PREAUTH 응답을 받은 후 연결을 닫아야 합니다.

```text
   Example:

     S: * PREAUTH IMAP4rev2 server logged in as Smith
```

---
#### **7.1.5.  BYE Response**

```text
   Contents: 
               OPTIONAL response code
               human-readable text
```

BYE 응답은 항상 태그가 지정되지 않으며 서버가 곧 연결을 닫을 것임을 나타냅니다.  사람이 읽을 수 있는 텍스트는 클라이언트의 상태 보고서에서 사용자에게 표시될 수 있습니다.  BYE 응답은 다음 네 가지 조건 중 하나에서 전송됩니다.

1. 정상적인 로그아웃 시퀀스의 일부로.  서버는 LOGOUT 명령에 대해 태그가 지정된 OK 응답을 보낸 후 연결을 닫습니다.

1. 패닉 셧다운 공지로.  서버는 즉시 연결을 닫습니다.

1. 비활성 자동 로그아웃을 공지합니다.  서버는 즉시 연결을 닫습니다.

1. 연결 시작 시 가능한 세 가지 인사말 중 하나로, 서버가 이 클라이언트로부터의 연결을 수락할 의사가 없음을 나타냅니다.  서버는 즉시 연결을 닫습니다.

일반적인 LOGOUT 시퀀스의 일부로 발생하는 BYE\(첫 번째 경우\)와 오류로 인해 발생하는 BYE\(나머지 세 가지 경우\)의 차이점은 오류가 발생한 경우 연결이 즉시 닫힌다는 것입니다.  모든 경우에 클라이언트는 연결이 닫힐 때까지 서버에서 응답 데이터를 계속 읽어야 합니다. 이렇게 하면 보류 중인 태그가 지정되지 않았거나 완료 응답을 읽고 처리할 수 있습니다.

```text
   Example:

     S: * BYE Autologout; idle for too long
```

---
### **7.2.  Server Responses - Server Status**

이러한 응답에는 항상 태그가 지정되지 않습니다.  이는 서버 상태 데이터가 서버에서 클라이언트로 전송되는 방식입니다.

---
#### **7.2.1.  ENABLED Response**

```text
   Contents:   capability listing
```

ENABLED 응답은 ENABLE 명령의 결과로 발생합니다.  기능 목록에는 서버가 지원하고 성공적으로 활성화된 기능 이름의 공백으로 구분된 목록이 포함되어 있습니다. ENABLED 응답에는 기능이 포함되어 있지 않을 수 있습니다. 이는 클라이언트가 나열한 확장이 성공적으로 활성화되지 않았음을 의미합니다.

```text
   Example:

     S: * ENABLED CONDSTORE QRESYNC
```

---
#### **7.2.2.  CAPABILITY Response**

```text
   Contents:   capability listing
```

CAPABILITY 응답은 CAPABILITY 명령의 결과로 발생합니다. 기능 목록에는 서버가 지원하는 기능 이름이 공백으로 구분된 목록이 포함되어 있습니다.  기능 목록에는 "IMAP4rev2" 원자가 포함되어야 하지만 이것이 나열된 첫 번째 기능일 필요는 없습니다.  기능 이름의 순서는 중요하지 않습니다.

클라이언트 및 서버 구현은 "AUTH=PLAIN"\(\[PLAIN\]에 설명됨\) 기능을 구현해야 하며 일반 텍스트 포트에서 "STARTTLS" 및 "LOGINDISABLED"를 구현해야 합니다.  이러한 기능과 관련된 중요한 정보는 보안 고려 사항\(섹션 11\)을 참조하세요.

"AUTH="로 시작하는 기능 이름은 서버가 해당 특정 인증 메커니즘\[SASL\]을 지원함을 나타냅니다.

LOGINDISABLED 기능은 LOGIN 명령이 비활성화되어 있으며 사용자 이름과 암호가 유효한 경우에도 서버가 LOGIN 명령을 사용하려는 시도에 대해 태그된 NO 응답으로 응답함을 나타냅니다\(유효성은 확인되지 않음\).  서버가 LOGINDISABLED 기능을 광고하는 경우 IMAP 클라이언트는 LOGIN 명령을 발행해서는 안 됩니다.

다른 기능 이름은 서버가 IMAP4rev2 프로토콜의 확장, 개정 또는 개정을 지원함을 나타냅니다.  IMAP4rev1 기능이 광고되지 않으면 클라이언트가 추가 기능을 사용하는 명령을 발행할 때까지 서버 응답은 이 문서를 준수해야 합니다.  IMAP4rev1 및 IMAP4rev2 기능이 모두 광고되는 경우 클라이언트가 추가 기능을 사용하는 명령을 발행할 때까지 서버 응답은 \[RFC3501\]을 준수해야 합니다.  \(예를 들어 클라이언트는 ENABLE IMAP4rev2를 실행하여 IMAP4rev2 관련 동작을 활성화할 수 있습니다.\)

기능 이름은 RFC 필수 정책 \[RFC8126\]을 사용하여 IANA에 등록되어야 합니다.  서버는 등록되지 않은 기능 이름을 제공해서는 안 됩니다.

클라이언트 구현은 "IMAP4rev2" 이외의 기능 이름을 요구해서는 안 되며 "STARTTLS" 및 "LOGINDISABLED"\(일반 텍스트 포트의 경우\)도 가능합니다.  클라이언트 구현은 알 수 없는 기능 이름을 무시해야 합니다\(MUST\).

서버는 초기 PREAUTH 또는 OK 응답에서 CAPABILITY 응답 코드를 사용하고 성공적인 인증의 일부로 태그가 지정된 OK 응답에서 업데이트된 CAPABILITY 응답 코드를 보내 자동으로 기능을 보낼 수 있습니다.  클라이언트가 이러한 자동 기능을 인식하고 TLS 및/또는 인증 상태가 수신된 이후 변경되지 않은 경우 별도의 CAPABILITY 명령을 보낼 필요가 없습니다.

서버가 반환하는 기능 목록은 연결 중에 변경될 수 있습니다.  특히 TLS 협상 성공\(STARTTLS 명령\) 및/또는 인증 성공\(AUTHENTICATE 또는 LOGIN 명령\) 후에 서버가 기능 목록을 변경하는 것이 매우 일반적입니다.

```text
   Example:

     S: * CAPABILITY STARTTLS AUTH=GSSAPI IMAP4rev2 LOGINDISABLED
      XPIG-LATIN
```

위의 예에서 XPIG-LATIN은 가상의 기능 이름입니다.

---
### **7.3.  Server Responses - Mailbox Status**

이러한 응답에는 항상 태그가 지정되지 않습니다.  이는 사서함 상태 데이터가 서버에서 클라이언트로 전송되는 방식입니다.  이러한 응답 중 다수는 일반적으로 동일한 이름을 가진 명령으로 인해 발생합니다.

---
#### **7.3.1.  LIST Response**

```text
   Contents: 
               name attributes
               hierarchy delimiter
               name
               OPTIONAL extension data
```

LIST 응답은 LIST 명령의 결과로 발생합니다.  LIST 사양과 일치하는 단일 이름을 반환합니다.  단일 LIST 명령에 대해 여러 LIST 응답이 있을 수 있습니다.

다음 기본 사서함 이름 특성이 정의됩니다.

\NonExistent - "\NonExistent" 특성은 사서함 이름이 기존 사서함을 참조하지 않음을 나타냅니다.  이 속성 자체는 의미가 없습니다. 정식 LIST 패턴과 일치하지만 존재하지 않는 사서함 이름은 아래 나열된 두 조건 중 하나도 충족하지 않는 한 반환되어서는 안 되기 때문입니다.

```text
      1.  The mailbox name also satisfies the selection criteria (for
          example, it is subscribed and the "SUBSCRIBED" selection
          option has been specified).

      2.  "RECURSIVEMATCH" has been specified, and the mailbox name has
          at least one descendant mailbox name that does not match the
          LIST pattern and does match the selection criteria.
```

- 실제로 이는 "\NonExistent" 특성이 일반적으로 "\Subscribed", "\Remote", "\HasChildren" 또는 CHILDINFO 확장 데이터 항목 중 하나 이상과 함께 반환됨을 의미합니다.

- "\NonExistent" 특성은 "\NoSelect"를 의미합니다.

\Noinferiors - 이 이름 아래에는 하위 계층 수준이 존재할 수 없습니다. 현재 하위 수준은 존재하지 않으며 앞으로도 만들 수 없습니다.

\Noselect - 이 이름을 선택 가능한 사서함으로 사용할 수 없습니다.

\HasChildren - 이 특성이 있으면 사서함에 하위 사서함이 있음을 나타냅니다.  하위 사서함이 있고 사용자가 그 중 어느 것에도 액세스할 수 있는 권한이 없는 경우 서버는 이 특성을 설정해서는 안 됩니다.  이 경우 \HasNoChildren을 사용해야 합니다. 그러나 대부분의 경우 서버는 사용자가 하위 사서함에 액세스할 수 있는지 여부를 효율적으로 계산하지 못할 수 있습니다.  사서함을 처리할 때 사서함의 \HasChildren 특성이 정확해야 하더라도 클라이언트는 사서함이 \HasChildren 특성으로 표시되어 있지만 하위 사서함이 나타나지 않는 상황을 처리할 준비가 되어 있어야 합니다. LIST 명령에 대한 응답입니다.  예를 들어, 서버가 하위 사서함을 나열할 수 있기 전에 다른 클라이언트가 하위 사서함을 삭제하거나 사용자가 액세스 제어를 사용하여 액세스할 수 없게 만든 경우에 이러한 상황이 발생할 수 있습니다.

\HasNoChildren - 이 특성이 있으면 사서함에 현재 인증된 사용자가 액세스할 수 있는 하위 사서함이 없음을 나타냅니다.

\Marked - 서버가 사서함을 "흥미로움"으로 표시했습니다. 사서함에는 마지막으로 사서함을 선택한 이후 추가된 메시지가 포함되어 있을 수 있습니다.

\표시 없음 - 마지막으로 사서함을 선택한 이후 사서함에 추가 메시지가 포함되어 있지 않습니다.

\Subscribed - SUBSCRIBE 명령을 사용하여 사서함 이름을 구독했습니다.

\Remote - 사서함이 원격 사서함입니다.

서버가 동일한 LIST 응답에서 \HasChildren 및 \HasNoChildren 속성을 모두 반환하는 것은 오류입니다.  \HasChildren 및 \HasNoChildren 특성이 모두 있는 LIST 응답을 받은 클라이언트는 LIST 응답에 두 특성이 모두 없는 것처럼 작동해야 합니다.

- 참고: \HasNoChildren 특성을 \NoInferiors 특성과 혼동해서는 안 됩니다. 이는 현재 하위 사서함이 존재하지 않으며 앞으로도 만들 수 없음을 나타냅니다.

서버가 사서함이 "흥미로운"지 여부를 결정하는 것이 가능하지 않은 경우 서버는 \Marked 또는 \Unmarked를 전송해서는 안 됩니다.  서버는 단일 사서함에 대해 \Marked, \Unmarked 및 \Noselect 중 하나 이상을 보내서는 안 되며 이들 중 어느 것도 보내지 않을 수 있습니다.

위에 정의된 기본 메일함 이름 속성 외에도 IMAP 서버는 메일함의 "역할"\(또는 "특수 용도"\)을 나타내는 다음 속성 중 일부 또는 전부를 포함할 수도 있습니다.  이러한 속성은 위에 정의된 기본 속성과 함께 포함됩니다.  특정 사서함에는 이러한 특성이 없거나 하나 또는 둘 이상이 있을 수 있습니다.  어떤 경우에는 클라이언트에게 해당 사서함에 무엇을 넣을지 조언하는 것이 특별한 용도로 사용됩니다.  다른 경우에는 그곳에서 무엇을 찾을 수 있는지에 대해 고객에게 조언합니다.

\All - 이 편지함은 사용자의 메시지 저장소에 있는 모든 메시지를 표시합니다. 구현에서는 \Trash 및 \Junk에 있는 메시지와 같은 일부 메시지를 생략할 수도 있습니다.  이 특별한 용도가 지원되면 가상 사서함을 나타내는 것이 거의 확실합니다.

\Archive - 이 사서함은 메시지를 보관하는 데 사용됩니다.  "보관" 사서함의 의미는 서버에 따라 다릅니다. 일반적으로 받은 편지함에서 메시지를 가져오거나 사용자가 접근할 수 없도록 하는 동시에 메시지에 접근할 수 없도록 하는 데 사용됩니다.

\Drafts - 이 사서함은 임시 메시지\(일반적으로 작성 중이지만 아직 전송되지 않은 메시지\)를 보관하는 데 사용됩니다.  일부 서버 구현에서는 "\Draft" 메시지 플래그로 표시된 다른 사서함의 메시지가 포함된 가상 사서함일 수 있습니다.  또는 고객이 여기에 초안을 넣으라는 조언일 수도 있습니다.

\플래그됨 - 이 사서함은 어떤 방식으로든 "중요"로 표시된 모든 메시지를 표시합니다.  이 특별한 사용이 지원되면 "\Flagged" 메시지 플래그로 표시된 메시지\(다른 사서함에서\)를 수집하는 가상 사서함을 나타낼 가능성이 높습니다.

\Junk - 이 사서함은 정크 메일로 간주되는 메시지가 보관되는 곳입니다. 일부 서버 구현에서는 여기에 자동으로 메시지를 넣을 수 있습니다. 또는 클라이언트 측 스팸 필터에 대한 조언일 수도 있습니다.

\Sent - 이 사서함은 보낸 메시지의 복사본을 보관하는 데 사용됩니다.  일부 서버 구현에서는 여기에 자동으로 메시지를 넣을 수 있습니다.  또는 클라이언트가 보낸 메시지를 여기에 저장하라는 조언일 수도 있습니다.

\Trash - 이 사서함은 삭제되었거나 삭제 표시된 메시지를 보관하는 데 사용됩니다.  일부 서버 구현에서는 "\Deleted" 메시지 플래그로 표시된 다른 사서함의 메시지가 포함된 가상 사서함일 수 있습니다.  또는 IMAP "\Deleted" 모델을 사용하지 않기로 선택한 클라이언트가 휴지통 위치로 사용해야 한다는 조언일 수도 있습니다.  IMAP "\Deleted" 모델을 엄격하게 요구하는 서버 구현에서는 이 특별한 사용이 지원되지 않을 가능성이 높습니다.

모든 특수 용도 속성은 선택 사항이며 특정 서버 또는 메시지 저장소는 속성 조합을 지원하거나 전혀 지원하지 않을 수 있습니다.  대부분의 경우 특정 사용자에 대해 지정된 속성을 가진 메일함은 최대 하나일 수 있지만 일부 서버 또는 메시지 저장소 구현에서는 여러 메일함이 동일한 특수 용도 속성을 가질 수도 있습니다.

특수 용도 속성은 사용자별로 다를 수 있습니다.  사용자 Adam은 자신의 \Sent 사서함을 Barb 사용자와 공유할 수 있지만 해당 사서함이 Barb의 \Sent 사서함 역할도 할 가능성은 거의 없습니다.

다른 사서함 이름 속성은 "IMAP 사서함 이름 속성" 레지스트리 \[IMAP-MAILBOX-NAME-ATTRS-REG\]에서 찾을 수 있습니다.

계층 구분 기호는 사서함 이름에서 계층 수준을 구분하는 데 사용되는 문자입니다.  클라이언트는 이를 사용하여 하위 사서함을 만들고 더 높거나 낮은 수준의 이름 지정 계층을 검색할 수 있습니다. 최상위 계층 노드의 모든 하위 항목은 동일한 구분 문자를 사용해야 합니다.  NIL 계층 구조 구분 기호는 계층 구조가 존재하지 않음을 의미합니다. 이름은 "단순한" 이름입니다.

이름은 왼쪽에서 오른쪽으로의 명확한 계층 구조를 나타내며 LIST 명령에서 참조로 사용하기에 유효해야 합니다.  \Noselect 또는 \NonExistent가 표시되지 않는 한 이름은 사서함 이름을 허용하는 SELECT와 같은 명령의 인수로도 유효해야 합니다.

이름 뒤에는 태그가 지정된 데이터\("확장 데이터 항목"이라고도 함\)의 괄호로 묶인 목록인 선택적 확장 필드 시리즈가 올 수 있습니다.  확장 필드의 첫 번째 요소는 데이터 유형을 식별하는 문자열입니다.  \[RFC5258\]은 문자열 등록\("태그"라고 함. 이러한 태그를 IMAP 명령 태그와 혼동하지 말 것\)에 대한 요구 사항을 지정합니다. 특히, "태그는 IANA에 등록되어야 합니다"라고 명시되어 있습니다.  이 문서는 이를 변경하지 않습니다.  등록 템플릿은 \[RFC5258\]의 섹션 9.5를 참조하세요. 서버는 해당 LIST 명령에서 클라이언트가 직접 요청하지 않은 확장 필드의 데이터를 반환할 수 있습니다. 예를 들어 클라이언트는 확장된 LIST 응답을 활용하는 다른 IMAP 확장을 사용하여 추가 확장 필드를 활성화할 수 있습니다. 클라이언트는 인식하지 못하는 모든 확장 필드를 무시해야 합니다.

```text
   Example:

     S: * LIST (\Noselect) "/" ~/Mail/foo

   Example:

     S: * LIST (\Marked) ":" Tables (tablecloth (("edge" "lacy")
         ("color" "red")) Sample "text")
     S: * LIST () ":" Tables:new (tablecloth ("edge" "lacy")
         Sample ("text" "more text"))
```

---
#### **7.3.2.  NAMESPACE Response**

```text
   Contents:   the prefix and hierarchy delimiter to the server's
               Personal Namespace(s), Other Users' Namespace(s), and
               Shared Namespace(s)
```

NAMESPACE 응답은 NAMESPACE 명령의 결과로 발생합니다.  여기에는 서버가 노출하려는 서버의 개인 네임스페이스, 다른 사용자의 네임스페이스 및 공유 네임스페이스에 대한 접두사 및 계층 구분 기호가 포함됩니다.  응답에는 사용할 수 없는 네임스페이스 클래스에 대한 NIL이 포함됩니다.  Namespace-Response- Extensions ABNF 비터미널은 확장성을 위해 정의되며 응답에 포함될 수 있습니다.

```text
   Example:

     S: * NAMESPACE (("" "/")) (("~" "/")) NIL
```

---
#### **7.3.3.  STATUS Response**

```text
   Contents: 
               name
               status parenthesized list
```

STATUS 응답은 STATUS 명령의 결과로 발생합니다.  STATUS 사양과 일치하는 사서함 이름과 요청된 사서함 상태 정보를 반환합니다.

```text
   Example:

     S: * STATUS blurdybloop (MESSAGES 231 UIDNEXT 44292)
```

---
#### **7.3.4.  ESEARCH Response**

내용: 하나 이상의 검색-반환-데이터 쌍

ESEARCH 응답은 SEARCH 또는 UID SEARCH 명령의 결과로 발생합니다.

ESEARCH 응답은 선택적 검색 상관기로 시작됩니다.  누락된 경우 특정 IMAP 명령으로 인해 응답이 발생하지 않은 것이며, 존재하는 경우 응답을 반환한 명령의 태그가 포함되어 있습니다.

검색 상관자 뒤에는 선택적 UID 표시기가 옵니다.  이 표시기가 있으면 ESEARCH 응답의 모든 데이터는 UID를 참조합니다. 그렇지 않으면 반환된 모든 데이터는 메시지 번호를 참조합니다.

ESEARCH 응답의 나머지 부분에는 하나 이상의 검색 데이터 쌍이 포함되어 있습니다.  각 쌍은 고유한 반품 항목 이름으로 시작하고 그 뒤에 공백과 해당 데이터가 옵니다.  검색 데이터 쌍은 어떤 순서로든 반환될 수 있습니다.  확장 프로그램에서 달리 지정하지 않는 한 모든 반품 항목 이름은 ESEARCH 응답에서 한 번만 나타나야 합니다.

이 문서에서는 다음과 같은 반품 품목 이름을 지정합니다.

MIN - 검색 기준을 충족하는 가장 낮은 메시지 번호/UID를 반환합니다.

- 검색 결과 일치 항목이 없으면 서버는 ESEARCH 응답에 MIN 반환 항목을 포함해서는 안 됩니다. 그러나 여전히 ESEARCH 응답을 보내야 합니다.

MAX - 검색 기준을 충족하는 가장 높은 메시지 번호/UID를 반환합니다.

- 검색 결과 일치 항목이 없으면 서버는 ESEARCH 응답에 MAX 반환 항목을 포함해서는 안 됩니다. 그러나 여전히 ESEARCH 응답을 보내야 합니다.

ALL - 시퀀스 세트 구문을 사용하여 검색 기준을 충족하는 모든 메시지 번호/UID를 반환합니다.  각 세트는 반드시 완료되어야 합니다. 특히 UID 세트는 범위의 각 숫자가 기존\(일치하는\) 메시지에 해당하는 경우에만 ESEARCH 응답으로 반환됩니다.  클라이언트는 메시지/UID가 특정 순서로 나열될 것이라고 가정해서는 안 됩니다.

- 검색 결과 일치 항목이 없으면 서버는 ESEARCH 응답에 ALL 반환 항목을 포함해서는 안 됩니다. 그러나 여전히 ESEARCH 응답을 보내야 합니다.

COUNT - 검색 기준을 만족하는 메시지 수를 반환합니다. 이 반환 항목은 항상 ESEARCH 응답에 포함되어야 합니다.

```text
   Example:

     S: * ESEARCH UID COUNT 17 ALL 4:18,21,28

   Example:

     S: * ESEARCH (TAG "a567") UID COUNT 17 ALL 4:18,21,28

   Example:

     S: * ESEARCH COUNT 18 ALL 1:17,21
```

---
#### **7.3.5.  FLAGS Response**

```text
   Contents:   flag parenthesized list
```

FLAGS 응답은 SELECT 또는 EXAMINE 명령의 결과로 발생합니다. 괄호로 묶인 플래그 목록은 이 사서함에 적용할 수 있는 플래그\(최소한 시스템 정의 플래그\)를 식별합니다.  서버 구현에 따라 시스템 플래그 이외의 플래그도 존재할 수 있습니다.

FLAGS 응답의 업데이트는 클라이언트에 의해 기억되어야 합니다.

```text
   Example:

     S: * FLAGS (\Answered \Flagged \Deleted \Seen \Draft)
```

---
### **7.4.  Server Responses - Mailbox Size**

이러한 응답에는 항상 태그가 지정되지 않습니다.  이것이 메일박스 크기의 변화가 서버에서 클라이언트로 전송되는 방식입니다. "\*" 토큰 바로 뒤에는 메시지 수를 나타내는 숫자가 있습니다.

---
#### **7.4.1.  EXISTS Response**

```text
   Contents:   none
```

EXISTS 응답은 사서함에 있는 메시지 수를 보고합니다. 이 응답은 SELECT 또는 EXAMINE 명령의 결과로 그리고 메일함의 크기가 변경된 경우\(예: 새 메시지\) 발생합니다.

EXISTS 응답의 업데이트는 클라이언트에 의해 기억되어야 합니다.

```text
   Example:

     S: * 23 EXISTS
```

---
### **7.5.  Server Responses - Message Status**

이러한 응답에는 항상 태그가 지정되지 않습니다.  이는 동일한 이름을 가진 명령의 결과로 메시지 데이터가 서버에서 클라이언트로 전송되는 방식입니다.  "\*" 토큰 바로 뒤에는 메시지 시퀀스 번호를 나타내는 숫자가 있습니다.

---
#### **7.5.1.  EXPUNGE Response**

```text
   Contents:   none
```

EXPUNGE 응답은 지정된 메시지 시퀀스 번호가 메일함에서 영구적으로 제거되었음을 보고합니다.  메일함의 각 연속 메시지에 대한 메시지 시퀀스 번호는 즉시 1씩 감소하며, 이 감소는 후속 응답\(태그가 지정되지 않은 다른 EXPUNGE 응답 포함\)의 메시지 시퀀스 번호에 반영됩니다.

EXPUNGE 응답은 또한 메일함의 메시지 수를 감소시킵니다. 새로운 값으로 EXISTS 응답을 보낼 필요는 없습니다.

즉시 감소 규칙의 결과로, 일련의 연속적인 EXPUNGE 응답에 나타나는 메시지 시퀀스 번호는 메시지가 낮은 숫자에서 높은 숫자로 제거되는지, 아니면 높은 숫자에서 낮은 숫자로 제거되는지에 따라 달라집니다.  예를 들어, 9개 메시지로 구성된 사서함의 마지막 5개 메시지가 삭제되는 경우 "낮은 것에서 높은 것" 서버는 메시지 시퀀스 번호 5에 대해 태그가 지정되지 않은 5개의 EXPUNGE 응답을 보내는 반면, "높은 것에서 낮은 것" 서버는 태그가 없는 연속적인 EXPUNGE 응답을 보냅니다. 메시지 시퀀스 번호 9, 8, 7, 6 및 5의 경우.

EXPUNGE 응답은 진행 중인 명령이 없거나 FETCH, STORE 또는 SEARCH 명령에 응답하는 동안 전송되어서는 안 됩니다.  이 규칙은 클라이언트와 서버 간의 메시지 시퀀스 번호 동기화 손실을 방지하는 데 필요합니다.  완전한 명령이 수신될 때까지 명령은 "진행 중"이 아닙니다. 특히 명령 지속 협상 중에는 명령이 "진행 중"이 아닙니다.

- 참고: UID FETCH, UID STORE 및 UID SEARCH는 FETCH, STORE 및 SEARCH와 다른 명령입니다.  EXPUNGE 응답은 UID 명령 중에 전송될 수 있습니다.

클라이언트는 EXPUNGE 응답의 업데이트를 기억해야 합니다.

```text
   Example:

     S: * 44 EXPUNGE
```

---
#### **7.5.2.  FETCH Response**

```text
   Contents:   message data
```

FETCH 응답은 메시지에 대한 데이터를 클라이언트에 반환합니다.  데이터는 데이터 항목 이름의 쌍이며 해당 값은 괄호 안에 표시됩니다.  이 응답은 FETCH 또는 STORE 명령의 결과뿐만 아니라 일방적인 서버 결정\(예: 플래그 업데이트\)에 의해 발생합니다.

현재 데이터 항목은 다음과 같습니다.

BINARY\[<section-binary\>\]<<number\>\> - 해당 Content-Transfer-Encoding 헤더 필드에 지정된 인코딩을 제거한 후 지정된 섹션의 콘텐츠를 표현하는 <nstring\> 또는 <literal8\>입니다.  <number\>가 있으면 DECODED 섹션 데이터 내의 오프셋을 나타냅니다.

- 디코딩된 데이터의 도메인이 "8비트"이고 데이터에 NUL 옥텟이 포함되어 있지 않은 경우 서버는 <literal8\> 대신 <string\>으로 데이터를 반환해야 합니다. 이를 통해 클라이언트는 데이터 스트림에서 NUL을 명시적으로 스캔하지 않고도 "8비트" 데이터에 NUL 옥텟이 포함되어 있는지 확인할 수 있습니다.

- 메시징 클라이언트와 서버는 인터넷 프로토콜에서 텍스트 데이터\(텍스트/\* 미디어 유형\) 줄을 종료하기 위한 인터넷 CRLF 규칙을 준수하는 데 있어서 매우 느슨했습니다.  BINARY\[...\] FETCH 데이터 항목으로 데이터를 보낼 때 서버는 서버에 있는 데이터의 기본 저장소 표현에 관계없이 텍스트 라인 지향 섹션이 항상 IMAP CRLF 라인 종료 구문을 사용하여 전송되도록 해야 합니다.

- 서버가 섹션의 Content-Transfer-Encoding을 디코딩하는 방법을 모르는 경우 요청을 실패하고 "UNKNOWN-CTE" 응답 코드가 포함된 "NO" 응답을 발행해야 합니다.

BINARY.SIZE\[<section-binary\>\] - 해당 Content-Transfer-Encoding 헤더 필드에 지정된 인코딩을 제거한 후 섹션의 크기입니다.  반환된 값은 해당 FETCH BINARY 요청에 의해 반환될 <nstring\> 또는 <literal8\>의 크기와 일치해야 합니다.

- 서버가 섹션의 Content-Transfer-Encoding을 디코딩하는 방법을 모르는 경우 요청을 실패하고 "UNKNOWN-CTE" 응답 코드가 포함된 "NO" 응답을 발행해야 합니다.

BODY - 확장 데이터가 없는 BODYSTRUCTURE 형식입니다.

BODY\[<섹션\>\]<<원본 옥텟\>\> - 지정된 섹션의 본문 내용을 표현하는 문자열입니다. 문자열은 콘텐츠 전송 인코딩, 본문 유형 및 하위 유형에 따라 클라이언트에 의해 해석되어야 합니다.

- 원본 옥텟이 지정된 경우 이 문자열은 해당 원본 옥텟에서 시작하는 전체 본문 내용의 하위 문자열입니다.  즉, BODY\[\]<0\>은 잘릴 수 있지만 BODY\[\]는 절대 잘리지 않습니다.

- 참고: 원본 옥텟 기능은 클라이언트가 BODY\[<section\>\]<<partial\>\> 데이터 항목의 FETCH를 통해 특별히 요청하지 않는 한 FETCH 응답에서 서버에 의해 사용되어서는 안 됩니다.

- \[CHARSET\] 식별자가 이 섹션에 대해 괄호로 묶인 본문 매개변수 목록의 일부인 경우 8비트 텍스트 데이터가 허용됩니다.  헤더\(부분 지정자 HEADER 또는 MIME 또는 MESSAGE/RFC822 또는 MESSAGE/GLOBAL 부분의 헤더 부분\)는 UTF-8일 수 있습니다. 또한 헤더와 본문 사이의 빈 줄을 구분하는 \[RFC5322\]는 UTF-8이 아닙니다. 헤더 라인 하위 설정의 영향을 받습니다. 본문이나 빈 줄이 없는 메시지의 경우를 제외하고 빈 줄은 항상 헤더 데이터의 일부로 포함됩니다.

- 바이너리 데이터와 같은 비텍스트 데이터는 클라이언트에 전송되기 전에 반드시 base64와 같은 텍스트 형식으로 인코딩되어 전송되어야 합니다. 원본 바이너리 데이터를 파생하려면 클라이언트가 전송 인코딩된 문자열을 디코딩해야 합니다.

BODYSTRUCTURE - 메시지의 \[MIME-IMB\] 본문 구조를 설명하는 괄호로 묶인 목록입니다.  이는 \[MIME-IMB\] 헤더 필드를 구문 분석하고 필요에 따라 다양한 필드를 기본값으로 설정하여 서버에서 계산됩니다.

- 예를 들어 48줄, 2279옥텟으로 구성된 간단한 텍스트 메시지의 본문 구조는 다음과 같습니다.

```text
         ("TEXT" "PLAIN" ("CHARSET" "US-ASCII") NIL NIL "7BIT" 2279 48)
```

- 여러 부분은 괄호 중첩으로 표시됩니다.  괄호로 묶인 목록의 첫 번째 요소인 신체 유형 대신 하나 이상의 중첩된 신체 구조의 시퀀스가 ​​있습니다.  괄호 안에 있는 목록의 두 번째 요소는 다중 부분 하위 유형\(혼합, 다이제스트, 병렬, 대체 등\)입니다.

- 예를 들어 텍스트와 base64로 인코딩된 텍스트 첨부 파일로 구성된 두 부분으로 구성된 메시지의 본문 구조는 다음과 같습니다.

```text
         (("TEXT" "PLAIN" ("CHARSET" "US-ASCII") NIL NIL "7BIT" 1152 23)
          ("TEXT" "PLAIN" ("CHARSET" "US-ASCII" "NAME" "cc.diff")
          "<960723163407.20117h@cac.washington.edu>" "Compiler diff"
          "BASE64" 4554 73) "MIXED")
```

- 확장 데이터는 다중 부분 하위 유형을 따릅니다.  확장 데이터는 BODY 가져오기를 통해 반환되지 않지만 BODYSTRUCTURE 가져오기를 통해 반환될 수 있습니다.  확장 데이터가 있는 경우 정의된 순서대로 있어야 합니다.  다중 부분 본문 부분의 확장 데이터는 다음 순서로 되어 있습니다.

본문 매개변수 괄호로 묶인 목록 - 속성/값 쌍의 괄호로 묶인 목록\(예: \("foo" "bar" "baz" "rag"\) 여기서 "bar"는 "foo"의 값이고 "rag"는 다음의 값입니다. "baz"\)는 \[MIME-IMB\]에 정의되어 있습니다.  서버는 \[RFC2231\]에 설명된 대로 매개변수-값 연속 및 매개변수-값 문자 집합을 디코딩해야 합니다. 예를 들어 메시지에 매개변수 "baz\*0", "baz\*1" 및 "baz\*2"가 포함된 경우 서버는 다음을 수행해야 합니다. \[RFC2231\]에 따라 디코딩하고 연결한 후 결과 값을 "baz" 매개변수로 반환합니다.  마찬가지로, 메시지에 "foo\*0\*" 및 "foo\*1\*" 매개변수가 포함된 경우 서버는 \[RFC2231\]에 따라 이를 디코딩하고 UTF-8로 변환한 후 연결하고 결과 값을 "foo\* 매개변수로 반환해야 합니다. ".

본문 처리 - 처리 유형 문자열과 그 뒤에 \[DISPOSITION\]에 정의된 대로 처리 속성/값 쌍의 괄호로 묶인 목록으로 구성된 괄호로 묶인 목록입니다.  서버는 \[RFC2231\]에 설명된 대로 매개변수 값 연속을 디코딩해야 합니다.

신체 언어 - \[LANGUAGE-TAGS\]에 정의된 신체 언어 값을 제공하는 문자열 또는 괄호로 묶인 목록입니다.

본문 위치 - \[LOCATION\]에 정의된 본문 콘텐츠 URI를 제공하는 문자열입니다.

- 다음 확장 데이터는 이 프로토콜 버전에서 아직 정의되지 않았습니다.  이러한 확장 데이터는 0개 이상의 NIL, 문자열, 숫자 또는 잠재적으로 중첩된 괄호로 묶인 해당 데이터 목록으로 구성될 수 있습니다.  BODYSTRUCTURE 가져오기를 수행하는 클라이언트 구현은 이러한 확장 데이터를 허용하도록 준비되어야 합니다.  서버 구현은 이 프로토콜의 개정판에 의해 정의될 때까지 그러한 확장 데이터를 전송해서는 안 됩니다.

- 다중 부분이 아닌 본문 부분의 기본 필드는 다음과 같은 순서로 되어 있습니다.

본문 유형 - \[MIME-IMB\]에 정의된 콘텐츠 미디어 유형 이름을 제공하는 문자열입니다.

본문 하위 유형 - \[MIME-IMB\]에 정의된 콘텐츠 하위 유형 이름을 제공하는 문자열입니다.

본문 매개변수 괄호로 묶인 목록 - 속성/값 쌍의 괄호로 묶인 목록\(예: \("foo" "bar" "baz" "rag"\) 여기서 "bar"는 "foo"의 값이고 "rag"는 다음의 값입니다. "baz"\)는 \[MIME-IMB\]에 정의되어 있습니다.

body id - \[MIME-IMB\]의 섹션 7에 정의된 대로 Content-ID 헤더 필드 값을 제공하는 문자열입니다.

본문 설명 - \[MIME-IMB\]의 섹션 8에 정의된 대로 Content-Description 헤더 필드 값을 제공하는 문자열입니다.

본문 인코딩 - \[MIME-IMB\]의 섹션 6에 정의된 대로 콘텐츠 전송 인코딩을 제공하는 문자열입니다.

몸체 크기 - 몸체의 크기를 옥텟 단위로 나타내는 숫자입니다.  이 크기는 전송 인코딩의 크기이지 디코딩 후의 결과 크기가 아닙니다.

- MESSAGE 유형 및 하위 유형 RFC822의 본문 유형에는 기본 필드 바로 뒤에 봉투 구조, 본문 구조 및 캡슐화된 메시지의 텍스트 줄 크기가 포함됩니다.

- TEXT 유형의 본문 유형에는 기본 필드 바로 뒤에 텍스트 줄의 본문 크기가 포함됩니다.  이 크기는 콘텐츠 전송 인코딩의 크기이지 디코딩 후 결과 크기가 아닙니다.

- 확장 데이터는 위에 나열된 기본 필드와 유형별 필드를 따릅니다.  확장 데이터는 BODY 가져오기를 통해 반환되지 않지만 BODYSTRUCTURE 가져오기를 통해 반환될 수 있습니다. 확장 데이터가 있는 경우 정의된 순서대로 있어야 합니다.

- 다중 부분이 아닌 본문 부분의 확장 데이터는 다음과 같은 순서로 되어 있습니다.

본체 MD5 - \[MD5\]에 정의된 본체 MD5 값을 제공하는 문자열입니다.

본문 처리 - 다중 부분 본문 부분에 대한 본문 처리와 동일한 내용 및 기능을 포함하는 괄호로 묶인 목록입니다.

신체 언어 - \[LANGUAGE-TAGS\]에 정의된 신체 언어 값을 제공하는 문자열 또는 괄호로 묶인 목록입니다.

본문 위치 - \[LOCATION\]에 정의된 본문 콘텐츠 URI를 제공하는 문자열입니다.

- 다음 확장 데이터는 이 버전의 프로토콜에서 아직 정의되지 않았으며 위의 다중 부분 확장 데이터에서 설명한 것과 같습니다.

ENVELOPE - 메시지의 봉투 구조를 설명하는 괄호로 묶인 목록입니다.  이는 \[RFC5322\] 헤더를 구성 요소 부분으로 구문 분석하고 필요에 따라 다양한 필드를 기본값으로 설정하여 서버에서 계산됩니다.

- 봉투 구조의 필드는 날짜, 제목, 보낸 사람, 보낸 사람, 회신 대상, 받는 사람, 참조, 숨은 참조, 회신 대상, 메시지 ID의 순서로 되어 있습니다.  날짜, 제목, 회신 대상 및 메시지 ID 필드는 문자열입니다.  보낸 사람, 보낸 사람, 회신 대상, 받는 사람, 참조 및 숨은 참조 필드는 괄호로 묶인 주소 구조 목록입니다.

- 주소 구조는 전자 메일 주소를 설명하는 괄호 안의 목록입니다.  주소 구조의 필드는 표시 이름, \[SMTP\] at-domain-list\(\[RFC5322\]의 소스 경로 및 obs-route ABNF 생성\), 메일함 이름\(\[RFC5322\]의 로컬 부분 ABNF 생성\)의 순서로 되어 있습니다. \) 및 호스트 이름.

- \[RFC5322\] 그룹 구문은 호스트 이름 필드가 NIL인 특수한 형태의 주소 구조로 표시됩니다.  사서함 이름 필드도 NIL인 경우 이는 그룹 끝 표시\(RFC 822 구문의 세미콜론\)입니다.  사서함 이름 필드가 NIL이 아닌 경우 이는 그룹 표시의 시작이고 사서함 이름 필드에는 그룹 이름 문구가 포함됩니다.

- \[RFC5322\] 헤더에 날짜, 제목, In-Reply-To 및 Message-ID 헤더 필드가 없으면 봉투의 해당 구성원은 NIL입니다. 이러한 헤더 필드가 있지만 비어 있는 경우 봉투의 해당 멤버는 빈 문자열입니다.

- 참고: 일부 서버는 "현재는 있지만 비어 있는" 경우 NIL 봉투 구성원을 반환할 수 있습니다.  클라이언트는 NIL과 빈 문자열을 동일하게 처리해야 합니다\(SHOULD\).

- 참고: \[RFC5322\]에서는 모든 메시지에 유효한 날짜 헤더 필드가 있어야 합니다.  따라서 올바른 형식의 메시지의 경우 봉투의 날짜 멤버는 NIL이거나 빈 문자열일 수 없습니다. 그러나 형식이 잘못된 메시지나 초안 메시지의 경우 NIL이 될 수 있습니다.

- 참고: \[RFC5322\]에서는 In-Reply-To 및 Message-ID 헤더 필드\(있는 경우\)에 비어 있지 않은 콘텐츠가 있어야 합니다.  따라서 올바른 형식의 메시지의 경우 봉투의 in-reply-to 및 message-id 멤버는 빈 문자열일 수 없습니다.  그러나 잘못된 형식의 메시지에 대해서는 여전히 빈 문자열일 수 있습니다.

- \[RFC5322\] 헤더에 From, To, Cc 및 Bcc 헤더 필드가 없거나 존재하지만 비어 있는 경우 봉투의 해당 멤버는 NIL입니다.

- Sender 또는 Reply-To 헤더 필드가 \[RFC5322\] 헤더에 없거나 존재하지만 비어 있는 경우 서버는 봉투의 해당 멤버를 from 멤버와 동일한 값으로 설정합니다\(클라이언트는 이를 수행하는 방법을 알고 있습니다\).

- 참고: \[RFC5322\]에서는 모든 메시지에 유효한 From 헤더 필드가 있어야 합니다.  따라서 올바른 형식의 메시지의 경우 봉투의 보낸 사람, 보낸 사람 및 회신 구성원은 NIL일 수 없습니다. 그러나 형식이 잘못된 메시지나 초안 메시지의 경우에는 NIL이 될 수 있습니다.

FLAGS - 이 메시지에 대해 설정된 플래그의 괄호 안에 있는 목록입니다.

INTERNALDATE - 메시지의 내부 날짜를 나타내는 문자열입니다.

RFC822.SIZE - 섹션 2.3.4에 설명된 대로 메시지 크기를 표현하는 숫자입니다.

UID - 메시지의 고유 식별자를 나타내는 숫자입니다.

서버가 원치 않는 FETCH 응답을 보내기로 선택한 경우 UID FETCH 항목을 포함해야 합니다.  이는 \[RFC3501\]과 비교할 때 새로운 요구 사항입니다.

```text
   Example:

     S: * 23 FETCH (FLAGS (\Seen) RFC822.SIZE 44827 UID 447)
```

---
### **7.6.  Server Responses - Command Continuation Request**

명령 계속 요청 응답은 태그 대신 "+" 토큰으로 표시됩니다.  이 응답 형식은 서버가 클라이언트의 명령을 계속 받아들일 준비가 되었음을 나타냅니다.  이 응답의 나머지 부분은 텍스트 한 줄입니다.

이 응답은 AUTHENTICATE 명령에서 서버 데이터를 클라이언트에 전송하고 추가 클라이언트 데이터를 요청하는 데 사용됩니다.  이 응답은 명령에 대한 인수가 동기화 리터럴인 경우에도 사용됩니다.

서버가 예상되는 것으로 나타내지 않는 한 클라이언트는 동기화 리터럴의 옥텟을 보내는 것이 허용되지 않습니다.  이를 통해 서버는 한 줄씩 명령을 처리하고 오류를 거부할 수 있습니다.  명령을 종료하는 CRLF를 포함하여 명령의 나머지 부분은 리터럴의 옥텟 뒤에 옵니다.  추가 명령 인수가 있는 경우 리터럴 옥텟 뒤에 공백과 해당 인수가 옵니다.

```text
   Example:

     C: A001 LOGIN {11}
     S: + Ready for additional command text
     C: FRED FOOBAR {7}
     S: + Ready for additional command text
     C: fat man
     S: A001 OK LOGIN completed
     C: A044 BLURDYBLOOP {102856}
     S: A044 BAD No such command as "BLURDYBLOOP"
```

---
## **8.  Sample IMAP4rev2 Connection**

다음은 비 TLS 포트에서의 IMAP4rev2 연결 기록입니다.  이 샘플의 긴 줄은 편집의 명확성을 위해 끊어졌습니다.

S: \* OK \[CAPABILITY STARTTLS AUTH=SCRAM-SHA-256 LOGINDISABLED IMAP4rev2\] IMAP4rev2 서비스 준비됨 C: a000 starttls S: a000 OK TLS 협상 진행 <TLS 협상\> C: A001 AUTHENTICATE SCRAM-SHA-256 biwsbj11c2VyLHI9ck9wck5HZndFYmVSV2diT kVrcU8= S: + cj1yT3ByTkdmd0ViZVJXZ2JORWtxTyVodllEcFdVYTJSYVRDQWZ1eEZJbGopaE 5sRiRrMCxzPVcyMlphSjBTTlk3c29Fc1VFamI2Z1E9PSxpPTQwOTY= C: SV2diTkVrcU8laHZZRHBXVWEyUmFUQ0FmdXhG SWxqKWhObEYkazAscD1kSHpiWmFwV0lrNGpVaE4rVXRlOXl0YWc5epmTUhnc3Ft bWl6N0FuZFZRPQ== S: + dj02cnJpVFJCaTIzV3BSUi93dHVw K21NaFVaVW4vZEI1bkxUSlJzamw5NUc0 PQ== C: S: A001 OK SCRAM-SHA-256 인증 성공 C: babc ENABLE IMAP4rev2 S: \* ENABLED IMAP4rev2 S: babc OK 일부 기능 활성화됨 C: a002 받은 편지함 선택 S: \* 18 존재 S: \* FLAGS \(\답변 \플래그 \삭제 \본 \초안\) S: \* 확인 \[UIDVALIDITY 3857529045\] 유효한 UID S: \* LIST \(\) "/" INBOX \("OLDNAME" \("받은 편지함\) "\)\) S: a002 OK \[READ-WRITE\] SELECT 완료 C: a003 12 전체 가져오기 S: \* 12 FETCH \(FLAGS \(\Seen\) INTERNALDATE "17-Jul-1996 02:44:25 -0700" RFC822.SIZE 4286 ENVELOPE \( "1996년 7월 17일 수요일 02:23:25 -0700 \(PDT\)" "IMAP4rev2 WG mtg 요약 및 분" \(\("Terry Gray" NIL "gray" "cac.washington.edu"\)\) \(\("Terry 회색" NIL "회색" "cac.washington.edu"\)\) \(\("Terry Grey" NIL "회색" "cac.washington.edu"\)\) \(\(NIL NIL "imap" "cac.washington.edu"\)\) \(\(NIL NIL "분" "CNRI.Reston.VA.US"\) \("John Klensin" NIL "KLENSIN" "MIT.EDU"\)\) NIL NIL "<B27397-0100000@cac.washington.ed\>"\) BODY \("TEXT" "PLAIN" \("CHARSET" "US-ASCII"\) NIL NIL "7BIT" 3028 92\)\) S: a003 OK FETCH 완료 C: a004 fetch 12 body\[header\] S: \* 12 FETCH \(BODY\[HEADER \] {342} S: 날짜: 1996년 7월 17일 수요일 02:23:25 -0700\(PDT\) S: 보낸 사람: Terry Gray <gray@cac.washington.edu\> S: 제목: IMAP4rev2 WG mtg 요약 및 회의록 S: 받는 사람: imap@cac.washington.edu S: 참조: Minute@CNRI.Reston.VA.US, John Klensin <KLENSIN@MIT.EDU\> S: 메시지 ID: <B27397-0100000@cac.washington.edu\> S : MIME 버전: 1.0 S: 콘텐츠 유형: TEXT/PLAIN; CHARSET=US-ASCII S: S: \) S: a004 OK FETCH 완료 C: a005 store 12 +flags \deleted S: \* 12 FETCH \(FLAGS \(\Seen \Deleted\)\) S: a005 OK +FLAGS 완료 C: a006 로그아웃 S: \* BYE IMAP4rev2 서버가 연결을 종료하고 있습니다. S: a006 OK LOGOUT 완료

---
## **9.  Formal Syntax**

다음 구문 사양은 \[ABNF\]에 지정된 ABNF\(Augmented Backus-Naur Form\) 표기법을 사용합니다.

이후 규칙이 이전 규칙과 겹치는 대체 또는 선택적 규칙의 경우 이전에 나열된 규칙이 우선 순위를 가져야 합니다.  예를 들어, 플래그로 구문 분석될 때 "\Seen"은 플래그 확장이 아닌 \Seen 플래그 이름입니다. 하지만 "\Seen"은 플래그 확장으로 구문 분석될 수 있습니다.  전부는 아니지만 이 규칙의 일부 사례가 아래에 설명되어 있습니다.

참고: \[ABNF\] 규칙을 엄격히 준수해야 합니다. 특히:

1. 달리 명시하지 않는 한 모든 알파벳 문자는 대소문자를 구분하지 않습니다.  토큰 문자열을 정의하기 위해 대문자 또는 소문자를 사용하는 것은 편집상의 명확성을 위해서만 사용됩니다. 구현에서는 이러한 문자열을 대소문자를 구분하지 않고 허용해야 합니다.

1. 모든 경우에 SP는 정확히 하나의 공백을 나타냅니다.  TAB을 대체하거나, 추가 공백을 삽입하거나, SP를 선형 공백\(LWSP\)과 동일하게 처리하는 것은 허용되지 않습니다.

1. OCTET 생성을 제외하고 ASCII NUL 문자 %x00은 어디에도 사용되어서는 안 됩니다.

```text
   SP              = <Defined in RFC 5234>
   CTL             = <Defined in RFC 5234>
   CRLF            = <Defined in RFC 5234>
   ALPHA           = <Defined in RFC 5234>
   DIGIT           = <Defined in RFC 5234>
   DQUOTE          = <Defined in RFC 5234>
   OCTET           = <Defined in RFC 5234>

   address         = "(" addr-name SP addr-adl SP addr-mailbox SP
                     addr-host ")"

   addr-adl        = nstring
                       ; Holds route from [RFC5322] obs-route if
                       ; non-NIL

   addr-host       = nstring
                       ; NIL indicates [RFC5322] group syntax.
                       ; Otherwise, holds [RFC5322] domain name

   addr-mailbox    = nstring
                       ; NIL indicates end of [RFC5322] group; if
                       ; non-NIL and addr-host is NIL, holds
                       ; [RFC5322] group name.
                       ; Otherwise, holds [RFC5322] local-part
                       ; after removing [RFC5322] quoting

   addr-name       = nstring
                       ; If non-NIL, holds phrase from [RFC5322]
                       ; mailbox after removing [RFC5322] quoting

   append          = "APPEND" SP mailbox [SP flag-list] [SP date-time]
                     SP literal

   append-uid      = uniqueid

   astring         = 1*ASTRING-CHAR / string

   ASTRING-CHAR   = ATOM-CHAR / resp-specials

   atom            = 1*ATOM-CHAR

   ATOM-CHAR       = <any CHAR except atom-specials>

   atom-specials   = "(" / ")" / "{" / SP / CTL / list-wildcards /
                     quoted-specials / resp-specials

   authenticate    = "AUTHENTICATE" SP auth-type [SP initial-resp]
                     *(CRLF base64)

   auth-type       = atom
                       ; Authentication mechanism name, as defined by
                       ; [SASL], Section 7.1

   base64          = *(4base64-char) [base64-terminal]

   base64-char     = ALPHA / DIGIT / "+" / "/"
                       ; Case sensitive

   base64-terminal = (2base64-char "==") / (3base64-char "=")

   body            = "(" (body-type-1part / body-type-mpart) ")"

   body-extension  = nstring / number / number64 /
                      "(" body-extension *(SP body-extension) ")"
                       ; Future expansion.  Client implementations
                       ; MUST accept body-extension fields.  Server
                       ; implementations MUST NOT generate
                       ; body-extension fields except as defined by
                       ; future Standard or Standards Track
                       ; revisions of this specification.

   body-ext-1part  = body-fld-md5 [SP body-fld-dsp [SP body-fld-lang
                     [SP body-fld-loc *(SP body-extension)]]]
                       ; MUST NOT be returned on non-extensible
                       ; "BODY" fetch

   body-ext-mpart  = body-fld-param [SP body-fld-dsp [SP body-fld-lang
                     [SP body-fld-loc *(SP body-extension)]]]
                       ; MUST NOT be returned on non-extensible
                       ; "BODY" fetch

   body-fields     = body-fld-param SP body-fld-id SP body-fld-desc SP
                     body-fld-enc SP body-fld-octets

   body-fld-desc   = nstring

   body-fld-dsp    = "(" string SP body-fld-param ")" / nil

   body-fld-enc    = (DQUOTE ("7BIT" / "8BIT" / "BINARY" / "BASE64"/
                     "QUOTED-PRINTABLE") DQUOTE) / string
                     ; Content-Transfer-Encoding header field value.
                     ; Defaults to "7BIT" (as per RFC 2045)
                     ; if not present in the body part.

   body-fld-id     = nstring

   body-fld-lang   = nstring / "(" string *(SP string) ")"

   body-fld-loc    = nstring

   body-fld-lines  = number64

   body-fld-md5    = nstring

   body-fld-octets = number

   body-fld-param  = "(" string SP string *(SP string SP string) ")" /
                     nil

   body-type-1part = (body-type-basic / body-type-msg / body-type-text)
                     [SP body-ext-1part]

   body-type-basic = media-basic SP body-fields
                       ; MESSAGE subtype MUST NOT be "RFC822" or
                       ; "GLOBAL"

   body-type-mpart = 1*body SP media-subtype
                     [SP body-ext-mpart]
                       ; MULTIPART body part

   body-type-msg   = media-message SP body-fields SP envelope
                     SP body SP body-fld-lines

   body-type-text  = media-text SP body-fields SP body-fld-lines

   capability      = ("AUTH=" auth-type) / atom
                       ; New capabilities SHOULD be
                       ; registered with IANA using the
                       ; RFC Required policy, i.e., in
                       ; a Standards Track, an Experimental,
                       ; or an Informational RFC.

   capability-data = "CAPABILITY" *(SP capability) SP "IMAP4rev2"
                     *(SP capability)
                       ; See Section 6.1.1 for information about
                       ; required security-related capabilities.
                       ; Servers that offer RFC 1730 compatibility MUST
                       ; list "IMAP4" as the first capability.
                       ; Servers that offer RFC 3501 compatibility MUST
                       ; list "IMAP4rev1" as one of the capabilities.

   CHAR            = <defined in [ABNF]>

   CHAR8           = %x01-ff
                       ; any OCTET except NUL, %x00

   charset         = atom / quoted

   childinfo-extended-item =  "CHILDINFO" SP "("
               list-select-base-opt-quoted
               *(SP list-select-base-opt-quoted) ")"
               ; Extended data item (mbox-list-extended-item)
               ; returned when the RECURSIVEMATCH
               ; selection option is specified.
               ; Note 1: the CHILDINFO extended data item tag can be
               ; returned with or without surrounding quotes, as per
               ; mbox-list-extended-item-tag production.
               ; Note 2: The selection options are always returned
               ; quoted, unlike their specification in
               ; the extended LIST command.

   child-mbox-flag =  "\HasChildren" / "\HasNoChildren"
               ; attributes for the CHILDREN return option, at most
               ; one possible per LIST response

   command         = tag SP (command-any / command-auth /
                     command-nonauth / command-select) CRLF
                       ; Modal based on state

   command-any     = "CAPABILITY" / "LOGOUT" / "NOOP"
                       ; Valid in all states

   command-auth    = append / create / delete / enable / examine /
                     list / namespace-command / rename /
                     select / status / subscribe / unsubscribe /
                     idle
                       ; Valid only in Authenticated or Selected state

   command-nonauth = login / authenticate / "STARTTLS"
                       ; Valid only when in Not Authenticated state

   command-select  = "CLOSE" / "UNSELECT" / "EXPUNGE" / copy /
                      move / fetch / store / search / uid
                       ; Valid only when in Selected state

   continue-req    = "+" SP (resp-text / base64) CRLF

   copy            = "COPY" SP sequence-set SP mailbox

   create          = "CREATE" SP mailbox
                       ; Use of INBOX gives a NO error

   date            = date-text / DQUOTE date-text DQUOTE

   date-day        = 1*2DIGIT
                       ; Day of month

   date-day-fixed  = (SP DIGIT) / 2DIGIT
                       ; Fixed-format version of date-day

   date-month      = "Jan" / "Feb" / "Mar" / "Apr" / "May" / "Jun" /
                     "Jul" / "Aug" / "Sep" / "Oct" / "Nov" / "Dec"

   date-text       = date-day "-" date-month "-" date-year

   date-year       = 4DIGIT

   date-time       = DQUOTE date-day-fixed "-" date-month "-" date-year
                     SP time SP zone DQUOTE

   delete          = "DELETE" SP mailbox
                       ; Use of INBOX gives a NO error

   digit-nz        = %x31-39
                       ; 1-9

   eitem-standard-tag =  atom
               ; a tag for LIST extended data item defined in a Standard
               ; Track or Experimental RFC.

   eitem-vendor-tag =  vendor-token "-" atom
               ; a vendor-specific tag for LIST extended data item

   enable          = "ENABLE" 1*(SP capability)

   enable-data     = "ENABLED" *(SP capability)

   envelope        = "(" env-date SP env-subject SP env-from SP
                     env-sender SP env-reply-to SP env-to SP env-cc SP
                     env-bcc SP env-in-reply-to SP env-message-id ")"

   env-bcc         = "(" 1*address ")" / nil

   env-cc          = "(" 1*address ")" / nil

   env-date        = nstring

   env-from        = "(" 1*address ")" / nil

   env-in-reply-to = nstring

   env-message-id  = nstring

   env-reply-to    = "(" 1*address ")" / nil

   env-sender      = "(" 1*address ")" / nil

   env-subject     = nstring

   env-to          = "(" 1*address ")" / nil

   esearch-response  = "ESEARCH" [search-correlator] [SP "UID"]
                       *(SP search-return-data)
                     ; ESEARCH response replaces SEARCH response
                     ; from IMAP4rev1.

   examine         = "EXAMINE" SP mailbox

   fetch           = "FETCH" SP sequence-set SP (
                     "ALL" / "FULL" / "FAST" /
                     fetch-att / "(" fetch-att *(SP fetch-att) ")")

   fetch-att       = "ENVELOPE" / "FLAGS" / "INTERNALDATE" /
                     "RFC822.SIZE" /
                     "BODY" ["STRUCTURE"] / "UID" /
                     "BODY" section [partial] /
                     "BODY.PEEK" section [partial] /
                     "BINARY" [".PEEK"] section-binary [partial] /
                     "BINARY.SIZE" section-binary

   flag            = "\Answered" / "\Flagged" / "\Deleted" /
                     "\Seen" / "\Draft" / flag-keyword / flag-extension
                       ; Does not include "\Recent"

   flag-extension  = "\" atom
                       ; Future expansion.  Client implementations
                       ; MUST accept flag-extension flags.  Server
                       ; implementations MUST NOT generate
                       ; flag-extension flags except as defined by
                       ; a future Standard or Standards Track
                       ; revisions of this specification.
                       ; "\Recent" was defined in RFC 3501
                       ; and is now deprecated.

   flag-fetch      = flag / obsolete-flag-recent

   flag-keyword    = "$MDNSent" / "$Forwarded" / "$Junk" /
                     "$NotJunk" / "$Phishing" / atom

   flag-list       = "(" [flag *(SP flag)] ")"

   flag-perm       = flag / "\*"

   greeting        = "*" SP (resp-cond-auth / resp-cond-bye) CRLF

   header-fld-name = astring

   header-list     = "(" header-fld-name *(SP header-fld-name) ")"

   idle            = "IDLE" CRLF "DONE"

   initial-resp    =  (base64 / "=")
                      ; "initial response" defined in
                      ; Section 4 of [SASL]

   list            = "LIST" [SP list-select-opts] SP
                     mailbox SP mbox-or-pat
                     [SP list-return-opts]

   list-mailbox    = 1*list-char / string

   list-char       = ATOM-CHAR / list-wildcards / resp-specials

   list-return-opt   =  return-option
                        ; Note that return-option is the ABNF
                        ; non-terminal used by RFC 5258

   list-return-opts =  "RETURN" SP
               "(" [list-return-opt *(SP list-return-opt)] ")"
               ; list return options, e.g., CHILDREN

   list-select-base-opt =  "SUBSCRIBED" / option-extension
               ; options that can be used by themselves

   list-select-base-opt-quoted =  DQUOTE list-select-base-opt DQUOTE

   list-select-independent-opt =  "REMOTE" / option-extension
               ; options that do not syntactically interact with
               ; other options

   list-select-mod-opt =  "RECURSIVEMATCH" / option-extension
               ; options that require a list-select-base-opt
               ; to also be present

   list-select-opt =  list-select-base-opt / list-select-independent-opt
                      / list-select-mod-opt

   list-select-opts =  "(" [
                      (*(list-select-opt SP) list-select-base-opt
                      *(SP list-select-opt))
                     / (list-select-independent-opt
                      *(SP list-select-independent-opt))
                        ] ")"
               ; Any number of options may be in any order.
               ; If a list-select-mod-opt appears, then a
               ; list-select-base-opt must also appear.
               ; This allows these:
               ; ()
               ; (REMOTE)
               ; (SUBSCRIBED)
               ; (SUBSCRIBED REMOTE)
               ; (SUBSCRIBED RECURSIVEMATCH)
               ; (SUBSCRIBED REMOTE RECURSIVEMATCH)
               ; But does NOT allow these:
               ; (RECURSIVEMATCH)
               ; (REMOTE RECURSIVEMATCH)

   list-wildcards  = "%" / "*"

   literal         = "{" number64 ["+"] "}" CRLF *CHAR8
                       ; <number64> represents the number of CHAR8s.
                       ; A non-synchronizing literal is distinguished
                       ; from a synchronizing literal by the presence of
                       ; "+" before the closing "}".
                       ; Non-synchronizing literals are not allowed when
                       ; sent from server to the client.

   literal8        =  "~{" number64 "}" CRLF *OCTET
                       ; <number64> represents the number of OCTETs
                       ; in the response string.

   login           = "LOGIN" SP userid SP password

   mailbox         = "INBOX" / astring
                       ; INBOX is case insensitive.  All case variants
                       ; of INBOX (e.g., "iNbOx") MUST be interpreted as
                       ; INBOX, not as an astring.  An astring that
                       ; consists of the case-insensitive sequence
                       ; "I" "N" "B" "O" "X" is considered
                       ; to be an INBOX and not an astring.
                       ; Refer to Section 5.1 for further
                       ; semantic details of mailbox names.

   mailbox-data    =  "FLAGS" SP flag-list / "LIST" SP mailbox-list /
                      esearch-response /
                      "STATUS" SP mailbox SP "(" [status-att-list] ")" /
                      number SP "EXISTS" / namespace-response /
                      obsolete-search-response /
                      obsolete-recent-response
                       ; obsolete-search-response and
                       ; obsolete-recent-response can only be returned
                       ; by servers that support both IMAPrev1
                       ; and IMAPrev2.

   mailbox-list    = "(" [mbx-list-flags] ")" SP
                      (DQUOTE QUOTED-CHAR DQUOTE / nil) SP mailbox
                      [SP mbox-list-extended]
               ; This is the list information pointed to by the ABNF
               ; item "mailbox-data", which is defined above

   mbox-list-extended =  "(" [mbox-list-extended-item
                         *(SP mbox-list-extended-item)] ")"

   mbox-list-extended-item = mbox-list-extended-item-tag SP
                              tagged-ext-val

   mbox-list-extended-item-tag = astring
                  ; The content MUST conform to either
                  ; "eitem-vendor-tag" or "eitem-standard-tag"
                  ; ABNF productions.

   mbox-or-pat =  list-mailbox / patterns

   mbx-list-flags  = *(mbx-list-oflag SP) mbx-list-sflag
                     *(SP mbx-list-oflag) /
                     mbx-list-oflag *(SP mbx-list-oflag)

   mbx-list-oflag  = "\Noinferiors" / child-mbox-flag /
                     "\Subscribed" / "\Remote" / flag-extension
                  ; Other flags; multiple from this list are
                  ; possible per LIST response, but each flag
                  ; can only appear once per LIST response

   mbx-list-sflag  = "\NonExistent" / "\Noselect" / "\Marked" /
                     "\Unmarked"
                  ; Selectability flags; only one per LIST response

   media-basic     = ((DQUOTE ("APPLICATION" / "AUDIO" / "IMAGE" /
                     "FONT" / "MESSAGE" / "MODEL" / "VIDEO" ) DQUOTE)
                     / string)
                     SP media-subtype
                       ; FONT defined in [RFC8081].
                       ; MODEL defined in [RFC2077].
                       ; Other top-level media types
                       ; are defined in [MIME-IMT].

   media-message   = DQUOTE "MESSAGE" DQUOTE SP
                     DQUOTE ("RFC822" / "GLOBAL") DQUOTE
                       ; Defined in [MIME-IMT]

   media-subtype   = string
                       ; Defined in [MIME-IMT]

   media-text      = DQUOTE "TEXT" DQUOTE SP media-subtype
                       ; Defined in [MIME-IMT]

   message-data    = nz-number SP ("EXPUNGE" / ("FETCH" SP msg-att))

   move            = "MOVE" SP sequence-set SP mailbox

   msg-att         = "(" (msg-att-dynamic / msg-att-static)
                      *(SP (msg-att-dynamic / msg-att-static)) ")"

   msg-att-dynamic = "FLAGS" SP "(" [flag-fetch *(SP flag-fetch)] ")"
                       ; MAY change for a message

   msg-att-static  = "ENVELOPE" SP envelope /
                     "INTERNALDATE" SP date-time /
                     "RFC822.SIZE" SP number64 /
                     "BODY" ["STRUCTURE"] SP body /
                     "BODY" section ["<" number ">"] SP nstring /
                     "BINARY" section-binary SP (nstring / literal8) /
                     "BINARY.SIZE" section-binary SP number /
                     "UID" SP uniqueid
                       ; MUST NOT change for a message

   name-component  = 1*UTF8-CHAR
                       ; MUST NOT contain ".", "/", "%", or "*"

   namespace         = nil / "(" 1*namespace-descr ")"

   namespace-command = "NAMESPACE"

   namespace-descr   = "(" string SP
                          (DQUOTE QUOTED-CHAR DQUOTE / nil)
                           [namespace-response-extensions] ")"

   namespace-response-extensions = *namespace-response-extension

   namespace-response-extension = SP string SP
                     "(" string *(SP string) ")"

   namespace-response = "NAMESPACE" SP namespace
                         SP namespace SP namespace
                    ; The first Namespace is the Personal Namespace(s).
                    ; The second Namespace is the Other Users'
                    ; Namespace(s).
                    ; The third Namespace is the Shared Namespace(s).

   nil             = "NIL"

   nstring         = string / nil

   number          = 1*DIGIT
                       ; Unsigned 32-bit integer
                       ; (0 <= n < 4,294,967,296)

   number64        = 1*DIGIT
                       ; Unsigned 63-bit integer
                       ; (0 <= n <= 9,223,372,036,854,775,807)

   nz-number       = digit-nz *DIGIT
                       ; Non-zero unsigned 32-bit integer
                       ; (0 < n < 4,294,967,296)

   nz-number64     = digit-nz *DIGIT
                       ; Unsigned 63-bit integer
                       ; (0 < n <= 9,223,372,036,854,775,807)

   obsolete-flag-recent = "\Recent"

   obsolete-recent-response = number SP "RECENT"

   obsolete-search-response = "SEARCH" *(SP nz-number)

   oldname-extended-item =  "OLDNAME" SP "(" mailbox ")"
                       ; Extended data item (mbox-list-extended-item)
                       ; returned in a LIST response when a mailbox is
                       ; renamed or deleted. Also returned when
                       ; the server canonicalized the provided mailbox
                       ; name.
                       ; Note 1: the OLDNAME tag can be returned
                       ; with or without surrounding quotes, as per
                       ; mbox-list-extended-item-tag production.

   option-extension = (option-standard-tag / option-vendor-tag)
                      [SP option-value]

   option-standard-tag =  atom
                  ; an option defined in a Standards Track or
                  ; Experimental RFC

   option-val-comp =  astring /
                      option-val-comp *(SP option-val-comp) /
                      "(" option-val-comp ")"

   option-value =  "(" option-val-comp ")"

   option-vendor-tag =  vendor-token "-" atom
                  ; a vendor-specific option, non-standard

   partial-range    = number64 ["." nz-number64]
                       ; Copied from RFC 5092 (IMAP URL)
                       ; and updated to support 64-bit sizes.

   partial         = "<" number64 "." nz-number64 ">"
                       ; Partial FETCH request. 0-based offset of
                       ; the first octet, followed by the number of
                       ; octets in the fragment.

   password        = astring

   patterns        = "(" list-mailbox ")"
                     ; [RFC5258] supports multiple patterns,
                     ; but this document only requires one
                     ; to be supported.
                     ; If the server is also implementing
                     ; [RFC5258], the "patterns" syntax from
                     ; that document must be followed.

   quoted          = DQUOTE *QUOTED-CHAR DQUOTE

   QUOTED-CHAR     = <any TEXT-CHAR except quoted-specials> /
                     "\" quoted-specials / UTF8-2 / UTF8-3 / UTF8-4

   quoted-specials = DQUOTE / "\"

   rename          = "RENAME" SP mailbox SP mailbox
                       ; Use of INBOX as a destination gives a NO error

   response        = *(continue-req / response-data) response-done

   response-data   = "*" SP (resp-cond-state / resp-cond-bye /
                     mailbox-data / message-data / capability-data /
                     enable-data) CRLF

   response-done   = response-tagged / response-fatal

   response-fatal  = "*" SP resp-cond-bye CRLF
                       ; Server closes connection immediately

   response-tagged = tag SP resp-cond-state CRLF

   resp-code-apnd  = "APPENDUID" SP nz-number SP append-uid

   resp-code-copy  = "COPYUID" SP nz-number SP uid-set SP uid-set

   resp-cond-auth  = ("OK" / "PREAUTH") SP resp-text
                       ; Authentication condition

   resp-cond-bye   = "BYE" SP resp-text

   resp-cond-state = ("OK" / "NO" / "BAD") SP resp-text
                       ; Status condition

   resp-specials   = "]"

   resp-text       = ["[" resp-text-code "]" SP] [text]

   resp-text-code  = "ALERT" /
                     "BADCHARSET" [SP "(" charset *(SP charset) ")" ] /
                     capability-data / "PARSE" /
                     "PERMANENTFLAGS" SP
                         "(" [flag-perm *(SP flag-perm)] ")" /
                     "READ-ONLY" / "READ-WRITE" / "TRYCREATE" /
                     "UIDNEXT" SP nz-number /
                     "UIDVALIDITY" SP nz-number /
                     resp-code-apnd / resp-code-copy / "UIDNOTSTICKY" /
                     "UNAVAILABLE" / "AUTHENTICATIONFAILED" /
                     "AUTHORIZATIONFAILED" / "EXPIRED" /
                     "PRIVACYREQUIRED" / "CONTACTADMIN" / "NOPERM" /
                     "INUSE" / "EXPUNGEISSUED" / "CORRUPTION" /
                     "SERVERBUG" / "CLIENTBUG" / "CANNOT" /
                     "LIMIT" / "OVERQUOTA" / "ALREADYEXISTS" /
                     "NONEXISTENT" / "NOTSAVED" / "HASCHILDREN" /
                     "CLOSED" /
                     "UNKNOWN-CTE" /
                     atom [SP 1*<any TEXT-CHAR except "]">]

   return-option   = "SUBSCRIBED" / "CHILDREN" / status-option /
                      option-extension

   search          = "SEARCH" [search-return-opts]
                     SP search-program

   search-correlator  = SP "(" "TAG" SP tag-string ")"

   search-key      = "ALL" / "ANSWERED" / "BCC" SP astring /
                     "BEFORE" SP date / "BODY" SP astring /
                     "CC" SP astring / "DELETED" / "FLAGGED" /
                     "FROM" SP astring / "KEYWORD" SP flag-keyword /
                     "ON" SP date / "SEEN" /
                     "SINCE" SP date / "SUBJECT" SP astring /
                     "TEXT" SP astring / "TO" SP astring /
                     "UNANSWERED" / "UNDELETED" / "UNFLAGGED" /
                     "UNKEYWORD" SP flag-keyword / "UNSEEN" /
                       ; Above this line were in [IMAP2]
                     "DRAFT" / "HEADER" SP header-fld-name SP astring /
                     "LARGER" SP number64 / "NOT" SP search-key /
                     "OR" SP search-key SP search-key /
                     "SENTBEFORE" SP date / "SENTON" SP date /
                     "SENTSINCE" SP date / "SMALLER" SP number64 /
                     "UID" SP sequence-set / "UNDRAFT" / sequence-set /
                     "(" search-key *(SP search-key) ")"

   search-modifier-name = tagged-ext-label

   search-mod-params = tagged-ext-val
                     ; This non-terminal shows recommended syntax
                     ; for future extensions.

   search-program     = ["CHARSET" SP charset SP]
                       search-key *(SP search-key)
                       ; CHARSET argument to SEARCH MUST be
                       ; registered with IANA.

   search-ret-data-ext = search-modifier-name SP search-return-value
                       ; Note that not every SEARCH return option
                       ; is required to have the corresponding
                       ; ESEARCH return data.

   search-return-data = "MIN" SP nz-number /
                       "MAX" SP nz-number /
                       "ALL" SP sequence-set /
                       "COUNT" SP number /
                       search-ret-data-ext
                       ; All return data items conform to
                       ; search-ret-data-ext syntax.
                       ; Note that "$" marker is not allowed
                       ; after the ALL return data item.

   search-return-opts = SP "RETURN" SP "(" [search-return-opt
                       *(SP search-return-opt)] ")"

   search-return-opt  = "MIN" / "MAX" / "ALL" / "COUNT" /
                        "SAVE" /
                        search-ret-opt-ext
                       ; conforms to generic search-ret-opt-ext
                       ; syntax

   search-ret-opt-ext = search-modifier-name [SP search-mod-params]

   search-return-value = tagged-ext-val
                       ; Data for the returned search option.
                       ; A single "nz-number"/"number"/"number64" value
                       ; can be returned as an atom (i.e., without
                       ; quoting).  A sequence-set can be returned
                       ; as an atom as well.

   section         = "[" [section-spec] "]"

   section-binary  = "[" [section-part] "]"

   section-msgtext = "HEADER" /
                     "HEADER.FIELDS" [".NOT"] SP header-list /
                     "TEXT"
                       ; top-level or MESSAGE/RFC822 or
                       ; MESSAGE/GLOBAL part

   section-part    = nz-number *("." nz-number)
                       ; body part reference.
                       ; Allows for accessing nested body parts.

   section-spec    = section-msgtext / (section-part ["." section-text])

   section-text    = section-msgtext / "MIME"
                       ; text other than actual body part (headers,
                       ; etc.)

   select          = "SELECT" SP mailbox

   seq-number      = nz-number / "*"
                       ; message sequence number (COPY, FETCH, STORE
                       ; commands) or unique identifier (UID COPY,
                       ; UID FETCH, UID STORE commands).
                       ; * represents the largest number in use.  In
                       ; the case of message sequence numbers, it is
                       ; the number of messages in a non-empty mailbox.
                       ; In the case of unique identifiers, it is the
                       ; unique identifier of the last message in the
                       ; mailbox or, if the mailbox is empty, the
                       ; mailbox's current UIDNEXT value.
                       ; The server should respond with a tagged BAD
                       ; response to a command that uses a message
                       ; sequence number greater than the number of
                       ; messages in the selected mailbox.  This
                       ; includes "*" if the selected mailbox is empty.

   seq-range       = seq-number ":" seq-number
                       ; two seq-number values and all values between
                       ; these two regardless of order.
                       ; Example: 2:4 and 4:2 are equivalent and
                       ; indicate values 2, 3, and 4.
                       ; Example: a unique identifier sequence range of
                       ; 3291:* includes the UID of the last message in
                       ; the mailbox, even if that value is less than
                       ; 3291.

   sequence-set    = (seq-number / seq-range) ["," sequence-set]
                       ; set of seq-number values, regardless of order.
                       ; Servers MAY coalesce overlaps and/or execute
                       ; the sequence in any order.
                       ; Example: a message sequence number set of
                       ; 2,4:7,9,12:* for a mailbox with 15 messages is
                       ; equivalent to 2,4,5,6,7,9,12,13,14,15
                       ; Example: a message sequence number set of
                       ; *:4,5:7 for a mailbox with 10 messages is
                       ; equivalent to 10,9,8,7,6,5,4,5,6,7 and MAY
                       ; be reordered and overlap coalesced to be
                       ; 4,5,6,7,8,9,10.

   sequence-set    =/ seq-last-command
                       ; Allow for "result of the last command"
                       ; indicator.

   seq-last-command   = "$"

   status          = "STATUS" SP mailbox SP
                     "(" status-att *(SP status-att) ")"

   status-att      = "MESSAGES" / "UIDNEXT" / "UIDVALIDITY" /
                     "UNSEEN" / "DELETED" / "SIZE"

   status-att-val  = ("MESSAGES" SP number) /
                     ("UIDNEXT" SP nz-number) /
                     ("UIDVALIDITY" SP nz-number) /
                     ("UNSEEN" SP number) /
                     ("DELETED" SP number) /
                     ("SIZE" SP number64)
                       ; Extensions to the STATUS responses
                       ; should extend this production.
                       ; Extensions should use the generic
                       ; syntax defined by tagged-ext.

   status-att-list =  status-att-val *(SP status-att-val)

   status-option = "STATUS" SP "(" status-att *(SP status-att) ")"
                       ; This ABNF production complies with
                       ; <option-extension> syntax.

   store           = "STORE" SP sequence-set SP store-att-flags

   store-att-flags = (["+" / "-"] "FLAGS" [".SILENT"]) SP
                     (flag-list / (flag *(SP flag)))

   string          = quoted / literal

   subscribe       = "SUBSCRIBE" SP mailbox

   tag             = 1*<any ASTRING-CHAR except "+">

   tag-string      = astring
                     ; <tag> represented as <astring>

   tagged-ext-label    = tagged-label-fchar *tagged-label-char
                         ; Is a valid RFC 3501 "atom".

   tagged-label-fchar  = ALPHA / "-" / "_" / "."

   tagged-label-char   = tagged-label-fchar / DIGIT / ":"

   tagged-ext-comp     = astring /
                         tagged-ext-comp *(SP tagged-ext-comp) /
                         "(" tagged-ext-comp ")"
                         ; Extensions that follow this general
                         ; syntax should use nstring instead of
                         ; astring when appropriate in the context
                         ; of the extension.
                         ; Note that a message set or a "number"
                         ; can always be represented as an "atom".
                         ; A URL should be represented as
                         ; a "quoted" string.

   tagged-ext-simple   = sequence-set / number / number64

   tagged-ext-val      = tagged-ext-simple /
                         "(" [tagged-ext-comp] ")"

   text            = 1*(TEXT-CHAR / UTF8-2 / UTF8-3 / UTF8-4)
                       ; Non-ASCII text can only be returned
                       ; after ENABLE IMAP4rev2 command

   TEXT-CHAR       = <any CHAR except CR and LF>

   time            = 2DIGIT ":" 2DIGIT ":" 2DIGIT
                       ; Hours minutes seconds

   uid             = "UID" SP
                     (copy / move / fetch / search / store /
                      uid-expunge)
                       ; Unique identifiers used instead of message
                       ; sequence numbers

   uid-expunge     = "EXPUNGE" SP sequence-set
                       ; Unique identifiers used instead of message
                       ; sequence numbers

   uid-set         = (uniqueid / uid-range) *("," uid-set)

   uid-range       = (uniqueid ":" uniqueid)
                       ; two uniqueid values and all values
                       ; between these two regardless of order.
                       ; Example: 2:4 and 4:2 are equivalent.

   uniqueid        = nz-number
                       ; Strictly ascending

   unsubscribe     = "UNSUBSCRIBE" SP mailbox

   userid          = astring

   UTF8-CHAR       = <Defined in Section 4 of RFC 3629>

   UTF8-2          = <Defined in Section 4 of RFC 3629>

   UTF8-3          = <Defined in Section 4 of RFC 3629>

   UTF8-4          = <Defined in Section 4 of RFC 3629>

   vendor-token    = "vendor." name-component
                       ; Definition copied from RFC 2244.
                       ; MUST be registered with IANA

   zone            = ("+" / "-") 4DIGIT
                       ; Signed four-digit value of hhmm representing
                       ; hours and minutes east of Greenwich (that is,
                       ; the amount that the given time differs from
                       ; Universal Time).  Subtracting the timezone
                       ; from the given time will give the UT form.
                       ; The Universal Time zone is "+0000".
```

---
## **10.  Author's Note**

이 문서는 이전 문서의 개정 또는 재작성이며 \[RFC3501\], \[RFC2060\], \[RFC1730\], 게시되지 않은 IMAP2bis.TXT 문서, \[IMAP2\] 및 \[RFC1064\] 문서의 프로토콜 사양을 대체합니다.

---
## **11.  Security Considerations**

전자 메일 데이터를 포함한 IMAP4rev2 프로토콜 트랜잭션은 네트워크를 통해 암호화되지 않은 상태로 전송되므로 보호가 협상되지 않는 한 도청 및 조작 가능성에 노출됩니다.  이는 암시적 TLS 포트, STARTTLS 명령, AUTHENTICATE 명령의 협상된 기밀 보호 또는 기타 보호 메커니즘을 사용하여 수행할 수 있습니다.

---
### **11.1.  TLS-Related Security Considerations**

이 섹션은 STARTTLS 명령과 암시적 TLS 포트 사용에 모두 적용됩니다.

IMAP 클라이언트 및 서버 구현은 \[RFC8314\]의 관련 TLS 권장 사항을 준수해야 합니다.  이 문서의 권장 사항/요구 사항이 \[RFC8314\]의 권장 사항과 충돌하는 경우\(예: TLS 암호 모음과 관련하여\) 이 문서의 권장 사항이 우선합니다.

클라이언트와 서버는 TLS 1.2\[TLS-1.2\] 이상을 구현해야 합니다.  TLS 1.3\[TLS-1.3\] 사용을 권장합니다.  TLS 1.2는 상대방이 아직 TLS 1.3을 구현하지 않은 경우에만 사용할 수 있습니다. 또한 TLS 1.2를 사용하는 경우 IMAP 구현은 TLS\_ECDHE\_RSA\_WITH\_AES\_128\_GCM\_SHA256 암호화 제품군을 구현해야 합니다.  이는 두 개의 호환 구현이 상호 운용되도록 구성할 수 있다는 점에서 중요합니다.  RFC 7525 \[RFC7525\]에서 권장되는 기타 TLS 암호화 제품군은 권장됩니다: TLS\_DHE\_RSA\_WITH\_AES\_128\_GCM\_SHA256, TLS\_DHE\_RSA\_WITH\_AES\_256\_GCM\_SHA384 및 TLS\_ECDHE\_RSA\_WITH\_AES\_256\_GCM\_SHA384.  다른 모든 암호 제품군은 선택 사항입니다.  이는 \[IMAP-TLS\]의 섹션 2.1에서 변경된 사항입니다.

필수 구현 TLS 1.3 암호화 제품군 목록은 \[TLS-1.3\]의 섹션 9.1에 설명되어 있습니다.

TLS 협상 \[TLS-1.3\] \[TLS-1.2\] 중에 클라이언트는 서버 인증서 메시지에 표시된 서버의 ID와 비교하여 서버 호스트 이름에 대한 이해를 확인해야 합니다. 섬기는 사람. 이 절차는 \[RFC7817\]에 설명되어 있습니다.

클라이언트와 서버 모두 허용 가능한 인증 및/또는 개인 정보 보호가 달성되었는지 확인하기 위해 STARTTLS 명령과 후속 TLS \[TLS-1.3\] \[TLS-1.2\] 협상의 결과를 확인해야 합니다.

---
### **11.2.  STARTTLS Command versus Use of Implicit TLS Port**

최대 역호환성을 위해 클라이언트는 암시적 TLS 포트에서 TLS 협상과 일반 텍스트 포트에서 STARTTLS 명령을 사용하여 TLS 협상을 모두 구현해야 합니다.

서버는 암시적 TLS 포트에서 TLS 협상을 구현해야 합니다. 서버는 또한 일반 텍스트 포트에서 IMAP을 구현해야 합니다.  서버가 일반 텍스트 포트에서 수신 대기하는 경우 해당 포트에서 STARTTLS 명령을 허용해야 합니다.

일부 사이트/방화벽 관리자는 사이트 전체에 TLS를 적용해야 한다고 주장하며 각 상위 수준 프로토콜의 구성 옵션에 의존하지 않는 것을 선호합니다.  이러한 이유로 IMAP4rev2 클라이언트는 사용자 구성이나 DNS SRV 레코드\[RFC6186\]에 의해 재정의되지 않는 한 기본적으로 포트 993과 143\(및 IPv4와 IPv6 모두\)을 동시에 시도해야 합니다.  이러한 동시 연결을 구현하기 위한 좋은 알고리즘은 \[RFC8305\]에 설명되어 있습니다.

11.3.  현재 연결 상태에 적합하지 않은 원치 않는 응답에 대한 클라이언트 처리

일반 텍스트 메일 전송\(TLS 스트리핑을 초래하는 방화벽 구성 오류 또는 처음에 TLS를 협상하지 않기로 선택한 이메일 클라이언트의 취약한 보안 정책으로 인해 발생\)은 이메일 클라이언트를 혼란스럽게 하거나 심지어 충돌을 일으킬 수 있는 응답을 주입할 수 있습니다.  이로 인한 피해를 최소화하려면 다음 조치를 권장합니다.

\* PREAUTH 응답과 관련된 특별 보안 고려 사항은 섹션 7.1.4를 참조하세요.

\* 많은 서버 응답 및 응답 코드는 인증된 상태 또는 선택된 상태에서만 의미가 있습니다.  그러나 STARTTLS/AUTHENTICATE 명령이 실행되기 전에 서버\(또는 경로상의 공격자\)가 일반 텍스트로 잘못된 응답을 보내는 것을 막을 수 있는 방법은 없습니다.  인증 전에 클라이언트는 CAPABILITY 및 서버 상태 응답\(7.1절\) 이외의 모든 응답과 CAPABILITY 이외의 모든 응답 코드를 무시해야 합니다.  \(특히 일부 이메일 클라이언트는 인증 전에 수신된 LIST 응답을 잘못 처리하거나 사서함이 선택되지 않은 경우 FETCH 응답을 잘못 처리하는 것으로 알려져 있습니다.\) 클라이언트는 TLS 이후까지 ALERT 응답 코드를 무시해야 합니다\(암시적 TLS 포트에서 STARTTLS 또는 TLS 협상을 사용하는지 여부\). \) 또는 기밀 보호 기능이 있는 SASL 보안 계층이 성공적으로 협상되었습니다.  IMAP 확장에서 명시적으로 허용하지 않는 한, 선택 상태가 아닌 경우 클라이언트는 FLAGS, EXIST, EXPUNGE 및 FETCH와 같은 메시지 및 메일함 상태와 관련된 응답/응답 코드를 무시해야 합니다.

---
### **11.4.  COPYUID and APPENDUID Response Codes**

COPYUID 및 APPENDUID 응답 코드는 사서함에 대한 정보를 반환합니다. 이는 클라이언트가 사서함에 COPY 또는 APPEND를 허용하지만 SELECT 또는 EXAMINE은 허용하지 않는 권한이 사서함에 설정된 경우 민감한 것으로 간주될 수 있습니다.

결과적으로, 클라이언트가 사서함을 SELECT 또는 EXAMINE에 액세스할 수 없는 경우 이러한 응답 코드는 발행되어서는 안 됩니다.

---
### **11.5.  LIST Command and Other Users' Namespace**

다른 사용자의 네임스페이스 접두사의 인수가 포함된 LIST 명령에 대한 응답으로 서버는 현재 인증된 사용자에게 개인 사서함에 대한 목록 액세스 권한을 부여하지 않은 사용자를 나열해서는 안 됩니다.  이러한 목록을 제공하면 서버에 있는 사람의 기밀 정보가 공개되거나 공격할 사용자 계정 목록의 시작점이 제공되어 보안이 손상될 수 있습니다.

---
### **11.6.  Use of MD5**

BODYSTRUCTURE FETCH 데이터 항목은 "body MD5" 필드에 메시지 본문의 MD5 다이제스트를 포함할 수 있습니다\(body-fld-md5 ABNF 생성\). MD5는 더 이상 보안 암호화 해시\[RFC6151\]로 간주되지 않지만 이 필드는 Content-MD5 헤더 필드\(원본 메시지에 있는 경우\)의 값을 노출하는 데만 사용됩니다. 이는 메시지 무결성 검사일 뿐이며 사용되지 않습니다. 암호화 목적으로.  또한 메시지 무결성 검사를 제공하는 다른 메커니즘은 RFC 1864 \[MD5\]가 게시된 이후 정의되었으며 현재 Content-MD5보다 더 일반적으로 사용됩니다.  이러한 두 가지 메커니즘은 DKIM 서명 헤더 필드\[RFC6376\]와 S/MIME 서명\[RFC8550\]\[RFC8551\]입니다.

---
### **11.7.  Other Security Considerations**

유효하지 않은 자격 증명으로 인해 실패한 AUTHENTICATE 명령에 대한 서버 오류 메시지에는 자격 증명이 유효하지 않은 이유를 자세히 설명해서는 안 됩니다.

LOGIN 명령을 사용하면 비밀번호가 암호화되지 않은 상태로 전송됩니다.  이는 일반 텍스트 비밀번호를 사용하지 않는 \[SASL\] 메커니즘과 함께 AUTHENTICATE 명령을 사용하고 먼저 STARTTLS 또는 기타 보호 메커니즘을 통해 암호화를 협상함으로써 방지할 수 있습니다.

서버 구현은 인증 시 다음을 요구하는 구성을 구현해야 합니다.

```text
   1.  The STARTTLS command has been negotiated or TLS negotiated on an
       Implicit TLS port
       OR
   2.  Some other mechanism that protects the session from password
       snooping has been provided
       OR
   3.  The following measures are in place:
       a)  The LOGINDISABLED capability is advertised, and [SASL]
           mechanisms (such as PLAIN) using plaintext passwords are NOT
           advertised in the CAPABILITY list.
           AND
       b)  The LOGIN command returns an error even if the password is
           correct
           AND
       c)  The AUTHENTICATE command returns an error with all [SASL]
           mechanisms that use plaintext passwords, even if the password
           is correct.
```

실패한 LOGIN 명령에 대한 서버 오류 메시지는 비밀번호가 아닌 사용자 이름이 유효하지 않다고 지정해서는 안 됩니다.

서버에는 실패한 AUTHENTICATE/LOGIN 시도를 제한하거나 지연하는 메커니즘이 있어야 합니다.

서버는 모든 인증 실패를 보고하고 비밀번호 무차별 대입 공격 및 비밀번호 스프레이 공격\[NCSC\]과 관련된 인증 실패 시도를 분석해야 합니다.  스프레이 공격으로 인해 잘 알려진 비밀번호와 일치하는 비밀번호를 가진 계정은 반드시 차단되어야 하며, 그러한 계정과 연결된 사용자에게는 비밀번호 변경을 요청해야 합니다.  상당한 강도를 지닌 비밀번호만 허용되어야 합니다.

추가 보안 고려사항은 AUTHENTICATE 및 LOGIN 명령을 정의하는 섹션에서 논의됩니다\(각각 섹션 6.2.2 및 6.2.3 참조\).

---
## **12.  IANA Considerations**

IANA는 "서비스 이름 및 전송 프로토콜 포트 번호" 레지스트리를 다음과 같이 업데이트했습니다.

1. TCP 포트 143에 대한 등록 및 해당 "imap" 서비스 이름이 이 문서 및 \[RFC3501\]을 가리키도록 업데이트되었습니다.

1. TCP 포트 993에 대한 등록 및 해당 "imaps" 서비스 이름이 이 문서 \[RFC8314\] 및 \[RFC3501\]을 가리키도록 업데이트되었습니다.

1. UDP 포트 143과 993은 모두 레지스트리에서 "예약됨"으로 표시되었습니다.

추가 IANA 작업은 다음 하위 섹션에 지정되어 있습니다.

---
### **12.1.  Updates to IMAP Capabilities Registry**

IMAP4 기능은 표준 트랙 또는 IESG 승인 정보 또는 실험 RFC를 게시하여 등록됩니다.  레지스트리는 현재 다음 위치에 있습니다: <https://www.iana.org/locationments/imap4-capability\>

이 사양이 AUTH= 접두사, STARTTLS 및 LOGINDISABLED 확장을 개정함에 따라 IANA는 이 문서와 \[RFC3501\]을 가리키도록 이러한 3개 확장에 대한 레지스트리 항목을 업데이트했습니다.

---
### **12.2.  GSSAPI/SASL Service Name**

GSSAPI/Kerberos/SASL 서비스 이름은 표준 트랙 또는 IESG 승인 실험 RFC를 게시하여 등록됩니다.  레지스트리는 현재 <https://www.iana.org/locationments/gssapi-service-names\>에 있습니다.

IANA는 이 문서와 \[RFC3501\]을 모두 가리키도록 이전에 \[RFC3501\]에 등록된 "imap" 서비스 이름을 업데이트했습니다.

12.3.  LIST 선택 옵션, LIST 반환 옵션 및 LIST 확장 데이터 항목

\[RFC5258\]은 LIST 선택 옵션, LIST 반환 옵션 및 LIST 확장 데이터 항목에 대한 IANA 등록 절차를 지정합니다.  이 문서는 이러한 등록 절차를 변경하지 않습니다.  특히, LIST 선택 옵션\(Section 6.3.9.1\) 및 LIST 반환 옵션\(Section 6.3.9.2\)은 \[RFC5258\]의 9절에 지정된 절차를 사용하여\(그리고 \[RFC5258\]의 9.3절에 있는 등록 템플릿을 사용하여\) 등록됩니다.  LIST 확장 데이터 항목은 \[RFC5258\] 섹션 9.6의 등록 템플릿을 사용하여 등록됩니다.

IANA는 "OLDNAME" LIST-EXTENDED 확장 데이터 항목 항목에 대해 RFC 9051에 대한 참조를 추가했습니다.  이는 \[RFC5465\]에 대한 기존 참조에 추가됩니다.

---
### **12.4.  IMAP Mailbox Name Attributes and IMAP Response Codes**

IANA는 \[RFC3501\] 외에도 이 문서를 가리키도록 "IMAP Mailbox Name Attributes" 레지스트리를 업데이트했습니다.

IANA는 \[RFC3501\] 외에도 이 문서를 가리키도록 "IMAP 응답 코드" 레지스트리를 업데이트했습니다.

---
## **13.  References**
---
### **13.1.  Normative References**

```text
   [ABNF]     Crocker, D., Ed. and P. Overell, "Augmented BNF for Syntax
              Specifications: ABNF", STD 68, RFC 5234,
              DOI 10.17487/RFC5234, January 2008,
              <https://www.rfc-editor.org/info/rfc5234>.

   [BCP178]   Saint-Andre, P., Crocker, D., and M. Nottingham,
              "Deprecating the "X-" Prefix and Similar Constructs in
              Application Protocols", BCP 178, RFC 6648, June 2012.

              <https://www.rfc-editor.org/info/bcp178>

   [CHARSET]  Freed, N. and J. Postel, "IANA Charset Registration
              Procedures", BCP 19, RFC 2978, DOI 10.17487/RFC2978,
              October 2000, <https://www.rfc-editor.org/info/rfc2978>.

   [DISPOSITION]
              Troost, R., Dorner, S., and K. Moore, Ed., "Communicating
              Presentation Information in Internet Messages: The
              Content-Disposition Header Field", RFC 2183,
              DOI 10.17487/RFC2183, August 1997,
              <https://www.rfc-editor.org/info/rfc2183>.

   [I18N-HDRS]
              Yang, A., Steele, S., and N. Freed, "Internationalized
              Email Headers", RFC 6532, DOI 10.17487/RFC6532, February
              2012, <https://www.rfc-editor.org/info/rfc6532>.

   [IMAP-IMPLEMENTATION]
              Leiba, B., "IMAP4 Implementation Recommendations",
              RFC 2683, DOI 10.17487/RFC2683, September 1999,
              <https://www.rfc-editor.org/info/rfc2683>.

   [IMAP-MULTIACCESS]
              Gahrns, M., "IMAP4 Multi-Accessed Mailbox Practice",
              RFC 2180, DOI 10.17487/RFC2180, July 1997,
              <https://www.rfc-editor.org/info/rfc2180>.

   [LANGUAGE-TAGS]
              Alvestrand, H., "Content Language Headers", RFC 3282,
              DOI 10.17487/RFC3282, May 2002,
              <https://www.rfc-editor.org/info/rfc3282>.

   [LOCATION] Palme, J., Hopmann, A., and N. Shelness, "MIME
              Encapsulation of Aggregate Documents, such as HTML
              (MHTML)", RFC 2557, DOI 10.17487/RFC2557, March 1999,
              <https://www.rfc-editor.org/info/rfc2557>.

   [MD5]      Myers, J. and M. Rose, "The Content-MD5 Header Field",
              RFC 1864, DOI 10.17487/RFC1864, October 1995,
              <https://www.rfc-editor.org/info/rfc1864>.

   [MIME-HDRS]
              Moore, K., "MIME (Multipurpose Internet Mail Extensions)
              Part Three: Message Header Extensions for Non-ASCII Text",
              RFC 2047, DOI 10.17487/RFC2047, November 1996,
              <https://www.rfc-editor.org/info/rfc2047>.

   [MIME-IMB] Freed, N. and N. Borenstein, "Multipurpose Internet Mail
              Extensions (MIME) Part One: Format of Internet Message
              Bodies", RFC 2045, DOI 10.17487/RFC2045, November 1996,
              <https://www.rfc-editor.org/info/rfc2045>.

   [MIME-IMT] Freed, N. and N. Borenstein, "Multipurpose Internet Mail
              Extensions (MIME) Part Two: Media Types", RFC 2046,
              DOI 10.17487/RFC2046, November 1996,
              <https://www.rfc-editor.org/info/rfc2046>.

   [MULTIAPPEND]
              Crispin, M., "Internet Message Access Protocol (IMAP) -
              MULTIAPPEND Extension", RFC 3502, DOI 10.17487/RFC3502,
              March 2003, <https://www.rfc-editor.org/info/rfc3502>.

   [NET-UNICODE]
              Klensin, J. and M. Padlipsky, "Unicode Format for Network
              Interchange", RFC 5198, DOI 10.17487/RFC5198, March 2008,
              <https://www.rfc-editor.org/info/rfc5198>.

   [PLAIN]    Zeilenga, K., Ed., "The PLAIN Simple Authentication and
              Security Layer (SASL) Mechanism", RFC 4616,
              DOI 10.17487/RFC4616, August 2006,
              <https://www.rfc-editor.org/info/rfc4616>.

   [RFC2077]  Nelson, S., Parks, C., and , "The Model Primary Content
              Type for Multipurpose Internet Mail Extensions", RFC 2077,
              DOI 10.17487/RFC2077, January 1997,
              <https://www.rfc-editor.org/info/rfc2077>.

   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", BCP 14, RFC 2119,
              DOI 10.17487/RFC2119, March 1997,
              <https://www.rfc-editor.org/info/rfc2119>.

   [RFC2231]  Freed, N. and K. Moore, "MIME Parameter Value and Encoded
              Word Extensions: Character Sets, Languages, and
              Continuations", RFC 2231, DOI 10.17487/RFC2231, November
              1997, <https://www.rfc-editor.org/info/rfc2231>.

   [RFC3503]  Melnikov, A., "Message Disposition Notification (MDN)
              profile for Internet Message Access Protocol (IMAP)",
              RFC 3503, DOI 10.17487/RFC3503, March 2003,
              <https://www.rfc-editor.org/info/rfc3503>.

   [RFC4648]  Josefsson, S., "The Base16, Base32, and Base64 Data
              Encodings", RFC 4648, DOI 10.17487/RFC4648, October 2006,
              <https://www.rfc-editor.org/info/rfc4648>.

   [RFC4752]  Melnikov, A., Ed., "The Kerberos V5 ("GSSAPI") Simple
              Authentication and Security Layer (SASL) Mechanism",
              RFC 4752, DOI 10.17487/RFC4752, November 2006,
              <https://www.rfc-editor.org/info/rfc4752>.

   [RFC5258]  Leiba, B. and A. Melnikov, "Internet Message Access
              Protocol version 4 - LIST Command Extensions", RFC 5258,
              DOI 10.17487/RFC5258, June 2008,
              <https://www.rfc-editor.org/info/rfc5258>.

   [RFC5322]  Resnick, P., Ed., "Internet Message Format", RFC 5322,
              DOI 10.17487/RFC5322, October 2008,
              <https://www.rfc-editor.org/info/rfc5322>.

   [RFC5788]  Melnikov, A. and D. Cridland, "IMAP4 Keyword Registry",
              RFC 5788, DOI 10.17487/RFC5788, March 2010,
              <https://www.rfc-editor.org/info/rfc5788>.

   [RFC7525]  Sheffer, Y., Holz, R., and P. Saint-Andre,
              "Recommendations for Secure Use of Transport Layer
              Security (TLS) and Datagram Transport Layer Security
              (DTLS)", BCP 195, RFC 7525, DOI 10.17487/RFC7525, May
              2015, <https://www.rfc-editor.org/info/rfc7525>.

   [RFC7817]  Melnikov, A., "Updated Transport Layer Security (TLS)
              Server Identity Check Procedure for Email-Related
              Protocols", RFC 7817, DOI 10.17487/RFC7817, March 2016,
              <https://www.rfc-editor.org/info/rfc7817>.

   [RFC8081]  Lilley, C., "The "font" Top-Level Media Type", RFC 8081,
              DOI 10.17487/RFC8081, February 2017,
              <https://www.rfc-editor.org/info/rfc8081>.

   [RFC8098]  Hansen, T., Ed. and A. Melnikov, Ed., "Message Disposition
              Notification", STD 85, RFC 8098, DOI 10.17487/RFC8098,
              February 2017, <https://www.rfc-editor.org/info/rfc8098>.

   [RFC8174]  Leiba, B., "Ambiguity of Uppercase vs Lowercase in RFC
              2119 Key Words", BCP 14, RFC 8174, DOI 10.17487/RFC8174,
              May 2017, <https://www.rfc-editor.org/info/rfc8174>.

   [RFC8314]  Moore, K. and C. Newman, "Cleartext Considered Obsolete:
              Use of Transport Layer Security (TLS) for Email Submission
              and Access", RFC 8314, DOI 10.17487/RFC8314, January 2018,
              <https://www.rfc-editor.org/info/rfc8314>.

   [SASL]     Melnikov, A., Ed. and K. Zeilenga, Ed., "Simple
              Authentication and Security Layer (SASL)", RFC 4422,
              DOI 10.17487/RFC4422, June 2006,
              <https://www.rfc-editor.org/info/rfc4422>.

   [SCRAM-SHA-256]
              Hansen, T., "SCRAM-SHA-256 and SCRAM-SHA-256-PLUS Simple
              Authentication and Security Layer (SASL) Mechanisms",
              RFC 7677, DOI 10.17487/RFC7677, November 2015,
              <https://www.rfc-editor.org/info/rfc7677>.

   [TLS-1.2]  Dierks, T. and E. Rescorla, "The Transport Layer Security
              (TLS) Protocol Version 1.2", RFC 5246,
              DOI 10.17487/RFC5246, August 2008,
              <https://www.rfc-editor.org/info/rfc5246>.

   [TLS-1.3]  Rescorla, E., "The Transport Layer Security (TLS) Protocol
              Version 1.3", RFC 8446, DOI 10.17487/RFC8446, August 2018,
              <https://www.rfc-editor.org/info/rfc8446>.

   [UTF-7]    Goldsmith, D. and M. Davis, "UTF-7 A Mail-Safe
              Transformation Format of Unicode", RFC 2152,
              DOI 10.17487/RFC2152, May 1997,
              <https://www.rfc-editor.org/info/rfc2152>.

   [UTF-8]    Yergeau, F., "UTF-8, a transformation format of ISO
              10646", STD 63, RFC 3629, DOI 10.17487/RFC3629, November
              2003, <https://www.rfc-editor.org/info/rfc3629>.
```

---
### **13.2.  Informative References**
---
#### **13.2.1.  Related Protocols**

```text
   [ANONYMOUS]
              Zeilenga, K., "Anonymous Simple Authentication and
              Security Layer (SASL) Mechanism", RFC 4505,
              DOI 10.17487/RFC4505, June 2006,
              <https://www.rfc-editor.org/info/rfc4505>.

   [CERT-555316]
              Carnegie Mellon University, "STARTTLS plaintext command
              injection vulnerability", Software Engineering Institute,
              CERT Coordination Center, Vulnerability Note VU#555316,
              September 2011, <https://www.kb.cert.org/vuls/id/555316>.

   [CHARSET-REG]
              IANA, "Character Set Registrations",
              <https://www.iana.org/assignments/charset-reg/>.

   [IMAP-DISC]
              Melnikov, A., Ed., "Synchronization Operations for
              Disconnected IMAP4 Clients", RFC 4549,
              DOI 10.17487/RFC4549, June 2006,
              <https://www.rfc-editor.org/info/rfc4549>.

   [IMAP-I18N]
              Newman, C., Gulbrandsen, A., and A. Melnikov, "Internet
              Message Access Protocol Internationalization", RFC 5255,
              DOI 10.17487/RFC5255, June 2008,
              <https://www.rfc-editor.org/info/rfc5255>.

   [IMAP-KEYWORDS-REG]
              IANA, "IMAP and JMAP Keywords",
              <https://www.iana.org/assignments/imap-jmap-keywords/>.

   [IMAP-MAILBOX-NAME-ATTRS-REG]
              IANA, "IMAP Mailbox Name Attributes",
              <https://www.iana.org/assignments/imap-mailbox-name-
              attributes/>.

   [IMAP-MODEL]
              Crispin, M., "Distributed Electronic Mail Models in
              IMAP4", RFC 1733, DOI 10.17487/RFC1733, December 1994,
              <https://www.rfc-editor.org/info/rfc1733>.

   [IMAP-URL] Melnikov, A., Ed. and C. Newman, "IMAP URL Scheme",
              RFC 5092, DOI 10.17487/RFC5092, November 2007,
              <https://www.rfc-editor.org/info/rfc5092>.

   [IMAP-UTF-8]
              Resnick, P., Ed., Newman, C., Ed., and S. Shen, Ed., "IMAP
              Support for UTF-8", RFC 6855, DOI 10.17487/RFC6855, March
              2013, <https://www.rfc-editor.org/info/rfc6855>.

   [NCSC]     NCSC, "Spray you, spray me: defending against password
              spraying attacks", May 2018, <https://www.ncsc.gov.uk/
              blog-post/spray-you-spray-me-defending-against-password-
              spraying-attacks>.

   [RFC2087]  Myers, J., "IMAP4 QUOTA extension", RFC 2087,
              DOI 10.17487/RFC2087, January 1997,
              <https://www.rfc-editor.org/info/rfc2087>.

   [RFC2177]  Leiba, B., "IMAP4 IDLE command", RFC 2177,
              DOI 10.17487/RFC2177, June 1997,
              <https://www.rfc-editor.org/info/rfc2177>.

   [RFC2193]  Gahrns, M., "IMAP4 Mailbox Referrals", RFC 2193,
              DOI 10.17487/RFC2193, September 1997,
              <https://www.rfc-editor.org/info/rfc2193>.

   [RFC2342]  Gahrns, M. and C. Newman, "IMAP4 Namespace", RFC 2342,
              DOI 10.17487/RFC2342, May 1998,
              <https://www.rfc-editor.org/info/rfc2342>.

   [RFC3348]  Gahrns, M. and R. Cheng, "The Internet Message Action
              Protocol (IMAP4) Child Mailbox Extension", RFC 3348,
              DOI 10.17487/RFC3348, July 2002,
              <https://www.rfc-editor.org/info/rfc3348>.

   [RFC3516]  Nerenberg, L., "IMAP4 Binary Content Extension", RFC 3516,
              DOI 10.17487/RFC3516, April 2003,
              <https://www.rfc-editor.org/info/rfc3516>.

   [RFC3691]  Melnikov, A., "Internet Message Access Protocol (IMAP)
              UNSELECT command", RFC 3691, DOI 10.17487/RFC3691,
              February 2004, <https://www.rfc-editor.org/info/rfc3691>.

   [RFC4314]  Melnikov, A., "IMAP4 Access Control List (ACL) Extension",
              RFC 4314, DOI 10.17487/RFC4314, December 2005,
              <https://www.rfc-editor.org/info/rfc4314>.

   [RFC4315]  Crispin, M., "Internet Message Access Protocol (IMAP) -
              UIDPLUS extension", RFC 4315, DOI 10.17487/RFC4315,
              December 2005, <https://www.rfc-editor.org/info/rfc4315>.

   [RFC4466]  Melnikov, A. and C. Daboo, "Collected Extensions to IMAP4
              ABNF", RFC 4466, DOI 10.17487/RFC4466, April 2006,
              <https://www.rfc-editor.org/info/rfc4466>.

   [RFC4731]  Melnikov, A. and D. Cridland, "IMAP4 Extension to SEARCH
              Command for Controlling What Kind of Information Is
              Returned", RFC 4731, DOI 10.17487/RFC4731, November 2006,
              <https://www.rfc-editor.org/info/rfc4731>.

   [RFC4959]  Siemborski, R. and A. Gulbrandsen, "IMAP Extension for
              Simple Authentication and Security Layer (SASL) Initial
              Client Response", RFC 4959, DOI 10.17487/RFC4959,
              September 2007, <https://www.rfc-editor.org/info/rfc4959>.

   [RFC5161]  Gulbrandsen, A., Ed. and A. Melnikov, Ed., "The IMAP
              ENABLE Extension", RFC 5161, DOI 10.17487/RFC5161, March
              2008, <https://www.rfc-editor.org/info/rfc5161>.

   [RFC5182]  Melnikov, A., "IMAP Extension for Referencing the Last
              SEARCH Result", RFC 5182, DOI 10.17487/RFC5182, March
              2008, <https://www.rfc-editor.org/info/rfc5182>.

   [RFC5256]  Crispin, M. and K. Murchison, "Internet Message Access
              Protocol - SORT and THREAD Extensions", RFC 5256,
              DOI 10.17487/RFC5256, June 2008,
              <https://www.rfc-editor.org/info/rfc5256>.

   [RFC5465]  Gulbrandsen, A., King, C., and A. Melnikov, "The IMAP
              NOTIFY Extension", RFC 5465, DOI 10.17487/RFC5465,
              February 2009, <https://www.rfc-editor.org/info/rfc5465>.

   [RFC5530]  Gulbrandsen, A., "IMAP Response Codes", RFC 5530,
              DOI 10.17487/RFC5530, May 2009,
              <https://www.rfc-editor.org/info/rfc5530>.

   [RFC5819]  Melnikov, A. and T. Sirainen, "IMAP4 Extension for
              Returning STATUS Information in Extended LIST", RFC 5819,
              DOI 10.17487/RFC5819, March 2010,
              <https://www.rfc-editor.org/info/rfc5819>.

   [RFC6151]  Turner, S. and L. Chen, "Updated Security Considerations
              for the MD5 Message-Digest and the HMAC-MD5 Algorithms",
              RFC 6151, DOI 10.17487/RFC6151, March 2011,
              <https://www.rfc-editor.org/info/rfc6151>.

   [RFC6154]  Leiba, B. and J. Nicolson, "IMAP LIST Extension for
              Special-Use Mailboxes", RFC 6154, DOI 10.17487/RFC6154,
              March 2011, <https://www.rfc-editor.org/info/rfc6154>.

   [RFC6186]  Daboo, C., "Use of SRV Records for Locating Email
              Submission/Access Services", RFC 6186,
              DOI 10.17487/RFC6186, March 2011,
              <https://www.rfc-editor.org/info/rfc6186>.

   [RFC6376]  Crocker, D., Ed., Hansen, T., Ed., and M. Kucherawy, Ed.,
              "DomainKeys Identified Mail (DKIM) Signatures", STD 76,
              RFC 6376, DOI 10.17487/RFC6376, September 2011,
              <https://www.rfc-editor.org/info/rfc6376>.

   [RFC6409]  Gellens, R. and J. Klensin, "Message Submission for Mail",
              STD 72, RFC 6409, DOI 10.17487/RFC6409, November 2011,
              <https://www.rfc-editor.org/info/rfc6409>.

   [RFC6851]  Gulbrandsen, A. and N. Freed, Ed., "Internet Message
              Access Protocol (IMAP) - MOVE Extension", RFC 6851,
              DOI 10.17487/RFC6851, January 2013,
              <https://www.rfc-editor.org/info/rfc6851>.

   [RFC7162]  Melnikov, A. and D. Cridland, "IMAP Extensions: Quick Flag
              Changes Resynchronization (CONDSTORE) and Quick Mailbox
              Resynchronization (QRESYNC)", RFC 7162,
              DOI 10.17487/RFC7162, May 2014,
              <https://www.rfc-editor.org/info/rfc7162>.

   [RFC7888]  Melnikov, A., Ed., "IMAP4 Non-synchronizing Literals",
              RFC 7888, DOI 10.17487/RFC7888, May 2016,
              <https://www.rfc-editor.org/info/rfc7888>.

   [RFC8126]  Cotton, M., Leiba, B., and T. Narten, "Guidelines for
              Writing an IANA Considerations Section in RFCs", BCP 26,
              RFC 8126, DOI 10.17487/RFC8126, June 2017,
              <https://www.rfc-editor.org/info/rfc8126>.

   [RFC8305]  Schinazi, D. and T. Pauly, "Happy Eyeballs Version 2:
              Better Connectivity Using Concurrency", RFC 8305,
              DOI 10.17487/RFC8305, December 2017,
              <https://www.rfc-editor.org/info/rfc8305>.

   [RFC8438]  Bosch, S., "IMAP Extension for STATUS=SIZE", RFC 8438,
              DOI 10.17487/RFC8438, August 2018,
              <https://www.rfc-editor.org/info/rfc8438>.

   [RFC8474]  Gondwana, B., Ed., "IMAP Extension for Object
              Identifiers", RFC 8474, DOI 10.17487/RFC8474, September
              2018, <https://www.rfc-editor.org/info/rfc8474>.

   [RFC8550]  Schaad, J., Ramsdell, B., and S. Turner, "Secure/
              Multipurpose Internet Mail Extensions (S/MIME) Version 4.0
              Certificate Handling", RFC 8550, DOI 10.17487/RFC8550,
              April 2019, <https://www.rfc-editor.org/info/rfc8550>.

   [RFC8551]  Schaad, J., Ramsdell, B., and S. Turner, "Secure/
              Multipurpose Internet Mail Extensions (S/MIME) Version 4.0
              Message Specification", RFC 8551, DOI 10.17487/RFC8551,
              April 2019, <https://www.rfc-editor.org/info/rfc8551>.

   [SMTP]     Klensin, J., "Simple Mail Transfer Protocol", RFC 5321,
              DOI 10.17487/RFC5321, October 2008,
              <https://www.rfc-editor.org/info/rfc5321>.
```

---
#### **13.2.2.  Historical Aspects of IMAP and Related Protocols**

```text
   [IMAP-COMPAT]
              Crispin, M., "IMAP4 Compatibility with IMAP2bis",
              RFC 2061, DOI 10.17487/RFC2061, December 1996,
              <https://www.rfc-editor.org/info/rfc2061>.

   [IMAP-HISTORICAL]
              Crispin, M., "IMAP4 Compatibility with IMAP2 and
              IMAP2bis", RFC 1732, DOI 10.17487/RFC1732, December 1994,
              <https://www.rfc-editor.org/info/rfc1732>.

   [IMAP-OBSOLETE]
              Crispin, M., "Internet Message Access Protocol - Obsolete
              Syntax", RFC 2062, DOI 10.17487/RFC2062, December 1996,
              <https://www.rfc-editor.org/info/rfc2062>.

   [IMAP-TLS] Newman, C., "Using TLS with IMAP, POP3 and ACAP",
              RFC 2595, DOI 10.17487/RFC2595, June 1999,
              <https://www.rfc-editor.org/info/rfc2595>.

   [IMAP2]    Crispin, M., "Interactive Mail Access Protocol: Version
              2", RFC 1176, DOI 10.17487/RFC1176, August 1990,
              <https://www.rfc-editor.org/info/rfc1176>.

   [IMAP2BIS] Crispin, M., "INTERACTIVE MAIL ACCESS PROTOCOL - VERSION
              2bis", Work in Progress, Internet-Draft, draft-ietf-imap-
              imap2bis-02, 29 October 1993,
              <https://datatracker.ietf.org/doc/html/draft-ietf-imap-
              imap2bis-02>.

   [RFC1064]  Crispin, M., "Interactive Mail Access Protocol: Version
              2", RFC 1064, DOI 10.17487/RFC1064, July 1988,
              <https://www.rfc-editor.org/info/rfc1064>.

   [RFC1730]  Crispin, M., "Internet Message Access Protocol - Version
              4", RFC 1730, DOI 10.17487/RFC1730, December 1994,
              <https://www.rfc-editor.org/info/rfc1730>.

   [RFC2060]  Crispin, M., "Internet Message Access Protocol - Version
              4rev1", RFC 2060, DOI 10.17487/RFC2060, December 1996,
              <https://www.rfc-editor.org/info/rfc2060>.

   [RFC3501]  Crispin, M., "INTERNET MESSAGE ACCESS PROTOCOL - VERSION
              4rev1", RFC 3501, DOI 10.17487/RFC3501, March 2003,
              <https://www.rfc-editor.org/info/rfc3501>.

   [RFC822]   Crocker, D., "STANDARD FOR THE FORMAT OF ARPA INTERNET
              TEXT MESSAGES", STD 11, RFC 822, DOI 10.17487/RFC0822,
              August 1982, <https://www.rfc-editor.org/info/rfc822>.
```

---
# **Appendix A.  Backward Compatibility with IMAP4rev1**

IMAP4rev1과의 호환성을 유지하려는 구현은 CAPABILITY 응답/응답 코드에서 IMAP4rev1 및 IMAP4rev2를 모두 광고할 수 있습니다.  \(이러한 서버 구현은 IMAP4rev2로 접힌 다른 IMAP4rev1 확장도 광고하려고 할 가능성이 높습니다. 부록 E를 참조하십시오.\) 일부 IMAP4rev1 응답은 IMAP4rev2에서 제거되었지만 해당 응답이 있어도 IMAP4rev2 전용 클라이언트는 중단되지 않습니다.

IMAP4rev1과 IMAP4rev2가 모두 광고되는 경우 IMAP4rev2를 사용하려는 IMAP 클라이언트는 "ENABLE IMAP4rev2" 명령을 실행해야 합니다.

IMAP4rev1과 비교할 때 IMAP4rev2에서는 일부 요청 데이터 항목, 해당 응답 데이터 항목 및 응답이 제거되었습니다.  자세한 내용은 부록 E를 참조하세요.  더 이상 사용되지 않는 SEARCH 및 RECENT 응답을 제외하고 IMAP4rev1 및 IMAP4rev2를 모두 광고하는 서버는 IMAPrev1 클라이언트가 명시적으로 요청하지 않는 한 제거된 응답 데이터 항목/응답을 반환하지 않습니다.

IMAP4rev1 및 IMAP4rev2를 모두 광고하는 서버는 클라이언트가 "ENABLE IMAP4rev2"를 발행하지 않는 한 UTF-8 인용 문자열을 생성해서는 안 됩니다. 이 목표를 달성하려면 \[IMAP-UTF-8\]에 설명되거나 참조된 메커니즘의 구현을 고려하세요.

IMAP4rev1 및 IMAP4rev2를 모두 광고하는 서버와 IMAP4rev1 서버와 호환되도록 의도된 클라이언트는 부록 A.1에 설명된 사서함 국제 명명 규칙과 호환되어야 합니다.

또한 63비트 본문 부분/메시지 크기를 지원하고 IMAP4rev1 및 IMAP4rev2에 대한 지원을 알리려는 서버에 대한 특별 고려 사항은 부록 D를 참조하세요.

A.1.  IMAP4rev1과의 호환성을 위한 메일박스 국제 명명 규칙

IMAP4rev2 전용 클라이언트 및 서버에는 이 섹션에 설명된 사서함 국제 명명 규칙에 대한 지원이 필요하지 않습니다. IMAP4rev1 구현과의 이전 버전과의 호환성을 위해서만 사용됩니다.

관례적으로 IMAP4rev1의 국제 메일함 이름은 \[UTF-7\]에 설명된 UTF-7 인코딩의 수정된 버전을 사용하여 지정됩니다. 수정된 UTF-7은 이 프로토콜의 이전 버전을 구현하는 서버에서도 사용할 수 있습니다.

수정된 UTF-7에서는 "&"를 제외한 인쇄 가능한 US-ASCII 문자가 그 자체를 나타냅니다. 즉, 옥텟 값이 0x20-0x25 및 0x27-0x7e인 문자입니다.  문자 "&"\(0x26\)는 2옥텟 시퀀스 "&-"로 표시됩니다.

다른 모든 문자\(옥텟 값 0x00-0x1f 및 0x7f-0xff\)는 "/" 대신 ","가 사용되는 \[UTF-7\]의 추가 수정을 통해 수정된 base64로 표시됩니다.  수정된 base64는 자신을 나타낼 수 있는 US-ASCII 문자의 인쇄를 나타내는 데 사용되어서는 안 됩니다.  수정된 base64 알파벳 내의 문자만 수정된 base64 텍스트에 허용됩니다.

"&"는 수정된 base64로 이동하는 데 사용되며 "-"는 US-ASCII로 다시 이동하는 데 사용됩니다.  base64에서 US-ASCII로의 암시적 이동은 없으며 null 이동\(base64에서는 "-&", US-ASCII에서 "&-"는 "&"를 의미함\)은 허용되지 않습니다.  그러나 모든 이름은 US-ASCII로 시작하고 US-ASCII로 끝나야 합니다. 즉, ASCII가 아닌 ISO-10646 문자로 끝나는 이름은 반드시 "-"로 끝나야 합니다.

이러한 수정의 목적은 UTF-7의 다음 문제를 해결하는 것입니다.

1. UTF-7은 이동을 위해 "+" 문자를 사용합니다. 이는 사서함 이름, 특히 USENET 뉴스 그룹 이름에서 "+"를 일반적으로 사용하는 것과 충돌합니다.

1. UTF-7의 인코딩은 "/" 문자를 사용하는 base64입니다. 이는 널리 사용되는 계층 구분 기호로 "/"를 사용하는 것과 충돌합니다.

1. UTF-7은 "\"의 인코딩되지 않은 사용을 금지합니다. 이는 널리 사용되는 계층 구분 기호로 "\"를 사용하는 것과 충돌합니다.

1. UTF-7은 "\~"의 인코딩되지 않은 사용을 금지합니다. 이는 일부 서버에서 홈 디렉터리 표시기로 "\~"를 사용하는 것과 충돌합니다.

1. UTF-7은 동일한 문자열을 나타내는 여러 대체 형식을 허용합니다. 특히 인쇄 가능한 US-ASCII 문자는 인코딩된 형식으로 표시될 수 있습니다.

수정된 UTF-7은 규칙이지만 "&" 문자가 포함된 사서함 이름을 처리하는 서버에 대한 특정 요구 사항을 설정합니다.  특히, 서버 구현은 수정된 UTF-7 이름의 수정된 base64 부분의 정확한 형식을 유지해야 하며, 이름이 대소문자를 구분하지 않거나 대소문자를 접는 경우에도 해당 텍스트를 대소문자를 구분하여 처리해야 합니다.

서버 구현은 CREATE의 인수로 사용되는 "&" 문자가 포함된 모든 사서함 이름이 다음과 같은지 확인해야 합니다. 올바르게 수정된 UTF-7 구문인지; 불필요한 교대가 없습니다. 자신을 나타낼 수 있는 인쇄 US-ASCII 문자의 수정된 base64에는 인코딩이 없습니다.  그러나 클라이언트 구현은 이를 수행하는 서버에 의존해서는 안 되며 수정된 UTF-7 구문을 준수하지 않는 한 "&" 문자가 포함된 메일함 이름을 생성하려고 시도해서는 안 됩니다.

수정된 UTF-7 규칙을 따르지 않는 메일 저장소를 내보내는 서버 구현은 비ASCII 문자 또는 "&" 문자가 포함된 모든 메일함 이름을 수정된 UTF-7로 변환해야 합니다.

- 예를 들어 영어, 중국어, 일본어 텍스트가 혼합된 사서함 이름은 다음과 같습니다. \~peter/mail/&U,BTFw-/&ZeVnLIqe-

- 예를 들어 문자열 "&Jjo!" "!" 앞에 US-ASCII로의 이동이 포함되어 있지 않기 때문에 유효한 사서함 이름이 아닙니다. 올바른 형식은 "&Jjo-!"입니다.  "&U,BTFw-&ZeVnLIqe-" 문자열은 불필요한 시프트를 포함하고 있으므로 허용되지 않습니다.  올바른 형식은 "&U,BTF2XlZyyKng-"입니다.

---
# **Appendix B.  Backward Compatibility with BINARY Extension**

IMAP4rev2는 BINARY 확장 \[RFC3516\]에서 제공하는 기능의 하위 집합을 통합합니다. 특히 여기에는 추가 FETCH 항목\(BINARY, BINARY.PEEK 및 BINARY.SIZE\)이 포함되지만 APPEND 명령에 대한 확장은 포함되지 않습니다.  전체 \[RFC3516\] 기능을 지원하는 IMAP4rev2 구현은 CAPABILITY 응답/응답 코드에서 BINARY 기능도 광고해야 합니다.

---
# **Appendix C.  Backward Compatibility with LIST-EXTENDED Extension**

IMAP4rev2는 LIST-EXTENDED 확장 \[RFC5258\]이 제공하는 대부분의 기능을 통합합니다.  특히 LIST-EXTENDED 기능이 CAPABILITY 응답/응답 코드에도 광고되지 않는 한 IMAP4rev2에서는 여러 메일박스 패턴에 대한 구문이 지원되지 않습니다.

---
# **Appendix D.  63-Bit Body Part and Message Sizes**

IMAP4rev2는 서버가 지원할 수 있는 허용되는 본문 부분과 메시지 크기를 32비트에서 63비트로 늘립니다.  서버 구현은 63비트 길이의 본문 부분/메시지 크기를 지원할 필요가 없습니다. 그러나 클라이언트 구현에서는 이를 예상해야 합니다.

IMAP4rev1은 63비트 길이의 본문 부분/메시지 크기를 지원하지 않았으므로 IMAP4rev1 및 IMAP4rev2 이메일 클라이언트 모두에서 액세스할 수 있는 63비트 지원 서버/사서함에서 노출되는 상호 운용성 문제가 있습니다.  IMAP4rev1은 4Gb보다 큰 메시지의 전체 내용을 검색할 수 없으므로 이러한 서버는 4Gb보다 큰 메시지를 4Gb 미만의 메시지로 바꾸거나 IMAP4rev1 클라이언트에서 숨겨야 합니다.  이 문서에서는 이 문제를 해결하기 위한 구현 전략을 규정하지 않습니다.

---
# **Appendix E.  Changes from RFC 3501 / IMAP4rev1**

다음은 RFC 3501 이후 변경 사항을 요약한 것입니다.

1. 64비트 메시지 및 본문 부분 크기를 지원합니다.

1. IMAP NAMESPACE \[RFC2342\], UNSELECT \[RFC3691\], UIDPLUS \[RFC4315\], ESEARCH \[RFC4731\], SEARCHRES \[RFC5182\], ENABLE \[RFC5161\], IDLE \[RFC2177\], SASL-IR \[RFC4959\], LIST-EXTENDED로 접혀 있습니다. \[RFC5258\], LIST-STATUS \[RFC5819\], MOVE \[RFC6851\] 및 LITERAL 확장 \[RFC7888\].  또한 IMAP ABNF 확장 \[RFC4466\], 응답 코드 \[RFC5530\], BINARY 확장의 FETCH 측 \[RFC3516\] 및 SPECIAL-USE \[RFC6154\]의 새 메일함 속성 목록으로 접혀 있습니다.

1. 상태 크기 \[RFC8438\] 및 상태 삭제됨을 추가했습니다.

1. 이제 SEARCH 명령은 ESEARCH 응답을 반환해야 합니다\(SEARCH 응답은 이제 더 이상 사용되지 않음\).

1. 어떤 SEARCH 키가 부분 문자열 일치를 사용해야 하는지, 어떤 키를 사용하지 않아야 하는지 명확히 했습니다.

1. \[RFC2231\]에 설명된 대로 서버가 매개변수 값 연속을 디코딩해야 함을 명확히 했습니다.  이 요구 사항은 \[RFC2231\] 자체에 숨겨져 있습니다.

1. MOVE 및 UID MOVE 모두에 대해 COPYUID 응답 코드가 반환된다는 점을 명확히 했습니다.

1. 대상 사서함을 생성하지 않는 COPY/MOVE 명령에 대한 요구 사항이 강화되었습니다.  또한 대상 사서함이 존재하지 않고 생성될 수 있는 경우 TRYCREATE 응답 코드를 반환하도록 요구했습니다.

1. \[RFC7162\]의 CLOSED 응답 코드를 추가했습니다.  사서함이 이미 선택된 경우 SELECT/EXAMINE을 사용하려면 이제 CLOSED 응답 코드를 반환해야 합니다.

1. 이제 태그가 지정되지 않은 LIST 응답을 반환하려면 SELECT/EXAMINE이 필요합니다.

1. SELECT/EXAMINE의 UNSEEN 응답 코드는 이제 더 이상 사용되지 않습니다.

1. SELECT/EXAMINE, \Recent 플래그, RECENT STATUS 및 SEARCH NEW 항목에 대한 RECENT 응답은 이제 더 이상 사용되지 않습니다.

1. 새 키워드가 성공적으로 추가되고 서버가 동일한 사서함에 대해 \* 이전에 광고한 경우 서버가 새 PERMANENTFLAGS 응답 코드를 보낼 필요가 없음을 명확히 했습니다.

1. 향후 확장성을 위해 tagged-ext-simple에 대해 ABNF를 확장하여 기본 number64를 허용합니다.

1. $MDNSent, $Forwarded, $Junk, $NonJunk 및 $Phishing 키워드를 지원하기 위해 IMAP 서버에 SHOULD 수준 요구 사항이 추가되었습니다.

1. 이제 사서함 이름과 메시지 헤더에서 UTF-8을 허용합니다.  IMAP4rev1과의 호환성을 원하지 않는 한 메일함 이름에서 수정된 UTF-7에 대한 지원은 필요하지 않습니다.

1. CHECK 명령을 제거했습니다.  클라이언트는 대신 NOOP를 사용해야 합니다.

1. RFC822, RFC822.HEADER 및 RFC822.TEXT FETCH 데이터 항목은 더 이상 사용되지 않습니다.  클라이언트는 대신 해당 BODY\[\] 변형을 사용해야 합니다.

1. LSUB 명령은 더 이상 사용되지 않습니다.  클라이언트는 대신 LIST\(SUBSCRIBED\)를 사용해야 합니다.

1. 이제 IDLE 명령은 현재 선택된 사서함 상태와 관련되지 않은 업데이트를 반환할 수 있습니다.

1. 모든 원치 않는 FETCH 업데이트에는 UID가 포함되어야 합니다.

1. 클라이언트 구현은 인식하지 못하는 응답 코드를 무시해야 함을 명확히 했습니다.  \(SHOULD에서 MUST로 변경되었습니다.\)

1. resp-text ABNF 비터미널이 빈 텍스트를 허용하도록 업데이트되었습니다.

1. ENABLE 이후에는 사람이 읽을 수 있는 IMAP4rev2 응답 텍스트에 UTF-8로 인코딩된 비ASCII가 포함될 수 있습니다.

1. \[RFC7525\], \[RFC7817\] 및 \[RFC8314\]에 따라 최신 TLS 관련 권장 사항을 사용하도록 업데이트되었습니다.

1. ALERT 응답 코드 및 PREAUTH 응답 사용에 대한 경고가 추가되었습니다.

1. DIGEST-MD5 SASL 메커니즘을 SCRAM-SHA-256으로 교체했습니다.  DIGEST-MD5는 더 이상 사용되지 않습니다.

1. 클라이언트로부터 수신된 모든 명령이 서버 자동 로그아웃 타이머를 재설정한다는 점을 명확히 했습니다.

1. \[BCP178\]에 따라 IMAP 확장에 대한 IANA 등록 절차를 개정하고 "X" 규칙을 제거했습니다.

1. 기존 관행에 더 부합하도록 연결을 닫을 때 서버에 대한 요구 사항을 완화했습니다.

---
# **Appendix F.  Other Recommended IMAP Extensions**

모든 IMAP 클라이언트 및 서버에는 다음 확장에 대한 지원이 권장됩니다.  특정 상황에서 IMAP이 사용하는 대역폭 및/또는 왕복 횟수를 크게 줄이는 반면, EXTRA WG는 이를 IMAP4rev2의 일부로 요구하면 새로운 구현에 비해 구현 기준이 너무 높아진다고 결정했습니다.  또한 이 목록에 IMAP 확장이 없다고 해서 그것이 부족하거나 IMAP4rev2와 함께 사용하는 것이 권장되지 않는 것은 아닙니다.

1. 빠른 메일함 재동기화\(QRESYNC\) 및 CONDSTORE 확장 \[RFC7162\].  상태를 조금 더 저장하는 대신 IMAP 메일함의 변경 사항을 더 효율적으로 검색할 수 있습니다.

1. OBJECTID 확장 \[RFC8474\]는 메시지가 이동/복사되거나 사서함 이름이 바뀔 때 IMAP 클라이언트 캐시를 보존하는 데 도움이 됩니다.

---
# **Acknowledgements**

이 문서의 이전 초안 버전은 Mark Crispin이 편집했습니다. 안타깝게도 그는 더 이상 이 작업을 도와줄 수 없습니다.  이 개정판의 편집자들은 Mark가 승인하기를 바라고 있습니다.

Chris Newman은 I18N에 대한 텍스트와 메시지 및 메일함 이름에 UTF-8을 사용하는 내용을 기고했습니다.

인덱스 생성에 도움을 주신 Tony Hansen에게 감사드립니다. 광범위한 피드백을 주신 Murray Kucherawy, Timo Sirainen, Bron Gondwana, Stephan Bosch, Robert Sparks, Arnt Gulbrandsen, Benjamin Kaduk, Daniel Migaul, Roman Danyliw 및 Éric Vyncke에게 감사드립니다.

이 문서는 \[RFC2342\]\(Mike Gahrns 및 Chris Newman 작성\), \[RFC3516\]\(Lyndon Nerenberg 작성\), \[RFC4315\]\(Mark Crispin 작성\), \[RFC4466\]\(Cyrus Daboo 작성\), \[RFC4731\]\(Dave 작성\)의 텍스트를 통합합니다. Cridland\), \[RFC4959\]\(Rob Siemborski 및 Arnt Gulbrandsen 작성\), \[RFC5161\]\(Arnt Gulbrandsen 작성\), \[RFC5465\]\(Arnt Gulbrandsen 및 Curtis King 작성\), \[RFC5530\]\(Arnt Gulbrandsen 작성\), \[RFC5819\]\(작성\) Timo Sirainen\), \[RFC6154\]\(Jamie Nicolson 작성\), \[RFC6851\]\(Arnt Gulbrandsen 및 Ned Freed 작성\) 및 \[RFC8438\]\(Stephan Bosch 작성\)이므로 이 문서의 작성자/편집자가 수행한 작업에 감사드립니다.  이 문서의 편집자는 위 목록에서 편집되었습니다.

CHILDREN 반환 옵션은 원래 \[RFC3348\]에서 Mike Gahrns와 Raymond Cheng이 제안했습니다.  섹션 6.3.9.5의 정보 대부분은 원래 사양 \[RFC3348\]에서 직접 가져온 것입니다.

ENABLE 명령이 "모든 명령" ABNF 프로덕션이 아니라 "command-auth"의 구성원이어야 함을 지적하고 관련된 보안 문제를 지적한 Damian Poddebniak, Fabian Ising, Hanno Boeck 및 Sebastian Schinzel에게 감사드립니다. 인증 전에 받은 ALERT, PREAUTH 및 기타 응답을 사용합니다.

---
# **Index**

$ + - \ A B C D E F H I K L M N O P R S T U

```text
      $

         $Forwarded (predefined flag)
            Section 2.3.2
         $Junk (predefined flag)
            Section 2.3.2
         $MDNSent (predefined flag)
            Section 2.3.2
         $NotJunk (predefined flag)
            Section 2.3.2
         $Phishing (predefined flag)
            Section 2.3.2, Paragraph 6.10.1

      +

         +FLAGS <flag list>
            Section 6.4.6
         +FLAGS.SILENT <flag list>
            Section 6.4.6

      -

         -FLAGS <flag list>
            Section 6.4.6
         -FLAGS.SILENT <flag list>
            Section 6.4.6

      \

         \All (mailbox name attribute)
            Section 7.3.1
         \Answered (system flag)
            Section 2.3.2
         \Archive (mailbox name attribute)
            Section 7.3.1
         \Deleted (system flag)
            Section 2.3.2
         \Draft (system flag)
            Section 2.3.2
         \Drafts (mailbox name attribute)
            Section 7.3.1
         \Flagged (mailbox name attribute)
            Section 7.3.1
         \Flagged (system flag)
            Section 2.3.2
         \HasChildren (mailbox name attribute)
            Section 7.3.1
         \HasNoChildren (mailbox name attribute)
            Section 7.3.1
         \Junk (mailbox name attribute)
            Section 7.3.1
         \Marked (mailbox name attribute)
            Section 7.3.1
         \Noinferiors (mailbox name attribute)
            Section 7.3.1
         \NonExistent (mailbox name attribute)
            Section 7.3.1, Paragraph 4.2.1
         \Noselect (mailbox name attribute)
            Section 7.3.1
         \Recent (system flag)
            Section 2.3.2
         \Remote (mailbox name attribute)
            Section 7.3.1
         \Seen (system flag)
            Section 2.3.2
         \Sent (mailbox name attribute)
            Section 7.3.1
         \Subscribed (mailbox name attribute)
            Section 7.3.1
         \Trash (mailbox name attribute)
            Section 7.3.1
         \Unmarked (mailbox name attribute)
            Section 7.3.1

      A

         ALERT (response code)
            Section 7.1
         ALL (fetch item)
            Section 6.4.5
         ALL (search key)
            Section 6.4.4
         ALL (search result option)
            Section 6.4.4, Paragraph 6.6.1
         ALL (search return item name)
            Section 7.3.4, Paragraph 7.6.1
         ALREADYEXISTS (response code)
            Section 7.1, Paragraph 4.4.1
         ANSWERED (search key)
            Section 6.4.4
         APPEND (command)
            Section 6.3.12
         APPENDUID (response code)
            Section 7.1, Paragraph 4.6.1
         AUTHENTICATE (command)
            Section 6.2.2
         AUTHENTICATIONFAILED (response code)
            Section 7.1, Paragraph 4.8.1
         AUTHORIZATIONFAILED (response code)
            Section 7.1, Paragraph 4.10.1

      B

         BAD (response)
            Section 7.1.3
         BADCHARSET (response code)
            Section 7.1
         BCC <string> (search key)
            Section 6.4.4
         BEFORE <date> (search key)
            Section 6.4.4
         BINARY.PEEK[<section-binary>]<<partial>> (fetch item)
            Section 6.4.5
         BINARY.SIZE[<section-binary>] (fetch item)
            Section 6.4.5, Paragraph 9.6.1
         BINARY.SIZE[<section-binary>] (fetch result)
            Section 7.5.2, Paragraph 4.4.1
         BINARY[<section-binary>]<<number>> (fetch result)
            Section 7.5.2, Paragraph 4.2.1
         BINARY[<section-binary>]<<partial>> (fetch item)
            Section 6.4.5, Paragraph 9.2.1
         BODY (fetch item)
            Section 6.4.5
         BODY (fetch result)
            Section 7.5.2
         BODY <string> (search key)
            Section 6.4.4
         BODY.PEEK[<section>]<<partial>> (fetch item)
            Section 6.4.5
         BODYSTRUCTURE (fetch item)
            Section 6.4.5
         BODYSTRUCTURE (fetch result)
            Section 7.5.2, Paragraph 4.10.1
         BODY[<section>]<<origin octet>> (fetch result)
            Section 7.5.2, Paragraph 4.8.1
         BODY[<section>]<<partial>> (fetch item)
            Section 6.4.5, Paragraph 9.10.1
         BYE (response)
            Section 7.1.5
         Body Structure (message attribute)
            Section 2.3.6

      C

         CANNOT (response code)
            Section 7.1, Paragraph 4.14.1
         CAPABILITY (command)
            Section 6.1.1
         CAPABILITY (response code)
            Section 7.1
         CAPABILITY (response)
            Section 7.2.2
         CC <string> (search key)
            Section 6.4.4
         CLIENTBUG (response code)
            Section 7.1, Paragraph 4.18.1
         CLOSE (command)
            Section 6.4.1
         CLOSED (response code)
            Section 7.1, Paragraph 4.20.1
         CONTACTADMIN (response code)
            Section 7.1, Paragraph 4.22.1
         COPY (command)
            Section 6.4.7
         COPYUID (response code)
            Section 7.1, Paragraph 4.24.1
         CORRUPTION (response code)
            Section 7.1, Paragraph 4.26.1
         COUNT (search result option)
            Section 6.4.4
         COUNT (search return item name)
            Section 7.3.4
         CREATE (command)
            Section 6.3.4

      D

         DELETE (command)
            Section 6.3.5
         DELETED (search key)
            Section 6.4.4
         DELETED (status item)
            Section 6.3.11
         DRAFT (search key)
            Section 6.4.4

      E

         ENABLE (command)
            Section 6.3.1
         ENVELOPE (fetch item)
            Section 6.4.5
         ENVELOPE (fetch result)
            Section 7.5.2, Paragraph 4.42.1
         ESEARCH (response)
            Section 7.3.4
         EXAMINE (command)
            Section 6.3.3
         EXPIRED (response code)
            Section 7.1, Paragraph 4.28.1
         EXPUNGE (command)
            Section 6.4.3
         EXPUNGE (response)
            Section 7.5.1
         EXPUNGEISSUED (response code)
            Section 7.1, Paragraph 4.30.1
         Envelope Structure (message attribute)
            Section 2.3.5

      F

         FAST (fetch item)
            Section 6.4.5
         FETCH (command)
            Section 6.4.5
         FETCH (response)
            Section 7.5.2
         FLAGGED (search key)
            Section 6.4.4
         FLAGS (fetch item)
            Section 6.4.5
         FLAGS (fetch result)
            Section 7.5.2
         FLAGS (response)
            Section 7.3.5
         FLAGS <flag list> (store command data item)
            Section 6.4.6
         FLAGS.SILENT <flag list> (store command data item)
            Section 6.4.6
         FROM <string> (search key)
            Section 6.4.4
         FULL (fetch item)
            Section 6.4.5
         Flags (message attribute)
            Section 2.3.2

      H

         HASCHILDREN (response code)
            Section 7.1, Paragraph 4.32.1
         HEADER (part specifier)
            Section 6.4.5.1, Paragraph 5
         HEADER <field-name> <string> (search key)
            Section 6.4.4
         HEADER.FIELDS (part specifier)
            Section 6.4.5.1, Paragraph 5
         HEADER.FIELDS.NOT (part specifier)
            Section 6.4.5.1, Paragraph 5

      I

         IDLE (command)
            Section 6.3.13
         INTERNALDATE ( fetch item)
            Section 6.4.5
         INTERNALDATE (fetch result)
            Section 7.5.2
         INUSE (response code)
            Section 7.1, Paragraph 4.34.1
         Internal Date (message attribute)
            Section 2.3.3

      K

         KEYWORD <flag> (search key)
            Section 6.4.4
         Keyword (type of flag)
            Section 2.3.2, Paragraph 4

      L

         LARGER <n> (search key)
            Section 6.4.4
         LIMIT (response code)
            Section 7.1, Paragraph 4.36.1
         LIST (command)
            Section 6.3.9
         LIST (response)
            Section 7.3.1
         LOGOUT (command)
            Section 6.1.3

      M

         MAX (search result option)
            Section 6.4.4, Paragraph 6.4.1
         MAX (search return item name)
            Section 7.3.4, Paragraph 7.4.1
         MAY (specification requirement term)
            Section 1.2
         MESSAGES (status item)
            Section 6.3.11
         MIME (part specifier)
            Section 6.4.5.1, Paragraph 7
         MIN (search result option)
            Section 6.4.4, Paragraph 6.2.1
         MIN (search return item name)
            Section 7.3.4, Paragraph 7.2.1
         MOVE (command)
            Section 6.4.8
         MUST (specification requirement term)
            Section 1.2
         MUST NOT (specification requirement term)
            Section 1.2
         Message Sequence Number (message attribute)
            Section 2.3.1.2

      N

         NAMESPACE (command)
            Section 6.3.10
         NAMESPACE (response)
            Section 7.3.2
         NO (response)
            Section 7.1.2
         NONEXISTENT (response code)
            Section 7.1, Paragraph 4.38.1
         NOOP (command)
            Section 6.1.2
         NOPERM (response code)
            Section 7.1, Paragraph 4.40.1
         NOT <search-key> (search key)
            Section 6.4.4
         NOT RECOMMENDED (specification requirement term)
            Section 1.2

      O

         OK (response)
            Section 7.1.1
         ON <date> (search key)
            Section 6.4.4
         OPTIONAL (specification requirement term)
            Section 1.2; Section 1.2
         OR <search-key1> <search-key2> (search key)
            Section 6.4.4
         OVERQUOTA (response code)
            Section 7.1, Paragraph 4.42.1

      P

         PARSE (response code)
            Section 7.1
         PERMANENTFLAGS (response code)
            Section 7.1, Paragraph 4.46.1
         PREAUTH (response)
            Section 7.1.4
         PRIVACYREQUIRED (response code)
            Section 7.1, Paragraph 4.48.1
         Permanent Flag (class of flag)
            Section 2.3.2, Paragraph 9
         Predefined keywords
            Section 2.3.2, Paragraph 5

      R

         READ-ONLY (response code)
            Section 7.1
         READ-WRITE (response code)
            Section 7.1
         RECOMMENDED (specification requirement term)
            Section 1.2
         RENAME (command)
            Section 6.3.6
         REQUIRED (specification requirement term)
            Section 1.2
         RFC822.SIZE (fetch item)
            Section 6.4.5
         RFC822.SIZE (fetch result)
            Section 7.5.2
         RFC822.SIZE (message attribute)
            Section 2.3.4

      S

         SAVE (search result option)
            Section 6.4.4, Paragraph 6.10.1
         SEARCH (command)
            Section 6.4.4
         SEEN (search key)
            Section 6.4.4
         SELECT (command)
            Section 6.3.2
         SENTBEFORE <date> (search key)
            Section 6.4.4
         SENTON <date> (search key)
            Section 6.4.4
         SENTSINCE <date> (search key)
            Section 6.4.4
         SERVERBUG (response code)
            Section 7.1, Paragraph 4.54.1
         SHOULD (specification requirement term)
            Section 1.2
         SHOULD NOT (specification requirement term)
            Section 1.2
         SINCE <date> (search key)
            Section 6.4.4
         SIZE (status item)
            Section 6.3.11
         SMALLER <n> (search key)
            Section 6.4.4
         STARTTLS (command)
            Section 6.2.1
         STATUS (command)
            Section 6.3.11
         STATUS (response)
            Section 7.3.3
         STORE (command)
            Section 6.4.6
         SUBJECT <string> (search key)
            Section 6.4.4
         SUBSCRIBE (command)
            Section 6.3.7
         Session Flag (class of flag)
            Section 2.3.2, Paragraph 9
         System Flag (type of flag)
            Section 2.3.2, Paragraph 2

      T

         TEXT (part specifier)
            Section 6.4.5.1, Paragraph 5
         TEXT <string> (search key)
            Section 6.4.4
         TO <string> (search key)
            Section 6.4.4
         TRYCREATE (response code)
            Section 7.1

      U

         UID (command)
            Section 6.4.9
         UID (fetch item)
            Section 6.4.5
         UID (fetch result)
            Section 7.5.2
         UID <sequence set> (search key)
            Section 6.4.4
         UIDNEXT (response code)
            Section 7.1
         UIDNEXT (status item)
            Section 6.3.11
         UIDNOTSTICKY (response code)
            Section 7.1, Paragraph 4.60.1
         UIDVALIDITY (response code)
            Section 7.1
         UIDVALIDITY (status item)
            Section 6.3.11
         UNANSWERED (search key)
            Section 6.4.4
         UNAVAILABLE (response code)
            Section 7.1, Paragraph 4.64.1
         UNDELETED (search key)
            Section 6.4.4
         UNDRAFT (search key)
            Section 6.4.4
         UNFLAGGED (search key)
            Section 6.4.4
         UNKEYWORD <flag> (search key)
            Section 6.4.4
         UNKNOWN-CTE (response code)
            Section 7.1
         UNSEEN (search key)
            Section 6.4.4
         UNSEEN (status item)
            Section 6.3.11
         UNSELECT (command)
            Section 6.4.2
         UNSUBSCRIBE (command)
            Section 6.3.8
         Unique Identifier (UID) (message attribute)
            Section 2.3.1.1
```

---
# **Authors' Addresses**

```text
   Alexey Melnikov (editor)
   Isode Ltd
   14 Castle Mews
   Hampton, Middlesex
   TW12 2NP
   United Kingdom

   Email: Alexey.Melnikov@isode.com

   Barry Leiba (editor)
   Futurewei Technologies

   Email: barryleiba@computer.org
   URI:   http://internetmessagingtechnology.org/
```
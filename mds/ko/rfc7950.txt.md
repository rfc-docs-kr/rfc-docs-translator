

```text
Internet Engineering Task Force (IETF)                 M. Bjorklund, Ed.
Request for Comments: 7950                                Tail-f Systems
Category: Standards Track                                    August 2016
ISSN: 2070-1721
```

- YANG 1.1 데이터 모델링 언어

---
# **Abstract**

YANG은 구성 데이터, 상태 데이터, 원격 프로시저 호출 및 네트워크 관리 프로토콜에 대한 알림을 모델링하는 데 사용되는 데이터 모델링 언어입니다. 이 문서에서는 YANG 언어 버전 1.1의 구문과 의미를 설명합니다. YANG 버전 1.1은 원래 사양의 모호함과 결함을 해결하는 YANG 언어의 유지 관리 릴리스입니다. YANG 버전 1에는 이전 버전과 약간의 비호환성이 있습니다. 이 문서에서는 NETCONF\(Network Configuration Protocol\)에 대한 YANG 매핑도 지정합니다.

---
# **Status of This Memo**

이것은 인터넷 표준 추적 문서입니다.

이 문서는 IETF\(Internet Engineering Task Force\)의 제품입니다. 이는 IETF 커뮤니티의 합의를 나타냅니다. 공개 검토를 받았으며 IESG\(Internet Engineering Steering Group\)의 출판 승인을 받았습니다. 인터넷 표준에 대한 자세한 내용은 RFC 7841의 섹션 2에서 확인할 수 있습니다.

이 문서의 현재 상태, 정오표, 피드백 제공 방법에 대한 정보는 http://www.rfc-editor.org/info/rfc7950에서 얻을 수 있습니다.

---
# **Copyright Notice**

Copyright \(c\) 2016 IETF Trust 및 문서 작성자로 확인된 사람. 판권 소유.

이 문서는 이 문서의 발행일에 유효한 BCP 78 및 IETF 문서에 관한 IETF 트러스트의 법적 조항\(http://trustee.ietf.org/license-info\)의 적용을 받습니다. 이 문서와 관련된 귀하의 권리 및 제한 사항을 설명하므로 이 문서를 주의 깊게 검토하십시오. 이 문서에서 추출한 코드 구성 요소는 Trust Legal Provisions의 섹션 4.e에 설명된 대로 Simplified BSD License 텍스트를 포함해야 하며 Simplified BSD License에 설명된 대로 보증 없이 제공됩니다.

이 문서에는 2008년 11월 10일 이전에 공개되거나 공개된 IETF 문서 또는 IETF 기고문의 자료가 포함될 수 있습니다. 이 자료의 일부에 대한 저작권을 제어하는 ​​사람은 해당 자료의 수정을 허용할 권리를 IETF 트러스트에 부여하지 않았을 수 있습니다. IETF 표준 프로세스 외부. 이러한 자료의 저작권을 관리하는 사람으로부터 적절한 라이센스를 얻지 않고 이 문서는 IETF 표준 프로세스 외부에서 수정할 수 없으며 IETF 표준 프로세스 외부에서 이 문서의 파생물을 생성할 수 없습니다. RFC로 게시하거나 영어 이외의 언어로 번역합니다.

---
# **Table of Contents**

```text
   1. Introduction ....................................................9
      1.1. Summary of Changes from RFC 6020 ..........................10
   2. Key Words ......................................................12
   3. Terminology ....................................................12
      3.1. A Note on Examples ........................................16
   4. YANG Overview ..................................................16
      4.1. Functional Overview .......................................16
      4.2. Language Overview .........................................18
           4.2.1. Modules and Submodules .............................18
           4.2.2. Data Modeling Basics ...............................19
           4.2.3. Configuration and State Data .......................23
           4.2.4. Built-In Types .....................................24
           4.2.5. Derived Types (typedef) ............................25
           4.2.6. Reusable Node Groups (grouping) ....................25
           4.2.7. Choices ............................................27
           4.2.8. Extending Data Models (augment) ....................28
           4.2.9. Operation Definitions ..............................29
           4.2.10. Notification Definitions ..........................31
   5. Language Concepts ..............................................32
      5.1. Modules and Submodules ....................................32
           5.1.1. Import and Include by Revision .....................33
           5.1.2. Module Hierarchies .................................34
      5.2. File Layout ...............................................36
      5.3. XML Namespaces ............................................36
           5.3.1. YANG XML Namespace .................................36
      5.4. Resolving Grouping, Type, and Identity Names ..............37
      5.5. Nested Typedefs and Groupings .............................37
      5.6. Conformance ...............................................38
           5.6.1. Basic Behavior .....................................38
           5.6.2. Optional Features ..................................38
           5.6.3. Deviations .........................................39
           5.6.4. Announcing Conformance Information in NETCONF ......40
           5.6.5. Implementing a Module ..............................40
      5.7. Datastore Modification ....................................44
   6. YANG Syntax ....................................................44
      6.1. Lexical Tokenization ......................................45
           6.1.1. Comments ...........................................45
           6.1.2. Tokens .............................................45
           6.1.3. Quoting ............................................45
      6.2. Identifiers ...............................................47
           6.2.1. Identifiers and Their Namespaces ...................47
      6.3. Statements ................................................48
           6.3.1. Language Extensions ................................48
      6.4. XPath Evaluations .........................................49
           6.4.1. XPath Context ......................................50
      6.5. Schema Node Identifier ....................................54
   7. YANG Statements ................................................55
      7.1. The "module" Statement ....................................55
           7.1.1. The module's Substatements .........................56
           7.1.2. The "yang-version" Statement .......................57
           7.1.3. The "namespace" Statement ..........................57
           7.1.4. The "prefix" Statement .............................57
           7.1.5. The "import" Statement .............................58
           7.1.6. The "include" Statement ............................59
           7.1.7. The "organization" Statement .......................60
           7.1.8. The "contact" Statement ............................60
           7.1.9. The "revision" Statement ...........................60
           7.1.10. Usage Example .....................................61
      7.2. The "submodule" Statement .................................62
           7.2.1. The submodule's Substatements ......................63
           7.2.2. The "belongs-to" Statement .........................63
           7.2.3. Usage Example ......................................64
      7.3. The "typedef" Statement ...................................65
           7.3.1. The typedef's Substatements ........................65
           7.3.2. The typedef's "type" Statement .....................65
           7.3.3. The "units" Statement ..............................65
           7.3.4. The typedef's "default" Statement ..................66
           7.3.5. Usage Example ......................................66
      7.4. The "type" Statement ......................................66
           7.4.1. The type's Substatements ...........................67
      7.5. The "container" Statement .................................67
           7.5.1. Containers with Presence ...........................67
           7.5.2. The container's Substatements ......................68
           7.5.3. The "must" Statement ...............................69
           7.5.4. The must's Substatements ...........................70
           7.5.5. The "presence" Statement ...........................71
           7.5.6. The container's Child Node Statements ..............71
           7.5.7. XML Encoding Rules .................................71
           7.5.8. NETCONF <edit-config> Operations ...................72
           7.5.9. Usage Example ......................................72
      7.6. The "leaf" Statement ......................................73
           7.6.1. The leaf's Default Value ...........................74
           7.6.2. The leaf's Substatements ...........................75
           7.6.3. The leaf's "type" Statement ........................75
           7.6.4. The leaf's "default" Statement .....................75
           7.6.5. The leaf's "mandatory" Statement ...................76
           7.6.6. XML Encoding Rules .................................76
           7.6.7. NETCONF <edit-config> Operations ...................76
           7.6.8. Usage Example ......................................77
      7.7. The "leaf-list" Statement .................................77
           7.7.1. Ordering ...........................................78
           7.7.2. The leaf-list's Default Values .....................79
           7.7.3. The leaf-list's Substatements ......................80
           7.7.4. The leaf-list's "default" Statement ................80
           7.7.5. The "min-elements" Statement .......................80
           7.7.6. The "max-elements" Statement .......................81
           7.7.7. The "ordered-by" Statement .........................81
           7.7.8. XML Encoding Rules .................................82
           7.7.9. NETCONF <edit-config> Operations ...................82
           7.7.10. Usage Example .....................................83
      7.8. The "list" Statement ......................................84
           7.8.1. The list's Substatements ...........................85
           7.8.2. The list's "key" Statement .........................85
           7.8.3. The list's "unique" Statement ......................86
           7.8.4. The list's Child Node Statements ...................87
           7.8.5. XML Encoding Rules .................................88
           7.8.6. NETCONF <edit-config> Operations ...................88
           7.8.7. Usage Example ......................................90
      7.9. The "choice" Statement ....................................93
           7.9.1. The choice's Substatements .........................94
           7.9.2. The choice's "case" Statement ......................94
           7.9.3. The choice's "default" Statement ...................96
           7.9.4. The choice's "mandatory" Statement .................98
           7.9.5. XML Encoding Rules .................................98
           7.9.6. Usage Example ......................................99
      7.10. The "anydata" Statement .................................100
           7.10.1. The anydata's Substatements ......................100
           7.10.2. XML Encoding Rules ...............................101
           7.10.3. NETCONF <edit-config> Operations .................101
           7.10.4. Usage Example ....................................101
      7.11. The "anyxml" Statement ..................................102
           7.11.1. The anyxml's Substatements .......................103
           7.11.2. XML Encoding Rules ...............................103
           7.11.3. NETCONF <edit-config> Operations .................103
           7.11.4. Usage Example ....................................104
      7.12. The "grouping" Statement ................................104
           7.12.1. The grouping's Substatements .....................105
           7.12.2. Usage Example ....................................105
      7.13. The "uses" Statement ....................................106
           7.13.1. The uses's Substatements .........................106
           7.13.2. The "refine" Statement ...........................106
           7.13.3. XML Encoding Rules ...............................107
           7.13.4. Usage Example ....................................107
      7.14. The "rpc" Statement .....................................108
           7.14.1. The rpc's Substatements ..........................109
           7.14.2. The "input" Statement ............................109
           7.14.3. The "output" Statement ...........................110
           7.14.4. NETCONF XML Encoding Rules .......................111
           7.14.5. Usage Example ....................................112
      7.15. The "action" Statement ..................................113
           7.15.1. The action's Substatements .......................114
           7.15.2. NETCONF XML Encoding Rules .......................114
           7.15.3. Usage Example ....................................115
      7.16. The "notification" Statement ............................116
           7.16.1. The notification's Substatements .................117
           7.16.2. NETCONF XML Encoding Rules .......................117
           7.16.3. Usage Example ....................................118
      7.17. The "augment" Statement .................................119
           7.17.1. The augment's Substatements ......................121
           7.17.2. XML Encoding Rules ...............................121
           7.17.3. Usage Example ....................................122
      7.18. The "identity" Statement ................................124
           7.18.1. The identity's Substatements .....................124
           7.18.2. The "base" Statement .............................124
           7.18.3. Usage Example ....................................125
      7.19. The "extension" Statement ...............................126
           7.19.1. The extension's Substatements ....................126
           7.19.2. The "argument" Statement .........................127
           7.19.3. Usage Example ....................................127
      7.20. Conformance-Related Statements ..........................128
           7.20.1. The "feature" Statement ..........................128
           7.20.2. The "if-feature" Statement .......................130
           7.20.3. The "deviation" Statement ........................131
      7.21. Common Statements .......................................134
           7.21.1. The "config" Statement ...........................134
           7.21.2. The "status" Statement ...........................135
           7.21.3. The "description" Statement ......................136
           7.21.4. The "reference" Statement ........................136
           7.21.5. The "when" Statement .............................136
   8. Constraints ...................................................138
      8.1. Constraints on Data ......................................138
      8.2. Configuration Data Modifications .........................139
      8.3. NETCONF Constraint Enforcement Model .....................139
           8.3.1. Payload Parsing ...................................139
           8.3.2. NETCONF <edit-config> Processing ..................140
           8.3.3. Validation ........................................141
   9. Built-In Types ................................................141
      9.1. Canonical Representation .................................141
      9.2. The Integer Built-In Types ...............................142
           9.2.1. Lexical Representation ............................142
           9.2.2. Canonical Form ....................................143
           9.2.3. Restrictions ......................................143
           9.2.4. The "range" Statement .............................143
           9.2.5. Usage Example .....................................144
      9.3. The decimal64 Built-In Type ..............................144
           9.3.1. Lexical Representation ............................145
           9.3.2. Canonical Form ....................................145
           9.3.3. Restrictions ......................................145
           9.3.4. The "fraction-digits" Statement ...................145
           9.3.5. Usage Example .....................................146
      9.4. The string Built-In Type .................................146
           9.4.1. Lexical Representation ............................146
           9.4.2. Canonical Form ....................................147
           9.4.3. Restrictions ......................................147
           9.4.4. The "length" Statement ............................147
           9.4.5. The "pattern" Statement ...........................148
           9.4.6. The "modifier" Statement ..........................148
           9.4.7. Usage Example .....................................149
      9.5. The boolean Built-In Type ................................150
           9.5.1. Lexical Representation ............................150
           9.5.2. Canonical Form ....................................150
           9.5.3. Restrictions ......................................150
      9.6. The enumeration Built-In Type ............................150
           9.6.1. Lexical Representation ............................150
           9.6.2. Canonical Form ....................................151
           9.6.3. Restrictions ......................................151
           9.6.4. The "enum" Statement ..............................151
           9.6.5. Usage Example .....................................152
      9.7. The bits Built-In Type ...................................154
           9.7.1. Restrictions ......................................154
           9.7.2. Lexical Representation ............................154
           9.7.3. Canonical Form ....................................154
           9.7.4. The "bit" Statement ...............................155
           9.7.5. Usage Example .....................................156
      9.8. The binary Built-In Type .................................157
           9.8.1. Restrictions ......................................157
           9.8.2. Lexical Representation ............................157
           9.8.3. Canonical Form ....................................157
      9.9. The leafref Built-In Type ................................157
           9.9.1. Restrictions ......................................158
           9.9.2. The "path" Statement ..............................158
           9.9.3. The "require-instance" Statement ..................159
           9.9.4. Lexical Representation ............................159
           9.9.5. Canonical Form ....................................159
           9.9.6. Usage Example .....................................159
      9.10. The identityref Built-In Type ...........................163
           9.10.1. Restrictions .....................................163
           9.10.2. The identityref's "base" Statement ...............163
           9.10.3. Lexical Representation ...........................163
           9.10.4. Canonical Form ...................................164
           9.10.5. Usage Example ....................................164
      9.11. The empty Built-In Type .................................165
           9.11.1. Restrictions .....................................165
           9.11.2. Lexical Representation ...........................165
           9.11.3. Canonical Form ...................................165
           9.11.4. Usage Example ....................................166
      9.12. The union Built-In Type .................................166
           9.12.1. Restrictions .....................................166
           9.12.2. Lexical Representation ...........................166
           9.12.3. Canonical Form ...................................167
           9.12.4. Usage Example ....................................167
      9.13. The instance-identifier Built-In Type ...................168
           9.13.1. Restrictions .....................................168
           9.13.2. Lexical Representation ...........................169
           9.13.3. Canonical Form ...................................169
           9.13.4. Usage Example ....................................169
   10. XPath Functions ..............................................170
      10.1. Function for Node Sets ..................................170
           10.1.1. current() ........................................170
      10.2. Function for Strings ....................................170
           10.2.1. re-match() .......................................170
      10.3. Function for the YANG Types "leafref" and
            "instance-identifier" ...................................171
           10.3.1. deref() ..........................................171
      10.4. Functions for the YANG Type "identityref" ...............172
           10.4.1. derived-from() ...................................172
           10.4.2. derived-from-or-self() ...........................174
      10.5. Function for the YANG Type "enumeration" ................174
           10.5.1. enum-value() .....................................174
      10.6. Function for the YANG Type "bits" .......................175
           10.6.1. bit-is-set() .....................................175
   11. Updating a Module ............................................176
   12. Coexistence with YANG Version 1 ..............................179
   13. YIN ..........................................................179
      13.1. Formal YIN Definition ...................................180
           13.1.1. Usage Example ....................................182
   14. YANG ABNF Grammar ............................................184
   15. NETCONF Error Responses for YANG-Related Errors ..............211
      15.1. Error Message for Data That Violates a "unique"
            Statement ...............................................211
      15.2. Error Message for Data That Violates a
            "max-elements" Statement ................................211
      15.3. Error Message for Data That Violates a
            "min-elements" Statement ................................211
      15.4. Error Message for Data That Violates a "must"
            Statement ...............................................212
      15.5. Error Message for Data That Violates a
            "require-instance" Statement ............................212
      15.6. Error Message for Data That Violates a Mandatory
            "choice" Statement ......................................212
      15.7. Error Message for the "insert" Operation ................212
   16. IANA Considerations ..........................................213
   17. Security Considerations ......................................213
   18. References ...................................................214
      18.1. Normative References ....................................214
      18.2. Informative References ..................................215
   Acknowledgements .................................................217
   Contributors .....................................................217
   Author's Address .................................................217
```

---
## **1.  Introduction**

YANG은 원래 NETCONF\(네트워크 구성 프로토콜\), NETCONF 원격 프로시저 호출 및 NETCONF 알림\[RFC6241\]에 의해 조작되는 구성 및 상태 데이터를 모델링하도록 설계된 데이터 모델링 언어입니다. YANG 버전 1 \[RFC6020\]이 발표된 이후 YANG은 다른 프로토콜\(예: RESTCONF \[RESTCONF\] 및 CoAP\(Constrained Application Protocol\) 관리 인터페이스\(CoMI\) \[CoMI\]\)에 사용되거나 사용하도록 제안되었습니다. 또한 XML 이외의 인코딩이 제안되었습니다\(예: JSON \[RFC7951\]\).

이 문서에서는 YANG 언어 버전 1.1의 구문과 의미를 설명합니다. 또한 YANG 모듈에 정의된 데이터 모델이 XML\(Extensible Markup Language\) \[XML\]로 인코딩되는 방법과 NETCONF 작업을 사용하여 데이터를 조작하는 방법에 대해서도 설명합니다. 다른 프로토콜과 인코딩도 가능하지만 이 사양의 범위를 벗어납니다.

YANG 데이터 모델 개발과 관련하여 \[YANG-Guidelines\]에서는 몇 가지 지침과 권장 사항을 제공합니다.

이 문서는 RFC 6020 \[RFC6020\]을 폐기하지 않습니다.

---
### **1.1.  Summary of Changes from RFC 6020**

이 문서는 YANG 언어 버전 1.1을 정의합니다. YANG 버전 1.1은 원래 사양\[RFC6020\]의 모호성과 결함을 해결하는 YANG 언어의 유지 관리 릴리스입니다.

다음 변경 사항은 YANG 버전 1과 이전 버전과 호환되지 않습니다.

o 큰따옴표로 묶인 문자열의 이스케이프 문자 해석 규칙을 변경했습니다. 이는 YANG 버전 1에서 이전 버전과 호환되지 않는 변경 사항입니다. YANG 버전 1 모듈을 1.1로 업데이트하고 모듈이 현재 불법인 문자 시퀀스를 사용하는 경우 새 규칙과 일치하도록 문자열을 변경해야 합니다. 자세한 내용은 섹션 6.1.3을 참조하세요.

o 따옴표가 없는 문자열에는 작은따옴표나 큰따옴표 문자가 포함될 수 없습니다. 이는 YANG 버전 1에서 이전 버전과 호환되지 않는 변경 사항입니다. YANG 버전 1 모듈을 1.1로 업데이트하고 모듈에서 이러한 인용 문자를 사용하는 경우 새 규칙과 일치하도록 문자열을 변경해야 합니다. 자세한 내용은 섹션 6.1.3을 참조하세요.

o 목록 키에서 "when" 및 "if-feature"를 불법으로 만들었습니다. 이는 YANG 버전 1에서 이전 버전과 호환되지 않는 변경 사항입니다. YANG 버전 1 모듈을 1.1로 업데이트하고 모듈에서 이러한 구성을 사용하는 경우 새 규칙과 일치하도록 제거해야 합니다.

o YANG 모듈에서 유효한 문자를 정의했습니다. YANG 버전 1 모듈을 1.1로 업데이트할 때 현재 불법인 문자는 모두 제거해야 합니다. 자세한 내용은 섹션 6을 참조하세요.

o 내장 유형 "string"에서 문자가 아닌 문자를 사용할 수 없게 만들었습니다. 이 변경 사항은 YANG 기반 프로토콜의 런타임 동작에 영향을 미칩니다.

YANG에 다음과 같은 추가 변경 사항이 적용되었습니다.

o YANG 버전을 "1"에서 "1.1"로 변경했습니다.

o YANG 버전 "1.1"에서 "yang-version" 문을 필수로 만들었습니다.

o 기능 이름에 대한 부울 표현식이 되도록 "if-feature" 구문을 확장했습니다.

o "bit", "enum" 및 "identity"에서 "if-feature"를 허용합니다.

o "refine"에서 "if-feature"를 허용합니다.

o "선택"을 "case"라는 약칭으로 허용합니다\(참조:

- 섹션 7.9.2\).

o "패턴" 진술에 새로운 하위 진술 "수정자"를 추가했습니다\(섹션 9.4.6 참조\).

o "입력", "출력" 및 "알림"에 "반드시"를 허용합니다.

o leafref에서 "require-instance"를 허용합니다.

o "가져오기" 및 "포함"에서 "설명" 및 "참조"를 허용합니다.

o 모듈의 여러 개정판 가져오기를 허용합니다.

o 조건부 필수 노드를 추가하기 위해 "증강"을 허용합니다\(참조:

- 섹션 7.17\).

o 새로운 XPath\(XML Path Language\) 기능 세트가 추가되었습니다.

- 섹션 10.

o 섹션 6.4.1에서 XPath 컨텍스트의 트리를 명확하게 했습니다.

o XPath 표현식에서 IDref의 문자열 값을 정의했습니다\(섹션 9.10 참조\).

o typedef의 leafref에서 접두사가 없는 이름의 의미를 명확히 했습니다\(섹션 6.4.1 및 9.9.2 참조\).

o 여러 기본 ID에서 ID가 파생되도록 허용합니다\(섹션 7.18 및 9.10 참조\).

o 열거형과 비트의 하위 유형을 허용합니다\(섹션 9.6 및 9.7 참조\).

o 리프 목록이 기본값을 갖도록 허용합니다\(섹션 7.7.2 참조\).

o 비구성 리프 목록에서 고유하지 않은 값을 허용합니다\(섹션 7.7 참조\).

o 문법에서 대소문자 구분 문자열에 대한 구문을 사용합니다\(\[RFC7405\]에 따름\).

o 모듈 광고 메커니즘을 변경했습니다\(섹션 5.6.4 참조\).

o 하위 모듈의 정의에 대한 범위 지정 규칙이 변경되었습니다. 이제 하위 모듈은 "include" 문을 사용하지 않고도 동일한 모듈에 속하는 모든 하위 모듈의 모든 정의를 참조할 수 있습니다.

o 데이터 노드에 연결된 작업을 정의하는 데 사용되는 새로운 문 "action"을 추가했습니다.

o 알림이 데이터 노드에 연결되도록 허용합니다.

o 새로운 데이터 정의문 "anydata"를 추가했습니다\(참조:

- 섹션 7.10\), 데이터가 YANG에서 모델링될 수 있는 경우 "anyxml" 대신 사용하는 것이 권장됩니다.\(SHOULD\)

o 공용체에서 "empty" 및 "leafref" 유형을 허용합니다.

o 키에 "비어 있음" 유형을 허용합니다.

o 식별자가 "xml" 문자로 시작할 수 없다는 제한을 제거했습니다.

NETCONF 매핑이 다음과 같이 변경되었습니다.

o 서버는 다음을 사용하여 YANG 1.1 모듈에 대한 지원을 알립니다.

- ietf-yang-library \[RFC7895\] 대신 <hello\> 메시지의 기능으로 나열합니다.

---
## **2.  Key Words**

핵심 단어 "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY" 및 "OPTIONAL 이 문서의 "는 BCP 14 \[RFC2119\]에 설명된 대로 해석됩니다.\(MUST NOT\)

---
## **3.  Terminology**

이 문서에서는 다음 용어가 사용됩니다.

o 작업: 데이터 트리의 노드에 대해 정의된 작업입니다.

o anydata: anyxml을 제외하고 YANG으로 모델링할 수 있는 알려지지 않은 노드 집합을 포함할 수 있는 데이터 노드입니다.

o anyxml: 알 수 없는 XML 데이터 청크를 포함할 수 있는 데이터 노드입니다.

o 기능 보강: 이전에 정의된 스키마 노드에 새 스키마 노드를 추가합니다.

o 기본 유형: 파생 유형이 파생된 유형으로, 내장 유형이거나 다른 파생 유형일 수 있습니다.

o 내장 유형: uint32 또는 문자열과 같이 YANG 언어로 정의된 YANG 데이터 유형입니다.

o 선택: 식별된 여러 대안 중 하나만 유효한 스키마 노드입니다.

o 클라이언트: 일부 네트워크 관리 프로토콜을 통해 서버의 YANG 정의 데이터에 액세스할 수 있는 엔터티입니다.

o 적합성: 서버가 데이터 모델을 얼마나 정확하게 따르는지에 대한 척도입니다.

o 컨테이너: 데이터 트리에서 최대 하나의 인스턴스에 존재하는 내부 데이터 노드입니다. 컨테이너에는 값이 없지만 하위 노드 집합이 있습니다.

o 데이터 정의문: 새로운 데이터 노드를 정의하는 문입니다. "컨테이너", "리프", "리프 목록", "목록", "선택", "케이스", "증강", "사용", "anydata" 및 "anyxml" 중 하나입니다.

o 데이터 모델: 데이터 모델은 데이터가 표현되고 액세스되는 방식을 설명합니다.

o 데이터 노드: 데이터 트리에서 인스턴스화될 수 있는 스키마 트리의 노드입니다. 컨테이너, 리프, 리프-리스트, 리스트, 애니데이터, 애니xml 중 하나입니다.

o 데이터 트리: 구성 데이터, 상태 데이터, 결합된 구성 및 상태 데이터, RPC 또는 작업 입력, RPC 또는 작업 출력 또는 알림과 같이 YANG으로 모델링된 모든 데이터의 인스턴스화된 트리입니다.

o 파생 유형: 내장 유형\(예: uint32\) 또는 다른 파생 유형에서 파생된 유형입니다.

o 확장: 확장은 YANG이 아닌 의미를 명령문에 첨부합니다. "확장" 문은 이러한 의미를 표현하기 위해 새로운 문을 정의합니다.

o 기능: 모델의 일부를 선택 사항으로 표시하는 메커니즘입니다. 정의에는 기능 이름으로 태그를 지정할 수 있으며 해당 기능을 지원하는 서버에서만 유효합니다.

o 그룹화: 모듈에서 로컬로 사용하거나 모듈에서 가져오는 다른 모듈에서 사용할 수 있는 재사용 가능한 스키마 노드 집합입니다. "그룹화" 문은 데이터 정의 문이 아니므로 스키마 트리의 노드를 정의하지 않습니다.

o 식별자: 다양한 종류의 YANG 항목을 이름으로 식별하는 데 사용되는 문자열입니다.

o ID: 전역적으로 고유하고 추상적이며 유형이 지정되지 않은 이름입니다.

o 인스턴스 식별자: 데이터 트리에서 특정 노드를 식별하기 위한 메커니즘입니다.

o 내부 노드: 리프 노드가 아닌 계층 구조 내의 노드입니다.

o 리프\(leaf\): 데이터 트리에서 최대 하나의 인스턴스에 존재하는 데이터 노드입니다. 리프에는 값이 있지만 하위 노드는 없습니다.

o 리프 목록\(leaf-list\): 리프 노드와 비슷하지만 단일 노드가 아닌 고유하게 식별 가능한 노드 집합을 정의합니다. 각 노드에는 값이 있지만 하위 노드는 없습니다.

o 목록: 데이터 트리의 여러 인스턴스에 존재할 수 있는 내부 데이터 노드입니다. 목록에는 값이 없고 오히려 하위 노드 집합이 있습니다.

o 필수 노드: 필수 노드는 다음 중 하나입니다.

- \* 값이 "true"인 "필수" 문이 있는 리프, 선택, anydata 또는 anyxml 노드입니다.

- \* 0보다 큰 값을 갖는 "min-elements" 문이 있는 목록 또는 리프 목록 노드입니다.

- \* "존재" 설명이 없고 하위 노드로 필수 노드가 하나 이상 있는 컨테이너 노드입니다.

o 모듈: YANG 모듈은 스키마 노드의 계층 구조를 정의합니다. 정의와 다른 곳에서 가져오거나 포함하는 정의를 통해 모듈은 독립적이며 "컴파일 가능"합니다.

o 비존재 컨테이너: 자체적으로는 의미가 없고 하위 노드를 포함하기 위해서만 존재하는 컨테이너입니다.

o 존재 컨테이너: 존재가 존재하는 컨테이너

- 컨테이너 자체에는 어떤 의미가 있습니다.

o RPC: 원격 프로시저 호출.

o RPC 작업: 특정 원격 프로시저 호출.

o 스키마 노드: 스키마 트리의 노드입니다. 액션, 컨테이너, 리프, 리프 목록, 목록, 선택, 케이스, rpc, 입력, 출력, 알림, anydata, anyxml 중 하나입니다.

o 스키마 노드 식별자: 스키마 트리에서 특정 노드를 식별하기 위한 메커니즘입니다.

o 스키마 트리: 모듈 내에 지정된 정의 계층입니다.

o 서버: 일부 네트워크 관리 프로토콜을 통해 클라이언트에게 YANG 정의 데이터에 대한 액세스를 제공하는 엔터티입니다.

o 서버 편차: 서버가 모듈을 충실하게 구현하지 못하는 것입니다.

o 하위 모듈: 파생된 유형, 그룹화, 데이터 노드, RPC, 작업 및 알림을 모듈에 제공하는 부분 모듈 정의입니다. YANG 모듈은 여러 하위 모듈로 구성될 수 있습니다.

o 최상위 데이터 노드: "모듈" 또는 "하위 모듈" 문과 사이에 다른 데이터 노드가 없는 데이터 노드입니다.

o 사용: "uses" 문은 "grouping" 문에 정의된 스키마 노드 집합을 인스턴스화하는 데 사용됩니다. 인스턴스화된 노드는 특정 요구 사항에 맞게 조정 및 확장될 수 있습니다.

o 값 공간: 데이터 유형의 경우; 데이터 유형이 허용하는 값 ​​세트. 리프 또는 리프 목록 인스턴스의 경우; 데이터 유형의 값 공간.

다음 용어는 \[RFC6241\]에 정의되어 있습니다.

```text
   o  configuration data

   o  configuration datastore

   o  datastore

   o  state data
```

YANG으로 모델링하면 데이터 저장소는 인스턴스화된 데이터 트리로 구현됩니다.

YANG으로 모델링할 때 구성 데이터 저장소는 구성 데이터가 포함된 인스턴스화된 데이터 트리로 구현됩니다.

---
### **3.1.  A Note on Examples**

이 문서 전체에는 YANG 문의 예가 ​​많이 있습니다. 이러한 예는 특정 기능을 설명하기 위한 것이며 완전하고 유효한 YANG 모듈로 간주되지 않습니다.

---
## **4.  YANG Overview**

이 비표준 섹션은 처음 독자에게 YANG에 대한 높은 수준의 개요를 제공하기 위한 것입니다.

---
### **4.1.  Functional Overview**

YANG은 원래 NETCONF 프로토콜의 데이터를 모델링하도록 설계된 언어입니다. YANG 모듈은 구성, 상태 데이터, RPC 및 알림을 포함하여 NETCONF 기반 작업에 사용할 수 있는 데이터 계층을 정의합니다. 이를 통해 NETCONF 클라이언트와 서버 간에 전송되는 모든 데이터에 대한 완전한 설명이 가능합니다. 이 사양의 범위를 벗어나더라도 YANG은 NETCONF 이외의 프로토콜과 함께 사용할 수도 있습니다.

YANG은 데이터의 계층적 구성을 각 노드에 이름과 값 또는 하위 노드 집합이 있는 트리로 모델링합니다. YANG은 노드에 대한 명확하고 간결한 설명과 해당 노드 간의 상호 작용을 제공합니다.

YANG은 데이터 모델을 모듈과 하위 모듈로 구성합니다. 모듈은 다른 외부 모듈에서 정의를 가져올 수 있으며 하위 모듈의 정의를 포함할 수 있습니다. 계층 구조를 확장하여 한 모듈에서 다른 모듈에 정의된 계층 구조에 데이터 노드를 추가할 수 있습니다. 이 증강은 특정 조건이 충족되는 경우에만 새 노드가 나타나는 조건부일 수 있습니다.

YANG 데이터 모델은 계층 구조에 있는 다른 노드의 존재 또는 값을 기반으로 노드의 존재 또는 값을 제한하여 데이터에 적용되는 제약 조건을 설명할 수 있습니다. 이러한 제약 조건은 클라이언트나 서버에서 시행할 수 있습니다.

YANG은 내장 유형 세트를 정의하고 추가 유형을 정의할 수 있는 유형 메커니즘을 가지고 있습니다. 파생 유형은 클라이언트나 서버에서 시행할 수 있는 범위 또는 패턴 제한과 같은 메커니즘을 사용하여 기본 유형의 유효한 값 집합을 제한할 수 있습니다. 또한 호스트 이름이 포함된 문자열 기반 유형과 같은 파생 유형 사용에 대한 사용 규칙을 정의할 수도 있습니다.

YANG은 재사용 가능한 노드 그룹 정의를 허용합니다. 이러한 그룹화를 사용하면 노드를 개선하거나 강화하여 특정 요구 사항에 맞게 노드를 조정할 수 있습니다. 파생 유형 및 그룹화는 하나의 모듈에서 정의할 수 있으며 동일한 모듈이나 이를 가져오는 다른 모듈에서 사용할 수 있습니다.

YANG 데이터 계층 구조에는 목록 항목이 서로 구별되는 키로 식별되는 목록 정의가 포함됩니다. 이러한 목록은 사용자별로 정렬되거나 시스템에서 자동으로 정렬되도록 정의될 수 있습니다. 사용자 정렬 목록의 경우 목록 항목의 순서를 조작하기 위한 작업이 정의됩니다.

YANG 모듈은 YIN\(YANG Independent Notation\)\(섹션 13\)이라는 동등한 XML 구문으로 변환될 수 있으므로 XML 파서 및 XSLT\(Extensible Stylesheet Language Transformations\) 스크립트를 사용하는 애플리케이션이 모델에서 작동할 수 있습니다. YANG에서 YIN으로의 변환은 의미상 무손실이므로 YIN의 콘텐츠를 다시 YANG으로 왕복할 수 있습니다.

YANG은 확장 가능한 언어로 표준 기관, 공급업체 및 개인이 확장을 정의할 수 있습니다. 명령문 구문을 사용하면 이러한 확장이 표준 YANG 문과 자연스럽게 공존할 수 있으며, YANG 모듈의 확장은 독자가 알아차릴 만큼 충분히 두드러집니다.

YANG은 임의의 XML 문서나 임의의 데이터 모델이 아닌 NETCONF와 같은 네트워크 관리 프로토콜에 대한 데이터 모델의 표현을 허용하도록 문제 공간을 제한하여 가능한 모든 문제를 해결하려는 경향에 저항합니다.

YANG은 가능한 한 SNMP\(Simple Network Management Protocol\)의 SMIv2\(Structure of Management Information 버전 2 \[RFC2578\] \[RFC2579\]\)와의 호환성을 유지합니다. SMIv2 기반 MIB 모듈은 읽기 전용 액세스를 위해 YANG 모듈로 자동 변환될 수 있습니다\[RFC6643\]. 그러나 YANG은 YANG에서 SMIv2로의 역변환에는 관심이 없습니다.

---
### **4.2.  Language Overview**

이 섹션에서는 이후 섹션의 언어 세부 사항을 이해하는 데 도움이 되는 YANG에서 사용되는 몇 가지 중요한 구성을 소개합니다.

---
#### **4.2.1.  Modules and Submodules**

YANG 데이터 모델은 모듈에 정의되어 있습니다. 모듈에는 관련 정의 모음이 포함되어 있습니다.

모듈에는 모듈 헤더 문, "개정" 문, 정의 문이라는 세 가지 유형의 문이 포함되어 있습니다. 모듈 헤더 문은 모듈을 설명하고 모듈 자체에 대한 정보를 제공하고, "개정" 문은 모듈의 기록에 대한 정보를 제공하며, 정의 문은 데이터 모델이 정의된 모듈의 본문입니다.

서버는 동일한 데이터에 대한 다중 보기 또는 서버 데이터의 분리된 하위 섹션에 대한 다중 보기를 허용하는 여러 모듈을 구현할 수 있습니다. 또는 서버는 사용 가능한 모든 데이터를 정의하는 하나의 모듈만 구현할 수도 있습니다.

모듈에는 모듈 설계자의 필요에 따라 하위 모듈로 분리된 정의 부분이 있을 수 있습니다. 외부 보기는 해당 하위 모듈의 존재 여부나 크기에 관계없이 단일 모듈의 보기로 유지됩니다.

"import" 문을 사용하면 모듈이나 하위 모듈이 다른 모듈에 정의된 정의를 참조할 수 있습니다.

"include" 문은 모듈에 속한 각 하위 모듈을 식별하는 데 사용됩니다.

---
#### **4.2.2.  Data Modeling Basics**

YANG은 데이터 모델링을 위한 네 가지 주요 데이터 노드 유형을 정의합니다. 다음 각 하위 섹션의 예에서는 YANG 구문과 해당 XML 인코딩을 보여줍니다. YANG 문의 구문은 섹션 6.3에 정의되어 있습니다.

---
##### **4.2.2.1.  Leaf Nodes**

리프 인스턴스에는 정수나 문자열과 같은 간단한 데이터가 포함됩니다. 특정 유형의 값이 정확히 하나만 있고 하위 노드가 없습니다.

```text
   YANG Example:

     leaf host-name {
       type string;
       description
         "Hostname for this system.";
     }

   XML Encoding Example:

     <host-name>my.example.com</host-name>
```

"leaf" 문은 섹션 7.6에서 다룹니다.

---
##### **4.2.2.2.  Leaf-List Nodes**

리프 목록은 특정 유형의 값 시퀀스를 정의합니다.

```text
   YANG Example:

     leaf-list domain-search {
       type string;
       description
         "List of domain names to search.";
     }

   XML Encoding Example:

     <domain-search>high.example.com</domain-search>
     <domain-search>low.example.com</domain-search>
     <domain-search>everywhere.example.com</domain-search>
```

"leaf-list" 문은 섹션 7.7에서 다룹니다.

---
##### **4.2.2.3.  Container Nodes**

컨테이너는 하위 트리에서 관련 노드를 그룹화하는 데 사용됩니다. 컨테이너에는 하위 노드만 있고 값은 없습니다. 컨테이너에는 모든 유형\(리프, 목록, 컨테이너, 리프 목록, 작업 및 알림\)의 하위 노드가 개수 제한 없이 포함될 수 있습니다.

```text
   YANG Example:

     container system {
       container login {
         leaf message {
           type string;
           description
             "Message given at start of login session.";
         }
       }
     }

   XML Encoding Example:

     <system>
       <login>
         <message>Good morning</message>
       </login>
     </system>
```

"컨테이너" 설명은 섹션 7.5에서 다룹니다.

---
##### **4.2.2.4.  List Nodes**

목록은 목록 항목의 순서를 정의합니다. 각 항목은 컨테이너와 같으며 정의된 키 리프가 있는 경우 해당 키 리프 값으로 고유하게 식별됩니다. 목록은 여러 키 리프를 정의할 수 있으며 모든 유형\(리프, 목록, 컨테이너 등 포함\)의 하위 노드를 원하는 수만큼 포함할 수 있습니다.

```text
   YANG Example:

     list user {
       key "name";
       leaf name {
         type string;
       }
       leaf full-name {
         type string;
       }
       leaf class {
         type string;
       }
     }

   XML Encoding Example:

     <user>
       <name>glocks</name>
       <full-name>Goldie Locks</full-name>
       <class>intruder</class>
     </user>
     <user>
       <name>snowey</name>
       <full-name>Snow White</full-name>
       <class>free-loader</class>
     </user>
     <user>
       <name>rzell</name>
       <full-name>Rapun Zell</full-name>
       <class>tower</class>
     </user>
```

"목록" 문은 섹션 7.8에서 다룹니다.

---
##### **4.2.2.5.  Example Module**

다음 명령문을 결합하여 모듈을 정의합니다.

```text
     // Contents of "example-system.yang"
     module example-system {
       yang-version 1.1;
       namespace "urn:example:system";
       prefix "sys";

       organization "Example Inc.";
       contact "joe@example.com";
       description
         "The module for entities implementing the Example system.";

       revision 2007-06-09 {
         description "Initial revision.";
       }

       container system {
         leaf host-name {
           type string;
           description
             "Hostname for this system.";
         }

         leaf-list domain-search {
           type string;
           description
             "List of domain names to search.";
         }

         container login {
           leaf message {
             type string;
             description
               "Message given at start of login session.";
           }

           list user {
             key "name";
             leaf name {
               type string;
             }
             leaf full-name {
               type string;
             }
             leaf class {
               type string;
             }
           }
         }
       }
     }
```

---
#### **4.2.3.  Configuration and State Data**

YANG은 "config" 문을 기반으로 구성 데이터뿐만 아니라 상태 데이터도 모델링할 수 있습니다. 노드에 "config false" 태그가 지정되면 해당 하위 계층이 상태 데이터로 플래그가 지정됩니다. "config true" 태그가 지정되면 하위 계층 구조가 구성 데이터로 플래그 지정됩니다. 상위 컨테이너, 목록 및 키 리프도 보고되어 상태 데이터에 대한 컨텍스트를 제공합니다.

이 예에서는 각 인터페이스에 대해 구성된 속도와 관찰된 속도라는 두 개의 리프가 정의됩니다.

```text
     list interface {
       key "name";
       config true;

       leaf name {
         type string;
       }
       leaf speed {
         type enumeration {
           enum 10m;
           enum 100m;
           enum auto;
         }
       }
       leaf observed-speed {
         type uint32;
         config false;
       }
     }
```

"config" 문은 섹션 7.21.1에서 다룹니다.

---
#### **4.2.4.  Built-In Types**

YANG에는 많은 프로그래밍 언어와 유사한 내장 유형 세트가 있지만 네트워크 관리의 특별한 요구 사항으로 인해 약간의 차이가 있습니다. 다음 표에는 섹션 9에서 설명한 내장 유형이 요약되어 있습니다.

```text
       +---------------------+-------------------------------------+
       | Name                | Description                         |
       +---------------------+-------------------------------------+
       | binary              | Any binary data                     |
       | bits                | A set of bits or flags              |
       | boolean             | "true" or "false"                   |
       | decimal64           | 64-bit signed decimal number        |
       | empty               | A leaf that does not have any value |
       | enumeration         | One of an enumerated set of strings |
       | identityref         | A reference to an abstract identity |
       | instance-identifier | A reference to a data tree node     |
       | int8                | 8-bit signed integer                |
       | int16               | 16-bit signed integer               |
       | int32               | 32-bit signed integer               |
       | int64               | 64-bit signed integer               |
       | leafref             | A reference to a leaf instance      |
       | string              | A character string                  |
       | uint8               | 8-bit unsigned integer              |
       | uint16              | 16-bit unsigned integer             |
       | uint32              | 32-bit unsigned integer             |
       | uint64              | 64-bit unsigned integer             |
       | union               | Choice of member types              |
       +---------------------+-------------------------------------+
```

"type" 문은 섹션 7.4에서 다룹니다.

---
#### **4.2.5.  Derived Types (typedef)**

YANG은 "typedef" 문을 사용하여 기본 유형에서 파생 유형을 정의할 수 있습니다. 기본 유형은 내장 유형이거나 파생 유형일 수 있으며 파생 유형의 계층 구조를 허용합니다.

파생된 유형은 "type" 문의 인수로 사용될 수 있습니다.

```text
   YANG Example:

     typedef percent {
       type uint8 {
         range "0 .. 100";
       }
     }

     leaf completed {
       type percent;
     }

   XML Encoding Example:

     <completed>20</completed>
```

"typedef" 문은 섹션 7.3에서 다룹니다.

---
#### **4.2.6.  Reusable Node Groups (grouping)**

"grouping" 문을 사용하여 노드 그룹을 재사용 가능한 컬렉션으로 조립할 수 있습니다. 그룹화는 "uses" 문으로 인스턴스화되는 노드 집합을 정의합니다.

```text
   YANG Example:

     grouping target {
       leaf address {
         type inet:ip-address;
         description "Target IP address.";
       }
       leaf port {
         type inet:port-number;
          description "Target port number.";
       }
     }

     container peer {
       container destination {
         uses target;
       }
     }

   XML Encoding Example:

     <peer>
       <destination>
         <address>2001:db8::2</address>
         <port>830</port>
       </destination>
     </peer>
```

그룹화는 사용될 때 구체화되어 특정 명령문을 재정의할 수 있습니다. 이 예에서는 설명이 구체화되었습니다.

```text
     container connection {
       container source {
         uses target {
           refine "address" {
             description "Source IP address.";
           }
           refine "port" {
             description "Source port number.";
           }
         }
       }
       container destination {
         uses target {
           refine "address" {
             description "Destination IP address.";
           }
           refine "port" {
             description "Destination port number.";
           }
         }
       }
     }
```

"그룹화" 설명은 섹션 7.12에서 다룹니다.

---
#### **4.2.7.  Choices**

YANG을 사용하면 데이터 모델이 "choice" 및 "case" 문을 사용하여 호환되지 않는 노드를 고유한 선택 항목으로 분리할 수 있습니다. "choice" 문에는 함께 나타날 수 없는 스키마 노드 집합을 정의하는 "case" 문 집합이 포함되어 있습니다. 각 "케이스"에는 여러 노드가 포함될 수 있지만 각 노드는 "선택" 아래의 하나의 "케이스"에만 나타날 수 있습니다.

선택 및 사례 노드는 스키마 트리에만 표시되고 데이터 트리에는 표시되지 않습니다. 개념적 스키마를 넘어서는 추가 계층 수준은 필요하지 않습니다. 케이스의 존재는 케이스 내에 하나 이상의 노드가 있음으로 표시됩니다.

선택한 케이스 중 하나만 유효할 수 있으므로 한 케이스의 노드가 데이터 트리에 생성되면 다른 모든 케이스의 모든 노드는 암시적으로 삭제됩니다. 서버는 제약 조건 적용을 처리하여 구성에 비호환성이 존재하지 않도록 방지합니다.

```text
   YANG Example:

     container food {
       choice snack {
         case sports-arena {
           leaf pretzel {
             type empty;
           }
           leaf beer {
             type empty;
           }
         }
         case late-night {
           leaf chocolate {
             type enumeration {
               enum dark;
               enum milk;
               enum first-available;
             }
           }
         }
       }
     }

   XML Encoding Example:

     <food>
       <pretzel/>
       <beer/>
     </food>
```

"선택" 진술은 섹션 7.9에서 다룹니다.

---
#### **4.2.8.  Extending Data Models (augment)**

YANG을 사용하면 모듈이 현재 모듈\(및 하위 모듈\)과 외부 모듈을 모두 포함하여 데이터 모델에 추가 노드를 삽입할 수 있습니다. 예를 들어, 이는 공급업체가 상호 운용 가능한 방식으로 표준 데이터 모델에 공급업체별 매개변수를 추가하는 데 유용합니다.

"augment" 문은 새 노드가 삽입되는 데이터 모델 계층 구조의 위치를 ​​정의하고, "when" 문은 새 노드가 유효한 조건을 정의합니다.

서버가 "증가" 문을 포함하는 모듈을 구현할 때 이는 서버의 증강 모듈 구현에 추가 노드가 포함되어 있음을 의미합니다.

```text
   YANG Example:

     augment /system/login/user {
       when "class != 'wheel'";
       leaf uid {
         type uint16 {
           range "1000 .. 30000";
         }
       }
     }
```

이 예에서는 사용자의 "클래스"가 "wheel"이 아닌 경우에만 유효한 "uid" 노드를 정의합니다.

모듈이 다른 모듈을 보강하는 경우 인코딩에 추가되는 XML 요소는 보강 모듈의 네임스페이스에 있습니다. 예를 들어, 위의 확장이 접두사 "other"가 있는 모듈에 있는 경우 XML은 다음과 같습니다.

```text
   XML Encoding Example:

     <user>
       <name>alicew</name>
       <full-name>Alice N. Wonderland</full-name>
       <class>drop-out</class>
       <other:uid>1024</other:uid>
     </user>
```

"증강" 설명은 섹션 7.17에서 다룹니다.

---
#### **4.2.9.  Operation Definitions**

YANG은 작업 정의를 허용합니다. 작업 이름, 입력 매개변수 및 출력 매개변수는 YANG 데이터 정의 문을 사용하여 모델링됩니다. 모듈의 최상위 수준 작업은 "rpc" 문으로 정의됩니다. 작업은 컨테이너 또는 목록 데이터 노드에 연결될 수도 있습니다. 이러한 작업은 "action" 문으로 정의됩니다.

YANG 최상위 수준 작업의 예:

```text
     rpc activate-software-image {
       input {
         leaf image-name {
           type string;
         }
       }
       output {
         leaf status {
           type string;
         }
       }
     }

   NETCONF XML Example:

     <rpc message-id="101"
          xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
       <activate-software-image xmlns="http://example.com/system">
         <image-name>example-fw-2.3</image-name>
       </activate-software-image>
     </rpc>
```

<rpc-응답 메시지-id="101"

- xmlns="urn:ietf:params:xml:ns:netconf:base:1.0"\> <status xmlns="http://example.com/system"\> example-fw-2.3 이미지를 설치하는 중입니다. </status\> </rpc-reply\>

YANG 목록 데이터 노드에 연결된 작업의 예:

```text
     list interface {
       key "name";

       leaf name {
         type string;
       }

       action ping {
         input {
           leaf destination {
             type inet:ip-address;
           }
         }
         output {
           leaf packet-loss {
             type uint8;
           }
         }
       }
     }

   NETCONF XML Example:

     <rpc message-id="102"
          xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
       <action xmlns="urn:ietf:params:xml:ns:yang:1">
         <interface xmlns="http://example.com/system">
           <name>eth1</name>
           <ping>
             <destination>192.0.2.1</destination>
           </ping>
         </interface>
       </action>
     </rpc>

     <rpc-reply message-id="102"
                xmlns="urn:ietf:params:xml:ns:netconf:base:1.0"
                xmlns:sys="http://example.com/system">
       <sys:packet-loss>60</sys:packet-loss>
     </rpc-reply>
```

"rpc" 문은 섹션 7.14에서 다루고, "action" 문은 섹션 7.15에서 다룹니다.

---
#### **4.2.10.  Notification Definitions**

YANG에서는 알림 정의를 허용합니다. YANG 데이터 정의문은 알림 내용을 모델링하는 데 사용됩니다.

```text
   YANG Example:

     notification link-failure {
       description
         "A link failure has been detected.";
       leaf if-name {
         type leafref {
           path "/interface/name";
         }
       }
       leaf if-admin-status {
         type admin-status;
       }
       leaf if-oper-status {
         type oper-status;
       }
     }

   NETCONF XML Example:

     <notification
         xmlns="urn:ietf:params:netconf:capability:notification:1.0">
       <eventTime>2007-09-01T10:00:00Z</eventTime>
       <link-failure xmlns="urn:example:system">
         <if-name>so-1/2/3.0</if-name>
         <if-admin-status>up</if-admin-status>
         <if-oper-status>down</if-oper-status>
       </link-failure>
     </notification>
```

"통지" 설명은 섹션 7.16에서 다룹니다.

---
## **5.  Language Concepts**
---
### **5.1.  Modules and Submodules**

모듈은 YANG 정의의 기본 단위입니다. 모듈은 단일 데이터 모델을 정의합니다. 모듈은 추가 노드를 사용하여 기존 데이터 모델을 확장할 수도 있습니다.

하위 모듈은 모듈에 정의를 제공하는 부분 모듈입니다. 모듈에는 여러 개의 하위 모듈이 포함될 수 있지만 각 하위 모듈은 하나의 모듈에만 속할 수 있습니다.

YANG 모듈 및 하위 모듈 개발자는 표준 또는 기타 엔터프라이즈 모듈과 충돌할 가능성이 낮은 모듈 이름을 선택하는 것이 좋습니다\(예: 모듈 이름의 접두사로 엔터프라이즈 또는 조직 이름을 사용\). 서버 내에서 모든 모듈 이름은 고유해야 합니다.\(SHOULD, MUST\)

모듈은 "include" 문을 사용하여 모든 하위 모듈을 나열합니다. 모듈 또는 해당 모듈에 속하는 하위 모듈은 모듈과 모듈에 포함된 모든 하위 모듈의 정의를 참조할 수 있습니다.

모듈이나 하위 모듈은 "import" 문을 사용하여 외부 모듈을 참조합니다. 모듈 또는 하위 모듈의 문은 "import" 문에 지정된 접두사를 사용하여 외부 모듈의 정의를 참조할 수 있습니다.

YANG 버전 1과의 이전 버전과의 호환성을 위해 하위 모듈은 "include" 문을 사용하여 해당 모듈 내의 다른 하위 모듈을 참조할 수 있지만 YANG 버전 1.1에서는 이것이 필요하지 않습니다. 하위 모듈은 자신이 속한 모듈과 해당 모듈에 포함된 모든 하위 모듈의 모든 정의를 참조할 수 있습니다. 하위 모듈은 해당 모듈에 포함된 개정판과 다른 하위 모듈의 다른 개정판을 포함해서는 안 됩니다.\(MAY, MUST NOT\)

모듈이나 하위 모듈은 다른 모듈의 하위 모듈을 포함해서는 안 되며, 하위 모듈은 자체 모듈을 가져와서는 안 됩니다.\(MUST NOT\)

"import" 및 "include" 문은 다른 모듈에서 정의를 사용할 수 있도록 만드는 데 사용됩니다.

o 모듈이나 하위 모듈이 외부 모듈의 정의를 참조하려면 외부 모듈을 가져와야 합니다.\(MUST\)

o 모듈은 모든 하위 모듈을 포함해야 합니다.\(MUST\)

o 모듈 또는 해당 모듈에 속하는 하위 모듈은 모듈의 정의와 모듈에 포함된 모든 하위 모듈을 참조할 수 있습니다.\(MAY\)

수입품의 순환 체인이 있어서는 안 됩니다. 예를 들어 모듈 "a"가 모듈 "b"를 가져오는 경우 "b"는 "a"를 가져올 수 없습니다.\(MUST NOT\)

외부 모듈의 정의가 참조될 때 로컬로 정의된 접두사를 반드시 사용해야 하며 그 뒤에 콜론\(":"\)과 외부 식별자가 옵니다. 로컬 모듈의 정의에 대한 참조는 접두사 표기법을 사용할 수 있습니다. 내장 데이터 유형은 어떤 모듈에도 속하지 않고 접두사가 없기 때문에 내장 데이터 유형\(예: int32\)에 대한 참조는 접두사 표기법을 사용할 수 없습니다. 정의에 대한 참조 구문은 섹션 14의 "identifier-ref" 규칙에 의해 공식적으로 정의됩니다.\(MUST, MAY\)

---
#### **5.1.1.  Import and Include by Revision**

게시된 모듈은 시간이 지남에 따라 독립적으로 발전합니다. 이러한 발전을 허용하기 위해 특정 개정판을 사용하여 모듈을 가져올 수 있습니다. 처음에 모듈은 모듈이 작성될 때 현재인 다른 모듈의 개정판을 가져옵니다. 가져온 모듈의 향후 개정판이 게시되면 가져오기 모듈은 영향을 받지 않으며 해당 내용도 변경되지 않습니다. 모듈 작성자가 가져온 모듈의 가장 최근 게시된 개정판으로 이동할 준비가 되면 업데이트된 "import" 문을 사용하여 모듈이 다시 게시됩니다. 새 개정판을 다시 게시함으로써 작성자는 가져온 모듈의 변경 사항을 승인했음을 명시적으로 나타냅니다.

하위 모듈의 경우 문제는 관련이 있지만 더 간단합니다. 모듈 또는 하위 모듈을 포함하는 하위 모듈은 포함된 하위 모듈의 개정판을 지정할 수 있습니다. 하위 모듈이 변경되면 이를 개정별로 포함하는 모든 모듈 또는 하위 모듈을 업데이트하여 새 개정을 참조해야 합니다.

예를 들어 모듈 "b"는 모듈 "a"를 가져옵니다.

```text
     module a {
       yang-version 1.1;
       namespace "urn:example:a";
       prefix "a";

       revision 2008-01-01 { ... }
       grouping a {
         leaf eh { .... }
       }
     }

     module b {
       yang-version 1.1;
       namespace "urn:example:b";
       prefix "b";

       import a {
         prefix "p";
         revision-date 2008-01-01;
       }

       container bee {
         uses p:a;
       }
     }
```

"a"의 저자가 새로운 개정판을 출판하면 "b"의 저자가 변경 사항을 받아들이지 못할 수도 있습니다. 새 개정판이 허용되는 경우 "b" 작성자는 "import" 문에서 업데이트된 개정판을 사용하여 다시 출판할 수 있습니다.

특정 개정으로 모듈을 가져오지 않으면 어떤 개정이 사용되는지 정의되지 않습니다.

---
#### **5.1.2.  Module Hierarchies**

YANG을 사용하면 데이터에 둘 이상의 최상위 노드가 있을 수 있는 여러 계층의 데이터 모델링이 가능합니다. 모듈의 각 최상위 데이터 노드는 별도의 계층 구조를 정의합니다. 여러 개의 최상위 노드가 있는 모델이 때로는 편리하며 YANG에서 지원됩니다.

---
##### **5.1.2.1.  NETCONF XML Encoding**

NETCONF는 모든 XML 콘텐츠를 <config\> 및 <data\> 요소의 페이로드로 전달할 수 있습니다. YANG 모듈의 최상위 노드는 순서에 관계없이 이러한 요소 내에서 하위 요소로 인코딩됩니다. 이 캡슐화는 해당 NETCONF 메시지가 항상 올바른 형식의 XML 문서임을 보장합니다.

예를 들면 다음과 같습니다.

```text
     module example-config {
       yang-version 1.1;
       namespace "urn:example:config";
       prefix "co";

       container system { ... }
       container routing { ... }
     }
```

NETCONF에서 다음과 같이 인코딩될 수 있습니다.

```text
     <rpc message-id="101"
          xmlns="urn:ietf:params:xml:ns:netconf:base:1.0"
          xmlns:nc="urn:ietf:params:xml:ns:netconf:base:1.0">
       <edit-config>
         <target>
           <running/>
         </target>
         <config>
           <system xmlns="urn:example:config">
             <!-- system data here -->
           </system>
           <routing xmlns="urn:example:config">
             <!-- routing data here -->
           </routing>
         </config>
       </edit-config>
     </rpc>
```

---
### **5.2.  File Layout**

YANG 모듈과 하위 모듈은 일반적으로 파일당 하나의 "모듈" 또는 "하위 모듈" 문으로 저장됩니다. 파일 이름은 다음 형식이어야 합니다.\(SHOULD\)

```text
     module-or-submodule-name ['@' revision-date] ( '.yang' / '.yin' )
```

"module-or-submodule-name"은 모듈이나 하위 모듈의 이름이고, 선택 사항인 "revision-date"는 "revision" 문\(섹션 7.1.9\)에 정의된 대로 모듈이나 하위 모듈의 최신 개정판입니다. .

파일 확장자 ".yang"은 파일 내용이 YANG 구문\(섹션 6\)으로 작성되었음을 나타내고, ".yin"은 파일 내용이 YIN 구문\(섹션 13\)으로 작성되었음을 나타냅니다.

YANG 파서는 이 규칙을 통해 가져온 모듈과 포함된 하위 모듈을 찾을 수 있습니다.

---
### **5.3.  XML Namespaces**

모든 YANG 정의는 모듈 내에서 지정됩니다. 각 모듈은 전역적으로 고유한 URI \[RFC3986\]인 고유한 XML 네임스페이스 \[XML-NAMES\]에 바인딩됩니다. NETCONF 클라이언트 또는 서버는 데이터의 XML 인코딩 중에 네임스페이스를 사용합니다.

RFC 스트림\[RFC4844\]에 게시된 모듈의 XML 네임스페이스는 IANA에 의해 할당되어야 합니다. \[RFC6020\]의 섹션 14를 참조하세요.\(MUST\)

개인 모듈의 XML 네임스페이스는 중앙 레지스트리 없이 모듈을 소유한 조직에 의해 할당됩니다. 네임스페이스 URI는 표준 또는 기타 엔터프라이즈 네임스페이스와 충돌할 수 없도록 선택해야 합니다\(예: 네임스페이스에서 엔터프라이즈 또는 조직 이름을 사용\).\(MUST\)

"네임스페이스" 문은 섹션 7.1.3에서 다룹니다.

---
#### **5.3.1.  YANG XML Namespace**

YANG은 NETCONF <edit-config\> 작업, <error-info\> 콘텐츠 및 <action\> 요소에 대한 XML 네임스페이스를 정의합니다. 이 네임스페이스의 이름은 "urn:ietf:params:xml:ns:yang:1"입니다.

---
### **5.4.  Resolving Grouping, Type, and Identity Names**

그룹화, 유형 및 ID 이름은 사용되는 컨텍스트가 아닌 정의된 컨텍스트에서 확인됩니다. 그룹화, typedef 및 ID 사용자는 원래 정의에 의해 만들어진 모든 참조를 충족하기 위해 모듈을 가져오거나 하위 모듈을 포함할 필요가 없습니다. 이는 기존 프로그래밍 언어의 정적 범위 지정처럼 동작합니다.

예를 들어, 모듈이 유형이 참조되는 그룹화를 정의하는 경우 그룹화가 두 번째 모듈에서 사용되면 유형은 두 번째 모듈이 아닌 원래 모듈의 컨텍스트에서 확인됩니다. 두 모듈 모두 유형을 정의하는 경우 모호성은 없습니다.

---
### **5.5.  Nested Typedefs and Groupings**

Typedef 및 그룹화는 많은 YANG 문 아래에 중첩되어 나타날 수 있으므로 이들이 나타나는 문 계층 구조에 따라 어휘 범위를 지정할 수 있습니다. 이를 통해 유형과 그룹화를 계층 구조의 최상위 수준에 배치하는 대신 사용되는 위치 근처에서 정의할 수 있습니다. 근접할수록 가독성이 높아집니다.

또한 범위 지정을 사용하면 서로 다른 하위 모듈에 있는 유형 간의 이름 지정 충돌에 대한 걱정 없이 유형을 정의할 수 있습니다. 대형 모듈 내에서 이름 충돌을 방지하도록 설계된 선행 문자열을 추가하지 않고도 유형 이름을 지정할 수 있습니다.

마지막으로, 범위 지정을 통해 모듈 작성자는 유형 및 그룹화를 해당 모듈 또는 하위 모듈에 비공개로 유지하여 재사용을 방지할 수 있습니다. 최상위 유형 및 그룹화\(즉, "모듈" 또는 "하위 모듈" 명령문의 하위 명령문으로 나타나는 것\)만 모듈이나 하위 모듈 외부에서 사용할 수 있으므로 개발자는 모듈의 어떤 부분이 모듈에 표시되는지 더 잘 제어할 수 있습니다. 내부 정보를 숨길 필요성을 지원하고 외부 세계와 공유되는 정보와 비공개로 유지되는 정보 사이의 경계를 유지합니다.

범위 정의는 더 높은 범위의 섀도우 정의를 적용해서는 안 됩니다. 명령문 계층의 상위 레벨에 일치하는 식별자가 있는 정의가 있는 경우 유형 또는 그룹화를 정의할 수 없습니다.\(MUST NOT\)

접두사가 없는 유형 또는 그룹화에 대한 참조 또는 현재 모듈의 접두사를 사용하는 참조는 각 조상 명령문의 바로 하위 명령문 중에서 일치하는 "typedef" 또는 "grouping" 명령문을 찾아서 해결됩니다.

---
### **5.6.  Conformance**

모델 준수는 서버가 모델을 얼마나 정확하게 따르는지를 측정하는 것입니다. 일반적으로 서버는 모델을 충실하게 구현하는 역할을 담당하므로 애플리케이션이 모델을 구현하는 서버를 동일하게 처리할 수 있습니다. 모델과의 편차는 모델의 유용성을 감소시키고 이를 사용하는 애플리케이션의 취약성을 증가시킬 수 있습니다.

YANG 모델러는 적합성을 위한 세 가지 메커니즘을 가지고 있습니다.

o 모델의 기본 동작

o 모델의 일부인 선택적 기능

o 모델과의 편차

우리는 이들 각각을 순서대로 고려할 것입니다.

---
#### **5.6.1.  Basic Behavior**

이 모델은 YANG 기반 클라이언트와 서버 간의 계약을 정의합니다. 이 계약을 통해 양 당사자는 상대방이 모델링된 데이터 뒤에 있는 구문과 의미를 알고 있다는 믿음을 가질 수 있습니다. YANG의 강점은 이번 계약의 강점에 있습니다.

---
#### **5.6.2.  Optional Features**

많은 모델에서 모델러는 모델 섹션을 조건부로 허용합니다. 서버는 모델의 이러한 조건부 부분이 특정 서버에 대해 지원되는지 또는 유효한지 여부를 제어합니다.

예를 들어, syslog 데이터 모델은 로그를 로컬에 저장하는 기능을 포함하도록 선택할 수 있지만 모델러는 이것이 서버에 로컬 저장소가 있는 경우에만 가능하다는 것을 깨닫게 됩니다. 로컬 저장소가 없는 경우 애플리케이션은 서버에 로그를 저장하라고 지시해서는 안 됩니다.

YANG은 "기능"이라는 구성을 사용하여 이 조건부 메커니즘을 지원합니다. 기능은 모델러에게 서버에 의해 제어되는 방식으로 모듈의 일부를 조건부로 만드는 메커니즘을 제공합니다. 모델은 모든 서버에 보편적으로 존재하지 않는 구성을 표현할 수 있습니다. 이러한 기능은 모델 정의에 포함되어 일관된 보기를 허용하고 애플리케이션이 지원되는 기능을 학습하고 해당 동작을 서버에 맞게 조정할 수 있도록 합니다.

모듈은 간단한 문자열로 식별되는 기능을 원하는 수만큼 선언할 수 있으며 해당 기능을 기반으로 모듈의 일부를 선택 사항으로 만들 수 있습니다. 서버가 기능을 지원하는 경우 모듈의 해당 부분이 해당 서버에 유효합니다. 서버가 해당 기능을 지원하지 않으면 모듈의 해당 부분은 유효하지 않으며 애플리케이션은 그에 따라 작동해야 합니다.

기능은 "feature" 문을 사용하여 정의됩니다. 기능에 대한 조건부 모듈의 정의는 "if-feature" 문으로 표시됩니다.

자세한 내용은 섹션 7.20.1에서 확인할 수 있습니다.

---
#### **5.6.3.  Deviations**

이상적인 세계에서는 모든 서버가 정의된 대로 정확하게 모델을 구현해야 하며 모델과의 차이는 허용되지 않습니다. 그러나 현실 세계에서는 서버가 작성된 대로 모델을 구현할 수 없거나 구현하도록 설계되지 않는 경우가 많습니다. 이러한 서버 편차를 처리하기 위한 YANG 기반 자동화의 경우 서버가 애플리케이션에 이러한 편차의 세부 사항을 알리는 메커니즘이 있어야 합니다.

예를 들어, BGP 모듈은 원하는 수의 BGP 피어를 허용할 수 있지만 특정 서버는 16개의 BGP 피어만 지원할 수 있습니다. 17번째 피어를 구성하는 모든 애플리케이션에는 오류가 발생합니다. 오류가 발생하면 애플리케이션에 다른 피어를 추가할 수 없다는 사실을 알리는 데 충분할 수 있지만, 애플리케이션이 이 제한 사항을 사전에 알고 사용자가 성공할 수 없는 경로를 시작하지 못하게 할 수 있다면 훨씬 더 좋을 것입니다.

서버 편차는 스키마 트리에서 노드를 식별하는 문자열을 인수로 사용하는 "편차" 문을 사용하여 선언됩니다. 명령문의 내용은 서버 구현이 모듈에 정의된 계약에서 벗어나는 방식을 자세히 설명합니다.

자세한 내용은 섹션 7.20.3에서 확인할 수 있습니다.

---
#### **5.6.4.  Announcing Conformance Information in NETCONF**

이 문서는 적합성 정보를 발표하기 위한 다음 메커니즘을 정의합니다. 다른 메커니즘은 향후 사양에 따라 정의될 수 있습니다.

NETCONF 서버는 \[RFC7895\]에 정의된 YANG 모듈 "ietf-yang-library"를 구현하고 "/modules-state/module" 목록에 구현된 모든 모듈을 나열하여 자신이 구현하는 모듈\(섹션 5.6.5 참조\)을 발표해야 합니다.\(MUST\)

또한 서버는 <hello\> 메시지에서 다음 기능을 광고해야 합니다\(줄 바꿈 및 공백은 형식 지정 목적으로만 사용됨\).\(MUST\)

```text
     urn:ietf:params:netconf:capability:yang-library:1.0?
       revision=<date>&module-set-id=<id>
```

"revision" 매개변수는 서버가 구현한 "ietf-yang-library" 모듈의 개정일과 동일한 값을 갖는다. 이 매개변수는 반드시 존재해야 합니다.\(MUST\)

"module-set-id" 매개변수는 "ietf-yang-library"의 리프 "/modules-state/module-set-id"와 동일한 값을 갖습니다. 이 매개변수는 반드시 존재해야 합니다.\(MUST\)

이 메커니즘을 사용하면 클라이언트는 서버에 대해 지원되는 모듈을 캐시하고 <hello\> 메시지의 "module-set-id" 값이 변경되는 경우에만 캐시를 업데이트할 수 있습니다.

---
#### **5.6.5.  Implementing a Module**

서버는 모듈의 데이터 노드, RPC, 작업, 알림 및 편차를 구현하는 경우 모듈을 구현합니다.

서버는 하나 이상의 모듈 개정판을 구현해서는 안 됩니다.\(MUST NOT\)

서버가 모듈 B를 가져오는 모듈 A를 구현하고 A가 서버가 지원하는 "증강" 또는 "경로" 문에서 B의 노드를 사용하는 경우 서버는 이러한 노드가 정의된 모듈 B의 개정판을 구현해야 합니다. . 이는 모듈 B를 개정판으로 가져왔는지 여부와 관계가 없습니다.\(MUST\)

서버가 모듈 C의 개정 날짜를 지정하지 않고 모듈 C를 가져오는 모듈 A를 구현하고 서버가 C를 구현하지 않는 경우\(예: C가 일부 typedef만 정의하는 경우\) 서버는 "/modules- state/module" 목록을 "ietf-yang-library" \[RFC7895\]에서 선택하고 이 모듈에 대해 리프 "conformance-type"을 "import"로 설정해야 합니다.\(MUST\)

서버가 "ietf-yang-library"의 "/modules-state/module" 목록에 모듈 C를 나열하고 모듈 C의 개정 날짜를 지정하지 않고 C를 가져오는 다른 모듈 M이 나열되어 있는 경우 서버는 다음을 사용해야 합니다. 모듈 Ms에 대해 나열된 C의 최신 개정판의 정의입니다.\(MUST\)

이러한 규칙이 있는 이유는 클라이언트가 서버에 구현된 모든 리프 및 리프 목록의 특정 데이터 모델 구조와 유형을 알 수 있어야 하기 때문입니다.

예를 들어 다음 모듈을 사용하면 다음과 같습니다.

```text
     module a {
       yang-version 1.1;
       namespace "urn:example:a";
       prefix "a";

       import b {
         revision-date 2015-01-01;
       }
       import c;

       revision 2015-01-01;

       feature foo;

       augment "/b:x" {
         if-feature foo;

         leaf y {
           type b:myenum;
         }
       }

       container a {
         leaf x {
           type c:bar;
         }
       }
     }

     module b {
       yang-version 1.1;
       namespace "urn:example:b";
       prefix "b";

       revision 2015-01-01;

       typedef myenum {
         type enumeration {
           enum zero;
         }
       }

       container x {
       }
     }

     module b {
       yang-version 1.1;
       namespace "urn:example:b";
       prefix "b";

       revision 2015-04-04;
       revision 2015-01-01;

       typedef myenum {
         type enumeration {
           enum zero; // added in 2015-01-01
           enum one;  // added in 2015-04-04
         }
       }

       container x {  // added in 2015-01-01
         container y; // added in 2015-04-04
       }
     }

     module c {
       yang-version 1.1;
       namespace "urn:example:c";
       prefix "c";

       revision 2015-02-02;

       typedef bar {
         ...
       }
     }

     module c {
       yang-version 1.1;
       namespace "urn:example:c";
       prefix "c";

       revision 2015-03-03;
       revision 2015-02-02;

       typedef bar {
         ...
       }
     }
```

모듈 "a"의 개정판 "2015-01-01"을 구현하고 "foo" 기능을 지원하는 서버는 모듈 "b"의 개정판 "2015-01-01" 또는 "2015-04-04"를 구현할 수 있습니다. "b"는 개정판으로 가져왔으므로 서버가 구현하는 "b"의 개정판에 관계없이 리프 "/b:x/a:y"의 유형은 동일합니다.

모듈 "a"를 구현하지만 "foo" 기능을 지원하지 않는 서버는 모듈 "b"를 구현할 필요가 없습니다.

모듈 "a"의 개정판 "2015-01-01"을 구현하는 서버는 모듈 "c"의 개정판을 선택하여 "ietf-yang-library"의 "/modules-state/module" 목록에 나열합니다.

다음 XML 인코딩 예는 모듈 "a"를 구현하는 서버의 "/modules-state/module" 목록에 대한 유효한 데이터를 보여줍니다.

```text
     <modules-state
         xmlns="urn:ietf:params:xml:ns:yang:ietf-yang-library">
       <module-set-id>ee1ecb017370cafd</module-set-id>
       <module>
         <name>a</name>
         <revision>2015-01-01</revision>
         <namespace>urn:example:a</namespace>
         <feature>foo</feature>
         <conformance-type>implement</conformance-type>
       </module>
       <module>
         <name>b</name>
         <revision>2015-04-04</revision>
         <namespace>urn:example:b</namespace>
         <conformance-type>implement</conformance-type>
       </module>

       <module>
         <name>c</name>
         <revision>2015-02-02</revision>
         <namespace>urn:example:c</namespace>
         <conformance-type>import</conformance-type>
       </module>
     </modules-state>
```

---
### **5.7.  Datastore Modification**

데이터 모델을 사용하면 서버가 네트워크 관리 프로토콜 메시지를 통해 명시적으로 지시되지 않은 방식으로 구성 데이터 저장소를 변경할 수 있습니다. 예를 들어, 데이터 모델은 클라이언트가 값을 제공하지 않을 때 시스템 생성 값이 할당되는 리프를 정의할 수 있습니다. 이러한 변경이 허용되는 상황을 지정하는 공식 메커니즘은 이 사양의 범위를 벗어납니다.

---
## **6.  YANG Syntax**

YANG 구문은 SMIng \[RFC3780\] 및 C 및 C++와 같은 프로그래밍 언어의 구문과 유사합니다. 이 C와 유사한 구문은 가독성을 위해 특별히 선택되었습니다. 왜냐하면 YANG은 모듈 작성자 및 YANG 도구 체인 개발자보다 모델 독자의 시간과 노력을 더 중요하게 생각하기 때문입니다. 이 섹션에서는 YANG 구문을 소개합니다.

YANG 모듈의 유효한 문자는 유니코드 및 ISO/IEC 10646 \[ISO.10646\] 문자이며 탭, 캐리지 리턴 및 줄 바꿈을 포함하지만 다른 C0 제어 문자, 대리 블록 및 비문자는 제외됩니다. 문자 구문은 섹션 14의 "yang-char" 규칙에 의해 공식적으로 정의됩니다.

YANG 모듈과 하위 모듈은 UTF-8 \[RFC3629\] 문자 인코딩을 사용하여 파일에 저장됩니다.

YANG 모듈의 줄은 캐리지 리턴-줄 바꿈 조합 또는 줄 바꿈 단독으로 끝납니다. 줄바꿈이 뒤따르지 않는 캐리지 리턴은 인용된 문자열 안에만 나타날 수 있습니다\(6.1.3절\). 인용된 문자열 안에 나타나는 캐리지 리턴 및 줄 바꿈은 수정 없이 문자열 값의 일부가 됩니다. 여러 줄로 묶인 문자열의 값에는 YANG 모듈의 줄과 동일한 형태의 줄 끝이 포함됩니다.

---
### **6.1.  Lexical Tokenization**

YANG 모듈은 일련의 토큰으로 구문 분석됩니다. 이 섹션에서는 입력 스트림에서 토큰을 인식하는 규칙을 자세히 설명합니다. YANG 토큰화 규칙은 간단하면서도 강력합니다. 단순성은 파서를 구현하기 쉽게 유지해야 하는 필요성에 의해 주도되는 반면, 강력한 모델러는 모델을 읽을 수 있는 형식으로 표현해야 한다는 사실에 의해 주도됩니다.

---
#### **6.1.1.  Comments**

주석은 C++ 스타일입니다. 한 줄 주석은 "//"로 시작하고 줄 끝에서 끝납니다. 블록 주석은 "/\*"로 시작하고 가장 가까운 "\*/"로 끝납니다.

인용된 문자열\(섹션 6.1.3\) 내에서 이러한 문자 쌍은 주석의 시작이나 끝으로 해석되지 않습니다.

---
#### **6.1.2.  Tokens**

YANG의 토큰은 키워드, 문자열, 세미콜론\(";"\) 또는 중괄호\("{" 또는 "}"\)입니다. 문자열은 인용되거나 인용되지 않을 수 있습니다. 키워드는 이 문서에 정의된 YANG 키워드 중 하나이거나 접두사 식별자, 콜론\(":"\), 언어 확장 키워드 중 하나입니다. 키워드는 대소문자를 구분합니다. 식별자의 공식적인 정의는 섹션 6.2를 참조하세요.

---
#### **6.1.3.  Quoting**

따옴표가 없는 문자열은 공백, 탭, 캐리지 리턴 또는 줄 바꿈 문자, 작은따옴표 또는 큰따옴표 문자, 세미콜론\(";"\), 중괄호\("{" 또는 "}"\)를 포함하지 않는 일련의 문자입니다. , 또는 주석 시퀀스\("//", "/\*" 또는 "\*/"\).

모든 키워드는 법적으로 따옴표가 없는 문자열로 표시될 수 있습니다.

따옴표가 없는 문자열 내에서는 모든 문자가 보존됩니다. 이는 따옴표가 없는 문자열에서 백슬래시 문자가 특별한 의미를 갖지 않음을 의미합니다.

큰따옴표로 묶인 문자열에 YANG 파일의 레이아웃에 따라 텍스트를 들여쓰는 데 사용되는 공백 또는 탭 문자가 뒤에 오는 줄바꿈이 포함된 경우 이 선행 공백은 문자열에서 시작 열까지 제거됩니다. 큰따옴표 문자 또는 공백이 아닌 첫 번째 문자 중 먼저 나타나는 문자. 제거를 위해 검사해야 하는 후속 라인의 모든 탭 문자는 먼저 8개의 공백 문자로 변환됩니다.

큰따옴표로 묶인 문자열의 줄 바꿈 앞에 공백이나 탭 문자가 포함되어 있으면 이 후행 공백이 문자열에서 제거됩니다.

작은 따옴표로 묶인 문자열\(' '로 묶음\)은 따옴표 안의 각 문자를 유지합니다. 앞에 백슬래시가 있어도 작은따옴표로 묶인 문자열에는 작은따옴표 문자가 나타날 수 없습니다.

큰따옴표로 묶인 문자열\(" "로 묶임\) 내에서 백슬래시 문자는 백슬래시 바로 뒤에 오는 문자에 따라 특수 문자를 나타냅니다.

```text
    \n      newline
    \t      a tab character
    \"      a double quote
    \\      a single backslash
```

백슬래시 뒤에는 다른 문자가 와서는 안 됩니다.\(MUST NOT\)

따옴표 붙은 문자열 뒤에 더하기 문자\("+"\)가 오고 또 다른 따옴표 붙은 문자열이 오면 두 문자열이 하나의 문자열로 연결되어 여러 연결을 통해 하나의 문자열을 만들 수 있습니다. 인용된 문자열과 더하기 문자 사이에는 공백, 줄 바꿈 및 주석이 허용됩니다.

큰따옴표로 묶인 문자열에서는 백슬래시로 이스케이프된 문자를 대체하기 전에 공백 자르기가 수행됩니다. 연결은 마지막 단계로 수행됩니다.

---
##### **6.1.3.1.  Quoting Examples**

다음 문자열은 동일합니다.

```text
     hello
     "hello"
     'hello'
     "hel" + "lo"
     'hel' + "lo"
```

다음 예에서는 몇 가지 특수 문자열을 보여줍니다.

"\"" - 큰따옴표가 포함된 문자열 '"' - 큰따옴표가 포함된 문자열 "\n" - 개행 문자 '\n'이 포함된 문자열 - 백슬래시 뒤에 문자 n이 포함된 문자열

다음 예에서는 일부 잘못된 문자열을 보여줍니다.

'''' - 작은따옴표로 묶인 문자열에는 작은따옴표를 포함할 수 없습니다. """ - 큰따옴표로 묶인 문자열에서는 큰따옴표를 이스케이프해야 합니다.

다음 문자열은 동일합니다.

```text
         "first line
            second line"

     "first line\n" + "  second line"
```

---
### **6.2.  Identifiers**

식별자는 이름으로 다양한 종류의 YANG 항목을 식별하는 데 사용됩니다. 각 식별자는 대문자나 소문자 ASCII 문자 또는 밑줄 문자로 시작하고 그 뒤에 0개 이상의 ASCII 문자, 숫자, 밑줄 문자, 하이픈 및 점이 옵니다. 구현은 최대 64자 길이의 식별자를 지원해야 하며 더 긴 식별자를 지원할 수 있습니다\(MAY\). 식별자는 대소문자를 구분합니다. 식별자 구문은 섹션 14의 "식별자" 규칙에 의해 공식적으로 정의됩니다. 식별자는 인용되거나 인용되지 않은 문자열로 지정될 수 있습니다.\(MUST\)

---
#### **6.2.1.  Identifiers and Their Namespaces**

각 식별자는 정의되는 YANG 항목의 유형에 따라 달라지는 네임스페이스에서 유효합니다. 네임스페이스에 정의된 모든 식별자는 고유해야 합니다.\(MUST\)

o 모든 모듈 및 하위 모듈 이름은 동일한 전역 모듈 식별자 네임스페이스를 공유합니다.

o 모듈과 해당 하위 모듈에 정의된 모든 확장 이름은 동일한 확장 식별자 네임스페이스를 공유합니다.

o 모듈과 해당 하위 모듈에 정의된 모든 기능 이름은 동일한 기능 식별자 네임스페이스를 공유합니다.

o 모듈과 해당 하위 모듈에 정의된 모든 ID 이름은 동일한 ID 식별자 네임스페이스를 공유합니다.

o 상위 노드 내에서 또는 모듈이나 하위 모듈의 최상위 수준에서 정의된 모든 파생 유형 이름은 동일한 유형 식별자 네임스페이스를 공유합니다. 이 네임스페이스는 상위 노드 또는 모듈의 모든 하위 노드로 범위가 지정됩니다. 이는 모든 하위 노드가 해당 typedef를 사용할 수 있으며 동일한 이름을 가진 typedef를 정의해서는 안 된다는 것을 의미합니다.\(MUST NOT\)

o 상위 노드 내에서 또는 모듈이나 하위 모듈의 최상위 수준에 정의된 모든 그룹화 이름은 동일한 그룹화 식별자 네임스페이스를 공유합니다. 이 네임스페이스는 상위 노드 또는 모듈의 모든 하위 노드로 범위가 지정됩니다. 이는 모든 하위 노드가 해당 그룹을 사용할 수 있으며 동일한 이름을 가진 그룹을 정의해서는 안 된다는 것을 의미합니다.\(MUST NOT\)

o 상위 노드 내에서 또는 모듈이나 하위 모듈의 최상위 수준에서 \(직접 또는 "uses" 문을 통해\) 정의된 모든 리프, 리프 목록, 목록, 컨테이너, 선택 사항, rpcs, 작업, 알림, anydatas 및 anyxml 동일한 식별자 네임스페이스를 공유합니다. 상위 노드가 케이스 노드가 아닌 한 이 네임스페이스는 상위 노드 또는 모듈로 범위가 지정됩니다. 이 경우 네임스페이스는 케이스 또는 선택 노드가 아닌 가장 가까운 상위 노드로 범위가 지정됩니다.

o 선택 항목 내의 모든 케이스는 동일한 케이스 식별자를 공유합니다.

- 네임스페이스. 이 네임스페이스의 범위는 상위 선택 노드로 지정됩니다.

YANG에서는 전방 참조가 허용됩니다.

---
### **6.3.  Statements**

YANG 모듈에는 일련의 명령문이 포함되어 있습니다. 각 명령문은 키워드로 시작하고 그 뒤에 0개 또는 1개의 인수가 오고 그 뒤에는 세미콜론\(";"\) 또는 중괄호\("{ }"\)로 묶인 하위 명령문 블록이 옵니다.

```text
     statement = keyword [argument] (";" / "{" *statement "}")
```

인수는 섹션 6.1.2에 정의된 대로 문자열입니다.

---
#### **6.3.1.  Language Extensions**

모듈은 "extension" 키워드를 사용하여 YANG 확장을 도입할 수 있습니다\(섹션 7.19 참조\). 확장은 "import" 문을 사용하여 다른 모듈에서 가져올 수 있습니다\(섹션 7.1.5 참조\). 가져온 확장을 사용하는 경우 확장 모듈을 가져온 접두사를 사용하여 확장 키워드를 정규화해야 합니다. 확장이 정의된 모듈에서 사용되는 경우 확장의 키워드는 이 모듈의 접두사로 정규화되어야 합니다.\(MUST, MUST\)

확장 처리는 특정 YANG 파서 또는 해당 확장이 포함된 도구 세트에 대해 해당 확장에 대한 지원이 요구되는지 여부에 따라 달라집니다. YANG 모듈에 알 수 없는 명령문\(섹션 14 참조\)으로 나타나는 지원되지 않는 확장은 전체적으로 무시될 수 있습니다. 지원되는 모든 확장은 해당 확장을 관리하는 사양에 따라 처리되어야 합니다.\(MAY, MUST\)

확장을 사용하는 모듈이 확장을 지원하지 않는 응용 프로그램에도 의미가 있도록 확장을 정의할 때는 주의해야 합니다.

---
### **6.4.  XPath Evaluations**

YANG은 많은 노드 간 참조 및 종속성을 지정하기 위한 표기법으로 XPath\(XML Path Language\) 1.0 \[XPATH\]를 사용합니다. XPath 인터프리터를 구현하기 위해 구현이 필요하지는 않지만 데이터 모델에 인코딩된 요구 사항이 적용되도록 해야 합니다. 시행 방식은 시행 결정입니다. XPath 표현식은 구문적으로 정확해야 하며 사용된 모든 접두사는 XPath 컨텍스트에 있어야 합니다\(섹션 6.4.1 참조\). 구현에서는 XPath 표현식을 직접 사용하는 대신 직접 구현하도록 선택할 수 있습니다.\(MUST, MUST\)

XPath 표현식에 사용되는 데이터 모델은 XPath 1.0 \[XPATH\]에서 사용되는 것과 동일하며, XSLT 1.0에서 사용되는 루트 노드 하위에 대한 확장이 동일합니다\(\[XSLT\]의 섹션 3.1 참조\). 특히 이는 루트 노드가 자식으로 요소 노드를 얼마든지 가질 수 있음을 의미합니다.

데이터 트리에는 문서 순서 개념이 없습니다. 구현에서는 일부 문서 순서를 선택해야 하지만 이를 수행하는 방법은 구현 결정입니다. 이는 YANG 모듈의 XPath 표현식이 특정 문서 순서에 의존해서는 안 된다는 것을 의미합니다.\(SHOULD NOT\)

XPath 1.0의 숫자는 IEEE 754 \[IEEE754-2008\] 배정밀도 부동 소수점 값입니다. \[XPATH\]의 섹션 3.5를 참조하세요. 이는 int64, uint64 및decimal64 유형\(섹션 9.2 및 9.3 참조\)의 일부 값을 XPath 표현식으로 정확하게 표현할 수 없음을 의미합니다. 따라서 XPath 표현식에서 64비트 숫자 값이 있는 노드를 사용할 때는 적절한 주의를 기울여야 합니다. 특히, 동등성을 포함하는 수치 비교는 예상치 못한 결과를 낳을 수 있습니다.

예를 들어 다음 정의를 고려해보세요.

```text
     leaf lxiv {
       type decimal64 {
         fraction-digits 18;
       }
       must ". <= 10";
     }
```

값이 10.0000000000000001인 "lxiv" 리프의 인스턴스는 유효성 검사를 성공적으로 통과합니다.

---
#### **6.4.1.  XPath Context**

모든 YANG XPath 표현식은 다음 XPath 컨텍스트 정의를 공유합니다.

o 네임스페이스 선언 세트는 XPath 표현식이 지정된 모듈의 모든 "import" 문의 접두사 및 네임스페이스 쌍과 "네임스페이스" 문의 URI에 대한 "접두사" 문의 접두사 세트입니다.

o 네임스페이스 접두사가 없는 이름은 현재 노드의 식별자와 동일한 네임스페이스에 속합니다. 그룹화 내에서 해당 네임스페이스는 그룹화가 사용되는 위치에 따라 영향을 받습니다\(섹션 7.13 참조\). typedef 내에서 해당 네임스페이스는 typedef가 참조되는 위치에 영향을 받습니다. typedef가 그룹화 내에서 정의되고 참조되는 경우 네임스페이스는 그룹화가 사용되는 위치에 영향을 받습니다\(섹션 7.13 참조\).

o 함수 라이브러리는 \[XPATH\]에 정의된 핵심 함수 라이브러리와 섹션 10에 정의된 함수입니다.

o 변수 바인딩 세트가 비어 있습니다.

접두사가 없는 이름을 처리하는 메커니즘은 XPath 2.0 \[XPATH2.0\]에서 채택되었으며 YANG에서 XPath 표현식을 단순화하는 데 도움이 됩니다. YANG 노드 식별자는 항상 null이 아닌 네임스페이스 URI를 가진 정규화된 이름이므로 모호성이 발생할 수 없습니다.

액세스 가능한 트리는 XPath 표현식이 포함된 명령문이 정의된 위치에 따라 달라집니다.

o XPath 표현식이 구성을 나타내는 데이터 노드에 대한 하위 설명에 정의된 경우 액세스 가능한 트리는 컨텍스트 노드가 존재하는 데이터 저장소의 데이터입니다. 루트 노드는 모든 모듈의 모든 최상위 구성 데이터 노드를 하위 노드로 갖습니다.

o XPath 표현식이 상태 데이터를 나타내는 데이터 노드에 대한 하위 설명에 정의된 경우 액세스 가능한 트리는 서버의 모든 상태 데이터와 실행 중인 구성 데이터 저장소입니다. 루트 노드는 모든 모듈의 모든 최상위 데이터 노드를 하위 노드로 갖습니다.

o XPath 표현식이 하위 설명에 정의된 경우

- "알림" 문에서 액세스 가능한 트리는 알림 인스턴스, 서버의 모든 상태 데이터 및 실행 중인 구성 데이터 저장소입니다. 알림이 모듈의 최상위 수준에 정의된 경우 루트 노드에는 노드가 있습니다.

- 정의되는 알림과 모든 모듈의 모든 최상위 데이터 노드를 하위 항목으로 나타냅니다. 그렇지 않으면 루트 노드는 모든 모듈의 모든 최상위 데이터 노드를 자식으로 갖습니다.

o XPath 표현식이 "rpc" 또는 "action" 문의 "input" 문에 대한 하위 문으로 정의된 경우 액세스 가능한 트리는 RPC 또는 작업 작업 인스턴스, 서버의 모든 상태 데이터 및 실행 중인 구성 데이터 저장소입니다. . 루트 노드에는 모든 모듈의 최상위 데이터 노드가 하위로 있습니다. 또한 RPC의 경우 루트 노드에는 하위로 정의되는 RPC 작업을 나타내는 노드도 있습니다. 정의 중인 작업을 나타내는 노드에는 해당 작업의 입력 매개변수가 자식으로 포함됩니다.

o XPath 표현식이 "rpc" 또는 "action" 문의 "output" 문에 대한 하위 문으로 정의된 경우 액세스 가능한 트리는 RPC 또는 작업 작업 인스턴스, 서버의 모든 상태 데이터 및 실행 중인 구성 데이터 저장소입니다. . 루트 노드에는 모든 모듈의 최상위 데이터 노드가 하위로 있습니다. 또한 RPC의 경우 루트 노드에는 하위로 정의되는 RPC 작업을 나타내는 노드도 있습니다. 정의되는 작업을 나타내는 노드는 작업의 출력 매개변수를 하위로 갖습니다.

접근 가능한 트리에는 사용 중인 기본값이 있는 모든 리프와 리프 목록이 존재합니다\(섹션 7.6.1 및 7.7.2 참조\).

액세스 가능한 트리에 존재하는 노드가 비존재 컨테이너를 하위로 갖는 경우 비존재 컨테이너도 액세스 가능한 트리에 존재합니다.

컨텍스트 노드는 YANG XPath 표현식에 따라 달라지며 XPath 표현식이 포함된 YANG 문이 정의된 위치에 지정됩니다.

---
##### **6.4.1.1.  Examples**

다음 모듈이 주어지면:

```text
     module example-a {
       yang-version 1.1;
       namespace urn:example:a;
       prefix a;

       container a {
         list b {
           key id;
           leaf id {
             type string;
           }
           notification down {
             leaf reason {
               type string;
             }
           }
           action reset {
             input {
               leaf delay {
                 type uint32;
               }
             }
             output {
               leaf result {
                 type string;
               }
             }
           }
         }
       }
       notification failure {
         leaf b-ref {
           type leafref {
             path "/a/b/id";
           }
         }
       }
     }
```

XML로 지정된 다음 데이터 트리가 제공됩니다.

```text
     <a xmlns="urn:example:a">
       <b>
         <id>1</id>
       </b>
       <b>
         <id>2</id>
       </b>
     </a>
```

/a/b\[id="2"\]의 "down" 알림에 대해 액세스 가능한 트리는 다음과 같습니다.

```text
     <a xmlns="urn:example:a">
       <b>
         <id>1</id>
       </b>
       <b>
         <id>2</id>
         <down>
           <reason>error</reason>
         </down>
       </b>
     </a>
     // possibly other top-level nodes here
```

"when" 매개변수가 "10"으로 설정된 /a/b\[id="1"\]에서 "reset" 작업 호출에 대해 액세스 가능한 트리는 다음과 같습니다.

```text
     <a xmlns="urn:example:a">
       <b>
         <id>1</id>
         <reset>
           <delay>10</delay>
         </reset>
       </b>
       <b>
         <id>2</id>
       </b>
     </a>
     // possibly other top-level nodes here
```

이 작업의 작업 출력에 대해 액세스 가능한 트리는 다음과 같습니다.

```text
     <a xmlns="urn:example:a">
       <b>
         <id>1</id>
         <reset>
           <result>ok</result>
         </reset>
       </b>
       <b>
         <id>2</id>
       </b>
     </a>
     // possibly other top-level nodes here
```

알림 "실패"에 대해 액세스 가능한 트리는 다음과 같습니다.

```text
     <a xmlns="urn:example:a">
       <b>
         <id>1</id>
       </b>
       <b>
         <id>2</id>
       </b>
     </a>
     <failure>
       <b-ref>2</b-ref>
     </failure>
     // possibly other top-level nodes here
```

---
### **6.5.  Schema Node Identifier**

스키마 노드 식별자는 스키마 트리에서 노드를 식별하는 문자열입니다. 이는 각각 섹션 14의 "absolute-schema-nodeid" 및 "descendant-schema-nodeid" 규칙에 의해 정의된 "absolute" 및 "descendant"의 두 가지 형식을 갖습니다. 스키마 노드 식별자는 슬래시\("/"\)로 구분된 식별자 경로로 구성됩니다. 절대 스키마 노드 식별자에서 선행 슬래시 뒤의 첫 번째 식별자는 로컬 모듈 또는 가져온 모듈의 최상위 스키마 노드입니다.

외부 모듈에 정의된 식별자에 대한 참조는 적절한 접두사로 한정되어야 하며, 현재 모듈과 해당 하위 모듈에 정의된 식별자에 대한 참조는 접두사를 사용할 수 있습니다.\(MUST\)

예를 들어, 최상위 노드 "a"의 하위 노드 "b"를 식별하려면 문자열 "/a/b"를 사용할 수 있습니다.

---
## **7.  YANG Statements**

다음 섹션에서는 모든 YANG 문을 설명합니다.

YANG에 정의된 하위 명령문이 없는 명령문이라도 공급업체별 확장을 하위 명령문으로 가질 수 있습니다. 예를 들어 "설명" 문에는 YANG에 정의된 하위 문이 없지만 다음은 유효합니다.

```text
     description "Some text." {
       ex:documentation-flag 5;
     }
```

---
### **7.1.  The "module" Statement**

"모듈" 문은 모듈의 이름을 정의하고 모듈에 속한 모든 문을 함께 그룹화합니다. "모듈" 명령문의 인수는 모듈 이름이며, 그 뒤에는 자세한 모듈 정보를 담고 있는 하위 명령문 블록이 옵니다. 모듈 이름은 식별자입니다\(섹션 6.2 참조\).

RFC 스트림\[RFC4844\]에 게시된 모듈 이름은 IANA에 의해 할당되어야 합니다. \[RFC6020\]의 섹션 14를 참조하세요.\(MUST\)

개인 모듈 이름은 중앙 레지스트리 없이 모듈을 소유한 조직에서 할당됩니다. 모듈 이름을 지정하는 방법에 대한 권장 사항은 섹션 5.1을 참조하세요.

모듈은 일반적으로 다음과 같은 레이아웃을 갖습니다.

```text
     module <module-name> {

       // header information
       <yang-version statement>
       <namespace statement>
       <prefix statement>

       // linkage statements
       <import statements>
       <include statements>

       // meta-information
       <organization statement>
       <contact statement>
       <description statement>
       <reference statement>

       // revision history
       <revision statements>

       // module definitions
       <other statements>
     }
```

---
#### **7.1.1.  The module's Substatements**

```text
                 +--------------+---------+-------------+
                 | substatement | section | cardinality |
                 +--------------+---------+-------------+
                 | anydata      | 7.10    | 0..n        |
                 | anyxml       | 7.11    | 0..n        |
                 | augment      | 7.17    | 0..n        |
                 | choice       | 7.9     | 0..n        |
                 | contact      | 7.1.8   | 0..1        |
                 | container    | 7.5     | 0..n        |
                 | description  | 7.21.3  | 0..1        |
                 | deviation    | 7.20.3  | 0..n        |
                 | extension    | 7.19    | 0..n        |
                 | feature      | 7.20.1  | 0..n        |
                 | grouping     | 7.12    | 0..n        |
                 | identity     | 7.18    | 0..n        |
                 | import       | 7.1.5   | 0..n        |
                 | include      | 7.1.6   | 0..n        |
                 | leaf         | 7.6     | 0..n        |
                 | leaf-list    | 7.7     | 0..n        |
                 | list         | 7.8     | 0..n        |
                 | namespace    | 7.1.3   | 1           |
                 | notification | 7.16    | 0..n        |
                 | organization | 7.1.7   | 0..1        |
                 | prefix       | 7.1.4   | 1           |
                 | reference    | 7.21.4  | 0..1        |
                 | revision     | 7.1.9   | 0..n        |
                 | rpc          | 7.14    | 0..n        |
                 | typedef      | 7.3     | 0..n        |
                 | uses         | 7.13    | 0..n        |
                 | yang-version | 7.1.2   | 1           |
                 +--------------+---------+-------------+
```

---
#### **7.1.2.  The "yang-version" Statement**

"yang-version" 문은 모듈 개발에 사용된 YANG 언어 버전을 지정합니다. 명령문의 인수는 문자열입니다. 이 사양을 기반으로 정의된 YANG 모듈에 대한 값 "1.1"을 포함해야 합니다.\(MUST\)

"yang-version" 문을 포함하지 않거나 "1" 값을 포함하는 모듈 또는 하위 모듈은 \[RFC6020\]에 정의된 YANG 버전 1용으로 개발되었습니다.

"1.1"\(여기에 정의된 버전\) 이외의 버전에 대한 "yang-version" 문 처리는 이 사양의 범위를 벗어납니다. 더 높은 버전을 정의하는 모든 문서는 그러한 더 높은 버전의 이전 버전과의 호환성을 정의해야 합니다.

YANG 버전 1과 1.1 간의 호환성은 섹션 12를 참조하세요.

---
#### **7.1.3.  The "namespace" Statement**

"네임스페이스" 문은 모듈에 의해 정의된 모든 식별자가 XML 인코딩에서 정규화되는 XML 네임스페이스를 정의합니다. 단, 그룹화 내부에 정의된 데이터 노드, 작업 노드 및 알림 노드에 대한 식별자는 예외입니다\(자세한 내용은 섹션 7.13 참조\). . "네임스페이스" 문의 인수는 네임스페이스의 URI입니다.

```text
   See also Section 5.3.
```

---
#### **7.1.4.  The "prefix" Statement**

"prefix" 문은 모듈 및 해당 네임스페이스와 관련된 접두사를 정의하는 데 사용됩니다. "prefix" 문의 인수는 모듈에 액세스하기 위해 접두어로 사용되는 접두사 문자열입니다. 모듈에 포함된 정의를 참조하기 위해 접두사 문자열을 모듈과 함께 사용할 수 있습니다\(예: "if:ifName"\). 접두사는 식별자입니다\(섹션 6.2 참조\).\(MAY\)

"모듈" 문 내에서 사용될 때 "접두사" 문은 이 모듈을 가져올 때 사용하도록 제안된 접두사를 정의합니다.

NETCONF XML의 가독성을 높이기 위해 접두사를 사용하는 XML 또는 XPath를 생성하는 NETCONF 클라이언트 또는 서버는 충돌이 없는 한 모듈에서 정의한 접두사를 XML 네임스페이스 접두사로 사용해야 합니다.\(SHOULD\)

"import" 문 내에서 사용되는 경우 "prefix" 문은 가져온 모듈 내부의 정의에 액세스할 때 사용할 접두사를 정의합니다. 가져온 모듈의 식별자에 대한 참조가 사용되는 경우 가져온 모듈의 접두사 문자열 뒤에 콜론\(":"\)과 식별자가 사용됩니다\(예: "if:ifIndex"\). YANG 모듈의 가독성을 높이려면 충돌이 없는 한 모듈을 가져올 때 모듈에서 정의한 접두사를 사용해야 합니다. 충돌이 있는 경우, 즉 동일한 접두사를 정의한 두 개의 서로 다른 모듈을 가져오면 그 중 적어도 하나를 다른 접두사로 가져와야 합니다.\(SHOULD, MUST\)

모듈 자체의 접두사를 포함한 모든 접두사는 모듈 또는 하위 모듈 내에서 고유해야 합니다.\(MUST\)

---
#### **7.1.5.  The "import" Statement**

"import" 문은 한 모듈의 정의를 다른 모듈이나 하위 모듈 내에서 사용할 수 있도록 만듭니다. 인수는 가져올 모듈의 이름이며 명령문 다음에는 자세한 가져오기 정보를 보유하는 하위 명령문 블록이 옵니다. 모듈을 가져올 때 가져오는 모듈은 다음을 수행할 수 있습니다.

o 가져온 모듈이나 해당 하위 모듈의 최상위 수준에 정의된 그룹화 및 typedef를 사용합니다.

o 가져온 모듈이나 해당 하위 모듈에 정의된 확장, 기능 및 ID를 사용합니다.

o "must", "path" 및 "when" 문에서 가져온 모듈의 스키마 트리에 있는 노드를 사용하거나 "augment" 및 "deviation" 문에서 대상 노드로 사용합니다.

필수 "접두사" 하위 설명은 가져오기 모듈 또는 하위 모듈로 범위가 지정된 가져온 모듈에 대한 접두사를 할당합니다. 여러 "import" 문을 지정하여 여러 모듈에서 가져올 수 있습니다.

선택적 "revision-date" 하위 설명이 있는 경우 로컬 모듈의 정의에서 참조되는 모든 typedef, 그룹화, 확장, 기능 및 ID는 가져온 모듈의 지정된 개정에서 가져옵니다. 가져온 모듈의 지정된 개정판이 존재하지 않으면 오류입니다. "개정 날짜" 하위 설명이 없으면 모듈의 어느 개정판에서 가져온 것인지 정의되지 않습니다.

서로 다른 접두사가 사용되는 경우 동일한 모듈의 여러 개정판을 가져올 수 있습니다.

```text
                 +---------------+---------+-------------+
                 | substatement  | section | cardinality |
                 +---------------+---------+-------------+
                 | description   | 7.21.3  | 0..1        |
                 | prefix        | 7.1.4   | 1           |
                 | reference     | 7.21.4  | 0..1        |
                 | revision-date | 7.1.5.1 | 0..1        |
                 +---------------+---------+-------------+
```

- 수입품의 기재사항

---
##### **7.1.5.1.  The import's "revision-date" Statement**

가져오기의 "revision-date" 문은 가져올 모듈의 버전을 지정하는 데 사용됩니다.

---
#### **7.1.6.  The "include" Statement**

"include" 문은 하위 모듈의 콘텐츠를 해당 하위 모듈의 상위 모듈에서 사용할 수 있도록 만드는 데 사용됩니다. 인수는 포함할 하위 모듈의 이름인 식별자입니다. 모듈은 "belongs-to" 문에 정의된 대로 해당 모듈에 속하는 하위 모듈만 포함할 수 있습니다\(섹션 7.2.2 참조\).

모듈에 하위 모듈이 포함되어 있으면 하위 모듈의 내용이 모듈의 노드 계층 구조에 통합됩니다.

YANG 버전 1과의 하위 호환성을 위해 하위 모듈은 동일한 모듈에 속하는 다른 하위 모듈을 포함할 수 있지만 YANG 버전 1.1에서는 이것이 필요하지 않습니다\(섹션 5.1 참조\).

선택적 "revision-date" 하위 설명이 있는 경우 하위 모듈의 지정된 개정이 모듈에 포함됩니다. 하위 모듈의 지정된 개정판이 없으면 오류입니다. "개정 날짜" 하위 설명이 없으면 하위 모듈의 어떤 개정이 포함되어 있는지 정의되지 않습니다.

동일한 하위 모듈의 여러 개정판을 포함하면 안 됩니다.\(MUST NOT\)

```text
                 +---------------+---------+-------------+
                 | substatement  | section | cardinality |
                 +---------------+---------+-------------+
                 | description   | 7.21.3  | 0..1        |
                 | reference     | 7.21.4  | 0..1        |
                 | revision-date | 7.1.5.1 | 0..1        |
                 +---------------+---------+-------------+

                       The includes's Substatements
```

---
#### **7.1.7.  The "organization" Statement**

"조직" 문은 이 모듈을 담당하는 당사자를 정의합니다. 인수는 이 모듈이 개발된 후원을 받는 조직에 대한 텍스트 설명을 지정하는 데 사용되는 문자열입니다.

---
#### **7.1.8.  The "contact" Statement**

"연락처" 문은 모듈에 대한 연락처 정보를 제공합니다. 인수는 이름, 우편 주소, 전화번호, 전자 메일 주소 등 이 모듈에 관한 기술 문의를 보내야 하는 사람의 연락처 정보를 지정하는 데 사용되는 문자열입니다.

---
#### **7.1.9.  The "revision" Statement**

"개정" 문은 초기 개정을 포함하여 모듈의 편집 개정 내역을 지정합니다. 일련의 "개정" 문은 모듈 정의의 변경 사항을 자세히 설명합니다. 인수는 "YYYY-MM-DD" 형식의 날짜 문자열이며 그 뒤에 자세한 개정 정보를 보유하는 하위 설명 블록이 옵니다. 모듈에는 최소한 하나의 "개정" 문이 있어야 합니다. 게시된 모든 편집 변경 사항에 대해 모든 개정 내용이 역순으로 정렬되도록 개정 순서 앞에 새로운 내용을 추가해야 합니다.\(SHOULD, SHOULD\)

---
##### **7.1.9.1.  The revision's Substatements**

```text
                 +--------------+---------+-------------+
                 | substatement | section | cardinality |
                 +--------------+---------+-------------+
                 | description  | 7.21.3  | 0..1        |
                 | reference    | 7.21.4  | 0..1        |
                 +--------------+---------+-------------+
```

---
#### **7.1.10.  Usage Example**

다음 예는 \[RFC6991\]을 사용합니다.

```text
     module example-system {
       yang-version 1.1;
       namespace "urn:example:system";
       prefix "sys";

       import ietf-yang-types {
         prefix "yang";
         reference "RFC 6991: Common YANG Data Types";
       }

       include example-types;

       organization "Example Inc.";
       contact
         "Joe L. User

          Example Inc.
          42 Anywhere Drive
          Nowhere, CA 95134
          USA

          Phone: +1 800 555 0100
          Email: joe@example.com";

       description
         "The module for entities implementing the Example system.";

       revision 2007-06-09 {
         description "Initial revision.";
       }

       // definitions follow...
     }
```

---
### **7.2.  The "submodule" Statement**

YANG의 기본 장치는 모듈이지만 YANG 모듈 자체는 여러 하위 모듈로 구성될 수 있습니다. 하위 모듈을 사용하면 모듈 디자이너는 복잡한 모델을 모든 하위 모듈이 하위 모듈을 포함하는 모듈에 의해 정의되는 단일 네임스페이스에 기여하는 여러 조각으로 분할할 수 있습니다.

"submodule" 문은 하위 모듈의 이름을 정의하고 하위 모듈에 속한 모든 문을 함께 그룹화합니다. "하위 모듈" 문의 인수는 하위 모듈의 이름이며, 그 뒤에는 자세한 하위 모듈 정보를 보유하는 하위 명령문 블록이 옵니다. 서브모듈 이름은 식별자입니다\(섹션 6.2 참조\).

RFC 스트림\[RFC4844\]에 게시된 하위 모듈의 이름은 IANA에 의해 할당되어야 합니다. \[RFC6020\]의 섹션 14를 참조하세요.\(MUST\)

개인 하위 모듈 이름은 중앙 레지스트리 없이 하위 모듈을 소유한 조직에서 할당됩니다. 서브모듈 이름을 지정하는 방법에 대한 권장 사항은 섹션 5.1을 참조하세요.

하위 모듈의 레이아웃은 일반적으로 다음과 같습니다.

```text
     submodule <module-name> {

       <yang-version statement>

       // module identification
       <belongs-to statement>

       // linkage statements
       <import statements>

       // meta-information
       <organization statement>
       <contact statement>
       <description statement>
       <reference statement>

       // revision history
       <revision statements>

       // module definitions
       <other statements>
     }
```

---
#### **7.2.1.  The submodule's Substatements**

```text
                 +--------------+---------+-------------+
                 | substatement | section | cardinality |
                 +--------------+---------+-------------+
                 | anydata      | 7.10    | 0..n        |
                 | anyxml       | 7.11    | 0..n        |
                 | augment      | 7.17    | 0..n        |
                 | belongs-to   | 7.2.2   | 1           |
                 | choice       | 7.9     | 0..n        |
                 | contact      | 7.1.8   | 0..1        |
                 | container    | 7.5     | 0..n        |
                 | description  | 7.21.3  | 0..1        |
                 | deviation    | 7.20.3  | 0..n        |
                 | extension    | 7.19    | 0..n        |
                 | feature      | 7.20.1  | 0..n        |
                 | grouping     | 7.12    | 0..n        |
                 | identity     | 7.18    | 0..n        |
                 | import       | 7.1.5   | 0..n        |
                 | include      | 7.1.6   | 0..n        |
                 | leaf         | 7.6     | 0..n        |
                 | leaf-list    | 7.7     | 0..n        |
                 | list         | 7.8     | 0..n        |
                 | notification | 7.16    | 0..n        |
                 | organization | 7.1.7   | 0..1        |
                 | reference    | 7.21.4  | 0..1        |
                 | revision     | 7.1.9   | 0..n        |
                 | rpc          | 7.14    | 0..n        |
                 | typedef      | 7.3     | 0..n        |
                 | uses         | 7.13    | 0..n        |
                 | yang-version | 7.1.2   | 1           |
                 +--------------+---------+-------------+
```

---
#### **7.2.2.  The "belongs-to" Statement**

"belongs-to" 문은 하위 모듈이 속한 모듈을 지정합니다. 인수는 모듈의 이름인 식별자입니다.

하위 모듈은 자신이 속한 모듈이나 해당 모듈에 속한 다른 하위 모듈에만 포함되어야 합니다.\(MUST\)

필수 "접두사" 하위 명령문은 하위 모듈이 속한 모듈에 대한 접두사를 할당합니다. 하위 모듈이 속한 모듈과 해당 하위 모듈의 모든 정의는 접두사를 사용하여 액세스할 수 있습니다.

```text
                 +--------------+---------+-------------+
                 | substatement | section | cardinality |
                 +--------------+---------+-------------+
                 | prefix       | 7.1.4   | 1           |
                 +--------------+---------+-------------+

                       The belongs-to's Substatement
```

---
#### **7.2.3.  Usage Example**

```text
     submodule example-types {
       yang-version 1.1;
       belongs-to "example-system" {
         prefix "sys";
       }

       import ietf-yang-types {
         prefix "yang";
       }

       organization "Example Inc.";
       contact
         "Joe L. User

          Example Inc.
          42 Anywhere Drive
          Nowhere, CA 95134
          USA

          Phone: +1 800 555 0100
          Email: joe@example.com";

       description
         "This submodule defines common Example types.";

       revision "2007-06-09" {
         description "Initial revision.";
       }

       // definitions follow...
     }
```

---
### **7.3.  The "typedef" Statement**

"typedef" 문은 섹션 5.5의 규칙에 따라 모듈이나 하위 모듈에서 로컬로 사용할 수 있는 새로운 유형을 정의하고, 여기서 가져오는 다른 모듈에서 사용할 수 있습니다. 새로운 유형을 "파생 유형"이라고 하며, 파생된 유형을 "기본 유형"이라고 합니다. 모든 파생 유형은 YANG 내장 유형으로 역추적될 수 있습니다.

"typedef" 문의 인수는 정의할 유형의 이름인 식별자이며 뒤에는 자세한 typedef 정보를 포함하는 하위 명령문 블록이 와야 합니다.\(MUST\)

유형의 이름은 YANG 내장 유형 중 하나가 아니어야 합니다. typedef가 YANG 모듈 또는 하위 모듈의 최상위 수준에 정의된 경우 정의할 유형의 이름은 모듈 내에서 고유해야 합니다.\(MUST NOT, MUST\)

---
#### **7.3.1.  The typedef's Substatements**

```text
                 +--------------+---------+-------------+
                 | substatement | section | cardinality |
                 +--------------+---------+-------------+
                 | default      | 7.3.4   | 0..1        |
                 | description  | 7.21.3  | 0..1        |
                 | reference    | 7.21.4  | 0..1        |
                 | status       | 7.21.2  | 0..1        |
                 | type         | 7.3.2   | 1           |
                 | units        | 7.3.3   | 0..1        |
                 +--------------+---------+-------------+
```

---
#### **7.3.2.  The typedef's "type" Statement**

반드시 존재해야 하는 "type" 문은 이 유형이 파생되는 기본 유형을 정의합니다. 자세한 내용은 섹션 7.4를 참조하세요.\(MUST\)

---
#### **7.3.3.  The "units" Statement**

선택 사항인 "units" 문은 해당 유형과 관련된 단위의 텍스트 정의가 포함된 문자열을 인수로 사용합니다.

---
#### **7.3.4.  The typedef's "default" Statement**

"default" 문은 새 유형의 기본값이 포함된 문자열을 인수로 사용합니다.

"default" 문의 값은 "type" 문에 지정된 유형에 따라 유효해야 합니다.\(MUST\)

기본 유형에 기본값이 있고 새 파생 유형이 새 기본값을 지정하지 않는 경우 기본 유형의 기본값은 새 파생 유형의 기본값이기도 합니다.

유형의 기본값이 파생 유형 또는 리프 정의에 지정된 새 제한 사항에 따라 유효하지 않은 경우 파생 유형 또는 리프 정의는 제한 사항과 호환되는 새 기본값을 지정해야 합니다.\(MUST\)

---
#### **7.3.5.  Usage Example**

```text
     typedef listen-ipv4-address {
       type inet:ipv4-address;
       default "0.0.0.0";
     }
```

---
### **7.4.  The "type" Statement**

"type" 문은 YANG 내장 유형\(섹션 9 참조\) 또는 파생 유형\(섹션 7.3 참조\)의 이름인 문자열을 인수로 취하고, 그 뒤에 추가 설명에 사용되는 선택적 하위 문 블록이 옵니다. 유형에 대한 제한.

적용할 수 있는 제한은 제한되는 유형에 따라 다릅니다. 모든 내장 유형에 대한 제한 사항은 섹션 9의 하위 섹션에 설명되어 있습니다.

---
#### **7.4.1.  The type's Substatements**

```text
               +------------------+---------+-------------+
               | substatement     | section | cardinality |
               +------------------+---------+-------------+
               | base             | 7.18.2  | 0..n        |
               | bit              | 9.7.4   | 0..n        |
               | enum             | 9.6.4   | 0..n        |
               | fraction-digits  | 9.3.4   | 0..1        |
               | length           | 9.4.4   | 0..1        |
               | path             | 9.9.2   | 0..1        |
               | pattern          | 9.4.5   | 0..n        |
               | range            | 9.2.4   | 0..1        |
               | require-instance | 9.9.3   | 0..1        |
               | type             | 7.4     | 0..n        |
               +------------------+---------+-------------+
```

---
### **7.5.  The "container" Statement**

"컨테이너" 문은 스키마 트리에서 내부 데이터 노드를 정의하는 데 사용됩니다. 이는 식별자인 하나의 인수를 취하고 그 뒤에 자세한 컨테이너 정보를 보유하는 하위 명령문 블록이 옵니다.

컨테이너 노드에는 값이 없지만 데이터 트리에 하위 노드 목록이 있습니다. 하위 노드는 컨테이너의 하위 설명에 정의됩니다.

---
#### **7.5.1.  Containers with Presence**

YANG은 두 가지 스타일의 컨테이너를 지원합니다. 하나는 데이터 노드의 계층 구조를 구성하기 위해서만 존재하는 것과 데이터 트리에 존재한다는 것이 명시적인 의미를 갖는 것입니다.

첫 번째 스타일에서 컨테이너는 자체적으로 의미가 없으며 하위 노드를 포함하기 위해서만 존재합니다. 특히 하위 노드가 없는 컨테이너 노드가 있다는 것은 컨테이너 노드가 없다는 것과 의미상 동일합니다. YANG은 이 스타일을 "비존재 컨테이너"라고 부릅니다. 이것이 기본 스타일입니다.

예를 들어, SONET\(동기식 광 네트워크\) 인터페이스에 대한 스크램블링 옵션 세트를 "스크램블링" 컨테이너 내에 배치하여 구성 계층의 구성을 강화하고 이러한 노드를 함께 유지할 수 있습니다. "스크램블링" 노드 자체는 의미가 없으므로 노드가 비어 있을 때 노드를 제거하면 사용자가 이 작업을 수행할 필요가 없습니다.

두 번째 스타일에서는 컨테이너 자체의 존재가 단일 데이터 비트를 나타내는 어떤 의미를 전달합니다.

구성 데이터의 경우 컨테이너는 구성 손잡이이자 관련 구성 노드를 구성하는 수단 역할을 합니다. 이러한 컨테이너는 명시적으로 생성되고 삭제됩니다.

YANG은 이 스타일을 "존재 컨테이너"라고 부르며 노드의 존재가 무엇을 의미하는지 나타내는 텍스트 문자열을 인수로 사용하는 "존재" 문을 사용하여 표시됩니다.

예를 들어 "ssh" 컨테이너는 SSH\(Secure SHell\)를 사용하여 서버에 로그인하는 기능을 켤 수 있지만 연결 속도 또는 재시도 제한과 같은 SSH 관련 구성 손잡이도 포함할 수 있습니다.

"존재" 문\(섹션 7.5.5 참조\)은 데이터 트리에서 컨테이너의 존재에 의미를 부여하는 데 사용됩니다.

---
#### **7.5.2.  The container's Substatements**

```text
                 +--------------+---------+-------------+
                 | substatement | section | cardinality |
                 +--------------+---------+-------------+
                 | action       | 7.15    | 0..n        |
                 | anydata      | 7.10    | 0..n        |
                 | anyxml       | 7.11    | 0..n        |
                 | choice       | 7.9     | 0..n        |
                 | config       | 7.21.1  | 0..1        |
                 | container    | 7.5     | 0..n        |
                 | description  | 7.21.3  | 0..1        |
                 | grouping     | 7.12    | 0..n        |
                 | if-feature   | 7.20.2  | 0..n        |
                 | leaf         | 7.6     | 0..n        |
                 | leaf-list    | 7.7     | 0..n        |
                 | list         | 7.8     | 0..n        |
                 | must         | 7.5.3   | 0..n        |
                 | notification | 7.16    | 0..n        |
                 | presence     | 7.5.5   | 0..1        |
                 | reference    | 7.21.4  | 0..1        |
                 | status       | 7.21.2  | 0..1        |
                 | typedef      | 7.3     | 0..n        |
                 | uses         | 7.13    | 0..n        |
                 | when         | 7.21.5  | 0..1        |
                 +--------------+---------+-------------+
```

---
#### **7.5.3.  The "must" Statement**

선택 사항인 "must" 문은 XPath 표현식이 포함된 문자열을 인수로 사용합니다\(섹션 6.4 참조\). 유효한 데이터에 대한 제약 조건을 공식적으로 선언하는 데 사용됩니다. 제약은 섹션 8의 규칙에 따라 시행됩니다.

데이터 저장소가 검증되면 모든 "필수" 제약 조건은 액세스 가능한 트리의 각 노드에 대해 한 번씩 개념적으로 평가됩니다\(섹션 6.4.1 참조\).

데이터가 유효하려면 이러한 모든 제약 조건이 "true"로 평가되어야 합니다.\(MUST\)

XPath 표현식은 섹션 6.4.1의 정의 외에도 다음 컨텍스트에서 개념적으로 평가됩니다.

o "반드시" 진술이 "통지" 진술의 하위 진술인 경우 컨텍스트 노드는 액세스 가능한 트리에서 알림을 나타내는 노드입니다.

o "반드시" 문이 "입력" 문의 하위 문인 경우 컨텍스트 노드는 액세스 가능한 트리의 작업을 나타내는 노드입니다.

o "반드시" 진술이 "출력"의 하위 진술인 경우

- 문에서 컨텍스트 노드는 액세스 가능한 트리의 작업을 나타내는 노드입니다.

o 그렇지 않은 경우 컨텍스트 노드는 "반드시" 문이 정의된 액세스 가능한 트리의 노드입니다.

XPath 표현식의 결과는 표준 XPath 규칙을 사용하여 부울 값으로 변환됩니다.

데이터 트리의 모든 리프 값은 개념적으로 표준 형식\(섹션 9.1 참조\)으로 저장되므로 모든 XPath 비교는 표준 값에 대해 수행됩니다.

또한 XPath 표현식은 개념적으로 평가됩니다. 이는 구현이 서버에서 XPath 평가자를 사용할 필요가 없음을 의미합니다. 실제로 평가가 어떻게 수행되는지는 구현 결정입니다.

---
#### **7.5.4.  The must's Substatements**

```text
                 +---------------+---------+-------------+
                 | substatement  | section | cardinality |
                 +---------------+---------+-------------+
                 | description   | 7.21.3  | 0..1        |
                 | error-app-tag | 7.5.4.2 | 0..1        |
                 | error-message | 7.5.4.1 | 0..1        |
                 | reference     | 7.21.4  | 0..1        |
                 +---------------+---------+-------------+
```

---
##### **7.5.4.1.  The "error-message" Statement**

선택사항인 "error-message" 문은 문자열을 인수로 사용합니다. 제약 조건이 "false"로 평가되면 문자열은 NETCONF의 <rpc-error\>에 <error-message\>로 전달됩니다.

---
##### **7.5.4.2.  The "error-app-tag" Statement**

선택사항인 "error-app-tag" 문은 문자열을 인수로 사용합니다. 제약 조건이 "false"로 평가되면 문자열은 NETCONF의 <rpc-error\>에 <error-app-tag\>로 전달됩니다.

---
##### **7.5.4.3.  Usage Example of must and error-message**

```text
     container interface {
       leaf ifType {
         type enumeration {
           enum ethernet;
           enum atm;
         }
       }
       leaf ifMTU {
         type uint32;
       }
       must 'ifType != "ethernet" or ifMTU = 1500' {
         error-message "An Ethernet MTU must be 1500";
       }
       must 'ifType != "atm" or'
          + ' (ifMTU <= 17966 and ifMTU >= 64)' {
         error-message "An ATM MTU must be 64 .. 17966";
       }
     }
```

---
#### **7.5.5.  The "presence" Statement**

"존재" 문은 데이터 트리에 컨테이너가 있다는 의미를 지정합니다. 노드의 존재가 의미하는 바에 대한 텍스트 설명이 포함된 문자열을 인수로 사용합니다.

컨테이너에 "존재" 문이 있는 경우 데이터 트리에 컨테이너가 존재한다는 것은 어떤 의미를 갖습니다. 그렇지 않으면 컨테이너는 데이터에 일부 구조를 제공하는 데 사용되며 그 자체로는 의미가 없습니다.

추가 정보는 섹션 7.5.1을 참조하십시오.

---
#### **7.5.6.  The container's Child Node Statements**

컨테이너 내에서 "container", "leaf", "list", "leaf-list", "uses", "choice", "anydata" 및 "anyxml" 문을 사용하여 컨테이너에 대한 하위 노드를 정의할 수 있습니다. .

---
#### **7.5.7.  XML Encoding Rules**

컨테이너 노드는 XML 요소로 인코딩됩니다. 요소의 로컬 이름은 컨테이너의 식별자이고 해당 네임스페이스는 모듈의 XML 네임스페이스입니다\(섹션 7.1.3 참조\).

컨테이너의 하위 노드는 컨테이너 요소의 하위 요소로 인코딩됩니다. 컨테이너가 RPC나 작업 입력 또는 출력 매개변수를 정의하는 경우 이러한 하위 요소는 "컨테이너" 문 내에 정의된 것과 동일한 순서로 인코딩됩니다. 그렇지 않으면 하위 요소가 어떤 순서로든 인코딩됩니다.

컨테이너에 대한 하위 요소 사이의 공백은 중요하지 않습니다. 즉, 구현은 하위 요소 사이에 공백 문자를 삽입할 수 있습니다.\(MAY\)

존재하지 않는 컨테이너에 하위 노드가 없는 경우 컨테이너는 XML 인코딩에 존재할 수도 있고 존재하지 않을 수도 있습니다.

---
#### **7.5.8.  NETCONF <edit-config> Operations**

컨테이너의 XML 요소에 있는 "작업" 속성\(\[RFC6241\]의 섹션 7.2 참조\)을 사용하여 <edit-config\>를 통해 컨테이너를 생성, 삭제, 교체 및 수정할 수 있습니다.

컨테이너에 "존재" 문이 없고 마지막 하위 노드가 삭제된 경우 NETCONF 서버는 컨테이너를 삭제할 수 있습니다.\(MAY\)

NETCONF 서버가 <edit-config\> 요청을 처리할 때 컨테이너 노드에 대한 절차 요소는 다음과 같습니다.

o 작업이 "병합" 또는 "교체"인 경우 노드가 없으면 노드가 생성됩니다.

o 작업이 "생성"인 경우 노드가 존재하지 않으면 노드가 생성됩니다. 노드가 이미 존재하는 경우 "data-exists" 오류가 반환됩니다.

o 작업이 "삭제"인 경우 노드가 있으면 삭제됩니다. 노드가 존재하지 않으면 "데이터 누락" 오류가 반환됩니다.

---
#### **7.5.9.  Usage Example**

다음과 같은 컨테이너 정의가 주어졌습니다.

```text
     container system {
       description
         "Contains various system parameters.";
       container services {
         description
           "Configure externally available services.";
         container "ssh" {
           presence "Enables SSH";
           description
             "SSH service-specific configuration.";
           // more leafs, containers, and stuff here...
         }
       }
     }
```

해당 XML 인스턴스 예:

```text
     <system>
       <services>
         <ssh/>
       </services>
     </system>
```

<ssh\> 요소가 있으므로 SSH가 활성화됩니다.

<edit-config\>를 사용하여 컨테이너를 삭제하려면 다음을 수행하세요.

```text
     <rpc message-id="101"
          xmlns="urn:ietf:params:xml:ns:netconf:base:1.0"
          xmlns:nc="urn:ietf:params:xml:ns:netconf:base:1.0">
       <edit-config>
         <target>
           <running/>
         </target>
         <config>
           <system xmlns="urn:example:config">
             <services>
               <ssh nc:operation="delete"/>
             </services>
           </system>
         </config>
       </edit-config>
     </rpc>
```

---
### **7.6.  The "leaf" Statement**

"리프" 문은 스키마 트리에서 리프 노드를 정의하는 데 사용됩니다. 이는 식별자인 하나의 인수를 취하고 그 뒤에 자세한 리프 정보를 보유하는 하위 명령문 블록이 옵니다.

데이터 트리에서 리프 노드에는 값이 있지만 하위 노드는 없습니다. 개념적으로 데이터 트리의 값은 항상 표준 형식입니다\(섹션 9.1 참조\).

리프 노드는 데이터 트리의 인스턴스 0개 또는 1개에 존재합니다.

"리프" 문은 특정 내장 유형 또는 파생 유형의 스칼라 변수를 정의하는 데 사용됩니다.

---
#### **7.6.1.  The leaf's Default Value**

리프의 기본값은 리프가 데이터 트리에 존재하지 않는 경우 서버가 사용하는 값입니다. 기본값의 사용법은 비존재 컨테이너가 아닌 스키마 트리에서 리프의 가장 가까운 조상 노드에 따라 달라집니다\(섹션 7.5.1 참조\).

o 스키마 트리에 해당 조상이 없으면 기본값을 사용해야 합니다.\(MUST\)

o 그렇지 않은 경우, 이 조상이 사례 노드인 경우 사례의 노드가 데이터 트리에 존재하거나 사례 노드가 선택의 기본 사례이고 다른 사례의 노드가 데이터에 존재하지 않는 경우 기본값을 사용해야 합니다. 나무.\(MUST\)

o 그렇지 않은 경우 조상 노드가 데이터 트리에 존재하는 경우 기본값을 사용해야 합니다.\(MUST\)

이러한 경우 기본값이 사용 중이라고 합니다.

리프 또는 그 조상 중 하나에 "false"로 평가되는 "when" 조건 또는 "if-feature" 표현식이 있는 경우 기본값은 사용되지 않습니다.

기본값이 사용 중인 경우 서버는 마치 리프가 기본값을 해당 값으로 사용하여 데이터 트리에 존재하는 것처럼 작동해야 합니다.\(MUST\)

리프에 "기본" 문이 있는 경우 리프의 기본값은 "기본" 문의 값입니다. 그렇지 않고 리프의 유형에 기본값이 있고 리프가 필수가 아닌 경우 리프의 기본값은 유형의 기본값이 됩니다. 다른 모든 경우에는 리프에 기본값이 없습니다.

---
#### **7.6.2.  The leaf's Substatements**

```text
                 +--------------+---------+-------------+
                 | substatement | section | cardinality |
                 +--------------+---------+-------------+
                 | config       | 7.21.1  | 0..1        |
                 | default      | 7.6.4   | 0..1        |
                 | description  | 7.21.3  | 0..1        |
                 | if-feature   | 7.20.2  | 0..n        |
                 | mandatory    | 7.6.5   | 0..1        |
                 | must         | 7.5.3   | 0..n        |
                 | reference    | 7.21.4  | 0..1        |
                 | status       | 7.21.2  | 0..1        |
                 | type         | 7.6.3   | 1           |
                 | units        | 7.3.3   | 0..1        |
                 | when         | 7.21.5  | 0..1        |
                 +--------------+---------+-------------+
```

---
#### **7.6.3.  The leaf's "type" Statement**

반드시 존재해야 하는 "type" 문은 기존 내장 유형 또는 파생 유형의 이름을 인수로 사용합니다. 선택적 하위 설명은 이 유형에 대한 제한 사항을 지정합니다. 자세한 내용은 섹션 7.4를 참조하세요.\(MUST\)

---
#### **7.6.4.  The leaf's "default" Statement**

선택적인 "default" 문은 리프의 기본값이 포함된 문자열을 인수로 사용합니다.

"기본" 문의 값은 리프의 "유형" 문에 지정된 유형에 따라 유효해야 합니다.\(MUST\)

"default" 문은 "mandatory"가 "true"인 노드에 있어서는 안 됩니다.\(MUST NOT\)

기본값의 정의는 "if-feature" 문으로 표시되어서는 안 됩니다. 예를 들어 다음은 불법입니다.\(MUST NOT\)

```text
     leaf color {
       type enumeration {
         enum blue { if-feature blue; }
         ...
       }
       default blue; // illegal - enum value is conditional
     }
```

---
#### **7.6.5.  The leaf's "mandatory" Statement**

선택 사항인 "필수" 문은 "true" 또는 "false" 문자열을 인수로 사용하고 유효한 데이터에 제약 조건을 적용합니다. 지정하지 않으면 기본값은 "false"입니다.

"mandatory"가 "true"인 경우 제약 조건의 동작은 비존재 컨테이너가 아닌 스키마 트리에서 리프의 가장 가까운 조상 노드 유형에 따라 달라집니다\(섹션 7.5.1 참조\).

o 스키마 트리에 그러한 조상이 없으면 리프가 반드시 존재해야 합니다.\(MUST\)

o 그렇지 않고 이 조상이 사례 노드인 경우 사례의 노드가 데이터 트리에 존재하면 리프가 반드시 존재해야 합니다.\(MUST\)

o 그렇지 않은 경우 조상 노드가 데이터 트리에 존재하는 경우 리프가 반드시 존재해야 합니다.\(MUST\)

이 제약은 섹션 8의 규칙에 따라 시행됩니다.

---
#### **7.6.6.  XML Encoding Rules**

리프 노드는 XML 요소로 인코딩됩니다. 요소의 로컬 이름은 리프의 식별자이고 해당 네임스페이스는 모듈의 XML 네임스페이스입니다\(섹션 7.1.3 참조\).

리프 노드의 값은 유형에 따라 XML로 인코딩되어 요소에 문자 데이터로 전송됩니다.

예제는 섹션 7.6.8을 참조하세요.

---
#### **7.6.7.  NETCONF <edit-config> Operations**

NETCONF 서버가 <edit-config\> 요청을 처리할 때 리프 노드에 대한 절차 요소는 다음과 같습니다.

o 작업이 "병합" 또는 "교체"인 경우 노드가 없으면 생성되고 해당 값은 XML RPC 데이터에 있는 값으로 설정됩니다.

o 작업이 "생성"인 경우 노드가 존재하지 않으면 노드가 생성됩니다. 노드가 이미 존재하는 경우 "data-exists" 오류가 반환됩니다.

o 작업이 "삭제"인 경우 노드가 있으면 삭제됩니다. 노드가 존재하지 않으면 "데이터 누락" 오류가 반환됩니다.

---
#### **7.6.8.  Usage Example**

다음 "리프" 문이 주어지면 이전에 정의된 "ssh" 컨테이너에 배치됩니다\(섹션 7.5.9 참조\).

```text
     leaf port {
       type inet:port-number;
       default 22;
       description
         "The port to which the SSH server listens.";
     }
```

해당 XML 인스턴스 예:

```text
     <port>2022</port>
```

<edit-config\>를 사용하여 리프 값을 설정하려면:

```text
     <rpc message-id="101"
          xmlns="urn:ietf:params:xml:ns:netconf:base:1.0"
          xmlns:nc="urn:ietf:params:xml:ns:netconf:base:1.0">
       <edit-config>
         <target>
           <running/>
         </target>
         <config>
           <system xmlns="urn:example:config">
             <services>
               <ssh>
                 <port>2022</port>
               </ssh>
             </services>
           </system>
         </config>
       </edit-config>
     </rpc>
```

---
### **7.7.  The "leaf-list" Statement**

"leaf" 문이 특정 유형의 간단한 스칼라 변수를 정의하는 데 사용되는 경우 "leaf-list" 문은 특정 유형의 배열을 정의하는 데 사용됩니다. "리프 목록" 문은 식별자인 하나의 인수를 취하고 그 뒤에 자세한 리프 목록 정보를 보유하는 하위 명령문 블록이 옵니다.

구성 데이터에서 리프 목록의 값은 고유해야 합니다.\(MUST\)

기본값의 정의는 "if-feature" 문으로 표시되어서는 안 됩니다.\(MUST NOT\)

개념적으로 데이터 트리의 값은 반드시 정규 형식이어야 합니다\(섹션 9.1 참조\).\(MUST\)

---
#### **7.7.1.  Ordering**

YANG은 목록과 리프 목록 내에서 항목을 정렬하는 두 가지 스타일을 지원합니다. 많은 목록에서 목록 항목의 순서는 목록 구성 구현에 영향을 주지 않으며 서버는 합리적인 순서로 목록 항목을 자유롭게 정렬할 수 있습니다. 목록의 "설명" 문자열은 서버 구현자에게 명령을 제안할 수 있습니다. YANG은 이러한 스타일의 목록을 "시스템 순서"라고 부릅니다. 이러한 목록은 "주문 시스템"이라는 문구로 표시됩니다.

예를 들어 유효한 사용자 목록은 일반적으로 알파벳순으로 정렬됩니다. 왜냐하면 구성에 사용자가 나타나는 순서는 해당 사용자의 계정 생성에 영향을 주지 않기 때문입니다.

다른 스타일의 목록에서는 목록 항목의 순서가 목록 구성 구현에 중요하며 사용자는 항목 순서를 지정해야 하며 서버는 해당 순서를 유지합니다. YANG은 이러한 스타일의 목록을 "사용자가 주문한" 목록이라고 부릅니다. 이러한 목록은 "사용자에 의해 주문됨"이라는 문구로 표시됩니다.

예를 들어 패킷 필터 항목이 들어오는 트래픽에 적용되는 순서는 해당 트래픽이 필터링되는 방식에 영향을 미칠 수 있습니다. 사용자는 모든 TCP 트래픽을 삭제하는 필터 항목을 신뢰할 수 있는 인터페이스의 모든 트래픽을 허용하는 필터 항목 앞이나 뒤에 적용해야 하는지 결정해야 합니다. 순서를 선택하는 것이 중요할 것입니다.

YANG은 NETCONF의 <edit-config\> 작업 내에서 사용자가 정렬한 목록의 목록 항목 순서를 제어할 수 있는 다양한 기능 세트를 제공합니다. 목록 항목은 삽입 또는 재배열될 수 있으며 목록의 첫 번째 또는 마지막 항목으로 배치되거나 다른 특정 항목 앞이나 뒤에 배치될 수 있습니다.

"ordered-by" 문은 섹션 7.7.7에서 다룹니다.

---
#### **7.7.2.  The leaf-list's Default Values**

리프 목록의 기본값은 리프 목록이 데이터 트리에 존재하지 않는 경우 서버가 사용하는 값입니다. 기본값의 사용법은 비존재 컨테이너가 아닌 스키마 트리에서 리프 목록의 가장 가까운 조상 노드에 따라 다릅니다\(섹션 7.5.1 참조\).

o 스키마 트리에 해당 조상이 없으면 기본값을 사용해야 합니다.\(MUST\)

o 그렇지 않은 경우, 이 조상이 사례 노드인 경우 사례의 노드가 데이터 트리에 존재하거나 사례 노드가 선택의 기본 사례이고 다른 사례의 노드가 데이터에 존재하지 않는 경우 기본값을 사용해야 합니다. 나무.\(MUST\)

o 그렇지 않은 경우 조상 노드가 데이터 트리에 존재하는 경우 기본값을 사용해야 합니다.\(MUST\)

이러한 경우 기본값이 사용 중이라고 합니다.

리프 목록 또는 해당 상위 항목에 "false"로 평가되는 "when" 조건 또는 "if-feature" 표현식이 있는 경우 기본값은 사용되지 않습니다.

기본값이 사용 중인 경우 서버는 마치 리프 목록이 기본값을 해당 값으로 사용하여 데이터 트리에 존재하는 것처럼 작동해야 합니다.\(MUST\)

리프 목록에 하나 이상의 "default" 문이 있는 경우 리프 목록의 기본값은 "default" 문 값이 되며, 리프 목록이 사용자 정렬된 경우에는 기본 값이 "기본" 문 순서대로 사용됩니다. "기본" 진술. 그렇지 않고 리프 목록의 유형에 기본값이 있고 리프 목록에 1보다 크거나 같은 값을 가진 "min-elements" 문이 없으면 리프 목록의 기본값은 해당 유형의 인스턴스 중 하나입니다. 기본값. 다른 모든 경우에는 리프 목록에 기본값이 없습니다.

---
#### **7.7.3.  The leaf-list's Substatements**

```text
                 +--------------+---------+-------------+
                 | substatement | section | cardinality |
                 +--------------+---------+-------------+
                 | config       | 7.21.1  | 0..1        |
                 | default      | 7.7.4   | 0..n        |
                 | description  | 7.21.3  | 0..1        |
                 | if-feature   | 7.20.2  | 0..n        |
                 | max-elements | 7.7.6   | 0..1        |
                 | min-elements | 7.7.5   | 0..1        |
                 | must         | 7.5.3   | 0..n        |
                 | ordered-by   | 7.7.7   | 0..1        |
                 | reference    | 7.21.4  | 0..1        |
                 | status       | 7.21.2  | 0..1        |
                 | type         | 7.4     | 1           |
                 | units        | 7.3.3   | 0..1        |
                 | when         | 7.21.5  | 0..1        |
                 +--------------+---------+-------------+
```

---
#### **7.7.4.  The leaf-list's "default" Statement**

선택 사항인 "default" 문은 리프 목록의 기본값이 포함된 문자열을 인수로 사용합니다.

"기본" 문의 값은 리프 목록의 "유형" 문에 지정된 유형에 따라 유효해야 합니다.\(MUST\)

"기본" 문은 "최소 요소"의 값이 1보다 크거나 같은 노드에 있어서는 안 됩니다.\(MUST NOT\)

---
#### **7.7.5.  The "min-elements" Statement**

선택 사항인 "min-elements" 문은 유효한 목록 항목에 제약을 가하는 음수가 아닌 정수를 인수로 사용합니다. 유효한 리프 목록 또는 목록에는 최소 요소 항목이 있어야 합니다.\(MUST\)

"min-elements" 문이 없으면 기본값은 0입니다.

제약 조건의 동작은 비존재 컨테이너가 아닌 스키마 트리에서 리프 목록 또는 목록의 가장 가까운 조상 노드의 유형에 따라 달라집니다\(섹션 7.5.1 참조\).

o 스키마 트리에 해당 조상이 없으면 제약 조건이 적용됩니다.

o 그렇지 않고 이 조상이 사례 노드인 경우 사례의 다른 노드가 존재하면 제약 조건이 적용됩니다.

o 그렇지 않은 경우 조상 노드가 존재하면 시행됩니다.

이 제약은 섹션 8의 규칙에 따라 추가로 시행됩니다.

---
#### **7.7.6.  The "max-elements" Statement**

선택 사항인 "max-elements" 문은 유효한 목록 항목에 제약을 두는 "unbounded" 문자열이나 양의 정수를 인수로 사용합니다. 유효한 리프 목록 또는 목록에는 항상 최대 최대 요소 항목이 있습니다.

"max-elements" 문이 없으면 기본값은 "unbounded"입니다.

"max-elements" 제약 조건은 섹션 8의 규칙에 따라 시행됩니다.

---
#### **7.7.7.  The "ordered-by" Statement**

"ordered-by" 문은 목록 내의 항목 순서가 사용자에 의해 결정되는지 아니면 시스템에 의해 결정되는지를 정의합니다. 인수는 "system" 또는 "user" 문자열 중 하나입니다. 존재하지 않는 경우 기본적으로 "시스템"으로 주문됩니다.

목록이 상태 데이터, RPC 출력 매개변수 또는 알림 내용을 나타내는 경우 이 문은 무시됩니다.

추가 정보는 섹션 7.7.1을 참조하십시오.

---
##### **7.7.7.1.  ordered-by system**

목록의 항목은 시스템에서 결정한 순서에 따라 정렬됩니다. 목록의 "설명" 문자열은 서버 구현자에게 명령을 제안할 수 있습니다. 그렇지 않은 경우 구현에서는 항목을 어떤 순서로든 자유롭게 정렬할 수 있습니다. 구현은 데이터 생성 방법에 관계없이 동일한 데이터에 대해 동일한 순서를 사용해야 합니다. 결정적 순서를 사용하면 "diff"와 같은 간단한 도구를 사용하여 비교가 가능해집니다.\(SHOULD\)

이것이 기본 순서입니다.

---
##### **7.7.7.2.  ordered-by user**

목록의 항목은 사용자가 정의한 순서에 따라 정렬됩니다. NETCONF에서 이 순서는 <edit-config\> 요청의 특수 XML 속성을 사용하여 제어됩니다. 자세한 내용은 섹션 7.7.9를 참조하세요.

---
#### **7.7.8.  XML Encoding Rules**

리프 목록 노드는 일련의 XML 요소로 인코딩됩니다. 각 요소의 로컬 이름은 리프 목록의 식별자이고 해당 네임스페이스는 모듈의 XML 네임스페이스입니다\(섹션 7.1.3 참조\).

각 리프 목록 항목의 값은 유형에 따라 XML로 인코딩되어 요소에 문자 데이터로 전송됩니다.

리프 목록 항목을 나타내는 XML 요소는 리프 목록이 "사용자에 의해 정렬"된 경우 사용자가 지정한 순서로 나타나야 합니다. 그렇지 않은 경우 순서는 구현에 따라 다릅니다. 리프 목록 항목을 나타내는 XML 요소는 리프 목록이 RPC 또는 작업 입력 또는 출력 매개 변수를 정의하지 않는 한 리프 목록의 형제 요소와 인터리브될 수 있습니다.\(MUST, MAY\)

예제는 섹션 7.7.10을 참조하세요.

---
#### **7.7.9.  NETCONF <edit-config> Operations**

리프 목록 항목은 리프 목록 항목의 XML 요소에 있는 "작업" 속성을 사용하여 <edit-config\>를 통해 생성 및 삭제할 수 있지만 수정할 수는 없습니다.

"사용자가 정렬한" 리프 목록에서 YANG XML 네임스페이스\(섹션 5.3.1\)의 "삽입" 및 "값" 속성을 사용하여 리프 목록에서 항목이 삽입되는 위치를 제어할 수 있습니다. 이는 "만들기" 작업 중에 새 리프 목록 항목을 삽입하거나 "병합" 또는 "교체" 작업 중에 새 리프 목록 항목을 삽입하거나 기존 항목을 이동하는 데 사용할 수 있습니다.

"insert" 속성은 "first", "last", "before" 및 "after" 값을 사용할 수 있습니다. 값이 "이전" 또는 "이후"인 경우 리프 목록의 기존 항목을 지정하는 데에도 "값" 속성을 사용해야 합니다.\(MUST\)

"create" 작업에 "insert" 속성이 없으면 기본값은 "last"입니다.

동일한 <edit-config\> 요청에서 "ordered-by user" 리프 목록의 여러 항목이 수정되는 경우 해당 항목은 요청의 XML 요소 순서에 따라 한 번에 하나씩 수정됩니다.

전체 리프 목록을 포괄하는 "교체" 작업이 포함된 <copy-config\> 또는 <edit-config\>에서 리프 목록 순서는 요청의 XML 요소 순서와 동일합니다.

NETCONF 서버가 <edit-config\> 요청을 처리할 때 리프 목록 노드에 대한 절차 요소는 다음과 같습니다.

o 작업이 "병합" 또는 "교체"인 경우 리프 목록 항목이 없으면 생성됩니다.

o 작업이 "생성"인 경우 리프 목록 항목이 없으면 생성됩니다. 리프 목록 항목이 이미 존재하는 경우 "data-exists" 오류가 반환됩니다.

o 작업이 "삭제"인 경우 해당 항목이 리프 목록에서 삭제됩니다. 리프 목록 항목이 없으면 "데이터 누락" 오류가 반환됩니다.

---
#### **7.7.10.  Usage Example**

```text
     leaf-list allow-user {
       type string;
       description
         "A list of user name patterns to allow.";
     }
```

해당 XML 인스턴스 예:

```text
     <allow-user>alice</allow-user>
     <allow-user>bob</allow-user>
```

기본 <edit-config\> 작업 "병합"을 사용하여 이 목록에 새 요소를 생성하려면:

```text
     <rpc message-id="101"
          xmlns="urn:ietf:params:xml:ns:netconf:base:1.0"
          xmlns:nc="urn:ietf:params:xml:ns:netconf:base:1.0">
       <edit-config>
         <target>
           <running/>
         </target>
         <config>
           <system xmlns="urn:example:config">
             <services>
               <ssh>
                 <allow-user>eric</allow-user>
               </ssh>
             </services>
           </system>
         </config>
       </edit-config>
     </rpc>
```

다음과 같이 정렬된 사용자 리프 목록이 제공됩니다.

```text
     leaf-list cipher {
       type string;
       ordered-by user;
       description
         "A list of ciphers.";
     }
```

다음은 "3des-cbc" 뒤에 새 암호 "blowfish-cbc"를 삽입하는 데 사용됩니다.

```text
     <rpc message-id="102"
          xmlns="urn:ietf:params:xml:ns:netconf:base:1.0"
          xmlns:nc="urn:ietf:params:xml:ns:netconf:base:1.0"
          xmlns:yang="urn:ietf:params:xml:ns:yang:1">
       <edit-config>
         <target>
           <running/>
         </target>
         <config>
           <system xmlns="urn:example:config">
             <services>
               <ssh>
                 <cipher nc:operation="create"
                         yang:insert="after"
                         yang:value="3des-cbc">blowfish-cbc</cipher>
               </ssh>
             </services>
           </system>
         </config>
       </edit-config>
     </rpc>
```

---
### **7.8.  The "list" Statement**

"list" 문은 스키마 트리에서 내부 데이터 노드를 정의하는 데 사용됩니다. 목록 노드는 데이터 트리의 여러 인스턴스에 존재할 수 있습니다. 이러한 각 인스턴스를 목록 항목이라고 합니다. "list" 문은 식별자인 하나의 인수를 취하고 그 뒤에 자세한 목록 정보를 보유하는 하위 문 블록이 옵니다.

목록 항목은 정의된 경우 목록의 키 값으로 고유하게 식별됩니다.

---
#### **7.8.1.  The list's Substatements**

```text
                 +--------------+---------+-------------+
                 | substatement | section | cardinality |
                 +--------------+---------+-------------+
                 | action       | 7.15    | 0..n        |
                 | anydata      | 7.10    | 0..n        |
                 | anyxml       | 7.11    | 0..n        |
                 | choice       | 7.9     | 0..n        |
                 | config       | 7.21.1  | 0..1        |
                 | container    | 7.5     | 0..n        |
                 | description  | 7.21.3  | 0..1        |
                 | grouping     | 7.12    | 0..n        |
                 | if-feature   | 7.20.2  | 0..n        |
                 | key          | 7.8.2   | 0..1        |
                 | leaf         | 7.6     | 0..n        |
                 | leaf-list    | 7.7     | 0..n        |
                 | list         | 7.8     | 0..n        |
                 | max-elements | 7.7.6   | 0..1        |
                 | min-elements | 7.7.5   | 0..1        |
                 | must         | 7.5.3   | 0..n        |
                 | notification | 7.16    | 0..n        |
                 | ordered-by   | 7.7.7   | 0..1        |
                 | reference    | 7.21.4  | 0..1        |
                 | status       | 7.21.2  | 0..1        |
                 | typedef      | 7.3     | 0..n        |
                 | unique       | 7.8.3   | 0..n        |
                 | uses         | 7.13    | 0..n        |
                 | when         | 7.21.5  | 0..1        |
                 +--------------+---------+-------------+
```

---
#### **7.8.2.  The list's "key" Statement**

목록이 구성을 나타내는 경우 반드시 있어야 하고 그렇지 않으면 존재할 수 있는 "키" 문은 이 목록의 하나 이상의 리프 식별자에 대한 공백으로 구분된 목록을 지정하는 문자열을 인수로 사용합니다. 리프 식별자는 키에 두 번 이상 나타나서는 안 됩니다. 각각의 리프 식별자는 목록의 하위 리프를 참조해야 합니다. 리프는 목록에 대한 하위 설명이나 목록에 사용되는 그룹화에서 직접 정의될 수 있습니다.\(MUST, MUST NOT, MUST\)

키에 지정된 모든 리프의 결합된 값은 목록 항목을 고유하게 식별하는 데 사용됩니다. 모든 키 리프에는 목록 항목이 생성될 때 값이 제공되어야 합니다. 따라서 키 리프의 기본값이나 해당 유형은 무시됩니다. 키 리프의 모든 "필수" 문은 무시됩니다.\(MUST\)

키의 일부인 리프는 기본 제공 유형이나 파생 유형일 수 있습니다.

목록의 모든 키 리프는 목록 자체와 "구성"에 대해 동일한 값을 가져야 합니다.\(MUST\)

키 문자열 구문은 섹션 14의 "key-arg" 규칙에 의해 공식적으로 정의됩니다.

---
#### **7.8.3.  The list's "unique" Statement**

"고유" 문은 유효한 목록 항목에 제약을 두는 데 사용됩니다. 이는 공백으로 구분된 스키마 노드 식별자 목록을 포함하는 문자열을 인수로 취하며, 이는 하위 형식으로 제공되어야 합니다\(섹션 14의 "descendant-schema-nodeid" 규칙 참조\). 이러한 각 스키마 노드 식별자는 리프를 참조해야 합니다.\(MUST, MUST\)

참조된 리프 중 하나가 구성 데이터를 나타내는 경우 참조된 리프 모두는 구성 데이터를 나타내야 합니다\(MUST\).\(MUST\)

"고유" 제약 조건은 기본값이 있는 리프를 포함하여 인수 문자열에 지정된 모든 리프 인스턴스의 결합된 값이 참조된 모든 리프가 존재하거나 기본값을 갖는 모든 목록 항목 인스턴스 내에서 고유해야 함을 지정합니다. 제약은 섹션 8의 규칙에 따라 시행됩니다.\(MUST\)

고유 문자열 구문은 섹션 14의 "unique-arg" 규칙에 의해 공식적으로 정의됩니다.

---
##### **7.8.3.1.  Usage Example**

다음 목록을 사용하세요.

```text
     list server {
       key "name";
       unique "ip port";
       leaf name {
         type string;
       }
       leaf ip {
         type inet:ip-address;
       }
       leaf port {
         type inet:port-number;
       }
     }
```

다음 구성은 유효하지 않습니다.

```text
     <server>
       <name>smtp</name>
       <ip>192.0.2.1</ip>
       <port>25</port>
     </server>

     <server>
       <name>http</name>
       <ip>192.0.2.1</ip>
       <port>25</port>
     </server>
```

"http" 및 "ftp" 목록 항목에는 참조된 모든 리프에 대한 값이 없으므로 "고유" 제약 조건이 적용될 때 고려되지 않으므로 다음 구성이 유효합니다.

```text
     <server>
       <name>smtp</name>
       <ip>192.0.2.1</ip>
       <port>25</port>
     </server>

     <server>
       <name>http</name>
       <ip>192.0.2.1</ip>
     </server>

     <server>
       <name>ftp</name>
       <ip>192.0.2.1</ip>
     </server>
```

---
#### **7.8.4.  The list's Child Node Statements**

목록 내에서 "container", "leaf", "list", "leaf-list", "uses", "choice", "anydata" 및 "anyxml" 문을 사용하여 목록에 대한 하위 노드를 정의할 수 있습니다. .

---
#### **7.8.5.  XML Encoding Rules**

목록은 목록의 각 항목에 대해 하나씩 일련의 XML 요소로 인코딩됩니다. 각 요소의 로컬 이름은 목록의 식별자이고 해당 네임스페이스는 모듈의 XML 네임스페이스입니다\(섹션 7.1.3 참조\). 목록 전체를 둘러싼 XML 요소는 없습니다.

목록의 키 노드는 "key" 문에 정의된 것과 동일한 순서로 목록의 식별자 요소에 대한 하위 요소로 인코딩됩니다.

목록의 나머지 하위 노드는 키 뒤의 목록 요소에 대한 하위 요소로 인코딩됩니다. 목록이 RPC나 작업 입력 또는 출력 매개변수를 정의하는 경우 하위 요소는 "list" 문 내에 정의된 것과 동일한 순서로 인코딩됩니다. 그렇지 않으면 하위 요소가 어떤 순서로든 인코딩됩니다.

목록 항목에 대한 하위 요소 사이의 공백은 중요하지 않습니다. 즉, 구현은 하위 요소 사이에 공백 문자를 삽입할 수 있습니다.\(MAY\)

목록 항목을 나타내는 XML 요소는 목록이 "사용자가 정렬"한 경우 사용자가 지정한 순서로 나타나야 합니다. 그렇지 않은 경우 순서는 구현에 따라 다릅니다. 목록 항목을 나타내는 XML 요소는 목록이 RPC 또는 작업 입력 또는 출력 매개변수를 정의하지 않는 한 목록의 형제 요소와 인터리브될 수 있습니다.\(MUST, MAY\)

---
#### **7.8.6.  NETCONF <edit-config> Operations**

목록 항목은 목록의 XML 요소에 있는 "작업" 속성을 사용하여 <edit-config\>를 통해 생성, 삭제, 교체 및 수정할 수 있습니다. 각 경우에 모든 키의 값은 목록 항목을 고유하게 식별하는 데 사용됩니다. 목록 항목에 모든 키가 지정되지 않은 경우 "요소 누락" 오류가 반환됩니다.

"정렬 기준 사용자" 목록에서 YANG XML 네임스페이스\(섹션 5.3.1\)의 "삽입" 및 "키" 속성을 사용하여 목록에서 항목이 삽입되는 위치를 제어할 수 있습니다. 이는 "만들기" 작업 중에 새 목록 항목을 삽입하거나 "병합" 또는 "교체" 작업 중에 새 목록 항목을 삽입하거나 기존 항목을 이동하는 데 사용할 수 있습니다.

"insert" 속성은 "first", "last", "before" 및 "after" 값을 사용할 수 있습니다. 값이 "이전" 또는 "이후"인 경우 목록의 기존 요소를 지정하기 위해 "키" 속성도 사용해야 합니다. "key" 속성의 값은 목록 항목에 대한 전체 인스턴스 식별자\(섹션 9.13 참조\)의 핵심 조건자입니다.\(MUST\)

"create" 작업에 "insert" 속성이 없으면 기본값은 "last"입니다.

동일한 <edit-config\> 요청에서 "ordered-by user" 목록의 여러 항목이 수정되면 해당 항목은 요청의 XML 요소 순서대로 한 번에 하나씩 수정됩니다.

전체 목록을 포함하는 "replace" 작업이 포함된 <copy-config\> 또는 <edit-config\>에서 목록 항목 순서는 요청의 XML 요소 순서와 동일합니다.

NETCONF 서버가 <edit-config\> 요청을 처리할 때 목록 노드에 대한 절차 요소는 다음과 같습니다.

o 작업이 "병합" 또는 "교체"인 경우 목록 항목이 없으면 생성됩니다. 목록 항목이 이미 존재하고 "삽입" 및 "키" 속성이 있는 경우 목록 항목은 "삽입" 및 "키" 속성 값에 따라 이동됩니다. 목록 항목이 존재하고 "삽입" 및 "키" 속성이 없으면 목록 항목이 이동되지 않습니다.

o 작업이 "생성"인 경우 목록 항목이 존재하지 않으면 생성됩니다. 목록 항목이 이미 존재하는 경우 "data-exists" 오류가 반환됩니다.

o 작업이 "삭제"인 경우 해당 항목이 있으면 목록에서 삭제됩니다. 목록 항목이 없으면 "데이터 누락" 오류가 반환됩니다.

---
#### **7.8.7.  Usage Example**

다음 목록이 주어졌습니다.

```text
     list user {
       key "name";
       config true;
       description
         "This is a list of users in the system.";

       leaf name {
         type string;
       }
       leaf type {
         type string;
       }
       leaf full-name {
         type string;
       }
     }
```

해당 XML 인스턴스 예:

```text
     <user>
       <name>fred</name>
       <type>admin</type>
       <full-name>Fred Flintstone</full-name>
     </user>
```

새 사용자 "barney"를 생성하려면:

```text
     <rpc message-id="101"
          xmlns="urn:ietf:params:xml:ns:netconf:base:1.0"
          xmlns:nc="urn:ietf:params:xml:ns:netconf:base:1.0">
       <edit-config>
         <target>
           <running/>
         </target>
         <config>
           <system xmlns="urn:example:config">
             <user nc:operation="create">
               <name>barney</name>
               <type>admin</type>
               <full-name>Barney Rubble</full-name>
             </user>
           </system>
         </config>
       </edit-config>
     </rpc>
```

"fred" 유형을 "superuser"로 변경하려면:

```text
     <rpc message-id="102"
          xmlns="urn:ietf:params:xml:ns:netconf:base:1.0"
          xmlns:nc="urn:ietf:params:xml:ns:netconf:base:1.0">
       <edit-config>
         <target>
           <running/>
         </target>
         <config>
           <system xmlns="urn:example:config">
             <user>
               <name>fred</name>
               <type>superuser</type>
             </user>
           </system>
         </config>
       </edit-config>
     </rpc>
```

다음과 같이 정렬된 사용자 목록이 제공됩니다.

```text
     list user {
       description
         "This is a list of users in the system.";
       ordered-by user;
       config true;

       key "first-name surname";

       leaf first-name {
         type string;
       }
       leaf surname {
         type string;
       }
       leaf type {
         type string;
       }
     }
```

다음은 사용자 "fred flintstone" 뒤에 새 사용자 "barney rubble"을 삽입하는 데 사용됩니다.

```text
     <rpc message-id="101"
          xmlns="urn:ietf:params:xml:ns:netconf:base:1.0"
          xmlns:nc="urn:ietf:params:xml:ns:netconf:base:1.0"
          xmlns:yang="urn:ietf:params:xml:ns:yang:1">
       <edit-config>
         <target>
           <running/>
         </target>
         <config>
           <system xmlns="urn:example:config"
                xmlns:ex="urn:example:config">
             <user nc:operation="create"
                   yang:insert="after"
                   yang:key="[ex:first-name='fred']
                             [ex:surname='flintstone']">
               <first-name>barney</first-name>
               <surname>rubble</surname>
               <type>admin</type>
             </user>
           </system>
         </config>
       </edit-config>
     </rpc>
```

다음은 "barney rubble" 사용자를 "fred flintstone" 사용자 앞으로 이동하는 데 사용됩니다.

```text
     <rpc message-id="102"
          xmlns="urn:ietf:params:xml:ns:netconf:base:1.0"
          xmlns:nc="urn:ietf:params:xml:ns:netconf:base:1.0"
          xmlns:yang="urn:ietf:params:xml:ns:yang:1">
       <edit-config>
         <target>
           <running/>
         </target>
         <config>
           <system xmlns="urn:example:config"
                xmlns:ex="urn:example:config">
             <user nc:operation="merge"
                   yang:insert="before"
                   yang:key="[ex:name='fred']
                             [ex:surname='flintstone']">
               <first-name>barney</first-name>
               <surname>rubble</surname>
             </user>
           </system>
         </config>
       </edit-config>
     </rpc>
```

---
### **7.9.  The "choice" Statement**

"선택" 문은 일련의 대안을 정의하며, 그 중 하나만 하나의 데이터 트리에 나타날 수 있습니다. 인수는 식별자이고 그 뒤에는 자세한 선택 정보를 담고 있는 하위 진술 블록이 옵니다. 식별자는 스키마 트리에서 선택 노드를 식별하는 데 사용됩니다. 데이터 트리에 선택 노드가 없습니다.

선택은 각각 "case" 하위 설명으로 정의된 여러 가지로 구성됩니다. 각 분기에는 여러 개의 하위 노드가 포함되어 있습니다. 선택한 분기 중 최대 하나의 노드가 동시에 존재합니다.

선택한 사례 중 하나만 데이터 트리에서 언제든지 유효할 수 있으므로 한 사례에서 노드를 생성하면 다른 모든 사례에서 모든 노드가 암시적으로 삭제됩니다. 요청이 케이스에서 노드를 생성하는 경우 서버는 선택 항목 내의 다른 케이스에 정의된 기존 노드를 삭제합니다.

---
#### **7.9.1.  The choice's Substatements**

```text
                 +--------------+---------+-------------+
                 | substatement | section | cardinality |
                 +--------------+---------+-------------+
                 | anydata      | 7.10    | 0..n        |
                 | anyxml       | 7.11    | 0..n        |
                 | case         | 7.9.2   | 0..n        |
                 | choice       | 7.9     | 0..n        |
                 | config       | 7.21.1  | 0..1        |
                 | container    | 7.5     | 0..n        |
                 | default      | 7.9.3   | 0..1        |
                 | description  | 7.21.3  | 0..1        |
                 | if-feature   | 7.20.2  | 0..n        |
                 | leaf         | 7.6     | 0..n        |
                 | leaf-list    | 7.7     | 0..n        |
                 | list         | 7.8     | 0..n        |
                 | mandatory    | 7.9.4   | 0..1        |
                 | reference    | 7.21.4  | 0..1        |
                 | status       | 7.21.2  | 0..1        |
                 | when         | 7.21.5  | 0..1        |
                 +--------------+---------+-------------+
```

---
#### **7.9.2.  The choice's "case" Statement**

"case" 문은 선택 항목을 정의하는 데 사용됩니다. 인수로 식별자를 취하고 그 뒤에는 자세한 사례 정보를 담고 있는 하위 진술 블록이 옵니다.

식별자는 스키마 트리에서 사례 노드를 식별하는 데 사용됩니다. 데이터 트리에 케이스 노드가 없습니다.

"case" 문 내에서 "anydata", "anyxml", "choice", "container", "leaf", "list", "leaf-list" 및 "uses" 문을 사용하여 하위 노드를 정의할 수 있습니다. 케이스 노드에. 이러한 모든 하위 노드의 식별자는 선택 항목의 모든 경우에서 고유해야 합니다. 예를 들어 다음은 불법입니다.\(MUST\)

```text
     choice interface-type {     // This example is illegal YANG
       case a {
         leaf ethernet { ... }
       }
       case b {
         container ethernet { ...}
       }
     }
```

간단히 말해서, 분기에 단일 "anydata", "anyxml", "choice", "container", "leaf", "list" 또는 "leaf-list" 문이 포함된 경우 "case" 문을 생략할 수 있습니다. 이 경우 케이스 노드는 스키마 트리에 계속 존재하며 해당 식별자는 하위 노드의 식별자와 동일합니다. 스키마 노드 식별자\(6.5절\)는 항상 사례 노드 식별자를 명시적으로 포함해야 합니다. 다음 예:\(MUST\)

```text
     choice interface-type {
       container ethernet { ... }
     }
```

다음과 같습니다:

```text
     choice interface-type {
       case ethernet {
         container ethernet { ... }
       }
     }
```

케이스 식별자는 선택 사항 내에서 고유해야 합니다.\(MUST\)

---
##### **7.9.2.1.  The case's Substatements**

```text
                 +--------------+---------+-------------+
                 | substatement | section | cardinality |
                 +--------------+---------+-------------+
                 | anydata      | 7.10    | 0..n        |
                 | anyxml       | 7.11    | 0..n        |
                 | choice       | 7.9     | 0..n        |
                 | container    | 7.5     | 0..n        |
                 | description  | 7.21.3  | 0..1        |
                 | if-feature   | 7.20.2  | 0..n        |
                 | leaf         | 7.6     | 0..n        |
                 | leaf-list    | 7.7     | 0..n        |
                 | list         | 7.8     | 0..n        |
                 | reference    | 7.21.4  | 0..1        |
                 | status       | 7.21.2  | 0..1        |
                 | uses         | 7.13    | 0..n        |
                 | when         | 7.21.5  | 0..1        |
                 +--------------+---------+-------------+
```

---
#### **7.9.3.  The choice's "default" Statement**

"기본값" 문은 선택한 사례의 하위 노드가 존재하지 않는 경우 해당 사례를 기본값으로 간주해야 하는지 여부를 나타냅니다. 인수는 기본 "case" 문의 식별자입니다. "default" 문이 누락된 경우 기본 사례가 없습니다.

"필수"가 "true"인 선택 항목에는 "기본" 문이 있어서는 안 됩니다.\(MUST NOT\)

기본 사례는 사례 아래에 있는 노드의 "기본" 설명\(즉, 리프 및 리프 목록의 기본값 및 중첩 선택의 기본 사례\)을 고려할 때만 중요합니다. 기본 케이스 아래에 중첩된 기본 케이스와 기본값은 케이스 아래에 노드가 하나도 없는 경우 사용됩니다.

기본 사례 바로 아래에 필수 노드\(섹션 3\)가 있어서는 안 됩니다.\(MUST NOT\)

케이스 아래의 하위 노드에 대한 기본값은 해당 케이스 아래의 노드 중 하나가 있거나 해당 케이스가 기본 케이스인 경우에만 사용됩니다. 케이스 아래 노드가 하나도 없고 케이스가 기본 케이스가 아닌 경우 케이스 하위 노드의 기본값은 무시됩니다.

이 예에서 선택 항목의 기본값은 "간격"이며, "매일", "시간" 또는 "수동"이 없으면 기본값이 사용됩니다. "daily"가 있으면 "time-of-day"의 기본값이 사용됩니다.

```text
     container transfer {
       choice how {
         default interval;
         case interval {
           leaf interval {
             type uint16;
             units minutes;
             default 30;
           }
         }
         case daily {
           leaf daily {
             type empty;
           }
           leaf time-of-day {
             type string;
             units 24-hour-clock;
             default "01.00";
           }
         }
         case manual {
           leaf manual {
             type empty;
           }
         }
       }
     }
```

---
#### **7.9.4.  The choice's "mandatory" Statement**

선택 사항인 "필수" 문은 "true" 또는 "false" 문자열을 인수로 사용하고 유효한 데이터에 제약 조건을 적용합니다. "mandatory"가 "true"인 경우 선택한 사례 분기 중 정확히 하나에서 최소한 하나의 노드가 존재해야 합니다.\(MUST\)

지정하지 않으면 기본값은 "false"입니다.

제약 조건의 동작은 비존재 컨테이너가 아닌 스키마 트리에서 선택 항목의 가장 가까운 조상 노드의 유형에 따라 달라집니다\(섹션 7.5.1 참조\).

o 스키마 트리에 해당 조상이 없으면 제약 조건이 적용됩니다.

o 그렇지 않고 이 조상이 사례 노드인 경우 사례의 다른 노드가 존재하면 제약 조건이 적용됩니다.

o 그렇지 않은 경우 조상 노드가 존재하면 시행됩니다.

이 제약은 섹션 8의 규칙에 따라 추가로 시행됩니다.

---
#### **7.9.5.  XML Encoding Rules**

선택 및 사례 노드는 XML에 표시되지 않습니다.

선택한 "case" 문의 하위 노드는 RPC나 작업 입력 또는 출력 매개변수 정의의 일부인 경우 "case" 문에 정의된 것과 동일한 순서로 인코딩되어야 합니다. 그렇지 않으면 하위 요소가 어떤 순서로든 인코딩됩니다.\(MUST\)

---
#### **7.9.6.  Usage Example**

다음과 같은 선택이 주어졌습니다.

```text
     container protocol {
       choice name {
         case a {
           leaf udp {
             type empty;
           }
         }
         case b {
           leaf tcp {
             type empty;
           }
         }
       }
     }
```

해당 XML 인스턴스 예:

```text
     <protocol>
       <tcp/>
     </protocol>
```

프로토콜을 TCP에서 UDP로 변경하려면:

```text
     <rpc message-id="101"
          xmlns="urn:ietf:params:xml:ns:netconf:base:1.0"
          xmlns:nc="urn:ietf:params:xml:ns:netconf:base:1.0">
       <edit-config>
         <target>
           <running/>
         </target>
         <config>
           <system xmlns="urn:example:config">
             <protocol>
               <udp nc:operation="create"/>
             </protocol>
           </system>
         </config>
       </edit-config>
     </rpc>
```

---
### **7.10.  The "anydata" Statement**

"anydata" 문은 스키마 트리의 내부 노드를 정의합니다. 이는 식별자인 하나의 인수를 취하고 그 뒤에는 자세한 모든 데이터 정보를 보유하는 하위 명령문 블록이 옵니다.

"anydata" 문은 anyxml을 제외하고 YANG으로 모델링할 수 있지만 모듈 설계 시에는 데이터 모델이 알려지지 않은 알 수 없는 노드 집합을 나타내는 데 사용됩니다. 필수는 아니지만 모든 데이터 콘텐츠에 대한 데이터 모델이 프로토콜 신호 또는 이 문서의 범위를 벗어나는 기타 수단을 통해 알려지는 것이 가능합니다.

anydata가 유용할 수 있는 예는 디자인 타임에 특정 알림이 알려지지 않은 수신된 알림 목록입니다.

anydata 노드는 확장될 수 없습니다\(섹션 7.17 참조\).

anydata 노드는 데이터 트리의 인스턴스 0개 또는 1개에 존재합니다.

구현은 anydata 노드의 특정 인스턴스를 모델링하는 데 사용되는 데이터 모델을 알 수도 있고 모를 수도 있습니다.

anydata를 사용하면 콘텐츠 조작이 제한되므로 "anydata" 문을 사용하여 구성 데이터를 정의하면 안 됩니다.\(SHOULD NOT\)

---
#### **7.10.1.  The anydata's Substatements**

```text
                 +--------------+---------+-------------+
                 | substatement | section | cardinality |
                 +--------------+---------+-------------+
                 | config       | 7.21.1  | 0..1        |
                 | description  | 7.21.3  | 0..1        |
                 | if-feature   | 7.20.2  | 0..n        |
                 | mandatory    | 7.6.5   | 0..1        |
                 | must         | 7.5.3   | 0..n        |
                 | reference    | 7.21.4  | 0..1        |
                 | status       | 7.21.2  | 0..1        |
                 | when         | 7.21.5  | 0..1        |
                 +--------------+---------+-------------+
```

---
#### **7.10.2.  XML Encoding Rules**

anydata 노드는 XML 요소로 인코딩됩니다. 요소의 로컬 이름은 anydata의 식별자이고 해당 네임스페이스는 모듈의 XML 네임스페이스입니다\(섹션 7.1.3 참조\). anydata 노드의 값은 anydata 요소에 대한 XML 하위 요소로 인코딩된 노드 집합입니다.

---
#### **7.10.3.  NETCONF <edit-config> Operations**

anydata 노드는 불투명한 데이터 덩어리로 처리됩니다. 이 데이터는 전체적으로만 수정할 수 있습니다.

anydata 노드의 하위 요소에 있는 모든 "작업" 속성은 NETCONF 서버에서 무시됩니다.

NETCONF 서버가 <edit-config\> 요청을 처리할 때 anydata 노드에 대한 절차 요소는 다음과 같습니다.

o 작업이 "병합" 또는 "교체"인 경우 노드가 없으면 생성되고 해당 값은 XML RPC 데이터에 있는 anydata 노드의 하위 요소로 설정됩니다.

o 작업이 "create"인 경우 노드가 없으면 생성되고 해당 값은 XML RPC 데이터에 있는 anydata 노드의 하위 요소로 설정됩니다. 노드가 이미 존재하는 경우 "data-exists" 오류가 반환됩니다.

o 작업이 "삭제"인 경우 노드가 있으면 삭제됩니다. 노드가 존재하지 않으면 "데이터 누락" 오류가 반환됩니다.

---
#### **7.10.4.  Usage Example**

다음과 같은 "anydata" 문이 있다고 가정해 보겠습니다.

```text
     list logged-notification {
       key time;
       leaf time {
         type yang:date-and-time;
       }
       anydata data;
     }
```

다음은 이러한 목록 인스턴스의 유효한 인코딩입니다.

```text
     <logged-notification>
       <time>2014-07-29T13:43:12Z</time>
       <data>
         <notification
           xmlns="urn:ietf:params:xml:ns:netconf:notification:1.0">
           <eventTime>2014-07-29T13:43:01Z</eventTime>
           <event xmlns="urn:example:event">
             <event-class>fault</event-class>
             <reporting-entity>
               <card>Ethernet0</card>
             </reporting-entity>
             <severity>major</severity>
           </event>
         </notification>
       </data>
     </logged-notification>
```

---
### **7.11.  The "anyxml" Statement**

"anyxml" 문은 스키마 트리의 내부 노드를 정의합니다. 이는 식별자인 하나의 인수를 취하고 그 뒤에 자세한 anyxml 정보를 보유하는 하위 명령문 블록이 옵니다.

"anyxml" 문은 알 수 없는 XML 청크를 나타내는 데 사용됩니다. XML에는 제한이 없습니다. 이는 예를 들어 RPC 응답에 유용할 수 있습니다. NETCONF의 <get-config\> 작업에 있는 <filter\> 매개변수를 예로 들 수 있습니다.

anyxml 노드는 확장될 수 없습니다\(섹션 7.17 참조\).

anyxml 노드는 데이터 트리의 인스턴스 0개 또는 1개에 존재합니다.

anyxml을 사용하면 콘텐츠 조작이 제한되므로 구성 데이터를 정의하는 데 "anyxml" 문을 사용하면 안 됩니다.\(SHOULD NOT\)

YANG 버전 1에서는 "anyxml"이 알려지지 않은 데이터 계층 구조를 모델링할 수 있는 유일한 문이라는 점에 유의해야 합니다. 많은 경우 이러한 알려지지 않은 데이터 계층은 실제로 YANG에서 모델링되지만 특정 YANG 데이터 모델은 디자인 타임에 알려지지 않습니다. 이러한 상황에서는 "anyxml" 대신 "anydata"\(섹션 7.10\)를 사용하는 것이 좋습니다.\(SHOULD\)

---
#### **7.11.1.  The anyxml's Substatements**

```text
                 +--------------+---------+-------------+
                 | substatement | section | cardinality |
                 +--------------+---------+-------------+
                 | config       | 7.21.1  | 0..1        |
                 | description  | 7.21.3  | 0..1        |
                 | if-feature   | 7.20.2  | 0..n        |
                 | mandatory    | 7.6.5   | 0..1        |
                 | must         | 7.5.3   | 0..n        |
                 | reference    | 7.21.4  | 0..1        |
                 | status       | 7.21.2  | 0..1        |
                 | when         | 7.21.5  | 0..1        |
                 +--------------+---------+-------------+
```

---
#### **7.11.2.  XML Encoding Rules**

anyxml 노드는 XML 요소로 인코딩됩니다. 요소의 로컬 이름은 anyxml의 식별자이고 해당 네임스페이스는 모듈의 XML 네임스페이스입니다\(섹션 7.1.3 참조\). anyxml 노드의 값은 이 요소의 XML 콘텐츠로 인코딩됩니다.

인코딩에 사용된 모든 XML 접두사는 각 인스턴스 인코딩에 국한됩니다. 이는 동일한 XML이 구현에 따라 다르게 인코딩될 수 있음을 의미합니다.

---
#### **7.11.3.  NETCONF <edit-config> Operations**

anyxml 노드는 불투명한 데이터 덩어리로 처리됩니다. 이 데이터는 전체적으로만 수정할 수 있습니다.

anyxml 노드의 하위 요소에 있는 모든 "작업" 속성은 NETCONF 서버에서 무시됩니다.

NETCONF 서버가 <edit-config\> 요청을 처리할 때 anyxml 노드에 대한 절차 요소는 다음과 같습니다.

o 작업이 "병합" 또는 "교체"인 경우 노드가 없으면 생성되고 해당 값은 XML RPC 데이터에서 찾은 anyxml 노드의 XML 콘텐츠로 설정됩니다.

o 작업이 "create"인 경우 노드가 없으면 생성되고 해당 값은 XML RPC 데이터에 있는 anyxml 노드의 XML 콘텐츠로 설정됩니다. 노드가 이미 존재하는 경우 "data-exists" 오류가 반환됩니다.

o 작업이 "삭제"인 경우 노드가 있으면 삭제됩니다. 노드가 존재하지 않으면 "데이터 누락" 오류가 반환됩니다.

---
#### **7.11.4.  Usage Example**

다음 "anyxml" 문이 있다고 가정해 보겠습니다.

```text
     anyxml html-info;
```

다음은 동일한 anyxml 값에 대한 두 가지 유효한 인코딩입니다.

<html-정보\>

- <p xmlns="http://www.w3.org/1999/xhtml"\> 이거 <em\>매우</em\> 멋지네요. </p\> </html-정보\>

<html-정보\>

- <x:p xmlns:x="http://www.w3.org/1999/xhtml"\> 이거 <x:em\>매우</x:em\> 멋지네요. </x:p\> </html-정보\>

---
### **7.12.  The "grouping" Statement**

"그룹화" 문은 섹션 5.5의 규칙에 따라 모듈이나 하위 모듈에서 로컬로 사용할 수 있고 여기에서 가져오는 다른 모듈에서 사용할 수 있는 재사용 가능한 노드 블록을 정의하는 데 사용됩니다. 이는 식별자인 하나의 인수를 취하고 그 뒤에 자세한 그룹화 정보를 보유하는 하위 명령문 블록이 옵니다.

"그룹화" 문은 데이터 정의 문이 아니므로 스키마 트리의 노드를 정의하지 않습니다.

그룹화는 기존 프로그래밍 언어의 "구조" 또는 "레코드"와 같습니다.

그룹화가 정의되면 "uses" 문에서 참조할 수 있습니다\(섹션 7.13 참조\). 그룹화는 다른 그룹화의 체인을 통해 직접적이든 간접적이든 자신을 참조해서는 안 됩니다.\(MUST NOT\)

그룹화가 YANG 모듈 또는 하위 모듈의 최상위 수준에서 정의된 경우 그룹화의 식별자는 모듈 내에서 고유해야 합니다.\(MUST\)

그룹화는 단순한 텍스트 대체 메커니즘 그 이상입니다. 또한 노드 컬렉션을 정의합니다. 그룹화 내부에 나타나는 식별자는 그룹화가 사용되는 위치가 아니라 정의된 범위를 기준으로 확인됩니다. 접두사 매핑, 유형 이름, 그룹화 이름 및 확장 사용은 계층 구조에서 평가됩니다.

여기서 "그룹화" 문이 나타납니다. 확장의 경우 이는 "그룹화" 문에 대한 직계 하위 항목으로 정의된 확장이 그룹화 자체에 적용됨을 의미합니다.

그룹화가 계층 구조에서 작업이나 알림 노드를 정의하는 경우 모든 컨텍스트에서 사용할 수는 없습니다. 예를 들어 rpc 정의에서는 사용할 수 없습니다. 섹션 7.15 및 7.16을 참조하십시오.

---
#### **7.12.1.  The grouping's Substatements**

```text
                 +--------------+---------+-------------+
                 | substatement | section | cardinality |
                 +--------------+---------+-------------+
                 | action       | 7.15    | 0..n        |
                 | anydata      | 7.10    | 0..n        |
                 | anyxml       | 7.11    | 0..n        |
                 | choice       | 7.9     | 0..n        |
                 | container    | 7.5     | 0..n        |
                 | description  | 7.21.3  | 0..1        |
                 | grouping     | 7.12    | 0..n        |
                 | leaf         | 7.6     | 0..n        |
                 | leaf-list    | 7.7     | 0..n        |
                 | list         | 7.8     | 0..n        |
                 | notification | 7.16    | 0..n        |
                 | reference    | 7.21.4  | 0..1        |
                 | status       | 7.21.2  | 0..1        |
                 | typedef      | 7.3     | 0..n        |
                 | uses         | 7.13    | 0..n        |
                 +--------------+---------+-------------+
```

---
#### **7.12.2.  Usage Example**

```text
     import ietf-inet-types {
       prefix "inet";
     }

     grouping endpoint {
       description "A reusable endpoint group.";
       leaf ip {
         type inet:ip-address;
       }
       leaf port {
         type inet:port-number;
       }
     }
```

---
### **7.13.  The "uses" Statement**

"uses" 문은 "그룹화" 정의를 참조하는 데 사용됩니다. 그룹화의 이름인 하나의 인수를 사용합니다.

그룹화에 대한 "사용" 참조의 효과는 그룹화에 의해 정의된 노드가 현재 스키마 트리에 복사된 다음 "정제" 및 "증강" 문에 따라 업데이트된다는 것입니다.

그룹화에 정의된 식별자는 "그룹화" 문 내부에 나타나지 않는 "uses" 문을 통해 그룹화 내용이 스키마 트리에 추가될 때까지 네임스페이스에 바인딩되지 않으며, 이 시점에서 네임스페이스에 바인딩됩니다. 현재 모듈의.

---
#### **7.13.1.  The uses's Substatements**

```text
                 +--------------+---------+-------------+
                 | substatement | section | cardinality |
                 +--------------+---------+-------------+
                 | augment      | 7.17    | 0..n        |
                 | description  | 7.21.3  | 0..1        |
                 | if-feature   | 7.20.2  | 0..n        |
                 | reference    | 7.21.4  | 0..1        |
                 | refine       | 7.13.2  | 0..n        |
                 | status       | 7.21.2  | 0..1        |
                 | when         | 7.21.5  | 0..1        |
                 +--------------+---------+-------------+
```

---
#### **7.13.2.  The "refine" Statement**

그룹화에 있는 각 노드의 속성 중 일부는 "refine" 문을 사용하여 구체화할 수 있습니다. 인수는 그룹화에서 노드를 식별하는 문자열입니다. 이 노드를 구체화의 대상 노드라고 합니다. 그룹화의 노드가 "refine" 문의 대상 노드로 존재하지 않으면 구체화되지 않으므로 그룹화에 정의된 대로 정확하게 사용됩니다.

인수 문자열은 하위 스키마 노드 식별자입니다\(섹션 6.5 참조\).

다음과 같은 개선 작업을 수행할 수 있습니다.

o 리프 또는 선택 노드는 기본값을 얻을 수 있으며, 이미 기본값이 있는 경우 새 기본값을 얻을 수 있습니다.

o 리프 목록 노드는 기본값 세트를 얻을 수 있으며, 이미 기본값이 있는 경우 새로운 기본값 세트를 얻을 수 있습니다. 즉, 세련된 기본값 세트가 이미 제공된 기본값을 대체합니다.

o 모든 노드는 특수한 "설명" 문자열을 얻을 수 있습니다.

o 모든 노드는 특수한 "참조" 문자열을 얻을 수 있습니다.

o 모든 노드는 다른 "config" 문을 얻을 수 있습니다.

o 리프, anydata, anyxml 또는 선택 노드는 다른 "필수" 문을 가질 수 있습니다.

o 컨테이너 노드는 "존재" 진술을 얻을 수 있습니다.

o 리프, 리프 목록, 목록, 컨테이너, anydata 또는 anyxml 노드는 추가 "필수" 표현식을 얻을 수 있습니다.

o 리프 목록 또는 목록 노드는 다른 "최소 요소" 또는 "최대 요소" 문을 얻을 수 있습니다.

o 리프, 리프 목록, 목록, 컨테이너, 선택, 케이스, anydata 또는 anyxml 노드는 추가 "if-feature" 표현식을 얻을 수 있습니다.

o 확장이 개선을 허용하는 경우 모든 노드는 개선된 확장을 얻을 수 있습니다. 자세한 내용은 섹션 7.19를 참조하세요.

---
#### **7.13.3.  XML Encoding Rules**

그룹화의 각 노드는 다른 XML 네임스페이스가 있는 다른 모듈에서 가져온 경우에도 인라인으로 정의된 것처럼 인코딩됩니다.

---
#### **7.13.4.  Usage Example**

다른 모듈의 HTTP 서버 정의에서 섹션 7.12.2에 정의된 "종점" 그룹화를 사용하려면 다음을 수행할 수 있습니다.

```text
     import example-system {
       prefix "sys";
     }

     container http-server {
       leaf name {
         type string;
       }
       uses sys:endpoint;
     }
```

해당 XML 인스턴스 예:

```text
     <http-server>
       <name>extern-web</name>
       <ip>192.0.2.1</ip>
       <port>80</port>
     </http-server>
```

포트 80이 HTTP 서버의 기본값이어야 하는 경우 기본값을 추가할 수 있습니다.

```text
     container http-server {
       leaf name {
         type string;
       }
       uses sys:endpoint {
         refine port {
           default 80;
         }
       }
     }
```

서버 목록을 정의하고 각 서버에 키로 "ip"와 "port"가 있는 경우 다음을 수행할 수 있습니다.

```text
     list server {
       key "ip port";
       leaf name {
         type string;
       }
       uses sys:endpoint;
     }
```

다음은 오류입니다.

```text
     container http-server {
       uses sys:endpoint;
       leaf ip {          // illegal - same identifier "ip" used twice
         type string;
       }
     }
```

---
### **7.14.  The "rpc" Statement**

"rpc" 문은 RPC 작업을 정의하는 데 사용됩니다. 이는 식별자인 하나의 인수를 취하고 그 뒤에 자세한 rpc 정보를 보유하는 하위 명령문 블록이 옵니다. 이 인수는 RPC의 이름입니다.

"rpc" 문은 스키마 트리의 rpc 노드를 정의합니다. rpc 노드 아래에는 "input"이라는 이름의 스키마 노드와 "output"이라는 이름의 스키마 노드도 정의됩니다. "입력" 및 "출력" 노드는 모듈의 네임스페이스에 정의됩니다.

---
#### **7.14.1.  The rpc's Substatements**

```text
                 +--------------+---------+-------------+
                 | substatement | section | cardinality |
                 +--------------+---------+-------------+
                 | description  | 7.21.3  | 0..1        |
                 | grouping     | 7.12    | 0..n        |
                 | if-feature   | 7.20.2  | 0..n        |
                 | input        | 7.14.2  | 0..1        |
                 | output       | 7.14.3  | 0..1        |
                 | reference    | 7.21.4  | 0..1        |
                 | status       | 7.21.2  | 0..1        |
                 | typedef      | 7.3     | 0..n        |
                 +--------------+---------+-------------+
```

---
#### **7.14.2.  The "input" Statement**

선택적인 "input" 문은 작업에 대한 입력 매개변수를 정의하는 데 사용됩니다. 논쟁이 필요하지 않습니다. "입력"하는 하위 명령문은 연산의 입력 노드 아래에 있는 노드를 정의합니다.

입력 트리의 리프에 값이 "true"인 "필수" 문이 있는 경우 해당 리프는 RPC 호출에 있어야 합니다.\(MUST\)

입력 트리의 리프에 기본값이 있는 경우 서버는 섹션 7.6.1에 설명된 것과 동일한 경우에 이 값을 사용해야 합니다. 이러한 경우 서버는 마치 리프가 기본값을 해당 값으로 사용하여 RPC 호출에 존재하는 것처럼 작동해야 합니다.\(MUST, MUST\)

입력 트리의 리프 목록에 하나 이상의 기본값이 있는 경우 서버는 섹션 7.7.2에 설명된 것과 동일한 경우에 이러한 값을 사용해야 합니다. 이러한 경우 서버는 마치 기본값을 해당 값으로 사용하여 RPC 호출에 리프 목록이 있는 것처럼 작동해야 합니다.\(MUST, MUST\)

입력 트리는 데이터 저장소의 일부가 아니므로 입력 트리의 노드에 대한 모든 "config" 문은 무시됩니다.

노드에 "false"로 평가되는 "when" 문이 있는 경우 이 노드는 입력 트리에 있어서는 안 됩니다.\(MUST NOT\)

---
##### **7.14.2.1.  The input's Substatements**

```text
                 +--------------+---------+-------------+
                 | substatement | section | cardinality |
                 +--------------+---------+-------------+
                 | anydata      | 7.10    | 0..n        |
                 | anyxml       | 7.11    | 0..n        |
                 | choice       | 7.9     | 0..n        |
                 | container    | 7.5     | 0..n        |
                 | grouping     | 7.12    | 0..n        |
                 | leaf         | 7.6     | 0..n        |
                 | leaf-list    | 7.7     | 0..n        |
                 | list         | 7.8     | 0..n        |
                 | must         | 7.5.3   | 0..n        |
                 | typedef      | 7.3     | 0..n        |
                 | uses         | 7.13    | 0..n        |
                 +--------------+---------+-------------+
```

---
#### **7.14.3.  The "output" Statement**

선택 사항인 "output" 문은 RPC 작업에 대한 출력 매개 변수를 정의하는 데 사용됩니다. 논쟁이 필요하지 않습니다. "출력"하는 하위 명령문은 작업의 출력 노드 아래에 있는 노드를 정의합니다.

출력 트리의 리프에 값이 "true"인 "필수" 문이 있는 경우 리프는 RPC 응답에 있어야 합니다.\(MUST\)

출력 트리의 리프에 기본값이 있는 경우 클라이언트는 섹션 7.6.1에 설명된 것과 동일한 경우에 이 값을 사용해야 합니다. 이러한 경우 클라이언트는 마치 리프가 기본값을 해당 값으로 사용하여 RPC 응답에 존재하는 것처럼 작동해야 합니다.\(MUST, MUST\)

출력 트리의 리프 목록에 하나 이상의 기본값이 있는 경우 클라이언트는 섹션 7.7.2에 설명된 것과 동일한 경우에 이러한 값을 사용해야 합니다. 이러한 경우 클라이언트는 마치 기본값을 해당 값으로 사용하여 RPC 응답에 리프 목록이 있는 것처럼 작동해야 합니다.\(MUST, MUST\)

출력 트리는 데이터 저장소의 일부가 아니므로 출력 트리의 노드에 대한 모든 "config" 문은 무시됩니다.

노드에 "false"로 평가되는 "when" 문이 있는 경우 이 노드는 출력 트리에 있어서는 안 됩니다.\(MUST NOT\)

---
##### **7.14.3.1.  The output's Substatements**

```text
                 +--------------+---------+-------------+
                 | substatement | section | cardinality |
                 +--------------+---------+-------------+
                 | anydata      | 7.10    | 0..n        |
                 | anyxml       | 7.11    | 0..n        |
                 | choice       | 7.9     | 0..n        |
                 | container    | 7.5     | 0..n        |
                 | grouping     | 7.12    | 0..n        |
                 | leaf         | 7.6     | 0..n        |
                 | leaf-list    | 7.7     | 0..n        |
                 | list         | 7.8     | 0..n        |
                 | must         | 7.5.3   | 0..n        |
                 | typedef      | 7.3     | 0..n        |
                 | uses         | 7.13    | 0..n        |
                 +--------------+---------+-------------+
```

---
#### **7.14.4.  NETCONF XML Encoding Rules**

rpc 노드는 \[RFC6241\]의 대체 그룹 "rpcOperation"에 지정된 대로 <rpc\> 요소에 대한 하위 XML 요소로 인코딩됩니다. 요소의 로컬 이름은 rpc의 식별자이고 해당 네임스페이스는 모듈의 XML 네임스페이스입니다\(섹션 7.1.3 참조\).

입력 매개변수는 "input" 문 내에 정의된 것과 동일한 순서로 rpc 노드의 XML 요소에 대한 하위 XML 요소로 인코딩됩니다.

RPC 작업 호출이 성공하고 출력 매개변수가 반환되지 않으면 <rpc-reply\>에는 \[RFC6241\]에 정의된 단일 <ok/\> 요소가 포함됩니다. 출력 매개변수가 반환되면 "output" 문에 정의된 것과 동일한 순서로 \[RFC6241\]에 정의된 <rpc-reply\> 요소에 대한 하위 요소로 인코딩됩니다.

---
#### **7.14.5.  Usage Example**

다음 예에서는 RPC 작업을 정의합니다.

```text
     module example-rock {
       yang-version 1.1;
       namespace "urn:example:rock";
       prefix "rock";

       rpc rock-the-house {
         input {
           leaf zip-code {
             type string;
           }
         }
       }
     }
```

완전한 rpc 및 rpc-reply의 해당 XML 인스턴스 예:

```text
     <rpc message-id="101"
          xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
       <rock-the-house xmlns="urn:example:rock">
         <zip-code>27606-0100</zip-code>
       </rock-the-house>
     </rpc>

     <rpc-reply message-id="101"
                xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
       <ok/>
     </rpc-reply>
```

---
### **7.15.  The "action" Statement**

"action" 문은 특정 컨테이너 또는 목록 데이터 노드에 연결된 작업을 정의하는 데 사용됩니다. 이는 식별자인 하나의 인수를 취하고 그 뒤에 자세한 작업 정보를 보유하는 하위 명령문 블록이 옵니다. 인수는 작업의 이름입니다.

"action" 문은 스키마 트리의 작업 노드를 정의합니다. 작업 노드 아래에는 "input"이라는 이름의 스키마 노드와 "output"이라는 이름의 스키마 노드도 정의됩니다. "입력" 및 "출력" 노드는 모듈의 네임스페이스에 정의됩니다.

작업은 rpc, 다른 작업 또는 알림 내에서 정의되어서는 안 됩니다. 즉, 작업 노드는 스키마 트리의 상위 항목 중 하나로 rpc, 작업 또는 알림 노드를 가져서는 안 됩니다. 예를 들어, 노드 계층 어딘가에 작업을 포함하는 그룹이 알림 정의에 사용되면 오류가 발생한다는 의미입니다.\(MUST NOT\)

작업에는 "키" 문이 없는 목록 노드인 조상 노드가 있어서는 안 됩니다.\(MUST NOT\)

작업은 모듈의 최상위 수준이나 "case" 문에서 정의될 수 없으므로 노드 계층 구조의 최상위에 있는 작업을 포함하는 그룹화가 모듈의 최상위 수준이나 "case" 문에서 사용되는 경우 오류가 발생합니다. 사례 정의.

작업과 rpc의 차이점은 작업이 데이터 저장소의 노드에 연결되어 있는 반면 rpc는 그렇지 않다는 것입니다. 작업이 호출되면 데이터 저장소의 노드가 작업 이름 및 입력 매개변수와 함께 지정됩니다.

---
#### **7.15.1.  The action's Substatements**

```text
                 +--------------+---------+-------------+
                 | substatement | section | cardinality |
                 +--------------+---------+-------------+
                 | description  | 7.21.3  | 0..1        |
                 | grouping     | 7.12    | 0..n        |
                 | if-feature   | 7.20.2  | 0..n        |
                 | input        | 7.14.2  | 0..1        |
                 | output       | 7.14.3  | 0..1        |
                 | reference    | 7.21.4  | 0..1        |
                 | status       | 7.21.2  | 0..1        |
                 | typedef      | 7.3     | 0..n        |
                 +--------------+---------+-------------+
```

---
#### **7.15.2.  NETCONF XML Encoding Rules**

작업이 호출되면 네임스페이스 "urn:ietf:params:xml:ns:yang:1"\(섹션 5.3.1 참조\)에서 로컬 이름 "action"을 가진 요소는 <에 대한 하위 XML 요소로 인코딩됩니다. \[RFC6241\]의 대체 그룹 "rpcOperation"에 의해 지정된 대로 \[RFC6241\]에 정의된 rpc\> 요소입니다.

<action\> 요소에는 데이터 저장소의 노드를 식별하는 노드 계층 구조가 포함되어 있습니다. 여기에는 최상위 수준에서 작업이 포함된 목록 또는 컨테이너까지 직접 경로에 있는 모든 컨테이너와 목록 노드가 포함되어야 합니다. 목록의 경우 모든 키 리프도 포함되어야 합니다. 가장 안쪽 컨테이너 또는 목록에는 정의된 작업의 이름을 전달하는 XML 요소가 포함되어 있습니다. 이 요소 내에서 입력 매개변수는 "input" 문 내에 정의된 것과 동일한 순서로 하위 XML 요소로 인코딩됩니다.\(MUST, MUST\)

```text
   Only one action can be invoked in one <rpc>.  If more than one action
   is present in the <rpc>, the server MUST reply with a "bad-element"
   <error-tag> in the <rpc-error>.
```

작업 작업 호출이 성공하고 출력 매개변수가 반환되지 않으면 <rpc-reply\>에는 \[RFC6241\]에 정의된 단일 <ok/\> 요소가 포함됩니다. 출력 매개변수가 반환되면 "output" 문에 정의된 것과 동일한 순서로 \[RFC6241\]에 정의된 <rpc-reply\> 요소에 대한 하위 요소로 인코딩됩니다.

---
#### **7.15.3.  Usage Example**

다음 예에서는 서버 팜에서 서버 하나를 재설정하는 작업을 정의합니다.

```text
     module example-server-farm {
       yang-version 1.1;
       namespace "urn:example:server-farm";
       prefix "sfarm";

       import ietf-yang-types {
         prefix "yang";
       }

       list server {
         key name;
         leaf name {
           type string;
         }
         action reset {
           input {
             leaf reset-at {
               type yang:date-and-time;
               mandatory true;
              }
            }
            output {
              leaf reset-finished-at {
                type yang:date-and-time;
                mandatory true;
              }
            }
          }
        }
      }
```

완전한 rpc 및 rpc-reply의 해당 XML 인스턴스 예:

```text
     <rpc message-id="101"
          xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
       <action xmlns="urn:ietf:params:xml:ns:yang:1">
         <server xmlns="urn:example:server-farm">
           <name>apache-1</name>
           <reset>
             <reset-at>2014-07-29T13:42:00Z</reset-at>
           </reset>
         </server>
       </action>
     </rpc>

     <rpc-reply message-id="101"
                xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
       <reset-finished-at xmlns="urn:example:server-farm">
         2014-07-29T13:42:12Z
       </reset-finished-at>
     </rpc-reply>
```

---
### **7.16.  The "notification" Statement**

"notification" 문은 알림을 정의하는 데 사용됩니다. 이는 식별자인 하나의 인수를 취하고 그 뒤에 자세한 알림 정보를 포함하는 하위 명령문 블록이 옵니다. "알림" 문은 스키마 트리의 알림 노드를 정의합니다.

알림은 모듈의 최상위 수준에서 정의되거나 스키마 트리의 특정 컨테이너 또는 목록 데이터 노드에 연결될 수 있습니다.

알림은 rpc, 작업 또는 다른 알림 내에 정의되어서는 안 됩니다. 즉, 알림 노드는 rpc, 작업 또는 알림 노드를 스키마 트리의 상위 항목 중 하나로 가져서는 안 됩니다. 예를 들어, 이는 노드 계층 어딘가에 알림을 포함하는 그룹이 rpc 정의에 사용되는 경우 오류가 발생함을 의미합니다.\(MUST NOT\)

알림에는 "키" 문이 없는 목록 노드인 조상 노드가 있어서는 안 됩니다.\(MUST NOT\)

"case" 문에서는 알림을 정의할 수 없으므로 노드 계층 구조의 최상위에 알림을 포함하는 그룹이 사례 정의에 사용되는 경우 오류가 발생합니다.

알림 트리의 리프에 값이 "true"인 "필수" 문이 있는 경우 리프는 알림 인스턴스에 있어야 합니다.\(MUST\)

알림 트리의 리프에 기본값이 있는 경우 클라이언트는 섹션 7.6.1에 설명된 것과 동일한 경우에 이 값을 사용해야 합니다. 이러한 경우 클라이언트는 마치 리프가 기본값을 해당 값으로 사용하여 알림 인스턴스에 존재하는 것처럼 작동해야 합니다.\(MUST, MUST\)

알림 트리의 리프 목록에 하나 이상의 기본값이 있는 경우 클라이언트는 섹션 7.7.2에 설명된 것과 동일한 경우에 이러한 값을 사용해야 합니다. 이러한 경우 클라이언트는 마치 리프 목록이 기본값을 해당 값으로 사용하여 알림 인스턴스에 존재하는 것처럼 작동해야 합니다.\(MUST, MUST\)

알림 트리는 데이터 저장소의 일부가 아니므로 알림 트리의 노드에 대한 모든 "config" 문은 무시됩니다.

---
#### **7.16.1.  The notification's Substatements**

```text
                 +--------------+---------+-------------+
                 | substatement | section | cardinality |
                 +--------------+---------+-------------+
                 | anydata      | 7.10    | 0..n        |
                 | anyxml       | 7.11    | 0..n        |
                 | choice       | 7.9     | 0..n        |
                 | container    | 7.5     | 0..n        |
                 | description  | 7.21.3  | 0..1        |
                 | grouping     | 7.12    | 0..n        |
                 | if-feature   | 7.20.2  | 0..n        |
                 | leaf         | 7.6     | 0..n        |
                 | leaf-list    | 7.7     | 0..n        |
                 | list         | 7.8     | 0..n        |
                 | must         | 7.5.3   | 0..n        |
                 | reference    | 7.21.4  | 0..1        |
                 | status       | 7.21.2  | 0..1        |
                 | typedef      | 7.3     | 0..n        |
                 | uses         | 7.13    | 0..n        |
                 +--------------+---------+-------------+
```

---
#### **7.16.2.  NETCONF XML Encoding Rules**

모듈의 최상위 수준에 정의된 알림 노드는 "NETCONF 이벤트 알림" \[RFC5277\]에 정의된 <notification\> 요소에 대한 하위 XML 요소로 인코딩됩니다. 요소의 로컬 이름은 알림의 식별자이고 해당 네임스페이스는 모듈의 XML 네임스페이스입니다\(섹션 7.1.3 참조\).

알림 노드가 데이터 노드의 하위 노드로 정의되면 \[RFC5277\]에 정의된 <notification\> 요소에는 데이터 저장소의 노드를 식별하는 노드 계층이 포함됩니다. 여기에는 최상위 수준부터 알림을 포함하는 목록 또는 컨테이너까지 모든 컨테이너와 목록 노드가 포함되어야 합니다. 목록의 경우 모든 키 리프도 포함되어야 합니다. 가장 안쪽 컨테이너 또는 목록에는 정의된 알림의 이름을 전달하는 XML 요소가 포함되어 있습니다.\(MUST, MUST\)

알림의 하위 노드는 순서에 관계없이 알림 노드의 XML 요소에 대한 하위 요소로 인코딩됩니다.

---
#### **7.16.3.  Usage Example**

다음 예에서는 모듈의 최상위 수준에서 알림을 정의합니다.

```text
     module example-event {
       yang-version 1.1;
       namespace "urn:example:event";
       prefix "ev";

       notification event {
         leaf event-class {
           type string;
         }
         leaf reporting-entity {
           type instance-identifier;
         }
         leaf severity {
           type string;
         }
       }
     }
```

완전한 알림의 해당 XML 인스턴스 예:

```text
     <notification
       xmlns="urn:ietf:params:xml:ns:netconf:notification:1.0">
       <eventTime>2008-07-08T00:01:00Z</eventTime>
       <event xmlns="urn:example:event">
         <event-class>fault</event-class>
         <reporting-entity>
           /ex:interface[ex:name='Ethernet0']
         </reporting-entity>
         <severity>major</severity>
       </event>
     </notification>
```

다음 예에서는 데이터 노드의 알림을 정의합니다.

```text
     module example-interface-module {
       yang-version 1.1;
       namespace "urn:example:interface-module";
       prefix "if";

       container interfaces {
         list interface {
           key "name";
           leaf name {
             type string;
           }
           notification interface-enabled {
             leaf by-user {
               type string;
             }
           }
         }
       }
     }
```

완전한 알림의 해당 XML 인스턴스 예:

```text
     <notification
       xmlns="urn:ietf:params:xml:ns:netconf:notification:1.0">
       <eventTime>2008-07-08T00:01:00Z</eventTime>
       <interfaces xmlns="urn:example:interface-module">
         <interface>
           <name>eth1</name>
           <interface-enabled>
             <by-user>fred</by-user>
           </interface-enabled>
         </interface>
       </interfaces>
     </notification>
```

---
### **7.17.  The "augment" Statement**

"augment" 문을 사용하면 모듈이나 하위 모듈이 외부 모듈이나 현재 모듈 및 해당 하위 모듈에 정의된 스키마 트리에 추가하고 "uses" 문에서 그룹화의 노드에 추가할 수 있습니다. 인수는 스키마 트리의 노드를 식별하는 문자열입니다. 이 노드를 기능 보강의 대상 노드라고 합니다. 대상 노드는 컨테이너, 목록, 선택, 사례, 입력, 출력 또는 알림 노드여야 합니다. "augment" 문 뒤에 오는 하위 문에 정의된 노드로 확장됩니다.\(MUST\)

인수 문자열은 스키마 노드 식별자입니다\(섹션 6.5 참조\). "augment" 문이 모듈이나 하위 모듈의 최상위 수준에 있는 경우 스키마 노드 식별자의 절대 형식\(섹션 14의 "absolute-schema-nodeid" 규칙에 의해 정의됨\)을 사용해야 합니다. "augment" 문이 "uses" 문에 대한 하위 문인 경우 하위 형식\(섹션 14의 "descendant-schema-nodeid" 규칙에 의해 정의됨\)을 사용해야 합니다.\(MUST, MUST\)

대상 노드가 컨테이너, 목록, 사례, 입력, 출력 또는 알림 노드인 경우 "container", "leaf", "list", "leaf-list", "uses" 및 "choice" 문은 다음과 같을 수 있습니다. "augment" 문 내에서 사용됩니다.

대상 노드가 컨테이너 또는 목록 노드인 경우 "augment" 문 내에서 "action" 및 "notification" 문을 사용할 수 있습니다.

대상 노드가 선택 노드인 경우 "case" 문 또는 단축형 "case" 문\(섹션 7.9.2 참조\)을 "augment" 문 내에서 사용할 수 있습니다.

"augment" 문은 동일한 모듈의 동일한 이름을 가진 여러 노드를 대상 노드에 추가해서는 안 됩니다.\(MUST NOT\)

확장이 다른 모듈의 대상 노드에 대한 구성을 나타내는 필수 노드\(섹션 3 참조\)를 추가하는 경우 확장은 "when" 문을 사용하여 조건부로 이루어져야 합니다. 기능 보강 모듈에 대해 모르는 클라이언트가 중단되지 않도록 "when" 표현식을 정의할 때는 주의해야 합니다.\(MUST\)

다음 예에서는 "mandatory-leaf"로 "인터페이스" 항목을 확장해도 괜찮습니다. 왜냐하면 확장은 "some-new-iftype" 지원에 따라 달라지기 때문입니다. 이전 클라이언트는 이 유형에 대해 모르므로 이 유형을 선택하지 않으므로 필수 데이터 노드를 추가하지 않습니다.

```text
     module example-augment {
       yang-version 1.1;
       namespace "urn:example:augment";
       prefix mymod;

       import ietf-interfaces {
         prefix if;
       }

       identity some-new-iftype {
          base if:interface-type;
       }

       augment "/if:interfaces/if:interface" {
          when 'derived-from-or-self(if:type, "mymod:some-new-iftype")';

          leaf mandatory-leaf {
             mandatory true;
             type string;
          }
       }
     }
```

---
#### **7.17.1.  The augment's Substatements**

```text
                 +--------------+---------+-------------+
                 | substatement | section | cardinality |
                 +--------------+---------+-------------+
                 | action       | 7.15    | 0..n        |
                 | anydata      | 7.10    | 0..n        |
                 | anyxml       | 7.11    | 0..n        |
                 | case         | 7.9.2   | 0..n        |
                 | choice       | 7.9     | 0..n        |
                 | container    | 7.5     | 0..n        |
                 | description  | 7.21.3  | 0..1        |
                 | if-feature   | 7.20.2  | 0..n        |
                 | leaf         | 7.6     | 0..n        |
                 | leaf-list    | 7.7     | 0..n        |
                 | list         | 7.8     | 0..n        |
                 | notification | 7.16    | 0..n        |
                 | reference    | 7.21.4  | 0..1        |
                 | status       | 7.21.2  | 0..1        |
                 | uses         | 7.13    | 0..n        |
                 | when         | 7.21.5  | 0..1        |
                 +--------------+---------+-------------+
```

---
#### **7.17.2.  XML Encoding Rules**

"augment" 문에 정의된 모든 데이터 노드는 "augment"가 지정된 모듈의 XML 네임스페이스에 있는 XML 요소로 정의됩니다.

노드가 보강되면 보강 하위 노드는 순서에 관계없이 보강된 노드에 대한 하위 요소로 인코딩됩니다.

---
#### **7.17.3.  Usage Example**

urn:example:interface-module 네임스페이스에는 다음이 있습니다.

```text
     container interfaces {
       list ifEntry {
         key "ifIndex";

         leaf ifIndex {
           type uint32;
         }
         leaf ifDescr {
           type string;
         }
         leaf ifType {
           type iana:IfType;
         }
         leaf ifMtu {
           type int32;
         }
       }
     }
```

그런 다음 urn:example:ds0 네임스페이스에 다음이 있습니다.

```text
     import example-interface-module {
       prefix "if";
     }
     augment "/if:interfaces/if:ifEntry" {
       when "if:ifType='ds0'";
       leaf ds0ChannelNumber {
         type ChannelNumber;
       }
     }
```

해당 XML 인스턴스 예:

```text
     <interfaces xmlns="urn:example:interface-module"
                 xmlns:ds0="urn:example:ds0">
       <ifEntry>
         <ifIndex>1</ifIndex>
         <ifDescr>Flintstone Inc Ethernet A562</ifDescr>
         <ifType>ethernetCsmacd</ifType>
         <ifMtu>1500</ifMtu>
       </ifEntry>
       <ifEntry>
         <ifIndex>2</ifIndex>
         <ifDescr>Flintstone Inc DS0</ifDescr>
         <ifType>ds0</ifType>
         <ds0:ds0ChannelNumber>1</ds0:ds0ChannelNumber>
       </ifEntry>
     </interfaces>
```

또 다른 예로, 섹션 7.9.6에 정의된 선택이 있다고 가정합니다. 다음 구성을 사용하여 프로토콜 정의를 확장할 수 있습니다.

```text
     augment /ex:system/ex:protocol/ex:name {
       case c {
         leaf smtp {
           type empty;
         }
       }
     }
```

해당 XML 인스턴스 예:

```text
     <ex:system>
       <ex:protocol>
         <ex:tcp/>
       </ex:protocol>
     </ex:system>

   or

     <ex:system>
       <ex:protocol>
         <other:smtp/>
       </ex:protocol>
     </ex:system>
```

---
### **7.18.  The "identity" Statement**

"identity" 문은 새로운 전역적으로 고유하고 추상적이며 유형이 지정되지 않은 ID를 정의하는 데 사용됩니다. ID의 유일한 목적은 이름, 의미 및 존재를 나타내는 것입니다. ID는 처음부터 정의되거나 하나 이상의 기본 ID에서 파생될 수 있습니다. ID의 인수는 ID의 이름인 식별자입니다. 그 뒤에는 자세한 신원 정보를 담고 있는 하위 진술 블록이 옵니다.

내장 데이터 유형 "identityref"\(섹션 9.10 참조\)를 사용하여 데이터 모델 내에서 ID를 참조할 수 있습니다.

---
#### **7.18.1.  The identity's Substatements**

```text
                 +--------------+---------+-------------+
                 | substatement | section | cardinality |
                 +--------------+---------+-------------+
                 | base         | 7.18.2  | 0..n        |
                 | description  | 7.21.3  | 0..1        |
                 | if-feature   | 7.20.2  | 0..n        |
                 | reference    | 7.21.4  | 0..1        |
                 | status       | 7.21.2  | 0..1        |
                 +--------------+---------+-------------+
```

---
#### **7.18.2.  The "base" Statement**

선택 사항인 "base" 문은 새 ID가 파생되는 기존 ID의 이름인 문자열을 인수로 사용합니다. "기본" 문이 없으면 ID가 처음부터 정의됩니다. 여러 개의 "기본" 문이 존재하는 경우 해당 문 모두에서 ID가 파생됩니다.

기본 이름에 접두사가 있으면 해당 접두사와 함께 가져온 모듈에 정의된 ID를 참조하거나, 접두사가 로컬 모듈의 접두사와 일치하는 경우 로컬 모듈을 참조합니다. 그렇지 않으면 일치하는 이름을 가진 ID가 현재 모듈이나 포함된 하위 모듈에 정의되어야 합니다.\(MUST\)

ID는 다른 ID 체인을 통해 직접적이든 간접적이든 자신을 참조해서는 안 됩니다.\(MUST NOT\)

ID 파생에는 다음과 같은 속성이 있습니다.

o 비반사적입니다. 즉, 정체성이 그 자체에서 파생되지 않는다는 의미입니다.

o 이는 추이적입니다. 즉, 정체성 B가 A에서 파생되고 C가 B에서 파생되면 C도 A에서 파생됩니다.

---
#### **7.18.3.  Usage Example**

```text
     module example-crypto-base {
       yang-version 1.1;
       namespace "urn:example:crypto-base";
       prefix "crypto";

       identity crypto-alg {
         description
           "Base identity from which all crypto algorithms
            are derived.";
       }

       identity symmetric-key {
         description
           "Base identity used to identify symmetric-key crypto
            algorithms.";
         }

       identity public-key {
         description
           "Base identity used to identify public-key crypto
            algorithms.";
         }
     }

     module example-des {
       yang-version 1.1;
       namespace "urn:example:des";
       prefix "des";

       import "example-crypto-base" {
         prefix "crypto";
       }

       identity des {
         base "crypto:crypto-alg";
         base "crypto:symmetric-key";
         description "DES crypto algorithm.";
       }

       identity des3 {
         base "crypto:crypto-alg";
         base "crypto:symmetric-key";
         description "Triple DES crypto algorithm.";
       }
     }
```

---
### **7.19.  The "extension" Statement**

"확장" 문을 사용하면 YANG 언어 내에서 새 문을 정의할 수 있습니다. 이 새로운 명령문 정의는 다른 모듈에서 가져와 사용할 수 있습니다.

"확장" 문의 인수는 확장에 대한 새 키워드인 식별자이며 자세한 확장 정보를 보유하는 하위 명령문 블록이 뒤에 와야 합니다. "확장" 문의 목적은 다른 모듈에서 가져와 사용할 수 있도록 키워드를 정의하는 것입니다.

확장은 "확장" 문에 의해 정의된 경우 문 이름 뒤에 인수와 선택적인 하위 문 블록을 사용하여 일반 YANG 문처럼 사용할 수 있습니다. 문의 이름은 확장이 정의된 모듈의 접두사인 콜론\(":"\)과 확장의 키워드를 인터리브 공백 없이 결합하여 생성됩니다. 확장의 하위 설명은 이 사양의 범위를 벗어나는 일부 메커니즘을 사용하여 "확장" 설명으로 정의됩니다. 구문론적으로 하위 명령문은 "확장" 문을 사용하여 정의된 확장을 포함하여 YANG 문이어야 합니다. 확장의 YANG 문은 섹션 14의 구문 규칙을 따라야 합니다.\(MUST, MUST\)

확장은 개선\(Section 7.13.2 참조\)과 편차\(Section 7.20.3.2\)를 허용할 수 있지만 이것이 정의되는 방식에 대한 메커니즘은 이 사양의 범위를 벗어납니다.

---
#### **7.19.1.  The extension's Substatements**

```text
                 +--------------+---------+-------------+
                 | substatement | section | cardinality |
                 +--------------+---------+-------------+
                 | argument     | 7.19.2  | 0..1        |
                 | description  | 7.21.3  | 0..1        |
                 | reference    | 7.21.4  | 0..1        |
                 | status       | 7.21.2  | 0..1        |
                 +--------------+---------+-------------+
```

---
#### **7.19.2.  The "argument" Statement**

선택적인 "인수" 문은 키워드에 대한 인수 이름인 문자열을 인수로 사용합니다. "인수" 문이 없으면 키워드를 사용할 때 인수가 필요하지 않습니다.

인수 이름은 YIN 매핑에서 사용되며 인수의 "yin-element" 문에 따라 XML 속성 또는 요소 이름으로 사용됩니다.

---
##### **7.19.2.1.  The argument's Substatement**

```text
                 +--------------+----------+-------------+
                 | substatement | section  | cardinality |
                 +--------------+----------+-------------+
                 | yin-element  | 7.19.2.2 | 0..1        |
                 +--------------+----------+-------------+
```

---
##### **7.19.2.2.  The "yin-element" Statement**

선택적인 "yin-element" 문은 문자열 "true" 또는 "false"를 인수로 사용합니다. 이 명령문은 인수가 YIN의 XML 요소 또는 XML 속성에 매핑되는지 여부를 나타냅니다\(섹션 13 참조\).

"yin-element" 문이 없으면 기본값은 "false"입니다.

---
#### **7.19.3.  Usage Example**

확장을 정의하려면 다음을 수행하십시오.

```text
     module example-extensions {
       yang-version 1.1;
       ...

       extension c-define {
         description
           "Takes as an argument a name string.
            Makes the code generator use the given name
            in the #define.";
         argument "name";
       }
     }
```

확장 기능을 사용하려면:

```text
     module example-interfaces {
       yang-version 1.1;

       ...
       import example-extensions {
         prefix "myext";
       }
       ...

       container interfaces {
         ...
         myext:c-define "MY_INTERFACES";
       }
     }
```

---
### **7.20.  Conformance-Related Statements**

이 섹션에서는 섹션 5.6에 설명된 대로 적합성과 관련된 설명을 정의합니다.

---
#### **7.20.1.  The "feature" Statement**

"feature" 문은 스키마 부분을 조건부로 표시하는 메커니즘을 정의하는 데 사용됩니다. 나중에 "if-feature" 문을 사용하여 참조할 수 있는 기능 이름이 정의됩니다\(섹션 7.20.2 참조\). "if-feature" 문으로 태그가 지정된 스키마 노드는 서버가 지정된 기능 표현식을 지원하지 않는 한 서버에서 무시됩니다. 이를 통해 YANG 모듈의 일부가 서버의 조건에 따라 조건부로 적용될 수 있습니다. 모델은 모델 내의 서버 기능을 나타낼 수 있으므로 다양한 서버 기능과 역할을 허용하는 보다 풍부한 모델을 제공할 수 있습니다.

"feature" 설명에 대한 인수는 새 기능의 이름이며 섹션 6.2의 식별자 규칙을 따릅니다. 이 이름은 "if-feature" 문에서 스키마 노드를 기능에 연결하는 데 사용됩니다.

이 예에서 "local-storage"라는 기능은 서버가 일종의 로컬 저장소에 syslog 메시지를 저장하는 기능을 나타냅니다. 이 기능은 일종의 로컬 저장소 존재에 따라 "로컬 저장소 제한" 리프를 조건부로 만드는 데 사용됩니다. 서버가 이 기능을 지원한다고 보고하지 않으면 "local-storage-limit" 노드가 지원되지 않습니다.

```text
     module example-syslog {
       yang-version 1.1;

       ...
       feature local-storage {
         description
           "This feature means that the server supports local
            storage (memory, flash, or disk) that can be used to
            store syslog messages.";
       }

       container syslog {
         leaf local-storage-limit {
           if-feature local-storage;
           type uint64;
           units "kilobyte";
           config false;
           description
             "The amount of local storage that can be
              used to hold syslog messages.";
         }
       }
     }
```

"if-feature" 문은 YANG 구문 내 여러 위치에서 사용될 수 있습니다. 서버가 해당 기능을 지원하지 않으면 "if-feature" 태그가 붙은 정의는 무시됩니다.

기능은 직접적으로든 간접적으로든 다른 기능 체인을 통해 자체적으로 참조해서는 안 됩니다.\(MUST NOT\)

서버가 다른 기능에 종속된 기능\(즉, 해당 기능에 하나 이상의 "if-feature" 하위 설명이 있음\)을 지원하려면 서버가 모든 종속 기능도 지원해야 합니다.\(MUST\)

---
##### **7.20.1.1.  The feature's Substatements**

```text
                 +--------------+---------+-------------+
                 | substatement | section | cardinality |
                 +--------------+---------+-------------+
                 | description  | 7.21.3  | 0..1        |
                 | if-feature   | 7.20.2  | 0..n        |
                 | reference    | 7.21.4  | 0..1        |
                 | status       | 7.21.2  | 0..1        |
                 +--------------+---------+-------------+
```

---
#### **7.20.2.  The "if-feature" Statement**

"if-feature" 문은 상위 문을 조건부로 만듭니다. 인수는 기능 이름에 대한 부울 표현식입니다. 이 표현식에서 기능 이름은 해당 기능이 서버에서 지원되는 경우에만 "true"로 평가됩니다. 상위 명령문은 부울 표현식이 "true"로 평가되는 서버에 의해 구현됩니다.

if-feature 부울 표현식 구문은 섹션 14의 "if-feature-expr" 규칙에 의해 공식적으로 정의됩니다. 괄호는 표현식을 그룹화하는 데 사용됩니다. 식이 평가될 때 우선 순위는 그룹화\(괄호\), "not", "and", "or"입니다\(가장 높은 우선 순위부터\).

부울 표현식의 기능 이름에 접두사가 있는 경우 접두사가 붙은 이름은 해당 접두사와 함께 가져온 모듈에 정의된 기능을 참조하거나 접두사가 로컬 모듈의 접두사와 일치하는 경우 로컬 모듈을 나타냅니다. 그렇지 않으면 일치하는 이름을 가진 기능이 현재 모듈이나 포함된 하위 모듈에 정의되어야 합니다.\(MUST\)

목록 키인 리프에는 "if-feature" 문이 있어서는 안 됩니다.\(MUST NOT\)

---
##### **7.20.2.1.  Usage Example**

이 예에서는 "outbound-tls" 또는 "outbound-ssh" 기능이 서버에서 지원되는 경우 컨테이너 "target"이 구현됩니다.

```text
     container target {
       if-feature "outbound-tls or outbound-ssh";
       ...
     }
```

다음 예는 동일합니다.

```text
     if-feature "not foo or bar and baz";

     if-feature "(not foo) or (bar and baz)";
```

---
#### **7.20.3.  The "deviation" Statement**

"편차" 문은 서버가 충실하게 구현하지 않는 모듈의 계층 구조를 정의합니다. 인수는 모듈에서 벗어나는 스키마 트리의 노드를 식별하는 문자열입니다. 이 노드를 편차의 대상 노드라고 합니다. "편차" 설명의 내용은 편차에 대한 세부정보를 제공합니다.

인수 문자열은 절대 스키마 노드 식별자입니다\(섹션 6.5 참조\).

편차는 서버 또는 서버 클래스가 표준에서 벗어나는 방식을 정의합니다. 즉, 편차는 구현이 표준과 어떻게 다른지 학습하기 위한 메커니즘이므로 게시된 표준의 일부가 되어서는 안 됩니다.\(MUST\)

서버 편차는 권장되지 않으며 최후의 수단으로만 사용해야 합니다. 서버가 표준을 따르지 못하는 이유를 애플리케이션에 알려주는 것은 표준을 올바르게 구현하는 것을 대체할 수 없습니다. 모듈에서 벗어난 서버는 모듈과 완전히 호환되지 않습니다.\(MUST\)

그러나 어떤 경우에는 특정 장치에 표준 모듈의 일부를 지원하는 하드웨어 또는 소프트웨어 기능이 없을 수도 있습니다. 이런 일이 발생하면 서버는 모듈의 지원되지 않는 부분을 구성하려는 시도를 의심하지 않는 응용 프로그램에 다시 보고되는 오류로 처리하거나 들어오는 요청을 무시하도록 선택합니다. 어느 선택도 받아들일 수 없습니다.

대신 YANG을 사용하면 "편차" 문을 사용하여 서버가 지원되지 않거나 지원되지만 구문이 다른 기본 모듈 부분을 문서화할 수 있습니다.

서버가 발표한 모든 편차를 순서에 관계없이 적용한 후에도 결과 데이터 모델은 여전히 ​​유효해야 합니다.\(MUST\)

---
##### **7.20.3.1.  The deviation's Substatements**

```text
                 +--------------+----------+-------------+
                 | substatement | section  | cardinality |
                 +--------------+----------+-------------+
                 | description  | 7.21.3   | 0..1        |
                 | deviate      | 7.20.3.2 | 1..n        |
                 | reference    | 7.21.4   | 0..1        |
                 +--------------+----------+-------------+
```

---
##### **7.20.3.2.  The "deviate" Statement**

"일탈" 문은 서버의 대상 노드 구현이 원래 정의에서 어떻게 벗어나는지 정의합니다. 인수는 "지원되지 않음", "추가", "교체" 또는 "삭제" 문자열 중 하나입니다.

"지원되지 않음" 인수는 대상 노드가 이 서버에 의해 구현되지 않음을 나타냅니다.

"add" 인수는 대상 노드에 속성을 추가합니다. 추가할 속성은 "일탈" 문에 대한 하위 설명으로 식별됩니다. 속성이 한 번만 나타날 수 있는 경우 해당 속성은 대상 노드에 존재해서는 안 됩니다.\(MUST NOT\)

"replace" 인수는 대상 노드의 속성을 대체합니다. 대체할 속성은 "일탈" 문에 대한 하위 설명으로 식별됩니다. 대체할 속성은 대상 노드에 있어야 합니다.\(MUST\)

"delete" 인수는 대상 노드에서 속성을 삭제합니다. 삭제할 속성은 "delete" 문의 하위 설명으로 식별됩니다. 하위 명령문의 키워드는 대상 노드의 해당 키워드와 일치해야 하며 인수의 문자열은 대상 노드의 해당 키워드의 인수 문자열과 동일해야 합니다.\(MUST\)

```text
               +--------------+--------------+-------------+
               | substatement | section      | cardinality |
               +--------------+--------------+-------------+
               | config       | 7.21.1       | 0..1        |
               | default      | 7.6.4, 7.7.4 | 0..n        |
               | mandatory    | 7.6.5        | 0..1        |
               | max-elements | 7.7.6        | 0..1        |
               | min-elements | 7.7.5        | 0..1        |
               | must         | 7.5.3        | 0..n        |
               | type         | 7.4          | 0..1        |
               | unique       | 7.8.3        | 0..n        |
               | units        | 7.3.3        | 0..1        |
               +--------------+--------------+-------------+
```

- 일탈자의 변명

대상 노드에 확장으로 정의된 속성이 있는 경우 확장이 편차를 허용하면 이 속성이 벗어날 수 있습니다. 자세한 내용은 섹션 7.19를 참조하세요.

---
##### **7.20.3.3.  Usage Example**

이 예에서 서버는 RFC 867 스타일의 "주간" 서비스를 지원하지 않는다는 것을 클라이언트 애플리케이션에 알립니다.

```text
     module example-deviations {
       yang-version 1.1;
       namespace "urn:example:deviations";
       prefix md;

       import example-base {
         prefix base;
       }

       deviation /base:system/base:daytime {
         deviate not-supported;
       }
       ...
     }
```

서버는 "example-base" 및 "example-deviations" 모듈을 모두 광고합니다.

다음 예에서는 기본값이 정의되지 않은 리프에 서버별 기본값을 설정합니다.

```text
     deviation /base:system/base:user/base:type {
       deviate add {
         default "admin"; // new users are 'admin' by default
       }
     }
```

이 예에서 서버는 이름 서버 수를 3으로 제한합니다.

```text
     deviation /base:system/base:name-server {
       deviate replace {
         max-elements 3;
       }
     }
```

원래 정의가 다음과 같은 경우:

```text
     container system {
       must "daytime or time";
       ...
     }
```

서버는 다음을 수행하여 이 "필수" 제약 조건을 제거할 수 있습니다.

```text
     deviation /base:system {
       deviate delete {
         must "daytime or time";
       }
     }
```

---
### **7.21.  Common Statements**

이 섹션에서는 다른 여러 명령문에 공통되는 하위 명령문을 정의합니다.

---
#### **7.21.1.  The "config" Statement**

"config" 문은 "true" 또는 "false" 문자열을 인수로 사용합니다. "config"가 "true"이면 정의는 구성을 나타냅니다. 구성을 나타내는 데이터 노드는 구성 데이터 저장소의 일부입니다.

"config"가 "false"인 경우 정의는 상태 데이터를 나타냅니다. 상태 데이터를 나타내는 데이터 노드는 구성 데이터 저장소의 일부가 아닙니다.

"config"가 지정되지 않은 경우 기본값은 상위 스키마 노드의 "config" 값과 동일합니다. 상위 노드가 케이스 노드인 경우 값은 케이스 노드의 상위 선택 노드와 동일합니다.

최상위 노드가 "config" 문을 지정하지 않으면 기본값은 "true"입니다.

노드의 "config"가 "false"로 설정된 경우 그 아래의 어떤 노드도 "config"를 "true"로 설정할 수 없습니다.

---
#### **7.21.2.  The "status" Statement**

"status" 문은 "current", "deprecated" 또는 "obsolete" 문자열 중 하나를 인수로 사용합니다.

o "현재"는 정의가 최신이고 유효함을 의미합니다.

o "더 이상 사용되지 않음"은 더 이상 사용되지 않는 정의를 나타내지만 이전/기존 구현과의 상호 운용성을 촉진하기 위해 새로운/지속적인 구현을 허용합니다.

o "오래된"이란 정의가 더 이상 사용되지 않으며 구현되어서는 안 되며/또는 구현에서 제거될 수 있음을 의미합니다.\(SHOULD NOT\)

상태가 지정되지 않은 경우 기본값은 "현재"입니다.

정의가 "현재"인 경우 동일한 모듈 내에서 "더 이상 사용되지 않는" 또는 "사용되지 않는" 정의를 참조해서는 안 됩니다.\(MUST NOT\)

정의가 "사용되지 않는" 경우 동일한 모듈 내에서 "사용되지 않는" 정의를 참조하면 안 됩니다.\(MUST NOT\)

예를 들어 다음은 불법입니다.

```text
     typedef my-type {
       status deprecated;
       type int32;
     }

     leaf my-leaf {
       status current;
       type my-type; // illegal, since my-type is deprecated
     }
```

---
#### **7.21.3.  The "description" Statement**

"설명" 문은 이 정의에 대해 사람이 읽을 수 있는 텍스트 설명이 포함된 문자열을 인수로 사용합니다. 텍스트는 모듈 개발자가 선택한 언어로 제공됩니다. 상호 운용성을 위해 모듈을 사용할 네트워크 관리자 커뮤니티에서 널리 이해되는 언어를 선택하는 것이 좋습니다.\(SHOULD\)

---
#### **7.21.4.  The "reference" Statement**

"참조" 문은 외부 문서\(관련 관리 정보를 정의하는 또 다른 모듈 또는 이 정의와 관련된 추가 정보를 제공하는 문서\)에 대해 사람이 읽을 수 있는 상호 참조인 문자열을 인수로 사용합니다.

예를 들어 "uri" 데이터 유형에 대한 typedef는 다음과 같습니다.

```text
     typedef uri {
       type string;
       reference
         "RFC 3986: Uniform Resource Identifier (URI): Generic Syntax";
       ...
     }
```

---
#### **7.21.5.  The "when" Statement**

"when" 문은 상위 데이터 정의 문을 조건부로 만듭니다. 상위 데이터 정의 문에 의해 정의된 노드는 "when" 문에 지정된 조건이 만족되는 경우에만 유효합니다. 명령문의 인수는 이 조건을 공식적으로 지정하는 데 사용되는 XPath 표현식\(섹션 6.4 참조\)입니다. XPath 표현식이 특정 인스턴스에 대해 개념적으로 "true"로 평가되는 경우 상위 데이터 정의 문에 의해 정의된 노드는 유효합니다. 그렇지 않으면 그렇지 않습니다.

목록 키인 리프에는 "when" 문이 있어서는 안 됩니다.\(MUST NOT\)

키 리프가 목록에 사용되는 그룹화에 정의된 경우 "uses" 문에는 "when" 문이 있어서는 안 됩니다.\(MUST NOT\)

추가 정보는 섹션 8.3.2를 참조하십시오.

XPath 표현식은 섹션 6.4.1의 정의 외에도 다음 컨텍스트에서 개념적으로 평가됩니다.

o "언제" 문이 "증강" 문의 하위인 경우 대상 노드가 데이터 노드인 경우 컨텍스트 노드는 데이터 트리에서 기능 보강의 대상 노드입니다. 그렇지 않은 경우 컨텍스트 노드는 데이터 노드이기도 한 대상 노드에 가장 가까운 상위 노드입니다. 해당 노드가 없으면 컨텍스트 노드는 루트 노드입니다. 액세스 가능한 트리는 "증강" 문에 의해 추가된 노드의 모든 인스턴스\(있는 경우\)를 제거하여 XPath 표현식을 처리하는 동안 잠정적으로 변경됩니다.

o "when" 문이 "uses", "choice" 또는 "case" 문의 하위인 경우 컨텍스트 노드는 데이터 노드이기도 한 "when" 문이 있는 노드에 가장 가까운 조상 노드입니다. . 해당 노드가 없으면 컨텍스트 노드는 루트 노드입니다. 액세스 가능한 트리는 "uses", "choice" 또는 "case" 문에 의해 추가된 노드의 모든 인스턴스\(있는 경우\)를 제거하여 XPath 표현식을 처리하는 동안 잠정적으로 변경됩니다.

o "when" 문이 다른 데이터 정의 문의 하위인 경우 "when" 문이 정의된 데이터 노드의 모든 인스턴스를 단일 항목으로 대체하여 XPath 표현식을 처리하는 동안 액세스 가능한 트리가 잠정적으로 변경됩니다. 이름이 같지만 값도 없고 자식도 없는 더미 노드입니다. 그러한 인스턴스가 존재하지 않으면 임시로 더미 노드가 생성됩니다. 컨텍스트 노드는 이 더미 노드입니다.

XPath 표현식의 결과는 표준 XPath 규칙을 사용하여 부울 값으로 변환됩니다.

XPath 표현식이 연관된 "when" 문이 있는 노드를 참조하는 경우 해당 "when" 표현식을 먼저 평가해야 합니다. "when" 표현식 사이에는 순환 종속성이 있어서는 안 됩니다.\(MUST, MUST NOT\)

XPath 표현식은 개념적으로 평가됩니다. 이는 구현이 서버에서 XPath 평가자를 사용할 필요가 없음을 의미합니다. "when" 문은 특별히 작성된 코드로 매우 잘 구현될 수 있습니다.

---
## **8.  Constraints**
---
### **8.1.  Constraints on Data**

여러 YANG 문은 유효한 데이터에 대한 제약 조건을 정의합니다. 이러한 제약 조건은 문이 정의하는 데이터 유형에 따라 다양한 방식으로 적용됩니다.

o 제약 조건이 구성 데이터에 정의된 경우 유효한 구성 데이터 트리에서 true여야 합니다.\(MUST\)

o 제약 조건이 상태 데이터에 정의된 경우 유효한 상태 데이터 트리에서 true여야 합니다.\(MUST\)

o 알림 내용에 제약 조건이 정의된 경우 모든 알림 데이터 트리에서 true여야 합니다.\(MUST\)

o 제약 조건이 RPC 또는 작업 입력 매개 변수에 정의된 경우 RPC 또는 작업 작업 호출 시 해당 제약 조건이 참이어야 합니다.\(MUST\)

o 제약 조건이 RPC 또는 작업 출력 매개 변수에 정의된 경우 RPC 또는 작업 응답에서 true여야 합니다.\(MUST\)

다음 속성은 모든 데이터 트리에 적용됩니다.

o 모든 리프 데이터 값은 유형의 "범위", "길이" 및 "패턴" 속성에 정의된 값을 포함하여 리프에 대한 유형 제약 조건과 일치해야 합니다.\(MUST\)

o 모든 목록 항목에 대해 모든 주요 리프가 있어야 합니다.\(MUST\)

o 노드는 모든 선택 항목에서 최대 하나의 사례 분기에 대해 존재해야 합니다.\(MUST\)

o 서버에서 "if-feature" 표현식이 "false"로 평가되는 경우 "if-feature" 태그가 지정된 노드가 없어야 합니다.\(MUST\)

o 데이터 트리에서 "언제" 조건이 "거짓"으로 평가되는 경우 "언제" 태그가 지정된 노드가 없어야 합니다.\(MUST\)

유효한 데이터 트리에서는 다음 속성이 적용됩니다.

o 모든 "필수" 제약 조건은 "참"으로 평가되어야 합니다.\(MUST\)

o "경로" 문을 통해 정의된 모든 참조 무결성 제약 조건을 충족해야 합니다.\(MUST\)

o 목록의 모든 "고유" 제약 조건을 충족해야 합니다.\(MUST\)

o "필수" 제약 조건은 "false"로 평가되는 "when" 조건 또는 "if-feature" 표현식이 있는 노드나 그 조상이 아닌 한 리프와 선택 항목에 대해 적용됩니다.

o "최소 요소" 및 "최대 요소" 제약 조건은 목록 및 리프 목록에 대해 적용됩니다. 단, 노드나 그 조상 중 하나에 "false"로 평가되는 "when" 조건 또는 "if-feature" 표현식이 있는 경우는 제외됩니다. .

실행 중인 구성 데이터 저장소는 항상 유효해야 합니다.\(MUST\)

---
### **8.2.  Configuration Data Modifications**

o 요청이 선택 사항에 따라 구성 데이터 노드를 생성하는 경우 데이터 트리의 다른 사례 분기에 있는 기존 노드는 서버에 의해 삭제됩니다.

o 요청이 노드의 "언제" 표현식이 거짓이 되도록 구성 데이터 노드를 수정하는 경우 "언제" 표현식이 포함된 데이터 트리의 노드가 서버에 의해 삭제됩니다.

---
### **8.3.  NETCONF Constraint Enforcement Model**

구성 데이터의 경우 제약 조건을 적용해야 하는 세 가지 창이 있습니다.\(MUST\)

o RPC 페이로드를 분석하는 동안

o <edit-config\> 작업을 처리하는 동안

o 검증 중

다음 섹션에서는 이러한 각 시나리오를 고려합니다.

---
#### **8.3.1.  Payload Parsing**

콘텐츠가 RPC 페이로드로 도착하면 서버가 구현하는 모델 집합에 의해 정의된 계층 구조와 콘텐츠 규칙을 따르는 올바른 형식의 XML이어야 합니다.\(MUST\)

o 리프 데이터 값이 유형의 "범위", "길이" 및 "패턴" 속성에 정의된 것을 포함하여 리프에 대한 유형 제약 조건과 일치하지 않는 경우 서버는 "잘못된 값"으로 응답해야 합니다. <rpc-error\>의 tag\>와 ​​제약 조건과 관련된 error-app-tag\(섹션 7.5.4.2\) 및 error-message\(섹션 7.5.4.1\)가 있는 경우.\(MUST\)

```text
   o  If all keys of a list entry are not present, the server MUST reply
      with a "missing-element" <error-tag> in the <rpc-error>.

   o  If data for more than one case branch of a choice is present, the
      server MUST reply with a "bad-element" <error-tag> in the
      <rpc-error>.

   o  If data for a node tagged with "if-feature" is present and the
      "if-feature" expression evaluates to "false" in the server, the
      server MUST reply with an "unknown-element" <error-tag> in the
      <rpc-error>.

   o  If data for a node tagged with "when" is present and the "when"
      condition evaluates to "false", the server MUST reply with an
      "unknown-element" <error-tag> in the <rpc-error>.

   o  For insert handling, if the values for the attributes "before" and
      "after" are not valid for the type of the appropriate key leafs,
      the server MUST reply with a "bad-attribute" <error-tag> in the
      <rpc-error>.

   o  If the attributes "before" and "after" appear in any element that
      is not a list whose "ordered-by" property is "user", the server
      MUST reply with an "unknown-attribute" <error-tag> in the
      <rpc-error>.
```

---
#### **8.3.2.  NETCONF <edit-config> Processing**

들어오는 데이터를 구문 분석한 후 NETCONF 서버는 해당 데이터를 구성 데이터 저장소에 적용하여 <edit-config\> 작업을 수행합니다. 이 처리 중에 다음 오류가 감지되어야 합니다.\(MUST\)

o 존재하지 않는 데이터에 대한 삭제 요청.

o 기존 데이터에 대한 요청을 생성합니다.

o 존재하지 않는 "이전" 또는 "이후" 매개변수가 포함된 요청을 삽입합니다.

```text
   o  Modification requests for nodes tagged with "when", and the "when"
      condition evaluates to "false".  In this case, the server MUST
      reply with an "unknown-element" <error-tag> in the <rpc-error>.
```

---
#### **8.3.3.  Validation**

데이터 저장소 처리가 완료되면 최종 콘텐츠는 모든 유효성 검사 제약 조건을 준수해야 합니다. 이 검증 처리는 데이터 저장소에 따라 서로 다른 시간에 수행됩니다. 데이터 저장소가 "실행 중"이거나 "시작" 중인 경우 이러한 제약 조건은 <edit-config\> 또는 <copy-config\> 작업이 끝날 때 적용되어야 합니다. 데이터 저장소가 "후보"인 경우 <commit\> 또는 <validate\> 작업이 발생할 때까지 제약 조건 적용이 지연됩니다.\(MUST, MUST\)

---
## **9.  Built-In Types**

YANG에는 많은 프로그래밍 언어와 유사한 내장 유형 세트가 있지만 관리 정보 모델의 특별한 요구 사항으로 인해 약간의 차이가 있습니다.

해당 기본 제공 유형이나 다른 파생 유형에서 파생된 추가 유형을 정의할 수 있습니다. 파생 유형은 하위 유형 지정을 사용하여 가능한 값 세트를 공식적으로 제한할 수 있습니다.

다양한 내장 유형과 파생 유형은 다양한 종류의 하위 유형 지정, 즉 문자열의 길이 및 정규식 제한\(섹션 9.4.4 및 9.4.5\)과 숫자 유형의 범위 제한\(섹션 9.2.4\)을 허용합니다.

특정 유형 값의 어휘 표현은 XML 인코딩에서 그리고 YANG 모듈에서 기본값과 숫자 범위를 지정할 때 사용됩니다.

---
### **9.1.  Canonical Representation**

대부분의 유형에는 유형 값에 대한 단일 표준 표현이 있습니다. 일부 유형에서는 동일한 값의 여러 어휘 표현을 허용합니다. 예를 들어, 양의 정수 "17"은 "+17" 또는 "17"로 표시될 수 있습니다. 구현은 이 문서에 지정된 모든 어휘 표현을 지원해야 합니다.\(MUST\)

서버가 XML로 인코딩된 데이터를 보낼 때 이 섹션에 정의된 표준 형식을 사용해야 합니다. 다른 인코딩에는 대체 표현이 도입될 수 있습니다. 그러나 데이터 트리의 값은 개념적으로 이 섹션에 정의된 표준 표현으로 저장됩니다. 특히, 데이터 유형이 표준 형식을 갖는 경우 모든 XPath 표현식 평가는 표준 형식을 사용하여 수행됩니다. 데이터 유형에 표준 형식이 없으면 값의 형식은 데이터 유형의 어휘 표현과 일치해야 하지만 정확한 형식은 구현에 따라 다릅니다.\(MUST, MUST\)

일부 유형에는 인코딩\(예: 해당 유형이 발생하는 XML 컨텍스트\)에 따라 달라지는 어휘 표현이 있습니다. 이러한 유형에는 표준 형식이 없습니다.

---
### **9.2.  The Integer Built-In Types**

정수 내장 유형은 int8, int16, int32, int64, uint8, uint16, uint32 및 uint64입니다. 이는 다양한 크기의 부호 있는 정수와 부호 없는 정수를 나타냅니다.

int8은 -128에서 127 사이의 정수 값을 나타냅니다.

int16은 -32768에서 32767 사이의 정수 값을 나타냅니다.

- 포함하여.

int32는 -2147483648에서 2147483647 사이의 정수 값을 나타냅니다.

int64는 -9223372036854775808에서 9223372036854775807 사이의 정수 값을 나타냅니다.

uint8은 0에서 255 사이의 정수 값을 나타냅니다.

uint16은 0에서 65535 사이의 정수 값을 나타냅니다.

uint32는 0에서 4294967295 사이의 정수 값을 나타냅니다.

- 포함하여.

uint64는 0에서 18446744073709551615 사이의 정수 값을 나타냅니다.

---
#### **9.2.1.  Lexical Representation**

정수 값은 선택적 기호\("+" 또는 "-"\)와 일련의 10진수 숫자로 어휘적으로 표현됩니다. 부호가 지정되지 않으면 "+"로 간주됩니다.

편의를 위해 YANG 모듈에서 정수의 기본값을 지정할 때 값을 16진수 또는 8진수 표기법으로 나타내는 대체 어휘 표현을 사용할 수 있습니다. 16진수 표기법은 선택적 기호\("+" 또는 "-"\), 문자 "0x", 그 뒤에 대문자 또는 소문자일 수 있는 16진수 숫자로 구성됩니다. 8진수 표기법은 선택적 기호\("+" 또는 "-"\), 문자 "0", 8진수 숫자로 구성됩니다.

YANG 모듈의 기본값 앞에 0\("0"\)이 있으면 8진수로 해석됩니다. XML 인코딩에서 정수는 항상 10진수로 해석되며 앞에 0이 허용됩니다.

```text
   Examples:

     // legal values
     +4711                       // legal positive value
     4711                        // legal positive value
     -123                        // legal negative value
     0xf00f                      // legal positive hexadecimal value
     -0xf                        // legal negative hexadecimal value
     052                         // legal positive octal value

     // illegal values
     - 1                         // illegal intermediate space
```

---
#### **9.2.2.  Canonical Form**

양의 정수의 표준 형식에는 "+" 기호가 포함되지 않습니다. 앞에 0을 붙이는 것은 금지됩니다. 값 0은 "0"으로 표시됩니다.

---
#### **9.2.3.  Restrictions**

모든 정수 유형은 "범위" 문\(9.2.4절\)으로 제한될 수 있습니다.

---
#### **9.2.4.  The "range" Statement**

"type" 문에 대한 선택적 하위 문인 "range" 문은 범위 표현 문자열을 인수로 사용합니다. 정수 및 십진 내장 유형 또는 이들에서 파생된 유형을 제한하는 데 사용됩니다.

범위는 명시적 값 또는 하한값, 두 개의 연속된 점 ".." 및 상한값으로 구성됩니다. 여러 값이나 범위를 "|"로 구분하여 지정할 수 있습니다. 여러 값이나 범위가 제공되면 모두 분리되어야 하며 오름차순이어야 합니다. 이미 범위가 제한된 유형에 범위 제한이 적용되는 경우 새 제한은 동일하게 제한되거나 더 제한적이어야 합니다. 즉, 하한을 높이거나 상한을 줄이거나 명시적인 값 또는 범위를 제거하거나 범위를 여러 개로 분할해야 합니다. 중간 간격이 있는 범위. 범위 표현에 주어진 각 명시적 값과 범위 경계 값은 다음과 같아야 합니다.\(MUST, MUST, MUST\)

제한되는 유형과 일치하거나 특수 값 "min" 또는 "max" 중 하나여야 합니다. "최소" 및 "최대"는 각각 제한되는 유형에 허용되는 최소값과 최대값을 의미합니다.

범위 표현식 구문은 섹션 14의 "range-arg" 규칙에 의해 공식적으로 정의됩니다.

---
##### **9.2.4.1.  The range's Substatements**

```text
                 +---------------+---------+-------------+
                 | substatement  | section | cardinality |
                 +---------------+---------+-------------+
                 | description   | 7.21.3  | 0..1        |
                 | error-app-tag | 7.5.4.2 | 0..1        |
                 | error-message | 7.5.4.1 | 0..1        |
                 | reference     | 7.21.4  | 0..1        |
                 +---------------+---------+-------------+
```

---
#### **9.2.5.  Usage Example**

```text
     typedef my-base-int32-type {
       type int32 {
         range "1..4 | 10..20";
       }
     }
```

```text
     typedef my-type1 {
       type my-base-int32-type {
         // legal range restriction
         range "11..max"; // 11..20
       }
     }
```

```text
     typedef my-type2 {
       type my-base-int32-type {
         // illegal range restriction
         range "11..100";
       }
     }
```

---
### **9.3.  The decimal64 Built-In Type**

Decimal64 내장 유형은 10진수로 표시될 수 있는 실수의 하위 집합을 나타냅니다. 10진수64의 값 공간은 64비트 부호 있는 정수에 음의 10제곱을 곱하여 얻을 수 있는 숫자 집합입니다. 즉, "i x 10^-n"으로 표현됩니다. 여기서 i는 정수64이고 n은 정수입니다. 1부터 18까지.

---
#### **9.3.1.  Lexical Representation**

10진수64 값은 선택적 기호\("+" 또는 "-"\)와 일련의 10진수 숫자, 선택적으로 소수점 표시기인 마침표\('.'\) 및 일련의 10진수 숫자로 어휘적으로 표시됩니다. 부호가 지정되지 않으면 "+"로 간주됩니다.

---
#### **9.3.2.  Canonical Form**

양의 십진수64 값의 표준 형식에는 "+" 기호가 포함되지 않습니다. 소수점은 필수입니다. 소수점 앞과 뒤에 최소한 한 자리가 있어야 한다는 규칙에 따라 선행 및 후행 0은 금지됩니다. 값 0은 "0.0"으로 표시됩니다.\(MUST\)

---
#### **9.3.3.  Restrictions**

10진수64 유형은 "범위" 문\(9.2.4절\)으로 제한할 수 있습니다.

---
#### **9.3.4.  The "fraction-digits" Statement**

유형이 "decimal64"인 경우 "type" 문에 대한 하위 설명인 "fraction-digits" 문이 있어야 합니다. 1에서 18 사이의 정수를 인수로 사용합니다. 이는 값 공간을 "i x 10^-n"으로 표현 가능한 숫자로 제한하여 10진수64 유형 값 간의 최소 차이 크기를 제어합니다. 여기서 n은 분수 인수입니다.\(MUST\)

다음 표에는 각 분수 값의 최소값과 최대값이 나열되어 있습니다.

```text
     +----------------+-----------------------+----------------------+
     | fraction-digit | min                   | max                  |
     +----------------+-----------------------+----------------------+
     | 1              | -922337203685477580.8 | 922337203685477580.7 |
     | 2              | -92233720368547758.08 | 92233720368547758.07 |
     | 3              | -9223372036854775.808 | 9223372036854775.807 |
     | 4              | -922337203685477.5808 | 922337203685477.5807 |
     | 5              | -92233720368547.75808 | 92233720368547.75807 |
     | 6              | -9223372036854.775808 | 9223372036854.775807 |
     | 7              | -922337203685.4775808 | 922337203685.4775807 |
     | 8              | -92233720368.54775808 | 92233720368.54775807 |
     | 9              | -9223372036.854775808 | 9223372036.854775807 |
     | 10             | -922337203.6854775808 | 922337203.6854775807 |
     | 11             | -92233720.36854775808 | 92233720.36854775807 |
     | 12             | -9223372.036854775808 | 9223372.036854775807 |
     | 13             | -922337.2036854775808 | 922337.2036854775807 |
     | 14             | -92233.72036854775808 | 92233.72036854775807 |
     | 15             | -9223.372036854775808 | 9223.372036854775807 |
     | 16             | -922.3372036854775808 | 922.3372036854775807 |
     | 17             | -92.23372036854775808 | 92.23372036854775807 |
     | 18             | -9.223372036854775808 | 9.223372036854775807 |
     +----------------+-----------------------+----------------------+
```

---
#### **9.3.5.  Usage Example**

```text
     typedef my-decimal {
       type decimal64 {
         fraction-digits 2;
         range "1 .. 3.14 | 10 | 20..max";
       }
     }
```

---
### **9.4.  The string Built-In Type**

string 내장 유형은 YANG에서 사람이 읽을 수 있는 문자열을 나타냅니다. 유효한 문자는 유니코드 및 ISO/IEC 10646 \[ISO.10646\] 문자이며 탭, 캐리지 리턴 및 줄 바꿈을 포함하지만 다른 C0 제어 문자, 대리 블록 및 비문자는 제외됩니다. 문자열 구문은 섹션 14의 "양-문자열" 규칙에 의해 공식적으로 정의됩니다.

---
#### **9.4.1.  Lexical Representation**

문자열 값은 XML 인코딩에서 문자 데이터로 어휘적으로 표현됩니다.

---
#### **9.4.2.  Canonical Form**

표준 형식은 어휘 표현과 동일합니다. 문자열 값의 유니코드 정규화는 수행되지 않습니다.

---
#### **9.4.3.  Restrictions**

문자열은 "length"\(섹션 9.4.4\) 및 "pattern"\(섹션 9.4.5\) 문으로 제한될 수 있습니다.

---
#### **9.4.4.  The "length" Statement**

"type" 문에 대한 선택적 하위 문인 "length" 문은 길이 표현 문자열을 인수로 사용합니다. 내장 유형 "string" 및 "binary" 또는 이들에서 파생된 유형을 제한하는 데 사용됩니다.

"길이" 문은 문자열의 유니코드 문자 수를 제한합니다.

길이 범위는 명시적 값 또는 하한, 두 개의 연속 점 ".." 및 상한으로 구성됩니다. 여러 값이나 범위를 "|"로 구분하여 지정할 수 있습니다. 길이 제한 값은 음수가 아니어야 합니다. 여러 값이나 범위가 제공되면 모두 분리되어야 하며 오름차순이어야 합니다. 이미 길이가 제한된 유형에 길이 제한이 적용되는 경우 새로운 제한은 동일하게 제한되거나 더 제한적이어야 합니다. 즉, 하한을 높이거나, 상한을 줄이거나, 명시적인 길이 값 또는 범위를 제거하거나, 범위를 다음으로 분할해야 합니다. 중간 간격이 있는 여러 범위. 길이 값은 음수가 아닌 정수이거나 특수 값 "min" 또는 "max" 중 하나입니다. "최소" 및 "최대"는 각각 제한되는 유형에 허용되는 최소 및 최대 길이를 의미합니다. 18446744073709551615보다 큰 길이 값을 지원하기 위해 구현이 필요하지 않습니다.\(MUST NOT, MUST, MUST\)

길이 표현식 구문은 섹션 14의 "length-arg" 규칙에 의해 공식적으로 정의됩니다.

---
##### **9.4.4.1.  The length's Substatements**

```text
                 +---------------+---------+-------------+
                 | substatement  | section | cardinality |
                 +---------------+---------+-------------+
                 | description   | 7.21.3  | 0..1        |
                 | error-app-tag | 7.5.4.2 | 0..1        |
                 | error-message | 7.5.4.1 | 0..1        |
                 | reference     | 7.21.4  | 0..1        |
                 +---------------+---------+-------------+
```

---
#### **9.4.5.  The "pattern" Statement**

"type" 문에 대한 선택적 하위 문인 "pattern" 문은 \[XSD-TYPES\]에 정의된 정규식 문자열을 인수로 사용합니다. 내장 유형 "문자열" 또는 "문자열"에서 파생된 유형을 패턴과 일치하는 값으로 제한하는 데 사용됩니다.

유형에 여러 개의 "패턴" 문이 있는 경우 표현식은 함께 AND로 연결됩니다. 즉, 이러한 모든 표현식이 일치해야 합니다.

이미 패턴이 제한된 유형에 패턴 제한이 적용되는 경우 값은 새 패턴 외에도 기본 유형의 모든 패턴과 일치해야 합니다.

---
##### **9.4.5.1.  The pattern's Substatements**

```text
                 +---------------+---------+-------------+
                 | substatement  | section | cardinality |
                 +---------------+---------+-------------+
                 | description   | 7.21.3  | 0..1        |
                 | error-app-tag | 7.5.4.2 | 0..1        |
                 | error-message | 7.5.4.1 | 0..1        |
                 | modifier      | 9.4.6   | 0..1        |
                 | reference     | 7.21.4  | 0..1        |
                 +---------------+---------+-------------+
```

---
#### **9.4.6.  The "modifier" Statement**

"pattern" 문에 대한 선택적 하위 문인 "modifier" 문은 문자열 "invert-match"를 인수로 사용합니다.

패턴에 "invert-match" 수정자가 있는 경우 유형은 패턴과 일치하지 않는 값으로 제한됩니다.

---
#### **9.4.7.  Usage Example**

다음 형식 정의를 사용합니다.

```text
     typedef my-base-str-type {
       type string {
         length "1..255";
       }
     }
```

다음 개선 사항은 합법적입니다.

```text
     type my-base-str-type {
       // legal length refinement
       length "11 | 42..max"; // 11 | 42..255
     }
```

다음 수정은 불법입니다.

```text
     type my-base-str-type {
       // illegal length refinement
       length "1..999";
     }
```

다음 유형의 경우:

```text
     type string {
       length "0..4";
       pattern "[0-9a-fA-F]*";
     }
```

다음 문자열이 일치합니다.

```text
     AB          // legal
     9A00        // legal
```

다음 문자열은 일치하지 않습니다.

```text
     00ABAB      // illegal, too long
     xx00        // illegal, bad characters
```

다음 유형의 경우:

```text
     type string {
       length "1..max";
       pattern '[a-zA-Z_][a-zA-Z0-9\-_.]*';
       pattern '[xX][mM][lL].*' {
         modifier invert-match;
       }
     }
```

다음 문자열은 일치합니다:

```text
     enabled     // legal
```

다음 문자열은 일치하지 않습니다.

```text
     10-mbit     // illegal, starts with a number
     xml-element // illegal, starts with illegal sequence
```

---
### **9.5.  The boolean Built-In Type**

부울 내장 유형은 부울 값을 나타냅니다.

---
#### **9.5.1.  Lexical Representation**

부울 값의 어휘 표현은 "true" 또는 "false" 값을 갖는 문자열입니다. 이 값은 소문자여야 합니다.\(MUST\)

---
#### **9.5.2.  Canonical Form**

표준 형식은 어휘 표현과 동일합니다.

---
#### **9.5.3.  Restrictions**

부울은 제한될 수 없습니다.

---
### **9.6.  The enumeration Built-In Type**

열거형 내장 유형은 할당된 이름 집합의 값을 나타냅니다.

---
#### **9.6.1.  Lexical Representation**

열거형 값의 어휘적 표현은 할당된 이름 문자열입니다.

---
#### **9.6.2.  Canonical Form**

정식 형식은 할당된 이름 문자열입니다.

---
#### **9.6.3.  Restrictions**

열거형은 기본 유형에 대한 값의 하위 집합을 열거하는 하나 이상의 "enum"\(섹션 9.6.4\) 문으로 제한될 수 있습니다.

---
#### **9.6.4.  The "enum" Statement**

유형이 "열거"인 경우 "type" 문에 대한 하위 설명인 "enum" 문이 있어야 합니다. 열거 유형의 할당된 각 이름을 지정하는 데 반복적으로 사용됩니다. 할당된 이름인 문자열을 인수로 사용합니다. 문자열은 길이가 0이어서는 안 되며 선행 또는 후행 공백 문자\("White\_Space" 속성이 있는 모든 유니코드 문자\)가 있어서는 안 됩니다. 유니코드 제어 코드의 사용은 피해야 합니다.\(MUST, MUST NOT, SHOULD\)

명령문 뒤에는 선택적으로 자세한 열거 정보를 보유하는 하위 명령문 블록이 옵니다.

열거형에 할당된 모든 이름은 고유해야 합니다.\(MUST\)

기존 열거 유형이 제한되면 새 유형의 할당된 이름 집합은 기본 유형의 할당된 이름 집합의 하위 집합이어야 합니다. 이렇게 할당된 이름의 값은 변경되어서는 안 됩니다.\(MUST, MUST NOT\)

---
##### **9.6.4.1.  The enum's Substatements**

```text
                 +--------------+---------+-------------+
                 | substatement | section | cardinality |
                 +--------------+---------+-------------+
                 | description  | 7.21.3  | 0..1        |
                 | if-feature   | 7.20.2  | 0..n        |
                 | reference    | 7.21.4  | 0..1        |
                 | status       | 7.21.2  | 0..1        |
                 | value        | 9.6.4.2 | 0..1        |
                 +--------------+---------+-------------+
```

---
##### **9.6.4.2.  The "value" Statement**

선택 사항인 "value" 문은 정수 값을 열거형에 할당된 이름과 연결하는 데 사용됩니다. 이 정수 값은 -2147483648 \~ 2147483647 범위에 있어야 하며 열거형 유형 내에서 고유해야 합니다.\(MUST\)

값을 지정하지 않으면 자동으로 값이 할당됩니다. "enum" 하위 문이 처음으로 정의된 경우 할당된 값은 0입니다. 그렇지 않은 경우 할당된 값은 현재 가장 높은 열거형 값\(즉, 부모 "type" 문에서 현재 "enum" 하위 문 이전의 암시적 또는 명시적 가장 높은 열거형 값\)보다 1 더 큽니다.

"enum" 문에 "if-feature" 문이 있어도 자동으로 할당된 값에는 영향을 미치지 않습니다.

현재 최고 값이 2147483647과 같은 경우 현재 최고 값을 가진 항목 다음의 "enum" 하위 설명에 열거 값을 지정해야 합니다.\(MUST\)

기존 열거 유형이 제한되는 경우 "value" 문은 기본 유형과 동일한 값을 가지거나 존재하지 않아야 합니다. 이 경우 값은 기본 유형과 동일합니다.\(MUST\)

---
#### **9.6.5.  Usage Example**

```text
     leaf myenum {
       type enumeration {
         enum zero;
         enum one;
         enum seven {
           value 7;
         }
       }
     }
```

값이 "7"인 리프 "myenum"의 어휘 표현은 다음과 같습니다.

```text
     <myenum>seven</myenum>
```

다음 형식 정의를 사용합니다.

```text
     typedef my-base-enumeration-type {
       type enumeration {
         enum white {
           value 1;
         }
         enum yellow {
           value 2;
         }
         enum red {
           value 3;
         }
       }
     }
```

다음 개선 사항은 합법적입니다.

```text
     type my-base-enumeration-type {
       // legal enum refinement
       enum yellow;
       enum red {
         value 3;
       }
     }
```

다음 수정은 불법입니다.

```text
     type my-base-enumeration-type {
       // illegal enum refinement
       enum yellow {
         value 4; // illegal value change
       }
       enum black; // illegal addition of new name
     }
```

다음 예에서는 "enum"에 "if-feature" 태그를 지정하여 해당 기능을 광고하는 서버에서만 해당 값을 허용하는 방법을 보여줍니다.

```text
     type enumeration {
       enum tcp;
       enum ssh {
         if-feature ssh;
       }
       enum tls {
         if-feature tls;
       }
     }
```

---
### **9.7.  The bits Built-In Type**

비트 내장 유형은 비트 세트를 나타냅니다. 즉, 비트 값은 0부터 시작하는 작은 정수 위치 번호로 식별되는 플래그 집합입니다. 각 비트 번호에는 할당된 이름이 있습니다.

기존 비트 유형이 제한되면 새 유형의 할당된 이름 집합은 기본 유형의 할당된 이름 집합의 하위 집합이어야 합니다. 할당된 이름의 비트 위치는 변경되어서는 안 됩니다.\(MUST, MUST NOT\)

---
#### **9.7.1.  Restrictions**

비트 유형은 "bit"\(9.7.4절\) 문을 사용하여 제한할 수 있습니다.

---
#### **9.7.2.  Lexical Representation**

비트 유형의 어휘 표현은 설정된 비트 이름의 공백으로 구분된 목록입니다. 따라서 길이가 0인 문자열은 비트가 설정되지 않은 값을 나타냅니다.

---
#### **9.7.3.  Canonical Form**

표준 형식에서 비트 값은 단일 공백 ​​문자로 구분되며 해당 위치에 따라 순서대로 표시됩니다\(섹션 9.7.4.2 참조\).

---
#### **9.7.4.  The "bit" Statement**

"type" 문에 대한 하위 설명인 "bit" 문은 유형이 "bits"인 경우 반드시 있어야 합니다. 비트 유형의 할당된 각 명명된 비트를 지정하는 데 반복적으로 사용됩니다. 비트에 할당된 이름인 문자열을 인수로 사용합니다. 그 뒤에는 자세한 비트 정보를 보유하는 하위 명령문 블록이 옵니다. 할당된 이름은 식별자와 동일한 구문 규칙을 따릅니다\(섹션 6.2 참조\).\(MUST\)

비트 유형에 할당된 모든 이름은 고유해야 합니다.\(MUST\)

---
##### **9.7.4.1.  The bit's Substatements**

```text
                 +--------------+---------+-------------+
                 | substatement | section | cardinality |
                 +--------------+---------+-------------+
                 | description  | 7.21.3  | 0..1        |
                 | if-feature   | 7.20.2  | 0..n        |
                 | position     | 9.7.4.2 | 0..1        |
                 | reference    | 7.21.4  | 0..1        |
                 | status       | 7.21.2  | 0..1        |
                 +--------------+---------+-------------+
```

---
##### **9.7.4.2.  The "position" Statement**

선택 사항인 "위치" 문은 가상 비트 필드 내에서 비트 위치를 지정하는 음수가 아닌 정수 값을 인수로 사용합니다. 위치 값은 0\~4294967295 범위에 있어야 하며 비트 유형 내에서 고유해야 합니다.\(MUST\)

비트 위치를 지정하지 않으면 자동으로 할당됩니다. "비트" 하위 설명이 처음으로 정의된 경우 할당된 값은 영\(0\)입니다. 그렇지 않은 경우 할당된 값은 현재 가장 높은 비트 위치\(즉, 부모 "유형" 문에서 현재 "비트" 하위 문 앞의 암시적 또는 명시적 가장 높은 비트 위치\)보다 1 더 큽니다.

"비트" 문에 "if-feature" 문이 있어도 자동으로 할당된 위치에는 영향을 미치지 않습니다.

현재 가장 높은 비트 위치 값이 4294967295와 같은 경우 현재 가장 높은 위치 값을 가진 항목 다음의 "비트" 하위 설명에 대해 위치 값을 지정해야 합니다.\(MUST\)

기존 비트 유형이 제한되는 경우 "위치" 문은 기본 유형과 동일한 값을 갖거나 존재하지 않아야 합니다. 이 경우 값은 기본 유형과 동일합니다.\(MUST\)

---
#### **9.7.5.  Usage Example**

다음과 같은 typedef 및 리프가 제공됩니다.

```text
     typedef mybits-type {
       type bits {
         bit disable-nagle {
           position 0;
         }
         bit auto-sense-speed {
           position 1;
         }
         bit ten-mb-only {
           position 2;
         }
       }
     }

     leaf mybits {
       type mybits-type;
       default "auto-sense-speed";
     }
```

비트 값이 비활성화-nagle 및 10MB 전용으로 설정된 이 리프의 어휘 표현은 다음과 같습니다.

```text
     <mybits>disable-nagle ten-mb-only</mybits>
```

다음 예에서는 이 유형의 법적 개선을 보여줍니다.

```text
     type mybits-type {
       // legal bit refinement
       bit disable-nagle {
         position 0;
       }
       bit auto-sense-speed {
         position 1;
       }
     }
```

다음 수정은 불법입니다.

```text
     type mybits-type {
       // illegal bit refinement
       bit disable-nagle {
         position 2; // illegal position change
       }
       bit hundred-mb-only; // illegal addition of new name
     }
```

---
### **9.8.  The binary Built-In Type**

바이너리 내장 유형은 모든 바이너리 데이터, 즉 일련의 옥텟을 나타냅니다.

---
#### **9.8.1.  Restrictions**

바이너리 유형은 "length"\(9.4.4절\) 문으로 제한될 수 있습니다. 이진 값의 길이는 포함된 옥텟 수입니다.

---
#### **9.8.2.  Lexical Representation**

바이너리 값은 base64 인코딩 방식으로 인코딩됩니다\(\[RFC4648\]의 섹션 4 참조\).

---
#### **9.8.3.  Canonical Form**

이진 값의 표준 형식은 \[RFC4648\]의 "Base 64 인코딩" 규칙을 따릅니다.

---
### **9.9.  The leafref Built-In Type**

leafref 내장 유형은 스키마 트리의 일부 리프 또는 리프 목록 노드의 값 공간으로 제한되며 선택적으로 데이터 트리의 해당 인스턴스 노드에 의해 추가로 제한됩니다. "경로" 하위 설명\(9.9.2절\)은 스키마 트리에서 참조된 리프 또는 리프 목록 노드를 식별하는 데 사용됩니다. 참조 노드의 값 공간은 참조 노드의 값 공간입니다.

"require-instance" 속성\(섹션 9.9.3\)이 "true"인 경우 데이터 트리에 노드가 있거나 사용 중인 기본값이 있는 노드가 있어야 합니다\(섹션 7.6.1 및 7.7.2 참조\). 유효한 데이터 트리의 leafref 값과 동일한 값을 가진 참조된 스키마 트리 리프 또는 리프 목록 노드의 것입니다.\(MUST\)

참조 노드가 구성 데이터를 나타내고 "require-instance" 속성\(9.9.3절\)이 "true"인 경우 참조 노드도 구성을 나타내야 합니다\(MUST\).\(MUST\)

리프 참조의 원형 체인이 있어서는 안 됩니다.\(MUST NOT\)

리프 참조가 참조하는 리프가 하나 이상의 기능을 기반으로 하는 조건부인 경우\(섹션 7.20.2 참조\), 리프 참조 유형이 있는 리프도 최소한 동일한 기능 집합을 기반으로 하는 조건부여야 합니다.\(MUST\)

---
#### **9.9.1.  Restrictions**

리프 참조는 "require-instance" 문\(9.9.3절\)을 사용하여 제한할 수 있습니다.

---
#### **9.9.2.  The "path" Statement**

유형이 "leafref"인 경우 "type" 문의 하위 설명인 "path" 문이 있어야 합니다. 리프 또는 리프 목록 노드를 참조해야 하는 문자열을 인수로 사용합니다.\(MUST, MUST\)

경로 인수의 구문은 XPath 축약 구문의 하위 집합입니다. 조건자는 목록 항목의 키 노드 값을 제한하는 데에만 사용됩니다. 각 조건자는 키당 정확히 하나의 동일성 테스트로 구성되며 목록에 여러 키가 있는 경우 여러 개의 인접한 조건자가 존재할 수 있습니다. 구문은 섹션 14의 "path-arg" 규칙에 의해 공식적으로 정의됩니다.\(MAY\)

조건자는 리프 인스턴스를 고유하게 식별하기 위해 둘 이상의 키 참조가 필요한 경우에만 사용됩니다. 이는 목록에 여러 키가 있거나 목록의 키가 아닌 리프에 대한 참조가 필요한 경우에 발생합니다. 이러한 경우 일반적으로 여러 리프 참조가 지정되고 조건자를 사용하여 이를 하나로 묶습니다.

"경로" 표현식은 0개, 1개 또는 그 이상의 노드로 구성된 노드 세트로 평가됩니다. "require-instance" 속성이 "true"인 경우 이 노드 세트는 비어 있지 않아야 합니다.\(MUST\)

"경로" XPath 표현식은 섹션 6.4.1의 정의 외에도 다음 컨텍스트에서 개념적으로 평가됩니다.

o "경로" 문이 typedef 내에 정의된 경우 컨텍스트 노드는 typedef를 참조하는 데이터 트리의 리프 또는 리프 목록 노드입니다.

o 그렇지 않은 경우 컨텍스트 노드는 "경로" 문이 정의된 데이터 트리의 노드입니다.

---
#### **9.9.3.  The "require-instance" Statement**

"type" 문에 대한 하위 설명인 "require-instance" 문은 유형이 "instance-identifier" 또는 "leafref"인 경우 존재할 수 있습니다. "true" 또는 "false" 문자열을 인수로 사용합니다. 이 문이 없으면 기본값은 "true"입니다.\(MAY\)

"require-instance"가 "true"인 경우 데이터가 유효하려면 참조되는 인스턴스가 반드시 존재해야 함을 의미합니다. 이 제약은 섹션 8의 규칙에 따라 시행됩니다.\(MUST\)

"require-instance"가 "false"인 경우 참조되는 인스턴스가 유효한 데이터에 존재할 수 있음을 의미합니다.\(MAY\)

---
#### **9.9.4.  Lexical Representation**

leafref 값은 참조하는 리프가 해당 값을 나타내는 것과 동일한 방식으로 어휘적으로 표현됩니다.

---
#### **9.9.5.  Canonical Form**

리프 참조의 정식 형식은 참조하는 리프의 정식 형식과 동일합니다.

---
#### **9.9.6.  Usage Example**

다음 목록을 사용하세요.

```text
     list interface {
       key "name";
       leaf name {
         type string;
       }
       leaf admin-status {
         type admin-status;
       }
       list address {
         key "ip";
         leaf ip {
           type yang:ip-address;
         }
       }
     }
```

다음 리프 참조는 기존 인터페이스를 나타냅니다.

```text
     leaf mgmt-interface {
       type leafref {
         path "../interface/name";
       }
     }
```

해당 XML 조각의 예:

```text
     <interface>
       <name>eth0</name>
     </interface>
     <interface>
       <name>lo</name>
     </interface>

     <mgmt-interface>eth0</mgmt-interface>
```

다음 리프 참조는 인터페이스의 기존 주소를 나타냅니다.

```text
     container default-address {
       leaf ifname {
         type leafref {
           path "../../interface/name";
         }
       }
       leaf address {
         type leafref {
           path "../../interface[name = current()/../ifname]"
              + "/address/ip";
         }
       }
     }
```

해당 XML 조각의 예:

```text
     <interface>
       <name>eth0</name>
       <admin-status>up</admin-status>
       <address>
         <ip>192.0.2.1</ip>
       </address>
       <address>
         <ip>192.0.2.2</ip>
       </address>
     </interface>
     <interface>
       <name>lo</name>
       <admin-status>up</admin-status>
       <address>
         <ip>127.0.0.1</ip>
       </address>
     </interface>

     <default-address>
       <ifname>eth0</ifname>
       <address>192.0.2.2</address>
     </default-address>
```

다음 목록에서는 해당 키 중 하나에 대해 leafref를 사용합니다. 이는 관계형 데이터베이스의 외래 키와 유사합니다.

```text
     list packet-filter {
       key "if-name filter-id";
       leaf if-name {
         type leafref {
           path "/interface/name";
         }
       }
       leaf filter-id {
         type uint32;
       }
       ...
     }
```

해당 XML 조각의 예:

```text
     <interface>
       <name>eth0</name>
       <admin-status>up</admin-status>
       <address>
         <ip>192.0.2.1</ip>
       </address>
       <address>
         <ip>192.0.2.2</ip>
       </address>
     </interface>

     <packet-filter>
       <if-name>eth0</if-name>
       <filter-id>1</filter-id>
       ...
     </packet-filter>
     <packet-filter>
       <if-name>eth0</if-name>
       <filter-id>2</filter-id>
       ...
     </packet-filter>
```

다음 알림은 기존 관리 상태를 참조하는 두 개의 리프 참조를 정의합니다.

```text
     notification link-failure {
       leaf if-name {
         type leafref {
           path "/interface/name";
         }
       }
       leaf admin-status {
         type leafref {
           path "/interface[name = current()/../if-name]"
              + "/admin-status";
         }
       }
     }
```

해당 XML 알림의 예:

```text
     <notification
       xmlns="urn:ietf:params:xml:ns:netconf:notification:1.0">
       <eventTime>2008-04-01T00:01:00Z</eventTime>
       <link-failure xmlns="urn:example:system">
         <if-name>eth0</if-name>
         <admin-status>up</admin-status>
       </link-failure>
     </notification>
```

---
### **9.10.  The identityref Built-In Type**

Identityref 내장 유형은 기존 ID를 참조하는 데 사용됩니다\(섹션 7.18 참조\).

---
#### **9.10.1.  Restrictions**

Identityref는 제한될 수 없습니다.

---
#### **9.10.2.  The identityref's "base" Statement**

"type" 문에 대한 하위 문인 "base" 문은 유형이 "identityref"인 경우 적어도 한 번 이상 존재해야 합니다. 인수는 "identity" 문으로 정의된 ID의 이름입니다. ID 이름에 접두사가 있으면 해당 접두사와 함께 가져온 모듈에 정의된 ID를 나타냅니다. 그렇지 않으면 일치하는 이름을 가진 ID가 현재 모듈이나 포함된 하위 모듈에 정의되어야 합니다.\(MUST, MUST\)

IDref의 유효한 값은 모든 IDref의 기본 ID에서 파생된 모든 ID입니다. 특정 서버에서 유효한 값은 서버에서 구현된 모듈에 정의된 ID 집합으로 추가로 제한됩니다.

---
#### **9.10.3.  Lexical Representation**

Identityref는 \[XML-NAMES\]에 정의된 대로 참조된 ID의 정규화된 이름으로 어휘적으로 표현됩니다. 접두사가 없으면 Identityref의 네임스페이스는 Identityref 값을 포함하는 요소에 적용되는 기본 네임스페이스입니다.

"default" 문을 사용하여 IDref에 기본값이 제공되면 기본값의 ID 이름에 접두사가 있을 수 있습니다. ID 이름에 접두사가 있는 경우 해당 접두사와 함께 가져온 모듈에 정의된 ID를 참조하거나 ID가 ID에 정의된 경우 현재 모듈의 접두사를 나타냅니다.\(MAY\)

현재 모듈 또는 해당 하위 모듈 중 하나입니다. 그렇지 않으면 일치하는 이름을 가진 ID가 현재 모듈이나 해당 하위 모듈 중 하나에서 정의되어야 합니다.\(MUST\)

"must" 또는 "when" XPath 표현식에서 "identityref" 유형 노드의 문자열 값은 접두사가 있는 참조 ID의 정규화된 이름입니다. 참조된 ID가 가져온 모듈에 정의된 경우 문자열 값의 접두사는 해당 "import" 문에 정의된 접두사입니다. 그렇지 않은 경우 문자열 값의 접두사는 현재 모듈의 접두사입니다.

---
#### **9.10.4.  Canonical Form**

어휘 형식은 값이 발생하는 XML 컨텍스트에 따라 달라지므로 이 유형에는 표준 형식이 없습니다.

---
#### **9.10.5.  Usage Example**

섹션 7.18.3의 ID 정의와 다음 모듈을 사용합니다.

```text
     module example-my-crypto {
       yang-version 1.1;
       namespace "urn:example:my-crypto";
       prefix mc;

       import "example-crypto-base" {
         prefix "crypto";
       }

       identity aes {
         base "crypto:crypto-alg";
       }

       leaf crypto {
         type identityref {
           base "crypto:crypto-alg";
         }
       }

       container aes-parameters {
         when "../crypto = 'mc:aes'";
         ...
       }
     }
```

다음은 값이 "des" 모듈에 정의된 "des3" ID인 경우 리프 "crypto"를 인코딩할 수 있는 방법의 예입니다.

```text
     <crypto xmlns:des="urn:example:des">des:des3</crypto>
```

인코딩에 사용되는 모든 접두사는 각 인스턴스 인코딩에 대해 로컬입니다. 이는 동일한 IDref가 다른 구현에 따라 다르게 인코딩될 수 있음을 의미합니다. 예를 들어 다음 예제에서는 위와 동일한 리프를 인코딩합니다.

```text
     <crypto xmlns:x="urn:example:des">x:des3</crypto>
```

"crypto" 리프의 값이 "example-my-crypto" 모듈에 정의된 "aes"인 경우 다음과 같이 인코딩될 수 있습니다.

```text
     <crypto xmlns:mc="urn:example:my-crypto">mc:aes</crypto>
```

또는 기본 네임스페이스를 사용하여:

```text
     <crypto>aes</crypto>
```

---
### **9.11.  The empty Built-In Type**

빈 내장 유형은 값이 없는 리프를 나타냅니다. 존재 여부에 따라 정보를 전달합니다.

빈 유형은 기본값을 가질 수 없습니다.

---
#### **9.11.1.  Restrictions**

빈 유형은 제한할 수 없습니다.

---
#### **9.11.2.  Lexical Representation**

```text
   Not applicable.
```

---
#### **9.11.3.  Canonical Form**

```text
   Not applicable.
```

---
#### **9.11.4.  Usage Example**

다음 리프를 사용합니다.

```text
     leaf enable-qos {
       type empty;
     }
```

다음은 리프가 존재하는 경우 유효한 인코딩의 예입니다.

```text
     <enable-qos/>
```

---
### **9.12.  The union Built-In Type**

공용체 내장 유형은 해당 멤버 유형 중 하나에 해당하는 값을 나타냅니다.

유형이 "union"인 경우 "type" 문\(7.4절\)이 있어야 합니다. Union의 각 구성원 유형을 지정하는 데 반복적으로 사용됩니다. 멤버 유형의 이름인 문자열을 인수로 사용합니다.\(MUST\)

멤버 유형은 기본 제공 유형이나 파생 유형일 수 있습니다.

XML 인코딩을 생성할 때 값은 해당 값이 속한 멤버 유형의 규칙에 따라 인코딩됩니다. XML 인코딩을 해석할 때 일치하는 항목이 발견될 때까지 "type" 문에 지정된 순서대로 각 멤버 유형에 대해 값의 유효성이 연속적으로 확인됩니다. 일치하는 유형은 검증된 노드 값의 유형이 되며 인코딩은 해당 유형의 규칙에 따라 해석됩니다.

멤버 유형에 정의된 기본값이나 "단위" 속성은 공용체 유형에 의해 상속되지 않습니다.

---
#### **9.12.1.  Restrictions**

노동조합은 제한될 수 없습니다. 그러나 각 회원 유형은 섹션 9에 정의된 규칙에 따라 제한될 수 있습니다.

---
#### **9.12.2.  Lexical Representation**

공용체의 어휘 표현은 멤버 유형 중 하나의 표현에 해당하는 값입니다.

---
#### **9.12.3.  Canonical Form**

공용체 값의 정식 형식은 값 멤버 유형의 정식 형식과 동일합니다.

---
#### **9.12.4.  Usage Example**

다음은 int32와 열거형의 결합입니다.

```text
     type union {
       type int32;
       type enumeration {
         enum "unbounded";
       }
     }
```

멤버 유형이 "require-instance" 속성\(섹션 9.9.3\)이 "true"인 leafref인 경우 주의해야 합니다. 이러한 유형의 리프가 기존 인스턴스를 참조하는 경우 대상 인스턴스가 삭제되면 리프 값의 유효성을 다시 검사해야 합니다. 예를 들어 다음과 같은 정의를 사용합니다.

```text
     list filter {
       key name;
       leaf name {
         type string;
       }
       ...
     }

     leaf outbound-filter {
       type union {
         type leafref {
           path "/filter/name";
         }
         type enumeration {
           enum default-filter;
         }
       }
     }
```

필터 목록에 "http"라는 이름의 항목이 있고 outbound-filter 리프에 다음 값이 있다고 가정합니다.

```text
     <filter>
       <name>http</name>
     </filter>
     <outbound-filter>http</outbound-filter>
```

필터 항목 "http"가 제거되면 outbound-filter 리프의 값이 leafref와 일치하지 않으며 다음 멤버 유형이 확인됩니다. 현재 값\("http"\)이 열거형과 일치하지 않으므로 결과 구성이 유효하지 않습니다.

공용체의 두 번째 멤버 유형이 열거형이 아닌 "문자열" 유형인 경우 현재 값이 일치하고 결과 구성이 유효합니다.

---
### **9.13.  The instance-identifier Built-In Type**

인스턴스 식별자 내장 유형은 데이터 트리에서 특정 인스턴스 노드를 고유하게 식별하는 데 사용됩니다.

인스턴스 식별자의 구문은 섹션 14의 "인스턴스 식별자" 규칙에 의해 공식적으로 정의된 XPath 축약 구문의 하위 집합입니다. 이는 데이터 트리에서 노드를 고유하게 식별하는 데 사용됩니다. 조건자는 목록 항목의 키 노드 값, 리프 목록 항목의 값 또는 키가 없는 목록의 위치 인덱스를 지정하는 데에만 사용됩니다. 키로 목록 항목을 식별하기 위해 각 조건자는 키당 하나의 동일성 테스트로 구성되며 각 키에는 해당 조건자가 있어야 합니다. 키 유형이 "비어 있음"인 경우 길이가 0인 문자열\(""\)로 표시됩니다.\(MUST\)

인스턴스 식별자 유형이 있는 리프가 구성 데이터를 나타내고 "require-instance" 속성\(9.9.3절\)이 "true"인 경우 참조하는 노드도 구성을 나타내야 합니다. 이러한 리프는 유효한 데이터에 제약을 가합니다. 이러한 모든 리프 노드는 데이터가 유효하려면 사용 중인 기본값\(섹션 7.6.1 및 7.7.2 참조\)으로 기존 노드나 리프 또는 리프 목록 노드를 참조해야 합니다. 이 제약은 섹션 8의 규칙에 따라 시행됩니다.\(MUST, MUST\)

"instance-identifier" XPath 표현식은 섹션 6.4.1의 정의 외에도 다음 컨텍스트에서 개념적으로 평가됩니다.

o 컨텍스트 노드는 액세스 가능한 트리의 루트 노드입니다.

---
#### **9.13.1.  Restrictions**

인스턴스 식별자는 "require-instance" 문\(9.9.3절\)을 사용하여 제한할 수 있습니다.

---
#### **9.13.2.  Lexical Representation**

인스턴스 식별자 값은 어휘적으로 문자열로 표현됩니다. 인스턴스 식별자 값의 모든 노드 이름은 명시적인 네임스페이스 접두사로 한정되어야 하며 이러한 접두사는 인스턴스 식별자의 XML 요소에 있는 XML 네임스페이스 범위에서 선언되어야 합니다.\(MUST\)

인코딩에 사용되는 모든 접두사는 각 인스턴스 인코딩에 대해 로컬입니다. 이는 동일한 인스턴스 식별자가 다른 구현에 따라 다르게 인코딩될 수 있음을 의미합니다.

---
#### **9.13.3.  Canonical Form**

어휘 형식은 값이 발생하는 XML 컨텍스트에 따라 달라지므로 이 유형에는 표준 형식이 없습니다.

---
#### **9.13.4.  Usage Example**

다음은 인스턴스 식별자의 예입니다.

/\* 컨테이너의 인스턴스 식별자 \*/ /ex:system/ex:services/ex:ssh

/\* 리프에 대한 인스턴스 식별자 \*/ /ex:system/ex:services/ex:ssh/ex:port

/\* 목록 항목에 대한 인스턴스 식별자 \*/ /ex:system/ex:user\[ex:name='fred'\]

/\* 목록 항목의 리프에 대한 인스턴스 식별자 \*/ /ex:system/ex:user\[ex:name='fred'\]/ex:type

/\* 두 개의 키가 있는 목록 항목에 대한 인스턴스 식별자 \*/ /ex:system/ex:server\[ex:ip='192.0.2.1'\]\[ex:port='80'\]

/\* 두 번째 항목이 있는 목록 항목의 인스턴스 식별자

- 키\("활성화됨"\)는 "비어 있음" 유형입니다. \*/ /ex:system/ex:service\[ex:name='foo'\]\[ex:enabled=''\]

/\* 리프 목록 항목의 인스턴스 식별자 \*/ /ex:system/ex:services/ex:ssh/ex:cipher\[.='blowfish-cbc'\]

/\* 키가 없는 목록 항목의 인스턴스 식별자 \*/ /ex:stats/ex:port\[3\]

---
## **10.  XPath Functions**

이 문서에서는 두 개의 일반 XPath 함수와 다섯 개의 YANG 유형별 XPath 함수를 정의합니다. 함수 서명은 \[XPATH\]에 사용된 구문으로 지정됩니다.

---
### **10.1.  Function for Node Sets**
---
#### **10.1.1.  current()**

```text
     node-set current()
```

current\(\) 함수는 입력 매개변수를 사용하지 않으며 초기 컨텍스트 노드가 유일한 멤버인 노드 세트를 반환합니다.

---
##### **10.1.1.1.  Usage Example**

이 목록을 사용하면 다음과 같습니다.

```text
     list interface {
       key "name";
       ...
       leaf enabled {
         type boolean;
       }
       ...
     }
```

다음 리프에서는 참조된 인터페이스가 활성화되도록 보장하는 "필수" 표현식을 정의합니다.

```text
     leaf outgoing-interface {
       type leafref {
         path "/interface/name";
       }
       must '/interface[name=current()]/enabled = "true"';
     }
```

---
### **10.2.  Function for Strings**
---
#### **10.2.1.  re-match()**

```text
     boolean re-match(string subject, string pattern)
```

re-match\(\) 함수는 "subject" 문자열이 정규식 "pattern"과 일치하는 경우 "true"를 반환합니다. 그렇지 않으면 "false"를 반환합니다.

re-match\(\) 함수는 문자열이 주어진 정규식과 일치하는지 확인합니다. 사용되는 정규식은 XML 스키마 정규식 \[XSD-TYPES\]입니다. 여기에는 머리와 꼬리에 정규식을 암시적으로 고정하는 것이 포함됩니다.

---
##### **10.2.1.1.  Usage Example**

표현식:

```text
     re-match("1.22.333", "\d{1,3}\.\d{1,3}\.\d{1,3}")

   returns "true".
```

eth0.<number\>라는 모든 논리적 인터페이스를 계산하려면 다음을 수행합니다.

```text
     count(/interface[re-match(name, "eth0\.\d+")])
```

---
### **10.3.  Function for the YANG Types "leafref" and "instance-identifier"**
---
#### **10.3.1.  deref()**

```text
     node-set deref(node-set nodes)
```

deref\(\) 함수는 "nodes" 인수에서 문서 순서의 첫 번째 노드에 의해 정의된 참조를 따르고 참조하는 노드를 반환합니다.

첫 번째 인수 노드가 "instance-identifier" 유형인 경우 함수는 인스턴스 식별자가 참조하는 단일 노드\(존재하는 경우\)를 포함하는 노드 세트를 반환합니다. 해당 노드가 없으면 빈 노드 세트가 반환됩니다.

첫 번째 인수 노드가 "leafref" 유형인 경우 함수는 리프 참조가 참조하는 노드를 포함하는 노드 집합을 반환합니다. 특히 이 세트에는 첫 번째 인수 노드와 동일한 값을 갖는 leafref의 "경로" 문\(9.9.2절\)에 의해 선택된 노드가 포함됩니다.

첫 번째 인수 노드가 다른 유형이면 빈 노드 세트가 반환됩니다.

---
##### **10.3.1.1.  Usage Example**

```text
     list interface {
       key "name type";
       leaf name { ... }
       leaf type { ... }
       leaf enabled {
         type boolean;
       }
       ...
     }

     container mgmt-interface {
       leaf name {
         type leafref {
           path "/interface/name";
         }
       }
       leaf type {
         type leafref {
           path "/interface[name=current()/../name]/type";
         }
         must 'deref(.)/../enabled = "true"' {
           error-message
             "The management interface cannot be disabled.";
         }
       }
     }
```

---
### **10.4.  Functions for the YANG Type "identityref"**
---
#### **10.4.1.  derived-from()**

```text
     boolean derived-from(node-set nodes, string identity)
```

파생된 from\(\) 함수는 인수 "nodes"의 노드가 "identityref" 유형의 노드이고 해당 값이 ID "identity"에서 파생된 ID인 경우\(섹션 7.18.2 참조\) "true"를 반환합니다. ; 그렇지 않으면 "false"를 반환합니다.

매개변수 "identity"는 섹션 14의 "identifier-ref" 규칙과 일치하는 문자열입니다. ID에 접두사가 있는 경우 해당 접두사와 함께 가져온 모듈에 정의된 ID를 참조하거나, 다음과 같은 경우 로컬 모듈을 참조합니다. 접두사는 로컬 모듈의 접두사와 일치합니다. 접두사가 없는 경우 ID는 현재 모듈 또는 포함된 하위 모듈에 정의된 ID를 참조합니다.

---
##### **10.4.1.1.  Usage Example**

```text
     module example-interface {
       yang-version 1.1;

       ...
       identity interface-type;

       identity ethernet {
         base interface-type;
       }

       identity fast-ethernet {
         base ethernet;
       }

       identity gigabit-ethernet {
         base ethernet;
       }

       list interface {
         key name;
         ...
         leaf type {
           type identityref {
             base interface-type;
           }
         }
         ...
       }

       augment "/interface" {
         when 'derived-from(type, "exif:ethernet")';
         // generic Ethernet definitions here
       }
       ...
     }
```

---
#### **10.4.2.  derived-from-or-self()**

```text
     boolean derived-from-or-self(node-set nodes, string identity)
```

Derived-from-or-self\(\) 함수는 인수 "nodes"의 노드가 "identityref" 유형의 노드이고 해당 값이 동일하거나 파생된 ID인 경우 "true"를 반환합니다\(섹션 7.18.1 참조\). 2\) 신원 "신원"; 그렇지 않으면 "false"를 반환합니다.

매개변수 "identity"는 섹션 14의 "identifier-ref" 규칙과 일치하는 문자열입니다. ID에 접두사가 있는 경우 해당 접두사와 함께 가져온 모듈에 정의된 ID를 참조하거나, 다음과 같은 경우 로컬 모듈을 참조합니다. 접두사는 로컬 모듈의 접두사와 일치합니다. 접두사가 없는 경우 ID는 현재 모듈 또는 포함된 하위 모듈에 정의된 ID를 참조합니다.

---
##### **10.4.2.1.  Usage Example**

섹션 10.4.1.1에 정의된 모듈은 다음을 가질 수도 있습니다:

```text
       augment "/interface" {
         when 'derived-from-or-self(type, "exif:fast-ethernet");
         // Fast-Ethernet-specific definitions here
       }
```

---
### **10.5.  Function for the YANG Type "enumeration"**
---
#### **10.5.1.  enum-value()**

```text
     number enum-value(node-set nodes)
```

enum-value\(\) 함수는 "nodes" 인수에서 문서 순서의 첫 번째 노드가 "enumeration" 유형의 노드인지 확인하고 열거형의 정수 값을 반환합니다. "nodes" 노드 세트가 비어 있거나 "nodes"의 첫 번째 노드가 "열거" 유형이 아닌 경우 NaN\(숫자 아님\)을 반환합니다.

---
##### **10.5.1.1.  Usage Example**

이 데이터 모델을 사용하면 다음과 같습니다.

```text
     list alarm {
       ...
       leaf severity {
         type enumeration {
           enum cleared {
             value 1;
           }
           enum indeterminate {
             value 2;
           }
           enum minor {
             value 3;
           }
           enum warning {
             value 4;
           }
           enum major {
             value 5;
           }
           enum critical {
             value 6;
           }
         }
       }
     }
```

다음 XPath 표현식은 심각도가 "major" 이상인 경보만 선택합니다.

```text
     /alarm[enum-value(severity) >= 5]
```

---
### **10.6.  Function for the YANG Type "bits"**
---
#### **10.6.1.  bit-is-set()**

```text
     boolean bit-is-set(node-set nodes, string bit-name)
```

인수 "nodes"의 문서 순서에서 첫 번째 노드가 "bits" 유형의 노드이고 해당 값에 "bit-name" 비트가 설정된 경우 bit-is-set\(\) 함수는 "true"를 반환합니다. 그렇지 않으면 "false"를 반환합니다.

---
##### **10.6.1.1.  Usage Example**

인터페이스에 다음 리프가 있는 경우:

```text
     leaf flags {
       type bits {
         bit UP;
         bit PROMISCUOUS
         bit DISABLED;
       }
      }
```

다음 XPath 표현식을 사용하여 UP 플래그가 설정된 모든 인터페이스를 선택할 수 있습니다.

```text
     /interface[bit-is-set(flags, "UP")]
```

---
## **11.  Updating a Module**

모듈을 통해 경험이 쌓이면 해당 모듈을 수정하는 것이 바람직할 수 있습니다. 그러나 원래 사양을 사용하는 클라이언트와 업데이트된 사양을 사용하는 서버 간에 상호 운용성 문제를 일으킬 가능성이 있는 경우 게시된 모듈에 대한 변경은 허용되지 않습니다.

게시된 변경 사항의 경우 새로운 "개정" 설명\(섹션 7.1.9\)이 기존 "개정" 설명 앞에 포함되어야 합니다. 기존 "개정" 설명이 없는 경우 새 개정을 식별하기 위해 하나를 추가해야 합니다. 또한 필요한 모든 변경 사항은 "조직" 및 "연락처" 문\(섹션 7.1.7 및 7.1.8\)을 포함한 모든 메타데이터 문에 적용되어야 합니다.\(MUST, MUST, MUST\)

모듈에 포함된 정의는 다른 모듈에서 가져올 수 있으며 모듈 이름을 통해 "import" 문에서 참조됩니다. 따라서 모듈 이름은 변경하면 안 됩니다. 게다가 모든 XML 요소는 네임스페이스에 의해 한정되므로 "네임스페이스" 문은 변경되어서는 안 됩니다.\(MUST NOT, MUST NOT\)

더 이상 사용되지 않는 정의는 게시된 모듈에서 제거되어서는 안 됩니다. 그 이유는 해당 식별자가 다른 모듈에서 계속 참조될 수 있기 때문입니다.\(MUST NOT\)

게시된 모듈의 정의는 다음 방법 중 하나로 수정될 수 있습니다.

o "열거형" 유형에는 이전 열거형의 값이 변경되지 않는 경우 새 열거형이 추가될 수 있습니다. 기존 열거형 앞에 새 열거형을 삽입하거나 기존 열거형을 재정렬하면 명시적인 값이 할당되지 않는 한 기존 열거형에 대한 새 값이 생성됩니다.

o "비트" 유형에는 이전 비트 위치가 변경되지 않는 경우 새 비트가 추가될 수 있습니다. 기존 비트 앞에 새 비트를 삽입하거나 기존 비트를 재정렬하면 명시적인 위치가 할당되지 않은 한 기존 비트에 대한 새 위치가 생성됩니다.

o "범위", "길이" 또는 "패턴" 문은 허용되는 값 공간을 확장할 수 있습니다.

o "기본" 문은 기본값이 없는 리프에 추가될 수 있습니다\(직접 또는 해당 유형을 통해 간접적으로\).

o "단위" 문구를 추가할 수 있습니다.

o "참조" 진술이 추가되거나 업데이트될 수 있습니다.

o "필수" 문은 제거되거나 제약 조건이 완화될 수 있습니다.

o "언제" 문은 제거되거나 제약 조건이 완화될 수 있습니다.

o "필수" 진술은 제거되거나 "참"에서 "거짓"으로 변경될 수 있습니다.

o "최소 요소" 문은 제거되거나 더 적은 요소를 요구하도록 변경될 수 있습니다.

o "최대 요소" 문은 제거되거나 더 많은 요소를 허용하도록 변경될 수 있습니다.

o 정의의 의미를 변경하지 않고 "설명" 문을 추가하거나 변경할 수 있습니다.

o "기본" 진술은 "신원" 진술에 추가될 수 있습니다.

o "base" 문이 하나 이상 남아 있는 경우 "identityref" 유형에서 "base" 문을 제거할 수 있습니다.

o 새로운 형식 정의, 그룹화, rpcs, 알림, 확장,

- 기능, 아이덴티티가 추가될 수 있습니다.

o 기존 노드나 모듈이나 하위 모듈의 최상위 수준에 필수 노드\(섹션 3\)를 추가하지 않거나 조건부로 새 기능에 종속되는 경우\(예: "if"가 있는 경우\) 새로운 데이터 정의 문을 추가할 수 있습니다. -feature" 문은 새로운 기능을 나타냅니다.\)

o 새로운 "사례" 설명이 추가될 수 있습니다.

o 상태 데이터를 나타내는 노드는 필수 사항이 아닌 경우 구성을 나타내도록 변경될 수 있습니다\(섹션 3\).

o "if-feature" 문은 해당 노드가 필수가 아닌 경우 제거될 수 있습니다\(섹션 3\).

o "상태" 설명이 추가되거나 "현재"에서 "더 이상 사용되지 않음" 또는 "구식"으로 변경되거나 "더 이상 사용되지 않음"에서 "구식"으로 변경될 수 있습니다.

o "유형" 문은 해당 유형의 구문이나 의미를 변경하지 않는 다른 "유형" 문으로 대체될 수 있습니다. 예를 들어 인라인 유형 정의는 typedef로 대체될 수 있지만 int8 유형은 int16으로 대체될 수 없습니다. 구문이 변경되기 때문입니다.

o 모든 데이터 정의 노드 세트는 구문상 및 의미상 동등한 노드의 다른 세트로 대체될 수 있습니다. 예를 들어, 리프 세트는 동일한 리프가 있는 그룹의 "uses" 문으로 대체될 수 있습니다.

o 모듈의 정의가 여기에서 허용된 것 이외의 방식으로 변경되지 않는 한, 모듈은 하위 모듈 세트로 분할되거나 하위 모듈이 제거될 수 있습니다.

o 접두사의 모든 로컬 사용도 변경되는 경우 "접두사" 문은 변경될 수 있습니다.

그렇지 않고 이전 정의의 의미가 변경된 경우\(즉, 위에서 구체적으로 허용된 정의 이외의 정의에 편집 외 변경이 발생한 경우\) 이는 새로운 식별자를 사용하는 새로운 정의를 통해 달성되어야 합니다.\(MUST\)

데이터 정의 문을 하위 문으로 포함하는 문에서 해당 데이터 정의 하위 문은 재정렬되어서는 안 됩니다. 새로운 데이터 정의 문이 추가되면 기존 하위 설명 순서의 어느 위치에나 추가할 수 있습니다.\(MUST NOT\)

---
## **12.  Coexistence with YANG Version 1**

YANG 버전 1.1 모듈은 YANG 버전 1 하위 모듈을 포함하면 안 되며, YANG 버전 1 모듈은 YANG 버전 1.1 하위 모듈을 포함하면 안 됩니다.\(MUST NOT\)

YANG 버전 1 모듈 또는 하위 모듈은 개정판별로 YANG 버전 1.1 모듈을 가져와서는 안 됩니다.\(MUST NOT\)

YANG 버전 1.1 모듈 또는 하위 모듈은 개정판별로 YANG 버전 1 모듈을 가져올 수 있습니다.\(MAY\)

YANG 버전 1 모듈 A가 수정 없이 모듈 B를 가져오고 모듈 B가 YANG 버전 1.1로 업데이트되는 경우 서버는 두 모듈\(A 및 B\)을 동시에 구현할 수 있습니다. 이러한 경우 NETCONF 서버는 섹션 5.6.4에 정의된 규칙을 사용하여 두 모듈을 모두 광고해야 하며 \[RFC6020\]에 정의된 규칙에 따라 모듈 A와 YANG 버전 1로 지정된 모듈 B의 최신 개정판을 광고해야 합니다.\(MAY, MUST\)

이 규칙은 YANG 버전 1.1 모듈과 함께 기존 YANG 버전 1 모듈의 구현을 허용하기 위해 존재합니다. 이 규칙이 없으면 단일 모듈을 YANG 버전 1.1로 업데이트하면 이를 가져오는 모듈에 계단식 효과가 발생하여 모든 모듈도 YANG 버전 1.1로 업데이트해야 하는 식입니다.

---
## **13.  YIN**

YANG 모듈은 YIN이라는 대체 XML 기반 구문으로 변환될 수 있습니다. 번역된 모듈을 YIN 모듈이라고 합니다. 이 섹션에서는 두 형식 간의 양방향 매핑 규칙을 설명합니다.

YANG 및 YIN 형식은 서로 다른 표기법을 사용하여 동일한 정보를 포함합니다. YIN 표기법을 사용하면 개발자는 YANG 데이터 모델을 XML로 표현할 수 있으므로 데이터 필터링 및 유효성 검사, 자동 코드 및 문서 생성, 기타 작업을 위한 풍부한 XML 기반 도구 세트를 사용할 수 있습니다. XSLT 또는 XML 유효성 검사기와 같은 도구를 활용할 수 있습니다.

YANG과 YIN 간의 매핑은 모델의 정보 내용을 수정하지 않습니다. 주석과 공백은 유지되지 않습니다.

---
### **13.1.  Formal YIN Definition**

```text
   There is a one-to-one correspondence between YANG keywords and YIN
   elements.  The local name of a YIN element is identical to the
   corresponding YANG keyword.  This means, in particular, that the
   document element (root) of a YIN document is always <module> or
   <submodule>.
```

YANG 키워드에 해당하는 YIN 요소는 연관된 URI가 "urn:ietf:params:xml:ns:yang:yin:1"인 네임스페이스에 속합니다.

확장 키워드에 해당하는 YIN 요소는 확장 키워드가 "extension" 문을 통해 선언되는 YANG 모듈의 네임스페이스에 속합니다.

모든 YIN 요소의 이름은 \[XML-NAMES\]의 표준 메커니즘, 즉 "xmlns" 및 "xmlns:xxx" 특성을 사용하여 해당 네임스페이스\(위에 지정된 대로\)로 적절하게 정규화되어야 합니다.\(MUST\)

YANG 문의 인수는 YIN에서 XML 속성이나 키워드 요소의 하위 요소로 표시됩니다. 표 1은 YANG 키워드 세트에 대한 매핑을 정의합니다. 확장의 경우 인수 매핑은 "확장" 문 내에 지정됩니다\(섹션 7.19 참조\). 인수에는 다음 규칙이 적용됩니다.

o 인수가 속성으로 표시되는 경우 이 속성에는 네임스페이스가 없습니다.

o 인수가 요소로 표시되는 경우 상위 키워드 요소와 동일한 네임스페이스로 한정됩니다.

o 인수가 요소로 표시되는 경우 키워드 요소의 첫 번째 하위 요소여야 합니다.\(MUST\)

YANG 문의 하위 명령문은 키워드 요소의 \(추가\) 하위 항목으로 표시되며 상대적 순서는 YANG의 하위 명령문 순서와 동일해야 합니다.\(MUST\)

YANG의 주석은 XML 주석에 매핑될 수 있습니다.\(MAY\)

```text
            +------------------+---------------+-------------+
            | keyword          | argument name | yin-element |
            +------------------+---------------+-------------+
            | action           | name          | false       |
            | anydata          | name          | false       |
            | anyxml           | name          | false       |
            | argument         | name          | false       |
            | augment          | target-node   | false       |
            | base             | name          | false       |
            | belongs-to       | module        | false       |
            | bit              | name          | false       |
            | case             | name          | false       |
            | choice           | name          | false       |
            | config           | value         | false       |
            | contact          | text          | true        |
            | container        | name          | false       |
            | default          | value         | false       |
            | description      | text          | true        |
            | deviate          | value         | false       |
            | deviation        | target-node   | false       |
            | enum             | name          | false       |
            | error-app-tag    | value         | false       |
            | error-message    | value         | true        |
            | extension        | name          | false       |
            | feature          | name          | false       |
            | fraction-digits  | value         | false       |
            | grouping         | name          | false       |
            | identity         | name          | false       |
            | if-feature       | name          | false       |
            | import           | module        | false       |
            | include          | module        | false       |
            | input            | <no argument> | n/a         |
            | key              | value         | false       |
            | leaf             | name          | false       |
            | leaf-list        | name          | false       |
            | length           | value         | false       |
            | list             | name          | false       |
            | mandatory        | value         | false       |
            | max-elements     | value         | false       |
            | min-elements     | value         | false       |
            | modifier         | value         | false       |
            | module           | name          | false       |
            | must             | condition     | false       |
            | namespace        | uri           | false       |
            | notification     | name          | false       |
            | ordered-by       | value         | false       |
            | organization     | text          | true        |
            | output           | <no argument> | n/a         |

            | path             | value         | false       |
            | pattern          | value         | false       |
            | position         | value         | false       |
            | prefix           | value         | false       |
            | presence         | value         | false       |
            | range            | value         | false       |
            | reference        | text          | true        |
            | refine           | target-node   | false       |
            | require-instance | value         | false       |
            | revision         | date          | false       |
            | revision-date    | date          | false       |
            | rpc              | name          | false       |
            | status           | value         | false       |
            | submodule        | name          | false       |
            | type             | name          | false       |
            | typedef          | name          | false       |
            | unique           | tag           | false       |
            | units            | name          | false       |
            | uses             | name          | false       |
            | value            | value         | false       |
            | when             | condition     | false       |
            | yang-version     | value         | false       |
            | yin-element      | value         | false       |
            +------------------+---------------+-------------+

           Table 1: Mapping of Arguments of the YANG Statements
```

---
#### **13.1.1.  Usage Example**

다음 YANG 모듈:

```text
     module example-foo {
       yang-version 1.1;
       namespace "urn:example:foo";
       prefix "foo";

       import example-extensions {
         prefix "myext";
       }

       list interface {
         key "name";
         leaf name {
           type string;
         }

         leaf mtu {
           type uint32;
           description "The MTU of the interface.";
           myext:c-define "MY_MTU";
         }
       }
     }
```

여기서 확장자 "c-define"은 섹션 7.19.3에 정의되어 있으며 다음 YIN으로 변환됩니다.

```text
     <module name="example-foo"
             xmlns="urn:ietf:params:xml:ns:yang:yin:1"
             xmlns:foo="urn:example:foo"
             xmlns:myext="urn:example:extensions">

       <namespace uri="urn:example:foo"/>
       <prefix value="foo"/>

       <import module="example-extensions">
         <prefix value="myext"/>
       </import>
```

<목록 이름="인터페이스"\>

- <key value="name"/\> <leaf name="name"\> <type name="string"/\> </leaf\> <leaf name="mtu"\> <type name="uint32"/\> <설명 \> <text\>인터페이스의 MTU입니다.</text\> </description\> <myext:c-define name="MY\_MTU"/\> </leaf\> </list\> </module\>

---
## **14.  YANG ABNF Grammar**

YANG에서는 거의 모든 명령문이 순서가 없습니다. ABNF 문법 \[RFC5234\] \[RFC7405\]은 정식 순서를 정의합니다. 모듈 가독성을 높이려면 이 순서대로 절을 입력하는 것이 좋습니다.\(SHOULD\)

ABNF 문법 내에서 순서가 지정되지 않은 명령문은 주석으로 표시됩니다.

이 문법은 스캐너가 YANG 주석을 단일 공백 ​​문자로 바꾸는 것으로 가정합니다.

```text
   <CODE BEGINS> file "yang.abnf"

   module-stmt         = optsep module-keyword sep identifier-arg-str
                         optsep
                         "{" stmtsep
                             module-header-stmts
                             linkage-stmts
                             meta-stmts
                             revision-stmts
                             body-stmts
                         "}" optsep

   submodule-stmt      = optsep submodule-keyword sep identifier-arg-str
                         optsep
                         "{" stmtsep
                             submodule-header-stmts
                             linkage-stmts
                             meta-stmts
                             revision-stmts
                             body-stmts
                         "}" optsep
```

모듈 헤더-stmts = ;; 이러한 stmt는 어떤 순서로든 나타날 수 있습니다.

- 양-버전-stmt 네임스페이스-stmt 접두사-stmt

하위 모듈-헤더-stmts =

- ;; 이러한 stmt는 yang-version-stmt presents-to-stmt 순서에 관계없이 나타날 수 있습니다.

```text
   meta-stmts          = ;; these stmts can appear in any order
                         [organization-stmt]
                         [contact-stmt]
                         [description-stmt]
                         [reference-stmt]

   linkage-stmts       = ;; these stmts can appear in any order
                         *import-stmt
                         *include-stmt

   revision-stmts      = *revision-stmt

   body-stmts          = *(extension-stmt /
                           feature-stmt /
                           identity-stmt /
                           typedef-stmt /
                           grouping-stmt /
                           data-def-stmt /
                           augment-stmt /
                           rpc-stmt /
                           notification-stmt /
                           deviation-stmt)

   data-def-stmt       = container-stmt /
                         leaf-stmt /
                         leaf-list-stmt /
                         list-stmt /
                         choice-stmt /
                         anydata-stmt /
                         anyxml-stmt /
                         uses-stmt

   yang-version-stmt   = yang-version-keyword sep yang-version-arg-str
                         stmtend
```

yang-version-arg-str = < 규칙과 일치하는 문자열 \>

- < 양 버전 인수 \>

```text
   yang-version-arg    = "1.1"

   import-stmt         = import-keyword sep identifier-arg-str optsep
                         "{" stmtsep
                             ;; these stmts can appear in any order
                             prefix-stmt
                             [revision-date-stmt]
                             [description-stmt]
                             [reference-stmt]
                         "}" stmtsep

   include-stmt        = include-keyword sep identifier-arg-str optsep
                         (";" /
                          "{" stmtsep
                              ;; these stmts can appear in any order
                              [revision-date-stmt]
                              [description-stmt]
                              [reference-stmt]
                          "}") stmtsep

   namespace-stmt      = namespace-keyword sep uri-str stmtend

   uri-str             = < a string that matches the rule >
                         < URI in RFC 3986 >

   prefix-stmt         = prefix-keyword sep prefix-arg-str stmtend

   belongs-to-stmt     = belongs-to-keyword sep identifier-arg-str
                         optsep
                         "{" stmtsep
                             prefix-stmt
                         "}" stmtsep

   organization-stmt   = organization-keyword sep string stmtend

   contact-stmt        = contact-keyword sep string stmtend

   description-stmt    = description-keyword sep string stmtend

   reference-stmt      = reference-keyword sep string stmtend

   units-stmt          = units-keyword sep string stmtend

   revision-stmt       = revision-keyword sep revision-date optsep
                         (";" /
                          "{" stmtsep
                              ;; these stmts can appear in any order
                              [description-stmt]
                              [reference-stmt]
                          "}") stmtsep

   revision-date       = date-arg-str

   revision-date-stmt  = revision-date-keyword sep revision-date stmtend

   extension-stmt      = extension-keyword sep identifier-arg-str optsep
                         (";" /
                          "{" stmtsep
                              ;; these stmts can appear in any order
                              [argument-stmt]
                              [status-stmt]
                              [description-stmt]
                              [reference-stmt]
                          "}") stmtsep

   argument-stmt       = argument-keyword sep identifier-arg-str optsep
                         (";" /
                          "{" stmtsep
                              [yin-element-stmt]
                          "}") stmtsep

   yin-element-stmt    = yin-element-keyword sep yin-element-arg-str
                         stmtend
```

yin-element-arg-str = < 규칙과 일치하는 문자열 \>

- <음-요소-인수\>

```text
   yin-element-arg     = true-keyword / false-keyword

   identity-stmt       = identity-keyword sep identifier-arg-str optsep
                         (";" /
                          "{" stmtsep
                              ;; these stmts can appear in any order
                              *if-feature-stmt
                              *base-stmt
                              [status-stmt]
                              [description-stmt]
                              [reference-stmt]
                          "}") stmtsep

   base-stmt           = base-keyword sep identifier-ref-arg-str
                         stmtend

   feature-stmt        = feature-keyword sep identifier-arg-str optsep
                         (";" /
                          "{" stmtsep
                              ;; these stmts can appear in any order
                              *if-feature-stmt
                              [status-stmt]
                              [description-stmt]
                              [reference-stmt]
                          "}") stmtsep

   if-feature-stmt     = if-feature-keyword sep if-feature-expr-str
                         stmtend
```

if-feature-expr-str = < 규칙과 일치하는 문자열 \>

- < if-feature-expr \>

```text
   if-feature-expr     = if-feature-term
                           [sep or-keyword sep if-feature-expr]

   if-feature-term     = if-feature-factor
                           [sep and-keyword sep if-feature-term]

   if-feature-factor   = not-keyword sep if-feature-factor /
                         "(" optsep if-feature-expr optsep ")" /
                         identifier-ref-arg

   typedef-stmt        = typedef-keyword sep identifier-arg-str optsep
                         "{" stmtsep
                             ;; these stmts can appear in any order
                             type-stmt
                             [units-stmt]
                             [default-stmt]
                             [status-stmt]
                             [description-stmt]
                             [reference-stmt]
                          "}" stmtsep

   type-stmt           = type-keyword sep identifier-ref-arg-str optsep
                         (";" /
                          "{" stmtsep
                              [type-body-stmts]
                          "}") stmtsep

   type-body-stmts     = numerical-restrictions /
                         decimal64-specification /
                         string-restrictions /
                         enum-specification /
                         leafref-specification /
                         identityref-specification /
                         instance-identifier-specification /
                         bits-specification /
                         union-specification /
                         binary-specification

   numerical-restrictions = [range-stmt]

   range-stmt          = range-keyword sep range-arg-str optsep
                         (";" /
                          "{" stmtsep
                              ;; these stmts can appear in any order
                              [error-message-stmt]
                              [error-app-tag-stmt]
                              [description-stmt]
                              [reference-stmt]
                           "}") stmtsep
```

10진수64 사양 = ;; 이러한 stmt는 임의의 순서로 나타날 수 있습니다. 분수-숫자-stmt \[범위-stmt\]

```text
   fraction-digits-stmt = fraction-digits-keyword sep
                          fraction-digits-arg-str stmtend
```

Fraction-digits-arg-str = < 규칙과 일치하는 문자열 \>

- < 분수-숫자-인수 \>

```text
   fraction-digits-arg = ("1" ["0" / "1" / "2" / "3" / "4" /
                               "5" / "6" / "7" / "8"])
                         / "2" / "3" / "4" / "5" / "6" / "7" / "8" / "9"
```

문자열 제한 = ;; 이러한 stmt는 어떤 순서로든 나타날 수 있습니다.

- \[길이-stmt\] \*패턴-stmt

```text
   length-stmt         = length-keyword sep length-arg-str optsep
                         (";" /
                          "{" stmtsep
                              ;; these stmts can appear in any order
                              [error-message-stmt]
                              [error-app-tag-stmt]
                              [description-stmt]
                              [reference-stmt]
                           "}") stmtsep

   pattern-stmt        = pattern-keyword sep string optsep
                         (";" /
                          "{" stmtsep
                              ;; these stmts can appear in any order
                              [modifier-stmt]
                              [error-message-stmt]
                              [error-app-tag-stmt]
                              [description-stmt]
                              [reference-stmt]
                           "}") stmtsep

   modifier-stmt       = modifier-keyword sep modifier-arg-str stmtend

   modifier-arg-str    = < a string that matches the rule >
                         < modifier-arg >

   modifier-arg        = invert-match-keyword

   default-stmt        = default-keyword sep string stmtend

   enum-specification  = 1*enum-stmt

   enum-stmt           = enum-keyword sep string optsep
                         (";" /
                          "{" stmtsep
                              ;; these stmts can appear in any order
                              *if-feature-stmt
                              [value-stmt]
                              [status-stmt]
                              [description-stmt]
                              [reference-stmt]
                           "}") stmtsep
```

leafref 사양 =

- ;; 이러한 stmt는 어떤 순서로든 나타날 수 있습니다. path-stmt \[require-instance-stmt\]

```text
   path-stmt           = path-keyword sep path-arg-str stmtend

   require-instance-stmt = require-instance-keyword sep
                            require-instance-arg-str stmtend
```

require-instance-arg-str = < 규칙과 일치하는 문자열 \> < require-instance-arg \>

```text
   require-instance-arg = true-keyword / false-keyword

   instance-identifier-specification =
                         [require-instance-stmt]

   identityref-specification =
                         1*base-stmt

   union-specification = 1*type-stmt

   binary-specification = [length-stmt]

   bits-specification  = 1*bit-stmt

   bit-stmt            = bit-keyword sep identifier-arg-str optsep
                         (";" /
                          "{" stmtsep
                              ;; these stmts can appear in any order
                              *if-feature-stmt
                              [position-stmt]
                              [status-stmt]
                              [description-stmt]
                              [reference-stmt]
                          "}") stmtsep

   position-stmt       = position-keyword sep
                         position-value-arg-str stmtend
```

position-value-arg-str = < 규칙과 일치하는 문자열 \>

- < 위치 값 인수 \>

```text
   position-value-arg  = non-negative-integer-value

   status-stmt         = status-keyword sep status-arg-str stmtend

   status-arg-str      = < a string that matches the rule >
                         < status-arg >

   status-arg          = current-keyword /
                         obsolete-keyword /
                         deprecated-keyword

   config-stmt         = config-keyword sep
                         config-arg-str stmtend

   config-arg-str      = < a string that matches the rule >
                         < config-arg >

   config-arg          = true-keyword / false-keyword

   mandatory-stmt      = mandatory-keyword sep
                         mandatory-arg-str stmtend
```

필수-arg-str = < 규칙과 일치하는 문자열 \>

- < 필수 인수 \>

```text
   mandatory-arg       = true-keyword / false-keyword

   presence-stmt       = presence-keyword sep string stmtend

   ordered-by-stmt     = ordered-by-keyword sep
                         ordered-by-arg-str stmtend
```

order-by-arg-str = <규칙과 일치하는 문자열\>

- < 인수별로 정렬 \>

```text
   ordered-by-arg      = user-keyword / system-keyword

   must-stmt           = must-keyword sep string optsep
                         (";" /
                          "{" stmtsep
                              ;; these stmts can appear in any order
                              [error-message-stmt]
                              [error-app-tag-stmt]
                              [description-stmt]
                              [reference-stmt]
                           "}") stmtsep

   error-message-stmt  = error-message-keyword sep string stmtend

   error-app-tag-stmt  = error-app-tag-keyword sep string stmtend

   min-elements-stmt   = min-elements-keyword sep
                         min-value-arg-str stmtend
```

min-value-arg-str = < 규칙과 일치하는 문자열 \>

- < 최소값 인수 \>

```text
   min-value-arg       = non-negative-integer-value

   max-elements-stmt   = max-elements-keyword sep
                         max-value-arg-str stmtend
```

max-value-arg-str = < 규칙과 일치하는 문자열 \>

- < 최대값 인수 \>

```text
   max-value-arg       = unbounded-keyword /
                         positive-integer-value

   value-stmt          = value-keyword sep integer-value-str stmtend
```

정수 값-str = < 규칙과 일치하는 문자열 \>

- < 정수값 \>

```text
   grouping-stmt       = grouping-keyword sep identifier-arg-str optsep
                         (";" /
                          "{" stmtsep
                              ;; these stmts can appear in any order
                              [status-stmt]
                              [description-stmt]
                              [reference-stmt]
                              *(typedef-stmt / grouping-stmt)
                              *data-def-stmt
                              *action-stmt
                              *notification-stmt
                          "}") stmtsep

   container-stmt      = container-keyword sep identifier-arg-str optsep
                         (";" /
                          "{" stmtsep
                              ;; these stmts can appear in any order
                              [when-stmt]
                              *if-feature-stmt
                              *must-stmt
                              [presence-stmt]
                              [config-stmt]
                              [status-stmt]
                              [description-stmt]
                              [reference-stmt]
                              *(typedef-stmt / grouping-stmt)
                              *data-def-stmt
                              *action-stmt
                              *notification-stmt
                          "}") stmtsep

   leaf-stmt           = leaf-keyword sep identifier-arg-str optsep
                         "{" stmtsep
                             ;; these stmts can appear in any order
                             [when-stmt]
                             *if-feature-stmt
                             type-stmt
                             [units-stmt]
                             *must-stmt
                             [default-stmt]
                             [config-stmt]
                             [mandatory-stmt]
                             [status-stmt]
                             [description-stmt]
                             [reference-stmt]
                          "}" stmtsep

   leaf-list-stmt      = leaf-list-keyword sep identifier-arg-str optsep
                         "{" stmtsep
                             ;; these stmts can appear in any order
                             [when-stmt]
                             *if-feature-stmt
                             type-stmt stmtsep
                             [units-stmt]
                             *must-stmt
                             *default-stmt
                             [config-stmt]
                             [min-elements-stmt]
                             [max-elements-stmt]
                             [ordered-by-stmt]
                             [status-stmt]
                             [description-stmt]
                             [reference-stmt]
                          "}" stmtsep

   list-stmt           = list-keyword sep identifier-arg-str optsep
                         "{" stmtsep
                             ;; these stmts can appear in any order
                             [when-stmt]
                             *if-feature-stmt
                             *must-stmt
                             [key-stmt]
                             *unique-stmt
                             [config-stmt]
                             [min-elements-stmt]
                             [max-elements-stmt]
                             [ordered-by-stmt]
                             [status-stmt]
                             [description-stmt]
                             [reference-stmt]
                             *(typedef-stmt / grouping-stmt)
                             1*data-def-stmt
                             *action-stmt
                             *notification-stmt
                          "}" stmtsep

   key-stmt            = key-keyword sep key-arg-str stmtend

   key-arg-str         = < a string that matches the rule >
                         < key-arg >

   key-arg             = node-identifier *(sep node-identifier)

   unique-stmt         = unique-keyword sep unique-arg-str stmtend

   unique-arg-str      = < a string that matches the rule >
                         < unique-arg >

   unique-arg          = descendant-schema-nodeid
                         *(sep descendant-schema-nodeid)

   choice-stmt         = choice-keyword sep identifier-arg-str optsep
                         (";" /
                          "{" stmtsep
                              ;; these stmts can appear in any order
                              [when-stmt]
                              *if-feature-stmt
                              [default-stmt]
                              [config-stmt]
                              [mandatory-stmt]
                              [status-stmt]
                              [description-stmt]
                              [reference-stmt]
                              *(short-case-stmt / case-stmt)
                          "}") stmtsep

   short-case-stmt     = choice-stmt /
                         container-stmt /
                         leaf-stmt /
                         leaf-list-stmt /
                         list-stmt /
                         anydata-stmt /
                         anyxml-stmt

   case-stmt           = case-keyword sep identifier-arg-str optsep
                         (";" /
                          "{" stmtsep
                              ;; these stmts can appear in any order
                              [when-stmt]
                              *if-feature-stmt
                              [status-stmt]
                              [description-stmt]
                              [reference-stmt]
                              *data-def-stmt
                          "}") stmtsep

   anydata-stmt        = anydata-keyword sep identifier-arg-str optsep
                         (";" /
                          "{" stmtsep
                              ;; these stmts can appear in any order
                              [when-stmt]
                              *if-feature-stmt
                              *must-stmt
                              [config-stmt]
                              [mandatory-stmt]
                              [status-stmt]
                              [description-stmt]
                              [reference-stmt]
                           "}") stmtsep

   anyxml-stmt         = anyxml-keyword sep identifier-arg-str optsep
                         (";" /
                          "{" stmtsep
                              ;; these stmts can appear in any order
                              [when-stmt]
                              *if-feature-stmt
                              *must-stmt
                              [config-stmt]
                              [mandatory-stmt]
                              [status-stmt]
                              [description-stmt]
                              [reference-stmt]
                           "}") stmtsep

   uses-stmt           = uses-keyword sep identifier-ref-arg-str optsep
                         (";" /
                          "{" stmtsep
                              ;; these stmts can appear in any order
                              [when-stmt]
                              *if-feature-stmt
                              [status-stmt]
                              [description-stmt]
                              [reference-stmt]
                              *refine-stmt
                              *uses-augment-stmt
                          "}") stmtsep

   refine-stmt         = refine-keyword sep refine-arg-str optsep
                          "{" stmtsep
                              ;; these stmts can appear in any order
                              *if-feature-stmt
                              *must-stmt
                              [presence-stmt]
                              *default-stmt
                              [config-stmt]
                              [mandatory-stmt]
                              [min-elements-stmt]
                              [max-elements-stmt]
                              [description-stmt]
                              [reference-stmt]
                            "}" stmtsep

   refine-arg-str      = < a string that matches the rule >
                         < refine-arg >

   refine-arg          = descendant-schema-nodeid
```

사용-증강-stmt = 증가 키워드 sep 사용-증강-arg-str optsep "{" stmtsep ;; 이러한 stmt는 어떤 순서로든 나타날 수 있습니다. \[when-stmt\] \*if-feature-stmt \[status-stmt\] \[description-stmt\] \[reference-stmt\] 1\*\(data-def-stmt / case-stmt / action-stmt / 알림-stmt\) "}" stmtsep

use-augment-arg-str = < 규칙과 일치하는 문자열 \>

- < 사용-증강-인수 \>

```text
   uses-augment-arg    = descendant-schema-nodeid

   augment-stmt        = augment-keyword sep augment-arg-str optsep
                         "{" stmtsep
                             ;; these stmts can appear in any order
                             [when-stmt]
                             *if-feature-stmt
                             [status-stmt]
                             [description-stmt]
                             [reference-stmt]
                             1*(data-def-stmt / case-stmt /
                                action-stmt / notification-stmt)
                          "}" stmtsep

   augment-arg-str     = < a string that matches the rule >
                         < augment-arg >

   augment-arg         = absolute-schema-nodeid

   when-stmt           = when-keyword sep string optsep
                         (";" /
                          "{" stmtsep
                              ;; these stmts can appear in any order
                              [description-stmt]
                              [reference-stmt]
                           "}") stmtsep

   rpc-stmt            = rpc-keyword sep identifier-arg-str optsep
                         (";" /
                          "{" stmtsep
                              ;; these stmts can appear in any order
                              *if-feature-stmt
                              [status-stmt]
                              [description-stmt]
                              [reference-stmt]
                              *(typedef-stmt / grouping-stmt)
                              [input-stmt]
                              [output-stmt]
                          "}") stmtsep

   action-stmt         = action-keyword sep identifier-arg-str optsep
                         (";" /
                          "{" stmtsep
                              ;; these stmts can appear in any order
                              *if-feature-stmt
                              [status-stmt]
                              [description-stmt]
                              [reference-stmt]
                              *(typedef-stmt / grouping-stmt)
                              [input-stmt]
                              [output-stmt]
                          "}") stmtsep

   input-stmt          = input-keyword optsep
                         "{" stmtsep
                             ;; these stmts can appear in any order
                             *must-stmt
                             *(typedef-stmt / grouping-stmt)
                             1*data-def-stmt
                         "}" stmtsep

   output-stmt         = output-keyword optsep
                         "{" stmtsep
                             ;; these stmts can appear in any order
                             *must-stmt
                             *(typedef-stmt / grouping-stmt)
                             1*data-def-stmt
                         "}" stmtsep
```

알림-stmt = 알림 키워드 sep

- 식별자-arg-str optsep \(";" / "{" stmtsep ;; 이러한 stmt는 어떤 순서로든 나타날 수 있습니다. \*if-feature-stmt \*must-stmt \[status-stmt\] \[description-stmt\] \[reference-stmt\] \*\(typedef-stmt / grouping-stmt\) \*data-def-stmt "}"\) stmtsep

```text
   deviation-stmt      = deviation-keyword sep
                         deviation-arg-str optsep
                         "{" stmtsep
                             ;; these stmts can appear in any order
                             [description-stmt]
                             [reference-stmt]
                             (deviate-not-supported-stmt /
                               1*(deviate-add-stmt /
                                  deviate-replace-stmt /
                                  deviate-delete-stmt))
                         "}" stmtsep
```

편차-arg-str = < 규칙과 일치하는 문자열 \>

- < 편차-인수 \>

```text
   deviation-arg       = absolute-schema-nodeid

   deviate-not-supported-stmt =
                         deviate-keyword sep
                         not-supported-keyword-str stmtend

   deviate-add-stmt    = deviate-keyword sep add-keyword-str optsep
                         (";" /
                          "{" stmtsep
                              ;; these stmts can appear in any order
                              [units-stmt]
                              *must-stmt
                              *unique-stmt
                              *default-stmt
                              [config-stmt]
                              [mandatory-stmt]
                              [min-elements-stmt]
                              [max-elements-stmt]
                          "}") stmtsep
```

deviate-delete-stmt = deviate-keyword sep delete-keyword-str optsep \(";" / "{" stmtsep ;; 이러한 stmt는 어떤 순서로든 나타날 수 있습니다. \[units-stmt\] \*must-stmt \*unique-stmt \*default- stmt "}"\) stmtsep

deviate-replace-stmt = deviate-keyword sep replacement-keyword-str optsep \(";" / "{" stmtsep ;; 이러한 stmt는 어떤 순서로든 나타날 수 있습니다. \[type-stmt\] \[units-stmt\] \[default-stmt\] \[ config-stmt\] \[필수-stmt\] \[최소 요소-stmt\] \[최대 요소-stmt\] "}"\) stmtsep

not-supported-keyword-str = < 규칙과 일치하는 문자열 \> < not-supported-keyword \>

```text
   add-keyword-str     = < a string that matches the rule >
                         < add-keyword >
```

delete-keyword-str = < 규칙과 일치하는 문자열 \>

- < 키워드 삭제 \>

replacement-keyword-str = < 규칙과 일치하는 문자열 \>

- < 교체 키워드 \>

;; 확장의 사용법을 나타냅니다. 알 수 없음 = 접두사 ":" 식별자 \[sep 문자열\] optsep \(";" / "{" optsep \*\(\(yang-stmt /known-statement\) optsep\) "}"\) stmtsep

```text
   yang-stmt           = action-stmt /
                         anydata-stmt /
                         anyxml-stmt /
                         argument-stmt /
                         augment-stmt /
                         base-stmt /
                         belongs-to-stmt /
                         bit-stmt /
                         case-stmt /
                         choice-stmt /
                         config-stmt /
                         contact-stmt /
                         container-stmt /
                         default-stmt /
                         description-stmt /
                         deviate-add-stmt /

                         deviate-delete-stmt /
                         deviate-not-supported-stmt /
                         deviate-replace-stmt /
                         deviation-stmt /
                         enum-stmt /
                         error-app-tag-stmt /
                         error-message-stmt /
                         extension-stmt /
                         feature-stmt /
                         fraction-digits-stmt /
                         grouping-stmt /
                         identity-stmt /
                         if-feature-stmt /
                         import-stmt /
                         include-stmt /
                         input-stmt /
                         key-stmt /
                         leaf-list-stmt /
                         leaf-stmt /
                         length-stmt /
                         list-stmt /
                         mandatory-stmt /
                         max-elements-stmt /
                         min-elements-stmt /
                         modifier-stmt /
                         module-stmt /
                         must-stmt /
                         namespace-stmt /
                         notification-stmt /
                         ordered-by-stmt /
                         organization-stmt /
                         output-stmt /
                         path-stmt /
                         pattern-stmt /
                         position-stmt /
                         prefix-stmt /
                         presence-stmt /
                         range-stmt /
                         reference-stmt /
                         refine-stmt /
                         require-instance-stmt /
                         revision-date-stmt /
                         revision-stmt /
                         rpc-stmt /
                         status-stmt /
                         submodule-stmt /
                         typedef-stmt /
                         type-stmt /

                         unique-stmt /
                         units-stmt /
                         uses-augment-stmt /
                         uses-stmt /
                         value-stmt /
                         when-stmt /
                         yang-version-stmt /
                         yin-element-stmt

   ;; Ranges

   range-arg-str       = < a string that matches the rule >
                         < range-arg >

   range-arg           = range-part *(optsep "|" optsep range-part)

   range-part          = range-boundary
                         [optsep ".." optsep range-boundary]

   range-boundary      = min-keyword / max-keyword /
                         integer-value / decimal-value

   ;; Lengths

   length-arg-str      = < a string that matches the rule >
                         < length-arg >

   length-arg          = length-part *(optsep "|" optsep length-part)

   length-part         = length-boundary
                         [optsep ".." optsep length-boundary]

   length-boundary     = min-keyword / max-keyword /
                         non-negative-integer-value

   ;; Date

   date-arg-str        = < a string that matches the rule >
                         < date-arg >

   date-arg            = 4DIGIT "-" 2DIGIT "-" 2DIGIT

   ;; Schema Node Identifiers

   schema-nodeid       = absolute-schema-nodeid /
                         descendant-schema-nodeid

   absolute-schema-nodeid = 1*("/" node-identifier)

   descendant-schema-nodeid =
                         node-identifier
                         [absolute-schema-nodeid]

   node-identifier     = [prefix ":"] identifier

   ;; Instance Identifiers

   instance-identifier = 1*("/" (node-identifier
                                 [1*key-predicate /
                                  leaf-list-predicate /
                                  pos]))

   key-predicate       = "[" *WSP key-predicate-expr *WSP "]"

   key-predicate-expr  = node-identifier *WSP "=" *WSP quoted-string

   leaf-list-predicate = "[" *WSP leaf-list-predicate-expr *WSP "]"

   leaf-list-predicate-expr = "." *WSP "=" *WSP quoted-string

   pos                 = "[" *WSP positive-integer-value *WSP "]"

   quoted-string       = (DQUOTE string DQUOTE) / (SQUOTE string SQUOTE)

   ;; leafref path

   path-arg-str        = < a string that matches the rule >
                         < path-arg >

   path-arg            = absolute-path / relative-path

   absolute-path       = 1*("/" (node-identifier *path-predicate))

   relative-path       = 1*("../") descendant-path

   descendant-path     = node-identifier
                         [*path-predicate absolute-path]

   path-predicate      = "[" *WSP path-equality-expr *WSP "]"

   path-equality-expr  = node-identifier *WSP "=" *WSP path-key-expr

   path-key-expr       = current-function-invocation *WSP "/" *WSP
                         rel-path-keyexpr

   rel-path-keyexpr    = 1*(".." *WSP "/" *WSP)
                         *(node-identifier *WSP "/" *WSP)
                         node-identifier

   ;;; Keywords, using the syntax for case-sensitive strings (RFC 7405)

   ;; statement keywords
   action-keyword           = %s"action"
   anydata-keyword          = %s"anydata"
   anyxml-keyword           = %s"anyxml"
   argument-keyword         = %s"argument"
   augment-keyword          = %s"augment"
   base-keyword             = %s"base"
   belongs-to-keyword       = %s"belongs-to"
   bit-keyword              = %s"bit"
   case-keyword             = %s"case"
   choice-keyword           = %s"choice"
   config-keyword           = %s"config"
   contact-keyword          = %s"contact"
   container-keyword        = %s"container"
   default-keyword          = %s"default"
   description-keyword      = %s"description"
   deviate-keyword          = %s"deviate"
   deviation-keyword        = %s"deviation"
   enum-keyword             = %s"enum"
   error-app-tag-keyword    = %s"error-app-tag"
   error-message-keyword    = %s"error-message"
   extension-keyword        = %s"extension"
   feature-keyword          = %s"feature"
   fraction-digits-keyword  = %s"fraction-digits"
   grouping-keyword         = %s"grouping"
   identity-keyword         = %s"identity"
   if-feature-keyword       = %s"if-feature"
   import-keyword           = %s"import"
   include-keyword          = %s"include"
   input-keyword            = %s"input"
   key-keyword              = %s"key"
   leaf-keyword             = %s"leaf"
   leaf-list-keyword        = %s"leaf-list"
   length-keyword           = %s"length"
   list-keyword             = %s"list"
   mandatory-keyword        = %s"mandatory"
   max-elements-keyword     = %s"max-elements"
   min-elements-keyword     = %s"min-elements"
   modifier-keyword         = %s"modifier"
   module-keyword           = %s"module"
   must-keyword             = %s"must"
   namespace-keyword        = %s"namespace"

   notification-keyword     = %s"notification"
   ordered-by-keyword       = %s"ordered-by"
   organization-keyword     = %s"organization"
   output-keyword           = %s"output"
   path-keyword             = %s"path"
   pattern-keyword          = %s"pattern"
   position-keyword         = %s"position"
   prefix-keyword           = %s"prefix"
   presence-keyword         = %s"presence"
   range-keyword            = %s"range"
   reference-keyword        = %s"reference"
   refine-keyword           = %s"refine"
   require-instance-keyword = %s"require-instance"
   revision-keyword         = %s"revision"
   revision-date-keyword    = %s"revision-date"
   rpc-keyword              = %s"rpc"
   status-keyword           = %s"status"
   submodule-keyword        = %s"submodule"
   type-keyword             = %s"type"
   typedef-keyword          = %s"typedef"
   unique-keyword           = %s"unique"
   units-keyword            = %s"units"
   uses-keyword             = %s"uses"
   value-keyword            = %s"value"
   when-keyword             = %s"when"
   yang-version-keyword     = %s"yang-version"
   yin-element-keyword      = %s"yin-element"

   ;; other keywords

   add-keyword              = %s"add"
   current-keyword          = %s"current"
   delete-keyword           = %s"delete"
   deprecated-keyword       = %s"deprecated"
   false-keyword            = %s"false"
   invert-match-keyword     = %s"invert-match"
   max-keyword              = %s"max"
   min-keyword              = %s"min"
   not-supported-keyword    = %s"not-supported"
   obsolete-keyword         = %s"obsolete"
   replace-keyword          = %s"replace"
   system-keyword           = %s"system"
   true-keyword             = %s"true"
   unbounded-keyword        = %s"unbounded"
   user-keyword             = %s"user"

   and-keyword              = %s"and"
   or-keyword               = %s"or"
   not-keyword              = %s"not"

   current-function-invocation = current-keyword *WSP "(" *WSP ")"

   ;;; Basic Rules

   prefix-arg-str      = < a string that matches the rule >
                         < prefix-arg >

   prefix-arg          = prefix

   prefix              = identifier
```

식별자-arg-str = < 규칙과 일치하는 문자열 \>

- < 식별자-인수 \>

```text
   identifier-arg      = identifier

   identifier          = (ALPHA / "_")
                         *(ALPHA / DIGIT / "_" / "-" / ".")
```

식별자-ref-arg-str = < 규칙과 일치하는 문자열 \>

- < 식별자-참조-인수\>

```text
   identifier-ref-arg  = identifier-ref

   identifier-ref      = [prefix ":"] identifier

   string              = < an unquoted string, as returned by >
                         < the scanner, that matches the rule >
                         < yang-string >

   yang-string         = *yang-char
```

;; 탭, 캐리지를 포함한 모든 유니코드 또는 ISO/IEC 10646 문자 ;; 리턴 및 라인 피드\(다른 C0 컨트롤은 제외\) ;; 문자, 대리 블록 및 문자가 아닌 문자 yang-char = %x09 / %x0A / %x0D / %x20-D7FF / ; 서로게이트 블록 %xD800-DFFF %xE000-FDCF / 제외; 문자가 아닌 %xFDD0-FDEF %xFDF0-FFFD / 제외; 문자가 아닌 %xFFFE-FFFF %x10000-1FFFD / 제외; 문자가 아닌 %x1FFFE-1FFFF %x20000-2FFFD / 제외; 문자가 아닌 %x2FFFE-2FFFF %x30000-3FFFD / 제외; 문자가 아닌 %x3FFFE-3FFFF %x40000-4FFFD / 제외; 문자가 아닌 %x4FFFE-4FFFF %x50000-5FFFD / 제외; 문자가 아닌 %x5FFFE-5FFFF %x60000-6FFFD / 제외; 문자가 아닌 %x6FFFE-6FFFF %x70000-7FFFD / 제외; 문자가 아닌 %x7FFFE-7FFFF %x80000-8FFFD / 제외; 문자가 아닌 %x8FFFE-8FFFF %x90000-9FFFD / 제외; 문자가 아닌 %x9FFFE-9FFFF %xA0000-AFFFD / 제외; 문자가 아닌 %xAFFFE-AFFFF %xB0000-BFFFD / 제외; 문자가 아닌 %xBFFFE-BFFFF %xC0000-CFFFD / 제외; 문자가 아닌 %xCFFFE-CFFFF %xD0000-DFFFD / 제외; 문자가 아닌 %xDFFFE-DFFFF %xE0000-EFFFD / 제외; 문자가 아닌 %xEFFFE-EFFFF %xF0000-FFFFD / 제외; 문자가 아닌 %xFFFFFE-FFFFF %x100000-10FFFD 제외; 문자가 아닌 %x10FFFE-10FFFF 제외

```text
   integer-value       = ("-" non-negative-integer-value) /
                          non-negative-integer-value

   non-negative-integer-value = "0" / positive-integer-value

   positive-integer-value = (non-zero-digit *DIGIT)

   zero-integer-value  = 1*DIGIT

   stmtend             = optsep (";" / "{" stmtsep "}") stmtsep

   sep                 = 1*(WSP / line-break)
                         ; unconditional separator

   optsep              = *(WSP / line-break)

   stmtsep             = *(WSP / line-break / unknown-statement)

   line-break          = CRLF / LF

   non-zero-digit      = %x31-39

   decimal-value       = integer-value ("." zero-integer-value)

   SQUOTE              = %x27
                         ; single quote
```

;; RFC 5234의 핵심 규칙

```text
   ALPHA               = %x41-5A / %x61-7A
                         ; A-Z / a-z

   CR                  = %x0D
                         ; carriage return

   CRLF                = CR LF
                         ; Internet standard newline

   DIGIT               = %x30-39
                         ; 0-9

   DQUOTE              = %x22
                         ; double quote

   HTAB                = %x09
                         ; horizontal tab

   LF                  = %x0A
                         ; line feed

   SP                  = %x20
                         ; space

   WSP                 = SP / HTAB
                         ; whitespace

   <CODE ENDS>
```

---
## **15.  NETCONF Error Responses for YANG-Related Errors**

데이터 모델 처리와 관련된 오류 사례에 대해 여러 NETCONF 오류 응답이 정의됩니다. 관련 YANG 문에 "error-app-tag" 하위 문이 있는 경우 이는 아래에 지정된 기본값을 재정의합니다.

---
### **15.1.  Error Message for Data That Violates a "unique" Statement**

NETCONF 작업으로 인해 "고유" 제약 조건이 무효화되는 구성 데이터가 발생하는 경우 다음 오류가 반환되어야 합니다.\(MUST\)

error-tag: 작업 실패 error-app-tag: data-not-unique error-info: <non-unique\>: "고유" 제약 조건을 무효화하는 리프를 가리키는 인스턴스 식별자가 포함되어 있습니다. 이 요소는 고유하지 않은 각 리프에 대해 한 번씩 존재합니다.

<non-unique\> 요소는 YANG에 있습니다.

- 네임스페이스\("urn:ietf:params:xml:ns:yang:1"\).

---
### **15.2.  Error Message for Data That Violates a "max-elements" Statement**

NETCONF 작업으로 인해 목록 또는 리프 목록에 항목이 너무 많은 구성 데이터가 발생하는 경우 다음 오류가 반환되어야 합니다.\(MUST\)

```text
     error-tag:      operation-failed
     error-app-tag:  too-many-elements
```

이 오류는 두 개 이상의 추가 하위 항목이 있는 경우에도 목록 노드를 식별하는 오류 경로와 함께 한 번 반환됩니다.

---
### **15.3.  Error Message for Data That Violates a "min-elements" Statement**

NETCONF 작업으로 인해 목록이나 리프 목록에 항목이 너무 적은 구성 데이터가 발생하는 경우 다음 오류가 반환되어야 합니다.\(MUST\)

```text
     error-tag:      operation-failed
     error-app-tag:  too-few-elements
```

이 오류는 두 개 이상의 자식이 누락된 경우에도 목록 노드를 식별하는 오류 경로와 함께 한 번 반환됩니다.

---
### **15.4.  Error Message for Data That Violates a "must" Statement**

NETCONF 작업으로 인해 "must" 문에 의해 부과된 제한 사항을 위반하는 구성 데이터가 발생하는 경우 "must" 문에 대해 특정 "error-app-tag" 하위 문이 존재하지 않는 한 다음 오류가 반환되어야 합니다.\(MUST\)

```text
     error-tag:      operation-failed
     error-app-tag:  must-violation
```

15.5. "require-instance" 문을 위반하는 데이터에 대한 오류 메시지

NETCONF 작업으로 인해 require-instance "true"로 표시된 "instance-identifier" 또는 "leafref" 유형의 리프가 존재하지 않는 인스턴스를 참조하는 구성 데이터가 발생하는 경우 다음 오류가 반환되어야 합니다.\(MUST\)

오류 태그: 데이터 누락 오류 앱 태그: 인스턴스 필수 오류 경로: 인스턴스 식별자 또는 리프 참조 리프의 경로입니다.

15.6. 필수 "선택" 문을 위반하는 데이터에 대한 오류 메시지

NETCONF 작업으로 인해 필수 선택에 노드가 없는 구성 데이터가 발생하는 경우 다음 오류가 반환되어야 합니다.\(MUST\)

오류 태그: 데이터 누락 오류 앱 태그: 선택 누락 오류 경로: 선택 항목이 누락된 요소의 경로입니다. error-info: <missing-choice\>: 누락된 필수 선택의 이름이 포함되어 있습니다.

- <missing-choice\> 요소는 YANG 네임스페이스\("urn:ietf:params:xml:ns:yang:1"\)에 있습니다.

---
### **15.7.  Error Message for the "insert" Operation**

목록 또는 리프 목록 노드에 대한 <edit-config\>에서 "삽입" 및 "키" 또는 "값" 속성이 사용되고 "키" 또는 "값"이 존재하지 않는 인스턴스를 참조하는 경우 다음 오류가 반환되어야 합니다.\(MUST\)

```text
     error-tag:      bad-attribute
     error-app-tag:  missing-instance
```

---
## **16.  IANA Considerations**

이 문서는 "NETCONF\(네트워크 구성 프로토콜\) 기능 URN" 레지스트리에서 하나의 기능 식별자 URN을 등록합니다.

```text
     Index           Capability Identifier
     -------------   ---------------------------------------------------
     :yang-library   urn:ietf:params:netconf:capability:yang-library:1.0
```

---
## **17.  Security Considerations**

이 문서는 관리 정보의 설명을 쓰고 읽는 데 사용되는 언어를 정의합니다. 언어 자체는 인터넷 보안에 영향을 미치지 않습니다.

기본 NETCONF 프로토콜에 대한 고려 사항과 동일한 고려 사항이 관련됩니다\(\[RFC6241\]의 섹션 9 참조\).

YANG에서 모델링된 데이터에는 민감한 정보가 포함될 수 있습니다. YANG에 정의된 RPC 또는 알림은 중요한 정보를 전송할 수 있습니다.

보안 문제는 YANG에서 모델링한 데이터의 사용과 관련이 있습니다. 이러한 문제는 데이터 모델을 설명하는 문서와 데이터를 조작하는 데 사용되는 인터페이스에 대한 문서\(예: NETCONF 문서\)에서 다루어져야 합니다.

YANG에서 모델링된 데이터는 다음에 따라 달라집니다.

o 민감한 정보를 전송하는 데 사용되는 전송 인프라의 보안.

o 그러한 민감한 정보를 저장하거나 공개하는 애플리케이션의 보안.

o 민감한 데이터의 사용을 제한하기 위한 적절한 인증 및 액세스 제어 메커니즘.

YANG 파서는 잘못된 문서에 대해 강력해야 합니다. 알 수 없거나 신뢰할 수 없는 소스에서 잘못된 형식의 문서를 읽으면 공격자가 YANG 파서를 실행하는 사용자의 권한을 얻을 수 있습니다. 극단적인 상황에서는 전체 시스템이 손상될 수 있습니다.

---
## **18.  References**
---
### **18.1.  Normative References**

\[ISO.10646\]

- 국제 표준화 기구, "정보 기술 - 범용 다중 옥텟 코드 문자 집합\(UCS\)", ISO 표준 10646:2014, 2014.

```text
   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", BCP 14, RFC 2119,
              DOI 10.17487/RFC2119, March 1997,
              <http://www.rfc-editor.org/info/rfc2119>.

   [RFC3629]  Yergeau, F., "UTF-8, a transformation format of
              ISO 10646", STD 63, RFC 3629, DOI 10.17487/RFC3629,
              November 2003, <http://www.rfc-editor.org/info/rfc3629>.

   [RFC3986]  Berners-Lee, T., Fielding, R., and L. Masinter, "Uniform
              Resource Identifier (URI): Generic Syntax", STD 66,
              RFC 3986, DOI 10.17487/RFC3986, January 2005,
              <http://www.rfc-editor.org/info/rfc3986>.

   [RFC4648]  Josefsson, S., "The Base16, Base32, and Base64 Data
              Encodings", RFC 4648, DOI 10.17487/RFC4648, October 2006,
              <http://www.rfc-editor.org/info/rfc4648>.

   [RFC5234]  Crocker, D., Ed., and P. Overell, "Augmented BNF for
              Syntax Specifications: ABNF", STD 68, RFC 5234,
              DOI 10.17487/RFC5234, January 2008,
              <http://www.rfc-editor.org/info/rfc5234>.

   [RFC5277]  Chisholm, S. and H. Trevino, "NETCONF Event
              Notifications", RFC 5277, DOI 10.17487/RFC5277, July 2008,
              <http://www.rfc-editor.org/info/rfc5277>.

   [RFC6241]  Enns, R., Ed., Bjorklund, M., Ed., Schoenwaelder, J., Ed.,
              and A. Bierman, Ed., "Network Configuration Protocol
              (NETCONF)", RFC 6241, DOI 10.17487/RFC6241, June 2011,
              <http://www.rfc-editor.org/info/rfc6241>.

   [RFC7405]  Kyzivat, P., "Case-Sensitive String Support in ABNF",
              RFC 7405, DOI 10.17487/RFC7405, December 2014,
              <http://www.rfc-editor.org/info/rfc7405>.

   [RFC7895]  Bierman, A., Bjorklund, M., and K. Watsen, "YANG Module
              Library", RFC 7895, DOI 10.17487/RFC7895, June 2016,
              <http://www.rfc-editor.org/info/rfc7895>.

   [XML]      Bray, T., Paoli, J., Sperberg-McQueen, C., Maler, E., and
              F. Yergeau, "Extensible Markup Language (XML) 1.0 (Fifth
              Edition)", W3C Recommendation REC-xml-20081126,
              November 2008,
              <https://www.w3.org/TR/2008/REC-xml-20081126/>.

   [XML-NAMES]
              Bray, T., Hollander, D., Layman, A., Tobin, R., and H.
              Thompson, "Namespaces in XML 1.0 (Third Edition)", World
              Wide Web Consortium Recommendation REC-xml-names-20091208,
              December 2009,
              <http://www.w3.org/TR/2009/REC-xml-names-20091208>.

   [XPATH]    Clark, J. and S. DeRose, "XML Path Language (XPath)
              Version 1.0", World Wide Web Consortium Recommendation
              REC-xpath-19991116, November 1999,
              <http://www.w3.org/TR/1999/REC-xpath-19991116>.

   [XSD-TYPES]
              Biron, P. and A. Malhotra, "XML Schema Part 2: Datatypes
              Second Edition", World Wide Web Consortium Recommendation
              REC-xmlschema-2-20041028, October 2004,
              <http://www.w3.org/TR/2004/REC-xmlschema-2-20041028>.
```

---
### **18.2.  Informative References**

\[CoMI\] van der Stok, P. 및 A. Bierman, "CoAP 관리

- 인터페이스", 진행 중인 작업, 초안-vanderstok-core-comi-09, 2016년 3월.

```text
   [IEEE754-2008]
              IEEE, "IEEE Standard for Floating-Point Arithmetic",
              IEEE 754-2008, DOI 10.1109/IEEESTD.2008.4610935, 2008,
              <http://standards.ieee.org/findstds/
              standard/754-2008.html>.
```

\[RESTCONF\]

- Bierman, A., Bjorklund, M. 및 K. Watsen, "RESTCONF 프로토콜", 진행 중인 작업, 초안-ietf-netconf-restconf-16, 2016년 8월.

```text
   [RFC2578]  McCloghrie, K., Ed., Perkins, D., Ed., and J.
              Schoenwaelder, Ed., "Structure of Management Information
              Version 2 (SMIv2)", STD 58, RFC 2578,
              DOI 10.17487/RFC2578, April 1999,
              <http://www.rfc-editor.org/info/rfc2578>.

   [RFC2579]  McCloghrie, K., Ed., Perkins, D., Ed., and J.
              Schoenwaelder, Ed., "Textual Conventions for SMIv2",
              STD 58, RFC 2579, DOI 10.17487/RFC2579, April 1999,
              <http://www.rfc-editor.org/info/rfc2579>.

   [RFC3780]  Strauss, F. and J. Schoenwaelder, "SMIng - Next Generation
              Structure of Management Information", RFC 3780,
              DOI 10.17487/RFC3780, May 2004,
              <http://www.rfc-editor.org/info/rfc3780>.

   [RFC4844]  Daigle, L., Ed., and Internet Architecture Board, "The RFC
              Series and RFC Editor", RFC 4844, DOI 10.17487/RFC4844,
              July 2007, <http://www.rfc-editor.org/info/rfc4844>.

   [RFC6020]  Bjorklund, M., Ed., "YANG - A Data Modeling Language for
              the Network Configuration Protocol (NETCONF)", RFC 6020,
              DOI 10.17487/RFC6020, October 2010,
              <http://www.rfc-editor.org/info/rfc6020>.

   [RFC6643]  Schoenwaelder, J., "Translation of Structure of Management
              Information Version 2 (SMIv2) MIB Modules to YANG
              Modules", RFC 6643, DOI 10.17487/RFC6643, July 2012,
              <http://www.rfc-editor.org/info/rfc6643>.

   [RFC6991]  Schoenwaelder, J., Ed., "Common YANG Data Types",
              RFC 6991, DOI 10.17487/RFC6991, July 2013,
              <http://www.rfc-editor.org/info/rfc6991>.

   [RFC7951]  Lhotka, L., "JSON Encoding of Data Modeled with YANG",
              RFC 7951, DOI 10.17487/RFC7951, August 2016,
              <http://www.rfc-editor.org/info/rfc7951>.

   [XPATH2.0]
              Berglund, A., Boag, S., Chamberlin, D., Fernandez, M.,
              Kay, M., Robie, J., and J. Simeon, "XML Path Language
              (XPath) 2.0 (Second Edition)", World Wide Web Consortium
              Recommendation REC-xpath20-20101214, December 2010,
              <http://www.w3.org/TR/2010/REC-xpath20-20101214>.

   [XSLT]     Clark, J., "XSL Transformations (XSLT) Version 1.0", World
              Wide Web Consortium Recommendation REC-xslt-19991116,
              November 1999,
              <http://www.w3.org/TR/1999/REC-xslt-19991116>.
```

\[YANG-가이드라인\]

- Bierman, A., "YANG 데이터 모델 문서의 작성자 및 검토자를 위한 지침", 진행 중인 작업, 초안-ietf-netmod-rfc6087bis-07, 2016년 7월.

---
# **Acknowledgements**

편집자는 이 문서의 다양한 초안 버전에 대해 유용한 의견을 제공한 다음 개인들에게 감사를 표하고 싶습니다: Mehmet Ersue, Washam Fan, Joel Halpern, Per Hedeland, Leif Johansson, Ladislav Lhotka, Lionel Morand, Gerhard Muenz, Peyman Owladi, Tom Petch, Randy Presuhn, David Reid, Jernej Tuljak, Kent Watsen, Bert Wijnen, Robert Wilton 및 Dale Worley.

---
# **Contributors**

다음 사람들은 모두 초기 YANG 문서에 크게 기여했습니다.

```text
    - Andy Bierman (YumaWorks)
    - Balazs Lengyel (Ericsson)
    - David Partain (Ericsson)
    - Juergen Schoenwaelder (Jacobs University Bremen)
    - Phil Shafer (Juniper Networks)
```

---
# **Author's Address**

```text
   Martin Bjorklund (editor)
   Tail-f Systems

   Email: mbj@tail-f.com
```
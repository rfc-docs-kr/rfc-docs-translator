

```text
Network Working Group                                       M. Padlipsky
Request for Comment: 666                                26 November 1974
NIC: 31396
```

- 통합 사용자 수준 프로토콜 사양

RFC 451에 대해 많은 논의를 한 후에 나는 거기에 제안된 "통합 사용자 수준 프로토콜"이 항상 기본 동기였던 공통 명령 언어로 발전했다는 것을 발견했습니다. 이 후자의 접근 방식이 UULP의 원래 목표를 충족하고 이를 넘어 훨씬 더 유용한 영역으로 확장되는 데에는 몇 가지 이유가 있습니다.

1. 사용자의 편의성. 공통 편집기 "neted"에 대한 좋은 반응에서 알 수 있듯이, 네트워크 워킹 그룹은 네트워크의 시스템 프로그래머가 아닌 사용자의 편의가 제공되어야 한다는 사실을 인정하게 되었습니다. 사용자가 사용하는 서버 호스트에 관계없이 "일괄" 작업을 포함하여 동일한 일반 기능을 호출할 수 있도록 허용하는 것은 확실히 공통 명령 언어에 대한 설득력 있는 초기 정당화입니다. "모든" 서버가 어떤 방식으로든 수행하는 일반 기능에 대한 관심은 "언어적" 우아함보다는 언어의 공통 명령 하위 집합 측면을 강조하기 위한 것입니다. 이 시도는 "모든 것"을 완료하는 복잡한 방법이 아니라 많은 작업을 수행하는 쉬운 방법을 지정하는 것입니다.

2. "자원 공유". 최근 NWG에서 주목받고 있는 또 다른 영역은 외부 시스템에서 자원의 "자동" 또는 프로그램 기반 호출입니다. Telnet 프로토콜의 오래된 "n x m 문제"를 피하려면 그러한 기능을 수행하기 위해 일종의 공통 중간 표현이 분명히 필요합니다. 이 경우 n 호스트는 그렇지 않으면 m 명령 언어를 추적해야 합니다. 인간이 사용할 수 있는 공통 중간 표현은 다음 지점에서 확장된 것처럼 일석이조로 두 마리의 새를 죽이는 것처럼 보입니다.

3. 메커니즘의 경제성. RFC 451에서 나는 소켓 1과 텔넷을 통해 연결된 단일 사용자 수준 프로토콜이 프로토콜이 발전한 후 새로운 응답자가 소켓마다 초기 연결 프로토콜을 서비스할 필요가 없다는 점에서 메커니즘의 경제성을 제공할 것이라는 주장을 발전시켰습니다. 이러한 고려 사항은 여전히 ​​​​적용되지만 자원 공유의 맥락을 고려할 때 훨씬 더 큰 경제가 가시화됩니다. 현재 제안처럼 공통 명령 언어가 사용자가 직접 사용하도록 설계된 경우 터미널 지원 "미니 호스트"\(예: ANTS 및 TIP\)의 사용자가 실제로 모든 작업을 수행할 때 중간 서버를 요구할 필요가 없습니다. 원하는 것은 공통적으로 특정 서버에서 작업하는 것입니다.

언어. \(이는 많은 사용자가 전문 프로그래머가 아니며 명령 언어에 익숙하지 않다는 사실을 고려하면 특히 그렇습니다.\) 즉, 프로그램에만 적합한 중간 언어를 통해 자원 공유가 이루어지면 서버 B의 일반 기능을 얻기 위해 서버 A만 사용하는 비용을 발생시키고 싶지 않다면 서버 B의 기본 명령 언어를 배워야 합니다. \(그리고 서버 A의 기본 언어를 배워야 할 수도 있습니다. 한 서버에서 두 대의 서버를 사용하는 데 드는 비용이 요인이 아닌 경우.\)

4. 프론트엔딩. 여기서 제안된 공통 명령 언어의 또 다른 이점은 대체로 기존 명령에 대한 프런트 엔드를 통해 구현에 적합하다는 것입니다. 따라서 기존 구현을 폐기해야 하는 불쾌한 필요성이 최소화됩니다. 실제로 취해진 접근 방식은 대체가 아닌 "기본" 명령 언어에 추가하여 공통 명령 언어를 마련하려는 의식적인 노력입니다. 기존 명령 언어가 표현하는 풍부함은 존재하지 않습니다. 또한 폐쇄된 환경이므로 기본 명령과 이름 지정 충돌이 발생하지 않습니다.

5. 회계 및 인증. 네트워크 서비스 사용을 설명하고 사용자 ID를 인증하는 것과 관련하여 FTP의 의미에 대한 수많은 RFC\(Bressler의 RFC 487, Pogran의 RFC 501 및 내 RFC 505 및 심지어 491\)에서 알 수 있듯이 이 영역은 아직 공중에 떠 있어요. 여기에 제안된 일반 로그인 명령은 서버가 적절한 계정 및 액세스 제어를 활성화하는 동시에 적절한 프로세스를 연결과 연결할 수 있도록 허용하므로 문제에 도움이 됩니다.

6. 프로세스-프로세스 기능. 외부 개체 프로그램의 호출을 가능하게 함으로써 현재 제안은 "병렬성"과 같은 프로세스 간 기능을 수행할 수 있는 루브릭을 제공합니다. \(아래의 "call" 명령에 대한 논의를 참조하십시오.\) UULP가 만병통치약으로 발전하고 있는 것은 아닙니다. 수행되는 실제 트랜잭션은 공통 명령 언어로 이루어지지 않을 가능성이 가장 높다고 가정합니다. 확실히 그럴 수도 있다\); 그러나 제공된 것은 아마도 특수한 경우의 프로그램을 다른 곳에서 실행하는 알려진 방법입니다. 또한 Day's File Access Protocol과 같이 우리가 일반화하고자 하는 새로운 기능을 배치할 수 있는 편리한 환경을 제공합니다.

```text
   All of which seems to be a fair amount of mileage to get out of a
   distaste for remembering whether you find out who's logged in by
   saying "systat", "users", "s.who:c", "listf tty", or "who"....
```

---
# **Context**

궁극적으로 초기 연결 프로토콜에 대한 일반 응답자가 되도록 의도되었지만 UULP는 처음에는 Telnet 프로토콜 "협상 옵션"이 될 것입니다. 옵션이 활성화되면 서버 호스트는 여기에 설명된 일반적인 규칙과 명령을 지원하는 명령 환경을 제공합니다.

어떤 의미에서 UULP는 "선택기"입니다. 즉, 공통 명령 하위 집합에는 CCN의 현재 Telnet 서버 라인을 따라 공통 명령 환경을 종료하고 다른 다양한 환경으로 들어가기 위한 명령이 포함됩니다. UULP 환경에서 "네이티브" 명령 프로세서로 나가기 위해 UULP 명령은 "로컬"입니다\(아래 사례 설명 참조\). "eol" 명령\(아래\)으로 변경하지 않는 한 모든 명령은 Telnet "Newline"\(현재 cr-lf\)으로 종료됩니다. 내부 구분 기호는 공백입니다\(공백\). \(FTP 서버와 같은 다른 환경으로의 진입은 아래에서 논의됩니다.\) 단순히 옵션 협상을 해제하는 명백히 자연스러운 메커니즘이 아닌 메커니즘을 도입하는 데는 두 가지 이유가 있습니다. 첫째, 더 편리할 것입니다. 사용자가 자신의 User Telnet 프로그램으로 탈출하여 옵션을 비활성화하는 것보다 명령을 입력하는 것입니다. 둘째, 궁극적으로 UULP가 모든 네트워크 로그인에 의해 발생하는 기본 환경이 되도록 법제화될 것으로 기대됩니다. 이 경우 서버의 "기본" 명령 환경에 들어가는 자연스러운 방법은 UULP 명령을 사용하는 것입니다.

- 참고: 여기에서 논의된 모든 UULP 명령은 간단한 설명과 함께 옵션별로 분류된 부록 1에 나열되어 있습니다. 부록은 첫 번째 UULP 사용자 매뉴얼로 간주될 수 있습니다.

---
# **Responses**

특정 서버에서 지원되지 않는 모든 선택적 명령은 "구현되지 않음: 명령 이름" 형식의 메시지로 응답됩니다. 여기서 변수는 요청된 명령의 이름입니다. 이 문서 전반에 걸쳐 모든 리터럴은 지정된 대로 정확하게 전송되어야 서버가 "실제" 사용자 외에 프로그램\("자동화" 또는 "명령 매크로" 포함\)에 의해 구동될 가능성을 허용할 수 있습니다.

일반적으로 여기서는 소수의 문자적이고 제한된 응답이 텍스트가 다양할 수 있는 숫자로 코딩된 다양한 응답보다 우수하다는 견해를 취했습니다. 다시 말하지만, 동기는 메커니즘의 경제를 달성하는 것입니다. 코딩된 모델의 경우 코드 할당 조정자가 있어야 하며 이는 피하는 것이 좋습니다. 또한, FTP를 사용하면서 경험한 바와 같이, 코드가 많으면 모호함이 많다. \(발신자는 예를 들어 452를 선택하는 데 완벽하게 유효한 사례를 가질 수 있지만,

수신자는 예를 들어 453을 예상하는 코드 정의를 똑같이 잘 해석할 수 있습니다.\) Multics의 관련 "오류 테이블" 메커니즘에 대한 경험은 코드화된 응답이 관리적 및 기술적 문제를 모두 발생시킨다는 주장을 뒷받침합니다. 숫자 코드에 대한 최종 반대는 일부 사람들에게는 부적절하다고 간주될 수 있지만 상황의 미학은 어느 정도 주목할 가치가 있다고 생각합니다. 그리고 실제 사용자가 공통 명령 언어를 사용할 때, 나는 그 많은 숫자가 돌아다니는 것 때문에 주의가 산만해질 것 같습니다. \(또한 "사용자 UULP"에 의해 숫자가 제거될 수 있다고 가정할 수도 없습니다. 여기서 기본 목표 중 하나는 TIP의 사용자가 처리할 수 있을 만큼 간단하게 만드는 것입니다.\)

---
# **Arguments**

검토 과정에서 주장에 대한 일부 글로벌 논평이 적절하다는 것이 분명해졌습니다. 특히 명령줄에서 인수를 지정하는 전략과 "제어 인수"에 대한 질문이라는 두 가지 영역이 약간의 혼란을 가져온 것으로 보입니다. 첫 번째 점수에서는 "프론트 엔드 가능성"이라는 목표를 상기해야 합니다. 특정 명령의 두 가지 기본 구현을 고려하십시오. 그 중 하나는 \(A\) 사용자의 질문을 통해 인수를 수집할 것으로 예상하고, 다른 하나는 \(B\) 호출 시 인수를 수신할 것으로 예상합니다\(폐쇄 서브루틴으로 호출됨\). 이제 "서버 UULP"가 A를 다시 작성할 필요 없이 필요에 따라 A에 인수를 공급할 수 있다고 상상하기는 쉽지만, 광범위하게 다시 작성하지 않고 B가 인수를 조사하도록 만드는 방법을 아는 것은 매우 어렵습니다. 따라서 인수를 미리 지정하는 "최소 공통 분모" 접근 방식은 기존 구현을 재작업하는 측면에서 최소 비용을 발생시킵니다.

두 번째 악보에서는 "제어 인수"라는 Multics 명령 언어 규칙에서 개념을 차용했는데, 이는 실제 실습에서 매우 편리해 보이기 때문입니다. 핵심은 일부 인수는 일반적으로 명령에 대한 모드 또는 제어 기능을 지정하는 리터럴을 의미하는 반면 다른 인수는 특정 파일 이름이나 사용자 식별자와 같은 것을 지정하는 변수라는 것입니다. 일반적인 예는 "mail" 명령입니다. 여기서 변수는 사용자 식별자와 호스트 식별자이고 "제어 인수"는 사용자 식별자가 중단되고 호스트 식별자가 시작되었음을 나타내는 지정자입니다. 여기서 사용되는 규칙은 제어 인수를 하이픈으로 시작하는 것입니다. 이 문자는 가변 인수를 시작하는 데 사용되지 않는 것 같습니다. 따라서 메일 예제에서는 "-at"를 사용합니다. 깊은 철학적 요점은 아니지만 이 접근 방식은 순서 의존성에 대한 논쟁 목록을 완화하고 나에게 옳다고 느낍니다.

---
# **Case**

Telnet 프로토콜의 네트워크 가상 터미널의 키보드 사양에 의해 존재하지 않게 된 것처럼 보이지만, 대문자 전용 터미널에서 사용자를 어떻게 해야 하는지에 대한 문제는 실제로 여전히 어려운 문제로 남아 있습니다. 고려해야 할 두 가지 측면이 있습니다: 명령의 알파벳 대소문자와 소문자 입력을 허용하기 위해 "대소문자 매핑"을 발생시키는 기능입니다. 일부 서버는 내부적으로 모두 대문자 또는 모두 소문자로 작동하고 모든 입력을 적절하게 매핑하기 때문에 첫 번째 측면에 로컬 문제가 없습니다. \(그러나 예를 들어 대소문자 혼합 시스템을 처리하기 위해 이러한 시스템에서 사용자 FTP를 사용할 때 문제가 발생합니다.\) 그러나 다른 서버는 대소문자에 일반적인 언어적 의미를 부여합니다. \(예를 들어 Smith의 이름은 "SMITH"가 아니고 "smith"가 아닌 "Smith"입니다.\) 대소문자를 구분하지 않는 서버에 대한 불필요한 처리를 최소화하기 위해 모든 UULP 명령은 도착 여부에 관계없이 그대로 인식됩니다. 대문자 또는 모두 소문자. \(단순히 입력 편의를 위해 여기에서는 모두 낮게 표시됩니다.\) 입력이 반드시 대소문자 매핑될 것이라고 가정하는 것은 로컬 구현에 대한 부당한 가정이므로 임의로 혼합된 대소문자는 인식되지 않습니다.

두 번째 측면에서 명령 인수\(매개변수라고도 함\)에서 대문자와 소문자를 구별하는 모든 서버는 대문자 전용 터미널에서의 로그인을 지원하기 위해 부록 2에 지정된 대로 UULP "map" 명령을 제공해야 합니다. 모든 128개의 ASCII 코드가 생성 가능해야 한다는 Telnet 프로토콜의 규정을 지원하지 않거나 이를 어색하게 지원하는 사용자 호스트에 연결됩니다. 이는 대문자 네트워크 전체의 개인 식별자\(및 심지어 네트워크 가상 경로 이름까지\)가 사용 가능한 공통 명령 하위 집합에 대한 사전 조건이 되도록 규정하는 대안보다 더 간단하고 바람직한 솔루션으로 보입니다. \(아래에 설명된 대로 후자의 개념은 합의되면 원활하게 적용됩니다. 그러나 여기서 요점은 합의될 때까지 UULP의 이점을 박탈할 필요가 없다는 것입니다.\)

---
# **User Names**

위에서 암시한 것처럼 다양한 서버에는 사용자 이름을 표현하는 다양한 방법이 있습니다. 분명히 메모리 절약 원칙에 따라 네트워크 내에서 그리고 네트워크를 위한 이름의 공통 중간 표현이 있어야 합니다. 이 표현은 네트워크 정보 센터의 "NIC ID"를 기반으로 한다는 점도 분명합니다. 그러나 불행하게도 최신 정보를 보호하기 위한 수용 가능한 메커니즘이 여기서 입법화될 수 없다는 점은 매우 분명합니다. 암시된 데이터베이스를 안전하게 업데이트하기 위한 메커니즘은 말할 것도 없습니다. 그러므로 현 단계에서는 그럴 것으로 보인다.

사용자 이름을 로컬 이름이 아닌 네트워크 전체 이름으로 처리하고 지원 메커니즘이 발전하도록 하는 사실을 서버에 전달하기 위해 UULP 구문만 지정하는 것이 합리적입니다.

이름 앞에 별표\("\*"\)가 있으면 네트워크 전체 이름을 나타냅니다. \(이러한 이름은 UULP 명령 이름과 마찬가지로 모두 대문자이거나 모두 소문자일 수 있습니다.\) "\*free"라는 이름은 \(로그인의 맥락에서\) 로그인이 필요하다는 의미로 명시적으로 예약되어 있습니다. 지원 계정 또는 샘플링 계정\(해당 계정이 사용 가능한 경우\) 해당 계정을 사용할 수 없는 경우 "잘못된 ID: \*무료"라는 응답이 표시됩니다. 네트워크 전체 이름이 일반적으로 사용 가능한 경우 서버는 해당 이름을 로컬 이름으로 매핑하거나 원하는 대로 로컬 이름으로 등록하게 합니다. 요점은 네트워크 전체 이름이 UULP의 맥락에서 서버에 의해 "작동하도록 만들어진다"는 것입니다.

---
# **Special Characters and Signals**

사용자의 편의를 위해 텔넷 프로토콜의 문자보다 삶의 사실이 더 중요해야 하는 또 다른 영역은 문자 "삭제" 및 "삭제"에 관한 영역입니다. 사용자 텔넷은 일반 문자 삭제 및 일반 라인 삭제를 위한 텔넷 제어 코드의 전송을 균일하게 촉진할 수 있습니다. 그러나 사용자 텔넷은 다를 것이라는 점은 확실합니다. 사용자가 두 개 이상의 사용자 텔넷을 사용하는 경우 다시 너무 많은 반사 신경을 개발해야 하는 불편한 위치에 놓이게 됩니다. 따라서 UULP는 선택적으로 "erase char" 및 "kill char" 명령을 지원합니다. 여기서 char는 인쇄 가능한 ASCII 문자입니다\(특정 운영 체제의 가장 안쪽 영역에서 인식되는 "제어 문자"와의 충돌 가능성을 피하기 위해\). . 아마도 부주의한 사용자는 특정 명령을 호출할 수 없는 위치에 놓이는 것을 피하기 위해 알파벳을 선택하지 않도록 지시받을 수 있습니다\(예를 들어, 변경할 수 없는 경우 자신을 지우고 종료하는 경우\).

이러한 명령은 관련 Telnet 제어 코드를 보완하는 명령이며 동일한 의미를 갖습니다. 여기서 요점은 사용자가 "erase #"이라고 말하고 서버에서 "#"을 지우기 문자로 인식하도록 하는 것이 사용자 Telnet으로 전송하도록 하는 것보다 훨씬 더 편리할 수 있다는 것입니다. Telnet과 동일합니다. 명령은 일부 서버에서 심각한 구현 문제를 초래할 수 있고 결국 동등한 기능이 Telnet에 존재하기 때문에 선택 사항으로 지정됩니다.

참고: 삭제는 "초기"에 수행되는 것으로 가정됩니다.

- 가능합니다. 즉, "erase x" "erase x" 시퀀스는 "erase x" "erase"와 동일하게 나타나야 합니다.

- "x"를 사용하면 명령줄에서 공백이 지워집니다. 아마도 이는 사용자 커뮤니티에서 변칙적인 결과를 용인할 수 있는 매우 드문 경로이지만 의도는 분명해야 합니다.

Telnet "동기화" 및 "중단" 메커니즘은 본질적으로 Telnet에 맡기는 것이 가장 좋습니다. 그러나 라인의 끝은 다른 이야기일 수도 있습니다. 따라서 잠재적인 편의를 위해 UULP는 선택적으로 "eol char"를 지원하여 이후부터 char를 줄 끝 문자로 처리하도록 서버에 요청합니다. Telnet Newline으로 되돌리려면 "eol"\(즉, 인수 없음, 현재 종결자\).

---
# **Prompts**

서버가 동일하면서도 달라지는 또 다른 측면은 "명령 수준에 있음"을 나타내는 방법입니다. 일부는 "준비 메시지"를 출력합니다. 기타, "프롬프트 문자". 다른 시스템에 대한 명령 로그인을 통해 일부 기능이 수행되는 UULP의 경우 알려진 프롬프트 문자를 지정하는 기능이 매우 바람직합니다. UULP 명령은 "프롬프트 문자"입니다. 여기서 char는 사용자 프로세스\(서버의\)가 명령 수준에 있을 때 전송되는 문자입니다. "네이티브" 프롬프트 또는 준비 메시지로 구성된 행에 char 접두어를 붙이는 것은 명시적으로 허용됩니다. 또한 이 명령은 로그인 전에 허용되는 것으로 명시적으로 승인됩니다. \(다시 말하지만, 알파벳 문자를 선택할 경우 발생할 수 있는 나쁜 결과에 대해 경고해야 합니다.\)

- 참고: "prompt", "eol", "erase" 및 "kill"은 관련 설정을 변경하기 위해 char의 새로운 값으로 모두 다시 호출될 수 있습니다. 인수 없이 호출하면 모두 끌 수 있습니다.

---
# **Login**

아마도 가장 까다로운 개찰구는 일반 로그인을 지정하려는 시도일 것입니다. UULP 로그인 명령은 "login userident"입니다. 여기서 userident는 로컬에서 허용되는 사용자 식별자이거나 위에서 설명한 네트워크 전체 식별자입니다. 나중에 논의할 맥락에서의 유용성을 위해 지역적으로 허용되는 형식에는 공백이 포함되어서는 안 됩니다. 서버는 임의의 텍스트\(예: "오늘의 메시지"\)로 로그인 시도에 응답할 수 있지만 응답의 일부 줄은 다음 중 하나여야 합니다. 프롬프트\(위에서 설명한 대로, 현재 상황에서 성공을 나타냄\) 로그인\); "비밀번호:"; 또는 "잘못된 ID: userident." 비밀번호가 필요한 경우 마스크를 보내거나 입력 숨기기 옵션을 성공적으로 협상하는 것은 서버의 책임입니다.

"login \*free"는 특별히 비밀번호가 필요하지 않도록 정의되어 있습니다. \("프리로더"가 사용자 텔넷에 액세스할 수 있고 "\*free" 구문을 배웠다면 그가 일반 비밀번호도 읽을 수 없었다고 가정하는 것은 소용이 없습니다.\) 비밀번호를 제공해야 하는 경우 허용 가능한 응답 프롬프트 또는 "로그인 실패"로 시작하는 줄을 포함하는 임의의 텍스트입니다. 또는 "계정:"을 사용하세요. 계정이 요청되면 응답은 "로그인 실패" 메시지이거나 이미 설명된 프롬프트가 포함된 텍스트여야 합니다. 로그인 과정에서 오류가 발생하면 사용자는 로그인 명령을 시작하여 다시 시도해야 합니다. \(즉, 서버가 ID나 비밀번호를 "기억"할 필요는 없습니다.\)

"로그인 \*무료"에 대한 허용 가능한 응답은 "제한된 액세스만"이라는 것이 명시적으로 인정됩니다. \(프롬프트가 이어짐\) 이는 문제의 서버에 있는 무료 계정이 메일을 수락하고 특정 사용자가 로그인했는지 알려주는 것과 같은 기능을 허용하기 위해서만 존재한다는 것을 \(인간\) 사용자에게 경고하기 위한 것입니다. \(이러한 작업의 "로그인 없는" 수행에 대한 반대의 경우\) , RFC 491을 참조하십시오. 또한 로그인 없는 작업이 자연스러운 경우 서버가 "login \*free"에 대한 응답으로 프롬프트를 반환하는 것 외에 다른 작업을 수행해야 한다는 내용은 여기에 나와 있지 않습니다.\) UULP 로그인 규칙과 " 프롬프트" 명령을 사용하면 프로그램이 무료 계정에 로그인하여 이러한 기능 중 하나를 수행하는 것이 비교적 간단합니다. 로그인 명령이 성공하면 프로그램이 보장된 프롬프트 문자를 "보기" 때문입니다.

일반적으로 일종의 "데몬" 프로세스 서비스 메일 등을 가지고 있는 호스트의 삶을 더 단순하게 만들기 위해 로그인에 대한 추가 확장이 필요합니다. 여기서 중요한 점은 일부 호스트는 어떤 종류의 프로세스에 자격이 없는 "login \*free"를 전달해야 하는지 알지 못하는 반면, 메일을 처리하거나 who 명령을 수행하거나 설정하기 위한 명시적인 요청으로 무엇을 해야 할지 확신할 수 있다는 것입니다. 콘솔 간 통신. 따라서 UULP "로그인"은 "-mail", "-who" 또는 "-concom"의 "제어 인수"\(위에서 설명한 대로\)를 허용하며 관련된 각 UULP 명령은 모든 로그인에서 해당 문자열을 사용해야 합니다. 그들이 전송하는 라인. 다시 말하지만, 서버가 정보와 어떤 관련이 있는지에 대해서는 아무 말도 없지만 일부 서버에서는 정보가 필요하거나 원합니다.

---
# **Usage Information**

대부분의 서버는 명령 호출 순서부터 전체 사용자 매뉴얼까지 일종의 온라인 문서를 제공합니다. UULP 환경에는 "일반" 시스템 정보와 특정 서버의 UULP 구현에 대한 정보라는 두 가지 종류의 관심 정보가 있습니다. "네이티브" 명령에 대한 설명을 얻는 방법을 배우려면 UULP 명령은 "help -sys"\(약어: "?"\)입니다. "-sys"는 "제어 인수"로 간주되며 다음과 같이 앞에 붙습니다.

다른 종류의 이름\(예: 명령 이름\)과 쉽게 구별할 수 있도록 하이픈\("-"\)을 사용합니다. 서버의 UULP 구현에 대한 설명을 얻으려면 "help -uulp"를 사용하십시오. 특정 UULP 명령 구현에 대한 설명을 얻으려면 "help comname"을 사용하십시오. 도움말 명령 "help"를 사용하는 방법을 상기합니다.

- 참고: 명령 이름 및 네트워크 전체 사용자 이름과 마찬가지로 제어 인수는 모두 대문자이거나 모두 소문자일 수 있습니다.

```text
   It is specifically acknowledged that "No peculiarities." is an
   appropriate response to "help comname" if nothing of interest need be
   said about the Server's implementation of the UULP command in
   question.  (After all, we're sparing users the necessity of studying
   a dozen or so users' manuals; the least they can do is to read the
   UULP command list.)  Appropriate information for less taciturn Hosts
   to furnish would be such data as local command invoked (if such be
   the case), argument syntax (e.g., pathname description, or name of
   help file about pathnames), "To be implemented.", or even "Not to be
   implemented."

"Mail"
```

일반적인 목적을 위해 별도의 메일 프로토콜이 발전하고 있음에도 불구하고 UULP는 로그인 기반 덕분에 메일에 대한 액세스 제어 및 보낸 사람 인증을 수행하는 시스템이 이러한 기능을 사용자가 사용할 수 있도록 허용하므로 이 주제를 다루어야 합니다. 일반 기능의 프레임워크. 따라서 자신의 메일함을 읽으려면 UULP 명령은 "readmail"입니다. "실시간" 입력을 수집하여 로컬 사용자 "mail userident"에게 보내려면 원격 사용자에게 "mail userident -at 호스트 이름"으로 전달합니다. 여기서 인수는 "명백한" 의미를 갖습니다. 이전에 생성된 파일을 보내려면 "mail -f filename userident -at hostname"을 입력하세요. 여러 사용자 ID가 제공될 수 있습니다. 구분 기호는 공백\(공백\)입니다. 호스트 이름에도 비슷한 고려 사항이 적용됩니다. 둘 다 목록이면 쌍으로 처리되어야 합니다. \(특정 호스트의 여러 사용자에게 보낸 다음 다른 호스트의 다른 사용자에게 보내는 욕구를 처리하기 위해 더 정교한 구문을 개발할 수 있지만 여러 호출을 수행하면 작업이 완료되므로 현 시점에서는 그렇게 할 필요가 없어 보입니다. .\)

mail 명령은 보낸 사람을 식별하는 행\(호스트 및 시간이 바람직하지만 필수는 아님\)을 메시지 앞에 붙입니다. "라이브" 컬렉션의 경우 메시지 끝은 마침표\("."\)와 정규 줄 종결자\(보통 Telnet Newline이지만 eol 명령에 대한 설명 참조\)로만 구성된 줄로 표시됩니다. 원격 메일이 성공적으로 전송되지 않으면 로컬 파일에 저장되고 해당 파일 이름이 실패 메시지의 일부로 출력됩니다. \(나중 전송을 위한 "대기열"은 감탄하지만

필요하지 않습니다.\) 전송 메커니즘은 일반 메일 프로토콜을 따릅니다. "-at" 절과 함께 호출되면 mail 명령은 "login \*free -mail"을 원격 호스트로 보낸 다음 "-at" 절 없이 mail 명령을 보냅니다.

바람직하지만 필수는 아니지만 "readmail"을 장식하는 것은 호스트 이름\("-at 호스트 이름"\)을 허용하여 로컬 호스트가 명명된 호스트로 이동하도록 하는 것입니다\("login \*free -mail"을 통해\). 거기에서 메일을 확인해 보세요. 물론 여러 호스트 이름을 지정할 수 있습니다. 꽤 비용이 많이 드는 추가 장식은 모든 호스트\(또는 해당 목적에 맞는 무료 계정을 가지고 있는 것으로 알려진 모든 호스트\)의 메일을 확인하라는 요청으로 "-all"을 허용하는 것입니다.

---
# **Direct Communication**

로그인한 다른 사용자와 직접 메시지를 교환하는 기능은 분명히 많은 사용자들에게 매우 높이 평가되고 있습니다. 따라서 이 기능이 UULP의 범위 내에 있지 않다는 사실에도 불구하고 우리는 잠시 이야기를 나눈 후 이를 다루겠습니다.

- 여담: UULP는 일반적인 철자법으로 일반 함수 호출을 특정, 기존 "네이티브" 함수에 대한 호출로 변환하는 간단한 "프런트 엔드"가 다양한 서버에 있을 수 있다고 가정합니다. 그러나 콘솔 간 통신 영역에서는 이 전제가 실제로 유지되지 않습니다. 문제는 작성자에게 알려진 두 가지 주요 "네이티브" 구현에 심각한 결함이 있다는 것입니다. TENEX "링크" 메커니즘은 안전하지 않으며\(내가 부주의하게 허용하더라도 내가 입력하는 모든 내용을 볼 수 없음\) 불편합니다\(왜 성가신 세미콜론을 기억해야 합니까? 어떻게 해야 합니까?\). 하나를 잊어버린 후에 다시 단계로 돌아가나요?\). 또한 사용자 인터페이스가 비판 대상이 아니더라도 로컬 TTY 버퍼를 통해 네트워크 I/O를 강제하지 않는 시스템에서는 시뮬레이션하기가 매우 어려울 수 있습니다. 반면에 Multics의 "send\_message" 메커니즘은 더 정교한 디자인을 가지고 있지만 터무니없이 비쌉니다. 따라서 설명할 UULP 메커니즘은 이 기능을 지원하기 위해 새로운 로컬 구현이 개발될 것이라고 가정합니다.

콘솔 간 통신을 허용하려면: "concom -on"; 거절하려면 "concom -off"를 사용하세요. 기본값은 꺼져 있습니다. 메시지 전송 모드로 들어가려면: "concom userident -at 호스트 이름"\("-at" 절은 선택 사항\). 메시지 전송 모드를 종료하려면 마침표로만 구성된 행을 입력하십시오\(위의 메일 참조\). 메시지 전송 모드에서는 각 라인이 하나의 단위로 전송됩니다. concom이 보낸 첫 번째 메시지는 "보낸 사람:"으로 시작하고 회신할 적절한 주소를 포함하는 식별 줄로 시작해야 합니다. 마감 기간 전용 라인

다른 concom도 닫힐 수 있도록 전송되어야 합니다. 허용되는 오류 응답은 "사용할 수 없음: userident"입니다. \(특정 사용자의 존재를 확인도 부정도 하지 않습니다. 이는 보안 측면에서 우려되는 문제입니다.\) 물론 명령은 메시지를 전송하는 데 필요한 모든 작업을 수행해야 합니다. 즉, 로컬에서 호출된 경우 로컬 메커니즘에 액세스하고, 원격 통신을 위해 호출된 경우 원격 호스트의 concom 명령\("login \*free -concom"을 통해\)에 액세스합니다. 따라서 TIP의 사용자는 이것이 편리하다면 상대방의 호스트에서 로컬 형식의 concom을 사용하고, 어떤 이유로든 직접 사용이 불편한 경우에는 "일반적인" 서버에서 원격 형식을 사용합니다\(예: 예를 들어 거기에 계정이 없습니다\).

```text
   The prerequisites for establishing communications are to find out if
   the user is logged in, and what "address" to use if so.  The
   mechanism for gathering this information is an expanded "who"
   command.  (Note that "who" is the UULP command to invoke the generic
   who's logged in function, with no constraints on format of reply.)
   The syntax is "who userident -at hostname", where both arguments may
   be multiple.  If no "-at" clause, then check local Host only.
   Response must begin "From hostname: userident:" followed by either an
   appropriate address (e.g., "ll" if local "concom" uses TTY numbers
   and userident is logged in on TTY ll), or "Not available."
```

메일과 마찬가지로 "-all" 장식이 즐거울 수 있습니다. "-all" 사용 여부에 관계없이 지정된 사용자에 대한 검색에서는 여전히 "login \*free -who" 로그인이 적절한 원격 호스트에서 사용된다고 가정합니다. "누가 사용자인지". 이것이 확장된 who 명령에 대한 응답이 엄격하게 지정되어야 하는 이유입니다. 또한 네트워크 전체 또는 로컬 사용자 이름으로 문의하는지 여부에 관계없이 응답은 "concom"에서 사용하기에 적합해야 합니다.

"좋은" concom 구현은 아마도 확장된 who 명령을 자동으로 수행하여 사용자가 별도로 명령을 수행할 필요가 없도록 할 것입니다. 실제로 로그인에 대한 -concom 제어 인수는 이러한 가능성을 충족시키기 위해 누가 및 concom을 수행할 수 있는지를 암시하도록 정의됩니다. 그러한 접근 방식이 규칙이 되도록 입법화하고 싶은 유혹이 있지만, 구현에 미치는 영향은 그렇게 하기에는 충분히 명확하지 않습니다. 그러나 구현자에 대한 강력한 힌트로 간주되어야 하는 암시적인 사람입니다.

---
# **File Creation and Manipulation**

공통 명령 하위 집합은 파일을 생성하고 조작하는 기능을 제공해야 합니다. 한편으로는 메일을 보내고 다른 한편으로는 후속 컴파일을 위한 소스 파일을 생성하려면 생성이 필요합니다. 조작\(예: 복사, 이름 바꾸기, 입력,

등\)은 공통 명령 언어로만 작업하려는 사용자의 편의 측면과 원하는 일괄 기능을 수행하는 수단으로 모두 필요합니다\(아래 참조\). 파일 조작 명령의 경우 사용자는 파일 전송 프로토콜 환경에 들어갈 수 있습니다. 그러나 FTP 사용자 인터페이스는 매우 높은 수준의 프로그램 구동 가능성으로 인해 제한됩니다. 또한 약어가 부족하고 명령 이름을 4자로 제한하여 기억하기 어려운 문제가 있습니다. 또한 일부 중요한 기능\(예: 파일을 입력하도록 하는 등\)은 처리되지 않습니다. 따라서 다양한 UULP 파일 조작 명령이 부록 1에 나와 있습니다. 여기서는 자세히 다룰 필요가 없습니다. 그러나 일부 컨텍스트가 유용할 수 있습니다.

파일 조작 명령은 모든 서버가 대략 "사용자의 작업 디렉토리"에 해당하는 개념을 가지고 있다고 가정합니다. 아직 개발되지 않은 네트워크 가상 경로 이름이든 "로컬" 다양한 이름이든 모든 파일 이름은 달리 명시하지 않는 한 이 디렉토리의 파일을 참조하는 것으로 간주됩니다. 즉, 사용자는 "dsk:" 등을 제공할 필요가 없습니다. 그가 파일 "x"를 언급할 때 그는 "내 현재 작업 디렉토리에 있는 'x'라는 이름의 파일"을 의미하고 서버는 그것이 무엇을 의미하는지 "알고" 있는 것으로 간주됩니다.

UULP 개발의 현재 단계에서는 다음 설명을 합리적으로 설명하는 것이 효과적이지 않은 것 같습니다. 지금은 FTP를 사용해야 하는 파일 조작 명령\(예: 외부 파일의 복사본\)이 FTP를 사용하고 이를 허용한다고만 말하면 충분합니다. 프로토콜의 맥락과 의미가 더 널리 이해됨에 따라 자세한 구현 참고 사항이 파일 명령에 추가될 것이며 의심할 바 없이 다른 명령에 대해서도 개선될 것입니다. 어떤 면에서 일반 파일 명령은 외부 파일을 처리할 때 알려진 휴먼 인터페이스의 일종의 "사용자 FTP"로 볼 수 있습니다. \(물론, 네트워크 가상 경로명이 있을 때까지는 문제가 실제로 발생하지 않습니다.\) "식별" 명령이 바람직할 것으로 예상합니다. 특정 현재 사용자는 필요한 로그인 정보를 사용할 수 있습니다. 이러한 명령은 부록 1에 포함되어 있지만 현재로서는 추측으로 분류되어야 합니다.

파일 생성에 관한 문제는 다소 복잡합니다. UULP 환경에서 파일을 생성하는 기능이 매우 바람직하다는 것은 분명합니다. 또한 가짜 주소로 메일을 사용하여 파일을 만든 다음 "보내지 않은 메일" 파일의 이름을 바꾸는 것은 사용자가 수행하기에는 너무 비잔틴적이라는 것도 분명합니다. 불행히도 대안이 무엇인지는 명확하지 않습니다. 즉, 공통 편집기가 필요하다는 것은 매우 분명하지만 어떤 편집기여야 하는지는 전혀 명확하지 않습니다.

널리 알려진 두 명의 편집자가 떠오릅니다: TECO와 QED. 그러나 모든 사람이 그것을 가지고 있는 것은 아닙니다. 모두가 그렇다고 하더라도 '방언' 문제는 큰 문제가 될 수밖에 없습니다. 모든 관련 시스템 프로그래머가 동의하더라도, 의도된 사용자 집단이 TECO나 QED만큼 복잡한 언어를 기꺼이 배울 것인지에 대한 의문이 남아 있습니다. 따라서 "neted"라고 불리는 선택적 UULP 명령이 제안되었습니다. \(RFC 569도 참조하십시오.\) 이 편집기는 줄 지향 컨텍스트 편집기입니다\("정규 표현식"도 없고 줄 번호도 없음\). 이는 주석이 달린 \(PL/I\) 소스 코드 목록을 포함하여 4장이나 Multics 프로그래머 매뉴얼에 풍부하게 문서화되어 있습니다. 간단한 사용자 가이드를 준비했습니다\(부록 3 참조\). 이미 여러 가지 구현이 존재하며 더 많은 구현이 이루어졌습니다. 또한 이를 구현하도록 요청받는 일부 시스템 프로그래머에게는 불쾌감을 줄 수도 있습니다. 따라서 상위 기관에서 필수로 지정하지 않는 한 선택 사항입니다.

---
# **Other Protocols**

UULP를 제안한 명목상의 초기 원동력은 각각의 새로운 프로토콜에 대한 새로운 접촉 소켓을 위해 새로운 응답 메커니즘을 구축하도록 요구하는 대신 공통 메커니즘을 통해 새로운 네트워크 사용자 프로토콜을 호출할 수 있도록 하는 것이었습니다. 이 목표는 UULP의 진정한 목표를 인정함으로써 뒷전으로 밀려났지만 완전히 폐기된 것은 아닙니다. 따라서 FTP 서버 환경에 들어가기 위한 UULP 명령은 "ftp"입니다. RJE 서버 환경에 들어가기 위한 UULP 명령은 "rje"입니다. 종료는 해당 프로토콜에 따릅니다. \(가능한 경우 종료는 UULP 환경으로 돌아가야 합니다.\)

---
# **Invoking Foreign Programs**

공통 명령 환경에서 특정 로컬 프로그램을 호출하는 것이 바람직한 두 가지 광범위한 상황이 있습니다. 연결의 사용자 측 자체가 프로그램일 수 있고 원하는 서버 측 프로그램이 특별히 협력하는 프로그램일 수 있습니다. 물론 이것은 더 정교한 맥락입니다. 덜 정교한 컨텍스트는 사용자 측이 "실제" 사용자라고 가정하고 사용자가 이미 공통 언어로 컴파일한 컴파일러나 개체 프로그램을 호출하려는 욕구입니다. 다시 한 번 사용자의 편의를 위해 일종의 "서버 투명" 모드에서 작동합니다. \(후자의 경우에는 서버의 "일괄" 사용도 포함됩니다. 아래를 참조하십시오.\) 두 가지 상황 모두에서 UULP의 중요한 역할은 서버의 특이성과 관계없이 특정 프로그램을 호출할 수 있는 메커니즘을 지정하는 것입니다. 명령 언어.

프로그래밍 언어는 여기서 다루기에는 너무 큰 문제입니다. 그러나 사용자가 어떻게든 소스 프로그램을 생성한다고 가정하면 그는 여전히 적절한 컴파일러나 심지어 목적 프로그램을 호출할 때 철자법의 공통성을 원합니다. 선택 사항이지만 강력하게 권장되는 UULP 명령으로 "호출 이름"은 개체 프로그램 이름을 호출해야 합니다\(여기서 명명된 프로그램은 인수가 적절하게 지정된 "기본" 명령일 수 있음\). "pl1", "-basic", "-fortran", "-lisp" 등의 값은 적절한 언어 프로세서의 호출을 요청하는 것으로 인식되어야 합니다\(이름이 지정된 소스 파일에서 작동하거나 그렇지 않은 경우 해석적/대화형으로 작동\). 소스 파일의 이름이 지정됨\), "합리적인" 기본값이 적용됩니다. 이 모든 것은 시스템 명령과 새로운 UULP 명령 사이의 잠재적인 이름 지정 충돌을 피하기 위해 "네이티브" 명령이 UULP 환경\("호출" 제외\)에서 직접 호출할 수 없음을 의미한다는 점에 유의하십시오.

- UULP 환경의 "호출" 명령은 완료 정보 반환에 대한 임시 규칙이 주어지면 "병렬" 계산을 위한 루브릭을 구성합니다. \(초기자가 rfc를 "수신"할 수 있는 경우 Telnet 쓰기 소켓 + 2에 쓰는 것이 적절해 보일 수 있습니다. 그러나 데이터 스트림의 응답도 특수 프로그램으로 간주되어 어쨌든 "사용자" 측에서는 가정됩니다. .\)

---
# **Other Matters**

"배치" 모드라는 주제는 주목할 만합니다. 파일 조작 명령과 마찬가지로, 확실한 사양을 위해서는 더 많은 협의가 필요합니다. 그러나 로그인에 대한 "-batch" 제어 인수는 서버에 의한 배치 모드 처리를 시작해야 하며 호출 및 식별 명령이 주어지면 우리가 요구할 수 있는 모든 것은 출력 파일을 통해 반환하기 위해 출력 파일을 지정하는 규칙입니다. "작업" 자체의 복사 명령\(출력이 서버에 저장되지 않고 반환되는 경우\) 물론 -batch에는 비밀번호 및 타이밍 문제와 관련된 일부 하위 구조가 필요할 수 있습니다. 향후 반복에서 이 영역에 대한 자세한 내용이 나타날 것입니다.

허구화된 시나리오는 다음과 같습니다.

```text
   login Me -batch -pw xxx -shift 3
   copy *452<me>source.text source.pl2
   call -pl2 source
   call source input output
   identify Me2 yyy
   copy output *555>root>Me>output452
   logout
```

사용자 "Me"는 서버가 명령을 수신하기를 원합니다\(TIP에서 직접 또는 사용자가 이를 포함하는 파일을 생성한 다른 서버로부터\). 이를 통해 비밀번호 "xxx"를 사용하여 배치 작업을 설정합니다. Shift 3에서 실행됩니다\(해당되는 경우\). 작업은 먼저 호스트 452의 "<me\>" 디렉터리에서 "source.text" 파일을 로컬 파일 "source.pl2"로 복사한 다음 이를 로컬 PL2 컴파일러로 컴파일하고 실행합니다\("찾을 수 없음" 응답이 지정된 인수\(아마도 입력 및 출력을 위한 파일 이름\)를 사용하여 컴파일이 실패한 경우 알려진 파일로 복사한 다음 사용자 식별자 "Me2"와 비밀번호 "yyy". 우아하지는 않지만 작동해야 합니다.

마지막으로 로그아웃 주제에 대해 UULP 명령은 "logout"입니다. 서버는 로그아웃을 실행하기 위해 적절한 조치를 취한 후 텔넷 연결을 닫아야 합니다. Telnet 연결을 유지하려면 "logout -save"를 사용하십시오. 서버를 닫는 것은 사용자 텔넷을 닫을 필요가 없다는 점에서 사용자의 편의로 간주됩니다. 또한 연결을 "매달린" 상태로 두지 않고 연결을 끊기 위해 사용자 측과 복잡한 협상을 요구하지 않도록 프로그램 기반 응용 프로그램에 바람직합니다.

---
# **APPENDIX 1.  THE COMMON COMMAND SUBSET**

```text
   Syntax                                                   Opt

   I. "Set-up" Commands
```

login id arg ID는 네트워크 전체 또는 호스트별일 수 있습니다. "\*무료"는 예약되어 있습니다. 인수는 "-mail", "-who", "-concom", "-batch"일 수도 있고 없을 수도 있습니다. 결과는 로그인되거나 적절한 데몬으로 전달됩니다.

프롬프트 char char이 일반 프롬프트 메시지가 되거나 앞에 오도록 지정합니다. 로그인하기 전에 허용됩니다.

Erase char X char가 지우기 문자임을 지정합니다. 인수 없이 호출하면 기본값으로 되돌아갑니다.

```text
   kill char                                                 X
```

char이 종료 문자임을 지정합니다. 인수 없이 호출하면 기본값으로 되돌아갑니다.

eol char X char이 개행 문자임을 지정합니다. 인수 없이 호출하면 기본값으로 되돌아갑니다.

local 로컬 명령 환경을 입력합니다.

ftp FTP 환경으로 들어갑니다.

rje RJE 환경으로 들어갑니다. logout 로그아웃하고 Telnet 연결을 끊습니다.

logout -save 로그아웃하지만 Telnet 연결은 유지합니다.

map 부록 2의 대소문자 매핑 규칙을 적용합니다. 대소문자가 중요한 호스트에 필수입니다.

recognition id arg X 필요한 "팬아웃" 로그인에서 id가 사용자 식별자로 사용되도록 지정합니다. arg가 지정된 경우 해당 로그인에 사용할 비밀번호이거나 "-pw"입니다. 이 경우 서버는 마스크를 제공하거나 Hide Your Input Telnet 옵션을 협상합니다. 인수가 없으면 팬아웃 로그인 시 비밀번호가 제공되지 않습니다. 기본 ID는 "\*free"입니다.

```text
   II.  Communications Commands
```

readmail "사서함"을 입력합니다.

readmail \(id\) -at 호스트 X 원격 호스트 호스트에 "mailbox"를 입력합니다. 공백\(공백\)으로 구분하여 여러 호스트를 지정할 수 있습니다.

호스트의 작업 디렉터리를 알려진 사용자 식별자 또는 \(선택적으로\) ID가 암시하는 디렉터리로 변경하는 기능을 의미합니다.

```text
   readmail -all                                              XX
```

메일을 검색해 보세요. 매우 선택 사항입니다.

mail id id로 지정된 로컬 사용자에게 메일을 보내기 위해 마침표\("."\)로만 구성된 행까지 입력을 수집합니다.

mail -f file id 지정된 파일의 내용을 지정된 로컬 사용자에게 보냅니다.

메일 ID -at 호스트 지정된 호스트의 원격 사용자에게 메일을 보내기 위해 마침표\("."\)로만 구성된 행까지 입력을 수집합니다. ID와 호스트는 둘 다 공백으로 구분되어 여러 개일 수 있습니다. \(여러 개일 경우 쌍으로 복용해야 합니다.\)

mail -f 파일 ID -at 호스트 지정된 파일의 내용을 지정된 원격 사용자에게 보냅니다.

who 로그인한 일반 사용자 명령입니다.

아이디는 누구인가요? 아이디가 로그인되어 있나요? 제한된 응답.

who id -at 호스트 지정된 사용자가 지정된 호스트에 로그인되어 있습니까? 제한된 응답.

concom -on 콘솔 간 통신을 활성화합니다.

concom -off 콘솔 간 통신을 비활성화합니다.

concom id 마침표\("."\)로만 구성된 줄까지 지정된 로컬 사용자에게 메시지를 보냅니다.

concom id -at 호스트 지정된 원격 사용자에게 메시지를 보냅니다.

```text
   III.  File Commands
```

type path 지정된 파일의 내용을 입력합니다. 경로 이름은 로컬이거나 네트워크 전체일 수 있습니다. 현재 작업 디렉터리가 기본값입니다.

listdir 현재 작업 디렉터리의 내용을 나열합니다. \(로컬 형식이 허용됩니다.\)

listdir path 지정된 디렉터리의 내용을 나열합니다.

rename old new 지정된 파일의 이름을 표시된 대로 변경합니다.

addname old new X 지정된 파일에 지정된 추가 이름을 지정합니다.

경로 삭제 지정된 파일을 제거합니다. \(필요한 경우 "말소"하십시오.\)

copy from to 두 번째 경로 이름에서 첫 번째 경로 이름으로 지정된 파일의 복사본을 만듭니다.

link from to X 파일 시스템에 그러한 개념이 있는 경우 두 경로 이름 사이에 "링크"를 만드십시오. 두 번째 인수가 없으면 작업 디렉터리에 동일한 항목 이름을 사용합니다.

status path st X 파일 시스템에 이러한 개념이 있는 경우 지정된 파일이나 디렉터리에 대한 상태 정보를 제공합니다.

changewd path X 인수가 없으면 "home" 디렉터리로 돌아갑니다.

typewd 현재 작업 디렉터리의 경로 이름을 입력합니다.

```text
   neted path

   See Appendix 3.

   IV.  Invoking "Native" Programs
```

호출 이름\(args\) 지정된 인수\(있는 경우\)를 사용하여 지정된 프로그램을 호출합니다. 다음 이름은 해당 언어 프로세서의 호출을 나타내기 위해 예약되어 있습니다: "-pl1", "-basic", "-fortran", "-lisp". \(소스 파일이 지정되지 않은 경우 가능하면 "해석적으로" 호출하십시오.\)

```text
   V. On-line Documentation
```

도움말 이름 지정된 UULP 명령에 대한 정보를 입력합니다. 이름이 "-sys"인 경우 로컬 시스템의 도움말 메커니즘을 사용하는 방법에 대한 정보를 입력합니다. "uulp"인 경우 로컬 시스템의 UULP 구현에 대한 것입니다. 이름이 지정되지 않은 경우 명령 자체를 설명하십시오.

---
# **APPENDIX 2.  MAP COMMAND CONVENTIONS**

이 부록에는 결국 RFC 411에 자세히 설명된 사례 매핑 규칙이 포함됩니다.

---
# **APPENDIX 3.  EDIT COMMAND REQUESTS**

이 부록에는 최종적으로 neted 명령 요청\(현재 초안이 존재함\)에 대한 설명이 포함되거나 먼저 게시되는 경우 리소스 노트북 버전에 대한 참조가 포함됩니다. 지금은 요청이 기본적으로 찾기, 다음, 맨 위, 변경, 저장 및 종료라는 점만 지적하면 충분합니다. 즉, 컨텍스트 편집기의 "구식" 취향입니다.

\[저자가 11/20-21/04에 광학 문자 인식 및 초기 교정을 수행했습니다. 몇 가지 원래 오타가 수정되었습니다. 일부는 남아있을 수 있습니다.\]
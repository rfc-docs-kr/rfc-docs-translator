

```text
Network Working Group                                     T. Berners-Lee
Request for Comments: 3986                                       W3C/MIT
STD: 66                                                      R. Fielding
Updates: 1738                                               Day Software
Obsoletes: 2732, 2396, 1808                                  L. Masinter
Category: Standards Track                                  Adobe Systems
                                                            January 2005

           Uniform Resource Identifier (URI): Generic Syntax
```

---
# **Status of This Memo**

본 문서는 인터넷 커뮤니티를 위한 인터넷 표준 트랙 프로토콜을 명시하고 개선을 위한 논의와 제안을 요청합니다. 이 프로토콜의 표준화 상태 및 상태에 대해서는 "인터넷 공식 프로토콜 표준"\(STD 1\) 최신판을 참조하세요. 이 메모의 배포는 무제한입니다.

---
# **Copyright Notice**

저작권\(C\)인터넷학회\(2005\).

---
# **Abstract**

URI\(Uniform Resource Identifier\)는 추상 또는 물리적 리소스를 식별하는 간단한 문자 시퀀스입니다. 이 사양은 인터넷에서 URI 사용에 대한 지침 및 보안 고려 사항과 함께 일반 URI 구문과 상대 형식일 수 있는 URI 참조를 확인하는 프로세스를 정의합니다. URI 구문은 모든 유효한 URI의 상위 집합인 문법을 정의하므로 구현이 가능한 모든 식별자의 체계별 요구 사항을 알지 못해도 URI 참조의 공통 구성 요소를 구문 분석할 수 있습니다. 이 사양은 URI에 대한 생성 문법을 정의하지 않습니다. 해당 작업은 각 URI 체계의 개별 사양에 따라 수행됩니다.

---
# **Table of Contents**

```text
   1.  Introduction . . . . . . . . . . . . . . . . . . . . . . . . .  4
       1.1.  Overview of URIs . . . . . . . . . . . . . . . . . . . .  4
             1.1.1.  Generic Syntax . . . . . . . . . . . . . . . . .  6
             1.1.2.  Examples . . . . . . . . . . . . . . . . . . . .  7
             1.1.3.  URI, URL, and URN  . . . . . . . . . . . . . . .  7
       1.2.  Design Considerations  . . . . . . . . . . . . . . . . .  8
             1.2.1.  Transcription  . . . . . . . . . . . . . . . . .  8
             1.2.2.  Separating Identification from Interaction . . .  9
             1.2.3.  Hierarchical Identifiers . . . . . . . . . . . . 10
       1.3.  Syntax Notation  . . . . . . . . . . . . . . . . . . . . 11
   2.  Characters . . . . . . . . . . . . . . . . . . . . . . . . . . 11
       2.1.  Percent-Encoding . . . . . . . . . . . . . . . . . . . . 12
       2.2.  Reserved Characters  . . . . . . . . . . . . . . . . . . 12
       2.3.  Unreserved Characters  . . . . . . . . . . . . . . . . . 13
       2.4.  When to Encode or Decode . . . . . . . . . . . . . . . . 14
       2.5.  Identifying Data . . . . . . . . . . . . . . . . . . . . 14
   3.  Syntax Components  . . . . . . . . . . . . . . . . . . . . . . 16
       3.1.  Scheme . . . . . . . . . . . . . . . . . . . . . . . . . 17
       3.2.  Authority  . . . . . . . . . . . . . . . . . . . . . . . 17
             3.2.1.  User Information . . . . . . . . . . . . . . . . 18
             3.2.2.  Host . . . . . . . . . . . . . . . . . . . . . . 18
             3.2.3.  Port . . . . . . . . . . . . . . . . . . . . . . 22
       3.3.  Path . . . . . . . . . . . . . . . . . . . . . . . . . . 22
       3.4.  Query  . . . . . . . . . . . . . . . . . . . . . . . . . 23
       3.5.  Fragment . . . . . . . . . . . . . . . . . . . . . . . . 24
   4.  Usage  . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25
       4.1.  URI Reference  . . . . . . . . . . . . . . . . . . . . . 25
       4.2.  Relative Reference . . . . . . . . . . . . . . . . . . . 26
       4.3.  Absolute URI . . . . . . . . . . . . . . . . . . . . . . 27
       4.4.  Same-Document Reference  . . . . . . . . . . . . . . . . 27
       4.5.  Suffix Reference . . . . . . . . . . . . . . . . . . . . 27
   5.  Reference Resolution . . . . . . . . . . . . . . . . . . . . . 28
       5.1.  Establishing a Base URI  . . . . . . . . . . . . . . . . 28
             5.1.1.  Base URI Embedded in Content . . . . . . . . . . 29
             5.1.2.  Base URI from the Encapsulating Entity . . . . . 29
             5.1.3.  Base URI from the Retrieval URI  . . . . . . . . 30
             5.1.4.  Default Base URI . . . . . . . . . . . . . . . . 30
       5.2.  Relative Resolution  . . . . . . . . . . . . . . . . . . 30
             5.2.1.  Pre-parse the Base URI . . . . . . . . . . . . . 31
             5.2.2.  Transform References . . . . . . . . . . . . . . 31
             5.2.3.  Merge Paths  . . . . . . . . . . . . . . . . . . 32
             5.2.4.  Remove Dot Segments  . . . . . . . . . . . . . . 33
       5.3.  Component Recomposition  . . . . . . . . . . . . . . . . 35
       5.4.  Reference Resolution Examples  . . . . . . . . . . . . . 35
             5.4.1.  Normal Examples  . . . . . . . . . . . . . . . . 36
             5.4.2.  Abnormal Examples  . . . . . . . . . . . . . . . 36
   6.  Normalization and Comparison . . . . . . . . . . . . . . . . . 38
       6.1.  Equivalence  . . . . . . . . . . . . . . . . . . . . . . 38
       6.2.  Comparison Ladder  . . . . . . . . . . . . . . . . . . . 39
             6.2.1.  Simple String Comparison . . . . . . . . . . . . 39
             6.2.2.  Syntax-Based Normalization . . . . . . . . . . . 40
             6.2.3.  Scheme-Based Normalization . . . . . . . . . . . 41
             6.2.4.  Protocol-Based Normalization . . . . . . . . . . 42
   7.  Security Considerations  . . . . . . . . . . . . . . . . . . . 43
       7.1.  Reliability and Consistency  . . . . . . . . . . . . . . 43
       7.2.  Malicious Construction . . . . . . . . . . . . . . . . . 43
       7.3.  Back-End Transcoding . . . . . . . . . . . . . . . . . . 44
       7.4.  Rare IP Address Formats  . . . . . . . . . . . . . . . . 45
       7.5.  Sensitive Information  . . . . . . . . . . . . . . . . . 45
       7.6.  Semantic Attacks . . . . . . . . . . . . . . . . . . . . 45
   8.  IANA Considerations  . . . . . . . . . . . . . . . . . . . . . 46
   9.  Acknowledgements . . . . . . . . . . . . . . . . . . . . . . . 46
   10. References . . . . . . . . . . . . . . . . . . . . . . . . . . 46
       10.1. Normative References . . . . . . . . . . . . . . . . . . 46
       10.2. Informative References . . . . . . . . . . . . . . . . . 47
   A.  Collected ABNF for URI . . . . . . . . . . . . . . . . . . . . 49
   B.  Parsing a URI Reference with a Regular Expression  . . . . . . 50
   C.  Delimiting a URI in Context  . . . . . . . . . . . . . . . . . 51
   D.  Changes from RFC 2396  . . . . . . . . . . . . . . . . . . . . 53
       D.1.  Additions  . . . . . . . . . . . . . . . . . . . . . . . 53
       D.2.  Modifications  . . . . . . . . . . . . . . . . . . . . . 53
   Index  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 56
   Authors' Addresses . . . . . . . . . . . . . . . . . . . . . . . . 60
   Full Copyright Statement . . . . . . . . . . . . . . . . . . . . . 61
```

---
## **1.  Introduction**

URI\(Uniform Resource Identifier\)는 리소스를 식별하기 위한 간단하고 확장 가능한 수단을 제공합니다. URI 구문 및 의미 체계에 대한 이 사양은 World Wide Web 글로벌 정보 이니셔티브에서 도입한 개념에서 파생되었으며, 이 식별자는 1990년부터 사용되었으며 "WWW의 범용 리소스 식별자" \[RFC1630\]에 설명되어 있습니다. 구문은 "인터넷 리소스 로케이터에 대한 기능 권장 사항" \[RFC1736\] 및 "Uniform Resource Names에 대한 기능 요구 사항" \[RFC1737\]에 제시된 권장 사항을 충족하도록 설계되었습니다.

이 문서는 모든 URI에 대한 단일 일반 구문을 정의하기 위해 "Uniform Resource Locators" \[RFC1738\] 및 "Relative 균일 리소스 로케이터" \[RFC1808\]를 병합한 \[RFC2396\]을 더 이상 사용하지 않습니다. 이는 IPv6 주소에 대한 구문을 도입한 \[RFC2732\]를 더 이상 사용하지 않습니다. 개별 URI 체계의 특정 구문을 정의한 RFC 1738의 일부는 제외됩니다. 해당 부분은 별도의 문서로 업데이트됩니다. 새로운 URI 체계를 등록하는 과정은 \[BCP35\]에 별도로 정의되어 있다. 새로운 URI 체계 설계자를 위한 조언은 \[RFC2718\]에서 찾을 수 있습니다. RFC 2396의 모든 중요한 변경 사항은 부록 D에 나와 있습니다.

본 사양에서는 \[BCP19\]에 제공된 정의에 따라 "문자" 및 "코드화된 문자 집합"이라는 용어를 사용하고, \[BCP19\]가 "문자 집합"이라고 부르는 대신 "문자 인코딩"을 사용합니다.

---
### **1.1.  Overview of URIs**

URI는 다음과 같은 특징이 있습니다.

```text
   Uniform
```

- 균일성은 여러 가지 이점을 제공합니다. 해당 리소스에 액세스하는 데 사용되는 메커니즘이 다를 수 있는 경우에도 동일한 컨텍스트에서 다양한 유형의 리소스 식별자를 사용할 수 있습니다. 다양한 유형의 리소스 식별자에 걸쳐 공통 구문 규칙을 균일하게 의미적으로 해석할 수 있습니다. 기존 식별자가 사용되는 방식을 방해하지 않고 새로운 유형의 리소스 식별자를 도입할 수 있습니다. 이를 통해 식별자를 다양한 컨텍스트에서 재사용할 수 있으므로 새로운 애플리케이션이나 프로토콜이 기존의 크고 널리 사용되는 리소스 식별자 세트를 활용할 수 있습니다.

```text
   Resource
```

- 이 사양은 리소스가 될 수 있는 범위를 제한하지 않습니다. 오히려 "리소스"라는 용어는 URI로 식별할 수 있는 모든 항목에 대해 일반적인 의미로 사용됩니다. 익숙한 예로는 전자 문서, 이미지, 일관된 목적을 가진 정보 소스\(예: "오늘의 로스앤젤레스 일기 예보"\), 서비스\(예: HTTP-SMS 게이트웨이\) 및 기타 컬렉션이 있습니다. 자원. 리소스에 반드시 인터넷을 통해 액세스할 수 있는 것은 아닙니다. 예를 들어, 인간, 기업, 도서관의 책도 자원이 될 수 있습니다. 마찬가지로 추상 개념은 수학 방정식의 연산자 및 피연산자, 관계 유형\(예: "부모" 또는 "직원"\) 또는 숫자 값\(예: 0, 1 및 무한대\)과 같은 리소스가 될 수 있습니다.

```text
   Identifier
```

- 식별자는 식별 범위 내에서 식별되는 항목을 다른 모든 항목과 구별하는 데 필요한 정보를 구현합니다. "식별" 및 "식별"이라는 용어의 사용은 해당 목적이 달성되는 방식\(예: 이름, 주소 또는 문맥\)에 관계없이 하나의 자원을 다른 모든 자원과 구별하려는 목적을 나타냅니다. 이러한 용어는 식별자가 참조된 항목의 ID를 정의하거나 구현한다는 가정으로 오해되어서는 안 됩니다. 그러나 일부 식별자의 경우에는 그럴 수 있습니다. 또한 URI를 사용하는 시스템이 식별된 리소스에 액세스할 것이라고 가정해서는 안 됩니다. 많은 경우 URI는 액세스하려는 의도 없이 리소스를 나타내는 데 사용됩니다. 마찬가지로, 식별된 "하나의" 리소스는 본질적으로 단일하지 않을 수 있습니다\(예: 리소스는 명명된 집합이거나 시간에 따라 변하는 매핑일 수 있음\).

URI는 섹션 3의 <URI\>라는 구문 규칙과 일치하는 일련의 문자로 구성된 식별자입니다. 이는 별도로 정의된 확장 가능한 명명 체계 세트\(섹션 3.1\)를 통해 리소스의 균일한 식별을 가능하게 합니다. 식별이 수행, 할당 또는 활성화되는 방법은 각 체계 사양에 위임됩니다.

이 사양은 리소스의 특성, 애플리케이션이 리소스를 참조하려고 하는 이유 또는 리소스 식별을 위해 URI를 사용할 수 있는 시스템 종류에 제한을 두지 않습니다. 이 사양에서는 URI가 시간이 지나도 동일한 리소스를 식별하는 데 지속되어야 한다고 요구하지 않습니다. 그러나 이는 모든 URI 체계의 공통 목표입니다. 그럼에도 불구하고 이 내용에는 아무것도 없습니다

사양은 애플리케이션이 특정 유형의 리소스나 해당 애플리케이션이 원하는 특성을 유지하는 URI의 하위 집합으로 제한되는 것을 방지합니다.

URI는 전역 범위를 가지며 컨텍스트에 관계없이 일관되게 해석됩니다. 하지만 해당 해석의 결과는 최종 사용자의 컨텍스트와 관련될 수 있습니다. 예를 들어, "http://localhost/"는 "localhost"에 해당하는 네트워크 인터페이스가 각 최종 사용자마다 다를 수 있더라도 해당 참조의 모든 사용자에 대해 동일한 해석을 갖습니다. 해석은 액세스와 무관합니다. 그러나 해당 참조를 기반으로 수행된 작업은 최종 사용자의 컨텍스트와 관련하여 발생합니다. 이는 전역적으로 고유한 항목을 참조하려는 작업이 해당 리소스를 다른 모든 항목과 구별하는 URI를 사용해야 함을 의미합니다. 최종 사용자의 로컬 컨텍스트와 관련하여 식별되는 URI는 온라인 도움말 매뉴얼이 최종 사용자의 파일 시스템에 있는 파일을 참조하는 경우\(예: , "파일:///etc/hosts"\).

---
#### **1.1.1.  Generic Syntax**

각 URI는 섹션 3.1에 정의된 대로 해당 체계 내에서 식별자를 할당하기 위한 사양을 나타내는 체계 이름으로 시작합니다. 따라서 URI 구문은 각 체계의 사양이 해당 체계를 사용하는 식별자의 구문과 의미를 추가로 제한할 수 있는 통합되고 확장 가능한 명명 시스템입니다.

이 사양은 모든 URI 체계에 필요하거나 많은 URI 체계에 공통적인 URI 구문 요소를 정의합니다. 따라서 이는 URI 참조에 대한 체계 독립적 구문 분석 메커니즘을 구현하는 데 필요한 구문과 의미를 정의하며, 이를 통해 체계 종속 의미 체계가 필요할 때까지 URI의 체계 종속 처리를 연기할 수 있습니다. 마찬가지로, URI 참조를 사용하는 프로토콜 및 데이터 형식은 아직 정의되지 않은 체계를 포함하여 모든 URI에 허용되는 구문 범위에 대한 정의로 이 사양을 참조할 수 있습니다. 이는 URI를 사용하는 프로토콜, 데이터 형식 및 구현의 진화에서 식별 체계의 진화를 분리합니다.

일반 URI 구문 분석기는 모든 URI 참조를 주요 구성 요소로 구문 분석할 수 있습니다. 체계가 결정되면 구성 요소에 대해 추가 체계별 구문 분석을 수행할 수 있습니다. 즉, URI 일반 구문은 모든 URI 체계 구문의 상위 집합입니다.

---
#### **1.1.2.  Examples**

다음 예제 URI는 일반적인 구문 구성 요소의 여러 URI 체계와 변형을 보여줍니다.

```text
      ftp://ftp.is.co.za/rfc/rfc1808.txt

      http://www.ietf.org/rfc/rfc2396.txt

      ldap://[2001:db8::7]/c=GB?objectClass?one

      mailto:John.Doe@example.com

      news:comp.infosystems.www.servers.unix

      tel:+1-816-555-1212

      telnet://192.0.2.16:80/

      urn:oasis:names:specification:docbook:dtd:xml:4.1.2
```

---
#### **1.1.3.  URI, URL, and URN**

URI는 위치 지정자, 이름 또는 둘 다로 더 분류될 수 있습니다. "Uniform Resource Locator"\(URL\)라는 용어는 리소스를 식별하는 것 외에도 기본 액세스 메커니즘\(예: 네트워크 "위치"\)을 설명하여 리소스를 찾는 수단을 제공하는 URI의 하위 집합을 나타냅니다. "URN\(Uniform Resource Name\)"이라는 용어는 역사적으로 "urn" 구성표 \[RFC2141\] 하에서 두 URI를 모두 참조하는 데 사용되었습니다. 이 두 URI는 리소스가 더 이상 존재하지 않거나 사용할 수 없게 된 경우에도 전역적으로 고유하고 지속성을 유지해야 합니다. 이름의 속성을 가진 다른 URI로.

개별 구성표는 "이름" 또는 "위치 지정자" 중 하나로 분류될 필요는 없습니다. 지정된 체계의 URI 인스턴스는 이름이나 위치 지정자 또는 둘 다의 특성을 가질 수 있으며, 이는 체계의 품질보다는 명명 기관이 식별자를 할당하는 데 있어 지속성과 주의에 따라 결정되는 경우가 많습니다. 향후 사양 및 관련 문서에서는 보다 제한적인 용어 "URL" 및 "URN"\[RFC3305\]보다는 일반 용어 "URI"를 사용해야 합니다.

---
### **1.2.  Design Considerations**
---
#### **1.2.1.  Transcription**

URI 구문은 전역 전사를 주요 고려 사항 중 하나로 설계되었습니다. URI는 기본 라틴 알파벳 문자, 숫자 및 몇 가지 특수 문자 등 매우 제한된 집합의 문자 시퀀스입니다. URI는 다양한 방식으로 표현될 수 있습니다. 예를 들어 종이의 잉크, 화면의 픽셀 또는 일련의 문자 인코딩 옥텟 등입니다. URI의 해석은 사용된 문자에만 의존하며 해당 문자가 네트워크 프로토콜에서 표현되는 방식에는 의존하지 않습니다.

전사의 목표는 간단한 시나리오로 설명할 수 있습니다. Sam과 Kim이라는 두 동료가 국제 컨퍼런스의 한 술집에 앉아 연구 아이디어를 교환하고 있다고 상상해 보십시오. Sam은 더 많은 정보를 얻기 위해 Kim에게 위치를 요청하고 Kim은 냅킨에 연구 사이트의 URI를 적습니다. 집에 돌아온 샘은 냅킨을 꺼내 컴퓨터에 URI를 입력하면 컴퓨터는 김이 언급한 정보를 검색한다.

시나리오에서 밝혀진 몇 가지 디자인 고려 사항은 다음과 같습니다.

- URI는 항상 옥텟 시퀀스로 표시되지 않는 문자 시퀀스입니다.

- URI는 네트워크가 아닌 소스에서 복사될 수 있으므로 언어와 로케일 전반에 걸쳐 키보드\(및 관련 입력 장치\)에 의해 부과된 제약 내에서 컴퓨터에 입력될 가능성이 가장 높은 문자로 구성되어야 합니다.

- URI는 사람들이 기억해야 하는 경우가 많으며 의미 있거나 친숙한 구성 요소로 구성되면 사람들이 URI를 기억하기가 더 쉽습니다.

이러한 설계 고려 사항이 항상 일치하는 것은 아닙니다. 예를 들어, URI 구성 요소의 가장 의미 있는 이름을 지정하려면 일부 시스템에서는 입력할 수 없는 문자가 필요한 경우가 많습니다. 한 매체에서 다른 매체로 자원 식별자를 전사하는 능력은 가장 의미 있는 구성요소로 구성된 URI를 갖는 것보다 더 중요하게 간주되어 왔습니다.

지역적 맥락에서 그리고 기술이 발전함에 따라 사용자는 더 넓은 범위의 문자를 사용할 수 있다는 이점을 누릴 수 있습니다. 그러한 사용은 이 사양에 의해 정의되지 않습니다. 퍼센트 인코딩 옥텟\(섹션 2.1\)은 URI 내에서 다음과 같은 경우 US-ASCII 코드 문자 집합 범위 밖의 문자를 나타내는 데 사용될 수 있습니다.

표현은 URI가 참조되는 프로토콜 요소나 체계에 의해 허용됩니다. 이러한 정의는 URI에 대해 퍼센트 인코딩되기 전에 해당 문자를 옥텟에 매핑하는 데 사용되는 문자 인코딩을 지정해야 합니다.

---
#### **1.2.2.  Separating Identification from Interaction**

URI에 대한 일반적인 오해는 URI가 액세스 가능한 리소스를 참조하는 데만 사용된다는 것입니다. URI 자체는 식별만 제공합니다. 리소스에 대한 액세스는 URI의 존재 여부에 따라 보장되거나 암시되지 않습니다. 대신, URI 참조와 관련된 모든 작업은 프로토콜 요소, 데이터 형식 속성 또는 그것이 나타나는 자연어 텍스트에 의해 정의됩니다.

URI가 주어지면 시스템은 "액세스", "업데이트", "교체" 또는 "속성 찾기"와 같은 단어로 특징지어질 수 있는 것처럼 리소스에 대해 다양한 작업을 수행하려고 시도할 수 있습니다. 이러한 작업은 이 사양이 아닌 URI를 사용하는 프로토콜에 의해 정의됩니다. 그러나 URI에 대한 일반적인 작업을 설명하기 위해 몇 가지 일반 용어를 사용합니다. URI "해석"은 URI를 역참조하는 데 필요한 액세스 메커니즘과 적절한 매개변수를 결정하는 프로세스입니다. 이 해결 방법에는 여러 번의 반복이 필요할 수 있습니다. 해당 액세스 메커니즘을 사용하여 URI 리소스에 대한 작업을 수행하는 것은 URI를 "역참조"하는 것입니다.

정보 검색 시스템 내에서 정보 소스를 식별하기 위해 URI를 사용하는 경우 가장 일반적인 형태의 URI 역참조는 "검색"입니다. 즉, 관련 리소스의 표현을 검색하기 위해 URI를 사용하는 것입니다. "표현"은 해당 옥텟을 설명하는 표현 메타데이터와 함께 옥텟의 시퀀스로, 표현이 생성되는 시점의 리소스 상태에 대한 기록을 구성합니다. 검색은 URI를 캐시 키로 사용하여 로컬로 캐시된 표현을 확인하고, URI를 확인하여 적절한 액세스 메커니즘\(있는 경우\)을 결정하고, URI를 역참조하여 적용하는 프로세스를 통해 수행됩니다. 검색 작업. 검색을 수행하는 데 사용되는 프로토콜에 따라 리소스\(리소스 메타데이터\) 및 다른 리소스와의 관계에 대한 추가 정보가 제공될 수 있습니다.

정보 검색 시스템의 URI 참조는 지연 바인딩되도록 설계되었습니다. 액세스 결과는 일반적으로 액세스될 때 결정되며 시간이 지남에 따라 또는 상호 작용의 다른 측면으로 인해 달라질 수 있습니다. 이러한 참조는 미래에 사용하기 위해 만들어졌습니다. 식별되는 것은 과거에 얻은 특정 결과가 아니라 미래 결과에 대해 사실로 예상되는 특성입니다. 이러한 경우 URI가 참조하는 리소스는 실제로 관찰된 특성과 동일합니다.

시간이 지남에 따라 리소스 공급자의 추가 의견이나 주장을 통해 설명될 수 있습니다.

많은 URI 체계가 프로토콜 이름을 따서 명명되었지만 이것이 이러한 URI를 사용하면 명명된 프로토콜을 통해 리소스에 액세스한다는 의미는 아닙니다. URI는 단순히 식별을 위해 사용되는 경우가 많습니다. URI를 사용하여 리소스 표현을 검색하는 경우에도 해당 액세스는 체계 이름과 연결된 프로토콜과 독립적인 게이트웨이, 프록시, 캐시 및 이름 확인 서비스를 통해 이루어질 수 있습니다. 일부 URI를 확인하려면 둘 이상의 프로토콜을 사용해야 할 수 있습니다\(예: 로컬 캐시에서 표현을 찾을 수 없을 때 "http" URI의 원본 서버에 액세스하는 데 일반적으로 DNS와 HTTP가 모두 사용됩니다\).

---
#### **1.2.3.  Hierarchical Identifiers**

URI 구문은 왼쪽에서 오른쪽으로 중요도가 낮아지는 순서대로 구성 요소가 나열되는 계층적으로 구성됩니다. 일부 URI 체계의 경우 표시되는 계층 구조는 체계 자체로 제한됩니다. 체계 구성 요소 구분 기호\(":"\) 뒤의 모든 항목은 URI 처리에 불투명한 것으로 간주됩니다. 다른 URI 체계는 계층 구조를 명시적으로 만들고 일반 구문 분석 알고리즘에 표시되도록 합니다.

일반 구문은 슬래시\("/"\), 물음표\("?"\) 및 숫자 기호\("#"\) 문자를 사용하여 식별자에 대한 일반 구문 분석기의 계층적 해석에 중요한 구성 요소를 구분합니다. 친숙한 구문을 일관되게 사용하여 이러한 식별자의 가독성을 높이는 것 외에도 명명 체계 전반에 걸쳐 계층을 통일적으로 표현하면 해당 계층을 기준으로 체계 독립적인 참조를 만들 수 있습니다.

문서의 그룹 또는 "트리"가 공통 목적을 위해 구성되는 경우가 많습니다. 여기서 이러한 문서에 있는 대부분의 URI 참조는 트리 외부가 아닌 트리 내부의 리소스를 가리킵니다. 마찬가지로, 특정 사이트에 있는 문서는 원격 사이트의 리소스보다 해당 사이트의 다른 리소스를 참조할 가능성이 훨씬 더 높습니다. URI의 상대 참조를 사용하면 문서 트리가 해당 위치 및 액세스 체계와 부분적으로 독립될 수 있습니다. 예를 들어, 문서가 상대 참조를 통해 서로 참조하는 경우 "파일", "http" 및 "ftp" 체계 각각을 통해 단일 하이퍼텍스트 문서 세트에 동시에 액세스하고 탐색할 수 있습니다. 또한 이러한 문서 트리는 상대 참조를 변경하지 않고도 전체적으로 이동할 수 있습니다.

상대 참조\(섹션 4.2\)는 참조 컨텍스트와 대상 URI 간의 계층적 이름 공간 내 차이를 설명하여 리소스를 참조합니다. 참조 해상도 알고리즘,

섹션 5에 제시된 내용은 그러한 참조가 대상 URI로 변환되는 방법을 정의합니다. 상대 참조는 계층적 URI의 컨텍스트 내에서만 사용될 수 있으므로, 새로운 URI 체계의 설계자는 해당 체계 내에서 상대 참조를 금지해야 하는 강력한 이유가 없는 한 일반 구문의 계층적 구성 요소와 일치하는 구문을 사용해야 합니다.

- 참고: 이전 사양에서는 URI에 대한 상대 참조를 나타내기 위해 "부분 URI" 및 "상대 URI"라는 용어를 사용했습니다. 일부 독자들은 이러한 용어를 상대 URI가 URI를 참조하는 방법이 아니라 URI의 하위 집합이라는 의미로 오해했기 때문에 이 사양에서는 이를 단순히 상대 참조라고 부릅니다.

모든 URI 참조는 사용될 때 일반 구문 분석기에 의해 구문 분석됩니다. 그러나 계층적 처리는 하나 이상의 도트 세그먼트\(섹션 3.3에 설명된 "." 또는 ".."의 전체 경로 세그먼트\)를 포함하지 않는 한 참조에 사용된 절대 URI에 영향을 미치지 않기 때문에 URI 체계 사양은 슬래시 문자, 물음표 문자 및 URI "scheme:"의 사용을 허용하지 않음으로써 불투명 식별자를 정의합니다. 그리고 "구성표:..".

---
### **1.3.  Syntax Notation**

이 사양은 해당 사양에 정의된 다음 핵심 ABNF 구문 규칙을 포함하여 \[RFC2234\]의 ABNF\(Augmented Backus-Naur Form\) 표기법을 사용합니다: ALPHA\(문자\), CR\(캐리지 리턴\), DIGIT\(십진수\), DQUOTE\(이중 숫자\) quote\), HEXDIG\(16진수\), LF\(줄 바꿈\) 및 SP\(공백\). 전체 URI 구문은 부록 A에 수집되어 있습니다.

---
## **2.  Characters**

URI 구문은 아마도 리소스를 식별하기 위해 데이터를 일련의 문자로 인코딩하는 방법을 제공합니다. 그러면 URI 문자는 전송이나 표시를 위해 옥텟으로 인코딩되는 경우가 많습니다. 이 사양은 URI 문자와 해당 문자를 저장하거나 전송하는 데 사용되는 옥텟 간의 매핑을 위한 특정 문자 인코딩을 요구하지 않습니다. URI가 프로토콜 요소에 나타나면 문자 인코딩은 해당 프로토콜에 의해 정의됩니다. 이러한 정의가 없으면 URI는 주변 텍스트와 동일한 문자 인코딩을 사용하는 것으로 간주됩니다.

ABNF 표기법은 터미널 값을 US-ASCII 코드 문자 집합\[ASCII\]을 기반으로 음이 아닌 정수\(코드 포인트\)로 정의합니다. URI는 일련의 문자이기 때문에 URI 구문을 이해하려면 해당 관계를 뒤집어야 합니다. 그러므로,

구문 규칙을 완성하려면 ABNF에서 사용하는 정수 값을 US-ASCII를 통해 해당 문자에 다시 매핑해야 합니다.

URI는 숫자, 문자 및 몇 가지 그래픽 기호로 구성된 제한된 문자 집합으로 구성됩니다. 이러한 문자의 예약된 하위 집합은 URI 내의 구문 구성 요소를 구분하는 데 사용될 수 있으며 예약되지 않은 집합과 구분 기호 역할을 하지 않는 예약 문자를 포함한 나머지 문자는 각 구성 요소의 식별 데이터를 정의합니다.

---
### **2.1.  Percent-Encoding**

백분율 인코딩 메커니즘은 해당 옥텟의 해당 문자가 허용된 집합 외부에 있거나 구성 요소의 구분 기호로 사용되거나 구성 요소 내에 있는 경우 구성 요소의 데이터 옥텟을 나타내는 데 사용됩니다. 퍼센트 인코딩 옥텟은 퍼센트 문자 "%" 뒤에 해당 옥텟의 숫자 값을 나타내는 두 개의 16진수 숫자로 구성된 삼중 문자로 인코딩됩니다. 예를 들어, "%20"은 이진 옥텟 "00100000"\(ABNF: %x20\)에 대한 백분율 인코딩이며 US-ASCII에서는 공백 문자\(SP\)에 해당합니다. 섹션 2.4에서는 퍼센트 인코딩과 디코딩이 적용되는 시기를 설명합니다.

```text
      pct-encoded = "%" HEXDIG HEXDIG
```

대문자 16진수 'A'\~'F'는 각각 소문자 'a'\~'f'와 동일합니다. 두 URI가 백분율로 인코딩된 옥텟에 사용된 16진수 숫자의 경우에만 다른 경우에는 동일합니다. 일관성을 위해 URI 생성자와 노멀라이저는 모든 백분율 인코딩에 대해 대문자 16진수를 사용해야 합니다.

---
### **2.2.  Reserved Characters**

URI에는 "예약된" 집합의 문자로 구분된 구성 요소와 하위 구성 요소가 포함됩니다. 이러한 문자는 일반 구문, 각 체계별 구문 또는 URI 역참조 알고리즘의 구현별 구문에 의해 구분 기호로 정의될 수도 있고 정의되지 않을 수도 있기 때문에 "예약된" 문자라고 합니다. URI 구성 요소의 데이터가 예약 문자의 구분 기호 목적과 충돌하는 경우 URI가 형성되기 전에 충돌하는 데이터를 백분율로 인코딩해야 합니다.

```text
      reserved    = gen-delims / sub-delims

      gen-delims  = ":" / "/" / "?" / "#" / "[" / "]" / "@"

      sub-delims  = "!" / "$" / "&" / "'" / "(" / ")"
                  / "*" / "+" / "," / ";" / "="
```

예약된 문자의 목적은 URI 내의 다른 데이터와 구별할 수 있는 구분 문자 집합을 제공하는 것입니다. 예약된 문자를 해당 백분율로 인코딩된 옥텟으로 대체하는 방식이 다른 URI는 동일하지 않습니다. 예약된 문자를 백분율로 인코딩하거나 예약된 문자에 해당하는 백분율로 인코딩된 옥텟을 디코딩하면 대부분의 응용 프로그램에서 URI를 해석하는 방식이 변경됩니다. 따라서 예약된 집합의 문자는 정규화로부터 보호되므로 URI 내의 데이터 하위 구성 요소를 구분하기 위해 체계별 및 생산자별 알고리즘에서 안전하게 사용할 수 있습니다.

예약된 문자\(gen-delims\)의 하위 집합은 섹션 3에 설명된 일반 URI 구성 요소의 구분 기호로 사용됩니다. 구성 요소의 ABNF 구문 규칙은 예약된 또는 gen-delims 규칙 이름을 직접 사용하지 않습니다. 대신, 각 구문 규칙은 해당 구성 요소 내에서 허용되는 문자\(즉, 구분하지 않음\)를 나열하고, 예약된 집합에도 있는 이러한 문자는 구성 요소 내의 하위 구성 요소 구분 기호로 사용하기 위해 "예약"됩니다. 이 사양에서는 가장 일반적인 하위 구성 요소만 정의합니다. 다른 하위 구성 요소는 URI 체계의 사양이나 URI 역참조 알고리즘의 구현별 구문에 의해 정의될 수 있습니다. 단, 이러한 하위 구성 요소는 해당 구성 요소 내에서 허용되는 예약 세트의 문자로 구분됩니다.

URI 생성 응용 프로그램은 예약된 집합의 문자에 해당하는 데이터 옥텟을 백분율로 인코딩해야 합니다. 단, 이러한 문자가 해당 구성 요소의 데이터를 나타내기 위해 URI 체계에서 특별히 허용되지 않는 한은 아닙니다. 예약된 문자가 URI 구성 요소에 있고 해당 문자에 대해 알려진 구분 역할이 없는 경우 US-ASCII의 해당 문자 인코딩에 해당하는 데이터 옥텟을 나타내는 것으로 해석되어야 합니다.

---
### **2.3.  Unreserved Characters**

URI에 허용되지만 예약된 용도가 없는 문자를 예약되지 않은 문자라고 합니다. 여기에는 대문자 및 소문자, 십진수, 하이픈, 마침표, 밑줄 및 물결표가 포함됩니다.

```text
      unreserved  = ALPHA / DIGIT / "-" / "." / "_" / "~"
```

예약되지 않은 문자를 해당 백분율로 인코딩된 US-ASCII 옥텟으로 대체하는 방식이 다른 URI는 동일합니다. 즉, 동일한 리소스를 식별합니다. 그러나 URI 비교 구현이 항상 비교 전에 정규화를 수행하는 것은 아닙니다\(섹션 6 참조\). 일관성을 위해 ALPHA\(%41-%5A 및 %61-%7A\), DIGIT\(%30-%39\), 하이픈\(%2D\), 마침표\(%2E\), 밑줄\(%\) 범위의 백분율로 인코딩된 옥텟 5F\) 또는 물결표\(%7E\)는 URI 생성자가 생성해서는 안 되며, URI에서 발견되면 URI 정규화 프로그램을 통해 해당 예약되지 않은 문자로 디코딩되어야 합니다.

---
### **2.4.  When to Encode or Decode**

일반적인 상황에서 URI 내의 옥텟이 백분율로 인코딩되는 유일한 시간은 해당 구성 요소 부분에서 URI를 생성하는 프로세스 동안입니다. 이는 구현 시 예약된 문자 중 어떤 문자가 하위 구성 요소 구분 기호로 사용되고 어떤 문자가 데이터로 안전하게 사용될 수 있는지 결정하는 경우입니다. 일단 생성된 URI는 항상 백분율로 인코딩된 형식입니다.

URI가 역참조될 때 체계별 역참조 프로세스에 중요한 구성 요소 및 하위 구성 요소\(있는 경우\)는 해당 구성 요소 내의 백분율 인코딩 옥텟이 안전하게 디코딩될 수 있기 전에 구문 분석되고 분리되어야 합니다. 그렇지 않으면 데이터가 구성 요소로 오해될 수 있습니다. 구분 기호. 유일한 예외는 언제든지 디코딩할 수 있는 예약되지 않은 세트의 문자에 해당하는 백분율로 인코딩된 옥텟입니다. 예를 들어 물결표\("\~"\) 문자에 해당하는 옥텟은 이전 URI 처리 구현에서 "%7E"로 인코딩되는 경우가 많습니다. "%7E"는 해석을 변경하지 않고 "\~"로 대체될 수 있습니다.

퍼센트\("%"\) 문자는 퍼센트 인코딩된 옥텟에 대한 표시기 역할을 하기 때문에 해당 옥텟이 URI 내에서 데이터로 사용되려면 "%25"로 퍼센트 인코딩되어야 합니다. 구현 시 동일한 문자열을 두 번 이상 퍼센트 인코딩하거나 디코딩해서는 안 됩니다. 이미 디코딩된 문자열을 디코딩하면 퍼센트 데이터 옥텟을 퍼센트 인코딩의 시작으로 잘못 해석할 수 있고, 그 반대의 경우도 마찬가지입니다. 퍼센트 인코딩된 문자열입니다.

---
### **2.5.  Identifying Data**

URI 문자는 각 URI 구성 요소에 대한 식별 데이터를 제공하여 시스템 간 식별을 위한 외부 인터페이스 역할을 합니다. URI 생성 인터페이스의 존재와 성격은 해당 URI를 사용하는 클라이언트에게 숨겨지지만\(따라서 이 사양에서 정의한 상호 운용성 요구 사항의 범위를 벗어남\) URI 문자 해석에 혼란과 오류가 자주 발생합니다. 문제. 구현자는 다음과 관련된 여러 문자 인코딩이 있음을 인식해야 합니다.

URI 생성 및 전송: 로컬 이름 및 데이터 인코딩, 공용 인터페이스 인코딩, URI 문자 인코딩, 데이터 형식 인코딩 및 프로토콜 인코딩.

파일 시스템 이름과 같은 로컬 이름은 로컬 문자 인코딩으로 저장됩니다. URI 생성 애플리케이션\(예: 원본 서버\)은 일반적으로 의미 있는 이름을 생성하기 위한 기초로 로컬 인코딩을 사용합니다. URI 생산자는 로컬 인코딩을 공용 인터페이스에 적합한 인코딩으로 변환한 다음 공용 인터페이스 인코딩을 제한된 URI 문자 집합\(예약됨, 예약되지 않음 및 백분율 인코딩\)으로 변환합니다. 이러한 문자는 데이터 형식\(예: 문서 문자 집합\) 내에서 참조로 사용하기 위해 옥텟으로 인코딩되며, 이러한 데이터 형식은 인터넷 프로토콜을 통한 전송을 위해 나중에 인코딩되는 경우가 많습니다.

대부분의 시스템에서 URI 구성 요소 내에 나타나는 예약되지 않은 문자는 US-ASCII의 해당 문자 인코딩에 해당하는 데이터 옥텟을 나타내는 것으로 해석됩니다. URI 소비자는 문자 "X"가 옥텟 "01011000"에 해당한다고 가정하며, 그 가정이 잘못된 경우에도 이를 작성하는 데 아무런 해가 없습니다. EBCDIC와 같이 다른 문자 인코딩 형태로 식별자를 내부적으로 제공하는 시스템은 일반적으로 내부에서 텍스트 식별자를 UTF-8 \[STD63\]\(또는 US-ASCII 문자 인코딩의 다른 상위 집합\)로 문자 변환합니다. 인터페이스를 통해 단순히 원래 옥텟을 퍼센트 인코딩하여 생성된 것보다 더 의미 있는 식별자를 제공합니다.

예를 들어, EBCDIC 기반 파일 시스템을 사용하여 로컬로 저장된 데이터를 HTTP 서버를 통해 인터넷의 클라이언트에 제공하는 정보 서비스를 생각해 보십시오. 작성자가 해당 파일 시스템에 "Laguna Beach"라는 이름의 파일을 생성하면 해당 리소스에 해당하는 "http" URI에는 "Laguna%20Beach"라는 의미 있는 문자열이 포함될 것으로 예상됩니다. 그러나 해당 서버가 지나치게 단순한 원시 옥텟 매핑을 사용하여 URI를 생성하는 경우 결과는 "%D3%81%87%A4%95%81@%C2%85%81%83%88"을 포함하는 URI가 됩니다. . 내부 트랜스코딩 인터페이스는 URI를 생성하기 전에 로컬 이름을 US-ASCII의 상위 집합으로 트랜스코딩하여 이 문제를 해결합니다. 당연히 이러한 인터페이스에서 수신 URI를 적절하게 해석하려면 로컬 이름을 얻기 위해 역방향 트랜스코딩을 적용하기 전에 백분율로 인코딩된 옥텟을 디코딩해야 합니다\(예: "%20"에서 SP로\).

어떤 경우에는 URI 구성 요소와 그것이 표현하도록 제작된 식별 데이터 사이의 내부 인터페이스가 문자 인코딩 변환보다 훨씬 덜 직접적입니다. 예를 들어 URI의 일부는 비ASCII 데이터에 대한 쿼리를 반영하거나 숫자를 반영할 수 있습니다.

지도상의 좌표. 마찬가지로, URI 체계는 구성 요소를 형성하고 URI를 생성하기 전에 적용되는 추가 인코딩 요구 사항으로 구성 요소를 정의할 수 있습니다.

새로운 URI 체계가 UCS\(Universal Character Set\)의 문자로 구성된 텍스트 데이터를 나타내는 구성 요소를 정의하는 경우 데이터는 먼저 UTF-8 문자 인코딩\[STD63\]에 따라 옥텟으로 인코딩되어야 합니다. 그러면 예약되지 않은 집합의 문자에 해당하지 않는 옥텟만 백분율로 인코딩되어야 합니다. 예를 들어 문자 A는 "A"로 표시되고 LATIN CAPITAL LETTER A WITH GRAVE 문자는 "%C3%80"으로 표시되며 KATAKANA LETTER A 문자는 "%E3%82%A2"로 표시됩니다. ".

---
## **3.  Syntax Components**

일반 URI 구문은 체계, 권한, 경로, 쿼리 및 조각이라고 하는 구성 요소의 계층적 시퀀스로 구성됩니다.

```text
      URI         = scheme ":" hier-part [ "?" query ] [ "#" fragment ]

      hier-part   = "//" authority path-abempty
                  / path-absolute
                  / path-rootless
                  / path-empty
```

구성표 및 경로 구성 요소는 필수이지만 경로는 비어 있을 수 있습니다\(문자 없음\). 권한이 있는 경우 경로는 비어 있거나 슬래시\("/"\) 문자로 시작되어야 합니다. 권한이 없는 경우 경로는 두 개의 슬래시 문자\("//"\)로 시작할 수 없습니다. 이러한 제한으로 인해 경로에 대해 5개의 서로 다른 ABNF 규칙이 생성되며\(섹션 3.3\) 그 중 하나만 지정된 URI 참조와 일치합니다.

다음은 두 가지 예시 URI와 해당 구성 요소 부분입니다.

```text
         foo://example.com:8042/over/there?name=ferret#nose
         \_/   \______________/\_________/ \_________/ \__/
          |           |            |            |        |
       scheme     authority       path        query   fragment
          |   _____________________|__
         / \ /                        \
         urn:example:animal:ferret:nose
```

---
### **3.1.  Scheme**

각 URI는 해당 체계 내에서 식별자를 할당하기 위한 사양을 참조하는 체계 이름으로 시작됩니다. 따라서 URI 구문은 각 체계의 사양이 해당 체계를 사용하는 식별자의 구문과 의미를 추가로 제한할 수 있는 통합되고 확장 가능한 명명 시스템입니다.

구성표 이름은 문자로 시작하고 문자, 숫자, 더하기\("+"\), 마침표\("."\) 또는 하이픈\("-"\)의 조합이 뒤따르는 일련의 문자로 구성됩니다. 체계는 대소문자를 구분하지 않지만 표준 형식은 소문자이며 체계를 지정하는 문서는 소문자를 사용해야 합니다. 구현에서는 견고성을 위해 대문자를 체계 이름의 소문자와 동일하게 허용해야 하지만\(예: "HTTP" 및 "http" 허용\) 일관성을 위해 소문자 체계 이름만 생성해야 합니다.

```text
      scheme      = ALPHA *( ALPHA / DIGIT / "+" / "-" / "." )
```

이 문서에서는 개별 구성표를 지정하지 않습니다. 새로운 URI 체계를 등록하는 과정은 \[BCP35\]에 별도로 정의되어 있다. 체계 레지스트리는 체계 이름과 해당 사양 간의 매핑을 유지 관리합니다. 새로운 URI 체계 설계자를 위한 조언은 \[RFC2718\]에서 찾을 수 있습니다. URI 체계 사양은 섹션 4.3에 설명된 대로 체계별 구문과 일치하는 모든 문자열이 <absolute-URI\> 문법과도 일치하도록 자체 구문을 정의해야 합니다.

하나 이상의 체계별 제한 사항을 위반하는 URI가 표시되면 체계별 해결 프로세스는 사용되지 않는 부분을 무시하는 대신 참조를 오류로 표시해야 합니다. 이렇게 하면 동등한 URI 수가 줄어들고 URI가 사용자를 오도하도록 구성되었음을 나타낼 수 있는 일반 구문의 남용을 감지하는 데 도움이 됩니다\(섹션 7.6\).

---
### **3.2.  Authority**

많은 URI 체계에는 명명 기관에 대한 계층적 요소가 포함되어 있어 URI의 나머지 부분에 의해 정의된 이름 공간의 관리가 해당 기관에 위임됩니다\(이 기관은 나중에 이를 추가로 위임할 수도 있음\). 일반 구문은 선택적인 포트 및 사용자 정보와 함께 등록된 이름이나 서버 주소를 기반으로 권한을 구별하기 위한 일반적인 수단을 제공합니다.

권한 구성 요소 앞에는 이중 슬래시\("//"\)가 있고 다음 슬래시\("/"\), 물음표\("?"\) 또는 숫자 기호\("#"\) 문자로 종료됩니다. URI의.

```text
      authority   = [ userinfo "@" ] host [ ":" port ]
```

URI 생성자와 노멀라이저는 포트 구성 요소가 비어 있는 경우 호스트와 포트를 구분하는 ":" 구분 기호를 생략해야 합니다. 일부 체계에서는 userinfo 및/또는 port 하위 구성 요소를 허용하지 않습니다.

URI에 권한 구성 요소가 포함된 경우 경로 구성 요소는 비어 있거나 슬래시\("/"\) 문자로 시작되어야 합니다. 유효성을 검사하지 않는 파서\(URI 참조를 주요 구성 요소로 단순히 분리하는 파서\)는 기관의 하위 구성 요소 구조를 종종 무시하여 URI가 다음과 같이 될 때까지 이중 슬래시부터 첫 번째 종료 구분 기호까지 불투명한 문자열로 처리합니다. 역참조됨.

---
#### **3.2.1.  User Information**

userinfo 하위 구성 요소는 사용자 이름과 선택적으로 리소스에 액세스하기 위한 권한을 얻는 방법에 대한 체계별 정보로 구성될 수 있습니다. 사용자 정보\(있는 경우\) 뒤에는 호스트와 구분하는 상업용 at 기호\("@"\)가 옵니다.

```text
      userinfo    = *( unreserved / pct-encoded / sub-delims / ":" )
```

userinfo 필드에 "user:password" 형식을 사용하는 것은 더 이상 사용되지 않습니다. 애플리케이션은 콜론 뒤의 데이터가 빈 문자열\(비밀번호 없음을 나타냄\)이 아닌 한 userinfo 하위 구성 요소 내에서 발견된 첫 번째 콜론\(":"\) 문자 뒤의 데이터를 일반 텍스트로 렌더링해서는 안 됩니다. 애플리케이션은 참조의 일부로 수신된 데이터를 무시하거나 거부하도록 선택할 수 있으며 암호화되지 않은 형식으로 해당 데이터의 저장을 거부해야 합니다. 일반 텍스트로 인증 정보를 전달하는 것은 사용된 거의 모든 경우에 보안 위험이 있는 것으로 입증되었습니다.

그래픽 하이퍼텍스트 브라우징과 같이 사용자 피드백을 위해 URI를 렌더링하는 애플리케이션은 가능한 경우 URI의 나머지 부분과 구별되는 방식으로 사용자 정보를 렌더링해야 합니다. 이러한 렌더링은 사용자 정보가 신뢰할 수 있는 도메인 이름처럼 보이도록 잘못 조작된 경우 사용자에게 도움이 됩니다\(섹션 7.6\).

---
#### **3.2.2.  Host**

권한의 호스트 하위 구성요소는 대괄호 안에 캡슐화된 IP 리터럴, 점으로 구분된 십진수 형식의 IPv4 주소 또는 등록된 이름으로 식별됩니다. 호스트 하위 구성 요소는 대소문자를 구분하지 않습니다. URI 내에 호스트 하위 구성 요소가 있다고 해서 해당 구성표에 인터넷의 지정된 호스트에 대한 액세스가 필요하다는 의미는 아닙니다. 대부분의 경우 호스트 구문은 다음 목적으로만 사용됩니다.

DNS용으로 생성 및 배포된 기존 등록 프로세스를 재사용하여 다른 레지스트리를 배포하는 비용 없이 전역적으로 고유한 이름을 얻습니다. 그러나 이러한 사용에는 그에 따른 비용이 발생합니다. 도메인 이름 소유권은 URI 제작자가 예상하지 못한 이유로 시간이 지남에 따라 변경될 수 있습니다. 다른 경우에는 호스트 구성 요소 내의 데이터가 인터넷 호스트와 아무 관련이 없는 등록된 이름을 식별합니다. ABNF 규칙에 "호스트"라는 이름을 사용하는 이유는 이것이 유일한 목적이 아니라 가장 일반적인 목적이기 때문입니다.

```text
      host        = IP-literal / IPv4address / reg-name
```

호스트의 구문 규칙은 IPv4 주소와 등록 이름을 완전히 구별하지 못하기 때문에 모호합니다. 구문을 명확하게 하기 위해 "first-match-wins" 알고리즘을 적용합니다. 호스트가 IPv4address에 대한 규칙과 일치하면 reg-name이 아닌 IPv4 주소 리터럴로 간주되어야 합니다. 호스트는 대소문자를 구분하지 않지만, 생성자와 노멀라이저는 일관성을 위해 등록된 이름과 16진수 주소에 소문자를 사용해야 하며, 퍼센트 인코딩에는 대문자만 사용해야 합니다.

인터넷 프로토콜 리터럴 주소 버전 6 \[RFC3513\] 이상으로 식별되는 호스트는 IP 리터럴을 대괄호\("\[" 및 "\]"\)로 묶어 구별됩니다. 이는 URI 구문에서 대괄호 문자가 허용되는 유일한 위치입니다. 미래의 아직 정의되지 않은 IP 리터럴 주소 형식을 예상하여 구현에서는 경험적 결정에 의존하기보다는 선택적 버전 플래그를 사용하여 그러한 형식을 명시적으로 나타낼 수 있습니다.

```text
      IP-literal = "[" ( IPv6address / IPvFuture  ) "]"

      IPvFuture  = "v" 1*HEXDIG "." 1*( unreserved / sub-delims / ":" )
```

버전 플래그는 IP 버전을 나타내지 않습니다. 오히려 리터럴 형식의 향후 버전을 나타냅니다. 따라서 구현 시 아래 설명된 기존 IPv4 및 IPv6 리터럴 주소 형식에 대한 버전 플래그를 제공해서는 안 됩니다. 버전 플래그가 있음을 나타내는 "v"\(대소문자 구분\)로 시작하는 IP 리터럴을 포함하는 URI가 해당 버전 플래그의 의미를 모르는 애플리케이션에 의해 역참조되는 경우 애플리케이션은 다음을 반환해야 합니다. "지원되지 않는 주소 메커니즘"에 대한 적절한 오류입니다.

IPv6 리터럴 주소로 식별되는 호스트는 이전 버전 플래그 없이 대괄호 안에 표시됩니다. 여기에 제공된 ABNF는 \[RFC3513\]에 제공된 IPv6 리터럴 주소의 텍스트 정의를 번역한 것입니다. 이 구문은 IPv6 범위 주소 지정 영역 식별자를 지원하지 않습니다.

128비트 IPv6 주소는 8개의 16비트 조각으로 나뉩니다. 각 부분은 1\~4개의 16진수\(앞에 0이 허용됨\)를 사용하여 대소문자를 구분하지 않는 16진수로 숫자로 표시됩니다. 8개의 인코딩된 조각은 콜론 문자로 구분되어 가장 중요한 부분부터 지정됩니다. 선택적으로 가장 중요하지 않은 두 부분이 IPv4 주소 텍스트 형식으로 대신 표시될 수도 있습니다. 주소 내에서 하나 이상의 연속된 0 값 16비트 조각의 시퀀스는 제거될 수 있으며, 모든 숫자를 생략하고 제거를 표시하기 위해 정확히 두 개의 연속 콜론을 해당 위치에 남겨 둡니다.

```text
      IPv6address =                            6( h16 ":" ) ls32
                  /                       "::" 5( h16 ":" ) ls32
                  / [               h16 ] "::" 4( h16 ":" ) ls32
                  / [ *1( h16 ":" ) h16 ] "::" 3( h16 ":" ) ls32
                  / [ *2( h16 ":" ) h16 ] "::" 2( h16 ":" ) ls32
                  / [ *3( h16 ":" ) h16 ] "::"    h16 ":"   ls32
                  / [ *4( h16 ":" ) h16 ] "::"              ls32
                  / [ *5( h16 ":" ) h16 ] "::"              h16
                  / [ *6( h16 ":" ) h16 ] "::"

      ls32        = ( h16 ":" h16 ) / IPv4address
                  ; least-significant 32 bits of address

      h16         = 1*4HEXDIG
                  ; 16 bits of address represented in hexadecimal
```

IPv4 리터럴 주소로 식별되는 호스트는 \[RFC0952\]를 참조하여 \[RFC1123\]에 설명된 대로 점으로 구분된 십진수 표기법\("."으로 구분된 0\~255 범위의 4개의 십진수 시퀀스\)으로 표시됩니다. 섹션 7.4에 설명된 대로 일부 플랫폼에서는 다른 형태의 점으로 구분된 표기법이 해석될 수 있지만 이 문법에서는 점으로 구분된 10진수 형식인 4옥텟만 허용됩니다.

```text
      IPv4address = dec-octet "." dec-octet "." dec-octet "." dec-octet

      dec-octet   = DIGIT                 ; 0-9
                  / %x31-39 DIGIT         ; 10-99
                  / "1" 2DIGIT            ; 100-199
                  / "2" %x30-34 DIGIT     ; 200-249
                  / "25" %x30-35          ; 250-255
```

등록된 이름으로 식별되는 호스트는 일반적으로 로컬로 정의된 호스트 또는 서비스 이름 레지스트리 내에서 조회하기 위한 문자 시퀀스입니다. 하지만 URI의 체계별 의미에 따라 특정 레지스트리\(또는 고정 이름 테이블\)를 대신 사용해야 할 수도 있습니다. 가장 일반적인 이름 등록 메커니즘은 DNS\(Domain Name System\)입니다. DNS에서 조회할 등록된 이름은 다음 구문을 사용합니다.

\[RFC1034\]의 섹션 3.5 및 \[RFC1123\]의 섹션 2.1에 정의되어 있습니다. 이러한 이름은 "."으로 구분된 일련의 도메인 레이블로 구성되며, 각 도메인 레이블은 영숫자 문자로 시작하고 끝나며 "-" 문자도 포함할 수 있습니다. DNS에 있는 정규화된 도메인 이름의 가장 오른쪽 도메인 레이블 뒤에는 단일 "."가 올 수 있습니다. 전체 도메인 이름과 일부 로컬 도메인을 구별해야 하는 경우에도 마찬가지입니다.

```text
      reg-name    = *( unreserved / pct-encoded / sub-delims )
```

URI 체계가 호스트에 대한 기본값을 정의하는 경우 호스트 하위 구성 요소가 정의되지 않거나 등록된 이름이 비어 있는 경우\(길이 0\) 해당 기본값이 적용됩니다. 예를 들어, "file" URI 체계는 권한 없음, 빈 호스트 및 "localhost"가 모두 최종 사용자의 컴퓨터를 의미하도록 정의되는 반면, "http" 체계는 누락된 권한 또는 빈 호스트를 유효하지 않은 것으로 간주합니다.

이 사양은 특정 등록 이름 조회 기술을 요구하지 않으므로 상호 운용성에 필요한 것 이상으로 regname 구문을 제한하지 않습니다. 대신 등록된 이름 구문 준수 문제를 URI 확인을 수행하는 각 응용 프로그램의 운영 체제에 위임하고 해당 운영 체제는 호스트 식별을 위해 무엇을 허용할지 결정합니다. URI 확인 구현에서는 등록된 이름을 조회하기 위해 DNS, 호스트 테이블, 전화번호부, NetInfo, WINS 또는 기타 시스템을 사용할 수 있습니다. 그러나 전역 범위를 가지려는 URI에는 DNS 정규화된 도메인 이름과 같은 전역 범위 명명 시스템이 필요합니다. URI 생산자는 DNS 사용이 즉시 명백하지 않은 경우에도 DNS 구문을 준수하는 이름을 사용해야 하며 이러한 이름의 길이를 255자 이하로 제한해야 합니다.

reg-name 구문은 기본 이름 확인 기술과 관계없이 균일한 방식으로 비ASCII 등록 이름을 나타내기 위해 백분율로 인코딩된 옥텟을 허용합니다. ASCII가 아닌 문자는 먼저 UTF-8 \[STD63\]에 따라 인코딩되어야 하며, 그런 다음 해당 UTF-8 시퀀스의 각 옥텟이 URI 문자로 표시되도록 백분율로 인코딩되어야 합니다. URI 생성 애플리케이션은 UTF-8 문자 시퀀스를 나타내는 데 사용되지 않는 한 호스트에서 백분율 인코딩을 사용해서는 안 됩니다. 비ASCII 등록 이름이 DNS를 통해 확인하기 위한 국제화된 도메인 이름을 나타내는 경우 이름을 조회하기 전에 이름을 IDNA 인코딩 \[RFC3490\]으로 변환해야 합니다. URI 생산자는 레거시 URI 확인자와의 상호 운용성을 최대화하려는 경우 백분율 인코딩이 아닌 IDNA 인코딩으로 등록된 이름을 제공해야 합니다.

---
#### **3.2.3.  Port**

권한의 포트 하위 구성요소는 호스트 뒤의 선택적 포트 번호\(10진수\)로 지정되며 단일 콜론\(":"\) 문자로 구분됩니다.

```text
      port        = *DIGIT
```

구성표는 기본 포트를 정의할 수 있습니다. 예를 들어, "http" 체계는 예약된 TCP 포트 번호에 해당하는 기본 포트 "80"을 정의합니다. 포트 번호로 지정되는 포트 유형\(예: TCP, UDP, SCTP\)은 URI 체계에 의해 정의됩니다. URI 생성자와 노멀라이저는 포트가 비어 있거나 해당 값이 체계의 기본값과 동일한 경우 포트 구성 요소와 ":" 구분 기호를 생략해야 합니다.

---
### **3.3.  Path**

경로 구성 요소에는 일반적으로 계층적 형식으로 구성된 데이터가 포함되어 있으며 비계층적 쿼리 구성 요소\(섹션 3.4\)의 데이터와 함께 URI 체계 및 명명 권한\(있는 경우\) 범위 내에서 리소스를 식별하는 데 사용됩니다. 경로는 첫 번째 물음표\("?"\)나 숫자 기호\("#"\) 문자 또는 URI의 끝으로 종료됩니다.

URI에 권한 구성 요소가 포함된 경우 경로 구성 요소는 비어 있거나 슬래시\("/"\) 문자로 시작되어야 합니다. URI에 권한 구성 요소가 포함되어 있지 않으면 경로는 두 개의 슬래시 문자\("//"\)로 시작할 수 없습니다. 또한 URI 참조\(섹션 4.1\)는 상대 경로 참조일 수 있으며, 이 경우 첫 번째 경로 세그먼트에는 콜론\(":"\) 문자가 포함될 수 없습니다. ABNF에는 이러한 경우를 명확하게 하기 위해 5가지 별도의 규칙이 필요하며, 그 중 하나만 주어진 URI 참조 내의 경로 하위 문자열과 일치합니다. 우리는 파서가 이러한 규칙 중 하나와 일치하는 URI 하위 문자열을 설명하기 위해 "경로 구성 요소"라는 일반적인 용어를 사용합니다.

```text
      path          = path-abempty    ; begins with "/" or is empty
                    / path-absolute   ; begins with "/" but not "//"
                    / path-noscheme   ; begins with a non-colon segment
                    / path-rootless   ; begins with a segment
                    / path-empty      ; zero characters

      path-abempty  = *( "/" segment )
      path-absolute = "/" [ segment-nz *( "/" segment ) ]
      path-noscheme = segment-nz-nc *( "/" segment )
      path-rootless = segment-nz *( "/" segment )
      path-empty    = 0<pchar>

      segment       = *pchar
      segment-nz    = 1*pchar
      segment-nz-nc = 1*( unreserved / pct-encoded / sub-delims / "@" )
                    ; non-zero-length segment without any colon ":"

      pchar         = unreserved / pct-encoded / sub-delims / ":" / "@"
```

경로는 슬래시\("/"\) 문자로 구분된 일련의 경로 세그먼트로 구성됩니다. 경로는 항상 URI에 대해 정의되지만 정의된 경로는 비어 있을 수 있습니다\(길이가 0임\). 계층 구조를 나타내기 위해 슬래시 문자를 사용하는 것은 URI가 상대 참조의 컨텍스트로 사용되는 경우에만 필요합니다. 예를 들어, URI <mailto:fred@example.com\>에는 "fred@example.com" 경로가 있는 반면, URI <foo://info.example.com?fred\>에는 빈 경로가 있습니다.

경로 세그먼트 "." 및 ".."\(점 세그먼트라고도 함\)은 경로 이름 계층 내에서 상대 참조를 위해 정의됩니다. 이름의 계층 구조 내에서 상대 위치를 나타내기 위해 상대 경로 참조\(섹션 4.2\)의 시작 부분에 사용하기 위한 것입니다. 이는 현재 디렉터리와 상위 디렉터리를 각각 나타내는 일부 운영 체제의 파일 디렉터리 구조 내에서의 역할과 유사합니다. 그러나 파일 시스템과 달리 이러한 점 세그먼트는 URI 경로 계층 내에서만 해석되며 확인 프로세스의 일부로 제거됩니다\(섹션 5.2\).

계층적 경로의 점 세그먼트를 제외하고 경로 세그먼트는 일반 구문에 의해 불투명한 것으로 간주됩니다. URI 생성 응용 프로그램은 스키마별 또는 역참조 처리기별 하위 구성 요소를 구분하기 위해 세그먼트에 허용되는 예약 문자를 사용하는 경우가 많습니다. 예를 들어 세미콜론\(";"\) 및 등호\("="\) 예약 문자는 해당 세그먼트에 적용할 수 있는 매개변수와 매개변수 값을 구분하는 데 자주 사용됩니다. 쉼표\(","\) 예약 문자는 비슷한 목적으로 자주 사용됩니다. 예를 들어, 한 URI 생성자는 "name;v=1.1"과 같은 세그먼트를 사용하여 "name" 버전 1.1에 대한 참조를 나타낼 수 있는 반면, 다른 생성자는 "name,1.1"과 같은 세그먼트를 사용하여 동일함을 나타낼 수 있습니다. 매개변수 유형은 체계별 의미 체계에 따라 정의될 수 있지만 대부분의 경우 매개변수 구문은 URI의 역참조 알고리즘 구현에 따라 다릅니다.

---
### **3.4.  Query**

쿼리 구성 요소에는 경로 구성 요소\(섹션 3.3\)의 데이터와 함께 URI 체계 및 명명 권한\(있는 경우\) 범위 내에서 리소스를 식별하는 데 사용되는 비계층적 데이터가 포함되어 있습니다. 쿼리 구성 요소는 첫 번째 물음표\("?"\) 문자로 표시되고 숫자 기호\("#"\) 문자 또는 URI 끝으로 종료됩니다.

```text
      query       = *( pchar / "/" / "?" )
```

슬래시\("/"\) 및 물음표\("?"\) 문자는 쿼리 구성 요소 내의 데이터를 나타낼 수 있습니다. 일부 오래되고 잘못된 구현은 상대 참조의 기본 URI\(섹션 5.1\)로 사용될 때 그러한 데이터를 올바르게 처리하지 못할 수 있다는 점에 유의하십시오. 계층적 구분 기호를 찾을 때 쿼리 데이터와 경로 데이터를 구별하지 못하기 때문입니다. 그러나 쿼리 구성 요소는 "key=value" 쌍의 형태로 식별 정보를 전달하는 데 자주 사용되며 자주 사용되는 값 중 하나는 다른 URI에 대한 참조이므로 해당 문자를 퍼센트 인코딩하지 않는 것이 유용성 측면에서 더 나을 때도 있습니다.

---
### **3.5.  Fragment**

URI의 조각 식별자 구성 요소를 사용하면 기본 리소스 및 추가 식별 정보를 참조하여 보조 리소스를 간접적으로 식별할 수 있습니다. 식별된 2차 리소스는 1차 리소스의 일부 또는 하위 집합, 1차 리소스의 표현에 대한 일부 보기, 또는 이러한 표현에 의해 정의되거나 기술된 다른 일부 리소스일 수 있습니다. 조각 식별자 구성 요소는 숫자 기호\("#"\) 문자의 존재로 표시되고 URI의 끝으로 종료됩니다.

```text
      fragment    = *( pchar / "/" / "?" )
```

조각 식별자의 의미는 기본 리소스에 대한 검색 작업으로 인해 발생할 수 있는 표현 집합에 의해 정의됩니다. 따라서 조각의 형식과 해상도는 잠재적으로 검색된 표현의 미디어 유형 \[RFC2046\]에 따라 달라집니다. 비록 그러한 검색이 URI가 역참조되는 경우에만 수행되더라도 말입니다. 그러한 표현이 존재하지 않으면 조각의 의미 체계는 알 수 없는 것으로 간주되어 효과적으로 제한되지 않습니다. 조각 식별자 의미 체계는 URI 체계와 독립적이므로 체계 사양에 따라 재정의될 수 없습니다.

개별 미디어 유형은 해당 미디어 유형에 의해 보조 리소스로 식별 가능한 다양한 유형의 하위 집합, 뷰 또는 외부 참조를 지정하기 위해 조각 식별자 구문 내에서 자체 제한 사항이나 구조를 정의할 수 있습니다. 검색 요청의 속성\(즉, 콘텐츠 협상\)을 기반으로 표현이 선택되는 리소스의 경우처럼 기본 리소스에 여러 표현이 있는 경우 조각으로 식별되는 모든 내용은 모든 표현에서 일관되어야 합니다. 각 표현은 표현 방법에 관계없이 동일한 보조 리소스에 해당하도록 조각을 정의하거나 조각을 정의되지 않은 상태\(즉, 찾을 수 없음\)로 두어야 합니다.

다른 URI와 마찬가지로 조각 식별자 구성 요소를 사용한다고 해서 검색 작업이 수행된다는 의미는 아닙니다. 조각 식별자가 있는 URI는 기본 리소스에 액세스할 수 있거나 액세스할 것이라는 암시 없이 보조 리소스를 참조하는 데 사용될 수 있습니다.

조각 식별자는 클라이언트 측 간접 참조의 기본 형태로서 정보 검색 시스템에서 특별한 역할을 하며, 이를 통해 작성자는 리소스 소유자가 간접적으로만 제공하는 기존 리소스의 측면을 구체적으로 식별할 수 있습니다. 따라서 조각 식별자는 URI의 체계별 처리에 사용되지 않습니다. 대신, 조각 식별자는 역참조 전에 URI의 나머지 부분과 분리되므로 조각 자체 내의 식별 정보는 URI 체계에 관계없이 사용자 에이전트에 의해서만 역참조됩니다. 이러한 별도의 처리는 특히 시간이 지남에 따라 자원이 이동함에 따라 정확한 참고 자료의 방향 전환을 위해 정보 손실로 인식되는 경우가 많지만, 이는 또한 정보 제공자가 참고 자료 작성자가 자원 내의 정보를 선택적으로 참조할 권리를 거부하는 것을 방지하는 역할도 합니다. 또한 간접 참조는 URI를 사용하는 시스템에 추가적인 유연성과 확장성을 제공합니다. 새로운 미디어 유형은 새로운 식별 체계보다 정의하고 배포하기가 더 쉽기 때문입니다.

슬래시\("/"\) 및 물음표\("?"\) 문자는 조각 식별자 내의 데이터를 나타내는 데 허용됩니다. 일부 오래되고 잘못된 구현에서는 이 데이터가 상대 참조의 기본 URI로 사용될 때 이 데이터를 올바르게 처리하지 못할 수 있다는 점에 유의하세요\(섹션 5.1\).

---
## **4.  Usage**

애플리케이션이 URI를 참조할 때 항상 "URI" 구문 규칙에 정의된 전체 참조 형식을 사용하지는 않습니다. 공간을 절약하고 계층적 지역성을 활용하기 위해 많은 인터넷 프로토콜 요소와 미디어 유형 형식에서는 URI의 약어를 허용하는 반면 다른 형식에서는 구문을 특정 형태의 URI로 제한합니다. 우리는 이 사양에서 참조 구문의 가장 일반적인 형태를 정의합니다. 왜냐하면 참조 구문은 일관되게 해석되기 위해 균일한 구문 분석 알고리즘이 필요한 일반 구문의 디자인에 영향을 미치고 이에 의존하기 때문입니다.

---
### **4.1.  URI Reference**

URI 참조는 리소스 식별자의 가장 일반적인 사용법을 나타내는 데 사용됩니다.

```text
      URI-reference = URI / relative-ref
```

URI 참조는 URI이거나 상대 참조입니다. URI 참조의 접두사가 콜론 구분 기호 뒤에 오는 체계의 구문과 일치하지 않으면 URI 참조는 상대 참조입니다.

URI 참조는 일반적으로 어떤 구성 요소가 존재하는지, 참조가 상대적인지 여부를 결정하기 위해 먼저 5개의 URI 구성 요소로 구문 분석됩니다. 그런 다음 각 구성 요소는 해당 하위 부분과 유효성 검사를 위해 구문 분석됩니다. "first-match-wins" 명확성 규칙과 함께 URI 참조의 ABNF는 일반 구문에 대한 유효성 검사 파서를 정의하는 데 충분합니다. 정규식에 익숙한 독자는 주어진 문자열을 가져와 URI 구성 요소를 추출하는 비검증 URI 참조 구문 분석기의 예를 부록 B에서 확인해야 합니다.

---
### **4.2.  Relative Reference**

상대 참조는 계층적 구문\(1.2.3 단원\)을 활용하여 다른 계층적 URI의 이름 공간에 상대적인 URI 참조를 표현합니다.

```text
      relative-ref  = relative-part [ "?" query ] [ "#" fragment ]

      relative-part = "//" authority path-abempty
                    / path-absolute
                    / path-noscheme
                    / path-empty
```

상대 참조가 참조하는 URI\(대상 URI라고도 함\)는 섹션 5의 참조 확인 알고리즘을 적용하여 얻습니다.

두 개의 슬래시 문자로 시작하는 상대 참조를 네트워크 경로 참조라고 합니다. 그러한 참조는 거의 사용되지 않습니다. 단일 슬래시 문자로 시작하는 상대 참조를 절대 경로 참조라고 합니다. 슬래시 문자로 시작하지 않는 상대 참조를 상대 경로 참조라고 합니다.

콜론 문자\(예: "this:that"\)가 포함된 경로 세그먼트는 체계 이름으로 오해될 수 있으므로 상대 경로 참조의 첫 번째 세그먼트로 사용할 수 없습니다. 상대 경로 참조를 만들려면 이러한 세그먼트 앞에 점 세그먼트\(예: "./this:that"\)가 와야 합니다.

---
### **4.3.  Absolute URI**

일부 프로토콜 요소는 조각 식별자 없이 URI의 절대 형식만 허용합니다. 예를 들어 나중에 상대 참조에서 사용하기 위해 기본 URI를 정의하면 조각을 허용하지 않는 절대 URI 구문 규칙이 필요합니다.

```text
      absolute-URI  = scheme ":" hier-part [ "?" query ]
```

URI 체계 사양은 해당 체계별 구문과 일치하는 모든 문자열이 <absolute-URI\> 문법과도 일치하도록 자체 구문을 정의해야 합니다. 체계 사양은 해당 체계를 통해 식별할 수 있는 리소스에 대한 적용 가능성에 관계없이 조각 식별자 구문이나 사용법을 정의하지 않습니다. 조각 식별은 체계 정의와 직교하기 때문입니다. 그러나 체계 사양에는 이러한 사용이 적절할 때 조각 식별자와 함께 체계의 URI 사용을 보여주는 예를 포함하여 광범위한 예를 포함하는 것이 좋습니다.

---
### **4.4.  Same-Document Reference**

URI 참조가 조각 구성 요소\(있는 경우\)를 제외하고 기본 URI\(섹션 5.1\)와 동일한 URI를 참조하는 경우 해당 참조를 "동일 문서" 참조라고 합니다. 동일 문서 참조의 가장 빈번한 예는 비어 있거나 숫자 기호\("#"\) 구분 기호와 조각 식별자만 포함하는 상대 참조입니다.

검색 작업을 위해 동일한 문서 참조가 역참조되면 해당 참조의 대상은 참조와 동일한 엔터티\(표현, 문서 또는 메시지\) 내에 있도록 정의됩니다. 따라서 역참조로 인해 새로운 검색 작업이 발생해서는 안 됩니다.

섹션 6.2.2 및 6.2.3에 설명된 대로 비교하기 전에 기본 및 대상 URI의 정규화가 허용되지만 실제로는 거의 수행되지 않습니다. 정규화는 동일한 문서 참조 세트를 늘릴 수 있으며 이는 일부 캐싱 애플리케이션에 도움이 될 수 있습니다. 따라서 참조 작성자는 약간 다르지만 동일하지만 참조 URI가 특정 응용 프로그램에서 동일한 문서 참조로 해석되거나 해석되지 않을 것이라고 가정해서는 안 됩니다.

---
### **4.5.  Suffix Reference**

URI 구문은 URI 체계를 통한 리소스 및 확장성에 대한 명확한 참조를 위해 설계되었습니다. 그러나 URI 식별 및 사용이 보편화되면서 전통적인 미디어\(텔레비전, 라디오, 신문, 광고판 등\)에서는 URI라는 접미사를 점점 더 많이 사용하고 있습니다.

참조로서의 URI는 다음과 같이 URI의 권한 및 경로 부분으로만 구성됩니다.

```text
      www.w3.org/Addressing/
```

또는 단순히 자체적으로 DNS에 등록된 이름입니다. 이러한 참조는 주로 기계가 아닌 사람의 해석을 위한 것이며, 상황 기반 경험적 방법이 URI를 완성하는 데 충분하다는 가정 하에 있습니다\(예: "www"로 시작하는 대부분의 등록된 이름에는 "http:/"라는 URI 접두사가 있을 가능성이 높습니다. /"\). URI 접미사를 명확하게 하기 위한 표준 경험적 방법 세트는 없지만 많은 클라이언트 구현에서는 사용자가 이를 입력하고 경험적으로 해결할 수 있도록 허용합니다.

접미사 참조를 사용하는 이러한 관행은 일반적이지만 가능하면 피해야 하며 장기 참조가 예상되는 상황에서는 절대로 사용해서는 안 됩니다. 위에서 언급한 경험적 방법은 시간이 지남에 따라 변경되며, 특히 새로운 URI 체계가 대중화되면 상황에 맞지 않게 사용될 때 종종 부정확합니다. 또한 \[RFC1535\]에 설명된 것과 같은 보안 문제가 발생할 수 있습니다.

URI 접미사는 상대 경로 참조와 동일한 구문을 가지므로 상대 참조가 필요한 컨텍스트에서는 접미사 참조를 사용할 수 없습니다. 결과적으로 접미사 참조는 대화 상자 및 오프라인 광고와 같이 정의된 기본 URI가 없는 위치로 제한됩니다.

---
## **5.  Reference Resolution**

이 섹션에서는 결과가 섹션 3의 <URI\> 구문 규칙과 일치하는 문자열이 되도록 상대 참조를 허용하는 컨텍스트 내에서 URI 참조를 확인하는 프로세스를 정의합니다.

---
### **5.1.  Establishing a Base URI**

"상대적"이라는 용어는 상대 참조가 적용되는 "기본 URI"가 존재함을 의미합니다. 조각 전용 참조\(섹션 4.4\) 외에도 상대 참조는 기본 URI가 알려진 경우에만 사용할 수 있습니다. 상대적일 수 있는 URI 참조를 구문 분석하기 전에 파서가 기본 URI를 설정해야 합니다. 기본 URI는 <absolute-URI\> 구문 규칙\(섹션 4.3\)을 준수해야 합니다. 기본 URI가 URI 참조에서 얻은 경우 해당 참조는 절대 형식으로 변환되어야 하며 기본 URI로 사용되기 전에 모든 조각 구성 요소를 제거해야 합니다.

참조의 기본 URI는 아래에서 우선 순위에 따라 설명되는 네 가지 방법 중 하나로 설정될 수 있습니다. 우선순위는 레이어 측면에서 생각할 수 있으며, 여기서 가장 안쪽에 정의된 기본 URI가 가장 높은 우선순위를 갖습니다. 이는 다음과 같이 그래픽으로 시각화할 수 있습니다.

```text
         .----------------------------------------------------------.
         |  .----------------------------------------------------.  |
         |  |  .----------------------------------------------.  |  |
         |  |  |  .----------------------------------------.  |  |  |
         |  |  |  |  .----------------------------------.  |  |  |  |
         |  |  |  |  |       <relative-reference>       |  |  |  |  |
         |  |  |  |  `----------------------------------'  |  |  |  |
         |  |  |  | (5.1.1) Base URI embedded in content   |  |  |  |
         |  |  |  `----------------------------------------'  |  |  |
         |  |  | (5.1.2) Base URI of the encapsulating entity |  |  |
         |  |  |         (message, representation, or none)   |  |  |
         |  |  `----------------------------------------------'  |  |
         |  | (5.1.3) URI used to retrieve the entity            |  |
         |  `----------------------------------------------------'  |
         | (5.1.4) Default Base URI (application-dependent)         |
         `----------------------------------------------------------'
```

---
#### **5.1.1.  Base URI Embedded in Content**

특정 미디어 유형 내에서 상대 참조에 대한 기본 URI는 파서에서 쉽게 얻을 수 있도록 콘텐츠 자체에 포함될 수 있습니다. 이는 일반적인 검색 컨텍스트\(예: 이메일 또는 USENET 뉴스\) 이외의 프로토콜을 통해 다른 사람에게 전송될 수 있는 목차와 같은 설명 문서에 유용할 수 있습니다.

각 미디어 유형에 대해 기본 URI를 삽입하는 방법을 지정하는 것은 이 사양의 범위를 벗어납니다. 사용 가능한 경우 적절한 구문은 각 미디어 유형과 관련된 데이터 형식 사양에 설명되어 있습니다.

---
#### **5.1.2.  Base URI from the Encapsulating Entity**

기본 URI가 포함되지 않은 경우 기본 URI는 표현의 검색 컨텍스트에 의해 정의됩니다. 메시지나 아카이브와 같은 다른 엔터티 내에 포함된 문서의 경우 검색 컨텍스트는 해당 엔터티입니다. 따라서 표현의 기본 기본 URI는 표현이 캡슐화되는 엔터티의 기본 URI입니다.

MIME 컨테이너 유형\(예: 메시지 및 멀티파트 유형\) 내에 기본 URI를 삽입하는 메커니즘은 MHTML \[RFC2557\]에 정의되어 있습니다. MIME 메시지 헤더 구문을 사용하지 않지만 일부 형태의 태그가 지정된 메타데이터가 메시지 내에 포함될 수 있도록 허용하는 프로토콜은 기본 URI를 메시지의 일부로 정의하기 위한 자체 구문을 정의할 수 있습니다.

---
#### **5.1.3.  Base URI from the Retrieval URI**

기본 URI가 내장되어 있지 않고 표현이 다른 엔터티 내에 캡슐화되지 않은 경우, 표현을 검색하는 데 URI가 사용된 경우 해당 URI는 기본 URI로 간주됩니다. 검색이 리디렉션된 요청의 결과인 경우 사용된 마지막 URI\(즉, 표현의 실제 검색 결과를 가져온 URI\)가 기본 URI입니다.

---
#### **5.1.4.  Default Base URI**

위에 설명된 조건 중 어느 것도 적용되지 않으면 기본 URI는 애플리케이션의 컨텍스트에 의해 정의됩니다. 이 정의는 반드시 애플리케이션에 따라 달라지므로 다른 방법 중 하나를 사용하여 기본 URI를 정의하지 못하면 동일한 콘텐츠가 애플리케이션 유형에 따라 다르게 해석될 수 있습니다.

상대 참조가 포함된 표현의 발신자는 해당 참조에 대한 기본 URI가 설정될 수 있도록 보장할 책임이 있습니다. 조각 전용 참조 외에도 상대 참조는 기본 URI가 잘 정의된 상황에서만 안정적으로 사용할 수 있습니다.

---
### **5.2.  Relative Resolution**

이 섹션에서는 주어진 기본 URI에 상대적일 수 있는 URI 참조를 참조 대상의 구문 분석된 구성 요소로 변환하는 알고리즘을 설명합니다. 그런 다음 섹션 5.3에 설명된 대로 구성 요소를 재구성하여 대상 URI를 형성할 수 있습니다. 이 알고리즘은 다른 구현의 출력을 테스트하는 데 사용할 수 있는 최종 결과를 제공합니다. 결과가 이 알고리즘에서 제공하는 것과 일치하는 경우 응용 프로그램은 다른 알고리즘을 사용하여 상대 참조 확인을 구현할 수 있습니다.

---
#### **5.2.1.  Pre-parse the Base URI**

기본 URI\(Base\)는 섹션 5.1의 절차에 따라 설정되고 섹션 3에 설명된 5가지 주요 구성 요소로 구문 분석됩니다. 기본 URI에는 스키마 구성 요소만 있어야 한다는 점에 유의하세요. 다른 구성 요소는 비어 있거나 정의되지 않을 수 있습니다. 연관된 구분 기호가 URI 참조에 나타나지 않으면 구성 요소는 정의되지 않습니다. 경로 구성 요소는 비어 있을 수 있지만 정의되지 않은 경우는 없습니다.

섹션 6.2.2 및 6.2.3에 설명된 대로 기본 URI의 정규화는 선택 사항입니다. URI 참조를 정규화하려면 먼저 대상 URI로 변환해야 합니다.

---
#### **5.2.2.  Transform References**

각 URI 참조\(R\)에 대해 다음 의사 코드는 R을 대상 URI\(T\)로 변환하는 알고리즘을 설명합니다.

- -- URI 참조는 5개의 URI 구성 요소로 구문 분석됩니다. -- \(R.scheme, R.authority, R.path, R.query, R.fragment\) =parse\(R\);

- -- 엄격하지 않은 파서는 참조의 체계가 기본 URI의 체계와 동일한 경우 이를 무시할 수 있습니다. -- if \(\(엄격하지 않음\) and \(R.scheme == Base.scheme\)\) then undefine\(R.scheme\); 종료;

```text
      if defined(R.scheme) then
         T.scheme    = R.scheme;
         T.authority = R.authority;
         T.path      = remove_dot_segments(R.path);
         T.query     = R.query;
      else
         if defined(R.authority) then
            T.authority = R.authority;
            T.path      = remove_dot_segments(R.path);
            T.query     = R.query;
         else
            if (R.path == "") then
               T.path = Base.path;
               if defined(R.query) then
                  T.query = R.query;
               else
                  T.query = Base.query;
               endif;
            else
               if (R.path starts-with "/") then
                  T.path = remove_dot_segments(R.path);
               else
                  T.path = merge(Base.path, R.path);
                  T.path = remove_dot_segments(T.path);
               endif;
               T.query = R.query;
            endif;
            T.authority = Base.authority;
         endif;
         T.scheme = Base.scheme;
      endif;

      T.fragment = R.fragment;
```

---
#### **5.2.3.  Merge Paths**

위의 의사코드는 상대 경로 참조를 기본 URI의 경로와 병합하기 위한 "병합" 루틴을 나타냅니다. 이는 다음과 같이 수행됩니다.

- 기본 URI에 정의된 권한 구성 요소와 빈 경로가 있는 경우 참조 경로와 연결된 "/"로 구성된 문자열을 반환합니다. 그렇지 않으면,

- 기본 URI 경로의 마지막 세그먼트를 제외한 모든 부분에 추가된 참조 경로 구성 요소로 구성된 문자열을 반환합니다. 즉, 기본 URI 경로에서 가장 오른쪽 "/" 다음의 모든 문자를 제외하거나, 다음과 같은 경우 전체 기본 URI 경로를 제외합니다. "/" 문자를 포함하지 않습니다.\)

---
#### **5.2.4.  Remove Dot Segments**

의사코드는 또한 특수 "."를 해석하고 제거하기 위한 "remove\_dot\_segments" 루틴을 참조합니다. 및 ".."는 참조된 경로의 전체 경로 세그먼트입니다. 이는 대상 URI를 형성하기 전에 유효하지 않거나 관련 없는 점 세그먼트를 제거하기 위해 경로가 상대 경로인지 여부에 관계없이 참조에서 경로가 추출된 후에 수행됩니다. 이 제거 프로세스를 수행하는 방법에는 여러 가지가 있지만 두 개의 문자열 버퍼를 사용하는 간단한 방법을 설명합니다.

1. 입력 버퍼는 이제 추가된 경로 구성 요소로 초기화되고 출력 버퍼는 빈 문자열로 초기화됩니다.

1. 입력 버퍼가 비어 있지 않은 동안 다음과 같이 반복합니다.

```text
       A.  If the input buffer begins with a prefix of "../" or "./",
           then remove that prefix from the input buffer; otherwise,

       B.  if the input buffer begins with a prefix of "/./" or "/.",
           where "." is a complete path segment, then replace that
           prefix with "/" in the input buffer; otherwise,

       C.  if the input buffer begins with a prefix of "/../" or "/..",
           where ".." is a complete path segment, then replace that
           prefix with "/" in the input buffer and remove the last
           segment and its preceding "/" (if any) from the output
           buffer; otherwise,

       D.  if the input buffer consists only of "." or "..", then remove
           that from the input buffer; otherwise,

       E.  move the first path segment in the input buffer to the end of
           the output buffer, including the initial "/" character (if
           any) and any subsequent characters up to, but not including,
           the next "/" character or the end of the input buffer.
```

1. 마지막으로, Remove\_dot\_segments의 결과로 출력 버퍼가 반환됩니다.

도트 세그먼트는 기본 URI의 이름 계층과 관련된 식별자를 표현하기 위해 URI 참조에 사용하기 위한 것입니다. Remove\_dot\_segments 알고리즘은 추가 도트 세그먼트를 오류로 처리하거나 역참조 구현에 의해 잘못 해석되도록 두는 대신 추가 도트 세그먼트를 제거하여 해당 계층 구조를 존중합니다.

다음은 병합된 경로의 두 가지 예에 위 단계가 적용되는 방법을 보여 주며, 각 단계 후 두 버퍼의 상태를 보여줍니다.

```text
      STEP   OUTPUT BUFFER         INPUT BUFFER

       1 :                         /a/b/c/./../../g
       2E:   /a                    /b/c/./../../g
       2E:   /a/b                  /c/./../../g
       2E:   /a/b/c                /./../../g
       2B:   /a/b/c                /../../g
       2C:   /a/b                  /../g
       2C:   /a                    /g
       2E:   /a/g

      STEP   OUTPUT BUFFER         INPUT BUFFER

       1 :                         mid/content=5/../6
       2E:   mid                   /content=5/../6
       2E:   mid/content=5         /../6
       2C:   mid                   /6
       2E:   mid/6
```

일부 애플리케이션에서는 문자열 대신 두 개의 세그먼트 스택을 사용하여 Remove\_dot\_segments 알고리즘을 구현하는 것이 더 효율적이라는 것을 알 수 있습니다.

- 참고: 일부 오래된 잘못된 구현은 기본 경로와 참조 경로를 병합하기 전에 참조의 쿼리 구성 요소를 해당 경로 구성 요소에서 분리하지 못하여 쿼리 구성 요소에 "/../" 문자열이 포함된 경우 상호 운용성 오류가 발생한다는 점에 주의하세요. "/./".

---
### **5.3.  Component Recomposition**

구문 분석된 URI 구성 요소를 재구성하여 해당 URI 참조 문자열을 얻을 수 있습니다. 의사 코드를 사용하면 다음과 같습니다.

```text
      result = ""
```

- 정의된 경우\(구성표\) 결과에 구성표를 추가합니다. 결과에 ":"를 추가합니다. 종료;

- 정의된 경우\(권한\) 결과에 "//"를 추가합니다. 결과에 권한을 추가합니다. 종료;

- 결과에 경로를 추가합니다.

- 정의된 경우\(쿼리\) "?"를 추가합니다. 결과적으로; 결과에 쿼리를 추가합니다. 종료;

- 정의된 경우\(조각\) 결과에 "#"을 추가합니다. 결과에 조각을 추가합니다. 종료;

```text
      return result;
```

정의되지 않은 구성 요소\(구분 기호가 참조에 없음을 의미함\)와 비어 있는 구성 요소\(구분 기호가 존재하고 바로 뒤에 다음 구성 요소 구분 기호가 따라옴을 의미함\) 사이의 구별을 유지하는 데 주의를 기울이십시오. 참고 끝.

---
### **5.4.  Reference Resolution Examples**

잘 정의된 기본 URI가 있는 표현 내에서

```text
      http://a/b/c/d;p?q
```

상대 참조는 다음과 같이 대상 URI로 변환됩니다.

---
#### **5.4.1.  Normal Examples**

```text
      "g:h"           =  "g:h"
      "g"             =  "http://a/b/c/g"
      "./g"           =  "http://a/b/c/g"
      "g/"            =  "http://a/b/c/g/"
      "/g"            =  "http://a/g"
      "//g"           =  "http://g"
      "?y"            =  "http://a/b/c/d;p?y"
      "g?y"           =  "http://a/b/c/g?y"
      "#s"            =  "http://a/b/c/d;p?q#s"
      "g#s"           =  "http://a/b/c/g#s"
      "g?y#s"         =  "http://a/b/c/g?y#s"
      ";x"            =  "http://a/b/c/;x"
      "g;x"           =  "http://a/b/c/g;x"
      "g;x?y#s"       =  "http://a/b/c/g;x?y#s"
      ""              =  "http://a/b/c/d;p?q"
      "."             =  "http://a/b/c/"
      "./"            =  "http://a/b/c/"
      ".."            =  "http://a/b/"
      "../"           =  "http://a/b/"
      "../g"          =  "http://a/b/g"
      "../.."         =  "http://a/"
      "../../"        =  "http://a/"
      "../../g"       =  "http://a/g"
```

---
#### **5.4.2.  Abnormal Examples**

다음과 같은 비정상적인 예는 일반적인 상황에서는 발생할 가능성이 거의 없지만 모든 URI 파서는 이를 일관되게 해결할 수 있어야 합니다. 각 예제는 위와 동일한 기반을 사용합니다.

파서는 기본 URI 경로에 계층적 수준이 있는 것보다 상대 경로 참조에 ".." 세그먼트가 더 많은 경우를 처리할 때 주의해야 합니다. ".." 구문은 URI의 권한 구성 요소를 변경하는 데 사용할 수 없습니다.

```text
      "../../../g"    =  "http://a/g"
      "../../../../g" =  "http://a/g"
```

마찬가지로 파서는 도트 세그먼트 "."를 제거해야 합니다. 및 ".."는 경로의 완전한 구성 요소인 경우이지만 세그먼트의 일부인 경우에는 해당되지 않습니다.

```text
      "/./g"          =  "http://a/g"
      "/../g"         =  "http://a/g"
      "g."            =  "http://a/b/c/g."
      ".g"            =  "http://a/b/c/.g"
      "g.."           =  "http://a/b/c/g.."
      "..g"           =  "http://a/b/c/..g"
```

상대 참조가 "."의 불필요하거나 무의미한 형식을 사용하는 경우는 거의 없습니다. 및 ".."는 전체 경로 세그먼트입니다.

```text
      "./../g"        =  "http://a/b/g"
      "./g/."         =  "http://a/b/c/g/"
      "g/./h"         =  "http://a/b/c/g/h"
      "g/../h"        =  "http://a/b/c/h"
      "g;x=1/./y"     =  "http://a/b/c/g;x=1/y"
      "g;x=1/../y"    =  "http://a/b/c/y"
```

일부 응용 프로그램은 참조의 쿼리 및/또는 조각 구성 요소를 기본 경로와 병합하고 점 세그먼트를 제거하기 전에 경로 구성 요소에서 분리하지 못합니다. 이 오류는 조각의 일반적인 사용에 계층 구조\("/"\) 문자가 포함되지 않고 쿼리 구성 요소가 일반적으로 상대 참조 내에서 사용되지 않기 때문에 거의 발견되지 않습니다.

```text
      "g?y/./x"       =  "http://a/b/c/g?y/./x"
      "g?y/../x"      =  "http://a/b/c/g?y/../x"
      "g#s/./x"       =  "http://a/b/c/g#s/./x"
      "g#s/../x"      =  "http://a/b/c/g#s/../x"
```

일부 파서는 기본 URI 체계와 동일한 경우 체계 이름이 상대 참조에 존재할 수 있도록 허용합니다. 이는 부분 URI \[RFC1630\]의 이전 사양에서 허점으로 간주됩니다. 해당 사용은 피해야 하지만 이전 버전과의 호환성을 위해 허용됩니다.

```text
      "http:g"        =  "http:g"         ; for strict parsers
                      /  "http://a/b/c/g" ; for backward compatibility
```

---
## **6.  Normalization and Comparison**

URI에 대한 가장 일반적인 작업 중 하나는 단순 비교입니다. 즉, 해당 리소스에 액세스하기 위해 URI를 사용하지 않고 두 URI가 동일한지 확인하는 것입니다. 응답 캐시에 액세스할 때마다 비교가 수행되고, 브라우저는 기록을 확인하여 링크 색상을 지정하거나, XML 파서가 네임스페이스 내의 태그를 처리합니다. URI 비교 전 광범위한 정규화는 검색 공간을 정리하거나 요청 작업 및 응답 저장의 중복을 줄이기 위해 스파이더 및 인덱싱 엔진에서 자주 사용됩니다.

URI 비교는 특정 목적을 위해 수행됩니다. 다양한 목적으로 URI를 비교하는 프로토콜이나 구현은 별칭 식별자를 줄이는 데 얼마나 많은 노력을 기울여야 하는지에 관해 서로 다른 설계 상충관계를 겪는 경우가 많습니다. 이 섹션에서는 URI를 비교하는 데 사용할 수 있는 다양한 방법, URI 간의 장단점, URI를 사용할 수 있는 애플리케이션 유형에 대해 설명합니다.

---
### **6.1.  Equivalence**

URI는 리소스를 식별하기 위해 존재하기 때문에 아마도 동일한 리소스를 식별할 때 동등한 것으로 간주되어야 합니다. 그러나 이러한 동등성의 정의는 구현이 두 리소스에 대해 완전히 알고 있거나 제어하지 않는 한 두 리소스를 비교할 수 있는 방법이 없기 때문에 실제로 많이 사용되지 않습니다. 이러한 이유로 URI의 동등성 또는 차이점에 대한 결정은 문자열 비교를 기반으로 하며 아마도 URI 체계 정의에서 제공하는 추가 규칙을 참조하여 보강될 수 있습니다. 이러한 비교의 가능한 결과를 설명하기 위해 "다른" 및 "동등한"이라는 용어를 사용하지만, 응용 프로그램에 따른 동등성 버전이 많이 있습니다.

두 URI가 동일하다는 것을 판단하는 것이 가능하더라도 두 URI가 서로 다른 리소스를 식별하는지 여부를 판단하는 데는 URI 비교만으로는 충분하지 않습니다. 예를 들어, 서로 다른 두 도메인 이름의 소유자가 두 도메인 이름 모두에서 동일한 리소스를 제공하기로 결정하면 두 개의 서로 다른 URI가 생성될 수 있습니다. 따라서 비교 방법은 위양성을 엄격히 피하면서 위음성을 최소화하도록 설계되었습니다.

동등성을 테스트할 때 애플리케이션은 상대 참조를 직접 비교해서는 안 됩니다. 비교하기 전에 참조를 해당 대상 URI로 변환해야 합니다. 표현 검색과 같은 네트워크 작업을 선택\(또는 회피\)하기 위해 URI를 비교할 때 조각 구성 요소\(있는 경우\)는 비교에서 제외되어야 합니다.

---
### **6.2.  Comparison Ladder**

실제로 URI 동등성을 테스트하기 위해 다양한 방법이 사용됩니다. 이러한 방법은 필요한 처리량과 위음성 가능성이 감소되는 정도에 따라 구분되는 범위에 속합니다. 위에서 언급했듯이 거짓음성은 제거될 수 없습니다. 실제로는 확률을 줄일 수 있지만 이렇게 줄이려면 더 많은 처리가 필요하며 모든 애플리케이션에 비용 효율적이지는 않습니다.

이러한 범위의 비교 관행을 사다리로 간주하면 다음 논의는 저렴하지만 거짓 부정을 생성할 가능성이 상대적으로 높은 관행부터 시작하여 계산 비용이 더 높고 오류 위험이 낮은 관행으로 진행하여 사다리를 올라갈 것입니다. 거짓 부정.

---
#### **6.2.1.  Simple String Comparison**

문자열로 간주될 때 두 개의 URI가 동일하면 두 URI가 동일하다고 결론을 내리는 것이 안전합니다. 이러한 유형의 동등성 테스트는 계산 비용이 매우 낮으며 다양한 응용 프로그램, 특히 구문 분석 영역에서 널리 사용됩니다.

문자열의 동등성을 테스트하려면 몇 가지 기본적인 예방 조치가 필요합니다. 이 절차를 종종 "비트별" 또는 "바이트별" 비교라고 부르는데 이는 오해의 소지가 있습니다. 문자열이 같은지 테스트하는 것은 일반적으로 문자열을 구성하는 문자의 쌍 비교를 기반으로 합니다. 첫 번째 문자열부터 시작하여 두 문자열이 모두 소진되고 모든 문자가 동일한 것으로 확인될 때까지, 한 쌍의 문자가 같지 않을 때까지 또는 하나가 될 때까지 계속됩니다. 문자열 중 다른 문자열이 먼저 소진됩니다.

이 문자 비교를 위해서는 각 문자 쌍을 비교 가능한 형식으로 입력해야 합니다. 예를 들어, 하나의 URI가 EBCDIC 인코딩의 바이트 배열에 저장되고 두 번째 URI가 Java 문자열 객체\(UTF-16\)에 저장되는 경우 순진하게 적용된 비트별 비교는 오류를 생성합니다. 바이트 대 바이트 또는 비트 대 비트보다는 문자 대 문자를 기준으로 동등성을 말하는 것이 더 좋습니다. 실제로 문자별 비교는 공통 문자 인코딩으로 변환한 후 코드포인트별로 수행되어야 합니다.

거짓 부정은 URI 별칭의 생성 및 사용으로 인해 발생합니다. 비교 방법에 관계없이 이미 정규화된 형식\(즉, 아래 설명과 같이 정규화가 적용된 후 생성되는 것과 동일한 형식\)으로 URI 참조를 일관되게 제공함으로써 불필요한 별칭을 줄일 수 있습니다.

프로토콜과 데이터 형식은 사람과 구현이 자신의 최선의 이익을 위해 일관되게 URI 참조를 제공하거나 최소한 얻을 수 있는 효율성을 무효화할 만큼 일관적이라는 이론을 기반으로 일부 URI 비교를 간단한 문자열 비교로 제한하는 경우가 많습니다. 추가 정규화에서.

---
#### **6.2.2.  Syntax-Based Normalization**

구현에서는 거짓 부정 가능성을 줄이기 위해 이 사양에서 제공하는 정의를 기반으로 하는 논리를 사용할 수 있습니다. 이 처리는 문자 대 문자열 비교보다 비용이 약간 더 높습니다. 예를 들어 이 접근 방식을 사용하는 애플리케이션은 다음 두 URI가 동등하다고 합리적으로 고려할 수 있습니다.

```text
      example://a/b/c/%7Bfoo%7D
      eXAMPLE://a/./b/../b/%63/%7bfoo%7d
```

브라우저와 같은 웹 사용자 에이전트는 일반적으로 캐시된 응답이 사용 가능한지 여부를 결정할 때 이러한 유형의 URI 정규화를 적용합니다. 구문 기반 정규화에는 대소문자 정규화, 백분율 인코딩 정규화, 도트 세그먼트 제거 등의 기술이 포함됩니다.

---
##### **6.2.2.1.  Case Normalization**

모든 URI의 경우 퍼센트 인코딩 삼중항\(예: "%3a" 대 "%3A"\) 내의 16진수는 대소문자를 구분하지 않으므로 숫자 A-F에 대문자를 사용하도록 정규화해야 합니다.

URI가 일반 구문의 구성 요소를 사용하는 경우 구성 요소 구문 동등성 규칙이 항상 적용됩니다. 즉, 구성표와 호스트는 대소문자를 구분하지 않으므로 소문자로 정규화해야 합니다. 예를 들어, URI <HTTP://www.EXAMPLE.com/\>은 <http://www.example.com/\>과 동일합니다. 다른 일반 구문 구성요소는 체계에 의해 특별히 정의되지 않는 한 대소문자를 구분하는 것으로 가정됩니다\(섹션 6.2.3 참조\).

---
##### **6.2.2.2.  Percent-Encoding Normalization**

백분율 인코딩 메커니즘\(섹션 2.1\)은 동일한 URI 간의 변동이 자주 발생하는 원인입니다. 위에서 언급한 정규화 문제 외에도 일부 URI 생성자는 백분율 인코딩이 필요하지 않은 옥텟을 백분율 인코딩하여 결과적으로 인코딩되지 않은 대응 항목과 동일한 URI를 생성합니다. 이러한 URI는 섹션 2.3에 설명된 대로 예약되지 않은 문자에 해당하는 백분율로 인코딩된 옥텟을 디코딩하여 정규화되어야 합니다.

---
##### **6.2.2.3.  Path Segment Normalization**

전체 경로 세그먼트 "." 및 ".."는 상대 참조\(섹션 4.1\) 내에서만 사용하기 위한 것이며 참조 확인 프로세스\(섹션 5.2\)의 일부로 제거됩니다. 그러나 일부 배포된 구현에서는 참조가 이미 URI인 경우 참조 확인이 필요하지 않다고 잘못 가정하여 비상대 경로에서 도트 세그먼트가 발생할 때 이를 제거하지 못합니다. URI 노멀라이저는 섹션 5.2.4에 설명된 대로 Remove\_dot\_segments 알고리즘을 경로에 적용하여 도트 세그먼트를 제거해야 합니다.

---
#### **6.2.3.  Scheme-Based Normalization**

URI의 구문과 의미는 각 체계에 대한 정의 사양에 설명된 대로 체계마다 다릅니다. 구현에서는 추가 처리 비용으로 체계별 규칙을 사용하여 거짓 부정 가능성을 줄일 수 있습니다. 예를 들어, "http" 구성표는 권한 구성 요소를 사용하고, 기본 포트가 "80"이고, "/"에 해당하는 빈 경로를 정의하기 때문에 다음 네 개의 URI는 동일합니다.

```text
      http://example.com
      http://example.com/
      http://example.com:/
      http://example.com:80/
```

일반적으로 경로가 비어 있는 권한에 대한 일반 구문을 사용하는 URI는 "/" 경로로 정규화되어야 합니다. 마찬가지로, 포트가 비어 있거나 체계의 기본값인 명시적인 ":port"는 포트와 해당 ":" 구분 기호가 생략된 것과 동일하므로 체계 기반 정규화를 통해 제거해야 합니다. 예를 들어, 위의 두 번째 URI는 "http" 구성표의 일반 형식입니다.

정규화가 체계에 따라 달라지는 또 다른 경우는 빈 권한 구성 요소 또는 빈 호스트 하위 구성 요소를 처리하는 경우입니다. 많은 체계 사양의 경우 빈 권한이나 호스트는 오류로 간주됩니다. 다른 경우에는 "localhost" 또는 최종 사용자의 호스트와 동일한 것으로 간주됩니다. 체계가 권한에 대한 기본값을 정의하고 해당 기본값에 대한 URI 참조가 필요한 경우 통일성, 간결성 및 국제화를 위해 참조는 빈 권한으로 정규화되어야 합니다. 그러나 userinfo 또는 port 하위 구성 요소가 비어 있지 않으면 호스트가 기본값과 일치하더라도 명시적으로 제공되어야 합니다.

정규화는 구성표에 따라 라이센스가 부여되지 않는 한 관련 구성 요소가 비어 있을 때 구분 기호를 제거해서는 안 됩니다.

사양. 예를 들어 URI "http://example.com/?" 위의 예와 동일하다고 가정할 수 없습니다. 마찬가지로 userinfo 하위 구성 요소 내 구분 기호의 유무는 일반적으로 해석에 중요합니다. 조각 구성 요소에는 체계 기반 정규화가 적용되지 않습니다. 따라서 접미사 "#"만 다른 두 URI는 체계에 관계없이 서로 다른 것으로 간주됩니다.

일부 체계에서는 대소문자를 구분하지 않는 데이터로 구성된 추가 하위 구성요소를 정의하여 이 데이터를 일반적인 대소문자\(예: 모두 소문자\)로 변환할 수 있도록 노멀라이저에 암시적 라이센스를 제공합니다. 예를 들어 "mailto" URI 체계와 같이 인터넷 호스트 이름을 포함하도록 path의 하위 구성 요소를 정의하는 URI 체계는 해당 하위 구성 요소가 대소문자를 구분하지 않게 하여 대소문자 정규화를 적용합니다\(예: "mailto:Joe@Example. COM"은 "mailto:Joe@example.com"과 동일하지만 일반 구문에서는 경로 구성 요소가 대소문자를 구분한다고 간주합니다.

다른 체계별 정규화가 가능합니다.

---
#### **6.2.4.  Protocol-Based Normalization**

위음성 발생률을 줄이기 위한 상당한 노력은 웹 스파이더의 경우 비용 효율적인 경우가 많습니다. 따라서 그들은 URI 비교에서 훨씬 더 공격적인 기술을 구현합니다. 예를 들어, 다음과 같은 URI가 발견된 경우

```text
      http://example.com/data
```

후행 슬래시만 다른 URI로 리디렉션됩니다.

```text
      http://example.com/data/
```

그들은 미래에 이 둘을 동등한 것으로 간주할 가능성이 높습니다. 이러한 종류의 기술은 리소스에 액세스한 결과와 해당 체계의 역참조 알고리즘의 공통 규칙\(이 경우 상대 참조 문제를 피하기 위해 HTTP 원본 서버에 의한 리디렉션 사용\)에 의해 동등성이 명확하게 표시되는 경우에만 적합합니다.

---
## **7.  Security Considerations**

URI 자체는 보안 위협을 일으키지 않습니다. 그러나 URI는 네트워크 리소스에 액세스하기 위한 간단한 지침 세트를 제공하는 데 자주 사용되므로 URI 내의 데이터를 올바르게 해석하고, 해당 데이터로 인해 의도하지 않은 액세스가 발생하는 것을 방지하고, 그렇지 않은 데이터가 포함되지 않도록 주의해야 합니다. 일반 텍스트로 공개됩니다.

---
### **7.1.  Reliability and Consistency**

일단 정보를 검색하는 데 URI를 사용했다면 나중에 해당 URI를 통해 동일한 정보를 검색할 수 있다는 보장은 없습니다. 미래에 해당 URI를 통해 검색할 수 있는 정보가 과거에 검색한 정보와 눈에 띄게 유사할 것이라는 보장도 없습니다. URI 구문은 주어진 체계나 권한이 네임스페이스를 할당하거나 시간이 지남에 따라 유지하는 방법을 제한하지 않습니다. 이러한 보증은 해당 네임스페이스와 문제의 리소스를 제어하는 ​​사람에게서만 얻을 수 있습니다. 특정 URI 체계는 해당 체계에 대한 모든 명명 기관에 의미 체계가 필요한 경우 이름 지속성과 같은 추가 의미 체계를 정의할 수 있습니다.

---
### **7.2.  Malicious Construction**

표현 검색과 같이 외관상 무해하고 멱등성이 있는 작업을 수행하려는 시도가 실제로는 피해를 줄 수 있는 원격 작업을 유발하도록 URI를 구성하는 것이 가능한 경우가 있습니다. 안전하지 않은 URI는 일반적으로 문제의 네트워크 프로토콜용으로 예약된 포트 번호가 아닌 다른 포트 번호를 지정하여 구성됩니다. 클라이언트는 자신도 모르게 다른 프로토콜 서비스를 실행하는 사이트에 접속하고, URI 내의 데이터에는 이 다른 프로토콜에 따라 해석될 때 예기치 않은 작업을 유발하는 지침이 포함되어 있습니다. 이러한 남용의 빈번한 예는 포트 구성 요소가 "25"인 프로토콜 기반 체계를 사용하여 사용자 에이전트 소프트웨어를 속여 SMTP 서버를 통해 의도하지 않거나 가장한 메시지를 보내는 것입니다.

응용 프로그램은 해당 URI를 역참조하는 데 사용되는 프로토콜이 해당 잘 알려진 포트에서 예상되는 프로토콜과 호환되지 않는 한 "잘 알려진 포트" 범위\(0 - 1023\) 내에서 TCP 포트 번호를 지정하는 URI의 역참조를 방지해야 합니다. IANA는 잘 알려진 포트의 레지스트리를 유지 관리하지만 애플리케이션은 새로운 서비스 배포를 방해하지 않도록 이러한 제한을 사용자가 구성할 수 있도록 해야 합니다.

URI에 지정된 확인 또는 역참조 프로토콜의 구분 기호와 일치하는 백분율 인코딩 옥텟\(예: TELNET 프로토콜의 CR 및 LF 문자\)이 포함된 경우 해당 프로토콜을 통해 전송하기 전에 이러한 백분율 인코딩을 디코딩하면 안 됩니다. 프로토콜을 위반할 수 있는 퍼센트 인코딩 전송은 디코딩된 옥텟이 추가 작업이나 매개변수로 해석되도록 허용하여 예상치 못한 해로울 수 있는 원격 작업을 트리거하는 것보다 덜 해롭습니다.

---
### **7.3.  Back-End Transcoding**

URI가 역참조되면 그 안에 있는 데이터는 종종 사용자 에이전트와 하나 이상의 서버에 의해 구문 분석됩니다. 예를 들어 HTTP에서 일반적인 사용자 에이전트는 URI를 다섯 가지 주요 구성 요소로 구문 분석하고 기관의 서버에 액세스한 다음 기관, 경로 및 쿼리 구성 요소 내의 데이터를 보냅니다. 일반적인 서버는 해당 정보를 가져와 경로를 세그먼트로 구문 분석하고 쿼리를 키/값 쌍으로 구문 분석한 다음 구현별 핸들러를 호출하여 요청에 응답합니다. 결과적으로 URI를 전체적으로 또는 별도의 구성 요소로 분할하여 처리하는 서버 구현에 대한 일반적인 보안 문제는 해당 URI 내의 문자 및 백분율 인코딩으로 표시되는 옥텟 데이터를 올바르게 해석하는 것입니다.

백분율로 인코딩된 옥텟은 역참조 프로세스 중 특정 시점에서 디코딩되어야 합니다. 애플리케이션은 옥텟을 디코딩하기 전에 URI를 해당 구성 요소와 하위 구성 요소로 분할해야 합니다. 그렇지 않으면 디코딩된 옥텟이 구분 기호로 오해될 수 있습니다. 옥텟을 디코딩한 후에는 URI 내의 데이터에 대한 보안 검사를 적용해야 합니다. 그러나 "%00" 퍼센트 인코딩\(NUL\)은 특별한 처리가 필요할 수 있으며 애플리케이션이 구성 요소 내에서 원시 데이터를 수신할 것으로 예상하지 않는 경우 거부되어야 합니다.

URI 경로 해석 프로세스에 백엔드 파일 시스템 또는 관련 시스템 기능의 사용이 포함되는 경우 특별한 주의를 기울여야 합니다. 파일 시스템은 일반적으로 "/", "\", ":", "\[" 및 "\]" 문자와 같은 특수 문자와 ".", ".."와 같은 특수 장치 이름에 작동 의미를 할당합니다. , "...", "aux", "lpt" 등. 어떤 경우에는 그러한 이름이 있는지 테스트하는 것만으로도 운영 체제가 일시 중지되거나 관련 없는 시스템 호출을 호출하여 거부와 관련된 심각한 보안 문제가 발생할 수 있습니다. 서비스 중단 및 의도하지 않은 데이터 전송. 이 사양에서는 이러한 중요한 문자와 장치 이름을 모두 나열하는 것이 불가능합니다. 구현자는 애플리케이션에 연결할 수 있는 저장 장치 유형에 대해 예약된 이름과 문자를 조사하고 이에 따라 URI 구성 요소에서 얻은 데이터의 사용을 제한해야 합니다.

---
### **7.4.  Rare IP Address Formats**

IPv4address의 URI 구문은 일반적인 점으로 구분된 십진수 형식의 IPv4 주소 리터럴만 허용하지만 URI를 처리하는 많은 구현에서는 gethostbyname\(\) 및 inet\_aton\(\)과 같은 플랫폼 종속 시스템 루틴을 사용하여 문자열 리터럴을 실제 IP 주소. 불행하게도 이러한 시스템 루틴은 섹션 3.2.2에 설명된 것보다 훨씬 더 큰 형식 집합을 허용하고 처리하는 경우가 많습니다.

예를 들어, 많은 구현에서는 세 숫자의 점 형식을 허용합니다. 여기서 마지막 부분은 16비트 수량으로 해석되고 네트워크 주소\(예: 클래스 B 네트워크\)의 가장 오른쪽 2바이트에 배치됩니다. 마찬가지로 두 숫자의 점 형태는 마지막 부분이 24비트 수량으로 해석되어 네트워크 주소\(클래스 A\)의 가장 오른쪽 3바이트에 배치되고 단일 숫자\(점 없음\)는 다음과 같이 해석된다는 의미입니다. 32비트 수량이며 네트워크 주소에 직접 저장됩니다. 혼란을 더욱 가중시키는 것은 일부 구현에서는 C 언어에 지정된 대로 점으로 구분된 각 부분을 10진수, 8진수 또는 16진수로 해석하도록 허용합니다\(즉, 앞에 오는 0x 또는 0X는 16진수를 의미하고 앞에 오는 0은 8진수를 의미하며 그렇지 않은 경우 숫자는 10진수로 해석됩니다.\)

이러한 추가 IP 주소 형식은 플랫폼 구현 간의 차이로 인해 URI 구문에서 허용되지 않습니다. 그러나 애플리케이션이 문자열 리터럴 형식의 IP 주소를 기반으로 리소스에 대한 액세스를 필터링하려고 시도하는 경우 보안 문제가 될 수 있습니다. 이 필터링을 수행하는 경우 리터럴은 숫자 형식으로 변환되어야 하며 문자열 형식의 접두사 또는 접미사가 아닌 숫자 값을 기준으로 필터링되어야 합니다.

---
### **7.5.  Sensitive Information**

URI 생산자는 비밀로 유지하려는 사용자 이름이나 비밀번호가 포함된 URI를 제공해서는 안 됩니다. URI는 브라우저에 자주 표시되고 일반 텍스트 책갈피에 저장되며 사용자 에이전트 기록 및 중개 애플리케이션\(프록시\)에 의해 기록됩니다. userinfo 구성요소 내에 표시되는 비밀번호는 더 이상 사용되지 않으며 'password' 매개변수가 공개되도록 의도된 드문 경우를 제외하고는 오류로 간주되거나 단순히 무시되어야 합니다.

---
### **7.6.  Semantic Attacks**

userinfo 하위 구성 요소는 거의 사용되지 않고 권한 구성 요소의 호스트 앞에 나타나기 때문에 하나의 \(신뢰할 수 있는\) 명명 권한을 식별하는 것처럼 보이면서 실제로 이름 뒤에 숨겨진 다른 권한을 식별함으로써 인간 사용자를 오도하려는 의도의 URI를 구성하는 데 사용할 수 있습니다. 소음. 예를 들어

```text
      ftp://cnn.example.com&story=breaking_news@10.0.0.1/top_story.htm
```

인간 사용자는 호스트가 'cnn.example.com'이지만 실제로는 '10.0.0.1'이라고 가정하게 될 수 있습니다. 오해의 소지가 있는 userinfo 하위 구성 요소는 위의 예보다 훨씬 길 수 있습니다.

위와 같은 오해의 소지가 있는 URI는 소프트웨어 자체에 대한 공격이 아니라 URI의 의미에 대한 사용자의 선입견에 대한 공격입니다. 사용자 에이전트는 만병통치약은 없지만 사용자 정보가 있는 경우 다른 색상이나 톤을 사용하여 렌더링하는 등 URI의 다양한 구성 요소를 구별하여 이러한 공격의 영향을 줄일 수 있습니다. URI 기반 의미론적 공격에 대한 자세한 내용은 \[Siedzik\]에서 확인할 수 있습니다.

---
## **8.  IANA Considerations**

3.1절의 <scheme\>에 정의된 URI 스키마 이름은 \[BCP35\]에 정의된 절차에 따라 IANA에서 관리하는 등록된 네임스페이스를 형성합니다. 이 문서에는 IANA 조치가 필요하지 않습니다.

---
## **9.  Acknowledgements**

이 사양은 RFC 2396 \[RFC2396\], RFC 1808 \[RFC1808\] 및 RFC 1738 \[RFC1738\]에서 파생되었습니다. 해당 문서의 승인 내용은 여전히 ​​적용됩니다. 또한 \[RFC2732\]에서 Robert M. Hinden, Brian E. Carpenter 및 Larry Masinter가 정의한 대로 호스트 구문의 IPv6 리터럴에 대한 업데이트\(수정 사항 포함\)를 통합합니다. 또한 Gisle Aas, Reese Anschultz, Daniel Barclay, Tim Bray, Mike Brown, Rob Cameron, Jeremy Carroll, Dan Connolly, Adam M. Costello, John Cowan, Jason Diamond, Martin Duerst, Stefan Eissing, Clive D.W. 페더, 알 길먼, 토니 해먼드, 엘리오트 해롤드, 팻 헤이즈, 헨리 홀츠먼, 이안 B. 제이콥스, 마이클 케이, 존 C. 클렌신, 그레이엄 클라인, 댄 콘, 브루스 릴리, 앤드루 메인, 데이브 맥알핀, 아이라 맥도날드, 마이클 밀링 , Ray Merkert, Stephen Pollei, Julian Reschke, Tomas Rokicki, Miles Sabin, Kai Schaetzl, Mark Thomson, Ronald Tschalaer, Norm Walsh, Marc Warne, Stuart Williams 및 Henry Zongaro에게 감사의 말씀을 드립니다.

---
## **10.  References**
---
### **10.1.  Normative References**

```text
   [ASCII]    American National Standards Institute, "Coded Character
              Set -- 7-bit American Standard Code for Information
              Interchange", ANSI X3.4, 1986.

   [RFC2234]  Crocker, D. and P. Overell, "Augmented BNF for Syntax
              Specifications: ABNF", RFC 2234, November 1997.

   [STD63]    Yergeau, F., "UTF-8, a transformation format of
              ISO 10646", STD 63, RFC 3629, November 2003.

   [UCS]      International Organization for Standardization,
              "Information Technology - Universal Multiple-Octet Coded
              Character Set (UCS)", ISO/IEC 10646:2003, December 2003.
```

---
### **10.2.  Informative References**

```text
   [BCP19]    Freed, N. and J. Postel, "IANA Charset Registration
              Procedures", BCP 19, RFC 2978, October 2000.

   [BCP35]    Petke, R. and I. King, "Registration Procedures for URL
              Scheme Names", BCP 35, RFC 2717, November 1999.

   [RFC0952]  Harrenstien, K., Stahl, M., and E. Feinler, "DoD Internet
              host table specification", RFC 952, October 1985.

   [RFC1034]  Mockapetris, P., "Domain names - concepts and facilities",
              STD 13, RFC 1034, November 1987.

   [RFC1123]  Braden, R., "Requirements for Internet Hosts - Application
              and Support", STD 3, RFC 1123, October 1989.

   [RFC1535]  Gavron, E., "A Security Problem and Proposed Correction
              With Widely Deployed DNS Software", RFC 1535,
              October 1993.

   [RFC1630]  Berners-Lee, T., "Universal Resource Identifiers in WWW: A
              Unifying Syntax for the Expression of Names and Addresses
              of Objects on the Network as used in the World-Wide Web",
              RFC 1630, June 1994.

   [RFC1736]  Kunze, J., "Functional Recommendations for Internet
              Resource Locators", RFC 1736, February 1995.

   [RFC1737]  Sollins, K. and L. Masinter, "Functional Requirements for
              Uniform Resource Names", RFC 1737, December 1994.

   [RFC1738]  Berners-Lee, T., Masinter, L., and M. McCahill, "Uniform
              Resource Locators (URL)", RFC 1738, December 1994.

   [RFC1808]  Fielding, R., "Relative Uniform Resource Locators",
              RFC 1808, June 1995.

   [RFC2046]  Freed, N. and N. Borenstein, "Multipurpose Internet Mail
              Extensions (MIME) Part Two: Media Types", RFC 2046,
              November 1996.

   [RFC2141]  Moats, R., "URN Syntax", RFC 2141, May 1997.

   [RFC2396]  Berners-Lee, T., Fielding, R., and L. Masinter, "Uniform
              Resource Identifiers (URI): Generic Syntax", RFC 2396,
              August 1998.

   [RFC2518]  Goland, Y., Whitehead, E., Faizi, A., Carter, S., and D.
              Jensen, "HTTP Extensions for Distributed Authoring --
              WEBDAV", RFC 2518, February 1999.

   [RFC2557]  Palme, J., Hopmann, A., and N. Shelness, "MIME
              Encapsulation of Aggregate Documents, such as HTML
              (MHTML)", RFC 2557, March 1999.

   [RFC2718]  Masinter, L., Alvestrand, H., Zigmond, D., and R. Petke,
              "Guidelines for new URL Schemes", RFC 2718, November 1999.

   [RFC2732]  Hinden, R., Carpenter, B., and L. Masinter, "Format for
              Literal IPv6 Addresses in URL's", RFC 2732, December 1999.

   [RFC3305]  Mealling, M. and R. Denenberg, "Report from the Joint
              W3C/IETF URI Planning Interest Group: Uniform Resource
              Identifiers (URIs), URLs, and Uniform Resource Names
              (URNs): Clarifications and Recommendations", RFC 3305,
              August 2002.

   [RFC3490]  Faltstrom, P., Hoffman, P., and A. Costello,
              "Internationalizing Domain Names in Applications (IDNA)",
              RFC 3490, March 2003.

   [RFC3513]  Hinden, R. and S. Deering, "Internet Protocol Version 6
              (IPv6) Addressing Architecture", RFC 3513, April 2003.

   [Siedzik]  Siedzik, R., "Semantic Attacks: What's in a URL?",
              April 2001, <http://www.giac.org/practical/gsec/
              Richard_Siedzik_GSEC.pdf>.
```

---
# **Appendix A.  Collected ABNF for URI**

```text
   URI           = scheme ":" hier-part [ "?" query ] [ "#" fragment ]

   hier-part     = "//" authority path-abempty
                 / path-absolute
                 / path-rootless
                 / path-empty

   URI-reference = URI / relative-ref

   absolute-URI  = scheme ":" hier-part [ "?" query ]

   relative-ref  = relative-part [ "?" query ] [ "#" fragment ]

   relative-part = "//" authority path-abempty
                 / path-absolute
                 / path-noscheme
                 / path-empty

   scheme        = ALPHA *( ALPHA / DIGIT / "+" / "-" / "." )

   authority     = [ userinfo "@" ] host [ ":" port ]
   userinfo      = *( unreserved / pct-encoded / sub-delims / ":" )
   host          = IP-literal / IPv4address / reg-name
   port          = *DIGIT

   IP-literal    = "[" ( IPv6address / IPvFuture  ) "]"

   IPvFuture     = "v" 1*HEXDIG "." 1*( unreserved / sub-delims / ":" )

   IPv6address   =                            6( h16 ":" ) ls32
                 /                       "::" 5( h16 ":" ) ls32
                 / [               h16 ] "::" 4( h16 ":" ) ls32
                 / [ *1( h16 ":" ) h16 ] "::" 3( h16 ":" ) ls32
                 / [ *2( h16 ":" ) h16 ] "::" 2( h16 ":" ) ls32
                 / [ *3( h16 ":" ) h16 ] "::"    h16 ":"   ls32
                 / [ *4( h16 ":" ) h16 ] "::"              ls32
                 / [ *5( h16 ":" ) h16 ] "::"              h16
                 / [ *6( h16 ":" ) h16 ] "::"

   h16           = 1*4HEXDIG
   ls32          = ( h16 ":" h16 ) / IPv4address
   IPv4address   = dec-octet "." dec-octet "." dec-octet "." dec-octet

   dec-octet     = DIGIT                 ; 0-9
                 / %x31-39 DIGIT         ; 10-99
                 / "1" 2DIGIT            ; 100-199
                 / "2" %x30-34 DIGIT     ; 200-249
                 / "25" %x30-35          ; 250-255

   reg-name      = *( unreserved / pct-encoded / sub-delims )

   path          = path-abempty    ; begins with "/" or is empty
                 / path-absolute   ; begins with "/" but not "//"
                 / path-noscheme   ; begins with a non-colon segment
                 / path-rootless   ; begins with a segment
                 / path-empty      ; zero characters

   path-abempty  = *( "/" segment )
   path-absolute = "/" [ segment-nz *( "/" segment ) ]
   path-noscheme = segment-nz-nc *( "/" segment )
   path-rootless = segment-nz *( "/" segment )
   path-empty    = 0<pchar>

   segment       = *pchar
   segment-nz    = 1*pchar
   segment-nz-nc = 1*( unreserved / pct-encoded / sub-delims / "@" )
                 ; non-zero-length segment without any colon ":"

   pchar         = unreserved / pct-encoded / sub-delims / ":" / "@"

   query         = *( pchar / "/" / "?" )

   fragment      = *( pchar / "/" / "?" )

   pct-encoded   = "%" HEXDIG HEXDIG

   unreserved    = ALPHA / DIGIT / "-" / "." / "_" / "~"
   reserved      = gen-delims / sub-delims
   gen-delims    = ":" / "/" / "?" / "#" / "[" / "]" / "@"
   sub-delims    = "!" / "$" / "&" / "'" / "(" / ")"
                 / "*" / "+" / "," / ";" / "="
```

---
# **Appendix B.  Parsing a URI Reference with a Regular Expression**

"첫 번째 일치 승리" 알고리즘은 POSIX 정규식에서 사용되는 "탐욕스러운" 명확성 방법과 동일하므로 URI 참조의 잠재적인 5개 구성 요소를 구문 분석하기 위해 정규식을 사용하는 것이 자연스럽고 일반적입니다.

다음 줄은 올바른 형식의 URI 참조를 해당 구성 요소로 분해하기 위한 정규식입니다.

```text
      ^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?
       12            3  4          5       6  7        8 9
```

위의 두 번째 줄에 있는 숫자는 가독성을 돕기 위한 것입니다. 이는 각 하위 표현식\(즉, 각 쌍의 괄호\)에 대한 참조 지점을 나타냅니다. 하위 표현식 <n\>과 일치하는 값을 $<n\>이라고 합니다. 예를 들어, 위의 표현식을 다음과 일치시킵니다.

```text
      http://www.ics.uci.edu/pub/ietf/uri/#Related
```

결과적으로 다음 하위 표현식이 일치합니다.

```text
      $1 = http:
      $2 = http
      $3 = //www.ics.uci.edu
      $4 = www.ics.uci.edu
      $5 = /pub/ietf/uri/
      $6 = <undefined>
      $7 = <undefined>
      $8 = #Related
      $9 = Related
```

여기서 <정의되지 않음\>은 위 예의 쿼리 구성 요소와 마찬가지로 구성 요소가 존재하지 않음을 나타냅니다. 따라서 우리는 다섯 가지 구성 요소의 가치를 다음과 같이 결정할 수 있습니다.

```text
      scheme    = $2
      authority = $4
      path      = $5
      query     = $7
      fragment  = $9
```

반대 방향으로 나아가면 섹션 5.3의 알고리즘을 사용하여 해당 구성 요소에서 URI 참조를 다시 만들 수 있습니다.

---
# **Appendix C.  Delimiting a URI in Context**

URI는 해석을 위한 명확한 컨텍스트를 제공하지 않는 형식을 통해 전송되는 경우가 많습니다. 예를 들어 URI가 일반 텍스트에 포함되는 경우가 많습니다. 예로는 이메일로 전송된 텍스트, USENET 뉴스, 인쇄된 종이 등이 있습니다. 이러한 경우에는 URI를 텍스트의 나머지 부분, 특히 URI의 일부로 오해할 수 있는 구두점에서 구분할 수 있는 것이 중요합니다.

실제로 URI는 다양한 방법으로 구분되지만 일반적으로 큰따옴표 "http://example.com/", 꺾쇠 괄호 <http://example.com/\> 또는 공백을 사용하여 구분됩니다.

```text
      http://example.com/
```

이러한 래퍼는 URI의 일부를 구성하지 않습니다.

경우에 따라 여러 줄에 걸쳐 긴 URI를 나누기 위해 추가 공백\(공백, 줄 바꿈, 탭 등\)을 추가해야 할 수도 있습니다. URI를 추출할 때 공백은 무시되어야 합니다.

하이픈\("-"\) 문자 뒤에는 공백이 들어가지 않아야 합니다. 일부 식자기와 프린터는 줄바꿈을 할 때 줄 끝에 하이픈을 \(잘못\) 삽입할 수 있기 때문에 하이픈 바로 뒤에 줄바꿈이 포함된 URI의 해석기는 줄바꿈 주위의 모든 공백을 무시해야 하며 하이픈이 나타날 수 있다는 점을 인식해야 합니다. 또는 실제로 URI의 일부가 아닐 수도 있습니다.

공백이 포함된 참조에 대한 구분 스타일로 각 URI 주위에 <\> 꺾쇠 괄호를 사용하는 것이 특히 권장됩니다.

접두사 "URL:"\(뒤에 공백이 있거나 없음\)은 URI를 다른 대괄호 지정자와 구별하는 데 도움이 되는 방법으로 이전에 권장되었지만 실제로는 일반적으로 사용되지 않으며 더 이상 권장되지 않습니다.

견고성을 위해 사용자가 입력한 URI를 허용하는 소프트웨어는 구분 기호와 포함된 공백을 모두 인식하고 제거해야 합니다.

예를 들어, 텍스트

- 예, Jim. "http://www.w3.org/Addressing/"에서 찾았습니다. 하지만 아마도 <ftp://foo.example에서 찾을 수 있을 것입니다. com/rfc/\>. <http://www.ics.uci.edu/pub/ietf/uri/historical.html#WARNING\>의 경고에 유의하십시오.

URI 참조가 포함되어 있습니다.

```text
      http://www.w3.org/Addressing/
      ftp://foo.example.com/rfc/
      http://www.ics.uci.edu/pub/ietf/uri/historical.html#WARNING
```

---
# **Appendix D.  Changes from RFC 2396**
---
### **D.1.  Additions**

URI에 대한 ABNF 규칙은 용어의 일반적인 사용법 중 하나인 선택적 조각이 있는 절대 URI에 대응하기 위해 도입되었습니다.

\[RFC2732\]에 설명된 대로 IPv6\(및 이후\) ​​리터럴이 권한 구성 요소의 호스트 부분에 대해 가능한 식별자 목록에 추가되었으며, 예약된 세트 및 버전 플래그에 "\[" 및 "\]"가 추가되었습니다. IP 리터럴의 향후 버전을 예상합니다. 대괄호는 이제 권한 구성 요소 내에서 예약된 것으로 지정되며 호스트 내에서 IP 리터럴에 대한 구분 기호로 사용할 수 없습니다. 경로, 쿼리 및 조각 구성 요소의 기술적 정의를 변경하지 않고 이러한 변경을 수행하기 위해 허용되는 문자를 직접 지정하도록 해당 규칙을 재정의했습니다.

\[RFC2732\]는 IPv6 주소에 대한 ABNF 설명이 부족한 IPv6 리터럴 주소 정의를 \[RFC3513\]에 따르므로 \[RFC3513\]의 섹션 2.2에 정의된 텍스트 표현과 일치하는 IPv6address에 대한 새로운 ABNF 규칙을 만들었습니다. 마찬가지로, 각 10진수 옥텟을 0-255 범위로 제한하기 위해 IPv4 주소의 정의가 개선되었습니다.

URI 정규화 및 비교에 관한 섹션 6은 Tim Bray의 입력과 W3C 기술 아키텍처 그룹 내의 토론을 사용하여 완전히 다시 작성되고 확장되었습니다.

---
### **D.2.  Modifications**

RFC 2396의 임시 BNF 구문은 \[RFC2234\]의 ABNF로 대체되었습니다. 이 변경으로 인해 이전에 밑줄 문자가 포함된 모든 규칙 이름을 대시로 바꿔야 했습니다. 또한 전체 문법을 더욱 이해하기 쉽게 만들기 위해 여러 구문 규칙이 제거되거나 단순화되었습니다. 더 이상 사용되지 않는 문법 규칙을 참조하는 사양은 다음 표에 따라 해당 규칙을 대체하여 이해할 수 있습니다.

```text
   +----------------+--------------------------------------------------+
   | obsolete rule  | translation                                      |
   +----------------+--------------------------------------------------+
   | absoluteURI    | absolute-URI                                     |
   | relativeURI    | relative-part [ "?" query ]                      |
   | hier_part      | ( "//" authority path-abempty /                  |
   |                | path-absolute ) [ "?" query ]                    |
   |                |                                                  |
   | opaque_part    | path-rootless [ "?" query ]                      |
   | net_path       | "//" authority path-abempty                      |
   | abs_path       | path-absolute                                    |
   | rel_path       | path-rootless                                    |
   | rel_segment    | segment-nz-nc                                    |
   | reg_name       | reg-name                                         |
   | server         | authority                                        |
   | hostport       | host [ ":" port ]                                |
   | hostname       | reg-name                                         |
   | path_segments  | path-abempty                                     |
   | param          | *<pchar excluding ";">                           |
   |                |                                                  |
   | uric           | unreserved / pct-encoded / ";" / "?" / ":"       |
   |                |  / "@" / "&" / "=" / "+" / "$" / "," / "/"       |
   |                |                                                  |
   | uric_no_slash  | unreserved / pct-encoded / ";" / "?" / ":"       |
   |                |  / "@" / "&" / "=" / "+" / "$" / ","             |
   |                |                                                  |
   | mark           | "-" / "_" / "." / "!" / "~" / "*" / "'"          |
   |                |  / "(" / ")"                                     |
   |                |                                                  |
   | escaped        | pct-encoded                                      |
   | hex            | HEXDIG                                           |
   | alphanum       | ALPHA / DIGIT                                    |
   +----------------+--------------------------------------------------+
```

체계별 구문 정의에 대해 위의 사용되지 않는 규칙을 사용하는 것은 더 이상 사용되지 않습니다.

문자에 관한 섹션 2는 예약된 문자, 언제 예약되었는지, 일반 구문에서 구분 기호로 사용되지 않는 경우에도 예약된 이유를 설명하기 위해 다시 작성되었습니다. 느낌표\("!"\), 별표\("\*"\), 작은따옴표\("'"\), 열고 닫는 괄호\("\(" 및 "\)"\)를 포함하여 일반적으로 디코딩하기에 안전하지 않은 표시 문자 는 예약된 것과 예약되지 않은 것의 구별을 명확하게 하고 체계 설계자의 가장 일반적인 질문에 대답하기 위해 예약된 세트로 이동되었습니다. 마찬가지로, 백분율로 인코딩된 문자에 대한 섹션이 다시 작성되었으며 이제 URI 노멀라이저에 백분율로 인코딩된 옥텟을 디코딩할 수 있는 라이센스가 부여됩니다.

예약되지 않은 문자에 해당합니다. 일반적으로 "이스케이프된" 및 "이스케이프되지 않은"이라는 용어는 다른 형태의 이스케이프 메커니즘과의 혼동을 줄이기 위해 각각 "퍼센트 인코딩된" 및 "디코딩된"으로 대체되었습니다.

URI 및 URI 참조에 대한 ABNF는 LALR 파서에 더 친숙해지고 복잡성을 줄이기 위해 다시 설계되었습니다. 결과적으로 uric, uric\_no\_slash, opaque\_part, net\_path, abs\_path, rel\_path, path\_segments, rel\_segment 및 mark 규칙과 함께 구문 설명의 레이아웃 형식이 제거되었습니다. "불투명" URI에 대한 모든 참조는 경로 구성 요소가 계층 구조에 어떻게 불투명할 수 있는지에 대한 더 나은 설명으로 대체되었습니다. URI의 하위 집합인지 여부에 대한 불필요한 혼란을 피하기 위해 상대 URI 규칙은 상대 참조로 대체되었습니다. 첫 번째 세그먼트에 콜론이 있는 URI 또는 ​​상대 참조로 URI 참조를 구문 분석하는 것과 관련된 모호성은 5개의 별도 경로 일치 규칙을 사용하여 제거되었습니다.

조각 식별자는 일반 구문 구성 요소 섹션과 URI 및 상대 참조 규칙 내 섹션으로 다시 이동되었지만 절대 URI에서는 제외되었습니다. 조각 구문을 다시 통합한 결과 숫자 기호\("#"\) 문자가 예약된 세트로 다시 이동되었습니다.

경로 구성 요소가 비어 있을 수 있도록 ABNF가 수정되었습니다. 이는 또한 실제로 "dav:" 네임스페이스\[RFC2518\]와 많은 WWW 브라우저 구현에서 내부적으로 사용되는 "about:" 체계에 존재하는 것처럼 절대 URI가 "scheme:" 뒤에 아무것도 구성되지 않도록 허용합니다. 5개의 별도 경로 일치 규칙을 사용하여 권한과 경로 사이의 경계에 대한 모호성을 제거했습니다.

이제 일반 구문을 사용하는 레지스트리 기반 명명 기관이 호스트 규칙 내에 정의됩니다. 이 변경으로 인해 제공된 이름이 무엇이든 단순히 로컬 이름 확인 메커니즘에 제공되는 현재 구현이 사양과 일치할 수 있습니다. 또한 여기에서 DNS 이름 형식을 다시 지정할 필요가 없습니다. 또한 호스트 구성 요소에 백분율로 인코딩된 옥텟을 포함할 수 있습니다. 이는 국제화된 도메인 이름을 URI로 제공하고 URI 처리 위의 애플리케이션 계층에서 기본 문자 인코딩으로 처리하며 IDNA 라이브러리에 다음과 같이 전달하는 데 필요합니다. UTF-8 문자 인코딩으로 등록된 이름입니다. 서버, 호스트 포트, 호스트 이름, 도메인 라벨, 최상위 라벨 및 영숫자 규칙이 제거되었습니다.

\[RFC2396\]의 상대 참조 분석 알고리즘은 명확성을 높이고 다음 문제를 해결하기 위해 이번 개정판에 대해 의사 코드로 다시 작성되었습니다.

- \[RFC2396\] 섹션 5.2, 6a단계에서 경로가 없는 기본 URI를 설명하지 못했습니다.

- 참조에 빈 경로와 정의된 쿼리 구성 요소가 포함되어 있는 경우 대상 URI가 기본 URI의 경로 구성 요소를 상속하는 \[RFC1808\]의 동작이 복원되었습니다.

- URI 참조가 동일한 문서 참조인지 여부에 대한 결정이 URI 파서에서 분리되어 배포된 URI 처리 구현의 내부 아키텍처와 일치하는 방식으로 애플리케이션 내의 URI 처리 인터페이스를 단순화했습니다. 이제 결정은 참조 자체의 형식이 아닌 절대 형식으로 참조를 변환한 후 기본 URI와의 비교를 기반으로 이루어집니다. 이 변경으로 인해 RFC 2396에 제공된 규칙보다 이 사양에서 더 많은 참조가 "동일 문서"로 간주될 수 있습니다. 특히 별칭을 줄이기 위해 정규화가 사용되는 경우 더욱 그렇습니다. 그러나 기존 동일 문서 참조의 상태는 변경되지 않습니다.

- 경로 병합 루틴을 두 개의 루틴으로 분리했습니다. 즉, 기본 URI 경로와 상대 경로 참조의 조합을 설명하기 위한 병합과 특수 "."를 제거하는 방법을 설명하기 위한 Remove\_dot\_segments입니다. 구성된 경로의 ".." 세그먼트입니다. 이제 일반적인 구현을 일치시키고 실제로 URI 정규화를 개선하기 위해 모든 URI 참조 경로에 Remove\_dot\_segments 알고리즘이 적용됩니다. 이 변경 사항은 기본 URI에 비계층 경로가 있는 비정상적인 참조 및 동일 체계 참조의 구문 분석에만 영향을 미칩니다.

---
# **Index**

A - ABNF 11 절대 27 절대 경로 26 절대 URI 27 액세스 9 권한 17, 18

```text
   B
      base URI  28

   C
      character encoding  4
      character  4
      characters  8, 11
      coded character set  4

   D
      dec-octet  20
      dereference  9
      dot-segments  23

   F
      fragment  16, 24

   G
      gen-delims  13
      generic syntax  6

   H
      h16  20
      hier-part  16
      hierarchical  10
      host  18

   I
      identifier  5
      IP-literal  19
      IPv4  20
      IPv4address  19, 20
      IPv6  19
      IPv6address  19, 20
      IPvFuture  19

   L
      locator  7
      ls32  20

   M
      merge  32

   N
      name  7
      network-path  26

   P
      path  16, 22, 26
         path-abempty  22
         path-absolute  22
         path-empty  22
         path-noscheme  22
         path-rootless  22
      path-abempty  16, 22, 26
      path-absolute  16, 22, 26
      path-empty  16, 22, 26

      path-rootless  16, 22
      pchar  23
      pct-encoded  12
      percent-encoding  12
      port  22

   Q
      query  16, 23

   R
      reg-name  21
      registered name  20
      relative  10, 28
      relative-path  26
      relative-ref  26
      remove_dot_segments  33
      representation  9
      reserved  12
      resolution  9, 28
      resource  5
      retrieval  9

   S
      same-document  27
      sameness  9
      scheme  16, 17
      segment  22, 23
         segment-nz  23
         segment-nz-nc  23
      sub-delims  13
      suffix  27

   T
      transcription  8

   U
      uniform  4
      unreserved  13
      URI grammar
         absolute-URI  27
         ALPHA  11
         authority  18
         CR  11
         dec-octet  20
         DIGIT  11
         DQUOTE  11
         fragment  24
         gen-delims  13

         h16  20
         HEXDIG  11
         hier-part  16
         host  19
         IP-literal  19
         IPv4address  20
         IPv6address  20
         IPvFuture  19
         LF  11
         ls32  20
         OCTET  11
         path  22
         path-abempty  22
         path-absolute  22
         path-empty  22
         path-noscheme  22
         path-rootless  22
         pchar  23
         pct-encoded  12
         port  22
         query  24
         reg-name  21
         relative-ref  26
         reserved  13
         scheme  17
         segment  23
         segment-nz  23
         segment-nz-nc  23
         SP  11
         sub-delims  13
         unreserved  13
         URI  16
         URI-reference  25
         userinfo  18
      URI  16
      URI-reference  25
      URL  7
      URN  7
      userinfo  18
```

---
# **Authors' Addresses**

Tim Berners-Lee 월드 와이드 웹 컨소시엄 Massachusetts Institute of Technology 77 Massachusetts Avenue Cambridge, MA 02139 USA

```text
   Phone: +1-617-253-5702
   Fax:   +1-617-258-5999
   EMail: timbl@w3.org
   URI:   http://www.w3.org/People/Berners-Lee/

   Roy T. Fielding
   Day Software
   5251 California Ave., Suite 110
   Irvine, CA  92617
   USA

   Phone: +1-949-679-2960
   Fax:   +1-949-679-2972
   EMail: fielding@gbiv.com
   URI:   http://roy.gbiv.com/

   Larry Masinter
   Adobe Systems Incorporated
   345 Park Ave
   San Jose, CA  95110
   USA

   Phone: +1-408-536-3024
   EMail: LMM@acm.org
   URI:   http://larry.masinter.net/
```

---
# **Full Copyright Statement**

저작권\(C\)인터넷학회\(2005\).

이 문서에는 BCP 78에 포함된 권리, 라이선스 및 제한 사항이 적용되며, 여기에 명시된 경우를 제외하고 작성자는 모든 권리를 보유합니다.

이 문서와 여기에 포함된 정보는 "있는 그대로" 제공되며 기여자, 그가 대표하거나 후원하는 조직\(있는 경우\), 인터넷 사회 및 인터넷 엔지니어링 태스크 포스는 모든 명시적 또는 명시적 보증을 부인합니다. 여기에 포함된 정보의 사용이 상품성이나 특정 목적에의 적합성에 대한 묵시적인 보증이나 권리를 침해하지 않는다는 보증을 포함하되 이에 국한되지 않습니다.

---
# **Intellectual Property**

IETF는 이 문서에 설명된 기술의 구현이나 사용과 관련이 있다고 주장될 수 있는 지적 재산권 또는 기타 권리의 유효성이나 범위, 그러한 권리에 따른 라이선스가 적용되거나 적용되지 않을 수 있는 범위에 대해 어떠한 입장도 취하지 않습니다. 는 가능하다; 또한 그러한 권리를 확인하기 위해 독립적인 노력을 했다는 것을 나타내지도 않습니다. IETF 문서의 권리와 관련된 IETF 절차에 대한 정보는 BCP 78 및 BCP 79에서 확인할 수 있습니다.

IETF 사무국에 제출된 IPR 공개 사본 및 사용 가능한 라이센스에 대한 보증, 또는 이 사양의 구현자 또는 사용자가 해당 독점적 권리 사용에 대한 일반 라이센스 또는 허가를 얻으려는 시도의 결과를 얻을 수 있습니다. IETF 온라인 IPR 저장소\(http://www.ietf.org/ipr\)에서.

IETF는 이 표준을 구현하는 데 필요할 수 있는 기술에 적용될 수 있는 모든 저작권, 특허, 특허 출원 또는 기타 독점권에 관심을 갖도록 관심 있는 당사자를 초대합니다. IETF\(ietf-ipr@ietf.org\)에 해당 정보를 보내주십시오.

---
# **Acknowledgement**

RFC 편집 기능을 위한 자금은 현재 Internet Society에서 제공됩니다.
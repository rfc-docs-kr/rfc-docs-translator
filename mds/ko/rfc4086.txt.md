

```text
Network Working Group                                   D. Eastlake, 3rd
Request for Comments: 4086                         Motorola Laboratories
BCP: 106                                                     J. Schiller
Obsoletes: 1750                                                      MIT
Category: Best Current Practice                               S. Crocker
                                                               June 2005
```

- 보안을 위한 임의성 요구 사항

---
# **Status of This Memo**

이 문서는 인터넷 커뮤니티를 위한 인터넷 모범 사례를 지정하고 개선을 위한 토론과 제안을 요청합니다. 이 메모의 배포는 무제한입니다.

---
# **Copyright Notice**

Copyright \(C\) The Internet Society \(2005\).

---
# **Abstract**

보안 시스템은 패턴 분석 시도를 저지하는 강력한 암호화 알고리즘을 기반으로 합니다. 그러나 이러한 시스템의 보안은 암호, 암호화 키 및 유사한 수량에 대한 비밀 수량 생성에 따라 달라집니다. 비밀 수량을 생성하기 위해 의사 무작위 프로세스를 사용하면 의사 보안이 발생할 수 있습니다. 정교한 공격자는 잠재적 수 공간 전체에서 수량을 찾는 것보다 비밀 수량을 생성한 환경을 재현하고 결과로 생성된 작은 가능성 집합을 검색하는 것이 더 쉽다는 것을 알 수 있습니다.

수완이 풍부하고 의욕이 넘치는 적을 무력화하기 위해 임의의 수량을 선택하는 것은 놀라울 정도로 어렵습니다. 이 문서는 이러한 양을 생성하기 위해 열악한 엔트로피 소스 또는 기존의 의사 난수 생성 기술을 사용할 때의 많은 함정을 지적합니다. 진정한 무작위 하드웨어 기술의 사용을 권장하고 많은 시스템의 기존 하드웨어를 이러한 목적으로 사용할 수 있음을 보여줍니다. 하드웨어 솔루션을 사용할 수 없을 때 문제를 개선하기 위한 제안을 제공하고 일부 응용 프로그램에 필요한 양이 얼마나 많은지에 대한 예를 제공합니다.

---
# **Table of Contents**

```text
   1. Introduction and Overview .......................................3
   2. General Requirements ............................................4
   3. Entropy Sources .................................................7
      3.1. Volume Required ............................................7
      3.2. Existing Hardware Can Be Used For Randomness ...............8
           3.2.1. Using Existing Sound/Video Input ....................8
           3.2.2. Using Existing Disk Drives ..........................8
      3.3. Ring Oscillator Sources ....................................9
      3.4. Problems with Clocks and Serial Numbers ...................10
      3.5. Timing and Value of External Events .......................11
      3.6. Non-hardware Sources of Randomness ........................12
   4. De-skewing .....................................................12
      4.1. Using Stream Parity to De-Skew ............................13
      4.2. Using Transition Mappings to De-Skew ......................14
      4.3. Using FFT to De-Skew ......................................15
      4.4. Using Compression to De-Skew ..............................15
   5. Mixing .........................................................16
      5.1. A Trivial Mixing Function .................................17
      5.2. Stronger Mixing Functions .................................18
      5.3. Using S-Boxes for Mixing ..................................19
      5.4. Diffie-Hellman as a Mixing Function .......................19
      5.5. Using a Mixing Function to Stretch Random Bits ............20
      5.6. Other Factors in Choosing a Mixing Function ...............20
   6. Pseudo-random Number Generators ................................21
      6.1. Some Bad Ideas ............................................21
           6.1.1. The Fallacy of Complex Manipulation ................21
           6.1.2. The Fallacy of Selection from a Large Database .....22
           6.1.3. Traditional Pseudo-random Sequences ................23
      6.2. Cryptographically Strong Sequences ........................24
           6.2.1. OFB and CTR Sequences ..............................25
           6.2.2. The Blum Blum Shub Sequence Generator ..............26
      6.3. Entropy Pool Techniques ...................................27
   7. Randomness Generation Examples and Standards ...................28
      7.1. Complete Randomness Generators ............................28
           7.1.1. US DoD Recommendations for Password Generation .....28
           7.1.2. The /dev/random Device .............................29
           7.1.3. Windows CryptGenRandom .............................30
      7.2. Generators Assuming a Source of Entropy ...................31
           7.2.1. X9.82 Pseudo-Random Number Generation ..............31
           7.2.2. X9.17 Key Generation ...............................33
           7.2.3. DSS Pseudo-random Number Generation ................34
   8. Examples of Randomness Required ................................34
      8.1. Password Generation .......................................35
      8.2. A Very High Security Cryptographic Key ....................36
   9. Conclusion .....................................................38
  10. Security Considerations ........................................38
  11. Acknowledgments ................................................39
  Appendix A: Changes from RFC 1750 ..................................40
  Informative References .............................................41
```

---
## **1.  Introduction and Overview**

소프트웨어 암호화가 보편화되기까지는 갈 길이 멀지만 더 널리 사용되고 있습니다. SSH, IPSEC, TLS, S/MIME, PGP, DNSSEC 및 Kerberos와 같은 시스템이 성숙해지고 있으며 네트워크 환경의 일부가 되고 있습니다. \[SSH\] \[IPSEC\] \[TLS\] \[S/MIME\] \[MAIL\_PGP\*\] \[DNSSEC\* \]. 비교를 위해 이 문서\[RFC1750\]의 이전 버전이 1994년에 발행되었을 때 IETF의 유일한 인터넷 암호화 보안 사양은 Privacy Enhanced Mail 프로토콜\[MAIL\_PEM\*\]이었습니다.

이러한 시스템은 스누핑 및 스푸핑에 대한 실질적인 보호 기능을 제공합니다. 그러나 잠재적인 결함이 있습니다. 모든 암호화 시스템의 중심에는 추측할 수 없는\(즉, 임의의\) 비밀 번호 생성이 있습니다.

이러한 난수를 생성하기 위한 일반적으로 사용 가능한 기능의 부족\(즉, 진정으로 예측할 수 없는 소스의 일반 가용성 부족\)은 암호화 소프트웨어 설계에 열린 상처를 형성합니다. 광범위한 하드웨어에서 실행되는 키 또는 암호 생성 절차를 구축하려는 소프트웨어 개발자에게 이것은 매우 현실적인 문제입니다.

요구 사항은 적이 추측하거나 결정할 가능성이 매우 낮은 데이터에 대한 것입니다. 무작위성에 대한 전통적인 통계 테스트만 충족하거나 시계와 같은 제한된 범위의 소스를 기반으로 하는 의사 무작위 데이터를 사용하는 경우 이는 쉽게 실패할 수 있습니다. 때때로 그러한 유사 난수량은 당황스러울 정도로 작은 가능성 공간을 통해 검색하는 적이 추측할 수 있습니다.

이 Best Current Practice 문서는 공격에 강한 무작위 수량을 생성하는 기술을 설명합니다. 향후 시스템에는 하드웨어 난수 생성이 포함되거나 이러한 목적으로 사용할 수 있는 기존 하드웨어에 대한 액세스를 제공할 것을 권장합니다. 이러한 하드웨어를 사용할 수 없는 경우 사용할 수 있는 방법을 제안하고 샘플 응용 프로그램에 필요한 무작위 비트 수에 대한 추정치를 제공합니다.

---
## **2.  General Requirements**

오늘날 일반적으로 발생하는 임의성 요구 사항은 일반적으로 간단한 문자열인 사용자 암호를 선택하는 것입니다. 분명히 추측할 수 있는 암호는 보안을 제공하지 않습니다. 재사용 가능한 비밀번호의 경우 사용자가 비밀번호를 기억할 수 있는 것이 바람직합니다. 이로 인해 발음 가능한 문자열이나 일반 단어로 구성된 구를 사용하는 것이 좋습니다. 그러나 이는 암호 정보의 형식에만 영향을 미치며 암호를 추측하기 매우 어렵다는 요구 사항에는 영향을 주지 않습니다.

다른 많은 요구 사항은 암호화 분야에서 나옵니다. 암호화 기술을 사용하여 기밀성 및 인증을 비롯한 다양한 서비스를 제공할 수 있습니다. 이러한 서비스는 적이 알 수 없고 추측할 수 없는 전통적으로 "키"라고 하는 수량을 기반으로 합니다.

초기 시퀀스 번호를 선택할 때 임의성을 위해 사용되는 TCP/IP 프로토콜도 있습니다\[RFC1948\].

일반적으로 말하면, 위의 예는 원할 수 있는 두 가지 다른 유형의 무작위 수량도 보여줍니다. 사람이 사용할 수 있는 암호의 경우 유일한 중요한 특성은 추측할 수 없다는 것입니다. ASCII 문자로 구성될 수 있으므로 예를 들어 모든 바이트의 최상위 비트는 0입니다. 반면에 고정 길이 키 등의 경우 일반적으로 진정한 무작위로 보이는 수량, 즉 비트가 통계적 무작위성 테스트를 통과하는 수량을 원합니다.

일회성 패드를 사용한 대칭 암호화 또는 미국 AES\(Advanced Encryption Standard\)와 같은 알고리즘을 사용하는 경우와 같이 기밀 및/또는 인증을 사용하여 통신하려는 당사자는 모두 동일한 비밀 키를 알고 있어야 합니다. 비대칭 또는 "공개 키" 암호화 기술이 사용되는 다른 경우에는 키가 쌍으로 제공됩니다. 쌍 중 하나의 키는 비공개이며 한 당사자가 비밀로 유지해야 합니다. 다른 하나는 공개되어 전 세계에 공개될 수 있습니다. 공개 키에서 개인 키를 결정하는 것은 계산상 불가능하며 공개 키에 대한 지식은 적에게 도움이 되지 않습니다\[ASYMMETRIC\]. 일반 참조\[SCHNEIER, FERGUSON, KAUFMAN\]를 참조하십시오.

임의 수량에 대한 요구 사항의 빈도와 양은 암호화 시스템마다 크게 다릅니다. 순수한 RSA를 사용하면 새 키 쌍이 생성될 때만 임의의 양이 필요합니다. 그 이후에는 임의성을 더 이상 필요로 하지 않고 원하는 수의 메시지에 서명할 수 있습니다. 미국 NIST\(National Institute of Standards and Technology\)에서 고안한 공개 키 디지털 서명 알고리즘은 각 서명\[DSS\]에 좋은 난수가 필요합니다. 그리고

1회용 패드로 암호화\(원칙적으로 가능한 가장 강력한 암호화 기술\)하려면 처리할 모든 메시지에 대해 동일한 양의 무작위성이 필요합니다. 일반 참조\[SCHNEIER, FERGUSON, KAUFMAN\]를 참조하십시오.

이러한 경우 대부분의 경우 공격자는 시행 착오를 통해 "비밀" 키를 확인하려고 시도할 수 있습니다. 올바른 키를 고유하게 식별할 수 있다는 메시지보다 키가 충분히 작으면 가능합니다. 상대가 이에 성공할 확률은 특정 응용 프로그램에 따라 수용할 수 있을 정도로 낮아야 합니다. 적이 검색해야 하는 공간의 크기는 정보 이론적 의미에서 존재하는 주요 "정보"의 양과 관련이 있습니다\[SHANNON\]. 이것은 다음과 같이 가능한 다른 비밀 값의 수와 각 값의 확률에 따라 다릅니다.

```text
                              -----
                              \
        Bits of information =  \     - p   * log  ( p  )
                               /        i       2    i
                              /
                              -----
```

여기서 i는 1부터 가능한 비밀 값의 수까지 세고 p sub i는 i로 번호가 매겨진 값의 확률입니다. \(p sub i가 1보다 작기 때문에 로그는 음수이므로 합계의 각 항은 음수가 아닙니다.\)

동일한 확률의 2^n개의 다른 값이 있는 경우 n비트의 정보가 존재하고 상대방은 비밀 수량을 추측하기 전에 평균적으로 값의 절반 또는 2^\(n-1\)을 시도해야 합니다. . 다른 값의 확률이 동일하지 않으면 존재하는 정보가 적고 적에게 평균적으로 더 적은 추측이 필요합니다. 특히 적이 불가능하거나 확률이 낮다고 알 수 있는 모든 값은 적이 더 가능성 있는 값을 먼저 검색하는 적에 의해 초기에 무시될 수 있습니다.

예를 들어 128비트 키를 사용하는 암호화 시스템을 생각해 보십시오. 이러한 키가 8비트 시드가 있는 고정 의사 난수 생성기를 사용하여 파생된 경우 공격자는 2개가 아닌 256개의 키\(가능한 모든 시드와 함께 의사 난수 생성기를 실행하여\)만 검색하면 됩니다. 처음에는 ^128개의 키가 있는 것처럼 보일 수 있습니다. 이 128비트 키에는 8비트의 "정보"만 있습니다.

위의 분석은 평균적으로 정확하지만 실제로 중요한 것이 적의 작업 요소인 암호 분석의 경우 일부 경우에는 오해의 소지가 있을 수 있습니다. 예를 들어, 이전 단락에서와 같이 128비트 키를 생성하는 의사 난수 생성기가 있지만 시간의 절반을 생성하지 않고 나머지 2^128 - 1 값에서 임의 선택을 생성한다고 가정합니다. 시간. 위의 Shannon 방정식은 이러한 키 값 중 하나에 64비트의 정보가 있다고 말하지만, 상대는 단순히 값 0을 시도함으로써 사용의 절반, 비록 무작위 절반이지만 보안을 깨뜨릴 수 있습니다. 따라서 암호화 목적을 위해 다음과 같이 정의된 미엔트로피와 같은 다른 척도를 살펴보는 것도 유용합니다.

```text
        Min-entropy =  - log  ( maximum ( p  ) )
                                           i
```

여기서 i는 위와 같습니다. 이 방정식을 사용하여 새로운 가상 분포에 대해 64비트의 고전적인 Shannon 엔트로피와 달리 1비트의 최소 엔트로피를 얻습니다.

Renyi 엔트로피라고도 하는 엔트로피의 연속 스펙트럼이 정의되었으며 매개변수 r로 지정됩니다. 여기서 r = 1은 Shannon 엔트로피이고 r = 무한대는 최소 엔트로피입니다. r = 0이면 그냥 log\(n\)입니다. 여기서 n은 0이 아닌 확률의 수입니다. Renyi 엔트로피는 r의 증가하지 않는 함수이므로 최소 엔트로피는 항상 엔트로피의 가장 보수적인 척도이며 일반적으로 암호화 평가에 사용하기에 가장 좋습니다\[LUBY\].

전통적인 의미에서 통계적으로 테스트된 임의성은 보안 사용에 필요한 예측 불가능성과 동일하지 않습니다.

예를 들어 CRC Standard Mathematical Tables의 랜덤 테이블과 같이 널리 사용되는 상수 시퀀스를 사용하는 것은 적에게 매우 취약합니다. 그것을 배우거나 추측하는 적은 시퀀스 \[CRC\]에 따라 미래와 과거의 모든 보안을 쉽게 깨뜨릴 수 있습니다. 또 다른 예로서 AES를 상수 키와 함께 사용하여 1, 2, 3, ...과 같은 연속적인 정수를 암호화하면 뛰어난 통계적 무작위성 속성도 있지만 예측 가능한 출력이 생성됩니다. 반면에 6면체 다이를 연속적으로 굴리고 결과 값을 ASCII로 인코딩하면 상당한 예측 불가능한 구성 요소로 인해 통계적으로 불량한 출력이 생성됩니다. 따라서 통계 테스트의 통과 또는 실패는 어떤 것이 예측할 수 없는지 또는 예측 가능한지 나타내지 않습니다.

---
## **3.  Entropy Sources**

엔트로피 소스는 구현에 매우 의존하는 경향이 있습니다. 일단 충분한 엔트로피를 모으면 섹션 4와 섹션 4와 5.

미래에 강력하고 이식 가능한 무작위성에 대한 희망이 있습니까? 있을 수 있습니다. 필요한 것은 예측할 수 없는 숫자의 물리적 소스입니다.

열 잡음\(종종 집적 회로에서 Johnson 잡음이라고 함\) 또는 방사성 감쇠 소스와 빠르고 자유롭게 실행되는 발진기가 트릭을 직접 수행합니다\[GIFFORD\]. 이것은 사소한 양의 하드웨어이며 컴퓨터 시스템 아키텍처의 표준 부분으로 쉽게 포함될 수 있습니다. 대부분의 오디오\(또는 비디오\) 입력 장치를 사용할 수 있습니다\[TURBID\]. 더욱이, 회전하는 디스크 또는 링 오실레이터와 안정적인 \(크리스탈\) 시간 소스 등이 있는 모든 시스템은 적절한 무작위 소스를 가지고 있습니다\(\[DAVIS\] 및 섹션 3.3\). 필요한 것은 이 작은 추가 하드웨어와 이에 액세스하는 소프트웨어가 필요하고 유용하다는 컴퓨터 공급업체 간의 일반적인 인식입니다.

ANSI X9는 현재 엔트로피 소스 전용 부분을 포함하는 표준을 개발 중입니다. \[X9.82\]의 파트 2를 참조하십시오.

---
### **3.1.  Volume Required**

얼마나 많은 예측 불가능성이 필요합니까? 예를 들어 초당 임의의 비트 수로 요구 사항을 정량화할 수 있습니까?

답은 별로 필요하지 않다는 것입니다. AES의 경우 키는 128비트가 될 수 있으며 섹션 8의 예에서 볼 수 있듯이 가장 높은 보안 시스템도 200비트가 훨씬 넘는 강력한 키 자료를 요구하지 않을 것입니다. 일련의 키가 필요한 경우 섹션 6.2에서 설명한 대로 강력한 암호 시퀀스를 사용하여 강력한 임의 시드\(시작 값\)에서 키를 생성할 수 있습니다. 시작할 때 생성되는 수백 개의 무작위 비트 또는 이러한 기술을 사용하는 경우 하루에 한 번이면 충분합니다. 랜덤 비트가 초당 1개 정도로 느리게 생성되고 생성 프로세스를 겹칠 수 없더라도, 대부분의 높은 보안 애플리케이션에서 가끔 200초를 기다리는 것은 허용되어야 합니다.

이 숫자는 달성하기 쉽지 않습니다. 반복적으로 동전을 던지는 사람에 의해 달성될 수 있으며 거의 ​​모든 하드웨어 기반 프로세스가 훨씬 빠를 가능성이 높습니다.

---
### **3.2.  Existing Hardware Can Be Used For Randomness**

아래에 설명된 것처럼 많은 컴퓨터에는 진정한 임의의 양을 생성하는 데 주의를 기울여 사용할 수 있는 하드웨어가 함께 제공됩니다.

---
#### **3.2.1.  Using Existing Sound/Video Input**

많은 컴퓨터에는 마이크의 사운드 또는 카메라의 비디오 입력과 같은 일부 실제 아날로그 소스를 디지털화하는 입력이 내장되어 있습니다. 소스가 연결되지 않은 사운드 디지타이저 또는 렌즈 캡이 있는 카메라의 "입력"은 기본적으로 열 잡음입니다. 시스템이 어떤 것을 탐지하기에 충분한 이득을 가지고 있다면 그러한 입력은 상당히 높은 품질의 무작위 비트를 제공할 수 있습니다. 이 방법은 하드웨어 구현에 크게 의존합니다.

예를 들어 일부 UNIX 기반 시스템에서는 마이크 잭에 아무 것도 연결하지 않거나 마이크가 낮은 수준의 배경 소음만 수신하는 상태에서 /dev/audio 장치에서 읽을 수 있습니다. 이러한 데이터는 기본적으로 무작위 잡음이지만 하드웨어 오류가 발생할 경우 일부 확인 없이는 신뢰할 수 없으며 왜곡을 보정해야 합니다.

이 접근 방식을 왜곡 보정을 위한 압축과 결합하면\(섹션 4 참조\) UNIX 스타일 명령줄을 사용하여 막대한 양의 중간 품질 임의 데이터를 생성할 수 있습니다.

```text
        cat /dev/audio | compress - >random-bits-file
```

이러한 유형의 임의성 소스에 대한 자세한 조사는 \[TURBID\]에 나와 있습니다.

---
#### **3.2.2.  Using Existing Disk Drives**

디스크 드라이브는 혼란스러운 공기 난기류\[DAVIS, Jakobsson\]로 인해 회전 속도에 약간의 무작위 변동이 있습니다. 낮은 수준의 디스크 검색 시간 계측을 추가하면 이 임의성을 포함하는 일련의 측정값이 생성됩니다. 이러한 데이터는 일반적으로 높은 상관 관계가 있으므로 아래 섹션 5.2에 설명된 대로 상당한 처리가 필요합니다. 그럼에도 불구하고 10년 전의 실험은 그러한 처리를 통해 당시 느린 컴퓨터의 느린 디스크 드라이브도 분당 100비트 이상의 뛰어난 임의 데이터를 쉽게 생성할 수 있음을 보여주었습니다.

프로세서 속도가 증가할 때마다 디스크 동작의 시간을 측정할 수 있는 해상도가 증가하거나 디스크 검색 속도가 증가하고 이 기술로 가능한 임의 비트 생성 속도가 증가합니다. 이 백서 작성 시점과 최신 하드웨어를 사용하는 경우 보다 일반적인 임의 비트 생성 속도는

초당 10,000비트. 이 기술은 많은 운영 체제 라이브러리에 포함된 난수 생성기에서 사용됩니다.

참고: 디스크 컨트롤러에 캐시 메모리를 포함하더라도 캐시 적중을 나타내는 매우 짧은 검색 시간이 단순히 무시되는 경우 이 기술에 거의 영향을 미치지 않습니다.

---
### **3.3.  Ring Oscillator Sources**

집적 회로를 설계하거나 현장 프로그래밍하는 경우 홀수 개의 게이트를 직렬로 연결하여 자유롭게 실행되는 링 오실레이터를 생성할 수 있습니다. 고정 주파수\(예: 안정적인 수정 발진기에 의해 결정된 주파수\)에서 링의 한 지점을 샘플링하면 자유 실행 발진기 타이밍의 변화로 인해 일정량의 엔트로피를 추출할 수 있습니다. 비교적 소수 길이를 가진 몇 개의 링 오실레이터에서 샘플링된 값을 XOR'ing하여 엔트로피 속도를 높일 수 있습니다. 때때로 홀수 개의 링을 사용하여 링이 어떻게든 서로 동기식으로 잠기더라도 여전히 샘플링된 비트 전환이 있도록 하는 것이 좋습니다. 샘플링할 수 있는 또 다른 소스는 잡음이 많은 다이오드의 출력입니다.

이러한 소스에서 샘플링된 비트는 디스크 회전 타이밍이 그렇듯이 과도하게 왜곡을 보정해야 합니다\(섹션 4 참조\). 특정 설계에 따라 생성되는 엔트로피의 양을 결정하려면 엔지니어링 연구가 필요합니다. 어쨌든 이들은 비용이 현대 표준에 따라 하드웨어의 사소한 양인 좋은 소스가 될 수 있습니다.

예를 들어, IEEE 802.11i는 원치 않는 동기화 등을 피하기 위해 링을 서로 격리하고 클록 회로로부터 분리하는 설계에 상당한 주의를 기울이고 광범위한 사후 처리\[IEEE\_802.11i\]와 함께 아래 회로를 제안합니다.

```text
             |\     |\                |\
         +-->| >0-->| >0-- 19 total --| >0--+-------+
         |   |/     |/                |/    |       |
         |                                  |       |
         +----------------------------------+       V
                                                 +-----+
             |\     |\                |\         |     | output
         +-->| >0-->| >0-- 23 total --| >0--+--->| XOR |------>
         |   |/     |/                |/    |    |     |
         |                                  |    +-----+
         +----------------------------------+      ^ ^
                                                   | |
             |\     |\                |\           | |
         +-->| >0-->| >0-- 29 total --| >0--+------+ |
         |   |/     |/                |/    |        |
         |                                  |        |
         +----------------------------------+        |
                                                     |
             Other randomness, if available ---------+
```

---
### **3.4.  Problems with Clocks and Serial Numbers**

컴퓨터 시계 및 유사한 운영 체제 또는 하드웨어 값은 해당 사양에서 나타날 수 있는 것보다 훨씬 더 적은 실제 예측 불가능 비트를 제공합니다.

수많은 시스템의 시계에 대한 테스트가 수행되었으며 동작이 광범위하고 예상치 못한 방식으로 다양할 수 있음이 밝혀졌습니다. 하나의 하드웨어 세트에서 실행되는 운영 체제의 한 버전은 실제로 클럭의 마이크로초 분해능을 제공할 수 있는 반면, "동일한" 시스템의 다른 구성은 항상 동일한 하위 비트를 제공하고 상위 비트만 많이 계산할 수 있습니다. 낮은 해상도. 즉, 공칭 클럭 해상도에 따라 값이 "변경되어야" 하는 충분한 시간이 경과한 경우에도 클럭을 연속적으로 읽으면 동일한 값이 생성될 수 있습니다. 두 번의 읽기 사이에 시계가 변경되지 않았는지 확인하고 1씩 증가시키는 추가 코드 때문에 시계를 자주 읽으면 인공적인 순차 값이 생성될 수 있는 경우도 있습니다! 이러한 시스템 시계를 기반으로 예측할 수 없는 숫자를 생성하도록 이식 가능한 응용 프로그램 코드를 설계하는 것은 시스템 디자이너가 항상 시스템 시계의 속성을 알지 못하기 때문에 특히 어렵습니다.

하드웨어 일련 번호\(이더넷 MAC 주소 등\)를 사용하면 생각보다 적은 비트의 고유성을 제공할 수도 있습니다. 이러한 수량은 일반적으로 심하게 구조화되어 있으며 하위 필드에는 가능한 값의 범위가 제한되어 있거나 대략적인 제조 날짜 또는 기타 데이터를 기반으로 값을 쉽게 추측할 수 있습니다.

예를 들어, 컴퓨터와 이더넷 어댑터를 모두 제조하는 회사는 적어도 내부적으로는 내장 주소의 범위를 크게 제한하는 자체 어댑터를 사용할 가능성이 있습니다.

위에서 설명한 것과 같은 문제로 인해 코드가 다양한 컴퓨터 플랫폼 및 시스템에 포팅되어야 하는 경우 예측할 수 없는 양을 생성하는 코드 생성이 어렵습니다.

---
### **3.5.  Timing and Value of External Events**

마우스 이동, 키 입력 및 유사한 사용자 이벤트의 타이밍과 내용을 측정할 수 있습니다. 이것은 몇 가지 자격이 있는 추측할 수 없는 데이터의 합리적인 소스입니다. 일부 시스템에서는 키 입력과 같은 입력이 버퍼링됩니다. 사용자의 키 입력 간 타이밍에 충분한 변동과 예측 불가능성이 있을 수 있지만 해당 변동에 쉽게 액세스할 수 있는 방법이 없을 수 있습니다. 또 다른 문제는 샘플링 타이밍 세부 사항에 대한 표준 방법이 없다는 것입니다. 이로 인해 이 기술을 사용하여 광범위한 시스템에 배포할 표준 소프트웨어를 구축하기가 어렵습니다.

마우스 움직임의 양과 실제 키 입력은 일반적으로 타이밍보다 액세스하기 쉽지만 사용자가 매우 반복적인 입력을 제공할 수 있기 때문에 예측 가능성이 적을 수 있습니다.

네트워크 패킷 도착 시간 및 길이와 같은 다른 외부 이벤트도 사용할 수 있지만 매우 주의해야 합니다. 특히 이러한 네트워크 트래픽 측정값이 공격자에 의해 조작될 가능성과 시스템 시작 시 이력이 없는 점을 신중하게 고려해야 합니다. 이 입력이 조작의 대상인 경우 엔트로피 소스로 신뢰해서는 안 됩니다.

원칙적으로 원시 라디오 수신 또는 적절한 장비를 갖춘 컴퓨터의 온도 감지와 같은 거의 모든 외부 센서를 사용할 수 있습니다. 그러나 각각의 경우에 이 데이터가 적대적 조작의 대상이 되는 정도와 실제로 제공할 수 있는 엔트로피의 양을 신중하게 고려해야 합니다.

위의 기술은 측정 중인 수량에 액세스할 수 없는 공격자에 대해 매우 강력합니다. 예를 들어, 이러한 기술은 자신의 환경에 대한 액세스 권한이 없고 사후에 임의 시드를 크랙하려는 오프라인 공격자에 대해 강력합니다. 모든 경우에 외부 센서의 타이밍이나 값을 더 정확하게 측정할수록 더 빠르게 비트를 생성할 수 있습니다.

---
### **3.6.  Non-hardware Sources of Randomness**

입력 엔트로피의 가장 좋은 소스는 링 발진기, 디스크 드라이브 타이밍, 열 잡음 또는 방사성 붕괴와 같은 하드웨어 기반 임의 소스입니다. 그러나 이들 중 어느 것도 사용할 수 없는 경우 다른 가능성이 있습니다. 여기에는 시스템 클럭, 시스템 또는 입력/출력 버퍼, 사용자/시스템/하드웨어/네트워크 일련 번호 또는 주소 및 타이밍, 사용자 입력이 포함됩니다. 불행하게도 이러한 각 소스는 상황에 따라 매우 제한적이거나 예측 가능한 값을 생성할 수 있습니다.

위에 나열된 소스 중 일부는 시스템의 각 사용자가 본질적으로 임의성의 소스인 다중 사용자 시스템에서 매우 강력합니다. 그러나 작은 단일 사용자 또는 임베디드 시스템에서는 특히 시작할 때 공격자가 유사한 구성을 조립할 수 있습니다. 이것은 철저한 검색을 실용적으로 만들기 위해 원래 사용된 것과 충분히 상관관계가 있는 혼합 프로세스에 대한 적의 입력을 제공할 수 있습니다.

강력한 믹싱 기능이 있는 여러 개의 임의 입력을 사용하는 것이 좋으며 특정 입력의 약점을 극복할 수 있습니다. 요청된 "무작위" 사용자 키 입력의 타이밍과 내용은 수백 개의 임의 비트를 생성할 수 있지만 보수적인 가정이 필요합니다. 예를 들어 합리적으로 보수적인 한 가지 가정은 키 입력 간 간격이 기껏해야 몇 비트의 임의성을 제공하지만 간격이 해당 지점까지의 간격 시퀀스에서 고유한 경우에만 제공된다는 것입니다. 유사한 가정은 키 코드가 몇 비트의 임의성을 제공하지만 코드가 시퀀스에서 고유한 경우에만 제공된다는 것입니다. 따라서 이전 값을 복제한 간격 또는 키 코드는 추가 임의성을 제공하지 않는 것으로 간주됩니다. 입력된 문자와 이러한 타이밍을 혼합한 결과는 클록 값 및 기타 입력과 추가로 결합될 수 있습니다.

이 전략은 일부 입력이 일부 대상 시스템에서 매우 약한 경우에도 보안을 위해 우수한 난수를 생성하기 위한 실용적인 이식 가능한 코드를 만들 수 있습니다. 그러나 특히 적이 과거에 생성 프로세스를 관찰할 수 있었던 경우 소규모, 단일 사용자 또는 임베디드 시스템에 대한 고급 공격에 대해서는 여전히 실패할 수 있습니다. 하드웨어 기반 임의 소스가 여전히 바람직합니다.

---
## **4.  De-skewing**

엔트로피가 난수를 생성하기 위해 수집된 양의 분포 모양에 대한 특정 요구 사항이 있습니까? 좋은 소식은 분포가 균일할 필요가 없다는 것입니다. 성능을 제한하는 데 필요한 모든 것은 방법에 대한 보수적인 추정치입니다.

불균일합니다. 비트 스트림의 왜곡을 보정하는 간단한 기술은 아래에 나와 있으며 더 강력한 암호화 기술은 섹션 5.2에서 설명합니다.

---
### **4.1.  Using Stream Parity to De-Skew**

간단하지만 특별히 실용적이지 않은 예로서 충분히 긴 비트 문자열을 사용하여 문자열을 "0" 또는 "1"로 매핑하는 것을 고려하십시오. 매핑이 완벽하게 균일한 분포를 생성하지는 않지만 원하는 만큼 근접할 수 있습니다. 목적에 맞는 매핑 중 하나는 문자열의 패리티를 가져오는 것입니다. 이는 추정된 최대 왜곡까지 모든 정도의 왜곡에 걸쳐 견고하고 하드웨어에서 구현하기 쉽다는 장점이 있습니다.

다음 분석은 샘플링해야 하는 비트 수를 제공합니다.

1 대 0의 비율이 \( 0.5 + E \) 대 \( 0.5 - E \)라고 가정합니다. 여기서 E는 0과 0.5 사이이며 분포의 "편심" 측정값입니다. N 비트 샘플의 패리티 함수 분포를 고려하십시오. 패리티가 1 또는 0이 될 각각의 확률은 \(p + q\)^N의 이항 확장에서 홀수 항 또는 짝수 항의 합이 될 것입니다. 여기서 p = 0.5 + E, 1의 확률, q = 0.5 - E, 0의 확률.

이 합계는 다음과 같이 쉽게 계산할 수 있습니다.

```text
                         N            N
        1/2 * ( ( p + q )  + ( p - q )  )
```

그리고

- N N 1/2 \* \( \( p + q \) - \( p - q \) \).

\(패리티가 1이 될 확률에 해당하는 공식은 N이 홀수인지 짝수인지에 따라 다릅니다.\)

p + q = 1 및 p - q = 2E이므로 이러한 식은 다음과 같이 줄어듭니다.

```text
                       N
        1/2 * [1 + (2E)  ]
```

그리고

- N 1/2 \* \[1 - \(2E\) \].

E가 0이 아닌 한 이들 중 어느 것도 정확히 0.5가 되지는 않지만 임의로 0.5에 가깝게 만들 수 있습니다. 예를 들어 확률이 0.5의 일부 델타 d 내에 있기를 원하면

```text
                            N
        ( 0.5 + ( 0.5 * (2E)  ) )  <  0.5 + d.
```

N을 풀면 N \> log\(2d\)/log\(2E\)가 됩니다. \(2E는 1보다 작으므로 로그는 음수입니다. 음수로 나누면 부등식의 의미가 반전됩니다.\)

다음 표는 50/50 분포의 0.001 이내가 되기 위해 다양한 왜곡도에 대해 샘플링해야 하는 문자열의 길이 N을 제공합니다.

```text
                +---------+--------+-------+
                | Prob(1) |    E   |    N  |
                +---------+--------+-------+
                |   0.5   |  0.00  |    1  |
                |   0.6   |  0.10  |    4  |
                |   0.7   |  0.20  |    7  |
                |   0.8   |  0.30  |   13  |
                |   0.9   |  0.40  |   28  |
                |   0.95  |  0.45  |   59  |
                |   0.99  |  0.49  |  308  |
                +---------+--------+-------+
```

마지막 항목은 분포가 99% 편향되더라도 308개 샘플 문자열의 패리티가 50/50 분포의 0.001 내에 있음을 보여줍니다. 그러나 섹션 5.2에서 볼 수 있듯이 사용 가능한 엔트로피를 더 많이 추출하는 훨씬 더 강력한 기술이 있습니다.

---
### **4.2.  Using Transition Mappings to De-Skew**

원래 von Neumann\[VON\_NEUMANN\]으로 인한 또 다른 기술은 비트 스트림을 겹치지 않는 쌍의 시퀀스로 검사하는 것입니다. 그런 다음 찾은 00 또는 11 쌍을 버리고 01을 0으로 해석하고 10을 1로 해석할 수 있습니다. 1의 확률은 0.5+E이고 0의 확률은 0.5-E라고 가정합니다. 여기서 E는 이심률입니다. 이전 섹션에서 설명한 소스의. 그런 다음 각 쌍의 확률은 다음 표에 나와 있습니다.

```text
            +------+-----------------------------------------+
            | pair |            probability                  |
            +------+-----------------------------------------+
            |  00  | (0.5 - E)^2          =  0.25 - E + E^2  |
            |  01  | (0.5 - E)*(0.5 + E)  =  0.25     - E^2  |
            |  10  | (0.5 + E)*(0.5 - E)  =  0.25     - E^2  |
            |  11  | (0.5 + E)^2          =  0.25 + E + E^2  |
            +------+-----------------------------------------+
```

이 기술은 바이어스를 완전히 제거하지만 특정 원하는 출력 비트 수에 대해 불확실한 수의 입력 비트가 필요합니다. 특정 쌍이 폐기될 확률은 0.5 + 2E^2이므로 X 출력 비트를 생성하기 위한 예상 입력 비트 수는 X/\(0.25 - E^2\)입니다.

이 기술은 각 비트가 스트림의 다른 비트와 동일한 확률로 0 또는 1이 될 확률이 있고 비트가 상관관계가 없는 스트림에서 나온 비트라고 가정합니다. 즉, 비트가 동일한 독립 분포에서 나온다고 가정합니다. 예를 들어 대체 비트가 두 개의 상관된 소스에서 나온 경우 위의 분석이 무너집니다.

위의 기술은 또한 적에게 악용될 수 있는 패턴을 항상 주시하지 않는 경우 간단한 통계 분석이 어떻게 오도할 수 있는지에 대한 또 다른 예를 제공합니다. 알고리즘이 약간 잘못 읽혀 겹치지 않는 쌍 대신 겹치는 연속 비트 쌍이 사용되는 경우 주어진 통계 분석은 동일합니다. 그러나 편향되지 않고 상관관계가 없는 일련의 임의의 1과 0을 제공하는 대신 정확히 1과 0이 번갈아 나타나는 완전히 예측 가능한 시퀀스를 생성합니다.

---
### **4.3.  Using FFT to De-Skew**

실제 데이터가 강하게 상관된 비트로 구성되어 있으면 여전히 유용한 양의 엔트로피가 포함될 수 있습니다. 이 엔트로피는 다양한 변환을 통해 추출할 수 있으며 가장 강력한 변환은 아래 섹션 5.2에 설명되어 있습니다.

데이터의 푸리에 변환 또는 최적화된 변형인 FFT를 사용하는 것은 주로 이론적인 이유로 흥미롭습니다. 이 기술이 강한 상관 관계를 버릴 것임을 알 수 있습니다. 적절한 데이터가 처리되고 나머지 상관 관계가 감소하면 통계적 독립성과 정규 분포 무작위성에 접근하는 스펙트럼 선이 생성될 수 있습니다\[BRILLINGER\].

---
### **4.4.  Using Compression to De-Skew**

가역 압축 기술은 왜곡된 비트 스트림을 왜곡 보정하는 조잡한 방법도 제공합니다. 이는 가역 압축의 정의와 시퀀스의 정보량에 대한 섹션 2의 공식에서 직접 따릅니다. 압축은 되돌릴 수 있으므로 더 긴 입력에 있는 것과 동일한 양의 정보가 더 짧은 출력에 있어야 합니다. Shannon 정보 방정식에 따르면 이것은 평균적으로 서로 다른 짧은 시퀀스의 확률이 더 긴 시퀀스의 확률보다 더 균일하게 분포되는 경우에만 가능합니다. 따라서 더 짧은 시퀀스는 입력에 비해 왜곡을 보정해야 합니다.

그러나 많은 압축 기술은 출력 스트림에 다소 예측 가능한 서문을 추가하고 유사한 시퀀스를 출력에 주기적으로 삽입하거나 고유한 미묘한 패턴을 도입할 수 있습니다. 섹션 5.2에 설명된 것과 비교하여 대략적인 기술로만 간주되어야 합니다. 최소한 압축된 시퀀스의 시작 부분은 건너뛰어야 하며 대략적인 무작위 비트가 필요한 응용 프로그램에는 이후 비트만 사용해야 합니다.

---
## **5.  Mixing**

강력하고 신뢰할 수 있는 하드웨어 엔트로피 소스가 없을 때 추측할 수 없는 난수를 얻기 위한 최상의 전체 전략은 무엇입니까? 상관관계가 없는 여러 소스에서 입력을 받아 강력한 믹싱 기능으로 믹싱하는 것입니다. 이러한 함수는 결합되는 다른 양이 고정되거나 쉽게 추측할 수 있는 경우\(낮은 엔트로피\)에도 소스에 존재하는 엔트로피를 보존합니다. 하드웨어도 실패할 수 있으므로 이 접근 방식은 좋은 하드웨어 소스에서도 권장할 수 있습니다. 그러나 이는 추가된 소프트웨어 복잡성으로 인해 전체 실패 가능성이 증가할 가능성과 비교하여 평가해야 합니다.

섹션 3에 나열된 것과 같은 좋은 소스를 사용하고 이 섹션에서 설명한 대로 혼합하면 강력한 씨앗을 갖게 됩니다. 그런 다음 섹션 6 및 7에 설명된 대로 강력한 암호화 자료를 대량으로 생성하는 데 사용할 수 있습니다.

강한 혼합 기능은 입력을 결합하고 각 출력 비트가 모든 입력 비트의 다른 복잡한 비선형 함수인 출력을 생성하는 기능입니다. 평균적으로 입력 비트를 변경하면 출력 비트의 약 절반이 변경됩니다. 그러나 관계가 복잡하고 비선형적이기 때문에 특정 입력 비트가 변경될 때 특정 출력 비트가 변경되지 않을 수 있습니다.

섹션 4에서 설명한 것처럼 0 또는 1 쪽으로 치우쳐 있거나 어느 정도 예측 가능한 패턴을 가진 비트 스트림을 보다 무작위적인 더 짧은 스트림으로 변환하는 문제를 고려하십시오. 이것은 단순히 강력한 혼합 기능이 필요한 또 다른 경우입니다. , 입력 비트를 혼합하고 더 적은 수의 출력 비트를 생성합니다. 여러 비트의 패리티를 사용하는 섹션 4.1에 제공된 기술은 단순히 연속적으로 XOR한 결과입니다. 이것은 바로 아래에서 사소한 혼합 함수로 검사됩니다. 왜곡된 비트 스트림에서 더 많은 임의성을 추출하기 위해 더 강력한 혼합 기능을 사용하는 방법은 섹션 5.2에서 검토합니다. \[NASLUND\]도 참조하십시오.

---
### **5.1.  A Trivial Mixing Function**

설명을 위해 XOR\(Exclusive Or\) 기능을 사용하여 단일 비트 입력에 대한 간단한 예를 설명합니다. 이 함수는 아래 표와 같이 캐리가 없는 덧셈과 같습니다. 이것은 한 입력 비트의 변화에 ​​대해 하나의 출력 비트가 항상 변하는 퇴화 사례입니다. 그러나 단순함에도 불구하고 유용한 예시를 제공합니다.

```text
                +-----------+-----------+----------+
                |  input 1  |  input 2  |  output  |
                +-----------+-----------+----------+
                |     0     |     0     |     0    |
                |     0     |     1     |     1    |
                |     1     |     0     |     1    |
                |     1     |     1     |     0    |
                +-----------+-----------+----------+
```

입력 1과 2가 상관되지 않고 이러한 방식으로 결합되면 출력은 입력보다 훨씬 더 나은\(덜 왜곡된\) 임의 비트가 됩니다. 위의 섹션 4.1에 정의된 "편심" E를 가정하면 출력 편심은 다음과 같이 입력 편심과 관련됩니다.

```text
        E       = 2 * E        * E
         output        input 1    input 2
```

E는 결코 1/2보다 크지 않기 때문에 적어도 하나의 입력이 완전히 왜곡된 상수인 경우를 제외하고 이심률은 항상 개선됩니다. 이것은 다음 표에 설명되어 있습니다. 여기서 상단 및 왼쪽 값은 두 개의 입력 이심률이고 항목은 출력 이심률입니다.

```text
     +--------+--------+--------+--------+--------+--------+--------+
     |    E   |  0.00  |  0.10  |  0.20  |  0.30  |  0.40  |  0.50  |
     +--------+--------+--------+--------+--------+--------+--------+
     |  0.00  |  0.00  |  0.00  |  0.00  |  0.00  |  0.00  |  0.00  |
     |  0.10  |  0.00  |  0.02  |  0.04  |  0.06  |  0.08  |  0.10  |
     |  0.20  |  0.00  |  0.04  |  0.08  |  0.12  |  0.16  |  0.20  |
     |  0.30  |  0.00  |  0.06  |  0.12  |  0.18  |  0.24  |  0.30  |
     |  0.40  |  0.00  |  0.08  |  0.16  |  0.24  |  0.32  |  0.40  |
     |  0.50  |  0.00  |  0.10  |  0.20  |  0.30  |  0.40  |  0.50  |
     +--------+--------+--------+--------+--------+--------+--------+
```

그러나 위의 계산에서는 입력이 상관되지 않는다고 가정합니다. 예를 들어 입력이 두 시계의 자정부터 몇 초까지 정확한 분 수의 패리티인 경우 훨씬 더 긴 임의 간격으로 샘플링하면 각각 무작위로 나타날 수 있습니다.

1분보다 그러나 둘 다 샘플링되고 XOR과 결합되면 결과는 대부분 0이 됩니다.

---
### **5.2.  Stronger Mixing Functions**

미국 정부의 AES\(Advanced Encryption Standard\)는 여러 비트 수량에 대한 강력한 혼합 기능의 예입니다. 이것은 최대 384비트의 입력\(128비트의 "데이터" 및 256비트의 "키"\)을 취하고 128비트의 출력을 생성하며, 각각은 모든 입력 비트의 복잡한 비선형 함수에 의존합니다. \[DES\]와 같은 이러한 특성을 가진 다른 암호화 기능도 키와 데이터 입력 비트를 모두 혼합하는 것으로 간주하여 사용할 수 있습니다.

혼합 함수의 또 다른 좋은 제품군은 "메시지 다이제스트" 또는 미국 정부 보안 해시 표준\[SHA\*\] 및 MD4, MD5\[MD4, MD5\] 시리즈와 같은 해싱 함수입니다. 이러한 함수는 모두 실질적으로 무제한의 입력을 받고 모든 입력 비트를 혼합하여 상대적으로 짧은 고정 길이 출력을 생성합니다. MD\* 시리즈는 128비트의 출력을 생성하고 SHA-1은 160비트를 생성하며 기타 SHA 기능은 최대 512비트를 생성합니다.

메시지 다이제스트 기능은 다양한 양의 입력을 위해 설계되었지만 AES 및 기타 암호화 기능을 사용하여 여러 입력을 결합할 수도 있습니다. 128비트 출력이 적절하면 입력을 128비트 데이터 양과 연속 AES "키"로 압축할 수 있으며 필요한 경우 0으로 채울 수 있습니다. 그런 다음 전자 코드북 모드에서 AES를 사용하여 "키"로 수량을 연속적으로 암호화합니다. 또는 입력을 하나의 128비트 키와 여러 데이터 블록으로 묶을 수 있으며 CBC-MAC를 계산할 수 있습니다\[MODES\].

128비트 이상의 출력이 필요하고 AES를 사용하려는 경우 더 복잡한 믹싱을 사용해야 합니다\(하지만 입력된 것보다 더 많은 "무작위" 비트를 얻는 것은 절대 불가능합니다\). 예를 들어 입력이 A, B, C의 세 수량으로 압축된다고 가정합니다. AES를 사용하여 A를 B로 암호화한 다음 C를 키로 사용하여 출력의 첫 번째 부분을 생성한 다음 B를 C로 암호화한 다음 A는 더 많은 출력을 위해, 필요한 경우 A로 C를 암호화한 다음 더 많은 출력을 위해 B를 암호화합니다. 위에 주어진 키의 순서를 반대로 하여 더 많은 출력을 생성할 수 있습니다. 입력 데이터의 다양한 하위 집합 또는 입력 데이터의 다른 복사본을 다른 접두사 및/또는 접미사로 해시하여 여러 출력을 생성하는 해시 함수에서도 동일한 작업을 수행할 수 있습니다.

강력한 믹싱 함수를 사용하는 예를 들어 각각 99%가 0으로 편향된 308비트 문자열의 경우를 다시 생각해 보십시오. 섹션 4.1에 제공된 패리티 기술은 이를 1비트로 줄이고 1/1000 편차만 0 또는 1일 가능성이 동일합니다. 그러나 섹션 2에 제공된 정보에 대한 방정식을 적용하면

308비트 왜곡된 시퀀스에는 5비트 이상의 정보가 포함됩니다. 따라서 SHA-1로 해싱하고 결과의 하위 5비트를 가져오면 문자열의 패리티를 계산하여 주어진 단일 비트가 아닌 편향되지 않은 5개의 임의 비트가 생성됩니다. 또는 일부 응용 프로그램의 경우 전체 해시 출력을 사용하여 거의 모든 5비트 이상의 엔트로피를 160비트 수량으로 유지할 수 있습니다.

---
### **5.3.  Using S-Boxes for Mixing**

DES 및 AES를 포함한 많은 최신 블록 암호화 기능은 S-Box\(대체 상자\)로 알려진 모듈을 통합합니다. 이들은 제한된 엔트로피를 입력에서 출력으로 집중시키는 효과가 있는 복잡한 비선형 혼합 기능을 통해 더 많은 수의 입력에서 더 적은 수의 출력을 생성합니다.

S-Box는 때때로 구부러진 부울 함수\(최대 비선형성으로 하나의 출력 비트를 생성하는 짝수 비트의 함수\)를 통합합니다. 특정 비트 위치가 다른 모든 입력 쌍의 출력을 보면 정확히 절반의 출력이 다릅니다. 각 출력 비트가 구부러진 함수에 의해 생성되어 이러한 함수의 선형 조합도 구부러진 함수가 되는 S-Box를 "완벽한 S-Box"라고 합니다.

S-box 및 이러한 상자의 다양한 반복 적용 또는 캐스케이드를 사용하여 \[SBOX1, SBOX2\]를 혼합할 수 있습니다.

---
### **5.4.  Diffie-Hellman as a Mixing Function**

Diffie-Hellman 지수 키 교환은 두 당사자 간에 공유 비밀을 생성하는 기술입니다. 두 통신 당사자 간의 모든 메시지를 관찰할 수 있더라도 제3자가 이 비밀을 결정하는 것은 계산상 불가능할 수 있습니다. 이 공유 비밀은 각 당사자 \[D-H\]가 생성한 초기 수량의 혼합입니다.

이러한 초기 양이 임의적이고 상관관계가 없는 경우 공유 비밀은 엔트로피를 결합하지만 물론 생성된 공유 비밀의 크기보다 더 많은 임의성을 생성할 수 없습니다.

Diffie-Hellman 계산이 비공개로 수행되는 경우에는 이것이 사실이지만 공개 키 중 하나를 관찰할 수 있고 사용되는 모듈러스를 알고 있는 적은 공유 키를 계산할 수 있도록 다른 비밀 키의 공간을 검색하기만 하면 됩니다. 비밀 \[D-H\]. 따라서 보수적으로 공개 Diffie-Hellman을 고려하여 추측 가능성이 두 입력 중 더 나쁜 것에 해당하는 수량을 생성하는 것이 가장 좋습니다. 이것과 Diffie-Hellman이 계산 집약적이라는 사실 때문에 믹싱 함수로 사용하는 것은 권장되지 않습니다.

---
### **5.5.  Using a Mixing Function to Stretch Random Bits**

믹싱 기능이 입력과 같거나 더 적은 출력 비트를 생성할 필요는 없지만 믹싱 비트는 입력에 존재하는 임의의 예측 불가능성을 "늘일" 수 없습니다. 따라서 각 입력에 12비트의 예측 불가능성\(예: 4,096개의 동일 확률 값\)이 있는 32비트의 4개 입력은 48비트 이상의 예측 불가능한 출력을 생성할 수 없습니다. 출력은 예를 들어 연속적인 정수와 혼합하여 수백 또는 수천 비트로 확장될 수 있지만 영리한 적의 검색 공간은 여전히 ​​2^48 가능성입니다. 또한 입력보다 적은 비트로 혼합하면 출력의 무작위성이 강화되는 경향이 있습니다.

섹션 5.1의 마지막 표에서는 배타적 논리합을 사용하여 임의 비트와 상수 비트를 혼합하면 임의 비트가 생성됨을 보여줍니다. 이것은 사실이지만 하나의 임의 비트를 둘 이상으로 "확장"하는 방법을 제공하지 않습니다. 예를 들어 임의의 비트가 0과 혼합된 다음 1과 혼합되면 2비트 시퀀스가 ​​생성되지만 항상 01 또는 10이 됩니다. 가능한 값이 2개뿐이므로 여전히 1비트만 있습니다. 원래 임의성.

---
### **5.6.  Other Factors in Choosing a Mixing Function**

로컬 사용의 경우 AES는 결함에 대해 광범위하게 테스트되었고 소프트웨어에서 합리적으로 효율적이며 오픈 소스 코드를 포함하여 전 세계에서 사용 가능한 하드웨어 및 소프트웨어 구현으로 광범위하게 문서화되고 구현된다는 이점이 있습니다. SHA\* 제품군은 연구가 조금 적고 AES보다 더 많은 CPU 주기를 요구하는 경향이 있지만 결함이 있다고 생각할 이유는 없습니다. SHA\*와 MD5는 모두 초기 MD4 알고리즘에서 파생되었습니다. 그들은 모두 사용 가능한 소스 코드를 가지고 있습니다\[SHA\*, MD4, MD5\]. MD4 및 MD5에서 약점의 일부 징후가 발견되었습니다. 특히 MD4는 3라운드만 있고 처음 2라운드 또는 마지막 2라운드의 독립적인 브레이크가 여러 개 있습니다. 그리고 MD5 출력에서 ​​일부 충돌이 발견되었습니다.

AES는 강력하고 공개적이며 국제적인 프로세스를 통해 선택되었습니다. 그것과 SHA\*는 DES와 마찬가지로 대부분 비밀로 유지되는 기준에 따라 미국 NSA\(National Security Agency\)에 의해 보증되었습니다. 이것이 많은 추측과 의심의 원인이 되었지만 수년 동안 DES를 조사한 결과 NSA가 IBM에서 시작된 디자인 수정에 개입한 것은 주로 DES를 강화하기 위한 것이었습니다. DES에서 숨겨진 또는 특별한 약점이 발견되었다는 발표는 없습니다. SHA 알고리즘을 생성하기 위한 MD4에 대한 NSA의 수정은 공개 암호화 커뮤니티에 아직 알려지지 않은 위협에 대해 이러한 알고리즘을 유사하게 강화했을 가능성이 있습니다.

입력 길이를 예측할 수 없는 경우 해시 알고리즘은 일반적으로 가변 길이 입력을 허용하도록 설계되었기 때문에 블록 암호화 알고리즘보다 사용하기 더 편리합니다. 블록 암호화 알고리즘은 일반적으로 블록 크기의 배수가 아닌 입력을 수용하기 위해 추가 패딩 알고리즘이 필요합니다.

이 문서 작성 시점을 기준으로 저자는 전 세계에 취소 불가능한 로열티 프리 라이선스가 부여된 특허 외에 기본 AES, DES, SHA\*, MD4 및 MD5 알고리즘에 대한 특허 청구를 알지 못합니다. 물론 저자가 알지 못하는 필수 특허 또는 구현 또는 사용에 대한 특허 또는 발행되었거나 발행될 기타 관련 특허가 있을 수 있습니다.

---
## **6.  Pseudo-random Number Generators**

시드가 충분한 엔트로피를 가지고 있을 때 섹션 3에 설명된 대로 입력에서 가능하고 섹션 4 및 5에 설명된 대로 왜곡 보정 및 혼합될 수 있는 경우 해당 시드를 알고리즘적으로 확장하여 많은 수의 암호학적으로 강력한 무작위 수량을 생성할 수 있습니다. 이러한 알고리즘은 플랫폼 독립적이며 모든 컴퓨터에서 동일한 방식으로 작동할 수 있습니다. 안전한 알고리즘을 위해서는 입력 및 내부 작동이 적대적 관찰로부터 보호되어야 합니다.

대칭 암호화 알고리즘의 설계와 같은 의사 난수 생성 알고리즘의 설계는 아마추어의 작업이 아닙니다. 아래 섹션 6.1에는 실패한 알고리즘이 사용한 여러 가지 나쁜 아이디어가 나열되어 있습니다. 작동 방식을 알아보려면 섹션 6.1을 건너뛰고 이 섹션의 나머지 부분과 몇 가지 표준 의사 난수 생성 알고리즘을 설명하고 참조하는 섹션 7을 읽으십시오. \[X9.82\]의 섹션 7 및 파트 3을 참조하십시오.

---
### **6.1.  Some Bad Ideas**

아래의 하위 섹션에서는 합리적으로 보일 수 있지만 안전하지 않은 의사 난수 생성으로 이어지는 여러 가지 아이디어를 설명합니다.

---
#### **6.1.1.  The Fallacy of Complex Manipulation**

```text
   One approach that may give a misleading appearance of
   unpredictability is to take a very complex algorithm (or an excellent
   traditional pseudo-random number generator with good statistical
   properties) and to calculate a cryptographic key by starting with
   limited data such as the computer system clock value as the seed.
   Adversaries who knew roughly when the generator was started would
   have a relatively small number of seed values to test, as they would
   know likely values of the system clock.  Large numbers of pseudo-
```

임의의 비트가 생성될 수 있지만 적이 확인해야 하는 검색 공간은 매우 작을 수 있습니다.

따라서 매우 강력하거나 복잡한 데이터 조작은 적이 조작이 무엇인지 알 수 있고 시작 시드 값에 엔트로피가 충분하지 않은 경우 도움이 되지 않습니다. 일반적으로 제한된 수의 시드 값에서 비롯된 제한된 수의 결과를 사용하여 보안을 무력화할 수 있습니다.

또 다른 심각한 전략적 오류는 알고리즘에 대한 이론이나 분석이 없을 때 매우 복잡한 의사 난수 생성 알고리즘이 강력한 난수를 생성한다고 가정하는 것입니다. 저자가 복잡한 알고리즘을 설명하는 \[KNUTH\]의 3장 시작 부분 근처에 이 오류의 훌륭한 예가 있습니다. 알고리즘에 해당하는 기계어 프로그램이 너무 복잡해서 주석 없이 코드를 읽으려는 사람이 프로그램이 무엇을 하고 있는지 알 수 없도록 의도한 것입니다. 안타깝게도 이 알고리즘을 실제로 사용하면 어떤 경우에는 단일 반복 값으로, 다른 경우에는 값의 작은 주기로 거의 즉시 수렴되는 것으로 나타났습니다.

```text
   Not only does complex manipulation not help you if you have a limited
   range of seeds, but blindly-chosen complex manipulation can destroy
   the entropy in a good seed!
```

---
#### **6.1.2.  The Fallacy of Selection from a Large Database**

예측할 수 없다는 오해를 불러일으킬 수 있는 또 다른 접근 방식은 데이터베이스에서 무작위로 수량을 선택하고 그 강도가 데이터베이스의 총 비트 수와 관련이 있다고 가정하는 것입니다. 예를 들어 일반적인 USENET 서버는 하루에 많은 메가바이트의 정보를 처리합니다\[USENET\_1, USENET\_2\]. 이 데이터의 임의 시작점에서 32바이트의 데이터를 가져와 임의의 수량을 선택했다고 가정합니다. 이것은 32\*8 = 256비트의 추측 불가능성을 산출하지 않습니다. 데이터의 대부분이 바이트당 2\~3비트의 정보만 포함하는 인간 언어인 경우에도 32\*2 = 64비트의 추측 불가능성은 생성되지 않습니다. 동일한 Usenet 데이터베이스에 액세스할 수 있는 적의 경우 추측 불가능성은 선택의 시작점에만 있습니다. 그것은 아마도 수십 비트가 조금 넘는 추측 불가능성일 것입니다.

공개적으로 사용 가능한 CD/DVD 레코딩 또는 기타 대규모 공개 데이터베이스의 데이터에서 시퀀스를 선택하는 데에도 동일한 주장이 적용됩니다. 적이 동일한 데이터베이스에 액세스할 수 있는 경우 이 "대량의 데이터에서 선택" 단계는 거의 구매하지 않습니다. 그러나 활성 다중 사용자 시스템의 시스템 버퍼와 같이 적이 액세스할 수 없는 데이터에서 선택할 수 있는 경우 도움이 될 수 있습니다.

---
#### **6.1.3.  Traditional Pseudo-random Sequences**

이 섹션에서는 결정적 또는 "의사 난수" 숫자의 전통적인 소스에 대해 설명합니다. 이들은 일반적으로 "종자" 수량으로 시작하고 간단한 숫자 또는 논리 연산을 사용하여 일련의 값을 생성합니다. 이 섹션에서 설명하는 기술 중 어느 것도 암호화 사용에 적합하지 않습니다. 일반적인 정보를 제공합니다.

\[KNUTH\]는 의사 난수에 대한 고전적인 설명을 제공합니다. 그가 언급한 응용 프로그램은 자연 현상의 시뮬레이션, 샘플링, 수치 분석, 컴퓨터 프로그램 테스트, 의사 결정 및 게임입니다. 이들 중 어느 것도 우리가 말하는 보안 용도와 동일한 특성을 가지고 있지 않습니다. 마지막 두 개에서만 임의의 수량을 찾으려는 적이 있을 수 있습니다. 그러나 이러한 경우 일반적으로 적은 추측된 값을 사용할 기회가 한 번뿐입니다. 암호를 추측하거나 암호화 체계를 깨려고 시도할 때 공격자는 일반적으로 올바른 값을 추측할 수 있는 많은, 아마도 무제한의 기회를 갖습니다. 때로는 적이 깨뜨릴 메시지를 저장하고 반복적으로 공격할 수 있습니다. 적들은 또한 컴퓨터의 도움을 받는 것으로 가정합니다.

숫자의 "무작위성"을 테스트하기 위해 Knuth는 통계 및 스펙트럼을 포함한 다양한 측정을 제안합니다. 이러한 테스트는 "무작위" 시퀀스의 서로 다른 부분 간의 자기 상관이나 해당 값의 분포와 같은 것을 확인합니다. 그러나 이러한 테스트는 CRC Standard Mathematical Tables\[CRC\]에 인쇄된 "무작위" 시퀀스와 같이 일정하게 저장된 무작위 시퀀스로 충족될 수 있습니다. Knuth가 제안한 모든 테스트를 충족했음에도 불구하고 해당 시퀀스는 우리를 암호화하는 데 적합하지 않습니다. 적이 일반적으로 게시된 모든 "무작위" 시퀀스의 복사본을 가지고 있고 소스를 발견하고 미래 값을 예측할 수 있다고 가정해야 하기 때문입니다.

일반적인 의사 난수 생성 기술은 선형 합동 의사 난수 생성기입니다. 이 기술은 N+1로 번호가 매겨진 값이 N으로 번호가 매겨진 값에서 계산되는 모듈식 산술을 사용합니다.

```text
        V    = ( V  * a + b )(Mod c)
         N+1      N
```

위의 기술은 암호학적으로 잘 이해되는 \[SHIFT\*\] 선형 시프트 레지스터 의사 난수 생성기와 강한 관계가 있습니다. 이러한 생성기에서 비트는 선택한 고정 탭에서 레지스터로의 비트의 Exclusive Or\(캐리 없는 이진 합계\)로서 시프트 레지스터의 한쪽 끝에서 도입됩니다. 예를 들어 다음을 고려하십시오.

```text
      +----+     +----+     +----+                      +----+
      | B  | <-- | B  | <-- | B  | <--  . . . . . . <-- | B  | <-+
      |  0 |     |  1 |     |  2 |                      |  n |   |
      +----+     +----+     +----+                      +----+   |
        |                     |            |                     |
        |                     |            V                  +-----+
        |                     V            +----------------> |     |
        V                     +-----------------------------> | XOR |
        +---------------------------------------------------> |     |
                                                              +-----+

       V    = ( ( V  * 2 ) + B  XOR  B ... )(Mod 2^n)
        N+1         N         0       2
```

기존 의사 난수 생성기 알고리즘의 품질은 이러한 시퀀스에 대한 통계 테스트를 통해 측정됩니다. 신중하게 선택한 값 a, b, c 및 초기 V 또는 위의 간단한 프로세스에서 신중하게 선택한 시프트 레지스터 탭 배치는 우수한 통계를 생성할 수 있습니다.

이러한 시퀀스는 시퀀스가 ​​탐색 중인 공간의 구조와 직교하는 한 시뮬레이션\(Monte Carlo 실험\)에 적합할 수 있습니다. 거기에서도 미묘한 패턴이 문제를 일으킬 수 있습니다. 그러나 이러한 시퀀스는 보안 응용 프로그램에서 사용하기에 분명히 좋지 않습니다. 초기 상태를 알면 완전히 예측 가능합니다. 의사 난수 생성기의 형태에 따라 시퀀스는 \[SCHNEIER, STERN\] 시퀀스의 짧은 부분을 관찰하여 결정될 수 있습니다. 예를 들어 위의 생성기를 사용하면 V\(n\)에 대한 지식이 주어지면 V\(n+1\)을 결정할 수 있습니다. 실제로 이러한 기술을 사용하면 의사 난수 값의 1비트만 해제되더라도 짧은 시퀀스에서 시드를 결정할 수 있음이 나타났습니다.

선형 합동 생성기가 깨졌을 뿐만 아니라 이제 모든 다항식 합동 생성기를 깨는 기술이 알려져 있습니다\[KRAWCZYK\].

---
### **6.2.  Cryptographically Strong Sequences**

일련의 무작위 수량을 생성해야 하는 경우 적이 시퀀스에서 일부 값을 학습할 수 있습니다. 일반적으로 공격자는 자신이 알고 있는 값에서 다른 값을 예측할 수 없어야 합니다.

올바른 기술은 강력한 임의 시드에서 시작하여 해당 시드\[FERGUSON, SCHNEIER\]에서 암호학적으로 강력한 단계를 수행하고 시퀀스 요소에서 생성기의 전체 상태를 공개하지 않는 것입니다. 시퀀스의 각 값을 고정된 값으로 계산할 수 있는 경우

이전 가치에서 벗어나 가치가 손상되면 모든 미래 가치를 결정할 수 있습니다. 예를 들어 각 값이 이전에 사용된 값의 상수 함수인 경우 함수가 매우 강력하고 반전할 수 없는 메시지 다이제스트 함수인 경우에도 마찬가지입니다.

\(키 값의 시퀀스를 생성하는 기술이 충분히 빠르다면 기밀 시스템의 기초로 사소하게 사용될 수 있습니다. 두 당사자가 동일한 시퀀스 생성 기술을 사용하고 동일한 시드 자료로 시작하면 예를 들어, XOR 연산의 가역 속성으로 인해 암호화를 위해 전송되는 데이터와 함께 한쪽 끝에서 XOR'되고 해독을 위해 수신된 이 데이터와 XOR'될 수 있습니다. 간단한 스트림 암호라고 합니다.\)

---
#### **6.2.1.  OFB and CTR Sequences**

강력한 시퀀스를 생성하는 한 가지 방법은 시드 값을 가져오고 시드를 연속적인 정수 등과 연결하여 생성된 양을 해시한 다음 얻은 값을 마스킹하여 적이 사용할 수 있는 생성기 상태의 양을 제한하는 것입니다. .

카운터\(CTR\) 모드 암호화에서와 같이 연속적인 정수를 암호화하기 위해 무작위 키 및 시드 값과 함께 "암호화" 알고리즘을 사용하는 것도 가능할 수 있습니다. 또는 암호화의 모든 출력 값을 다음 반복을 위해 암호화할 값으로 피드백할 수 있습니다. 이것은 출력 피드백 모드\(OFB\) \[MODES\]의 특정 예입니다.

출력 피드백의 일부를 이전 입력의 일부와 결합하기 위해 이동 및 마스킹이 사용되는 예가 아래에 나와 있습니다. 이러한 유형의 부분 피드백은 아래에 설명된 이유로 피해야 합니다.

```text
            +---------------+
            |       V       |
            |  |     n      |--+
            +--+------------+  |
                  |            |     +---------+
             shift|            +---> |         |      +-----+
               +--+                  | Encrypt | <--- | Key |
               |           +-------- |         |      +-----+
               |           |         +---------+
               V           V
            +------------+--+
            |      V     |  |
            |       n+1     |
            +---------------+
```

1의 시프트가 사용되는 경우 이것은 섹션 6.1.3에 설명된 시프트 레지스터 기술과 동일하지만 피드백이 모든 비트의 복잡한 비선형 함수에 의해 결정된다는 가장 중요한 차이점이 있습니다. 몇 비트 위치 탭에서 출력의 간단한 선형 또는 다항식 조합으로.

```text
   Donald W. Davies showed that this sort of shifted partial output
   feedback significantly weakens an algorithm, compared to feeding all
   the output bits back as input.  In particular, for DES, repeatedly
   encrypting a full 64-bit quantity will give an expected repeat in
   about 2^63 iterations.  Feeding back anything less than 64 (and more
   than 0) bits will give an expected repeat in between 2^31 and 2^32
   iterations!
```

이러한 기술로 시퀀스가 ​​생성되었을 때 다른 시퀀스의 값을 예측하는 것은 암호 시스템을 깨거나 부분적인 정보만 사용하여 "가역 불가능" 해싱을 뒤집는 것과 같습니다. 각 반복에서 공개되는 정보가 적을수록 적이 시퀀스를 예측하기가 더 어려워집니다. 따라서 각 값에서 한 비트만 사용하는 것이 가장 좋습니다. 경우에 따라서는 암호화 시스템이 가역적일 때에도 시스템을 깨뜨리는 것이 불가능하고 각 생성 값이 모두 밝혀지면 깨질 수 있음을 보여주었습니다.

---
#### **6.2.2.  The Blum Blum Shub Sequence Generator**

현재 가장 강력한 대중적 증거가 있는 발전기는 Blum Blum Shub 발전기라고 하며 발명가의 이름을 따서 명명되었습니다\[BBS\]. 그것은 또한 매우 간단하고 2차 나머지를 기반으로 합니다. 유일한 단점은 섹션 6.1.3에 제공된 전통적인 기술과 비교하여 계산 집약적이라는 것입니다. 세션 키 생성과 같이 드물게 사용되는 용도로 사용되는 경우 이는 큰 단점이 아닙니다.

4로 나누었을 때 나머지가 3인 두 개의 큰 소수\(예: p 및 q\)를 선택하기만 하면 됩니다. n = p \* q라고 합니다. 그런 다음 상대적으로 n보다 소수인 난수 x를 선택합니다. 생성기의 초기 시드와 후속 값을 계산하는 방법은 다음과 같습니다.

```text
                    2
         s    =  ( x  )(Mod n)
          0
                    2
         s    = ( s   )(Mod n)
          i+1      i
```

각 의 하단에서 몇 비트만 사용하도록 주의하십시오. 최하위 비트만 사용하는 것이 항상 안전합니다. 다음 이상을 사용하지 않는 경우:

```text
         log  ( log  ( s  ) )
            2      2    i
```

하위 비트, 그런 다음 이러한 방식으로 생성된 시퀀스에서 추가 비트를 예측하는 것은 n을 분해하는 것만큼 어렵습니다. 초기 x가 비밀이면 원하는 경우 n을 공개할 수 있습니다.

이 생성기의 흥미로운 특징은 s 값을 직접 계산할 수 있다는 것입니다. 특히,

```text
               ( (2^i) (Mod ((p-1)*(q-1)) ) )
      s  = ( s                                )(Mod n)
       i      0
```

즉, 이러한 방식으로 많은 키가 생성되는 응용 프로그램에서는 키를 모두 저장할 필요가 없습니다. 각 키는 작은 색인과 초기 s 및 n에서 효과적으로 색인화되고 복구될 수 있습니다.

---
### **6.3.  Entropy Pool Techniques**

섹션 7.1.2 및 7.1.3에 설명된 것과 같은 많은 현대 의사 난수 소스는 비트의 "풀"을 유지하는 기술을 활용하고 입력을 일부 임의성과 함께 풀에 강력하게 혼합하고 의사 난수를 추출하는 작업을 제공합니다. 풀에서 비트. 이것은 아래 그림에 설명되어 있습니다.

```text
             +--------+    +------+    +---------+
         --->| Mix In |--->| POOL |--->| Extract |--->
             |  Bits  |    |      |    |   Bits  |
             +--------+    +------+    +---------+
                               ^           V
                               |           |
                               +-----------+
```

풀에 공급되는 비트는 위에서 설명한 다양한 하드웨어, 환경 또는 사용자 입력 소스에서 나올 수 있습니다. 또한 시스템 종료 시 풀의 상태를 저장하고 안정적인 스토리지를 사용할 수 있을 때 다시 시작할 때 복원하는 것이 일반적입니다.

원하는 특정 출력 사용을 지원하기 위해 충분한 엔트로피가 풀에 추가되었는지 주의해야 합니다. 유사한 제안에 대해서는 \[RSA\_BULL1\]을 참조하십시오.

---
## **7.  Randomness Generation Examples and Standards**

이제 키 또는 기타 암호화된 임의 수량의 생성을 위해 몇 가지 공개 표준과 널리 배포된 예가 있습니다. 섹션 7.1의 일부에는 엔트로피 소스가 포함되어 있습니다. 섹션 7.2에 설명된 다른 것들은 의사 난수 강 시퀀스 생성기를 제공하지만 임의 시드의 입력 또는 엔트로피 소스의 입력을 가정합니다.

---
### **7.1.  Complete Randomness Generators**

세 가지 표준이 아래에 설명되어 있습니다. 두 개의 이전 표준은 64비트 블록 및 키 크기 제한이 있는 DES를 사용하지만 동등하거나 더 강력한 혼합 기능은 \[DES\]로 대체될 수 있습니다. 세 번째는 SHA-1\[SHA\*\]에 기반한 보다 현대적이고 강력한 표준입니다. 마지막으로 널리 배포된 최신 UNIX 및 Windows 난수 생성기에 대해 설명합니다.

---
#### **7.1.1.  US DoD Recommendations for Password Generation**

미국 국방부는 암호 생성\[DoD\]에 대한 구체적인 권장 사항을 가지고 있습니다. 다음과 같이 출력 피드백 모드\[MODES\]에서 미국 데이터 암호화 표준\[DES\]을 사용할 것을 제안합니다.

에서 결정된 초기화 벡터를 사용합니다.

- 시스템 시계, 시스템 ID, 사용자 ID, 날짜 및 시간 시스템 인터럽트 레지스터, 시스템 상태 레지스터 및 시스템 카운터에서 결정된 키를 사용합니다. 일반 텍스트로 시스템 관리자가 입력한 8자의 ASCII 바이트와 같이 무작위로 생성된 외부 64비트 수량을 사용합니다.

그런 다음 64비트 출력 피드백 모드에서 DES가 생성한 64비트 "암호 텍스트"에서 암호를 계산할 수 있습니다. 사람이 암호를 기억해야 하는 경우 이 64비트에서 필요한 만큼의 비트를 가져와 발음 가능한 단어, 구 또는 기타 형식으로 확장할 수 있습니다.

---
#### **7.1.2.  The /dev/random Device**

UNIX 운영 체제의 여러 버전은 커널 상주 난수 생성기를 제공합니다. 이러한 생성기 중 일부는 정상적인 시스템 작동 중에 커널이 캡처한 이벤트를 사용합니다.

예를 들어 일부 Linux 버전에서 생성기는 각각 4바이트의 128개 단어로 표시되는 512바이트의 임의 풀로 구성됩니다. 디스크 드라이브 인터럽트와 같은 이벤트가 발생하면 이벤트 시간이 풀에 XOR'되고 풀은 기본 다항식 128을 통해 교반됩니다. 풀 자체는 링 버퍼로 처리되며 새 전체 풀에서 데이터가 XOR'ed\(다항식으로 교반한 후\)됩니다.

풀에 엔트로피를 추가하는 각 호출은 입력에 포함될 가능성이 있는 실제 엔트로피의 양을 추정합니다. 풀 자체에는 풀의 모든 엔트로피에 대한 합계를 추정하는 누산기가 포함되어 있습니다.

입력 이벤트는 아래 나열된 여러 소스에서 가져옵니다. 불행히도 인간 운영자가 없는 서버 시스템의 경우 첫 번째와 세 번째를 사용할 수 없으며 이 경우 엔트로피가 느리게 추가될 수 있습니다.

1. 키보드 인터럽트. 인터럽트 시간과 스캔 코드가 풀에 추가됩니다. 이는 실제로 키 입력 간 도달 시간을 측정하여 인간 조작자의 엔트로피를 추가합니다.

2. 디스크 완료 및 기타 인터럽트. 사람이 사용하는 시스템에는 예측하기 어려운 디스크 패턴이 있을 수 있습니다.

- 액세스합니다. \(그러나 모든 디스크 드라이버가 이 타이밍 정보를 유용하기에 충분한 정확도로 캡처하는 것을 지원하는 것은 아닙니다.\)

3. 마우스 동작. 타이밍과 마우스 위치가 추가됩니다.

임의 바이트가 필요한 경우 풀은 SHA-1\[SHA\*\]로 해시되어 반환된 임의 바이트를 생성합니다. SHA-1의 출력\(20바이트\)보다 더 많은 바이트가 필요한 경우 해시된 출력이 풀로 다시 교반되고 다음 20바이트를 얻기 위해 새 해시가 수행됩니다. 풀에서 바이트가 제거되면 그에 따라 엔트로피 추정치가 감소합니다.

시스템 시작 시 합리적인 임의 풀을 보장하기 위해 표준 시작 및 종료 스크립트는 종료 시 풀을 디스크 파일에 저장하고 시스템 시작 시 이 파일을 읽습니다.

두 개의 사용자 내보내기 인터페이스가 있습니다. /dev/random은 풀에서 바이트를 반환하지만 예상 엔트로피가 0으로 떨어지면 차단됩니다. 이벤트에서 풀에 엔트로피가 추가되면 /dev/random을 통해 더 많은 데이터를 사용할 수 있습니다. 이러한 /dev/random 장치에서 얻은 임의 데이터는 풀에 충분한 임의 비트가 있거나 적절한 시간 내에 추가된 경우 장기 키에 대한 키 생성에 적합합니다.

/dev/urandom은 /dev/random처럼 작동합니다. 그러나 랜덤 풀에 대한 엔트로피 추정치가 0으로 떨어지는 경우에도 데이터를 제공합니다. 이는 세션 키 또는 더 많은 임의 비트를 기다리기 위한 차단이 허용되지 않는 기타 키 생성 작업에 적합할 수 있습니다. 공격자가 SHA-1을 되돌릴 수 있는 경우 과거 출력이 현재 출력에서 ​​계산될 수 있다는 점에서 풀의 엔트로피 추정치가 작은 경우에도 데이터를 계속 가져올 위험이 있습니다. SHA-1이 비가역적으로 설계되었다는 점을 감안할 때 이것은 합리적인 위험입니다.

Linux, Solaris 또는 위에서 설명한 코드가 있는 기타 UNIX 시스템에서 난수를 얻으려면 응용 프로그램에서 /dev/random 또는 /dev/urandom을 열고 원하는 바이트 수를 읽기만 하면 됩니다.

\(Linux Random 장치는 Theodore Ts'o가 작성했습니다. PGP 2.X 및 PGP 3.0\(일명 PGP 5.0\)의 난수 생성기를 기반으로 합니다.\)

---
#### **7.1.3.  Windows CryptGenRandom**

널리 배포된 Windows 운영 체제 사용자에 대한 Microsoft의 권장 사항은 일반적으로 CryptAPI 암호화 서비스 공급자와 함께 CryptGenRandom 의사 난수 생성 호출을 사용하는 것입니다. 이것은 암호화 서비스 공급자에 대한 핸들을 취합니다.

라이브러리, 호출자가 엔트로피를 제공할 수 있고 생성된 유사 무작위성이 반환되는 버퍼에 대한 포인터, 원하는 무작위 옥텟 수에 대한 표시.

Windows CryptAPI 암호화 서비스 공급자는 모든 사용자와 함께 시드 상태 변수를 저장합니다. CryptGenRandom이 호출되면 호출에 제공된 임의성과 프로세스 ID, 스레드 ID, 시스템 시계, 시스템 시간, 시스템 카운터, 메모리 상태, 사용 가능한 디스크 클러스터 및 해시된 사용자와 같은 다양한 시스템 및 사용자 데이터와 결합됩니다. 환경 블록. 이 데이터는 모두 SHA-1에 공급되며 출력은 RC4 키 스트림을 시드하는 데 사용됩니다. 해당 키 스트림은 요청된 의사 난수 데이터를 생성하고 사용자의 시드 상태 변수를 업데이트하는 데 사용됩니다.

Windows ".NET" 사용자는 아마도 RNGCryptoServiceProvider.GetBytes 메서드 인터페이스를 사용하는 것이 더 쉬울 것입니다.

자세한 내용은 \[WSC\]를 참조하십시오.

---
### **7.2.  Generators Assuming a Source of Entropy**

다음 세 섹션에서 설명하는 의사 난수 생성기는 모두 엔트로피가 충분한 시드 값이 제공된다고 가정합니다. 그런 다음 해당 시드에서 강력한 시퀀스\(섹션 6.2 참조\)를 생성합니다.

---
#### **7.2.1.  X9.82 Pseudo-Random Number Generation**

ANSI X9F1 위원회는 실제 난수 생성기와 의사 난수 생성기를 모두 포함하는 난수 생성 표준을 만드는 마지막 단계에 있습니다. 여기에는 해시 함수를 기반으로 하는 여러 의사 난수 생성기가 포함되며 그 중 하나는 아마도 HMAC SHA 해시 구조\[RFC2104\]를 기반으로 할 것입니다. 이 생성기의 초안 버전은 아래에 설명되어 있으며 여러 옵션 기능이 생략되어 있습니다\[X9.82\].

아래 하위 섹션에서 HMAC 해시 구성은 단순히 HMAC라고 하지만 물론 특정 용도에서는 특정 표준 SHA 함수를 선택해야 합니다. 일반적으로 생성할 의사 난수 값의 강도가 N 비트인 경우 선택한 SHA 함수는 N 비트 이상의 출력을 생성해야 하며 입력 엔트로피의 최소 N 비트 소스가 필요합니다. 이 생성기의 인스턴스화 전체에서 동일한 해시 함수를 사용해야 합니다.

---
##### **7.2.1.1.  Notation**

다음 섹션에서는 아래와 같은 표기법이 사용됩니다.

- hash\_length는 사용 중인 기본 해시 함수의 출력 크기입니다.

- input\_entropy는 생성기에 엔트로피를 제공하는 입력 비트 문자열입니다.

- K는 생성기 상태의 일부이며 임의의 비트가 생성될 때마다 적어도 한 번 업데이트되는 크기 hash\_length의 비트 문자열입니다.

- V는 hash\_length 크기의 비트열이며 생성기 상태의 일부입니다. 출력의 hash\_length 비트가 생성될 때마다 업데이트됩니다.

```text
      "|" represents concatenation.
```

---
##### **7.2.1.2.  Initializing the Generator**

각 바이트의 하위 비트가 1로 설정된 경우를 제외하고 V를 모두 0바이트로 설정합니다.

K를 모두 0바이트로 설정한 후 다음을 설정합니다.

```text
         K = HMAC ( K, V | 0x00 | input_entropy )

         V = HMAC ( K, V )

         K = HMAC ( K, V | 0x01 | input_entropy )

         V = HMAC ( K, V )
```

참고: 모든 SHA 알고리즘은 정수 바이트를 생성하므로 K와 V의 길이는 정수 바이트가 됩니다.

---
##### **7.2.1.3.  Generating Random Bits**

출력이 필요한 경우 다음을 설정하기만 하면 됩니다.

```text
         V = HMAC ( K, V )
```

V의 선행 비트를 사용합니다. V의 길이보다 더 많은 비트가 필요한 경우 "temp"를 널 비트 문자열로 설정한 다음 반복적으로 수행합니다.

```text
         V = HMAC ( K, V )
         temp = temp | V
```

temp가 요청된 임의의 비트 수보다 크거나 같으면 중지합니다. temp에서 요청된 선행 비트 수를 사용합니다. 알고리즘의 정의는 2^35비트보다 많은 요청을 금지합니다.

위에서 설명한 대로 의사 난수 출력 비트를 추출하고 저장한 후 반환하기 전에 다음과 같이 HMAC를 두 번 더 수행해야 합니다.

```text
         K = HMAC ( K, V | 0x00 )
         V = HMAC ( K, V )
```

---
#### **7.2.2.  X9.17 Key Generation**

- American National Standards Institute는 \[X9.17\] 키 시퀀스를 생성하기 위해 다음과 같은 방법을 지정했습니다.

s는 초기 64비트 시드입니다.

- 0

g는 생성된 64비트 키 수량의 시퀀스입니다.

-   N

- k는 이 키 시퀀스를 생성하기 위해 예약된 임의의 키입니다.

- t는 키가 생성되는 시간으로 가능한 한 세밀한 해상도\(최대 64비트\)입니다.

- DES\(K,Q\)는 키 K를 사용하여 수량 Q의 DES 암호화입니다.

```text
   Then:

         g    = DES ( k, DES ( k, t ) XOR s  )
          n                                n

         s    = DES ( k, DES ( k, t ) XOR  g  )
          n+1                               n
```

g sub n을 DES 키로 사용하려면 매 8비트마다 해당 용도의 패리티를 조정해야 하지만 수정되지 않은 전체 64비트 g는 다음 s를 계산하는 데 사용해야 합니다.

---
#### **7.2.3.  DSS Pseudo-random Number Generation**

NIST 디지털 서명 표준\[DSS\]의 부록 3은 개인 키 등으로 사용하기 위한 일련의 의사 난수 160비트 수량을 생성하는 방법을 제공합니다. 범용 유사 난수 생성을 위한 다음 알고리즘을 생성하기 위해 변경 공지 1 \[DSS\_CN1\]에 의해 수정되었습니다.

```text
         t = 0x 67452301 EFCDAB89 98BADCFE 10325476 C3D2E1F0

         XKEY  = initial seed
             0

         For j = 0 to ...

             XVAL = ( XKEY  + optional user input ) (Mod 2^512)
                          j

             X  = G( t, XVAL )
              j

             XKEY   = ( 1 + XKEY  + X  ) (Mod 2^512)
                 j+1            j    j
```

이렇게 생성된 수량 X는 160비트 값의 의사 난수 시퀀스입니다. 위의 "G"에 대해 두 가지 기능을 사용할 수 있습니다. 각각은 160비트 값을 생성하고 160비트 값과 512비트 값의 두 인수를 사용합니다.

첫 번째는 SHA-1을 기반으로 하며 SHA-1 사양에서 아래 첨자가 있는 H로 표시되는 5개의 연결 변수를 5분의 1로 나눈 첫 번째 인수로 설정하여 작동합니다. 그런 다음 NIST SHA-1 사양 섹션 7의 \(a\) \~ \(e\) 단계가 512비트 데이터 블록인 것처럼 두 번째 인수에 대해 실행됩니다. 그런 다음 해당 단계 후 연결 변수의 값을 연결하여 G \[SHA\*\]의 출력을 생성합니다.

대체 방법으로 NIST는 또한 DES 암호화 기능\[DSS\]의 여러 응용 프로그램을 기반으로 대체 G 기능을 정의했습니다.

---
## **8.  Examples of Randomness Required**

다음은 보안에 필요한 무작위성의 대략적인 계산을 보여주는 두 가지 예입니다. 첫 번째는 보통 수준의 보안 암호용이고 두 번째는 매우 높은 수준의 보안 암호화 키가 필요하다고 가정합니다.

또한 \[ORMAN\] 및 \[RSA\_BULL13\]은 대칭 키 교환에 사용해야 하는 공개 키 길이에 대한 정보를 제공합니다.

---
### **8.1.  Password Generation**

사용자 암호가 1년에 한 번 변경되고 공격자가 특정 계정의 암호를 추측할 수 있는 확률이 1/1000 미만인 것이 바람직하다고 가정합니다. 또한 시스템에 암호를 보내는 것이 암호를 시도하는 유일한 방법이라고 가정합니다. 그렇다면 중요한 질문은 적이 얼마나 자주 가능성을 시도할 수 있는지입니다. 공격자가 6초마다 최대 하나의 암호를 시도하도록 시스템에 지연이 도입되었다고 가정합니다. 그것은 시간당 600번, 하루에 약 15,000번 또는 1년에 약 5,000,000번의 시도입니다. 어떤 종류의 모니터링을 가정한다면 실제로 누군가가 1년 동안 지속적으로 시도할 수 있을 것 같지 않습니다. 로그 파일을 월별로 확인하더라도 공격이 감지되기 ​​전에 500,000번의 시도가 더 그럴듯하고 암호를 변경하고 더 많은 암호를 시도하기 어렵게 만드는 조치가 취해집니다.

500,000번의 시도에서 암호를 추측할 확률이 1/1000이라는 것은 최소 500,000,000개의 암호 또는 약 2^29의 우주를 의미합니다. 따라서 29비트의 임의성이 필요합니다. 비밀번호 생성을 위해 US DoD 권장 입력을 사용하여 달성할 수 있습니다. 각 입력은 평균 5비트 이상인 8개의 입력이 있기 때문입니다\(섹션 7.1 참조\). 1,000개의 단어 목록을 사용하여 암호는 3단어 구로 표현할 수 있습니다\(1,000,000,000 가능성\). 대소문자를 구분하지 않는 문자와 숫자를 사용하면 6자로 충분합니다\(\(26+10\)^6 = 2,176,782,336 가능성\).

보안 수준이 높은 암호의 경우 필요한 비트 수가 증가합니다. 확률을 1,000으로 줄이려면 동일한 요소만큼 암호의 범위를 늘려야 하며, 이는 약 10비트를 추가합니다. 따라서 위의 시나리오에서 암호를 추측할 확률이 100만 분의 1에 불과하려면 39비트의 임의성과 1,000단어 목록의 4단어 구문 또는 8개의 문자/숫자 암호가 필요합니다. 1/10^9의 기회를 얻으려면 49비트의 임의성이 필요하며, 이는 5단어 구 또는 10자/숫자 암호를 의미합니다.

물론 실제 시스템에는 다른 요소가 있습니다. 예를 들어, 암호가 크고 기억하기 어려울수록 사용자가 암호를 적어두려고 할 가능성이 높아져 추가적인 손상 위험이 있습니다.

---
### **8.2.  A Very High Security Cryptographic Key**

두 당사자 간의 대칭 암호화/암호 해독에 매우 높은 보안 키가 필요하다고 가정합니다. 또한 적이 통신을 관찰할 수 있고 사용 중인 알고리즘을 알고 있다고 가정합니다. 무작위 가능성의 영역 내에서 공격자는 사용 중인 값을 찾기 위해 키 값을 시도할 수 있습니다. 더 나아가 키의 무차별 대입 시도가 적이 할 수 있는 최선이라고 가정합니다.

---
#### **8.2.1.  Effort per Key Trial**

각 키를 시도하는 데 얼마나 많은 노력이 필요합니까? 보안 수준이 매우 높은 애플리케이션의 경우 노력의 가치가 낮다고 가정하는 것이 가장 좋습니다. 단일 키를 시도하는 데 분명히 수만 번의 컴퓨터 주기 이상이 걸리더라도 키당 훨씬 적은 노력으로 거대한 키 값 블록을 테스트할 수 있는 패턴이 있을 수 있습니다. 따라서 키당 200주기 이하로 가정하는 것이 가장 좋습니다. \(컴퓨터가 여러 비트에서 병렬로 작동하고 열악한 암호화 알고리즘으로 많은 키 또는 키 그룹을 병렬로 테스트할 수 있기 때문에 이에 대한 명확한 하한선은 없습니다. 그러나 우리는 어떤 값을 가정해야 하며 가상의 높은 보안 작업을 위해 합리적으로 강력한 알고리즘이 선택되기를 바랍니다.\)

적이 고도로 병렬화된 프로세서나 대규모 워크스테이션 네트워크를 지휘할 수 있다면 오늘날 초당 10^11 사이클은 아마도 최소 가정일 것입니다. 앞으로 몇 년을 내다보면 최소한 10배 이상의 개선이 있어야 합니다. 따라서 초당 10^10개의 키, 시간당 3.6\*10^12 또는 주당 6\*10^14 또는 월 2.4\*10^15의 키를 확인할 수 있다고 가정하는 것이 합리적입니다. 이는 한 달 안에 키를 찾을 수 없도록 최소 63비트의 키 임의성이 필요함을 의미합니다. 그럼에도 불구하고 지금부터 몇 년 후에 매우 단호하고 수완이 풍부한 적이 2주 안에 열쇠를 깨뜨릴 수 있습니다. 평균적으로 키의 절반만 시도하면 됩니다.

이러한 질문은 Business Software Alliance에서 후원한 "적절한 상용 보안을 제공하기 위한 대칭 암호의 최소 키 길이: 암호 작성자 및 컴퓨터 과학자의 Ad Hoc 그룹에 의한 보고서"\[KeyStudy\]에서 자세히 고려됩니다. 1995년에 매우 높은 보안을 위한 합리적인 키 길이는 75\~90비트 범위이며 암호화 비용이 키 크기에 따라 크게 달라지지 않기 때문에 90비트를 권장합니다. 이러한 권장 사항을 업데이트하려면 무어의 법칙\[MOORE\]에 대해 연간 비트의 2/3만 추가하면 됩니다. 이는 2004년에 합리적인 키 길이가 81\~96비트 범위에 있다는 결정으로 해석됩니다. 실제로 오늘날에는 96보다 긴 키를 사용하는 것이 점점 일반화되고 있습니다.

AES가 있는 128비트\(또는 그 이상\) 키 및 트리플 DES가 있는 유효 길이가 112비트인 키와 같은 비트.

---
#### **8.2.2.  Meet-in-the-Middle Attacks**

선택되었거나 알려진 일반 텍스트와 결과 암호화된 텍스트를 사용할 수 있는 경우 암호화 알고리즘의 구조에서 허용하는 경우 "meet-in-the-middle" 공격이 가능합니다. \(알려진 일반 텍스트 공격에서 공격자는 암호화되는 메시지의 전체 또는 일부\(아마도 일부 표준 헤더 또는 트레일러 필드\)를 알고 있습니다. 선택된 일반 텍스트 공격에서 공격자는 선택한 일반 텍스트를 다음과 같이 강제로 암호화할 수 있습니다. 텍스트가 너무 재미있기 때문에 암호화된 채널을 통해 공격자가 보낸 흥미로운 텍스트를 "유출"합니다.

다음은 중간 만남 공격에 대한 지나치게 단순화된 설명입니다. 공격자는 알려진 또는 선택된 일반 텍스트를 가능한 모든 첫 번째 절반 키로 반 암호화하고 출력을 정렬한 다음 다음을 사용하여 인코딩된 텍스트를 반 해독할 수 있습니다. 모든 두 번째 하프 키. 일치하는 항목이 발견되면 절반에서 전체 키를 조합하여 메시지 또는 다른 메시지의 다른 부분을 해독하는 데 사용할 수 있습니다. 최선의 경우 이러한 유형의 공격은 적에게 필요한 작업 지수를 절반으로 줄이면서 매우 크지만 거의 일정한 노력 요소를 추가할 수 있습니다. 따라서 이 공격을 탑재할 수 있다면 \[KeyStudy\] 분석에 따르면 2004년에는 매우 강력한 키의 임의성 양을 두 배로 최소 192비트\(96\*2\)로 늘려야 합니다.

이 정도의 무작위성은 US DoD에서 암호 생성을 위해 권장하는 입력의 한계를 훨씬 넘어서며 사용자 입력 타이밍, 하드웨어 난수 생성 또는 기타 임의성 소스가 필요할 수 있습니다.

Meet-in-the-middle 공격은 암호화 알고리즘이 이러한 방식으로 분해될 수 있다고 가정합니다. 어떤 최신 알고리즘에도 이러한 약점이 없기를 바라지만, 우리가 확신하지 못하는 경우나 키가 어떤 알고리즘과 함께 사용될지도 모르는 경우가 있을 수 있습니다. 기본 알고리즘이 중간자 공격의 대상이 아니더라도 기본 알고리즘을 서로 다른 키로 두 번\(또는 두 개의 서로 다른 알고리즘을 순차적으로\) 적용하여 더 강력한 알고리즘을 생성하려는 시도는 보안이 덜 강화됩니다. 예상되는. 이러한 복합 알고리즘은 중간자 공격의 대상이 됩니다.

중간자 공격을 수행하려면 막대한 자원이 필요할 수 있지만 아마도 주요 국가의 국가 안보 서비스 범위 내에 있을 것입니다. 기본적으로 모든 국가는 다른 국가의 트래픽을 감시합니다.

---
#### **8.2.3.  Other Considerations**

\[KeyStudy\]는 또한 특수 목적의 코드 해독 하드웨어의 가능성과 적절한 안전 마진을 고려합니다.

위와 같은 키 길이 계산은 논란의 여지가 있으며 사용 중인 암호화 알고리즘에 대한 다양한 가정에 따라 달라집니다. 어떤 경우에는 알고리즘 파괴 기술과 사용 중인 알고리즘의 강점에 대한 깊은 지식을 가진 전문가가 위에서 도출한 192비트 키 크기의 절반 미만으로도 만족할 수 있습니다.

보수적 설계 원칙의 추가 예는 \[FERGUSON\]을 참조하십시오.

---
## **9.  Conclusion**

보안 사용을 위해 추측할 수 없는 "무작위" 비밀 수량을 생성하는 것은 필수적이지만 어려운 작업입니다.

필요한 엔트로피를 생성하는 하드웨어 기술은 비교적 간단합니다. 특히 음량과 음질이 높을 필요가 없으며 오디오 입력이나 디스크 드라이브와 같은 기존 컴퓨터 하드웨어를 사용할 수 있습니다.

널리 사용되는 계산 기술은 여러 소스의 저품질 임의 수량 또는 한 소스의 대량의 저품질 입력을 처리하여 더 적은 양의 고품질 키 자료를 생성할 수 있습니다. 임의의 하드웨어 소스가 없는 경우 다양한 사용자 및 소프트웨어 소스를 주의해서 대신 사용할 수 있습니다. 그러나 대부분의 최신 시스템에는 고품질 무작위성을 생성하는 데 사용할 수 있는 디스크 드라이브 또는 오디오 입력과 같은 하드웨어가 이미 있습니다.

충분한 양의 고품질 시드 키 자료\(수백 비트\)를 사용할 수 있게 되면 이 시드 자료에서 계산적으로 예측할 수 없는 양의 암호학적으로 강력한 시퀀스를 생성하는 계산 기술을 사용할 수 있습니다.

---
## **10.  Security Considerations**

이 문서 전체는 암호, 암호화 키, 초기화 벡터, 시퀀스 번호 및 유사한 보안 응용 프로그램으로 사용하기 위해 예측할 수 없는 "무작위" 수량을 생성하기 위한 기술 및 권장 사항에 관한 것입니다.

---
## **11.  Acknowledgements**

광범위한 논평을 해준 Paul Hoffman과 John Kelsey와 그의 논문 "Software Generation of Practically Strong Random Numbers"의 자료 통합을 허용한 Peter Gutmann에게 특별히 감사드립니다.

다음 사람들\(알파벳순\)이 이 문서에 크게 기여했습니다.

- Steve Bellovin, Daniel Brown, Don Davis, Peter Gutmann, Tony Hansen, Sandy Harris, Paul Hoffman, Scott Hollenback, Russ Housley, Christian Huitema, John Kelsey, Mats Naslund 및 Damir Rajnovic.

다음은 이 문서의 전신인 RFC 1750에 기여한 사람들\(알파벳순\)입니다.

- David M. Balenson, Don T. Davis, Carl Ellison, Marc Horowitz, Christian Huitema, Charlie Kaufman, Steve Kent, Hal Murray, Neil Haller, Richard Pitkin, Tim Redmond, Doug Tygar.

---
# **Appendix A: Changes from RFC 1750**

1. 감사의 글이 추가되었습니다.

2. S-box와 혼합에 관한 섹션 5.3 삽입.

3. 링 오실레이터 임의성 소스에 대한 섹션 3.3 추가.

4. 160비트 이상을 생성하는 AES 및 SHA 시리즈 구성원 추가. AES의 사용은 강조되었으며 DES의 사용은 덜 강조되었습니다.

5. 엔트로피 풀 기술에 대한 섹션 6.3 추가.

6. FIPS 186-2\(변경 공지 1 포함\)에 제공된 의사 난수 생성 기술에 대한 섹션 7.2.3, X9.82에 제공된 항목에 대한 7.2.1, 난수 생성 기술에 대한 섹션 7.1.2 추가 Linux 및 기타 UNIX 시스템의 /dev/random 장치 및 Windows 운영 체제의 난수 생성 기술에 대한 섹션 7.1.3.

7. 1996년 1월에 발표된 "Minimal Key Lengths for Symmetric Ciphers to Provide Adequate Commercial Security" 연구 \[KeyStudy\] 및 \[RFC1948\]에 참조를 추가했습니다.

8. Diffie-Hellman을 믹싱 함수로 사용할 때 주의 사항을 추가했습니다. 이러한 주의 사항과 계산 집약적인 특성으로 인해 사용하지 않는 것이 좋습니다.

9. X9.82 노력과 \[TURBID\] 및 \[NASLUND\] 논문에 대한 참조 추가.

10. 최소 엔트로피 및 Renyi 엔트로피에 대한 논의 및 \[LUBY\] 책에 대한 참조 추가.

11. 대대적인 구조 조정, 사소한 문구 변경 및 다양한 참조 업데이트.

---
# **Informative References**

\[AES\] "AES\(Advanced Encryption Standard\) 사양", 미국, 미국 표준 기술 연구소, FIPS 197, 2001년 11월.

\[비대칭\] Simmons, G., Ed., "보안 통신 및

- Asymmetric Cryptosystems", AAAS 선정 심포지엄 69, ISBN 0-86531-338-5, Westview Press, 1982.

\[BBS\] Blum, L., Blum, M. 및 M. Shub, "A Simple

- Unpredictable Pseudo-Random Number Generator", SIAM Journal on Computing, v. 15, n. 2, 1986.

\[BRILLINGER\] Brillinger, D., "시계열: 데이터 분석 및 이론", Holden-Day, 1981.

```text
   [CRC]           "C.R.C. Standard Mathematical Tables", Chemical
                   Rubber Publishing Company.
```

\[DAVIS\] Davis, D., Ihaka, R. 및 P. Fenstermacher,

- "디스크 드라이브의 공기 난기류로 인한 암호화 임의성", 암호학의 발전 - Crypto '94, Springer-Verlag 강의 노트 in Computer Science #839, 1984.

\[DES\] "Data Encryption Standard", US National Institute of Standards and Technology, FIPS 46-3, 1999년 10월. 또한 "Data Encryption Algorithm", American National Standards Institute, ANSI X3.92-1981. DES 수행을 위한 FORTRAN 코드를 포함하는 FIPS 112, "암호 사용"도 참조하십시오.

```text
   [D-H]           Rescorla, E., "Diffie-Hellman Key Agreement Method",
                   RFC 2631, June 1999.
```

\[DNSSEC1\] Arends, R., Austein, R., Larson, M., Massey, D. 및 S. Rose, "DNS 보안 소개 및 요구 사항", RFC 4033, 2005년 3월.

\[DNSSEC2\] Arends, R., Austein, R., Larson, M., Massey, D. 및 S. Rose, "DNS 보안 확장에 대한 리소스 레코드", RFC 4034, 2005년 3월.

\[DNSSEC3\] Arends, R., Austein, R., Larson, M., Massey, D. 및 S. Rose, "DNS 보안 확장을 위한 프로토콜 수정", RFC 4035, 2005년 3월.

\[DoD\] "암호 관리 지침", 미합중국, 국방부, 컴퓨터 보안 센터, CSC-STD-002-85, 1885년 4월.

\("비밀번호 사용", FIPS 112도 참조하십시오.

- CSC-STD-002-85를 부록 중 하나로 통합합니다. FIPS 112는 현재 http://www.idl.nist.gov/fipspubs/fip112.htm에서 사용할 수 있습니다.\)

\[DSS\] "DSS\(디지털 서명 표준\)", 미국 국립 표준 기술 연구소, FIPS 186-2, 2000년 1월.

\[DSS\_CN1\] "디지털 서명 표준 변경 공지 1", 미국 국립 표준 기술 연구소, FIPS 186-2 변경 공지 1, 5, 2001년 10월.

\[FERGUSON\] 퍼거슨, N. 및 B. 슈나이어, "실용적

- Cryptography", Wiley Publishing Inc., ISBN 047122894X, 2003년 4월.

```text
   [GIFFORD]       Gifford, D., "Natural Random Number", MIT/LCS/TM-371,
                   September 1988.
```

\[IEEE\_802.11i\] "시스템 간 통신 및 정보 교환에 대한 표준 개정 - LAN/MAN 특정 요구 사항 - 파트 11: 무선 매체 액세스 제어\(MAC\) 및 물리적 계층\(PHY\) 사양: 매체 액세스 제어\(MAC\) 보안 향상" , IEEE, 2004년 1월.

\[IPSEC\] Kent, S. 및 R. Atkinson, "인터넷 프로토콜을 위한 보안 아키텍처", RFC 2401, 1998년 11월.

\[Jakobsson\] Jakobsson, M., Shriver, E., Hillyer, B. 및 A. Juels, "실용적인 보안 임의 비트 생성기", 컴퓨터 및 통신 보안에 관한 제5차 ACM 회의 절차, 1998.

\[KAUFMAN\] Kaufman, C., Perlman, R. 및 M. Speciner, "네트워크 보안: 공용 환경에서의 개인 통신", Prentis Hall PTR, ISBN 0-13-046019-2, 2판 2002.

\[KeyStudy\] Blaze, M., Diffie, W., Riverst, R., Schneier, B. Shimomura, T., Thompson, E. 및 M. Weiner, "적절한 상용 보안을 제공하기 위한 대칭 암호의 최소 키 길이: A Report by an Ad Hoc Group of Cryptographers and Computer Scientists", 1996년 1월. .

\[KNUTH\] Knuth, D., "The Art of Computer Programming", Volume 2: Seminumerical Algorithms, Chapter 3: Random Numbers, Addison-Wesley Publishing Company, 3판, 1997년 11월.

\[KRAWCZYK\] Krawczyk, H., "합동을 예측하는 방법

- Generators", Journal of Algorithms, V. 13, N. 4, 1992년 12월.

\[LUBY\] Luby, M., "Pseudorandomness and Cryptographic Applications", Princeton University Press, ISBN 0691025460, 1996년 1월 8일.

\[MAIL\_PEM1\] Linn, J., "인터넷을 위한 개인 정보 보호 강화

- 전자 메일: 파트 I: 메시지 암호화 및 인증 절차", RFC 1421, 1993년 2월.

\[MAIL\_PEM2\] Kent, S., "인터넷을 위한 개인 정보 보호 강화

- 전자 메일: 파트 II: 인증서 기반 키 관리", RFC 1422, 1993년 2월.

\[MAIL\_PEM3\] Balenson, D., "인터넷 전자 메일에 대한 개인 정보 보호 강화: 파트 III: 알고리즘, 모드 및 식별자", RFC 1423, 1993년 2월.

\[MAIL\_PEM4\] Kaliski, B., "인터넷 전자 메일에 대한 개인 정보 보호 강화: 파트 IV: 주요 인증 및 관련 서비스", RFC 1424, 1993년 2월.

\[MAIL\_PGP1\] Callas, J., Donnerhacke, L., Finney, H. 및 R. Thayer, "OpenPGP 메시지 형식", RFC 2440, 1998년 11월.

\[MAIL\_PGP2\] Elkins, M., Del Torto, D., Levien, R. 및 T. Roessler, "OpenPGP를 사용한 MIME 보안", RFC 3156, 2001년 8월.

\[S/MIME\] RFC 2632\~2634:

```text
                   Ramsdell, B., "S/MIME Version 3 Certificate
                   Handling", RFC 2632, June 1999.

                   Ramsdell, B., "S/MIME Version 3 Message
                   Specification", RFC 2633, June 1999.
```

- Hoffman, P., "S/MIME를 위한 향상된 보안 서비스", RFC 2634, 1999년 6월.

```text
   [MD4]           Rivest, R., "The MD4 Message-Digest Algorithm", RFC
                   1320, April 1992.

   [MD5]           Rivest, R., "The MD5 Message-Digest Algorithm ", RFC
                   1321, April 1992.
```

\[MODES\] "DES 작동 모드", 미국 국립 표준 기술 연구소, FIPS 81, 1980년 12월. 또한: "데이터 암호화 알고리즘 - 작동 모드", 미국 국립 표준 연구소, ANSI X3.106-1983.

\[무어\] 무어의 법칙: 실리콘 회로의 논리 밀도가 기하급수적으로 증가합니다. 원래 1964년 Gordon Moore가 1962년부터 매년 두 배로 공식화한 이 비율은 1970년대 후반에 18개월마다 두 배로 떨어졌고 이 문서 날짜까지 그대로 유지되었습니다. "The New Hacker's Dictionary", 제3판, MIT Press, ISBN 0-262-18178-9, Eric S. Raymond, 1996을 참조하십시오.

\[NASLUND\] Naslund, M. 및 A. Russell, "편향 소스에서 최적으로 편향되지 않은 비트 추출", 정보 이론에 대한 IEEE 트랜잭션. 46\(3\), 2000년 5월.

\[ORMAN\] Orman, H. 및 P. Hoffman, "대칭 키 교환에 사용되는 공개 키의 강점 결정", BCP 86, RFC 3766, 2004년 4월.

\[RFC1750\] Eastlake 3rd, D., Crocker, S. 및 J. Schiller, "보안을 위한 임의성 권장 사항", RFC 1750, 1994년 12월.

\[RFC1948\] Bellovin, S., "시퀀스 번호 공격에 대한 방어", RFC 1948, 1996년 5월.

\[RFC2104\] Krawczyk, H., Bellare, M. 및 R. Canetti, "HMAC: 메시지 인증을 위한 키 해싱", RFC 2104, 1997년 2월.

\[RSA\_BULL1\] "에서 난수 생성에 대한 제안

- 소프트웨어", RSA Laboratories Bulletin #1, 1996년 1월.

\[RSA\_BULL13\] Silverman, R., "A Cost-Based Security Analysis of Symmetric and Asymmetric Key Lengths", RSA Laboratories Bulletin #13, 2000년 4월\(2001년 11월 개정\).

\[SBOX1\] Mister, S. and C. Adams, "Practical S-box Design", Selected Areas in Cryptography, 1996.

\[SBOX2\] Nyberg, K., "Perfect Non-linear S-boxes", Advances in Cryptography, Eurocrypt '91 Proceedings, Springer-Verland, 1991.

\[SCHNEIER\] Schneier, B., "Applied Cryptography: Protocols, Algorithms, and Source Code in C", 2판, John Wiley & Sons, 1996.

\[SHANNON\] Shannon, C., "의 수학적 이론

- Communication", University of Illinois Press, 1963. 원본 출처: Bell System Technical Journal, 1948년 7월 및 10월.

```text
   [SHIFT1]        Golub, S., "Shift Register Sequences", Aegean Park
                   Press, Revised Edition, 1982.
```

\[SHIFT2\] Barker, W., "시프트 레지스터의 암호 분석

- Generated Stream Cypher Systems", Aegean Park Press, 1984.

\[SHA\] "보안 해시 표준", 미국 국립 과학 기술 연구소, FIPS 180-2, 2002년 8월 1일.

\[SHA\_RFC\] Eastlake 3rd, D. 및 P. Jones, "US Secure Hash Algorithm 1\(SHA1\)", RFC 3174, 2001년 9월.

\[SSH\] SECSH 작업 그룹의 제품, 작업 진행 중, 2005.

\[STERN\] Stern, J., "Secret Linear Congruential Generators are not Cryptographically Secure", Proc. IEEE STOC, 1987.

\[TLS\] Dierks, T. 및 C. Allen, "TLS 프로토콜 버전 1.0", RFC 2246, 1999년 1월.

```text
   [TURBID]        Denker, J., "High Entropy Symbol Generator",
                   <http://www.av8n.com/turbid/paper/turbid.htm>, 2003.
```

\[USENET\_1\] Kantor, B. 및 P. Lapsley, "네트워크 뉴스 전송 프로토콜", RFC 977, 1986년 2월.

```text
   [USENET_2]      Barber, S., "Common NNTP Extensions", RFC 2980,
                   October 2000.
```

\[VON\_NEUMANN\] Von Nuemann, J., "에 사용되는 다양한 기술

- 난수와의 연결", Von Neumann's Collected Works, Vol. 5, Pergamon Press, 1963.

\[WSC\] Howard, M. 및 D. LeBlanc, "보안 코드 작성, 제2판", Microsoft Press, ISBN 0735617228, 2002년 12월.

\[X9.17\] "금융 기관 키 관리\(도매\)에 대한 미국 국가 표준", 미국 은행가 협회, 1985.

\[X9.82\] "난수 생성", American National Standards Institute, ANSI X9F1, 진행 중인 작업. 파트 1 - 개요 및 일반 원칙. 파트 2 - 비결정적 임의 비트 생성기 파트 3 - 결정적 임의 비트 생성기

---
# **Authors' Addresses**

```text
   Donald E. Eastlake 3rd
   Motorola Laboratories
   155 Beaver Street
   Milford, MA 01757 USA

   Phone: +1 508-786-7554 (w)
          +1 508-634-2066 (h)
   EMail: Donald.Eastlake@motorola.com

   Jeffrey I. Schiller
   MIT, Room E40-311
   77 Massachusetts Avenue
   Cambridge, MA 02139-4307 USA

   Phone: +1 617-253-0161
   EMail: jis@mit.edu

   Steve Crocker

   EMail: steve@stevecrocker.com
```

---
# **Full Copyright Statement**

Copyright \(C\) The Internet Society \(2005\).

이 문서는 BCP 78에 포함된 권리, 라이선스 및 제한 사항의 적용을 받으며 여기에 명시된 경우를 제외하고 작성자는 모든 권리를 보유합니다.

이 문서 및 여기에 포함된 정보는 "있는 그대로" 제공되며 기여자, 기여자가 대표하거나 후원하는 조직\(있는 경우\), 인터넷 사회 및 인터넷 공학 태스크포스는 모든 명시적 또는 묵시적 보증을 부인합니다. 여기에서 구성은 상품성 또는 특정 목적에의 적합성에 대한 권리 또는 묵시적 보증을 침해하지 않습니다.

---
# **Intellectual Property**

IETF는 이 문서에 설명된 기술의 구현 또는 사용과 관련이 있다고 주장할 수 있는 지적 재산권 또는 기타 권리의 유효성 또는 범위 또는 그러한 권리에 따른 라이센스의 범위에 대해 어떠한 입장도 취하지 않습니다. 는 가능하다; 또한 그러한 권리를 식별하기 위해 독립적인 노력을 기울였다는 것을 나타내지 않습니다. RFC 문서의 권리와 관련된 절차에 대한 정보는 BCP 78 및 BCP 79에서 찾을 수 있습니다.

IETF 사무국에 제출된 IPR 공개 사본 및 사용 가능한 라이선스에 대한 보증 또는 이 사양의 구현자 또는 사용자가 이러한 독점권 사용에 대한 일반 라이선스 또는 허가를 얻으려는 시도의 결과를 얻을 수 있습니다. http://www.ietf.org/ipr의 IETF 온라인 IPR 저장소에서.

IETF는 이 표준을 구현하는 데 필요할 수 있는 기술을 포함할 수 있는 저작권, 특허 또는 특허 출원 또는 기타 소유권에 관심을 갖도록 이해 당사자를 초대합니다. 정보를 IETF\(ietf-ipr@ietf.org\)로 보내주십시오.

---
# **Acknowledgement**

RFC 편집기 기능에 대한 자금은 현재 Internet Society에서 제공하고 있습니다.
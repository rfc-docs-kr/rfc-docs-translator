

```text
Network Working Group                                      R. Fielding
Request for Comments: 2616                                   UC Irvine
Obsoletes: 2068                                              J. Gettys
Category: Standards Track                                   Compaq/W3C
                                                              J. Mogul
                                                                Compaq
                                                            H. Frystyk
                                                               W3C/MIT
                                                           L. Masinter
                                                                 Xerox
                                                              P. Leach
                                                             Microsoft
                                                        T. Berners-Lee
                                                               W3C/MIT
                                                             June 1999

                Hypertext Transfer Protocol -- HTTP/1.1
```

---
# **Status of this Memo**

이 문서는 인터넷 커뮤니티를 위한 인터넷 표준 추적 프로토콜을 지정하고 개선을 위한 토론 및 제안을 요청합니다. 이 프로토콜의 표준화 상태 및 상태에 대해서는 "Internet Official Protocol Standards"\(STD 1\) 최신판을 참조하십시오. 이 메모의 배포는 무제한입니다.

---
# **Copyright Notice**

Copyright \(C\) The Internet Society \(1999\). 판권 소유.

---
# **Abstract**

HTTP\(Hypertext Transfer Protocol\)는 분산, 협업, 하이퍼미디어 정보 시스템을 위한 응용 프로그램 수준 프로토콜입니다. 이는 요청 방법, 오류 코드 및 헤더의 확장을 통해 이름 서버 및 분산 개체 관리 시스템과 같은 하이퍼텍스트 사용을 넘어 많은 작업에 사용할 수 있는 일반적인 상태 비저장 프로토콜입니다\[47\]. HTTP의 특징은 데이터 표현을 입력하고 협상하는 것입니다. 이를 통해 전송되는 데이터와 독립적으로 시스템을 구축할 수 있습니다.

HTTP는 1990년부터 World-Wide Web 글로벌 정보 이니셔티브에서 사용되어 왔습니다. 이 사양은 "HTTP/1.1"이라는 프로토콜을 정의하며 RFC 2068\[33\]에 대한 업데이트입니다.

---
# **Table of Contents**

```text
   1   Introduction ...................................................7
   1.1    Purpose......................................................7
   1.2   Requirements .................................................8
   1.3   Terminology ..................................................8
   1.4   Overall Operation ...........................................12
   2   Notational Conventions and Generic Grammar ....................14
   2.1   Augmented BNF ...............................................14
   2.2   Basic Rules .................................................15
   3   Protocol Parameters ...........................................17
   3.1   HTTP Version ................................................17
   3.2   Uniform Resource Identifiers ................................18
   3.2.1    General Syntax ...........................................19
   3.2.2    http URL .................................................19
   3.2.3    URI Comparison ...........................................20
   3.3   Date/Time Formats ...........................................20
   3.3.1    Full Date ................................................20
   3.3.2    Delta Seconds ............................................21
   3.4   Character Sets ..............................................21
   3.4.1    Missing Charset ..........................................22
   3.5   Content Codings .............................................23
   3.6   Transfer Codings ............................................24
   3.6.1    Chunked Transfer Coding ..................................25
   3.7   Media Types .................................................26
   3.7.1    Canonicalization and Text Defaults .......................27
   3.7.2    Multipart Types ..........................................27
   3.8   Product Tokens ..............................................28
   3.9   Quality Values ..............................................29
   3.10  Language Tags ...............................................29
   3.11  Entity Tags .................................................30
   3.12  Range Units .................................................30
   4   HTTP Message ..................................................31
   4.1   Message Types ...............................................31
   4.2   Message Headers .............................................31
   4.3   Message Body ................................................32
   4.4   Message Length ..............................................33
   4.5   General Header Fields .......................................34
   5   Request .......................................................35
   5.1   Request-Line ................................................35
   5.1.1    Method ...................................................36
   5.1.2    Request-URI ..............................................36
   5.2   The Resource Identified by a Request ........................38
   5.3   Request Header Fields .......................................38
   6   Response ......................................................39
   6.1   Status-Line .................................................39
   6.1.1    Status Code and Reason Phrase ............................39
   6.2   Response Header Fields ......................................41
   7   Entity ........................................................42
   7.1   Entity Header Fields ........................................42
   7.2   Entity Body .................................................43
   7.2.1    Type .....................................................43
   7.2.2    Entity Length ............................................43
   8   Connections ...................................................44
   8.1   Persistent Connections ......................................44
   8.1.1    Purpose ..................................................44
   8.1.2    Overall Operation ........................................45
   8.1.3    Proxy Servers ............................................46
   8.1.4    Practical Considerations .................................46
   8.2   Message Transmission Requirements ...........................47
   8.2.1    Persistent Connections and Flow Control ..................47
   8.2.2    Monitoring Connections for Error Status Messages .........48
   8.2.3    Use of the 100 (Continue) Status .........................48
   8.2.4    Client Behavior if Server Prematurely Closes Connection ..50
   9   Method Definitions ............................................51
   9.1   Safe and Idempotent Methods .................................51
   9.1.1    Safe Methods .............................................51
   9.1.2    Idempotent Methods .......................................51
   9.2   OPTIONS .....................................................52
   9.3   GET .........................................................53
   9.4   HEAD ........................................................54
   9.5   POST ........................................................54
   9.6   PUT .........................................................55
   9.7   DELETE ......................................................56
   9.8   TRACE .......................................................56
   9.9   CONNECT .....................................................57
   10   Status Code Definitions ......................................57
   10.1  Informational 1xx ...........................................57
   10.1.1   100 Continue .............................................58
   10.1.2   101 Switching Protocols ..................................58
   10.2  Successful 2xx ..............................................58
   10.2.1   200 OK ...................................................58
   10.2.2   201 Created ..............................................59
   10.2.3   202 Accepted .............................................59
   10.2.4   203 Non-Authoritative Information ........................59
   10.2.5   204 No Content ...........................................60
   10.2.6   205 Reset Content ........................................60
   10.2.7   206 Partial Content ......................................60
   10.3  Redirection 3xx .............................................61
   10.3.1   300 Multiple Choices .....................................61
   10.3.2   301 Moved Permanently ....................................62
   10.3.3   302 Found ................................................62
   10.3.4   303 See Other ............................................63
   10.3.5   304 Not Modified .........................................63
   10.3.6   305 Use Proxy ............................................64
   10.3.7   306 (Unused) .............................................64
   10.3.8   307 Temporary Redirect ...................................65
   10.4  Client Error 4xx ............................................65
   10.4.1    400 Bad Request .........................................65
   10.4.2    401 Unauthorized ........................................66
   10.4.3    402 Payment Required ....................................66
   10.4.4    403 Forbidden ...........................................66
   10.4.5    404 Not Found ...........................................66
   10.4.6    405 Method Not Allowed ..................................66
   10.4.7    406 Not Acceptable ......................................67
   10.4.8    407 Proxy Authentication Required .......................67
   10.4.9    408 Request Timeout .....................................67
   10.4.10   409 Conflict ............................................67
   10.4.11   410 Gone ................................................68
   10.4.12   411 Length Required .....................................68
   10.4.13   412 Precondition Failed .................................68
   10.4.14   413 Request Entity Too Large ............................69
   10.4.15   414 Request-URI Too Long ................................69
   10.4.16   415 Unsupported Media Type ..............................69
   10.4.17   416 Requested Range Not Satisfiable .....................69
   10.4.18   417 Expectation Failed ..................................70
   10.5  Server Error 5xx ............................................70
   10.5.1   500 Internal Server Error ................................70
   10.5.2   501 Not Implemented ......................................70
   10.5.3   502 Bad Gateway ..........................................70
   10.5.4   503 Service Unavailable ..................................70
   10.5.5   504 Gateway Timeout ......................................71
   10.5.6   505 HTTP Version Not Supported ...........................71
   11   Access Authentication ........................................71
   12   Content Negotiation ..........................................71
   12.1  Server-driven Negotiation ...................................72
   12.2  Agent-driven Negotiation ....................................73
   12.3  Transparent Negotiation .....................................74
   13   Caching in HTTP ..............................................74
   13.1.1   Cache Correctness ........................................75
   13.1.2   Warnings .................................................76
   13.1.3   Cache-control Mechanisms .................................77
   13.1.4   Explicit User Agent Warnings .............................78
   13.1.5   Exceptions to the Rules and Warnings .....................78
   13.1.6   Client-controlled Behavior ...............................79
   13.2  Expiration Model ............................................79
   13.2.1   Server-Specified Expiration ..............................79
   13.2.2   Heuristic Expiration .....................................80
   13.2.3   Age Calculations .........................................80
   13.2.4   Expiration Calculations ..................................83
   13.2.5   Disambiguating Expiration Values .........................84
   13.2.6   Disambiguating Multiple Responses ........................84
   13.3  Validation Model ............................................85
   13.3.1   Last-Modified Dates ......................................86
   13.3.2   Entity Tag Cache Validators ..............................86
   13.3.3   Weak and Strong Validators ...............................86
   13.3.4   Rules for When to Use Entity Tags and Last-Modified Dates.89
   13.3.5   Non-validating Conditionals ..............................90
   13.4  Response Cacheability .......................................91
   13.5  Constructing Responses From Caches ..........................92
   13.5.1   End-to-end and Hop-by-hop Headers ........................92
   13.5.2   Non-modifiable Headers ...................................92
   13.5.3   Combining Headers ........................................94
   13.5.4   Combining Byte Ranges ....................................95
   13.6  Caching Negotiated Responses ................................95
   13.7  Shared and Non-Shared Caches ................................96
   13.8  Errors or Incomplete Response Cache Behavior ................97
   13.9  Side Effects of GET and HEAD ................................97
   13.10   Invalidation After Updates or Deletions ...................97
   13.11   Write-Through Mandatory ...................................98
   13.12   Cache Replacement .........................................99
   13.13   History Lists .............................................99
   14   Header Field Definitions ....................................100
   14.1  Accept .....................................................100
   14.2  Accept-Charset .............................................102
   14.3  Accept-Encoding ............................................102
   14.4  Accept-Language ............................................104
   14.5  Accept-Ranges ..............................................105
   14.6  Age ........................................................106
   14.7  Allow ......................................................106
   14.8  Authorization ..............................................107
   14.9  Cache-Control ..............................................108
   14.9.1   What is Cacheable .......................................109
   14.9.2   What May be Stored by Caches ............................110
   14.9.3   Modifications of the Basic Expiration Mechanism .........111
   14.9.4   Cache Revalidation and Reload Controls ..................113
   14.9.5   No-Transform Directive ..................................115
   14.9.6   Cache Control Extensions ................................116
   14.10   Connection ...............................................117
   14.11   Content-Encoding .........................................118
   14.12   Content-Language .........................................118
   14.13   Content-Length ...........................................119
   14.14   Content-Location .........................................120
   14.15   Content-MD5 ..............................................121
   14.16   Content-Range ............................................122
   14.17   Content-Type .............................................124
   14.18   Date .....................................................124
   14.18.1   Clockless Origin Server Operation ......................125
   14.19   ETag .....................................................126
   14.20   Expect ...................................................126
   14.21   Expires ..................................................127
   14.22   From .....................................................128
   14.23   Host .....................................................128
   14.24   If-Match .................................................129
   14.25   If-Modified-Since ........................................130
   14.26   If-None-Match ............................................132
   14.27   If-Range .................................................133
   14.28   If-Unmodified-Since ......................................134
   14.29   Last-Modified ............................................134
   14.30   Location .................................................135
   14.31   Max-Forwards .............................................136
   14.32   Pragma ...................................................136
   14.33   Proxy-Authenticate .......................................137
   14.34   Proxy-Authorization ......................................137
   14.35   Range ....................................................138
   14.35.1    Byte Ranges ...........................................138
   14.35.2    Range Retrieval Requests ..............................139
   14.36   Referer ..................................................140
   14.37   Retry-After ..............................................141
   14.38   Server ...................................................141
   14.39   TE .......................................................142
   14.40   Trailer ..................................................143
   14.41  Transfer-Encoding..........................................143
   14.42   Upgrade ..................................................144
   14.43   User-Agent ...............................................145
   14.44   Vary .....................................................145
   14.45   Via ......................................................146
   14.46   Warning ..................................................148
   14.47   WWW-Authenticate .........................................150
   15 Security Considerations .......................................150
   15.1      Personal Information....................................151
   15.1.1   Abuse of Server Log Information .........................151
   15.1.2   Transfer of Sensitive Information .......................151
   15.1.3   Encoding Sensitive Information in URI's .................152
   15.1.4   Privacy Issues Connected to Accept Headers ..............152
   15.2  Attacks Based On File and Path Names .......................153
   15.3  DNS Spoofing ...............................................154
   15.4  Location Headers and Spoofing ..............................154
   15.5  Content-Disposition Issues .................................154
   15.6  Authentication Credentials and Idle Clients ................155
   15.7  Proxies and Caching ........................................155
   15.7.1    Denial of Service Attacks on Proxies....................156
   16   Acknowledgments .............................................156
   17   References ..................................................158
   18   Authors' Addresses ..........................................162
   19   Appendices ..................................................164
   19.1  Internet Media Type message/http and application/http ......164
   19.2  Internet Media Type multipart/byteranges ...................165
   19.3  Tolerant Applications ......................................166
   19.4  Differences Between HTTP Entities and RFC 2045 Entities ....167
   19.4.1   MIME-Version ............................................167
   19.4.2   Conversion to Canonical Form ............................167
   19.4.3   Conversion of Date Formats ..............................168
   19.4.4   Introduction of Content-Encoding ........................168
   19.4.5   No Content-Transfer-Encoding ............................168
   19.4.6   Introduction of Transfer-Encoding .......................169
   19.4.7   MHTML and Line Length Limitations .......................169
   19.5  Additional Features ........................................169
   19.5.1   Content-Disposition .....................................170
   19.6  Compatibility with Previous Versions .......................170
   19.6.1   Changes from HTTP/1.0 ...................................171
   19.6.2   Compatibility with HTTP/1.0 Persistent Connections ......172
   19.6.3   Changes from RFC 2068 ...................................172
   20   Index .......................................................175
   21   Full Copyright Statement ....................................176
```

---
# **1 Introduction**
---
## **1.1 Purpose**

HTTP\(Hypertext Transfer Protocol\)는 분산, 협업, 하이퍼미디어 정보 시스템을 위한 응용 프로그램 수준 프로토콜입니다. HTTP는 1990년부터 World-Wide Web 글로벌 정보 이니셔티브에서 사용되어 왔습니다. HTTP/0.9라고 하는 HTTP의 첫 번째 버전은 인터넷을 통한 원시 데이터 전송을 위한 간단한 프로토콜이었습니다. RFC 1945 \[6\]에 정의된 HTTP/1.0은 메시지가 전송된 데이터에 대한 메타 정보와 요청/응답 의미 체계에 대한 수정자를 포함하는 MIME 유사 메시지 형식이 되도록 허용하여 프로토콜을 개선했습니다. 그러나 HTTP/1.0은 계층적 프록시, 캐싱, 지속적인 연결의 필요성 또는 가상 호스트의 영향을 충분히 고려하지 않습니다. 또한 "HTTP/1.0"이라고 부르는 불완전하게 구현된 응용 프로그램이 급증하면서 통신하는 두 응용 프로그램이 서로의 실제 기능을 확인하기 위해 프로토콜 버전을 변경해야 했습니다.

이 사양에서는 "HTTP/1.1"이라는 프로토콜을 정의합니다. 이 프로토콜에는 해당 기능의 안정적인 구현을 보장하기 위해 HTTP/1.0보다 더 엄격한 요구 사항이 포함되어 있습니다.

실용적인 정보 시스템에는 검색, 프런트엔드 업데이트, 주석 등 단순 검색보다 더 많은 기능이 필요합니다. HTTP는 요청의 목적을 나타내는 개방형 메서드 및 헤더 집합을 허용합니다\[47\]. 이는 URI\(Uniform Resource Identifier\) ​​\[3\]가 위치\(URL\) \[4\] 또는 이름\(URN\) \[20\]으로 제공하는 참조 규율을 기반으로 구축되었습니다.

방법을 적용하게 됩니다. 메시지는 다목적 인터넷 메일 확장\(MIME\) \[7\]에 의해 정의된 대로 인터넷 메일\[9\]에서 사용되는 것과 유사한 형식으로 전달됩니다.

HTTP는 SMTP \[16\], NNTP \[13\], FTP \[18\], Gopher \[2\] 및 WAIS \[18\]에서 지원하는 것을 포함하여 사용자 에이전트와 다른 인터넷 시스템에 대한 프록시/게이트웨이 간의 통신을 위한 일반 프로토콜로도 사용됩니다. 10\] 프로토콜. 이러한 방식으로 HTTP는 다양한 애플리케이션에서 사용 가능한 리소스에 대한 기본적인 하이퍼미디어 액세스를 허용합니다.

---
## **1.2 Requirements**

이 문서의 핵심 단어 "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY" 및 "OPTIONAL"은 다음과 같습니다. RFC 2119 \[34\]에 설명된 대로 해석됩니다.\(MUST NOT\)

```text
   An implementation is not compliant if it fails to satisfy one or more
   of the MUST or REQUIRED level requirements for the protocols it
   implements. An implementation that satisfies all the MUST or REQUIRED
   level and all the SHOULD level requirements for its protocols is said
   to be "unconditionally compliant"; one that satisfies all the MUST
   level requirements but not all the SHOULD level requirements for its
   protocols is said to be "conditionally compliant."
```

---
## **1.3 Terminology**

이 사양에서는 HTTP 통신의 참가자와 개체가 수행하는 역할을 나타내기 위해 다양한 용어를 사용합니다.

연결

- 통신을 목적으로 두 프로그램 사이에 설정된 전송 계층 가상 회선입니다.

메시지

- HTTP 통신의 기본 단위로, 섹션 4에 정의된 구문과 일치하는 구조화된 옥텟 시퀀스로 구성되고 연결을 통해 전송됩니다.

요구

- 섹션 5에 정의된 HTTP 요청 메시지.

응답

- 섹션 6에 정의된 HTTP 응답 메시지.

자원

- 섹션 3.2에 정의된 대로 URI로 식별할 수 있는 네트워크 데이터 개체 또는 서비스입니다. 리소스는 다양한 표현\(예: 여러 언어, 데이터 형식, 크기 및 해상도\)으로 제공되거나 다른 방식으로 달라질 수 있습니다.

실재

- 요청 또는 응답의 페이로드로 전송되는 정보입니다. 엔터티는 섹션 7에 설명된 대로 엔터티 헤더 필드 형식의 메타정보와 엔터티 본문 형식의 콘텐츠로 구성됩니다.

대표

- 섹션 12에 설명된 대로 콘텐츠 협상이 적용되는 응답에 포함된 엔터티. 특정 응답 상태와 관련된 여러 표현이 있을 수 있습니다.

내용 협상

- 섹션 12에 설명된 대로 요청을 처리할 때 적절한 표현을 선택하는 메커니즘. 모든 응답의 엔터티 표현은 협상될 수 있습니다\(오류 응답 포함\).

변종

- 리소스는 주어진 순간에 하나 이상의 표현을 가질 수 있습니다. 이러한 표현 각각을 '변형'이라고 합니다. '변형'이라는 용어를 사용한다고 해서 반드시 자원이 내용 협상 대상임을 의미하는 것은 아닙니다.

고객

- 요청을 보내기 위해 연결을 설정하는 프로그램입니다.

사용자 에이전트

- 요청을 시작하는 클라이언트입니다. 이는 브라우저, 편집기, 스파이더\(웹 탐색 로봇\) 또는 기타 최종 사용자 도구인 경우가 많습니다.

섬기는 사람

- 응답을 다시 보내 요청을 처리하기 위해 연결을 수락하는 응용 프로그램입니다. 특정 프로그램은 클라이언트이자 서버가 될 수 있습니다. 이러한 용어의 사용은 일반적인 프로그램 기능이 아닌 특정 연결을 위해 프로그램이 수행하는 역할만을 의미합니다. 마찬가지로 모든 서버는 원본 서버, 프록시, 게이트웨이 또는 터널 역할을 할 수 있으며 각 요청의 특성에 따라 동작을 전환할 수 있습니다.

원본 서버

- 특정 리소스가 상주하거나 생성될 서버입니다.

대리

- 다른 클라이언트를 대신하여 요청을 수행할 목적으로 서버와 클라이언트 역할을 모두 수행하는 중개 프로그램입니다. 요청은 내부적으로 처리되거나 가능한 번역을 통해 다른 서버로 전달됩니다. 프록시는 이 사양의 클라이언트 및 서버 요구 사항을 모두 구현해야 합니다. "투명 프록시"는 프록시 인증 및 식별에 필요한 것 이상으로 요청이나 응답을 수정하지 않는 프록시입니다. "비투명 프록시"는 그룹 주석 서비스, 미디어 유형 변환, 프로토콜 축소 또는 익명 필터링과 같은 일부 추가 서비스를 사용자 에이전트에 제공하기 위해 요청 또는 응답을 수정하는 프록시입니다. 투명하거나 불투명한 동작이 명시적으로 명시된 경우를 제외하고 HTTP 프록시 요구 사항은 두 가지 유형의 프록시 모두에 적용됩니다.\(MUST\)

게이트웨이

- 다른 서버의 중개자 역할을 하는 서버입니다. 프록시와 달리 게이트웨이는 요청된 리소스에 대한 원본 서버인 것처럼 요청을 받습니다. 요청 클라이언트는 자신이 게이트웨이와 통신하고 있다는 사실을 인식하지 못할 수도 있습니다.

터널

- 두 연결 사이에서 블라인드 릴레이 역할을 하는 중개 프로그램입니다. 일단 활성화되면 터널은 HTTP 요청에 의해 시작되었을 수 있지만 HTTP 통신의 당사자로 간주되지 않습니다. 릴레이된 연결의 양쪽 끝이 닫히면 터널은 더 이상 존재하지 않습니다.

은닉처

- 응답 메시지의 프로그램 로컬 저장소와 메시지 저장, 검색 및 삭제를 제어하는 ​​하위 시스템입니다. 캐시는 향후 동등한 요청에 대한 응답 시간과 네트워크 대역폭 소비를 줄이기 위해 캐시 가능한 응답을 저장합니다. 모든 클라이언트나 서버에는 캐시가 포함될 수 있지만 터널 역할을 하는 서버에서는 캐시를 사용할 수 없습니다.

캐시 가능

- 캐시가 후속 요청에 응답하는 데 사용하기 위해 응답 메시지의 복사본을 저장하도록 허용된 경우 응답을 캐시할 수 있습니다. HTTP 응답의 캐시 가능성을 결정하는 규칙은 섹션 13에 정의되어 있습니다. 리소스가 캐시 가능하더라도 캐시가 특정 요청에 대해 캐시된 복사본을 사용할 수 있는지 여부에 대한 추가 제약이 있을 수 있습니다.

직접

- 하나 이상의 프록시를 통해 원본 서버에서 불필요한 지연 없이 직접 응답이 오면 직접 응답합니다. 유효성이 원본 서버에서 직접 확인된 경우에도 응답은 직접 이루어집니다.

명시적인 만료 시간

- 원서버가 추가 검증 없이 엔터티가 더 이상 캐시에 의해 반환되지 않도록 의도하는 시간입니다.

경험적 만료 시간

- 명시적인 만료 시간을 사용할 수 없는 경우 캐시에 의해 할당된 만료 시간입니다.

나이

- 응답 기간은 원본 서버에서 전송되었거나 성공적으로 검증된 이후의 시간입니다.

신선도 수명

- 응답 생성과 만료 시간 사이의 시간입니다.

신선한

- 해당 연령이 아직 신선도 수명을 초과하지 않은 경우 응답은 신선합니다.

탁한

- 해당 연령이 신선도 수명을 초과한 경우 응답은 오래되었습니다.

의미적으로 투명하다

- 캐시의 사용이 성능 향상을 제외하고 요청 클라이언트나 원본 서버에 영향을 주지 않는 경우 특정 응답과 관련하여 "의미상 투명한" 방식으로 작동합니다. 캐시가 의미상 투명할 때 클라이언트는 원본 서버에서 해당 요청을 직접 처리했을 때 받았을 것과 정확히 동일한 응답\(홉별 헤더 제외\)을 받습니다.

검증인

- 캐시 항목이 엔터티의 동등한 복사본인지 확인하는 데 사용되는 프로토콜 요소\(예: 엔터티 태그 또는 마지막 수정 시간\)입니다.

상류 하류

- 업스트림과 다운스트림은 메시지의 흐름을 설명합니다. 모든 메시지는 업스트림에서 다운스트림으로 흐릅니다.

```text
   inbound/outbound
      Inbound and outbound refer to the request and response paths for
      messages: "inbound" means "traveling toward the origin server",
      and "outbound" means "traveling toward the user agent"
```

---
## **1.4 Overall Operation**

HTTP 프로토콜은 요청/응답 프로토콜입니다. 클라이언트는 요청 방법, URI 및 프로토콜 버전의 형태로 서버에 요청을 보낸 후 서버와의 연결을 통해 요청 수정자, 클라이언트 정보 및 가능한 본문 콘텐츠가 포함된 MIME 형식 메시지를 보냅니다. 서버는 메시지의 프로토콜 버전과 성공 또는 오류 코드를 포함하는 상태 줄로 응답하고, 이어서 서버 정보, 엔터티 메타 정보, 가능한 엔터티 본문 콘텐츠가 포함된 MIME 형식 메시지로 응답합니다. HTTP와 MIME의 관계는 부록 19.4에 설명되어 있습니다.

대부분의 HTTP 통신은 사용자 에이전트에 의해 시작되며 일부 원본 서버의 리소스에 적용되는 요청으로 구성됩니다. 가장 간단한 경우 이는 사용자 에이전트\(UA\)와 원본 서버\(O\) 간의 단일 연결\(v\)을 통해 수행될 수 있습니다.

```text
          request chain ------------------------>
       UA -------------------v------------------- O
          <----------------------- response chain
```

요청/응답 체인에 하나 이상의 중개자가 있으면 더 복잡한 상황이 발생합니다. 중개자에는 프록시, 게이트웨이, 터널의 세 가지 일반적인 형태가 있습니다. 프록시는 절대 형식으로 URI에 대한 요청을 수신하고, 메시지의 전부 또는 일부를 다시 작성하고, 형식이 변경된 요청을 URI로 식별되는 서버로 전달하는 전달 에이전트입니다. 게이트웨이는 다른 서버 위의 계층 역할을 하는 수신 에이전트이며 필요한 경우 요청을 기본 서버의 프로토콜로 변환합니다. 터널은 메시지를 변경하지 않고 두 연결 간의 중계 지점 역할을 합니다. 터널은 중개자가 메시지의 내용을 이해할 수 없는 경우에도 통신이 중개자\(예: 방화벽\)를 통과해야 할 때 사용됩니다.

```text
          request chain -------------------------------------->
       UA -----v----- A -----v----- B -----v----- C -----v----- O
          <------------------------------------- response chain
```

위 그림은 사용자 에이전트와 원본 서버 사이의 세 가지 중개자\(A, B, C\)를 보여줍니다. 전체 체인을 이동하는 요청 또는 응답 메시지는 4개의 개별 연결을 통과합니다. 일부 HTTP 통신 옵션이 있기 때문에 이러한 구별이 중요합니다.

터널이 아닌 가장 가까운 이웃과의 연결, 체인의 끝점에만 적용되거나 체인을 따라 있는 모든 연결에만 적용될 수 있습니다. 다이어그램은 선형이지만 각 참가자는 여러 동시 통신에 참여할 수 있습니다. 예를 들어, B는 A 이외의 많은 클라이언트로부터 요청을 수신하거나 A의 요청을 처리하는 동시에 C 이외의 서버로 요청을 전달할 수 있습니다.

터널 역할을 하지 않는 통신 당사자는 요청 처리를 위해 내부 캐시를 사용할 수 있습니다. 캐시의 효과는 체인에 있는 참가자 중 하나가 해당 요청에 적용할 수 있는 캐시된 응답을 가지고 있는 경우 요청/응답 체인이 단축된다는 것입니다. 다음은 UA 또는 A에 의해 캐시되지 않은 요청에 대해 \(C를 통해\) O로부터의 이전 응답의 캐시된 복사본이 B에 있는 경우 결과 체인을 보여줍니다.

```text
          request chain ---------->
       UA -----v----- A -----v----- B - - - - - - C - - - - - - O
          <--------- response chain
```

모든 응답을 유용하게 캐시할 수 있는 것은 아니며 일부 요청에는 캐시 동작에 특별한 요구 사항을 적용하는 수정자가 포함될 수 있습니다. 캐시 동작 및 캐시 가능한 응답에 대한 HTTP 요구 사항은 섹션 13에 정의되어 있습니다.

실제로 현재 World Wide Web을 통해 실험 중이거나 배포되고 있는 캐시 및 프록시의 다양한 아키텍처와 구성이 있습니다. 이러한 시스템에는 대양 횡단 대역폭을 절약하기 위한 프록시 캐시의 국가 계층 구조, 캐시 항목을 브로드캐스트하거나 멀티캐스트하는 시스템, CD-ROM을 통해 캐시된 데이터의 하위 집합을 배포하는 조직 등이 포함됩니다. HTTP 시스템은 고대역폭 링크를 통한 기업 인트라넷과 저전력 무선 링크 및 간헐적 연결을 갖춘 PDA를 통한 액세스에 사용됩니다. HTTP/1.1의 목표는 이미 배포된 다양한 구성을 지원하는 동시에 높은 신뢰성을 요구하고, 이것이 실패할 경우 적어도 안정적인 실패 표시를 요구하는 웹 애플리케이션을 구축하는 사람들의 요구 사항을 충족하는 프로토콜 구성을 도입하는 것입니다.

HTTP 통신은 일반적으로 TCP/IP 연결을 통해 이루어집니다. 기본 포트는 TCP 80\[19\]이지만 다른 포트도 사용할 수 있다. 이는 HTTP가 인터넷이나 다른 네트워크의 다른 프로토콜 위에 구현되는 것을 배제하지 않습니다. HTTP는 안정적인 전송만을 가정합니다. 그러한 보장을 제공하는 모든 프로토콜을 사용할 수 있습니다. 문제의 프로토콜의 전송 데이터 단위에 대한 HTTP/1.1 요청 및 응답 구조의 매핑은 이 사양의 범위를 벗어납니다.

HTTP/1.0에서는 대부분의 구현에서 각 요청/응답 교환에 대해 새로운 연결을 사용했습니다. HTTP/1.1에서는 연결이 하나 이상의 요청/응답 교환에 사용될 수 있지만 다양한 이유로 연결이 닫힐 수 있습니다\(섹션 8.1 참조\).

---
# **2 Notational Conventions and Generic Grammar**
---
## **2.1 Augmented BNF**

이 문서에 명시된 모든 메커니즘은 RFC 822 \[9\]에서 사용되는 것과 유사한 산문과 확장된 BNF\(Backus-Naur Form\)로 설명됩니다. 구현자는 이 사양을 이해하기 위해 표기법에 익숙해야 합니다. 증강된 BNF에는 다음 구성이 포함됩니다.

이름 = 정의

- 규칙의 이름은 단순히 이름 자체이며\("<" 및 "\>"를 둘러싸지 않음\) 해당 정의와 등호 "=" 문자로 구분됩니다. 공백은 연속 줄의 들여쓰기가 두 줄 이상에 걸쳐 있는 규칙 정의를 나타내는 데 사용된다는 점에서만 중요합니다. SP, LWS, HT, CRLF, DIGIT, ALPHA 등과 같은 특정 기본 규칙은 대문자로 표시됩니다. 꺾쇠 괄호는 해당 규칙 이름의 사용을 쉽게 식별할 수 있도록 정의 내에서 사용됩니다.

"오자"

- 따옴표는 리터럴 텍스트를 둘러쌉니다. 별도로 명시하지 않는 한 텍스트는 대소문자를 구분하지 않습니다.

규칙1 | 규칙2

- 막대\("|"\)로 구분된 요소는 대안입니다. 예를 들어 "yes | no"는 예 또는 아니요를 허용합니다.

\(규칙1 규칙2\)

- 괄호 안의 요소는 단일 요소로 취급됩니다. 따라서 "\(elem \(foo | bar\) elem\)"은 토큰 시퀀스 "elem foo elem" 및 "elem bar elem"을 허용합니다.

\*규칙

- 요소 앞의 문자 "\*"는 반복을 나타냅니다. 전체 형식은 "<n\>\*<m\>element"로, 요소가 <n\>회 이상, 최대 <m\>회 발생함을 나타냅니다. 기본값은 0과 무한대이므로 "\*\(요소\)"는 0을 포함한 모든 숫자를 허용합니다. "1\*요소"에는 최소한 하나가 필요합니다. "1\*2element"는 1개 또는 2개를 허용합니다.

\[규칙\]

- 대괄호는 선택적 요소를 묶습니다. "\[foo bar\]"는 "\*1\(foo bar\)"와 동일합니다.

N 규칙

- 특정 반복: "<n\>\(요소\)"는 "<n\>\*<n\>\(요소\)"와 동일합니다. 즉, \(요소\)가 정확히 <n\>회 발생합니다. 따라서 2DIGIT는 2자리 숫자이고, 3ALPHA는 세 개의 알파벳 문자로 구성된 문자열입니다.

#규칙

- 요소 목록을 정의하기 위해 "\*"와 유사한 구성 "#"이 정의됩니다. 전체 형식은 "<n\>#<m\>element"이며, 각각 하나 이상의 쉼표\(","\)와 선택적인 선형 공백\(LWS\)으로 구분된 <n\>개 이상, <m\>개 이하의 요소를 나타냅니다. 이는 일반적인 목록 형식을 매우 쉽게 만듭니다. \( \*LWS 요소 \*\( \*LWS "," \*LWS 요소 \)\)와 같은 규칙은 1#element로 표시될 수 있습니다. 이 구성이 사용되는 곳마다 널 요소가 허용되지만 존재하는 요소 수에 영향을 주지는 않습니다. 즉, "\(요소\), , \(요소\)"는 허용되지만 두 요소로만 계산됩니다. 따라서 최소한 하나의 요소가 필요한 경우에는 null이 아닌 요소가 최소한 하나 있어야 합니다. 기본값은 0과 무한대이므로 "#element"는 0을 포함한 모든 숫자를 허용합니다. "1#element"에는 하나 이상이 필요합니다. "1#2element"는 1개 또는 2개를 허용합니다.\(MAY, MUST\)

; 논평

- 규칙 텍스트 오른쪽에 약간의 거리를 두고 있는 세미콜론은 줄 끝까지 계속되는 주석을 시작합니다. 이는 사양과 병행하여 유용한 참고 사항을 포함하는 간단한 방법입니다.

묵시적 \*LWS

- 본 명세서에서 설명하는 문법은 단어 기반이다. 별도로 명시하지 않는 한, LWS\(선형 공백\)는 필드 해석을 변경하지 않고 인접한 두 단어\(토큰 또는 인용 문자열\) 사이, 인접한 단어와 구분 기호 사이에 포함될 수 있습니다. 하나 이상의 구분 기호\(LWS 및/또는

- 구분 기호\)는 두 개의 토큰\(아래 "토큰" 정의\) 사이에 존재해야 합니다. 그렇지 않으면 단일 토큰으로 해석되기 때문입니다.\(MUST\)

---
## **2.2 Basic Rules**

다음 규칙은 기본 구문 분석 구성을 설명하기 위해 이 사양 전체에서 사용됩니다. US-ASCII 코드 문자 집합은 ANSI X3.4-1986 \[21\]에 정의되어 있습니다.

```text
       OCTET          = <any 8-bit sequence of data>
       CHAR           = <any US-ASCII character (octets 0 - 127)>
       UPALPHA        = <any US-ASCII uppercase letter "A".."Z">
       LOALPHA        = <any US-ASCII lowercase letter "a".."z">
       ALPHA          = UPALPHA | LOALPHA
       DIGIT          = <any US-ASCII digit "0".."9">
       CTL            = <any US-ASCII control character
                        (octets 0 - 31) and DEL (127)>
       CR             = <US-ASCII CR, carriage return (13)>
       LF             = <US-ASCII LF, linefeed (10)>
       SP             = <US-ASCII SP, space (32)>
       HT             = <US-ASCII HT, horizontal-tab (9)>
       <">            = <US-ASCII double-quote mark (34)>
```

HTTP/1.1은 CR LF 시퀀스를 Entity-Body를 제외한 모든 프로토콜 요소에 대한 줄 끝 표시로 정의합니다\(허용되는 응용 프로그램에 대해서는 부록 19.3 참조\). Entity-Body 내의 줄 끝 표시는 섹션 3.7에 설명된 대로 관련 미디어 유형으로 정의됩니다.

```text
       CRLF           = CR LF
```

연속 줄이 공백이나 가로 탭으로 시작하는 경우 HTTP/1.1 헤더 필드 값을 여러 줄로 접을 수 있습니다. 접기를 포함한 모든 선형 공백은 SP와 동일한 의미를 갖습니다. 수신자는 필드 값을 해석하거나 메시지를 다운스트림으로 전달하기 전에 모든 선형 공백을 단일 SP로 바꿀 수 있습니다.\(MAY\)

```text
       LWS            = [CRLF] 1*( SP | HT )
```

TEXT 규칙은 메시지 구문 분석기에 의해 해석되지 않는 설명 필드 내용 및 값에만 사용됩니다. \*TEXT의 단어에는 RFC 2047\[14\]의 규칙에 따라 인코딩된 경우에만 ISO-8859-1\[22\] 이외의 문자 집합의 문자가 포함될 수 있습니다.\(MAY\)

```text
       TEXT           = <any OCTET except CTLs,
                        but including LWS>
```

CRLF는 헤더 필드 연속의 일부로만 TEXT 정의에서 허용됩니다. TEXT 값을 해석하기 전에는 접이식 LWS가 단일 SP로 대체될 것으로 예상됩니다.

16진수 문자는 여러 프로토콜 요소에 사용됩니다.

```text
       HEX            = "A" | "B" | "C" | "D" | "E" | "F"
                      | "a" | "b" | "c" | "d" | "e" | "f" | DIGIT
```

많은 HTTP/1.1 헤더 필드 값은 LWS 또는 특수 문자로 구분된 단어로 구성됩니다. 이러한 특수 문자는 매개변수 값\(섹션 3.6에 정의된 대로\) 내에서 사용되도록 인용 문자열에 있어야 합니다.\(MUST\)

```text
       token          = 1*<any CHAR except CTLs or separators>
       separators     = "(" | ")" | "<" | ">" | "@"
                      | "," | ";" | ":" | "\" | <">
                      | "/" | "[" | "]" | "?" | "="
                      | "{" | "}" | SP | HT
```

주석 텍스트를 괄호로 묶어 일부 HTTP 헤더 필드에 주석을 포함할 수 있습니다. 설명은 필드 값 정의의 일부로 "설명"을 포함하는 필드에서만 허용됩니다. 다른 모든 필드에서는 괄호가 필드 값의 일부로 간주됩니다.

```text
       comment        = "(" *( ctext | quoted-pair | comment ) ")"
       ctext          = <any TEXT excluding "(" and ")">
```

텍스트 문자열이 큰따옴표를 사용하여 인용된 경우 단일 단어로 구문 분석됩니다.

```text
       quoted-string  = ( <"> *(qdtext | quoted-pair ) <"> )
       qdtext         = <any TEXT except <">>
```

백슬래시 문자\("\"\)는 인용 문자열 및 주석 구성 내에서만 단일 문자 인용 메커니즘으로 사용될 수 있습니다.\(MAY\)

```text
       quoted-pair    = "\" CHAR
```

---
# **3 Protocol Parameters**
---
## **3.1 HTTP Version**

HTTP는 "<major\>.<minor\>" 번호 지정 체계를 사용하여 프로토콜 버전을 나타냅니다. 프로토콜 버전 관리 정책은 보낸 사람이 해당 통신을 통해 얻은 기능보다는 추가 HTTP 통신을 이해하기 위한 메시지 형식과 용량을 표시할 수 있도록 하기 위한 것입니다. 통신 동작에 영향을 주지 않거나 확장 가능한 필드 값에만 추가되는 메시지 구성 요소를 추가하는 경우 버전 번호는 변경되지 않습니다. <minor\> 번호는 일반 메시지 구문 분석 알고리즘을 변경하지 않지만 메시지 의미를 추가하고 보낸 사람의 추가 기능을 암시할 수 있는 프로토콜 추가 기능에 대한 변경 사항이 있을 때 증가됩니다. <major\> 번호는 프로토콜 내의 메시지 형식이 변경되면 증가됩니다. 자세한 설명은 RFC 2145 \[36\]을 참조하세요.

HTTP 메시지의 버전은 메시지의 첫 번째 줄에 있는 HTTP-Version 필드로 표시됩니다.

```text
       HTTP-Version   = "HTTP" "/" 1*DIGIT "." 1*DIGIT
```

메이저 및 마이너 숫자는 별도의 정수로 처리되어야 하며 각각은 한 자리보다 높게 증가할 수 있습니다. 따라서 HTTP/2.4는 HTTP/2.13보다 낮은 버전이고 HTTP/12.3보다 낮은 버전입니다. 수신자는 선행 0을 무시해야 하며 전송해서는 안 됩니다.\(MUST, MUST NOT\)

"HTTP/1.1"의 HTTP 버전을 포함하는 요청 또는 응답 메시지를 보내는 애플리케이션은 최소한 조건부로 이 사양을 준수해야 합니다. 최소한 이 사양을 조건부로 준수하는 애플리케이션은 메시지에서 HTTP 버전 "HTTP/1.1"을 사용해야 하며, HTTP/1.0과 호환되지 않는 모든 메시지에 대해 그렇게 해야 합니다. 특정 HTTP 버전 값을 보내는 시기에 대한 자세한 내용은 RFC 2145 \[36\]을 참조하세요.\(MUST, MUST\)

애플리케이션의 HTTP 버전은 애플리케이션이 최소한 조건부로 호환되는 가장 높은 HTTP 버전입니다.

프록시 및 게이트웨이 애플리케이션은 애플리케이션과 다른 프로토콜 버전으로 메시지를 전달할 때 주의해야 합니다. 프로토콜 버전은 발신자의 프로토콜 기능을 나타내기 때문에 프록시/게이트웨이는 실제 버전보다 높은 버전 표시가 있는 메시지를 보내서는 안 됩니다. 더 높은 버전의 요청이 수신되면 프록시/게이트웨이는 요청 버전을 다운그레이드하거나 오류로 응답하거나 터널 동작으로 전환해야 합니다.\(MUST NOT, MUST\)

RFC 2068\[33\]이 발표된 이후 발견된 HTTP/1.0 프록시의 상호 운용성 문제로 인해 캐싱 프록시는 반드시\(MUST\), 게이트웨이는\(MAY\), 터널은 요청을 지원하는 최고 버전으로 업그레이드해서는 안 됩니다\(MUST NOT\). 해당 요청에 대한 프록시/게이트웨이의 응답은 요청과 동일한 주요 버전이어야 합니다.\(MUST NOT, MUST\)

- 참고: HTTP 버전 간 변환에는 관련 버전에서 요구하거나 금지하는 헤더 필드의 수정이 포함될 수 있습니다.

---
## **3.2 Uniform Resource Identifiers**

URI는 WWW 주소, 범용 문서 식별자\(Universal Document Identifier\), 범용 자원 식별자\(Universal Resource Identifier\)\[3\], 그리고 마지막으로 URL\(Uniform Resource Locator\)\[4\]과 이름\(URN\)\[20\]의 조합 등 다양한 이름으로 알려져 있습니다. HTTP에 관한 한, 통일 자원 식별자는 이름, 위치 또는 기타 특성을 통해 자원을 식별하는 단순한 형식의 문자열입니다.

---
### **3.2.1 General Syntax**

HTTP의 URI는 사용 상황에 따라 절대 형식이나 일부 알려진 기본 URI\[11\]에 상대적인 형식으로 표시될 수 있습니다. 두 형식은 절대 URI가 항상 체계 이름으로 시작하고 그 뒤에 콜론이 따른다는 사실로 구별됩니다. URL 구문 및 의미 체계에 대한 최종 정보는 "URI\(Uniform Resource Identifiers\): 일반 구문 및 의미 체계", RFC 2396 \[42\]\(RFC 1738 \[4\] 및 RFC 1808 \[11\] 대체\)을 참조하세요. 이 사양은 해당 사양의 "URI-reference", "absoluteURI", "relativeURI", "port", "host", "abs\_path", "rel\_path" 및 "authority"의 정의를 채택합니다.

HTTP 프로토콜은 URI 길이에 사전 제한을 두지 않습니다. 서버는 자신이 제공하는 모든 리소스의 URI를 처리할 수 있어야 하며\(MUST\) 이러한 URI를 생성할 수 있는 GET 기반 양식을 제공하는 경우 제한 없는 길이의 URI를 처리할 수 있어야 합니다\(SHOULD\). URI가 서버가 처리할 수 있는 것보다 길면 서버는 414\(Request-URI Too Long\) 상태를 반환해야 합니다\(섹션 10.4.15 참조\).\(MUST, SHOULD\)

- 참고: 서버는 255바이트를 초과하는 URI 길이에 따라 주의해야 합니다. 일부 이전 클라이언트 또는 프록시 구현에서는 이러한 길이를 제대로 지원하지 않을 수 있기 때문입니다.

---
### **3.2.2 http URL**

"http" 구성표는 HTTP 프로토콜을 통해 네트워크 리소스를 찾는 데 사용됩니다. 이 섹션에서는 http URL에 대한 체계별 구문과 의미를 정의합니다.

```text
   http_URL = "http:" "//" host [ ":" port ] [ abs_path [ "?" query ]]
```

포트가 비어 있거나 지정되지 않은 경우 포트 80이 가정됩니다. 의미론은 식별된 리소스가 해당 호스트의 해당 포트에서 TCP 연결을 수신하는 서버에 있고 리소스에 대한 요청-URI가 abs\_path\(섹션 5.1.2\)라는 것입니다. URL에 IP 주소를 사용하는 것은 가능하면 피해야 합니다\(RFC 1900 \[24\] 참조\). URL에 abs\_path가 없으면 리소스에 대한 요청-URI로 사용될 때 "/"로 제공되어야 합니다\(섹션 5.1.2\). 프록시가 정규화된 도메인 이름이 아닌 호스트 이름을 수신하는 경우 수신한 호스트 이름에 해당 도메인을 추가할 수 있습니다. 프록시가 정규화된 도메인 이름을 수신하는 경우 프록시는 호스트 이름을 변경해서는 안 됩니다.\(SHOULD, MUST, MAY, MUST NOT\)

---
### **3.2.3 URI Comparison**

일치 여부를 결정하기 위해 두 개의 URI를 비교할 때 클라이언트는 다음 예외를 제외하고 전체 URI에 대해 대/소문자를 구분하는 옥텟별 비교를 사용해야 합니다.\(SHOULD\)

```text
      - A port that is empty or not given is equivalent to the default
        port for that URI-reference;

        - Comparisons of host names MUST be case-insensitive;

        - Comparisons of scheme names MUST be case-insensitive;
```

- - 빈 abs\_path는 "/"의 abs\_path와 동일합니다.

"예약된" 및 "안전하지 않은" 집합\(RFC 2396 \[42\] 참조\) 이외의 문자는 해당 ""%" HEX HEX" 인코딩과 동일합니다.

예를 들어 다음 세 개의 URI는 동일합니다.

```text
      http://abc.com:80/~smith/home.html
      http://ABC.com/%7Esmith/home.html
      http://ABC.com:/%7esmith/home.html
```

---
## **3.3 Date/Time Formats**
---
### **3.3.1 Full Date**

HTTP 애플리케이션은 역사적으로 날짜/시간 스탬프 표시에 대해 세 가지 다른 형식을 허용했습니다.

```text
      Sun, 06 Nov 1994 08:49:37 GMT  ; RFC 822, updated by RFC 1123
      Sunday, 06-Nov-94 08:49:37 GMT ; RFC 850, obsoleted by RFC 1036
      Sun Nov  6 08:49:37 1994       ; ANSI C's asctime() format
```

첫 번째 형식은 인터넷 표준으로 선호되며 RFC 1123\[8\]\(RFC 822\[9\]에 대한 업데이트\)에 의해 정의된 형식의 고정 길이 하위 집합을 나타냅니다. 두 번째 형식은 일반적으로 사용되지만 더 이상 사용되지 않는 RFC 850 \[12\] 날짜 형식을 기반으로 하며 4자리 연도가 없습니다. 날짜 값을 구문 분석하는 HTTP/1.1 클라이언트와 서버는 헤더 필드에서 HTTP 날짜 값을 표현하기 위해 RFC 1123 형식만 생성해야 하지만\(HTTP/1.0과의 호환성을 위해\) 세 가지 형식을 모두 허용해야 합니다. 자세한 내용은 섹션 19.3을 참조하세요.\(MUST\)

- 참고: 날짜 값 수신자는 프록시/게이트웨이를 통해 SMTP 또는 NNTP로 메시지를 검색하거나 게시할 때와 같이 HTTP가 아닌 응용 프로그램에서 전송했을 수 있는 날짜 값을 엄격하게 수락하도록 권장됩니다.

모든 HTTP 날짜/시간 스탬프는 예외 없이 그리니치 표준시\(GMT\)로 표시되어야 합니다. HTTP의 경우 GMT는 UTC\(협정 세계시\)와 정확히 동일합니다. 이는 시간대에 대한 세 글자 약어로 "GMT"를 포함하여 처음 두 형식으로 표시되며 asctime 형식을 읽을 때 가정해야 합니다. HTTP 날짜는 대소문자를 구분하며 문법에 SP로 특별히 포함된 것 이상의 추가 LWS를 포함해서는 안 됩니다.\(MUST, MUST, MUST NOT\)

```text
       HTTP-date    = rfc1123-date | rfc850-date | asctime-date
       rfc1123-date = wkday "," SP date1 SP time SP "GMT"
       rfc850-date  = weekday "," SP date2 SP time SP "GMT"
       asctime-date = wkday SP date3 SP time SP 4DIGIT
       date1        = 2DIGIT SP month SP 4DIGIT
                      ; day month year (e.g., 02 Jun 1982)
       date2        = 2DIGIT "-" month "-" 2DIGIT
                      ; day-month-year (e.g., 02-Jun-82)
       date3        = month SP ( 2DIGIT | ( SP 1DIGIT ))
                      ; month day (e.g., Jun  2)
       time         = 2DIGIT ":" 2DIGIT ":" 2DIGIT
                      ; 00:00:00 - 23:59:59
       wkday        = "Mon" | "Tue" | "Wed"
                    | "Thu" | "Fri" | "Sat" | "Sun"
       weekday      = "Monday" | "Tuesday" | "Wednesday"
                    | "Thursday" | "Friday" | "Saturday" | "Sunday"
       month        = "Jan" | "Feb" | "Mar" | "Apr"
                    | "May" | "Jun" | "Jul" | "Aug"
                    | "Sep" | "Oct" | "Nov" | "Dec"
```

- 참고: 날짜/시간 스탬프 형식에 대한 HTTP 요구 사항은 프로토콜 스트림 내에서의 사용에만 적용됩니다. 클라이언트와 서버는 사용자 표시, 요청 로깅 등에 이러한 형식을 사용할 필요가 없습니다.

---
### **3.3.2 Delta Seconds**

일부 HTTP 헤더 필드에서는 메시지가 수신된 시간 이후의 시간 값을 10진수로 표시되는 정수\(초\)로 지정할 수 있습니다.

```text
       delta-seconds  = 1*DIGIT
```

---
## **3.4 Character Sets**

HTTP는 MIME에 대해 설명된 것과 동일한 "문자 집합"이라는 용어 정의를 사용합니다.

이 문서에서 "문자 집합"이라는 용어는 일련의 옥텟을 문자 시퀀스로 변환하기 위해 하나 이상의 테이블에 사용되는 방법을 나타내기 위해 사용됩니다. 지정된 문자 세트에서 모든 문자를 사용할 수 있는 것은 아니며 문자 세트가 특정 문자를 나타내기 위해 두 개 이상의 옥텟 시퀀스를 제공할 수 있다는 점에서 반대 방향의 무조건적인 변환은 필요하지 않습니다. 이 정의는 US-ASCII와 같은 간단한 단일 테이블 매핑부터 ISO-2022 기술을 사용하는 것과 같은 복잡한 테이블 전환 방법에 이르기까지 다양한 종류의 문자 인코딩을 허용하기 위한 것입니다. 그러나 MIME 문자 집합 이름과 관련된 정의는 옥텟에서 문자로 수행될 매핑을 완전히 지정해야 합니다. 특히, 정확한 매핑을 결정하기 위해 외부 프로파일링 정보를 사용하는 것은 허용되지 않습니다.\(MUST\)

- 참고: "문자 집합"이라는 용어를 사용하는 것은 일반적으로 "문자 인코딩"이라고 합니다. 그러나 HTTP와 MIME은 동일한 레지스트리를 공유하므로 용어도 공유하는 것이 중요합니다.

HTTP 문자 집합은 대소문자를 구분하지 않는 토큰으로 식별됩니다. 전체 토큰 세트는 IANA 문자 세트 레지스트리\[19\]에 의해 정의됩니다.

```text
       charset = token
```

HTTP는 임의의 토큰을 charset 값으로 사용할 수 있도록 허용하지만 IANA 문자 집합 레지스트리\[19\] 내에서 미리 정의된 값을 가진 모든 토큰은 해당 레지스트리에서 정의된 문자 집합을 나타내야 합니다. 애플리케이션은 문자 집합 사용을 IANA 레지스트리에서 정의한 문자 집합으로 제한해야 합니다.\(MUST, SHOULD\)

구현자는 IETF 문자 집합 요구 사항 \[38\] \[41\]을 알고 있어야 합니다.

---
### **3.4.1 Missing Charset**

일부 HTTP/1.0 소프트웨어는 charset 매개변수가 없는 Content-Type 헤더를 "수신자가 추측해야 함"을 의미하도록 잘못 해석했습니다. 이 동작을 방지하려는 발신자는 문자 세트가 ISO-8859-1인 경우에도 문자 세트 매개변수를 포함할 수 있으며 수신자를 혼동하지 않을 것으로 알려진 경우에는 그렇게 해야 합니다.\(SHOULD\)

불행하게도 일부 이전 HTTP/1.0 클라이언트는 명시적 문자 집합 매개변수를 제대로 처리하지 못했습니다. HTTP/1.1 수신자는 발신자가 제공한 문자 집합 레이블을 존중해야 합니다. 그리고 문자 세트를 "추측"할 수 있는 조항이 있는 사용자 에이전트는 반드시 해당 문자 세트를 사용해야 합니다.\(MUST\)

문서를 처음 표시할 때 수신자의 기본 설정이 아닌 해당 문자 세트를 지원하는 경우 content-type 필드입니다. 섹션 3.7.1을 참조하세요.

---
## **3.5 Content Codings**

콘텐츠 코딩 값은 엔터티에 적용되었거나 적용될 수 있는 인코딩 변환을 나타냅니다. 콘텐츠 코딩은 기본 미디어 유형의 정체성을 잃지 않고 정보 손실 없이 문서를 압축하거나 유용하게 변환할 수 있도록 하는 데 주로 사용됩니다. 엔터티는 코딩된 형식으로 저장되고 직접 전송되며 수신자만 디코딩하는 경우가 많습니다.

```text
       content-coding   = token
```

모든 콘텐츠 코딩 값은 대소문자를 구분하지 않습니다. HTTP/1.1은 Accept-Encoding\(섹션 14.3\) 및 Content-Encoding\(섹션 14.11\) 헤더 필드에서 콘텐츠 코딩 값을 사용합니다. 값은 콘텐츠 코딩을 설명하지만 더 중요한 것은 인코딩을 제거하는 데 필요한 디코딩 메커니즘이 무엇인지 나타내는 것입니다.

IANA\(Internet Assigned Numbers Authority\)는 콘텐츠 코딩 가치 토큰을 위한 레지스트리 역할을 합니다. 처음에 레지스트리에는 다음 토큰이 포함되어 있습니다.

gzip RFC 1952 \[25\]에 설명된 대로 파일 압축 프로그램 "gzip"\(GNU zip\)에 의해 생성된 인코딩 형식입니다. 이 형식은 32비트 CRC를 사용하는 Lempel-Ziv 코딩\(LZ77\)입니다.

압박 붕대

- 일반적인 UNIX 파일 압축 프로그램 "compress"에 의해 생성된 인코딩 형식입니다. 이 형식은 적응형 Lempel-Ziv-Welch 코딩\(LZW\)입니다.

- 인코딩 형식을 식별하기 위해 프로그램 이름을 사용하는 것은 바람직하지 않으며 향후 인코딩에서는 권장되지 않습니다. 여기서의 사용은 좋은 디자인이 아니라 역사적 관행을 대표합니다. HTTP의 이전 구현과의 호환성을 위해 애플리케이션은 "x-gzip" 및 "x-compress"를 각각 "gzip" 및 "compress"와 동일한 것으로 간주해야 합니다.\(SHOULD\)

꺾다

- RFC 1951 \[29\]에 설명된 "deflate" 압축 메커니즘과 결합하여 RFC 1950 \[31\]에 정의된 "zlib" 형식입니다.

신원

- 기본\(신원\) 인코딩입니다. 아무런 변형도 사용하지 않습니다. 이 콘텐츠 코딩은 Accept-Encoding 헤더에서만 사용되며 Content-Encoding 헤더에서는 사용되어서는 안 됩니다.\(SHOULD NOT\)

새로운 콘텐츠 코딩 값 토큰을 등록해야 합니다. 클라이언트와 서버 간의 상호 운용성을 허용하려면 새로운 값을 구현하는 데 필요한 콘텐츠 코딩 알고리즘의 사양이 공개적으로 사용 가능하고 독립적인 구현에 적합해야 하며 이 섹션에 정의된 콘텐츠 코딩의 목적을 준수해야 합니다.\(SHOULD\)

---
## **3.6 Transfer Codings**

전송 코딩 값은 네트워크를 통한 "안전한 전송"을 보장하기 위해 엔터티 본문에 적용되었거나 적용될 수 있거나 적용될 필요가 있는 인코딩 변환을 나타내는 데 사용됩니다. 이는 전송 코딩이 원본 엔터티가 아닌 메시지의 속성이라는 점에서 콘텐츠 코딩과 다릅니다.

```text
       transfer-coding         = "chunked" | transfer-extension
       transfer-extension      = token *( ";" parameter )
```

매개변수는 속성/값 쌍의 형태입니다.

```text
       parameter               = attribute "=" value
       attribute               = token
       value                   = token | quoted-string
```

모든 전송 코딩 값은 대소문자를 구분하지 않습니다. HTTP/1.1은 TE 헤더 필드\(섹션 14.39\) 및 Transfer-Encoding 헤더 필드\(섹션 14.41\)에서 전송 코딩 값을 사용합니다.

전송 코딩이 메시지 본문에 적용될 때마다 연결을 닫아 메시지가 종료되지 않는 한 전송 코딩 집합에는 "청크"가 포함되어야 합니다. "청크된" 전송 코딩이 사용되는 경우 메시지 본문에 적용된 마지막 전송 코딩이어야 합니다. "청크된" 전송 코딩은 메시지 본문에 두 번 이상 적용되어서는 안 됩니다. 이러한 규칙을 통해 수신자는 메시지의 전송 길이를 결정할 수 있습니다\(섹션 4.4\).\(MUST, MUST, MUST NOT\)

전송 코딩은 7비트 전송 서비스를 통해 바이너리 데이터를 안전하게 전송할 수 있도록 설계된 MIME \[7\]의 Content-Transfer-Encoding 값과 유사합니다. 그러나 안전한 전송은 8비트 클린 전송 프로토콜의 초점이 다릅니다. HTTP에서 메시지 본문의 안전하지 않은 유일한 특징은 정확한 본문 길이\(섹션 7.2.2\)를 결정하기 어렵거나 공유 전송을 통해 데이터를 암호화하려는 욕구입니다.

IANA\(Internet Assigned Numbers Authority\)는 전송 코딩 가치 토큰을 위한 등록 기관 역할을 합니다. 처음에 레지스트리에는 "chunked"\(섹션 3.6.1\), "identity"\(섹션 3.6.2\), "gzip"\(섹션 3.5\), "compress"\(섹션 3.5\) 및 "deflate"\(섹션\) 토큰이 포함되어 있습니다. 섹션 3.5\).

새로운 전송 코딩 가치 토큰은 새로운 콘텐츠 코딩 가치 토큰과 동일한 방식으로 등록되어야 합니다\(섹션 3.5\).\(SHOULD\)

이해하지 못하는 전송 코딩이 포함된 엔터티 본문을 수신하는 서버는 501\(구현되지 않음\)을 반환하고 연결을 닫아야 합니다. 서버는 HTTP/1.0 클라이언트에 전송 코딩을 보내면 안 됩니다.\(SHOULD, MUST NOT\)

---
### **3.6.1 Chunked Transfer Coding**

청크 인코딩은 메시지 본문을 일련의 청크로 전송하기 위해 수정합니다. 각 청크에는 고유한 크기 표시기가 있고 그 뒤에 엔터티 헤더 필드가 포함된 선택적 트레일러가 옵니다. 이를 통해 수신자가 전체 메시지를 수신했는지 확인하는 데 필요한 정보와 함께 동적으로 생성된 콘텐츠를 전송할 수 있습니다.\(MAY\)

```text
       Chunked-Body   = *chunk
                        last-chunk
                        trailer
                        CRLF

       chunk          = chunk-size [ chunk-extension ] CRLF
                        chunk-data CRLF
       chunk-size     = 1*HEX
       last-chunk     = 1*("0") [ chunk-extension ] CRLF

       chunk-extension= *( ";" chunk-ext-name [ "=" chunk-ext-val ] )
       chunk-ext-name = token
       chunk-ext-val  = token | quoted-string
       chunk-data     = chunk-size(OCTET)
       trailer        = *(entity-header CRLF)
```

청크 크기 필드는 청크의 크기를 나타내는 16진수 문자열입니다. 청크 인코딩은 크기가 0인 청크로 끝나고 빈 줄로 끝나는 트레일러가 이어집니다.

트레일러를 사용하면 발신자가 메시지 끝에 추가 HTTP 헤더 필드를 포함할 수 있습니다. Trailer 헤더 필드는 어떤 헤더 필드가 트레일러에 포함되어 있는지 나타내는 데 사용될 수 있습니다\(14.40절 참조\).

응답에 청크 전송 코딩을 사용하는 서버는 다음 중 하나 이상이 참이 아닌 이상 헤더 필드에 대한 트레일러를 사용해서는 안 됩니다.\(MUST NOT\)

a\) 요청에는 섹션 14.39에 설명된 대로 응답의 전송 코딩에서 "트레일러"가 허용됨을 나타내는 TE 헤더 필드가 포함되어 있습니다. 또는,

b\) 서버는 응답에 대한 원서버이고, 트레일러 필드는 전적으로 선택적 메타데이터로 구성되며, 수신자는 이 메타데이터를 수신하지 않고도 \(원서버가 허용하는 방식으로\) 메시지를 사용할 수 있습니다. 즉, 원본 서버는 클라이언트에 대한 경로를 따라 트레일러 필드가 자동으로 삭제될 수 있는 가능성을 기꺼이 받아들입니다.

이 요구 사항은 메시지가 HTTP/1.1\(또는 이상\) 프록시에서 수신되어 HTTP/1.0 수신자에게 전달될 때 상호 운용성 오류를 방지합니다. 이는 프로토콜 준수로 인해 프록시에 무한 버퍼가 필요할 수 있는 상황을 방지합니다.

Chunked-Body를 디코딩하는 프로세스의 예가 부록 19.4.6에 나와 있습니다.

모든 HTTP/1.1 애플리케이션은 "청크된" 전송 코딩을 수신하고 디코딩할 수 있어야 하며, 이해하지 못하는 청크 확장 확장을 무시해야 합니다.\(MUST\)

---
## **3.7 Media Types**

HTTP는 개방적이고 확장 가능한 데이터 유형 지정 및 유형 협상을 제공하기 위해 Content-Type\(섹션 14.17\) 및 Accept\(섹션 14.1\) 헤더 필드에서 인터넷 미디어 유형\[17\]을 사용합니다.

```text
       media-type     = type "/" subtype *( ";" parameter )
       type           = token
       subtype        = token
```

매개변수는 속성/값 쌍의 형태로 유형/하위 유형을 따를 수 있습니다\(섹션 3.6에 정의됨\).\(MAY\)

유형, 하위 유형 및 매개변수 속성 이름은 대소문자를 구분하지 않습니다. 매개변수 값은 매개변수 이름의 의미에 따라 대소문자를 구분할 수도 있고 그렇지 않을 수도 있습니다. 선형 공백\(LWS\)은 유형과 하위 유형 사이, 속성과 해당 값 사이에 사용되어서는 안 됩니다. 매개변수의 유무는 미디어 유형 레지스트리 내의 정의에 따라 미디어 유형 처리에 중요할 수 있습니다.\(MUST NOT\)

일부 이전 HTTP 애플리케이션은 미디어 유형 매개변수를 인식하지 못합니다. 이전 HTTP 애플리케이션으로 데이터를 전송할 때 구현은 해당 유형/하위 유형 정의에서 요구하는 경우에만 미디어 유형 매개변수를 사용해야 합니다.\(SHOULD\)

미디어 유형 값은 IANA \[19\]\)에 등록됩니다. 미디어 유형 등록 프로세스는 RFC 1590 \[17\]에 요약되어 있습니다. 등록되지 않은 미디어 유형의 사용은 권장되지 않습니다.

---
### **3.7.1 Canonicalization and Text Defaults**

인터넷 미디어 유형은 표준 형식으로 등록됩니다. HTTP 메시지를 통해 전송되는 엔터티 본문은 다음 단락에 정의된 "텍스트" 유형을 제외하고 전송 전에 적절한 표준 형식으로 표현되어야 합니다.\(MUST\)

표준 형식인 경우 "텍스트" 유형의 미디어 하위 유형은 CRLF를 텍스트 줄 바꿈으로 사용합니다. HTTP는 이 요구 사항을 완화하고 전체 엔터티 본문에 대해 일관되게 수행될 때 줄바꿈을 나타내는 일반 CR 또는 LF만으로 텍스트 미디어 전송을 허용합니다. HTTP 애플리케이션은 HTTP를 통해 수신된 텍스트 미디어의 줄 바꿈을 나타내는 CRLF, 베어 CR 및 베어 LF를 허용해야 합니다. 또한 텍스트가 일부 멀티바이트 문자 집합의 경우처럼 CR과 LF에 각각 옥텟 13과 10을 사용하지 않는 문자 집합으로 표현되는 경우 HTTP는 해당 옥텟 시퀀스에 의해 정의된 모든 옥텟 시퀀스의 사용을 허용합니다. 줄 바꿈에 대해 CR 및 LF와 동일한 문자 집합입니다. 줄 바꿈에 대한 이러한 유연성은 엔터티 본문의 텍스트 미디어에만 적용됩니다. 베어 CR 또는 LF는 HTTP 제어 구조\(예: 헤더 필드 및 멀티파트 경계\) 내에서 CRLF를 대체해서는 안 됩니다.\(MUST, MUST NOT\)

엔터티 본문이 콘텐츠 코딩으로 인코딩된 경우 기본 데이터는 인코딩되기 전에 위에 정의된 형식이어야 합니다.\(MUST\)

"charset" 매개변수는 일부 미디어 유형에서 데이터의 문자 세트\(섹션 3.4\)를 정의하는 데 사용됩니다. 보낸 사람이 명시적인 charset 매개 변수를 제공하지 않으면 "text" 유형의 미디어 하위 유형은 HTTP를 통해 수신될 때 "ISO-8859-1"의 기본 문자 집합 값을 갖도록 정의됩니다. "ISO-8859-1" 또는 그 하위 집합 이외의 문자 집합의 데이터는 적절한 문자 집합 값으로 레이블을 지정해야 합니다. 호환성 문제는 섹션 3.4.1을 참조하세요.\(MUST\)

---
### **3.7.2 Multipart Types**

MIME은 단일 메시지 본문 내에 하나 이상의 엔터티를 캡슐화하는 다양한 "다중 부분" 유형을 제공합니다. 모든 다중 부분 유형은 RFC 2046의 섹션 5.1.1에 정의된 대로 공통 구문을 공유합니다.

\[40\], 미디어 유형 값의 일부로 경계 매개변수를 포함해야 합니다. 메시지 본문은 그 자체로 프로토콜 요소이므로 본문 부분 사이의 줄 바꿈을 나타내기 위해 CRLF만 사용해야 합니다. RFC 2046과 달리 다중 부분 메시지의 에필로그는 비어 있어야 합니다. HTTP 애플리케이션은 에필로그를 전송해서는 안 됩니다\(원래 멀티파트에 에필로그가 포함된 경우에도\). 이러한 제한은 다중 부분 메시지 본문의 자체 구분 특성을 유지하기 위해 존재하며 메시지 본문의 "끝"은 끝 다중 부분 경계로 표시됩니다.\(MUST, MUST, MUST NOT\)

일반적으로 HTTP는 다중 부분 메시지 본문을 다른 미디어 유형과 다르지 않게, 즉 엄격히 페이로드로 처리합니다. 한 가지 예외는 206\(부분 콘텐츠\) 응답에 나타나는 "multipart/byteranges" 유형\(부록 19.2\)입니다. 이는 섹션 13.5.4 및 14.16에 설명된 대로 일부 HTTP 캐싱 메커니즘에 의해 해석됩니다. 다른 모든 경우에 HTTP 사용자 에이전트는 MIME 사용자 에이전트가 멀티파트 유형을 수신할 때와 동일하거나 유사한 동작을 따라야 합니다\(SHOULD\). 다중 부분 메시지 본문의 각 본문 부분에 있는 MIME 헤더 필드는 MIME 의미 체계에 의해 정의된 것 이상으로 HTTP에 아무런 의미가 없습니다.\(SHOULD\)

일반적으로 HTTP 사용자 에이전트는 MIME 사용자 에이전트가 멀티파트 유형을 수신할 때와 동일하거나 유사한 동작을 따라야 합니다\(SHOULD\). 애플리케이션이 인식할 수 없는 멀티파트 하위 유형을 수신하는 경우 애플리케이션은 이를 "멀티파트/혼합"과 동등한 것으로 처리해야 합니다.\(SHOULD, MUST\)

- 참고: "multipart/form-data" 유형은 RFC 1867 \[15\]에 설명된 대로 POST 요청 방법을 통해 처리하기에 적합한 양식 데이터를 전달하기 위해 특별히 정의되었습니다.

---
## **3.8 Product Tokens**

제품 토큰은 통신 응용 프로그램이 소프트웨어 이름과 버전으로 자신을 식별할 수 있도록 하는 데 사용됩니다. 제품 토큰을 사용하는 대부분의 필드에서는 애플리케이션의 상당 부분을 구성하는 하위 제품을 공백으로 구분하여 나열할 수도 있습니다. 일반적으로 제품은 용도를 식별하는 데 중요한 순서대로 나열됩니다.

```text
       product         = token ["/" product-version]
       product-version = token

   Examples:

       User-Agent: CERN-LineMode/2.15 libwww/2.17b3
       Server: Apache/0.8.4
```

제품 토큰은 짧고 명확해야 합니다. 광고나 기타 필수적이지 않은 정보에 사용해서는 안 됩니다. 모든 토큰 문자가 제품 버전에 나타날 수 있지만 이 토큰은 버전 식별자로만 사용해야 합니다\(즉, 동일한 제품의 연속 버전은 제품 값의 제품 버전 부분에서만 달라야 합니다\).\(SHOULD, MUST NOT, SHOULD\)

---
## **3.9 Quality Values**

HTTP 콘텐츠 협상\(섹션 12\)은 짧은 "부동 소수점" 숫자를 사용하여 다양한 협상 가능한 매개변수의 상대적 중요성\("가중치"\)을 나타냅니다. 가중치는 0\~1 범위의 실수로 정규화됩니다. 여기서 0은 최소값이고 1은 최대값입니다. 매개변수의 품질 값이 0이면 이 매개변수가 포함된 콘텐츠는 클라이언트에서 '허용되지 않습니다'. HTTP/1.1 애플리케이션은 소수점 이하 3자리 이상을 생성해서는 안 됩니다. 이러한 값의 사용자 구성도 이러한 방식으로 제한되어야 합니다.\(MUST NOT, SHOULD\)

```text
       qvalue         = ( "0" [ "." 0*3DIGIT ] )
                      | ( "1" [ "." 0*3("0") ] )
```

"품질 값"은 잘못된 이름입니다. 왜냐하면 이 값은 원하는 품질의 상대적인 저하를 나타낼 뿐이기 때문입니다.

---
## **3.10 Language Tags**

언어 태그는 다른 인간에게 정보를 전달하기 위해 인간이 말하거나, 쓰거나, 전달하는 자연어를 식별합니다. 컴퓨터 언어는 명시적으로 제외됩니다. HTTP는 Accept-Language 및 Content-Language 필드 내에서 언어 태그를 사용합니다.

HTTP 언어 태그의 구문과 레지스트리는 RFC 1766 \[1\]에 정의된 것과 동일합니다. 요약하면, 언어 태그는 하나 이상의 부분, 즉 기본 언어 태그와 비어 있을 수 있는 일련의 하위 태그로 구성됩니다.

```text
        language-tag  = primary-tag *( "-" subtag )
        primary-tag   = 1*8ALPHA
        subtag        = 1*8ALPHA
```

태그 내에는 공백이 허용되지 않으며 모든 태그는 대소문자를 구분하지 않습니다. 언어 태그의 네임스페이스는 IANA에서 관리합니다. 예제 태그는 다음과 같습니다.

```text
       en, en-US, en-cockney, i-cherokee, x-pig-latin
```

여기서 두 글자의 기본 태그는 ISO-639 언어 약어이고 두 글자의 초기 하위 태그는 ISO-3166 국가 코드입니다. \(위의 마지막 3개 태그는 등록된 태그가 아니며, 마지막을 제외한 모두 향후 등록될 수 있는 태그의 예입니다.\)

---
## **3.11 Entity Tags**

엔터티 태그는 동일한 요청 리소스에서 두 개 이상의 엔터티를 비교하는 데 사용됩니다. HTTP/1.1은 ETag\(섹션 14.19\), If-Match\(섹션 14.24\), If-None-Match\(섹션 14.26\) 및 If-Range\(섹션 14.27\) 헤더 필드의 엔터티 태그를 사용합니다. 캐시 유효성 검사기로 사용 및 비교되는 방법에 대한 정의는 섹션 13.3.3에 있습니다. 엔터티 태그는 불투명한 인용 문자열로 구성되며, 앞에 약점 표시자가 붙을 수도 있습니다.

```text
      entity-tag = [ weak ] opaque-tag
      weak       = "W/"
      opaque-tag = quoted-string
```

"강력한 엔터티 태그"는 옥텟 동등성에 의해 동등한 경우에만 리소스의 두 엔터티에 의해 공유될 수 있습니다.\(MAY\)

"W/" 접두사로 표시되는 "약한 엔터티 태그"는 엔터티가 동일하고 의미론에 큰 변화 없이 서로 대체될 수 있는 경우에만 리소스의 두 엔터티에 의해 공유될 수 있습니다. 약한 엔터티 태그는 약한 비교에만 사용할 수 있습니다.\(MAY\)

엔터티 태그는 특정 리소스와 관련된 모든 엔터티의 모든 버전에서 고유해야 합니다. 주어진 엔터티 태그 값은 다른 URI에 대한 요청으로 얻은 엔터티에 사용될 수 있습니다. 서로 다른 URI에 대한 요청으로 얻은 엔터티와 함께 ​​동일한 엔터티 태그 값을 사용한다고 해서 해당 엔터티가 동등하다는 의미는 아닙니다.\(MUST, MAY\)

---
## **3.12 Range Units**

HTTP/1.1을 사용하면 클라이언트가 응답 엔터티의 일부\(일부 범위\)만 응답에 포함되도록 요청할 수 있습니다. HTTP/1.1은 Range\(섹션 14.35\) 및 Content-Range\(섹션 14.16\) 헤더 필드에서 범위 단위를 사용합니다. 엔터티는 다양한 구조 단위에 따라 하위 범위로 분류될 수 있습니다.

```text
      range-unit       = bytes-unit | other-range-unit
      bytes-unit       = "bytes"
      other-range-unit = token
```

HTTP/1.1에서 정의된 유일한 범위 단위는 "바이트"입니다. HTTP/1.1 구현은 다른 단위를 사용하여 지정된 범위를 무시할 수 있습니다.\(MAY\)

HTTP/1.1은 범위 지식에 의존하지 않는 애플리케이션 구현을 허용하도록 설계되었습니다.

---
# **4 HTTP Message**
---
## **4.1 Message Types**

HTTP 메시지는 클라이언트에서 서버로의 요청과 서버에서 클라이언트로의 응답으로 구성됩니다.

```text
       HTTP-message   = Request | Response     ; HTTP/1.1 messages
```

요청\(섹션 5\) 및 응답\(섹션 6\) 메시지는 엔터티\(메시지의 페이로드\)를 전송하기 위해 RFC 822\[9\]의 일반 메시지 형식을 사용합니다. 두 가지 메시지 유형 모두 시작 줄, 0개 이상의 헤더 필드\("헤더"라고도 함\), 헤더 필드의 끝을 나타내는 빈 줄\(즉, CRLF 앞에 아무것도 없는 줄\)로 구성됩니다. 메시지 본문.

```text
        generic-message = start-line
                          *(message-header CRLF)
                          CRLF
                          [ message-body ]
        start-line      = Request-Line | Status-Line
```

견고성을 위해 서버는 요청 라인이 예상되는 곳에서 수신된 빈 라인을 무시해야 합니다. 즉, 서버가 메시지 시작 부분에서 프로토콜 스트림을 읽고 CRLF를 먼저 수신하는 경우 CRLF를 무시해야 합니다.\(SHOULD\)

특정 버그가 있는 HTTP/1.0 클라이언트 구현은 POST 요청 후에 추가 CRLF를 생성합니다. BNF에 의해 명시적으로 금지된 내용을 다시 설명하려면 HTTP/1.1 클라이언트는 요청 앞에 추가 CRLF를 추가하거나 뒤에 붙여서는 안 됩니다.\(MUST NOT\)

---
## **4.2 Message Headers**

일반 헤더\(섹션 4.5\), 요청 헤더\(섹션 5.3\), 응답 헤더\(섹션 6.2\) 및 엔터티 헤더\(섹션 7.1\) 필드를 포함하는 HTTP 헤더 필드는 섹션에 제공된 것과 동일한 일반 형식을 따릅니다. RFC 822 \[9\]의 3.1. 각 헤더 필드는 이름, 콜론\(":"\) 및 필드 값으로 구성됩니다. 필드 이름은 대소문자를 구분합니다. 필드 값 앞에는 임의의 LWS가 올 수 있지만 단일 SP가 선호됩니다. 헤더 필드는 각 추가 줄 앞에 최소한 하나의 SP 또는 HT를 추가하여 여러 줄로 확장할 수 있습니다. 응용 프로그램은 HTTP 구성을 생성할 때 알려진 또는 표시된 "공통 형식"을 따라야 합니다. 왜냐하면 어떤 것도 허용하지 않는 일부 구현이 있을 수 있기 때문입니다.\(MAY\)

일반적인 형태를 넘어서요.

```text
       message-header = field-name ":" [ field-value ]
       field-name     = token
       field-value    = *( field-content | LWS )
       field-content  = <the OCTETs making up the field-value
                        and consisting of either *TEXT or combinations
                        of token, separators, and quoted-string>
```

field-content에는 선행 또는 후행 LWS가 포함되지 않습니다. 즉, field-value의 공백이 아닌 첫 번째 문자 앞이나 field-value의 공백이 아닌 마지막 문자 뒤에 발생하는 선형 공백입니다. 이러한 선행 또는 후행 LWS는 필드 값의 의미를 변경하지 않고 제거될 수 있습니다. 필드 내용 사이에 발생하는 모든 LWS는 필드 값을 해석하거나 메시지 다운스트림을 전달하기 전에 단일 SP로 대체될 수 있습니다.\(MAY, MAY\)

필드 이름이 다른 헤더 필드가 수신되는 순서는 중요하지 않습니다. 그러나 일반 헤더 필드를 먼저 보낸 다음 요청 헤더 또는 응답 헤더 필드를 보내고 엔터티 헤더 필드로 끝나는 것이 "좋은 습관"입니다.

동일한 필드 이름을 가진 여러 메시지 헤더 필드는 해당 헤더 필드의 전체 필드 값이 쉼표로 구분된 목록\[예: #\(값\)\]으로 정의된 경우에만 메시지에 존재할 수 있습니다. 메시지의 의미를 변경하지 않고 여러 헤더 필드를 하나의 "필드-이름: 필드-값" 쌍으로 결합하는 것이 가능해야 하며, 각 후속 필드 값을 첫 번째 필드에 추가하고 각각을 쉼표로 구분해야 합니다. 따라서 동일한 field-name을 가진 헤더 필드가 수신되는 순서는 결합된 필드 값의 해석에 중요하므로 프록시는 메시지가 전달될 때 이러한 필드 값의 순서를 변경해서는 안 됩니다.\(MAY, MUST, MUST NOT\)

---
## **4.3 Message Body**

HTTP 메시지의 메시지 본문\(있는 경우\)은 요청 또는 응답과 관련된 엔터티 본문을 전달하는 데 사용됩니다. Message-Body는 Transfer-Encoding 헤더 필드\(섹션 14.41\)에 표시된 대로 전송 코딩이 적용된 경우에만 Entity-Body와 다릅니다.

```text
       message-body = entity-body
                    | <entity-body encoded as per Transfer-Encoding>
```

전송 인코딩은 메시지의 안전하고 적절한 전송을 보장하기 위해 애플리케이션이 적용한 전송 코딩을 나타내는 데 사용해야 합니다. 전송 인코딩은 메시지의 속성이 아닌 메시지의 속성입니다.\(MUST\)

엔터티이므로 요청/응답 체인을 따라 모든 애플리케이션에 의해 추가되거나 제거될 수 있습니다. \(그러나 섹션 3.6에서는 특정 전송 코딩을 사용할 수 있는 경우를 제한합니다.\)\(MAY\)

메시지에서 메시지 본문이 허용되는 경우에 대한 규칙은 요청과 응답에 따라 다릅니다.

요청에 메시지 본문이 있다는 것은 요청의 메시지 헤더에 Content-Length 또는 Transfer-Encoding 헤더 필드가 포함되어 있음을 나타냅니다. 요청 방법의 사양\(섹션 5.1.1\)이 요청에서 엔터티 본문 전송을 허용하지 않는 경우 메시지 본문은 요청에 포함되어서는 안 됩니다. 서버는 모든 요청에 ​​대해 메시지 본문을 읽고 전달해야 합니다. 요청 방법에 엔터티 본문에 대해 정의된 의미가 포함되어 있지 않으면 요청을 처리할 때 메시지 본문을 무시해야 합니다.\(MUST NOT, SHOULD\)

응답 메시지의 경우 메시지 본문이 메시지에 포함되는지 여부는 요청 방법과 응답 상태 코드\(섹션 6.1.1\)에 따라 달라집니다. HEAD 요청 방법에 대한 모든 응답은 비록 Entity-Header 필드가 존재한다고 믿게 만들 수 있더라도 message-body를 포함해서는 안 됩니다. 모든 1xx\(정보\), 204\(콘텐츠 없음\) 및 304\(수정되지 않음\) 응답에는 메시지 본문이 포함되어서는 안 됩니다. 다른 모든 응답에는 메시지 본문이 포함되지만 길이는 0일 수 있습니다.\(MUST NOT, MUST NOT, MAY\)

---
## **4.4 Message Length**

메시지의 전송 길이는 메시지에 나타나는 메시지 본문의 길이입니다. 즉, 전송 코딩이 적용된 후입니다. 메시지 본문이 메시지에 포함된 경우 해당 본문의 전송 길이는 다음 중 하나에 따라 결정됩니다\(우선순위\).

1. 메시지 본문을 포함해서는 안 되는 모든 응답 메시지\(예: 1xx, 204, 304 응답 및 HEAD 요청에 대한 응답\)는 헤더 필드 뒤의 첫 번째 빈 줄로 항상 종료됩니다. 메시지에 엔터티 헤더 필드가 있습니다.\(MUST NOT\)

2. Transfer-Encoding 헤더 필드\(섹션 14.41\)가 존재하고 "identity" 이외의 값을 갖는 경우 전송 길이는 "청크" 전송 코딩\(섹션 3.6\)을 사용하여 정의됩니다. 연결을 닫으면 종료됩니다.

3. Content-Length 헤더 필드\(섹션 14.13\)가 있는 경우 OCTET의 10진수 값은 엔터티 길이와 전송 길이를 모두 나타냅니다. Content-Length 헤더 필드는 이 두 길이가 다른 경우\(즉, Transfer-Encoding이 있는 경우\) 전송되어서는 안 됩니다.\(MUST NOT\)

헤더 필드가 존재함\). Transfer-Encoding 헤더 필드와 Content-Length 헤더 필드가 모두 포함된 메시지를 수신한 경우 후자는 무시해야 합니다.\(MUST\)

4. 메시지가 "multipart/byteranges" 미디어 유형을 사용하고 전송 길이가 별도로 지정되지 않은 경우 이 자체 제한 미디어 유형은 전송 길이를 정의합니다. 이 미디어 유형은 수신자가 이를 할당할 수 있다는 것을 발신자가 알지 않는 한 사용해서는 안 됩니다. 1.1 클라이언트의 여러 바이트 범위 지정자가 있는 Range 헤더 요청에 존재한다는 것은 클라이언트가 multipart/byteranges 응답을 구문 분석할 수 있음을 의미합니다.

- 범위 헤더는 multipart/byteranges를 이해하지 못하는 1.0 프록시에 의해 전달될 수 있습니다. 이 경우 서버는 이 섹션의 항목 1, 3 또는 5에 정의된 방법을 사용하여 메시지를 구분해야 합니다.\(MUST\)

5. 서버가 연결을 종료합니다. \(연결을 닫으면 서버가 응답을 다시 보낼 가능성이 없기 때문에 요청 본문의 끝을 나타내는 데 사용할 수 없습니다.\)

HTTP/1.0 애플리케이션과의 호환성을 위해, 메시지 본문을 포함하는 HTTP/1.1 요청은 서버가 HTTP/1.1을 준수하는 것으로 알려지지 않은 한 유효한 Content-Length 헤더 필드를 포함해야 합니다. 요청에 메시지 본문이 포함되어 있고 Content-Length가 제공되지 않은 경우 서버는 메시지 길이를 결정할 수 없으면 400\(잘못된 요청\)으로 응답해야 하고, 메시지 길이를 주장하려면 411\(길이 필요\)로 응답해야 합니다. 유효한 Content-Length를 수신합니다.\(MUST, SHOULD\)

엔터티를 수신하는 모든 HTTP/1.1 애플리케이션은 "청크" 전송 코딩\(섹션 3.6\)을 수락해야 하므로 메시지 길이를 미리 결정할 수 없는 경우 메시지에 이 메커니즘을 사용할 수 있습니다.\(MUST\)

메시지에는 Content-Length 헤더 필드와 비식별 전송 코딩이 모두 포함되어서는 안 됩니다. 메시지에 비ID 전송 코딩이 포함된 경우 Content-Length를 무시해야 합니다.\(MUST NOT, MUST\)

메시지 본문이 허용되는 메시지에 Content-Length가 제공되면 해당 필드 값은 메시지 본문의 OCTET 수와 정확히 일치해야 합니다. HTTP/1.1 사용자 에이전트는 유효하지 않은 길이가 수신되고 감지되면 사용자에게 알려야 합니다.\(MUST, MUST\)

---
## **4.5 General Header Fields**

요청 및 응답 메시지 모두에 일반적으로 적용 가능하지만 전송되는 엔터티에는 적용되지 않는 몇 가지 헤더 필드가 있습니다. 이러한 헤더 필드는 다음에만 적용됩니다.

```text
   message being transmitted.

       general-header = Cache-Control            ; Section 14.9
                      | Connection               ; Section 14.10
                      | Date                     ; Section 14.18
                      | Pragma                   ; Section 14.32
                      | Trailer                  ; Section 14.40
                      | Transfer-Encoding        ; Section 14.41
                      | Upgrade                  ; Section 14.42
                      | Via                      ; Section 14.45
                      | Warning                  ; Section 14.46
```

일반 헤더 필드 이름은 프로토콜 버전이 변경된 경우에만 안정적으로 확장될 수 있습니다. 그러나 통신의 모든 당사자가 일반 헤더 필드로 인식하는 경우 새롭거나 실험적인 헤더 필드에 일반 헤더 필드의 의미가 부여될 수 있습니다. 인식할 수 없는 헤더 필드는 엔터티 헤더 필드로 처리됩니다.

---
# **5 Request**

클라이언트에서 서버로 보내는 요청 메시지에는 해당 메시지의 첫 번째 줄에 리소스에 적용할 메서드, 리소스 식별자 및 사용 중인 프로토콜 버전이 포함됩니다.

```text
        Request       = Request-Line              ; Section 5.1
                        *(( general-header        ; Section 4.5
                         | request-header         ; Section 5.3
                         | entity-header ) CRLF)  ; Section 7.1
                        CRLF
                        [ message-body ]          ; Section 4.3
```

---
## **5.1 Request-Line**

Request-Line은 메소드 토큰으로 시작하고 그 뒤에 Request-URI와 프로토콜 버전이 오고 CRLF로 끝납니다. 요소는 SP 문자로 구분됩니다. 최종 CRLF 시퀀스를 제외하고 CR 또는 LF는 허용되지 않습니다.

```text
        Request-Line   = Method SP Request-URI SP HTTP-Version CRLF
```

---
### **5.1.1 Method**

Method 토큰은 Request-URI에 의해 식별된 리소스에 대해 수행될 메서드를 나타냅니다. 이 방법은 대소문자를 구분합니다.

```text
       Method         = "OPTIONS"                ; Section 9.2
                      | "GET"                    ; Section 9.3
                      | "HEAD"                   ; Section 9.4
                      | "POST"                   ; Section 9.5
                      | "PUT"                    ; Section 9.6
                      | "DELETE"                 ; Section 9.7
                      | "TRACE"                  ; Section 9.8
                      | "CONNECT"                ; Section 9.9
                      | extension-method
       extension-method = token
```

리소스에서 허용하는 메서드 목록은 Allow 헤더 필드\(섹션 14.7\)에서 지정할 수 있습니다. 허용된 메서드 집합은 동적으로 변경될 수 있으므로 응답의 반환 코드는 메서드가 현재 리소스에 허용되는지 여부를 항상 클라이언트에 알립니다. 원서버는 메소드가 원서버에 알려져 있지만 요청된 리소스에 허용되지 않는 경우 상태 코드 405\(허용되지 않는 메소드\)를 반환해야 하며, 원서버가 메소드를 인식하지 못하거나 구현하지 않은 경우 501\(구현되지 않음\)을 반환해야 합니다. GET 및 HEAD 메소드는 모든 범용 서버에서 지원되어야 합니다. 다른 모든 방법은 선택사항입니다. 그러나 위의 방법이 구현되는 경우 섹션 9에 지정된 것과 동일한 의미로 구현되어야 합니다.\(SHOULD, MUST, MUST\)

---
### **5.1.2 Request-URI**

요청-URI는 통일 자원 식별자\(섹션 3.2\)이며 요청을 적용할 자원을 식별합니다.

```text
       Request-URI    = "*" | absoluteURI | abs_path | authority
```

Request-URI의 네 가지 옵션은 요청의 성격에 따라 다릅니다. 별표 "\*"는 요청이 특정 리소스에 적용되지 않고 서버 자체에 적용되며 사용된 방법이 반드시 리소스에 적용되지 않는 경우에만 허용됨을 의미합니다. 한 가지 예는 다음과 같습니다.

```text
       OPTIONS * HTTP/1.1
```

요청이 프록시에 이루어질 때 절대URI 형식이 필요합니다. 프록시는 요청을 전달하거나 유효한 캐시에서 서비스를 제공하고 응답을 반환하도록 요청됩니다. 프록시는 요청을 다른 프록시로 전달하거나 서버로 직접 전달할 수 있습니다.\(MUST, MAY\)

절대URI로 지정됩니다. 요청 루프를 피하기 위해 프록시는 별칭, 로컬 변형 및 숫자 IP 주소를 포함하여 모든 서버 이름을 인식할 수 있어야 합니다. 요청 라인의 예는 다음과 같습니다.\(MUST\)

```text
       GET http://www.w3.org/pub/WWW/TheProject.html HTTP/1.1
```

향후 버전의 HTTP의 모든 요청에서 절대URI로의 전환을 허용하려면 모든 HTTP/1.1 서버는 HTTP/1.1 클라이언트가 프록시에 대한 요청에서만 절대URI 형식을 생성하더라도 요청에서 절대URI 형식을 수락해야 합니다.\(MUST\)

권한 양식은 CONNECT 메소드\(섹션 9.9\)에서만 사용됩니다.

요청-URI의 가장 일반적인 형태는 원본 서버나 게이트웨이에서 리소스를 식별하는 데 사용되는 것입니다. 이 경우 URI의 절대 경로는 Request-URI로 전송되어야 하며\(섹션 3.2.1, abs\_path 참조\) URI의 네트워크 위치\(권한\)는 Host 헤더 필드에서 전송되어야 합니다. 예를 들어, 원본 서버에서 직접 위의 리소스를 검색하려는 클라이언트는 호스트 "www.w3.org"의 포트 80에 대한 TCP 연결을 생성하고 다음 행을 보냅니다.\(MUST\)

```text
       GET /pub/WWW/TheProject.html HTTP/1.1
       Host: www.w3.org
```

요청의 나머지 부분이 이어집니다. 절대 경로는 비워둘 수 없습니다. 원래 URI에 아무 것도 없으면 "/"\(서버 루트\)로 제공되어야 합니다.\(MUST\)

Request-URI는 섹션 3.2.1에 지정된 형식으로 전송됩니다. Request-URI가 "% HEX HEX" 인코딩\[42\]을 사용하여 인코딩된 경우 원서버는 요청을 적절하게 해석하기 위해 Request-URI를 디코딩해야 합니다. 서버는 적절한 상태 코드로 유효하지 않은 Request-URI에 응답해야 합니다\(SHOULD\).\(MUST, SHOULD\)

투명 프록시는 수신된 Request-URI의 "abs\_path" 부분을 다음 인바운드 서버로 전달할 때 이를 다시 작성해서는 안 됩니다. 단, 위에서 언급한 null abs\_path를 "/"로 대체하는 경우는 예외입니다.\(MUST NOT\)

- 참고: "재작성 금지" 규칙은 원본 서버가 예약된 목적으로 예약되지 않은 URI 문자를 부적절하게 사용할 때 프록시가 요청의 의미를 변경하는 것을 방지합니다. 구현자는 일부 HTTP/1.1 이전 프록시가 요청-URI를 다시 작성하는 것으로 알려져 있다는 점을 알고 있어야 합니다.

---
## **5.2 The Resource Identified by a Request**

인터넷 요청으로 식별되는 정확한 리소스는 Request-URI와 Host 헤더 필드를 모두 검사하여 결정됩니다.

요청된 호스트에 따라 리소스가 달라지는 것을 허용하지 않는 원서버는 HTTP/1.1 요청에 의해 식별된 리소스를 결정할 때 Host 헤더 필드 값을 무시할 수 있습니다. \(그러나 HTTP/1.1의 호스트 지원에 대한 다른 요구 사항은 섹션 19.6.1.1을 참조하십시오.\)\(MAY\)

요청된 호스트\(가상 호스트 또는 허영 호스트 이름이라고도 함\)를 기반으로 리소스를 구별하는 원서버는 HTTP/1.1 요청에서 요청된 리소스를 결정하기 위해 다음 규칙을 사용해야 합니다.\(MUST\)

1. Request-URI가 절대URI인 경우 호스트는 Request-URI의 일부입니다. 요청의 모든 Host 헤더 필드 값은 무시되어야 합니다.\(MUST\)

2. Request-URI가 절대URI가 아니고 요청에 Host 헤더 필드가 포함된 경우 Host 헤더 필드 값에 따라 호스트가 결정됩니다.

3. 규칙 1 또는 2에 의해 결정된 호스트가 서버의 유효한 호스트가 아닌 경우 응답은 400\(잘못된 요청\) 오류 메시지여야 합니다.\(MUST\)

Host 헤더 필드가 없는 HTTP/1.0 요청의 수신자는 정확한 리소스가 요청되고 있는지 확인하기 위해 경험적 방법\(예: 특정 호스트에 고유한 항목에 대한 URI 경로 검사\)을 사용하려고 시도할 수 있습니다.\(MAY\)

---
## **5.3 Request Header Fields**

요청 헤더 필드를 사용하면 클라이언트는 요청 및 클라이언트 자체에 대한 추가 정보를 서버에 전달할 수 있습니다. 이러한 필드는 프로그래밍 언어 메서드 호출의 매개 변수와 동일한 의미를 갖는 요청 수정자 역할을 합니다.

```text
       request-header = Accept                   ; Section 14.1
                      | Accept-Charset           ; Section 14.2
                      | Accept-Encoding          ; Section 14.3
                      | Accept-Language          ; Section 14.4
                      | Authorization            ; Section 14.8
                      | Expect                   ; Section 14.20
                      | From                     ; Section 14.22
                      | Host                     ; Section 14.23
                      | If-Match                 ; Section 14.24

                      | If-Modified-Since        ; Section 14.25
                      | If-None-Match            ; Section 14.26
                      | If-Range                 ; Section 14.27
                      | If-Unmodified-Since      ; Section 14.28
                      | Max-Forwards             ; Section 14.31
                      | Proxy-Authorization      ; Section 14.34
                      | Range                    ; Section 14.35
                      | Referer                  ; Section 14.36
                      | TE                       ; Section 14.39
                      | User-Agent               ; Section 14.43
```

요청 헤더 필드 이름은 프로토콜 버전이 변경된 경우에만 안정적으로 확장될 수 있습니다. 그러나 통신의 모든 당사자가 이를 요청 헤더 필드로 인식하는 경우 새롭거나 실험적인 헤더 필드에 요청 헤더 필드의 의미가 부여될 수 있습니다. 인식할 수 없는 헤더 필드는 엔터티 헤더 필드로 처리됩니다.\(MAY\)

---
# **6 Response**

서버는 요청 메시지를 수신하고 해석한 후 HTTP 응답 메시지로 응답합니다.

```text
       Response      = Status-Line               ; Section 6.1
                       *(( general-header        ; Section 4.5
                        | response-header        ; Section 6.2
                        | entity-header ) CRLF)  ; Section 7.1
                       CRLF
                       [ message-body ]          ; Section 7.2
```

---
## **6.1 Status-Line**

응답 메시지의 첫 번째 줄은 프로토콜 버전, 숫자 상태 코드, 관련 텍스트 문구로 구성되며 각 요소는 SP 문자로 구분됩니다. 최종 CRLF 시퀀스를 제외하고 CR 또는 LF는 허용되지 않습니다.

```text
       Status-Line = HTTP-Version SP Status-Code SP Reason-Phrase CRLF
```

---
### **6.1.1 Status Code and Reason Phrase**

Status-Code 요소는 요청을 이해하고 만족시키려는 시도의 3자리 정수 결과 코드입니다. 이러한 코드는 섹션 10에 완전히 정의되어 있습니다. Reason-Phrase는 상태 코드에 대한 간단한 텍스트 설명을 제공하기 위한 것입니다. Status-Code는 오토마타에서 사용하기 위한 것이고 Reason-Phrase는 인간 사용자를 위한 것입니다. 클라이언트는 이유 문구를 검사하거나 표시할 필요가 없습니다.

상태 코드의 첫 번째 숫자는 응답 클래스를 정의합니다. 마지막 두 자리에는 분류 역할이 없습니다. 첫 번째 숫자에는 5개의 값이 있습니다.

```text
      - 1xx: Informational - Request received, continuing process
```

- 2xx: 성공 - 작업이 성공적으로 수신되었습니다.

- 이해하고 받아들인다.

- - 3xx: 리디렉션 - 요청을 완료하려면 추가 조치를 취해야 합니다.

- - 4xx: 클라이언트 오류 - 요청에 잘못된 구문이 포함되어 있거나 이행할 수 없습니다.

- - 5xx: 서버 오류 - 서버가 명백히 유효한 요청을 이행하지 못했습니다.

HTTP/1.1에 정의된 숫자 상태 코드의 개별 값과 해당 이유 문구의 예시 세트가 아래에 나와 있습니다. 여기에 나열된 이유 문구는 단지 권장사항일 뿐입니다. 프로토콜에 영향을 주지 않고 해당 지역의 문구로 대체될 수 있습니다.\(MAY\)

```text
      Status-Code    =
            "100"  ; Section 10.1.1: Continue
          | "101"  ; Section 10.1.2: Switching Protocols
          | "200"  ; Section 10.2.1: OK
          | "201"  ; Section 10.2.2: Created
          | "202"  ; Section 10.2.3: Accepted
          | "203"  ; Section 10.2.4: Non-Authoritative Information
          | "204"  ; Section 10.2.5: No Content
          | "205"  ; Section 10.2.6: Reset Content
          | "206"  ; Section 10.2.7: Partial Content
          | "300"  ; Section 10.3.1: Multiple Choices
          | "301"  ; Section 10.3.2: Moved Permanently
          | "302"  ; Section 10.3.3: Found
          | "303"  ; Section 10.3.4: See Other
          | "304"  ; Section 10.3.5: Not Modified
          | "305"  ; Section 10.3.6: Use Proxy
          | "307"  ; Section 10.3.8: Temporary Redirect
          | "400"  ; Section 10.4.1: Bad Request
          | "401"  ; Section 10.4.2: Unauthorized
          | "402"  ; Section 10.4.3: Payment Required
          | "403"  ; Section 10.4.4: Forbidden
          | "404"  ; Section 10.4.5: Not Found
          | "405"  ; Section 10.4.6: Method Not Allowed
          | "406"  ; Section 10.4.7: Not Acceptable

          | "407"  ; Section 10.4.8: Proxy Authentication Required
          | "408"  ; Section 10.4.9: Request Time-out
          | "409"  ; Section 10.4.10: Conflict
          | "410"  ; Section 10.4.11: Gone
          | "411"  ; Section 10.4.12: Length Required
          | "412"  ; Section 10.4.13: Precondition Failed
          | "413"  ; Section 10.4.14: Request Entity Too Large
          | "414"  ; Section 10.4.15: Request-URI Too Large
          | "415"  ; Section 10.4.16: Unsupported Media Type
          | "416"  ; Section 10.4.17: Requested range not satisfiable
          | "417"  ; Section 10.4.18: Expectation Failed
          | "500"  ; Section 10.5.1: Internal Server Error
          | "501"  ; Section 10.5.2: Not Implemented
          | "502"  ; Section 10.5.3: Bad Gateway
          | "503"  ; Section 10.5.4: Service Unavailable
          | "504"  ; Section 10.5.5: Gateway Time-out
          | "505"  ; Section 10.5.6: HTTP Version not supported
          | extension-code

      extension-code = 3DIGIT
      Reason-Phrase  = *<TEXT, excluding CR, LF>
```

HTTP 상태 코드는 확장 가능합니다. HTTP 애플리케이션은 등록된 모든 상태 코드의 의미를 이해할 필요는 없지만, 그러한 이해는 분명히 바람직합니다. 그러나 애플리케이션은 첫 번째 숫자로 표시된 모든 상태 코드의 클래스를 이해해야 하며, 인식할 수 없는 응답을 캐시해서는 안 된다는 점을 제외하고는 인식할 수 없는 모든 응답을 해당 클래스의 x00 상태 코드와 동일한 것으로 처리해야 합니다. 예를 들어, 클라이언트가 인식할 수 없는 상태 코드 431을 수신하면 요청에 문제가 있다고 안전하게 가정하고 응답을 400 상태 코드를 수신한 것처럼 처리할 수 있습니다. 그러한 경우, 사용자 에이전트는 응답과 함께 반환된 엔터티를 사용자에게 제시해야 합니다. 왜냐하면 해당 엔터티에는 비정상적인 상태를 설명하는 사람이 읽을 수 있는 정보가 포함될 가능성이 높기 때문입니다.\(MUST NOT, SHOULD\)

---
## **6.2 Response Header Fields**

응답 헤더 필드를 사용하면 서버는 상태 표시줄에 배치할 수 없는 응답에 대한 추가 정보를 전달할 수 있습니다. 이러한 헤더 필드는 서버에 대한 정보와 Request-URI로 식별된 리소스에 대한 추가 액세스에 대한 정보를 제공합니다.

```text
       response-header = Accept-Ranges           ; Section 14.5
                       | Age                     ; Section 14.6
                       | ETag                    ; Section 14.19
                       | Location                ; Section 14.30
                       | Proxy-Authenticate      ; Section 14.33

                       | Retry-After             ; Section 14.37
                       | Server                  ; Section 14.38
                       | Vary                    ; Section 14.44
                       | WWW-Authenticate        ; Section 14.47
```

응답 헤더 필드 이름은 프로토콜 버전이 변경되는 경우에만 안정적으로 확장될 수 있습니다. 그러나 통신의 모든 당사자가 이를 응답 헤더 필드로 인식하는 경우 새롭거나 실험적인 헤더 필드에 응답 헤더 필드의 의미가 부여될 수 있습니다. 인식할 수 없는 헤더 필드는 엔터티 헤더 필드로 처리됩니다.\(MAY\)

---
# **7 Entity**

요청 및 응답 메시지는 요청 방법이나 응답 상태 코드에 의해 달리 제한되지 않는 한 엔터티를 전송할 수 있습니다. 엔터티는 엔터티 헤더 필드와 엔터티 본문으로 구성되지만 일부 응답에는 엔터티 헤더만 포함됩니다.\(MAY\)

이 섹션에서 보낸 사람과 받는 사람 모두 엔터티를 보내는 사람과 받는 사람에 따라 클라이언트나 서버를 나타냅니다.

---
## **7.1 Entity Header Fields**

엔터티 헤더 필드는 엔터티 본문에 대한 메타 정보를 정의하거나, 본문이 없는 경우 요청에 의해 식별된 리소스에 대한 메타 정보를 정의합니다. 이 메타정보 중 일부는 선택사항입니다. 일부는 이 사양의 일부에 의해 요구될 수 있습니다.\(MUST\)

```text
       entity-header  = Allow                    ; Section 14.7
                      | Content-Encoding         ; Section 14.11
                      | Content-Language         ; Section 14.12
                      | Content-Length           ; Section 14.13
                      | Content-Location         ; Section 14.14
                      | Content-MD5              ; Section 14.15
                      | Content-Range            ; Section 14.16
                      | Content-Type             ; Section 14.17
                      | Expires                  ; Section 14.21
                      | Last-Modified            ; Section 14.29
                      | extension-header

       extension-header = message-header
```

확장 헤더 메커니즘을 사용하면 프로토콜을 변경하지 않고도 추가 엔터티 헤더 필드를 정의할 수 있지만 이러한 필드를 수신자가 인식할 수 있다고 가정할 수는 없습니다. 인식할 수 없는 헤더 필드는 수신자가 무시해야 하며 투명 프록시에 의해 전달되어야 합니다.\(MUST\)

---
## **7.2 Entity Body**

HTTP 요청 또는 응답과 함께 전송된 엔터티 본문\(있는 경우\)은 엔터티 헤더 필드에 정의된 형식 및 인코딩을 따릅니다.

```text
       entity-body    = *OCTET
```

Entity-Body는 섹션 4.3에 설명된 대로 Message-Body가 있는 경우에만 메시지에 존재합니다. 메시지의 안전하고 적절한 전송을 보장하기 위해 적용될 수 있는 전송 인코딩을 디코딩하여 메시지 본문에서 엔터티 본문을 얻습니다.

---
### **7.2.1 Type**

메시지에 엔터티 본문이 포함된 경우 해당 본문의 데이터 유형은 헤더 필드 Content-Type 및 Content-Encoding을 통해 결정됩니다. 이는 순서가 지정된 2계층 인코딩 모델을 정의합니다.

```text
       entity-body := Content-Encoding( Content-Type( data ) )
```

Content-Type은 기본 데이터의 미디어 유형을 지정합니다. Content-Encoding은 일반적으로 데이터 압축을 위해 요청된 리소스의 속성인 데이터에 적용되는 추가 콘텐츠 코딩을 나타내는 데 사용될 수 있습니다. 기본 인코딩은 없습니다.

Entity-Body를 포함하는 모든 HTTP/1.1 메시지는 해당 본문의 미디어 유형을 정의하는 Content-Type 헤더 필드를 포함해야 합니다. 미디어 유형이 Content-Type 필드에 의해 제공되지 않는 경우에만 수신자는 콘텐츠 및/또는 리소스를 식별하는 데 사용되는 URI의 이름 확장자를 검사하여 미디어 유형을 추측하려고 시도할 수 있습니다. 미디어 유형을 알 수 없는 경우 수신자는 이를 "application/octet-stream" 유형으로 처리해야 합니다.\(SHOULD, MAY, SHOULD\)

---
### **7.2.2 Entity Length**

메시지의 엔터티 길이는 전송 코딩이 적용되기 전 메시지 본문의 길이입니다. 섹션 4.4에서는 메시지 본문의 전송 길이가 결정되는 방법을 정의합니다.

---
# **8 Connections**
---
## **8.1 Persistent Connections**
---
### **8.1.1 Purpose**

영구 연결 이전에는 각 URL을 가져오기 위해 별도의 TCP 연결이 설정되어 HTTP 서버의 부하가 증가하고 인터넷 정체가 발생했습니다. 인라인 이미지 및 기타 관련 데이터를 사용하려면 클라이언트가 짧은 시간 내에 동일한 서버에 대해 여러 요청을 해야 하는 경우가 많습니다. 이러한 성능 문제에 대한 분석과 프로토타입 구현 결과가 이용 가능합니다\[26\]\[30\]. 실제 HTTP/1.1\(RFC 2068\) 구현에 대한 구현 경험과 측정 결과는 좋은 결과를 보여줍니다\[39\]. 예를 들어 T/TCP\[27\]와 같은 대안도 모색되었습니다.

지속적인 HTTP 연결에는 다음과 같은 여러 가지 장점이 있습니다.

- - 더 적은 수의 TCP 연결을 열고 닫음으로써 라우터와 호스트\(클라이언트, 서버, 프록시, 게이트웨이, 터널 또는 캐시\)의 CPU 시간이 절약되고, TCP 프로토콜 제어 블록에 사용되는 메모리를 호스트에 저장할 수 있습니다.

- - HTTP 요청 및 응답은 연결에서 파이프라인될 수 있습니다. 파이프라이닝을 사용하면 클라이언트가 각 응답을 기다리지 않고 여러 요청을 할 수 있으므로 단일 TCP 연결을 훨씬 더 효율적으로 사용하고 경과 시간을 줄일 수 있습니다.

- - TCP 개방으로 인한 패킷 수를 줄이고, TCP가 네트워크의 혼잡 상태를 판단할 수 있는 충분한 시간을 허용함으로써 네트워크 혼잡을 줄입니다.

- - TCP의 연결 열기 핸드셰이크에 소요되는 시간이 없기 때문에 후속 요청에 대한 대기 시간이 줄어듭니다.

- - TCP 연결을 닫는 데 따른 불이익 없이 오류를 보고할 수 있으므로 HTTP는 더욱 우아하게 발전할 수 있습니다. 향후 버전의 HTTP를 사용하는 클라이언트는 낙관적으로 새로운 기능을 시도할 수 있지만 이전 서버와 통신하는 경우 오류가 보고된 후 이전 의미 체계를 사용하여 다시 시도하십시오.

```text
   HTTP implementations SHOULD implement persistent connections.
```

---
### **8.1.2 Overall Operation**

HTTP/1.1과 이전 버전의 HTTP 사이의 중요한 차이점은 지속적인 연결이 모든 HTTP 연결의 기본 동작이라는 것입니다. 즉, 달리 명시하지 않는 한 클라이언트는 서버의 오류 응답 후에도 서버가 지속적인 연결을 유지할 것이라고 가정해야 합니다.\(SHOULD\)

영구 연결은 클라이언트와 서버가 TCP 연결 종료를 알릴 수 있는 메커니즘을 제공합니다. 이 신호는 연결 헤더 필드\(섹션 14.10\)를 사용하여 발생합니다. 닫기 신호가 전송되면 클라이언트는 해당 연결에 대해 더 이상 요청을 보내서는 안 됩니다.\(MUST NOT\)

---
#### **8.1.2.1 Negotiation**

HTTP/1.1 서버는 연결 토큰 "close"를 포함하는 연결 헤더가 요청에 전송되지 않는 한 HTTP/1.1 클라이언트가 지속적인 연결을 유지하려고 한다고 가정할 수 있습니다. 서버가 응답을 보낸 후 즉시 연결을 끊기로 선택한 경우 연결 토큰 닫기를 포함하는 연결 헤더를 보내야 합니다.\(MAY, SHOULD\)

HTTP/1.1 클라이언트는 연결이 열려 있을 것으로 예상할 수 있지만 서버의 응답에 연결 토큰 닫기가 있는 연결 헤더가 포함되어 있는지 여부에 따라 연결을 열어두기로 결정할 수 있습니다. 클라이언트가 해당 요청 이상으로 연결을 유지하고 싶지 않은 경우 연결 토큰 닫기를 포함하는 연결 헤더를 보내야 합니다.\(MAY, SHOULD\)

클라이언트나 서버가 연결 헤더에 닫기 토큰을 보내는 경우 해당 요청은 연결에 대한 마지막 요청이 됩니다.

클라이언트와 서버는 명시적으로 신호를 보내지 않는 한 1.1 미만의 HTTP 버전에 대해 지속적인 연결이 유지된다고 가정해서는 안 됩니다. HTTP/1.0 클라이언트와의 하위 호환성에 대한 자세한 내용은 섹션 19.6.2를 참조하세요.\(SHOULD NOT\)

지속성을 유지하려면 섹션 4.4에 설명된 대로 연결의 모든 메시지는 자체 정의된 메시지 길이\(즉, 연결 종료로 정의되지 않은 메시지 길이\)를 가져야 합니다.\(MUST\)

---
#### **8.1.2.2 Pipelining**

지속적인 연결을 지원하는 클라이언트는 요청을 "파이프라인"할 수 있습니다\(즉, 각 응답을 기다리지 않고 여러 요청을 보낼 수 있습니다\). 서버는 요청이 수신된 순서와 동일한 순서로 해당 요청에 대한 응답을 보내야 합니다.\(MAY, MUST\)

연결 설정 직후 지속적인 연결과 파이프라인을 가정하는 클라이언트는 첫 번째 파이프라인 시도가 실패할 경우 연결을 다시 시도할 준비가 되어 있어야 합니다. 클라이언트가 이러한 재시도를 수행하는 경우 연결이 지속된다는 것을 알기 전에는 파이프라인을 수행해서는 안 됩니다. 또한 클라이언트는 해당 응답을 모두 보내기 전에 서버가 연결을 닫는 경우 요청을 다시 보낼 준비를 해야 합니다.\(SHOULD, MUST NOT, MUST\)

클라이언트는 멱등성이 아닌 메서드나 메서드의 멱등성이 아닌 시퀀스를 사용하여 요청을 파이프라인해서는 안 됩니다\(섹션 9.1.2 참조\). 그렇지 않으면 전송 연결이 조기에 종료되어 불확실한 결과가 발생할 수 있습니다. 비멱등성 요청을 보내려는 클라이언트는 이전 요청에 대한 응답 상태를 수신할 때까지 해당 요청 보내기를 기다려야 합니다.\(SHOULD NOT, SHOULD\)

---
### **8.1.3 Proxy Servers**

프록시가 섹션 14.10에 지정된 대로 연결 헤더 필드의 속성을 올바르게 구현하는 것이 특히 중요합니다.

프록시 서버는 클라이언트 및 연결되는 원본 서버\(또는 다른 프록시 서버\)와 별도로 지속적인 연결을 신호해야 합니다. 각 영구 연결은 하나의 전송 링크에만 적용됩니다.\(MUST\)

프록시 서버는 HTTP/1.0 클라이언트와 HTTP/1.1 영구 연결을 설정해서는 안 됩니다\(그러나 많은 HTTP/1.0 클라이언트에 의해 구현된 Keep-Alive 헤더 문제에 대한 정보 및 논의는 RFC 2068 \[33\]을 참조하십시오\).\(MUST NOT\)

---
### **8.1.4 Practical Considerations**

서버에는 일반적으로 더 이상 비활성 연결을 유지하지 않는 시간 초과 값이 있습니다. 클라이언트가 동일한 서버를 통해 더 많은 연결을 만들 가능성이 높으므로 프록시 서버는 이 값을 더 높게 설정할 수 있습니다. 영구 연결을 사용하면 클라이언트나 서버에 대한 이 제한 시간의 길이\(또는 존재 여부\)에 대한 요구 사항이 없습니다.

클라이언트나 서버가 시간 초과를 원할 경우 전송 연결을 정상적으로 종료해야 합니다. 클라이언트와 서버는 둘 다 가까운 전송의 다른 쪽을 지속적으로 관찰하고 적절하게 응답해야 합니다. 클라이언트나 서버가 상대방의 종료를 신속하게 감지하지 못하면 네트워크에서 불필요한 리소스 소모가 발생할 수 있습니다.\(SHOULD, SHOULD\)

클라이언트, 서버 또는 프록시는 언제든지 전송 연결을 닫을 수 있습니다. 예를 들어, 서버가 "유휴" 연결을 종료하기로 결정한 동시에 클라이언트가 새 요청을 보내기 시작했을 수 있습니다. 서버 입장에서는 유휴 상태에서 연결이 종료되고 있지만 클라이언트 입장에서는 요청이 진행 중인 상태입니다.\(MAY\)

이는 클라이언트, 서버 및 프록시가 비동기 닫기 이벤트에서 복구할 수 있어야 함을 의미합니다. 클라이언트 소프트웨어는 요청 시퀀스가 ​​멱등성이 있는 한 전송 연결을 다시 열고 사용자 상호 작용 없이 중단된 요청 시퀀스를 재전송해야 합니다\(섹션 9.1.2 참조\). 사용자 에이전트가 인간 운영자에게 요청을 재시도할 수 있는 선택권을 제공할 수 있지만 비멱등성 메서드나 시퀀스는 자동으로 재시도해서는 안 됩니다. 애플리케이션의 의미론적 이해를 갖춘 사용자 에이전트 소프트웨어에 의한 확인은 사용자 확인을 대체할 수 있습니다. 두 번째 요청 시퀀스가 ​​실패하는 경우 자동 재시도를 반복해서는 안 됩니다.\(MUST, SHOULD, MUST NOT, MAY, SHOULD NOT\)

서버는 가능하다면 항상 연결당 하나 이상의 요청에 응답해야 합니다. 서버는 네트워크 또는 클라이언트 오류가 의심되지 않는 한 응답을 전송하는 도중에 연결을 닫아서는 안 됩니다.\(SHOULD, SHOULD NOT\)

영구 연결을 사용하는 클라이언트는 특정 서버에 대해 유지하는 동시 연결 수를 제한해야 합니다. 단일 사용자 클라이언트는 서버나 프록시와의 연결을 2개 이상 유지해서는 안 됩니다. 프록시는 다른 서버 또는 프록시에 대해 최대 2\*N 연결을 사용해야 합니다. 여기서 N은 동시에 활성 사용자 수입니다. 이러한 지침은 HTTP 응답 시간을 개선하고 정체를 방지하기 위한 것입니다.\(SHOULD, SHOULD NOT, SHOULD\)

---
## **8.2 Message Transmission Requirements**
---
### **8.2.1 Persistent Connections and Flow Control**

HTTP/1.1 서버는 클라이언트가 재시도할 것으로 예상하여 연결을 종료하는 대신 지속적인 연결을 유지하고 TCP의 흐름 제어 메커니즘을 사용하여 임시 과부하를 해결해야 합니다. 후자의 기술은 네트워크 정체를 악화시킬 수 있습니다.\(SHOULD\)

---
### **8.2.2 Monitoring Connections for Error Status Messages**

메시지 본문을 보내는 HTTP/1.1\(또는 그 이상\) 클라이언트는 요청을 전송하는 동안 네트워크 연결에서 오류 상태를 모니터링해야 합니다. 클라이언트가 오류 상태를 확인하면 즉시 본문 전송을 중단해야 합니다. 본문이 "청크" 인코딩\(섹션 3.6\)을 사용하여 전송되는 경우 길이가 0인 청크와 빈 트레일러를 사용하여 메시지 끝을 조기에 표시할 수 있습니다. 본문 앞에 Content-Length 헤더가 있는 경우 클라이언트는 연결을 닫아야 합니다.\(SHOULD, SHOULD, MAY, MUST\)

---
### **8.2.3 Use of the 100 (Continue) Status**

100\(계속\) 상태\(섹션 10.1.1 참조\)의 목적은 요청 본문과 함께 요청 메시지를 보내는 클라이언트가 원서버가 요청을 수락할 의향이 있는지\(요청 헤더를 기반으로\) 결정할 수 있도록 하는 것입니다. 클라이언트가 요청 본문을 보내기 전에. 어떤 경우에는 서버가 본문을 확인하지 않고 메시지를 거부하는 경우 클라이언트가 본문을 보내는 것이 부적절하거나 매우 비효율적일 수 있습니다.

HTTP/1.1 클라이언트 요구 사항:

- - 클라이언트가 요청 본문을 보내기 전에 100\(Continue\) 응답을 기다리는 경우 "100-continue" 기대와 함께 Expect 요청 헤더 필드\(섹션 14.20\)를 보내야 합니다.\(MUST\)

- - 클라이언트는 요청 본문을 보낼 의도가 없는 경우 "100-continue" 기대와 함께 Expect 요청 헤더 필드\(섹션 14.20\)를 보내서는 안 됩니다.\(MUST NOT\)

이전 구현이 있기 때문에 프로토콜은 클라이언트가 417\(예상 실패\) 상태 또는 100\(계속\) 상태를 수신하지 않고 "예상: 100- 계속"을 보낼 수 있는 모호한 상황을 허용합니다. 따라서 클라이언트가 이 헤더 필드를 100\(계속\) 상태를 본 적이 없는 원본 서버\(아마도 프록시를 통해\)로 보낼 때 클라이언트는 요청 본문을 보내기 전에 무한정 기다리면 안 됩니다.\(SHOULD NOT\)

HTTP/1.1 원본 서버 요구 사항:

- - "100-continue" 기대치를 갖는 Expect 요청 헤더 필드를 포함하는 요청을 수신하면 원서버는 100\(계속\) 상태로 응답하고 입력 스트림에서 계속 읽거나 최종 상태로 응답해야 합니다. 암호. 원서버는 100\(계속\) 응답을 보내기 전에 요청 본문을 기다려서는 안 됩니다. 최종 상태 코드로 응답하면 전송 연결을 닫거나 계속할 수 있습니다.\(MUST, MUST NOT, MAY\)

- 요청의 나머지 부분을 읽고 삭제합니다. 최종 상태 코드를 반환하는 경우 요청된 메서드를 수행해서는 안 됩니다.\(MUST NOT\)

- - 원서버는 요청 메시지에 "100-continue" 기대치를 갖는 Expect 요청 헤더 필드가 포함되어 있지 않은 경우 100\(Continue\) 응답을 보내서는 안 되며, 그러한 요청이 있는 경우 100\(Continue\) 응답을 보내서는 안 됩니다. HTTP/1.0\(또는 이전\) 클라이언트에서 옵니다. 이 규칙에는 예외가 있습니다. RFC 2068과의 호환성을 위해 서버는 "100- 계속해" 기대. 100\(계속\) 상태에 대한 선언되지 않은 대기와 관련된 클라이언트 처리 지연을 최소화하기 위한 목적인 이 예외는 HTTP/1.1 요청에만 적용되며 다른 HTTP 버전 값이 있는 요청에는 적용되지 않습니다.\(MUST NOT, MAY\)

- - 원서버는 해당 요청에 대한 요청 본문의 일부 또는 전부를 이미 수신한 경우 100\(계속\) 응답을 생략할 수 있습니다.\(MAY\)

- - 100\(계속\) 응답을 보내는 원서버는 전송 연결을 조기에 종료하지 않는 한 요청 본문이 수신되고 처리되면 궁극적으로 최종 상태 코드를 보내야 합니다.\(MUST\)

- - 원본 서버가 "100-continue" 기대치를 갖는 Expect 요청 헤더 필드를 포함하지 않는 요청을 수신하는 경우 요청에는 요청 본문이 포함되며 서버는 전체 요청 본문을 읽기 전에 최종 상태 코드로 응답합니다. 전송 연결에서 서버는 전체 요청을 읽을 때까지 또는 클라이언트가 연결을 닫을 때까지 전송 연결을 닫아서는 안 됩니다. 그렇지 않으면 클라이언트가 응답 메시지를 안정적으로 수신하지 못할 수 있습니다. 그러나 이 요구 사항은 서버가 서비스 거부 공격이나 심각하게 손상된 클라이언트 구현으로부터 자신을 방어하는 것을 방지하는 것으로 해석되지 않습니다.\(SHOULD NOT\)

HTTP/1.1 프록시 요구 사항:

- - 프록시가 "100-continue" 기대치를 갖는 Expect 요청 헤더 필드를 포함하는 요청을 수신하고 프록시가 다음 홉 서버가 HTTP/1.1 이상을 준수한다는 것을 알고 있거나 HTTP를 모르는 경우 다음 홉 서버 버전에서는 Expect 헤더 필드를 포함하여 요청을 전달해야 합니다.\(MUST\)

- - 프록시가 다음 홉 서버의 버전이 HTTP/1.0 이하임을 알고 있는 경우 요청을 전달해서는 안 되며 417\(예상 실패\) 상태로 응답해야 합니다.\(MUST NOT\)

- - 프록시는 최근 참조된 다음 홉 서버로부터 수신된 HTTP 버전 번호를 기록하는 캐시를 유지해야 합니다.\(SHOULD\)

- - 요청 메시지가 HTTP/1.0\(또는 이전\) 클라이언트로부터 수신되었고 "100-continue" 기대와 함께 Expect 요청 헤더 필드를 포함하지 않은 경우 프록시는 100\(Continue\) 응답을 전달해서는 안 됩니다. 이 요구 사항은 1xx 응답 전달에 대한 일반 규칙보다 우선합니다\(섹션 10.1 참조\).\(MUST NOT\)

---
### **8.2.4 Client Behavior if Server Prematurely Closes Connection**

HTTP/1.1 클라이언트가 요청 본문은 포함하지만 "100-continue" 기대치를 갖는 Expect 요청 헤더 필드는 포함하지 않은 요청을 보내는 경우, 그리고 클라이언트가 HTTP/1.1 원본 서버에 직접 연결되지 않은 경우 , 클라이언트가 서버로부터 상태를 수신하기 전에 연결이 닫힌 것을 확인하면 클라이언트는 요청을 다시 시도해야 합니다. 클라이언트가 이 요청을 재시도하는 경우 신뢰할 수 있는 응답을 얻을 수 있도록 다음과 같은 "이진 지수 백오프" 알고리즘을 사용할 수 있습니다.\(SHOULD, MAY\)

- 1. 서버에 새로운 연결을 시작합니다.

- 2. 요청 헤더 전송

- 3. 변수 R을 서버까지의 예상 왕복 시간\(예: 연결을 설정하는 데 걸린 시간 기준\)으로 초기화하거나 왕복 시간을 사용할 수 없는 경우 5초의 상수 값으로 초기화합니다.

- 4. T = R \* \(2\*\*N\)을 계산합니다. 여기서 N은 이 요청의 이전 재시도 횟수입니다.

```text
      5. Wait either for an error response from the server, or for T
         seconds (whichever comes first)
```

- 6. 오류 응답이 수신되지 않으면 T초 후에 요청 본문을 전송합니다.

- 7. 클라이언트가 연결이 조기에 종료된 것을 확인하면 요청이 수락되거나 오류 응답이 수신되거나 사용자가 참을성이 없어 재시도 프로세스를 종료할 때까지 1단계부터 반복합니다.

어느 시점에서든 오류 상태가 수신되면 클라이언트는

```text
      - SHOULD NOT continue and
```

- - 요청 메시지 전송이 완료되지 않은 경우 연결을 닫아야 합니다.\(SHOULD\)

---
# **9 Method Definitions**

HTTP/1.1의 일반적인 메소드 세트는 아래에 정의되어 있습니다. 이 세트는 확장될 수 있지만 추가 메소드가 별도로 확장된 클라이언트 및 서버에 대해 동일한 의미를 공유한다고 가정할 수는 없습니다.

호스트 요청 헤더 필드\(섹션 14.23\)는 모든 HTTP/1.1 요청과 함께 제공되어야 합니다.\(MUST\)

---
## **9.1 Safe and Idempotent Methods**
---
### **9.1.1 Safe Methods**

구현자는 소프트웨어가 인터넷을 통한 상호 작용에서 사용자를 대표한다는 점을 인식해야 하며, 자신이나 다른 사람에게 예상치 못한 의미를 가질 수 있는 자신이 취할 수 있는 모든 작업을 사용자가 인식할 수 있도록 주의해야 합니다.

특히, GET 및 HEAD 메소드는 검색 이외의 조치를 취하는 의미를 가져서는 안 된다는 규칙이 확립되었습니다. 이러한 방법은 "안전한" 것으로 간주되어야 합니다. 이를 통해 사용자 에이전트는 POST, PUT 및 DELETE와 같은 다른 메소드를 특별한 방식으로 나타낼 수 있으므로 사용자는 안전하지 않을 수 있는 작업이 요청되고 있다는 사실을 알 수 있습니다.\(SHOULD NOT\)

당연히 서버가 GET 요청 수행의 결과로 부작용을 생성하지 않는다는 것을 보장하는 것은 불가능합니다. 실제로 일부 동적 리소스에서는 이를 기능으로 간주합니다. 여기서 중요한 차이점은 사용자가 부작용을 요청하지 않았으므로 이에 대해 책임을 질 수 없다는 것입니다.

---
### **9.1.2 Idempotent Methods**

오류 또는 만료 문제를 제외하고 N \> 0 동일한 요청의 부작용이 단일 요청의 경우와 동일하다는 점에서 메서드는 "멱등성" 속성을 가질 수도 있습니다. GET, HEAD, PUT 및 DELETE 메소드는 이 속성을 공유합니다. 또한 OPTIONS 및 TRACE 메소드에는 부작용이 있어서는 안 되며 본질적으로 멱등성을 갖습니다.\(SHOULD NOT\)

그러나 해당 시퀀스에서 실행된 모든 메서드가 멱등성이더라도 여러 요청의 시퀀스는 멱등성이 아닐 수 있습니다. \(전체 시퀀스의 단일 실행이 항상 해당 시퀀스의 전부 또는 일부를 다시 실행해도 변경되지 않는 결과를 생성하는 경우 해당 시퀀스는 멱등성이 없습니다.\) 예를 들어, 해당 결과가 나중에 동일한 순서로 수정되는 값입니다.

부작용이 전혀 없는 시퀀스는 정의상 멱등적입니다\(동일한 리소스 집합에서 동시 작업이 실행되지 않는 경우\).

---
## **9.2 OPTIONS**

OPTIONS 메소드는 요청-URI로 식별되는 요청/응답 체인에서 사용 가능한 통신 옵션에 대한 정보 요청을 나타냅니다. 이 방법을 사용하면 클라이언트는 리소스 작업을 암시하거나 리소스 검색을 시작하지 않고도 리소스 또는 서버 기능과 관련된 옵션 및/또는 요구 사항을 결정할 수 있습니다.

이 메서드에 대한 응답은 캐시할 수 없습니다.

OPTIONS 요청에 Entity-Body\(Content-Length 또는 Transfer-Encoding이 있음으로 표시됨\)가 포함된 경우 미디어 유형은 Content-Type 필드로 표시되어야 합니다. 이 사양에서는 이러한 본문의 용도를 정의하지 않지만 향후 HTTP 확장에서는 OPTIONS 본문을 사용하여 서버에 대해 더 자세한 쿼리를 수행할 수 있습니다. 그러한 확장을 지원하지 않는 서버는 요청 본문을 삭제할 수 있습니다.\(MUST, MAY\)

Request-URI가 별표\("\*"\)인 경우 OPTIONS 요청은 특정 리소스가 아닌 일반적으로 서버에 적용하기 위한 것입니다. 서버의 통신 옵션은 일반적으로 리소스에 따라 달라지므로 "\*" 요청은 "ping" 또는 "no-op" 유형의 방법으로만 유용합니다. 클라이언트가 서버의 기능을 테스트하도록 허용하는 것 외에는 아무 것도 수행하지 않습니다. 예를 들어, 이는 HTTP/1.1 준수\(또는 준수 부족\)에 대한 프록시를 테스트하는 데 사용될 수 있습니다.

Request-URI가 별표가 아닌 경우 OPTIONS 요청은 해당 리소스와 통신할 때 사용할 수 있는 옵션에만 적용됩니다.

200 응답에는 서버에 의해 구현되고 해당 리소스에 적용 가능한 선택적 기능\(예: 허용\)을 나타내는 모든 헤더 필드가 포함되어야 하며, 이 사양에서 정의되지 않은 확장도 포함될 수 있습니다. 응답 본문에는 통신 옵션에 대한 정보도 포함되어야 합니다. 그러한 형식\(SHOULD, SHOULD\)

본문은 이 사양에 의해 정의되지 않지만 향후 HTTP 확장에 의해 정의될 수 있습니다. 적절한 응답 형식을 선택하기 위해 콘텐츠 협상을 사용할 수 있습니다. 응답 본문이 포함되지 않은 경우 응답에는 필드 값이 "0"인 Content-Length 필드가 포함되어야 합니다.\(MAY, MUST\)

Max-Forwards 요청 헤더 필드는 요청 체인의 특정 프록시를 대상으로 하는 데 사용될 수 있습니다. 프록시가 요청 전달이 허용되는 절대URI에서 OPTIONS 요청을 수신하면 프록시는 Max-Forwards 필드를 확인해야 합니다. Max-Forwards 필드 값이 0\("0"\)인 경우 프록시는 메시지를 전달해서는 안 됩니다. 대신 프록시는 자체 통신 옵션으로 응답해야 합니다. Max-Forwards field-value가 0보다 큰 정수인 경우 프록시는 요청을 전달할 때 field-value를 감소시켜야 합니다. 요청에 Max-Forwards 필드가 없으면 전달된 요청에는 Max-Forwards 필드가 포함되어서는 안 됩니다.\(MAY, MUST, MUST NOT, MUST, MUST NOT\)

---
## **9.3 GET**

GET 메소드는 요청-URI에 의해 식별되는 모든 정보\(엔티티 형식\)를 검색하는 것을 의미합니다. 요청-URI가 데이터 생성 프로세스를 참조하는 경우 해당 텍스트가 프로세스의 출력이 아닌 한 프로세스의 소스 텍스트가 아닌 응답의 엔터티로 반환되는 것은 생성된 데이터입니다.

요청 메시지에 If-Modified-Since, If-Unmodified-Since, If-Match, If-None-Match 또는 If-Range 헤더 필드가 포함된 경우 GET 메서드의 의미가 "조건부 GET"으로 변경됩니다. 조건부 GET 메서드는 조건부 헤더 필드에 설명된 상황에서만 엔터티가 전송되도록 요청합니다. 조건부 GET 방법은 여러 요청을 요구하거나 클라이언트가 이미 보유하고 있는 데이터를 전송하지 않고도 캐시된 엔터티를 새로 고칠 수 있도록 하여 불필요한 네트워크 사용량을 줄이기 위한 것입니다.

요청 메시지에 Range 헤더 필드가 포함된 경우 GET 메서드의 의미가 "부분 GET"으로 변경됩니다. 부분 GET은 섹션 14.35에 설명된 대로 엔터티의 일부만 전송되도록 요청합니다. 부분 GET 방법은 클라이언트가 이미 보유하고 있는 데이터를 전송하지 않고 부분적으로 검색된 엔터티를 완료할 수 있도록 하여 불필요한 네트워크 사용을 줄이기 위한 것입니다.

GET 요청에 대한 응답은 섹션 13에 설명된 HTTP 캐싱 요구 사항을 충족하는 경우에만 캐시 가능합니다.

양식에 사용될 때 보안 고려사항은 섹션 15.1.3을 참조하십시오.

---
## **9.4 HEAD**

HEAD 메소드는 서버가 응답에서 메시지 본문을 반환해서는 안 된다는 점을 제외하면 GET과 동일합니다. HEAD 요청에 대한 응답으로 HTTP 헤더에 포함된 메타정보는 GET 요청에 대한 응답으로 전송된 정보와 동일해야 합니다. 이 방법은 Entity-Body 자체를 전송하지 않고 요청에 의해 암시된 엔터티에 대한 메타정보를 얻는 데 사용될 수 있습니다. 이 방법은 하이퍼텍스트 링크의 유효성, 접근성 및 최근 수정 사항을 테스트하는 데 자주 사용됩니다.\(MUST NOT, SHOULD\)

HEAD 요청에 대한 응답은 응답에 포함된 정보가 해당 리소스에서 이전에 캐시된 엔터티를 업데이트하는 데 사용될 수 있다는 의미에서 캐시될 수 있습니다. 새 필드 값이 캐시된 엔터티가 현재 엔터티와 다르다는 것을 나타내는 경우\(Content-Length, Content-MD5, ETag 또는 Last-Modified의 변경으로 표시됨\) 캐시는 캐시 항목을 오래된 항목으로 처리해야 합니다.\(MAY, MUST\)

---
## **9.5 POST**

POST 메소드는 원서버가 Request-Line의 Request-URI에 의해 식별되는 자원의 새로운 하위 항목으로 요청에 포함된 엔터티를 수락하도록 요청하는 데 사용됩니다. POST는 다음 기능을 처리하는 균일한 방법을 허용하도록 설계되었습니다.

```text
      - Annotation of existing resources;

      - Posting a message to a bulletin board, newsgroup, mailing list,
        or similar group of articles;

      - Providing a block of data, such as the result of submitting a
        form, to a data-handling process;
```

- - 추가 작업을 통해 데이터베이스를 확장합니다.

POST 메서드에 의해 수행되는 실제 기능은 서버에 의해 결정되며 일반적으로 Request-URI에 따라 달라집니다. 게시된 엔터티는 파일이 이를 포함하는 디렉터리에 종속되고, 뉴스 기사가 게시된 뉴스 그룹에 종속되거나, 레코드가 데이터베이스에 종속되는 것과 같은 방식으로 해당 URI에 종속됩니다.

POST 메서드로 수행된 작업으로 인해 URI로 식별할 수 있는 리소스가 생성되지 않을 수 있습니다. 이 경우 응답에 결과를 설명하는 엔터티가 포함되어 있는지 여부에 따라 200\(OK\) 또는 204\(콘텐츠 없음\)가 적절한 응답 상태입니다.

리소스가 원서버에서 생성된 경우 응답은 201\(Created\)이어야 하며 요청 상태를 설명하고 새 리소스를 참조하는 엔터티와 위치 헤더\(14.30절 참조\)를 포함해야 합니다.\(SHOULD\)

응답에 적절한 Cache-Control 또는 Expires 헤더 필드가 포함되어 있지 않으면 이 메서드에 대한 응답을 캐시할 수 없습니다. 그러나 303\(기타 참조\) 응답을 사용하여 사용자 에이전트에 캐시 가능한 리소스를 검색하도록 지시할 수 있습니다.

POST 요청은 섹션 8.2에 명시된 메시지 전송 요구 사항을 준수해야 합니다.\(MUST\)

보안 고려 사항은 섹션 15.1.3을 참조하세요.

---
## **9.6 PUT**

PUT 메소드는 동봉된 엔터티가 제공된 Request-URI에 저장되도록 요청합니다. Request-URI가 이미 존재하는 리소스를 참조하는 경우 포함된 엔터티는 원서버에 있는 엔터티의 수정된 버전으로 간주되어야 합니다. 요청-URI가 기존 리소스를 가리키지 않고 해당 URI가 요청하는 사용자 에이전트에 의해 새 리소스로 정의될 수 있는 경우 원서버는 해당 URI를 사용하여 리소스를 생성할 수 있습니다. 새로운 리소스가 생성되면 원서버는 201\(Created\) 응답을 통해 사용자 에이전트에 알려야 합니다. 기존 리소스가 수정된 경우 요청이 성공적으로 완료되었음을 나타내기 위해 200\(OK\) 또는 204\(콘텐츠 없음\) 응답 코드를 전송해야 합니다. Request-URI로 리소스를 생성하거나 수정할 수 없는 경우 문제의 성격을 반영하는 적절한 오류 응답이 제공되어야 합니다. 엔터티의 수신자는 이해하거나 구현할 수 없는 Content-\*\(예: Content-Range\) 헤더를 무시해서는 안 되며, 그러한 경우 501\(구현되지 않음\) 응답을 반환해야 합니다.\(SHOULD, MUST, SHOULD, SHOULD, MUST NOT, MUST\)

요청이 캐시를 통과하고 Request-URI가 현재 캐시된 하나 이상의 엔터티를 식별하는 경우 해당 항목은 오래된 항목으로 처리되어야 합니다. 이 메서드에 대한 응답은 캐시할 수 없습니다.\(SHOULD\)

POST와 PUT 요청의 근본적인 차이점은 Request-URI의 다른 의미에 반영됩니다. POST 요청의 URI는 포함된 엔터티를 처리할 리소스를 식별합니다. 해당 리소스는 데이터를 허용하는 프로세스, 다른 프로토콜에 대한 게이트웨이 또는 주석을 허용하는 별도의 엔터티일 수 있습니다. 대조적으로, PUT 요청의 URI는 요청에 포함된 엔터티를 식별합니다. 사용자 에이전트는 어떤 URI가 의도되었는지 알고 있으며 서버는 요청을 다른 리소스에 적용하려고 시도해서는 안 됩니다. 서버가 요청이 다른 URI에 적용되기를 원하는 경우,\(MUST NOT\)

301\(영구적으로 이동됨\) 응답을 보내야 합니다. 그런 다음 사용자 에이전트는 요청을 리디렉션할지 여부를 자체적으로 결정할 수 있습니다.\(MUST\)

단일 리소스는 다양한 URI로 식별될 수 있습니다. 예를 들어 기사에는 각 특정 버전을 식별하는 URI와 별개로 "현재 버전"을 식별하기 위한 URI가 있을 수 있습니다. 이 경우 일반 URI에 대한 PUT 요청으로 인해 원본 서버에서 다른 여러 URI가 정의될 ​​수 있습니다.\(MAY\)

HTTP/1.1은 PUT 메서드가 원본 서버의 상태에 어떻게 영향을 미치는지 정의하지 않습니다.

PUT 요청은 섹션 8.2에 명시된 메시지 전송 요구 사항을 준수해야 합니다.\(MUST\)

특정 엔터티 헤더에 대해 달리 지정하지 않는 한, PUT 요청의 엔터티 헤더는 PUT에 의해 생성되거나 수정된 ​​리소스에 적용되어야 합니다.\(SHOULD\)

---
## **9.7 DELETE**

DELETE 메소드는 원서버가 Request-URI로 식별된 자원을 삭제하도록 요청한다. 이 방법은 원본 서버에 대한 사람의 개입\(또는 다른 수단\)에 의해 무시될 수 있습니다. 원본 서버에서 반환된 상태 코드가 작업이 성공적으로 완료되었음을 나타내더라도 클라이언트는 작업이 수행되었음을 보장할 수 없습니다. 그러나 서버는 응답이 제공될 때 리소스를 삭제하거나 액세스할 수 없는 위치로 이동할 의도가 없는 한 성공을 표시해서는 안 됩니다.\(MAY, SHOULD NOT\)

성공적인 응답은 응답에 상태를 설명하는 엔터티가 포함된 경우 200\(OK\), 작업이 아직 실행되지 않은 경우 202\(수락\), 작업이 실행되었지만 응답에 상태가 포함되지 않은 경우 204\(콘텐츠 없음\)여야 합니다. 엔터티.\(SHOULD\)

요청이 캐시를 통과하고 Request-URI가 현재 캐시된 하나 이상의 엔터티를 식별하는 경우 해당 항목은 오래된 항목으로 처리되어야 합니다. 이 메서드에 대한 응답은 캐시할 수 없습니다.\(SHOULD\)

---
## **9.8 TRACE**

TRACE 메소드는 요청 메시지의 원격 애플리케이션 계층 루프백을 호출하는 데 사용됩니다. 요청의 최종 수신자는 클라이언트에게 다시 수신된 메시지를 200\(OK\) 응답의 엔터티 본문으로 반영해야 합니다. 최종 수신자는 다음 중 하나입니다.\(SHOULD\)

요청에서 Max-Forwards 값 0을 수신하는 원본 서버 또는 첫 번째 프록시 또는 게이트웨이입니다\(섹션 14.31 참조\). TRACE 요청에는 엔터티가 포함되어서는 안 됩니다.\(MUST NOT\)

TRACE를 통해 클라이언트는 요청 체인의 다른 쪽 끝에서 수신되는 내용을 확인하고 해당 데이터를 테스트 또는 진단 정보에 사용할 수 있습니다. Via 헤더 필드\(섹션 14.45\)의 값은 요청 체인의 추적 역할을 하기 때문에 특히 중요합니다. Max-Forwards 헤더 필드를 사용하면 클라이언트가 요청 체인의 길이를 제한할 수 있으며, 이는 무한 루프에서 메시지를 전달하는 프록시 체인을 테스트하는 데 유용합니다.

요청이 유효한 경우 응답은 "message/http"의 Content-Type을 사용하여 엔터티 본문에 전체 요청 메시지를 포함해야 합니다. 이 메서드에 대한 응답은 캐시되어서는 안 됩니다.\(SHOULD, MUST NOT\)

---
## **9.9 CONNECT**

이 사양에서는 동적으로 터널로 전환할 수 있는 프록시와 함께 사용하기 위해 메소드 이름 CONNECT를 예약합니다\(예: SSL 터널링 \[44\]\).

---
# **10 Status Code Definitions**

각 상태 코드는 아래에 설명되어 있습니다. 여기에는 따를 수 있는 메서드에 대한 설명과 응답에 필요한 메타정보가 포함됩니다.

---
## **10.1 Informational 1xx**

이 상태 코드 클래스는 상태 줄과 선택적 헤더로만 구성된 임시 응답을 나타내며 빈 줄로 종료됩니다. 이 상태 코드 클래스에는 필수 헤더가 없습니다. HTTP/1.0은 1xx 상태 코드를 정의하지 않았으므로 서버는 실험 조건을 제외하고 HTTP/1.0 클라이언트에 1xx 응답을 보내서는 안 됩니다.\(MUST NOT\)

클라이언트는 100\(계속\) 상태 메시지를 기대하지 않더라도 일반 응답 전에 하나 이상의 1xx 상태 응답을 수락할 준비를 해야 합니다. 예상치 못한 1xx 상태 응답은 사용자 에이전트에 의해 무시될 수 있습니다.\(MUST, MAY\)

프록시와 클라이언트 간의 연결이 닫히지 않거나 프록시 자체가 1xx 응답 생성을 요청하지 않는 한 프록시는 1xx 응답을 전달해야 합니다. \(예를 들어,\(MUST\)

프록시는 요청을 전달할 때 "Expect: 100-continue" 필드를 추가합니다. 그러면 해당 100\(Continue\) 응답을 전달할 필요가 없습니다.\)

---
### **10.1.1 100 Continue**

클라이언트는 요청을 계속해야 합니다. 이 임시 응답은 요청의 초기 부분이 수신되었으며 아직 서버에서 거부되지 않았음을 클라이언트에 알리는 데 사용됩니다. 클라이언트는 요청의 나머지 부분을 보내 계속해야 하며, 요청이 이미 완료된 경우 이 응답을 무시해야 합니다. 서버는 요청이 완료된 후 최종 응답을 보내야 합니다. 이 상태 코드의 사용 및 처리에 대한 자세한 내용은 섹션 8.2.3을 참조하세요.\(SHOULD, SHOULD, MUST\)

---
### **10.1.2 101 Switching Protocols**

서버는 업그레이드 메시지 헤더 필드\(섹션 14.42\)를 통해 이 연결에서 사용되는 애플리케이션 프로토콜의 변경에 대한 클라이언트의 요청을 이해하고 기꺼이 준수합니다. 서버는 101 응답을 종료하는 빈 줄 바로 뒤에 있는 응답의 업그레이드 헤더 필드에 정의된 프로토콜로 프로토콜을 전환합니다.

프로토콜은 그렇게 하는 것이 유리한 경우에만 전환해야 합니다. 예를 들어, 최신 버전의 HTTP로 전환하는 것은 이전 버전보다 유리하며, 실시간 동기 프로토콜로 전환하는 것은 이러한 기능을 사용하는 리소스를 전달할 때 유리할 수 있습니다.\(SHOULD\)

---
## **10.2 Successful 2xx**

이 상태 코드 클래스는 클라이언트의 요청이 성공적으로 수신되고, 이해되고, 승인되었음을 나타냅니다.

---
### **10.2.1 200 OK**

요청이 성공했습니다. 응답과 함께 반환되는 정보는 요청에 사용된 방법에 따라 달라집니다. 예를 들면 다음과 같습니다.

```text
   GET    an entity corresponding to the requested resource is sent in
          the response;

   HEAD   the entity-header fields corresponding to the requested
          resource are sent in the response without any message-body;

   POST   an entity describing or containing the result of the action;
```

최종 서버가 수신한 요청 메시지가 포함된 엔터티를 추적합니다.

---
### **10.2.2 201 Created**

요청이 이행되어 새 리소스가 생성되었습니다. 새로 생성된 리소스는 Location 헤더 필드에서 제공하는 리소스에 대한 가장 구체적인 URI를 사용하여 응답 엔터티에서 반환된 URI에 의해 참조될 수 있습니다. 응답에는 사용자 또는 사용자 에이전트가 가장 적절한 것을 선택할 수 있는 리소스 특성 및 위치 목록이 포함된 엔터티가 포함되어야 합니다. 엔터티 형식은 Content-Type 헤더 필드에 제공된 미디어 유형으로 지정됩니다. 원본 서버는 201 상태 코드를 반환하기 전에 리소스를 생성해야 합니다. 작업을 즉시 수행할 수 없는 경우 서버는 대신 202\(수락\) 응답으로 응답해야 합니다.\(SHOULD, MUST, SHOULD\)

201 응답에는 방금 생성된 요청된 변형에 대한 엔터티 태그의 현재 값을 나타내는 ETag 응답 헤더 필드가 포함될 수 있습니다\(섹션 14.19 참조\).\(MAY\)

---
### **10.2.3 202 Accepted**

처리 요청이 승인되었지만 처리가 완료되지 않았습니다. 요청이 실제로 처리될 때 허용되지 않을 수 있으므로 결국에는 요청이 실행될 수도 있고 실행되지 않을 수도 있습니다. 이와 같은 비동기 작업에서 상태 코드를 다시 보내는 기능은 없습니다.

202 응답은 의도적으로 비커밋입니다. 그 목적은 프로세스가 완료될 때까지 서버에 대한 사용자 에이전트의 연결이 지속될 필요 없이 서버가 다른 프로세스\(아마도 하루에 한 번만 실행되는 배치 지향 프로세스\)에 대한 요청을 수락할 수 있도록 하는 것입니다. 이 응답과 함께 반환된 엔터티에는 요청의 현재 상태 표시와 상태 모니터에 대한 포인터 또는 사용자가 요청이 이행될 것으로 예상할 수 있는 시기에 대한 일부 추정이 포함되어야 합니다.\(SHOULD\)

---
### **10.2.4 203 Non-Authoritative Information**

엔터티 헤더에 반환된 메타정보는 원본 서버에서 사용할 수 있는 최종 세트가 아니지만 로컬 또는 타사 복사본에서 수집됩니다. 제시된 세트는 원래 버전의 하위 세트 또는 상위 세트일 수 있습니다. 예를 들어, 리소스에 대한 로컬 주석 정보를 포함하면 원본 서버가 알고 있는 메타정보의 상위 집합이 생성될 수 있습니다. 이 응답 코드를 사용할 필요는 없으며 응답이 200\(OK\)인 경우에만 적합합니다.\(MAY\)

---
### **10.2.5 204 No Content**

서버는 요청을 이행했지만 엔터티 본문을 반환할 필요가 없으며 업데이트된 메타정보를 반환하기를 원할 수도 있습니다. 응답에는 엔터티 헤더 형식의 새롭거나 업데이트된 메타정보가 포함될 수 있으며, 이 정보가 있는 경우 요청된 변형과 연결되어야 합니다.\(SHOULD\)

클라이언트가 사용자 에이전트인 경우 요청을 보낸 문서 보기를 변경해서는 안 됩니다. 이 응답은 주로 사용자 에이전트의 활성 문서 보기를 변경하지 않고 발생하는 작업에 대한 입력을 허용하기 위한 것이지만, 새롭거나 업데이트된 메타정보는 현재 사용자 에이전트의 활성 보기에 있는 문서에 적용되어야 합니다.\(SHOULD NOT, SHOULD\)

204 응답은 메시지 본문을 포함해서는 안 되며, 따라서 항상 헤더 필드 뒤의 첫 번째 빈 줄로 종료됩니다.\(MUST NOT\)

---
### **10.2.6 205 Reset Content**

서버는 요청을 이행했으며 사용자 에이전트는 요청을 전송하게 만든 문서 보기를 재설정해야 합니다. 이 응답은 주로 사용자 입력을 통해 발생하는 작업에 대한 입력을 허용하고 사용자가 다른 입력 작업을 쉽게 시작할 수 있도록 입력이 제공되는 형식을 지우는 데 사용됩니다. 응답에는 엔터티가 포함되어서는 안 됩니다.\(SHOULD, MUST NOT\)

---
### **10.2.7 206 Partial Content**

서버가 리소스에 대한 부분 GET 요청을 이행했습니다. 요청에는 원하는 범위를 나타내는 Range 헤더 필드\(섹션 14.35\)가 포함되어야 하며 요청을 조건부로 만들기 위해 If-Range 헤더 필드\(섹션 14.27\)가 포함될 수 있습니다.\(MUST\)

응답에는 다음 헤더 필드가 포함되어야 합니다.\(MUST\)

- - 이 응답에 포함된 범위를 나타내는 Content-Range 헤더 필드\(섹션 14.16\) 또는 각 부분에 대한 Content-Range 필드를 포함하는 multipart/byteranges Content-Type입니다. 응답에 Content-Length 헤더 필드가 있는 경우 해당 값은 메시지 본문에 전송된 실제 OCTET 수와 일치해야 합니다.\(MUST\)

```text
      - Date
```

- - ETag 및/또는 Content-Location\(헤더가 동일한 요청에 대한 200 응답으로 전송된 경우\)

- - 만료, 캐시 제어 및/또는 Vary\(필드 값이 동일한 변형에 대한 이전 응답에서 전송된 값과 다를 수 있음\)

206 응답이 강력한 캐시 유효성 검사기\(섹션 13.3.3 참조\)를 사용한 If-Range 요청의 결과인 경우 응답에는 다른 엔터티 헤더가 포함되어서는 안 됩니다. 응답이 약한 유효성 검사기를 사용한 If-Range 요청의 결과인 경우 응답에는 다른 엔터티 헤더가 포함되어서는 안 됩니다. 이는 캐시된 엔터티 본문과 업데이트된 헤더 간의 불일치를 방지합니다. 그렇지 않은 경우 응답에는 동일한 요청에 대한 200\(OK\) 응답과 함께 반환되었을 모든 엔터티 헤더가 포함되어야 합니다.\(SHOULD NOT, MUST NOT, MUST\)

ETag 또는 Last-Modified 헤더가 정확히 일치하지 않는 경우 캐시는 206 응답을 이전에 캐시된 다른 콘텐츠와 결합해서는 안 됩니다\(13.5.4 참조\).\(MUST NOT\)

Range 및 Content-Range 헤더를 지원하지 않는 캐시는 206\(부분\) 응답을 캐시해서는 안 됩니다.\(MUST NOT\)

---
## **10.3 Redirection 3xx**

이 상태 코드 클래스는 요청을 이행하기 위해 사용자 에이전트가 추가 조치를 취해야 함을 나타냅니다. 필요한 작업은 두 번째 요청에 사용된 메서드가 GET 또는 HEAD인 경우에만 사용자와의 상호 작용 없이 사용자 에이전트에 의해 수행될 수 있습니다. 클라이언트는 무한 리디렉션 루프를 감지해야 합니다. 이러한 루프는 각 리디렉션에 대한 네트워크 트래픽을 생성하기 때문입니다.\(MAY, SHOULD\)

- 참고: 이 사양의 이전 버전에서는 최대 5개의 리디렉션을 권장했습니다. 콘텐츠 개발자는 이러한 고정된 제한을 구현하는 클라이언트가 있을 수 있다는 점을 알고 있어야 합니다.

---
### **10.3.1 300 Multiple Choices**

요청된 리소스는 각각 고유한 특정 위치를 가진 표현 집합 중 하나에 해당하며 사용자\(또는 사용자 에이전트\)가 선호하는 표현을 선택하고 리디렉션할 수 있도록 에이전트 중심 협상 정보\(섹션 12\)가 제공됩니다. 해당 위치로 요청하세요.

HEAD 요청이 아닌 한, 응답에는 사용자 또는 사용자 에이전트가 가장 적절한 것을 선택할 수 있는 리소스 특성 및 위치 목록을 포함하는 엔터티가 포함되어야 합니다. 엔터티 형식은 Content-Type 헤더 필드에 제공된 미디어 유형으로 지정됩니다. 형식과 기능에 따라\(SHOULD\)

사용자 에이전트에서 가장 적절한 선택이 자동으로 수행될 수 있습니다. 그러나 본 사양에서는 이러한 자동 선택에 대한 어떠한 기준도 정의하지 않습니다.\(MAY\)

서버가 선호하는 표현을 선택하는 경우 위치 필드에 해당 표현에 대한 특정 URI를 포함해야 합니다. 사용자 에이전트는 자동 리디렉션을 위해 위치 필드 값을 사용할 수 있습니다. 달리 명시하지 않는 한 이 응답은 캐시 가능합니다.\(SHOULD\)

---
### **10.3.2 301 Moved Permanently**

요청된 리소스에는 새로운 영구 URI가 할당되었으며 이 리소스에 대한 향후 참조는 반환된 URI 중 하나를 사용해야 합니다. 링크 편집 기능이 있는 클라이언트는 가능한 경우 요청-URI에 대한 참조를 서버에서 반환된 하나 이상의 새 참조에 자동으로 다시 연결해야 합니다. 달리 명시하지 않는 한 이 응답은 캐시 가능합니다.\(SHOULD\)

새로운 영구 URI는 응답의 위치 필드에 의해 제공되어야 합니다. 요청 방법이 HEAD가 아닌 한, 응답 엔터티에는 새 URI에 대한 하이퍼링크가 포함된 짧은 하이퍼텍스트 메모가 포함되어야 합니다.\(SHOULD, SHOULD\)

GET 또는 HEAD 이외의 요청에 대한 응답으로 301 상태 코드가 수신되면 사용자 에이전트는 사용자가 확인할 수 없는 한 요청을 자동으로 리디렉션해서는 안 됩니다. 이는 요청이 발행된 조건을 변경할 수 있기 때문입니다.\(MUST NOT\)

참고: 이후 POST 요청을 자동으로 리디렉션하는 경우

- 301 상태 코드를 수신하면 일부 기존 HTTP/1.0 사용자 에이전트가 이를 GET 요청으로 잘못 변경합니다.

---
### **10.3.3 302 Found**

요청된 리소스는 일시적으로 다른 URI에 있습니다. 때때로 리디렉션이 변경될 수 있으므로 클라이언트는 향후 요청에 대해 Request-URI를 계속 사용해야 합니다. 이 응답은 Cache-Control 또는 Expires 헤더 필드에 표시된 경우에만 캐시할 수 있습니다.\(SHOULD\)

임시 URI는 응답의 위치 필드로 제공되어야 합니다. 요청 방법이 HEAD가 아닌 한, 응답 엔터티에는 새 URI에 대한 하이퍼링크가 포함된 짧은 하이퍼텍스트 메모가 포함되어야 합니다.\(SHOULD, SHOULD\)

GET 또는 HEAD 이외의 요청에 대한 응답으로 302 상태 코드가 수신되면 사용자 에이전트는 사용자가 확인할 수 없는 한 요청을 자동으로 리디렉션해서는 안 됩니다. 이는 요청이 발행된 조건을 변경할 수 있기 때문입니다.\(MUST NOT\)

- 참고: RFC 1945 및 RFC 2068에서는 클라이언트가 리디렉션된 요청에 대한 메서드를 변경할 수 없도록 지정합니다. 그러나 대부분의 기존 사용자 에이전트 구현은 302를 303 응답인 것처럼 처리하여 원래 요청 방법에 관계없이 위치 필드 값에 대해 GET을 수행합니다. 클라이언트에게 어떤 종류의 반응이 예상되는지 명확하게 밝히려는 서버에 대해 상태 코드 303 및 307이 추가되었습니다.

---
### **10.3.4 303 See Other**

요청에 대한 응답은 다른 URI에서 찾을 수 있으며 해당 리소스에 대한 GET 메서드를 사용하여 검색해야 합니다\(SHOULD\). 이 방법은 주로 POST 활성화 스크립트의 출력이 사용자 에이전트를 선택한 리소스로 리디렉션할 수 있도록 하기 위해 존재합니다. 새 URI는 원래 요청한 리소스에 대한 대체 참조가 아닙니다. 303 응답은 캐시되어서는 안 되지만 두 번째\(리디렉션된\) 요청에 대한 응답은 캐시될 수 있습니다.\(SHOULD, MUST NOT\)

응답의 위치 필드에 다른 URI가 제공되어야 합니다. 요청 방법이 HEAD가 아닌 한, 응답 엔터티에는 새 URI에 대한 하이퍼링크가 포함된 짧은 하이퍼텍스트 메모가 포함되어야 합니다.\(SHOULD, SHOULD\)

- 참고: HTTP/1.1 이전의 많은 사용자 에이전트는 303 상태를 이해하지 못합니다. 이러한 클라이언트와의 상호 운용성이 문제가 되는 경우 대부분의 사용자 에이전트가 303에 대해 여기에 설명된 대로 302 응답에 반응하므로 302 상태 코드를 대신 사용할 수 있습니다.

---
### **10.3.5 304 Not Modified**

클라이언트가 조건부 GET 요청을 수행하고 액세스가 허용되었지만 문서가 수정되지 않은 경우 서버는 이 상태 코드로 응답해야 합니다. 304 응답은 메시지 본문을 포함해서는 안 되며, 따라서 항상 헤더 필드 뒤의 첫 번째 빈 줄로 종료됩니다.\(SHOULD, MUST NOT\)

응답에는 다음 헤더 필드가 포함되어야 합니다.\(MUST\)

- - 날짜\(14.18.1항에 따라 생략이 요구되지 않는 한\)

시계 없는 원본 서버가 이러한 규칙을 따르고 프록시와 클라이언트가 규칙 없이 수신된 응답에 자신의 날짜를 추가하는 경우\(\[RFC 2068\], 섹션 14.19에 이미 지정된 대로\) 캐시가 올바르게 작동합니다.

- - ETag 및/또는 Content-Location\(헤더가 동일한 요청에 대한 200 응답으로 전송된 경우\)

- - 만료, 캐시 제어 및/또는 Vary\(필드 값이 동일한 변형에 대한 이전 응답에서 전송된 값과 다를 수 있음\)

조건부 GET이 강력한 캐시 유효성 검사기를 사용한 경우\(섹션 13.3.3 참조\) 응답에는 다른 엔터티 헤더가 포함되어서는 안 됩니다. 그렇지 않은 경우\(즉, 조건부 GET이 약한 유효성 검사기를 사용함\) 응답에는 다른 엔터티 헤더가 포함되어서는 안 됩니다. 이는 캐시된 엔터티 본문과 업데이트된 헤더 간의 불일치를 방지합니다.\(SHOULD NOT, MUST NOT\)

304 응답이 현재 캐시되지 않은 엔터티를 나타내는 경우 캐시는 응답을 무시하고 조건 없이 요청을 반복해야 합니다.\(MUST\)

캐시가 수신된 304 응답을 사용하여 캐시 항목을 업데이트하는 경우 캐시는 응답에 제공된 새로운 필드 값을 반영하도록 항목을 업데이트해야 합니다.\(MUST\)

---
### **10.3.6 305 Use Proxy**

요청된 리소스는 위치 필드에 제공된 프록시를 통해 액세스되어야 합니다. 위치 필드는 프록시의 URI를 제공합니다. 수신자는 프록시를 통해 이 단일 요청을 반복해야 합니다. 305 응답은 원본 서버에서만 생성되어야 합니다.\(MUST, MUST\)

- 참고: RFC 2068은 305가 단일 요청을 리디렉션하고 원본 서버에서만 생성되도록 의도되었다는 점을 명확하게 밝히지 않았습니다. 이러한 제한 사항을 준수하지 않으면 보안상 심각한 결과를 초래할 수 있습니다.

---
### **10.3.7 306 (Unused)**

306 상태 코드는 이전 버전의 사양에서 사용되었으며 더 이상 사용되지 않으며 해당 코드는 예약되어 있습니다.

---
### **10.3.8 307 Temporary Redirect**

요청된 리소스는 일시적으로 다른 URI에 있습니다. 때때로 리디렉션이 변경될 수 있으므로 클라이언트는 향후 요청에 대해 Request-URI를 계속 사용해야 합니다. 이 응답은 Cache-Control 또는 Expires 헤더 필드에 표시된 경우에만 캐시할 수 있습니다.\(SHOULD\)

임시 URI는 응답의 위치 필드로 제공되어야 합니다. 요청 방법이 HEAD가 아닌 한, 응답 엔터티에는 새 URI에 대한 하이퍼링크가 포함된 짧은 하이퍼텍스트 메모가 포함되어야 합니다. 많은 HTTP/1.1 이전 사용자 에이전트가 307 상태를 이해하지 못하기 때문입니다. 따라서 메모에는 사용자가 새 URI에서 원래 요청을 반복하는 데 필요한 정보가 포함되어야 합니다.\(SHOULD, SHOULD, SHOULD\)

GET 또는 HEAD 이외의 요청에 대한 응답으로 307 상태 코드가 수신되면 사용자 에이전트는 사용자가 확인할 수 없는 한 요청을 자동으로 리디렉션해서는 안 됩니다. 이는 요청이 발행된 조건을 변경할 수 있기 때문입니다.\(MUST NOT\)

---
## **10.4 Client Error 4xx**

4xx 클래스의 상태 코드는 클라이언트가 오류를 범한 것으로 보이는 경우를 위한 것입니다. HEAD 요청에 응답하는 경우를 제외하고 서버는 오류 상황에 대한 설명과 그것이 일시적인지 영구적인지 여부를 포함하는 엔터티를 포함해야 합니다. 이러한 상태 코드는 모든 요청 방법에 적용 가능합니다. 사용자 에이전트는 포함된 엔터티를 사용자에게 표시해야 합니다.\(SHOULD, SHOULD\)

클라이언트가 데이터를 보내는 경우 TCP를 사용하는 서버 구현은 서버가 입력 연결을 닫기 전에 클라이언트가 응답이 포함된 패킷의 수신을 확인하도록 주의해야 합니다. 클라이언트가 닫힌 후에도 계속해서 서버에 데이터를 보내는 경우 서버의 TCP 스택은 클라이언트에 재설정 패킷을 보냅니다. 이로 인해 클라이언트의 확인되지 않은 입력 버퍼가 HTTP 애플리케이션에서 읽고 해석되기 전에 지워질 수 있습니다.\(SHOULD\)

---
### **10.4.1 400 Bad Request**

잘못된 구문으로 인해 서버에서 요청을 이해할 수 없습니다. 클라이언트는 수정 없이 요청을 반복해서는 안 됩니다.\(SHOULD NOT\)

---
### **10.4.2 401 Unauthorized**

요청에는 사용자 인증이 필요합니다. 응답에는 요청된 리소스에 적용 가능한 챌린지를 포함하는 WWW-Authenticate 헤더 필드\(섹션 14.47\)가 포함되어야 합니다. 클라이언트는 적절한 Authorization 헤더 필드\(섹션 14.8\)를 사용하여 요청을 반복할 수 있습니다. 요청에 이미 인증 자격 증명이 포함된 경우 401 응답은 해당 자격 증명에 대한 인증이 거부되었음을 나타냅니다. 401 응답에 이전 응답과 동일한 챌린지가 포함되어 있고 사용자 에이전트가 이미 한 번 이상 인증을 시도한 경우 응답에 제공된 엔터티가 관련 진단 정보를 포함할 수 있으므로 사용자에게 해당 엔터티가 표시되어야 합니다. HTTP 접근 인증은 "HTTP 인증: 기본 및 다이제스트 접근 인증" \[43\]에서 설명된다.\(MUST, MAY, SHOULD\)

---
### **10.4.3 402 Payment Required**

이 코드는 향후 사용을 위해 예약되어 있습니다.

---
### **10.4.4 403 Forbidden**

서버가 요청을 이해했지만 이행을 거부하고 있습니다. 승인은 도움이 되지 않으며 요청을 반복해서는 안 됩니다. 요청 방법이 HEAD가 아니고 서버가 요청이 이행되지 않은 이유를 공개하려는 경우 엔터티에 거부 이유를 설명해야 합니다. 서버가 이 정보를 클라이언트에 제공하지 않으려면 상태 코드 404\(찾을 수 없음\)를 대신 사용할 수 있습니다.\(SHOULD NOT, SHOULD\)

---
### **10.4.5 404 Not Found**

서버가 Request-URI와 일치하는 항목을 찾지 못했습니다. 상태가 일시적인지 영구적인지에 대한 표시는 없습니다. 410\(Gone\) 상태 코드는 서버가 내부적으로 구성 가능한 메커니즘을 통해 이전 리소스를 영구적으로 사용할 수 없고 전달 주소가 없다는 것을 알고 있는 경우 사용해야 합니다. 이 상태 코드는 서버가 요청이 거부된 정확한 이유를 밝히고 싶지 않거나 적용할 수 있는 다른 응답이 없을 때 일반적으로 사용됩니다.\(SHOULD\)

---
### **10.4.6 405 Method Not Allowed**

Request-Line에 지정된 방법은 Request-URI로 식별된 리소스에 대해 허용되지 않습니다. 응답에는 요청된 리소스에 대한 유효한 메서드 목록이 포함된 Allow 헤더가 포함되어야 합니다.\(MUST\)

---
### **10.4.7 406 Not Acceptable**

요청에 의해 식별된 리소스는 요청에서 전송된 수락 헤더에 따라 허용되지 않는 콘텐츠 특성을 가진 응답 엔터티만 생성할 수 있습니다.

HEAD 요청이 아닌 한, 응답에는 사용자 또는 사용자 에이전트가 가장 적절한 것을 선택할 수 있는 사용 가능한 엔터티 특성 및 위치 목록이 포함된 엔터티가 포함되어야 합니다. 엔터티 형식은 Content-Type 헤더 필드에 제공된 미디어 유형으로 지정됩니다. 사용자 에이전트의 형식과 기능에 따라 가장 적절한 선택이 자동으로 수행될 수 있습니다. 그러나 본 사양에서는 이러한 자동 선택에 대한 어떠한 기준도 정의하지 않습니다.\(SHOULD, MAY\)

- 참고: HTTP/1.1 서버는 요청에 전송된 승인 헤더에 따라 허용되지 않는 응답을 반환할 수 있습니다. 어떤 경우에는 406 응답을 보내는 것보다 이것이 더 나을 수도 있습니다. 사용자 에이전트는 수신 응답의 헤더를 검사하여 허용 가능한지 확인하는 것이 좋습니다.

응답을 받아들일 수 없는 경우 사용자 에이전트는 추가 데이터 수신을 일시적으로 중단하고 사용자에게 추가 작업에 대한 결정을 문의해야 합니다.\(SHOULD\)

---
### **10.4.8 407 Proxy Authentication Required**

이 코드는 401\(인증되지 않음\)과 유사하지만 클라이언트가 먼저 프록시를 통해 자신을 인증해야 함을 나타냅니다. 프록시는 요청된 리소스에 대해 프록시에 적용 가능한 챌린지를 포함하는 Proxy-Authenticate 헤더 필드\(섹션 14.33\)를 반환해야 합니다. 클라이언트는 적절한 Proxy-Authorization 헤더 필드\(섹션 14.34\)를 사용하여 요청을 반복할 수 있습니다. HTTP 접근 인증은 "HTTP 인증: 기본 및 다이제스트 접근 인증" \[43\]에서 설명된다.\(MUST, MAY\)

---
### **10.4.9 408 Request Timeout**

서버가 대기할 준비가 된 시간 내에 클라이언트가 요청을 생성하지 않았습니다. 클라이언트는 나중에 수정 없이 요청을 반복할 수 있습니다.\(MAY\)

---
### **10.4.10 409 Conflict**

리소스의 현재 상태와의 충돌로 인해 요청을 완료할 수 없습니다. 이 코드는 사용자가 충돌을 해결하고 요청을 다시 제출할 수 있을 것으로 예상되는 상황에서만 허용됩니다. 응답 본문에는 충분한 내용이 포함되어야 합니다.\(SHOULD\)

사용자가 충돌의 원인을 인식할 수 있도록 정보를 제공합니다. 이상적으로 응답 엔터티에는 사용자 또는 사용자 에이전트가 문제를 해결하는 데 충분한 정보가 포함됩니다. 그러나 이는 불가능할 수도 있고 필수 사항도 아닙니다.

PUT 요청에 대한 응답으로 충돌이 발생할 가능성이 가장 높습니다. 예를 들어, 버전 관리가 사용되고 PUT 중인 엔터티에 이전\(타사\) 요청에 의해 생성된 것과 충돌하는 리소스 변경 사항이 포함된 경우 서버는 409 응답을 사용하여 요청을 완료할 수 없음을 나타낼 수 있습니다. . 이 경우 응답 엔터티에는 응답 Content-Type에 정의된 형식으로 두 버전 간의 차이점 목록이 포함될 가능성이 높습니다.

---
### **10.4.11 410 Gone**

요청한 리소스는 더 이상 서버에서 사용할 수 없으며 전달 주소도 알려져 있지 않습니다. 이 상태는 영구적인 것으로 간주될 것으로 예상됩니다. 링크 편집 기능이 있는 클라이언트는 사용자 승인 후 Request-URI에 대한 참조를 삭제해야 합니다. 서버가 조건이 영구적인지 여부를 알 수 없거나 결정할 수 있는 기능이 없는 경우 상태 코드 404\(찾을 수 없음\)를 대신 사용해야 합니다. 달리 명시하지 않는 한 이 응답은 캐시 가능합니다.\(SHOULD, SHOULD\)

410 응답은 주로 리소스를 의도적으로 사용할 수 없으며 서버 소유자가 해당 리소스에 대한 원격 링크를 제거하기를 원한다는 사실을 수신자에게 알려 웹 유지 관리 작업을 지원하기 위한 것입니다. 이러한 이벤트는 제한된 시간 동안 진행되는 판촉 서비스 및 더 이상 서버 사이트에서 근무하지 않는 개인에게 속한 리소스에 대해 일반적입니다. 영구적으로 사용할 수 없는 모든 리소스를 "사라짐"으로 표시하거나 일정 기간 동안 표시를 유지할 필요는 없습니다. 이는 서버 소유자의 재량에 달려 있습니다.

---
### **10.4.12 411 Length Required**

서버는 정의된 콘텐츠 길이 없이 요청 수락을 거부합니다. 클라이언트는 요청 메시지에 message-body의 길이를 포함하는 유효한 Content-Length 헤더 필드를 추가하는 경우 요청을 반복할 수 있습니다.\(MAY\)

---
### **10.4.13 412 Precondition Failed**

하나 이상의 요청 헤더 필드에 제공된 전제 조건이 서버에서 테스트되었을 때 false로 평가되었습니다. 이 응답 코드를 사용하면 클라이언트는 현재 리소스 메타 정보\(헤더 필드 데이터\)에 사전 조건을 배치하여 요청된 메서드가 의도한 리소스 이외의 리소스에 적용되는 것을 방지할 수 있습니다.

---
### **10.4.14 413 Request Entity Too Large**

요청 엔터티가 서버가 처리할 의사가 있거나 처리할 수 있는 것보다 크기 때문에 서버가 요청 처리를 거부하고 있습니다. 서버는 클라이언트가 요청을 계속하는 것을 방지하기 위해 연결을 닫을 수 있습니다.\(MAY\)

조건이 일시적인 경우 서버는 그것이 일시적임을 나타내고 클라이언트가 몇 시간 후에 다시 시도할 수 있는지를 나타내기 위해 Retry-After 헤더 필드를 포함해야 합니다.\(SHOULD\)

---
### **10.4.15 414 Request-URI Too Long**

요청-URI가 서버가 해석할 수 있는 것보다 길기 때문에 서버가 요청 서비스를 거부하고 있습니다. 이 드문 상황은 클라이언트가 긴 쿼리 정보가 포함된 POST 요청을 GET 요청으로 부적절하게 변환한 경우, 클라이언트가 리디렉션의 URI "블랙홀"\(예: 다음을 가리키는 리디렉션된 URI 접두사\)에 빠진 경우에만 발생할 가능성이 높습니다. 자체 접미사\) 또는 요청-URI를 읽거나 조작하기 위해 고정 길이 버퍼를 사용하는 일부 서버에 존재하는 보안 허점을 악용하려는 클라이언트에 의해 서버가 공격을 받는 경우입니다.

---
### **10.4.16 415 Unsupported Media Type**

요청 엔터티가 요청된 메서드에 대해 요청한 리소스에서 지원하지 않는 형식이기 때문에 서버가 요청 서비스를 거부하고 있습니다.

---
### **10.4.17 416 Requested Range Not Satisfiable**

요청에 Range 요청 헤더 필드\(섹션 14.35\)가 포함되어 있고 이 필드의 범위 지정자 값 중 어느 것도 선택한 리소스의 현재 범위와 겹치지 않고 요청이 그렇지 않은 경우 서버는 이 상태 코드로 응답을 반환해야 합니다. If-Range 요청 헤더 필드를 포함합니다. \(바이트 범위의 경우 이는 모든 byte-range-spec 값 중 첫 번째 byte-pos가 선택한 리소스의 현재 길이보다 컸음을 의미합니다.\)\(SHOULD\)

바이트 범위 요청에 대해 이 상태 코드가 반환되면 응답에는 선택한 리소스의 현재 길이를 지정하는 Content-Range 엔터티 헤더 필드가 포함되어야 합니다\(섹션 14.16 참조\). 이 응답은 multipart/byteranges 콘텐츠 유형을 사용하면 안 됩니다.\(SHOULD, MUST NOT\)

---
### **10.4.18 417 Expectation Failed**

Expect 요청 헤더 필드\(14.20절 참조\)에 주어진 기대를 이 서버가 충족할 수 없거나, 서버가 프록시인 경우 서버는 다음 홉 서버가 요청을 충족할 수 없다는 명확한 증거를 가지고 있습니다. .

---
## **10.5 Server Error 5xx**

숫자 "5"로 시작하는 응답 상태 코드는 서버가 오류가 발생했거나 요청을 수행할 수 없음을 인식하는 경우를 나타냅니다. HEAD 요청에 응답하는 경우를 제외하고 서버는 오류 상황에 대한 설명과 그것이 일시적인지 영구적인지 여부를 포함하는 엔터티를 포함해야 합니다. 사용자 에이전트는 포함된 엔터티를 사용자에게 표시해야 합니다. 이러한 응답 코드는 모든 요청 방법에 적용 가능합니다.\(SHOULD, SHOULD\)

---
### **10.5.1 500 Internal Server Error**

서버에서 요청을 이행할 수 없는 예상치 못한 상황이 발생했습니다.

---
### **10.5.2 501 Not Implemented**

서버가 요청을 이행하는 데 필요한 기능을 지원하지 않습니다. 이는 서버가 요청 방법을 인식하지 못하고 어떤 리소스에도 이를 지원할 수 없는 경우에 적합한 응답입니다.

---
### **10.5.3 502 Bad Gateway**

서버가 게이트웨이 또는 프록시 역할을 하는 동안 요청을 이행하려고 시도하는 동안 액세스한 업스트림 서버로부터 잘못된 응답을 받았습니다.

---
### **10.5.4 503 Service Unavailable**

일시적인 과부하 또는 서버 점검으로 인해 현재 서버에서 요청을 처리할 수 없습니다. 이는 이것이 일시적인 상태이며 약간의 시간이 지나면 완화될 것이라는 의미입니다. 알려진 경우 지연 길이는 Retry-After 헤더에 표시될 수 있습니다. Retry-After가 제공되지 않으면 클라이언트는 500 응답과 마찬가지로 응답을 처리해야 합니다.\(MAY, SHOULD\)

- 참고: 503 상태 코드가 존재한다고 해서 서버가 과부하될 때 이를 사용해야 한다는 의미는 아닙니다. 일부 서버에서는 단순히 연결을 거부할 수도 있습니다.

---
### **10.5.5 504 Gateway Timeout**

서버가 게이트웨이 또는 프록시 역할을 하는 동안 URI\(예: HTTP, FTP, LDAP\) 또는 완료를 시도하는 데 액세스해야 하는 기타 보조 서버\(예: DNS\)로 지정된 업스트림 서버로부터 적시에 응답을 받지 못했습니다. 요청.

- 참고: 구현자 참고 사항: 배포된 일부 프록시는 DNS 조회 시간이 초과될 때 400 또는 500을 반환하는 것으로 알려져 있습니다.

---
### **10.5.6 505 HTTP Version Not Supported**

서버가 요청 메시지에 사용된 HTTP 프로토콜 버전을 지원하지 않거나 지원을 거부합니다. 서버는 이 오류 메시지 외에 섹션 3.1에 설명된 대로 클라이언트와 동일한 주요 버전을 사용하여 요청을 완료할 수 없거나 완료할 의사가 없음을 나타냅니다. 응답에는 해당 버전이 지원되지 않는 이유와 해당 서버에서 지원하는 다른 프로토콜을 설명하는 엔터티가 포함되어야 합니다.\(SHOULD\)

---
# **11 Access Authentication**

HTTP는 서버가 클라이언트 요청에 도전하고 클라이언트가 인증 정보를 제공하는 데 사용할 수 있는 몇 가지 선택적 도전-응답 인증 메커니즘을 제공합니다. 액세스 인증을 위한 일반적인 프레임워크와 "기본" 및 "다이제스트" 인증 사양은 "HTTP 인증: 기본 및 다이제스트 액세스 인증" \[43\]에 지정되어 있습니다. 이 사양은 해당 사양의 "챌린지" 및 "자격 증명"의 정의를 채택합니다.\(MAY\)

---
# **12 Content Negotiation**

대부분의 HTTP 응답에는 인간 사용자가 해석할 수 있는 정보가 포함된 엔터티가 포함되어 있습니다. 당연히 요청에 해당하는 "가장 좋은" 엔터티를 사용자에게 제공하는 것이 바람직합니다. 불행하게도 서버와 캐시의 경우 모든 사용자가 "최고"에 대해 동일한 선호도를 갖는 것은 아니며 모든 사용자 에이전트가 모든 엔터티 유형을 동등하게 렌더링할 수 있는 것도 아닙니다. 이러한 이유로 HTTP에는 "콘텐츠 협상"\(사용 가능한 표현이 여러 개 있을 때 주어진 응답에 대해 가장 적합한 표현을 선택하는 프로세스\)을 위한 여러 메커니즘이 제공됩니다.

참고: 이는 "형식 협상"이라고 부르지 않습니다.

- 대체 표현은 동일한 미디어 유형일 수 있지만 해당 유형의 다른 기능을 사용하거나 다른 언어로 되어 있을 수 있습니다.

오류 응답을 포함하여 Entity-Body를 포함하는 모든 응답은 협상 대상이 될 수 있습니다.\(MAY\)

HTTP에서 가능한 콘텐츠 협상에는 서버 중심 협상과 에이전트 중심 협상이라는 두 가지 종류가 있습니다. 이 두 종류의 협상은 직교하므로 별도로 사용할 수도 있고 조합하여 사용할 수도 있습니다. 투명 협상이라고 하는 한 가지 조합 방법은 후속 요청에 대해 서버 중심 협상을 제공하기 위해 캐시가 원본 서버에서 제공한 에이전트 중심 협상 정보를 사용할 때 발생합니다.

---
## **12.1 Server-driven Negotiation**

응답에 대한 최상의 표현을 선택하는 것이 서버에 있는 알고리즘에 의해 이루어지는 경우 이를 서버 중심 협상이라고 합니다. 선택은 응답의 사용 가능한 표현\(언어, 콘텐츠 코딩 등 다양할 수 있는 차원\)과 요청 메시지의 특정 헤더 필드 내용 또는 요청과 관련된 기타 정보\(예: 클라이언트의 네트워크 주소로\).

서버 중심 협상은 사용 가능한 표현 중에서 선택하는 알고리즘이 사용자 에이전트에 설명하기 어렵거나 서버가 첫 번째 응답과 함께 클라이언트에 "최선의 추측"을 보내려고 할 때 유리합니다. "최선의 추측"이 사용자에게 충분할 경우 후속 요청의 왕복 지연\). 서버의 추측을 향상시키기 위해 사용자 에이전트는 그러한 응답에 대한 선호도를 설명하는 요청 헤더 필드\(Accept, Accept-Language, Accept-Encoding 등\)를 포함할 수 있습니다.\(MAY\)

서버 중심 협상에는 다음과 같은 단점이 있습니다.

- 1. 서버가 특정 사용자에게 "최적"인 것이 무엇인지 정확하게 결정하는 것은 불가능합니다. 이를 위해서는 사용자 에이전트의 기능과 응답의 의도된 사용에 대한 완전한 지식이 필요하기 때문입니다\(예: 사용자가 화면에서 보거나 종이에 인쇄하고 싶습니까?\).

- 2. 사용자 에이전트가 모든 요청에 ​​대해 해당 기능을 설명하도록 하는 것은 매우 비효율적일 수 있으며\(응답의 소수만이 다중 표현을 갖는다는 점을 감안할 때\) 잠재적으로 사용자의 개인정보를 침해할 수 있습니다.

- 3. 원본 서버의 구현과 요청에 대한 응답을 생성하는 알고리즘이 복잡해집니다.

- 4. 여러 사용자의 요청에 대해 동일한 응답을 사용하는 공용 캐시의 기능을 제한할 수 있습니다.

HTTP/1.1에는 사용자 에이전트 기능 및 사용자 기본 설정 설명을 통해 서버 중심 협상을 활성화하기 위한 다음 요청 헤더 필드가 포함되어 있습니다. Accept\(섹션 14.1\), Accept-Charset\(섹션 14.2\), Accept-Encoding\(섹션 14.3\), Accept- 언어\(섹션 14.4\) 및 사용자 에이전트\(섹션 14.43\). 그러나 원서버는 이러한 차원으로 제한되지 않으며 요청 헤더 필드 외부 또는 이 사양에 정의되지 않은 확장 헤더 필드 내의 정보를 포함하여 요청의 모든 측면에 따라 응답을 변경할 수 있습니다.\(MAY\)

Vary 헤더 필드는 서버 중심 협상에 따라 표현을 선택하기 위해 서버가 사용하는 매개변수를 표현하는 데 사용될 수 있습니다. 캐시에 의한 Vary 헤더 필드 사용에 대해서는 섹션 13.6을 참조하고 서버에 의한 Vary 헤더 필드 사용에 대해서는 섹션 14.44를 참조하십시오.

---
## **12.2 Agent-driven Negotiation**

에이전트 중심 협상을 사용하면 원본 서버로부터 초기 응답을 받은 후 사용자 에이전트가 응답에 대한 최상의 표현을 선택합니다. 선택은 초기 응답의 헤더 필드 또는 엔터티 본문 내에 포함된 응답의 사용 가능한 표현 목록을 기반으로 하며 각 표현은 자체 URI로 식별됩니다. 표현 중에서 선택은 자동으로 수행되거나\(사용자 에이전트가 그렇게 할 수 있는 경우\) 사용자가 생성된\(아마도 하이퍼텍스트\) 메뉴에서 선택하여 수동으로 수행될 수 있습니다.

에이전트 중심 협상은 응답이 일반적으로 사용되는 차원\(예: 유형, 언어 또는 인코딩\)에 따라 다를 때, 원서버가 요청 검사에서 사용자 에이전트의 기능을 결정할 수 없을 때, 일반적으로 공개 캐시가 서버 부하를 분산하고 네트워크 사용량을 줄이는 데 사용됩니다.

에이전트 중심 협상은 최상의 대체 표현을 얻기 위해 두 번째 요청이 필요하다는 단점이 있습니다. 이 두 번째 요청은 캐싱을 사용할 때만 효율적입니다. 또한 이 사양은 자동 선택을 지원하는 메커니즘을 정의하지 않지만 이러한 메커니즘이 확장으로 개발되어 HTTP/1.1 내에서 사용되는 것을 방지하지는 않습니다.

HTTP/1.1은 서버가 서버 중심 협상을 사용하여 다양한 응답을 제공할 의지가 없거나 제공할 수 없는 경우 에이전트 중심 협상을 활성화하기 위한 300\(다중 선택\) 및 406\(허용되지 않음\) 상태 코드를 정의합니다.

---
## **12.3 Transparent Negotiation**

투명한 협상은 서버 중심 협상과 에이전트 중심 협상의 조합입니다. 캐시에 사용 가능한 응답 표현 목록 형식이 제공되고\(에이전트 중심 협상에서와 같이\) 변화의 차원이 캐시에 의해 완전히 이해되면 캐시는 서버 중심 협상을 대신 수행할 수 있게 됩니다. 해당 리소스에 대한 후속 요청을 위해 원본 서버의

투명한 협상은 원본 서버에 필요한 협상 작업을 분산하고 캐시가 올바른 응답을 올바르게 추측할 수 있을 때 에이전트 중심 협상의 두 번째 요청 지연을 제거하는 이점이 있습니다.

이 사양은 투명한 협상을 위한 메커니즘을 정의하지 않지만 그러한 메커니즘이 HTTP/1.1 내에서 사용할 수 있는 확장으로 개발되는 것을 방지하지는 않습니다.

---
# **13 Caching in HTTP**

HTTP는 일반적으로 응답 캐시를 사용하여 성능을 향상시킬 수 있는 분산 정보 시스템에 사용됩니다. HTTP/1.1 프로토콜에는 캐싱 작업을 최대한 효과적으로 수행하기 위한 여러 요소가 포함되어 있습니다. 이러한 요소는 프로토콜의 다른 측면과 분리될 수 없고 서로 상호 작용하기 때문에 메서드, 헤더, 응답 코드 등에 대한 자세한 설명과 별도로 HTTP의 기본 캐싱 설계를 설명하는 것이 유용합니다.

성능이 크게 향상되지 않으면 캐싱은 쓸모가 없습니다. HTTP/1.1에서 캐싱의 목적은 많은 경우에 요청을 보낼 필요를 없애고 다른 많은 경우에 전체 응답을 보낼 필요를 없애는 것입니다. 전자는 많은 작업에 필요한 네트워크 왕복 횟수를 줄입니다. 우리는 이 목적을 위해 "만료" 메커니즘을 사용합니다\(섹션 13.2 참조\). 후자는 네트워크 대역폭 요구 사항을 줄입니다. 우리는 이 목적을 위해 "검증" 메커니즘을 사용합니다\(섹션 13.3 참조\).

성능, 가용성 및 연결 끊김 작업에 대한 요구 사항은 의미 투명성이라는 목표를 완화할 수 있어야 합니다. HTTP/1.1 프로토콜은 원본 서버, 캐시,

클라이언트는 필요한 경우 명시적으로 투명성을 줄입니다. 그러나 불투명한 작업은 비전문가 사용자에게 혼란을 줄 수 있고 특정 서버 응용 프로그램\(예: 상품 주문 응용 프로그램\)과 호환되지 않을 수 있으므로 프로토콜에서는 투명성을 완화해야 합니다.

- - 클라이언트 또는 원본 서버에 의해 완화된 경우 명시적인 프로토콜 수준 요청에 의해서만

- - 캐시 또는 클라이언트에 의해 완화될 때 최종 사용자에게 명시적인 경고만 제공

따라서 HTTP/1.1 프로토콜은 다음과 같은 중요한 요소를 제공합니다.

- 1. 모든 당사자가 요구할 때 완전한 의미 투명성을 제공하는 프로토콜 기능.

- 2. 원서버나 사용자 에이전트가 불투명한 작업을 명시적으로 요청하고 제어할 수 있도록 하는 프로토콜 기능입니다.

- 3. 캐시가 요청된 의미 투명성의 근사치를 보존하지 않는 응답에 경고를 첨부할 수 있도록 하는 프로토콜 기능.

기본 원칙은 클라이언트가 의미 투명성의 잠재적 완화를 감지하는 것이 가능해야 한다는 것입니다.

- 참고: 서버, 캐시 또는 클라이언트 구현자는 이 사양에서 명시적으로 논의되지 않은 디자인 결정에 직면할 수 있습니다. 결정이 의미적 투명성에 영향을 미칠 수 있는 경우, 신중하고 완전한 분석을 통해 투명성을 깨는 데 상당한 이점이 나타나지 않는 한 구현자는 투명성을 유지하는 측면에서 오류를 범해야 합니다.

---
### **13.1.1 Cache Correctness**

올바른 캐시는 다음 조건 중 하나를 충족하는 요청에 적합한 캐시가 보유하는 최신 응답으로 요청에 응답해야 합니다\(섹션 13.2.5, 13.2.6 및 13.12 참조\).\(MUST\)

```text
      1. It has been checked for equivalence with what the origin server
         would have returned by revalidating the response with the
         origin server (section 13.3);
```

- 2. "충분히 신선하다"\(섹션 13.2 참조\). 기본 경우 이는 클라이언트, 원본 서버 및 캐시의 최소 제한 신선도 요구 사항을 충족함을 의미합니다\(14.9절 참조\). 원본 서버가 그렇게 지정하는 경우 원본 서버만의 신선도 요구 사항이 적용됩니다.

저장된 응답이 "충분히 신선하지" 않은 경우

- 클라이언트와 원서버 모두의 제한적인 신선도 요구 사항으로, 신중하게 고려된 상황에서 캐시는 그러한 응답이 금지되지 않는 한\(예: "no-store" 캐시 지시어 또는 "no-cache" 캐시 요청 지시어\(섹션 14.9 참조\).\(MAY\)

- 3. 적절한 304\(수정되지 않음\), 305\(프록시 리디렉션\) 또는 오류\(4xx 또는 5xx\) 응답 메시지입니다.

캐시가 원본 서버와 통신할 수 없는 경우 응답이 캐시에서 올바르게 제공될 수 있으면 올바른 캐시는 위와 같이 응답해야 합니다. 그렇지 않은 경우 통신 실패가 있음을 나타내는 오류나 경고를 반환해야 합니다.\(MUST\)

캐시가 일반적으로 요청 클라이언트에 전달하는 응답\(전체 응답 또는 304\(수정되지 않음\) 응답\)을 수신하고 수신된 응답이 더 이상 신선하지 않은 경우, 캐시는 이를 요청 클라이언트에 전달해야 합니다\(SHOULD\). 새 경고를 추가합니다\(기존 경고 헤더는 제거하지 않음\). 캐시는 단순히 응답이 전송 중에 오래되었다는 이유로 응답을 재검증하려고 시도해서는 안 됩니다. 이로 인해 무한 루프가 발생할 수 있습니다. 경고 없이 오래된 응답을 받은 사용자 에이전트는 사용자에게 경고 표시를 표시할 수 있습니다.\(SHOULD, SHOULD NOT, MAY\)

---
### **13.1.2 Warnings**

캐시가 직접적이지도 않고 "충분히 신선하지도 않은" 응답을 반환할 때마다\(섹션 13.1.1의 조건 2 의미에서\) 경고 일반 헤더를 사용하여 해당 효과에 대한 경고를 첨부해야 합니다. 경고 헤더와 현재 정의된 경고는 섹션 14.46에 설명되어 있습니다. 경고를 통해 클라이언트는 적절한 조치를 취할 수 있습니다.\(MUST\)

경고는 캐시 관련 및 기타 목적으로 사용될 수 있습니다. 오류 상태 코드 대신 경고를 사용하면 이러한 응답을 실제 실패와 구별할 수 있습니다.\(MAY\)

경고에는 세 자리 경고 코드가 할당됩니다. 첫 번째 숫자는 재검증에 성공한 후 저장된 캐시 항목에서 경고를 삭제해야 하는지, 삭제하면 안 되는지 여부를 나타냅니다.\(MUST NOT\)

1xx 응답의 최신성 또는 재검증 상태를 설명하는 경고이므로 성공적인 재검증 후에는 삭제해야 합니다. 1XX 경고 코드는 캐시된 항목을 검증할 때만 캐시에 의해 생성될 수 있습니다. 클라이언트가 생성해서는 안 됩니다.\(MUST, MAY, MUST NOT\)

2xx 재검증으로 수정되지 않고\(예: 엔터티 본문의 손실 압축\) 성공적인 재검증 후에 삭제하면 안 되는 엔터티 본문 또는 엔터티 헤더의 일부 측면을 설명하는 경고입니다.\(MUST NOT\)

코드 자체의 정의는 섹션 14.46을 참조하십시오.

HTTP/1.0 캐시는 첫 번째 범주의 경고를 삭제하지 않고 응답의 모든 경고를 캐시합니다. HTTP/1.0 캐시로 전달되는 응답의 경고에는 추가 경고 날짜 필드가 포함되어 있어 향후 HTTP/1.1 수신자가 잘못 캐시된 경고를 믿지 않게 됩니다.

경고에는 경고 텍스트도 포함됩니다. 텍스트는 적절한 자연 언어\(아마도 클라이언트의 Accept 헤더를 기반으로 함\)일 수 있으며 어떤 문자 집합이 사용되는지에 대한 선택 사항 표시를 포함할 수 있습니다.\(MAY\)

동일한 코드 번호를 가진 여러 경고를 포함하여 여러 경고가 응답\(원본 서버 또는 캐시에 의해\)에 첨부될 수 있습니다. 예를 들어, 서버는 영어와 바스크어 텍스트로 동일한 경고를 제공할 수 있습니다.\(MAY\)

응답에 여러 개의 경고가 첨부된 경우 모든 경고를 사용자에게 표시하는 것은 실용적이지 않거나 합리적이지 않을 수 있습니다. 이 버전의 HTTP는 표시할 경고와 순서를 결정하기 위한 엄격한 우선순위 규칙을 지정하지 않지만 몇 가지 경험적 방법을 제안합니다.

---
### **13.1.3 Cache-control Mechanisms**

HTTP/1.1의 기본 캐시 메커니즘\(서버 지정 만료 시간 및 유효성 검사기\)은 캐시에 대한 암시적 지시어입니다. 어떤 경우에는 서버나 클라이언트가 HTTP 캐시에 명시적인 지시어를 제공해야 할 수도 있습니다. 이를 위해 Cache-Control 헤더를 사용합니다.

Cache-Control 헤더를 사용하면 클라이언트나 서버가 요청이나 응답으로 다양한 지시문을 전송할 수 있습니다. 이러한 지시문은 일반적으로 기본 캐싱 알고리즘을 재정의합니다. 일반적으로 헤더 값 사이에 명백한 충돌이 있는 경우 가장 제한적인 해석이 적용됩니다\(즉, 의미 투명성을 보존할 가능성이 가장 높은 해석\). 하지만,

경우에 따라 캐시 제어 지시문은 의미 투명성의 근사치를 약화시키는 것으로 명시적으로 지정됩니다\(예: "max-stale" 또는 "public"\).

캐시 제어 지시문은 섹션 14.9에 자세히 설명되어 있습니다.

---
### **13.1.4 Explicit User Agent Warnings**

많은 사용자 에이전트를 사용하면 사용자가 기본 캐싱 메커니즘을 재정의할 수 있습니다. 예를 들어, 사용자 에이전트는 사용자가 캐시된 엔터티\(명시적으로 오래된 엔터티라도\)의 유효성을 검사하지 않도록 지정할 수 있도록 허용할 수 있습니다. 또는 사용자 에이전트가 습관적으로 모든 요청에 ​​"Cache-Control: max-stale=3600"을 추가할 수도 있습니다. 사용자 에이전트는 불투명한 동작이나 비정상적으로 비효율적인 캐싱을 초래하는 동작을 기본값으로 설정해서는 안 되지만, 사용자의 명시적인 작업을 통해 그렇게 하도록 명시적으로 구성할 수 있습니다.\(SHOULD NOT\)

사용자가 기본 캐싱 메커니즘을 재정의한 경우 사용자 에이전트는 이로 인해 서버의 투명성 요구 사항을 충족하지 못할 수 있는 정보가 표시될 때마다\(특히 표시된 엔터티가 오래된 것으로 알려진 경우\) 사용자에게 명시적으로 알려야 합니다. 프로토콜은 일반적으로 사용자 에이전트가 응답이 오래된지 여부를 결정할 수 있도록 허용하므로 이 표시는 실제로 이런 일이 발생할 때만 표시하면 됩니다. 표시는 대화 상자일 필요는 없습니다. 이는 아이콘\(예: 썩어가는 물고기 그림\)일 수도 있고 다른 표시일 수도 있습니다.\(SHOULD\)

사용자가 캐시의 효율성을 비정상적으로 감소시키는 방식으로 캐싱 메커니즘을 재정의한 경우, 사용자 에이전트는 사용자에게 이 상태를 지속적으로 표시해야 합니다\(예: 불꽃 속의 화폐 그림 표시\). 실수로 과도한 리소스를 소비하거나 과도한 대기 시간이 발생하지 않습니다.\(SHOULD\)

---
### **13.1.5 Exceptions to the Rules and Warnings**

어떤 경우에는 캐시 운영자가 클라이언트가 요청하지 않은 경우에도 오래된 응답을 반환하도록 캐시를 구성하도록 선택할 수 있습니다. 이 결정은 가볍게 내려서는 안 되지만 가용성이나 성능상의 이유로 필요할 수 있으며, 특히 캐시가 원본 서버에 제대로 연결되지 않은 경우 더욱 그렇습니다. 캐시가 오래된 응답을 반환할 때마다 클라이언트 소프트웨어가 잠재적인 문제가 있을 수 있음을 사용자에게 경고할 수 있도록 경고 헤더를 사용하여 이를 표시해야 합니다.\(MAY, MUST\)

또한 사용자 에이전트가 직접 또는 새로운 응답을 얻기 위한 조치를 취할 수 있습니다. 이러한 이유로 캐시는 기술적 또는 정책적 이유로 준수가 불가능한 경우를 제외하고 클라이언트가 직접 또는 새로운 응답을 명시적으로 요청하는 경우 오래된 응답을 반환해서는 안 됩니다.\(SHOULD NOT\)

---
### **13.1.6 Client-controlled Behavior**

원본 서버\(응답 기간에 대한 기여도에 따라 중간 캐시 포함\)가 만료 정보의 주요 소스인 반면, 경우에 따라 클라이언트는 캐시된 캐시를 반환할지 여부에 대한 캐시의 결정을 제어해야 할 수도 있습니다. 확인하지 않고 응답합니다. 클라이언트는 Cache-Control 헤더의 여러 지시문을 사용하여 이를 수행합니다.

클라이언트의 요청은 검증되지 않은 응답을 수락할 수 있는 최대 연령을 지정할 수 있습니다. 0 값을 지정하면 캐시가 모든 응답을 다시 검증하게 됩니다. 클라이언트는 응답이 만료되기까지 남은 최소 시간을 지정할 수도 있습니다. 이 두 옵션 모두 캐시 동작에 대한 제약을 증가시키므로 캐시의 의미 투명성 근사치를 더 이상 완화할 수 없습니다.\(MAY, MAY\)

클라이언트는 또한 최대 부실 상태까지 오래된 응답을 허용하도록 지정할 수도 있습니다. 이는 캐시에 대한 제약 조건을 완화하여 의미 투명성에 대한 원본 서버의 지정된 제약 조건을 위반할 수 있지만 연결이 끊어진 작업 또는 연결 상태가 좋지 않은 경우 고가용성을 지원하는 데 필요할 수 있습니다.\(MAY\)

---
## **13.2 Expiration Model**
---
### **13.2.1 Server-Specified Expiration**

HTTP 캐싱은 캐시가 원본 서버에 대한 요청을 완전히 피할 수 있을 때 가장 잘 작동합니다. 요청을 피하기 위한 기본 메커니즘은 원서버가 향후 명시적인 만료 시간을 제공하여 후속 요청을 충족하는 데 응답이 사용될 수 있음을 나타내는 것입니다. 즉, 캐시는 먼저 서버에 접속하지 않고도 새로운 응답을 반환할 수 있습니다.\(MAY\)

우리는 서버가 만료 시간에 도달하기 전에 의미상 중요한 방식으로 엔터티가 변경될 가능성이 없다는 믿음으로 응답에 미래의 명시적인 만료 시간을 할당할 것으로 기대합니다. 이는 일반적으로 서버의 만료 시간을 신중하게 선택하는 한 의미적 투명성을 유지합니다.

만료 메커니즘은 캐시에서 가져온 응답에만 적용되며 요청 클라이언트에 즉시 전달되는 직접 응답에는 적용되지 않습니다.

원서버가 모든 요청을 검증하기 위해 의미상 투명한 캐시를 강제하려는 경우 과거의 명시적인 만료 시간을 할당할 수 있습니다. 이는 응답이 항상 오래되었음을 의미하므로 캐시는 후속 요청에 사용하기 전에 응답을 검증해야 합니다. 재검증을 강제하는 보다 제한적인 방법은 섹션 14.9.4를 참조하세요.\(MAY, SHOULD\)

원서버가 모든 요청을 검증하기 위해 HTTP/1.1 캐시를 강제로 구성하려는 경우 "must- revalidate" 캐시 제어 지시문을 사용해야 합니다\(섹션 14.9 참조\).\(SHOULD\)

서버는 Expires 헤더 또는 Cache-Control 헤더의 max-age 지시문을 사용하여 명시적인 만료 시간을 지정합니다.

만료 시간을 사용하여 사용자 에이전트가 디스플레이를 새로 고치거나 리소스를 다시 로드하도록 강제할 수는 없습니다. 그 의미는 캐싱 메커니즘에만 적용되며 이러한 메커니즘은 해당 리소스에 대한 새 요청이 시작될 때 리소스의 만료 상태만 확인하면 됩니다. 캐시와 히스토리 메커니즘의 차이점에 대한 설명은 섹션 13.13을 참조하세요.

---
### **13.2.2 Heuristic Expiration**

원본 서버가 항상 명시적인 만료 시간을 제공하는 것은 아니기 때문에 HTTP 캐시는 일반적으로 타당한 만료 시간을 추정하기 위해 다른 헤더 값\(예: Last-Modified 시간\)을 사용하는 알고리즘을 사용하여 경험적 만료 시간을 할당합니다. HTTP/1.1 사양은 특정 알고리즘을 제공하지 않지만 결과에 최악의 제약을 부과합니다. 경험적 만료 시간은 의미적 투명성을 손상시킬 수 있으므로 주의해서 사용해야 하며 원본 서버가 가능한 한 명시적인 만료 시간을 제공하도록 권장합니다.

---
### **13.2.3 Age Calculations**

캐시된 항목이 최신인지 확인하려면 캐시는 해당 항목의 기간이 신선도 수명을 초과하는지 알아야 합니다. 우리는 섹션 13.2.4에서 후자를 계산하는 방법을 논의합니다. 이 섹션에서는 응답 또는 캐시 항목의 수명을 계산하는 방법을 설명합니다.

이 논의에서 "지금"이라는 용어는 "계산을 수행하는 호스트의 현재 클록 값"을 의미하기 위해 사용됩니다. HTTP를 사용하는 호스트, 특히 원본 서버와 캐시를 실행하는 호스트는 NTP \[28\] 또는 일부 유사한 프로토콜을 사용하여 시계를 전 세계적으로 정확한 시간 표준에 동기화해야 합니다.\(SHOULD\)

HTTP/1.1에서는 원본 서버가 가능하다면 모든 응답과 함께 응답이 생성된 시간을 제공하는 Date 헤더를 보내도록 요구합니다\(섹션 14.18 참조\). 산술 연산에 적합한 형식으로 Date 헤더의 값을 나타내기 위해 "date\_value"라는 용어를 사용합니다.

HTTP/1.1은 Age 응답 헤더를 사용하여 캐시에서 얻은 응답 메시지의 예상 수명을 전달합니다. Age 필드 값은 원본 서버에서 응답이 생성되거나 재검증된 이후 캐시에서 추정한 시간입니다.

본질적으로 Age 값은 응답이 원본 서버의 경로를 따라 각 캐시에 상주한 시간과 네트워크 경로를 따라 전송된 시간의 합계입니다.

우리는 산술 연산에 적합한 형식으로 Age 헤더의 값을 나타내기 위해 "age\_value"라는 용어를 사용합니다.

응답의 수명은 완전히 독립적인 두 가지 방법으로 계산할 수 있습니다.

- 1. 로컬 시계가 원본 서버의 시계와 합리적으로 잘 동기화된 경우 이제 date\_value를 뺍니다. 결과가 음수이면 결과는 0으로 대체됩니다.

- 2. age\_value, 응답 경로에 있는 모든 캐시가 HTTP/1.1을 구현하는 경우.

응답이 수신될 때 응답의 연령을 계산하는 두 가지 독립적인 방법이 있다는 점을 고려하면 이를 다음과 같이 결합할 수 있습니다.

```text
       corrected_received_age = max(now - date_value, age_value)
```

거의 동기화된 시계나 모든 HTTP/1.1 경로가 있는 한 신뢰할 수 있는\(보수적인\) 결과를 얻습니다.

네트워크로 인한 지연으로 인해 서버가 응답을 생성하는 시간과 다음 아웃바운드 캐시 또는 클라이언트에서 응답을 수신하는 시간 사이에 상당한 간격이 경과할 수 있습니다. 수정하지 않으면 이러한 지연으로 인해 연령이 부적절하게 낮아질 수 있습니다.

Age 값을 반환한 요청은 해당 Age 값이 생성되기 전에 시작되어야 하므로 요청이 시작된 시간을 기록하여 네트워크로 인한 지연을 수정할 수 있습니다. 그런 다음 Age 값이 수신되면 요청이 시작된 시간을 기준으로 해석해야 합니다.\(MUST\)

응답을 받은 시간. 이 알고리즘은 얼마나 많은 지연이 발생하더라도 보수적인 동작을 발생시킵니다. 그래서 우리는 다음을 계산합니다:

```text
      corrected_initial_age = corrected_received_age
                            + (now - request_time)
```

여기서 "request\_time"은 이 응답을 유도한 요청이 전송된 시간\(현지 시계 기준\)입니다.

캐시가 응답을 수신할 때 수명 계산 알고리즘 요약:

```text
      /*
       * age_value
       *      is the value of Age: header received by the cache with
       *              this response.
       * date_value
       *      is the value of the origin server's Date: header
       * request_time
       *      is the (local) time when the cache made the request
       *              that resulted in this cached response
       * response_time
       *      is the (local) time when the cache received the
       *              response
       * now
       *      is the current (local) time
       */

      apparent_age = max(0, response_time - date_value);
      corrected_received_age = max(apparent_age, age_value);
      response_delay = response_time - request_time;
      corrected_initial_age = corrected_received_age + response_delay;
      resident_time = now - response_time;
      current_age   = corrected_initial_age + resident_time;
```

캐시 항목의 current\_age는 캐시 항목이 원본 서버에 의해 마지막으로 검증된 이후의 시간\(초\)을 Corrected\_initial\_age에 추가하여 계산됩니다. 캐시 항목에서 응답이 생성되면 캐시는 캐시 항목의 current\_age와 동일한 값을 가진 응답에 단일 Age 헤더 필드를 포함해야 합니다.\(MUST\)

응답에 Age 헤더 필드가 있다는 것은 응답이 직접 응답이 아니라는 것을 의미합니다. 그러나 응답에 Age 헤더 필드가 없다고 해서 응답이 다음과 같다는 의미는 아니기 때문에 그 반대는 사실이 아닙니다.

요청 경로의 모든 캐시가 HTTP/1.1을 준수하지 않는 한\(즉, 이전 HTTP 캐시가 Age 헤더 필드를 구현하지 않은 경우\) 응답은 직접 이루어집니다.

---
### **13.2.4 Expiration Calculations**

응답이 신선한지 오래된지 결정하려면 해당 응답의 신선도 수명을 해당 기간과 비교해야 합니다. 연령은 섹션 13.2.3에 설명된 대로 계산됩니다. 이 섹션에서는 신선도 수명을 계산하고 응답이 만료되었는지 확인하는 방법을 설명합니다. 아래 설명에서 값은 산술 연산에 적합한 모든 형식으로 표시될 수 있습니다.

Expires 헤더의 값을 나타내기 위해 "expires\_value"라는 용어를 사용합니다. 우리는 응답에서 Cache-Control 헤더의 "max-age" 지시문에 의해 전달되는 초 수의 적절한 값을 나타내기 위해 "max\_age\_value"라는 용어를 사용합니다\(섹션 14.9.3 참조\).

max-age 지시문은 Expires보다 우선순위가 높으므로 응답에 max-age가 있는 경우 계산은 간단합니다.

```text
      freshness_lifetime = max_age_value
```

그렇지 않고 응답에 Expires가 있으면 계산은 다음과 같습니다.

```text
      freshness_lifetime = expires_value - date_value
```

모든 정보가 원본 서버에서 제공되므로 이러한 계산 중 어느 것도 시계 왜곡에 취약하지 않습니다.

Expires, Cache-Control: max-age 또는 Cache-Control: s-maxage\(섹션 14.9.3 참조\)가 응답에 나타나지 않고 응답에 캐싱에 대한 다른 제한 사항이 포함되지 않은 경우 캐시는 신선도를 계산할 수 있습니다. 휴리스틱을 사용하여 평생. 해당 경고가 아직 추가되지 않은 경우 캐시는 기간이 24시간을 초과하는 모든 응답에 경고 113을 첨부해야 합니다.\(MAY, MUST\)

```text
   Also, if the response does have a Last-Modified time, the heuristic
   expiration value SHOULD be no more than some fraction of the interval
   since that time. A typical setting of this fraction might be 10%.
```

응답이 만료되었는지 확인하는 계산은 매우 간단합니다.

```text
      response_is_fresh = (freshness_lifetime > current_age)
```

---
### **13.2.5 Disambiguating Expiration Values**

만료 값은 낙관적으로 할당되므로 두 캐시에 동일한 리소스에 대해 서로 다른 새로운 값이 포함될 수 있습니다.

검색을 수행하는 클라이언트가 자체 캐시에 이미 신선한 요청에 대해 직접 응답이 아닌 응답을 수신하고 기존 캐시 항목의 Date 헤더가 새 응답의 Date보다 최신인 경우 클라이언트는 무시할 수 있습니다. 응답. 그렇다면 "Cache-Control: max-age=0" 지시문\(섹션 14.9 참조\)을 사용하여 요청을 재시도하여 원본 서버에 강제로 검사할 수 있습니다.\(MAY, MAY\)

캐시에 서로 다른 유효성 검사기를 사용하여 동일한 표현에 대한 두 개의 새로운 응답이 있는 경우 최신 Date 헤더가 있는 응답을 사용해야 합니다. 이러한 상황은 캐시가 다른 캐시의 응답을 풀링하거나 클라이언트가 명백히 새로운 캐시 항목의 다시 로드 또는 재검증을 요청했기 때문에 발생할 수 있습니다.\(MUST\)

---
### **13.2.6 Disambiguating Multiple Responses**

클라이언트는 여러 경로를 통해 응답을 받을 수 있으므로 일부 응답은 한 캐시 세트를 통해 흐르고 다른 응답은 다른 캐시 세트를 통해 흐르므로 클라이언트는 원본 서버가 보낸 순서와 다른 순서로 응답을 받을 수 있습니다. . 우리는 클라이언트가 가장 최근에 생성된 응답을 사용하기를 원합니다. 비록 오래된 응답이 여전히 신선한 것 같더라도 말입니다.

이후 응답이 의도적으로 더 빠른 만료 시간을 전달하는 것이 가능하기 때문에 엔터티 태그나 만료 값 모두 응답에 순서를 지정할 수 없습니다. 날짜 값은 1초 단위로 정렬됩니다.

클라이언트가 캐시 항목을 재검증하려고 시도하고 수신된 응답에 기존 항목의 것보다 오래된 것으로 보이는 Date 헤더가 포함되어 있는 경우 클라이언트는 무조건 요청을 반복하고 다음을 포함해야 합니다.\(SHOULD\)

```text
       Cache-Control: max-age=0
```

중간 캐시가 원본 서버를 통해 직접 복사본을 검증하도록 강제하거나

```text
       Cache-Control: no-cache
```

중간 캐시가 원본 서버에서 새 복사본을 얻도록 강제합니다.

Date 값이 동일하면 클라이언트는 두 가지 응답 중 하나를 사용할 수 있습니다\(또는 매우 신중한 경우 새 응답을 요청할 수 있습니다\). 서버는 클라이언트가 만료 시간이 겹치는 경우 동일한 시간 동안 생성된 응답 간에 결정론적으로 선택할 수 있는 클라이언트에 의존해서는 안 됩니다.\(MAY, MUST NOT\)

---
## **13.3 Validation Model**

캐시에 클라이언트 요청에 대한 응답으로 사용하려는 오래된 항목이 있는 경우 먼저 원본 서버\(또는 새로운 응답이 있는 중간 캐시\)를 확인하여 캐시된 항목을 여전히 사용할 수 있는지 확인해야 합니다. . 이를 캐시 항목의 "검증"이라고 합니다. 캐시된 항목이 양호하면 전체 응답을 재전송하는 오버헤드를 지불하고 싶지 않고, 캐시된 항목이 유효하지 않은 경우 추가 왕복의 오버헤드를 지불하고 싶지 않기 때문에 HTTP/1.1 프로토콜은 다음을 지원합니다. 조건부 방법의 사용.

조건부 방법을 지원하는 주요 프로토콜 기능은 "캐시 유효성 검사기"와 관련된 기능입니다. 원본 서버가 전체 응답을 생성하면 캐시 항목과 함께 보관되는 일종의 유효성 검사기를 연결합니다. 클라이언트\(사용자 에이전트 또는 프록시 캐시\)가 캐시 항목이 있는 리소스에 대해 조건부 요청을 하면 요청에 연결된 유효성 검사기가 포함됩니다.

그런 다음 서버는 해당 유효성 검사기를 엔터티의 현재 유효성 검사기와 비교하여 확인하고 일치하는 경우\(섹션 13.3.3 참조\) 엔터티 본문이 아닌 특수 상태 코드\(일반적으로 304\(수정되지 않음\)\)로 응답합니다. 그렇지 않으면 전체 응답\(엔티티 본문 포함\)을 반환합니다. 따라서 유효성 검사기가 일치하면 전체 응답 전송을 방지하고 일치하지 않으면 추가 왕복을 방지합니다.

HTTP/1.1에서 조건부 요청은 암시적으로 메서드\(보통 GET\)를 조건부로 바꾸는 특수 헤더\(유효성 검사기 포함\)를 전달한다는 점을 제외하면 동일한 리소스에 대한 일반 요청과 완전히 동일해 보입니다.

프로토콜에는 캐시 검증 조건에 대한 긍정적인 의미와 부정적인 의미가 모두 포함됩니다. 즉, 유효성 검사기가 일치하는 경우에만 메서드를 수행하도록 요청하거나 유효성 검사기가 일치하지 않는 경우에만 메서드를 수행하도록 요청할 수 있습니다.

- 참고: 유효성 검사기가 없는 응답은 캐시 제어 지시문에 의해 명시적으로 금지되지 않는 한 캐시되고 만료될 때까지 캐시에서 제공될 수 있습니다. 그러나 캐시에 엔터티에 대한 유효성 검사기가 없으면 조건부 검색을 수행할 수 없습니다. 즉, 만료된 후에는 새로 고칠 수 없습니다.

---
### **13.3.1 Last-Modified Dates**

Last-Modified 엔터티 헤더 필드 값은 종종 캐시 유효성 검사기로 사용됩니다. 간단히 말해서, Last-Modified 값 이후 엔터티가 수정되지 않은 경우 캐시 항목은 유효한 것으로 간주됩니다.

---
### **13.3.2 Entity Tag Cache Validators**

엔터티 태그인 ETag 응답 헤더 필드 값은 "불투명" 캐시 유효성 검사기를 제공합니다. 이는 수정 날짜를 저장하는 것이 불편하거나 HTTP 날짜 값의 1초 해상도가 충분하지 않거나 원본 서버가 수정 날짜 사용으로 인해 발생할 수 있는 특정 역설을 피하려는 상황에서 보다 안정적인 유효성 검사를 허용할 수 있습니다. .

엔터티 태그는 섹션 3.11에 설명되어 있습니다. 엔터티 태그와 함께 사용되는 헤더는 섹션 14.19, 14.24, 14.26 및 14.44에 설명되어 있습니다.

---
### **13.3.3 Weak and Strong Validators**

```text
   Since both origin servers and caches will compare two validators to
   decide if they represent the same or different entities, one normally
   would expect that if the entity (the entity-body or any entity-
   headers) changes in any way, then the associated validator would
   change as well. If this is true, then we call this validator a
   "strong validator."

   However, there might be cases when a server prefers to change the
   validator only on semantically significant changes, and not when
   insignificant aspects of the entity change. A validator that does not
   always change when the resource changes is a "weak validator."
```

엔터티 태그는 일반적으로 "강력한 유효성 검사기"이지만 프로토콜은 엔터티 태그를 "약함"으로 태그 지정하는 메커니즘을 제공합니다. 강력한 유효성 검사기는 엔터티의 비트가 변경될 때마다 변경되는 반면 약한 값은 엔터티의 의미가 변경될 때마다 변경되는 것으로 생각할 수 있습니다. 또는 강력한 유효성 검사기를 특정 엔터티에 대한 식별자의 일부로 생각할 수 있는 반면 약한 유효성 검사기는 의미상 동일한 엔터티 집합에 대한 식별자의 일부로 생각할 수 있습니다.

- 참고: 강력한 유효성 검사기의 한 가지 예는 엔터티가 변경될 때마다 안정적인 저장소에서 증가하는 정수입니다.

- 엔터티의 수정 시간을 1초 단위로 표현하면 리소스가 1초 동안 두 번 수정될 수 있으므로 약한 유효성 검사기가 될 수 있습니다.

- 약한 유효성 검사기에 대한 지원은 선택 사항입니다. 그러나 약한 유효성 검사기를 사용하면 동등한 객체를 보다 효율적으로 캐싱할 수 있습니다. 예를 들어, 사이트의 조회수 카운터는 며칠 또는 몇 주마다 업데이트된다면 충분할 것이며 해당 기간 동안의 모든 값은 동등할 정도로 "충분히 양호"할 가능성이 높습니다.

유효성 검사기의 "사용"은 클라이언트가 요청을 생성하고 유효성 검사 헤더 필드에 유효성 검사기를 포함할 때 또는 서버가 두 유효성 검사기를 비교할 때입니다.

강력한 유효성 검사기는 어떤 상황에서도 사용할 수 있습니다. 약한 유효성 검사기는 엔터티의 정확한 동일성에 의존하지 않는 컨텍스트에서만 사용할 수 있습니다. 예를 들어 두 종류 모두 전체 엔터티의 조건부 GET에 사용할 수 있습니다. 그러나 하위 범위 검색에는 강력한 유효성 검사기만 사용할 수 있습니다. 그렇지 않으면 클라이언트가 내부적으로 일관성이 없는 엔터티로 끝날 수 있기 때문입니다.

클라이언트는 약한 유효성 검사기나 강력한 유효성 검사기를 사용하여 간단한\(하위 범위가 아닌\) GET 요청을 발행할 수 있습니다. 클라이언트는 다른 형태의 요청에 약한 유효성 검사기를 사용해서는 안 됩니다.\(MAY, MUST NOT\)

HTTP/1.1 프로토콜이 유효성 검사기에 정의하는 유일한 기능은 비교입니다. 비교 컨텍스트가 약한 유효성 검사기 사용을 허용하는지 여부에 따라 두 가지 유효성 검사기 비교 함수가 있습니다.

- - 강력한 비교 기능: 동일하다고 간주되기 위해서는 두 검증자가 모든 면에서 동일해야 하며 둘 다 약해서는 안 됩니다.\(MUST NOT\)

- - 약한 비교 기능: 동일하다고 간주되기 위해서는 두 검증자가 모든 면에서 동일해야 하지만 둘 중 하나 또는 둘 다 결과에 영향을 주지 않고 "약함"으로 태그될 수 있습니다.\(MUST\)

엔터티 태그는 명시적으로 약한 태그가 지정되지 않는 한 강력합니다. 섹션 3.11에는 엔터티 태그의 구문이 나와 있습니다.

요청에서 유효성 검사기로 사용되는 Last-Modified 시간은 다음 규칙을 사용하여 강력하다고 추론할 수 없는 한 암시적으로 약합니다.

- - 유효성 검사기는 원본 서버에 의해 엔터티의 실제 현재 유효성 검사기와 비교됩니다.

- - 해당 원서버는 연관된 엔터티가 제시된 검증자가 다루는 두 번째 동안 두 번 변경되지 않았다는 것을 확실하게 알고 있습니다.

```text
   or
```

- 유효성 검사기가 If-에서 클라이언트에 의해 사용되려고 합니다.

- 클라이언트가 관련 엔터티에 대한 캐시 항목을 갖고 있기 때문에 Modified-Since 또는 If-Unmodified-Since 헤더

- - 해당 캐시 항목에는 원본 서버가 원래 응답을 보낸 시간을 제공하는 날짜 값이 포함됩니다.

- - 제시된 Last-Modified 시간은 날짜 값보다 최소 60초 전입니다.

```text
   or
```

- - 유효성 검사기는 중간 캐시에 의해 엔터티의 캐시 항목에 저장된 유효성 검사기와 비교됩니다.

- - 해당 캐시 항목에는 원본 서버가 원래 응답을 보낸 시간을 제공하는 날짜 값이 포함됩니다.

- - 제시된 Last-Modified 시간은 날짜 값보다 최소 60초 전입니다.

이 방법은 동일한 초 동안 원본 서버에서 두 개의 서로 다른 응답을 보냈지만 둘 다 동일한 Last-Modified 시간을 가졌다면 해당 응답 중 적어도 하나는 Last-Modified와 동일한 Date 값을 갖는다는 사실에 의존합니다. 시간. 임의의 60초 제한은 응답 준비 중 Date 및 Last-Modified 값이 다른 시계에서 생성되거나 다소 다른 시간에 생성될 가능성을 방지합니다. 60초가 너무 짧다고 판단되는 경우 구현에서는 60초보다 큰 값을 사용할 수 있습니다.\(MAY\)

클라이언트가 Last-Modified 시간만 있고 불투명한 유효성 검사기가 없는 값에 대해 하위 범위 검색을 수행하려는 경우 여기에 설명된 의미에서 Last-Modified 시간이 강한 경우에만 이 작업을 수행할 수 있습니다.\(MAY\)

전체 본문 GET 요청이 아닌 조건부 요청을 수신하는 캐시 또는 원본 서버는 조건을 평가하기 위해 강력한 비교 기능을 사용해야 합니다.\(MUST\)

이러한 규칙을 통해 HTTP/1.1 캐시와 클라이언트는 HTTP/1.0에서 얻은 값에 대해 하위 범위 검색을 안전하게 수행할 수 있습니다.

```text
   servers.
```

---
### **13.3.4 Rules for When to Use Entity Tags and Last-Modified Dates**

우리는 다양한 유효성 검사기 유형을 사용해야 하는 시기와 목적에 관해 원본 서버, 클라이언트 및 캐시에 대한 일련의 규칙과 권장 사항을 채택합니다.

```text
   HTTP/1.1 origin servers:
```

- - 엔터티 태그 유효성 검사기를 생성하는 것이 가능하지 않은 한 엔터티 태그 유효성 검사기를 보내야 합니다.\(SHOULD\)

- - 성능 고려 사항이 약한 엔터티 태그 사용을 지원하거나 강력한 엔터티 태그를 보내는 것이 실행 불가능한 경우 강력한 엔터티 태그 대신 약한 엔터티 태그를 보낼 수 있습니다.\(MAY\)

- - If-Modified-Since 헤더에서 이 날짜를 사용함으로써 발생할 수 있는 의미 투명성의 붕괴 위험이 심각한 문제를 야기하지 않는 한, 전송이 가능한 경우 Last-Modified 값을 전송해야 합니다.\(SHOULD\)

즉, HTTP/1.1 원본 서버에 선호되는 동작은 강력한 엔터티 태그와 Last-Modified 값을 모두 보내는 것입니다.

합법적이려면 관련 엔터티 값이 어떤 방식으로든 변경될 때마다 강력한 엔터티 태그가 변경되어야 합니다. 약한 엔터티 태그는 연관된 엔터티가 의미상 중요한 방식으로 변경될 때마다 변경되어야 합니다.\(MUST, SHOULD\)

- 참고: 의미상 투명한 캐싱을 제공하기 위해 원서버는 두 개의 서로 다른 엔터티에 대해 특정 강력한 엔터티 태그 값을 재사용하거나 의미상으로 다른 두 엔터티에 대해 특정 약한 엔터티 태그 값을 재사용하는 것을 피해야 합니다. 캐시 항목은 만료 시간에 관계없이 임의로 오랜 기간 동안 지속될 수 있으므로 캐시가 과거 어느 시점에 얻은 유효성 검사기를 사용하여 항목의 유효성을 다시 검사하지 않을 것이라고 기대하는 것은 부적절할 수 있습니다.

```text
   HTTP/1.1 clients:
```

- - 원서버가 엔터티 태그를 제공한 경우 캐시 조건부 요청\(If-Match 또는 If-None-Match 사용\)에서 해당 엔터티 태그를 사용해야 합니다.\(MUST\)

- - 원서버가 Last-Modified 값만 제공한 경우 비하위 범위 캐시 조건부 요청에서 해당 값을 사용해야 합니다\(If-Modified-Since 사용\).\(SHOULD\)

- - HTTP/1.0 원본 서버에서 Last-Modified 값만 제공한 경우 하위 범위 캐시 조건부 요청에서 해당 값을 사용할 수 있습니다\(If-Unmodified-Since: 사용\). 사용자 에이전트는 어려움이 있는 경우 이를 비활성화하는 방법을 제공해야 합니다\(SHOULD\).\(MAY, SHOULD\)

- - 원본 서버에서 엔터티 태그와 Last-Modified 값을 모두 제공한 경우 캐시 조건부 요청에서 두 유효성 검사기를 모두 사용해야 합니다. 이를 통해 HTTP/1.0 및 HTTP/1.1 캐시가 모두 적절하게 응답할 수 있습니다.\(SHOULD\)

HTTP/1.1 원본 서버는 Last-Modified 날짜\(예: If-Modified-Since 또는 If-Unmodified-Since 헤더 필드\)와 하나 이상의 엔터티 태그\(예: If-Match, If-None-Match 또는 If-Range 헤더 필드\)를 캐시 유효성 검사기로 사용하는 경우 요청의 모든 조건부 헤더 필드와 일치하지 않는 한 응답 상태 304\(수정되지 않음\)를 반환해서는 안 됩니다.\(MUST NOT\)

HTTP/1.1 캐싱 프록시는 캐시 유효성 검사기로서 마지막 수정 날짜와 하나 이상의 엔터티 태그를 모두 포함하는 조건부 요청을 수신할 때 캐시된 응답이 모든 항목과 일치하지 않는 한 로컬로 캐시된 응답을 클라이언트에 반환해서는 안 됩니다. 요청의 조건부 헤더 필드.\(MUST NOT\)

- 참고: 이러한 규칙의 기본 원칙은 HTTP/1.1 서버와 클라이언트가 응답 및 요청에서 사용할 수 있는 중복되지 않는 정보를 최대한 많이 전송해야 한다는 것입니다. 이 정보를 수신하는 HTTP/1.1 시스템은 수신하는 유효성 검사기에 대해 가장 보수적인 가정을 합니다.

- HTTP/1.0 클라이언트와 캐시는 엔터티 태그를 무시합니다. 일반적으로 이러한 시스템에서 수신하거나 사용하는 최종 수정 값은 투명하고 효율적인 캐싱을 지원하므로 HTTP/1.1 원본 서버는 Last-Modified 값을 제공해야 합니다. HTTP/1.0 시스템에서 유효성 검사기로 Last-Modified 값을 사용하면 심각한 문제가 발생할 수 있는 드문 경우에 HTTP/1.1 원본 서버는 이를 제공해서는 안 됩니다.

---
### **13.3.5 Non-validating Conditionals**

엔터티 태그 뒤에 있는 원칙은 서비스 작성자만이 적절한 캐시 유효성 검사 메커니즘을 선택할 수 있을 만큼 리소스의 의미를 잘 알고 있으며, 바이트 동일성보다 더 복잡한 유효성 검사기 비교 기능의 사양은 웜 캔을 열 수 있다는 것입니다. 따라서 다른 헤더\(HTTP/1.0과의 호환성을 위해 Last-Modified 제외\)의 비교는 캐시 항목의 유효성을 검사할 목적으로 사용되지 않습니다.

---
## **13.4 Response Cacheability**

캐시 제어\(섹션 14.9\) 지시문에 의해 특별히 제한되지 않는 한, 캐싱 시스템은 항상 성공적인 응답\(섹션 13.8 참조\)을 캐시 항목으로 저장할 수 있고, 새로운 경우 유효성 검사 없이 반환할 수 있으며, 성공적인 유효성 검사 후에 반환할 수 있습니다. . 응답과 관련된 캐시 유효성 검사기나 명시적인 만료 시간이 없는 경우 해당 응답이 캐시될 것으로 예상하지 않지만 특정 캐시는 이러한 예상을 위반할 수 있습니다\(예: 사용 가능한 네트워크 연결이 거의 또는 전혀 없는 경우\). 클라이언트는 일반적으로 Date 헤더를 현재 시간과 비교하여 캐시에서 이러한 응답을 가져왔는지 감지할 수 있습니다.\(MAY, MAY\)

- 참고: 일부 HTTP/1.0 캐시는 경고를 제공하지 않고 이러한 기대치를 위반하는 것으로 알려져 있습니다.

그러나 어떤 경우에는 캐시가 엔터티를 유지하거나 후속 요청에 대한 응답으로 엔터티를 반환하는 것이 부적절할 수 있습니다. 이는 서비스 작성자가 절대적인 의미 투명성이 필요하다고 간주하거나 보안 또는 개인 정보 보호를 고려하기 때문일 수 있습니다. 따라서 특정 리소스 개체 또는 그 일부가 다른 고려 사항에 관계없이 캐시되지 않음을 서버가 나타낼 수 있도록 특정 캐시 제어 지시문이 제공됩니다.

섹션 14.8에서는 요청에 Authorization 헤더가 포함된 경우 일반적으로 공유 캐시가 이전 요청에 대한 응답을 저장하고 반환하는 것을 금지합니다.

상태 코드 200, 203, 206, 300, 301 또는 410으로 수신된 응답은 캐시에 저장되고 캐시 제어 지시문이 캐싱을 금지하지 않는 한 만료 메커니즘에 따라 후속 요청에 대한 응답으로 사용될 수 있습니다. 그러나 Range 및 Content-Range 헤더를 지원하지 않는 캐시는 206\(부분 콘텐츠\) 응답을 캐시해서는 안 됩니다.\(MAY, MUST NOT\)

다른 상태 코드\(예: 상태 코드 302 및 307\)와 함께 수신된 응답은 명시적으로 허용하는 캐시 제어 지시문이나 다른 헤더가 없는 한 후속 요청에 대한 응답으로 반환되어서는 안 됩니다. 예를 들어 여기에는 다음이 포함됩니다. Expires 헤더\(섹션 14.21\); "max-age", "s-maxage", "must- revalidate", "proxy-revalidate", "public" 또는 "private" 캐시 제어 지시문\(섹션 14.9\).\(MUST NOT\)

---
## **13.5 Constructing Responses From Caches**

HTTP 캐시의 목적은 향후 요청에 응답하는 데 사용할 요청에 대한 응답으로 수신된 정보를 저장하는 것입니다. 대부분의 경우 캐시는 단순히 요청자에게 응답의 적절한 부분을 반환합니다. 그러나 캐시가 이전 응답을 기반으로 캐시 항목을 보유하는 경우 새 응답의 일부를 캐시 항목에 보관된 항목과 결합해야 할 수도 있습니다.

---
### **13.5.1 End-to-end and Hop-by-hop Headers**

캐시 및 비캐싱 프록시의 동작을 정의하기 위해 HTTP 헤더를 두 가지 범주로 나눕니다.

- - 요청이나 응답의 최종 수신자에게 전송되는 엔드투엔드 헤더입니다. 응답의 종단 간 헤더는 캐시 항목의 일부로 저장되어야 하며 캐시 항목에서 형성된 모든 응답으로 전송되어야 합니다.\(MUST\)

- - 단일 전송 수준 연결에만 의미가 있고 캐시에 저장되거나 프록시에 의해 전달되지 않는 홉별 헤더입니다.

다음 HTTP/1.1 헤더는 홉별 헤더입니다.

```text
      - Connection
      - Keep-Alive
      - Proxy-Authenticate
      - Proxy-Authorization
      - TE
      - Trailers
      - Transfer-Encoding
      - Upgrade
```

HTTP/1.1에 정의된 다른 모든 헤더는 엔드투엔드 헤더입니다.

다른 홉별 헤더는 HTTP/1.1\(또는 그 이상\)에 도입되기 위해 연결 헤더\(섹션 14.10\)에 나열되어야 합니다.\(MUST\)

---
### **13.5.2 Non-modifiable Headers**

다이제스트 인증과 같은 HTTP/1.1 프로토콜의 일부 기능은 특정 종단 간 헤더의 값에 따라 달라집니다. 투명 프록시는 해당 헤더의 정의에서 요구하거나 특별히 허용하지 않는 한 종단 간 헤더를 수정해서는 안 됩니다.\(SHOULD NOT\)

투명 프록시는 요청 또는 응답에서 다음 필드를 수정해서는 안 되며, 아직 존재하지 않는 경우 이러한 필드를 추가해서는 안 됩니다.\(MUST NOT\)

```text
      - Content-Location

      - Content-MD5

      - ETag

      - Last-Modified
```

투명 프록시는 응답에서 다음 필드를 수정해서는 안 됩니다.\(MUST NOT\)

```text
      - Expires
```

그러나 아직 존재하지 않는 경우 이러한 필드를 추가할 수 있습니다. Expires 헤더가 추가되면 해당 응답의 Date 헤더와 동일한 필드 값이 제공되어야 합니다.\(MAY, MUST\)

프록시는 no-transform 캐시 제어 지시문이 포함된 메시지 또는 요청에서 다음 필드를 수정하거나 추가해서는 안 됩니다.\(MUST NOT\)

```text
      - Content-Encoding

      - Content-Range

      - Content-Type
```

불투명 프록시는 변환 없음을 포함하지 않는 메시지에 이러한 필드를 수정하거나 추가할 수 있지만, 그렇게 하는 경우 경고 214\(변환 적용됨\)가 메시지에 아직 나타나지 않으면 반드시 추가해야 합니다\(섹션 참조\). 14.46\).\(MUST\)

- 경고: 이후 버전의 HTTP에 더 강력한 인증 메커니즘이 도입되면 종단 간 헤더를 불필요하게 수정하면 인증 실패가 발생할 수 있습니다. 이러한 인증 메커니즘은 여기에 나열되지 않은 헤더 필드의 값에 의존할 수 있습니다.\(MAY\)

요청 또는 응답의 Content-Length 필드는 섹션 4.4의 규칙에 따라 추가되거나 삭제됩니다. 투명 프록시는 전송 길이\(섹션 4.4\)를 변경할 수 있지만 엔터티 본문의 엔터티 길이\(섹션 7.2.2\)를 보존해야 합니다.\(MUST\)

---
### **13.5.3 Combining Headers**

캐시가 서버에 유효성 검사 요청을 하고 서버가 304\(수정되지 않음\) 응답 또는 206\(부분 콘텐츠\) 응답을 제공하면 캐시는 요청 클라이언트에 보낼 응답을 구성합니다.

상태 코드가 304\(수정되지 않음\)인 경우 캐시는 캐시 항목에 저장된 Entity-Body를 이 나가는 응답의 Entity-Body로 사용합니다. 상태 코드가 206\(부분 콘텐츠\)이고 ETag 또는 Last-Modified 헤더가 정확히 일치하는 경우 캐시는 캐시 항목에 저장된 콘텐츠를 응답에서 수신된 새 콘텐츠와 결합하고 결과를 엔터티 본문으로 사용할 수 있습니다. 이 나가는 응답\(13.5.4 참조\).\(MAY\)

캐시 항목에 저장된 종단 간 헤더는 다음을 제외하고 구성된 응답에 사용됩니다.

- - 경고 코드 1xx\(섹션 14.46 참조\)가 있는 저장된 모든 경고 헤더는 캐시 항목과 전달된 응답에서 삭제되어야 합니다.\(MUST\)

- - 경고 코드 2xx가 포함된 모든 저장된 경고 헤더는 캐시 항목 및 전달된 응답에 유지되어야 합니다.\(MUST\)

- - 304 또는 206 응답에 제공된 모든 종단 간 헤더는 캐시 항목의 해당 헤더를 대체해야 합니다.\(MUST\)

캐시가 캐시 항목을 제거하기로 결정하지 않는 한 캐시 항목에 저장된 엔드투엔드 헤더를 바로 위에서 설명한 경고 헤더를 제외하고 들어오는 응답에서 수신된 해당 헤더로 교체해야 합니다. 수신 응답의 헤더 필드 이름이 캐시 항목의 두 개 이상의 헤더와 일치하는 경우 이러한 이전 헤더를 모두 교체해야 합니다.\(MUST, MUST\)

즉, 들어오는 응답에서 수신된 종단 간 헤더 집합은 캐시 항목과 함께 저장된 모든 해당 종단 간 헤더를 재정의합니다\(경고 코드 1xx가 포함된 저장된 경고 헤더는 제외\). 재정의됨\).

참고: 이 규칙은 원본 서버가 304\(Not

- 수정됨\) 또는 206\(부분 콘텐츠\) 응답으로 동일한 엔터티 또는 그 하위 범위에 대한 이전 응답과 관련된 헤더를 업데이트합니다. 하지만 그렇게 하는 것이 항상 의미가 있거나 정확하지는 않습니다. 이 규칙은 원본 서버가 304\(수정되지 않음\) 또는 206\(부분 콘텐츠\) 응답을 사용하여 이전 응답과 함께 제공한 헤더를 완전히 삭제하는 것을 허용하지 않습니다.

---
### **13.5.4 Combining Byte Ranges**

요청에 하나 이상의 범위 사양이 포함되었거나 연결이 조기에 끊어졌기 때문에 응답은 엔터티 본문 바이트의 하위 범위만 전송할 수 있습니다. 그러한 전송을 여러 번 한 후에 캐시는 동일한 엔터티 본문의 여러 범위를 수신했을 수 있습니다.

캐시에 엔터티에 대한 비어 있지 않은 하위 범위 집합이 저장되어 있고 수신 응답이 다른 하위 범위를 전송하는 경우 다음 조건이 모두 충족되면 캐시는 새 하위 범위를 기존 집합과 결합할 수 있습니다.\(MAY\)

- - 들어오는 응답과 캐시 항목 모두 캐시 유효성 검사기를 갖습니다.

- - 두 개의 캐시 유효성 검사기는 강력한 비교 기능을 사용하여 일치합니다\(섹션 13.3.3 참조\).

요구 사항 중 하나라도 충족되지 않으면 캐시는 가장 최근의 부분 응답\(모든 응답과 함께 전송된 날짜 값을 기반으로 하고 이러한 값이 동일하거나 누락된 경우 들어오는 응답을 사용\)만 사용해야 하며 다른 부분 정보를 폐기해야 합니다\(MUST\).\(MUST\)

---
## **13.6 Caching Negotiated Responses**

응답에 Vary 헤더 필드가 있는 것으로 표시되는 서버 중심 콘텐츠 협상\(12.1절\)을 사용하면 캐시가 후속 요청에 대한 응답을 사용할 수 있는 조건과 절차가 변경됩니다. 서버에서 Vary 헤더 필드를 사용하는 방법은 섹션 14.44를 참조하세요.

서버는 Vary 헤더 필드를 사용하여 서버 주도 협상에 따라 캐시 가능한 응답의 여러 표현 중에서 선택하는 데 사용된 요청 헤더 필드를 캐시에 알려야 합니다\(SHOULD\). Vary 필드 값으로 명명된 헤더 필드 세트를 "선택" 요청 헤더라고 합니다.\(SHOULD\)

캐시가 Request-URI가 Vary 헤더 필드를 포함하여 하나 이상의 캐시 항목을 지정하는 후속 요청을 수신할 때 캐시는 해당 캐시 항목을 사용하여 새 요청에 대한 응답을 구성해서는 안 됩니다. 새 요청은 원래 요청에 저장된 해당 요청 헤더와 일치합니다.\(MUST NOT\)

두 요청의 선택 요청 헤더는 첫 번째 요청의 선택 요청 헤더가 두 번째 요청의 선택 요청 헤더로 변환될 수 있는 경우에만 일치하도록 정의됩니다.

해당 BNF에서 허용하는 위치에 선형 공백\(LWS\)을 추가 또는 제거하거나 섹션 4.2의 메시지 헤더에 대한 규칙에 따라 여러 메시지 헤더 필드를 동일한 필드 이름으로 결합합니다.

"\*"의 Vary 헤더 필드 값은 항상 일치하지 않으며 해당 리소스에 대한 후속 요청은 원본 서버에서만 적절하게 해석될 수 있습니다.

캐시된 항목에 대한 선택 요청 헤더 필드가 새 요청의 선택 요청 헤더 필드와 일치하지 않는 경우 캐시는 먼저 조건부로 새 요청을 원서버에 중계하지 않는 한 요청을 충족하기 위해 캐시된 항목을 사용해서는 안 됩니다. 요청하면 서버는 사용할 엔터티를 나타내는 엔터티 태그 또는 Content-Location을 포함하여 304\(수정되지 않음\)로 응답합니다.\(MUST NOT\)

엔터티 태그가 캐시된 표현에 할당된 경우 전달된 요청은 조건부여야 하며 리소스에 대한 모든 캐시 항목의 If-None-Match 헤더 필드에 엔터티 태그를 포함해야 합니다. 이는 현재 캐시가 보유하고 있는 엔터티 집합을 서버에 전달하므로 이러한 엔터티 중 하나라도 요청된 엔터티와 일치하면 서버는 304\(수정되지 않음\) 응답에서 ETag 헤더 필드를 사용하여 캐시에 어떤 항목이 있는지 알릴 수 있습니다. 적절하다. 새 응답의 엔터티 태그가 기존 항목의 엔터티 태그와 일치하는 경우 새 응답을 사용하여 기존 항목의 헤더 필드를 업데이트해야 하며 결과가 클라이언트에 반환되어야 합니다.\(SHOULD, MUST\)

기존 캐시 항목 중 하나라도 관련 엔터티에 대한 부분 콘텐츠만 포함하는 경우 요청이 해당 항목에 의해 완전히 충족되는 범위에 대한 것이 아니라면 해당 엔터티 태그는 If-None-Match 헤더 필드에 포함되어서는 안 됩니다.\(SHOULD NOT\)

캐시가 동일한 Request-\]URI에 대한 Content-Location 필드가 기존 캐시 항목의 항목과 일치하고, 해당 엔터티 태그가 기존 항목의 항목과 다르며, 날짜가 기존 항목보다 최신인 성공적인 응답을 수신한 경우 항목인 경우 기존 항목은 향후 요청에 대한 응답으로 반환되어서는 안 되며 캐시에서 삭제되어야 합니다.\(SHOULD NOT\)

---
## **13.7 Shared and Non-Shared Caches**

보안 및 개인정보 보호를 위해 "공유" 캐시와 "비공유" 캐시를 구별할 필요가 있습니다. 비공유 캐시는 단일 사용자만 액세스할 수 있는 캐시입니다. 이 경우 접근성은 적절한 보안 메커니즘을 통해 시행되어야 합니다. 다른 모든 캐시는 "공유"된 것으로 간주됩니다. 다른 섹션\(SHOULD\)

이 사양은 개인 정보 손실이나 액세스 제어 실패를 방지하기 위해 공유 캐시 작동에 특정 제약을 적용합니다.

---
## **13.8 Errors or Incomplete Response Cache Behavior**

불완전한 응답\(예: Content-Length 헤더에 지정된 것보다 적은 바이트의 데이터\)을 수신하는 캐시는 응답을 저장할 수 있습니다. 그러나 캐시는 이를 부분 응답으로 처리해야 합니다. 섹션 13.5.4에 설명된 대로 부분 응답을 결합할 수 있습니다. 결과는 전체 응답일 수도 있고 여전히 부분적일 수도 있습니다. 캐시는 206\(부분 콘텐츠\) 상태 코드를 사용하여 명시적으로 표시하지 않고 클라이언트에 부분 응답을 반환해서는 안 됩니다. 캐시는 상태 코드 200\(OK\)을 사용하여 부분 응답을 반환해서는 안 됩니다.\(MAY, MUST, MAY, MUST NOT, MUST NOT\)

캐시가 항목 재검증을 시도하는 동안 5xx 응답을 수신하면 이 응답을 요청 클라이언트에 전달하거나 서버가 응답에 실패한 것처럼 작동할 수 있습니다. 후자의 경우, 캐시된 항목에 "must-revalidate" 캐시 제어 지시어가 포함되어 있지 않는 한 이전에 수신한 응답을 반환할 수 있습니다\(섹션 14.9 참조\).\(MAY, MAY\)

---
## **13.9 Side Effects of GET and HEAD**

원서버가 응답 캐싱을 명시적으로 금지하지 않는 한, 모든 리소스에 대한 GET 및 HEAD 메서드 적용은 이러한 응답이 캐시에서 가져오는 경우 잘못된 동작으로 이어질 수 있는 부작용을 가져서는 안 됩니다. 여전히 부작용이 있을 수 있지만 캐시는 캐싱 결정에서 그러한 부작용을 고려할 필요가 없습니다. 캐시는 항상 원본 서버의 캐싱에 대한 명시적 제한을 준수해야 합니다.\(SHOULD NOT, MAY\)

이 규칙에 대한 한 가지 예외에 주목합니다. 일부 애플리케이션은 전통적으로 쿼리 URL\(rel\_path 부분에 "?"가 포함된 URL\)과 함께 GET 및 HEAD를 사용하여 심각한 부작용이 있는 작업을 수행했기 때문에 캐시는 이러한 URI에 대한 응답을 새로운 것으로 처리해서는 안 됩니다. 서버가 명시적인 만료 시간을 제공하지 않는 한. 이는 특히 그러한 URI에 대한 HTTP/1.0 서버의 응답을 캐시에서 가져오면 안 된다는 것을 의미합니다. 관련 정보는 섹션 9.1.1을 참조하세요.\(MUST NOT, SHOULD NOT\)

---
## **13.10 Invalidation After Updates or Deletions**

원본 서버의 리소스에 대해 수행된 특정 방법의 영향으로 인해 하나 이상의 기존 캐시 항목이 불투명하게 무효화될 수 있습니다. 즉, 계속해서 "최신" 상태를 유지하더라도 원본 서버가 해당 리소스에 대한 새 요청에 대해 반환하는 내용을 정확하게 반영하지 않습니다.

HTTP 프로토콜에서는 이러한 모든 캐시 항목이 유효하지 않은 것으로 표시되도록 보장할 방법이 없습니다. 예를 들어, 원본 서버에서 변경을 야기한 요청이 캐시 항목이 저장된 프록시를 통과하지 않았을 수 있습니다. 그러나 몇 가지 규칙은 잘못된 동작의 가능성을 줄이는 데 도움이 됩니다.

이 섹션에서 "엔티티 무효화"라는 문구는 캐시가 해당 엔터티의 모든 인스턴스를 저장소에서 제거하거나 이를 "유효하지 않음"으로 표시하고 응답으로 반환되기 전에 필수 재검증이 필요함을 의미합니다. 후속 요청.

일부 HTTP 메소드는 캐시가 엔터티를 무효화하도록 해야 합니다. 이는 Request-URI 또는 ​​Location 또는 Content-Location 헤더\(있는 경우\)에서 참조하는 엔터티입니다. 이러한 방법은 다음과 같습니다.\(MUST\)

```text
      - PUT

      - DELETE

      - POST
```

서비스 거부 공격을 방지하기 위해 Location 또는 Content-Location 헤더의 URI를 기반으로 한 무효화는 호스트 부분이 Request-URI와 동일한 경우에만 수행되어야 합니다.\(MUST\)

이해하지 못하는 메소드에 대한 요청을 통과하는 캐시는 요청-URI가 참조하는 모든 엔터티를 무효화해야 합니다.\(SHOULD\)

---
## **13.11 Write-Through Mandatory**

원본 서버의 리소스를 수정할 것으로 예상되는 모든 메서드는 원본 서버를 통해 작성되어야 합니다. 여기에는 현재 GET 및 HEAD를 제외한 모든 메소드가 포함됩니다. 캐시는 요청을 인바운드 서버로 전송하고 인바운드 서버로부터 해당 응답을 수신하기 전에 클라이언트의 요청에 응답해서는 안 됩니다. 이는 인바운드 서버가 최종 응답을 보내기 전에 프록시 캐시가 100\(계속\) 응답을 보내는 것을 방지하지 않습니다.\(MUST, MUST NOT\)

일관된 업데이트를 제공하기 어렵고 쓰기 전에 서버, 캐시 또는 네트워크 오류로 인해 발생하는 문제로 인해 대안\("다시 쓰기" 또는 "다시 복사" 캐싱이라고 함\)은 HTTP/1.1에서 허용되지 않습니다. 뒤쪽에.

---
## **13.12 Cache Replacement**

동일한 리소스에 대한 기존 응답이 캐시되는 동안 새로운 캐시 가능\(섹션 14.9.2, 13.2.5, 13.2.6 및 13.8 참조\) 응답이 리소스로부터 수신되는 경우 캐시는 새 응답을 사용하여 현재 응답에 응답해야 합니다\(SHOULD\). 요구. 이를 캐시 저장소에 삽입할 수 있으며, 다른 모든 요구 사항을 충족하는 경우 이전에 이전 응답이 반환되도록 만들었던 향후 요청에 응답하는 데 이를 사용할 수 있습니다. 새 응답을 캐시 저장소에 삽입하는 경우 섹션 13.5.3의 규칙이 적용됩니다.\(SHOULD, MAY\)

- 참고: 기존에 캐시된 응답보다 오래된 Date 헤더 값을 가진 새 응답은 캐시할 수 없습니다.

---
## **13.13 History Lists**

사용자 에이전트에는 세션에서 이전에 검색된 엔터티를 다시 표시하는 데 사용할 수 있는 "뒤로" 버튼 및 기록 목록과 같은 기록 메커니즘이 있는 경우가 많습니다.

기록 메커니즘과 캐시는 다릅니다. 특히 기록 메커니즘은 리소스의 현재 상태에 대한 의미상 투명한 보기를 표시하려고 시도해서는 안 됩니다. 오히려 기록 메커니즘은 리소스를 검색할 때 사용자가 본 내용을 정확하게 보여주기 위한 것입니다.\(SHOULD NOT\)

기본적으로 만료 시간은 기록 메커니즘에 적용되지 않습니다. 엔터티가 아직 저장되어 있는 경우 사용자가 만료된 기록 문서를 새로 고치도록 에이전트를 특별히 구성하지 않은 한 엔터티가 만료된 경우에도 기록 메커니즘은 이를 표시해야 합니다.\(SHOULD\)

이는 기록 메커니즘이 사용자에게 보기가 오래되었을 수 있음을 알리는 것을 금지하는 것으로 해석되어서는 안 됩니다.

- 참고: 기록 목록 메커니즘으로 인해 사용자가 오래된 리소스를 보는 것을 불필요하게 방지하는 경우 서비스 작성자가 원할 때 HTTP 만료 제어 및 캐시 제어 사용을 피하게 되는 경향이 있습니다. 서비스 작성자는 사용자가 이전에 가져온 리소스를 보기 위해 탐색 컨트롤\(예: BACK\)을 사용할 때 오류 메시지나 경고 메시지가 표시되지 않는 것이 중요하다고 생각할 수 있습니다. 때때로 그러한 리소스가 캐시되어서는 안 되거나 빠르게 만료되어야 하는 경우에도 사용자 인터페이스 고려 사항으로 인해 서비스 작성자는 부적절하게 작동하는 결과를 겪지 않기 위해 캐싱을 방지하는 다른 수단\(예: "한 번만" URL\)을 사용해야 할 수 있습니다. 역사 메커니즘.

---
# **14 Header Field Definitions**

이 섹션에서는 모든 표준 HTTP/1.1 헤더 필드의 구문과 의미를 정의합니다. 엔터티 헤더 필드의 경우 보낸 사람과 받는 사람 모두 엔터티를 보내고 받는 사람에 따라 클라이언트나 서버를 참조합니다.

---
## **14.1 Accept**

Accept 요청 헤더 필드는 응답에 허용되는 특정 미디어 유형을 지정하는 데 사용될 수 있습니다. Accept 헤더는 인라인 이미지에 대한 요청의 경우처럼 요청이 원하는 유형의 작은 집합으로 구체적으로 제한되어 있음을 나타내는 데 사용될 수 있습니다.

```text
       Accept         = "Accept" ":"
                        #( media-range [ accept-params ] )

       media-range    = ( "*/*"
                        | ( type "/" "*" )
                        | ( type "/" subtype )
                        ) *( ";" parameter )
       accept-params  = ";" "q" "=" qvalue *( accept-extension )
       accept-extension = ";" token [ "=" ( token | quoted-string ) ]
```

별표 "\*" 문자는 미디어 유형을 범위로 그룹화하는 데 사용됩니다. "\*/\*"는 모든 미디어 유형을 나타내고 "type/\*"은 해당 유형의 모든 하위 유형을 나타냅니다. 미디어 범위에는 해당 범위에 적용할 수 있는 미디어 유형 매개변수가 포함될 수 있습니다.\(MAY\)

각 미디어 범위 뒤에는 상대적인 품질 요소를 나타내는 "q" 매개변수로 시작하는 하나 이상의 accept-params가 올 수 있습니다. 첫 번째 "q" 매개변수\(있는 경우\)는 미디어 범위 매개변수를 허용 매개변수와 구분합니다. 품질 요소를 사용하면 사용자 또는 사용자 에이전트는 0에서 1까지의 qvalue 척도를 사용하여 해당 미디어 범위에 대한 상대적인 선호도를 나타낼 수 있습니다\(섹션 3.9\). 기본값은 q=1입니다.\(MAY\)

- 참고: 미디어 유형 매개변수와 확장 매개변수 승인을 구분하기 위해 "q" 매개변수 이름을 사용하는 것은 역사적 관행 때문입니다. 이렇게 하면 "q"라는 이름의 미디어 유형 매개변수가 미디어 범위와 함께 사용되는 것이 방지되지만, IANA 미디어 유형 레지스트리에 "q" 매개변수가 부족하고 미디어 유형이 거의 사용되지 않는다는 점을 고려하면 이러한 이벤트는 발생할 가능성이 거의 없는 것으로 여겨집니다. Accept의 매개변수 향후 미디어 유형에서는 "q"라는 매개변수를 등록하지 않는 것이 좋습니다.

예

```text
       Accept: audio/*; q=0.2, audio/basic

   SHOULD be interpreted as "I prefer audio/basic, but send me any audio
   type if it is the best available after an 80% mark-down in quality."
```

Accept 헤더 필드가 없으면 클라이언트가 모든 미디어 유형을 수락하는 것으로 간주됩니다. Accept 헤더 필드가 존재하고 서버가 결합된 Accept 필드 값에 따라 허용 가능한 응답을 보낼 수 없는 경우 서버는 406\(허용되지 않음\) 응답을 보내야 합니다.\(SHOULD\)

좀 더 정교한 예는 다음과 같습니다.

```text
       Accept: text/plain; q=0.5, text/html,
               text/x-dvi; q=0.8, text/x-c

   Verbally, this would be interpreted as "text/html and text/x-c are
   the preferred media types, but if they do not exist, then send the
   text/x-dvi entity, and if that does not exist, send the text/plain
   entity."
```

미디어 범위는 보다 구체적인 미디어 범위나 특정 미디어 유형으로 재정의될 수 있습니다. 특정 유형에 둘 이상의 미디어 범위가 적용되는 경우 가장 구체적인 참조가 우선적으로 적용됩니다. 예를 들어,

```text
       Accept: text/*, text/html, text/html;level=1, */*
```

다음과 같은 우선순위를 갖습니다:

```text
       1) text/html;level=1
       2) text/html
       3) text/*
       4) */*
```

특정 유형과 관련된 미디어 유형 품질 요소는 해당 유형과 일치하는 우선순위가 가장 높은 미디어 범위를 찾아서 결정됩니다. 예를 들어,

```text
       Accept: text/*;q=0.3, text/html;q=0.7, text/html;level=1,
               text/html;level=2;q=0.4, */*;q=0.5
```

다음 값이 연결됩니다.

```text
       text/html;level=1         = 1
       text/html                 = 0.7
       text/plain                = 0.3

       image/jpeg                = 0.5
       text/html;level=2         = 0.4
       text/html;level=3         = 0.7
```

- 참고: 사용자 에이전트에는 특정 미디어 범위에 대한 기본 품질 값 세트가 제공될 수 있습니다. 그러나 사용자 에이전트가 다른 렌더링 에이전트와 상호 작용할 수 없는 폐쇄형 시스템이 아닌 이상 이 기본 설정은 사용자가 구성할 수 있어야 합니다.

---
## **14.2 Accept-Charset**

Accept-Charset 요청 헤더 필드는 응답에 허용되는 문자 집합을 나타내는 데 사용될 수 있습니다. 이 필드를 사용하면 보다 포괄적이거나 특수 목적의 문자 집합을 이해할 수 있는 클라이언트가 해당 문자 집합으로 문서를 표현할 수 있는 서버에 해당 기능을 알릴 수 있습니다.

```text
      Accept-Charset = "Accept-Charset" ":"
              1#( ( charset | "*" )[ ";" "q" "=" qvalue ] )
```

문자 집합 값은 섹션 3.4에 설명되어 있습니다. 각 문자 세트에는 해당 문자 세트에 대한 사용자의 선호도를 나타내는 관련 품질 값이 제공될 수 있습니다. 기본값은 q=1입니다. 예는 다음과 같습니다\(MAY\)

```text
      Accept-Charset: iso-8859-5, unicode-1-1;q=0.8
```

Accept-Charset 필드에 있는 특수 값 "\*"는 Accept-Charset 필드의 다른 곳에서 언급되지 않은 모든 문자 세트\(ISO-8859-1 포함\)와 일치합니다. Accept-Charset 필드에 "\*"가 없으면 명시적으로 언급되지 않은 모든 문자 세트는 품질 값 0을 얻습니다. 단, ISO-8859-1은 명시적으로 언급되지 않은 경우 품질 값 1을 얻습니다.

Accept-Charset 헤더가 없으면 기본값은 모든 문자 집합을 허용하는 것입니다. Accept-Charset 헤더가 있고 서버가 Accept-Charset 헤더에 따라 허용되는 응답을 보낼 수 없는 경우 서버는 406\(허용되지 않음\) 상태 코드와 함께 오류 응답을 보내야 합니다. 허용되지 않는 응답도 허용됩니다.\(SHOULD\)

---
## **14.3 Accept-Encoding**

Accept-Encoding 요청 헤더 필드는 Accept와 유사하지만 응답에서 허용되는 콘텐츠 코딩\(섹션 3.5\)을 제한합니다.

```text
       Accept-Encoding  = "Accept-Encoding" ":"

                          1#( codings [ ";" "q" "=" qvalue ] )
       codings          = ( content-coding | "*" )
```

사용 예는 다음과 같습니다.

```text
       Accept-Encoding: compress, gzip
       Accept-Encoding:
       Accept-Encoding: *
       Accept-Encoding: compress;q=0.5, gzip;q=1.0
       Accept-Encoding: gzip;q=1.0, identity; q=0.5, *;q=0
```

서버는 다음 규칙을 사용하여 Accept-Encoding 필드에 따라 콘텐츠 코딩이 허용되는지 여부를 테스트합니다.

```text
      1. If the content-coding is one of the content-codings listed in
         the Accept-Encoding field, then it is acceptable, unless it is
         accompanied by a qvalue of 0. (As defined in section 3.9, a
         qvalue of 0 means "not acceptable.")
```

- 2. Accept-Encoding 필드의 특수 "\*" 기호는 헤더 필드에 명시적으로 나열되지 않은 사용 가능한 콘텐츠 코딩과 일치합니다.

- 3. 여러 콘텐츠 코딩이 허용되는 경우 0이 아닌 가장 높은 q값을 가진 허용 가능한 콘텐츠 코딩이 선호됩니다.

- 4. Accept-Encoding 필드에 "identity;q=0"이 포함되거나 필드에 "\*;q=0"이 포함되어 있고 명시적으로 포함되지 않기 때문에 특별히 거부되지 않는 한 "identity" 콘텐츠 코딩은 항상 허용됩니다. "신원" 콘텐츠 코딩. Accept-Encoding 필드 값이 비어 있으면 "ID" 인코딩만 허용됩니다.

요청에 Accept-Encoding 필드가 있고 서버가 Accept-Encoding 헤더에 따라 허용 가능한 응답을 보낼 수 없는 경우 서버는 406\(허용되지 않음\) 상태 코드와 함께 오류 응답을 보내야 합니다.\(SHOULD\)

요청에 Accept-Encoding 필드가 없으면 서버는 클라이언트가 모든 콘텐츠 코딩을 수락할 것이라고 가정할 수 있습니다. 이 경우 "ID"가 사용 가능한 콘텐츠 코딩 중 하나인 경우 서버는 다른 콘텐츠 코딩이 클라이언트에 의미가 있다는 추가 정보가 없는 한 "ID" 콘텐츠 코딩을 사용해야 합니다.\(MAY, SHOULD\)

- 참고: 요청에 Accept-Encoding 필드가 포함되지 않고 "ID" 콘텐츠 코딩을 사용할 수 없는 경우 콘텐츠 코딩은 일반적으로 HTTP/1.0 클라이언트에서 이해됩니다\(예:

"gzip" 및 "압축"\)이 선호됩니다. 일부 오래된 고객

- 다른 콘텐츠 코딩과 함께 전송된 메시지를 부적절하게 표시합니다. 서버는 특정 사용자 에이전트나 클라이언트에 대한 정보를 기반으로 이 결정을 내릴 수도 있습니다.

- 참고: 대부분의 HTTP/1.0 애플리케이션은 콘텐츠 코딩과 관련된 qvalue를 인식하거나 따르지 않습니다. 이는 qvalue가 작동하지 않으며 x-gzip 또는 x-compress에서 허용되지 않음을 의미합니다.

---
## **14.4 Accept-Language**

Accept-Language 요청 헤더 필드는 Accept와 유사하지만 요청에 대한 응답으로 선호되는 자연어 세트를 제한합니다. 언어 태그는 섹션 3.10에 정의되어 있습니다.

```text
       Accept-Language = "Accept-Language" ":"
                         1#( language-range [ ";" "q" "=" qvalue ] )
       language-range  = ( ( 1*8ALPHA *( "-" 1*8ALPHA ) ) | "*" )
```

각 언어 범위에는 해당 범위에서 지정된 언어에 대한 사용자 선호도의 추정치를 나타내는 관련 품질 값이 제공될 수 있습니다. 품질 값의 기본값은 "q=1"입니다. 예를 들어,\(MAY\)

```text
       Accept-Language: da, en-gb;q=0.8, en;q=0.7
```

"나는 덴마크어를 선호하지만 영국식 영어와 다른 유형의 영어도 허용합니다."라는 의미입니다. 언어 범위는 태그와 정확히 일치하는 경우 또는 접두사 뒤의 첫 번째 태그 문자가 "-"인 등 태그의 접두사와 정확히 동일한 경우 언어 태그와 일치합니다. Accept-Language 필드에 있는 특수 범위 "\*"는 Accept-Language 필드에 있는 다른 범위와 일치하지 않는 모든 태그와 일치합니다.

- 참고: 접두사 일치 규칙을 사용한다고 해서 사용자가 특정 태그가 있는 언어를 이해하면 이 사용자가 해당 태그가 있는 모든 언어도 이해할 것이라는 것이 항상 사실인 방식으로 언어 태그가 언어에 할당된다는 의미는 아닙니다. 이 태그가 접두사인 태그입니다. 접두사 규칙은 이 경우 접두사 태그의 사용을 허용합니다.

Accept-Language 필드에 의해 언어 태그에 할당된 언어 품질 요소는 해당 필드에서 언어 태그와 일치하는 가장 긴 언어 범위의 품질 값입니다. 필드의 언어 범위가 태그와 일치하지 않으면 할당된 언어 품질 요소는 0입니다. 요청에 Accept-Language 헤더가 없으면 서버는

모든 언어가 동일하게 허용된다고 가정해야 합니다\(SHOULD\). Accept-Language 헤더가 있으면 0보다 큰 품질 요소가 할당된 모든 언어가 허용됩니다.\(SHOULD\)

모든 요청에서 사용자의 완전한 언어 기본 설정과 함께 Accept-Language 헤더를 보내는 것은 사용자의 개인 정보 보호 기대에 어긋날 수 있습니다. 이 문제에 대한 논의는 섹션 15.1.4를 참조하십시오.

명료도는 개별 사용자에 따라 크게 달라지므로 클라이언트 응용 프로그램에서 사용자가 사용할 수 있는 언어 기본 설정을 선택하는 것이 좋습니다. 선택할 수 없는 경우 Accept-Language 헤더 필드를 요청에 제공해서는 안 됩니다.\(MUST NOT\)

- 참고: 사용자가 언어적 선호도를 선택할 수 있도록 할 때 사용자는 위에서 설명한 언어 매칭의 세부 사항에 익숙하지 않다는 사실을 구현자에게 상기시키고 적절한 지침을 제공해야 합니다. 예를 들어, 사용자는 "en-gb"를 선택하면 영국 영어를 사용할 수 없는 경우 모든 종류의 영어 문서가 제공될 것이라고 가정할 수 있습니다. 이러한 경우 사용자 에이전트는 가장 일치하는 동작을 얻기 위해 "en"을 추가하도록 제안할 수 있습니다.

---
## **14.5 Accept-Ranges**

- Accept-Ranges 응답 헤더 필드를 사용하면 서버는 리소스에 대한 범위 요청의 수락을 나타낼 수 있습니다.

```text
          Accept-Ranges     = "Accept-Ranges" ":" acceptable-ranges
          acceptable-ranges = 1#range-unit | "none"
```

- 바이트 범위 요청을 수락하는 원본 서버는 보낼 수 있습니다.\(MAY\)

```text
          Accept-Ranges: bytes
```

- 하지만 반드시 그렇게 해야 하는 것은 아닙니다. 클라이언트는 관련된 리소스에 대해 이 헤더를 수신하지 않고도 바이트 범위 요청을 생성할 수 있습니다. 범위 단위는 섹션 3.12에 정의되어 있습니다.\(MAY\)

- 리소스에 대한 어떤 종류의 범위 요청도 수락하지 않는 서버는 보낼 수 있습니다.\(MAY\)

```text
          Accept-Ranges: none
```

- 클라이언트에게 범위 요청을 시도하지 말라고 조언합니다.

---
## **14.6 Age**

- Age 응답 헤더 필드는 원본 서버에서 응답\(또는 재검증\)이 생성된 이후 보낸 사람의 추정 시간을 전달합니다. 캐시된 응답은 수명이 신선도 수명을 초과하지 않는 경우 "신선"합니다. 연령 값은 섹션 13.2.3에 지정된 대로 계산됩니다.

```text
           Age = "Age" ":" age-value
           age-value = delta-seconds
```

- 연령 값은 음이 아닌 십진수 정수로, 시간을 초 단위로 나타냅니다.

- 캐시가 나타낼 수 있는 가장 큰 양의 정수보다 큰 값을 수신하거나 수명 계산이 오버플로되는 경우 2147483648\(2^31\) 값을 가진 Age 헤더를 전송해야 합니다. 캐시를 포함하는 HTTP/1.1 서버는 자체 캐시에서 생성된 모든 응답에 Age 헤더 필드를 포함해야 합니다. 캐시는 최소 31비트 범위의 산술 유형을 사용해야 합니다.\(MUST, MUST, SHOULD\)

---
## **14.7 Allow**

- 허용 엔터티 헤더 필드에는 요청-URI로 식별된 리소스가 지원하는 메서드 집합이 나열됩니다. 이 필드의 목적은 엄격하게 리소스와 관련된 유효한 방법을 수신자에게 알리는 것입니다. Allow 헤더 필드는 405\(Method Not Allowed\) 응답에 있어야 합니다.\(MUST\)

```text
          Allow   = "Allow" ":" #Method
```

- 사용예:

```text
          Allow: GET, HEAD, PUT
```

- 이 필드는 클라이언트가 다른 방법을 시도하는 것을 막을 수 없습니다. 그러나 허용 헤더 필드 값이 제공하는 표시를 따라야 합니다. 허용되는 실제 메소드 세트는 각 요청 시 원본 서버에 의해 정의됩니다.\(SHOULD\)

- 새로운 리소스나 수정된 ​​리소스가 지원할 방법을 추천하기 위해 Allow 헤더 필드가 PUT 요청과 함께 제공될 수 있습니다. 서버는 이러한 메서드를 지원할 필요가 없으며 실제 지원되는 메서드를 제공하는 응답에 Allow 헤더를 포함해야 합니다.\(MAY, SHOULD\)

- 프록시는 지정된 모든 방법을 이해하지 못하더라도 허용 헤더 필드를 수정해서는 안 됩니다. 사용자 에이전트가 원서버와 통신하는 다른 수단을 가질 수 있기 때문입니다.\(MUST NOT\)

---
## **14.8 Authorization**

- 서버에 자신을 인증하려는 사용자 에이전트는 일반적으로 401 응답을 받은 후 반드시 그런 것은 아니지만 요청에 Authorization 요청 헤더 필드를 포함하여 인증을 수행합니다. Authorization 필드 값은 요청 중인 리소스 영역에 대한 사용자 에이전트의 인증 정보가 포함된 자격 증명으로 구성됩니다.

```text
          Authorization  = "Authorization" ":" credentials
```

- HTTP 액세스 인증은 "HTTP 인증: 기본 및 다이제스트 액세스 인증" \[43\]에 설명되어 있습니다. 요청이 인증되고 영역이 지정된 경우 동일한 자격 증명이 이 영역 내의 다른 모든 요청에 ​​대해 유효해야 합니다\(인증 체계 자체가 챌린지 값에 따라 달라지는 자격 증명이나 동기화된 시계를 사용하는 것과 같은 달리 요구하지 않는다고 가정\). .\(SHOULD\)

공유 캐시\(13.7절 참조\)가 요청을 수신할 때

- Authorization 필드를 포함하는 경우 다음 특정 예외 중 하나가 발생하지 않는 한 다른 요청에 대한 응답으로 해당 응답을 반환해서는 안 됩니다.\(MUST NOT\)

1. 응답에 "s-maxage" 캐시 제어가 포함된 경우

- 지시문에 따라 캐시는 후속 요청에 응답할 때 해당 응답을 사용할 수 있습니다. 그러나 \(지정된 최대 수명이 지난 경우\) 프록시 캐시는 원본 서버가 새 요청을 인증할 수 있도록 새 요청의 요청 헤더를 사용하여 먼저 원본 서버에서 이를 재검증해야 합니다. \(이것은 s-maxage에 대해 정의된 동작입니다.\) 응답에 "s-maxage=0"이 포함된 경우 프록시는 이를 재사용하기 전에 항상 이를 재검증해야 합니다.\(MAY, MUST, MUST\)

- 2. 응답에 "must-revalidate" 캐시 제어 지시문이 포함된 경우 캐시는 후속 요청에 응답할 때 해당 응답을 사용할 수 있습니다. 그러나 응답이 오래되면 모든 캐시는 원본 서버가 새 요청을 인증할 수 있도록 새 요청의 요청 헤더를 사용하여 원본 서버에서 먼저 이를 재검증해야 합니다.\(MAY, MUST\)

- 3. 응답에 "public" 캐시 제어 지시문이 포함된 경우 후속 요청에 대한 응답으로 반환될 수 있습니다.\(MAY\)

---
## **14.9 Cache-Control**

Cache-Control 일반 헤더 필드는 요청/응답 체인을 따라 모든 캐싱 메커니즘을 따라야 하는 지시어를 지정하는 데 사용됩니다. 지시어는 캐시가 요청이나 응답을 방해하는 것을 방지하기 위한 동작을 지정합니다. 이러한 지시문은 일반적으로 기본 캐싱 알고리즘을 재정의합니다. 요청에 지시문이 있다고 해서 응답에 동일한 지시문이 제공된다는 의미는 아니라는 점에서 캐시 지시문은 단방향입니다.\(MUST\)

- HTTP/1.0 캐시는 Cache-Control을 구현하지 않을 수 있으며 Pragma: no-cache만 구현할 수 있습니다\(섹션 14.32 참조\).

캐시 지시문은 요청/응답 체인을 따라 모든 수신자에게 적용될 수 있으므로 해당 애플리케이션에 대한 중요성에 관계없이 프록시 또는 게이트웨이 애플리케이션을 통해 전달되어야 합니다. 특정 캐시에 대해 캐시 지시어를 지정할 수 없습니다.\(MUST\)

```text
    Cache-Control   = "Cache-Control" ":" 1#cache-directive

    cache-directive = cache-request-directive
         | cache-response-directive

    cache-request-directive =
           "no-cache"                          ; Section 14.9.1
         | "no-store"                          ; Section 14.9.2
         | "max-age" "=" delta-seconds         ; Section 14.9.3, 14.9.4
         | "max-stale" [ "=" delta-seconds ]   ; Section 14.9.3
         | "min-fresh" "=" delta-seconds       ; Section 14.9.3
         | "no-transform"                      ; Section 14.9.5
         | "only-if-cached"                    ; Section 14.9.4
         | cache-extension                     ; Section 14.9.6

     cache-response-directive =
           "public"                               ; Section 14.9.1
         | "private" [ "=" <"> 1#field-name <"> ] ; Section 14.9.1
         | "no-cache" [ "=" <"> 1#field-name <"> ]; Section 14.9.1
         | "no-store"                             ; Section 14.9.2
         | "no-transform"                         ; Section 14.9.5
         | "must-revalidate"                      ; Section 14.9.4
         | "proxy-revalidate"                     ; Section 14.9.4
         | "max-age" "=" delta-seconds            ; Section 14.9.3
         | "s-maxage" "=" delta-seconds           ; Section 14.9.3
         | cache-extension                        ; Section 14.9.6

    cache-extension = token [ "=" ( token | quoted-string ) ]
```

1#field-name 매개변수 없이 지시문이 나타나면 지시문은 전체 요청 또는 응답에 적용됩니다. 이러한 지시문이 1#field-name 매개변수와 함께 나타나면 명명된 필드에만 적용되고 나머지 요청이나 응답에는 적용되지 않습니다. 이 메커니즘은 확장성을 지원합니다. HTTP 프로토콜의 향후 버전 구현에서는 HTTP/1.1에 정의되지 않은 헤더 필드에 이러한 지시문을 적용할 수 있습니다.

캐시 제어 지시문은 다음과 같은 일반적인 범주로 분류될 수 있습니다.

- - 캐시 가능한 항목에 대한 제한 사항 이는 원본 서버에 의해서만 부과될 수 있습니다.

- - 캐시에 저장할 수 있는 항목에 대한 제한 사항 이는 원본 서버나 사용자 에이전트에 의해 부과될 수 있습니다.

- - 기본 만료 메커니즘의 수정 이는 원본 서버나 사용자 에이전트에 의해 부과될 수 있습니다.

- - 캐시 재검증 및 재로드를 제어합니다. 이는 사용자 에이전트에 의해서만 부과될 수 있습니다.

- - 엔터티 변환을 제어합니다.

- - 캐싱 시스템 확장.

---
### **14.9.1 What is Cacheable**

기본적으로 요청 메서드, 요청 헤더 필드 및 응답 상태의 요구 사항에 따라 응답이 캐시 가능하다고 표시되면 응답을 캐시할 수 있습니다. 섹션 13.4에는 캐시 가능성에 대한 이러한 기본값이 요약되어 있습니다. 다음 Cache-Control 응답 지시문을 사용하면 원본 서버가 응답의 기본 캐시 가능성을 재정의할 수 있습니다.

공공의

- 일반적으로 캐시할 수 없거나 비공유 캐시 내에서만 캐시할 수 있는 경우에도 응답이 모든 캐시에 의해 캐시될 수 있음을 나타냅니다. \(자세한 내용은 승인, 섹션 14.8을 참조하세요.\)\(MAY\)

사적인

- 응답 메시지의 전부 또는 일부가 단일 사용자를 위한 것이며 공유 캐시에 의해 캐시되어서는 안 된다는 것을 나타냅니다. 이를 통해 원본 서버는 특정 부분이\(MUST NOT\)

- 응답은 한 명의 사용자만을 위한 것이며 다른 사용자의 요청에 대한 유효한 응답이 아닙니다. 개인\(비공유\) 캐시는 응답을 캐시할 수 있습니다.\(MAY\)

- 참고: 비공개라는 단어의 사용은 응답이 캐시될 수 있는 위치만 제어하며 메시지 내용의 개인정보 보호를 보장할 수는 없습니다.

캐시 없음

- no-cache 지시문이 field-name을 지정하지 않으면 캐시는 원서버와의 성공적인 재검증 없이 후속 요청을 만족시키기 위해 응답을 사용해서는 안 됩니다. 이를 통해 원본 서버는 클라이언트 요청에 대해 오래된 응답을 반환하도록 구성된 캐시에 의한 캐싱도 방지할 수 있습니다.\(MUST NOT\)

- no-cache 지시문이 하나 이상의 field-name을 지정하는 경우 캐시는 캐싱에 대한 다른 제한 사항에 따라 후속 요청을 만족시키기 위해 응답을 사용할 수 있습니다. 그러나 지정된 field-name은 원서버와의 성공적인 재검증 없이 후속 요청에 대한 응답으로 전송되어서는 안 됩니다. 이를 통해 원본 서버는 응답에서 특정 헤더 필드의 재사용을 방지하는 동시에 나머지 응답의 캐싱을 허용할 수 있습니다.\(MAY, MUST NOT\)

- 참고: 대부분의 HTTP/1.0 캐시는 이 지시문을 인식하거나 따르지 않습니다.

---
### **14.9.2 What May be Stored by Caches**

무점포

- no-store 지시문의 목적은 중요한 정보\(예: 백업 테이프\)가 실수로 공개되거나 보관되는 것을 방지하는 것입니다. no-store 지시문은 전체 메시지에 적용되며 응답이나 요청으로 전송될 수 있습니다. 요청으로 전송된 경우 캐시는 이 요청이나 이에 대한 응답의 일부를 저장해서는 안 됩니다. 응답으로 전송된 경우 캐시는 이 응답이나 이를 유도한 요청의 어떤 부분도 저장해서는 안 됩니다. 이 지시어는 비공유 캐시와 공유 캐시 모두에 적용됩니다. 이 맥락에서 "저장해서는 안 된다"는 것은 캐시가 의도적으로 정보를 비휘발성 저장소에 저장해서는 안 되며, 정보를 전달한 후 가능한 한 빨리 휘발성 저장소에서 정보를 제거하기 위해 최선을 다해야 한다는 것을 의미합니다.\(MAY, MUST NOT, MUST NOT, MUST NOT\)

- 이 지시문이 응답과 연결되어 있는 경우에도 사용자는 해당 응답을 캐싱 시스템 외부에 명시적으로 저장할 수 있습니다\(예: "다른 이름으로 저장" 대화 상자 사용\). 히스토리 버퍼는 정상적인 작업의 일부로 이러한 응답을 저장할 수 있습니다.\(MAY\)

- 이 지시문의 목적은 캐시 데이터 구조에 대한 예상치 못한 액세스를 통해 우발적으로 정보가 공개되는 것을 우려하는 특정 사용자 및 서비스 작성자의 명시된 요구 사항을 충족하는 것입니다. 이 지시문을 사용하면 경우에 따라 개인 정보 보호가 향상될 수 있지만 어떤 방식으로든 개인 정보 보호를 보장하기 위한 신뢰할 수 있거나 충분한 메커니즘이 아니라는 점에 주의해야 합니다. 특히, 악의적이거나 손상된 캐시는 이 지시문을 인식하거나 따르지 않을 수 있으며 통신 네트워크는 도청에 취약할 수 있습니다.

---
### **14.9.3 Modifications of the Basic Expiration Mechanism**

엔터티의 만료 시간은 Expires 헤더를 사용하여 원서버에 의해 지정될 수 있습니다\(14.21절 참조\). 또는 응답에서 max-age 지시문을 사용하여 지정할 수도 있습니다. 캐시된 응답에 max-age 캐시 제어 지시문이 있는 경우 현재 수명이 해당 리소스에 대한 새 요청 시 지정된 수명 값\(초\)보다 크면 응답은 오래된 것입니다. 응답에 대한 max-age 지시문은 더 제한적인 다른 캐시 지시문이 존재하지 않는 한 응답이 캐시 가능함\(예: "공개"\)을 의미합니다.\(MAY, MAY\)

응답에 Expires 헤더와 max-age 지시문이 모두 포함된 경우 Expires 헤더가 더 제한적이라 하더라도 max-age 지시문은 Expires 헤더를 재정의합니다. 이 규칙을 사용하면 원본 서버는 주어진 응답에 대해 HTTP/1.0 캐시보다 HTTP/1.1\(또는 그 이상\) 캐시에 더 긴 만료 시간을 제공할 수 있습니다. 이는 동기화되지 않은 시계로 인해 특정 HTTP/1.0 캐시가 기간이나 만료 시간을 부적절하게 계산하는 경우 유용할 수 있습니다.

많은 HTTP/1.0 캐시 구현에서는 응답 날짜 값보다 작거나 같은 Expires 값을 Cache-Control 응답 지시문 "no-cache"와 동일한 것으로 처리합니다. HTTP/1.1 캐시가 그러한 응답을 수신하고 응답에 Cache-Control 헤더 필드가 포함되어 있지 않은 경우 HTTP/1.0 서버와의 호환성을 유지하기 위해 응답을 캐시할 수 없는 것으로 간주해야 합니다.\(SHOULD\)

- 참고: 원서버는 해당 기능을 이해하지 못하는 이전 캐시를 포함하는 네트워크에서 "private" 지시문과 같은 상대적으로 새로운 HTTP 캐시 제어 기능을 사용하기를 원할 수 있습니다. 원본 서버는 값이 Date 값보다 작거나 같은 Expires 필드와 새로운 기능을 결합해야 합니다. 이렇게 하면 이전 캐시가 응답을 부적절하게 캐싱하는 것을 방지할 수 있습니다.

s-최대

- 응답에 s-maxage 지시어가 포함된 경우 공유 캐시\(개인 캐시는 아님\)의 경우 이 지시어에 지정된 최대 수명이 max-age 지시어 또는 Expires 헤더에 지정된 최대 수명보다 우선합니다. s-maxage 지시어는 또한 Proxy-revalidate 지시어\(14.9.4절 참조\)의 의미를 암시합니다. 즉, 공유 캐시는 먼저 항목을 재검증하지 않고 후속 요청에 응답하기 위해 항목이 오래 된 후에 해당 항목을 사용해서는 안 됩니다. 원본 서버. s-maxage 지시어는 개인 캐시에 의해 항상 무시됩니다.

이 사양을 준수하지 않는 대부분의 이전 캐시는 캐시 제어 지시문을 구현하지 않습니다. HTTP/1.1 호환 캐시에 의한 캐싱을 제한하지만 방지하지는 않는 캐시 제어 지시문을 사용하려는 원서버는 max-age 지시문이 Expires 헤더를 무시한다는 요구 사항과 HTTP 이전의 사실을 활용할 수 있습니다. /1.1 호환 캐시는 max-age 지시문을 준수하지 않습니다.\(MAY\)

다른 지시문을 사용하면 사용자 에이전트가 기본 만료 메커니즘을 수정할 수 있습니다. 요청 시 다음 지시문을 지정할 수 있습니다.\(MAY\)

최대 연령

- 클라이언트가 지정된 시간\(초\)보다 크지 않은 응답을 수락할 의사가 있음을 나타냅니다. max-stale 지시문도 포함되지 않는 한 클라이언트는 오래된 응답을 기꺼이 받아들이지 않습니다.

최소한의 신선함

- 클라이언트가 신선도 수명이 현재 수명에 지정된 시간\(초\)을 더한 것 이상인 응답을 수락할 의사가 있음을 나타냅니다. 즉, 클라이언트는 최소한 지정된 시간\(초\) 동안 여전히 신선한 응답을 원합니다.

최대 부실

- 클라이언트가 만료 시간을 초과한 응답을 수락할 의사가 있음을 나타냅니다. max-stale에 값이 할당되면 클라이언트는 만료 시간을 지정된 초 수만큼 초과하지 않은 응답을 기꺼이 수락합니다. max-stale에 값이 할당되지 않으면 클라이언트는 모든 연령의 오래된 응답을 기꺼이 받아들입니다.

요청에 대한 max-stale 지시문으로 인해 또는 캐시가 응답 만료 시간을 재정의하도록 구성되었기 때문에 캐시가 오래된 응답을 반환하는 경우 캐시는 경고 110을 사용하여 오래된 응답에 경고 헤더를 첨부해야 합니다. \(응답이 오래되었습니다.\)\(MUST\)

유효성 검사 없이 오래된 응답을 반환하도록 캐시를 구성할 수 있지만 이는 캐시 유효성 검사와 관련된 "MUST" 수준 요구 사항\(예: "must-revalidate" 캐시 제어 지시문\)과 충돌하지 않는 경우에만 가능합니다.\(MUST\)

새 요청과 캐시된 항목에 모두 "max-age" 지시문이 포함된 경우 해당 요청에 대해 캐시된 항목의 최신성을 결정하는 데 두 값 중 더 작은 값이 사용됩니다.

---
### **14.9.4 Cache Revalidation and Reload Controls**

때때로 사용자 에이전트는 캐시가 원서버와 함께 캐시 항목을 재검증하거나\(원서버 경로에 있는 다음 캐시뿐만 아니라\) 원서버에서 캐시 항목을 다시 로드하도록 요구하거나 주장해야 할 수도 있습니다. 캐시 또는 원본 서버가 캐시된 응답의 만료 시간을 과대평가한 경우 엔드투엔드 재검증이 필요할 수 있습니다. 어떤 이유로 캐시 항목이 손상된 경우 엔드투엔드 다시 로드가 필요할 수 있습니다.

```text
   End-to-end revalidation may be requested either when the client does
   not have its own local cached copy, in which case we call it
   "unspecified end-to-end revalidation", or when the client does have a
   local cached copy, in which case we call it "specific end-to-end
   revalidation."
```

클라이언트는 Cache-Control 요청 지시문을 사용하여 다음 세 가지 종류의 작업을 지정할 수 있습니다.

엔드 투 엔드 재로드

- 요청에는 "no-cache" 캐시 제어 지시문이 포함되어 있거나 HTTP/1.0 클라이언트와의 호환성을 위해 "Pragma: no-cache"가 포함되어 있습니다. 요청의 no-cache 지시문에 필드 이름을 포함하면 안 됩니다. 서버는 그러한 요청에 응답할 때 캐시된 복사본을 사용해서는 안 됩니다.\(MUST NOT, MUST NOT\)

특정 엔드투엔드 재검증

- 요청에는 "max-age=0" 캐시 제어 지시문이 포함되어 있습니다. 이 지시어는 원본 서버로의 경로를 따라 각 캐시가 다음 캐시나 서버에서 자체 항목을 재검증하도록 강제합니다. 초기 요청에는 클라이언트의 현재 유효성 검사기와 함께 캐시 유효성 검사 조건이 포함됩니다.

지정되지 않은 엔드투엔드 재검증

- 요청에는 "max-age=0" 캐시 제어 지시문이 포함되어 있습니다. 이 지시문은 원본 서버로의 경로를 따라 각 캐시가 다음 캐시나 서버에서 자체 항목을 재검증하도록 강제합니다. 초기 요청에는 캐시 유효성 검사가 포함되지 않습니다.

- 조건부; 이 자원에 대한 캐시 항목을 보유하는 경로의 첫 번째 캐시\(있는 경우\)에는 현재 유효성 검사기와 함께 캐시 유효성 검사 조건이 포함됩니다.

최대 연령

- 중간 캐시가 max-age=0 지시문을 통해 자체 캐시 항목을 재검증하도록 강제되고 클라이언트가 요청에 자체 유효성 검사기를 제공한 경우 제공된 유효성 검사기는 현재 저장된 유효성 검사기와 다를 수 있습니다. 캐시 항목. 이 경우 캐시는 의미 투명성에 영향을 주지 않고 자체 요청을 할 때 두 유효성 검사기를 사용할 수 있습니다.\(MAY\)

- 단, 검증인의 선택에 따라 성능에 영향을 미칠 수 있습니다. 가장 좋은 접근 방식은 중간 캐시가 요청 시 자체 유효성 검사기를 사용하는 것입니다. 서버가 304\(수정되지 않음\)로 응답하면 캐시는 이제 검증된 복사본을 200\(OK\) 응답으로 클라이언트에 반환할 수 있습니다. 그러나 서버가 새로운 엔터티 및 캐시 유효성 검사기로 응답하는 경우 중간 캐시는 강력한 비교 기능을 사용하여 반환된 유효성 검사기와 클라이언트 요청에 제공된 유효성 검사기를 비교할 수 있습니다. 클라이언트의 유효성 검사기가 원본 서버의 유효성 검사기와 같으면 중간 캐시는 단순히 304\(수정되지 않음\)를 반환합니다. 그렇지 않으면 200\(OK\) 응답으로 새 엔터티를 반환합니다.

- 요청에 no-cache 지시어가 포함된 경우 min-fresh, max-stale 또는 max-age를 포함해서는 안 됩니다.\(SHOULD NOT\)

캐시된 경우에만

- 네트워크 연결이 매우 좋지 않은 경우와 같은 경우에 클라이언트는 캐시가 현재 저장된 응답만 반환하고 원본 서버로 다시 로드하거나 재검증하지 않기를 원할 수 있습니다. 이를 위해 클라이언트는 요청에 only-if-cached 지시문을 포함할 수 있습니다. 이 지시문을 수신하면 캐시는 요청의 다른 제약 조건과 일치하는 캐시된 항목을 사용하여 응답하거나 504\(Gateway Timeout\) 상태로 응답해야 합니다. 그러나 캐시 그룹이 내부 연결이 양호한 통합 시스템으로 운영되는 경우 그러한 요청은 해당 캐시 그룹 내에서 전달될 수 있습니다.\(SHOULD, MAY\)

재검증 필수

- 캐시는 서버의 지정된 만료 시간을 무시하도록 구성될 수 있고 클라이언트 요청에는 max-stale 지시문\(유사한 효과가 있음\)이 포함될 수 있으므로 프로토콜에는 원서버가 캐시의 재검증을 요구하는 메커니즘도 포함되어 있습니다. 이후 사용 시 캐시 항목. must-revalidate 지시어가 캐시에 의해 수신된 응답에 존재할 때, 해당 캐시는 항목이 오래되어 응답하기 위해 해당 항목을 사용해서는 안 됩니다.\(MAY, MUST NOT\)

- 원본 서버에서 먼저 재검증하지 않고 후속 요청을 합니다. \(즉, 원본 서버의 Expires 또는 max-age 값에만 기반하여 캐시된 응답이 오래된 경우 캐시는 매번 엔드 투 엔드 재검증을 수행해야 합니다.\)\(MUST\)

- 특정 프로토콜 기능에 대한 안정적인 작동을 지원하려면 must-revalidate 지시어가 필요합니다. 모든 상황에서 HTTP/1.1 캐시는 must-revalidate 지시어를 준수해야 합니다. 특히 캐시가 어떤 이유로든 원본 서버에 도달할 수 없는 경우 504\(Gateway Timeout\) 응답을 생성해야 합니다.\(MUST\)

- 서버는 엔터티에 대한 요청을 재검증하지 못하면 자동으로 실행되지 않는 금융 거래와 같이 잘못된 작업이 발생할 수 있는 경우에만 must-revalidate 지시문을 보내야 합니다. 수신자는 이 지시문을 위반하는 자동화된 조치를 취해서는 안 되며, 재검증이 실패하는 경우 엔터티의 검증되지 않은 복사본을 자동으로 제공해서는 안 됩니다.\(SHOULD, MUST NOT\)

- 권장되지는 않지만 심각한 연결 제약 하에서 작동하는 사용자 에이전트는 이 지시어를 위반할 수 있지만, 그렇다면 검증되지 않은 응답이 제공되었음을 사용자에게 명시적으로 경고해야 합니다. 검증되지 않은 각 액세스에 대해 경고를 제공해야 하며 명시적인 사용자 확인을 요구해야 합니다\(SHOULD\).\(MUST, MUST\)

프록시 재검증

- Proxy-revalidate 지시어는 비공유 사용자 에이전트 캐시에 적용되지 않는다는 점을 제외하고 must-revalidate 지시어와 동일한 의미를 갖습니다. 인증된 요청에 대한 응답에서 사용자의 캐시가 응답을 저장하고 나중에 재검증할 필요 없이 응답을 반환하도록 허용하는 동시에\(해당 사용자가 이미 한 번 인증했기 때문에\) 많은 사용자에게 서비스를 제공하는 프록시를 요구하는 데 사용할 수 있습니다. 매번 재검증합니다\(각 사용자가 인증되었는지 확인하기 위해\). 이러한 인증된 응답에는 캐시를 허용하기 위해 공개 캐시 제어 지시문도 필요합니다.

---
### **14.9.5 No-Transform Directive**

변환 없음

- 중간 캐시\(프록시\) 구현자는 특정 엔터티 본문의 미디어 유형을 변환하는 것이 유용하다는 것을 알았습니다. 예를 들어, 투명하지 않은 프록시는 캐시 공간을 절약하거나 느린 링크의 트래픽 양을 줄이기 위해 이미지 형식 간에 변환할 수 있습니다.

그러나 다음과 같은 경우 심각한 운영상의 문제가 발생합니다.

- 변환은 특정 종류의 응용 프로그램을 위한 엔터티 본문에 적용됩니다. 예를 들어 의료용 애플리케이션

- 이미징, 과학적 데이터 분석 및 엔드투엔드 인증을 사용하는 것 모두는 원래 엔터티 본문과 비트 단위로 동일한 엔터티 본문을 수신하는 데 달려 있습니다.

- 따라서 메시지에 no-transform 지시문이 포함된 경우 중간 캐시 또는 프록시는 섹션 13.5.2에 나열된 헤더를 no-transform 지시문의 대상으로 변경해서는 안 됩니다. 이는 캐시나 프록시가 엔터티 본문 자체의 값을 포함하여 이러한 헤더에 의해 지정된 엔터티 본문의 모든 측면을 변경해서는 안 된다는 것을 의미합니다.\(MUST NOT, MUST NOT\)

---
### **14.9.6 Cache Control Extensions**

Cache-Control 헤더 필드는 각각 선택적으로 할당된 값이 있는 하나 이상의 캐시 확장 토큰을 사용하여 확장될 수 있습니다. 정보 확장\(캐시 동작의 변경이 필요하지 않은 확장\)은 다른 지시문의 의미를 변경하지 않고 추가될 수 있습니다. 동작 확장은 기존 캐시 지시어 기반에 대한 수정자 역할을 하여 작동하도록 설계되었습니다. 새 지시문과 표준 지시문이 모두 제공되므로 새 지시문을 이해하지 못하는 응용 프로그램은 기본적으로 표준 지시문에 지정된 동작을 수행하고 새 지시문을 이해하는 응용 프로그램은 이를 표준과 관련된 요구 사항을 수정하는 것으로 인식합니다. 지령. 이러한 방식으로 기본 프로토콜을 변경하지 않고도 캐시 제어 지시문을 확장할 수 있습니다.\(MAY\)

이 확장 메커니즘은 기본 HTTP 버전에 대해 정의된 모든 캐시 제어 지시문을 따르고 특정 확장을 따르며 이해하지 못하는 모든 지시문을 무시하는 HTTP 캐시에 의존합니다.

예를 들어, private 지시어에 대한 수정자 역할을 하는 Community라는 가상의 새로운 응답 지시어를 생각해 보세요. 우리는 이 새로운 지시문을 정의하여 비공유 캐시 외에도 해당 값에 이름이 지정된 커뮤니티 구성원만이 공유하는 캐시가 응답을 캐시할 수 있음을 의미합니다. UCI 커뮤니티가 공유 캐시에서 비공개 응답을 사용하도록 허용하려는 원본 서버는 다음을 포함하여 그렇게 할 수 있습니다.

```text
       Cache-Control: private, community="UCI"
```

이 헤더 필드를 보는 캐시는 캐시가 커뮤니티 캐시 확장을 이해하지 못하더라도 개인 지시문도 보고 이해하여 기본적으로 안전한 동작을 수행하므로 올바르게 작동합니다.

인식할 수 없는 캐시 지시문은 무시해야 합니다. HTTP/1.1 캐시에서 인식되지 않을 가능성이 있는 모든 캐시 지시문은 표준 지시문\(또는 응답의 기본 캐시 가능성\)과 결합되어 캐시가 확장을 이해하지 못하는 경우에도 캐시 동작이 최소한으로 올바르게 유지된다고 가정합니다. 에스\).\(MUST\)

---
## **14.10 Connection**

연결 일반 헤더 필드를 사용하면 발신자가 해당 특정 연결에 대해 원하는 옵션을 지정할 수 있으며 추가 연결을 통해 프록시에 의해 전달되어서는 안 됩니다.\(MUST NOT\)

Connection 헤더에는 다음과 같은 문법이 있습니다.

```text
       Connection = "Connection" ":" 1#(connection-token)
       connection-token  = token
```

HTTP/1.1 프록시는 메시지가 전달되기 전에 연결 헤더 필드를 구문 분석해야 하며, 이 필드의 각 연결 토큰에 대해 연결 토큰과 동일한 이름을 가진 메시지에서 헤더 필드를 제거해야 합니다. 연결 옵션은 해당 추가 헤더 필드가 아닌 연결 헤더 필드에 연결 토큰이 있음으로 표시됩니다. 해당 연결 옵션과 관련된 매개변수가 없으면 추가 헤더 필드가 전송되지 않을 수 있기 때문입니다.\(MUST\)

연결 헤더에 나열된 메시지 헤더는 Cache-Control과 같은 종단 간 헤더를 포함해서는 안 됩니다.\(MUST NOT\)

HTTP/1.1은 응답이 완료된 후 연결이 닫힐 것이라는 신호를 보내는 사람에 대한 "닫기" 연결 옵션을 정의합니다. 예를 들어,

```text
       Connection: close
```

요청 또는 응답 헤더 필드는 현재 요청/응답이 완료된 후 연결이 '지속적'\(섹션 8.1\)으로 간주되어서는 안 된다는 것을 나타냅니다.\(SHOULD NOT\)

지속적인 연결을 지원하지 않는 HTTP/1.1 애플리케이션은 모든 메시지에 "close" 연결 옵션을 포함해야 합니다.\(MUST\)

연결 헤더를 포함하는 HTTP/1.0\(또는 하위 버전\) 메시지를 수신하는 시스템은 이 필드의 각 연결 토큰에 대해 연결과 동일한 이름을 가진 메시지에서 헤더 필드를 제거하고 무시해야 합니다. 토큰. 이는 HTTP/1.1 이전 프록시에 의해 헤더 필드가 잘못 전달되는 것을 방지합니다. 섹션 19.6.2를 참조하십시오.\(MUST\)

---
## **14.11 Content-Encoding**

Content-Encoding 엔터티 헤더 필드는 미디어 유형에 대한 수정자로 사용됩니다. 해당 값은 Entity-Body에 어떤 추가 콘텐츠 코딩이 적용되었는지, 따라서 Content-Type 헤더 필드에서 참조하는 미디어 유형을 얻기 위해 어떤 디코딩 메커니즘을 적용해야 하는지를 나타냅니다. Content-Encoding은 기본 미디어 유형의 ID를 잃지 않고 문서를 압축하는 데 주로 사용됩니다.

```text
       Content-Encoding  = "Content-Encoding" ":" 1#content-coding
```

콘텐츠 코딩은 섹션 3.5에 정의되어 있습니다. 그 사용 예는 다음과 같습니다.

```text
       Content-Encoding: gzip
```

콘텐츠 코딩은 요청-URI로 식별되는 엔터티의 특성입니다. 일반적으로 엔터티 본문은 이 인코딩으로 저장되며 렌더링 또는 유사한 사용 전에만 디코딩됩니다. 그러나 "no-transform" 캐시 제어 지시문이 메시지에 존재하지 않는 한, 불투명 프록시는 수신자가 새로운 코딩을 수용할 수 있는 것으로 알려진 경우 콘텐츠 코딩을 수정할 수 있습니다.\(MAY\)

엔터티의 콘텐츠 코딩이 "ID"가 아닌 경우 응답에는 사용된 비식별 콘텐츠 코딩을 나열하는 Content-Encoding 엔터티 헤더\(섹션 14.11\)가 포함되어야 합니다.\(MUST\)

요청 메시지에 포함된 엔터티의 콘텐츠 코딩이 원서버에서 허용되지 않는 경우 서버는 상태 코드 415\(지원되지 않는 미디어 유형\)로 응답해야 합니다.\(SHOULD\)

여러 인코딩이 엔터티에 적용된 경우 콘텐츠 코딩은 적용된 순서대로 나열되어야 합니다. 인코딩 매개변수에 대한 추가 정보는 이 사양에서 정의되지 않은 다른 엔터티 헤더 필드에 의해 제공될 수 있습니다.\(MUST, MAY\)

---
## **14.12 Content-Language**

Content-Language 엔터티 헤더 필드는 포함된 엔터티에 대한 대상 독자의 자연 언어를 설명합니다. 이는 엔터티 본문 내에서 사용되는 모든 언어와 동일하지 않을 수 있습니다.

```text
       Content-Language  = "Content-Language" ":" 1#language-tag
```

언어 태그는 섹션 3.10에 정의되어 있습니다. Content-Language의 주요 목적은 사용자가 자신이 선호하는 언어에 따라 엔터티를 식별하고 구별할 수 있도록 하는 것입니다. 따라서 본문 내용이 덴마크어를 읽을 수 있는 청중만을 대상으로 하는 경우 해당 필드는 다음과 같습니다.

```text
       Content-Language: da
```

Content-Language가 지정되지 않은 경우 기본값은 콘텐츠가 모든 언어 사용자를 대상으로 하는 것입니다. 이는 보낸 사람이 해당 내용을 자연어에만 적용되는 것으로 간주하지 않거나 해당 내용이 어떤 언어에 해당하는지 알 수 없음을 의미할 수 있습니다.

여러 청중을 대상으로 하는 콘텐츠의 경우 여러 언어가 나열될 수 있습니다. 예를 들어, 원본 마오리어와 영어 버전으로 동시에 제시된 "와이탕이 조약"의 번역은 다음을 요구합니다.\(MAY\)

```text
       Content-Language: mi, en
```

그러나 엔터티 내에 여러 언어가 존재한다고 해서 해당 엔터티가 여러 언어 사용자를 대상으로 한다는 의미는 아닙니다. 예를 들어 "라틴어 첫 수업"과 같은 초급 언어 입문서는 영어를 구사하는 청중이 사용하도록 의도된 것이 분명합니다. 이 경우 Content-Language에는 "en"만 포함됩니다.

Content-Language는 모든 미디어 유형에 적용될 수 있으며 텍스트 문서에만 국한되지 않습니다.\(MAY\)

---
## **14.13 Content-Length**

Content-Length Entity-Header 필드는 수신자에게 전송된 Entity-Body의 크기를 OCTET의 십진수로 표시하거나, HEAD 방법의 경우 전송되었을 Entity-Body의 크기를 나타냅니다. 요청은 GET이었습니다.

```text
       Content-Length    = "Content-Length" ":" 1*DIGIT
```

예는 다음과 같습니다

```text
       Content-Length: 3495
```

애플리케이션은 섹션 4.4의 규칙에 의해 금지되지 않는 한 이 필드를 사용하여 메시지 본문의 전송 길이를 나타내야 합니다.\(SHOULD\)

0보다 크거나 같은 모든 Content-Length는 유효한 값입니다. 4.4절에서는 Content-Length가 제공되지 않은 경우 메시지 본문의 길이를 결정하는 방법을 설명합니다.

이 필드의 의미는 "message/external-body" 콘텐츠 유형 내에서 사용되는 선택적 필드인 MIME의 해당 정의와 크게 다릅니다. HTTP에서는 섹션 4.4의 규칙에 의해 금지되지 않는 한 메시지 길이가 전송되기 전에 결정될 수 있을 때마다 전송되어야 합니다.\(SHOULD\)

---
## **14.14 Content-Location**

Content-Location 엔터티 헤더 필드는 요청된 리소스의 URI와 별도의 위치에서 해당 엔터티에 액세스할 수 있는 경우 메시지에 포함된 엔터티에 대한 리소스 위치를 제공하는 데 사용될 수 있습니다. 서버는 응답 엔터티에 해당하는 변형에 대한 Content-Location을 제공해야 합니다. 특히 리소스에 연결된 여러 엔터티가 있고 해당 엔터티가 실제로 개별적으로 액세스할 수 있는 별도의 위치를 ​​갖고 있는 경우 서버는 반환되는 특정 변형에 대한 Content-Location을 제공해야 합니다.\(MAY, SHOULD\)

```text
       Content-Location = "Content-Location" ":"
                         ( absoluteURI | relativeURI )
```

Content-Location 값은 엔터티의 기본 URI도 정의합니다.

Content-Location 값은 원래 요청된 URI를 대체하지 않습니다. 이는 요청 당시 이 특정 엔터티에 해당하는 리소스의 위치에 대한 설명일 뿐입니다. 특정 엔터티의 소스를 식별하려는 경우 향후 요청은 Content-Location URI를 요청-URI로 지정할 수 있습니다.\(MAY\)

캐시는 검색에 사용된 URI와 다른 Content-Location을 가진 엔터티가 해당 Content-Location URI에 대한 이후 요청에 응답하는 데 사용될 수 있다고 가정할 수 없습니다. 그러나 섹션 13.6에 설명된 대로 Content-Location을 사용하여 단일 요청 리소스에서 검색된 여러 엔터티를 구별할 수 있습니다.

Content-Location이 상대 URI인 경우 상대 URI는 Request-URI를 기준으로 해석됩니다.

PUT 또는 POST 요청에서 Content-Location 헤더의 의미는 정의되지 않습니다. 이러한 경우 서버는 이를 무시할 수 있습니다.

---
## **14.15 Content-MD5**

RFC 1864\[23\]에 정의된 Content-MD5 Entity-Header 필드는 Entity-Body의 종단 간 메시지 무결성 검사\(MIC\)를 제공할 목적으로 Entity-Body의 MD5 다이제스트입니다. \(참고: MIC는 전송 중인 개체 본체의 실수로 인한 수정을 탐지하는 데 유용하지만 악의적인 공격에 대한 증거는 아닙니다.\)

```text
        Content-MD5   = "Content-MD5" ":" md5-digest
        md5-digest   = <base64 of 128 bit MD5 digest as per RFC 1864>
```

Content-MD5 헤더 필드는 엔터티 본문의 무결성 검사 기능을 위해 원서버 또는 클라이언트에 의해 생성될 수 있습니다. 원본 서버 또는 클라이언트만 Content-MD5 헤더 필드를 생성할 수 있습니다. 프록시와 게이트웨이는 이를 생성해서는 안 됩니다. 이는 종단 간 무결성 검사로서의 가치를 상실하기 때문입니다. 게이트웨이와 프록시를 포함한 Entity-Body의 수신자는 이 헤더 필드의 다이제스트 값이 수신된 Entity-Body의 다이제스트 값과 일치하는지 확인할 수 있습니다.\(MAY, MUST NOT, MAY\)

MD5 다이제스트는 적용된 모든 콘텐츠 코딩을 포함하지만 메시지 본문에 적용된 전송 인코딩은 포함하지 않는 엔터티 본문의 콘텐츠를 기반으로 계산됩니다. 메시지가 전송 인코딩으로 수신된 경우 수신된 엔터티에 대해 Content-MD5 값을 확인하기 전에 해당 인코딩을 제거해야 합니다.\(MUST\)

이로 인해 다이제스트는 전송 인코딩이 적용되지 않은 경우 전송되는 순서대로 엔터티 본문의 옥텟에서 정확하게 계산됩니다.

HTTP는 MIME 복합 미디어 유형\(예: multipart/\* 및 message/rfc822\)에 대해 다이제스트를 계산할 수 있도록 RFC 1864를 확장하지만 이전 단락에 정의된 대로 다이제스트가 계산되는 방식은 변경되지 않습니다.

이로 인해 몇 가지 결과가 발생합니다. 복합 유형의 엔터티 본문에는 각각 자체 MIME 및 HTTP 헤더\(Content-MD5, Content-Transfer-Encoding 및 Content-Encoding 헤더 포함\)가 있는 많은 본문 부분이 포함될 수 있습니다. 본문 부분에 Content-Transfer-Encoding 또는 Content-Encoding 헤더가 있는 경우 본문 부분의 콘텐츠에 인코딩이 적용되었다고 가정하고 본문 부분은 그대로 Content-MD5 다이제스트에 포함됩니다. -- 즉, 신청 후. Transfer-Encoding 헤더 필드는 본문 부분 내에서 허용되지 않습니다.\(MAY\)

모든 줄바꿈을 CRLF로 변환하는 것은 다이제스트를 계산하거나 확인하기 전에 수행되어서는 안 됩니다. 실제로 전송된 텍스트에 사용된 줄바꿈 규칙은 다이제스트를 계산할 때 변경되지 않은 상태로 남아 있어야 합니다.\(MUST NOT\)

- 참고: Content-MD5의 정의는 MIME 엔터티 본문에 대한 RFC 1864의 HTTP 정의와 정확히 동일하지만 HTTP 엔터티 본문에 대한 Content-MD5 적용과 MIME 엔터티에 대한 적용이 여러 면에서 다릅니다. - 시체. 하나는 MIME과 달리 HTTP가 Content-Transfer-Encoding을 사용하지 않고 Transfer-Encoding 및 Content-Encoding을 사용한다는 것입니다. 또 다른 점은 HTTP가 MIME보다 바이너리 콘텐츠 유형을 더 자주 사용하므로 이러한 경우 다이제스트를 계산하는 데 사용되는 바이트 순서가 해당 유형에 대해 정의된 전송 바이트 순서라는 점에 주목할 가치가 있습니다. 마지막으로 HTTP는 CRLF를 사용하는 표준 형식뿐만 아니라 여러 줄 바꿈 규칙을 사용하여 텍스트 유형의 전송을 허용합니다.

---
## **14.16 Content-Range**

Content-Range 엔터티 헤더는 전체 엔터티 본문에서 부분 본문이 적용되어야 하는 위치를 지정하기 위해 부분 엔터티 본문과 함께 전송됩니다. 범위 단위는 섹션 3.12에 정의되어 있습니다.

```text
       Content-Range = "Content-Range" ":" content-range-spec

       content-range-spec      = byte-content-range-spec
       byte-content-range-spec = bytes-unit SP
                                 byte-range-resp-spec "/"
                                 ( instance-length | "*" )

       byte-range-resp-spec = (first-byte-pos "-" last-byte-pos)
                                      | "*"
       instance-length           = 1*DIGIT
```

헤더는 길이를 알 수 없거나 결정하기 어려운 경우를 제외하고 전체 엔터티 본문의 전체 길이를 나타내야 합니다. 별표 "\*" 문자는 응답이 생성된 시점에 인스턴스 길이를 알 수 없음을 의미합니다.\(SHOULD\)

byte-ranges-specifier 값\(섹션 14.35.1 참조\)과 달리 byte-range-resp-spec은 하나의 범위만 지정해야 하며 범위의 첫 번째 바이트와 마지막 바이트 모두에 대한 절대 바이트 위치를 포함해야 합니다.\(MUST\)

마지막 byte-pos 값이 첫 번째-byte-pos 값보다 작거나 인스턴스 길이 값이 마지막-pos 값보다 작거나 같은 byte-range-resp-spec이 있는 byte-content-range-spec byte-pos 값이 잘못되었습니다. 유효하지 않은 byte-content-range-spec의 수신자는 이를 무시하고 이와 함께 전송되는 모든 콘텐츠를 무시해야 합니다.\(MUST\)

상태 코드 416\(요청 범위가 충족되지 않음\)으로 응답을 보내는 서버는 바이트 범위-resp-spec이 "\*"인 Content-Range 필드를 포함해야 합니다. 인스턴스 길이는 현재 길이를 지정합니다.\(SHOULD\)

선택한 리소스. 상태 코드 206\(부분 콘텐츠\)의 응답은 byte-range-resp-spec이 "\*"인 Content-Range 필드를 포함해서는 안 됩니다.\(MUST NOT\)

엔터티에 총 1234바이트가 포함되어 있다고 가정하는 byte-content-range-spec 값의 예:

. 처음 500바이트:

- 바이트 0-499/1234

. 두 번째 500바이트:

- 바이트 500-999/1234

. 처음 500바이트를 제외한 모든 항목:

- 바이트 500-1233/1234

. 마지막 500바이트:

- 바이트 734-1233/1234

HTTP 메시지에 단일 범위의 콘텐츠\(예: 단일 범위에 대한 요청에 대한 응답 또는 구멍 없이 겹치는 범위 집합에 대한 요청\)가 포함된 경우 이 콘텐츠는 Content-Range와 함께 전송됩니다. 헤더 및 실제로 전송된 바이트 수를 표시하는 Content-Length 헤더. 예를 들어,

```text
       HTTP/1.1 206 Partial content
       Date: Wed, 15 Nov 1995 06:25:24 GMT
       Last-Modified: Wed, 15 Nov 1995 04:58:08 GMT
       Content-Range: bytes 21010-47021/47022
       Content-Length: 26012
       Content-Type: image/gif
```

HTTP 메시지에 여러 범위의 콘텐츠\(예: 겹치지 않는 여러 범위에 대한 요청에 대한 응답\)가 포함된 경우 이는 다중 부분 메시지로 전송됩니다. 이 목적으로 사용되는 멀티파트 미디어 유형은 부록 19.2에 정의된 "multipart/byteranges"입니다. 호환성 문제는 부록 19.6.3을 참조하세요.

단일 범위에 대한 요청에 대한 응답은 multipart/byteranges 미디어 유형을 사용하여 전송되어서는 안 됩니다. 결과가 단일 범위인 여러 범위에 대한 요청에 대한 응답은 한 부분으로 구성된 multipart/byteranges 미디어 유형으로 전송될 수 있습니다. multipart/byteranges 메시지를 디코딩할 수 없는 클라이언트는 단일 요청에서 여러 바이트 범위를 요청해서는 안 됩니다.\(MUST NOT, MAY, MUST NOT\)

클라이언트가 하나의 요청으로 여러 바이트 범위를 요청할 때 서버는 요청에 나타난 순서대로 이를 반환해야 합니다.\(SHOULD\)

서버가 구문상 유효하지 않기 때문에 byte-range-spec을 무시하는 경우 서버는 유효하지 않은 Range 헤더 필드가 존재하지 않는 것처럼 요청을 처리해야 합니다. \(일반적으로 이는 전체 엔터티가 포함된 200 응답을 반환한다는 의미입니다.\)\(SHOULD\)

서버가 충족되지 않는 Range 요청 헤더 필드\(즉, 모든 byte-range-spec 값이 더 큰 첫 번째 바이트-pos 값을 갖는 요청\(If- Range 요청 헤더 필드를 포함하는 요청 제외\)을 수신하는 경우 선택한 리소스의 현재 길이보다\) 응답 코드 416\(요청 범위가 만족스럽지 않음\)을 반환해야 합니다\(섹션 10.4.17\).\(SHOULD\)

- 참고: 모든 서버가 이 요청 헤더를 구현하는 것은 아니기 때문에 클라이언트는 충족되지 않는 Range 요청 헤더에 대해 200\(OK\) 응답 대신 416\(요청 범위가 충족되지 않음\) 응답을 보내는 데 서버에 의존할 수 없습니다.

---
## **14.17 Content-Type**

Content-Type Entity-Header 필드는 수신자에게 전송된 Entity-Body의 미디어 유형을 나타내며, HEAD 메소드의 경우 요청이 GET이었다면 전송되었을 미디어 유형을 나타냅니다.

```text
       Content-Type   = "Content-Type" ":" media-type
```

미디어 유형은 섹션 3.7에 정의되어 있습니다. 해당 분야의 예는 다음과 같습니다.

```text
       Content-Type: text/html; charset=ISO-8859-4
```

엔터티의 미디어 유형을 식별하는 방법에 대한 추가 논의는 섹션 7.2.1에 제공됩니다.

---
## **14.18 Date**

Date 일반 헤더 필드는 메시지가 시작된 날짜와 시간을 나타내며 RFC 822의 orig-date와 동일한 의미를 갖습니다. 필드 값은 섹션 3.3.1에 설명된 대로 HTTP 날짜입니다. RFC 1123 \[8\] 날짜 형식으로 전송되어야 합니다.\(MUST\)

```text
       Date  = "Date" ":" HTTP-date
```

예는 다음과 같습니다

```text
       Date: Tue, 15 Nov 1994 08:12:31 GMT
```

원본 서버는 다음 경우를 제외하고 모든 응답에 Date 헤더 필드를 포함해야 합니다.\(MUST\)

- 1. 응답 상태 코드가 100\(계속\) 또는 101\(스위칭 프로토콜\)인 경우 응답에는 서버 옵션에 날짜 헤더 필드가 포함될 수 있습니다.\(MAY\)

- 2. 응답 상태 코드가 서버 오류를 전달하는 경우. 500\(내부 서버 오류\) 또는 503\(서비스를 사용할 수 없음\)이며 유효한 날짜를 생성하는 것이 불편하거나 불가능합니다.

3. 서버에 제공할 수 있는 시계가 없는 경우

- 현재 시간의 합리적인 근사치인 경우 응답에는 날짜 헤더 필드가 포함되어서는 안 됩니다. 이 경우 섹션 14.18.1의 규칙을 따라야 합니다.\(MUST NOT, MUST\)

메시지가 수신자에 의해 캐시되거나 날짜가 필요한 프로토콜을 통해 게이트웨이되는 경우 Date 헤더 필드가 없는 수신 메시지는 수신자에 의해 할당되어야 합니다. 시계가 없는 HTTP 구현은 사용할 때마다 응답을 재검증하지 않고 응답을 캐시해서는 안 됩니다\(MUST NOT\). HTTP 캐시, 특히 공유 캐시는 NTP\[28\]와 같은 메커니즘을 사용하여 시계를 신뢰할 수 있는 외부 표준과 동기화해야 합니다.\(MUST, MUST NOT, SHOULD\)

클라이언트는 PUT 및 POST 요청의 경우처럼 엔터티 본문을 포함하는 메시지에 날짜 헤더 필드만 보내야 하며, 이 경우에도 선택 사항입니다. 시계가 없는 클라이언트는 요청에 Date 헤더 필드를 보내면 안 됩니다.\(SHOULD, MUST NOT\)

Date 헤더에 전송된 HTTP 날짜는 메시지 생성 이후의 날짜와 시간을 나타내서는 안 됩니다. 구현 시 합리적으로 정확한 날짜 및 시간을 생성할 수 있는 수단이 없는 경우를 제외하고는 메시지 생성 날짜 및 시간에 대해 사용 가능한 가장 가까운 근사치를 나타내야 합니다\(SHOULD\). 이론적으로 날짜는 엔터티가 생성되기 직전의 순간을 나타내야 합니다. 실제로 날짜는 메시지 생성 중 의미 값에 영향을 주지 않고 언제든지 생성될 수 있습니다.\(SHOULD NOT, SHOULD\)

---
### **14.18.1 Clockless Origin Server Operation**

일부 원본 서버 구현에는 사용 가능한 시계가 없을 수도 있습니다. 시계가 없는 원서버는 Expires 또는 Last-Modified 값이 신뢰할 수 있는 시계를 가진 시스템이나 사용자에 의해 리소스와 연결되지 않은 한 응답에 할당해서는 안 됩니다. 서버 구성 시간이나 그 이전에 과거인 것으로 알려진 Expires 값을 할당할 수 있습니다\(이는 각 리소스에 대해 별도의 Expires 값을 저장하지 않고 응답의 "사전 만료"를 허용합니다\).\(MUST NOT, MAY\)

---
## **14.19 ETag**

ETag 응답 헤더 필드는 요청된 변형에 대한 엔터티 태그의 현재 값을 제공합니다. 엔터티 태그와 함께 사용되는 헤더는 섹션 14.24, 14.26 및 14.44에 설명되어 있습니다. 엔터티 태그는 동일한 리소스의 다른 엔터티와 비교하는 데 사용될 수 있습니다\(섹션 13.3.3 참조\).\(MAY\)

```text
      ETag = "ETag" ":" entity-tag

   Examples:

      ETag: "xyzzy"
      ETag: W/"xyzzy"
      ETag: ""
```

---
## **14.20 Expect**

Expect 요청 헤더 필드는 클라이언트가 특정 서버 동작을 요구함을 나타내는 데 사용됩니다.

```text
      Expect       =  "Expect" ":" 1#expectation

      expectation  =  "100-continue" | expectation-extension
      expectation-extension =  token [ "=" ( token | quoted-string )
                               *expect-params ]
      expect-params =  ";" token [ "=" ( token | quoted-string ) ]
```

요청의 Expect 필드에 있는 기대 값을 이해하지 못하거나 준수할 수 없는 서버는 적절한 오류 상태로 응답해야 합니다. 기대치를 충족할 수 없는 경우 서버는 417\(예상 실패\) 상태로 응답해야 하며, 요청에 다른 문제가 있는 경우 다른 4xx 상태로 응답해야 합니다.\(MUST, MUST\)

이 헤더 필드는 향후 확장을 허용하는 확장 가능한 구문으로 정의됩니다. 서버가 지원하지 않는 기대 확장을 포함하는 Expect 필드가 포함된 요청을 수신하는 경우 417\(예상 실패\) 상태로 응답해야 합니다.\(MUST\)

기대값 비교는 따옴표가 없는 토큰\(100-continue 토큰 포함\)의 경우 대소문자를 구분하지 않으며, 따옴표 붙은 문자열 기대 확장의 경우 대소문자를 구분합니다.

Expect 메커니즘은 홉별 메커니즘입니다. 즉, HTTP/1.1 프록시는 충족할 수 없을 것으로 예상되는 요청을 수신하는 경우 417\(예상 실패\) 상태를 반환해야 합니다. 그러나 Expect 요청 헤더 자체는 엔드투엔드입니다. 요청이 전달되면 반드시 전달되어야 합니다.\(MUST, MUST\)

많은 이전 HTTP/1.0 및 HTTP/1.1 애플리케이션은 Expect 헤더를 이해하지 못합니다.

100\(계속\) 상태 사용에 대해서는 섹션 8.2.3을 참조하세요.

---
## **14.21 Expires**

Expires 엔터티 헤더 필드는 응답이 오래된 것으로 간주되는 날짜/시간을 제공합니다. 오래된 캐시 항목은 원본 서버\(또는 엔터티의 새로운 복사본이 있는 중간 캐시\)에서 먼저 유효성을 검사하지 않는 한 캐시\(프록시 캐시 또는 사용자 에이전트 캐시\)에 의해 일반적으로 반환되지 않을 수 있습니다. 만료 모델에 대한 자세한 내용은 섹션 13.2를 참조하세요.

Expires 필드가 있다고 해서 원래 리소스가 해당 시점, 이전 또는 이후에 변경되거나 존재하지 않게 된다는 의미는 아닙니다.

형식은 섹션 3.3.1의 HTTP-date에 정의된 절대 날짜 및 시간입니다. RFC 1123 날짜 형식이어야 합니다.\(MUST\)

```text
      Expires = "Expires" ":" HTTP-date
```

그 사용 예는 다음과 같습니다.

```text
      Expires: Thu, 01 Dec 1994 16:00:00 GMT
```

- 참고: 응답에 max-age 지시어\(섹션 14.9.3 참조\)가 있는 Cache-Control 필드가 포함된 경우 해당 지시어가 Expires 필드를 재정의합니다.

HTTP/1.1 클라이언트와 캐시는 특히 "0" 값을 포함하여 과거\(즉, "이미 만료됨"\)와 같은 다른 유효하지 않은 날짜 형식을 처리해야 합니다.\(MUST\)

응답을 "이미 만료됨"으로 표시하기 위해 원서버는 Date 헤더 값과 동일한 Expires 날짜를 보냅니다. \(섹션 13.2.4의 만료 계산 규칙을 ​​참조하세요.\)

응답을 "만료되지 않음"으로 표시하기 위해 원서버는 응답이 전송된 시점으로부터 약 1년 후에 만료 날짜를 보냅니다. HTTP/1.1 서버는 향후 1년 이상의 만료 날짜를 보내서는 안 됩니다.\(SHOULD NOT\)

기본적으로 캐시할 수 없는 응답에 미래 특정 시간의 날짜 값이 있는 Expires 헤더 필드가 존재한다는 것은 Cache-Control 헤더 필드\(섹션 14.9\)에 의해 달리 지정되지 않는 한 응답이 캐시 가능함을 나타냅니다. .

---
## **14.22 From**

From 요청 헤더 필드가 제공되면 요청 사용자 에이전트를 제어하는 ​​인간 사용자의 인터넷 이메일 주소를 포함해야 합니다. 주소는 RFC 1123 \[8\]에 의해 업데이트된 대로 RFC 822 \[9\]의 "사서함"에 정의된 대로 기계에서 사용할 수 있어야 합니다.\(SHOULD, SHOULD\)

```text
       From   = "From" ":" mailbox
```

예는 다음과 같습니다:

```text
       From: webmaster@w3.org
```

이 헤더 필드는 로깅 목적으로 그리고 유효하지 않거나 원치 않는 요청의 소스를 식별하는 수단으로 사용될 수 있습니다. 안전하지 않은 형태의 액세스 보호로 사용해서는 안 됩니다. 이 필드의 해석은 수행된 방법에 대한 책임을 수락하는 지정된 사람을 대신하여 요청이 수행된다는 것입니다. 특히 로봇 에이전트는 수신 측에서 문제가 발생할 경우 로봇 실행 책임자에게 연락할 수 있도록 이 헤더를 포함해야 합니다.\(MAY, SHOULD NOT, SHOULD\)

이 필드의 인터넷 이메일 주소는 요청을 발행한 인터넷 호스트와 별개일 수 있습니다. 예를 들어 요청이 프록시를 통해 전달되면 원래 발급자의 주소를 사용해야 합니다.\(MAY, SHOULD\)

클라이언트는 사용자의 승인 없이 From 헤더 필드를 전송해서는 안 됩니다. 이는 사용자의 개인 정보 보호 이익이나 해당 사이트의 보안 정책과 충돌할 수 있기 때문입니다. 사용자는 요청하기 전에 언제든지 이 필드의 값을 비활성화, 활성화 및 수정할 수 있는 것이 좋습니다.\(SHOULD NOT\)

---
## **14.23 Host**

호스트 요청 헤더 필드는 사용자 또는 참조 리소스\(일반적으로 HTTP URL,

섹션 3.2.2에 설명된 대로\). 호스트 필드 값은 원래 URL에서 제공한 원본 서버 또는 게이트웨이의 명명 권한을 나타내야 합니다. 이를 통해 원본 서버 또는 게이트웨이는 단일 IP 주소의 여러 호스트 이름에 대한 서버의 루트 "/" URL과 같이 내부적으로 모호한 URL을 구별할 수 있습니다.\(MUST\)

```text
       Host = "Host" ":" host [ ":" port ] ; Section 3.2.2
```

뒤에 오는 포트 정보가 없는 "호스트"는 요청된 서비스의 기본 포트를 의미합니다\(예: HTTP URL의 경우 "80"\). 예를 들어 <http://www.w3.org/pub/WWW/\>에 대한 원본 서버의 요청에는 다음이 적절하게 포함됩니다.

```text
       GET /pub/WWW/ HTTP/1.1
       Host: www.w3.org
```

클라이언트는 모든 HTTP/1.1 요청 메시지에 Host 헤더 필드를 포함해야 합니다. 요청된 URI에 요청 중인 서비스에 대한 인터넷 호스트 이름이 포함되어 있지 않으면 Host 헤더 필드에 빈 값을 제공해야 합니다. HTTP/1.1 프록시는 전달하는 모든 요청 메시지에 프록시가 요청하는 서비스를 식별하는 적절한 Host 헤더 필드가 포함되어 있는지 확인해야 합니다. 모든 인터넷 기반 HTTP/1.1 서버는 Host 헤더 필드가 없는 모든 HTTP/1.1 요청 메시지에 대해 400\(잘못된 요청\) 상태 코드로 응답해야 합니다.\(MUST, MUST, MUST, MUST\)

호스트와 관련된 기타 요구 사항은 섹션 5.2 및 19.6.1.1을 참조하세요.

---
## **14.24 If-Match**

If-Match 요청 헤더 필드는 이를 조건부로 만드는 방법과 함께 사용됩니다. 이전에 리소스에서 얻은 하나 이상의 엔터티가 있는 클라이언트는 If-Match 헤더 필드에 관련 엔터티 태그 목록을 포함하여 해당 엔터티 중 하나가 최신인지 확인할 수 있습니다. 엔터티 태그는 섹션 3.11에 정의되어 있습니다. 이 기능의 목적은 최소한의 트랜잭션 오버헤드로 캐시된 정보를 효율적으로 업데이트할 수 있도록 하는 것입니다. 또한 업데이트 요청 시 잘못된 버전의 리소스가 실수로 수정되는 것을 방지하기 위해 사용됩니다. 특별한 경우로 "\*" 값은 리소스의 현재 엔터티와 일치합니다.

```text
       If-Match = "If-Match" ":" ( "*" | 1#entity-tag )
```

엔터티 태그 중 하나라도 해당 리소스에 대한 유사한 GET 요청\(If-Match 헤더 없이\)에 대한 응답으로 반환되었을 엔터티의 엔터티 태그와 일치하거나 "\*"가 제공된 경우

해당 리소스에 대한 현재 엔터티가 존재하는 경우 서버는 If-Match 헤더 필드가 존재하지 않는 것처럼 요청된 방법을 수행할 수 있습니다.\(MAY\)

서버는 If-Match의 엔터티 태그를 비교하기 위해 강력한 비교 기능\(섹션 13.3.3 참조\)을 사용해야 합니다.\(MUST\)

일치하는 엔터티 태그가 없거나 "\*"가 주어지고 현재 엔터티가 존재하지 않는 경우 서버는 요청된 방법을 수행해서는 안 되며 412\(전제 조건 실패\) 응답을 반환해야 합니다. 이 동작은 클라이언트가 PUT와 같은 업데이트 메서드가 클라이언트가 마지막으로 검색한 이후 변경된 리소스를 수정하지 못하도록 하려는 경우에 가장 유용합니다.\(MUST NOT\)

요청이 If-Match 헤더 필드 없이 2xx 또는 412 상태 이외의 결과를 초래한다면 If-Match 헤더는 무시되어야 합니다.\(MUST\)

"If-Match: \*"의 의미는 원서버\(또는 Vary 메커니즘을 사용하는 캐시, 섹션 14.44 참조\)에 의해 선택된 표현이 존재하는 경우 메서드를 수행해야 하며, 다음과 같은 경우에는 수행해서는 안 된다는 것입니다. 대표성이 존재하지 않습니다.\(MUST NOT\)

리소스\(예: PUT\)를 업데이트하려는 요청에는 If-Match 값\(단일 엔터티 태그\)에 해당하는 엔터티가 더 이상 존재하지 않는 경우 요청 방법을 적용해서는 안 된다는 것을 알리기 위해 If-Match 헤더 필드가 포함될 수 있습니다. 해당 리소스의 표현입니다. 이를 통해 사용자는 리소스가 자신도 모르게 변경된 경우 요청이 성공하지 않기를 원한다는 것을 나타낼 수 있습니다. 예:\(MUST NOT\)

```text
       If-Match: "xyzzy"
       If-Match: "xyzzy", "r2d2xxxx", "c3piozzzz"
       If-Match: *
```

If-Match 헤더 필드와 If-None-Match 또는 If-Modified-Since 헤더 필드가 모두 있는 요청의 결과는 이 사양에 의해 정의되지 않습니다.

---
## **14.25 If-Modified-Since**

If-Modified-Since 요청 헤더 필드는 조건부로 만드는 방법과 함께 사용됩니다. 요청된 변형이 이 필드에 지정된 시간 이후 수정되지 않은 경우 엔터티는 서버에서 반환되지 않습니다. 대신 메시지 본문 없이 304\(수정되지 않음\) 응답이 반환됩니다.

```text
       If-Modified-Since = "If-Modified-Since" ":" HTTP-date
```

필드의 예는 다음과 같습니다.

```text
       If-Modified-Since: Sat, 29 Oct 1994 19:43:31 GMT
```

If-Modified-Since 헤더가 있고 Range 헤더가 없는 GET 방법은 식별된 엔터티가 If-Modified-Since 헤더에 지정된 날짜 이후 수정된 경우에만 전송되도록 요청합니다. 이를 결정하는 알고리즘에는 다음과 같은 경우가 포함됩니다.

- a\) 요청이 일반적으로 200\(OK\) 상태 이외의 결과를 초래하거나 전달된 If-Modified-Since 날짜가 유효하지 않은 경우 응답은 일반 GET의 경우와 정확히 동일합니다. 서버의 현재 시간보다 이후의 날짜는 유효하지 않습니다.

- b\) If-Modified-Since 날짜 이후 변형이 수정된 경우 응답은 일반 GET의 경우와 정확히 동일합니다.

c\) 유효한 If- 이후 변형이 수정되지 않은 경우

- 수정됨 - 이후 날짜부터 서버는 304\(수정되지 않음\) 응답을 반환해야 합니다.\(SHOULD\)

이 기능의 목적은 최소한의 트랜잭션 오버헤드로 캐시된 정보를 효율적으로 업데이트할 수 있도록 하는 것입니다.

- 참고: Range 요청 헤더 필드는 If-Modified-Since의 의미를 수정합니다. 자세한 내용은 섹션 14.35를 참조하세요.

- 참고: 수정된 이후 시간이 서버에 의해 해석되는 경우 해당 시계는 클라이언트와 동기화되지 않을 수 있습니다.

- 참고: If-Modified-Since 헤더 필드를 처리할 때 일부 서버는 304\(수정되지 않음\) 응답을 보낼지 여부를 결정하기 위해 보다 작음 기능이 아닌 정확한 날짜 비교 기능을 사용합니다. 캐시 검증을 위해 If-Modified-Since 헤더 필드를 보낼 때 최상의 결과를 얻으려면 클라이언트는 가능할 때마다 이전 Last-Modified 헤더 필드에서 수신된 정확한 날짜 문자열을 사용하는 것이 좋습니다.

- 참고: 클라이언트가 동일한 요청에 대해 Last-Modified 헤더에서 가져온 날짜 대신 If-Modified-Since 헤더에 임의의 날짜를 사용하는 경우 클라이언트는 이 날짜가 서버의 헤더에서 해석된다는 사실을 알아야 합니다. 시간에 대한 이해. 클라이언트는 클라이언트와 서버 간의 시간 인코딩이 다르기 때문에 동기화되지 않은 시계와 반올림 문제를 고려해야 합니다. 여기에는 문서가 처음 요청된 시간과 후속 요청의 If-Modified-Since 날짜 사이에 문서가 변경된 경우 경쟁 조건이 발생할 가능성이 포함됩니다.

- If-Modified-Since 날짜가 서버 시계를 수정하지 않고 클라이언트 시계에서 파생된 경우 시계 오차 관련 문제가 발생할 가능성이 있습니다. 클라이언트와 서버 간의 서로 다른 시간 기반에 대한 수정은 네트워크 대기 시간으로 인해 기껏해야 대략적인 수준입니다.

If-Modified-Since 헤더 필드와 If-Match 또는 If-Unmodified-Since 헤더 필드가 모두 있는 요청의 결과는 이 사양에 의해 정의되지 않습니다.

---
## **14.26 If-None-Match**

If-None-Match 요청 헤더 필드는 이를 조건부로 만드는 방법과 함께 사용됩니다. 이전에 리소스에서 얻은 하나 이상의 엔터티가 있는 클라이언트는 If-None-Match 헤더 필드에 관련 엔터티 태그 목록을 포함하여 해당 엔터티 중 최신 엔터티가 없음을 확인할 수 있습니다. 이 기능의 목적은 최소한의 트랜잭션 오버헤드로 캐시된 정보를 효율적으로 업데이트할 수 있도록 하는 것입니다. 또한 클라이언트가 리소스가 존재하지 않는다고 생각할 때 메서드\(예: PUT\)가 기존 리소스를 실수로 수정하는 것을 방지하는 데에도 사용됩니다.

특별한 경우로 "\*" 값은 리소스의 현재 엔터티와 일치합니다.

```text
       If-None-Match = "If-None-Match" ":" ( "*" | 1#entity-tag )
```

엔터티 태그 중 하나라도 해당 리소스에 대한 유사한 GET 요청\(If-None-Match 헤더 없이\)에 대한 응답으로 반환되었을 엔터티의 엔터티 태그와 일치하거나 "\*"가 제공되고 현재 해당 리소스에 대한 엔터티가 존재하는 경우 리소스의 수정 날짜가 요청의 If-Modified-Since 헤더 필드에 제공된 날짜와 일치하지 않기 때문에 그렇게 해야 하는 경우를 제외하고 서버는 요청된 방법을 수행해서는 안 됩니다. 대신, 요청 방법이 GET 또는 HEAD인 경우 서버는 일치하는 엔터티 중 하나의 캐시 관련 헤더 필드\(특히 ETag\)를 포함하여 304\(수정되지 않음\) 응답으로 응답해야 합니다. 다른 모든 요청 방법의 경우 서버는 412\(전제 조건 실패\) 상태로 응답해야 합니다.\(MUST NOT, SHOULD, MUST\)

두 엔터티 태그가 일치하는지 확인하는 방법에 대한 규칙은 섹션 13.3.3을 참조하세요. 약한 비교 기능은 GET 또는 HEAD 요청에만 사용할 수 있습니다.

일치하는 엔터티 태그가 없으면 서버는 If-None-Match 헤더 필드가 존재하지 않는 것처럼 요청된 방법을 수행할 수 있지만 요청의 If-Modified-Since 헤더 필드도 무시해야 합니다. 즉, 일치하는 엔터티 태그가 없으면 서버는 304\(수정되지 않음\) 응답을 반환해서는 안 됩니다.\(MUST, MUST NOT\)

요청이 If-None-Match 헤더 필드 없이 2xx 또는 304 상태 이외의 결과를 초래한다면 If-None-Match 헤더는 무시되어야 합니다. \(If-Modified-Since와 If-None-Match가 동일한 요청에 나타날 때 서버 동작에 대한 논의는 섹션 13.3.4를 참조하십시오.\)\(MUST\)

"If-None-Match: \*"의 의미는 원서버\(또는 Vary 메커니즘을 사용하는 캐시, 섹션 14.44 참조\)에 의해 선택된 표현이 존재하는 경우 메서드를 수행해서는 안 되며 수행해야 한다는 것입니다. 표현이 존재하지 않는 경우. 이 기능은 PUT 작업 간의 경합을 방지하는 데 유용합니다.\(MUST NOT\)

```text
   Examples:

       If-None-Match: "xyzzy"
       If-None-Match: W/"xyzzy"
       If-None-Match: "xyzzy", "r2d2xxxx", "c3piozzzz"
       If-None-Match: W/"xyzzy", W/"r2d2xxxx", W/"c3piozzzz"
       If-None-Match: *
```

If-None-Match 헤더 필드와 If-Match 또는 If-Unmodified-Since 헤더 필드가 모두 있는 요청의 결과는 이 사양에 의해 정의되지 않습니다.

---
## **14.27 If-Range**

클라이언트가 캐시에 엔터티의 부분 복사본을 가지고 있고 캐시에 전체 엔터티의 최신 복사본을 갖고 싶다면 조건부 GET과 함께 Range 요청 헤더를 사용할 수 있습니다\(둘 중 하나 또는 둘 다 사용\). If-Unmodified-Since 및 If-Match.\) 그러나 엔터티가 수정되어 조건이 실패하면 클라이언트는 전체 현재 엔터티 본문을 얻기 위해 두 번째 요청을 해야 합니다.

```text
   The If-Range header allows a client to "short-circuit" the second
   request. Informally, its meaning is `if the entity is unchanged, send
   me the part(s) that I am missing; otherwise, send me the entire new
   entity'.

        If-Range = "If-Range" ":" ( entity-tag | HTTP-date )
```

클라이언트에 엔터티에 대한 엔터티 태그가 없지만 최종 수정 날짜가 있는 경우 If-Range 헤더에서 해당 날짜를 사용할 수 있습니다. \(서버는 2개 이하의 문자를 검사하여 유효한 HTTP-date와 모든 형태의 엔터티 태그를 구별할 수 있습니다.\) If-Range 헤더는 Range 헤더와 함께만 사용해야 하며 요청이 그렇지 않은 경우 무시해야 합니다. Range 헤더를 포함하지 않거나 서버가 하위 범위 작업을 지원하지 않는 경우.\(MAY, MUST\)

If-Range 헤더에 제공된 엔터티 태그가 엔터티의 현재 엔터티 태그와 일치하는 경우 서버는 206\(부분 콘텐츠\) 응답을 사용하여 엔터티의 지정된 하위 범위를 제공해야 합니다\(SHOULD\). 엔터티 태그가 일치하지 않으면 서버는 200\(OK\) 응답을 사용하여 전체 엔터티를 반환해야 합니다.\(SHOULD, SHOULD\)

---
## **14.28 If-Unmodified-Since**

If-Unmodified-Since 요청 헤더 필드는 이를 조건부로 만드는 방법과 함께 사용됩니다. 이 필드에 지정된 시간 이후 요청된 리소스가 수정되지 않은 경우 서버는 If-Unmodified-Since 헤더가 없는 것처럼 요청된 작업을 수행해야 합니다.\(SHOULD\)

요청된 변형이 지정된 시간 이후 수정된 경우 서버는 요청된 작업을 수행해서는 안 되며 412\(전제 조건 실패\)를 반환해야 합니다.\(MUST NOT\)

```text
      If-Unmodified-Since = "If-Unmodified-Since" ":" HTTP-date
```

필드의 예는 다음과 같습니다.

```text
       If-Unmodified-Since: Sat, 29 Oct 1994 19:43:31 GMT
```

요청이 정상적으로\(즉, If-Unmodified-Since 헤더 없이\) 2xx 또는 412 상태 이외의 결과를 초래한다면 If-Unmodified-Since 헤더는 무시되어야 합니다.\(SHOULD\)

지정된 날짜가 유효하지 않으면 헤더가 무시됩니다.

If-Unmodified-Since 헤더 필드와 If-None-Match 또는 If-Modified-Since 헤더 필드가 모두 있는 요청의 결과는 이 사양에 의해 정의되지 않습니다.

---
## **14.29 Last-Modified**

Last-Modified 엔터티 헤더 필드는 원본 서버가 변형이 마지막으로 수정되었다고 믿는 날짜와 시간을 나타냅니다.

```text
       Last-Modified  = "Last-Modified" ":" HTTP-date
```

그 사용 예는 다음과 같습니다.

```text
       Last-Modified: Tue, 15 Nov 1994 12:45:26 GMT
```

이 헤더 필드의 정확한 의미는 원본 서버의 구현과 원본 리소스의 성격에 따라 다릅니다. 파일의 경우 파일 시스템이 마지막으로 수정된 시간일 수 있습니다. 동적으로 포함된 부분이 있는 엔터티의 경우 구성 요소 부분의 마지막 수정 시간 집합 중 가장 최근일 수 있습니다. 데이터베이스 게이트웨이의 경우 레코드의 마지막 업데이트 타임스탬프일 수 있습니다. 가상 개체의 경우 내부 상태가 마지막으로 변경된 시간일 수 있습니다.

원서버는 서버의 메시지 발생 시간보다 이후의 최종 수정 날짜를 보내서는 안 됩니다. 리소스의 마지막 수정이 미래의 시간을 나타내는 경우 서버는 해당 날짜를 메시지 발생 날짜로 바꿔야 합니다.\(MUST NOT, MUST\)

원서버는 응답의 Date 값을 생성하는 시간에 최대한 가까운 엔터티의 Last-Modified 값을 얻어야 합니다\(SHOULD\). 이를 통해 수신자는 특히 응답이 생성되는 시간 근처에 엔터티가 변경되는 경우 엔터티의 수정 시간을 정확하게 평가할 수 있습니다.\(SHOULD\)

HTTP/1.1 서버는 가능할 때마다 Last-Modified를 전송해야 합니다.\(SHOULD\)

---
## **14.30 Location**

위치 응답 헤더 필드는 요청 완료 또는 새 리소스 식별을 위해 요청 URI가 아닌 다른 위치로 수신자를 리디렉션하는 데 사용됩니다. 201\(Created\) 응답의 경우 위치는 요청에 의해 생성된 새 리소스의 위치입니다. 3xx 응답의 경우 위치는 리소스로의 자동 리디렉션을 위한 서버의 기본 URI를 나타내야 합니다\(SHOULD\). 필드 값은 단일 절대 URI로 구성됩니다.\(SHOULD\)

```text
       Location       = "Location" ":" absoluteURI
```

예는 다음과 같습니다:

```text
       Location: http://www.w3.org/pub/WWW/People.html
```

- 참고: Content-Location 헤더 필드\(14.14절\)는 Content-Location이 요청에 포함된 엔터티의 원래 위치를 식별한다는 점에서 Location과 다릅니다. 따라서 응답에 Location 및 Content-Location 모두에 대한 헤더 필드가 포함될 수 있습니다. 또한 일부 메서드의 캐시 요구 사항은 섹션 13.10을 참조하세요.

---
## **14.31 Max-Forwards**

Max-Forwards 요청 헤더 필드는 요청을 다음 인바운드 서버로 전달할 수 있는 프록시 또는 게이트웨이 수를 제한하기 위해 TRACE\(섹션 9.8\) 및 OPTIONS\(섹션 9.2\) 메서드가 포함된 메커니즘을 제공합니다. 이는 클라이언트가 중간 체인에서 실패하거나 반복되는 것으로 보이는 요청 체인을 추적하려고 할 때 유용할 수 있습니다.

```text
       Max-Forwards   = "Max-Forwards" ":" 1*DIGIT
```

Max-Forwards 값은 이 요청 메시지가 전달될 수 있는 남은 횟수를 나타내는 10진수 정수입니다.

Max-Forwards 헤더 필드가 포함된 TRACE 또는 OPTIONS 요청의 각 프록시 또는 게이트웨이 수신자는 요청을 전달하기 전에 해당 값을 확인하고 업데이트해야 합니다. 수신된 값이 0인 경우 수신자는 요청을 전달해서는 안 됩니다. 대신 최종 수신자로 응답해야 합니다. 수신된 Max-Forwards 값이 0보다 큰 경우 전달된 메시지에는 값이 1만큼 감소된 업데이트된 Max-Forwards 필드가 포함되어야 합니다.\(MUST, MUST NOT, MUST\)

Max-Forwards 헤더 필드는 이 사양에 정의된 다른 모든 메서드와 해당 메서드 정의의 일부로 명시적으로 참조되지 않는 확장 메서드에 대해 무시될 수 있습니다.\(MAY\)

---
## **14.32 Pragma**

Pragma 일반 헤더 필드는 요청/응답 체인을 따라 모든 수신자에게 적용될 수 있는 구현 관련 지시문을 포함하는 데 사용됩니다. 모든 pragma 지시문은 프로토콜의 관점에서 선택적 동작을 지정합니다. 그러나 일부 시스템에서는 동작이 지시문과 일치하도록 요구할 수 있습니다.\(MAY\)

```text
       Pragma            = "Pragma" ":" 1#pragma-directive
       pragma-directive  = "no-cache" | extension-pragma
       extension-pragma  = token [ "=" ( token | quoted-string ) ]
```

요청 메시지에 no-cache 지시문이 있는 경우 애플리케이션은 요청 내용의 캐시된 복사본이 있더라도 해당 요청을 원본 서버로 전달해야 합니다. 이 pragma 지시어는 no-cache 캐시 지시어\(섹션 14.9 참조\)와 동일한 의미를 가지며 HTTP/1.0과의 이전 버전과의 호환성을 위해 여기에 정의되었습니다. 클라이언트는 캐시 없음 요청이 HTTP/1.1을 준수하는 것으로 알려지지 않은 서버로 전송될 때 두 헤더 필드를 모두 포함해야 합니다.\(SHOULD, SHOULD\)

Pragma 지시문은 요청/응답 체인을 따라 모든 수신자에게 적용될 수 있으므로 해당 애플리케이션에 대한 중요성에 관계없이 프록시 또는 게이트웨이 애플리케이션을 통해 전달되어야 합니다. 특정 수신자에 대해 pragma를 지정하는 것은 불가능합니다. 그러나 수신자와 관련되지 않은 모든 pragma 지시문은 해당 수신자에 의해 무시되어야 합니다.\(MUST, SHOULD\)

HTTP/1.1 캐시는 클라이언트가 "Cache-Control: no-cache"를 보낸 것처럼 "Pragma: no-cache"를 처리해야 합니다. HTTP에는 새로운 Pragma 지시문이 정의되지 않습니다.\(SHOULD\)

- 참고: 응답 헤더 필드로서 "Pragma: no-cache"의 의미가 실제로 지정되지 않았기 때문에 응답에서 "Cache-Control: no-cache"에 대한 안정적인 대체를 제공하지 않습니다.

---
## **14.33 Proxy-Authenticate**

프록시 인증 응답 헤더 필드는 407\(프록시 인증 필요\) 응답의 일부로 포함되어야 합니다. 필드 값은 이 요청-URI의 프록시에 적용할 수 있는 인증 체계와 매개변수를 나타내는 챌린지로 구성됩니다.\(MUST\)

```text
       Proxy-Authenticate  = "Proxy-Authenticate" ":" 1#challenge
```

HTTP 액세스 인증 프로세스는 "HTTP 인증: 기본 및 다이제스트 액세스 인증"\[43\]에 설명되어 있습니다. WWW-Authenticate와 달리 Proxy-Authenticate 헤더 필드는 현재 연결에만 적용되며 다운스트림 클라이언트로 전달되어서는 안 됩니다. 그러나 중간 프록시는 다운스트림 클라이언트에서 요청하여 자체 자격 증명을 얻어야 할 수 있으며, 이는 일부 상황에서 프록시가 Proxy-Authenticate 헤더 필드를 전달하는 것처럼 나타납니다.\(SHOULD NOT\)

---
## **14.34 Proxy-Authorization**

Proxy-Authorization 요청 헤더 필드를 사용하면 클라이언트는 인증이 필요한 프록시에 대해 자신\(또는 해당 사용자\)을 식별할 수 있습니다. Proxy-Authorization 필드 값은 요청 중인 리소스의 프록시 및/또는 영역에 대한 사용자 에이전트의 인증 정보를 포함하는 자격 증명으로 구성됩니다.

```text
       Proxy-Authorization     = "Proxy-Authorization" ":" credentials
```

HTTP 액세스 인증 프로세스는 "HTTP 인증: 기본 및 다이제스트 액세스 인증"\[43\]에 설명되어 있습니다. Authorization과 달리 Proxy-Authorization 헤더 필드는 Proxy-Authenticate 필드를 사용하여 인증을 요구한 다음 아웃바운드 프록시에만 적용됩니다. 여러 프록시가 체인에 사용되는 경우

Proxy-Authorization 헤더 필드는 자격 증명을 받을 것으로 예상되는 첫 번째 아웃바운드 프록시에서 사용됩니다. 프록시가 주어진 요청을 협력적으로 인증하는 메커니즘인 경우 프록시는 클라이언트 요청의 자격 증명을 다음 프록시로 중계할 수 있습니다.\(MAY\)

---
## **14.35 Range**
---
### **14.35.1 Byte Ranges**

모든 HTTP 엔터티는 HTTP 메시지에서 바이트 시퀀스로 표시되므로 바이트 범위 개념은 모든 HTTP 엔터티에 의미가 있습니다. \(그러나 모든 클라이언트와 서버가 바이트 범위 작업을 지원할 필요는 없습니다.\)

HTTP의 바이트 범위 사양은 엔터티 본문의 바이트 시퀀스에 적용됩니다\(메시지 본문과 반드시 ​​동일할 필요는 없음\).

바이트 범위 작업은 단일 바이트 범위 또는 단일 엔터티 내의 범위 집합을 지정할 수 있습니다.\(MAY\)

```text
       ranges-specifier = byte-ranges-specifier
       byte-ranges-specifier = bytes-unit "=" byte-range-set
       byte-range-set  = 1#( byte-range-spec | suffix-byte-range-spec )
       byte-range-spec = first-byte-pos "-" [last-byte-pos]
       first-byte-pos  = 1*DIGIT
       last-byte-pos   = 1*DIGIT
```

byte-range-spec의 first-byte-pos 값은 범위 내 첫 번째 바이트의 바이트 오프셋을 제공합니다. last-byte-pos 값은 범위 내 마지막 바이트의 바이트 오프셋을 제공합니다. 즉, 지정된 바이트 위치가 포함됩니다. 바이트 오프셋은 0부터 시작합니다.

last-byte-pos 값이 존재하는 경우 해당 byte-range-spec의 첫 번째 byte-pos보다 크거나 같아야 합니다. 그렇지 않으면 byte-range-spec이 구문상 유효하지 않습니다. 하나 이상의 구문상 유효하지 않은 byte-range-spec 값을 포함하는 byte-range-set의 수신자는 해당 byte-range-set를 포함하는 헤더 필드를 무시해야 합니다.\(MUST, MUST\)

last-byte-pos 값이 없거나 값이 Entity-Body의 현재 길이보다 크거나 같은 경우 last-byte-pos는 엔터티의 현재 길이보다 1 작은 것과 같은 것으로 간주됩니다. - 본문\(바이트\)입니다.

마지막 바이트 위치를 선택하면 클라이언트는 엔터티의 크기를 알지 못한 채 검색되는 바이트 수를 제한할 수 있습니다.

```text
       suffix-byte-range-spec = "-" suffix-length
       suffix-length = 1*DIGIT
```

suffix-byte-range-spec은 suffix-length 값으로 제공되는 길이의 Entity-Body의 접미사를 지정하는 데 사용됩니다. \(즉, 이 형식은 엔터티 본문의 마지막 N 바이트를 지정합니다.\) 엔터티가 지정된 접미사 길이보다 짧으면 전체 엔터티 본문이 사용됩니다.

구문적으로 유효한 byte-range-set에 첫 번째 바이트-pos가 Entity-Body의 현재 길이보다 작은 적어도 하나의 byte-range-spec이 포함되거나 비 - 접미사 길이가 0이면 바이트 범위 집합이 만족됩니다. 그렇지 않으면 바이트 범위 집합이 만족스럽지 않습니다. 바이트 범위 집합이 만족스럽지 않은 경우 서버는 416\(요청된 범위가 만족스럽지 않음\) 상태의 응답을 반환해야 합니다. 그렇지 않으면 서버는 Entity-Body의 만족 가능한 범위를 포함하는 206\(부분 콘텐츠\) 상태의 응답을 반환해야 합니다.\(SHOULD, SHOULD\)

바이트 범위 지정자 값의 예\(길이가 10000인 엔터티 본문을 가정\):

- - 처음 500바이트\(바이트 오프셋 0-499 포함\): 바이트=0- 499

- 두 번째 500바이트\(바이트 오프셋 500-999 포함\):

- 바이트=500-999

- - 마지막 500바이트\(바이트 오프셋 9500-9999 포함\): bytes=-500

```text
      - Or bytes=9500-
```

- - 첫 번째 및 마지막 바이트만\(바이트 0 및 9999\): bytes=0-0,-1

- - 두 번째 500바이트에 대한 몇 가지 법적이지만 정식은 아닌 사양\(바이트 오프셋 500-999 포함\): 바이트=500-600,601-999 바이트=500-700,601-999

---
### **14.35.2 Range Retrieval Requests**

조건부 또는 무조건 GET 메소드를 사용하는 HTTP 검색 요청은 요청의 결과로 반환된 엔터티에 적용되는 Range 요청 헤더를 사용하여 전체 엔터티 대신 엔터티의 하나 이상의 하위 범위를 요청할 수 있습니다.\(MAY\)

```text
      Range = "Range" ":" ranges-specifier
```

서버는 Range 헤더를 무시할 수 있습니다. 그러나 HTTP/1.1 원본 서버와 중간 캐시는 가능하면 바이트 범위를 지원해야 합니다. Range는 부분적으로 실패한 전송의 효율적인 복구를 지원하고 대규모 엔터티의 효율적인 부분 검색을 지원하기 때문입니다.\(MAY\)

서버가 Range 헤더를 지원하고 지정된 범위가 엔터티에 적합한 경우:

- - 무조건 GET에 Range 헤더가 있으면 GET이 성공할 경우 반환되는 내용이 수정됩니다. 즉, 응답에는 200\(OK\) 대신 206\(부분 콘텐츠\)의 상태 코드가 전달됩니다.

- - 조건부 GET\(If-Modified-Since 및 If-None-Match 중 하나 또는 둘 다를 사용하거나 If-Unmodified-Since 및 If-Match 중 하나 또는 둘 다를 사용하는 요청\)에 Range 헤더가 있으면 무엇을 수정합니까? 그렇지 않으면 GET이 성공하고 조건이 true인 경우 반환됩니다. 조건이 false인 경우 반환되는 304\(수정되지 않음\) 응답에는 영향을 미치지 않습니다.

어떤 경우에는 Range 헤더 외에 If-Range 헤더\(14.27절 참조\)를 사용하는 것이 더 적절할 수도 있습니다.

범위를 지원하는 프록시가 Range 요청을 수신하고 해당 요청을 인바운드 서버로 전달하고 응답으로 전체 엔터티를 수신하는 경우 요청된 범위만 클라이언트에 반환해야 합니다. 캐시 할당 정책과 일치하는 경우 수신된 전체 응답을 캐시에 저장해야 합니다\(SHOULD\).\(SHOULD, SHOULD\)

---
## **14.36 Referer**

Referer\[sic\] 요청 헤더 필드를 사용하면 서버의 이익을 위해 클라이언트가 Request-URI를 얻은 리소스의 주소\(URI\)를 지정할 수 있습니다\(헤더 필드의 철자가 틀리더라도 "리퍼러"\). Referer 요청 헤더를 사용하면 서버가 관심, 로깅, 최적화된 캐싱 등을 위해 리소스에 대한 백링크 목록을 생성할 수 있습니다. 또한 유지 관리를 위해 오래되었거나 잘못 입력된 링크를 추적할 수 있습니다. 사용자 키보드의 입력과 같이 자체 URI가 없는 소스에서 Request-URI를 얻은 경우 Referer 필드를 전송해서는 안 됩니다.\(MUST NOT\)

```text
       Referer        = "Referer" ":" ( absoluteURI | relativeURI )

   Example:

       Referer: http://www.w3.org/hypertext/DataSources/Overview.html
```

필드 값이 상대 URI인 경우 요청-URI를 기준으로 해석되어야 합니다. URI에는 조각이 포함되어서는 안 됩니다. 보안 고려 사항은 섹션 15.1.3을 참조하세요.\(SHOULD, MUST NOT\)

---
## **14.37 Retry-After**

Retry-After 응답 헤더 필드는 503\(서비스 사용 불가\) 응답과 함께 사용하여 요청 클라이언트가 서비스를 사용할 수 없는 기간을 나타낼 수 있습니다. 이 필드는 3xx\(리디렉션\) 응답과 함께 사용되어 사용자 에이전트가 리디렉션된 요청을 발행하기 전에 대기하도록 요청하는 최소 시간을 나타낼 수도 있습니다. 이 필드의 값은 HTTP 날짜이거나 응답 시간 이후의 정수\(십진수\)일 수 있습니다.\(MAY\)

```text
       Retry-After  = "Retry-After" ":" ( HTTP-date | delta-seconds )
```

그 사용의 두 가지 예는 다음과 같습니다

```text
       Retry-After: Fri, 31 Dec 1999 23:59:59 GMT
       Retry-After: 120
```

후자의 예에서는 지연 시간이 2분입니다.

---
## **14.38 Server**

서버 응답 헤더 필드에는 원본 서버가 요청을 처리하는 데 사용하는 소프트웨어에 대한 정보가 포함됩니다. 필드에는 여러 제품 토큰\(섹션 3.8\)과 서버 및 중요한 하위 제품을 식별하는 설명이 포함될 수 있습니다. 제품 토큰은 응용 프로그램을 식별하는 데 중요한 순서대로 나열됩니다.

```text
       Server         = "Server" ":" 1*( product | comment )

   Example:

       Server: CERN/3.0 libwww/2.17
```

응답이 프록시를 통해 전달되는 경우 프록시 애플리케이션은 서버 응답 헤더를 수정해서는 안 됩니다. 대신에 Via 필드를 포함해야 합니다\(섹션 14.45에 설명되어 있음\).\(MUST NOT, SHOULD\)

- 참고: 서버의 특정 소프트웨어 버전을 공개하면 서버 시스템이 보안 허점이 있는 것으로 알려진 소프트웨어에 대한 공격에 더욱 취약해질 수 있습니다. 서버 구현자는 이 필드를 구성 가능한 옵션으로 만드는 것이 좋습니다.

---
## **14.39 TE**

TE 요청 헤더 필드는 응답에서 어떤 확장 전송 코딩을 수락할지, 청크 전송 코딩에서 트레일러 필드를 수락할지 여부를 나타냅니다. 그 값은 키워드 "트레일러" 및/또는 선택적 허용 매개변수가 있는 확장 전송 코딩 이름의 쉼표로 구분된 목록으로 구성될 수 있습니다\(섹션 3.6에 설명됨\).

```text
       TE        = "TE" ":" #( t-codings )
       t-codings = "trailers" | ( transfer-extension [ accept-params ] )
```

"트레일러"라는 키워드가 있다는 것은 섹션 3.6.1에 정의된 대로 클라이언트가 청크 전송 코딩의 트레일러 필드를 기꺼이 받아들인다는 것을 나타냅니다. 이 키워드는 자체적으로 전송 코딩을 나타내지 않더라도 전송 코딩 값과 함께 사용하도록 예약되어 있습니다.

사용 예는 다음과 같습니다.

```text
       TE: deflate
       TE:
       TE: trailers, deflate;q=0.5
```

TE 헤더 필드는 즉시 연결에만 적용됩니다. 따라서 TE가 HTTP/1.1 메시지에 존재할 때마다 연결 헤더 필드\(섹션 14.10\) 내에 키워드를 제공해야 합니다.\(MUST\)

서버는 다음 규칙을 사용하여 TE 필드에 따라 전송 코딩이 허용되는지 여부를 테스트합니다.

- 1. "청크" 전송 코딩은 항상 허용됩니다. 키워드 "트레일러"가 나열되면 클라이언트는 자신과 모든 다운스트림 클라이언트를 대신하여 청크 분할 응답의 트레일러 필드를 수락할 의사가 있음을 나타냅니다. 주어진 경우 클라이언트는 모든 다운스트림 클라이언트가 전달된 응답의 트레일러 필드를 기꺼이 수락하거나 다운스트림 수신자를 대신하여 응답을 버퍼링하려고 시도한다는 것을 의미합니다.

- 참고: HTTP/1.1은 클라이언트가 전체 응답을 버퍼링할 수 있도록 청크된 응답의 크기를 제한하는 수단을 정의하지 않습니다.

```text
      2. If the transfer-coding being tested is one of the transfer-
         codings listed in the TE field, then it is acceptable unless it
         is accompanied by a qvalue of 0. (As defined in section 3.9, a
         qvalue of 0 means "not acceptable.")
```

3. 다중 전송 코딩이 허용되는 경우

- 0이 아닌 가장 높은 q값을 갖는 허용 가능한 전송 코딩이 선호됩니다. "청크된" 전송 코딩의 q값은 항상 1입니다.

TE 필드 값이 비어 있거나 TE 필드가 없는 경우 유일한 전송 코딩은 "청크"입니다. 전송 코딩이 없는 메시지는 항상 허용됩니다.

---
## **14.40 Trailer**

Trailer 일반 필드 값은 주어진 헤더 필드 세트가 청크 전송 코딩으로 인코딩된 메시지의 트레일러에 있음을 나타냅니다.

```text
       Trailer  = "Trailer" ":" 1#field-name
```

HTTP/1.1 메시지는 비어 있지 않은 트레일러와 함께 청크 분할 전송 코딩을 사용하는 메시지에 Trailer 헤더 필드를 포함해야 합니다. 이렇게 하면 수신자가 예고편에서 예상되는 헤더 필드를 알 수 있습니다.\(SHOULD\)

예고편 헤더 필드가 없으면 예고편에는 헤더 필드가 포함되어서는 안 됩니다. "청크" 전송 코딩에서 트레일러 필드 사용에 대한 제한 사항은 섹션 3.6.1을 참조하세요.\(SHOULD NOT\)

Trailer 헤더 필드에 나열된 메시지 헤더 필드는 다음 헤더 필드를 포함해서는 안 됩니다.\(MUST NOT\)

```text
      . Transfer-Encoding

      . Content-Length

      . Trailer
```

---
## **14.41 Transfer-Encoding**

Transfer-Encoding 일반 헤더 필드는 보낸 사람과 받는 사람 간에 메시지를 안전하게 전송하기 위해 메시지 본문에 적용된 변환 유형\(있는 경우\)을 나타냅니다. 이는 전송 코딩이 엔터티가 아닌 메시지의 속성이라는 점에서 콘텐츠 코딩과 다릅니다.

```text
     Transfer-Encoding       = "Transfer-Encoding" ":" 1#transfer-coding
```

전송 코딩은 섹션 3.6에 정의되어 있습니다. 예는 다음과 같습니다:

```text
     Transfer-Encoding: chunked
```

여러 인코딩이 엔터티에 적용된 경우 전송 코딩은 적용된 순서대로 나열되어야 합니다. 인코딩 매개변수에 대한 추가 정보는 이 사양에서 정의되지 않은 다른 엔터티 헤더 필드에 의해 제공될 수 있습니다.\(MUST, MAY\)

많은 이전 HTTP/1.0 응용 프로그램은 Transfer-Encoding 헤더를 이해하지 못합니다.

---
## **14.42 Upgrade**

업그레이드 일반 헤더를 사용하면 클라이언트는 서버가 프로토콜 전환에 적합하다고 판단한 경우 지원하고 사용할 추가 통신 프로토콜을 지정할 수 있습니다. 서버는 어떤 프로토콜이 전환되고 있는지 나타내기 위해 101\(전환 프로토콜\) 응답 내의 업그레이드 헤더 필드를 사용해야 합니다.\(MUST\)

```text
       Upgrade        = "Upgrade" ":" 1#product
```

예를 들어,

```text
       Upgrade: HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11
```

업그레이드 헤더 필드는 HTTP/1.1에서 다른 호환되지 않는 프로토콜로 전환하기 위한 간단한 메커니즘을 제공하기 위한 것입니다. 이는 현재 요청이 HTTP/1.1을 사용하여 이루어졌음에도 불구하고 클라이언트가 더 높은 주 버전 번호를 가진 최신 버전의 HTTP와 같은 다른 프로토콜을 사용하려는 욕구를 광고할 수 있도록 허용함으로써 이를 수행합니다. 이는 클라이언트가 더 일반적으로 지원되는 프로토콜에서 요청을 시작할 수 있도록 허용하는 동시에 가능한 경우 "더 나은" 프로토콜을 사용하고 싶다는 것을 서버에 표시함으로써 호환되지 않는 프로토콜 간의 어려운 전환을 용이하게 합니다\("더 나은" 프로토콜은 서버에 의해 결정됨\). , 아마도 요청되는 방법 및/또는 리소스의 성격에 따라\).

업그레이드 헤더 필드는 기존 전송 계층 연결 시 애플리케이션 계층 프로토콜을 전환하는 데에만 적용됩니다. 업그레이드는 프로토콜 변경을 주장하는 데 사용할 수 없습니다. 서버의 승인 및 사용은 선택 사항입니다. 프로토콜 변경 후 애플리케이션 계층 통신의 기능과 특성은 선택한 새 프로토콜에 전적으로 의존하지만, 프로토콜 변경 후 첫 번째 작업은 업그레이드 헤더 필드가 포함된 초기 HTTP 요청에 대한 응답이어야 합니다.\(MUST\)

업그레이드 헤더 필드는 즉시 연결에만 적용됩니다. 따라서 업그레이드 키워드는 HTTP/1.1 메시지에 업그레이드가 존재할 때마다 연결 헤더 필드\(섹션 14.10\) 내에 제공되어야 합니다.\(MUST\)

업그레이드 헤더 필드는 다른 연결의 프로토콜로의 전환을 나타내는 데 사용할 수 없습니다. 이를 위해서는 301, 302, 303 또는 305 리디렉션 응답을 사용하는 것이 더 적합합니다.

이 사양은 섹션 3.1의 HTTP 버전 규칙과 이 사양에 대한 향후 업데이트에 정의된 대로 하이퍼텍스트 전송 프로토콜 제품군에서 사용하기 위한 프로토콜 이름 "HTTP"만 정의합니다. 모든 토큰을 프로토콜 이름으로 사용할 수 있습니다. 그러나 클라이언트와 서버 모두 이름을 동일한 프로토콜과 연결하는 경우에만 유용합니다.

---
## **14.43 User-Agent**

User-Agent 요청 헤더 필드에는 요청을 보낸 사용자 에이전트에 대한 정보가 포함되어 있습니다. 이는 통계 목적, 프로토콜 위반 추적 및 특정 사용자 에이전트 제한을 피하기 위한 응답 맞춤화를 위한 사용자 에이전트 자동 인식을 위한 것입니다. 사용자 에이전트는 요청에 이 필드를 포함해야 합니다. 필드에는 여러 제품 토큰\(섹션 3.8\)과 사용자 에이전트의 중요한 부분을 구성하는 에이전트 및 하위 제품을 식별하는 설명이 포함될 수 있습니다. 일반적으로 제품 토큰은 응용 프로그램을 식별하는 데 중요한 순서대로 나열됩니다.\(SHOULD\)

```text
       User-Agent     = "User-Agent" ":" 1*( product | comment )

   Example:

       User-Agent: CERN-LineMode/2.15 libwww/2.17b3
```

---
## **14.44 Vary**

Vary 필드 값은 응답이 최신인 동안 캐시가 재검증 없이 후속 요청에 응답하기 위해 응답을 사용할 수 있는지 여부를 완전히 결정하는 요청 헤더 필드 세트를 나타냅니다. 캐시할 수 없거나 오래된 응답의 경우 Vary 필드 값은 표현을 선택하는 데 사용된 기준에 대해 사용자 에이전트에 알려줍니다. Vary 필드 값 "\*"은 캐시가 후속 요청의 요청 헤더에서 이 응답이 적절한 표현인지 확인할 수 없음을 의미합니다. 캐시에 의한 Vary 헤더 필드 사용에 대해서는 섹션 13.6을 참조하세요.

```text
       Vary  = "Vary" ":" ( "*" | 1#field-name )
```

HTTP/1.1 서버는 서버 중심 협상의 대상이 되는 캐시 가능한 응답과 함께 Vary 헤더 필드를 포함해야 합니다. 그렇게 하면 캐시가 해당 리소스에 대한 향후 요청을 적절하게 해석하고 사용자 에이전트에 협상이 있음을 알릴 수 있습니다.\(SHOULD\)

해당 리소스에. 서버는 서버 주도 협상이 적용되는 캐시할 수 없는 응답이 있는 Vary 헤더 필드를 포함할 수 있습니다. 이는 응답 시 응답이 달라지는 차원에 대한 유용한 정보를 사용자 에이전트에 제공할 수 있기 때문입니다.\(MAY\)

필드 이름 목록으로 구성된 Vary 필드 값은 응답을 위해 선택된 표현이 가장 적절한 표현을 선택할 때 나열된 요청 헤더 필드 값만 고려하는 선택 알고리즘을 기반으로 한다는 신호를 보냅니다. 캐시는 응답이 새로운 기간 동안 나열된 필드 이름에 대해 동일한 값을 사용하여 향후 요청에 대해 동일한 선택이 이루어질 것이라고 가정할 수 있습니다.\(MAY\)

주어진 필드 이름은 이 사양에 정의된 표준 요청 헤더 필드 집합으로 제한되지 않습니다. 필드 이름은 대소문자를 구분합니다.

"\*"의 Vary 필드 값은 요청 헤더\(예: 클라이언트의 네트워크 주소\)에 국한되지 않는 지정되지 않은 매개변수가 응답 표현 선택에 역할을 한다는 신호입니다. "\*" 값은 프록시 서버에 의해 생성되어서는 안 됩니다. 이는 원본 서버에 의해서만 생성될 수 있습니다.\(MUST NOT\)

---
## **14.45  Via**

Via 일반 헤더 필드는 요청 시 사용자 에이전트와 서버 사이, 응답 시 원본 서버와 클라이언트 사이의 중간 프로토콜과 수신자를 나타내기 위해 게이트웨이와 프록시에서 사용해야 합니다. 이는 RFC 822 \[9\]의 "수신" 필드와 유사하며 메시지 전달을 추적하고, 요청 루프를 방지하고, 요청/응답 체인을 따라 모든 보낸 사람의 프로토콜 기능을 식별하는 데 사용됩니다.\(MUST\)

```text
      Via =  "Via" ":" 1#( received-protocol received-by [ comment ] )
      received-protocol = [ protocol-name "/" ] protocol-version
      protocol-name     = token
      protocol-version  = token
      received-by       = ( host [ ":" port ] ) | pseudonym
      pseudonym         = token
```

received-protocol은 요청/응답 체인의 각 세그먼트를 따라 서버 또는 클라이언트가 수신한 메시지의 프로토콜 버전을 나타냅니다. 업스트림 애플리케이션의 프로토콜 기능에 대한 정보가 모든 수신자에게 계속 표시되도록 메시지가 전달될 때 수신된 프로토콜 버전이 Via 필드 값에 추가됩니다.

프로토콜 이름은 "HTTP"인 경우에만 선택 사항입니다. 수신자 필드는 일반적으로 이후에 메시지를 전달한 수신자 서버 또는 클라이언트의 호스트 및 선택적 포트 번호입니다. 그러나 실제 호스트가 민감한 정보로 간주되는 경우에는 가명으로 대체될 수 있습니다. 포트가 제공되지 않으면 수신 프로토콜의 기본 포트로 간주될 수 있습니다.\(MAY, MAY\)

Multiple Via 필드 값은 메시지를 전달한 각 프록시 또는 게이트웨이를 나타냅니다. 각 수신자는 전달 애플리케이션의 순서에 따라 최종 결과가 정렬되도록 정보를 추가해야 합니다.\(MUST\)

User-Agent 및 Server 헤더 필드와 유사하게 수신자 프록시 또는 게이트웨이의 소프트웨어를 식별하기 위해 Via 헤더 필드에 주석을 사용할 수 있습니다. 그러나 Via 필드의 모든 설명은 선택 사항이며 메시지를 전달하기 전에 수신자가 삭제할 수 있습니다.\(MAY, MAY\)

예를 들어, 요청 메시지는 HTTP/1.0 사용자 에이전트에서 "fred"라는 내부 프록시 코드명으로 전송될 수 있습니다. 이 프록시 코드명은 HTTP/1.1을 사용하여 해당 요청을 아무데도.com에 있는 공개 프록시로 전달하고, 이 프록시는 다음과 같이 요청을 완료합니다. 이를 원본 서버인 www.ics.uci.edu로 전달합니다. www.ics.uci.edu에서 수신한 요청에는 다음과 같은 Via 헤더 필드가 있습니다.

```text
       Via: 1.0 fred, 1.1 nowhere.com (Apache/1.1)
```

네트워크 방화벽을 통해 포털로 사용되는 프록시와 게이트웨이는 기본적으로 방화벽 지역 내 호스트의 이름과 포트를 전달해서는 안 됩니다. 이 정보는 명시적으로 활성화된 경우에만 전파되어야 합니다. 활성화되지 않은 경우 방화벽 뒤에 있는 호스트의 수신 호스트는 해당 호스트에 대한 적절한 가명으로 대체되어야 합니다.\(SHOULD NOT, SHOULD, SHOULD\)

내부 구조를 숨기기 위한 강력한 개인 정보 보호 요구 사항이 있는 조직의 경우 프록시는 동일한 수신 프로토콜 값을 가진 Via 헤더 필드 항목의 정렬된 하위 시퀀스를 단일 항목으로 결합할 수 있습니다. 예를 들어,\(MAY\)

```text
       Via: 1.0 ricky, 1.1 ethel, 1.1 fred, 1.0 lucy

        could be collapsed to

       Via: 1.0 ricky, 1.1 mertz, 1.0 lucy
```

애플리케이션은 모두 동일한 조직 제어 하에 있고 호스트가 이미 가명으로 대체되지 않은 한 여러 항목을 결합해서는 안 됩니다. 애플리케이션은 서로 다른 수신 프로토콜 값을 가진 항목을 결합해서는 안 됩니다.\(SHOULD NOT, MUST NOT\)

---
## **14.46 Warning**

경고 일반 헤더 필드는 메시지에 반영되지 않을 수 있는 메시지의 상태 또는 변환에 대한 추가 정보를 전달하는 데 사용됩니다. 이 정보는 일반적으로 메시지의 엔터티 본문에 적용된 캐싱 작업이나 변환으로 인해 의미 투명성이 부족할 수 있음을 경고하는 데 사용됩니다.

경고 헤더는 다음을 사용하여 응답과 함께 전송됩니다.

```text
       Warning    = "Warning" ":" 1#warning-value

       warning-value = warn-code SP warn-agent SP warn-text
                                             [SP warn-date]

       warn-code  = 3DIGIT
       warn-agent = ( host [ ":" port ] ) | pseudonym
                       ; the name or pseudonym of the server adding
                       ; the Warning header, for use in debugging
       warn-text  = quoted-string
       warn-date  = <"> HTTP-date <">
```

응답은 하나 이상의 경고 헤더를 전달할 수 있습니다.\(MAY\)

경고 텍스트는 응답을 받는 인간 사용자가 가장 이해할 수 있는 자연 언어 및 문자 집합으로 되어 있어야 합니다. 이 결정은 캐시 또는 사용자의 위치, 요청의 Accept-Language 필드, 응답의 Content-Language 필드 등과 같은 사용 가능한 모든 정보를 기반으로 할 수 있습니다. 기본 언어는 영어이고 기본 문자 집합은 ISO-8859-1입니다.\(SHOULD, MAY\)

ISO-8859-1 이외의 문자 집합이 사용되는 경우 RFC 2047 \[14\]에 설명된 방법을 사용하여 경고 텍스트에 인코딩해야 합니다.\(MUST\)

경고 헤더는 일반적으로 모든 메시지에 적용될 수 있지만 일부 특정 경고 코드는 캐시에만 적용되며 응답 메시지에만 적용될 수 있습니다. 새로운 경고 헤더는 기존 경고 헤더 뒤에 추가되어야 합니다. 캐시는 메시지와 함께 수신한 경고 헤더를 삭제해서는 안 됩니다. 그러나 캐시가 캐시 항목의 유효성을 성공적으로 검사한 경우에는 지정된 항목을 제외하고 해당 항목에 이전에 첨부된 모든 경고 헤더를 제거해야 합니다\(SHOULD\).\(SHOULD, MUST NOT, SHOULD\)

특정 경고 코드. 그런 다음 유효성 검사 응답에서 수신된 경고 헤더를 추가해야 합니다. 즉, 경고 헤더는 가장 최근의 관련 응답에 첨부되는 헤더입니다.\(MUST\)

여러 경고 헤더가 응답에 첨부되면 사용자 에이전트는 응답에 나타나는 순서대로 가능한 한 많은 경고 헤더를 사용자에게 알려야 합니다. 사용자에게 모든 경고를 알릴 수 없는 경우 사용자 에이전트는 다음 경험적 방법을 따라야 합니다.\(SHOULD\)

- - 응답 초기에 나타나는 경고는 응답 후반에 나타나는 경고보다 우선순위가 높습니다.

- - 사용자가 선호하는 문자 집합의 경고는 다른 문자 집합의 경고보다 우선하지만 경고 코드와 경고 에이전트는 동일합니다.

여러 경고 헤더를 생성하는 시스템은 이 사용자 에이전트 동작을 염두에 두고 헤더를 주문해야 합니다.\(SHOULD\)

경고와 관련된 캐시 동작에 대한 요구 사항은 섹션 13.1.2에 설명되어 있습니다.

이것은 현재 정의된 경고 코드 목록으로, 각각 영어로 된 권장 경고 텍스트와 그 의미에 대한 설명이 포함되어 있습니다.

110 응답이 오래되었습니다. 반환된 응답이 오래되었을 때마다 반드시 포함되어야 합니다.\(MUST\)

111 Revalidation failed 서버에 도달할 수 없어 응답을 재검증하려는 시도가 실패하여 캐시가 오래된 응답을 반환하는 경우 반드시 포함되어야 합니다.\(MUST\)

112 연결 끊김 작업은 캐시가 일정 기간 동안 네트워크의 나머지 부분과 의도적으로 연결이 끊어진 경우 포함되어야 합니다.\(SHOULD\)

113 캐시가 경험적으로 24시간보다 큰 신선도 수명을 선택하고 응답 기간이 24시간보다 큰 경우 경험적 만료를 포함해야 합니다.\(MUST\)

199 기타 경고 경고 텍스트에는 인간 사용자에게 표시되거나 기록될 임의의 정보가 포함될 수 있습니다. 이 경고를 수신하는 시스템은 사용자에게 경고를 표시하는 것 외에 자동화된 조치를 취해서는 안 됩니다.\(MAY, MUST NOT\)

214 적용되는 변환은 응답의 콘텐츠 코딩\(Content-Encoding 헤더에 지정된 대로\) 또는 미디어 유형\(Content-Type 헤더에 지정된 대로\)을 변경하는 변환을 적용하는 경우 중간 캐시 또는 프록시에 의해 추가되어야 합니다. 또는 이 경고 코드가 응답에 이미 나타나지 않는 한 응답의 엔터티 본문입니다.\(MUST\)

299 기타 지속적인 경고 경고 텍스트에는 인간 사용자에게 표시되거나 기록될 임의의 정보가 포함될 수 있습니다. 이 경고를 받은 시스템은 자동화된 조치를 취해서는 안 됩니다.\(MAY, MUST NOT\)

구현이 버전이 HTTP/1.0 이하인 하나 이상의 경고 헤더가 포함된 메시지를 보내는 경우 보낸 사람은 응답 날짜와 일치하는 경고 날짜를 각 경고 값에 포함해야 합니다.\(MUST\)

구현이 경고 날짜를 포함하는 경고 값이 있는 메시지를 수신하고 해당 경고 날짜가 응답의 날짜 값과 다른 경우 해당 경고 값은 저장, 전달 또는 전송하기 전에 메시지에서 삭제되어야 합니다. 그것을 사용하여. \(이것은 경고 헤더 필드의 순진한 캐싱으로 인한 나쁜 결과를 방지합니다.\) 이러한 이유로 모든 경고 값이 삭제되면 경고 헤더도 삭제되어야 합니다.\(MUST, MUST\)

---
## **14.47 WWW-Authenticate**

WWW-인증 응답 헤더 필드는 401\(인증되지 않음\) 응답 메시지에 포함되어야 합니다. 필드 값은 요청-URI에 적용할 수 있는 인증 체계와 매개변수를 나타내는 하나 이상의 챌린지로 구성됩니다.\(MUST\)

```text
       WWW-Authenticate  = "WWW-Authenticate" ":" 1#challenge
```

HTTP 액세스 인증 프로세스는 "HTTP 인증: 기본 및 다이제스트 액세스 인증"\[43\]에 설명되어 있습니다. 사용자 에이전트는 WWW-Authenticate 필드 값을 구문 분석할 때 둘 이상의 챌린지를 포함할 수 있으므로 특별한 주의를 기울이는 것이 좋습니다. 또는 둘 이상의 WWW-Authenticate 헤더 필드가 제공되는 경우 챌린지 자체의 내용에 쉼표로 구분된 값이 포함될 수 있습니다. 인증 매개변수 목록입니다.

---
# **15 Security Considerations**

이 섹션은 이 문서에 설명된 대로 HTTP/1.1의 보안 제한 사항을 응용 프로그램 개발자, 정보 제공자 및 사용자에게 알리기 위한 것입니다. 토론에는 드러난 문제에 대한 최종적인 해결책이 포함되어 있지는 않지만 보안 위험을 줄이기 위한 몇 가지 제안은 포함되어 있습니다.

---
## **15.1 Personal Information**

HTTP 클라이언트는 대량의 개인 정보\(예: 사용자 이름, 위치, 메일 주소, 비밀번호, 암호화 키 등\)에 접근하는 경우가 많으므로 이 정보가 HTTP 프로토콜을 통해 의도하지 않게 다른 소스로 유출되는 것을 방지하기 위해 매우 주의해야 합니다. . 우리는 사용자가 그러한 정보의 전파를 제어할 수 있는 편리한 인터페이스를 제공하고 설계자와 구현자는 이 영역에 특히 주의할 것을 강력히 권장합니다. 역사에 따르면 이 영역의 오류는 심각한 보안 및/또는 개인 정보 보호 문제를 야기하고 구현 회사에 매우 부정적인 평판을 초래하는 경우가 많습니다.\(SHOULD\)

---
### **15.1.1 Abuse of Server Log Information**

서버는 사용자의 독서 패턴이나 관심 주제를 식별할 수 있는 사용자 요청에 대한 개인 데이터를 저장할 수 있는 위치에 있습니다. 이 정보는 본질적으로 명백히 기밀이며 특정 국가에서는 해당 정보의 처리가 법률에 따라 제한될 수 있습니다. 데이터를 제공하기 위해 HTTP 프로토콜을 사용하는 사람들은 게시된 결과로 식별 가능한 개인의 허가 없이 해당 자료가 배포되지 않도록 할 책임이 있습니다.

---
### **15.1.2 Transfer of Sensitive Information**

일반 데이터 전송 프로토콜과 마찬가지로 HTTP는 전송되는 데이터의 내용을 규제할 수 없으며 특정 요청의 맥락에서 특정 정보 조각의 민감도를 결정하는 선험적 방법도 없습니다. 따라서 애플리케이션은 해당 정보 제공자에게 이 정보에 대해 가능한 한 많은 제어권을 제공해야 합니다. 이 맥락에서 특별히 언급할 가치가 있는 네 가지 헤더 필드는 Server, Via, Referer 및 From입니다.\(SHOULD\)

서버의 특정 소프트웨어 버전을 공개하면 서버 시스템이 보안 허점이 있는 것으로 알려진 소프트웨어에 대한 공격에 더욱 취약해질 수 있습니다. 구현자는 서버 헤더 필드를 구성 가능한 옵션으로 만들어야 합니다.\(SHOULD\)

네트워크 방화벽을 통해 포털 역할을 하는 프록시는 방화벽 뒤의 호스트를 식별하는 헤더 정보 전송과 관련하여 특별한 예방 조치를 취해야 합니다. 특히 방화벽 뒤에서 생성된 모든 Via 필드를 제거하거나 삭제된 버전으로 교체해야 합니다.\(SHOULD, SHOULD\)

Referer 헤더를 사용하면 읽기 패턴을 연구하고 역방향 링크를 그릴 수 있습니다. 매우 유용할 수 있지만 사용자 세부 정보가 포함된 정보와 분리되지 않으면 그 힘이 남용될 수 있습니다.

추천자. 개인 정보가 제거된 경우에도 Referer 헤더는 게시가 부적절한 개인 문서의 URI를 나타낼 수 있습니다.

보낸 사람 필드에 전송된 정보는 사용자의 개인 정보 보호 이익이나 해당 사이트의 보안 정책과 충돌할 수 있으므로 사용자가 필드의 내용을 비활성화, 활성화 및 수정할 수 없는 상태에서는 전송되어서는 안 됩니다. 사용자는 사용자 기본 설정 또는 애플리케이션 기본 구성 내에서 이 필드의 내용을 설정할 수 있어야 합니다.\(SHOULD NOT, MUST\)

필수는 아니지만 사용자가 보낸 사람 및 추천자 정보 전송을 활성화하거나 비활성화할 수 있도록 편리한 토글 인터페이스를 제공하는 것이 좋습니다.

User-Agent\(섹션 14.43\) 또는 Server\(섹션 14.38\) 헤더 필드는 때때로 특정 클라이언트나 서버에 악용될 수 있는 특정 보안 허점이 있는지 확인하는 데 사용될 수 있습니다. 불행하게도 이와 동일한 정보는 현재 HTTP에 더 나은 메커니즘이 없는 다른 귀중한 목적으로 자주 사용됩니다.

---
### **15.1.3 Encoding Sensitive Information in URI's**

링크의 소스는 개인 정보이거나 개인 정보 소스를 공개할 수 있으므로 추천자 필드 전송 여부를 사용자가 선택할 수 있도록 하는 것이 좋습니다. 예를 들어, 브라우저 클라이언트에는 공개/익명 탐색을 위한 토글 스위치가 있을 수 있으며, 이를 통해 추천자 및 보낸 사람 정보 전송을 각각 활성화/비활성화할 수 있습니다.

참조 페이지가 보안 프로토콜로 전송된 경우 클라이언트는 \(비보안\) HTTP 요청에 Referer 헤더 필드를 포함해서는 안 됩니다.\(SHOULD NOT\)

HTTP 프로토콜을 사용하는 서비스 작성자는 민감한 데이터 제출을 위해 GET 기반 양식을 사용해서는 안 됩니다. 이렇게 하면 이 데이터가 요청-URI에 인코딩되기 때문입니다. 많은 기존 서버, 프록시 및 사용자 에이전트는 제3자가 볼 수 있는 위치에 요청 URI를 기록합니다. 서버는 대신 POST 기반 양식 제출을 사용할 수 있습니다.\(SHOULD NOT\)

---
### **15.1.4 Privacy Issues Connected to Accept Headers**

Accept 요청 헤더는 액세스되는 모든 서버에 사용자에 대한 정보를 공개할 수 있습니다. 특히 Accept-Language 헤더는 특정 언어에 대한 이해가 종종 불가능하기 때문에 사용자가 사적인 성격으로 간주하는 정보를 공개할 수 있습니다.

특정 인종 그룹의 구성원과 밀접한 관련이 있습니다. 모든 요청에서 전송될 Accept-Language 헤더의 내용을 구성하는 옵션을 제공하는 사용자 에이전트는 구성 프로세스에 사용자가 관련된 개인 정보 보호 손실을 인식하도록 하는 메시지를 포함하도록 하는 것이 좋습니다.

개인정보 보호 손실을 제한하는 접근 방식은 사용자 에이전트가 기본적으로 Accept-Language 헤더 전송을 생략하고, 감지하는 경우 서버에 Accept-Language 헤더 전송을 시작할지 여부를 사용자에게 묻는 것입니다. 서버에서 생성된 Vary 응답 헤더 필드의 경우 이러한 전송으로 인해 서비스 품질이 향상될 수 있습니다.

모든 요청에서 전송되는 정교한 사용자 정의 승인 헤더 필드\(특히 여기에 품질 값이 포함된 경우\)는 서버에서 상대적으로 안정적이고 수명이 긴 사용자 식별자로 사용될 수 있습니다. 이러한 사용자 식별자를 사용하면 콘텐츠 제공자가 클릭 추적을 수행할 수 있으며, 협력 콘텐츠 제공자가 서버 간 클릭 추적 또는 개별 사용자의 양식 제출을 일치시킬 수 있습니다. 프록시 뒤에 있지 않은 많은 사용자의 경우 사용자 에이전트를 실행하는 호스트의 네트워크 주소도 오랫동안 지속되는 사용자 식별자 역할을 합니다. 개인 정보 보호를 강화하기 위해 프록시를 사용하는 환경에서 사용자 에이전트는 최종 사용자에게 허용 헤더 구성 옵션을 제공하는 데 보수적이어야 합니다. 극단적인 개인 정보 보호 조치로서 프록시는 중계된 요청에서 승인 헤더를 필터링할 수 있습니다. 높은 수준의 헤더 구성 기능을 제공하는 범용 사용자 에이전트는 관련될 수 있는 개인 정보 보호 손실에 대해 사용자에게 경고해야 합니다\(SHOULD\).\(SHOULD\)

---
## **15.2 Attacks Based On File and Path Names**

HTTP 원본 서버의 구현은 HTTP 요청에 의해 반환되는 문서를 서버 관리자가 의도한 문서로만 제한하도록 주의해야 합니다. HTTP 서버가 HTTP URI를 파일 시스템 호출로 직접 변환하는 경우 서버는 HTTP 클라이언트에 전달하려는 의도가 아닌 파일을 제공하지 않도록 특별한 주의를 기울여야 합니다. 예를 들어 UNIX, Microsoft Windows 및 기타 운영 체제에서는 ".."를 경로 구성 요소로 사용하여 현재 디렉터리 수준 위의 디렉터리 수준을 나타냅니다. 이러한 시스템에서 HTTP 서버는 HTTP 서버를 통해 액세스할 수 있도록 의도된 리소스 외부의 리소스에 대한 액세스를 허용하는 경우 Request-URI에서 그러한 구성을 허용하지 않아야 합니다\(MUST\). 마찬가지로, 서버 내부에서만 참조하기 위한 파일\(액세스 제어 파일, 구성 파일, 스크립트 코드 등\)은 민감한 정보를 포함할 수 있으므로 부적절한 검색으로부터 보호해야 합니다. 경험에 따르면 이러한 HTTP 서버 구현의 사소한 버그가 보안 위험으로 바뀌는 것으로 나타났습니다.\(SHOULD, MUST, MUST, MUST\)

---
## **15.3 DNS Spoofing**

HTTP를 사용하는 클라이언트는 도메인 이름 서비스에 크게 의존하므로 일반적으로 IP 주소와 DNS 이름의 고의적인 잘못된 연결을 기반으로 하는 보안 공격에 취약합니다. 클라이언트는 IP 번호/DNS 이름 연결의 지속적인 유효성을 가정할 때 주의해야 합니다.

특히, HTTP 클라이언트는 이전 호스트 이름 조회 결과를 캐싱하는 대신 IP 번호/DNS 이름 연결 확인을 위해 이름 확인자에 의존해야 합니다. 많은 플랫폼은 이미 적절한 경우 호스트 이름 조회를 로컬로 캐시할 수 있으며 그렇게 하도록 구성되어야 합니다. 그러나 이러한 조회를 캐시하는 것이 적절하지만, 이름 서버에서 보고한 TTL\(Time To Live\) 정보로 인해 캐시된 정보가 계속 유용할 가능성이 있는 경우에만 가능합니다.\(SHOULD, SHOULD\)

HTTP 클라이언트가 성능 향상을 위해 호스트 이름 조회 결과를 캐시하는 경우 DNS가 보고하는 TTL 정보를 관찰해야 합니다.\(MUST\)

HTTP 클라이언트가 이 규칙을 준수하지 않으면 이전에 액세스한 서버의 IP 주소가 변경될 때 스푸핑될 수 있습니다. 네트워크 번호 재지정이 점차 보편화될 것으로 예상됨에 따라\[24\], 이러한 형태의 공격 가능성도 커질 것입니다. 따라서 이 요구 사항을 준수하면 잠재적인 보안 취약성이 줄어듭니다.

또한 이 요구 사항은 동일한 DNS 이름을 사용하는 복제된 서버에 대한 클라이언트의 로드 균형 조정 동작을 개선하고 사용자가 해당 전략을 사용하는 사이트에 액세스할 때 실패할 가능성을 줄입니다.

---
## **15.4 Location Headers and Spoofing**

단일 서버가 서로 신뢰하지 않는 여러 조직을 지원하는 경우 해당 조직의 제어 하에 생성된 응답에서 Location 및 Content-Location 헤더의 값을 확인하여 해당 조직이 리소스를 무효화하려고 시도하지 않는지 확인해야 합니다. 그들에게는 권한이 없습니다.\(MUST\)

---
## **15.5 Content-Disposition Issues**

HTTP에서 종종 구현되는 Content-Disposition\(섹션 19.5.1 참조\) 헤더가 파생되는 RFC 1806 \[35\]에는 여러 가지 매우 심각한 보안 고려 사항이 있습니다. Content-Disposition은 HTTP 표준의 일부는 아니지만 광범위하게 구현되므로 구현자를 위한 사용 및 위험을 문서화하고 있습니다. 자세한 내용은 RFC 2183 \[49\]\(RFC 1806 업데이트\)을 참조하세요.

---
## **15.6 Authentication Credentials and Idle Clients**

기존 HTTP 클라이언트와 사용자 에이전트는 일반적으로 인증 정보를 무기한 유지합니다. HTTP/1.1. 서버가 클라이언트에게 캐시된 자격 증명을 삭제하도록 지시하는 방법을 제공하지 않습니다. 이는 HTTP에 대한 추가 확장이 필요한 심각한 결함입니다. 자격 증명 캐싱이 애플리케이션의 보안 모델을 방해할 수 있는 상황은 다음을 포함하지만 이에 국한되지는 않습니다.

- - 서버가 클라이언트가 사용자에게 자격 증명을 다시 묻는 원인이 될 수 있는 오랜 기간 동안 유휴 상태였던 클라이언트.

- - 세션 종료 표시\(페이지의 '로그아웃' 또는 '커밋' 버튼과 같은\)를 포함하는 애플리케이션은 클라이언트가 자격 증명을 유지할 더 이상 이유가 없다는 것을 애플리케이션의 서버 측에서 '인식'합니다.

이에 대해서는 현재 별도의 연구가 진행 중이다. 이 문제에는 여러 가지 해결 방법이 있으며 화면 보호기, 유휴 시간 초과 및 이 문제에 내재된 보안 문제를 완화하는 기타 방법에 비밀번호 보호를 사용하는 것이 좋습니다. 특히, 자격 증명을 캐시하는 사용자 에이전트는 사용자 제어 하에 캐시된 자격 증명을 삭제하기 위한 쉽게 액세스할 수 있는 메커니즘을 제공하도록 권장됩니다.

---
## **15.7 Proxies and Caching**

본질적으로 HTTP 프록시는 중간자이며 중간자 공격의 기회를 나타냅니다. 프록시가 실행되는 시스템이 손상되면 심각한 보안 및 개인 정보 보호 문제가 발생할 수 있습니다. 프록시는 보안 관련 정보, 개별 사용자 및 조직에 대한 개인 정보, 사용자 및 콘텐츠 제공자에 속한 독점 정보에 액세스할 수 있습니다. 손상된 프록시 또는 보안 및 개인 정보 보호 고려 사항을 고려하지 않고 구현 또는 구성된 프록시는 광범위한 잠재적 공격에 사용될 수 있습니다.

프록시 운영자는 민감한 정보를 포함하거나 전송하는 시스템을 보호하는 것처럼 프록시가 실행되는 시스템을 보호해야 합니다. 특히, 프록시에서 수집된 로그 정보에는 매우 민감한 개인정보나 조직에 대한 정보가 포함되어 있는 경우가 많습니다. 로그 정보는 주의 깊게 보호되어야 하며, 적절한 사용 지침을 개발하고 따라야 합니다. \(15.1.1항\)

캐싱 프록시는 캐시의 콘텐츠가 악의적으로 악용될 수 있는 매력적인 대상을 나타내기 때문에 추가적인 잠재적 취약성을 제공합니다. HTTP 요청이 완료된 후에도 캐시 콘텐츠가 지속되기 때문에 캐시에 대한 공격은 사용자가 정보가 네트워크에서 제거되었다고 믿은 후에도 오랫동안 정보를 공개할 수 있습니다. 따라서 캐시 내용은 민감한 정보로 보호되어야 합니다.

프록시 구현자는 디자인 및 코딩 결정과 프록시 운영자에게 제공하는 구성 옵션\(특히 기본 구성\)이 개인 정보 보호 및 보안에 미치는 영향을 고려해야 합니다.

프록시 사용자는 자신이 프록시를 실행하는 사람보다 더 신뢰할 수 없다는 점을 인식해야 합니다. HTTP 자체로는 이 문제를 해결할 수 없습니다.

적절한 경우 암호화를 현명하게 사용하면 광범위한 보안 및 개인정보 공격으로부터 보호하는 데 충분할 수 있습니다. 이러한 암호화는 HTTP/1.1 사양의 범위를 벗어납니다.

---
### **15.7.1 Denial of Service Attacks on Proxies**

그들은 존재합니다. 그들은 방어하기가 어렵습니다. 연구는 계속됩니다. 조심하세요.

---
# **16 Acknowledgments**

이 사양에서는 David H. Crocker가 RFC 822\[9\]에 대해 정의한 확장된 BNF 및 일반 구성을 많이 사용합니다. 마찬가지로 Nathaniel Borenstein과 Ned Freed가 MIME에 대해 제공한 많은 정의를 재사용합니다\[7\]. 우리는 이 사양에 이를 포함시키면 HTTP와 인터넷 메일 메시지 형식 간의 관계에 대한 과거의 혼란을 줄이는 데 도움이 되기를 바랍니다.

HTTP 프로토콜은 수년에 걸쳐 상당히 발전했습니다. 이는 www-talk 메일링 리스트에 참여한 많은 사람들과 같은 크고 활동적인 개발자 커뮤니티의 혜택을 받았으며, HTTP와 World-Wide Web의 성공에 가장 큰 책임이 있는 커뮤니티는 바로 이 커뮤니티입니다. 일반적인. Marc Andreessen, Robert Cailliau, Daniel W. Connolly, Bob Denny, John Franks, Jean-Francois Groff, Phillip M. Hallam-Baker, Hakon W. Lie, Ari Luotonen, Rob McCool, Lou Montulli, Dave Raggett, Tony Sanders 및 Marc VanHeyningen은 프로토콜의 초기 측면을 정의하려는 노력에 대해 특별히 인정받을 자격이 있습니다.

이 문서는 HTTP-WG에 참여하는 모든 사람들의 의견으로부터 큰 도움을 받았습니다. 이미 언급된 사람들 외에도 다음 개인이 이 사양에 기여했습니다.

```text
       Gary Adams                  Ross Patterson
       Harald Tveit Alvestrand     Albert Lunde
       Keith Ball                  John C. Mallery
       Brian Behlendorf            Jean-Philippe Martin-Flatin
       Paul Burchard               Mitra
       Maurizio Codogno            David Morris
       Mike Cowlishaw              Gavin Nicol
       Roman Czyborra              Bill Perry
       Michael A. Dolan            Jeffrey Perry
       David J. Fiander            Scott Powers
       Alan Freier                 Owen Rees
       Marc Hedlund                Luigi Rizzo
       Greg Herlihy                David Robinson
       Koen Holtman                Marc Salomon
       Alex Hopmann                Rich Salz
       Bob Jernigan                Allan M. Schiffman
       Shel Kaphan                 Jim Seidman
       Rohit Khare                 Chuck Shotton
       John Klensin                Eric W. Sink
       Martijn Koster              Simon E. Spero
       Alexei Kosut                Richard N. Taylor
       David M. Kristol            Robert S. Thau
       Daniel LaLiberte            Bill (BearHeart) Weinman
       Ben Laurie                  Francois Yergeau
       Paul J. Leach               Mary Ellen Zurko
       Daniel DuBois               Josh Cohen
```

캐싱 디자인의 내용과 프리젠테이션의 대부분은 Shel Kaphan, Paul Leach, Koen Holtman, David Morris 및 Larry Masinter를 포함한 개인의 제안과 의견에 따른 것입니다.

범위 지정의 대부분은 원래 Ari Luotonen과 John Franks가 수행한 작업을 기반으로 하며 Steve Zilles의 추가 입력도 포함됩니다.

팔로알토의 "동굴인"들에게 감사드립니다. 넌 네가 누구인지 안다.

Jim Gettys\(이 문서의 현재 편집자\)는 특히 이 문서의 이전 편집자인 Roy Fielding과 John Klensin, Jeff Mogul, Paul Leach, Dave Kristol, Koen Holtman, John Franks, Josh Cohen, Alex Hopmann, Scott Lawrence와 Larry Masinter에게 도움을 주었습니다. 특히 "MUST/MAY/SHOULD" 감사를 수행한 Jeff Mogul과 Scott Lawrence에게 감사드립니다.\(MUST\)

Apache Group, Jigsaw의 저자인 Anselm Baird-Smith 및 Henrik Frystyk는 RFC 2068을 초기에 구현했으며 이 문서에서 수정하려는 많은 문제를 발견한 데 대해 감사를 표하고 싶습니다.

---
# **17 References**

\[1\] Alvestrand, H., "언어 식별을 위한 태그", RFC 1766, 1995년 3월.

\[2\] Anklesaria, F., McCahill, M., Lindner, P., Johnson, D., Torrey, D. 및 B. Alberti, "인터넷 Gopher 프로토콜\(분산 문서 검색 및 검색 프로토콜\)", RFC 1436 , 1993년 3월.

\[3\] Berners-Lee, T., "WWW의 범용 리소스 식별자", RFC 1630, 1994년 6월.

\[4\] Berners-Lee, T., Masinter, L. 및 M. McCahill, "Uniform Resource Locators\(URL\)", RFC 1738, 1994년 12월.

\[5\] Berners-Lee, T. 및 D. Connolly, "하이퍼텍스트 마크업 언어 - 2.0", RFC 1866, 1995년 11월.

\[6\] Berners-Lee, T., Fielding, R. 및 H. Frystyk, "하이퍼텍스트 전송 프로토콜 - HTTP/1.0", RFC 1945, 1996년 5월.

\[7\] Freed, N. 및 N. Borenstein, "다목적 인터넷 메일

- 확장\(MIME\) 파트 1: 인터넷 메시지 본문 형식", RFC 2045, 1996년 11월.

\[8\] Braden, R., "인터넷 호스트에 대한 요구 사항 - 통신 계층", STD 3, RFC 1123, 1989년 10월.

\[9\] Crocker, D., "ARPA 인터넷 문자 메시지 형식에 대한 표준", STD 11, RFC 822, 1982년 8월.

\[10\] Davis, F., Kahle, B., Morris, H., Salem, J., Shen, T., Wang, R., Sui, J. 및 M. Grinbaum, "WAIS 인터페이스 프로토콜 프로토타입 기능 사양 ," \(v1.5\), Thinking Machines Corporation, 1990년 4월.

```text
   [11] Fielding, R., "Relative Uniform Resource Locators", RFC 1808,
        June 1995.
```

\[12\] Horton, M. 및 R. Adams, "USENET 메시지 교환 표준", RFC 1036, 1987년 12월.

\[13\] Kantor, B. 및 P. Lapsley, "네트워크 뉴스 전송 프로토콜", RFC 977, 1986년 2월.

\[14\] Moore, K., "MIME\(다목적 인터넷 메일 확장\) 3부: 비ASCII 텍스트에 대한 메시지 헤더 확장", RFC 2047, 1996년 11월.

\[15\] Nebel, E. 및 L. Masinter, "HTML의 양식 기반 파일 업로드", RFC 1867, 1995년 11월.

```text
   [16] Postel, J., "Simple Mail Transfer Protocol", STD 10, RFC 821,
        August 1982.

   [17] Postel, J., "Media Type Registration Procedure", RFC 1590,
        November 1996.
```

\[18\] Postel, J. 및 J. Reynolds, "파일 전송 프로토콜", STD 9, RFC 959, 1985년 10월.

\[19\] Reynolds, J. 및 J. Postel, "할당된 번호", STD 2, RFC 1700, 1994년 10월.

\[20\] Sollins, K. 및 L. Masinter, "Uniform Resource Names에 대한 기능 요구 사항", RFC 1737, 1994년 12월.

\[21\] US-ASCII. 코드화된 문자 세트 - 정보 교환을 위한 7비트 미국 표준 코드입니다. 표준 ANSI X3.4-1986, ANSI, 1986.

```text
   [22] ISO-8859. International Standard -- Information Processing --
        8-bit Single-Byte Coded Graphic Character Sets --
        Part 1: Latin alphabet No. 1, ISO-8859-1:1987.
        Part 2: Latin alphabet No. 2, ISO-8859-2, 1987.
        Part 3: Latin alphabet No. 3, ISO-8859-3, 1988.
        Part 4: Latin alphabet No. 4, ISO-8859-4, 1988.
        Part 5: Latin/Cyrillic alphabet, ISO-8859-5, 1988.
        Part 6: Latin/Arabic alphabet, ISO-8859-6, 1987.
        Part 7: Latin/Greek alphabet, ISO-8859-7, 1987.
        Part 8: Latin/Hebrew alphabet, ISO-8859-8, 1988.
        Part 9: Latin alphabet No. 5, ISO-8859-9, 1990.
```

\[23\] Meyers, J. 및 M. Rose, "Content-MD5 헤더 필드", RFC 1864, 1995년 10월.

\[24\] Carpenter, B. 및 Y. Rekhter, "번호 재설정 작업 필요", RFC 1900, 1996년 2월.

```text
   [25] Deutsch, P., "GZIP file format specification version 4.3", RFC
        1952, May 1996.
```

\[26\] Venkata N. Padmanabhan, Jeffrey C. Mogul. "HTTP 대기 시간 개선", 컴퓨터 네트워크 및 ISDN 시스템, v. 28, pp. 25-35, 1995년 12월. Proc. 제2회 국제 WWW 컨퍼런스 '94: 모자이크와 웹, 1994년 10월, http://www.ncsa.uiuc.edu/SDG/IT94/Proceedings/DDay/mogul/HTTPLatency.html에서 볼 수 있습니다.

\[27\] 조 터치\(Joe Touch\), 존 하이데만\(John Heidemann\), 카티아 오브라츠카\(Katia Obraczka\). "HTTP 성능 분석", <URL: http://www.isi.edu/touch/pubs/http-perf96/\>, ISI 연구 보고서 ISI/RR-98-463, \(1996년 8월 원본 보고서\), USC/정보과학연구소, 1998년 8월.

\[28\] Mills, D., "네트워크 시간 프로토콜\(버전 3\) 사양, 구현 및 분석", RFC 1305, 1992년 3월.

```text
   [29] Deutsch, P., "DEFLATE Compressed Data Format Specification
        version 1.3", RFC 1951, May 1996.
```

\[30\] S. Spero, "HTTP 성능 문제 분석,"

- http://sunsite.unc.edu/mdma-release/http-prob.html.

\[31\] Deutsch, P. 및 J. Gailly, "ZLIB 압축 데이터 형식

- 사양 버전 3.3", RFC 1950, 1996년 5월.

\[32\] 프랭크스, J., 할람-베이커, P., 호스테틀러, J., 리치, P.,

- Luotonen, A., Sink, E. 및 L. Stewart, "HTTP 확장: 다이제스트 액세스 인증", RFC 2069, 1997년 1월.

\[33\] Fielding, R., Gettys, J., Mogul, J., Frystyk, H. 및 T.

- Berners-Lee, "하이퍼텍스트 전송 프로토콜 - HTTP/1.1", RFC 2068, 1997년 1월.

\[34\] Bradner, S., "요구 사항 수준을 나타 내기 위해 RFC에 사용되는 핵심 단어", BCP 14, RFC 2119, 1997년 3월.

\[35\] Troost, R. 및 Dorner, S., "프레젠테이션 전달

- 인터넷 메시지의 정보: 콘텐츠 처리 헤더", RFC 1806, 1995년 6월.

\[36\] Mogul, J., Fielding, R., Gettys, J. 및 H. Frystyk, "HTTP 버전 번호의 사용 및 해석", RFC 2145, 1997년 5월. \[jg639\]

```text
   [37] Palme, J., "Common Internet Message Headers", RFC 2076, February
        1997. [jg640]
```

\[38\] Yergeau, F., "UTF-8, 유니코드 및 ISO-10646의 변환 형식", RFC 2279, 1998년 1월. \[jg641\]

\[39\] Nielsen, H.F., Gettys, J., Baird-Smith, A., Prud'hommeaux, E., Lie, H. 및 C. Lilley. "HTTP/1.1, CSS1 및 PNG의 네트워크 성능 효과", ACM SIGCOMM '97 간행물, 프랑스 칸, 1997년 9월.\[jg642\]

\[40\] Freed, N. 및 N. Borenstein, "다목적 인터넷 메일 확장\(MIME\) 2부: 미디어 유형", RFC 2046, 1996년 11월. \[jg643\]

\[41\] Alvestrand, H., "문자 집합 및 언어에 대한 IETF 정책", BCP 18, RFC 2277, 1998년 1월. \[jg644\]

\[42\] Berners-Lee, T., Fielding, R. 및 L. Masinter, "URI\(Uniform Resource Identifier\): 일반 구문 및 의미", RFC 2396, 1998년 8월. \[jg645\]

\[43\] Franks, J., Hallam-Baker, P., Hostetler, J., Lawrence, S., Leach, P., Luotonen, A., Sink, E. 및 L. Stewart, "HTTP 인증: 기본 및 다이제스트 액세스 인증", RFC 2617, 1999년 6월. \[jg646\]

\[44\] Luotonen, A., "웹 프록시 서버를 통한 TCP 기반 프로토콜 터널링", 진행 중인 작업. \[jg647\]

\[45\] Palme, J. 및 A. Hopmann, "MIME 전자 메일 캡슐화

- HTML\(MHTML\)과 같은 집계 문서", RFC 2110, 1997년 3월.

```text
   [46] Bradner, S., "The Internet Standards Process -- Revision 3", BCP
        9, RFC 2026, October 1996.

   [47] Masinter, L., "Hyper Text Coffee Pot Control Protocol
        (HTCPCP/1.0)", RFC 2324, 1 April 1998.
```

\[48\] ​​Freed, N. 및 N. Borenstein, "다목적 인터넷 메일 확장\(MIME\) 5부: 적합성 기준 및 예", RFC 2049, 1996년 11월.

\[49\] Troost, R., Dorner, S. 및 K. Moore, "인터넷 메시지에서 프레젠테이션 정보 전달: 콘텐츠 처리 헤더 필드", RFC 2183, 1997년 8월.

---
# **18 Authors' Addresses**

Roy T. Fielding 정보 및 컴퓨터 공학 캘리포니아 대학교, Irvine Irvine, CA 92697-3425, USA

```text
   Fax: +1 (949) 824-1715
   EMail: fielding@ics.uci.edu
```

James Gettys 월드 와이드 웹 컨소시엄 MIT 컴퓨터 공학 연구소 545 Technology Square Cambridge, MA 02139, USA

```text
   Fax: +1 (617) 258 8682
   EMail: jg@w3.org

   Jeffrey C. Mogul
   Western Research Laboratory
   Compaq Computer Corporation
   250 University Avenue
   Palo Alto, California, 94305, USA

   EMail: mogul@wrl.dec.com
```

Henrik Frystyk Nielsen 월드 와이드 웹 컨소시엄 MIT 컴퓨터 공학 연구소 545 Technology Square Cambridge, MA 02139, USA

```text
   Fax: +1 (617) 258 8682
   EMail: frystyk@w3.org

   Larry Masinter
   Xerox Corporation
   3333 Coyote Hill Road
   Palo Alto, CA 94034, USA

   EMail: masinter@parc.xerox.com

   Paul J. Leach
   Microsoft Corporation
   1 Microsoft Way
   Redmond, WA 98052, USA

   EMail: paulle@microsoft.com
```

Tim Berners-Lee 월드 와이드 웹 컨소시엄 MIT 컴퓨터 공학 연구소 소장 545 Technology Square Cambridge, MA 02139, USA

```text
   Fax: +1 (617) 258 8682
   EMail: timbl@w3.org
```

---
# **19 Appendices**
---
## **19.1 Internet Media Type message/http and application/http**

HTTP/1.1 프로토콜을 정의하는 것 외에도 이 문서는 인터넷 미디어 유형 "message/http" 및 "application/http"에 대한 사양 역할을 합니다. message/http 유형은 줄 길이 및 인코딩과 관련하여 모든 "메시지" 유형에 대한 MIME 제한 사항을 준수하는 경우 단일 HTTP 요청 또는 응답 메시지를 묶는 데 사용할 수 있습니다. application/http 유형은 하나 이상의 HTTP 요청 또는 응답 메시지\(혼합되지 않음\)의 파이프라인을 묶는 데 사용될 수 있습니다. 다음은 IANA \[17\]에 등록됩니다.

```text
       Media Type name:         message
       Media subtype name:      http
       Required parameters:     none
       Optional parameters:     version, msgtype
        version: The HTTP-Version number of the enclosed message
                 (e.g., "1.1"). If not present, the version can be
                 determined from the first line of the body.
        msgtype: The message type -- "request" or "response". If not
                 present, the type can be determined from the first
                 line of the body.
       Encoding considerations: only "7bit", "8bit", or "binary" are
                                permitted
       Security considerations: none

       Media Type name:         application
       Media subtype name:      http
       Required parameters:     none
       Optional parameters:     version, msgtype
        version: The HTTP-Version number of the enclosed messages
                 (e.g., "1.1"). If not present, the version can be
                 determined from the first line of the body.
        msgtype: The message type -- "request" or "response". If not
                 present, the type can be determined from the first
                 line of the body.
       Encoding considerations: HTTP messages enclosed by this type
                 are in "binary" format; use of an appropriate
                 Content-Transfer-Encoding is required when
                 transmitted via E-mail.
       Security considerations: none
```

---
## **19.2 Internet Media Type multipart/byteranges**

HTTP 206\(부분 콘텐츠\) 응답 메시지에 여러 범위의 콘텐츠\(겹치지 않는 여러 범위에 대한 요청에 대한 응답\)가 포함된 경우 이는 다중 부분 메시지 본문으로 전송됩니다. 이 목적을 위한 미디어 유형을 "multipart/byteranges"라고 합니다.

multipart/byteranges 미디어 유형에는 두 개 이상의 부분이 포함되어 있으며 각 부분에는 자체 Content-Type 및 Content-Range 필드가 있습니다. 필수 경계 매개변수는 각 신체 부위를 구분하는 데 사용되는 경계 문자열을 지정합니다.

```text
       Media Type name:         multipart
       Media subtype name:      byteranges
       Required parameters:     boundary
       Optional parameters:     none
       Encoding considerations: only "7bit", "8bit", or "binary" are
                                permitted
       Security considerations: none
```

예를 들어:

```text
   HTTP/1.1 206 Partial Content
   Date: Wed, 15 Nov 1995 06:25:24 GMT
   Last-Modified: Wed, 15 Nov 1995 04:58:08 GMT
   Content-type: multipart/byteranges; boundary=THIS_STRING_SEPARATES

   --THIS_STRING_SEPARATES
   Content-type: application/pdf
   Content-range: bytes 500-999/8000

   ...the first range...
   --THIS_STRING_SEPARATES
   Content-type: application/pdf
   Content-range: bytes 7000-7999/8000

   ...the second range
   --THIS_STRING_SEPARATES--

      Notes:
```

- 1\) 추가 CRLF는 엔터티의 첫 번째 경계 문자열 앞에 올 수 있습니다.

- 2\) RFC 2046 \[40\]에서는 경계 문자열을 인용하는 것을 허용하지만 일부 기존 구현에서는 인용된 경계 문자열을 잘못 처리합니다.

- 3\) 다수의 브라우저와 서버는 multipart/x-byteranges 미디어 유형을 사용하기 위해 byteranges 사양의 초기 초안으로 코딩되었습니다. 이는 HTTP/1.1에 문서화된 버전과 거의 호환되지만 완전히 호환되지는 않습니다.

---
## **19.3 Tolerant Applications**

이 문서에서는 HTTP/1.1 메시지 생성에 대한 요구 사항을 지정하지만 모든 애플리케이션이 구현에 있어서 올바른 것은 아닙니다. 따라서 운영 애플리케이션에서는 편차가 명확하게 해석될 수 있을 때마다 편차를 허용할 것을 권장합니다.

클라이언트는 상태 라인 구문 분석에 관대해야 하며 서버는 요청 라인 구문 분석 시 관대해야 합니다. 특히, 단일 SP만 필요하더라도 필드 사이에 SP 또는 HT 문자의 양에 관계없이 허용해야 합니다.\(SHOULD, SHOULD\)

메시지 헤더 필드의 줄 종결자는 시퀀스 CRLF입니다. 그러나 애플리케이션이 이러한 헤더를 구문 분석할 때 단일 LF를 줄 종결자로 인식하고 선행 CR을 무시하는 것이 좋습니다.

엔터티 본문의 문자 집합은 해당 본문 내에서 사용되는 문자 코드의 가장 낮은 공통 분모로 레이블을 지정해야 합니다. 단, 엔터티에 레이블을 지정하지 않는 것이 US-ASCII 또는 ISO-8859- 레이블로 엔터티에 레이블을 지정하는 것보다 선호됩니다. 1. 섹션 3.7.1 및 3.4.1을 참조하십시오.\(SHOULD\)

날짜 구문 분석 및 인코딩 요구 사항과 날짜 인코딩과 관련된 기타 잠재적인 문제에 대한 추가 규칙은 다음과 같습니다.

- - HTTP/1.1 클라이언트와 캐시는 50년 이상 미래로 보이는 RFC-850 날짜가 실제로 과거라고 가정해야 합니다\(이는 "2000년" 문제를 해결하는 데 도움이 됩니다\).\(SHOULD\)

- - HTTP/1.1 구현은 내부적으로 구문 분석된 만료 날짜를 적절한 값보다 빠른 것으로 나타낼 수 있지만 내부적으로 구문 분석된 만료 날짜를 적절한 값보다 이후로 나타내서는 안 됩니다.\(MUST NOT\)

- - 모든 만료 관련 계산은 반드시 GMT로 이루어져야 합니다. 현지 시간대는 연령이나 만료 시간의 계산이나 비교에 영향을 주어서는 안 됩니다.\(MUST, MUST NOT\)

- - HTTP 헤더가 GMT 이외의 시간대의 날짜 값을 잘못 전달하는 경우 가장 보수적인 가능한 변환을 사용하여 GMT로 변환해야 합니다.\(MUST\)

---
## **19.4 Differences Between HTTP Entities and RFC 2045 Entities**

HTTP/1.1은 인터넷 메일\(RFC 822 \[9\]\) 및 다목적 인터넷 메일 확장\(MIME \[7\]\)에 대해 정의된 많은 구성을 사용하여 엔터티가 개방형 다양한 표현과 확장 가능한 메커니즘으로 전송될 수 있도록 합니다. 그러나 RFC 2045에서는 메일에 대해 논의하고 HTTP에는 RFC 2045에 설명된 것과 다른 몇 가지 기능이 있습니다. 이러한 차이점은 바이너리 연결을 통해 성능을 최적화하고 새로운 미디어 유형을 더 자유롭게 사용할 수 있도록 신중하게 선택되었습니다. 비교를 더 쉽게 하고 일부 초기 HTTP 서버 및 클라이언트의 관행을 인정합니다.

이 부록은 HTTP가 RFC 2045와 다른 특정 영역을 설명합니다. 엄격한 MIME 환경에 대한 프록시 및 게이트웨이는 이러한 차이점을 인식하고 필요한 경우 적절한 변환을 제공해야 합니다. MIME 환경에서 HTTP로의 프록시 및 게이트웨이도 일부 변환이 필요할 수 있으므로 차이점을 인식해야 합니다.\(SHOULD\)

---
### **19.4.1 MIME-Version**

HTTP는 MIME 호환 프로토콜이 아닙니다. 그러나 HTTP/1.1 메시지에는 메시지를 구성하는 데 사용된 MIME 프로토콜 버전을 나타내는 단일 MIME-Version 일반 헤더 필드가 포함될 수 있습니다. MIME-Version 헤더 필드의 사용은 메시지가 MIME 프로토콜\(RFC 2045\[7\]에 정의된 대로\)을 완전히 준수함을 나타냅니다. 프록시/게이트웨이는 HTTP 메시지를 엄격한 MIME 환경으로 내보낼 때 완전한 규정 준수\(가능한 경우\)를 보장할 책임이 있습니다.\(MAY\)

```text
       MIME-Version   = "MIME-Version" ":" 1*DIGIT "." 1*DIGIT
```

MIME 버전 "1.0"은 HTTP/1.1에서 사용되는 기본값입니다. 그러나 HTTP/1.1 메시지 구문 분석 및 의미 체계는 MIME 사양이 아닌 이 문서에 의해 정의됩니다.

---
### **19.4.2 Conversion to Canonical Form**

RFC 2045\[7\]에서는 RFC 2049\[48\]의 섹션 4에 설명된 대로 인터넷 메일 엔터티가 전송되기 전에 정식 형식으로 변환되도록 요구합니다. 이 문서의 섹션 3.7.1에서는 HTTP를 통해 전송될 때 "텍스트" 미디어 유형의 하위 유형에 허용되는 형식을 설명합니다. RFC 2046에서는 "텍스트" 유형의 콘텐츠가 줄 바꿈을 CRLF로 나타내도록 요구하고 줄 외부에서 CR 또는 LF 사용을 금지합니다.

브레이크 시퀀스. HTTP에서는 메시지가 HTTP를 통해 전송될 때 CRLF, Bare CR 및 Bare LF가 텍스트 내용 내에서 줄바꿈을 표시하도록 허용합니다.

가능한 경우 HTTP에서 엄격한 MIME 환경으로의 프록시 또는 게이트웨이는 이 문서의 섹션 3.7.1에 설명된 텍스트 미디어 유형 내의 모든 줄 바꿈을 RFC 2049 표준 형식의 CRLF로 변환해야 합니다. 그러나 이것은 Content-Encoding의 존재와 HTTP가 옥텟 13 및 10을 사용하지 않는 일부 문자 세트의 사용을 허용하여 CR 및 LF를 표현한다는 사실로 인해 복잡해질 수 있습니다. 멀티바이트 문자 세트.\(SHOULD\)

구현자는 원본 콘텐츠가 이미 정식 형식인 경우를 제외하고 변환 시 원본 콘텐츠에 적용된 암호화 체크섬이 깨진다는 점에 유의해야 합니다. 따라서 HTTP에서 이러한 체크섬을 사용하는 모든 콘텐츠에는 표준 형식을 사용하는 것이 좋습니다.

---
### **19.4.3 Conversion of Date Formats**

HTTP/1.1은 날짜 비교 프로세스를 단순화하기 위해 제한된 날짜 형식 집합\(섹션 3.3.1\)을 사용합니다. 다른 프로토콜의 프록시와 게이트웨이는 메시지에 있는 모든 Date 헤더 필드가 HTTP/1.1 형식 중 하나를 준수하는지 확인하고 필요한 경우 날짜를 다시 작성해야 합니다\(SHOULD\).\(SHOULD\)

---
### **19.4.4 Introduction of Content-Encoding**

RFC 2045에는 HTTP/1.1의 Content-Encoding 헤더 필드와 동일한 개념이 포함되어 있지 않습니다. 이는 미디어 유형에 대한 수정자 역할을 하기 때문에 HTTP에서 MIME 호환 프로토콜로의 프록시 및 게이트웨이는 메시지를 전달하기 전에 Content-Type 헤더 필드의 값을 변경하거나 Entity-Body를 디코딩해야 합니다. \(인터넷 메일에 대한 Content-Type의 일부 실험적 응용 프로그램에서는 Content-Encoding과 동등한 기능을 수행하기 위해 ";conversions=<content-coding\>"이라는 미디어 유형 매개 변수를 사용했습니다. 그러나 이 매개 변수는 RFC 2045의 일부가 아닙니다. \)\(MUST\)

---
### **19.4.5 No Content-Transfer-Encoding**

HTTP는 RFC 2045의 CTE\(Content-Transfer-Encoding\) 필드를 사용하지 않습니다. MIME 호환 프로토콜에서 HTTP로의 프록시 및 게이트웨이는 전달하기 전에 모든 비식별 CTE\("quoted-printable" 또는 "base64"\) 인코딩을 제거해야 합니다. HTTP 클라이언트에 대한 응답 메시지입니다.\(MUST\)

HTTP에서 MIME 호환 프로토콜까지의 프록시와 게이트웨이는 메시지가 해당 프로토콜에서 안전한 전송을 위해 올바른 형식과 인코딩으로 되어 있는지 확인하는 역할을 합니다.

전송"은 사용되는 프로토콜의 제한 사항에 의해 정의됩니다. 이러한 프록시 또는 게이트웨이는 대상 프로토콜을 통한 안전한 전송 가능성을 향상시키는 경우 적절한 콘텐츠 전송 인코딩으로 데이터에 라벨을 지정해야 합니다.\(SHOULD\)

---
### **19.4.6 Introduction of Transfer-Encoding**

HTTP/1.1에는 Transfer-Encoding 헤더 필드\(섹션 14.41\)가 도입되었습니다. 프록시/게이트웨이는 MIME 호환 프로토콜을 통해 메시지를 전달하기 전에 모든 전송 코딩을 제거해야 합니다.\(MUST\)

"청크된" 전송 코딩\(섹션 3.6\)을 디코딩하는 프로세스는 의사 코드로 다음과 같이 표현될 수 있습니다.

```text
       length := 0
       read chunk-size, chunk-extension (if any) and CRLF
       while (chunk-size > 0) {
          read chunk-data and CRLF
          append chunk-data to entity-body
          length := length + chunk-size
          read chunk-size and CRLF
       }
       read entity-header
       while (entity-header not empty) {
          append entity-header to existing header fields
          read entity-header
       }
       Content-Length := length
       Remove "chunked" from Transfer-Encoding
```

---
### **19.4.7 MHTML and Line Length Limitations**

MHTML \[45\] 구현과 코드를 공유하는 HTTP 구현은 MIME 줄 길이 제한을 인식해야 합니다. HTTP에는 이러한 제한이 없으므로 HTTP는 긴 줄을 접지 않습니다. HTTP에 의해 전송되는 MHTML 메시지는 줄 길이 제한, 접기, 정규화 등을 포함하여 MHTML의 모든 규칙을 따릅니다. HTTP는 모든 메시지 본문을 페이로드\(섹션 3.7.2 참조\)로 전송하고 내용이나 MIME 헤더를 해석하지 않기 때문입니다. 그 안에 포함될 수 있는 라인입니다.

---
## **19.5 Additional Features**

RFC 1945 및 RFC 2068은 일부 기존 HTTP 구현에서 사용되는 프로토콜 요소를 문서화하지만 대부분의 HTTP/1.1 애플리케이션에서 일관되고 정확하게 사용되지는 않습니다. 구현자는 이러한 기능을 알고 있어야 하지만 다른 HTTP/1.1 응용 프로그램에서의 존재나 상호 운용성에 의존할 수는 없습니다. 이들 중 일부

제안된 실험적 기능을 설명하고 일부는 실험적 배포에서 부족한 것으로 확인되었지만 현재 기본 HTTP/1.1 사양에서 해결되는 기능을 설명합니다.

SMTP 및 MIME의 Content-Disposition 및 Title과 같은 여러 다른 헤더도 종종 구현됩니다\(RFC 2076 \[37\] 참조\).

---
### **19.5.1 Content-Disposition**

Content-Disposition 응답 헤더 필드는 사용자가 콘텐츠를 파일에 저장하도록 요청하는 경우 원본 서버가 기본 파일 이름을 제안하는 수단으로 제안되었습니다. 이 사용법은 RFC 1806 \[35\]의 Content-Disposition 정의에서 파생되었습니다.

```text
        content-disposition = "Content-Disposition" ":"
                              disposition-type *( ";" disposition-parm )
        disposition-type = "attachment" | disp-extension-token
        disposition-parm = filename-parm | disp-extension-parm
        filename-parm = "filename" "=" quoted-string
        disp-extension-token = token
        disp-extension-parm = token "=" ( token | quoted-string )
```

예는 다음과 같습니다

```text
        Content-Disposition: attachment; filename="fname.ext"
```

수신 사용자 에이전트는 현재 HTTP 구현에 적용되는 것으로 여겨지는 유일한 매개변수인 filename-parm 매개변수에 있는 모든 디렉토리 경로 정보를 존중해서는 안 됩니다. 파일 이름은 터미널 구성 요소로만 처리되어야 합니다.\(SHOULD NOT, SHOULD\)

이 헤더가 application/octet-stream 콘텐츠 유형의 응답에 사용되면 사용자 에이전트가 응답을 표시하지 않고 '다른 이름으로 응답 저장...' 대화 상자를 직접 입력해야 한다는 암시가 암시됩니다.

콘텐츠 처리 보안 문제에 대해서는 섹션 15.5를 참조하세요.

---
## **19.6 Compatibility with Previous Versions**

이전 버전과의 호환성을 요구하는 것은 프로토콜 사양의 범위를 벗어납니다. 그러나 HTTP/1.1은 이전 버전을 쉽게 지원할 수 있도록 의도적으로 설계되었습니다. 이 사양을 작성하는 시점\(1996\)에 상용 HTTP/1.1 서버가 다음을 기대한다는 점은 주목할 가치가 있습니다.

```text
      - recognize the format of the Request-Line for HTTP/0.9, 1.0, and
        1.1 requests;

      - understand any valid request in the format of HTTP/0.9, 1.0, or
        1.1;
```

- - 클라이언트가 사용하는 것과 동일한 주요 버전의 메시지로 적절하게 응답합니다.

그리고 우리는 HTTP/1.1 클라이언트가 다음을 기대합니다:

```text
      - recognize the format of the Status-Line for HTTP/1.0 and 1.1
        responses;
```

- - HTTP/0.9, 1.0 또는 1.1 형식의 유효한 응답을 이해합니다.

대부분의 HTTP/1.0 구현에서 각 연결은 요청 전에 클라이언트에 의해 설정되고 응답을 보낸 후 서버에 의해 닫힙니다. 일부 구현에서는 RFC 2068 \[33\]의 섹션 19.7.1에 설명된 지속 연결의 Keep-Alive 버전을 구현합니다.

---
### **19.6.1 Changes from HTTP/1.0**

이 섹션에서는 HTTP/1.0 버전과 HTTP/1.1 버전 간의 주요 차이점을 요약합니다.

19.6.1.1 멀티 홈 웹 서버를 단순화하고 IP 주소를 보존하기 위한 변경 사항

클라이언트와 서버가 Host 요청 헤더를 지원하고, Host 요청 헤더\(섹션 14.23\)가 HTTP/1.1 요청에서 누락된 경우 오류를 보고하고, 절대 URI를 허용하는 요구 사항\(섹션 5.1.2\)이 가장 중요한 요구 사항 중 하나입니다. 이 사양에 정의된 변경 사항.

이전 HTTP/1.0 클라이언트는 IP 주소와 서버의 일대일 관계를 가정했습니다. 해당 요청이 전달된 IP 주소 외에 요청의 의도된 서버를 구별하기 위한 확립된 메커니즘이 없었습니다. 위에 설명된 변경 사항을 통해 인터넷은 이전 HTTP 클라이언트가 더 이상 일반적이지 않게 되면 단일 IP 주소에서 여러 웹 사이트를 지원할 수 있게 되어 단일 호스트에 많은 IP 주소를 할당하면 심각한 문제가 발생하는 대규모 운영 웹 서버를 크게 단순화할 수 있습니다. . 또한 인터넷은 루트 수준 HTTP URL에서 특수 목적 도메인 이름을 사용할 수 있도록 허용하는 유일한 목적으로 할당된 IP 주소를 복구할 수 있습니다. 웹의 성장 속도와 이미 배포된 서버 수를 고려하면 이는 매우

모든 HTTP 구현\(기존 HTTP/1.0 애플리케이션 업데이트 포함\)이 다음 요구 사항을 올바르게 구현하는 것이 중요합니다.

- - 클라이언트와 서버 모두 호스트 요청 헤더를 지원해야 합니다.\(MUST\)

- - HTTP/1.1 요청을 보내는 클라이언트는 Host 헤더를 보내야 합니다.\(MUST\)

- - HTTP/1.1 요청에 호스트 요청 헤더가 포함되지 않은 경우 서버는 400\(잘못된 요청\) 오류를 보고해야 합니다.\(MUST\)

```text
      - Servers MUST accept absolute URIs.
```

---
### **19.6.2 Compatibility with HTTP/1.0 Persistent Connections**

일부 클라이언트 및 서버는 HTTP/1.0 클라이언트 및 서버의 일부 이전 영구 연결 구현과 호환되기를 원할 수 있습니다. HTTP/1.0의 영구 연결은 기본 동작이 아니기 때문에 명시적으로 협상됩니다. 지속적인 연결의 HTTP/1.0 실험적 구현에는 결함이 있으며 HTTP/1.1의 새로운 기능은 이러한 문제를 수정하도록 설계되었습니다. 문제는 일부 기존 1.0 클라이언트가 Connection을 이해하지 못하는 프록시 서버에 Keep-Alive를 보낼 수 있다는 것입니다. 그러면 이 프록시 서버가 이를 다음 인바운드 서버로 잘못 전달하여 Keep-Alive 연결을 설정하고 중단을 초래할 수 있습니다. 응답 종료를 기다리는 HTTP/1.0 프록시입니다. 결과적으로 HTTP/1.0 클라이언트는 프록시와 통신할 때 Keep-Alive를 사용하지 못하도록 방지되어야 합니다.

그러나 프록시와의 대화는 지속적인 연결의 가장 중요한 용도이므로 금지하는 것은 분명히 용납될 수 없습니다. 따라서 지속적인 연결이 필요함을 나타내기 위한 다른 메커니즘이 필요하며, 이는 연결을 무시하는 이전 프록시와 통신할 때에도 안전하게 사용할 수 있습니다. 지속적인 연결은 HTTP/1.1 메시지의 기본값입니다. 비지속성을 선언하기 위한 새로운 키워드\(Connection: close\)를 도입합니다. 섹션 14.10을 참조하세요.

지속적인 연결의 원래 HTTP/1.0 형식\(Connection: Keep-Alive 및 Keep-Alive 헤더\)은 RFC 2068에 문서화되어 있습니다. \[33\]

---
### **19.6.3 Changes from RFC 2068**

이 사양은 키워드 사용을 수정하고 명확하게 하기 위해 신중하게 감사되었습니다. RFC 2068은 RFC 2119 \[34\]에 제시된 규칙과 관련하여 많은 문제를 안고 있었습니다.

인바운드 서버 오류\(예: DNS 오류\)에 사용해야 하는 오류 코드를 명확히 했습니다. \(섹션 10.5.5\).

CREATE에는 리소스가 처음 생성될 때 Etag를 보내야 하는 경쟁이 있었습니다. \(섹션 10.2.2\).

Content-Base는 사양에서 삭제되었습니다. 널리 구현되지 않았으며 강력한 확장 메커니즘 없이는 간단하고 안전하게 도입할 수 있는 방법이 없습니다. 또한 MHTML \[45\]에서도 유사하지만 동일하지는 않은 방식으로 사용됩니다.

```text
   Transfer-coding and message lengths all interact in ways that
   required fixing exactly when chunked encoding is used (to allow for
   transfer encoding that may not be self delimiting); it was important
   to straighten out exactly how message lengths are computed. (Sections
   3.6, 4.4, 7.2.2, 13.5.2, 14.13, 14.16)

   A content-coding of "identity" was introduced, to solve problems
   discovered in caching. (section 3.5)

   Quality Values of zero should indicate that "I don't want something"
   to allow clients to refuse a representation. (Section 3.9)

   The use and interpretation of HTTP version numbers has been clarified
   by RFC 2145. Require proxies to upgrade requests to highest protocol
   version they support to deal with problems discovered in HTTP/1.0
   implementations (Section 3.1)

   Charset wildcarding is introduced to avoid explosion of character set
   names in accept headers. (Section 14.2)

   A case was missed in the Cache-Control model of HTTP/1.1; s-maxage
   was introduced to add this missing case. (Sections 13.4, 14.8, 14.9,
   14.9.3)

   The Cache-Control: max-age directive was not properly defined for
   responses. (Section 14.9.3)

   There are situations where a server (especially a proxy) does not
   know the full length of a response but is capable of serving a
   byterange request. We therefore need a mechanism to allow byteranges
   with a content-range not indicating the full length of the message.
   (Section 14.16)

   Range request responses would become very verbose if all meta-data
   were always returned; by allowing the server to only send needed
   headers in a 206 response, this problem can be avoided. (Section
   10.2.7, 13.5.3, and 14.27)

   Fix problem with unsatisfiable range requests; there are two cases:
   syntactic problems, and range doesn't exist in the document. The 416
   status code was needed to resolve this ambiguity needed to indicate
   an error for a byte range request that falls outside of the actual
   contents of a document. (Section 10.4.17, 14.16)
```

구현자가 오류를 범하는 것을 훨씬 더 어렵게 만들기 위해 메시지 전송 요구 사항을 다시 작성합니다. 여기서 오류의 결과는 인터넷에 심각한 영향을 미칠 수 있고 다음 문제를 처리할 수 있기 때문입니다.

- 1. "HTTP/1.1 이상"을 "HTTP/1.1"로 변경합니다. 이는 HTTP/1.x의 향후 버전 구현 동작에 대한 요구 사항을 잘못 배치하는 상황입니다.

- 2. 일반적으로 "클라이언트"가 아닌 사용자 에이전트가 요청을 재시도해야 함을 분명히 했습니다.

- 3. 클라이언트가 예기치 않은 100\(계속\) 응답을 무시하고 프록시가 100개의 응답을 전달하도록 요구 사항을 1xx 응답에 대한 일반 요구 사항으로 변환했습니다.

- 4. HTTP에 대해 비TCP 전송이 가능하다는 점을 더 명확하게 하기 위해 일부 TCP 관련 언어를 수정했습니다.

- 5. 원서버가 필수 100\(계속\) 응답을 보내기 전에 요청 본문을 기다리면 안 됩니다.\(MUST NOT\)

- 6. 요청 본문의 일부를 이미 본 경우 서버가 100\(계속\)을 생략하도록 허용합니다.

- 7. 서버가 서비스 거부 공격과 손상된 클라이언트를 방어할 수 있도록 허용합니다.

이 변경으로 Expect 헤더와 417 상태 코드가 추가됩니다. 메시지 전송 요구 사항 수정 사항은 섹션 8.2, 10.4.18, 8.1.2.2, 13.11 및 14.20에 있습니다.

```text
   Proxies should be able to add Content-Length when appropriate.
   (Section 13.5.2)

   Clean up confusion between 403 and 404 responses. (Section 10.4.4,
   10.4.5, and 10.4.11)
```

경고가 잘못 캐시되거나 적절하게 업데이트되지 않을 수 있습니다. \(섹션 13.1.2, 13.2.4, 13.5.2, 13.5.3, 14.9.3 및 14.46\) PUT 또는 기타 메소드가 요청에 필요할 수 있으므로 경고도 일반 헤더여야 합니다.

```text
   Transfer-coding had significant problems, particularly with
   interactions with chunked encoding. The solution is that transfer-
   codings become as full fledged as content-codings. This involves
   adding an IANA registry for transfer-codings (separate from content
   codings), a new header field (TE) and enabling trailer headers in the
   future. Transfer encoding is a major performance benefit, so it was
   worth fixing [39]. TE also solves another, obscure, downward
   interoperability problem that could have occurred due to interactions
   between authentication trailers, chunked encoding and HTTP/1.0
   clients.(Section 3.6, 3.6.1, and 14.39)
```

PATCH, LINK, UNLINK 메소드가 정의되었지만 이 사양의 이전 버전에서는 일반적으로 구현되지 않았습니다. RFC 2068 \[33\]을 참조하세요.

Alternates, Content-Version, Derived-From, Link, URI, Public 및 Content-Base 헤더 필드는 이 사양의 이전 버전에서 정의되었지만 일반적으로 구현되지는 않았습니다. RFC 2068 \[33\]을 참조하세요.

---
# **20 Index**

INDEX에 대해서는 이 RFC의 PostScript 버전을 참조하세요.

---
## **21.  Full Copyright Statement**

Copyright \(C\) The Internet Society \(1999\). 판권 소유.

이 문서와 그 번역본은 복사되어 타인에게 제공될 수 있으며, 이에 대해 설명하거나 설명하거나 구현을 지원하는 파생물은 어떤 종류의 제한 없이 전체적으로 또는 부분적으로 준비, 복사, 출판 및 배포될 수 있습니다. , 단, 위의 저작권 표시와 이 단락은 그러한 모든 사본 및 파생물에 포함됩니다. 그러나 이 문서 자체는 인터넷 표준 개발 목적으로 필요한 경우를 제외하고는 저작권 표시를 제거하거나 Internet Society 또는 기타 인터넷 조직에 대한 참조를 제거하는 등 어떤 식으로든 수정할 수 없습니다. 인터넷 표준 프로세스를 따르거나 영어 이외의 언어로 번역하는 데 필요한 대로 따라야 합니다.

위에서 부여된 제한된 권한은 영구적이며 Internet Society 또는 그 승계자 또는 양수인에 의해 취소되지 않습니다.

이 문서와 여기에 포함된 정보는 "있는 그대로" 제공되며 인터넷 사회 및 인터넷 공학 태스크포스는 여기에 포함된 정보의 사용이 상품성 또는 특정 목적에의 적합성에 대한 권리 또는 묵시적 보증을 침해하는 행위.

---
# **Acknowledgement**

RFC 편집기 기능에 대한 자금은 현재 Internet Society에서 제공하고 있습니다.
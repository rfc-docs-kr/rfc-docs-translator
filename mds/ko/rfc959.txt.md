

```text
                                                                        
Network Working Group                                          J. Postel
Request for Comments: 959                                    J. Reynolds
                                                                     ISI
Obsoletes RFC: 765 (IEN 149)                                October 1985

                      FILE TRANSFER PROTOCOL (FTP)
```

---
# **Status of this Memo**

이 메모는 FTP\(파일 전송 프로토콜\)의 공식 사양입니다. 이 메모의 배포는 무제한입니다.

이 사양 버전에는 다음과 같은 새로운 선택적 명령이 포함되어 있습니다.

- CDUP\(상위 디렉터리로 변경\), SMNT\(구조 마운트\), STOU\(고유 저장\), RMD\(디렉터리 제거\), MKD\(디렉터리 만들기\), PWD\(디렉터리 인쇄\) 및 SYST\(시스템\).

이 사양은 이전 버전과 호환됩니다.

---
## **1.  INTRODUCTION**

FTP의 목적은 1\) 파일\(컴퓨터 프로그램 및/또는 데이터\) 공유를 촉진하고, 2\) 원격 컴퓨터의 간접적 또는 암시적\(프로그램을 통해\) 사용을 장려하고, 3\) 파일 저장 시스템의 변형으로부터 사용자를 보호하는 것입니다. 호스트, 4\) 데이터를 안정적이고 효율적으로 전송합니다. FTP는 사용자가 터미널에서 직접 사용할 수 있지만 주로 프로그램에서 사용하도록 설계되었습니다.

본 사양의 시도는 간단하고 쉽게 구현 가능한 프로토콜 설계로 maxi-host, mini-host, 개인용 워크스테이션 및 TAC 사용자의 다양한 요구를 충족시키는 것입니다.

이 문서에서는 전송 제어 프로토콜\(TCP\)\[2\]과 Telnet 프로토콜\[3\]에 대한 지식이 있다고 가정합니다. 이러한 문서는 ARPA-인터넷 프로토콜 핸드북\[1\]에 포함되어 있습니다.

---
## **2.  OVERVIEW**

이 섹션에서는 역사, 용어 및 FTP 모델에 대해 설명합니다. 이 섹션에 정의된 용어는 FTP에서 특별한 의미를 갖는 용어입니다. 일부 용어는 FTP 모델에만 적용됩니다. 일부 독자들은 용어를 검토하면서 FTP 모델에 대한 섹션을 살펴보고 싶어할 수도 있습니다.

```text
   2.1.  HISTORY
```

- FTP는 수년에 걸쳐 오랜 발전을 거듭해 왔습니다. 부록 III은 FTP와 관련된 의견 요청 문서를 연대순으로 정리한 것입니다. 여기에는 MIT의 호스트 구현을 위해 개발된 1971년에 최초로 제안된 파일 전송 메커니즘이 포함됩니다. \(RFC 114\), RFC 141의 의견 및 토론.

- RFC 172는 호스트 컴퓨터\(터미널 IMP 포함\) 간의 파일 전송을 위한 사용자 수준 지향 프로토콜을 제공했습니다. RFC 265의 개정판에서는 추가 검토를 위해 FTP를 다시 언급했으며 RFC 281에서는 추가 변경 사항을 제안했습니다. "데이터 유형 설정" 트랜잭션의 사용은 1982년 1월 RFC 294에서 제안되었습니다.

- RFC 354는 RFC 264 및 265를 폐기했습니다. 파일 전송 프로토콜은 이제 ARPANET의 HOST 간 파일 전송을 위한 프로토콜로 정의되었으며, FTP의 주요 기능은 호스트 간에 파일을 효율적이고 안정적으로 전송하고 원격 장치를 편리하게 사용할 수 있도록 정의되었습니다. 파일 저장 기능. RFC 385는 오류, 강조점 및 프로토콜 추가 사항에 대해 추가로 설명했으며 RFC 414는 작업 서버 및 사용자 FTP에 대한 상태 보고서를 제공했습니다. 1973년에 발행된 RFC 430\(다른 RFC 중에서 언급하기에는 너무 많음\)에는 FTP에 대한 추가 설명이 나와 있습니다. 마지막으로 "공식" FTP 문서가 RFC 454로 게시되었습니다.

- 1973년 7월까지 FTP의 마지막 버전에서 상당한 변경이 이루어졌지만 일반적인 구조는 동일하게 유지되었습니다. RFC 542는 이러한 변경 사항을 반영하기 위해 새로운 "공식" 사양으로 게시되었습니다. 그러나 이전 사양을 기반으로 한 많은 구현은 업데이트되지 않았습니다.

- 1974년에 RFC 607과 614는 FTP에 대한 논평을 계속했습니다. RFC 624는 추가 설계 변경과 사소한 수정을 제안했습니다. 1975년에 "Leaving Well Enough Alone"이라는 제목의 RFC 686에서는 FTP의 초기 버전과 이후 버전 간의 차이점을 논의했습니다. RFC 691은 인쇄 파일 주제와 관련하여 RFC 686의 사소한 개정판을 제시했습니다.

- NCP에서 기본 프로토콜인 TCP로의 전환에 동기를 부여받아 TCP에서 사용하기 위한 FTP 사양인 RFC 765의 위의 모든 노력을 통해 피닉스가 탄생했습니다.

- FTP 사양의 최신 버전은 일부 사소한 문서 오류를 수정하고 일부 프로토콜 기능에 대한 설명을 개선하며 몇 가지 새로운 선택적 명령을 추가하기 위한 것입니다.

- 특히 이번 사양 버전에는 다음과 같은 새로운 선택적 명령이 포함되었습니다.

- CDUP - 상위 디렉토리로 변경

```text
         SMNT - Structure Mount

         STOU - Store Unique

         RMD - Remove Directory

         MKD - Make Directory

         PWD - Print Directory

         SYST - System
```

- 본 사양은 이전 버전과 호환됩니다. 이전 사양을 준수하여 구현된 프로그램은 자동으로 이 사양을 준수해야 합니다.

```text
   2.2.  TERMINOLOGY

      ASCII
```

- ASCII 문자 집합은 ARPA-Internet Protocol Handbook에 정의되어 있습니다. FTP에서 ASCII 문자는 8비트 코드 세트의 하위 절반으로 정의됩니다\(즉, 최상위 비트는 0입니다\).

```text
      access controls
```

- 액세스 제어는 시스템 사용 및 해당 시스템의 파일에 대한 사용자의 액세스 권한을 정의합니다. 파일의 무단 사용이나 실수로 인한 사용을 방지하려면 액세스 제어가 필요합니다. 액세스 제어를 호출하는 것은 서버-FTP 프로세스의 특권입니다.

```text
      byte size
```

- FTP에는 두 가지 바이트 크기, 즉 파일의 논리적 바이트 크기와 데이터 전송에 사용되는 전송 바이트 크기가 있습니다. 전송 바이트 크기는 항상 8비트입니다. 전송 바이트 크기는 데이터가 시스템에 저장되는 바이트 크기나 데이터 구조 해석을 위한 논리적 바이트 크기일 필요는 없습니다.

```text
      control connection
```

- 명령 및 응답 교환을 위한 USER-PI와 SERVER-PI 간의 통신 경로입니다. 이 연결은 Telnet 프로토콜을 따릅니다.

```text
      data connection
```

- 지정된 모드 및 유형으로 데이터가 전송되는 전이중 연결입니다. 전송되는 데이터는 파일의 일부, 전체 파일 또는 여러 파일일 수 있습니다. 경로는 서버-DTP와 사용자-DTP 사이 또는 두 서버-DTP 사이일 수 있습니다.

```text
      data port
```

- 수동 데이터 전송 프로세스는 데이터 연결을 열기 위해 활성 전송 프로세스의 연결을 데이터 포트에서 "수신"합니다.

```text
      DTP
```

- 데이터 전송 프로세스는 데이터 연결을 설정하고 관리합니다. DTP는 수동적이거나 능동적일 수 있습니다.

```text
      End-of-Line
```

- 라인 끝 순서는 인쇄 라인의 분리를 정의합니다. 순서는 캐리지 리턴\(Carriage Return\)과 라인 피드\(Line Feed\)입니다.

```text
      EOF
```

- 전송되는 파일의 끝을 정의하는 파일 끝 조건입니다.

```text
      EOR
```

- 전송되는 레코드의 끝을 정의하는 레코드 끝 조건입니다.

```text
      error recovery
```

- 사용자가 호스트 시스템이나 전송 프로세스의 실패와 같은 특정 오류로부터 복구할 수 있도록 하는 절차입니다. FTP에서 오류 복구에는 지정된 체크포인트에서 파일 전송을 다시 시작하는 작업이 포함될 수 있습니다.

```text
      FTP commands
```

- 사용자 FTP에서 서버 FTP 프로세스로 흐르는 제어 정보를 구성하는 명령 집합입니다.

```text
      file
```

- 경로 이름으로 고유하게 식별되는 임의 길이의 순서가 지정된 컴퓨터 데이터\(프로그램 포함\) 세트입니다.

```text
      mode
```

- 데이터 연결을 통해 데이터가 전송되는 모드입니다. 모드는 EOR 및 EOF를 포함하여 전송 중 데이터 형식을 정의합니다. FTP에 정의된 전송 모드는 전송 모드 섹션에 설명되어 있습니다.

```text
      NVT
```

- Telnet 프로토콜에 정의된 네트워크 가상 터미널.

```text
      NVFS
```

- 네트워크 가상 파일 시스템. 표준 명령 및 경로 이름 규칙을 사용하여 표준 네트워크 파일 시스템을 정의하는 개념입니다.

```text
      page
```

- 파일은 페이지라고 불리는 독립적인 부분의 집합으로 구성될 수 있습니다. FTP는 불연속 파일의 전송을 독립적인 색인 페이지로 지원합니다.

```text
      pathname
```

- 경로명은 파일을 식별하기 위해 사용자가 파일 시스템에 입력해야 하는 문자열로 정의된다. 경로 이름에는 일반적으로 장치 및/또는 디렉터리 이름과 파일 이름 사양이 포함됩니다. FTP는 아직 표준 경로 이름 규칙을 지정하지 않습니다. 각 사용자는 전송과 관련된 파일 시스템의 파일 명명 규칙을 따라야 합니다.

```text
      PI
```

- 프로토콜 해석기. 프로토콜의 사용자 측과 서버 측에는 사용자 PI와 서버 PI에서 구현되는 고유한 역할이 있습니다.

```text
      record
```

- 순차 파일은 레코드라고 불리는 여러 개의 연속된 부분으로 구성될 수 있습니다. 레코드 구조는 FTP에서 지원되지만 파일에는 레코드 구조가 필요하지 않습니다.

```text
      reply
```

- 응답은 FTP 명령에 대한 응답으로 제어 연결을 통해 서버에서 사용자에게 전송되는 승인\(긍정적 또는 부정적\)입니다. 일반적인 응답 형식은 완료 코드\(오류 코드 포함\)와 그 뒤에 오는 텍스트 문자열입니다. 코드는 프로그램에서 사용하기 위한 것이며 텍스트는 일반적으로 인간 사용자를 위한 것입니다.

```text
      server-DTP
```

- 정상적인 "활성" 상태의 데이터 전송 프로세스는 "수신" 데이터 포트와의 데이터 연결을 설정합니다. 전송 및 저장을 위한 매개변수를 설정하고 PI의 명령에 따라 데이터를 전송합니다. 데이터 포트에서 연결을 시작하는 대신 DTP를 "수동" 상태로 전환하여 수신 대기할 수 있습니다.

```text
      server-FTP process
```

- 사용자 FTP 프로세스 및 다른 서버와 협력하여 파일 전송 기능을 수행하는 프로세스 또는 프로세스 집합입니다. 기능은 프로토콜 해석기\(PI\)와 데이터 전송 프로세스\(DTP\)로 구성됩니다.

```text
      server-PI
```

- 서버 프로토콜 해석기는 포트 L에서 사용자 PI의 연결을 "수신"하고 제어 통신 연결을 설정합니다. user-PI로부터 표준 FTP 명령을 수신하고, 응답을 보내고, 서버-DTP를 관리합니다.

```text
      type
```

- 데이터 전송 및 저장에 사용되는 데이터 표현 유형입니다. 유형은 데이터 저장 시점과 데이터 전송 시점 사이의 특정 변환을 의미합니다. FTP에 정의된 표현 유형은 데이터 연결 설정 섹션에 설명되어 있습니다.

```text
      user
```

- 파일 전송 서비스를 받고자 하는 사람을 대신하는 사람 또는 프로세스. 인간 사용자는 서버-FTP 프로세스와 직접 상호 작용할 수 있지만 프로토콜 설계가 오토마타에 중점을 두기 때문에 사용자-FTP 프로세스를 사용하는 것이 좋습니다.

```text
      user-DTP
```

- 데이터 전송 프로세스는 서버-FTP 프로세스의 연결을 데이터 포트에서 "수신"합니다. 두 서버가 서로 데이터를 전송하는 경우 사용자 DTP는 비활성화됩니다.

```text
      user-FTP process
```

- 하나 이상의 서버-FTP 프로세스와 협력하여 파일 전송 기능을 함께 수행하는 프로토콜 해석기, 데이터 전송 프로세스 및 사용자 인터페이스를 포함한 기능 세트입니다. 사용자 인터페이스를 통해 사용자와의 명령-응답 대화에서 현지 언어를 사용할 수 있습니다.

```text
      user-PI
```

- 사용자 프로토콜 해석기는 포트 U에서 서버 FTP 프로세스로의 제어 연결을 시작하고 FTP 명령을 시작하며 해당 프로세스가 파일 전송의 일부인 경우 사용자 DTP를 관리합니다.

2.3. FTP 모델

- 위의 정의를 염두에 두고 FTP 서비스에 대해 다음 모델\(그림 1 참조\)을 다이어그램으로 작성할 수 있습니다.

```text
                                            -------------
                                            |/---------\|
                                            ||   User  ||    --------
                                            ||Interface|<--->| User |
                                            |\----^----/|    --------
                  ----------                |     |     |
                  |/------\|  FTP Commands  |/----V----\|
                  ||Server|<---------------->|   User  ||
                  ||  PI  ||   FTP Replies  ||    PI   ||
                  |\--^---/|                |\----^----/|
                  |   |    |                |     |     |
      --------    |/--V---\|      Data      |/----V----\|    --------
      | File |<--->|Server|<---------------->|  User   |<--->| File |
      |System|    || DTP  ||   Connection   ||   DTP   ||    |System|
      --------    |\------/|                |\---------/|    --------
                  ----------                -------------

                  Server-FTP                   USER-FTP
```

- 참고: 1. 데이터 연결은 양방향으로 사용될 수 있습니다. 2. 데이터 연결이 항상 존재할 필요는 없습니다.

```text
                      Figure 1  Model for FTP Use
```

- 그림 1에 설명된 모델에서 사용자 프로토콜 해석기는 제어 연결을 시작합니다. 제어 연결은 Telnet 프로토콜을 따릅니다. 사용자가 시작되면 표준 FTP 명령이 user-PI에 의해 생성되고 제어 연결을 통해 서버 프로세스로 전송됩니다. \(사용자는 예를 들어 TAC 터미널에서 서버 FTP에 대한 직접 제어 연결을 설정하고 사용자 FTP 프로세스를 우회하여 독립적으로 표준 FTP 명령을 생성할 수 있습니다.\) 표준 응답은 서버 PI에서 사용자에게 전송됩니다. 명령에 대한 응답으로 제어 연결을 통한 PI입니다.

- FTP 명령은 데이터 연결\(데이터 포트, 전송 모드, 표시 유형 및 구조\)에 대한 매개변수와 파일 시스템 작업의 특성\(저장, 검색, 추가, 삭제 등\)을 지정합니다. 사용자-DTP 또는 그 지정자는 지정된 데이터 포트에서 "수신"해야 하며 서버는 지정된 매개변수에 따라 데이터 연결 및 데이터 전송을 시작합니다. 데이터 포트는 다음 위치에 있을 필요가 없습니다.

- 제어 연결을 통해 FTP 명령을 시작하는 동일한 호스트. 단, 사용자 또는 사용자-FTP 프로세스는 지정된 데이터 포트에서 "수신"을 보장해야 합니다. 또한 데이터 연결은 동시 전송 및 수신에 사용될 수 있다는 점에 유의해야 합니다.

- 또 다른 상황에서는 사용자가 로컬 호스트가 아닌 두 호스트 간에 파일을 전송하려고 할 수도 있습니다. 사용자는 두 서버에 대한 제어 연결을 설정한 다음 두 서버 간의 데이터 연결을 준비합니다. 이러한 방식으로 제어 정보는 user-PI로 전달되지만 데이터는 서버 데이터 전송 프로세스 간에 전송됩니다. 다음은 이 서버-서버 상호 작용의 모델입니다.

```text
      
                    Control     ------------   Control
                    ---------->| User-FTP |<-----------
                    |          | User-PI  |           |
                    |          |   "C"    |           |
                    V          ------------           V
            --------------                        --------------
            | Server-FTP |   Data Connection      | Server-FTP |
            |    "A"     |<---------------------->|    "B"     |
            -------------- Port (A)      Port (B) --------------
      

                                 Figure 2
```

- 프로토콜에서는 데이터 전송이 진행되는 동안 제어 연결이 열려 있어야 합니다. FTP 서비스 사용을 마친 후 제어 연결 종료를 요청하는 것은 사용자의 책임이며, 조치를 취하는 것은 서버입니다. 명령 없이 제어 연결이 닫히면 서버는 데이터 전송을 중단할 수 있습니다.

- FTP와 Telnet의 관계:

- FTP는 제어 연결에서 Telnet 프로토콜을 사용합니다. 이는 두 가지 방법으로 달성할 수 있습니다. 첫째, 사용자 PI 또는 서버 PI는 자체 절차에서 직접 Telnet 프로토콜의 규칙을 구현할 수 있습니다. 또는 둘째, user-PI 또는 server-PI가 시스템의 기존 Telnet 모듈을 활용할 수 있습니다.

- 구현의 용이성, 코드 공유 및 모듈식 프로그래밍이 두 번째 접근 방식을 주장합니다. 효율성과 독립성

- 첫 번째 접근 방식을 주장하십시오. 실제로 FTP는 Telnet 프로토콜에 거의 의존하지 않으므로 첫 번째 접근 방식에는 반드시 많은 양의 코드가 필요하지 않습니다.

---
## **3.  DATA TRANSFER FUNCTIONS**

파일은 데이터 연결을 통해서만 전송됩니다. 제어 연결은 수행할 기능을 설명하는 명령 전송과 이러한 명령에 대한 응답에 사용됩니다\(FTP 응답 섹션 참조\). 여러 명령이 호스트 간 데이터 전송과 관련됩니다. 이러한 데이터 전송 명령에는 데이터 비트가 전송되는 방법을 지정하는 MODE 명령과 데이터가 표시되는 방식을 정의하는 데 사용되는 STRUcture 및 TYPE 명령이 포함됩니다. 전송과 표현은 기본적으로 독립적이지만 "스트림" 전송 모드는 파일 구조 속성에 따라 달라지며 "압축" 전송 모드를 사용하는 경우 필러 바이트의 특성은 표현 유형에 따라 다릅니다.

3.1. 데이터 표현 및 저장

- 송신 호스트의 저장 장치에서 수신 호스트의 저장 장치로 데이터가 전송됩니다. 두 시스템의 데이터 저장 표현이 다르기 때문에 데이터에 대해 특정 변환을 수행해야 하는 경우가 많습니다. 예를 들어 NVT-ASCII는 시스템마다 데이터 저장 방식이 다릅니다. DEC TOPS-20s는 일반적으로 NVT-ASCII를 5개의 7비트 ASCII 문자로 저장하고 36비트 단어에서 왼쪽 정렬됩니다. IBM 메인프레임은 NVT-ASCII를 8비트 EBCDIC 코드로 저장합니다. Multics는 NVT-ASCII를 36비트 단어의 4개의 9비트 문자로 저장합니다. 서로 다른 시스템 간에 텍스트를 전송할 때 문자를 표준 NVT-ASCII 표현으로 변환하는 것이 바람직합니다. 송신 및 수신 사이트는 표준 표현과 내부 표현 간에 필요한 변환을 수행해야 합니다.

- 단어 길이가 다른 호스트 시스템 간에 바이너리 데이터\(문자 코드 아님\)를 전송할 때 표현상의 다른 문제가 발생합니다. 발신자가 데이터를 전송하는 방법과 수신자가 데이터를 저장하는 방법이 항상 명확하지는 않습니다. 예를 들어, 32비트 워드 길이 시스템에서 36비트 워드 길이 시스템으로 32비트 바이트를 전송할 때 오른쪽 정렬된 32비트 바이트를 저장하는 것이 \(효율성과 유용성의 이유로\) 바람직할 수 있습니다. 후자 시스템에서는 36비트 워드로. 어떤 경우든 사용자는 데이터 표현 및 변환 기능을 지정할 수 있는 옵션을 가져야 합니다. 주목해야 할 점

- FTP는 매우 제한된 데이터 유형 표현을 제공합니다. 이 제한된 기능을 넘어서 원하는 변환은 사용자가 직접 수행해야 합니다.

```text
      3.1.1.  DATA TYPES
```

- 데이터 표현은 사용자가 표현 유형을 지정하여 FTP에서 처리됩니다. 이 유형은 암시적으로\(ASCII 또는 EBCDIC에서와 같이\) 또는 명시적으로\(로컬 바이트에서와 같이\) "논리적 바이트 크기"라고 하는 해석을 위한 바이트 크기를 정의할 수 있습니다. 이는 "전송 바이트 크기"라고 하는 데이터 연결을 통해 전송하는 데 사용되는 바이트 크기와는 아무런 관련이 없으며 두 가지를 혼동해서는 안 됩니다. 예를 들어 NVT-ASCII의 논리적 바이트 크기는 8비트입니다. 유형이 로컬 바이트인 경우 TYPE 명령에는 논리적 바이트 크기를 지정하는 필수 두 번째 매개변수가 있습니다. 전송 바이트 크기는 항상 8비트입니다.

```text
         3.1.1.1.  ASCII TYPE
```

- 이는 기본 유형이며 모든 FTP 구현에서 허용되어야 합니다. 두 호스트 모두 EBCDIC 유형이 더 편리하다고 생각하는 경우를 제외하고는 주로 텍스트 파일 전송을 위한 것입니다.

- 송신자는 데이터를 내부 문자 표현에서 표준 8비트 NVT-ASCII 표현으로 변환합니다\(Telnet 사양 참조\). 수신자는 표준 형식의 데이터를 자신의 내부 형식으로 변환합니다.

- NVT 표준에 따라 텍스트 줄의 끝을 표시하기 위해 필요한 경우 <CRLF\> 시퀀스를 사용해야 합니다. \(데이터 표현 및 저장 섹션 끝에 있는 파일 구조에 대한 설명을 참조하세요.\)

- 표준 NVT-ASCII 표현을 사용한다는 것은 데이터가 8비트 바이트로 해석되어야 함을 의미합니다.

- ASCII 및 EBCDIC 유형에 대한 형식 매개변수는 아래에 설명되어 있습니다.

```text
         3.1.1.2.  EBCDIC TYPE
```

- 이 유형은 내부 문자 표현을 위해 EBCDIC을 사용하는 호스트 간의 효율적인 전송을 위한 것입니다.

- 전송을 위해 데이터는 8비트 EBCDIC 문자로 표시됩니다. 문자 코드는 EBCDIC 유형과 ASCII 유형의 기능 사양 간의 유일한 차이점입니다.

- 줄 끝\(레코드 끝과 반대로 - 구조 설명 참조\)은 구조를 표시하기 위해 EBCDIC 유형과 함께 거의 사용되지 않지만 필요한 경우 <NL\> 문자를 사용해야 합니다. .

```text
         3.1.1.3.  IMAGE TYPE
```

- 데이터는 전송을 위해 8비트 전송 바이트로 압축되는 연속 비트로 전송됩니다. 수신 사이트는 데이터를 연속 비트로 저장해야 합니다. 저장 시스템의 구조에 따라 파일\(또는 레코드 구조 파일의 경우 각 레코드\)을 편리한 경계\(바이트, 단어 또는 블록\)까지 채워야 할 수도 있습니다. 모두 0이어야 하는 이 패딩은 파일 끝\(또는 각 레코드의 끝\)에서만 발생할 수 있으며 파일을 검색할 때 제거될 수 있도록 패딩 비트를 식별하는 방법이 있어야 합니다. . 사용자가 저장 사이트에서 파일을 처리할 수 있도록 패딩 변환이 잘 공개되어야 합니다.

- 이미지 유형은 파일의 효율적인 저장 및 검색과 바이너리 데이터 전송을 위한 것입니다. 모든 FTP 구현에서 이 유형을 허용하는 것이 좋습니다.

```text
         3.1.1.4.  LOCAL TYPE
```

- 데이터는 필수 두 번째 매개변수인 바이트 크기에 의해 지정된 크기의 논리적 바이트로 전송됩니다. 바이트 크기 값은 10진수 정수여야 합니다. 기본값은 없습니다. 논리적 바이트 크기는 전송 바이트 크기와 반드시 동일할 필요는 없습니다. 바이트 크기에 차이가 있는 경우 전송 바이트 경계를 무시하고 끝에 필요한 패딩을 사용하여 논리 바이트를 연속적으로 압축해야 합니다.

- 데이터가 수신 호스트에 도달하면 논리적 바이트 크기와 특정 호스트에 따라 변환됩니다. 이 변환은 반전 가능해야 하며\(즉, 동일한 매개변수를 사용하는 경우 동일한 파일을 검색할 수 있음\) FTP 구현자가 이를 잘 공개해야 합니다.

- 예를 들어, 32비트 단어가 포함된 호스트에 36비트 부동 소수점 숫자를 보내는 사용자는 해당 데이터를 논리 바이트 크기가 36인 로컬 바이트로 보낼 수 있습니다. 그러면 수신 호스트는 논리 바이트를 저장할 것으로 예상됩니다. 쉽게 조작할 수 있도록 말이죠. 이 예에서는 36비트 논리 바이트를 64비트 더블 워드에 넣는 것으로 충분합니다.

- 또 다른 예에서, 36비트 워드 크기를 가진 한 쌍의 호스트는 TYPE L 36을 사용하여 워드로 서로 데이터를 보낼 수 있습니다. 데이터는 9개의 전송 바이트가 2개의 전송 바이트를 전달하도록 압축된 8비트 전송 바이트로 전송됩니다. 호스트 말.

```text
         3.1.1.5.  FORMAT CONTROL
```

- ASCII 및 EBCDIC 유형도 두 번째\(선택적\) 매개변수를 사용합니다. 이는 어떤 종류의 수직 형식 컨트롤이 파일과 연관되어 있는지를 나타냅니다. FTP에는 다음과 같은 데이터 표현 유형이 정의되어 있습니다.

- 캐릭터 파일은 인쇄, 저장 및 나중에 검색, 처리 등 세 가지 목적 중 하나로 호스트로 전송될 수 있습니다. 인쇄를 위해 파일을 보내는 경우 수신 호스트는 세로 형식 컨트롤이 표시되는 방법을 알아야 합니다. 두 번째 경우에는 호스트에 파일을 저장한 다음 나중에 정확히 동일한 형식으로 검색할 수 있어야 합니다. 마지막으로, 한 호스트에서 다른 호스트로 파일을 이동하고 과도한 문제 없이 두 번째 호스트에서 파일을 처리할 수 있어야 합니다. 단일 ASCII 또는 EBCDIC 형식은 이러한 조건을 모두 충족하지 않습니다. 따라서 이러한 유형에는 다음 세 가지 형식 중 하나를 지정하는 두 번째 매개변수가 있습니다.

```text
            3.1.1.5.1.  NON PRINT
```

- 두 번째\(형식\) 매개변수가 생략된 경우 사용되는 기본 형식입니다. 모든 FTP 구현에서는 인쇄 이외의 형식을 허용해야 합니다.

- 파일에는 세로 형식 정보가 포함되어 있지 않아야 합니다. 프린터 프로세스로 전달되면 이 프로세스는 간격과 여백에 대한 표준 값을 가정할 수 있습니다.

- 일반적으로 이 형식은 처리 또는 저장용 파일에 사용됩니다.

```text
            3.1.1.5.2.  TELNET FORMAT CONTROLS
```

- 파일에는 프린터 프로세스가 적절하게 해석하는 ASCII/EBCDIC 수직 형식 컨트롤\(예: <CR\>, <LF\>, <NL\>, <VT\>, <FF\>\)이 포함되어 있습니다. <CRLF\>는 정확히 이 순서에서 줄 끝을 나타냅니다.

```text
            3.1.1.5.2.  CARRIAGE CONTROL (ASA)
```

- 파일에는 ASA\(FORTRAN\) 수직 형식 제어 문자가 포함되어 있습니다. \(RFC 740 부록 C 및 Communications of the ACM, Vol. 7, No. 10, p. 606, 1964년 10월 참조\) ASA 표준에 따라 형식이 지정된 행이나 레코드에서 첫 번째 문자는 인쇄되지 않습니다. . 대신, 기록의 나머지 부분이 인쇄되기 전에 발생해야 하는 용지의 수직 이동을 결정하는 데 사용해야 합니다.

ASA 표준은 다음 제어를 지정합니다.

- 문자:

```text
                  Character     Vertical Spacing

                  blank         Move paper up one line
                  0             Move paper up two lines
                  1             Move paper to top of next page
                  +             No movement, i.e., overprint
```

- 분명히 프린터 프로세스가 구조적 엔터티의 끝을 구별할 수 있는 방법이 있어야 합니다. 파일에 레코드 구조\(아래 참조\)가 있으면 문제가 되지 않습니다. 기록은 전송 및 저장 중에 명시적으로 표시됩니다. 파일에 레코드 구조가 없는 경우 <CRLF\> 줄 끝 시퀀스는 인쇄 줄을 구분하는 데 사용되지만 이러한 형식 이펙터는 ASA 컨트롤에 의해 재정의됩니다.

```text
      3.1.2.  DATA STRUCTURES
```

- FTP에서는 다양한 표시 유형 외에도 파일 구조를 지정할 수 있습니다. FTP에는 세 가지 파일 구조가 정의되어 있습니다.

- 내부 구조가 없고 파일이 데이터 바이트의 연속적인 시퀀스로 간주되는 파일 구조,

- 파일이 순차적 레코드로 구성되는 레코드 구조

- 파일이 독립적인 색인 페이지로 구성되는 페이지 구조.

- STRUcture 명령이 사용되지 않았지만 모든 FTP 구현에서 "텍스트" 파일\(즉, TYPE ASCII 또는 EBCDIC가 있는 파일\)에 대해 파일 및 레코드 구조가 모두 허용되어야 하는 경우 파일 구조가 가정되는 기본값입니다. 파일 구조는 파일의 전송 모드\(전송 모드 섹션 참조\)와 파일의 해석 및 저장에 모두 영향을 미칩니다.

- 파일의 "자연스러운" 구조는 파일을 저장하는 호스트에 따라 달라집니다. 소스 코드 파일은 일반적으로 IBM 메인프레임에 고정 길이 레코드로 저장되지만 DEC TOPS-20에는 <CRLF\>와 같이 줄로 분할된 문자 스트림으로 저장됩니다. 이러한 서로 다른 사이트 간의 파일 전송이 유용하려면 한 사이트가 파일에 대한 다른 사이트의 가정을 인식할 수 있는 방법이 있어야 합니다.

- 일부 사이트는 본질적으로 파일 지향적이고 다른 사이트는 본질적으로 기록 지향이므로 한 구조의 파일이 다른 구조의 호스트로 전송되면 문제가 발생할 수 있습니다. 텍스트 파일이 레코드 구조와 함께 파일 지향 호스트로 전송되면 해당 호스트는 레코드 구조를 기반으로 파일에 내부 변환을 적용해야 합니다. 분명히 이 변환은 유용해야 하지만 레코드 구조를 사용하여 동일한 파일을 검색할 수 있도록 되돌릴 수도 있어야 합니다.

- 레코드 지향 호스트에 파일 구조로 파일을 전송하는 경우 호스트가 파일을 로컬에서 처리할 수 있는 레코드로 나누기 위해 어떤 기준을 사용해야 하는지에 대한 의문이 있습니다. 이 구분이 필요한 경우 FTP 구현에서는 줄 끝 시퀀스를 사용해야 합니다.

- ASCII의 경우 <CRLF\>, EBCDIC 텍스트 파일의 경우 <NL\>을 구분 기호로 사용합니다. FTP 구현이 이 기술을 채택하는 경우 파일 구조를 사용하여 파일을 검색하는 경우 변환을 되돌릴 준비를 해야 합니다.

```text
         3.1.2.1.  FILE STRUCTURE
```

- STRUcture 명령을 사용하지 않은 경우 파일 구조가 기본값으로 가정됩니다.

- 파일 구조에는 내부 구조가 없으며 파일은 데이터 바이트의 연속적인 시퀀스로 간주됩니다.

```text
         3.1.2.2.  RECORD STRUCTURE
```

- 모든 FTP 구현에서는 "텍스트" 파일\(즉, TYPE ASCII 또는 EBCDIC 파일\)에 대해 레코드 구조를 허용해야 합니다.

- 레코드 구조에서는 파일이 순차적 레코드로 구성됩니다.

```text
         3.1.2.3.  PAGE STRUCTURE
```

- 불연속적인 파일을 전송하기 위해 FTP는 페이지 구조를 정의합니다. 이러한 유형의 파일은 "랜덤 액세스 파일" 또는 "홀리 파일"이라고도 합니다. 이러한 파일에는 파일 전체\(예: 파일 설명자\)나 파일 섹션\(예: 페이지 액세스 제어\) 또는 둘 다와 관련된 다른 정보가 있는 경우도 있습니다. FTP에서는 파일의 섹션을 페이지라고 합니다.

다양한 페이지 크기와 관련 기능을 제공하기 위해

- 정보, 각 페이지는 페이지 헤더와 함께 전송됩니다. 페이지 헤더에는 다음과 같이 정의된 필드가 있습니다.

```text
               Header Length
```

- 이 바이트를 포함하는 페이지 헤더의 논리 바이트 수입니다. 최소 헤더 길이는 4입니다.

```text
               Page Index
```

- 파일의 이 섹션에 대한 논리적 페이지 번호입니다. 이는 이 페이지의 전송 시퀀스 번호가 아니라 파일의 이 페이지를 식별하는 데 사용되는 인덱스입니다.

```text
               Data Length
```

- 페이지 데이터의 논리 바이트 수입니다. 최소 데이터 길이는 0입니다.

```text
               Page Type
```

- 페이지 유형입니다. 다음 페이지 유형이 정의됩니다.

```text
                     0 = Last Page
```

- 페이징된 구조적 전송의 끝을 나타내는 데 사용됩니다. 헤더 길이는 4, 데이터 길이는 0이어야 합니다.

```text
                     1 = Simple Page
```

- 이는 페이지 수준 관련 제어 정보가 없는 단순 페이지 파일의 일반적인 유형입니다. 헤더 길이는 4여야 합니다.

```text
                     2 = Descriptor Page
```

- 파일 전체에 대한 설명 정보를 전송하는 데 사용되는 유형입니다.

```text
                     3 = Access Controlled Page
```

- 이 유형에는 페이지 수준 액세스 제어 정보가 있는 페이지 파일에 대한 추가 헤더 필드가 포함됩니다. 헤더 길이는 5여야 ​​합니다.

```text
               Optional Fields
```

- 추가 헤더 필드는 페이지별 액세스 제어와 같은 페이지별 제어 정보를 제공하는 데 사용될 수 있습니다.

- 모든 필드의 길이는 1논리 바이트입니다. 논리적 바이트 크기는 TYPE 명령으로 지정됩니다. 자세한 내용과 페이지 구조의 특정 사례는 부록 I을 참조하세요.

- 매개변수에 대한 주의 사항: 검색된 버전을 사용하려면 동일한 매개변수를 사용하여 파일을 저장하고 검색해야 합니다.

- 원래 전송된 버전과 동일해야 합니다. 반대로, FTP 구현은 파일을 저장하고 검색하는 데 사용된 매개변수가 동일한 경우 원본과 동일한 파일을 반환해야 합니다.

```text
   3.2.  ESTABLISHING DATA CONNECTIONS
```

- 데이터 전송 메커니즘은 적절한 포트에 대한 데이터 연결 설정과 전송 매개변수 선택으로 구성됩니다. 사용자와 서버 DTP 모두 기본 데이터 포트를 가지고 있습니다. 사용자 프로세스 기본 데이터 포트는 제어 연결 포트\(예: U\)와 동일합니다. 서버 프로세스의 기본 데이터 포트는 제어 연결 포트\(즉, L-1\)에 인접한 포트이다.

- 전송 바이트 크기는 8비트 바이트입니다. 이 바이트 크기는 실제 데이터 전송에만 관련됩니다. 이는 호스트 파일 시스템 내의 데이터 표현과 관련이 없습니다.

- 수동 데이터 전송 프로세스\(사용자-DTP 또는 두 번째 서버-DTP일 수 있음\)는 전송 요청 명령을 보내기 전에 데이터 포트에서 "수신"해야 합니다. FTP 요청 명령은 데이터 전송 방향을 결정합니다. 서버는 전송 요청을 수신하면 포트에 대한 데이터 연결을 시작합니다. 연결이 설정되면 DTP 간에 데이터 전송이 시작되고 서버-PI는 사용자-PI에 확인 응답을 보냅니다.

- 모든 FTP 구현은 기본 데이터 포트의 사용을 지원해야 하며 USER-PI만 기본이 아닌 포트에 대한 변경을 시작할 수 있습니다.

- PORT 명령을 이용하여 사용자가 대체 데이터 포트를 지정할 수 있습니다. 사용자는 파일을 TAC 라인 프린터에 덤프하거나 제3자 호스트에서 검색하기를 원할 수 있습니다. 후자의 경우 사용자 PI는 두 서버 PI 모두와의 제어 연결을 설정합니다. 그러면 한 서버에 FTP 명령을 통해 다른 서버가 시작할 연결을 "수신"하라는 지시가 전달됩니다. user-PI는 하나의 server-PI에 다른 서버의 데이터 포트를 나타내는 PORT 명령을 보냅니다. 마지막으로 두 가지 모두 적절한 전송 명령이 전송됩니다. 사용자 컨트롤러와 서버 간에 전송되는 명령과 응답의 정확한 순서는 FTP 응답 섹션에 정의되어 있습니다.

- 일반적으로 데이터 연결을 유지하는 것, 즉 연결을 시작하고 닫는 것은 서버의 책임입니다. 이에 대한 예외

- 사용자 DTP가 EOF를 표시하기 위해 연결을 닫아야 하는 전송 모드로 데이터를 보내는 경우입니다. 서버는 다음 조건에서 데이터 연결을 닫아야 합니다.\(MUST\)

- 1. 서버는 EOF를 나타내기 위해 닫기가 필요한 전송 모드에서 데이터 전송을 완료했습니다.

- 2. 서버는 사용자로부터 ABORT 명령을 받습니다.

- 3. 사용자의 명령에 의해 포트 사양이 변경됩니다.

- 4. 제어 연결이 법적으로 또는 기타 방식으로 닫혀 있습니다.

- 5. 복구할 수 없는 오류 상황이 발생했습니다.

- 그렇지 않은 경우 닫기는 서버 옵션이며 서버는 250 또는 226 응답으로만 사용자 프로세스에 이를 알려야 합니다.

```text
   3.3.  DATA CONNECTION MANAGEMENT
```

- 기본 데이터 연결 포트: 모든 FTP 구현은 기본 데이터 연결 포트의 사용을 지원해야 하며, User-PI만 기본이 아닌 포트의 사용을 시작할 수 있습니다.

- 기본이 아닌 데이터 포트 협상: User-PI는 PORT 명령을 사용하여 기본이 아닌 사용자 측 데이터 포트를 지정할 수 있습니다. User-PI는 PASV 명령을 사용하여 기본이 아닌 서버 측 데이터 포트를 식별하도록 서버 측에 요청할 수 있습니다. 연결은 주소 쌍으로 정의되므로 이러한 작업 중 하나는 다른 데이터 연결을 얻는 데 충분하지만 데이터 연결의 양쪽 끝에서 새 포트를 사용하기 위해 두 명령을 모두 수행하는 것이 허용됩니다.

- 데이터 연결 재사용: 데이터 전송의 스트림 모드를 사용하는 경우 연결을 종료하여 파일의 끝을 표시해야 합니다. 이는 신뢰할 수 있는 통신을 보장하기 위해 TCP가 제한 시간 동안 연결 기록을 보유해야 하기 때문에 세션에서 여러 파일을 전송해야 하는 경우 문제가 발생합니다. 따라서 연결을 즉시 다시 열 수 없습니다.

- 이 문제에 대한 해결책은 두 가지가 있습니다. 첫 번째는 기본이 아닌 포트를 협상하는 것입니다. 두 번째는 다른 전송 모드를 사용하는 것입니다.

- 전송 모드에 대한 설명입니다. 스트림 전송 모드는

- 연결이 조기에 종료되었는지 여부를 판단할 수 없기 때문에 본질적으로 신뢰할 수 없습니다. 다른 전송 모드\(블록, 압축\)는 파일 끝을 나타내기 위해 연결을 닫지 않습니다. 파일의 끝을 확인하기 위해 데이터 연결을 구문 분석할 수 있을 만큼 충분한 FTP 인코딩이 있습니다. 따라서 이러한 모드를 사용하면 여러 파일 전송을 위해 데이터 연결을 열어 둘 수 있습니다.

```text
   3.4.  TRANSMISSION MODES
```

- 데이터 전송 시 다음으로 고려해야 할 사항은 적절한 전송 모드를 선택하는 것입니다. 세 가지 모드가 있습니다. 하나는 데이터 형식을 지정하고 다시 시작 절차를 허용하는 모드입니다. 효율적인 전송을 위해 데이터를 압축하는 것; 처리가 거의 또는 전혀 없이 데이터를 전달하는 것입니다. 이 마지막 경우에는 모드가 구조 속성과 상호 작용하여 처리 유형을 결정합니다. 압축 모드에서는 표현 유형에 따라 필러 바이트가 결정됩니다.

- 모든 데이터 전송은 데이터 연결 종료로 명시적으로 명시되거나 암시될 수 있는 파일 끝\(EOF\)으로 완료되어야 합니다. 레코드 구조가 있는 파일의 경우 최종 EOR\(레코드 끝 표시\)을 포함하여 모든 EOR\(end-of-record 표시\)이 명시적입니다. 페이지 구조로 전송된 파일의 경우 "마지막 페이지" 페이지 유형이 사용됩니다.

- 참고: 이 섹션의 나머지 부분에서 바이트는 달리 명시적으로 언급된 경우를 제외하고 "전송 바이트"를 의미합니다.

- 표준화된 전송을 위해 송신 호스트는 내부 라인 끝 또는 레코드 끝 표시를 전송 모드 및 파일 구조에 규정된 표현으로 변환하고, 수신 호스트는 내부 표시로 역변환을 수행합니다. IBM 메인프레임 레코드 수 필드는 다른 호스트에서 인식되지 않을 수 있으므로 레코드 끝 정보는 스트림 모드에서 2바이트 제어 코드로 전송되거나 블록 또는 압축 모드 설명자에서 플래그가 지정된 비트로 전송될 수 있습니다. 레코드 구조가 없는 ASCII 또는 EBCDIC 파일의 줄 끝은 각각 <CRLF\> 또는 <NL\>로 표시되어야 합니다. 이러한 변환은 일부 시스템에 대한 추가 작업을 의미하므로 레코드가 아닌 구조화된 텍스트 파일을 전송하는 동일한 시스템은 전송을 위해 이진 표현 및 스트림 모드를 사용하려고 할 수 있습니다.

- FTP에는 다음 전송 모드가 정의되어 있습니다.

```text
      3.4.1.  STREAM MODE
```

- 데이터는 바이트 스트림으로 전송됩니다. 사용되는 표현 유형에는 제한이 없습니다. 레코드 구조가 허용됩니다.

- 레코드 구조 파일에서 EOR 및 EOF는 각각 2바이트 제어 코드로 표시됩니다. 제어 코드의 첫 번째 바이트는 모두 1, 즉 이스케이프 문자입니다. 두 번째 바이트에는 EOR의 경우 하위 비트가 켜져 있고 다른 곳에서는 0이 있고 EOF의 경우 두 번째 하위 비트가 켜져 있습니다. 즉, 바이트는 EOR의 경우 값 1, EOF의 경우 값 2를 갖습니다. EOR과 EOF는 하위 비트를 모두 ON\(즉, 값 3\)하여 전송된 마지막 바이트에 함께 표시할 수 있습니다. 모든 1의 바이트를 데이터로 전송하려는 경우 제어 코드의 두 번째 바이트에서 반복되어야 합니다.

- 구조가 파일 구조인 경우 송신 호스트가 데이터 연결을 닫는 것으로 EOF가 표시되며 모든 바이트는 데이터 바이트입니다.

```text
      3.4.2.  BLOCK MODE
```

- 파일은 하나 이상의 헤더 바이트 앞에 일련의 데이터 블록으로 전송됩니다. 헤더 바이트에는 개수 필드와 설명자 코드가 포함됩니다. 카운트 필드는 데이터 블록의 전체 길이를 바이트 단위로 나타내므로 다음 데이터 블록의 시작을 표시합니다\(필러 비트 없음\). 설명자 코드는 다음을 정의합니다: 파일의 마지막 블록\(EOF\) 레코드의 마지막 블록\(EOR\), 재시작 마커\(오류 복구 및 재시작 섹션 참조\) 또는 의심되는 데이터\(즉, 전송되는 데이터에 오류가 의심되고 신뢰할 수 없음\). 이 마지막 코드는 FTP 내의 오류 제어용이 아닙니다. 이는 특정 유형의 데이터\(예: 지진 또는 기상 데이터\)를 교환하는 사이트에서 로컬 오류\(예: "자기 테이프 읽기 오류"\)에도 불구하고 모든 데이터를 보내고 받지만 전송 시 특정 데이터를 표시하려는 의도에서 비롯되었습니다. 부분이 의심됩니다\). 이 모드에서는 레코드 구조가 허용되며 모든 표현 유형을 사용할 수 있습니다.

- 헤더는 3바이트로 구성됩니다. 24비트의 헤더 정보 중 하위 16비트는 바이트 수를 나타내고, 상위 8비트는 아래와 같이 디스크립터 코드를 나타냅니다.

```text
         Block Header

            +----------------+----------------+----------------+
            | Descriptor     |    Byte Count                   |
            |         8 bits |                      16 bits    |
            +----------------+----------------+----------------+
            
```

설명자 코드는 비트 플래그로 표시됩니다.

- 설명자 바이트. 4개의 코드가 할당되었으며, 각 코드 번호는 바이트에서 해당 비트의 10진수 값입니다.

```text
            Code     Meaning
            
             128     End of data block is EOR
              64     End of data block is EOF
              32     Suspected errors in data block
              16     Data block is a restart marker
```

- 이 인코딩을 사용하면 특정 블록에 대해 둘 이상의 설명자 코딩 조건이 존재할 수 있습니다. 필요한 만큼 많은 비트를 플래그할 수 있습니다.

- 재시작 마커는 제어 연결을 통해 사용되는 언어\(예: default--NVT-ASCII\)로 인쇄 가능한 문자를 나타내는 8비트 바이트의 정수로 데이터 스트림에 내장됩니다. <SP\>\(해당 언어의 공백\)는 재시작 표시 내에서 사용되어서는 안 됩니다.

- 예를 들어 6자리 마커를 전송하려면 다음이 전송됩니다.

```text
            +--------+--------+--------+
            |Descrptr|  Byte count     |
            |code= 16|             = 6 |
            +--------+--------+--------+

            +--------+--------+--------+
            | Marker | Marker | Marker |
            | 8 bits | 8 bits | 8 bits |
            +--------+--------+--------+

            +--------+--------+--------+
            | Marker | Marker | Marker |
            | 8 bits | 8 bits | 8 bits |
            +--------+--------+--------+

      3.4.3.  COMPRESSED MODE
```

- 전송되는 정보에는 세 가지 종류가 있습니다: 일반 데이터, 바이트 문자열로 전송; 복제 또는 필러로 구성된 압축 데이터 및 제어 정보는 2바이트 이스케이프 시퀀스로 전송됩니다. n\>0바이트\(최대 127\)의 일반 데이터가 전송되는 경우 이러한 n바이트 앞에는 가장 왼쪽 비트가 0으로 설정되고 가장 오른쪽 7비트가 숫자 n을 포함하는 바이트가 옵니다.

```text
         Byte string:

             1       7                8                     8
            +-+-+-+-+-+-+-+-+ +-+-+-+-+-+-+-+-+     +-+-+-+-+-+-+-+-+
            |0|       n     | |    d(1)       | ... |      d(n)     |
            +-+-+-+-+-+-+-+-+ +-+-+-+-+-+-+-+-+     +-+-+-+-+-+-+-+-+
                                          ^             ^
                                          |---n bytes---|
                                              of data
```

n 데이터 바이트의 문자열 d\(1\),..., d\(n\)

- 개수 n은 양수여야 합니다.

- 데이터 바이트 d의 n 복제 문자열을 압축하기 위해 다음 2바이트가 전송됩니다.

```text
         Replicated Byte:

              2       6               8
            +-+-+-+-+-+-+-+-+ +-+-+-+-+-+-+-+-+
            |1 0|     n     | |       d       |
            +-+-+-+-+-+-+-+-+ +-+-+-+-+-+-+-+-+
```

- n 필러 바이트의 문자열은 단일 바이트로 압축될 수 있으며, 여기서 필러 바이트는 표현 유형에 따라 다릅니다. 유형이 ASCII 또는 EBCDIC인 경우 필러 바이트는 <SP\>\(공백, ASCII 코드 32, EBCDIC 코드 64\)입니다. 유형이 이미지 또는 로컬 바이트인 경우 필러는 0바이트입니다.

```text
         Filler String:

              2       6
            +-+-+-+-+-+-+-+-+
            |1 1|     n     |
            +-+-+-+-+-+-+-+-+
```

- 이스케이프 시퀀스는 더블바이트이며, 그 중 첫 번째는

- 이스케이프 바이트\(모두 0\) 및 두 번째 바이트에는 블록 모드에서 정의된 설명 코드가 포함됩니다. 설명자 코드는 블록 모드에서와 동일한 의미를 가지며 후속 바이트 문자열에 적용됩니다.

- 압축 모드는 약간의 추가 CPU 비용으로 대규모 네트워크 전송에서 대역폭을 늘리는 데 유용합니다. RJE 호스트에서 생성된 파일과 같은 프린터 파일의 크기를 줄이는 데 가장 효과적으로 사용할 수 있습니다.

3.5. 오류 복구 및 다시 시작

- 데이터 전송 중 손실되거나 뒤섞인 비트를 감지할 수 있는 규정이 없습니다. 이 수준의 오류 제어는 TCP에 의해 처리됩니다. 그러나 전체 시스템 오류\(호스트, FTP 프로세스 또는 기본 네트워크 오류 포함\)로부터 사용자를 보호하기 위해 다시 시작 절차가 제공됩니다.

- 재시작 절차는 데이터 전송의 블록 및 압축 모드에 대해서만 정의됩니다. 일부 마커 정보와 함께 데이터 스트림에 특수 마커 코드를 삽입하려면 데이터 송신자가 필요합니다. 마커 정보는 발신자에게만 의미가 있지만 제어 연결의 기본 언어 또는 협상된 언어\(ASCII 또는 EBCDIC\)로 인쇄 가능한 문자로 구성되어야 합니다. 마커는 비트 수, 레코드 수 또는 시스템이 데이터 체크포인트를 식별할 수 있는 기타 정보를 나타낼 수 있습니다. 데이터 수신자는 재시작 절차를 구현하는 경우 수신 시스템에서 이 마커의 해당 위치를 표시하고 이 정보를 사용자에게 반환합니다.

- 시스템 장애가 발생한 경우 사용자는 FTP 재시작 절차를 통해 마커 지점을 식별하여 데이터 전송을 다시 시작할 수 있습니다. 다음 예에서는 다시 시작 절차의 사용을 보여줍니다.

- 데이터 송신자는 데이터 스트림의 편리한 지점에 적절한 마커 블록을 삽입합니다. 수신 호스트는 파일 시스템에 해당 데이터 포인트를 표시하고 마지막으로 알려진 발신자 및 수신자 표시 정보를 직접 또는 110 응답의 제어 연결을 통해 사용자에게 전달합니다\(발신자가 누구인지에 따라 다름\). 시스템 오류가 발생하는 경우 사용자 또는 컨트롤러 프로세스는 서버의 마커 코드를 인수로 사용하여 다시 시작 명령을 전송하여 마지막 서버 마커에서 서버를 다시 시작합니다. 재시작 명령은 제어 장치를 통해 전송됩니다.

- 연결이며 시스템 오류가 발생했을 때 실행 중이던 명령\(예: RETR, STOR 또는 LIST\)이 바로 뒤에옵니다.

---
## **4.  FILE TRANSFER FUNCTIONS**

user-PI에서 server-PI로의 통신 채널은 사용자에서 표준 서버 포트로의 TCP 연결로 설정됩니다. 사용자 프로토콜 해석기는 FTP 명령을 보내고 수신된 응답을 해석하는 일을 담당합니다. 서버-PI는 명령을 해석하고 응답을 보내고 DTP에 데이터 연결을 설정하고 데이터를 전송하도록 지시합니다. 데이터 전송\(수동 전송 프로세스\)의 두 번째 당사자가 사용자-DTP인 경우 이는 사용자-FTP 호스트의 내부 프로토콜을 통해 관리됩니다. 두 번째 서버-DTP인 경우 사용자-PI의 명령에 따라 PI에 의해 관리됩니다. FTP 응답은 다음 섹션에서 설명됩니다. 이 섹션의 몇 가지 명령에 대한 설명에서 가능한 응답을 명시적으로 설명하는 것이 도움이 됩니다.

```text
   4.1.  FTP COMMANDS

      4.1.1.  ACCESS CONTROL COMMANDS
```

- 다음 명령은 액세스 제어 식별자를 지정합니다\(명령 코드는 괄호 안에 표시됨\).

```text
         USER NAME (USER)
```

- 인수 필드는 사용자를 식별하는 Telnet 문자열입니다. 사용자 ID는 서버가 파일 시스템에 액세스하는 데 필요한 ID입니다. 이 명령은 일반적으로 제어 연결이 이루어진 후 사용자가 전송하는 첫 번째 명령입니다\(일부 서버에서는 이 명령이 필요할 수 있음\). 일부 서버에서는 비밀번호 및/또는 계정 명령 형태의 추가 식별 정보가 필요할 수도 있습니다. 서버는 액세스 제어 및/또는 계정 정보를 변경하기 위해 언제든지 새로운 USER 명령을 입력하도록 허용할 수 있습니다. 이는 이미 제공된 모든 사용자, 비밀번호 및 계정 정보를 플러시하고 로그인 시퀀스를 다시 시작하는 효과가 있습니다. 모든 전송 매개변수는 변경되지 않으며 진행 중인 모든 파일 전송은 이전 액세스 제어 매개변수에 따라 완료됩니다.

```text
         PASSWORD (PASS)
```

- 인수 필드는 사용자의 비밀번호를 지정하는 Telnet 문자열입니다. 이 명령은 user name 명령 바로 앞에 와야 하며 일부 사이트의 경우 액세스 제어를 위한 사용자 식별을 완료합니다. 비밀번호 정보는 매우 민감하므로 일반적으로 이를 "마스킹"하거나 입력을 억제하는 것이 바람직합니다. 서버에는 이를 달성할 수 있는 완벽한 방법이 없는 것 같습니다. 따라서 민감한 비밀번호 정보를 숨기는 것은 사용자 FTP 프로세스의 책임입니다.

```text
         ACCOUNT (ACCT)
```

- 인수 필드는 사용자 계정을 식별하는 Telnet 문자열입니다. 이 명령은 반드시 USER 명령과 관련이 있는 것은 아닙니다. 일부 사이트에서는 로그인을 위한 계정이 필요하고 다른 사이트에서는 파일 저장과 같은 특정 액세스에만 계정이 필요할 수 있기 때문입니다. 후자의 경우 명령은 언제든지 도착할 수 있습니다.

- 자동화를 위해 이러한 경우를 구별하기 위한 응답 코드가 있습니다. 로그인에 계정 정보가 필요한 경우 성공적인 PASSword 명령에 대한 응답은 응답 코드 332입니다. 반면, 로그인에 계정 정보가 필요하지 않은 경우에 대한 응답은 다음과 같습니다. 성공적인 PASSword 명령은 230입니다. 그리고 대화에서 나중에 발행된 명령에 계정 정보가 필요한 경우 서버는 명령을 저장하는지\(ACCounT 명령 수신 대기 중\) 또는 폐기하는지에 따라 각각 332 또는 532 응답을 반환해야 합니다.

```text
         CHANGE WORKING DIRECTORY (CWD)
```

- 이 명령을 사용하면 사용자는 로그인이나 계정 정보를 변경하지 않고도 파일 저장이나 검색을 위해 다른 디렉터리나 데이터 세트로 작업할 수 있습니다. 전송 매개변수도 비슷하게 변경되지 않습니다. 인수는 디렉토리나 기타 시스템 종속 파일 그룹 지정자를 지정하는 경로 이름입니다.

```text
         CHANGE TO PARENT DIRECTORY (CDUP)
```

- 이 명령은 CWD의 특수한 경우로 서로 다른 운영 체제 간 디렉토리 트리를 전송하는 프로그램의 구현을 단순화하기 위해 포함되었습니다.

- 상위 디렉터리의 이름을 지정하는 구문입니다. 응답 코드는 CWD의 응답 코드와 동일해야 합니다. 자세한 내용은 부록 II를 참조하세요.

```text
         STRUCTURE MOUNT (SMNT)
```

- 이 명령을 사용하면 사용자는 로그인이나 계정 정보를 변경하지 않고 다른 파일 시스템 데이터 구조를 마운트할 수 있습니다. 전송 매개변수도 비슷하게 변경되지 않습니다. 인수는 디렉토리나 기타 시스템 종속 파일 그룹 지정자를 지정하는 경로 이름입니다.

```text
         REINITIALIZE (REIN)
```

- 이 명령은 진행 중인 전송 완료를 허용하는 경우를 제외하고 모든 I/O 및 계정 정보를 플러시하여 USER를 종료합니다. 모든 매개변수가 기본 설정으로 재설정되고 제어 연결은 열린 상태로 유지됩니다. 이는 제어 연결이 열린 직후 사용자가 자신을 발견하는 상태와 동일하다. USER 명령이 뒤따를 것으로 예상될 수 있습니다.

```text
         LOGOUT (QUIT)
```

- 이 명령은 USER를 종료시키며, 파일 전송이 진행되지 않는 경우 서버는 제어 연결을 종료합니다. 파일 전송이 진행 중이면 결과 응답을 위해 연결이 열린 상태로 유지되고 서버는 연결을 닫습니다. 사용자 프로세스가 여러 사용자에 대해 파일을 전송하지만 각 사용자에 대한 연결을 닫았다가 다시 열고 싶지 않은 경우 QUIT 대신 REIN 명령을 사용해야 합니다.

- 제어 연결이 예기치 않게 닫히면 서버가 중단\(ABOR\) 및 로그아웃\(QUIT\)이라는 효과적인 조치를 취하게 됩니다.

```text
      4.1.2.  TRANSFER PARAMETER COMMANDS
```

- 모든 데이터 전송 매개변수에는 기본값이 있으며, 데이터 전송 매개변수를 지정하는 명령은 기본 매개변수 값을 변경하려는 경우에만 필요합니다. 기본값은 마지막으로 지정한 값이며, 값을 지정하지 않은 경우 표준 기본값은 여기에 명시된 대로입니다. 이는 서버가 적용 가능한 기본값을 "기억"해야 함을 의미합니다. 명령은 FTP 서비스 요청보다 먼저 이루어져야 한다는 점을 제외하면 어떤 순서로든 가능합니다. 다음 명령은 데이터 전송 매개변수를 지정합니다.

```text
         DATA PORT (PORT)
```

- 인수는 데이터 연결에 사용되는 데이터 포트에 대한 HOST-PORT 사양입니다. 사용자 및 서버 데이터 포트 모두에 대한 기본값이 있으며 일반적인 상황에서는 이 명령과 해당 응답이 필요하지 않습니다. 이 명령을 사용하는 경우 인수는 32비트 인터넷 호스트 주소와 16비트 TCP 포트 주소를 연결한 것입니다. 이 주소 정보는 8비트 필드로 나누어지고 각 필드의 값은 10진수\(문자열 표현\)로 전송됩니다. 필드는 쉼표로 구분됩니다. 포트 명령은 다음과 같습니다:

```text
               PORT h1,h2,h3,h4,p1,p2
```

- 여기서 h1은 인터넷 호스트 주소의 상위 8비트입니다.

```text
         PASSIVE (PASV)
```

- 이 명령은 서버-DTP가 데이터 포트\(기본 데이터 포트가 아님\)에서 "수신"하고 전송 명령 수신 시 연결을 시작하는 대신 연결을 기다리도록 요청합니다. 이 명령에 대한 응답에는 이 서버가 수신 대기 중인 호스트 및 포트 주소가 포함됩니다.

```text
         REPRESENTATION TYPE (TYPE)
```

- 인수는 데이터 표현 및 저장 섹션에 설명된 대로 표현 유형을 지정합니다. 몇몇 유형은 두 번째 매개변수를 사용합니다. 첫 번째 매개변수는 단일 Telnet 문자로 표시되며 ASCII 및 EBCDIC의 두 번째 형식 매개변수도 마찬가지입니다. 로컬 바이트의 두 번째 매개변수는 바이트 크기를 나타내는 10진수 정수입니다. 매개변수는 <SP\>\(공백, ASCII 코드 32\)로 구분됩니다.

- 유형에 따라 다음 코드가 할당됩니다.

\ /

- A - ASCII | | N - 인쇄되지 않음 |-\><-| T - Telnet 형식 이펙터 E - EBCDIC| | C - 캐리지 제어\(ASA\) / \ I - 이미지 L <바이트 크기\> - 로컬 바이트 바이트 크기

- 기본 표시 유형은 ASCII Non-print입니다. Format 매개변수가 변경되고 나중에 첫 번째 인수만 변경되면 Format은 Non-print 기본값으로 돌아갑니다.

```text
         FILE STRUCTURE (STRU)
```

- 인수는 데이터 표현 및 저장 섹션에 설명된 파일 구조를 지정하는 단일 Telnet 문자 코드입니다.

- 구조에는 다음 코드가 할당됩니다.

```text
               F - File (no record structure)
               R - Record structure
               P - Page structure
```

- 기본 구조는 파일입니다.

```text
         TRANSFER MODE (MODE)
```

- 인수는 전송 모드 섹션에 설명된 데이터 전송 모드를 지정하는 단일 Telnet 문자 코드입니다.

- 전송 모드에는 다음 코드가 할당됩니다.

```text
               S - Stream
               B - Block
               C - Compressed
```

- 기본 전송 모드는 스트림입니다.

```text
      4.1.3.  FTP SERVICE COMMANDS
```

- FTP 서비스 명령은 사용자가 요청한 파일 전송 또는 파일 시스템 기능을 정의합니다. FTP 서비스 명령의 인수는 일반적으로 경로 이름입니다. 경로 이름 구문은 서버 사이트 규칙\(표준 기본값 적용 가능\)과 제어 연결의 언어 규칙을 따라야 합니다. 제안된 기본 처리는 마지막으로 지정된 장치, 디렉터리 또는 파일 이름을 사용하거나 로컬 사용자에 대해 정의된 표준 기본값을 사용하는 것입니다. 명령은 "rename from" 명령 뒤에 "rename to" 명령이 와야 하고 재시작 명령 뒤에 중단된 서비스 명령\(예: STOR 또는 RETR\)이 와야 한다는 점을 제외하면 어떤 순서로든 가능합니다. FTP 서비스에 대한 응답으로 전송되는 데이터

- 명령은 특정 정보 응답을 제외하고 항상 데이터 연결을 통해 전송됩니다. 다음 명령은 FTP 서비스 요청을 지정합니다.

```text
         RETRIEVE (RETR)
```

- 이 명령은 서버 DTP가 경로 이름에 지정된 파일의 복사본을 데이터 연결의 다른 쪽 끝에 있는 서버 또는 사용자 DTP로 전송하도록 합니다. 서버 사이트에 있는 파일의 상태와 내용은 영향을 받지 않습니다.

```text
         STORE (STOR)
```

- 이 명령은 서버-DTP가 데이터 연결을 통해 전송된 데이터를 수락하고 해당 데이터를 서버 사이트에 파일로 저장하도록 합니다. 경로명에 지정된 파일이 서버 사이트에 존재하는 경우 해당 파일의 내용은 전송되는 데이터로 대체됩니다. 경로 이름에 지정된 파일이 아직 존재하지 않으면 서버 사이트에 새 파일이 생성됩니다.

```text
         STORE UNIQUE (STOU)
```

- 이 명령은 결과 파일이 해당 디렉터리에 고유한 이름으로 현재 디렉터리에 생성된다는 점을 제외하면 STOR처럼 동작합니다. 250 전송 시작됨 응답에는 생성된 이름이 포함되어야 합니다.

```text
         APPEND (with create) (APPE)
```

- 이 명령은 서버-DTP가 데이터 연결을 통해 전송된 데이터를 수락하고 해당 데이터를 서버 사이트의 파일에 저장하도록 합니다. 경로 이름에 지정된 파일이 서버 사이트에 존재하는 경우 해당 파일에 데이터가 추가됩니다. 그렇지 않으면 경로 이름에 지정된 파일이 서버 사이트에 생성됩니다.

```text
         ALLOCATE (ALLO)
```

- 일부 서버에서는 전송할 새 파일을 수용할 수 있는 충분한 저장 공간을 확보하기 위해 이 명령이 필요할 수 있습니다. 인수는 파일용으로 예약될 저장소의 바이트 수\(논리적 바이트 크기 사용\)를 나타내는 10진수 정수입니다. 레코드 또는 페이지 구조와 함께 전송된 파일의 경우 최대 레코드 또는 페이지 크기\(논리적 바이트 단위\)가 필요할 수도 있습니다. 이는 두 번째 인수 필드에 10진수로 표시됩니다.

- 명령. 이 두 번째 인수는 선택 사항이지만, 존재할 경우 세 개의 Telnet 문자 <SP\> R <SP\>로 첫 번째 인수와 구분되어야 합니다. 이 명령 뒤에는 STORe 또는 APPEnd 명령이 와야 합니다. 파일의 최대 크기를 미리 선언할 필요가 없는 서버에서는 ALLO 명령을 NOOP\(작업 없음\)로 처리해야 하며, 최대 레코드나 페이지 크기에만 관심이 있는 서버에서는 더미 값을 허용해야 합니다. 첫 번째 인수를 무시하고 무시합니다.

```text
         RESTART (REST)
```

- 인수 필드는 파일 전송을 다시 시작할 서버 마커를 나타냅니다. 이 명령은 파일 전송을 유발하지 않지만 파일을 지정된 데이터 체크포인트로 건너뜁니다. 이 명령 바로 뒤에는 파일 전송을 재개하는 적절한 FTP 서비스 명령이 와야 합니다.

```text
         RENAME FROM (RNFR)
```

- 이 명령은 이름을 바꿀 파일의 이전 경로 이름을 지정합니다. 이 명령 바로 뒤에는 새 파일 경로 이름을 지정하는 "rename to" 명령이 와야 합니다.

```text
         RENAME TO (RNTO)
```

이 명령은 파일의 새 경로 이름을 지정합니다.

- 바로 앞의 "rename from" 명령에 지정됩니다. 두 명령을 함께 사용하면 파일 이름이 변경됩니다.

```text
         ABORT (ABOR)
```

- 이 명령은 이전 FTP 서비스 명령 및 관련 데이터 전송을 중단하도록 서버에 지시합니다. 중단 명령에는 FTP 명령 섹션에서 설명한 대로 서버에서 강제로 인식하도록 하는 "특별 조치"가 필요할 수 있습니다. 이전 명령이 완료된 경우\(데이터 전송 포함\) 아무런 조치도 취하지 않습니다. 제어 연결은 서버에서 닫히는 것이 아니라 데이터 연결은 닫아야 합니다.

- 서버가 이 명령을 수신한 경우에는 \(1\) FTP 서비스 명령이 이미 완료되었거나 \(2\) FTP 서비스 명령이 아직 진행 중인 경우 두 가지 경우가 있습니다.

- 첫 번째 경우, 서버는 데이터 연결을 닫고\(열려 있는 경우\) 중단 명령이 성공적으로 처리되었음을 나타내는 226 응답으로 응답합니다.

- 두 번째 경우, 서버는 진행 중인 FTP 서비스를 중단하고 데이터 연결을 닫으며 서비스 요청이 비정상적으로 종료되었음을 나타내는 426 응답을 반환합니다. 그런 다음 서버는 중단 명령이 성공적으로 처리되었음을 나타내는 226 응답을 보냅니다.

```text
         DELETE (DELE)
```

- 이 명령은 경로명에 지정된 파일을 서버 사이트에서 삭제합니다. 추가 보호 수준이 필요한 경우\(예: "삭제하시겠습니까?"라는 쿼리\) 사용자 FTP 프로세스에서 이를 제공해야 합니다.

```text
         REMOVE DIRECTORY (RMD)
```

- 이 명령을 사용하면 경로 이름에 지정된 디렉터리가 디렉터리\(경로 이름이 절대인 경우\) 또는 현재 작업 디렉터리의 하위 디렉터리\(경로 이름이 상대인 경우\)로 제거됩니다. 부록 II를 참조하세요.

```text
         MAKE DIRECTORY (MKD)
```

- 이 명령을 사용하면 경로 이름에 지정된 디렉터리가 디렉터리\(경로 이름이 절대인 경우\) 또는 현재 작업 디렉터리의 하위 디렉터리\(경로 이름이 상대인 경우\)로 생성됩니다. 부록 II를 참조하세요.

```text
         PRINT WORKING DIRECTORY (PWD)
```

이 명령은 현재 작업의 이름을 지정합니다.

- 응답으로 반환될 디렉터리입니다. 부록 II를 참조하세요.

```text
         LIST (LIST)
```

- 이 명령은 목록이 서버에서 패시브 DTP로 전송되도록 합니다. 경로 이름이 디렉터리나 다른 파일 그룹을 지정하는 경우 서버는 지정된 디렉터리의 파일 목록을 전송해야 합니다. 경로 이름이 파일을 지정하는 경우 서버는 파일에 대한 현재 정보를 보내야 합니다. null 인수는 사용자의 현재 작업 디렉터리 또는 기본 디렉터리를 의미합니다. 데이터 전송은 ASCII 유형 또는 EBCDIC 유형의 데이터 연결을 통해 이루어집니다. \(사용자는 반드시

- TYPE이 적절한 ASCII 또는 EBCDIC인지 확인하십시오. 파일의 정보는 시스템마다 크게 다를 수 있으므로 이 정보는 프로그램에서 자동으로 사용하기 어려울 수 있지만 인간 사용자에게는 매우 유용할 수 있습니다.

```text
         NAME LIST (NLST)
```

- 이 명령은 디렉터리 목록이 서버에서 사용자 사이트로 전송되도록 합니다. 경로 이름은 디렉토리나 기타 시스템별 파일 그룹 설명자를 지정해야 합니다. null 인수는 현재 디렉터리를 의미합니다. 서버는 파일 이름 스트림을 반환하며 다른 정보는 반환하지 않습니다. 데이터는 <CRLF\> 또는 <NL\>로 구분된 유효한 경로 이름 문자열로서 데이터 연결을 통해 ASCII 또는 EBCDIC 유형으로 전송됩니다. \(사용자는 TYPE이 올바른지 다시 확인해야 합니다.\) 이 명령은 프로그램이 파일을 자동으로 추가 처리하는 데 사용할 수 있는 정보를 반환하기 위한 것입니다. 예를 들어 "다중 가져오기" 기능을 구현하는 경우입니다.

```text
         SITE PARAMETERS (SITE)
```

- 이 명령은 파일 전송에 필수적이지만 프로토콜에 명령으로 포함될 만큼 보편적이지 않은 시스템 관련 서비스를 제공하기 위해 서버에서 사용됩니다. 이러한 서비스의 성격과 구문 사양은 HELP SITE 명령에 대한 응답으로 명시될 수 있습니다.

```text
         SYSTEM (SYST)
```

- 이 명령은 서버의 운영체제 종류를 알아내는 데 사용됩니다. 응답은 현재 버전의 할당 번호 문서\[4\]에 나열된 시스템 이름 중 하나를 첫 번째 단어로 포함해야 합니다.

```text
         STATUS (STAT)
```

- 이 명령은 상태 응답이 응답 형식으로 제어 연결을 통해 전송되도록 합니다. 명령은 파일 전송 중에 전송될 수 있습니다\(텔넷 IP 및 동기화 신호와 함께 - FTP 명령 섹션 참조\). 이 경우 서버는 진행 중인 작업 상태로 응답하거나 파일 간에 전송될 수 있습니다. 전송. 후자의 경우 명령에 인수 필드가 있을 수 있습니다. 인수가 경로 이름인 경우 명령은 데이터가 다음과 같다는 점을 제외하면 "list" 명령과 유사합니다.

- 제어 연결을 통해 전송됩니다. 부분 경로 이름이 제공되면 서버는 해당 사양과 관련된 파일 이름이나 속성 목록으로 응답할 수 있습니다. 인수가 제공되지 않으면 서버는 서버 FTP 프로세스에 대한 일반 상태 정보를 반환해야 합니다. 여기에는 모든 전송 매개변수의 현재 값과 연결 상태가 포함되어야 합니다.

```text
         HELP (HELP)
```

이 명령은 서버가 유용한 정보를 보내도록 합니다.

- 사용자에 대한 제어 연결을 통한 구현 상태에 관한 정보. 명령은 인수\(예: 명령 이름\)를 취하고 보다 구체적인 정보를 응답으로 반환할 수 있습니다. 응답 유형은 211 또는 214입니다. USER 명령을 입력하기 전에 HELP를 허용하는 것이 좋습니다. 서버는 예를 들어 HELP SITE에 대한 응답으로 사이트 종속 매개변수를 지정하기 위해 이 응답을 사용할 수 있습니다.

```text
         NOOP (NOOP)
```

- 이 명령은 매개 변수나 이전에 입력한 명령에 영향을 주지 않습니다. 서버가 OK 응답을 보내는 것 외에는 어떤 작업도 지정하지 않습니다.

파일 전송 프로토콜은 제어 연결을 통한 모든 통신에 대해 Telnet 프로토콜의 사양을 따릅니다. Telnet 통신에 사용되는 언어는 협상된 옵션일 수 있으므로 다음 두 섹션의 모든 참조는 "Telnet 언어" 및 해당 "Telnet 라인 끝 코드"에 대한 것입니다. 현재 이를 NVT-ASCII 및 <CRLF\>를 의미하는 것으로 간주할 수 있습니다. Telnet 프로토콜의 다른 사양은 인용되지 않습니다.

FTP 명령은 "Telnet 줄 끝 코드"로 끝나는 "Telnet 문자열"입니다. 명령 코드 자체는 매개변수가 뒤따르는 경우 문자 <SP\>\(공백\)로 끝나고 그렇지 않으면 Telnet-EOL로 끝나는 알파벳 문자입니다. 이 섹션에서는 명령 코드와 명령 의미를 설명합니다. 명령의 자세한 구문은 명령 섹션에서 지정하고, 응답 순서는 명령 및 응답 순서 섹션에서 논의하며, 명령 사용을 설명하는 시나리오는 일반적인 FTP 시나리오 섹션에서 제공됩니다.

FTP 명령은 액세스 제어 식별자, 데이터 전송 매개변수 또는 FTP 서비스 요청을 지정하는 명령으로 분할될 수 있습니다. 데이터 전송이 진행되는 동안 특정 명령\(예: ABOR, STAT, QUIT\)이 제어 연결을 통해 전송될 수 있습니다. 일부

서버는 제어 및 데이터 연결을 동시에 모니터링하지 못할 수 있으며, 이 경우 서버의 주의를 끌기 위해 특별한 조치가 필요합니다. 잠정적으로 다음과 같은 순서 형식이 권장됩니다.

- 1. 사용자 시스템은 Telnet 스트림에 Telnet "인터럽트 프로세스"\(IP\) 신호를 삽입합니다.

- 2. 사용자 시스템은 Telnet "Synch" 신호를 보냅니다.

- 3. 사용자 시스템은 Telnet 스트림에 명령\(예: ABOR\)을 삽입합니다.

- 4. 서버 PI는 "IP"를 수신한 후 Telnet 스트림에서 정확히 하나의 FTP 명령을 검색합니다.

\(다른 서버의 경우 이 작업이 필요하지 않을 수 있지만 위에 나열된 작업은 비정상적인 효과를 가져서는 안 됩니다.\)

```text
   4.2.  FTP REPLIES
```

- 파일 전송 프로토콜 명령에 대한 응답은 파일 전송 과정에서 요청과 작업의 동기화를 보장하고 사용자 프로세스가 항상 서버 상태를 알 수 있도록 고안되었습니다. 모든 명령은 하나 이상의 응답을 생성해야 하지만 응답이 두 개 이상일 수도 있습니다. 후자의 경우 여러 응답을 쉽게 구별할 수 있어야 합니다. 또한 일부 명령은 USER, PASS 및 ACCT, RNFR 및 RNTO와 같은 순차적 그룹에서 발생합니다. 응답은 이전 명령이 모두 성공한 경우 중간 상태의 존재를 보여줍니다. 시퀀스의 특정 지점에서 오류가 발생하면 처음부터 전체 시퀀스를 반복해야 합니다.

- 명령-응답 시퀀스의 세부 사항은 아래 상태 다이어그램 세트에 명시되어 있습니다.

- FTP 응답은 세 자리 숫자\(세 개의 영숫자 문자로 전송됨\)와 그 뒤에 오는 일부 텍스트로 구성됩니다. 이 숫자는 오토마타가 다음에 어떤 상태로 들어갈지 결정하는 데 사용됩니다. 텍스트는 인간 사용자를 위한 것입니다. 세 자리 숫자에는 사용자 프로세스\(User-PI\)가 텍스트를 검사할 필요가 없고 필요에 따라 텍스트를 삭제하거나 사용자에게 전달할 수 있을 만큼 충분한 인코딩된 정보가 포함되어 있습니다. 특히 텍스트는 서버에 따라 달라질 수 있으므로 각 응답 코드마다 텍스트가 다를 수 있습니다.

- 응답은 3자리 코드와 공백을 포함하도록 정의됩니다.

- <SP\> 뒤에는 한 줄의 텍스트\(일부 최대 줄 길이가 지정됨\)가 오고 Telnet 줄 끝 코드로 종료됩니다. 그러나 텍스트가 한 줄보다 긴 경우도 있습니다. 이러한 경우 사용자 프로세스가 응답 읽기를 중지하고\(예: 제어 연결에서 입력 처리 중지\) 다른 작업을 수행할 수 있는 시기를 알 수 있도록 전체 텍스트를 괄호로 묶어야 합니다. 이를 위해서는 두 개 이상의 라인이 올 것임을 나타내기 위해 첫 번째 라인에 특별한 형식이 필요하고, 마지막 라인으로 지정하려면 마지막 라인에 또 다른 형식이 필요합니다. 이들 중 적어도 하나에는 트랜잭션 상태를 나타내는 적절한 응답 코드가 포함되어 있어야 합니다. 모든 진영을 만족시키기 위해 첫 번째 줄과 마지막 줄의 코드가 동일해야 한다는 것이 결정되었습니다.

- 따라서 여러 줄 응답의 형식은 첫 번째 줄이 정확한 필수 응답 코드로 시작하고 바로 뒤에 하이픈 "-"\(마이너스라고도 함\), 텍스트가 뒤따르는 것입니다. 마지막 줄은 동일한 코드로 시작하고 바로 Space <SP\>, 선택적으로 일부 텍스트 및 Telnet 줄 끝 코드가 옵니다.

예를 들어:

- 123-첫 번째 줄 두 번째 줄 234 숫자 123으로 시작하는 줄 마지막 줄

- 그런 다음 사용자 프로세스는 줄 시작 부분에서 <SP\>\(공백\) 뒤에 동일한 응답 코드가 두 번째로 나타나는 것을 검색하고 모든 중간 줄을 무시하면 됩니다. 중간 줄이 3자리 숫자로 시작하는 경우 서버는 혼동을 피하기 위해 앞 부분을 채워야 합니다.

- 이 방식을 사용하면 "인공적인" 첫 번째 줄과 마지막 줄을 추가하여 응답 정보\(예: STAT 응답\)에 표준 시스템 루틴을 사용할 수 있습니다. 드물지만 이러한 루틴이 줄 시작 부분에 세 자리 숫자와 공백을 생성할 수 있는 경우 각 텍스트 줄의 시작 부분은 공백과 같은 일부 중립 텍스트로 오프셋되어야 합니다.

- 이 방식은 여러 줄의 응답이 중첩되지 않을 수 있다고 가정합니다.

- 답변의 세 자리 숫자는 각각 특별한 의미를 갖습니다. 이는 사용자 프로세스에 의한 매우 간단한 응답부터 매우 정교한 응답까지 허용하기 위한 것입니다. 첫 번째 숫자는 응답이 좋은지, 나쁜지, 불완전한지를 나타냅니다. \(상태 다이어그램 참조\) 복잡하지 않은 사용자 프로세스는 다음 작업\(계획대로 진행,

- 다시 실행, 축소 등\) 이 첫 번째 숫자를 간단히 검토하면 됩니다. 어떤 종류의 오류가 발생했는지\(예: 파일 시스템 오류, 명령 구문 오류\) 대략적으로 알고 싶어하는 사용자 프로세스는 두 번째 숫자를 검사하고 세 번째 숫자는 가장 미세한 정보 등급\(예: 선행 RNFR 없는 RNTO 명령\)을 위해 예약할 수 있습니다. .

- 응답 코드의 첫 번째 숫자에는 5개의 값이 있습니다.

```text
            1yz   Positive Preliminary reply
```

- 요청된 작업이 시작되고 있습니다. 새로운 명령을 계속하기 전에 또 다른 응답을 기대하십시오. \(완료 응답 전에 다른 명령을 보내는 사용자 프로세스는 프로토콜을 위반하지만 서버 FTP 프로세스는 이전 명령이 진행 중인 동안 도착하는 모든 명령을 대기열에 넣어야 합니다.\) 이러한 유형의 응답은 다음을 나타내는 데 사용할 수 있습니다. 명령이 승인되었으며 사용자 프로세스는 이제 동시 모니터링이 어려운 구현을 위해 데이터 연결에 주의를 기울일 수 있습니다. 서버-FTP 프로세스는 명령당 최대 1개의 1yz 응답을 보낼 수 있습니다.

```text
            2yz   Positive Completion reply
```

- 요청한 작업이 성공적으로 완료되었습니다. 새로운 요청이 시작될 수 있습니다.

```text
            3yz   Positive Intermediate reply
```

- 명령이 수락되었지만 요청한 작업은 추가 정보 수신을 기다리는 동안 보류 중입니다. 사용자는 이 정보를 지정하는 다른 명령을 보내야 합니다. 이 응답은 명령 시퀀스 그룹에서 사용됩니다.

```text
            4yz   Transient Negative Completion reply
```

- 명령이 승인되지 않아 요청한 작업이 수행되지 않았지만 오류 상태는 일시적이므로 작업을 다시 요청할 수 있습니다. 사용자는 명령 시퀀스의 시작 부분으로 돌아가야 합니다. 특히 두 개의 서로 다른 사이트\(서버 및 사용자 프로세스\)가 해석에 동의해야 하는 경우 "일시적"이라는 의미를 할당하기가 어렵습니다. 4yz 카테고리의 각 응답은 시간 값이 약간 다를 수 있지만 의도는

- 사용자 프로세스가 다시 시도하도록 권장됩니다. 응답이 4yz 또는 5yz\(영구 부정\) 범주에 속하는지 결정하는 경험적 규칙은 명령 형식이나 사용자 또는 서버의 속성\(예: 명령은 사용된 인수와 철자가 동일합니다. 사용자는 파일 액세스나 사용자 이름을 변경하지 않습니다. 서버는 새로운 구현을 설정하지 않습니다.\)

```text
            5yz   Permanent Negative Completion reply
```

- 명령이 승인되지 않았으며 요청한 작업이 수행되지 않았습니다. 사용자 프로세스는 정확한 요청을 \(동일한 순서로\) 반복하지 않는 것이 좋습니다. 일부 "영구적인" 오류 조건도 수정될 수 있으므로 인간 사용자는 미래의 특정 시점\(예: 철자가 변경된 후 또는 사용자가 직접 작업을 수행하여 명령 시퀀스를 다시 시작하도록 사용자 프로세스에 지시할 수 있음\)을 원할 수 있습니다. 그의 디렉토리 상태를 변경했습니다.\)

- 다음 기능 그룹은 두 번째 숫자로 인코딩됩니다.

- x0z 구문 - 이 응답은 구문 오류, 기능 범주에 맞지 않는 구문적으로 올바른 명령, 구현되지 않거나 불필요한 명령을 나타냅니다.

- x1z 정보 - 상태나 도움과 같은 정보 요청에 대한 응답입니다.

- x2z 연결 - 제어 및 데이터 연결을 참조하는 응답입니다.

- x3z 인증 및 계정 - 로그인 프로세스 및 계정 절차에 대한 답변입니다.

- x4z 아직 지정되지 않았습니다.

- x5z 파일 시스템 - 이 응답은 요청된 전송 또는 기타 파일 시스템 작업과 관련된 서버 파일 시스템의 상태를 나타냅니다.

- 세 번째 숫자는 두 번째 숫자로 지정된 각 기능 범주에서 더 미세한 의미 등급을 제공합니다. 아래 답변 목록에서 이를 확인할 수 있습니다. 텍스트를 참고하세요

보다는 각 답글과 관련된 메시지를 보내는 것이 좋습니다.

- 필수이며 연관된 명령에 따라 변경될 수도 있습니다. 반면에 응답 코드는 마지막 섹션의 사양을 엄격히 따라야 합니다. 즉, 서버 구현은 여기에 설명된 것과 약간 다른 상황에 대해 새로운 코드를 만들어서는 안 되며, 오히려 이미 정의된 코드를 적용해야 합니다.

- 성공적인 실행으로 사용자 프로세스에 새로운 정보를 제공하지 않는 TYPE 또는 ALLO와 같은 명령은 200 응답을 반환하게 됩니다. 해당 명령이 해당 컴퓨터 시스템과 관련이 없기 때문에 특정 서버-FTP 프로세스에 의해 구현되지 않는 경우\(예: TOPS20 사이트의 ALLO\) 간단한 사용자 프로세스가 계속 진행할 수 있음을 알 수 있도록 긍정적인 완료 응답이 여전히 필요합니다. 그 행동 과정. 이 경우에는 "저장소 할당이 필요하지 않습니다."라는 응답 텍스트와 함께 202 응답이 사용됩니다. 반면에 명령이 비사이트 특정 작업을 요청하고 구현되지 않은 경우 응답은 502입니다. 이를 개선한 것은 구현되었지만 구현되지 않은 매개변수를 요청하는 명령에 대한 504 응답입니다.

- 4.2.1 기능 그룹별 응답 코드

```text
         200 Command okay.
         500 Syntax error, command unrecognized.
             This may include errors such as command line too long.
         501 Syntax error in parameters or arguments.
         202 Command not implemented, superfluous at this site.
         502 Command not implemented.
         503 Bad sequence of commands.
         504 Command not implemented for that parameter.
          

         110 Restart marker reply.
             In this case, the text is exact and not left to the
             particular implementation; it must read:
                  MARK yyyy = mmmm
             Where yyyy is User-process data stream marker, and mmmm
             server's equivalent marker (note the spaces between markers
             and "=").
         211 System status, or system help reply.
         212 Directory status.
         213 File status.
         214 Help message.
             On how to use the server or the meaning of a particular
             non-standard command.  This reply is useful only to the
             human user.
         215 NAME system type.
             Where NAME is an official system name from the list in the
             Assigned Numbers document.
          
         120 Service ready in nnn minutes.
         220 Service ready for new user.
         221 Service closing control connection.
             Logged out if appropriate.
         421 Service not available, closing control connection.
             This may be a reply to any command if the service knows it
             must shut down.
         125 Data connection already open; transfer starting.
         225 Data connection open; no transfer in progress.
         425 Can't open data connection.
         226 Closing data connection.
             Requested file action successful (for example, file
             transfer or file abort).
         426 Connection closed; transfer aborted.
         227 Entering Passive Mode (h1,h2,h3,h4,p1,p2).
          
         230 User logged in, proceed.
         530 Not logged in.
         331 User name okay, need password.
         332 Need account for login.
         532 Need account for storing files.
          

         150 File status okay; about to open data connection.
         250 Requested file action okay, completed.
         257 "PATHNAME" created.
         350 Requested file action pending further information.
         450 Requested file action not taken.
             File unavailable (e.g., file busy).
         550 Requested action not taken.
             File unavailable (e.g., file not found, no access).
         451 Requested action aborted. Local error in processing.
         551 Requested action aborted. Page type unknown.
         452 Requested action not taken.
             Insufficient storage space in system.
         552 Requested file action aborted.
             Exceeded storage allocation (for current directory or
             dataset).
         553 Requested action not taken.
             File name not allowed.
         
```

- 4.2.2 응답 코드의 숫자 순서 목록

```text
         110 Restart marker reply.
             In this case, the text is exact and not left to the
             particular implementation; it must read:
                  MARK yyyy = mmmm
             Where yyyy is User-process data stream marker, and mmmm
             server's equivalent marker (note the spaces between markers
             and "=").
         120 Service ready in nnn minutes.
         125 Data connection already open; transfer starting.
         150 File status okay; about to open data connection.
          

         200 Command okay.
         202 Command not implemented, superfluous at this site.
         211 System status, or system help reply.
         212 Directory status.
         213 File status.
         214 Help message.
             On how to use the server or the meaning of a particular
             non-standard command.  This reply is useful only to the
             human user.
         215 NAME system type.
             Where NAME is an official system name from the list in the
             Assigned Numbers document.
         220 Service ready for new user.
         221 Service closing control connection.
             Logged out if appropriate.
         225 Data connection open; no transfer in progress.
         226 Closing data connection.
             Requested file action successful (for example, file
             transfer or file abort).
         227 Entering Passive Mode (h1,h2,h3,h4,p1,p2).
         230 User logged in, proceed.
         250 Requested file action okay, completed.
         257 "PATHNAME" created.
          
         331 User name okay, need password.
         332 Need account for login.
         350 Requested file action pending further information.
          
         421 Service not available, closing control connection.
             This may be a reply to any command if the service knows it
             must shut down.
         425 Can't open data connection.
         426 Connection closed; transfer aborted.
         450 Requested file action not taken.
             File unavailable (e.g., file busy).
         451 Requested action aborted: local error in processing.
         452 Requested action not taken.
             Insufficient storage space in system.
          

         500 Syntax error, command unrecognized.
             This may include errors such as command line too long.
         501 Syntax error in parameters or arguments.
         502 Command not implemented.
         503 Bad sequence of commands.
         504 Command not implemented for that parameter.
         530 Not logged in.
         532 Need account for storing files.
         550 Requested action not taken.
             File unavailable (e.g., file not found, no access).
         551 Requested action aborted: page type unknown.
         552 Requested file action aborted.
             Exceeded storage allocation (for current directory or
             dataset).
         553 Requested action not taken.
             File name not allowed.
         
```

---
## **5.  DECLARATIVE SPECIFICATIONS**

```text
   5.1.  MINIMUM IMPLEMENTATION
```

- 불필요한 오류 메시지 없이 FTP를 작동 가능하게 만들려면 모든 서버에 대해 다음과 같은 최소 구현이 필요합니다.

유형 - ASCII 비인쇄

- MODE - 스트림 구조 - 파일, 레코드 명령 - USER, QUIT, PORT, TYPE, MODE, STRU\(기본값 RETR, STOR, NOOP\).

- 전송 매개변수의 기본값은 다음과 같습니다.

```text
         TYPE - ASCII Non-print
         MODE - Stream
         STRU - File
```

- 모든 호스트는 위의 내용을 표준 기본값으로 수락해야 합니다.

```text
   5.2.  CONNECTIONS
```

- 서버 프로토콜 해석기는 포트 L에서 "수신"해야 합니다. 사용자 또는 사용자 프로토콜 해석기는 전이중 제어 연결을 시작해야 합니다. 서버 및 사용자 프로세스는 ARPA-인터넷 프로토콜 핸드북\[1\]에 지정된 대로 Telnet 프로토콜의 규칙을 따라야 합니다. 서버는 명령줄 편집을 제공할 의무가 없으며 사용자 호스트에서 수행되도록 요구할 수도 있습니다. 제어 연결은 모든 전송 및 응답이 완료된 후 사용자의 요청에 따라 서버에 의해 종료됩니다.

- 사용자-DTP는 지정된 데이터 포트에서 "수신"해야 합니다. 이는 기본 사용자 포트\(U\)이거나 PORT 명령에 지정된 포트일 수 있습니다. 서버는 지정된 사용자 데이터 포트를 사용하여 자신의 기본 데이터 포트\(L-1\)에서 데이터 연결을 시작해야 합니다. 전송 방향과 사용되는 포트는 FTP 서비스 명령에 의해 결정됩니다.

- 모든 FTP 구현은 기본 포트를 사용한 데이터 전송을 지원해야 하며 USER-PI만 기본이 아닌 포트의 사용을 시작할 수 있습니다.

- 두 서버 A와 B 사이에 데이터가 전송될 때\(그림 2 참조\), 사용자 PI인 C는 두 서버 PI와 제어 연결을 설정합니다. A라고 하는 서버 중 하나는 전송 서비스 명령을 받을 때 연결을 시작하는 대신 데이터 포트에서 "수신"하라는 PASV 명령을 보냅니다. user-PI가 수신 대기 중인 호스트 및 포트의 ID를 포함하는 PASV 명령에 대한 승인을 수신하면 user-PI는 PORT 명령을 통해 A의 포트 a를 B로 보냅니다. 답장이 반환됩니다. 그런 다음 사용자 PI는 해당 서비스 명령을 A와 B에 보낼 수 있습니다. 서버 B가 연결을 시작하고 전송이 진행됩니다. 명령-응답 시퀀스는 메시지가 수직적으로 동기적이지만 수평적으로 비동기식인 경우 아래에 나열되어 있습니다.

```text
         User-PI - Server A                User-PI - Server B
         ------------------                ------------------
         
         C->A : Connect                    C->B : Connect
         C->A : PASV
         A->C : 227 Entering Passive Mode. A1,A2,A3,A4,a1,a2
                                           C->B : PORT A1,A2,A3,A4,a1,a2
                                           B->C : 200 Okay
         C->A : STOR                       C->B : RETR
                    B->A : Connect to HOST-A, PORT-a

                                Figure 3
```

- 데이터 연결은 데이터 연결 설정 섹션에 설명된 조건에 따라 서버에 의해 종료되어야 합니다. 파일 끝을 표시하기 위해 연결을 닫을 필요가 없는 데이터 전송 후에 데이터 연결을 닫는 경우 서버는 즉시 이를 수행해야 합니다. 사용자 프로세스가 "수신"을 수행해야 하는지 확인하기 위해 이미 데이터 연결을 테스트했기 때문에 새로운 전송 명령이 나올 때까지 기다리는 것은 허용되지 않습니다. \(사용자는 전송 요청을 보내기 전에 닫힌 데이터 포트에서 "수신"해야 함을 기억하십시오\). 여기서 경쟁 조건을 방지하기 위해 서버는 데이터 연결을 닫은 후 응답\(226\)을 보냅니다\(또는 연결이 열려 있는 경우 "파일 전송 완료" 응답\(250\) 및 사용자 PI는 다음 중 하나를 기다려야 합니다\). 새로운 전송 명령을 내리기 전에 응답합니다\).

- 사용자나 서버는 상대방이 연결을 닫는 것을 확인할 때마다 즉시 연결에 대기 중인 나머지 데이터를 읽고 자신의 쪽에서 닫기를 실행해야 합니다.

```text
   5.3.  COMMANDS
```

- 명령은 FTP 명령 섹션에 설명된 대로 제어 연결을 통해 전송되는 텔넷 문자열입니다. 명령 기능과 의미는 액세스 제어 명령, 매개변수 전송 명령, FTP 서비스 명령 및 기타 명령 섹션에 설명되어 있습니다. 명령 구문은 여기에서 지정됩니다.

- 명령은 명령 코드로 시작하고 그 뒤에 인수 필드가 옵니다. 명령 코드는 4자 이하의 알파벳 문자입니다. 영문 대문자와 소문자는 동일하게 취급됩니다. 따라서 다음 중 하나가 검색 명령을 나타낼 수 있습니다.

```text
                  RETR    Retr    retr    ReTr    rETr
```

- 이는 A 또는 ASCII TYPE과 같은 매개변수 값을 나타내는 모든 기호에도 적용됩니다. 명령 코드와 인수 필드는 하나 이상의 공백으로 구분됩니다.

- 인수 필드는 NVT-ASCII 표현을 위한 문자 시퀀스 <CRLF\>\(캐리지 리턴, 라인 피드\)로 끝나는 가변 길이 문자열로 구성됩니다. 다른 협상된 언어의 경우 다른 줄 끝 문자가 사용될 수 있습니다. 서버는 줄 끝 코드가 수신될 때까지 아무런 조치도 취하지 않는다는 점에 유의해야 합니다.

- 구문은 NVT-ASCII에 아래에 지정되어 있습니다. 인수 필드의 모든 문자는 ASCII로 표현된 10진수 정수를 포함한 ASCII 문자입니다. 대괄호는 선택적 인수 필드를 나타냅니다. 옵션을 선택하지 않으면 적절한 기본값이 암시됩니다.

```text
      5.3.1.  FTP COMMANDS
```

- FTP 명령은 다음과 같습니다.

```text
            USER <SP> <username> <CRLF>
            PASS <SP> <password> <CRLF>
            ACCT <SP> <account-information> <CRLF>
            CWD  <SP> <pathname> <CRLF>
            CDUP <CRLF>
            SMNT <SP> <pathname> <CRLF>
            QUIT <CRLF>
            REIN <CRLF>
            PORT <SP> <host-port> <CRLF>
            PASV <CRLF>
            TYPE <SP> <type-code> <CRLF>
            STRU <SP> <structure-code> <CRLF>
            MODE <SP> <mode-code> <CRLF>
            RETR <SP> <pathname> <CRLF>
            STOR <SP> <pathname> <CRLF>
            STOU <CRLF>
            APPE <SP> <pathname> <CRLF>
            ALLO <SP> <decimal-integer>
                [<SP> R <SP> <decimal-integer>] <CRLF>
            REST <SP> <marker> <CRLF>
            RNFR <SP> <pathname> <CRLF>
            RNTO <SP> <pathname> <CRLF>
            ABOR <CRLF>
            DELE <SP> <pathname> <CRLF>
            RMD  <SP> <pathname> <CRLF>
            MKD  <SP> <pathname> <CRLF>
            PWD  <CRLF>
            LIST [<SP> <pathname>] <CRLF>
            NLST [<SP> <pathname>] <CRLF>
            SITE <SP> <string> <CRLF>
            SYST <CRLF>
            STAT [<SP> <pathname>] <CRLF>
            HELP [<SP> <string>] <CRLF>
            NOOP <CRLF>

      5.3.2.  FTP COMMAND ARGUMENTS
```

- 위 인수 필드의 구문\(해당되는 경우 BNF 표기법 사용\)은 다음과 같습니다.

<사용자 이름\> ::= <문자열\>

- <비밀번호\> ::= <문자열\> <계정정보\> ::= <문자열\> <문자열\> ::= <문자\> | <char\><string\> <char\> ::= <CR\> 및 <LF\>를 제외한 128개의 ASCII 문자 <marker\> ::= <pr-string\> <pr-string\> ::= <pr-char\> | <pr-char\><pr-string\> <pr-char\> ::= 인쇄 가능한 문자, ASCII 코드 33\~126 <byte-size\> ::= <number\> <host-port\> ::= <host-number \>,<포트 번호\> <호스트 번호\> ::= <번호\>,<번호\>,<번호\>,<번호\> <포트 번호\> ::= <번호\>,<번호\> <번호\> :: = 1부터 255까지의 모든 십진 정수 <form-code\> ::= N | 티 | C <유형 코드\> ::= A \[<sp\> <형식 코드\>\] | E \[<sp\> <양식 코드\>\] | 나는 | L <sp\> <바이트 크기\> <구조 코드\> ::= F | R | P <모드 코드\> ::= S | 비 | C <pathname\> ::= <string\> <decimal-integer\> ::= 임의의 10진수

5.4. 명령과 응답의 순서

- 사용자와 서버 간의 통신은 교대 대화를 지향합니다. 따라서 사용자는 FTP 명령을 실행하고 서버는 프롬프트 기본 응답으로 응답합니다. 사용자는 추가 명령을 보내기 전에 초기 기본 성공 또는 실패 응답을 기다려야 합니다.

- 특정 명령에는 사용자가 기다려야 하는 두 번째 응답이 필요합니다. 예를 들어, 이러한 응답은 파일 전송의 진행이나 완료 또는 데이터 연결 종료에 대해 보고할 수 있습니다. 이는 파일 전송 명령에 대한 보조 응답입니다.

- 정보 답변의 중요한 그룹 중 하나는 연결 인사말입니다. 정상적인 상황에서 서버는 연결이 완료되면 "입력 대기 중"이라는 220 응답을 보냅니다. 사용자는 명령을 보내기 전에 이 인사말 메시지를 기다려야 합니다. 서버가 입력을 즉시 수락할 수 없는 경우 120 "예상 지연" 응답을 즉시 전송해야 하며 준비되면 220 응답을 전송해야 합니다. 그러면 사용자는 지연이 발생하더라도 전화를 끊지 말아야 한다는 것을 알게 됩니다.

```text
      Spontaneous Replies
```

- 때때로 "시스템"에는 사용자\(보통 모든 사용자\)에게 메시지를 보내야 하는 경우가 있습니다. 예를 들어 "시스템이 15분 후에 다운됩니다"입니다. FTP에는 이러한 자발적인 정보가 서버에서 사용자에게 전송되는 규정이 없습니다. 이러한 정보는 서버 PI의 큐에 저장되고 다음 응답에서 사용자 PI로 전달되는 것이 좋습니다\(여러 줄 응답으로 만들 수도 있음\).

- 아래 표에는 각 명령에 대한 대체 성공 및 실패 응답이 나열되어 있습니다. 이는 엄격하게 준수되어야 합니다. 서버는 응답의 텍스트를 대체할 수 있지만 코드 번호와 특정 명령 응답 순서에 의해 암시되는 의미와 동작은 변경할 수 없습니다.

```text
      Command-Reply Sequences
```

- 이 섹션에서는 명령-응답 순서가 제시됩니다. 각 명령은 가능한 응답과 함께 나열됩니다. 명령 그룹은 함께 나열됩니다. 예비 답변이 먼저 나열되고\(다음 답변은 들여쓰기되고 그 아래에 표시됨\) 긍정적인 완료와 부정적인 완료, 마지막으로 중간 응답이 나열됩니다.

시퀀스의 나머지 명령으로 응답합니다.

- 다음. 이 목록은 별도로 제시될 상태 다이어그램의 기초를 형성합니다.

```text
            Connection Establishment
               120
                  220
               220
               421
            Login
               USER
                  230
                  530
                  500, 501, 421
                  331, 332
               PASS
                  230
                  202
                  530
                  500, 501, 503, 421
                  332
               ACCT
                  230
                  202
                  530
                  500, 501, 503, 421
               CWD
                  250
                  500, 501, 502, 421, 530, 550
               CDUP
                  200
                  500, 501, 502, 421, 530, 550
               SMNT
                  202, 250
                  500, 501, 502, 421, 530, 550
            Logout
               REIN
                  120
                     220
                  220
                  421
                  500, 502
               QUIT
                  221
                  500

            Transfer parameters
               PORT
                  200
                  500, 501, 421, 530
               PASV
                  227
                  500, 501, 502, 421, 530
               MODE
                  200
                  500, 501, 504, 421, 530
               TYPE
                  200
                  500, 501, 504, 421, 530
               STRU
                  200
                  500, 501, 504, 421, 530
            File action commands
               ALLO
                  200
                  202
                  500, 501, 504, 421, 530
               REST
                  500, 501, 502, 421, 530
                  350
               STOR
                  125, 150
                     (110)
                     226, 250
                     425, 426, 451, 551, 552
                  532, 450, 452, 553
                  500, 501, 421, 530
               STOU
                  125, 150
                     (110)
                     226, 250
                     425, 426, 451, 551, 552
                  532, 450, 452, 553
                  500, 501, 421, 530
               RETR
                  125, 150
                     (110)
                     226, 250
                     425, 426, 451
                  450, 550
                  500, 501, 421, 530

               LIST
                  125, 150
                     226, 250
                     425, 426, 451
                  450
                  500, 501, 502, 421, 530
               NLST
                  125, 150
                     226, 250
                     425, 426, 451
                  450
                  500, 501, 502, 421, 530
               APPE
                  125, 150
                     (110)
                     226, 250
                     425, 426, 451, 551, 552
                  532, 450, 550, 452, 553
                  500, 501, 502, 421, 530
               RNFR
                  450, 550
                  500, 501, 502, 421, 530
                  350
               RNTO
                  250
                  532, 553
                  500, 501, 502, 503, 421, 530
               DELE
                  250
                  450, 550
                  500, 501, 502, 421, 530
               RMD
                  250
                  500, 501, 502, 421, 530, 550
               MKD
                  257
                  500, 501, 502, 421, 530, 550
               PWD
                  257
                  500, 501, 502, 421, 550
               ABOR
                  225, 226
                  500, 501, 502, 421

            Informational commands
               SYST
                  215
                  500, 501, 502, 421
               STAT
                  211, 212, 213
                  450
                  500, 501, 502, 421, 530
               HELP
                  211, 214
                  500, 501, 502, 421
            Miscellaneous commands
               SITE
                  200
                  202
                  500, 501, 530
               NOOP
                  200
                  500 421
```

---
## **6.  STATE DIAGRAMS**

여기서는 매우 간단한 FTP 구현에 대한 상태 다이어그램을 제시합니다. 응답 코드의 첫 번째 숫자만 사용됩니다. FTP 명령 또는 명령 시퀀스의 각 그룹에 대해 하나의 상태 다이어그램이 있습니다.

명령 그룹화는 각 명령에 대한 모델을 구성한 다음 구조적으로 동일한 모델로 명령을 수집하여 결정되었습니다.

각 명령 또는 명령 시퀀스에는 성공\(S\), 실패\(F\), 오류\(E\)의 세 가지 가능한 결과가 있습니다. 아래 상태 다이어그램에서는 "시작"을 나타내는 기호 B를 사용하고 "응답 대기"를 나타내는 기호 W를 사용합니다.

먼저 가장 큰 FTP 명령 그룹을 나타내는 다이어그램을 제시합니다.

```text
      
                               1,3    +---+
                          ----------->| E |
                         |            +---+
                         |
      +---+    cmd    +---+    2      +---+
      | B |---------->| W |---------->| S |
      +---+           +---+           +---+
                         |
                         |     4,5    +---+
                          ----------->| F |
                                      +---+
      
```

- 이 다이어그램은 다음 명령을 모델링합니다.

- ABOR, ALLO, DELE, CWD, CDUP, SMNT, HELP, MODE, NOOP, PASV, QUIT, SITE, PORT, SYST, STAT, RMD, MKD, PWD, STRU 및 TYPE.

다른 큰 명령 그룹은 매우 유사한 다이어그램으로 표시됩니다.

```text
      
                               3      +---+
                          ----------->| E |
                         |            +---+
                         |
      +---+    cmd    +---+    2      +---+
      | B |---------->| W |---------->| S |
      +---+       --->+---+           +---+
                 |     | |
                 |     | |     4,5    +---+
                 |  1  |  ----------->| F |
                  -----               +---+
      
```

- 이 다이어그램은 다음 명령을 모델링합니다.

- APPE, LIST, NLST, REIN, RETR, STOR 및 STOU.

이 두 번째 모델은 명령의 첫 번째 그룹을 나타내는 데 사용될 수도 있습니다. 유일한 차이점은 첫 번째 그룹의 100 시리즈 응답은 예상치 못한 것이므로 오류로 처리되는 반면 두 번째 그룹은 100 시리즈를 기대합니다\(일부는 필요할 수 있음\). 답글. 명령당 최대 1개의 100 시리즈 응답이 허용된다는 점을 기억하세요.

나머지 다이어그램 모델 명령 시퀀스는 아마도 가장 간단한 이름 바꾸기 시퀀스일 것입니다.

```text
      
      +---+   RNFR    +---+    1,2    +---+
      | B |---------->| W |---------->| E |
      +---+           +---+        -->+---+
                       | |        |
                3      | | 4,5    |
         --------------  ------   |
        |                      |  |   +---+
        |               ------------->| S |
        |              |   1,3 |  |   +---+
        |             2|  --------
        |              | |     |
        V              | |     |
      +---+   RNTO    +---+ 4,5 ----->+---+
      |   |---------->| W |---------->| F |
      +---+           +---+           +---+
      
```

다음 다이어그램은 Restart 명령의 간단한 모델입니다.

```text
      
      +---+   REST    +---+    1,2    +---+
      | B |---------->| W |---------->| E |
      +---+           +---+        -->+---+
                       | |        |
                3      | | 4,5    |
         --------------  ------   |
        |                      |  |   +---+
        |               ------------->| S |
        |              |   3   |  |   +---+
        |             2|  --------
        |              | |     |
        V              | |     |
      +---+   cmd     +---+ 4,5 ----->+---+
      |   |---------->| W |---------->| F |
      +---+        -->+---+           +---+
                  |      |
                  |  1   |
                   ------
      
```

- "cmd"는 APPE, STOR 또는 RETR입니다.

위의 세 가지 모델은 유사합니다. Restart는 두 번째 단계에서 100개의 시리즈 응답을 처리한다는 점에서만 Rename 2와 다르며, 두 번째 그룹은 100개의 시리즈 응답을 기대합니다\(일부는 필요할 수 있음\). 명령당 최대 1개의 100 시리즈 응답이 허용된다는 점을 기억하세요.

가장 복잡한 다이어그램은 로그인 시퀀스에 대한 것입니다.

```text
      
                            1
      +---+   USER    +---+------------->+---+
      | B |---------->| W | 2       ---->| E |
      +---+           +---+------  |  -->+---+
                       | |       | | |
                     3 | | 4,5   | | |
         --------------   -----  | | |
        |                      | | | |
        |                      | | | |
        |                 ---------  |
        |               1|     | |   |
        V                |     | |   |
      +---+   PASS    +---+ 2  |  ------>+---+
      |   |---------->| W |------------->| S |
      +---+           +---+   ---------->+---+
                       | |   | |     |
                     3 | |4,5| |     |
         --------------   --------   |
        |                    | |  |  |
        |                    | |  |  |
        |                 -----------
        |             1,3|   | |  |
        V                |  2| |  |
      +---+   ACCT    +---+--  |   ----->+---+
      |   |---------->| W | 4,5 -------->| F |
      +---+           +---+------------->+---+
```

마지막으로 명령 및 응답 교환을 모델링하는 데 사용할 수 있는 일반화된 다이어그램을 제시합니다.

```text
      
               ------------------------------------
              |                                    |
      Begin   |                                    |
        |     V                                    |
        |   +---+  cmd   +---+ 2         +---+     |
         -->|   |------->|   |---------->|   |     |
            |   |        | W |           | S |-----|
         -->|   |     -->|   |-----      |   |     |
        |   +---+    |   +---+ 4,5 |     +---+     |
        |     |      |    | |      |               |
        |     |      |   1| |3     |     +---+     |
        |     |      |    | |      |     |   |     |
        |     |       ----  |       ---->| F |-----
        |     |             |            |   |
        |     |             |            +---+
         -------------------
              |
              |
              V
             End
      
```

---
## **7.  TYPICAL FTP SCENARIO**

호스트 S와 파일을 전송하려는 호스트 U의 사용자:

```text
   In general, the user will communicate to the server via a mediating
   user-FTP process.  The following may be a typical scenario.  The
   user-FTP prompts are shown in parentheses, '---->' represents
   commands from host U to host S, and '<----' represents replies from
   host S to host U.

      LOCAL COMMANDS BY USER              ACTION INVOLVED

      ftp (host) multics<CR>         Connect to host S, port L,
                                     establishing control connections.
                                     <---- 220 Service ready <CRLF>.
      username Doe <CR>              USER Doe<CRLF>---->
                                     <---- 331 User name ok,
                                               need password<CRLF>.
      password mumble <CR>           PASS mumble<CRLF>---->
                                     <---- 230 User logged in<CRLF>.
      retrieve (local type) ASCII<CR>
      (local pathname) test 1 <CR>   User-FTP opens local file in ASCII.
      (for. pathname) test.pl1<CR>   RETR test.pl1<CRLF> ---->
                                     <---- 150 File status okay;
                                           about to open data
                                           connection<CRLF>.
                                     Server makes data connection
                                     to port U.
      
                                     <---- 226 Closing data connection,
                                         file transfer successful<CRLF>.
      type Image<CR>                 TYPE I<CRLF> ---->
                                     <---- 200 Command OK<CRLF>
      store (local type) image<CR>
      (local pathname) file dump<CR> User-FTP opens local file in Image.
      (for.pathname) >udd>cn>fd<CR>  STOR >udd>cn>fd<CRLF> ---->
                                     <---- 550 Access denied<CRLF>
      terminate                      QUIT <CRLF> ---->
                                     Server closes all
                                     connections.
```

---
## **8.  CONNECTION ESTABLISHMENT**

FTP 제어 연결은 사용자 프로세스 포트 U와 서버 프로세스 포트 L 사이에 TCP를 통해 설정됩니다. 이 프로토콜에는 서비스 포트 21\(25 8진수\), 즉 L=21이 할당됩니다.

---
# **APPENDIX I -  PAGE STRUCTURE**

페이지 구조를 지원하기 위한 FTP의 필요성은 주로 TOPS-20 시스템 간의 파일, 특히 NLS에서 사용되는 파일의 효율적인 전송을 지원해야 하는 필요성에서 비롯됩니다.

TOPS-20의 파일 시스템은 페이지 개념을 기반으로 합니다. 운영 체제는 파일을 페이지로 조작하는 데 가장 효율적입니다. 운영 체제는 많은 응용 프로그램이 파일을 순차적인 문자 스트림으로 볼 수 있도록 파일 시스템에 대한 인터페이스를 제공합니다. 그러나 일부 응용 프로그램은 기본 페이지 구조를 직접 사용하며 이들 중 일부는 홀리 파일을 생성합니다.

TOPS-20 디스크 파일은 경로 이름, 페이지 테이블, \(비어 있을 수도 있는\) 페이지 집합, 속성 집합의 네 가지 항목으로 구성됩니다.

경로 이름은 RETR 또는 STOR 명령에 지정됩니다. 여기에는 디렉터리 이름, 파일 이름, 파일 이름 확장자 및 세대 번호가 포함됩니다.

페이지 테이블에는 최대 2\*\*18개의 항목이 포함됩니다. 각 항목은 비어 있거나 페이지를 가리킬 수 있습니다. 비어 있지 않으면 일부 페이지별 액세스 비트도 있습니다. 파일의 모든 페이지에 동일한 액세스 보호가 필요한 것은 아닙니다.

- 페이지는 각각 36비트로 구성된 512개 단어의 연속된 집합입니다.

FDB\(파일 설명자 블록\)의 파일 속성에는 생성 시간, 쓰기 시간, 읽기 시간, 작성자의 바이트 크기, 파일 끝 포인터, 읽기 및 쓰기 횟수, 백업 시스템 테이프 번호 등이 포함됩니다. , 등.

페이지 테이블의 항목이 연속적이어야 한다는 요구 사항은 없습니다. 점유된 페이지 테이블 슬롯 사이에 빈 페이지 테이블 슬롯이 있을 수 있습니다. 또한 파일 포인터의 끝은 단순히 숫자입니다. 실제로 파일의 "마지막" 데이터를 가리킬 필요는 없습니다. TOPS-20의 일반적인 순차적 I/O 호출로 인해 파일 포인터의 끝이 기록된 마지막 데이터 뒤에 남게 되지만, 특정 프로그래밍 시스템에서 요구하는 경우 다른 작업으로 인해 그렇지 않을 수도 있습니다.

실제로 이러한 특별한 경우 모두 NLS 데이터 파일에서 "홀리" 파일과 파일 끝이 아닌 파일 끝 포인터가 발생합니다.

TOPS-20 페이징 파일은 FTP 전송 매개변수인 TYPE L 36, STRU P 및 MODE S\(실제로 모든 모드를 사용할 수 있음\)를 사용하여 전송할 수 있습니다.

각 정보 페이지에는 헤더가 있습니다. 논리적 바이트인 각 헤더 필드는 TYPE이 L 36이므로 TOPS-20 워드입니다.

헤더 필드는 다음과 같습니다.

```text
      Word 0: Header Length.
```

- 헤더 길이는 5이다.

```text
      Word 1: Page Index.
```

- 데이터가 디스크 파일 페이지인 경우 파일의 페이지 맵에 있는 해당 페이지의 번호입니다. 파일의 빈 페이지\(구멍\)는 전송되지 않습니다. 구멍은 0으로 된 페이지와 동일하지 않습니다.

```text
      Word 2: Data Length.
```

- 헤더 다음에 나오는 이 페이지의 데이터 단어 수입니다. 따라서 전송 단위의 전체 길이는 헤더 길이에 데이터 길이를 더한 값입니다.

```text
      Word 3: Page Type.
```

- 이것이 어떤 유형의 청크인지에 대한 코드입니다. 데이터 페이지는 유형 3이고 FDB 페이지는 유형 2입니다.

```text
      Word 4: Page Access Control.
```

- 파일의 페이지 맵에 있는 페이지와 연결된 액세스 비트입니다. \(이 전체 단어 수량은 넷에서 디스크로 읽는 프로그램에 의해 SPACS의 AC2에 저장됩니다.\)

헤더 다음에는 데이터 길이 데이터 단어가 있습니다. 데이터 길이는 현재 데이터 페이지의 경우 512이고 FDB의 경우 31입니다. 디스크 파일 페이지의 후행 0은 삭제될 수 있으며, 이 경우 데이터 길이는 512보다 작아집니다.

---
# **APPENDIX II -  DIRECTORY COMMANDS**

UNIX는 디렉토리가 일반 파일만큼 쉽게 조작할 수 있는 트리형 디렉토리 구조를 갖고 있기 때문에 디렉토리 생성을 처리하는 명령을 포함하도록 이러한 시스템의 FTP 서버를 확장하는 것이 유용합니다. ARPA-인터넷에는 트리형 디렉토리\(TOPS-20 및 Multics 포함\)를 가진 다른 호스트가 있으므로 이러한 명령은 가능한 한 일반적입니다.

- FTP에 4개의 디렉터리 명령이 추가되었습니다.

```text
         MKD pathname
```

- "pathname"이라는 이름으로 디렉터리를 만듭니다.

```text
         RMD pathname
```

- "pathname"이라는 이름의 디렉터리를 제거합니다.

```text
         PWD
```

- 현재 작업 디렉토리 이름을 인쇄합니다.

```text
         CDUP
```

- 현재 작업 디렉토리의 상위 디렉토리로 변경합니다.

"pathname" 인수는 "pathname" 문자열에 서버에 달리 지정할 수 있는 충분한 정보가 포함되어 있지 않는 한 현재 작업 디렉터리의 하위 디렉터리로 생성\(제거\)되어야 합니다. 예를 들어 "pathname"은 절대 경로 이름입니다\(UNIX 및 Multics에서\). \) 또는 경로 이름은 TOPS-20에 대한 "<abso.lute.path\>"와 같습니다.

```text
   REPLY CODES
```

- CDUP 명령은 CWD의 특별한 경우이며 상위 디렉터리 이름을 지정하기 위한 서로 다른 구문을 사용하는 운영 체제 간에 디렉터리 트리를 전송하는 프로그램 구현을 단순화하기 위해 포함되었습니다. CDUP의 응답 코드는 CWD의 응답 코드와 동일합니다.

- RMD의 응답 코드는 파일 아날로그 DELE의 응답 코드와 동일합니다.

- 그러나 MKD의 응답 코드는 좀 더 복잡합니다. 새로 생성된 디렉토리는 아마도 미래의 대상이 될 것입니다.

- CWD 명령. 불행하게도 MKD에 대한 주장이 항상 CWD에 대한 적절한 주장이 아닐 수도 있습니다. 예를 들어 TOPS-20 하위 디렉터리가 하위 디렉터리 이름만 제공하여 생성된 경우가 이에 해당합니다. 즉, TOPS-20 서버 FTP의 경우 명령 순서는 다음과 같습니다.

```text
         MKD MYDIR
         CWD MYDIR

      will fail.  The new directory may only be referred to by its
      "absolute" name; e.g., if the MKD command above were issued while
      connected to the directory <DFRANKLIN>, the new subdirectory
      could only be referred to by the name <DFRANKLIN.MYDIR>.
```

- 그러나 UNIX 및 Multics에서도 MKD에 제공된 인수가 적합하지 않을 수 있습니다. "상대" 경로 이름\(즉, 현재 디렉터리를 기준으로 해석되는 경로 이름\)인 경우 사용자는 하위 디렉터리에 도달하기 위해 동일한 현재 디렉터리에 있어야 합니다. 응용 프로그램에 따라 불편할 수도 있습니다. 어떤 경우에도 그다지 강력하지 않습니다.

- 이러한 문제를 해결하려면 MKD 명령이 성공적으로 완료되면 서버가 다음 형식의 줄을 반환해야 합니다.

```text
         257<space>"<directory-name>"<space><commentary>
```

- 즉, 서버는 생성된 디렉터리를 참조할 때 사용할 문자열을 사용자에게 알려줍니다. 디렉터리 이름에는 모든 문자가 포함될 수 있습니다. 포함된 큰따옴표는 큰따옴표로 이스케이프해야 합니다\("따옴표 이중화" 규칙\).

- 예를 들어, 사용자가 /usr/dm 디렉토리에 연결하고 pathname이라는 하위 디렉토리를 생성합니다.

CWD /usr/dm

- 200 디렉토리가 /usr/dm으로 변경되었습니다. MKD 경로 이름 257 "/usr/dm/pathname" 디렉토리가 생성되었습니다.

- 큰따옴표가 포함된 예:

MKD foo"바

- 257 "/usr/dm/foo""bar" 디렉토리가 생성됨 CWD /usr/dm/foo"bar 200 디렉토리가 /usr/dm/foo"bar로 변경됨

- 동일한 이름을 가진 하위 디렉터리가 이전에 존재하는 것은 오류이며, 이 경우 서버는 "액세스 거부" 오류 응답을 반환해야 합니다.

CWD /usr/dm

- 200 디렉토리가 /usr/dm으로 변경되었습니다. MKD 경로 이름 521-"/usr/dm/pathname" 디렉토리가 이미 존재합니다. 521 아무런 조치도 취하지 않고 있습니다.

- MKD의 실패 응답은 파일 생성 사촌인 STOR와 유사합니다. 또한 하위 디렉터리와 동일한 이름을 가진 파일 이름이 하위 디렉터리 생성과 충돌하는 경우 "액세스 거부" 반환이 제공됩니다\(이것은 UNIX에서는 문제이지만 TOPS-20에서는 문제가 되어서는 안 됩니다\).

- 본질적으로 PWD 명령은 성공적인 MKD 명령과 동일한 유형의 정보를 반환하기 때문에 성공적인 PWD 명령도 257 응답 코드를 사용합니다.

```text
   SUBTLETIES
```

- 이러한 명령은 한 시스템에서 다른 시스템으로 하위 트리를 전송하는 데 가장 유용하기 때문에 MKD에 대한 인수가 대상 호스트가 알 수 있는 충분한 정보가 포함되어 있지 않는 한 현재 작업 디렉토리의 하위 디렉토리로 해석된다는 점을 주의 깊게 관찰하십시오. 그렇지 않으면. TOPS-20 세계에서 이를 사용하는 가상의 예:

```text
         CWD <some.where>
         200 Working directory changed
         MKD overrainbow
         257 "<some.where.overrainbow>" directory created
         CWD overrainbow
         431 No such directory
         CWD <some.where.overrainbow>
         200 Working directory changed
```

CWD <어떤 곳\>

- 200 작업 디렉토리가 <some.where\> MKD <unambiguous\>로 변경되었습니다. 257 "<unambiguous\>" 디렉토리가 CWD <unambiguous\> 생성되었습니다.

- 첫 번째 예에서는 연결된 디렉터리의 하위 디렉터리가 생성됩니다. 대조적으로, 두 번째 예의 인수에는 TOPS-20에 대한 충분한 정보가 포함되어 있습니다.

- <명확한\> 디렉터리는 최상위 디렉터리입니다. 또한 첫 번째 예에서 사용자는 TOPS-20에서 반환된 이름이 아닌 다른 이름으로 새로 생성된 디렉터리에 액세스하려고 시도하여 프로토콜을 "위반"했습니다. <overrainbow\> 디렉터리가 있었다면 이 경우에 문제가 발생할 수 있었습니다. 이는 일부 TOPS-20 구현에 내재된 모호함입니다. RMD 명령에도 비슷한 고려 사항이 적용됩니다. 요점은 이것이다: 상대 경로와 절대 경로 이름을 표시하는 호스트의 규칙을 위반하는 경우를 제외하고 호스트는 MKD 및 RMD 명령의 피연산자를 하위 디렉터리로 처리해야 한다는 것입니다. MKD 명령에 대한 257 응답에는 항상 생성된 디렉터리의 절대 경로 이름이 포함되어야 합니다.

---
# **APPENDIX III - RFCs on FTP**

```text
   Bhushan, Abhay, "A File Transfer Protocol", RFC 114 (NIC 5823),
   MIT-Project MAC, 16 April 1971.
```

Harslem, Eric 및 John Heafner, "RFC 114\(파일 전송 프로토콜\)에 대한 의견", RFC 141\(NIC 6726\), RAND, 1971년 4월 29일.

```text
   Bhushan, Abhay, et al, "The File Transfer Protocol", RFC 172
   (NIC 6794), MIT-Project MAC, 23 June 1971.
```

Braden, Bob, "DTP 및 FTP 제안에 대한 의견", RFC 238\(NIC 7663\), UCLA/CCN, 1971년 9월 29일.

```text
   Bhushan, Abhay, et al, "The File Transfer Protocol", RFC 265
   (NIC 7813), MIT-Project MAC, 17 November 1971.
```

McKenzie, Alex, "파일 전송 프로토콜에 대한 제안된 추가", RFC 281\(NIC 8163\), BBN, 1971년 12월 8일.

Bhushan, Abhay, "파일 전송 프로토콜에서 "데이터 유형 설정" 트랜잭션의 사용", RFC 294\(NIC 8304\), MIT-Project MAC, 1972년 1월 25일.

```text
   Bhushan, Abhay, "The File Transfer Protocol", RFC 354 (NIC 10596),
   MIT-Project MAC, 8 July 1972.
```

Bhushan, Abhay, "파일 전송 프로토콜\(RFC 354\)에 대한 의견", RFC 385\(NIC 11357\), MIT-Project MAC, 1972년 8월 18일.

```text
   Hicks, Greg, "User FTP Documentation", RFC 412 (NIC 12404), Utah,
   27 November 1972.
```

Bhushan, Abhay, "FTP\(파일 전송 프로토콜\) 상태 및 추가 설명", RFC 414\(NIC 12406\), MIT-Project MAC, 1972년 11월 20일.

Braden, Bob, "파일 전송 프로토콜에 대한 의견", RFC 430\(NIC 13299\), UCLA/CCN, 1973년 2월 7일.

Thomas, Bob, Bob Clements, "FTP 서버 간 상호 작용", RFC 438\(NIC 13770\), BBN, 1973년 1월 15일.

Braden, Bob, "FTP의 파일 인쇄", RFC 448\(NIC 13299\), UCLA/CCN, 1973년 2월 27일.

```text
   McKenzie, Alex, "File Transfer Protocol", RFC 454 (NIC 14333), BBN,
   16 February 1973.
```

Bressler, Bob 및 Bob Thomas, "FTP를 통한 메일 검색", RFC 458\(NIC 14378\), BBN-NET 및 BBN-TENEX, 1973년 2월 20일.

```text
   Neigus, Nancy, "File Transfer Protocol", RFC 542 (NIC 17759), BBN,
   12 July 1973.
```

Krilanovich, Mark 및 George Gregg, "파일 전송 프로토콜에 대한 의견", RFC 607\(NIC 21255\), UCSB, 1974년 1월 7일.

Pogran, Ken 및 Nancy Neigus, "RFC 607에 대한 응답 - 파일 전송 프로토콜에 대한 설명", RFC 614\(NIC 21530\), BBN, 1974년 1월 28일.

Krilanovich, Mark, George Gregg, Wayne Hathaway 및 Jim White, "파일 전송 프로토콜에 대한 의견", RFC 624\(NIC 22054\), UCSB, Ames Research Center, SRI-ARC, 1974년 2월 28일.

Bhushan, Abhay, "RFC 430에 대한 FTP 의견 및 응답", RFC 463\(NIC 14573\), MIT-DMCG, 1973년 2월 21일.

```text
   Braden, Bob, "FTP Data Compression", RFC 468 (NIC 14742), UCLA/CCN,
   8 March 1973.
```

Bhushan, Abhay, "FTP 및 네트워크 메일 시스템", RFC 475\(NIC 14919\), MIT-DMCG, 1973년 3월 6일.

Bressler, Bob, Bob Thomas "FTP 서버-서버 상호 작용 - II", RFC 478\(NIC 14947\), BBN-NET 및 BBN-TENEX, 1973년 3월 26일.

White, Jim, "NIC Journal의 FTP 사용", RFC 479\(NIC 14948\), SRI-ARC, 1973년 3월 8일.

```text
   White, Jim, "Host-Dependent FTP Parameters", RFC 480 (NIC 14949),
   SRI-ARC, 8 March 1973.

   Padlipsky, Mike, "An FTP Command-Naming Problem", RFC 506
   (NIC 16157), MIT-Multics, 26 June 1973.
```

Day, John, "FTP 그룹에 대한 메모\(파일 액세스 프로토콜 제안\)", RFC 520\(NIC 16819\), 일리노이, 1973년 6월 25일.

```text
   Merryman, Robert, "The UCSD-CC Server-FTP Facility", RFC 532
   (NIC 17451), UCSD-CC, 22 June 1973.

   Braden, Bob, "TENEX FTP Problem", RFC 571 (NIC 18974), UCLA/CCN,
   15 November 1973.
```

McKenzie, Alex 및 Jon Postel, "Telnet 및 FTP 구현 - 일정 변경", RFC 593\(NIC 20615\), BBN 및 MITRE, 1973년 11월 29일.

Sussman, Julie, "더 안정적인 메일 서비스를 위한 FTP 오류 코드 사용", RFC 630\(NIC 30237\), BBN, 1974년 4월 10일.

```text
   Postel, Jon, "Revised FTP Reply Codes", RFC 640 (NIC 30843),
   UCLA/NMC, 5 June 1974.

   Harvey, Brian, "Leaving Well Enough Alone", RFC 686 (NIC 32481),
   SU-AI, 10 May 1975.
```

Harvey, Brian, "FTP에서 한 번 더 시도", RFC 691\(NIC 32700\), SU-AI, 1975년 5월 28일.

Lieb, J., "FTP의 CWD 명령", RFC 697\(NIC 32963\), 1975년 7월 14일.

```text
   Harrenstien, Ken, "FTP Extension: XSEN", RFC 737 (NIC 42217), SRI-KL,
   31 October 1977.

   Harrenstien, Ken, "FTP Extension: XRSQ/XRCP", RFC 743 (NIC 42758),
   SRI-KL, 30 December 1977.
```

Lebling, P. David, "FTP 메일 및 MLFL 조사", RFC 751, MIT, 1978년 12월 10일.

```text
   Postel, Jon, "File Transfer Protocol Specification", RFC 765, ISI,
   June 1980.
```

Mankins, David, Dan Franklin 및 Buzz Owen, "디렉토리 지향 FTP 명령", RFC 776, BBN, 1980년 12월.

```text
   Padlipsky, Michael, "FTP Unique-Named Store Command", RFC 949, MITRE,
   July 1985.
```

---
# **REFERENCES**

```text
   [1]  Feinler, Elizabeth, "Internet Protocol Transition Workbook",
        Network Information Center, SRI International, March 1982.

   [2]  Postel, Jon, "Transmission Control Protocol - DARPA Internet
        Program Protocol Specification", RFC 793, DARPA, September 1981.
```

\[3\] Postel, Jon, Joyce Reynolds, "Telnet 프로토콜

- 사양", RFC 854, ISI, 1983년 5월.

\[4\] Reynolds, Joyce 및 Jon Postel, "할당된 번호", RFC 943, ISI, 1985년 4월.
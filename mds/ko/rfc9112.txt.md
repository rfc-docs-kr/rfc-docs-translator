

```text
﻿

Internet Engineering Task Force (IETF)                  R. Fielding, Ed.
Request for Comments: 9112                                         Adobe
STD: 99                                               M. Nottingham, Ed.
Obsoletes: 7230                                                   Fastly
Category: Standards Track                                J. Reschke, Ed.
ISSN: 2070-1721                                               greenbytes
                                                               June 2022

                                HTTP/1.1
```

---
# **Abstract**

HTTP\(Hypertext Transfer Protocol\)는 분산, 협업, 하이퍼텍스트 정보 시스템을 위한 상태 비저장 애플리케이션 수준 프로토콜입니다. 이 문서에서는 HTTP/1.1 메시지 구문, 메시지 구문 분석, 연결 관리 및 관련 보안 문제를 지정합니다.

이 문서는 RFC 7230의 일부를 폐기합니다.

---
# **Status of This Memo**

이것은 인터넷 표준 추적 문서입니다.

이 문서는 IETF\(Internet Engineering Task Force\)의 제품입니다. 이는 IETF 커뮤니티의 합의를 나타냅니다. 공개 검토를 받았으며 IESG\(Internet Engineering Steering Group\)의 출판 승인을 받았습니다. 인터넷 표준에 대한 자세한 내용은 RFC 7841의 섹션 2에서 확인할 수 있습니다.

이 문서의 현재 상태, 정오표, 피드백 제공 방법에 대한 정보는 https://www.rfc-editor.org/info/rfc9112에서 확인할 수 있습니다.

---
# **Copyright Notice**

Copyright \(c\) 2022 IETF Trust 및 문서 작성자로 확인된 사람. 판권 소유.

이 문서는 이 문서의 발행일에 유효한 BCP 78 및 IETF 문서에 관한 IETF 트러스트의 법적 조항\(https://trustee.ietf.org/license-info\)의 적용을 받습니다. 이 문서와 관련된 귀하의 권리 및 제한 사항을 설명하므로 이 문서를 주의 깊게 검토하십시오. 이 문서에서 추출한 코드 구성요소는 Trust Legal Provisions의 섹션 4.e에 설명된 대로 개정된 BSD 라이센스 텍스트를 포함해야 하며 개정된 BSD 라이센스에 설명된 대로 보증 없이 제공됩니다.

이 문서에는 2008년 11월 10일 이전에 공개되거나 공개된 IETF 문서 또는 IETF 기고문의 자료가 포함될 수 있습니다. 이 자료의 일부에 대한 저작권을 제어하는 ​​사람은 해당 자료의 수정을 허용할 권리를 IETF 트러스트에 부여하지 않았을 수 있습니다. IETF 표준 프로세스 외부. 이러한 자료의 저작권을 관리하는 사람으로부터 적절한 라이센스를 얻지 않고 이 문서는 IETF 표준 프로세스 외부에서 수정할 수 없으며 IETF 표준 프로세스 외부에서 이 문서의 파생물을 생성할 수 없습니다. RFC로 게시하거나 영어 이외의 언어로 번역합니다.

---
# **Table of Contents**

```text
   1.  Introduction
     1.1.  Requirements Notation
     1.2.  Syntax Notation
   2.  Message
     2.1.  Message Format
     2.2.  Message Parsing
     2.3.  HTTP Version
   3.  Request Line
     3.1.  Method
     3.2.  Request Target
       3.2.1.  origin-form
       3.2.2.  absolute-form
       3.2.3.  authority-form
       3.2.4.  asterisk-form
     3.3.  Reconstructing the Target URI
   4.  Status Line
   5.  Field Syntax
     5.1.  Field Line Parsing
     5.2.  Obsolete Line Folding
   6.  Message Body
     6.1.  Transfer-Encoding
     6.2.  Content-Length
     6.3.  Message Body Length
   7.  Transfer Codings
     7.1.  Chunked Transfer Coding
       7.1.1.  Chunk Extensions
       7.1.2.  Chunked Trailer Section
       7.1.3.  Decoding Chunked
     7.2.  Transfer Codings for Compression
     7.3.  Transfer Coding Registry
     7.4.  Negotiating Transfer Codings
   8.  Handling Incomplete Messages
   9.  Connection Management
     9.1.  Establishment
     9.2.  Associating a Response to a Request
     9.3.  Persistence
       9.3.1.  Retrying Requests
       9.3.2.  Pipelining
     9.4.  Concurrency
     9.5.  Failures and Timeouts
     9.6.  Tear-down
     9.7.  TLS Connection Initiation
     9.8.  TLS Connection Closure
   10. Enclosing Messages as Data
     10.1.  Media Type message/http
     10.2.  Media Type application/http
   11. Security Considerations
     11.1.  Response Splitting
     11.2.  Request Smuggling
     11.3.  Message Integrity
     11.4.  Message Confidentiality
   12. IANA Considerations
     12.1.  Field Name Registration
     12.2.  Media Type Registration
     12.3.  Transfer Coding Registration
     12.4.  ALPN Protocol ID Registration
   13. References
     13.1.  Normative References
     13.2.  Informative References
   Appendix A.  Collected ABNF
   Appendix B.  Differences between HTTP and MIME
     B.1.  MIME-Version
     B.2.  Conversion to Canonical Form
     B.3.  Conversion of Date Formats
     B.4.  Conversion of Content-Encoding
     B.5.  Conversion of Content-Transfer-Encoding
     B.6.  MHTML and Line Length Limitations
   Appendix C.  Changes from Previous RFCs
     C.1.  Changes from HTTP/0.9
     C.2.  Changes from HTTP/1.0
       C.2.1.  Multihomed Web Servers
       C.2.2.  Keep-Alive Connections
       C.2.3.  Introduction of Transfer-Encoding
     C.3.  Changes from RFC 7230
   Acknowledgements
   Index
   Authors' Addresses
```

---
## **1.  Introduction**

HTTP\(Hypertext Transfer Protocol\)는 네트워크 기반 하이퍼텍스트 정보 시스템과의 유연한 상호 작용을 위해 확장 가능한 의미 체계와 자체 설명 메시지를 사용하는 상태 비저장 애플리케이션 수준 요청/응답 프로토콜입니다. HTTP/1.1은 다음과 같이 정의됩니다.

\*  이 문서

```text
   *  "HTTP Semantics" [HTTP]

   *  "HTTP Caching" [CACHING]
```

이 문서에서는 HTTP/1.1 메시지 구문, 프레이밍 및 연결 관리 메커니즘을 사용하여 HTTP 의미 체계가 전달되는 방법을 지정합니다. 그 목표는 HTTP/1.1 메시지 구문 분석기와 메시지 전달 중개자에 대한 완전한 요구 사항 세트를 정의하는 것입니다.

이 문서는 HTTP/1.1 메시징 및 연결 관리와 관련된 RFC 7230 부분을 폐기했으며 변경 사항은 부록 C.3에 요약되어 있습니다. RFC 7230의 다른 부분은 "HTTP 의미론"\[HTTP\]에 의해 폐기되었습니다.

---
### **1.1.  Requirements Notation**

키워드 "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY" 및 "OPTIONAL" "는 BCP 14 \[RFC2119\] \[RFC8174\]에 설명된 대로 여기에 표시된 것처럼 모두 대문자로 표시되는 경우에만 해석됩니다.\(MUST NOT\)

오류 처리에 관한 적합성 기준 및 고려 사항은 \[HTTP\]의 섹션 2에 정의되어 있습니다.

---
### **1.2.  Syntax Notation**

이 사양은 \[RFC7405\]에 정의된 문자열의 대소문자 구분 표기법으로 확장된 \[RFC5234\]의 ABNF\(Augmented Backus-Naur Form\) 표기법을 사용합니다.

또한 \[HTTP\]의 섹션 5.6.1에 정의된 목록 확장을 사용하여 "#" 연산자를 사용하여 쉼표로 구분된 목록을 간결하게 정의할 수 있습니다\("\*" 연산자가 반복을 나타내는 방식과 유사\). 부록 A는 표준 ABNF 표기법으로 확장된 모든 목록 연산자와 함께 수집된 문법을 보여줍니다.

관례적으로 "obs-" 접두사가 붙은 ABNF 규칙 이름은 역사적인 이유로 나타나는 오래된 문법 규칙을 나타냅니다.

\[RFC5234\], 부록 B.1에 정의된 대로 다음 핵심 규칙이 참조로 포함됩니다. ALPHA\(문자\), CR\(캐리지 리턴\), CRLF\(CR LF\), CTL\(컨트롤\), DIGIT\(십진수 0-9\) , DQUOTE\(큰따옴표\), HEXDIG\(16진수 0-9/A-F/a-f\), HTAB\(가로 탭\), LF\(줄 바꿈\), OCTET\(8비트 데이터 시퀀스\), SP\(공백\) 및 VCHAR\( 보이는 모든 \[USASCII\] 문자\).

아래 규칙은 \[HTTP\]에 정의되어 있습니다.

```text
     BWS           = <BWS, see [HTTP], Section 5.6.3>
     OWS           = <OWS, see [HTTP], Section 5.6.3>
     RWS           = <RWS, see [HTTP], Section 5.6.3>
     absolute-path = <absolute-path, see [HTTP], Section 4.1>
     field-name    = <field-name, see [HTTP], Section 5.1>
     field-value   = <field-value, see [HTTP], Section 5.5>
     obs-text      = <obs-text, see [HTTP], Section 5.6.4>
     quoted-string = <quoted-string, see [HTTP], Section 5.6.4>
     token         = <token, see [HTTP], Section 5.6.2>
     transfer-coding =
                     <transfer-coding, see [HTTP], Section 10.1.4>
```

아래 규칙은 \[URI\]에 정의되어 있습니다.

```text
     absolute-URI  = <absolute-URI, see [URI], Section 4.3>
     authority     = <authority, see [URI], Section 3.2>
     uri-host      = <host, see [URI], Section 3.2.2>
     port          = <port, see [URI], Section 3.2.3>
     query         = <query, see [URI], Section 3.4>
```

---
## **2.  Message**

HTTP/1.1 클라이언트와 서버는 메시지를 보내 통신합니다. HTTP의 일반적인 용어와 핵심 개념은 \[HTTP\]의 섹션 3을 참조하세요.

---
### **2.1.  Message Format**

HTTP/1.1 메시지는 인터넷 메시지 형식 \[RFC5322\]과 유사한 형식의 CRLF와 일련의 옥텟이 뒤따르는 시작 줄로 구성됩니다. 0개 이상의 헤더 필드 줄\(통칭하여 "헤더" 또는 "헤더 섹션"\), 헤더 섹션의 끝을 나타내는 빈 줄, 선택적 메시지 본문입니다.

```text
     HTTP-message   = start-line CRLF
                      *( field-line CRLF )
                      CRLF
                      [ message-body ]
```

메시지는 클라이언트에서 서버로의 요청일 수도 있고 서버에서 클라이언트로의 응답일 수도 있습니다. 구문론적으로 두 가지 유형의 메시지는 요청 라인\(요청의 경우\) 또는 상태 라인\(응답의 경우\)인 시작 라인과 메시지 본문의 길이를 결정하는 알고리즘\(섹션\)에서만 다릅니다. 6\).

```text
     start-line     = request-line / status-line
```

이론적으로 클라이언트는 요청을 수신하고 서버는 응답을 수신하여 서로 다른 시작줄 형식으로 구분할 수 있습니다. 실제로 서버는 요청\(응답은 알 수 없거나 유효하지 않은 요청 방법으로 해석됨\)만 기대하도록 구현되고 클라이언트는 응답만 기대하도록 구현됩니다.

HTTP는 다목적 인터넷 메일 확장\(MIME\) \[RFC2045\]과 유사한 일부 프로토콜 요소를 사용합니다. HTTP 메시지와 MIME 메시지의 차이점은 부록 B를 참조하세요.

---
### **2.2.  Message Parsing**

HTTP 메시지를 구문 분석하는 일반적인 절차는 시작 줄을 구조로 읽고, 각 헤더 필드 줄을 빈 줄까지 필드 이름별로 해시 테이블로 읽은 다음 구문 분석된 데이터를 사용하여 메시지 본문이 예상되는지 확인하는 것입니다. . 메시지 본문이 표시된 경우 메시지 본문 길이와 동일한 옥텟 수를 읽거나 연결이 닫힐 때까지 스트림으로 읽혀집니다.

수신자는 HTTP 메시지를 US-ASCII\[USASCII\]의 상위 집합인 인코딩의 옥텟 시퀀스로 구문 분석해야 합니다. 특정 인코딩에 관계없이 HTTP 메시지를 유니코드 문자 스트림으로 구문 분석하면 문자열 처리 라이브러리가 옥텟 LF\(%x0A\)가 포함된 잘못된 멀티바이트 문자 시퀀스를 처리하는 다양한 방식으로 인해 보안 취약점이 발생합니다. 문자열 기반 구문 분석기는 메시지 구문 분석이 개별 필드 행을 기술한 후 헤더 필드 행 값 내에서와 같이 메시지에서 요소가 추출된 후 프로토콜 요소 내에서만 안전하게 사용할 수 있습니다.\(MUST\)

시작 줄과 필드에 대한 줄 종결자는 시퀀스 CRLF이지만 수신자는 단일 LF를 줄 종결자로 인식하고 이전 CR을 무시할 수 있습니다.\(MAY\)

발신자는 콘텐츠 이외의 프로토콜 요소 내에서 베어 CR\(바로 뒤에 LF가 오지 않는 CR 문자\)을 생성해서는 안 됩니다. 이러한 베어 CR의 수신자는 해당 요소를 유효하지 않은 것으로 간주하거나 요소를 처리하거나 메시지를 전달하기 전에 각 베어 CR을 SP로 교체해야 합니다.\(MUST NOT, MUST\)

이전 HTTP/1.0 사용자 에이전트 구현에서는 줄 끝으로 종료되지 않은 메시지 본문 콘텐츠를 읽지 못한 일부 초기 서버 응용 프로그램에 대한 해결 방법으로 POST 요청 후에 추가 CRLF를 보낼 수 있습니다. HTTP/1.1 사용자 에이전트는 요청 앞에 추가 CRLF를 추가하거나 뒤에 붙여서는 안 됩니다. 줄 끝으로 요청 메시지 본문을 종료하려는 경우 사용자 에이전트는 종료 CRLF 옥텟을 메시지 본문 길이의 일부로 계산해야 합니다.\(MUST NOT, MUST\)

견고성을 위해 요청 라인을 수신하고 구문 분석할 것으로 예상되는 서버는 요청 라인 이전에 수신된 적어도 하나의 빈 라인\(CRLF\)을 무시해야 합니다.\(SHOULD\)

발신자는 시작 줄과 첫 번째 헤더 필드 사이에 공백을 보내서는 안 됩니다.\(MUST NOT\)

시작 줄과 첫 번째 헤더 필드 사이에 공백을 수신하는 수신자는 메시지를 유효하지 않은 것으로 거부하거나 추가 처리 없이 공백 앞에 오는 각 줄을 사용해야 합니다\(즉, 공백이 앞에 오는 모든 후속 줄과 함께 전체 줄을 무시해야 합니다\). , 적절하게 구성된 헤더 필드가 수신되거나 헤더 섹션이 종료될 때까지\). 요청 밀수\(섹션 11.2\) 또는 응답 분할\(섹션 11.1\) 공격에 취약할 수 있는 다운스트림 수신자의 잘못된 해석을 방지하려면 잘못된 공백 앞에 오는 줄을 거부하거나 제거해야 합니다.\(MUST\)

HTTP 요청 메시지만 수신하는 서버 또는 시작줄에서 HTTP 요청 메시지로 나타나는 것을 처리하는 서버가 위에 나열된 견고성 예외를 제외하고 HTTP 메시지 문법과 일치하지 않는 일련의 옥텟을 수신하는 경우, 서버는 400\(잘못된 요청\) 응답으로 응답하고 연결을 닫아야 합니다\(SHOULD\).\(SHOULD\)

---
### **2.3.  HTTP Version**

HTTP는 "<major\>.<minor\>" 번호 지정 체계를 사용하여 프로토콜 버전을 나타냅니다. 이 사양은 버전 "1.1"을 정의합니다. \[HTTP\]의 섹션 2.5는 HTTP 버전 번호의 의미를 지정합니다.

HTTP/1.x 메시지의 버전은 시작줄의 HTTP 버전 필드로 표시됩니다. HTTP 버전은 대소문자를 구분합니다.

```text
     HTTP-version  = HTTP-name "/" DIGIT "." DIGIT
     HTTP-name     = %s"HTTP"
```

HTTP/1.1 메시지가 HTTP/1.0 수신자\[HTTP/1.0\] 또는 버전을 알 수 없는 수신자에게 전송될 때, HTTP/1.1 메시지는 다음과 같은 경우 유효한 HTTP/1.0 메시지로 해석될 수 있도록 구성됩니다. 최신 기능은 무시됩니다. 이 사양은 일부 새로운 기능에 대한 수신자 버전 요구 사항을 지정하므로 준수하는 발신자는 구성이나 메시지 수신을 통해 수신자가 HTTP/1.1을 지원한다고 확인할 때까지 호환되는 기능만 사용하게 됩니다.

HTTP 메시지를 처리하는 중개자\(즉, 터널 역할을 하지 않는 모든 중개자\)는 업스트림 문제에 대한 해결 방법으로 의도적으로 다운그레이드되지 않는 한 전달된 메시지에서 자체 HTTP 버전을 보내야 합니다. 즉, 중개자는 해당 메시지의 프로토콜 버전이 해당 중개자가 메시지 수신 및 전송에 적합한 버전과 일치하는지 확인하지 않고 맹목적으로 시작 줄을 전달할 수 없습니다. HTTP 버전을 다시 작성하지 않고 HTTP 메시지를 전달하면 다운스트림 수신자가 메시지 보낸 사람의 버전을 사용하여 나중에 해당 보낸 사람과의 통신에 사용하기에 안전한 기능을 결정할 때 통신 오류가 발생할 수 있습니다.\(MUST\)

클라이언트가 HTTP 사양을 잘못 구현하고 최신 버전 응답을 올바르게 처리할 수 없는 것으로 알려지거나 의심되는 경우\(예: 클라이언트가 버전 번호 구문 분석에 실패한 경우\) 서버는 HTTP/1.1 요청에 대한 HTTP/1.0 응답을 보낼 수 있습니다. 올바르게 또는 프로토콜의 주어진 마이너 버전을 따르지 않는 경우에도 중개자가 HTTP 버전을 맹목적으로 전달하는 것으로 알려진 경우. 이러한 프로토콜 다운그레이드는 하나 이상의 요청 헤더 필드\(예: User-Agent\)가 오류가 있는 것으로 알려진 클라이언트가 전송한 값과 고유하게 일치하는 경우와 같이 특정 클라이언트 속성에 의해 트리거되지 않는 한 수행되어서는 안 됩니다.\(MAY, SHOULD NOT\)

---
## **3.  Request Line**

요청 라인은 메소드 토큰으로 시작하고 이어서 단일 공백\(SP\), 요청 대상 및 또 다른 단일 공백\(SP\)이 따르고 프로토콜 버전으로 끝납니다.

```text
     request-line   = method SP request-target SP HTTP-version
```

요청 라인 문법 규칙에 따라 각 구성 요소 요소가 단일 SP 옥텟으로 구분되어야 하지만 수신자는 대신 공백으로 구분된 단어 경계를 구문 분석하고 CRLF 종결자를 제외하고 모든 형태의 공백을 SP 구분 기호로 처리할 수 있습니다. 앞이나 뒤의 공백을 무시합니다. 이러한 공백에는 SP, HTAB, VT\(%x0B\), FF\(%x0C\) 또는 베어 CR 중 하나 이상의 옥텟이 포함됩니다. 그러나 관대한 구문 분석은 메시지 수신자가 여러 명이고 각각 ​​견고성에 대한 고유한 해석이 있는 경우 요청 밀수 보안 취약점을 초래할 수 있습니다\(섹션 11.2 참조\).\(MAY\)

HTTP는 \[HTTP\]의 섹션 2.3에 설명된 대로 요청 라인 길이에 미리 정의된 제한을 두지 않습니다. 구현하는 것보다 긴 메소드를 수신하는 서버는 501\(구현되지 않음\) 상태 코드로 응답해야 합니다. 구문 분석하려는 URI보다 긴 요청 대상을 수신하는 서버는 414\(URI가 너무 김\) 상태 코드로 응답해야 합니다\(\[HTTP\]의 섹션 15.5.15 참조\).\(SHOULD, MUST\)

실제로 요청 라인 길이에 대한 다양한 임시 제한이 있습니다. 모든 HTTP 발신자와 수신자는 최소 8000옥텟의 요청 라인 길이를 지원하는 것이 좋습니다.\(SHOULD\)

---
### **3.1.  Method**

메소드 토큰은 대상 자원에서 수행될 요청 메소드를 나타냅니다. 요청 방법은 대소문자를 구분합니다.

```text
     method         = token
```

이 사양에 의해 정의된 요청 메서드는 HTTP 메서드 레지스트리에 관한 정보 및 새 메서드 정의에 대한 고려 사항과 함께 \[HTTP\]의 섹션 9에서 찾을 수 있습니다.

---
### **3.2.  Request Target**

요청 대상은 요청을 적용할 대상 리소스를 식별합니다. 클라이언트는 원하는 대상 URI에서 요청 대상을 파생합니다. 요청되는 방법과 요청이 프록시에 대한 것인지 여부에 따라 요청 대상에 대한 네 가지 고유한 형식이 있습니다.

```text
     request-target = origin-form
                    / absolute-form
                    / authority-form
                    / asterisk-form
```

요청 대상에는 공백이 허용되지 않습니다. 불행하게도 일부 사용자 에이전트는 하이퍼텍스트 참조에서 발견된 공백을 적절하게 인코딩하거나 제외하지 못하여 허용되지 않는 문자가 잘못된 요청 라인의 요청 대상으로 전송되는 결과를 낳습니다.

유효하지 않은 요청 라인의 수신자는 400\(잘못된 요청\) 오류 또는 301\(영구적으로 이동됨\) 리디렉션으로 응답해야 하며 요청 대상이 올바르게 인코딩되어야 합니다. 수신자는 자동 수정을 시도한 다음 리디렉션 없이 요청을 처리해서는 안 됩니다. 잘못된 요청 라인이 요청 체인을 따라 보안 필터를 우회하도록 의도적으로 제작될 수 있기 때문입니다.\(SHOULD, SHOULD NOT\)

클라이언트는 모든 HTTP/1.1 요청 메시지에 Host 헤더 필드\(\[HTTP\]의 섹션 7.2\)를 보내야 합니다. 대상 URI에 권한 구성 요소가 포함된 경우 클라이언트는 userinfo 하위 구성 요소 및 해당 "@" 구분 기호를 제외하고 해당 권한 구성 요소와 동일한 Host에 대한 필드 값을 전송해야 합니다\(\[HTTP\]의 섹션 4.2\). 대상 URI에 대한 권한 구성 요소가 누락되었거나 정의되지 않은 경우 클라이언트는 빈 필드 값이 포함된 Host 헤더 필드를 보내야 합니다.\(MUST, MUST, MUST\)

서버는 Host 헤더 필드가 없는 HTTP/1.1 요청 메시지와 두 개 이상의 Host 헤더 필드 행 또는 유효하지 않은 필드 값이 있는 Host 헤더 필드를 포함하는 요청 메시지에 400\(잘못된 요청\) 상태 코드로 응답해야 합니다. .\(MUST\)

---
#### **3.2.1.  origin-form**

요청 대상의 가장 일반적인 형식은 "원본 형식"입니다.

```text
     origin-form    = absolute-path [ "?" query ]
```

CONNECT 또는 서버 전체 OPTIONS 요청\(아래 설명 참조\) 이외의 원본 서버에 직접 요청할 때 클라이언트는 대상 URI의 절대 경로 및 쿼리 구성 요소만 요청 대상으로 보내야 합니다. 대상 URI의 경로 구성 요소가 비어 있는 경우 클라이언트는 요청 대상의 원본 형식 내에서 경로로 "/"를 보내야 합니다. \[HTTP\]의 섹션 7.2에 정의된 대로 Host 헤더 필드도 전송됩니다.\(MUST, MUST\)

예를 들어, 다음과 같이 식별된 리소스의 표현을 검색하려는 클라이언트가 있습니다.

```text
     http://www.example.org/where?q=now
```

원본 서버에서 직접 호스트 "www.example.org"의 포트 80에 대한 TCP 연결을 열고\(또는 재사용\) 다음 행을 보냅니다.

```text
   GET /where?q=now HTTP/1.1
   Host: www.example.org
```

요청 메시지의 나머지 부분이 이어집니다.

---
#### **3.2.2.  absolute-form**

CONNECT 또는 서버 전체 OPTIONS 요청\(아래 설명 참조\) 이외의 프록시에 요청할 때 클라이언트는 요청 대상으로 "절대 형식"의 대상 URI를 보내야 합니다.\(MUST\)

```text
     absolute-form  = absolute-URI
```

프록시는 가능한 경우 유효한 캐시에서 요청을 서비스하거나 클라이언트를 대신하여 다음 인바운드 프록시 서버 또는 요청 대상에 표시된 원본 서버에 직접 동일한 요청을 수행하도록 요청됩니다. 이러한 메시지 "전달"에 대한 요구 사항은 \[HTTP\]의 섹션 7.6에 정의되어 있습니다.

요청 라인의 절대 형식의 예는 다음과 같습니다.

```text
   GET http://www.example.org/pub/WWW/TheProject.html HTTP/1.1
```

클라이언트는 요청 대상이 절대 형식인 경우에도 HTTP/1.1 요청에서 Host 헤더 필드를 보내야 합니다. 이를 통해 Host 정보가 Host를 구현하지 않았을 수 있는 고대 HTTP/1.0 프록시를 통해 전달될 수 있기 때문입니다.\(MUST\)

프록시가 절대 형식의 request-target으로 요청을 수신하면 프록시는 수신된 Host 헤더 필드\(있는 경우\)를 무시하고 대신 이를 request-target의 호스트 정보로 바꿔야 합니다. 그러한 요청을 전달하는 프록시는 수신된 Host 필드 값을 전달하는 대신 수신된 요청 대상을 기반으로 새로운 Host 필드 값을 생성해야 합니다.\(MUST, MUST\)

원서버가 request-target의 절대 형식으로 요청을 수신하면 원서버는 수신된 Host 헤더 필드\(있는 경우\)를 무시하고 대신 request-target의 호스트 정보를 사용해야 합니다. request-target에 권한 구성 요소가 없으면 이 경우 빈 Host 헤더 필드가 전송됩니다.\(MUST\)

대부분의 HTTP/1.1 클라이언트가 프록시에 절대 형식만 전송하더라도 서버는 요청에서 절대 형식을 수락해야 합니다.\(MUST\)

---
#### **3.2.3.  authority-form**

request-target의 "authority-form"은 CONNECT 요청에만 사용됩니다\(\[HTTP\]의 섹션 9.3.6\). 이는 콜론\(":"\)으로 구분된 터널 대상의 uri-host 및 포트 번호로만 구성됩니다.

```text
     authority-form = uri-host ":" port
```

하나 이상의 프록시를 통해 터널을 설정하기 위해 CONNECT 요청을 할 때 클라이언트는 요청 대상으로 터널 대상의 호스트와 포트만 보내야 합니다. 클라이언트는 대상 URI가 포트를 생략하는 경우 체계의 기본 포트를 보내는 것을 제외하고 대상 URI의 권한 구성 요소에서 호스트와 포트를 얻습니다. 예를 들어 "http://www.example.com"에 대한 CONNECT 요청은 다음과 같습니다.\(MUST\)

```text
   CONNECT www.example.com:80 HTTP/1.1
   Host: www.example.com
```

---
#### **3.2.4.  asterisk-form**

request-target의 "별표 형식"은 서버 전체 OPTIONS 요청\(\[HTTP\]의 섹션 9.3.7\)에만 사용됩니다.

```text
     asterisk-form  = "*"
```

클라이언트가 해당 서버의 특정 명명된 리소스와 달리 서버 전체에 대한 OPTIONS를 요청하려는 경우 클라이언트는 요청 대상으로 "\*"\(%x2A\)만 보내야 합니다. 예를 들어,\(MUST\)

```text
   OPTIONS * HTTP/1.1
```

프록시가 URI에 빈 경로가 있고 쿼리 구성 요소가 없는 절대 형식의 요청 대상으로 OPTIONS 요청을 수신하는 경우 요청 체인의 마지막 프록시는 전달할 때 "\*"의 요청 대상을 보내야 합니다. 지정된 원본 서버에 대한 요청입니다.\(MUST\)

예를 들어, 요청

```text
   OPTIONS http://www.example.org:8001 HTTP/1.1
```

최종 프록시에 의해 다음과 같이 전달됩니다.

```text
   OPTIONS * HTTP/1.1
   Host: www.example.org:8001
```

호스트 "www.example.org"의 포트 8001에 연결한 후.

---
### **3.3.  Reconstructing the Target URI**

요청 대상이 절대 형식인 경우 대상 URI는 요청 대상입니다. 이 경우 서버는 추가 평가를 위해 URI를 일반 구성 요소로 구문 분석합니다.

그렇지 않으면 서버는 대상 리소스를 식별하기 위해 연결 컨텍스트와 요청 메시지의 다양한 부분에서 대상 URI를 재구성합니다\(\[HTTP\]의 섹션 7.1\).

\* 서버 구성이 고정된 URI 체계를 제공하거나 신뢰할 수 있는 아웃바운드 게이트웨이에서 체계를 제공하는 경우 해당 체계가 대상 URI에 사용됩니다. 게이트웨이 서버가 클라이언트의 연결 컨텍스트를 수신하고 이를 인바운드 서버에 대한 자체 연결로 대체하기 때문에 이는 대규모 배포에서 일반적입니다. 그렇지 않고 보안 연결을 통해 요청이 수신되면 대상 URI의 체계는 "https"입니다. 그렇지 않은 경우 구성표는 "http"입니다.

\* 요청 대상이 권한 형식인 경우 대상 URI의 권한 구성 요소는 요청 대상입니다. 그렇지 않은 경우 대상 URI의 권한 구성 요소는 Host 헤더 필드의 필드 값입니다. Host 헤더 필드가 없거나 해당 필드 값이 비어 있거나 유효하지 않은 경우 대상 URI의 권한 구성 요소는 비어 있습니다.

\* 요청 대상이 권한 형식 또는 별표 형식인 경우 대상 URI의 결합된 경로 및 쿼리 구성 요소는 비어 있습니다. 그렇지 않은 경우 대상 URI의 결합된 경로 및 쿼리 구성 요소는 요청 대상입니다.

\* 위와 같이 결정된 재구성된 대상 URI의 구성 요소는 스키마, "://", 권한, 결합된 경로 및 쿼리 구성 요소를 연결하여 절대 URI 형식으로 재결합될 수 있습니다.

예시 1: 보안 연결을 통해 수신된 다음 메시지

```text
   GET /pub/WWW/TheProject.html HTTP/1.1
   Host: www.example.org
```

대상 URI가 다음과 같습니다.

```text
     https://www.example.org/pub/WWW/TheProject.html
```

예 2: 안전하지 않은 연결을 통해 수신된 다음 메시지

```text
   OPTIONS * HTTP/1.1
   Host: www.example.org:8080
```

대상 URI가 다음과 같습니다.

```text
     http://www.example.org:8080
```

대상 URI의 권한 구성 요소가 비어 있고 해당 URI 체계에 비어 있지 않은 권한이 필요한 경우\("http" 및 "https"의 경우\) 서버는 요청을 거부하거나 다음과 일치하는 구성된 기본값이 적용되는지 여부를 결정할 수 있습니다. 들어오는 연결의 컨텍스트. 컨텍스트에는 주소 및 포트와 같은 연결 세부 정보, 적용된 보안, 해당 서버 구성과 관련하여 로컬로 정의된 정보가 포함될 수 있습니다. 요청을 추가로 처리하기 전에 빈 권한이 구성된 기본값으로 대체됩니다.

보안 연결의 컨텍스트 내에서 권한에 대한 기본 이름을 제공하는 것은 사용자 에이전트의 의도된 권한이 기본값과 다를 가능성이 있는 경우 본질적으로 안전하지 않습니다. 요청 컨텍스트에서 권한을 고유하게 식별할 수 있는 서버는 이러한 위험 없이 해당 ID를 기본값으로 사용할 수 있습니다. 또는 새 클라이언트를 얻는 방법을 설명하는 안전한 리소스로 요청을 리디렉션하는 것이 더 나을 수도 있습니다.\(MAY\)

클라이언트의 대상 URI를 재구성하는 것은 대상 리소스를 식별하는 프로세스의 절반일 뿐입니다. 나머지 절반은 \[HTTP\]의 섹션 7.4에 정의된 대로 해당 대상 URI가 서버가 응답을 보낼 의향이 있고 응답을 보낼 수 있는 리소스를 식별하는지 여부를 결정하는 것입니다.

---
## **4.  Status Line**

응답 메시지의 첫 번째 라인은 프로토콜 버전, 공백\(SP\), 상태 코드 및 기타 공백으로 구성되고 상태 코드를 설명하는 OPTIONAL 텍스트 문구로 끝나는 상태 라인입니다.\(MAY\)

```text
     status-line = HTTP-version SP status-code SP [ reason-phrase ]
```

상태 줄 문법 규칙에서는 각 구성 요소를 단일 SP 옥텟으로 구분해야 하지만 수신자는 대신 공백으로 구분된 단어 경계를 구문 분석하고 줄 종결자를 제외하고 모든 형태의 공백을 SP 구분 기호로 처리할 수 있습니다. 앞이나 뒤의 공백을 무시합니다. 이러한 공백에는 SP, HTAB, VT\(%x0B\), FF\(%x0C\) 또는 베어 CR 중 하나 이상의 옥텟이 포함됩니다. 그러나 관대한 구문 분석은 메시지 수신자가 여러 명이고 각각 ​​견고성에 대한 고유한 해석이 있는 경우 응답 분할 보안 취약점을 초래할 수 있습니다\(섹션 11.1 참조\).\(MAY\)

상태 코드 요소는 클라이언트의 해당 요청을 이해하고 만족시키려는 서버의 시도 결과를 설명하는 3자리 정수 코드입니다. 수신자는 해당 상태 코드에 대해 정의된 의미\(해당 수신자가 상태 코드를 인식한 경우\) 또는 특정 코드를 인식할 수 없는 경우 해당 상태 코드의 클래스에 따라 응답 메시지의 나머지 부분을 구문 분석하고 해석합니다.

```text
     status-code    = 3DIGIT
```

HTTP의 핵심 상태 코드는 상태 코드 클래스, 새로운 상태 코드 정의에 대한 고려 사항, 그러한 정의를 수집하기 위한 IANA 레지스트리와 함께 \[HTTP\]의 섹션 15에 정의되어 있습니다.

이유 문구 요소는 숫자 상태 코드와 관련된 텍스트 설명을 제공하기 위한 목적으로만 존재하며, 대부분 대화형 텍스트 클라이언트에서 더 자주 사용되었던 이전 인터넷 응용 프로그램 프로토콜을 따릅니다.

```text
     reason-phrase  = 1*( HTAB / SP / VCHAR / obs-text )
```

클라이언트는 이유 문구 콘텐츠가 정보에 대한 신뢰할 수 있는 채널이 아니기 때문에 무시해야 합니다\(이 내용은 특정 로케일에 대해 번역되거나 중개자가 덮어쓰거나 메시지가 다른 버전의 HTTP를 통해 전달될 때 삭제될 수 있음\). 서버는 이유 문구가 없는 경우에도 상태 코드와 이유 문구를 구분하는 공간을 보내야 합니다\(즉, 상태 줄은 공백으로 끝납니다\).\(SHOULD, MUST\)

---
## **5.  Field Syntax**

각 필드 줄은 대소문자를 구분하지 않는 필드 이름과 콜론\(":"\), 선택적 선행 공백, 필드 줄 값 및 선택적 후행 공백으로 구성됩니다.

```text
     field-line   = field-name ":" OWS field-value OWS
```

필드 값 내 구문 분석 규칙은 \[HTTP\]의 섹션 5.5에 정의되어 있습니다. 이 섹션에서는 HTTP/1.1 메시지 내에 헤더 필드를 포함하고 추출하기 위한 일반 구문을 다룹니다.

---
### **5.1.  Field Line Parsing**

메시지는 개별 필드 이름과 관계없이 일반 알고리즘을 사용하여 구문 분석됩니다. 지정된 필드 줄 값 내의 콘텐츠는 메시지 해석의 이후 단계\(일반적으로 메시지의 전체 필드 섹션이 처리된 후\)까지 구문 분석되지 않습니다.

필드 이름과 콜론 사이에는 공백이 허용되지 않습니다. 과거에는 이러한 공백 처리의 차이로 인해 요청 라우팅 및 응답 처리의 보안 취약점이 발생했습니다. 서버는 헤더 필드 이름과 콜론 사이에 공백이 포함된 수신된 요청 메시지를 응답 상태 코드 400\(잘못된 요청\)으로 거부해야 합니다. 프록시는 메시지를 다운스트림으로 전달하기 전에 응답 메시지에서 이러한 공백을 제거해야 합니다.\(MUST, MUST\)

필드 줄 값은 선택적 공백\(OWS\)이 앞 및/또는 뒤에 올 수 있습니다. 사람이 일관되게 읽을 수 있도록 필드 라인 값 앞에 단일 SP가 선호됩니다. 필드 라인 값에는 선행 또는 후행 공백이 포함되지 않습니다. 필드 라인 값의 공백이 아닌 첫 번째 옥텟 이전 또는 필드 라인 값의 공백이 아닌 마지막 옥텟 이후에 발생하는 OWS는 필드를 추출할 때 파서에 의해 제외됩니다. 필드 라인의 라인 값.

---
### **5.2.  Obsolete Line Folding**

역사적으로 HTTP/1.x 필드 값은 각 추가 줄 앞에 최소한 하나의 공백이나 가로 탭\(obs-fold\)을 추가하여 여러 줄로 확장할 수 있었습니다. 이 사양은 "message/http" 미디어 유형\(섹션 10.1\) 내를 제외하고 이러한 줄 접기를 더 이상 사용하지 않습니다.

```text
     obs-fold     = OWS CRLF RWS
                  ; obsolete line folding
```

발신자는 메시지가 "message/http" 미디어 유형 내에서 패키징되도록 의도되지 않는 한 줄 접기를 포함하는 메시지\(즉, obs-fold 규칙과 일치하는 필드 줄 값이 있는 메시지\)를 생성해서는 안 됩니다.\(MUST NOT\)

"message/http" 컨테이너 내에 있지 않은 요청 메시지에서 obs-fold를 수신하는 서버는 반드시 400\(잘못된 요청\)을 전송하여 메시지를 거부해야 하며, 바람직하게는 더 이상 사용되지 않는 줄 접기가 허용되지 않음을 설명하는 표현과 함께 해야 합니다. 필드 값을 해석하거나 메시지 다운스트림을 전달하기 전에 수신된 각 obs-fold를 하나 이상의 SP 옥텟으로 대체합니다.\(MUST\)

"message/http" 컨테이너 내에 없는 응답 메시지에서 obs-fold를 수신하는 프록시 또는 게이트웨이는 메시지를 삭제하고 이를 502\(잘못된 게이트웨이\) 응답으로 대체해야 하며, 바람직하게는 허용되지 않는 라인을 설명하는 표현으로 대체해야 합니다. 폴딩이 수신되었거나 필드 값을 해석하거나 메시지 다운스트림을 전달하기 전에 수신된 각 obs-fold를 하나 이상의 SP 옥텟으로 대체합니다.\(MUST\)

"message/http" 컨테이너 내에 있지 않은 응답 메시지에서 obs-fold를 수신하는 사용자 에이전트는 필드 값을 해석하기 전에 수신된 각 obs-fold를 하나 이상의 SP 옥텟으로 대체해야 합니다.\(MUST\)

---
## **6.  Message Body**

HTTP/1.1 메시지의 메시지 본문\(있는 경우\)은 요청 또는 응답에 대한 콘텐츠\(\[HTTP\]의 섹션 6.4\)를 전달하는 데 사용됩니다. 섹션 6.1에 설명된 대로 전송 코딩이 적용되지 않은 경우 메시지 본문은 내용과 동일합니다.

```text
     message-body = *OCTET
```

HTTP/1.1 메시지에 메시지 본문이 존재하는 시기를 결정하는 규칙은 요청과 응답에 따라 다릅니다.

요청에 메시지 본문이 있으면 Content-Length 또는 Transfer-Encoding 헤더 필드를 통해 알립니다. 요청 메시지 프레이밍은 메소드 의미론과 무관합니다.

섹션 6.3에 자세히 설명된 대로 응답에 메시지 본문이 있는지 여부는 응답하는 요청 방법과 응답 상태 코드에 따라 달라집니다. 이는 응답 콘텐츠가 HTTP 의미론\(\[HTTP\]의 섹션 6.4.1\)에 의해 허용되는 경우에 해당합니다.

---
### **6.1.  Transfer-Encoding**

Transfer-Encoding 헤더 필드에는 메시지 본문을 형성하기 위해 콘텐츠에 적용된\(또는 앞으로 적용될\) 전송 코딩 시퀀스에 해당하는 전송 코딩 이름이 나열됩니다. 전송 코딩은 섹션 7에 정의되어 있습니다.

```text
     Transfer-Encoding = #transfer-coding
                          ; defined in [HTTP], Section 10.1.4
```

Transfer-Encoding은 7비트 전송 서비스\(\[RFC2045\], 섹션 6\)를 통해 바이너리 데이터를 안전하게 전송할 수 있도록 설계된 MIME의 Content-Transfer-Encoding 필드와 유사합니다. 그러나 안전한 전송은 8비트 클린 전송 프로토콜의 초점이 다릅니다. HTTP의 경우 Transfer-Encoding은 주로 동적으로 생성된 콘텐츠를 정확하게 구분하기 위한 것입니다. 또한 전송 중에만 적용되는 인코딩과 선택한 표현의 특징인 인코딩을 구별하는 역할도 합니다.

콘텐츠 크기를 미리 알 수 없을 때 메시지를 구성하는 데 중요한 역할을 하기 때문에 수신자는 청크 전송 코딩\(섹션 7.1\)을 구문 분석할 수 있어야 합니다. 발신자는 청크 분할 전송 코딩을 메시지 본문에 두 번 이상 적용해서는 안 됩니다\(즉, 이미 청크 분할된 메시지를 청크 분할하는 것은 허용되지 않습니다\). 청크 이외의 전송 코딩이 요청의 콘텐츠에 적용되는 경우 보낸 사람은 메시지가 적절하게 구성되었는지 확인하기 위해 최종 전송 코딩으로 청크를 적용해야 합니다. 청크 이외의 전송 코딩이 응답 내용에 적용되는 경우 발신자는 청크를 최종 전송 코딩으로 적용하거나 연결을 닫아 메시지를 종료해야 합니다.\(MUST, MUST NOT, MUST, MUST\)

예를 들어,

```text
   Transfer-Encoding: gzip, chunked
```

내용이 gzip 코딩을 사용하여 압축된 후 청크 코딩을 사용하여 메시지 본문을 구성함을 나타냅니다.

Content-Encoding\(\[HTTP\]의 섹션 8.4.1\)과 달리 Transfer-Encoding은 표현의 속성이 아니라 메시지의 속성입니다. 요청/응답 체인의 모든 수신자는 수신된 전송 코딩을 디코딩하거나 전송 인코딩 필드 값에 해당 변경 사항이 적용된다고 가정하여 메시지 본문에 추가 전송 코딩을 적용할 수 있습니다. 인코딩 매개변수에 대한 추가 정보는 이 사양에 정의되지 않은 다른 헤더 필드에서 제공될 수 있습니다.\(MAY\)

Transfer-Encoding은 HEAD 요청에 대한 응답이나 GET 요청에 대한 304\(수정되지 않음\) 응답\(\[HTTP\]의 섹션 15.4.5\)으로 전송될 수 있으며 둘 다 메시지 본문을 포함하지 않아 원본이 요청이 무조건 GET인 경우 서버는 메시지 본문에 전송 코딩을 적용했을 것입니다. 그러나 응답 체인\(원본 서버 포함\)의 모든 수신자는 필요하지 않은 경우 전송 코딩을 제거할 수 있으므로 이 표시는 필요하지 않습니다.\(MAY\)

서버는 상태 코드가 1xx\(정보\) 또는 204\(콘텐츠 없음\)인 응답으로 Transfer-Encoding 헤더 필드를 전송해서는 안 됩니다. 서버는 CONNECT 요청에 대한 2xx\(성공\) 응답에서 Transfer-Encoding 헤더 필드를 전송해서는 안 됩니다\(\[HTTP\]의 섹션 9.3.6\).\(MUST NOT, MUST NOT\)

이해하지 못하는 전송 코딩이 포함된 요청 메시지를 수신한 서버는 501\(구현되지 않음\)로 응답해야 합니다.\(SHOULD\)

전송 인코딩이 HTTP/1.1에 추가되었습니다. 일반적으로 HTTP/1.0 지원만을 광고하는 구현은 전송 인코딩 콘텐츠를 처리하는 방법을 이해하지 못할 것이며 전송 인코딩으로 수신된 HTTP/1.0 메시지는 청크 전송 코딩을 적절하게 처리하지 않고 전달될 가능성이 높다고 가정합니다. 운송 중.

클라이언트는 서버가 HTTP/1.1 요청\(또는 이후 마이너 개정판\)을 처리할 것이라는 것을 알지 않는 한 전송 인코딩이 포함된 요청을 보내서는 안 됩니다. 그러한 지식은 특정 사용자 구성의 형태이거나 이전에 수신된 응답의 버전을 기억함으로써 얻을 수 있습니다. 해당 요청이 HTTP/1.1\(또는 이후 마이너 개정판\)을 나타내지 않는 한 서버는 Transfer-Encoding이 포함된 응답을 보내면 안 됩니다.\(MUST NOT, MUST NOT\)

Transfer-Encoding의 초기 구현에서는 메시지 프레이밍을 위한 청크 전송 코딩과 진행률 표시줄에서 사용할 예상 Content-Length 헤더 필드가 모두 전송되는 경우가 있었습니다. 이것이 Transfer-Encoding이 상호 호환되지 않는 것이 아니라 Content-Length를 재정의하는 것으로 정의되는 이유입니다. 안타깝게도 이러한 메시지를 전달하면 다운스트림 수신자가 이 사양에 따라 메시지를 구문 분석하지 못하는 경우, 특히 다운스트림 수신자가 HTTP/1.0만 구현하는 경우 요청 밀수\(섹션 11.2\) 또는 응답 분할\(섹션 11.1\) 공격과 관련된 취약점이 발생할 수 있습니다.

서버는 콘텐츠 길이와 전송 인코딩을 모두 포함하는 요청을 거부하거나 전송 인코딩에만 따라서 이러한 요청을 처리할 수 있습니다. 그럼에도 불구하고 서버는 잠재적인 공격을 피하기 위해 그러한 요청에 응답한 후 연결을 닫아야 합니다.\(MAY, MUST\)

Transfer-Encoding 헤더 필드가 포함된 HTTP/1.0 메시지를 수신하는 서버 또는 클라이언트는 Content-Length가 존재하더라도 프레이밍에 결함이 있는 것처럼 메시지를 처리하고 메시지를 처리한 후 연결을 닫아야 합니다. 메시지 보낸 사람이 나중에 연결을 사용하면 잘못 해석될 수 있는 메시지의 일부를 버퍼에 보관했을 수 있습니다.\(MUST\)

---
### **6.2.  Content-Length**

메시지에 Transfer-Encoding 헤더 필드가 없는 경우 Content-Length 헤더 필드\(\[HTTP\]의 섹션 8.6\)는 잠재적인 콘텐츠에 대해 예상 크기를 십진수 옥텟 수로 제공할 수 있습니다. 콘텐츠가 포함된 메시지의 경우 Content-Length 필드 값은 데이터\(및 메시지\)가 끝나는 위치를 결정하는 데 필요한 프레이밍 정보를 제공합니다. 콘텐츠를 포함하지 않는 메시지의 경우 Content-Length는 선택한 표현의 크기를 나타냅니다\(\[HTTP\]의 섹션 8.6\).

발신자는 Transfer-Encoding 헤더 필드가 포함된 메시지에 Content-Length 헤더 필드를 보내면 안 됩니다.\(MUST NOT\)

- | \*참고:\* 메시지 프레이밍을 위한 HTTP의 Content-Length 사용 | MIME의 동일한 필드 사용과 크게 다릅니다. 여기서 | "message/external- | body" 미디어 유형 내에서만 사용되는 선택적 필드입니다.

---
### **6.3.  Message Body Length**

메시지 본문의 길이는 다음 중 하나에 따라 결정됩니다\(우선순위에 따라\).

1. HEAD 요청에 대한 모든 응답과 1xx\(정보\), 204\(콘텐츠 없음\) 또는 304\(수정되지 않음\) 상태 코드가 있는 응답은 헤더 필드에 관계없이 항상 헤더 필드 뒤의 첫 번째 빈 줄로 종료됩니다. 메시지에 존재하므로 메시지 본문이나 트레일러 섹션을 포함할 수 없습니다.

2. CONNECT 요청에 대한 2xx\(성공\) 응답은 헤더 필드를 마무리하는 빈 줄 바로 뒤에 연결이 터널이 된다는 것을 의미합니다. 클라이언트는 그러한 메시지에서 수신된 모든 Content-Length 또는 Transfer-Encoding 헤더 필드를 무시해야 합니다.\(MUST\)

3. Transfer-Encoding 및 Content-Length 헤더 필드가 모두 포함된 메시지가 수신되면 Transfer-Encoding이 Content-Length를 재정의합니다. 이러한 메시지는 요청 밀수\(섹션 11.2\) 또는 응답 분할\(섹션 11.1\)을 수행하려는 시도를 나타낼 수 있으며 오류로 처리되어야 합니다. 메시지를 전달하기로 선택한 중개자는 메시지 다운스트림을 전달하기 전에 먼저 수신된 Content-Length 필드를 제거하고 전송 인코딩\(아래 설명 참조\)을 처리해야 합니다.\(MUST\)

4. Transfer-Encoding 헤더 필드가 있고 청크 전송 코딩\(7.1절\)이 최종 인코딩인 경우 전송 코딩이 데이터가 완료되었음을 나타낼 때까지 청크 데이터를 읽고 디코딩하여 메시지 본문 길이가 결정됩니다.

- 응답에 Transfer-Encoding 헤더 필드가 있고 청크 전송 코딩이 최종 인코딩이 아닌 경우 메시지 본문 길이는 서버에서 연결을 닫을 때까지 연결을 읽어 결정됩니다.

- 요청에 Transfer-Encoding 헤더 필드가 있고 청크 전송 코딩이 최종 인코딩이 아닌 경우 메시지 본문 길이를 안정적으로 결정할 수 없습니다. 서버는 400\(잘못된 요청\) 상태 코드로 응답한 다음 연결을 닫아야 합니다.\(MUST\)

5. Transfer-Encoding 없이 잘못된 Content-Length 헤더 필드가 있는 메시지가 수신된 경우 메시지 프레이밍은 유효하지 않으며 수신자는 필드 값이 쉼표로 성공적으로 구문 분석되지 않는 한 이를 복구할 수 없는 오류로 처리해야 합니다. 분리된 목록\(\[HTTP\]의 섹션 5.6.1\), 목록의 모든 값이 유효하고 목록의 모든 값이 동일합니다\(이 경우 메시지는 Content-Length 필드로 사용되는 단일 값으로 처리됩니다\). 값\). 복구할 수 없는 오류가 요청 메시지에 있는 경우 서버는 400\(잘못된 요청\) 상태 코드로 응답한 다음 연결을 닫아야 합니다. 프록시가 수신한 응답 메시지에 있는 경우 프록시는 서버에 대한 연결을 닫고 수신된 응답을 삭제한 다음 502\(잘못된 게이트웨이\) 응답을 클라이언트에 보내야 합니다. 사용자 에이전트가 수신한 응답 메시지에 있는 경우 사용자 에이전트는 서버에 대한 연결을 닫고 수신된 응답을 폐기해야 합니다.\(MUST, MUST, MUST, MUST\)

6. 유효한 Content-Length 헤더 필드가 Transfer-Encoding 없이 존재하는 경우 해당 필드의 10진수 값은 예상되는 메시지 본문 길이\(옥텟\)를 정의합니다. 보낸 사람이 연결을 닫거나 표시된 옥텟 수를 수신하기 전에 받는 사람이 시간 초과되면 받는 사람은 메시지가 불완전한 것으로 간주하고 연결을 닫아야 합니다.\(MUST\)

7. 이것이 요청 메시지이고 위 사항 중 어느 것도 사실이 아닌 경우 메시지 본문 길이는 0입니다\(메시지 본문이 없음\).

8. 그렇지 않은 경우 선언된 메시지 본문 길이가 없는 응답 메시지이므로 메시지 본문 길이는 서버가 연결을 닫기 전에 수신한 옥텟 수에 따라 결정됩니다.

네트워크 오류로 인해 중단된 부분적으로 수신된 메시지와 성공적으로 완료된 닫혀 구분된 응답 메시지를 구별할 수 있는 방법이 없기 때문에 서버는 가능할 때마다 인코딩 또는 길이로 구분된 메시지를 생성해야 합니다. 닫기 구분 기능은 주로 HTTP/1.0과의 이전 버전과의 호환성을 위해 존재합니다.\(SHOULD\)

- | \*참고:\* 요청 메시지는 | 항상 명시적으로 길이 또는 전송 코딩으로 구성됩니다. 둘 다 없으면 요청이 즉시 종료됨을 의미 | 헤더 섹션.

서버는 411\(길이 필요\)로 응답하여 메시지 본문은 포함하지만 Content-Length는 포함하지 않는 요청을 거부할 수 있습니다.\(MAY\)

청크 분할 이외의 전송 코딩이 적용되지 않는 한, 메시지 본문이 포함된 요청을 보내는 클라이언트는 메시지 본문 길이가 미리 알려진 경우 청크 분할 전송 코딩 대신 유효한 Content-Length 헤더 필드를 사용해야 합니다. 서비스는 청크 전송 코딩을 이해하더라도 411\(길이 필요\) 상태 코드로 청크에 응답합니다. 이는 일반적으로 이러한 서비스가 호출되기 전에 콘텐츠 길이가 필요한 게이트웨이를 통해 구현되고 서버가 처리하기 전에 전체 요청을 버퍼링할 수 없거나 버퍼링할 의사가 없기 때문입니다.\(SHOULD\)

메시지 본문이 포함된 요청을 보내는 사용자 에이전트는 유효한 Content-Length 헤더 필드를 보내거나 청크 전송 코딩을 사용해야 합니다. 클라이언트는 서버가 HTTP/1.1\(또는 그 이상\) 요청을 처리할 것이라는 것을 알지 않는 한 청크 분할 전송 코딩을 사용해서는 안 됩니다. 그러한 정보는 특정 사용자 구성의 형태로 제공되거나 이전에 수신된 응답의 버전을 기억함으로써 얻을 수 있습니다.\(MUST, MUST NOT\)

연결에 대한 마지막 요청에 대한 최종 응답이 완전히 수신되었고 읽을 추가 데이터가 남아 있는 경우, 사용자 에이전트는 남은 데이터를 삭제하거나 해당 데이터가 이전 메시지 본문의 일부에 속하는지 확인하려고 시도할 수 있습니다. 이전 메시지의 Content-Length 값이 잘못된 경우입니다. 클라이언트는 이러한 추가 데이터를 별도의 응답으로 처리, 캐시 또는 전달해서는 안 됩니다. 이러한 동작은 캐시 중독에 취약하기 때문입니다.\(MAY, MUST NOT\)

---
## **7.  Transfer Codings**

전송 코딩 이름은 네트워크를 통한 "안전한 전송"을 보장하기 위해 메시지 콘텐츠에 적용되었거나 적용될 수 있거나 적용되어야 할 인코딩 변환을 나타내는 데 사용됩니다. 이는 전송 코딩이 전송되는 표현의 속성이 아니라 메시지의 속성이라는 점에서 콘텐츠 코딩과 다릅니다.

모든 전송 코딩 이름은 대소문자를 구분하지 않으며 섹션 7.3에 정의된 대로 HTTP 전송 코딩 레지스트리 내에 등록되어야 합니다. 이는 Transfer-Encoding\(섹션 6.1\) 및 TE\(\[HTTP\]의 섹션 10.1.4\) 헤더 필드에 사용됩니다\(후자는 "전송 코딩" 문법도 정의함\).

---
### **7.1.  Chunked Transfer Coding**

청크 전송 코딩은 콘텐츠를 일련의 청크로 전송하기 위해 콘텐츠를 래핑합니다. 각 청크에는 자체 크기 표시기가 있고 그 뒤에 트레일러 필드가 포함된 OPTIONAL 트레일러 섹션이 옵니다. 청크를 사용하면 크기를 알 수 없는 콘텐츠 스트림을 길이로 구분된 버퍼 시퀀스로 전송할 수 있습니다. 이를 통해 발신자는 연결 지속성을 유지하고 수신자는 전체 메시지를 수신한 시기를 알 수 있습니다.\(MAY\)

```text
     chunked-body   = *chunk
                      last-chunk
                      trailer-section
                      CRLF

     chunk          = chunk-size [ chunk-ext ] CRLF
                      chunk-data CRLF
     chunk-size     = 1*HEXDIG
     last-chunk     = 1*("0") [ chunk-ext ] CRLF

     chunk-data     = 1*OCTET ; a sequence of chunk-size octets
```

청크 크기 필드는 옥텟 단위로 청크 데이터의 크기를 나타내는 16진수 문자열입니다. 청크 크기가 0인 청크가 수신되면 청크 전송 코딩이 완료되고, 그 뒤에 트레일러 섹션이 올 수 있으며 마지막으로 빈 줄로 종료됩니다.

수신자는 청크 전송 코딩을 구문 분석하고 디코딩할 수 있어야 합니다.\(MUST\)

HTTP/1.1은 중개자가 전체 응답을 버퍼링할 수 있도록 청크된 응답의 크기를 제한하는 수단을 정의하지 않습니다. 또한 청크 크기가 매우 크면 해당 값이 수신 구현에서 정확하게 표시되지 않으면 오버플로가 발생하거나 정밀도가 손실될 수 있습니다. 따라서 수신자는 잠재적으로 큰 16진수 숫자를 예상하고 정수 변환 오버플로로 인한 구문 분석 오류나 정수 표현으로 인한 정밀도 손실을 방지해야 합니다.\(MUST\)

청크 코딩은 매개변수를 정의하지 않습니다. 이들의 존재는 오류로 처리되어야 합니다.\(SHOULD\)

---
#### **7.1.1.  Chunk Extensions**

청크 코딩을 사용하면 청크당 메타데이터\(예: 서명 또는 해시\), 중간 메시지 제어 정보 또는 메시지 본문 무작위화를 제공하기 위해 각 청크가 청크 크기 바로 뒤에 0개 이상의 청크 확장을 포함할 수 있습니다. 크기.

```text
     chunk-ext      = *( BWS ";" BWS chunk-ext-name
                         [ BWS "=" BWS chunk-ext-val ] )

     chunk-ext-name = token
     chunk-ext-val  = token / quoted-string
```

청크 코딩은 각 연결마다 다르며 상위 수준 애플리케이션이 확장을 검사하기 전에 각 수신자\(중개자 포함\)가 제거하거나 다시 코딩할 가능성이 높습니다. 따라서 청크 확장의 사용은 일반적으로 "긴 폴링"\(클라이언트와 서버가 청크 확장 사용에 관해 공유 기대를 가질 수 있음\)과 같은 특수 HTTP 서비스 또는 종단 간 보안 연결 내의 패딩으로 제한됩니다.

수신자는 인식할 수 없는 청크 확장을 무시해야 합니다. 서버는 메시지의 다른 부분에 대해 길이 제한 및 시간 초과를 적용하는 것과 동일한 방식으로 요청에서 수신된 청크 확장의 총 길이를 제공된 서비스에 대해 합리적인 양으로 제한해야 하며 적절한 4xx\(클라이언트 오류\)를 생성해야 합니다. \) 해당 금액을 초과하면 응답합니다.\(MUST\)

---
#### **7.1.2.  Chunked Trailer Section**

트레일러 섹션을 사용하면 메시지 무결성 검사, 디지털 서명 또는 사후 처리 상태와 같이 콘텐츠가 전송되는 동안 동적으로 생성될 수 있는 메타데이터를 제공하기 위해 보낸 사람이 청크 메시지 끝에 추가 필드를 포함할 수 있습니다. 트레일러 필드의 적절한 사용과 제한 사항은 \[HTTP\]의 섹션 6.5에 정의되어 있습니다.

```text
     trailer-section   = *( field-line CRLF )
```

메시지에서 청크 코딩을 제거하는 수신자는 수신된 트레일러 필드를 선택적으로 유지하거나 삭제할 수 있습니다. 수신된 트레일러 필드를 보유하는 수신자는 수신된 헤더 필드와 별도로 트레일러 필드를 저장/전달하거나 수신된 트레일러 필드를 헤더 섹션에 병합해야 합니다. 수신자는 해당 헤더 필드 정의가 트레일러 필드 값을 안전하게 병합할 수 있는 방법을 명시적으로 허용하고 지시하지 않는 한 수신된 트레일러 필드를 헤더 섹션에 병합해서는 안 됩니다.\(MAY, MUST, MUST NOT\)

---
#### **7.1.3.  Decoding Chunked**

청크 전송 코딩을 디코딩하는 프로세스는 다음과 같이 의사 코드로 표현될 수 있습니다.

```text
     length := 0
     read chunk-size, chunk-ext (if any), and CRLF
     while (chunk-size > 0) {
        read chunk-data and CRLF
        append chunk-data to content
        length := length + chunk-size
        read chunk-size, chunk-ext (if any), and CRLF
     }
     read trailer field
     while (trailer field is not empty) {
        if (trailer fields are stored/forwarded separately) {
            append trailer field to existing trailer fields
        }
        else if (trailer field is understood and defined as mergeable) {
            merge trailer field with existing header fields
        }
        else {
            discard trailer field
        }
        read trailer field
     }
     Content-Length := length
     Remove "chunked" from Transfer-Encoding
```

---
### **7.2.  Transfer Codings for Compression**

압축을 위한 다음 전송 코딩 이름은 해당 콘텐츠 코딩과 동일한 알고리즘으로 정의됩니다.

압축\(및 x-압축\)

- \[HTTP\]의 8.4.1.1항을 참고하세요.

꺾다

- \[HTTP\]의 8.4.1.2항을 참고하세요.

gzip\(및 x-gzip\)

- \[HTTP\]의 8.4.1.3항을 참고하세요.

압축 코딩은 매개변수를 정의하지 않습니다. 이러한 압축 코딩이 포함된 매개변수의 존재는 오류로 처리되어야 합니다.\(SHOULD\)

---
### **7.3.  Transfer Coding Registry**

```text
   The "HTTP Transfer Coding Registry" defines the namespace for
   transfer coding names.  It is maintained at
   <https://www.iana.org/assignments/http-parameters>.
```

등록에는 다음 필드가 포함되어야 합니다.\(MUST\)

```text
   *  Name

   *  Description
```

\* 사양 텍스트에 대한 포인터

전송 코딩의 이름은 섹션 7.2에 정의된 압축 코딩의 경우처럼 인코딩 변환이 동일하지 않는 한 콘텐츠 코딩의 이름\(\[HTTP\]의 섹션 8.4.1\)과 겹쳐서는 안 됩니다.\(MUST NOT\)

TE 헤더 필드\(\[HTTP\]의 10.1.4절\)는 다중 전송 코딩이 허용되는 경우 순위 값으로 "q"라는 의사 매개변수를 사용합니다. 향후 전송 코딩 등록에서는 모호함을 피하기 위해 "q"\(대소문자 구분 안 함\)라는 매개변수를 정의해서는 안 됩니다.\(SHOULD NOT\)

이 네임스페이스에 추가되는 값은 IETF 검토\(\[RFC8126\]의 섹션 4.8 참조\)가 필요하며 본 사양에 정의된 전송 코딩의 목적을 준수해야 합니다.\(MUST\)

인코딩 형식을 식별하기 위해 프로그램 이름을 사용하는 것은 바람직하지 않으며 향후 인코딩에서는 권장되지 않습니다.

---
### **7.4.  Negotiating Transfer Codings**

TE 필드\(\[HTTP\]의 섹션 10.1.4\)는 HTTP/1.1에서 청크 외에 어떤 전송 코딩을 클라이언트가 응답에서 수락할지, 클라이언트가 청크에 트레일러 필드를 보존할지 여부를 나타내는 데 사용됩니다. 전송 코딩.

클라이언트는 TE로 청크된 전송 코딩 이름을 전송해서는 안 됩니다. 청크 분할은 HTTP/1.1 수신자에게 항상 허용됩니다.\(MUST NOT\)

TE 사용의 세 가지 예는 다음과 같습니다.

```text
   TE: deflate
   TE:
   TE: trailers, deflate;q=0.5
```

다중 전송 코딩이 허용되는 경우 클라이언트는 대소문자를 구분하지 않는 "q" 매개변수를 사용하여 선호도에 따라 코딩 순위를 매길 수 있습니다\(콘텐츠 협상 필드에 사용되는 q값과 유사, \[HTTP\]의 섹션 12.4.2 참조\). 순위 값은 0에서 1 사이의 실수입니다. 여기서 0.001은 가장 선호되지 않고 1은 가장 선호됩니다. 값 0은 "허용되지 않음"을 의미합니다.\(MAY\)

TE 필드 값이 비어 있거나 TE 필드가 없으면 허용되는 유일한 전송 코딩이 청크됩니다. 전송 코딩이 없는 메시지는 항상 허용됩니다.

키워드 "trailers"는 \[HTTP\]의 섹션 6.5에 설명된 대로 보낸 사람이 트레일러 필드를 삭제하지 않음을 나타냅니다.

TE 헤더 필드는 즉시 연결에만 적용되므로 TE의 송신자는 TE 헤더 필드가 연결되는 것을 방지하기 위해 Connection 헤더 필드\(\[HTTP\]의 7.6.1절\) 내에 "TE" 연결 옵션도 보내야 합니다. 의미론을 지원하지 않는 중개자에 의해 전달됩니다.\(MUST\)

---
## **8.  Handling Incomplete Messages**

일반적으로 취소된 요청이나 트리거된 시간 초과 예외로 인해 불완전한 요청 메시지를 수신한 서버는 연결을 닫기 전에 오류 응답을 보낼 수 있습니다.\(MAY\)

연결이 조기에 닫히거나 청크 전송 코딩 디코딩이 실패할 때 발생할 수 있는 불완전한 응답 메시지를 수신한 클라이언트는 메시지를 불완전한 것으로 기록해야 합니다. 불완전한 응답에 대한 캐시 요구 사항은 \[CACHING\]의 섹션 3.3에 정의되어 있습니다.\(MUST\)

응답이 헤더 섹션 중간\(빈 줄이 수신되기 전\)에서 종료되고 상태 코드가 응답의 전체 의미를 전달하기 위해 헤더 필드에 의존할 수 있는 경우 클라이언트는 의미가 전달되었다고 가정할 수 없습니다. 클라이언트는 다음에 수행할 작업을 결정하기 위해 요청을 반복해야 할 수도 있습니다.

인코딩을 종료하는 크기가 0인 청크가 수신되지 않은 경우 청크 분할 전송 코딩을 사용하는 메시지 본문은 불완전합니다. 수신된 메시지 본문의 크기\(옥텟 단위\)가 Content-Length에서 지정한 값보다 작은 경우 유효한 Content-Length를 사용하는 메시지는 불완전합니다. 청크 전송 코딩이나 Content-Length가 없는 응답은 연결 종료로 종료되며, 헤더 섹션이 그대로 수신된 경우 기본 연결에서 오류가 표시되지 않는 한\(예: "불완전한 닫기"\) 완료된 것으로 간주됩니다. TLS는 섹션 9.8에 설명된 대로 응답을 불완전하게 남겨 둡니다.

---
## **9.  Connection Management**

HTTP 메시징은 기본 전송 또는 세션 계층 연결 프로토콜과 독립적입니다. HTTP는 요청을 순차적으로 전달하고 응답을 순차적으로 전달하는 안정적인 전송만을 가정합니다. 기본 전송 프로토콜의 데이터 단위에 대한 HTTP 요청 및 응답 구조의 매핑은 이 사양의 범위를 벗어납니다.

\[HTTP\]의 섹션 7.3에 설명된 대로 HTTP 상호 작용에 사용되는 특정 연결 프로토콜은 클라이언트 구성 및 대상 URI에 의해 결정됩니다. 예를 들어 "http" URI 체계\(\[HTTP\]의 섹션 4.2.1\)는 기본 TCP 포트 80을 사용하는 IP를 통한 TCP의 기본 연결을 나타내지만 클라이언트는 다른 연결을 통해 프록시를 사용하도록 구성될 수 있습니다. , 포트 또는 프로토콜.

HTTP 구현은 현재 연결 상태 유지, 새 연결 설정 또는 기존 연결 재사용, 연결에서 수신된 메시지 처리, 연결 실패 감지 및 각 연결 닫기를 포함하는 연결 관리에 참여할 것으로 예상됩니다. 대부분의 클라이언트는 서버 끝점당 둘 이상의 연결을 포함하여 여러 연결을 병렬로 유지합니다. 대부분의 서버는 수천 개의 동시 연결을 유지하는 동시에 요청 대기열을 제어하여 공정한 사용을 활성화하고 서비스 거부 공격을 감지하도록 설계되었습니다.

---
### **9.1.  Establishment**

다양한 전송 또는 세션 계층 프로토콜을 통해 연결이 설정되는 방법을 설명하는 것은 이 사양의 범위를 벗어납니다. 각 HTTP 연결은 하나의 기본 전송 연결에 매핑됩니다.

---
### **9.2.  Associating a Response to a Request**

HTTP/1.1에는 주어진 요청 메시지를 해당하는 하나 이상의 응답 메시지와 연결하기 위한 요청 식별자가 포함되어 있지 않습니다. 따라서 동일한 연결에서 요청이 이루어진 순서와 정확히 일치하도록 응답 도착 순서에 의존합니다. 요청당 하나 이상의 응답 메시지는 하나 이상의 정보 응답\(1xx; \[HTTP\]의 섹션 15.2 참조\)이 동일한 요청에 대한 최종 응답 앞에 올 때만 발생합니다.

연결에 대해 하나 이상의 미해결 요청이 있는 클라이언트는 전송된 순서대로 미해결 요청 목록을 유지해야 하며 해당 연결에서 수신된 각 응답 메시지를 아직 최종\(비-1xx\)을 수신하지 않은 첫 번째 미해결 요청에 연결해야 합니다\(MUST\). 응답.\(MUST\)

클라이언트가 미해결 요청이 없는 연결에서 데이터를 수신하는 경우 클라이언트는 해당 데이터를 유효한 응답으로 간주해서는 안 됩니다. 데이터가 하나 이상의 CRLF\(섹션 2.2에 따라 폐기될 수 있음\)로만 구성되지 않는 한 메시지 구분이 이제 모호하므로 클라이언트는 연결을 닫아야 합니다.\(MUST NOT\)

---
### **9.3.  Persistence**

HTTP/1.1은 기본적으로 "영구 연결"을 사용하므로 단일 연결을 통해 여러 요청과 응답을 전달할 수 있습니다. HTTP 구현은 지속적인 연결을 지원해야 합니다\(SHOULD\).\(SHOULD\)

수신자는 가장 최근에 수신한 메시지의 프로토콜 버전과 연결 헤더 필드\(\[HTTP\]의 섹션 7.6.1\)를 기반으로 연결이 지속되는지 여부를 결정합니다.

\* "닫기" 연결 옵션이 있는 경우\(9.6절\) 현재 응답 후에 연결이 지속되지 않습니다. 또 다른,

\* 수신된 프로토콜이 HTTP/1.1\(또는 그 이상\)인 경우 현재 응답 후에도 연결이 유지됩니다. 또 다른,

\* 수신된 프로토콜이 HTTP/1.0이고 "연결 유지" 연결 옵션이 있는 경우 수신자가 프록시가 아니거나 메시지가 응답이고 수신자는 HTTP/1.0 "연결 유지"를 따르기를 원합니다. 메커니즘에서는 현재 응답 후에도 연결이 유지됩니다. 그렇지 않으면,

\* 현재 응답 후에 연결이 종료됩니다.

지속적인 연결을 지원하지 않는 클라이언트는 모든 요청 메시지에 "close" 연결 옵션을 보내야 합니다.\(MUST\)

지속적인 연결을 지원하지 않는 서버는 1xx\(정보\) 상태 코드가 없는 모든 응답 메시지에 "close" 연결 옵션을 보내야 합니다.\(MUST\)

클라이언트는 "닫기" 연결 옵션을 보내거나 받을 때까지 또는 "연결 유지" 연결 옵션 없이 HTTP/1.0 응답을 받을 때까지 지속적인 연결에 대한 추가 요청을 보낼 수 있습니다.\(MAY\)

지속성을 유지하려면 연결의 모든 메시지는 섹션 6에 설명된 대로 자체 정의된 메시지 길이\(즉, 연결 종료로 정의되지 않은 길이\)를 가져야 합니다. 서버는 전체 요청 메시지 본문을 읽거나 닫아야 합니다. 응답을 보낸 후 연결; 그렇지 않으면 영구 연결의 나머지 데이터가 다음 요청으로 잘못 해석될 수 있습니다. 마찬가지로 클라이언트는 후속 요청에 대해 동일한 연결을 재사용하려는 경우 전체 응답 메시지 본문을 읽어야 합니다.\(MUST, MUST\)

프록시 서버는 HTTP/1.0 클라이언트와의 지속적인 연결을 유지해서는 안 됩니다\(많은 HTTP/1.0 클라이언트가 구현하는 Keep-Alive 헤더 필드 문제에 대한 정보 및 논의는 부록 C.2.2 참조\).\(MUST NOT\)

HTTP/1.0 클라이언트와의 하위 호환성에 대한 자세한 내용은 부록 C.2.2를 참조하세요.

---
#### **9.3.1.  Retrying Requests**

의도 여부에 관계없이 언제든지 연결을 닫을 수 있습니다. 구현에서는 비동기 닫기 이벤트에서 복구해야 할 필요성을 예상해야 합니다. 클라이언트가 미해결 요청 시퀀스를 자동으로 재시도할 수 있는 조건은 \[HTTP\]의 섹션 9.2.2에 정의되어 있습니다.

---
#### **9.3.2.  Pipelining**

지속적인 연결을 지원하는 클라이언트는 요청을 "파이프라인"할 수 있습니다\(즉, 각 응답을 기다리지 않고 여러 요청을 보낼 수 있습니다\). 서버는 모두 안전한 메서드\(\[HTTP\]의 섹션 9.2.1\)를 가지고 있는 경우 일련의 파이프라인 요청을 병렬로 처리할 수 있지만 요청이 수신된 것과 동일한 순서로 해당 응답을 보내야 합니다.\(MAY, MUST\)

요청을 파이프라인으로 처리하는 클라이언트는 해당 응답을 모두 받기 전에 연결이 닫히면 응답되지 않은 요청을 재시도해야 합니다. 연결 실패\(마지막 완전한 응답에서 서버에 의해 명시적으로 닫히지 않은 연결\) 후 파이프라인 요청을 재시도할 때 클라이언트는 연결 설정 직후 파이프라인을 사용해서는 안 됩니다. 이전 파이프라인의 첫 번째 남은 요청이 다음과 같은 오류 응답을 발생시켰을 수 있기 때문입니다. 조기에 닫힌 연결에서 여러 요청이 전송되면 다시 손실될 수 있습니다\(섹션 9.6에 설명된 TCP 재설정 문제 참조\).\(SHOULD, MUST NOT\)

멱등성 메서드\(\[HTTP\]의 섹션 9.2.2\)는 연결 실패 후 자동으로 재시도할 수 있기 때문에 파이프라인에 중요합니다. 사용자 에이전트는 파이프라인 시퀀스와 관련된 부분 실패 조건을 감지하고 복구할 수 있는 수단이 없는 한, 해당 메서드에 대한 최종 응답 상태 코드가 수신될 때까지 비멱등 메서드 이후에 파이프라인 요청을 해서는 안 됩니다.\(SHOULD NOT\)

파이프라인 요청을 수신하는 중개자는 인바운드로 전달할 때 해당 요청을 파이프라인할 수 있습니다. 이는 어떤 요청이 안전하게 파이프라인될 수 있는지 결정하기 위해 아웃바운드 사용자 에이전트에 의존할 수 있기 때문입니다. 응답을 받기 전에 인바운드 연결이 실패하는 경우 파이프라이닝 중개자는 요청에 모두 멱등성 메서드가 있는 경우 아직 응답을 받지 못한 일련의 요청을 재시도할 수 있습니다. 그렇지 않은 경우 파이프라이닝 중개자는 수신된 모든 응답을 전달한 다음 아웃바운드 사용자 에이전트가 그에 따라 복구할 수 있도록 해당 아웃바운드 연결을 닫아야 합니다.\(MAY, SHOULD\)

---
### **9.4.  Concurrency**

클라이언트는 특정 서버에 대해 유지 관리하는 동시에 열려 있는 연결 수를 제한해야 합니다.

이전 HTTP 개정판에서는 특정 수의 연결을 한도로 제공했지만 이는 많은 애플리케이션에서 실용적이지 않은 것으로 나타났습니다. 결과적으로 이 사양은 특정 최대 연결 수를 요구하지 않지만 대신 클라이언트가 여러 연결을 열 때 보수적이 되도록 권장합니다.

다중 연결은 일반적으로 "헤드 오브 라인 차단" 문제를 피하기 위해 사용됩니다. 여기서 상당한 서버 측 처리가 필요하거나 매우 큰 콘텐츠를 전송하는 요청은 동일한 연결에서 후속 요청을 차단합니다. 그러나 각 연결은 서버 리소스를 소비합니다.

또한 여러 연결을 사용하면 혼잡한 네트워크에서 바람직하지 않은 부작용이 발생할 수 있습니다. 더 많은 수의 연결을 사용하면 혼잡하지 않은 네트워크에서 부작용이 발생할 수도 있습니다. 그 이유는 집계 및 초기 동기화된 전송 동작으로 인해 더 적은 수의 병렬 연결을 사용했다면 존재하지 않았을 혼잡이 발생할 수 있기 때문입니다.

서버는 단일 클라이언트에서 과도한 수의 열린 연결과 같이 악의적이거나 서비스 거부 공격의 특징으로 간주되는 트래픽을 거부할 수 있습니다.

---
### **9.5.  Failures and Timeouts**

서버에는 일반적으로 더 이상 비활성 연결을 유지하지 않는 시간 초과 값이 있습니다. 클라이언트가 동일한 프록시 서버를 통해 더 많은 연결을 만들 가능성이 높으므로 프록시 서버는 이 값을 더 높게 설정할 수 있습니다. 영구 연결을 사용하면 클라이언트나 서버에 대한 이 제한 시간의 길이\(또는 존재 여부\)에 대한 요구 사항이 없습니다.

시간 초과를 원하는 클라이언트나 서버는 연결을 정상적으로 종료해야 합니다. 구현에서는 수신된 종료 신호에 대해 열려 있는 연결을 지속적으로 모니터링하고 적절하게 응답해야 합니다. 연결 양쪽을 즉시 종료하면 할당된 시스템 리소스를 회수할 수 있기 때문입니다.\(SHOULD, SHOULD\)

클라이언트, 서버 또는 프록시는 언제든지 전송 연결을 닫을 수 있습니다. 예를 들어, 서버가 "유휴" 연결을 종료하기로 결정한 동시에 클라이언트가 새 요청을 보내기 시작했을 수 있습니다. 서버 입장에서는 유휴 상태에서 연결이 종료되고 있지만 클라이언트 입장에서는 요청이 진행 중인 상태입니다.\(MAY\)

서버는 가능한 경우 지속적인 연결을 유지해야 하며, 클라이언트가 재시도할 것으로 예상하여 연결을 종료하는 대신 기본 전송의 흐름 제어 메커니즘이 일시적인 과부하를 해결하도록 허용해야 합니다. 후자의 기술은 네트워크 정체나 서버 부하를 악화시킬 수 있습니다.\(SHOULD\)

메시지 본문을 보내는 클라이언트는 요청을 전송하는 동안 네트워크 연결에서 오류 응답을 모니터링해야 합니다. 서버가 메시지 본문 수신을 원하지 않고 연결을 닫고 있음을 나타내는 응답을 클라이언트가 본 경우 클라이언트는 즉시 본문 전송을 중단하고 연결 쪽을 닫아야 합니다.\(SHOULD, SHOULD\)

---
### **9.6.  Tear-down**

"닫기" 연결 옵션은 보낸 사람이 응답이 완료된 후 이 연결을 닫을 것이라는 신호로 정의됩니다. 발신자는 연결을 닫으려고 할 때 "close" 연결 옵션이 포함된 연결 헤더 필드\(\[HTTP\]의 섹션 7.6.1\)를 보내야 합니다\(SHOULD\). 예를 들어,\(SHOULD\)

```text
   Connection: close
```

요청 헤더 필드는 이것이 클라이언트가 이 연결에서 보낼 마지막 요청임을 나타내는 반면, 응답에서 동일한 필드는 응답 메시지가 완료된 후 서버가 이 연결을 닫을 것임을 나타냅니다.

필드 이름 "Close"는 예약되어 있습니다. 해당 이름을 헤더 필드로 사용하면 "close" 연결 옵션과 충돌할 수 있기 때문입니다.

"close" 연결 옵션을 전송하는 클라이언트는 해당 연결에 대한 추가 요청\("close"를 포함하는 요청 이후\)을 전송해서는 안 되며\(MUST\) 이 요청에 해당하는 최종 응답 메시지를 읽은 후에 연결을 닫아야 합니다\(MUST\).\(MUST NOT\)

"닫기" 연결 옵션을 수신한 서버는 "닫기" 연결 옵션이 포함된 요청에 대한 최종 응답을 보낸 후 연결 종료\(아래 참조\)를 시작해야 합니다. 서버는 해당 연결에 대한 최종 응답으로 "닫기" 연결 옵션을 보내야 합니다\(SHOULD\). 서버는 해당 연결에서 수신된 추가 요청을 처리해서는 안 됩니다.\(MUST, SHOULD, MUST NOT\)

"닫기" 연결 옵션을 보내는 서버는 "닫기" 연결 옵션이 포함된 응답을 보낸 후 연결 종료\(아래 참조\)를 시작해야 합니다. 서버는 해당 연결에서 수신된 추가 요청을 처리해서는 안 됩니다.\(MUST, MUST NOT\)

"닫기" 연결 옵션을 수신한 클라이언트는 해당 연결에 대한 요청 전송을 중단하고 "닫기" 연결 옵션이 포함된 응답 메시지를 읽은 후 연결을 닫아야 합니다. 추가 파이프라인 요청이 연결에서 전송된 경우 클라이언트는 해당 요청이 서버에 의해 처리될 것이라고 가정해서는 안 됩니다.\(MUST\)

서버가 TCP 연결을 즉시 닫는 경우 클라이언트가 마지막 HTTP 응답을 읽지 못할 위험이 있습니다. 서버가 완전히 닫힌 연결에서 클라이언트로부터 추가 데이터\(예: 서버의 응답을 받기 전에 클라이언트가 보낸 다른 요청\)를 받으면 서버의 TCP 스택은 클라이언트에 재설정 패킷을 보냅니다. 불행하게도 재설정 패킷은 클라이언트의 HTTP 구문 분석기가 읽고 해석하기 전에 클라이언트의 확인되지 않은 입력 버퍼를 지울 수 있습니다.

TCP 재설정 문제를 방지하기 위해 서버는 일반적으로 단계적으로 연결을 닫습니다. 먼저, 서버는 읽기/쓰기 연결의 쓰기 측만 닫아 절반 닫기를 수행합니다. 그런 다음 서버는 클라이언트가 해당 닫기를 수신할 때까지 또는 자체 TCP 스택이 서버의 마지막 응답이 포함된 패킷에 대한 클라이언트의 승인을 받았다고 서버가 합리적으로 확신할 때까지 연결에서 계속해서 읽습니다. 마지막으로 서버는 연결을 완전히 종료합니다.

재설정 문제가 TCP에만 국한된 것인지, 아니면 다른 전송 연결 프로토콜에서도 발견될 수 있는지는 알 수 없습니다.

클라이언트에 의해 절반 닫힌 TCP 연결은 요청 메시지를 구분하지 않으며 클라이언트가 더 이상 응답에 관심이 없다는 것을 의미하지도 않습니다. 일반적으로 HTTP/1.1은 전송과 독립적이므로 전송 신호는 신호 엣지 케이스에 의존할 수 없습니다.

---
### **9.7.  TLS Connection Initiation**

개념적으로 HTTP/TLS는 단순히 TLS\[TLS13\]를 통해 보안된 연결을 통해 HTTP 메시지를 보내는 것입니다.

HTTP 클라이언트는 TLS 클라이언트 역할도 합니다. 적절한 포트에서 서버에 대한 연결을 시작하고 TLS ClientHello를 보내 TLS 핸드셰이크를 시작합니다. TLS 핸드셰이크가 완료되면 클라이언트는 첫 번째 HTTP 요청을 시작할 수 있습니다. 모든 HTTP 데이터는 반드시 TLS "애플리케이션 데이터"로 전송되어야 하지만 그렇지 않으면 HTTP에 대한 일반 연결처럼 처리됩니다\(영구 연결로 재사용 가능 포함\).\(MUST\)

---
### **9.8.  TLS Connection Closure**

TLS는 \(오류가 아닌\) 연결 종료 이전에 종료 경고 교환을 사용하여 안전한 연결 종료를 제공합니다. \[TLS13\]의 섹션 6.1을 참조하세요. 유효한 종료 경고가 수신되면 해당 연결에서 더 이상 데이터가 수신되지 않는다는 구현을 보장할 수 있습니다.

구현이 일반적으로 HTTP 메시지 경계를 감지하여 관심 있는 모든 메시지 데이터를 전송하거나 수신했음을 알면 폐쇄 경고를 보낸 다음 해당 메시지 수신을 기다리지 않고 연결을 닫아 "불완전한 닫기"를 생성할 수 있습니다. 피어로부터의 폐쇄 경고.

불완전한 종료는 이미 수신된 데이터의 보안에 의문을 제기하지 않지만 후속 데이터가 잘렸을 수 있음을 나타낼 수 있습니다. TLS는 HTTP 메시지 프레이밍을 직접 인식하지 못하므로 메시지가 완전한지 확인하려면 HTTP 데이터 자체를 검사해야 합니다. 불완전한 메시지 처리는 섹션 8에 정의되어 있습니다.

불완전한 종료가 발생하면 클라이언트는 다음 중 하나를 수신한 모든 요청을 완료된 것으로 처리해야 합니다.\(SHOULD\)

1. Content-Length 헤더 필드에 지정된 만큼의 데이터 또는

2. 터미널 길이가 0인 청크\(청크의 Transfer-Encoding이 사용되는 경우\).

청크 전송 코딩이나 Content-Length가 없는 응답은 유효한 종료 경고가 수신된 경우에만 완료됩니다. 불완전한 메시지를 완전한 것으로 처리하면 구현이 공격에 노출될 수 있습니다.

불완전한 종료를 감지한 클라이언트는 정상적으로 복구해야 합니다.\(SHOULD\)

클라이언트는 연결을 닫기 전에 종료 경고를 보내야 합니다. 더 이상 데이터를 수신할 것으로 예상하지 않는 클라이언트는 서버의 종료 경고를 기다리지 않고 단순히 연결을 닫는 것을 선택하여 서버 측에서 불완전한 종료를 생성할 수 있습니다.\(MUST, MAY\)

클라이언트는 종종 서버 데이터의 끝을 찾을 수 있으므로 서버는 클라이언트로부터 불완전한 종료를 수신할 준비를 해야 합니다.\(SHOULD\)

서버는 연결을 닫기 전에 클라이언트와 종료 경고 교환을 시작하려고 시도해야 합니다. 서버는 종료 경고를 보낸 후 연결을 닫을 수 있으므로 클라이언트 측에서 불완전한 종료가 생성됩니다.\(MUST, MAY\)

---
## **10.  Enclosing Messages as Data**
---
### **10.1.  Media Type message/http**

"message/http" 미디어 유형은 줄 길이 및 인코딩과 관련하여 모든 "메시지" 유형에 대한 MIME 제한 사항을 준수하는 경우 단일 HTTP 요청 또는 응답 메시지를 포함하는 데 사용할 수 있습니다. 줄 길이 제한으로 인해 "message/http" 내의 필드 값은 섹션 5.2에 설명된 대로 줄 접기\(obs-fold\)를 사용하여 여러 줄에 걸쳐 필드 값을 전달할 수 있습니다. "message/http" 데이터 수신자는 메시지가 소비될 때 사용되지 않는 줄 접기를 하나 이상의 SP 문자로 바꿔야 합니다.\(MUST\)

```text
   Type name:  message

   Subtype name:  http

   Required parameters:  N/A

   Optional parameters:  version, msgtype
```

- 버전: 포함된 메시지의 HTTP 버전 번호\(예: "1.1"\)입니다. 버전이 없으면 본문의 첫 번째 줄에서 버전을 확인할 수 있습니다.

- msgtype: 메시지 유형 - "요청" 또는 "응답". 존재하지 않는 경우, 본문의 첫 번째 줄에서 유형을 판별할 수 있습니다.

인코딩 고려 사항: "7bit", "8bit" 또는 "binary"만 허용됩니다.

```text
   Security considerations:  see Section 11

   Interoperability considerations:  N/A

   Published specification:  RFC 9112 (see Section 10.1).
```

이 미디어 유형을 사용하는 애플리케이션: 해당 없음

```text
   Fragment identifier considerations:  N/A

   Additional information:  Magic number(s):  N/A

                            Deprecated alias names for this type:  N/A

                            File extension(s):  N/A

                            Macintosh file type code(s):  N/A
```

자세한 내용은 연락할 사람 및 이메일 주소: 작성자의 주소 섹션을 참조하세요.

```text
   Intended usage:  COMMON
```

사용 제한: 해당 없음

```text
   Author:  See Authors' Addresses section.

   Change controller:  IESG
```

---
### **10.2.  Media Type application/http**

"application/http" 미디어 유형은 하나 이상의 HTTP 요청 또는 응답 메시지\(혼합되지 않음\)의 파이프라인을 묶는 데 사용될 수 있습니다.

```text
   Type name:  application

   Subtype name:  http

   Required parameters:  N/A

   Optional parameters:  version, msgtype
```

- 버전: 포함된 메시지의 HTTP 버전 번호\(예: "1.1"\)입니다. 버전이 없으면 본문의 첫 번째 줄에서 버전을 확인할 수 있습니다.

- msgtype: 메시지 유형 - "요청" 또는 "응답". 존재하지 않는 경우, 본문의 첫 번째 줄에서 유형을 판별할 수 있습니다.

인코딩 고려사항: 이 유형으로 묶인 HTTP 메시지는 "바이너리" 형식입니다. 이메일을 통해 전송할 때는 적절한 콘텐츠 전송 인코딩을 사용해야 합니다.

```text
   Security considerations:  see Section 11

   Interoperability considerations:  N/A

   Published specification:  RFC 9112 (see Section 10.2).
```

이 미디어 유형을 사용하는 애플리케이션: 해당 없음

```text
   Fragment identifier considerations:  N/A
```

추가 정보: 이 유형에 대해 더 이상 사용되지 않는 별칭 이름: 해당 없음

```text
                            Magic number(s):  N/A

                            File extension(s):  N/A

                            Macintosh file type code(s):  N/A
```

자세한 내용은 연락할 사람 및 이메일 주소: 작성자의 주소 섹션을 참조하세요.

```text
   Intended usage:  COMMON
```

사용 제한: 해당 없음

```text
   Author:  See Authors' Addresses section.

   Change controller:  IESG
```

---
## **11.  Security Considerations**

이 섹션은 개발자, 정보 제공자 및 사용자에게 HTTP 메시지 구문 및 구문 분석과 관련된 알려진 보안 고려 사항을 알리기 위한 것입니다. HTTP 의미론, 콘텐츠 및 라우팅에 대한 보안 고려사항은 \[HTTP\]에서 다루어집니다.

---
### **11.1.  Response Splitting**

응답 분할\(일명 CRLF 주입\)은 웹 사용에 대한 다양한 공격에 사용되는 일반적인 기술로, HTTP 메시지 프레이밍의 라인 기반 특성과 지속적인 연결에 대한 응답에 대한 요청의 정렬된 연결을 활용합니다\[Klein\]. 이 기술은 요청이 공유 캐시를 통과할 때 특히 해로울 수 있습니다.

응답 분할은 공격자가 나중에 디코딩되어 응답의 응답 헤더 필드 내에서 에코되는 요청의 일부 매개변수 내에서 인코딩된 데이터를 보낼 수 있는 서버\(일반적으로 애플리케이션 서버 내\)의 취약점을 악용합니다. 디코딩된 데이터가 응답이 종료되고 후속 응답이 시작된 것처럼 보이도록 조작된 경우 응답은 분할되었으며 명백한 두 번째 응답 내의 콘텐츠는 공격자에 의해 제어됩니다. 그런 다음 공격자는 동일한 영구 연결에 대해 다른 요청을 수행하고 수신자\(중개자 포함\)를 속여 분할의 두 번째 절반이 두 번째 요청에 대한 신뢰할 수 있는 응답이라고 믿도록 할 수 있습니다.

예를 들어, 요청 대상 내의 매개변수는 애플리케이션 서버에서 읽고 리디렉션 내에서 재사용될 수 있으며, 결과적으로 동일한 매개변수가 응답의 Location 헤더 필드에 에코됩니다. 매개 변수가 응용 프로그램에 의해 디코딩되고 응답 필드에 배치될 때 제대로 인코딩되지 않은 경우 공격자는 응용 프로그램의 단일 응답을 두 개 이상의 응답처럼 보이게 만드는 인코딩된 CRLF 옥텟 및 기타 콘텐츠를 보낼 수 있습니다.

응답 분할에 대한 일반적인 방어 방법은 인코딩된 CR 및 LF\(예: "%0D" 및 "%0A"\)처럼 보이는 데이터에 대한 요청을 필터링하는 것입니다. 그러나 이는 애플리케이션 서버가 문자 세트 트랜스코딩, XML 엔터티 변환, base64 디코딩, sprintf 재포맷 등과 같은 보다 모호한 데이터 변환이 아닌 URI 디코딩만 수행한다고 가정합니다. 더 효과적인 완화 방법은 서버의 핵심 프로토콜 라이브러리 이외의 다른 작업이 수행되지 않도록 방지하는 것입니다. 헤더 섹션 내에서 CR 또는 LF를 보냅니다. 이는 헤더 필드의 출력을 잘못된 옥텟을 필터링하는 API로 제한하고 애플리케이션 서버가 프로토콜 스트림에 직접 쓰는 것을 허용하지 않음을 의미합니다.

---
### **11.2.  Request Smuggling**

요청 밀수\(\[Linhart\]\)는 명백히 무해한 요청 내에서 추가 요청\(정책에 의해 차단되거나 비활성화될 수 있음\)을 숨기기 위해 다양한 수신자 간의 프로토콜 구문 분석의 차이를 이용하는 기술입니다. 응답 분할과 마찬가지로 요청 밀수는 HTTP 사용에 대한 다양한 공격으로 이어질 수 있습니다.

이 사양에서는 요청 구문 분석, 특히 섹션 6.3의 메시지 프레이밍과 관련하여 요청 밀수의 효율성을 줄이기 위해 새로운 요구 사항을 도입했습니다.

---
### **11.3.  Message Integrity**

HTTP는 메시지 무결성을 보장하기 위한 특정 메커니즘을 정의하지 않고, 대신 기본 전송 프로토콜의 오류 감지 기능과 길이 또는 청크로 구분된 프레이밍을 사용하여 완전성을 감지합니다. 역사적으로 단일 무결성 메커니즘의 부족은 대부분의 HTTP 통신의 비공식적 특성으로 인해 정당화되었습니다. 그러나 정보 액세스 메커니즘으로 HTTP가 널리 보급됨에 따라 메시지 무결성 확인이 중요한 환경에서 HTTP의 사용이 증가했습니다.

인증된 암호화와 같이 "https" 구성표와 함께 제공되는 메커니즘은 메시지 수정으로부터 보호합니다. 그러나 메시지를 자르는 데 연결 폐쇄를 사용할 수 없도록 주의가 필요합니다\(섹션 9.8 참조\). 사용자 에이전트는 불완전한 메시지 수락을 거부하거나 특별하게 처리할 수 있습니다. 예를 들어, 의료 기록이나 약물 상호 작용 정보를 보는 데 사용되는 브라우저는 전송 중에 해당 정보가 프로토콜에 의해 불완전하거나 만료되거나 손상된 것으로 감지되는 경우 사용자에게 이를 알려야 합니다. 이러한 메커니즘은 사용자 에이전트 확장이나 응답에 있는 메시지 무결성 메타데이터의 존재를 통해 선택적으로 활성화될 수 있습니다.

"http" 구성표는 우발적이거나 악의적인 메시지 수정에 대한 보호 기능을 제공하지 않습니다.

"https" 구성표가 사용되는 경우에도 중개자가 원치 않는 메시지 수정 위험을 완화하기 위해 프로토콜 확장을 사용할 수 있습니다. 확장 가능한 메타데이터 필드를 통해 메시지에 선택적으로 추가되는 메시지 인증 코드 또는 디지털 서명을 사용하여 무결성을 보장할 수 있습니다.

---
### **11.4.  Message Confidentiality**

HTTP는 원할 때 메시지 기밀성을 제공하기 위해 기본 전송 프로토콜을 사용합니다. HTTP는 전송 프로토콜과 독립적으로 특별히 설계되어 다양한 형태의 암호화된 연결을 통해 사용할 수 있으며 이러한 전송 선택은 URI 체계 선택이나 사용자 에이전트 구성 내에서 식별됩니다.

"https" 체계는 \[HTTP\]의 섹션 4.2.2에 설명된 대로 기밀 연결이 필요한 리소스를 식별하는 데 사용할 수 있습니다.

---
## **12.  IANA Considerations**

다음 등록에 대한 변경 컨트롤러는 "IETF\(iesg@ietf.org\) - Internet Engineering Task Force"입니다.

---
### **12.1.  Field Name Registration**

IANA는 \[HTTP\]의 섹션 18.4에 설명된 대로 <https://www.iana.org/locationments/http-fields\>의 "Hypertext Transfer Protocol\(HTTP\) 필드 이름 레지스트리"에 다음 필드 이름을 추가했습니다.

```text
   +===================+===========+=========+============+
   | Field Name        | Status    | Section | Comments   |
   +===================+===========+=========+============+
   | Close             | permanent | 9.6     | (reserved) |
   +-------------------+-----------+---------+------------+
   | MIME-Version      | permanent | B.1     |            |
   +-------------------+-----------+---------+------------+
   | Transfer-Encoding | permanent | 6.1     |            |
   +-------------------+-----------+---------+------------+

                           Table 1
```

---
### **12.2.  Media Type Registration**

IANA는 미디어 유형 "message/http" 및 "application/http"에 대한 섹션 10.1 및 10.2의 등록 정보로 <https://www.iana.org/locationments/media-types\>의 "미디어 유형" 레지스트리를 업데이트했습니다. ", 각각.

---
### **12.3.  Transfer Coding Registration**

IANA는 섹션 7.3의 등록 절차와 아래 표에 요약된 콘텐츠 코딩 이름을 사용하여 <https://www.iana.org/locationments/http-parameters/\>에서 "HTTP 전송 코딩 레지스트리"를 업데이트했습니다.

```text
   +============+===========================================+=========+
   | Name       | Description                               | Section |
   +============+===========================================+=========+
   | chunked    | Transfer in a series of chunks            | 7.1     |
   +------------+-------------------------------------------+---------+
   | compress   | UNIX "compress" data format [Welch]       | 7.2     |
   +------------+-------------------------------------------+---------+
   | deflate    | "deflate" compressed data ([RFC1951])     | 7.2     |
   |            | inside the "zlib" data format ([RFC1950]) |         |
   +------------+-------------------------------------------+---------+
   | gzip       | GZIP file format [RFC1952]                | 7.2     |
   +------------+-------------------------------------------+---------+
   | trailers   | (reserved)                                | 12.3    |
   +------------+-------------------------------------------+---------+
   | x-compress | Deprecated (alias for compress)           | 7.2     |
   +------------+-------------------------------------------+---------+
   | x-gzip     | Deprecated (alias for gzip)               | 7.2     |
   +------------+-------------------------------------------+---------+

                                 Table 2
```

- | \*참고:\* 코딩 이름 "trailers"는 | TE 헤더의 키워드 "트레일러"와 충돌합니다 | 필드\(\[HTTP\]의 섹션 10.1.4\).

---
### **12.4.  ALPN Protocol ID Registration**

IANA는 <https://www.iana.org/locationments/tls-extensiontype-values/\>에서 "TLS 애플리케이션 계층 프로토콜 협상\(ALPN\) 프로토콜 ID" 레지스트리를 아래 등록으로 업데이트했습니다.

```text
          +==========+=============================+===========+
          | Protocol | Identification Sequence     | Reference |
          +==========+=============================+===========+
          | HTTP/1.1 | 0x68 0x74 0x74 0x70 0x2f    | RFC 9112  |
          |          | 0x31 0x2e 0x31 ("http/1.1") |           |
          +----------+-----------------------------+-----------+

                                 Table 3
```

---
## **13.  References**
---
### **13.1.  Normative References**

```text
   [CACHING]  Fielding, R., Ed., Nottingham, M., Ed., and J. Reschke,
              Ed., "HTTP Caching", STD 98, RFC 9111,
              DOI 10.17487/RFC9111, June 2022,
              <https://www.rfc-editor.org/info/rfc9111>.

   [HTTP]     Fielding, R., Ed., Nottingham, M., Ed., and J. Reschke,
              Ed., "HTTP Semantics", STD 97, RFC 9110,
              DOI 10.17487/RFC9110, June 2022,
              <https://www.rfc-editor.org/info/rfc9110>.

   [RFC1950]  Deutsch, P. and J-L. Gailly, "ZLIB Compressed Data Format
              Specification version 3.3", RFC 1950,
              DOI 10.17487/RFC1950, May 1996,
              <https://www.rfc-editor.org/info/rfc1950>.

   [RFC1951]  Deutsch, P., "DEFLATE Compressed Data Format Specification
              version 1.3", RFC 1951, DOI 10.17487/RFC1951, May 1996,
              <https://www.rfc-editor.org/info/rfc1951>.

   [RFC1952]  Deutsch, P., "GZIP file format specification version 4.3",
              RFC 1952, DOI 10.17487/RFC1952, May 1996,
              <https://www.rfc-editor.org/info/rfc1952>.

   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", BCP 14, RFC 2119,
              DOI 10.17487/RFC2119, March 1997,
              <https://www.rfc-editor.org/info/rfc2119>.

   [RFC5234]  Crocker, D., Ed. and P. Overell, "Augmented BNF for Syntax
              Specifications: ABNF", STD 68, RFC 5234,
              DOI 10.17487/RFC5234, January 2008,
              <https://www.rfc-editor.org/info/rfc5234>.

   [RFC7405]  Kyzivat, P., "Case-Sensitive String Support in ABNF",
              RFC 7405, DOI 10.17487/RFC7405, December 2014,
              <https://www.rfc-editor.org/info/rfc7405>.

   [RFC8174]  Leiba, B., "Ambiguity of Uppercase vs Lowercase in RFC
              2119 Key Words", BCP 14, RFC 8174, DOI 10.17487/RFC8174,
              May 2017, <https://www.rfc-editor.org/info/rfc8174>.

   [TLS13]    Rescorla, E., "The Transport Layer Security (TLS) Protocol
              Version 1.3", RFC 8446, DOI 10.17487/RFC8446, August 2018,
              <https://www.rfc-editor.org/info/rfc8446>.

   [URI]      Berners-Lee, T., Fielding, R., and L. Masinter, "Uniform
              Resource Identifier (URI): Generic Syntax", STD 66,
              RFC 3986, DOI 10.17487/RFC3986, January 2005,
              <https://www.rfc-editor.org/info/rfc3986>.
```

\[USASCII\] 미국 국립 표준 협회\(American National Standards Institute\), "코드화된 문자 집합 - 정보 교환을 위한 7비트 미국 표준 코드", ANSI X3.4, 1986.

```text
   [Welch]    Welch, T., "A Technique for High-Performance Data
              Compression", IEEE Computer 17(6),
              DOI 10.1109/MC.1984.1659158, June 1984,
              <https://ieeexplore.ieee.org/document/1659158/>.
```

---
### **13.2.  Informative References**

```text
   [HTTP/1.0] Berners-Lee, T., Fielding, R., and H. Frystyk, "Hypertext
              Transfer Protocol -- HTTP/1.0", RFC 1945,
              DOI 10.17487/RFC1945, May 1996,
              <https://www.rfc-editor.org/info/rfc1945>.

   [Klein]    Klein, A., "Divide and Conquer - HTTP Response Splitting,
              Web Cache Poisoning Attacks, and Related Topics", March
              2004, <https://packetstormsecurity.com/papers/general/
              whitepaper_httpresponse.pdf>.

   [Linhart]  Linhart, C., Klein, A., Heled, R., and S. Orrin, "HTTP
              Request Smuggling", June 2005,
              <https://www.cgisecurity.com/lib/HTTP-Request-
              Smuggling.pdf>.

   [RFC2045]  Freed, N. and N. Borenstein, "Multipurpose Internet Mail
              Extensions (MIME) Part One: Format of Internet Message
              Bodies", RFC 2045, DOI 10.17487/RFC2045, November 1996,
              <https://www.rfc-editor.org/info/rfc2045>.

   [RFC2046]  Freed, N. and N. Borenstein, "Multipurpose Internet Mail
              Extensions (MIME) Part Two: Media Types", RFC 2046,
              DOI 10.17487/RFC2046, November 1996,
              <https://www.rfc-editor.org/info/rfc2046>.

   [RFC2049]  Freed, N. and N. Borenstein, "Multipurpose Internet Mail
              Extensions (MIME) Part Five: Conformance Criteria and
              Examples", RFC 2049, DOI 10.17487/RFC2049, November 1996,
              <https://www.rfc-editor.org/info/rfc2049>.

   [RFC2068]  Fielding, R., Gettys, J., Mogul, J., Frystyk, H., and T.
              Berners-Lee, "Hypertext Transfer Protocol -- HTTP/1.1",
              RFC 2068, DOI 10.17487/RFC2068, January 1997,
              <https://www.rfc-editor.org/info/rfc2068>.

   [RFC2557]  Palme, J., Hopmann, A., and N. Shelness, "MIME
              Encapsulation of Aggregate Documents, such as HTML
              (MHTML)", RFC 2557, DOI 10.17487/RFC2557, March 1999,
              <https://www.rfc-editor.org/info/rfc2557>.

   [RFC5322]  Resnick, P., Ed., "Internet Message Format", RFC 5322,
              DOI 10.17487/RFC5322, October 2008,
              <https://www.rfc-editor.org/info/rfc5322>.

   [RFC7230]  Fielding, R., Ed. and J. Reschke, Ed., "Hypertext Transfer
              Protocol (HTTP/1.1): Message Syntax and Routing",
              RFC 7230, DOI 10.17487/RFC7230, June 2014,
              <https://www.rfc-editor.org/info/rfc7230>.

   [RFC8126]  Cotton, M., Leiba, B., and T. Narten, "Guidelines for
              Writing an IANA Considerations Section in RFCs", BCP 26,
              RFC 8126, DOI 10.17487/RFC8126, June 2017,
              <https://www.rfc-editor.org/info/rfc8126>.
```

---
# **Appendix A.  Collected ABNF**

아래 수집된 ABNF에서는 \[HTTP\]의 섹션 5.6.1에 따라 목록 규칙이 확장됩니다.

```text
   BWS = <BWS, see [HTTP], Section 5.6.3>

   HTTP-message = start-line CRLF *( field-line CRLF ) CRLF [
    message-body ]
   HTTP-name = %x48.54.54.50 ; HTTP
   HTTP-version = HTTP-name "/" DIGIT "." DIGIT

   OWS = <OWS, see [HTTP], Section 5.6.3>

   RWS = <RWS, see [HTTP], Section 5.6.3>

   Transfer-Encoding = [ transfer-coding *( OWS "," OWS transfer-coding
    ) ]

   absolute-URI = <absolute-URI, see [URI], Section 4.3>
   absolute-form = absolute-URI
   absolute-path = <absolute-path, see [HTTP], Section 4.1>
   asterisk-form = "*"
   authority = <authority, see [URI], Section 3.2>
   authority-form = uri-host ":" port

   chunk = chunk-size [ chunk-ext ] CRLF chunk-data CRLF
   chunk-data = 1*OCTET
   chunk-ext = *( BWS ";" BWS chunk-ext-name [ BWS "=" BWS chunk-ext-val
    ] )
   chunk-ext-name = token
   chunk-ext-val = token / quoted-string
   chunk-size = 1*HEXDIG
   chunked-body = *chunk last-chunk trailer-section CRLF

   field-line = field-name ":" OWS field-value OWS
   field-name = <field-name, see [HTTP], Section 5.1>
   field-value = <field-value, see [HTTP], Section 5.5>

   last-chunk = 1*"0" [ chunk-ext ] CRLF

   message-body = *OCTET
   method = token

   obs-fold = OWS CRLF RWS
   obs-text = <obs-text, see [HTTP], Section 5.6.4>
   origin-form = absolute-path [ "?" query ]

   port = <port, see [URI], Section 3.2.3>

   query = <query, see [URI], Section 3.4>
   quoted-string = <quoted-string, see [HTTP], Section 5.6.4>

   reason-phrase = 1*( HTAB / SP / VCHAR / obs-text )
   request-line = method SP request-target SP HTTP-version
   request-target = origin-form / absolute-form / authority-form /
    asterisk-form

   start-line = request-line / status-line
   status-code = 3DIGIT
   status-line = HTTP-version SP status-code SP [ reason-phrase ]

   token = <token, see [HTTP], Section 5.6.2>
   trailer-section = *( field-line CRLF )
   transfer-coding = <transfer-coding, see [HTTP], Section 10.1.4>

   uri-host = <host, see [URI], Section 3.2.2>
```

---
# **Appendix B.  Differences between HTTP and MIME**

HTTP/1.1은 인터넷 메시지 형식\[RFC5322\] 및 다목적 인터넷 메일 확장\(MIME\) \[RFC2045\]에 대해 정의된 많은 구성을 사용하여 메시지 본문이 개방형 다양한 표현과 확장 가능한 필드로 전송될 수 있도록 합니다. 그러나 이러한 구성 중 일부는 대화형 통신의 요구에 더 잘 맞도록 재해석되어 HTTP 내에서 MIME 구성이 사용되는 방식에 약간의 차이가 있습니다. 이러한 차이점은 바이너리 연결에 대한 성능을 최적화하고, 새로운 미디어 유형을 더 자유롭게 사용할 수 있도록 하며, 날짜 비교를 용이하게 하고, 일반적인 구현을 수용하기 위해 신중하게 선택되었습니다.

이 부록에서는 HTTP가 MIME과 다른 특정 영역을 설명합니다. 엄격한 MIME 환경을 오가는 프록시와 게이트웨이는 이러한 차이점을 인식하고 필요한 경우 적절한 변환을 제공해야 합니다.

---
### **B.1.  MIME-Version**

HTTP는 MIME 호환 프로토콜이 아닙니다. 그러나 메시지에는 메시지를 구성하는 데 사용된 MIME 프로토콜 버전을 나타내는 단일 MIME-Version 헤더 필드가 포함될 수 있습니다. MIME-Version 헤더 필드의 사용은 메시지가 MIME 프로토콜\(\[RFC2045\]에 정의된 대로\)을 완전히 준수함을 나타냅니다. 발신자는 HTTP 메시지를 엄격한 MIME 환경으로 내보낼 때 \(가능한 경우\) 완전한 적합성을 보장할 책임이 있습니다.

---
### **B.2.  Conversion to Canonical Form**

MIME에서는 \[RFC2049\]의 섹션 4에 설명된 대로 인터넷 메일 본문 부분을 전송하기 전에 표준 형식으로 변환해야 하며 "텍스트" 유형의 콘텐츠는 CRLF로 줄 바꿈을 나타내어 CR 또는 CR 사용을 금지합니다. 줄 바꿈 시퀀스 외부의 LF \[RFC2046\]. 대조적으로, HTTP는 콘텐츠 내의 줄 바꿈을 표시하기 위해 CRLF, 베어 CR 또는 베어 LF가 사용되는지 여부를 신경 쓰지 않습니다.

HTTP에서 엄격한 MIME 환경으로의 프록시 또는 게이트웨이는 텍스트 미디어 유형 내의 모든 줄 바꿈을 RFC 2049 표준 형식의 CRLF로 변환해야 합니다. 그러나 이는 Content-Encoding의 존재와 HTTP가 CR 및 LF를 각각 나타내기 위해 옥텟 13 및 10을 사용하지 않는 일부 문자 세트의 사용을 허용한다는 사실로 인해 복잡해질 수 있습니다.

원본 콘텐츠가 이미 정식 형식인 경우를 제외하고 변환하면 원본 콘텐츠에 적용된 모든 암호화 체크섬이 중단됩니다. 따라서 HTTP에서 이러한 체크섬을 사용하는 모든 콘텐츠에는 표준 형식을 사용하는 것이 좋습니다.

---
### **B.3.  Conversion of Date Formats**

HTTP/1.1은 제한된 날짜 형식 세트\(\[HTTP\]의 섹션 5.6.7\)를 사용하여 날짜 비교 프로세스를 단순화합니다. 다른 프로토콜의 프록시와 게이트웨이는 메시지에 있는 모든 Date 헤더 필드가 HTTP/1.1 형식 중 하나를 준수하는지 확인하고 필요한 경우 날짜를 다시 작성해야 합니다.

---
### **B.4.  Conversion of Content-Encoding**

MIME에는 HTTP의 Content-Encoding 헤더 필드와 동일한 개념이 포함되어 있지 않습니다. 이는 미디어 유형에 대한 수정자 역할을 하기 때문에 HTTP에서 MIME 호환 프로토콜로의 프록시 및 게이트웨이는 메시지를 전달하기 전에 Content-Type 헤더 필드의 값을 변경하거나 표현을 디코딩해야 합니다. \(인터넷 메일에 대한 Content-Type의 일부 실험적 응용 프로그램에서는 Content-Encoding과 동등한 기능을 수행하기 위해 ";conversions=<content-coding\>"이라는 media-type 매개 변수를 사용했습니다. 그러나 이 매개 변수는 MIME 표준의 일부가 아닙니다. .\)

---
### **B.5.  Conversion of Content-Transfer-Encoding**

HTTP는 MIME의 Content-Transfer-Encoding 필드를 사용하지 않습니다. MIME 호환 프로토콜에서 HTTP로의 프록시 및 게이트웨이는 응답 메시지를 HTTP 클라이언트에 전달하기 전에 모든 콘텐츠 전송 인코딩을 제거해야 합니다.

HTTP에서 MIME 호환 프로토콜까지의 프록시와 게이트웨이는 메시지가 해당 프로토콜의 안전한 전송을 위해 올바른 형식과 인코딩으로 되어 있는지 확인하는 일을 담당합니다. 여기서 "안전한 전송"은 사용 중인 프로토콜의 제한 사항에 따라 정의됩니다. 이러한 프록시 또는 게이트웨이는 대상 프로토콜을 통한 안전한 전송 가능성을 높이는 경우 적절한 콘텐츠 전송 인코딩으로 데이터를 변환하고 레이블을 지정해야 합니다.

---
### **B.6.  MHTML and Line Length Limitations**

MHTML \[RFC2557\] 구현과 코드를 공유하는 HTTP 구현은 MIME 줄 길이 제한을 인식해야 합니다. HTTP에는 이러한 제한이 없으므로 HTTP는 긴 줄을 접지 않습니다. HTTP에 의해 전송되는 MHTML 메시지는 줄 길이 제한, 접기, 정규화 등을 포함하여 MHTML의 모든 규칙을 따릅니다. HTTP는 "multipart/byteranges" 유형을 제외하고 수정 없이 메시지 본문을 전송하기 때문입니다\(\[HTTP\]의 섹션 14.6\). \)은 콘텐츠나 콘텐츠에 포함될 수 있는 MIME 헤더 줄을 해석하지 않습니다.

---
# **Appendix C.  Changes from Previous RFCs**
---
### **C.1.  Changes from HTTP/0.9**

HTTP/0.9는 요청의 헤더 필드를 지원하지 않았기 때문에 이름 기반 가상 호스트\(호스트 헤더 필드를 검사하여 리소스 선택\)를 지원하는 메커니즘이 없습니다. 이름 기반 가상 호스트를 구현하는 모든 서버는 HTTP/0.9에 대한 지원을 비활성화해야 합니다. HTTP/0.9로 보이는 대부분의 요청은 실제로 클라이언트가 요청 대상을 적절하게 인코딩하지 못하여 잘못 구성된 HTTP/1.x 요청입니다.

---
### **C.2.  Changes from HTTP/1.0**
---
#### **C.2.1.  Multihomed Web Servers**

클라이언트와 서버가 Host 헤더 필드\(\[HTTP\]의 섹션 7.2\)를 지원하고, HTTP/1.1 요청에서 누락된 경우 오류를 보고하고, 절대 URI를 허용해야 하는 요구 사항\(섹션 3.2\)은 다음에 의해 정의된 가장 중요한 변경 사항 중 하나입니다. HTTP/1.1.

이전 HTTP/1.0 클라이언트는 IP 주소와 서버의 일대일 관계를 가정했습니다. 해당 요청이 전달된 IP 주소 외에 요청의 의도된 서버를 구별하기 위한 확립된 메커니즘이 없었습니다. Host 헤더 필드는 HTTP/1.1 개발 중에 도입되었으며 대부분의 HTTP/1.0 브라우저에서 신속하게 구현되었지만 완전한 채택을 보장하기 위해 모든 HTTP/1.1 요청에 추가 요구 사항이 적용되었습니다. 이 글을 쓰는 시점에서 대부분의 HTTP 기반 서비스는 요청 대상 지정을 위해 Host 헤더 필드에 의존합니다.

---
#### **C.2.2.  Keep-Alive Connections**

HTTP/1.0에서 각 연결은 요청 전에 클라이언트에 의해 설정되고 응답을 보낸 후 서버에 의해 닫힙니다. 그러나 일부 구현에서는 \[RFC2068\]의 섹션 19.7.1에 설명된 지속 연결의 명시적으로 협상된\("Keep-Alive"\) 버전을 구현합니다.

일부 클라이언트와 서버는 "Connection: keep-alive" 요청 헤더 필드를 사용하여 명시적으로 협상함으로써 지속적인 연결에 대한 이전 접근 방식과 호환되기를 원할 수 있습니다. 그러나 HTTP/1.0 영구 연결의 일부 실험적 구현에는 결함이 있습니다. 예를 들어, HTTP/1.0 프록시 서버가 연결을 이해하지 못하는 경우 해당 헤더 필드를 다음 인바운드 서버로 잘못 전달하여 연결이 중단될 수 있습니다.

시도된 솔루션 중 하나는 특히 프록시를 대상으로 하는 Proxy-Connection 헤더 필드를 도입하는 것이었습니다. 실제로는 프록시가 여러 계층에 배포되어 위에서 설명한 것과 동일한 문제가 발생하는 경우가 많기 때문에 이 작업도 실행 불가능했습니다.

결과적으로 클라이언트는 어떤 요청에서도 Proxy-Connection 헤더 필드를 보내지 않는 것이 좋습니다.

또한 클라이언트는 요청 시 "연결: 연결 유지" 사용을 신중하게 고려하도록 권장됩니다. HTTP/1.0 서버와의 지속적인 연결을 활성화할 수 있지만 이를 사용하는 클라이언트는 "정지된" 요청\(클라이언트가 헤더 필드 전송을 중지해야 함을 나타냄\)에 대한 연결을 모니터링해야 하며 클라이언트는 이 메커니즘을 사용해서는 안 됩니다. 프록시를 사용하는 동안에는 전혀 발생하지 않습니다.

---
#### **C.2.3.  Introduction of Transfer-Encoding**

HTTP/1.1에는 Transfer-Encoding 헤더 필드가 도입되었습니다\(섹션 6.1\). MIME 호환 프로토콜을 통해 HTTP 메시지를 전달하기 전에 전송 코딩을 디코딩해야 합니다.

---
### **C.3.  Changes from RFC 7230**

HTTP의 설계 목표, 역사, 아키텍처, 적합성 기준, 프로토콜 버전 관리, URI, 메시지 라우팅, 헤더 필드를 소개하는 대부분의 섹션이 \[HTTP\]로 이동되었습니다. 이 문서는 HTTP/1.1과 관련된 메시징 구문 및 연결 관리 요구 사항으로 축소되었습니다.

```text
   Bare CRs have been prohibited outside of content.  (Section 2.2)

   The ABNF definition of authority-form has changed from the more
   general authority component of a URI (in which port is optional) to
   the specific host:port format that is required by CONNECT.
   (Section 3.2.3)

   Recipients are required to avoid smuggling/splitting attacks when
   processing an ambiguous message framing.  (Section 6.1)

   In the ABNF for chunked extensions, (bad) whitespace around ";" and
   "=" has been reintroduced.  Whitespace was removed in [RFC7230], but
   that change was found to break existing implementations.
   (Section 7.1.1)

   Trailer field semantics now transcend the specifics of chunked
   transfer coding.  The decoding algorithm for chunked (Section 7.1.3)
   has been updated to encourage storage/forwarding of trailer fields
   separately from the header section, to only allow merging into the
   header section if the recipient knows the corresponding field
   definition permits and defines how to merge, and otherwise to discard
   the trailer fields instead of merging.  The trailer part is now
   called the trailer section to be more consistent with the header
   section and more distinct from a body part.  (Section 7.1.2)

   Transfer coding parameters called "q" are disallowed in order to
   avoid conflicts with the use of ranks in the TE header field.
   (Section 7.3)
```

---
# **Acknowledgements**

이 문서에도 적용되는 \[HTTP\]의 부록 "감사의 말씀"을 참조하세요.

---
# **Index**

A C D F G H M O R T X

```text
      A

         absolute-form (of request-target)  Section 3.2.2
         application/http Media Type  *_Section 10.2_*
         asterisk-form (of request-target)  Section 3.2.4
         authority-form (of request-target)  Section 3.2.3

      C

         chunked (Coding Format)  Section 6.1; Section 6.3
         chunked (transfer coding)  *_Section 7.1_*
         close  Section 9.3; *_Section 9.6_*
         compress (transfer coding)  *_Section 7.2_*
         Connection header field  Section 9.6
         Content-Length header field  Section 6.2
         Content-Transfer-Encoding header field  Appendix B.5

      D

         deflate (transfer coding)  *_Section 7.2_*

      F

         Fields
            Close  *_Section 9.6, Paragraph 4_*
            MIME-Version  *_Appendix B.1_*
            Transfer-Encoding  *_Section 6.1_*

      G

         Grammar
            ALPHA  *_Section 1.2_*
            CR  *_Section 1.2_*
            CRLF  *_Section 1.2_*
            CTL  *_Section 1.2_*
            DIGIT  *_Section 1.2_*
            DQUOTE  *_Section 1.2_*
            HEXDIG  *_Section 1.2_*
            HTAB  *_Section 1.2_*
            HTTP-message  *_Section 2.1_*
            HTTP-name  *_Section 2.3_*
            HTTP-version  *_Section 2.3_*
            LF  *_Section 1.2_*
            OCTET  *_Section 1.2_*
            SP  *_Section 1.2_*
            Transfer-Encoding  *_Section 6.1_*
            VCHAR  *_Section 1.2_*
            absolute-form  Section 3.2; *_Section 3.2.2_*
            asterisk-form  Section 3.2; *_Section 3.2.4_*
            authority-form  Section 3.2; *_Section 3.2.3_*
            chunk  *_Section 7.1_*
            chunk-data  *_Section 7.1_*
            chunk-ext  Section 7.1; *_Section 7.1.1_*
            chunk-ext-name  *_Section 7.1.1_*
            chunk-ext-val  *_Section 7.1.1_*
            chunk-size  *_Section 7.1_*
            chunked-body  *_Section 7.1_*
            field-line  *_Section 5_*; Section 7.1.2
            field-name  Section 5
            field-value  Section 5
            last-chunk  *_Section 7.1_*
            message-body  *_Section 6_*
            method  *_Section 3.1_*
            obs-fold  *_Section 5.2_*
            origin-form  Section 3.2; *_Section 3.2.1_*
            reason-phrase  *_Section 4_*
            request-line  *_Section 3_*
            request-target  *_Section 3.2_*
            start-line  *_Section 2.1_*
            status-code  *_Section 4_*
            status-line  *_Section 4_*
            trailer-section  Section 7.1; *_Section 7.1.2_*
         gzip (transfer coding)  *_Section 7.2_*

      H

         Header Fields
            MIME-Version  *_Appendix B.1_*
            Transfer-Encoding  *_Section 6.1_*
         header line  Section 2.1
         header section  Section 2.1
         headers  Section 2.1

      M

         Media Type
            application/http  *_Section 10.2_*
            message/http  *_Section 10.1_*
         message/http Media Type  *_Section 10.1_*
         method  *_Section 3.1_*
         MIME-Version header field  *_Appendix B.1_*

      O

         origin-form (of request-target)  Section 3.2.1

      R

         request-target  *_Section 3.2_*

      T

         Transfer-Encoding header field  *_Section 6.1_*

      X

         x-compress (transfer coding)  *_Section 7.2_*
         x-gzip (transfer coding)  *_Section 7.2_*
```

---
# **Authors' Addresses**

```text
   Roy T. Fielding (editor)
   Adobe
   345 Park Ave
   San Jose, CA 95110
   United States of America
   Email: fielding@gbiv.com
   URI:   https://roy.gbiv.com/

   Mark Nottingham (editor)
   Fastly
   Prahran
   Australia
   Email: mnot@mnot.net
   URI:   https://www.mnot.net/

   Julian Reschke (editor)
   greenbytes GmbH
   Hafenweg 16
   48155 Münster
   Germany
   Email: julian.reschke@greenbytes.de
   URI:   https://greenbytes.de/tech/webdav/
```
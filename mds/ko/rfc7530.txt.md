

```text
Internet Engineering Task Force (IETF)                    T. Haynes, Ed.
Request for Comments: 7530                                  Primary Data
Obsoletes: 3530                                           D. Noveck, Ed.
Category: Standards Track                                           Dell
ISSN: 2070-1721                                               March 2015

              Network File System (NFS) Version 4 Protocol
```

---
# **Abstract**

NFS\(네트워크 파일 시스템\) 버전 4 프로토콜은 NFS 프로토콜 버전 2\(RFC 1094\) 및 버전 3\(RFC 1813\)을 기반으로 구축된 분산 파일 시스템 프로토콜입니다. 이전 버전과 달리 NFS 버전 4 프로토콜은 파일 잠금 지원과 MOUNT 프로토콜을 통합하면서 기존 파일 액세스를 지원합니다. 또한 강력한 보안\(및 협상\), COMPOUND 작업, 클라이언트 캐싱 및 국제화에 대한 지원이 추가되었습니다. 물론 NFS 버전 4가 인터넷 환경에서 잘 동작하도록 하는 데에도 관심이 쏠렸다.

이 문서는 함께 제공되는 XDR\(외부 데이터 표현\) 설명 문서인 RFC 7531과 함께 NFS 버전 4 프로토콜의 정의인 RFC 3530을 더 이상 사용하지 않습니다.

---
# **Status of This Memo**

이것은 인터넷 표준 추적 문서입니다.

이 문서는 IETF\(Internet Engineering Task Force\)의 제품입니다. 이는 IETF 커뮤니티의 합의를 나타냅니다. 공개 검토를 받았으며 IESG\(Internet Engineering Steering Group\)의 출판 승인을 받았습니다. 인터넷 표준에 대한 자세한 내용은 RFC 5741의 섹션 2에서 확인할 수 있습니다.

이 문서의 현재 상태, 정오표, 피드백 제공 방법에 대한 정보는 http://www.rfc-editor.org/info/rfc7530에서 얻을 수 있습니다.

---
# **Copyright Notice**

Copyright \(c\) 2015 IETF Trust 및 문서 작성자로 확인된 사람. 판권 소유.

이 문서는 이 문서의 발행일에 유효한 BCP 78 및 IETF 문서에 관한 IETF 트러스트의 법적 조항\(http://trustee.ietf.org/license-info\)의 적용을 받습니다. 이 문서와 관련된 귀하의 권리 및 제한 사항을 설명하므로 이 문서를 주의 깊게 검토하십시오. 이 문서에서 추출한 코드 구성 요소는 Trust Legal Provisions의 섹션 4.e에 설명된 대로 Simplified BSD License 텍스트를 포함해야 하며 Simplified BSD License에 설명된 대로 보증 없이 제공됩니다.

이 문서에는 2008년 11월 10일 이전에 공개되거나 공개된 IETF 문서 또는 IETF 기고문의 자료가 포함될 수 있습니다. 이 자료의 일부에 대한 저작권을 제어하는 ​​사람은 해당 자료의 수정을 허용할 권리를 IETF 트러스트에 부여하지 않았을 수 있습니다. IETF 표준 프로세스 외부. 이러한 자료의 저작권을 관리하는 사람으로부터 적절한 라이센스를 얻지 않고 이 문서는 IETF 표준 프로세스 외부에서 수정할 수 없으며 IETF 표준 프로세스 외부에서 이 문서의 파생물을 생성할 수 없습니다. RFC로 게시하거나 영어 이외의 언어로 번역합니다.

---
# **Table of Contents**

```text
   1. Introduction ....................................................8
      1.1. Requirements Language ......................................8
      1.2. NFS Version 4 Goals ........................................8
      1.3. Definitions in the Companion Document RFC 7531 Are
           Authoritative ..............................................9
      1.4. Overview of NFSv4 Features .................................9
           1.4.1. RPC and Security ....................................9
           1.4.2. Procedure and Operation Structure ..................10
           1.4.3. File System Model ..................................10
           1.4.4. OPEN and CLOSE .....................................12
           1.4.5. File Locking .......................................12
           1.4.6. Client Caching and Delegation ......................13
      1.5. General Definitions .......................................14
      1.6. Changes since RFC 3530 ....................................16
      1.7. Changes between RFC 3010 and RFC 3530 .....................16
   2. Protocol Data Types ............................................18
      2.1. Basic Data Types ..........................................18
      2.2. Structured Data Types .....................................21
   3. RPC and Security Flavor ........................................25
      3.1. Ports and Transports ......................................25
           3.1.1. Client Retransmission Behavior .....................26
      3.2. Security Flavors ..........................................27
           3.2.1. Security Mechanisms for NFSv4 ......................27
      3.3. Security Negotiation ......................................28
           3.3.1. SECINFO ............................................29
           3.3.2. Security Error .....................................29
           3.3.3. Callback RPC Authentication ........................29
   4. Filehandles ....................................................30
      4.1. Obtaining the First Filehandle ............................30
           4.1.1. Root Filehandle ....................................31
           4.1.2. Public Filehandle ..................................31
      4.2. Filehandle Types ..........................................31
           4.2.1. General Properties of a Filehandle .................32
           4.2.2. Persistent Filehandle ..............................32
           4.2.3. Volatile Filehandle ................................33
           4.2.4. One Method of Constructing a Volatile Filehandle ...34
      4.3. Client Recovery from Filehandle Expiration ................35
   5. Attributes .....................................................35
      5.1. REQUIRED Attributes .......................................37
      5.2. RECOMMENDED Attributes ....................................37
      5.3. Named Attributes ..........................................37
      5.4. Classification of Attributes ..............................39
      5.5. Set-Only and Get-Only Attributes ..........................40
      5.6. REQUIRED Attributes - List and Definition References ......40
      5.7. RECOMMENDED Attributes - List and Definition References ...41
      5.8. Attribute Definitions .....................................42
           5.8.1. Definitions of REQUIRED Attributes .................42
           5.8.2. Definitions of Uncategorized RECOMMENDED
                  Attributes .........................................45
      5.9. Interpreting owner and owner_group ........................51
      5.10. Character Case Attributes ................................53
   6. Access Control Attributes ......................................54
      6.1. Goals .....................................................54
      6.2. File Attributes Discussion ................................55
           6.2.1. Attribute 12: acl ..................................55
           6.2.2. Attribute 33: mode .................................70
      6.3. Common Methods ............................................71
           6.3.1. Interpreting an ACL ................................71
           6.3.2. Computing a mode Attribute from an ACL .............72
      6.4. Requirements ..............................................73
           6.4.1. Setting the mode and/or ACL Attributes .............74
           6.4.2. Retrieving the mode and/or ACL Attributes ..........75
           6.4.3. Creating New Objects ...............................75
   7. NFS Server Namespace ...........................................77
      7.1. Server Exports ............................................77
      7.2. Browsing Exports ..........................................77
      7.3. Server Pseudo-File System .................................78
      7.4. Multiple Roots ............................................79
      7.5. Filehandle Volatility .....................................79
      7.6. Exported Root .............................................79
      7.7. Mount Point Crossing ......................................79
      7.8. Security Policy and Namespace Presentation ................80
   8. Multi-Server Namespace .........................................81
      8.1. Location Attributes .......................................81
      8.2. File System Presence or Absence ...........................81
      8.3. Getting Attributes for an Absent File System ..............83
           8.3.1. GETATTR within an Absent File System ...............83
           8.3.2. READDIR and Absent File Systems ....................84
      8.4. Uses of Location Information ..............................84
           8.4.1. File System Replication ............................85
           8.4.2. File System Migration ..............................86
           8.4.3. Referrals ..........................................86
      8.5. Location Entries and Server Identity ......................87
      8.6. Additional Client-Side Considerations .....................88
      8.7. Effecting File System Referrals ...........................89
           8.7.1. Referral Example (LOOKUP) ..........................89
           8.7.2. Referral Example (READDIR) .........................93
      8.8. The Attribute fs_locations ................................96
   9. File Locking and Share Reservations ............................98
      9.1. Opens and Byte-Range Locks ................................99
           9.1.1. Client ID ..........................................99
           9.1.2. Server Release of Client ID .......................102
           9.1.3. Use of Seqids .....................................103
           9.1.4. Stateid Definition ................................104
           9.1.5. Lock-Owner ........................................110
           9.1.6. Use of the Stateid and Locking ....................110
           9.1.7. Sequencing of Lock Requests .......................113
           9.1.8. Recovery from Replayed Requests ...................114
           9.1.9. Interactions of Multiple Sequence Values ..........114
           9.1.10. Releasing State-Owner State ......................115
           9.1.11. Use of Open Confirmation .........................116
      9.2. Lock Ranges ..............................................117
      9.3. Upgrading and Downgrading Locks ..........................117
      9.4. Blocking Locks ...........................................118
      9.5. Lease Renewal ............................................119
      9.6. Crash Recovery ...........................................120
           9.6.1. Client Failure and Recovery .......................120
           9.6.2. Server Failure and Recovery .......................120
           9.6.3. Network Partitions and Recovery ...................122
      9.7. Recovery from a Lock Request Timeout or Abort ............130
      9.8. Server Revocation of Locks ...............................130
      9.9. Share Reservations .......................................132
      9.10. OPEN/CLOSE Operations ...................................132
           9.10.1. Close and Retention of State Information .........133
      9.11. Open Upgrade and Downgrade ..............................134
      9.12. Short and Long Leases ...................................135
      9.13. Clocks, Propagation Delay, and Calculating Lease
            Expiration ..............................................135
      9.14. Migration, Replication, and State .......................136
           9.14.1. Migration and State ..............................136
           9.14.2. Replication and State ............................137
           9.14.3. Notification of Migrated Lease ...................137
           9.14.4. Migration and the lease_time Attribute ...........138
   10. Client-Side Caching ..........................................139
      10.1. Performance Challenges for Client-Side Caching ..........139
      10.2. Delegation and Callbacks ................................140
           10.2.1. Delegation Recovery ..............................142
      10.3. Data Caching ............................................147
           10.3.1. Data Caching and OPENs ...........................147
           10.3.2. Data Caching and File Locking ....................148
           10.3.3. Data Caching and Mandatory File Locking ..........150
           10.3.4. Data Caching and File Identity ...................150
      10.4. Open Delegation .........................................151
           10.4.1. Open Delegation and Data Caching .................154
           10.4.2. Open Delegation and File Locks ...................155
           10.4.3. Handling of CB_GETATTR ...........................155
           10.4.4. Recall of Open Delegation ........................158
           10.4.5. OPEN Delegation Race with CB_RECALL ..............160
           10.4.6. Clients That Fail to Honor Delegation Recalls ....161
           10.4.7. Delegation Revocation ............................162
      10.5. Data Caching and Revocation .............................162
           10.5.1. Revocation Recovery for Write Open Delegation ....163
      10.6. Attribute Caching .......................................164
      10.7. Data and Metadata Caching and Memory-Mapped Files .......166
      10.8. Name Caching ............................................168
      10.9. Directory Caching .......................................169
   11. Minor Versioning .............................................170
   12. Internationalization .........................................170
      12.1. Introduction ............................................170
      12.2. Limitations on Internationalization-Related
            Processing in the NFSv4 Context .........................172
      12.3. Summary of Server Behavior Types ........................173
      12.4. String Encoding .........................................173
      12.5. Normalization ...........................................174
      12.6. Types with Processing Defined by Other Internet Areas ...175
      12.7. Errors Related to UTF-8 .................................177
      12.8. Servers That Accept File Component Names That
            Are Not Valid UTF-8 Strings .............................177
   13. Error Values .................................................178
      13.1. Error Definitions .......................................179
           13.1.1. General Errors ...................................180
           13.1.2. Filehandle Errors ................................181
           13.1.3. Compound Structure Errors ........................183
           13.1.4. File System Errors ...............................184
           13.1.5. State Management Errors ..........................186
           13.1.6. Security Errors ..................................187
           13.1.7. Name Errors ......................................187
           13.1.8. Locking Errors ...................................188
           13.1.9. Reclaim Errors ...................................190
           13.1.10. Client Management Errors ........................191
           13.1.11. Attribute Handling Errors .......................191
           13.1.12. Miscellaneous Errors ............................191
      13.2. Operations and Their Valid Errors .......................192
      13.3. Callback Operations and Their Valid Errors ..............200
      13.4. Errors and the Operations That Use Them .................201
   14. NFSv4 Requests ...............................................206
      14.1. COMPOUND Procedure ......................................207
      14.2. Evaluation of a COMPOUND Request ........................207
      14.3. Synchronous Modifying Operations ........................208
      14.4. Operation Values ........................................208
   15. NFSv4 Procedures .............................................209
      15.1. Procedure 0: NULL - No Operation ........................209
      15.2. Procedure 1: COMPOUND - COMPOUND Operations .............210
   16. NFSv4 Operations .............................................214
      16.1. Operation 3: ACCESS - Check Access Rights ...............214
      16.2. Operation 4: CLOSE - Close File .........................217
      16.3. Operation 5: COMMIT - Commit Cached Data ................218
      16.4. Operation 6: CREATE - Create a Non-regular File Object ..221
      16.5. Operation 7: DELEGPURGE - Purge Delegations
            Awaiting Recovery .......................................224
      16.6. Operation 8: DELEGRETURN - Return Delegation ............226
      16.7. Operation 9: GETATTR - Get Attributes ...................227
      16.8. Operation 10: GETFH - Get Current Filehandle ............229
      16.9. Operation 11: LINK - Create Link to a File ..............230
      16.10. Operation 12: LOCK - Create Lock .......................232
      16.11. Operation 13: LOCKT - Test for Lock ....................236
      16.12. Operation 14: LOCKU - Unlock File ......................238
      16.13. Operation 15: LOOKUP - Look Up Filename ................240
      16.14. Operation 16: LOOKUPP - Look Up Parent Directory .......242
      16.15. Operation 17: NVERIFY - Verify Difference in
             Attributes .............................................243
      16.16. Operation 18: OPEN - Open a Regular File ...............245
      16.17. Operation 19: OPENATTR - Open Named Attribute
             Directory ..............................................256
      16.18. Operation 20: OPEN_CONFIRM - Confirm Open ..............257
      16.19. Operation 21: OPEN_DOWNGRADE - Reduce Open File
             Access .................................................260
      16.20. Operation 22: PUTFH - Set Current Filehandle ...........262
      16.21. Operation 23: PUTPUBFH - Set Public Filehandle .........263
      16.22. Operation 24: PUTROOTFH - Set Root Filehandle ..........265
      16.23. Operation 25: READ - Read from File ....................266
      16.24. Operation 26: READDIR - Read Directory .................269
      16.25. Operation 27: READLINK - Read Symbolic Link ............273
      16.26. Operation 28: REMOVE - Remove File System Object .......274
      16.27. Operation 29: RENAME - Rename Directory Entry ..........276
      16.28. Operation 30: RENEW - Renew a Lease ....................278
      16.29. Operation 31: RESTOREFH - Restore Saved Filehandle .....280
      16.30. Operation 32: SAVEFH - Save Current Filehandle .........281
      16.31. Operation 33: SECINFO - Obtain Available Security ......282
      16.32. Operation 34: SETATTR - Set Attributes .................286
      16.33. Operation 35: SETCLIENTID - Negotiate Client ID ........289
      16.34. Operation 36: SETCLIENTID_CONFIRM - Confirm Client ID ..293
      16.35. Operation 37: VERIFY - Verify Same Attributes ..........297
      16.36. Operation 38: WRITE - Write to File ....................299
      16.37. Operation 39: RELEASE_LOCKOWNER - Release
             Lock-Owner State .......................................304
      16.38. Operation 10044: ILLEGAL - Illegal Operation ...........305
   17. NFSv4 Callback Procedures ....................................306
      17.1. Procedure 0: CB_NULL - No Operation .....................306
      17.2. Procedure 1: CB_COMPOUND - COMPOUND Operations ..........307
   18. NFSv4 Callback Operations ....................................309
      18.1. Operation 3: CB_GETATTR - Get Attributes ................309
      18.2. Operation 4: CB_RECALL - Recall an Open Delegation ......310
      18.3. Operation 10044: CB_ILLEGAL - Illegal Callback
            Operation ...............................................311
   19. Security Considerations ......................................312
   20. IANA Considerations ..........................................314
      20.1. Named Attribute Definitions .............................314
           20.1.1. Initial Registry .................................315
           20.1.2. Updating Registrations ...........................315
      20.2. Updates to Existing IANA Registries .....................315
   21. References ...................................................316
      21.1. Normative References ....................................316
      21.2. Informative References ..................................318
   Acknowledgments ..................................................322
   Authors' Addresses ...............................................323
```

---
## **1.  Introduction**
---
### **1.1.  Requirements Language**

이 문서의 핵심 단어 "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY" 및 "OPTIONAL"은 다음과 같습니다. 이 문서의 섹션 1.4.3.2 및 5에 설명된 대로 속성 클래스를 구별하기 위해 "필수" 및 "권장"이 한정자로 사용되는 경우를 제외하고 RFC 2119 \[RFC2119\]에 설명된 대로 해석됩니다.\(MUST NOT\)

---
### **1.2.  NFS Version 4 Goals**

NFSv4\(Network File System 버전 4\) 프로토콜은 버전 2\[RFC1094\] 및 버전 3\[RFC1813\]에서 이미 정의된 NFS 프로토콜의 추가 개정판입니다. 이전 버전의 필수 특성을 유지합니다. 쉽게 복구할 수 있는 디자인; 전송 프로토콜, 운영 체제 및 파일 시스템에 독립적입니다. 간단; 그리고 좋은 성능. NFSv4 개정판에는 다음과 같은 목표가 있습니다.

o 인터넷 접속이 향상되고 성능이 향상됩니다.

- 이 프로토콜은 방화벽을 쉽게 통과하고 대기 시간이 길고 대역폭이 낮은 곳에서 잘 작동하며 서버당 매우 많은 수의 클라이언트로 확장되도록 설계되었습니다.

o 프로토콜에 내장된 협상을 통해 강력한 보안을 제공합니다.

- 이 프로토콜은 RPCSEC\_GSS 프로토콜을 지원하는 ONC\(개방형 네트워크 컴퓨팅\) RPC\(원격 프로시저 호출\) 작업 그룹의 작업을 기반으로 구축되었습니다\(\[RFC2203\] 및 \[RFC5403\] 참조\). 또한 NFSv4 프로토콜은 클라이언트와 서버가 보안을 협상할 수 있도록 하고 클라이언트와 서버가 최소한의 보안 체계 집합을 지원하도록 요구하는 메커니즘을 제공합니다.

```text
   o  Good cross-platform interoperability.
```

- 프로토콜은 하나의 파일 시스템이나 운영 체제를 다른 파일 시스템이나 운영 체제보다 과도하게 선호하지 않는 유용하고 공통된 기능 세트를 제공하는 파일 시스템 모델을 특징으로 합니다.

o 프로토콜 확장을 위해 설계되었습니다.

- 프로토콜은 이전 버전과의 호환성을 손상시키지 않는 표준 확장을 허용하도록 설계되었습니다.

이 문서는 함께 제공되는 XDR\(External Data Representation\) 설명 문서 \[RFC7531\]와 함께 NFSv4를 설명하는 권위 있는 문서인 \[RFC3530\]을 폐기합니다. 이전에 유효한 요청이 유효한 상태로 유지된다는 점에서 유선 프로토콜 변경이 도입되지 않습니다.

---
### **1.3.  Definitions in the Companion Document RFC 7531 Are Authoritative**

"네트워크 파일 시스템\(NFS\) 버전 4 외부 데이터 표현 표준\(XDR\) 설명" \[RFC7531\]에는 프로토콜에서 사용되는 구성의 XDR 설명 언어 정의가 포함되어 있습니다. 이 문서 내에는 설명을 위해 여러 구성이 재현되어 있습니다. 독자는 \[RFC7531\] 외부에서 재현된 구성에 오류가 있을 수 있다는 경고를 받습니다. \[RFC7531\]과 일치하지 않는 문서의 모든 부분에 대해서는 \[RFC7531\]이 권위 있는 것으로 간주됩니다.

---
### **1.4.  Overview of NFSv4 Features**

독자에게 합리적인 맥락을 제공하기 위해 NFSv4 프로토콜의 주요 기능을 간략하게 검토합니다. 이는 이전 버전의 NFS 프로토콜에 익숙한 독자와 NFS 프로토콜을 처음 접하는 독자 모두에게 적절한 컨텍스트를 제공하기 위해 수행됩니다. NFS 프로토콜을 처음 접하는 독자의 경우 여전히 몇 가지 기본 지식이 필요합니다. 독자는 \[RFC4506\] 및 \[RFC5531\]에 설명된 XDR 및 RPC 프로토콜에 익숙해야 합니다. 파일 시스템 및 분산 파일 시스템에 대한 기본 지식도 필요합니다.

---
#### **1.4.1.  RPC and Security**

이전 버전의 NFS와 마찬가지로 NFSv4 프로토콜에 사용되는 XDR 및 RPC 메커니즘은 \[RFC4506\] 및 \[RFC5531\]에 정의되어 있습니다. 엔드 투 엔드 보안 요구 사항을 충족하기 위해 RPCSEC\_GSS 프레임워크\(\[RFC2203\]의 버전 1과 \[RFC5403\]의 버전 2 모두\)를 사용하여 기본 RPC 보안을 확장합니다. RPCSEC\_GSS를 사용하면 NFSv4 프로토콜에 인증, 무결성 및 개인정보 보호를 제공하는 다양한 메커니즘이 제공될 수 있습니다. Kerberos V5는 \[RFC4121\]에 설명된 대로 사용되어 하나의 보안 프레임워크를 제공합니다. RPCSEC\_GSS를 사용하면 NFSv4 보안을 위해 다른 메커니즘을 지정하고 사용할 수도 있습니다.

대역 내 보안 협상을 활성화하기 위해 NFSv4 프로토콜은 서버의 파일 시스템 리소스에 액세스하기 위해 사용해야 하는 보안 메커니즘과 관련된 정책에 대해 서버에 쿼리하는 방법을 클라이언트에 제공하는 새로운 작업을 추가했습니다. 이를 통해 클라이언트는 클라이언트와 서버 모두에 지정된 정책을 충족하는 보안 메커니즘을 안전하게 일치시킬 수 있습니다.

---
#### **1.4.2.  Procedure and Operation Structure**

NFS 프로토콜의 이전 버전과 크게 다른 점은 COMPOUND 프로시저의 도입입니다. NFSv4 프로토콜에는 NULL과 COMPOUND라는 두 가지 RPC 프로시저가 있습니다. COMPOUND 프로시저는 작업 측면에서 정의되며 이러한 작업은 기존 NFS 프로시저에 더 가깝습니다.

COMPOUND 프로시저를 사용하면 클라이언트는 단순하거나 복잡한 요청을 작성할 수 있습니다. 이러한 COMPOUND 요청을 사용하면 논리적 파일 시스템 작업에 필요한 RPC 수를 줄일 수 있습니다. 예를 들어, 클라이언트는 이전에 서버에 접속하지 않고도 단일 COMPOUND RPC에서 LOOKUP, OPEN 및 READ 작업을 결합하여 한 번의 요청으로 파일에서 데이터를 읽을 수 있습니다. 이전 버전의 NFS 프로토콜에서는 이러한 유형의 단일 요청이 불가능했습니다.

COMPOUND에 사용되는 모델은 매우 간단합니다. 논리적 OR 또는 AND 연산은 없습니다. COMPOUND 요청 내에 결합된 작업은 서버에서 순서대로 평가됩니다. 작업이 실패한 결과를 반환하면 평가가 종료되고 평가된 모든 작업의 ​​결과가 클라이언트에 반환됩니다.

NFSv4 프로토콜은 계속해서 클라이언트가 "파일 핸들"을 통해 서버의 파일이나 디렉터리를 참조하도록 합니다. COMPOUND 프로시저에는 작업 시퀀스 내에서 한 작업에서 다른 작업으로 파일 핸들을 전달하는 방법이 있습니다. 현재 파일 핸들과 저장된 파일 핸들이라는 개념이 있습니다. 대부분의 작업은 현재 파일 핸들을 작업할 파일 시스템 개체로 사용합니다. 저장된 파일 핸들은 COMPOUND 프로시저 내의 임시 파일 핸들 저장소뿐만 아니라 특정 작업을 위한 추가 피연산자로 사용됩니다.

---
#### **1.4.3.  File System Model**

NFSv4 프로토콜에 사용되는 일반 파일 시스템 모델은 이전 버전과 동일합니다. 서버 파일 시스템은 계층적이며 내부에 포함된 일반 파일은 불투명 바이트 스트림으로 처리됩니다. 약간 다른 점은 파일 및 디렉터리 이름이 국제화의 기본 사항을 처리하기 위해 UTF-8로 인코딩된다는 점입니다.

NFSv4 프로토콜은 경로 이름과 파일 핸들 간의 초기 매핑을 제공하기 위해 별도의 프로토콜이 필요하지 않습니다. 이 매핑에 이전 MOUNT 프로토콜을 사용하는 대신 서버는 서버에서 제공하는 파일 시스템 트리의 논리적 루트 또는 최상위를 나타내는 루트 파일 핸들을 제공합니다. 서버는 의사 파일 시스템과 함께 결합하여 여러 파일 시스템을 제공합니다. 이러한 의사 파일 시스템은 실제 파일 시스템 간의 경로 이름에 잠재적인 차이를 제공합니다.

---
##### **1.4.3.1.  Filehandle Types**

이전 버전의 NFS 프로토콜에서는 서버가 제공하는 파일 핸들이 참조하는 파일 시스템 개체의 수명 동안 유효하거나 지속되는 것으로 보장되었습니다. 일부 서버 구현의 경우 이러한 지속성 요구 사항을 충족하기가 어려웠습니다. NFSv4 프로토콜의 경우 다른 유형의 파일 핸들\(휘발성\)을 도입하여 이 요구 사항을 완화했습니다. 지속적이고 일시적인 파일 핸들 유형을 사용하면 서버 구현이 운영 환경과 함께 서버의 파일 시스템 기능과 일치할 수 있습니다. 클라이언트는 서버가 제공하는 파일 핸들 유형에 대한 지식을 갖게 되며 각각의 의미를 처리할 준비를 할 수 있습니다.

---
##### **1.4.3.2.  Attribute Types**

NFSv4 프로토콜에는 REQUIRED, RECOMMENDED 및 명명된 속성으로 구분되는 풍부하고 확장 가능한 파일 객체 속성 구조가 있습니다\(섹션 5 참조\).\(MUST\)

필수 속성 중 일부\(전부는 아님\)는 NFSv3의 속성에서 파생됩니다\(\[RFC1813\]의 fattr3 데이터 유형 정의 참조\). REQUIRED 속성의 예로는 일반 파일을 디렉터리\(일부 운영 환경에서는 폴더라고도 함\) 및 기타 유형의 개체와 구별할 수 있도록 하는 파일 개체 유형\(섹션 5.8.1.2\)이 있습니다. 필수 속성은 섹션 5.1에서 논의됩니다.\(MUST, MUST, MUST\)

RECOMMENDED 속성의 예는 acl\(섹션 6.2.1\)입니다. 이 속성은 파일 객체에 대한 ACL\(액세스 제어 목록\)을 정의합니다. ACL은 NFSv3에서 사용되는 모델 이상의 파일 액세스 제어를 제공합니다. ACL 정의를 사용하면 개별 사용자 및 그룹에 대한 특정 권한 집합을 지정할 수 있습니다. 또한 ACL 상속을 통해 파일 시스템 개체가 생성될 때 액세스 권한을 전파하고 디렉터리 트리를 제한할 수 있습니다. RECOMMENDED 속성은 섹션 5.2에서 논의됩니다.\(SHOULD, SHOULD\)

명명된 속성은 디렉터리나 파일과 연결되고 문자열 이름으로 참조되는 불투명 바이트 스트림입니다. 명명된 속성은 클라이언트 응용 프로그램에서 응용 프로그램별 데이터를 일반 파일이나 디렉터리와 연결하는 방법으로 사용하기 위한 것입니다. NFSv4.1은 상호 운용이 불가능한 구현의 개발을 방지하기 위해 허용된 작업을 강화하여 NFSv4.0과 관련된 명명된 속성을 수정합니다. 명명된 속성은 섹션 5.3에서 논의됩니다.

---
##### **1.4.3.3.  Multi-Server Namespace**

단일 서버 네임스페이스는 서버가 원격 액세스를 위해 제공하는 파일 시스템 계층 구조입니다. 이는 로컬에서 사용 가능한 모든 파일 시스템의 적절한 하위 집합입니다. NFSv4에는 서버 경계를 넘나들고 서버 간 개별 파일 시스템에 대한 지원을 중단 없이 전송할 수 있는 네임스페이스 구현을 허용하는 다양한 기능이 포함되어 있습니다. 이는 모두 하나의 파일 시스템이 해당 파일 시스템에 대한 대체 위치 또는 새 위치를 지정할 수 있도록 하는 속성을 기반으로 합니다. 즉, 클라이언트가 단일 서버의 로컬 파일 시스템을 통과할 수 있는 것처럼 이제 다른 서버의 원격 파일 시스템을 통과할 수 있습니다.

이러한 속성은 추가 위치에 대한 사양을 제공하지만 실제 파일 시스템 콘텐츠는 제공하지 않는 부재 파일 시스템 개념과 함께 사용될 수 있습니다. 이를 통해 다음과 같은 여러 가지 중요한 기능을 사용할 수 있습니다.

o 한 서버가 클라이언트를 다른 서버가 제공하는 파일 시스템으로 안내할 수 있는 참조를 구현하기 위해 파일 시스템이 없는 경우 위치 속성을 사용할 수 있습니다. 이를 통해 광범위한 다중 서버 네임스페이스를 구성할 수 있습니다.

o 현재 파일 시스템 인스턴스를 사용할 수 없는 경우 사용할 대체 파일 시스템 인스턴스 또는 복제본의 위치를 ​​제공하기 위해 현재 파일 시스템에 대한 위치 속성이 제공될 수 있습니다.

o 이전에 존재했던 파일 시스템이 없을 때 위치 속성이 제공될 수 있습니다. 이를 통해 파일 시스템을 대체 서버로 중단 없이 마이그레이션할 수 있습니다.

---
#### **1.4.4.  OPEN and CLOSE**

NFSv4 프로토콜에는 OPEN 및 CLOSE 작업이 도입되었습니다. OPEN 작업은 파일 조회, 생성 및 공유 의미\(9.9절 참조\)를 결합할 수 있는 단일 지점을 제공합니다. CLOSE 작업은 OPEN에 의해 ​​누적된 상태의 해제도 제공합니다.

---
#### **1.4.5.  File Locking**

NFSv4 프로토콜을 사용하면 바이트 범위 파일 잠금에 대한 지원이 NFS 프로토콜의 일부입니다. 파일 잠금 지원은 RPC 콜백 메커니즘이 필요하지 않도록 구성되어 있습니다. 이는 NFS 파일 잠금 프로토콜인 NLM\(Network Lock Manager\) \[RFC1813\]의 이전 버전과 다릅니다. 파일 잠금과 관련된 상태는 임대 기반 모델에 따라 서버에서 유지됩니다. 서버는 NFS 클라이언트가 보유한 모든 상태에 대해 단일 임대 기간을 정의합니다.

클라이언트가 정의된 기간 내에 임대를 갱신하지 않으면 클라이언트의 임대와 관련된 모든 상태가 서버에 의해 해제될 수 있습니다. 클라이언트는 RENEW 작업을 사용하거나 암시적으로 다른 작업\(주로 READ\)을 사용하여 임대를 갱신할 수 있습니다.

---
#### **1.4.6.  Client Caching and Delegation**

NFSv4 프로토콜의 파일, 속성 및 디렉터리 캐싱은 이전 버전과 유사합니다. 속성과 디렉터리 정보는 클라이언트가 결정한 기간 동안 캐시됩니다. 미리 정의된 시간 초과가 끝나면 클라이언트는 서버에 쿼리하여 관련 파일 시스템 개체가 업데이트되었는지 확인합니다.

파일 데이터의 경우 클라이언트는 파일이 열릴 때 캐시 유효성을 확인합니다. 파일이 변경되었는지 확인하기 위해 쿼리가 서버로 전송됩니다. 이 정보를 기반으로 클라이언트는 파일에 대한 데이터 캐시를 유지해야 할지 아니면 해제해야 할지 결정합니다. 또한 파일이 닫히면 수정된 데이터가 서버에 기록됩니다.

애플리케이션이 파일 데이터에 대한 액세스를 직렬화하려는 경우 문제의 파일 데이터 범위에 대한 파일 잠금을 사용해야 합니다.

캐싱 영역에서 NFSv4에 추가된 주요 기능은 서버가 특정 책임을 클라이언트에 위임하는 기능입니다. 서버가 클라이언트에게 파일에 대한 위임을 부여하면 클라이언트는 해당 파일을 다른 클라이언트와 공유하는 것과 관련하여 특정 의미를 보장받습니다. OPEN 시 서버는 클라이언트에게 파일에 대한 읽기\(OPEN\_DELEGATE\_READ\) 또는 쓰기\(OPEN\_DELEGATE\_WRITE\) 위임을 제공할 수 있습니다\(섹션 10.4 참조\). 클라이언트에 OPEN\_DELEGATE\_READ 위임이 부여되면 다른 클라이언트는 위임 기간 동안 파일에 쓸 수 없다는 것이 보장됩니다. 클라이언트에 OPEN\_DELEGATE\_WRITE 위임이 부여되면 클라이언트는 다른 클라이언트가 파일에 대한 읽기 또는 쓰기 액세스 권한을 갖고 있지 않음을 확신합니다.

위임은 서버에서 회수될 수 있습니다. 다른 클라이언트가 부여된 위임과 액세스가 충돌하는 방식으로 파일에 대한 액세스를 요청하는 경우 서버는 초기 클라이언트에게 알리고 위임을 회수할 수 있습니다. 이를 위해서는 서버와 클라이언트 사이에 콜백 경로가 존재해야 합니다. 이 콜백 경로가 존재하지 않으면 위임을 부여할 수 없습니다. 위임의 본질은 클라이언트가 서버와의 즉각적인 상호 작용 없이 OPEN, CLOSE, LOCK, LOCKU, READ 또는 WRITE와 같은 작업을 로컬로 서비스할 수 있도록 한다는 것입니다.

---
### **1.5.  General Definitions**

다음 정의는 독자에게 적절한 맥락을 제공할 목적으로 제공됩니다.

부재 파일 시스템: 네임스페이스 구성 요소에 백업 파일 시스템이 없으면 파일 시스템이 "부재"됩니다.

Anonymous Stateid: Anonymous Stateid는 특수 잠금 개체이며 섹션 9.1.4.3에 정의되어 있습니다.

바이트: 이 문서에서 바이트는 옥텟, 즉 길이가 정확히 8비트인 데이텀입니다.

클라이언트: 클라이언트는 NFS 서버의 리소스에 액세스하는 엔터티입니다. 클라이언트는 NFS 서버에 직접 액세스하는 논리를 포함하는 애플리케이션일 수 있습니다. 클라이언트는 일련의 애플리케이션에 원격 파일 시스템 서비스를 제공하는 기존 운영 체제 클라이언트일 수도 있습니다.

- 바이트 범위 잠금과 관련하여 클라이언트는 하나 이상의 애플리케이션을 대신하여 잠금 세트를 유지 관리하는 엔터티이기도 합니다. 이 클라이언트는 자신이 관리하는 잠금에 대한 충돌 또는 오류 복구를 담당합니다.

- 여러 클라이언트가 동일한 전송 및 연결을 공유할 수 있으며 여러 클라이언트가 동일한 네트워크 노드에 존재할 수 있습니다.

클라이언트 ID: 클라이언트 ID는 클라이언트가 제공한 검증 도구 및 ID에 대한 고유한 약식 참조로 사용되는 64비트 수량입니다. 서버는 클라이언트 ID 제공을 담당합니다.

파일 시스템: 파일 시스템은 동일한 fsid 속성을 공유하는 서버의 개체 모음입니다\(섹션 5.8.1.9 참조\).

임대: 임대는 클라이언트에 취소할 수 없는 잠금이 부여되는 서버에서 정의한 시간 간격입니다. 임대 기간 종료 시 임대 기간이 연장되지 않은 경우 잠금이 취소될 수 있습니다. 임대 간격 이후 충돌하는 잠금이 부여된 경우 잠금을 취소해야 합니다.

- 서버가 부여한 모든 임대는 동일한 고정 기간을 갖습니다. 고정 간격 기간은 서버 장애 시 가변 길이 임대에 대한 상태를 유지하는 데 서버가 부담하는 비용을 줄이기 위해 선택되었습니다.

잠금: "잠금"이라는 용어는 별도로 명시하지 않는 한 레코드\(바이트 범위\) 잠금 및 공유 예약을 나타내는 데 사용됩니다.

잠금 소유자: 각 바이트 범위 잠금은 특정 잠금 소유자 및 공개 소유자와 연결됩니다. 잠금 소유자는 클라이언트 ID와 불투명 소유자 문자열로 구성됩니다. 클라이언트는 필요에 따라 바이트 범위 잠금의 소유권을 설정하기 위해 이를 서버에 제공합니다.

Open-Owner: 열려 있는 각 파일은 클라이언트 ID와 불투명 소유자 문자열로 구성된 특정 공개 소유자와 연결됩니다. 클라이언트는 필요에 따라 공개 소유권을 설정하기 위해 이를 서버에 제공합니다.

READ Bypass Stateid: READ Bypass Stateid는 특수 잠금 개체이며 섹션 9.1.4.3에 정의되어 있습니다.

서버: "서버"는 파일 시스템 세트에 대한 클라이언트 액세스를 조정하는 일을 담당하는 엔터티입니다.

안정적인 스토리지: NFSv4 서버는 여러 정전\(계단식 정전, 즉 빠르게 연속적으로 여러 번 정전이 발생하는 경우 포함\), 운영 체제 장애, 저장 매체 자체 이외의 구성 요소의 하드웨어 장애\( 예를 들어 디스크, 비휘발성 RAM\).

- NFS 서버에 허용되는 안정적인 저장소의 몇 가지 예는 다음과 같습니다.

- \(1\) 데이터의 미디어 커밋. 즉, 수정된 데이터가 디스크 미디어\(예: 디스크 플래터\)에 성공적으로 기록되었습니다.

- \(2\) 배터리 지원 온드라이브 중간 스토리지 또는 무정전 전원 시스템\(UPS\)을 갖춘 즉시 응답 디스크 드라이브.

- \(3\) 배터리 지원 중간 저장 및 복구 소프트웨어를 사용하여 서버에서 데이터를 커밋합니다.

- \(4\) UPS 및 복구 소프트웨어를 통한 캐시 커밋.

Stateid: stateid는 특정 파일 및 잠금 유형에 대한 잠금 소유자/열기 소유자 쌍 또는 특정 열기 소유자에 대해 서버에서 제공하는 열기 및 잠금 상태를 고유하게 식별하는 서버에서 반환된 128비트 수량입니다.

검증자: 검증자는 클라이언트가 다시 시작되었고 이전 잠금 상태가 모두 손실되었는지 확인하는 데 서버가 사용할 수 있는 클라이언트가 생성한 64비트 수량입니다.

---
### **1.6.  Changes since RFC 3530**

RFC 3530 \[RFC3530\]의 주요 변경 사항은 다음과 같습니다.

o XDR 정의가 동반 문서로 이동되었습니다.

- \[RFC7531\].

o IETF 지적재산권 정책이 최신 버전으로 업데이트되었습니다.

o 다중 서버 네임스페이스 기능에 대한 설명이 재구성되어 더욱 완전해졌습니다.

o 도메인 이름 처리가 다음을 반영하도록 업데이트되었습니다.

- 애플리케이션의 국제화된 도메인 이름\(IDNA\) \[RFC5891\].

o 이전에 필수였던 LIPKEY 및 SPKM-3 보안 메커니즘이 제거되었습니다.

o 상태가 마이그레이션된 경우 클라이언트가 새 서버에 대한 콜백 정보를 다시 설정하는 것과 관련하여 몇 가지 설명이 제공되었습니다.

o 무료 잠금 및 네트워크 파티션을 위한 세 번째 엣지 케이스가 추가되었습니다.

o stateid의 정의가 강화되었습니다.

---
### **1.7.  Changes between RFC 3010 and RFC 3530**

\[RFC3530\]의 NFSv4 프로토콜 정의는 \[RFC3010\]에 있는 정의를 대체하고 폐기되었습니다. 두 문서의 일부는 동일하게 유지되었지만 다른 문서에는 실질적인 변경이 있었습니다. \[RFC3010\]과 \[RFC3530\] 사이의 변경 사항은 구현 경험과 프로토콜에 대한 추가 검토를 반영합니다.

다음 목록에는 모든 변경 사항이 포함되어 있지는 않지만 가장 주목할만한 변경 사항이나 추가 사항이 나와 있습니다.

o 상태 모델에 open\_owner4 식별자가 추가되었습니다. 이는 POSIX 기반 클라이언트와 파일 잠금에 사용하는 모델을 수용하기 위해 수행되었습니다. POSIX 클라이언트의 경우 open\_owner4는 프로세스 집합 간에 잠재적으로 공유되는 파일 설명자에 해당하고 lock\_owner4 식별자는 파일을 잠그는 프로세스에 해당합니다.

o 소유자 및 그룹 속성 처리에 대한 설명 및 오류 조건이 추가되었습니다. 이러한 속성은 문자열 기반이므로\(이전 NFS 버전의 숫자 uid/gid와 반대\) 번역이 불가능할 수 있으므로 변경이 이루어집니다.

o 평가 및 부분 지원을 다루기 위해 ACL 및 모드 속성에 대한 설명을 추가했습니다.

o XDR 불투명으로 정의된 식별자의 경우 크기 제한을 설정합니다.

o POSIX 클라이언트가 로컬 마운트를 올바르게 구성할 수 있도록 Mounted\_on\_fileid 속성을 추가했습니다.

o 새 클라이언트 콜백 정보를 지정하는 기능을 추가하는 동시에 확인 세부 정보를 올바르게 처리하도록 SETCLIENTID/SETCLIENTID\_CONFIRM 작업을 수정했습니다. 또한 콜백 정보 자체에 대한 설명도 추가되었습니다.

o 클라이언트가 lock\_owner4를 더 이상 사용하지 않을 것임을 서버에 알릴 수 있는 새로운 작업 RELEASE\_LOCKOWNER를 추가했습니다.

o 클라이언트를 올바르게 식별하고 추가 오류 반환을 허용하기 위해 RENEW 작업 변경 사항이 추가되었습니다.

o 모든 작업에 대한 오류 반환 가능성을 확인했습니다.

o 클라이언트가 동일한 효과를 얻기 위해 일련의 LOOKUP 작업을 구성하도록 하기 위해 LOOKUP 및 OPEN에서 pathname4 데이터 유형의 사용을 제거했습니다.

---
## **2.  Protocol Data Types**

NFSv4 프로토콜의 데이터 유형을 설명하는 구문과 의미는 XDR \[RFC4506\] 및 RPC \[RFC5531\] 문서에 정의되어 있습니다. 다음 섹션에서는 XDR 데이터 유형을 기반으로 이 프로토콜에 특정한 유형과 구조를 정의합니다. 참고로 크기 상수와 권위 있는 정의는 \[RFC7531\]에서 찾을 수 있습니다.

---
### **2.1.  Basic Data Types**

표 1에는 기본 NFSv4 데이터 유형이 나열되어 있습니다.

```text
   +-----------------+-------------------------------------------------+
   | Data Type       | Definition                                      |
   +-----------------+-------------------------------------------------+
   | int32_t         | typedef int int32_t;                            |
   |                 |                                                 |
   | uint32_t        | typedef unsigned int uint32_t;                  |
   |                 |                                                 |
   | int64_t         | typedef hyper int64_t;                          |
   |                 |                                                 |
   | uint64_t        | typedef unsigned hyper uint64_t;                |
   |                 |                                                 |
   | attrlist4       | typedef opaque attrlist4<>;                     |
   |                 |                                                 |
   |                 | Used for file/directory attributes.             |
   |                 |                                                 |
   | bitmap4         | typedef uint32_t bitmap4<>;                     |
   |                 |                                                 |
   |                 | Used in attribute array encoding.               |
   |                 |                                                 |
   | changeid4       | typedef uint64_t changeid4;                     |
   |                 |                                                 |
   |                 | Used in the definition of change_info4.         |
   |                 |                                                 |
   | clientid4       | typedef uint64_t clientid4;                     |
   |                 |                                                 |
   |                 | Shorthand reference to client identification.   |
   |                 |                                                 |
   | count4          | typedef uint32_t count4;                        |
   |                 |                                                 |
   |                 | Various count parameters (READ, WRITE, COMMIT). |
   |                 |                                                 |
   | length4         | typedef uint64_t length4;                       |
   |                 |                                                 |
   |                 | Describes LOCK lengths.                         |
   |                 |                                                 |

   | mode4           | typedef uint32_t mode4;                         |
   |                 |                                                 |
   |                 | Mode attribute data type.                       |
   |                 |                                                 |
   | nfs_cookie4     | typedef uint64_t nfs_cookie4;                   |
   |                 |                                                 |
   |                 | Opaque cookie value for READDIR.                |
   |                 |                                                 |
   | nfs_fh4         | typedef opaque nfs_fh4<NFS4_FHSIZE>;            |
   |                 |                                                 |
   |                 | Filehandle definition.                          |
   |                 |                                                 |
   | nfs_ftype4      | enum nfs_ftype4;                                |
   |                 |                                                 |
   |                 | Various defined file types.                     |
   |                 |                                                 |
   | nfsstat4        | enum nfsstat4;                                  |
   |                 |                                                 |
   |                 | Return value for operations.                    |
   |                 |                                                 |
   | nfs_lease4      | typedef uint32_t nfs_lease4;                    |
   |                 |                                                 |
   |                 | Duration of a lease in seconds.                 |
   |                 |                                                 |
   | offset4         | typedef uint64_t offset4;                       |
   |                 |                                                 |
   |                 | Various offset designations (READ, WRITE, LOCK, |
   |                 | COMMIT).                                        |
   |                 |                                                 |
   | qop4            | typedef uint32_t qop4;                          |
   |                 |                                                 |
   |                 | Quality of protection designation in SECINFO.   |
   |                 |                                                 |
   | sec_oid4        | typedef opaque sec_oid4<>;                      |
   |                 |                                                 |
   |                 | Security Object Identifier.  The sec_oid4 data  |
   |                 | type is not really opaque.  Instead, it         |
   |                 | contains an ASN.1 OBJECT IDENTIFIER as used by  |
   |                 | GSS-API in the mech_type argument to            |
   |                 | GSS_Init_sec_context.  See [RFC2743] for        |
   |                 | details.                                        |
   |                 |                                                 |
   | seqid4          | typedef uint32_t seqid4;                        |
   |                 |                                                 |
   |                 | Sequence identifier used for file locking.      |
   |                 |                                                 |

   | utf8string      | typedef opaque utf8string<>;                    |
   |                 |                                                 |
   |                 | UTF-8 encoding for strings.                     |
   |                 |                                                 |
   | utf8str_cis     | typedef utf8string utf8str_cis;                 |
   |                 |                                                 |
   |                 | Case-insensitive UTF-8 string.                  |
   |                 |                                                 |
   | utf8str_cs      | typedef utf8string utf8str_cs;                  |
   |                 |                                                 |
   |                 | Case-sensitive UTF-8 string.                    |
   |                 |                                                 |
   | utf8str_mixed   | typedef utf8string utf8str_mixed;               |
   |                 |                                                 |
   |                 | UTF-8 strings with a case-sensitive prefix and  |
   |                 | a case-insensitive suffix.                      |
   |                 |                                                 |
   | component4      | typedef utf8str_cs component4;                  |
   |                 |                                                 |
   |                 | Represents pathname components.                 |
   |                 |                                                 |
   | linktext4       | typedef opaque linktext4<>;                     |
   |                 |                                                 |
   |                 | Symbolic link contents ("symbolic link" is      |
   |                 | defined in an Open Group [openg_symlink]        |
   |                 | standard).                                      |
   |                 |                                                 |
   | ascii_REQUIRED4 | typedef utf8string ascii_REQUIRED4;             |
   |                 |                                                 |
   |                 | String is sent as ASCII and thus is             |
   |                 | automatically UTF-8.                            |
   |                 |                                                 |
   | pathname4       | typedef component4 pathname4<>;                 |
   |                 |                                                 |
   |                 | Represents pathname for fs_locations.           |
   |                 |                                                 |
   | nfs_lockid4     | typedef uint64_t nfs_lockid4;                   |
   |                 |                                                 |
   | verifier4       | typedef opaque verifier4[NFS4_VERIFIER_SIZE];   |
   |                 |                                                 |
   |                 | Verifier used for various operations (COMMIT,   |
   |                 | CREATE, OPEN, READDIR, WRITE)                   |
   |                 | NFS4_VERIFIER_SIZE is defined as 8.             |
   +-----------------+-------------------------------------------------+

                      Table 1: Base NFSv4 Data Types
```

---
### **2.2.  Structured Data Types**
---
#### **2.2.1.  nfstime4**

```text
   struct nfstime4 {
           int64_t         seconds;
           uint32_t        nseconds;
   };
```

nfstime4 구조는 1970년 1월 1일 협정 세계시\(UTC\) 자정 또는 0시 이후의 초 및 나노초 수를 제공합니다. 초 필드의 0보다 큰 값은 1970년 1월 1일 0시 이후의 날짜를 나타냅니다. 초 필드의 0보다 작은 값은 1970년 1월 1일 0시 이전의 날짜를 나타냅니다. 두 경우 모두 nseconds 필드가 추가됩니다. 최종 시간 표현을 위한 초 필드입니다. 예를 들어, 표시할 시간이 1970년 1월 1일 0시 이전 0.5초인 경우 초 필드의 값은 음수 1\(-1\)이고 nseconds 필드의 값은 0.5초\( 500000000\). n초 동안 999,999,999보다 큰 값은 유효하지 않은 것으로 간주됩니다.

이 데이터 유형은 시간 및 날짜 정보를 전달하는 데 사용됩니다. 서버는 시간 값을 처리할 때 로컬 시간 표현으로 변환하고 가능한 한 많은 정확도를 유지합니다. 파일 시스템 객체에 대해 저장된 타임스탬프의 정밀도가 정의된 것보다 낮으면 정밀도가 손실될 수 있습니다. 클라이언트 및 서버 시간 차이를 줄이려면 보조 시간 유지 관리 프로토콜이 권장됩니다.

---
#### **2.2.2.  time_how4**

```text
   enum time_how4 {
           SET_TO_SERVER_TIME4 = 0,
           SET_TO_CLIENT_TIME4 = 1
   };
```

---
#### **2.2.3.  settime4**

```text
   union settime4 switch (time_how4 set_it) {
    case SET_TO_CLIENT_TIME4:
            nfstime4       time;
    default:
            void;
   };
```

위의 정의는 시간 값을 설정하기 위한 속성 정의로 사용됩니다. set\_it가 SET\_TO\_SERVER\_TIME4이면 서버는 시간 값에 대한 로컬 시간 표현을 사용합니다.

---
#### **2.2.4.  specdata4**

```text
   struct specdata4 {
           uint32_t specdata1; /* major device number */
           uint32_t specdata2; /* minor device number */
   };
```

이 데이터 유형은 장치 파일 유형 NF4CHR 및 NF4BLK에 대한 추가 정보를 나타냅니다.

---
#### **2.2.5.  fsid4**

```text
   struct fsid4 {
           uint64_t        major;
           uint64_t        minor;
   };
```

이 유형은 필수 속성으로 사용되는 파일 시스템 식별자입니다.\(MUST\)

---
#### **2.2.6.  fs_location4**

```text
   struct fs_location4 {
           utf8str_cis             server<>;
           pathname4               rootpath;
   };
```

---
#### **2.2.7.  fs_locations4**

```text
   struct fs_locations4 {
           pathname4       fs_root;
           fs_location4    locations<>;
   };
```

fs\_location4 및 fs\_locations4 데이터 유형은 마이그레이션 및 복제 지원에 사용되는 fs\_locations RECOMMENDED 속성에 사용됩니다.\(SHOULD\)

---
#### **2.2.8.  fattr4**

```text
   struct fattr4 {
           bitmap4         attrmask;
           attrlist4       attr_vals;
   };
```

fattr4 구조는 파일 및 디렉터리 속성을 나타내는 데 사용됩니다.

비트맵은 비트 값을 포함하는 데 사용되는 32비트 정수의 계산된 배열입니다. 비트 n을 포함하는 배열의 정수 위치는 \(n / 32\) 표현식으로 계산할 수 있으며 해당 정수 내의 비트는 \(n mod 32\)입니다.

```text
                       0            1
     +-----------+-----------+-----------+--
     |  count    | 31  ..  0 | 63  .. 32 |
     +-----------+-----------+-----------+--
```

---
#### **2.2.9.  change_info4**

```text
   struct change_info4 {
           bool            atomic;
           changeid4       before;
           changeid4       after;
   };
```

이 구조는 CREATE, LINK, REMOVE 및 RENAME 작업과 함께 사용되어 클라이언트가 대상 파일 시스템 개체가 있는 디렉터리에 대한 변경 속성 값을 알 수 있도록 합니다.

---
#### **2.2.10.  clientaddr4**

```text
   struct clientaddr4 {
           /* see struct rpcb in RFC 1833 */
           string r_netid<>;    /* network id */
           string r_addr<>;     /* universal address */
   };
```

clientaddr4 구조는 \(1\) 클라이언트 ID를 사용하는 클라이언트의 주소를 지정하거나 \(2\) 콜백 등록의 일부로 SETCLIENTID 작업의 일부로 사용됩니다. r\_netid 및 r\_addr 필드에는 각각 네트워크 ID와 범용 주소가 포함됩니다. 네트워크 ID 및 범용 주소 개념은 IPv4를 통한 TCP 및 IPv6을 통한 TCP 형식과 함께 \[RFC5665\], 특히 표 2 및 3과 섹션 5.2.3.3 및 5.2.3.4에 정의되어 있습니다.

---
#### **2.2.11.  cb_client4**

```text
   struct cb_client4 {
           unsigned int    cb_program;
           clientaddr4     cb_location;
   };
```

이 구조는 클라이언트가 서버에 콜백 주소를 알리는 데 사용됩니다. 여기에는 프로그램 번호와 클라이언트 주소가 포함됩니다.

---
#### **2.2.12.  nfs_client_id4**

```text
   struct nfs_client_id4 {
           verifier4       verifier;
           opaque          id<NFS4_OPAQUE_LIMIT>;
   };
```

이 구조는 SETCLIENTID 작업에 대한 인수의 일부입니다.

---
#### **2.2.13.  open_owner4**

```text
   struct open_owner4 {
           clientid4       clientid;
           opaque          owner<NFS4_OPAQUE_LIMIT>;
   };
```

이 구조는 열린 상태의 소유자를 식별하는 데 사용됩니다.

---
#### **2.2.14.  lock_owner4**

```text
   struct lock_owner4 {
           clientid4       clientid;
           opaque          owner<NFS4_OPAQUE_LIMIT>;
   };
```

이 구조는 파일 잠금 상태의 소유자를 식별하는 데 사용됩니다.

---
#### **2.2.15.  open_to_lock_owner4**

```text
   struct open_to_lock_owner4 {
           seqid4          open_seqid;
           stateid4        open_stateid;
           seqid4          lock_seqid;
           lock_owner4     lock_owner;
   };
```

이 구조는 open\_owner4에 대해 수행된 첫 번째 LOCK 작업에 사용됩니다. 유효한 open\_stateid 시퀀스에서 새로운 lock\_stateid 시퀀스로 전환이 이루어지도록 open\_stateid와 lock\_owner를 모두 제공합니다. 이 메커니즘을 사용하면 open\_stateid/open\_seqid 형식으로 설정된 상태에 연결되어 있으므로 lock\_owner/lock\_seqid 쌍의 확인을 피할 수 있습니다.

---
#### **2.2.16.  stateid4**

```text
   struct stateid4 {
           uint32_t        seqid;
           opaque          other[NFS4_OTHER_SIZE];
   };
```

이 구조는 클라이언트와 서버 간의 다양한 상태 공유 메커니즘에 사용됩니다. 클라이언트의 경우 이 데이터 구조는 읽기 전용입니다. 서버는 stateid가 전환될 때마다 seqid 필드를 단조롭게 증가시켜야 합니다. 클라이언트는 OPEN stateid의 seqid를 검사하여 서버에서 수행되는 OPEN 처리 순서를 결정하므로 이는 중요합니다.

---
## **3.  RPC and Security Flavor**

NFSv4 프로토콜은 \[RFC5531\] 및 \[RFC4506\]에 정의된 RPC 버전 2와 XDR을 사용하는 RPC 애플리케이션입니다. 버전 1\(\[RFC2203\]\) 및 버전 2\(\[RFC5403\]\)에 정의된 RPCSEC\_GSS 보안 특성은 NFSv4 프로토콜에 대해 더 강력한 보안을 제공하는 메커니즘으로 구현되어야 합니다. 그러나 RPCSEC\_GSS 배포는 선택 사항입니다.\(MUST\)

---
### **3.1.  Ports and Transports**

역사적으로 NFSv2 및 NFSv3 서버는 포트 2049에 상주했습니다. NFS 프로토콜에 대해 등록된 포트 2049\[RFC3232\]가 기본 구성이어야 합니다. NFS 서비스에 등록된 포트를 사용한다는 것은 NFS 클라이언트가 \[RFC1833\]에 설명된 대로 RPC 바인딩 프로토콜을 사용할 필요가 없음을 의미합니다. 이렇게 하면 NFS가 방화벽을 통과할 수 있습니다.\(SHOULD\)

NFSv4 구현이 IP 네트워크 프로토콜을 통한 작업을 지원하는 경우 NFS와 IP 간에 지원되는 전송 계층은 네트워크 정체를 방지하기 위해 지정된 IETF 표준 전송 프로토콜이어야 합니다. 이러한 전송에는 TCP 및 SCTP\(스트림 제어 전송 프로토콜\)가 포함됩니다. 상호 운용성을 향상시키기 위해 NFSv4 구현은 TCP 전송 프로토콜을 통한 작업을 지원해야 합니다.\(MUST, MUST\)

TCP가 전송 수단으로 사용되는 경우 클라이언트와 서버는 영구 연결을 사용해야 합니다. 이는 단기 연결을 통해 TCP의 혼잡 제어가 약화되는 것을 방지하고 SYN 핸드셰이크의 필요성을 제거하여 WAN\(Wide Area Network\) 환경의 성능을 향상시킵니다.\(SHOULD\)

섹션 19에서 설명한 대로 NFSv4의 인증 모델은 머신 기반에서 주체 기반으로 이동했습니다. 그러나 이러한 인증 모델 수정이 다음에 대한 기술적 요구 사항을 의미하지는 않습니다.

TCP 연결 관리 모델을 전체 시스템 기반에서 사용자별 모델 기반으로 이동합니다. 특히 TCP를 통한 NFS 클라이언트 구현은 전통적으로 NFS 클라이언트와 서버 간의 공통 TCP 연결을 통해 여러 사용자에 대한 트래픽을 다중화했습니다. NFS 클라이언트가 AUTH\_SYS, AUTH\_DH, RPCSEC\_GSS 또는 다른 유형을 사용하는지 여부에 관계없이 이는 사실입니다. 마찬가지로 TCP를 통한 NFS 서버 구현에서는 이러한 모델을 가정하고 예상되는 클라이언트 시스템 수에 비례하여 TCP 연결 관리 구현을 확장합니다. NFSv4는 이 연결 관리 모델을 수정하지 않도록 의도되었습니다. 이 가정을 위반하는 NFSv4 클라이언트는 서버에서 확장 문제가 발생하여 서비스가 감소할 수 있습니다.

---
#### **3.1.1.  Client Retransmission Behavior**

TCP와 같은 신뢰할 수 있는 전송을 통해 수신된 NFSv4 요청을 처리할 때 NFSv4 서버는 설정된 전송 연결이 끊어진 경우를 제외하고 요청을 자동으로 삭제해서는 안 됩니다. NFSv4 클라이언트와 서버 간의 계약이 주어지면 클라이언트는 다음 중 하나 또는 둘 다에 해당하지 않는 한 요청을 재시도해서는 안 됩니다.\(MUST NOT, MUST NOT\)

o 전송 연결이 끊어졌습니다.

o 재시도 중인 프로시저가 NULL 프로시저입니다.

TCP와 같은 신뢰할 수 있는 전송은 다른 피어가 연결을 끊었을 때\(예: NFS 서버 재부팅\) 피어에게 항상 동기식으로 알리지 않으므로 NFSv4 클라이언트는 연결을 적극적으로 "탐색"하여 연결이 끊겼는지 확인할 수 있습니다. 깨졌습니다. NULL 프로시저를 사용하는 것이 권장되는 방법 중 하나입니다. 따라서 클라이언트가 원격 프로시저 호출 시간 초과\(임의의 구현별 양\)를 경험하는 경우 원격 프로시저 호출을 다시 시도하는 대신 서버에 NULL 프로시저 호출을 실행할 수 있습니다. 서버가 중단된 경우 전송 연결 중단은 결국 NFSv4 클라이언트에 표시됩니다. 그런 다음 클라이언트는 다시 연결한 다음 원래 요청을 다시 시도할 수 있습니다. NULL 프로시저 호출이 응답을 받으면 연결이 끊어지지 않은 것입니다. 클라이언트는 원래 요청의 응답을 더 오래 기다리기로 결정할 수도 있고, 원래 요청을 다시 보내기 전에 전송 연결을 끊고 다시 연결할 수도 있습니다.

서버에서 클라이언트로의 콜백에도 동일한 규칙이 적용되지만 콜백을 수행하는 서버가 클라이언트가 되고 콜백을 받는 클라이언트가 서버가 됩니다.

---
### **3.2.  Security Flavors**

기존 RPC 구현에는 보안 특성으로 AUTH\_NONE, AUTH\_SYS, AUTH\_DH 및 AUTH\_KRB4가 포함되었습니다. \[RFC2203\]에서는 GSS-API \[RFC2743\]의 기능을 사용하는 RPCSEC\_GSS의 추가 보안 버전이 도입되었습니다. 이를 통해 RPC 보안 기능을 추가하는 추가 구현 오버헤드 없이 RPC 계층에서 다양한 보안 메커니즘을 사용할 수 있습니다. NFSv4의 경우 필수 구현 보안 메커니즘을 활성화하려면 RPCSEC\_GSS 보안 특성을 사용해야 합니다. AUTH\_NONE, AUTH\_SYS 및 AUTH\_DH와 같은 다른 버전도 구현될 수 있습니다.\(MUST, MAY\)

---
#### **3.2.1.  Security Mechanisms for NFSv4**

RPCSEC\_GSS는 GSS-API를 통해 보안 서비스를 제공하는 여러 메커니즘을 지원합니다. 상호 운용성을 위해 NFSv4 클라이언트와 서버는 Kerberos V5 보안 메커니즘을 지원해야 합니다.\(MUST\)

RPCSEC\_GSS를 사용하려면 메커니즘, QOP\(보호 품질\) 및 서비스\(인증, 무결성, 개인 정보 보호\)를 선택해야 합니다. 필수 보안 메커니즘의 경우 NFSv4는 QOP 0이 사용되도록 지정하고 QOP 0을 적절한 보호 수준에 매핑하는 것은 메커니즘 또는 메커니즘의 구성에 달려 있습니다. 각 필수 메커니즘은 무결성 및 개인정보 보호를 구현하기 위한 최소 암호화 알고리즘 세트를 지정합니다. NFSv4 클라이언트와 서버는 각 필수 메커니즘의 필수 암호화 알고리즘을 준수하는 운영 환경에서 구현되어야 합니다.\(MUST\)

---
##### **3.2.1.1.  Kerberos V5 as a Security Triple**

\[RFC4121\]에 설명된 Kerberos V5 GSS-API 메커니즘은 표 2에 지정된 RPCSEC\_GSS 서비스로 구현되어야 합니다. 클라이언트와 서버 모두 각각의 의사 플레이버를 지원해야 합니다.\(MUST, MUST\)

```text
     +--------+-------+----------------------+-----------------------+
     | Number | Name  | Mechanism's OID      | RPCSEC_GSS service    |
     +--------+-------+----------------------+-----------------------+
     | 390003 | krb5  | 1.2.840.113554.1.2.2 | rpc_gss_svc_none      |
     | 390004 | krb5i | 1.2.840.113554.1.2.2 | rpc_gss_svc_integrity |
     | 390005 | krb5p | 1.2.840.113554.1.2.2 | rpc_gss_svc_privacy   |
     +--------+-------+----------------------+-----------------------+

                 Table 2: Mapping Pseudo-Flavor to Service
```

여기에서는 의사 플레이버가 구현자에게 매핑 보조 수단으로 제공됩니다. 이 NFS 프로토콜에는 보안 협상 방법이 포함되어 있고 GSS-API 메커니즘을 이해하고 있기 때문에

의사 맛은 필요하지 않습니다. \[RFC2623\]에 설명된 대로 보안 협상이 MOUNT 프로토콜을 통해 수행되므로 NFSv3에는 의사 플레이버가 필요합니다.

이 문서가 지정된 당시 HMAC-SHA1을 사용한 AES\(Advanced Encryption Standard\)는 Kerberos V5에 대한 필수 알고리즘 세트였습니다. 대조적으로 NFSv4.0이 \[RFC3530\]에서 처음 지정되었을 때 Kerberos V5에는 더 약한 알고리즘 세트가 필수였고 NFSv4.0 사양에서는 필수였습니다. 그 이유는 당시 Kerberos V5 사양이 더 강한 알고리즘을 지정하지 않았기 때문입니다. NFSv4 사양은 Kerberos V5에 필요한 알고리즘을 지정하지 않으며, 대신 더 강력한 알고리즘이 지정되면 구현자는 Kerberos V5 표준의 발전을 추적할 것으로 예상됩니다.\(MUST\)

3.2.1.1.1. Kerberos V5의 암호화 알고리즘에 대한 보안 고려 사항

NFSv4를 배포할 때 달성되는 보안 강도는 기존 Kerberos V5 인프라에 따라 달라집니다. Kerberos V5의 알고리즘은 클라이언트나 서버에 직접 노출되거나 선택 가능하지 않으므로 필요한 경우 보안이 허용되는지 확인하기 위해 NFSv4 사용자가 요구하는 몇 가지 실사가 있습니다. 약한 알고리즘이 기본적으로 비활성화되어야 하는 이유에 대한 지침은 \[RFC6649\]에 제공됩니다.

---
### **3.3.  Security Negotiation**

NFSv4 서버가 잠재적으로 여러 보안 메커니즘을 제공하는 경우 클라이언트는 서버와의 통신에 사용할 메커니즘을 결정하거나 협상하는 방법이 필요합니다. NFS 서버는 NFS 클라이언트가 사용할 수 있는 파일 시스템 네임스페이스 내에 여러 지점을 가질 수 있습니다. 그러면 NFS 서버는 이러한 각 진입점이 서로 다르거나 여러 보안 메커니즘을 사용할 수 있도록 구성될 수 있습니다.

클라이언트와 서버 간의 보안 협상은 제3자가 협상 순서를 가로채고 클라이언트와 서버가 필요하거나 원하는 것보다 낮은 수준의 보안을 선택하도록 강요할 가능성을 제거하기 위해 보안 채널을 사용하여 수행되어야 합니다. 자세한 내용은 섹션 19를 참조하세요.\(SHOULD\)

---
#### **3.3.1.  SECINFO**

SECINFO 작업을 통해 클라이언트는 파일 핸들별로 어떤 보안 트리플\(\[RFC2743\] 및 섹션 16.31.4 참조\)을 서버 액세스에 사용할지 결정할 수 있습니다. 일반적으로 클라이언트는 서버와의 초기 통신 중이나 클라이언트가 네임스페이스를 탐색할 때 새 보안 정책을 발견하는 경우를 제외하고는 SECINFO 작업을 사용할 필요가 없습니다. 어느 조건이든 클라이언트는 새로운 보안 트리플을 협상해야 합니다.

---
#### **3.3.2.  Security Error**

각 NFSv4 클라이언트와 서버가 최소 보안 세트\(예: RPCSEC\_GSS의 Kerberos V5\)를 지원해야 한다는 가정에 따라 NFS 클라이언트는 최소 보안 트리플 중 하나를 사용하여 서버와의 통신을 시작합니다. 서버와 통신하는 동안 클라이언트는 NFS4ERR\_WRONGSEC의 NFS 오류를 수신할 수 있습니다. 이 오류를 통해 서버는 현재 사용 중인 보안 트리플이 서버의 파일 시스템 리소스에 액세스하는 데 적합하지 않음을 클라이언트에 알릴 수 있습니다. 그런 다음 클라이언트는 서버에서 사용할 수 있는 보안 트리플을 결정하고 클라이언트에 적합한 보안 트리플을 선택해야 합니다. 클라이언트가 NFS4ERR\_WRONGSEC 오류에 응답하고 SECINFO를 사용하는 방법에 대한 자세한 내용은 섹션 16.31을 참조하세요.\(MUST\)

---
#### **3.3.3.  Callback RPC Authentication**

이 섹션의 다른 부분에 명시된 경우를 제외하고 콜백 RPC\(나중에 설명\)는 사용된 원래 SETCLIENTID 작업의 보안 방식을 사용하여 클라이언트 ID\(나중에 설명\)를 획득한 주체에 대해 NFS 서버를 상호 인증해야 합니다.\(MUST\)

AUTH\_NONE의 경우 주체가 없으므로 이는 문제가 되지 않습니다.

AUTH\_SYS에는 상호 인증이나 서버 주체에 대한 개념이 없으므로 서버의 콜백은 사용자가 위임을 설정할 때 사용한 AUTH\_SYS 자격 증명을 사용합니다.

AUTH\_DH의 경우 일반적으로 사용되는 규칙 중 하나는 서버가 이 AUTH\_DH 주체에 해당하는 자격 증명을 사용한다는 것입니다.

```text
     unix.host@domain
```

여기서 호스트 및 도메인은 네트워크 정보 시스템 도메인 또는 DNS 도메인과 같이 서버 호스트 및 해당 호스트가 있는 디렉터리 서비스 도메인의 이름에 해당하는 변수입니다.

RPCSEC\_GSS에서 사용되는 보안 메커니즘에 관계없이 NFS 서버는 GSS\_C\_NT\_HOSTBASED\_SERVICE 이름 유형을 통해 GSS-API에서 자신을 식별해야 합니다. GSS\_C\_NT\_HOSTBASED\_SERVICE 이름의 형식은 다음과 같습니다.\(MUST\)

```text
     service@hostname
```

NFS의 경우 "service" 요소는 다음과 같습니다.

```text
     nfs
```

보안 메커니즘을 구현하면 nfs@hostname을 다양한 형식으로 변환합니다. Kerberos V5의 경우 다음 형식이 권장됩니다.\(SHOULD\)

```text
     nfs/hostname
```

Kerberos V5의 경우 nfs/hostname은 Kerberos 키 배포 센터 데이터베이스의 서버 주체가 됩니다. 이는 클라이언트가 SETCLIENTID 작업을 실행할 때 GSS-API 컨텍스트를 획득한 것과 동일한 주체입니다. 따라서 서버 주체의 영역 이름은 SETCLIENTID의 경우와 마찬가지로 콜백의 경우에도 동일해야 합니다.

---
## **4.  Filehandles**

NFS 프로토콜의 파일 핸들은 파일 시스템 개체에 대한 서버별 고유 식별자입니다. 파일 핸들의 내용은 클라이언트에게 불투명합니다. 따라서 서버는 파일 핸들을 파일 시스템 개체의 내부 표현으로 변환하는 일을 담당합니다.

---
### **4.1.  Obtaining the First Filehandle**

NFS 프로토콜의 작업은 하나 이상의 파일 핸들 측면에서 정의됩니다. 따라서 클라이언트는 서버와의 통신을 시작하기 위해 파일 핸들이 필요합니다. NFSv2 프로토콜 \[RFC1094\] 및 NFSv3 프로토콜 \[RFC1813\]에는 이 첫 번째 파일 핸들을 얻기 위한 보조 프로토콜이 존재합니다. MOUNT 프로토콜\(RPC 프로그램 번호 100005\)은 문자열 기반 파일 시스템 경로 이름을 NFS 프로토콜에서 사용할 수 있는 파일 핸들로 변환하는 메커니즘을 제공합니다.

MOUNT 프로토콜은 보안 및 방화벽을 통한 사용 측면에서 결함이 있습니다. 이것이 \[RFC2054\] 및 \[RFC2055\]에서 공개 파일 핸들의 사용이 도입된 이유 중 하나입니다. LOOKUP 작업과 함께 공용 파일 핸들을 사용하면

NFSv2 및 NFSv3 프로토콜에서는 NFS 클라이언트와 서버 간의 실행 가능한 상호 작용에 MOUNT 프로토콜이 필요하지 않다는 것이 입증되었습니다.

따라서 NFSv4 프로토콜은 문자열 기반 경로 이름을 파일 핸들로 변환하기 위해 보조 프로토콜을 사용하지 않습니다. 두 개의 특수 파일 핸들이 NFS 클라이언트의 시작점으로 사용됩니다.

---
#### **4.1.1.  Root Filehandle**

특수 파일 핸들 중 첫 번째는 루트 파일 핸들입니다. 루트 파일 핸들은 NFS 서버에 있는 파일 시스템 네임스페이스의 "개념적" 루트입니다. 클라이언트는 PUTROOTFH 작업을 사용하여 루트 파일 핸들을 사용하거나 시작합니다. PUTROOTFH 작업은 서버에 현재 파일 핸들을 서버 파일 트리의 루트로 설정하도록 지시합니다. 이 PUTROOTFH 작업이 사용되면 클라이언트는 LOOKUP 작업을 통해 서버의 파일 트리 전체를 탐색할 수 있습니다. 서버 네임스페이스에 대한 전체 논의는 섹션 7에 있습니다.

---
#### **4.1.2.  Public Filehandle**

두 번째 특수 파일핸들은 공용 파일핸들입니다. 루트 파일 핸들과 달리 공용 파일 핸들은 서버에서 임의의 파일 시스템 개체를 바인딩하거나 나타낼 수 있습니다. 서버는 이 바인딩을 담당합니다. 공용 파일 핸들과 루트 파일 핸들이 동일한 파일 시스템 객체를 참조할 수도 있습니다. 그러나 공용 파일 핸들과 서버 파일 시스템 개체의 바인딩을 정의하는 것은 서버의 관리 소프트웨어와 서버 관리자의 정책에 달려 있습니다. 클라이언트는 이 바인딩에 대해 어떤 가정도 하지 않을 수 있습니다. 클라이언트는 PUTPUBFH 작업을 통해 공용 파일 핸들을 사용합니다.

---
### **4.2.  Filehandle Types**

NFSv2 및 NFSv3 프로토콜에는 단일 의미 집합을 갖는 한 가지 유형의 파일 핸들이 있었는데, 그 중 가장 중요한 것은 서버 재부팅 시에도 지속된다는 점이었습니다. 따라서 NFSv4에서는 이러한 유형의 파일 핸들을 "영구적"이라고 합니다. 영구 파일 핸들의 의미는 이전과 동일하게 유지됩니다. NFSv4에 도입된 새로운 유형의 파일 핸들은 특정 서버 환경을 수용하려고 시도하는 휘발성 파일 핸들입니다.

영구 파일 핸들의 올바른 구현을 불가능하게 만드는 서버 기능 또는 구현 문제를 해결하기 위해 휘발성 파일 핸들 유형이 도입되었습니다. 일부 서버 환경에서는 영구 파일 핸들을 구성하는 데 사용할 수 있는 파일 시스템 수준 불변성을 제공하지 않습니다. 기본 서버

파일 시스템이 불변성을 제공하지 않거나 서버의 파일 시스템 프로그래밍 인터페이스가 필요한 불변성에 대한 액세스를 제공하지 못할 수 있습니다. 휘발성 파일 핸들은 계층적 저장소 관리, 파일 시스템 재구성 또는 마이그레이션과 같은 서버 기능의 구현을 용이하게 할 수 있습니다. 그러나 휘발성 파일 핸들은 클라이언트의 구현 부담을 증가시킵니다.

클라이언트는 영구 파일 핸들과 휘발성 파일 핸들을 다르게 처리해야 하므로 클라이언트가 서버에서 반환하는 파일 핸들 유형을 결정하는 데 사용할 수 있는 파일 속성이 정의됩니다.

---
#### **4.2.1.  General Properties of a Filehandle**

파일 핸들에는 서버가 개별 파일을 구별하는 데 필요한 모든 정보가 포함되어 있습니다. 클라이언트에게는 파일 핸들이 불투명합니다. 클라이언트는 이후 요청에 사용할 파일 핸들을 저장하고 바이트 단위 비교를 수행하여 동일한 서버의 두 파일 핸들이 동일한지 비교할 수 있습니다. 그러나 클라이언트는 파일 핸들의 내용을 달리 해석해서는 안 됩니다. 동일한 서버의 두 파일 핸들이 동일한 경우 동일한 파일을 참조해야 합니다. 그러나 두 개의 서로 다른 파일 핸들이 서로 다른 파일 시스템 개체를 참조할 필요는 없습니다. 서버는 파일 핸들과 파일 시스템 개체 간의 일대일 대응을 유지하려고 노력해야 하지만 매핑이 일대일이 아닌 상황이 있을 수 있습니다. 클라이언트는 올바른 동작이 아닌 성능 향상을 위해서만 파일 핸들 비교를 사용해야 합니다. 모든 클라이언트는 두 개의 서로 다른 파일 핸들이 동일한 객체를 나타내는지 여부를 확인할 수 없는 상황에 대비해야 하며, 이러한 경우 표시된 객체가 다르다고 가정하는 것을 피해야 합니다. 이로 인해 잘못된 동작이 발생할 수 있습니다. 데이터 캐싱의 맥락에서 파일 핸들과 속성 비교에 대한 추가 논의는 섹션 10.3.4에 나와 있습니다.\(MUST NOT, MUST, SHOULD, MUST\)

예를 들어, 서버에서 탐색할 때 두 개의 서로 다른 경로 이름이 동일한 파일 시스템 개체에서 종료되는 경우 서버는 각 경로에 대해 동일한 파일 핸들을 반환해야 합니다\(SHOULD\). 이는 동일한 기본 파일 객체 및 관련 데이터를 참조하는 두 개의 파일 이름을 생성하기 위해 하드 링크를 사용하는 경우 발생할 수 있습니다. 예를 들어, /a/b/c 및 /a/d/c 경로가 동일한 파일을 참조하는 경우 서버는 두 경로 이름 탐색에 대해 동일한 파일 핸들을 반환해야 합니다\(SHOULD\).\(SHOULD, SHOULD\)

---
#### **4.2.2.  Persistent Filehandle**

영구 파일 핸들은 참조하는 파일 시스템 객체의 수명 동안 고정된 값을 갖는 것으로 정의됩니다. 서버가 파일 시스템 개체에 대한 파일 핸들을 생성하면 서버는 해당 개체의 수명 동안 동일한 파일 핸들을 수락해야 합니다.\(MUST\)

그 물체. 서버가 다시 시작되거나 재부팅되면 NFS 서버는 서버의 이전 인스턴스화에서와 동일한 파일 핸들 값을 적용해야 합니다. 마찬가지로, 파일 시스템이 마이그레이션되면 새 NFS 서버는 이전 NFS 서버와 동일한 파일 핸들을 사용해야 합니다.

파일 시스템 개체가 제거되면 영구 파일 핸들이 오래되거나 유효하지 않게 됩니다. 서버에 삭제된 객체를 참조하는 영구 파일 핸들이 표시되면 NFS4ERR\_STALE 오류를 반환해야 합니다. 객체를 포함하는 파일 시스템을 더 이상 사용할 수 없으면 파일 핸들이 오래될 수 있습니다. 파일 시스템이 이동식 미디어에 존재하고 해당 미디어를 서버에서 더 이상 사용할 수 없는 경우, 파일 시스템 전체가 삭제된 경우 또는 파일 시스템이 서버의 네임스페이스에서 단순히 제거된 경우\(예: UNIX 환경에서는 마운트 해제됨\).\(MUST\)

---
#### **4.2.3.  Volatile Filehandle**

휘발성 파일 핸들은 영구 파일 핸들과 동일한 수명 특성을 공유하지 않습니다. 서버는 여러 시점에서 휘발성 파일 핸들이 더 이상 유효하지 않다고 판단할 수 있습니다. 서버가 휘발성 파일 핸들이 제거된 객체를 참조한다는 것을 확실히 확인할 수 있는 경우 서버는 NFS4ERR\_STALE을 클라이언트에 반환해야 합니다\(영구 파일 핸들의 경우와 마찬가지로\). 서버가 휘발성 파일 핸들을 더 이상 사용할 수 없다고 판단하는 다른 모든 경우에는 NFS4ERR\_FHEXPIRED 오류를 반환해야 합니다.

필수 속성 "fh\_expire\_type"은 클라이언트가 서버가 특정 파일 시스템에 제공하는 파일 핸들 유형을 결정하는 데 사용됩니다. 이 속성은 다음 값을 가진 비트마스크입니다.\(MUST\)

FH4\_PERSISTENT: FH4\_PERSISTENT 값은 객체가 파일 시스템에서 제거될 때까지 유효한 영구 파일 핸들을 나타내는 데 사용됩니다. 서버는 이 파일 핸들에 대해 NFS4ERR\_FHEXPIRED를 반환하지 않습니다. FH4\_PERSISTENT는 아래에 명시된 비트가 하나도 설정되지 않은 값으로 정의됩니다.

FH4\_VOLATILE\_ANY: 파일 핸들은 특별히 제외된 경우\(예: FH4\_NOEXPIRE\_WITH\_OPEN\)를 제외하고 언제든지 만료될 수 있습니다.

FH4\_NOEXPIRE\_WITH\_OPEN: FH4\_VOLATILE\_ANY가 설정된 경우에만 설정할 수 있습니다. 이 비트가 설정되면 FH4\_VOLATILE\_ANY의 의미는 파일 핸들이 열려 있을 때 파일 핸들의 만료를 제외하도록 규정됩니다.

FH4\_VOL\_MIGRATION: 파일 핸들은 마이그레이션 결과로 만료됩니다. FH4\_VOLATILE\_ANY가 설정된 경우 FH4\_VOL\_MIGRATION은 중복됩니다.

FH4\_VOL\_RENAME: 이름을 바꾸는 동안 파일 핸들이 만료됩니다. 여기에는 요청 클라이언트에 의한 이름 바꾸기 또는 다른 클라이언트에 의한 이름 바꾸기가 포함됩니다. FH4\_VOLATILE\_ANY가 설정된 경우 FH4\_VOL\_RENAME은 중복됩니다.

열려 있는 동안 만료될 수 있는 휘발성 파일 핸들을 제공하는 서버\(예: FH4\_VOL\_MIGRATION 또는 FH4\_VOL\_RENAME이 설정되거나 FH4\_VOLATILE\_ANY가 설정되고 FH4\_NOEXPIRE\_WITH\_OPEN이 설정되지 않은 경우\)는 다음으로 이어지는 구성 요소의 OPEN 파일에 영향을 줄 수 있는 RENAME 또는 REMOVE를 거부해야 합니다. 파일을 엽니다. 또한 서버는 서버 재시작 시 유예 기간 동안 모든 RENAME 또는 REMOVE 요청을 거부해야 합니다.\(SHOULD\)

FH4\_VOL\_MIGRATION 및 FH4\_VOL\_RENAME 비트를 사용하면 서버에서 명시적인 파일 핸들 만료 오류 없이 특정 이벤트가 발생할 때마다 클라이언트가 만료가 발생했음을 확인할 수 있습니다. FH4\_VOLATILE\_ANY는 이러한 형태의 정보를 제공하지 않습니다. 서버가 마이그레이션 시 전부는 아니지만 많은 파일 핸들을 만료시키는 상황에서는\(예: 열려 있는 파일 핸들을 제외한 모든 파일 핸들\) FH4\_VOLATILE\_ANY\(이 경우 FH4\_NOEXPIRE\_WITH\_OPEN 사용\)가 더 나은 선택입니다. 클라이언트가 모든 파일 핸들이 마이그레이션이 발생하면 만료되며, 마이그레이션 이벤트 자체와 시간적으로 분리되어 추가 만료가 발생할 가능성이 높습니다\(파일 CLOSE의 결과\).

---
#### **4.2.4.  One Method of Constructing a Volatile Filehandle**

휘발성 파일 핸들은 클라이언트에게는 불투명하지만 다음을 포함할 수 있습니다.

```text
     [volatile bit = 1 | server boot time | slot | generation number]
```

o 슬롯은 서버 휘발성 파일 핸들 테이블의 인덱스입니다.

o 세대 번호는 테이블의 세대 번호입니다.

- 입장/슬롯

클라이언트가 휘발성 파일 핸들을 제시하면 서버는 휘발성 비트에 대한 검사가 통과되었다고 가정하여 다음 검사를 수행합니다. 서버 부팅 시간이 현재 서버 부팅 시간보다 짧으면 NFS4ERR\_FHEXPIRED를 반환합니다. 슬롯이 범위를 벗어나면 NFS4ERR\_BADHANDLE을 반환합니다. 세대 번호가 일치하지 않으면 NFS4ERR\_FHEXPIRED를 반환합니다.

서버가 재부팅되면 테이블이 사라집니다\(휘발성임\).

휘발성 비트가 0이면 그 뒤에 다른 구조가 있는 영구 파일 핸들입니다.

---
### **4.3.  Client Recovery from Filehandle Expiration**

가능하다면 클라이언트는 NFS4ERR\_FHEXPIRED 오류 수신을 복구해야 합니다. 클라이언트는 휘발성 파일 핸들의 만료로부터 복구할 준비를 할 수 있도록 추가 책임을 져야 합니다. 서버가 영구 파일 핸들을 반환하는 경우 클라이언트에는 이러한 추가 단계가 필요하지 않습니다.

휘발성 파일 핸들의 경우 가장 일반적으로 클라이언트는 문제의 파일 시스템 개체를 포함하여 이어지는 구성 요소 이름을 저장해야 합니다. 이러한 이름을 사용하면 클라이언트는 여전히 사용 가능한 네임스페이스에서 파일 핸들을 찾거나 서버의 파일 시스템 네임스페이스 루트에서 시작하여 복구할 수 있어야 합니다.

만료된 파일 핸들이 파일 시스템에서 제거된 개체를 참조하는 경우 클라이언트는 만료된 파일 핸들에서 복구할 수 없습니다.

만료된 파일 핸들이 이름이 변경된 파일을 참조할 수도 있습니다. 다른 클라이언트가 파일 이름을 바꾼 경우 원래 클라이언트가 복구하지 못할 수도 있습니다. 그러나 클라이언트 자체가 파일 이름을 바꾸는 중이고 파일이 열려 있는 경우에는 클라이언트가 복구할 수도 있습니다. 클라이언트는 이름 바꾸기 요청 처리를 기반으로 새 경로 이름을 결정할 수 있습니다. 그런 다음 클라이언트는 새 경로 이름을 기반으로 새 파일 핸들을 다시 생성할 수 있습니다. 클라이언트는 COMPOUND 작업 메커니즘을 사용하여 다음과 같은 작업 집합을 구성할 수도 있습니다.

```text
     RENAME A B
     LOOKUP B
     GETFH
```

COMPOUND 프로시저는 원자성을 제공하지 않습니다. 이 예는 만료된 파일 핸들에서 복구하는 오버헤드만 줄입니다.

---
## **5.  Attributes**

확장성 및 비 UNIX 플랫폼과의 상호 운용성 향상 요구 사항을 충족하려면 속성을 유연한 방식으로 처리해야 합니다. NFSv3 fattr3 구조에는 모든 클라이언트와 서버가 할 수 없는 고정된 속성 목록이 포함되어 있습니다.

지원하거나 관심을 갖습니다. fattr3 구조는 새로운 요구가 발생할 때 확장될 수 없으며 지원되지 않음을 나타낼 방법을 제공하지 않습니다. NFSv4.0 프로토콜을 사용하면 클라이언트는 서버가 지원하는 속성을 쿼리하고 지원되는 속성\(또는 그 하위 집합\)만으로 요청을 구성할 수 있습니다.

이를 위해 속성은 REQUIRED, RECOMMENDED 및 명명된 세 그룹으로 나뉩니다. REQUIRED 및 RECOMMENDED 속성은 NFSv4.0 프로토콜에서 구체적이고 잘 정의된 인코딩으로 지원되며 숫자로 식별됩니다. GETATTR 요청에서 전송된 비트 벡터에 비트를 설정하여 요청됩니다. 서버 응답에는 응답에 반환된 속성을 나열하는 비트 벡터가 포함되어 있습니다. 새로운 REQUIRED 또는 RECOMMENDED 속성은 새로운 속성 번호 값을 할당하고 속성에 대한 인코딩을 정의하는 표준 트랙 RFC를 게시하여 새로운 마이너 버전의 일부로 NFSv4 프로토콜에 추가될 수 있습니다. 자세한 내용은 섹션 11을 참조하세요.\(MUST, MUST, MUST\)

명명된 속성은 파일 시스템 객체와 연관된 속성의 숨겨진 디렉터리에 액세스하는 OPENATTR 작업을 통해 액세스됩니다. OPENATTR은 객체에 대한 파일 핸들을 취하고 속성 계층에 대한 파일 핸들을 반환합니다. 명명된 속성에 대한 파일 핸들은 LOOKUP 또는 READDIR로 액세스할 수 있는 디렉터리 개체이며 이름이 명명된 속성을 나타내고 데이터 바이트가 속성의 값인 파일을 포함합니다. 예를 들어:

```text
        +----------+-----------+---------------------------------+
        | LOOKUP   | "foo"     | ; look up file                  |
        | GETATTR  | attrbits  |                                 |
        | OPENATTR |           | ; access foo's named attributes |
        | LOOKUP   | "x11icon" | ; look up specific attribute    |
        | READ     | 0,4096    | ; read stream of bytes          |
        +----------+-----------+---------------------------------+
```

명명된 속성은 NFS 클라이언트 구현이 아닌 애플리케이션에 필요한 데이터를 위한 것입니다. NFS 구현자는 새로운 속성을 IETF 표준 추적 프로세스에 적용하여 RECOMMENDED 속성으로 정의하도록 적극 권장됩니다.\(SHOULD\)

REQUIRED로 분류된 속성 세트는 서버가 이를 지원하기 위해 필요한 모든 작업을 수행해야 하기 때문에 의도적으로 작습니다. 서버는 가능한 한 많은 RECOMMENDED 속성을 지원해야 합니다. 그러나 정의에 따르면 서버가 이들 모두를 지원할 필요는 없습니다. 데이터가 다수의 클라이언트에 의해 필요하고 서버에서 지원이 제공되지 않을 때 클라이언트가 합리적으로 계산할 수 없는 경우 속성은 필수로 간주됩니다.\(MUST, SHOULD, MUST\)

OPENATTR에 의해 반환된 숨겨진 디렉터리는 프로토콜 처리의 편의를 위한 것입니다. 클라이언트는 서버의 명명된 속성 구현과 서버의 기본 파일 시스템에 명명된 속성 디렉터리가 있는지 여부에 대해 어떤 가정도 해서는 안 됩니다. 따라서 명명된 특성 디렉터리에 대한 SETATTR 및 GETATTR과 같은 작업은 정의되지 않습니다.

---
### **5.1.  REQUIRED Attributes**

최소 수준의 상호 운용성을 보장하려면 이러한 속성을 모든 NFSv4.0 클라이언트 및 서버에서 지원해야 합니다. 서버는 이러한 속성을 저장하고 반환해야 하며\(MUST\), 클라이언트는 이러한 속성으로 제한된 속성 세트로 작동할 수 있어야 합니다\(MUST\). 필수 속성만 사용하면 일부 클라이언트 기능이 어떤 방식으로든 손상되거나 제한될 수 있습니다. 클라이언트는 GETATTR 요청에서 비트를 설정하여 이러한 속성이 반환되도록 요청할 수 있습니다. 이러한 각 비트 세트에 대해 서버는 해당 속성 값을 반환해야 합니다.\(MUST, MUST, MUST, MUST\)

---
### **5.2.  RECOMMENDED Attributes**

이러한 속성은 NFSv4.0 프로토콜의 지원을 보증할 만큼 충분히 잘 이해되어 있습니다. 그러나 일부 클라이언트 및 서버에서는 지원되지 않을 수 있습니다. 클라이언트는 GETATTR 요청에 비트를 설정하여 이러한 속성이 반환되도록 요청할 수 있지만 서버가 해당 속성을 반환하지 않는 경우를 처리해야 합니다. 클라이언트는 서버가 지원하는 속성 세트를 요청할 수 있으며 서버가 지원하지 않는 속성을 요청해서는 안 됩니다. 서버는 지원되지 않는 속성에 대한 요청을 허용해야 하며 요청을 오류로 간주하기보다는 단순히 해당 속성을 반환하지 않아야 합니다. 서버는 편안하게 할 수 있는 모든 속성을 지원하고 운영 환경에서 지원하기 어려운 속성만 지원하지 못할 것으로 예상됩니다. 서버는 클라이언트에게 "거짓말"을 할 필요가 없을 때마다 속성을 제공해야 합니다. 예를 들어, 파일 수정 시간은 정확한 시간이어야 하거나 서버에서 지원하지 않아야 합니다. 때로는 이것이 내담자에게 어려울 수도 있지만, 내담자는 속성을 조작하거나 구성할지 여부와 속성 없이 수행할지 여부와 방법을 결정하는 데 더 나은 위치에 있습니다.\(MUST, SHOULD NOT\)

---
### **5.3.  Named Attributes**

이러한 속성은 NFSv4 프로토콜의 직접 인코딩에서는 지원되지 않지만 숫자가 아닌 문자열 이름으로 액세스되며 파일 시스템 개체와 함께 저장되는 해석되지 않은 바이트 스트림에 해당합니다. 이러한 속성의 네임스페이스는 OPENATTR 작업을 사용하여 액세스할 수 있습니다. OPENATTR 작업은 가상 "명명된 속성 디렉터리"에 대한 파일 핸들을 반환합니다.

보다 일반적인 디렉터리에서 작동하는 작업을 사용하여 네임스페이스를 더 자세히 살펴보고 수정할 수 있습니다. 특히, READDIR은 그러한 명명된 속성의 목록을 가져오는 데 사용될 수 있으며 LOOKUP 및 OPEN은 특정 속성을 선택할 수 있습니다. 새로운 명명된 속성의 생성은 파일 생성을 지정하는 OPEN의 결과일 수 있습니다.

OPEN이 완료되면 명명된 속성은 OPEN에서 반환된 파일 핸들 및 상태 ID를 사용하여 일반적인 READ 및 WRITE 작업으로 검사하고 변경할 수 있습니다.

명명된 속성과 명명된 속성 디렉터리에는 고유한\(이름이 지정되지 않은\) 속성이 있을 수 있습니다. 이러한 각 개체에는 필수 속성이 모두 있어야 하며 추가 RECOMMENDED 속성이 있을 수도 있습니다. 그러나 명명된 속성 및 명명된 속성 디렉터리에 대한 속성 집합은 해당 파일 시스템의 다른 객체에 대한 집합만큼 클 필요는 없으며 일반적으로 클 필요도 없습니다.\(MUST\)

명명된 속성은 위임 대상이 될 수 있습니다. 그러나 위임 부여 여부는 서버의 재량에 따르므로 서버는 명명된 속성에 대한 위임을 지원할 필요가 없습니다.

서버가 임의의 명명된 속성을 지원하는 것이 좋습니다. 클라이언트는 서버의 파일 시스템에 명명된 속성을 저장하는 기능에 의존해서는 안 됩니다. 서버가 명명된 속성을 지원하는 경우 이를 처리할 수 있는 클라이언트는 파일의 데이터와 메타데이터를 한 위치에서 다른 위치로 완전히 투명하게 복사할 수 있어야 합니다. 이는 일반 디렉토리 항목에 허용되는 이름이 명명된 속성 이름에도 유효함을 의미합니다.\(SHOULD\)

NFSv4.0에서는 일부 서버가 명명된 속성에 대해 완전히 일반적인 계층적 디렉터리 구조를 지원하는 반면 다른 서버는 제한적이지만 명명된 속성에 대한 적절한 구조. 이러한 환경에서는 클라이언트나 애플리케이션이 이식 불가능한 확장에 의존하게 될 수 있습니다. 제한사항은 다음과 같습니다.

o 명명된 속성 디렉터리에서는 CREATE가 허용되지 않습니다. 따라서 기호 링크 및 특수 파일과 같은 객체에는 이름 속성이 허용되지 않습니다. 또한 명명된 특성 디렉터리에는 디렉터리를 생성할 수 없으므로 단일 개체에 대한 명명된 특성의 계층 구조는 허용되지 않습니다.

o 명명된 속성 디렉터리 또는 명명된 속성에서 OPENATTR이 수행되면 서버는 오류를 반환해야 합니다.\(MUST\)

o 다른 명명된 속성 디렉토리 또는 일반\(즉, 명명되지 않은 속성\) 디렉토리에 대해 명명된 속성의 RENAME을 수행하는 것은 허용되지 않습니다.

o 명명된 특성 디렉터리 간 또는 명명된 특성 디렉터리와 일반 디렉터리 간에 하드 링크를 만드는 것은 허용되지 않습니다.

속성 이름은 이 문서나 다른 IETF 표준 트랙 문서에 의해 제어되지 않습니다. 자세한 내용은 섹션 20을 참조하세요.

---
### **5.4.  Classification of Attributes**

SETATTR 및 GETATTR을 사용하여 액세스되는 각 속성\(예: REQUIRED 및 RECOMMENDED 속성\)은 세 가지 범주 중 하나로 분류될 수 있습니다.\(MUST\)

1. 속성 값이 동일한 서버를 공유하는 모든 파일 객체에 대해 동일해지는 서버별 속성.

2. 동일한 서버 및 fsid 속성을 공유하는 일부 또는 모든 파일 객체에 대해 속성 값이 동일한 파일별 시스템 속성\(섹션 5.8.1.9\). 공유가 적용되는 시기에 대한 자세한 내용은 아래를 참조하세요.

```text
   3.  per-file system object attributes.
```

파일별 시스템 속성 처리는 특정 속성과 동종\(5.8.2.12절\) 속성의 설정에 따라 달라집니다. 다음 규칙이 적용됩니다.

1. Supported\_attrs, fsid, Homogeneous, link\_support 및 Symlink\_support 속성의 값은 항상 지정된 파일 시스템 내의 모든 개체에 공통됩니다.

2. 다른 속성의 경우, 동종 속성이 문제의 파일 시스템 내에서 지원되고 값이 false인 경우 다른 파일 시스템 개체에 대해 다른 값이 반환될 수 있습니다.

속성의 분류는 다음과 같습니다. time\_access\_set 및 time\_modify\_set 속성은 time\_access 및 time\_modify에 해당하는 쓰기 전용 속성이고 SETATTR의 특수 인스턴스에서 사용되기 때문에 이 섹션에 나열되지 않습니다.

o 서버별 속성은 다음과 같습니다.

```text
         lease_time
```

o 파일 시스템별 속성은 다음과 같습니다.

- 지원되는\_attrs, fh\_expire\_type, link\_support, Symlink\_support, Unique\_handles, aclsupport, cansettime, Case\_insensitive, Case\_preserving, chown\_restricted, files\_avail, files\_free, files\_total, fs\_locations, Homogeneous, maxfilesize, maxname, maxread, maxwrite, no\_trunc, space\_avail, space\_free, space\_total 및 time\_delta

o 파일 시스템별 개체 속성은 다음과 같습니다.

- 유형, 변경, 크기, 명명된\_attr, fsid, rdattr\_error, 파일 핸들, acl, 아카이브, 파일 ID, 숨김, maxlink, mimetype, 모드, numlinks, 소유자, owner\_group, rawdev, space\_used, 시스템, time\_access, time\_backup, time\_create, time\_metadata, time\_modify 및 Mounted\_on\_fileid

quota\_avail\_hard, quota\_avail\_soft 및 quota\_used의 경우 적절한 분류에 대해서는 아래 정의를 참조하세요.

---
### **5.5.  Set-Only and Get-Only Attributes**

일부 REQUIRED 및 RECOMMENDED 속성은 설정 전용입니다. 즉, SETATTR을 통해 설정할 수 있지만 GETATTR을 통해 검색할 수는 없습니다. 마찬가지로 일부 REQUIRED 및 RECOMMENDED 속성은 가져오기 전용입니다. 즉, GETATTR을 통해 검색할 수 있지만 SETATTR을 통해 설정할 수는 없습니다. 클라이언트가 get-only 속성을 설정하거나 set-only 속성을 얻으려고 시도하는 경우 서버는 NFS4ERR\_INVAL을 반환해야 합니다.\(MUST, MUST, MUST\)

---
### **5.6.  REQUIRED Attributes - List and Definition References**

필수 속성 목록은 표 3에 나와 있습니다. 표 열의 의미는 다음과 같습니다.\(MUST\)

o 이름: 속성의 이름입니다.

o ID: 속성에 할당된 번호입니다. 할당된 번호와 \[RFC7531\] 사이에 충돌이 있는 경우 후자가 권위가 있지만 그러한 경우에는 이 문서 및/또는 \[RFC7531\]에 대한 정오표로 해결되어야 합니다. 정오표 프로세스는 \[IESG\_ERRATA\]를 참조하세요.

o 데이터 유형: 속성의 XDR 데이터 유형입니다.

o Acc: 속성에 대한 액세스가 허용됩니다. R은 읽기 전용을 의미합니다\(GETATTR은 검색할 수 있고 SETATTR은 설정할 수 없음\). W는 쓰기 전용을 의미합니다\(SETATTR은 설정할 수 있고 GETATTR은 검색할 수 없음\). R W는 읽기/쓰기를 의미합니다\(GETATTR은 검색할 수 있고 SETATTR은 설정할 수 있음\).

o 정의: 속성을 설명하는 본 사양의 섹션입니다.

```text
      +-----------------+----+------------+-----+-------------------+
      | Name            | ID | Data Type  | Acc | Defined in        |
      +-----------------+----+------------+-----+-------------------+
      | supported_attrs | 0  | bitmap4    | R   | Section 5.8.1.1   |
      | type            | 1  | nfs_ftype4 | R   | Section 5.8.1.2   |
      | fh_expire_type  | 2  | uint32_t   | R   | Section 5.8.1.3   |
      | change          | 3  | changeid4  | R   | Section 5.8.1.4   |
      | size            | 4  | uint64_t   | R W | Section 5.8.1.5   |
      | link_support    | 5  | bool       | R   | Section 5.8.1.6   |
      | symlink_support | 6  | bool       | R   | Section 5.8.1.7   |
      | named_attr      | 7  | bool       | R   | Section 5.8.1.8   |
      | fsid            | 8  | fsid4      | R   | Section 5.8.1.9   |
      | unique_handles  | 9  | bool       | R   | Section 5.8.1.10  |
      | lease_time      | 10 | nfs_lease4 | R   | Section 5.8.1.11  |
      | rdattr_error    | 11 | nfsstat4   | R   | Section 5.8.1.12  |
      | filehandle      | 19 | nfs_fh4    | R   | Section 5.8.1.13  |
      +-----------------+----+------------+-----+-------------------+

                       Table 3: REQUIRED Attributes
```

---
### **5.7.  RECOMMENDED Attributes - List and Definition References**

RECOMMENDED 속성은 표 4에 정의되어 있습니다. 열 헤더의 의미는 표 3과 동일합니다. 의미는 섹션 5.6을 참조하십시오.\(SHOULD\)

```text
   +-------------------+----+-----------------+-----+------------------+
   | Name              | ID | Data Type       | Acc | Defined in       |
   +-------------------+----+-----------------+-----+------------------+
   | acl               | 12 | nfsace4<>       | R W | Section 6.2.1    |
   | aclsupport        | 13 | uint32_t        | R   | Section 6.2.1.2  |
   | archive           | 14 | bool            | R W | Section 5.8.2.1  |
   | cansettime        | 15 | bool            | R   | Section 5.8.2.2  |
   | case_insensitive  | 16 | bool            | R   | Section 5.8.2.3  |
   | case_preserving   | 17 | bool            | R   | Section 5.8.2.4  |
   | chown_restricted  | 18 | bool            | R   | Section 5.8.2.5  |
   | fileid            | 20 | uint64_t        | R   | Section 5.8.2.6  |
   | files_avail       | 21 | uint64_t        | R   | Section 5.8.2.7  |
   | files_free        | 22 | uint64_t        | R   | Section 5.8.2.8  |
   | files_total       | 23 | uint64_t        | R   | Section 5.8.2.9  |

   | fs_locations      | 24 | fs_locations4   | R   | Section 5.8.2.10 |
   | hidden            | 25 | bool            | R W | Section 5.8.2.11 |
   | homogeneous       | 26 | bool            | R   | Section 5.8.2.12 |
   | maxfilesize       | 27 | uint64_t        | R   | Section 5.8.2.13 |
   | maxlink           | 28 | uint32_t        | R   | Section 5.8.2.14 |
   | maxname           | 29 | uint32_t        | R   | Section 5.8.2.15 |
   | maxread           | 30 | uint64_t        | R   | Section 5.8.2.16 |
   | maxwrite          | 31 | uint64_t        | R   | Section 5.8.2.17 |
   | mimetype          | 32 | ascii_          | R W | Section 5.8.2.18 |
   |                   |    |   REQUIRED4<>   |     |                  |
   | mode              | 33 | mode4           | R W | Section 6.2.2    |
   | mounted_on_fileid | 55 | uint64_t        | R   | Section 5.8.2.19 |
   | no_trunc          | 34 | bool            | R   | Section 5.8.2.20 |
   | numlinks          | 35 | uint32_t        | R   | Section 5.8.2.21 |
   | owner             | 36 | utf8str_mixed   | R W | Section 5.8.2.22 |
   | owner_group       | 37 | utf8str_mixed   | R W | Section 5.8.2.23 |
   | quota_avail_hard  | 38 | uint64_t        | R   | Section 5.8.2.24 |
   | quota_avail_soft  | 39 | uint64_t        | R   | Section 5.8.2.25 |
   | quota_used        | 40 | uint64_t        | R   | Section 5.8.2.26 |
   | rawdev            | 41 | specdata4       | R   | Section 5.8.2.27 |
   | space_avail       | 42 | uint64_t        | R   | Section 5.8.2.28 |
   | space_free        | 43 | uint64_t        | R   | Section 5.8.2.29 |
   | space_total       | 44 | uint64_t        | R   | Section 5.8.2.30 |
   | space_used        | 45 | uint64_t        | R   | Section 5.8.2.31 |
   | system            | 46 | bool            | R W | Section 5.8.2.32 |
   | time_access       | 47 | nfstime4        | R   | Section 5.8.2.33 |
   | time_access_set   | 48 | settime4        | W   | Section 5.8.2.34 |
   | time_backup       | 49 | nfstime4        | R W | Section 5.8.2.35 |
   | time_create       | 50 | nfstime4        | R W | Section 5.8.2.36 |
   | time_delta        | 51 | nfstime4        | R   | Section 5.8.2.37 |
   | time_metadata     | 52 | nfstime4        | R   | Section 5.8.2.38 |
   | time_modify       | 53 | nfstime4        | R   | Section 5.8.2.39 |
   | time_modify_set   | 54 | settime4        | W   | Section 5.8.2.40 |
   +-------------------+----+-----------------+-----+------------------+

                      Table 4: RECOMMENDED Attributes
```

---
### **5.8.  Attribute Definitions**
---
#### **5.8.1.  Definitions of REQUIRED Attributes**
---
##### **5.8.1.1.  Attribute 0: supported_attrs**

이 객체에 대해 지원되는 모든 REQUIRED 및 RECOMMENDED 속성을 검색하는 비트 벡터입니다. 이 속성의 범위는 일치하는 fsid가 있는 모든 개체에 적용됩니다.\(MUST\)

---
##### **5.8.1.2.  Attribute 1: type**

여러 특수 상수 중 하나를 사용하여 객체의 유형을 지정합니다.

o NF4REG는 일반 파일을 지정합니다.

o NF4DIR은 디렉터리를 지정합니다.

o NF4BLK는 블록 장치 특수 파일을 지정합니다.

o NF4CHR은 문자장치 특수파일을 지정한다.

o NF4LNK는 심볼릭 링크를 지정합니다.

o NF4SOCK은 명명된 소켓 특수 파일을 지정합니다.

o NF4FIFO는 fifo 특수 파일을 지정합니다.

o NF4ATTRDIR은 명명된 속성 디렉터리를 지정합니다.

o NF4NAMEDATTR은 명명된 속성을 지정합니다.

설명 텍스트 및 작동 설명 내에서 다음 문구는 아래 주어진 의미와 함께 사용됩니다.

o "디렉토리입니다"라는 문구는 객체의 유형 속성이 NF4DIR 또는 NF4ATTRDIR임을 의미합니다.

o "특수 파일입니다"라는 문구는 객체의 유형 속성이 NF4BLK, NF4CHR, NF4SOCK 또는 NF4FIFO임을 의미합니다.

o "일반 파일입니다"라는 문구는 개체의 유형 속성이 NF4REG 또는 NF4NAMEDATTR임을 의미합니다.

o "심볼릭 링크입니다"라는 문구는 객체의 유형 속성이 NF4LNK임을 의미합니다.

---
##### **5.8.1.3.  Attribute 2: fh_expire_type**

서버는 이를 사용하여 클라이언트에 파일 핸들 만료 동작을 지정합니다. 추가 설명은 섹션 4를 참조하세요.

---
##### **5.8.1.4.  Attribute 3: change**

클라이언트가 파일 데이터, 디렉터리 내용 또는 객체 속성이 수정되었는지 확인하는 데 사용할 수 있는 서버에서 생성된 값입니다. 서버는 이 속성 값에 대해 객체의 time\_metadata 속성을 반환할 수 있지만 파일 시스템 객체가 time\_metadata의 확인보다 더 자주 업데이트될 수 없는 경우에만 가능합니다.\(MAY\)

---
##### **5.8.1.5.  Attribute 4: size**

객체의 크기\(바이트\)입니다.

---
##### **5.8.1.6.  Attribute 5: link_support**

객체의 파일 시스템이 하드 링크를 지원하는 경우 TRUE입니다.

---
##### **5.8.1.7.  Attribute 6: symlink_support**

객체의 파일 시스템이 심볼릭 링크를 지원하는 경우 TRUE입니다.

---
##### **5.8.1.8.  Attribute 7: named_attr**

이 객체에 명명된 속성이 있는 경우 TRUE입니다. 즉, 이 개체에는 비어 있지 않은 명명된 속성 디렉터리가 있습니다.

---
##### **5.8.1.9.  Attribute 8: fsid**

이 객체를 보유하는 파일 시스템의 고유한 파일 시스템 식별자입니다. fsid 속성에는 주요 구성 요소와 보조 구성 요소가 있으며 각 구성 요소의 데이터 유형은 uint64\_t입니다.

---
##### **5.8.1.10.  Attribute 9: unique_handles**

두 개의 서로 다른 파일 핸들이 두 개의 서로 다른 파일 시스템 개체를 참조하는 것이 보장되는 경우 TRUE입니다.

---
##### **5.8.1.11.  Attribute 10: lease_time**

서버 임대 기간\(초\)입니다.

---
##### **5.8.1.12.  Attribute 11: rdattr_error**

READDIR 작업 중 속성을 검색하려는 시도에서 오류가 반환되었습니다.

---
##### **5.8.1.13.  Attribute 19: filehandle**

이 객체의 파일 핸들입니다\(주로 READDIR 요청용\).

---
#### **5.8.2.  Definitions of Uncategorized RECOMMENDED Attributes**

RECOMMENDED 속성 대부분의 정의는 다음과 같습니다. 공통 카테고리를 공유하는 컬렉션은 다른 섹션에서 정의됩니다.\(SHOULD\)

---
##### **5.8.2.1.  Attribute 14: archive**

TRUE, 이 파일이 마지막 수정 이후 보관된 경우\(time\_backup을 위해 더 이상 사용되지 않음\)

---
##### **5.8.2.2.  Attribute 15: cansettime**

서버가 SETATTR 작업에 지정된 대로 파일 시스템 개체의 시간을 변경할 수 있는 경우 TRUE입니다.

---
##### **5.8.2.3.  Attribute 16: case_insensitive**

TRUE, 이 파일 시스템의 파일 이름 비교가 대소문자를 구분하지 않는 경우. 이는 비교에만 적용되며 파일 이름이 저장되는 경우에는 적용되지 않습니다.

---
##### **5.8.2.4.  Attribute 17: case_preserving**

TRUE, 이 파일 시스템의 파일 이름 대소문자가 유지되는 경우. 이는 파일 이름이 저장되는 방법만 참조하고 비교 방법은 참조하지 않습니다. 대소문자를 혼합하여 저장된 파일 이름은 대소문자를 구분하지 않거나 대소문자를 구분하는 비교를 사용하여 비교할 수 있습니다.

---
##### **5.8.2.5.  Attribute 18: chown_restricted**

TRUE인 경우 호출자가 권한 있는 사용자\(예: UNIX 운영 환경의 "루트" 또는 Windows 2000의 "소유권 가져오기" 권한\)가 아닌 경우 서버는 소유자 또는 파일과 연관된 그룹을 변경하라는 요청을 거부합니다. \).

---
##### **5.8.2.6.  Attribute 20: fileid**

파일 시스템 내에서 파일을 고유하게 식별하는 번호입니다.

---
##### **5.8.2.7.  Attribute 21: files_avail**

이 객체를 포함하는 파일 시스템에서 이 사용자가 사용할 수 있는 파일 슬롯 - 관련 최소 한도여야 합니다.

---
##### **5.8.2.8.  Attribute 22: files_free**

이 객체를 포함하는 파일 시스템의 여유 파일 슬롯 - 관련 최소 한도여야 합니다.

---
##### **5.8.2.9.  Attribute 23: files_total**

이 객체를 포함하는 파일 시스템의 총 파일 슬롯입니다.

---
##### **5.8.2.10.  Attribute 24: fs_locations**

이 파일 시스템을 찾을 수 있는 위치입니다. 서버가 NFS4ERR\_MOVED를 오류로 반환하는 경우 이 속성을 지원해야 합니다.\(MUST\)

서버는 0 경로 구성 요소로 구성된 경로를 반환하여 특정 서버의 루트 경로를 지정합니다.

---
##### **5.8.2.11.  Attribute 25: hidden**

Windows API와 관련하여 파일이 숨겨진 것으로 간주되는 경우 TRUE입니다.

---
##### **5.8.2.12.  Attribute 26: homogeneous**

TRUE, 이 객체의 파일 시스템이 동종인 경우, 즉 파일 시스템의 모든 객체\(동일한 fsid를 가진 서버의 모든 객체\)는 모든 파일 시스템별 속성에 대해 공통 값을 갖습니다.

---
##### **5.8.2.13.  Attribute 27: maxfilesize**

이 개체의 파일 시스템에 대해 지원되는 최대 파일 크기입니다.

---
##### **5.8.2.14.  Attribute 28: maxlink**

이 개체에 대한 최대 하드 링크 수입니다.

---
##### **5.8.2.15.  Attribute 29: maxname**

이 개체에 지원되는 최대 파일 이름 크기입니다.

---
##### **5.8.2.16.  Attribute 30: maxread**

이 객체에 대해 READ 작업이 반환할 최대 데이터 양입니다.

---
##### **5.8.2.17.  Attribute 31: maxwrite**

WRITE 작업이 이 개체에 대해 허용할 최대 데이터 양입니다. 파일이 쓰기 가능한 경우 이 속성을 지원해야 합니다. 이 속성이 부족하면 클라이언트가 대역폭을 낭비하거나 최상의 성능을 얻지 못할 수 있습니다.\(SHOULD\)

---
##### **5.8.2.18.  Attribute 32: mimetype**

이 객체의 MIME 미디어 유형/하위 유형입니다.

---
##### **5.8.2.19.  Attribute 55: mounted_on_fileid**

fileid와 비슷하지만 대상 파일 핸들이 파일 시스템의 루트인 경우 이 속성은 기본 디렉터리의 fileid를 나타냅니다.

UNIX 기반 운영 환경은 파일 시스템을 기존 파일 시스템의 기존 파일 개체\(마운트 지점, 일반적으로 디렉터리\)에 연결\(마운트\)하여 파일 시스템을 네임스페이스에 연결합니다. readdir\(\) \[readdir\_api\]와 같은 API를 통해 마운트 지점의 상위 디렉터리를 읽을 때 반환 결과는 각각 구성 요소 이름과 파일 ID가 포함된 디렉터리 항목입니다. 마운트 지점 디렉토리 항목의 파일 ID는 stat\(\) \[stat\] 시스템 호출이 반환하는 파일 ID와 다릅니다. stat\(\) 시스템 호출은 마운트된 파일 시스템 루트의 파일 ID를 반환하는 반면, readdir\(\)은 파일 시스템이 마운트 지점에 마운트되기 전에 stat\(\)가 반환했을 파일 ID를 반환합니다.

NFSv3과 달리 NFSv4.0에서는 클라이언트의 LOOKUP 요청이 다른 파일 시스템을 통과할 수 있습니다. 클라이언트는 LOOKUP의 파일 핸들 인수에 LOOKUP이 반환한 파일 핸들의 fsid 속성과 다른 fsid 속성이 있을 때마다 파일 시스템 교차를 감지합니다. UNIX 기반 클라이언트는 이를 "마운트 지점 교차"로 간주합니다. UNIX에는 프로세스가 현재 작업 디렉토리를 결정할 수 있도록 하는 레거시 체계가 있습니다. 이는 앞서 설명한 대로 마운트 지점 상위의 readdir\(\)과 파일 ID를 반환하는 마운트 지점의 stat\(\)에 의존합니다. Mounted\_on\_fileid 속성은 앞서 설명한 대로 readdir\(\)이 반환한 파일 ID에 해당합니다.

NFSv4.0 클라이언트는 Mounted\_on\_fileid가 제공하는 것과 일치하는 파일 ID를 간단하게 조작할 수 있지만\(서버가 Mounted\_on\_fileid를 지원하지 않는 경우 클라이언트는 선택의 여지가 없음\) 클라이언트가 다음과 충돌하는 파일 ID를 생성할 위험이 있습니다. 파일 시스템의 다른 개체에 이미 할당되었습니다. 대신, 서버가 Mounted\_on\_fileid를 제공할 수 있으면 이 영역에서 클라이언트 작동 문제가 발생할 가능성이 제거됩니다.

서버가 대상 파일 객체 위에 마운트된 항목이 없음을 감지하면 반환되는 Mounted\_on\_fileid 값은 fileid 속성의 값과 동일합니다.

Mounted\_on\_fileid 속성은 RECOMMENDED이므로 서버는 가능하면 이를 제공해야 하며 UNIX 기반 서버의 경우 이는 간단합니다. 일반적으로 Mounted\_on\_fileid는 READDIR 작업 중에 요청되며, 이 경우에 mount\_on\_fileid가 readdir\(\)에서 반환된 디렉터리 항목의 fileid와 동일하므로 이를 반환하는 것은 쉽지 않습니다\(적어도 UNIX 기반 서버의 경우\). GETATTR 작업에서 Mounted\_on\_fileid가 요청되면 서버는 개체의 부모 디렉터리에 있는 파일 개체 항목과 동일한 값, 즉 readdir\(\)이 반환한 값을 반환하는 불변성을 따라야 합니다. 일부 운영 환경에서는 두 개 이상의 일련의 파일 시스템을 단일 마운트 지점에 마운트할 수 있습니다. 이 경우 서버가 앞서 언급한 불변성을 따르려면 중간 마운트 지점이 아닌 기본 마운트 지점을 찾아야 합니다.\(SHOULD\)

---
##### **5.8.2.20.  Attribute 34: no_trunc**

이 속성이 TRUE인 경우 클라이언트가 name\_max보다 긴 파일 이름을 사용하면 이름이 잘리는 대신 오류가 반환됩니다.

---
##### **5.8.2.21.  Attribute 35: numlinks**

이 개체에 대한 하드 링크 수입니다.

---
##### **5.8.2.22.  Attribute 36: owner**

이 개체 소유자의 문자열 이름입니다.

---
##### **5.8.2.23.  Attribute 37: owner_group**

이 개체의 그룹 소유권에 대한 문자열 이름입니다.

---
##### **5.8.2.24.  Attribute 38: quota_avail_hard**

추가 할당이 거부되기 전에 이 파일이나 디렉터리에 할당할 수 있는 현재 할당을 초과하는 추가 디스크 공간의 양을 나타내는 값\(바이트\)입니다. 이 공간은 다른 파일이나 디렉터리에 대한 할당으로 인해 소모될 수 있는 것으로 이해됩니다.

---
##### **5.8.2.25.  Attribute 39: quota_avail_soft**

사용자에게 합리적으로 경고하기 전에 이 파일이나 디렉터리에 할당할 수 있는 추가 디스크 공간의 양을 나타내는 값\(바이트\)입니다. 다른 파일이나 디렉터리에 대한 서버 측 규칙이 있을 수 있지만 이 공간은 다른 파일이나 디렉터리에 대한 할당으로 인해 소모될 수 있습니다.

---
##### **5.8.2.26.  Attribute 40: quota_used**

이 파일이나 디렉터리 및 기타 유사한 파일이나 디렉터리에서 사용하는 디스크 공간의 양을 나타내는 바이트 단위의 값입니다. 여기서 "유사" 집합은 최소한 다음의 모든 파일이나 디렉터리에 공간을 할당하는 기준을 충족합니다. set은 세트에 있는 다른 모든 파일이나 디렉터리의 "quota\_avail\_hard"를 줄입니다.

quota\_used 값이 유지되는 고유하지만 겹치는 파일 또는 디렉터리 집합이 여러 개 있을 수 있습니다\(예: "주어진 소유자가 있는 모든 파일", "주어진 그룹 소유자가 있는 모든 파일" 등\). 서버는 quota\_used 속성의 내용을 제공할 때 이러한 세트 중 하나를 자유롭게 선택할 수 있지만 반복 가능한 방식으로 수행해야 합니다. 규칙은 파일 시스템별로 구성되거나 "할당량이 가장 작은 집합을 선택"할 수 있습니다.

---
##### **5.8.2.27.  Attribute 41: rawdev**

NF4BLK 또는 NF4CHR 유형 파일의 원시 장치 번호입니다. 장치 번호는 메이저 번호와 마이너 번호로 구분됩니다. 파일의 유형 속성이 NF4BLK 또는 NF4CHR이 아닌 경우 이 속성은 반환되어서는 안 되며, 반환된 모든 값은 유용한 것으로 간주되어서는 안 됩니다.\(SHOULD NOT\)

---
##### **5.8.2.28.  Attribute 42: space_avail**

이 객체를 포함하는 파일 시스템에서 이 사용자가 사용할 수 있는 디스크 공간\(바이트\) - 관련 최소 한도여야 합니다.

---
##### **5.8.2.29.  Attribute 43: space_free**

이 개체를 포함하는 파일 시스템의 여유 디스크 공간\(바이트\) - 관련 최소 한도여야 합니다.

---
##### **5.8.2.30.  Attribute 44: space_total**

이 객체를 포함하는 파일 시스템의 총 디스크 공간\(바이트\)입니다.

---
##### **5.8.2.31.  Attribute 45: space_used**

이 객체에 할당된 파일 시스템 바이트 수입니다.

---
##### **5.8.2.32.  Attribute 46: system**

이 파일이 Windows 운영 환경과 관련된 "시스템" 파일인 경우 TRUE입니다.

---
##### **5.8.2.33.  Attribute 47: time_access**

서버로 전송된 READ 작업을 통해 객체에 마지막으로 액세스한 시간을 나타냅니다. "액세스"라는 개념은 서버의 운영 환경 및/또는 서버의 파일 시스템 의미에 따라 달라집니다. 예를 들어 POSIX\(Portable Operating System Interface\) 의미 체계를 준수하는 서버의 경우 time\_access는 READ 및 READDIR 작업에 의해서만 업데이트되며 \[read\_api\], \[readdir\_api\], \[write\_api\] 개체의 콘텐츠를 수정하는 작업에는 업데이트되지 않습니다. . 물론 해당 time\_access\_set 속성을 설정하는 것은 time\_access 속성을 수정하는 또 다른 방법입니다.

파일 객체가 쓰기 가능한 파일 시스템에 있을 때마다 서버는 time\_access를 안정적인 저장소에 기록하기 위해 최선을 다해야 합니다. 그러나 이렇게 하면 성능에 미치는 영향을 완화하기 위해, 특히 서버가 캐시에서 개체 콘텐츠 읽기를 만족할 때마다 서버는 액세스 시간 업데이트를 캐시하고 안정적인 저장소에 느리게 쓸 수 있습니다. 서버 관리자에게 time\_access 업데이트를 비활성화하는 옵션을 제공하는 것도 허용됩니다.\(MAY\)

---
##### **5.8.2.34.  Attribute 48: time_access_set**

개체에 대한 마지막 액세스 시간을 설정합니다. SETATTR만 사용하세요.

---
##### **5.8.2.35.  Attribute 49: time_backup**

개체의 마지막 백업 시간입니다.

---
##### **5.8.2.36.  Attribute 50: time_create**

객체가 생성된 시간입니다. 이 속성은 기존 UNIX 파일 속성 "ctime"\("변경 시간"\)과는 아무런 관련이 없습니다.

---
##### **5.8.2.37.  Attribute 51: time_delta**

```text
   Smallest useful server time granularity.
```

---
##### **5.8.2.38.  Attribute 52: time_metadata**

객체의 마지막 메타데이터 수정 시간입니다.

---
##### **5.8.2.39.  Attribute 53: time_modify**

객체를 마지막으로 수정한 시간입니다.

---
##### **5.8.2.40.  Attribute 54: time_modify_set**

객체를 마지막으로 수정한 시간을 설정합니다. SETATTR만 사용하세요.

---
### **5.9.  Interpreting owner and owner_group**

RECOMMENDED 속성 "owner" 및 "owner\_group"\(또한 acl 속성에 사용되는 nfs4ace 구조 내 who 필드의 값으로 사용되는 사용자 및 그룹\)은 UTF-8 문자열 형식으로 표시됩니다. 이 형식은 클라이언트나 서버의 특정 기본 구현과 연결된 표현의 사용을 방지합니다. \[RFC2624\]의 섹션 6.1은 추가적인 근거를 제공합니다. 클라이언트와 서버는 그러한 표현을 기대하는 API를 통해 애플리케이션에 대한 로컬 저장 또는 프리젠테이션에 사용되는 소유자 및 그룹에 대한 고유한 로컬 표현을 갖게 될 것으로 예상됩니다. 따라서 프로토콜에서는 이러한 속성이 클라이언트와 서버 간에 전송될 때 로컬 표현이 "identifier@dns\_domain" 형식의 문자열로 변환되도록 요구합니다. 이를 통해 동일한 로컬 표현을 사용하지 않는 클라이언트와 서버는 둘 다 해석할 수 있는 공통 구문을 사용하므로 효과적으로 상호 운용할 수 있습니다.\(SHOULD\)

마찬가지로 보안 주체는 다양한 보안 메커니즘에 따라 다양한 방식으로 표현될 수 있습니다. 서버는 일반적으로 이러한 표현을 일반적으로 로컬 저장소에서 사용되는 공통 형식으로 변환하여 이러한 보안 주체에 해당하는 사용자를 식별하는 수단으로 사용됩니다. 이러한 로컬 식별자가 해당 보안 주체에 의해 생성된 파일과 연결된 소유자 특성의 형태로 변환되면 공통 형식으로 각 해당 보안 주체 집합과 연결된 사용자를 식별합니다.

소유자 및 그룹 문자열을 해석하는 데 사용되는 번역은 프로토콜의 일부로 지정되지 않습니다. 이를 통해 다양한 솔루션을 사용할 수 있습니다. 예를 들어 숫자 식별자를 user@dns\_domain 구문에 매핑하는 로컬 변환 테이블을 참조할 수 있습니다. 번역을 완료하기 위해 이름 서비스를 사용할 수도 있습니다. 서버는 소유자 및 owner\_group 속성을 번역 없이 로컬 저장소에 저장하여 특정 번역\(가능한 문자열의 제한된 집합만 번역\)에 제한되지 않고 보다 일반적인 서비스를 제공할 수 있습니다. 또는 번역을 보강할 수도 있습니다.

번역이 가능한 경우에는 로컬 표현을 사용하면서 번역이 불가능한 속성에 대한 전체 문자열을 저장하는 방식입니다.

사용자 및 그룹 문자열의 가능한 모든 값에 대한 지원을 제공하지 않는 서버는 변환이 없는 문자열이 제시될 때 소유자 또는 owner\_group 속성의 SETATTR에 대해 설정되는 값으로 또는 그 일부로 오류\(NFS4ERR\_BADOWNER\)를 반환해야 합니다. acl 속성의 값. 서버가 SETATTR에서 유효한 사용자 또는 그룹 문자열을 수락하면 해당 GETATTR이 완료될 때 해당 속성이 더 이상 변경되지 않는 한 동일한 문자열\(아래 참조\)을 반환할 것을 약속합니다. GETATTR. 이것이 가능하지 않은 일부 국제화 관련 예외에 대해서는 아래를 참조하십시오. 구성 변경\(문자열을 로컬 표현으로 매핑하는 변경 포함\)과 잘못 구성된 이름 변환\(별칭 포함\)으로 인해 해당 약속을 이행하는 것이 불가능해질 수 있습니다. 서버는 소유권이나 ACL에 대한 실제 변경이 발생하지 않은 경우 이러한 속성의 값이 변경되는 상황을 피하기 위해 적절한 노력을 기울여야 합니다.\(SHOULD\)

소유자 문자열의 "dns\_domain" 부분은 DNS 도메인 이름을 의미합니다\(예: "user@example.org"\). 서버는 하나 이상의 도메인에 대해 유효한 사용자 집합을 허용해야 합니다. 서버는 다른 도메인을 유효한 번역이 없는 것으로 처리할 수 있습니다. 서버가 보안 제약에 따라 여러 도메인 또는 모든 도메인에 대한 사용자를 수락할 수 있는 경우 보다 일반적인 서비스가 제공됩니다.

구현 가이드로서 클라이언트와 서버 모두 소유자 문자열의 "dns\_domain" 부분을 구성하는 수단을 제공할 수 있습니다. 예를 들어, NFS 서버를 실행하는 호스트의 DNS 도메인 이름은 "lab.example.org"일 수 있지만 사용자 이름은 "example.org"에 정의됩니다. 이러한 구성이 없거나 기본적으로 서버의 현재 DNS 도메인 이름은 "dns\_domain"에 사용되는 값이어야 합니다.

위에서 언급한 대로 서버는 속성에서 "user@domain" 또는 "group@domain" 형식의 문자열을 허용할 때 해당 속성을 가져올 때 이 동일한 문자열을 반환하는 것이 바람직합니다. 국제화 문제로 인해 특정 상황에서는 이것이 불가능하므로 클라이언트는 이러한 점에 유의해야 합니다. 이러한 문제에 대한 자세한 논의는 섹션 12를 참조하십시오.

클라이언트나 서버에서 사용할 수 있는 번역이 없는 경우 속성 값은 "@" 없이 구성됩니다. 따라서 소유자 또는 소유자 그룹 속성에 "@"이 없으면 보낸 사람이 번역을 사용할 수 없음을 의미합니다.

그리고 속성의 수신자는 해당 문자열을 자체 내부 형식으로 변환하기 위한 기초로 사용해서는 안 됩니다. 속성 값을 번역할 수 없더라도 여전히 유용할 수 있습니다. 클라이언트의 경우 속성 문자열은 소유권의 로컬 표시에 사용될 수 있습니다.

32비트 부호 없는 사용자 식별자와 그룹 식별자로 사용자와 그룹을 식별하는 NFSv3과의 호환성을 높이기 위해 선행 0이 없는 ASCII 인코딩 십진수 값으로 구성된 소유자 및 그룹 문자열에 다음과 같은 특수 해석을 제공할 수 있습니다. 그러한 지원을 제공하기로 선택한 클라이언트 및 서버. 수신자는 이러한 사용자 또는 그룹 문자열을 해당 숫자 값을 갖는 NFSv3 uid 또는 gid로 표시되는 것과 동일한 사용자를 나타내는 것으로 처리할 수 있습니다.

보안 메커니즘이 Kerberos를 사용하는 경우 서버는 이러한 숫자 값을 거부해야 합니다\(SHOULD\). 즉, 이러한 시나리오에서는 클라이언트가 이미 "user@domain" 문자열을 구성해야 합니다. 다른 보안 메커니즘의 경우 서버는 이러한 숫자 값을 허용해야 합니다. 구현 참고 사항으로 서버는 이러한 승인을 구성 가능하게 만들 수 있습니다. 서버가 숫자 값을 지원하지 않거나 꺼진 상태로 구성된 경우에는 NFS4ERR\_BADOWNER 오류를 반환해야 합니다. 보안 메커니즘이 Kerberos를 사용하고 클라이언트가 특수 형식을 사용하려고 시도하는 경우 이러한 방식으로 지정된 사용자 또는 소유자에 대한 유효한 변환이 있을 때 서버는 NFS4ERR\_BADOWNER 오류를 반환해야 합니다. 이 경우 클라이언트는 호환성을 위해 특수 형식이 아닌 적절한 user@domain 문자열을 사용해야 합니다.\(SHOULD, SHOULD, MUST, SHOULD\)

보안 메커니즘이 RPCSEC\_GSS가 아닌 경우 클라이언트는 항상 숫자 값을 허용해야 합니다. 클라이언트는 먼저 숫자 식별자 제공을 시도하여 서버가 숫자 식별자를 지원하는지 확인할 수 있습니다. 이 시도가 NFS4ERR\_BADOWNER 오류와 함께 거부되면 클라이언트는 "user@dns\_domain" 형식의 명명된 식별자만 사용해야 합니다.\(MUST\)

소유자 문자열 "nobody"는 익명 사용자를 지정하는 데 사용될 수 있으며, 이는 일반적인 방법을 통해 소유자 특성에 매핑될 수 없는 보안 주체에 의해 생성된 파일과 연결됩니다.

---
### **5.10.  Character Case Attributes**

대소 문자 구분 및 대소 문자 보존 속성과 관련하여 유니코드 문자의 대소 문자 구분 비교는 유니코드 표준 \[UNICODE\]의 3장에 정의된 대로 유니코드 기본 대소 문자 접기를 사용해야 하며, SpecialCasing.txt \[SPECIALCASING\] 파일; 유니코드 표준의 섹션 3.13을 참조하세요.\(SHOULD\)

SpecialCasing.txt 파일은 기본 케이스 접기를 특정 상황에 대한 로케일 및 컨텍스트 종속 케이스 접기로 대체합니다. 로캘 및 상황에 따른 대소문자 구분의 예는 LATIN 대문자 I\("I", U+0049\)가 LATIN SMALL LETTER I\("i", U+0069\)로 기본 대소문자를 구분하는 것입니다. 그러나 여러 언어\(예: 터키어\)에서는 점이 있는 "I" 문자를 점이 없는 "I" 문자와 다른 문자로 처리합니다. 따라서 이러한 언어에서는 I가 위의 점 앞에 있지 않는 한 "I"\(U+0049\) 문자는 다른 문자인 LATIN SMALL LETTER DOTLESS I\(U+0131\)로 대소문자를 바꿔야 합니다.

이 RFC의 \[UNICODE\] 및 \[SPECIALCASING\] 참조는 이 RFC가 게시될 당시 유니코드의 최신 버전이었던 유니코드 표준 버전 7.0.0에 대한 것입니다. 구현은 항상 최신 버전의 유니코드\(<http://www.unicode.org/versions/latest/\>\)를 사용해야 합니다.\(SHOULD\)

---
## **6.  Access Control Attributes**

ACL\(액세스 제어 목록\)은 세분화된 액세스 제어를 지정하는 파일 속성입니다. 이 섹션에서는 "acl", "aclsupport" 및 "mode" 파일 속성과 해당 상호 작용을 다룹니다. 파일 속성은 모든 파일 시스템 개체에 적용될 수 있습니다.

---
### **6.1.  Goals**

ACL과 모드는 권한 지정을 위한 두 가지 잘 확립된 모델을 나타냅니다. 이 섹션에서는 다음 목표를 달성하기 위한 요구 사항을 지정합니다.

o 서버가 모드 속성을 지원하는 경우 모드 속성만 설정하고 검색하는 클라이언트에 합리적인 의미를 제공해야 합니다.

o 서버가 ACL 속성을 지원하는 경우 해당 속성만 설정하고 검색하는 클라이언트에 합리적인 의미를 제공해야 합니다.

o 모드 속성을 지원하는 서버에서 ACL 속성이 상속을 통해 또는 명시적으로 객체에 설정된 적이 없는 경우 동작은 전통적인 UNIX와 유사한 동작이어야 합니다.

o 모드 속성을 지원하는 서버에서 ACL 속성이 이전에 명시적으로 또는 상속을 통해 객체에 설정된 경우:

- \* 모드 속성만 설정하면 소유자, 소유자 그룹 및 기타에 대한 읽기, 쓰기 및 실행에 대한 기존 UNIX와 유사한 권한을 효과적으로 제어해야 합니다.

- \* 모드 속성만 설정하면 합리적인 보안이 제공됩니다. 예를 들어, 000 모드를 설정하면 이전의 기존 ACL 또는 상속된 ACL에 관계없이 모든 주체가 읽기 또는 쓰기를 위해 향후 열기가 실패하도록 보장하기에 충분해야 합니다.

o 객체에 모드 속성이 설정되면 새 모드와 충돌하지 않도록 ACL 속성을 수정해야 할 수도 있습니다. 이러한 경우 ACL은 최대한 많은 정보를 유지하는 것이 바람직합니다. 여기에는 상속, AUDIT 및 ALARM 액세스 제어 항목\(ACE\), 새 모드와 충돌하지 않는 부여 및 거부된 권한에 대한 정보가 포함됩니다.

---
### **6.2.  File Attributes Discussion**

NFSv4를 사용하여 액세스하는 파일 시스템은 ACL을 지원하지 않을 수 있으므로 각 ACL 속성에 대한 지원은 권장되지만 필수는 아닙니다.\(SHOULD\)

---
#### **6.2.1.  Attribute 12: acl**

NFSv4.0 ACL 속성에는 파일 시스템 개체와 연결된 ACE 배열이 포함되어 있습니다. 클라이언트는 acl 속성을 읽고 쓸 수 있지만 서버는 ACL을 사용하여 액세스 제어를 수행해야 합니다. 클라이언트는 OPEN 또는 ACCESS 작업을 사용하여 데이터나 메타데이터를 수정하거나 읽지 않고도 액세스를 확인할 수 있습니다.

NFS ACE 구조는 다음과 같이 정의됩니다.

```text
   typedef uint32_t        acetype4;

   typedef uint32_t        aceflag4;

   typedef uint32_t        acemask4;

   struct nfsace4 {
           acetype4                type;
           aceflag4                flag;
           acemask4                access_mask;
           utf8str_mixed           who;
   };
```

요청이 성공했는지 확인하기 위해 서버는 각 nfsace4 항목을 순서대로 처리합니다. 요청자와 일치하는 "누구"가 있는 ACE만 고려됩니다. 각 ACE는 요청자의 액세스 비트가 모두 허용될 때까지 처리됩니다. ACCESS\_ALLOWED\_ACE에 의해 비트\(아래 참조\)가 허용되면 이후 ACE 처리에서 더 이상 고려되지 않습니다. ACCESS\_DENIED\_ACE인 경우

요청자의 액세스에 ACE의 "access\_mask"와 공통된 허용되지 않은 비트가 여전히 있는 경우 요청이 거부됩니다. ACL이 완전히 처리되었을 때 요청자의 마스크에 허용되거나 거부되지 않은 비트가 있으면 액세스가 거부됩니다.

ALLOW 및 DENY ACE 유형과 달리 ALARM 및 AUDIT ACE 유형은 요청자의 액세스에 영향을 주지 않으며 대신 요청자의 액세스 시도의 결과로 이벤트를 트리거하는 데 사용됩니다. 따라서 AUDIT 및 ALARM ACE는 ALLOW 및 DENY ACE를 처리한 후에만 처리됩니다.

NFSv4.0 ACL 모델은 매우 풍부합니다. 일부 서버 플랫폼은 UNIX 스타일 모드 속성을 뛰어넘는 액세스 제어 기능을 제공할 수 있지만 NFS ACL 모델만큼 풍부하지는 않습니다. 사용자가 이 보다 제한된 기능을 활용할 수 있도록 서버는 ACL 모델과 NFSv4.0 ACL 모델 간의 매핑을 통해 acl 속성을 지원할 수 있습니다. 서버는 실제로 저장하거나 적용하는 ACL이 최소한 설정된 NFSv4 ACL만큼 엄격한지 확인해야 합니다. 정확하게 표현될 수 있는 작은 집합을 벗어나는 ACL을 거부하여 이를 달성하려는 유혹이 있습니다. 그러나 이러한 접근 방식은 서버 매핑에 대한 특별한 클라이언트 측 지식 없이는 ACL을 사용할 수 없게 만들 수 있으며, 이로 인해 공통 NFSv4 ACL 프로토콜을 사용하는 목적이 무산됩니다. 따라서 서버는 보안을 손상시키지 않으면서 가능한 모든 ACL을 수락해야 합니다. 이를 달성하기 위해 서버는 지원되지 않는 권한 비트의 경우 ACL에 의해 허용되거나 거부되지 않은 비트를 거부해야 한다는 규칙에 대해 특별한 예외를 만들 수 있습니다. 예를 들어 UNIX 스타일 서버는 ACL이 해당 권한을 명시적으로 허용하지 않더라도 속성 읽기 권한을 자동으로 허용하도록 선택할 수 있습니다. \(속성을 읽을 수 있는 권한을 명시적으로 거부하는 ACL은 여전히 ​​거부되어야 합니다.\)

서버에 ACL을 적용하는 여러 모듈이 있을 수 있다는 사실로 인해 상황이 복잡해집니다. 예를 들어, NFSv4.0 액세스에 대한 적용은 로컬 액세스에 대한 적용과 다를 수 있지만 그보다 약하지는 않으며, 둘 다 서버 메시지 블록\(SMB\)과 같은 다른 프로토콜을 통한 액세스에 대한 적용과 다를 수 있습니다. 중소기업\]. 따라서 모든 모듈이 ACL을 지원할 수 없더라도 서버가 ACL을 수락하는 것이 유용할 수 있습니다.

NFSv4 액세스와 관련된 기본 원칙은 서버가 실제로 적용되는 것보다 파일에 대해 더 제한된 액세스를 제공하는 ACL을 허용해서는 안 된다는 것입니다.

---
##### **6.2.1.1.  ACE Type**

유형 필드\(acetype4\)에 사용되는 상수는 다음과 같습니다.

```text
   const ACE4_ACCESS_ALLOWED_ACE_TYPE      = 0x00000000;
   const ACE4_ACCESS_DENIED_ACE_TYPE       = 0x00000001;
   const ACE4_SYSTEM_AUDIT_ACE_TYPE        = 0x00000002;
   const ACE4_SYSTEM_ALARM_ACE_TYPE        = 0x00000003;
```

acl 속성에는 네 가지 비트 유형이 모두 허용됩니다.

```text
   +------------------------------+--------------+---------------------+
   | Value                        | Abbreviation | Description         |
   +------------------------------+--------------+---------------------+
   | ACE4_ACCESS_ALLOWED_ACE_TYPE | ALLOW        | Explicitly grants   |
   |                              |              | the access defined  |
   |                              |              | in acemask4 to the  |
   |                              |              | file or directory.  |
   |                              |              |                     |
   | ACE4_ACCESS_DENIED_ACE_TYPE  | DENY         | Explicitly denies   |
   |                              |              | the access defined  |
   |                              |              | in acemask4 to the  |
   |                              |              | file or directory.  |
   |                              |              |                     |
   | ACE4_SYSTEM_AUDIT_ACE_TYPE   | AUDIT        | LOG (in a system-   |
   |                              |              | dependent way) any  |
   |                              |              | access attempt to a |
   |                              |              | file or directory   |
   |                              |              | that uses any of    |
   |                              |              | the access methods  |
   |                              |              | specified in        |
   |                              |              | acemask4.           |
   |                              |              |                     |
   | ACE4_SYSTEM_ALARM_ACE_TYPE   | ALARM        | Generate a system   |
   |                              |              | ALARM (system       |
   |                              |              | dependent) when any |
   |                              |              | access attempt is   |
   |                              |              | made to a file or   |
   |                              |              | directory for the   |
   |                              |              | access methods      |
   |                              |              | specified in        |
   |                              |              | acemask4.           |
   +------------------------------+--------------+---------------------+
```

"약어" 열은 이 섹션의 나머지 부분에서 유형이 참조되는 방식을 나타냅니다.

---
##### **6.2.1.2.  Attribute 13: aclsupport**

서버는 위의 ACE 유형을 모두 지원할 필요는 없습니다. 이 속성은 현재 파일 시스템에 지원되는 ACE 유형을 나타냅니다. aclsupport 속성 내에서 위 정의를 나타내는 데 사용되는 비트마스크 상수는 다음과 같습니다.

```text
   const ACL4_SUPPORT_ALLOW_ACL    = 0x00000001;
   const ACL4_SUPPORT_DENY_ACL     = 0x00000002;
   const ACL4_SUPPORT_AUDIT_ACL    = 0x00000004;
   const ACL4_SUPPORT_ALARM_ACL    = 0x00000008;
```

ALLOW 또는 DENY ACE 유형을 지원하는 서버는 ALLOW 및 DENY ACE 유형을 모두 지원해야 합니다.\(SHOULD\)

서버가 해당 ACE 유형에 대한 지원을 요청하지 않는 한 클라이언트는 ACE 설정을 시도해서는 안 됩니다. 서버가 저장할 수 없는 ACE를 설정하라는 요청을 받으면 NFS4ERR\_ATTRNOTSUPP를 사용하여 요청을 거부해야 합니다. 서버가 저장할 수는 있지만 시행할 수 없는 ACE를 설정하라는 요청을 수신하는 경우 서버는 NFS4ERR\_ATTRNOTSUPP를 사용하여 요청을 거부해야 합니다.\(MUST, SHOULD\)

---
##### **6.2.1.3.  ACE Access Mask**

액세스 마스크 필드에 사용되는 비트마스크 상수는 다음과 같습니다.

```text
   const ACE4_READ_DATA            = 0x00000001;
   const ACE4_LIST_DIRECTORY       = 0x00000001;
   const ACE4_WRITE_DATA           = 0x00000002;
   const ACE4_ADD_FILE             = 0x00000002;
   const ACE4_APPEND_DATA          = 0x00000004;
   const ACE4_ADD_SUBDIRECTORY     = 0x00000004;
   const ACE4_READ_NAMED_ATTRS     = 0x00000008;
   const ACE4_WRITE_NAMED_ATTRS    = 0x00000010;
   const ACE4_EXECUTE              = 0x00000020;
   const ACE4_DELETE_CHILD         = 0x00000040;
   const ACE4_READ_ATTRIBUTES      = 0x00000080;
   const ACE4_WRITE_ATTRIBUTES     = 0x00000100;

   const ACE4_DELETE               = 0x00010000;
   const ACE4_READ_ACL             = 0x00020000;
   const ACE4_WRITE_ACL            = 0x00040000;
   const ACE4_WRITE_OWNER          = 0x00080000;
   const ACE4_SYNCHRONIZE          = 0x00100000;
```

일부 마스크에는 일치하는 값이 있습니다\(예: ACE4\_READ\_DATA 및 ACE4\_LIST\_DIRECTORY\). 마스크 항목 ACE4\_LIST\_DIRECTORY, ACE4\_ADD\_FILE 및 ACE4\_ADD\_SUBDIRECTORY는 디렉터리 개체에 사용하기 위한 반면, ACE4\_READ\_DATA, ACE4\_WRITE\_DATA 및 ACE4\_APPEND\_DATA는 디렉터리가 아닌 개체에 사용하기 위한 것입니다.

---
###### **6.2.1.3.1.  Discussion of Mask Attributes**

```text
   ACE4_READ_DATA

      Operation(s) affected:

         READ

         OPEN

      Discussion:
```

- 파일의 데이터를 읽기 위한 권한입니다.

- 서버는 ACE4\_EXECUTE 액세스 마스크 비트만 설정된 경우 사용자가 파일의 데이터를 읽을 수 있는 기능을 허용해야 합니다.\(SHOULD\)

```text
   ACE4_LIST_DIRECTORY

      Operation(s) affected:

         READDIR

      Discussion:
```

- 디렉토리의 내용을 나열할 수 있는 권한입니다.

```text
   ACE4_WRITE_DATA

      Operation(s) affected:

         WRITE

         OPEN
```

- SETATTR 크기

```text
      Discussion:
```

- 파일의 데이터를 수정하기 위한 권한입니다.

```text
   ACE4_ADD_FILE

      Operation(s) affected:

         CREATE

         LINK

         OPEN

         RENAME

      Discussion:
```

- 디렉토리에 새 파일을 추가하기 위한 권한입니다. nfs\_ftype4가 NF4LNK, NF4BLK, NF4CHR, NF4SOCK 또는 NF4FIFO인 경우 CREATE 작업이 영향을 받습니다. \(NF4DIR은 ACE4\_ADD\_SUBDIRECTORY에 포함되어 나열되지 않습니다.\) OPEN은 일반 파일을 생성하는 데 사용될 때 영향을 받습니다. LINK 및 RENAME은 항상 영향을 받습니다.

```text
   ACE4_APPEND_DATA

      Operation(s) affected:

         WRITE

         OPEN
```

- SETATTR 크기

```text
      Discussion:
```

- 파일의 데이터를 수정하는 기능이 있지만 EOF에서만 시작됩니다. 이는 동일한 사용자 또는 그룹에 대해 ACE4\_APPEND\_DATA를 허용하고 ACE4\_WRITE\_DATA를 거부함으로써 추가 전용 파일 개념을 허용합니다. 파일에 위에서 설명한 것과 같은 ACL이 있고 EOF가 아닌 다른 위치에 대해 WRITE 요청이 이루어진 경우 서버는 NFS4ERR\_ACCESS를 반환해야 합니다.\(SHOULD\)

```text
   ACE4_ADD_SUBDIRECTORY

      Operation(s) affected:

         CREATE

         RENAME

      Discussion:
```

- 디렉토리 내에 하위 디렉토리를 생성하기 위한 권한입니다. nfs\_ftype4가 NF4DIR인 경우 CREATE 작업이 영향을 받습니다. RENAME 작업은 항상 영향을 받습니다.

```text
   ACE4_READ_NAMED_ATTRS

      Operation(s) affected:

         OPENATTR

      Discussion:
```

- 파일의 명명된 속성을 읽거나 명명된 속성 디렉터리를 조회하기 위한 권한입니다. OPENATTR은 명명된 속성 디렉터리를 생성하는 데 사용되지 않을 때 영향을 받습니다. 이는 1\)creater가 TRUE이지만 명명된 속성 디렉터리가 이미 존재하거나 2\)createir가 FALSE인 경우입니다.

```text
   ACE4_WRITE_NAMED_ATTRS

      Operation(s) affected:

         OPENATTR

      Discussion:
```

- 파일의 명명된 속성을 쓰거나 명명된 속성 디렉터리를 생성할 수 있는 권한입니다. OPENATTR은 명명된 특성 디렉터리를 만드는 데 사용될 때 영향을 받습니다. 이것은creater이 TRUE이고 명명된 속성 디렉터리가 존재하지 않는 경우입니다. 명명된 속성 디렉터리가 존재하는지 여부를 확인하는 능력은 그것을 찾는 능력에 달려 있습니다. 따라서 사용자는 명명된 특성 디렉터리를 생성하려면 ACE4\_READ\_NAMED\_ATTRS 권한도 필요합니다.

```text
   ACE4_EXECUTE

      Operation(s) affected:

         READ

      Discussion:
```

- 파일을 실행하기 위한 권한입니다.

- 서버는 ACE4\_EXECUTE 액세스 마스크 비트만 설정된 경우 사용자가 파일의 데이터를 읽을 수 있는 기능을 허용해야 합니다. 내용을 읽지 않고서는 파일을 실행할 수 있는 방법이 없기 때문이다. 서버가 READ 작업을 허용하기로 결정할 때 ACE4\_EXECUTE 및 ACE4\_READ\_DATA 비트를 동일하게 처리할 수 있더라도 ACL에서 두 비트가 독립적으로 설정되도록 허용해야 하며 ACCESS 작업에 응답할 때 두 비트를 구별해야 합니다\(MUST\). 특히, 서버는 다른 비트가 설정될 때 두 비트 중 하나를 자동으로 켜서는 안 됩니다. 그렇게 하면 클라이언트가 읽기 권한과 실행 권한 간의 구별을 올바르게 시행하는 것이 불가능해지기 때문입니다.\(SHOULD, MUST, SHOULD NOT\)

- 예를 들어 다음 ACL의 SETATTR을 따릅니다.

```text
         nfsuser:ACE4_EXECUTE:ALLOW
```

- 해당 파일에 대한 ACL의 후속 GETATTR은 다음을 반환해야 합니다.\(SHOULD\)

```text
         nfsuser:ACE4_EXECUTE:ALLOW

         Rather than:

         nfsuser:ACE4_EXECUTE/ACE4_READ_DATA:ALLOW

   ACE4_EXECUTE

      Operation(s) affected:

         LOOKUP

         OPEN

         REMOVE

         RENAME

         LINK

         CREATE

      Discussion:
```

- 디렉토리를 탐색/탐색하기 위한 권한입니다.

```text
   ACE4_DELETE_CHILD

      Operation(s) affected:

         REMOVE

         RENAME

      Discussion:
```

- 디렉토리 내의 파일이나 디렉토리를 삭제하기 위한 권한입니다. ACE4\_DELETE 및 ACE4\_DELETE\_CHILD가 상호 작용하는 방법에 대한 자세한 내용은 섹션 6.2.1.3.2를 참조하세요.

```text
   ACE4_READ_ATTRIBUTES

      Operation(s) affected:
```

- 파일 시스템 객체 속성의 GETATTR

```text
         VERIFY

         NVERIFY

         READDIR

      Discussion:
```

- 파일의 기본 속성\(비ACL\)을 읽는 기능. UNIX 시스템에서는 기본 속성을 통계 수준 속성으로 생각할 수 있습니다. 이 액세스 마스크 비트를 허용하면 엔터티가 "ls -l" 및 stat를 실행할 수 있음을 의미합니다. READDIR 작업이 속성을 요청하는 경우 READDIR이 성공하려면 이 마스크를 허용해야 합니다.

```text
   ACE4_WRITE_ATTRIBUTES

      Operation(s) affected:
```

time\_access\_set, time\_backup, time\_create의 SETATTR,

- time\_modify\_set, mimetype, 숨김 및 시스템

```text
      Discussion:
```

- 파일이나 디렉터리와 관련된 시간을 임의의 값으로 변경하는 권한입니다. 또한 MIME 유형, 숨김 및 시스템 속성을 변경할 수 있는 권한입니다. ACE4\_WRITE\_DATA 또는 ACE4\_WRITE\_ATTRIBUTES가 있는 사용자는 파일과 관련된 시간을 현재 서버 시간으로 설정할 수 있습니다.

```text
   ACE4_DELETE

      Operation(s) affected:

         REMOVE

      Discussion:
```

파일이나 디렉터리를 삭제할 수 있는 권한입니다. 보다

- ACE4\_DELETE 및 ACE4\_DELETE\_CHILD 상호 작용에 대한 자세한 내용은 섹션 6.2.1.3.2를 참조하세요.

```text
   ACE4_READ_ACL

      Operation(s) affected:
```

- ACL의 GETATTR

```text
         NVERIFY

         VERIFY

      Discussion:
```

- ACL을 읽을 수 있는 권한입니다.

```text
   ACE4_WRITE_ACL

      Operation(s) affected:
```

- acl 및 모드의 SETATTR

```text
      Discussion:
```

- acl 및 mode 속성을 쓰기 위한 권한입니다.

```text
   ACE4_WRITE_OWNER

      Operation(s) affected:
```

- 소유자 및 owner\_group의 SETATTR

```text
      Discussion:
```

- 소유자, 소유자\_그룹 속성을 쓰기 위한 권한입니다. UNIX 시스템에서는 chown\(\) 및 chgrp\(\)를 실행하는 기능입니다.

```text
   ACE4_SYNCHRONIZE

      Operation(s) affected:

         NONE

      Discussion:
```

파일 개체를 동기화로 사용하기 위한 권한

- 프로세스 간 통신을 위한 기본 요소입니다. 이 권한은 클라이언트를 대신하여 NFSv4.0 서버에 의해 적용되거나 해석되지 않습니다.

- 일반적으로 ACE4\_SYNCHRONIZE 권한은 로컬 파일 시스템, 즉 NFSv4.0을 통해 액세스되지 않는 파일 시스템에서만 의미가 있습니다. 권한 비트가 존재하는 이유는 Windows와 같은 일부 운영 환경에서는 ACE4\_SYNCHRONIZE를 사용하기 때문입니다.

예를 들어, 클라이언트가 다음과 같은 파일을 복사하는 경우

- ACE4\_SYNCHRONIZE는 로컬 파일 시스템에서 NFSv4.0 서버로 설정되고 나중에 NFSv4.0 서버의 파일을 로컬 파일 시스템으로 복사합니다. ACE4\_SYNCHRONIZE가 원본 파일에 설정된 경우 클라이언트는 두 번째 사본에 설정되었습니다. NFSv4.0 서버에 ACE4\_SYNCHRONIZE 비트를 설정할 수 있는 수단이 없으면 첫 번째 복사본에는 권한 집합이 없습니다. NFSv4.0 서버에 ACE4\_SYNCHRONIZE 비트를 검색할 수 있는 수단이 없으면 두 번째 복사본에는 권한 집합이 없습니다.

서버 구현에서는 이 마스크 목록이 암시하는 제어 세분성을 제공할 필요가 없습니다. 예를 들어 POSIX 기반 시스템은 ACE4\_APPEND\_DATA\(파일에 추가하는 기능\)와 ACE4\_WRITE\_DATA\(기존 콘텐츠를 수정하는 기능\)를 구별하지 못할 수 있습니다. 두 마스크 모두 단일 "쓰기" 권한에 연결됩니다. 이러한 서버가 클라이언트에 속성을 반환하면 쓰기 권한이 활성화된 경우에만 ACE4\_APPEND\_DATA 및 ACE4\_WRITE\_DATA가 모두 표시됩니다.

서버가 정확하게 구현할 수 없는 SETATTR 요청을 수신하면 이전에 설명한 실행 및 읽기 사례를 제외하고 액세스가 더 제한된 방향으로 오류가 발생해야 합니다. 예를 들어, 이전 단락에서 설명한 대로 서버가 데이터 덮어쓰기와 새 데이터 추가를 구별할 수 없다고 가정합니다. 클라이언트가 ACE4\_APPEND\_DATA가 설정되어 있지만 ACE4\_WRITE\_DATA가 설정되지 않은 ALLOW ACE를 제출하는 경우\(또는 그 반대\) 서버는 ACE4\_APPEND\_DATA를 끄거나 NFS4ERR\_ATTRNOTSUPP를 사용하여 요청을 거부해야 합니다.

---
###### **6.2.1.3.2.  ACE4_DELETE versus ACE4_DELETE_CHILD**

두 개의 액세스 마스크 비트가 디렉터리 항목 삭제 기능을 제어합니다. 개체 자체\("대상"\)의 ACE4\_DELETE와 포함 디렉터리\("상위"\)의 ACE4\_DELETE\_CHILD입니다.

많은 시스템은 또한 대상 또는 상위를 소유한 사용자에 대해서만 연결 해제를 허용하기 위해 디렉터리에서 "고정 비트"\(MODE4\_SVTX\)를 사용합니다. 일부 시스템에서는 대상이 쓰기 가능한지 여부에 따라 결정이 달라집니다.

서버는 대상에서 ACE4\_DELETE가 허용되거나 상위에서 ACE4\_DELETE\_CHILD가 허용되는 경우 연결 해제를 허용해야 합니다. \(상위 또는 대상이 이러한 권한 중 다른 권한을 명시적으로 거부하는 경우에도 마찬가지입니다.\)\(SHOULD\)

문제의 ACL이 위 항목 중 하나를 명시적으로 허용하거나 거부하지 않고 MODE4\_SVTX가 상위 항목에 설정되지 않은 경우 서버는 ACE4\_ADD\_FILE이 허용되는 경우에만 제거를 허용해야 합니다. MODE4\_SVTX가 설정된 경우 서버는 제거 프로그램이 상위 또는 대상을 소유하도록 요구하거나 대상이 쓰기 가능하도록 요구할 수도 있습니다.\(SHOULD\)

이를 통해 서버는 ACE4\_ADD\_FILE이 쓰기 비트를 대신하여 전통적인 UNIX와 유사한 의미 체계에 가까운 것을 지원할 수 있습니다.

---
##### **6.2.1.4.  ACE flag**

플래그 필드에 사용되는 비트마스크 상수는 다음과 같습니다.

```text
   const ACE4_FILE_INHERIT_ACE             = 0x00000001;
   const ACE4_DIRECTORY_INHERIT_ACE        = 0x00000002;
   const ACE4_NO_PROPAGATE_INHERIT_ACE     = 0x00000004;
   const ACE4_INHERIT_ONLY_ACE             = 0x00000008;
   const ACE4_SUCCESSFUL_ACCESS_ACE_FLAG   = 0x00000010;
   const ACE4_FAILED_ACCESS_ACE_FLAG       = 0x00000020;
   const ACE4_IDENTIFIER_GROUP             = 0x00000040;
```

서버는 이러한 플래그를 지원할 필요가 없습니다. 서버가 이러한 플래그와 유사하지만 정확히 동일하지는 않은 플래그를 지원하는 경우 구현에서는 프로토콜 정의 플래그와 구현 정의 플래그 간의 매핑을 정의할 수 있습니다.

예를 들어, 클라이언트가 ACE4\_FILE\_INHERIT\_ACE가 설정된 ACE를 설정하려고 하지만 ACE4\_DIRECTORY\_INHERIT\_ACE는 설정하지 않는다고 가정해 보겠습니다. 서버가 어떤 형태의 ACL 상속도 지원하지 않는 경우 서버는 NFS4ERR\_ATTRNOTSUPP를 사용하여 요청을 거부해야 합니다. 서버의 경우

파일과 디렉터리 모두에 적용되는 단일 "ACE 상속" 플래그를 지원하는 경우 서버는 요청을 거부할 수 있습니다\(즉, 클라이언트가 파일 및 디렉터리 상속 플래그를 모두 설정하도록 요구함\). 서버는 요청을 수락하고 ACE4\_DIRECTORY\_INHERIT\_ACE 플래그를 자동으로 켤 수도 있습니다.

---
###### **6.2.1.4.1.  Discussion of Flag Bits**

ACE4\_FILE\_INHERIT\_ACE

- 하위 디렉터리에 있는 디렉터리가 아닌 모든 파일은 이 ACE를 상속받습니다.

ACE4\_DIRECTORY\_INHERIT\_ACE

- 디렉터리에 배치할 수 있으며 생성된 각 새 디렉터리에 이 ACE를 추가해야 함을 나타냅니다. 이 플래그가 디렉터리가 아닌 파일 시스템 개체에 설정될 ACL 속성의 ACE에 설정된 경우 ACL을 설정하려는 작업은 NFS4ERR\_ATTRNOTSUPP와 함께 실패해야 합니다.\(SHOULD\)

ACE4\_INHERIT\_ONLY\_ACE

- 디렉토리에 배치할 수 있지만 디렉토리에 적용되지는 않습니다. 이 비트가 설정된 ALLOW 및 DENY ACE는 디렉터리에 대한 액세스에 영향을 주지 않으며, 이 비트가 설정된 AUDIT 및 ALARM ACE는 로그 또는 경보 이벤트를 트리거하지 않습니다. 이러한 ACE는 위의 두 플래그에 지정된 대로 새로 생성된 파일 및 디렉터리에 적용\(이 비트가 지워진 상태\)된 후에만 적용됩니다. 이 플래그가 ACE에 있지만 ACE4\_DIRECTORY\_INHERIT\_ACE나 ACE4\_FILE\_INHERIT\_ACE가 모두 없는 경우 이러한 속성을 설정하려는 작업은 NFS4ERR\_ATTRNOTSUPP로 인해 실패해야 합니다.\(SHOULD\)

ACE4\_NO\_PROPAGATE\_INHERIT\_ACE

- 디렉토리에 배치할 수 있습니다. 이 플래그는 이 ACE의 상속이 새로 생성된 하위 디렉터리에서 중지되어야 함을 서버에 알립니다.

```text
   ACE4_SUCCESSFUL_ACCESS_ACE_FLAG
```

ACE4\_FAILED\_ACCESS\_ACE\_FLAG

- ACE4\_SUCCESSFUL\_ACCESS\_ACE\_FLAG\(SUCCESS\) 및 ACE4\_FAILED\_ACCESS\_ACE\_FLAG\(FAILED\) 플래그 비트는 ACE4\_SYSTEM\_AUDIT\_ACE\_TYPE\(AUDIT\) 및 ACE4\_SYSTEM\_ALARM\_ACE\_TYPE\(ALARM\) ACE 유형에만 설정할 수 있습니다. 파일의 ACL을 처리하는 동안 서버가 OPEN을 시도하는 주체와 일치하는 AUDIT 또는 ALARM ACE를 발견하면 서버는 그 사실을 기록하고 AUDIT에서 발견된 SUCCESS 및 FAILED 플래그가 있는지 여부를 기록합니다. 알람 에이스. 서버가 ACL 처리를 완료하면 작업이 성공했는지 여부를 기록합니다.

- 실패했어요. 작업이 성공하고 일치하는 AUDIT 또는 ALARM ACE에 대해 SUCCESS 플래그가 설정된 경우 적절한 AUDIT 또는 ALARM 이벤트가 발생합니다. 작업이 실패하고 일치하는 AUDIT 또는 ALARM ACE에 대해 FAILED 플래그가 설정된 경우 적절한 AUDIT 또는 ALARM 이벤트가 발생합니다. SUCCESS 또는 FAILED 중 하나 또는 둘 다를 설정할 수 있지만 둘 다 설정하지 않으면 AUDIT 또는 ALARM ACE가 유용하지 않습니다.

- 앞에서 설명한 처리는 NFS4\_OK를 반환하는 경우에도 ACCESS 작업에 적용됩니다. AUDIT 및 ALARM의 목적을 위해 요청 및 지원된 비트를 반환하지 못하는 경우 ACCESS 작업을 "실패"로 간주합니다.

ACE4\_IDENTIFIER\_GROUP

- "누구"가 UNIX에서 정의된 GROUP 또는 Windows에서 정의된 GROUP ACCOUNT를 나타냄을 나타냅니다. 클라이언트와 서버는 섹션 6.2.1.5에 설명된 특수 식별자 중 하나와 동일한 who 값을 가진 ACE의 ACE4\_IDENTIFIER\_GROUP 플래그를 무시해야 합니다.\(MUST\)

---
##### **6.2.1.5.  ACE Who**

ACE의 who 필드는 ACE가 적용되는 주체를 지정하는 식별자입니다. 플래그 비트 ACE4\_IDENTIFIER\_GROUP을 사용하여 사용자 또는 그룹을 나타낼 수 있습니다.

특정 DNS 도메인의 맥락이 아닌 보편적으로 이해해야 하는 몇 가지 특수 식별자가 있습니다. 이러한 식별자 중 일부는 NFS 클라이언트가 서버에 액세스할 때 이해할 수 없지만 로컬 프로세스가 파일에 액세스할 때는 의미가 있습니다. 이러한 권한을 표시하고 수정하는 기능은 서버의 액세스 방법 중 어느 것도 식별자를 이해하지 못하는 경우에도 NFS를 통해 허용됩니다.

```text
   +---------------+---------------------------------------------------+
   | Who           | Description                                       |
   +---------------+---------------------------------------------------+
   | OWNER         | The owner of the file.                            |
   | GROUP         | The group associated with the file.               |
   | EVERYONE      | The world, including the owner and owning group.  |
   | INTERACTIVE   | Accessed from an interactive terminal.            |
   | NETWORK       | Accessed via the network.                         |
   | DIALUP        | Accessed as a dialup user to the server.          |
   | BATCH         | Accessed from a batch job.                        |
   | ANONYMOUS     | Accessed without any authentication.              |
   | AUTHENTICATED | Any authenticated user (opposite of ANONYMOUS).   |
   | SERVICE       | Access from a system service.                     |
   +---------------+---------------------------------------------------+

                       Table 5: Special Identifiers

   To avoid conflict, these special identifiers are distinguished by an
   appended "@" and should appear in the form "xxxx@" (with no domain
   name after the "@") -- for example, ANONYMOUS@.
```

이러한 특수 식별자가 있는 항목에서는 ACE4\_IDENTIFIER\_GROUP 플래그를 무시해야 합니다. 이러한 특수 식별자를 사용하여 항목을 인코딩할 때 ACE4\_IDENTIFIER\_GROUP 플래그를 0으로 설정해야 합니다.\(MUST, SHOULD\)

---
###### **6.2.1.5.1.  Discussion of EVERYONE@**

"EVERYONE@"은 UNIX의 "기타" 엔터티와 동일하지 않다는 점에 유의하는 것이 중요합니다. 이는 정의에 따라 UNIX "기타"에는 파일의 소유자 또는 소유 그룹이 포함되지 않기 때문입니다. "EVERYONE@"은 문자 그대로 소유자 또는 소유 그룹을 포함한 모든 사람을 의미합니다.

---
#### **6.2.2.  Attribute 33: mode**

NFSv4.0 모드 속성은 UNIX 모드 비트를 기반으로 합니다. 다음 비트가 정의됩니다:

```text
   const MODE4_SUID = 0x800;  /* set user id on execution */
   const MODE4_SGID = 0x400;  /* set group id on execution */
   const MODE4_SVTX = 0x200;  /* save text even after use */
   const MODE4_RUSR = 0x100;  /* read permission: owner */
   const MODE4_WUSR = 0x080;  /* write permission: owner */
   const MODE4_XUSR = 0x040;  /* execute permission: owner */
   const MODE4_RGRP = 0x020;  /* read permission: group */
   const MODE4_WGRP = 0x010;  /* write permission: group */
   const MODE4_XGRP = 0x008;  /* execute permission: group */

   const MODE4_ROTH = 0x004;  /* read permission: other */
   const MODE4_WOTH = 0x002;  /* write permission: other */
   const MODE4_XOTH = 0x001;  /* execute permission: other */
```

비트 MODE4\_RUSR, MODE4\_WUSR 및 MODE4\_XUSR은 소유자 속성에서 식별된 주체에 적용됩니다. 비트 MODE4\_RGRP, MODE4\_WGRP 및 MODE4\_XGRP는 owner\_group 속성에서 식별되었지만 소유자 속성에서는 식별되지 않은 주체에 적용됩니다. 비트 MODE4\_ROTH, MODE4\_WOTH 및 MODE4\_XOTH는 소유자 속성과 일치하지 않고 owner\_group 속성과 일치하는 그룹이 없는 모든 주체에 적용됩니다.

위에 지정된 모드 이외의 비트는 이 프로토콜에서 정의되지 않습니다. 서버는 GETATTR 또는 READDIR 작업에서 위에 정의된 비트 이외의 비트를 반환해서는 안 되며, 위에 정의된 비트 이외의 비트가 SETATTR, CREATE, OPEN, VERIFY 또는 NVERIFY 작업에서 설정된 경우 NFS4ERR\_INVAL을 반환해야 합니다.\(MUST NOT\)

---
### **6.3.  Common Methods**

이 섹션의 요구 사항은 향후 섹션, 특히 섹션 6.4에서 참조됩니다.

---
#### **6.3.1.  Interpreting an ACL**
---
##### **6.3.1.1.  Server Considerations**

서버는 섹션 6.2.1에 설명된 알고리즘을 사용하여 ACL이 객체에 대한 액세스를 허용하는지 여부를 결정합니다. 그러나 ACL이 유일한 액세스 결정자가 아닐 수도 있습니다. 예를 들어:

o 읽기 전용으로 내보낸 파일 시스템의 경우, 객체의 ACL이 쓰기 권한을 부여하더라도 서버는 쓰기 권한을 거부할 수 있습니다.

o 서버 구현은 ACL을 수정할 수 있는 유효한 방법이 없는 상황이 발생하는 것을 방지하기 위해 ACE4\_WRITE\_ACL 및 ACE4\_READ\_ACL 권한을 부여할 수 있습니다.\(MAY\)

o 모든 서버는 실행 권한만 부여된 경우 사용자에게 파일의 데이터를 읽을 수 있는 기능을 허용합니다. 즉, ACL이 사용자 ACE4\_READ\_DATA 액세스를 거부하고 사용자 ACE4\_EXECUTE를 허용하는 경우 서버는 사용자가 데이터를 읽을 수 있도록 허용합니다. 파일의\).

o 많은 서버에는 객체 소유자가 ACL에서 거부한 액세스를 재정의할 수 있는 소유자 재정의 개념이 있습니다. 예를 들어, 이는 권한이 변경된 열린 파일에 대해 사용자가 계속 액세스할 수 있도록 허용하는 데 도움이 될 수 있습니다.

o 많은 서버에는 일반 사용자 이상의 권한을 가진 "수퍼유저"라는 개념이 있습니다. 수퍼유저는 ACL에서 허용하지 않는 방식으로 데이터나 메타데이터를 읽거나 쓸 수 있습니다.

---
##### **6.3.1.2.  Client Considerations**

클라이언트는 ACL 해석을 기반으로 자체 액세스 확인을 수행해서는 안 되며, OPEN 및 ACCESS 작업을 사용하여 액세스 확인을 수행해야 합니다. 이를 통해 클라이언트는 ACL 해석을 기반으로 액세스 권한을 부여해야 하는지 여부를 서버가 결정하도록 한 결과에 따라 조치를 취할 수 있습니다.\(SHOULD NOT\)

클라이언트는 서버에 이를 적용할 적절한 정보가 없더라도 객체의 ACL이 특정 액세스를 정의하는 상황을 인식해야 합니다. 예를 들어, 서버는 특정 OPEN이 읽기 액세스를 위한 사용자의 열기를 반영하는지 아니면 문제의 파일 실행의 일부로 수행되는지 여부를 결정할 방법이 없습니다. 이러한 상황에서 클라이언트는 ACL에 정의된 대로 액세스를 적용하는 데 있어 자신의 역할을 수행해야 합니다. 이를 위해 클라이언트는 사용자 또는 애플리케이션에 요청된 액세스 권한을 부여해야 하는지 여부를 결정하기 위해 사용자 또는 애플리케이션의 요청을 서비스하기 전에 적절한 ACCESS 작업을 보냅니다\(또는 캐시된 이전 결정을 사용합니다\). ACL이 서버가 시행하지 않는 액세스를 정의할 수 있는 예는 섹션 6.3.1.1을 참조하세요.

---
#### **6.3.2.  Computing a mode Attribute from an ACL**

다음 방법을 사용하여 ACL을 기반으로 모드 속성의 MODE4\_R\*, MODE4\_W\* 및 MODE4\_X\* 비트를 계산할 수 있습니다.

먼저, 각 특수 식별자 OWNER@, GROUP@ 및 EVERYONE@에 대해 식별자 EVERYONE@과 고려 중인 식별자에 대한 ALLOW 및 DENY ACE만 고려하여 ACL을 순서대로 평가합니다. 평가 결과는 해당 식별자에 허용되는 비트를 정확하게 보여주는 NFSv4 ACL 마스크입니다.

그런 다음 OWNER@, GROUP@ 및 EVERYONE@에 대해 계산된 마스크를 다음과 같이 각각 사용자, 그룹 및 기타에 대한 모드 비트로 변환합니다.

1. ACE4\_READ\_DATA가 해당 마스크에 설정된 경우에만 읽기 비트\(MODE4\_RUSR, MODE4\_RGRP 또는 MODE4\_ROTH\)를 설정합니다.

2. 해당 마스크에 ACE4\_WRITE\_DATA 및 ACE4\_APPEND\_DATA가 모두 설정된 경우에만 쓰기 비트\(MODE4\_WUSR, MODE4\_WGRP 또는 MODE4\_WOTH\)를 설정합니다.

3. 해당 마스크에 ACE4\_EXECUTE가 설정된 경우에만 실행 비트\(MODE4\_XUSR, MODE4\_XGRP 또는 MODE4\_XOTH\)를 설정합니다.

---
##### **6.3.2.1.  Discussion**

일부 서버 구현에서는 명명된 사용자 및 그룹에 허용되는 비트를 그룹 비트\(MODE4\_RGRP, MODE4\_WGRP 및 MODE4\_XGRP\)에 추가합니다.

모드 비트가 허용하는 것처럼 보이는 액세스가 거부된 파일 그룹의 구성원을 보는 사용자에게 혼란을 야기하는 것으로 밝혀졌기 때문에 구현에서는 이를 수행하지 않는 것이 좋습니다. \(DENY ACE가 있으면 이러한 동작이 발생할 수도 있지만 DENY ACE는 거의 사용되지 않을 것으로 예상됩니다.\)

모드를 가져올 때 나타나는 동일한 사용자 혼란은 모드 설정이 소유자, 그룹 및 기타 사용자에 대한 권한을 효과적으로 제어하지 못하는 경우에도 발생합니다. 이는 다음 요구 사항 중 일부에 동기를 부여합니다.

---
### **6.4.  Requirements**

모드와 ACL을 모두 지원하는 서버는 MODE4\_\*USR, MODE4\_\*GRP 및 MODE4\_\*OTH 비트를 "OWNER@", "GROUP@" 및 "EVERYONE@"의 각 who 필드가 있는 ACE와 동기화하도록 주의해야 합니다. " 클라이언트가 ACL만 요청하든지 소유자, 소유자 그룹, 모드 속성 중 하나를 요청하든 의미상 동일한 액세스 권한이 존재함을 클라이언트가 확인할 수 있도록 합니다.

많은 요구 사항이 섹션 6.3.2를 참조하지만 해당 메서드에는 "SHOULD"로 지정된 동작이 있다는 점에 유의하세요. 이는 소유자, 그룹 및 기타에 대한 실제 권한이 아닌 철회된 POSIX ACL 초안\(\[P1003.1e\]\)에 따라 모드를 계산하는 기존 구현을 무효화하지 않기 위한 의도적인 것입니다.\(SHOULD\)

---
#### **6.4.1.  Setting the mode and/or ACL Attributes**
---
##### **6.4.1.1.  Setting mode and Not ACL**

모드 속성이 설정되어 9개의 하위 모드 비트 중 하나가 변경되고 ACL 속성이 명시적으로 설정되지 않은 경우 해당 비트의 업데이트된 값에 따라 acl 속성을 수정해야 합니다. 이는 모드를 이전과 같이 설정한 후에도 하위 비트의 값이 동일하더라도 발생해야 합니다.

AUDIT 또는 ALARM ACE는 모드 변경에 영향을 받지 않습니다.

권한 비트가 변경될 수 있는 경우 섹션 6.3.2에 설명된 방법을 통해 계산된 모드가 하위 9비트\(MODE4\_R\*, MODE4\_W\*, MODE4\_X\*\)를 생성하도록 acl 속성을 수정해야 합니다. 변경 속성에 의해 수정된 모드 속성. ACL 속성도 다음과 같이 수정되어야 합니다.\(MUST, SHOULD\)

1. MODE4\_RGRP가 설정되지 않은 경우 OWNER@ 및 EVERYONE@ 이외의 ACL에 명시적으로 나열된 엔터티에는 ACE4\_READ\_DATA가 부여되어서는 안 됩니다.\(SHOULD NOT\)

2. MODE4\_WGRP가 설정되지 않은 경우 OWNER@ 및 EVERYONE@ 이외의 ACL에 명시적으로 나열된 엔터티에는 ACE4\_WRITE\_DATA 또는 ACE4\_APPEND\_DATA가 부여되어서는 안 됩니다.\(SHOULD NOT\)

3. MODE4\_XGRP가 설정되지 않은 경우 OWNER@ 및 EVERYONE@ 이외의 ACL에 명시적으로 나열된 엔터티에는 ACE4\_EXECUTE가 부여되어서는 안 됩니다.\(SHOULD NOT\)

ALLOW ACE에 나타나는 위에 나열된 것 이외의 액세스 마스크 비트도 비활성화될 수 있습니다.\(MAY\)

ACE4\_INHERIT\_ONLY\_ACE 플래그가 설정된 ACE는 ACL 자체의 권한에 영향을 주지 않으며 AUDIT 및 ALARM 유형의 ACE에도 영향을 미치지 않습니다. 따라서 ACL 속성을 수정할 때 이러한 ACE를 수정되지 않은 상태로 두는 것이 바람직합니다.

또한 모드만 나타내는 ACL을 대신하여 acl을 삭제하면 요구 사항이 충족될 수도 있습니다. 이는 허용되지만 서버에서는 위의 요구 사항을 위반하지 않고 가능한 한 많은 ACL을 보존하는 것이 좋습니다. ACL을 폐기하면 모드 속성으로 생성된 파일이 ACL을 상속하는 것이 사실상 불가능해집니다\(섹션 6.4.3 참조\).

---
##### **6.4.1.2.  Setting ACL and Not mode**

acl을 설정하고 모드 속성을 설정하지 않는 경우 모드의 권한 비트는 ACL에서 파생되어야 합니다. 이 경우 ACL 속성은 주어진 대로 설정되어야 합니다. 모드 속성\(MODE4\_R\*, MODE4\_W\*, MODE4\_X\*\)의 하위 9개 비트는 섹션 6.3.2에 설명된 방법의 결과와 일치하도록 수정되어야 합니다. 모드의 상위 3개 비트\(MODE4\_SUID, MODE4\_SGID, MODE4\_SVTX\)는 변경되지 않고 유지되어야 합니다.\(SHOULD, MUST, SHOULD\)

---
##### **6.4.1.3.  Setting Both ACL and mode**

동일한 작업에서 모드와 acl 속성을 모두 설정하는 경우 속성은 모드, ACL 순서로 적용되어야 합니다. 모드 관련 속성은 지정된 대로 설정되고, ACL 속성은 지정된 대로 설정되며, 위의 섹션 6.4.1.2에 설명된 대로 최종 모드를 변경할 수 있습니다.\(MUST\)

---
#### **6.4.2.  Retrieving the mode and/or ACL Attributes**

이 섹션은 모드 및 ACL 속성을 모두 지원하는 서버에만 적용됩니다.

일부 서버 구현에는 "ACL이 없는 개체"라는 개념이 있을 수 있습니다. 즉, 모드 속성에 따라 모든 권한이 부여 및 거부되고 해당 개체에 대해 ACL 속성이 저장되지 않음을 의미합니다. 그러한 서버에 ACL 속성이 요청되면 서버는 모드와 충돌하지 않는 ACL을 반환해야 합니다. 즉, 반환된 ACL은 섹션 6.3.2에 설명된 대로 모드 속성\(MODE4\_R\*, MODE4\_W\*, MODE4\_X\*\)의 하위 9개 비트를 나타내야 합니다.\(SHOULD\)

다른 서버 구현의 경우 ACL 속성은 모든 개체에 대해 항상 존재합니다. 이러한 서버는 모드 속성\(MODE4\_SUID, MODE4\_SGID, MODE4\_SVTX\)의 상위 비트 3개 이상을 저장해야 합니다. 서버는 요청된 경우 모드 속성을 반환해야 하며, 모드의 하위 9비트\(MODE4\_R\*, MODE4\_W\*, MODE4\_X\*\)는 섹션 6.3.2의 메서드를 ACL 속성에 적용한 결과와 일치해야 합니다.\(SHOULD, MUST\)

---
#### **6.4.3.  Creating New Objects**

서버가 ACL 속성을 지원하는 경우 상위 디렉터리의 ACL 속성을 사용하여 새로 생성된 객체에 대한 초기 ACL 속성을 계산할 수 있습니다. 이 섹션에서는 이를 상속된 ACL이라고 합니다. 하나 이상을 추가하는 행위

상위 디렉터리의 ACL에 있는 ACE를 기반으로 하는 상속된 ACL에 대한 ACE를 이 섹션에서는 ACE 상속이라고 합니다.

mode 및 ACL 속성이 있거나 없을 때 CREATE 및 OPEN의 동작은 다음과 같아야 합니다.\(SHOULD\)

1. 호출에 모드만 제공된 경우:

- 이 경우 상속이 이루어져야 하지만 섹션 6.4.1.1에 설명된 대로 상속된 ACL에 모드를 적용하여 ACL을 수정해야 합니다.\(MUST\)

2. 호출에 ACL만 제공되는 경우:

- 이 경우 상속이 발생해서는 안 되며 CREATE 또는 OPEN에 정의된 ACL이 수정 없이 설정되고 모드는 6.4.1.2절과 같이 수정됩니다.\(SHOULD NOT\)

3. 호출에 모드와 ACL이 모두 제공된 경우:

- 이 경우 상속이 발생해서는 안 되며 두 속성 모두 섹션 6.4.1.3에 설명된 대로 설정됩니다.\(SHOULD NOT\)

4. 통화에 모드나 ACL이 모두 제공되지 않은 경우:

- 초기 속성 없이 객체가 생성되는 경우\(예: OPEN4\_CREATE의 opentype4 및 EXCLUSIVE4의 createmode4를 사용한 OPEN 작업\) 상속이 발생해서는 안 됩니다. 대신, 서버는 새로 생성된 개체에 대한 모든 액세스를 거부하도록 권한을 설정해야 합니다. 적절한 클라이언트가 후속 SETATTR 작업에서 원하는 속성을 설정할 것으로 예상되며, 서버는 개체가 생성된 권한에 관계없이 해당 작업이 성공하도록 허용해야 합니다. 예를 들어, 빈 ACL은 모든 권한을 거부하지만 서버는 WRITE\_ACL이 암시적으로 거부되더라도 소유자의 SETATTR이 성공하도록 허용해야 합니다.\(SHOULD NOT, SHOULD, SHOULD\)

다른 경우에는 상속이 이루어져야 하며

- ACL이 수정됩니다. 지원되는 경우 모드 속성은 MODE4\_SUID, MODE4\_SGID 및 MODE4\_SVTX 비트가 지워진 상태에서 섹션 6.3.2에 설명된 방법을 통해 계산되어야 합니다. 상위 디렉토리에 상속 가능한 ACE가 없으면 acl 속성 생성 규칙이 구현에 따라 정의됩니다.\(SHOULD, MUST\)

---
##### **6.4.3.1.  The Inherited ACL**

생성되는 개체가 디렉터리가 아닌 경우 상속된 ACL은 ACE4\_FILE\_INHERIT\_FLAG가 설정되지 않은 한 상위 디렉터리 ACL에서 ACE를 상속해서는 안 됩니다.\(SHOULD NOT\)

생성되는 객체가 디렉터리인 경우 상속된 ACL은 상위 디렉터리에서 상속 가능한 모든 ACE, 즉 ACE4\_FILE\_INHERIT\_ACE 또는 ACE4\_DIRECTORY\_INHERIT\_ACE 플래그가 설정된 ACE를 상속해야 합니다. 상속 가능한 ACE에 ACE4\_FILE\_INHERIT\_ACE가 설정되어 있지만 ACE4\_DIRECTORY\_INHERIT\_ACE가 지워진 경우 새로 생성된 디렉터리의 상속된 ACE에는 디렉터리가 디렉터리가 아닌 ACE의 영향을 받지 않도록 ACE4\_INHERIT\_ONLY\_ACE 플래그가 설정되어 있어야 합니다.\(MUST\)

새 디렉터리가 생성되면 서버는 상속 가능하고 효과적인 상속된 ACE\(즉, ACE4\_INHERIT\_ONLY\_ACE나 ACE4\_NO\_PROPAGATE\_INHERIT\_ACE가 설정되지 않음\)를 두 개의 ACE\(상속 플래그가 없는 ACE와 ACE4\_INHERIT\_ONLY\_ACE가 설정된 ACE\)로 분할할 수 있습니다. 이렇게 하면 새 디렉터리의 하위 항목에 상속될 ACE를 수정하지 않고도 디렉터리에 대한 유효 권한을 수정하는 것이 더 간단해집니다.\(MAY\)

---
## **7.  NFS Server Namespace**
---
### **7.1.  Server Exports**

UNIX 서버에서 네임스페이스는 루트 디렉터리 또는 "/" 아래의 경로 이름으로 접근할 수 있는 모든 파일을 설명합니다. Windows 서버에서 네임스페이스는 매핑된 디스크 문자로 명명된 디스크의 모든 파일을 구성합니다. NFS 서버 관리자는 NFS 클라이언트가 전체 서버의 파일 시스템 네임스페이스를 사용할 수 있도록 하는 경우가 거의 없습니다. 네임스페이스의 일부는 "내보내기" 기능을 통해 사용 가능한 경우가 더 많습니다. 이전 버전의 NFS 프로토콜에서는 각 내보내기에 대한 루트 파일 핸들이 MOUNT 프로토콜을 통해 획득되었습니다. 클라이언트는 내보낸 네임스페이스의 개체를 식별하는 문자열을 보내고 서버는 이에 대한 루트 파일 핸들을 반환합니다. MOUNT 프로토콜은 서버의 내보내기를 열거하는 EXPORTS 프로시저를 지원합니다.

---
### **7.2.  Browsing Exports**

NFSv4 프로토콜은 클라이언트가 다중 구성 요소 LOOKUP을 통해 이러한 내보내기에 대한 파일 핸들을 얻는 데 사용할 수 있는 루트 파일 핸들을 제공합니다. 일반적인 사용자 경험은 그래픽 사용자 인터페이스\(아마도 파일 "열기" 대화 상자 창\)를 사용하여 프로그레시브 브라우징을 통해 파일을 찾는 것입니다.

디렉토리 트리를 통해. 클라이언트는 단일 구성 요소의 점진적인 LOOKUP 작업을 통해 한 내보내기에서 다른 내보내기로 이동할 수 있어야 합니다.

이러한 검색 스타일은 NFSv2 및 NFSv3 프로토콜에서 잘 지원되지 않습니다. 클라이언트는 모든 LOOKUP 작업이 단일 서버 파일 시스템 내에 유지되기를 기대합니다. 예를 들어 장치 속성은 변경되지 않습니다. 이렇게 하면 클라이언트가 내보내기에 걸쳐 있는 네임스페이스 경로를 사용하지 못하게 됩니다.

클라이언트의 자동 마운트는 MOUNT 프로토콜의 EXPORTS 프로시저를 사용하여 서버 네임스페이스의 스냅샷을 얻을 수 있습니다. 서버의 경로 이름 구문을 이해하면 클라이언트에 서버 네임스페이스의 이미지를 생성할 수 있습니다. 서버에서 내보내지 않은 네임스페이스 부분은 사용자가 마운트된 파일 시스템에서 다른 파일 시스템으로 탐색할 수 있도록 하는 "의사 파일 시스템"으로 채워집니다. 클라이언트의 서버 네임스페이스 표현에는 단점이 있습니다. 즉, 정적이라는 것입니다. 서버 관리자가 새 내보내기를 추가하면 클라이언트는 이를 인식하지 못합니다.

---
### **7.3.  Server Pseudo-File System**

NFSv4 서버는 단일 서버 네임스페이스 프레임워크 내에서 모든 내보내기를 제공하여 이러한 네임스페이스 불일치를 방지합니다. NFSv4 클라이언트는 LOOKUP 및 READDIR 작업을 사용하여 한 내보내기에서 다른 내보내기로 원활하게 탐색합니다. 내보내지지 않은 서버 네임스페이스 부분은 내보낸 디렉터리 보기만 제공하는 "의사 파일 시스템"을 통해 연결됩니다. 의사 파일 시스템에는 고유한 fsid가 있으며 일반 읽기 전용 파일 시스템처럼 작동합니다.

서버의 네임스페이스 구성에 따라 여러 의사 파일 시스템이 존재할 수 있습니다. 예를 들어:

```text
     /a         pseudo-file system
     /a/b       real file system
     /a/b/c     pseudo-file system
     /a/b/c/d   real file system
```

각 의사 파일 시스템은 별도의 엔터티로 간주되므로 고유한 fsid를 갖습니다.

---
### **7.4.  Multiple Roots**

DOS 및 Windows 운영 환경은 때때로 "다중 루트"를 갖는 것으로 설명됩니다. 파일 시스템은 일반적으로 디스크 문자로 표시됩니다. MacOS는 파일 시스템을 최상위 이름으로 나타냅니다. 이러한 플랫폼용 NFSv4 서버는 이러한 루트 이름 위에 의사 파일 시스템을 구성하여 디스크 문자나 볼륨 이름이 단순히 의사 루트의 디렉터리 이름이 되도록 할 수 있습니다.

---
### **7.5.  Filehandle Volatility**

서버 의사 파일 시스템의 특성은 서버에서 사용할 수 있는 파일 시스템을 논리적으로 표현한 것입니다. 따라서 의사 파일 시스템은 서버가 처음 인스턴스화될 때 동적으로 구성될 가능성이 높습니다. 의사 파일 시스템에는 영구 파일 핸들을 구성할 수 있는 디스크상 대응 항목이 없을 것으로 예상됩니다. 서버가 의사 파일 시스템에 영구 파일 핸들을 제공하는 것이 바람직하더라도 NFS 클라이언트는 의사 파일 시스템 파일 핸들이 일시적이라는 것을 예상해야 합니다. 이는 문제의 파일 핸들과 관련된 "fh\_expire\_type" 속성을 확인하여 확인할 수 있습니다. 파일 핸들이 일시적인 경우 NFS4ERR\_FHEXPIRED 오류를 수신할 때 NFS 클라이언트는 파일 핸들 값\(예: 다중 구성 요소 LOOKUP 사용\)을 복구할 준비를 해야 합니다.

---
### **7.6.  Exported Root**

서버의 루트 파일 시스템을 내보내는 경우 의사 파일 시스템이 필요하지 않다고 결론을 내릴 수도 있습니다. 이것은 잘못된 것입니다. 서버에 다음 파일 시스템이 있다고 가정합니다.

```text
     /       disk1  (exported)
     /a      disk2  (not exported)
     /a/b    disk3  (exported)
```

disk2는 내보내지지 않기 때문에 간단한 LOOKUP으로 disk3에 접근할 수 없습니다. 서버는 의사 파일 시스템을 사용하여 격차를 해소해야 합니다.

---
### **7.7.  Mount Point Crossing**

서버 파일 시스템 환경은 하나의 파일 시스템이 두 번째 파일 시스템에 의해 '덮이거나' 마운트되는 디렉토리를 포함하는 방식으로 구성될 수 있습니다. 예를 들어:

```text
     /a/b            (file system 1)
     /a/b/c/d        (file system 2)
```

이 서버의 의사 파일 시스템은 다음과 같이 구성될 수 있습니다.

```text
     /               (placeholder/not exported)
     /a/b            (file system 1)
     /a/b/c/d        (file system 2)
```

완전한 의사 파일 시스템을 클라이언트에 제공하는 것은 서버의 책임입니다. 클라이언트가 "/a/b/c/d" 경로에 대한 LOOKUP 요청을 보내는 경우 서버의 응답은 파일 시스템 "/a/b/c/d"의 파일 핸들입니다. 이전 버전의 NFS 프로토콜에서 서버는 파일 시스템 "/a/b" 내의 "/a/b/c/d" 디렉터리의 파일 핸들로 응답했습니다.

NFS 클라이언트는 "fsid" 속성 값의 변경을 통해 서버 마운트 지점을 통과하는지 확인할 수 있습니다.

---
### **7.8.  Security Policy and Namespace Presentation**

NFSv4 클라이언트는 사용된 보안 메커니즘을 변경할 수 있는 기능을 보유하고 있으므로 허용되는 것이 무엇인지 결정한 후 서버는 SECINFO를 사용하여 클라이언트가 사용하는 보안 메커니즘을 기반으로 네임스페이스의 다른 보기를 제시해서는 안 됩니다. 대신, 부적절한 보안 메커니즘을 사용하여 데이터에 액세스하려는 시도가 있는 경우 일관된 보기를 제공하고 NFS4ERR\_WRONGSEC를 반환해야 합니다.\(SHOULD NOT\)

보안 고려 사항으로 인해 특정 파일 시스템의 존재를 숨겨야 하는 경우\(그 안에 있는 모든 데이터와는 반대로\) 서버는 서버 네임스페이스에 있는 공유 리소스의 보안 정책을 리소스의 상위 구성 요소에 적용할 수 있습니다. 예를 들어:

```text
       /                       (placeholder/not exported)
       /a/b                    (file system 1)
       /a/b/MySecretProject    (file system 2)
```

/a/b/MySecretProject 디렉터리는 실제 파일 시스템이며 공유 리소스입니다. /a/b/ MySecretProject에 대한 보안 정책이 무결성을 갖춘 Kerberos이고 이 파일 시스템의 존재에 대한 지식을 제한하는 것이 바람직하다고 가정합니다. 이 경우 서버는 /a/b에도 동일한 보안 정책을 적용해야 합니다. 이를 통해 필요할 때 보안을 유지할 파일 시스템의 존재 여부를 알 수 있습니다.

서버 리소스에서 여러 개의 분리된 보안 메커니즘을 사용하는 경우 이러한 종류의 정책을 적용하면 보안을 사용하여 더 높은 수준의 파일 시스템에 액세스할 수 없게 됩니다.

맛. 따라서 이러한 종류의 구성은 서로 분리된 여러 보안 특성 세트를 사용하여 클라이언트로부터 존재\(내용이 아닌\)를 숨기는 것과 호환되지 않습니다.

다른 상황에서는 서버 이름 공간에 있는 특정 개체의 보안에 모든 직계 자손의 모든 보안 메커니즘을 통합하는 것이 바람직한 정책입니다. 강력한 보안 요구 사항이 달리 지정되지 않는 한 일반적이고 편리한 방법은 모든 유효한 보안 메커니즘에서 전체 의사 파일 시스템에 액세스할 수 있도록 만드는 것입니다.

네트워크의 데이터 보안이 우려되는 경우 클라이언트는 중간자 공격을 방지하기 위해 강력한 보안 메커니즘을 사용하여 의사 파일 시스템에 액세스해야 합니다.

---
## **8.  Multi-Server Namespace**

NFSv4는 네임스페이스가 단일 서버의 경계를 넘어 확장될 수 있도록 하는 속성을 지원합니다. 클라이언트와 서버가 이러한 다중 서버 네임스페이스 구성을 지원하는 것이 권장됩니다. 그러나 이러한 다중 서버 네임스페이스의 사용은 선택 사항이며 여러 목적으로 단일 서버 네임스페이스를 완벽하게 사용할 수 있습니다. 그러나 다중 서버 네임스페이스를 사용하면 네임스페이스에서 파일 시스템의 논리적 위치를 특정 파일 시스템이 특정 서버에 위치하게 만드는 \(변경 가능한\) 논리적 및 관리적 고려 사항과 분리함으로써 많은 이점을 제공할 수 있습니다.\(SHOULD\)

---
### **8.1.  Location Attributes**

NFSv4에는 한 서버의 파일 시스템을 다른 서버에 있는 해당 파일 시스템의 하나 이상의 인스턴스와 연결할 수 있도록 하는 RECOMMENDED 속성이 포함되어 있습니다. 이러한 속성은 연결된 단일 서버 네임스페이스 내의 해당 파일 시스템 경로와 함께 서버 주소 대상\(하나 이상의 IP 주소를 나타내는 DNS 이름 또는 리터럴 IP 주소\)을 지정하여 이러한 파일 시스템 인스턴스를 지정합니다.\(SHOULD\)

fs\_locations RECOMMENDED 속성을 사용하면 특정 파일 시스템에 해당하는 데이터를 찾을 수 있는 파일 시스템 위치를 지정할 수 있습니다.\(SHOULD\)

---
### **8.2.  File System Presence or Absence**

NFSv4 네임스페이스\(일반적으로 다중 서버 네임스페이스일 필요는 없음\)의 지정된 위치에는 fs\_locations 속성을 통해 연결된 여러 파일 시스템 인스턴스 위치가 있을 수 있습니다. 해당 위치에 실제 현재 파일 시스템이 있을 수도 있습니다.

일반적인 네임스페이스 작업\(예: LOOKUP\)을 통해 액세스할 수 있습니다. 이 경우 파일 시스템은 네임스페이스의 해당 위치에 "존재"한다고 하며 클라이언트는 일반적으로 이를 사용하며 주요 위치가 더 이상 존재하지 않는 상황에 대해 위치 관련 속성을 통해 지정된 추가 위치의 사용을 예약합니다. 사용 가능.

문제의 네임스페이스 위치에 실제 파일 시스템이 없으면 파일 시스템이 "없다"고 합니다. 부재 파일 시스템에는 루트 이외의 파일이나 디렉터리가 포함되어 있지 않습니다. 대체 위치를 결정하는 데 유용한 작은 속성 세트에 액세스하는 것을 제외하고 이를 참조하면 NFS4ERR\_MOVED 오류가 발생합니다. 서버가 NFS4ERR\_MOVED 오류를 반환하는 경우 fs\_locations 속성을 지원해야 합니다.\(MUST\)

오류 이름은 한때 존재했다가 나중에 없어진 파일 시스템의 경우를 암시하지만 이는 하나의 가능성일 뿐입니다. 네임스페이스의 위치는 위치 속성으로 지정된 파일 시스템 집합이 유일한 실현이므로 영구적으로 없을 수 있습니다. NFS4ERR\_MOVED라는 이름은 해당 기능에 대한 이전의 보다 제한된 개념을 반영하지만, 참조된 파일 시스템이 이동되었거나 단순히 존재하지 않았는지 관계없이 참조된 파일 시스템이 없을 때마다 이 오류가 반환됩니다.

GETATTR 유형 작업\(나중에 논의됨\)의 경우를 제외하고, 작업 시작 시 현재 파일 핸들이 없는 파일 시스템 내에 있으면 해당 작업은 수행되지 않고 NFS4ERR\_MOVED 오류가 반환됩니다. 현재 서버에는 시스템이 없습니다.

현재 파일 핸들이 없는 파일 시스템 내에 있으면 GETFH가 성공할 수 없기 때문에 없는 파일 시스템 내의 파일 핸들을 클라이언트로 전송할 수 없습니다. 클라이언트가 없는 파일 시스템 내에 파일 핸들을 갖고 있는 경우 이는 파일 시스템이 존재할 때 해당 파일 핸들을 획득하고 이후에 파일 시스템이 없게 된 결과입니다.

존재하지 않는 파일 시스템 내에 있는 현재 파일 핸들에 대한 검사는 모든 작업 시작 시 발생하기 때문에 존재하지 않는 파일 시스템 내에 있도록 현재 파일 핸들을 변경하는 작업에서는 오류가 발생하지 않습니다. 이를 통해 PUTFH-GETATTR 및 LOOKUP-GETATTR과 같은 조합을 사용하여 아래에 설명된 대로 속성 정보, 특히 위치 속성 정보를 얻을 수 있습니다.

---
### **8.3.  Getting Attributes for an Absent File System**

파일 시스템이 없으면 대부분의 속성을 사용할 수 없지만 사용 가능한 작은 속성 세트, 특히 이 파일 시스템의 올바른 현재 위치에 대한 정보를 제공하는 fs\_locations에 대한 클라이언트 액세스를 허용해야 합니다. .

---
#### **8.3.1.  GETATTR within an Absent File System**

위에서 언급한 것처럼 GETATTR의 경우 부재한 파일 시스템 내에서 파일 핸들에 대한 속성을 얻을 수 있다는 점에서 예외가 있습니다. 이 예외는 속성 마스크에 최소한 fs\_locations 속성 비트가 포함된 경우에만 적용됩니다. 이는 클라이언트가 부재 파일 시스템에 관한 결과에 관심이 있음을 나타냅니다. 요청하지 않으면 GETATTR에서 NFS4ERR\_MOVED 오류가 발생합니다.

존재하지 않는 파일 시스템에서 GETATTR이 수행되면 지원되는 속성 세트가 매우 제한됩니다. 일반적으로 필수 속성을 포함하여 많은 속성은 부재 파일 시스템에서는 사용할 수 없습니다. fs\_locations 속성 외에도 다음 속성을 부재 파일 시스템에서 사용할 수 있어야 합니다. RECOMMENDED 속성의 경우 최소한 현재 파일 시스템에서 사용할 수 있는 것과 동일한 수준으로 사용할 수 있어야 합니다.\(MUST, SHOULD, SHOULD\)

fsid: 이 속성은 클라이언트가 특히 현재 파일 시스템과 존재하지 않는 파일 시스템 사이의 경계를 포함하여 파일 시스템 경계를 결정할 수 있도록 제공되어야 합니다. 이 값은 현재 서버의 다른 fsid와 달라야 하며 클라이언트가 연결될 수 있는 특정 대상의 fsid와 특별한 관계가 있을 필요가 없습니다.

Mounted\_on\_fileid: 존재하지 않는 파일 시스템의 상단에 있는 객체의 경우 이 속성을 사용할 수 있어야 합니다. 파일 ID는 현재 상위 파일 시스템 내에 있으므로 이 정보를 제공하기 위해 존재하지 않는 파일 시스템을 참조할 필요가 없습니다.

다른 속성을 제공할 수 있는 경우에도 없는 파일 시스템에 대해 다른 속성을 사용해서는 안 됩니다. 서버는 정보가 많을수록 항상 더 좋다고 가정해서는 안 되며, 추가 정보를 불필요하게 제공하는 것도 피해야 합니다.\(SHOULD NOT\)

GETATTR 작업에 fs\_locations 속성에 대한 비트마스크가 포함되어 있지만 비트마스크에 지원되지 않는 속성이 포함된 경우 GETATTR은 오류를 반환하지 않지만 결과와 함께 지원되는 실제 속성의 마스크를 반환합니다.

VERIFY/NVERIFY 처리는 속성 마스크에 fs\_locations가 포함되지 않은 경우 NFS4ERR\_MOVED 오류가 발생한다는 점에서 GETATTR과 유사합니다. 부재 파일 시스템에 대해 지원되지 않는 속성의 속성 마스크에 나타나는 모든 점\(여기에는 일반적으로 필수 속성이 일부 포함됨\)도 NFS4ERR\_MOVED 결과를 초래한다는 점에서 다릅니다.\(MUST\)

---
#### **8.3.2.  READDIR and Absent File Systems**

현재 파일 핸들이 없는 파일 시스템 내에 있을 때 수행되는 READDIR은 NFS4ERR\_MOVED 오류를 발생시킵니다. GETATTR의 경우와 달리 READDIR에 대해서는 그러한 예외가 발생하지 않기 때문입니다.

존재하지 않는 파일 시스템에 대한 속성은 해당 디렉토리에 하나 이상의 존재하지 않는 파일 시스템의 루트 디렉터리가 포함되어 있는 경우 현재 파일 시스템의 디렉터리에 대한 READDIR을 통해 가져올 수 있습니다. 이 경우 처리는 다음과 같습니다.

o 요청된 속성 세트에 fs\_locations가 포함된 경우 속성 가져오기가 정상적으로 진행되며 rdattr\_error 속성이 요청된 경우에도 NFS4ERR\_MOVED 표시가 반환되지 않습니다.

o 요청된 속성 세트에 fs\_locations가 포함되지 않은 경우 rdattr\_error 속성이 요청되면 부재 파일 시스템의 루트에 대한 각 디렉토리 항목은 NFS4ERR\_MOVED를 rdattr\_error 속성 값으로 보고합니다.

o 요청된 속성 세트에 fs\_locations 또는 rdattr\_error 속성 중 하나가 포함되어 있지 않은 경우 디렉토리 내에 없는 파일 시스템의 루트가 발생하면 NFS4ERR\_MOVED 오류와 함께 READDIR이 실패하게 됩니다.

o 파일 시스템이 없기 때문에 속성을 사용할 수 없는 경우\(일반적으로 필수 속성인 경우에도\) 오류 표시가 발생하지 않습니다. 이 경우 없는 파일 시스템의 루트 디렉터리에 대해 반환되는 속성 집합은 실제로 사용 가능한 속성으로 제한됩니다.\(MUST\)

---
### **8.4.  Uses of Location Information**

fs\_locations의 위치 보유 속성은 파일 시스템이 없을 가능성과 함께 안정적이고 관리 가능하며 확장 가능한 데이터 액세스를 제공하는 데 중요한 여러 기능을 제공합니다.

파일 시스템이 있는 경우 이러한 속성은 서버 오류, 통신 문제 또는 현재 파일 시스템에 대한 지속적인 액세스를 불가능하거나 비실용적으로 만드는 기타 문제가 발생할 경우 동일한 데이터에 액세스하는 데 사용할 대체 위치를 제공할 수 있습니다. 어떤 상황에서는 문제의 파일 시스템에 대한 고성능 액세스를 제공하기 위해 여러 대체 위치를 동시에 사용할 수 있습니다. 복제된 데이터 세트가 실제로 존재하지 않고 복제본이 동일한 데이터에 대한 다른 경로인 경우가 있지만 이러한 대체 위치 제공을 "복제"라고 합니다.

파일 시스템이 존재하다가 나중에 존재하지 않는 경우, 클라이언트는 대체 위치에서 자신의 데이터에 계속 액세스할 수 있는 기회를 얻을 수 있습니다. 파일 시스템 내용을 새 위치로 전송하는 것을 "마이그레이션"이라고 합니다. 자세한 내용은 섹션 8.4.2를 참조하세요.

대체 위치는 파일 시스템 데이터의 물리적 복제본이거나 동일한 서버에 대한 대체 통신 경로일 수 있으며, 다양한 형태의 서버 클러스터링의 경우 동일한 물리적 파일 시스템에 대한 액세스를 제공하는 다른 서버일 수 있습니다. 이러한 전환을 처리하는 고객의 책임은 새로운 액세스 경로의 특정 특성과 데이터가 실제로 마이그레이션된 방법 및 여부에 따라 달라집니다. 이러한 문제는 아래에서 자세히 논의됩니다.

이전에 파일 시스템이 없었던 경우, 파일 시스템 위치 지정은 한 서버에 있는 파일 시스템을 다른 서버에서 정의한 네임스페이스와 연결할 수 있는 수단을 제공하여 일반적인 다중 서버 네임스페이스 기능을 허용합니다. 파일 시스템이 없는 대신 이러한 위치를 지정하는 것을 "참조"라고 합니다.

위치 관련 속성에 대한 클라이언트 지원은 선택 사항이므로 서버는 예를 들어 프록시 역할을 하여 해당 클라이언트로부터 마이그레이션 및 추천 이벤트를 숨기는 조치를 취할 수 있습니다\(필수는 아니지만\).\(MAY\)

---
#### **8.4.1.  File System Replication**

fs\_locations 속성은 현재 파일 시스템 인스턴스 대신 또는 그에 추가하여 데이터에 액세스하는 데 사용할 대체 위치를 제공합니다. 파일 시스템에 처음 액세스할 때 클라이언트는 fs\_locations 속성을 조사하여 대체 위치 집합의 값을 얻어야 합니다.

서버 오류, 통신 문제 또는 기타 문제로 인해 현재 파일 시스템에 대한 지속적인 액세스가 불가능하거나 비현실적인 경우 클라이언트는 해당 데이터에 대한 지속적인 액세스를 얻는 방법으로 대체 위치를 사용할 수 있습니다. 클라이언트와 대상 파일 시스템 간의 다중 경로를 활용하여 더 높은 성능을 제공하기 위해 여러 위치를 동시에 사용할 수 있습니다.

IP 주소 집합을 나타내는 DNS 이름이 있는 단일 항목에서 파생되거나 각각 고유한 서버 주소가 있는 여러 항목에서 파생된 여러 서버 주소는 동일한 실제 서버에 해당할 수 있습니다.

---
#### **8.4.2.  File System Migration**

파일 시스템이 존재하고 존재하지 않는 경우 클라이언트는 fs\_locations 속성에 지정된 대로 대체 위치에서 해당 데이터에 계속 액세스할 수 있는 기회를 얻을 수 있습니다. 일반적으로 클라이언트는 문제의 파일 시스템에 액세스하고 NFS4ERR\_MOVED 오류가 발생한 다음 fs\_locations 속성을 사용하여 데이터의 새 위치를 결정합니다.

이러한 마이그레이션은 로드 밸런싱이나 일반 리소스 재할당을 제공하는 데 도움이 될 수 있습니다. 프로토콜은 파일 시스템이 서버 간에 이동되는 방법을 지정하지 않습니다. 다양한 서버 간 전송 메커니즘이 사용될 수 있으며 선택은 서버 구현자에게 맡겨질 것으로 예상됩니다. NFSv4 프로토콜은 클라이언트와 서버 간에 마이그레이션 이벤트를 전달하는 데 사용되는 방법을 지정합니다.

대체 위치를 마이그레이션 대상으로 지정하는 경우 동일한 데이터를 지정해야 합니다. 파일 시스템이 쓰기 가능한 경우 원래 파일 시스템에 대한 변경 사항이 모든 마이그레이션 대상에서 표시되어야 합니다. 파일 시스템이 쓰기 가능하지 않지만 쓰기 가능한 파일 시스템의 읽기 전용 복사본\(주기적으로 업데이트될 수 있음\)을 나타내는 경우 업데이트 전파에 유사한 요구 사항이 적용됩니다. 원본 파일 시스템에 표시되는 모든 변경 사항은 모든 마이그레이션 대상에 이미 적용되어 있어야 합니다. 이는 클라이언트가 마이그레이션 대상으로 전환할 때 파일 시스템 상태가 반전되는 것을 볼 가능성을 방지하기 위한 것입니다.

---
#### **8.4.3.  Referrals**

조회는 기본적으로 지정된 서버의 물리적 위치와 관계없이 네임스페이스 내의 위치에 파일 시스템을 배치하는 방법을 제공합니다. 이를 통해 단일 서버 또는 서버 세트가 파일 시스템을 포함하는 다중 서버 네임스페이스를 제공할 수 있습니다.

여러 서버에 위치합니다. 이에 대한 몇 가지 가능한 용도에는 사이트 전체 또는 조직 전체 네임스페이스를 설정하거나 이를 진정한 글로벌 네임스페이스로 결합하는 것이 포함됩니다.

클라이언트가 현재 네임스페이스의 위치를 ​​처음 참조할 때 해당 위치가 새 파일 시스템의 일부이고 해당 파일 시스템이 없다고 판단하면 참조가 발생합니다. 이런 일이 발생하면 일반적으로 NFS4ERR\_MOVED 오류를 수신하여 fs\_locations 속성을 가져와서 파일 시스템의 실제 위치를 확인할 수 있습니다.

위치 관련 속성은 클라이언트의 요구에 따라 선택될 단일 파일 시스템 위치 또는 다중 파일 시스템 위치를 지정할 수 있습니다.

다중 서버 네임스페이스 사용은 NFSv4에서 활성화되지만 필수는 아닙니다. 다중 서버 네임스페이스의 사용과 그 범위는 사용되는 애플리케이션과 시스템 관리 기본 설정에 따라 달라집니다.

다중 서버 네임스페이스는 포함된 모든 파일 시스템에 대한 대규모 조회 세트를 제공하는 단일 서버에 의해 구축될 수 있습니다. 대안으로, 단일 다중 서버 네임스페이스는 네임스페이스의 개별적으로 관리되는 각 부분에 대해 별도의 참조 파일 시스템\(별도의 서버에 있음\)으로 관리상 분할될 수 있습니다. 최상위 참조 파일 시스템 또는 모든 세그먼트는 가용성을 높이기 위해 복제된 참조 파일 시스템을 사용할 수 있습니다.

일반적으로 다중 서버 네임스페이스는 네임스페이스의 특정 위치에 있는 한 클라이언트에 제공되는 동일한 데이터가 해당 위치에 있는 모든 클라이언트에 제공된다는 점에서 대부분 균일합니다.

---
### **8.5.  Location Entries and Server Identity**

위에서 언급한 것처럼 단일 위치 항목은 여러 IP 주소를 나타낼 수 있는 DNS 이름 형태의 서버 주소 대상을 가질 수 있는 반면, 여러 위치 항목은 동일한 서버를 참조하는 자체 서버 주소 대상을 가질 수 있습니다.

동일한 서버에 대한 여러 주소가 존재하는 경우 클라이언트는 지정된 서버 네트워크 주소의 네임스페이스에 있는 각 파일 시스템에 대해 다른 서버 네트워크 주소 각각에 대한 해당 네임스페이스 위치에 파일 시스템이 있다고 가정할 수 있습니다. fs\_locations에 명시적인 목록이 없더라도 이 작업을 수행할 수 있습니다. 해당 파일 시스템 위치는 fs\_locations 속성을 통해 명시적으로 지정된 것과 마찬가지로 대체 위치로 사용될 수 있습니다.

단일 위치 항목이 여러 서버 IP 주소를 지정하는 경우 클라이언트는 사용할 단일 주소를 선택해야 합니다. 두 개의 서버 주소가 단일 위치 항목으로 지정되고 서로 다른 서버에 해당하는 경우 이는 일반적으로 일종의 구성 오류를 나타내므로 클라이언트는 대안이 가능할 때 이러한 위치 항목을 사용하지 않아야 합니다. 그렇지 않은 경우 클라이언트는 동일한 서버로 지정되지 않은 다른 IP 주소를 사용하지 않고 IP 주소 중 하나를 선택하여 사용해야 합니다.

---
### **8.6.  Additional Client-Side Considerations**

클라이언트가 참조, 복제 및 마이그레이션을 구현하는 서버를 사용할 때 참조 또는 재배치된 파일 시스템을 포함하는 지정된 파일 시스템을 마운트하는 사용자가 해당 사용자 측 파일 시스템의 일관된 그림을 계속 볼 수 있도록 주의해야 합니다. 다른 서버에 있을 수 있는 다수의 서버측 파일 시스템이 포함되어 있음에도 불구하고.

한 가지 중요한 문제는 서버 측 파일 시스템의 루트에서 상위\(UNIX의 경우 ".."로 지정됨\)로 상향 탐색하는 것입니다. 이 경우 참조, 마이그레이션 또는 작업의 결과로 해당 파일 시스템으로 전환됩니다. 복제 결과로 인한 전환. 클라이언트가 그러한 지점에 있고 상위로 올라가야 하는 경우 LOOKUPP 작업을 서버에 보내는 대신 다중 서버 네임스페이스 내에서 볼 수 있듯이 상위로 돌아가야 합니다. 해당 서버의 단일 서버 네임스페이스입니다. 이를 수행하려면 클라이언트는 해당 파일 시스템 루트를 나타내는 파일 핸들을 기억하고 현재 서버에 LOOKUPP 작업을 실행하는 대신 이를 사용해야 합니다. 이를 통해 클라이언트는 상향 탐색과 하향 탐색이 일관된 일관된 네임스페이스를 애플리케이션에 제공할 수 있습니다.

또 다른 문제는 추천 위치 새로 고침과 관련이 있습니다. 조회가 광범위하게 사용되면 서버 구성이 변경됨에 따라 조회도 변경될 수 있습니다. 클라이언트는 참조 순회와 관련된 정보를 캐시하여 향후 클라이언트 측 요청이 서버 통신 없이 로컬로 해결될 것으로 예상됩니다. 이는 일반적으로 클라이언트측 이름 조회 캐싱에 뿌리를 두고 있습니다. 고객은 위치 정보의 변화를 감지하기 위해 추천 지점에 대한 이 데이터를 주기적으로 제거해야 합니다.

클라이언트가 개방형 소유자가 서버의 여러 파일 시스템에 대한 상태를 갖도록 허용하는 경우 잠재적인 문제가 있습니다. 즉, 투명한 경우 개방형 소유자와 관련된 시퀀스 번호를 처리하는 방법이 불분명하다는 점입니다. 상태 마이그레이션. 클라이언트는 개방형 소유자의 사용을 단일 파일 시스템으로 제한하면 이러한 상황을 피할 수 있습니다.

서버는 여러 파일 시스템에 걸쳐 있는 공개 소유자와 관련된 상태 마이그레이션을 거부할 수 있습니다. 서버가 그러한 상태를 마이그레이션하지 않기로 선택한 경우 클라이언트가 새 서버에서 해당 상태 ID를 사용할 때 서버는 NFS4ERR\_BAD\_STATEID를 반환해야 합니다.\(MAY, MUST\)

클라이언트가 마이그레이션 발생 여부에 관계없이 이전 서버에서 해당 상태 ID를 사용할 때 서버는 NFS4ERR\_STALE\_STATEID를 반환해야 합니다.\(MUST\)

---
### **8.7.  Effecting File System Referrals**

파일 시스템이 없고 fs\_locations 속성으로 하나 이상의 대체 위치를 사용할 수 있게 되면 참조가 적용됩니다. 클라이언트는 일반적으로 NFS4ERR\_MOVED 오류를 받고, 적절한 위치 정보를 가져온 다음, 원래 네임스페이스 내의 논리적 위치를 유지하더라도 다른 서버의 파일 시스템에 계속 액세스합니다. 참조는 클라이언트가 이전에 문제의 파일 시스템을 참조하지 않은 경우에만 발생한다는 점에서 마이그레이션 이벤트와 다릅니다\(따라서 전환할 항목이 없음\). 참조는 해당 루트에 없는 파일 시스템이 있는 경우에만 적용됩니다.

아래 섹션에 제공된 예는 실제 클라이언트가 일반적으로 다중 구성 요소 조회를 수행하지 않지만 이름 계층의 상위 수준에 관한 캐시된 정보를 갖는다는 점에서 다소 인위적입니다. 그러나 이러한 예는 특정 클라이언트가 캐시를 선택하는 방법에 대한 세부 사항을 과도하게 설명하지 않고 필요한 동작을 소수의 요청 범위 내에 명확하고 쉽게 넣을 수 있도록 선택되었습니다.

---
#### **8.7.1.  Referral Example (LOOKUP)**

대상 서버에 /this/is/the/path가 없는 환경에서 다음 COMPOUND를 보낸다고 가정해보자. 이는 여러 가지 이유 때문일 수 있습니다. 파일 시스템이 이동한 경우일 수도 있고, 대상 서버가 주로 또는 단독으로 클라이언트를 다양한 파일 시스템이 있는 서버로 참조하도록 기능하는 경우일 수도 있습니다.

```text
   o  PUTROOTFH

   o  LOOKUP "this"

   o  LOOKUP "is"

   o  LOOKUP "the"

   o  LOOKUP "path"

   o  GETFH

   o  GETATTR(fsid, fileid, size, time_modify)
```

주어진 상황에서 결과는 다음과 같습니다.

```text
   o  PUTROOTFH --> NFS_OK.  The current fh is now the root of the
      pseudo-fs.

   o  LOOKUP "this" --> NFS_OK.  The current fh is for /this and is
      within the pseudo-fs.

   o  LOOKUP "is" --> NFS_OK.  The current fh is for /this/is and is
      within the pseudo-fs.

   o  LOOKUP "the" --> NFS_OK.  The current fh is for /this/is/the and
      is within the pseudo-fs.

   o  LOOKUP "path" --> NFS_OK.  The current fh is for /this/is/the/path
      and is within a new, absent file system, but ... the client will
      never see the value of that fh.

   o  GETFH --> NFS4ERR_MOVED.  Fails, because the current fh is in an
      absent file system at the start of the operation and the
      specification makes no exception for GETFH.
```

o GETATTR\(fsid, 파일 ID, 크기, time\_modify\). GETFH의 실패로 인해 COMPOUND 처리가 중지되므로 실행되지 않습니다.

GETFH가 실패하면 클라이언트는 존재하지 않는 파일 시스템의 루트와 해당 파일 시스템을 찾을 수 있는 위치, 즉 서버와 해당 서버의 루트 fh에 상대적인 경로를 결정해야 합니다. 이 예에서 클라이언트는 중간 디렉토리에 대한 파일 핸들 및 속성 정보\(예: fsid\)를 얻지 않았으므로 부재 파일 시스템이 시작되는 위치를 확신할 수 없습니다. 예를 들어, /this/is/the가 이동된 파일 시스템의 루트이고 "경로" 조회가 성공한 이유는 해당 파일 시스템이 이동된 파일 시스템에 없기 때문일 수 있습니다.

해당 작업은 마지막 LOOKUP과 GETFH 사이에서 이동되었습니다\(COMPOUND는 원자적이지 않기 때문에\). 모든 중간 디렉터리에 대한 fsid가 있더라도 아직 fsid가 없기 때문에 /this/is/the/path가 새 파일 시스템의 루트인지 알 수 없습니다.

필요한 정보를 얻으려면 적절한 파일 시스템 경계가 어디에 있는지 확인할 수 있도록 GETFH 및 GETATTR과 함께 LOOKUP 체인을 다시 보내 적어도 fsid를 얻도록 합시다. 클라이언트는 동시에 fs\_locations를 가져오도록 선택할 수 있지만 대부분의 경우 클라이언트는 파일 시스템 경계가 어디에 있는지\(NFS4ERR\_MOVED가 수신되고 수신되지 않은 위치 때문에\) fs\_locations를 가져오는 위치에 대해 잘 추측할 수 있습니다. 불필요한.

```text
   OP01:  PUTROOTFH --> NFS_OK
```

- 현재 fh는 pseudo-fs의 루트에 있습니다.

```text
   OP02:  GETATTR(fsid) --> NFS_OK
```

- 완전성을 위해서요. 일반적으로 클라이언트는 서버와 통신을 설정하자마자 pseudo-fs의 fsid를 알게 됩니다.

```text
   OP03:  LOOKUP "this" --> NFS_OK

   OP04:  GETATTR(fsid) --> NFS_OK
```

- 현재 fsid를 가져와서 파일 시스템 경계가 어디에 있는지 확인하세요. fsid는 이 예에서 pseudo-fs의 ID이므로 경계가 없습니다.

```text
   OP05:  GETFH --> NFS_OK
```

- 현재 fh는 /this에 대한 것이며 pseudo-fs 내에 있습니다.

```text
   OP06:  LOOKUP "is" --> NFS_OK
```

- 현재 fh는 /this/is에 대한 것이며 pseudo-fs 내에 있습니다.

```text
   OP07:  GETATTR(fsid) --> NFS_OK
```

- 현재 fsid를 가져와서 파일 시스템 경계가 어디에 있는지 확인하세요. fsid는 이 예에서 pseudo-fs의 ID이므로 경계가 없습니다.

```text
   OP08:  GETFH --> NFS_OK
```

- 현재 fh는 /this/is에 대한 것이며 pseudo-fs 내에 있습니다.

```text
   OP09:  LOOKUP "the" --> NFS_OK
```

- 현재 fh는 /this/is/the에 대한 것이며 pseudo-fs 내에 있습니다.

```text
   OP10:  GETATTR(fsid) --> NFS_OK
```

- 현재 fsid를 가져와서 파일 시스템 경계가 어디에 있는지 확인하세요. fsid는 이 예에서 pseudo-fs의 ID이므로 경계가 없습니다.

```text
   OP11:  GETFH --> NFS_OK
```

- 현재 fh는 /this/is/the에 대한 것이며 pseudo-fs 내에 있습니다.

```text
   OP12:  LOOKUP "path" --> NFS_OK

   -  The current fh is for /this/is/the/path and is within a new,
      absent file system, but ...
```

- 클라이언트는 해당 fh의 값을 결코 볼 수 없습니다.

```text
   OP13:  GETATTR(fsid, fs_locations) --> NFS_OK
```

- 파일 시스템 경계가 어디에 있는지 fsid를 통해 파악하고 있습니다. 이 작업에서 fsid는 상위 디렉토리\(OP10에서 검색됨\)의 그것과 다릅니다. 우리에게 주어진 fsid가 반드시 새 위치에 보존되는 것은 아닙니다. 해당 fsid는 다를 수 있으며 실제로 이 파일 시스템에 대해 가지고 있는 fsid는 해당 새 서버에 있는 다른 파일 시스템의 유효한 fsid일 수 있습니다.

- 이 특별한 경우에 우리는 /this/is/the가 아닌 /this/is/the/path로 이동했다고 확신합니다. 왜냐하면 우리는 후자의 fsid를 갖고 있고 pseudo-fs의 fsid이기 때문입니다. 아마도 움직일 수 없을 것입니다. 그러나 다른 예에서는 의존할 수 있는 이러한 종류의 정보가 없을 수 있습니다\(예: /this/is/the는 /this/is/the/path와 별개의 비 의사 파일 시스템일 수 있음\). 이동되는 파일 시스템의 경계에는 신뢰할 수 있는 다른 소스 정보가 있어야 합니다. 예를 들어 /this/is 파일 시스템이 이동된 경우 참조가 아닌 마이그레이션의 경우가 발생하며 마이그레이션된 파일 시스템의 경계가 명확해지면 fs\_locations를 가져올 수 있습니다.

- 이 시점에서 NFS4ERR\_MOVED를 받았다는 사실은 이것이 추천일 가능성이 높으며 대상이 필요하다는 것을 의미하기 때문에 fs\_locations를 가져오는 중입니다. /this/is/the가 마이그레이션된 파일 시스템인 경우에도 해당 파일 시스템에 대한 위치 정보가 필요합니다.

```text
   OP14:  GETFH --> NFS4ERR_MOVED
```

- 작업 시작 시 현재 fh가 없는 파일 시스템에 있고 사양에서 GETFH에 대한 예외를 두지 않기 때문에 실패합니다. 이는 서버가 존재하지 않는 파일 시스템 내에서 클라이언트에게 파일 핸들을 절대 보내지 않는다는 것을 의미합니다.

위의 내용을 고려하면 클라이언트는 fsid 변경이 발생한 위치\("the"와 "path" 사이\)를 기록하여 부재 파일 시스템의 루트가 어디에 있는지\(/this/is/the/path\) 압니다. fs\_locations 속성은 참조가 진행될 수 있도록 클라이언트에 없는 파일 시스템의 실제 위치도 제공합니다. 서버는 참조 서버가 보낸 정보와 파일 시스템의 홈 정보 간에 충돌 문제가 발생할 가능성이 거의 없도록 클라이언트에 부재하는 파일 시스템에 대한 최소한의 정보를 제공합니다. 참조 서버에는 파일 핸들과 속성이 거의 없으며 클라이언트는 참조를 활성화하는 기능을 사용하여 수신한 정보를 임시 정보로 처리할 수 있습니다.

---
#### **8.7.2.  Referral Example (READDIR)**

클라이언트가 참조를 만날 수 있는 또 다른 상황은 일부 하위 디렉터리가 존재하지 않는 파일 시스템의 루트인 디렉터리에서 READDIR을 수행하는 경우입니다.

해당 디렉토리가 다음과 같이 읽혀진다고 가정합니다.

```text
   o  PUTROOTFH

   o  LOOKUP "this"

   o  LOOKUP "is"

   o  LOOKUP "the"

   o  READDIR(fsid, size, time_modify, mounted_on_fileid)
```

이 경우 rdattr\_error가 요청되지 않고 fs\_locations가 요청되지 않으며 일부 속성을 제공할 수 없기 때문에 결과는 READDIR에서 NFS4ERR\_MOVED 오류가 되며 자세한 결과는 다음과 같습니다.

```text
   o  PUTROOTFH --> NFS_OK.  The current fh is at the root of the
      pseudo-fs.

   o  LOOKUP "this" --> NFS_OK.  The current fh is for /this and is
      within the pseudo-fs.

   o  LOOKUP "is" --> NFS_OK.  The current fh is for /this/is and is
      within the pseudo-fs.

   o  LOOKUP "the" --> NFS_OK.  The current fh is for /this/is/the and
      is within the pseudo-fs.

   o  READDIR(fsid, size, time_modify, mounted_on_fileid) -->
      NFS4ERR_MOVED.  Note that the same error would have been returned
      if /this/is/the had migrated, but it is returned because the
      directory contains the root of an absent file system.
```

이제 rdattr\_error를 사용하여 다시 보낸다고 가정해 보겠습니다.

```text
   o  PUTROOTFH

   o  LOOKUP "this"

   o  LOOKUP "is"

   o  LOOKUP "the"

   o  READDIR(rdattr_error, fsid, size, time_modify, mounted_on_fileid)
```

결과는 다음과 같습니다:

```text
   o  PUTROOTFH --> NFS_OK.  The current fh is at the root of the
      pseudo-fs.

   o  LOOKUP "this" --> NFS_OK.  The current fh is for /this and is
      within the pseudo-fs.

   o  LOOKUP "is" --> NFS_OK.  The current fh is for /this/is and is
      within the pseudo-fs.

   o  LOOKUP "the" --> NFS_OK.  The current fh is for /this/is/the and
      is within the pseudo-fs.

   o  READDIR(rdattr_error, fsid, size, time_modify, mounted_on_fileid)
      --> NFS_OK.  The attributes for the directory entry with the
      component named "path" will only contain rdattr_error with the
      value NFS4ERR_MOVED, together with an fsid value and a value for
      mounted_on_fileid.
```

따라서 fs\_locations를 얻기 위해 또 다른 READDIR을 수행한다고 가정합니다\(단원 8.7.1에서와 같이 GETATTR을 직접 사용할 수도 있었지만\).

```text
   o  PUTROOTFH

   o  LOOKUP "this"

   o  LOOKUP "is"

   o  LOOKUP "the"

   o  READDIR(rdattr_error, fs_locations, mounted_on_fileid, fsid, size,
      time_modify)
```

결과는 다음과 같습니다.

```text
   o  PUTROOTFH --> NFS_OK.  The current fh is at the root of the
      pseudo-fs.

   o  LOOKUP "this" --> NFS_OK.  The current fh is for /this and is
      within the pseudo-fs.

   o  LOOKUP "is" --> NFS_OK.  The current fh is for /this/is and is
      within the pseudo-fs.

   o  LOOKUP "the" --> NFS_OK.  The current fh is for /this/is/the and
      is within the pseudo-fs.

   o  READDIR(rdattr_error, fs_locations, mounted_on_fileid, fsid, size,
      time_modify) --> NFS_OK.  The attributes will be as shown below.
```

"path"라는 구성요소가 있는 디렉토리 항목의 속성에는 다음만 포함됩니다.

```text
   o  rdattr_error (value: NFS_OK)

   o  fs_locations

   o  mounted_on_fileid (value: unique fileid within referring file
      system)

   o  fsid (value: unique value within referring server)
```

"path" 항목의 속성에는 size 또는 time\_modify가 포함되지 않습니다. 이러한 속성은 존재하지 않는 파일 시스템 내에서 사용할 수 없기 때문입니다.

---
### **8.8.  The Attribute fs_locations**

fs\_locations 속성은 fs\_location4\(섹션 2.2.6\) 및 fs\_locations4\(섹션 2.2.7\)에 의해 정의됩니다. 서버 이름과 해당 서버의 네임스페이스 내 파일 시스템 루트에 대한 경로를 제공하여 파일 시스템의 위치를 ​​나타내는 데 사용됩니다. 서버 세트의 네임스페이스 내 동일한 경로에 해당 파일 시스템이 있는 경우 서버 이름 배열이 제공될 수 있습니다. 서버 배열의 항목은 UTF-8 문자열이며 기존 DNS 호스트 이름, IPv4 주소, IPv6 주소 또는 길이가 0인 문자열 중 하나를 나타냅니다. RPC에 사용되는 현재 주소를 나타내기 위해 길이가 0인 문자열을 사용해야 합니다. 동일한 루트 경로를 공유하는 모든 서버가 하나의 fs\_location4 인스턴스에 나열될 필요는 없습니다. 편의를 위해 서버 이름 배열이 제공됩니다. 동일한 루트 경로를 공유하는 서버는 fs\_locations 속성의 별도 fs\_location4 항목에 나열될 수도 있습니다.\(SHOULD\)

fs\_locations4 데이터 유형 및 fs\_locations 속성에는 이러한 위치의 배열이 포함되어 있습니다. 각 서버의 네임스페이스는 다르게 구성될 수 있으므로 fs\_root 필드를 제공한다. fs\_root가 나타내는 경로는 현재 서버의 네임스페이스, 즉 fs\_locations 속성을 얻은 서버의 파일 시스템 위치를 나타냅니다. fs\_root 경로는 현재 파일 핸들이 지정하는 현재 파일 시스템 내의 개체에 관계없이 위치가 보고되는 파일 시스템의 루트를 명확하게 참조하여 클라이언트를 지원하기 위한 것입니다. fs\_root는 단순히 클라이언트가 현재 서버의 개체\(즉, fs\_locations 속성이 적용되는 개체\)에 도달하는 데 사용하는 경로 이름입니다.

fs\_locations 속성이 조사되고 대체 파일 시스템 위치가 없는 경우 서버는 유효한 fs\_root와 함께 fs\_location4 구조의 길이가 0인 배열을 반환해야 합니다.\(SHOULD\)

예를 들어, 두 서버\(servA 및 servB\)에 복제된 파일 시스템이 있다고 가정합니다. servA에서 파일 시스템은 /a/b/c 경로에 있습니다. servB에서 파일 시스템은 /x/y/z 경로에 있습니다. 클라이언트가 /a/b/c/d에 있는 디렉토리에 대한 fs\_locations 값을 얻는 경우 파일 시스템의 루트가 /a/b/c에 있는 servA의 네임스페이스에 있는지 반드시 알지 못할 수도 있습니다. 클라이언트가 servB로 전환할 때 servA에서 처음 참조한 디렉토리가 이제 /x/y/z/d 경로로 표시되는지 확인해야 합니다.

servB에서. 이를 용이하게 하기 위해 servA가 제공하는 fs\_locations 속성에는 fs\_root 값 /a/b/c와 fs\_locations에 두 개의 항목이 있습니다. fs\_locations의 한 항목은 자체\(servA\)에 대한 항목이고, 다른 항목은 경로가 /x/y/z인 servB에 대한 항목입니다. 이 정보를 사용하여 클라이언트는 액세스 경로 시작 부분에서 /a/b/c를 /x/y/z로 대체하고 /x/y/z/d를 구성하여 새 서버에 사용할 수 있습니다.

각 루트 경로의 구성 요소 수가 동일해야 한다는 요구 사항은 없습니다. rootpath 또는 fs\_root의 구성 요소 수 사이에는 관계가 없으며 각 rootpath와 fs\_root의 구성 요소 중 어느 것도 동일할 필요가 없습니다. 위의 예에서 위치 배열의 세 번째 요소\(서버는 "servC", 루트 경로는 "/I/II"\), 위치 배열의 네 번째 요소\(서버는 "servD\)를 가질 수 있습니다. " 및 루트 경로는 "/aleph/beth/gimel/daleth/he"와 동일합니다.

fs\_root와 루트 경로 사이의 관계는 클라이언트가 현재 서버의 fs\_root에 표시된 경로 이름을 새 서버의 루트 경로에 표시된 대체 이름으로 바꾸는 것입니다.

참조 또는 마이그레이션된 파일 시스템의 예로 serv1에 파일 시스템이 있다고 가정합니다. serv1에서 파일 시스템은 /az/buky/vedi/glagoli에 있습니다. 클라이언트는 Glagoli의 개체가 마이그레이션된\(또는 추천인\) 것을 발견합니다. 클라이언트는 /az/buky/vedi/glagoli의 fs\_root와 위치 배열의 한 요소\(서버는 serv2, 루트 경로는 /izhitsa/fita\)를 포함하는 fs\_locations 속성을 가져옵니다. 클라이언트는 /az/buky/vedi/glagoli를 /izhitsa/fita로 바꾸고 serv2에서 후자의 경로 이름을 사용합니다.

따라서 서버는 클라이언트가 fs\_locations 속성이 적용되는 객체에 도달하는 데 사용한 경로와 동일한 fs\_root를 반환해야 합니다. 그렇지 않으면 클라이언트는 새 서버에서 사용할 새 경로를 결정할 수 없습니다.\(MUST\)

---
## **9.  File Locking and Share Reservations**

NFS 프로토콜에 잠금을 통합하면 반드시 상태 저장이 가능해집니다. 공유 예약을 포함하면 프로토콜은 NFS와 NLM\(Network Lock Manager\) \[xnfs\]의 기존 조합보다 상태에 훨씬 더 의존하게 됩니다. 이 상태를 관리 가능하게 만드는 데는 세 가지 구성 요소가 있습니다.

o 클라이언트와 서버 간의 명확한 구분

o 클라이언트와 서버 사이의 상태 불일치를 안정적으로 감지하는 능력

o 간단하고 강력한 복구 메커니즘

이 모델에서는 서버가 상태 정보를 소유합니다. 클라이언트는 잠금 변경을 요청하고 서버는 변경된 내용으로 응답합니다. 클라이언트가 시작하지 않은 잠금 상태 변경은 자주 발생하지 않습니다. 클라이언트는 이러한 변경 사항에 대한 즉각적인 알림을 받고 서버의 변경 사항을 반영하도록 잠금 상태 보기를 조정할 수 있습니다.

서버에서 생성되어 요청 시 클라이언트에 전달되는 개별 상태 조각은 128비트 상태 ID로 표시됩니다. 이러한 상태 ID는 특정 열린 파일, 특정 소유자가 보유한 바이트 범위 잠금 세트 또는 특정 방법이나 특정 위치에서 파일에 액세스하기 위한 회수 가능한 권한 위임을 나타낼 수 있습니다.

모든 경우에 클라이언트 전체를 나타내는 가장 일반적인 정보에서 대부분의 클라이언트 및 서버 잠금 상호 작용에 사용되는 최종 경량 상태 ID로 전환됩니다. 이 전환의 세부정보는 개체 유형에 따라 다르지만 항상 클라이언트 ID로 시작됩니다.

Win32 공유 예약을 지원하려면 파일을 원자적으로 OPEN하거나 CREATE하고 동일한 작업에서 적절한 잠금을 적용해야 합니다. 별도의 공유/공유 해제 작업을 사용하면 Win32 OpenFile API를 올바르게 구현할 수 없습니다. 공유 의미 체계를 올바르게 구현하려면 파일을 열거나 생성할 때 사용된 이전 NFS 프로토콜 메커니즘\(LOOKUP, CREATE, ACCESS\)을 교체해야 합니다. NFSv4 프로토콜에는 LOOKUP, CREATE 및 ACCESS의 NFSv3 방법론을 포함하는 OPEN 작업이 있습니다. 그러나 많은 작업에 파일 핸들이 필요하기 때문에 서버에 상태를 설정하지 않고 파일 이름을 파일 핸들에 매핑하도록 기존 LOOKUP이 유지됩니다. 접근 권한을 부여하거나 파일을 수정하는 정책은 클라이언트의 상태에 따라 서버에서 관리됩니다. 이러한 메커니즘은 권고 전용 잠금부터 전체 강제 잠금까지 정책을 구현할 수 있습니다.

---
### **9.1.  Opens and Byte-Range Locks**

READ 및 WRITE 작업과 비교할 때 바이트 범위 잠금을 조작하는 일은 드물다고 가정됩니다. 또한 서버가 다시 시작되거나 네트워크가 분할되는 경우는 상대적으로 드물다고 가정됩니다. 따라서 READ 및 WRITE 작업이 잠금을 보유하고 있는지 여부를 나타내는 간단한 메커니즘을 갖는 것이 중요합니다. 바이트 범위 잠금 요청에는 잠금을 설정하고 잠금 소유자를 고유하게 정의하는 데 필요한 중량 정보가 포함되어 있습니다.

다음 섹션에서는 중량 정보에서 대부분의 클라이언트 및 서버 잠금 및 임대 상호 작용에 사용되는 최종 stateid로의 전환에 대해 설명합니다.

---
#### **9.1.1.  Client ID**

각 LOCK 요청에 대해 클라이언트는 서버에 자신을 식별해야 합니다. 이는 올바른 잠금 식별 및 충돌 복구를 허용하는 방식으로 수행됩니다. 서버에 대한 ID를 설정하려면 SETCLIENTID 작업과 SETCLIENTID\_CONFIRM 작업 순서가 필요합니다. 클라이언트의 새로운 구현에 의한 식별 설정은 새로운 클라이언트 구현이 임대가 만료될 때까지 기다리게 하는 것과는 반대로 클라이언트의 이전 구현이 서버에 가졌을 수 있는 임대 상태를 즉시 중단하는 효과도 있습니다. 임대 상태를 깨면 서버는 모든 잠금, 공유 예약을 제거하고 서버가 CLAIM\_DELEGATE\_PREV 클레임 유형을 지원하지 않는 경우 동일한 ID를 가진 동일한 클라이언트와 연결된 모든 위임 상태를 제거합니다. 위임 상태 복구에 대한 논의는 섹션 10.2.1을 참조하세요.

열기 소유자와 바이트 범위 잠금 소유자는 별도의 엔터티이며 동일한 불투명 배열을 사용하여 각각의 소유자를 지정하더라도 별도의 상태로 유지됩니다. 프로토콜은 공개 소유자\(open\_owner4 구조로 표시\)와 잠금 소유자\(lock\_owner4 구조로 표시\)를 구별합니다.

두 종류의 소유자 모두 클라이언트 ID와 불투명 소유자 문자열로 구성됩니다. 각 클라이언트에 대해 해당 클라이언트와 함께 사용되는 고유한 소유자 값 집합은 해당 클라이언트에 대한 해당 유형의 소유자 집합을 구성합니다.

각 열기는 특정 열기 소유자와 연결되고, 각 바이트 범위 잠금은 잠금 소유자 및 열기 소유자와 연결되며, 후자는 LOCK 작업이 수행된 열린 파일과 연결된 열기 소유자입니다.

클라이언트 식별은 다음 구조로 캡슐화됩니다.

```text
   struct nfs_client_id4 {
           verifier4       verifier;
           opaque          id<NFS4_OPAQUE_LIMIT>;
   };
```

첫 번째 필드인 verifier는 클라이언트 재부팅을 감지하는 데 사용되는 클라이언트 구현 검증자입니다. 검증자가 서버가 이전에 클라이언트에 대해 기록한 것과 다른 경우에만\(구조의 두 번째 필드인 id로 식별됨\) 서버는 클라이언트의 임대 상태를 취소하는 프로세스를 시작합니다.

두 번째 필드인 id는 클라이언트를 고유하게 정의하는 가변 길이 문자열입니다.

클라이언트가 ID 문자열을 생성하는 방법에 대한 몇 가지 고려 사항이 있습니다.

o 여러 클라이언트가 동일한 문자열을 제공하지 않도록 문자열은 고유해야 합니다. 동일한 문자열 범위를 제공하는 두 클라이언트의 결과는 한 클라이언트에서 오류가 발생하고 임대 상태가 갑자기 취소된 한 클라이언트까지 발생합니다.

o 동일한 클라이언트의 후속 구현\(예: 재부팅\) 시 클라이언트가 동일한 문자열을 제공하도록 문자열을 선택해야 합니다. 구현자는 로컬 파일에 문자열을 기록해야 하는 접근 방식에 대해 주의해야 합니다. 이는 로컬 디스크가 없고 모든 파일 액세스가 NFSv4 서버에서 이루어지는 환경에서 구현을 사용할 수 없기 때문입니다.

o 문자열은 모든 서버 네트워크 주소에 공통되는 것이 아니라 클라이언트가 액세스하는 각 서버 네트워크 주소마다 달라야 합니다. 그 이유는 동일한 서버가 여러 네트워크 주소를 수신하고 있는지 클라이언트가 알 수 없기 때문입니다. 클라이언트가 해당 서버의 각 네트워크 주소에 동일한 ID 문자열을 사용하여 SETCLIENTID를 발행하는 경우 서버는 해당 클라이언트가 동일한 클라이언트라고 생각하고 연속되는 각 SETCLIENTID로 인해 서버는 클라이언트의 이전 임대 상태를 제거하는 프로세스를 시작하게 됩니다.

o 문자열을 생성하는 알고리즘은 클라이언트의 네트워크 주소가 변경되지 않을 것이라고 가정해서는 안 됩니다. 여기에는 클라이언트 구현 간의 변경 사항과 클라이언트가 현재 구현에서 계속 실행되는 동안의 변경 사항도 포함됩니다. 이는 클라이언트가 클라이언트와 서버의 네트워크 주소만 포함하는 경우를 의미합니다.

- ID 문자열에는 클라이언트가 네트워크 주소를 포기한 후 ID 문자열을 생성하기 위해 유사한 알고리즘을 사용하는 다른 클라이언트가 충돌하는 ID 문자열을 생성할 실제 위험이 있습니다.

위의 고려 사항을 고려하여 잘 생성된 ID 문자열의 예는 다음을 포함합니다.

o 서버의 네트워크 주소.

o 클라이언트의 네트워크 주소.

o 사용자 수준 NFSv4 클라이언트의 경우 UUID\(Universally Unique Identifier\)와 같이 동일한 호스트에서 실행되는 다른 사용자 수준 클라이언트와 클라이언트를 구별하기 위한 추가 정보를 포함해야 합니다.

o 다음 중 하나 이상과 같이 고유한 경향이 있는 추가 정보:

- \* 클라이언트 시스템의 일련 번호\(개인 정보 보호를 위해 일련 번호에 대해 단방향 기능을 수행하는 것이 가장 좋습니다\).

- \* MAC 주소\(개인 정보 보호를 위해 MAC 주소에서 단방향 기능을 수행하는 것이 가장 좋습니다\).

- \* NFSv4 소프트웨어가 클라이언트에 처음 설치되었을 때의 타임스탬프\(단, 파일은 NFSv4를 통해서만 액세스할 수 있으므로 파일에 저장된 정보 사용에 대해 앞서 언급한 주의 사항이 적용됩니다\).

- \* 실제 난수입니다. 그러나 이 숫자는 클라이언트 구현 간에 동일해야 하기 때문에 이는 소프트웨어 설치의 타임스탬프를 사용하는 것과 동일한 문제를 공유합니다.

보안 조치로서, 주어진 ID 문자열에 대한 상태를 설정한 주체가 SETCLIENTID를 발행한 주체와 동일하지 않은 경우 서버는 클라이언트의 임대 상태를 취소해서는 안 됩니다.\(MUST NOT\)

SETCLIENTID\(섹션 16.33\) 및 SETCLIENTID\_CONFIRM\(섹션 16.34\)에는 서버가 위임 지원을 위해 클라이언트에 콜백하는 데 필요한 정보를 설정하는 두 번째 목적이 있습니다. 클라이언트의 임대 상태를 제거하지 않고 클라이언트의 동일한 구현 내에서 SETCLIENTID 및 SETCLIENTID\_CONFIRM을 통해 이 정보를 변경할 수 있습니다.

SETCLIENTID 및 SETCLIENTID\_CONFIRM 시퀀스가 ​​성공적으로 완료되면 클라이언트는 더 길고 덜 컴팩트한 nfs\_client\_id4 구조 대신 clientid4 유형의 단축 클라이언트 식별자를 사용합니다. 이 단축 클라이언트 식별자\(클라이언트 ID\)는 서버에서 할당되며 이전에 서버에서 할당한 클라이언트 ID와 충돌하지 않도록 선택해야 합니다. 이는 서버를 다시 시작하거나 재부팅할 때마다 적용됩니다. 서버 재부팅 후 클라이언트 ID가 서버에 표시되고 해당 클라이언트 ID가 인식되지 않으면 서버는 NFS4ERR\_STALE\_CLIENTID 오류와 함께 요청을 거부합니다. 이런 일이 발생하면 클라이언트는 SETCLIENTID 작업을 사용하여 새 클라이언트 ID를 얻은 다음 서버 재부팅 사례에 필요한 기타 복구를 진행해야 합니다\(섹션 9.6.2 참조\).

또한 클라이언트는 현재 클라이언트 ID에서 파생된 stateid를 사용하여 NFS4ERR\_STALE\_STATEID 오류를 수신할 때 SETCLIENTID 작업을 사용해야 합니다. 이는 기존 클라이언트 ID를 무효화한 서버 재부팅을 나타내기 때문입니다\(자세한 내용은 섹션 9.6.2 참조\).

작업의 전체 사양은 SETCLIENTID\(섹션 16.33.4\) 및 SETCLIENTID\_CONFIRM\(섹션 16.34.4\)에 대한 자세한 설명을 참조하세요.

---
#### **9.1.2.  Server Release of Client ID**

클라이언트가 해당 클라이언트 ID와 관련된 상태를 보유하지 않는다고 서버가 판단하는 경우 서버는 클라이언트 ID를 해제하도록 선택할 수 있습니다. 서버는 간헐적으로 활성인 클라이언트가 자원을 소비하지 않도록 비활성 클라이언트에 대해 이 선택을 할 수 있습니다. 이 릴리스 이후에 클라이언트가 서버에 연결하는 경우 서버는 클라이언트가 적절한 오류를 수신하여 SETCLIENTID/SETCLIENTID\_CONFIRM 시퀀스를 사용하여 새 ID를 설정하도록 해야 합니다. 이러한 이벤트로부터 클라이언트를 복구하기 위한 결과 작업은 서버가 실패하고 다시 시작된 것과 동일한 부담이 되기 때문에 서버는 클라이언트 ID 해제를 매우 주저해야 한다는 점은 분명합니다. 일반적으로 서버는 해당 클라이언트에서 몇 분 동안 활동이 없으면 클라이언트 ID를 해제하지 않습니다.

SETCLIENTID 요청의 ID 문자열이 올바르게 구성되고 클라이언트가 SETCLIENTID를 연속적으로 사용할 때마다 동일한 주체를 사용하도록 주의를 기울이면 활성 서비스 거부 공격을 제외하고 NFS4ERR\_CLID\_INUSE가 반환되지 않아야 합니다.

그러나 클라이언트 버그, 서버 버그 또는 ID 문자열의 주요 소유자가 의도적으로 변경된 경우\(예: 보안 버전을 변경하는 클라이언트의 경우, 새 버전에서는 이전 소유자에 대한 매핑이 없음\) 드물지만 NFS4ERR\_CLID\_INUSE가 발생합니다.

이 경우 서버가 현재 상태가 없는 클라이언트 ID에 대한 SETCLIENTID를 얻거나 상태가 있지만 임대가 만료된 경우 NFS4ERR\_CLID\_INUSE를 반환하는 대신 서버는 SETCLIENTID를 허용하고 다음에 오는 경우 새 클라이언트 ID를 확인해야 합니다. 적절한 SETCLIENTID\_CONFIRM.\(MUST\)

---
#### **9.1.3.  Use of Seqids**

여러 상황에서 "seqids"라는 32비트 시퀀스 값이 잠금 상태 관리의 일부로 사용됩니다. 다음과 같은 값이 사용됩니다.

o 특정 잠금 소유자 또는 공개 소유자와 관련된 잠금 관련 작업의 순서를 제공합니다. 자세한 설명은 섹션 9.1.7을 참조하십시오.

o 특정 소유권 특성 세트를 공유하는 잠금 세트의 순서화된 인스턴스 세트를 정의합니다. 자세한 설명은 섹션 9.1.4.2를 참조하세요.

동일한 객체에 대한 연속적인 seqid 값은 일반적으로 현재 값을 1씩 증가시켜 도달합니다. 이 패턴은 seqid가 NFS4\_UINT32\_MAX를 지나 증가할 때까지 계속됩니다. 이 경우 0이 아닌 1이 다음 seqid 값이 됩니다.

두 seqid 값 중 어느 것이 나중에 오는지 결정하기 위해 두 seqid 값을 비교하는 경우 랩어라운드 가능성을 고려해야 합니다. 대부분의 경우 값은 간단한 수치 비교를 사용할 수 있는 수준입니다. 예를 들어, 비교 대상 seqid 값이 모두 100만 미만인 경우 값이 클수록 나중에 간주할 수 있습니다. 반면, 값 중 하나가 NFS\_UINT32\_MAX 또는 그 근처에 있고 다른 하나가 100만 미만인 경우 구현에서는 더 낮은 값이 한 번 더 랩어라운드되어 수치적으로 더 낮지만 실제로는 더 늦었다고 합리적으로 결정할 수 있습니다.

구현에서는 하나에서 다른 것으로의 증분 체인이 2\*\*31보다 짧다는 합리적인 가정을 채택하여 잠재적인 랩어라운드가 있는 경우 seqid를 비교할 수 있습니다. 따라서 두 seqid의 차이가 2\*\*31보다 작으면 낮은 seqid가 더 이른 것으로 처리됩니다. 다만, 차이점이라면

두 seqid 사이의 값이 2\*\*31보다 크거나 같은 경우, 낮은 seqid가 한 번 더 랩어라운드를 겪었고 나중에 처리할 수 있다고 가정할 수 있습니다.

---
#### **9.1.4.  Stateid Definition**

서버가 모든 유형의 잠금\(열기, 바이트 범위 잠금 및 위임 포함\)을 부여하면 동일한 유형의 동일한 파일에 대한 잠금 세트\(종종 단일 잠금\)를 나타내는 고유한 상태 ID로 응답합니다. 동일한 소유권 특성을 공유합니다. 따라서 서로 다른 공개 소유자가 동일한 파일을 열면 각각 식별 가능한 상태 ID가 있습니다. 마찬가지로, 특정 잠금 소유자가 소유한 파일의 각 바이트 범위 잠금 세트에는 고유한 식별 상태 ID가 있습니다. 또한 위임에는 참조할 수 있는 관련 상태 ID가 있습니다. stateid는 잠금 또는 잠금 세트에 대한 간략한 참조로 사용되며, stateid가 주어지면 서버는 연관된 상태 소유자 또는 상태 소유자\(공개 소유자/잠금 소유자 쌍의 경우\)를 결정할 수 있습니다. 연관된 파일 핸들. stateid를 사용하는 경우 현재 파일 핸들은 해당 stateid와 연결된 핸들이어야 합니다.

특정 클라이언트 ID와 연관된 모든 stateid는 해당 stateid의 청구를 나타내는 공통 임대와 서버에서 유지 관리하기 위해 나타내는 객체와 연관됩니다. 임대에 대한 논의는 섹션 9.5를 참조하십시오.

각 stateid는 서버마다 고유해야 합니다. 많은 작업에서는 stateid를 인수로 사용하지만 clientid는 사용하지 않으므로 서버는 stateid에서 클라이언트를 추론할 수 있어야 합니다.

---
##### **9.1.4.1.  Stateid Types**

특별한 상태 ID\(섹션 9.1.4.3 참조\)를 제외하고 각 상태 ID는 NFSv4 프로토콜에 의해 정의된 유형 집합 중 하나의 잠금 개체를 나타냅니다. 보증에 관해 언급한 이러한 모든 경우에는 클라이언트 재시작이나 잠금 취소와 같은 상황이 발생하여 보증이 무효화될 수 있다는 점에 유의하세요.

o 상태 ID는 파일 열기를 나타낼 수 있습니다.

- 이 경우 각 stateid는 지정된 클라이언트 ID/open-owner/filehandle 트리플에 대한 OPEN 상태를 나타냅니다. 이러한 stateid는 업그레이드 및 OPEN\_DOWNGRADE 작업을 초래하는 OPEN에 대한 응답으로 변경될 수 있습니다\(결과적으로 stateid의 seqid가 증가함\).

o Stateid는 바이트 범위 잠금 세트를 나타낼 수 있습니다.

- 특정 소유자가 특정 파일에 대해 보유한 모든 잠금과 특정 열린 파일의 보호 하에 획득한 모든 잠금은 단일 상태 ID와 연결되며, LOCK 및 LOCKU 작업이 해당 잠금 집합에 영향을 미칠 때마다 seqid가 증가합니다.

o Stateid는 파일 위임을 나타낼 수 있습니다. 이는 위임이 반환될 때까지 다른 클라이언트가 특정 파일을 참조하거나 수정하지 않을 것임을 서버가 클라이언트에 대해 기억할 수 있는 보증입니다.

- stateid는 특정 파일 핸들에 대해 클라이언트가 보유한 단일 위임을 나타냅니다.

---
##### **9.1.4.2.  Stateid Structure**

Stateid는 두 개의 필드, 즉 특정 잠금 세트를 식별하는 96비트 "기타" 필드와 32비트 "seqid" 시퀀스 값으로 나뉩니다. 특별한 상태 ID\(섹션 9.1.4.3 참조\)의 경우를 제외하고 "기타" 필드의 특정 값은 동일한 유형의 잠금 세트\(예: 바이트 범위 잠금, 열기 또는 위임\)를 나타냅니다. 특정 파일이나 디렉터리를 공유하며 동일한 소유권 특성을 공유합니다. seqid는 이러한 잠금 세트의 특정 인스턴스를 지정하고 세트에서 잠금을 추가하거나 삭제하거나 잠금이 적용되는 바이트 범위의 변경을 통해 해당 잠금 세트의 변경 사항을 나타내기 위해 증가됩니다. 하나 이상의 잠금 유형의 업그레이드 또는 다운그레이드.

이러한 잠금 세트가 처음 생성되면 서버는 seqid 값이 1인 stateid를 반환합니다. 잠금 세트를 수정하는 후속 작업에서 서버는 동일한 상태-소유자/파일/유형 조합에 대한 stateid를 반환할 때마다 seqid 필드를 1씩 전진시켜야 하며 해당 작업은 세트에 일부 변경을 가할 수 있습니다. 실제로 지정된 잠금 수입니다. 이 경우 서버는 이전에 해당 상태 소유자/파일/유형 조합에 사용된 것과 동일한 "기타" 필드와 함께 증가된 seqid 필드와 함께 stateid를 반환합니다.

Seqids는 클라이언트와 서버 모두에서 비교됩니다. 클라이언트는 이러한 비교를 사용하여 작업 순서를 결정하고, 서버는 이를 사용하여 NFS4ERR\_OLD\_STATEID 오류가 반환되는지 여부를 결정합니다. 모든 경우에 섹션 9.1.3에서 설명한 대로 seqid 랩어라운드 가능성을 고려해야 합니다.

---
##### **9.1.4.3.  Special Stateids**

"기타" 필드가 모두 0이거나 모두 1인 Stateid 값은 예약되어 있습니다. 이는 서버에 의해 할당되어서는 안 되지만 프로토콜에 의해 정의된 특별한 의미를 갖습니다. 특별한 의미는 "other" 필드가 모두 0인지 아니면 모두 1인지 여부와 seqid 필드의 특정 값에 따라 달라집니다.\(MUST NOT\)

NFSv4에서는 "other"와 seqid의 다음 조합이 정의됩니다.

익명 Stateid: "other"와 seqid가 모두 0인 경우 stateid는 요청과 관련된 열려 있는 상태가 없음을 나타내기 위해 READ, WRITE 및 SETATTR 요청에 사용할 수 있는 특수 익명 stateid로 처리됩니다. 익명의 stateid 값이 사용되고 기존 열기가 요청된 액세스 형식을 거부하면 해당 요청에 대한 액세스가 거부됩니다.

READ Bypass Stateid: "other"와 seqid가 모두 1인 경우 stateid는 특수한 READ Bypass StateID입니다. 이 값이 WRITE 또는 SETATTR에 사용되면 익명 값처럼 처리됩니다. READ에서 사용될 때 서버는 일반적으로 READ 요청에 대한 액세스가 거부되더라도 액세스를 허용할 수 있습니다.\(MAY\)

"기타" 필드에 모두 0 또는 모두 1이 있지만 위의 경우 중 하나와 일치하지 않는 stateid 값이 사용되는 경우 서버는 NFS4ERR\_BAD\_STATEID 오류를 반환해야 합니다.\(MUST\)

다른 상태 ID와 달리 특수 상태 ID는 개별 클라이언트 ID 또는 파일 핸들과 연결되지 않으며 모든 유효한 클라이언트 ID 및 파일 핸들과 함께 사용할 수 있습니다.

---
##### **9.1.4.4.  Stateid Lifetime and Validation**

Stateid는 클라이언트가 다시 시작되거나 서버가 다시 시작될 때까지 또는 클라이언트가 CLOSE 또는 DELEGRETURN과 같은 작업을 통해 stateid와 관련된 모든 잠금을 반환할 때까지 유효한 상태로 유지되어야 합니다. 취소로 인해 잠금이 손실된 경우 클라이언트 ID가 유효한 한 stateid는 취소된 상태의 유효한 지정으로 유지됩니다. 바이트 범위 잠금과 관련된 Stateid는 예외입니다. LOCKU가 나머지 모든 잠금을 해제하더라도 연관된 열려 있는 파일이 열려 있는 한 유효합니다.

클라이언트가 반환을 요청하지 않고도 클라이언트의 잠금이 무효화되는 상황이 있다는 점에 유의해야 합니다. 여기에는 임대 만료 및 임대 기간 내의 다양한 형태의 잠금 취소가 포함됩니다. 이러한 상황에서는 stateid가 유효한 상태로 유지되며 클라이언트는 이를 사용하여 관련된 손실된 잠금의 처리를 결정할 수 있다는 점에 유의하는 것이 중요합니다.

"기타" 값은 단일 클라이언트 ID의 컨텍스트 내에서 다른 목적\(예: 다른 파일 핸들, 소유자 또는 잠금 유형\)으로 재사용되어서는 안 됩니다. 서버는 해제될 수 있는 지점을 넘어 동일한 목적으로 "기타" 값을 유지할 수 있지만, 그렇게 하는 경우 이전 값과의 순서 연속성을 유지해야 합니다.

서버가 유효하지 않고 오래된 stateid를 인식해야 한다는 요구 사항을 충족하는 데 사용할 수 있는 메커니즘 중 하나는 서버가 stateid의 "기타" 필드를 두 개의 필드로 나누는 것입니다.

o 잠금 상태 구조 테이블에 대한 인덱스입니다.

o 특정 용도로 테이블 항목을 할당할 때마다 증가하는 세대 번호.

그런 다음 각 테이블 항목에 다음을 저장합니다.

o stateid가 연결된 클라이언트 ID입니다.

o 이 인덱스 값을 공유하는 \(최대 1개\) 유효한 stateid에 대한 현재 세대 번호입니다.

o 잠금이 수행된 파일의 파일 핸들입니다.

o stateid 유형 표시\(공개, 바이트 범위 잠금, 파일 위임\).

o 현재 "기타" 값에 해당하는 마지막 seqid 값이 반환됩니다.

o 이 stateid와 연관된 잠금의 현재 상태 표시, 특히 이것이 취소되었는지 여부, 그렇다면 그 이유는 무엇입니까?

이 정보를 사용하면 수신 stateid를 검증할 수 있으며 필요한 경우 적절한 오류가 반환됩니다. 특수 및 비특수 상태 ID는 별도로 처리됩니다. \(특수 상태 ID에 대한 논의는 섹션 9.1.4.3을 참조하십시오.\)

stateid가 테스트되고 "other" 필드가 모두 0 또는 모두 1인 경우 "other" 및 seqid 필드가 특수 stateid에 대해 정의된 조합과 일치하는지 확인하고 결과는 다음과 같이 결정됩니다.

o "other" 및 seqid 필드가 특수 stateid와 연관된 정의된 조합과 일치하지 않는 경우 NFS4ERR\_BAD\_STATEID 오류가 반환됩니다.

o 조합이 일반적으로 유효하지만 stateid가 사용되는 컨텍스트에 적합하지 않은 경우\(예: LOCK 작업에서 open stateid가 필요할 때 모두 0인 stateid가 사용되는 경우\) NFS4ERR\_BAD\_STATEID 오류도 반환됩니다.

o 그렇지 않으면 검사가 완료되고 특수 stateid가 유효한 것으로 승인됩니다.

stateid가 테스트 중이고 "other" 필드가 모두 0도 아니고 모두 1도 아닌 경우 다음 절차를 사용하여 들어오는 stateid를 검증하고 필요한 경우 "other" 필드가 다음과 같다고 가정하여 적절한 오류를 반환할 수 있습니다. 테이블 인덱스와 엔트리 생성으로 나누어집니다. 서열번호 비교와 관련하여 사용된 용어 "이전" 및 "이후"는 섹션 9.1.3에 설명된 대로 이해되어야 한다는 점에 유의하십시오.

o 테이블 인덱스 필드가 연관된 테이블의 범위를 벗어나면 NFS4ERR\_BAD\_STATEID를 반환합니다.

o 선택한 테이블 항목이 수신 stateid에 지정된 것과 다른 세대인 경우 NFS4ERR\_BAD\_STATEID를 반환합니다.

o 선택한 테이블 항목이 현재 파일 핸들과 일치하지 않으면 NFS4ERR\_BAD\_STATEID를 반환합니다.

o stateid가 임대 만료로 인해 취소된 상태 또는 손실된 상태를 나타내는 경우 NFS4ERR\_EXPIRED, NFS4ERR\_BAD\_STATEID 또는 NFS4ERR\_ADMIN\_REVOKED를 적절하게 반환합니다.

o stateid 유형이 stateid가 나타나는 컨텍스트에 대해 유효하지 않은 경우 NFS4ERR\_BAD\_STATEID를 반환합니다. stateid는 일반적으로 유효할 수 있지만 특정 작업에서는 유효하지 않을 수 있습니다. 예를 들어 바이트 범위 잠금을 나타내지 않는 stateid가 LOCK의 non-from\_open 케이스나 LOCKU로 전달되거나 열기를 나타내지 않는 stateid는 CLOSE 또는 OPEN\_DOWNGRADE로 전달됩니다. 이러한 경우 서버는 NFS4ERR\_BAD\_STATEID를 반환해야 합니다.\(MUST\)

o seqid 필드가 0이 아니고 현재 "other" 필드에 해당하는 현재 시퀀스 값보다 늦으면 NFS4ERR\_BAD\_STATEID를 반환합니다.

o seqid 필드가 현재 "other" 필드에 해당하는 현재 시퀀스 값보다 이전인 경우 NFS4ERR\_OLD\_STATEID를 반환합니다.

o 그렇지 않은 경우 stateid는 유효하며 테이블 항목에는 stateid 유형에 대한 추가 정보 및 관련 잠금 세트\(예: 개방 소유자 및 잠금 소유자 정보\)와 같은 특정 유형의 stateid와 관련된 정보가 포함되어야 합니다. \)뿐만 아니라 개방 모드 및 바이트 범위와 같은 특정 잠금 자체에 대한 정보도 포함됩니다.

---
##### **9.1.4.5.  Stateid Use for I/O Operations**

I/O\(입/출력\) 작업을 수행하는 클라이언트는 클라이언트가 보유한 잠금\(열기 및 위임 포함\)과 I/O 요청을 보내는 다양한 유형의 상태 소유자를 기반으로 적절한 상태 ID를 선택해야 합니다. 이 점에서 파일 크기를 변경하는 SETATTR 작업은 I/O 작업처럼 처리됩니다.

우선순위가 낮은 순서대로 적용되는 다음 규칙은 적절한 stateid 선택을 관리합니다. 이러한 규칙을 따르면 클라이언트는 적절한 작업 응답이나 콜백을 통해 실제로 알림을 받은 잠금만 고려합니다.

o 클라이언트가 문제의 파일에 대한 위임을 보유한 경우 위임 상태 ID를 사용해야 합니다.\(SHOULD\)

o 그렇지 않고, I/O를 전송하는 잠금 소유자\(예: 프로세스\)에 해당하는 엔터티가 연관된 열린 파일에 대한 바이트 범위 잠금 상태 ID를 갖는 경우 해당 잠금 소유자 및 열린 파일에 대한 바이트 범위 잠금 상태 ID를 갖습니다. 파일을 사용해야 합니다.\(SHOULD\)

o 바이트 범위 잠금 상태 ID가 없는 경우 현재 열린 소유자에 대한 OPEN 상태 ID, 즉 문제의 열린 파일에 대한 OPEN 상태 ID를 사용해야 합니다.\(SHOULD\)

o 마지막으로, 위의 사항 중 어느 것도 적용되지 않으면 특별한 stateid를 사용해야 합니다.\(SHOULD\)

이러한 규칙을 무시하면 서버에 요청을 적절하게 처리하는 데 필요한 정보가 없는 상황이 발생할 수 있습니다. 예를 들어, 필수 바이트 범위 잠금이 적용될 때 stateid가 잠금 stateid를 통해 적절한 잠금 소유자를 나타내지 않으면 요청이 거부될 수 있습니다.

그러나 서버는 이러한 순서 규칙을 적용하려고 시도해서는 안 되며 I/O 요청을 적절하게 처리하기 위해 사용 가능한 모든 정보를 사용해야 합니다. 특히, 클라이언트가 특정 파일에 대한 위임을 갖고 있는 경우 요청이 특수한 상태 ID와 함께 전송되더라도 요청을 처리할 때 이 사실을 기록해야 합니다.\(SHOULD\)

---
##### **9.1.4.6.  Stateid Use for SETATTR Operations**

SETATTR 작업의 경우 stateid가 존재합니다. 파일 크기를 설정하는 경우가 아닌 경우 클라이언트는 특수한 상태 ID를 보내거나 해당 파일에 대한 위임이 보류된 경우 위임 상태 ID를 보낼 수 있습니다. 서버는 stateid를 검증해야 하며 위임 보유 여부에 대한 결정을 최적화하기 위해 stateid를 사용할 수 있지만 특수 stateid가 전송될 때에도 위임의 존재를 기록해야 하며 전송 시 유효한 위임 stateid를 수락해야 합니다\(MUST\).\(MUST\)

---
#### **9.1.5.  Lock-Owner**

잠금을 요청할 때 클라이언트는 클라이언트 ID와 요청된 잠금 소유자의 식별자를 서버에 제공해야 합니다. 이 두 필드는 잠금 소유자를 구성하며 다음과 같이 정의됩니다.

o 클라이언트의 SETCLIENTID 작업 사용의 일부로 서버에서 반환된 클라이언트 ID.

o 클라이언트가 관리하는 잠금의 소유자를 고유하게 정의하는 데 사용되는 가변 길이 불투명 배열입니다.

- 스레드 ID, 프로세스 ID 또는 기타 고유 값일 수 있습니다.

서버가 잠금을 허용하면 고유한 stateid로 응답합니다. stateid는 서버가 잠금 소유자 간의 통신을 유지하므로 잠금 소유자에 대한 간략한 참조로 사용됩니다.

---
#### **9.1.6.  Use of the Stateid and Locking**

모든 READ, WRITE 및 SETATTR 작업에는 stateid가 포함됩니다. 이 섹션의 목적에 따라 파일의 크기 속성을 변경하는 SETATTR 작업은 이전 크기와 새 크기 사이의 영역\(예: SETATTR을 통해 잘리거나 파일에 추가된 범위\)을 쓰는 것처럼 처리됩니다. SETATTR이 텍스트에 명시적으로 언급되지 않은 경우에도 마찬가지입니다. 이러한 작업 중 하나에 전달된 상태 ID는 OPEN\(예: 공개 소유자를 통해\), 바이트 범위 잠금 세트 또는 위임을 나타내는 것이어야 하며, 익명 액세스 또는 READ를 나타내는 특수 상태 ID일 수도 있습니다. 상태 ID를 우회합니다.

상태 소유자가 서버에 잠금 또는 공유 예약을 설정한 상황에서 READ 또는 WRITE를 수행하는 경우\(모든 OPEN은 공유 예약을 구성함\) stateid\(이전에 서버에서 반환한\)를 사용하여 무엇을 표시해야 합니다. 바이트 범위 잠금 및 공유 예약을 포함한 잠금은 상태 소유자가 보유합니다. 클라이언트가 상태를 설정하지 않은 경우 -

바이트 범위 잠금 또는 공유 예약 - 익명의 stateid가 사용됩니다. 익명의 stateid 또는 서버에서 반환된 stateid가 사용되는지 여부에 관계없이 충돌하는 공유 예약 또는 파일에 대한 필수 바이트 범위 잠금이 있는 경우 서버는 READ 또는 WRITE 작업 서비스를 거부해야 합니다.\(MUST\)

공유 예약은 OPEN 작업에 의해 설정되며 OPEN이 READ 또는 WRITE 작업을 거부하면 해당 작업이 NFS4ERR\_LOCKED 오류와 함께 거부된다는 점에서 본질적으로 필수입니다. 바이트 범위 잠금은 서버에 의해 필수 또는 권고로 구현될 수 있으며, 필수 또는 권고 동작의 선택은 액세스되는 파일을 기반으로 서버에 의해 결정될 수 있습니다\(예를 들어 일부 UNIX 기반 서버는 " 모드 속성에 필수 잠금 비트"가 설정되어 있으면 I/O가 가능하기 전에 파일에 바이트 범위 잠금이 필요합니다. 바이트 범위 잠금이 권장되는 경우 충돌하는 잠금 요청의 승인만 방지하고 읽기 또는 쓰기에는 영향을 미치지 않습니다. 그러나 필수 바이트 범위 잠금은 I/O 작업 충돌을 방지합니다. 시도되면 NFS4ERR\_LOCKED로 거부됩니다. 클라이언트가 적절한 공유 예약이 있음을 알고 있는 파일에서 NFS4ERR\_LOCKED를 받으면 적절한 잠금 유형을 사용하여 I/O가 수행될 영역을 포함하는 파일 영역에 LOCK 요청을 발행해야 합니다. \(즉, READ 작업의 경우 READ\*\_LT, WRITE 작업의 경우 WRITE\*\_LT\).

NFSv3에는 stateid 개념이 없었기 때문에 READ 또는 WRITE 작업을 보내는 클라이언트의 애플리케이션 프로세스가 파일에 대한 적절한 바이트 범위 잠금도 획득했는지 알 수 있는 방법이 없었습니다. 따라서 강제 잠금을 구현할 방법이 없었습니다. stateid 구조를 사용하면 이 장벽이 제거되었습니다.

필수 파일 잠금을 지원하는 UNIX 환경의 경우 권고 잠금과 필수 잠금 간의 차이가 미묘합니다. 실제로 권고 및 필수 바이트 범위 잠금은 API 및 구현 요구 사항에 관한 한 정확히 동일합니다. 파일에 필수 잠금 속성이 설정된 경우 서버는 잠금 소유자가 읽거나 쓰려는 영역에 대해 적절한 공유\(읽기\) 또는 배타적\(쓰기\) 바이트 범위 잠금을 가지고 있는지 확인합니다. 적절한 잠금이 없으면 서버는 충돌하는 잠금이 있는지 확인합니다. 이는 잠금 소유자를 대신하여 충돌하는 잠금을 획득하려고 시도하여 수행할 수 있으며, 성공하면 읽기 또는 쓰기가 완료된 후 잠금을 해제합니다. \), 존재하는 경우 서버는 NFS4ERR\_LOCKED를 반환합니다.

Windows 환경의 경우 권장 바이트 범위 잠금이 없으므로 서버는 I/O 요청 중에 항상 바이트 범위 잠금을 확인합니다.

따라서 NFSv4 LOCK 작업에서는 권고 및 필수 바이트 범위 잠금을 구별할 필요가 없습니다. 구별을 가져오는 것은 NFSv4 서버의 READ 및 WRITE 작업 처리입니다.

OPEN 유형 작업\(예: OPEN, OPEN\_DOWNGRADE\) 또는 LOCK 유형 작업\(예: LOCK 또는 LOCKU\)에 의해 반환되는지 여부에 관계없이 이 섹션에 언급된 특수 stateid 값 이외의 모든 stateid는 파일에 대한 액세스 모드를 정의합니다. \(예: READ, WRITE 또는 READ-WRITE\) stateid 시퀀스를 시작한 원래 OPEN에 의해 ​​설정되고 해당 stateid 시퀀스 내의 후속 OPEN 및 OPEN\_DOWNGRADE에 의해 수정됩니다. 크기 속성을 지정하는 READ, WRITE 또는 SETATTR이 완료되면 해당 작업은 해당 작업과 연관된 OPEN이 지정된 경우 해당 작업이 적절한지 확인하기 위해 액세스 모드를 검사해야 합니다.

WRITE 유형 작업\(예: 크기를 설정하는 WRITE 및 SETATTR\)의 경우 서버는 액세스 모드가 쓰기를 허용하는지 확인하고 그렇지 않은 경우 NFS4ERR\_OPENMODE 오류를 반환해야 합니다. READ의 경우, 서버는 액세스 모드에서 해당 검사를 수행하거나 쓰기 구현이 불가피하게 읽기를 수행할 수 있는 클라이언트를 수용하기 위해 쓰기에 대해서만 열 때 READ를 허용하도록 선택할 수 있습니다\(예: 버퍼 캐시 제약 조건으로 인해\). . 그러나 이러한 상황에서 READ가 허용되더라도 서버는 READ와 충돌하는 잠금\(예: READ 거부를 지정하는 또 다른 열기\)을 계속 확인해야 합니다. 읽기 액세스에 대한 OPEN이 있으면 충돌하는 공유 예약이 존재할 수 없음을 보장하므로 READ에 대한 액세스 모드 확인을 시행하는 서버는 충돌하는 공유 예약을 명시적으로 확인할 필요가 없습니다.\(MUST\)

READ 우회 상태 ID는 READ 작업이 서버의 잠금 검사를 우회하도록 허용할 수 있습니다. 그러나 READ 우회 stateid를 사용한 WRITE 작업은 잠금 검사를 우회해서는 안 되며 익명의 stateid가 사용된 것과 정확히 동일하게 처리됩니다.\(MAY, MUST NOT\)

특수 상태 ID 중 하나를 사용하는 READ 또는 WRITE 작업이 수행되고 잠금 요청 범위가 READ 또는 WRITE 작업 범위와 충돌하는 동안 잠금이 부여되지 않을 수 있습니다. 이 단락의 목적에 따라 공유 잠금이 요청되고 WRITE 작업이 수행되는 경우 또는 배타적 잠금이 요청되고 READ 또는 WRITE 작업이 수행되는 경우 충돌이 발생합니다. 크기를 설정하는 SETATTR은 위에서 설명한 WRITE와 유사하게 처리됩니다.

---
#### **9.1.7.  Sequencing of Lock Requests**

잠금에는 ONC RPC에서 제공하지 않는 "최대 1개" 의미 체계가 필요하므로 대부분의 NFS 작업과 다릅니다. 일련의 잠금 요청이 여러 TCP 연결에 걸쳐 있을 수 있으므로 안정적인 전송을 통한 ONC RPC는 충분하지 않습니다. 재전송 또는 재정렬 시 잠금 또는 잠금 해제 요청은 잘 정의되고 일관된 동작을 가져야 합니다. 이를 달성하기 위해 각 잠금 요청에는 연속적으로 증가하는 정수인 시퀀스 번호가 포함됩니다. 다른 주 소유자는 다른 순서를 가지고 있습니다. 서버는 수신된 마지막 시퀀스 번호\(L\)와 반환된 응답을 유지합니다. 서버는 특정 상태 소유자에 대해 발행된 첫 번째 요청에 대해 seqid 값 1을 할당해야 합니다. 후속 값은 섹션 9.1.3에 설명된 대로 랩어라운드를 거쳐 seqid 값을 증가시켜 도달됩니다.\(SHOULD\)

순서 번호가 포함된 요청의 경우 각 상태 소유자에 대해 미해결 요청이 1개 이상 있어서는 안 됩니다.

요청이 수신되면 해당 시퀀스 번호\(r\)가 마지막으로 수신된 요청의 시퀀스 번호\(L\)와 비교됩니다. 올바른 다음 시퀀스\(일반적으로 L + 1\)가 있는 경우에만 seqid 확인 지점을 넘어 요청이 처리됩니다. 클라이언트가 올바르게 작동하는 경우 마지막 요청\(L\)이 전송되기 전에 \(r\)에 대한 응답이 수신되어야 합니다. 마지막 요청의 중복\(r == L\)이 수신되면 저장된 응답이 반환됩니다. 수신된 시퀀스 값이 다른 값인 경우 NFS4ERR\_BAD\_SEQID 오류 반환과 함께 거부됩니다. SETCLIENTID/SETCLIENTID\_CONFIRM 시퀀스가 ​​클라이언트 검증자를 변경할 때마다 시퀀스 기록이 다시 초기화됩니다.

\[Chet\]에 설명된 기존 캐시보다 중복된 비멱등성 요청에 대한 보다 안정적인 캐시를 제공하기 위해 서버가 클라이언트에 전송된 마지막 응답을 유지하는 것이 중요합니다. 기존 중복 요청 캐시는 불필요한 요청을 제거하기 위해 가장 최근에 사용된 알고리즘을 사용합니다. 그러나 지정된 상태 소유자에 대한 마지막 잠금 요청 및 응답은 서버에 잠금 상태가 존재하는 한 캐시되어야 합니다.

클라이언트는 CLOSE, LOCK, LOCKU, OPEN, OPEN\_CONFIRM 및 OPEN\_DOWNGRADE 작업에 대한 시퀀스 번호를 앞당겨야 합니다. 이는 해당 시퀀스 번호를 사용한 이전 작업에서 오류가 발생한 경우에도 마찬가지입니다. 이 규칙의 유일한 예외는 이전 작업에서 NFS4ERR\_STALE\_CLIENTID, NFS4ERR\_STALE\_STATEID, NFS4ERR\_BAD\_STATEID, NFS4ERR\_BAD\_SEQID, NFS4ERR\_BADXDR, NFS4ERR\_RESOURCE, NFS4ERR\_NOFILEHANDLE 또는 NFS4ERR\_MOVED 오류 중 하나를 받은 경우입니다.\(MUST\)

---
#### **9.1.8.  Recovery from Replayed Requests**

위에서 설명한 대로 일련 번호는 주 소유자별로 지정됩니다. 서버가 수신된 마지막 시퀀스 번호를 유지하고 위에서 설명한 방법을 따르는 한, 비잔틴 라우터가 오래된 요청을 다시 보낼 위험은 없습니다. 서버는 열려 있는 파일이나 잠금이 해제된 닫힌 파일이 있는 한 \(상태 소유자, 시퀀스 번호\) 상태만 유지하면 됩니다.

LOCK, LOCKU, OPEN, OPEN\_DOWNGRADE 및 CLOSE에는 각각 시퀀스 번호가 포함되어 있으므로 서버가 상태 소유자 상태를 유지하는 동안에는 이러한 작업이 재생되어 원하지 않는 결과를 초래할 위험이 존재하지 않습니다.

---
#### **9.1.9.  Interactions of Multiple Sequence Values**

일부 작업에는 요청 순서 확인 및 재전송 결정을 위한 여러 데이터 소스가 있을 수 있습니다. 일부 작업에는 여러 유형의 상태 소유자와 연결된 여러 시퀀스 값이 있습니다. 또한 이러한 작업에는 자체 seqid 값이 있는 stateid가 있을 수도 있으며 유효성이 검사됩니다.

위에서 언급한 것처럼 확인할 시퀀스 값이 여러 개 있을 수 있습니다. 서버는 단일 작업 내에서 이러한 여러 시퀀스 값을 처리할 때 다음 규칙을 따라야 합니다.

o 상태 소유자가 서버에 알려지지 않았기 때문에 상태 소유자와 연관된 시퀀스 값을 확인할 수 없는 경우 비교에 참여하지 않습니다.

o 상태 소유자 시퀀스 값 중 하나라도 유효하지 않은 경우

- NFS4ERR\_BAD\_SEQID가 반환됩니다. stateid 시퀀스를 확인하면 NFS4ERR\_BAD\_STATEID 또는 NFS4ERR\_OLD\_STATEID가 적절하게 반환되지만 NFS4ERR\_BAD\_SEQID가 우선 순위를 가집니다.

o 시퀀스 값 중 하나라도 이전 요청과 일치하면 상태 소유자의 경우 재전송으로 간주되어 재실행되지 않습니다. 작업 유형이 원래 사용된 유형과 일치하지 않으면 NFS4ERR\_BAD\_SEQID가 반환됩니다. 서버가 요청이 원본과 다르다고 판단하면 NFS4ERR\_BAD\_SEQID를 반환할 수 있습니다.

o 여러 시퀀스 값이 이전 작업과 일치하지만 작업이 동일하지 않은 경우 NFS4ERR\_BAD\_SEQID가 반환됩니다.

o 비교에 사용할 수 있는 시퀀스 값이 없고 작업이 OPEN인 경우 서버는 확인이 필요하지 않다고 결론적으로 결정할 수 없는 한\(예: 소유자 공개 상태가 없음을 인식함으로써\) OPEN\_CONFIRM이 필요함을 클라이언트에 나타냅니다. 현재 클라이언트 ID에 대해 릴리스된 적이 있습니다\).

---
#### **9.1.10.  Releasing State-Owner State**

특정 상태 소유자가 더 이상 서버에서 열린 상태 또는 파일 잠금 상태를 유지하지 않으면 서버는 상태 소유자와 관련된 시퀀스 번호 상태를 해제하도록 선택할 수 있습니다. 서버는 임대 만료, 서버 메모리 회수 또는 기타 구현 관련 세부 사항을 기반으로 이 선택을 할 수 있습니다. 이 작업이 완료되면 일반적으로 일치하는 상태 소유자 시퀀스로 식별되는 재전송된 요청이 올바르게 인식되지 않을 수 있으므로 클라이언트는 상태 소유자 상태가 해제되지 않은 경우 가질 수 있는 원래 응답을 받지 못할 수 있습니다. .

서버가 특정 상태 소유자가 클라이언트에 의해 다시는 사용되지 않을 것이라고 확신할 수 있다면 그러한 문제는 발생할 수 없습니다. 상태 소유자 상태가 해제되고 클라이언트가 이후에 해당 상태 소유자를 사용하는 경우에도 클라이언트가 단순히 원래 응답을 얻는 것보다 더 복잡한 복구 경로를 가질 수 있더라도 재전송된 요청은 유효하지 않은 것으로 감지되고 요청이 실행되지 않습니다. 투명하게 돌아왔습니다.

어떤 경우에도 서버는 상태 소유자가 현재 클라이언트에 의해 활용되고 있지 않을 때\(즉, 열려 있는 파일이 없을 때\) 상태 소유자 상태를 안전하게 해제할 수 있습니다\(재전송된 요청이 잘못 처리되지 않는다는 점에서\). 개방형 소유자와 연결되어 있고 잠금 소유자와 연결된 잠금 상태 ID는 없습니다. 서버는 현재 활성 요청의 재전송이 수신되는 경우 복구 경로를 단순화하기 위해 상태 소유자 상태를 유지하도록 선택할 수 있습니다. 그러나 이 상태를 유지하기로 선택한 기간은 구현에 따라 다릅니다.

서버가 이전에 상태 소유자 상태를 해제한 후 LOCK, LOCKU, OPEN\_DOWNGRADE 또는 CLOSE가 재전송되는 경우 서버는 상태 소유자에게 열린 파일이 없음을 발견하고 클라이언트에 오류가 반환됩니다. 상태 소유자가 파일을 열어 둔 경우 상태 ID는 일치하지 않으며 클라이언트에 다시 오류가 반환됩니다.

---
#### **9.1.11.  Use of Open Confirmation**

OPEN이 재전송되고 오픈 소유자가 처음으로 사용 중이거나 서버에서 이전에 오픈 소유자 상태를 해제한 경우 OPEN\_CONFIRM 작업을 사용하면 잘못된 동작을 방지할 수 있습니다. 서버가 처음으로 오픈 소유자의 사용을 관찰하면 해당 OPEN에 대해 OPEN\_CONFIRM을 수행하도록 클라이언트에 지시합니다. 이 시퀀스는 공개 소유자 및 관련 시퀀스 번호의 사용을 설정합니다. OPEN\_CONFIRM 시퀀스는 서버의 새로운 오픈 소유자를 클라이언트의 기존 오픈 소유자와 연결하므로 시퀀스 번호는 유효한\(즉, 0이 아닌\) 값을 가질 수 있습니다. OPEN\_CONFIRM 단계는 수신된 값이 올바른지 서버에 확인합니다. \(자세한 내용은 섹션 16.18을 참조하세요.\)

OPEN을 확인하라는 요구 사항이 클라이언트와 서버에 어려움을 초래할 수 있는 상황이 많이 있습니다. 즉, 수신된 정보에 대해 적시에 조치를 취하지 못하게 될 수 있습니다. 왜냐하면 해당 정보는 잠정적이며 즉시 삭제될 수 있기 때문입니다. 비확인. 다행스럽게도 이러한 상황에서는 서버가 열기 요청에 응답할 때 확인이 필요하지 않습니다. 두 가지 제약 조건은 다음과 같습니다.

o 서버는 확인이 필요한 공개에 대해 위임을 부여해서는 안 됩니다.

o 서버는 회수 유형 열기\(즉, CLAIM\_PREVIOUS 또는 CLAIM\_DELEGATE\_PREV 클레임 유형을 지정하는 열기\)에 대한 확인을 요구해서는 안 됩니다.\(MUST NOT\)

이러한 제약 조건은 서버가 위임을 보내야 할 수 있는 유일한 재개 유형 열기와 관련되어 있습니다. CLAIM\_NULL의 경우 위임 전송은 선택 사항이지만 CLAIM\_DELEGATE\_CUR의 경우 위임이 전송되지 않습니다.

확인이 필요한 공개와 함께 전송되는 위임은 비확인에서 복구하면 프로토콜에 과도한 복잡성이 추가되고, 회수 유형 공개에 대한 확인을 요구하면 임대 만료까지 회수 상태를 해결할 수 없기 때문에 문제가 발생합니다. 회수되는 잠금 세트를 적시에 결정하기가 어렵습니다\(유예 기간이 만료될 수 있으므로\).

회수 유형 열기에 대한 열기 확인을 요구하는 것은 그러한 열기가 수행되는 환경의 특성으로 인해 피할 수 있습니다. CLAIM\_PREVIOUS 열기의 경우 이는 서버 재부팅 직후이므로 열기 소유자가 생성되고 사용되지 않은 것으로 확인되어 재활용될 시간이 없어야 합니다. CLAIM\_DELEGATE\_PREV가 열리면,

우리는 클라이언트 재부팅 상황이나 네트워크 파티션으로 인해 임대 상태가 삭제되고 NFS4ERR\_EXPIRED가 반환되는 상황을 처리하고 있습니다. 위임을 지원하는 서버는 클라이언트 초기화 또는 임대 상태 삭제 이후 해당 클라이언트에 대한 공개 소유자가 재활용되지 않았음을 확신할 수 있으므로 확인이 필요하지 않다고 확신할 수 있습니다.

---
### **9.2.  Lock Ranges**

이 프로토콜을 사용하면 잠금 소유자가 바이트 범위의 잠금을 요청한 다음 초기 잠금의 하위 범위를 업그레이드하거나 잠금 해제할 수 있습니다. 이는 흔하지 않은 유형의 요청이 될 것으로 예상됩니다. 어떤 경우에도 서버 또는 서버 파일 시스템은 하위 범위 잠금 의미를 지원하지 못할 수 있습니다. 서버가 잠금 소유자에 대한 현재 잠금 상태의 하위 범위를 나타내는 잠금 요청을 수신하는 경우 서버는 하위 범위 잠금 작업을 지원하지 않음을 나타내기 위해 NFS4ERR\_LOCK\_RANGE 오류를 반환할 수 있습니다. 따라서 클라이언트는 이 오류를 받을 준비가 되어 있어야 하며, 적절한 경우 요청 응용 프로그램에 오류를 보고해야 합니다.

서버가 하위 범위 요청을 지원하지 않을 수 있고 서버 오류 시 파일 잠금 상태 복구와 관련된 이유로 인해 클라이언트는 단일 요청에 인접해 있는 여러 개의 독립적인 잠금 범위를 결합하는 것을 권장하지 않습니다. 아래 섹션 9.6.2에서 설명한 대로 서버는 잠금 복구 중 클라이언트의 동작이 서버 오류 이전 클라이언트의 잠금 동작과 유사한 경우에만 효과적으로 작동하는 복구 중 특정 최적화를 사용할 수 있습니다.

---
### **9.3.  Upgrading and Downgrading Locks**

클라이언트가 레코드에 쓰기 잠금을 설정한 경우 유형을 READ\_LT로 설정하여 LOCK 요청을 통해 잠금을 읽기 잠금으로 원자적으로 다운그레이드하도록 요청할 수 있습니다. 서버가 원자성 다운그레이드를 지원하면 요청이 성공합니다. 그렇지 않은 경우 NFS4ERR\_LOCK\_NOTSUPP를 반환합니다. 클라이언트는 이 오류를 받을 준비가 되어 있어야 하며, 적절한 경우 요청 응용 프로그램에 오류를 보고해야 합니다.

클라이언트가 레코드에 대해 읽기 잠금을 설정한 경우 유형을 WRITE\_LT 또는 WRITEW\_LT로 설정하여 LOCK 요청을 통해 잠금을 쓰기 잠금으로 원자적으로 업그레이드하도록 요청할 수 있습니다. 서버가 원자성 업그레이드를 지원하지 않으면 NFS4ERR\_LOCK\_NOTSUPP를 반환합니다. 기존 충돌 없이 업그레이드를 수행할 수 있으면 요청이 성공합니다. 그렇지 않으면 서버는 NFS4ERR\_DENIED 또는 NFS4ERR\_DEADLOCK을 반환합니다. 클라이언트가 WRITEW\_LT로 설정된 유형으로 LOCK 요청을 발행한 경우 NFS4ERR\_DEADLOCK 오류가 반환됩니다.

서버가 교착 상태를 감지했습니다. 클라이언트는 이러한 오류를 수신할 준비가 되어 있어야 하며, 적절한 경우 이를 요청 애플리케이션에 보고해야 합니다.

---
### **9.4.  Blocking Locks**

일부 클라이언트에는 차단 잠금 지원이 필요합니다. NFSv4 프로토콜은 콜백 메커니즘에 의존해서는 안 되므로 이전에 거부된 잠금이 부여된 경우 클라이언트에 알릴 수 없습니다. 클라이언트는 계속해서 잠금을 폴링하는 것 외에는 선택의 여지가 없습니다. 이는 공정성 문제를 야기합니다. 두 가지 새로운 잠금 유형인 READW 및 WRITEW가 추가되었으며 이는 클라이언트가 차단 잠금을 요청하고 있음을 서버에 나타내는 데 사용됩니다. 서버는 보류 중인 차단 잠금의 정렬된 목록을 유지해야 합니다. 충돌하는 잠금이 해제되면 서버는 첫 번째 대기 클라이언트가 잠금을 다시 요청할 때까지 임대 기간을 기다릴 수 있습니다. 임대 기간이 만료된 후 다음 대기 클라이언트 요청에 잠금이 허용됩니다. 클라이언트는 적시에 잠금을 획득할 수 있도록 충분히 작은 간격으로 폴링해야 합니다. 서버는 보류 중인 차단 잠금 목록을 유지할 필요가 없습니다. 이는 올바른 작업을 제공하는 데 사용되지 않고 공정성을 높이는 데만 사용되기 때문입니다. 크래시 복구의 순서가 지정되지 않은 특성으로 인해 잠금 상태를 안정적인 저장소에 저장해야 차단 잠금의 순서가 부여되는 것을 보장할 수 있습니다.

또한 서버는 잠금 유형을 기록하고 요청 거부 반환을 지연하여 충돌하는 잠금이 해제될 때까지 추가 시간을 허용하여 성공적인 반환을 허용할 수 있습니다. 이러한 방식으로 클라이언트는 잠금 차단을 위해 불필요하게 자주 폴링하는 부담을 피할 수 있습니다. 서버는 클라이언트가 요청을 재전송하는 경우 지연 시간에 주의해야 합니다.

서버가 차단 잠금 요청을 수신하고 이를 거부한 다음 나중에 동일한 잠금에 대한 비차단 요청을 수신하고 이 요청도 거부된 경우 보류 중인 차단 잠금 목록에서 문제의 잠금을 제거해야 합니다. 클라이언트는 이러한 비차단 요청을 사용하여 잠금을 요청하는 프로세스가 중단될 때 발생할 수 있는 것처럼 이번이 잠금을 폴링하려는 마지막 시간임을 서버에 나타내야 합니다. 이는 다른 잠금 요청을 승인하기 전에 임대 기간을 불필요하게 기다리는 것을 방지하기 위한 서버에 대한 배려입니다. 그러나 클라이언트는 이러한 예의를 이행할 필요가 없으며 서버는 클라이언트의 그렇게 하는 것에 의존해서는 안 됩니다. 또한 클라이언트는 이 최종 잠금 요청이 수락될 가능성에 대비해야 합니다.

---
### **9.5.  Lease Renewal**

임대의 목적은 충돌했거나 연결할 수 없는 클라이언트가 보유하고 있는 오래된 잠금을 서버가 제거할 수 있도록 하는 것입니다. 이는 캐시 일관성을 위한 메커니즘이 아니며 임대 간격이 만료되지 않은 경우 임대 갱신이 거부되지 않을 수 있습니다.

클라이언트는 자신이 여전히 활성 상태이고 서버에 있는 관련 상태가 클라이언트에 대해 여전히 유효하다는 긍정적인 표시를 암시적으로 제공할 수 있습니다. 유효한 클라이언트 ID\(DELEGPURGE, LOCK, LOCKT, OPEN, RELEASE\_LOCKOWNER 또는 RENEW\) 또는 유효한 상태 ID\(CLOSE, DELEGRETURN, LOCK, LOCKU, OPEN, OPEN\_CONFIRM, OPEN\_DOWNGRADE, READ, SETATTR 또는 WRITE\)를 사용하여 수행된 모든 작업은 서버에 알립니다. 해당 클라이언트에 대한 모든 임대\(즉, 특정 클라이언트 ID를 공유하는 모든 임대\)를 갱신합니다. 후자의 경우 stateid는 특수 stateid\(익명 stateid 또는 READ 우회 stateid\) 중 하나가 아니어야 합니다.

클라이언트가 다시 시작되거나 재부팅된 경우 클라이언트는 SETCLIENTID/SETCLIENTID\_CONFIRM 시퀀스를 실행하지 않으면 이러한 요청을 수행하지 않습니다. SETCLIENTID/SETCLIENTID\_CONFIRM 시퀀스\(클라이언트 검증자를 변경하는 시퀀스\)를 사용하면 클라이언트와 관련된 잠금 상태를 삭제하도록 서버에 알립니다. SETCLIENTID/SETCLIENTID\_CONFIRM은 임대를 갱신하지 않습니다.

서버가 재부팅된 경우 상태 ID\(NFS4ERR\_STALE\_STATEID 오류\) 또는 클라이언트 ID\(NFS4ERR\_STALE\_CLIENTID 오류\)가 유효하지 않으므로 허위 갱신을 방지할 수 있습니다.

이 접근 방식을 사용하면 오버헤드가 낮은 임대 갱신이 가능하며 확장성이 뛰어납니다. 일반적인 경우에는 임대 갱신을 위해 추가 RPC가 필요하지 않으며, 최악의 경우에는 임대 기간\(즉, RENEW 작업\)마다 하나의 RPC가 필요합니다. 클라이언트의 모든 상태가 임대 갱신 작업과 관련되어 있으므로 클라이언트가 보유한 잠금 수는 요인이 아닙니다.

새 임대를 생성하는 모든 작업은 기존 임대도 갱신하므로 서버는 지정된 클라이언트에 대한 모든 유효한 임대에 대해 공통 임대 만료 시간을 유지해야 합니다. 이 임대 시간은 암시적 임대 갱신 작업 시 쉽게 업데이트될 수 있습니다.

---
### **9.6.  Crash Recovery**

충돌 복구의 중요한 요구 사항은 클라이언트와 서버 모두 상대방이 언제 실패했는지 알 수 있어야 한다는 것입니다. 또한 클라이언트는 서버가 다시 시작되거나 재부팅되는 동안 일관된 데이터 보기를 볼 수 있어야 합니다. 클라이언트 또는 네트워크 버퍼 내에서 대기열에 있을 수 있는 모든 읽기 및 쓰기 작업은 클라이언트가 읽기 및 쓰기 작업을 보호하는 잠금을 성공적으로 복구할 때까지 기다려야 합니다.

---
#### **9.6.1.  Client Failure and Recovery**

클라이언트에 오류가 발생하는 경우 관련 임대가 만료되면 서버는 클라이언트의 잠금을 복구할 수 있습니다. 다른 클라이언트의 잠금 충돌은 이 임대 만료 후에만 부여될 수 있습니다. 클라이언트가 임대 기간 내에 다시 시작하거나 다시 초기화할 수 있는 경우 클라이언트는 새 잠금을 얻기 전에 남은 임대 기간 동안 기다려야 할 수 있습니다.

다시 시작할 때 클라이언트 지연을 최소화하기 위해 열기 및 잠금 요청은 클라이언트 제공 검증자에 의해 클라이언트 인스턴스와 연결됩니다. 이 검증자는 클라이언트가 수행한 초기 SETCLIENTID 호출의 일부입니다. 서버는 SETCLIENTID 작업의 결과로 클라이언트 ID를 반환합니다. 그런 다음 클라이언트는 SETCLIENTID\_CONFIRM을 사용하여 클라이언트 ID의 사용을 확인합니다. 클라이언트는 불투명 소유자 필드와 결합된 클라이언트 ID를 사용하여 OPEN에 대한 공개 소유자를 식별합니다. 그런 다음 이 연관 체인은 특정 클라이언트에 대한 모든 잠금을 식별하는 데 사용됩니다.

검증자는 초기화할 때마다 클라이언트에 의해 변경되므로 서버는 새 검증자를 현재 보유된 잠금과 관련된 검증자와 비교하여 일치하지 않는지 결정할 수 있습니다. 이는 클라이언트의 새로운 인스턴스화 및 그에 따른 잠금 상태 손실을 나타냅니다. 결과적으로 서버는 이전 검증자에서 파생된 이전 클라이언트 ID와 연관된 모든 잠금을 자유롭게 해제할 수 있습니다.

검증자는 COMMIT 작업에 대해 검증자와 동일한 고유성 속성을 가지고 있어야 합니다.

---
#### **9.6.2.  Server Failure and Recovery**

서버가 잠금 상태를 잃으면\(일반적으로 다시 시작 또는 재부팅의 결과로\) 클라이언트가 이 사실을 발견하고 손실된 잠금 상태를 다시 설정할 시간을 허용해야 합니다. 서버가 다른 클라이언트에 충돌하는 액세스 권한을 부여했기 때문에 서버가 유효한 요청을 거부하지 않고도 클라이언트는 잠금 상태를 다시 설정할 수 있어야 합니다. 마찬가지로 고객이 다음과 같은 가능성이 있는 경우

아직 파일에 대한 잠금 상태를 재설정하지 않은 경우 서버는 해당 파일에 대한 읽기 및 쓰기 작업을 허용하지 않아야 합니다. 이 복구 기간은 임대 기간과 동일합니다.

클라이언트는 두 가지 오류 중 하나를 수신하면 서버 오류\(따라서 잠금 상태 손실\)가 발생했음을 확인할 수 있습니다. NFS4ERR\_STALE\_STATEID 오류는 재부팅 또는 재시작으로 인해 무효화된 상태 ID를 나타냅니다. NFS4ERR\_STALE\_CLIENTID 오류는 재부팅 또는 다시 시작으로 인해 클라이언트 ID가 무효화되었음을 나타냅니다. 이들 중 하나가 수신되면 클라이언트는 새로운 클라이언트 ID\(섹션 9.1.1 참조\)를 설정하고 아래 설명된 대로 잠금 상태를 다시 설정해야 합니다.

임대 기간과 동일한 잠금, 읽기 및 쓰기의 특별 처리 기간을 "유예 기간"이라고 합니다. 유예 기간 동안 클라이언트는 회수 유형 잠금 요청\(즉, 회수가 TRUE로 설정된 LOCK 요청 및 CLAIM\_PREVIOUS 또는 CLAIM\_DELEGATE\_PREV 클레임 유형을 사용하는 OPEN 작업\)을 통해 잠금 및 관련 상태를 복구합니다. 유예 기간 동안 서버는 NFS4ERR\_GRACE 오류와 함께 READ 및 WRITE 작업과 비재확보 잠금 요청\(예: 기타 LOCK 및 OPEN 작업\)을 거부해야 합니다.

비재확보 요청 승인이 다른 클라이언트의 잠금 재확보와 충돌하지 않는다는 것을 서버가 확실하게 결정할 수 있는 경우 NFS4ERR\_GRACE 오류가 반환될 필요가 없으며 비재확보 클라이언트 요청을 처리할 수 있습니다. 서버가 유예 기간 동안 읽기 및 쓰기 작업을 서비스할 수 있으려면 임박한 회수 잠금 요청과 읽기 또는 쓰기 작업 간에 충돌이 발생할 수 없음을 다시 보장할 수 있어야 합니다. 서버가 해당 보증을 제공할 수 없는 경우 NFS4ERR\_GRACE 오류가 클라이언트에 반환되어야 합니다.

서버가 유예 기간 동안 간단하고 유효한 처리를 제공하는 가장 쉬운 방법은 NFS4ERR\_GRACE 오류를 반환하여 모든 비재확보 잠금 요청과 READ 및 WRITE 작업을 거부하는 것입니다. 그러나 서버는 부여된 잠금에 대한 정보를 안정적인 저장소에 보관할 수 있습니다. 이 정보를 사용하여 서버는 일반 잠금이나 READ 또는 WRITE 작업을 안전하게 처리할 수 있는지 확인할 수 있습니다.

예를 들어, 특정 파일에 대한 잠금 수를 안정적인 저장소에서 사용할 수 있는 경우 서버는 파일에 대해 회수된 잠금을 추적할 수 있으며 모든 회수가 처리되면 회수되지 않은 잠금 요청이 처리될 수 있습니다. 이런 방식으로 서버는 비재확보 잠금 요청이 잠재적인 재확보 요청과 충돌하지 않도록 보장할 수 있습니다. I/O 요청과 관련하여 서버가 다음을 수행할 수 있는 경우

안정적인 저장소나 다른 유사한 메커니즘의 정보를 통해 파일에 대한 미해결 회수 요청이 없다고 판단하면 해당 파일에 대해 I/O 요청 처리가 정상적으로 진행될 수 있습니다.

다시 말하면, 유예 기간 동안 비재확보 잠금 및 I/O 요청 처리를 허용하는 서버의 경우, 이후에 재확보된 잠금이 거부되지 않고 이후에 재확보된 잠금이 I/O 작업을 방해하지 않았는지 결정해야 합니다. 유예기간 동안 처리됩니다.\(MUST\)

클라이언트는 비재확보 잠금 및 I/O 요청에 대한 NFS4ERR\_GRACE 오류 반환에 대비해야 합니다. 이 경우 클라이언트는 요청에 대한 재시도 메커니즘을 사용해야 합니다. 서버에 부담을 주지 않으려면 재시도 사이에 몇 초 정도의 지연 시간을 두어야 합니다. 일반적인 문제에 대한 추가 논의는 \[Floyd\]에 포함되어 있습니다. 클라이언트는 유예 기간 내에 I/O 및 비재확보 잠금 요청을 수행할 수 있는 서버와 그렇게 할 수 없는 서버를 모두 고려해야 합니다.

서버의 유예 기간 이외의 회수 유형 잠금 요청은 서버가 재부팅 또는 재시작 이후 충돌하는 잠금이나 I/O 요청이 승인되지 않았음을 보장할 수 있는 경우에만 성공할 수 있습니다.

서버는 재시작 시 임대 기간에 대한 새로운 값을 설정할 수 있습니다. 따라서 클라이언트는 새 클라이언트 ID가 설정되면 Lease\_time 속성을 다시 가져와 해당 서버와 관련된 임대에 대한 임대 갱신의 기초로 사용해야 합니다. 그러나 서버는 이 다시 시작 이벤트에 대해 최소한 이전 서버 인스턴스화에 대한 임대 기간만큼 긴 유예 기간을 설정해야 합니다. 이를 통해 이전 서버 인스턴스에서 얻은 클라이언트 상태를 안정적으로 다시 설정할 수 있습니다.

---
#### **9.6.3.  Network Partitions and Recovery**

네트워크 파티션 기간이 서버에서 제공한 임대 기간보다 길면 서버는 클라이언트로부터 임대 갱신을 받지 못한 것입니다. 이런 일이 발생하면 서버는 임대를 취소하고 클라이언트에 대해 보유된 모든 잠금을 해제할 수 있습니다. 결과적으로 클라이언트가 보유한 모든 stateid는 유효하지 않거나 유효하지 않게 됩니다. 클라이언트가 네트워크 분할 후 서버에 도달할 수 있게 되면 클라이언트가 현재 유효하지 않은 상태 ID로 제출한 모든 I/O는 실패하고 서버는 NFS4ERR\_EXPIRED 오류를 반환합니다. 이 오류가 수신되면 클라이언트는 잠금을 보유한 응용 프로그램에 적절하게 알립니다.

---
##### **9.6.3.1.  Courtesy Locks**

클라이언트에 대한 배려 또는 최적화의 일환으로 서버는 최근 통신이 임대 기간을 초과하여 임대 취소를 지연시키는 클라이언트를 대신하여 위임을 포함하여 잠금을 계속 보유할 수 있습니다. 서버가 이러한 무료 잠금 중 하나와 충돌하는 잠금 또는 I/O 요청을 수신하거나 리소스가 부족한 경우 서버는 해당 시점에 임대 취소가 발생하도록 할 수 있으며 이후로 관련 상태 ID 중 하나가 있을 때 NFS4ERR\_EXPIRED를 반환할 수 있습니다. 해제된 잠금이 사용됩니다. 임대 취소가 발생하지 않았고 서버가 무료 잠금 중 하나와 충돌하는 잠금 또는 I/O 요청을 받은 경우 요구 사항은 다음과 같습니다.\(MAY\)

o 위임이 아닌 무료 잠금의 경우 무료 잠금을 해제하고 새 요청을 승인해야 합니다.\(MUST\)

o 잠금 또는 I/O 요청이 무료 잠금으로 유지되는 위임과 충돌하는 경우 서버는 요청 해결을 지연할 수 있지만 요청을 거부해서는 안 되며 위임을 해제하고 새 요청을 승인해야 합니다. 결국 요청합니다.\(MUST NOT\)

o 무료 잠금으로 보관 중인 위임과 충돌하는 위임 요청의 경우 서버는 원하는 대로 새 요청을 승인할지 여부를 결정할 수 있지만, 충돌하는 요청을 승인하는 경우 위임은 무료 잠금 장치는 반드시 해제되어야 합니다.\(MUST\)

네트워크 파티션이 복구되기 전에 서버가 재부팅하지 않거나 임대를 취소하지 않는 경우 원래 클라이언트가 해제된 무료 잠금에 액세스하려고 하면 서버는 NFS4ERR\_BAD\_STATEID를 클라이언트에 다시 보내야 합니다. 클라이언트가 해제되지 않은 무료 잠금에 액세스하려고 하면 서버는 모든 무료 잠금을 암시적으로 갱신되는 것으로 표시해야 합니다.\(SHOULD, SHOULD\)

---
##### **9.6.3.2.  Lease Cancellation**

임대 만료로 인해 임대는 만료 직후 또는 이후에 취소될 수 있으며, 이는 잠금 충돌이 발생하거나 서버가 허용할 수 있는 기간을 초과하는 분할 기간이 연장되는 경우에 따라 달라집니다.

임대가 취소되면 이와 관련된 모든 잠금 상태가 해제되고 관련 stateid를 사용하면 NFS4ERR\_EXPIRED가 반환됩니다. 마찬가지로 연결된 클라이언트 ID를 사용하면 NFS4ERR\_EXPIRED가 반환됩니다.

클라이언트는 새 clientid를 설정하기 위해 SETCLIENTID 뒤에 SETCLIENTID\_CONFIRM을 사용하여 이 상황을 복구해야 합니다. 이 클라이언트 ID를 사용하여 잠금을 획득하면 임대가 설정됩니다.

---
##### **9.6.3.3.  Client's Reaction to a Freed Lock**

클라이언트가 네트워크 분할 중에 특정 서버가 어떻게 작동할지 미리 결정할 수 있는 방법은 없습니다. 파티션이 복구되면 클라이언트에는 여전히 모든 잠금이 있거나 일부 잠금이 있거나 잠금이 전혀 없습니다. 클라이언트는 다양한 오류 반환 값을 검사하여 응답을 결정할 수 있습니다.

```text
   NFS4ERR_EXPIRED:
```

- 파티션 도중 발생한 임대 취소로 인해 모든 잠금이 해제되었습니다. 클라이언트는 복구를 위해 SETCLIENTID를 사용해야 합니다.

```text
   NFS4ERR_ADMIN_REVOKED:
```

- 파티션 이전, 도중 또는 이후에 현재 잠금이 취소되었습니다. 클라이언트는 일반적으로 이 오류를 처리해야 합니다.\(SHOULD\)

```text
   NFS4ERR_BAD_STATEID:
```

- 파티션 중에 현재 잠금이 취소/해제되었으며, 서버가 재부팅되지 않았습니다. 다른 잠금은 여전히 ​​갱신될 수 있습니다. 클라이언트는 SETCLIENTID를 수행할 필요가 없으며 대신 RENEW 호출을 통해 조사해야 합니다.\(MAY, SHOULD\)

```text
   NFS4ERR_RECLAIM_BAD:
```

- 파티션 도중 현재 잠금이 해제되어 서버가 재부팅되었습니다. 서버에 다른 잠금에 대한 정보가 없을 수도 있습니다. 여전히 재생 가능합니다.

```text
   NFS4ERR_NO_GRACE:
```

- 파티션 중에 클라이언트의 잠금이 취소되었으며 서버가 재부팅되었습니다. 클라이언트의 잠금은 재생 가능하지 않습니다.

```text
   NFS4ERR_OLD_STATEID:
```

- 서버가 재부팅되지 않았습니다. 클라이언트는 일반적으로 이 오류를 처리해야 합니다.\(SHOULD\)

---
##### **9.6.3.4.  Edge Conditions**

네트워크 파티션이 서버 재부팅과 결합되면 서버와 클라이언트 모두 클라이언트가 더 이상 액세스할 수 없는 잠금을 회수하지 않도록 해야 할 책임이 있습니다. 간단히 말하면 다음과 같습니다.

o 클라이언트의 책임: 클라이언트는 가장 최근에 성공적으로 설정된 클라이언트 임대가 끝날 때 보유하지 않은 잠금을 회수하려고 시도해서는 안 됩니다.\(MUST NOT\)

o 서버의 책임: 서버는 충돌하는 잠금을 부여할 수 없었다는 사실을 알지 않는 한 클라이언트가 잠금을 회수하도록 허용해서는 안 됩니다. 그러나 충돌하는 잠금이 허용되었는지 여부를 결정할 때 위와 같이 클라이언트가 책임이 있다고 가정하는 것이 허용됩니다.\(MUST NOT\)

서버는 해당 클라이언트로부터 OPEN 작업을 받은 후 해당 클라이언트의 임대가 "성공적으로 설정되었습니다"라고 간주할 수 있습니다.

위의 내용은 일반적으로 서버 재부팅을 포함하지 않는 CLAIM\_DELEGATE\_PREV 재확보가 아닌 CLAIM\_PREVIOUS 재확보에 대한 것입니다. 그러나 클라이언트와 서버가 동시에 다운되는 기간 동안 서버가 CLAIM\_DELEGATE\_PREV를 지원하기 위해 위임 정보를 지속적으로 저장하는 경우 유사한 제한 사항이 적용됩니다.

다음 섹션에서는 이러한 책임을 무시할 경우 발생할 수 있는 문제를 보여주는 예를 제공하고 서버의 책임을 충족할 수 있는 서버 구현 전략의 예도 제공합니다.

---
###### **9.6.3.4.1.  First Server Edge Condition**

첫 번째 경계 조건에는 다음과 같은 시나리오가 있습니다.

1. 클라이언트 A가 잠금을 획득합니다.

2. 클라이언트 A와 서버는 상호 네트워크 분할을 경험하므로 클라이언트 A는 임대를 갱신할 수 없습니다.

3. 클라이언트 A의 임대가 만료되어 서버가 잠금을 해제합니다.

4. 클라이언트 B는 클라이언트 A의 잠금과 충돌할 수 있는 잠금을 획득합니다.

5. 클라이언트 B가 잠금을 해제합니다.

6. 서버가 재부팅됩니다.

7. 클라이언트 A와 서버 사이의 네트워크 파티션이 복구됩니다.

8. 클라이언트 A는 RENEW 작업을 실행하고 RENEW 작업을 다시 받습니다.

- NFS4ERR\_STALE\_CLIENTID.

9. 클라이언트 A는 서버의 유예 기간 내에 잠금을 회수합니다.

따라서 마지막 단계에서 서버는 클라이언트 A의 잠금 회수를 잘못 허용했습니다. 클라이언트 B가 잠금으로 보호하는 개체를 수정한 경우 클라이언트 A는 개체 손상을 경험하게 됩니다.

---
###### **9.6.3.4.2.  Second Server Edge Condition**

두 번째로 알려진 경계 조건은 다음과 같습니다.

1. 클라이언트 A가 잠금을 획득합니다.

2. 서버가 재부팅됩니다.

3. 클라이언트 A와 서버는 상호 네트워크 분할을 경험하므로 클라이언트 A는 유예 기간 내에 잠금을 회수할 수 없습니다.

4. 서버의 회수 유예 기간이 종료됩니다. 클라이언트 A에는 서버에 기록된 잠금이 없습니다.

5. 클라이언트 B는 클라이언트 A의 잠금과 충돌할 수 있는 잠금을 획득합니다.

6. 클라이언트 B가 잠금을 해제합니다.

7. 서버가 두 번째로 재부팅됩니다.

8. 클라이언트 A와 서버 사이의 네트워크 파티션이 복구됩니다.

9. 클라이언트 A는 RENEW 작업을 실행하고 RENEW 작업을 다시 받습니다.

- NFS4ERR\_STALE\_CLIENTID.

10. 클라이언트 A는 서버의 유예 기간 내에 잠금을 회수합니다.

첫 번째 경계 조건과 마찬가지로 두 번째 경계 조건 시나리오의 마지막 단계에서는 서버가 클라이언트 A의 잠금 회수를 잘못 승인했습니다.

---
###### **9.6.3.4.3.  Handling Server Edge Conditions**

위의 두 가지 예에서 클라이언트는 가장 최근에 성공적으로 설정된 임대가 끝날 때 보유하고 있던 잠금을 회수하려고 시도합니다. 이로써 책임을 다했습니다.

그러나 회수된 잠금이 마지막으로 유지된 이후 충돌하는 잠금을 부여했음에도 불구하고 서버는 회수를 허용하여 실패했습니다.

이러한 엣지 조건을 해결하려면 서버가 \(1\) 재부팅 후 엣지 조건이 발생한다고 가정하여 모든 회수 시도에 대해 NFS4ERR\_NO\_GRACE를 반환하거나 \(2\) 안정적인 저장소에 일부 정보를 기록해야 합니다. 서버가 안정적인 저장소에 기록하는 정보의 양은 엣지 조건이 발생할 때마다 서버가 원하는 정도에 반비례합니다. 모든 에지 조건을 완전히 허용하는 서버는 획득된 모든 잠금을 안정적인 저장소에 기록합니다. 클라이언트가 잠금을 해제하고 잠금 소유자가 잠금 해제를 위해 시퀀스 번호를 앞당기는 경우에만 안정적인 저장소에서 잠금 기록을 제거합니다. 소유자 시퀀스의 마지막 상태 저장 이벤트가 아닙니다. 앞서 언급한 두 가지 엣지 조건의 경우, 서버가 가장 가혹할 수 있고 여전히 회수 유예 기간을 지원하려면 서버가 최소한의 정보를 안정적인 저장소에 기록해야 합니다. 예를 들어, 서버 구현은 각 클라이언트에 대해 다음을 포함하는 레코드를 안정적인 저장소에 저장할 수 있습니다.

o 클라이언트의 ID 문자열.

o 클라이언트의 임대가 만료되었는지 또는 바이트 범위 잠금, 공유 예약 또는 위임을 취소하기 위한 관리 개입\(섹션 9.8 참조\)이 있었는지 여부를 나타내는 부울입니다.

o 서버 부팅 또는 재부팅 후 처음으로 업데이트되는 타임스탬프 클라이언트는 서버에서 바이트 범위 잠금, 공유 예약 또는 위임 상태를 획득합니다. 서버가 재부팅될 때까지 후속 잠금 요청 시 타임스탬프를 업데이트할 필요가 없습니다.

서버 구현은 또한 최근 두 번의 서버 재부팅의 타임스탬프를 안정적인 저장소에 기록합니다.

위의 기록 유지를 가정하면 첫 번째 엣지 조건의 경우 서버 재부팅 후 클라이언트 A의 임대가 만료되었다는 기록은 다른 클라이언트가 충돌하는 기록 잠금, 공유 예약 또는 위임을 획득했을 수 있음을 의미합니다. 따라서 서버는 NFS4ERR\_NO\_GRACE 또는 NFS4ERR\_RECLAIM\_BAD 오류와 함께 클라이언트 A의 회수를 거부해야 합니다.

두 번째 경계 조건의 경우 서버가 두 번째로 재부팅된 후 클라이언트가 만료되지 않은 레코드 잠금, 공유 예약 또는 서버의 이전 구현 이전에 설정된 위임을 가지고 있다는 기록은 서버가 클라이언트 A의 회수를 거부해야 함을 의미합니다. 오류 NFS4ERR\_NO\_GRACE 또는 NFS4ERR\_RECLAIM\_BAD.

기록 보관 수준 및 접근 방식에 관계없이 서버는 다음 전략 중 하나를 구현해야 합니다\(공유 예약 회수, 바이트 범위 잠금 및 위임에 적용됨\).\(MUST\)

1. NFS4ERR\_NO\_GRACE를 사용하여 모든 회수를 거부합니다. 이는 매우 가혹하지만 서버가 안정적인 저장소에 잠금 상태를 기록하지 않으려는 경우 필요합니다.

2. 이를 충족시키기 위해 충분한 상태를 안정적인 저장소에 기록합니다.

-   책임. 의심스러운 경우 서버는 가혹한 측면에서 오류를 범해야 합니다.

- 서버를 재부팅한 후 안정적인 저장소에 복구할 수 없는 손상이나 손상이 있다고 서버가 판단한 경우, 영향을 받은 모든 클라이언트 및/또는 잠금에 대해 서버는 NFS4ERR\_NO\_GRACE를 반환해야 합니다.\(MUST\)

---
###### **9.6.3.4.4.  Client Edge Condition**

세 번째 엣지 조건은 서버가 아닌 클라이언트에 영향을 미칩니다. 클라이언트가 일부 잠금을 회수하는 도중에 서버가 재부팅된 후 네트워크 파티션이 설정된 경우 클라이언트는 전체가 아닌 일부 잠금을 회수한 상황일 수 있습니다. 이 경우 보수적인 클라이언트는 회수되지 않은 잠금이 취소되었다고 가정합니다.

세 번째로 알려진 경계 조건은 다음과 같습니다.

1. 클라이언트 A가 잠금 1을 획득합니다.

2. 클라이언트 A가 잠금 2를 획득합니다.

3. 서버가 재부팅됩니다.

4. 클라이언트 A는 RENEW 작업을 실행하고 RENEW 작업을 다시 받습니다.

- NFS4ERR\_STALE\_CLIENTID.

5. 클라이언트 A는 서버의 유예 기간 내에 잠금 1을 회수합니다.

6. 클라이언트 A와 서버는 상호 네트워크 분할을 경험하므로 클라이언트 A는 유예 기간 내에 남은 잠금을 회수할 수 없습니다.

7. 서버의 회수 유예 기간이 종료됩니다.

8. 클라이언트 B는 클라이언트 A의 잠금 2와 충돌할 수 있는 잠금을 획득합니다.

9. 클라이언트 B가 잠금을 해제합니다.

10. 서버가 두 번째로 재부팅됩니다.

11. 클라이언트 A와 서버 사이의 네트워크 파티션이 복구됩니다.

12. 클라이언트 A는 RENEW 작업을 실행하고 RENEW 작업을 다시 받습니다.

- NFS4ERR\_STALE\_CLIENTID.

13. 클라이언트 A는 서버의 유예 기간 내에 잠금 1과 잠금 2를 모두 회수합니다.

마지막 단계에서 클라이언트는 충돌하는 잠금이 클라이언트 B에 부여되었을 때 해당 잠금을 계속 보유했던 것처럼 잠금 2를 회수합니다.

이는 첫 번째 서버 재부팅 후 SETCLIENTID에 의해 설정된 임대 종료 시 해당 잠금을 보유하지 않았음에도 불구하고 클라이언트가 잠금 2를 회수하려고 시도하여 책임에 실패했기 때문에 발생합니다. \(클라이언트는 이전 임대에 대해 잠금 2를 보유했지만 중요한 것은 가장 최근 임대뿐입니다.\)

서버는 잠금 2의 회수를 거부하여 이 상황을 피할 수 있습니다. 그러나 이를 정확하게 수행하려면 보유된 개별 잠금에 대한 추가 정보가 재부팅 후에도 유지되도록 해야 합니다. 서버 구현에서는 이를 수행할 필요가 없으므로 클라이언트는 서버가 그렇게 할 것이라고 가정해서는 안 됩니다.

대신, 클라이언트는 이전 서버 인스턴스에서 성공적으로 획득한 잠금만 회수해야 하며, 새로 재부팅하기 전에 회수하지 못한 잠금은 생략해야 합니다. 따라서 위의 마지막 단계에서 클라이언트 A는 잠금 1만 회수해야 합니다.\(MUST\)

---
###### **9.6.3.4.5.  Client's Handling of Reclaim Errors**

클라이언트의 NFS4ERR\_NO\_GRACE 및 NFS4ERR\_RECLAIM\_BAD 오류 처리에 대한 명령은 이 사양의 범위를 벗어납니다. 이러한 처리 전략은 클라이언트의 운영 환경에 따라 크게 달라지기 때문입니다. 그러나 한 가지 잠재적인 접근 방식이 아래에 설명되어 있습니다.

클라이언트의 회수가 실패하면 클라이언트가 상태 회수를 시도하는 객체의 변경 속성을 검사하고 이를 사용하여 일반 OPEN 또는 LOCK 요청을 통해 상태를 다시 설정할지 여부를 결정할 수 있습니다. 클라이언트의 운영 환경이 허용한다면 이는 허용됩니다. 즉, 클라이언트 구현자는 사용자의 동작을 문서화하는 것이 좋습니다. 클라이언트는 UNIX 신호, GUI 팝업 창 등을 통해 바이트 범위 잠금 또는 공유 예약\(위임 여부에 관계없이\)이 손실되었음을 애플리케이션에 알릴 수도 있습니다. 자세한 내용은 섹션 10.5를 참조하세요. 클라이언트 상태에서 회수되지 않은 위임을 처리하기 위해 클라이언트가 수행해야 하는 작업에 대해 설명합니다.

잠금 취소에 대한 자세한 내용은 섹션 9.8을 참조하세요.

---
### **9.7.  Recovery from a Lock Request Timeout or Abort**

잠금 요청 시간이 초과되는 경우 클라이언트는 요청을 재시도하지 않기로 결정할 수 있습니다. 클라이언트는 요청이 발행된 프로세스가 종료될 때\(예: UNIX에서 신호로 인해\) 요청을 중단할 수도 있습니다. 그러나 서버가 요청을 수신하고 그에 따라 조치를 취했을 수도 있습니다. 이렇게 하면 클라이언트가 변경 사항을 인식하지 못한 채 서버의 상태가 변경됩니다. 클라이언트가 동일한 상태 소유자의 seqid 및/또는 stateid를 사용하는 다른 작업을 시도하기 전에 상태를 서버와 재동기화하는 것이 가장 중요합니다. 이는 특별한 재동기화 작업 없이도 간단하게 수행할 수 있습니다.

서버는 상태 소유자에서 받은 마지막 잠금 요청과 응답을 유지 관리하므로 각 상태 소유자에 대해 클라이언트는 잠금 요청이 응답을 받지 않도록 보낸 마지막 잠금 요청을 캐시해야 합니다. 이로부터 다음에 클라이언트가 상태 소유자에 대한 잠금 작업을 수행할 때 캐시된 요청이 있는 경우 이를 보낼 수 있으며 요청이 상태를 설정한 것\(예: LOCK 또는 OPEN 작업\)인 경우 서버는 캐시된 결과를 반환하거나, 요청을 본 적이 없다면 이를 수행합니다. 클라이언트는 상태 제거 요청\(예: LOCKU 또는 CLOSE 작업\)을 수행할 수 있습니다. 이 접근 방식을 사용하면 지정된 상태 소유자에 대한 클라이언트와 서버의 순서 및 상태 ID 정보가 다시 동기화되고, 결과적으로 잠금 상태도 다시 동기화됩니다.

---
### **9.8.  Server Revocation of Locks**

언제든지 서버는 클라이언트가 보유한 잠금을 취소할 수 있으며 클라이언트는 이 이벤트에 대비해야 합니다. 클라이언트가 잠금이 취소되었거나 취소되었을 수 있음을 감지하면 클라이언트는 자신과 서버 간의 상태 정보를 검증해야 합니다. 클라이언트의 잠금 상태를 검증한다는 것은 클라이언트가 현재 보유하고 있는 각 잠금의 상태를 확인하거나 회수해야 함을 의미합니다.

잠금 취소의 첫 번째 인스턴스는 서버를 재부팅하거나 다시 초기화할 때 발생합니다. 이 경우 클라이언트는 오류\(NFS4ERR\_STALE\_STATEID 또는 NFS4ERR\_STALE\_CLIENTID\)를 수신하고 클라이언트는 이전 섹션에서 설명한 대로 일반적인 충돌 복구를 진행합니다.

두 번째 잠금 취소 이벤트는 만료 전에 임대를 갱신할 수 없는 것입니다. 이는 드물거나 특이한 사건으로 간주되지만 고객은 회복할 준비가 되어 있어야 합니다. 서버와 클라이언트 모두 임대 갱신 실패를 감지하고 데이터 손상 없이 복구할 수 있습니다. 서버의 경우 클라이언트에 대해 서비스된 마지막 갱신 이벤트를 추적하고 임대가 만료되는 시기를 알고 있습니다. 마찬가지로 클라이언트는 임대 기간을 갱신하는 작업을 추적해야 합니다. 각 요청이 전송된 시간과 해당 응답이 수신된 시간을 사용하여 클라이언트는 해당 갱신이 서버에서 발생할 수 있는 시간을 제한하여 임대 기간 만료가 발생할 수 있는지 확인해야 합니다. .

세 번째 잠금 해제 이벤트는 임대 기간 내에 관리자 개입의 결과로 발생할 수 있습니다. 이는 드문 사건으로 간주되지만 서버 관리자가 클라이언트가 보유한 특정 잠금을 해제하거나 취소하기로 결정했을 수도 있습니다. 취소의 결과로 클라이언트는 NFS4ERR\_ADMIN\_REVOKED 오류를 수신하게 됩니다. 이 경우 클라이언트는 상태 소유자의 잠금만 손실되었다고 가정할 수 있습니다. 클라이언트는 잠금 보유자에게 적절하게 알립니다. 클라이언트는 작업 실패로 인해 임대 기간이 갱신되었다고 가정할 수 없습니다.

클라이언트가 임대 기간이 만료되었다고 판단하면 클라이언트는 관련 임대에 대해 보유된 모든 잠금을 "유효하지 않음"으로 표시해야 합니다. 이는 클라이언트가 서버에 대한 적절한 잠금 상태를 다시 설정하거나 확인할 수 없음을 의미합니다. 섹션 9.6에 설명된 대로 클라이언트에 대한 임대 기간이 만료된 후 서버가 충돌하는 잠금을 허용할 수 있는 시나리오가 있습니다. 임대 기간이 만료되었을 가능성이 있는 경우 클라이언트는 현재 보유하고 있는 각 잠금의 유효성을 검사하여 충돌하는 잠금이 부여되지 않았는지 확인해야 합니다. 클라이언트는 I/O 요청을 발행하여 이 작업을 수행할 수 있습니다. 보류 중인 관련 I/O가 없는 경우 문제의 잠금과 관련된 stateid를 지정하는 길이가 0인 읽기를 합성하여 갱신을 트리거할 수 있습니다. 요청에 대한 응답이 성공하면 클라이언트는 해당 stateid에 의해 관리되는 모든 잠금의 유효성을 검사하고 자체와 서버 간의 적절한 상태를 다시 설정합니다.

I/O 요청이 성공하지 못한 경우 stateid와 관련된 잠금 중 하나 이상이 서버에 의해 취소되었으며 클라이언트는 소유자에게 이를 알려야 합니다.

---
### **9.9.  Share Reservations**

공유 예약은 파일에 대한 액세스를 제어하는 ​​메커니즘입니다. 이는 바이트 범위 잠금과 별개의 독립적인 메커니즘입니다. 클라이언트가 파일을 열면 필요한 액세스 유형\(READ, WRITE 또는 BOTH\)과 다른 액세스를 거부할 액세스 유형\(OPEN4\_SHARE\_DENY\_NONE, OPEN4\_SHARE\_DENY\_READ, OPEN4\_SHARE\_DENY\_WRITE 또는 OPEN4\_SHARE\_DENY\_BOTH\)을 지정하여 서버에 OPEN 작업을 실행합니다. OPEN이 실패하면 클라이언트는 애플리케이션의 열기 요청에 실패합니다.

의미론의 의사 코드 정의:

```text
     if (request.access == 0)
             return (NFS4ERR_INVAL)
     else if ((request.access & file_state.deny) ||
         (request.deny & file_state.access))
             return (NFS4ERR_DENIED)
```

OPEN에 대한 공유 예약 확인은 동일한 공개 소유자에 대한 기존 OPEN에 대해 예외 없이 수행됩니다.

액세스 및 거부 필드에 대한 OPEN 및 OPEN\_DOWNGRADE 작업에 사용되는 상수는 다음과 같습니다.

```text
   const OPEN4_SHARE_ACCESS_READ   = 0x00000001;
   const OPEN4_SHARE_ACCESS_WRITE  = 0x00000002;
   const OPEN4_SHARE_ACCESS_BOTH   = 0x00000003;

   const OPEN4_SHARE_DENY_NONE     = 0x00000000;
   const OPEN4_SHARE_DENY_READ     = 0x00000001;
   const OPEN4_SHARE_DENY_WRITE    = 0x00000002;
   const OPEN4_SHARE_DENY_BOTH     = 0x00000003;
```

---
### **9.10.  OPEN/CLOSE Operations**

올바른 공유 의미를 제공하려면 클라이언트는 OPEN 작업을 사용하여 초기 파일 핸들을 얻고 원하는 액세스와 거부할 액세스\(있는 경우\)를 나타내야 합니다. 클라이언트가 특수 상태 ID\(익명 상태 ID 또는 READ 바이패스 상태 ID\) 중 하나를 사용하려는 경우에도 OPEN 작업을 통해 일반 파일에 대한 파일 핸들을 얻어야 적절한 공유 의미 체계를 사용할 수 있습니다.\(MUST\)

적용된. 파일 열기를 위한 프로그래밍 인터페이스에 기본 거부 모드가 없는 클라이언트는 OPEN4\_SHARE\_DENY\_NONE 거부 모드를 요청해야 합니다.

CREATE 플래그를 사용한 OPEN 작업은 이전 버전의 NFS 프로토콜에서 사용된 일반 파일에 대한 CREATE 작업도 포함합니다. 이를 통해 공유를 통한 생성이 원자적으로 수행될 수 있습니다.

CLOSE 작업은 해당 파일에 대해 공개 소유자가 보유한 모든 공유 예약을 제거합니다. 바이트 범위 잠금이 유지되면 클라이언트는 CLOSE를 발행하기 전에 모든 잠금을 해제해야 합니다. 서버는 CLOSE 시 미해결 잠금을 모두 해제할 수 있지만 일부 서버는 여전히 바이트 범위 잠금이 유지된 파일의 CLOSE를 지원하지 않을 수 있습니다. CLOSE 이후 잠금이 존재하는 경우 서버는 실패 NFS4ERR\_LOCKS\_HELD를 반환해야 합니다.\(SHOULD, MAY, MUST\)

LOOKUP 작업은 서버에 잠금 상태를 설정하지 않고 파일 핸들을 반환합니다. 유효한 stateid가 없으면 서버는 클라이언트의 액세스 권한이 가장 적은 것으로 가정합니다. 예를 들어 한 클라이언트가 OPEN4\_SHARE\_DENY\_BOTH를 사용하여 파일을 열고 다른 클라이언트가 LOOKUP을 통해 얻은 파일 핸들을 통해 파일에 액세스하는 경우 두 번째 클라이언트는 특수 READ 바이패스 상태 ID를 사용하여 파일을 읽을 수만 있습니다. 두 번째 클라이언트는 OPEN의 유효한 상태 ID가 없고 특수 익명 상태 ID에 대한 액세스가 허용되지 않기 때문에 파일을 전혀 쓸 수 없습니다.

---
#### **9.10.1.  Close and Retention of State Information**

CLOSE 작업은 stateid 할당 해제를 요청하므로 CLOSE 재전송을 처리하는 데 특별한 어려움이 있을 수 있습니다. 일반적으로 지정되는 열린 파일의 상태를 결정하는 데 사용되는 상태 정보가 할당 해제되어 NFS4ERR\_BAD\_STATEID가 발생할 수 있기 때문입니다. 오류.

서버는 다양한 방법으로 이 문제를 처리할 수 있습니다. 프로토콜이 적절하게 사용되고 있다는 가장 큰 확신을 제공하기 위해 서버는 stateid를 할당 해제하는 대신 이를 종료 보류 중으로 표시하고 나중에 할당 해제될 때까지 이 상태의 stateid를 유지해야 합니다. 이런 방식으로 재전송된 CLOSE를 stateid가 이러한 고유한 상태의 상태 정보를 가리키므로 인식할 수 있어 오류 없이 처리할 수 있습니다.

이 전략을 채택할 때 서버는 다음 중 가장 빠른 시점까지 상태 정보를 유지해야 합니다.

o 동일한 공개 소유자에 대해 유효하게 순서가 지정된 또 다른 요청으로, 이는 재전송이 아닙니다.

o 활동이 없는 기간으로 인해 오픈 소유자가 서버에 의해 해제되는 시간입니다.

o SETCLIENTID의 결과로 클라이언트에 대한 모든 잠금이 해제됩니다.

서버는 이 경우가 재전송된 종료로 인해 발생해야 한다는 가정 하에 할당 취소된 stateid에 대한 CLOSE 이벤트에서 단순히 NFS4\_OK에 응답함으로써 덜 완전한 프로토콜 오류 검사를 수행함으로써 이러한 복잡성을 피할 수 있습니다. 이 접근 방식을 채택할 때 이 상황에서 오류 없음 표시를 반환할 때 최소한 오류를 기록하는 것이 바람직합니다. 서버가 응답 캐시 메커니즘을 유지하는 경우 CLOSE가 실제로 재전송인지 확인하고 대부분의 경우 오류 로깅을 피할 수 있습니다.

---
### **9.11.  Open Upgrade and Downgrade**

파일에 대해 OPEN이 수행되고 열기가 수행되는 개방 소유자가 이미 파일을 연 경우 결과적으로 서버에서 유지 관리되는 열린 파일 상태가 새 파일에 의해 지정된 액세스 및 거부 비트를 포함하도록 업그레이드됩니다. OPEN은 물론 기존 OPEN에 대한 것들도 포함됩니다. 결과적으로 프로토콜에 관한 한 하나의 열린 파일이 있으며, 여기에는 완료된 모든 OPEN 요청에 대한 액세스 및 거부 비트의 통합이 포함됩니다. 두 OPEN의 효과를 재설정하기 위해 단 한 번의 CLOSE만 수행됩니다. OPEN을 실행할 때 클라이언트는 동일한 파일이 실제로 열려 있다는 사실을 알지 못할 수도 있습니다. 위의 내용은 두 OPEN으로 인해 OPENed 개체가 동일한 파일 핸들로 지정되는 경우에만 적용됩니다.

서버가 동일한 파일 객체에 해당하는 여러 파일 핸들을 내보내도록 선택하고 동일한 파일 객체의 두 개의 다른 OPEN에서 서로 다른 파일 핸들을 반환하는 경우 서버는 액세스 비트와 거부 비트를 함께 "OR"하여 열려 있는 두 파일을 통합해서는 안 됩니다. 대신 서버는 별도의 stateid를 사용하여 별도의 OPEN을 유지해야 하며 이를 해제하려면 별도의 CLOSE가 필요합니다.\(MUST NOT\)

클라이언트에 있는 여러 개의 열린 파일이 서버에 있는 단일 열린 파일 개체로 병합된 경우 클라이언트에 있는 열린 파일 중 하나를 닫으면 서버에 있는 열린 파일의 액세스 및 거부 상태가 변경되어야 할 수 있습니다. 이는 나머지 열기에 대한 액세스 및 거부 비트의 결합이 이전보다 더 작을 수 있기 때문입니다\(즉, 적절한 하위 집합\). OPEN\_DOWNGRADE 작업은 필요한 변경을 수행하는 데 사용되며 클라이언트는 이를 업데이트하는 데 사용해야 합니다.

다른 클라이언트의 공유 예약 요청이 올바르게 처리되도록 서버를 구성합니다. 반환된 stateid에는 서버에 전달된 것과 동일한 "other" 필드가 있습니다. 파일에 대한 액세스 및 거부 비트가 변경되지 않은 상황에서도 반환된 stateid의 seqid 값은 반드시 증가되어야 합니다\(9.1.4절\).\(MUST\)

---
### **9.12.  Short and Long Leases**

서버 임대 기간을 결정할 때 일반적인 임대 절충안이 적용됩니다. 짧은 임대는 RENEW 또는 READ\(길이가 0인\) 요청을 늘리는 대신 빠른 서버 복구에 적합합니다. 임대 기간이 길어질수록 매우 많은 수의 클라이언트를 처리하려는 서버에 확실히 더 친절하고 온화해집니다. RENEW 요청 횟수는 임대 시간에 비례하여 감소합니다. 장기 임대의 단점은 서버 오류 후 복구 속도가 느리고\(서버는 새 잠금 요청을 승인하기 전에 임대가 만료되고 유예 기간이 경과할 때까지 기다려야 함\) 파일 경합이 증가한다는 것\(클라이언트가 잠금 해제 요청 전송에 실패하면 서버는 새 잠금을 부여하기 전에 임대 만료를 기다려야 합니다.

서버가 비휘발성 메모리에 임대 상태를 저장할 수 있는 경우 장기 임대를 사용할 수 있습니다. 복구 시 서버는 비휘발성 메모리에서 임대 상태를 재구성하고 클라이언트와의 작업을 계속할 수 있으므로 장기 임대는 문제가 되지 않습니다.

---
### **9.13.  Clocks, Propagation Delay, and Calculating Lease Expiration**

동기화된 시계의 필요성을 피하기 위해 임대 시간은 서버에서 시간 델타로 부여됩니다. 그러나 클라이언트와 서버 시계가 잠금 기간 동안 과도하게 드리프트하지 않아야 한다는 요구 사항이 있습니다. 또한 네트워크 전반에 걸친 전파 지연 문제\(쉽게 수백 밀리초가 될 수 있음\)와 요청이 손실되어 재전송되어야 할 가능성도 있습니다.

전파 지연을 고려하려면 클라이언트는 이를 임대 시간에서 빼야 합니다\(예를 들어 클라이언트가 단방향 전파 지연을 200msec로 추정하는 경우 임대를 얻을 때 이미 200msec가 지났다고 가정할 수 있습니다\). 또한 서버에 응답을 다시 받는 데 200msec가 더 걸립니다. 따라서 클라이언트는 임대가 만료되기 400msec 전에 잠금 갱신을 보내거나 데이터를 서버에 다시 써야 합니다.

서버의 임대 기간 구성은 서버의 리소스에 액세스할 클라이언트의 네트워크 거리를 고려해야 합니다. 임대 기간은 네트워크 전파 지연 및 기타 네트워크 지연을 고려하여 책정될 것으로 예상됩니다.

클라이언트 인구에 대한 요소. 프로토콜은 적절한 임대 기간을 결정하는 자동 방법을 허용하지 않으므로 서버 관리자는 임대 기간을 조정해야 할 수도 있습니다.

---
### **9.14.  Migration, Replication, and State**

특정 파일 시스템 처리에 대한 책임이 새 서버로 이전되거나\(이전\) 클라이언트가 파일 시스템 복제 환경에서 대체 서버를 사용하기로 선택한 경우\(예: 서버 응답 없음에 대한 응답\) 클라이언트와 서버\(예: 잠금, 임대, 상태 ID 및 클라이언트 ID\)는 아래에 설명되어 있습니다. 마이그레이션과 복제의 처리 방법은 다릅니다. 파일 서버 상태 및 복구에 대한 관련 논의는 섹션 9.6의 하위 섹션을 참조하세요.

한 서버가 다른 서버에서 시작된 클라이언트의 불투명 값을 허용할 것으로 예상되는 경우 서버는 빅엔디안 바이트 순서로 불투명 값을 인코딩해야 합니다. 이 작업이 완료되면 새 서버는 기본 바이트 순서가 파일 시스템의 복제 및 마이그레이션에 협력하는 다른 서버의 것과 다르더라도 상태 ID, 디렉터리 쿠키, 파일 핸들 등과 같은 값을 구문 분석할 수 있습니다.\(SHOULD\)

---
#### **9.14.1.  Migration and State**

마이그레이션의 경우 파일 시스템 마이그레이션과 관련된 서버는 모든 서버 상태를 원래 서버에서 새 서버로 전송해야 합니다. 이는 클라이언트에게 투명한 방식으로 수행되어야 합니다. 이 상태 전송은 파일 시스템 마이그레이션이 발생할 때 클라이언트의 전환을 쉽게 해줍니다. 서버가 모든 상태를 성공적으로 전송하면 클라이언트는 원래 서버에서 할당한 상태 ID를 계속 사용합니다. 따라서 새 서버는 이러한 상태 ID를 유효한 것으로 인식해야 합니다. 이는 클라이언트 ID에도 적용됩니다. 마이그레이션 이벤트를 통해 전체 파일 시스템에 대한 책임이 이전되므로 잠금 이전으로 인해 새 서버에서 충돌이 발생할 가능성이 없습니다.\(SHOULD\)

서버 간 정보 전송의 일부로 임대도 전송됩니다. 새 서버로 전송되는 임대는 일반적으로 이전 서버에 있던 동일한 클라이언트의 만료 시간과 다릅니다. 특정 클라이언트에 대한 특정 서버의 모든 임대가 동시에 만료되는 속성을 유지하려면 서버는 만료 시간을 전송 중인 임대 또는 이미 존재하는 임대 중 나중에 만료되는 시간으로 앞당겨야 합니다. 이를 통해 고객은 특별한 노력 없이도 두 클래스의 임대 갱신을 유지할 수 있습니다.

서버는 마이그레이션 시 상태 정보를 전송하지 않도록 선택할 수 있습니다. 그러나 이 선택은 권장되지 않습니다. 이 경우 클라이언트가 원래 서버의 상태 정보를 제공할 때\(예: RENEW 작업 또는 길이가 0인 READ 작업\) 클라이언트는 새 서버로부터 NFS4ERR\_STALE\_CLIENTID 또는 NFS4ERR\_STALE\_STATEID를 수신할 준비가 되어 있어야 합니다. 그런 다음 클라이언트는 서버 오류에 대한 응답으로 일반적으로 하는 것처럼 상태 정보를 복구해야 합니다. 새 서버는 서버가 다시 시작되는 경우와 마찬가지로 상태 정보를 복구할 수 있도록 주의를 기울여야 합니다.

클라이언트는 섹션 16.33 및 16.34에 설명된 순서에 따라 가능한 한 빨리 새 서버로 새 콜백 정보를 다시 설정해야 합니다. 이렇게 하면 위임을 회수할 수 없어 서버 작업이 차단되는 일이 발생하지 않습니다.\(SHOULD\)

---
#### **9.14.2.  Replication and State**

복제 시 클라이언트 전환은 서버 제어 하에 있지 않으므로 상태 처리가 다릅니다. 이 경우 임대, 상태 ID 및 클라이언트 ID는 한 서버에서 다른 서버로 전환하는 동안 유효하지 않습니다. 클라이언트는 새 서버에서 잠금을 다시 설정해야 합니다. 이는 서버 재부팅 후 회수 유형 요청을 통해 잠금을 다시 설정하는 것과 비교할 수 있습니다. 차이점은 서버에 잠금 회수 요청과 새 잠금 획득 요청을 구별하거나 후자를 연기하는 규정이 없다는 것입니다. 따라서 클라이언트가 새 서버에 잠금을 다시 설정하면\(LOCK 또는 OPEN 요청을 통해\) 잠금 충돌로 인해 요청이 거부될 수 있습니다. 복제는 파일 시스템의 읽기 전용 사용을 위한 것이므로 이러한 잠금 거부는 실제로 큰 어려움을 초래하지 않습니다. 새 서버에 대한 잠금을 다시 설정하려는 시도가 거부되면 클라이언트는 원래 잠금이 취소된 것처럼 상황을 처리해야 합니다.

---
#### **9.14.3.  Notification of Migrated Lease**

임대 갱신의 경우 클라이언트가 다른 서버로 마이그레이션된 파일 시스템에 대한 요청을 제출하지 않을 수 있습니다. 이는 암시적 임대 갱신 메커니즘으로 인해 발생할 수 있습니다. 클라이언트는 서버의 한 파일 시스템에 요청을 제출할 때 모든 파일 시스템에 대한 임대를 갱신합니다.

클라이언트가 새 서버로 재배치되었을 수 있는 임대 갱신을 예약하려면 클라이언트는 해당 임대가 만료되기 전에 임대 재배치에 대해 알아내야 합니다. 이를 달성하기 위해 클라이언트에 대한 임대를 암시적으로 갱신하는 모든 작업\(예: OPEN, CLOSE, READ, WRITE, RENEW, LOCK 등\)은 임대에 대한 책임이 있는 경우 NFS4ERR\_LEASE\_MOVED 오류를 반환합니다.

리뉴얼되어 새로운 서버로 이전되었습니다. 이 조건은 클라이언트가 NFS4ERR\_MOVED 오류를 수신하고 서버가 임대가 새 서버로 이동된 각 파일 시스템에 대한 액세스에 대한 후속 GETATTR\(fs\_locations\)을 수신할 때까지 계속됩니다. 관례적으로, GETATTR\(fs\_locations\)을 포함하는 화합물은 서버가 액세스를 수행하는 클라이언트를 식별할 수 있도록 RENEW 작업을 추가해야 합니다.\(SHOULD\)

NFS4ERR\_LEASE\_MOVED 오류를 수신하면 파일 시스템 마이그레이션을 지원하는 클라이언트는 열린 상태를 유지하는 해당 서버의 모든 파일 시스템을 조사해야 합니다. 클라이언트가 마이그레이션된 모든 파일 시스템을 성공적으로 조사한 후에는 서버는 해당 클라이언트의 상태 저장 요청에 대한 정상적인 처리를 다시 시작해야 합니다.\(MUST, MUST\)

NFS4ERR\_LEASE\_MOVED 오류를 올바르게 처리하지 않는 레거시 클라이언트를 지원하려면 서버는 최소 2번의 임대 기간을 기다린 후 시간 초과되어야 하며, 이때 서버는 모든 클라이언트의 상태 저장 요청에 대한 정상적인 처리를 재개합니다. 클라이언트가 마이그레이션된 파일에 액세스하려고 시도하면 서버는 NFS4ERR\_MOVED로 응답해야 합니다.\(SHOULD, MUST\)

클라이언트가 NFS4ERR\_MOVED 오류를 수신하면 클라이언트는 일반 프로세스에 따라 fs\_locations 속성을 통해 새 서버 정보를 얻고 새 서버에서 해당 임대 갱신을 수행할 수 있습니다. 서버의 상태가 투명하게 전송되지 않은 경우 클라이언트는 위에서 설명한 대로 새 서버로부터 NFS4ERR\_STALE\_CLIENTID 또는 NFS4ERR\_STALE\_STATEID를 수신합니다. 그러면 클라이언트는 서버 오류 발생 시와 마찬가지로 상태 정보를 복구할 수 있습니다.

---
#### **9.14.4.  Migration and the lease_time Attribute**

마이그레이션 시 클라이언트가 임대를 적절하게 관리할 수 있도록 대상 서버는 Lease\_time 속성에 대한 적절한 값을 설정해야 합니다.

상태가 투명하게 전송되면 해당 상태에는 Lease\_time 속성의 올바른 값이 포함되어야 합니다. 대상 서버의 Lease\_time 속성은 원본의 임대 시간 속성보다 작아서는 안 됩니다. 이렇게 하면 원본 서버에서 부여한 임대가 조기 만료될 수 있기 때문입니다. 상태가 투명하게 전송되는 마이그레이션 시 클라이언트는 rent\_time 속성을 다시 가져올 의무가 없으며 \(소스 서버에서\) 이전에 가져온 값을 계속 사용할 수 있습니다.

상태가 투명하게 전송되지 않은 경우\(즉, 클라이언트가 실제 또는 시뮬레이션된 서버 재부팅을 확인하는 경우\) 클라이언트는 새\(즉, 대상\) 서버에서 Lease\_time 값을 가져와 사용해야 합니다.

후속 잠금 요청을 위해. 그러나 서버는 잠재적으로 충돌할 수 있는 비재확보 잠금이 부여되기 전에 클라이언트가 잠금을 재확보할 수 있는 충분한 시간을 갖도록 하기 위해 최소한 소스 서버의 rent\_time만큼 긴 유예 기간을 준수해야 합니다. 새 서버가 이전 서버에서 Lease\_time 값을 얻는 방법은 서버 구현에 달려 있습니다. NFSv4 프로토콜에서는 지정되지 않습니다.

---
## **10.  Client-Side Caching**

NFS 프로토콜로 우수한 성능을 제공하려면 클라이언트측 데이터, 파일 속성 및 파일 이름 캐싱이 필수적입니다. 분산된 캐시 일관성을 제공하는 것은 어려운 문제이며 이전 버전의 NFS 프로토콜에서는 이를 시도하지 않았습니다. 대신 일관성 부족으로 인해 사용자에게 발생하는 문제를 줄이기 위해 여러 NFS 클라이언트 구현 기술이 사용되었습니다. 이러한 기술은 이전 프로토콜 사양에 의해 명확하게 정의되지 않았으며 클라이언트 동작이 유효한지 또는 유효하지 않은지 불분명한 경우가 많습니다.

NFSv4 프로토콜은 이전 프로토콜 버전에서 사용된 것과 유사한 많은 기술을 사용합니다. NFSv4 프로토콜은 분산 캐시 일관성을 제공하지 않습니다. 그러나 클라이언트 측 캐싱으로 인한 파괴적인 간섭 없이 잠금 및 공유 예약을 사용할 수 있도록 보다 제한된 캐싱 보장 세트를 정의합니다.

또한 NFSv4 프로토콜은 일반적으로 서버에서 내리는 많은 결정을 클라이언트가 로컬에서 내릴 수 있도록 하는 위임 메커니즘을 도입합니다. 이 메커니즘은 공유가 자주 발생하지 않거나 공유가 읽기 전용인 일반적인 경우를 효율적으로 지원합니다.

---
### **10.1.  Performance Challenges for Client-Side Caching**

NFS 프로토콜의 이전 버전에서 사용된 캐싱 기술은 우수한 성능을 제공하는 데 성공했습니다. 그러나 이러한 기술을 매우 많은 수의 클라이언트에서 사용할 경우 몇 가지 확장성 문제가 발생할 수 있습니다. 이는 클라이언트가 지리적으로 분산되어 있는 경우 특히 그렇습니다. 이는 일반적으로 캐시 재검증 요청에 대한 대기 시간을 증가시킵니다.

이전 버전의 NFS 프로토콜은 파일이 열릴 때 파일 데이터 캐시 유효성 검사 요청을 반복합니다. 이 동작은 심각한 성능 문제를 일으킬 수 있습니다. 일반적인 경우는 단일 클라이언트에서만 파일에 액세스하는 경우입니다. 따라서 공유가 자주 발생하지 않습니다.

이 경우 충돌이 없는지 확인하기 위해 서버를 반복적으로 참조하는 것은 비용이 많이 듭니다. 성능과 관련하여 더 나은 옵션은 서버를 참조하지 않고 반복적으로 파일을 여는 클라이언트를 허용하는 것입니다. 이는 다른 클라이언트의 잠재적인 충돌 작업이 실제로 발생할 때까지 수행됩니다.

파일 잠금과 관련하여 유사한 상황이 발생합니다. 데이터 캐싱을 잠금 의미론\(섹션 10.3.2 참조\)과 일치시키는 데 필요한 READ 및 WRITE 요청뿐만 아니라 파일 잠금 및 잠금 해제 요청을 서버에 보내는 것은 성능을 심각하게 제한할 수 있습니다. 자주 발생하지 않는 충돌로부터 보호하기 위해 잠금을 사용하면 큰 페널티가 발생합니다. 이 페널티는 응용 프로그램의 파일 잠금 사용을 방해할 수 있습니다.

NFSv4 프로토콜은 다음 설계 목표에 따라 보다 공격적인 캐싱 전략을 제공합니다.

o 광범위한 서버 의미론과의 호환성.

o 보다 공격적인 모델을 제공할 수 없는 경우 이전 버전의 NFS 프로토콜과 동일한 캐싱 이점을 제공합니다.

o 모든 요구 사항이 충족되지 않는 경우에도 많은 이점을 얻을 수 있도록 공격적인 캐싱에 대한 요구 사항을 구성합니다.

서버에 대한 적절한 요구 사항은 특정 형태의 캐싱을 다루는 이후 섹션에서 논의됩니다\(섹션 10.4 참조\).

---
### **10.2.  Delegation and Callbacks**

파일에 대한 서버 책임을 클라이언트에 다시 위임하면 클라이언트 간 충돌이 없을 때 서버에 대한 반복 요청을 방지하여 성능이 향상됩니다. 서버에서 클라이언트로의 "콜백" RPC를 사용하면 다른 클라이언트가 위임된 파일 공유에 참여할 때 서버는 위임된 책임을 회수합니다.

위임 대상과 위임 유형을 지정하여 위임이 서버에서 클라이언트로 전달됩니다. 다양한 유형의 위임이 있지만 각 유형에는 위임에 의존하는 작업을 수행할 때 위임을 나타내는 데 사용되는 상태 ID가 포함되어 있습니다. 이 상태 ID는 잠금 및 공유 예약과 관련된 상태 ID와 유사하지만 위임에 대한 상태 ID가 클라이언트 ID와 연결되어 있고

해당 클라이언트의 모든 공개 소유자를 대신하여 사용됩니다. 위임은 클라이언트 내부의 특정 프로세스나 제어 스레드가 아닌 클라이언트 전체에 대해 이루어집니다.

콜백 RPC는 모든 환경에서 작동하지 않을 수 있으므로\(예: 방화벽으로 인해\) 올바른 프로토콜 작동은 이에 의존하지 않습니다. CB\_NULL 프로시저를 통한 콜백 기능의 예비 테스트를 통해 콜백 지원 여부가 결정됩니다. CB\_NULL 프로시저는 콜백 경로의 연속성을 확인합니다. 서버는 특정 클라이언트에 대한 콜백 가용성을 예비 평가하고 콜백이 지원된다는 것을 확인할 때까지 책임 위임을 방지합니다. 위임 승인은 항상 충돌하는 액세스가 없을 때 조건부로 이루어지기 때문에 클라이언트는 위임이 승인될 것이라고 가정해서는 안 되며 위임이 승인되지 않은 채 OPEN이 처리될 수 있도록 항상 준비해야 합니다.

일단 승인되면 위임은 대부분의 방식으로 잠금처럼 작동합니다. 해당 고객이 보유한 다른 모든 임대와 함께 갱신 대상인 관련 임대가 있습니다.

잠금과 달리 위임된 파일에 대한 두 번째 클라이언트의 작업으로 인해 서버는 콜백을 통해 위임을 회수하게 됩니다.

회수 시 위임을 보유한 클라이언트는 수정된 상태\(예: 수정된 데이터\)를 서버에 플러시하고 위임을 반환해야 합니다. 회수가 완료될 때까지 충돌하는 요청은 처리되지 않습니다. 클라이언트가 위임을 반환하거나 서버가 위임 반환 대기 시간을 초과하고 시간 초과로 인해 위임을 취소하면 회수가 완료된 것으로 간주됩니다. 그 사이에 서버는 충돌하는 요청에 대한 응답을 지연하거나 NFS4ERR\_DELAY로 응답합니다. 회수 해결 후 서버는 두 번째 클라이언트의 요청을 승인하거나 거부하는 데 필요한 정보를 갖게 됩니다.

클라이언트가 위임 회수를 수신할 때 서버에 플러시해야 하는 실질적인 상태가 있을 수 있습니다. 따라서 서버에 대한 수많은 RPC가 포함될 수 있으므로 서버는 위임이 반환될 때까지 충분한 시간을 허용해야 합니다. 클라이언트가 회수의 결과로 서버에 상태를 부지런히 플러시하고 있음을 서버가 확인할 수 있는 경우 서버는 회수에 허용되는 일반적인 시간을 연장할 수 있습니다. 그러나 회수 완료에 허용되는 시간은 제한이 없어야 합니다.\(MAY\)

이에 대한 예는 특정 파일에 대한 열기를 중재하는 책임이 클라이언트에 위임되는 경우입니다\(섹션 10.4 참조\). 서버는 클라이언트에 어떤 열기가 적용되는지 알 수 없습니다. 이 지식이 없으면 서버는 파일에 대한 위임이 반환될 때까지 파일에 대한 액세스 및 거부 상태가 특정 열기를 허용하는지 여부를 확인할 수 없습니다.

클라이언트 오류 또는 네트워크 파티션으로 인해 회수 콜백에 응답하지 못할 수 있습니다. 이 경우 서버는 위임을 취소합니다. 그러면 클라이언트에 여전히 수정된 상태가 쓸모 없게 됩니다.

클라이언트는 서버 구현자가 발행된 위임 수에 실질적인 제한을 적용할 수 있다는 점을 알아야 합니다. 또한 어떤 위임을 취소할지 결정할 수 있는 방법이 없으므로 서버는 어떤 위임이라도 취소할 수 있습니다. 해당 클라이언트가 보유하고 있는 다른 위임을 취소하도록 서버가 구현된 경우, 각각의 새로운 위임 요청으로 인해 취소가 발생하므로 클라이언트는 제한에 도달했는지 확인할 수 있습니다. 그런 다음 클라이언트는 필요하지 않은 위임을 결정하고 이를 선제적으로 해제할 수 있습니다.

---
#### **10.2.1.  Delegation Recovery**

위임 복구에서 처리해야 하는 세 가지 상황은 다음과 같습니다.

o 클라이언트 재부팅 또는 다시 시작

```text
   o  Server reboot or restart (see Section 9.6.3.1)

   o  Network partition (full or callback-only)
```

클라이언트가 재부팅되거나 다시 시작되는 경우 새 verifier4 값을 사용하여 nfs\_client\_id4로 수행된 SETCLIENTID 확인으로 인해 바이트 범위 잠금 및 공유 예약이 해제됩니다. 그러나 위임은 약간 다르게 처리될 수 있습니다.

클라이언트가 재부팅되거나 다시 시작된 후 위임을 다시 설정해야 하는 상황이 있습니다. 그 이유는 클라이언트가 로컬에 저장된 파일 데이터를 가지고 있을 수 있고 이 데이터가 이전에 보유한 위임과 연관되어 있기 때문입니다. 클라이언트는 서버에서 적절한 파일 상태를 다시 설정해야 합니다.

이러한 유형의 클라이언트 복구를 허용하기 위해 서버는 다른 종류의 잠금이 해제된 후에도 위임이 유지되도록 허용할 수 있습니다. 이는 이러한 위임과 충돌하는 다른 클라이언트의 요청이 기다려야 함을 의미합니다. 정상적인 회상이기 때문에\(MAY\)

클라이언트가 변경된 상태를 서버에 플러시하는 데 상당한 시간이 필요할 수 있으므로 다른 클라이언트는 위임 충돌로 인해 발생하는 지연에 대비해야 합니다. 클라이언트가 재부팅 프로세스를 완료할 수 있는 기회를 제공하기 위해\(이 기간 동안에는 임대가 갱신되지 않습니다\) 서버는 일반적인 임대 만료 기간을 넘어 위임 복구 기간을 연장할 수 있습니다. 공개 위임의 경우 해제되지 않은 위임은 클레임 유형 CLAIM\_DELEGATE\_PREV와 함께 OPEN을 사용하여 회수됩니다. \(공개 위임 및 OPEN 세부 사항에 대한 논의는 각각 섹션 10.5 및 16.16을 참조하십시오.\)\(MAY\)

서버는 CLAIM\_DELEGATE\_PREV의 클레임 유형을 지원할 수 있지만, 지원하는 경우 SETCLIENTID\_CONFIRM 시 위임을 제거해서는 안 되며 대신 CLAIM\_DELEGATE\_PREV를 사용하여 클라이언트 회수에 사용할 수 있도록 해야 합니다. 서버는 클라이언트가 DELEGPURGE를 수행하거나 SETCLIENTID\_CONFIRM 또는 마지막 성공적인 CLAIM\_DELEGATE\_PREV 회수 시간 중 더 늦은 시간부터 하나의 임대 기간이 경과할 때까지 위임을 제거해서는 안 됩니다.\(MUST NOT, MUST NOT\)

위에 명시된 요구 사항은 위에서 요구한 대로 서버가 더 이상 위임 정보를 보관할 의무가 없을 때 반드시 해당 정보를 폐기해야 함을 의미하는 것은 아닙니다. 몇 가지 구체적인 사례는 다음과 같습니다.

o DELEGPURGE 발생으로 기간이 종료되는 경우, 회수되지 않은 위임을 삭제하는 것이 적절하고 바람직합니다.

o 성공적인 CLAIM\_DELEGATE\_PREV 회수 없이 임대 기간이 경과하여 기간이 종료되고 해당 상황이 네트워크 분할\(즉, 임대 만료 발생\)의 결과로 나타나는 경우 서버의 임대 만료 접근 방식\(예의 사용 포함 가능\) 잠금은 일반적으로 회수되지 않은 위임을 보존하기 위해 제공됩니다. 임대 취소가 발생하는 경우에도 네트워크 파티션 복구의 일부로 CLAIM\_DELEGATE\_PREV를 사용하여 이러한 위임을 회수해야 합니다.

o 비통신 기간 후에 클라이언트를 재부팅하는 경우 클라이언트 재부팅 복구의 일부로 CLAIM\_DELEGATE\_PREV를 사용하여 회수되지 않은 위임도 회수할 수 있어야 합니다.

o 성공적인 CLAIM\_DELEGATE\_PREV 회수 없이 임대 기간이 경과하여 기간이 종료되고 임대 갱신이 발생하는 경우 서버는 회수되지 않은 위임이 포기되었다고 결론을 내릴 수 있으며 묵시적인 DELEGPURGE를 가정해야 하는 상황으로 간주할 수 있습니다.

CLAIM\_DELEGATE\_PREV 클레임 유형을 지원하는 서버는 DELEGPURGE 작업을 지원해야 하며, 마찬가지로 DELEGPURGE를 지원하는 서버는 CLAIM\_DELEGATE\_PREV를 지원해야 합니다. CLAIM\_DELEGATE\_PREV를 지원하지 않는 서버는 클라이언트가 해당 기능을 사용하려고 시도하거나 DELEGPURGE 작업을 수행하는 경우 NFS4ERR\_NOTSUPP를 반환해야 합니다.\(MUST, MUST\)

CLAIM\_DELEGATE\_PREV 클레임 유형에 대한 지원은 클라이언트가 다시 시작되는 동안에도 클라이언트에서 영구 저장소를 사용하여 클라이언트가 쓴 데이터를 저장할 수 있다는 점에서 "클라이언트 영구 위임" 제공이라고도 합니다. 아래에 설명된 선택적 예외를 제외하고 이 기능을 사용하려면 클라이언트에서 영구 저장소를 사용해야 하며 서버의 영구 저장소 요구 사항을 추가하지 않는다는 점에 유의해야 합니다.

클라이언트 지속 위임에 대해 생각하는 한 가지 좋은 방법은 대부분의 경우 클라이언트가 다시 시작되는 동안 유지될 수 있도록 특별한 의미 조정을 통해 "예의 잠금"처럼 작동한다는 것입니다. 이로 인해 다른 모든 종류의 잠금이 해제됩니다. . 이러한 잠금은 일반적으로 서버를 다시 시작해도 유지되지 않습니다. 한 가지 예외는 클라이언트와 서버에 동시 오류가 발생하는 경우이며 아래에서 설명합니다.

서버가 DELEGPURGE에 NFS\_OK를 반환하여 CLAIM\_DELEGATE\_PREV 지원을 암시적으로 표시하면 쓰기 위임이 있는 클라이언트는 서버에 기록할 데이터에 대해 쓰기 저장 캐싱을 사용하여 위임이 회수될 때까지 쓰기 저장을 연기할 수 있습니다. , 아마도 클라이언트가 다시 시작된 후에 가능합니다. 마찬가지로, 서버가 CLAIM\_DELEGATE\_PREV 지원을 표시하면 읽기 위임이 있는 클라이언트와 해당 위임에 대한 쓰기 개방 하위 클라이언트는 클라이언트가 다시 시작된 후 특정 검증 없이 지속적으로 캐시된 파일 복사본의 무결성을 확신할 수 있습니다. 속성을 변경합니다.

서버가 재부팅되거나 다시 시작되면 바이트 범위 잠금 및 공유 예약과 유사한 방식으로 위임이 회수됩니다\(CLAIM\_PREVIOUS와 함께 OPEN 작업 사용\). 그러나 의미상 약간의 차이가 있습니다. 일반적인 경우 서버는 위임을 허용하지 않아야 한다고 결정하면 위임을 허용하지 않고 요청된 작업\(예: OPEN\)을 수행합니다. 회수의 경우 서버는 위임을 승인하지만 클라이언트는 위임이 승인되었지만 서버에 의해 회수된 것으로 처리하도록 특별한 지정이 적용됩니다. 이로 인해 고객은 다음과 같은 의무를 집니다.

수정된 모든 상태를 서버에 쓴 다음 위임을 반환합니다. 위임 회수를 처리하는 이 프로세스는 NFSv4 프로토콜의 세 가지 원칙을 조화시킵니다.

o 회수 시 이전 서버 인스턴스에 의해 할당된 리소스를 요청하는 클라이언트에는 해당 리소스를 부여해야 합니다.

o 서버는 위임이 승인되어야 하는지 여부와 일단 승인되면 위임이 계속되어야 하는지 여부를 결정할 수 있는 의심할 여지 없는 권한을 가지고 있습니다.

o 클라이언트가 콜백을 수신할 수 있는 능력이 입증될 때까지 콜백 사용에 의존해서는 안 됩니다.

클라이언트에 위임과 관련된 열기가 두 개 이상 있는 경우 CLAIM\_DELEGATE\_CUR 유형의 OPEN 작업을 사용하여 추가 열기에 대한 상태를 설정할 수 있습니다. 이것이 회수된 위임과 관련된 열기를 설정하는 데 사용되는 경우 서버는 유예 기간 내에 이를 허용해야 합니다.\(MUST\)

클라이언트와 서버가 동시에 다시 시작되지 않고 일련의 클라이언트와 서버가 다시 시작되는 상황은 CLAIM\_DELEGATE\_PREV 및 CLAIM\_PREVIOUS 회수 주기의 조합을 통해 처리됩니다. 영구 저장소는 클라이언트에만 필요합니다. 각 서버 오류에 대해 CLAIM\_PREVIOUS 회수 주기가 수행되고, 각 클라이언트가 다시 시작될 때마다 CLAIM\_DELEGATE\_PREV 회수 주기가 수행됩니다.

클라이언트와 서버의 동시 실패 가능성\(예: 데이터 센터 정전\)을 처리하기 위해 서버는 다시 시작하는 클라이언트로부터 수신하는 CLAIM\_DELEGATE\_PREV 회수 요청에 응답할 수 있도록 위임 정보를 지속적으로 저장할 수 있습니다. 이는 서버를 다시 시작해도 영구 위임 상태가 유지될 수 있는 한 가지 경우입니다. 서버는 이 정보를 저장할 필요가 없지만, 그렇게 하는 경우 쓰기 위임과 읽기 위임에 대해 그렇게 해야 합니다. 보류 기간 동안\(여러 클라이언트 및/또는 서버 인스턴스에 걸쳐\) 일부 공개 쓰기는 위임의 일부로 수행되었습니다. 이러한 정보를 지속적으로 기록할 공간이 제한되어 있는 경우 서버는 영구 저장 기록 없이 활성 상태를 유지하는 것보다 우선적으로 이 클래스의 위임을 회수해야 합니다.\(MAY\)

네트워크 분할이 발생하면 임대 갱신 기간이 만료되면 서버에서 위임을 해제할 수 있습니다. 이는 잠금 및 공유 예약의 동작과 유사하며 잠금 및 공유 예약의 경우 충돌하는 잠금 요청이 없을 때 잠금이 해제되지 않는 "예의 잠금"에 대한 지원으로 수정될 수 있습니다. 잠금 및 공유 예약의 경우 잠금 해제는 충돌이 발생하는 즉시 발생합니다.

요청의 경우, 서버는 충돌하는 요청이 보류되는 기간을 설정할 수 있습니다. 결국 다른 클라이언트로부터 충돌하는 요청이 발생하면 위임이 취소됩니다.\(MAY\)

콜백 경로가 손실되면\(예: 이후 네트워크 구성 변경으로 인해\) 위임이 취소될 수도 있다는 점에서 비슷한 효과가 있습니다. 회수 요청이 실패하고 위임이 취소됩니다.

클라이언트는 일반적으로 위임과 관련된 stateid를 사용하고 NFS4ERR\_EXPIRED, NFS4ERR\_BAD\_STATEID 또는 NFS4ERR\_ADMIN\_REVOKED 오류 중 하나를 수신할 때 위임 취소에 대해 알아냅니다\(NFS4ERR\_EXPIRED는 클라이언트와 관련된 모든 잠금 상태가 손실되었음을 나타냅니다\). 또한 클라이언트 재부팅 후 위임 회수를 시도하고 NFS4ERR\_EXPIRED를 수신하면 위임 취소에 대해 알아낼 수도 있습니다. 취소된 OPEN\_DELEGATE\_WRITE 위임의 경우 위임이 취소된 클라이언트와 별도로 다른 클라이언트에 의해 데이터가 수정되었을 수 있으므로 문제가 있습니다. 그러한 문제에 대한 논의는 섹션 10.5.1을 참조하십시오. 또한 위임이 취소되면 취소된 위임에 대한 정보가 서버에 의해 안정적인 저장소에 기록됩니다\(섹션 9.6에 설명됨\). 이는 위임을 취소한 후 취소된 위임을 보유한 클라이언트에 취소 사실이 통보되기 전에 서버가 재부팅되는 경우를 처리하기 위해 수행됩니다.

임대와 관련된 모든 잠금이 손실된 네트워크 파티션으로 인해 위임이 손실되면 클라이언트에도 NFS4ERR\_EXPIRED 오류가 표시됩니다. 이 경우에는 연결된 클라이언트 ID가 무효화되어 사용 시 NFS4ERR\_STALE\_CLIENTID가 반환된다는 점에서 위임이 취소되는 다른 상황과 구별할 수 있습니다.

NFS4ERR\_EXPIRED가 반환되면 서버는 클라이언트가 보유한 위임에 대한 정보를 유지하고 충돌하는 요청으로 인해 무효화된 정보를 삭제할 수 있습니다. 이러한 정보를 유지하면 클라이언트는 SETCLIENTID\_CONFIRM 복구가 완료된 후 클레임 유형 CLAIM\_DELEGATE\_PREV를 사용하여 무효화되지 않은 모든 위임을 복구할 수 있습니다. 일반적으로 요청 충돌로 인해 무효화되었기 때문에 클라이언트에 기록이 없는 위임 복구를 시도하면 NFS4ERR\_BAD\_RECLAIM 오류가 발생합니다. 클라이언트가 보유한 모든 위임에 대해 회수가 시도되면 DELEGPURGE를 수행하여 나머지 서버 위임 정보가 해제되도록 허용해야 합니다.\(MAY, SHOULD\)

---
### **10.3.  Data Caching**

응용 프로그램이 파일 집합에 대한 액세스를 공유하는 경우 다른 응용 프로그램의 액세스 충돌 가능성을 고려하여 구현해야 합니다. 이는 문제의 응용 프로그램이 다른 클라이언트에서 실행되거나 동일한 클라이언트에 상주하는지 여부에 관계없이 적용됩니다.

공유 예약 및 바이트 범위 잠금은 상호 배제 기능을 제공하여 애플리케이션이 액세스를 조정할 수 있도록 NFSv4 프로토콜에서 제공하는 기능입니다. NFSv4 프로토콜의 데이터 캐싱은 이러한 기능을 사용하는 사람들이 의존하는 가정을 무효화하지 않도록 구현되어야 합니다.

---
#### **10.3.1.  Data Caching and OPENs**

애플리케이션이 의존하는 공유 가정이 무효화되는 것을 방지하기 위해 NFSv4 클라이언트는 READ 또는 WRITE 작업을 통해 동일한 데이터를 얻거나 수정하는 것이 유효하지 않은 경우 캐시된 데이터를 애플리케이션에 제공하거나 애플리케이션을 대신하여 수정해서는 안 됩니다.

또한 공개 위임이 없는 경우\(섹션 10.4 참조\) 두 가지 추가 규칙이 적용됩니다. 이러한 규칙은 실제로 많은 NFSv2 및 NFSv3 클라이언트에서 준수됩니다.

o 먼저 OPEN을 수행한 후 클라이언트에 있는 캐시된 데이터를 다시 검증해야 합니다. 재검증이란 클라이언트가 서버에서 변경 속성을 가져와 캐시된 변경 속성과 비교하고, 다를 경우 캐시된 데이터\(및 캐시된 속성\)를 유효하지 않은 것으로 선언하는 것을 의미합니다. 이는 OPEN된 파일의 데이터가 여전히 클라이언트 캐시에 올바르게 반영되도록 하기 위한 것입니다. 이 유효성 검사는 최소한 클라이언트의 OPEN 작업에 DENY=WRITE 또는 BOTH가 포함되어 다른 클라이언트가 WRITE 액세스로 파일을 열 수 있는 기간이 종료될 때 수행되어야 합니다. 클라이언트는 이 수준의 캐시 재검증을 가정하는 사용자의 이익을 위해 NFSv3 프로토콜의 실행과 병행하기 위해 재검증을 더 자주\(예: DENY=NONE을 지정하는 OPEN에서\) 수행하도록 선택할 수 있습니다.

- 데이터 및 메타데이터 수정을 위해 변경 속성이 업데이트되므로 일부 클라이언트 구현자는 캐시된 데이터를 검증하기 위해 변경 속성이 아닌 time\_modify 속성을 사용하여 메타데이터 변경이 순수 데이터를 허위로 무효화하지 않도록 유혹을 받을 수 있습니다. 구현자는 이 접근 방식에 대해 주의를 기울여야 합니다. 변경 속성은 파일이 업데이트될 때마다 변경되도록 보장되는 반면, time\_modify는 업데이트 시에만 변경되도록 보장됩니다.

- time\_delta 속성의 세분성. 변경 속성이 아닌 클라이언트의 데이터 캐시 유효성 검사 로직인 time\_modify를 사용하면 클라이언트가 오래된 데이터를 유효한 것으로 잘못 표시할 위험이 있습니다.

o 둘째, 수정된 데이터는 쓰기 위해 열린 파일을 닫기 전에 서버로 플러시되어야 합니다. 이는 첫 번째 규칙을 보완합니다. CLOSE 시 데이터가 플러시되지 않으면 클라이언트가 파일을 OPEN한 후 수행된 유효성 재검사는 해당 목적을 달성할 수 없습니다. 닫기 전에 데이터를 플러시하는 또 다른 측면은 클라이언트가 CLOSE 작업을 요청하기 전에 데이터를 서버의 안정적인 저장소에 커밋해야 한다는 것입니다. 서버를 재부팅하거나 다시 시작하고 CLOSE된 파일의 경우 파일에 기록할 데이터를 재전송하지 못할 수 있으므로 이러한 요구 사항이 적용됩니다.

---
#### **10.3.2.  Data Caching and File Locking**

일관되지 않은 파일 액세스를 제외하기 위해 공유 예약 대신 파일 잠금을 사용하도록 선택한 응용 프로그램의 경우 클라이언트 측 데이터 캐싱에 적용되는 유사한 제약 조건 집합이 있습니다. 이러한 규칙은 실행된 실제 READ 및 WRITE 작업과 동일한 방식으로 파일 잠금이 사용되는 경우에만 유효합니다. 이는 순수한 규칙을 기반으로 하는 파일 잠금과 반대됩니다. 예를 들어, 파일을 두 개의 1MB 영역으로 나누고 바이트 0과 1에 대한 파일 잠금을 통해 두 영역에 대한 액세스를 보호함으로써 2MB 파일을 조작할 수 있습니다. 파일의 0바이트 쓰기에 대한 잠금은 첫 번째 영역에서 읽기 및 쓰기 작업을 수행할 수 있는 권한을 나타냅니다. 파일의 첫 번째 바이트에 대한 쓰기 잠금은 두 번째 영역에서 읽기 및 쓰기 작업을 수행할 수 있는 권한을 나타냅니다. 파일을 조작하는 모든 응용 프로그램이 이 규칙을 준수하는 한 로컬 파일 시스템에서 작동합니다. 그러나 클라이언트가 데이터 캐싱을 삼가하지 않는 한 NFSv4 프로토콜에서는 작동하지 않을 수 있습니다.

파일 잠금 환경의 데이터 캐싱 규칙은 다음과 같습니다.

o 먼저 클라이언트가 특정 지역에 대한 파일 잠금을 획득하면 해당 지역에 해당하는 데이터 캐시\(캐시된 데이터가 있는 경우\)를 재검증해야 합니다. 변경 속성이 캐시된 데이터를 얻은 이후 파일이 업데이트되었을 수 있음을 나타내는 경우 클라이언트는 새로 잠긴 영역에 대해 캐시된 데이터를 플러시하거나 무효화해야 합니다. 클라이언트는 파일에 대해 가지고 있는 수정되지 않은 캐시된 데이터를 모두 무효화하도록 선택할 수 있지만 올바른 작업을 위한 유일한 요구 사항은 새로 잠긴 영역의 모든 데이터를 무효화하는 것입니다.

o 둘째, 지역에 대한 쓰기 잠금을 해제하기 전에 해당 지역에 대해 수정된 모든 데이터를 서버로 플러시해야 합니다. 수정된 데이터는 안정적인 저장소에도 기록되어야 합니다.

데이터를 서버로 플러시하고 캐시된 데이터를 무효화하려면 잠기거나 잠금 해제된 실제 바이트 범위가 반영되어야 합니다. 클라이언트 캐시 블록 경계를 반영하기 위해 이를 반올림하거나 내림하면 주의 깊게 수행하지 않으면 문제가 발생할 수 있습니다. 예를 들어, 해당 블록의 절반만 잠금 해제된 영역 내에 있을 때 수정된 블록을 쓰면 잠금 해제된 영역 외부 영역에 잘못된 수정이 발생할 수 있습니다. 이는 결국 다른 클라이언트에 의해 잠긴 지역의 일부일 수 있습니다. 클라이언트는 전체 블록이 아닌 부분\(초기 또는 최종\)과 겹치는 WRITE 작업 부분을 동기적으로 수행하여 이러한 상황을 피할 수 있습니다. 마찬가지로, 전체 버퍼 블록의 정수수가 아닌 잠긴 영역을 무효화하려면 클라이언트가 소유한 데이터가 유효하지 않을 수 있다는 재검증 절차를 통해 클라이언트가 서버에서 하나 또는 두 개의 부분 블록을 읽어야 합니다.

지역 잠금 해제의 전제 조건으로 서버에 기록되는 데이터는 서버에서 안정적인 저장소에 기록되어야 합니다. 클라이언트는 동기 쓰기를 사용하거나 COMMIT 작업을 통한 비동기 쓰기를 수행하여 이를 수행할 수 있습니다. 이는 서버 재부팅 후 수정된 데이터를 재전송하면 다른 클라이언트가 보유한 잠금과 충돌할 수 있기 때문에 필요합니다.

클라이언트 구현은 LOCKU 시 잠긴 범위에 포함된 것보다 더 많은 데이터를 서버에 플러시하여 비표준 방식\(예: 바이트 범위 잠금을 전역 세마포로 사용\)으로 바이트 범위 잠금을 사용하는 애플리케이션을 수용하도록 선택할 수 있습니다. . 여기에는 잠금 해제가 수행되는 파일이 아닌 다른 파일 내의 수정된 데이터가 포함될 수 있습니다. 이러한 경우 클라이언트는 애플리케이션이 보유한 레코드 잠금 범위 내에서만 읽기 및 쓰기가 수행되는 애플리케이션을 방해해서는 안 됩니다. 예를 들어, 애플리케이션은 파일의 단일 바이트를 잠그고 계속해서 해당 단일 바이트를 씁니다. 수정된 모든 데이터를 서버에 플러시하여 LOCKU를 처리하기로 선택한 클라이언트는 관련 없는 잠금 해제에 대한 응답으로 해당 단일 바이트를 유효하게 쓸 수 있습니다. 그러나 기록된 단일 바이트가 위치한 전체 블록을 기록하는 것은 유효하지 않습니다. 왜냐하면 여기에는 잠겨 있지 않고 다른 클라이언트에 의해 잠겨 있을 수 있는 영역이 포함되어 있기 때문입니다. 클라이언트 구현은 수정된 데이터가 있는 파일을 적절한 바이트 범위 잠금이 적용되는 영역에 대해 모든 수정이 수행되는 파일과 바이트 범위 잠금이 적용되지 않는 수정이 있는 파일로 나누어 이 문제를 피할 수 있습니다. 이전 파일 클래스에 대해 수행된 모든 쓰기에는 잠기지 않아 클라이언트에서 수정되지 않은 영역이 포함되어서는 안 됩니다.

---
#### **10.3.3.  Data Caching and Mandatory File Locking**

클라이언트 측 데이터 캐싱은 실행 중인 경우 필수 파일 잠금을 준수해야 합니다. 지정된 파일에 대한 필수 파일 잠금이 있음은 클라이언트가 적절한 공유 예약이 있는 파일에 대한 READ 또는 WRITE에서 NFS4ERR\_LOCKED를 다시 얻을 때 표시됩니다. 파일에 필수 잠금이 적용되면 클라이언트는 읽거나 쓰는 데이터에 대해 적절한 파일 잠금이 있는지 확인해야 합니다. 읽거나 쓰는 범위에 대한 잠금이 존재하는 경우 클라이언트는 클라이언트의 검증된 캐시를 사용하여 요청을 충족할 수 있습니다. READ 또는 WRITE 범위에 대해 적절한 파일 잠금이 유지되지 않는 경우 READ 또는 WRITE 요청은 클라이언트의 캐시에 의해 충족되지 않아야 하며 요청은 처리를 위해 서버로 전송되어야 합니다. READ 또는 WRITE 요청이 잠긴 영역과 부분적으로 겹치는 경우 요청은 각 영역\(잠금 여부와 관계없이\)이 적절하게 처리되는 여러 조각으로 나누어야 합니다.

---
#### **10.3.4.  Data Caching and File Identity**

클라이언트가 데이터를 캐시할 때 파일 데이터는 해당 데이터가 속한 파일 시스템 개체에 따라 구성되어야 합니다. NFSv3 클라이언트의 경우 캐싱을 위해 고유한 파일 핸들이 고유한 파일 시스템 개체를 나타낸다고 가정하는 것이 일반적인 관행이었습니다. 그러면 클라이언트는 이를 기반으로 데이터 캐시를 구성하고 유지 관리할 수 있습니다.

NFSv4 프로토콜에서는 파일 핸들이 객체의 경로 이름을 기반으로 구성될 수 있기 때문에 이제 "객체당 하나의 파일 핸들" 모델에서 크게 벗어날 가능성이 있습니다. 따라서 클라이언트에는 두 개의 파일 핸들이 동일한 파일 시스템 개체를 지정하는지 확인하는 안정적인 방법이 필요합니다. 클라이언트가 단순히 모든 고유한 파일 핸들이 고유한 개체를 나타낸다고 가정하고 이를 기반으로 데이터 캐싱을 진행하면 동일한 서버측 개체에 매핑된 고유한 클라이언트측 개체 간에 캐싱 불일치가 발생할 수 있습니다.

NFSv4 프로토콜은 파일 핸들을 구별하는 방법을 제공함으로써 NFSv3 프로토콜과 비교하여 잠재적인 기능 회귀를 완화합니다. 이 방법이 없으면 동일한 클라이언트 내에서 캐싱 불일치가 발생할 수 있으며 이는 이전 버전의 NFS 프로토콜에서는 발생하지 않았습니다. 여러 클라이언트에서 실행되는 응용 프로그램에서 이러한 불일치가 발생할 수 있지만 여기서는 해당 문제를 다루지 않습니다.

데이터 캐싱을 위해 다음 단계를 통해 NFSv4 클라이언트는 두 개의 서로 다른 파일 핸들이 동일한 서버 측 개체를 나타내는지 여부를 확인할 수 있습니다.

o 두 개의 파일 핸들로 지정된 GETATTR이 fsid 속성의 서로 다른 값을 반환하는 경우 파일 핸들은 고유한 개체를 나타냅니다.

o 문제의 두 파일 핸들의 fsid와 일치하는 fsid가 있는 파일에 대한 GETATTR이 값이 TRUE인 Unique\_handles 속성을 반환하는 경우 두 개체는 서로 다릅니다.

o 두 파일 핸들로 전달된 GETATTR이 두 핸들 모두에 대한 fileid 속성을 반환하지 않으면 두 개체가 동일한지 여부를 확인할 수 없습니다. 따라서 해당 지식\(예: 클라이언트 측 데이터 캐싱\)에 의존하는 작업을 안정적으로 수행할 수 없습니다. GETATTR이 두 파일 핸들 모두에 대해 fileid 속성을 반환하지 않는 경우 두 파일 핸들의 fsid가 동일하므로 두 파일 핸들 중 어느 쪽에도 해당 속성을 반환하지 않습니다.

o 두 개의 파일 핸들로 전달된 GETATTR이 fileid 속성에 대해 서로 다른 값을 반환하는 경우 해당 두 파일 핸들은 별개의 개체입니다.

o 그렇지 않으면 동일한 객체입니다.

---
### **10.4.  Open Delegation**

파일이 열려 있는 동안 서버는 해당 파일에 대한 열기 및 닫기의 추가 처리를 열기 클라이언트에 위임할 수 있습니다. 위임이 허용된 상황은 변경될 수 있으므로 그러한 위임은 모두 취소 가능합니다. 특히, 서버는 다른 클라이언트로부터 충돌하는 OPEN을 수신할 수 있습니다. 서버는 다른 클라이언트의 OPEN이 허용되는지 여부를 결정하기 전에 위임을 회수해야 합니다. 위임을 하는 것은 서버에 달려 있으며 클라이언트는 특정 OPEN이 공개 위임으로 이어질지 여부를 가정해서는 안 됩니다. 다음은 OPEN을 위임해야 하는지 여부를 결정할 때 서버가 사용할 수 있는 일반적인 조건 집합입니다.

o 클라이언트는 서버의 콜백 요청에 응답할 수 있어야 합니다. 서버는 콜백 기능 테스트를 위해 CB\_NULL 프로시저를 사용합니다.

o 고객은 이전 회상에 적절하게 응답해야 합니다.

o 요청된 위임과 충돌하는 현재 공개 상태가 없어야 합니다.

o 요청된 위임과 충돌하는 현재 위임이 없어야 합니다.

o 파일의 최근 기록을 기준으로 향후 열기 요청이 충돌할 확률은 낮아야 합니다.

o 필요한 처리가 위임된 클라이언트가 적용할 규정된 처리와 호환되지 않게 만드는 OPEN/CLOSE의 서버별 의미 체계가 존재합니다\(아래 참조\).

공개 위임에는 OPEN\_DELEGATE\_READ와 OPEN\_DELEGATE\_WRITE의 두 가지 유형이 있습니다. OPEN\_DELEGATE\_READ 위임을 사용하면 클라이언트가 다른 사람의 읽기 액세스를 거부하지 않는 읽기용 파일 열기 요청을 자체적으로 처리할 수 있습니다. 그러나 서버에 쓰기 위해 파일을 열기 위한 모든 요청을 계속해서 보내야 합니다. 여러 OPEN\_DELEGATE\_READ 위임이 동시에 처리될 수 있으며 충돌하지 않습니다. OPEN\_DELEGATE\_WRITE 위임을 사용하면 클라이언트가 모든 열기를 자체적으로 처리할 수 있습니다. 특정 시간에 특정 파일에 대해 하나의 OPEN\_DELEGATE\_WRITE 위임만 존재할 수 있으며 이는 OPEN\_DELEGATE\_READ 위임과 일치하지 않습니다.\(MUST\)

단일 클라이언트가 OPEN\_DELEGATE\_READ 위임을 보유하면 다른 클라이언트가 파일의 내용이나 속성을 수정할 수 없다는 것이 보장됩니다. 둘 이상의 클라이언트가 OPEN\_DELEGATE\_READ 위임을 보유한 경우 해당 파일의 내용과 속성을 변경할 수 없습니다. 클라이언트에 OPEN\_DELEGATE\_WRITE 위임이 있으면 다른 클라이언트가 파일 데이터에 액세스하지 않으므로 파일 데이터를 수정할 수 있습니다. OPEN\_DELEGATE\_WRITE 위임을 보유하는 클라이언트는 파일 데이터와 밀접하게 연결된 파일 속성\(크기, time\_modify 및 변경\)에만 영향을 미칠 수 있습니다.

클라이언트에 공개 위임이 있는 경우 OPEN 또는 CLOSE를 서버에 보내지 않고 내부적으로 적절한 상태를 업데이트합니다. OPEN\_DELEGATE\_READ 위임의 경우 로컬로 처리할 수 없는 열기\(쓰기를 위해 열거나 읽기 액세스를 거부하는 열기\)를 서버로 보내야 합니다.

공개 위임이 이루어지면 OPEN에 대한 응답에는 다음을 지정하는 공개 위임 구조가 포함됩니다.

```text
   o  the type of delegation (read or write)

   o  space limitation information to control flushing of data on close
      (OPEN_DELEGATE_WRITE delegation only; see Section 10.4.1)
```

o 읽기 및 쓰기 권한을 지정하는 nfsace4

o READ 및 WRITE 위임을 나타내는 stateid

위임 stateid는 OPEN 고유의 stateid와는 별개입니다. 위임 stateid와 달리 표준 stateid는 특정 공개 소유자와 연결되어 있으며 위임이 회수되고 파일이 열린 상태로 유지된 후에도 계속 유효합니다.

클라이언트 내부에서 파일 열기 요청이 이루어지고 공개 위임이 유효한 경우 다음 조건에 따라서만 수락 또는 거부됩니다. 대리인이 다른 검사를 수행해야 한다는 요구 사항이 있으면 공개 위임이 거부되어 서버 자체에서 검사를 수행할 수 있어야 합니다.

o 요청 및 파일에 대한 액세스 및 거부 비트

- 섹션 9.9에 설명되어 있습니다.

o 아래에 결정된 읽기 및 쓰기 권한.

위임과 함께 전달된 nfsace4를 사용하면 빈번한 ACCESS 호출을 피할 수 있습니다. 권한 확인은 다음과 같아야 합니다.

o nfsace4가 열기가 완료될 수 있음을 나타내는 경우 서버를 참조하지 않고 승인되어야 합니다.

o nfsace4가 열기가 수행되지 않을 수 있음을 나타내는 경우 최종 응답을 얻기 위해 ACCESS 요청을 서버로 보내야 합니다.

서버는 파일의 실제 ACL보다 더 제한적인 nfsace4를 반환할 수 있습니다. 여기에는 모든 액세스 거부를 지정하는 nfsace4가 포함됩니다. 기존 사용자 "root"를 사용자 "nobody"로 매핑하는 것과 같은 일부 일반적인 관행으로 인해 위임 응답에서 파일의 실제 ACL을 반환하는 것이 잘못될 수 있습니다.

다양한 다른 형태의 캐싱과 함께 위임을 사용하면 사용자의 모든 요청이 로컬에서 충족될 수 있으므로 특정 사용자에 대해 서버 인증이 수행되지 않을 가능성이 생깁니다. 클라이언트가 인증을 위해 서버에 의존하는 경우 클라이언트는 ACCESS 작업을 사용하여 각 사용자에 대해 인증이 발생하는지 확인해야 합니다. 그렇지 않으면 ACCESS 작업이 필요하지 않은 경우에도 마찬가지입니다. 앞에서 언급했듯이 서버는 공개 위임이 있을 때마다 모든 액세스를 거부하는 nfsace4를 반환하여 빈번한 인증을 시행할 수 있습니다.

---
#### **10.4.1.  Open Delegation and Data Caching**

OPEN 위임을 사용하면 파일 열기 및 닫기와 관련된 메시지 오버헤드의 대부분을 제거할 수 있습니다. 공개 위임이 적용될 때 열기에서는 요청된 공유 모드와 충돌할 가능성이 없는 한 서버에 유효성 검사 메시지를 보낼 필요가 없습니다. "OPEN\_DELEGATE\_READ 위임"의 지속적인 지속성은 쓰기를 위한 OPEN이 없음을 보장하므로 이 클라이언트에서 발생하지 않은 쓰기가 발생하지 않습니다. 마찬가지로 쓰기 위해 열린 파일을 닫을 때 OPEN\_DELEGATE\_WRITE 위임이 적용되는 경우 열린 위임이 회수될 때까지 기록된 데이터를 서버로 플러시할 필요가 없습니다. 공개 위임이 계속 지속되면 다른 클라이언트가 열거나 읽거나 쓸 수 없다는 것을 보장할 수 있습니다.

공개 위임의 목적을 위해 OPEN\(익명 및 READ 바이패스 상태 ID\) 없이 수행된 읽기 및 쓰기는 해당 유형의 OPEN과 기능적으로 동등한 것으로 처리됩니다. 다른 클라이언트가 익명 상태 ID를 사용하여 수행한 읽기 및 쓰기는 서버가 OPEN\_DELEGATE\_WRITE 위임을 회수하도록 강제합니다. 다른 클라이언트가 수행한 익명 상태 ID를 사용한 쓰기는 OPEN\_DELEGATE\_READ 위임을 강제로 회수합니다. READ 우회 stateid를 사용한 READ가 OPEN\_DELEGATE\_READ 위임을 강제로 회수하지 않는다는 점을 제외하면 READ 우회 stateid 처리는 동일합니다.

위임을 사용하면 클라이언트는 파일 CLOSE가 서비스될 때 서버에 데이터를 쓰는 것을 피할 수 있습니다. 파일 닫기 시스템 호출은 애플리케이션에서 생성된 수정된 파일 데이터에 대한 안정적인 저장소가 부족하다는 알림을 클라이언트에 알리는 일반적인 지점입니다. 마지막에 파일 데이터가 서버에 기록되고 일반 계정을 통해 서버는 데이터에 사용 가능한 파일 시스템 공간이 초과되었는지 확인할 수 있습니다\(즉, 서버가 NFS4ERR\_NOSPC 또는 NFS4ERR\_DQUOT를 반환함\). 이 회계에는 할당량이 포함됩니다. 위임을 도입하려면 클라이언트와 서버 간에 동일한 유형의 통신이 발생하도록 대체 방법을 마련해야 합니다.

위임 응답에서 서버는 파일 크기 제한이나 수정된 ​​블록 수 및 관련 블록 크기를 제공합니다. 서버는 클라이언트가 원래 위임에 제공된 것과 동일한 크기의 데이터를 서버로 플러시할 수 있는지 확인해야 합니다. 서버는 모든 미결 위임에 대해 이러한 보증을 해야 합니다. 따라서 서버는 사용 가능한 파일 시스템 공간과 적용 가능한 할당량을 고려하여 새 데이터나 수정된 ​​데이터에 사용 가능한 공간을 주의 깊게 관리해야 합니다. 서버는 관리 결과에 따라 위임을 회수할 수 있습니다.

사용 가능한 파일 시스템 공간. 클라이언트는 위임을 위한 서버의 상태 공간 제한을 준수해야 합니다. 클라이언트가 위임에 대해 명시된 제한을 초과하는 경우 서버의 동작은 정의되지 않습니다.

서버 조건, 할당량 또는 사용 가능한 파일 시스템 공간에 따라 서버는 매우 제한적인 공간 제한을 통해 OPEN\_DELEGATE\_WRITE 위임을 부여할 수 있습니다. 수정된 데이터가 서버를 닫을 때 항상 강제로 플러시되는 방식으로 제한 사항을 정의할 수 있습니다.

인증과 관련하여 CLOSE가 발생한 후 수정된 데이터를 서버에 플러시하는 것은 문제가 될 수 있습니다. 예를 들어, 응용 프로그램 사용자가 클라이언트에서 로그오프했을 수 있으며 만료되지 않은 인증 자격 증명이 없을 수 있습니다. 이 경우 클라이언트는 만료되지 않은 로컬 자격 증명을 실제로 사용할 수 있도록 특별한 주의를 기울여야 할 수도 있습니다. 이를 달성할 수 있는 한 가지 방법은 자격 증명의 만료 시간을 추적하고 만료되기 훨씬 전에 데이터를 플러시하는 것입니다.

---
#### **10.4.2.  Open Delegation and File Locks**

클라이언트가 OPEN\_DELEGATE\_WRITE 위임을 보유하면 잠금 작업이 로컬로 수행될 수 있습니다. 여기에는 필수 파일 잠금에 필요한 항목이 포함됩니다. 위임은 충돌하는 잠금이 있을 수 없음을 암시하므로 이는 수행될 수 있습니다. 마찬가지로 일반적으로 잠금 획득 및 잠금 해제와 관련된 데이터 플러시와 관련된 모든 재검증을 수행할 필요가 없습니다.

클라이언트가 OPEN\_DELEGATE\_READ 위임을 보유하면 잠금 작업이 로컬로 수행되지 않습니다. 비독점 잠금 요청을 포함한 모든 잠금 작업은 해결을 위해 서버로 전송됩니다.

---
#### **10.4.3.  Handling of CB_GETATTR**

서버는 대상이 OPEN\_DELEGATE\_WRITE 위임이 유효한 파일인 GETATTR에 대해 특별한 처리를 사용해야 합니다. 그 이유는 OPEN\_DELEGATE\_WRITE 위임을 보유한 클라이언트가 데이터를 수정했을 수 있으며 서버는 이 변경 사항을 GETATTR을 제출한 두 번째 클라이언트에 반영해야 하기 때문입니다. 따라서 OPEN\_DELEGATE\_WRITE 위임을 보유한 클라이언트를 조사해야 합니다. 서버는 CB\_GETATTR 작업을 사용합니다. 서버가 CB\_GETATTR을 통해 안정적으로 쿼리할 수 있는 유일한 속성은 크기와 변경입니다.

CB\_GETATTR은 다른 클라이언트의 GETATTR 요청을 충족하는 데 사용되므로 서버는 위임을 보유한 클라이언트가 파일의 수정된 버전을 가지고 있는지만 알면 됩니다. 클라이언트의 위임된 파일 복사본이 수정되지 않은 경우\(데이터 또는 크기\) 서버는 서버에 로컬로 저장된 속성을 사용하여 두 번째 클라이언트의 GETATTR 요청을 충족할 수 있습니다. 파일이 수정되면 서버는 이 수정된 상태에 대해서만 알면 됩니다. 서버가 파일이 현재 수정되었다고 판단하면 파일이 서버에서 로컬로 수정된 것처럼 두 번째 클라이언트의 GETATTR에 응답합니다.

변경 속성의 형식은 서버에 의해 결정되고 클라이언트에게는 불투명하므로 클라이언트와 서버는 파일의 수정된 상태를 전달하는 방법에 동의해야 합니다. 크기 속성의 경우 클라이언트는 파일 크기의 현재 보기를 보고합니다. 변경 속성의 경우 처리가 더 복잡합니다.

클라이언트의 경우 OPEN\_DELEGATE\_WRITE 위임을 받으면 다음 단계가 수행됩니다.

o 변경 속성의 값은 서버에서 가져와 캐시됩니다. 이 값을 c로 표현하겠습니다.

o 클라이언트는 수정된 데이터가 클라이언트에 보관되어 있음을 전달하는 데 사용되는 c보다 큰 값을 생성합니다. 이 값을 d로 표현하겠습니다.

o 클라이언트가 CB\_GETATTR을 통해 변경 사항을 쿼리하는 경우

- 속성은 수정된 데이터를 보유하고 있는지 확인합니다. 파일이 수정되면 변경 속성 값으로 d 값이 반환됩니다. 이 파일이 현재 수정되지 않은 경우 클라이언트는 변경 속성에 대해 c 값을 반환합니다.

구현을 단순화하기 위해 클라이언트는 각 CB\_GETATTR에 대해 동일한 값 d를 반환할 수 있습니다. 이는 연속적인 CB\_GETATTR 작업 사이에 클라이언트가 캐시의 파일 데이터나 메타데이터를 다시 수정하는 경우에도 마찬가지입니다. 유일한 요구 사항은 클라이언트가 수정된 데이터를 보유하고 있음을 서버에 표시할 수 있어야 하기 때문에 클라이언트는 동일한 값을 반환할 수 있습니다. 따라서 d의 값은 항상 c + 1일 수 있습니다.\(MAY\)

서버가 변경 사항을 계산하는 시간 단위가 무엇인지 알 수 없다는 점에서 변경 속성은 클라이언트에게 불투명하지만, 클라이언트가 이를 부호 없는 정수로 처리해야 한다는 점에서는 불투명하지 않습니다. 서버는 해당 정수에 대한 클라이언트의 변경 결과를 볼 수 있어야 합니다. 따라서 서버는 변경 속성을 클라이언트에 보낼 때 네트워크 바이트 순서로 인코딩해야 합니다. 클라이언트는 이를 네트워크 바이트 순서에서 해당 순서로 디코딩해야 합니다.\(MUST, MUST\)

수신할 때는 기본 순서로 인코딩해야 하며, 클라이언트는 서버에 보낼 때 네트워크 바이트 순서로 인코딩해야 합니다. 이러한 이유로 변경 속성은 불투명한 바이트 배열이 아닌 부호 없는 정수로 정의됩니다.\(MUST\)

서버의 경우 OPEN\_DELEGATE\_WRITE 위임을 제공할 때 다음 단계가 수행됩니다.

o OPEN\_DELEGATE\_WRITE 위임을 제공하면 서버는 위임을 기록하는 데 사용하는 데이터 구조에 변경 속성의 복사본을 캐시합니다. 이 값을 sc로 표현하겠습니다.

o 두 번째 클라이언트가 동일한 파일에 대한 GETATTR 작업을 서버로 보내면 서버는 첫 번째 클라이언트로부터 변경 속성을 얻습니다. 이 값을 cc로 둡니다.

o cc 값이 sc와 같으면 파일은 수정되지 않으며 서버는 변경 사항, time\_metadata 및 time\_modify\(예:\)에 대한 현재 값을 두 번째 클라이언트에 반환합니다.

o cc 값이 sc와 같지 않으면 파일은 현재 첫 번째 클라이언트에서 수정되었으며 나중에 서버에서도 수정될 가능성이 높습니다. 그런 다음 서버는 현재 시간을 사용하여 time\_metadata 및 time\_modify에 대한 속성 값을 구성합니다. nsc라고 부르는 새로운 sc 값은 nsc \>= sc + 1과 같이 서버에 의해 계산됩니다. 그런 다음 서버는 구성된 time\_metadata, time\_modify 및 nsc 값을 요청자에게 반환합니다. 서버는 위임 레코드의 sc를 nsc로 바꿉니다. time\_modify, time\_metadata 및 변경 사항이 뒤로 이동하는 것처럼 보일 가능성을 방지하려면\(위임이 취소되거나 반환되기 전에 위임을 보유한 클라이언트가 수정된 데이터를 서버에 기록하지 못한 경우 발생\) 서버는 파일의 구성된 속성 값이 있는 메타데이터 레코드입니다. 합리적인 성능을 위해 구성된 속성 값을 안정적인 저장소에 커밋하는 것은 선택 사항입니다.\(SHOULD, MAY\)

이 섹션의 앞부분에서 설명한 것처럼 클라이언트는 후속 CB\_GETATTR 호출에서 동일한 cc 값을 반환할 수 있습니다. 이는 연속적인 CB\_GETATTR 호출 사이에 클라이언트 캐시에서 파일이 다시 수정된 경우에도 마찬가지입니다. 따라서 서버는 파일이 다시 수정되었다고 가정해야 하며 구성하고 반환하는 새 nsc가 반환한 이전 nsc보다 큰지 확인해야 합니다. 예제 구현의 위임 레코드는 위임이 승인될 때 FALSE로 설정되는 부울 필드\("수정"이라고 함\)와 변경 속성 값에 대한 승인 시 설정된 sc 값을 포함하여 이 명령을 충족합니다. 수정된 필드는 처음 cc != sc 및 TRUE로 설정됩니다.\(MAY, MUST\)

위임이 반환되거나 취소될 때까지 TRUE로 유지됩니다. nsc, time\_modify 및 time\_metadata 구성 처리에서는 다음 의사 코드를 사용합니다.

```text
       if (!modified) {
           do CB_GETATTR for change and size;

           if (cc != sc)
               modified = TRUE;
       } else {
           do CB_GETATTR for size;
       }

       if (modified) {
           sc = sc + 1;
           time_modify = time_metadata = current_time;
           update sc, time_modify, time_metadata into file's metadata;
       }
```

이는 클라이언트\(GETATTR을 보낸\)에게 요청한 속성을 반환하지만 크기는 CB\_GETATTR이 반환한 것에서 나오는지 확인합니다. 서버는 클라이언트가 수정한 크기로 파일의 메타데이터를 업데이트하지 않습니다.

파일 속성 크기가 서버의 현재 값과 다른 경우, 서버는 CB\_GETATTR을 통해 검색된 변경 속성 값과 관계없이 이를 수정으로 처리하고 마지막 단계와 마찬가지로 두 번째 클라이언트에 응답합니다.

이 방법론은 클라이언트와 서버 간의 클럭 차이 문제와 CB\_GETATTR 사용이 중단되는 기타 시나리오를 해결합니다.

서버는 CB\_GETATTR을 사용할 의무가 없습니다. 그러므로 서버는 위임의 사용을 피하기 위해 단순히 위임을 회수할 수도 있습니다.\(MAY\)

---
#### **10.4.4.  Recall of Open Delegation**

다음과 같은 경우에는 공개 위임을 회수해야 합니다.

```text
   o  Potentially conflicting OPEN request (or READ/WRITE done with
      "special" stateid)
```

o 다른 클라이언트가 발행한 SETATTR

o 파일에 대한 REMOVE 요청

o RENAME의 소스 또는 대상으로 파일에 대한 RENAME 요청

파일로 이어지는 경로에 있는 디렉터리의 RENAME으로 인해 공개 위임이 회수되는지 여부는 서버 파일 시스템의 의미에 따라 달라집니다. 파일이 열려 있을 때 해당 파일 시스템이 이러한 RENAME을 거부하는 경우 문제의 파일이 실제로 열려 있는지 확인하기 위해 호출을 수행해야 합니다.

위의 상황 외에도 서버는 자원 제약으로 인해 그렇게 하는 것이 바람직할 경우 언제든지 공개 위임을 회수하도록 선택할 수 있습니다. 고객은 항상 리콜 가능성에 대비해야 합니다.

클라이언트가 공개 위임에 대한 회수를 받으면 위임을 반환하기 전에 서버의 상태를 업데이트해야 합니다. 클라이언트가 자발적으로 위임을 반환하기로 선택할 때마다 이와 동일한 업데이트를 수행해야 합니다. 다음과 같은 상태 항목을 처리해야 합니다.

o 위임과 관련된 파일이 더 이상 열려 있지 않고 이전 CLOSE 작업이 서버로 전송되지 않은 경우 CLOSE 작업을 서버로 전송해야 합니다.

o 파일에 클라이언트에 다른 열린 참조가 있는 경우 OPEN 작업을 서버로 보내야 합니다. 위임 stateid가 더 이상 유효하지 않으므로 클라이언트가 나중에 사용할 수 있도록 서버에서 적절한 stateid를 제공합니다. 이러한 OPEN 요청은 CLAIM\_DELEGATE\_CUR의 클레임 유형으로 수행됩니다. 이를 통해 클라이언트가 OPEN을 수행하기 위한 적절한 권한을 설정할 수 있도록 위임 stateid를 표시할 수 있습니다. \(자세한 내용은 섹션 16.16을 참조하세요.\)

o 파일 잠금이 부여된 경우 해당 LOCK 작업을 수행해야 합니다. 이는 OPEN\_DELEGATE\_WRITE 위임 사례에만 적용됩니다.

o OPEN\_DELEGATE\_WRITE 위임의 경우 회수 시 파일이 쓰기용으로 열려 있지 않은 경우 파일에 대해 수정된 모든 데이터를 서버로 플러시해야 합니다. 위임이 존재하지 않았다면 클라이언트는 CLOSE 작업 전에 이 데이터 플러시를 수행했을 것입니다.

o OPEN\_DELEGATE\_WRITE 위임의 경우 회수 시점에 파일이 아직 열려 있으면 파일에 대해 수정된 데이터를 서버로 플러시해야 합니다.

o OPEN\_DELEGATE\_WRITE 위임이 적용되면 위임 기간 동안 파일이 잘릴 수 있습니다. 예를 들어, 크기 속성 값이 0인 OPEN UNCHECKED4의 결과로 잘림이 발생할 수 있습니다. 따라서 파일 잘림이 발생했지만 이 작업이 서버에 전파되지 않은 경우 수정된 데이터가 서버에 기록되기 전에 잘림이 발생해야 합니다.

OPEN\_DELEGATE\_WRITE 위임의 경우 파일 잠금에는 몇 가지 추가 요구 사항이 적용됩니다. 연관된 불변성을 정확하게 유지하려면 OPEN\_DELEGATE\_WRITE 위임이 유효한 동안 쓰기 잠금이 해제된 모든 영역에서 수정된 데이터를 플러시해야 합니다. 그러나 OPEN\_DELEGATE\_WRITE 위임은 다른 클라이언트에 의한 다른 잠금을 의미하지 않기 때문에 OPEN\_DELEGATE\_WRITE 위임이 적용되는 동안 쓰기 잠금이 해제된 경우 파일에 대해 수정된 모든 데이터를 플러시하는 것이 더 간단한 구현입니다\(위에서 설명한 대로\).

구현 고려 사항\(예: 리소스 가용성 제약\)으로 인해 위의 작업을 수행하는 것이 바람직할 경우 구현에서는 위임이 회수될 때까지\(또는 위임을 자발적으로 반환하기로 결정할 때까지\) 기다릴 필요가 없습니다. 그러나 일반적으로 파일의 실제 열린 상태가 계속 변경될 수 있다는 사실로 인해 위임 반환의 일부를 제외하고 열기 및 닫기에 대한 정보를 서버에 보내는 것은 가치가 없습니다. 위임을 획득한 개시를 마감하는 경우에만 고객이 이를 조기에 수행할 가능성이 높습니다. 이 경우 일단 완료된 마감은 취소되지 않기 때문입니다. 이러한 작업 예약에 대한 클라이언트의 선택에 관계없이 위임을 초래한 개시에 해당하는 마감을 포함하여 \(해당되는 경우\) 위임이 반환되기 전에 모든 작업을 수행해야 합니다. 이러한 작업은 이전 요청이나 동일한 COMPOUND 요청의 이전 작업에서 수행될 수 있습니다.

---
#### **10.4.5.  OPEN Delegation Race with CB_RECALL**

서버는 CB\_RECALL을 통해 클라이언트에게 회수 사실을 알립니다. 발생할 수 있는 경합 사례는 위임을 설정한 COMPOUND가 클라이언트에 반환되기 전에 위임이 즉시 회수되는 경우입니다. CB\_RECALL은 클라이언트에 매핑이 없는 상태 ID와 파일 핸들을 모두 제공하므로 회수 시도를 받아들일 수 없습니다. 이 시점에서 클라이언트에는 응답하지 않거나 NFS4ERR\_BADHANDLE로 응답하는 두 가지 선택 사항이 있습니다. 응답하지 않으면 서버가 추가 위임을 허용하지 않기로 결정할 위험이 있습니다.

대신 NFS4ERR\_BADHANDLE로 응답하면 클라이언트와 서버 모두 경쟁 조건이 발생하고 있음을 감지할 수 있습니다. 클라이언트는 보류 중인 위임 목록을 유지할 수 있습니다. 알 수 없는 위임에 대한 CB\_RECALL을 수신하면 보류 중인 회수 목록에 stateid 및 파일 핸들을 캐시할 수 있습니다. 위임이 제공되면 회수 보류 목록에 없는 경우에만 사용됩니다. 다음 CB\_RECALL 시 즉시 위임을 반환할 수 있습니다.

그러면 서버는 위임을 발행하는 시기를 추적하고 클라이언트가 NFS4ERR\_BADHANDLE을 사용하여 CB\_RECALL에 응답하는 경우 클라이언트가 아직 위임을 받지 못했다고 가정할 수 있습니다. 서버는 위임을 취소하기 전에 클라이언트에게 이 위임을 받고 이를 반환할 수 있는 합리적인 시간을 제공해야 합니다. 실패한 콜백 경로와 달리 서버는 CB\_RECALL을 사용하여 클라이언트를 주기적으로 조사하여 위임을 받았고 반환할 준비가 되었는지 확인해야 합니다.\(SHOULD\)

서버가 최종적으로 충분한 시간이 경과했다고 판단하면 위임을 취소해야 하며 임대를 취소해서는 안 됩니다. 이 확장된 회수 프로세스 동안 서버는 클라이언트 임대를 갱신해야 합니다. 여기서의 의도는 클라이언트가 서버로 인해 발생한 조건에 대해 너무 부담스러운 부담을 지불하지 않는다는 것입니다.\(SHOULD NOT, SHOULD\)

---
#### **10.4.6.  Clients That Fail to Honor Delegation Recalls**

서버에서 클라이언트로의 콜백 경로 실패 등 다양한 이유로 클라이언트가 회수에 응답하지 못할 수 있습니다. 클라이언트는 콜백 경로의 오류를 인식하지 못할 수 있습니다. 이러한 인식 부족으로 인해 클라이언트는 위임이 취소된 후 오랜 시간이 지나서 클라이언트가 위임한 데이터를 다른 클라이언트가 수정했다는 사실을 알게 될 수 있습니다. 이는 특히 OPEN\_DELEGATE\_WRITE 위임을 보유한 클라이언트의 문제입니다.

또한 서버에는 회수에 응답하지 않는 클라이언트가 임대가 만료되기 전에 임대를 갱신하는 요청을 포함하여 다른 NFS 요청을 보낼 수도 있다는 딜레마가 있습니다. 임대 갱신 작업에 대해 오류를 반환하지 않으면 서버는 클라이언트가 위임이 유효하다고 믿도록 유도합니다.

이 어려움은 다음 규칙에 따라 해결됩니다.

o 콜백 경로가 다운되었을 때 다음 중 하나가 발생하면 서버는 위임을 취소해서는 안 됩니다.\(MUST NOT\)

- \* 클라이언트가 RENEW 작업을 실행했고 서버가 NFS4ERR\_CB\_PATH\_DOWN 오류를 반환했습니다. 서버는 서버가 알고 있는 클라이언트의 바이트 범위 잠금 및 공유 예약에 대한 임대를 갱신해야 합니다\(클라이언트가 설정했지만 위임으로 인해 아직 서버에 전송되지 않은 잠금 및 공유 예약과 반대\). . 서버는 클라이언트의 위임을 취소하기 전에 클라이언트에게 서버에 위임을 반환할 수 있는 합리적인 시간을 제공해야 합니다.\(MUST, SHOULD\)

- \* 서버가 위임 회수를 시도한 후 클라이언트가 일정 기간 동안 RENEW 작업을 실행하지 않았습니다. 이 기간은 Lease\_time 속성 값보다 작아서는 안 됩니다.\(MUST NOT\)

o 클라이언트가 위임을 보유한 경우 콜백 경로 실패 시 위임 임대를 갱신하기 위해 stateid를 사용하는 RENEW를 제외한 작업에 의존할 수 없습니다. 콜백 경로 실패 시에도 위임을 유지하려는 클라이언트는 이를 위해 RENEW를 사용해야 합니다.

---
#### **10.4.7.  Delegation Revocation**

위임이 취소되는 시점에 클라이언트에 연결된 열기가 있는 경우 이러한 열기를 보유하는 애플리케이션에 알려야 합니다. 이 알림은 일반적으로 읽기/쓰기 작업에 대한 오류를 반환하거나 열린 파일에 대해 닫기를 시도할 때 발생합니다.

위임이 취소된 시점에 파일에 대한 열기가 없으면 취소 알림이 필요하지 않습니다. 그러나 클라이언트에 파일에 대한 수정된 데이터가 있는 경우 애플리케이션 사용자에게 알려야 합니다. 안타깝게도 활성 애플리케이션이 클라이언트에 없을 수 있으므로 사용자에게 알리는 것이 불가능할 수 있습니다. 자세한 내용은 섹션 10.5.1을 참조하세요.

---
### **10.5.  Data Caching and Revocation**

잠금 및 위임이 취소되면 성공적인 캐싱에 대한 가정이 더 이상 보장되지 않습니다. 잠금 또는 공유 예약이 취소된 경우 해당 소유자에게 알려야 합니다. 이 알림에는 취소된 해당 위임이 있는 파일이 열려 있는 애플리케이션이 포함됩니다.

취소와 관련된 캐시된 데이터는 클라이언트에서 제거되어야 합니다. 클라이언트 캐시에 수정된 데이터가 있는 경우 해당 데이터는 서버에 기록되지 않고 클라이언트에서 제거되어야 합니다. 언급한 대로 클라이언트가 가정한 가정은 잠금이나 위임이 취소된 시점에는 더 이상 유효하지 않습니다. 예를 들어, 첫 번째 클라이언트에서 잠금이 취소된 후 다른 클라이언트에 충돌하는 잠금이 부여되었을 수 있습니다. 따라서 잠금 범위 내의 데이터가 다른 클라이언트에 의해 수정되었을 수 있습니다. 분명히 첫 번째 클라이언트는 해지 시 파일에 어떤 일이 발생했는지 애플리케이션에 보장할 수 없습니다.

잠금 소유자에 대한 알림은 많은 경우 열린 파일에 대한 다음 및 모든 후속 읽기/쓰기 또는 닫기 시 오류를 반환하는 것으로 구성됩니다. 특정 작업에 대한 오류가 반환되지 않을 수 있기 때문에 클라이언트가 사용할 수 있는 방법으로 인해 이러한 알림이 불가능해지는 경우 신호 또는 프로세스 종료와 같은 보다 과감한 조치가 적절할 수 있습니다. 이에 대한 정당성은 애플리케이션이 의존하는 불변성이 위반될 수 있다는 것입니다. 클라이언트 운영 환경에서 오류가 일반적으로 처리되는 방식에 따라 로깅, 콘솔 메시지 및 GUI 팝업을 포함한 추가 수준의 알림이 적절할 수 있습니다.

---
#### **10.5.1.  Revocation Recovery for Write Open Delegation**

OPEN\_DELEGATE\_WRITE 위임에 대한 해지 복구는 파일이 열려 있지 않은 동안 클라이언트 캐시에서 수정된 데이터라는 특별한 문제를 발생시킵니다. 이 상황에서 각 닫을 때 수정된 데이터를 서버에 플러시하지 않는 클라이언트는 사용자가 해지 결과로 발생한 실패에 대한 적절한 알림을 받도록 해야 합니다. 이러한 상황에서는 문제를 해결하기 위해 사람의 조치가 필요할 수 있으므로 해당 사용자나 관리자에게 알리는 알림 체계가 필요할 수 있습니다. 로깅 및 콘솔 메시지가 일반적인 예입니다.

클라이언트에 수정된 데이터가 있는 경우 서버에 정상적으로 플러시되어서는 안 됩니다. 클라이언트는 복구를 용이하게 하기 위해 파일 시스템 네임스페이스의 다른 이름으로 위임 중에 수정된 파일 데이터의 복사본을 제공하려고 시도할 수 있습니다. 파일이 다른 클라이언트에 의해 수정되지 않았음을 클라이언트가 확인할 수 있거나 클라이언트가 문제의 파일에 대해 완전히 캐시된 복사본을 가지고 있는 경우, 클라이언트의 파일 보기에 대한 저장된 복사본은 특별한 가치를 가질 수 있습니다. 회복을 위해. 다른 경우에는 부분적으로는 클라이언트의 캐시된 데이터를 기반으로 하고 부분적으로는 다른 클라이언트가 수정한 서버 복사본을 기반으로 하는 파일 복사본을 사용하여 복구하는 것이 결코 간단하지 않으므로 클라이언트는 이러한 상황에서 파일 내용 저장을 피하거나 특히 사용자에게 가능한 문제를 경고하기 위한 결과입니다.

위임 철회 상황에서 이러한 수정된 데이터의 저장은 특정 크기의 파일로 제한되거나 대상 파일 시스템 내에서 충분한 디스크 공간을 사용할 수 있는 경우에만 사용될 수 있습니다. 이러한 저장은 캐시된 복사본이 대상 파일 시스템에 적절하게 저장될 때까지 캐시된 복사본을 계속 사용할 수 있을 만큼 클라이언트에 충분한 버퍼링 리소스가 있는 상황으로 제한될 수도 있습니다.

---
### **10.6.  Attribute Caching**

이 섹션에서 설명하는 속성에는 명명된 속성이 포함되지 않습니다. 명명된 개별 속성은 파일과 유사하며, 이에 대한 데이터 캐싱은 일반 파일에 대한 데이터 캐싱과 마찬가지로 처리되어야 합니다. 마찬가지로 OPENATTR 디렉터리의 LOOKUP 결과는 다른 경로 이름과 동일한 기준으로 캐시되며 디렉터리 내용도 유사합니다.

클라이언트는 서버에서 얻은 파일 속성을 캐시하고 이를 사용하여 후속 GETATTR 요청을 피할 수 있습니다. 이 캐시는 파일 속성에 대한 모든 수정이 항상 서버에 대한 요청을 통해 수행된다는 점에서 캐싱을 통해 작성됩니다. 즉, 수정이 로컬에서 수행되거나 캐시되어서는 안 됩니다. 이에 대한 예외는 데이터 캐싱과 밀접하게 연결된 속성에 대한 수정입니다. 따라서 로컬 데이터 캐시에 데이터를 써서 파일을 확장하면 이러한 변경 사항이 서버에 즉시 반영되지 않고 클라이언트에 표시되는 크기에 즉시 반영됩니다. 일반적으로 이러한 변경 사항은 서버에 직접 전파되지 않지만 수정된 데이터가 서버로 플러시되면 유사한 속성 변경이 서버에서 수행됩니다. 공개 위임이 적용되면 수정된 속성이 CB\_GETATTR 호출에 대한 응답으로 서버에 반환될 수 있습니다.

속성의 로컬 캐싱으로 인해 개별 클라이언트에서 유지 관리되는 속성 캐시가 일관되지 않게 됩니다. 서버에서 한 순서로 변경된 사항은 한 클라이언트에서는 다른 순서로, 다른 클라이언트에서는 세 번째 순서로 나타날 수 있습니다.

일반적인 파일 시스템 애플리케이션 프로그래밍 인터페이스는 동시에 여러 파일의 속성을 원자적으로 수정하거나 조사하는 수단을 제공하지 않습니다. 다음 규칙은 위에서 언급한 잠재적인 비일관성을 합리적으로 관리할 수 있는 환경을 제공합니다. 이러한 규칙은 이전 NFS 프로토콜의 관행에서 파생되었습니다.

o 특정 파일의 모든 속성\(fsid별 속성 제외\)은 단일 파일의 컨텍스트 내에서 비직렬화가 발생할 수 없도록 클라이언트에서 하나의 단위로 캐시됩니다.

o 클라이언트 캐시 항목이 서버에서 새로 고쳐지지 않고 유지될 수 있는 기간에 대한 상한 시간 경계가 유지됩니다.

o 서버에서 속성을 수정하는 작업이 수행되면 업데이트된 속성 세트가 포함된 RPC의 일부로 요청됩니다. 여기에는 속성을 간접적으로 업데이트하는 디렉터리 작업이 포함됩니다. 이는 GETATTR 작업으로 수정 작업을 수행한 다음 GETATTR의 결과를 사용하여 클라이언트의 캐시된 속성을 업데이트함으로써 수행됩니다.

캐시할 속성의 전체 집합이 READDIR에 의해 요청되면 클라이언트는 GETATTR을 통해 얻은 속성과 동일한 기반으로 결과를 캐시할 수 있습니다.

클라이언트는 변경 속성과 time\_access 속성을 모두 가져오고 변경 속성이 속성이 캐시되었을 때와 동일한 값을 갖는 경우 time\_access 이외의 속성은 변경되지 않았다고 가정하여 파일에 대한 캐시된 속성 버전의 유효성을 검사할 수 있습니다. 많은 서버가 변경 사항을 업데이트하는 작업이 time\_access를 업데이트하지 않는 환경에서 작동하기 때문에 time\_access 속성도 가져옵니다. 예를 들어 POSIX 파일 의미 체계는 쓰기 시스템 호출로 파일이 수정될 때 액세스 시간을 업데이트하지 않습니다. 따라서 현재 time\_access 값을 원하는 클라이언트는 속성 캐시 검증 처리 중에 변경된 값을 가져와서 캐시된 time\_access를 업데이트해야 합니다.

클라이언트는 수정된 일반 파일의 데이터\(크기, 시간\_수정 및 변경\)와 밀접하게 연결된 속성에 대한 수정된 속성의 캐시를 유지할 수 있습니다. 이 세 가지 속성 외에 클라이언트는 수정된 속성의 캐시를 유지해서는 안 됩니다. 대신 속성 변경 사항이 즉시 서버로 전송됩니다.\(MUST NOT\)

일부 운영 환경에서는 파일 객체의 내용을 읽을 때마다 time\_access에 해당하는 내용이 암시적으로 업데이트될 것으로 예상됩니다. NFS 클라이언트가 일반 파일, 디렉터리, 심볼릭 링크 등 파일 객체의 콘텐츠를 캐싱하는 경우 클라이언트는 각 항목으로 서버의 time\_access 속성\(SETATTR 또는 작은 READ 또는 READDIR 요청을 통해\)을 업데이트해서는 안 됩니다. 캐시에서 만족된 읽기입니다. 그 이유는 특히 time\_access의 명시적인 SETATTR이 서버의 변경 속성을 변경할 수 있기 때문에 콘텐츠 캐싱의 성능 이점을 상실할 수 있기 때문입니다. 변경 속성이 변경되면 콘텐츠를 캐싱하는 클라이언트는 콘텐츠가 변경되었다고 생각하고 서버에서 수정되지 않은 데이터를 다시 읽습니다. 또한 클라이언트는 수정된 버전의 time\_access를 캐시에 유지하도록 권장되지 않습니다. 이는 클라이언트가 결국 나쁜 성능 영향으로 서버에 액세스 시간을 기록해야 하거나 서버의 time\_access를 업데이트하지 않음을 의미하기 때문입니다. 상황은\(SHOULD NOT\)

동일한 파일의 닫기와 열기 사이의 액세스 시간을 캐시하는 애플리케이션은 과거와 현재 사이를 오가는 액세스 시간을 관찰합니다. time\_access 속성은 항상 서버에서 충족한 READ에 의해 파일에 마지막으로 액세스한 시간을 의미합니다. 이런 식으로 클라이언트는 앞으로 진행되는 time\_access 변경 사항만 보는 경향이 있습니다.

---
### **10.7.  Data and Metadata Caching and Memory-Mapped Files**

일부 운영 환경에는 응용 프로그램이 파일 내용을 응용 프로그램의 주소 공간에 매핑하는 기능이 포함되어 있습니다. 응용 프로그램이 주소 공간에 로드되지 않은 블록에 해당하는 메모리 위치에 접근할 때마다 페이지 폴트가 발생하여 파일을 읽습니다\(또는 해당 블록이 파일에 없으면 블록을 할당한 다음 애플리케이션의 주소 공간에서 인스턴스화됨\)

파일에 대한 각 메모리 매핑 액세스에 페이지 오류가 필요한 한 액세스 및 수정을 감지하는 데 사용되는 파일의 관련 속성\(time\_access, time\_metadata, time\_modify 및 변경\)이 업데이트됩니다. 그러나 많은 운영 환경에서 페이지 폴트가 필요하지 않은 경우 이러한 속성은 파일이 로컬 파일인지 또는 원격으로 액세스되는지 여부에 관계없이 메모리 액세스를 통해 파일을 읽거나 업데이트할 때 업데이트되지 않습니다. 클라이언트나 서버는 메모리 매핑된 I/O를 통해 액세스되는 파일의 속성을 업데이트하지 못할 수 있습니다. 이는 다음과 같은 몇 가지 의미를 갖습니다.\(MAY\)

o 클라이언트도 액세스하고 있는 파일에 메모리 매핑된 응용 프로그램이 서버에 있는 경우 클라이언트는 캐시가 오래되었는지 여부를 확인하기 위해 변경 속성의 일관된 값을 얻지 못할 수 있습니다. 파일이 메모리 매핑되어 있음을 알고 있는 서버는 항상 변경 사항에 대해 업데이트된 값을 비관적으로 반환하여 응용 프로그램이 항상 파일에 대한 최신 데이터와 메타데이터를 가져오도록 할 수 있습니다. 그러나 이는 성능에 부정적인 영향을 미치므로 이러한 동작은 선택 사항입니다.\(MAY\)

o 메모리 매핑된 파일이 서버에서 수정되지 않고 대신 메모리 매핑된 인터페이스를 통해 응용 프로그램에서 읽는 중인 경우 클라이언트에는 업데이트된 time\_access 속성이 표시되지 않습니다. 그러나 많은 운영 환경에서는 서버에서 프로세스가 실행되지 않습니다. 따라서 NFS 클라이언트는 로컬 프로세스와 관련하여 불리한 점이 없습니다.

o 파일을 메모리 매핑하는 다른 클라이언트가 있고 해당 클라이언트가 OPEN\_DELEGATE\_WRITE 위임을 보유한 경우 이전 두 글머리 기호 항목에서 설명한 것과 동일한 문제 집합이 적용됩니다. 따라서 서버가 클라이언트가 가지고 있는 파일에 대해 CB\_GETATTR을 수행하면

- 캐시에서 수정되면 CB\_GETATTR의 응답이 반드시 정확하지는 않습니다. 앞에서 설명한 것처럼 클라이언트의 의무는 연속적인 CB\_GETATTR 호출 사이에 파일이 다시 수정되었는지 여부가 아니라 위임이 허용된 이후 파일이 수정되었음을 보고하는 것이며 서버는 클라이언트가 캐시에서 수정한 모든 파일이 수정되었다고 가정해야 합니다. 연속적인 CB\_GETATTR 호출 사이에서 다시 수정되었습니다. 클라이언트의 메모리 관리 시스템의 특성에 따라 이러한 약한 의무는 불가능할 수도 있습니다. 클라이언트는 파일이 메모리 매핑될 때마다 CB\_GETATTR에 오래된 정보를 반환할 수 있습니다.\(MUST, MAY\)

o 동일한 파일에 대한 메모리 매핑과 파일 잠금의 혼합은 문제가 있습니다. 각 클라이언트의 페이지 크기가 8192바이트인 다음 시나리오를 고려해 보세요.

- \* 클라이언트 A 메모리는 파일 X의 첫 번째 페이지\(8192바이트\)를 매핑합니다.

- \* 클라이언트 B 메모리는 파일 X의 첫 번째 페이지\(8192바이트\)를 매핑합니다.

- \* 클라이언트 A 쓰기는 처음 4096바이트를 잠급니다.

```text
      *  Client B write locks second 4096 bytes.
```

- \* 클라이언트 A는 STORE 명령을 통해 잠긴 영역의 일부를 수정합니다.

- \* 클라이언트 A와 동시에 클라이언트 B는 잠긴 영역의 일부에 STORE를 발행합니다.

여기서 문제는 첫 번째 페이지의 올바른 보기를 얻기 위해 각 클라이언트가 재동기화하는 것입니다. 많은 운영 환경에서 각 클라이언트의 가상 메모리 관리 시스템은 페이지가 수정되었다는 사실만 알고 각 잠금 영역에 해당하는 페이지의 하위 집합이 수정되었다는 사실은 알지 못합니다. 따라서 각 클라이언트가 올바른 작업, 즉 잠긴 페이지 부분만 서버에 쓰는 것은 불가능합니다. 예를 들어 클라이언트 A가 단순히 페이지를 작성한 다음 클라이언트 B가 페이지를 작성한 경우 클라이언트 A의 데이터가 손실됩니다.

게다가 파일에 필수 잠금이 활성화되어 있으면 다른 문제가 발생합니다. 클라이언트 A와 B가 STORE 명령을 실행하면 결과 페이지 오류로 인해 전체 페이지에 대한 바이트 범위 잠금이 필요합니다. 그런 다음 각 클라이언트는 잠긴 범위를 전체 페이지로 확장하려고 시도하며 이로 인해 교착 상태가 발생합니다.

NFS4ERR\_DEADLOCK 오류를 STORE 명령에 전달하는 것은 기껏해야 어렵습니다.

클라이언트가 전체 메모리 매핑된 파일을 잠그는 경우 적어도 클라이언트가 파일 중간 영역의 잠금을 해제할 때까지는 권고 또는 필수 바이트 범위 잠금에 문제가 없습니다.

위의 문제를 고려하여 다음이 허용됩니다.

o 클라이언트와 서버는 바이트 범위 잠금이 있는 파일에 대한 메모리 매핑을 거부할 수 있습니다.\(MAY\)

o 클라이언트와 서버는 메모리 매핑된 파일에 대한 바이트 범위 잠금을 거부할 수 있습니다.\(MAY\)

o 클라이언트는 I/O에 대한 필수 잠금이 필요하다는 것을 알고 있는 파일에 대한 메모리 매핑을 거부할 수 있습니다. 파일이 열리고 매핑된 후 필수 잠금이 활성화되면 클라이언트는 매핑된 파일에 대한 응용 프로그램의 추가 액세스를 거부할 수 있습니다.\(MAY, MAY\)

---
### **10.8.  Name Caching**

LOOKUP 및 READDIR 작업의 결과는 후속 LOOKUP 작업 비용을 피하기 위해 캐시될 수 있습니다. 속성 캐싱의 경우와 마찬가지로 다양한 클라이언트 캐시 간에 불일치가 발생할 수 있습니다. 이러한 불일치의 영향을 완화하고 일반적인 파일 시스템 API의 컨텍스트를 고려하여 클라이언트 이름 캐시 항목이 수행된 디렉터리 변경 작업으로 인해 항목이 유효하지 않게 만들어지지 않았는지 확인하지 않고 클라이언트 이름 캐시 항목을 유지할 수 있는 기간에 대한 상한 시간 경계가 유지됩니다. 다른 클라이언트에 의해.

클라이언트가 이름 캐시 항목이 있는 디렉터리를 변경하지 않는 경우 클라이언트는 해당 디렉터리가 수정되지 않도록 정기적으로 해당 디렉터리의 속성을 가져와야 합니다. 수정 사항이 발생하지 않았음을 확인한 후 관련 이름 캐시 항목의 만료 시간은 현재 시간에 이름 캐시 유효 기간 제한을 더한 값으로 업데이트될 수 있습니다.

클라이언트가 특정 디렉터리를 변경할 때 다른 클라이언트가 해당 디렉터리를 변경했는지 여부를 확인해야 합니다. 이는 작업에 대해 반환된 관련change\_info4 값에서 디렉터리 작업 전후에 보고된 변경 속성을 사용하여 수행됩니다. 서버는 디렉토리 작업과 관련하여 Change\_info4 데이터가 원자적으로 제공되는지 여부를 클라이언트와 통신할 수 있습니다. 변경 값이 원자적으로 제공되면 클라이언트는 작업 전 변경 값을 클라이언트 이름 캐시의 변경 값과 비교할 수 있습니다. 비교 결과 디렉터리가 다른 클라이언트에 의해 업데이트되었음을 ​​나타내는 경우 수정된 디렉터리와 관련된 이름 캐시가 클라이언트에서 제거됩니다. 비교 결과 수정 사항이 없음이 나타나면 이름 캐시를 업데이트할 수 있습니다.

클라이언트가 디렉터리 작업을 반영하고 관련 시간 제한이 연장되었습니다. 작업 후 변경 값은 향후change\_info4 비교를 위한 기초로 저장되어야 합니다.

위의 시나리오에서 설명한 것처럼 이름 캐싱을 위해서는 클라이언트가 이름 캐시 항목이 캐시된 시점에 디렉터리의 변경 특성을 검사하여 이름 캐시 데이터의 유효성을 다시 검사해야 합니다. 이를 위해서는 해당 디렉토리의 내용이 수정될 때 서버가 디렉토리의 변경 속성을 업데이트해야 합니다. 클라이언트가 Change\_info4 정보를 적절하고 정확하게 사용하기 위해서는 서버가 작업 전후의 변경 속성 값을 원자적으로 보고해야 합니다. 서버가 디렉터리 작업과 관련하여 이전 및 이후 값을 원자적으로 보고할 수 없는 경우 서버는 Change\_info4 반환 값에 해당 사실을 표시해야 합니다. 정보가 원자적으로 보고되지 않는 경우 클라이언트는 다른 클라이언트가 디렉터리를 변경하지 않았다고 가정해서는 안 됩니다.

---
### **10.9.  Directory Caching**

READDIR 작업의 결과는 후속 READDIR 작업을 방지하는 데 사용될 수 있습니다. 속성 및 이름 캐싱의 경우와 마찬가지로 다양한 클라이언트 캐시 간에 불일치가 발생할 수 있습니다. 이러한 불일치로 인한 영향을 완화하고 일반적인 파일 시스템 API의 컨텍스트를 고려하여 다음 규칙을 따라야 합니다.

o 단일 READDIR 작업에서 얻지 못한 디렉터리에 대한 캐시된 READDIR 정보는 항상 디렉터리 내용의 일관된 스냅샷이어야 합니다. 이는 첫 번째 READDIR 이전과 캐시에 기여하는 마지막 READDIR 이후에 GETATTR을 사용하여 결정됩니다.

o 클라이언트가 캐시된 정보를 재검증해야 하기 전에 디렉터리 캐시 항목이 유효한 것으로 간주되는 기간을 나타내기 위해 상한 시간 경계가 유지됩니다.

유효성 재검사 기술은 이름 캐싱의 경우에서 설명한 것과 유사합니다. 클라이언트가 문제의 디렉터리를 변경하지 않는 경우 GETATTR을 사용하여 디렉터리의 변경 속성을 확인하는 것이 적절합니다. 캐시 항목의 수명은 이러한 검사점에서 연장될 수 있습니다. 클라이언트가 디렉터리를 수정할 때 클라이언트는change\_info4 데이터를 사용하여 디렉터리를 수정하는 다른 클라이언트가 있는지 확인해야 합니다. 다른 클라이언트 수정이 발생하지 않는 것으로 확인되면 클라이언트는 자체 변경 사항을 반영하도록 디렉터리 캐시를 업데이트할 수 있습니다.

이전에 설명했듯이 디렉터리 캐싱에서는 클라이언트가 디렉터리가 캐시된 시점에서 디렉터리의 변경 특성을 검사하여 디렉터리 캐시 데이터의 유효성을 다시 검사해야 합니다. 이를 위해서는 해당 디렉토리의 내용이 수정될 때 서버가 디렉토리의 변경 속성을 업데이트해야 합니다. 클라이언트가 Change\_info4 정보를 적절하고 정확하게 사용하기 위해서는 서버가 작업 전후의 변경 속성 값을 원자적으로 보고해야 합니다. 서버가 디렉터리 작업과 관련하여 이전 및 이후 값을 원자적으로 보고할 수 없는 경우 서버는 Change\_info4 반환 값에 해당 사실을 표시해야 합니다. 정보가 원자적으로 보고되지 않는 경우 클라이언트는 다른 클라이언트가 디렉터리를 변경하지 않았다고 가정해서는 안 됩니다.

---
## **11.  Minor Versioning**

필요에 따라 발전할 수 있는 NFS 프로토콜의 요구 사항을 해결하기 위해 NFSv4 프로토콜에는 향후 사소한 변경이나 버전 관리를 허용하는 규칙과 프레임워크가 포함되어 있습니다.

부 버전 관리와 관련된 기본 가정은 향후 승인되는 모든 부 버전이 IETF 프로세스를 따르고 표준 트랙 RFC에 문서화되어야 한다는 것입니다. 따라서 각 부 버전 번호는 RFC에 해당합니다. NFSv4 프로토콜의 마이너 버전 0은 이 RFC로 표시됩니다. COMPOUND 및 CB\_COMPOUND 프로시저는 클라이언트가 요청하는 부 버전의 인코딩을 지원합니다.

향후 마이너 버전은 NFSv2에서 NFSv3으로, NFSv3에서 NFSv4.0으로 이동할 때 수행된 것처럼 이전 마이너 버전의 XDR을 대체하는 것이 아니라 확장할 것입니다.

마이너 버전 구성에 대한 자세한 규칙 사양은 초기 마이너 버전을 정의하는 문서에서 다루거나, NFSv4 전체에 대한 버전 관리 프레임워크를 설정하는 RFC에서 다뤄질 것입니다.

---
## **12.  Internationalization**
---
### **12.1.  Introduction**

국제화는 자체 용어 집합이 있는 복잡한 주제입니다\(\[RFC6365\] 참조\). 이 주제는 NFS 구현의 복잡한 기록과 상태로 인해 NFSv4.0에서 더욱 복잡해졌습니다. 이 섹션에서는 NFSv4.0 클라이언트가 국제화 지원을 구현할 수 있는 기반으로 "NFSv4.0 국제화"\(즉, 기존 클라이언트 및 서버에 의해 구현되는 국제화\)라고 부르는 것에 대해 설명합니다.

이 섹션은 기존 구현의 동작을 기반으로 합니다. 설명된 동작은 각각 적절한 NFSv4 서버 구현과 서버 측 물리적 파일 시스템의 조합으로 설명됩니다. 표시된 동작에 따라 서버와 물리적 파일 시스템을 구성하는 것이 일반적입니다. 아래 설명에서는 서로 다른 동작을 보여주는 각 구성을 별도로 고려합니다.

이 섹션에서 핵심 단어 "MUST", "SHOULD" 및 "MAY"는 일반적인 의미를 유지합니다. 그러나 구현 패턴에서 이 사양을 도출할 때 기존 구현 동작 패턴을 결정할 수 있는 상황에서 사용된 규범적 용어가 기존 구현의 동작에서 어떻게 파생되는지 아래에 문서화합니다.\(MUST\)

o 모든 기존 클라이언트 또는 서버에 의해 구현된 동작은 "MUST"를 사용하여 설명됩니다. 새로운 구현은 상호 운용성을 보장하기 위해 기존 구현을 따라야 하기 때문입니다. 다른 동작이 실행 가능할 수도 있지만 이것이 합리적으로 보이는 사례는 발견되지 않았습니다.\(MUST\)

- 반대의 의미는 "MUST NOT"입니다. 어떤 유형의 동작이 상호 운용성 문제를 야기하는 경우 기존 클라이언트나 서버에서 이를 구현해서는 안 됩니다.\(MUST NOT\)

o 해당 동작이 다른 대안보다 더 바람직한 대부분의 기존 클라이언트 또는 서버에 의해 구현된 동작은 "SHOULD"를 사용하여 설명됩니다. 왜냐하면 새로운 구현은 달리 수행해야 할 강력한 이유가 없는 한 기존 관행을 따라야 하기 때문입니다.\(SHOULD\)

- "하지 말아야 한다"는 반대의 의미가 적용됩니다.\(SHOULD NOT\)

o 전부는 아니지만 일부 기존 클라이언트 또는 서버에 의해 구현된 동작은 "MAY"를 사용하여 설명됩니다. 이는 새로운 구현이 그러한 방식으로 동작할지 여부를 선택할 수 있음을 나타냅니다. 따라서 새로운 구현은 기존 구현과 동일한 유연성을 갖게 됩니다.\(MAY\)

o 지금까지 알려진 모든 기존 클라이언트 또는 서버에 의해 구현된 동작\(그러나 세부 사항에 대해 약간의 불확실성이 남아 있는 경우\)은 "should"를 사용하여 설명됩니다. 이러한 경우는 주로 오류 반환의 세부 사항과 관련이 있습니다. 이러한 상황이 일반적으로 상호 운용성에 영향을 미치지 않더라도 새로운 구현은 기존 방식을 따라야 합니다.

특정 서버 동작이 존재하는 것으로 알려지지는 않았지만 존재하지 않는 것으로 확실하게 판단할 수 없는 경우도 있습니다. 부분적으로 이는 오랜 시간이 경과한 결과입니다.

\[RFC3530\]이 발표된 이후 구현에 참여한 사람들이 더 이상 작업 그룹 활동에 참여하거나 이를 인식하지 못하는 상황이 발생했습니다.

존재하는 것으로 알려지지 않았거나 존재하지 않는 것으로 알려진 가능한 서버 동작의 경우 다음과 같이 "SHOULD NOT" 및 "MUST NOT"을 사용하고 "SHOULD" 및 "MUST"에 대해서도 유사하게 사용합니다.\(MUST NOT\)

o 어떤 경우에는 잠재적인 동작이 존재하는 것으로 알려지지 않았지만 실제로 구현된 경우 상호 운용성 어려움이 예상되고 보고되어 잠재적인 동작이 구현되지 않았다는 결론을 내릴 수 있는 성격을 갖습니다. 그러한 행동에 대해서는 "MUST NOT"을 사용합니다. 마찬가지로, 반대되는 행동에 적용하려면 "MUST"를 사용합니다.\(MUST NOT, MUST\)

o 다른 경우에는 잠재적인 행동이 존재하는 것으로 알려지지 않았지만 그 행동은 바람직하지 않지만 잠재적인 존재에 대해 결론을 내릴 수 있는 성격이 아닙니다. 그러한 경우에는 "SHOULD NOT"을 사용합니다. 마찬가지로 반대 동작에 적용하려면 "SHOULD"를 사용합니다.\(SHOULD NOT, SHOULD\)

서버에 적용되는 "MAY", "SHOULD" 또는 "SHOULD NOT"의 경우 클라이언트는 지정된 작업을 수행할 수도 있고 수행하지 않을 수도 있는 서버가 있다는 것을 인식해야 하며 다음 중 하나에 대비해야 합니다. 궁극.\(SHOULD NOT\)

12.2. NFSv4 컨텍스트에서 국제화 관련 처리에 대한 제한 사항

NFSv4 클라이언트 및 서버와 관련하여 국제화 관련 처리를 보편적으로 만들 수 있는 정도를 제한하는 여러 가지 주목할만한 상황이 있습니다.

o NFSv4 클라이언트는 디자인 및 내부 인터페이스가 IETF 범위에 속하지 않는 광범위한 클라이언트 측 소프트웨어 구성 요소 세트의 일부로, 특정 문자 인코딩이 표준으로 만들어질 수 있는 정도를 제한합니다.

o 파일 구성요소 이름의 서버측 처리는 일반적으로

- IETF에서 문자 인코딩 및 정규화 처리를 지정할 수 없는 서버 측 물리적 파일 시스템 내에서 구현됩니다.

o UNIX 시스템의 일반적인 구현 패턴으로 인해 NFSv4 클라이언트는 사용 중인 문자 인코딩을 알지 못하며 이는 동일한 클라이언트 시스템의 프로세스 간에도 다를 수 있습니다.

o 사용자는 이전에 UTF-8이 아닌 인코딩이나 특정 정규화 형식과 일치하지 않는 UTF-8 인코딩으로 저장된 파일에 액세스해야 할 수도 있습니다.

---
### **12.3.  Summary of Server Behavior Types**

섹션 12.6에서 언급한 것처럼 서버는 유효한 UTF-8이 아닌 구성 요소 이름 문자열을 거부할 수 있습니다. 이로 인해 아래에 설명된 대로 다양한 유형의 유효한 서버 동작이 발생합니다. 이것이 섹션 12.4에 설명된 유효한 정규화 관련 동작과 결합되면 아래에 설명된 결합 동작이 생성됩니다.\(MAY\)

o 파일 구성 요소 이름을 UTF-8 문자열로 제한하는 서버는 섹션 12.4에 설명된 대로 정규화 관련 처리와 함께 존재합니다. 이는 "UTF-8 전용 서버"로 가장 잘 설명됩니다.

o 파일 구성 요소 이름을 UTF-8 문자열로 제한하지 않는 서버는 매우 일반적이며 UTF-8 사용을 지향하지 않는 클라이언트/응용 프로그램을 처리하는 데 필요합니다. 이러한 서버는 정규화 관련 문제를 무시하며 정규화 또는 표현 독립적 조회를 구현할 방법이 없습니다. 이는 파일 구성 요소 이름을 해석되지 않은 바이트 문자열로 처리하고 표시되는 문자에 대한 지식이 없기 때문에 "UTF-8을 인식하지 못하는 서버"로 가장 잘 설명됩니다. 자세한 내용은 섹션 12.7을 참조하세요.

o 서버가 UTF-8 문자열의 구조를 인식하면서 유효한 UTF-8이 아닌 구성 요소 이름을 허용하는 것이 가능합니다. 이러한 서버는 정규화 또는 표현 독립적 조회를 구현할 수 있지만 해당 기술은 유효한 UTF-8 문자열에만 적용됩니다. 이러한 서버는 일반적이지 않지만 이 동작을 갖도록 알려진 서버를 하나 이상 구성할 수 있습니다. 하나의 문자 집합을 사용하는 파일 이름이 우연히 UTF-8 파일 이름처럼 보일 수 있으므로 이 동작을 사용하면 안 됩니다. UTF-8 정규화 또는 표현 독립적 조회의 결과는 다른 문자 집합과 관련하여 모든 경우에 정확할 가능성이 없습니다.\(SHOULD NOT\)

---
### **12.4.  String Encoding**

잠재적으로 ASCII 범위\[RFC20\] 외부의 문자를 포함하는 문자열은 일반적으로 유니코드\[UNICODE\]의 UTF-8 인코딩\[RFC3629\]을 사용하여 NFSv4에서 표현됩니다. 정확한 인코딩 및 디코딩 규칙은 \[RFC3629\]를 참조하세요.

프로토콜 처리의 일부 세부 사항은 문자열 유형에 따라 다릅니다.

o 구성 요소 이름인 문자열의 경우 ASCII가 아닌 문자에 대해 선호되는 인코딩은 유니코드의 UTF-8 표현입니다.

- 대부분의 경우 클라이언트는 프로세스별 로케일 사양의 제어 하에 사용자 수준에서 인코딩이 수행되어 사용되는 인코딩에 대한 지식이 없습니다. 결과적으로 NFSv4 클라이언트가 UTF-8 사용을 강제하는 것이 불가능할 수 있습니다. UTF-8이 아닌 인코딩을 사용하면 다른 형식의 이름 인코딩을 사용하여 저장된 파일에 대한 액세스를 방해할 수 있으므로 문제가 될 수 있습니다. 또한 UTF-8로 인코딩되지 않은 문자열의 정규화 관련 처리\(섹션 12.5 참조\)로 인해 부적절한 이름 수정이나 별칭이 발생할 수 있습니다. 실수로 UTF-8 규칙을 준수하는 비UTF-8 인코딩 이름이 있는 경우 정식으로 동등한 문자열을 대체하면 비UTF-8 인코딩 이름이 대폭 변경될 수 있습니다.

- 여기에 언급된 수정 및 별칭 종류는 문제의 문자열에 따라 거짓 부정 및 거짓 긍정으로 이어질 수 있으며, 이로 인해 권한 상승 및 서비스 거부와 같은 보안 문제가 발생할 수 있습니다\(자세한 논의는 \[RFC6943\] 참조\). .

o 도메인 이름 기반 문자열의 경우 ASCII가 아닌 문자는 유니코드의 UTF-8 인코딩을 사용하여 표현되어야 하며 추가 문자열 형식 제한이 적용됩니다. 자세한 내용은 섹션 12.6을 참조하세요.\(MUST\)

o 심볼릭 링크\(XDR의 linktext4 유형\)의 콘텐츠는 NFSv4 서버에서 불투명 데이터로 처리되어야 합니다. UTF-8 인코딩이 자주 사용되지만 반드시 그럴 필요는 없습니다. 이런 점에서 심볼릭 링크의 내용은 인코딩이 이 사양의 범위에 속하지 않는다는 점에서 일반 파일의 내용과 같습니다.\(MUST\)

o 다른 종류의 문자열의 경우 ASCII가 아닌 문자는 유니코드의 UTF-8 인코딩을 사용하여 표현되어야 합니다.\(SHOULD\)

---
### **12.5.  Normalization**

클라이언트와 서버 운영 환경은 문자 정규화와 관련하여 정책과 운영 방법이 다를 수 있습니다\(정규화 형식에 대한 설명은 \[유니코드\] 참조\). 이러한 차이는 동일한 클라이언트의 응용 프로그램 간에도 존재할 수 있습니다. 이는 상호 운용성을 극대화하는 프로토콜에 대한 단일 정규화 정책을 제공하는 데 어려움을 더합니다. 이 문제는 서버가 대소문자 구분을 지원하거나 지원하지 않을 수 있는 문자 대소문자 문제와 유사합니다.

파일 이름 일치를 확인하고 파일 이름을 저장할 때 대소문자를 보존할 수도 있고 그렇지 않을 수도 있습니다. 프로토콜은 특정 동작을 요구하지는 않지만 다양한 유용한 동작을 허용합니다.

NFSv4 프로토콜은 현재 특정 정규화 형식의 사용을 요구하지 않습니다. NFSv4 프로토콜의 후속 마이너 버전에서는 특정 정규화 형식을 지정할 수 있습니다. 따라서 서버와 클라이언트는 프로토콜 요청 및 응답 내에서 정규화되지 않은 문자를 받을 수 있다고 예상할 수 있습니다. 운영 환경에 정규화가 필요한 경우 구현 시 애플리케이션\(클라이언트\) 또는 로컬 파일 시스템\(서버\)에 정보를 제공하기 전에 프로토콜 내에서 다양한 UTF-8 인코딩 문자열을 정규화해야 합니다.

서버 구현은 파일을 찾거나 생성할 때 결과 문자열을 사용하기 전에 특정 정규화 형식을 따르도록 파일 이름을 정규화할 수 있습니다. 서버는 또한 특정 정규화 형식과 일치하도록 이름을 수정하지 않고 정규화를 구분하지 않는 문자열 비교를 수행할 수도 있습니다. 구성 요소 이름이 유효한 UTF-8 문자열이 아니기 때문에 정규화 관련 처리에서 제외되는 경우를 제외하고 서버는 정규화 여부, 정규화 대상 형식 및 수행 여부에 대해 동일한 선택을 해야 합니다. 정규화를 구분하지 않는 문자열 비교\) 특정 파일 시스템에 대한 모든 액세스에 대해 동일한 방식으로 수행됩니다. 서버는 특정 정규화 형식을 따르지 않는다는 이유로 파일 이름을 거부해서는 안 됩니다. 이는 다른 정규화 형식을 사용하는 클라이언트에 대한 액세스를 거부할 수 있기 때문입니다.\(MAY, MAY, MUST, SHOULD NOT\)

---
### **12.6.  Types with Processing Defined by Other Internet Areas**

NFSv4가 처리하는 문자열에는 도메인 이름을 기반으로 하는 두 가지 유형이 있습니다. 이러한 문자열의 처리는 다른 인터넷 표준에 의해 정의되므로 해당 문자열의 처리 동작은 모든 서버 운영 체제 및 서버 파일 시스템에서 일관되어야 합니다.

이는 다음과 같습니다:

o fs\_locations 속성에 나타나는 서버 이름입니다. 대부분의 경우 이러한 서버 이름은 서버에서 클라이언트로만 전송됩니다. VERIFY 또는 NVERIFY 작업에서 fs\_locations 속성을 사용하는 경우는 예외입니다.

o 사용자 및 그룹 집합을 나타내는 데 사용되며 도메인 이름 형식의 주요 접미사입니다.

이러한 모든 도메인 관련 문자열을 처리하기 위한 일반 규칙은 클라이언트 또는 서버인 발신자 또는 수신자의 역할과 유사하고 독립적입니다. 그러나 이러한 규칙을 준수하지 못한 결과는 클라이언트 또는 서버에 따라 다를 수 있습니다. 서버는 유효하지 않은 문자열이 전송되면 오류를 보고할 수 있는 반면, 클라이언트는 유효하지 않은 문자열을 무시하거나 대신 기본값을 사용합니다.

전송된 문자열은 \[RFC5890\]에 정의된 대로 하나 이상의 U-레이블 형식이어야 합니다. 이것이 비실용적이라면 대신 하나 이상의 LDH 레이블\[RFC5890\] 형식을 사용하거나 U-레이블 형식이 올바르지 않은 레이블을 포함하는 UTF-8 도메인 이름을 사용할 수 있습니다. 수신자는 허용되는 모든 형식의 도메인 및 서버 이름을 받아들일 수 있어야 합니다. 서버는 NFS4ERR\_INVAL 오류를 사용하여 유효한 UTF-8이 아니거나 유효한 LDH 레이블이 아닌 ASCII 레이블을 포함하거나 XN 레이블\("xn--"로 시작\)을 포함하는 문자열을 거부해야 합니다. "xn--" 뒤의 문자는 Punycode 알고리즘 \[RFC3492\]의 유효한 출력이 아닙니다.\(SHOULD, MUST\)

도메인 문자열이 id@domain 또는 group@domain의 일부인 경우 두 가지 가능한 접근 방식이 있습니다.

1. 서버는 도메인 문자열을 일련의 U-레이블로 처리합니다. 도메인 문자열이 일련의 A-레이블 또는 예약되지 않은 LDH\(NR-LDH\) 레이블인 경우 Punycode 알고리즘\[RFC3492\]을 사용하여 이를 U-레이블로 변환합니다. 도메인 문자열이 일련의 다른 종류의 LDH 레이블인 경우 서버는 \[RFC3490\]에 정의된 ToUnicode 함수를 사용하여 문자열을 일반적으로 U-레이블 구문을 따르는 일련의 레이블로 변환할 수 있습니다. 도메인 문자열이 U-레이블이 아닌 UTF-8 문자열인 경우 서버는 \[RFC3490\]에 정의된 ToASCII 함수를 사용한 다음 문자열에 대한 ToUnicode 함수를 사용하여 일련의 레이블로 변환하려고 시도할 수 있습니다. 일반적으로 U-라벨 구문을 준수합니다. 결과적으로 GETATTR의 사용자 ID 내에 반환된 도메인 문자열은 SETATTR을 사용하여 사용자 ID를 설정할 때 전송된 문자열과 일치하지 않을 수 있습니다. 이 경우 도메인은 일반적으로 U-레이블 구문을 따르는 형식이 됩니다. .

2. 서버는 도메인 문자열을 일련의 U-레이블로 처리하려고 시도하지 않습니다. 특히 위에서 설명한 방법을 사용하여 U-레이블이 아닌 도메인 문자열을 U-레이블에 매핑하지 않습니다. 결과적으로 사용자 ID의 GETATTR에 반환된 도메인 문자열은 SETATTR로 사용자 ID를 설정할 때 사용된 것과 동일해야 합니다.\(MUST\)

서버는 첫 번째 방법을 사용해야 합니다.\(SHOULD\)

VERIFY 및 NVERIFY의 경우 소유자 및 owner\_group 속성 확인에 추가 문자열 처리 요구 사항이 적용됩니다. 섹션 5.9를 참조하세요.

---
### **12.7.  Errors Related to UTF-8**

클라이언트가 잘못된 UTF-8 문자열을 보내는 경우 서버는 NFS4ERR\_INVAL 오류를 반환할 수 있습니다. 여기에는 부적절한 접두사가 감지되는 경우와 개수에 전체 UCS\(Universal Multiple-Octet Coded Character Set\) 문자를 구성하지 않는 후행 바이트가 포함되는 경우가 포함됩니다.\(MAY\)

서버가 NFS4ERR\_INVAL 수신에 대한 응답으로 반환하지 않는 경우 유효한 UTF-8이 아닌 구성 요소 이름을 서버에서 처리하기 위한 요구 사항은 섹션 12.8에 설명되어 있습니다.

클라이언트가 제공한 문자열이 NFS4ERR\_INVAL로 거부되지 않지만 서버에서 해당 문자열의 값으로 지원하지 않는 문자를 포함하는 경우\(예: 슬래시가 포함된 이름 또는 UTF-8에서 변환할 때 16비트에 맞지 않는 문자\) 유니코드 코드 포인트로\) 서버는 NFS4ERR\_BADCHAR 오류를 반환해야 합니다.

UTF-8 문자열이 파일 이름으로 사용되고 파일 시스템이 이름 내의 모든 문자를 지원하지만 해당 특정 이름의 사용을 허용하지 않는 경우 서버는 NFS4ERR\_BADNAME 오류를 반환해야 합니다. 여기에는 "."의 파일 시스템 금지와 같은 상황이 포함됩니다. 특정 작업에 대한 파일 이름으로 ".." 및 유사한 제약 조건이 적용됩니다.

12.8. 유효한 UTF-8 문자열이 아닌 파일 구성 요소 이름을 허용하는 서버

이전에 설명한 대로 서버는 내보낸 실제 파일 시스템의 전체 또는 일부 하위 집합에서 유효한 UTF-8 문자열이 아닌 구성 요소 이름을 허용할 수 있습니다. 일반적인 패턴은 서버가 사용 중인 문자 세트를 인식하지 않고 구성 요소 이름을 해석되지 않은 바이트 문자열로 처리하는 UTF-8 비인식 물리적 파일 시스템을 사용하는 것입니다.\(MAY\)

이러한 서버는 유선으로 수신된 구성 요소 이름의 저장된 표현을 변경해서는 안 되며 구성 요소 이름 문자열의 옥텟별 비교를 사용하여 동등성을 결정해야 합니다\(문자열 비교에 대한 광범위한 개념과 반대\). 이는 서버가 사용되는 문자 인코딩을 알지 못하기 때문입니다.\(SHOULD NOT\)

그럼에도 불구하고 이러한 서버가 이전 단락에서 권장된 것보다 더 광범위한 문자열 동등 개념을 사용하는 경우 다음 고려 사항이 적용됩니다.

o 7비트 ASCII 외부에서 문자열 내용을 변경하는 문자열 처리는 일반적으로 문자 집합에 따라 다르므로 문자 집합을 알 수 없는 경우 일반적으로 안전하지 않습니다. 이 처리로 인해 파일 이름이 예기치 않은 방식으로 변경되어 파일을 생성하거나 이름을 바꾼 응용 프로그램이나 클라이언트 및 원래 파일 이름을 기대하는 다른 사용자가 파일에 액세스할 수 없게 될 수 있습니다. 따라서 이러한 처리를 수행하면 잘못된 문자열 수정이나 앨리어싱이 발생할 수 있으므로 수행해서는 안 됩니다.

o 유니코드 정규화는 특히 위험합니다.

- 처리에서는 문자열이 UTF-8이라고 가정합니다. 파일 이름을 만드는 데 다른 문자 집합이 사용되었기 때문에 이러한 가정이 거짓인 경우 정규화는 해당 문자 집합과 관련하여 파일 이름을 손상시켜 파일을 만든 응용 프로그램과 원래 파일 이름을 기대하는 다른 응용 프로그램이 파일에 액세스할 수 없도록 렌더링할 수 있습니다. 따라서 유니코드 정규화는 잘못된 문자열 수정이나 앨리어싱을 유발할 수 있으므로 수행해서는 안 됩니다.\(SHOULD NOT\)

위의 권장 사항을 따르지 않으면 결과적인 문자열 수정 및 별칭으로 인해 문제의 문자열에 따라 거짓 부정 및 거짓 긍정이 모두 발생할 수 있으며 이로 인해 권한 상승 및 서비스 거부와 같은 보안 문제가 발생할 수 있습니다\(\[RFC6943 참조\). \] 추가 논의를 위해\).

---
## **13.  Error Values**

NFS 오류 번호는 COMPOUND 또는 CB\_COMPOUND 요청 내에서 실패한 작업에 할당됩니다. COMPOUND 요청에는 결과가 COMPOUND 응답에 순차적으로 인코딩된 여러 NFS 작업이 포함되어 있습니다. 성공적인 작업의 결과는 NFS4\_OK 상태와 그 뒤에 인코딩된 작업 결과로 구성됩니다. NFS 작업이 실패하면 응답에 오류 상태가 입력되고 COMPOUND 요청이 종료됩니다.

---
### **13.1.  Error Definitions**

```text
       +-----------------------------+--------+-------------------+
       | Error                       | Number | Description       |
       +-----------------------------+--------+-------------------+
       | NFS4_OK                     | 0      | Section 13.1.3.1  |
       | NFS4ERR_ACCESS              | 13     | Section 13.1.6.1  |
       | NFS4ERR_ADMIN_REVOKED       | 10047  | Section 13.1.5.1  |
       | NFS4ERR_ATTRNOTSUPP         | 10032  | Section 13.1.11.1 |
       | NFS4ERR_BADCHAR             | 10040  | Section 13.1.7.1  |
       | NFS4ERR_BADHANDLE           | 10001  | Section 13.1.2.1  |
       | NFS4ERR_BADNAME             | 10041  | Section 13.1.7.2  |
       | NFS4ERR_BADOWNER            | 10039  | Section 13.1.11.2 |
       | NFS4ERR_BADTYPE             | 10007  | Section 13.1.4.1  |
       | NFS4ERR_BADXDR              | 10036  | Section 13.1.1.1  |
       | NFS4ERR_BAD_COOKIE          | 10003  | Section 13.1.1.2  |
       | NFS4ERR_BAD_RANGE           | 10042  | Section 13.1.8.1  |
       | NFS4ERR_BAD_SEQID           | 10026  | Section 13.1.8.2  |
       | NFS4ERR_BAD_STATEID         | 10025  | Section 13.1.5.2  |
       | NFS4ERR_CB_PATH_DOWN        | 10048  | Section 13.1.12.1 |
       | NFS4ERR_CLID_INUSE          | 10017  | Section 13.1.10.1 |
       | NFS4ERR_DEADLOCK            | 10045  | Section 13.1.8.3  |
       | NFS4ERR_DELAY               | 10008  | Section 13.1.1.3  |
       | NFS4ERR_DENIED              | 10010  | Section 13.1.8.4  |
       | NFS4ERR_DQUOT               | 69     | Section 13.1.4.2  |
       | NFS4ERR_EXIST               | 17     | Section 13.1.4.3  |
       | NFS4ERR_EXPIRED             | 10011  | Section 13.1.5.3  |
       | NFS4ERR_FBIG                | 27     | Section 13.1.4.4  |
       | NFS4ERR_FHEXPIRED           | 10014  | Section 13.1.2.2  |
       | NFS4ERR_FILE_OPEN           | 10046  | Section 13.1.4.5  |
       | NFS4ERR_GRACE               | 10013  | Section 13.1.9.1  |
       | NFS4ERR_INVAL               | 22     | Section 13.1.1.4  |
       | NFS4ERR_IO                  | 5      | Section 13.1.4.6  |
       | NFS4ERR_ISDIR               | 21     | Section 13.1.2.3  |
       | NFS4ERR_LEASE_MOVED         | 10031  | Section 13.1.5.4  |
       | NFS4ERR_LOCKED              | 10012  | Section 13.1.8.5  |
       | NFS4ERR_LOCKS_HELD          | 10037  | Section 13.1.8.6  |
       | NFS4ERR_LOCK_NOTSUPP        | 10043  | Section 13.1.8.7  |
       | NFS4ERR_LOCK_RANGE          | 10028  | Section 13.1.8.8  |
       | NFS4ERR_MINOR_VERS_MISMATCH | 10021  | Section 13.1.3.2  |
       | NFS4ERR_MLINK               | 31     | Section 13.1.4.7  |
       | NFS4ERR_MOVED               | 10019  | Section 13.1.2.4  |
       | NFS4ERR_NAMETOOLONG         | 63     | Section 13.1.7.3  |
       | NFS4ERR_NOENT               | 2      | Section 13.1.4.8  |
       | NFS4ERR_NOFILEHANDLE        | 10020  | Section 13.1.2.5  |
       | NFS4ERR_NOSPC               | 28     | Section 13.1.4.9  |
       | NFS4ERR_NOTDIR              | 20     | Section 13.1.2.6  |
       | NFS4ERR_NOTEMPTY            | 66     | Section 13.1.4.10 |

       | NFS4ERR_NOTSUPP             | 10004  | Section 13.1.1.5  |
       | NFS4ERR_NOT_SAME            | 10027  | Section 13.1.11.3 |
       | NFS4ERR_NO_GRACE            | 10033  | Section 13.1.9.2  |
       | NFS4ERR_NXIO                | 6      | Section 13.1.4.11 |
       | NFS4ERR_OLD_STATEID         | 10024  | Section 13.1.5.5  |
       | NFS4ERR_OPENMODE            | 10038  | Section 13.1.8.9  |
       | NFS4ERR_OP_ILLEGAL          | 10044  | Section 13.1.3.3  |
       | NFS4ERR_PERM                | 1      | Section 13.1.6.2  |
       | NFS4ERR_RECLAIM_BAD         | 10034  | Section 13.1.9.3  |
       | NFS4ERR_RECLAIM_CONFLICT    | 10035  | Section 13.1.9.4  |
       | NFS4ERR_RESOURCE            | 10018  | Section 13.1.3.4  |
       | NFS4ERR_RESTOREFH           | 10030  | Section 13.1.4.12 |
       | NFS4ERR_ROFS                | 30     | Section 13.1.4.13 |
       | NFS4ERR_SAME                | 10009  | Section 13.1.11.4 |
       | NFS4ERR_SERVERFAULT         | 10006  | Section 13.1.1.6  |
       | NFS4ERR_SHARE_DENIED        | 10015  | Section 13.1.8.10 |
       | NFS4ERR_STALE               | 70     | Section 13.1.2.7  |
       | NFS4ERR_STALE_CLIENTID      | 10022  | Section 13.1.10.2 |
       | NFS4ERR_STALE_STATEID       | 10023  | Section 13.1.5.6  |
       | NFS4ERR_SYMLINK             | 10029  | Section 13.1.2.8  |
       | NFS4ERR_TOOSMALL            | 10005  | Section 13.1.1.7  |
       | NFS4ERR_WRONGSEC            | 10016  | Section 13.1.6.3  |
       | NFS4ERR_XDEV                | 18     | Section 13.1.4.14 |
       +-----------------------------+--------+-------------------+

                    Table 6: Protocol Error Definitions
```

---
#### **13.1.1.  General Errors**

이 섹션에서는 다양한 목적에 적용할 수 있는 오류를 다룹니다.

---
##### **13.1.1.1.  NFS4ERR_BADXDR (Error Code 10036)**

이 작업의 인수가 XDR 정의에 지정된 인수와 일치하지 않습니다. 여기에는 모든 인수가 확인되기 전에 요청이 종료되는 상황이 포함됩니다. 이 오류는 고정 열거형\(부울 포함\)에 열거형에 유효하지 않은 입력 스트림 내 값이 있을 때 적용됩니다. 응답자는 작업 실행을 수행하기 전에 COMPOUND 프로시저에 대한 모든 작업을 사전 구문 분석하고 이 경우 RPC 수준 XDR 오류를 반환할 수 있습니다.

---
##### **13.1.1.2.  NFS4ERR_BAD_COOKIE (Error Code 10003)**

이 오류는 클라이언트가 제공한 일부 수량 또는 이전 호출을 위해 서버가 보낸 쿠키로 인덱싱된 정보 세트를 제공하는 작업에 사용됩니다. 값을 의도한 목적으로 사용할 수 없는 경우 이 오류가 발생합니다.

---
##### **13.1.1.3.  NFS4ERR_DELAY (Error Code 10008)**

여러 가지 이유로 인해 회신자는 합리적인 시간 내에 이 작업을 처리할 수 없었습니다. 클라이언트는 기다렸다가 새 RPC 트랜잭션 ID로 요청을 시도해야 합니다.

다음은 이러한 상황을 초래할 수 있는 두 가지 예입니다.

o 계층적 저장소를 지원하는 서버는 마이그레이션된 파일을 처리하라는 요청을 받습니다.

o 작업을 진행하려면 위임 회수가 필요하며 이 위임 회수를 기다리면 이 요청을 적시에 처리하는 것이 불가능합니다.

---
##### **13.1.1.4.  NFS4ERR_INVAL (Error Code 22)**

이 작업에 대한 인수는 요청에 대한 XDR 정의에 지정된 인수와 일치하더라도 어떤 이유로 유효하지 않습니다.

---
##### **13.1.1.5.  NFS4ERR_NOTSUPP (Error Code 10004)**

작업이 선택 사항이고 이 서버에서 지원되지 않거나 작업이 현재 마이너 버전에서 구현되어서는 안 되기 때문에 작업이 지원되지 않습니다.\(MUST NOT\)

---
##### **13.1.1.6.  NFS4ERR_SERVERFAULT (Error Code 10006)**

특정 법적 NFSv4 프로토콜 오류 값에 매핑되지 않는 오류가 서버에서 발생했습니다. 클라이언트는 이를 적절한 오류로 변환해야 합니다. UNIX 클라이언트는 이를 EIO로 변환하도록 선택할 수 있습니다.

---
##### **13.1.1.7.  NFS4ERR_TOOSMALL (Error Code 10005)**

이 오류는 클라이언트가 지정한 제한에 따라 작업이 가변적인 양의 데이터를 반환하는 경우에 사용됩니다. 반환된 데이터가 클라이언트가 지정한 제한 내에 들어갈 수 없는 경우 이 오류가 발생합니다.

---
#### **13.1.2.  Filehandle Errors**

이러한 오류는 현재 또는 저장된 파일 핸들 또는 현재 파일 핸들이 되도록 PUTFH에 전달된 파일 핸들이 어떤 방식으로든 유효하지 않은 상황을 처리합니다. 여기에는 파일 핸들이 일반적으로 유효한 파일 핸들이지만 현재 작업에 적합한 개체 유형이 아닌 상황이 포함됩니다.

오류 설명이 현재 또는 저장된 파일 핸들에 문제가 있음을 나타내는 경우, 파일 핸들이 해당 작업의 암시적 인수인 경우에만 조건을 확인한다는 점을 이해해야 합니다.

---
##### **13.1.2.1.  NFS4ERR_BADHANDLE (Error Code 10001)**

이 오류는 현재 서버의 잘못된 NFS 파일 핸들에 대해 생성됩니다. 현재 파일 핸들이 내부 일관성 검사에 실패했습니다. 일단 PUTFH에 의해 유효한 것으로 승인되면 후속 상태 변경으로 인해 파일 핸들이 이 오류를 생성할 수 없습니다.

---
##### **13.1.2.2.  NFS4ERR_FHEXPIRED (Error Code 10014)**

현재 작업의 인수인 현재 또는 저장된 파일 핸들은 일시적이며 서버에서 만료되었습니다.

---
##### **13.1.2.3.  NFS4ERR_ISDIR (Error Code 21)**

현재 작업에서 디렉터리가 이 작업의 대상으로 허용되지 않는 경우 현재 또는 저장된 파일 핸들은 디렉터리를 지정합니다.

---
##### **13.1.2.4.  NFS4ERR_MOVED (Error Code 10019)**

현재 파일 핸들 객체를 포함하는 파일 시스템이 서버에 없습니다. 다른 서버로 재배치 또는 마이그레이션되었거나 존재하지 않았을 수도 있습니다. 클라이언트는 현재 파일 핸들에 대한 "fs\_locations" 속성을 획득하여 새 파일 시스템 위치를 획득할 수 있습니다. 자세한 내용은 섹션 8을 참조하세요.

---
##### **13.1.2.5.  NFS4ERR_NOFILEHANDLE (Error Code 10020)**

현재 작업에 논리적 현재 또는 저장된 파일 핸들 값이 필요하며 설정되지 않았습니다. 이는 잘못된 COMPOUND 작업의 결과일 수 있습니다\(즉, 현재 파일 핸들을 설정해야 하는 작업 앞에 PUTFH 또는 PUTROOTFH가 없음\).

---
##### **13.1.2.6.  NFS4ERR_NOTDIR (Error Code 20)**

현재\(또는 저장된\) 파일 핸들은 디렉터리가 필요한 작업에 대한 디렉터리가 아닌 개체를 지정합니다.

---
##### **13.1.2.7.  NFS4ERR_STALE (Error Code 70)**

현재 작업에 대한 인수를 지정하는 현재 또는 저장된 파일 핸들 값이 잘못되었습니다. 해당 파일 핸들이 참조하는 파일 시스템 개체가 더 이상 존재하지 않거나 해당 개체에 대한 액세스가 취소되었습니다.

---
##### **13.1.2.8.  NFS4ERR_SYMLINK (Error Code 10029)**

현재 파일 핸들은 현재 작업이 대상으로 기호 링크를 허용하지 않는 경우 기호 링크를 지정합니다.

---
#### **13.1.3.  Compound Structure Errors**

이 섹션에서는 특정 작업보다는 COMPOUND 요청의 전체 구조\(COMPOUND와 CB\_COMPOUND를 모두 포함함을 의미함\)와 관련된 오류를 다룹니다.

COMPOUND 요청에 나타날 수 있는 작업에는 여러 가지 기본 제약이 있습니다.

---
##### **13.1.3.1.  NFS_OK (Error Code 0)**

NFS\_OK는 모든 구성 작업이 오류 없이 완료되었다는 점에서 작업이 성공적으로 완료되었음을 나타냅니다.

---
##### **13.1.3.2.  NFS4ERR_MINOR_VERS_MISMATCH (Error Code 10021)**

지정된 부 버전이 현재 수신기에서 지원하는 버전이 아닙니다. 이 값은 COMPOUND 프로시저의 전체 상태에서 반환되지만 결과는 결과 개수를 0으로 지정해야 하므로 특정 작업과 연결되지 않습니다.

---
##### **13.1.3.3.  NFS4ERR_OP_ILLEGAL (Error Code 10044)**

연산 코드는 현재 COMPOUND 프로시저에 대해 유효한 코드가 아닙니다. 이 오류와 일치하는 결과 스트림의 opcode는 잘못된 값이지만 요청 스트림에 나타나는 값은 다를 수 있습니다. 잘못된 값이 나타나고 응답자가 작업 실행을 수행하기 전에 COMPOUND 프로시저에 대한 모든 작업을 미리 구문 분석하는 경우 RPC 수준 XDR 오류가 반환될 수 있습니다.

---
##### **13.1.3.4.  NFS4ERR_RESOURCE (Error Code 10018)**

COMPOUND 프로시저 처리를 위해 서버는 사용 가능한 리소스를 모두 소모할 수 있으며 COMPOUND 프로시저 내에서 처리 작업을 계속할 수 없습니다. 이 오류는 COMPOUND 프로시저 처리와 관련된 리소스 소진 인스턴스의 서버에서 반환됩니다.

---
#### **13.1.4.  File System Errors**

이러한 오류는 프로토콜이나 NFSv4.x 기능이 아닌 기본 파일 시스템 구현에서 발생한 상황을 설명합니다.

---
##### **13.1.4.1.  NFS4ERR_BADTYPE (Error Code 10007)**

CREATE에 부적절한 유형이 지정된 객체를 생성하려고 했습니다. 유형이 정의되지 않았기 때문일 수 있습니다. 서버에서 지원하지 않는 유형이기 때문입니다. 또는 OPEN을 사용하여 파일 생성을 수행하는 일반 파일이나 명명된 속성과 같이 생성할 의도가 없는 유형이기 때문입니다.

---
##### **13.1.4.2.  NFS4ERR_DQUOT (Error Code 69)**

리소스\(할당량\) 하드 한도를 초과했습니다. 서버의 사용자 리소스 제한이 초과되었습니다.

---
##### **13.1.4.3.  NFS4ERR_EXIST (Error Code 17)**

지정된 대상 이름\(생성, 이름 변경 또는 링크 시\)의 파일 시스템 개체가 이미 존재합니다.

---
##### **13.1.4.4.  NFS4ERR_FBIG (Error Code 27)**

파일 시스템 개체가 너무 큽니다. 이 작업으로 인해 파일 시스템 개체가 서버 제한을 ​​초과하게 되었습니다.

---
##### **13.1.4.5.  NFS4ERR_FILE_OPEN (Error Code 10046)**

작업과 관련된 파일 시스템 개체가 현재 열려 있으므로 작업이 허용되지 않습니다. 서버는 열린 파일 시스템 개체에 대한 연결, 제거 또는 이름 변경을 허용하지 않을 수 있지만 필수는 아닙니다.

---
##### **13.1.4.6.  NFS4ERR_IO (Error Code 5)**

이는 파일 시스템이 복구를 제공할 수 없는 I/O 오류가 발생했음을 나타냅니다.

---
##### **13.1.4.7.  NFS4ERR_MLINK (Error Code 31)**

요청으로 인해 파일 시스템 개체가 초과해야 할 수 있는 하드 링크 수에 대한 서버 제한이 발생했을 수 있습니다.

---
##### **13.1.4.8.  NFS4ERR_NOENT (Error Code 2)**

이는 해당 파일이나 디렉터리가 없음을 나타냅니다. 지정된 이름으로 참조되는 파일 시스템 개체가 존재하지 않습니다.

---
##### **13.1.4.9.  NFS4ERR_NOSPC (Error Code 28)**

이는 장치에 남은 공간이 없음을 나타냅니다. 이 작업으로 인해 서버의 파일 시스템이 해당 제한을 초과했을 수 있습니다.

---
##### **13.1.4.10.  NFS4ERR_NOTEMPTY (Error Code 66)**

비어 있지 않은 디렉토리를 제거하려고 했습니다.

---
##### **13.1.4.11.  NFS4ERR_NXIO (Error Code 6)**

이는 I/O 오류를 나타냅니다. 해당 장치나 주소가 없습니다.

---
##### **13.1.4.12.  NFS4ERR_RESTOREFH (Error Code 10030)**

RESTOREFH 작업에 작업할 저장된 파일 핸들\(SAVEFH로 식별됨\)이 없습니다.

---
##### **13.1.4.13.  NFS4ERR_ROFS (Error Code 30)**

이는 읽기 전용 파일 시스템을 나타냅니다. 읽기 전용 파일 시스템에서 수정 작업을 시도했습니다.

---
##### **13.1.4.14.  NFS4ERR_XDEV (Error Code 18)**

이는 연결과 같이 부적절하게 경계를 넘는 작업을 수행하려는 시도를 나타냅니다. 예를 들어, 이는 다음 사이의 경계로 인해 발생할 수 있습니다.

o 파일 시스템\(fsid가 다른 경우\).

o 서로 다른 명명된 속성 디렉터리 또는 명명된

- 속성 디렉터리와 일반 디렉터리.

o 파일 시스템 구현이 별도의 것으로 처리하고\(예: 공간 계산 목적으로\) 영역 간의 교차 연결이 허용되지 않는 파일 시스템의 영역입니다.

---
#### **13.1.5.  State Management Errors**

이러한 오류는 지정된 작업에 전달된 stateid\(또는 stateid 중 하나\)에 문제가 있음을 나타냅니다. 여기에는 stateid가 유효하지 않은 상황과 stateid가 유효하지만 취소된 잠금 상태를 지정하는 상황이 포함됩니다. 작업에 따라 stateid가 유효한 경우 열기, 바이트 범위 잠금 또는 파일 위임을 지정할 수 있습니다.

---
##### **13.1.5.1.  NFS4ERR_ADMIN_REVOKED (Error Code 10047)**

stateid는 관리 상호 작용으로 인해\(아마도 임대가 유효한 동안\) 취소되었거나 임대가 유효한 동안 위임을 반환하지 못해 위임이 취소되었기 때문에 취소된 모든 유형의 잠금 상태를 지정합니다.

---
##### **13.1.5.2.  NFS4ERR_BAD_STATEID (Error Code 10025)**

현재 서버 인스턴스에서 생성된 상태 ID는 다음 중 하나에 사용되었습니다.

o 잠금 상태\(현재 또는

- 현재\(상태 소유자, 파일\) 쌍에 대해 대체됨\)

o "예의 잠금" 처리에서 발생할 수 있는 것처럼 임대 만료 후 해제되었지만 임대 취소 없이 잠금 상태를 지정합니다.

---
##### **13.1.5.3.  NFS4ERR_EXPIRED (Error Code 10011)**

stateid 또는 clientid는 임대 만료 직후 또는 나중에 충돌하는 잠금 요청 이후에 클라이언트의 임대 취소로 인해 취소되거나 해제된 모든 유형의 잠금 상태를 지정합니다.

---
##### **13.1.5.4.  NFS4ERR_LEASE_MOVED (Error Code 10031)**

갱신되는 임대는 새 서버로 마이그레이션된 파일 시스템과 연결됩니다.

---
##### **13.1.5.5.  NFS4ERR_OLD_STATEID (Error Code 10024)**

stateid에는 최신이 아닌 seqid 값이 제공됩니다.

---
##### **13.1.5.6.  NFS4ERR_STALE_STATEID (Error Code 10023)**

이전 서버 인스턴스에서 생성된 stateid가 사용되었습니다.

---
#### **13.1.6.  Security Errors**

NFSv4의 다양한 권한 관련 오류는 다음과 같습니다.

---
##### **13.1.6.1.  NFS4ERR_ACCESS (Error Code 13)**

이는 권한이 거부되었음을 나타냅니다. 호출자에게 요청된 작업을 수행할 수 있는 올바른 권한이 없습니다. 이를 소유자 또는 권한 있는 사용자 권한 실패로 제한하는 NFS4ERR\_PERM\(섹션 13.1.6.2\)과 대조해 보세요.

---
##### **13.1.6.2.  NFS4ERR_PERM (Error Code 1)**

이는 요청자가 소유자가 아님을 나타냅니다. 호출자가 권한 있는 사용자\(루트\)도 아니고 작업 대상의 소유자도 아니기 때문에 작업이 허용되지 않았습니다.

---
##### **13.1.6.3.  NFS4ERR_WRONGSEC (Error Code 10016)**

이는 클라이언트가 작업에 사용하는 보안 메커니즘이 서버의 보안 정책과 일치하지 않음을 나타냅니다. 클라이언트는 사용 중인 보안 메커니즘을 변경하고 작업을 다시 보내야 합니다. SECINFO를 사용하여 적절한 메커니즘을 결정할 수 있습니다.

---
#### **13.1.7.  Name Errors**

NFSv4의 이름은 UTF-8 문자열입니다. 문자열의 길이가 0이 아닌 경우 NFS4ERR\_INVAL 오류가 발생합니다. 유효한 UTF-8이 아닌 경우에도 NFS4ERR\_INVAL 오류가 발생하지만 서버는 다른 문자 형식의 파일 시스템을 수용할 수 있으므로 이 오류를 반환하지 않습니다. 이 외에도 이름과 관련된 특정 문제를 나타내는 다른 오류가 많이 있습니다.

---
##### **13.1.7.1.  NFS4ERR_BADCHAR (Error Code 10040)**

UTF-8 문자열에는 사용 중인 컨텍스트에서 서버가 지원하지 않는 문자가 포함되어 있습니다.

---
##### **13.1.7.2.  NFS4ERR_BADNAME (Error Code 10041)**

요청의 이름 문자열은 서버에서 지원하는 유효한 UTF-8 문자로 구성되어 있지만 해당 이름은 서버에서 현재 작업에 대한 유효한 이름으로 지원되지 않습니다. 예를 들어, 파일 시스템이 상위 디렉터리에 대한 링크에 해당 이름을 사용하는 서버에 ".."라는 이름의 파일이나 디렉터리를 만드는 경우가 있습니다.

문자열의 정규화 문제로 인해 이 오류가 반환되어서는 안 됩니다. 파일 시스템이 특정 정규화 형식으로 이름을 유지하는 경우 이름을 거부하는 것이 아니라 적절한 정규화를 수행하는 것은 서버의 책임입니다.

---
##### **13.1.7.3.  NFS4ERR_NAMETOOLONG (Error Code 63)**

작업의 파일 이름이 서버의 구현 제한을 초과하면 반환됩니다.

---
#### **13.1.8.  Locking Errors**

이 섹션에서는 잠금\(공유 예약 및 바이트 범위 잠금\)과 관련된 오류를 다룹니다. 잠금 회수 프로세스와 관련된 오류는 처리하지 않습니다. 이에 대해서는 다음 섹션에서 다룹니다.

---
##### **13.1.8.1.  NFS4ERR_BAD_RANGE (Error Code 10042)**

LOCK, LOCKT 또는 LOCKU 작업의 범위가 서버에 허용되는 오프셋 범위에 적합하지 않습니다. 예를 들어, 이 오류는 32비트 범위만 지원하는 서버가 해당 서버에서 처리할 수 없는 범위를 수신할 때 발생합니다. \(섹션 16.10.4 참조\)

---
##### **13.1.8.2.  NFS4ERR_BAD_SEQID (Error Code 10026)**

잠금 요청의 시퀀스 번호\(seqid\)는 다음 예상 번호도 아니고 처리된 마지막 번호도 아닙니다.

---
##### **13.1.8.3.  NFS4ERR_DEADLOCK (Error Code 10045)**

서버는 차단 잠금 요청에 대한 파일 잠금 교착 상태 조건을 확인할 수 있습니다.

---
##### **13.1.8.4.  NFS4ERR_DENIED (Error Code 10010)**

파일을 잠그려는 시도가 거부되었습니다. 이는 일시적인 조건일 수 있으므로 클라이언트는 잠금이 승인될 때까지 잠금 요청을 다시 보내는 것이 좋습니다. 재전송에 대한 설명은 섹션 9.4를 참조하세요.

---
##### **13.1.8.5.  NFS4ERR_LOCKED (Error Code 10012)**

I/O와 기존 잠금 사이에 충돌이 있는 파일에서 읽기 또는 쓰기 작업이 시도되었습니다.

o 수행 중인 I/O와 일치하지 않는 공유 예약이 있습니다.

o 읽거나 쓸 범위가 기존 필수 바이트 범위 잠금과 교차합니다.

---
##### **13.1.8.6.  NFS4ERR_LOCKS_HELD (Error Code 10037)**

예상치 못한 잠금으로 인해 작업이 차단되었습니다.

---
##### **13.1.8.7.  NFS4ERR_LOCK_NOTSUPP (Error Code 10043)**

서버가 잠금의 원자성 업그레이드 또는 다운그레이드를 지원하지 않는 경우 소유자가 이미 보유하고 있는 잠금 범위의 업그레이드 또는 다운그레이드를 요구하는 잠금 요청이 시도되었습니다.

---
##### **13.1.8.8.  NFS4ERR_LOCK_RANGE (Error Code 10028)**

잠금 요청은 현재 잠금 소유자에 대해 현재 보유하고 있는 잠금과 부분적으로 겹치는 범위에서 작동하고 있으며 단일 잠금과 정확하게 일치하지 않습니다. 여기서 서버는 이러한 유형의 요청을 지원하지 않으므로 POSIX 잠금 의미 체계를 구현하지 않습니다. fcntl\]. 이것이 LOCK, LOCKT 및 LOCKU에 각각 어떻게 적용되는지에 대한 설명은 섹션 16.10.5, 16.11.5 및 16.12.5를 참조하세요.

---
##### **13.1.8.9.  NFS4ERR_OPENMODE (Error Code 10038)**

클라이언트가 READ, WRITE, LOCK 또는 전달된 stateid에 의해 승인되지 않은 기타 작업\(예: 읽기 전용으로 열린 파일에 쓰기\)을 시도했습니다.

---
##### **13.1.8.10.  NFS4ERR_SHARE_DENIED (Error Code 10015)**

공유 충돌로 인해 공유 예약이 있는 파일을 열려는 시도가 실패했습니다.

---
#### **13.1.9.  Reclaim Errors**

이러한 오류는 서버를 다시 시작한 후 잠금을 회수하는 프로세스와 관련이 있습니다.

---
##### **13.1.9.1.  NFS4ERR_GRACE (Error Code 10013)**

서버가 복구 또는 유예 기간에 있습니다. 이 기간은 최소한 서버의 임대 기간과 일치해야 합니다. 해당 기간 동안에는 회수 이외의 잠금 요청을 승인할 수 없습니다.

---
##### **13.1.9.2.  NFS4ERR_NO_GRACE (Error Code 10033)**

서버는 이 클라이언트의 상태와 충돌할 수 있는 다른 클라이언트에 상태를 부여하지 않았다고 보장할 수 없습니다. 이 클라이언트에서는 더 이상 회수가 성공하지 않습니다.

---
##### **13.1.9.3.  NFS4ERR_RECLAIM_BAD (Error Code 10034)**

서버는 요청된 상태와 충돌할 수 있는 다른 클라이언트에 상태를 부여하지 않았다고 보장할 수 없습니다. 그러나 이는 이 호출에서 요청된 상태에만 적용됩니다. 추가 회수가 성공할 수 있습니다.

NFS4ERR\_RECLAIM\_CONFLICT와 달리 이는 올바르게 작동하는 클라이언트와 서버 사이에서 발생할 수 있습니다. 섹션 9.6.3.4에 설명된 "가장자리 조건" 시나리오에서는 클라이언트의 잠금이 여전히 유효한지 여부를 서버만 알 수 있게 하고 NFS4ERR\_RECLAIM\_BAD는 서버가 클라이언트에 잠금이 유효한지 알리는 방법입니다. 그렇지 않습니다.

---
##### **13.1.9.4.  NFS4ERR_RECLAIM_CONFLICT (Error Code 10035)**

클라이언트가 시도한 회수가 다른 클라이언트가 이미 보유하고 있는 잠금과 충돌합니다. NFS4ERR\_RECLAIM\_BAD와 달리 이는 클라이언트 중 하나가 잘못 동작하는 경우에만 발생할 수 있습니다.

---
#### **13.1.10.  Client Management Errors**

이 섹션에서는 클라이언트 ID를 생성하고 관리하는 데 사용되는 요청과 관련된 오류를 다룹니다.

---
##### **13.1.10.1.  NFS4ERR_CLID_INUSE (Error Code 10017)**

SETCLIENTID 작업에서 clientid가 이미 다른 클라이언트에서 사용 중임을 발견했습니다.

---
##### **13.1.10.2.  NFS4ERR_STALE_CLIENTID (Error Code 10022)**

서버에서 인식하지 못하는 클라이언트 ID가 잠금 또는 SETCLIENTID\_CONFIRM 요청에 사용되었습니다.

---
#### **13.1.11.  Attribute Handling Errors**

이 섹션에서는 NFSv4 내 속성 처리와 관련된 오류를 다룹니다.

---
##### **13.1.11.1.  NFS4ERR_ATTRNOTSUPP (Error Code 10032)**

지정된 속성은 서버에서 지원되지 않습니다. 이 오류는 GETATTR 작업에 의해 반환되어서는 안 됩니다.\(MUST NOT\)

---
##### **13.1.11.2.  NFS4ERR_BADOWNER (Error Code 10039)**

이 오류는 owner 또는 owner\_group 속성 값이나 ACL 속성 값 내 ace의 who 필드를 로컬 표현으로 변환할 수 없을 때 반환됩니다.

---
##### **13.1.11.3.  NFS4ERR_NOT_SAME (Error Code 10027)**

이 오류는 비교된 속성이 클라이언트 요청에 제공된 속성과 동일하지 않음을 나타내기 위해 VERIFY 작업에 의해 반환됩니다.

---
##### **13.1.11.4.  NFS4ERR_SAME (Error Code 10009)**

이 오류는 비교된 속성이 클라이언트 요청에 제공된 속성과 동일했음을 나타내기 위해 NVERIFY 작업에 의해 반환됩니다.

---
#### **13.1.12.  Miscellaneous Errors**
---
##### **13.1.12.1.  NFS4ERR_CB_PATH_DOWN (Error Code 10048)**

콜백 경로를 통해 클라이언트에 접속하는 중에 문제가 발생했습니다.

---
### **13.2.  Operations and Their Valid Errors**

이 섹션에는 각 프로토콜 작업에 대한 유효한 오류 반환을 제공하는 표가 포함되어 있습니다. 오류 코드 NFS4\_OK\(오류 없음을 나타냄\)는 나열되지 않지만 ILLEGAL을 제외한 모든 작업에서 반환될 수 있는 것으로 이해해야 합니다.

```text
   +---------------------+---------------------------------------------+
   | Operation           | Errors                                      |
   +---------------------+---------------------------------------------+
   | ACCESS              | NFS4ERR_ACCESS, NFS4ERR_BADHANDLE,          |
   |                     | NFS4ERR_BADXDR, NFS4ERR_DELAY,              |
   |                     | NFS4ERR_FHEXPIRED, NFS4ERR_INVAL,           |
   |                     | NFS4ERR_IO, NFS4ERR_MOVED,                  |
   |                     | NFS4ERR_NOFILEHANDLE, NFS4ERR_RESOURCE,     |
   |                     | NFS4ERR_SERVERFAULT, NFS4ERR_STALE          |
   |                     |                                             |
   | CLOSE               | NFS4ERR_ADMIN_REVOKED, NFS4ERR_BADHANDLE,   |
   |                     | NFS4ERR_BAD_SEQID, NFS4ERR_BAD_STATEID,     |
   |                     | NFS4ERR_BADXDR, NFS4ERR_DELAY,              |
   |                     | NFS4ERR_EXPIRED, NFS4ERR_FHEXPIRED,         |
   |                     | NFS4ERR_INVAL, NFS4ERR_ISDIR,               |
   |                     | NFS4ERR_LEASE_MOVED, NFS4ERR_LOCKS_HELD,    |
   |                     | NFS4ERR_MOVED, NFS4ERR_NOFILEHANDLE,        |
   |                     | NFS4ERR_OLD_STATEID, NFS4ERR_RESOURCE,      |
   |                     | NFS4ERR_SERVERFAULT, NFS4ERR_STALE,         |
   |                     | NFS4ERR_STALE_STATEID                       |
   |                     |                                             |
   | COMMIT              | NFS4ERR_ACCESS, NFS4ERR_BADHANDLE,          |
   |                     | NFS4ERR_BADXDR, NFS4ERR_DELAY,              |
   |                     | NFS4ERR_FHEXPIRED, NFS4ERR_INVAL,           |
   |                     | NFS4ERR_IO, NFS4ERR_ISDIR, NFS4ERR_MOVED,   |
   |                     | NFS4ERR_NOFILEHANDLE, NFS4ERR_RESOURCE,     |
   |                     | NFS4ERR_ROFS, NFS4ERR_SERVERFAULT,          |
   |                     | NFS4ERR_STALE, NFS4ERR_SYMLINK              |
   |                     |                                             |
   | CREATE              | NFS4ERR_ACCESS, NFS4ERR_ATTRNOTSUPP,        |
   |                     | NFS4ERR_BADCHAR, NFS4ERR_BADHANDLE,         |
   |                     | NFS4ERR_BADNAME, NFS4ERR_BADOWNER,          |
   |                     | NFS4ERR_BADTYPE, NFS4ERR_BADXDR,            |
   |                     | NFS4ERR_DELAY, NFS4ERR_DQUOT,               |
   |                     | NFS4ERR_EXIST, NFS4ERR_FHEXPIRED,           |
   |                     | NFS4ERR_INVAL, NFS4ERR_IO, NFS4ERR_MOVED,   |
   |                     | NFS4ERR_NAMETOOLONG, NFS4ERR_NOFILEHANDLE,  |
   |                     | NFS4ERR_NOSPC, NFS4ERR_NOTDIR,              |
   |                     | NFS4ERR_PERM, NFS4ERR_RESOURCE,             |
   |                     | NFS4ERR_ROFS, NFS4ERR_SERVERFAULT,          |
   |                     | NFS4ERR_STALE                               |

   |                     |                                             |
   | DELEGPURGE          | NFS4ERR_BADXDR, NFS4ERR_DELAY,              |
   |                     | NFS4ERR_LEASE_MOVED, NFS4ERR_NOTSUPP,       |
   |                     | NFS4ERR_RESOURCE, NFS4ERR_SERVERFAULT,      |
   |                     | NFS4ERR_STALE_CLIENTID                      |
   |                     |                                             |
   | DELEGRETURN         | NFS4ERR_ADMIN_REVOKED, NFS4ERR_BAD_STATEID, |
   |                     | NFS4ERR_BADXDR, NFS4ERR_DELAY,              |
   |                     | NFS4ERR_EXPIRED, NFS4ERR_INVAL,             |
   |                     | NFS4ERR_LEASE_MOVED, NFS4ERR_MOVED,         |
   |                     | NFS4ERR_NOFILEHANDLE, NFS4ERR_NOTSUPP,      |
   |                     | NFS4ERR_OLD_STATEID, NFS4ERR_RESOURCE,      |
   |                     | NFS4ERR_SERVERFAULT, NFS4ERR_STALE,         |
   |                     | NFS4ERR_STALE_STATEID                       |
   |                     |                                             |
   | GETATTR             | NFS4ERR_ACCESS, NFS4ERR_BADHANDLE,          |
   |                     | NFS4ERR_BADXDR, NFS4ERR_DELAY,              |
   |                     | NFS4ERR_FHEXPIRED, NFS4ERR_GRACE,           |
   |                     | NFS4ERR_INVAL, NFS4ERR_IO, NFS4ERR_MOVED,   |
   |                     | NFS4ERR_NOFILEHANDLE, NFS4ERR_RESOURCE,     |
   |                     | NFS4ERR_SERVERFAULT, NFS4ERR_STALE          |
   |                     |                                             |
   | GETFH               | NFS4ERR_BADHANDLE, NFS4ERR_FHEXPIRED,       |
   |                     | NFS4ERR_MOVED, NFS4ERR_NOFILEHANDLE,        |
   |                     | NFS4ERR_RESOURCE, NFS4ERR_SERVERFAULT,      |
   |                     | NFS4ERR_STALE                               |
   |                     |                                             |
   | ILLEGAL             | NFS4ERR_BADXDR, NFS4ERR_OP_ILLEGAL          |
   |                     |                                             |
   | LINK                | NFS4ERR_ACCESS, NFS4ERR_BADCHAR,            |
   |                     | NFS4ERR_BADHANDLE, NFS4ERR_BADNAME,         |
   |                     | NFS4ERR_BADXDR, NFS4ERR_DELAY,              |
   |                     | NFS4ERR_DQUOT, NFS4ERR_EXIST,               |
   |                     | NFS4ERR_FHEXPIRED, NFS4ERR_FILE_OPEN,       |
   |                     | NFS4ERR_INVAL, NFS4ERR_IO, NFS4ERR_ISDIR,   |
   |                     | NFS4ERR_MLINK, NFS4ERR_MOVED,               |
   |                     | NFS4ERR_NAMETOOLONG, NFS4ERR_NOENT,         |
   |                     | NFS4ERR_NOFILEHANDLE, NFS4ERR_NOSPC,        |
   |                     | NFS4ERR_NOTDIR, NFS4ERR_NOTSUPP,            |
   |                     | NFS4ERR_RESOURCE, NFS4ERR_ROFS,             |
   |                     | NFS4ERR_SERVERFAULT, NFS4ERR_STALE,         |
   |                     | NFS4ERR_WRONGSEC, NFS4ERR_XDEV              |
   |                     |                                             |

   | LOCK                | NFS4ERR_ACCESS, NFS4ERR_ADMIN_REVOKED,      |
   |                     | NFS4ERR_BADHANDLE, NFS4ERR_BAD_RANGE,       |
   |                     | NFS4ERR_BAD_SEQID, NFS4ERR_BAD_STATEID,     |
   |                     | NFS4ERR_BADXDR, NFS4ERR_DEADLOCK,           |
   |                     | NFS4ERR_DELAY, NFS4ERR_DENIED,              |
   |                     | NFS4ERR_EXPIRED, NFS4ERR_FHEXPIRED,         |
   |                     | NFS4ERR_GRACE, NFS4ERR_INVAL,               |
   |                     | NFS4ERR_ISDIR, NFS4ERR_LEASE_MOVED,         |
   |                     | NFS4ERR_LOCK_NOTSUPP, NFS4ERR_LOCK_RANGE,   |
   |                     | NFS4ERR_MOVED, NFS4ERR_NOFILEHANDLE,        |
   |                     | NFS4ERR_NO_GRACE, NFS4ERR_OLD_STATEID,      |
   |                     | NFS4ERR_OPENMODE, NFS4ERR_RECLAIM_BAD,      |
   |                     | NFS4ERR_RECLAIM_CONFLICT, NFS4ERR_RESOURCE, |
   |                     | NFS4ERR_SERVERFAULT, NFS4ERR_STALE,         |
   |                     | NFS4ERR_STALE_CLIENTID,                     |
   |                     | NFS4ERR_STALE_STATEID                       |
   |                     |                                             |
   | LOCKT               | NFS4ERR_ACCESS, NFS4ERR_BADHANDLE,          |
   |                     | NFS4ERR_BAD_RANGE, NFS4ERR_BADXDR,          |
   |                     | NFS4ERR_DELAY, NFS4ERR_DENIED,              |
   |                     | NFS4ERR_EXPIRED, NFS4ERR_FHEXPIRED,         |
   |                     | NFS4ERR_GRACE, NFS4ERR_INVAL,               |
   |                     | NFS4ERR_ISDIR, NFS4ERR_LEASE_MOVED,         |
   |                     | NFS4ERR_LOCK_RANGE, NFS4ERR_MOVED,          |
   |                     | NFS4ERR_NOFILEHANDLE, NFS4ERR_RESOURCE,     |
   |                     | NFS4ERR_SERVERFAULT, NFS4ERR_STALE,         |
   |                     | NFS4ERR_STALE_CLIENTID                      |
   |                     |                                             |
   | LOCKU               | NFS4ERR_ACCESS, NFS4ERR_ADMIN_REVOKED,      |
   |                     | NFS4ERR_BADHANDLE, NFS4ERR_BAD_RANGE,       |
   |                     | NFS4ERR_BAD_SEQID, NFS4ERR_BAD_STATEID,     |
   |                     | NFS4ERR_BADXDR, NFS4ERR_DELAY,              |
   |                     | NFS4ERR_EXPIRED, NFS4ERR_FHEXPIRED,         |
   |                     | NFS4ERR_GRACE, NFS4ERR_INVAL,               |
   |                     | NFS4ERR_ISDIR, NFS4ERR_LEASE_MOVED,         |
   |                     | NFS4ERR_LOCK_RANGE, NFS4ERR_MOVED,          |
   |                     | NFS4ERR_NOFILEHANDLE, NFS4ERR_OLD_STATEID,  |
   |                     | NFS4ERR_RESOURCE, NFS4ERR_SERVERFAULT,      |
   |                     | NFS4ERR_STALE, NFS4ERR_STALE_STATEID        |
   |                     |                                             |

   | LOOKUP              | NFS4ERR_ACCESS, NFS4ERR_BADCHAR,            |
   |                     | NFS4ERR_BADHANDLE, NFS4ERR_BADNAME,         |
   |                     | NFS4ERR_BADXDR, NFS4ERR_DELAY,              |
   |                     | NFS4ERR_FHEXPIRED, NFS4ERR_INVAL,           |
   |                     | NFS4ERR_IO, NFS4ERR_MOVED,                  |
   |                     | NFS4ERR_NAMETOOLONG, NFS4ERR_NOENT,         |
   |                     | NFS4ERR_NOFILEHANDLE, NFS4ERR_NOTDIR,       |
   |                     | NFS4ERR_RESOURCE, NFS4ERR_SERVERFAULT,      |
   |                     | NFS4ERR_STALE, NFS4ERR_SYMLINK,             |
   |                     | NFS4ERR_WRONGSEC                            |
   |                     |                                             |
   | LOOKUPP             | NFS4ERR_ACCESS, NFS4ERR_BADHANDLE,          |
   |                     | NFS4ERR_DELAY, NFS4ERR_FHEXPIRED,           |
   |                     | NFS4ERR_IO, NFS4ERR_MOVED, NFS4ERR_NOENT,   |
   |                     | NFS4ERR_NOFILEHANDLE, NFS4ERR_NOTDIR,       |
   |                     | NFS4ERR_RESOURCE, NFS4ERR_SERVERFAULT,      |
   |                     | NFS4ERR_STALE, NFS4ERR_SYMLINK,             |
   |                     | NFS4ERR_WRONGSEC                            |
   |                     |                                             |
   | NVERIFY             | NFS4ERR_ACCESS, NFS4ERR_ATTRNOTSUPP,        |
   |                     | NFS4ERR_BADCHAR, NFS4ERR_BADHANDLE,         |
   |                     | NFS4ERR_BADXDR, NFS4ERR_DELAY,              |
   |                     | NFS4ERR_FHEXPIRED, NFS4ERR_GRACE,           |
   |                     | NFS4ERR_INVAL, NFS4ERR_IO, NFS4ERR_MOVED,   |
   |                     | NFS4ERR_NOFILEHANDLE, NFS4ERR_SAME,         |
   |                     | NFS4ERR_SERVERFAULT, NFS4ERR_STALE          |
   |                     |                                             |
   | OPEN                | NFS4ERR_ACCESS, NFS4ERR_ADMIN_REVOKED,      |
   |                     | NFS4ERR_ATTRNOTSUPP, NFS4ERR_BADCHAR,       |
   |                     | NFS4ERR_BADHANDLE, NFS4ERR_BADNAME,         |
   |                     | NFS4ERR_BADOWNER, NFS4ERR_BAD_SEQID,        |
   |                     | NFS4ERR_BAD_STATEID, NFS4ERR_BADXDR,        |
   |                     | NFS4ERR_DELAY, NFS4ERR_DQUOT,               |
   |                     | NFS4ERR_EXIST, NFS4ERR_EXPIRED,             |
   |                     | NFS4ERR_FBIG, NFS4ERR_FHEXPIRED,            |
   |                     | NFS4ERR_GRACE, NFS4ERR_INVAL, NFS4ERR_IO,   |
   |                     | NFS4ERR_ISDIR, NFS4ERR_MOVED,               |
   |                     | NFS4ERR_NAMETOOLONG, NFS4ERR_NOENT,         |
   |                     | NFS4ERR_NOFILEHANDLE, NFS4ERR_NO_GRACE,     |
   |                     | NFS4ERR_NOSPC, NFS4ERR_NOTDIR,              |
   |                     | NFS4ERR_NOTSUPP, NFS4ERR_OLD_STATEID,       |
   |                     | NFS4ERR_PERM, NFS4ERR_RECLAIM_BAD,          |
   |                     | NFS4ERR_RECLAIM_CONFLICT, NFS4ERR_RESOURCE, |
   |                     | NFS4ERR_ROFS, NFS4ERR_SERVERFAULT,          |
   |                     | NFS4ERR_SHARE_DENIED, NFS4ERR_STALE,        |
   |                     | NFS4ERR_STALE_CLIENTID, NFS4ERR_SYMLINK,    |
   |                     | NFS4ERR_WRONGSEC                            |
   |                     |                                             |

   | OPENATTR            | NFS4ERR_ACCESS, NFS4ERR_BADHANDLE,          |
   |                     | NFS4ERR_BADXDR, NFS4ERR_DELAY,              |
   |                     | NFS4ERR_DQUOT, NFS4ERR_FHEXPIRED,           |
   |                     | NFS4ERR_IO, NFS4ERR_MOVED, NFS4ERR_NOENT,   |
   |                     | NFS4ERR_NOFILEHANDLE, NFS4ERR_NOSPC,        |
   |                     | NFS4ERR_NOTSUPP, NFS4ERR_RESOURCE,          |
   |                     | NFS4ERR_ROFS, NFS4ERR_SERVERFAULT,          |
   |                     | NFS4ERR_STALE                               |
   |                     |                                             |
   | OPEN_CONFIRM        | NFS4ERR_ADMIN_REVOKED, NFS4ERR_BADHANDLE,   |
   |                     | NFS4ERR_BAD_SEQID, NFS4ERR_BAD_STATEID,     |
   |                     | NFS4ERR_BADXDR, NFS4ERR_EXPIRED,            |
   |                     | NFS4ERR_FHEXPIRED, NFS4ERR_INVAL,           |
   |                     | NFS4ERR_ISDIR, NFS4ERR_LEASE_MOVED,         |
   |                     | NFS4ERR_MOVED, NFS4ERR_NOFILEHANDLE,        |
   |                     | NFS4ERR_OLD_STATEID, NFS4ERR_RESOURCE,      |
   |                     | NFS4ERR_SERVERFAULT, NFS4ERR_STALE,         |
   |                     | NFS4ERR_STALE_STATEID                       |
   |                     |                                             |
   | OPEN_DOWNGRADE      | NFS4ERR_ADMIN_REVOKED, NFS4ERR_BADHANDLE,   |
   |                     | NFS4ERR_BAD_SEQID, NFS4ERR_BAD_STATEID,     |
   |                     | NFS4ERR_BADXDR, NFS4ERR_DELAY,              |
   |                     | NFS4ERR_EXPIRED, NFS4ERR_FHEXPIRED,         |
   |                     | NFS4ERR_INVAL, NFS4ERR_LEASE_MOVED,         |
   |                     | NFS4ERR_LOCKS_HELD, NFS4ERR_MOVED,          |
   |                     | NFS4ERR_NOFILEHANDLE, NFS4ERR_OLD_STATEID,  |
   |                     | NFS4ERR_RESOURCE, NFS4ERR_ROFS,             |
   |                     | NFS4ERR_SERVERFAULT, NFS4ERR_STALE,         |
   |                     | NFS4ERR_STALE_STATEID                       |
   |                     |                                             |
   | PUTFH               | NFS4ERR_BADHANDLE, NFS4ERR_BADXDR,          |
   |                     | NFS4ERR_DELAY, NFS4ERR_FHEXPIRED,           |
   |                     | NFS4ERR_MOVED, NFS4ERR_SERVERFAULT,         |
   |                     | NFS4ERR_STALE, NFS4ERR_WRONGSEC             |
   |                     |                                             |
   | PUTPUBFH            | NFS4ERR_DELAY, NFS4ERR_SERVERFAULT,         |
   |                     | NFS4ERR_WRONGSEC                            |
   |                     |                                             |
   | PUTROOTFH           | NFS4ERR_DELAY, NFS4ERR_SERVERFAULT,         |
   |                     | NFS4ERR_WRONGSEC                            |
   |                     |                                             |

   | READ                | NFS4ERR_ACCESS, NFS4ERR_ADMIN_REVOKED,      |
   |                     | NFS4ERR_BADHANDLE, NFS4ERR_BAD_STATEID,     |
   |                     | NFS4ERR_BADXDR, NFS4ERR_DELAY,              |
   |                     | NFS4ERR_EXPIRED, NFS4ERR_FHEXPIRED,         |
   |                     | NFS4ERR_GRACE, NFS4ERR_INVAL, NFS4ERR_IO,   |
   |                     | NFS4ERR_ISDIR, NFS4ERR_LEASE_MOVED,         |
   |                     | NFS4ERR_LOCKED, NFS4ERR_MOVED,              |
   |                     | NFS4ERR_NOFILEHANDLE, NFS4ERR_OLD_STATEID,  |
   |                     | NFS4ERR_OPENMODE, NFS4ERR_RESOURCE,         |
   |                     | NFS4ERR_SERVERFAULT, NFS4ERR_STALE,         |
   |                     | NFS4ERR_STALE_STATEID, NFS4ERR_SYMLINK      |
   |                     |                                             |
   | READDIR             | NFS4ERR_ACCESS, NFS4ERR_BAD_COOKIE,         |
   |                     | NFS4ERR_BADHANDLE, NFS4ERR_BADXDR,          |
   |                     | NFS4ERR_DELAY, NFS4ERR_FHEXPIRED,           |
   |                     | NFS4ERR_INVAL, NFS4ERR_IO, NFS4ERR_MOVED,   |
   |                     | NFS4ERR_NOFILEHANDLE, NFS4ERR_NOTDIR,       |
   |                     | NFS4ERR_NOT_SAME, NFS4ERR_RESOURCE,         |
   |                     | NFS4ERR_SERVERFAULT, NFS4ERR_STALE,         |
   |                     | NFS4ERR_TOOSMALL                            |
   |                     |                                             |
   | READLINK            | NFS4ERR_ACCESS, NFS4ERR_BADHANDLE,          |
   |                     | NFS4ERR_DELAY, NFS4ERR_FHEXPIRED,           |
   |                     | NFS4ERR_INVAL, NFS4ERR_IO, NFS4ERR_ISDIR,   |
   |                     | NFS4ERR_MOVED, NFS4ERR_NOFILEHANDLE,        |
   |                     | NFS4ERR_NOTSUPP, NFS4ERR_RESOURCE,          |
   |                     | NFS4ERR_SERVERFAULT, NFS4ERR_STALE          |
   |                     |                                             |
   | RELEASE_LOCKOWNER   | NFS4ERR_BADXDR, NFS4ERR_EXPIRED,            |
   |                     | NFS4ERR_LEASE_MOVED, NFS4ERR_LOCKS_HELD,    |
   |                     | NFS4ERR_RESOURCE, NFS4ERR_SERVERFAULT,      |
   |                     | NFS4ERR_STALE_CLIENTID                      |
   |                     |                                             |
   | REMOVE              | NFS4ERR_ACCESS, NFS4ERR_BADCHAR,            |
   |                     | NFS4ERR_BADHANDLE, NFS4ERR_BADNAME,         |
   |                     | NFS4ERR_BADXDR, NFS4ERR_DELAY,              |
   |                     | NFS4ERR_FHEXPIRED, NFS4ERR_FILE_OPEN,       |
   |                     | NFS4ERR_GRACE, NFS4ERR_INVAL, NFS4ERR_IO,   |
   |                     | NFS4ERR_MOVED, NFS4ERR_NAMETOOLONG,         |
   |                     | NFS4ERR_NOENT, NFS4ERR_NOFILEHANDLE,        |
   |                     | NFS4ERR_NOTDIR, NFS4ERR_NOTEMPTY,           |
   |                     | NFS4ERR_RESOURCE, NFS4ERR_ROFS,             |
   |                     | NFS4ERR_SERVERFAULT, NFS4ERR_STALE          |
   |                     |                                             |

   | RENAME              | NFS4ERR_ACCESS, NFS4ERR_BADCHAR,            |
   |                     | NFS4ERR_BADHANDLE, NFS4ERR_BADNAME,         |
   |                     | NFS4ERR_BADXDR, NFS4ERR_DELAY,              |
   |                     | NFS4ERR_DQUOT, NFS4ERR_EXIST,               |
   |                     | NFS4ERR_FHEXPIRED, NFS4ERR_FILE_OPEN,       |
   |                     | NFS4ERR_GRACE, NFS4ERR_INVAL, NFS4ERR_IO,   |
   |                     | NFS4ERR_MOVED, NFS4ERR_NAMETOOLONG,         |
   |                     | NFS4ERR_NOENT, NFS4ERR_NOFILEHANDLE,        |
   |                     | NFS4ERR_NOSPC, NFS4ERR_NOTDIR,              |
   |                     | NFS4ERR_NOTEMPTY, NFS4ERR_RESOURCE,         |
   |                     | NFS4ERR_ROFS, NFS4ERR_SERVERFAULT,          |
   |                     | NFS4ERR_STALE, NFS4ERR_WRONGSEC,            |
   |                     | NFS4ERR_XDEV                                |
   |                     |                                             |
   | RENEW               | NFS4ERR_ACCESS, NFS4ERR_BADXDR,             |
   |                     | NFS4ERR_CB_PATH_DOWN, NFS4ERR_EXPIRED,      |
   |                     | NFS4ERR_LEASE_MOVED, NFS4ERR_RESOURCE,      |
   |                     | NFS4ERR_SERVERFAULT, NFS4ERR_STALE_CLIENTID |
   |                     |                                             |
   | RESTOREFH           | NFS4ERR_BADHANDLE, NFS4ERR_FHEXPIRED,       |
   |                     | NFS4ERR_MOVED, NFS4ERR_RESOURCE,            |
   |                     | NFS4ERR_RESTOREFH, NFS4ERR_SERVERFAULT,     |
   |                     | NFS4ERR_STALE, NFS4ERR_WRONGSEC             |
   |                     |                                             |
   | SAVEFH              | NFS4ERR_BADHANDLE, NFS4ERR_FHEXPIRED,       |
   |                     | NFS4ERR_MOVED, NFS4ERR_NOFILEHANDLE,        |
   |                     | NFS4ERR_RESOURCE, NFS4ERR_SERVERFAULT,      |
   |                     | NFS4ERR_STALE                               |
   |                     |                                             |
   | SECINFO             | NFS4ERR_ACCESS, NFS4ERR_BADCHAR,            |
   |                     | NFS4ERR_BADHANDLE, NFS4ERR_BADNAME,         |
   |                     | NFS4ERR_BADXDR, NFS4ERR_DELAY,              |
   |                     | NFS4ERR_FHEXPIRED, NFS4ERR_INVAL,           |
   |                     | NFS4ERR_MOVED, NFS4ERR_NAMETOOLONG,         |
   |                     | NFS4ERR_NOENT, NFS4ERR_NOFILEHANDLE,        |
   |                     | NFS4ERR_NOTDIR, NFS4ERR_RESOURCE,           |
   |                     | NFS4ERR_SERVERFAULT, NFS4ERR_STALE          |
   |                     |                                             |

   | SETATTR             | NFS4ERR_ACCESS, NFS4ERR_ADMIN_REVOKED,      |
   |                     | NFS4ERR_ATTRNOTSUPP, NFS4ERR_BADCHAR,       |
   |                     | NFS4ERR_BADHANDLE, NFS4ERR_BADOWNER,        |
   |                     | NFS4ERR_BAD_STATEID, NFS4ERR_BADXDR,        |
   |                     | NFS4ERR_DELAY, NFS4ERR_DQUOT,               |
   |                     | NFS4ERR_EXPIRED, NFS4ERR_FBIG,              |
   |                     | NFS4ERR_FHEXPIRED, NFS4ERR_GRACE,           |
   |                     | NFS4ERR_INVAL, NFS4ERR_IO, NFS4ERR_ISDIR,   |
   |                     | NFS4ERR_LEASE_MOVED, NFS4ERR_LOCKED,        |
   |                     | NFS4ERR_MOVED, NFS4ERR_NOFILEHANDLE,        |
   |                     | NFS4ERR_NOSPC, NFS4ERR_OLD_STATEID,         |
   |                     | NFS4ERR_OPENMODE, NFS4ERR_PERM,             |
   |                     | NFS4ERR_RESOURCE, NFS4ERR_ROFS,             |
   |                     | NFS4ERR_SERVERFAULT, NFS4ERR_STALE,         |
   |                     | NFS4ERR_STALE_STATEID                       |
   |                     |                                             |
   | SETCLIENTID         | NFS4ERR_BADXDR, NFS4ERR_CLID_INUSE,         |
   |                     | NFS4ERR_DELAY, NFS4ERR_INVAL,               |
   |                     | NFS4ERR_RESOURCE, NFS4ERR_SERVERFAULT       |
   |                     |                                             |
   | SETCLIENTID_CONFIRM | NFS4ERR_BADXDR, NFS4ERR_CLID_INUSE,         |
   |                     | NFS4ERR_DELAY, NFS4ERR_RESOURCE,            |
   |                     | NFS4ERR_SERVERFAULT, NFS4ERR_STALE_CLIENTID |
   |                     |                                             |
   | VERIFY              | NFS4ERR_ACCESS, NFS4ERR_ATTRNOTSUPP,        |
   |                     | NFS4ERR_BADCHAR, NFS4ERR_BADHANDLE,         |
   |                     | NFS4ERR_BADXDR, NFS4ERR_DELAY,              |
   |                     | NFS4ERR_FHEXPIRED, NFS4ERR_GRACE,           |
   |                     | NFS4ERR_INVAL, NFS4ERR_IO, NFS4ERR_MOVED,   |
   |                     | NFS4ERR_NOFILEHANDLE, NFS4ERR_NOT_SAME,     |
   |                     | NFS4ERR_RESOURCE, NFS4ERR_SERVERFAULT,      |
   |                     | NFS4ERR_STALE                               |
   |                     |                                             |

   | WRITE               | NFS4ERR_ACCESS, NFS4ERR_ADMIN_REVOKED,      |
   |                     | NFS4ERR_BADHANDLE, NFS4ERR_BAD_STATEID,     |
   |                     | NFS4ERR_BADXDR, NFS4ERR_DELAY,              |
   |                     | NFS4ERR_DQUOT, NFS4ERR_EXPIRED,             |
   |                     | NFS4ERR_FBIG, NFS4ERR_FHEXPIRED,            |
   |                     | NFS4ERR_GRACE, NFS4ERR_INVAL, NFS4ERR_IO,   |
   |                     | NFS4ERR_ISDIR, NFS4ERR_LEASE_MOVED,         |
   |                     | NFS4ERR_LOCKED, NFS4ERR_MOVED,              |
   |                     | NFS4ERR_NOFILEHANDLE, NFS4ERR_NOSPC,        |
   |                     | NFS4ERR_NXIO, NFS4ERR_OLD_STATEID,          |
   |                     | NFS4ERR_OPENMODE, NFS4ERR_RESOURCE,         |
   |                     | NFS4ERR_ROFS, NFS4ERR_SERVERFAULT,          |
   |                     | NFS4ERR_STALE, NFS4ERR_STALE_STATEID,       |
   |                     | NFS4ERR_SYMLINK                             |
   |                     |                                             |
   +---------------------+---------------------------------------------+
```

- 표 7: 각 프로토콜 작업에 대한 유효한 오류 반환

---
### **13.3.  Callback Operations and Their Valid Errors**

이 섹션에는 각 콜백 작업에 대한 유효한 오류 반환을 제공하는 표가 포함되어 있습니다. 오류 코드 NFS4\_OK\(오류 없음을 나타냄\)는 나열되지 않지만 CB\_ILLEGAL을 제외한 모든 콜백 작업에서 반환될 수 있는 것으로 이해해야 합니다.

```text
   +-------------+-----------------------------------------------------+
   | Callback    | Errors                                              |
   | Operation   |                                                     |
   +-------------+-----------------------------------------------------+
   | CB_GETATTR  | NFS4ERR_BADHANDLE, NFS4ERR_BADXDR, NFS4ERR_DELAY,   |
   |             | NFS4ERR_INVAL, NFS4ERR_SERVERFAULT                  |
   |             |                                                     |
   | CB_ILLEGAL  | NFS4ERR_BADXDR, NFS4ERR_OP_ILLEGAL                  |
   |             |                                                     |
   | CB_RECALL   | NFS4ERR_BADHANDLE, NFS4ERR_BAD_STATEID,             |
   |             | NFS4ERR_BADXDR, NFS4ERR_DELAY, NFS4ERR_SERVERFAULT  |
   |             |                                                     |
   +-------------+-----------------------------------------------------+

     Table 8: Valid Error Returns for Each Protocol Callback Operation
```

---
### **13.4.  Errors and the Operations That Use Them**

```text
   +--------------------------+----------------------------------------+
   | Error                    | Operations                             |
   +--------------------------+----------------------------------------+
   | NFS4ERR_ACCESS           | ACCESS, COMMIT, CREATE, GETATTR, LINK, |
   |                          | LOCK, LOCKT, LOCKU, LOOKUP, LOOKUPP,   |
   |                          | NVERIFY, OPEN, OPENATTR, READ,         |
   |                          | READDIR, READLINK, REMOVE, RENAME,     |
   |                          | RENEW, SECINFO, SETATTR, VERIFY, WRITE |
   |                          |                                        |
   | NFS4ERR_ADMIN_REVOKED    | CLOSE, DELEGRETURN, LOCK, LOCKU, OPEN, |
   |                          | OPEN_CONFIRM, OPEN_DOWNGRADE, READ,    |
   |                          | SETATTR, WRITE                         |
   |                          |                                        |
   | NFS4ERR_ATTRNOTSUPP      | CREATE, NVERIFY, OPEN, SETATTR, VERIFY |
   |                          |                                        |
   | NFS4ERR_BADCHAR          | CREATE, LINK, LOOKUP, NVERIFY, OPEN,   |
   |                          | REMOVE, RENAME, SECINFO, SETATTR,      |
   |                          | VERIFY                                 |
   |                          |                                        |
   | NFS4ERR_BADHANDLE        | ACCESS, CB_GETATTR, CB_RECALL, CLOSE,  |
   |                          | COMMIT, CREATE, GETATTR, GETFH, LINK,  |
   |                          | LOCK, LOCKT, LOCKU, LOOKUP, LOOKUPP,   |
   |                          | NVERIFY, OPEN, OPENATTR, OPEN_CONFIRM, |
   |                          | OPEN_DOWNGRADE, PUTFH, READ, READDIR,  |
   |                          | READLINK, REMOVE, RENAME, RESTOREFH,   |
   |                          | SAVEFH, SECINFO, SETATTR, VERIFY,      |
   |                          | WRITE                                  |
   |                          |                                        |
   | NFS4ERR_BADNAME          | CREATE, LINK, LOOKUP, OPEN, REMOVE,    |
   |                          | RENAME, SECINFO                        |
   |                          |                                        |
   | NFS4ERR_BADOWNER         | CREATE, OPEN, SETATTR                  |
   |                          |                                        |
   | NFS4ERR_BADTYPE          | CREATE                                 |
   |                          |                                        |
   | NFS4ERR_BADXDR           | ACCESS, CB_GETATTR, CB_ILLEGAL,        |
   |                          | CB_RECALL, CLOSE, COMMIT, CREATE,      |
   |                          | DELEGPURGE, DELEGRETURN, GETATTR,      |
   |                          | ILLEGAL, LINK, LOCK, LOCKT, LOCKU,     |
   |                          | LOOKUP, NVERIFY, OPEN, OPENATTR,       |
   |                          | OPEN_CONFIRM, OPEN_DOWNGRADE, PUTFH,   |
   |                          | READ, READDIR, RELEASE_LOCKOWNER,      |
   |                          | REMOVE, RENAME, RENEW, SECINFO,        |
   |                          | SETATTR, SETCLIENTID,                  |
   |                          | SETCLIENTID_CONFIRM, VERIFY, WRITE     |
   |                          |                                        |

   | NFS4ERR_BAD_COOKIE       | READDIR                                |
   |                          |                                        |
   | NFS4ERR_BAD_RANGE        | LOCK, LOCKT, LOCKU                     |
   |                          |                                        |
   | NFS4ERR_BAD_SEQID        | CLOSE, LOCK, LOCKU, OPEN,              |
   |                          | OPEN_CONFIRM, OPEN_DOWNGRADE           |
   |                          |                                        |
   | NFS4ERR_BAD_STATEID      | CB_RECALL, CLOSE, DELEGRETURN, LOCK,   |
   |                          | LOCKU, OPEN, OPEN_CONFIRM,             |
   |                          | OPEN_DOWNGRADE, READ, SETATTR, WRITE   |
   |                          |                                        |
   | NFS4ERR_CB_PATH_DOWN     | RENEW                                  |
   |                          |                                        |
   | NFS4ERR_CLID_INUSE       | SETCLIENTID, SETCLIENTID_CONFIRM       |
   |                          |                                        |
   | NFS4ERR_DEADLOCK         | LOCK                                   |
   |                          |                                        |
   | NFS4ERR_DELAY            | ACCESS, CB_GETATTR, CB_RECALL, CLOSE,  |
   |                          | COMMIT, CREATE, DELEGPURGE,            |
   |                          | DELEGRETURN, GETATTR, LINK, LOCK,      |
   |                          | LOCKT, LOCKU, LOOKUP, LOOKUPP,         |
   |                          | NVERIFY, OPEN, OPENATTR,               |
   |                          | OPEN_DOWNGRADE, PUTFH, PUTPUBFH,       |
   |                          | PUTROOTFH, READ, READDIR, READLINK,    |
   |                          | REMOVE, RENAME, SECINFO, SETATTR,      |
   |                          | SETCLIENTID, SETCLIENTID_CONFIRM,      |
   |                          | VERIFY, WRITE                          |
   |                          |                                        |
   | NFS4ERR_DENIED           | LOCK, LOCKT                            |
   |                          |                                        |
   | NFS4ERR_DQUOT            | CREATE, LINK, OPEN, OPENATTR, RENAME,  |
   |                          | SETATTR, WRITE                         |
   |                          |                                        |
   | NFS4ERR_EXIST            | CREATE, LINK, OPEN, RENAME             |
   |                          |                                        |
   | NFS4ERR_EXPIRED          | CLOSE, DELEGRETURN, LOCK, LOCKT,       |
   |                          | LOCKU, OPEN, OPEN_CONFIRM,             |
   |                          | OPEN_DOWNGRADE, READ,                  |
   |                          | RELEASE_LOCKOWNER, RENEW, SETATTR,     |
   |                          | WRITE                                  |
   |                          |                                        |
   | NFS4ERR_FBIG             | OPEN, SETATTR, WRITE                   |
   |                          |                                        |

   | NFS4ERR_FHEXPIRED        | ACCESS, CLOSE, COMMIT, CREATE,         |
   |                          | GETATTR, GETFH, LINK, LOCK, LOCKT,     |
   |                          | LOCKU, LOOKUP, LOOKUPP, NVERIFY, OPEN, |
   |                          | OPENATTR, OPEN_CONFIRM,                |
   |                          | OPEN_DOWNGRADE, PUTFH, READ, READDIR,  |
   |                          | READLINK, REMOVE, RENAME, RESTOREFH,   |
   |                          | SAVEFH, SECINFO, SETATTR, VERIFY,      |
   |                          | WRITE                                  |
   |                          |                                        |
   | NFS4ERR_FILE_OPEN        | LINK, REMOVE, RENAME                   |
   |                          |                                        |
   | NFS4ERR_GRACE            | GETATTR, LOCK, LOCKT, LOCKU, NVERIFY,  |
   |                          | OPEN, READ, REMOVE, RENAME, SETATTR,   |
   |                          | VERIFY, WRITE                          |
   |                          |                                        |
   | NFS4ERR_INVAL            | ACCESS, CB_GETATTR, CLOSE, COMMIT,     |
   |                          | CREATE, DELEGRETURN, GETATTR, LINK,    |
   |                          | LOCK, LOCKT, LOCKU, LOOKUP, NVERIFY,   |
   |                          | OPEN, OPEN_CONFIRM, OPEN_DOWNGRADE,    |
   |                          | READ, READDIR, READLINK, REMOVE,       |
   |                          | RENAME, SECINFO, SETATTR, SETCLIENTID, |
   |                          | VERIFY, WRITE                          |
   |                          |                                        |
   | NFS4ERR_IO               | ACCESS, COMMIT, CREATE, GETATTR, LINK, |
   |                          | LOOKUP, LOOKUPP, NVERIFY, OPEN,        |
   |                          | OPENATTR, READ, READDIR, READLINK,     |
   |                          | REMOVE, RENAME, SETATTR, VERIFY, WRITE |
   |                          |                                        |
   | NFS4ERR_ISDIR            | CLOSE, COMMIT, LINK, LOCK, LOCKT,      |
   |                          | LOCKU, OPEN, OPEN_CONFIRM, READ,       |
   |                          | READLINK, SETATTR, WRITE               |
   |                          |                                        |
   | NFS4ERR_LEASE_MOVED      | CLOSE, DELEGPURGE, DELEGRETURN, LOCK,  |
   |                          | LOCKT, LOCKU, OPEN_CONFIRM,            |
   |                          | OPEN_DOWNGRADE, READ,                  |
   |                          | RELEASE_LOCKOWNER, RENEW, SETATTR,     |
   |                          | WRITE                                  |
   |                          |                                        |
   | NFS4ERR_LOCKED           | READ, SETATTR, WRITE                   |
   |                          |                                        |
   | NFS4ERR_LOCKS_HELD       | CLOSE, OPEN_DOWNGRADE,                 |
   |                          | RELEASE_LOCKOWNER                      |
   |                          |                                        |
   | NFS4ERR_LOCK_NOTSUPP     | LOCK                                   |
   |                          |                                        |
   | NFS4ERR_LOCK_RANGE       | LOCK, LOCKT, LOCKU                     |
   |                          |                                        |
   | NFS4ERR_MLINK            | LINK                                   |

   |                          |                                        |
   | NFS4ERR_MOVED            | ACCESS, CLOSE, COMMIT, CREATE,         |
   |                          | DELEGRETURN, GETATTR, GETFH, LINK,     |
   |                          | LOCK, LOCKT, LOCKU, LOOKUP, LOOKUPP,   |
   |                          | NVERIFY, OPEN, OPENATTR, OPEN_CONFIRM, |
   |                          | OPEN_DOWNGRADE, PUTFH, READ, READDIR,  |
   |                          | READLINK, REMOVE, RENAME, RESTOREFH,   |
   |                          | SAVEFH, SECINFO, SETATTR, VERIFY,      |
   |                          | WRITE                                  |
   |                          |                                        |
   | NFS4ERR_NAMETOOLONG      | CREATE, LINK, LOOKUP, OPEN, REMOVE,    |
   |                          | RENAME, SECINFO                        |
   |                          |                                        |
   | NFS4ERR_NOENT            | LINK, LOOKUP, LOOKUPP, OPEN, OPENATTR, |
   |                          | REMOVE, RENAME, SECINFO                |
   |                          |                                        |
   | NFS4ERR_NOFILEHANDLE     | ACCESS, CLOSE, COMMIT, CREATE,         |
   |                          | DELEGRETURN, GETATTR, GETFH, LINK,     |
   |                          | LOCK, LOCKT, LOCKU, LOOKUP, LOOKUPP,   |
   |                          | NVERIFY, OPEN, OPENATTR, OPEN_CONFIRM, |
   |                          | OPEN_DOWNGRADE, READ, READDIR,         |
   |                          | READLINK, REMOVE, RENAME, SAVEFH,      |
   |                          | SECINFO, SETATTR, VERIFY, WRITE        |
   |                          |                                        |
   | NFS4ERR_NOSPC            | CREATE, LINK, OPEN, OPENATTR, RENAME,  |
   |                          | SETATTR, WRITE                         |
   |                          |                                        |
   | NFS4ERR_NOTDIR           | CREATE, LINK, LOOKUP, LOOKUPP, OPEN,   |
   |                          | READDIR, REMOVE, RENAME, SECINFO       |
   |                          |                                        |
   | NFS4ERR_NOTEMPTY         | REMOVE, RENAME                         |
   |                          |                                        |
   | NFS4ERR_NOTSUPP          | DELEGPURGE, DELEGRETURN, LINK, OPEN,   |
   |                          | OPENATTR, READLINK                     |
   |                          |                                        |
   | NFS4ERR_NOT_SAME         | READDIR, VERIFY                        |
   |                          |                                        |
   | NFS4ERR_NO_GRACE         | LOCK, OPEN                             |
   |                          |                                        |
   | NFS4ERR_NXIO             | WRITE                                  |
   |                          |                                        |
   | NFS4ERR_OLD_STATEID      | CLOSE, DELEGRETURN, LOCK, LOCKU, OPEN, |
   |                          | OPEN_CONFIRM, OPEN_DOWNGRADE, READ,    |
   |                          | SETATTR, WRITE                         |
   |                          |                                        |
   | NFS4ERR_OPENMODE         | LOCK, READ, SETATTR, WRITE             |
   |                          |                                        |
   | NFS4ERR_OP_ILLEGAL       | CB_ILLEGAL, ILLEGAL                    |

   |                          |                                        |
   | NFS4ERR_PERM             | CREATE, OPEN, SETATTR                  |
   |                          |                                        |
   | NFS4ERR_RECLAIM_BAD      | LOCK, OPEN                             |
   |                          |                                        |
   | NFS4ERR_RECLAIM_CONFLICT | LOCK, OPEN                             |
   |                          |                                        |
   | NFS4ERR_RESOURCE         | ACCESS, CLOSE, COMMIT, CREATE,         |
   |                          | DELEGPURGE, DELEGRETURN, GETATTR,      |
   |                          | GETFH, LINK, LOCK, LOCKT, LOCKU,       |
   |                          | LOOKUP, LOOKUPP, OPEN, OPENATTR,       |
   |                          | OPEN_CONFIRM, OPEN_DOWNGRADE, READ,    |
   |                          | READDIR, READLINK, RELEASE_LOCKOWNER,  |
   |                          | REMOVE, RENAME, RENEW, RESTOREFH,      |
   |                          | SAVEFH, SECINFO, SETATTR, SETCLIENTID, |
   |                          | SETCLIENTID_CONFIRM, VERIFY, WRITE     |
   |                          |                                        |
   | NFS4ERR_RESTOREFH        | RESTOREFH                              |
   |                          |                                        |
   | NFS4ERR_ROFS             | COMMIT, CREATE, LINK, OPEN, OPENATTR,  |
   |                          | OPEN_DOWNGRADE, REMOVE, RENAME,        |
   |                          | SETATTR, WRITE                         |
   |                          |                                        |
   | NFS4ERR_SAME             | NVERIFY                                |
   |                          |                                        |
   | NFS4ERR_SERVERFAULT      | ACCESS, CB_GETATTR, CB_RECALL, CLOSE,  |
   |                          | COMMIT, CREATE, DELEGPURGE,            |
   |                          | DELEGRETURN, GETATTR, GETFH, LINK,     |
   |                          | LOCK, LOCKT, LOCKU, LOOKUP, LOOKUPP,   |
   |                          | NVERIFY, OPEN, OPENATTR, OPEN_CONFIRM, |
   |                          | OPEN_DOWNGRADE, PUTFH, PUTPUBFH,       |
   |                          | PUTROOTFH, READ, READDIR, READLINK,    |
   |                          | RELEASE_LOCKOWNER, REMOVE, RENAME,     |
   |                          | RENEW, RESTOREFH, SAVEFH, SECINFO,     |
   |                          | SETATTR, SETCLIENTID,                  |
   |                          | SETCLIENTID_CONFIRM, VERIFY, WRITE     |
   |                          |                                        |
   | NFS4ERR_SHARE_DENIED     | OPEN                                   |
   |                          |                                        |
   | NFS4ERR_STALE            | ACCESS, CLOSE, COMMIT, CREATE,         |
   |                          | DELEGRETURN, GETATTR, GETFH, LINK,     |
   |                          | LOCK, LOCKT, LOCKU, LOOKUP, LOOKUPP,   |
   |                          | NVERIFY, OPEN, OPENATTR, OPEN_CONFIRM, |
   |                          | OPEN_DOWNGRADE, PUTFH, READ, READDIR,  |
   |                          | READLINK, REMOVE, RENAME, RESTOREFH,   |
   |                          | SAVEFH, SECINFO, SETATTR, VERIFY,      |
   |                          | WRITE                                  |
   |                          |                                        |

   | NFS4ERR_STALE_CLIENTID   | DELEGPURGE, LOCK, LOCKT, OPEN,         |
   |                          | RELEASE_LOCKOWNER, RENEW,              |
   |                          | SETCLIENTID_CONFIRM                    |
   |                          |                                        |
   | NFS4ERR_STALE_STATEID    | CLOSE, DELEGRETURN, LOCK, LOCKU,       |
   |                          | OPEN_CONFIRM, OPEN_DOWNGRADE, READ,    |
   |                          | SETATTR, WRITE                         |
   |                          |                                        |
   | NFS4ERR_SYMLINK          | COMMIT, LOOKUP, LOOKUPP, OPEN, READ,   |
   |                          | WRITE                                  |
   |                          |                                        |
   | NFS4ERR_TOOSMALL         | READDIR                                |
   |                          |                                        |
   | NFS4ERR_WRONGSEC         | LINK, LOOKUP, LOOKUPP, OPEN, PUTFH,    |
   |                          | PUTPUBFH, PUTROOTFH, RENAME, RESTOREFH |
   |                          |                                        |
   | NFS4ERR_XDEV             | LINK, RENAME                           |
   |                          |                                        |
   +--------------------------+----------------------------------------+

             Table 9: Errors and the Operations That Use Them
```

---
## **14.  NFSv4 Requests**

NFSv4 RPC 프로그램에는 NULL과 COMPOUND라는 두 가지 전통적인 RPC 프로시저가 있습니다. 다른 모든 기능은 일련의 작업으로 정의되며 이러한 작업은 일반적인 XDR/RPC 구문 및 의미 체계로 정의됩니다. 그러나 이러한 작업은 COMPOUND 프로시저 내에 캡슐화됩니다. 이를 위해서는 클라이언트가 하나 이상의 NFSv4 작업을 단일 요청으로 결합해야 합니다.

NFS4\_CALLBACK 프로그램은 서버-클라이언트 신호를 제공하는 데 사용되며 NFSv4 프로그램과 유사한 방식으로 구성됩니다. CB\_NULL 및 CB\_COMPOUND 프로시저는 NFS 프로그램 내에 NULL 및 COMPOUND가 있는 것과 동일한 방식으로 정의됩니다. CB\_COMPOUND 요청은 NFS4\_CALLBACK 프로그램의 나머지 작업도 캡슐화합니다. NFS4\_CALLBACK 프로그램에는 미리 정의된 RPC 프로그램 번호가 없습니다. "일시적" 프로그램 범위에서 프로그램 번호를 지정하는 것은 클라이언트의 몫입니다. NFS4\_CALLBACK 프로그램의 프로그램 및 포트 번호는 클라이언트가 SETCLIENTID/SETCLIENTID\_CONFIRM 시퀀스의 일부로 제공합니다. 프로그램 및 포트는 다른 SETCLIENTID/SETCLIENTID\_CONFIRM 시퀀스에 의해 변경될 수 있으며, 해당 시퀀스를 사용하여 관련 임대 클라이언트 상태를 제거하지 않고도 클라이언트 구현 내에서 이를 변경할 수 있습니다.

---
### **14.1.  COMPOUND Procedure**

COMPOUND 프로시저는 대기 시간이 긴 네트워크 내에서 더 나은 성능을 얻을 수 있는 기회를 제공합니다. 클라이언트는 여러 종속 작업을 단일 COMPOUND 프로시저로 결합하여 여러 RPC의 누적 대기 시간을 방지할 수 있습니다. COMPOUND 작업은 클라이언트가 기본 절차를 클라이언트 환경에 맞게 사용자 정의된 단일 요청으로 결합할 수 있도록 하여 프로토콜 단순화를 제공할 수 있습니다.

CB\_COMPOUND 프로시저는 위에서 설명한 COMPOUND의 기능과 정확하게 유사합니다.

COMPOUND 프로시저의 기본 구조는 다음과 같습니다.

```text
   +-----+--------------+--------+-----------+-----------+-----------+--
   | tag | minorversion | numops | op + args | op + args | op + args |
   +-----+--------------+--------+-----------+-----------+-----------+--
```

응답의 구조는 다음과 같습니다.

```text
     +------------+-----+--------+-----------------------+--
     |last status | tag | numres | status + op + results |
     +------------+-----+--------+-----------------------+--
```

위 설명에 사용된 numops 및 numres 필드는 요청 및 응답에 인코딩된 인수 또는 결과의 수를 나타내는 데 사용되는 계산된 배열 인코딩의 수를 나타냅니다. XDR 인코딩에 따라 이러한 개수는 인코딩된 작업 인수 또는 결과의 수와 정확히 일치해야 합니다.

---
### **14.2.  Evaluation of a COMPOUND Request**

서버는 COMPOUND 프로시저 내의 각 작업을 순서대로 평가하여 COMPOUND 프로시저를 처리합니다. 각 구성요소 연산은 32비트 연산 코드와 연산 유형에 따라 결정되는 길이 인수로 구성됩니다. 각 작업의 결과는 응답 버퍼에 순차적으로 인코딩됩니다. 각 작업의 결과 앞에는 opcode와 상태 코드\(일반적으로 0\)가 옵니다. 작업으로 인해 0이 아닌 상태 코드가 발생하면 상태가 인코딩되고 COMPOUND 시퀀스의 평가가 중단되며 응답이 반환됩니다. NFS4ERR\_SAME과 같은 "오류가 아닌" 조건이 발생하는 경우에도 평가가 중지됩니다.

COMPOUND 프로시저 내에 포함된 작업에 대한 원자성 요구 사항은 없습니다. COMPOUND 요청의 일부로 평가되는 작업은 서버가 수신하는 다른 COMPOUND 요청과 동시에 평가될 수 있습니다.

COMPOUND는 트랜잭션이 아니며 부분적으로 완료된 COMPOUND 프로시저를 복구하는 것은 클라이언트의 책임입니다. 이는 NFS4ERR\_RESOURCE 및 NFS4ERR\_DELAY와 같은 오류로 인해 언제든지 발생할 수 있습니다. 이러한 오류는 유효한 작업 문자열에서도 발생할 수 있습니다. 또한, COMPOUND 프로시저를 처리하는 중에 서버 재부팅이 발생하면 클라이언트는 COMPOUND 처리가 얼마나 진행되었는지 확인해야 하는 어려운 작업을 맡게 될 수 있습니다. 따라서 클라이언트는 프로시저 내 작업이 실패하는 경우 지나치게 복잡한 COMPOUND 프로시저를 피해야 합니다.

각 작업은 COMPOUND 요청의 실행 컨텍스트의 일부로 사용 가능한 현재 파일 핸들과 저장된 파일 핸들을 가정합니다. 작업은 현재 파일 핸들을 설정, 변경 또는 반환할 수 있습니다. 저장된 파일핸들은 파일핸들 값의 임시 저장과 RENAME 및 LINK 작업의 피연산자로 사용됩니다.

---
### **14.3.  Synchronous Modifying Operations**

파일 시스템을 수정하는 NFSv4 작업은 동기식입니다. 서버에서 작업이 성공적으로 완료되면 클라이언트는 요청과 관련된 모든 데이터가 이제 안정적인 저장소에 있음을 신뢰할 수 있습니다\(한 가지 예외는 UNSTABLE4 옵션이 지정된 WRITE 작업의 파일 데이터의 경우입니다\).

이는 동일한 COMPOUND 요청 내의 모든 이전 작업도 안정적인 저장소에 반영됨을 의미합니다. 이 동작을 통해 클라이언트는 서버 오류로 인해 부분적으로 실행된 COMPOUND 요청을 복구할 수 있습니다. 예를 들어, COMPOUND 요청에 작업 A와 B가 포함되어 있고 서버가 클라이언트에 응답을 보낼 수 없는 경우 서버가 요청을 처리하는 과정에 따라 두 작업의 결과가 안정적인 저장소에 반영되거나 단지 오퍼레이션 A가 반영될 수도 있습니다. 서버는 B 작업의 결과만을 안정적인 저장소에 저장해서는 안 됩니다.

---
### **14.4.  Operation Values**

COMPOUND 프로시저에 인코딩된 작업은 작업 값으로 식별됩니다. RPC 프로시저 번호와의 중복을 피하기 위해 작업 0\(영\)과 1은 정의되지 않습니다. 작업 2는 정의되지 않았지만 나중에 부 버전 관리와 함께 사용하도록 예약되어 있습니다.

---
## **15.  NFSv4 Procedures**
---
### **15.1.  Procedure 0: NULL - No Operation**
---
#### **15.1.1.  SYNOPSIS**

```text
     <null>
```

---
#### **15.1.2.  ARGUMENT**

```text
     void;
```

---
#### **15.1.3.  RESULT**

```text
     void;
```

---
#### **15.1.4.  DESCRIPTION**

표준 NULL 프로시저. 무효 논쟁, 무효 응답. 이 절차에는 관련된 기능이 없습니다. 이 때문에 서비스 요청 처리에 따른 오버헤드를 측정하는 데 사용되는 경우도 있습니다. 따라서 서버는 이 절차를 서비스하는 데 불필요한 작업이 수행되지 않도록 해야 합니다.

---
### **15.2.  Procedure 1: COMPOUND - COMPOUND Operations**
---
#### **15.2.1.  SYNOPSIS**

```text
     compoundargs -> compoundres
```

---
#### **15.2.2.  ARGUMENT**

```text
     union nfs_argop4 switch (nfs_opnum4 argop) {
             case <OPCODE>: <argument>;
             ...
     };

   struct COMPOUND4args {
           utf8str_cs      tag;
           uint32_t        minorversion;
           nfs_argop4      argarray<>;
   };
```

---
#### **15.2.3.  RESULT**

```text
     union nfs_resop4 switch (nfs_opnum4 resop) {
             case <OPCODE>: <argument>;
             ...
     };

   struct COMPOUND4res {
           nfsstat4        status;
           utf8str_cs      tag;
           nfs_resop4      resarray<>;
   };
```

---
#### **15.2.4.  DESCRIPTION**

COMPOUND 프로시저는 하나 이상의 NFS 작업을 단일 RPC 요청으로 결합하는 데 사용됩니다. 기본 NFS RPC 프로그램에는 NULL과 COMPOUND라는 두 가지 주요 프로시저가 있습니다. 다른 모든 작업에서는 COMPOUND 프로시저를 래퍼로 사용합니다.

COMPOUND 프로시저는 개별 작업을 단일 RPC 요청으로 결합하는 데 사용됩니다. 서버는 각 작업을 차례로 해석합니다. 서버에서 작업이 실행되고 해당 작업의 상태가 NFS4\_OK인 경우 COMPOUND 프로시저의 다음 작업이 실행됩니다. 서버는 더 이상 실행할 작업이 없거나 작업 중 하나가 NFS4\_OK 이외의 상태 값을 가질 때까지 이 프로세스를 계속합니다.

COMPOUND 프로시저를 처리하는 동안 서버는 COMPOUND 시퀀스 내의 작업 중 일부 또는 전부를 실행하는 데 사용할 수 있는 리소스가 없다는 것을 알 수 있습니다. 이 경우 리소스 소진이 발생한 COMPOUND 프로시저 내의 특정 작업에 대해 NFS4ERR\_RESOURCE 오류가 반환됩니다. 이는 COMPOUND 시퀀스 내의 모든 이전 작업이 성공적으로 평가되었다고 가정합니다. 평가된 모든 작업의 ​​결과는 클라이언트에 반환되어야 합니다.

서버는 일반적으로 클라이언트 요청을 디코딩하는 두 가지 방법 중에서 선택합니다. 첫 번째는 전체 COMPOUND의 디코딩이 그 안의 모든 작업 실행보다 앞서는 전통적인 원패스 XDR 디코드입니다. 이 경우 XDR 디코딩 오류가 있으면 RPC XDR 디코딩 오류가 반환됩니다. 두 번째 방법은 기본 COMPOUND 요청을 디코딩하기 위한 초기 패스를 만든 다음 서버가 실행할 준비가 되면 각 개별 작업을 XDR 디코딩하는 것입니다. 이 경우, COMPOUND 내의 이전 작업이 실행된 후 서버는 이러한 작업 디코딩 중에 XDR 디코딩 오류가 발생할 수 있습니다. 이 경우 서버는 NFS4ERR\_BADXDR 오류를 반환하여 디코딩 오류를 나타냅니다.

COMPOUND 인수에는 부 버전 필드가 포함되어 있습니다. 이 필드의 초기 값과 기본값은 0입니다. 이 필드는 클라이언트가 어떤 부 버전이 요청되는지 서버와 통신할 수 있도록 향후 부 버전에서 사용됩니다. 서버가 지원하지 않는 마이너 버전 필드 값이 있는 COMPOUND 프로시저를 수신하는 경우 서버는 NFS4ERR\_MINOR\_VERS\_MISMATCH 오류와 길이가 0인 resultdata 배열을 반환해야 합니다.\(MUST\)

COMPOUND 결과에는 상태 필드가 포함되어 있습니다. 결과 배열 길이가 0이 아닌 경우 이 상태는 COMPOUND 프로시저 내에서 실행된 마지막 작업의 상태와 동일해야 합니다. 따라서 작업에 오류가 발생한 경우 상태 값은 실패한 작업에 대해 반환되는 오류 값과 동일합니다.

COMPOUND 프로시저에는 연산 0\(영\), 1\(1\) 및 2\(2\)가 정의되어 있지 않습니다. 서버는 첫 번째 적법한 작업\(OP\_ACCESS\)보다 작거나 마지막 적법한 작업\(OP\_RELEASE\_LOCKOWNER\)보다 큰 작업이 포함된 요청을 받을 수 있습니다. 이 경우 서버의 응답은 요청의 잘못된 opcode가 아닌 opcode OP\_ILLEGAL을 인코딩합니다. ILLEGAL 반환 결과의 상태 필드는 NFS4ERR\_OP\_ILLEGAL로 설정됩니다. COMPOUND 프로시저의 반환 결과도 NFS4ERR\_OP\_ILLEGAL입니다.

요청의 "태그" 정의는 구현자에게 달려 있습니다. 이는 패킷 스니퍼 및 엔지니어 디버깅 구현의 이점을 위해 COMPOUND 요청의 내용을 요약하는 데 사용될 수 있습니다. 그러나 응답의 "태그" 값은 요청에 제공된 값과 동일해야 합니다. 이는 CB\_COMPOUND 프로시저의 태그 필드에도 적용됩니다.\(SHOULD\)

---
##### **15.2.4.1.  Current Filehandle**

현재 파일 핸들과 저장된 파일 핸들은 프로토콜 전체에서 사용됩니다. 대부분의 작업은 암시적으로 현재 파일 핸들을 인수로 사용하며 많은 작업이 현재 파일 핸들을 결과의 일부로 설정합니다. 클라이언트가 지정한 작업 순서와 현재 및 저장된 파일 핸들 인수 및 결과를 결합하면 프로토콜 유연성이 향상됩니다. 현재 파일 핸들 사용법의 가장 좋고 가장 쉬운 예는 다음과 같은 순서입니다.

```text
                        PUTFH fh1              {fh1}
                        LOOKUP "compA"         {fh2}
                        GETATTR                {fh2}
                        LOOKUP "compB"         {fh3}
                        GETATTR                {fh3}
                        LOOKUP "compC"         {fh4}
                        GETATTR                {fh4}
                        GETFH

                    Figure 1: Filehandle Usage Example
```

이 예에서 PUTFH\(16.20절\) 작업은 현재 파일 핸들 값을 명시적으로 설정하는 반면, 각 LOOKUP 작업의 결과는 현재 파일 핸들 값을 결과 파일 시스템 개체로 설정합니다. 또한 클라이언트는 현재 파일 핸들을 인수로 사용하여 GETATTR 작업을 삽입할 수 있습니다.

PUTROOTFH\(섹션 16.22\) 및 PUTPUBFH\(섹션 16.21\) 작업도 현재 파일 핸들을 설정합니다. 위의 예에서는 동일한 효과를 얻기 위해 "PUTFH fh1"을 PUTROOTFH로 바꾸거나 파일 핸들 인수가 없는 PUTPUBFH로 바꿉니다\("compA"가 네임스페이스 루트 바로 아래에 있다는 가정하에\).

현재 파일핸들과 함께 저장된 파일핸들이 있습니다. 현재 파일 핸들은 LOOKUP과 같은 작업의 결과로 설정되지만 저장된 파일 핸들은 SAVEFH 작업을 사용하여 직접 설정해야 합니다. SAVEFH 작업은 현재 파일 핸들 값을 저장된 값으로 복사합니다. 저장된 파일 핸들 값은 LINK 및 RENAME 작업에 대한 현재 파일 핸들 값과 함께 사용됩니다. RESTOREFH 작업은 저장된 파일 핸들을 복사합니다.

값을 현재 파일 핸들 값으로 바꿉니다. 결과적으로 저장된 파일 핸들 값은 클라이언트의 일련의 작업에 대한 일종의 "스크래치" 영역으로 사용될 수 있습니다.

---
#### **15.2.5.  IMPLEMENTATION**

작업의 일부만 평가된 후에 모든 유형의 오류가 발생할 수 있으므로 클라이언트는 오류로부터 복구할 준비를 해야 합니다. NFS4ERR\_RESOURCE 오류의 원인이 복잡하거나 긴 작업 세트인 경우 작업 수가 줄어들면 서버가 해당 작업을 성공적으로 평가할 수 있을 가능성이 높습니다. 따라서 클라이언트는 복구 시 이러한 유형의 복잡성을 처리할 책임이 있습니다.

단일 복합에는 OPEN, LOCK 또는 RENEW에 사용되는 clientid 필드에 대해 서로 다른 값을 갖는 여러 작업이 포함되어서는 안 됩니다. 이로 인해 클라이언트 ID가 포함되지 않은 작업이 포함된 작업과 잠재적인 상호 작용이 있는 경우 혼란이 발생할 수 있습니다. 단일 클라이언트 ID만 사용된 경우 어떤 클라이언트가 참조되고 있는지 분명합니다. OPEN 및 GETATTR의 상호 작용과 관련된 특정 예는 섹션 16.16.6을 참조하세요.

---
## **16.  NFSv4 Operations**
---
### **16.1.  Operation 3: ACCESS - Check Access Rights**
---
#### **16.1.1.  SYNOPSIS**

```text
     (cfh), accessreq -> supported, accessrights
```

---
#### **16.1.2.  ARGUMENT**

```text
   const ACCESS4_READ      = 0x00000001;
   const ACCESS4_LOOKUP    = 0x00000002;
   const ACCESS4_MODIFY    = 0x00000004;
   const ACCESS4_EXTEND    = 0x00000008;
   const ACCESS4_DELETE    = 0x00000010;
   const ACCESS4_EXECUTE   = 0x00000020;

   struct ACCESS4args {
           /* CURRENT_FH: object */
           uint32_t        access;
   };
```

---
#### **16.1.3.  RESULT**

```text
   struct ACCESS4resok {
           uint32_t        supported;
           uint32_t        access;
   };

   union ACCESS4res switch (nfsstat4 status) {
    case NFS4_OK:
            ACCESS4resok   resok4;
    default:
            void;
   };
```

---
#### **16.1.4.  DESCRIPTION**

ACCESS는 RPC 요청의 자격 증명으로 식별된 사용자가 현재 파일 핸들에 지정된 파일 시스템 개체에 대해 갖는 액세스 권한을 결정합니다. 클라이언트는 비트마스크 "액세스"에서 확인할 액세스 권한 집합을 인코딩합니다. 서버는 비트마스크에 인코딩된 권한을 확인합니다. NFS4\_OK 상태가 반환되면 두 개의 비트마스크가 응답에 포함됩니다. 첫 번째 "지원됨"은 서버가 안정적으로 확인할 수 있는 액세스 권한을 나타냅니다. 두 번째 "액세스"는 제공된 파일 핸들에 대해 사용자가 사용할 수 있는 액세스 권한을 나타냅니다. 성공하면 현재 파일 핸들이 해당 값을 유지합니다.

지원되는 필드에는 원래 인수로 전송된 값만큼만 포함됩니다. 예를 들어 클라이언트가 ACCESS4\_READ 값만 설정된 ACCESS 작업을 보내고 서버가 이 값을 지원하는 경우 서버는 다른 값을 안정적으로 확인할 수 있었더라도 ACCESS4\_READ만 반환합니다.

이 작업의 결과는 본질적으로 권고 사항입니다. NFS4\_OK의 반환 상태와 비트마스크에 설정된 적절한 비트는 향후 파일 시스템 개체에 대한 액세스가 허용된다는 의미는 아닙니다. 접근 권한은 언제든지 서버에 의해 철회될 수 있기 때문입니다.

다음과 같은 접근 권한을 요청할 수 있습니다.

ACCESS4\_READ: 파일에서 데이터를 읽거나 디렉터리를 읽습니다.

ACCESS4\_LOOKUP: 디렉터리에서 이름을 찾습니다\(디렉토리가 아닌 개체에는 의미 없음\).

ACCESS4\_MODIFY: 기존 파일 데이터를 다시 쓰거나 기존 디렉터리 항목을 수정합니다.

ACCESS4\_EXTEND: 새 데이터를 쓰거나 디렉터리 항목을 추가합니다.

ACCESS4\_DELETE: 기존 디렉토리 항목을 삭제합니다.

ACCESS4\_EXECUTE: 파일을 실행합니다\(디렉토리에는 의미 없음\).

성공하면 현재 파일 핸들이 해당 값을 유지합니다.

---
#### **16.1.5.  IMPLEMENTATION**

일반적으로 클라이언트가 파일 속성의 uid, gid 및 mode 필드를 검사하거나 ACL 속성의 내용을 해석하여 액세스 권한을 추론하는 것만으로는 충분하지 않습니다. 이는 서버가 uid 또는 gid 매핑을 수행하거나 추가 액세스 제어 제한을 시행할 수 있기 때문입니다. 서버가 클라이언트와 동일한 ID 공간에 있지 않을 수도 있습니다. 이러한 경우\(및 기타 경우\) 클라이언트는 현재 파일 속성만으로는 액세스 확인을 안정적으로 수행할 수 없습니다.

NFSv2 프로토콜에서 작업 허용 여부를 확인하는 신뢰할 수 있는 유일한 방법은 작업을 시도하여 성공했는지 실패했는지 확인하는 것이었습니다. NFSv4 프로토콜의 ACCESS 작업을 사용하여 클라이언트는 하나 이상의 작업 클래스가 허용되는지 여부를 나타내도록 서버에 요청할 수 있습니다. ACCESS 작업은 클라이언트가 액세스 실패를 초래할 수 있는 일련의 작업을 수행하기 전에 확인할 수 있도록 제공됩니다. OPEN 작업은 포인트를 제공합니다.

여기서 서버는 파일 객체에 대한 액세스와 해당 정보를 클라이언트에 반환하는 방법을 확인할 수 있습니다. ACCESS 작업은 디렉터리 작업이나 클라이언트에서 UNIX API "액세스"가 사용되는 경우에 여전히 유용합니다.

ACCESS 호출에 대한 응답으로 서버가 반환한 정보는 영구적이지 않습니다. 서버가 검사를 수행한 정확한 시간에는 정확했지만 이후에는 반드시 그런 것은 아닙니다. 서버는 언제든지 접근권한을 철회할 수 있습니다.

클라이언트는 액세스 권한을 결정하는 데 사용되는 ACCESS 요청에 인증 정보를 구축하기 위해 사용자의 유효한 자격 증명을 사용해야 합니다. 후속 읽기 및 쓰기 작업에 사용되는 유효 사용자 및 그룹 자격 증명입니다.

많은 구현에서는 ACCESS4\_DELETE 권한을 직접 지원하지 않습니다. UNIX와 같은 운영 체제는 디렉터리가 아닌 개체에 대한 액세스 요청에 설정된 경우 ACCESS4\_DELETE 비트를 무시합니다. 이러한 시스템에서 파일에 대한 삭제 권한은 파일 자체의 권한에 의해 결정되는 대신 파일이 있는 디렉터리에 대한 액세스 권한에 따라 결정됩니다. 따라서 지원될 수 있는 액세스 권한을 열거하는 반환된 마스크는 ACCESS4\_DELETE 값이 0으로 설정됩니다. 이는 서버가 해당 특정 액세스 권한을 확인할 수 없음을 클라이언트에 나타냅니다. 반환된 액세스 마스크의 ACCESS4\_DELETE 비트는 클라이언트에서 무시됩니다.

---
### **16.2.  Operation 4: CLOSE - Close File**
---
#### **16.2.1.  SYNOPSIS**

```text
     (cfh), seqid, open_stateid -> open_stateid
```

---
#### **16.2.2.  ARGUMENT**

```text
   struct CLOSE4args {
           /* CURRENT_FH: object */
           seqid4          seqid;
           stateid4        open_stateid;
   };
```

---
#### **16.2.3.  RESULT**

```text
   union CLOSE4res switch (nfsstat4 status) {
    case NFS4_OK:
            stateid4       open_stateid;
    default:
            void;
   };
```

---
#### **16.2.4.  DESCRIPTION**

CLOSE 작업은 현재 파일 핸들에 지정된 대로 일반 또는 명명된 속성 파일에 대한 공유 예약을 해제합니다. 이 CLOSE의 결과로 서버에서 공개된 공유 예약 및 기타 상태 정보는 제공된 stateid와만 연관됩니다. 시퀀스 ID는 올바른 순서를 제공합니다. 다른 OPEN과 연관된 상태는 영향을 받지 않습니다.

바이트 범위 잠금이 유지되면 클라이언트는 CLOSE를 발행하기 전에 모든 잠금을 해제해야 합니다. 서버는 CLOSE 시 미해결 잠금을 모두 해제할 수 있지만 일부 서버는 여전히 바이트 범위 잠금이 유지된 파일의 CLOSE를 지원하지 않을 수 있습니다. CLOSE 이후 잠금이 존재하는 경우 서버는 실패를 반환해야 합니다.\(SHOULD, MAY, MUST\)

성공하면 현재 파일 핸들이 해당 값을 유지합니다.

---
#### **16.2.5.  IMPLEMENTATION**

CLOSE가 stateid를 반환하더라도 이 stateid는 클라이언트에 유용하지 않으며 더 이상 사용되지 않는 것으로 처리되어야 합니다. CLOSE는 단일 개방 소유자에 의한 파일의 모든 OPEN과 연관된 상태를 "종료"합니다. 위에서 언급한 대로 CLOSE는 모든 파일 잠금 상태를 해제하거나 오류를 반환합니다. 따라서 CLOSE에서 반환된 stateid는 후속 작업에 유용하지 않습니다.

---
### **16.3.  Operation 5: COMMIT - Commit Cached Data**
---
#### **16.3.1.  SYNOPSIS**

```text
     (cfh), offset, count -> verifier
```

---
#### **16.3.2.  ARGUMENT**

```text
   struct COMMIT4args {
           /* CURRENT_FH: file */
           offset4         offset;
           count4          count;
   };
```

---
#### **16.3.3.  RESULT**

```text
   struct COMMIT4resok {
           verifier4       writeverf;
   };

   union COMMIT4res switch (nfsstat4 status) {
    case NFS4_OK:
            COMMIT4resok   resok4;
    default:
            void;
   };
```

---
#### **16.3.4.  DESCRIPTION**

COMMIT 작업은 현재 파일 핸들에 지정된 파일에 대한 안정적인 저장소로 데이터를 강제로 삭제하거나 플러시합니다. 플러시된 데이터는 이전에 stable 필드가 UNSTABLE4로 설정된 WRITE 작업으로 작성된 데이터입니다.

오프셋은 플러시가 시작될 파일 내의 위치를 ​​지정합니다. 오프셋 값 0\(영\)은 파일 시작 부분부터 데이터를 플러시한다는 의미입니다. 개수는 플러시할 데이터의 바이트 수를 지정합니다. count가 0\(영\)이면 오프셋에서 파일 끝까지 플러시가 수행됩니다.

서버는 COMMIT가 성공적으로 완료되면 쓰기 검증자를 반환합니다. 쓰기 검증자는 클라이언트가 초기 WRITE와 COMMIT 사이에 서버가 다시 시작되었는지 또는 재부팅되었는지 확인하는 데 사용됩니다. 클라이언트는 초기 쓰기에서 반환된 쓰기 검증자와 COMMIT 작업에서 반환된 검증자를 비교하여 이를 수행합니다. 서버는 각 서버 이벤트 또는 인스턴스화 시 쓰기 검증자의 값을 다양하게 변경해야 합니다.

커밋되지 않은 데이터의 손실. 가장 일반적으로 이는 서버를 재부팅할 때 발생합니다. 그러나 서버의 다른 이벤트로 인해 커밋되지 않은 데이터가 손실될 수도 있습니다.

성공하면 현재 파일 핸들이 해당 값을 유지합니다.

---
#### **16.3.5.  IMPLEMENTATION**

COMMIT 작업은 파일 상태를 디스크와 동기화하는 POSIX fsync\(\) \[fsync\] 시스템 호출과 작업 및 의미가 유사합니다\(파일 데이터 및 메타데이터가 디스크 또는 안정적인 저장소에 플러시됩니다\). COMMIT는 클라이언트에 대해 동일한 작업을 수행하여 서버의 동기화되지 않은 데이터와 메타데이터를 서버의 디스크나 지정된 파일에 대한 안정적인 저장소로 플러시합니다. fsync\(\)와 마찬가지로 일부 수정된 데이터가 있거나 동기화할 수정된 데이터가 없을 수 있습니다. 데이터는 서버의 일반적인 주기적인 버퍼 동기화 활동에 의해 동기화되었을 수 있습니다. COMMIT는 예상치 못한 오류가 발생하지 않는 한 NFS4\_OK를 반환해야 합니다.

COMMIT는 클라이언트가 파일 범위를 플러시할 수 있다는 점에서 fsync\(\)와 다릅니다\(대개 파일이 완전히 기록되기 전에 클라이언트의 버퍼 재확보 방식에 의해 트리거될 가능성이 높습니다\).

COMMIT의 서버 구현은 비교적 간단합니다. 서버가 오프셋 0과 개수 0에서 시작하는 전체 파일 COMMIT 요청을 받으면 파일을 fsync\(\)하는 것과 동등한 작업을 수행해야 합니다. 그렇지 않으면 오프셋 및 개수로 지정된 범위의 캐시된 데이터가 안정적인 저장소로 플러시되도록 준비해야 합니다. 두 경우 모두 파일과 관련된 모든 메타데이터를 반환하기 전에 안정적인 저장소로 플러시해야 합니다. 서버에 플러시할 항목이 없는 것은 오류가 아닙니다. 이는 플러시해야 하는 데이터와 메타데이터가 마지막 서버 오류 중에 이미 플러시되었거나 손실되었음을 의미합니다.

COMMIT의 클라이언트 구현은 좀 더 복잡합니다. 클라이언트 버퍼를 안정적인 저장소에 커밋하려는 데에는 두 가지 이유가 있습니다. 첫 번째는 클라이언트가 버퍼를 재사용하기를 원한다는 것입니다. 이 경우 COMMIT 요청을 통해 버퍼의 오프셋과 개수가 서버로 전송됩니다. 그런 다음 서버는 오프셋 및 개수를 기반으로 캐시된 데이터를 플러시하고 파일과 관련된 모든 메타데이터를 플러시합니다. 그런 다음 플러시 및 쓰기 확인자의 상태를 반환합니다. 클라이언트가 COMMIT를 생성하는 또 다른 이유는 CLOSE에서 수행될 수 있는 것과 같은 전체 파일 플러시를 위한 것입니다. 이 경우 클라이언트는 커밋되지 않은 데이터가 포함된 이 파일에 대한 모든 버퍼를 수집하고 오프셋 0과 개수 0으로 COMMIT 작업을 수행한 다음 해당 버퍼를 모두 해제합니다. 다른 더티 버퍼는 일반적인 방식으로 서버로 전송됩니다.

안정적인 매개변수가 UNSTABLE4로 설정된 클라이언트에 의해 버퍼가 작성된 후 버퍼가 COMMIT 작업을 통해 플러시되거나 안정적인 매개변수가 FILE\_SYNC4로 설정된 WRITE 작업을 통해 기록될 때까지 클라이언트가 버퍼를 수정한 것으로 간주해야 합니다. DATA\_SYNC4. 이는 데이터가 서버의 안정적인 저장소로 플러시되기 전에 버퍼가 해제되어 재사용되는 것을 방지하기 위해 수행됩니다.

WRITE 또는 COMMIT 작업에서 응답이 반환되고 서버에서 이전에 반환한 것과 다른 쓰기 검증자가 포함된 경우 클라이언트는 커밋되지 않은 캐시된 데이터가 포함된 모든 버퍼를 서버에 다시 전송해야 합니다. 이를 수행하는 방법은 구현자에게 달려 있습니다. 관심 있는 버퍼가 하나만 있는 경우 적절한 안정적인 매개변수를 사용하여 WRITE 요청으로 다시 전송해야 할 것입니다. 버퍼가 두 개 이상인 경우 stable 매개변수를 UNSTABLE4로 설정하여 WRITE 요청의 모든 버퍼를 재전송한 다음 COMMIT 작업을 재전송하여 서버의 모든 데이터를 안정적인 저장소로 플러시하는 것이 좋습니다. 이러한 재전송 시기는 구현자에게 달려 있습니다.

위의 설명은 버퍼 캐시 기반 시스템뿐만 아니라 페이지 캐시 기반 시스템에도 적용됩니다. 이러한 시스템에서는 버퍼 캐시 대신 가상 메모리 시스템을 수정해야 합니다.

---
### **16.4.  Operation 6: CREATE - Create a Non-regular File Object**
---
#### **16.4.1.  SYNOPSIS**

```text
     (cfh), name, type, attrs -> (cfh), cinfo, attrset
```

---
#### **16.4.2.  ARGUMENT**

```text
   union createtype4 switch (nfs_ftype4 type) {
    case NF4LNK:
            linktext4 linkdata;
    case NF4BLK:
    case NF4CHR:
            specdata4 devdata;
    case NF4SOCK:
    case NF4FIFO:
    case NF4DIR:
            void;
    default:
            void;  /* server should return NFS4ERR_BADTYPE */
   };

   struct CREATE4args {
           /* CURRENT_FH: directory for creation */
           createtype4     objtype;
           component4      objname;
           fattr4          createattrs;
   };
```

---
#### **16.4.3.  RESULT**

```text
   struct CREATE4resok {
           change_info4    cinfo;
           bitmap4         attrset;        /* attributes set */
   };

   union CREATE4res switch (nfsstat4 status) {
    case NFS4_OK:
            CREATE4resok resok4;
    default:
            void;
   };
```

---
#### **16.4.4.  DESCRIPTION**

CREATE 작업은 지정된 이름을 가진 디렉터리에 비정규 파일 객체를 생성합니다. OPEN 작업은 일반 파일을 만드는 데 사용됩니다.

objname은 새 개체의 이름을 지정합니다. objtype은 생성될 객체의 유형\(디렉토리, 심볼릭 링크 등\)을 결정합니다.

동일한 이름의 개체가 디렉터리에 이미 존재하는 경우 서버는 NFS4ERR\_EXIST 오류를 반환합니다.

새 파일 객체가 생성된 디렉터리에 대해 서버는 cinfo에change\_info4 정보를 반환합니다. Change\_info4 구조체의 원자 필드를 사용하면 서버는 파일 객체 생성과 관련하여 변경 전후 속성이 원자적으로 획득되었는지 여부를 나타냅니다.

objname의 길이가 0이면 NFS4ERR\_INVAL이 반환됩니다. objname에는 일반 UTF-8, 문자 지원 및 이름 확인도 적용됩니다. 자세한 내용은 섹션 12.7을 참조하세요.

현재 파일 핸들이 새 객체의 파일 핸들로 대체됩니다.

createattrs 필드는 객체에 대한 초기 속성 세트를 지정합니다. 속성 세트에는 객체 유형에 유효한 쓰기 가능한 속성이 포함될 수 있습니다. 작업이 성공하면 서버는 객체에 대해 어떤 속성이 성공적으로 설정되었는지 나타내는 속성 마스크를 클라이언트에 반환합니다.

createattrs에 소유자 속성이나 소유자에 대한 ACE가 있는 ACL이 포함되어 있지 않고 서버의 파일 시스템이 소유자 속성\(또는 소유자 ACE\)을 지원하고 요구하는 경우 서버는 소유자\(또는 소유자 ACE\)를 파생해야 합니다. . 이는 일반적으로 호출의 RPC 자격 증명에 표시된 주체에서 나오지만 서버의 운영 환경이나 파일 시스템 의미에 따라 다른 파생 방법이 필요할 수 있습니다. 마찬가지로 createattrs에 그룹 속성이나 그룹 ACE가 모두 포함되지 않고 서버의 파일 시스템이 그룹 속성\(또는 그룹 ACE\)의 개념을 지원하고 요구하는 경우 서버는 그룹 속성\(또는 해당 소유자 ACE\)을 파생해야 합니다. 파일을 위해. 이는 RPC의 자격 증명\(예: 자격 증명에 AUTH\_SYS 등\)이 포함된 경우 그룹 주체, 자격 증명의 주체와 연결된 그룹 식별자\(예: POSIX 시스템에는 모든 사용자 식별자에 대한 그룹 식별자\), 개체가 있는 디렉터리에서 상속됨\(MUST, MUST\)

서버의 운영 환경이나 파일 시스템 의미가 지시하는 모든 것에서 생성됩니다. 이는 OPEN 작업에도 적용됩니다.

반대로 클라이언트가 RPC의 자격 증명에 파일을 생성할 권한이 없음을 나타내는 주체가 소유자 속성, 그룹 속성 또는 ACL을 createattrs에 지정할 수도 있습니다. 이 인스턴스에서 반환되는 오류는 NFS4ERR\_PERM입니다. 이는 OPEN 작업에도 적용됩니다.

---
#### **16.4.5.  IMPLEMENTATION**

클라이언트가 생성 후에 속성 값을 설정하려는 경우 적절한 속성이 설정되도록 SETATTR 작업을 COMPOUND 요청에 추가할 수 있습니다.

---
### **16.5.  Operation 7: DELEGPURGE - Purge Delegations Awaiting Recovery**
---
#### **16.5.1.  SYNOPSIS**

```text
     clientid ->
```

---
#### **16.5.2.  ARGUMENT**

```text
   struct DELEGPURGE4args {
           clientid4       clientid;
   };
```

---
#### **16.5.3.  RESULT**

```text
   struct DELEGPURGE4res {
           nfsstat4        status;
   };
```

---
#### **16.5.4.  DESCRIPTION**

DELEGPURGE는 특정 클라이언트에 대한 복구를 기다리는 모든 위임을 제거합니다. 이는 위임 정보를 안정적인 저장소에 커밋하지 않는 클라이언트에 유용하며, 위임 정보 복구를 기다리는 서버에서 충돌하는 요청을 지연시킬 필요가 없음을 나타냅니다.

이 작업은 클라이언트의 안정적인 저장소에 위임 정보를 기록하는 클라이언트를 지원하기 위해 제공됩니다. 이 경우 클라이언트에 알려진 모든 위임에 대해 위임 복구\(CLAIM\_DELEGATE\_PREV 사용\)를 수행한 후 즉시 DELEGPURGE를 실행해야 합니다. 이렇게 하면 클라이언트에 대한 추가 위임이 복구되지 않음을 서버에 알리므로 리소스를 확보하고 복구되지 않은 위임과 충돌하는 요청을 하는 다른 클라이언트의 지연을 방지할 수 있습니다. 더 이상 CLAIM\_DELEGATE\_PREV 복구가 수행되지 않는다는 것이 확인되면 모든 클라이언트는 복구의 일부로 DELEGPURGE를 사용해야 합니다. 여기에는 안정적인 저장소에 위임 정보를 기록하지 않고 SETCLIENTID\_CONFIRM 직후에 DELEGPURGE를 수행하는 클라이언트가 포함됩니다.\(SHOULD\)

서버와 클라이언트에 알려진 위임 세트는 다를 수 있습니다. 그 이유는 다음과 같습니다.

o 클라이언트는 요청을 한 후 실패할 수 있습니다.

- 위임하지만 결과를 수신하고 클라이언트의 안정적인 저장소에 커밋하기 전에.

o 위임이 존재한다는 표시를 삭제한 후 위임 반환이 서버에서 완전히 처리되기 전에 클라이언트가 실패할 수 있습니다.

o 서버와 클라이언트가 다시 시작되는 경우 서버는 존재하는 위임의 하위 집합에 대한 위임의 영구 기록을 제한할 수 있습니다.

o 클라이언트는 위임의 하위 집합에 대한 정보만 지속적으로 기록했을 수 있습니다.

서버는 DELEGPURGE를 지원할 수 있지만 지원 여부는 CLAIM\_DELEGATE\_PREV와 일치해야 합니다.\(MAY\)

o 서버는 DELEGPURGE와 CLAIM\_DELEGATE\_PREV를 모두 지원할 수 있습니다.

o 서버는 DELEGPURGE나 CLAIM\_DELEGATE\_PREV를 모두 지원하지 않을 수 있습니다.

이 사실을 통해 클라이언트는 시작 시 서버가 위임 정보의 영구 저장을 지원할 준비가 되었는지, 따라서 로컬 영구 저장소에 다시 쓰기 캐싱을 사용할 수 있는지 여부를 판단할 수 있으며, CLAIM\_DELEGATE\_PREV 복구를 사용하여 변경된 데이터를 안전하게 플러시할 수 있습니다. 클라이언트가 다시 시작되는 경우 서버.

---
### **16.6.  Operation 8: DELEGRETURN - Return Delegation**
---
#### **16.6.1.  SYNOPSIS**

```text
     (cfh), stateid ->
```

---
#### **16.6.2.  ARGUMENT**

```text
   struct DELEGRETURN4args {
           /* CURRENT_FH: delegated file */
           stateid4        deleg_stateid;
   };
```

---
#### **16.6.3.  RESULT**

```text
   struct DELEGRETURN4res {
           nfsstat4        status;
   };
```

---
#### **16.6.4.  DESCRIPTION**

DELEGRETURN은 현재 파일 핸들 및 stateid로 표시되는 위임을 반환합니다.

위임은 회수되거나 자발적으로\(즉, 서버가 위임을 회수하기 전\) 반환될 수 있습니다. 두 경우 모두 클라이언트는 위임을 반환하기 전에 위임 컨텍스트에 따라 변경된 상태를 서버에 올바르게 전파해야 합니다.

---
### **16.7.  Operation 9: GETATTR - Get Attributes**
---
#### **16.7.1.  SYNOPSIS**

```text
     (cfh), attrbits -> attrbits, attrvals
```

---
#### **16.7.2.  ARGUMENT**

```text
   struct GETATTR4args {
           /* CURRENT_FH: directory or file */
           bitmap4         attr_request;
   };
```

---
#### **16.7.3.  RESULT**

```text
   struct GETATTR4resok {
           fattr4          obj_attributes;
   };

   union GETATTR4res switch (nfsstat4 status) {
    case NFS4_OK:
            GETATTR4resok  resok4;
    default:
            void;
   };
```

---
#### **16.7.4.  DESCRIPTION**

GETATTR 작업은 현재 파일 핸들에 지정된 파일 시스템 개체에 대한 속성을 가져옵니다. 클라이언트는 서버가 반환할 각 속성 값에 대해 비트맵 인수에 비트를 설정합니다. 서버는 값을 반환할 수 있는 속성 값을 나타내는 속성 비트맵을 반환하고 그 뒤에 가장 낮은 속성 번호부터 정렬된 속성 값을 반환합니다.

서버는 속성이 서버에서 지원되는 경우 클라이언트가 요청하는 각 속성에 대한 값을 반환해야 합니다. 서버가 속성을 지원하지 않거나 유용한 값을 근사화할 수 없는 경우에는 속성 값을 반환해서는 안 되며 결과 비트맵에 속성 비트를 설정해서는 안 됩니다. 서버는 대상의 속성을 지원하지만 해당 값을 얻을 수 없는 경우 오류를 반환해야 합니다. 이 경우 속성 값이 반환되지 않습니다.\(MUST, MUST NOT, MUST\)

없는 파일 시스템은 섹션 8.3.1에 설명된 대로 매우 작은 속성 집합을 지원하는 것으로 처리되어야 합니다. 이전에 파일 시스템이 있었을 때 더 많은 속성이 지원되었더라도 마찬가지입니다.

모든 서버는 없는 파일 시스템을 제외하고 모든 파일 시스템에 대해 섹션 5에 지정된 대로 REQUIRED 속성을 지원해야 합니다.\(MUST\)

성공하면 현재 파일 핸들이 해당 값을 유지합니다.

---
#### **16.7.5.  IMPLEMENTATION**

문제의 파일에 대해 다른 클라이언트가 보유한 OPEN\_DELEGATE\_WRITE 위임이 있고 크기 및/또는 변경 사항이 조사되는 속성 집합에 있다고 가정해 보겠습니다. 서버에는 두 가지 선택이 있습니다. 첫째, 서버는 CB\_GETATTR 콜백을 사용하여 위임을 보유한 클라이언트로부터 이러한 속성의 실제 현재 값을 얻을 수 있습니다. 둘째, 서버는 특히 위임된 클라이언트가 응답하지 않을 때 문제의 위임을 회수할 수 있습니다. GETATTR은 다음 중 하나가 발생할 때까지 진행되어서는 안 됩니다.\(MUST NOT\)

o 요청된 속성 값은 CB\_GETATTR에 대한 응답으로 반환됩니다.

o OPEN\_DELEGATE\_WRITE 위임이 반환됩니다.

o OPEN\_DELEGATE\_WRITE 위임이 취소되었습니다.

위 중 하나가 매우 빠르게 발생하지 않는 한 위임이 처리되지 않는 동안 하나 이상의 NFS4ERR\_DELAY 오류가 반환됩니다.

---
### **16.8.  Operation 10: GETFH - Get Current Filehandle**
---
#### **16.8.1.  SYNOPSIS**

```text
     (cfh) -> filehandle
```

---
#### **16.8.2.  ARGUMENT**

```text
     /* CURRENT_FH: */
     void;
```

---
#### **16.8.3.  RESULT**

```text
   struct GETFH4resok {
           nfs_fh4         object;
   };

   union GETFH4res switch (nfsstat4 status) {
    case NFS4_OK:
            GETFH4resok     resok4;
    default:
            void;
   };
```

---
#### **16.8.4.  DESCRIPTION**

이 작업은 현재 파일 핸들 값을 반환합니다.

성공하면 현재 파일 핸들이 해당 값을 유지합니다.

---
#### **16.8.5.  IMPLEMENTATION**

LOOKUP 또는 CREATE와 같이 현재 파일 핸들을 변경하는 작업은 결과적으로 새 파일 핸들을 자동으로 반환하지 않습니다. 예를 들어 클라이언트가 디렉터리 항목을 조회하고 해당 파일 핸들을 가져와야 하는 경우 다음 요청이 필요합니다.

```text
     PUTFH  (directory filehandle)
     LOOKUP (entry name)
     GETFH
```

---
### **16.9.  Operation 11: LINK - Create Link to a File**
---
#### **16.9.1.  SYNOPSIS**

```text
     (sfh), (cfh), newname -> (cfh), cinfo
```

---
#### **16.9.2.  ARGUMENT**

```text
   struct LINK4args {
           /* SAVED_FH: source object */
           /* CURRENT_FH: target directory */
           component4      newname;
   };
```

---
#### **16.9.3.  RESULT**

```text
   struct LINK4resok {
           change_info4    cinfo;
   };

   union LINK4res switch (nfsstat4 status) {
    case NFS4_OK:
            LINK4resok resok4;
    default:
            void;
   };
```

---
#### **16.9.4.  DESCRIPTION**

LINK 작업은 SAVEFH 작업에 의해 설정된 대로 현재 파일 핸들이 나타내는 디렉터리에 저장된 파일 핸들이 나타내는 파일에 대한 추가 새 이름을 생성합니다. 기존 파일과 대상 디렉터리는 서버의 동일한 파일 시스템 내에 있어야 합니다. 성공하면 현재 파일 핸들이 계속 대상 디렉터리가 됩니다. newname과 동일한 이름을 가진 개체가 대상 디렉터리에 존재하는 경우 서버는 NFS4ERR\_EXIST를 반환해야 합니다.

대상 디렉터리의 경우 서버는 cinfo에change\_info4 정보를 반환합니다. Change\_info4 구조체의 원자 필드를 사용하면 서버는 링크 생성과 관련하여 변경 전후 속성이 원자적으로 획득되었는지 여부를 나타냅니다.

newname의 길이가 0\(영\)이거나 newname이 UTF-8 정의를 따르지 않는 경우 NFS4ERR\_INVAL 오류가 반환됩니다.

---
#### **16.9.5.  IMPLEMENTATION**

"하드" 링크된 파일의 속성에 대한 변경 사항은 링크된 모든 파일에 반영됩니다. 파일에 대한 링크가 만들어지면 파일 속성의 numlinks 값은 LINK 작업 이전의 값보다 1 커야 합니다.

"파일과 대상 디렉터리는 서버의 동일한 파일 시스템 내에 있어야 합니다"라는 문은 개체 속성의 fsid 필드가 동일함을 의미합니다. 서로 다른 파일 시스템에 상주하는 경우 NFS4ERR\_XDEV 오류가 반환됩니다. LINK 작업이 위반하는 파일 시스템의 내부 분할이 있는 경우 일부 서버에서 이 오류가 반환될 수 있습니다.

일부 서버에서는 "." 및 ".."은 newname에 대한 잘못된 값이며, 이를 지정하면 NFS4ERR\_BADNAME 오류가 반환됩니다.

현재 파일 핸들이 명명된 속성 디렉터리를 지정하고 링크할 객체\(저장된 파일 핸들\)가 동일한 객체에 대한 명명된 속성이 아닌 경우 NFS4ERR\_XDEV 오류가 반환되어야 합니다. 저장된 파일 핸들이 명명된 속성을 지정하고 현재 파일 핸들이 적절한 명명된 속성 디렉터리가 아닌 경우 NFS4ERR\_XDEV 오류도 반환되어야 합니다.\(MUST, MUST\)

현재 파일 핸들이 명명된 속성 디렉터리를 지정하고 연결될 개체\(저장된 파일 핸들\)가 해당 디렉터리 내의 명명된 속성인 경우 서버는 NFS4ERR\_NOTSUPP 오류를 반환할 수 있습니다.\(MAY\)

newname이 저장된 파일 핸들이 나타내는 파일에 이미 링크되어 있는 경우 서버는 NFS4ERR\_EXIST를 반환합니다.

CREATE 작업을 통해 심볼릭 링크가 생성된다는 점에 유의하세요.

---
### **16.10.  Operation 12: LOCK - Create Lock**
---
#### **16.10.1.  SYNOPSIS**

```text
     (cfh) locktype, reclaim, offset, length, locker -> stateid
```

---
#### **16.10.2.  ARGUMENT**

```text
   enum nfs_lock_type4 {
           READ_LT         = 1,
           WRITE_LT        = 2,
           READW_LT        = 3,    /* blocking read */
           WRITEW_LT       = 4     /* blocking write */
   };

   /*
    * For LOCK, transition from open_owner to new lock_owner
    */
   struct open_to_lock_owner4 {
           seqid4          open_seqid;
           stateid4        open_stateid;
           seqid4          lock_seqid;
           lock_owner4     lock_owner;
   };

   /*
    * For LOCK, existing lock_owner continues to request file locks
    */
   struct exist_lock_owner4 {
           stateid4        lock_stateid;
           seqid4          lock_seqid;
   };

   union locker4 switch (bool new_lock_owner) {
    case TRUE:
            open_to_lock_owner4     open_owner;
    case FALSE:
            exist_lock_owner4       lock_owner;
   };

   /*
    * LOCK/LOCKT/LOCKU: Record lock management
    */
   struct LOCK4args {
           /* CURRENT_FH: file */
           nfs_lock_type4  locktype;
           bool            reclaim;
           offset4         offset;
           length4         length;
           locker4         locker;
   };
```

---
#### **16.10.3.  RESULT**

```text
   struct LOCK4denied {
           offset4         offset;
           length4         length;
           nfs_lock_type4  locktype;
           lock_owner4     owner;
   };

   struct LOCK4resok {
           stateid4        lock_stateid;
   };

   union LOCK4res switch (nfsstat4 status) {
    case NFS4_OK:
            LOCK4resok     resok4;
    case NFS4ERR_DENIED:
            LOCK4denied    denied;
    default:
            void;
   };
```

---
#### **16.10.4.  DESCRIPTION**

LOCK 작업은 오프셋 및 길이 매개변수로 지정된 바이트 범위에 대한 바이트 범위 잠금을 요청합니다. 잠금 유형도 nfs\_lock\_type4s 중 하나로 지정됩니다. 회수 요청인 경우 회수 매개변수는 TRUE입니다.

해당 바이트가 현재 파일에 할당되지 않은 경우에도 파일의 바이트가 잠길 수 있습니다. 파일 끝을 통해 특정 오프셋에서 파일을 잠그려면\(파일의 실제 길이에 상관없이\) 모든 비트가 1로 설정된 길이 필드를 사용하십시오. 길이가 0이거나 모든 비트가 1로 설정되지 않은 길이가 지정되고 오프셋에 추가된 길이가 최대 64비트 부호 없는 정수 값을 초과하는 경우 NFS4ERR\_INVAL 오류가 발생합니다.

32비트 서버는 32비트 내에 맞는\(즉, NFS4\_UINT32\_MAX 이하\) 바이트 오프셋에 대한 잠금을 지원하는 서버입니다. 클라이언트가 NFS4\_UINT32\_MAX 오프셋을 넘어 하나 이상의 바이트와 겹치는 범위를 지정하지만 NFS4\_UINT64\_MAX 오프셋에서 끝나지 않는 경우 이러한 32비트 서버는 NFS4ERR\_BAD\_RANGE 오류를 반환해야 합니다.\(MUST\)

잠금이 거부된 경우 충돌하는 잠금의 소유자, 오프셋 및 길이가 반환됩니다.

성공하면 현재 파일 핸들이 해당 값을 유지합니다.

---
#### **16.10.5.  IMPLEMENTATION**

서버가 충돌하는 잠금의 정확한 오프셋과 길이를 확인할 수 없는 경우 인수에 제공된 동일한 오프셋과 길이가 거부된 결과에 반환되어야 합니다. 섹션 9에는 이것과 다른 파일 잠금 작업에 대한 전체 설명이 포함되어 있습니다.

LOCK 작업은 권한 확인 및 관련 파일의 액세스 유형에 대한 확인을 따릅니다. 그러나 다양한 유형의 잠금에 필요한 특정 권한과 모드는 서버에서 내보낸 파일 시스템의 의미를 반영하며 프로토콜에 의해 지정되지 않습니다. 예를 들어 Windows 2000에서는 READ용으로 열린 파일에 대한 쓰기 잠금을 허용하지만 POSIX 호환 시스템에서는 허용하지 않습니다.

클라이언트가 잠금 소유자가 이미 잠근 범위\(동일하거나 다른 잠금 유형\), 해당 범위의 하위 영역 또는 이미 여러 잠금을 포함하는 영역에 해당하는 잠금 요청을 하는 경우 해당 잠금 소유자에게 전체 또는 부분적으로 부여되고 서버가 이러한 잠금 작업을 지원하지 않는 경우\(즉, POSIX 잠금 의미 체계를 지원하지 않는 경우\) 서버는 NFS4ERR\_LOCK\_RANGE 오류를 반환합니다. 이 경우 클라이언트는 해당 잠금 소유자가 이미 잠근 바이트를 포함하지 않는 범위에 대해 LOCK만 사용하고 해당 잠금 소유자가 보유한 잠금의 LOCKU를 사용하여 오류를 반환하거나 필요한 작업을 에뮬레이트할 수 있습니다\( 정확히 일치하는 범위 및 유형\). 마찬가지로, 클라이언트가 기존 레코드 잠금을 업그레이드\(읽기 잠금에서 쓰기 잠금으로 변경\) 또는 다운그레이드\(쓰기 잠금에서 읽기 잠금으로 변경\)하는 잠금 요청을 하고 서버가 이러한 잠금을 지원하지 않는 경우 , 서버는 NFS4ERR\_LOCK\_NOTSUPP를 반환합니다. 이러한 작업은 다른 클라이언트의 잠금 요청이 충돌하는 경우 필요한 의미를 완벽하게 반영하지 못할 수 있습니다.

클라이언트가 OPEN\_DELEGATE\_WRITE 위임을 보유한 경우 해당 위임을 보유한 클라이언트는 다른 클라이언트가 열 수 없음을 보장합니다. 따라서 이러한 LOCK 작업이 충돌할 수 없습니다.

클라이언트. 따라서 클라이언트는 서버에서 LOCK 작업을 수행하지 않고 로컬로 잠금 요청을 처리할 수 있습니다. 그렇게 하는 경우 위임을 반환하기 전에 적절한 LOCK 및 LOCKU 작업을 전송하여 서버의 잠금 상태를 업데이트할 준비를 해야 합니다.

하나 이상의 클라이언트가 OPEN\_DELEGATE\_READ 위임을 보유하는 경우 서버가 필수 잠금 의미를 구현하는 모든 LOCK 작업은 그러한 모든 위임을 회수해야 합니다. 모든 위임이 반환되거나 취소될 때까지 LOCK 작업이 승인되지 않을 수 있습니다. 매우 빠르게 발생하는 경우를 제외하고 위임이 미해결 상태로 유지되는 동안 요청에 하나 이상의 NFS4ERR\_DELAY 오류가 반환됩니다.\(MUST\)

locker 인수는 LOCK 요청과 관련된 잠금 소유자를 지정합니다. locker4 구조는 클라이언트가 현재 열려 있는 파일 및 잠금 소유자와 관련된 바이트 범위 잠금 상태를 이미 생성했는지 여부를 나타내는 전환된 공용체입니다. 현재 열린 파일과 잠금 소유자에 대해 잠금 상태가 생성되었는지 여부와 부울 new\_lock\_owner가 설정되었는지 여부의 가능한 조합에 해당하는 여러 가지 경우를 고려해야 합니다. 모든 경우에 잠금 소유자가 명시적으로 지정되었는지 암시적으로 지정되었는지에 관계없이 lock\_seqid가 지정됩니다. 이 seqid 값은 잠금 소유자 순서 지정/재생 문제를 확인하는 데 사용됩니다. 지정된 잠금 소유자가 서버에 알려지지 않은 경우 이는 새 잠금 소유자에 대한 초기 시퀀스 값을 설정합니다.

o 상태가 생성되었고 부울 값이 false인 경우 lock\_seqid 이외의 인수 중 유일한 부분은 해당 열린 파일 및 잠금 소유자와 관련된 잠금 집합을 나타내는 상태 ID입니다.

o 상태가 생성되었고 부울 값이 true인 경우 서버는 NFS4ERR\_BAD\_SEQID 오류와 함께 요청을 거부합니다. 유일한 예외는 부울 값이 참인 이전 요청을 재전송하는 경우입니다. 이 경우 lock\_seqid는 원래 요청과 일치하고 응답은 아래의 최종 사례를 반영합니다.

o 바이트 범위 잠금 상태가 설정되지 않았고 부울이 true인 경우 인수에는 열린 파일의 상태 ID와 잠금에 사용할 잠금 소유자를 지정하는 open\_to\_lock\_owner 구조가 포함됩니다. 오픈 소유자가 명시적으로 제공되지는 않지만 이와 관련된 open\_seqid는 오픈 소유자 순서 문제를 확인하는 데 사용됩니다. 이 사례에서는 open\_stateid의 확립된 상태를 이용하여 lock stateid의 사용으로 전환하는 방법을 제공합니다.

---
### **16.11.  Operation 13: LOCKT - Test for Lock**
---
#### **16.11.1.  SYNOPSIS**

```text
     (cfh) locktype, offset, length, owner -> {void, NFS4ERR_DENIED ->
     owner}
```

---
#### **16.11.2.  ARGUMENT**

```text
   struct LOCKT4args {
           /* CURRENT_FH: file */
           nfs_lock_type4  locktype;
           offset4         offset;
           length4         length;
           lock_owner4     owner;
   };
```

---
#### **16.11.3.  RESULT**

```text
   union LOCKT4res switch (nfsstat4 status) {
    case NFS4ERR_DENIED:
            LOCK4denied    denied;
    case NFS4_OK:
            void;
    default:
            void;
   };
```

---
#### **16.11.4.  DESCRIPTION**

LOCKT 작업은 인수에 지정된 대로 잠금을 테스트합니다. 충돌하는 잠금이 존재하는 경우 충돌하는 잠금의 소유자, 오프셋, 길이 및 유형이 반환됩니다. 잠금이 유지되지 않으면 NFS4\_OK 외에는 아무것도 반환되지 않습니다. 잠금 유형 READ\_LT 및 READW\_LT는 차단 또는 비차단에 관계없이 충돌하는 잠금 테스트가 수행된다는 점에서 동일한 방식으로 처리됩니다. WRITE\_LT 및 WRITEW\_LT의 경우에도 마찬가지입니다.

범위는 LOCK과 같이 지정됩니다. NFS4ERR\_INVAL 및 NFS4ERR\_BAD\_RANGE 오류는 LOCK과 동일한 상황에서 반환됩니다.

성공하면 현재 파일 핸들이 해당 값을 유지합니다.

---
#### **16.11.5.  IMPLEMENTATION**

서버가 충돌하는 잠금의 정확한 오프셋과 길이를 확인할 수 없는 경우 인수에 제공된 동일한 오프셋과 길이가 거부된 결과에 반환되어야 합니다. 섹션 9에는 파일 잠금 메커니즘에 대한 추가 논의가 포함되어 있습니다.

LOCKT는 소유자를 식별하기 위해 LOCK에서 사용되는 stateid4가 아닌 lock\_owner4를 사용합니다. 이는 클라이언트가 잠금 존재 여부를 테스트하기 위해 파일을 열 필요가 없기 때문에 상태 ID를 사용하지 못할 수 있기 때문입니다.

충돌하는 잠금에 대한 테스트는 현재 잠금 소유자에 대한 잠금을 제외해야 합니다\(SHOULD\). 이러한 잠금은 검사되지 않으므로 범위가 중복될 가능성이 있어도 LOCKT의 결과에 영향을 미치지 않을 수 있습니다. 서버가 범위 확인을 위해 잠금 소유자와 일치하는 잠금을 검사하는 경우 NFS4ERR\_LOCK\_RANGE가 반환될 수 있습니다. NFS4\_OK를 반환하는 경우 클라이언트는 서버에 제공되는 유연성으로 인해 LOCK을 수행하고 LOCK 요청에 대해 NFS4ERR\_LOCK\_RANGE를 수신할 수 있습니다.\(SHOULD\)

클라이언트가 OPEN\_DELEGATE\_WRITE 위임을 보유하면 로컬에서 LOCK 요청을 처리하도록 선택할 수 있습니다\(섹션 16.10.5 참조\). 이러한 경우 LOCKT 요청은 유사하게 로컬로 처리됩니다.

---
### **16.12.  Operation 14: LOCKU - Unlock File**
---
#### **16.12.1.  SYNOPSIS**

```text
     (cfh) type, seqid, stateid, offset, length -> stateid
```

---
#### **16.12.2.  ARGUMENT**

```text
   struct LOCKU4args {
           /* CURRENT_FH: file */
           nfs_lock_type4  locktype;
           seqid4          seqid;
           stateid4        lock_stateid;
           offset4         offset;
           length4         length;
   };
```

---
#### **16.12.3.  RESULT**

```text
   union LOCKU4res switch (nfsstat4 status) {
    case NFS4_OK:
            stateid4       lock_stateid;
    default:
            void;
   };
```

---
#### **16.12.4.  DESCRIPTION**

LOCKU 연산은 매개변수에 지정된 바이트 범위 잠금을 해제합니다. 클라이언트는 nfs\_lock\_type4 열거 유형에 대해 유효한 값으로 locktype 필드를 설정할 수 있으며, 서버는 locktype에 대한 모든 유효한 값을 수락해야 합니다. locktype의 적법한 값은 LOCKU 작업의 성공이나 실패에 영향을 주지 않습니다.\(MUST\)

범위는 LOCK과 같이 지정됩니다. NFS4ERR\_INVAL 및 NFS4ERR\_BAD\_RANGE 오류는 LOCK과 동일한 상황에서 반환됩니다.

성공하면 현재 파일 핸들이 해당 값을 유지합니다.

---
#### **16.12.5.  IMPLEMENTATION**

잠금을 해제할 영역이 잠금 소유자가 실제로 보유한 잠금과 정확하게 일치하지 않는 경우 서버는 NFS4ERR\_LOCK\_RANGE 오류를 반환할 수 있습니다. 여기에는 \(1\) 영역이 잠겨 있지 않은 경우, \(2\) 영역이 잠긴 영역의 하위 범위인 경우, \(3\) 정확히 일치하지 않고 잠긴 영역과 겹치는 경우, 또는 \(4\) 지정된 영역에 여러 개가 포함된 경우가 포함됩니다. 자물쇠 소유자가 보유한 자물쇠. POSIX 잠금 \[fcntl\] 의미론에 의해 허용되는 이러한 모든 경우에 이 오류를 수신하는 클라이언트는 해당 작업에 대한 지원을 원하는 경우 실제로 보유하고 있는 잠금에 해당하는 범위에서 LOCKU를 사용하여 작업을 시뮬레이션해야 하며, 그에 대한 LOCK 요청이 뒤따를 수도 있습니다. 하위 범위가 잠금 해제되지 않습니다.

클라이언트가 OPEN\_DELEGATE\_WRITE 위임을 보유하면 로컬에서 LOCK 요청을 처리하도록 선택할 수 있습니다\(섹션 16.10.5 참조\). 이러한 경우 LOCKU 요청은 유사하게 로컬로 처리됩니다.

---
### **16.13.  Operation 15: LOOKUP - Look Up Filename**
---
#### **16.13.1.  SYNOPSIS**

```text
     (cfh), component -> (cfh)
```

---
#### **16.13.2.  ARGUMENT**

```text
   struct LOOKUP4args {
           /* CURRENT_FH: directory */
           component4      objname;
   };
```

---
#### **16.13.3.  RESULT**

```text
   struct LOOKUP4res {
           /* CURRENT_FH: object */
           nfsstat4        status;
   };
```

---
#### **16.13.4.  DESCRIPTION**

이 작업은 LOOKUP을 수행하거나 현재 파일 핸들에 지정된 디렉터리를 사용하여 파일 시스템 개체를 찾습니다. LOOKUP은 구성 요소를 평가하고 개체가 존재하는 경우 현재 파일 핸들이 구성 요소의 파일 핸들로 대체됩니다.

구성 요소가 존재하지 않거나 클라이언트에 평가 권한이 없어서 평가할 수 없는 경우 오류가 반환되고 현재 파일 핸들은 변경되지 않습니다.

구성요소의 길이가 0인 경우 NFS4ERR\_INVAL이 반환됩니다. 구성 요소에는 일반 UTF-8, 문자 지원 및 이름 확인도 적용됩니다. 자세한 내용은 섹션 12.7을 참조하세요.

---
#### **16.13.5.  IMPLEMENTATION**

클라이언트가 다중 구성 요소 조회 효과를 얻으려는 경우 다음과 같은 COMPOUND 요청을 구성하고 각 파일 핸들을 얻을 수 있습니다.

```text
     PUTFH  (directory filehandle)
     LOOKUP "pub"
     GETFH
     LOOKUP "foo"
     GETFH
     LOOKUP "bar"
     GETFH
```

NFSv4 서버는 LOOKUP 요청이 서버의 마운트 지점을 통과하도록 허용한다는 점에서 이전 NFS 버전의 의미 체계와 다릅니다. 클라이언트는 디렉토리의 fsid 속성을 조회된 디렉토리의 fsid 속성과 비교하여 마운트 지점 교차를 감지할 수 있습니다. fsid가 다른 경우 새 디렉토리는 서버 마운트 지점입니다. 마운트 지점 교차를 감지하는 UNIX 클라이언트는 서버의 파일 시스템을 마운트해야 합니다. 이는 UNIX 클라이언트에 공통적인 파일 객체 신원 확인 메커니즘을 유지하기 위해 수행되어야 합니다.

NFS 액세스를 "공유" 또는 "내보낸" 파일 시스템으로 제한하는 서버는 클라이언트가 서버의 네임스페이스를 탐색할 수 있도록 내보낸 파일 시스템을 통합할 수 있는 의사 파일 시스템을 제공해야 합니다. 의사 파일 시스템에 대한 클라이언트의 보기는 내보낸 파일 시스템으로 연결되는 경로로 제한됩니다.

참고: 이전 버전의 프로토콜에서는 "."라는 이름에 특별한 의미가 할당되었습니다. 그리고 "..". NFSv4는 이러한 이름에 특별한 의미를 할당하지 않습니다. 상위 디렉터리를 조회하려면 LOOKUPP 연산자를 사용해야 합니다.

이 작업은 기호 링크를 따르지 않습니다. 클라이언트는 조회 프로세스 중에 발견된 기호 링크에 의해 수정된 파일 이름을 포함하여 모든 파일 이름 구문 분석을 담당합니다.

제공된 현재 파일 핸들이 디렉토리가 아니라 심볼릭 링크인 경우 NFS4ERR\_SYMLINK가 오류로 반환됩니다. 디렉터리가 아닌 다른 모든 파일 형식의 경우 NFS4ERR\_NOTDIR 오류가 반환됩니다.

---
### **16.14.  Operation 16: LOOKUPP - Look Up Parent Directory**
---
#### **16.14.1.  SYNOPSIS**

```text
     (cfh) -> (cfh)
```

---
#### **16.14.2.  ARGUMENT**

```text
     /* CURRENT_FH: object */
     void;
```

---
#### **16.14.3.  RESULT**

```text
   struct LOOKUPP4res {
           /* CURRENT_FH: directory */
           nfsstat4        status;
   };
```

---
#### **16.14.4.  DESCRIPTION**

현재 파일 핸들은 일반 디렉토리 또는 명명된 속성 디렉토리를 참조하는 것으로 가정됩니다. LOOKUPP은 상위 디렉터리의 파일 핸들을 현재 파일 핸들로 할당합니다. 상위 디렉토리가 없으면 NFS4ERR\_NOENT 오류가 반환되어야 합니다. 따라서 현재 파일 핸들이 서버 파일 트리의 루트 또는 최상위에 있을 때 서버는 NFS4ERR\_NOENT를 반환합니다.

---
#### **16.14.5.  IMPLEMENTATION**

LOOKUP의 경우 LOOKUPP도 마운트 지점을 교차합니다.

현재 파일 핸들이 디렉토리나 명명된 속성 디렉토리가 아닌 경우 NFS4ERR\_NOTDIR 오류가 반환됩니다.

현재 파일 핸들이 OPENATTR을 통해 파일 시스템 개체와 연결된 명명된 특성 디렉터리\(즉, 명명된 특성 디렉터리의 하위 디렉터리가 아님\)인 경우 LOOKUPP은 관련 파일 시스템 개체의 파일 핸들을 반환해야 합니다.\(SHOULD\)

---
### **16.15.  Operation 17: NVERIFY - Verify Difference in Attributes**
---
#### **16.15.1.  SYNOPSIS**

```text
     (cfh), fattr -> -
```

---
#### **16.15.2.  ARGUMENT**

```text
   struct NVERIFY4args {
           /* CURRENT_FH: object */
           fattr4          obj_attributes;
   };
```

---
#### **16.15.3.  RESULT**

```text
   struct NVERIFY4res {
           nfsstat4        status;
   };
```

---
#### **16.15.4.  DESCRIPTION**

이 작업은 일부 파일 시스템 개체에서 하나 이상의 속성이 변경된 경우 수행될 작업 시퀀스의 접두사로 사용됩니다. 모든 속성이 일치하면 NFS4ERR\_SAME 오류가 반환되어야 합니다.

성공하면 현재 파일 핸들이 해당 값을 유지합니다.

---
#### **16.15.5.  IMPLEMENTATION**

이 작업은 캐시 유효성 검사 연산자로 유용합니다. 속성이 속한 개체가 변경된 경우 다음 작업을 통해 해당 개체와 관련된 새 데이터를 얻을 수 있습니다. 예를 들어 파일이 변경되었는지 확인하고 파일이 변경된 경우 새 데이터를 가져옵니다.

```text
     PUTFH  (public)
     LOOKUP "foobar"
     NVERIFY attrbits attrs
     READ 0 32767
```

NVERIFY 작업에 RECOMMENDED 속성이 지정되어 있고 서버가 파일 시스템 개체에 대해 해당 속성을 지원하지 않는 경우 NFS4ERR\_ATTRNOTSUPP 오류가 클라이언트에 반환됩니다.\(SHOULD\)

rdattr\_error 속성이나 쓰기 전용 속성\(예: time\_modify\_set\)이 지정되면 NFS4ERR\_INVAL 오류가 클라이언트에 반환됩니다.

---
### **16.16.  Operation 18: OPEN - Open a Regular File**
---
#### **16.16.1.  SYNOPSIS**

```text
     (cfh), seqid, share_access, share_deny, owner, openhow, claim ->
     (cfh), stateid, cinfo, rflags, attrset, delegation
```

---
#### **16.16.2.  ARGUMENT**

```text
   /*
    * Various definitions for OPEN
    */
   enum createmode4 {
           UNCHECKED4      = 0,
           GUARDED4        = 1,
           EXCLUSIVE4      = 2
   };

   union createhow4 switch (createmode4 mode) {
    case UNCHECKED4:
    case GUARDED4:
            fattr4         createattrs;
    case EXCLUSIVE4:
            verifier4      createverf;
   };

   enum opentype4 {
           OPEN4_NOCREATE  = 0,
           OPEN4_CREATE    = 1
   };

   union openflag4 switch (opentype4 opentype) {
    case OPEN4_CREATE:
            createhow4     how;
    default:
            void;
   };

   /* Next definitions used for OPEN delegation */
   enum limit_by4 {
           NFS_LIMIT_SIZE          = 1,
           NFS_LIMIT_BLOCKS        = 2
           /* others as needed */
   };

   struct nfs_modified_limit4 {
           uint32_t        num_blocks;
           uint32_t        bytes_per_block;
   };

   union nfs_space_limit4 switch (limit_by4 limitby) {
    /* limit specified as file size */
    case NFS_LIMIT_SIZE:
            uint64_t               filesize;
    /* limit specified by number of blocks */
    case NFS_LIMIT_BLOCKS:
            nfs_modified_limit4    mod_blocks;
   };

   enum open_delegation_type4 {
           OPEN_DELEGATE_NONE      = 0,
           OPEN_DELEGATE_READ      = 1,
           OPEN_DELEGATE_WRITE     = 2
   };

   enum open_claim_type4 {
           CLAIM_NULL              = 0,
           CLAIM_PREVIOUS          = 1,
           CLAIM_DELEGATE_CUR      = 2,
           CLAIM_DELEGATE_PREV     = 3
   };

   struct open_claim_delegate_cur4 {
           stateid4        delegate_stateid;
           component4      file;
   };

   union open_claim4 switch (open_claim_type4 claim) {
    /*
     * No special rights to file.
     * Ordinary OPEN of the specified file.
     */
    case CLAIM_NULL:
            /* CURRENT_FH: directory */
            component4      file;
    /*
     * Right to the file established by an
     * open previous to server reboot.  File
     * identified by filehandle obtained at
     * that time rather than by name.
     */
    case CLAIM_PREVIOUS:
            /* CURRENT_FH: file being reclaimed */
            open_delegation_type4   delegate_type;

    /*
     * Right to file based on a delegation
     * granted by the server.  File is
     * specified by name.
     */
    case CLAIM_DELEGATE_CUR:
            /* CURRENT_FH: directory */
            open_claim_delegate_cur4        delegate_cur_info;

    /*
     * Right to file based on a delegation
     * granted to a previous boot instance
     * of the client.  File is specified by name.
     */
    case CLAIM_DELEGATE_PREV:
            /* CURRENT_FH: directory */
            component4      file_delegate_prev;
   };

   /*
    * OPEN: Open a file, potentially receiving an open delegation
    */
   struct OPEN4args {
           seqid4          seqid;
           uint32_t        share_access;
           uint32_t        share_deny;
           open_owner4     owner;
           openflag4       openhow;
           open_claim4     claim;
   };
```

---
#### **16.16.3.  RESULT**

```text
   struct open_read_delegation4 {
    stateid4 stateid;    /* Stateid for delegation */
    bool     recall;     /* Pre-recalled flag for
                            delegations obtained
                            by reclaim (CLAIM_PREVIOUS) */

    nfsace4 permissions; /* Defines users who don't
                            need an ACCESS call to
                            open for read */
   };

   struct open_write_delegation4 {
    stateid4 stateid;      /* Stateid for delegation */
    bool     recall;       /* Pre-recalled flag for
                              delegations obtained
                              by reclaim
                              (CLAIM_PREVIOUS) */

    nfs_space_limit4
              space_limit; /* Defines condition that
                              the client must check to
                              determine whether the
                              file needs to be flushed
                              to the server on close */

    nfsace4   permissions; /* Defines users who don't
                              need an ACCESS call as
                              part of a delegated
                              open */
   };

   union open_delegation4 switch
      (open_delegation_type4 delegation_type) {
           case OPEN_DELEGATE_NONE:
                   void;
           case OPEN_DELEGATE_READ:
                   open_read_delegation4 read;
           case OPEN_DELEGATE_WRITE:
                   open_write_delegation4 write;
   };

   /*
    * Result flags
    */

   /* Client must confirm open */
   const OPEN4_RESULT_CONFIRM      = 0x00000002;
   /* Type of file locking behavior at the server */
   const OPEN4_RESULT_LOCKTYPE_POSIX = 0x00000004;

   struct OPEN4resok {
    stateid4       stateid;      /* Stateid for open */
    change_info4   cinfo;        /* Directory change info */
    uint32_t       rflags;       /* Result flags */
    bitmap4        attrset;      /* attribute set for create */
    open_delegation4 delegation; /* Info on any open
                                    delegation */
   };

   union OPEN4res switch (nfsstat4 status) {
    case NFS4_OK:
            /* CURRENT_FH: opened file */
            OPEN4resok      resok4;
    default:
            void;
   };
```

---
#### **16.16.4.  Warning to Client Implementers**

OPEN은 클라이언트가 사용할 파일 핸들을 생성한다는 점에서 LOOKUP과 유사합니다. 그러나 LOOKUP과 달리 OPEN은 파일 핸들에 서버 상태를 생성합니다. 일반적인 상황에서 클라이언트는 CLOSE 작업을 통해서만 이 상태를 해제할 수 있습니다. CLOSE는 현재 파일 핸들을 사용하여 닫을 파일을 결정합니다. 따라서 클라이언트는 동일한 COMPOUND 프로시저에서 GETFH 작업이 포함된 모든 OPEN 작업을 따라야 합니다. 그러면 CLOSE를 적절하게 사용할 수 있도록 클라이언트에 파일 핸들이 제공됩니다.\(MUST\)

다른 클라이언트가 동일한 파일에 대해 충돌하는 액세스를 시도하지 않는 한 서버는 무기한으로 상태를 유지할 수 있으므로 단순히 파일 임대가 만료될 때까지 기다리는 것만으로는 충분하지 않습니다.

---
#### **16.16.5.  DESCRIPTION**

OPEN 작업은 제공된 이름을 가진 디렉터리에 일반 파일을 생성 및/또는 엽니다. 서버에 파일이 없고 생성을 원할 경우 openhow 매개변수로 생성 방법을 지정합니다. 클라이언트는 UNCHECKED4, GUARDED4 또는 EXCLUSIVE4의 세 가지 생성 방법 중에서 선택할 수 있습니다.

현재 파일 핸들이 명명된 속성 디렉터리인 경우 OPEN은 명명된 속성 파일을 생성하거나 엽니다. 명명된 속성의 단독 생성은 지원되지 않습니다. createmode가 EXCLUSIVE4이고 현재 파일 핸들이 명명된 속성 디렉터리인 경우 서버는 EINVAL을 반환합니다.

UNCHECKED4는 해당 이름의 파일이 존재하지 않고 해당 이름의 기존 일반 파일이 발생하는 것이 오류가 아닌 경우 파일을 생성해야 함을 의미합니다. 이러한 유형의 생성에 대해 createattrs는 파일의 초기 속성 세트를 지정합니다. 속성 세트에는 일반 파일에 유효한 쓰기 가능한 속성이 포함될 수 있습니다. UNCHECKED4 생성이 기존 파일을 발견하면 createattrs에 지정된 속성은 사용되지 않습니다. 단, 크기가 0으로 지정되면 기존 파일이 잘립니다. GUARDED4가 지정된 경우 서버는 생성을 수행하기 전에 이름으로 중복 개체가 있는지 확인합니다. 중복된 것이 있으면 NFS4ERR\_EXIST 오류를 상태로 반환합니다. 개체가 존재하지 않으면 UNCHECKED4에 설명된 대로 요청이 수행됩니다. 작업이 성공한 각 경우\(UNCHECKED4 및 GUARDED4\)에 대해 서버는 객체에 대해 어떤 속성이 성공적으로 설정되었는지 나타내는 속성 마스크를 클라이언트에 반환합니다.

EXCLUSIVE4는 서버가 대상의 독점 생성을 보장하기 위해 검증자를 사용하여 독점 생성 의미 체계를 따르도록 지정합니다. 서버는 이름으로 중복 개체가 있는지 확인해야 합니다. 객체가 존재하지 않으면 서버는 객체를 생성하고 객체와 함께 검증자를 저장합니다. 객체가 존재하고 저장된 검증자가 클라이언트가 제공한 검증자와 일치하는 경우 서버는 기존 객체를 새로 생성된 객체로 사용합니다. 저장된 검증자가 일치하지 않으면 NFS4ERR\_EXIST 오류가 반환됩니다. 이 경우에는 서버가 대상 개체의 속성을 사용하여 검증자를 저장할 수 있으므로 속성이 제공되지 않을 수 있습니다. 서버가 독점 생성 검증자를 저장하기 위해 속성을 사용하는 경우 결과에 반환되는 속성 마스크에 적절한 비트를 설정하여 어떤 속성이 사용되었는지 나타냅니다.

대상 디렉터리의 경우 서버는 cinfo에change\_info4 정보를 반환합니다. Change\_info4 구조체의 원자 필드를 사용하면 서버는 링크 생성과 관련하여 변경 전후 속성이 원자적으로 획득되었는지 여부를 나타냅니다.

성공적으로 생성되면 현재 파일 핸들이 새 객체의 파일 핸들로 대체됩니다.

OPEN 작업은 OPEN 인수의 share\_access 및 share\_deny 필드를 사용하여 Windows 공유 예약 기능을 제공합니다. 클라이언트는 OPEN에서 필요한 share\_access를 지정합니다.

및 share\_deny 모드. SHARE를 직접 지원하지 않는 클라이언트\(예: UNIX\)의 경우 예상되는 거부 값은 DENY\_NONE입니다. OPEN 요청과 충돌하는 기존 공유 예약이 있는 경우 서버는 NFS4ERR\_SHARE\_DENIED 오류를 반환합니다. 완전한 SHARE 요청을 위해 클라이언트는 OPEN 인수에 대한 소유자 및 seqid 필드의 값을 제공해야 합니다. 공유 의미론에 대한 추가 논의는 섹션 9.9를 참조하세요.

클라이언트가 서버 오류로부터 상태를 복구하는 경우 OPEN 인수의 클레임 필드는 요청이 이전에 보유된 상태를 복구하려는 것임을 나타내는 데 사용됩니다.

OPEN 인수의 클레임 필드는 열려는 파일과 클라이언트가 소유한다고 주장하는 상태 정보를 지정하는 데 사용됩니다. OPEN에 대한 다양한 상황을 다루는 네 가지 기본 청구 유형이 있습니다. 그것들은 다음과 같습니다:

CLAIM\_NULL: 클라이언트의 경우 이는 새로운 OPEN 요청이며 클라이언트의 파일과 연결된 이전 상태가 없습니다.

CLAIM\_PREVIOUS: 클라이언트가 서버 재부팅 이전에 보관되었던 파일에 대해 기본 OPEN 상태를 요구하고 있습니다. 이는 일반적으로 서버가 영구 파일 핸들을 반환할 때 사용됩니다. 클라이언트에 OPEN을 회수할 파일 이름이 없을 수 있습니다.

CLAIM\_DELEGATE\_CUR: 클라이언트는 서버에서 부여한 OPEN 위임을 요청합니다. 이는 일반적으로 대표단을 소환하는 과정의 일부로 수행됩니다.

CLAIM\_DELEGATE\_PREV: 클라이언트가 이전 클라이언트 인스턴스에 부여된 위임을 요청하고 있습니다. 이 클레임 유형은 두 가지 상황\(클라이언트 재부팅 후 및 모든 잠금 상태가 손실된 임대 만료 후\)에서 SETCLIENTID\_CONFIRM 이후 및 해당 DELEGPURGE 이전에 사용됩니다. 서버는 CLAIM\_DELEGATE\_PREV를 지원할 수 있습니다. CLAIM\_DELEGATE\_PREV를 지원하는 경우 SETCLIENTID\_CONFIRM은 클라이언트의 위임 상태를 제거해서는 안 되며 서버는 DELEGPURGE 작업을 지원해야 합니다.\(MAY, MUST NOT\)

CLAIM\_DELEGATE\_PREV 클레임 유형을 사용할 때 다음 오류가 적용됩니다.

o 서버가 이 클레임 유형을 지원하지 않으면 NFS4ERR\_NOTSUPP가 반환됩니다.

o 회수가 특정 시점에 수행되면 NFS4ERR\_INVAL이 반환됩니다.

- 부적절한 시간\(예: DELEGPURGE가 완료된 후\)

o NFS4ERR\_BAD\_RECLAIM은 다른 오류 조건이 적용되지 않고 서버에 회수가 시도되는 위임 기록이 없는 경우 반환됩니다.

유예 기간 또는 임대 만료 기간 동안 서버에 도달하는 클레임 ​​유형이 CLAIM\_PREVIOUS가 아닌 OPEN 요청\(즉, 서버 재부팅 후 오픈 회수에 할당된 요청이 아닌 요청\)의 경우 서버는 NFS4ERR\_GRACE 오류를 반환합니다.

모든 OPEN 요청에 대해 서버는 공개 위임을 반환할 수 있으며, 이를 통해 섹션 10.4에 설명된 대로 추가 열기 및 닫기를 클라이언트에서 로컬로 처리할 수 있습니다. 위임은 서버가 결정한다는 점에 유의하세요. 클라이언트는 특정 인스턴스에서 위임이 승인되거나 승인되지 않을 것이라고 가정해서는 안 됩니다. 두 경우 모두에 대해 항상 준비해야 합니다. 부분적인 예외는 위임 유형이 청구되는 회수\(CLAIM\_PREVIOUS\) 사례입니다. 이 경우 서버가 위임 구조에서 즉시 회수를 지정할 수 있더라도 위임은 항상 허용됩니다.

성공적인 OPEN에 의해 ​​반환된 rflags를 통해 서버는 열린 파일을 처리하는 방법을 제어하는 ​​정보를 반환할 수 있습니다.

OPEN4\_RESULT\_CONFIRM은 클라이언트가 열린 파일을 사용하기 전에 OPEN\_CONFIRM 작업을 실행해야 함을 나타냅니다. OPEN4\_RESULT\_LOCKTYPE\_POSIX는 서버의 파일 잠금 동작이 전체 POSIX 잠금 기술 세트\[fcntl\]를 지원함을 나타냅니다. 이를 통해 클라이언트는 파일 잠금 관리 불일치를 처리하는 방식으로 파일 잠금 상태를 관리하도록 선택할 수 있습니다.\(MUST\)

구성요소의 길이가 0인 경우 NFS4ERR\_INVAL이 반환됩니다. 구성 요소에는 일반 UTF-8, 문자 지원 및 이름 확인도 적용됩니다. 자세한 내용은 섹션 12.7을 참조하세요.

OPEN이 완료되고 지정된 열기 소유자가 이미 결과 파일 핸들을 열었을 때 결과는 기존 상태와 함께 새로운 공유 및 거부 상태를 "OR"하는 것입니다. 이 경우 여러 OPEN이 완료되었더라도 CLOSE는 한 번만 수행하면 됩니다. 이러한 OPEN이 이루어지면 동일한 소유자가 보유하고 있는 기존 OPEN에 대해서도 예외 없이 새로운 OPEN에 대한 지분 예약 확인이 정상적으로 진행됩니다. 이 경우 반환된 stateid에는 이전 열기와 일치하는 "other" 필드가 있는 반면 seqid 필드는 새 열기로 인해 변경된 상태를 반영하기 위해 증가됩니다\(섹션 9.1.4\).

서버의 기본 파일 시스템이 읽기 전용 모드에서만 액세스 가능하고 OPEN 요청이 OPEN4\_SHARE\_ACCESS\_WRITE 또는 OPEN4\_SHARE\_ACCESS\_BOTH를 지정한 경우 서버는 NFS4ERR\_ROFS를 반환하여 읽기 전용 파일 시스템을 나타냅니다.

CREATE 작업과 마찬가지로 서버는 네 가지 속성 중 하나라도 필요하고 서버의 파일 시스템에서 지원하는 경우 소유자, 소유자 ACE, 그룹 또는 그룹 ACE를 파생해야 합니다. EXCLUSIVE4 createmode를 사용하는 OPEN의 경우 이러한 OPEN 호출에는 createattrs 필드가 포함되지 않으므로 서버에는 선택의 여지가 없습니다. 반대로 createattrs가 지정되고 RPC 자격 증명의 주체가 파일을 생성할 권한이 없는 소유자나 그룹\(또는 해당 ACE\)을 포함하는 경우 서버는 NFS4ERR\_PERM을 반환할 수 있습니다.\(MUST\)

OPEN이 크기를 0으로 지정하고\(예: 잘림\) 파일에 명명된 속성이 있는 경우 명명된 속성은 그대로 유지됩니다. 제거되지 않습니다.

---
#### **16.16.6.  IMPLEMENTATION**

OPEN 작업에는 EXCLUSIVE4 생성에 대한 지원이 포함됩니다. 메커니즘은 NFSv3 \[RFC1813\]의 지원과 유사합니다. NFSv3에서와 마찬가지로 이 메커니즘은 안정적인 배타적 생성을 제공합니다. How 매개변수가 EXCLUSIVE4인 경우 단독 생성이 호출됩니다. 이 경우 클라이언트는 고유하다고 합리적으로 예상할 수 있는 검증자를 제공합니다. 클라이언트 식별자\(아마도 클라이언트 네트워크 주소\)와 클라이언트에 의해 생성된 고유 번호\(아마도 RPC 트랜잭션 식별자\)의 조합이 적절할 수 있습니다.

객체가 존재하지 않으면 서버는 객체를 생성하고 검증자를 안정적인 저장소에 저장합니다. 임의의 파일 속성 저장을 위한 메커니즘을 제공하지 않는 파일 시스템의 경우 서버는 객체 메타데이터의 하나 이상의 요소를 사용하여 검증자를 저장할 수 있습니다. 요청 재전송 시 오류가 발생하는 것을 방지하려면 검증자를 안정적인 저장소에 저장해야 합니다. 배타적 의미 체계가 애플리케이션에 중요하기 때문에 배타적 생성이 수행되고 있다고 가정합니다. 예상되는 사용법으로 인해 배타적 생성은 검증기 저장을 위해 일반적으로 일시적인 복제 요청 캐시에만 의존하지 않습니다. 휘발성 저장소의 중복 요청 캐시는 충돌 후에도 유지되지 않으며 실제로 긴 네트워크 파티션에서 플러시되어 실패 창이 열릴 수 있습니다. UNIX 로컬 파일 시스템 환경에서 생성 시 검증자의 예상 저장 위치는 개체의 메타데이터\(타임스탬프\)입니다. 이러한 이유로 독점 객체 생성에는 서버가 검증자를 저장할 곳이 없기 때문에 초기 속성이 포함되지 않을 수 있습니다.

검증자를 안정적인 저장소에 커밋해야 한다는 요구 사항 때문에 서버가 이러한 배타적 생성 의미 체계를 지원할 수 없는 경우 NFS4ERR\_NOTSUPP 오류와 함께 OPEN 요청이 실패해야 합니다.

배타적 CREATE 요청 중에 객체가 이미 존재하는 경우 서버는 객체의 검증자를 재구성하고 이를 요청의 검증자와 비교합니다. 일치하면 서버는 요청을 성공으로 처리합니다. 요청은 응답이 손실되고 서버 중복 요청 캐시 메커니즘이 감지하지 못한 이전의 성공적인 요청의 중복인 것으로 추정됩니다. 검증자가 일치하지 않으면 NFS4ERR\_EXIST 상태로 요청이 거부됩니다.

클라이언트가 성공적인 독점 생성을 수행한 후에는 SETATTR을 실행하여 올바른 개체 속성을 설정해야 합니다. 그렇게 하기 전까지는 서버 구현이 검증자를 저장하기 위해 객체 메타데이터를 오버로드해야 할 수 있으므로 객체 속성에 의존해서는 안 됩니다. 후속 SETATTR은 OPEN과 동일한 COMPOUND 요청에서 발생해서는 안 됩니다. 이러한 분리는 요청 재전송 시에도 배타적 생성 메커니즘이 계속해서 제대로 작동하도록 보장합니다.

GUARDED4 속성을 사용하면 "정확히 한 번" 의미 체계가 제공되지 않습니다. 특히 응답이 손실되고 서버가 요청의 재전송을 감지하지 못하는 경우 생성이 성공적으로 수행되었더라도 NFS4ERR\_EXIST로 인해 작업이 실패할 수 있습니다. 클라이언트는 응용 프로그램이 단독 생성을 요청하지 않았지만 파일이 열릴 때 파일을 자르도록 요청한 경우 이 동작을 사용합니다. 클라이언트가 시간 초과되어 생성 요청을 재전송하는 경우 클라이언트는 GUARDED4를 사용하여 생성, 쓰기, 생성\(재전송\)과 같은 시퀀스가 ​​발생하지 않도록 할 수 있습니다.

공유 예약\(섹션 9.9 참조\)의 경우 클라이언트는 OPEN4\_SHARE\_ACCESS\_READ, OPEN4\_SHARE\_ACCESS\_WRITE 또는 OPEN4\_SHARE\_ACCESS\_BOTH 중 하나인 share\_access 값을 지정해야 합니다. share\_deny의 경우 클라이언트는 OPEN4\_SHARE\_DENY\_NONE, OPEN4\_SHARE\_DENY\_READ, OPEN4\_SHARE\_DENY\_WRITE 또는 OPEN4\_SHARE\_DENY\_BOTH 중 하나를 지정해야 합니다. 클라이언트가 이를 수행하지 못하면 서버는 NFS4ERR\_INVAL을 반환해야 합니다.

클라이언트는 share\_access 값\(OPEN4\_SHARE\_ACCESS\_READ, OPEN4\_SHARE\_ACCESS\_WRITE 또는 OPEN4\_SHARE\_ACCESS\_BOTH\)을 기반으로 요청자가 지정된 작업을 수행할 수 있는 적절한 액세스 권한을 가지고 있는지 확인해야 합니다. 이는 일반적으로 현재 요청자의 파일에 ACL 액세스 규칙을 적용한 결과입니다. 그러나 ACCESS 작업과 마찬가지로 클라이언트는

액세스 권한은 변경될 수 있고 ACL 프레임워크 외부에서 서버 관리 제어의 대상이 될 수 있으므로 서버의 결정을 추측하려고 시도해서는 안 됩니다. 요청자에게 읽기 또는 쓰기 권한이 없는 경우\(share\_access 값에 따라\) 서버는 NFS4ERR\_ACCESS를 반환해야 합니다. NFSv4 프로토콜은 열린 파일에 대해 실행된 READ 및 WRITE가 OPEN 자체와 동일한 자격 증명을 가져야 한다는 요구 사항을 부과하지 않으므로 서버는 여전히 READ 및 WRITE 자체에 대해 적절한 액세스 검사를 수행해야 합니다.

OPEN에 제공된 구성 요소가 일반 파일\(또는 명명된 속성\) 이외의 것으로 확인되면 클라이언트에 오류가 반환됩니다. 디렉터리인 경우 NFS4ERR\_ISDIR이 반환됩니다. 그렇지 않으면 NFS4ERR\_SYMLINK가 반환됩니다. NFS4ERR\_SYMLINK는 심볼릭 링크와 다른 유형의 특수 파일 모두에 대해 반환됩니다. NFS4ERR\_INVAL은 클라이언트가 제공한 인수가 정확하고 구성 요소가 비정규 파일로 해석될 OPEN을 보낸 시점에 클라이언트가 반드시 알 수 없기 때문에 부적절합니다.

현재 파일 핸들이 디렉터리가 아니면 NFS4ERR\_NOTDIR 오류가 반환됩니다.

COMPOUND에 OPEN\_DELEGATE\_WRITE 위임을 설정하는 OPEN이 포함되어 있는 경우 후속 GETATTR은 일반적으로 위임을 보유한 클라이언트에 CB\_GETATTR이 전송되는 결과를 낳습니다. 그러나 OPEN과 GETATTR이 동일한 COMPOUND의 일부인 경우 서버는 해당 작업이 동일한 클라이언트 ID에 대한 것임을 이해하고 응답할 수 없는 클라이언트에 쿼리하는 것을 피해야 합니다. OPEN 및 GETATTR의 이 순서는 OPEN 시 크기 및 변경 속성을 검색하는 것으로 이해되어야 합니다. 또한 섹션 15.2.5에 설명된 대로 클라이언트는 서로 다른 클라이언트 ID에 대한 작업을 혼합하는 COMPOUND를 구성해서는 안 됩니다.\(SHOULD, SHOULD\)

---
### **16.17.  Operation 19: OPENATTR - Open Named Attribute Directory**
---
#### **16.17.1.  SYNOPSIS**

```text
     (cfh) createdir -> (cfh)
```

---
#### **16.17.2.  ARGUMENT**

```text
   struct OPENATTR4args {
           /* CURRENT_FH: object */
           bool    createdir;
   };
```

---
#### **16.17.3.  RESULT**

```text
   struct OPENATTR4res {
           /* CURRENT_FH: named attr directory */
           nfsstat4        status;
   };
```

---
#### **16.17.4.  DESCRIPTION**

OPENATTR 작업은 현재 파일 핸들과 연관된 명명된 속성 디렉터리의 파일 핸들을 얻는 데 사용됩니다. OPENATTR의 결과는 NF4ATTRDIR 유형의 객체에 대한 파일 핸들이 됩니다. 이 파일 핸들에서 READDIR 및 LOOKUP 작업을 사용하여 원래 파일 시스템 개체와 관련된 다양한 명명된 속성에 대한 파일 핸들을 얻을 수 있습니다. 명명된 속성 디렉터리 내에서 반환된 파일 핸들은 NF4NAMEDATTR 유형을 갖습니다.

Createdir 인수를 사용하면 클라이언트는 명명된 속성 디렉터리가 OPENATTR 작업의 결과로 생성되어야 하는지 여부를 나타낼 수 있습니다. 일부 클라이언트는 객체에 명명된 속성이 존재하는지 확인하기 위해 createir에 대해 FALSE 값과 함께 OPENATTR 작업을 사용할 수 있습니다. 존재하지 않는 경우 NFS4ERR\_NOENT가 반환됩니다. Createdir의 값이 TRUE이고 명명된 속성 디렉터리가 없으면 디렉터리가 생성됩니다. 명명된 속성 디렉토리의 생성은 서버가 이러한 방식으로 명명된 속성 지원을 구현했으며 이 정의에 따라 그렇게 할 필요가 없다고 가정합니다.

---
#### **16.17.5.  IMPLEMENTATION**

서버가 현재 파일 핸들에 대해 명명된 속성을 지원하지 않으면 NFS4ERR\_NOTSUPP 오류가 클라이언트에 반환됩니다.

---
### **16.18.  Operation 20: OPEN_CONFIRM - Confirm Open**
---
#### **16.18.1.  SYNOPSIS**

```text
     (cfh), seqid, stateid -> stateid
```

---
#### **16.18.2.  ARGUMENT**

```text
   struct OPEN_CONFIRM4args {
           /* CURRENT_FH: opened file */
           stateid4        open_stateid;
           seqid4          seqid;
   };
```

---
#### **16.18.3.  RESULT**

```text
   struct OPEN_CONFIRM4resok {
           stateid4        open_stateid;
   };

   union OPEN_CONFIRM4res switch (nfsstat4 status) {
    case NFS4_OK:
            OPEN_CONFIRM4resok     resok4;
    default:
            void;
   };
```

---
#### **16.18.4.  DESCRIPTION**

이 작업은 클라이언트가 open-owner를 처음 사용하는 경우 시퀀스 ID 사용을 확인하는 데 사용됩니다. OPEN 작업에서 반환된 stateid는 open-owner의 다음 시퀀스 ID와 함께 이 작업의 인수로 사용됩니다. OPEN\_CONFIRM에 전달된 시퀀스 ID는 OPEN 작업에 전달된 seqid보다 1\(1\) 커야 합니다\(섹션 9.1.4\). 서버가 원래 OPEN과 관련하여 예상치 못한 시퀀스 ID를 수신하면 서버는 클라이언트가 원래 OPEN을 확인하지 않고 원래 OPEN과 관련된 모든 상태가 서버에 의해 해제된다고 가정합니다.

성공하면 현재 파일 핸들이 해당 값을 유지합니다.

---
#### **16.18.5.  IMPLEMENTATION**

특정 클라이언트는 특정 클라이언트 ID에 대해 많은 open\_owner4 데이터 구조를 생성할 수 있습니다. 클라이언트는 주기적으로 open\_owner4를 폐기하거나 무기한 사용을 중지합니다. 후자의 상황은 NFSv4 프로토콜에 명시적인 프로토콜이 없는 이유입니다.

open\_owner4를 종료하는 작업: 이러한 작업은 해당 상황에서는 쓸모가 없습니다. 대신, 무제한 메모리 사용을 방지하기 위해 서버는 파일에 대한 현재 열린 상태가 없고 최근에 사용되지 않은 open\_owner4를 처리하기 위한 전략을 구현해야 합니다. open\_owner4s를 폐기할 시기를 결정하는 데 사용되는 기간은 구현 선택 사항입니다. 기간은 임대 시간에 서버가 임대 시간 이후에 구현하려는 유예 기간을 더한 것 이상이어야 합니다. OPEN\_CONFIRM 작업을 통해 서버는 사용되지 않는 open\_owner4 데이터 구조를 안전하게 삭제할 수 있습니다.

클라이언트가 OPEN 작업을 실행하고 서버에 더 이상 open\_owner4 기록이 없는 경우 서버는 이것이 재생이나 재전송이 아닌 새로운 OPEN인지 확인해야 합니다.

서버는 위임을 부여하거나 회수 작업을 수행하는 OPEN에 대한 확인을 요구해서는 안 됩니다. 자세한 내용은 섹션 9.1.11을 참조하세요. 서버는 주어진 클라이언트 ID에 대해 하나의 open\_owner4를 삭제했는지 여부를 확인하여 이를 쉽게 피할 수 있습니다. 서버가 위임을 지원하지 않으면 open\_owner4\(모든 클라이언트에 대해\)가 삭제되었는지 여부를 나타내는 단일 비트만 유지 관리할 수 있습니다.\(MUST NOT\)

서버는 세 가지 이벤트 중 하나가 발생할 때까지 확인되지 않은 OPEN 상태를 유지해야 합니다. 먼저 클라이언트는 임대 기간 내에 적절한 시퀀스 ID 및 상태 ID와 함께 OPEN\_CONFIRM 요청을 보냅니다. 이 경우 서버의 OPEN 상태는 확인됨으로 전환되고 서버의 open\_owner4는 완전히 설정됩니다.

둘째, 클라이언트는 open\_owner4에 대해 잘못된 시퀀스 ID\(순서가 아님\)를 사용하여 또 다른 OPEN 요청을 보냅니다. 이 경우 서버는 두 번째 OPEN 요청이 유효하고 첫 번째 OPEN 요청이 재생이라고 가정합니다. 서버는 첫 번째 OPEN 요청의 OPEN 상태를 취소하고, 두 번째 OPEN 요청에 대해 확인되지 않은 OPEN 상태를 설정하고, OPEN\_CONFIRM이 필요하다는 표시로 두 번째 OPEN 요청에 응답합니다. 그런 다음 프로세스가 반복됩니다. 클라이언트에 대한 서비스 거부 공격 가능성이 있지만 클라이언트와 서버에서 Kerberos V5 기반 보안 유형 또는 암호화를 사용하는 다른 유형을 사용해야 하는 경우 완화됩니다.

서버가 특정 open\_owner4에 대해 확인되지 않은 OPEN 상태이고 stateid가 있지만 해당 작업이 OPEN이 아니거나 OPEN\_CONFIRM이지만 잘못된 stateid가 있는 open\_owner4에서 작업을 수신하면 어떻게 되나요? 그런 다음 seqid가 정확하더라도 서버는 작업이 재생이라고 가정하기 때문에 NFS4ERR\_BAD\_STATEID를 반환합니다. 서버에 설정된 OPEN 상태가 없으면 LOCK 작업이 유효할 수 있는 방법이 없습니다.

셋째, 임대 기간 내에 open\_owner4에 대해서는 앞서 언급한 두 가지 이벤트 중 어느 것도 발생하지 않습니다. 이 경우 OPEN 상태가 취소되고 open\_owner4의 폐기가 발생할 수 있습니다.

---
### **16.19.  Operation 21: OPEN_DOWNGRADE - Reduce Open File Access**
---
#### **16.19.1.  SYNOPSIS**

```text
     (cfh), stateid, seqid, access, deny -> stateid
```

---
#### **16.19.2.  ARGUMENT**

```text
   struct OPEN_DOWNGRADE4args {
           /* CURRENT_FH: opened file */
           stateid4        open_stateid;
           seqid4          seqid;
           uint32_t        share_access;
           uint32_t        share_deny;
   };
```

---
#### **16.19.3.  RESULT**

```text
   struct OPEN_DOWNGRADE4resok {
           stateid4        open_stateid;
   };

   union OPEN_DOWNGRADE4res switch (nfsstat4 status) {
    case NFS4_OK:
            OPEN_DOWNGRADE4resok    resok4;
    default:
            void;
   };
```

---
#### **16.19.4.  DESCRIPTION**

이 작업은 주어진 열기에 대한 share\_access 및 share\_deny 비트를 조정하는 데 사용됩니다. 이는 특정 공개 소유자가 서로 다른 share\_access 및 share\_deny 플래그를 사용하여 동일한 파일을 여러 번 열 때 필요합니다. 이 상황에서 열기 중 하나를 닫으면 더 이상 유효하지 않은 열기와 관련된 비트를 제거하기 위해 적절한 share\_access 및 share\_deny 플래그가 변경될 수 있습니다.

이 작업에 지정된 share\_access 및 share\_deny 비트는 지정된 열린 파일에 대한 현재 비트를 대체합니다. 지정된 share\_access 및 share\_deny 비트는 현재 파일의 현재 공개 소유자에 대해 유효한 OPEN의 일부 하위 집합에 대해 지정된 share\_access 및 share\_deny 비트의 합집합과 정확히 동일해야 합니다. 해당 제약 조건이 준수되지 않으면 NFS4ERR\_INVAL 오류가 반환되어야 합니다. share\_access 및 share\_deny 비트는 이미 부여된 비트의 하위 집합이므로 공유 예약 충돌로 인해 이 요청이 거부될 수 없습니다.

OPEN\_DOWNGRADE가 파일을 쓰기용으로 열 수 없도록 변경하고 쓰기 바이트 범위 잠금이 유지될 수 있으므로 서버는 NFS4ERR\_LOCKS\_HELD를 사용하여 OPEN\_DOWNGRADE를 거부해야 할 수도 있습니다.

성공하면 현재 파일 핸들이 해당 값을 유지합니다.

---
### **16.20.  Operation 22: PUTFH - Set Current Filehandle**
---
#### **16.20.1.  SYNOPSIS**

```text
     filehandle -> (cfh)
```

---
#### **16.20.2.  ARGUMENT**

```text
   struct PUTFH4args {
           nfs_fh4         object;
   };
```

---
#### **16.20.3.  RESULT**

```text
   struct PUTFH4res {
           /* CURRENT_FH: */
           nfsstat4        status;
   };
```

---
#### **16.20.4.  DESCRIPTION**

PUTFH는 현재 파일 핸들을 인수로 제공된 파일 핸들로 바꿉니다.

요청자가 사용하는 보안 메커니즘이 이 작업에 제공된 파일 핸들의 요구 사항을 충족하지 않는 경우 서버는 NFS4ERR\_WRONGSEC를 반환해야 합니다.\(MUST\)

현재 파일 핸들에 대한 자세한 내용은 섹션 15.2.4.1을 참조하세요.

---
#### **16.20.5.  IMPLEMENTATION**

PUTFH는 일반적으로 NFS 요청의 첫 번째 연산자로 사용되어 뒤따르는 작업에 대한 컨텍스트를 설정합니다.

---
### **16.21.  Operation 23: PUTPUBFH - Set Public Filehandle**
---
#### **16.21.1.  SYNOPSIS**

```text
     - -> (cfh)
```

---
#### **16.21.2.  ARGUMENT**

```text
     void;
```

---
#### **16.21.3.  RESULT**

```text
   struct PUTPUBFH4res {
           /* CURRENT_FH: public fh */
           nfsstat4        status;
   };
```

---
#### **16.21.4.  DESCRIPTION**

PUTPUBFH는 현재 파일 핸들을 서버 네임스페이스의 공개 파일 핸들을 나타내는 파일 핸들로 바꿉니다. 이 파일 핸들은 서버의 다른 디렉터리와 연결될 수 있는 루트 파일 핸들과 다를 수 있습니다.

공개 파일 핸들 개념은 \[RFC2054\], \[RFC2055\] 및 \[RFC2224\]에서 도입되었습니다. NFSv4의 목적은 공용 파일 핸들\(PUTPUBFH 작업으로 표시됨\)을 NFSv2 및 NFSv3의 WebNFS 서버와의 호환성을 제공하는 방법으로 사용하는 것입니다.

공용 파일 핸들과 루트 파일 핸들\(PUTROOTFH 작업으로 표시됨\)은 동일해야 합니다. 공용 파일 핸들과 루트 파일 핸들이 동일하지 않으면 공용 파일 핸들은 루트 파일 핸들의 자손이어야 합니다.\(MUST\)

---
#### **16.21.5.  IMPLEMENTATION**

PUTPUBFH는 NFS 요청의 첫 번째 연산자로 사용되어 뒤따르는 작업에 대한 컨텍스트를 설정합니다.

NFSv2 및 NFSv3 공용 파일 핸들을 사용하면 클라이언트는 LOOKUP에 제공된 경로 이름을 서버 루트를 기준으로 한 절대 경로 또는 공용 파일 핸들을 기준으로 평가해야 하는지 여부를 지정할 수 있습니다. \[RFC2224\]에는 기능에 대한 추가 논의가 포함되어 있습니다. NFSv4를 사용하면 해당 유형의 사양을 LOOKUP 작업에서 직접 사용할 수 없습니다. 그 이유는 절대 대 상대를 지정하는 데 필요한 구성 요소 구분 기호가 NFSv4에서 허용되지 않기 때문입니다. 따라서 클라이언트는 PUTROOTFH 또는 PUTPUBFH가 각각 NFS URL의 절대 평가 또는 상대 평가를 나타내는 데 사용되도록 요청을 구성할 책임이 있습니다.

\[RFC2224\]에는 절대 평가 사용과 사용 가능한 네임스페이스의 양과 관련하여 서버가 해당 평가에 적용할 수 있는 제한과 관련하여 언급된 경고가 있습니다. 이와 동일한 경고가 NFSv4에도 적용됩니다. 따라서 서버 구현 세부 사항으로 인해 NFSv3 절대 공용 파일 핸들 조회가 NFSv4 절대 확인과 다르게 동작할 수 있습니다.

SNEGO\(Simple and Protected GSS-API Negotiation Mechanism\) \[RFC4178\]를 사용하는 방법으로 공용 파일 핸들을 사용하는 \[RFC2755\]에 설명된 보안 협상 형식이 있습니다. 파일 핸들은 특별한 의미로 오버로드되지 않고 따라서 NFSv2 및 NFSv3과 동일한 프레임워크를 제공하지 않기 때문에 NFSv4에서는 이 방법을 사용할 수 없습니다. 따라서 클라이언트는 이 RFC에 설명된 보안 협상 메커니즘을 사용해야 합니다.

---
### **16.22.  Operation 24: PUTROOTFH - Set Root Filehandle**
---
#### **16.22.1.  SYNOPSIS**

```text
     - -> (cfh)
```

---
#### **16.22.2.  ARGUMENT**

```text
     void;
```

---
#### **16.22.3.  RESULT**

```text
   struct PUTROOTFH4res {
           /* CURRENT_FH: root fh */
           nfsstat4        status;
   };
```

---
#### **16.22.4.  DESCRIPTION**

PUTROOTFH는 현재 파일 핸들을 서버 네임스페이스의 루트를 나타내는 파일 핸들로 바꿉니다. 이 파일 핸들에서 LOOKUP 작업은 서버의 다른 파일 핸들을 찾을 수 있습니다. 이 파일 핸들은 서버의 다른 디렉터리와 연결될 수 있는 공용 파일 핸들과 다를 수 있습니다.

현재 파일 핸들에 대한 자세한 내용은 섹션 15.2.4.1을 참조하세요.

---
#### **16.22.5.  IMPLEMENTATION**

PUTROOTFH는 일반적으로 NFS 요청의 첫 번째 연산자로 사용되어 뒤따르는 작업에 대한 컨텍스트를 설정합니다.

---
### **16.23.  Operation 25: READ - Read from File**
---
#### **16.23.1.  SYNOPSIS**

```text
     (cfh), stateid, offset, count -> eof, data
```

---
#### **16.23.2.  ARGUMENT**

```text
   struct READ4args {
           /* CURRENT_FH: file */
           stateid4        stateid;
           offset4         offset;
           count4          count;
   };
```

---
#### **16.23.3.  RESULT**

```text
   struct READ4resok {
           bool            eof;
           opaque          data<>;
   };

   union READ4res switch (nfsstat4 status) {
    case NFS4_OK:
            READ4resok     resok4;
    default:
            void;
   };
```

---
#### **16.23.4.  DESCRIPTION**

READ 작업은 현재 파일 핸들로 식별되는 일반 파일에서 데이터를 읽습니다.

클라이언트는 READ가 시작될 위치의 오프셋과 읽을 바이트 수를 제공합니다. 오프셋 0\(영\)은 파일의 시작 부분부터 데이터를 읽는다는 의미입니다. 오프셋이 파일 크기보다 크거나 같으면 상태 NFS4\_OK가 데이터 길이가 0으로 설정된 상태로 반환되고 eof는 TRUE로 설정됩니다. READ에는 액세스 권한 검사가 적용됩니다.

클라이언트가 카운트 값을 0\(영\)으로 지정하면 READ가 성공하고 0\(영\) 바이트의 데이터를 반환합니다\(액세스 권한 확인에 따라 다름\). 서버는 클라이언트가 지정한 것보다 적은 바이트를 반환하도록 선택할 수 있습니다. 클라이언트는 이 조건을 확인하고 적절하게 처리해야 합니다.

READ 요청의 stateid 값은 이전 바이트 범위 잠금 또는 공유 예약 요청에서 반환된 값 또는 위임과 연결된 stateid를 나타냅니다. stateid는 서버에서 관련 공유 예약 및 바이트 범위 잠금이 여전히 유효한지 확인하고 클라이언트에 대한 임대 시간 제한을 업데이트하는 데 사용됩니다.

READ가 파일 끝에서 종료되거나\(공식적으로 올바른 형식의 READ 요청에서 오프셋 + 개수가 파일 크기와 같은 경우\) READ 요청이 파일 크기를 초과하는 경우\(오프셋 + 개수가 있는 경우\) count가 파일 크기보다 큰 경우\) eof는 TRUE로 반환됩니다. 그렇지 않으면 FALSE입니다. 빈 파일을 성공적으로 읽으면 eof가 항상 TRUE로 반환됩니다.

현재 파일 핸들이 일반 파일이 아닌 경우 클라이언트에 오류가 반환됩니다. 현재 파일 핸들이 디렉터리를 나타내는 경우 NFS4ERR\_ISDIR이 반환됩니다. 그렇지 않으면 NFS4ERR\_INVAL이 반환됩니다.

특별한 익명 상태 ID를 사용하는 READ의 경우 서버는 필수 파일 잠금 또는 파일에 대한 현재 share\_deny 모드에 따라 READ가 서비스되도록 허용할 수 있습니다. 특별한 READ 우회 상태 ID를 사용하는 READ의 경우 서버는 READ 작업이 서버의 잠금 검사를 우회하도록 허용할 수 있습니다.\(MAY, MAY\)

성공하면 현재 파일 핸들이 해당 값을 유지합니다.

---
#### **16.23.5.  IMPLEMENTATION**

서버가 "짧은 읽기"\(즉, 요청한 것보다 적은 데이터와 FALSE로 설정된 데이터\)를 반환하는 경우 클라이언트는 나머지 데이터를 가져오기 위해 또 다른 READ를 보내야 합니다. 서버는 여러 상황에서 요청한 것보다 적은 양의 데이터를 반환할 수 있습니다. 다른 클라이언트나 서버 자체에서 파일이 잘려서 요청 클라이언트가 생각하는 파일 크기가 변경되었을 수 있습니다. 이렇게 하면 클라이언트가 사용할 수 있는 실제 데이터 양이 줄어듭니다. 서버가 전송 크기를 줄여 짧은 읽기 결과를 반환할 수도 있습니다. 서버 리소스가 고갈되면 읽기 시간이 짧아질 수도 있습니다.

파일에 필수 바이트 범위 잠금이 적용되고 파일에서 읽을 데이터에 해당하는 바이트 범위가 stateid와 연결되지 않은 소유자에 의해 WRITE\_LT 잠긴 경우 서버는 NFS4ERR\_LOCKED 오류를 반환합니다. 클라이언트는 READ를 다시 시도하기 전에 LOCK 작업을 통해 적절한 READ\_LT를 얻으려고 시도해야 합니다. READ가 완료되면 클라이언트는 LOCKU를 통해 바이트 범위 잠금을 해제해야 합니다.

다른 클라이언트가 읽고 있는 파일에 대해 OPEN\_DELEGATE\_WRITE 위임을 갖고 있는 경우 위임을 회수해야 하며 해당 위임이 반환되거나 취소될 때까지 작업을 진행할 수 없습니다. 매우 빠르게 발생하는 경우를 제외하고 위임이 미해결 상태로 유지되는 동안 요청에 하나 이상의 NFS4ERR\_DELAY 오류가 반환됩니다. 일반적으로 위임은 READ 작업의 결과로 회수되지 않습니다. 왜냐하면 회수는 이전 OPEN의 결과로 발생하기 때문입니다. 그러나 특수한 stateid를 사용하여 READ를 수행할 수 있으므로 클라이언트가 이전에 OPEN을 수행했어야 하더라도 서버는 이 경우를 확인해야 합니다.

---
### **16.24.  Operation 26: READDIR - Read Directory**
---
#### **16.24.1.  SYNOPSIS**

```text
     (cfh), cookie, cookieverf, dircount, maxcount, attr_request ->
     cookieverf { cookie, name, attrs }
```

---
#### **16.24.2.  ARGUMENT**

```text
   struct READDIR4args {
           /* CURRENT_FH: directory */
           nfs_cookie4     cookie;
           verifier4       cookieverf;
           count4          dircount;
           count4          maxcount;
           bitmap4         attr_request;
   };
```

---
#### **16.24.3.  RESULT**

```text
   struct entry4 {
           nfs_cookie4     cookie;
           component4      name;
           fattr4          attrs;
           entry4          *nextentry;
   };

   struct dirlist4 {
           entry4          *entries;
           bool            eof;
   };

   struct READDIR4resok {
           verifier4       cookieverf;
           dirlist4        reply;
   };

   union READDIR4res switch (nfsstat4 status) {
    case NFS4_OK:
            READDIR4resok  resok4;
    default:
            void;
   };
```

---
#### **16.24.4.  DESCRIPTION**

READDIR 작업은 파일 시스템 디렉터리에서 가변 개수의 항목을 검색하고 각 항목에 대해 클라이언트가 요청한 속성과 클라이언트가 후속 READDIR에서 추가 디렉터리 항목을 요청할 수 있도록 하는 정보를 반환합니다.

인수에는 디렉터리 내에서 READDIR이 시작되어야 하는 위치를 나타내는 쿠키 값이 포함되어 있습니다. 쿠키 값 0\(영\)은 디렉터리 시작 부분에서 읽기를 시작하는 데 사용됩니다. 후속 READDIR 요청의 경우 클라이언트는 이전 READDIR 요청에서 서버가 제공한 쿠키 값을 지정합니다.

cookieverf 값은 쿠키 값이 0\(영\)\(첫 번째 디렉터리 읽기\)인 경우 0\(영\)으로 설정되어야 합니다. 후속 요청에서는 서버가 반환한 cookieverf여야 합니다. cookieverf는 쿠키를 획득한 READDIR에서 반환한 것과 일치해야 합니다. 서버가 cookieverf가 더 이상 해당 디렉터리에 유효하지 않다고 판단하면 NFS4ERR\_NOT\_SAME 오류가 반환되어야 합니다.

인수의 dircount 부분은 반환되어야 하는 디렉터리 정보의 최대 바이트 수에 대한 힌트입니다. 이 값은 디렉터리 항목 이름의 길이와 해당 항목의 쿠키 값을 나타냅니다. 이 길이는 서버의 기본 형식의 길이가 아니라 데이터\(이름 및 쿠키\)의 XDR 인코딩을 나타냅니다.

인수의 maxcount 값은 결과의 최대 바이트 수입니다. 이 최대 크기는 READDIR4resok 구조 내에서 반환되는 모든 데이터를 나타내며 XDR 오버헤드를 포함합니다. 서버가 더 적은 양의 데이터를 반환할 수 있습니다. 서버가 최대 개수 제한 내에서 단일 디렉터리 항목을 반환할 수 없는 경우 NFS4ERR\_TOOSMALL 오류가 클라이언트에 반환됩니다.

마지막으로 attr\_request는 서버가 제공하는 각 디렉토리 항목에 대해 반환될 속성 목록을 나타냅니다.

성공적으로 반환되면 서버의 응답은 디렉터리 항목 목록을 제공합니다. 이러한 각 항목에는 디렉터리 항목의 이름, 해당 항목의 쿠키 값 및 요청된 관련 속성이 포함되어 있습니다. 디렉토리에 더 이상 항목이 없으면 "eof" 플래그는 TRUE 값을 갖습니다.

쿠키 값은 서버에만 의미가 있으며 디렉터리 항목에 대한 "책갈피"로 사용됩니다. 언급한 대로 이 쿠키는 클라이언트가 후속 READDIR 작업에 사용하여 디렉터리를 계속 읽을 수 있습니다. 쿠키는 개념상 쿠키와 유사합니다.

READ 오프셋이지만 클라이언트가 그렇게 해석하면 안 됩니다. 서버는 READDIR 호출 사이에 디렉터리가 수정된 경우에도 READDIR 응답으로 발행된 쿠키 값을 수락하려고 시도해야 하지만, 서버가 중간에 재부팅된 경우와 같이 이것이 가능하지 않은 경우 NFS4ERR\_NOT\_VALID를 반환할 수 있습니다.\(SHOULD\)

어떤 경우에는 서버가 디렉토리 항목의 속성을 가져오는 동안 오류가 발생할 수 있습니다. 전체 READDIR 작업에 대해 오류를 반환하는 대신 서버는 'fattr4\_rdattr\_error' 속성을 반환할 수 있습니다. 이를 통해 서버는 클라이언트에 오류를 전달할 수 있으며 일시적 오류가 발생할 수 있는 경우 전체 작업이 실패하지 않도록 할 수 있습니다. 분명히 이 메서드가 제대로 작동하려면 클라이언트가 fattr4\_rdattr\_error 속성을 요청해야 합니다. 클라이언트가 속성을 요청하지 않으면 서버는 전체 READDIR 작업에 대해 실패를 반환할 수밖에 없습니다.

일부 파일 시스템 환경의 경우 디렉터리 항목 "." 및 ".."은 특별한 의미를 가지며, 다른 환경에서는 그렇지 않을 수도 있습니다. 서버가 디렉터리 내에서 이러한 특수 항목을 지원하는 경우 해당 항목이 READDIR 응답의 일부로 클라이언트에 반환되어서는 안 됩니다. 일부 클라이언트 환경을 활성화하려면 쿠키 값 0, 1, 2가 예약된 것으로 간주됩니다. UNIX 클라이언트는 서버의 응답과 로컬 표현을 결합하여 응용 프로그램에 대한 완전한 형식의 UNIX 디렉터리 표현을 활성화할 때 이러한 값을 사용합니다.

READDIR 인수의 경우 쿠키 값 1과 2를 사용하면 안 되며, READDIR 결과의 경우 쿠키 값 0, 1, 2가 반환되어서는 안 됩니다.\(MUST NOT\)

성공하면 현재 파일 핸들이 해당 값을 유지합니다.

---
#### **16.24.5.  IMPLEMENTATION**

서버의 파일 시스템 디렉토리 표현은 크게 다를 수 있습니다. 클라이언트의 프로그래밍 인터페이스는 NFS 프로토콜로 제대로 변환되지 않는 방식으로 로컬 운영 환경에 바인딩될 수도 있습니다. 따라서 클라이언트가 서버에 지침을 제공할 수 있도록 dircount 및 maxcount 필드가 제공됩니다. 클라이언트가 READDIR 중에 속성 수집에 적극적이라면 서버는 인코딩된 응답을 제한하는 방법에 대한 아이디어를 가지고 있습니다. dircount 필드는 디렉토리 항목 이름만을 기준으로 항목 수에 대한 힌트를 제공합니다. 힌트이므로 dircount 값이 0일 수도 있습니다. 이 경우 서버는 dircount 값을 무시하고 지정된 maxcount 값을 기반으로 디렉터리 정보를 반환할 수 있습니다.

일단 수신된 쿠키 값이 이후에 사용되지 않을 것임을 클라이언트가 나타낼 수 있는 방법이 없기 때문에 서버 구현에서는 반환된 쿠키에 해당하는 메모리를 할당하는 방식을 피해야 합니다. 서버가 검색을 재개할 디렉터리 내의 오프셋과 같은 값에 따라 쿠키 값을 기반으로 하는 경우 이러한 할당을 피할 수 있습니다.

이러한 기술로 생성된 쿠키는 관련 디렉터리가 수정되더라도 유효하게 유지되도록 설계되어야 합니다. 서버가 디렉터리 수정으로 인해 쿠키를 무효화하는 경우 대규모 디렉터리의 READDIR이 완료되지 않을 수 있습니다.

클라이언트가 디렉터리에 대해 하나 이상의 READDIR 작업을 수행한 후 디렉터리가 삭제되면 반환된 쿠키는 유효하지 않게 됩니다. 그러나 이전에 사용된 디렉토리 파일 핸들이 오래되어 후속 READDIR 작업에서 이와 같이 보고되므로 서버는 걱정할 필요가 없습니다. 이 경우 서버는 쿠키 검증 프로그램을 확인할 필요가 없습니다.

그러나 디렉터리에 대한 특정 재구성 작업\(디렉터리 압축 포함\)으로 인해 이전에 제공된 READDIR 쿠키가 무효화될 수 있습니다. 이러한 상황이 발생하면 서버는 더 이상 유효하지 않은 쿠키의 사용을 허용하지 않도록 쿠키 검증 프로그램을 수정해야 합니다.

cookieverf는 오래될 수 있는 쿠키 값을 관리하는 데 도움을 주기 위해 서버에서 사용될 수 있습니다. 서버가 제공된 쿠키/쿠키버프 쌍을 사용하여 디렉터리를 계속해서 올바르게 읽을 수 없는 경우는 거의 발생하지 않습니다. 클라이언트의 애플리케이션이 이러한 유형의 오류를 적절하게 처리하지 못할 수 있으므로 서버는 이 상황을 피하기 위해 모든 노력을 기울여야 합니다.

cookieverf를 사용하면 클라이언트가 오래되었을 수 있는 READDIR 쿠키 값을 사용하지 못하도록 보호할 수도 있습니다. 예를 들어 파일 시스템이 마이그레이션된 경우 서버는 이전 서버에서 사용했던 것과 동일한 쿠키 값을 사용하여 READDIR을 서비스할 수도 있고 그렇지 않을 수도 있습니다. 클라이언트가 cookieverf를 제공하면 서버는 클라이언트에 적절한 응답을 제공할 수 있습니다. 이렇게 하면 서버가 쿠키 값을 수락할 수 있지만 기본 디렉터리가 변경되어 이전 READDIR의 클라이언트 컨텍스트에서 응답이 유효하지 않은 경우가 방지됩니다.

일부 서버는 "."을 반환하지 않기 때문에 및 ".." 항목은 이전 버전의 NFS 프로토콜에서 수행된 것처럼 READDIR 응답에 이러한 항목이 있어야 하는 클라이언트가 해당 항목을 조작해야 합니다.

---
### **16.25.  Operation 27: READLINK - Read Symbolic Link**
---
#### **16.25.1.  SYNOPSIS**

```text
     (cfh) -> linktext
```

---
#### **16.25.2.  ARGUMENT**

```text
     /* CURRENT_FH: symlink */
     void;
```

---
#### **16.25.3.  RESULT**

```text
   struct READLINK4resok {
           linktext4       link;
   };

   union READLINK4res switch (nfsstat4 status) {
    case NFS4_OK:
            READLINK4resok resok4;
    default:
            void;
   };
```

---
#### **16.25.4.  DESCRIPTION**

READLINK는 심볼릭 링크와 관련된 데이터를 읽습니다. 데이터는 서버에 불투명한 UTF-8 문자열입니다. 즉, NFS 클라이언트에 의해 생성되거나 서버에서 로컬로 생성되는 경우 기호 링크의 데이터는 생성 시 해석되지 않고 단순히 저장됩니다.

성공하면 현재 파일 핸들이 해당 값을 유지합니다.

---
#### **16.25.5.  IMPLEMENTATION**

심볼릭 링크는 명목상 다른 파일에 대한 포인터입니다. 데이터가 반드시 서버에 의해 해석되는 것은 아닙니다. 그냥 파일에 저장됩니다. 클라이언트 구현에서는 서버 운영 체제에 의미가 없는 경로 이름을 기호 링크에 저장할 수 있습니다. READLINK 작업은 해석을 위해 데이터를 클라이언트에 반환합니다. 서로 다른 구현이 기호 링크에 대한 액세스를 공유하려는 경우 기호 링크의 데이터 해석에 동의해야 합니다.

READLINK 작업은 NF4LNK 유형의 개체에만 허용됩니다. 개체가 NF4LNK 유형이 아닌 경우 서버는 NFS4ERR\_INVAL 오류를 반환해야 합니다.

---
### **16.26.  Operation 28: REMOVE - Remove File System Object**
---
#### **16.26.1.  SYNOPSIS**

```text
     (cfh), filename -> change_info
```

---
#### **16.26.2.  ARGUMENT**

```text
   struct REMOVE4args {
           /* CURRENT_FH: directory */
           component4      target;
   };
```

---
#### **16.26.3.  RESULT**

```text
   struct REMOVE4resok {
           change_info4    cinfo;
   };

   union REMOVE4res switch (nfsstat4 status) {
    case NFS4_OK:
            REMOVE4resok   resok4;
    default:
            void;
   };
```

---
#### **16.26.4.  DESCRIPTION**

REMOVE 작업은 현재 파일 핸들에 해당하는 디렉터리에서 filename이라는 디렉터리 항목을 제거\(삭제\)합니다. 디렉토리의 항목이 해당 파일 시스템 개체에 대한 마지막 참조인 경우 개체가 삭제될 수 있습니다.

파일 이름이 제거된 디렉터리에 대해 서버는 cinfo에change\_info4 정보를 반환합니다. Change\_info4 구조체의 원자 필드를 사용하면 서버는 제거와 관련하여 변경 전후 속성이 원자적으로 획득되었는지 여부를 나타냅니다.

대상의 길이가 0이면 NFS4ERR\_INVAL이 반환됩니다. 대상에는 일반 UTF-8, 문자 지원 및 이름 확인도 적용됩니다. 자세한 내용은 섹션 12.7을 참조하세요.

성공하면 현재 파일 핸들이 해당 값을 유지합니다.

---
#### **16.26.5.  IMPLEMENTATION**

NFSv3에는 디렉터리 제거를 위해 다른 연산자\(RMDIR\)가 필요하고, 디렉터리가 아닌 제거를 위해서는 REMOVE가 필요합니다. 이를 통해 클라이언트는 디렉토리를 제거하기 위해 디렉토리가 아닌 삭제 시스템 호출\(예: POSIX의 unlink\(\) \[unlink\]\)이 전달될 때 파일 형식 확인을 건너뛸 수 있을 뿐만 아니라 그 반대의 경우\(예: POSIX의 rmdir\(\)\) 디렉터리가 아닌 경우\) 서버가 파일 형식을 확인할 것이라는 것을 알았기 때문입니다. NFSv4 REMOVE는 파일 유형에 관계없이 모든 디렉터리 항목을 삭제하는 데 사용할 수 있습니다. unlink\(\) 및 rmdir\(\) 시스템 호출의 NFSv4 클라이언트 진입점 구현자는 REMOVE를 실행하기 전에 시스템 호출이 제거할 수 있는 유형에 대해 먼저 파일 유형을 확인해야 합니다. 또는 구현자는 동일한 COMPOUND 호출에서 REMOVE 작업 전에 파일 형식을 확인하기 위해 LOOKUP/VERIFY 시퀀스를 포함하는 COMPOUND 호출을 생성할 수 있습니다.

마지막 참조의 개념은 서버마다 다릅니다. 그러나 객체의 이전 속성에 있는 numlinks 필드의 값이 1인 경우 클라이언트는 파일 핸들을 통해 객체를 참조하는 데 의존해서는 안 됩니다. 마찬가지로 클라이언트는 즉시 사용할 수 있게 되는 개체와 이전에 연결되었던 리소스\(디스크 공간, 디렉터리 항목 등\)에 의존해서는 안 됩니다. 따라서 클라이언트가 REMOVE를 사용하여 파일을 제거한 후에도 파일에 계속 액세스할 수 있어야 하는 경우 클라이언트는 파일에 계속 액세스할 수 있는지 확인하기 위한 조치를 취해야 합니다. 사용되는 일반적인 메커니즘은 파일의 이름을 이전 이름에서 새로운 숨겨진 이름으로 바꾸는 것입니다.

REMOVE 명령이 도착했을 때 서버에서 파일이 아직 열려 있는 것을 발견한 경우:

o 파일이 OPEN4\_SHARE\_DENY\_WRITE 또는 OPEN4\_SHARE\_DENY\_BOTH로 열린 경우 서버는 파일의 디렉터리 항목을 삭제해서는 안 됩니다.\(SHOULD NOT\)

o 파일이 OPEN4\_SHARE\_DENY\_WRITE로 열리지 않았거나

- OPEN4\_SHARE\_DENY\_BOTH, 서버는 파일의 디렉터리 항목을 삭제해야 합니다. 그러나 파일의 마지막 CLOSE까지 서버는 파일 핸들을 통해 파일에 대한 액세스를 계속 허용할 수 있습니다.\(SHOULD, MAY\)

---
### **16.27.  Operation 29: RENAME - Rename Directory Entry**
---
#### **16.27.1.  SYNOPSIS**

```text
     (sfh), oldname, (cfh), newname -> source_cinfo, target_cinfo
```

---
#### **16.27.2.  ARGUMENT**

```text
   struct RENAME4args {
           /* SAVED_FH: source directory */
           component4      oldname;
           /* CURRENT_FH: target directory */
           component4      newname;
   };
```

---
#### **16.27.3.  RESULT**

```text
   struct RENAME4resok {
           change_info4    source_cinfo;
           change_info4    target_cinfo;
   };

   union RENAME4res switch (nfsstat4 status) {
    case NFS4_OK:
            RENAME4resok    resok4;
    default:
            void;
   };
```

---
#### **16.27.4.  DESCRIPTION**

RENAME 작업은 SAVEFH 작업에 의해 설정된 저장된 파일 핸들에 해당하는 소스 디렉터리에서 oldname으로 식별된 개체의 이름을 현재 파일 핸들에 해당하는 대상 디렉터리의 newname으로 바꿉니다. 작업은 클라이언트에 대해 원자적이어야 합니다. 소스 및 대상 디렉토리는 서버의 동일한 파일 시스템에 있어야 합니다. 성공하면 현재 파일 핸들이 계속 대상 디렉터리가 됩니다.

대상 디렉터리에 newname이라는 이름의 항목이 이미 포함되어 있는 경우 소스 개체는 대상과 호환되어야 합니다. 둘 다 디렉터리가 아니거나 둘 다 디렉터리이고 대상은 비어 있어야 합니다. 호환되는 경우 기존 대상은 이름 변경이 발생하기 전에 제거됩니다\(대상이 제거될 때마다 클라이언트 및 서버 작업은 섹션 16.26 참조\). 호환되지 않거나 대상이 디렉터리이지만 비어 있지 않은 경우 서버는 NFS4ERR\_EXIST 오류를 반환합니다.

oldname과 newname이 모두 동일한 파일을 참조하는 경우\(서로의 하드 링크일 수 있음\) RENAME은 아무 작업도 수행하지 않고 성공을 반환해야 합니다.

RENAME과 관련된 두 디렉터리 모두에 대해 서버는change\_info4 정보를 반환합니다. Change\_info4 구조체의 원자 필드를 사용하면 서버는 이름 바꾸기와 관련하여 변경 전후 속성이 원자적으로 획득되었는지 여부를 나타냅니다.

이전 이름이 명명된 속성을 참조하고 저장된 파일 핸들과 현재 파일 핸들이 다른 파일 시스템 개체의 명명된 속성 디렉터리를 참조하는 경우 서버는 마치 저장된 파일 핸들과 현재 파일 핸들이 다른 파일 시스템의 디렉터리를 나타내는 것처럼 NFS4ERR\_XDEV를 반환합니다.

oldname 또는 newname의 길이가 0인 경우 NFS4ERR\_INVAL이 반환됩니다. oldname과 newname에는 일반 UTF-8, 문자 지원 및 이름 확인도 적용됩니다. 자세한 내용은 섹션 12.7을 참조하세요.

---
#### **16.27.5.  IMPLEMENTATION**

RENAME 작업은 클라이언트에 대해 원자적이어야 합니다. "소스 및 대상 디렉토리는 서버의 동일한 파일 시스템에 있어야 합니다"라는 설명은 디렉토리 속성의 fsid 필드가 동일함을 의미합니다. 서로 다른 파일 시스템에 상주하는 경우 NFS4ERR\_XDEV 오류가 반환됩니다.

객체의 fh\_expire\_type 속성 값에 따라 파일 핸들은 RENAME 시 만료되거나 만료되지 않을 수 있습니다. 그러나 서버 구현자는 이러한 방식으로 파일 핸들이 만료되지 않도록 시도하는 것이 좋습니다.

일부 서버에서는 파일 이름 "." 및 ".."은 oldname이나 newname에 적합하지 않으며 NFS4ERR\_BADNAME 오류가 발생합니다. 또한 많은 서버에서 oldname 또는 newname이 소스 디렉토리의 별칭인 경우가 확인됩니다. 이러한 경우 이러한 서버는 NFS4ERR\_INVAL 오류를 반환합니다.

소스 또는 대상 파일 핸들 중 하나가 디렉터리가 아닌 경우 서버는 NFS4ERR\_NOTDIR을 반환합니다.

---
### **16.28.  Operation 30: RENEW - Renew a Lease**
---
#### **16.28.1.  SYNOPSIS**

```text
     clientid -> ()
```

---
#### **16.28.2.  ARGUMENT**

```text
   struct RENEW4args {
           clientid4       clientid;
   };
```

---
#### **16.28.3.  RESULT**

```text
   struct RENEW4res {
           nfsstat4        status;
   };
```

---
#### **16.28.4.  DESCRIPTION**

RENEW 작업은 클라이언트가 현재 서버에 보유하고 있는 임대를 갱신하는 데 사용됩니다. RENEW 요청을 처리할 때 서버는 클라이언트와 관련된 모든 임대를 갱신합니다. 연관된 임대는 SETCLIENTID 작업을 통해 제공된 clientid에 의해 결정됩니다.

---
#### **16.28.5.  IMPLEMENTATION**

클라이언트가 위임을 보유한 경우 RENEW를 사용하여 서버가 콜백 경로가 다운되었다고 판단한 시기를 감지해야 합니다. 서버가 그러한 결정을 내리면 RENEW 작업만 위임에 대한 임대를 갱신합니다. 서버는 콜백 경로가 다운되었다고 판단하면 NFS4ERR\_CB\_PATH\_DOWN을 반환합니다. NFS4ERR\_CB\_PATH\_DOWN을 반환하더라도 서버는 클라이언트가 서버에 설정한 바이트 범위 잠금 및 공유 예약에 대한 임대를 갱신해야 합니다. 어떤 이유로 잠금 및 공유 예약 임대를 갱신할 수 없는 경우 콜백 경로도 다운된 경우에도 서버는 NFS4ERR\_CB\_PATH\_DOWN 이외의 오류를 반환해야 합니다. 서버가 NFS4ERR\_CB\_PATH\_DOWN 또는 NFS4ERR\_LEASE\_MOVED를 반환할 수 있는 조건이 있는 경우 NFS4ERR\_LEASE\_MOVED를 먼저 처리해야 합니다.\(MUST, MUST, MUST\)

RENEW를 발행하는 클라이언트는 주체, RPC 보안 특성, 그리고 해당되는 경우 다음 알고리즘 중 하나를 통해 GSS-API 메커니즘 및 서비스를 선택해야 합니다.\(MUST\)

o 클라이언트는 동일한 주체인 RPC 보안 특성을 사용하며, 특성이 RPCSEC\_GSS인 경우 클라이언트 ID가 SETCLIENTID\_CONFIRM을 통해 설정될 때 사용된 것과 동일한 메커니즘 및 서비스를 사용합니다.

o 클라이언트는 현재 서버에 OPEN 파일이 있는 모든 주체, RPC 보안 특성, 메커니즘 및 서비스 조합을 사용합니다. 즉, 동일한 주체가 OPEN 작업을 성공적으로 수행했습니다. 파일은 해당 주체에 의해 여전히 열려 있습니다. RENEW의 특징, 메커니즘, 서비스는 이전 OPEN과 일치합니다.

서버는 앞서 언급한 알고리즘 중 하나를 사용하지 않는 RENEW를 NFS4ERR\_ACCESS 오류와 함께 거부해야 합니다.\(MUST\)

---
### **16.29.  Operation 31: RESTOREFH - Restore Saved Filehandle**
---
#### **16.29.1.  SYNOPSIS**

```text
     (sfh) -> (cfh)
```

---
#### **16.29.2.  ARGUMENT**

```text
     /* SAVED_FH: */
     void;
```

---
#### **16.29.3.  RESULT**

```text
   struct RESTOREFH4res {
           /* CURRENT_FH: value of saved fh */
           nfsstat4        status;
   };
```

---
#### **16.29.4.  DESCRIPTION**

현재 파일 핸들을 저장된 파일 핸들의 값으로 설정합니다. 저장된 파일 핸들이 없으면 NFS4ERR\_RESTOREFH 오류를 반환합니다.

---
#### **16.29.5.  IMPLEMENTATION**

OPEN 및 LOOKUP과 같은 작업은 현재 파일 핸들을 사용하여 디렉터리를 나타내고 이를 새 파일 핸들로 바꿉니다. 이전 파일 핸들이 SAVEFH 연산자로 저장되었다고 가정하면 이전 파일 핸들을 현재 파일 핸들로 복원할 수 있습니다. 이는 일반적으로 디렉토리에 대한 사후 작업 속성을 얻는 데 사용됩니다.

```text
     PUTFH (directory filehandle)
     SAVEFH
     GETATTR attrbits     (pre-op dir attrs)
     CREATE optbits "foo" attrs
     GETATTR attrbits     (file attributes)
     RESTOREFH
     GETATTR attrbits     (post-op dir attrs)
```

---
### **16.30.  Operation 32: SAVEFH - Save Current Filehandle**
---
#### **16.30.1.  SYNOPSIS**

```text
     (cfh) -> (sfh)
```

---
#### **16.30.2.  ARGUMENT**

```text
     /* CURRENT_FH: */
     void;
```

---
#### **16.30.3.  RESULT**

```text
   struct SAVEFH4res {
           /* SAVED_FH: value of current fh */
           nfsstat4        status;
   };
```

---
#### **16.30.4.  DESCRIPTION**

현재 파일 핸들을 저장합니다. 이전 파일 핸들이 저장된 경우 더 이상 액세스할 수 없습니다. 저장된 파일 핸들은 RESTOREFH 연산자를 사용하여 현재 파일 핸들로 복원할 수 있습니다.

성공하면 현재 파일 핸들이 해당 값을 유지합니다.

---
#### **16.30.5.  IMPLEMENTATION**
---
### **16.31.  Operation 33: SECINFO - Obtain Available Security**
---
#### **16.31.1.  SYNOPSIS**

```text
     (cfh), name -> { secinfo }
```

---
#### **16.31.2.  ARGUMENT**

```text
   struct SECINFO4args {
           /* CURRENT_FH: directory */
           component4      name;
   };
```

---
#### **16.31.3.  RESULT**

```text
   /*
    * From RFC 2203
    */
   enum rpc_gss_svc_t {
           RPC_GSS_SVC_NONE        = 1,
           RPC_GSS_SVC_INTEGRITY   = 2,
           RPC_GSS_SVC_PRIVACY     = 3
   };

   struct rpcsec_gss_info {
           sec_oid4        oid;
           qop4            qop;
           rpc_gss_svc_t   service;
   };

   /* RPCSEC_GSS has a value of '6'.  See RFC 2203 */
   union secinfo4 switch (uint32_t flavor) {
    case RPCSEC_GSS:
            rpcsec_gss_info        flavor_info;
    default:
            void;
   };

   typedef secinfo4 SECINFO4resok<>;

   union SECINFO4res switch (nfsstat4 status) {
    case NFS4_OK:
            SECINFO4resok resok4;
    default:
            void;
   };
```

---
#### **16.31.4.  DESCRIPTION**

SECINFO 작업은 클라이언트가 특정 디렉터리 파일 핸들, 파일 이름 쌍에 대한 유효한 RPC 인증 특성 목록을 얻는 데 사용됩니다. SECINFO는 이름을 평가할 때 LOOKUP에 사용되는 것과 동일한 액세스 방법을 적용해야 합니다. 따라서 요청자에게 이름에 대한 LOOKUP을 수행할 수 있는 적절한 액세스 권한이 없는 경우 SECINFO는 동일한 방식으로 작동하고 NFS4ERR\_ACCESS를 반환해야 합니다.

결과에는 서버의 기본 설정에 해당하는 순서와 함께 사용 가능한 보안 메커니즘을 나타내는 배열이 포함됩니다. 가장 선호되는 항목은 배열의 첫 번째 항목입니다. 클라이언트는 원하고 지원하는 보안 메커니즘을 자유롭게 선택하거나 서버의 기본 설정 순서에 따라 지원하는 첫 번째 보안 메커니즘을 선택할 수 있습니다. 배열 항목은 secinfo4 구조로 표시됩니다. 'flavor' 필드에는 AUTH\_NONE, AUTH\_SYS\(\[RFC5531\]에 정의됨\) 또는 RPCSEC\_GSS\(\[RFC2203\]에 정의됨\) 값이 포함됩니다.

AUTH\_NONE 및 AUTH\_SYS 버전의 경우 추가 보안 정보가 반환되지 않습니다. RPCSEC\_GSS 반환 값의 경우 메커니즘 객체 ID\(\[RFC2743\]에 정의됨\), 보호 품질\(\[RFC2743\]에 정의됨\) 및 서비스 유형\(\[RFC2203에 정의됨\)을 포함하는 보안 트리플이 반환됩니다. \]\). SECINFO는 서로 다른 보안 트리플 값을 사용하여 RPCSEC\_GSS와 동일한 특징을 가진 여러 항목을 반환할 수 있습니다.

성공하면 현재 파일 핸들이 해당 값을 유지합니다.

이름의 길이가 0\(영\)이거나 이름이 UTF-8 정의를 따르지 않으면 NFS4ERR\_INVAL 오류가 반환됩니다.

---
#### **16.31.5.  IMPLEMENTATION**

SECINFO 작업은 NFS4ERR\_WRONGSEC의 오류 값이 다른 NFS 작업에서 반환될 때 NFS 클라이언트에서 사용될 것으로 예상됩니다. 이는 서버의 보안 정책이 클라이언트가 현재 사용하고 있는 것과 다르다는 것을 클라이언트에게 나타냅니다. 이 시점에서 클라이언트는 가능한 보안 종류 목록을 얻고 해당 정책에 가장 적합한 것을 선택해야 합니다.

언급한 대로 서버의 보안 정책은 클라이언트 요청이 NFS4ERR\_WRONGSEC를 수신하는 시기를 결정합니다. 이 오류를 수신할 수 있는 작업은 LINK, LOOKUP, LOOKUPP, OPEN, PUTFH, PUTPUBFH, PUTROOTFH, RENAME, RESTOREFH 및 간접적인 READDIR입니다. LINK 및 RENAME은 작업에 사용된 보안이 저장된 파일 핸들에 적합하지 않은 경우에만 이 오류를 수신합니다. 와 더불어

READDIR을 제외하고 이러한 작업은 클라이언트가 파일 핸들을 서버의 현재 파일 핸들로 인스턴스화할 수 있는 지점을 나타냅니다. 파일 핸들은 클라이언트에 의해 제공되거나\(PUTFH, PUTPUBFH, PUTROOTFH\) 이름에서 파일 핸들로 변환\(LOOKUP 및 OPEN\)의 결과로 생성됩니다. 파일 핸들이 이전 SAVEFH의 결과이기 때문에 RESTOREFH는 다릅니다. RESTOREFH에 대한 파일 핸들이 이전에 서버의 보안 일치 검사를 통과했더라도 서버는 보안 정책이 변경되지 않았는지 확인하기 위해 RESTOREFH에서 이를 다시 확인합니다.

클라이언트가 NFS4ERR\_WRONGSEC의 오류 반환을 해결하려는 경우 다음이 발생합니다.

o LOOKUP 및 OPEN의 경우 클라이언트는 원래 LOOKUP 또는 OPEN에 제공된 것과 동일한 현재 파일 핸들 및 이름으로 SECINFO를 사용하여 사용 가능한 보안 트리플을 열거합니다.

o LINK, PUTFH, RENAME 및 RESTOREFH의 경우 클라이언트는 SECINFO를 사용하고 상위 디렉터리 파일 핸들과 원래 PUTFH 또는 RESTOREFH 또는 LINK 및 RENAME의 경우 SAVEFH에서 제공한 파일 핸들에 해당하는 개체 이름을 제공합니다.

o LOOKUPP, PUTROOTFH 및 PUTPUBFH의 경우 SECINFO에는 현재 파일 핸들이 필요하고 이 세 가지 작업에 대한 파일 핸들이 없기 때문에 클라이언트는 SECINFO 작업을 사용할 수 없습니다. 따라서 클라이언트는 클라이언트에서 사용 가능한 보안 트리플을 반복하고 PUTROOTFH 또는 PUTPUBFH 작업을 다시 시도해야 합니다. 불행하게도 MANDATORY 보안 트리플 중 어느 것도 클라이언트와 서버에서 지원되지 않는 경우 클라이언트는 무결성을 지원하는 다른 보안 트리플을 사용해 보아야 합니다. 실패하면 클라이언트는 AUTH\_NONE을 사용해 볼 수 있지만 이러한 양식에는 무결성 검사가 부족하기 때문에 클라이언트가 위험해질 수 있습니다. 그럼에도 불구하고 서버는 클라이언트가 요청하고 서버가 지원하는 모든 보안 형식을 클라이언트가 사용할 수 있도록 허용해야 합니다. 그렇게 하는 데 따른 위험은 클라이언트에 있기 때문입니다.\(SHOULD, SHOULD\)

READDIR 작업은 NFS4ERR\_WRONGSEC 오류를 직접 반환하지 않습니다. 그러나 READDIR 요청에 속성에 대한 요청이 포함된 경우 READDIR 요청의 보안 트리플이 디렉터리 항목의 보안 트리플과 일치하지 않을 수 있습니다. 이런 경우이고 클라이언트가 rdattr\_error 속성을 요청한 경우 서버는 항목에 대한 rdattr\_error에 NFS4ERR\_WRONGSEC 오류를 반환합니다.

서버는 AUTH\_NONE 특성을 사용하여 클라이언트가 SECINFO 결과에 명시적으로 나열되지 않은 인증 특성을 사용하려고 시도할 수 있음을 나타낼 수 있습니다. 예를 들어 클라이언트는 나열된 특성을 사용하는 대신 AUTH\_NONE 대신 목록에 없는 RPCSEC\_GSS 메커니즘을 사용하도록 선택할 수 있습니다. 데이터 무결성이나 개인 정보 보호에 대한 애플리케이션 요구 사항을 충족하기 위해 그렇게 할 수도 있습니다. 목록에 없는 플레이버를 사용하기로 선택한 경우 클라이언트는 항상 AUTH\_NONE 또는 다른 나열된 플레이버를 사용하여 실패를 처리할 준비를 해야 합니다. ID 매핑이 지원된다고 가정할 수 없으며 해당 ID가 압류된다는 사실에 대비해야 합니다.\(MAY, SHOULD\)

SECINFO에서 사용하는 보안 유형에 대한 권장 사항에 대한 논의는 섹션 19를 참조하세요.

---
### **16.32.  Operation 34: SETATTR - Set Attributes**
---
#### **16.32.1.  SYNOPSIS**

```text
     (cfh), stateid, attrmask, attr_vals -> attrsset
```

---
#### **16.32.2.  ARGUMENT**

```text
   struct SETATTR4args {
           /* CURRENT_FH: target object */
           stateid4        stateid;
           fattr4          obj_attributes;
   };
```

---
#### **16.32.3.  RESULT**

```text
   struct SETATTR4res {
           nfsstat4        status;
           bitmap4         attrsset;
   };
```

---
#### **16.32.4.  DESCRIPTION**

SETATTR 작업은 파일 시스템 개체의 속성 중 하나 이상을 변경합니다. 새 속성은 비트맵과 비트순으로 비트맵 뒤에 오는 속성으로 지정됩니다.

SETATTR의 stateid 인수는 크기 속성을 설정하는 SETATTR 요청에 필요한 바이트 범위 잠금 컨텍스트를 제공하는 데 사용됩니다. 크기 속성을 설정하면 파일의 데이터가 수정되므로 해당 WRITE와 동일한 잠금 요구 사항이 있습니다. 크기 속성을 설정하는 SETATTR은 OPEN4\_SHARE\_DENY\_WRITE를 지정하는 공유 예약과 호환되지 않습니다. 이전 파일 끝과 새 파일 끝 사이의 영역은 해당 영역이 WRITE 대상으로 지정된 경우와 마찬가지로 수정된 것으로 간주됩니다. 서버가 필수 바이트 범위 잠금 동작을 구현하는 경우 바이트 범위 잠금. 유효한 stateid는 항상 지정되어야 합니다. 파일 크기 속성이 설정되지 않은 경우 특수 익명 상태 ID가 전달될 수 있습니다.\(SHOULD, MAY\)

작업이 성공하거나 실패하면 서버는 attrsset 비트마스크를 반환하여 성공적으로 설정된 속성\(있는 경우\)을 나타냅니다. 응답의 attrsset는 인수의 obj\_attributes의 일부인 bitmap4의 하위 집합입니다.

성공하면 현재 파일 핸들이 해당 값을 유지합니다.

---
#### **16.32.5.  IMPLEMENTATION**

요청이 설정할 소유자 속성을 지정하는 경우 서버는 개체의 현재 소유자가 요청에 지정된 값과 일치하는 경우 작업이 성공하도록 허용해야 합니다. 일부 서버는 요청자에게 권한이 없는 한 소유자 속성 설정을 금지하는 방식으로 구현될 수 있습니다. 소유자 값이 일치하는 이 경우에 서버가 관대하다면 객체 생성\(예: OPEN을 통한 단독 생성\)과 SETATTR의 경우 클라이언트 구현이 단순화될 수 있습니다.\(SHOULD\)

파일 크기 속성은 파일 크기 변경을 요청하는 데 사용됩니다. 값이 0이면 파일이 잘리고, 현재 파일 크기보다 작은 값을 사용하면 새 크기부터 파일 끝까지의 데이터가 삭제되고, 파일의 현재 크기보다 큰 경우 논리적으로 삭제됩니다. 파일 끝에 추가할 0으로 된 데이터 바이트입니다. 서버는 구멍이나 실제 제로 데이터 바이트를 사용하여 이를 자유롭게 구현할 수 있습니다. 클라이언트는 서버의 이 기능 구현과 관련하여 반환된 바이트가 0이 될 것이라는 가정을 해서는 안 됩니다. 서버는 SETATTR을 통해 파일 크기 확장을 지원해야 합니다.\(MUST\)

SETATTR은 원자성을 보장하지 않습니다. 실패한 SETATTR은 파일의 속성을 부분적으로 변경할 수 있습니다. 따라서 응답에는 항상 설정된 속성 목록과 상태가 포함됩니다.

속성이 변경되는 객체에 SETATTR을 수행하는 클라이언트가 아닌 다른 클라이언트가 보유한 파일 위임이 있는 경우 위임을 회수해야 하며 각 위임이 완료될 때까지 작업은 실제로 속성 변경을 진행할 수 없습니다. 반환 또는 취소됩니다. 위임이 회수되는 모든 경우에 서버는 위임이 미해결 상태로 유지되는 동안 하나 이상의 NFS4ERR\_DELAY 오류를 반환할 가능성이 높지만 위임이 빠르게 반환되는 경우에는 그렇게 하지 않을 수도 있습니다.

SETATTR을 사용하여 파일 크기를 변경하면 time\_modify 및 변경 속성이 간접적으로 변경됩니다. 크기 변경으로 인해 데이터가 삭제될 수 있으므로 클라이언트는 이를 고려해야 합니다.

time\_access\_set 및 time\_modify\_set 속성은 전환 통합으로 구성된 쓰기 전용 속성이므로 클라이언트가 서버에 시간 값 설정을 지시할 수 있습니다. Switched Union이 SET\_TO\_CLIENT\_TIME4를 지정하는 경우 클라이언트는 작업에 사용할 nfstime4를 제공한 것입니다. 스위치 통합이 SET\_TO\_CLIENT\_TIME4를 지정하지 않으면 서버는 SETATTR 작업에 현재 시간을 사용합니다.

서버 시간과 클라이언트 시간이 다르면 클라이언트 시간을 파일 시간과 비교하는 프로그램이 중단될 수 있습니다. 클라이언트/서버 시간 차이를 제한하려면 시간 유지 프로토콜을 사용해야 합니다.

변경 속성만 지정하고 바로 뒤에 SETATTR이 오는 VERIFY 작업이 포함된 COMPOUND를 사용하면 클라이언트가 NFSv3의 SETATTR 가드 메커니즘의 기능을 에뮬레이트하는 요청을 지정할 수 있는 수단을 제공합니다. 가드 메커니즘의 기능은 오래된 정보를 기반으로 파일 속성의 변경을 방지하는 것이므로 가드 조건 확인과 속성 설정 사이의 지연으로 인해 NFSv4 에뮬레이션의 해당 지연과 마찬가지로 이 기능이 손상될 가능성이 있습니다. . 따라서 NFSv4 서버는 이러한 요청을 실행할 때 이러한 지연을 최대한 방지하도록 주의해야 합니다.

서버가 클라이언트가 요청한 속성을 지원하지 않는 경우 서버는 NFS4ERR\_ATTRNOTSUPP를 반환해야 합니다.

실제로 설정된 속성의 마스크는 모든 경우에 SETATTR에 의해 반환됩니다. 해당 마스크에는 클라이언트가 설정하도록 요청하지 않은 속성 비트가 포함되어서는 안 됩니다. 요청과 응답의 속성 마스크가 동일한 경우 응답의 상태 필드는 NFS4\_OK여야 합니다.\(MUST NOT, MUST\)

---
### **16.33.  Operation 35: SETCLIENTID - Negotiate Client ID**
---
#### **16.33.1.  SYNOPSIS**

```text
     client, callback, callback_ident -> clientid, setclientid_confirm
```

---
#### **16.33.2.  ARGUMENT**

```text
   struct SETCLIENTID4args {
           nfs_client_id4  client;
           cb_client4      callback;
           uint32_t        callback_ident;
   };
```

---
#### **16.33.3.  RESULT**

```text
   struct SETCLIENTID4resok {
           clientid4       clientid;
           verifier4       setclientid_confirm;
   };

   union SETCLIENTID4res switch (nfsstat4 status) {
    case NFS4_OK:
            SETCLIENTID4resok      resok4;
    case NFS4ERR_CLID_INUSE:
            clientaddr4    client_using;
    default:
            void;
   };
```

---
#### **16.33.4.  DESCRIPTION**

클라이언트는 SETCLIENTID 작업을 사용하여 서버에 잠금 생성, 공유 예약 및 위임 상태를 수반하는 후속 요청에 대해 특정 클라이언트 식별자, 콜백 및 callback\_ident를 사용하려는 의도를 서버에 알립니다. 성공적으로 완료되면 서버는 별도의 단계를 통해 확인된 경우 후속 파일 잠금 및 파일 열기 요청에 사용되는 단축 클라이언트 ID를 반환합니다. 클라이언트 ID 확인은 클라이언트 ID 및 setclientid\_confirm 값을 검증자로 서버에 반환하기 위해 SETCLIENTID\_CONFIRM 작업을 통해 수행되어야 합니다. SETCLIENTID 및 SETCLIENTID\_CONFIRM을 사용하여 콜백 및 callback\_ident 정보를 수정할 수 있지만 단축 클라이언트 ID는 수정할 수 없으므로 두 개의 검증자가 필요합니다. 이 경우 setclientid\_confirm 값이 사실상 유일한 검증자입니다.

이 작업에서 제공되는 콜백 정보는 향후 클라이언트에게 공개 위임이 제공되는 경우 사용됩니다. 따라서 클라이언트는 SETCLIENTID가 사용될 때 콜백 프로그램에 대한 프로그램 및 포트 번호를 올바르게 반영해야 합니다.

callback\_ident 값은 콜백 시 서버에서 사용됩니다. 클라이언트는 callback\_ident를 활용하여 둘 이상의 콜백 RPC 프로그램 번호가 필요하지 않도록 하면서 어느 서버가 콜백을 시작하는지 계속 확인할 수 있습니다.

---
#### **16.33.5.  IMPLEMENTATION**

SETCLIENTID를 구현하는 방법을 이해하려면 다음 표기법을 사용하세요. 허락하다:

x는 SETCLIENTID4args 구조의 client.id 하위 필드 값입니다.

v client.verifier 하위 필드의 값이어야 합니다.

- SETCLIENTID4args 구조.

c는 반환된 클라이언트 ID 필드의 값입니다.

- SETCLIENTID4resok 구조.

k는 SETCLIENTID4args 구조의 callback 및 callback\_ident 필드의 값 조합을 나타냅니다.

SETCLIENTID4resok 구조에 반환된 setclientid\_confirm 값입니다.

{ v, x, c, k, s }는 클라이언트 레코드의 5배입니다. 클라이언트 레코드를 확인하기 위한 SETCLIENTID\_CONFIRM 작업이 있는 경우 클라이언트 레코드가 확인됩니다. 그렇지 않으면 확인되지 않습니다. 확인되지 않은 레코드는 SETCLIENTID 호출에 의해 설정됩니다.

SETCLIENTID는 비멱등성 작업이므로 서버가 DRC\(중복 요청 캐시\)를 구현하고 있다고 가정해 보겠습니다.

서버가 SETCLIENTID { v, x, k } 요청을 받으면 다음과 같은 방식으로 처리합니다.

o 먼저 DRC에서 요청을 조회합니다. 적중이 있으면 DRC에 캐시된 결과를 반환합니다. 서버는 클라이언트 상태\(잠금, 공유, 위임\)를 제거하지 않으며 클라이언트 { x }에 대해 기록된 콜백 및 callback\_ident 정보를 수정하지 않습니다.

- DRC 누락의 경우 서버는 클라이언트 ID 문자열 x를 사용하고 서버가 이전 SETCLIENTID 호출에서 기록했을 수 있는 x에 대한 클라이언트 레코드를 검색합니다. 동일한 ID 문자열 x가 있는 확인된 레코드에 대해 기록된 주체가 SETCLIENTID 호출의 주체와 일치하지 않으면 서버는 NFS4ERR\_CLID\_INUSE 오류를 반환합니다.

- 논의를 간결하게 하기 위해 처리에 대한 나머지 설명에서는 DRC 누락이 있었고 서버가 이전에 클라이언트 x에 대해 확인된 기록을 기록한 경우 앞서 언급한 주체 확인이 성공적으로 통과했다고 가정합니다.

o 서버는 {v, x, c, l, s }에 대해 확인된 레코드를 기록했는지 확인합니다. 여기서 l은 k와 같을 수도 있고 같지 않을 수도 있습니다. 그렇다면 요청의 ID 검증자 v가 확인 및 기록된 것과 일치하므로 서버는 이를 가능한 콜백 정보 업데이트로 간주하고 확인되지 않은 { v, x, c, k, t }를 기록하고 확인된 {를 남깁니다. v, x, c, l, s }가 t != s가 되도록 배치합니다. k가 l과 같은지 여부는 중요하지 않습니다. 기존에 확인되지 않은 { v, x, c, \*, \* }는 제거됩니다.

- 서버는 { c, t }를 반환합니다. 실제로 클라이언트는 콜백 값 k를 값 l로 업데이트하기를 원하기 때문에 이전 clientid4 값 c를 반환합니다. 이 요청은 오래된 콜백 정보가 있는 비잔틴 라우터의 요청일 가능성이 있지만 이는 문제가 되지 않습니다. 콜백 정보 업데이트는 SETCLIENTID\_CONFIRM { c, t }가 뒤따르는 경우에만 확인됩니다.

- 서버는 SETCLIENTID\_CONFIRM { c, t }를 통해 k의 확인을 기다립니다.

- 서버는 x에 대한 클라이언트\(잠금/공유/위임\) 상태를 제거하지 않습니다.

o 서버는 이전에 v != u, l이 k와 같거나 같지 않을 수 있는 확인된 { u, x, c, l, s } 레코드를 기록했으며 확인되지 않은 { \*, x, \*, \*, \* } x에 대한 기록입니다. 서버는 확인되지 않은 { v, x, d, k, t } \(d != c, t != s\)를 기록합니다.

- 서버는 { d, t }를 반환합니다.

- 서버는 SETCLIENTID\_CONFIRM { d, t }를 통해 { d, k }의 확인을 기다립니다.

- 서버는 x에 대한 클라이언트\(잠금/공유/위임\) 상태를 제거하지 않습니다.

o 서버는 이전에 v != u, l이 k와 같거나 같지 않을 수 있는 확인된 { u, x, c, l, s } 레코드를 기록했으며 확인되지 않은 { w, x, d, m, t }를 기록했습니다. c != d, t != s, m은 k와 같거나 같지 않을 수 있고, m은 l과 같거나 같지 않을 수 있으며, k는 l과 같거나 같지 않을 수 있도록 기록합니다. w == v인지 w != v인지는 아무런 차이가 없습니다. 서버는 확인되지 않은 { w, x, d, m, t } 레코드를 제거하고 이를 확인되지 않은 { v, x, e, k, r } 레코드로 대체합니다. 즉, e != d, e != c, r이 됩니다. !=t, r !=s.

- 서버는 { e, r }을 반환합니다.

- 서버는 SETCLIENTID\_CONFIRM { e, r }을 통해 { e, k }의 확인을 기다립니다.

- 서버는 x에 대한 클라이언트\(잠금/공유/위임\) 상태를 제거하지 않습니다.

o 서버에는 x에 대해 확인된 { \*, x, \*, \*, \* }가 없습니다. 확인되지 않은 { u, x, c, l, s }를 기록했을 수도 있고 기록하지 않았을 수도 있습니다. 여기서 l은 k와 같을 수도 있고 같지 않을 수도 있고, v와 같을 수도 있고 같지 않을 수도 있습니다. 확인되지 않은 모든 기록 { u, x, c, l , \* }는 u == v 또는 l == k인지에 관계없이 확인되지 않은 레코드 { v, x, d, k, t }로 대체됩니다. 여기서 d != c, t != s입니다.

- 서버는 { d, t }를 반환합니다.

- 서버는 SETCLIENTID\_CONFIRM { d, t }를 통해 { d, k }의 확인을 기다립니다. 서버는 x에 대한 클라이언트\(잠금/공유/위임\) 상태를 제거하지 않습니다.

서버는 clientid 및 setclientid\_confirm 값을 생성하며 이러한 값이 다시 생성될 가능성이 거의 없도록 주의해야 합니다.

---
### **16.34.  Operation 36: SETCLIENTID_CONFIRM - Confirm Client ID**
---
#### **16.34.1.  SYNOPSIS**

```text
     clientid, setclientid_confirm -> -
```

---
#### **16.34.2.  ARGUMENT**

```text
   struct SETCLIENTID_CONFIRM4args {
           clientid4       clientid;
           verifier4       setclientid_confirm;
   };
```

---
#### **16.34.3.  RESULT**

```text
   struct SETCLIENTID_CONFIRM4res {
           nfsstat4        status;
   };
```

---
#### **16.34.4.  DESCRIPTION**

이 작업은 클라이언트가 SETCLIENTID에 대한 이전 호출의 결과를 확인하는 데 사용됩니다. 클라이언트는 서버가 제공한\(SETCLIENTID 응답을 통해\) 클라이언트 ID를 제공합니다. 서버는 성공 또는 실패라는 간단한 상태로 응답합니다.

---
#### **16.34.5.  IMPLEMENTATION**

클라이언트는 SETCLIENTID\_CONFIRM 작업을 사용하여 다음 두 가지 사례를 확인해야 합니다.

o 클라이언트가 새로운 단축 클라이언트 식별자\(SETCLIENTID에 대한 응답으로 서버에서 반환됨\), 새 콜백 값\(SETCLIENTID에 대한 인수에 지정됨\) 및 새 callback\_ident 값\(SETCLIENTID에 대한 인수에 지정됨\)을 사용합니다. \). 이 경우 클라이언트가 SETCLIENTID\_CONFIRM을 사용하면 클라이언트의 이전 관련 임대 상태가 모두 제거되었음을 확인합니다. 관련 임대 클라이언트 상태에는 바이트 범위 잠금, 공유 예약 및 서버가 CLAIM\_DELEGATE\_PREV 클레임 유형을 지원하지 않는 경우 위임이 포함됩니다. 서버가 CLAIM\_DELEGATE\_PREV를 지원하는 경우 SETCLIENTID\_CONFIRM은 이 클라이언트에 대한 위임을 제거해서는 안 됩니다. 관련 임대 클라이언트 상태에는 바이트 범위 잠금 및 공유 예약만 포함됩니다.\(MUST NOT\)

o 이전에 확인된 속기 클라이언트 식별자를 클라이언트가 재사용합니다. 새로운 콜백 값 그리고 새로운 callback\_ident 값. 이 경우 클라이언트의 SETCLIENTID\_CONFIRM 사용으로 인해 이전 임대 상태\(잠금, 공유 예약 및 위임\)가 제거되어서는 안 됩니다.\(MUST NOT\)

SETCLIENTID 작업 설명에 소개된 대로 v, x, c, k, s, 확인되지 않은 클라이언트 레코드 및 확인된 클라이언트 레코드에 대해 동일한 표기법과 정의를 사용합니다. SETCLIENTID\_CONFIRM에 대한 인수는 { c, s } 표기법으로 표시됩니다. 여기서 c는 clientid4 유형의 값이고 s는 setclientid\_confirm 필드에 해당하는 verifier4 유형의 값입니다.

SETCLIENTID와 마찬가지로 SETCLIENTID\_CONFIRM은 비멱등성 작업이며 서버가 DRC\(중복 요청 캐시\)를 구현하고 있다고 가정합니다.

서버가 SETCLIENTID\_CONFIRM { c, s } 요청을 받으면 다음과 같은 방식으로 처리합니다.

o 먼저 DRC에서 요청을 조회합니다. 적중이 있으면 DRC에 캐시된 결과를 반환합니다. 서버는 관련된 임대 클라이언트 상태를 제거하지 않으며, 단축 값 c로 표시되는 클라이언트 { x }에 대해 기록된 콜백 및 callback\_ident 정보를 수정하지 않습니다.

DRC 누락의 경우 서버는 단축 값 c와 일치하는 클라이언트 레코드를 확인합니다. 처리사례는 다음과 같습니다.

o 서버가 확인되지 않은 { v, x, c, k, s } 레코드와 확인된 { v, x, c, l, t } 레코드를 기록했습니다\(예: s != t\). 레코드의 주체가 SETCLIENTID\_CONFIRM의 주체와 일치하지 않으면 서버는 NFS4ERR\_CLID\_INUSE를 반환하고 관련 임대 클라이언트 상태는 제거되지 않으며 클라이언트 { x }에 대해 기록된 콜백 및 callback\_ident 정보가 변경되지 않습니다. 그렇지 않으면 확인된 { v, x, c, l, t } 레코드는 제거되고 확인되지 않은 { v, x, c, k, s }는 확인으로 표시되어 클라이언트 { x에 대한 녹음 및 확인된 콜백 및 callback\_ident 정보가 수정됩니다. }.

- 서버는 관련 임대 클라이언트 상태를 제거하지 않습니다.

- 서버가 NFS4\_OK를 반환합니다.

o 서버는 확인되지 않은 {v, x, c, \*, \* }를 기록하지 않았고 확인된 {v, x, c, \*, s }를 기록했습니다. 레코드와 SETCLIENTID\_CONFIRM의 주체가 일치하지 않는 경우 서버는 관련 임대 클라이언트 상태를 제거하지 않고 클라이언트 { x }에 대해 기록된 콜백 및 callback\_ident 값을 변경하지 않고 NFS4ERR\_CLID\_INUSE를 반환합니다.

- 주체가 일치하면 클라이언트가 SETCLIENTID\_CONFIRM으로부터 응답을 받지 못했고 DRC 항목이 제거되었을 가능성이 높습니다. 어떤 시나리오에서든 보안 주체가 일치하고 { c, s }가 확인된 레코드와 일치하므로 서버는 클라이언트 x의 관련 임대 클라이언트 상태를 그대로 유지하고 콜백 및 callback\_ident 값을 수정하지 않은 상태로 두고 NFS4\_OK를 반환합니다.

o 서버는 확인된 { \*, \*, c, \*, \* }를 기록하지 않았고 확인되지 않은 { \*, x, c, k, s }를 기록했습니다. 클라이언트의 재시도인 경우에도 클라이언트의 첫 번째 SETCLIENTID\_CONFIRM 시도가 서버에서 수신되지 않았습니다. 재시도 여부는 서버가 알지 못하지만 처음 시도한 것처럼 처리합니다. 확인되지 않은 { \*, x, c, k, s } 레코드의 주체가 SETCLIENTID\_CONFIRM 요청의 주체와 일치하지 않으면 서버는 관련 임대 클라이언트 상태를 제거하지 않고 NFS4ERR\_CLID\_INUSE를 반환합니다.

- 그렇지 않으면 서버는 확인된 { \*, x, c, k, s }를 기록합니다. 확인된 { \*, x, d, \*, t }도 있는 경우 서버는 클라이언트 x의 관련 임대 클라이언트 상태를 제거하고 콜백 상태를 k로 덮어써야 합니다. 확인된 레코드 { \*, x, d, \*, t }가 제거됩니다.\(MUST\)

- 서버가 NFS4\_OK를 반환합니다.

o 서버에는 확인되거나 확인되지 않은 { \*, \*, c, \*, s }에 대한 기록이 없습니다. 서버는 NFS4ERR\_STALE\_CLIENTID를 반환합니다. 서버는 관련된 임대 클라이언트 상태를 제거하지 않으며 클라이언트에 대해 기록된 콜백 및 callback\_ident 정보를 수정하지 않습니다.

서버는 확인되지 않은 { v, x, c, k, s } 클라이언트 레코드를 캐시하고 잠시 동안 확인을 기다려야 합니다. SETCLIENTID 및 SETCLIENTID\_CONFIRM에 대한 레코드 처리에 대한 논의에서 분명히 알 수 있듯이 서버가 확인되지 않은 클라이언트 레코드를 결정론적으로 제거하지 않는 경우가 있습니다. 리소스 부족을 방지하기 위해 서버는 확인되지 않은 기록을 무기한 보관할 필요가 없습니다. 서버가 사용할 수 있는 한 가지 전략은 확인되지 않은 클라이언트 레코드 수에 대한 제한을 설정하고 제한이 초과되면 제거하는 것입니다.

가장 오래된 기록. 또 다른 전략은 일정 시간이 경과한 후 확인되지 않은 기록을 제거하는 것입니다. 시간의 선택은 매우 임의적이지만 서버의 임대 기간보다 높지는 않습니다. 임대 시간이 만료되기 전에 클라이언트의 작업을 통해 임대를 갱신해야 한다는 점을 고려하세요. 임대 만료 시간과 동일한 기간 전에 클라이언트가 SETCLIENTID 이후 SETCLIENTID\_CONFIRM을 실행할 수 없는 경우 클라이언트는 안정적인 상태 작업 중에 서버에서 상태를 유지할 수 없습니다.

클라이언트가 서버가 이미 삭제한 확인되지 않은 레코드에 대해 SETCLIENTID\_CONFIRM을 보내는 경우 클라이언트는 NFS4ERR\_STALE\_CLIENTID를 다시 받게 됩니다. 그렇다면 클라이언트는 다시 시작하고 SETCLIENTID를 보내 확인되지 않은 클라이언트 레코드를 다시 설정하고 확인되지 않은 클라이언트 ID와 setclientid\_confirm 검증자를 다시 가져와야 합니다. 그런 다음 클라이언트는 SETCLIENTID\_CONFIRM을 보내 클라이언트 ID를 확인해야 합니다.

SETCLIENTID\_CONFIRM은 임대를 설정하거나 갱신하지 않습니다. 그러나 SETCLIENTID\_CONFIRM이 관련 임대 클라이언트 상태를 제거하고 해당 상태에 기존 위임이 포함되어 있지 않은 경우 서버는 OPEN의 CLAIM\_DELEGATE\_PREV 클레임 유형을 통해 클라이언트가 Lease\_time 속성 값보다 적지 않은 기간을 회수하도록 허용해야 합니다. 작업\) 회수되지 않은 위임을 제거하기 전에 해당 위임을 제거합니다.\(MUST\)

---
### **16.35.  Operation 37: VERIFY - Verify Same Attributes**
---
#### **16.35.1.  SYNOPSIS**

```text
     (cfh), fattr -> -
```

---
#### **16.35.2.  ARGUMENT**

```text
   struct VERIFY4args {
           /* CURRENT_FH: object */
           fattr4          obj_attributes;
   };
```

---
#### **16.35.3.  RESULT**

```text
   struct VERIFY4res {
           nfsstat4        status;
   };
```

---
#### **16.35.4.  DESCRIPTION**

VERIFY 작업은 COMPOUND 요청에서 후속 작업을 진행하기 전에 속성에 클라이언트가 가정한 값이 있는지 확인하는 데 사용됩니다. 속성 중 하나라도 일치하지 않으면 NFS4ERR\_NOT\_SAME 오류가 반환되어야 합니다. 현재 파일 핸들은 작업이 성공적으로 완료된 후에도 해당 값을 유지합니다.

---
#### **16.35.5.  IMPLEMENTATION**

VERIFY 작업의 한 가지 가능한 용도는 다음 COMPOUND 시퀀스입니다. 이를 통해 클라이언트는 제거되는 파일이 클라이언트가 제거할 것으로 예상하는 파일과 일치하는지 확인하려고 시도합니다. 이 순서는 의도하지 않은 파일 삭제를 방지하는 데 도움이 됩니다.

```text
     PUTFH (directory filehandle)
     LOOKUP (filename)
     VERIFY (filehandle == fh)
     PUTFH (directory filehandle)
     REMOVE (filename)
```

이 시퀀스는 두 번째 클라이언트가 시퀀스 중간에 새 파일을 제거하고 생성하는 것을 막지는 않지만 의도하지 않은 결과를 방지하는 데 도움이 됩니다.

VERIFY 작업에 RECOMMENDED 속성이 지정되어 있고 서버가 파일 시스템 개체에 대해 해당 속성을 지원하지 않는 경우 NFS4ERR\_ATTRNOTSUPP 오류가 클라이언트에 반환됩니다.\(SHOULD\)

rdattr\_error 속성이나 쓰기 전용 속성\(예: time\_modify\_set\)이 지정되면 NFS4ERR\_INVAL 오류가 클라이언트에 반환됩니다.

---
### **16.36.  Operation 38: WRITE - Write to File**
---
#### **16.36.1.  SYNOPSIS**

```text
     (cfh), stateid, offset, stable, data -> count, committed, writeverf
```

---
#### **16.36.2.  ARGUMENT**

```text
   enum stable_how4 {
           UNSTABLE4       = 0,
           DATA_SYNC4      = 1,
           FILE_SYNC4      = 2
   };

   struct WRITE4args {
           /* CURRENT_FH: file */
           stateid4        stateid;
           offset4         offset;
           stable_how4     stable;
           opaque          data<>;
   };
```

---
#### **16.36.3.  RESULT**

```text
   struct WRITE4resok {
           count4          count;
           stable_how4     committed;
           verifier4       writeverf;
   };

   union WRITE4res switch (nfsstat4 status) {
    case NFS4_OK:
            WRITE4resok    resok4;
    default:
            void;
   };
```

---
#### **16.36.4.  DESCRIPTION**

WRITE 작업은 일반 파일에 데이터를 쓰는 데 사용됩니다. 대상 파일은 현재 파일 핸들로 지정됩니다. 오프셋은 데이터가 기록되어야 하는 오프셋을 지정합니다. 오프셋 0\(영\)은 쓰기가 파일 시작 부분에서 시작되어야 함을 지정합니다. 불투명 데이터 매개변수의 일부로 인코딩된 개수는 기록될 데이터의 바이트 수를 나타냅니다. 개수가 0\(영\)이면 WRITE가 성공하고 권한 확인에 따라 개수 0\(영\)을 반환합니다. 서버는 클라이언트가 요청한 것보다 적은 바이트를 쓰도록 선택할 수 있습니다.

WRITE 요청의 일부는 WRITE 수행 방법에 대한 사양입니다. 클라이언트는 stable 매개변수를 사용하여 서버에서 데이터를 처리하는 방법을 지정합니다. stable이 FILE\_SYNC4인 경우 서버는 결과를 반환하기 전에 작성된 데이터와 모든 파일 시스템 메타데이터를 안정적인 저장소에 커밋해야 합니다. 이는 NFSv2 프로토콜 의미 체계에 해당합니다. 다른 모든 행동은 프로토콜 위반으로 간주됩니다. stable이 DATA\_SYNC4인 경우 서버는 모든 데이터를 안정적인 저장소에 커밋해야 하며 반환하기 전에 데이터를 검색할 만큼 충분한 메타데이터를 커밋해야 합니다. 서버 구현자는 FILE\_SYNC4와 동일한 방식으로 DATA\_SYNC4를 자유롭게 구현할 수 있지만 성능이 저하될 수 있습니다. stable이 UNSTABLE4인 경우 서버는 클라이언트에 응답을 반환하기 전에 데이터와 메타데이터의 일부\(모두 또는 전혀 포함하지 않음\)를 stable 저장소에 자유롭게 커밋할 수 있습니다. 커밋되지 않은 데이터가 이후에 안정적인 저장소에 커밋되는지 여부와 시기가 보장되지 않습니다. 서버가 보장하는 유일한 것은 verf 값을 변경하지 않고 데이터를 삭제하지 않으며 클라이언트가 요청한 수준보다 낮은 수준으로 데이터와 메타데이터를 커밋하지 않는다는 것입니다.

WRITE 요청의 stateid 값은 이전 바이트 범위 잠금이나 공유 예약 요청에서 반환된 값 또는 위임과 연결된 stateid를 나타냅니다. stateid는 서버에서 관련 공유 예약 및 바이트 범위 잠금이 여전히 유효한지 확인하고 클라이언트에 대한 임대 시간 제한을 업데이트하는 데 사용됩니다.

성공적으로 완료되면 다음 결과가 반환됩니다. 계산 결과는 파일에 기록된 데이터의 바이트 수입니다. 서버는 요청한 것보다 적은 바이트를 쓸 수 있습니다. 그렇다면 오프셋 위치에서 시작하여 쓰여진 실제 바이트 수가 반환됩니다.

서버는 또한 커밋을 통해 데이터 및 메타데이터의 커밋 수준 표시를 반환합니다. 서버가 모든 데이터와 메타데이터를 안정적인 저장소에 커밋한 경우 커밋을 FILE\_SYNC4로 설정해야 합니다. 커밋 수준이 최소한 DATA\_SYNC4만큼 강력했다면 커밋을 DATA\_SYNC4로 설정해야 합니다. 그렇지 않으면 커밋된 값이 UNSTABLE4로 반환되어야 합니다. 안정이 FILE4\_SYNC인 경우 커밋도 FILE\_SYNC4여야 합니다. 다른 모든 것은 프로토콜 위반을 구성합니다. 안정적인 것이 DATA\_SYNC4인 경우 커밋된 것은 FILE\_SYNC4 또는 DATA\_SYNC4일 수 있습니다. 다른 모든 것은 프로토콜 위반을 구성합니다. stable이 UNSTABLE4인 경우 커밋된 항목은 FILE\_SYNC4, DATA\_SYNC4 또는 UNSTABLE4일 수 있습니다.

결과의 마지막 부분은 쓰기 검증자입니다. 쓰기 검증자는 WRITE 호출과 후속 WRITE 또는 COMMIT 호출 사이에 서버가 인스턴스\(부팅\) 상태를 변경했는지 여부를 확인하는 데 클라이언트가 사용할 수 있는 쿠키입니다. 이 쿠키는 NFSv4 프로토콜 서비스의 단일 인스턴스 동안 일관성을 유지해야 하며 커밋되지 않은 데이터가 손실될 수 있는 NFSv4 프로토콜 서버 인스턴스 간에 고유해야 합니다.

클라이언트가 UNSTABLE4로 설정된 안정적인 인수를 사용하여 서버에 데이터를 쓰고 응답이 DATA\_SYNC4 또는 UNSTABLE4의 커밋된 응답을 생성하는 경우 클라이언트는 향후 어느 시점에 COMMIT 작업을 수행하여 미해결 비동기 데이터 및 메타데이터를 동기화합니다. 클라이언트 오류를 ​​제외하고 서버의 안정적인 저장 공간입니다. 클라이언트 충돌이나 기타 오류로 인해 후속 COMMIT가 서버에서 수신되지 않을 수 있습니다.

특별한 익명 상태 ID를 사용하는 WRITE의 경우 서버는 필수 파일 잠금 또는 파일에 대한 현재 공유 거부 모드에 따라 WRITE가 서비스되도록 허용할 수 있습니다. 특별한 READ 우회 상태 ID를 사용하는 WRITE의 경우 서버는 WRITE 작업이 서버의 잠금 검사를 우회하도록 허용해서는 안 되며 WRITE는 익명 상태 ID가 사용된 것과 정확히 동일하게 처리됩니다.\(MAY, MUST NOT\)

성공하면 현재 파일 핸들이 해당 값을 유지합니다.

---
#### **16.36.5.  IMPLEMENTATION**

서버가 클라이언트가 요청한 것보다 더 적은 바이트의 데이터를 쓰는 것이 가능합니다. 이 경우 데이터가 전혀 기록되지 않는 한 서버는 오류를 반환해서는 안 됩니다. 서버가 지정된 바이트 수보다 적게 쓰는 경우 클라이언트는 나머지 데이터를 쓰기 위해 또 다른 WRITE를 실행해야 합니다.

파일에 데이터를 쓰는 행위로 인해 파일의 time\_modify 속성이 업데이트된다고 가정합니다. 그러나 파일의 내용이 변경되지 않는 한 파일의 time\_modify 속성을 변경해서는 안 됩니다. 따라서 개수가 0으로 설정된 WRITE 요청으로 인해 파일의 time\_modify 속성이 업데이트되어서는 안 됩니다.

안정적인 스토리지의 정의는 역사적으로 논쟁의 여지가 있었습니다. 안정적인 저장소의 다음과 같은 예상 속성은 구현 시 설계 문제를 해결하는 데 도움이 될 수 있습니다. 안정적인 스토리지는 다음과 같이 지속되는 영구 스토리지입니다.

```text
   1.  Repeated power failures.

   2.  Hardware failures (of any board, power supply, etc.).

   3.  Repeated software crashes, including reboot cycle.
```

이 정의는 안정적인 저장소 모듈 자체의 오류를 다루지 않습니다.

검증자는 캐시된 커밋되지 않은 데이터가 손실될 수 있는 NFSv4 프로토콜 서버의 다양한 인스턴스를 클라이언트가 감지할 수 있도록 정의됩니다. 대부분의 경우 검증자는 클라이언트가 서버 재부팅을 감지하도록 허용합니다. 이 정보는 클라이언트가 서버에서 캐시된 데이터가 손실되었는지 여부를 안전하게 판단할 수 있도록 하는 데 필요합니다. 서버가 예기치 않게 실패하고 클라이언트에 이전 WRITE 요청에서 커밋되지 않은 데이터가 있는 경우\(안정적인 인수가 UNSTABLE4로 설정되어 수행되고 커밋된 결과도 UNSTABLE4로 반환됨\) 캐시된 데이터를 안정적인 저장소로 플러시하지 않았을 수 있습니다. 복구 부담은 클라이언트에 있으며 클라이언트는 데이터를 서버로 재전송해야 합니다.

검증자를 사용하는 한 가지 제안 방법은 서버가 부팅된 시간이나 서버가 마지막으로 시작된 시간을 사용하는 것입니다\(재부팅하지 않고 서버를 다시 시작하면 버퍼가 손실되는 경우\).

결과의 커밋된 필드를 통해 클라이언트는 보다 효과적인 캐싱을 수행할 수 있습니다. 서버가 모든 WRITE 요청을 안정적인 저장소에 커밋하는 경우 인수의 stable 필드 값에 관계없이 FILE\_SYNC4로 설정된 커밋을 반환해야 합니다. NVRAM 가속기를 사용하는 서버는 이 정책을 구현하도록 선택할 수 있습니다. 클라이언트는 이를 사용하여 서버에 이미 커밋된 캐시된 데이터를 삭제하여 캐시의 효율성을 높일 수 있습니다.

일부 구현에서는 사용자 할당량이 초과되면 NFS4ERR\_DQUOT 대신 NFS4ERR\_NOSPC를 반환할 수 있습니다. 현재 파일 핸들이 디렉터리인 경우 서버는 NFS4ERR\_ISDIR을 반환합니다. 현재 파일 핸들이 일반 파일이나 디렉터리가 아닌 경우 서버는 NFS4ERR\_INVAL을 반환합니다.

파일에 대해 필수 파일 잠금이 설정되어 있고 파일에 쓸 데이터의 해당 레코드가 stateid와 연결되지 않은 소유자에 의해 읽거나 쓰기 잠긴 경우 서버는 NFS4ERR\_LOCKED를 반환합니다. 그렇다면 클라이언트는 WRITE 작업에 사용된 stateid에 해당하는 소유자가 쓰기 대상 영역과 겹치는 충돌하는 읽기 잠금을 가지고 있는지 확인해야 합니다. stateid의 소유자에게 충돌하는 읽기 잠금이 없으면 클라이언트는 WRITE를 다시 시도하기 전에 LOCK 작업을 통해 적절한 쓰기 바이트 범위 잠금을 얻으려고 시도해야 합니다. WRITE가 완료되면 클라이언트는 LOCKU를 통해 바이트 범위 잠금을 해제해야 합니다.

stateid의 소유자가 충돌하는 읽기 잠금을 갖고 있는 경우 클라이언트는 쓰기를 시도한 애플리케이션에 오류를 반환할 수밖에 없습니다. 그 이유는 stateid의 소유자가 읽기 잠금을 갖고 있었기 때문에 서버가 \(1\) 이 읽기 잠금을 쓰기 잠금으로 일시적으로 효과적으로 업그레이드하려고 시도했거나 \(2\) 업그레이드 기능이 없었기 때문입니다. 서버가 읽기 잠금 업그레이드를 시도했지만 실패한 경우 다른 클라이언트도 업그레이드를 시도할 수 있으므로 클라이언트가 LOCK 작업을 통해 업그레이드를 다시 시도하는 것은 의미가 없습니다. 동일한 잠금을 업그레이드하려고 두 클라이언트가 차단되면 클라이언트가 교착 상태가 됩니다. 서버에 업그레이드 기능이 없으면 업그레이드를 위해 LOCK 작업을 시도하는 것은 의미가 없습니다.

---
### **16.37.  Operation 39: RELEASE_LOCKOWNER - Release Lock-Owner State**
---
#### **16.37.1.  SYNOPSIS**

```text
     lock-owner -> ()
```

---
#### **16.37.2.  ARGUMENT**

```text
   struct RELEASE_LOCKOWNER4args {
           lock_owner4     lock_owner;
   };
```

---
#### **16.37.3.  RESULT**

```text
   struct RELEASE_LOCKOWNER4res {
           nfsstat4        status;
   };
```

---
#### **16.37.4.  DESCRIPTION**

이 작업은 클라이언트가 lock\_owner를 더 이상 사용하지 않으며 향후 클라이언트 요청이 이 lock\_owner를 참조하지 않는다는 것을 서버에 알리는 데 사용됩니다. 이를 통해 서버는 지정된 lock\_owner와 관련된 캐시된 상태를 해제할 수 있습니다. lock\_owner와 관련된 파일 잠금이 서버에 유지되면 NFS4ERR\_LOCKS\_HELD 오류가 반환되고 추가 조치가 수행되지 않습니다.

---
#### **16.37.5.  IMPLEMENTATION**

클라이언트는 유지되는 서버 상태의 양을 완화하기 위해 이 작업을 사용하도록 선택할 수 있습니다. RELEASE\_LOCKOWNER가 완료될 때 해제될 수 있는 정보에는 지정된 잠금 소유자 문자열, 잠금 소유자와 연관된 seqid, 잠금 소유자에 대해 저장된 응답 및 해당 잠금 소유자와 연관된 모든 잠금 상태 ID가 포함됩니다.

클라이언트의 애플리케이션 동작에 따라 서버는 관련 파일이 열려 있는 동안 잠금 소유자 관련 상태에 대한 참조를 보유하는 것과 관련하여 특정 의무를 갖기 때문에 클라이언트가 이 작업을 사용하는 것이 중요할 수 있습니다. 따라서 클라이언트가 lock\_owner가 더 이상 잠금 소유자와 연결된 기존 잠금 상태 ID를 참조하거나 새 잠금 상태를 생성하는 데 사용되지 않는다는 것을 확실히 알고 있는 경우 RELEASE\_LOCKOWNER를 사용해야 합니다.

---
### **16.38.  Operation 10044: ILLEGAL - Illegal Operation**
---
#### **16.38.1.  SYNOPSIS**

```text
     <null> -> ()
```

---
#### **16.38.2.  ARGUMENT**

```text
     void;
```

---
#### **16.38.3.  RESULT**

```text
   struct ILLEGAL4res {
           nfsstat4        status;
   };
```

---
#### **16.38.4.  DESCRIPTION**

이 작업은 클라이언트가 지원되지 않는 COMPOUND 내에서 작업 코드를 보내는 경우를 처리하기 위해 결과를 인코딩하기 위한 자리 표시자입니다. 자세한 내용은 섹션 15.2.4를 참조하세요.

ILLEGAL4res의 상태 필드는 NFS4ERR\_OP\_ILLEGAL로 설정되어야 합니다.\(MUST\)

---
#### **16.38.5.  IMPLEMENTATION**

클라이언트는 아마도 OP\_ILLEGAL 코드가 포함된 작업을 보내지 않을 것입니다. 그러나 보낸 경우 다른 유효하지 않은 작업 코드와 마찬가지로 응답은 ILLEGAL4res가 됩니다. 서버가 OP\_ILLEGAL이 아닌 잘못된 연산 코드를 받고 서버가 XDR 디코드 단계 중에 적법한 연산 코드를 확인하는 경우 ILLEGAL4res가 반환되지 않습니다.

---
## **17.  NFSv4 Callback Procedures**

콜백에 사용되는 절차는 다음 섹션에 정의되어 있습니다. 명확성을 위해 "클라이언트"와 "서버"라는 용어는 NFS 클라이언트와 서버를 의미합니다. 그러나 개별 콜백 RPC의 경우 이러한 용어의 의미는 정반대입니다.

---
### **17.1.  Procedure 0: CB_NULL - No Operation**
---
#### **17.1.1.  SYNOPSIS**

```text
     <null>
```

---
#### **17.1.2.  ARGUMENT**

```text
     void;
```

---
#### **17.1.3.  RESULT**

```text
     void;
```

---
#### **17.1.4.  DESCRIPTION**

표준 NULL 프로시저. 무효 논쟁, 무효 응답. 이 프로시저와 관련된 직접적인 기능이 없더라도 서버는 CB\_NULL을 사용하여 서버에서 클라이언트로의 RPC 경로가 있는지 확인합니다.

---
### **17.2.  Procedure 1: CB_COMPOUND - COMPOUND Operations**
---
#### **17.2.1.  SYNOPSIS**

```text
     compoundargs -> compoundres
```

---
#### **17.2.2.  ARGUMENT**

```text
   enum nfs_cb_opnum4 {
           OP_CB_GETATTR           = 3,
           OP_CB_RECALL            = 4,
           OP_CB_ILLEGAL           = 10044
   };

   union nfs_cb_argop4 switch (unsigned argop) {
    case OP_CB_GETATTR:
         CB_GETATTR4args           opcbgetattr;
    case OP_CB_RECALL:
         CB_RECALL4args            opcbrecall;
    case OP_CB_ILLEGAL:            void;
   };

   struct CB_COMPOUND4args {
           utf8str_cs      tag;
           uint32_t        minorversion;
           uint32_t        callback_ident;
           nfs_cb_argop4   argarray<>;
   };
```

---
#### **17.2.3.  RESULT**

```text
   union nfs_cb_resop4 switch (unsigned resop) {
    case OP_CB_GETATTR:    CB_GETATTR4res  opcbgetattr;
    case OP_CB_RECALL:     CB_RECALL4res   opcbrecall;
    case OP_CB_ILLEGAL:    CB_ILLEGAL4res  opcbillegal;
   };

   struct CB_COMPOUND4res {
           nfsstat4        status;
           utf8str_cs      tag;
           nfs_cb_resop4   resarray<>;
   };
```

---
#### **17.2.4.  DESCRIPTION**

CB\_COMPOUND 프로시저는 하나 이상의 콜백 프로시저를 단일 RPC 요청으로 결합하는 데 사용됩니다. 기본 콜백 RPC 프로그램에는 CB\_NULL 및 CB\_COMPOUND라는 두 가지 기본 프로시저가 있습니다. 다른 모든 작업은 CB\_COMPOUND 프로시저를 래퍼로 사용합니다.

CB\_COMPOUND 프로시저를 처리하는 동안 클라이언트는 CB\_COMPOUND 시퀀스 내의 작업 중 일부 또는 전부를 실행하는 데 사용할 수 있는 리소스가 없다는 것을 알 수 있습니다. 이 경우 리소스 소진이 발생한 CB\_COMPOUND 프로시저 내의 특정 작업에 대해 NFS4ERR\_RESOURCE 오류가 반환됩니다. 이는 CB\_COMPOUND 시퀀스 내의 모든 이전 작업이 성공적으로 평가되었다고 가정합니다.

CB\_COMPOUND 결과에는 상태 필드가 포함되어 있습니다. 이 상태는 CB\_COMPOUND 프로시저 내에서 실행된 마지막 작업의 상태와 동일해야 합니다. 따라서 작업에 오류가 발생한 경우 상태 값은 실패한 작업에 대해 반환되는 오류 값과 동일합니다.

태그 필드의 정의는 섹션 15.2를 참조하세요.

callback\_ident 값은 SETCLIENTID 중에 클라이언트에 의해 제공됩니다. 서버는 클라이언트가 서버를 올바르게 식별할 수 있도록 CB\_COMPOUND 중에 클라이언트 제공 callback\_ident를 사용해야 합니다.

잘못된 연산 코드는 COMPOUND 프로시저에서 처리되는 것과 동일한 방식으로 처리됩니다.

---
#### **17.2.5.  IMPLEMENTATION**

CB\_COMPOUND 프로시저는 개별 작업을 단일 RPC 요청으로 결합하는 데 사용됩니다. 클라이언트는 각 작업을 차례로 해석합니다. 클라이언트에 의해 작업이 실행되고 해당 작업의 상태가 NFS4\_OK이면 CB\_COMPOUND 프로시저의 다음 작업이 실행됩니다. 클라이언트는 더 이상 실행할 작업이 없거나 작업 중 하나가 NFS4\_OK 이외의 상태 값을 가질 때까지 이 프로세스를 계속합니다.

---
## **18.  NFSv4 Callback Operations**
---
### **18.1.  Operation 3: CB_GETATTR - Get Attributes**
---
#### **18.1.1.  SYNOPSIS**

```text
     fh, attr_request -> attrmask, attr_vals
```

---
#### **18.1.2.  ARGUMENT**

```text
   struct CB_GETATTR4args {
           nfs_fh4 fh;
           bitmap4 attr_request;
   };
```

---
#### **18.1.3.  RESULT**

```text
   struct CB_GETATTR4resok {
           fattr4  obj_attributes;
   };

   union CB_GETATTR4res switch (nfsstat4 status) {
    case NFS4_OK:
            CB_GETATTR4resok       resok4;
    default:
            void;
   };
```

---
#### **18.1.4.  DESCRIPTION**

CB\_GETATTR 작업은 OPEN\_DELEGATE\_WRITE 위임된 파일의 현재 수정된 상태를 얻기 위해 서버에서 사용됩니다. 크기 속성과 변경 속성은 클라이언트가 서비스하도록 보장하는 유일한 속성입니다. 클라이언트와 서버가 CB\_GETATTR 사용과 상호 작용하는 방법에 대한 전체 설명은 섹션 10.4.3을 참조하세요.

지정된 파일 핸들이 클라이언트가 OPEN\_DELEGATE\_WRITE 위임을 보유한 파일 핸들이 아닌 경우 NFS4ERR\_BADHANDLE 오류가 반환됩니다.

---
#### **18.1.5.  IMPLEMENTATION**

클라이언트는 변경 속성과 변경할 수 있는 속성\(time\_modify 및 크기\)에 대해서만 attmask 비트와 관련 속성 값을 반환합니다.

---
### **18.2.  Operation 4: CB_RECALL - Recall an Open Delegation**
---
#### **18.2.1.  SYNOPSIS**

```text
     stateid, truncate, fh -> ()
```

---
#### **18.2.2.  ARGUMENT**

```text
   struct CB_RECALL4args {
           stateid4        stateid;
           bool            truncate;
           nfs_fh4         fh;
   };
```

---
#### **18.2.3.  RESULT**

```text
   struct CB_RECALL4res {
           nfsstat4        status;
   };
```

---
#### **18.2.4.  DESCRIPTION**

CB\_RECALL 작업은 공개 위임을 회수하고 이를 서버에 반환하는 프로세스를 시작하는 데 사용됩니다.

자르기 플래그는 0으로 자르려는 파일에 대한 회수를 최적화하는 데 사용됩니다. 이 값이 설정되면 클라이언트는 파일에 대해 수정된 데이터를 서버에 전파할 의무가 없습니다. 이 데이터는 관련이 없기 때문입니다.

지정된 핸들이 클라이언트가 공개 위임을 보유한 핸들이 아닌 경우 NFS4ERR\_BADHANDLE 오류가 반환됩니다.

지정된 상태 ID가 파일 핸들에 의해 지정된 파일에 대한 공개 위임에 해당하는 상태가 아닌 경우 NFS4ERR\_BAD\_STATEID가 반환됩니다.

---
#### **18.2.5.  IMPLEMENTATION**

클라이언트는 콜백에 즉시 응답해야 합니다. 오류가 반환된 경우를 제외하고 회신해도 회수가 완료되지 않습니다. DELEGRETURN을 사용하여 위임이 반환될 때까지 회수는 완료되지 않습니다.

---
### **18.3.  Operation 10044: CB_ILLEGAL - Illegal Callback Operation**
---
#### **18.3.1.  SYNOPSIS**

```text
     <null> -> ()
```

---
#### **18.3.2.  ARGUMENT**

```text
     void;
```

---
#### **18.3.3.  RESULT**

```text
   /*
    * CB_ILLEGAL: Response for illegal operation numbers
    */
   struct CB_ILLEGAL4res {
           nfsstat4        status;
   };
```

---
#### **18.3.4.  DESCRIPTION**

이 작업은 클라이언트가 지원되지 않는 COMPOUND 내에서 작업 코드를 보내는 경우를 처리하기 위해 결과를 인코딩하기 위한 자리 표시자입니다. 자세한 내용은 섹션 15.2.4를 참조하세요.

CB\_ILLEGAL4res의 상태 필드는 NFS4ERR\_OP\_ILLEGAL로 설정되어야 합니다.\(MUST\)

---
#### **18.3.5.  IMPLEMENTATION**

서버는 아마도 OP\_CB\_ILLEGAL 코드가 포함된 작업을 보내지 않을 것입니다. 하지만 보낸 경우 다른 유효하지 않은 작업 코드와 마찬가지로 응답은 CB\_ILLEGAL4res가 됩니다. 클라이언트가 OP\_ILLEGAL이 아닌 잘못된 연산 코드를 받고 클라이언트가 XDR 디코드 단계 중에 적법한 연산 코드를 확인하는 경우 CB\_ILLEGAL4res가 반환되지 않습니다.

---
## **19.  Security Considerations**

NFS는 인증 관점에서 볼 때 클라이언트가 전체 시스템이거나 적어도 시스템의 소스 IP 주소인 모델을 역사적으로 사용해 왔습니다. NFS 서버는 NFS 클라이언트를 사용하여 최종 사용자를 적절하게 인증했습니다. NFS 서버는 클라이언트의 소스 IP 주소로 식별되는 특정 클라이언트에만 파일을 공유했습니다. 이 모델에서 AUTH\_SYS RPC 보안 특성은 NFS 서버에 대한 클라이언트를 사용하는 최종 사용자를 간단히 식별했습니다. NFS 응답을 처리할 때 클라이언트는 요청이 전송된 것과 동일한 IP 주소 및 포트 번호에서 응답이 오는지 확인했습니다. 이러한 모델은 구현하기 쉽고 배포 및 사용이 간단하지만 확실히 안전한 모델은 아닙니다. 따라서 NFSv4에서는 클라이언트의 최종 사용자가 보안 주체에 대해 상호 인증\(네트워크에서 암호나 키를 공개하지 않는 암호화 체계를 통해\)하는 엔드투엔드 인증을 사용하는 보안 모델을 구현에서 지원할 것을 요구합니다. NFS 서버에서. NFS 요청 및 응답의 무결성과 개인 정보 보호도 고려해야 합니다. 엔드투엔드 상호 인증, 무결성 및 개인 정보 보호 문제는 섹션 3의 일부로 논의됩니다.

NFSv4 필수 보안 모델이 사용되고 user@dns\_domain 형식의 보안 주체 또는 NFSv4 이름을 섹션 5.9에 설명된 대로 로컬 표현으로 또는 로컬 표현에서 번역해야 하는 경우 번역은 무결성을 유지하는 안전한 방식으로 수행되어야 합니다. 번역의. LDAP\(Lightweight Directory Access Protocol\)\(\[RFC4511\]\)와 같은 이름 서비스와의 통신을 위해 이는 인증 및 데이터 무결성을 사용하는 보안 서비스를 사용하는 것을 의미합니다. Kerberos 및 TLS\(전송 계층 보안\)\(\[RFC5246\]\)는 이러한 보안 서비스의 예입니다.\(SHOULD\)

구현이 필수라는 것이 반드시 사용해야 한다는 의미는 아닙니다. AUTH\_SYS는 NFSv4 클라이언트 및 서버에서 사용할 수 있습니다. 그러나 AUTH\_SYS는 NFSv4의 선택적 보안 유형일 뿐이므로 AUTH\_SYS를 통한 상호 운용성은 보장되지 않습니다.\(MUST, MAY\)

관리 오버헤드 감소, 성능 향상 및/또는 CPU 사용률 감소로 인해 NFSv4 구현 사용자는 각 원격 프로시저 호출 및 응답에서 무결성 보호를 활성화하는 보안 메커니즘을 사용하지 않도록 선택할 수 있습니다. 무결성이 없는 메커니즘을 사용하면 고객은 RPC 요청 및/또는 응답을 수정하는 NFS 클라이언트와 서버 사이의 공격자에게 취약해집니다. 구현 시 더 약한 보안 메커니즘을 사용하는 옵션을 자유롭게 제공할 수 있지만, 특히 사용자 선택을 무시하는 구현을 보장하는 두 가지 작업이 있습니다.

첫 번째 작업은 SECINFO입니다. 클라이언트는 rpc\_gss\_svc\_integrity 또는 rpc\_gss\_svc\_privacy\(rpc\_gss\_svc\_privacy에 무결성 보호가 포함됨\) 서비스를 사용하는 보안 트리플이 포함된 RPCSEC\_GSS와 같이 무결성 보호 기능이 있는 보안 방식으로 보호되도록 SECINFO 호출을 실행하는 것이 좋습니다. SECINFO 및 그 결과를 캡슐화하는 무결성 보호가 없으면 중간에 있는 공격자가 결과를 수정하여 클라이언트가 서버에서 허용하는 집합에서 더 약한 알고리즘을 선택할 수 있으므로 클라이언트 및/또는 서버가 추가 공격에 취약해질 수 있습니다.

무결성 보호를 사용해야 하는 두 번째 작업은 fs\_locations 속성에 대한 GETATTR입니다. 공격에는 두 단계가 있습니다. 먼저, 공격자는 NFS4ERR\_MOVED를 반환하도록 일부 작업의 보호되지 않은 결과를 수정합니다. 둘째, 클라이언트가 fs\_locations 속성에 대한 GETATTR을 추적할 때 공격자는 결과를 수정하여 클라이언트가 공격자가 제어하는 ​​서버로 트래픽을 마이그레이션하도록 합니다.\(SHOULD\)

SETCLIENTID/SETCLIENTID\_CONFIRM 작업은 클라이언트 상태 해제를 담당하므로 이러한 작업에 사용된 주체를 확인하고 이러한 작업의 이전 사용과 일치하는 것이 중요합니다. 자세한 내용은 섹션 9.1.1을 참조하세요.

UTF-8 형식의 유니코드는 파일 구성 요소 이름\(예: 디렉터리 및 파일 구성 요소 모두\)과 소유자 및 owner\_group 속성에 사용됩니다. 파일 구성 요소 이름에는 다른 문자 집합도 허용될 수 있습니다. 문자열 처리\(예: 유니코드 정규화\)는 문자열 비교에 대한 보안 문제를 야기합니다. 자세한 내용은 섹션 5.9 및 12를 참조하고 관련 식별자 비교 보안 고려 사항은 \[RFC6943\]을 참조하세요. 파일 구성요소 이름은 ACL이 적용되는 객체를 식별하는 데 사용되기 때문에 \[RFC6943\]의 식별자 비교 논의와 관련된 식별자입니다. 섹션 6을 참조하세요.

---
## **20.  IANA Considerations**

이 섹션에서는 \[RFC5226\]에 정의된 용어를 사용합니다.

---
### **20.1.  Named Attribute Definitions**

IANA는 \[RFC3530\] 및 \[RFC5661\]에 대해 "NFSv4 명명된 속성 정의 레지스트리"라는 레지스트리를 만들었습니다. 이 섹션에서는 새로운 변경 사항을 소개하지 않지만 의도를 요약합니다.

NFSv4 프로토콜은 0개 이상의 명명된 속성과 파일의 연결을 지원합니다. 이러한 속성의 네임스페이스 식별자는 문자열 이름으로 정의됩니다. 프로토콜은 이러한 파일 속성에 대한 특정 네임스페이스 할당을 정의하지 않습니다. IANA 레지스트리는 공통 이익이 존재하는 곳에서 상호 운용성을 촉진합니다. 애플리케이션 개발자는 필요에 따라 속성을 정의하고 사용할 수 있지만 IANA에 속성을 등록하는 것이 좋습니다.

이렇게 등록된 명명된 속성은 등록 이후에 정의된 버전을 포함하여 NFSv4의 모든 마이너 버전에 적용되는 것으로 추정됩니다. 명명된 속성이 사용되지 않는 부 버전과 관련하여 제한되도록 의도된 경우 레지스트리 할당에는 적용 가능한 제한이 명확하게 명시됩니다.

레지스트리는 \[RFC5226\]의 섹션 4.1에 정의된 사양 요구 정책을 사용하여 유지 관리됩니다.

NFSv4 사양에서 명명된 속성의 이름은 이론적으로 최대 2^32 - 1바이트 길이일 수 있지만 실제로 NFSv4 클라이언트와 서버는 그렇게 긴 문자열을 처리할 수 없습니다. IANA는 UTF-8 문자 128자를 초과하는 명명된 속성이 있는 할당 요청을 거부해야 합니다. IESG가 실험적 사용 및 표준 조치 할당 기반을 설정할 수 있는 유연성을 제공하기 위해 접두사 "EXPE" 및 "STDS"는 예약되어 있습니다. 길이가 0인 명명된 속성 이름은 예약되어 있습니다.

접두사 "PRIV"는 개인용으로 할당됩니다. IANA 레지스트리의 할당과 충돌할 위험 없이 등록되지 않은 명명된 속성을 사용하려는 사이트는 명명된 모든 속성에 접두사 "PRIV"를 사용해야 합니다.

일부 NFSv4 클라이언트 및 서버에는 대소문자를 구분하지 않는 의미 체계가 있으므로 "EXPE", "PRIV" 및 "STDS" 각각에 대한 15개의 추가 소문자 및 대소문자 혼합 순열이 예약되어 있습니다\(예: "expe", "expE", " exPe' 등은 예약되어 있습니다.\) 마찬가지로 IANA는 명명된 두 속성이 공통 사례로 변환된 경우 충돌할 수 있는 두 할당을 허용해서는 안 됩니다.

명명된 속성의 레지스트리는 각 할당에 대한 세 개의 필드를 포함하는 할당 목록입니다.

1. 속성의 실제 이름인 US-ASCII 문자열 이름. 이 이름은 고유해야 합니다. 이 문자열 이름의 길이는 1\~128자의 UTF-8 문자일 수 있습니다.

2. 명명된 속성의 사양에 대한 참조. 참조는 최대 256바이트\(또는 IANA에서 허용하는 경우 그 이상\)를 사용할 수 있습니다.

3. 등록자의 연락처. 접촉 지점은 최대 256바이트\(또는 IANA가 허용하는 경우 그 이상\)를 사용할 수 있습니다.

---
#### **20.1.1.  Initial Registry**

초기 레지스트리가 없습니다.

---
#### **20.1.2.  Updating Registrations**

등록자는 항상 연락처 필드를 업데이트할 수 있습니다. 다른 변경 사항을 적용하려면 전문가 검토 또는 IESG 승인이 필요합니다.

---
### **20.2.  Updates to Existing IANA Registries**

또한 이 문서는 RFC 3530을 더 이상 사용하지 않으므로 IANA는

o 네트워크 식별자\(r\_netid\) 레지스트리의 RFC 3530에 대한 모든 참조를 이 문서에 대한 참조로 대체했습니다.

o GSSAPI/Kerberos/SASL 서비스 이름 레지스트리의 RFC 3530에 대한 nfs 등록 참조에 대한 참조를 이 문서에 대한 참조로 대체했습니다.

---
## **21.  References**
---
### **21.1.  Normative References**

```text
   [RFC20]    Cerf, V., "ASCII format for network interchange", STD 80,
              RFC 20, October 1969,
              <http://www.rfc-editor.org/info/rfc20>.

   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", BCP 14, RFC 2119, March 1997,
              <http://www.rfc-editor.org/info/rfc2119>.

   [RFC2203]  Eisler, M., Chiu, A., and L. Ling, "RPCSEC_GSS Protocol
              Specification", RFC 2203, September 1997,
              <http://www.rfc-editor.org/info/rfc2203>.

   [RFC2743]  Linn, J., "Generic Security Service Application Program
              Interface Version 2, Update 1", RFC 2743, January 2000,
              <http://www.rfc-editor.org/info/rfc2743>.

   [RFC3490]  Faltstrom, P., Hoffman, P., and A. Costello,
              "Internationalizing Domain Names in Applications (IDNA)",
              RFC 3490, March 2003,
              <http://www.rfc-editor.org/info/rfc3490>.

   [RFC3492]  Costello, A., "Punycode: A Bootstring encoding of Unicode
              for Internationalized Domain Names in Applications
              (IDNA)", RFC 3492, March 2003,
              <http://www.rfc-editor.org/info/rfc3492>.

   [RFC3629]  Yergeau, F., "UTF-8, a transformation format of
              ISO 10646", STD 63, RFC 3629, November 2003,
              <http://www.rfc-editor.org/info/rfc3629>.

   [RFC5226]  Narten, T. and H. Alvestrand, "Guidelines for Writing an
              IANA Considerations Section in RFCs", BCP 26, RFC 5226,
              May 2008, <http://www.rfc-editor.org/info/rfc5226>.

   [RFC5403]  Eisler, M., "RPCSEC_GSS Version 2", RFC 5403,
              February 2009, <http://www.rfc-editor.org/info/rfc5403>.

   [RFC5531]  Thurlow, R., "RPC: Remote Procedure Call Protocol
              Specification Version 2", RFC 5531, May 2009,
              <http://www.rfc-editor.org/info/rfc5531>.

   [RFC5665]  Eisler, M., "IANA Considerations for Remote Procedure Call
              (RPC) Network Identifiers and Universal Address Formats",
              RFC 5665, January 2010,
              <http://www.rfc-editor.org/info/rfc5665>.

   [RFC5890]  Klensin, J., "Internationalized Domain Names for
              Applications (IDNA): Definitions and Document Framework",
              RFC 5890, August 2010,
              <http://www.rfc-editor.org/info/rfc5890>.

   [RFC5891]  Klensin, J., "Internationalized Domain Names in
              Applications (IDNA): Protocol", RFC 5891, August 2010,
              <http://www.rfc-editor.org/info/rfc5891>.

   [RFC6649]  Hornquist Astrand, L. and T. Yu, "Deprecate DES,
              RC4-HMAC-EXP, and Other Weak Cryptographic Algorithms in
              Kerberos", BCP 179, RFC 6649, July 2012,
              <http://www.rfc-editor.org/info/rfc6649>.

   [RFC7531]  Haynes, T., Ed., and D. Noveck, Ed., "Network File System
              (NFS) Version 4 External Data Representation Standard
              (XDR) Description", RFC 7531, March 2015,
              <http://www.rfc-editor.org/info/rfc7531>.

   [SPECIALCASING]
              The Unicode Consortium, "SpecialCasing-7.0.0.txt", Unicode
              Character Database, March 2014, <http://www.unicode.org/
              Public/UCD/latest/ucd/SpecialCasing.txt>.

   [UNICODE]  The Unicode Consortium, "The Unicode Standard,
              Version 7.0.0", (Mountain View, CA: The Unicode
              Consortium, 2014 ISBN 978-1-936213-09-2), June 2014,
              <http://www.unicode.org/versions/latest/>.

   [openg_symlink]
              The Open Group, "Section 3.372 of Chapter 3 of Base
              Definitions of The Open Group Base Specifications
              Issue 7", IEEE Std 1003.1, 2013 Edition (HTML Version),
              ISBN 1937218287, April 2013, <http://www.opengroup.org/>.
```

---
### **21.2.  Informative References**

\[Chet\] Juszczak, C., "NFS 서버의 성능 및 정확성 향상", USENIX 회의 논문집, 1990년 6월.

\[Floyd\] Floyd, S. 및 V. Jacobson, "주기적인 라우팅 메시지의 동기화", 네트워킹의 IEEE/ACM 트랜잭션 2\(2\), pp. 122-136, 1994년 4월.

\[IESG\_ERRATA\]

- IESG, "IETF 스트림에 대한 RFC 정오표의 IESG 처리", 2008년 7월.

```text
   [MS-SMB]   Microsoft Corporation, "Server Message Block (SMB)
              Protocol Specification", MS-SMB 43.0, May 2014.
```

\[P1003.1e\]

- 전기전자공학회, Inc., "IEEE 초안 P1003.1e", 1997.

```text
   [RFC1094]  Nowicki, B., "NFS: Network File System Protocol
              specification", RFC 1094, March 1989,
              <http://www.rfc-editor.org/info/rfc1094>.

   [RFC1813]  Callaghan, B., Pawlowski, B., and P. Staubach, "NFS
              Version 3 Protocol Specification", RFC 1813, June 1995,
              <http://www.rfc-editor.org/info/rfc1813>.

   [RFC1833]  Srinivasan, R., "Binding Protocols for ONC RPC Version 2",
              RFC 1833, August 1995,
              <http://www.rfc-editor.org/info/rfc1833>.

   [RFC2054]  Callaghan, B., "WebNFS Client Specification", RFC 2054,
              October 1996, <http://www.rfc-editor.org/info/rfc2054>.

   [RFC2055]  Callaghan, B., "WebNFS Server Specification", RFC 2055,
              October 1996, <http://www.rfc-editor.org/info/rfc2055>.

   [RFC2224]  Callaghan, B., "NFS URL Scheme", RFC 2224, October 1997,
              <http://www.rfc-editor.org/info/rfc2224>.

   [RFC2623]  Eisler, M., "NFS Version 2 and Version 3 Security Issues
              and the NFS Protocol's Use of RPCSEC_GSS and Kerberos V5",
              RFC 2623, June 1999,
              <http://www.rfc-editor.org/info/rfc2623>.

   [RFC2624]  Shepler, S., "NFS Version 4 Design Considerations",
              RFC 2624, June 1999,
              <http://www.rfc-editor.org/info/rfc2624>.

   [RFC2755]  Chiu, A., Eisler, M., and B. Callaghan, "Security
              Negotiation for WebNFS", RFC 2755, January 2000,
              <http://www.rfc-editor.org/info/rfc2755>.

   [RFC3010]  Shepler, S., Callaghan, B., Robinson, D., Thurlow, R.,
              Beame, C., Eisler, M., and D. Noveck, "NFS version 4
              Protocol", RFC 3010, December 2000,
              <http://www.rfc-editor.org/info/rfc3010>.

   [RFC3232]  Reynolds, J., Ed., "Assigned Numbers: RFC 1700 is Replaced
              by an On-line Database", RFC 3232, January 2002,
              <http://www.rfc-editor.org/info/rfc3232>.

   [RFC3530]  Shepler, S., Callaghan, B., Robinson, D., Thurlow, R.,
              Beame, C., Eisler, M., and D. Noveck, "Network File System
              (NFS) version 4 Protocol", RFC 3530, April 2003,
              <http://www.rfc-editor.org/info/rfc3530>.

   [RFC4121]  Zhu, L., Jaganathan, K., and S. Hartman, "The Kerberos
              Version 5 Generic Security Service Application Program
              Interface (GSS-API) Mechanism: Version 2", RFC 4121,
              July 2005, <http://www.rfc-editor.org/info/rfc4121>.

   [RFC4178]  Zhu, L., Leach, P., Jaganathan, K., and W. Ingersoll, "The
              Simple and Protected Generic Security Service Application
              Program Interface (GSS-API) Negotiation Mechanism",
              RFC 4178, October 2005,
              <http://www.rfc-editor.org/info/rfc4178>.

   [RFC4506]  Eisler, M., Ed., "XDR: External Data Representation
              Standard", STD 67, RFC 4506, May 2006,
              <http://www.rfc-editor.org/info/rfc4506>.

   [RFC4511]  Sermersheim, J., Ed., "Lightweight Directory Access
              Protocol (LDAP): The Protocol", RFC 4511, June 2006,
              <http://www.rfc-editor.org/info/rfc4511>.

   [RFC5246]  Dierks, T. and E. Rescorla, "The Transport Layer Security
              (TLS) Protocol Version 1.2", RFC 5246, August 2008,
              <http://www.rfc-editor.org/info/rfc5246>.

   [RFC5661]  Shepler, S., Ed., Eisler, M., Ed., and D. Noveck, Ed.,
              "Network File System (NFS) Version 4 Minor Version 1
              Protocol", RFC 5661, January 2010,
              <http://www.rfc-editor.org/info/rfc5661>.

   [RFC6365]  Hoffman, P. and J. Klensin, "Terminology Used in
              Internationalization in the IETF", BCP 166, RFC 6365,
              September 2011, <http://www.rfc-editor.org/info/rfc6365>.

   [RFC6943]  Thaler, D., Ed., "Issues in Identifier Comparison for
              Security Purposes", RFC 6943, May 2013,
              <http://www.rfc-editor.org/info/rfc6943>.

   [fcntl]    The Open Group, "Section 'fcntl()' of System Interfaces of
              The Open Group Base Specifications Issue 7", IEEE
              Std 1003.1, 2013 Edition (HTML Version), ISBN 1937218287,
              April 2013, <http://www.opengroup.org/>.

   [fsync]    The Open Group, "Section 'fsync()' of System Interfaces of
              The Open Group Base Specifications Issue 7", IEEE
              Std 1003.1, 2013 Edition (HTML Version), ISBN 1937218287,
              April 2013, <http://www.opengroup.org/>.

   [getpwnam]
              The Open Group, "Section 'getpwnam()' of System Interfaces
              of The Open Group Base Specifications Issue 7", IEEE
              Std 1003.1, 2013 Edition (HTML Version), ISBN 1937218287,
              April 2013, <http://www.opengroup.org/>.

   [read_api]
              The Open Group, "Section 'read()' of System Interfaces of
              The Open Group Base Specifications Issue 7", IEEE
              Std 1003.1, 2013 Edition (HTML Version), ISBN 1937218287,
              April 2013, <http://www.opengroup.org/>.

   [readdir_api]
              The Open Group, "Section 'readdir()' of System Interfaces
              of The Open Group Base Specifications Issue 7", IEEE
              Std 1003.1, 2013 Edition (HTML Version), ISBN 1937218287,
              April 2013, <http://www.opengroup.org/>.

   [stat]     The Open Group, "Section 'stat()' of System Interfaces of
              The Open Group Base Specifications Issue 7", IEEE
              Std 1003.1, 2013 Edition (HTML Version), ISBN 1937218287,
              April 2013, <http://www.opengroup.org/>.

   [unlink]   The Open Group, "Section 'unlink()' of System Interfaces
              of The Open Group Base Specifications Issue 7", IEEE
              Std 1003.1, 2013 Edition (HTML Version), ISBN 1937218287,
              April 2013, <http://www.opengroup.org/>.

   [write_api]
              The Open Group, "Section 'write()' of System Interfaces of
              The Open Group Base Specifications Issue 7", IEEE
              Std 1003.1, 2013 Edition (HTML Version), ISBN 1937218287,
              April 2013, <http://www.opengroup.org/>.
```

\[xnfs\] The Open Group, "상호 작업을 위한 프로토콜: XNFS, 버전 3W, ISBN 1-85912-184-5", 1998년 2월.

---
# **Acknowledgments**

A bis는 확실히 첫 번째 시도의 어깨 위에 세워졌습니다. Spencer Shepler, Brent Callaghan, David Robinson, Robert Thurlow, Carl Beame, Mike Eisler 및 David Noveck은 이 작업에 많은 노력을 기울였습니다.

Tom Haynes는 이 프로젝트에 시간을 투자해 준 NetApp, Inc.에 감사를 표하고 싶습니다.

Rob Thurlow는 마이그레이션이 발생한 경우 클라이언트가 새 서버에 접속해야 하는 방법을 명확히 했습니다.

David Black, Nico Williams, Mike Eisler, Trond Myklebust, James Lentini 및 Mike Kupfer는 섹션 12의 초기 초안 버전을 많이 읽고 수많은 유용한 제안을 제공했습니다. 이것이 없었다면 이 문서에 대한 해당 섹션의 필요한 개정은 불가능했을 것입니다.

Peter Staubach는 섹션 12의 초기 초안 버전을 거의 모두 읽고 출판된 결과를 얻었으며, 그의 수많은 의견은 항상 유용했으며 최종 결과의 품질을 향상시키는 데 크게 기여했습니다.

Peter Saint-Andre는 섹션 12의 최신 초안을 읽을 만큼 친절했으며 국제화 커뮤니티의 관심사에 대한 몇 가지 핵심 통찰력을 제공했습니다.

James Lentini는 섹션 8의 재작성을 기꺼이 읽었으며 그의 의견은 해당 노력의 질을 향상시키는 데 매우 중요했습니다.

Rob Thurlow, Sorin Faibish, James Lentini, Bruce Fields 및 Trond Myklebust는 격주 선별 회의에 충실하게 참석했으며 많은 조치 항목을 수락했습니다.

Bruce Fields는 일반적으로 세 번째 가장자리 조건과 커티시 잠금 장치 모두에 대한 좋은 공명판이었습니다. 그는 또한 \[RFC5661\]에서 백포트 문제를 근절하는 데 앞장섰습니다.

Marcel Telka는 자물쇠 소유자와 공개 소유자의 차이를 바로잡는 데 앞장섰습니다. 그는 또한 최종 문서를 부지런히 검토했습니다.

Benjamin Kaduk은 DES가 죽었다는 사실을 상기시켰고 Nico Williams는 우리가 관 뚜껑을 닫는 것을 도왔습니다.

```text
   Elwyn Davies provided a very thorough and engaging Gen-ART review;
   thanks!
```

---
# **Authors' Addresses**

```text
   Thomas Haynes (editor)
   Primary Data, Inc.
   4300 El Camino Real Ste 100
   Los Altos, CA  94022
   United States

   Phone: +1 408 215 1519
   EMail: thomas.haynes@primarydata.com

   David Noveck (editor)
   Dell
   300 Innovative Way
   Nashua, NH  03062
   United States

   Phone: +1 781 572 8038
   EMail: dave_noveck@dell.com
```
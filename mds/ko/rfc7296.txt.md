

```text
Internet Engineering Task Force (IETF)                        C. Kaufman
Request for Comments: 7296                                     Microsoft
STD: 79                                                       P. Hoffman
Obsoletes: 5996                                           VPN Consortium
Category: Standards Track                                         Y. Nir
ISSN: 2070-1721                                              Check Point
                                                               P. Eronen
                                                             Independent
                                                              T. Kivinen
                                                           INSIDE Secure
                                                            October 2014

            Internet Key Exchange Protocol Version 2 (IKEv2)
```

---
# **Abstract**

이 문서에서는 IKE\(인터넷 키 교환\) 프로토콜 버전 2에 대해 설명합니다. IKE는 상호 인증을 수행하고 SA\(보안 연결\)를 설정 및 유지 관리하는 데 사용되는 IPsec의 구성 요소입니다. 이 문서는 RFC 5996을 더 이상 사용하지 않으며 이에 대한 모든 정오표를 포함합니다. IKEv2를 인터넷 표준으로 발전시킵니다.

---
# **Status of This Memo**

이것은 인터넷 표준 추적 문서입니다.

이 문서는 IETF\(Internet Engineering Task Force\)의 제품입니다. 이는 IETF 커뮤니티의 합의를 나타냅니다. 공개 검토를 받았으며 IESG\(Internet Engineering Steering Group\)의 출판 승인을 받았습니다. 인터넷 표준에 대한 자세한 내용은 RFC 5741의 섹션 2에서 확인할 수 있습니다.

이 문서의 현재 상태, 정오표, 피드백 제공 방법에 대한 정보는 http://www.rfc-editor.org/info/rfc7296에서 얻을 수 있습니다.

---
# **Copyright Notice**

Copyright \(c\) 2014 IETF Trust 및 문서 작성자로 식별된 사람. 판권 소유.

이 문서는 이 문서의 발행일에 유효한 BCP 78 및 IETF 문서에 관한 IETF 트러스트의 법적 조항\(http://trustee.ietf.org/license-info\)의 적용을 받습니다. 이 문서와 관련된 귀하의 권리 및 제한 사항을 설명하므로 이 문서를 주의 깊게 검토하십시오. 이 문서에서 추출한 코드 구성 요소는 Trust Legal Provisions의 섹션 4.e에 설명된 대로 Simplified BSD License 텍스트를 포함해야 하며 Simplified BSD License에 설명된 대로 보증 없이 제공됩니다.

이 문서에는 2008년 11월 10일 이전에 공개되거나 공개된 IETF 문서 또는 IETF 기고문의 자료가 포함될 수 있습니다. 이 자료의 일부에 대한 저작권을 제어하는 ​​사람은 해당 자료의 수정을 허용할 권리를 IETF 트러스트에 부여하지 않았을 수 있습니다. IETF 표준 프로세스 외부. 이러한 자료의 저작권을 관리하는 사람으로부터 적절한 라이센스를 얻지 않고 이 문서는 IETF 표준 프로세스 외부에서 수정할 수 없으며 IETF 표준 프로세스 외부에서 이 문서의 파생물을 생성할 수 없습니다. RFC로 게시하거나 영어 이외의 언어로 번역합니다.

---
# **Table of Contents**

```text
   1. Introduction ....................................................5
      1.1. Usage Scenarios ............................................7
           1.1.1. Security Gateway to Security Gateway in
                  Tunnel Mode .........................................7
           1.1.2. Endpoint-to-Endpoint Transport Mode .................8
           1.1.3. Endpoint to Security Gateway in Tunnel Mode .........8
           1.1.4. Other Scenarios .....................................9
      1.2. The Initial Exchanges ......................................9
      1.3. The CREATE_CHILD_SA Exchange ..............................13
           1.3.1. Creating New Child SAs with the
                  CREATE_CHILD_SA Exchange ...........................14
           1.3.2. Rekeying IKE SAs with the CREATE_CHILD_SA
                  Exchange ...........................................16
           1.3.3. Rekeying Child SAs with the CREATE_CHILD_SA
                  Exchange ...........................................16
      1.4. The INFORMATIONAL Exchange ................................17
           1.4.1. Deleting an SA with INFORMATIONAL Exchanges ........18
      1.5. Informational Messages outside of an IKE SA ...............19
      1.6. Requirements Terminology ..................................20
      1.7. Significant Differences between RFC 4306 and RFC 5996 .....20
      1.8. Differences between RFC 5996 and This Document ............23
   2. IKE Protocol Details and Variations ............................23
      2.1. Use of Retransmission Timers ..............................24
      2.2. Use of Sequence Numbers for Message ID ....................25
      2.3. Window Size for Overlapping Requests ......................26
      2.4. State Synchronization and Connection Timeouts .............28
      2.5. Version Numbers and Forward Compatibility .................30
      2.6. IKE SA SPIs and Cookies ...................................32
           2.6.1. Interaction of COOKIE and INVALID_KE_PAYLOAD .......35
      2.7. Cryptographic Algorithm Negotiation .......................35
      2.8. Rekeying ..................................................36
           2.8.1. Simultaneous Child SA Rekeying .....................38
           2.8.2. Simultaneous IKE SA Rekeying .......................40
           2.8.3. Rekeying the IKE SA versus Reauthentication ........42
      2.9. Traffic Selector Negotiation ..............................42
           2.9.1. Traffic Selectors Violating Own Policy .............45
           2.9.2. Traffic Selectors in Rekeying ......................46
      2.10. Nonces ...................................................46
      2.11. Address and Port Agility .................................47
      2.12. Reuse of Diffie-Hellman Exponentials .....................47
      2.13. Generating Keying Material ...............................48
      2.14. Generating Keying Material for the IKE SA ................49
      2.15. Authentication of the IKE SA .............................50
      2.16. Extensible Authentication Protocol Methods ...............52
      2.17. Generating Keying Material for Child SAs .................54
      2.18. Rekeying IKE SAs Using a CREATE_CHILD_SA Exchange ........55
      2.19. Requesting an Internal Address on a Remote Network .......56
      2.20. Requesting the Peer's Version ............................58
      2.21. Error Handling ...........................................58
           2.21.1. Error Handling in IKE_SA_INIT .....................59
           2.21.2. Error Handling in IKE_AUTH ........................59
           2.21.3. Error Handling after IKE SA is Authenticated ......60
           2.21.4. Error Handling Outside IKE SA .....................60
      2.22. IPComp ...................................................61
      2.23. NAT Traversal ............................................62
           2.23.1. Transport Mode NAT Traversal ......................66
      2.24. Explicit Congestion Notification (ECN) ...................70
      2.25. Exchange Collisions ......................................70
           2.25.1. Collisions while Rekeying or Closing Child SAs ....71
           2.25.2. Collisions while Rekeying or Closing IKE SAs ......71
   3. Header and Payload Formats .....................................72
      3.1. The IKE Header ............................................72
      3.2. Generic Payload Header ....................................75
      3.3. Security Association Payload ..............................77
           3.3.1. Proposal Substructure ..............................80
           3.3.2. Transform Substructure .............................81
           3.3.3. Valid Transform Types by Protocol ..................85
           3.3.4. Mandatory Transform IDs ............................85
           3.3.5. Transform Attributes ...............................86
           3.3.6. Attribute Negotiation ..............................88
      3.4. Key Exchange Payload ......................................89
      3.5. Identification Payloads ...................................90
      3.6. Certificate Payload .......................................92
      3.7. Certificate Request Payload ...............................95
      3.8. Authentication Payload ....................................97
      3.9. Nonce Payload .............................................98
      3.10. Notify Payload ...........................................99
           3.10.1. Notify Message Types .............................101
      3.11. Delete Payload ..........................................104
      3.12. Vendor ID Payload .......................................105
      3.13. Traffic Selector Payload ................................106
           3.13.1. Traffic Selector .................................108
      3.14. Encrypted Payload .......................................110
      3.15. Configuration Payload ...................................112
           3.15.1. Configuration Attributes .........................113
           3.15.2. Meaning of INTERNAL_IP4_SUBNET and
                   INTERNAL_IP6_SUBNET ..............................116
           3.15.3. Configuration Payloads for IPv6 ..................118
           3.15.4. Address Assignment Failures ......................119
      3.16. Extensible Authentication Protocol (EAP) Payload ........120
   4. Conformance Requirements ......................................122
   5. Security Considerations .......................................124
      5.1. Traffic Selector Authorization ...........................127
   6. IANA Considerations ...........................................128
   7. References ....................................................128
      7.1. Normative References .....................................128
      7.2. Informative References ...................................130
   Appendix A. Summary of Changes from IKEv1 ........................136
   Appendix B. Diffie-Hellman Groups ................................137
     B.1. Group 1 - 768-bit MODP ....................................137
     B.2. Group 2 - 1024-bit MODP ...................................137
   Appendix C. Exchanges and Payloads ...............................138
     C.1. IKE_SA_INIT Exchange ......................................138
     C.2. IKE_AUTH Exchange without EAP .............................138
     C.3. IKE_AUTH Exchange with EAP ................................139
     C.4. CREATE_CHILD_SA Exchange for Creating or Rekeying
          Child SAs .................................................140
     C.5. CREATE_CHILD_SA Exchange for Rekeying the IKE SA ..........140
     C.6. INFORMATIONAL Exchange ....................................141
   Acknowledgements .................................................141
   Authors' Addresses ...............................................142
```

---
## **1.  Introduction**

IP 보안\(IPsec\)은 IP 데이터그램에 대한 기밀성, 데이터 무결성, 액세스 제어 및 데이터 소스 인증을 제공합니다. 이러한 서비스는 IP 데이터그램의 소스와 싱크 간의 공유 상태를 유지함으로써 제공됩니다. 이 상태는 무엇보다도 데이터그램에 제공되는 특정 서비스, 서비스를 제공하는 데 사용되는 암호화 알고리즘, 암호화 알고리즘에 대한 입력으로 사용되는 키를 정의합니다.

이 공유 상태를 수동 방식으로 설정하면 확장이 잘 되지 않습니다. 따라서 이 상태를 동적으로 설정하는 프로토콜이 필요합니다. 이 문서에서는 IKE\(인터넷 키 교환\)라는 프로토콜에 대해 설명합니다. IKE 버전 1은 RFC 2407 \[DOI\], 2408 \[ISAKMP\] 및 2409 \[IKEV1\]에 정의되었습니다. IKEv2는 이러한 RFC를 모두 대체했습니다. IKEv2는 \[IKEV2\]\(RFC 4306\)에 정의되었으며 \[Clarif\]\(RFC 4718\)에서 명확해졌습니다. \[RFC5996\]은 RFC 4306 및 4718을 대체하고 업데이트했습니다. 이 문서는 RFC 5996을 대체합니다. RFC 4306에 명시된 IKEv2는 이전 버전과 호환되지 않는 IKE 프로토콜에 대한 변경 사항입니다. RFC 5996은 IKEv2에 대한 설명을 제공하기 위해 RFC 4306을 개정하여 IKEv2 프로토콜을 최소한으로 변경했습니다. 이 문서는 RFC 5996을 대체하며 인터넷 표준으로의 발전에 적합하도록 약간 수정했습니다. RFC 4306과 5996 사이의 중요한 차이점 목록은 섹션 1.7에 제공되며, RFC 5996과 이 문서 간의 차이점은 섹션 1.8에 제공됩니다.

IKE는 두 당사자 간의 상호 인증을 수행하고 ESP\(보안 페이로드 캡슐화\)\[ESP\] 또는 AH\(인증 헤더\)\[AH\]에 대한 SA를 효율적으로 설정하는 데 사용할 수 있는 공유 비밀 정보를 포함하는 IKE SA\(보안 연결\)를 설정합니다. SA가 전달하는 트래픽을 보호하기 위해 사용할 암호화 알고리즘 세트입니다. 이 문서에서 "제품군" 또는 "암호화 제품군"이라는 용어는 SA를 보호하는 데 사용되는 전체 알고리즘 세트를 의미합니다. 개시자는 혼합 및 일치 방식으로 모음으로 결합할 수 있는 지원되는 알고리즘을 나열하여 하나 이상의 모음을 제안합니다. IKE는 ESP 또는 AH SA와 관련하여 IP 압축\(IPComp\) \[IP-COMP\] 사용을 협상할 수도 있습니다. IKE SA를 통해 설정되는 ESP 또는 AH용 SA를 "하위 SA"라고 합니다.

모든 IKE 통신은 요청과 응답이라는 메시지 쌍으로 구성됩니다. 이 쌍을 "교환"이라고 하며 때로는 "요청/응답 쌍"이라고도 합니다. IKE SA를 설정하는 처음 두 개의 메시지 교환을 IKE\_SA\_INIT 교환 및 IKE\_AUTH 교환이라고 합니다. 후속 IKE 교환을 CREATE\_CHILD\_SA 교환 또는 INFORMATIONAL 교환이라고 합니다. 일반적인 경우에는 IKE SA와 첫 번째 하위 SA를 설정하기 위한 단일 IKE\_SA\_INIT 교환과 단일 IKE\_AUTH 교환\(총 4개 메시지\)이 있습니다. 예외적인 경우에는 이러한 각 교환이 두 번 이상 있을 수 있습니다. 모든 경우에 모든 IKE\_SA\_INIT 교환은 다른 교환 유형보다 먼저 완료되어야 하며, 모든 IKE\_AUTH 교환은 반드시 완료되어야 하며, 그 이후에는 CREATE\_CHILD\_SA 및 INFORMATIONAL 교환이 임의의 순서로 발생할 수 있습니다. 일부 시나리오에서는 IPsec 끝점 간에 하위 SA가 하나만 필요하므로 추가 교환이 없습니다. 후속 교환은 동일한 인증된 엔드포인트 쌍 사이에 추가 하위 SA를 설정하고 관리 기능을 수행하는 데 사용될 수 있습니다.\(MUST, MAY\)

IKE 메시지 흐름은 항상 요청과 응답으로 구성됩니다. 신뢰성을 보장하는 것은 요청자의 책임입니다. 시간 초과 간격 내에 응답이 수신되지 않으면 요청자는 요청을 다시 전송해야 합니다\(또는 연결을 포기해야 합니다\).

IKE 세션의 첫 번째 교환인 IKE\_SA\_INIT는 IKE SA에 대한 보안 매개변수를 협상하고 nonce를 보내고 Diffie-Hellman 값을 보냅니다.

두 번째 교환인 IKE\_AUTH는 ID를 전송하고, 두 ID에 해당하는 비밀에 대한 지식을 증명하고, 첫 번째\(종종 유일한\) AH 또는 ESP 하위 SA에 대한 SA를 설정합니다\(AH 또는 ESP 하위 설정에 실패하지 않는 한\). SA. 이 경우 IKE SA는 하위 SA 없이 계속 설정됩니다.

후속 교환 유형은 CREATE\_CHILD\_SA\(하위 SA 생성\) 및 INFORMATIONAL\(SA 삭제, 오류 조건 보고 또는 기타 관리 수행\)입니다. 모든 요청에는 응답이 필요합니다. 페이로드가 없는 정보 요청\(구문에서 요구하는 빈 암호화 페이로드 제외\)은 일반적으로 활성 여부를 확인하는 데 사용됩니다. 이러한 후속 교환은 초기 교환이 완료될 때까지 사용할 수 없습니다.

다음 설명에서는 오류가 발생하지 않는 것으로 가정합니다. 오류 발생 시 흐름 수정은 섹션 2.21에 설명되어 있습니다.

---
### **1.1.  Usage Scenarios**

IKE는 각각 고유한 특수 요구 사항이 있는 다양한 시나리오에서 ESP 또는 AH SA를 협상하는 데 사용됩니다.

---
#### **1.1.1.  Security Gateway to Security Gateway in Tunnel Mode**

```text
                +-+-+-+-+-+            +-+-+-+-+-+
                |         | IPsec      |         |
   Protected    |Tunnel   | tunnel     |Tunnel   |     Protected
   Subnet   <-->|Endpoint |<---------->|Endpoint |<--> Subnet
                |         |            |         |
                +-+-+-+-+-+            +-+-+-+-+-+

           Figure 1: Security Gateway to Security Gateway Tunnel
```

이 시나리오에서는 IP 연결의 어느 끝점도 IPsec을 구현하지 않지만 이들 사이의 네트워크 노드는 일부 동안 트래픽을 보호합니다. 보호는 끝점에 투명하며 처리를 위해 터널 끝점을 통해 패킷을 보내는 일반 라우팅에 따라 달라집니다. 각 끝점은 "뒤에 있는" 주소 집합을 알리고 패킷은 내부 IP 헤더에 실제 끝점의 IP 주소가 포함되는 터널 모드로 전송됩니다.

---
#### **1.1.2.  Endpoint-to-Endpoint Transport Mode**

```text
   +-+-+-+-+-+                                          +-+-+-+-+-+
   |         |                 IPsec transport          |         |
   |Protected|                or tunnel mode SA         |Protected|
   |Endpoint |<---------------------------------------->|Endpoint |
   |         |                                          |         |
   +-+-+-+-+-+                                          +-+-+-+-+-+

                      Figure 2: Endpoint to Endpoint
```

이 시나리오에서는 IP 연결의 두 끝점 모두 \[IPSECARCH\]의 호스트에 필요한 대로 IPsec을 구현합니다. 전송 모드는 일반적으로 내부 IP 헤더 없이 사용됩니다. 이 SA에 의해 보호되는 패킷에 대해 단일 주소 쌍이 협상됩니다. 이러한 엔드포인트는 참가자의 IPsec 인증 ID를 기반으로 애플리케이션 계층 액세스 제어를 구현할 수 있습니다. 이 시나리오는 \[ARCHPRINC\], \[TRANSPARENCY\] 이후 인터넷의 지침 원칙이었던 종단 간 보안과 \[ARCHGUIDEPHIL\]에서 언급한 네트워크의 복잡성으로 인한 고유한 문제를 제한하는 방법을 가능하게 합니다. 이 시나리오는 IPv4 인터넷에 완전히 적용할 수는 없지만 IKEv1을 사용하는 인트라넷 내의 특정 시나리오에서는 성공적으로 배포되었습니다. IPv6로 전환하고 IKEv2를 채택하는 동안 더욱 광범위하게 활성화되어야 합니다.\(MAY\)

이 시나리오에서는 보호된 엔드포인트 중 하나 또는 둘 모두가 NAT\(네트워크 주소 변환\) 노드 뒤에 있을 수 있습니다. 이 경우 UDP 헤더의 포트 번호를 사용하여 터널링된 패킷을 UDP 캡슐화해야 합니다. NAT "뒤에 있는" 개별 엔드포인트를 식별합니다\(섹션 2.23 참조\).

---
#### **1.1.3.  Endpoint to Security Gateway in Tunnel Mode**

```text
   +-+-+-+-+-+                          +-+-+-+-+-+
   |         |         IPsec            |         |     Protected
   |Protected|         tunnel           |Tunnel   |     Subnet
   |Endpoint |<------------------------>|Endpoint |<--- and/or
   |         |                          |         |     Internet
   +-+-+-+-+-+                          +-+-+-+-+-+
```

- 그림 3: 엔드포인트에서 보안 게이트웨이 터널로

이 시나리오에서는 보호되는 끝점\(일반적으로 휴대용 로밍 컴퓨터\)이 IPsec 보호 터널을 통해 회사 네트워크에 다시 연결됩니다. 회사 네트워크의 정보에 액세스하는 데에만 이 터널을 사용할 수도 있고, 이점을 활용하기 위해 모든 트래픽을 회사 네트워크를 통해 다시 터널링할 수도 있습니다.

인터넷 기반 공격에 대해 기업 방화벽이 제공하는 보호 기능입니다. 두 경우 모두 보호된 엔드포인트는 반환된 패킷이 보안 게이트웨이로 이동하여 다시 터널링되도록 보안 게이트웨이와 연결된 IP 주소를 원합니다. 이 IP 주소는 정적이거나 보안 게이트웨이에 의해 동적으로 할당될 수 있습니다. 후자의 경우를 지원하기 위해 IKEv2에는 개시자가 SA 기간 동안 사용할 보안 게이트웨이 소유의 IP 주소를 요청할 수 있는 메커니즘\(즉, 구성 페이로드\)이 포함되어 있습니다.

이 시나리오에서는 패킷이 터널 모드를 사용합니다. 보호된 엔드포인트의 각 패킷에서 외부 IP 헤더에는 현재 위치와 연결된 소스 IP 주소\(즉, 엔드포인트로 직접 라우팅되는 트래픽을 가져오는 주소\)가 포함되고, 내부 IP 헤더에는 소스 IP 주소가 포함됩니다. 보안 게이트웨이에 의해 할당됩니다\(즉, 엔드포인트로 전달하기 위해 보안 게이트웨이로 라우팅되는 트래픽을 받을 주소\). 외부 대상 주소는 항상 보안 게이트웨이의 주소이고, 내부 대상 주소는 패킷의 최종 대상이 됩니다.

이 시나리오에서는 보호된 엔드포인트가 NAT 뒤에 있을 가능성이 있습니다. 이 경우 보안 게이트웨이에 표시되는 IP 주소는 보호되는 엔드포인트에서 전송된 IP 주소와 동일하지 않으며 패킷이 올바르게 라우팅되기 위해서는 UDP 캡슐화되어야 합니다. NAT와의 상호 작용은 섹션 2.23에서 자세히 다룹니다.

---
#### **1.1.4.  Other Scenarios**

위의 중첩된 조합과 마찬가지로 다른 시나리오도 가능합니다. 한 가지 주목할 만한 예는 섹션 1.1.1과 1.1.3의 측면을 결합한 것입니다. 서브넷은 IPsec 터널을 사용하여 원격 보안 게이트웨이를 통해 모든 외부 액세스를 수행할 수 있습니다. 여기서 서브넷의 주소는 나머지 인터넷을 통해 보안 게이트웨이로 라우팅됩니다. 예를 들어 사용자의 보안 게이트웨이에 동적으로 할당된 단일 IP 주소를 할당하는 ISP가 연결을 제공하더라도 고정 IP 주소를 사용하여 가상으로 인터넷에 있는 누군가의 홈 네트워크\(고정 IP 주소와 IPsec 릴레이는 다른 곳에 위치한 제3자\).

---
### **1.2.  The Initial Exchanges**

IKE를 사용한 통신은 항상 IKE\_SA\_INIT 및 IKE\_AUTH 교환\(IKEv1에서는 1단계로 알려짐\)으로 시작됩니다. 이러한 초기 교환은 일반적으로 4개의 메시지로 구성되지만 일부 시나리오에서는 그 수가 늘어날 수 있습니다. IKE를 사용하는 모든 통신은 요청/응답 쌍으로 구성됩니다. 먼저 기본 교환을 설명하고 이어서 설명하겠습니다.

변형. 첫 번째 메시지 쌍\(IKE\_SA\_INIT\)은 암호화 알고리즘을 협상하고 nonce를 교환하며 Diffie-Hellman 교환\[DH\]을 수행합니다.

두 번째 메시지 쌍\(IKE\_AUTH\)은 이전 메시지를 인증하고 ID와 인증서를 교환하며 첫 번째 하위 SA를 설정합니다. 이러한 메시지의 일부는 IKE\_SA\_INIT 교환을 통해 설정된 키로 암호화되고 무결성이 보호되므로 도청자로부터 ID가 숨겨지고 모든 메시지의 모든 필드가 인증됩니다. 암호화 키 생성 방법에 대한 자세한 내용은 섹션 2.14를 참조하세요. \(IKE\_AUTH 교환을 완료할 수 없는 중간자 공격자는 그럼에도 불구하고 개시자의 신원을 볼 수 있습니다.\)

초기 교환 이후의 모든 메시지는 IKE\_SA\_INIT 교환에서 협상된 암호화 알고리즘과 키를 사용하여 암호화 방식으로 보호됩니다. 이러한 후속 메시지는 섹션 2.14에 설명된 대로 파생된 키로 암호화된 섹션 3.14에 설명된 암호화된 페이로드의 구문을 사용합니다. 모든 후속 메시지에는 텍스트에서 "비어 있음"으로 언급되어 있더라도 암호화된 페이로드가 포함됩니다. CREATE\_CHILD\_SA, IKE\_AUTH 또는 INFORMATIONAL 교환의 경우 헤더 뒤의 메시지는 암호화되고 헤더를 포함하는 메시지는 IKE SA에 대해 협상된 암호화 알고리즘을 사용하여 무결성이 보호됩니다.

모든 IKE 메시지에는 고정 헤더의 일부로 메시지 ID가 포함되어 있습니다. 이 메시지 ID는 요청과 응답을 일치시키고 메시지 재전송을 식별하는 데 사용됩니다.

다음 설명에서는 메시지에 포함된 페이로드를 아래와 같은 이름으로 표시합니다.

```text
   Notation    Payload
   -----------------------------------------
   AUTH        Authentication
   CERT        Certificate
   CERTREQ     Certificate Request
   CP          Configuration
   D           Delete
   EAP         Extensible Authentication
   HDR         IKE header (not a payload)
   IDi         Identification - Initiator
   IDr         Identification - Responder
   KE          Key Exchange
   Ni, Nr      Nonce
   N           Notify
   SA          Security Association
   SK          Encrypted and Authenticated

   TSi         Traffic Selector - Initiator
   TSr         Traffic Selector - Responder
   V           Vendor ID
```

각 페이로드의 내용에 대한 자세한 내용은 섹션 3에 설명되어 있습니다. 선택적으로 나타날 수 있는 페이로드는 \[CERTREQ\]와 같이 괄호 안에 표시됩니다. 이는 인증서 요청 페이로드가 선택적으로 포함될 수 있음을 나타냅니다.

초기 교환은 다음과 같습니다.

```text
   Initiator                         Responder
   -------------------------------------------------------------------
   HDR, SAi1, KEi, Ni  -->
```

HDR에는 SPI\(보안 매개변수 색인\), 버전 번호, 교환 유형, 메시지 ID 및 다양한 종류의 플래그가 포함되어 있습니다. SAi1 페이로드에는 개시자가 IKE SA에 대해 지원하는 암호화 알고리즘이 명시되어 있습니다. KE 페이로드는 개시자의 Diffie-Hellman 값을 보냅니다. Ni는 개시자의 nonce입니다.

```text
                                <--  HDR, SAr1, KEr, Nr, [CERTREQ]
```

응답자는 개시자가 제공한 선택 사항 중에서 암호화 제품군을 선택하고 해당 선택을 SAr1 페이로드에 표현하고 KEr 페이로드와의 Diffie-Hellman 교환을 완료한 다음 Nr 페이로드에서 nonce를 보냅니다.

협상의 이 시점에서 각 당사자는 SKEYSEED\(섹션 2.14 참조\)라는 수량을 생성할 수 있으며, 여기에서 해당 IKE SA에 대한 모든 키가 파생됩니다. 다음 메시지는 메시지 헤더를 제외하고 전체적으로 암호화되고 무결성이 보호됩니다. 암호화 및 무결성 보호에 사용되는 키는 SKEYSEED에서 파생되며 SK\_e\(암호화\) 및 SK\_a\(인증, 즉 무결성 보호\)로 알려져 있습니다. 키 파생에 대한 자세한 내용은 섹션 2.13 및 2.14를 참조하세요. 각 방향에 대해 별도의 SK\_e 및 SK\_a가 계산됩니다. IKE SA 보호를 위해 Diffie-Hellman 값에서 파생된 키 SK\_e 및 SK\_a 외에도 다른 수량 SK\_d가 파생되어 하위 SA에 대한 추가 키 자료 파생에 사용됩니다. SK { ... } 표기는 해당 페이로드가 해당 방향의 SK\_e 및 SK\_a를 사용하여 암호화되고 무결성이 보호됨을 나타냅니다.

```text
   HDR, SK {IDi, [CERT,] [CERTREQ,]
       [IDr,] AUTH, SAi2,
       TSi, TSr}  -->
```

개시자는 IDi 페이로드로 자신의 신원을 확인하고 IDi에 해당하는 비밀에 대한 지식을 증명하며 무결성은 AUTH 페이로드를 사용하여 첫 번째 메시지의 콘텐츠를 보호합니다\(섹션 2.15 참조\). 또한 CERT 페이로드의 인증서와 CERTREQ 페이로드의 트러스트 앵커 목록을 보낼 수도 있습니다. CERT 페이로드가 포함된 경우 제공된 첫 번째 인증서에는 AUTH 필드를 확인하는 데 사용되는 공개 키가 포함되어야 합니다.\(MUST\)

선택적 페이로드 IDr을 사용하면 개시자는 응답자의 ID 중 어느 것과 통신할지 지정할 수 있습니다. 이는 응답자가 실행 중인 머신이 동일한 IP 주소에서 여러 ID를 호스팅할 때 유용합니다. 개시자가 제안한 IDr이 응답자가 승인할 수 없는 경우 응답자는 다른 IDr을 사용하여 교환을 완료할 수 있습니다. 개시자가 응답자가 요청한 것과 다른 IDr을 사용했다는 사실을 수락하지 않는 경우 개시자는 사실을 확인한 후 SA를 닫을 수 있습니다.

트래픽 선택기\(TSi 및 TSr\)는 섹션 2.9에서 논의됩니다.

개시자는 SAi2 페이로드를 사용하여 하위 SA 협상을 시작합니다. SAi2로 시작하는 최종 필드는 CREATE\_CHILD\_SA 교환 설명에 설명되어 있습니다.

```text
                                <--  HDR, SK {IDr, [CERT,] AUTH,
                                         SAr2, TSi, TSr}
```

응답자는 IDr 페이로드로 자신의 신원을 확인하고, 선택적으로 하나 이상의 인증서\(먼저 나열된 AUTH를 확인하는 데 사용되는 공개 키가 포함된 인증서와 함께\)를 보내고, 신원을 인증하고 AUTH 페이로드로 두 번째 메시지의 무결성을 보호합니다. CREATE\_CHILD\_SA 교환에서 아래에 설명된 추가 필드를 사용하여 하위 SA 협상을 완료합니다. IKE\_AUTH 교환의 양 당사자는 모든 서명과 메시지 인증 코드\(MAC\)가 올바르게 계산되었는지 확인해야 합니다. 어느 쪽이든 인증을 위해 공유 비밀을 사용하는 경우 ID 페이로드의 이름은 AUTH 페이로드를 생성하는 데 사용된 키와 일치해야 합니다.\(MUST, MUST\)

개시자는 IKE\_SA\_INIT에 Diffie-Hellman 값을 보내기 때문에 응답자가 지원되는 그룹 목록에서 선택할 Diffie-Hellman 그룹을 추측해야 합니다. 개시자가 잘못 추측하면 응답자는 선택한 그룹을 나타내는 INVALID\_KE\_PAYLOAD 유형의 알림 페이로드로 응답합니다. 이 경우 개시자는 수정된 Diffie-Hellman 그룹을 사용하여 IKE\_SA\_INIT를 재시도해야 합니다. 개시자는 거부 때문에 허용 가능한 전체 암호화 제품군 세트를 다시 제안해야 합니다.\(MUST, MUST\)

메시지가 인증되지 않았으며 그렇지 않은 경우 적극적인 공격자는 엔드포인트를 속여 둘 다 선호하는 강력한 제품군보다 약한 제품군을 협상하도록 할 수 있습니다.

어떤 이유로 IKE\_AUTH 교환 중에 하위 SA 생성이 실패하는 경우에도 IKE SA는 평소대로 생성됩니다. IKE SA 설정을 방해하지 않는 IKE\_AUTH 교환의 알림 메시지 유형 목록에는 최소한 NO\_PROPOSAL\_CHOSEN, TS\_UNACCEPTABLE, SINGLE\_PAIR\_REQUIRED, INTERNAL\_ADDRESS\_FAILURE 및 FAILED\_CP\_REQUIRED가 포함됩니다.\(MUST\)

실패가 IKE SA 생성과 관련된 경우\(예: AUTHENTICATION\_FAILED 알림 오류 메시지가 반환됨\) IKE SA가 생성되지 않습니다. IKE\_AUTH 메시지는 암호화되고 무결성이 보호되지만 이 알림 오류 메시지를 받은 피어가 아직 다른 쪽 끝을 인증하지 않은 경우\(또는 피어가 어떤 이유로 다른 쪽 끝을 인증하지 못한 경우\) 정보를 다음과 같이 처리해야 합니다. 주의. 보다 정확하게는 MAC이 올바르게 검증한다고 가정하면 오류 알림 메시지의 보낸 사람은 IKE\_SA\_INIT 교환의 응답자로 알려지지만 보낸 사람의 신원은 확인할 수 없습니다.

IKE\_AUTH 메시지에는 KEi/KEr 또는 Ni/Nr 페이로드가 포함되어 있지 않습니다. 따라서 IKE\_AUTH 교환의 SA 페이로드에는 NONE 이외의 값을 가진 변환 유형 4\(Diffie-Hellman 그룹\)가 포함될 수 없습니다. 구현에서는 NONE 값을 보내는 대신 전체 변환 하위 구조를 생략해야 합니다\(SHOULD\).\(SHOULD\)

---
### **1.3.  The CREATE_CHILD_SA Exchange**

CREATE\_CHILD\_SA 교환은 새로운 하위 SA를 생성하고 IKE SA와 하위 SA를 모두 다시 입력하는 데 사용됩니다. 이 교환은 단일 요청/응답 쌍으로 구성되며 해당 기능 중 일부는 IKEv1에서 2단계 교환이라고 합니다. 초기 교환이 완료된 후 IKE SA의 한쪽 끝에서 시작될 수 있습니다.\(MAY\)

SA는 새 SA를 생성한 다음 이전 SA를 삭제하여 키를 다시 입력합니다. 이 섹션에서는 키 재생성의 첫 번째 부분인 새 SA 생성에 대해 설명합니다. 섹션 2.8에서는 기존 SA에서 새 SA로 트래픽을 이동하고 기존 SA를 삭제하는 등 키 재생성 메커니즘을 다룹니다. 키 재설정의 전체 프로세스를 이해하려면 두 섹션을 함께 읽어야 합니다.

어느 끝점이든 CREATE\_CHILD\_SA 교환을 시작할 수 있으므로 이 섹션에서 개시자라는 용어는 이 교환을 시작하는 끝점을 나타냅니다. 구현은 IKE SA 내의 모든 CREATE\_CHILD\_SA 요청을 거부할 수 있습니다.\(MAY\)

CREATE\_CHILD\_SA 요청은 선택적으로 Child SA에 대한 순방향 비밀성을 더욱 강력하게 보장하기 위해 추가 Diffie-Hellman 교환을 위한 KE 페이로드를 포함할 수 있습니다. 하위 SA의 키 자료는 IKE SA 설정 중에 설정된 SK\_d, CREATE\_CHILD\_SA 교환 중에 교환된 nonce 및 Diffie-Hellman 값\(KE 페이로드가 CREATE\_CHILD\_SA 교환에 포함된 경우\)의 함수입니다.\(MAY\)

CREATE\_CHILD\_SA 교환에 KEi 페이로드가 포함된 경우 SA 제안 중 적어도 하나에는 KEi의 Diffie-Hellman 그룹이 포함되어야 합니다. KEi의 Diffie-Hellman 그룹은 개시자가 응답자가 수락할 것으로 기대하는 그룹의 요소여야 합니다\(추가 Diffie-Hellman 그룹이 제안될 수 있음\). 응답자가 다른 Diffie-Hellman 그룹\(NONE 제외\)을 사용하여 제안을 선택하는 경우 응답자는 요청을 거부하고 INVALID\_KE\_PAYLOAD 알림 페이로드에 선호하는 Diffie-Hellman 그룹을 표시해야 합니다. 이 알림과 관련된 두 개의 옥텟 데이터가 있습니다. 즉, 빅 엔디안 순서로 허용되는 Diffie-Hellman 그룹 번호입니다. 이러한 거부의 경우 CREATE\_CHILD\_SA 교환이 실패하고 개시자는 응답자가 INVALID\_KE\_PAYLOAD 알림 페이로드에 제공한 그룹의 Diffie-Hellman 제안 및 KEi를 사용하여 교환을 다시 시도할 것입니다.\(MUST, MUST, MUST\)

응답자는 이 IKE SA에서 더 이상 하위 SA를 수락할 의사가 없기 때문에 CREATE\_CHILD\_SA 요청을 수락할 수 없음을 나타내기 위해 NO\_ADDITIONAL\_SAS 알림을 보냅니다. 이 알림은 IKE SA 키 갱신을 거부하는 데에도 사용할 수 있습니다. 일부 최소 구현에서는 초기 IKE 교환 컨텍스트에서 단일 하위 SA 설정만 허용하고 더 추가하려는 후속 시도를 거부할 수 있습니다.

---
#### **1.3.1.  Creating New Child SAs with the CREATE_CHILD_SA Exchange**

CREATE\_CHILD\_SA 요청을 보내 하위 SA를 생성할 수 있습니다. 새 하위 SA를 생성하기 위한 CREATE\_CHILD\_SA 요청은 다음과 같습니다.

```text
   Initiator                         Responder
   -------------------------------------------------------------------
   HDR, SK {SA, Ni, [KEi,]
              TSi, TSr}  -->
```

개시자는 SA 페이로드의 SA 제안, Ni 페이로드의 nonce, 선택적으로 KEi 페이로드의 Diffie-Hellman 값, TSi 및 TSr 페이로드의 제안된 하위 SA에 대해 제안된 트래픽 선택기를 보냅니다.

새 하위 SA를 생성하기 위한 CREATE\_CHILD\_SA 응답은 다음과 같습니다.

```text
                                <--  HDR, SK {SA, Nr, [KEr,]

                                         TSi, TSr}
```

응답자는 KEi가 요청 및 선택된 암호화 제품군에 포함된 경우 SA 페이로드의 수락된 제안, Nr 페이로드의 nonce, KEr 페이로드의 Diffie-Hellman 값으로 응답합니다\(동일한 메시지 ID를 사용하여 응답\). 해당 그룹이 포함됩니다.

해당 SA에서 전송될 트래픽에 대한 트래픽 선택기는 응답의 TS 페이로드에 지정되며, 이는 하위 SA 개시자가 제안한 것의 하위 집합일 수 있습니다.

USE\_TRANSPORT\_MODE 알림은 하위 SA를 요청하는 SA 페이로드도 포함하는 요청 메시지에 포함될 수 있습니다. 생성된 SA에 대해 하위 SA가 터널 모드가 아닌 전송 모드를 사용하도록 요청합니다. 요청이 수락되면 응답에는 USE\_TRANSPORT\_MODE 유형의 알림도 포함되어야 합니다. 응답자가 요청을 거부하면 하위 SA가 터널 모드로 설정됩니다. 개시자가 이를 받아들일 수 없는 경우 개시자는 SA를 삭제해야 합니다. 참고: 이 옵션을 사용하여 전송 모드를 협상하는 경우를 제외하고 모든 하위 SA는 터널 모드를 사용합니다.\(MAY, MUST, MUST\)

ESP\_TFC\_PADDING\_NOT\_SUPPORTED 알림은 송신 엔드포인트가 협상 중인 하위 SA에 대한 TFC\(트래픽 흐름 기밀성\) 패딩이 포함된 패킷을 허용하지 않을 것이라고 주장합니다. 두 엔드포인트 모두 TFC 패딩을 허용하지 않는 경우 이 알림은 요청과 응답 모두에 포함됩니다. 이 알림이 메시지 중 하나에만 포함되어 있으면 TFC 패딩이 다른 방향으로 계속 전송될 수 있습니다.

NON\_FIRST\_FRAGMENTS\_ALSO 알림은 조각화 제어에 사용됩니다. 자세한 설명은 \[IPSECARCH\]를 참조하세요. 어느 쪽이든 먼저 전송하기 전에 두 당사자 모두 첫 번째가 아닌 조각을 보내는 데 동의해야 합니다. SA를 제안하는 요청과 이를 수락하는 응답 모두에 NON\_FIRST\_FRAGMENTS\_ALSO 알림이 포함된 경우에만 활성화됩니다. 응답자가 첫 번째가 아닌 조각을 보내거나 받기를 원하지 않는 경우 응답에서 NON\_FIRST\_FRAGMENTS\_ALSO 알림만 생략하고 전체 하위 SA 생성을 거부하지는 않습니다.

섹션 2.22에서 다루는 IPCOMP\_SUPPORTED 알림도 교환에 포함될 수 있습니다.

하위 SA를 생성하려는 시도가 실패하더라도 IKE SA가 중단되어서는 안 됩니다. IKE SA를 설정하기 위해 수행한 작업을 잃을 이유가 없습니다. 하위 SA 생성이 실패할 경우 발생할 수 있는 오류 메시지 목록은 섹션 2.21을 참조하십시오.\(SHOULD NOT\)

---
#### **1.3.2.  Rekeying IKE SAs with the CREATE_CHILD_SA Exchange**

IKE SA 키 재생성을 위한 CREATE\_CHILD\_SA 요청은 다음과 같습니다.

```text
   Initiator                         Responder
   -------------------------------------------------------------------
   HDR, SK {SA, Ni, KEi} -->
```

개시자는 SA 페이로드의 SA 제안, Ni 페이로드의 nonce, KEi 페이로드의 Diffie-Hellman 값을 보냅니다. KEi 페이로드가 포함되어야 합니다. SA 페이로드의 SPI 필드에 새로운 개시자 SPI가 제공됩니다. 피어가 IKE SA 키 재설정 요청을 수신하거나 IKE SA 키 재설정 요청을 전송하면 키 재설정 중인 IKE SA에서 새로운 CREATE\_CHILD\_SA 교환을 시작해서는 안 됩니다.\(MUST, SHOULD NOT\)

IKE SA 키 재생성에 대한 CREATE\_CHILD\_SA 응답은 다음과 같습니다.

```text
                                <--  HDR, SK {SA, Nr, KEr}
```

응답자는 선택한 암호화 제품군에 해당 그룹이 포함되어 있는 경우 SA 페이로드의 수락된 제안, Nr 페이로드의 nonce, Ker 페이로드의 Diffie-Hellman 값으로 응답합니다\(응답에 동일한 메시지 ID 사용\). SA 페이로드의 SPI 필드에 새로운 응답자 SPI가 제공됩니다.

새로운 IKE SA의 메시지 카운터는 이전 IKE SA의 내용에 관계없이 0으로 설정됩니다. 새 IKE SA의 양쪽에서 보내는 첫 번째 IKE 요청의 메시지 ID는 0입니다. 이전 IKE SA는 번호 지정을 유지하므로 추가 요청\(예: IKE SA 삭제\)에는 연속 번호가 지정됩니다. 새로운 IKE SA의 창 크기도 1로 재설정되었으며, 이 키 재설정 교환의 개시자는 새 IKE SA의 새로운 "원본 개시자"입니다.

섹션 2.18에서는 IKE SA 키 재입력에 대해서도 자세히 다루고 있습니다.

---
#### **1.3.3.  Rekeying Child SAs with the CREATE_CHILD_SA Exchange**

하위 SA 키 재생성을 위한 CREATE\_CHILD\_SA 요청은 다음과 같습니다.

```text
   Initiator                         Responder
   -------------------------------------------------------------------
   HDR, SK {N(REKEY_SA), SA, Ni, [KEi,]
       TSi, TSr}   -->
```

개시자는 SA 페이로드의 SA 제안, Ni 페이로드의 nonce, 선택적으로 KEi 페이로드의 Diffie-Hellman 값, TSi 및 TSr 페이로드의 제안된 하위 SA에 대해 제안된 트래픽 선택기를 보냅니다.

섹션 1.3.1에 설명된 알림은 키 재설정 교환을 통해 전송될 수도 있습니다. 일반적으로 이는 원래 교환에 사용된 것과 동일한 알림입니다. 예를 들어 전송 모드 SA를 다시 입력할 때 USE\_TRANSPORT\_MODE 알림이 사용됩니다.

교환의 목적이 기존 ESP 또는 AH SA를 교체하는 것이라면 REKEY\_SA 알림은 CREATE\_CHILD\_SA 교환에 포함되어야 합니다. 키를 다시 입력하는 SA는 알림 페이로드의 SPI 필드로 식별됩니다. 이는 교환 개시자가 인바운드 ESP 또는 AH 패킷에서 기대하는 SPI입니다. 이 알림 메시지 유형과 연결된 데이터가 없습니다. REKEY\_SA 알림의 프로토콜 ID 필드는 키를 다시 입력하는 SA의 프로토콜과 일치하도록 설정됩니다\(예: ESP의 경우 3, AH의 경우 2\).\(MUST\)

하위 SA 키를 다시 입력하기 위한 CREATE\_CHILD\_SA 응답은 다음과 같습니다.

```text
                                <--  HDR, SK {SA, Nr, [KEr,]
                                         TSi, TSr}
```

응답자는 KEi가 요청 및 선택된 암호화 제품군에 포함된 경우 SA 페이로드의 수락된 제안, Nr 페이로드의 nonce, KEr 페이로드의 Diffie-Hellman 값으로 응답합니다\(동일한 메시지 ID를 사용하여 응답\). 해당 그룹이 포함됩니다.

해당 SA에서 전송될 트래픽에 대한 트래픽 선택기는 응답의 TS 페이로드에 지정되며, 이는 하위 SA 개시자가 제안한 것의 하위 집합일 수 있습니다.

---
### **1.4.  The INFORMATIONAL Exchange**

IKE SA 작동 중 다양한 지점에서 피어는 특정 이벤트의 오류 또는 알림과 관련된 제어 메시지를 서로에게 전달하기를 원할 수 있습니다. 이를 달성하기 위해 IKE는 INFORMATIONAL 교환을 정의합니다. 정보 교환은 초기 교환 이후에만 발생해야 하며 협상된 키를 사용하여 암호화 방식으로 보호됩니다. 교환이 아닌 일부 정보 메시지는 IKE SA의 컨텍스트 외부로 전송될 수 있습니다. 섹션 2.21에서는 오류 메시지도 자세히 다루고 있습니다.\(MUST\)

IKE SA와 관련된 제어 메시지는 해당 IKE SA 아래에서 전송되어야 합니다. 하위 SA와 관련된 제어 메시지는 이를 생성한 IKE SA\(또는 IKE SA가 키를 다시 입력한 경우 그 후속\)의 보호 하에 전송되어야 합니다.\(MUST, MUST\)

정보 교환의 메시지에는 0개 이상의 알림, 삭제 및 구성 페이로드가 포함되어 있습니다. 정보 교환 요청의 수신자는 일부 응답을 보내야 합니다. 그렇지 않으면 보낸 사람은 메시지가 네트워크에서 손실되었다고 가정하고\(MUST\)

다시 전송해 보세요. 해당 응답은 빈 메시지일 수 있습니다. INFORMATIONAL 교환의 요청 메시지에는 페이로드가 포함되어 있지 않을 수도 있습니다. 이는 엔드포인트가 다른 엔드포인트에게 자신이 살아 있는지 확인하도록 요청할 수 있는 예상되는 방식입니다.\(MAY, MAY\)

INFORMATIONAL 교환은 다음과 같이 정의됩니다.

```text
   Initiator                         Responder
   -------------------------------------------------------------------
   HDR, SK {[N,] [D,]
       [CP,] ...}  -->
                                <--  HDR, SK {[N,] [D,]
                                         [CP,] ...}
```

INFORMATIONAL 교환 처리는 구성 요소 페이로드에 따라 결정됩니다.

---
#### **1.4.1.  Deleting an SA with INFORMATIONAL Exchanges**

ESP와 AH SA는 항상 쌍으로 존재하며 각 방향에 하나의 SA가 있습니다. SA가 닫히면 쌍의 두 구성원 모두 닫혀야 합니다\(즉, 삭제되어야 합니다\). 각 엔드포인트는 들어오는 SA를 닫아야 하며 다른 엔드포인트가 각 쌍의 다른 SA를 ​​닫을 수 있도록 허용해야 합니다. SA를 삭제하려면 삭제될 SA의 SPI\(인바운드 패킷 헤더에서 예상되는 대로\)를 나열하는 하나 이상의 삭제 페이로드가 포함된 정보 교환이 전송됩니다. 수신자는 지정된 SA를 종료해야 합니다. 단일 메시지로 SA의 양면에 대한 삭제 페이로드를 보내지 않는다는 점에 유의하십시오. 동시에 삭제할 SA가 많은 경우 INFORMATIONAL 교환에 각 SA 쌍의 인바운드 절반에 대한 삭제 페이로드가 포함됩니다.\(MUST, MUST, MUST\)

일반적으로 INFORMATIONAL 교환의 응답에는 반대 방향으로 진행되는 쌍을 이루는 SA에 대한 삭제 페이로드가 포함됩니다. 한 가지 예외가 있습니다. 우연히 SA 세트의 양쪽 끝이 독립적으로 SA를 종료하기로 결정한 경우 각각은 삭제 페이로드를 보낼 수 있으며 두 요청은 네트워크에서 교차될 수 있습니다. 노드가 이미 삭제 요청을 발행한 SA에 대한 삭제 요청을 수신하는 경우, 요청을 처리하는 동안 나가는 SA를 삭제하고 응답을 처리하는 동안 들어오는 SA를 삭제해야 합니다. 이 경우 응답에는 삭제된 SA에 대한 삭제 페이로드가 포함되어서는 안 됩니다. 왜냐하면 그렇게 하면 중복 삭제가 발생하고 이론적으로 잘못된 SA가 삭제될 수 있기 때문입니다.\(MUST, MUST NOT\)

ESP 및 AH SA와 마찬가지로 IKE SA도 INFORMATIONAL 교환을 전송하여 삭제됩니다. IKE SA를 삭제하면 해당 SA에서 협상된 나머지 하위 SA가 암시적으로 닫힙니다. IKE SA를 삭제하는 요청에 대한 응답은 빈 INFORMATIONAL 응답입니다.

반쯤 닫힌 ESP 또는 AH 연결은 비정상적이며 감사 기능이 있는 노드는 지속되는 경우 해당 연결의 존재를 감사해야 할 것입니다. 이 사양은 기간을 지정하지 않으므로 대기 시간을 결정하는 것은 개별 엔드포인트에 달려 있습니다. 노드는 반쯤 닫힌 연결에서 들어오는 데이터 수락을 거부할 수 있지만 일방적으로 연결을 닫고 SPI를 재사용해서는 안 됩니다. 연결 상태가 충분히 엉망이 되면 노드는 위에서 설명한 대로 IKE SA를 닫을 수 있습니다. 그런 다음 새 IKE SA 아래의 깨끗한 기반에 필요한 SA를 재구축할 수 있습니다.\(MUST NOT, MAY\)

---
### **1.5.  Informational Messages outside of an IKE SA**

노드가 처리할 수 없는 패킷을 수신하는 경우가 있지만 보낸 사람에게 이 상황을 알리고 싶을 수도 있습니다.

o ESP 또는 AH 패킷이 인식할 수 없는 SPI와 함께 도착하는 경우. 이는 수신 노드가 최근 충돌하여 상태를 잃었거나 기타 시스템 오작동이나 공격으로 인해 발생할 수 있습니다.

o 암호화된 IKE 요청 패킷이 인식할 수 없는 IKE SPI와 함께 포트 500 또는 4500에 도착하는 경우. 이는 수신 노드가 최근 충돌하여 상태를 잃었거나 기타 시스템 오작동이나 공격으로 인해 발생할 수 있습니다.

o IKE 요청 패킷이 구현에서 지원하는 것보다 더 높은 주 버전 번호로 도착하는 경우.

첫 번째 경우, 수신 노드에 패킷이 발생한 IP 주소에 대한 활성 IKE SA가 있는 경우 INFORMATIONAL 교환에서 해당 IKE SA를 통해 잘못된 패킷에 대한 INVALID\_SPI 알림을 보낼 수 있습니다. 알림 데이터에는 잘못된 패킷의 SPI가 포함되어 있습니다. 이 알림을 받는 사람은 SPI가 AH용인지 ESP용인지 알 수 없지만 많은 경우 SPI가 둘에 대해 다르기 때문에 이는 중요하지 않습니다. 적합한 IKE SA가 존재하지 않는 경우, 노드는 패킷이 UDP\(UDP 캡슐화 ESP 또는 AH\)인 경우 소스 UDP 포트를 대상 포트로 사용하여 암호화 보호 없이 정보 메시지를 소스 IP 주소로 보낼 수 있습니다. 이 경우 수신자는 무언가 잘못되었을 수 있다는 힌트로만 사용해야 합니다\(쉽게 위조될 수 있기 때문입니다\). 이 메시지는 INFORMATIONAL 교환의 일부가 아니며, 수신 노드는 이에 응답하면 안 됩니다. 그렇게 하면 메시지 루프가 발생할 수 있기 때문입니다. 메시지는 다음과 같이 구성됩니다. 해당 알림 수신자에게 의미 있는 IKE SPI 값이 없습니다. 0 값이나 임의 값을 사용하는 것은 모두 허용됩니다. 이는 0 IKE 개시자 SPI를 금지하는 섹션 3.1의 규칙에 대한 예외입니다. 개시자\(MAY, MAY, MUST NOT\)

플래그는 1로 설정되고 응답 플래그는 0으로 설정되며 버전 플래그는 일반적인 방식으로 설정됩니다. 이러한 플래그는 섹션 3.1에 설명되어 있습니다.

두 번째 및 세 번째 경우 메시지는 항상 암호화 보호 없이\(IKE SA 외부\) 전송되며 INVALID\_IKE\_SPI 또는 INVALID\_MAJOR\_VERSION 알림\(알림 데이터 없음\)을 포함합니다. 메시지는 응답 메시지이므로 동일한 IKE SPI와 함께 제공된 IP 주소 및 포트로 전송되며 메시지 ID 및 교환 유형이 요청에서 복사됩니다. 응답 플래그는 1로 설정되고 버전 플래그는 일반적인 방식으로 설정됩니다.

---
### **1.6.  Requirements Terminology**

이 문서의 기본 용어\(예: 보안 협회 또는 SA\)에 대한 정의는 \[IPSECARCH\]에서 찾을 수 있습니다. IKEv2의 일부는 이 문서의 다양한 섹션에 설명된 대로 \[IPSECARCH\]의 일부 처리 규칙에 의존한다는 점에 유의해야 합니다.

이 문서의 핵심 단어 "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY" 및 "OPTIONAL"은 다음과 같습니다. \[MUSTSHOULD\]에 설명된 대로 해석되어야 합니다.\(MUST NOT\)

---
### **1.7.  Significant Differences between RFC 4306 and RFC 5996**

이 문서에는 IKEv2\[IKEV2\]에 대한 설명과 확대 내용이 포함되어 있습니다. 많은 설명은 \[Clarif\]를 기반으로 합니다. 해당 문서에 나열된 변경 사항은 IPsec 작업 그룹에서 논의되었으며 작업 그룹이 해체된 후 IPsec 메일링 목록에서 논의되었습니다. 해당 문서에는 IKEv2에서 명확하지 않은 영역에 대한 자세한 설명이 포함되어 있으므로 IKEv2 구현자에게 유용합니다.

이 문서에 설명된 프로토콜은 RFC 4306에서 사용된 것과 동일한 주 버전 번호\(2\)와 부 버전 번호\(0\)를 유지합니다. 즉, 버전 번호는 RFC 4306에서 변경되지 \*않습니다\*. 여기에 나열된 내용은 이 문서 발행 시 이미 배포된 RFC 4306 구현에 영향을 미치지 않을 것으로 예상됩니다.

이 문서는 \[IKEV2\]보다 그림과 참조를 좀 더 일관되게 만듭니다.

IKEv2 개발자는 RFC 4306의 SHOULD 수준 요구 사항이 요구 사항을 따르지 않아도 되는 시기를 밝히지 않는다는 점에서 종종 불분명하다는 점을 지적했습니다. 그들은 또한 상호 운용성과 관련되지 않은 MUST 수준의 요구 사항이 있다는 점에 주목했습니다. 이것\(SHOULD, MUST\)

문서에는 이러한 요구 사항 중 일부에 대한 자세한 설명이 있습니다. 대문자로 표시되지 않은 모든 단어 사용은 이제 \[MUSTSHOULD\]의 상호 운용성 의미가 아니라 일반적인 영어 의미를 의미해야 합니다.\(MUST\)

IKEv2\(및 IKEv1\) 개발자는 RFC 4306 섹션 3.10.1의 코드 표에 많은 자료가 있다는 점을 지적했습니다. 이로 인해 구현자가 문서 본문에 필요한 모든 정보를 갖지 못하게 됩니다. 해당 표의 자료 대부분은 문서 본문의 관련 부분으로 이동되었습니다.

이 문서에서는 AH 및 ESP 중첩에 대한 논의를 삭제합니다. 이는 RFC 4306과 RFC 4301 완료 사이의 지연으로 인해 발생한 RFC 4306의 실수였습니다. 기본적으로 IKEv2는 RFC 4301을 기반으로 하며 RFC 2401의 일부인 "SA 번들"을 포함하지 않습니다. 단일 패킷은 통과할 수 있지만 IPsec을 여러 번 처리하는 경우 이러한 각 패스는 별도의 SA를 사용하며 패스는 전달 테이블에 의해 조정됩니다. IKEv2에서는 이러한 각 SA가 별도의 CREATE\_CHILD\_SA 교환을 사용하여 생성되어야 합니다.

INTERNAL\_ADDRESS\_EXPIRY 구성 속성 구현에 문제가 많기 때문에 이 문서에서는 해당 속성에 대한 논의를 삭제합니다. 이 문서를 준수하는 구현은 INTERNAL\_ADDRESS\_EXPIRY의 이전 값인 구성 속성 유형 5를 갖는 제안을 무시해야 합니다\(MUST\). 이 문서에서는 구성 속성에서 INTERNAL\_IP6\_NBNS도 제거했습니다.\(MUST\)

이 문서는 페이로드가 "올바른" 순서가 아닌 메시지 거부에 대한 허용을 제거합니다. 이제 구현은 이를 거부해서는 안 됩니다. 이는 페이로드 명령이 설명되는 명확성이 부족하기 때문입니다.\(MUST NOT\)

IANA 레지스트리에 포함된 RFC 4306의 항목 목록은 실제로 RFC 4306에 정의된 항목만 포함하도록 잘렸습니다. 또한 이러한 목록 중 상당수는 이제 개발자가 실제로 살펴봐야 하는 매우 중요한 지침 앞에 표시됩니다. RFC 4306 이후 새로운 항목이 추가되었기 때문에 개발 당시 IANA 레지스트리를 참조하세요.

이 문서에서는 당시 협상 상태에 따라 알림이 암호화되어 전송되거나 전송되지 않는 경우에 대한 설명을 추가합니다.

이 문서에서는 결합 모드 암호를 협상하는 방법에 대해 자세히 설명합니다.

섹션 1.3.2에서 "KEi 페이로드가 포함되어야 합니다"가 "KEi 페이로드가 포함되어야 합니다"로 변경되었습니다. 이로 인해 섹션 2.18도 변경되었습니다.\(MUST\)

섹션 2.1에는 개시자의 SPI 및/또는 IP를 사용하여 이것이 "반개방" IKE SA인지 아니면 새로운 요청인지 구별하는 방법을 다루는 새로운 자료가 있습니다.

이 문서에서는 섹션 2.5의 중요한 플래그 사용을 명확히 설명합니다.

섹션 2.8에서 "키를 다시 입력할 때 새 하위 SA는 이전 것과 다른 트래픽 선택기 및 알고리즘을 가질 수 있습니다."가 "키를 다시 입력할 때 새 하위 SA는 이전 것과 다른 트래픽 선택기 및 알고리즘을 가져서는 안 됩니다."로 변경되었습니다. 예전 것".\(SHOULD NOT\)

새로운 섹션 2.8.2에서는 동시 IKE SA 키 재입력에 대해 다룹니다.

이 문서에서는 IKEv2와 함께 사용되는 모든 PRF\(의사 난수 함수\)가 가변 크기 키를 사용해야 한다는 제한 사항을 섹션 2.13에 추가합니다. 고정 크기 키가 있는 표준화된 PRF가 없었기 때문에 이는 구현에 영향을 주지 않습니다.\(MUST\)

섹션 2.18에서는 IKE\_SA 키를 다시 입력할 때 Diffie-Hellman 교환을 수행해야 합니다. 이론적으로 RFC 4306은 Diffie-Hellman 교환이 선택 사항인 정책을 허용했지만 이는 IKE\_SA 키를 다시 입력할 때 유용하거나 적절하지 않았습니다.

섹션 2.21은 오류 응답이 필요한 다양한 경우와 이에 대한 적절한 응답을 다루기 위해 크게 확장되었습니다.

섹션 2.23에서는 NAT 통과에서 이제 UDP로 캡슐화된 IPsec 패킷과 UDP로 캡슐화되지 않은 IPsec 패킷을 수신할 때 모두 이해해야 함을 명시했습니다.

전송 모드가 요청될 때 NAT 통과를 설명하기 위해 섹션 2.23.1을 추가했습니다.

SA를 삭제 및/또는 키를 다시 입력할 때 타이밍 충돌이 있을 때 조치를 취하는 방법을 설명하기 위해 섹션 2.25를 추가했으며 두 개의 새로운 오류 알림\(TEMPORARY\_FAILURE 및 CHILD\_SA\_NOT\_FOUND\)이 정의되었습니다.

섹션 3.6에서 "구현은 해시 및 URL 조회를 위한 "http:" 구성표를 지원해야 합니다. 다른 URL 구성표의 동작은 현재 지정되지 않았으며 해당 구성표를 지정하는 문서가 없으면 이러한 구성표를 사용해서는 안 됩니다." 추가되었습니다.\(MUST, SHOULD NOT\)

섹션 3.15.3에는 IPv6 주소 구성과 관련된 새 문서에 대한 포인터가 추가되었습니다.

부록 C가 확장되고 명확해졌습니다.

---
### **1.8.  Differences between RFC 5996 and This Document**

이 문서의 상태가 인터넷 표준임을 요약 및 소개 섹션에서 명확히 했습니다.

새로운 섹션 2.9.2에서는 키 재생성의 트래픽 선택기를 다룹니다.

Diffie-Hellman 지수 재사용 시 RFC 6989에 대한 참조가 추가되었습니다\(섹션 2.12\).

0\(마지막\) 또는 2/3\(자세히\) 필드에 대해 제안 하위 구조 및 변환 하위 구조 헤더\(섹션 3.3.1 및 3.3.2\)에 "Last Substruc"라는 이름을 추가했습니다.

MODP\(Sophie Germain Modular Exponitionation\) 그룹이 아닌 그룹을 사용할 때 RFC 6989에 대한 참조를 추가했습니다\(섹션 3.3.2\).

식별 페이로드 섹션\(섹션 3.5\)에 RFC 4945에 대한 참조가 추가되었습니다.

섹션 3.6에서 원시 RSA 공개 키를 더 이상 사용하지 않습니다. 원시 공개 키에 대한 보다 일반적인 형식을 추가하는 새로운 작업이 진행 중입니다.

RFC 5996\(RFC Errata ID 2707 및 3036\)에 대한 정오표에 지정된 대로 섹션 3.6 및 3.10을 수정했습니다.

원시 RSA 키 사용 중단에 대한 IANA 고려 사항 섹션\(섹션 6\)에 메모를 추가하고 이전 콘텐츠\(RFC 5996 처리 중에 이미 수행됨\)를 제거했습니다. IANA가 이 문서를 가리키도록 RFC 5996에 대한 모든 참조를 업데이트해야 한다는 메모를 추가했습니다.

---
## **2.  IKE Protocol Details and Variations**

IKE는 일반적으로 UDP 포트 500에서 수신하고 전송하지만 IKE 메시지는 약간 다른 형식으로 UDP 포트 4500에서 수신될 수도 있습니다\(섹션 2.23 참조\). UDP는 데이터그램\(신뢰할 수 없는\) 프로토콜이므로 IKE에는 패킷 손실, 패킷 재생 및 패킷 위조를 포함한 전송 오류로부터의 복구가 정의에 포함됩니다. IKE는 \(1\) 일련의 재전송된 패킷 중 하나 이상이 시간 초과되기 전에 대상에 도달하는 한 작동하도록 설계되었습니다. \(2\) 채널이 위조 및 재생된 패킷으로 가득 차 있지 않으므로

두 엔드포인트의 네트워크 또는 CPU 용량을 모두 소모합니다. 이러한 최소 성능 요구 사항이 없더라도 IKE는 완전히 실패하도록 설계되었습니다\(마치 네트워크가 손상된 것처럼\).

IKEv2 메시지는 짧게 만들어졌지만 크기에 대한 상한선이 없는 구조\(특히 디지털 인증서\)가 포함되어 있으며 IKEv2 자체에는 대용량 메시지를 조각화하는 메커니즘이 없습니다. IP는 대용량 UDP 메시지의 조각화를 위한 메커니즘을 정의하지만 지원되는 최대 메시지 크기는 구현에 따라 다릅니다. 또한 IP 조각화를 사용하면 서비스 거부\(DoS\) 공격\[DOSUDPPROT\]에 대한 구현이 가능해집니다. 마지막으로 일부 NAT 및/또는 방화벽 구현에서는 IP 조각을 차단할 수 있습니다.

모든 IKEv2 구현은 최대 1280옥텟 길이의 IKE 메시지를 전송, 수신 및 처리할 수 있어야 하며\(MUST\) 최대 3000옥텟 길이의 메시지를 전송, 수신 및 처리할 수 있어야 합니다\(SHOULD\). IKEv2 구현은 지원되는 최대 UDP 메시지 크기를 인식해야 하며, 메시지가 최대값 미만으로 유지되는 경우 일부 인증서 또는 암호화 제품군 제안을 생략하여 메시지를 줄일 수 있습니다. 가능한 경우 교환에 인증서를 포함하는 대신 "해시 및 URL" 형식을 사용하면 대부분의 문제를 피할 수 있습니다. 그러나 구현 및 구성에서는 하위 SA가 설정된 후에만 URL 조회가 가능한 경우 재귀 문제로 인해 이 기술이 작동하지 않을 수 있다는 점을 명심해야 합니다.\(MUST, MAY\)

포트 4500에서 전송된 IKE 메시지를 포함하는 모든 패킷의 UDP 페이로드는 4개의 0이라는 접두사로 시작해야 합니다. 그렇지 않으면 수신자는 이를 처리하는 방법을 알 수 없습니다.\(MUST\)

---
### **2.1.  Use of Retransmission Timers**

IKE의 모든 메시지는 요청과 응답이라는 쌍으로 존재합니다. IKE SA 설정은 일반적으로 두 개의 교환으로 구성됩니다. IKE SA가 설정되면 보안 연결의 어느 쪽이든 언제든지 요청을 시작할 수 있으며 특정 순간에 "진행 중인" 많은 요청과 응답이 있을 수 있습니다. 그러나 각 메시지는 요청 또는 응답으로 표시되며, 각 교환에 대해 보안 연결의 한쪽 끝은 개시자이고 다른 쪽 끝은 응답자입니다.

모든 IKE 메시지 쌍에 대해 개시자는 시간 초과 시 재전송을 담당합니다. 응답자는 요청의 재전송을 수신하지 않는 한 응답을 절대 재전송해서는 안 됩니다. 이 경우 응답자는 응답의 재전송을 유발하는 경우를 제외하고는 재전송된 요청을 무시해야 합니다. 개시자는 해당 응답을 수신할 때까지 각 요청을 기억해야 합니다. 응답자는 각 응답을 기억해야 합니다.\(MUST, MUST, MUST, MUST\)

시퀀스 번호가 응답의 시퀀스 번호에 창 크기를 더한 값보다 크거나 같은 요청을 수신할 때까지\(섹션 2.3 참조\) 메모리를 절약하기 위해 응답자는 몇 분의 시간 초과 후에 응답을 잊을 수 있습니다. 응답자가 이미 응답을 잊어버린 재전송된 요청을 수신하는 경우 해당 요청을 무시해야 합니다\(예를 들어 새 응답 구성을 시도해서는 안 됩니다\).\(MUST\)

IKE는 신뢰할 수 있는 프로토콜입니다. 개시자는 해당 응답을 수신하거나 IKE SA가 실패했다고 간주할 때까지 요청을 재전송해야 합니다. 후자의 경우 개시자는 IKE SA 및 해당 IKE SA를 사용하여 협상된 모든 하위 SA와 관련된 모든 상태를 삭제합니다. 개시자로부터의 재전송은 원래 요청과 비트 단위로 동일해야 합니다. 즉, IKE 헤더\(IKE SA 개시자의 SPI 이후\)부터 시작하는 모든 항목은 비트 단위로 동일해야 합니다. 그 앞의 항목\(예: IP 및 UDP 헤더\)은 동일할 필요가 없습니다.\(MUST, MUST\)

IKE\_SA\_INIT 요청을 재전송하려면 특별한 처리가 필요합니다. 응답자가 IKE\_SA\_INIT 요청을 수신하면 패킷이 기존 "반 개방" IKE SA에 속하는 재전송인지\(응답자가 동일한 응답을 재전송하는 경우\) 아니면 새로운 요청\(이 경우 응답자는 새로운 IKE SA를 생성하고 새로운 응답을 보냅니다. 또는 IKE\_AUTH 요청이 이미 수신된 기존 IKE SA에 속합니다\(이 경우 응답자는 이를 무시합니다\).

단일 NAT 뒤의 서로 다른 두 피어가 동일한 개시자 SPI를 선택할 수 있기 때문에 개시자의 SPI 및/또는 IP 주소를 사용하여 이 세 가지 경우를 구별하는 것만으로는 충분하지 않습니다. 대신, 강력한 응답자는 전체 패킷, 해당 해시 또는 Ni 페이로드를 사용하여 IKE SA 조회를 수행합니다.

단방향 메시지의 재전송 정책은 일반 메시지의 재전송 정책과 다소 다릅니다. 승인이 전송되지 않기 때문에 단방향 메시지를 불필요하게 재전송할 이유가 없습니다. 이러한 메시지가 모두 오류라는 점을 고려하면 "불법" 패킷당 한 번만 메시지를 보내고 추가로 위반 패킷이 수신되는 경우에만 재전송하는 것이 합리적입니다. 그러나 그러한 오류 메시지의 재전송을 제한하는 것도 의미가 있습니다.

---
### **2.2.  Use of Sequence Numbers for Message ID**

모든 IKE 메시지에는 고정 헤더의 일부로 메시지 ID가 포함되어 있습니다. 이 메시지 ID는 요청과 응답을 일치시키고 메시지 재전송을 식별하는 데 사용됩니다. 메시지 재전송은 원본 메시지와 동일한 메시지 ID를 사용해야 합니다.\(MUST\)

메시지 ID는 32비트 수량으로, IKE\_SA\_INIT 메시지\(COOKIE 및 INVALID\_KE\_PAYLOAD와 같은 응답으로 인한 메시지 재시도 포함\)의 경우 0이며 이후 교환할 때마다 증가합니다. 따라서 IKE\_AUTH 메시지의 첫 번째 쌍은 ID 1을 갖고 두 번째\(EAP가 사용되는 경우\)는 2가 됩니다. IKE SA의 키를 다시 입력하면 메시지 ID가 새 IKE SA에서 0으로 재설정됩니다.

IKE 보안 연결의 각 끝점은 두 개의 "현재" 메시지 ID를 유지 관리합니다. 하나는 자신이 시작한 요청에 사용될 다음 ID와 다른 쪽 끝의 요청에서 볼 것으로 예상되는 다음 ID입니다. 이러한 카운터는 요청이 생성되고 수신될 때 증가합니다. 응답에는 항상 해당 요청과 동일한 메시지 ID가 포함됩니다. 즉, 초기 교환 후 각 정수 n은 원래 IKE 개시자의 n번째 요청, 해당 응답, 원래 IKE 응답자의 n번째 요청, 해당 응답 등 4개의 개별 메시지에서 메시지 ID로 나타날 수 있습니다. 두 끝에서 매우 다른 요청 수를 생성하는 경우 두 방향의 메시지 ID가 매우 다를 수 있습니다. 그러나 메시지 헤더의 개시자 및 응답 플래그가 4개 메시지 중 어느 메시지가 특정 메시지인지 지정하므로 메시지에는 모호성이 없습니다.

이 문서 전체에서 "개시자"는 설명된 교환을 시작한 당사자를 의미합니다. "원래 개시자"는 항상 현재 IKE SA를 생성한 교환을 시작한 당사자를 나타냅니다. 즉, "원래 응답자"가 IKE SA 키를 다시 입력하기 시작하면 해당 당사자가 새 IKE SA의 "원래 개시자"가 됩니다.

메시지 ID는 암호화되어 보호되며 메시지 재생을 방지합니다. 메시지 ID가 너무 커서 32비트에 맞지 않는 경우에는 IKE SA를 닫거나 키를 다시 입력해야 합니다.\(MUST\)

---
### **2.3.  Window Size for Overlapping Requests**

SET\_WINDOW\_SIZE 알림은 전송 엔드포인트가 여러 미해결 교환에 대한 상태를 유지할 수 있음을 확인하여 수신자가 첫 번째 응답을 받기 전에 여러 요청을 보낼 수 있도록 허용합니다. SET\_WINDOW\_SIZE 알림과 관련된 데이터는 길이가 4옥텟이어야 하며 보낸 사람이 보관하겠다고 약속한 메시지 수를 나타내는 빅 엔디안 표현을 포함해야 합니다. 창 크기는 초기 교환이 완료될 때까지 항상 1입니다.\(MUST\)

IKE 끝점은 더 큰 처리량을 허용하기 위해 피어가 여러 개의 미해결 메시지에 대한 상태를 유지할 준비가 되었음을 알리는 SET\_WINDOW\_SIZE 알림 메시지를 피어로부터 수신하지 않은 한 후속 메시지를 보내기 전에 각 메시지에 대한 응답을 기다려야 합니다.\(MUST\)

IKE SA가 설정된 후 IKE 처리량을 최대화하기 위해 IKE 끝점은 응답을 받기 전에 피어의 SET\_WINDOW\_SIZE에 설정된 제한까지 여러 요청을 발행할 수 있습니다. 이러한 요청은 네트워크를 통해 서로 전달될 수 있습니다. IKE 엔드포인트는 이러한 상황에서 교착 상태를 방지하기 위해 미해결 요청이 있는 동안 요청을 수락하고 처리할 준비를 해야 합니다. IKE 끝점은 요청이 처리되지 않은 동안 여러 요청을 수락하고 처리할 수도 있습니다.\(MAY, MUST\)

IKE 끝점은 전송된 IKE 요청에 대해 피어가 명시한 창 크기를 초과해서는 안 됩니다. 즉, 응답자가 창 크기가 N이라고 명시한 경우 개시자가 X를 요청해야 할 때 요청 X-N까지 모든 요청에 ​​대한 응답을 받을 때까지 기다려야 합니다. IKE 엔드포인트는 해당 응답을 수신할 때까지 보낸 각 요청의 복사본을 유지해야 합니다\(또는 정확하게 재생성할 수 있어야 합니다\). IKE 엔드포인트는 응답이 손실되고 개시자가 요청을 재전송하여 재전송을 요청하는 경우 선언된 창 크기와 동일한 이전 응답 수의 복사본을 유지하거나 정확하게 재생성할 수 있어야 합니다.\(MUST NOT, MUST, MUST, MUST\)

1보다 큰 창 크기를 지원하는 IKE 엔드포인트는 네트워크 오류 또는 패킷 재정렬 시 성능을 최대화하기 위해 들어오는 요청을 순서대로 처리할 수 있어야 합니다.

창 크기는 일반적으로 특정 구현의 \(구성 가능한\) 속성이며 혼잡 제어와 관련이 없습니다\(예를 들어 TCP의 창 크기와는 다름\). 특히 현재 적용되는 값보다 작은 값이 포함된 SET\_WINDOW\_SIZE 알림을 수신할 때 응답자가 수행해야 하는 작업은 정의되어 있지 않습니다. 따라서 현재 기존 IKE SA의 창 크기를 줄일 수 있는 방법은 없습니다. 늘릴 수만 있습니다. IKE SA 키를 다시 입력하면 새 IKE SA는 새 SET\_WINDOW\_SIZE 알림을 전송하여 명시적으로 증가할 때까지 창 크기 1로 시작합니다.

INVALID\_MESSAGE\_ID 알림은 지원되는 창 외부의 IKE 메시지 ID가 수신되면 전송됩니다. 이 알림 메시지는 응답으로 전송되어서는 안 됩니다. 잘못된 요청은 승인되어서는 안 됩니다. 대신, 4옥텟의 유효하지 않은 메시지 ID가 포함된 알림 데이터와의 정보 교환을 시작하여 상대방에게 알립니다. 이 알림을 보내는 것은 선택 사항이며 이 유형의 알림은 속도가 제한되어야 합니다.\(MUST NOT, MUST\)

---
### **2.4.  State Synchronization and Connection Timeouts**

IKE 끝점은 언제든지 IKE SA 및 해당 하위 SA 컬렉션과 관련된 모든 상태를 삭제할 수 있습니다. 이는 엔드포인트 충돌 및 재시작 시 예상되는 동작입니다. 엔드포인트가 실패하거나 상태를 다시 초기화하는 경우 다른 엔드포인트가 이러한 조건을 감지하고 폐기된 SA를 통해 패킷을 전송하여 블랙홀에 빠지게 함으로써 네트워크 대역폭을 계속 낭비하지 않는 것이 중요합니다.

INITIAL\_CONTACT 알림은 이 IKE SA가 인증된 ID 사이에서 현재 활성화된 유일한 IKE SA임을 확인합니다. 충돌 후 IKE SA가 설정될 때 전송될 수 있으며, 수신자는 이 정보를 사용하여 시간 초과를 기다리지 않고 동일한 인증된 ID에 대한 다른 IKE SA를 삭제할 수 있습니다. 이 알림은 복제될 수 있는 엔터티\(예: 사용자가 동시에 두 개의 원격 시스템에서 회사 방화벽에 연결할 수 있는 로밍 사용자의 자격 증명\)에 의해 전송되어서는 안 됩니다. INITIAL\_CONTACT 알림이 전송된 경우 이후에 별도의 교환이 아닌 첫 번째 IKE\_AUTH 요청 또는 응답에 포함되어야 합니다. 수신 당사자는 다른 메시지에서 이를 무시할 수 있습니다.\(MAY, MUST NOT, MUST\)

IKE는 네트워크의 DoS 공격에도 불구하고 작동하도록 설계되었으므로 엔드포인트는 라우팅 정보\(예: ICMP 메시지\) 또는 암호화 보호 없이 도착하는 IKE 메시지\(예: 알림 메시지\)를 기반으로 다른 엔드포인트가 실패했다고 결론을 내려서는 안 됩니다. 알 수 없는 SPI에 대해 불평\). 엔드포인트는 반복적인 연결 시도가 시간 초과 기간 동안 응답이 없거나 암호화로 보호된 INITIAL\_CONTACT 알림이 동일한 인증된 ID에 대한 다른 IKE SA에서 수신된 경우에만 다른 엔드포인트가 실패했다고 결론을 내려야 합니다. 엔드포인트는 라우팅 정보를 기반으로 다른 엔드포인트가 실패했다고 의심하고 다른 엔드포인트가 살아 있는지 확인하기 위한 요청을 시작해야 합니다. 상대방이 살아 있는지 확인하기 위해 IKE는 모든 IKE 요청과 마찬가지로 승인이 필요한 빈 INFORMATIONAL 요청을 지정합니다. IKE SA의 컨텍스트 내에서 "빈" 메시지는 IKE 헤더와 암호화된 헤더로 구성됩니다. 페이로드가 포함되지 않은 페이로드\). 암호화로 보호된\(신선한, 즉 재전송되지 않은\) 메시지가 최근 상대방으로부터 수신된 경우 보호되지 않은 알림 메시지는 무시될 수 있습니다. 구현 시 보호되지 않은 메시지를 기반으로 조치를 취하는 속도를 제한해야 합니다.\(MUST NOT, MUST, MAY, MUST\)

재시도 횟수와 시간 초과 길이는 상호 운용성에 영향을 주지 않으므로 이 사양에서는 다루지 않습니다. SA를 포기하기 전에 최소 몇 분 동안 메시지를 12회 이상 재전송하는 것이 좋습니다.

환경에 따라 다른 규칙이 필요할 수 있습니다. 좋은 네트워크 시민이 되려면 재전송 시간이 기하급수적으로 증가하여 네트워크 범람과 기존 혼잡 상황이 악화되는 것을 방지해야 합니다. IKE SA와 연결된 모든 SA에 나가는 트래픽만 있는 경우 블랙홀을 방지하려면 다른 엔드포인트의 활성 상태를 확인하는 것이 중요합니다. 최근에 IKE SA 또는 해당 하위 SA에서 암호화로 보호된 메시지가 수신되지 않은 경우 시스템은 데드 피어에 메시지가 전송되는 것을 방지하기 위해 활성 확인을 수행해야 합니다. \(실제로는 죽은 피어가 아닌 살아있는 피어를 감지하지만 이를 "데드 피어 감지" 또는 "DPD"라고도 합니다.\) IKE SA 또는 해당 하위 SA에서 암호화로 보호된 새로운 메시지를 수신하면 IKE의 활성이 보장됩니다. SA 및 모든 하위 SA. 이는 IKE 끝점의 실패 모드에 대한 요구 사항을 지정한다는 점에 유의하세요. 오류로 인해 연결된 모든 SA를 수신할 수 없는 경우 구현에서는 SA를 통한 전송을 중지해야 합니다. 시스템이 삭제 메시지를 보낼 수 있는 연결된 IKE SA 없이 서로 독립적으로 실패할 수 있는 하위 SA를 생성하는 경우 시스템은 별도의 IKE SA를 사용하여 그러한 하위 SA를 협상해야 합니다.\(MUST, MUST\)

IKE SA 개시자에 대한 한 가지 유형의 DoS 공격은 개시자가 적절한 주의를 기울이면 피할 수 있습니다. SA 설정의 처음 두 메시지는 암호화로 보호되지 않으므로 공격자는 실제 응답자보다 먼저 개시자의 메시지에 응답하여 독을 감염시킬 수 있습니다. 연결 설정 시도. 이를 방지하기 위해 개시자는 첫 번째 메시지에 대한 여러 응답을 기꺼이 받아들이고 각 응답을 잠재적으로 합법적인 것으로 처리하고 각 응답에 응답한 다음 암호화로 보호된 유효한 응답을 수신하면 유효하지 않은 반개방 연결을 모두 폐기할 수 있습니다. 그 요청 중 하나. 암호학적으로 유효한 응답이 수신되면 이후의 모든 응답은 암호학적으로 유효한지 여부에 관계없이 무시되어야 합니다.\(MAY\)

이러한 규칙을 사용하면 SA 수명에 대해 협상하고 합의할 이유가 없습니다. IKE가 IKE 메시지에 대한 승인이 반복적으로 부족하여 파트너가 죽은 것으로 추정하는 경우 IKE SA 및 해당 IKE SA를 통해 설정된 모든 하위 SA가 삭제됩니다.

IKE 끝점은 언제든지 비활성 하위 SA를 삭제하여 해당 상태를 유지하는 데 사용되는 리소스를 복구할 수 있습니다. IKE 끝점이 하위 SA를 삭제하기로 선택한 경우 삭제를 알리는 삭제 페이로드를 다른 쪽 끝으로 보내야 합니다. 마찬가지로 IKE SA 시간이 초과될 수 있습니다. IKE SA를 닫으면 연관된 모든 하위 SA가 암시적으로 닫힙니다. 이 경우, IKE 엔드포인트는 다른 엔드포인트가 더 이상 응답하지 않는 한 IKE SA를 닫았음을 나타내는 삭제 페이로드를 보내야 합니다\(SHOULD\).\(MUST, MAY, SHOULD\)

---
### **2.5.  Version Numbers and Forward Compatibility**

이 문서에서는 IKE 버전 2.0에 대해 설명합니다. 즉, 주 버전 번호는 2이고 부 버전 번호는 0입니다. 이 문서는 \[IKEV2\]를 대체합니다. 일부 구현에서는 버전 1.0과 버전 2.0을 지원하고 향후에는 다른 버전도 지원하기를 원할 가능성이 높습니다.

주 버전 번호는 패킷 형식이나 필요한 작업이 너무 크게 변경되어 이전 버전 노드가 이해하지 못한 필드를 무시하고 지정된 작업을 수행한 경우 새 버전 노드와 상호 운용할 수 없는 경우에만 증가해야 합니다. 이전 사양에서는. 마이너 버전 번호는 새로운 기능을 나타내며, 마이너 버전 번호가 더 작은 노드에서는 무시되어야 하지만, 마이너 버전 번호가 더 큰 노드에서는 정보 제공 목적으로 사용됩니다. 예를 들어 새로 정의된 알림 메시지 유형을 처리하는 기능을 나타낼 수 있습니다. 더 큰 마이너 버전 번호를 가진 노드는 해당 상대가 해당 메시지를 이해할 수 없으므로 메시지를 보내지 않을 것임을 간단히 알립니다.\(MUST\)

엔드포인트가 더 높은 주 버전 번호의 메시지를 수신하는 경우 반드시 해당 메시지를 삭제해야 하며 지원하는 가장 높은\(가장 가까운\) 버전 번호를 포함하는 INVALID\_MAJOR\_VERSION 유형의 인증되지 않은 알림 메시지를 보내야 합니다. 엔드포인트가 메이저 버전 n과 메이저 버전 m을 지원하는 경우 n과 m 사이의 모든 버전을 지원해야 합니다. 지원하는 주요 버전이 포함된 메시지를 받으면 해당 버전 번호로 응답해야 합니다. 두 노드가 둘 다 지원하는 최대값보다 낮은 주 버전 번호에 대응하도록 속이는 것을 방지하기 위해 IKE에는 노드가 더 높은 주 버전 번호를 말할 수 있음을 나타내는 플래그가 있습니다.\(MUST, MUST, MUST\)

따라서 IKE 헤더의 주요 버전 번호는 전송기가 지원하는 가장 높은 버전 번호가 아닌 메시지의 버전 번호를 나타냅니다. 개시자가 버전 n, n+1 및 n+2를 말할 수 있고 응답자가 버전 n 및 n+1을 말할 수 있다면 그들은 n+1 말하기를 협상할 것입니다. 여기서 개시자는 다음을 나타내는 플래그를 설정합니다. 더 높은 버전을 말하는 능력. 실수로\(아마도 오류 메시지를 보내는 활성 공격자를 통해\) 버전 n으로 협상하는 경우 두 사람 모두 상대방이 더 높은 버전 번호를 지원할 수 있다는 것을 알게 되며 연결을 끊고 버전 n+1을 사용하여 다시 연결해야 합니다.\(MUST\)

v1에서는 더 높은 버전 번호를 말할 수 있다는 것을 알 수 있는 방법이 없기 때문에 IKEv1은 이러한 규칙을 따르지 않습니다. 따라서 적극적인 공격자는 두 개의 v2 가능 노드를 속여 v1을 말하도록 할 수 있습니다. v2 지원 노드가 v1로 협상할 때 로그에 해당 사실을 기록해야 합니다.

또한 향후 호환성을 위해 RESERVED로 표시된 모든 필드는 버전 2.0을 실행하는 구현에서 0으로 설정해야 하며 해당 내용은 버전 2.0을 실행하는 구현에서 무시해야 합니다\("보내는 것에 보수적이어야 하고 받는 것에 자유로워야 합니다." \[ IP\]\). 이러한 방식으로 향후 버전의 프로토콜에서는 해당 필드를 이해하지 못하는 구현에서 무시되는 방식으로 해당 필드를 사용할 수 있습니다. 마찬가지로 정의되지 않은 페이로드 유형은 향후 사용을 위해 예약되어 있습니다. 정의되지 않은 버전의 구현은 해당 페이로드를 건너뛰고 해당 내용을 무시해야 합니다.\(MUST, MUST\)

IKEv2는 향후 호환성을 위한 유연성을 높이기 위해 각 페이로드 헤더에 "중요" 플래그를 추가합니다. 중요 플래그가 설정되어 있고 페이로드 유형이 인식되지 않는 경우 메시지는 거부되어야 하며 해당 페이로드가 포함된 IKE 요청에 대한 응답에는 지원되지 않는 중요 페이로드가 포함되었음을 나타내는 알림 페이로드 UNSUPPORTED\_CRITICAL\_PAYLOAD가 포함되어야 합니다. 해당 알림 페이로드에서 알림 데이터에는 1옥텟 페이로드 유형이 포함되어 있습니다. 중요 플래그가 설정되지 않고 페이로드 유형이 지원되지 않으면 해당 페이로드를 무시해야 합니다. IKE 응답 메시지로 전송된 페이로드에는 중요 플래그가 설정되어서는 안 됩니다. 중요 플래그는 콘텐츠가 아닌 페이로드 유형에만 적용됩니다. 페이로드 유형이 인식되지만 페이로드에 그렇지 않은 내용\(예: SA 페이로드 내부의 알 수 없는 변환 또는 알림 페이로드 내부의 알 수 없는 알림 메시지 유형\)이 포함된 경우 중요 플래그가 무시됩니다.\(MUST, MUST, MUST NOT\)

새로운 페이로드 유형이 향후 추가될 수 있고 이 사양에 정의된 필드와 인터리브되어 나타날 수 있지만 구현은 섹션 1과 2의 그림에 표시된 순서대로 이 사양에 정의된 페이로드를 전송해야 합니다. 구현은 다른 순서로 해당 페이로드가 포함된 메시지를 유효하지 않은 것으로 거부해서는 안 됩니다\(MUST NOT\).\(MUST NOT\)

---
### **2.6.  IKE SA SPIs and Cookies**

"IKE SPI"라고 하는 헤더의 처음 두 개의 8옥텟 필드는 IKE 패킷 시작 부분에서 연결 식별자로 사용됩니다. 각 엔드포인트는 두 SPI 중 하나를 선택하고 이를 IKE SA의 고유 식별자로 선택해야 합니다. SPI 값 0은 특별합니다. 이는 발신자가 원격 SPI 값을 아직 알 수 없음을 나타냅니다.\(MUST\)

들어오는 IKE 패킷은 패킷의 소스 IP 주소\(예를 들어\)를 사용하지 않고 패킷의 SPI만을 사용하여 IKE SA에 매핑됩니다.

메시지 헤더에 수신자의 SPI만 표시되는 ESP 및 AH와 달리 IKE에서는 발신자의 SPI도 모든 메시지에 전송됩니다. IKE SA의 원래 개시자가 선택한 SPI가 항상 먼저 전송되기 때문에 할당된 SPI를 사용하여 적절한 IKE SA를 찾으려는 여러 IKE SA가 열려 있는 엔드포인트는 헤더의 개시자 플래그를 보고 여부를 결정해야 합니다. 첫 번째 또는 두 번째 8옥텟을 할당했습니다.

초기 IKE 교환의 첫 번째 메시지에서 개시자는 응답자의 SPI 값을 알지 못하므로 해당 필드를 0으로 설정합니다. IKE\_SA\_INIT 교환으로 인해 INVALID\_KE\_PAYLOAD, NO\_PROPOSAL\_CHOSEN 또는 COOKIE로 인해 IKE SA가 생성되지 않으면 응답 메시지에서도 응답자의 SPI가 0이 됩니다. 그러나 응답자가 0이 아닌 응답자 SPI를 보내는 경우 개시자는 해당 이유만으로 응답을 거부해서는 안 됩니다.

IKE에 대해 예상되는 두 가지 공격은 상태 및 CPU 고갈로, 대상이 위조된 IP 주소의 세션 시작 요청으로 넘쳐납니다. 응답자가 최소한의 CPU를 사용하고 개시자가 패킷을 전송한다고 주장하는 주소에서 패킷을 수신할 수 있다는 것을 알 때까지 SA에 어떤 상태도 커밋하지 않으면 이러한 공격의 효율성이 떨어질 수 있습니다.

응답자가 다수의 미완료 IKE SA를 감지하면 COOKIE 알림이 포함된 응답으로 IKE\_SA\_INIT 요청에 응답해야 합니다. 이 알림과 관련된 데이터의 길이는 1\~64 옥텟\(포함\)이어야 하며 해당 생성에 대해서는 이 섹션의 뒷부분에서 설명합니다. IKE\_SA\_INIT 응답에 COOKIE 알림이 포함된 경우 개시자는 IKE\_SA\_INIT 요청을 재시도해야 하며 수신된 데이터를 첫 번째 페이로드로 포함하고 다른 모든 페이로드는 변경되지 않은 COOKIE 알림을 포함해야 합니다. 초기 교환은 다음과 같습니다.\(SHOULD, MUST, MUST\)

```text
   Initiator                         Responder
   -------------------------------------------------------------------
   HDR(A,0), SAi1, KEi, Ni  -->
                                <--  HDR(A,0), N(COOKIE)
   HDR(A,0), N(COOKIE), SAi1,
       KEi, Ni  -->
                                <--  HDR(A,B), SAr1, KEr,
                                         Nr, [CERTREQ]
   HDR(A,B), SK {IDi, [CERT,]
       [CERTREQ,] [IDr,] AUTH,
       SAi2, TSi, TSr}  -->
                                <--  HDR(A,B), SK {IDr, [CERT,]
                                         AUTH, SAr2, TSi, TSr}
```

처음 두 메시지는 쿠키 통신을 제외하고 개시자 또는 응답자 상태에 영향을 주지 않습니다. 특히 처음 4개 메시지의 메시지 시퀀스 번호는 모두 0이 되고 마지막 2개 메시지의 메시지 시퀀스 번호는 1이 됩니다. 'A'는 개시자가 할당한 SPI이고 'B'는 응답자가 할당한 SPI입니다.

IKE 구현은 두 번째 IKE\_SA\_INIT 메시지가 도착할 때 유효한 쿠키를 인식하기 위해 저장된 상태를 요구하지 않는 방식으로 응답자 쿠키 생성을 구현할 수 있습니다. 쿠키를 생성하는 데 사용되는 정확한 알고리즘과 구문은 상호 운용성에 영향을 주지 않으므로 여기서는 지정하지 않습니다. 다음은 엔드포인트가 쿠키를 사용하여 제한된 DoS 보호를 구현하는 방법의 예입니다.

이를 수행하는 좋은 방법은 응답자 쿠키를 다음과 같이 설정하는 것입니다.

```text
   Cookie = <VersionIDofSecret> | Hash(Ni | IPi | SPIi | <secret>)
```

여기서 <secret\>은 응답자에게만 알려지고 주기적으로 변경되는 무작위로 생성된 비밀입니다. | 연결을 나타냅니다. <VersionIDofSecret\>은 <secret\>이 다시 생성될 때마다 변경되어야 합니다. IKE\_SA\_INIT가 두 번째로 도착하면 쿠키를 다시 계산하고 수신된 쿠키와 비교할 수 있습니다.

메시지. 일치하는 경우 응답자는 <secret\>이 마지막으로 변경된 이후 쿠키가 생성되었으며 IPi가 처음 본 소스 주소와 동일해야 함을 알게 됩니다. SPIi를 계산에 통합하면 여러 IKE SA가 병렬로 설정되는 경우 모두 다른 쿠키를 얻게 됩니다\(개시자가 고유한 SPIi를 선택한다고 가정\). 해시에 Ni를 통합하면 메시지 2만 보는 공격자가 메시지 3을 성공적으로 위조할 수 없습니다. 또한 해시에 SPIi를 통합하면 공격자가 다른 쪽 끝에서 하나의 쿠키를 가져온 다음 모든 IKE\_SA\_INIT 교환을 시작하는 것을 방지할 수 있습니다. 다른 개시자 SPI\(및 아마도 포트 번호\)를 사용하여 응답자는 하나의 NAT 상자 뒤에 모두 연결을 시도하는 많은 시스템이 있다고 생각합니다.

초기화 과정에서 연결이 있는 동안 <secret\>에 대한 새 값을 선택하면 현재 <VersionIDofSecret\>이 아닌 다른 값으로 IKE\_SA\_INIT가 반환될 수 있습니다. 이 경우 응답자는 새 쿠키와 함께 다른 응답을 보내 메시지를 거부하거나 짧은 시간 동안 <secret\>의 이전 값을 유지하고 둘 중 하나에서 계산된 쿠키를 수락할 수 있습니다. 응답자는 <secret\>이 변경된 후 쿠키를 무기한 허용해서는 안 됩니다. 그렇게 하면 DoS 보호의 일부가 무효화되기 때문입니다. 응답자는 특히 공격을 받는 경우 <secret\> 값을 자주 변경해야 합니다.\(MAY\)

한 당사자가 예상된 값과 내용이 일치하지 않는 쿠키가 포함된 IKE\_SA\_INIT 요청을 수신하면 해당 당사자는 쿠키를 무시하고 쿠키가 포함되지 않은 것처럼 메시지를 처리해야 합니다. 일반적으로 이는 새 쿠키가 포함된 응답을 보내는 것을 의미합니다. 개시자는 가능한 경우 지수 백오프를 사용하여 포기하기 전에 시도하는 쿠키 교환 횟수를 제한해야 합니다. 공격자는 개시자의 IKE\_SA\_INIT 메시지에 대한 여러 쿠키 응답을 위조할 수 있으며 위조된 각 쿠키 응답으로 인해 두 개의 패킷이 전송됩니다. 즉, 개시자에서 응답자\(해당 쿠키를 거부함\)로 하나의 패킷, 응답자에서 응답자로 하나의 응답 올바른 쿠키를 포함하는 개시자입니다.\(MUST\)

용어에 대한 참고 사항: "쿠키"라는 용어는 IPsec을 통한 키 관리에 대한 초기 제안인 Photuris의 Karn 및 Simpson \[PHOTURIS\]에서 유래되었으며 지속되었습니다. ISAKMP\(인터넷 보안 협회 및 키 관리 프로토콜\) \[ISAKMP\] 고정 메시지 헤더에는 "쿠키"라는 두 개의 8옥텟 필드가 포함되어 있으며 해당 구문은 IKEv1과 IKEv2 모두에서 사용되지만 IKEv2에서는 "IKEv"라고 합니다. SPI"이고 쿠키를 보유하는 Notify 페이로드에 별도의 새로운 필드가 있습니다.

---
#### **2.6.1.  Interaction of COOKIE and INVALID_KE_PAYLOAD**

개시자가 IKE\_SA\_INIT 교환을 재시도해야 하는 두 가지 일반적인 이유는 응답자가 쿠키를 요청하거나 KEi 페이로드에 포함된 것과 다른 Diffie-Hellman 그룹을 원하기 때문입니다. 개시자가 응답자로부터 쿠키를 수신하는 경우 개시자는 IKE\_SA\_INIT 요청의 다음 재시도에만 쿠키를 포함할지 아니면 모든 후속 재시도에도 포함할지 여부를 결정해야 합니다.

개시자가 다음 재시도에만 쿠키를 포함하는 경우 경우에 따라 한 번의 추가 왕복이 필요할 수 있습니다. 개시자가 모든 재시도에 쿠키를 포함하지만 응답자가 이를 지원하지 않는 경우에도 추가 왕복이 필요합니다. 예를 들어 응답자가 쿠키 계산에 KEi 페이로드를 포함하는 경우 새 쿠키를 전송하여 요청을 거부합니다.

두 피어 모두 모든 재시도에 쿠키 포함을 지원하는 경우 교환 시간이 약간 더 짧아질 수 있습니다.

```text
   Initiator                   Responder
   -----------------------------------------------------------
   HDR(A,0), SAi1, KEi, Ni -->
                           <-- HDR(A,0), N(COOKIE)
   HDR(A,0), N(COOKIE), SAi1, KEi, Ni  -->
                           <-- HDR(A,0), N(INVALID_KE_PAYLOAD)
   HDR(A,0), N(COOKIE), SAi1, KEi', Ni -->
                           <-- HDR(A,B), SAr1, KEr, Nr
```

구현은 이 짧은 교환을 지원해야 하지만\(MUST NOT\) 다른 구현이 이 짧은 교환을 지원하지 않는 경우 실패해서는 안 됩니다\(MUST NOT\).\(MUST NOT\)

---
### **2.7.  Cryptographic Algorithm Negotiation**

"SA"로 알려진 페이로드 유형은 SA에 대한 IPsec 프로토콜\(IKE, ESP 또는 AH\) 선택 집합과 각 프로토콜과 관련된 암호화 알고리즘에 대한 제안을 나타냅니다.

SA 페이로드는 하나 이상의 제안으로 구성됩니다. 각 제안에는 하나의 프로토콜이 포함됩니다. 각 프로토콜에는 하나 이상의 변환이 포함되어 있으며 각각은 암호화 알고리즘을 지정합니다. 각 변환에는 0개 이상의 속성이 포함됩니다\(변환 ID가 암호화 알고리즘을 완전히 지정하지 않는 경우에만 속성이 필요함\).

이 계층 구조는 여러 변환에 대해 여러 값이 허용되므로 지원되는 제품군 수가 많을 때 암호화 제품군에 대한 제안을 효율적으로 인코딩하도록 설계되었습니다. 응답자는 아래 규칙에 따라 SA 제안의 하위 집합일 수 있는 단일 제품군을 선택해야 합니다.\(MUST\)

각 제안에는 하나의 프로토콜이 포함됩니다. 제안이 수락되면 SA 응답에는 동일한 프로토콜이 포함되어야 합니다. 응답자는 단일 제안을 수락하거나 모두 거부하고 오류를 반환해야 합니다. 오류는 NO\_PROPOSAL\_CHOSEN 유형의 알림에 표시됩니다.\(MUST, MUST\)

각 IPsec 프로토콜 제안에는 하나 이상의 변환이 포함되어 있습니다. 각 변환에는 변환 유형이 포함되어 있습니다. 허용된 암호화 제품군은 제안서에 포함된 각 유형의 변환을 정확히 하나만 포함해야 합니다. 예를 들어 ESP 제안에 ENCR\_3DES, 키 크기 128의 ENCR\_AES, 키 크기 256의 ENCR\_AES, AUTH\_HMAC\_MD5 및 AUTH\_HMAC\_SHA 변환이 포함된 경우 허용된 제품군에는 ENCR\_ 변환 중 하나와 AUTH\_ 변환 중 하나가 포함되어야 합니다. 따라서 6개의 조합이 허용됩니다.\(MUST, MUST\)

개시자가 무결성 보호를 갖춘 일반 암호와 결합 모드 암호를 모두 제안하는 경우 두 가지 제안이 필요합니다. 제안 중 하나에는 무결성 알고리즘이 포함된 일반 암호가 포함되고, 다른 제안에는 무결성 알고리즘이 없는 모든 결합 모드 암호가 포함됩니다\(결합 모드 암호에는 "NONE" 이외의 무결성 알고리즘이 허용되지 않기 때문\). .

---
### **2.8.  Rekeying**

IKE, ESP 및 AH 보안 협회는 제한된 시간 동안만 사용해야 하며 제한된 양의 데이터를 보호하기 위해 비밀 키를 사용합니다. 이는 전체 보안 협회의 수명을 제한합니다. 보안 연결의 수명이 만료되면 보안 연결을 사용하면 안 됩니다. 수요가 있는 경우 새로운 보안 협회가 설립될 수 있습니다. 만료된 연결을 대신하기 위해 보안 연결을 다시 설정하는 것을 "키 재설정"이라고 합니다.\(MUST NOT, MAY\)

최소한의 IPsec 구현을 허용하기 위해 전체 IKE SA를 다시 시작하지 않고 SA를 다시 입력하는 기능은 선택 사항입니다. 구현은 IKE SA 내의 모든 CREATE\_CHILD\_SA 요청을 거부할 수 있습니다. SA가 만료되었거나 곧 만료될 예정이고 여기에 설명된 메커니즘을 사용한 키 재생성 시도가 실패하는 경우 구현은 IKE SA 및 관련 하위 SA를 닫은 다음 새 SA를 시작할 수 있습니다\(MAY\). 구현에서는 SA의 키 재생성을 지원하기를 원할 수 있습니다. 그렇게 하면 성능이 향상되고 전환 중에 손실되는 패킷 수가 줄어들 가능성이 높기 때문입니다.\(MAY, MUST\)

기존 IKE SA 내에서 하위 SA를 다시 입력하려면 동등한 새 SA를 생성하고\(아래 섹션 2.17 참조\) 새 SA가 설정되면 이전 SA를 삭제하십시오. 키를 다시 입력할 때 새 하위 SA는 이전 SA와 다른 트래픽 선택기 및 알고리즘을 가져서는 안 됩니다.\(SHOULD NOT\)

IKE SA 키를 다시 입력하려면 기존 IKE SA 내의 CREATE\_CHILD\_SA를 사용하여 이전 IKE SA를 공유하는 피어와 함께 새로운 동등한 IKE SA\(아래 섹션 2.18 참조\)를 설정합니다. 이렇게 생성된 IKE SA는 원래 IKE SA의 하위 SA를 모두 상속하며, 새 IKE SA는 해당 하위 SA를 유지하는 데 필요한 모든 제어 메시지에 사용됩니다. 새로운 동등한 IKE SA가 생성된 후 개시자는 이전 IKE SA를 삭제하고 자신을 삭제하기 위한 삭제 페이로드는 이전 IKE SA를 통해 전송된 마지막 요청이어야 합니다.\(MUST\)

SA는 사전에 키를 다시 입력해야 합니다. 즉, 이전 SA가 만료되어 사용할 수 없게 되기 전에 새 SA를 설정해야 합니다. 트래픽이 새 SA로 전환될 수 있도록 새 SA가 설정된 시간과 이전 SA를 사용할 수 없게 되는 시간 사이에 충분한 시간이 경과해야 합니다.

IKEv1과 IKEv2의 차이점은 IKEv1 SA 수명이 협상된다는 점입니다. IKEv2에서 SA의 각 끝은 SA에 대한 자체 수명 정책을 시행하고 필요한 경우 SA 키를 다시 입력하는 일을 담당합니다. 두 끝이 서로 다른 수명 정책을 갖는 경우 수명이 더 짧은 끝은 항상 키 재설정을 요청하는 끝이 됩니다. SA가 오랫동안 비활성 상태이고 엔드포인트가 트래픽이 없을 때 SA를 시작하지 않는 경우 엔드포인트는 수명이 만료될 때 SA를 다시 입력하는 대신 SA를 닫도록 선택할 수 있습니다. SA를 마지막으로 다시 입력한 이후 트래픽이 없는 경우에도 그렇게 할 수 있습니다.\(MAY\)

IKEv2는 의도적으로 공통 엔드포인트 간에 동일한 트래픽 선택기를 사용하는 병렬 SA를 허용합니다. 이것의 목적 중 하나는 SA 간의 트래픽 QoS\(서비스 품질\) 차이를 지원하는 것입니다\(\[DIFFSERVFIELD\], \[DIFFSERVARCH\] 및 \[DIFFTUNNEL\]의 섹션 4.1 참조\). 따라서 IKEv1과 달리 엔드포인트와 트래픽 선택기의 조합은 해당 엔드포인트 간의 SA를 고유하게 식별하지 못할 수 있으므로 중복된 트래픽 선택기를 기반으로 SA를 삭제하는 IKEv1 키 재생성 휴리스틱을 사용하면 안 됩니다.\(SHOULD NOT\)

특히 손실된 패킷이 있는 경우 엔드포인트가 SA 상태에 동의하지 않을 수 있는 타이밍 창이 있습니다. CREATE\_CHILD\_SA에 대한 응답자는 생성 요청에 대한 응답을 보내기 전에 SA에서 메시지를 수락할 준비를 해야 하므로 개시자에게는 모호함이 없습니다. 개시자는 응답을 처리하자마자 SA 전송을 시작할 수 있습니다. 개시자,\(MUST, MAY\)

그러나 CREATE\_CHILD\_SA 요청에 대한 응답을 수신하고 처리할 때까지는 새로 생성된 SA를 수신할 수 없습니다. 그러면 응답자는 새로 생성된 SA를 보내도 괜찮은지 어떻게 알 수 있습니까?

기술적 정확성 및 상호 운용성 관점에서 응답자는 CREATE\_CHILD\_SA 요청에 대한 응답을 보내자마자 SA 전송을 시작할 수 있습니다. 그러나 어떤 상황에서는 이로 인해 패킷이 불필요하게 삭제될 수 있으므로 구현에서는 이러한 전송을 연기할 수 있습니다.\(MAY, MAY\)

응답자는 \(1\) SA 쌍의 나머지 절반에서 암호학적으로 유효한 메시지를 수신했거나 \(2\) 새 SA가 기존 SA의 키를 다시 입력한 경우 개시자가 SA에서 메시지를 수신할 준비가 되어 있음을 확신할 수 있습니다. 대체된 SA를 종료하라는 IKE 요청을 받습니다. SA 키를 다시 입력하면 응답자는 해당 이벤트 중 하나가 발생할 때까지 이전 SA에서 계속 트래픽을 보냅니다. 새로운 SA를 설정할 때 응답자는 SA를 수신하거나 시간 초과가 발생할 때까지 새로운 SA에 대한 메시지 전송을 연기할 수 있습니다. 개시자가 CREATE\_CHILD\_SA 요청에 대한 응답을 받지 못한 SA에서 메시지를 받으면 이를 패킷 손실 가능성이 있는 것으로 해석하고 CREATE\_CHILD\_SA 요청을 재전송합니다. 개시자는 메시지를 수신할 준비가 되었음을 응답자에게 확인하기 위해 대기 중인 메시지가 없는 경우 새로 생성된 ESP SA에 더미 ESP 메시지를 보낼 수 있습니다.\(MAY, MAY\)

---
#### **2.8.1.  Simultaneous Child SA Rekeying**

두 끝이 동일한 수명 정책을 갖는 경우 두 끝이 동시에 키 재생성을 시작할 수 있습니다\(이로 인해 중복 SA가 발생함\). 이런 일이 발생할 가능성을 줄이려면 키를 다시 입력하는 타이밍을 지터링해야 합니다\(키를 다시 입력해야 한다는 사실이 인지된 후 임의의 시간만큼 지연됨\).\(SHOULD\)

이러한 형태의 키 재생성은 동일한 노드 쌍 사이에 여러 개의 유사한 SA가 일시적으로 생성될 수 있습니다. 패킷을 수신할 수 있는 두 개의 SA가 있는 경우 노드는 두 SA를 통해 들어오는 패킷을 수락해야 합니다. 이러한 충돌을 통해 중복 SA가 생성된 경우 두 교환에 사용된 4개의 nonce 중 가장 낮은 값으로 생성된 SA는 이를 생성한 엔드포인트에 의해 종료되어야 합니다. "최저"는 옥텟별 비교를 의미합니다\(예를 들어 nonce를 큰 정수로 비교하는 대신\). 즉, 첫 번째 옥텟을 비교하는 것부터 시작하십시오. 동일하면 다음 옥텟으로 이동합니다. 한 nonce의 끝에 도달하면 해당 nonce가 더 낮은 nonce가 됩니다. 키를 다시 입력한 남아 있는 SA를 시작한 노드는 새 SA가 설정된 후 교체된 SA를 삭제해야 합니다.\(MUST, SHOULD\)

다음은 이것이 구현에 미치는 영향에 대한 설명입니다. 호스트 A와 B에는 SPI\(SPIa1,SPIb1\)가 포함된 기존 하위 SA 쌍이 있고 둘 다 동시에 키 재생성을 시작한다고 가정합니다.

```text
   Host A                            Host B
   -------------------------------------------------------------------
   send req1: N(REKEY_SA,SPIa1),
       SA(..,SPIa2,..),Ni1,..  -->
                                <--  send req2: N(REKEY_SA,SPIb1),
                                         SA(..,SPIb2,..),Ni2
   recv req2 <--
```

이 시점에서 A는 동시에 키 재발급이 발생하고 있음을 알고 있습니다. 그러나 어느 거래소가 가장 낮은 nonce를 가질지는 아직 알 수 없으므로 상황을 참고하고 평소대로 응답할 것입니다.

```text
   send resp2: SA(..,SPIa3,..),
        Nr1,..  -->
                                -->  recv req1
```

이제 B도 동시 키 재설정이 진행되고 있음을 알고 있습니다. 평소대로 반응합니다.

```text
                               <--  send resp1: SA(..,SPIb3,..),
                                        Nr2,..
   recv resp1 <--
                               -->  recv resp2
```

이 시점에서 A와 B 사이에는 세 개의 하위 SA 쌍이 있습니다\(기존 하나와 새 두 개\). 이제 A와 B는 nonce를 비교할 수 있습니다. 가장 낮은 nonce가 메시지 resp2의 Nr1이라고 가정합니다. 이 경우 B\(req2의 발신자\)는 중복된 새 SA를 삭제하고 A\(키가 다시 입력된 남아 있는 SA를 시작한 노드\)는 이전 SA를 삭제합니다.

```text
   send req3: D(SPIa1) -->
                                <--  send req4: D(SPIb2)
                                -->  recv req3
                                <--  send resp3: D(SPIb1)
   recv req4 <--
   send resp4: D(SPIa3) -->
```

이제 키 재설정이 완료되었습니다.

그러나 네트워크에서 일부 패킷이 손실되어 재전송이 발생하는 경우 발생할 수 있는 두 번째 이벤트 시퀀스가 ​​있습니다. 키 재설정은 평소대로 시작되지만 A의 첫 번째 패킷\(req1\)이 손실됩니다.

```text
   Host A                            Host B
   -------------------------------------------------------------------
   send req1: N(REKEY_SA,SPIa1),
       SA(..,SPIa2,..),
       Ni1,..  -->  (lost)
                                <--  send req2: N(REKEY_SA,SPIb1),
                                         SA(..,SPIb2,..),Ni2
   recv req2 <--
   send resp2: SA(..,SPIa3,..),
       Nr1,.. -->
                                -->  recv resp2
                                <--  send req3: D(SPIb1)
   recv req3 <--
   send resp3: D(SPIa1) -->
                                -->  recv resp3
```

B 입장에서는 이제 rekeying이 완료되었고, 아직 A의 req1을 받지 못했기 때문에 동시 rekeying이 있었다는 것조차 알지 못한다. 그러나 A는 메시지를 계속 재전송하고 결국 B에 도달하게 됩니다.

```text
   resend req1 -->
                                -->  recv req1
```

B가 보기에는 A가 더 이상 존재하지 않는 SA를 다시 입력하려고 하는 것처럼 보입니다. 따라서 B는 CHILD\_SA\_NOT\_FOUND와 같이 치명적이지 않은 것으로 요청에 응답합니다.

```text
                                <--  send resp1: N(CHILD_SA_NOT_FOUND)
   recv resp1 <--
```

A가 이 오류를 받으면 동시에 키를 다시 입력했다는 사실을 이미 알고 있으므로 오류 메시지를 무시할 수 있습니다.

---
#### **2.8.2.  Simultaneous IKE SA Rekeying**

아마도 가장 복잡한 경우는 두 피어가 동시에 IKE\_SA 키를 다시 입력하려고 할 때 발생합니다. 기본적으로 섹션 2.8의 내용은 이 경우에도 적용됩니다. 그러나 올바른 IKE\_SA가 하위 SA를 상속하는지 확인하는 것이 중요합니다.

두 끝점 모두 동시 키 재설정을 인식하는 경우는 하위 SA와 동일한 방식으로 작동합니다. CREATE\_CHILD\_SA 교환 후 A와 B 사이에 세 개의 IKE SA\(이전 IKE SA와 두 개의 새로운 IKE SA\)가 존재합니다. 가장 낮은 nonce를 포함하는 새로운 IKE SA는 이를 생성한 노드에 의해 삭제되어야 하며, 살아남은 다른 새로운 IKE SA는 모든 하위 SA를 상속해야 합니다.\(MUST\)

일반적인 동시 키 재설정 사례 외에도 한 피어가 다른 피어가 키 재설정을 수행하고 있다는 사실을 인지하기도 전에 키 재설정을 완료하는 특별한 경우가 있습니다. 단 하나의 피어만이 동시 키 재생성을 감지하는 경우 중복 SA가 생성되지 않습니다. 이 경우 동시 키 재설정을 인지하지 못한 피어가 이미 성공적으로 키를 다시 입력한 IKE SA를 다시 키하라는 요청을 받으면 현재 닫으려고 하는 IKE SA이기 때문에\(여부에 관계없이\) TEMPORARY\_FAILURE를 반환해야 합니다. 이미 SA에 대한 삭제 알림을 보냈습니다. 동시 키 재설정을 인지한 피어가 이전 IKE SA에 대한 다른 피어로부터 삭제 요청을 받으면 다른 피어가 동시 키 재설정을 감지하지 못했다는 것을 알게 되며 첫 번째 피어는 자신의 키 재설정 시도를 잊어버릴 수 있습니다.\(SHOULD\)

```text
   Host A                      Host B
   -------------------------------------------------------------------
   send req1:
        SA(..,SPIa1,..),Ni1,.. -->
                             <-- send req2: SA(..,SPIb1,..),Ni2,..
                             --> recv req1
                             <-- send resp1: SA(..,SPIb2,..),Nr2,..
   recv resp1 <--
   send req3: D() -->
                             --> recv req3
```

이 시점에서 호스트 B는 IKE\_SA를 닫으라는 요청을 확인합니다. 평소대로 대답하는 것 외에는 할 수 있는 일이 별로 없습니다. 그러나 이 시점에서 호스트 B는 req2 재전송을 중지해야 합니다. 호스트 A가 resp3을 수신하면 이전 IKE\_SA와 관련된 모든 상태가 삭제되고 이에 응답할 수 없게 되기 때문입니다.

```text
                             <-- send resp3: ()
```

TEMPORARY\_FAILURE 알림은 RFC 4306에 포함되지 않았으며 TEMPORARY\_FAILURE 알림 지원은 협상되지 않았습니다. 따라서 이 문서가 아닌 RFC 4306을 구현하는 이전 피어는 이러한 알림을 받을 수 있습니다. 이 경우 다른 알 수 없는 오류 알림과 동일하게 처리하고 교환을 중지합니다. 다른 피어가 이미 교환 키를 다시 입력했으므로 그렇게 해도 아무런 영향이 없습니다.

---
#### **2.8.3.  Rekeying the IKE SA versus Reauthentication**

IKE SA 키를 다시 입력하는 것과 재인증은 IKEv2에서 다른 개념입니다. IKE SA 키를 다시 입력하면 IKE SA에 대한 새 키가 설정되고 메시지 ID 카운터가 재설정되지만 당사자를 다시 인증하지는 않습니다\(AUTH 또는 EAP 페이로드는 관련되지 않음\).

일부 환경에서는 IKE SA 키를 다시 입력하는 것이 중요할 수 있지만 재인증\(당사자가 여전히 장기 자격 증명에 액세스할 수 있는지 확인\)이 더 중요한 경우가 많습니다.

IKEv2에는 재인증에 대한 특별한 지원이 없습니다. 재인증은 처음부터 새 IKE SA를 생성하고\(REKEY\_SA 알림 페이로드 없이 IKE\_SA\_INIT/IKE\_AUTH 교환 사용\), 새 IKE SA 내에서 새 하위 SA를 생성하고\(REKEY\_SA 알림 페이로드 없이\) 마지막으로 이전 IKE SA를 삭제하여 수행됩니다\(REKEY\_SA 알림 페이로드 없음\). 이전 하위 SA도 삭제합니다\).

이는 재인증을 통해 IKE SA 및 하위 SA에 대한 새 키도 설정된다는 의미입니다. 따라서 키 재생성은 재인증보다 더 자주 수행될 수 있지만 "인증 수명"이 "키 수명"보다 짧은 상황은 의미가 없습니다.

새로운 IKE SA 생성은 당사자\(원래 IKE SA의 개시자 또는 응답자\)에 의해 시작될 수 있지만 EAP 및/또는 구성 페이로드를 사용한다는 것은 실제로 원래 IKE와 동일한 당사자에 의해 재인증이 시작되어야 함을 의미합니다. SA. IKEv2는 현재 이 경우 응답자가 재인증을 요청하는 것을 허용하지 않습니다. 그러나 \[REAUTH\]와 같이 이 기능을 추가하는 확장이 있습니다.

---
### **2.9.  Traffic Selector Negotiation**

RFC4301 호환 IPsec 하위 시스템이 SPD\(보안 정책 데이터베이스\)의 "보호" 선택기와 일치하는 IP 패킷을 받으면 하위 시스템은 해당 패킷을 IPsec로 보호합니다. SA가 아직 존재하지 않는 경우 SA를 생성하는 것은 IKE의 작업입니다. 일부 구현에서는 IKE 실행과 관련하여 SPD를 업데이트할 수 있지만 시스템의 SPD 유지 관리는 IKE 범위를 벗어납니다\(예제 시나리오는 섹션 1.1.3 참조\).

트래픽 선택기\(TS\) 페이로드를 사용하면 엔드포인트가 SPD의 일부 정보를 피어에 전달할 수 있습니다. 이는 SPD에서 IKE로 전달되어야 합니다\(예를 들어 PF\_KEY API\[PFKEY\]는 SADB\_ACQUIRE 메시지를 사용함\). TS 페이로드는 새로 설정된 SA를 통해 전달될 패킷에 대한 선택 기준을 지정합니다.

이는 일부 시나리오에서 SPD의 일관성을 보장하기 위한 일관성 검사 역할을 할 수 있습니다. 다른 경우에는 SPD의 동적 업데이트를 안내합니다.

하위 SA 쌍을 생성하는 교환의 각 메시지에는 두 개의 TS 페이로드가 나타납니다. 각 TS 페이로드에는 하나 이상의 트래픽 선택기가 포함되어 있습니다. 각 트래픽 선택기는 주소 범위\(IPv4 또는 IPv6\), 포트 범위 및 IP 프로토콜 ID로 구성됩니다.

두 개의 TS 페이로드 중 첫 번째는 TSi\(Traffic Selector-initiator\)로 알려져 있습니다. 두 번째는 TSr\(Traffic Selector-responder\)로 알려져 있습니다. TSi는 하위 SA 쌍의 개시자로부터 전달된 트래픽의 소스 주소\(또는 전달된 트래픽의 대상 주소\)를 지정합니다. TSr은 하위 SA 쌍의 응답자로 전달되는 트래픽의 대상 주소\(또는 전달되는 트래픽의 소스 주소\)를 지정합니다. 예를 들어 원래 개시자가 하위 SA 쌍 생성을 요청하고 개시자 측의 서브넷 198.51.100.\*에서 응답자 측의 서브넷 192.0.2.\*로 모든 트래픽을 터널링하려는 경우 개시자는 다음을 포함합니다. 각 TS 페이로드의 단일 트래픽 선택기. TSi는 주소 범위\(198.51.100.0 - 198.51.100.255\)를 지정하고 TSr은 주소 범위\(192.0.2.0 - 192.0.2.255\)를 지정합니다. 해당 제안이 응답자가 수락했다고 가정하면 동일한 TS 페이로드를 다시 보냅니다.

IKEv2를 사용하면 응답자가 개시자가 제안한 트래픽의 하위 집합을 선택할 수 있습니다. 이는 두 끝점의 구성이 업데이트되고 있지만 한쪽 끝에서만 새 정보를 받은 경우에 발생할 수 있습니다. 두 엔드포인트는 서로 다른 사람에 의해 구성될 수 있으므로 오류가 없더라도 장기간 비호환성이 지속될 수 있습니다. 또한 한쪽 끝이 모든 주소를 터널링하도록 구성되고 다른 쪽 끝이 최신 목록을 갖는 경우와 같이 의도적으로 다른 구성을 허용합니다.

응답자가 개시자가 제안한 트래픽의 하위 집합을 선택하면 트래픽 선택기가 개시자 제안의 일부 하위 집합으로 범위가 좁아집니다\(단, 해당 집합이 null 집합이 되지 않는 경우\). 제안된 트래픽 선택기의 유형을 알 수 없는 경우 응답자는 해당 트래픽 선택기를 무시하므로 알 수 없는 유형이 제한된 집합에 반환되지 않습니다.

이 경우 응답자가 적절한 범위를 선택할 수 있도록 하려면 개시자가 데이터 패킷으로 인해 SA를 요청한 경우 개시자는 TSi 및 TSr 각각의 첫 번째 트래픽 선택기로 주소를 포함하는 매우 구체적인 트래픽 선택기를 포함해야 합니다. 요청을 트리거하는 패킷입니다. 이 예에서 개시자는 TSi에 두 개의 트래픽 선택기를 포함합니다. 첫 번째는 주소 범위\(198.51.100.43 - 198.51.100.43\)를 포함하고 소스 포트와\(SHOULD\)

패킷의 IP 프로토콜과 모든 포트 및 IP 프로토콜이 포함된 두 번째 패킷\(198.51.100.0 - 198.51.100.255\)입니다. 개시자는 마찬가지로 TSr에 두 개의 트래픽 선택기를 포함합니다. 개시자가 도착하는 패킷에 대한 응답이 아니라 시작 시에 하위 SA 쌍을 생성하는 경우 개시자가 초기 터널에 대해 다른 주소보다 선호하는 특정 주소가 없을 수 있습니다. 이 경우 TSi 및 TSr의 첫 번째 값은 특정 값이 아닌 범위일 수 있습니다.

응답자는 다음과 같이 축소를 수행합니다.

o 응답자의 정책이 제안된 트래픽 선택기의 어떤 부분도 허용하지 않는 경우 TS\_UNACCEPTABLE 알림 메시지로 응답합니다.

o 응답자의 정책이 TSi 및 TSr이 포함하는 전체 트래픽 집합을 허용하는 경우 축소가 필요하지 않으며 응답자는 동일한 TSi 및 TSr 값을 반환할 수 있습니다.

o 응답자의 정책이 TSi 및 TSr의 첫 번째 선택기를 허용하도록 허용하는 경우 응답자는 트래픽 선택기를 개시자의 첫 번째 선택을 포함하는 하위 집합으로 좁혀야 합니다. 위의 예에서 응답자는 모든 포트 및 IP 프로토콜을 사용하여 TSi가 \(198.51.100.43 - 198.51.100.43\)인 것으로 응답할 수 있습니다.\(MUST\)

o 응답자의 정책이 TSi 및 TSr의 첫 번째 선택자를 허용하는 것을 허용하지 않는 경우 응답자는 허용 가능한 TSi 및 TSr 하위 집합으로 범위를 좁힙니다.

범위를 좁힐 때 허용되는 여러 하위 집합이 있을 수 있지만 합집합은 허용되지 않습니다. 이 경우 응답자는 그 중 하나를 임의로 선택하고 응답에 ADDITIONAL\_TS\_POSSIBLE 알림을 포함할 수 있습니다. ADDITIONAL\_TS\_POSSIBLE 알림은 응답자가 제안된 트래픽 선택자의 범위를 좁혔지만 다른 트래픽 선택자도 허용되었을 것이라고 주장합니다. 단, 별도의 SA에서만 가능합니다. 이 알림 유형과 연결된 데이터가 없습니다. 이 경우는 개시자와 응답자가 서로 다르게 구성된 경우에만 발생합니다. 개시자와 응답자가 터널의 세분성에 동의하는 경우 개시자는 응답자가 허용하는 것보다 더 넓은 터널을 요청하지 않습니다.\(MAY\)

응답자의 정책에는 개시자의 트래픽 선택기에 포함된 여러 개의 더 작은 범위가 포함될 수 있으며, 응답자의 정책에서는 이러한 각 범위가 다른 SA를 ​​통해 전송되어야 합니다. 위의 예를 계속하면 응답자는 해당 주소를 개시자에게 터널링하거나 개시자로부터 터널링하려는 정책을 가질 수 있지만 각 주소 쌍은

별도로 협상된 Child SA. 개시자가 패킷을 기반으로 요청을 생성하지 않았지만 \(예를 들어\) 시작 시에 응답자가 올바른 범위를 선택하는 데 도움이 되는 매우 구체적인 첫 번째 트래픽 선택기가 없을 것입니다. 응답자가 이 터널에 어떤 주소 쌍을 포함해야 하는지 결정할 방법이 없으며 SINGLE\_PAIR\_REQUIRED 알림 메시지를 사용하여 요청을 추측하거나 거부해야 합니다.\(MUST\)

SINGLE\_PAIR\_REQUIRED 오류는 발신자가 단일 주소 쌍을 지정하는 트래픽 선택기만 허용하기 때문에 CREATE\_CHILD\_SA 요청을 허용할 수 없음을 나타냅니다. 요청자는 전달하려는 특정 트래픽에 대해서만 SA를 요청하여 응답해야 합니다.\(MUST\)

각 주소 쌍에 대해 별도의 SA를 요구하는 정책을 갖는 구현은 거의 없습니다. 이 때문에 개시자가 제안한 TSi 및 TSr의 일부만 응답자가 수용할 수 있는 경우 응답자는 SINGLE\_PAIR\_REQUIRED를 사용하는 대신 선택자를 수용 가능한 하위 집합으로 좁혀야 합니다.\(MUST\)

---
#### **2.9.1.  Traffic Selectors Violating Own Policy**

새 SA를 생성할 때 개시자는 자체 정책을 위반하는 트래픽 선택기를 제안하지 않아야 합니다. 이 규칙을 따르지 않으면 유효한 트래픽이 삭제될 수 있습니다. \[IPSECARCH\]의 관련 해제 정책을 사용하면 이러한 종류의 정책 위반이 발생할 수 없습니다.

이는 예를 통해 가장 잘 설명됩니다. 호스트 A에 198.51.100.66에 대한 트래픽이 AES를 사용하여 암호화된 호스트 B를 통해 전송되고 198.51.100.0/24의 다른 모든 호스트에 대한 트래픽도 B를 통해 전송되지만 3DES를 사용해야 하는 정책이 있다고 가정합니다. 또한 호스트 B가 AES와 3DES의 모든 조합을 허용한다고 가정합니다.

이제 호스트 A가 3DES를 사용하고 \(198.51.100.0 - 198.51.100.255\)을 포함하는 TSr을 포함하는 SA를 제안하는 경우 호스트 B는 이를 수락합니다. 이제 호스트 B는 이 SA를 사용하여 198.51.100.66에서 트래픽을 보낼 수도 있습니다. 그러나 이 트래픽에는 AES를 사용해야 하므로 해당 패킷은 A에 의해 삭제됩니다. 호스트 A가 AES를 사용하는 198.51.100.66에 대해서만 새 SA를 생성하더라도 호스트 B는 트래픽에 대해 첫 번째 SA를 자유롭게 계속 사용할 수 있습니다. 이러한 상황에서 SA를 제안할 때 호스트 A는 자체 정책을 따라야 하며 대신 \(\(198.51.100.0 - 198.51.100.65\), \(198.51.100.67 - 198.51.100.255\)\)을 포함하는 TSr을 포함해야 합니다.

```text
   In general, if (1) the initiator makes a proposal "for traffic X
   (TSi/TSr), do SA", and (2) for some subset X' of X, the initiator
   does not actually accept traffic X' with SA, and (3) the initiator
   would be willing to accept traffic X' with some SA' (!=SA), valid
   traffic can be unnecessarily dropped since the responder can apply
   either SA or SA' to traffic X'.
```

---
#### **2.9.2.  Traffic Selectors in Rekeying**

키 재설정은 기존 하위 SA를 다른 하위 SA로 바꾸는 데 사용됩니다. 새 SA가 원본보다 더 좁은 선택기 세트를 갖도록 허용되면 이전 SA에서 허용된 트래픽이 새 SA에서 삭제되어 "교체"라는 개념을 위반하게 됩니다. 따라서 새 SA는 원본보다 선택기가 더 좁아서는 안 됩니다. 키를 다시 입력한 SA가 현재 사용되는 SA보다 더 좁은 범위를 가져야 하는 경우 이는 현재 사용되는 SA가 정책에 위배되는 방식으로 정책이 변경되었음을 의미합니다. 이 경우 정책 변경이 적용된 후 SA가 이미 삭제되었을 것입니다.\(MUST NOT\)

개시자가 하위 SA 키를 다시 입력하려고 시도할 때 제안된 트래픽 선택기는 이전 하위 SA에서 사용된 트래픽 선택기와 동일하거나 상위 집합이어야 합니다. 즉, 현재 활성\(상관되지 않은\) 정책과 동일하거나 상위 집합입니다. 응답자는 현재 사용 중인 범위보다 더 좁은 트래픽 선택기를 좁혀서는 안 됩니다.\(SHOULD, MUST NOT\)

키를 다시 입력한 SA는 현재 사용 중인 SA보다 더 좁은 범위를 가질 수 없으므로 패킷의 선택기가 필요하지 않으므로 해당 선택기는 전송되어서는 안 됩니다.\(SHOULD NOT\)

---
### **2.10.  Nonces**

IKE\_SA\_INIT 메시지에는 각각 nonce가 포함되어 있습니다. 이러한 nonce는 암호화 기능에 대한 입력으로 사용됩니다. CREATE\_CHILD\_SA 요청과 CREATE\_CHILD\_SA 응답에도 nonce가 포함되어 있습니다. 이러한 nonce는 Child SA에 대한 키를 얻는 데 사용되는 키 파생 기술에 최신성을 추가하고 Diffie-Hellman 키에서 강력한 의사 난수 비트 생성을 보장하는 데 사용됩니다. IKEv2에서 사용되는 nonce는 무작위로 선택되어야 하고, 크기가 최소 128비트여야 하며, 협상된 의사 난수 함수\(PRF\) 키 크기의 최소 절반이어야 합니다. 그러나 개시자는 협상 결과가 알려지기 전에 nonce를 선택합니다. 따라서 nonce는 제안되는 모든 PRF에 대해 충분히 길어야 합니다. 키와 nonce 모두에 동일한 난수 소스가 사용되는 경우 후자가 전자를 손상시키지 않도록 주의해야 합니다.\(MUST\)

---
### **2.11.  Address and Port Agility**

IKE는 UDP 포트 500 및 4500을 통해 실행되며 실행되는 동일한 IP 주소에 대해 ESP 및 AH 연결을 암시적으로 설정합니다. 그러나 외부 헤더의 IP 주소와 포트는 그 자체로 암호화되어 보호되지 않으며 IKE는 NAT\(Network Address Translation\) 상자를 통해서도 작동하도록 설계되었습니다. 구현은 소스 포트가 500 또는 4500이 아니더라도 들어오는 요청을 수락해야 하며\(MUST\) 요청이 수신된 주소와 포트에 응답해야 합니다\(MUST\). 요청이 수신된 주소와 포트를 응답의 소스 주소와 포트로 지정해야 합니다. IKE는 IPv4 또는 IPv6에서 동일하게 작동합니다.\(MUST, MUST\)

---
### **2.12.  Reuse of Diffie-Hellman Exponentials**

IKE는 "완벽한 순방향 비밀성" 속성을 얻기 위해 일시적인 Diffie-Hellman 교환을 사용하여 키 자료를 생성합니다. 이는 연결이 닫히고 해당 키를 잊어버린 경우 연결의 모든 데이터를 기록하고 두 엔드포인트의 모든 장기 키에 액세스하는 사람이라도 연결을 보호하는 데 사용되는 키를 재구성할 수 없음을 의미합니다. 세션 키 공간에 대한 무차별 대입 검색을 수행하지 않고 대화합니다.

완벽한 순방향 보안을 달성하려면 연결이 닫힐 때 각 엔드포인트가 연결에 사용되는 키뿐만 아니라 해당 키를 다시 계산하는 데 사용할 수 있는 모든 정보도 잊어버려야 합니다.\(MUST\)

Diffie-Hellman 지수를 계산하는 것은 계산 비용이 많이 들기 때문에 엔드포인트에서는 여러 연결 설정에 이러한 지수를 재사용하는 것이 유리할 수 있습니다. 이를 위한 몇 가지 합리적인 전략이 있습니다. 엔드포인트는 주기적으로만 새로운 지수를 선택할 수 있지만, 일부 연결이 지수의 수명보다 짧은 기간 동안 지속되는 경우 순방향 비밀성이 완벽하지 않을 수 있습니다. 또는 각 연결에 어떤 지수가 사용되었는지 추적하고 해당 연결이 닫힐 때만 지수와 관련된 정보를 삭제할 수 있습니다. 이를 통해 더 많은 상태를 유지하는 대신 완벽한 순방향 비밀성을 잃지 않고 지수를 재사용할 수 있습니다.

Diffie-Hellman 지수를 재사용할지 여부와 시기는 상호 운용성에 영향을 미치지 않는다는 점에서 개인적인 결정입니다. 지수를 재사용하는 구현은 과거 교환에서 다른 엔드포인트가 사용한 지수를 기억하도록 선택할 수 있으며, 계산의 후반부를 피하기 위해 재사용되는 경우도 있습니다. \[재사용\]을 참조하세요.\(MAY\)

이 관행에 대한 보안 분석과 임시 Diffie-Hellman 키를 재사용할 때 추가 보안 고려 사항은 \[RFC6989\]를 참조하세요.

---
### **2.13.  Generating Keying Material**

IKE SA의 맥락에서는 암호화 알고리즘, 무결성 보호 알고리즘, Diffie-Hellman 그룹 및 PRF\(의사 난수 함수\)라는 네 가지 암호화 알고리즘이 협상됩니다. PRF는 IKE SA와 하위 SA 모두에서 사용되는 모든 암호화 알고리즘에 대한 키 자료를 구성하는 데 사용됩니다.

우리는 각 암호화 알고리즘과 무결성 보호 알고리즘이 고정 크기 키를 사용하고 해당 고정 크기 중 무작위로 선택된 값이 적절한 키 역할을 할 수 있다고 가정합니다. 가변 길이 키를 허용하는 알고리즘의 경우 고정 키 크기는 협상된 암호화 변환의 일부로 지정되어야 합니다\(키 길이 변환 속성의 정의는 섹션 3.3.5 참조\). 모든 값이 유효한 키가 아닌 알고리즘\(예: 키 패리티가 있는 DES 또는 3DES\)의 경우 키가 임의의 값에서 파생되는 알고리즘은 암호화 변환으로 지정되어야 합니다. HMAC\(해시된 메시지 인증 코드\) 기반 무결성 보호 기능의 경우 고정 키 크기는 기본 해시 함수의 출력 크기입니다.\(MUST, MUST\)

PRF는 모든 길이의 키를 허용하지만 기본 키 크기가 있다고 가정합니다. 선호하는 키 크기는 SK\_d, SK\_pi 및 SK\_pr의 길이로 사용되어야 합니다\(섹션 2.14 참조\). HMAC 구성을 기반으로 하는 PRF의 경우 기본 키 크기는 기본 해시 함수의 출력 길이와 같습니다. 다른 유형의 PRF는 선호하는 키 크기를 지정해야 합니다.\(MUST, MUST\)

키 입력 자료는 항상 협상된 PRF 알고리즘의 출력으로 파생됩니다. 필요한 키 자료의 양이 PRF의 출력 크기보다 클 수 있으므로 PRF가 반복적으로 사용됩니다. "prf+"라는 용어는 "prf"라는 의사 난수 함수에 대한 입력을 기반으로 의사 난수 스트림을 출력하는 함수를 설명합니다.

다음에서는 | 연결을 나타냅니다. prf+는 다음과 같이 정의됩니다.

```text
   prf+ (K,S) = T1 | T2 | T3 | T4 | ...

   where:
   T1 = prf (K, S | 0x01)
   T2 = prf (K, T1 | S | 0x02)
   T3 = prf (K, T2 | S | 0x03)
   T4 = prf (K, T3 | S | 0x04)
   ...
```

이는 필요한 모든 키를 계산하는 데 필요한 모든 자료가 prf+에서 출력될 때까지 계속됩니다. 키는 경계에 관계없이 출력 문자열에서 가져옵니다\(예: 필요한 키가 256비트 AES\(Advanced Encryption Standard\) 키와 160비트 HMAC 키이고 prf 함수가 160비트를 생성하는 경우 AES 키 HMAC 키는 T1과 T2의 시작 부분에서 나오고 HMAC 키는 T2의 나머지 부분과 T3의 시작 부분에서 나옵니다.

각 prf 함수의 끝에 연결된 상수는 단일 옥텟입니다. prf+ 함수는 prf 함수 출력 크기의 255배를 초과하여 정의되지 않습니다.

---
### **2.14.  Generating Keying Material for the IKE SA**

공유 키는 다음과 같이 계산됩니다. SKEYSEED라는 수량은 IKE\_SA\_INIT 교환 중에 교환된 nonce와 해당 교환 중에 설정된 Diffie-Hellman 공유 비밀에서 계산됩니다. SKEYSEED는 7개의 다른 비밀을 계산하는 데 사용됩니다. SK\_d는 이 IKE SA로 설정된 하위 SA에 대한 새 키를 파생하는 데 사용됩니다. 후속 교환의 구성 요소 메시지를 인증하기 위한 무결성 보호 알고리즘의 키로 사용되는 SK\_ai 및 SK\_ar SK\_ei 및 SK\_er는 모든 후속 교환을 암호화\(물론 해독\)하는 데 사용됩니다. AUTH 페이로드를 생성할 때 사용되는 SK\_pi 및 SK\_pr. SK\_d, SK\_pi 및 SK\_pr의 길이는 합의된 PRF의 기본 키 길이여야 합니다.\(MUST\)

SKEYSEED 및 그 파생상품은 다음과 같이 계산됩니다.

```text
   SKEYSEED = prf(Ni | Nr, g^ir)

   {SK_d | SK_ai | SK_ar | SK_ei | SK_er | SK_pi | SK_pr}
                   = prf+ (SKEYSEED, Ni | Nr | SPIi | SPIr)
```

\(SK\_d, SK\_ai, SK\_ar, SK\_ei, SK\_er, SK\_pi 및 SK\_pr 수량은 prf+의 생성된 비트에서 순서대로 가져옴을 나타냄\) g^ir은 일시적인 Diffie-Hellman 교환의 공유 비밀입니다. g^ir은 빅 엔디안의 옥텟 문자열로 표시됩니다.

필요한 경우 모듈러스의 길이를 만들기 위해 0으로 채워지는 순서입니다. Ni 및 Nr은 헤더가 제거된 nonce입니다. 이전 버전과의 호환성을 이유로 이 계산에서는 특별히 처리되는 두 가지 PRF가 있습니다. 협상된 PRF가 AES-XCBC-PRF-128 \[AESXCBCPRF128\] 또는 AES-CMAC-PRF-128 \[AESCMACPRF128\]인 경우 Ni의 처음 64비트와 Nr의 처음 64비트만 SKEYSEED 계산에 사용되지만 모든 비트는 prf+ 함수에 대한 입력에 사용됩니다.

트래픽 흐름의 두 방향은 서로 다른 키를 사용합니다. 원래 개시자의 메시지를 보호하는 데 사용되는 키는 SK\_ai 및 SK\_ei입니다. 반대 방향의 메시지를 보호하는 데 사용되는 키는 SK\_ar 및 SK\_er입니다.

---
### **2.15.  Authentication of the IKE SA**

확장 가능한 인증을 사용하지 않는 경우\(섹션 2.16 참조\) 피어는 각 서명\(또는 이 섹션의 뒷부분에 설명된 대로 패딩된 공유 비밀을 키로 사용하는 MAC\)의 데이터 블록을 통해 인증됩니다. 이 계산에서 IDi'와 IDr'은 고정 헤더를 제외한 전체 ID 페이로드입니다. 응답자의 경우 서명될 옥텟은 두 번째 메시지\(IKE\_SA\_INIT 응답\)의 헤더에 있는 첫 번째 SPI의 첫 번째 옥텟으로 시작하고 두 번째 메시지에 있는 마지막 페이로드의 마지막 옥텟으로 끝납니다. 여기에는 서명 계산 목적으로 개시자의 nonce Ni\(이를 포함하는 페이로드가 아닌 값만\)와 prf\(SK\_pr, IDr'\) 값이 추가됩니다. Nonce Ni나 prf\(SK\_pr, IDr'\) 값은 모두 전송되지 않습니다. 마찬가지로 개시자는 헤더에 있는 첫 번째 SPI의 첫 번째 옥텟에서 시작하여 마지막 페이로드의 마지막 옥텟으로 끝나는 첫 번째 메시지\(IKE\_SA\_INIT 요청\)에 서명합니다. 여기에 \(서명 계산 목적으로\) 응답자의 nonce Nr과 값 prf\(SK\_pi, IDi'\)가 추가됩니다. 양측이 상대방의 논스에 서명하는 것은 교환의 보안에 매우 중요합니다.

개시자의 서명된 옥텟은 다음과 같이 설명될 수 있습니다.

```text
   InitiatorSignedOctets = RealMessage1 | NonceRData | MACedIDForI
   GenIKEHDR = [ four octets 0 if using port 4500 ] | RealIKEHDR
   RealIKEHDR =  SPIi | SPIr |  . . . | Length
   RealMessage1 = RealIKEHDR | RestOfMessage1
   NonceRPayload = PayloadHeader | NonceRData
   InitiatorIDPayload = PayloadHeader | RestOfInitIDPayload
   RestOfInitIDPayload = IDType | RESERVED | InitIDData
   MACedIDForI = prf(SK_pi, RestOfInitIDPayload)
```

응답자의 서명된 옥텟은 다음과 같이 설명될 수 있습니다.

```text
   ResponderSignedOctets = RealMessage2 | NonceIData | MACedIDForR
   GenIKEHDR = [ four octets 0 if using port 4500 ] | RealIKEHDR
   RealIKEHDR =  SPIi | SPIr |  . . . | Length
   RealMessage2 = RealIKEHDR | RestOfMessage2
   NonceIPayload = PayloadHeader | NonceIData
   ResponderIDPayload = PayloadHeader | RestOfRespIDPayload
   RestOfRespIDPayload = IDType | RESERVED | RespIDData
   MACedIDForR = prf(SK_pr, RestOfRespIDPayload)
```

이 문서에 정의되지 않은 모든 페이로드 유형을 포함하여 모든 페이로드가 서명 아래에 포함됩니다. 교환의 첫 번째 메시지가 여러 번 전송되는 경우\(예: 응답자 쿠키 및/또는 다른 Diffie-Hellman 그룹을 사용하여\) 서명된 메시지의 최신 버전입니다.

선택적으로 메시지 3과 4에는 디지털 서명을 계산하는 데 사용된 키가 ID 페이로드의 이름에 속한다는 증거를 제공하는 인증서 또는 인증서 체인이 포함될 수 있습니다. 서명 또는 MAC는 서명자가 사용하는 키 유형에 따라 결정되고 인증 페이로드의 인증 방법 필드에 지정된 알고리즘을 사용하여 계산됩니다. 개시자와 응답자가 동일한 암호화 알고리즘을 사용하여 서명할 필요는 없습니다. 암호화 알고리즘의 선택은 각각의 키 유형에 따라 다릅니다. 특히, 개시자는 공유 키를 사용하고 응답자는 공개 서명 키와 인증서를 가질 수 있습니다. 인증에 공유 비밀을 사용하는 경우 양방향에서 동일한 키가 사용되는 경우가 일반적이지만 필수는 아닙니다.\(MAY\)

다른 무작위 소스를 통합하지 않고 사용자가 선택한 비밀번호에서만 공유 키를 파생시키는 것은 일반적이지만 일반적으로 안전하지 않은 관행입니다. 사용자가 선택한 비밀번호는 사전 공격에 저항할 만큼 충분히 예측할 수 없고 이 인증 방법에서는 이러한 공격을 방지할 수 없기 때문에 이는 일반적으로 안전하지 않습니다. \(부트스트래핑 및 IKE SA에 비밀번호 기반 인증을 사용하는 애플리케이션은 오프라인 사전 공격을 방지하도록 설계된 섹션 2.16의 인증 방법을 사용해야 합니다.\) 사전 공유 키에는 협상되는 가장 강력한 키만큼 예측할 수 없는 내용이 포함되어야 합니다. . 사전 공유 키의 경우 AUTH 값은 다음과 같이 계산됩니다.

```text
   For the initiator:
      AUTH = prf( prf(Shared Secret, "Key Pad for IKEv2"),
                       <InitiatorSignedOctets>)

   For the responder:
      AUTH = prf( prf(Shared Secret, "Key Pad for IKEv2"),
                       <ResponderSignedOctets>)
```

여기서 "Key Pad for IKEv2" 문자열은 null 종료가 없는 17개의 ASCII 문자입니다. 공유 비밀은 가변 길이일 수 있습니다. 공유 비밀이 비밀번호에서 파생된 경우 IKE 구현이 비밀번호를 일반 텍스트로 저장할 필요가 없고 대신 prf\(Shared Secret,"Key Pad for IKEv2"\) 값을 저장할 수 있도록 패드 문자열이 추가됩니다. IKEv2 이외의 프로토콜에 해당하는 비밀번호로 사용됩니다. 위에서 언급한 것처럼 비밀번호에서 공유 비밀을 파생시키는 것은 안전하지 않습니다. 이 구성은 사람들이 어쨌든 그렇게 할 것으로 예상되기 때문에 사용됩니다. 공유 비밀이 제공되는 관리 인터페이스는 최소 64 옥텟의 ASCII 문자열을 허용해야 하며 공유 비밀로 사용하기 전에 null 종결자를 추가해서는 안 됩니다. 또한 공유 비밀의 16진수 인코딩을 허용해야 합니다. 인코딩을 이진 문자열로 변환하기 위한 알고리즘이 지정된 경우 관리 인터페이스는 다른 인코딩을 허용할 수 있습니다.\(MUST NOT, MUST, MAY\)

EAP 인증에는 두 가지 유형이 있으며\(섹션 2.16에 설명됨\) 각 유형은 위에 표시된 AUTH 계산에서 서로 다른 값을 사용합니다. EAP 방법이 키 생성인 경우 계산 시 공유 비밀을 마스터 세션 키\(MSK\)로 대체합니다. 키를 생성하지 않는 방법의 경우 두 AUTH 계산에서 공유 비밀을 각각 SK\_pi 및 SK\_pr로 대체합니다.

---
### **2.16.  Extensible Authentication Protocol Methods**

공개 키 서명 및 공유 비밀을 사용한 인증 외에도 IKE는 RFC 3748 \[EAP\]에 정의된 방법을 사용한 인증을 지원합니다. 일반적으로 이러한 방법은 비대칭적이며\(사용자가 서버에 인증하도록 설계됨\) 상호적이지 않을 수도 있습니다. 이러한 이유로 이러한 프로토콜은 일반적으로 개시자를 응답자에 인증하는 데 사용되며 개시자에 대한 응답자의 공개 키 서명 기반 인증과 함께 사용해야 합니다. 이러한 방법은 종종 "레거시 인증" 메커니즘이라고 하는 메커니즘과 연관되어 있습니다.\(MUST\)

이 문서는 이 사양을 업데이트하지 않고도 향후 새로운 방법을 추가할 수 있다는 의도로 \[EAP\]를 참조하지만 여기에는 몇 가지 간단한 변형이 문서화되어 있습니다. \[EAP\]는 다양한 수의 메시지를 요구하는 인증 프로토콜을 정의합니다. 확장 가능한 인증은 IKE SA를 초기화하기 위해 완료해야 하는 추가 IKE\_AUTH 교환으로 IKE에서 구현됩니다.\(MUST\)

개시자는 IKE\_AUTH 교환의 첫 번째 메시지에서 AUTH 페이로드를 생략하여 EAP를 사용하고자 함을 나타냅니다. \(AUTH 페이로드는 비EAP 인증에 필요하므로 이 문서의 나머지 부분에서는 선택 사항으로 표시되지 않습니다.\) AUTH 페이로드가 아닌 IDi 페이로드를 포함함으로써 개시자는 신원을 선언했지만 입증하지 못했습니다. 그것. 응답자가 EAP 방법을 사용하려는 경우 IKE\_AUTH 교환의 응답에 EAP\(확장 가능 인증 프로토콜\) 페이로드를 배치하고 후속 IKE\_AUTH 교환에서 개시자 인증이 완료될 때까지 SAr2, TSi 및 TSr 전송을 연기합니다. 최소 EAP 방법의 경우 초기 SA 설정은 다음과 같이 나타납니다.

```text
   Initiator                         Responder
   -------------------------------------------------------------------
   HDR, SAi1, KEi, Ni  -->
                                <--  HDR, SAr1, KEr, Nr, [CERTREQ]
   HDR, SK {IDi, [CERTREQ,]
       [IDr,] SAi2,
       TSi, TSr}  -->
                                <--  HDR, SK {IDr, [CERT,] AUTH,
                                         EAP}
   HDR, SK {EAP}  -->
                                <--  HDR, SK {EAP (success)}
   HDR, SK {AUTH}  -->
                                <--  HDR, SK {AUTH, SAr2, TSi, TSr}
```

섹션 2.2에 설명된 대로 EAP가 사용되는 경우 IKE SA 초기 설정 메시지의 각 쌍에는 메시지 번호가 증가합니다. IKE\_AUTH 메시지의 첫 번째 쌍의 ID는 1이고 두 번째 쌍의 ID는 2입니다.

인증의 부작용으로 공유 키를 생성하는 EAP 방법의 경우, 해당 공유 키는 섹션 2.15에 지정된 공유 비밀 구문을 사용하여 메시지 7과 8에서 AUTH 페이로드를 생성하기 위해 개시자와 응답자 모두에 의해 사용되어야 합니다. EAP의 공유 키는 MSK라는 EAP 사양의 필드입니다. IKE 교환 중에 생성된 이 공유 키는 다른 목적으로 사용되어서는 안 됩니다.\(MUST, MUST NOT\)

공유 키를 설정하지 않는 EAP 방법은 사용하면 안 됩니다. 이러한 EAP 방법이 서버 인증 키를 사용하지 않는 다른 프로토콜에서 사용되는 경우 여러 중간자 공격\(EAPMITM\)을 받을 수 있기 때문입니다. 터널. 자세한 내용은 보안 고려 사항 섹션을 참조하세요. 공유 키를 생성하지 않는 EAP 방법을 사용하는 경우 메시지 7과 8의 AUTH 페이로드는 각각 SK\_pi 및 SK\_pr을 사용하여 생성되어야 합니다.\(SHOULD NOT, MUST\)

EAP를 사용하는 IKE SA의 개시자는 응답자가 알림 메시지를 보내거나 인증 프롬프트를 재시도하는 경우 초기 프로토콜 교환을 최소 10회의 IKE\_AUTH 교환으로 확장할 수 있어야 합니다. 선택한 EAP 인증 방법에 의해 정의된 프로토콜 교환이 성공적으로 종료되면 응답자는 성공 메시지가 포함된 EAP 페이로드를 보내야 합니다. 마찬가지로, 인증 방법이 실패한 경우 응답자는 실패 메시지가 포함된 EAP 페이로드를 보내야 합니다. 응답자는 언제든지 실패 메시지가 포함된 EAP 페이로드를 전송하여 IKE 교환을 종료할 수 있습니다.\(MUST, MUST, MAY\)

이러한 확장된 교환 이후에는 EAP 성공 메시지가 포함된 메시지 다음 두 메시지에 EAP AUTH 페이로드가 포함되어야 합니다.\(MUST\)

개시자 인증에서 EAP를 사용하는 경우 IDi 페이로드의 콘텐츠는 AAA\(인증, 권한 부여 및 계정 관리\) 라우팅 목적과 사용할 EAP 방법 선택에만 사용될 수 있습니다. 이 값은 EAP 방식으로 인증된 신원과 다를 수 있습니다. 정책 조회 및 액세스 제어 결정에서 실제 인증된 ID를 사용하는 것이 중요합니다. EAP 서버는 IKEv2 응답자와 통신하는 별도의 AAA 서버에 구현되는 경우가 많습니다. 이 경우 인증된 ID가 IDi 페이로드의 ID와 다른 경우 AAA 서버에서 IKEv2 응답자로 전송되어야 합니다.

---
### **2.17.  Generating Keying Material for Child SAs**

단일 하위 SA는 IKE\_AUTH 교환을 통해 생성되며 선택적으로 CREATE\_CHILD\_SA 교환에서 추가 하위 SA를 생성할 수 있습니다. 이에 대한 키 자료는 다음과 같이 생성됩니다.

```text
   KEYMAT = prf+(SK_d, Ni | Nr)
```

여기서 Ni 및 Nr은 이 요청이 처음 생성된 Child SA인 경우 IKE\_SA\_INIT 교환의 nonce이고, 이것이 후속 생성인 경우 CREATE\_CHILD\_SA 교환의 새로운 Ni 및 Nr입니다.

선택적 Diffie-Hellman 교환을 포함한 CREATE\_CHILD\_SA 교환의 경우 키 자료는 다음과 같이 정의됩니다.

```text
   KEYMAT = prf+(SK_d, g^ir (new) | Ni | Nr)
```

여기서 g^ir\(신규\)는 이 CREATE\_CHILD\_SA 교환의 임시 Diffie-Hellman 교환의 공유 비밀입니다\(필요한 경우 상위 비트의 길이를 0으로 채워 빅 엔디안 순서의 옥텟 문자열로 표시됨\). 계수\).

단일 CREATE\_CHILD\_SA 협상으로 인해 여러 보안 연결이 발생할 수 있습니다. ESP 및 AH SA는 쌍으로\(각 방향에 하나씩\) 존재하므로 단일 하위 SA 협상에서 두 개의 SA가 생성됩니다. 또한 하위 SA 협상에는 ESP 또는 AH\(예: \[ROHCV2\]에 설명된 ROHC\_INTEG\) 외에 또는 대신에 일부 향후 IPsec 프로토콜이 포함될 수 있습니다. 어떤 경우에도 각 하위 SA에 대한 키 자료는 다음 규칙을 사용하여 확장된 KEYMAT에서 가져와야 합니다.\(MUST\)

o 개시자에서 응답자로 데이터를 전달하는 SA의 모든 키는 SA가 응답자에서 개시자로 이동하기 전에 가져옵니다.

o 여러 IPsec 프로토콜이 협상되는 경우 프로토콜 헤더가 캡슐화된 패킷에 나타나는 순서대로 각 하위 SA에 대한 키 입력 자료가 사용됩니다.

o IPsec 프로토콜에 여러 개의 키가 필요한 경우 SA의 키 자료에서 해당 키를 가져오는 순서를 프로토콜 사양에 설명해야 합니다. ESP 및 AH의 경우 \[IPSECARCH\]는 순서를 정의합니다. 즉, 암호화 키\(있는 경우\)는 첫 번째 비트에서 가져와야 하고 무결성 키\(있는 경우\)는 나머지 비트에서 가져와야 합니다.\(MUST\)

각 암호화 알고리즘은 알고리즘의 일부로 지정되거나 SA 페이로드에서 협상된 고정된 수의 키 자료 비트를 사용합니다\(키 길이에 대한 설명은 섹션 2.13, 키 길이 변환 속성의 정의는 섹션 3.3.5 참조\).

---
### **2.18.  Rekeying IKE SAs Using a CREATE_CHILD_SA Exchange**

CREATE\_CHILD\_SA 교환을 사용하여 기존 IKE SA의 키를 다시 입력할 수 있습니다\(섹션 1.3.2 및 2.8 참조\). 새로운 개시자 및 응답자 SPI는 SA\(보안 연결\) 페이로드 내부 제안 구조의 SPI 필드\(IKE 헤더의 SPI 필드 아님\)에 제공됩니다. IKE SA 키를 다시 입력할 때 TS 페이로드는 생략됩니다. 새로운 IKE SA에 대한 SKEYSEED는 다음과 같이 기존 IKE SA의 SK\_d를 사용하여 계산됩니다.

```text
   SKEYSEED = prf(SK_d (old), g^ir (new) | Ni | Nr)
```

여기서 g^ir\(신규\)는 이 CREATE\_CHILD\_SA 교환의 임시 Diffie-Hellman 교환의 공유 비밀입니다\(모듈러스의 길이를 만들기 위해 필요한 경우 0이 추가된 빅 엔디안 순서의 옥텟 문자열로 표시됨\). Ni 및 Nr 헤더가 제거된 두 개의 nonce입니다.

이전 및 새 IKE SA가 다른 PRF를 선택했을 수 있습니다. 키 재생성 교환은 이전 IKE SA에 속하므로 SKEYSEED를 생성하는 데 사용되는 것은 이전 IKE SA의 PRF입니다.

IKE SA 키를 다시 입력하는 주요 이유는 이전 키 자료가 손상되어 현재 키에 대한 정보를 제공하지 않도록 하거나 그 반대의 경우도 마찬가지입니다. 따라서 구현에서는 IKE SA 키를 다시 입력할 때 새로운 Diffie-Hellman 교환을 수행해야 합니다. 즉, 개시자는 Diffie-Hellman 변환에 대해 "NONE" 값을 제안해서는 안 되며, 응답자는 그러한 제안을 수락해서는 안 됩니다. 즉, IKE SA 키를 다시 입력하는 성공적인 교환에는 항상 KEi/KEr 페이로드가 포함됩니다.\(MUST, MUST NOT\)

새로운 IKE SA는 메시지 카운터를 0으로 재설정해야 합니다.\(MUST\)

SK\_d, SK\_ai, SK\_ar, SK\_ei 및 SK\_er는 새로운 교환기의 SPIi, SPIr, Ni 및 Nr을 사용하고 새로운 IKE SA의 PRF를 사용하여 섹션 2.14에 지정된 대로 SKEYSEED에서 계산됩니다.

---
### **2.19.  Requesting an Internal Address on a Remote Network**

엔드포인트에서 보안 게이트웨이로의 시나리오에서 가장 일반적으로 발생하는 경우, 엔드포인트에는 보안 게이트웨이로 보호되는 네트워크의 IP 주소가 필요할 수 있으며 해당 주소를 동적으로 할당해야 할 수도 있습니다. 이러한 임시 주소에 대한 요청은 CP 페이로드를 포함함으로써 하위 SA를 생성하기 위한 요청\(메시지 3의 암시적 요청 포함\)에 포함될 수 있습니다. 그러나 IKE\_AUTH 교환 중에는 하나의 IP 주소만 할당하는 것이 일반적입니다. 해당 주소는 적어도 IKE SA가 삭제될 때까지 유지됩니다.

이 기능은 IPsec 원격 액세스 서버\(IRAS\)에 의해 보호되는 네트워크로 터널링을 시도하는 IPsec 원격 액세스 클라이언트\(IRAC\)에 주소 할당을 제공합니다. IKE\_AUTH 교환은 IKE SA 및 하위 SA를 생성하므로 IRAC는 IKE\_AUTH 교환에서 IRAS 제어 주소\(및 선택적으로 보호되는 네트워크에 관한 기타 정보\)를 요청해야 합니다. IRAS는 DHCP/BOOTP\(Bootstrap 프로토콜\) 서버 또는 자체 주소 풀과 같은 다양한 소스로부터 IRAC용 주소를 확보할 수 있습니다.\(MUST\)

```text
   Initiator                         Responder
   -------------------------------------------------------------------
    HDR, SK {IDi, [CERT,]
       [CERTREQ,] [IDr,] AUTH,
       CP(CFG_REQUEST), SAi2,
       TSi, TSr}  -->
                                <--  HDR, SK {IDr, [CERT,] AUTH,
                                         CP(CFG_REPLY), SAr2,
                                         TSi, TSr}
```

모든 경우에 CP 페이로드는 SA 페이로드 앞에 삽입되어야 합니다. 여러 IKE\_AUTH 교환이 있는 프로토콜 변형에서는 SA 페이로드가 포함된 메시지에 CP 페이로드를 삽입해야 합니다.\(MUST, MUST\)

CP\(CFG\_REQUEST\)는 적어도 INTERNAL\_ADDRESS 속성\(IPv4 또는 IPv6\)을 포함해야 하지만 개시자가 응답에서 반환되기를 원하는 추가 속성을 원하는 수만큼 포함할 수 있습니다.\(MUST\)

예를 들어 개시자에서 응답자에게 보내는 메시지는 다음과 같습니다.

```text
   CP(CFG_REQUEST)=
     INTERNAL_ADDRESS()
   TSi = (0, 0-65535, 0.0.0.0-255.255.255.255)
   TSr = (0, 0-65535, 0.0.0.0-255.255.255.255)

   NOTE: Traffic Selectors contain (protocol, port range, address
   range).
```

응답자가 개시자에게 보내는 메시지:

```text
   CP(CFG_REPLY)=
     INTERNAL_ADDRESS(192.0.2.202)
     INTERNAL_NETMASK(255.255.255.0)
     INTERNAL_SUBNET(192.0.2.0/255.255.255.0)
   TSi = (0, 0-65535, 192.0.2.202-192.0.2.202)
   TSr = (0, 0-65535, 192.0.2.0-192.0.2.255)
```

반환된 모든 값은 구현에 따라 다릅니다. 위의 예에서 볼 수 있듯이 IRAS는 CP\(CFG\_REQUEST\)에 포함되지 않은 다른 속성도 보낼 수 있으며 지원하지 않는 필수 속성이 아닌 속성을 무시할 수도 있습니다.\(MAY\)

IRAC가 REPLY를 처리할 수 없는 경우 IRAS가 불필요한 구성 조회를 수행하는 것을 원하지 않기 때문에 응답자는 개시자로부터 CP\(CFG\_REQUEST\)를 먼저 수신하지 않고 CFG\_REPLY를 보내면 안 됩니다.\(MUST NOT\)

IRAS의 구성에서 지정된 ID IDi에 대해 CP를 사용해야 하지만 IRAC가 CP\(CFG\_REQUEST\) 전송에 실패한 경우 IRAS는 요청을 실패하고 FAILED\_CP\_REQUIRED 오류로 하위 SA 생성을 종료해야 합니다. FAILED\_CP\_REQUIRED는 IKE SA에 치명적이지 않습니다. 이는 단순히 하위 SA 생성이 실패하는 원인이 됩니다. 개시자는 나중에 새로운 구성 페이로드 요청을 시작하여 이 문제를 해결할 수 있습니다. FAILED\_CP\_REQUIRED 오류에는 관련 데이터가 없습니다.\(MUST, MUST, MUST\)

---
### **2.20.  Requesting the Peer's Version**

다른 피어의 IKE 소프트웨어 버전 정보를 문의하려는 IKE 피어는 아래 방법을 사용할 수 있습니다. 이는 IKE SA와 첫 번째 하위 SA가 생성된 후 INFORMATIONAL 교환 내 구성 요청의 예입니다.\(MAY\)

IKE 구현은 일부 구현에 보안 취약점이 있는 것으로 알려진 경우 인증 전이나 인증 후에도 버전 정보 제공을 거부할 수 있습니다. 이 경우 빈 문자열을 반환하거나 CP가 지원되지 않는 경우 CP 페이로드를 반환해야 합니다.\(MAY, MUST\)

```text
   Initiator                          Responder
   -------------------------------------------------------------------
   HDR, SK {CP(CFG_REQUEST)}  -->
                                 <--  HDR, SK {CP(CFG_REPLY)}

   CP(CFG_REQUEST)=
     APPLICATION_VERSION("")

   CP(CFG_REPLY) APPLICATION_VERSION("foobar v1.3beta, (c) Foo Bar
     Inc.")
```

---
### **2.21.  Error Handling**

IKE 처리 중에 발생할 수 있는 오류에는 여러 종류가 있습니다. 일반적인 규칙은 형식이 잘못되었거나 정책상의 이유로 허용되지 않는 요청\(예: 일치하는 암호화 알고리즘 없음\)이 수신된 경우 응답에 오류를 나타내는 알림 페이로드가 포함된다는 것입니다. 그러한 응답을 보낼지 여부는 인증된 IKE SA가 있는지 여부에 따라 결정됩니다.

응답 패킷을 구문 분석하거나 처리하는 데 오류가 있는 경우 응답이 새 요청을 생성해서는 안 되기 때문에 일반적인 규칙은 오류 메시지를 다시 보내지 않는 것입니다. 새 요청이 오류 메시지를 다시 보내는 유일한 방법입니다. 응답 패킷을 구문 분석하거나 처리할 때 발생하는 이러한 오류로 인해 수신자는 IKE 상태를 정리해야 합니다\(예: 잘못된 SA에 대한 삭제 전송\).

인증 실패\(AUTHENTICATION\_FAILED 및 EAP 실패\)와 잘못된 메시지\(INVALID\_SYNTAX\)만 삭제 페이로드를 전달하는 명시적인 INFORMATIONAL 교환을 요구하지 않고 IKE SA를 삭제하게 됩니다. 정책에 따라 이것이 필요하다고 지시하는 경우 다른 오류 조건에서는 그러한 교환이 필요할 수 있습니다. EAP 실패로 교환이 종료되면 AUTHENTICATION\_FAILED 알림이 전송되지 않습니다.\(MAY\)

---
#### **2.21.1.  Error Handling in IKE_SA_INIT**

암호화로 보호되는 IKE SA가 설정되기 전에 발생하는 오류는 매우 신중하게 처리해야 합니다. 피어가 문제를 진단하도록 돕고 오류에 대응하는 것과 위조된 메시지를 기반으로 하는 DoS 공격에 참여하지 않으려는 것 사이에는 절충안이 있습니다.

IKE\_SA\_INIT 교환에서 오류 알림으로 인해 교환이 실패합니다. COOKIE, INVALID\_KE\_PAYLOAD 또는 INVALID\_MAJOR\_VERSION과 같은 일부 오류 알림은 이후의 성공적인 교환으로 이어질 수 있습니다. 모든 오류 알림은 완전히 인증되지 않았으므로 수신자는 포기하기 전에 한동안 계속 시도해야 합니다. COOKIE, INVALID\_KE\_PAYLOAD 및 INVALID\_MAJOR\_VERSION과 같이 이 사양에 수정 조치가 정의되어 있지 않은 한 수신자는 오류 알림에 따라 즉시 조치를 취해서는 안 됩니다.

---
#### **2.21.2.  Error Handling in IKE_AUTH**

IKE\_AUTH 교환에서 발생하는 모든 오류로 인해 어떤 이유로든\(잘못된 공유 비밀, 잘못된 ID, 신뢰할 수 없는 인증서 발급자, 취소되거나 만료된 인증서 등\) 인증이 실패하게 되면 AUTHENTICATION\_FAILED 알림이 발생해야 합니다. 응답자에서 오류가 발생한 경우 알림은 보호된 응답으로 반환되며 일반적으로 해당 응답의 유일한 페이로드입니다. IKE\_AUTH 메시지는 암호화되고 무결성이 보호되지만 이 알림을 받는 피어가 아직 상대방을 인증하지 않은 경우 해당 피어는 정보를 주의해서 처리해야 합니다.\(SHOULD\)

개시자에서 오류가 발생하면 일반적으로 다른 페이로드 없이 별도의 정보 교환으로 알림이 반환될 수 있습니다. 이는 응답 오류에 따라 새로운 교환을 시작하지 않는다는 일반 규칙에 대한 예외입니다.\(MAY\)

그러나 지원되지 않는 중요 페이로드가 포함되어 있거나 전체 메시지의 형식이 잘못된\(잘못된 페이로드 콘텐츠가 아닌\) 요청 메시지는 전체적으로 거부되어야 하며 UNSUPPORTED\_CRITICAL\_PAYLOAD 또는 INVALID\_SYNTAX 알림으로만 전송되어야 합니다. 응답. 이 경우 수신자는 인증과 관련된 페이로드를 확인해서는 안 됩니다.\(MUST\)

IKE\_AUTH 교환에서 인증이 성공하면 IKE SA가 설정됩니다. 그러나 하위 SA를 설정하거나 구성 정보를 요청하는 작업은 여전히 ​​실패할 수 있습니다. 이 실패로 인해 IKE SA가 자동으로 삭제되지는 않습니다. 특히 응답자는 인증과 관련된 모든 페이로드를 포함할 수 있습니다.

\(IDr, CERT 및 AUTH\) 피기백 교환\(FAILED\_CP\_REQUIRED, NO\_PROPOSAL\_CHOSEN 등\)에 대한 오류 알림을 보내는 동안 개시자는 이로 인해 인증에 실패해서는 안 됩니다. 물론 개시자는 정책상의 이유로 나중에 그러한 IKE SA를 삭제할 수도 있습니다.\(MUST NOT, MAY\)

IKE\_AUTH 교환 또는 그에 따른 INFORMATIONAL 교환\(IKE\_AUTH에 대한 응답을 처리할 때 오류가 발생한 경우\)에서 UNSUPPORTED\_CRITICAL\_PAYLOAD, INVALID\_SYNTAX 및 AUTHENTICATION\_FAILED 알림은 IKE SA가 삭제되거나 생성되지 않도록 하는 유일한 알림입니다. , 삭제 페이로드 없이. 확장 문서는 이러한 의미 체계로 새로운 오류 알림을 정의할 수 있지만, 공급업체 ID 페이로드를 사용하는 등 피어가 이를 이해하는 것으로 나타나지 않는 한 이를 사용해서는 안 됩니다.\(MUST NOT\)

---
#### **2.21.3.  Error Handling after IKE SA is Authenticated**

IKE SA가 인증된 후 오류가 있는 모든 요청은 반드시 상대방에게 오류를 알리는 응답이 발생해야 합니다.\(MUST\)

정상적인 상황에서는 한 피어의 유효한 응답으로 인해 다른 피어에서 오류 상황이 발생하는 경우가 있어서는 안 됩니다. 따라서 피어가 응답을 제외하고 다른 쪽 끝에 오류 메시지를 보낼 이유가 있어서는 안 됩니다. INFORMATIONAL 교환과 같은 오류 메시지를 전송하면 루프를 유발할 수 있는 추가 오류가 발생할 수 있으므로 이러한 오류는 전송되어서는 안 됩니다. 피어의 상태가 동일하지 않음을 나타내는 오류가 표시되면 IKE SA를 삭제하여 상태를 정리하고 다시 시작하는 것이 좋습니다.\(SHOULD NOT\)

요청을 구문 분석하는 피어가 형식이 잘못되었음을 확인하고\(메시지 인증 코드 확인 및 창 확인을 통과한 후\) INVALID\_SYNTAX 알림을 반환하는 경우 이 오류 알림은 두 피어 모두에서 치명적인 것으로 간주됩니다. 즉, IKE SA가 명시적인 삭제 페이로드 없이 삭제됩니다.

---
#### **2.21.4.  Error Handling Outside IKE SA**

노드는 보호되지 않은 메시지에 대한 응답으로 메시지를 보내는 속도를 제한해야 합니다.

노드가 알려진 IKE SA의 컨텍스트 외부에서 UDP 포트 500 또는 4500에서 메시지를 수신하는 경우\(그리고 해당 메시지는 IKE SA를 시작하라는 요청이 아님\) 이는 최근 노드 충돌의 결과일 수 있습니다. 메시지가 응답으로 표시된 경우 노드는 의심스러운 이벤트를 감사할 수 있지만 응답해서는 안 됩니다. 메시지가 요청으로 표시되면 노드는 의심스러운 이벤트를 감사하고 응답을 보낼 수 있습니다. 응답이 전송되면 응답은 IP로 전송되어야 합니다.\(MUST NOT, MAY, MUST\)

동일한 IKE SPI 및 복사된 메시지 ID와 함께 제공된 주소 및 포트. 응답은 암호화로 보호되어서는 안 되며 INVALID\_IKE\_SPI 알림 페이로드를 포함해야 합니다. INVALID\_IKE\_SPI 알림은 인식할 수 없는 대상 SPI와 함께 IKE 메시지가 수신되었음을 나타냅니다. 이는 일반적으로 수신자가 재부팅하여 IKE SA의 존재를 잊어버렸음을 나타냅니다.\(MUST NOT\)

이러한 보호되지 않은 알림 페이로드를 수신하는 피어는 응답해서는 안 되며 기존 SA의 상태를 변경해서는 안 됩니다. 메시지는 위조된 것일 수도 있고 실제 통신원이 속아서 보낸 응답일 수도 있습니다. 노드는 이러한 메시지\(및 ICMP 대상 도달 불가와 같은 네트워크 메시지\)를 해당 IP 주소에 대한 SA에 문제가 있을 수 있다는 힌트로 처리해야 하며 그러한 IKE SA에 대한 활성 검사를 시작해야 합니다. 구현에서는 속아서 DoS 공격에 참여하는 것을 방지하기 위해 이러한 테스트의 빈도를 제한해야 합니다.\(MUST NOT, SHOULD\)

IKE 요청 컨텍스트 외부에서 오류가 발생하는 경우\(예: 노드가 존재하지 않는 SPI에서 ESP 메시지를 수신하는 경우\) 노드는 문제를 설명하는 알림 페이로드를 사용하여 정보 교환을 시작해야 합니다.\(SHOULD\)

IKE SA가 있는 IP 주소\(및 NAT 통과가 사용되는 경우 포트\)에서 의심스러운 메시지를 수신하는 노드는 해당 SA를 통해 IKE INFORMATIONAL 교환에서 IKE 알림 페이로드를 보내야 합니다. 수신자는 결과적으로 SA의 상태를 변경해서는 안 되지만, 오작동 진단에 도움이 되도록 이벤트를 감사할 수 있습니다.\(SHOULD, MUST NOT\)

---
### **2.22.  IPComp**

IP 압축\[IP-COMP\] 사용은 하위 SA 설정의 일부로 협상될 수 있습니다. IP 압축에는 각 패킷의 추가 헤더와 압축 매개변수 인덱스\(CPI\)가 포함되지만 가상 "압축 연결"에는 이를 포함하는 ESP 또는 AH SA 외부에는 생명이 없습니다. 해당 ESP 또는 AH SA가 사라지면 압축 연결이 사라집니다. 삭제 페이로드에서는 명시적으로 언급되지 않습니다.

IP 압축 협상은 하위 SA와 관련된 암호화 매개변수 협상과 별개입니다. 하위 SA를 요청하는 노드는 IPCOMP\_SUPPORTED 유형의 하나 이상의 알림 페이로드를 통해 하나 이상의 압축 알고리즘에 대한 지원을 광고할 수 있습니다. 이 알림 메시지는 하위 SA를 협상하는 SA 페이로드가 포함된 메시지에만 포함될 수 있으며 보낸 사람이 이 SA에서 IPComp를 사용하려는 의지를 나타냅니다. 응답은 IPCOMP\_SUPPORTED 유형의 알림 페이로드를 사용하여 단일 압축 알고리즘을 수락했음을 나타낼 수 있습니다. 이러한 페이로드는 SA 페이로드를 포함하지 않는 메시지에서 발생해서는 안 됩니다.\(MAY, MAY, MUST NOT\)

이 알림 메시지와 연관된 데이터에는 2옥텟 IPComp CPI, 1옥텟 변환 ID, 선택적으로 해당 변환 ID에 의해 정의된 길이 및 형식의 속성이 포함됩니다. SA를 제안하는 메시지에는 지원되는 여러 알고리즘을 나타내는 여러 IPCOMP\_SUPPORTED 알림이 포함될 수 있습니다. SA를 수락하는 메시지에는 최대 1개의 SA가 포함될 수 있습니다.

변환 ID가 여기에 나열됩니다. 다음 표의 값은 RFC 4306 발행일 현재의 값입니다. 그 이후로 다른 값이 추가되었거나 이 문서가 발행된 후에 추가될 것입니다. 최신 값은 \[IKEV2IANA\]를 참조하세요.

```text
   Name              Number   Defined In
   ----------------------------------------
   IPCOMP_OUI        1        (UNSPECIFIED)
   IPCOMP_DEFLATE    2        RFC 2394
   IPCOMP_LZS        3        RFC 2395
   IPCOMP_LZJH       4        RFC 3051
```

여러 압축 알고리즘이 허용되고 Child SA의 두 방향에 대해 서로 다른 압축 알고리즘을 사용할 수 있도록 허용하는 것에 대한 논의가 있었지만, 이 사양의 구현은 제안되지 않은 IPComp 알고리즘을 허용해서는 안 되며, 둘 이상을 허용해서는 안 됩니다. , Child SA 설정에서 제안되고 허용된 알고리즘 이외의 알고리즘을 사용하여 압축해서는 안 됩니다.\(MUST NOT\)

암호화 매개변수에서 IPComp 협상을 분리하는 데 따른 부작용은 여러 암호화 제품군을 제안하고 그 중 일부에 대해서는 IP 압축을 제안하고 다른 제품군에는 IP 압축을 제안하는 것이 불가능하다는 것입니다.

어떤 경우에는 ROHC\(Robust Header Compression\)가 IP 압축보다 더 적합할 수 있습니다. \[ROHCV2\]는 IKEv2 및 IPsec과 함께 ROHC의 사용을 정의합니다.

---
### **2.23.  NAT Traversal**

NAT\(Network Address Translation\) 게이트웨이는 논란의 여지가 있는 주제입니다. 이 섹션에서는 이것이 무엇인지, 그리고 IKE 트래픽에 대해 어떻게 작동하는지 간략하게 설명합니다. 많은 사람들은 NAT가 사악하며 NAT가 더 잘 작동하도록 프로토콜을 설계해서는 안 된다고 믿습니다. IKEv2는 실제로 NAT가 작동할 가능성을 높이기 위해 일부 비직관적인 처리 규칙을 지정합니다.

NAT는 주로 IPv4 주소가 부족하기 때문에 존재하지만 다른 이유도 있습니다. NAT "뒤"에 있는 IP 노드는 전역적으로 고유하지 않은 IP 주소를 가지고 있지만 오히려 NAT 뒤의 네트워크 내에서 고유하지만 다른 NAT 뒤의 노드에서 재사용될 가능성이 있는 일부 공간에서 할당됩니다. 일반적으로 NAT 뒤에 있는 노드는 동일한 NAT 뒤에 있는 다른 노드 및 전역적으로 고유한 주소를 가진 노드와 통신할 수 있지만 다른 NAT 뒤에 있는 노드와는 통신할 수 없습니다. 해당 규칙에는 예외가 있습니다. 해당 노드가 실제 인터넷의 노드에 연결되면 NAT 게이트웨이는 IP 소스 주소를 게이트웨이로 다시 라우팅될 주소로 "변환"합니다. 인터넷에서 게이트웨이로 보내는 메시지의 대상 주소는 패킷을 올바른 엔드노드로 라우팅하는 내부 주소로 "변환"됩니다.

NAT는 엔드노드에 대해 "투명"하도록 설계되었습니다. NAT 뒤에 있는 노드의 소프트웨어나 인터넷의 노드 모두 NAT를 통해 통신하기 위해 수정이 필요하지 않습니다. 이러한 투명성을 달성하는 것은 다른 프로토콜보다 일부 프로토콜에서 더 어렵습니다. 패킷의 페이로드 내에 엔드포인트의 IP 주소를 포함하는 프로토콜은 NAT 게이트웨이가 프로토콜을 이해하고 내부 참조와 헤더의 참조를 수정하지 않는 한 실패합니다. 이러한 지식은 본질적으로 신뢰할 수 없으며 네트워크 계층 위반이며 종종 미묘한 문제를 초래합니다.

NAT를 통해 IPsec 연결을 열면 특별한 문제가 발생합니다. 연결이 전송 모드에서 실행되는 경우 패킷의 IP 주소를 변경하면 체크섬이 실패하고 NAT는 체크섬이 암호화되어 보호되므로 체크섬을 수정할 수 없습니다. 터널 모드에서도 AH 및 ESP 패킷의 주소를 투명하게 변환하려면 NAT에서 특수 논리가 필요하고 해당 논리는 경험적이며 본질적으로 신뢰할 수 없기 때문에 라우팅 문제가 있습니다. 이러한 이유로 IKEv2는 IKE 및 ESP 패킷의 UDP 캡슐화를 사용합니다. 이 인코딩은 효율성이 약간 떨어지지만 NAT가 처리하기는 더 쉽습니다. 또한 방화벽은 UDP로 캡슐화된 IPsec 트래픽을 전달하지만 캡슐화되지 않은 일반 ESP/AH는 전달하지 않도록 구성할 수 있으며 그 반대의 경우도 마찬가지입니다.

TCP 및 UDP 포트 번호와 주소를 변환하고 인바운드 패킷의 포트 번호를 사용하여 어떤 내부 노드가 주어진 패킷을 받아야 하는지 결정하는 것이 NAT의 일반적인 관행입니다. 이러한 이유로 IKE 패킷은 UDP 포트 500 또는 4500을 통해 전송되어야 하지만 모든 포트에서 들어오는 것을 수락해야 하며 응답은 패킷이 발생한 포트로 전송되어야 합니다. 이는 패킷이 NAT를 통과할 때 포트가 수정될 수 있기 때문입니다. 마찬가지로, IKE 끝점의 IP 주소는 일반적으로 페이로드가 암호화로 보호되고 NAT에 의해 투명하게 수정될 수 없기 때문에 IKE 페이로드에 포함되지 않습니다.\(MUST\)

포트 4500은 UDP로 캡슐화된 ESP 및 IKE용으로 예약되어 있습니다. 아래 설명된 대로 자신과 해당 상대 사이의 NAT를 검색하는 IPsec 끝점은 포트 4500에서 모든 후속 트래픽을 보내야 하며 NAT는 이를 특별히 처리해서는 안 됩니다\(포트 500에서와 같이\).\(MUST\)

초기자는 IKE 시작 시에도 NAT 유무에 관계없이 IKE와 ESP 모두에 포트 4500을 사용할 수 있습니다. 어느 쪽이든 포트 4500을 사용하는 경우 UDP 캡슐화로 ESP를 보낼 필요는 없지만 수신된 UDP 캡슐화 ESP 패킷을 이해해야 합니다. UDP 캡슐화는 포트 500에서 수행되어서는 안 됩니다. NAT-T\(Network Address Translation Traversal\)가 지원되는 경우\(즉, IKE\_SA\_INIT 중에 NAT\_DETECTION\_\*\_IP 페이로드가 교환된 경우\), 모든 장치는 UDP 캡슐화 둘 다를 수신하고 처리할 수 있어야 합니다\(MUST\). ESP 및 UDP로 캡슐화되지 않은 ESP 패킷은 언제든지 가능합니다. 어느 쪽이든 상대방의 선택에 관계없이 ESP에 UDP 캡슐화를 사용할지 여부를 결정할 수 있습니다. 그러나 NAT가 감지되면 두 장치 모두 ESP에 UDP 캡슐화를 사용해야 합니다.\(MUST NOT, MUST, MUST\)

NAT 통과\[NATREQ\]를 지원하기 위한 특정 요구 사항은 아래에 나열되어 있습니다. NAT 통과 지원은 선택 사항입니다. 이 섹션에만 나열된 요구 사항은 NAT 통과를 지원하는 구현에만 적용되어야 합니다.\(MUST\)

o IKE 개시자와 응답자 모두 IKE\_SA\_INIT 패킷에 NAT\_DETECTION\_SOURCE\_IP 및 NAT\_DETECTION\_DESTINATION\_IP 유형의 알림 페이로드를 포함해야 합니다. 이러한 페이로드는 호스트 사이에 NAT가 있는지, 어느 쪽이 NAT 뒤에 있는지 감지하는 데 사용될 수 있습니다. IKE\_SA\_INIT 패킷의 페이로드 위치는 Ni 및 Nr 페이로드 바로 뒤\(선택적 CERTREQ 페이로드 앞\)입니다.\(MUST\)

o NAT\_DETECTION\_SOURCE\_IP 알림과 관련된 데이터는 SPI\(헤더에 나타나는 순서대로\), IP 주소 및 이 패킷이 전송된 포트의 SHA-1 다이제스트입니다.

- 보낸 사람이 여러 네트워크 연결 중 어느 것이 패킷을 보내는 데 사용될지 모르는 경우 메시지에 여러 개의 NAT\_DETECTION\_SOURCE\_IP 페이로드가 있을 수 있습니다.\(MAY\)

o NAT\_DETECTION\_DESTINATION\_IP와 연관된 데이터

- 알림은 SPI\(헤더에 나타나는 순서대로\), IP 주소 및 이 패킷이 전송된 포트의 SHA-1 다이제스트입니다.

o NAT\_DETECTION\_SOURCE\_IP 또는

- NAT\_DETECTION\_DESTINATION\_IP 알림은 제공된 값을 SPI, 소스 또는 수신자 IP 주소 및 포트\(각각\)의 SHA-1 해시와 비교할 수 있으며, 일치하지 않는 경우 활성화해야 합니다.\(SHOULD\)

NAT 통과. 의 불일치가 있는 경우

- 모든 NAT\_DETECTION\_SOURCE\_IP 페이로드가 수신된 NAT\_DETECTION\_SOURCE\_IP 해시, NAT 통과가 지원되지 않는 경우 수신자는 연결 시도를 거부할 수 있습니다. NAT\_DETECTION\_DESTINATION\_IP 해시가 일치하지 않는 경우 이는 NAT\_DETECTION\_DESTINATION\_IP 페이로드를 수신하는 시스템이 NAT 뒤에 있고 해당 시스템이 \[UDPENCAPS\]에 정의된 대로 연결 유지 패킷 전송을 시작해야 함을 의미합니다. 또는 NAT 통과가 지원되지 않으면 연결 시도를 거부할 수도 있습니다.\(MAY, SHOULD\)

o 수신된 NAT\_DETECTION\_SOURCE\_IP 페이로드 중 페이로드가 포함된 패킷의 IP 헤더에서 찾은 소스 IP 및 포트의 예상 값과 일치하는 것이 없으면 해당 페이로드를 보내는 시스템이 NAT 뒤에 있음을 의미합니다\(예: 누군가 경로는 NAT 상자의 주소와 일치하도록 원래 패킷의 소스 주소를 변경했습니다. 이 경우 페이로드를 수신하는 시스템은 나중에 설명하는 것처럼 다른 시스템의 IP 주소에 대한 동적 업데이트를 허용해야 합니다.

o IKE 개시자는 NAT\_DETECTION\_SOURCE\_IP 또는 NAT\_DETECTION\_DESTINATION\_IP 페이로드가 있는지 확인해야 하며\(MUST\) 외부 패킷의 주소와 일치하지 않는 경우 UDP 포트 4500을 통해 이 IKE SA와 관련된 향후 모든 IKE 및 ESP 패킷을 터널링해야 합니다\(MUST\).\(MUST\)

o UDP 포트 4500을 통해 IKE 패킷을 터널링하기 위해 IKE 헤더에는 앞에 4개의 0 옥텟이 추가되고 결과는 UDP 헤더 바로 뒤에 옵니다. UDP 포트 4500을 통해 ESP 패킷을 터널링하기 위해 ESP 헤더는 UDP 헤더 바로 뒤에 옵니다. ESP 헤더의 처음 4개 옥텟에는 SPI가 포함되어 있고 SPI는 유효하게 0이 될 수 없으므로 항상 ESP와 IKE 메시지를 구별하는 것이 가능합니다.

o 구현에서는 NAT가 감지되지 않은 경우에도 수신된 UDP 캡슐화 ESP 패킷을 처리해야 합니다.\(MUST\)

o 전송 모드 TCP 및 UDP 패킷 체크섬 수정\(\[UDPENCAPS\] 참조\)에 필요한 원래 소스 및 대상 IP 주소는 교환과 관련된 트래픽 선택기에서 얻습니다. 전송 모드 NAT 통과의 경우 트래픽 선택기는 정확히 하나의 IP 주소를 포함해야 하며, 이 IP 주소는 원래 IP 주소로 사용됩니다. 이에 대해서는 섹션 2.23.1에서 더 자세히 다룹니다.\(MUST\)

o NAT 상자가 아직 살아있는 매핑을 제거하기로 결정하는 경우가 있습니다\(예: 연결 유지 간격이 너무 길거나 NAT 상자가 재부팅됨\). 무결성 보호가 검증된 패킷을 수신했지만 호스트가 이 사실을 분명히 알 수 있습니다.

이전 포트와 다른 포트, 주소 또는 둘 다

- 검증된 패킷의 SA와 연결됩니다. 이러한 검증된 패킷이 발견되면 MOBIKE\(IKEv2 Mobility and Multihoming\) \[MOBIKE\]와 같은 다른 복구 방법을 지원하지 않고 NAT 뒤에 있지 않은 호스트는 모든 패킷\(재전송 패킷 포함\)을 해당 호스트로 보내야 합니다. 검증된 패킷의 IP 주소와 포트는 이를 SA에 대한 새 주소와 포트 조합으로 저장해야 합니다\(즉, 주소를 동적으로 업데이트해야 합니다\). NAT 뒤에 있는 호스트는 검증된 패킷에 다른 포트 및/또는 주소 값이 있는 경우 이러한 유형의 동적 주소 업데이트를 수행해서는 안 됩니다. 왜냐하면 DoS 공격\(예: 공격자가 단일 패킷과의 연결을 끊을 수 있도록 허용\)이 가능하기 때문입니다. 또한 동적 주소 업데이트는 새 패킷에 대한 응답으로만 수행되어야 합니다. 그렇지 않으면 공격자가 이전에 재생된 패킷으로 주소를 되돌릴 수 있습니다. 이로 인해 동적 업데이트는 재생 방지가 활성화된 경우에만 안전하게 수행될 수 있습니다. IKEv2를 MOBIKE와 함께 사용하는 경우 위에 설명된 주소를 동적으로 업데이트하면 동일한 상황에서 MOBIKE가 복구하는 방식이 방해됩니다. 자세한 내용은 \[MOBIKE\]의 섹션 3.8을 참조하세요.\(SHOULD, SHOULD NOT\)

---
#### **2.23.1.  Transport Mode NAT Traversal**

NAT 통과와 함께 사용되는 전송 모드에는 IKEv2에서 사용되는 트래픽 선택기에 대한 특별한 처리가 필요합니다. 전체 시나리오는 다음과 같습니다.

```text
   +------+        +------+            +------+         +------+
   |Client| IP1    | NAT  | IPN1  IPN2 | NAT  |     IP2 |Server|
   |node  |<------>|  A   |<---------->|  B   |<------->|      |
   +------+        +------+            +------+         +------+
```

\(다른 시나리오는 이 복잡한 사례를 단순화한 것이므로 이 토론에서는 전체 시나리오를 사용합니다.\)

이 시나리오에는 NAT A와 NAT B라는 두 가지 주소 변환 NAT가 있습니다. NAT A는 클라이언트의 소스 주소 IP1을 IPN1에 매핑하는 동적 NAT입니다. NAT B는 IPN2 주소로 들어오는 연결이 게이트웨이의 주소 IP2에 매핑되도록 구성된 고정 NAT입니다. 즉, IPN2 대상 주소가 IP2에 매핑됩니다. 이를 통해 클라이언트는 IPN2에 연결하여 서버에 연결할 수 있습니다. NAT B가 반드시 고정 NAT일 필요는 없지만 클라이언트가 서버에 연결하는 방법을 알아야 하며, NAT B의 외부 주소, 즉 IPN2 주소를 어떻게든 알고 있는 경우에만 그렇게 할 수 있습니다. NAT B가 고정 NAT인 경우 해당 주소를 클라이언트 구성에 맞게 구성할 수 있습니다. 또 다른 옵션은 DNS와 같은 다른 프로토콜을 사용하여 이를 찾는 것이지만 이는 IKEv2의 범위를 벗어납니다.

이 시나리오에서는 클라이언트와 서버 모두 클라이언트 노드에서 발생하여 서버로 향하는 트래픽에 대해 전송 모드를 사용하도록 구성됩니다.

클라이언트가 서버로 트래픽을 보내기 위해 IKEv2 SA 및 하위 SA 생성을 시작하면 소스 IP 주소가 IP1이고 대상 IP 주소가 IPN2인 트리거 패킷이 있을 수 있습니다. PAD\(Peer Authorization Database\) 및 SPD에는 해당 주소\(또는 이를 포함하는 와일드카드 항목\)와 일치하는 구성이 있어야 합니다. 이는 전송 모드이기 때문에 트래픽 선택기와 정확히 동일한 주소 및 IKE 패킷의 외부 IP 주소를 사용합니다. 전송 모드의 경우 TSi 및 TSr 페이로드에서 정확히 하나의 IP 주소를 사용해야 합니다. 예를 들어 협상하려는 포트 범위가 여러 개 있는 경우 트래픽 선택기가 여러 개 있을 수 있지만 모든 TSi 항목은 IP1-IP1 범위를 IP 주소로 사용해야 하고 모든 TSr 항목은 IPN2-IPN2 범위를 다음과 같이 가져야 합니다. IP 주소. TSi 및 TSr의 첫 번째 트래픽 선택기는 요청을 트리거하는 패킷과 같이 프로토콜 및 포트 번호를 포함하여 매우 구체적인 트래픽 선택기를 가져야 합니다.\(MUST, SHOULD\)

그런 다음 NAT A는 IKE 패킷의 소스 주소를 IP1에서 IPN1로 바꾸고 NAT B는 IKE 패킷의 대상 주소를 IPN2에서 IP2로 바꾸므로 패킷이 서버에 도착할 때 여전히 정확히 동일한 트래픽을 갖게 됩니다. 클라이언트가 보낸 선택기이지만 IKE 패킷의 IP 주소가 IPN1 및 IP2로 대체되었습니다.

서버가 이 패킷을 수신하면 일반적으로 ID를 기반으로 RFC 4301 \[IPSECARCH\]에 설명된 PAD\(Peer Authorization Database\)를 찾은 다음 트래픽 선택기를 기반으로 SPD를 검색합니다. IP1은 실제로 서버에 아무런 의미가 없기 때문에\(클라이언트가 NAT 뒤에 있는 주소임\) 전송 모드가 사용되는 경우 IP1을 기반으로 조회를 수행하는 것은 쓸모가 없습니다. 반면, 서버는 일치하는 SPD 항목을 찾기 전에는 정책에 따라 전송 모드가 허용되는지 여부를 알 수 없습니다.

이 경우 서버는 먼저 개시자가 전송 모드를 요청했는지 확인한 다음 트래픽 선택기에서 주소 대체를 수행해야 합니다. 나중에 증분 체크섬 수정에 사용할 이전 트래픽 선택기 IP 주소를 먼저 저장해야 합니다\(TSi의 IP 주소는 원래 소스 주소로 저장될 수 있고 TSr의 IP 주소는 원래 대상 주소로 저장될 수 있음\). \). 이후 상대방이 NAT 뒤에 있는 것으로 감지되면 서버는 TSi 페이로드의 IP 주소를 수신된 IKE 패킷의 소스 주소에서 얻은 IP 주소로 교체합니다\(즉, TSi의 IP1을 IPN1로 교체\). . 서버 끝이 NAT 뒤에 있는 것으로 감지되면 IP를 교체합니다.

TSr 페이로드의 주소를 수신된 IKE 패킷의 대상 주소에서 얻은 IP 주소로 사용합니다\(즉, TSr의 IPN2를 IP2로 대체합니다\).

이 주소 대체 후에는 트래픽 선택기와 IKE UDP 소스/대상 주소가 모두 동일하게 보이고 서버는 이러한 새 트래픽 선택기를 기반으로 SPD 조회를 수행합니다. 항목이 발견되고 전송 모드를 허용하는 경우 해당 항목이 사용됩니다. 항목이 발견되었지만 전송 모드를 허용하지 않는 경우 서버는 주소 대체를 취소하고 원래 트래픽 선택기를 사용하여 SPD 조회를 다시 실행할 수 있습니다. 두 번째 조회가 성공하면 서버는 상대방이 보낸 실제 트래픽 선택기를 사용하여 터널 모드에서 SA를 생성합니다.\(MAY\)

로컬 호스트에서 볼 수 있는 주소를 사용하여 SPD를 조회하기 때문에 전송 모드에서 이러한 주소 대체가 필요합니다. 또한 터널 종료 확인 및 반환 패킷에 대한 SAD\(보안 연결 데이터베이스\) 항목이 로컬 운영 체제 스택에 표시되는 주소를 사용하여 추가되도록 합니다.

가장 일반적인 경우는 서버의 SPD에 모든 주소와 일치하는 와일드카드 항목이 포함된다는 것입니다. 그러나 이를 통해 알려진 다른 NAT의 외부 주소에 대해 다른 SPD 항목을 만들 수도 있습니다.

SPD 조회 후 서버는 찾은 SPD 항목을 기반으로 트래픽 선택기 범위를 좁힙니다. 이미 대체된 트래픽 선택기를 다시 사용하므로 IP 주소로 IPN1 및 IP2가 있는 트래픽 선택기를 다시 보냅니다. 트래픽 선택기에서 사용하는 프로토콜 번호나 포트 범위를 여전히 좁힐 수 있습니다. 하위 SA용으로 생성된 SAD 항목은 서버에서 볼 수 있는 주소, 즉 IPN1 및 IP2를 갖게 됩니다.

클라이언트가 Child SA에 대한 서버의 응답을 받으면 유사한 처리를 수행합니다. 전송 모드 SA가 생성된 경우 클라이언트는 원래 반환된 트래픽 선택기를 원래 소스 및 대상 주소로 저장할 수 있습니다. 트래픽 선택기의 IP 주소를 IKE 패킷의 IP 헤더에 있는 IP 주소로 대체합니다. 즉, IPN1을 IP1로, IP2를 IPN2로 대체합니다. 그런 다음 전송된 트래픽 선택기에 대해 SA를 확인하고 SAD 항목을 설치할 때 해당 트래픽 선택기를 사용합니다.

전송 모드의 NAT 통과 규칙 요약은 다음과 같습니다.

전송 모드를 제안하는 클라이언트의 경우:

- TSi 항목은 정확히 하나의 IP 주소를 가져야 하며 IKE SA의 소스 주소와 일치해야 합니다.\(MUST\)

- TSr 항목은 정확히 하나의 IP 주소를 가져야 하며 IKE SA의 대상 주소와 일치해야 합니다.\(MUST\)

- 첫 번째 TSi 및 TSr 트래픽 선택기는 요청을 트리거하는 패킷과 같은 프로토콜 및 포트 번호를 포함하여 매우 구체적인 트래픽 선택기를 가져야 합니다.\(SHOULD\)

- TSi 및 TSr 항목이 여러 개 있을 수 있습니다.\(MAY\)

- SA에 대한 전송 모드가 선택된 경우\(즉, 서버가 응답에 USE\_TRANSPORT\_MODE 알림을 포함하는 경우\):

- 원본 트래픽 선택기를 수신된 소스 및 대상 주소로 저장합니다.

- 서버가 NAT 뒤에 있는 경우 TSr 항목의 IP 주소를 IKE SA의 원격 주소로 대체합니다.

- 클라이언트가 NAT 뒤에 있는 경우 TSi 항목의 IP 주소를 IKE SA의 로컬 주소로 대체합니다.

- 원본 콘텐츠를 저장하는 것 이외의 용도로 트래픽 선택기를 사용하기 전에 주소 대체를 수행하십시오. 여기에는 트래픽 선택기가 다른 쪽 끝에서 올바르게 범위를 좁혔는지 확인하고 SAD 항목을 생성하는 등의 작업이 포함됩니다.

응답자의 경우 클라이언트가 전송 모드를 제안하는 경우:

- 원본 트래픽 선택기 IP 주소를 수신된 소스 및 대상 주소로 저장하고, 주소 대체 실행 취소가 필요한 경우 \[UDPENCAPS\]에서 지정한 "실제 소스 및 대상 주소"로 사용하고 TCP/UDP 체크섬 수정을 위해 사용합니다.

- 클라이언트가 NAT 뒤에 있는 경우 TSi 항목의 IP 주소를 IKE SA의 원격 주소로 대체합니다.

- 서버가 NAT 뒤에 있는 경우 TSr 항목의 IP 주소를 IKE SA의 로컬 주소로 대체합니다.

- ID와 대체 트래픽 선택기를 사용하여 PAD 및 SPD 조회를 수행합니다.

- SPD 항목이 발견되지 않거나\(발견된 경우\) SPD 항목이 전송 모드를 허용하지 않는 경우 트래픽 선택기 대체를 실행 취소합니다. ID와 원래 트래픽 선택기를 사용하여 PAD 및 SPD 조회를 다시 수행하고 터널 모드 SPD 항목도 검색합니다\(즉, 터널 모드로 대체\).

- 단, 전송 모드 SPD 항목이 발견된 경우 대체된 Traffic Selector 및 SPD 항목을 기준으로 일반 트래픽 선택 축소를 수행합니다. SAD 항목을 생성하고 트래픽 선택기를 클라이언트에 다시 보낼 때 결과 트래픽 선택기를 사용합니다.

---
### **2.24.  Explicit Congestion Notification (ECN)**

IPsec 터널이 원래 \[IPSECARCH-OLD\]에 지정된 대로 작동하는 경우 터널 캡슐화 해제 처리가 ECN 혼잡 표시를 삭제하여 네트워크에 해를 끼치기 때문에 ECN 사용은 외부 IP 헤더에 적합하지 않습니다. IKEv1 기반 IPsec용 IPsec 터널에 대한 ECN 지원에는 여러 작동 모드와 협상이 필요합니다\(\[ECN\] 참조\). IKEv2는 IKEv2에서 생성된 모든 터널 모드 하위 SA의 외부 IP 헤더에서 ECN을 사용할 수 있도록 요구하여 이러한 상황을 단순화합니다. 특히, IKEv2에 의해 생성된 모든 터널 모드 SA에 대한 터널 캡슐화기 및 캡슐화 해제기는 \[ECN\]에 지정된 터널에 대한 ECN 전체 기능 옵션을 지원해야 하며 \[IPSECARCH\]에 지정된 터널 캡슐화 및 캡슐화 해제 처리를 구현하여 ECN 혼잡 표시 폐기를 방지해야 합니다. .\(MUST\)

---
### **2.25.  Exchange Collisions**

IKEv2 교환은 어느 피어에서나 시작할 수 있으므로 동일한 SA에 영향을 미치는 두 교환이 부분적으로 겹칠 수 있습니다. 이로 인해 SA 상태 정보가 일시적으로 동기화되지 않는 상황이 발생할 수 있으며 피어는 정상적인 방식으로 처리할 수 없는 요청을 받을 수 있습니다.

분명히 1보다 큰 창 크기를 사용하면 상황이 더 복잡해지며, 특히 요청이 순서대로 처리되지 않는 경우 더욱 그렇습니다. 이 섹션에서는 창 크기가 1인 경우에도 발생할 수 있는 문제에 중점을 두고 해결 방법을 권장합니다.

TEMPORARY\_FAILURE 알림은 키 재생성 작업과 같은 일시적인 조건으로 인해 완료할 수 없는 요청을 피어가 수신할 때 전송되어야 합니다. 피어가 TEMPORARY\_FAILURE 알림을 받으면 즉시 작업을 재시도해서는 안 됩니다. 임시 조건을 유발한 작업이 무엇이든 보낸 사람이 완료할 수 있도록 기다려야 합니다. 수신자는 몇 분 동안 요청을 한 번 이상 재시도할 수 있습니다. 동료가 계속해서\(SHOULD, MUST NOT, MAY\)

몇 분 후에 동일한 IKE SA에서 TEMPORARY\_FAILURE를 수신하면 상태 정보가 동기화되지 않았다고 결론을 내리고 IKE SA를 닫아야 합니다.\(SHOULD\)

CHILD\_SA\_NOT\_FOUND 알림은 피어가 존재하지 않는 하위 SA를 다시 입력하라는 요청을 수신할 때 전송되어야 합니다. 개시자가 키를 다시 입력하려고 시도한 SA는 REKEY\_SA 알림의 SPI 필드에서 복사된 알림 페이로드의 SPI 필드로 표시됩니다. CHILD\_SA\_NOT\_FOUND 알림을 받은 피어는 하위 SA\(아직 존재하는 경우\)를 자동으로 삭제하고\(하위 SA가 아직 존재하지 않는 경우\) 처음부터 새 하위 SA를 생성하라는 요청을 보내야 합니다.\(SHOULD, SHOULD\)

---
#### **2.25.1.  Collisions while Rekeying or Closing Child SAs**

피어가 현재 닫으려고 하는 하위 SA를 다시 입력하라는 요청을 받으면 TEMPORARY\_FAILURE로 응답해야 합니다. 피어가 현재 키를 다시 입력하고 있는 하위 SA를 다시 입력하라는 요청을 받으면 평소와 같이 응답해야 하며 나중에 nonce를 기반으로 중복 SA를 닫을 준비를 해야 합니다\(섹션 2.8.1 참조\). 피어가 존재하지 않는 하위 SA를 다시 입력하라는 요청을 받으면 CHILD\_SA\_NOT\_FOUND로 응답해야 합니다.\(SHOULD, SHOULD, SHOULD\)

피어가 현재 닫으려고 하는 하위 SA를 닫으라는 요청을 받으면 삭제 페이로드 없이 응답해야 합니다\(섹션 1.4.1 참조\). 피어가 현재 키를 다시 입력하고 있는 하위 SA를 닫으라는 요청을 받으면 평소와 같이 삭제 페이로드로 응답해야 합니다. 피어가 존재하지 않는 하위 SA를 닫으라는 요청을 받은 경우 삭제 페이로드 없이 응답해야 합니다.\(SHOULD, SHOULD, SHOULD\)

피어가 IKE SA 키 재설정 요청을 수신하고 현재 해당 IKE SA의 하위 SA를 생성, 키 재설정 또는 종료 중인 경우 TEMPORARY\_FAILURE로 응답해야 합니다.\(SHOULD\)

---
#### **2.25.2.  Collisions while Rekeying or Closing IKE SAs**

피어가 현재 키를 다시 입력하고 있는 IKE SA를 다시 입력하라는 요청을 받으면 평소대로 응답해야 하며 중복 SA를 닫고 나중에 nonce를 기반으로 상속된 하위 SA를 이동할 준비를 해야 합니다\(섹션 2.8.2 참조\). 피어가 현재 닫으려고 하는 IKE SA를 다시 입력하라는 요청을 받으면 TEMPORARY\_FAILURE로 응답해야 합니다.\(SHOULD, SHOULD\)

피어가 현재 키를 다시 입력하고 있는 IKE SA를 닫으라는 요청을 받으면 평소와 같이 응답해야 하며 자신의 키 다시 입력 요청을 잊어버려야 합니다. 피어가 현재 닫으려고 하는 IKE SA를 닫으라는 요청을 받으면 평소와 같이 응답해야 하며 자신의 닫기 요청을 잊어버려야 합니다.\(SHOULD, SHOULD\)

피어가 현재 IKE SA를 다시 입력하고 있을 때 하위 SA를 생성하거나 다시 입력하라는 요청을 받으면 TEMPORARY\_FAILURE로 응답해야 합니다. 피어가 현재 IKE SA 키를 다시 입력하고 있을 때 하위 SA 삭제 요청을 받으면 평소와 같이 삭제 페이로드로 응답해야 합니다.\(SHOULD, SHOULD\)

---
## **3.  Header and Payload Formats**

이 섹션의 표에서 일부 암호화 기본 요소 및 구성 속성은 "UNSPECIFIED"로 표시됩니다. 알려진 사양이 없어 현재 상호 운용이 불가능한 항목입니다. 향후 사양에서는 그 용도를 설명할 수 있지만 그러한 사양이 만들어질 때까지 구현은 상호 운용 가능한 구현에서 "UNSPECIFIED"로 표시된 항목을 사용하려고 시도해서는 안 됩니다.\(SHOULD NOT\)

---
### **3.1.  The IKE Header**

IKE 메시지는 UDP 포트 500 및/또는 4500을 사용하며 UDP 데이터그램당 하나의 IKE 메시지가 있습니다. UDP 헤더를 통한 패킷 시작 부분의 정보는 헤더의 IP 주소와 UDP 포트가 역전되어 반환 패킷에 사용된다는 점을 제외하면 대부분 무시됩니다. UDP 포트 500에서 전송되면 IKE 메시지는 UDP 헤더 바로 다음에 시작됩니다. UDP 포트 4500에서 전송될 때 IKE 메시지 앞에는 0으로 구성된 4개의 옥텟이 추가됩니다. 이러한 0으로 구성된 4개의 옥텟은 IKE 메시지의 일부가 아니며 IKE에서 정의한 길이 필드나 체크섬에 포함되지 않습니다. 각 IKE 메시지는 이 문서에서 HDR로 표시된 IKE 헤더로 시작됩니다. 헤더 다음에는 각각 이전 페이로드의 다음 페이로드 필드로 식별되는 하나 이상의 IKE 페이로드가 있습니다. 페이로드는 IKE 헤더의 Next Payload 필드를 확인하여 IKE 메시지에 나타나는 순서대로 식별되며, 이후 Next Payload 필드가 0일 때까지 페이로드가 없음을 나타낼 때까지 IKE 페이로드 자체의 Next Payload 필드에 따라 식별됩니다. 따르다. "암호화된" 유형의 페이로드가 발견되면 해당 페이로드가 해독되고 해당 콘텐츠가 추가 페이로드로 구문 분석됩니다. 암호화된 페이로드는 패킷의 마지막 페이로드여야 하며 암호화된 페이로드는 다른 암호화된 페이로드를 포함해서는 안 됩니다.\(MUST NOT\)

헤더에 있는 응답자의 SPI는 IKE 보안 연결의 인스턴스를 식별합니다. 따라서 단일 IKE 인스턴스가 피어당 여러 세션을 포함하여 여러 피어와 고유한 세션을 멀티플렉싱하는 것이 가능합니다.

정수를 나타내는 모든 다중 옥텟 필드는 빅 엔디안 순서\("최상위 바이트 우선" 또는 "네트워크 바이트 순서"라고도 함\)로 배치됩니다.

IKE 헤더의 형식은 그림 4에 나와 있습니다.

```text
                        1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                       IKE SA Initiator's SPI                  |
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                       IKE SA Responder's SPI                  |
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |  Next Payload | MjVer | MnVer | Exchange Type |     Flags     |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                          Message ID                           |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                            Length                             |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                        Figure 4: IKE Header Format
```

o 개시자의 SPI\(8옥텟\) - 고유한 IKE 보안 연결을 식별하기 위해 개시자가 선택한 값입니다. 이 값은 0이 되어서는 안 됩니다.\(MUST NOT\)

o 응답자의 SPI\(8옥텟\) - 고유한 IKE 보안 연결을 식별하기 위해 응답자가 선택한 값입니다. 이 값은 IKE 초기 교환의 첫 번째 메시지\(쿠키를 포함한 해당 메시지의 반복 포함\)에서 0이어야 합니다.\(MUST\)

o 다음 페이로드\(1옥텟\) - 헤더 바로 뒤에 오는 페이로드 유형을 나타냅니다. 각 페이로드의 형식과 값은 아래에 정의되어 있습니다.

o 주요 버전\(4비트\) - 사용 중인 IKE 프로토콜의 주요 버전을 나타냅니다. 이 IKE 버전을 기반으로 한 구현은 주 버전을 2로 설정해야 합니다. IKE 및 ISAKMP의 이전 버전을 기반으로 한 구현은 주 버전을 1로 설정해야 합니다. 이 문서의 IKE 버전\(버전 2\)을 기반으로 한 구현은 다음을 포함하는 메시지를 거부하거나 무시해야 합니다. 섹션 2.5에 설명된 대로 INVALID\_MAJOR\_VERSION 알림 메시지와 함께 2보다 큰 버전 번호.\(MUST, MUST, MUST\)

o 부 버전\(4비트\) - 사용 중인 IKE 프로토콜의 부 버전을 나타냅니다. 이 IKE 버전을 기반으로 한 구현은 부 버전을 0으로 설정해야 합니다. 수신된 메시지의 부 버전 번호를 무시해야 합니다.\(MUST, MUST\)

o 교환 유형\(1옥텟\) - 사용 중인 교환 유형을 나타냅니다. 이는 교환의 각 메시지로 전송되는 페이로드를 제한합니다. 다음 표의 값은 RFC 4306 발행일 현재의 값입니다. 그 이후로 다른 값이 추가되었거나 이 문서가 발행된 후에 추가될 것입니다. 최신 값은 \[IKEV2IANA\]를 참조하세요.

```text
      Exchange Type             Value
      ----------------------------------
      IKE_SA_INIT               34
      IKE_AUTH                  35
      CREATE_CHILD_SA           36
      INFORMATIONAL             37
```

o 플래그\(1옥텟\) - 메시지에 설정된 특정 옵션을 나타냅니다. 옵션의 존재 여부는 설정되는 플래그 필드의 해당 비트로 표시됩니다. 비트는 다음과 같습니다.

```text
        +-+-+-+-+-+-+-+-+
        |X|X|R|V|I|X|X|X|
        +-+-+-+-+-+-+-+-+
```

- 아래 설명에서 비트가 'set'된다는 것은 해당 값이 '1'이라는 것을 의미하고, 'cleared'는 값이 '0'이라는 것을 의미합니다. 'X' 비트는 전송 시 지워져야 하며 수신 시 무시되어야 합니다.\(MUST\)

- \* R\(응답\) - 이 비트는 이 메시지가 동일한 메시지 ID를 포함하는 메시지에 대한 응답임을 나타냅니다. 이 비트는 모든 요청 메시지에서 지워져야 하며 모든 응답에서 설정되어야 합니다. IKE 끝점은 응답으로 표시된 메시지에 대한 응답을 생성해서는 안 됩니다\(한 가지 예외가 있음, 섹션 2.21.2 참조\).\(MUST, MUST NOT\)

- \* V\(버전\) - 이 비트는 송신기가 메이저 버전 번호 필드에 표시된 것보다 더 높은 프로토콜의 메이저 버전 번호를 말할 수 있음을 나타냅니다. IKEv2 구현에서는 전송 시 이 비트를 지워야 하며 수신 메시지에서는 이를 무시해야 합니다\(MUST\).\(MUST\)

- \* I\(개시자\) - 이 비트는 IKE SA의 원래 개시자가 보낸 메시지에서 설정되어야 하며 원래 응답자가 보낸 메시지에서 지워져야 합니다. 이는 수신자가 생성한 SPI의 8개 옥텟을 확인하는 데 사용됩니다. 이 비트는 IKE SA의 마지막 키 재생성을 시작한 사람을 반영하도록 변경됩니다.\(MUST\)

o 메시지 ID\(4옥텟, 부호 없는 정수\) - 손실된 패킷의 재전송 및 요청과 응답의 일치를 제어하는 ​​데 사용되는 메시지 식별자입니다. 이는 메시지 재생 공격을 방지하는 데 사용되므로 프로토콜 보안에 필수적입니다. 섹션 2.1 및 2.2를 참조하십시오.

o 길이\(4옥텟, 부호 없는 정수\) - 옥텟 단위의 총 메시지\(헤더 + 페이로드\) 길이입니다.

---
### **3.2.  Generic Payload Header**

섹션 3.3부터 3.16까지 정의된 각 IKE 페이로드는 그림 5에 표시된 일반 페이로드 헤더로 시작됩니다. 아래의 각 페이로드에 대한 그림에는 일반 페이로드 헤더가 포함되지만 간결성을 위해 각 필드에 대한 설명은 생략됩니다.

```text
                        1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   | Next Payload  |C|  RESERVED   |         Payload Length        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                     Figure 5: Generic Payload Header
```

일반 페이로드 헤더 필드는 다음과 같이 정의됩니다.

o 다음 페이로드\(1옥텟\) - 메시지에서 다음 페이로드의 페이로드 유형에 대한 식별자입니다. 현재 페이로드가 메시지의 마지막인 경우 이 필드는 0이 됩니다. 이 필드는 메시지 끝에 각 페이로드를 추가하고 다음 페이로드를 설정하여 추가 페이로드를 메시지에 추가할 수 있는 "체인" 기능을 제공합니다. 이전 페이로드의 필드를 사용하여 새 페이로드 유형을 나타냅니다. 항상 메시지의 마지막 페이로드가 되어야 하는 암호화된 페이로드는 예외입니다. 여기에는 추가 페이로드 형식의 데이터 구조가 포함되어 있습니다. 암호화된 페이로드의 헤더에서 다음 페이로드 필드는 첫 번째 포함된 페이로드의 페이로드 유형\(0 대신\)으로 설정됩니다. 반대로, 마지막으로 포함된 페이로드의 다음 페이로드 필드는 0으로 설정됩니다. 페이로드 유형 값이 여기에 나열됩니다. 다음 표의 값은 RFC 4306 발행일 현재의 값입니다. 그 이후로 다른 값이 추가되었거나 이 문서가 발행된 후에 추가될 것입니다. 최신 값은 \[IKEV2IANA\]를 참조하세요.

```text
      Next Payload Type                Notation  Value
      --------------------------------------------------
      No Next Payload                             0
      Security Association             SA         33
      Key Exchange                     KE         34
      Identification - Initiator       IDi        35
      Identification - Responder       IDr        36
      Certificate                      CERT       37
      Certificate Request              CERTREQ    38
      Authentication                   AUTH       39
      Nonce                            Ni, Nr     40
      Notify                           N          41
      Delete                           D          42
      Vendor ID                        V          43
      Traffic Selector - Initiator     TSi        44
      Traffic Selector - Responder     TSr        45
      Encrypted and Authenticated      SK         46
      Configuration                    CP         47
      Extensible Authentication        EAP        48
```

\(페이로드 유형 값 1-32는

- IKEv1에 대한 코드 할당과 중복되지 않도록 future입니다.\)

o 중요\(1비트\) - 이전 페이로드의 다음 페이로드 필드에 있는 페이로드 유형 코드를 이해하지 못하는 경우 발신자가 수신자가 이 페이로드를 건너뛰기를 원하는 경우 0으로 설정해야 합니다. 페이로드 유형을 이해하지 못하는 경우 수신자가 이 전체 메시지를 거부하기를 발신자가 원하는 경우 1로 설정해야 합니다. 수신자가 페이로드 유형 코드를 이해하는 경우 수신자는 무시해야 합니다. 이 문서에 정의된 페이로드 유형에 대해서는 0으로 설정해야 합니다. 중요한 비트는 첫 번째 옥텟에 유형 코드가 나타나는 "다음" 페이로드가 아닌 현재 페이로드에 적용됩니다. 이 문서에 정의된 페이로드에 대해 중요 비트를 설정하지 않는 이유는 모든 구현이 이 문서에 정의된 모든 페이로드 유형을 이해해야 하므로 중요 비트의 값을 무시해야 하기 때문입니다. 건너뛴 페이로드에는 유효한 다음 페이로드 및 페이로드 길이 필드가 있어야 합니다. 이 비트에 대한 자세한 내용은 섹션 2.5를 참조하세요.\(MUST, MUST, MUST, MUST, MUST\)

o 예약됨\(7비트\) - 0으로 전송되어야 합니다. 수신 시 무시해야 합니다.\(MUST\)

o 페이로드 길이\(2 옥텟, 부호 없는 정수\) - 일반 페이로드 헤더를 포함하여 현재 페이로드의 옥텟 길이입니다.

많은 페이로드에는 "RESERVED"로 표시된 필드가 포함되어 있습니다. IKEv2\(및 역사적으로 IKEv1\)의 일부 페이로드는 4옥텟 경계에 정렬되지 않습니다.

---
### **3.3.  Security Association Payload**

이 문서에서 SA로 표시된 보안 협회 페이로드는 보안 협회의 속성을 협상하는 데 사용됩니다. 보안 협회 페이로드를 조립하려면 큰 마음의 평화가 필요합니다. SA 페이로드에는 여러 제안이 포함될 수 있습니다. 둘 이상이 있는 경우 가장 선호하는 것부터 가장 선호하지 않는 것 순으로 정렬해야 합니다. 각 제안에는 단일 IPsec 프로토콜\(프로토콜이 IKE, ESP 또는 AH인 경우\)이 포함되어 있고, 각 프로토콜에는 여러 변환이 포함될 수 있으며, 각 변환에는 여러 속성이 포함될 수 있습니다. SA를 구문 분석할 때 구현에서는 총 페이로드 길이가 페이로드의 내부 길이 및 개수와 일치하는지 확인해야 합니다. 제안, 변환 및 속성에는 각각 고유한 가변 길이 인코딩이 있습니다. SA의 페이로드 길이에는 SA, 제안, 변환 및 속성 정보의 결합된 내용이 포함되도록 중첩됩니다. 제안의 길이에는 제안에 포함된 모든 변환 및 속성의 길이가 포함됩니다. 변환의 길이에는 포함된 모든 속성의 길이가 포함됩니다.\(MAY, MUST, MAY, MUST\)

보안 연관, 제안, 변환 및 속성의 구문은 ISAKMP를 기반으로 합니다. 그러나 의미는 다소 다릅니다. 복잡성과 계층 구조의 이유는 단일 SA에 인코딩될 알고리즘의 여러 가능한 조합을 허용하기 때문입니다. 때로는 여러 알고리즘을 선택할 수도 있고, 다른 경우에는 알고리즘을 조합하여 선택할 수도 있습니다. 예를 들어 개시자는 \(3DES 및 HMAC\_MD5\) 또는 \(AES 및 HMAC\_SHA1\)과 함께 ESP 사용을 제안할 수 있습니다.

SA 페이로드의 의미 체계가 ISAKMP 및 IKEv1에서 변경된 이유 중 하나는 일반적인 경우 인코딩을 더 간결하게 만들기 위한 것입니다.

제안 구조에는 제안 번호와 IPsec 프로토콜 ID가 포함되어 있습니다. 각 구조에는 이전 구조보다 1 더 큰 제안 번호가 있어야 합니다. 개시자의 SA 페이로드에 있는 첫 번째 제안의 제안 번호는 1이어야 합니다. 여러 제안을 사용하는 한 가지 이유는 표준 암호화 암호와 결합 모드 암호를 모두 제안하는 것입니다. 결합 모드 암호는 단일 암호화 알고리즘에 무결성과 암호화를 모두 포함하며 무결성 알고리즘을 제공하지 않거나 "NONE"의 단일 무결성 알고리즘을 제공해야 하며 무결성 알고리즘이 권장되는 방법이 아닙니다. 개시자가 결합 모드 암호와 일반 암호를 모두 제안하려면 두 가지 제안을 포함해야 합니다. 하나는 모든 결합 모드 암호를 갖고 다른 하나는 모든 암호를 갖습니다.\(MUST, MUST, MUST\)

무결성 알고리즘을 사용한 일반 암호입니다. 예를 들어, 그러한 제안 중 하나에는 두 개의 제안 구조가 있습니다. 제안 1은 무결성 알고리즘으로 HMAC-SHA1-96 또는 XCBC-96을 사용하는 CBC\(Cipher Block Chaining\) 모드의 AES-128, AES-192 및 AES-256 비트를 사용하는 ESP입니다. 제안 2는 8옥텟 ICV\(무결성 검사 값\)를 사용하는 GCM 모드의 AES-128 또는 AES-256입니다. 두 제안 모두 ESN\(확장 시퀀스 번호\) 사용을 허용하지만 요구하지는 않습니다. 이는 다음과 같이 설명될 수 있습니다.

```text
   SA Payload
      |
      +--- Proposal #1 ( Proto ID = ESP(3), SPI size = 4,
      |     |            7 transforms,      SPI = 0x052357bb )
      |     |
      |     +-- Transform ENCR ( Name = ENCR_AES_CBC )
      |     |     +-- Attribute ( Key Length = 128 )
      |     |
      |     +-- Transform ENCR ( Name = ENCR_AES_CBC )
      |     |     +-- Attribute ( Key Length = 192 )
      |     |
      |     +-- Transform ENCR ( Name = ENCR_AES_CBC )
      |     |     +-- Attribute ( Key Length = 256 )
      |     |
      |     +-- Transform INTEG ( Name = AUTH_HMAC_SHA1_96 )
      |     +-- Transform INTEG ( Name = AUTH_AES_XCBC_96 )
      |     +-- Transform ESN ( Name = ESNs )
      |     +-- Transform ESN ( Name = No ESNs )
      |
      +--- Proposal #2 ( Proto ID = ESP(3), SPI size = 4,
            |            4 transforms,      SPI = 0x35a1d6f2 )
            |
            +-- Transform ENCR ( Name = AES-GCM with a 8 octet ICV )
            |     +-- Attribute ( Key Length = 128 )
            |
            +-- Transform ENCR ( Name = AES-GCM with a 8 octet ICV )
            |     +-- Attribute ( Key Length = 256 )
            |
            +-- Transform ESN ( Name = ESNs )
            +-- Transform ESN ( Name = No ESNs )
```

각 제안/프로토콜 구조 뒤에는 하나 이상의 변환 구조가 옵니다. 다양한 변환의 수는 일반적으로 프로토콜에 의해 결정됩니다. AH에는 일반적으로 ESN\(확장 시퀀스 번호\)과 무결성 검사 알고리즘이라는 두 가지 변환이 있습니다. ESP에는 일반적으로 ESN, 암호화 알고리즘, 무결성 검사 알고리즘의 세 가지가 있습니다. IKE에는 일반적으로 Diffie-Hellman 그룹, 무결성 검사 알고리즘, PRF 알고리즘,

그리고 암호화 알고리즘. 각 프로토콜에 대해 허용되는 변환 집합에는 각 변환의 헤더에 나타나는 변환 ID 번호가 할당됩니다.

동일한 변환 유형을 가진 여러 변환이 있는 경우 제안은 해당 변환의 OR입니다. 변환 유형이 서로 다른 여러 변환이 있는 경우 제안은 서로 다른 그룹의 AND입니다. 예를 들어, \(3DES 또는 AES-CBC\) 및 \(HMAC\_MD5 또는 HMAC\_SHA\)을 사용하여 ESP를 제안하기 위해 ESP 제안에는 두 개의 변환 유형 1 후보\(3DES에 대해 하나, AEC-CBC에 대해 하나\)와 변환 유형 3 후보 두 개\(하나는 3DES에 대해 하나\)가 포함됩니다. HMAC\_MD5용이고 하나는 HMAC\_SHA용입니다\). 이는 네 가지 알고리즘 조합을 효과적으로 제안합니다. 개시자가 \(3DES 및 HMAC\_MD5\) 또는 \(IDEA 및 HMAC\_SHA\)와 같은 하위 집합만 제안하려는 경우 이를 단일 제안 내에서 여러 변환으로 인코딩할 방법이 없습니다. 대신, 개시자는 각각 두 개의 변환을 포함하는 두 개의 서로 다른 제안을 구성해야 합니다.

주어진 변환은 하나 이상의 속성을 가질 수 있습니다. 암호화 알고리즘에 가변 키 크기가 있는 경우처럼 변환을 여러 가지 방법으로 사용할 수 있는 경우 속성이 필요합니다. 변환은 알고리즘을 지정하고 속성은 키 크기를 지정합니다. 대부분의 변환에는 속성이 없습니다. 변환에는 동일한 유형의 여러 속성이 있어서는 안 됩니다. 속성에 대한 대체 값\(예: AES 암호화 알고리즘에 대한 여러 키 크기\)을 제안하려면 구현에 각각 단일 속성이 있는 동일한 변환 유형을 가진 여러 변환이 포함되어야 합니다.\(MAY, MUST NOT, MUST\)

변환 및 속성의 의미는 IKEv1의 의미와 상당히 다릅니다. IKEv1에서 단일 변환은 프로토콜에 대한 여러 알고리즘을 전달했으며, 하나는 변환에 전달되고 다른 알고리즘은 속성에 전달되었습니다.

```text
                        1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   | Next Payload  |C|  RESERVED   |         Payload Length        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                                                               |
   ~                          <Proposals>                          ~
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                  Figure 6: Security Association Payload
```

o 제안\(변수\) - 하나 이상의 제안 하위 구조.

보안 협회 페이로드의 페이로드 유형은 33입니다.

---
#### **3.3.1.  Proposal Substructure**

```text
                        1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   | Last Substruc |   RESERVED    |         Proposal Length       |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   | Proposal Num  |  Protocol ID  |    SPI Size   |Num  Transforms|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   ~                        SPI (variable)                         ~
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                                                               |
   ~                        <Transforms>                           ~
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                      Figure 7: Proposal Substructure
```

o 마지막 하위 구조\(1옥텟\) - 이것이 SA의 마지막 제안 하위 구조인지 여부를 지정합니다. 이 필드는 마지막 제안 하위 구조인 경우 0 값을 가지며, 더 많은 제안 하위 구조가 있는 경우 값 2를 갖습니다. 이 구문은 ISAKMP에서 상속되었지만 SA의 길이로 마지막 제안을 식별할 수 있으므로 필요하지 않습니다. 값 \(2\)는 IKEv1의 Proposal 페이로드 유형에 해당하며 Proposal 구조의 처음 4개 옥텟은 페이로드의 헤더와 다소 유사하게 보이도록 설계되었습니다.

o 예약됨\(1 옥텟\) - 0으로 전송되어야 합니다. 수신 시 무시해야 합니다.\(MUST\)

o 제안 길이\(2 옥텟, 부호 없는 정수\) - 뒤따르는 모든 변환 및 속성을 포함하는 이 제안의 길이입니다.

o 제안 번호\(1 옥텟\) - 제안이 작성되면 SA 페이로드의 첫 번째 제안은 1이어야 하며 후속 제안은 이전 제안보다 하나 더 많아야 합니다\(두 제안의 OR을 나타냄\). 제안이 수락되면 SA 페이로드의 제안 번호는 수락된 전송 제안의 번호와 일치해야 합니다.\(MUST, MUST\)

o 프로토콜 ID\(1옥텟\) - 현재 협상에 대한 IPsec 프로토콜 식별자를 지정합니다. 다음 표의 값은 RFC 4306 발행일 현재의 값입니다. 그 이후로 다른 값이 추가되었거나 이 문서가 발행된 후에 추가될 것입니다. 최신 값은 \[IKEV2IANA\]를 참조하세요.

```text
      Protocol                Protocol ID
      -----------------------------------
      IKE                     1
      AH                      2
      ESP                     3
```

o SPI 크기\(1옥텟\) - 초기 IKE SA 협상의 경우 이 필드는 0이어야 합니다. SPI는 외부 헤더에서 가져옵니다. 후속 협상에서는 해당 프로토콜의 SPI 크기\(옥텟\)와 동일합니다\(IKE의 경우 8, ESP 및 AH의 경우 4\).\(MUST\)

o 변환 수\(1옥텟\) - 이 제안의 변환 수를 지정합니다.

o SPI\(변수\) - 송신 엔터티의 SPI입니다. SPI 크기가 4옥텟의 배수가 아니더라도 페이로드에 패딩이 적용되지 않습니다. SPI 크기 필드가 0이면 이 필드는 보안 연관 페이로드에 존재하지 않습니다.

o 변환\(변수\) - 하나 이상의 변환 하위 구조.

---
#### **3.3.2.  Transform Substructure**

```text
                        1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   | Last Substruc |   RESERVED    |        Transform Length       |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |Transform Type |   RESERVED    |          Transform ID         |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                                                               |
   ~                      Transform Attributes                     ~
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                     Figure 8: Transform Substructure
```

o 마지막 하위 구조\(1옥텟\) - 이것이 제안서의 마지막 변환 하위 구조인지 여부를 지정합니다. 이것이 마지막 변환 하위 구조인 경우 이 필드의 값은 0이고

- 변환 하위 구조가 더 많은 경우 값은 3입니다. 이 구문은 ISAKMP에서 상속되었지만 제안의 길이에서 마지막 변환을 식별할 수 있으므로 필요하지 않습니다. 값 \(3\)은 IKEv1의 Transform 페이로드 유형에 해당하며, Transform 구조의 처음 4개 옥텟은 페이로드의 헤더와 다소 유사하게 보이도록 설계되었습니다.

o 예약됨 - 0으로 전송되어야 합니다. 수신 시 무시해야 합니다.\(MUST\)

o 변환 길이 - 헤더 및 속성을 포함한 변환 하위 구조의 길이\(옥텟\)입니다.

o 변환 유형\(1 옥텟\) - 이 변환에 지정되는 변환 유형입니다. 다양한 프로토콜은 다양한 변환 유형을 지원합니다. 일부 프로토콜의 경우 일부 변환은 선택 사항일 수 있습니다. 변환이 선택 사항이고 개시자가 변환을 생략하도록 제안하려는 경우 해당 유형의 변환은 제안에 포함되지 않습니다. 개시자가 응답자에게 선택적으로 변환을 사용하려는 경우 옵션 중 하나로 변환 ID = 0인 변환 하위 구조가 포함됩니다.

o 변환 ID\(2 옥텟\) - 제안되는 변환 유형의 특정 인스턴스입니다.

변환 유형 값은 아래에 나열되어 있습니다. 다음 표의 값은 RFC 4306 발행일 현재의 값입니다. 그 이후로 다른 값이 추가되었거나 이 문서가 발행된 후에 추가될 것입니다. 최신 값은 \[IKEV2IANA\]를 참조하세요.

```text
   Description                     Trans.  Used In
                                   Type
   ------------------------------------------------------------------
   Encryption Algorithm (ENCR)     1       IKE and ESP
   Pseudorandom Function (PRF)     2       IKE
   Integrity Algorithm (INTEG)     3       IKE*, AH, optional in ESP
   Diffie-Hellman Group (D-H)      4       IKE, optional in AH & ESP
   Extended Sequence Numbers (ESN) 5       AH and ESP
```

\(\*\) 본 문서에 명시된 암호화된 페이로드 형식에는 무결성 알고리즘 협상이 필수입니다. 예를 들어 \[AEAD\]는 별도의 무결성 알고리즘이 협상되지 않는 인증된 암호화를 기반으로 추가 형식을 지정합니다.

변환 유형 1\(암호화 알고리즘\)의 경우 변환 ID가 아래에 나열됩니다. 다음 표의 값은 RFC 4306 발행일 현재의 값입니다. 그 이후로 다른 값이 추가되었거나 이 문서가 발행된 후에 추가될 것입니다. 최신 값은 \[IKEV2IANA\]를 참조하세요.

```text
   Name                 Number      Defined In
   ---------------------------------------------------
   ENCR_DES_IV64        1           (UNSPECIFIED)
   ENCR_DES             2           [RFC2405], [DES]
   ENCR_3DES            3           [RFC2451]
   ENCR_RC5             4           [RFC2451]
   ENCR_IDEA            5           [RFC2451], [IDEA]
   ENCR_CAST            6           [RFC2451]
   ENCR_BLOWFISH        7           [RFC2451]
   ENCR_3IDEA           8           (UNSPECIFIED)
   ENCR_DES_IV32        9           (UNSPECIFIED)
   ENCR_NULL            11          [RFC2410]
   ENCR_AES_CBC         12          [RFC3602]
   ENCR_AES_CTR         13          [RFC3686]
```

변환 유형 2\(의사 랜덤 함수\)의 경우 변환 ID가 아래에 나열됩니다. 다음 표의 값은 RFC 4306 발행일 현재의 값입니다. 그 이후로 다른 값이 추가되었거나 이 문서가 발행된 후에 추가될 것입니다. 최신 값은 \[IKEV2IANA\]를 참조하세요.

```text
   Name                        Number    Defined In
   ------------------------------------------------------------------
   PRF_HMAC_MD5                1         [RFC2104], [MD5]
   PRF_HMAC_SHA1               2         [RFC2104], [FIPS.180-4.2012]
   PRF_HMAC_TIGER              3         (UNSPECIFIED)
```

변환 유형 3\(무결성 알고리즘\)의 경우 정의된 변환 ID가 아래에 나열됩니다. 다음 표의 값은 RFC 4306 발행일 현재의 값입니다. 그 이후로 다른 값이 추가되었거나 이 문서가 발행된 후에 추가될 것입니다. 최신 값은 \[IKEV2IANA\]를 참조하세요.

```text
   Name                 Number   Defined In
   ----------------------------------------
   NONE                 0
   AUTH_HMAC_MD5_96     1        [RFC2403]
   AUTH_HMAC_SHA1_96    2        [RFC2404]
   AUTH_DES_MAC         3        (UNSPECIFIED)
   AUTH_KPDK_MD5        4        (UNSPECIFIED)
   AUTH_AES_XCBC_96     5        [RFC3566]
```

변환 유형 4\(Diffie-Hellman 그룹\)의 경우 정의된 변환 ID가 아래에 나열되어 있습니다. 다음 표의 값은 RFC 4306 발행일 현재의 값입니다. 그 이후로 다른 값이 추가되었거나 이 문서가 발행된 후에 추가될 것입니다. 최신 값은 \[IKEV2IANA\]를 참조하세요.

```text
   Name                Number      Defined In
   ------------------------------------------
   NONE                    0
   768-bit MODP Group      1       Appendix B
   1024-bit MODP Group     2       Appendix B
   1536-bit MODP Group     5       [ADDGROUP]
   2048-bit MODP Group     14      [ADDGROUP]
   3072-bit MODP Group     15      [ADDGROUP]
   4096-bit MODP Group     16      [ADDGROUP]
   6144-bit MODP Group     17      [ADDGROUP]
   8192-bit MODP Group     18      [ADDGROUP]
```

ESP와 AH는 Diffie-Hellman 교환을 직접 포함하지 않지만 Diffie-Hellman 그룹은 Child SA에 대해 협상될 수 있습니다. 이를 통해 피어는 CREATE\_CHILD\_SA 교환에서 Diffie-Hellman을 사용하여 생성된 하위 SA 키에 대한 완벽한 순방향 보안을 제공할 수 있습니다.\(MAY\)

위에 나열된 MODP Diffie-Hellman 그룹은 특별한 유효성 테스트를 수행할 필요가 없지만 다른 유형의 그룹\(타원 곡선 그룹 및 작은 하위 그룹이 있는 MODP 그룹\)에서는 이를 사용하기 위해 몇 가지 추가 테스트를 수행해야 합니다. 안전하게. 자세한 내용은 "IKEv2에 대한 추가 Diffie-Hellman 테스트"\(\[RFC6989\]\)를 참조하세요.

변환 유형 5\(확장된 시퀀스 번호\)의 경우 정의된 변환 ID가 아래에 나열됩니다. 다음 표의 값은 RFC 4306 발행일 현재의 값입니다. 그 이후로 다른 값이 추가되었거나 이 문서가 발행된 후에 추가될 것입니다. 최신 값은 \[IKEV2IANA\]를 참조하세요.

```text
   Name                               Number
   --------------------------------------------
   No Extended Sequence Numbers       0
   Extended Sequence Numbers          1
```

ESN을 지원하는 개시자는 일반적으로 제안서에 값이 "0"과 "1"인 두 개의 ESN 변환을 포함합니다. 값이 "1"인 단일 ESN 변환을 포함하는 제안은 일반\(확장되지 않은\) 시퀀스 번호를 사용할 수 없음을 의미합니다.

RFC 4306이 발행된 이후 수많은 추가 변환 유형이 정의되었습니다. 자세한 내용은 IANA "IKEv2\(Internet Key Exchange Version 2\) 매개변수" 레지스트리를 참조하십시오.

---
#### **3.3.3.  Valid Transform Types by Protocol**

SA 페이로드에 수반되는 변환의 수와 유형은 SA 자체의 프로토콜에 따라 다릅니다. SA 수립을 제안하는 SA 페이로드는 다음과 같은 필수 및 선택적인 변환 유형을 갖는다. 규정을 준수하는 구현은 지원하는 각 프로토콜에 대한 모든 필수 및 선택 유형을 이해해야 합니다\(허용되지 않는 제품군이 있는 제안을 수락할 필요는 없지만\). 제안서에서 허용할 유일한 값이 NONE인 경우 선택적 유형을 생략할 수 있습니다.\(MUST, MAY\)

```text
   Protocol    Mandatory Types          Optional Types
   ---------------------------------------------------
   IKE         ENCR, PRF, INTEG*, D-H
   ESP         ENCR, ESN                INTEG, D-H
   AH          INTEG, ESN               D-H
```

\(\*\) 본 문서에 명시된 암호화된 페이로드 형식에는 무결성 알고리즘 협상이 필수입니다. 예를 들어 \[AEAD\]는 별도의 무결성 알고리즘이 협상되지 않는 인증된 암호화를 기반으로 추가 형식을 지정합니다.

---
#### **3.3.4.  Mandatory Transform IDs**

상호 운용성을 위해 지원해야 하고 지원해야 하는 제품군의 사양은 이 문서가 발전하는 것보다 더 빠르게 변경될 가능성이 높기 때문에 이 문서에서 제거되었습니다. 이 문서를 발행할 당시 \[RFC4307\]은 이러한 제품군을 지정하지만 향후 업데이트될 수 있으며 다른 RFC는 다른 제품군 세트를 지정할 수 있습니다.\(MUST\)

IKEv1에서 배운 중요한 교훈은 어떤 시스템도 필수 알고리즘만 구현하고 모든 고객에게 최선의 선택이 되기를 기대해서는 안 된다는 것입니다.

IANA는 향후 추가 변환을 추가할 가능성이 높으며 일부 사용자는 특히 구현이 특정 크기 제한까지 다양한 매개변수를 지원할 수 있어야 하는 IKE의 경우 개인 제품군을 사용하기를 원할 수 있습니다. 이 목표를 지원하기 위해 IKEv2의 모든 구현에는 새로운 Diffie-Hellman 그룹에 대한 Diffie-Hellman 매개변수\(생성기, 모듈러스, 지수 길이 및 값\)의 사양\(사용자 또는 시스템 관리자가\)을 허용하는 관리 기능이 포함되어야 합니다. 구현은 다음과 같습니다.\(SHOULD, SHOULD\)

이러한 그룹을 협상할 수 있도록 사용자 또는 시스템 관리자가 이러한 매개변수 및 관련 변환 ID를 입력할 수 있는 관리 인터페이스를 제공합니다.

IKEv2의 모든 구현에는 사용자 또는 시스템 관리자가 IKE와 함께 사용할 수 있는 제품군을 지정할 수 있는 관리 기능이 포함되어야 합니다. 변환 ID 세트가 포함된 페이로드를 수신하면 구현에서는 전송된 변환 ID를 관리 제어를 통해 로컬로 구성된 변환 ID와 비교하여 제안된 제품군이 로컬 정책에 따라 허용되는지 확인해야 합니다. 구현에서는 이러한 IKE 제품군 제어에 의해 승인되지 않은 SA 제안을 거부해야 합니다. 구현해야 하는 암호화 제품군은 로컬 정책에 허용되도록 구성할 필요가 없습니다.\(MUST, MUST, MUST, MUST\)

---
#### **3.3.5.  Transform Attributes**

보안 연관 페이로드의 각 변환에는 변환 사양을 수정하거나 완성하는 속성이 포함될 수 있습니다. 유효한 속성 세트는 변환에 따라 다릅니다. 현재는 단일 속성 유형만 정의됩니다. 키 길이 속성은 가변 길이 키를 사용하는 특정 암호화 변환에 사용됩니다\(자세한 내용은 아래 참조\).

속성은 유형/값 쌍이며 아래에 정의되어 있습니다. 속성은 고정된 2옥텟 길이 값 또는 가변 길이 값을 가질 수 있습니다. 후자의 경우 속성은 유형/길이/값으로 인코딩됩니다.

```text
                        1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |A|       Attribute Type        |    AF=0  Attribute Length     |
   |F|                             |    AF=1  Attribute Value      |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                   AF=0  Attribute Value                       |
   |                   AF=1  Not Transmitted                       |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                         Figure 9: Data Attributes
```

o 속성 형식\(AF\)\(1비트\) - 데이터 속성이 유형/길이/값\(TLV\) 형식을 따르는지 또는 단축된 유형/값\(TV\) 형식을 따르는지 여부를 나타냅니다. AF 비트가 0이면 속성은 TLV 형식을 사용합니다. AF 비트가 1이면 TV 형식\(2바이트 값 포함\)이 사용됩니다.

o 속성 유형\(15비트\) - 각 속성 유형에 대한 고유 식별자입니다\(아래 참조\).

o 속성 값\(가변 길이\) - 속성 유형과 연관된 속성의 값입니다. AF 비트가 0인 경우 이 필드에는 속성 길이 필드에 의해 정의된 가변 길이가 있습니다. AF 비트가 1인 경우 속성 값의 길이는 2옥텟입니다.

현재 정의된 유일한 속성 유형\(키 길이\)은 고정 길이입니다. 가변 길이 인코딩 사양은 향후 확장에만 포함됩니다. 고정 길이로 기술된 속성은 해당 길이가 2바이트를 초과하지 않는 한 가변 길이 인코딩을 사용하여 인코딩되어서는 안 됩니다. 가변 길이 속성은 그 값이 두 개의 옥텟에 들어갈 수 있더라도 고정 길이로 인코딩되어서는 안 됩니다. 참고: 이는 IKEv1에서 변경된 사항으로, 유연성이 향상되어 메시지 작성이 단순화되었을 수 있지만 파서는 확실히 복잡해졌습니다.\(MUST NOT, MUST NOT\)

다음 표의 값은 RFC 4306 발행일 현재의 값입니다. 그 이후로 다른 값이 추가되었거나 이 문서가 발행된 후에 추가될 것입니다. 최신 값은 \[IKEV2IANA\]를 참조하세요.

```text
   Attribute Type         Value         Attribute Format
   ------------------------------------------------------------
   Key Length (in bits)   14            TV
```

0-13 및 15-17 값은 IKEv1의 유사한 맥락에서 사용되었으며 일치하는 값을 제외하고는 할당되어서는 안 됩니다.

Key Length 속성은 다음과 같이 특정 변환에 대해 키 길이를 비트 단위로 지정합니다\(네트워크 바이트 순서를 사용해야 함\).\(MUST\)

o 키 길이 속성은 고정 길이 키를 사용하는 변환과 함께 사용되어서는 안 됩니다. 예를 들어 여기에는 ENCR\_DES, ENCR\_IDEA와 이 문서에 지정된 모든 유형 2\(의사 난수 함수\) 및 유형 3\(무결성 알고리즘\) 변환이 포함됩니다. 향후 유형 2 또는 3 변환에서는 이 속성을 사용하지 않는 것이 좋습니다.\(MUST NOT\)

o 일부 변환에서는 키 길이 속성이 항상 포함되어야 함을 지정합니다\(속성을 생략하는 것은 허용되지 않으며 이를 포함하지 않는 제안은 반드시 거부되어야 합니다\). 예를 들어 여기에는 ENCR\_AES\_CBC 및 ENCR\_AES\_CTR이 포함됩니다.\(MUST\)

o 일부 변환에서는 가변 길이 키를 허용하지만 속성이 포함되지 않은 경우 기본 키 길이도 지정합니다. 예를 들어 이러한 변환에는 ENCR\_RC5 및 ENCR\_BLOWFISH가 포함됩니다.

구현 참고 사항: 상호 운용성을 높이고 독립적인 엔드포인트 업그레이드를 지원하기 위해 이 프로토콜의 구현자는 더 강력한 보안을 제공하는 것으로 간주되는 값을 수락해야 합니다. 예를 들어, 피어가 키 길이가 X 비트인 가변 길이 암호를 허용하도록 구성되어 있고 더 큰 키 길이의 암호가 제공되는 경우 구현에서는 더 긴 키 사용을 지원하는 경우 제안을 수락해야 합니다.\(SHOULD, SHOULD\)

이 기능에 대한 지원을 통해 응답자는 "적어도" 특정 수준의 보안, 즉 "암호 Y에 대해 \_최소\_ X 비트의 키 길이"라는 개념을 표현할 수 있습니다. 그러나 속성은 항상 변경되지 않은 상태로 반환되므로\(다음 섹션 참조\) 여러 키 길이를 허용하려는 개시자는 동일한 변환 유형을 사용하고 각각 다른 키 길이 속성을 갖는 여러 변환을 포함해야 합니다.

---
#### **3.3.6.  Attribute Negotiation**

보안 협회 협상 개시자는 응답자에게 제안을 제시합니다. 응답자는 제안에서 하나의 완전한 매개변수 세트를 선택해야 합니다\(또는 수용 가능한 제안이 없으면 모든 제안을 거부해야 합니다\). 여러 제안이 있는 경우 응답자는 단일 제안을 선택해야 합니다. 선택한 제안에 동일한 유형의 여러 변환이 있는 경우 응답자는 단일 변환을 선택해야 합니다. 선택한 변환의 모든 속성은 수정되지 않은 상태로 반환되어야 합니다. 교환 개시자는 수락된 제안이 제안 중 하나와 일치하는지 확인해야 하며, 그렇지 않은 경우 교환을 종료해야 합니다.\(MUST, MUST, MUST, MUST, MUST\)

응답자가 이해하지 못하는 변환 유형이 포함된 제안이나 필수 변환 유형이 누락된 제안을 수신한 경우 이 제안을 수용할 수 없는 것으로 간주해야 합니다. 그러나 동일한 SA 페이로드의 다른 제안은 평소와 같이 처리됩니다. 마찬가지로, 응답자가 이해하지 못하는 변환을 수신하거나 이해하지 못하는 변환 속성을 포함하는 변환을 수신하는 경우에는 이 변환을 허용할 수 없는 것으로 간주해야 합니다. 동일한 변환 유형을 가진 다른 변환은 평소와 같이 처리됩니다. 이를 통해 향후에 새로운 변환 유형 및 변환 속성을 정의할 수 있습니다.\(MUST, MUST\)

Diffie-Hellman 그룹 협상에는 몇 가지 특별한 과제가 있습니다. SA 제안에는 동일한 메시지에 제안된 특성과 Diffie-Hellman 공개 번호\(KE\)가 포함됩니다. 초기 교환에서 개시자가 여러 Diffie-Hellman 그룹 중 하나를 사용하겠다고 제안하는 경우 응답자가 수락할 가능성이 가장 높은 그룹을 선택해야 합니다.\(SHOULD\)

해당 그룹에 해당하는 KE를 포함합니다. 응답자가 다른 Diffie-Hellman 그룹\(NONE 제외\)을 사용하여 제안을 선택하는 경우 응답자는 응답에서 올바른 그룹을 표시하고 개시자는 첫 번째 메시지를 재시도할 때 KE 값에 대해 해당 그룹의 요소를 선택해야 합니다. 그러나 중간자 다운그레이드 공격을 방지하기 위해 전체 지원 그룹 세트를 계속 제안해야 합니다. 제공된 제안 중 하나가 NONE의 Diffie-Hellman 그룹에 대한 것이고 응답자가 해당 Diffie-Hellman 그룹을 선택한 경우 개시자의 KE 페이로드를 무시하고 응답에서 KE 페이로드를 생략해야 합니다.\(SHOULD, SHOULD, MUST\)

---
### **3.4.  Key Exchange Payload**

이 문서에서 KE로 표시된 키 교환 페이로드는 Diffie-Hellman 키 교환의 일부로 Diffie-Hellman 공개 번호를 교환하는 데 사용됩니다. 키 교환 페이로드는 IKE 일반 페이로드 헤더와 Diffie-Hellman 공개 값 자체로 구성됩니다.

```text
                        1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   | Next Payload  |C|  RESERVED   |         Payload Length        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |   Diffie-Hellman Group Num    |           RESERVED            |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                                                               |
   ~                       Key Exchange Data                       ~
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                  Figure 10: Key Exchange Payload Format
```

키 교환 페이로드는 Diffie-Hellman 공개 값을 페이로드의 "키 교환 데이터" 부분에 복사하여 구성됩니다. MODP 그룹에 대한 Diffie-Hellman 공개 값의 길이는 지수화가 수행된 소수 모듈러스의 길이와 같아야 하며 필요한 경우 값 앞에 0비트를 추가해야 합니다.\(MUST\)

Diffie-Hellman 그룹 번호는 키 교환 데이터가 계산된 Diffie-Hellman 그룹을 식별합니다\(섹션 3.3.2 참조\). 이 Diffie-Hellman 그룹 번호는 동일한 메시지로 전송되는 SA 페이로드의 제안에 지정된 Diffie-Hellman 그룹과 일치해야 하며, 첫 번째 제안의 첫 번째 그룹에 있는 Diffie-Hellman 그룹\(있는 경우\)과 일치해야 합니다. 해당 SA 페이로드의 제안 중 어느 것도 Diffie-Hellman 그룹을 지정하지 않는 경우 KE 페이로드는 절대로\(MUST, MUST NOT\)

현재의. 선택한 제안이 다른 Diffie-Hellman 그룹\(NONE 제외\)을 사용하는 경우 메시지는 INVALID\_KE\_PAYLOAD 유형의 알림 페이로드로 거부되어야 합니다. 섹션 1.2 및 2.7도 참조하세요.\(MUST\)

키 교환 페이로드의 페이로드 유형은 34\(34\)입니다.

---
### **3.5.  Identification Payloads**

이 문서에서 IDi 및 IDr로 표시된 식별 페이로드를 통해 피어는 서로에게 ID를 주장할 수 있습니다. 이 ID는 정책 조회에 사용될 수 있지만 반드시 CERT 페이로드의 어떤 항목과도 ​​일치할 필요는 없습니다. 두 필드 모두 구현에서 액세스 제어 결정을 수행하는 데 사용될 수 있습니다. IDi/IDr 페이로드에서 ID\_IPV4\_ADDR/ID\_IPV6\_ADDR ID 유형을 사용하는 경우 IKEv2에서는 이 주소가 IKEv2 패킷의 IP 헤더 또는 TSi/TSr 페이로드의 모든 주소와 일치하도록 요구하지 않습니다. IDi/IDr의 내용은 순전히 상대방과 관련된 정책 및 인증 데이터를 가져오는 데 사용됩니다.

참고: IKEv1에서는 SA를 통과하는 데이터에 대한 TS\(트래픽 선택기\) 정보를 유지하기 위해 각 방향에서 두 개의 ID 페이로드가 사용되었습니다. IKEv2에서는 이 정보가 TS 페이로드로 전달됩니다\(섹션 3.13 참조\).

RFC 4301 \[IPSECARCH\]에 설명된 PAD\(Peer Authorization Database\)는 IKEv2에서 ID 페이로드의 사용을 설명하고 정책 세부 사항을 보다 구체적으로 처리하는 서비스를 제공하는 것 외에도 ID를 정책에 바인딩하기 위한 공식 모델을 제공합니다. 시행. PAD는 SPD와 IKE 보안 연결 관리 간의 링크를 제공하기 위한 것입니다. 자세한 내용은 RFC 4301의 섹션 4.4.3을 참조하세요.

식별 페이로드는 IKE 일반 페이로드 헤더와 그 뒤에 오는 식별 필드로 구성됩니다.

```text
                        1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   | Next Payload  |C|  RESERVED   |         Payload Length        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |   ID Type     |                 RESERVED                      |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                                                               |
   ~                   Identification Data                         ~
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                 Figure 11: Identification Payload Format
```

o ID 유형\(1옥텟\) - 사용되는 식별 유형을 지정합니다.

o 예약됨 - 0으로 전송되어야 합니다. 수신 시 무시해야 합니다.\(MUST\)

o 식별 데이터\(가변 길이\) - 식별 유형으로 표시되는 값입니다. 식별 데이터의 길이는 ID 페이로드 헤더의 크기로 계산됩니다.

식별 페이로드의 페이로드 유형은 IDi의 경우 35이고 Idr의 경우 36입니다.

다음 표에는 식별 유형 필드에 할당된 의미가 나열되어 있습니다. 다음 표의 값은 RFC 4306 발행일 현재의 값입니다. 그 이후로 다른 값이 추가되었거나 이 문서가 발행된 후에 추가될 것입니다. 최신 값은 \[IKEV2IANA\]를 참조하세요.

```text
   ID Type                           Value
   -------------------------------------------------------------------
   ID_IPV4_ADDR                        1
      A single four (4) octet IPv4 address.
```

ID\_FQDN 2

- 정규화된 도메인 이름 문자열입니다. ID\_FQDN의 예는 "example.com"입니다. 문자열에는 종결자\(예: NULL, CR 등\)가 포함되어서는 안 됩니다. ID\_FQDN의 모든 문자는 ASCII입니다. "국제화된 도메인 이름"의 경우 구문은 \[IDNA\]에 정의된 것과 같습니다\(예: "xn--tmonesimerkki-bfbb.example.net"\).\(MUST NOT\)

ID\_RFC822\_ADDR 3

- 정규화된 RFC 822 이메일 주소 문자열입니다. ID\_RFC822\_ADDR의 예는 "jsmith@example.com"입니다. 문자열에는 종결자가 포함되어서는 안 됩니다. \[EAI\]로 인해 구현에서는 이 필드를 순수 ASCII가 아닌 UTF-8 인코딩 텍스트로 처리하는 것이 현명합니다.\(MUST NOT\)

ID\_IPV6\_ADDR 5

- 단일 16옥텟 IPv6 주소.

ID\_DER\_ASN1\_DN 9

- ASN.1 X.500 고유 이름 \[PKIX\]의 이진 DER\(고유 인코딩 규칙\) 인코딩입니다.

ID\_DER\_ASN1\_GN 10

- ASN.1 X.509 GeneralName \[PKIX\]의 바이너리 DER 인코딩입니다.

ID\_KEY\_ID 11

- 특정 독점 유형의 식별을 수행하는 데 필요한 공급업체별 정보를 전달하는 데 사용할 수 있는 불투명 옥텟 스트림입니다.

두 구현은 서로가 허용할 수 있는 ID 유형을 생성할 수 있는 경우에만 상호 운용됩니다. 최대 상호 운용성을 보장하려면 구현이 ID\_IPV4\_ADDR, ID\_FQDN, ID\_RFC822\_ADDR 또는 ID\_KEY\_ID 중 하나 이상을 전송하도록 구성 가능해야 하며 이러한 네 가지 유형을 모두 허용하도록 구성 가능해야 합니다. 구현은 이러한 모든 유형을 생성하고 수용할 수 있어야 합니다. IPv6 지원 구현은 ID\_IPV6\_ADDR을 허용하도록 추가로 구성 가능해야 합니다. IPv6 전용 구현은 IP 주소에 대해 ID\_IPV4\_ADDR 대신 ID\_IPV6\_ADDR만 보내도록 구성할 수 있습니다.\(MUST, SHOULD, MUST, MAY\)

EAP \[EAP\]는 특정 유형의 식별자 사용을 요구하지 않지만 종종 EAP는 \[NAI\]에 정의된 네트워크 액세스 식별자\(NAI\)와 함께 사용됩니다. NAI는 이메일 주소\(예: "joe@example.com"\)와 약간 비슷해 보이지만 구문은 \[MAILFORMAT\]의 이메일 주소 구문과 정확히 동일하지는 않습니다. 영역 구성 요소를 포함하는 NAI의 경우 ID\_RFC822\_ADDR 식별 유형을 사용해야 합니다. 응답자 구현은 내용이 실제로 \[MAILFORMAT\]에 제공된 정확한 구문을 준수하는지 확인하려고 시도해서는 안 되며, 대신 합리적으로 보이는 NAI를 수락해야 합니다. 영역 구성 요소를 포함하지 않는 NAI의 경우 ID\_KEY\_ID 식별 유형을 사용해야 합니다.\(SHOULD, SHOULD\)

식별 페이로드 일치와 PKIX 인증서 내용에 대한 자세한 내용은 "IKEv1/ISAKMP, IKEv2 및 PKIX의 인터넷 IP 보안 PKI 프로필"\(\[RFC4945\]\)을 참조하세요.

---
### **3.6.  Certificate Payload**

이 문서에서 CERT로 표시된 인증서 페이로드는 IKE를 통해 인증서 또는 기타 인증 관련 정보를 전송하는 수단을 제공합니다. 발신자가 인증서를 사용할 수 있는 경우 인증서 페이로드가 교환에 포함되어야 합니다. 피어가 HTTP\_CERT\_LOOKUP\_SUPPORTED 알림 페이로드를 사용하여 다른 곳에서 이 정보를 검색할 수 있는 기능을 표시한 경우 인증서 페이로드의 해시 및 URL 형식을 사용해야 합니다. 모든 인증 메커니즘이 인증서를 사용하는 것은 아니며 인증서 이외의 데이터가 이 페이로드에 전달될 수 있기 때문에 "인증서 페이로드"라는 용어는 다소 오해의 소지가 있습니다.\(SHOULD\)

인증서 페이로드는 다음과 같이 정의됩니다.

```text
                        1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   | Next Payload  |C|  RESERVED   |         Payload Length        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   | Cert Encoding |                                               |
   +-+-+-+-+-+-+-+-+                                               |
   ~                       Certificate Data                        ~
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                   Figure 12: Certificate Payload Format
```

o 인증서 인코딩\(1 옥텟\) - 이 필드는 인증서 데이터 필드에 포함된 인증서 유형 또는 인증서 관련 정보를 나타냅니다. 다음 표의 값은 RFC 4306 발행일 현재의 값입니다. 그 이후로 다른 값이 추가되었거나 이 문서가 발행된 후에 추가될 것입니다. 최신 값은 \[IKEV2IANA\]를 참조하세요.

```text
      Certificate Encoding                 Value
      ----------------------------------------------------
      PKCS #7 wrapped X.509 certificate    1   UNSPECIFIED
      PGP Certificate                      2   UNSPECIFIED
      DNS Signed Key                       3   UNSPECIFIED
      X.509 Certificate - Signature        4
      Kerberos Token                       6   UNSPECIFIED
      Certificate Revocation List (CRL)    7
      Authority Revocation List (ARL)      8   UNSPECIFIED
      SPKI Certificate                     9   UNSPECIFIED
      X.509 Certificate - Attribute        10  UNSPECIFIED
      Deprecated (was Raw RSA Key)         11  DEPRECATED
      Hash and URL of X.509 certificate    12
      Hash and URL of X.509 bundle         13
```

o 인증서 데이터\(가변 길이\) - 실제 인코딩

- 인증서 데이터. 인증서 유형은 인증서 인코딩 필드에 표시됩니다.

인증서 페이로드의 페이로드 유형은 37\(37\)입니다.

위 인증서 유형 코드 중 일부에 대한 특정 구문은 이 문서에 정의되어 있지 않습니다. 이 문서에 정의된 구문의 유형은 다음과 같습니다.

o "X.509 인증서 - 서명"에는 보낸 사람의 AUTH 페이로드를 확인하는 데 사용되는 공개 키가 있는 DER로 인코딩된 X.509 인증서가 포함되어 있습니다. 이 인코딩을 사용하면 인증서 체인을 전송해야 하는 경우 여러 CERT 페이로드가 사용되며 그 중 첫 번째 페이로드만 보낸 사람의 AUTH 페이로드를 확인하는 데 사용되는 공개 키를 보유합니다.

o "인증서 해지 목록"에는 DER로 인코딩된 X.509 인증서 해지 목록이 포함되어 있습니다.

o 해시 및 URL 인코딩을 사용하면 긴 데이터 구조를 대체된 값의 20옥텟 SHA-1 해시\(\[FIPS.180-4.2012\] 참조\)와 그 뒤에 다음으로 확인되는 가변 길이 URL로 대체하여 IKE 메시지를 짧게 유지할 수 있습니다. DER로 인코딩된 데이터 구조 자체입니다. 이렇게 하면 엔드포인트에 캐시된 인증서 데이터가 있을 때 효율성이 향상되고 IKE 메시지가 IP 조각화\[DOSUDPPROT\]를 요구할 만큼 충분히 클 때 마운트하기가 더 쉬워지는 DoS 공격에 덜 영향을 받게 됩니다.

"번들의 해시 및 URL" 유형은 X.509 번들에 대해 다음 ASN.1 정의를 사용합니다.

```text
   CertBundle
     { iso(1) identified-organization(3) dod(6) internet(1)
       security(5) mechanisms(5) pkix(7) id-mod(0)
       id-mod-cert-bundle(34) }

   DEFINITIONS EXPLICIT TAGS ::=
   BEGIN

   IMPORTS
     Certificate, CertificateList
     FROM PKIX1Explicit88
        { iso(1) identified-organization(3) dod(6)
          internet(1) security(5) mechanisms(5) pkix(7)
          id-mod(0) id-pkix1-explicit(18) } ;

   CertificateOrCRL ::= CHOICE {
     cert [0] Certificate,
     crl  [1] CertificateList }
```

CertificateBundle ::= 인증서 또는 CRL의 순서

```text
   END
```

구현은 인증을 지원하기 위해 최대 4개의 X.509 인증서를 보내고 수락하도록 구성할 수 있어야 하며, 두 가지 해시 및 URL 형식\(HTTP URL 포함\)을 보내고 수락하도록 구성할 수 있어야 합니다\(MUST\). 여러 인증서가 전송되는 경우 첫 번째 인증서에는 AUTH 페이로드에 서명하는 데 사용되는 개인 키와 연결된 공개 키가 포함되어야 합니다. 다른 인증서는 어떤 순서로든 보낼 수 있습니다.\(MUST, MUST\)

구현은 해시 및 URL 조회를 위한 "http:" 체계를 지원해야 합니다. 다른 URL 구성표\[URLS\]의 동작은 현재 지정되지 않았으며 이러한 구성표는 이를 지정하는 문서가 없는 경우 사용되어서는 안 됩니다.\(MUST, SHOULD NOT\)

---
### **3.7.  Certificate Request Payload**

이 문서에서 CERTREQ로 표시된 인증서 요청 페이로드는 IKE를 통해 기본 인증서를 요청하는 수단을 제공하며 IKE\_INIT\_SA 응답 및/또는 IKE\_AUTH 요청에 나타날 수 있습니다. 발신자가 수신자의 인증서를 받아야 할 때 인증서 요청 페이로드가 교환에 포함될 수 있습니다.\(MAY\)

인증서 요청 페이로드는 다음과 같이 정의됩니다.

```text
                        1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   | Next Payload  |C|  RESERVED   |         Payload Length        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   | Cert Encoding |                                               |
   +-+-+-+-+-+-+-+-+                                               |
   ~                    Certification Authority                    ~
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

               Figure 13: Certificate Request Payload Format
```

o 인증서 인코딩\(1 옥텟\) - 요청된 인증서 유형 또는 형식의 인코딩을 포함합니다. 값은 섹션 3.6에 나열되어 있습니다.

o 인증 기관\(가변 길이\) - 요청된 인증서 유형에 대해 허용되는 인증 기관의 인코딩을 포함합니다.

인증서 요청 페이로드의 페이로드 유형은 38입니다.

인증서 인코딩 필드는 섹션 3.6에 정의된 것과 동일한 값을 갖습니다. 인증 기관 필드에는 이 인증서 유형에 대한 신뢰할 수 있는 기관의 표시기가 포함되어 있습니다. 인증 기관 값은 신뢰할 수 있는 인증 기관\(CA\) 공개 키의 SHA-1 해시가 연결된 목록입니다. 각각은 각 Trust Anchor 인증서의 주체 공개 키 정보 요소\(\[PKIX\]의 섹션 4.1.2.7 참조\)의 SHA-1 해시로 인코딩됩니다. 20옥텟 해시는 다른 형식 없이 연결되어 포함됩니다.

인증 기관 필드의 내용은 유형 4, 12 및 13인 X.509 인증서에 대해서만 정의됩니다. 다른 값은 해당 용도를 지정하는 표준 트랙 사양이 게시될 때까지 사용해서는 안 됩니다.\(SHOULD NOT\)

인증서 이외의 값은 "인증서" 페이로드에 정의되고 해당 값에 대한 요청은 인증서 요청 페이로드에 존재할 수 있다는 점에서 "인증서 요청"이라는 용어는 다소 오해의 소지가 있습니다. 이러한 경우 인증서 요청 페이로드의 구문은 이 문서에 정의되어 있지 않습니다.

인증서 요청 페이로드는 프로세서에 이 유형의 인증서가 있는지 확인하기 위해 인증서 인코딩 필드를 검사하여 처리됩니다. 그렇다면 인증 기관 필드를 검사하여 프로세서에 지정된 인증 기관 중 하나까지 유효성을 검사할 수 있는 인증서가 있는지 확인합니다. 이는 인증서 체인일 수 있습니다.

CERTREQ에 지정된 기준을 충족하는 최종 엔터티 인증서가 존재하는 경우 인증서 또는 인증서 체인은 CERTREQ 수신자가 다음과 같은 경우 인증서 요청자에게 다시 전송되어야 합니다.\(SHOULD\)

o 인증서 인증을 사용하도록 구성되어 있습니다.

o CERT 페이로드를 보내는 것이 허용됩니다.

o 현재 협상을 관리하는 일치하는 CA 신뢰 정책이 있으며,

o CERTREQ에 제공된 CA에 연결되는 시간별, 용도에 적합한 최종 엔터티 인증서가 하나 이상 있습니다.

인증서를 선택하는 데 사용되는 연결 프로세스 중에 인증서 해지 확인을 고려해야 합니다. 두 개의 피어가 두 개의 서로 다른 CA를 사용하도록 구성된 경우에도 적절한 선택 논리를 통해 교차 인증 관계가 지원되어야 합니다.

그 의도는 교차 인증을 통해 전달되는 신뢰를 통해 수신자가 성공적으로 검증하고 신뢰할 수 있는 대체 인증서를 발신자가 선택할 수 있는 경우 CERTREQ 기반 인증서 선택을 엄격하게 준수하여 통신을 방해하려는 것이 아닙니다. CRL 또는 기타 대역 외 구성 수단. 따라서 CERTREQ 처리는 필수 인증서가 아닌 인증서 선택에 대한 제안으로 보아야 합니다. 인증서가 없으면 CERTREQ가 무시됩니다. 이는 프로토콜의 오류 조건이 아닙니다. CERTREQ에 기본 CA가 전송되었지만 대체 CA가 허용되는 경우가 있을 수 있습니다\(아마도 운영자에게 메시지를 보낸 후\).

HTTP\_CERT\_LOOKUP\_SUPPORTED 알림은 CERTREQ 페이로드를 포함할 수 있는 모든 메시지에 포함될 수 있으며 발신자가 HTTP 기반 URL을 기반으로 인증서를 검색할 수 있음을 나타냅니다\(따라서 아마도 해당 형식의 인증서 사양을 수신하는 것을 선호할 것입니다\).\(MAY\)

---
### **3.8.  Authentication Payload**

이 문서에서 AUTH로 표시된 인증 페이로드에는 인증 목적으로 사용되는 데이터가 포함되어 있습니다. 인증 데이터의 구문은 아래와 같이 인증 방법에 따라 달라집니다.

인증 페이로드는 다음과 같이 정의됩니다.

```text
                        1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   | Next Payload  |C|  RESERVED   |         Payload Length        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   | Auth Method   |                RESERVED                       |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                                                               |
   ~                      Authentication Data                      ~
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                 Figure 14: Authentication Payload Format
```

o 인증 방법\(1옥텟\) - 사용되는 인증 방법을 지정합니다. 서명 유형이 여기에 나열되어 있습니다. 다음 표의 값은 RFC 4306 발행일 현재의 값입니다. 그 이후로 다른 값이 추가되었거나 이 문서가 발행된 후에 추가될 것입니다. 최신 값은 \[IKEV2IANA\]를 참조하세요.

```text
   Mechanism                              Value
   -----------------------------------------------------------------
   RSA Digital Signature                  1
      Computed as specified in Section 2.15 using an RSA private key
      with RSASSA-PKCS1-v1_5 signature scheme specified in [PKCS1]
      (implementers should note that IKEv1 used a different method for
      RSA signatures).  To promote interoperability, implementations
      that support this type SHOULD support signatures that use SHA-1
      as the hash function and SHOULD use SHA-1 as the default hash
      function when generating signatures.  Implementations can use the
      certificates received from a given peer as a hint for selecting a
      mutually understood hash function for the AUTH payload signature.
      Note, however, that the hash algorithm used in the AUTH payload
      signature doesn't have to be the same as any hash algorithm(s)
      used in the certificate(s).
```

공유 키 메시지 무결성 코드 2

- ID 페이로드의 ID와 협상된 PRF와 관련된 공유 키를 사용하여 섹션 2.15에 지정된 대로 계산됩니다.

DSS 디지털 서명 3

- SHA-1 해시를 통해 DSS 개인 키\(\[DSS\] 참조\)를 사용하여 섹션 2.15에 지정된 대로 계산됩니다.

o 예약됨 - 0으로 전송되어야 합니다. 수신 시 무시해야 합니다.\(MUST\)

```text
   o  Authentication Data (variable length) - see Section 2.15.
```

인증 페이로드의 페이로드 유형은 39\(39\)입니다.

---
### **3.9.  Nonce Payload**

이 문서에서 개시자와 응답자의 논스에 대해 각각 Ni 및 Nr로 표시된 Nonce 페이로드에는 교환 중 활성을 보장하고 재생 공격으로부터 보호하는 데 사용되는 무작위 데이터가 포함되어 있습니다.

Nonce 페이로드는 다음과 같이 정의됩니다.

```text
                        1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   | Next Payload  |C|  RESERVED   |         Payload Length        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                                                               |
   ~                            Nonce Data                         ~
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                      Figure 15: Nonce Payload Format
```

o Nonce 데이터\(가변 길이\) - 전송 엔터티에서 생성된 무작위 데이터를 포함합니다.

Nonce 페이로드의 페이로드 유형은 40입니다.

Nonce 데이터의 크기는 16\~256옥텟이어야 합니다. Nonce 값은 재사용하면 안 됩니다.\(MUST, MUST NOT\)

---
### **3.10.  Notify Payload**

이 문서에서 N으로 표시된 Notify 페이로드는 오류 조건 및 상태 전환과 같은 정보 데이터를 IKE 피어로 전송하는 데 사용됩니다. 알림 페이로드는 응답 메시지\(일반적으로 요청이 거부된 이유 지정\), INFORMATIONAL 교환\(IKE 요청이 아닌 오류를 보고하기 위해\) 또는 발신자 기능을 나타내거나 메시지의 의미를 수정하기 위해 다른 메시지에 나타날 수 있습니다. 요청.

알림 페이로드는 다음과 같이 정의됩니다.

```text
                        1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   | Next Payload  |C|  RESERVED   |         Payload Length        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |  Protocol ID  |   SPI Size    |      Notify Message Type      |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                                                               |
   ~                Security Parameter Index (SPI)                 ~
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                                                               |
   ~                       Notification Data                       ~
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                     Figure 16: Notify Payload Format
```

o 프로토콜 ID\(1옥텟\) - 이 알림이 SPI 필드에 SPI가 제공된 기존 SA와 관련된 경우 이 필드는 해당 SA의 유형을 나타냅니다. 하위 SA에 관한 알림의 경우 이 필드에는 AH를 나타내는 \(2\) 또는 ESP를 나타내는 \(3\)이 포함되어야 합니다. 이 문서에 정의된 알림 중 SPI는 INVALID\_SELECTORS, REKEY\_SA 및 CHILD\_SA\_NOT\_FOUND에만 포함됩니다. SPI 필드가 비어 있는 경우 이 필드는 0으로 전송되어야 하며 수신 시 무시되어야 합니다.\(MUST, MUST\)

o SPI 크기\(1옥텟\) - IPsec 프로토콜 ID로 정의된 SPI의 옥텟 길이입니다. 적용 가능한 SPI가 없으면 0입니다. IKE SA에 관한 알림의 경우 SPI 크기는 0이어야 하며 필드는 비어 있어야 합니다.\(MUST\)

o 알림 메시지 유형\(2옥텟\) - 알림 유형을 지정합니다.

- 알림 메시지.

```text
   o  SPI (variable length) - Security Parameter Index.
```

o 알림 데이터\(가변 길이\) - 알림 메시지 유형 외에 전송되는 상태 또는 오류 데이터입니다. 이 필드의 값은 유형별로 다릅니다\(아래 참조\).

알림 페이로드의 페이로드 유형은 41입니다.

---
#### **3.10.1.  Notify Message Types**

알림 정보는 SA를 설정할 수 없는 이유를 지정하는 오류 메시지일 수 있습니다. SA 데이터베이스를 관리하는 프로세스가 피어 프로세스와 통신하기를 원하는 상태 데이터일 수도 있습니다.

아래 표에는 알림 메시지와 해당 값이 나열되어 있습니다. 단순화와 프로버에 구성 정보 제공을 방지하기 위해 다양한 오류 상태의 수가 IKEv1에서 크게 줄었습니다.

0 - 16383 범위의 유형은 오류 보고용입니다. 응답에서 인식하지 못하는 이러한 유형 중 하나가 포함된 알림 페이로드를 수신하는 구현은 해당 요청이 완전히 실패했다고 가정해야 합니다\(MUST\). 요청에서 인식할 수 없는 오류 유형과 요청 또는 응답의 상태 유형은 무시되어야 하며 기록되어야 합니다.\(MUST, MUST\)

상태 유형이 있는 알림 페이로드는 모든 메시지에 추가될 수 있으며 인식되지 않으면 무시해야 합니다. 이는 기능을 나타내기 위한 것이며 SA 협상의 일부로 비암호화 매개변수를 협상하는 데 사용됩니다.\(MUST\)

오류 처리에 대한 자세한 내용은 섹션 2.21에서 확인할 수 있습니다.

다음 표의 값은 RFC 4306 발행일 현재의 값과 이 문서에 추가된 두 가지 오류 유형입니다. 그 이후로 다른 값이 추가되었거나 이 문서가 출판된 후에 추가될 예정입니다. 최신 값은 \[IKEV2IANA\]를 참조하세요.

```text
   NOTIFY messages: error types              Value
   -------------------------------------------------------------------
   UNSUPPORTED_CRITICAL_PAYLOAD              1
       See Section 2.5.

   INVALID_IKE_SPI                           4
       See Section 2.21.

   INVALID_MAJOR_VERSION                     5
       See Section 2.5.

   INVALID_SYNTAX                            7
       Indicates the IKE message that was received was invalid because
       some type, length, or value was out of range or because the
       request was rejected for policy reasons.  To avoid a DoS
       attack using forged messages, this status may only be
       returned for and in an encrypted packet if the Message ID and
```

- 암호화 체크섬이 유효했습니다. 노드를 조사하는 사람에게 정보가 유출되는 것을 방지하려면 이 상태를 다른 상태 유형 중 하나에 포함되지 않은 오류에 대한 응답으로 전송해야 합니다. 디버깅을 돕기 위해 더 자세한 오류 정보를 콘솔이나 로그에 기록해야 합니다.\(MUST\)

```text
   INVALID_MESSAGE_ID                        9
       See Section 2.3.

   INVALID_SPI                              11
       See Section 1.5.
```

NO\_PROPOSAL\_CHOSEN 14

- 제안된 암호화 제품군 중 어느 것도 허용되지 않았습니다. 이는 제공된 제안\(SA 페이로드 값, USE\_TRANSPORT\_MODE 알림, IPCOMP\_SUPPORTED 알림을 포함하되 이에 국한되지 않음\)이 응답자에게 허용되지 않는 경우에 전송될 수 있습니다. 이는 다른 이유로 하위 SA를 만들 수 없는 경우 "일반" 하위 SA 오류로 사용될 수도 있습니다. 섹션 2.7도 참조하세요.

INVALID\_KE\_PAYLOAD 17

- 섹션 1.2 및 1.3을 참조하세요.

인증\_실패 24

- 어떤 이유로 인증이 실패했을 때 IKE\_AUTH 메시지에 대한 응답으로 전송됩니다. 연관된 데이터가 없습니다. 섹션 2.21.2도 참조하세요.

```text
   SINGLE_PAIR_REQUIRED                     34
       See Section 2.9.

   NO_ADDITIONAL_SAS                        35
       See Section 1.3.

   INTERNAL_ADDRESS_FAILURE                 36
       See Section 3.15.4.

   FAILED_CP_REQUIRED                       37
       See Section 2.19.

   TS_UNACCEPTABLE                          38
       See Section 2.9.
```

INVALID\_SELECTORS 39

- 노드가 전달된 SA의 선택기와 일치하지 않는 ESP 또는 AH 패킷을 노드가 수신할 때 IKE INFORMATIONAL 교환으로 전송될 수 있습니다\(그리고 이로 인해 패킷이 삭제되었습니다\). 알림 데이터에는 문제가 되는 패킷의 시작\(ICMP 메시지와 같이\)이 포함되어 있으며 알림의 SPI 필드는 하위 SA의 SPI와 일치하도록 설정됩니다.\(MAY\)

```text
   TEMPORARY_FAILURE                        43
       See Section 2.25.

   CHILD_SA_NOT_FOUND                       44
       See Section 2.25.

   NOTIFY messages: status types            Value
   -------------------------------------------------------------------
   INITIAL_CONTACT                          16384
       See Section 2.4.

   SET_WINDOW_SIZE                          16385
       See Section 2.3.

   ADDITIONAL_TS_POSSIBLE                   16386
       See Section 2.9.

   IPCOMP_SUPPORTED                         16387
       See Section 2.22.

   NAT_DETECTION_SOURCE_IP                  16388
       See Section 2.23.

   NAT_DETECTION_DESTINATION_IP             16389
       See Section 2.23.

   COOKIE                                   16390
       See Section 2.6.

   USE_TRANSPORT_MODE                       16391
       See Section 1.3.1.

   HTTP_CERT_LOOKUP_SUPPORTED               16392
       See Section 3.6.

   REKEY_SA                                 16393
       See Section 1.3.3.

   ESP_TFC_PADDING_NOT_SUPPORTED            16394
       See Section 1.3.1.

   NON_FIRST_FRAGMENTS_ALSO                 16395
       See Section 1.3.1.
```

---
### **3.11.  Delete Payload**

이 문서에서 D로 표시된 삭제 페이로드에는 보낸 사람이 보안 연결 데이터베이스에서 제거한 프로토콜별 보안 연결 식별자가 포함되어 있으므로 더 이상 유효하지 않습니다. 그림 17은 삭제 페이로드의 형식을 보여줍니다. 삭제 페이로드에서 여러 SPI를 보낼 수 있습니다. 그러나 각 SPI는 동일한 프로토콜을 위한 것이어야 합니다. 프로토콜 식별자의 혼합은 삭제 페이로드에서 수행되어서는 안 됩니다. 그러나 각 삭제 페이로드가 서로 다른 프로토콜에 대한 SPI를 나열하는 단일 정보 교환에 여러 삭제 페이로드를 포함하는 것은 허용됩니다.\(MUST, MUST NOT\)

IKE SA 삭제는 프로토콜 ID 1\(IKE\)로 표시되지만 SPI는 없습니다. ESP 또는 AH와 같은 하위 SA를 삭제하면 해당 프로토콜의 IPsec 프로토콜 ID\(AH의 경우 2, ESP의 경우 3\)가 포함되며 SPI는 송신 엔드포인트가 인바운드 ESP 또는 AH 패킷에서 예상하는 SPI입니다.

삭제 페이로드는 다음과 같이 정의됩니다.

```text
                        1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   | Next Payload  |C|  RESERVED   |         Payload Length        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   | Protocol ID   |   SPI Size    |          Num of SPIs          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                                                               |
   ~               Security Parameter Index(es) (SPI)              ~
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                     Figure 17: Delete Payload Format
```

o 프로토콜 ID\(1옥텟\) - IKE SA의 경우 1, AH의 경우 2, ESP의 경우 3이어야 합니다.

o SPI 크기\(1옥텟\) - 프로토콜 ID에 의해 정의된 SPI의 옥텟 길이입니다. IKE\(SPI는 메시지 헤더에 있음\)의 경우 0이어야 하고 AH 및 ESP의 경우 4여야 합니다.\(MUST\)

o SPI 수\(2옥텟, 부호 없는 정수\) - 삭제 페이로드에 포함된 SPI 수입니다. 각 SPI의 크기는 SPI 크기 필드에 의해 정의됩니다.

o 보안 매개변수 색인\(가변 길이\) - 삭제할 특정 보안 연관을 식별합니다. 이 필드의 길이는 SPI 크기 및 SPI 수 필드에 따라 결정됩니다.

삭제 페이로드의 페이로드 유형은 42입니다.

---
### **3.12.  Vendor ID Payload**

이 문서에서 V로 표시된 공급업체 ID 페이로드에는 공급업체에서 정의한 상수가 포함되어 있습니다. 상수는 공급업체가 구현의 원격 인스턴스를 식별하고 인식하는 데 사용됩니다. 이 메커니즘을 통해 공급업체는 이전 버전과의 호환성을 유지하면서 새로운 기능을 실험할 수 있습니다.

공급업체 ID 페이로드는 발신자가 프로토콜에 대한 특정 확장을 수락할 수 있음을 알리거나 단순히 디버깅을 돕기 위해 구현을 식별할 수도 있습니다. 공급업체 ID 페이로드는 이 사양에 정의된 정보의 해석을 변경해서는 안 됩니다\(즉, 중요 비트를 0으로 설정해야 합니다\). 여러 공급업체 ID 페이로드가 전송될 수 있습니다. 공급업체 ID 페이로드를 전송하기 위해 구현이 전혀 필요하지 않습니다.\(MAY, MUST NOT, MAY\)

공급업체 ID 페이로드는 메시지의 일부로 전송될 수 있습니다. 익숙한 공급업체 ID 페이로드를 수신하면 개인 페이로드, 개인 교환, 개인 알림 등과 같이 이 문서 전체에 설명된 개인 사용 번호를 사용할 수 있습니다. 익숙하지 않은 공급업체 ID는 무시해야 합니다.\(MUST\)

이 프로토콜을 확장하려는 문서 작성자는 문서에서 확장을 구현하는 기능을 알리기 위해 공급업체 ID 페이로드를 정의해야 합니다. 승인을 받고 표준화된 문서에는 IANA가 향후 사용 범위를 벗어나는 "마법의 숫자"를 부여하고 공급업체 ID 사용 요구 사항이 사라질 것으로 예상됩니다.\(MUST\)

공급업체 ID 페이로드 필드는 다음과 같이 정의됩니다.

```text
                        1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   | Next Payload  |C|  RESERVED   |         Payload Length        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                                                               |
   ~                        Vendor ID (VID)                        ~
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                    Figure 18: Vendor ID Payload Format
```

o 공급업체 ID\(가변 길이\) - ID에 대한 중앙 등록이 없더라도 공급업체 ID의 고유성을 보장하는 것은 공급업체 ID를 선택하는 사람의 책임입니다. 좋은 방법은 회사 이름, 사람 이름 또는 일부 정보를 포함하는 것입니다. 자랑하고 싶다면 ID를 선택했을 때 있었던 위도, 경도, 시간과 임의 입력을 포함할 수 있습니다. 긴 고유 문자열의 메시지 다이제스트가 긴 고유 문자열 자체보다 바람직합니다.

공급업체 ID 페이로드의 페이로드 유형은 43입니다.

---
### **3.13.  Traffic Selector Payload**

이 문서에서 TS로 표시된 트래픽 선택기 페이로드를 사용하면 피어가 IPsec 보안 서비스에서 처리할 패킷 흐름을 식별할 수 있습니다. 트래픽 선택기 페이로드는 다음과 같이 IKE 일반 페이로드 헤더와 그 뒤에 오는 개별 트래픽 선택기로 구성됩니다.

```text
                        1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   | Next Payload  |C|  RESERVED   |         Payload Length        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   | Number of TSs |                 RESERVED                      |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                                                               |
   ~                       <Traffic Selectors>                     ~
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                Figure 19: Traffic Selectors Payload Format
```

o TS 수\(1옥텟\) - 제공되는 트래픽 선택기 수입니다.

o RESERVED - 이 필드는 0으로 전송되어야 하며 수신 시 무시되어야 합니다.\(MUST\)

o 트래픽 선택기\(가변 길이\) - 하나 이상의 개별 트래픽 선택기입니다.

트래픽 선택기 페이로드의 길이에는 TS 헤더와 모든 트래픽 선택기가 포함됩니다.

트래픽 선택기 페이로드의 페이로드 유형은 SA의 개시자 끝에 있는 주소의 경우 44개이고 응답자의 끝에 있는 주소의 경우 45개입니다.

TSi와 TSr에 동일한 수의 개별 트래픽 선택기가 포함될 필요는 없습니다. 따라서 이는 다음과 같이 해석됩니다. 즉, 패킷이 TSi의 개별 선택기 중 적어도 하나와 TSr의 개별 선택기 중 적어도 하나와 일치하면 패킷은 주어진 TSi/TSr과 일치합니다.

예를 들어 다음 트래픽 선택기는 다음과 같습니다.

```text
   TSi = ((17, 100, 198.51.100.66-198.51.100.66),
          (17, 200, 198.51.100.66-198.51.100.66))
   TSr = ((17, 300, 0.0.0.0-255.255.255.255),
          (17, 400, 0.0.0.0-255.255.255.255))
```

소스/대상 포트 \(100,300\), \(100,400\), \(200,300\) 및 \(200, 400\)의 네 가지 조합 중 하나를 사용하여 198.51.100.66에서 어느 위치로든 UDP 패킷을 일치시킵니다.

따라서 일부 유형의 정책에는 여러 하위 SA 쌍이 필요할 수 있습니다. 예를 들어 원본/대상 포트\(100,300\) 및 \(200,400\)만 일치하고 다른 두 조합은 일치하지 않는 정책은 단일 하위 SA 쌍으로 협상될 수 없습니다.

---
#### **3.13.1.  Traffic Selector**

```text
                        1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |   TS Type     |IP Protocol ID*|       Selector Length         |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |           Start Port*         |           End Port*           |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                                                               |
   ~                         Starting Address*                     ~
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                                                               |
   ~                         Ending Address*                       ~
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                        Figure 20: Traffic Selector
```

\*참고: TS 유형 및 선택기 길이를 제외한 모든 필드는 TS 유형에 따라 다릅니다. 표시된 필드는 현재 정의된 유일한 두 값인 TS 유형 7 및 8에 대한 것입니다.

o TS 유형\(1옥텟\) - 트래픽 선택기의 유형을 지정합니다.

o IP 프로토콜 ID\(1옥텟\) - 관련 IP 프로토콜 ID\(예: UDP, TCP, ICMP\)를 지정하는 값입니다. 0 값은 프로토콜 ID가 이 트래픽 선택기와 관련이 없음을 의미합니다. 즉, SA는 모든 프로토콜을 전달할 수 있습니다.

o 선택기 길이\(2옥텟, 부호 없는 정수\) - 헤더를 포함하여 이 트래픽 선택기 하위 구조의 길이를 지정합니다.

o 시작 포트\(2옥텟, 부호 없는 정수\) - 이 트래픽 선택기가 허용하는 가장 작은 포트 번호를 지정하는 값입니다. 포트가 정의되지 않은 프로토콜\(프로토콜 0 포함\)의 경우 또는 모든 포트가 허용되는 경우 이 필드는 0이어야 합니다. ICMP 및 ICMPv6 유형 및 코드 값과 모바일 IP 버전 6\(MIPv6\) 이동성 헤더\(MH\) 유형 값은 \[IPSECARCH\]의 섹션 4.4.1.1에 지정된 대로 이 필드에 표시됩니다. ICMP 유형 및 코드 값은 단일 16비트 정수 포트 번호로 처리되며, 유형은 최상위 8비트에, 코드는 최하위 8비트에 포함됩니다. MIPv6 MH 유형 값은 단일 16비트 정수 포트 번호로 처리되며 유형은 최상위 8비트, 최하위 8비트는 0으로 설정됩니다.\(MUST\)

o 끝 포트\(2옥텟, 부호 없는 정수\) - 이 트래픽 선택기가 허용하는 가장 큰 포트 번호를 지정하는 값입니다. 포트가 정의되지 않은 프로토콜\(프로토콜 0 포함\) 또는 모든 포트가 허용되는 경우 이 필드는 65535여야 합니다. MIPv6 MH 유형 값뿐만 아니라 ICMP 및 ICMPv6 유형 및 코드 값은 이 필드에 지정된 대로 표시됩니다. \[IPSECARCH\]의 섹션 4.4.1.1. ICMP 유형 및 코드 값은 단일 16비트 정수 포트 번호로 처리되며, 유형은 최상위 8비트에, 코드는 최하위 8비트에 포함됩니다. MIPv6 MH 유형 값은 단일 16비트 정수 포트 번호로 처리되며 유형은 최상위 8비트, 최하위 8비트는 0으로 설정됩니다.\(MUST\)

o 시작 주소 - 이 트래픽 선택기에 포함된 가장 작은 주소입니다\(길이는 TS 유형에 따라 결정됨\).

o 종료 주소 - 이 트래픽 선택기에 포함된 가장 큰 주소입니다\(길이는 TS 유형에 따라 결정됨\).

"ANY" 포트를 표시하려는 \[IPSECARCH\]를 준수하는 시스템은 시작 포트를 0으로 설정하고 끝 포트를 65535로 설정해야 합니다. \[IPSECARCH\]에 따르면 "ANY"에는 "OPAQUE"가 포함됩니다. "OPAQUE" 포트를 나타내기를 원하는 \[IPSECARCH\]와 함께 작동하는 시스템은 "ANY" 포트를 나타내지 않고 시작 포트를 65535로 설정하고 끝 포트를 0으로 설정해야 합니다.\(MUST, MUST\)

트래픽 선택기 유형 7과 8은 IPv6 이동성 헤더\[MIPV6\]에 대한 MH 유형 필드뿐만 아니라 ICMP 또는 ICMPv6 유형 및 코드 필드를 참조할 수도 있습니다. 그러나 ICMP나 MIPv6 패킷에는 별도의 소스 및 대상 필드가 없습니다. ICMP 및 MIPv6에 대한 트래픽 선택기를 지정하는 방법은 \[IPSECARCH\]의 섹션 4.4.1.3에 예제로 나와 있습니다.

다음 표에는 트래픽 선택기 유형 필드와 해당 주소 선택기 데이터의 값이 나열되어 있습니다. 다음 표의 값은 RFC 4306 발행일 현재의 값입니다. 그 이후로 다른 값이 추가되었거나 이 문서가 발행된 후에 추가될 것입니다. 최신 값은 \[IKEV2IANA\]를 참조하세요.

```text
   TS Type                            Value
   -------------------------------------------------------------------
   TS_IPV4_ADDR_RANGE                  7
```

두 개의 4옥텟으로 표시되는 IPv4 주소 범위

- 가치. 첫 번째 값은 시작 IPv4 주소\(포함\)이고 두 번째 값은 끝 IPv4 주소\(포함\)입니다. 지정된 두 주소 사이에 있는 모든 주소는 목록 내에 있는 것으로 간주됩니다.

```text
   TS_IPV6_ADDR_RANGE                  8
```

- 두 개의 16옥텟 값으로 표시되는 IPv6 주소 범위입니다. 첫 번째 값은 시작 IPv6 주소\(포함\)이고 두 번째 값은 끝 IPv6 주소\(포함\)입니다. 지정된 두 주소 사이에 있는 모든 주소는 목록 내에 있는 것으로 간주됩니다.

---
### **3.14.  Encrypted Payload**

이 문서에서 SK {...}로 표시된 암호화된 페이로드에는 암호화된 형식의 다른 페이로드가 포함되어 있습니다. 암호화된 페이로드는 메시지에 있는 경우 메시지의 마지막 페이로드여야 합니다. 메시지의 유일한 페이로드인 경우가 많습니다. 이 페이로드는 "암호화 및 인증된" 페이로드라고도 합니다.\(MUST\)

암호화 및 무결성 보호를 위한 알고리즘은 IKE SA 설정 중에 협상되며 키는 섹션 2.14 및 2.18에 지정된 대로 계산됩니다.

이 문서에서는 CBC 모드의 블록 암호와 가변 크기 메시지에 대해 고정 길이 체크섬을 계산하는 무결성 검사 알고리즘을 사용하여 암호화된 페이로드의 암호화 처리를 지정합니다. 설계는 RFC 2104\[HMAC\], 4303\[ESP\] 및 2451\[ESPCBC\]에 설명된 ESP 알고리즘을 따라 모델링되었습니다. 이 문서는 IKE 데이터의 암호화 처리를 완벽하게 지정하지만 설계 이론적 근거는 해당 문서를 참조해야 합니다. 향후 문서에서는 카운터 모드 암호화 및 인증된 암호화 알고리즘과 같은 다른 유형의 변환에 대한 암호화된 페이로드 처리를 지정할 수 있습니다. 피어는 그러한 사양이 존재하지 않는 변환을 협상해서는 안 됩니다.\(MUST NOT\)

인증된 암호화 알고리즘을 사용하여 IKE SA를 보호하는 경우 암호화된 페이로드의 구성은 여기에 설명된 것과 다릅니다. 인증된 암호화 알고리즘 및 IKEv2에서의 사용에 대한 자세한 내용은 \[AEAD\]를 참조하세요.

암호화된 페이로드의 페이로드 유형은 46입니다. 암호화된 페이로드는 IKE 일반 페이로드 헤더와 그 뒤에 오는 개별 필드로 구성됩니다.

```text
                        1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   | Next Payload  |C|  RESERVED   |         Payload Length        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                     Initialization Vector                     |
   |         (length is block size for encryption algorithm)       |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   ~                    Encrypted IKE Payloads                     ~
   +               +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |               |             Padding (0-255 octets)            |
   +-+-+-+-+-+-+-+-+                               +-+-+-+-+-+-+-+-+
   |                                               |  Pad Length   |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   ~                    Integrity Checksum Data                    ~
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                    Figure 21: Encrypted Payload Format
```

o 다음 페이로드 - 첫 번째 내장 페이로드의 페이로드 유형입니다. 이는 표준 헤더 형식의 예외입니다. 암호화된 페이로드가 메시지의 마지막 페이로드이고 따라서 다음 페이로드 필드가 일반적으로 0이기 때문입니다. 하지만 이 페이로드의 콘텐츠는 내장된 페이로드이고 첫 번째 유형을 넣을 자연스러운 장소가 없었기 때문에 해당 유형을 여기에 배치했습니다.

o 페이로드 길이 - 헤더의 길이를 포함합니다.

- 초기화 벡터\(IV\), 암호화된 IKE 페이로드, 패딩, 패드 길이 및 무결성 체크섬 데이터.

o 초기화 벡터 - CBC 모드 암호의 경우 초기화 벡터\(IV\)의 길이는 기본 암호화 알고리즘의 블록 길이와 같습니다. 발신자는 모든 메시지에 대해 예측할 수 없는 새로운 IV를 선택해야 합니다. 수신자는 모든 값을 수락해야 합니다. 독자는 IV 생성에 대한 조언을 위해 \[MODES\]를 참조하는 것이 좋습니다. 특히, 마지막 암호문 블록을 사용하여\(MUST\)

- 이전 메시지는 예측할 수 없는 것으로 간주되지 않습니다. CBC 이외의 모드의 경우 IV 형식 및 처리는 암호화 알고리즘 및 모드를 지정하는 문서에 지정됩니다.

o IKE 페이로드는 이 섹션 앞부분에 지정된 대로입니다. 이 필드는 협상된 암호로 암호화됩니다.

o 패딩은 발신자가 선택한 모든 값을 포함할 수 있으며 페이로드, 패딩 및 패드 길이의 조합이 암호화 블록 크기의 배수가 되도록 하는 길이를 가져야 합니다. 이 필드는 협상된 암호로 암호화됩니다.\(MUST\)

o 패드 길이는 패딩 필드의 길이입니다. 송신자는 페이로드, 패딩 및 패드 길이의 조합을 블록 크기의 배수로 만드는 최소값으로 패드 길이를 설정해야 하지만 수신자는 적절한 정렬을 초래하는 모든 길이를 수락해야 합니다. 이 필드는 협상된 암호로 암호화됩니다.\(MUST\)

o 무결성 체크섬 데이터는 고정 IKE 헤더부터 패드 길이까지 전체 메시지의 암호화 체크섬입니다. 체크섬은 암호화된 메시지에 대해 계산되어야 합니다. 길이는 협상된 무결성 알고리즘에 따라 결정됩니다.\(MUST\)

---
### **3.15.  Configuration Payload**

이 문서에서 CP로 표시되는 구성 페이로드는 IKE 피어 간에 구성 정보를 교환하는 데 사용됩니다. 교환은 IRAC가 IRAS로부터 내부 IP 주소를 요청하고 IRAC가 LAN에 직접 연결된 경우 DHCP\(동적 호스트 구성 프로토콜\)를 통해 얻을 수 있는 종류의 기타 정보를 교환하기 위한 것입니다.

구성 페이로드는 다음과 같이 정의됩니다.

```text
                        1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   | Next Payload  |C| RESERVED    |         Payload Length        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |   CFG Type    |                    RESERVED                   |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                                                               |
   ~                   Configuration Attributes                    ~
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                  Figure 22: Configuration Payload Format
```

구성 페이로드의 페이로드 유형은 47입니다.

o CFG 유형\(1 옥텟\) - 구성 속성으로 표시되는 교환 유형입니다. 다음 표의 값은 RFC 4306 발행일 현재의 값입니다. 그 이후로 다른 값이 추가되었거나 이 문서가 발행된 후에 추가될 것입니다. 최신 값은 \[IKEV2IANA\]를 참조하세요.

```text
      CFG Type           Value
      --------------------------
      CFG_REQUEST        1
      CFG_REPLY          2
      CFG_SET            3
      CFG_ACK            4
```

o 예약됨\(3옥텟\) - 0으로 전송되어야 합니다. 수신 시 무시해야 합니다.\(MUST\)

o 구성 속성\(가변 길이\) - 이는 구성 페이로드에 특정한 TLV\(유형 길이 값\) 구조이며 아래에 정의됩니다. 이 페이로드에는 0개 이상의 구성 속성이 있을 수 있습니다.

---
#### **3.15.1.  Configuration Attributes**

```text
                        1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |R|         Attribute Type      |            Length             |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                                                               |
   ~                             Value                             ~
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                 Figure 23: Configuration Attribute Format
```

o 예약됨\(1비트\) - 이 비트는 0으로 설정되어야 하며 수신 시 무시되어야 합니다.\(MUST\)

o 속성 유형\(15비트\) - 각 구성 속성 유형에 대한 고유 식별자입니다.

o 길이\(2옥텟, 부호 없는 정수\) - 값의 길이\(옥텟\)입니다.

o 값\(0개 이상의 옥텟\) - 이 구성 속성의 가변 길이 값입니다. 다음은 속성 유형을 나열합니다.

다음 표의 값은 RFC 4306 발행일 현재의 최신 값입니다\(RFC 5996에 의해 제거된 INTERNAL\_ADDRESS\_EXPIRY 및 INTERNAL\_IP6\_NBNS 제외\). 그 이후로 다른 값이 추가되었거나 이 문서가 출판된 후에 추가될 예정입니다. 최신 값은 \[IKEV2IANA\]를 참조하세요.

```text
      Attribute Type           Value  Multi-Valued  Length
      ------------------------------------------------------------
      INTERNAL_IP4_ADDRESS     1      YES*          0 or 4 octets
      INTERNAL_IP4_NETMASK     2      NO            0 or 4 octets
      INTERNAL_IP4_DNS         3      YES           0 or 4 octets
      INTERNAL_IP4_NBNS        4      YES           0 or 4 octets
      INTERNAL_IP4_DHCP        6      YES           0 or 4 octets
      APPLICATION_VERSION      7      NO            0 or more
      INTERNAL_IP6_ADDRESS     8      YES*          0 or 17 octets
      INTERNAL_IP6_DNS         10     YES           0 or 16 octets
      INTERNAL_IP6_DHCP        12     YES           0 or 16 octets
      INTERNAL_IP4_SUBNET      13     YES           0 or 8 octets
      SUPPORTED_ATTRIBUTES     14     NO            Multiple of 2
      INTERNAL_IP6_SUBNET      15     YES           17 octets
```

\* 이러한 속성은 다음과 같은 경우에만 반환 시 다중 값을 가질 수 있습니다.

- 여러 값이 요청되었습니다.

o INTERNAL\_IP4\_ADDRESS, INTERNAL\_IP6\_ADDRESS - 내부 네트워크의 주소로 레드 노드 주소 또는 개인 주소라고도 하며 인터넷의 개인 주소일 수도 있습니다. 요청 메시지에서 지정된 주소는 요청된 주소\(또는 특정 주소가 요청되지 않은 경우 길이가 0인 주소\)입니다. 특정 주소가 요청되면 이 주소에 대한 이전 연결이 존재했으며 요청자가 해당 주소를 재사용하기를 원한다는 의미일 가능성이 높습니다. IPv6를 사용하면 요청자는 사용하려는 하위 주소 옥텟을 제공할 수 있습니다. 여러 내부 주소 속성을 요청하여 여러 내부 주소를 요청할 수 있습니다. 응답자는 요청된 주소 수만큼만 보낼 수 있습니다. INTERNAL\_IP6\_ADDRESS는 두 개의 필드로 구성됩니다. 첫 번째는 16옥텟 IPv6 주소이고 두 번째는 \[ADDRIPV6\]에 정의된 1옥텟 접두사 길이입니다. 요청된 주소는 해당 주소를 요청하는 IKE SA\(또는 키를 다시 입력한 후속 항목\)가 유효한 한 유효합니다. 이에 대해서는 섹션 3.15.3에 자세히 설명되어 있습니다.\(MAY, MAY, MAY, MAY\)

o INTERNAL\_IP4\_NETMASK - 내부 네트워크의 넷마스크입니다. 요청 및 응답 메시지에는 하나의 넷마스크만 허용되며\(예: 255.255.255.0\) INTERNAL\_IP4\_ADDRESS 속성과 함께 사용해야 합니다. CFG\_REPLY의 INTERNAL\_IP4\_NETMASK는 INTERNAL\_IP4\_SUBNET과 거의 같은 의미입니다.\(MUST\)

- 동일한 정보\("나를 통해 이 주소로 트래픽 보내기"\)를 포함하지만 링크 경계도 암시합니다. 예를 들어 클라이언트는 자체 주소와 넷마스크를 사용하여 링크의 브로드캐스트 주소를 계산할 수 있습니다. 이 정보를 요청하기 위해 빈 INTERNAL\_IP4\_NETMASK 속성을 CFG\_REQUEST에 포함할 수 있습니다\(요청되지 않은 경우에도 게이트웨이가 정보를 보낼 수 있음\). CFG\_REQUEST에서 이 속성에 대한 비어 있지 않은 값은 의미가 없으므로 포함되어서는 안 됩니다.\(MUST NOT\)

o INTERNAL\_IP4\_DNS, INTERNAL\_IP6\_DNS - 네트워크 내 DNS 서버의 주소를 지정합니다. 여러 DNS 서버가 요청될 수 있습니다. 응답자는 0개 이상의 DNS 서버 속성으로 응답할 수 있습니다.\(MAY, MAY\)

o INTERNAL\_IP4\_NBNS - 네트워크 내 WINS\(NetBios 이름 서버\)의 주소를 지정합니다. 여러 NBNS 서버를 요청할 수 있습니다. 응답자는 0개 이상의 NBNS 서버 속성으로 응답할 수 있습니다.\(MAY, MAY\)

o INTERNAL\_IP4\_DHCP, INTERNAL\_IP6\_DHCP - 내부 DHCP 요청을 속성 내에 포함된 주소로 보내도록 호스트에 지시합니다. 여러 DHCP 서버가 요청될 수 있습니다. 응답자는 0개 이상의 DHCP 서버 속성으로 응답할 수 있습니다.\(MAY, MAY\)

o APPLICATION\_VERSION - IPsec 호스트의 버전 또는 애플리케이션 정보입니다. 이는 널로 끝나지 않는 인쇄 가능한 ASCII 문자의 문자열입니다.

o INTERNAL\_IP4\_SUBNET - 이 에지 장치가 보호하는 보호된 하위 네트워크입니다. 이 속성은 두 개의 필드로 구성됩니다. 첫 번째는 IP 주소이고 두 번째는 넷마스크입니다. 여러 하위 네트워크를 요청할 수 있습니다. 응답자는 0개 이상의 하위 네트워크 속성으로 응답할 수 있습니다. 이에 대해서는 섹션 3.15.2에서 자세히 설명합니다.\(MAY, MAY\)

o SUPPORTED\_ATTRIBUTES - 요청 내에서 사용될 때 이 속성은 길이가 0이어야 하며 지원하는 모든 속성으로 응답하도록 응답자에 대한 쿼리를 지정합니다. 응답에는 각각 2옥텟의 속성 식별자 집합을 포함하는 속성이 포함되어 있습니다. 길이를 2\(옥텟\)로 나눈 값은 응답에 포함된 지원되는 속성의 수를 나타냅니다.\(MUST\)

o INTERNAL\_IP6\_SUBNET - 이 에지 장치가 보호하는 보호된 하위 네트워크입니다. 이 속성은 두 개의 필드로 구성됩니다. 첫 번째는 16옥텟 IPv6 주소이고 두 번째는 \[ADDRIPV6\]에 정의된 1옥텟 접두사 길이입니다. 다수의

- 하위 네트워크를 요청할 수 있습니다. 응답자는 0개 이상의 하위 네트워크 속성으로 응답할 수 있습니다. 이에 대해서는 섹션 3.15.2에서 자세히 설명합니다.\(MAY, MAY\)

이 문서에서는 구현이 응답으로 어떤 정보를 보낼지 실제로 파악하는 방법에 대한 권장 사항이 제공되지 않습니다. 즉, 요청 IRAC에 어떤 DNS 서버를 반환해야 하는지를 IRAS가 결정하는 특정 방법을 권장하지 않습니다.

CFG\_REQUEST 및 CFG\_REPLY 쌍을 사용하면 IKE 엔드포인트가 피어로부터 정보를 요청할 수 있습니다. CFG\_REQUEST 구성 페이로드의 속성 길이가 0이 아닌 경우 해당 속성에 대한 제안으로 간주됩니다. CFG\_REPLY 구성 페이로드는 해당 값 또는 새 값을 반환할 수 있습니다. 또한 새로운 속성을 추가하고 일부 요청된 속성을 포함하지 않을 수도 있습니다. 인식되지 않거나 지원되지 않는 속성은 요청과 응답 모두에서 무시되어야 합니다.\(MAY, MAY, MUST\)

CFG\_SET 및 CFG\_ACK 쌍을 사용하면 IKE 엔드포인트가 구성 데이터를 피어에 푸시할 수 있습니다. 이 경우 CFG\_SET 구성 페이로드에는 개시자가 피어를 변경하기를 원하는 속성이 포함되어 있습니다. 응답자는 구성 데이터 중 하나를 수락한 경우 구성 페이로드를 반환해야 하며, 구성 페이로드에는 응답자가 길이가 0인 데이터로 수락한 속성이 포함되어야 합니다. 수락하지 않은 속성은 CFG\_ACK 구성 페이로드에 있어서는 안 됩니다. 속성이 허용되지 않으면 응답자는 빈 CFG\_ACK 페이로드 또는 CFG\_ACK 페이로드가 없는 응답 메시지를 반환해야 합니다. 현재 CFG\_SET/CFG\_ACK 교환에 대해 정의된 용도는 없지만 공급업체 ID를 기반으로 하는 확장과 관련하여 사용될 수 있습니다. 이 사양의 구현은 CFG\_SET 페이로드를 무시할 수 있습니다.\(MUST, MUST NOT, MUST, MAY\)

---
#### **3.15.2.  Meaning of INTERNAL_IP4_SUBNET and INTERNAL_IP6_SUBNET**

INTERNAL\_IP4/6\_SUBNET 속성은 속성을 알리는 게이트웨이를 통해 연결할 수 있는 하나 이상의 별도 SA가 필요한 추가 서브넷을 나타낼 수 있습니다. INTERNAL\_IP4/6\_SUBNET 속성은 게이트웨이를 통해 전송되어야 하는 트래픽에 대한 게이트웨이 정책을 표현할 수도 있습니다. 클라이언트는 다른 트래픽\(TSr에는 포함되지만 INTERNAL\_IP4/6\_SUBNET에는 포함되지 않음\)이 게이트웨이를 통해 전송되는지 또는 대상으로 직접 전송되는지 여부를 선택할 수 있습니다. 따라서 INTERNAL\_IP4/6\_SUBNET 속성에 나열된 주소로의 트래픽은 해당 속성을 알리는 게이트웨이를 통해 전송되어야 합니다. 트래픽 선택기가 문제의 주소를 포함하는 기존 하위 SA가 없는 경우 새 SA를 만들어야 합니다.

예를 들어 198.51.100.0/26과 192.0.2.0/24라는 두 개의 서브넷이 있고 클라이언트 요청에 다음이 포함되어 있는 경우:

```text
   CP(CFG_REQUEST) =
     INTERNAL_IP4_ADDRESS()
   TSi = (0, 0-65535, 0.0.0.0-255.255.255.255)
   TSr = (0, 0-65535, 0.0.0.0-255.255.255.255)
```

유효한 응답은 다음과 같습니다\(TSr 및 INTERNAL\_IP4\_SUBNET에 동일한 정보가 포함됨\).

```text
   CP(CFG_REPLY) =
     INTERNAL_IP4_ADDRESS(198.51.100.234)
     INTERNAL_IP4_SUBNET(198.51.100.0/255.255.255.192)
     INTERNAL_IP4_SUBNET(192.0.2.0/255.255.255.0)
   TSi = (0, 0-65535, 198.51.100.234-198.51.100.234)
   TSr = ((0, 0-65535, 198.51.100.0-198.51.100.63),
          (0, 0-65535, 192.0.2.0-192.0.2.255))
```

이러한 경우 INTERNAL\_IP4\_SUBNET은 실제로 유용한 정보를 전달하지 않습니다.

다른 가능한 응답은 다음과 같습니다.

```text
   CP(CFG_REPLY) =
     INTERNAL_IP4_ADDRESS(198.51.100.234)
     INTERNAL_IP4_SUBNET(198.51.100.0/255.255.255.192)
     INTERNAL_IP4_SUBNET(192.0.2.0/255.255.255.0)
   TSi = (0, 0-65535, 198.51.100.234-198.51.100.234)
   TSr = (0, 0-65535, 0.0.0.0-255.255.255.255)
```

이 응답은 클라이언트가 게이트웨이를 통해 모든 트래픽을 보낼 수 있지만 클라이언트가 INTERNAL\_IP4\_SUBNET에 포함되지 않은 트래픽을 게이트웨이를 통하지 않고 대상으로 직접 보내는 경우 게이트웨이는 신경 쓰지 않는다는 것을 의미합니다.

게이트웨이에 두 서브넷의 트래픽이 별도의 SA에서 전달되도록 요구하는 정책이 있는 경우 다른 상황이 발생합니다. 그런 다음 다음과 같은 응답은 두 번째 서브넷에 액세스하려는 경우 별도의 SA를 만들어야 함을 클라이언트에 나타냅니다.

```text
   CP(CFG_REPLY) =
     INTERNAL_IP4_ADDRESS(198.51.100.234)
     INTERNAL_IP4_SUBNET(198.51.100.0/255.255.255.192)
     INTERNAL_IP4_SUBNET(192.0.2.0/255.255.255.0)
   TSi = (0, 0-65535, 198.51.100.234-198.51.100.234)
   TSr = (0, 0-65535, 198.51.100.0-198.51.100.63)
```

INTERNAL\_IP4\_SUBNET은 클라이언트의 TSr에 주소 공간의 일부만 포함된 경우에도 유용할 수 있습니다. 예를 들어 클라이언트가 다음을 요청하는 경우:

```text
   CP(CFG_REQUEST) =
     INTERNAL_IP4_ADDRESS()
   TSi = (0, 0-65535, 0.0.0.0-255.255.255.255)
   TSr = (0, 0-65535, 192.0.2.155-192.0.2.155)
```

그러면 게이트웨이의 응답은 다음과 같을 수 있습니다.

```text
   CP(CFG_REPLY) =
     INTERNAL_IP4_ADDRESS(198.51.100.234)
     INTERNAL_IP4_SUBNET(198.51.100.0/255.255.255.192)
     INTERNAL_IP4_SUBNET(192.0.2.0/255.255.255.0)
   TSi = (0, 0-65535, 198.51.100.234-198.51.100.234)
   TSr = (0, 0-65535, 192.0.2.155-192.0.2.155)
```

CFG\_REQUEST에서 INTERNAL\_IP4\_SUBNET/INTERNAL\_IP6\_SUBNET의 의미가 불분명하므로 CFG\_REQUEST에서 안정적으로 사용할 수 없습니다.

---
#### **3.15.3.  Configuration Payloads for IPv6**

IPv6용 구성 페이로드는 해당 IPv4 페이로드를 기반으로 하며 "일반적인 IPv6 작업 방식"을 완전히 따르지 않습니다. 특히 IPv6 상태 비저장 자동 구성 또는 라우터 광고 메시지는 사용되지 않으며 이웃 검색도 사용되지 않습니다. IKEv2의 IPv6 구성을 설명하는 추가 문서인 \[IPV6CONFIG\]가 있습니다. 현재로서는 실험적인 문서이지만 더 많은 구현 경험을 통해 이 문서와 동일한 표준 처리를 받을 수 있기를 바랍니다.

INTERNAL\_IP6\_ADDRESS 구성 페이로드를 사용하여 클라이언트에 IPv6 주소를 할당할 수 있습니다. 최소한의 교환은 다음과 같습니다:

```text
   CP(CFG_REQUEST) =
     INTERNAL_IP6_ADDRESS()
     INTERNAL_IP6_DNS()
   TSi = (0, 0-65535, :: - FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF)
   TSr = (0, 0-65535, :: - FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF)

   CP(CFG_REPLY) =
     INTERNAL_IP6_ADDRESS(2001:DB8:0:1:2:3:4:5/64)
     INTERNAL_IP6_DNS(2001:DB8:99:88:77:66:55:44)
   TSi = (0, 0-65535, 2001:DB8:0:1:2:3:4:5 - 2001:DB8:0:1:2:3:4:5)
   TSr = (0, 0-65535, :: - FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF)
```

클라이언트는 특정 주소나 인터페이스 식별자를 요청하기 위해 CFG\_REQUEST에 비어 있지 않은 INTERNAL\_IP6\_ADDRESS 속성을 보낼 수 있습니다. 게이트웨이는 먼저 지정된 주소가 허용 가능한지 확인하고, 허용 가능한 경우 해당 주소를 반환합니다. 주소가 허용되지 않는 경우 게이트웨이는 다른 접두사와 함께 인터페이스 식별자를 사용하려고 시도합니다. 실패하더라도 게이트웨이는 다른 인터페이스 식별자를 선택합니다.\(MAY\)

INTERNAL\_IP6\_ADDRESS 속성에는 접두사 길이 필드도 포함되어 있습니다. CFG\_REPLY에서 사용되는 경우 이는 IPv4의 경우 INTERNAL\_IP4\_NETMASK 속성에 해당합니다.

IPv6 주소를 구성하는 이 접근 방식은 상당히 간단하지만 몇 가지 제한 사항이 있습니다. IKEv2를 사용하여 구성된 IPsec 터널은 IPv6 주소 지정 아키텍처 측면에서 완전한 기능을 갖춘 "인터페이스"가 아닙니다\[ADDRIPV6\]. 특히 링크-로컬 주소가 반드시 필요한 것은 아니며 이는 \[MLDV2\]와 같이 이를 가정하는 프로토콜의 사용을 복잡하게 만들 수 있습니다.

---
#### **3.15.4.  Address Assignment Failures**

구성 페이로드를 처리하는 동안 응답자가 개시자에 IP 주소를 할당하려고 시도하는 동안 오류가 발생하면 INTERNAL\_ADDRESS\_FAILURE 알림으로 응답합니다. 이 실패로 인해 초기 하위 SA를 만들 수 없는 경우에도 IKE SA는 계속 생성됩니다. IKE\_AUTH 교환 내에서 이 오류가 생성되면 하위 SA가 생성되지 않습니다. 그러나 좀 더 복잡한 오류 사례가 있습니다.

응답자가 구성 페이로드를 전혀 지원하지 않는 경우 모든 구성 페이로드를 무시하면 됩니다. 이러한 유형의 구현은 INTERNAL\_ADDRESS\_FAILURE 알림을 보내지 않습니다.

개시자가 IP 주소 할당을 요구하는 경우 CFG\_REPLY가 없는 응답을 오류로 처리합니다.

응답자가 구성 페이로드를 지원하더라도 개시자는 응답자가 지원하지 않는 특정 유형의 주소\(IPv4 또는 IPv6\)를 요청할 수 있습니다. 이 경우 응답자는 지원하지 않는 주소 유형을 무시하고 나머지 요청을 평소대로 처리합니다.

개시자가 응답자가 지원하는 유형의 주소를 여러 개 요청하고 요청 중 일부\(전부는 아님\)가 실패한 경우 응답자는 성공한 주소로만 응답합니다. 응답자는 주소를 할당할 수 없는 경우에만 INTERNAL\_ADDRESS\_FAILURE를 보냅니다.

개시자가 정책에 필요한 IP 주소를 수신하지 못하는 경우 IKE SA를 유지하고 적절한 시간 초과 후 별도의 정보 교환으로 구성 페이로드를 재시도하거나 삭제 페이로드를 전송하여 IKE SA를 해제할 수 있습니다. 별도의 정보 교환 내에서 나중에 시간 초과 후 처음부터 IKE SA를 다시 시도합니다. 이러한 오류 상황은 신속하게 해결되지 않을 수 있으므로 이러한 제한 시간은 너무 짧아서는 안 됩니다\(특히 IKE SA가 처음부터 시작된 경우\). 시간 초과는 몇 분 정도 걸릴 수 있습니다. 예를 들어, 응답자의 주소 부족 문제는 다른 클라이언트의 연결이 끊어지거나 응답자가 더 큰 주소 풀로 재구성될 때 더 많은 항목이 주소 풀에 반환되는 경우에만 수정될 수 있습니다.\(MAY\)

---
### **3.16.  Extensible Authentication Protocol (EAP) Payload**

이 문서에서 EAP로 표시된 확장 가능 인증 프로토콜 페이로드를 사용하면 RFC 3748 \[EAP\]에 정의된 프로토콜과 해당 프로토콜에 대한 후속 확장을 사용하여 IKE SA를 인증할 수 있습니다. EAP를 사용하는 경우 적절한 EAP 방법을 선택해야 합니다. 이러한 방법 중 다수는 다양한 인증 메커니즘과 함께 프로토콜의 사용을 지정하여 정의되었습니다. EAP 방법 유형은 \[EAP-IANA\]에 나열되어 있습니다. 명확성을 위해 여기에는 EAP 형식에 대한 간략한 요약이 포함되어 있습니다.

```text
                        1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   | Next Payload  |C|  RESERVED   |         Payload Length        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                                                               |
   ~                       EAP Message                             ~
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                       Figure 24: EAP Payload Format
```

EAP 페이로드의 페이로드 유형은 48입니다.

```text
                        1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |     Code      | Identifier    |           Length              |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |     Type      | Type_Data...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

                       Figure 25: EAP Message Format
```

o 코드\(1 옥텟\) - 이 메시지가 요청\(1\), 응답\(2\), 성공\(3\) 또는 실패\(4\)인지 여부를 나타냅니다.

o 식별자\(1옥텟\) - PPP에서 재생된 메시지와 반복된 메시지를 구별하는 데 사용됩니다. IKE에서는 EAP가 신뢰할 수 있는 프로토콜을 통해 실행되므로 식별자는 여기서 아무런 기능도 제공하지 않습니다. 응답 메시지에서 이 옥텟은 해당 요청의 식별자와 일치하도록 설정되어야 합니다.\(MUST\)

o 길이\(2옥텟, 부호 없는 정수\) - EAP 메시지의 길이입니다. 캡슐화 페이로드의 페이로드 길이보다 4개 작아야 합니다.\(MUST\)

o 유형\(1 옥텟\) - 코드 필드가 요청\(1\) 또는 응답\(2\)인 경우에만 존재합니다. 다른 코드의 경우 EAP 메시지 길이는 4옥텟이어야 하며 Type 및 Type\_Data 필드가 있어서는 안 됩니다. 요청\(1\) 메시지에서 유형은 요청되는 데이터를 나타냅니다. 응답\(2\) 메시지에서 유형은 Nak이거나 요청된 데이터 유형과 일치해야 합니다. IKE는 IKE\_AUTH 교환의 첫 번째 메시지에서 개시자 ID 표시를 전달하므로 응답자는 EAP ID 요청\(유형 1\)을 보내서는 안 됩니다. 그러나 개시자는 그러한 요청을 받으면 응답할 수 있습니다.\(MUST NOT, MUST, SHOULD NOT, MAY\)

o Type\_Data\(가변 길이\) - 요청 유형 및 관련 응답에 따라 달라집니다. EAP 방법에 대한 문서는 \[EAP\]를 참조하세요.

IKE는 IKE\_AUTH 교환의 첫 번째 메시지에서 개시자 ID 표시를 전달하므로 응답자는 EAP ID 요청을 보내서는 안 됩니다. 그러나 개시자는 그러한 요청을 받으면 응답할 수 있습니다.\(SHOULD NOT, MAY\)

---
## **4.  Conformance Requirements**

IKEv2의 모든 구현이 상호 운용될 수 있도록 하려면 다른 곳에 나열된 요구 사항 외에도 "지원해야 하는" 요구 사항이 있습니다. 물론 IKEv2는 보안 프로토콜이며 주요 기능 중 하나는 승인된 당사자만 SA 설정을 성공적으로 완료할 수 있도록 허용하는 것입니다. 따라서 특정 구현은 보편적인 상호 운용성을 방해하는 알고리즘 및 신뢰할 수 있는 권한과 관련된 여러 제한 사항으로 구성될 수 있습니다.\(MUST\)

IKEv2는 모든 규정을 준수하는 구현과 상호 운용할 수 있는 최소한의 구현을 허용하도록 설계되었습니다. 다음은 최소한의 구현에서 생략할 수 있는 기능입니다.

o NAT를 통해 SA를 협상하고 UDP를 통해 결과 ESP SA를 터널링하는 기능.

o 터널의 원격 끝에서 임시 IP 주소를 요청\(및 요청에 응답\)하는 기능.

o EAP 기반 인증을 지원하는 기능.

o 1보다 큰 창 크기를 지원하는 기능.

o 단일 IKE SA 내에서 여러 ESP 또는 AH SA를 설정하는 기능.

o SA 키를 다시 입력하는 기능.

상호 운용성을 보장하기 위해 모든 구현은 모든 페이로드 유형을 구문 분석할 수 있어야 하며\(건너뛰기만 하는 경우\) 페이로드 헤더에 중요 비트가 설정되어 있지 않으면 지원하지 않는 페이로드 유형을 무시할 수 있어야 합니다. 지원되지 않는 페이로드 헤더에 중요 비트가 설정된 경우 모든 구현은 해당 페이로드가 포함된 메시지를 거부해야 합니다.\(MUST, MUST\)

모든 구현은 두 개의 SA\(IKE용 하나, ESP 또는 AH용 하나\)를 설정하는 4개 메시지 IKE\_SA\_INIT 및 IKE\_AUTH 교환을 수행할 수 있어야 합니다. 구현은 해당 플랫폼에 적합한 경우 시작 전용이거나 응답 전용일 수 있습니다. 모든 구현은 INFORMATIONAL 교환에 응답할 수 있어야 하지만 최소 구현은 INFORMATIONAL 교환의 모든 요청에 ​​빈 응답으로 응답할 수 있습니다\(IKE SA의 컨텍스트 내에서 "빈" 메시지는 IKE 헤더로 구성됨\). 그 뒤에는 페이로드가 포함되지 않은 암호화된 페이로드가 옵니다\). 최소 구현은 요청을 인식하고 NO\_ADDITIONAL\_SAS 유형의 알림 페이로드를 사용하여 거부하는 경우에만 CREATE\_CHILD\_SA 교환을 지원할 수 있습니다. 최소 구현에서는 CREATE\_CHILD\_SA 또는 INFORMATIONAL 교환을 시작할 수 없습니다. SA가 만료되면\(수명 또는 전달된 옥텟의 로컬 구성된 값을 기반으로\) 구현은 CREATE\_CHILD\_SA 교환으로 SA를 갱신하려고 시도하거나 이전 SA를 삭제\(닫기\)하고 새 SA를 생성할 수 있습니다. 응답자가 NO\_ADDITIONAL\_SAS 알림과 함께 CREATE\_CHILD\_SA 요청을 거부하는 경우 구현에서는 대신 이전 SA를 삭제하고 새 SA를 생성할 수 있어야 합니다.\(MUST, MAY, MUST, MAY, MAY, MUST\)

임시 IP 주소 요청이나 그러한 요청에 대한 응답을 지원하기 위해 구현이 필요하지 않습니다. 구현이 그러한 요청 발행을 지원하고 해당 정책이 임시 IP 주소 사용을 요구하는 경우, 최소한 INTERNAL\_IP4\_ADDRESS 또는 INTERNAL\_IP6\_ADDRESS 유형의 필드를 포함하는 IKE\_AUTH 교환의 첫 번째 메시지에 CP 페이로드를 포함해야 합니다. 다른 모든 필드는 선택 사항입니다. 구현이 이러한 요청에 대한 응답을 지원하는 경우 IKE\_AUTH 교환의 첫 번째 메시지에서 CFG\_REQUEST 유형의 CP 페이로드를 구문 분석하고 INTERNAL\_IP4\_ADDRESS 또는 INTERNAL\_IP6\_ADDRESS 유형의 필드를 인식해야 합니다. 적절한 유형의 주소 임대를 지원하는 경우 요청된 유형의 주소가 포함된 CFG\_REPLY 유형의 CP 페이로드를 반환해야 합니다. 응답자는 다른 관련 속성을 포함할 수 있습니다.\(MUST, MUST, MUST\)

이 사양을 준수하는 구현을 호출하려면 다음을 허용하도록 구성할 수 있어야 합니다.\(MUST\)

o X.509\(PKIX\) 인증서를 사용하는 공개 키 인프라

- 1024 또는 2048비트 크기의 RSA 키를 포함하고 서명됩니다. 여기서 전달된 ID는 ID\_KEY\_ID, ID\_FQDN, ID\_RFC822\_ADDR 또는 ID\_DER\_ASN1\_DN 중 하나입니다.

o 전달된 ID가 ID\_KEY\_ID, ID\_FQDN 또는 ID\_RFC822\_ADDR인 공유 키 인증.

o 응답자가 PKIX 인증서를 사용하여 인증되고 개시자가 공유 키 인증을 사용하여 인증되는 인증.

---
## **5.  Security Considerations**

이 프로토콜은 인증되지 않은 피어에 대한 구성 정보 공개를 최소화하도록 설계되었지만 일부 공개는 불가피합니다. 한 피어 또는 다른 피어는 먼저 자신을 식별하고 먼저 자신의 신원을 증명해야 합니다. 조사를 피하기 위해 교환 개시자는 먼저 자신을 식별해야 하며 일반적으로 먼저 자신을 인증해야 합니다. 그러나 개시자는 응답자가 IKE를 지원하고 어떤 암호화 프로토콜을 지원하는지 알 수 있습니다. 응답자\(또는 응답자를 가장하는 사람\)는 개시자의 신원을 조사할 수 있을 뿐만 아니라 CERTREQ 페이로드를 사용하여 개시자가 사용할 인증서를 결정할 수도 있습니다.

EAP 인증을 사용하면 검색 가능성이 다소 변경됩니다. EAP 인증이 사용되면 응답자는 개시자보다 먼저 자신의 신원을 증명하므로 유효한 개시자의 이름을 알고 있는 개시자는 응답자의 이름과 인증서를 모두 검색할 수 있습니다.

추가 Diffie-Hellman 교환 없이 CREATE\_CHILD\_SA를 사용하여 키를 반복적으로 재생성하면 모든 SA가 단일 키의 암호화 분석에 취약해집니다. 구현자는 이 사실을 기록하고 지수화 간의 CREATE\_CHILD\_SA 교환에 제한을 설정해야 합니다. 이 문서에서는 그러한 제한을 규정하지 않습니다.

여기에 정의된 그룹을 사용하는 Diffie-Hellman 교환에서 파생된 키의 강도는 그룹의 고유 강도, 사용된 지수의 크기 및 사용된 난수 생성기가 제공하는 엔트로피에 따라 달라집니다. 이러한 입력으로 인해 정의된 그룹에 대한 키의 강도를 결정하기가 어렵습니다. Diffie-Hellman 그룹 2번은 강력한 난수 생성기 및 200비트 이상의 지수와 함께 사용되는 경우 3DES에서 일반적으로 사용됩니다. 그룹 5는 그룹 2보다 더 강력한 보안을 제공합니다. 그룹 1은 역사적인 목적으로만 사용되며 DES와 함께 사용하는 경우를 제외하고는 충분한 강도를 제공하지 않습니다. 이 역시 역사적인 용도로만 사용됩니다. 구현에서는 정책을 수립하고 보안 매개변수를 협상할 때 이러한 추정치를 기록해야 합니다.

이러한 제한 사항은 Diffie-Hellman 그룹 자체에 적용됩니다. IKE에는 더 강한 그룹 사용을 금지하는 내용이 없으며 더 강한 그룹에서 얻은 강도를 희석시키는 것도 없습니다\(다른 알고리즘의 강도에 의해 제한됨\).

PRF를 포함하여 협상됨\). 실제로 IKE의 확장 가능한 프레임워크는 더 많은 그룹 정의를 장려합니다. 타원 곡선 그룹을 사용하면 훨씬 작은 숫자를 사용하여 강도를 크게 높일 수 있습니다.

모든 Diffie-Hellman 지수는 사용 후 메모리에서 지워지는 것으로 가정됩니다.

IKE\_SA\_INIT 및 IKE\_AUTH 교환은 개시자가 인증되기 전에 발생합니다. 결과적으로 이 프로토콜의 구현은 안전하지 않은 네트워크에 배포될 때 완전히 강력해야 합니다. 구현 취약점, 특히 DoS 공격은 인증되지 않은 피어에 의해 악용될 수 있습니다. 이 문제는 EAP 기반 인증의 메시지 수가 무제한이기 때문에 특히 걱정스럽습니다.

모든 키의 강도는 협상된 PRF의 출력 크기에 따라 제한됩니다. 이러한 이유로 출력이 128비트 미만인 PRF\(예: 3DES-CBC\)는 이 프로토콜과 함께 사용하면 안 됩니다.\(MUST NOT\)

이 프로토콜의 보안은 무작위로 선택된 매개변수의 무작위성에 크게 좌우됩니다. 이는 강력한 무작위 또는 적절하게 시드된 의사 난수 소스에 의해 생성되어야 합니다\(\[RANDOMNESS\] 참조\). 구현자는 키의 보안을 훼손하지 않는 방식으로 키와 nonce 모두에 대해 난수를 사용하도록 주의를 기울여야 합니다.

이 프로토콜의 여러 암호화 설계 선택에 대한 이론적 근거에 대한 자세한 내용은 \[SIGMA\] 및 \[SKEME\]를 참조하세요. 협상된 하위 SA의 보안은 IKE SA에서 협상된 암호화 및 무결성 보호의 강도에 의존하지 않지만 구현은 IKE 무결성 보호 알고리즘으로 NONE 또는 IKE 암호화 알고리즘으로 ENCR\_NULL을 협상해서는 안 됩니다.\(MUST NOT\)

사전 공유 키를 사용할 때 중요한 고려 사항은 이러한 비밀의 무작위성을 보장하는 방법입니다. 가장 강력한 방법은 사전 공유된 키에 협상 중인 가장 강력한 키만큼의 무작위성이 포함되도록 하는 것입니다. 비밀번호, 이름 또는 기타 낮은 엔트로피 소스에서 공유 비밀을 파생시키는 것은 안전하지 않습니다. 이러한 소스는 특히 사전 및 사회 공학적 공격의 대상이 됩니다.

NAT\_DETECTION\_\*\_IP 알림에는 NAT 뒤에 내부 IP 주소를 숨기려는 시도로 주소와 포트의 해시가 포함되어 있습니다. IPv4 주소 공간은 32비트에 불과하고 일반적으로 매우 드물기 때문에 공격자는 가능한 모든 IP 주소를 시도하고 일치하는 해시를 찾으려고 노력함으로써 NAT 상자 뒤에 사용되는 내부 주소를 알아낼 수 있습니다. 포트 번호는 일반적으로 500으로 고정되어 있으며 패킷에서 SPI를 추출할 수 있습니다. 이렇게 하면 해시 계산 수가 2^32로 줄어듭니다. 교육받은 사람과 함께

개인 주소 공간을 사용하는 것으로 추측하면 해시 계산 횟수가 훨씬 적습니다. 따라서 설계자는 IKE를 사용해도 내부 주소 정보가 유출되지 않을 것이라고 가정해서는 안 됩니다.

후속 AUTH 페이로드를 보호하기 위해 공유 키를 생성하지 않는 EAP 인증 방법을 사용하는 경우 특정 중간자 및 서버 가장 공격이 가능합니다\[EAPMITM\]. 이러한 취약점은 보안 터널로 보호되지 않는 프로토콜에서도 EAP가 사용될 때 발생합니다. EAP는 단일 로그인 기능을 제공하는 데 자주 사용되는 범용 인증 프로토콜이므로 공유 키를 생성하지 않는 EAP 인증 방법\(비키 생성 EAP라고도 함\)을 사용하는 배포된 IPsec 솔루션 방법\)은 키를 생성하지 않는 동일한 EAP 방법을 사용하지만 보호되지 않는 방식으로 사용하는 전혀 관련 없는 응용 프로그램의 배포로 인해 손상될 수 있습니다. 이 취약점은 EAP에만 국한되지 않고 인증 인프라가 재사용되는 다른 시나리오에서도 발생할 수 있습니다. 예를 들어, IKEv2에서 사용하는 EAP 메커니즘이 토큰 인증자를 활용하는 경우 중간자 공격자는 웹 서버를 가장하고 토큰 인증 교환을 가로채고 이를 사용하여 IKEv2 연결을 시작할 수 있습니다. 이러한 이유로 키를 생성하지 않는 EAP 방법의 사용은 가능한 한 피해야 합니다. 사용되는 경우 이러한 EAP 방법의 모든 사용은 EAP 인증을 시작하기 전에 개시자가 응답자의 인증서를 검증하는 보호된 터널을 활용해야 한다는 것이 매우 중요합니다. 구현자는 IPsec 솔루션을 배포하는 관리자가 이러한 위험을 인식할 수 있도록 구현 문서에서 키를 생성하지 않는 EAP 방법을 사용할 때의 취약성을 설명해야 합니다.\(SHOULD, SHOULD\)

EAP를 사용하는 구현은 EAP 방법이 상호 인증을 제공하더라도 EAP 인증이 시작되기 전에 클라이언트에 대한 서버의 공개 키 기반 인증을 사용해야 합니다. 이렇게 하면 추가적인 IKEv2 프로토콜 변형을 방지하고 활성 공격자로부터 EAP 데이터를 보호할 수 있습니다.\(MUST\)

IKEv2의 메시지가 IP 수준 조각화가 필요할 만큼 길면 공격자가 리어셈블리 버퍼를 소진하여 교환이 완료되지 못하게 할 수 있습니다. 인증서를 보내는 대신 해시 및 URL 인코딩을 사용하면 이러한 가능성을 최소화할 수 있습니다\(섹션 3.6 참조\). 추가 완화는 \[DOSUDPPROT\]에서 논의됩니다.

승인 제어는 프로토콜 보안에 매우 중요합니다. 예를 들어, IKE 피어를 식별하는 데 사용되는 트러스트 앵커는 공용 웹 서버를 식별하는 데 사용되는 것과 같은 다른 형태의 신뢰에 사용되는 것과 달라야 합니다. 게다가 IKE는 신뢰할 수 있는 보안 정책을 정의하는 데 상당한 자유를 제공하지만

피어의 ID, 자격 증명 및 이들 간의 상관 관계를 명시적으로 정의하는 보안 정책을 갖는 것은 보안 구현에 필수적입니다.

---
### **5.1.  Traffic Selector Authorization**

IKEv2는 피어가 생성할 수 있는 하위 SA의 종류를 결정할 때 PAD\(피어 인증 데이터베이스\)의 정보를 사용합니다. 이 프로세스는 \[IPSECARCH\]의 섹션 4.4.3에 설명되어 있습니다. 피어가 일부 트래픽 선택기를 사용하여 하위 SA 생성을 요청하는 경우 PAD에는 IKEv2에서 인증된 ID와 트래픽 선택기에 허용된 주소를 연결하는 "하위 SA 인증 데이터"가 포함되어야 합니다.

예를 들어 인증된 ID "sgw23.example.com"이 192.0.2.0/24에 대한 하위 SA를 생성할 수 있도록 PAD를 구성할 수 있습니다. 이는 이 보안 게이트웨이가 이러한 주소에 대한 유효한 "대표"임을 의미합니다. 호스트 간 IPsec에는 "fooserver4.example.com"과 198.51.100.66/32를 연결하는 유사한 항목이 필요합니다. 이는 이 ID가 해당 주소의 유효한 "소유자" 또는 "대표자"임을 의미합니다.

\[IPSECARCH\]에 언급된 바와 같이, "인증된 피어가 다른 합법적인 피어와 연결된 ID를 스푸핑하는 것을 방지하려면 하위 SA 생성에 이러한 제약 조건을 적용하는 것이 필요합니다." 위에 제공된 예에서 PAD를 올바르게 구성하면 sgw23이 주소 198.51.100.66을 사용하여 하위 SA를 생성하는 것을 방지하고 fooserver4가 주소 192.0.2.0/24를 사용하여 하위 SA를 생성하지 못하게 합니다.

특정 주소를 사용하여 단순히 IKEv2 패킷을 전송한다고 해서 트래픽 선택기에서 해당 주소를 사용하여 하위 SA를 생성할 수 있는 권한이 부여되는 것은 아닙니다. 예를 들어, sgw23이 IP 주소를 198.51.100.66으로 스푸핑할 수 있더라도 fooserver4의 트래픽과 일치하는 하위 SA를 생성할 수는 없습니다.

IKEv2 사양은 구성 페이로드를 사용한 IP 주소 할당이 PAD와 상호 작용하는 방식을 정확히 지정하지 않습니다. 우리의 해석은 보안 게이트웨이가 구성 페이로드를 사용하여 주소를 할당할 때 인증된 피어 ID와 새로 할당된 내부 주소를 연결하는 임시 PAD 항목도 생성한다는 것입니다.

일부 환경에서는 PAD를 올바르게 구성하는 것이 어려울 수 있다는 것이 인식되었습니다. 예를 들어, DHCP를 사용하여 주소가 동적으로 할당된 호스트 쌍 사이에 IPsec을 사용하는 경우 PAD가

각 IP 주소에 대해 올바른 "소유자"를 지정합니다. 이를 위해서는 DHCP 서버에서 주소 할당을 안전하게 전달하고 이를 IKEv2를 사용하여 인증된 ID에 연결하는 메커니즘이 필요합니다.

이러한 제한으로 인해 일부 공급업체에서는 인증된 피어가 IKEv2 패킷에 사용된 것과 동일한 주소가 포함된 트래픽 선택기를 사용하여 하위 SA를 생성할 수 있도록 PAD를 구성하는 것으로 알려져 있습니다. IP 스푸핑이 가능한 환경\(예: 거의 모든 곳\)에서는 기본적으로 모든 피어가 트래픽 선택기를 사용하여 하위 SA를 생성할 수 있습니다. 이는 대부분의 상황에서 적절하지 않거나 안전한 구성이 아닙니다. 이 문제와 일반적인 호스트 간 IPsec의 제한 사항에 대한 광범위한 논의는 \[H2HIPSEC\]를 참조하세요.

---
## **6.  IANA Considerations**

\[IKEV2\]는 많은 필드 유형과 값을 정의했습니다. IANA는 이미 \[IKEV2IANA\]에 해당 유형과 값을 등록했으므로 여기에 다시 나열되지 않습니다.

"IKEv2 인증서 인코딩" 레지스트리에서 "원시 RSA 키" 항목이 더 이상 사용되지 않습니다.

IANA는 이 문서를 가리키도록 RFC 5996에 대한 모든 참조를 업데이트했습니다.

---
## **7.  References**
---
### **7.1.  Normative References**

```text
   [ADDGROUP] Kivinen, T. and M. Kojo, "More Modular Exponential (MODP)
              Diffie-Hellman groups for Internet Key Exchange (IKE)",
              RFC 3526, May 2003,
              <http://www.rfc-editor.org/info/rfc3526>.

   [ADDRIPV6] Hinden, R. and S. Deering, "IP Version 6 Addressing
              Architecture", RFC 4291, February 2006,
              <http://www.rfc-editor.org/info/rfc4291>.

   [AEAD]     Black, D. and D. McGrew, "Using Authenticated Encryption
              Algorithms with the Encrypted Payload of the Internet Key
              Exchange version 2 (IKEv2) Protocol", RFC 5282, August
              2008, <http://www.rfc-editor.org/info/rfc5282>.

   [AESCMACPRF128]
              Song, J., Poovendran, R., Lee, J., and T. Iwata, "The
              Advanced Encryption Standard-Cipher-based Message
              Authentication Code-Pseudo-Random Function-128 (AES-CMAC-
              PRF-128) Algorithm for the Internet Key Exchange Protocol
              (IKE)", RFC 4615, August 2006,
              <http://www.rfc-editor.org/info/rfc4615>.

   [AESXCBCPRF128]
              Hoffman, P., "The AES-XCBC-PRF-128 Algorithm for the
              Internet Key Exchange Protocol (IKE)", RFC 4434, February
              2006, <http://www.rfc-editor.org/info/rfc4434>.

   [EAP]      Aboba, B., Blunk, L., Vollbrecht, J., Carlson, J., and H.
              Levkowetz, "Extensible Authentication Protocol (EAP)", RFC
              3748, June 2004, <http://www.rfc-editor.org/info/rfc3748>.

   [ECN]      Ramakrishnan, K., Floyd, S., and D. Black, "The Addition
              of Explicit Congestion Notification (ECN) to IP", RFC
              3168, September 2001,
              <http://www.rfc-editor.org/info/rfc3168>.

   [ESPCBC]   Pereira, R. and R. Adams, "The ESP CBC-Mode Cipher
              Algorithms", RFC 2451, November 1998,
              <http://www.rfc-editor.org/info/rfc2451>.

   [IKEV2IANA]
              IANA, "Internet Key Exchange Version 2 (IKEv2)
              Parameters",
              <http://www.iana.org/assignments/ikev2-parameters/>.

   [IPSECARCH]
              Kent, S. and K. Seo, "Security Architecture for the
              Internet Protocol", RFC 4301, December 2005,
              <http://www.rfc-editor.org/info/rfc4301>.

   [MUSTSHOULD]
              Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", BCP 14, RFC 2119, March 1997,
              <http://www.rfc-editor.org/info/rfc2119>.

   [PKCS1]    Jonsson, J. and B. Kaliski, "Public-Key Cryptography
              Standards (PKCS) #1: RSA Cryptography Specifications
              Version 2.1", RFC 3447, February 2003,
              <http://www.rfc-editor.org/info/rfc3447>.

   [PKIX]     Cooper, D., Santesson, S., Farrell, S., Boeyen, S.,
              Housley, R., and W. Polk, "Internet X.509 Public Key
              Infrastructure Certificate and Certificate Revocation List
              (CRL) Profile", RFC 5280, May 2008,
              <http://www.rfc-editor.org/info/rfc5280>.

   [RFC4307]  Schiller, J., "Cryptographic Algorithms for Use in the
              Internet Key Exchange Version 2 (IKEv2)", RFC 4307,
              December 2005, <http://www.rfc-editor.org/info/rfc4307>.

   [UDPENCAPS]
              Huttunen, A., Swander, B., Volpe, V., DiBurro, L., and M.
              Stenberg, "UDP Encapsulation of IPsec ESP Packets", RFC
              3948, January 2005,
              <http://www.rfc-editor.org/info/rfc3948>.

   [URLS]     Berners-Lee, T., Fielding, R., and L. Masinter, "Uniform
              Resource Identifier (URI): Generic Syntax", STD 66, RFC
              3986, January 2005,
              <http://www.rfc-editor.org/info/rfc3986>.
```

---
### **7.2.  Informative References**

```text
   [AH]       Kent, S., "IP Authentication Header", RFC 4302, December
              2005, <http://www.rfc-editor.org/info/rfc4302>.

   [ARCHGUIDEPHIL]
              Bush, R. and D. Meyer, "Some Internet Architectural
              Guidelines and Philosophy", RFC 3439, December 2002,
              <http://www.rfc-editor.org/info/rfc3439>.

   [ARCHPRINC]
              Carpenter, B., "Architectural Principles of the Internet",
              RFC 1958, June 1996,
              <http://www.rfc-editor.org/info/rfc1958>.

   [Clarif]   Eronen, P. and P. Hoffman, "IKEv2 Clarifications and
              Implementation Guidelines", RFC 4718, October 2006,
              <http://www.rfc-editor.org/info/rfc4718>.
```

\[DES\] 미국 국립 표준 협회, "정보 시스템에 대한 미국 국가 표준 - 데이터 링크 암호화", ANSI X3.106, 1983.

\[DH\] Diffie, W. 및 M. Hellman, "새로운 방향

- 암호화", 정보 이론에 관한 IEEE 거래, V.IT-22 n. 6, 1977년 6월.

```text
   [DIFFSERVARCH]
              Blake, S., Black, D., Carlson, M., Davies, E., Wang, Z.,
              and W. Weiss, "An Architecture for Differentiated
              Services", RFC 2475, December 1998,
              <http://www.rfc-editor.org/info/rfc2475>.

   [DIFFSERVFIELD]
              Nichols, K., Blake, S., Baker, F., and D. Black,
              "Definition of the Differentiated Services Field (DS
              Field) in the IPv4 and IPv6 Headers", RFC 2474, December
              1998, <http://www.rfc-editor.org/info/rfc2474>.

   [DIFFTUNNEL]
              Black, D., "Differentiated Services and Tunnels", RFC
              2983, October 2000,
              <http://www.rfc-editor.org/info/rfc2983>.

   [DOI]      Piper, D., "The Internet IP Security Domain of
              Interpretation for ISAKMP", RFC 2407, November 1998,
              <http://www.rfc-editor.org/info/rfc2407>.
```

\[DOSUDPPROT\]

- Kaufman, C., Perlman, R. 및 B. Sommerfeld, "UDP 기반 프로토콜에 대한 DoS 보호", 컴퓨터 및 통신 보안에 관한 ACM 컨퍼런스, 2003년 10월.

```text
   [DSS]      National Institute of Standards and Technology, U.S.
              Department of Commerce, "Digital Signature Standard
              (DSS)", FIPS 186-4, July 2013,
              <http://nvlpubs.nist.gov/nistpubs/FIPS/
              NIST.FIPS.186-4.pdf>.

   [EAI]      Yang, A., Steele, S., and N. Freed, "Internationalized
              Email Headers", RFC 6532, February 2012,
              <http://www.rfc-editor.org/info/rfc6532>.

   [EAP-IANA] IANA, "Extensible Authentication Protocol (EAP) Registry:
              Method Types",
              <http://http://www.iana.org/assignments/eap-eke/>.

   [EAPMITM]  Asokan, N., Niemi, V., and K. Nyberg, "Man-in-the-Middle
              in Tunneled Authentication Protocols", November 2002,
              <http://eprint.iacr.org/2002/163>.

   [ESP]      Kent, S., "IP Encapsulating Security Payload (ESP)", RFC
              4303, December 2005,
              <http://www.rfc-editor.org/info/rfc4303>.

   [EXCHANGEANALYSIS]
              Perlman, R. and C. Kaufman, "Analysis of the IPsec key
              exchange Standard", WET-ICE Security Conference, MIT,
              2001, <http://www.computer.org/csdl/proceedings/
              wetice/2001/1269/00/12690150.pdf>.

   [FIPS.180-4.2012]
              National Institute of Standards and Technology, U.S.
              Department of Commerce, "Secure Hash Standard (SHS)", FIPS
              180-4, March 2012,
              <http://csrc.nist.gov/publications/fips/fips180-4/
              fips-180-4.pdf>.
```

\[H2HIPSEC\] Aura, T., Roe, M., A. Mohammed, "호스트 간 IPsec 경험", 제13회 보안 프로토콜에 관한 국제 워크숍, 영국 케임브리지, 2005년 4월.

```text
   [HMAC]     Krawczyk, H., Bellare, M., and R. Canetti, "HMAC: Keyed-
              Hashing for Message Authentication", RFC 2104, February
              1997, <http://www.rfc-editor.org/info/rfc2104>.
```

\[IDEA\] Lai, X., "On the Design and Security of Block Ciphers", ETH Series in Information Processing, v. 1, Konstanz: Hartung-Gorre Verlag, 1992.

```text
   [IDNA]     Klensin, J., "Internationalized Domain Names for
              Applications (IDNA): Definitions and Document Framework",
              RFC 5890, August 2010,
              <http://www.rfc-editor.org/info/rfc5890>.

   [IKEV1]    Harkins, D. and D. Carrel, "The Internet Key Exchange
              (IKE)", RFC 2409, November 1998,
              <http://www.rfc-editor.org/info/rfc2409>.

   [IKEV2]    Kaufman, C., "Internet Key Exchange (IKEv2) Protocol", RFC
              4306, December 2005,
              <http://www.rfc-editor.org/info/rfc4306>.

   [IP]       Postel, J., "Internet Protocol", STD 5, RFC 791, September
              1981, <http://www.rfc-editor.org/info/rfc791>.

   [IP-COMP]  Shacham, A., Monsour, B., Pereira, R., and M. Thomas, "IP
              Payload Compression Protocol (IPComp)", RFC 3173,
              September 2001, <http://www.rfc-editor.org/info/rfc3173>.

   [IPSECARCH-OLD]
              Kent, S. and R. Atkinson, "Security Architecture for the
              Internet Protocol", RFC 2401, November 1998,
              <http://www.rfc-editor.org/info/rfc2401>.

   [IPV6CONFIG]
              Eronen, P., Laganier, J., and C. Madson, "IPv6
              Configuration in Internet Key Exchange Protocol Version 2
              (IKEv2)", RFC 5739, February 2010,
              <http://www.rfc-editor.org/info/rfc5739>.

   [ISAKMP]   Maughan, D., Schneider, M., and M. Schertler, "Internet
              Security Association and Key Management Protocol
              (ISAKMP)", RFC 2408, November 1998,
              <http://www.rfc-editor.org/info/rfc2408>.

   [MAILFORMAT]
              Resnick, P., Ed., "Internet Message Format", RFC 5322,
              October 2008, <http://www.rfc-editor.org/info/rfc5322>.

   [MD5]      Rivest, R., "The MD5 Message-Digest Algorithm", RFC 1321,
              April 1992, <http://www.rfc-editor.org/info/rfc1321>.

   [MIPV6]    Perkins, C., Johnson, D., and J. Arkko, "Mobility Support
              in IPv6", RFC 6275, July 2011,
              <http://www.rfc-editor.org/info/rfc6275>.

   [MLDV2]    Vida, R. and L. Costa, "Multicast Listener Discovery
              Version 2 (MLDv2) for IPv6", RFC 3810, June 2004,
              <http://www.rfc-editor.org/info/rfc3810>.

   [MOBIKE]   Eronen, P., "IKEv2 Mobility and Multihoming Protocol
              (MOBIKE)", RFC 4555, June 2006,
              <http://www.rfc-editor.org/info/rfc4555>.
```

\[모드\] Dworkin, M., "블록 암호화 작동 모드에 대한 권장 사항", 국립 표준 기술 연구소, NIST 특별 간행물 800-38A 2001 에디션, 2001년 12월.

```text
   [NAI]      Aboba, B., Beadles, M., Arkko, J., and P. Eronen, "The
              Network Access Identifier", RFC 4282, December 2005,
              <http://www.rfc-editor.org/info/rfc4282>.

   [NATREQ]   Aboba, B. and W. Dixon, "IPsec-Network Address Translation
              (NAT) Compatibility Requirements", RFC 3715, March 2004,
              <http://www.rfc-editor.org/info/rfc3715>.

   [OAKLEY]   Orman, H., "The OAKLEY Key Determination Protocol", RFC
              2412, November 1998,
              <http://www.rfc-editor.org/info/rfc2412>.

   [PFKEY]    McDonald, D., Metz, C., and B. Phan, "PF_KEY Key
              Management API, Version 2", RFC 2367, July 1998,
              <http://www.rfc-editor.org/info/rfc2367>.

   [PHOTURIS] Karn, P. and W. Simpson, "Photuris: Session-Key Management
              Protocol", RFC 2522, March 1999,
              <http://www.rfc-editor.org/info/rfc2522>.

   [RANDOMNESS]
              Eastlake 3rd, D., Schiller, J., and S. Crocker,
              "Randomness Requirements for Security", BCP 106, RFC 4086,
              June 2005, <http://www.rfc-editor.org/info/rfc4086>.

   [REAUTH]   Nir, Y., "Repeated Authentication in Internet Key Exchange
              (IKEv2) Protocol", RFC 4478, April 2006,
              <http://www.rfc-editor.org/info/rfc4478>.

   [REUSE]    Menezes, A. and B. Ustaoglu, "On Reusing Ephemeral Keys In
              Diffie-Hellman Key Agreement Protocols", December 2008,
              <http://www.cacr.math.uwaterloo.ca/techreports/2008/
              cacr2008-24.pdf>.

   [RFC4945]  Korver, B., "The Internet IP Security PKI Profile of
              IKEv1/ISAKMP, IKEv2, and PKIX", RFC 4945, August 2007,
              <http://www.rfc-editor.org/info/rfc4945>.

   [RFC5996]  Kaufman, C., Hoffman, P., Nir, Y., and P. Eronen,
              "Internet Key Exchange Protocol Version 2 (IKEv2)", RFC
              5996, September 2010,
              <http://www.rfc-editor.org/info/rfc5996>.

   [RFC6989]  Sheffer, Y. and S. Fluhrer, "Additional Diffie-Hellman
              Tests for the Internet Key Exchange Protocol Version 2
              (IKEv2)", RFC 6989, July 2013,
              <http://www.rfc-editor.org/info/rfc6989>.

   [ROHCV2]   Ertekin, E., Christou, C., Jasani, R., Kivinen, T., and C.
              Bormann, "IKEv2 Extensions to Support Robust Header
              Compression over IPsec", RFC 5857, May 2010,
              <http://www.rfc-editor.org/info/rfc5857>.

   [SIGMA]    Krawczyk, H., "SIGMA: the 'SIGn-and-MAc' Approach to
              Authenticated Diffie-Hellman and its Use in the IKE
              Protocols", Advances in Cryptography - CRYPTO 2003
              Proceedings LNCS 2729, 2003,
              <http://www.informatik.uni-trier.de/~ley/db/conf/crypto/
              crypto2003.html>.
```

\[SKEME\] Krawczyk, H., "SKEME: 인터넷을 위한 다목적 보안 키 교환 메커니즘", IEEE Proceedings of the 1996 Symposium on Network and Distributed Systems Security, 1996.

```text
   [TRANSPARENCY]
              Carpenter, B., "Internet Transparency", RFC 2775, February
              2000, <http://www.rfc-editor.org/info/rfc2775>.
```

---
# **Appendix A.  Summary of Changes from IKEv1**

이번 IKE 개정의 목표는 다음과 같습니다.

```text
   1.   To define the entire IKE protocol in a single document,
        replacing RFCs 2407, 2408, and 2409 and incorporating subsequent
        changes to support NAT traversal, Extensible Authentication, and
        Remote Address acquisition;

   2.   To simplify IKE by replacing the eight different initial
        exchanges with a single four-message exchange (with changes in
        authentication mechanisms affecting only a single AUTH payload
        rather than restructuring the entire exchange) see
        [EXCHANGEANALYSIS];

   3.   To remove the Domain of Interpretation (DOI), Situation (SIT),
        and Labeled Domain Identifier fields, and the Commit and
        Authentication only bits;

   4.   To decrease IKE's latency in the common case by making the
        initial exchange be 2 round trips (4 messages), and allowing the
        ability to piggyback setup of a Child SA on that exchange;

   5.   To replace the cryptographic syntax for protecting the IKE
        messages themselves with one based closely on ESP to simplify
        implementation and security analysis;

   6.   To reduce the number of possible error states by making the
        protocol reliable (all messages are acknowledged) and sequenced.
        This allows shortening CREATE_CHILD_SA exchanges from 3 messages
        to 2;

   7.   To increase robustness by allowing the responder to not do
        significant processing until it receives a message proving that
        the initiator can receive messages at its claimed IP address;

   8.   To fix cryptographic weaknesses such as the problem with
        symmetries in hashes used for authentication (documented by Tero
        Kivinen);

   9.   To specify Traffic Selectors in their own payloads type rather
        than overloading ID payloads, and making more flexible the
        Traffic Selectors that may be specified;

   10.  To specify required behavior under certain error conditions or
        when data that is not understood is received in order to make it
        easier to make future revisions in a way that does not break
        backward compatibility;
```

11. 네트워크 오류 및 DoS 공격이 있는 경우 공유 상태가 유지되는 방법을 단순화하고 명확하게 합니다. 그리고

12. 최소한의 노력으로 IKEv2를 지원하도록 IKEv1 구현을 향상할 수 있도록 기존 구문과 매직 넘버를 최대한 유지합니다.

---
# **Appendix B.  Diffie-Hellman Groups**

IKE에서 사용하기 위해 여기에 정의된 두 개의 Diffie-Hellman 그룹이 있습니다. 이 그룹은 애리조나 대학의 Richard Schroeppel에 의해 생성되었습니다. 이러한 소수의 속성은 \[OAKLEY\]에 설명되어 있습니다.

그룹 1에서 제공하는 강도는 일반적인 용도에는 충분하지 않을 수 있으며 역사적인 이유로 여기에 있습니다.

추가 Diffie-Hellman 그룹은 \[ADDGROUP\]에 정의되었습니다.

---
### **B.1.  Group 1 - 768-bit MODP**

이 그룹에는 ID 1\(1\)이 할당됩니다.

소수는 2^768 - 2 ^704 - 1 + 2^64 \* { \[2^638 pi\] + 149686 } 16진수 값은 다음과 같습니다.

```text
   FFFFFFFF FFFFFFFF C90FDAA2 2168C234 C4C6628B 80DC1CD1
   29024E08 8A67CC74 020BBEA6 3B139B22 514A0879 8E3404DD
   EF9519B3 CD3A431B 302B0A6D F25F1437 4FE1356D 6D51C245
   E485B576 625E7EC6 F44C42E9 A63A3620 FFFFFFFF FFFFFFFF
```

발전기는 2입니다.

---
### **B.2.  Group 2 - 1024-bit MODP**

이 그룹에는 ID 2\(2개\)가 할당됩니다.

소수는 2^1024 - 2^960 - 1 + 2^64 \* { \[2^894 파이\] + 129093 }입니다. 16진수 값은 다음과 같습니다.

```text
   FFFFFFFF FFFFFFFF C90FDAA2 2168C234 C4C6628B 80DC1CD1
   29024E08 8A67CC74 020BBEA6 3B139B22 514A0879 8E3404DD
   EF9519B3 CD3A431B 302B0A6D F25F1437 4FE1356D 6D51C245
   E485B576 625E7EC6 F44C42E9 A637ED6B 0BFF5CB6 F406B7ED
   EE386BFB 5A899FA5 AE9F2411 7C4B1FE6 49286651 ECE65381
   FFFFFFFF FFFFFFFF
```

발전기는 2입니다.

---
# **Appendix C.  Exchanges and Payloads**

이 부록에는 IKEv2 교환에 대한 간략한 요약과 어떤 메시지에 어떤 페이로드가 나타날 수 있는지가 포함되어 있습니다. 이 부록은 순전히 정보를 제공하기 위한 것입니다. 이 문서의 본문과 일치하지 않는 경우 다른 텍스트가 올바른 것으로 간주됩니다.

공급업체 ID\(V\) 페이로드는 메시지의 어느 위치에나 포함될 수 있습니다. 여기 이 순서는 가장 논리적인 위치가 무엇인지 보여줍니다.

---
### **C.1.  IKE_SA_INIT Exchange**

```text
   request             --> [N(COOKIE),]
                           SA, KE, Ni,
                           [N(NAT_DETECTION_SOURCE_IP)+,
                            N(NAT_DETECTION_DESTINATION_IP),]
                           [V+][N+]

   normal response     <-- SA, KE, Nr,
   (no cookie)             [N(NAT_DETECTION_SOURCE_IP),
                            N(NAT_DETECTION_DESTINATION_IP),]
                           [[N(HTTP_CERT_LOOKUP_SUPPORTED),] CERTREQ+,]
                           [V+][N+]

   cookie response     <-- N(COOKIE),
                           [V+][N+]

   different Diffie-   <-- N(INVALID_KE_PAYLOAD),
   Hellman group           [V+][N+]
   wanted
```

---
### **C.2.  IKE_AUTH Exchange without EAP**

```text
   request             --> IDi, [CERT+,]
                           [N(INITIAL_CONTACT),]
                           [[N(HTTP_CERT_LOOKUP_SUPPORTED),] CERTREQ+,]
                           [IDr,]
                           AUTH,
                           [CP(CFG_REQUEST),]
                           [N(IPCOMP_SUPPORTED)+,]
                           [N(USE_TRANSPORT_MODE),]
                           [N(ESP_TFC_PADDING_NOT_SUPPORTED),]
                           [N(NON_FIRST_FRAGMENTS_ALSO),]
                           SA, TSi, TSr,
                           [V+][N+]

   response            <-- IDr, [CERT+,]
                           AUTH,
                           [CP(CFG_REPLY),]
                           [N(IPCOMP_SUPPORTED),]
                           [N(USE_TRANSPORT_MODE),]
                           [N(ESP_TFC_PADDING_NOT_SUPPORTED),]
                           [N(NON_FIRST_FRAGMENTS_ALSO),]
                           SA, TSi, TSr,
                           [N(ADDITIONAL_TS_POSSIBLE),]
                           [V+][N+]

   error in Child SA  <--  IDr, [CERT+,]
   creation                AUTH,
                           N(error),
                           [V+][N+]
```

---
### **C.3.  IKE_AUTH Exchange with EAP**

```text
   first request       --> IDi,
                           [N(INITIAL_CONTACT),]
                           [[N(HTTP_CERT_LOOKUP_SUPPORTED),] CERTREQ+,]
                           [IDr,]
                           [CP(CFG_REQUEST),]
                           [N(IPCOMP_SUPPORTED)+,]
                           [N(USE_TRANSPORT_MODE),]
                           [N(ESP_TFC_PADDING_NOT_SUPPORTED),]
                           [N(NON_FIRST_FRAGMENTS_ALSO),]
                           SA, TSi, TSr,
                           [V+][N+]

   first response      <-- IDr, [CERT+,] AUTH,
                           EAP,
                           [V+][N+]

                     / --> EAP
   repeat 1..N times |
                     \ <-- EAP

   last request        --> AUTH

   last response       <-- AUTH,
                           [CP(CFG_REPLY),]
                           [N(IPCOMP_SUPPORTED),]
                           [N(USE_TRANSPORT_MODE),]
                           [N(ESP_TFC_PADDING_NOT_SUPPORTED),]
                           [N(NON_FIRST_FRAGMENTS_ALSO),]
                           SA, TSi, TSr,
                           [N(ADDITIONAL_TS_POSSIBLE),]
                           [V+][N+]
```

---
### **C.4.  CREATE_CHILD_SA Exchange for Creating or Rekeying Child SAs**

```text
   request             --> [N(REKEY_SA),]
                           [CP(CFG_REQUEST),]
                           [N(IPCOMP_SUPPORTED)+,]
                           [N(USE_TRANSPORT_MODE),]
                           [N(ESP_TFC_PADDING_NOT_SUPPORTED),]
                           [N(NON_FIRST_FRAGMENTS_ALSO),]
                           SA, Ni, [KEi,] TSi, TSr,
                           [V+][N+]

   normal              <-- [CP(CFG_REPLY),]
   response                [N(IPCOMP_SUPPORTED),]
                           [N(USE_TRANSPORT_MODE),]
                           [N(ESP_TFC_PADDING_NOT_SUPPORTED),]
                           [N(NON_FIRST_FRAGMENTS_ALSO),]
                           SA, Nr, [KEr,] TSi, TSr,
                           [N(ADDITIONAL_TS_POSSIBLE),]
                           [V+][N+]

   error case          <-- N(error)

   different Diffie-   <-- N(INVALID_KE_PAYLOAD),
   Hellman group           [V+][N+]
   wanted
```

---
### **C.5.  CREATE_CHILD_SA Exchange for Rekeying the IKE SA**

```text
   request             --> SA, Ni, KEi,
                           [V+][N+]

   response            <-- SA, Nr, KEr,
                           [V+][N+]
```

---
### **C.6.  INFORMATIONAL Exchange**

```text
   request             --> [N+,]
                           [D+,]
                           [CP(CFG_REQUEST)]

   response            <-- [N+,]
                           [D+,]
                           [CP(CFG_REPLY)]
```

---
# **Acknowledgements**

IPsecME 작업 그룹의 많은 개인은 이 문서에 대한 아이디어와 텍스트를 제공하고 다른 사람들이 제안한 설명을 검토하는 데 큰 도움을 주었습니다.

IKEv2 문서의 승인 내용은 다음과 같습니다.

이 문서는 전체 IPsec WG의 공동 작업입니다. RFC에 표시할 수 있는 저자 수에 제한이 없다면 Bill Aiello, Stephane Beaulieu, Steve Bellovin, Sara Bitan, Matt Blaze, Ran Canetti, Darren Dukes 등이 알파벳 순서로 나열되었을 것입니다. Dan Harkins, Paul Hoffman, John Ioannidis, Charlie Kaufman, Steve Kent, Angelos Keromytis, Tero Kivinen, Hugo Krawczyk, Andrew Krywaniuk, Radia Perlman, Omer Reingold 및 Michael Richardson. 그 외 많은 분들이 디자인에 참여해 주셨습니다. 이는 IKEv1, ISAKMP 및 IPsec DOI의 진화이며, 각각에는 자체 작성자 목록이 있습니다. Hugh Daniel은 메시지 3에서 개시자가 응답자의 이름을 지정하도록 하는 기능을 제안하고 이 기능에 "You Tarzan, Me Jane"이라는 귀여운 이름을 부여했습니다. David Faucher와 Valery Smyslov는 트래픽 선택기 협상 설계를 개선하는 데 도움을 주었습니다.

---
# **Authors' Addresses**

```text
   Charlie Kaufman
   Microsoft
   1 Microsoft Way
   Redmond, WA  98052
   United States

   EMail: charliekaufman@outlook.com

   Paul Hoffman
   VPN Consortium
   127 Segre Place
   Santa Cruz, CA  95060
   United States

   Phone: 1-831-426-9827
   EMail: paul.hoffman@vpnc.org

   Yoav Nir
   Check Point Software Technologies Ltd.
   5 Hasolelim St.
   Tel Aviv 6789735
   Israel

   EMail: ynir.ietf@gmail.com

   Pasi Eronen
   Independent

   EMail: pe@iki.fi
```

Tero Kivinen INSIDE 보안 Eerikinkatu 28 HELSINKI FI-00180 핀란드

```text
   EMail: kivinen@iki.fi
```
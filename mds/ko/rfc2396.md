

```text
Network Working Group                                     T. Berners-Lee
Request for Comments: 2396                                       MIT/LCS
Updates: 1808, 1738                                          R. Fielding
Category: Standards Track                                    U.C. Irvine
                                                             L. Masinter
                                                       Xerox Corporation
                                                             August 1998

           Uniform Resource Identifiers (URI): Generic Syntax
```

---
# **Status of this Memo**

본 문서는 인터넷 커뮤니티를 위한 인터넷 표준 트랙 프로토콜을 명시하고 개선을 위한 논의와 제안을 요청합니다. 이 프로토콜의 표준화 상태 및 상태에 대해서는 "인터넷 공식 프로토콜 표준"\(STD 1\) 최신판을 참조하세요. 이 메모의 배포는 무제한입니다.

---
# **Copyright Notice**

저작권\(C\)인터넷학회\(1998\). 판권 소유.

---
# **IESG Note**

이 문서에서는 URI에 적용할 수 있는 작업의 "상위 집합"을 설명합니다. 이는 URI의 기본 기능에 대한 문법과 설명으로 구성됩니다. 유효한 URI가 무엇인지 이해하려면 문법과 관련 설명을 모두 연구해야 합니다. 설명된 기능 중 일부는 모든 URI 체계에 적용할 수 없으며 일부 작업은 사용된 체계에 관계없이 URI를 사용하여 특정 미디어 유형을 검색하는 경우에만 가능합니다.

---
# **Abstract**

URI\(Uniform Resource Identifier\)는 추상 또는 물리적 리소스를 식별하기 위한 압축된 문자열입니다. 이 문서는 절대 형식과 상대 형식을 모두 포함하는 URI의 일반 구문과 사용 지침을 정의합니다. 이는 RFC 1738 및 RFC 1808의 일반 정의를 개정하고 대체합니다.

이 문서는 구현이 가능한 모든 식별자 유형의 체계별 요구 사항을 알지 못해도 URI 참조의 공통 구성 요소를 구문 분석할 수 있도록 모든 유효한 URI의 상위 집합인 문법을 정의합니다. 이 문서는 URI에 대한 생성 문법을 정의하지 않습니다. 해당 작업은 각 URI 체계의 개별 사양에 따라 수행됩니다.

---
## **1. Introduction**

URI\(Uniform Resource Identifier\)는 리소스를 식별하기 위한 간단하고 확장 가능한 수단을 제공합니다. URI 구문 및 의미 체계에 대한 이 사양은 World Wide Web 글로벌 정보 이니셔티브에서 도입한 개념에서 파생되었습니다. 이 개념의 사용은 1990년부터 시작되었으며 "WWW의 범용 리소스 식별자"\[RFC1630\]에 설명되어 있습니다. URI 사양은 "인터넷 리소스 로케이터에 대한 기능 권장 사항" \[RFC1736\] 및 "Uniform Resource Names에 대한 기능 요구 사항" \[RFC1737\]에 제시된 권장 사항을 충족하도록 설계되었습니다.

이 문서는 모든 URI에 대한 단일 일반 구문을 정의하기 위해 "Uniform Resource Locators" \[RFC1738\] 및 "Relative 균일 리소스 로케이터" \[RFC1808\]를 업데이트하고 병합합니다. 개별 URL 구성표의 특정 구문을 정의한 RFC 1738 부분은 제외됩니다. 해당 부분은 새로운 URI 체계 등록 프로세스와 마찬가지로 별도의 문서로 업데이트됩니다. 이 문서에서는 US-ASCII 문자 집합\[ASCII\] 이외의 문자를 처리하기 위한 문제와 권장 사항을 논의하지 않습니다. 이러한 권장 사항은 별도의 문서에서 논의됩니다.

이전 RFC의 모든 중요한 변경 사항은 부록 G에 명시되어 있습니다.

---
## **1.1 Overview of URI**

URI는 다음과 같은 정의로 특징지어집니다.

- 균일 균일성은 여러 가지 이점을 제공합니다. 해당 리소스에 액세스하는 데 사용되는 메커니즘이 다를 수 있는 경우에도 동일한 컨텍스트에서 다양한 유형의 리소스 식별자를 사용할 수 있습니다. 다양한 유형의 리소스 식별자에 걸쳐 공통 구문 규칙을 균일하게 의미적으로 해석할 수 있습니다. 기존 식별자가 사용되는 방식을 방해하지 않고 새로운 유형의 리소스 식별자를 도입할 수 있습니다. 또한 식별자를 다양한 컨텍스트에서 재사용할 수 있으므로 새로운 애플리케이션이나 프로토콜이 기존의 대규모 리소스 식별자 집합을 활용할 수 있습니다.

- 리소스 리소스는 ID가 있는 모든 것이 될 수 있습니다. 익숙한 예로는 전자 문서, 이미지, 서비스\(예: "오늘의 로스앤젤레스 일기예보"\) 및 기타 리소스 모음이 있습니다. 모든 리소스가 네트워크에서 "검색 가능한" 것은 아닙니다. 예를 들어 인간, 기업, 도서관의 장서 등도 자원으로 간주될 수 있습니다.

```text
         The resource is the conceptual mapping to an entity or set of
         entities, not necessarily the entity which corresponds to that
         mapping at any particular instance in time.  Thus, a resource
         can remain constant even when its content---the entities to
         which it currently corresponds---changes over time, provided
         that the conceptual mapping is not changed in the process.
```

- 식별자 식별자는 ID가 있는 항목에 대한 참조 역할을 할 수 있는 개체입니다. URI의 경우 개체는 제한된 구문을 사용하는 일련의 문자입니다.

리소스를 식별한 후 시스템은 '접속', '업데이트', '교체' 또는 '속성 찾기'와 같은 단어로 특징지어질 수 있는 것처럼 리소스에 대해 다양한 작업을 수행할 수 있습니다.

---
### **1.2. URI, URL, and URN**

URI는 위치 지정자, 이름 또는 둘 다로 더 분류될 수 있습니다. "Uniform Resource Locator"\(URL\)라는 용어는 이름이나 다른 속성으로 리소스를 식별하는 대신 기본 액세스 메커니즘\(예: 네트워크 "위치"\)의 표현을 통해 리소스를 식별하는 URI의 하위 집합을 나타냅니다. s\) 해당 리소스의 "Uniform Resource Name"\(URN\)이라는 용어는 리소스가 더 이상 존재하지 않거나 사용할 수 없게 된 경우에도 전역적으로 고유하고 지속성을 유지해야 하는 URI의 하위 집합을 나타냅니다.

URI 체계\(섹션 3.1\)는 URI의 네임스페이스를 정의하므로 해당 체계를 사용하는 식별자의 구문과 의미를 더욱 제한할 수 있습니다. 이 사양은 모든 URI 체계에 필요하거나 많은 URI 체계에 공통적인 URI 구문 요소를 정의합니다. 따라서 이는 URI 참조에 대한 체계 독립적 구문 분석 메커니즘을 구현하는 데 필요한 구문과 의미를 정의하여 체계 종속 의미 체계가 필요할 때까지 URI의 체계 종속 처리를 연기할 수 있습니다. 로케이터에만 적용되는 구문이나 의미를 설명할 때 아래에서 URL이라는 용어를 사용합니다.

많은 URL 구성표가 프로토콜 이름을 따서 명명되었지만 이것이 URL의 리소스에 액세스하는 유일한 방법이 명명된 프로토콜을 통하는 것임을 의미하지는 않습니다. 게이트웨이, 프록시, 캐시 및 이름 확인 서비스는 원본 프로토콜과 관계없이 일부 리소스에 액세스하는 데 사용될 수 있으며 일부 URL의 확인에는 둘 이상의 프로토콜을 사용해야 할 수 있습니다\(예: DNS와 HTTP는 일반적으로 모두 로컬 캐시에서 찾을 수 없는 경우 "http" URL의 리소스에 액세스하는 데 사용됩니다.

URN은 기본 목적이 식별자를 사용하여 리소스에 지속적으로 레이블을 지정한다는 점에서 URL과 다릅니다. 해당 식별자는 정의된 네임스페이스 집합 중 하나에서 가져옵니다. 각 네임스페이스에는 고유한 집합 이름 구조와 할당 절차가 있습니다. "urn" 체계는 "URN 구문" \[RFC2141\] 및 관련 사양에 정의된 대로 표준화된 URN 네임스페이스에 대한 요구 사항을 설정하기 위해 예약되었습니다.

이 사양에 있는 대부분의 예제는 URL을 보여줍니다. 왜냐하면 구문의 가장 다양한 사용을 허용하고 종종 계층적 네임스페이스를 갖기 때문입니다. URI 구문 분석기는 URL과 URN 참조를 일반 URI로 구문 분석할 수 있습니다. 체계가 결정되면 일반 URI 구성 요소에 대해 체계별 구문 분석이 수행될 수 있습니다. 즉, URI 구문은 모든 URI 체계 구문의 상위 집합입니다.

---
### **1.3. Example URI**

다음 예에서는 일반적으로 사용되는 URI를 보여줍니다.

ftp://ftp.is.co.za/rfc/rfc1808.txt - -- 파일 전송 프로토콜 서비스를 위한 ftp 체계

gopher://spinaltap.micro.umn.edu/00/Weather/California/Los%20Angeles - -- Gopher 및 Gopher+ 프로토콜 서비스를 위한 Gopher 체계

http://www.math.uio.no/faq/compression-faq/part1.html - -- Hypertext Transfer Protocol 서비스를 위한 http 체계

mailto:mduerst@ifi.unizh.ch - -- 전자 메일 주소에 대한 mailto 구성표

news:comp.infosystems.www.servers.unix - -- USENET 뉴스 그룹 및 기사에 대한 뉴스 체계

telnet://melvyl.ucop.edu/ - -- TELNET 프로토콜을 통한 대화형 서비스를 위한 텔넷 체계

---
### **1.4. Hierarchical URI and Relative Forms**

절대 식별자는 식별자가 사용되는 컨텍스트와 독립적인 리소스를 나타냅니다. 반면, 상대 식별자는 계층적 네임스페이스 내에서 현재 컨텍스트와 리소스의 절대 식별자 간의 차이를 기술하여 리소스를 참조합니다.

일부 URI 체계는 이름의 계층 구조가 체계의 구성 요소를 구분하는 "/" 구분 기호로 표시되는 계층적 이름 지정 시스템을 지원합니다. 이 문서는 또 다른 URI를 생성하기 위해 \(계층적 체계의\) '기본' URI와 함께 사용될 수 있는 체계 독립적인 '상대적' 형태의 URI 참조를 정의합니다. 계층적 URI의 구문은 섹션 3에 설명되어 있습니다. 상대 URI 계산은 섹션 5에 설명되어 있습니다.

---
### **1.5. URI Transcribability**

URI 구문은 주요 관심사 중 하나로 전역 전사 가능성을 염두에 두고 설계되었습니다. URI는 기본 라틴 알파벳 문자, 숫자 및 몇 가지 특수 문자와 같이 매우 제한된 집합의 문자 시퀀스입니다. URI는 종이의 잉크, 화면의 픽셀, 코드화된 문자 집합의 옥텟 시퀀스 등 다양한 방식으로 표현될 수 있습니다. URI의 해석은 사용된 문자에만 의존하며 해당 문자가 네트워크 프로토콜에서 표현되는 방식은 아닙니다.

전사 가능성의 목표는 간단한 시나리오로 설명할 수 있습니다. Sam과 Kim이라는 두 동료가 국제 컨퍼런스의 한 술집에 앉아 연구 아이디어를 교환하고 있다고 상상해 보십시오. Sam은 더 많은 정보를 얻기 위해 Kim에게 위치를 요청하고 Kim은 냅킨에 연구 사이트의 URI를 적습니다. 집에 돌아온 샘은 냅킨을 꺼내 컴퓨터에 URI를 입력하면 컴퓨터는 김이 언급한 정보를 검색한다.

시나리오에서 밝혀진 몇 가지 디자인 문제는 다음과 같습니다.

- URI는 문자 시퀀스로, 항상 옥텟 시퀀스로 표시되지는 않습니다.

- URI는 네트워크가 아닌 소스에서 복사될 수 있으므로 언어와 로케일 전반에 걸쳐 키보드\(및 관련 입력 장치\)에 의해 부과된 제약 내에서 컴퓨터에 입력할 수 있을 가능성이 가장 높은 문자로 구성되어야 합니다.

- URI는 사람들이 기억해야 하는 경우가 많으며, 의미 있는 구성 요소로 구성되면 사람들이 URI를 기억하기가 더 쉽습니다.

이러한 디자인 문제가 항상 일치하는 것은 아닙니다. 예를 들어, URI 구성 요소의 가장 의미 있는 이름을 지정하려면 일부 시스템에서는 입력할 수 없는 문자가 필요한 경우가 많습니다. 한 매체에서 다른 매체로 자원 식별자를 전사하는 능력은 URI가 가장 의미 있는 구성 요소로 구성되는 것보다 더 중요하다고 간주되었습니다. 지역적, 지역적 맥락에서

기술이 향상되면 사용자는 더 다양한 캐릭터를 사용할 수 있게 되어 이점을 누릴 수 있습니다. 그러한 사용은 이 문서에 정의되어 있지 않습니다.

---
### **1.6. Syntax Notation and Common Elements**

이 문서에서는 두 가지 규칙을 사용하여 URI 구문을 설명하고 정의합니다. 레이아웃 형식이라고 하는 첫 번째 형식은 다음과 같이 구성 요소 및 구성 요소 구분 기호의 순서에 대한 일반적인 설명입니다.

```text
      <first>/<second>;<third>?<fourth>
```

구성 요소 이름은 꺾쇠 괄호로 묶여 있으며 꺾쇠 괄호 밖의 모든 문자는 리터럴 구분 기호입니다. 공백은 무시되어야 합니다. 이러한 설명은 비공식적으로 사용되며 구문 요구 사항을 정의하지 않습니다.

두 번째 규칙은 공식 URI 구문을 정의하는 데 사용되는 BNF와 유사한 문법입니다. 문법은 "|"를 제외하고는 \[RFC822\]의 문법과 같습니다. 대안을 지정하는 데 사용됩니다. 간단히 말해서, 규칙은 "=" 등호로 정의와 구분되고, 들여쓰기는 한 줄 이상에 걸쳐 규칙 정의를 계속하는 데 사용되며, 리터럴은 ""로 인용되고, 괄호 "\(" 및 "\)"는 요소를 그룹화하는 데 사용되며, 선택 사항입니다. 요소는 "\[" 및 "\]" 대괄호로 묶이고 요소 앞에 <n\>\*를 붙여 다음 요소의 n개 이상의 반복을 지정할 수 있습니다. n의 기본값은 0입니다.

프로토콜에서 허용하는 바이트\(옥텟\)를 정의하기 위해 BNF와 유사한 문법을 ​​사용하는 많은 사양과 달리 URI 문법은 문자 측면에서 정의됩니다. 문법의 각 리터럴은 특정 코드화된 문자 집합에서 해당 문자의 옥텟 인코딩이 아니라 해당 문자가 나타내는 문자에 해당합니다. 전송 시 URI가 비트와 바이트로 표현되는 방식은 이를 전송하는 데 사용되는 프로토콜의 문자 인코딩이나 이를 포함하는 문서의 문자 집합에 따라 달라집니다.

다음 정의는 많은 요소에 공통적으로 적용됩니다.

```text
      alpha    = lowalpha | upalpha

      lowalpha = "a" | "b" | "c" | "d" | "e" | "f" | "g" | "h" | "i" |
                 "j" | "k" | "l" | "m" | "n" | "o" | "p" | "q" | "r" |
                 "s" | "t" | "u" | "v" | "w" | "x" | "y" | "z"

      upalpha  = "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" |
                 "J" | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" |
                 "S" | "T" | "U" | "V" | "W" | "X" | "Y" | "Z"

      digit    = "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" |
                 "8" | "9"

      alphanum = alpha | digit
```

전체 URI 구문은 부록 A에 수집되어 있습니다.

---
## **2. URI Characters and Escape Sequences**

URI는 주로 컴퓨터 시스템과 비컴퓨터 통신 모두에서 전사 가능성과 유용성을 돕기 위해 선택된 제한된 문자 집합으로 구성됩니다. 일반적으로 URI 주위의 구분 기호로 사용되는 문자는 제외되었습니다. 제한된 문자 집합은 숫자, 문자 및 인터넷 사용자가 사용할 수 있는 대부분의 문자 인코딩 및 입력 기능에 공통적으로 사용되는 몇 가지 그래픽 기호로 구성됩니다.

```text
      uric          = reserved | unreserved | escaped
```

URI 내에서 문자는 구분 기호로 사용되거나 구분된 부분 내의 데이터 문자열\(옥텟\)을 나타내는 데 사용됩니다. 옥텟은 문자\(해당 옥텟에 대해 US-ASCII 문자 사용\[ASCII\]\) 또는 이스케이프 인코딩으로 직접 표현됩니다. 이 표현은 아래에 자세히 설명되어 있습니다.

---
## **2.1 URI and non-ASCII characters**

URI와 문자 사이의 관계는 US-ASCII의 일부가 아닌 문자에 대한 혼란의 원인이었습니다. 관계를 설명하려면 "문자"\(구별 가능한 의미 엔터티\)와 "옥텟"\(8비트 바이트\)을 구별하는 것이 유용합니다. 두 가지 매핑이 있는데, 하나는 URI 문자에서 옥텟으로, 다른 하나는 옥텟에서 원래 문자로 매핑됩니다.

```text
   URI character sequence->octet sequence->original character sequence
```

URI는 일련의 옥텟이 아닌 일련의 문자로 표시됩니다. 이는 URI가 컴퓨터 네트워크를 통하지 않는 수단\(예: 종이에 인쇄되거나 라디오를 통해 읽는 등\)을 통해 "전송"될 수 있기 때문입니다.

URI 체계는 URI 문자에서 옥텟으로의 매핑을 정의할 수 있습니다. 이것이 수행되는지 여부는 계획에 따라 다릅니다. 일반적으로 URI의 구분된 구성 요소 내에서 문자 시퀀스를 사용하여 옥텟 시퀀스를 나타낼 수 있습니다. 예를 들어 문자 "a"는 옥텟 97\(10진수\)을 나타내고 문자 시퀀스 "%", "0", "a"는 옥텟 10\(10진수\)을 나타냅니다.

일부 리소스에 대한 두 번째 번역이 있습니다. URI의 구성 요소에 의해 정의된 옥텟 시퀀스는 이후에 문자 시퀀스를 나타내는 데 사용됩니다. '문자 세트'는 이 매핑을 정의합니다. 인터넷 프로토콜에는 많은 문자 세트가 사용됩니다. 예를 들어, UTF-8 \[UTF-8\]은 ISO 10646 레퍼토리의 옥텟 시퀀스에서 문자 시퀀스로의 매핑을 정의합니다.

가장 간단한 경우 원래 문자 시퀀스에는 US-ASCII로 정의된 문자만 포함되며 두 가지 매핑 수준은 간단하고 쉽게 반전할 수 있습니다. 각 '원래 문자'는 해당 US-ASCII 코드의 옥텟으로 표시됩니다. , 이는 US-ASCII 문자 또는 해당 옥텟에 대한 "%" 이스케이프 시퀀스로 표시됩니다.

그러나 ASCII가 아닌 문자가 포함된 원래 문자 시퀀스의 경우 상황이 더 어렵습니다. 문자 시퀀스를 나타내기 위해 옥텟 시퀀스를 전송하는 인터넷 프로토콜은 둘 이상의 문자 집합이 있는 경우 사용된 문자 집합을 식별하는 방법을 제공할 것으로 예상됩니다\[RFC2277\]. 그러나 현재 일반 URI 구문에는 이 식별을 수행하기 위한 규정이 없습니다. 개별 URI 체계에는 단일 문자 집합이 필요하거나, 기본 문자 집합을 정의하거나, 사용된 문자 집합을 표시하는 방법을 제공할 수 있습니다.

URI 내의 문자 인코딩에 대한 체계적인 처리는 본 사양의 향후 수정으로 개발될 것으로 예상됩니다.

---
### **2.2. Reserved Characters**

많은 URI에는 특정 특수 문자로 구성되거나 특수 문자로 구분된 구성 요소가 포함되어 있습니다. 이러한 문자는 URI 구성 요소 내에서의 사용이 예약된 목적으로 제한되므로 "예약됨"이라고 합니다. URI 구성 요소의 데이터가 예약된 목적과 충돌하는 경우 URI를 형성하기 전에 충돌하는 데이터를 이스케이프해야 합니다.

```text
      reserved    = ";" | "/" | "?" | ":" | "@" | "&" | "=" | "+" |
                    "$" | ","
```

위의 "예약된" 구문 클래스는 URI 내에서는 허용되지만 일반 URI 구문의 특정 구성 요소 내에서는 허용되지 않을 수 있는 문자를 나타냅니다. 이는 섹션 3에 설명된 구성 요소의 구분 기호로 사용됩니다.

"예약된" 세트의 문자는 모든 상황에서 예약된 것은 아닙니다. 특정 URI 구성 요소 내에 실제로 예약된 문자 집합은 해당 구성 요소에 의해 정의됩니다. 일반적으로 문자가 이스케이프된 US-ASCII 인코딩으로 바뀌는 경우 URI의 의미가 변경되면 문자가 예약됩니다.

---
### **2.3. Unreserved Characters**

URI에 허용되지만 예약된 용도가 없는 데이터 문자를 예약되지 않은 것으로 간주합니다. 여기에는 대문자와 소문자, 십진수, 제한된 구두점 및 기호 세트가 포함됩니다.

```text
      unreserved  = alphanum | mark

      mark        = "-" | "_" | "." | "!" | "~" | "*" | "'" | "(" | ")"
```

예약되지 않은 문자는 URI의 의미를 변경하지 않고 이스케이프할 수 있지만 이스케이프되지 않은 문자가 표시되는 것을 허용하지 않는 컨텍스트에서 URI가 사용되지 않는 한 이 작업을 수행해서는 안 됩니다.

---
### **2.4. Escape Sequences**

예약되지 않은 문자를 사용하는 표현이 없으면 데이터를 이스케이프해야 합니다. 여기에는 아래 설명과 같이 US-ASCII 코드 문자 집합의 인쇄 가능한 문자에 해당하지 않거나 허용되지 않는 US-ASCII 문자에 해당하는 데이터가 포함됩니다.

---
#### **2.4.1. Escaped Encoding**

이스케이프된 옥텟은 퍼센트 문자 "%" 뒤에 옥텟 코드를 나타내는 두 개의 16진수 숫자로 구성된 삼중 문자로 인코딩됩니다. 예를 들어 "%20"은 US-ASCII 공백 문자에 대한 이스케이프 인코딩입니다.

```text
      escaped     = "%" hex hex
      hex         = digit | "A" | "B" | "C" | "D" | "E" | "F" |
                            "a" | "b" | "c" | "d" | "e" | "f"
```

---
#### **2.4.2. When to Escape and Unescape**

완성된 URI를 이스케이프하거나 이스케이프 해제하면 의미가 변경될 수 있으므로 URI는 항상 "이스케이프된" 형식입니다. 일반적으로 안전하게 수행할 수 있는 유일한 시간 이스케이프 인코딩은 URI가 해당 구성 요소 부분에서 생성될 때입니다. 각 구성 요소에는 예약된 자체 문자 집합이 있을 수 있으므로 해당 구성 요소를 생성하거나 해석하는 메커니즘만 이를 결정할 수 있습니다.

문자를 이스케이프 처리하지 않으면 의미가 변경됩니다. 마찬가지로, 해당 구성 요소 내의 이스케이프 문자를 안전하게 디코딩하려면 먼저 URI를 해당 구성 요소로 분리해야 합니다.

어떤 경우에는 예약되지 않은 문자로 표시될 수 있는 데이터가 이스케이프된 것처럼 나타날 수 있습니다. 예를 들어 예약되지 않은 "표시" 문자 중 일부는 일부 시스템에서 자동으로 이스케이프됩니다. 지정된 URI 체계가 정규화 알고리즘을 정의하는 경우 예약되지 않은 문자는 해당 알고리즘에 따라 이스케이프 해제될 수 있습니다. 예를 들어, http URL 경로에서 "\~" 대신 "%7e"가 사용되는 경우가 있지만 이 둘은 http URL과 동일합니다.

퍼센트 "%" 문자는 항상 이스케이프 표시기라는 예약된 목적을 갖고 있으므로 URI 내에서 데이터로 사용하려면 "%25"로 이스케이프해야 합니다. 구현자는 동일한 문자열을 두 번 이상 이스케이프하거나 이스케이프 해제하지 않도록 주의해야 합니다. 이미 이스케이프 해제된 문자열을 이스케이프 해제하면 백분율 데이터 문자를 다른 이스케이프 문자로 잘못 해석할 수 있고, 이미 이스케이프된 문자열을 이스케이프하는 경우 그 반대가 될 수 있기 때문입니다.

---
#### **2.4.3. Excluded US-ASCII Characters**

URI 구문 내에서는 허용되지 않지만 여기에는 제외된 US-ASCII 문자에 대한 설명과 제외 이유가 포함되어 있습니다.

US-ASCII 코드 문자 집합의 제어 문자는 인쇄할 수 없고 일부 제어 메커니즘에 의해 잘못 해석될 가능성이 높기 때문에 URI 내에서 사용되지 않습니다.

```text
   control     = <US-ASCII coded characters 00-1F and 7F hexadecimal>
```

URI를 전사하거나 조판하거나 ​​워드프로세서 프로그램으로 처리할 때 중요한 공백이 사라지고 중요하지 않은 공백이 도입될 수 있으므로 공백 문자는 제외됩니다. 공백은 여러 상황에서 URI를 구분하는 데에도 사용됩니다.

```text
   space       = <US-ASCII coded character 20 hexadecimal>
```

꺾쇠 괄호 "<" 및 "\>"와 큰따옴표\("\) 문자는 텍스트 문서 및 프로토콜 필드에서 URI 주위의 구분 기호로 자주 사용되므로 제외됩니다. 문자 "#"은 다음 용도로 사용되므로 제외됩니다. URI 참조의 조각 식별자에서 URI를 구분합니다.\(섹션 4\) 백분율 문자 "%"는 이스케이프 문자 인코딩에 사용되므로 제외됩니다.

```text
   delims      = "<" | ">" | "#" | "%" | <">
```

게이트웨이 및 기타 전송 에이전트는 때때로 이러한 문자를 수정하거나 구분 기호로 사용되는 것으로 알려져 있으므로 다른 문자는 제외됩니다.

```text
   unwise      = "{" | "}" | "|" | "\" | "^" | "[" | "]" | "`"
```

제외된 문자에 해당하는 데이터는 URI 내에서 적절하게 표시되기 위해 이스케이프되어야 합니다.

---
## **3. URI Syntactic Components**

URI 구문은 체계에 따라 다릅니다. 일반적으로 절대 URI는 다음과 같이 작성됩니다.

```text
      <scheme>:<scheme-specific-part>
```

절대 URI에는 사용되는 체계의 이름\(<scheme\>\)과 콜론\(":"\), 그리고 체계에 따라 해석이 달라지는 문자열\(<scheme-Specific-part\>\)이 포함됩니다.

URI 구문은 스키마별 부분이 모든 URI에 공통적인 일반 구조나 의미 집합을 가질 것을 요구하지 않습니다. 그러나 URI의 하위 집합은 네임스페이스 내의 계층적 관계를 표현하기 위한 공통 구문을 공유합니다. 이 "일반 URI" 구문은 다음 네 가지 주요 구성 요소의 시퀀스로 구성됩니다.

```text
      <scheme>://<authority><path>?<query>
```

<scheme\>을 제외하고 각각은 특정 URI에 없을 수 있습니다. 예를 들어 일부 URI 구성표는 <authority\> 구성 요소를 허용하지 않고 다른 구성 요소는 <query\> 구성 요소를 사용하지 않습니다.

```text
      absoluteURI   = scheme ":" ( hier_part | opaque_part )
```

본질적으로 계층적 URI는 계층적 구성 요소를 구분하기 위해 슬래시 "/" 문자를 사용합니다. 일부 파일 시스템의 경우 "/" 문자\(URI의 계층 구조를 나타내는 데 사용됨\)는 파일 이름 계층 구조를 구성하는 데 사용되는 구분 기호이므로 URI 경로는 파일 경로 이름과 유사하게 보입니다. 이는 리소스가 파일이거나 URI가 실제 파일 시스템 경로 이름에 매핑된다는 의미는 아닙니다.

```text
      hier_part     = ( net_path | abs_path ) [ "?" query ]

      net_path      = "//" authority [ abs_path ]

      abs_path      = "/"  path_segments
```

계층적 구성 요소를 구분하기 위해 슬래시 "/" 문자를 사용하지 않는 URI는 일반 URI 구문 분석기에 의해 불투명한 것으로 간주됩니다.

```text
      opaque_part   = uric_no_slash *uric

      uric_no_slash = unreserved | escaped | ";" | "?" | ":" | "@" |
                      "&" | "=" | "+" | "$" | ","
```

<abs\_path\> 및 <opaque\_part\> 구성을 모두 참조하기 위해 <path\>라는 용어를 사용합니다. 이는 주어진 URI에 대해 상호 배타적이며 단일 구성 요소로 구문 분석될 수 있기 때문입니다.

---
### **3.1. Scheme Component**

리소스에 접근하는 방법이 다양하듯이, 그러한 리소스를 식별하는 방식도 다양합니다. URI 구문은 예약 문자로 구분된 일련의 구성 요소로 구성되며, 첫 번째 구성 요소는 나머지 URI 문자열에 대한 의미를 정의합니다.

구성표 이름은 소문자로 시작하고 그 뒤에 소문자, 숫자, 더하기\("+"\), 마침표\("."\) 또는 하이픈\("-"\)의 조합이 오는 일련의 문자로 구성됩니다. 복원력을 위해 URI를 해석하는 프로그램은 대문자를 체계 이름의 소문자와 동일하게 처리해야 합니다\(예: "HTTP"와 "http" 허용\).

```text
      scheme        = alpha *( alpha | digit | "+" | "-" | "." )
```

상대 URI 참조는 체계 이름으로 시작하지 않는다는 점에서 절대 URI와 구별됩니다. 대신, 이 체계는 섹션 5.2에 설명된 대로 기본 URI에서 상속됩니다.

---
### **3.2. Authority Component**

많은 URI 체계에는 명명 기관에 대한 최상위 계층 요소가 포함되어 있으므로 URI의 나머지 부분에 의해 정의된 네임스페이스는 해당 기관에 의해 관리됩니다. 이 권한 구성 요소는 일반적으로 인터넷 기반 서버 또는 명명 권한의 체계별 레지스트리에 의해 정의됩니다.

```text
      authority     = server | reg_name
```

권한 구성 요소 앞에는 이중 슬래시 "//"가 있고 다음 슬래시 "/", 물음표 "?" 또는 URI 끝으로 종료됩니다. 권한 구성요소 내에는 문자 ";", ":", "@", "?" 및 "/"가 예약되어 있습니다.

상대 참조를 사용하기 위해 URI 체계에는 권한 구성 요소가 필요하지 않습니다. 권한 구성 요소가 없는 기본 URI는 상대 참조에도 권한 구성 요소가 없음을 의미합니다.

---
#### **3.2.1. Registry-based Naming Authority**

레지스트리 기반 명명 기관의 구조는 URI 체계에 따라 다르지만 기관 구성 요소에 허용되는 문자로 제한됩니다.

```text
      reg_name      = 1*( unreserved | escaped | "$" | "," |
                          ";" | ":" | "@" | "&" | "=" | "+" )
```

---
#### **3.2.2. Server-based Naming Authority**

인터넷의 지정된 서버에 대한 IP 기반 프로토콜을 직접 사용하는 URL 체계는 URI 체계별 데이터의 서버 구성 요소에 대해 공통 구문을 사용합니다.

```text
      <userinfo>@<host>:<port>
```

여기서 <userinfo\>는 사용자 이름과 선택적으로 서버 액세스 권한을 얻는 방법에 대한 체계별 정보로 구성될 수 있습니다. "<userinfo\>@" 및 ":<port\>" 부분은 생략될 수 있습니다.

```text
      server        = [ [ userinfo "@" ] hostport ]
```

사용자 정보\(있는 경우\) 뒤에는 상업용 at 기호 "@"가 옵니다.

```text
      userinfo      = *( unreserved | escaped |
                         ";" | ":" | "&" | "=" | "+" | "$" | "," )
```

일부 URL 구성표는 userinfo 필드에 "user:password" 형식을 사용합니다. 인증 정보를 일반 텍스트\(예: URI\)로 전달하는 것이 거의 모든 경우에 보안 위험이 있는 것으로 입증되었기 때문에 이 방법은 권장되지 않습니다.

호스트는 네트워크 호스트의 도메인 이름이거나 "."으로 구분된 4개의 10진수 그룹 집합인 IPv4 주소입니다. 리터럴 IPv6 주소는 지원되지 않습니다.

```text
      hostport      = host [ ":" port ]
      host          = hostname | IPv4address
      hostname      = *( domainlabel "." ) toplabel [ "." ]
      domainlabel   = alphanum | alphanum *( alphanum | "-" ) alphanum
      toplabel      = alpha | alpha *( alphanum | "-" ) alphanum

      IPv4address   = 1*digit "." 1*digit "." 1*digit "." 1*digit
      port          = *digit
```

호스트 이름은 \[RFC1034\]의 섹션 3 및 \[RFC1123\]의 섹션 2.1에 설명된 형식을 취합니다. 즉, "."으로 구분된 일련의 도메인 레이블이며, 각 도메인 레이블은 영숫자 문자로 시작하고 끝나며 "-" 문자도 포함할 수 있습니다. 정규화된 도메인 이름의 가장 오른쪽 도메인 레이블은 숫자로 시작하지 않으므로 구문상 도메인 이름과 IPv4 주소를 구별하며 뒤에 단일 "."가 올 수 있습니다. 전체 도메인 이름과 로컬 도메인을 구별해야 하는 경우. 실제로 리소스 로케이터로서 "균일"하려면 URL 호스트 이름이 정규화된 도메인 이름이어야 합니다. 그러나 실제로는 호스트 구성 요소가 로컬 도메인 리터럴일 수 있습니다.

- 참고: URL의 호스트 부분으로 리터럴 IPv6 주소를 포함하는 데 적합한 표현이 필요하지만 아직 실제로 결정되거나 구현되지 않았습니다.

포트는 서버의 네트워크 포트 번호입니다. 대부분의 체계는 기본 포트 번호가 있는 프로토콜을 지정합니다. 다른 포트 번호는 선택적으로 호스트와 콜론으로 구분하여 10진수로 제공될 수 있습니다. 포트를 생략하면 기본 포트 번호로 간주됩니다.

---
### **3.3. Path Component**

경로 구성 요소에는 권한\(또는 권한 구성 요소가 없는 경우 체계\)과 관련된 데이터가 포함되어 해당 체계 및 권한 범위 내의 리소스를 식별합니다.

```text
      path          = [ abs_path | opaque_part ]

      path_segments = segment *( "/" segment )
      segment       = *pchar *( ";" param )
      param         = *pchar

      pchar         = unreserved | escaped |
                      ":" | "@" | "&" | "=" | "+" | "$" | ","
```

경로는 단일 슬래시 "/" 문자로 구분된 일련의 경로 세그먼트로 구성될 수 있습니다. 경로 세그먼트 내에서 문자 "/", ";", "=" 및 "?" 예약되어 있습니다. 각 경로 세그먼트에는 세미콜론 ";"으로 표시된 일련의 매개변수가 포함될 수 있습니다. 성격. 매개변수는 상대 참조 구문 분석에 중요하지 않습니다.

---
### **3.4. Query Component**

쿼리 구성 요소는 리소스가 해석할 정보 문자열입니다.

```text
      query         = *uric
```

쿼리 구성 요소 내에서 ";", "/", "?", ":", "@", "&", "=", "+", "," 및 "$" 문자는 예약되어 있습니다.

---
## **4. URI References**

여기에서는 "URI 참조"라는 용어를 사용하여 리소스 식별자의 일반적인 사용법을 나타냅니다. URI 참조는 절대적이거나 상대적일 수 있으며 조각 식별자 형식으로 추가 정보가 첨부될 수 있습니다. 그러나 이러한 참조에서 발생하는 "URI"에는 조각 식별자\(있는 경우\)가 제거되고 상대 URI가 절대 형식으로 확인된 후에 절대 URI만 포함됩니다. URI 구문 및 의미론에 대한 논의를 절대 결과에 대한 논의로 제한할 수는 있지만 대부분의 URI 사용은 일반 URI 참조 내에 있으며 조각을 구문 분석하고 문제를 해결하지 않고는 그러한 참조에서 URI를 얻는 것이 불가능합니다. 상대적인 형태.

```text
      URI-reference = [ absoluteURI | relativeURI ] [ "#" fragment ]
```

상대 URI 구문은 절대 URI 구문의 단축 형식으로, URI의 일부 접두사가 누락되고 특정 경로 구성 요소\("." 및 ".."\)가 상대 URI를 해석할 때만 특별한 의미를 갖습니다. 길. 상대 URI 구문은 섹션 5에 정의되어 있습니다.

---
### **4.1. Fragment Identifier**

URI 참조가 식별된 리소스에 대한 검색 작업을 수행하는 데 사용되는 경우 크로스해칭\("#"\) 문자로 URI와 구분된 선택적 조각 식별자는 검색 후 사용자 에이전트가 해석할 추가 참조 정보로 구성됩니다. 작업이 성공적으로 완료되었습니다. 따라서 이는 URI의 일부가 아니지만 종종 URI와 함께 사용됩니다.

```text
      fragment      = *uric
```

조각 식별자의 의미는 참조에 사용된 URI 유형에 관계없이 검색 작업으로 인해 발생하는 데이터 속성입니다. 따라서 조각 식별자의 형식과 해석은 검색 결과의 미디어 유형 \[RFC2046\]에 따라 달라집니다. 섹션 2에 설명된 문자 제한

URI의 경우 URI 참조의 조각에도 적용됩니다. 개별 미디어 유형은 해당 미디어 유형 내에서 식별할 수 있는 다양한 유형의 "부분 보기"를 지정하기 위해 조각 내에서 추가 제한 사항이나 구조를 정의할 수 있습니다.

조각 식별자는 URI 참조가 검색용이고 해당 검색 결과가 식별된 조각이 일관되게 정의된 문서인 경우에만 의미가 있습니다.

---
### **4.2. Same-document References**

URI를 포함하지 않는 URI 참조는 현재 문서에 대한 참조입니다. 즉, 문서 내의 빈 URI 참조는 해당 문서의 시작에 대한 참조로 해석되고, 조각 식별자만 포함된 참조는 해당 문서의 식별된 조각에 대한 참조입니다. 이러한 참조를 순회해도 추가 검색 작업이 발생해서는 안 됩니다. 그러나 HTML의 FORM 요소의 경우처럼 항상 새 요청을 발생시키려는 컨텍스트에서 URI 참조가 발생하는 경우 빈 URI 참조는 현재 문서의 기본 URI를 나타내며 해당 URI로 대체되어야 합니다. 요청으로 변환될 때.

---
### **4.3. Parsing a URI Reference**

URI 참조는 일반적으로 어떤 구성 요소가 존재하는지, 그리고 참조가 상대적인지 절대적인지 여부를 결정하기 위해 네 가지 주요 구성 요소와 조각 식별자에 따라 구문 분석됩니다. 그런 다음 개별 구성 요소를 해당 하위 부분에 대해 구문 분석하고 불투명하지 않은 경우 유효성을 확인합니다.

BNF는 각 구성 요소에 허용되는 내용을 정의하지만 권한 구성 요소와 두 개의 슬래시 문자로 시작하는 경로 구성 요소를 구별하는 측면에서 모호합니다. 명확성을 위해 욕심 많은 알고리즘이 사용됩니다. 가장 왼쪽 일치 규칙은 일치할 수 있는 만큼의 URI 참조 문자열을 흡수합니다. 즉, 권위 구성 요소가 승리합니다.

정규식에 익숙한 독자는 부록 B에서 구체적인 구문 분석 예제와 Oracle 테스트를 참조해야 합니다.

---
## **5. Relative URI References**

공통 목적을 달성하기 위해 문서 그룹 또는 "트리"가 구성된 경우가 많습니다. 이 문서에 있는 대부분의 URI는 리소스가 아닌 트리 내의 리소스를 가리킵니다.

그것 밖에. 마찬가지로, 특정 사이트에 있는 문서는 원격 사이트의 리소스보다 해당 사이트의 다른 리소스를 참조할 가능성이 훨씬 더 높습니다.

URI의 상대 주소 지정을 사용하면 문서 트리가 해당 위치 및 액세스 체계와 부분적으로 독립될 수 있습니다. 예를 들어, 문서가 상대 URI를 사용하여 서로를 참조하는 경우 단일 하이퍼텍스트 문서 세트에 "file", "http" 및 "ftp" 체계 각각을 통해 동시에 액세스하고 탐색할 수 있습니다. 또한 이러한 문서 트리는 상대 참조를 변경하지 않고도 전체적으로 이동할 수 있습니다. WWW 내에서의 경험을 통해 임베디드 URI의 장기적 사용을 위해서는 상대 참조를 수행하는 능력이 필요하다는 것이 입증되었습니다.

상대 URI 구문은 다른 계층적 URI의 네임스페이스에 상대적인 참조를 표현하기 위해 <absoluteURI\>\(섹션 3\)의 <hier\_part\> 구문을 활용합니다.

```text
      relativeURI   = ( net_path | abs_path | rel_path ) [ "?" query ]
```

두 개의 슬래시 문자로 시작하는 상대 참조를 섹션 3의 <net\_path\>에 정의된 대로 네트워크 경로 참조라고 합니다. 이러한 참조는 거의 사용되지 않습니다.

단일 슬래시 문자로 시작하는 상대 참조를 섹션 3의 <abs\_path\>에 정의된 대로 절대 경로 참조라고 합니다.

구성표 이름이나 슬래시 문자로 시작하지 않는 상대 참조를 상대 경로 참조라고 합니다.

```text
      rel_path      = rel_segment [ abs_path ]

      rel_segment   = 1*( unreserved | escaped |
                          ";" | "@" | "&" | "=" | "+" | "$" | "," )
```

상대 경로 참조 내에서 전체 경로 세그먼트 "." 및 ".."는 각각 "현재 계층 수준" 및 "이 계층 수준 위의 수준"이라는 특별한 의미를 갖습니다. 이는 디렉터리 수준을 나타내기 위해 Unix 기반 파일 시스템 내에서 사용하는 것과 매우 유사하지만 이러한 경로 구성 요소는 상대 경로 참조를 절대 형식\(섹션 5.2\)으로 확인할 때만 특수한 것으로 간주됩니다.

작성자는 콜론 문자가 포함된 경로 세그먼트를 상대 URI 경로\(예: "this:that"\)의 첫 번째 세그먼트로 사용할 수 없다는 점을 알고 있어야 합니다. 왜냐하면 스키마 이름으로 오해될 수 있기 때문입니다.

따라서 해당 세그먼트가 상대 경로로 참조되도록 하려면 해당 세그먼트 앞에 다른 세그먼트\(예: "./this:that"\)를 추가해야 합니다.

특정 체계 내의 모든 URI가 <hier\_part\> 구문으로 제한될 필요는 없습니다. 해당 구문의 계층적 속성은 특정 문서 내에서 상대 URI가 사용될 때만 필요하기 때문입니다. 문서는 기본 URI가 <hier\_part\> 구문에 맞는 경우에만 상대 URI를 사용할 수 있습니다. 상대 참조를 포함하는 모든 문서에는 구문을 따르는 기본 URI도 있다고 가정합니다. 즉, 기본 URI가 적합하지 않은 문서 내에서는 상대 URI를 사용할 수 없습니다.

일부 URI 체계는 <hier\_part\> 구문과 일치하는 계층적 구문을 허용하지 않으므로 상대 참조를 사용할 수 없습니다.

---
### **5.1. Establishing a Base URI**

"상대 URI"라는 용어는 상대 참조가 적용되는 절대 "기본 URI"가 존재함을 의미합니다. 실제로 기본 URI는 상대 URI 참조의 의미를 정의하는 데 필요합니다. 그것이 없으면 상대 참조는 의미가 없습니다. 문서 내에서 상대 URI를 사용할 수 있으려면 해당 문서의 기본 URI가 파서에 알려져야 합니다.

문서의 기본 URI는 아래에 우선 순위에 따라 나열된 네 가지 방법 중 하나로 설정할 수 있습니다. 우선순위는 레이어 측면에서 생각할 수 있으며, 여기서 가장 안쪽에 정의된 기본 URI가 가장 높은 우선순위를 갖습니다. 이는 다음과 같이 그래픽으로 시각화할 수 있습니다.

```text
      .----------------------------------------------------------.
      |  .----------------------------------------------------.  |
      |  |  .----------------------------------------------.  |  |
      |  |  |  .----------------------------------------.  |  |  |
      |  |  |  |  .----------------------------------.  |  |  |  |
      |  |  |  |  |       <relative_reference>       |  |  |  |  |
      |  |  |  |  `----------------------------------'  |  |  |  |
      |  |  |  | (5.1.1) Base URI embedded in the       |  |  |  |
      |  |  |  |         document's content             |  |  |  |
      |  |  |  `----------------------------------------'  |  |  |
      |  |  | (5.1.2) Base URI of the encapsulating entity |  |  |
      |  |  |         (message, document, or none).        |  |  |
      |  |  `----------------------------------------------'  |  |
      |  | (5.1.3) URI used to retrieve the entity            |  |
      |  `----------------------------------------------------'  |
      | (5.1.4) Default Base URI is application-dependent        |
      `----------------------------------------------------------'
```

---
#### **5.1.1. Base URI within Document Content**

특정 문서 미디어 유형 내에서 문서의 기본 URI는 파서가 쉽게 얻을 수 있도록 콘텐츠 자체에 포함될 수 있습니다. 이는 일반적인 검색 컨텍스트\(예: 전자 메일 또는 USENET 뉴스\)가 아닌 프로토콜을 통해 다른 사람에게 전송될 수 있는 목차와 같은 설명 문서에 유용할 수 있습니다.

각 미디어 유형에 대해 기본 URI를 삽입하는 방법을 지정하는 것은 이 문서의 범위를 벗어납니다. 그러한 미디어 유형을 조작하는 사용자 에이전트는 해당 미디어 유형의 사양에서 적절한 구문을 얻을 수 있다고 가정합니다. 기본 URI가 HTML\(Hypertext Markup Language\) \[RFC1866\]에 삽입될 수 있는 방법에 대한 예가 부록 D에 제공되어 있습니다.

MIME 컨테이너 유형\(예: 메시지 및 멀티파트 유형\) 내에 기본 URI를 삽입하는 메커니즘은 MHTML \[RFC2110\]에 정의되어 있습니다. MIME 메시지 헤더 구문을 사용하지 않지만 일부 형태의 태그가 지정된 메타정보가 메시지 내에 포함될 수 있도록 허용하는 프로토콜은 기본 URI를 메시지의 일부로 정의하기 위한 자체 구문을 정의할 수 있습니다.

---
#### **5.1.2. Base URI from the Encapsulating Entity**

기본 URI가 포함되지 않은 경우 문서의 기본 URI는 문서의 검색 컨텍스트에 의해 정의됩니다. 다른 엔터티\(예: 메시지 또는 다른 문서\) 내에 포함된 문서의 경우 검색 컨텍스트는 해당 엔터티입니다. 따라서 문서의 기본 기본 URI는 문서가 캡슐화되는 엔터티의 기본 URI입니다.

---
#### **5.1.3. Base URI from the Retrieval URI**

기본 URI가 내장되어 있지 않고 문서가 다른 엔터티\(예: 복합 엔터티의 최상위 수준\) 내에 캡슐화되지 않은 경우 URI가 기본 문서를 검색하는 데 사용된 경우 해당 URI는 기본 URI로 간주됩니다. 검색이 리디렉션된 요청의 결과인 경우 사용된 마지막 URI\(즉, 문서의 실제 검색 결과\)가 기본 URI입니다.

---
#### **5.1.4. Default Base URI**

섹션 5.1.1-5.1.3에 설명된 조건 중 어느 것도 적용되지 않으면 기본 URI는 애플리케이션의 컨텍스트에 의해 정의됩니다. 이 정의는 반드시 애플리케이션에 따라 다르므로 실패합니다.

다른 방법 중 하나를 사용하여 기본 URI를 정의하면 동일한 콘텐츠가 애플리케이션 유형에 따라 다르게 해석될 수 있습니다.

해당 문서에 대한 기본 URI가 설정될 수 있도록 보장하는 것은 상대 URI를 포함하는 문서 배포자의 책임입니다. 문서의 기본 URI가 잘 정의되지 않은 상황에서는 상대 URI를 안정적으로 사용할 수 없다는 점을 강조해야 합니다.

---
### **5.2. Resolving Relative References to Absolute Form**

이 섹션에서는 주어진 기본 URI에 상대적일 수 있는 URI 참조를 확인하기 위한 예제 알고리즘을 설명합니다.

기본 URI는 섹션 5.1의 규칙에 따라 설정되고 섹션 3에 설명된 대로 네 가지 주요 구성 요소로 구문 분석됩니다. 기본 URI에는 스키마 구성 요소만 있어야 한다는 점에 유의하세요. 다른 구성 요소는 비어 있거나 정의되지 않을 수 있습니다. 선행 구분 기호가 URI 참조에 나타나지 않으면 구성 요소는 정의되지 않습니다. 경로 구성 요소는 비어 있을 수 있지만 정의되지 않은 경우는 없습니다. 기본 URI의 쿼리 구성 요소는 확인 알고리즘에서 사용되지 않으며 삭제될 수 있습니다.

각 URI 참조에 대해 다음 단계가 순서대로 수행됩니다.

1\) URI 참조는 섹션 4.3에 설명된 대로 잠재적인 4개 구성 요소와 조각 식별자로 구문 분석됩니다.

2\) 경로 구성 요소가 비어 있고 체계, 권한 및 쿼리 구성 요소가 정의되지 않은 경우 현재 문서에 대한 참조이므로 작업이 완료됩니다. 그렇지 않은 경우 참조 URI의 쿼리 및 조각 구성 요소는 URI 참조 내에서 찾은\(또는 찾을 수 없는\) 것으로 정의되며 기본 URI에서 상속되지 않습니다.

3\) 참조가 스키마 이름으로 시작함을 나타내는 스키마 구성 요소가 정의된 경우 참조는 절대 URI로 해석되고 완료됩니다. 그렇지 않으면 참조 URI의 체계가 기본 URI의 체계 구성 요소에서 상속됩니다.

- 이전 사양 \[RFC1630\]의 허점으로 인해 일부 파서는 스키마 이름이 기본 URI 스키마와 동일한 경우 상대 URI에 존재할 수 있도록 허용합니다. 불행하게도 이는 비계층적 URI의 올바른 구문 분석과 충돌할 수 있습니다. 이전 버전과의 호환성을 위해 구현은 기본 URI의 구성표와 일치하고 구성표가 항상 <hier\_part\> 구문을 사용하는 것으로 알려진 경우 구성표를 제거하여 이러한 참조를 해결할 수 있습니다. 파서

- 그런 다음 나머지 참조 구성 요소에 대해 아래 단계를 계속할 수 있습니다. 파서의 유효성을 검사하면 이러한 잘못된 상대 참조를 오류로 표시해야 합니다.

4\) 권한 구성 요소가 정의된 경우 참조는 -network-path이며 7단계로 건너뜁니다. 그렇지 않으면 참조 URI의 권한은 기본 URI의 권한 구성 요소에서 상속되며 URI 체계가 정의되지 않은 경우에도 정의되지 않습니다. 권한 구성 요소를 사용하지 마십시오.

5\) 경로 구성 요소가 슬래시 문자\("/"\)로 시작하는 경우 참조는 절대 경로이므로 7단계로 건너뜁니다.

6\) 이 단계에 도달하면 상대 경로 참조를 해결하는 것입니다. 상대 경로는 기본 URI의 경로와 병합되어야 합니다. 이를 수행하는 방법은 여러 가지가 있지만 별도의 문자열 버퍼를 사용하는 간단한 방법을 설명하겠습니다.

- a\) 기본 URI 경로 구성 요소의 마지막 세그먼트를 제외한 모든 부분이 버퍼에 복사됩니다. 즉, 마지막\(가장 오른쪽\) 슬래시 문자 뒤의 모든 문자가 제외됩니다.

- b\) 참조의 경로 구성 요소가 버퍼 문자열에 추가됩니다.

- c\) 모든 "./" 발생, 여기서 "." 완전한 경로 세그먼트이며 버퍼 문자열에서 제거됩니다.

- d\) 버퍼 문자열이 "."로 끝나는 경우 완전한 경로 세그먼트로서 "." 제거됩니다.

- e\) <세그먼트\>가 ".."와 같지 않은 완전한 경로 세그먼트인 경우 "<세그먼트\>/../"가 모두 발생하면 버퍼 문자열에서 제거됩니다. 이러한 경로 세그먼트 제거는 반복적으로 수행되어 일치하는 패턴이 남지 않을 때까지 각 반복에서 가장 왼쪽에 일치하는 패턴을 제거합니다.

- f\) 버퍼 문자열이 "<segment\>/.."로 끝나는 경우\(여기서 <segment\>는 ".."과 동일하지 않은 완전한 경로 세그먼트임\) 해당 "<segment\>/.."가 제거됩니다.

- g\) 결과 버퍼 문자열이 여전히 하나 이상의 ".." 전체 경로 세그먼트로 시작하는 경우 참조에 오류가 있는 것으로 간주됩니다. 구현에서는 이러한 구성 요소를 확인된 경로에 유지하거나\(즉, 최종 URI의 일부로 처리\), 확인된 경로에서 제거하거나\(즉, 루트 위의 상대 수준 삭제\), 순회를 피함으로써 이 오류를 처리할 수 있습니다. 참조.

- h\) 나머지 버퍼 문자열은 참조 URI의 새 경로 구성 요소입니다.

7\) - 기본 URI에서 상속된 요소를 포함하여 결과 URI 구성 요소는 URI 참조의 절대 형식을 제공하기 위해 다시 결합됩니다. 의사 코드를 사용하면 다음과 같습니다.

```text
         result = ""

         if scheme is defined then
             append scheme to result
             append ":" to result

         if authority is defined then
             append "//" to result
             append authority to result
```

- 결과에 경로 추가

```text
         if query is defined then
             append "?" to result
             append query to result

         if fragment is defined then
             append "#" to result
             append fragment to result

         return result
```

- 정의되지 않은 구성 요소\(참조에 구분 기호가 없음을 의미\)와 비어 있는 구성 요소\(구분 기호가 있고 바로 뒤에 다음 구성 요소가 있음을 의미\) 간의 구별을 유지하도록 주의해야 합니다. 구분 기호 또는 참조의 끝.

위의 알고리즘은 구현의 출력을 테스트할 수 있는 예를 제공하기 위한 것입니다. 알고리즘 자체의 구현은 필요하지 않습니다. 예를 들어, 일부 시스템에서는 일련의 문자열 패턴 교체보다는 병합되는 세그먼트 스택 쌍으로 6단계를 구현하는 것이 더 효율적이라는 것을 알 수 있습니다.

- 참고: 일부 WWW 클라이언트 응용 프로그램은 위의 6단계에서 기본 경로와 참조 경로를 병합하기 전에 경로 구성 요소에서 참조의 쿼리 구성 요소를 분리하지 못합니다. 쿼리 구성 요소에 "/../" 또는 "/./" 문자열이 포함되어 있으면 정보가 손실될 수 있습니다.

해결 예는 부록 C에 나와 있습니다.

---
## **6. URI Normalization and Equivalence**

많은 경우 서로 다른 URI 문자열이 실제로 동일한 리소스를 식별할 수 있습니다. 예를 들어, URL에 사용된 호스트 이름은 실제로 대소문자를 구분하지 않으며 URL <http://www.XEROX.com\>은 <http://www.xerox.com\>과 동일합니다. 일반적으로 정규형의 동등성 및 정의에 대한 규칙은 체계에 따라 다릅니다. 체계가 공통 구문의 요소를 사용하는 경우 공통 구문 동등성 규칙도 사용합니다. 즉, 체계와 호스트 이름은 대소문자를 구분하지 않고 명시적인 ":port"가 있는 URL\(여기서 포트는 체계의 기본값입니다\)을 사용합니다. 포트가 제거된 것과 동일합니다.

---
## **7. Security Considerations**

URI 자체는 보안 위협을 일으키지 않습니다. 사용자는 특정 리소스를 한 번에 찾은 URL이 계속 그렇게 할 것이라는 일반적인 보장은 없다는 점에 유의해야 합니다. 특정 기관이 네임스페이스를 할당하는 방법에 대한 제약이 없기 때문에 URL이 나중에 다른 리소스를 찾지 않을 것이라는 보장도 없습니다. 이러한 보증은 해당 네임스페이스와 문제의 리소스를 제어하는 ​​사람에게서만 얻을 수 있습니다. 특정 URI 체계에는 해당 체계에 대한 모든 명명 기관에 의미 체계가 필요한 경우 이름 지속성과 같은 추가 의미 체계가 포함될 수 있습니다.

리소스와 관련된 엔터티 검색과 같이 외관상 무해하고 멱등적인 작업을 수행하려는 시도가 실제로는 해를 끼칠 수 있는 원격 작업이 발생하도록 URL을 구성하는 것이 가능한 경우가 있습니다. 안전하지 않은 URL은 일반적으로 문제의 네트워크 프로토콜용으로 예약된 포트 번호가 아닌 다른 포트 번호를 지정하여 구성됩니다. 클라이언트는 실제로 다른 프로토콜을 실행하는 사이트에 자신도 모르게 접속합니다. URL의 내용에는 이 다른 프로토콜에 따라 해석될 때 예기치 않은 작업이 발생하는 지침이 포함되어 있습니다. 예를 들어 의도하지 않거나 가장한 메시지가 SMTP 서버를 통해 전송되도록 하기 위해 Gopher URL을 사용하는 경우가 있습니다.

프로토콜의 기본값이 아닌 포트 번호를 지정하는 URL을 사용할 때, 특히 예약된 공간 내의 번호인 경우 주의해야 합니다.

URL에 지정된 프로토콜에 대해 이스케이프된 구분 기호\(예: 텔넷 프로토콜의 경우 CR 및 LF 문자\)가 포함된 경우 전송 전에 이스케이프 해제되지 않도록 주의해야 합니다. 이는 프로토콜을 위반할 수 있지만 그러한 가능성을 방지합니다.

해당 프로토콜에서 추가 작업이나 매개 변수를 시뮬레이션하는 데 사용되는 문자로, 이로 인해 예상치 못한 유해한 원격 작업이 수행될 수 있습니다.

비밀로 하려는 비밀번호가 포함된 URL을 사용하는 것은 분명히 현명하지 못한 일입니다. 특히, 'password' 매개변수가 공개되도록 의도된 드문 경우를 제외하고는 URL의 'userinfo' 구성요소 내에서 비밀번호를 사용하는 것은 강력히 권장되지 않습니다.

---
## **8. Acknowledgements**

이 문서는 RFC 1738 \[RFC1738\] 및 RFC 1808 \[RFC1808\]에서 파생되었습니다. 해당 사양의 승인 사항은 여전히 ​​적용됩니다. 또한 Gisle Aas, Martin Beet, Martin Duerst, Jim Gettys, Martijn Koster, Dave Kristol, Daniel LaLiberte, Foteos Macrides, James Marshall, Ryan Moats, Keith Moore 및 Lauren Wood의 기여에 감사드립니다.

---
## **9. References**

```text
   [RFC2277] Alvestrand, H., "IETF Policy on Character Sets and
             Languages", BCP 18, RFC 2277, January 1998.

   [RFC1630] Berners-Lee, T., "Universal Resource Identifiers in WWW: A
             Unifying Syntax for the Expression of Names and Addresses
             of Objects on the Network as used in the World-Wide Web",
             RFC 1630, June 1994.

   [RFC1738] Berners-Lee, T., Masinter, L., and M. McCahill, Editors,
             "Uniform Resource Locators (URL)", RFC 1738, December 1994.

   [RFC1866] Berners-Lee T., and D. Connolly, "HyperText Markup Language
             Specification -- 2.0", RFC 1866, November 1995.

   [RFC1123] Braden, R., Editor, "Requirements for Internet Hosts --
             Application and Support", STD 3, RFC 1123, October 1989.

   [RFC822]  Crocker, D., "Standard for the Format of ARPA Internet Text
             Messages", STD 11, RFC 822, August 1982.

   [RFC1808] Fielding, R., "Relative Uniform Resource Locators", RFC
             1808, June 1995.

   [RFC2046] Freed, N., and N. Borenstein, "Multipurpose Internet Mail
             Extensions (MIME) Part Two: Media Types", RFC 2046,
             November 1996.

   [RFC1736] Kunze, J., "Functional Recommendations for Internet
             Resource Locators", RFC 1736, February 1995.

   [RFC2141] Moats, R., "URN Syntax", RFC 2141, May 1997.

   [RFC1034] Mockapetris, P., "Domain Names - Concepts and Facilities",
             STD 13, RFC 1034, November 1987.

   [RFC2110] Palme, J., and A. Hopmann, "MIME E-mail Encapsulation of
             Aggregate Documents, such as HTML (MHTML)", RFC 2110, March
             1997.

   [RFC1737] Sollins, K., and L. Masinter, "Functional Requirements for
             Uniform Resource Names", RFC 1737, December 1994.

   [ASCII]   US-ASCII. "Coded Character Set -- 7-bit American Standard
             Code for Information Interchange", ANSI X3.4-1986.

   [UTF-8]   Yergeau, F., "UTF-8, a transformation format of ISO 10646",
             RFC 2279, January 1998.
```

---
## **10. Authors' Addresses**

Tim Berners-Lee 월드 와이드 웹 컨소시엄 MIT 컴퓨터 과학 연구소, NE43-356 545 Technology Square Cambridge, MA 02139

```text
   Fax: +1(617)258-8682
   EMail: timbl@w3.org
```

Roy T. Fielding 정보 및 컴퓨터 과학과 University of California, Irvine Irvine, CA 92697-3425

```text
   Fax: +1(949)824-1715
   EMail: fielding@ics.uci.edu

   Larry Masinter
   Xerox PARC
   3333 Coyote Hill Road
   Palo Alto, CA 94034

   Fax: +1(415)812-4333
   EMail: masinter@parc.xerox.com
```

---
## **A. Collected BNF for URI**

```text
      URI-reference = [ absoluteURI | relativeURI ] [ "#" fragment ]
      absoluteURI   = scheme ":" ( hier_part | opaque_part )
      relativeURI   = ( net_path | abs_path | rel_path ) [ "?" query ]

      hier_part     = ( net_path | abs_path ) [ "?" query ]
      opaque_part   = uric_no_slash *uric

      uric_no_slash = unreserved | escaped | ";" | "?" | ":" | "@" |
                      "&" | "=" | "+" | "$" | ","

      net_path      = "//" authority [ abs_path ]
      abs_path      = "/"  path_segments
      rel_path      = rel_segment [ abs_path ]

      rel_segment   = 1*( unreserved | escaped |
                          ";" | "@" | "&" | "=" | "+" | "$" | "," )

      scheme        = alpha *( alpha | digit | "+" | "-" | "." )

      authority     = server | reg_name

      reg_name      = 1*( unreserved | escaped | "$" | "," |
                          ";" | ":" | "@" | "&" | "=" | "+" )

      server        = [ [ userinfo "@" ] hostport ]
      userinfo      = *( unreserved | escaped |
                         ";" | ":" | "&" | "=" | "+" | "$" | "," )

      hostport      = host [ ":" port ]
      host          = hostname | IPv4address
      hostname      = *( domainlabel "." ) toplabel [ "." ]
      domainlabel   = alphanum | alphanum *( alphanum | "-" ) alphanum
      toplabel      = alpha | alpha *( alphanum | "-" ) alphanum
      IPv4address   = 1*digit "." 1*digit "." 1*digit "." 1*digit
      port          = *digit

      path          = [ abs_path | opaque_part ]
      path_segments = segment *( "/" segment )
      segment       = *pchar *( ";" param )
      param         = *pchar
      pchar         = unreserved | escaped |
                      ":" | "@" | "&" | "=" | "+" | "$" | ","

      query         = *uric

      fragment      = *uric

      uric          = reserved | unreserved | escaped
      reserved      = ";" | "/" | "?" | ":" | "@" | "&" | "=" | "+" |
                      "$" | ","
      unreserved    = alphanum | mark
      mark          = "-" | "_" | "." | "!" | "~" | "*" | "'" |
                      "(" | ")"

      escaped       = "%" hex hex
      hex           = digit | "A" | "B" | "C" | "D" | "E" | "F" |
                              "a" | "b" | "c" | "d" | "e" | "f"

      alphanum      = alpha | digit
      alpha         = lowalpha | upalpha

      lowalpha = "a" | "b" | "c" | "d" | "e" | "f" | "g" | "h" | "i" |
                 "j" | "k" | "l" | "m" | "n" | "o" | "p" | "q" | "r" |
                 "s" | "t" | "u" | "v" | "w" | "x" | "y" | "z"
      upalpha  = "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" |
                 "J" | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" |
                 "S" | "T" | "U" | "V" | "W" | "X" | "Y" | "Z"
      digit    = "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" |
                 "8" | "9"
```

---
## **B. Parsing a URI Reference with a Regular Expression**

섹션 4.3에 설명된 대로 일반 URI 구문은 일부 URI 형식의 구성 요소를 명확하게 하는 데 충분하지 않습니다. 해당 섹션에 설명된 "탐욕 알고리즘"은 POSIX 정규 표현식에서 사용하는 명확성 방법과 동일하므로 URI 참조의 잠재적인 네 가지 구성 요소와 조각 식별자를 구문 분석하기 위해 정규 표현식을 사용하는 것이 자연스럽고 일반적입니다.

다음 줄은 URI 참조를 해당 구성 요소로 분류하기 위한 정규식입니다.

```text
      ^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?
       12            3  4          5       6  7        8 9
```

위의 두 번째 줄에 있는 숫자는 가독성을 돕기 위한 것입니다. 이는 각 하위 표현식\(즉, 각 쌍의 괄호\)에 대한 참조 지점을 나타냅니다. 하위 표현식 <n\>과 일치하는 값을 $<n\>이라고 합니다. 예를 들어, 위의 표현식을 다음과 일치시킵니다.

```text
      http://www.ics.uci.edu/pub/ietf/uri/#Related
```

결과적으로 다음 하위 표현식이 일치합니다.

```text
      $1 = http:
      $2 = http
      $3 = //www.ics.uci.edu
      $4 = www.ics.uci.edu
      $5 = /pub/ietf/uri/
      $6 = <undefined>
      $7 = <undefined>
      $8 = #Related
      $9 = Related
```

여기서 <정의되지 않음\>은 위 예의 쿼리 구성 요소와 마찬가지로 구성 요소가 존재하지 않음을 나타냅니다. 따라서 우리는 네 가지 구성 요소와 조각의 가치를 다음과 같이 결정할 수 있습니다.

```text
      scheme    = $2
      authority = $4
      path      = $5
      query     = $7
      fragment  = $9
```

반대 방향으로 진행하면 섹션 5.2의 7단계에 있는 알고리즘을 사용하여 해당 구성 요소에서 URI 참조를 다시 만들 수 있습니다.

---
## **C. Examples of Resolving Relative URI References**

잘 정의된 기본 URI가 있는 객체 내에서

```text
      http://a/b/c/d;p?q
```

상대 URI는 다음과 같이 확인됩니다.

---
### **C.1.  Normal Examples**

```text
      g:h           =  g:h
      g             =  http://a/b/c/g
      ./g           =  http://a/b/c/g
      g/            =  http://a/b/c/g/
      /g            =  http://a/g
      //g           =  http://g
      ?y            =  http://a/b/c/?y
      g?y           =  http://a/b/c/g?y
      #s            =  (current document)#s
      g#s           =  http://a/b/c/g#s
      g?y#s         =  http://a/b/c/g?y#s
      ;x            =  http://a/b/c/;x
      g;x           =  http://a/b/c/g;x
      g;x?y#s       =  http://a/b/c/g;x?y#s
      .             =  http://a/b/c/
      ./            =  http://a/b/c/
      ..            =  http://a/b/
      ../           =  http://a/b/
      ../g          =  http://a/b/g
      ../..         =  http://a/
      ../../        =  http://a/
      ../../g       =  http://a/g
```

---
### **C.2.  Abnormal Examples**

다음과 같은 비정상적인 예는 일반적인 상황에서는 발생할 가능성이 거의 없지만 모든 URI 파서는 이를 일관되게 해결할 수 있어야 합니다. 각 예에서는 위와 동일한 기반을 사용합니다.

빈 참조는 현재 문서의 시작을 나타냅니다.

```text
      <>            =  (current document)
```

파서는 기본 URI 경로에 계층적 수준보다 상대 경로 ".." 세그먼트가 더 많은 경우를 처리할 때 주의해야 합니다. ".." 구문은 URI의 권한 구성 요소를 변경하는 데 사용할 수 없습니다.

```text
      ../../../g    =  http://a/../g
      ../../../../g =  http://a/../../g
```

실제로 일부 구현에서는 명백한 작성자 오류를 보상하는 것이 요청 실패를 허용하는 것보다 낫다는 이론에 기초하여 상대 URI 계산을 적용한 후 선행 상대 기호 요소\(".", ".."\)를 제거합니다. 따라서 위의 두 참조는 일부 구현에서 "http://a/g"로 해석됩니다.

마찬가지로, 파서도 "." 처리를 피해야 합니다. 및 ".."은 상대 경로의 완전한 구성 요소가 아닌 경우 특수한 것으로 간주됩니다.

```text
      /./g          =  http://a/./g
      /../g         =  http://a/../g
      g.            =  http://a/b/c/g.
      .g            =  http://a/b/c/.g
      g..           =  http://a/b/c/g..
      ..g           =  http://a/b/c/..g
```

상대 URI가 "."의 불필요하거나 무의미한 형식을 사용하는 경우는 거의 없습니다. 및 ".."는 전체 경로 세그먼트입니다.

```text
      ./../g        =  http://a/b/g
      ./g/.         =  http://a/b/c/g/
      g/./h         =  http://a/b/c/g/h
      g/../h        =  http://a/b/c/h
      g;x=1/./y     =  http://a/b/c/g;x=1/y
      g;x=1/../y    =  http://a/b/c/y
```

모든 클라이언트 애플리케이션은 상대 URI를 확인하기 전에 기본 URI에서 쿼리 구성 요소를 제거합니다. 그러나 일부 애플리케이션은 참조의 쿼리 및/또는 조각 구성 요소를 기본 경로와 병합하기 전에 상대 경로에서 분리하지 못합니다. 일반적인 조각 사용에는 계층 구조\("/"\) 문자가 포함되지 않고 쿼리 구성 요소가 일반적으로 상대 참조 내에서 사용되지 않기 때문에 이 오류는 거의 발견되지 않습니다.

```text
      g?y/./x       =  http://a/b/c/g?y/./x
      g?y/../x      =  http://a/b/c/g?y/../x
      g#s/./x       =  http://a/b/c/g#s/./x
      g#s/../x      =  http://a/b/c/g#s/../x
```

일부 파서는 기본 URI 체계와 동일한 경우 체계 이름이 상대 URI에 존재할 수 있도록 허용합니다. 이는 부분 URI \[RFC1630\]의 이전 사양에서 허점으로 간주됩니다. 그 사용을 피해야 합니다.

```text
      http:g        =  http:g           ; for validating parsers
                    |  http://a/b/c/g   ; for backwards compatibility
```

---
## **D. Embedding the Base URI in HTML documents**

문서의 기본 URI가 문서 콘텐츠에 어떻게 포함될 수 있는지에 대한 예를 고려하는 것이 유용합니다. 이 부록에서는 HTML\(Hypertext Markup Language\) \[RFC1866\]로 작성된 문서에 내장된 기본 URI가 포함될 수 있는 방법을 설명합니다. 이 부록은 URI 사양의 일부를 구성하지 않으며 설명적인 예 이상으로 간주되어서는 안 됩니다.

HTML은 문서의 "HEAD" 부분에 존재할 때 파서가 BASE 요소의 "HREF" 속성을 상대 URI를 해결하기 위한 기본 URI로 사용해야 한다는 신호를 보내는 특수 요소 "BASE"를 정의합니다. "HREF" 특성은 절대 URI여야 합니다. HTML에서는 요소 및 속성 이름이 대소문자를 구분하지 않습니다. 예를 들어:

```text
      <!doctype html public "-//IETF//DTD HTML//EN">
      <HTML><HEAD>
      <TITLE>An example HTML document</TITLE>
      <BASE href="http://www.ics.uci.edu/Test/a/b/c">
      </HEAD><BODY>
      ... <A href="../x">a hypertext anchor</A> ...
      </BODY></HTML>
```

예제 문서를 읽는 파서는 주어진 상대 URI "../x"를 절대 URI를 나타내는 것으로 해석해야 합니다.

```text
      <http://www.ics.uci.edu/Test/a/x>
```

예제 문서를 얻은 상황에 관계없이.

---
## **E. Recommendations for Delimiting URI in Context**

URI는 해석을 위한 명확한 컨텍스트를 제공하지 않는 형식을 통해 전송되는 경우가 많습니다. 예를 들어 URI가 일반 텍스트에 포함되는 경우가 많습니다. 예로는 전자 메일로 전송된 텍스트, USENET 뉴스 메시지, 그리고 가장 중요하게는 종이에 인쇄된 텍스트가 포함됩니다. 이러한 경우에는 URI를 텍스트의 나머지 부분, 특히 URI의 일부로 오해할 수 있는 구두점에서 구분할 수 있는 것이 중요합니다.

실제로 URI는 다양한 방법으로 구분되지만 일반적으로 큰따옴표 "http://test.com/", 꺾쇠 괄호 <http://test.com/\> 또는 공백을 사용하여 구분됩니다.

```text
                             http://test.com/
```

이러한 래퍼는 URI의 일부를 구성하지 않습니다.

조각 식별자가 URI 참조와 연결된 경우 조각도 대괄호 안에 배치됩니다\("#" 문자로 URI와 구분됨\).

경우에 따라 여러 줄에 걸쳐 긴 URI를 나누기 위해 추가 공백\(공백, 줄 바꿈, 탭 등\)을 추가해야 할 수도 있습니다. URI를 추출할 때 공백은 무시되어야 합니다.

하이픈\("-"\) 문자 뒤에는 공백이 들어가지 않아야 합니다. 일부 조판기와 프린터는 줄을 나눌 때 줄 끝에 하이픈을 \(잘못\) 삽입할 수 있기 때문에 하이픈 바로 뒤에 줄 바꿈이 포함된 URI의 해석기는 줄 바꿈 주위의 이스케이프되지 않은 공백을 모두 무시해야 하며 다음 사항을 알고 있어야 합니다. 하이픈은 실제로 URI의 일부일 수도 있고 아닐 수도 있습니다.

공백이 포함된 URI의 구분 스타일로 각 URI 주위에 <\> 꺾쇠 괄호를 사용하는 것이 특히 권장됩니다.

접두사 "URL:"\(뒤에 공백이 있거나 없음\)은 URL을 다른 대괄호 지정자와 구별하는 데 도움이 되는 방법으로 권장되지만 실제로는 일반적이지 않습니다.

견고성을 위해 사용자가 입력한 URI를 허용하는 소프트웨어는 구분 기호와 포함된 공백을 모두 인식하고 제거해야 합니다.

예를 들어, 텍스트는 다음과 같습니다.

- 예, Jim. "http://www.w3.org/Addressing/"에서 찾았습니다. 하지만 아마도 <ftp://ds.internic에서 찾으실 수 있을 것입니다. 넷/rfc/\>. <http://www.ics.uci.edu/pub/ietf/uri/historical.html#WARNING\>의 경고에 유의하십시오.

URI 참조가 포함되어 있습니다.

```text
      http://www.w3.org/Addressing/
      ftp://ds.internic.net/rfc/
      http://www.ics.uci.edu/pub/ietf/uri/historical.html#WARNING
```

---
## **F. Abbreviated URLs**

URL 구문은 네트워크 리소스에 대한 명확한 참조와 URL 구성표를 통한 확장성을 위해 설계되었습니다. 그러나 URL 식별 및 사용이 일반화됨에 따라 기존 미디어\(텔레비전, 라디오, 신문, 광고판 등\)에서는 축약된 URL 참조를 점점 더 많이 사용하고 있습니다. 즉, 식별된 리소스의 권한과 경로 부분만으로 구성된 참조입니다.

```text
      www.w3.org/Addressing/
```

또는 단순히 DNS 호스트 이름 자체일 수도 있습니다. 이러한 참조는 주로 기계가 아닌 사람의 해석을 위한 것이며, 컨텍스트 기반 경험적 방법이 URL을 완성하는 데 충분하다는 가정하에 사용됩니다\(예: "www"로 시작하는 대부분의 호스트 이름에는 "http://"라는 URL 접두사가 있을 가능성이 높습니다\). \). 축약된 URL 참조를 명확하게 구분하기 위한 표준 경험적 방법 세트는 없지만 많은 클라이언트 구현을 통해 사용자가 해당 참조를 입력하고 경험적으로 해결할 수 있습니다. 이러한 경험적 방법은 시간이 지남에 따라, 특히 새로운 URL 구성표가 도입될 때 변경될 수 있다는 점에 유의해야 합니다.

단축 URL은 상대 URL 경로와 구문이 동일하므로 상대 URL이 필요한 상황에서는 단축 URL 참조를 사용할 수 없습니다. 이는 대화 상자 및 오프라인 광고와 같이 정의된 기본 URL이 없는 곳으로 축약된 URL의 사용을 제한합니다.

---
## **G. Summary of Non-editorial Changes**
---
### **G.1. Additions**

섹션 4\(URI 참조\)는 "URI가 무엇인지"에 대한 혼란과 URI의 일부는 아니지만 URI 구문 및 구문 분석 문제의 일부인 조각 식별자를 설명하는 방법에 대해 추가되었습니다. 또한 URI 참조에 있는 조각 식별자의 존재를 설명하기 위해 이전에 URI 구문을 재정의하려고 시도한 다른 IETF 사양\(HTML, HTTP 등\)에서 사용할 참조 정의를 제공합니다.

여러 가지 잘못된 해석을 명확히 하고 완전히 국제화된 URI를 위한 여지를 남기기 위해 섹션 2.4를 다시 작성했습니다.

단축된 URL에 대한 부록 F는 텔레비전과 잡지 광고에서 자주 볼 수 있는 단축된 참조를 설명하고 다른 맥락에서 사용되지 않는 이유를 설명하기 위해 추가되었습니다.

---
### **G.2. Modifications from both RFC 1738 and RFC 1808**

URL 대신 URI 구문으로 변경되었습니다.

"문자 인코딩"이라는 용어, URI "문자 집합" 및 %<hex\><hex\> 등가물을 사용한 문자 이스케이프와 관련된 혼란이 \(희망적으로\) 줄어들었습니다. 문자 집합과 관련된 많은 BNF 규칙 이름은 해당 목적을 더 정확하게 설명하고 US-ASCII 옥텟이 아닌 모든 "문자"를 포함하도록 변경되었습니다. 여기에 별도로 명시하지 않는 한 이러한 수정 사항은 URI 구문에 영향을 주지 않습니다.

RFC 1738과 RFC 1808은 모두 URI 해석 소프트웨어가 예약된 목적\(즉, 문자가 해당하는 데이터가 아닌 다른 것을 의미함\)을 가진 단일 문자 세트로 제한되는 것처럼 "예약된" 문자 세트를 참조합니다. 그리고 이 세트는 URI 체계에 의해 수정되었습니다. 그러나 이는 실제로는 사실이 아닙니다. 이스케이프 처리될 때 다르게 해석되는 모든 문자는 사실상 예약되어 있습니다. 게다가 HTTP 서버의 해석 엔진은 URI 체계뿐만 아니라 리소스에 의존하는 경우가 많습니다. 이에 따라 예약된 문자에 대한 설명이 변경되었습니다.

더하기 "+", 달러 "$" 및 쉼표 "," 문자는 쿼리 구성 요소 내에서 예약된 것으로 처리되므로 "예약된" 세트의 문자에 추가되었습니다.

물결표 "\~" 문자는 일부 키보드로는 표기하기 어려움에도 불구하고 인터넷에서 광범위하게 사용되기 때문에 "예약되지 않음" 세트에 추가되었습니다.

모든 체계가 영문자로 시작하도록 요구하도록 URI 체계의 구문이 변경되었습니다.

이전 BNF의 "user:password" 형식은 "userinfo" 토큰으로 변경되었으며 "user:password"일 가능성은 특정 체계로 만들어졌습니다. 특히, 일반 비밀번호를 사용하는 것은 구문에서도 제안되지 않습니다.

물음표 "?" 테스트 결과 많은 애플리케이션이 이 문자를 쿼리 구성 요소를 URI의 나머지 부분과 분리하기 위해 예약된 것으로 취급하는 것으로 나타났기 때문에 권한 구성 요소의 userinfo에 대해 허용되는 문자 집합에서 문자가 제거되었습니다.

세미콜론 ";" 여러 가지 새로운 체계에서 사용자 인증 유형을 나타내기 위해 userinfo 내에서 구분 기호로 문자를 사용하고 있기 때문에 권한 구성 요소 내에서 예약된 것으로 명시된 문자에 문자가 추가되었습니다.

RFC 1738에서는 경로가 슬래시로 URI의 권한 부분과 구분되도록 지정했습니다. RFC 1808은 그 뒤를 따랐지만 구문 분석 알고리즘을 설명하기 위해 구분 기호를 "접두사"로 사용하는 퍼지를 사용했습니다. RFC 1630에서는 슬래시를 경로의 일부로 간주했기 때문에 이 문제가 발생하지 않았습니다. 이 사양을 작성할 때 슬래시를 경로의 일부로 고려하지 않고\(실제 연습\) 또는 해당 슬래시를 보관하기 위해 별도의 구성 요소를 만드는 것입니다. 우리는 전자를 선택했습니다.

---
### **G.3. Modifications from RFC 1738**

특정 URL 구성표의 정의와 해당 구성표별 구문 및 의미는 별도의 문서로 이동되었습니다.

URL 호스트가 정규화된 도메인 이름으로 정의되었습니다. 그러나 많은 URL은 정규화된 도메인 이름 없이\(전체 정규화가 필요하지 않은 컨텍스트에서\) 호스트 없이\(일부 파일 URL에서처럼\) 또는 "localhost" 호스트와 함께 사용됩니다.

이제 URL 포트는 1\*숫자 대신 \*숫자입니다. 시스템에서는 호스트와 포트 사이의 ":" 구분 기호가 포트 없이 제공되는 경우를 처리해야 하기 때문입니다.

컨텍스트에서 URI를 구분하기 위한 권장 사항\(부록 E\)은 현재 관행을 반영하도록 조정되었습니다.

---
### **G.4. Modifications from RFC 1808**

RFC 1808\(섹션 4\)은 빈 URL 참조\(조각 식별자 외에 아무것도 포함하지 않은 참조\)를 기본 URL에 대한 참조로 정의했습니다. 불행하게도 해당 정의는 해당 참조를 선택하면 해당 리소스에 대한 새로운 검색 작업으로 해석될 수 있습니다. 이러한 참조의 일반적인 의도는 사용자 에이전트가 현재 문서의 보기를 해당 문서 내의 지정된 조각의 시작 부분으로 변경하는 것이지 리소스에 대한 추가 요청을 하는 것이 아니기 때문에 빈 항목을 올바르게 해석하는 방법에 대한 설명입니다. 섹션 4에 참조가 추가되었습니다.

신화적인 Base 헤더 필드에 대한 설명은 MHTML \[RFC2110\]에 정의된 Content-Location 헤더 필드에 대한 참조로 대체되었습니다.

RFC 1808에서는 일반 URI 구문의 속성이 있거나 없는 다양한 방식을 설명했습니다. 그러나 유일한 요구 사항은 상대 참조를 포함하는 특정 문서가 URI 체계에 관계없이 일반 URI 구문을 준수하는 기본 URI를 가져야 한다는 것입니다. 따라서 관련 설명은 이를 반영하도록 업데이트되었습니다.

BNF 용어 <net\_loc\>는 <authority\>로 대체되었습니다. 후자가 해당 용도와 목적을 더 정확하게 설명하기 때문입니다. 마찬가지로 권한은 더 이상 IP 서버 구문으로 제한되지 않습니다.

현재 클라이언트 응용 프로그램에 대한 광범위한 테스트를 통해 배포된 시스템의 대부분이 ";"를 사용하지 않는 것으로 나타났습니다. 문자를 사용하여 후행 매개변수 정보를 나타내며, 경로 세그먼트에 세미콜론이 있어도 해당 세그먼트의 상대적 구문 분석에 영향을 주지 않습니다. 따라서 매개변수는 별도의 구성요소로 제거되었으며 이제 모든 경로 세그먼트에 나타날 수 있습니다. 상대 URI 참조를 해결하기 위한 알고리즘에서 해당 영향이 제거되었습니다. 부록 C의 해결 예는 이러한 변경 사항을 반영하도록 수정되었습니다.

이제 구현에서는 기본 URI와 동일한 체계가 앞에 붙은 잘못된 상대 참조를 해결할 수 있지만 <hier\_part\> 구문을 사용하는 것으로 알려진 체계에 대해서만 가능합니다.

---
## **H.  Full Copyright Statement**

저작권\(C\)인터넷학회\(1998\). 판권 소유.

본 문서와 그 번역본은 다른 사람에게 복사 및 제공될 수 있으며, 본 문서에 대해 논평하거나 설명하거나 구현을 지원하는 파생 저작물은 어떤 종류의 제한 없이 전체 또는 일부를 준비, 복사, 출판 및 배포할 수 있습니다. 단, 위의 저작권 표시와 이 단락은 모든 사본과 파생물에 포함되어 있어야 합니다. 그러나 이 문서 자체는 저작권 표시를 제거하거나 인터넷 협회 또는 기타 인터넷 조직에 대한 참조를 제거하는 등 어떠한 방식으로도 수정할 수 없습니다. 단, 인터넷 표준을 개발할 목적으로 필요한 경우는 제외됩니다. 이 경우 저작권에 대한 절차는 인터넷 표준 프로세스를 따라야 하거나 영어 이외의 언어로 번역하려면 필요한 대로 따라야 합니다.

위에 부여된 제한된 권한은 영구적이며 Internet Society 또는 그 승계자 또는 양수인에 의해 취소되지 않습니다.

이 문서와 여기에 포함된 정보는 "있는 그대로" 제공되며 인터넷 사회와 인터넷 엔지니어링 태스크 포스는 여기에 있는 정보의 사용으로 인해 발생하지 않는 모든 보증을 포함하되 이에 국한되지 않고 명시적이든 묵시적이든 모든 보증을 부인합니다. 특정 목적에 대한 상품성이나 적합성에 대한 권리나 묵시적인 보증을 침해하는 행위.
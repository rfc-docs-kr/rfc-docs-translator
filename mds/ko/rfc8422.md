

```text
Internet Engineering Task Force (IETF)                            Y. Nir
Request for Comments: 8422                                   Check Point
Obsoletes: 4492                                             S. Josefsson
Category: Standards Track                                         SJD AB
ISSN: 2070-1721                                      M. Pegourie-Gonnard
                                                                     ARM
                                                             August 2018
```

- TLS\(전송 계층 보안\) 버전 1.2 이하를 위한 ECC\(타원 곡선 암호화\) 암호 제품군

---
# **Abstract**

이 문서에서는 TLS\(전송 계층 보안\) 프로토콜용 ECC\(타원 곡선 암호화\)를 기반으로 하는 키 교환 알고리즘에 대해 설명합니다. 특히 TLS 핸드셰이크에서 ECDHE\(Ephemeral Elliptic Curve Diffie-Hellman\) 키 계약의 사용과 인증 메커니즘으로 ECDSA\(Elliptic Curve Digital Signature Algorithm\) 및 EdDSA\(Edwards-curve Digital Signature Algorithm\)의 사용을 지정합니다.

이 문서는 RFC 4492를 폐기합니다.

---
# **Status of This Memo**

이것은 인터넷 표준 추적 문서입니다.

이 문서는 IETF\(Internet Engineering Task Force\)의 산물입니다. 이는 IETF 커뮤니티의 합의를 나타냅니다. 공개 검토를 받았으며 IESG\(Internet Engineering Steering Group\)의 게시 승인을 받았습니다. 인터넷 표준에 대한 추가 정보는 RFC 7841의 섹션 2에서 확인할 수 있습니다.

이 문서의 현재 상태, 정오표, 피드백 제공 방법에 대한 정보는 https://www.rfc-editor.org/info/rfc8422에서 얻을 수 있습니다.

---
# **Copyright Notice**

Copyright \(c\) 2018 IETF Trust 및 문서 작성자로 식별된 사람. 판권 소유.

이 문서에는 이 문서 발행일에 유효한 BCP 78 및 IETF 문서와 관련된 IETF Trust의 법적 조항\(https://trustee.ietf.org/license-info\)이 적용됩니다. 이 문서에 관한 귀하의 권리와 제한 사항이 설명되어 있으므로 이 문서를 주의 깊게 검토하십시오. 이 문서에서 추출된 코드 구성 요소는 신뢰 법률 조항의 섹션 4.e에 설명된 대로 단순화된 BSD 라이센스 텍스트를 포함해야 하며 단순화된 BSD 라이센스에 설명된 대로 보증 없이 제공됩니다.

---
# **Table of Contents**

```text
   1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   4
     1.1.  Conventions Used in This Document . . . . . . . . . . . .   4
   2.  Key Exchange Algorithm  . . . . . . . . . . . . . . . . . . .   4
     2.1.  ECDHE_ECDSA . . . . . . . . . . . . . . . . . . . . . . .   6
     2.2.  ECDHE_RSA . . . . . . . . . . . . . . . . . . . . . . . .   7
     2.3.  ECDH_anon . . . . . . . . . . . . . . . . . . . . . . . .   7
     2.4.  Algorithms in Certificate Chains  . . . . . . . . . . . .   7
   3.  Client Authentication . . . . . . . . . . . . . . . . . . . .   8
     3.1.  ECDSA_sign  . . . . . . . . . . . . . . . . . . . . . . .   8
   4.  TLS Extensions for ECC  . . . . . . . . . . . . . . . . . . .   9
   5.  Data Structures and Computations  . . . . . . . . . . . . . .  10
     5.1.  Client Hello Extensions . . . . . . . . . . . . . . . . .  10
       5.1.1.  Supported Elliptic Curves Extension . . . . . . . . .  11
       5.1.2.  Supported Point Formats Extension . . . . . . . . . .  13
       5.1.3.  The signature_algorithms Extension and EdDSA  . . . .  13
     5.2.  Server Hello Extension  . . . . . . . . . . . . . . . . .  14
     5.3.  Server Certificate  . . . . . . . . . . . . . . . . . . .  15
     5.4.  Server Key Exchange . . . . . . . . . . . . . . . . . . .  16
       5.4.1.  Uncompressed Point Format for NIST Curves . . . . . .  19
     5.5.  Certificate Request . . . . . . . . . . . . . . . . . . .  20
     5.6.  Client Certificate  . . . . . . . . . . . . . . . . . . .  21
     5.7.  Client Key Exchange . . . . . . . . . . . . . . . . . . .  22
     5.8.  Certificate Verify  . . . . . . . . . . . . . . . . . . .  23
     5.9.  Elliptic Curve Certificates . . . . . . . . . . . . . . .  24
     5.10. ECDH, ECDSA, and RSA Computations . . . . . . . . . . . .  24
     5.11. Public Key Validation . . . . . . . . . . . . . . . . . .  26
   6.  Cipher Suites . . . . . . . . . . . . . . . . . . . . . . . .  26
   7.  Implementation Status . . . . . . . . . . . . . . . . . . . .  27
   8.  Security Considerations . . . . . . . . . . . . . . . . . . .  27
   9.  IANA Considerations . . . . . . . . . . . . . . . . . . . . .  28
   10. References  . . . . . . . . . . . . . . . . . . . . . . . . .  29
     10.1.  Normative References . . . . . . . . . . . . . . . . . .  29
     10.2.  Informative References . . . . . . . . . . . . . . . . .  31
   Appendix A.  Equivalent Curves (Informative)  . . . . . . . . . .  32
   Appendix B.  Differences from RFC 4492  . . . . . . . . . . . . .  33
   Acknowledgements  . . . . . . . . . . . . . . . . . . . . . . . .  34
   Authors' Addresses  . . . . . . . . . . . . . . . . . . . . . . .  34
```

---
## **1.  Introduction**

이 문서에서는 TLS 버전 1.0 \[RFC2246\], 1.1 \[RFC4346\] 및 1.2 \[RFC5246\]에 적용 가능한 ECC를 지원하기 위한 TLS 추가 사항에 대해 설명합니다. TLS 1.3의 ECC 사용은 \[TLS1.3\]에 정의되어 있으며 명시적으로 이 문서의 범위를 벗어납니다. 특히 이 문서에서는 다음을 정의합니다.

- TLS 프리마스터 비밀을 설정하기 위해 임시 키와 함께 ECDHE 키 계약 방식을 사용합니다.

- TLS 피어 인증을 위해 ECDSA 및 EdDSA 서명을 사용합니다.

이 문서의 나머지 부분은 다음과 같이 구성됩니다. 섹션 2에서는 TLS용 ECC 기반 키 교환 알고리즘의 개요를 제공합니다. 섹션 3에서는 클라이언트 인증을 위한 ECC 인증서 사용에 대해 설명합니다. 클라이언트가 특정 곡선 및 포인트 형식의 사용을 협상할 수 있도록 하는 TLS 확장은 섹션 4에 나와 있습니다. 섹션 5에서는 ECC 기반 핸드셰이크에 필요한 다양한 데이터 구조, TLS 메시지의 인코딩 및 해당 메시지 처리를 지정합니다. 섹션 6에서는 ECC 기반 암호 제품군을 정의하고 이 사양의 모든 구현에 권장되는 이들 중 작은 하위 집합을 식별합니다. 섹션 8에서는 보안 고려 사항에 대해 설명합니다. 섹션 9에서는 이 문서의 전임자에 의해 생성된 네임스페이스에 대한 IANA 고려 사항을 설명합니다. 부록 B는 이 문서로 대체되는 문서인 \[RFC4492\]와의 차이점을 제공합니다.

이 사양을 구현하려면 TLS, TLS 확장 \[RFC4366\] 및 ECC에 대한 지식이 필요합니다.

---
### **1.1.  Conventions Used in This Document**

핵심 단어 "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY" 및 "OPTIONAL 이 문서의 "는 여기에 표시된 대로 모두 대문자로 표시되는 경우에만 BCP 14 \[RFC2119\] \[RFC8174\]에 설명된 대로 해석됩니다.

---
## **2.  Key Exchange Algorithm**

이 문서에서는 TLS에 대한 세 가지 새로운 ECC 기반 키 교환 알고리즘을 정의합니다. 이들 모두 ECDHE\(Ephemeral ECDH\)를 사용하여 TLS 프리마스터 비밀을 계산하며 인증에 사용되는 메커니즘\(있는 경우\)만 다릅니다. 프리마스터 비밀에서 TLS 마스터 비밀을 파생시키고 대량 암호화/MAC 키 및 초기화 벡터의 후속 생성은 키 교환 알고리즘과 독립적이며 ECC 도입의 영향을 받지 않습니다.

표 1에는 새로운 키 교환 알고리즘이 요약되어 있습니다. 이러한 모든 키 교환 알고리즘은 새로운 임시 키가 생성 및 사용되고 사용 후 폐기되는 경우에만 순방향 비밀성을 제공합니다.

```text
     +-------------+------------------------------------------------+
     | Algorithm   | Description                                    |
     +-------------+------------------------------------------------+
     | ECDHE_ECDSA | Ephemeral ECDH with ECDSA or EdDSA signatures. |
     | ECDHE_RSA   | Ephemeral ECDH with RSA signatures.            |
     | ECDH_anon   | Anonymous ephemeral ECDH, no signatures.       |
     +-------------+------------------------------------------------+

                   Table 1: ECC Key Exchange Algorithms
```

이러한 키 교환은 각각 DHE\_DSS, DHE\_RSA 및 DH\_anon과 유사합니다.

ECDHE\_RSA를 사용하면 서버는 기존 RSA 인증서를 재사용하고 제한된 클라이언트의 타원 곡선 기본 설정을 쉽게 준수할 수 있습니다\(섹션 4 참조\). 그러나 서버에서 발생하는 계산 비용은 순방향 보안을 제공하지 않는 기존 RSA 키 교환보다 ECDHE\_RSA가 더 높습니다.

익명 키 교환 알고리즘은 서버 또는 클라이언트 인증을 제공하지 않습니다. 다른 익명 TLS 키 교환과 마찬가지로 중간자 공격의 대상이 됩니다. 이 알고리즘과 함께 TLS를 사용하는 애플리케이션은 다른 수단으로 인증을 제공해야 합니다\(SHOULD\).

```text
          Client                                        Server
          ------                                        ------
          ClientHello          -------->
                                                   ServerHello
                                                  Certificate*
                                            ServerKeyExchange*
                                          CertificateRequest*+
                               <--------       ServerHelloDone
          Certificate*+
          ClientKeyExchange
          CertificateVerify*+
          [ChangeCipherSpec]
          Finished             -------->
                                            [ChangeCipherSpec]
                               <--------              Finished
          Application Data     <------->      Application Data

               * message is not sent under some conditions
               + message is not sent unless client authentication
                 is desired

            Figure 1: Message Flow in a Full TLS 1.2 Handshake
```

그림 1은 TLS 키 설정 프로토콜\(전체 핸드셰이크라고도 함\)과 관련된 모든 메시지를 보여줍니다. ECC 추가는 ClientHello, ServerHello, 서버의 인증서 메시지, ServerKeyExchange, ClientKeyExchange, CertificateRequest, 클라이언트의 인증서 메시지 및 CertificateVerify에만 직접적인 영향을 미칩니다. 다음으로 ECC 키 교환 알고리즘을 이러한 메시지의 내용과 처리 측면에서 더 자세히 설명합니다. 설명을 쉽게 하기 위해 클라이언트 인증 및 관련 메시지\(그림 1에서 '+'로 식별됨\)에 대한 논의는 섹션 3까지, 선택적 ECC 관련 확장\(Hello 메시지에 영향을 줌\)에 대한 논의는 섹션 4까지 연기합니다.

---
### **2.1.  ECDHE_ECDSA**

ECDHE\_ECDSA에서 서버의 인증서에는 ECDSA 또는 EdDSA 가능 공개 키가 포함되어야 합니다.

서버는 임시 ECDH 공개 키와 해당 곡선의 사양을 ServerKeyExchange 메시지로 보냅니다. 이러한 매개변수는 서버 인증서의 공개 키에 해당하는 개인 키를 사용하여 ECDSA 또는 EdDSA로 서명되어야 합니다.

클라이언트는 서버의 임시 ECDH 키와 동일한 곡선에서 ECDH 키 쌍을 생성하고 공개 키를 ClientKeyExchange 메시지로 보냅니다.

클라이언트와 서버 모두 ECDH 작업\(섹션 5.10 참조\)을 수행하고 결과 공유 비밀을 premaster 비밀로 사용합니다.

---
### **2.2.  ECDHE_RSA**

이 키 교환 알고리즘은 서버의 인증서에 서명이 승인된 RSA 공개 키가 포함되어야 하고 ServerKeyExchange 메시지의 서명이 해당 RSA 개인 키로 계산되어야 한다는 점을 제외하면 ECDHE\_ECDSA와 동일합니다.

---
### **2.3.  ECDH_anon**

참고: 이름이 "ECDH\_"\(E 없음\)로 시작함에도 불구하고 ECDH\_anon에 사용된 키는 ECDHE\_RSA 및 ECDHE\_ECDSA의 키와 마찬가지로 임시입니다. 이름 지정은 DH\_anon의 예를 따릅니다. 여기서 키도 임시이지만 이름에는 이를 반영하지 않습니다.

ECDH\_anon에서는 서버의 인증서, CertificateRequest, 클라이언트의 인증서 및 CertificateVerify 메시지를 전송해서는 안 됩니다.

서버는 임시 ECDH 공개 키와 ServerKeyExchange 메시지의 해당 곡선 사양을 보내야 합니다. 이러한 매개변수는 서명하면 안 됩니다.

클라이언트는 서버의 임시 ECDH 키와 동일한 곡선에서 ECDH 키 쌍을 생성하고 공개 키를 ClientKeyExchange 메시지로 보냅니다.

클라이언트와 서버 모두 ECDH 작업을 수행하고 결과 공유 비밀을 premaster 비밀로 사용합니다. 모든 ECDH 계산은 섹션 5.10에 지정된 대로 수행됩니다.

---
### **2.4.  Algorithms in Certificate Chains**

이 사양은 인증서 체인의 어느 곳에서나 사용되는 서명 체계에 제한을 두지 않습니다. 이 문서의 이전 버전에서는 일치하는 서명이 필요했지만 이전 TLS 버전에서 발생한 이 제한은 RFC 5246에서처럼 여기에서 해제되었습니다.

---
## **3.  Client Authentication**

이 문서는 관련된 클라이언트 인증서 유형인 ECDSA\_sign의 이름을 딴 클라이언트 인증 메커니즘을 정의합니다. ECDSA\_sign 메커니즘은 섹션 2에 설명된 모든 비익명 ECC 키 교환 알고리즘은 물론 TLS에 정의된 기타 비익명\(비ECC\) 키 교환 알고리즘과 함께 사용할 수 있습니다.

EdDSA 공개 키가 있는 클라이언트 인증서도 이 메커니즘을 사용합니다.

서버는 CertificateRequest 메시지에 이 인증서 유형을 포함시켜 ECC 기반 클라이언트 인증을 요청할 수 있습니다. 클라이언트는 서버가 제시한 방법에 맞는 인증서를 보유하고 있는지, 이를 인증에 사용할 의향이 있는지 확인해야 합니다.

이러한 조건이 충족되지 않으면 클라이언트는 인증서가 포함되지 않은 클라이언트 인증서 메시지를 보내야 합니다. 이 경우 ClientKeyExchange는 섹션 2에 설명된 대로 전송되어야 하며 CertificateVerify는 전송되어서는 안 됩니다. 서버에 클라이언트 인증이 필요한 경우 치명적인 핸드셰이크 실패 경고로 응답할 수 있습니다.

클라이언트가 적절한 인증서를 가지고 있고 이를 인증에 사용하려는 경우 클라이언트의 인증서 메시지\(섹션 5.6에 따라\)에 해당 인증서를 보내고 인증된 키에 해당하는 개인 키의 소유를 증명해야 합니다. 적절한 인증서를 결정하고 소유를 증명하는 프로세스는 인증 메커니즘마다 다르며 아래에 설명되어 있습니다.

참고: 서버가 서버 인증서와 다른 유형의 클라이언트 인증서를 요청\(및 클라이언트가 보내는\) 것이 허용됩니다.

---
### **3.1.  ECDSA_sign**

이 인증 메커니즘을 사용하려면 클라이언트는 ECDSA 또는 EdDSA 가능 공개 키가 포함된 인증서를 보유해야 합니다.

클라이언트는 섹션 5.8에 설명된 대로 CertificateVerify 메시지에 서명을 포함하여 인증된 키에 해당하는 개인 키의 소유를 증명합니다.

---
## **4.  TLS Extensions for ECC**

이 사양에는 \(i\) 지원되는 타원 곡선 확장과 \(ii\) 지원되는 포인트 형식 확장이라는 두 가지 TLS 확장이 정의되어 있습니다. 이를 통해 새 세션을 시작하는 핸드셰이크 중에 특정 곡선 및 포인트 형식\(예: 각각 압축 및 비압축\)의 사용을 협상할 수 있습니다. 이러한 확장은 제한된 수의 곡선 또는 점 형식만 지원할 수 있는 제한된 클라이언트와 특히 관련이 있습니다. 이는 \[RFC4366\]에 설명된 일반적인 접근 방식을 따릅니다. 메시지 세부 정보는 섹션 5에 지정되어 있습니다. 클라이언트는 ClientHello 메시지에 적절한 확장을 포함하여 구문 분석할 수 있는 포인트 형식과 지원하는 곡선을 열거합니다. 서버는 마찬가지로 ServerHello 메시지에 확장을 포함하여 구문 분석할 수 있는 포인트 형식을 열거합니다.

ClientHello 메시지에 ECC 암호 그룹을 제안하는 TLS 클라이언트는 이러한 확장을 포함해야 합니다. ECC 암호 모음을 구현하는 서버는 이러한 확장을 지원해야 하며, 클라이언트가 이러한 확장을 사용할 때 서버는 클라이언트가 지정한 곡선 선택을 존중하면서 핸드셰이크를 완료할 수 없다면 ECC 암호 모음의 사용을 협상해서는 안 됩니다. 이렇게 하면 클라이언트가 서버의 EC 키를 처리할 수 없기 때문에 협상된 ECC 핸드셰이크가 이후에 중단될 가능성이 제거됩니다.

클라이언트는 ECC 암호 모음을 제안하지 않는 경우 ClientHello 메시지에 이러한 확장을 포함해서는 안 됩니다. ECC 암호화 제품군을 제안하는 클라이언트는 이러한 확장자를 포함하지 않도록 선택할 수 있습니다. 이 경우 서버는 섹션 5에 나열된 타원 곡선이나 점 형식 중 하나를 자유롭게 선택할 수 있습니다. 해당 섹션에서는 이러한 확장의 구조와 처리에 대해서도 자세히 설명합니다.

세션을 재개하는 경우 서버는 현재 ClientHello 메시지에 나타나는 Supported Elliptic Curves Extension 및 Supported Point Formats Extension을 무시합니다. 이러한 확장은 새 세션을 협상하는 핸드셰이크 중에만 역할을 합니다.

---
## **5.  Data Structures and Computations**

이 섹션에서는 이전 세 섹션에서 지정된 ECC 기반 키 메커니즘에서 사용되는 데이터 구조와 계산을 지정합니다. 여기에 사용된 표시 언어는 TLS에서 사용된 것과 동일합니다. 이 사양은 TLS를 확장하므로 이러한 설명은 TLS 사양 및 TLS를 확장하는 다른 사양의 설명과 병합되어야 합니다. 이는 열거형 유형이 가능한 모든 값을 지정하지 않을 수 있으며 select\(\) 절로 선택한 여러 형식의 구조가 가능한 모든 경우를 나타내지 않을 수 있음을 의미합니다.

---
### **5.1.  Client Hello Extensions**

이 섹션에서는 \[RFC4366\]에 설명된 대로 ClientHello 메시지에 포함될 수 있는 두 가지 TLS 확장인 지원되는 타원 곡선 확장과 지원되는 포인트 형식 확장을 지정합니다.

다음 확장자가 전송되는 경우:

확장은 ECC 암호 모음을 제안하는 ClientHello 메시지와 함께 전송되어야 합니다.

이러한 확장의 의미:

이러한 확장을 통해 클라이언트는 지원하는 타원 곡선 및/또는 구문 분석할 수 있는 점 형식을 열거할 수 있습니다.

이러한 확장의 구조:

TLS 확장의 일반적인 구조는 \[RFC4366\]에 설명되어 있으며, 이 사양에서는 ExtensionType에 두 가지 유형을 추가합니다.

```text
      enum {
          elliptic_curves(10),
          ec_point_formats(11)
      } ExtensionType;
```

- elliptic\_curves\(지원되는 타원 곡선 확장\): 클라이언트가 지원하는 타원 곡선 집합을 나타냅니다. 이 확장의 경우 불투명 Extension\_data 필드에 NamedCurveList가 포함됩니다. 자세한 내용은 섹션 5.1.1을 참조하세요.

- ec\_point\_formats\(지원되는 포인트 형식 확장\): 클라이언트가 구문 분석할 수 있는 포인트 형식 세트를 나타냅니다. 이 확장의 경우 불투명 Extension\_data 필드에 ECPointFormatList가 포함됩니다. 자세한 내용은 섹션 5.1.2를 참조하세요.

발신자의 조치:

ClientHello 메시지에서 ECC 암호화 제품군을 제안하는 클라이언트는 이러한 확장을 \(다른 확장과 함께\) 추가하여 지원하는 곡선과 구문 분석할 수 있는 포인트 형식을 열거합니다. 클라이언트는 지원되는 타원 곡선 확장과 지원되는 점 형식 확장을 모두 보내야 합니다. 지원되는 포인트 형식 확장이 실제로 전송되는 경우 포인트 형식 목록의 항목 중 하나로 값 0\(압축되지 않음\)을 포함해야 합니다.

수신자의 조치:

이러한 확장 중 하나 또는 둘 다를 포함하는 ClientHello를 수신하는 서버는 클라이언트의 열거된 기능을 사용하여 적절한 암호 모음 선택을 안내해야 합니다. 제안된 ECC 암호 모음 중 하나는 클라이언트가 지원하는 곡선 및 포인트 형식을 사용하면서 서버가 핸드셰이크를 성공적으로 완료할 수 있는 경우에만 협상되어야 합니다\(섹션 5.3 및 5.4 참조\).

참고: ECDHE\_ECDSA 키 교환에 참여하는 서버는 인증서의 ECDSA 또는 EdDSA 키와 ServerKeyExchange 메시지의 임시 ECDH 키에 대해 서로 다른 곡선을 사용할 수 있습니다. 서버는 두 경우 모두 확장을 고려해야 합니다.

서버가 지원되는 타원 곡선 확장을 이해하지 못하거나, 지원되는 포인트 형식 확장을 이해하지 못하거나, 열거된 곡선 및 포인트 형식으로 제한하면서 ECC 핸드셰이크를 완료할 수 없는 경우, ECC 암호 사용을 협상해서는 안 됩니다. 모음곡. 클라이언트가 제안하고 서버에서 지원하는 다른 암호화 제품군에 따라 공통 암호화 제품군이 부족하여 치명적인 핸드셰이크 실패 경고가 발생할 수 있습니다.

---
#### **5.1.1.  Supported Elliptic Curves Extension**

RFC 4492는 TLS에서 사용하기 위해 NamedCurve 레지스트리\(아래 열거의 이름은 여전히 ​​NamedCurve이지만 현재는 "TLS Supported Groups" 레지스트리로 이름이 변경됨\)에 25개의 서로 다른 곡선을 정의했습니다. 많이 사용된 사례는 3개뿐입니다. 이 사양은 나머지\(숫자 1-22\)를 더 이상 사용하지 않습니다. 이 사양은 또한 명시적인 것을 더 이상 사용하지 않습니다.

식별자가 0xFF01 및 0xFF02인 곡선. 또한 \[RFC7748\]에 정의된 새로운 곡선을 추가합니다. 최종 결과는 다음과 같습니다.

```text
           enum {
               deprecated(1..22),
               secp256r1 (23), secp384r1 (24), secp521r1 (25),
               x25519(29), x448(30),
               reserved (0xFE00..0xFEFF),
               deprecated(0xFF01..0xFF02),
               (0xFFFF)
           } NamedCurve;
```

이후 다른 사양에서는 이 열거형에 다른 값을 추가했습니다. 이러한 값 중 일부는 곡선이 아니라 유한한 필드 그룹입니다. \[RFC7919\]를 참조하세요.

secp256r1, etc: 해당 명명된 곡선 또는 그룹의 지원을 나타냅니다. 명명된 곡선 secp256r1, secp384r1 및 secp521r1은 SEC 2 \[SECG-SEC2\]에 지정되어 있습니다. 이러한 곡선은 ANSI X9.62 \[ANSI.X9-62.2005\] 및 FIPS 186-4 \[FIPS.186-4\]에서도 권장됩니다. 이 문서의 나머지 부분에서는 이 세 가지 곡선을 "NIST 곡선"이라고 부릅니다. 원래 국립 표준 기술 연구소\(National Institute of Standards and Technology\)에서 표준화했기 때문입니다. 곡선 x25519 및 x448은 \[RFC7748\]에 정의되어 있습니다. 0xFE00부터 0xFEFF까지의 값은 개인용으로 예약되어 있습니다.

이 문서의 이전 버전에서는 명시적으로 정의된 프라임 및 char2 곡선도 지원했지만 이 사양에서는 더 이상 사용되지 않습니다.

NamedCurve 이름 공간\(현재 "TLS 지원 그룹"\)은 IANA에서 관리합니다. 새로운 값 할당이 추가되는 방법에 대한 정보는 섹션 9를 참조하십시오.

```text
           struct {
               NamedCurve named_curve_list<2..2^16-1>
           } NamedCurveList;
```

명명된\_곡선\_목록의 항목은 클라이언트의 기본 설정에 따라 정렬됩니다\(선호하는 항목부터\).

예를 들어 secp256r1\(일명 NIST P-256, 값 23 = 0x0017\) 및 secp384r1\(일명 NIST P-384, 값 24 = 0x0018\)만 지원하고 secp256r1 사용을 선호하는 클라이언트에는 다음으로 구성된 TLS 확장이 포함됩니다. 옥텟. 처음 두 옥텟은 확장 유형\(지원되는 타원 곡선 확장\)을 나타냅니다.

```text
           00 0A 00 06 00 04 00 17 00 18
```

---
#### **5.1.2.  Supported Point Formats Extension**

```text
           enum {
               uncompressed (0),
               deprecated (1..2),
               reserved (248..255)
           } ECPointFormat;
           struct {
               ECPointFormat ec_point_format_list<1..2^8-1>
           } ECPointFormatList;
```

위의 ECPointFormat 정의에는 세 가지 포인트 형식이 포함되었습니다. 이 사양은 압축되지 않은 포인트 형식을 제외한 모든 형식을 더 이상 사용하지 않습니다. 이 문서의 구현은 지원되는 모든 곡선에 대해 압축되지 않은 형식을 지원해야 하며\(MUST\) 이 사양에 정의된 곡선에 대해 다른 형식을 지원해서는 안 됩니다\(MUST NOT\). 이전 버전과의 호환성을 위해 포인트 형식 목록 확장이 계속 포함될 수 있으며 정확히 하나의 값, 즉 압축되지 않은 포인트 형식\(0\)을 포함할 수 있습니다. RFC 4492에서는 이 확장이 누락되면 압축되지 않은 포인트 형식만 지원된다는 의미이므로 압축되지 않은 형식을 지원하는 구현과의 상호 운용성은 확장이 있든 없든 작동해야 한다고 명시했습니다.

클라이언트가 확장을 보내고 확장에 압축되지 않은 포인트 형식이 포함되어 있지 않고 클라이언트가 지원 그룹 확장을 사용하여 이 사양에 정의된 곡선에 대한 지원을 표시한 경우 서버는 핸드셰이크를 중단하고 불법 매개변수를 반환해야 합니다. 알리다.

ECPointFormat 네임스페이스\(현재 "TLS EC 포인트 형식"\)는 IANA에서 관리합니다. 새로운 값 할당이 추가되는 방법에 대한 정보는 섹션 9를 참조하십시오.

다른 곡선을 지원하지 않는 이 사양을 준수하는 클라이언트는 다음 옥텟을 보내야 합니다. 처음 두 옥텟은 확장 유형\(지원되는 포인트 형식 확장\)을 나타냅니다.

```text
           00 0B 00 02 01 00
```

---
#### **5.1.3.  The signature_algorithms Extension and EdDSA**

\[RFC5246\]의 7.4.1.4.1절에 정의된 서명\_알고리즘 확장은 클라이언트가 지원하는 서명 알고리즘과 해시 함수의 조합을 광고합니다. EdDSA의 순수\(사전 해시되지 않은\) 형식은 서명하기 전에 데이터를 해시하지 않습니다. 이러한 이유로 확장 프로그램에서 해시 함수와 결합하는 것은 의미가 없습니다.

TLS 1.3과의 비트 전송 호환성을 위해 "TLS HashAlgorithm" 레지스트리에 "Intrinsic"\(값 8\)이라고 하는 새로운 더미 값을 정의합니다. 이는 해싱이 서명 알고리즘에 내재되어 있음을 의미합니다.

Signature\_algorithms 확장에서 ed25519 및 ed448을 나타내려면 값이 각각 \(8,7\) 및 \(8,8\)이어야 합니다.

---
### **5.2.  Server Hello Extension**

이 섹션에서는 지원되는 포인트 형식 확장인 \[RFC4366\]에 설명된 대로 ServerHello 메시지에 포함될 수 있는 TLS 확장을 지정합니다.

이 확장 프로그램이 전송되면:

지원 포인트 형식 확장은 ECC 암호화 제품군을 협상할 때 지원 포인트 형식 확장이 포함된 ClientHello 메시지에 대한 응답으로 ServerHello 메시지에 포함됩니다.

이 확장의 의미:

이 확장을 통해 서버는 ECDHE\_ECDSA, ECDHE\_RSA 또는 ECDH\_anon 키 교환 알고리즘을 사용할 때 ServerKeyExchange 메시지에 나타나는 곡선에 대해 구문 분석할 수 있는 포인트 형식을 열거할 수 있습니다.

이 확장의 구조:

서버의 지원 포인트 형식 확장은 클라이언트의 지원 포인트 형식 확장과 동일한 구조를 갖습니다\(섹션 5.1.2 참조\). 여기에서 ec\_point\_format\_list의 항목은 서버의 기본 설정에 따라 정렬됩니다\(선호하는 항목부터\). 서버에는 클라이언트 목록에서 발견되지 않은 항목이 포함될 수 있습니다. 그러나 확장이 없으면 이 사양은 정확히 1포인트 형식을 허용하므로 실제로 불일치가 발생할 가능성이 없습니다.

발신자의 조치:

Supported Point Formats Extension을 포함하는 ClientHello 메시지에 대한 응답으로 ECC 암호 모음을 선택하는 서버는 이 확장을 다른 확장과 함께 ServerHello 메시지에 추가하여 구문 분석할 수 있는 포인트 형식을 열거합니다. 지원되는 포인트 형식 확장은 사용 시 포인트 형식 목록의 항목 중 하나로 값 0\(압축되지 않음\)을 포함해야 합니다.

수신자의 조치:

지원되는 포인트 형식 확장이 포함된 ServerHello 메시지를 수신하는 클라이언트는 핸드셰이크 중에 서버가 선택한 포인트 형식을 존중해야 합니다\(섹션 5.6 및 5.7 참조\). ServerHello와 함께 지원되는 포인트 형식 확장이 수신되지 않으면 이는 압축되지 않은 포인트 형식만 허용하는 확장과 동일합니다.

---
### **5.3.  Server Certificate**

이 메시지가 전송되면:

이 메시지는 모든 비익명 ECC 기반 키 교환 알고리즘으로 전송됩니다.

이 메시지의 의미:

이 메시지는 서버의 정적 공개 키를 클라이언트에 인증적으로 전달하는 데 사용됩니다. 다음 표에는 각 키 교환 알고리즘에 적합한 서버 인증서 유형이 나와 있습니다. ECC 공개 키는 섹션 5.9에 설명된 대로 인증서로 인코딩되어야 합니다.

참고: 서버의 인증서 메시지는 인증서 체인을 전달할 수 있습니다. 표 2에 언급된 제한 사항은 서버 인증서\(체인의 첫 번째\)에만 적용됩니다.

```text
   +-------------+-----------------------------------------------------+
   | Algorithm   | Server Certificate Type                             |
   +-------------+-----------------------------------------------------+
   | ECDHE_ECDSA | Certificate MUST contain an ECDSA- or EdDSA-capable |
   |             | public key.                                         |
   | ECDHE_RSA   | Certificate MUST contain an RSA public key.         |
   +-------------+-----------------------------------------------------+

                     Table 2: Server Certificate Types
```

이 메시지의 구조:

TLS 인증서 형식과 동일합니다.

발신자의 조치:

서버는 적절한 인증서 체인을 구성하고 이를 인증서 메시지를 통해 클라이언트에 전달합니다. 클라이언트가 지원되는 타원 곡선 확장을 사용한 경우 서버의 공개 키

인증서는 클라이언트의 타원 곡선 선택을 존중해야 합니다. 이 요구 사항을 충족할 수 없는 서버는 ServerHello 메시지에서 ECC 암호 모음을 선택해서는 안 됩니다.\)

수신자의 조치:

클라이언트는 인증서 체인의 유효성을 검사하고, 서버의 공개 키를 추출하고, 키 유형이 협상된 키 교환 알고리즘에 적합한지 확인합니다. \(치명적인 핸드셰이크 실패의 가능한 이유는 타원 곡선 및 점 형식을 처리하는 클라이언트의 기능이 초과되었기 때문입니다. 섹션 5.1 참조\)

---
### **5.4.  Server Key Exchange**

이 메시지가 전송되면:

이 메시지는 ECDHE\_ECDSA, ECDHE\_RSA 및 ECDH\_anon 키 교환 알고리즘을 사용할 때 전송됩니다.

이 메시지의 의미:

이 메시지는 서버의 임시 ECDH 공개 키\(및 해당 타원 곡선 도메인 매개변수\)를 클라이언트에 전달하는 데 사용됩니다.

명시적 소수 및 명시적 char2 곡선에 대한 값을 갖는 데 사용되는 ECCurveType 열거형입니다. 해당 값은 이제 더 이상 사용되지 않으므로 하나의 값만 남습니다.

이 메시지의 구조:

```text
           enum {
               deprecated (1..2),
               named_curve (3),
               reserved(248..255)
           } ECCurveType;
```

Named\_curve 값은 명명된 곡선이 사용됨을 나타냅니다. 이제 이 옵션이 유일한 남은 형식입니다.

248부터 255까지의 값은 개인용으로 예약되어 있습니다.

ECCurveType 이름 공간\(현재 "TLS EC 곡선 유형"\)은 IANA에서 유지관리합니다. 새로운 값 할당이 추가되는 방법에 대한 정보는 섹션 9를 참조하십시오.

RFC 4492에는 ECCurve 구조와 ECBasisType 구조에 대한 사양이 있습니다. 이제 두 가지 모두 더 이상 사용되지 않는 명시적 곡선에만 사용되었기 때문에 생략됩니다.

```text
           struct {
               opaque point <1..2^8-1>;
           } ECPoint;
```

point: 이는 \[ANSI.X9-62.2005\]의 섹션 4.3.6에 있는 변환 루틴을 따르는 타원 곡선 점의 바이트 문자열 표현입니다. 이 바이트 문자열은 압축되지 않은 형식, 압축된 형식 또는 하이브리드 형식의 타원 곡선 점을 나타낼 수 있지만 이 사양에서는 압축되지 않은 형식을 제외한 모든 형식을 더 이상 사용하지 않습니다. NIST 곡선의 경우 편의를 위해 섹션 5.4.1에서 형식이 반복됩니다. X25519 및 X448 곡선의 경우 유일한 유효한 표현은 점의 u 값에 대한 32 또는 56 옥텟 표현인 \[RFC7748\]에 지정된 것입니다. 이 구조는 Ed25519 및 Ed448 공개 키와 함께 사용하면 안 됩니다.

```text
           struct {
               ECCurveType    curve_type;
               select (curve_type) {
                   case named_curve:
                       NamedCurve namedcurve;
               };
           } ECParameters;
```

curve\_type: 타원 곡선 도메인 매개변수의 유형을 식별합니다.

명명된 곡선: 권장되는 타원 곡선 도메인 매개변수 세트를 지정합니다. Diffie-Hellman이 가능한 곡선을 참조하는 NamedCurve의 모든 값이 허용됩니다. 명시적 곡선이 지원 중단됨에 따라 이제 여기에는 NamedCurve 값이 모두 포함됩니다.

```text
           struct {
               ECParameters    curve_params;
               ECPoint         public;
           } ServerECDHParams;
```

curve\_params: ECDH 공개 키와 연결된 타원 곡선 도메인 매개변수를 지정합니다.

공개: 임시 ECDH 공개 키입니다.

ServerKeyExchange 메시지는 다음과 같이 확장됩니다.

```text
           enum {
               ec_diffie_hellman
           } KeyExchangeAlgorithm;
```

- ec\_diffie\_hellman: ServerKeyExchange 메시지에 ECDH 공개 키가 포함되어 있음을 나타냅니다.

```text
      select (KeyExchangeAlgorithm) {
          case ec_diffie_hellman:
              ServerECDHParams    params;
              Signature           signed_params;
      } ServerKeyExchange;
```

- params: ECDH 공개 키 및 관련 도메인 매개변수를 지정합니다.

- signed\_params: 해당 해시에 적절한 서명이 적용된 params의 해시입니다. 서버의 인증서 메시지에 포함된 인증된 공개 키에 해당하는 개인 키가 서명에 사용됩니다.

```text
        enum {
            ecdsa(3),
            ed25519(7)
            ed448(8)
        } SignatureAlgorithm;
        select (SignatureAlgorithm) {
           case ecdsa:
                digitally-signed struct {
                    opaque sha_hash[sha_size];
                };
           case ed25519,ed448:
                digitally-signed struct {
                    opaque rawdata[rawdata_size];
                };
        } Signature;
      ServerKeyExchange.signed_params.sha_hash
          SHA(ClientHello.random + ServerHello.random +
                                 ServerKeyExchange.params);
      ServerKeyExchange.signed_params.rawdata
          ClientHello.random + ServerHello.random +
                                 ServerKeyExchange.params;
```

참고: SignatureAlgorithm은 ECDHE\_RSA 키 교환 알고리즘의 경우 "rsa"이고 ECDH\_anon의 경우 "anonymous"입니다. 이러한 경우는 TLS에 정의되어 있습니다. SignatureAlgorithm은 ECDHE\_ECDSA의 경우 "ecdsa" 또는 "eddsa"입니다.

ECDSA 서명은 섹션 5.10에 설명된 대로 생성되고 확인됩니다. 위의 sha\_hash 템플릿에서 SHA는 SHA-1이 아닌 해시 알고리즘을 나타낼 수 있습니다. ANSI X9.62에 따라 ECDSA 서명은 한 쌍의 정수 r과 s로 구성됩니다. 디지털 서명된 요소는 불투명 벡터 <0..2^16-1\>로 인코딩되며 그 내용은 다음 ASN.1 표기법에 해당하는 DER 인코딩입니다.

```text
              Ecdsa-Sig-Value ::= SEQUENCE {
                  r       INTEGER,
                  s       INTEGER
              }
```

\[RFC8410\]을 준수하는 프로토콜과 인증서 모두의 EdDSA 서명은 \[RFC8032\]에 따라 생성되고 검증됩니다. 디지털 서명된 요소는 불투명 벡터 <0..2^16-1\>로 인코딩되며, 그 내용에는 EdDSA 서명 알고리즘의 옥텟 문자열 출력이 포함됩니다.

발신자의 조치:

서버는 IEEE 1363 \[IEEE.P1363\]의 ECKAS-DH1 방식에 따라 타원 곡선 도메인 매개변수와 이러한 매개변수에 해당하는 임시 ECDH 공개 키를 선택합니다. 위에 정의된 형식을 사용하여 ServerKeyExchange 메시지를 통해 이 정보를 클라이언트에 전달합니다.

수신자의 조치:

클라이언트는 서명\(있는 경우\)을 확인하고 ServerKeyExchange 메시지에서 서버의 타원 곡선 도메인 매개변수와 임시 ECDH 공개 키를 검색합니다. \(치명적인 핸드셰이크 실패의 가능한 이유는 타원 곡선 및 점 형식을 처리하는 클라이언트의 기능이 초과되었기 때문입니다. 섹션 5.1 참조\)

---
#### **5.4.1.  Uncompressed Point Format for NIST Curves**

다음은 ServerKeyExchange 레코드에서 ECPoint를 표현하기 위한 연결 형식을 나타냅니다. 표현의 첫 번째 옥텟은 압축, 비압축 또는 하이브리드일 수 있는 형식을 나타냅니다. 이 사양은 이러한 곡선에 대해 압축되지 않은 형식만 지원합니다. 그 뒤에는 "빅 엔디안" 또는 "네트워크" 형식의 X 값의 이진 표현이 오고, "빅 엔디안" 또는 "네트워크" 형식의 Y 값의 이진 표현이 옵니다. 내부 길이 표시가 없으므로 각 숫자 표현은 곡선 매개변수에 의해 암시된 만큼의 옥텟을 차지합니다. 을 위한

P-256 이는 X와 Y 각각이 32옥텟을 사용하고 필요한 경우 왼쪽이 0으로 채워짐을 의미합니다. P-384의 경우 각각 48옥텟을 사용하고 P-521의 경우 각각 66옥텟을 사용합니다.

좀 더 공식적인 표현은 다음과 같습니다.

```text
             enum {
                 uncompressed(4),
                 (255)
               } PointConversionForm;

             struct {
                 PointConversionForm  form;
                 opaque               X[coordinate_length];
                 opaque               Y[coordinate_length];
             } UncompressedPointRepresentation;
```

---
### **5.5.  Certificate Request**

이 메시지가 전송되면:

클라이언트 인증을 요청할 때 전송되는 메시지입니다.

이 메시지의 의미:

서버는 이 메시지를 사용하여 허용 가능한 클라이언트 인증 방법을 제안합니다.

이 메시지의 구조:

TLS CertificateRequest 메시지는 다음과 같이 확장됩니다.

```text
           enum {
               ecdsa_sign(64),
               deprecated1(65),  /* was rsa_fixed_ecdh */
               deprecated2(66),  /* was ecdsa_fixed_ecdh */
               (255)
           } ClientCertificateType;
```

- ecdsa\_sign: 서버가 섹션 3에 지정된 해당 클라이언트 인증 방법을 사용하려고 함을 나타냅니다.

RFC 4492는 고정된 ECDH 공개 키를 포함하는 RSA 및 ECDSA 인증서도 정의했습니다. 이러한 메커니즘은 구현이 거의 없었으므로 이 사양에서는 해당 메커니즘을 더 이상 사용하지 않습니다.

발신자의 조치:

서버는 사용할 클라이언트 인증 방법을 결정하고 위에 정의된 형식을 사용하여 이 정보를 클라이언트에 전달합니다.

수신자의 조치:

클라이언트는 요청된 방법에 사용하기에 적합한 인증서가 있는지 여부와 클라이언트 인증을 진행할지 여부를 결정합니다.

---
### **5.6.  Client Certificate**

이 메시지가 전송되면:

이 메시지는 클라이언트가 적절한 인증서를 가지고 있고 클라이언트 인증을 진행하기로 결정한 경우 CertificateRequest에 대한 응답으로 전송됩니다. \(서버가 지원되는 포인트 형식 확장을 사용한 경우 인증서에 지정된 공개 키 포인트가 압축되지 않은 경우에만 인증서가 ECDSA\_sign 인증 방법과 함께 사용하기에 적합한 것으로 간주될 수 있습니다. 이는 여전히 지원되는 유일한 포인트 형식이기 때문입니다.

이 메시지의 의미:

이 메시지는 클라이언트의 정적 공개 키를 서버에 인증적으로 전달하는 데 사용됩니다. ECC 공개 키는 섹션 5.9에 설명된 대로 인증서로 인코딩되어야 합니다. 인증서에는 ECDSA 또는 EdDSA 가능 공개 키가 포함되어야 합니다.

참고: 클라이언트의 인증서 메시지는 인증서 체인을 전달할 수 있습니다. 위에 언급된 제한 사항은 클라이언트 인증서\(체인의 첫 번째\)에만 적용됩니다.

이 메시지의 구조:

TLS 클라이언트 인증서 형식과 동일합니다.

발신자의 조치:

클라이언트는 적절한 인증서 체인을 구성하고 이를 인증서 메시지를 통해 서버에 전달합니다.

수신자의 조치:

TLS 서버는 인증서 체인의 유효성을 검사하고, 클라이언트의 공개 키를 추출하고, 키 유형이 클라이언트 인증 방법에 적합한지 확인합니다.

---
### **5.7.  Client Key Exchange**

이 메시지가 전송되면:

이 메시지는 모든 키 교환 알고리즘으로 전송됩니다. 여기에는 클라이언트의 임시 ECDH 공개 키가 포함되어 있습니다.

메시지의 의미:

이 메시지는 클라이언트에 속한 키 교환과 관련된 임시 데이터\(예: 임시 ECDH 공개 키\)를 전달하는 데 사용됩니다.

이 메시지의 구조:

TLS ClientKeyExchange 메시지는 다음과 같이 확장됩니다.

```text
           enum {
               implicit,
               explicit
           } PublicValueEncoding;
```

- 암시적, 명시적: ECC 암호화 제품군의 경우 이는 클라이언트의 ECDH 공개 키가 클라이언트 인증서에 있는지\("암시적"\) 또는 ClientKeyExchange 메시지에 임시 ECDH 공개 키로 제공되는지\("명시적"\) 여부를 나타냅니다. 암시적 인코딩은 더 이상 사용되지 않으며 이전 버전과의 호환성을 위해서만 여기에 유지됩니다.

```text
           struct {
               ECPoint ecdh_Yc;
           } ClientECDiffieHellmanPublic;
```

ecdh\_Yc: 클라이언트의 임시 ECDH 공개 키를 바이트 문자열 ECPoint.point로 포함합니다. 이는 압축되지 않은 형식의 타원 곡선 점을 나타낼 수 있습니다.

```text
           struct {
               select (KeyExchangeAlgorithm) {
                   case ec_diffie_hellman: ClientECDiffieHellmanPublic;
               } exchange_keys;
           } ClientKeyExchange;
```

발신자의 조치:

클라이언트는 서버로부터 받은 매개변수에 해당하는 임시 ECDH 공개 키를 선택합니다. 형식은 5.4절과 동일합니다.

수신자의 조치:

서버는 ClientKeyExchange 메시지에서 클라이언트의 임시 ECDH 공개 키를 검색하고 이것이 서버의 ECDH 키와 동일한 타원 곡선에 있는지 확인합니다.

---
### **5.8.  Certificate Verify**

이 메시지가 전송되면:

이 메시지는 클라이언트가 디지털 서명에 사용할 수 있는 공개 키가 포함된 클라이언트 인증서를 보낼 때 전송됩니다.

메시지의 의미:

이 메시지에는 클라이언트 인증서 메시지의 공개 키에 해당하는 개인 키의 소유를 증명하는 서명이 포함되어 있습니다.

이 메시지의 구조:

TLS CertificateVerify 메시지와 기본 서명 유형은 TLS 기본 사양에 정의되어 있으며 후자는 여기 섹션 5.4에서 확장됩니다. "ecdsa" 및 "eddsa" 사례의 경우 CertificateVerify 메시지의 서명 필드에는 지금까지 교환된 핸드셰이크 메시지를 통해 계산된 ECDSA 또는 EdDSA\(각각\) 서명이 포함되어 있으며 이는 다른 서명 알고리즘을 사용하는 CertificateVerify와 완전히 유사합니다.

```text
           CertificateVerify.signature.sha_hash
               SHA(handshake_messages);
           CertificateVerify.signature.rawdata
               handshake_messages;
```

ECDSA 서명은 섹션 5.10에 설명된 대로 계산되며, 따라서 sha\_hash에 대한 위 템플릿의 SHA는 SHA-1이 아닌 해시 알고리즘을 나타낼 수 있습니다. ANSI X9.62에 따라 ECDSA 서명은 한 쌍의 정수 r과 s로 구성됩니다. 디지털 서명된 요소는 불투명 벡터 <0..2^16-1\>로 인코딩되며, 그 내용은 다음 ASN.1 표기법 \[X.680\]에 해당하는 DER 인코딩 \[X.690\]입니다.

```text
           Ecdsa-Sig-Value ::= SEQUENCE {
               r       INTEGER,
               s       INTEGER
           }
```

EdDSA 서명은 \[RFC8032\]에 따라 생성되고 검증됩니다. 디지털 서명된 요소는 불투명 벡터 <0..2^16-1\>로 인코딩되며, 그 내용에는 EdDSA 서명 알고리즘의 옥텟 문자열 출력이 포함됩니다.

발신자의 조치:

클라이언트는 클라이언트 hello부터 이 메시지를 포함하지 않고 보내거나 받은 모든 핸드셰이크 메시지에 대해 서명을 계산합니다. 인증된 공개 키에 해당하는 개인 키를 사용하여 위에 정의된 형식으로 전달되는 서명을 계산합니다.

수신자의 조치:

서버는 CertificateVerify 메시지에서 클라이언트의 서명을 추출하고 클라이언트의 인증서 메시지에서 받은 공개 키를 사용하여 서명을 확인합니다.

---
### **5.9.  Elliptic Curve Certificates**

ECC 공개 키를 포함하거나 ECDSA를 사용하여 서명된 X.509 인증서는 \[RFC3279\] 또는 이를 대체하거나 확장하는 다른 RFC를 준수해야 합니다. ECC 공개 키를 포함하거나 EdDSA를 사용하여 서명된 X.509 인증서는 \[RFC8410\]을 준수해야 합니다. 클라이언트는 ANSI X9.62, FIPS 186-4, SEC 2 \[SECG-SEC2\] 또는 \[RFC8032\]에서 권장되는 타원 곡선 도메인 매개변수를 사용해야 합니다.

Ed25519 알고리즘을 사용하는 EdDSA 키는 ed25519 서명 알고리즘을 사용해야 하며, Ed448 키는 ed448 서명 알고리즘을 사용해야 합니다. 이 문서에서는 TLS와 함께 Ed25519ph 및 Ed448ph 키의 사용을 정의하지 않습니다. Ed25519, Ed25519ph, Ed448 및 Ed448ph 키는 ECDSA와 함께 사용하면 안 됩니다.

---
### **5.10.  ECDH, ECDSA, and RSA Computations**

NIST 곡선에 대한 모든 ECDH 계산\(매개변수 및 키 생성, 공유 비밀 계산 포함\)은 ID 맵을 키 파생 함수\(KDF\)로 사용하는 ECKAS-DH1 체계를 사용하여 \[IEEE.P1363\]에 따라 수행됩니다. 프리마스터 비밀은 옥텟 문자열로 표시되는 ECDH 공유 비밀 타원 곡선 점의 x 좌표입니다. 이 옥텟 문자열\(IEEE 1363 용어로 Z\)은 FE2OSP\(필드

옥텟 문자열 변환 기본 요소\)는 지정된 필드에 대해 일정한 길이를 갖습니다. 이 옥텟 문자열에서 발견된 선행 0은 잘려서는 안 됩니다.

\(이러한 ID KDF 사용은 기술적인 문제입니다. 전체 그림은 TLS가 마스터 비밀번호를 계산하는 것 이외의 다른 용도로 프리마스터 비밀번호를 직접 사용하지 않기 때문에 ECDH가 중요하지 않은 KDF와 함께 사용된다는 것입니다. TLS 1.0 및 이는 MD5 및 SHA-1 기반 TLS 의사 난수 함수\(PRF\)가 KDF 역할을 한다는 의미이며, TLS 1.2에서는 KDF가 암호 모음에 의해 결정되며 향후 TLS 버전이나 새로운 TLS 확장이 도입될 가능성이 있습니다. 미래에는 이 계산이 달라질 수 있습니다.\)

X25519\(곡선 x25519\)를 사용하는 ECDHE 키 교환은 다음과 같습니다. \(1\) 각 당사자는 비밀 키 d를 무작위로 균일하게 선택하고 해당 공개 키 x = X25519\(d, G\)를 계산합니다. \(2\) 당사자들은 공개 키를 교환하고 공유 비밀을 x\_S = X25519\(d, x\_peer\)로 계산합니다. \(3\) 어느 쪽이든 모두 0인 x\_S를 획득하면 X25519 및 X448의 정의에 따라 핸드셰이크를 중단해야 합니다. X448용 ECDHE는 유사하게 작동하여 X25519를 X448로, x25519를 x448로 대체합니다. 파생된 공유 비밀은 premaster 비밀로 직접 사용됩니다. 이는 X25519가 포함된 ECDHE가 사용되는 경우 항상 정확히 32바이트이고 X448이 포함된 ECDHE가 사용되는 경우 56바이트입니다.

모든 ECDSA 계산은 ANSI X9.62 또는 그 후속 버전에 따라 수행되어야 합니다. 서명/검증할 데이터는 해싱되며, 결과는 추가 해싱 없이 ECDSA 알고리즘을 통해 직접 실행됩니다. \[FIPS.180-4\]의 SHA-256, SHA-384 또는 SHA-512와 같은 보안 해시 함수를 사용해야 합니다.

모든 EdDSA 계산은 \[RFC8032\] 또는 그 후속 항목에 따라 수행되어야 합니다. 서명/검증할 데이터는 해싱 없이 EdDSA 알고리즘을 통해 실행됩니다\(EdDSA는 내부적으로 "프리해시" 기능 PH를 통해 데이터를 실행합니다\). Ed448의 컨텍스트 매개변수는 빈 문자열로 설정되어야 합니다.

RFC 4492는 인증서\(아마도 subjectPublicKeyInfo의 매개변수 필드\)에 필요한 해시 함수를 지정하기 위한 메커니즘의 표준화를 예상했습니다. 이러한 표준화는 이루어지지 않았으며 결과적으로 TLS 1.1 이하에서는 SHA-1이 사용됩니다\(ID 기능을 사용하는 EdDSA 제외\). TLS 1.2는 DigitallySigned 구조체에 SignatureAndHashAlgorithm 매개변수를 추가하여 서명 해시 선택 시 민첩성을 허용합니다. EdDSA 서명에는 HashAlgorithm 8\(내재\)이 있어야 합니다.

모든 RSA 서명은 \[RFC8017\]의 섹션 7.2에 따라 생성되고 확인되어야 합니다.

---
### **5.11.  Public Key Validation**

NIST 곡선을 사용하면 각 당사자는 ClientKeyExchange 및 ServerKeyExchange 메시지에서 피어가 보낸 공개 키를 검증해야 합니다. 수신측은 피어 공개 값의 x 및 y 매개변수가 곡선 방정식 y^2 = x^3 + ax + b mod p를 충족하는지 확인해야 합니다. 자세한 내용은 \[Menezes\]의 섹션 2.3을 참조하세요. 그렇게 하지 않으면 공격자는 해당 키가 실제로 일시적이지 않은 경우 몇 번의 요청으로 전체 개인 키를 복구할 수 있을 정도로 개인 키에 대한 정보를 얻을 수 있습니다.

X25519 및 X448을 사용하는 경우 수신측은 \[RFC7748\]의 섹션 6에 설명된 대로 계산된 프리마스터 비밀 값이 모두 0인지 확인하고 그렇다면 핸드셰이크를 중단해야 합니다.

Ed25519 및 Ed448은 서명 확인의 일부로 공개 키 검증을 내부적으로 수행합니다.

---
## **6.  Cipher Suites**

아래 표는 섹션 2에 지정된 키 교환 알고리즘을 사용하는 ECC 암호화 제품군을 정의합니다.

```text
       +-----------------------------------------+----------------+
       | CipherSuite                             | Identifier     |
       +-----------------------------------------+----------------+
       | TLS_ECDHE_ECDSA_WITH_NULL_SHA           | { 0xC0, 0x06 } |
       | TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA   | { 0xC0, 0x08 } |
       | TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA    | { 0xC0, 0x09 } |
       | TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA    | { 0xC0, 0x0A } |
       | TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256 | { 0xC0, 0x2B } |
       | TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384 | { 0xC0, 0x2C } |
       |                                         |                |
       | TLS_ECDHE_RSA_WITH_NULL_SHA             | { 0xC0, 0x10 } |
       | TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA     | { 0xC0, 0x12 } |
       | TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA      | { 0xC0, 0x13 } |
       | TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA      | { 0xC0, 0x14 } |
       | TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256   | { 0xC0, 0x2F } |
       | TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384   | { 0xC0, 0x30 } |
       |                                         |                |
       | TLS_ECDH_anon_WITH_NULL_SHA             | { 0xC0, 0x15 } |
       | TLS_ECDH_anon_WITH_3DES_EDE_CBC_SHA     | { 0xC0, 0x17 } |
       | TLS_ECDH_anon_WITH_AES_128_CBC_SHA      | { 0xC0, 0x18 } |
       | TLS_ECDH_anon_WITH_AES_256_CBC_SHA      | { 0xC0, 0x19 } |
       +-----------------------------------------+----------------+

                      Table 3: TLS ECC Cipher Suites
```

이러한 각 암호 제품군에 대한 키 교환 방법, 암호 및 해시 알고리즘은 이름을 검토하여 쉽게 결정됩니다. 암호\(AES 암호 제외\) 및 해시 알고리즘은 \[RFC2246\] 및 \[RFC4346\]에 정의되어 있습니다. AES 암호는 \[RFC5246\]에 정의되어 있으며 AES-GCM 암호 모음은 \[RFC5289\]에 정의되어 있습니다.

서버 구현은 다음 암호화 모음을 모두 지원해야 하며\(SHOULD\) 클라이언트 구현은 그중 하나 이상을 지원해야 합니다\(SHOULD\).

```text
   o  TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256

   o  TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA

   o  TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256

   o  TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA
```

---
## **7.  Implementation Status**

NIST 곡선을 사용하는 ECDHE와 ECDSA는 모두 모든 주요 브라우저와 널리 사용되는 모든 TLS 라이브러리에서 널리 구현되고 지원됩니다. Curve25519가 포함된 ECDHE는 이제 여러 브라우저와 OpenSSL을 포함한 여러 TLS 라이브러리에서 구현됩니다. Curve448과 EdDSA는 상호 운용 가능한 구현을 갖추고 있지만 아직 널리 배포되지는 않았습니다.

---
## **8.  Security Considerations**

보안 문제는 이 메모 전체에서 논의됩니다.

ECC 암호 그룹을 사용하는 TLS 핸드셰이크의 경우 세 가지 TLS 기본 문서 각각의 부록 D에 있는 보안 고려 사항이 그에 따라 적용됩니다.

ECC와 관련된 보안 논의는 \[IEEE.P1363\] 및 \[ANSI.X9-62.2005\]에서 찾을 수 있습니다. 구현자와 사용자가 고려해야 할 중요한 문제 중 하나는 타원 곡선 선택입니다. 적절한 타원 곡선 크기 선택에 대한 지침은 표 1에 나와 있습니다. X25519 및 X448과 관련된 보안 고려 사항은 \[RFC7748\]의 섹션 7에 설명되어 있습니다.

타원 곡선 크기 외에도 주요 문제는 타원 곡선 구조입니다. 일반적으로 대수적 구조가 가능한 한 적은 타원 곡선을 사용하는 것이 더 보수적입니다. 따라서 랜덤 곡선은 Koblitz 곡선과 같은 특수 곡선보다 더 보수적이며, p 랜덤을 갖는 F\_p에 대한 곡선은 특수 형태의 p를 갖는 F\_p에 대한 곡선보다 더 보수적입니다.

p 랜덤을 갖는 F\_p에 대한 곡선은 특성 2에 대해 비슷한 크기의 여러 필드 사이에 선택의 여지가 없기 때문에 F\_2^m에 대한 곡선보다 더 보수적인 것으로 간주됩니다.

또 다른 문제는 단일 타원 곡선이 널리 사용될 때 치명적인 오류가 발생할 가능성이 있다는 것입니다. 이 경우 타원 곡선에 대한 공격으로 인해 많은 수의 키가 손상될 수 있습니다. 다시 말하지만, 이러한 우려는 널리 사용되는 곡선과 관련된 효율성 및 상호 운용성 향상과 균형을 이루어야 할 수도 있습니다. 타원 곡선 선택에 대한 실질적인 추가 정보는 \[IEEE.P1363\], \[ANSI.X9-62.2005\] 및 \[FIPS.186-4\]에서 찾을 수 있습니다.

\[RFC8032\] 소개에는 NIST 곡선을 사용하는 ECDSA 서명에 비해 EdDSA 서명의 보안, 성능 및 운영상의 이점이 나열되어 있습니다.

이 문서에 정의된 모든 키 교환 알고리즘은 순방향 보안을 제공합니다. 더 이상 사용되지 않는 키 교환 알고리즘 중 일부는 그렇지 않습니다.

---
## **9.  IANA Considerations**

이 문서의 전신인 \[RFC4492\]는 다음에 대한 IANA 레지스트리를 정의했습니다.

```text
   o  Supported Groups (Section 5.1)

   o  EC Point Format (Section 5.1)

   o  EC Curve Type (Section 5.4)
```

IANA는 이 세 레지스트리의 이름 앞에 "TLS"를 추가했습니다.

각 네임스페이스에 대해 이 문서는 초기 값 할당을 정의하고 개인용으로 예약된 256개 값\(NamedCurve\) 또는 8개 값\(ECPointFormat 및 ECCurveType\) 범위를 정의합니다. 추가 할당에 대한 정책은 "사양 필요"입니다. \(RFC 4492에서는 IETF 검토가 필요합니다.\)

RFC 4492를 참조하는 "ExtensionType Values", "TLS ClientCertificateType Identifiers", "TLS Cipher Suites", "TLS Supported Groups", "TLS EC Point Format" 및 "TLS EC Curve Type" 레지스트리의 모든 기존 항목은 이 문서를 참조하도록 업데이트되었습니다.

IANA는 "TLS 지원 그룹" 레지스트리에서 x25519에 값 29를 할당하고 x448에 값 30을 할당했습니다.

IANA는 이 문서를 참조로 ed25519\(7\) 및 ed448\(8\)에 대한 "TLS SignatureAlgorithm" 레지스트리에 두 개의 값을 할당했습니다. 이는 TLS 1.3과의 호환성을 유지합니다.

IANA는 DTLS-OK가 true\(Y\)로 설정된 Intrinsic\(8\)에 대한 "TLS HashAlgorithm" 레지스트리의 값 하나를 할당했으며 이 문서는 참조용입니다. 이는 TLS 1.3과의 호환성을 유지합니다.

---
## **10.  References**
---
### **10.1.  Normative References**

```text
   [ANSI.X9-62.2005]
              American National Standards Institute, "Public Key
              Cryptography for the Financial Services Industry: The
              Elliptic Curve Digital Signature Algorithm (ECDSA)",
              ANSI X9.62, November 2005.

   [FIPS.186-4]
              National Institute of Standards and Technology, "Digital
              Signature Standard (DSS)", FIPS PUB 186-4,
              DOI 10.6028/NIST.FIPS.186-4, July 2013,
              <http://nvlpubs.nist.gov/nistpubs/FIPS/
              NIST.FIPS.186-4.pdf>.

   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", BCP 14, RFC 2119,
              DOI 10.17487/RFC2119, March 1997,
              <https://www.rfc-editor.org/info/rfc2119>.

   [RFC2246]  Dierks, T. and C. Allen, "The TLS Protocol Version 1.0",
              RFC 2246, DOI 10.17487/RFC2246, January 1999,
              <https://www.rfc-editor.org/info/rfc2246>.

   [RFC3279]  Bassham, L., Polk, W., and R. Housley, "Algorithms and
              Identifiers for the Internet X.509 Public Key
              Infrastructure Certificate and Certificate Revocation List
              (CRL) Profile", RFC 3279, DOI 10.17487/RFC3279, April
              2002, <https://www.rfc-editor.org/info/rfc3279>.

   [RFC4346]  Dierks, T. and E. Rescorla, "The Transport Layer Security
              (TLS) Protocol Version 1.1", RFC 4346,
              DOI 10.17487/RFC4346, April 2006,
              <https://www.rfc-editor.org/info/rfc4346>.

   [RFC4366]  Blake-Wilson, S., Nystrom, M., Hopwood, D., Mikkelsen, J.,
              and T. Wright, "Transport Layer Security (TLS)
              Extensions", RFC 4366, DOI 10.17487/RFC4366, April 2006,
              <https://www.rfc-editor.org/info/rfc4366>.

   [RFC5246]  Dierks, T. and E. Rescorla, "The Transport Layer Security
              (TLS) Protocol Version 1.2", RFC 5246,
              DOI 10.17487/RFC5246, August 2008,
              <https://www.rfc-editor.org/info/rfc5246>.

   [RFC5289]  Rescorla, E., "TLS Elliptic Curve Cipher Suites with SHA-
              256/384 and AES Galois Counter Mode (GCM)", RFC 5289,
              DOI 10.17487/RFC5289, August 2008,
              <https://www.rfc-editor.org/info/rfc5289>.

   [RFC7748]  Langley, A., Hamburg, M., and S. Turner, "Elliptic Curves
              for Security", RFC 7748, DOI 10.17487/RFC7748, January
              2016, <https://www.rfc-editor.org/info/rfc7748>.

   [RFC8017]  Moriarty, K., Ed., Kaliski, B., Jonsson, J., and A. Rusch,
              "PKCS #1: RSA Cryptography Specifications Version 2.2",
              RFC 8017, DOI 10.17487/RFC8017, November 2016,
              <https://www.rfc-editor.org/info/rfc8017>.

   [RFC8032]  Josefsson, S. and I. Liusvaara, "Edwards-Curve Digital
              Signature Algorithm (EdDSA)", RFC 8032,
              DOI 10.17487/RFC8032, January 2017,
              <https://www.rfc-editor.org/info/rfc8032>.

   [RFC8174]  Leiba, B., "Ambiguity of Uppercase vs Lowercase in RFC
              2119 Key Words", BCP 14, RFC 8174, DOI 10.17487/RFC8174,
              May 2017, <https://www.rfc-editor.org/info/rfc8174>.

   [RFC8410]  Josefsson, S. and J. Schaad, "Algorithm Identifiers for
              Ed25519, Ed448, X25519 and X448 for Use in the Internet
              X.509 Public Key Infrastructure", RFC 8410,
              DOI 10.17487/RFC8410, August 2018,
              <https://www.rfc-editor.org/info/rfc8410>.

   [SECG-SEC2]
              Certicom Research, "SEC 2: Recommended Elliptic Curve
              Domain Parameters", Standards for Efficient Cryptography 2
              (SEC 2), Version 2.0, January 2010,
              <http://www.secg.org/sec2-v2.pdf>.

   [X.680]    ITU-T, "Abstract Syntax Notation One (ASN.1):
              Specification of basic notation", ITU-T Recommendation
              X.680, ISO/IEC 8824-1, August 2015.

   [X.690]    ITU-T, "Information technology-ASN.1 encoding rules:
              Specification of Basic Encoding Rules (BER), Canonical
              Encoding Rules (CER) and Distinguished Encoding Rules
              (DER)", ITU-T Recommendation X.690, ISO/IEC 8825-1, August
              2015.
```

---
### **10.2.  Informative References**

```text
   [FIPS.180-4]
              National Institute of Standards and Technology, "Secure
              Hash Standard (SHS)", FIPS PUB 180-4, DOI
              10.6028/NIST.FIPS.180-4, August 2015,
              <http://nvlpubs.nist.gov/nistpubs/FIPS/
              NIST.FIPS.180-4.pdf>.

   [IEEE.P1363]
              IEEE, "Standard Specifications for Public Key
              Cryptography", IEEE Std P1363,
              <http://ieeexplore.ieee.org/document/891000/>.

   [Menezes]  Menezes, A. and B. Ustaoglu, "On reusing ephemeral keys in
              Diffie-Hellman key agreement protocols", International
              Journal of Applied Cryptography, Vol. 2, Issue 2,
              DOI 10.1504/IJACT.2010.038308, January 2010.

   [RFC4492]  Blake-Wilson, S., Bolyard, N., Gupta, V., Hawk, C., and B.
              Moeller, "Elliptic Curve Cryptography (ECC) Cipher Suites
              for Transport Layer Security (TLS)", RFC 4492,
              DOI 10.17487/RFC4492, May 2006,
              <https://www.rfc-editor.org/info/rfc4492>.

   [RFC7919]  Gillmor, D., "Negotiated Finite Field Diffie-Hellman
              Ephemeral Parameters for Transport Layer Security (TLS)",
              RFC 7919, DOI 10.17487/RFC7919, August 2016,
              <https://www.rfc-editor.org/info/rfc7919>.

   [TLS1.3]   Rescorla, E., "The Transport Layer Security (TLS) Protocol
              Version 1.3", Work in Progress, draft-ietf-tls-tls13-28,
              March 2018.
```

---
# **Appendix A.  Equivalent Curves (Informative)**

모든 NIST 곡선\[FIPS.186-4\]과 여러 ANSI 곡선\[ANSI.X9-62.2005\]은 섹션 5.1.1에 나열된 곡선과 동일합니다. 다음 표에는 다양한 표준 기관에서 선택한 곡선 이름이 나와 있습니다. 한 행에 있는 여러 이름은 동일한 곡선에 대한 별칭을 나타냅니다.

```text
                  +-----------+------------+------------+
                  | SECG      | ANSI X9.62 | NIST       |
                  +-----------+------------+------------+
                  | sect163k1 |            | NIST K-163 |
                  | sect163r1 |            |            |
                  | sect163r2 |            | NIST B-163 |
                  | sect193r1 |            |            |
                  | sect193r2 |            |            |
                  | sect233k1 |            | NIST K-233 |
                  | sect233r1 |            | NIST B-233 |
                  | sect239k1 |            |            |
                  | sect283k1 |            | NIST K-283 |
                  | sect283r1 |            | NIST B-283 |
                  | sect409k1 |            | NIST K-409 |
                  | sect409r1 |            | NIST B-409 |
                  | sect571k1 |            | NIST K-571 |
                  | sect571r1 |            | NIST B-571 |
                  | secp160k1 |            |            |
                  | secp160r1 |            |            |
                  | secp160r2 |            |            |
                  | secp192k1 |            |            |
                  | secp192r1 | prime192v1 | NIST P-192 |
                  | secp224k1 |            |            |
                  | secp224r1 |            | NIST P-224 |
                  | secp256k1 |            |            |
                  | secp256r1 | prime256v1 | NIST P-256 |
                  | secp384r1 |            | NIST P-384 |
                  | secp521r1 |            | NIST P-521 |
                  +-----------+------------+------------+

        Table 4: Equivalent Curves Defined by SECG, ANSI, and NIST
```

---
# **Appendix B.  Differences from RFC 4492**

- EllipticCurveList의 이름이 NamedCurveList로 변경되었습니다.

```text
   o  Added TLS 1.2.

   o  Merged errata.
```

- ECDH 키 교환 알고리즘 제거: ECDH\_RSA 및 ECDH\_ECDSA

- 다수의 암호 제품군이 더 이상 사용되지 않습니다.

```text
         TLS_ECDH_ECDSA_WITH_NULL_SHA

         TLS_ECDH_ECDSA_WITH_RC4_128_SHA

         TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA

         TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA

         TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA

         TLS_ECDH_RSA_WITH_NULL_SHA

         TLS_ECDH_RSA_WITH_RC4_128_SHA

         TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA

         TLS_ECDH_RSA_WITH_AES_128_CBC_SHA

         TLS_ECDH_RSA_WITH_AES_256_CBC_SHA
```

- 다른 모든 RC4 암호 제품군

- 사용되지 않는 곡선과 압축되지 않은 점 형식을 제외한 모든 항목을 제거했습니다.

- X25519 및 X448이 추가되었습니다.

```text
   o  Deprecated explicit curves.
```

- 인증서의 서명 알고리즘에 대한 제한을 제거했습니다.

---
# **Acknowledgements**

이 문서의 텍스트 대부분은 이 문서의 전신인 \[RFC4492\]에서 가져온 것입니다. 해당 문서의 작성자는 다음과 같습니다.

```text
   o  Simon Blake-Wilson
   o  Nelson Bolyard
   o  Vipul Gupta
   o  Chris Hawk
   o  Bodo Moeller
```

이전 문서에서 저자는 Bill Anderson과 Tim Dierks의 기여를 인정했습니다.

저자는 이 문서에 기여한 Nikos Mavrogiannopoulos, Martin Thomson 및 Tanja Lange에게 감사를 표하고 싶습니다.

---
# **Authors' Addresses**

```text
   Yoav Nir
   Check Point Software Technologies Ltd.
   5 Hasolelim st.
   Tel Aviv  6789735
   Israel

   Email: ynir.ietf@gmail.com

   Simon Josefsson
   SJD AB

   Email: simon@josefsson.org

   Manuel Pegourie-Gonnard
   ARM

   Email: mpg@elzevir.fr
```


```text
﻿

Internet Engineering Task Force (IETF)                   J. Iyengar, Ed.
Request for Comments: 9000                                        Fastly
Category: Standards Track                                M. Thomson, Ed.
ISSN: 2070-1721                                                  Mozilla
                                                                May 2021

           QUIC: A UDP-Based Multiplexed and Secure Transport
```

---
# **Abstract**

이 문서는 QUIC 전송 프로토콜의 핵심을 정의합니다. QUIC은 구조화된 통신, 지연 시간이 짧은 연결 설정 및 네트워크 경로 마이그레이션을 위해 흐름 제어 스트림을 애플리케이션에 제공합니다. QUIC에는 다양한 배포 환경에서 기밀성, 무결성 및 가용성을 보장하는 보안 조치가 포함되어 있습니다. 함께 제공되는 문서는 키 협상, 손실 감지 및 모범적인 혼잡 제어 알고리즘을 위한 TLS의 통합을 설명합니다.

---
# **Status of This Memo**

이것은 인터넷 표준 추적 문서입니다.

이 문서는 IETF\(Internet Engineering Task Force\)의 제품입니다. 이는 IETF 커뮤니티의 합의를 나타냅니다. 공개 검토를 받았으며 IESG\(Internet Engineering Steering Group\)의 출판 승인을 받았습니다. 인터넷 표준에 대한 자세한 내용은 RFC 7841의 섹션 2에서 확인할 수 있습니다.

이 문서의 현재 상태, 정오표 및 피드백 제공 방법에 대한 정보는 https://www.rfc-editor.org/info/rfc9000에서 얻을 수 있습니다.

---
# **Copyright Notice**

Copyright \(c\) 2021 IETF Trust 및 문서 작성자로 확인된 사람. 판권 소유.

이 문서는 이 문서의 발행일에 유효한 BCP 78 및 IETF 문서에 관한 IETF 트러스트의 법적 조항\(https://trustee.ietf.org/license-info\)의 적용을 받습니다. 이 문서와 관련된 귀하의 권리 및 제한 사항을 설명하므로 이 문서를 주의 깊게 검토하십시오. 이 문서에서 추출한 코드 구성 요소는 Trust Legal Provisions의 섹션 4.e에 설명된 대로 Simplified BSD License 텍스트를 포함해야 하며 Simplified BSD License에 설명된 대로 보증 없이 제공됩니다.

---
# **Table of Contents**

```text
   1.  Overview
     1.1.  Document Structure
     1.2.  Terms and Definitions
     1.3.  Notational Conventions
   2.  Streams
     2.1.  Stream Types and Identifiers
     2.2.  Sending and Receiving Data
     2.3.  Stream Prioritization
     2.4.  Operations on Streams
   3.  Stream States
     3.1.  Sending Stream States
     3.2.  Receiving Stream States
     3.3.  Permitted Frame Types
     3.4.  Bidirectional Stream States
     3.5.  Solicited State Transitions
   4.  Flow Control
     4.1.  Data Flow Control
     4.2.  Increasing Flow Control Limits
     4.3.  Flow Control Performance
     4.4.  Handling Stream Cancellation
     4.5.  Stream Final Size
     4.6.  Controlling Concurrency
   5.  Connections
     5.1.  Connection ID
       5.1.1.  Issuing Connection IDs
       5.1.2.  Consuming and Retiring Connection IDs
     5.2.  Matching Packets to Connections
       5.2.1.  Client Packet Handling
       5.2.2.  Server Packet Handling
       5.2.3.  Considerations for Simple Load Balancers
     5.3.  Operations on Connections
   6.  Version Negotiation
     6.1.  Sending Version Negotiation Packets
     6.2.  Handling Version Negotiation Packets
     6.3.  Using Reserved Versions
   7.  Cryptographic and Transport Handshake
     7.1.  Example Handshake Flows
     7.2.  Negotiating Connection IDs
     7.3.  Authenticating Connection IDs
     7.4.  Transport Parameters
       7.4.1.  Values of Transport Parameters for 0-RTT
       7.4.2.  New Transport Parameters
     7.5.  Cryptographic Message Buffering
   8.  Address Validation
     8.1.  Address Validation during Connection Establishment
       8.1.1.  Token Construction
       8.1.2.  Address Validation Using Retry Packets
       8.1.3.  Address Validation for Future Connections
       8.1.4.  Address Validation Token Integrity
     8.2.  Path Validation
       8.2.1.  Initiating Path Validation
       8.2.2.  Path Validation Responses
       8.2.3.  Successful Path Validation
       8.2.4.  Failed Path Validation
   9.  Connection Migration
     9.1.  Probing a New Path
     9.2.  Initiating Connection Migration
     9.3.  Responding to Connection Migration
       9.3.1.  Peer Address Spoofing
       9.3.2.  On-Path Address Spoofing
       9.3.3.  Off-Path Packet Forwarding
     9.4.  Loss Detection and Congestion Control
     9.5.  Privacy Implications of Connection Migration
     9.6.  Server's Preferred Address
       9.6.1.  Communicating a Preferred Address
       9.6.2.  Migration to a Preferred Address
       9.6.3.  Interaction of Client Migration and Preferred Address
     9.7.  Use of IPv6 Flow Label and Migration
   10. Connection Termination
     10.1.  Idle Timeout
       10.1.1.  Liveness Testing
       10.1.2.  Deferring Idle Timeout
     10.2.  Immediate Close
       10.2.1.  Closing Connection State
       10.2.2.  Draining Connection State
       10.2.3.  Immediate Close during the Handshake
     10.3.  Stateless Reset
       10.3.1.  Detecting a Stateless Reset
       10.3.2.  Calculating a Stateless Reset Token
       10.3.3.  Looping
   11. Error Handling
     11.1.  Connection Errors
     11.2.  Stream Errors
   12. Packets and Frames
     12.1.  Protected Packets
     12.2.  Coalescing Packets
     12.3.  Packet Numbers
     12.4.  Frames and Frame Types
     12.5.  Frames and Number Spaces
   13. Packetization and Reliability
     13.1.  Packet Processing
     13.2.  Generating Acknowledgments
       13.2.1.  Sending ACK Frames
       13.2.2.  Acknowledgment Frequency
       13.2.3.  Managing ACK Ranges
       13.2.4.  Limiting Ranges by Tracking ACK Frames
       13.2.5.  Measuring and Reporting Host Delay
       13.2.6.  ACK Frames and Packet Protection
       13.2.7.  PADDING Frames Consume Congestion Window
     13.3.  Retransmission of Information
     13.4.  Explicit Congestion Notification
       13.4.1.  Reporting ECN Counts
       13.4.2.  ECN Validation
   14. Datagram Size
     14.1.  Initial Datagram Size
     14.2.  Path Maximum Transmission Unit
       14.2.1.  Handling of ICMP Messages by PMTUD
     14.3.  Datagram Packetization Layer PMTU Discovery
       14.3.1.  DPLPMTUD and Initial Connectivity
       14.3.2.  Validating the Network Path with DPLPMTUD
       14.3.3.  Handling of ICMP Messages by DPLPMTUD
     14.4.  Sending QUIC PMTU Probes
       14.4.1.  PMTU Probes Containing Source Connection ID
   15. Versions
   16. Variable-Length Integer Encoding
   17. Packet Formats
     17.1.  Packet Number Encoding and Decoding
     17.2.  Long Header Packets
       17.2.1.  Version Negotiation Packet
       17.2.2.  Initial Packet
       17.2.3.  0-RTT
       17.2.4.  Handshake Packet
       17.2.5.  Retry Packet
     17.3.  Short Header Packets
       17.3.1.  1-RTT Packet
     17.4.  Latency Spin Bit
   18. Transport Parameter Encoding
     18.1.  Reserved Transport Parameters
     18.2.  Transport Parameter Definitions
   19. Frame Types and Formats
     19.1.  PADDING Frames
     19.2.  PING Frames
     19.3.  ACK Frames
       19.3.1.  ACK Ranges
       19.3.2.  ECN Counts
     19.4.  RESET_STREAM Frames
     19.5.  STOP_SENDING Frames
     19.6.  CRYPTO Frames
     19.7.  NEW_TOKEN Frames
     19.8.  STREAM Frames
     19.9.  MAX_DATA Frames
     19.10. MAX_STREAM_DATA Frames
     19.11. MAX_STREAMS Frames
     19.12. DATA_BLOCKED Frames
     19.13. STREAM_DATA_BLOCKED Frames
     19.14. STREAMS_BLOCKED Frames
     19.15. NEW_CONNECTION_ID Frames
     19.16. RETIRE_CONNECTION_ID Frames
     19.17. PATH_CHALLENGE Frames
     19.18. PATH_RESPONSE Frames
     19.19. CONNECTION_CLOSE Frames
     19.20. HANDSHAKE_DONE Frames
     19.21. Extension Frames
   20. Error Codes
     20.1.  Transport Error Codes
     20.2.  Application Protocol Error Codes
   21. Security Considerations
     21.1.  Overview of Security Properties
       21.1.1.  Handshake
       21.1.2.  Protected Packets
       21.1.3.  Connection Migration
     21.2.  Handshake Denial of Service
     21.3.  Amplification Attack
     21.4.  Optimistic ACK Attack
     21.5.  Request Forgery Attacks
       21.5.1.  Control Options for Endpoints
       21.5.2.  Request Forgery with Client Initial Packets
       21.5.3.  Request Forgery with Preferred Addresses
       21.5.4.  Request Forgery with Spoofed Migration
       21.5.5.  Request Forgery with Version Negotiation
       21.5.6.  Generic Request Forgery Countermeasures
     21.6.  Slowloris Attacks
     21.7.  Stream Fragmentation and Reassembly Attacks
     21.8.  Stream Commitment Attack
     21.9.  Peer Denial of Service
     21.10. Explicit Congestion Notification Attacks
     21.11. Stateless Reset Oracle
     21.12. Version Downgrade
     21.13. Targeted Attacks by Routing
     21.14. Traffic Analysis
   22. IANA Considerations
     22.1.  Registration Policies for QUIC Registries
       22.1.1.  Provisional Registrations
       22.1.2.  Selecting Codepoints
       22.1.3.  Reclaiming Provisional Codepoints
       22.1.4.  Permanent Registrations
     22.2.  QUIC Versions Registry
     22.3.  QUIC Transport Parameters Registry
     22.4.  QUIC Frame Types Registry
     22.5.  QUIC Transport Error Codes Registry
   23. References
     23.1.  Normative References
     23.2.  Informative References
   Appendix A.  Pseudocode
     A.1.  Sample Variable-Length Integer Decoding
     A.2.  Sample Packet Number Encoding Algorithm
     A.3.  Sample Packet Number Decoding Algorithm
     A.4.  Sample ECN Validation Algorithm
   Contributors
   Authors' Addresses
```

---
## **1.  Overview**

QUIC는 안전한 범용 전송 프로토콜입니다. 이 문서는 \[QUIC-INVARIANTS\]에 정의된 QUIC의 버전 독립적 속성을 준수하는 QUIC 버전 1을 정의합니다.

QUIC은 클라이언트와 서버 간의 상태 저장 상호 작용을 생성하는 연결 지향 프로토콜입니다.

QUIC 핸드셰이크는 암호화 및 전송 매개변수의 협상을 결합합니다. QUIC은 패킷 보호를 위해 맞춤형 프레이밍을 사용하지만 TLS 핸드셰이크\[TLS13\]를 통합합니다. TLS와 QUIC의 통합은 \[QUIC-TLS\]에 자세히 설명되어 있습니다. 핸드셰이크는 가능한 한 빨리 애플리케이션 데이터를 교환할 수 있도록 구성되어 있습니다. 여기에는 클라이언트가 데이터를 즉시 전송\(0-RTT\)할 수 있는 옵션이 포함되며, 이를 활성화하려면 어떤 형태의 사전 통신 또는 구성이 필요합니다.

엔드포인트는 QUIC 패킷을 교환하여 QUIC에서 통신합니다. 대부분의 패킷에는 엔드포인트 간에 제어 정보와 애플리케이션 데이터를 전달하는 프레임이 포함되어 있습니다. QUIC은 각 패킷 전체를 인증하고 가능한 한 많은 각 패킷을 암호화합니다. QUIC 패킷은 UDP 데이터그램\[UDP\]으로 전달되어 기존 시스템 및 네트워크에 보다 쉽게 ​​배치할 수 있습니다.

애플리케이션 프로토콜은 순서가 지정된 바이트 시퀀스인 스트림을 통해 QUIC 연결을 통해 정보를 교환합니다. 두 가지 유형의 스트림을 만들 수 있습니다. 두 끝점에서 데이터를 보낼 수 있는 양방향 스트림, 단일 엔드포인트에서 데이터를 보낼 수 있는 단방향 스트림. 스트림 생성을 제한하고 보낼 수 있는 데이터의 양을 제한하기 위해 크레딧 기반 체계가 사용됩니다.

QUIC은 안정적인 전달 및 혼잡 제어를 구현하는 데 필요한 피드백을 제공합니다. 데이터 손실을 감지하고 복구하는 알고리즘은 \[빠른 복구\]의 섹션 6에 설명되어 있습니다. QUIC는 네트워크 혼잡을 피하기 위해 혼잡 제어에 의존합니다. 예시적인 혼잡 제어 알고리즘은 \[QUIC-RECOVERY\]의 섹션 7에 설명되어 있다.

QUIC 연결은 단일 네트워크 경로에 엄격하게 바인딩되지 않습니다. 연결 마이그레이션은 연결 식별자를 사용하여 연결을 새 네트워크 경로로 전송할 수 있도록 합니다. 이 버전의 QUIC에서는 클라이언트만 마이그레이션할 수 있습니다. 이 디자인은 또한 NAT 리바인딩으로 인해 발생할 수 있는 것과 같은 네트워크 토폴로지 또는 주소 매핑의 변경 후에도 연결을 계속할 수 있도록 합니다.

일단 설정되면 연결 종료를 위한 여러 옵션이 제공됩니다. 애플리케이션은 정상적인 종료를 관리할 수 있고, 엔드포인트는 시간 초과 기간을 협상할 수 있고, 오류로 인해 즉각적인 연결 해제가 발생할 수 있으며, 상태 비저장 메커니즘은 한 엔드포인트가 상태를 잃은 후 연결 종료를 제공합니다.

---
### **1.1.  Document Structure**

이 문서는 핵심 QUIC 프로토콜을 설명하며 다음과 같이 구성됩니다.

\* 스트림은 QUIC이 제공하는 기본 서비스 추상화입니다.

- - 섹션 2는 스트림과 관련된 핵심 개념을 설명합니다.

- - 섹션 3은 스트림 상태에 대한 참조 모델을 제공하며,

- - 섹션 4는 흐름 제어의 작동을 설명합니다.

\* 연결은 QUIC 엔드포인트가 통신하는 컨텍스트입니다.

- - 섹션 5는 연결과 관련된 핵심 개념을 설명합니다.

```text
      -  Section 6 describes version negotiation,
```

- - 섹션 7은 연결 설정 프로세스를 자세히 설명합니다.

- - 섹션 8은 주소 확인 및 중요한 서비스 거부 완화를 설명합니다.

- - 섹션 9에서는 엔드포인트가 연결을 새 네트워크 경로로 마이그레이션하는 방법을 설명합니다.

- 섹션 10에는 열기 종료 옵션이 나열되어 있습니다.

- 연결 및

- - 섹션 11은 스트림 및 연결 오류 처리에 대한 지침을 제공합니다.

\* 패킷과 프레임은 QUIC이 통신하기 위해 사용하는 기본 단위입니다.

- - 섹션 12는 패킷 및 프레임과 관련된 개념을 설명하고,

- - 섹션 13은 데이터의 전송, 재전송 및 확인을 위한 모델을 정의합니다.

- - 섹션 14는 QUIC 패킷을 전달하는 데이터그램의 크기를 관리하는 규칙을 지정합니다.

\* 마지막으로 QUIC 프로토콜 요소의 인코딩 세부 사항은 다음에서 설명합니다.

```text
      -  Section 15 (versions),

      -  Section 16 (integer encoding),

      -  Section 17 (packet headers),

      -  Section 18 (transport parameters),

      -  Section 19 (frames), and

      -  Section 20 (errors).
```

첨부 문서는 QUIC의 손실 감지 및 혼잡 제어\[QUIC-RECOVERY\], TLS 및 기타 암호화 메커니즘\[QUIC-TLS\]의 사용을 설명합니다.

이 문서는 \[QUIC-INVARIANTS\]의 프로토콜 불변성을 준수하는 QUIC 버전 1을 정의합니다.

QUIC 버전 1을 참조하려면 이 문서를 인용하십시오. QUIC의 제한된 버전 독립적 속성 집합에 대한 참조는 \[QUIC-INVARIANTS\]를 인용할 수 있습니다.

---
### **1.2.  Terms and Definitions**

키워드 "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY" 및 "OPTIONAL" "는 BCP 14 \[RFC2119\] \[RFC8174\]에 설명된 대로 여기에 표시된 것처럼 모두 대문자로 표시되는 경우에만 해석됩니다.\(MUST NOT\)

이 문서에서 일반적으로 사용되는 용어는 아래에 설명되어 있습니다.

QUIC: 이 문서에서 설명하는 전송 프로토콜입니다. QUIC은 약어가 아니라 이름입니다.

끝점: QUIC 패킷을 생성, 수신 및 처리하여 QUIC 연결에 참여할 수 있는 엔터티입니다. QUIC에는 클라이언트와 서버의 두 가지 유형의 엔드포인트만 있습니다.

클라이언트: QUIC 연결을 시작하는 끝점입니다.

서버: QUIC 연결을 수락하는 끝점입니다.

QUIC 패킷: UDP 데이터그램으로 캡슐화할 수 있는 QUIC의 완전한 처리 가능 단위입니다. 하나 이상의 QUIC 패킷을 단일 UDP 데이터그램에 캡슐화할 수 있습니다.

Ack-eliciting 패킷: ACK, PADDING 및 CONNECTION\_CLOSE 이외의 프레임을 포함하는 QUIC 패킷. 이로 인해 수신자가 승인을 보내게 됩니다. 섹션 13.2.1을 참조하십시오.

프레임: 구조화된 프로토콜 정보의 단위. 여러 프레임 유형이 있으며 각각 다른 정보를 전달합니다. 프레임은 QUIC 패킷에 포함됩니다.

주소: 자격 없이 사용되는 경우 네트워크 경로의 한쪽 끝을 나타내는 IP 버전, IP 주소 및 UDP 포트 번호의 튜플입니다.

연결 ID: 끝점에서 QUIC 연결을 식별하는 데 사용되는 식별자입니다. 각 엔드포인트는 피어가 엔드포인트로 전송되는 패킷에 포함할 하나 이상의 연결 ID를 선택합니다. 이 값은 피어에 불투명합니다.

스트림: QUIC 연결 내에서 정렬된 바이트의 단방향 또는 양방향 채널입니다. QUIC 연결은 여러 동시 스트림을 전달할 수 있습니다.

응용 프로그램: QUIC을 사용하여 데이터를 보내고 받는 엔터티입니다.

이 문서에서는 각 프로토콜의 단위를 나타내기 위해 "QUIC 패킷", "UDP 데이터그램" 및 "IP 패킷"이라는 용어를 사용합니다. 즉, 하나 이상의 QUIC 패킷을 UDP 데이터그램으로 캡슐화할 수 있으며, 이는 다시 IP 패킷으로 캡슐화됩니다.

---
### **1.3.  Notational Conventions**

이 문서의 패킷 및 프레임 다이어그램은 사용자 지정 형식을 사용합니다. 이 형식의 목적은 프로토콜 요소를 정의하는 것이 아니라 요약하는 것입니다. 산문은 완전한 의미론과 구조의 세부 사항을 정의합니다.

복합 필드는 이름이 지정된 다음 한 쌍의 일치하는 중괄호로 둘러싸인 필드 목록이 옵니다. 이 목록의 각 필드는 쉼표로 구분됩니다.

개별 필드에는 길이 정보와 고정 값, 선택 사항 또는 반복에 대한 표시가 포함됩니다. 개별 필드는 모든 길이가 비트인 다음과 같은 표기 규칙을 사용합니다.

x\(A\): x가 A 비트 길이임을 나타냅니다.

x \(i\): x가 섹션 16에 설명된 가변 길이 인코딩을 사용하여 정수 값을 보유함을 나타냅니다.

x \(A..B\): x는 A에서 B까지의 길이일 수 있음을 나타냅니다. A는 최소 0비트를 나타내기 위해 생략될 수 있고 B는 설정된 상한이 없음을 나타내기 위해 생략될 수 있습니다. 이 형식의 값은 항상 바이트 경계에서 끝납니다.

x\(L\) = C: x가 C의 고정 값을 가짐을 나타냅니다. x의 길이는 L로 표시되며 위의 길이 형식 중 하나를 사용할 수 있습니다.

x\(L\) = C..D: x가 위와 같이 L로 기술된 길이로 C에서 D까지의 범위에 있는 값을 가짐을 나타냅니다.

\[x\(L\)\]: x는 선택적이며 길이가 L임을 나타냅니다.

x \(L\) ...: x가 0번 이상 반복되고 각 인스턴스의 길이가 L임을 나타냅니다.

이 문서는 네트워크 바이트 순서\(즉, 빅 엔디안\) 값을 사용합니다. 필드는 각 바이트의 상위 비트부터 시작하여 배치됩니다.

규칙에 따라 개별 필드는 복합 필드의 이름을 사용하여 복합 필드를 참조합니다.

그림 1은 예를 제공합니다.

```text
   Example Structure {
     One-bit Field (1),
     7-bit Field with Fixed Value (7) = 61,
     Field with Variable-Length Integer (i),
     Arbitrary-Length Field (..),
     Variable-Length Field (8..24),
     Field With Minimum Length (16..),
     Field With Maximum Length (..128),
     [Optional Field (64)],
     Repeated Field (8) ...,
   }

                          Figure 1: Example Format
```

산문에서 단일 비트 필드를 참조할 때 해당 필드의 위치는 해당 필드의 값 세트와 함께 필드를 전달하는 바이트의 값을 사용하여 명확히 할 수 있습니다. 예를 들어 값 0x80은 그림 1의 1비트 필드와 같이 바이트의 최상위 비트에서 단일 비트 필드를 참조하는 데 사용할 수 있습니다.

---
## **2.  Streams**

QUIC의 스트림은 응용 프로그램에 경량의 정렬된 바이트 스트림 추상화를 제공합니다. 스트림은 단방향 또는 양방향일 수 있습니다.

데이터를 전송하여 스트림을 생성할 수 있습니다. 스트림 관리와 관련된 다른 프로세스\(흐름 제어 종료, 취소 및 관리\)는 모두 최소한의 오버헤드를 부과하도록 설계되었습니다. 예를 들어 단일 STREAM 프레임\(19.8절\)은 스트림을 열고, 데이터를 전달하고, 닫을 수 있습니다. 스트림은 수명이 길 수도 있고 전체 연결 기간 동안 지속될 수 있습니다.

스트림은 양쪽 끝점에서 생성할 수 있고 다른 스트림과 인터리브된 데이터를 동시에 보낼 수 있으며 취소할 수 있습니다. QUIC은 서로 다른 스트림의 바이트 간 순서를 보장하는 수단을 제공하지 않습니다.

QUIC은 흐름 제어 제약 조건 및 스트림 제한에 따라 임의의 수의 스트림이 동시에 작동하고 임의의 양의 데이터가 모든 스트림에서 전송되도록 허용합니다. 섹션 4를 참조하십시오.

---
### **2.1.  Stream Types and Identifiers**

스트림은 단방향 또는 양방향일 수 있습니다. 단방향 스트림은 한 방향으로 데이터를 전달합니다: 스트림 시작자에서 해당 피어로. 양방향 스트림을 사용하면 데이터를 양방향으로 보낼 수 있습니다.

스트림은 스트림 ID라고 하는 숫자 값으로 연결 내에서 식별됩니다. 스트림 ID는 연결의 모든 스트림에 대해 고유한 62비트 정수\(0 \~ 2^62-1\)입니다. 스트림 ID는 가변 길이 정수로 인코딩됩니다. 섹션 16을 참조하십시오. QUIC 끝점은 연결 내에서 스트림 ID를 재사용해서는 안 됩니다\(MUST NOT\).\(MUST NOT\)

스트림 ID의 최하위 비트\(0x01\)는 스트림의 개시자를 식별합니다. 클라이언트 시작 스트림에는 짝수 스트림 ID\(비트가 0으로 설정됨\)가 있고 서버 시작 스트림에는 홀수 스트림 ID\(비트가 1로 설정됨\)가 있습니다.

스트림 ID의 두 번째 최하위 비트\(0x02\)는 양방향 스트림\(비트가 0으로 설정됨\)과 단방향 스트림\(비트가 1로 설정됨\)을 구분합니다.

따라서 스트림 ID의 최하위 2비트는 표 1에 요약된 대로 스트림을 네 가지 유형 중 하나로 식별합니다.

```text
                +======+==================================+
                | Bits | Stream Type                      |
                +======+==================================+
                | 0x00 | Client-Initiated, Bidirectional  |
                +------+----------------------------------+
                | 0x01 | Server-Initiated, Bidirectional  |
                +------+----------------------------------+
                | 0x02 | Client-Initiated, Unidirectional |
                +------+----------------------------------+
                | 0x03 | Server-Initiated, Unidirectional |
                +------+----------------------------------+

                          Table 1: Stream ID Types
```

각 유형의 스트림 공간은 최소값\(각각 0x00\~0x03\)에서 시작합니다. 각 유형의 연속 스트림은 숫자가 증가하는 스트림 ID로 생성됩니다. 잘못된 순서로 사용된 스트림 ID는 낮은 번호의 스트림 ID를 가진 해당 유형의 모든 스트림이 열리도록 합니다.

---
### **2.2.  Sending and Receiving Data**

STREAM 프레임\(19.8절\)은 응용 프로그램에서 보낸 데이터를 캡슐화합니다. 끝점은 STREAM 프레임의 스트림 ID 및 오프셋 필드를 사용하여 데이터를 순서대로 배치합니다.

엔드포인트는 순서가 지정된 바이트 스트림으로 애플리케이션에 스트림 데이터를 전달할 수 있어야 합니다\(MUST\). 순서가 지정된 바이트 스트림을 전달하려면 끝점이 광고된 흐름 제어 제한까지 순서가 맞지 않게 수신된 모든 데이터를 버퍼링해야 합니다.\(MUST\)

QUIC은 순서가 잘못된 스트림 데이터의 전달을 특별히 허용하지 않습니다. 그러나 구현은 수신 응용 프로그램에 순서가 없는 데이터를 전달하는 기능을 제공하도록 선택할 수 있습니다\(MAY\).\(MAY\)

엔드포인트는 동일한 스트림 오프셋에서 스트림에 대한 데이터를 여러 번 수신할 수 있습니다. 이미 수신된 데이터는 폐기할 수 있습니다. 주어진 오프셋의 데이터는 여러 번 전송되는 경우 변경되어서는 안 됩니다\(MUST NOT\). 끝점은 PROTOCOL\_VIOLATION 유형의 연결 오류로 스트림 내의 동일한 오프셋에서 다른 데이터 수신을 처리할 수 있습니다\(MAY\).\(MUST NOT\)

스트림은 QUIC에서 볼 수 있는 다른 구조가 없는 정렬된 바이트 스트림 추상화입니다. STREAM 프레임 경계는 데이터가 전송되거나, 패킷 손실 후 재전송되거나, 수신기에서 응용 프로그램으로 전달될 때 보존되지 않을 것으로 예상됩니다.

끝점은 피어가 설정한 흐름 제어 제한 내에 있는지 확인하지 않고 스트림에서 데이터를 보내면 안 됩니다\(MUST NOT\). 흐름 제어는 섹션 4에서 자세히 설명합니다.\(MUST NOT\)

---
### **2.3.  Stream Prioritization**

스트림 멀티플렉싱은 스트림에 할당된 리소스의 우선 순위가 올바르게 지정된 경우 애플리케이션 성능에 상당한 영향을 미칠 수 있습니다.

QUIC은 우선순위 정보 교환을 위한 메커니즘을 제공하지 않습니다. 대신 응용 프로그램에서 우선 순위 정보를 받는 것에 의존합니다.

QUIC 구현은 응용 프로그램이 스트림의 상대적 우선 순위를 나타낼 수 있는 방법을 제공해야 합니다\(SHOULD\). 구현은 활성 스트림에 리소스를 할당하는 방법을 결정하기 위해 애플리케이션에서 제공하는 정보를 사용합니다.\(SHOULD\)

---
### **2.4.  Operations on Streams**

이 문서는 QUIC용 API를 정의하지 않습니다. 대신 애플리케이션 프로토콜이 의존할 수 있는 일련의 함수를 스트림에 정의합니다. 애플리케이션 프로토콜은 QUIC 구현이 이 섹션에 설명된 작업을 포함하는 인터페이스를 제공한다고 가정할 수 있습니다. 특정 애플리케이션 프로토콜과 함께 사용하도록 설계된 구현은 해당 프로토콜에서 사용되는 작업만 제공할 수 있습니다.

스트림의 전송 부분에서 애플리케이션 프로토콜은 다음을 수행할 수 있습니다.

```text
   *  write data, understanding when stream flow control credit
      (Section 4.1) has successfully been reserved to send the written
      data;
```

\* FIN 비트가 설정된 STREAM 프레임\(섹션 19.8\)을 생성하여 스트림을 종료합니다\(깨끗한 종료\). 그리고

\* 스트림을 재설정\(갑작스러운 종료\)하여 스트림이 아직 종료 상태가 아닌 경우 RESET\_STREAM 프레임\(19.4절\)이 발생합니다.

스트림의 수신 부분에서 애플리케이션 프로토콜은 다음을 수행할 수 있습니다.

```text
   *  read data; and
```

\* 스트림 읽기 중단 및 폐쇄 요청, 가능한 경우

- STOP\_SENDING 프레임\(섹션 19.5\)이 발생합니다.

애플리케이션 프로토콜은 또한 피어가 스트림을 열거나 재설정한 경우, 피어가 스트림 읽기를 중단한 경우, 새 데이터를 사용할 수 있는 경우, 데이터를 쓸 수 있거나 쓸 수 없는 경우를 포함하여 스트림의 상태 변경에 대한 알림을 받도록 요청할 수 있습니다. 흐름 제어로 인한 스트림.

---
## **3.  Stream States**

이 섹션에서는 전송 또는 수신 구성 요소 측면에서 스트림을 설명합니다. 두 가지 상태 머신이 설명됩니다. 하나는 엔드포인트가 데이터를 전송하는 스트림용\(섹션 3.1\)이고 다른 하나는 엔드포인트가 데이터를 수신하는 스트림용입니다\(섹션 3.2\).

단방향 스트림은 스트림 유형 및 끝점 역할에 따라 송신 또는 수신 상태 시스템을 사용합니다. 양방향 스트림은 두 엔드포인트에서 두 상태 시스템을 모두 사용합니다. 대부분의 경우 이러한 상태 시스템의 사용은 스트림이 단방향이든 양방향이든 동일합니다. 양방향 스트림의 경우 스트림을 여는 조건이 약간 더 복잡합니다. 송신측 또는 수신측 중 하나를 열면 스트림이 양방향으로 열리기 때문입니다.

이 섹션에 표시된 상태 머신은 대부분 정보를 제공합니다. 이 문서는 스트림 상태를 사용하여 다양한 유형의 프레임을 보낼 수 있는 시기와 방법에 대한 규칙과 다양한 유형의 프레임을 수신할 때 예상되는 반응을 설명합니다. 이러한 상태 머신은 QUIC 구현에 유용하도록 의도되었지만 이러한 상태는 구현을 제한하기 위한 것이 아닙니다. 구현은 해당 동작이 이러한 상태를 구현하는 구현과 일치하는 한 다른 상태 시스템을 정의할 수 있습니다.

- | 참고: 경우에 따라 단일 이벤트나 작업으로 인해 | 여러 상태를 통한 전환. 예를 들어 | FIN 비트가 설정된 STREAM은 | 전송 스트림: "준비" 상태에서 "전송" 상태로 | "전송" 상태에서 "데이터 전송" 상태로.

---
### **3.1.  Sending Stream States**

그림 2는 데이터를 피어로 보내는 스트림 부분의 상태를 보여줍니다.

```text
          o
          | Create Stream (Sending)
          | Peer Creates Bidirectional Stream
          v
      +-------+
      | Ready | Send RESET_STREAM
      |       |-----------------------.
      +-------+                       |
          |                           |
          | Send STREAM /             |
          |      STREAM_DATA_BLOCKED  |
          v                           |
      +-------+                       |
      | Send  | Send RESET_STREAM     |
      |       |---------------------->|
      +-------+                       |
          |                           |
          | Send STREAM + FIN         |
          v                           v
      +-------+                   +-------+
      | Data  | Send RESET_STREAM | Reset |
      | Sent  |------------------>| Sent  |
      +-------+                   +-------+
          |                           |
          | Recv All ACKs             | Recv ACK
          v                           v
      +-------+                   +-------+
      | Data  |                   | Reset |
      | Recvd |                   | Recvd |
      +-------+                   +-------+
```

- 그림 2: 스트림의 일부를 보내기 위한 상태

엔드포인트가 시작하는 스트림의 전송 부분\(클라이언트의 경우 유형 0과 2, 서버의 경우 유형 1과 3\)은 애플리케이션에서 열립니다. "준비" 상태는 응용 프로그램에서 데이터를 받아들일 수 있는 새로 생성된 스트림을 나타냅니다. 스트림 데이터는 전송 준비를 위해 이 상태에서 버퍼링될 수 있습니다.

첫 번째 STREAM 또는 STREAM\_DATA\_BLOCKED 프레임을 전송하면 스트림의 전송 부분이 "전송" 상태가 됩니다. 구현은 첫 번째 STREAM 프레임을 전송하고 이 상태에 진입할 때까지 스트림에 대한 스트림 ID 할당을 연기하도록 선택할 수 있으며, 이는 더 나은 스트림 우선 순위 지정을 허용할 수 있습니다.

피어\(서버의 경우 유형 0, 클라이언트의 경우 유형 1\)에 의해 시작된 양방향 스트림의 송신 부분은 수신 부분이 생성될 때 "준비" 상태에서 시작됩니다.

"보내기" 상태에서 엔드포인트는 STREAM 프레임에서 스트림 데이터를 전송하고 필요에 따라 재전송합니다. 엔드포인트는 피어가 설정한 흐름 제어 제한을 준수하고 MAX\_STREAM\_DATA 프레임을 계속 수락하고 처리합니다. "전송" 상태의 끝점은 스트림 흐름 제어 제한\(섹션 4.1\)에 의해 전송이 차단된 경우 STREAM\_DATA\_BLOCKED 프레임을 생성합니다.

애플리케이션이 모든 스트림 데이터가 전송되었음을 표시하고 FIN 비트를 포함하는 STREAM 프레임이 전송되면 스트림의 전송 부분이 "데이터 전송됨" 상태가 됩니다. 이 상태에서 엔드포인트는 필요한 경우에만 스트림 데이터를 재전송합니다. 끝점은 흐름 제어 제한을 확인하거나 이 상태의 스트림에 대해 STREAM\_DATA\_BLOCKED 프레임을 보낼 필요가 없습니다. MAX\_STREAM\_DATA 프레임은 피어가 최종 스트림 오프셋을 수신할 때까지 수신될 수 있습니다. 엔드포인트는 이 상태의 스트림에 대해 피어에서 수신하는 모든 MAX\_STREAM\_DATA 프레임을 안전하게 무시할 수 있습니다.

모든 스트림 데이터가 성공적으로 승인되면 스트림의 전송 부분이 터미널 상태인 "데이터 수신" 상태에 들어갑니다.

"Ready", "Send" 또는 "Data Sent" 중 하나인 모든 상태에서 응용 프로그램은 스트림 데이터 전송을 포기하겠다는 신호를 보낼 수 있습니다. 또는 엔드포인트가 피어로부터 STOP\_SENDING 프레임을 수신할 수 있습니다. 두 경우 모두 엔드포인트는 RESET\_STREAM 프레임을 전송하여 스트림이 "Reset Sent" 상태가 되도록 합니다.

끝점은 스트림을 언급하는 첫 번째 프레임으로 RESET\_STREAM을 보낼 수 있습니다. 이로 인해 해당 스트림의 전송 부분이 열린 다음 즉시 "Reset Sent" 상태로 전환됩니다.\(MAY\)

RESET\_STREAM이 포함된 패킷이 확인되면 스트림의 전송 부분이 터미널 상태인 "Reset Recvd" 상태로 들어갑니다.

---
### **3.2.  Receiving Stream States**

그림 3은 피어에서 데이터를 수신하는 스트림 부분의 상태를 보여줍니다. 스트림의 수신 부분에 대한 상태는 피어에서 스트림의 송신 부분의 일부 상태만 미러링합니다. 스트림의 수신 부분은 "준비" 상태와 같이 관찰할 수 없는 송신 부분의 상태를 추적하지 않습니다. 대신 스트림의 수신 부분에서 응용 프로그램으로의 데이터 전달을 추적하며 그 중 일부는 발신자가 관찰할 수 없습니다.

```text
          o
          | Recv STREAM / STREAM_DATA_BLOCKED / RESET_STREAM
          | Create Bidirectional Stream (Sending)
          | Recv MAX_STREAM_DATA / STOP_SENDING (Bidirectional)
          | Create Higher-Numbered Stream
          v
      +-------+
      | Recv  | Recv RESET_STREAM
      |       |-----------------------.
      +-------+                       |
          |                           |
          | Recv STREAM + FIN         |
          v                           |
      +-------+                       |
      | Size  | Recv RESET_STREAM     |
      | Known |---------------------->|
      +-------+                       |
          |                           |
          | Recv All Data             |
          v                           v
      +-------+ Recv RESET_STREAM +-------+
      | Data  |--- (optional) --->| Reset |
      | Recvd |  Recv All Data    | Recvd |
      +-------+<-- (optional) ----+-------+
          |                           |
          | App Read All Data         | App Read Reset
          v                           v
      +-------+                   +-------+
      | Data  |                   | Reset |
      | Read  |                   | Read  |
      +-------+                   +-------+

              Figure 3: States for Receiving Parts of Streams
```

피어에 의해 시작된 스트림의 수신 부분\(클라이언트의 경우 유형 1 및 3 또는 서버의 경우 유형 0 및 2\)은 해당 스트림에 대한 첫 번째 STREAM, STREAM\_DATA\_BLOCKED 또는 RESET\_STREAM 프레임이 수신될 때 생성됩니다. 피어에 의해 시작된 양방향 스트림의 경우 스트림의 송신 부분에 대한 MAX\_STREAM\_DATA 또는 STOP\_SENDING 프레임을 수신하면 수신 부분도 생성됩니다. 스트림 수신 부분의 초기 상태는 "Recv"입니다.

양방향 스트림의 경우 엔드포인트\(클라이언트의 경우 0 유형, 서버의 경우 1 유형\)에 의해 시작된 송신 부분이 "준비" 상태에 들어갈 때 수신 부분이 "수신" 상태에 들어갑니다.

해당 스트림에 대한 피어에서 MAX\_STREAM\_DATA 또는 STOP\_SENDING 프레임을 수신하면 끝점이 양방향 스트림을 엽니다. 열리지 않은 스트림에 대한 MAX\_STREAM\_DATA 프레임을 수신하면 원격 피어가 스트림을 열었고 흐름 제어 크레딧을 제공하고 있음을 나타냅니다. 미개봉 스트림에 대한 STOP\_SENDING 프레임 수신은 원격 피어가 더 이상 이 스트림에서 데이터를 수신하기를 원하지 않음을 나타냅니다. 패킷이 손실되거나 재정렬된 경우 프레임이 STREAM 또는 STREAM\_DATA\_BLOCKED 프레임보다 먼저 도착할 수 있습니다.

스트림이 생성되기 전에 낮은 번호의 스트림 ID를 가진 동일한 유형의 모든 스트림이 생성되어야 합니다. 이렇게 하면 스트림 생성 순서가 두 끝점에서 일관됩니다.\(MUST\)

"Recv" 상태에서 엔드포인트는 STREAM 및 STREAM\_DATA\_BLOCKED 프레임을 수신합니다. 들어오는 데이터는 버퍼링되며 응용 프로그램에 전달하기 위해 올바른 순서로 다시 어셈블할 수 있습니다. 애플리케이션에서 데이터를 소비하고 버퍼 공간을 사용할 수 있게 되면 엔드포인트는 피어가 더 많은 데이터를 보낼 수 있도록 MAX\_STREAM\_DATA 프레임을 보냅니다.

FIN 비트가 있는 STREAM 프레임이 수신되면 스트림의 최종 크기가 알려집니다. 섹션 4.5를 참조하십시오. 스트림의 수신 부분은 "크기를 알 수 있음" 상태로 들어갑니다. 이 상태에서 엔드포인트는 더 이상 MAX\_STREAM\_DATA 프레임을 보낼 필요가 없습니다. 스트림 데이터의 재전송만 수신합니다.

스트림에 대한 모든 데이터가 수신되면 수신 부분은 "Data Recvd" 상태로 들어갑니다. 이것은 "알려진 크기"로의 전환을 유발하는 동일한 STREAM 프레임을 수신한 결과로 발생할 수 있습니다. 모든 데이터를 수신한 후 스트림에 대한 모든 STREAM 또는 STREAM\_DATA\_BLOCKED 프레임을 버릴 수 있습니다.

"Data Recvd" 상태는 스트림 데이터가 애플리케이션에 전달될 때까지 지속됩니다. 스트림 데이터가 전달되면 스트림은 최종 상태인 "데이터 읽기" 상태로 들어갑니다.

"Recv" 또는 "Size Known" 상태에서 RESET\_STREAM 프레임을 수신하면 스트림이 "Reset Recvd" 상태가 됩니다. 이로 인해 애플리케이션으로의 스트림 데이터 전달이 중단될 수 있습니다.

RESET\_STREAM이 수신될 때\(즉, "Data Recvd" 상태에서\) 모든 스트림 데이터가 이미 수신되었을 가능성이 있습니다. 마찬가지로 나머지 스트림 데이터는 RESET\_STREAM 프레임을 수신한 후 도착할 수 있습니다\("Reset Recvd" 상태\). 구현은 선택에 따라 이 상황을 자유롭게 관리할 수 있습니다.

RESET\_STREAM 전송은 엔드포인트가 스트림 데이터의 전달을 보장할 수 없음을 의미합니다. 그러나 RESET\_STREAM이 수신된 경우 스트림 데이터가 전달되지 않아야 한다는 요구 사항은 없습니다. 구현은 스트림 데이터의 전달을 중단하고 소비되지 않은 데이터를 버리고 RESET\_STREAM 수신 신호를 보낼 수 있습니다\(MAY\). 스트림 데이터가 완전히 수신되고 애플리케이션에서 읽을 수 있도록 버퍼링되는 경우 RESET\_STREAM 신호가 억제되거나 보류될 수 있습니다. RESET\_STREAM이 억제되면 스트림의 수신 부분이 "Data Recvd"에 남아 있습니다.\(MAY\)

응용 프로그램이 스트림이 재설정되었음을 나타내는 신호를 수신하면 스트림의 수신 부분이 터미널 상태인 "재설정 읽기" 상태로 전환됩니다.

---
### **3.3.  Permitted Frame Types**

스트림의 송신자는 송신자 또는 수신자의 스트림 상태에 영향을 미치는 세 가지 프레임 유형\(STREAM\(19.8절\), STREAM\_DATA\_BLOCKED\(19.13절\) 및 RESET\_STREAM\(19.4절\)\)만 보냅니다.

발신자는 터미널 상태\("Data Recvd" 또는 "Reset Recvd"\)에서 이러한 프레임을 보내면 안 됩니다\(MUST NOT\). 발신자는 "Reset Sent" 상태 또는 터미널 상태\(즉, RESET\_STREAM 프레임을 보낸 후\)의 스트림에 대해 STREAM 또는 STREAM\_DATA\_BLOCKED 프레임을 보내서는 안 됩니다\(MUST NOT\). 수신기는 이들을 전달하는 패킷의 지연된 전달 가능성으로 인해 어떤 상태에서든 이 세 프레임 중 하나를 수신할 수 있습니다.\(MUST NOT, MUST NOT\)

스트림의 수신자는 MAX\_STREAM\_DATA 프레임\(19.10절\)과 STOP\_SENDING 프레임\(19.5절\)을 보냅니다.

수신자는 "Recv" 상태의 MAX\_STREAM\_DATA 프레임만 보냅니다. 수신자는 RESET\_STREAM 프레임을 수신하지 않은 상태\(즉, "Reset Recvd" 또는 "Reset Read" 이외의 상태\)에서 STOP\_SENDING 프레임을 보낼 수 있습니다. 그러나 모든 스트림 데이터가 수신되었으므로 "Data Recvd" 상태에서 STOP\_SENDING 프레임을 보내는 것은 거의 가치가 없습니다. 보낸 사람은 지연된 패킷 배달의 결과로 어떤 상태에서든 이 두 가지 유형의 프레임 중 하나를 받을 수 있습니다.\(MAY\)

---
### **3.4.  Bidirectional Stream States**

양방향 스트림은 송신 부분과 수신 부분으로 구성됩니다. 구현은 양방향 스트림의 상태를 송신 및 수신 스트림 상태의 합성물로 나타낼 수 있습니다. 가장 간단한 모델은 송신 또는 수신 부분이 비종단 상태일 때 스트림을 "열림"으로 표시하고 송신 스트림과 수신 스트림이 모두 종료 상태일 때 "닫힘"으로 표시합니다.

표 2는 HTTP/2\[HTTP2\]에 정의된 스트림 상태에 느슨하게 대응하는 양방향 스트림 상태의 보다 복잡한 매핑을 보여줍니다. 이는 스트림의 일부를 전송하거나 수신하는 여러 상태가 동일한 복합 상태에 매핑됨을 보여줍니다. 이것은 그러한 매핑에 대한 하나의 가능성일 뿐이라는 점에 유의하십시오. 이 매핑에서는 "닫힘" 또는 "반닫힘" 상태로 전환하기 전에 데이터를 확인해야 합니다.

```text
      +===================+=======================+=================+
      | Sending Part      | Receiving Part        | Composite State |
      +===================+=======================+=================+
      | No Stream / Ready | No Stream / Recv (*1) | idle            |
      +-------------------+-----------------------+-----------------+
      | Ready / Send /    | Recv / Size Known     | open            |
      | Data Sent         |                       |                 |
      +-------------------+-----------------------+-----------------+
      | Ready / Send /    | Data Recvd / Data     | half-closed     |
      | Data Sent         | Read                  | (remote)        |
      +-------------------+-----------------------+-----------------+
      | Ready / Send /    | Reset Recvd / Reset   | half-closed     |
      | Data Sent         | Read                  | (remote)        |
      +-------------------+-----------------------+-----------------+
      | Data Recvd        | Recv / Size Known     | half-closed     |
      |                   |                       | (local)         |
      +-------------------+-----------------------+-----------------+
      | Reset Sent /      | Recv / Size Known     | half-closed     |
      | Reset Recvd       |                       | (local)         |
      +-------------------+-----------------------+-----------------+
      | Reset Sent /      | Data Recvd / Data     | closed          |
      | Reset Recvd       | Read                  |                 |
      +-------------------+-----------------------+-----------------+
      | Reset Sent /      | Reset Recvd / Reset   | closed          |
      | Reset Recvd       | Read                  |                 |
      +-------------------+-----------------------+-----------------+
      | Data Recvd        | Data Recvd / Data     | closed          |
      |                   | Read                  |                 |
      +-------------------+-----------------------+-----------------+
      | Data Recvd        | Reset Recvd / Reset   | closed          |
      |                   | Read                  |                 |
      +-------------------+-----------------------+-----------------+
```

- 표 2: HTTP/2에 대한 스트림 상태의 가능한 매핑

- | 참고\(\*1\): 스트림이 아직 "유휴" 상태가 아닌 경우 | 생성되었거나 스트림의 수신 부분이 "Recv"에 있는 경우 | 아직 프레임을 수신하지 않은 상태입니다.

---
### **3.5.  Solicited State Transitions**

응용 프로그램이 스트림에서 수신하는 데이터에 더 이상 관심이 없으면 스트림 읽기를 중단하고 응용 프로그램 오류 코드를 지정할 수 있습니다.

스트림이 "Recv" 또는 "Size Known" 상태에 있는 경우 전송은 STOP\_SENDING 프레임을 전송하여 반대 방향으로 스트림을 닫도록 프롬프트하여 신호를 보내야 합니다\(SHOULD\). 이는 일반적으로 수신 애플리케이션이 더 이상 스트림에서 수신하는 데이터를 읽지 않음을 나타내지만 수신 데이터가 무시된다는 보장은 없습니다.\(SHOULD\)

STOP\_SENDING 프레임을 보낸 후 수신된 STREAM 프레임은 수신 시 폐기될 수 있지만 여전히 연결 및 스트림 흐름 제어에 포함됩니다.

STOP\_SENDING 프레임은 수신 엔드포인트가 RESET\_STREAM 프레임을 보내도록 요청합니다. STOP\_SENDING 프레임을 수신하는 끝점은 스트림이 "준비" 또는 "전송" 상태인 경우 RESET\_STREAM 프레임을 보내야 합니다. 스트림이 "데이터 전송됨" 상태인 경우 엔드포인트는 미해결 데이터를 포함하는 패킷이 확인되거나 손실되었다고 선언될 때까지 RESET\_STREAM 프레임 전송을 연기할 수 있습니다\(MAY\). 처리되지 않은 데이터가 손실되었다고 선언되면 엔드포인트는 데이터를 재전송하는 대신 RESET\_STREAM 프레임을 보내야 합니다\(SHOULD\).\(MUST, MAY, SHOULD\)

엔드포인트는 STOP\_SENDING 프레임의 오류 코드를 자신이 보내는 RESET\_STREAM 프레임으로 복사해야 하지만 모든 애플리케이션 오류 코드를 사용할 수 있습니다. STOP\_SENDING 프레임을 보내는 엔드포인트는 해당 스트림에 대해 이후에 수신되는 모든 RESET\_STREAM 프레임의 오류 코드를 무시할 수 있습니다\(MAY\).\(SHOULD, MAY\)

STOP\_SENDING은 피어에 의해 재설정되지 않은 스트림에 대해서만 전송되어야 합니다. STOP\_SENDING은 "Recv" 또는 "Size Known" 상태의 스트림에 가장 유용합니다.\(SHOULD\)

종단점은 이전 STOP\_SENDING을 포함하는 패킷이 손실된 경우 다른 STOP\_SENDING 프레임을 보낼 것으로 예상됩니다. 그러나 스트림에 대한 모든 스트림 데이터 또는 RESET\_STREAM 프레임이 수신되면 즉, 스트림이 "Recv" 또는 "Size Known" 이외의 상태에 있으면 STOP\_SENDING 프레임을 보낼 필요가 없습니다.

양방향 스트림의 양방향을 종료하려는 엔드포인트는 RESET\_STREAM 프레임을 전송하여 한 방향을 종료할 수 있으며 반대 방향으로 STOP\_SENDING 프레임을 전송하여 프롬프트 종료를 권장할 수 있습니다.

---
## **4.  Flow Control**

수신자는 버퍼링해야 하는 데이터의 양을 제한하여 빠른 발신자가 수신자를 압도하거나 악의적인 발신자가 많은 양의 메모리를 소비하지 않도록 해야 합니다. 수신기가 연결에 대한 메모리 커밋을 제한할 수 있도록 스트림 흐름은 개별적으로 그리고 연결 전체에서 전체적으로 제어됩니다. QUIC 수신자는 4.1절과 4.2절에 설명된 대로 발신자가 스트림과 모든 스트림에서 언제든지 보낼 수 있는 최대 데이터 양을 제어합니다.

마찬가지로 연결 내에서 동시성을 제한하기 위해 QUIC 끝점은 섹션 4.6에 설명된 대로 피어가 시작할 수 있는 최대 누적 스트림 수를 제어합니다.

CRYPTO 프레임으로 전송된 데이터는 스트림 데이터와 같은 방식으로 흐름 제어되지 않습니다. QUIC은 과도한 데이터 버퍼링을 방지하기 위해 암호화 프로토콜 구현에 의존합니다. \[QUIC-TLS\]를 참조하십시오. 여러 계층에서 과도한 버퍼링을 피하기 위해 QUIC 구현은 버퍼링 제한을 전달하기 위해 암호화 프로토콜 구현을 위한 인터페이스를 제공해야 합니다\(SHOULD\).\(SHOULD\)

---
### **4.1.  Data Flow Control**

QUIC는 수신자가 주어진 스트림 또는 전체 연결에 대해 수신할 준비가 된 총 바이트의 제한을 알리는 제한 기반 흐름 제어 체계를 사용합니다. 이는 QUIC에서 두 가지 수준의 데이터 흐름 제어로 이어집니다.

\* 스트림 흐름 제어: 각 스트림에서 보낼 수 있는 데이터의 양을 제한하여 단일 스트림이 연결에 대한 전체 수신 버퍼를 소비하지 않도록 합니다.

\* 연결 흐름 제어 - 모든 스트림의 STREAM 프레임에서 전송되는 스트림 데이터의 총 바이트를 제한하여 연결에 대한 발신자가 수신자의 버퍼 용량을 초과하지 않도록 합니다.

발신자는 한도를 초과하여 데이터를 보내면 안 됩니다.\(MUST NOT\)

수신기는 핸드셰이크 동안 전송 매개변수를 통해 모든 스트림에 대한 초기 제한을 설정합니다\(섹션 7.4\). 그 후 수신자는 MAX\_STREAM\_DATA 프레임\(19.10절\) 또는 MAX\_DATA 프레임\(19.9절\)을 발신자에게 보내 더 큰 제한을 알립니다.

수신자는 해당 스트림 ID와 함께 MAX\_STREAM\_DATA 프레임을 전송하여 스트림에 대해 더 큰 제한을 알릴 수 있습니다. MAX\_STREAM\_DATA 프레임은 스트림의 최대 절대 바이트 오프셋을 나타냅니다. 수신기는 해당 스트림에서 소비된 데이터의 현재 오프셋을 기반으로 광고할 흐름 제어 오프셋을 결정할 수 있습니다.

수신기는 모든 스트림의 절대 바이트 오프셋 합계의 최대값을 나타내는 MAX\_DATA 프레임을 전송하여 연결에 대한 더 큰 제한을 알릴 수 있습니다. 수신자는 모든 스트림에서 수신된 바이트의 누적 합계를 유지하며, 이는 알려진 연결 또는 스트림 데이터 제한 위반을 확인하는 데 사용됩니다. 수신기는 모든 스트림에서 소비된 바이트의 합계를 기준으로 광고할 최대 데이터 제한을 결정할 수 있습니다.

수신자가 연결 또는 스트림에 대한 제한을 알리면 더 작은 제한을 알리는 것은 오류가 아니지만 더 작은 제한은 효과가 없습니다.

발신자가 알려진 연결 또는 스트림 데이터 제한을 위반하는 경우 수신자는 FLOW\_CONTROL\_ERROR 유형의 오류로 연결을 닫아야 합니다. 오류 처리에 대한 자세한 내용은 섹션 11을 참조하십시오.\(MUST\)

발신자는 흐름 제어 제한을 증가시키지 않는 MAX\_STREAM\_DATA 또는 MAX\_DATA 프레임을 무시해야 합니다.\(MUST\)

보낸 사람이 한도까지 데이터를 보낸 경우 새 데이터를 보낼 수 없으며 차단된 것으로 간주됩니다. 송신자는 STREAM\_DATA\_BLOCKED 또는 DATA\_BLOCKED 프레임을 보내어 쓸 데이터가 있지만 흐름 제어 제한에 의해 차단되었음을 수신자에게 표시해야 합니다\(SHOULD\). 보낸 사람이 유휴 시간 제한\(10.1절\)보다 긴 기간 동안 차단되면 보낸 사람이 전송할 수 있는 데이터를 가지고 있더라도 받는 사람이 연결을 닫을 수 있습니다. 연결이 닫히지 않도록 하려면 흐름 제어가 제한된 발신자는 전송 중인 ack-eliciting 패킷이 없을 때 STREAM\_DATA\_BLOCKED 또는 DATA\_BLOCKED 프레임을 주기적으로 보내야 합니다\(SHOULD\).\(SHOULD, SHOULD\)

---
### **4.2.  Increasing Flow Control Limits**

구현은 MAX\_STREAM\_DATA 및 MAX\_DATA 프레임에서 언제 얼마나 많은 크레딧을 광고할 것인지 결정하지만 이 섹션에서는 몇 가지 고려 사항을 제공합니다.

발신자를 차단하지 않기 위해 수신자는 왕복 내에서 MAX\_STREAM\_DATA 또는 MAX\_DATA 프레임을 여러 번 보내거나 프레임 손실 및 후속 복구를 위한 시간을 허용하기에 충분히 일찍 보낼 수 있습니다\(MAY\).\(MAY\)

제어 프레임은 연결 오버헤드에 기여합니다. 따라서 변경 사항이 적은 MAX\_STREAM\_DATA 및 MAX\_DATA 프레임을 자주 보내는 것은 바람직하지 않습니다. 반면에 업데이트 빈도가 낮은 경우 발신자를 차단하지 않으려면 한도를 더 크게 증분해야 하므로 수신자에게 더 많은 리소스를 투입해야 합니다. 한도를 알리는 정도를 결정할 때 리소스 약정과 오버헤드 사이에는 상충 관계가 있습니다.

수신기는 자동 튜닝 메커니즘을 사용하여 일반적인 TCP 구현과 유사하게 왕복 시간 추정치 및 수신 애플리케이션이 데이터를 소비하는 속도를 기반으로 광고되는 추가 크레딧의 빈도와 양을 조정할 수 있습니다. 최적화로서 엔드포인트는 보낼 다른 프레임이 있을 때만 흐름 제어와 관련된 프레임을 보낼 수 있으므로 흐름 제어로 인해 추가 패킷이 전송되지 않도록 합니다.

차단된 발신자는 STREAM\_DATA\_BLOCKED 또는 DATA\_BLOCKED 프레임을 보낼 필요가 없습니다. 따라서 수신기는 MAX\_STREAM\_DATA 또는 MAX\_DATA 프레임을 보내기 전에 STREAM\_DATA\_BLOCKED 또는 DATA\_BLOCKED 프레임을 기다리면 안 됩니다. 그렇게 하면 발신자가 나머지 연결 동안 차단될 수 있습니다. 발신자가 이러한 프레임을 보내더라도 이를 기다리면 발신자가 적어도 전체 왕복 동안 차단됩니다.\(MUST NOT\)

보낸 사람이 차단된 후 크레딧을 받으면 응답으로 많은 양의 데이터를 보낼 수 있으므로 단기간의 정체가 발생할 수 있습니다. 발신자가 이러한 혼잡을 피할 수 있는 방법에 대한 논의는 \[빠른 복구\]의 섹션 7.7을 참조하십시오.

---
### **4.3.  Flow Control Performance**

엔드포인트가 해당 피어가 이 연결에서 피어의 대역폭 지연 곱보다 큰 사용 가능한 흐름 제어 크레딧을 항상 가지고 있는지 확인할 수 없는 경우 수신 처리량은 흐름 제어에 의해 제한됩니다.

패킷 손실은 수신 버퍼에 간격을 발생시켜 응용 프로그램이 데이터를 소비하지 못하게 하고 수신 버퍼 공간을 확보할 수 있습니다.

흐름 제어 한계를 적시에 업데이트하면 성능을 향상시킬 수 있습니다. 흐름 제어 업데이트를 제공하기 위해서만 패킷을 전송하면 네트워크 부하가 증가하고 성능이 저하될 수 있습니다. ACK 프레임과 같은 다른 프레임과 함께 흐름 제어 업데이트를 보내면 해당 업데이트 비용이 줄어듭니다.

---
### **4.4.  Handling Stream Cancellation**

엔드포인트는 연결 수준 흐름 제어를 위한 모든 바이트를 설명할 수 있도록 모든 스트림에서 소비된 흐름 제어 크레딧의 양에 결국 동의해야 합니다.

RESET\_STREAM 프레임을 수신하면 엔드포인트는 일치하는 스트림의 상태를 해제하고 해당 스트림에 도착하는 추가 데이터를 무시합니다.

RESET\_STREAM은 스트림의 한 방향을 갑자기 종료합니다. 양방향 스트림의 경우 RESET\_STREAM은 반대 방향의 데이터 흐름에 영향을 주지 않습니다. 양쪽 엔드포인트는 해당 방향이 종료 상태에 들어갈 때까지 종료되지 않은 방향으로 스트림에 대한 흐름 제어 상태를 유지해야 합니다\(MUST\).\(MUST\)

---
### **4.5.  Stream Final Size**

최종 크기는 스트림에서 사용하는 흐름 제어 크레딧의 양입니다. 스트림의 모든 연속 바이트가 한 번 전송되었다고 가정하면 최종 크기는 전송된 바이트 수입니다. 보다 일반적으로 이것은 스트림에서 전송된 최대 오프셋이 있는 바이트의 오프셋보다 1 높거나 바이트가 전송되지 않은 경우 0입니다.

송신자는 스트림이 종료되는 방법에 관계없이 항상 스트림의 최종 크기를 수신자에게 안정적으로 전달합니다. 최종 크기는 FIN 플래그가 있는 STREAM 프레임의 오프셋 및 길이 필드의 합입니다. 이러한 필드는 암시적일 수 있습니다. 또는 RESET\_STREAM 프레임의 최종 크기 필드가 이 값을 전달합니다. 이렇게 하면 두 엔드포인트가 해당 스트림에서 발신자가 얼마나 많은 흐름 제어 크레딧을 소비했는지에 대해 동의합니다.

엔드포인트는 스트림의 수신 부분이 "알려진 크기" 또는 "수신 재설정" 상태\(섹션 3\)에 들어갈 때 스트림의 최종 크기를 알게 됩니다. 수신자는 연결 수준 흐름 컨트롤러의 스트림에서 전송된 모든 바이트를 설명하기 위해 스트림의 최종 크기를 사용해야 합니다.\(MUST\)

끝점은 최종 크기 또는 그 이상으로 스트림의 데이터를 보내면 안 됩니다\(MUST NOT\).\(MUST NOT\)

스트림의 최종 크기가 알려지면 변경할 수 없습니다. 스트림의 최종 크기 변경을 나타내는 RESET\_STREAM 또는 STREAM 프레임이 수신되면 엔드포인트는 FINAL\_SIZE\_ERROR 유형의 오류로 응답해야 합니다\(SHOULD\). 오류 처리에 대한 자세한 내용은 섹션 11을 참조하십시오. 수신기는 스트림이 닫힌 후에도 최종 크기 이상의 데이터 수신을 FINAL\_SIZE\_ERROR 유형의 오류로 처리해야 합니다\(SHOULD\). 엔드포인트가 이러한 오류를 생성하도록 요구하는 것은 엔드포인트가 닫힌 스트림에 대한 최종 크기 상태를 유지해야 함을 의미하기 때문에 이러한 오류를 생성하는 것은 필수 사항이 아닙니다. 이는 상당한 상태 약정을 의미할 수 있습니다.\(SHOULD, SHOULD\)

---
### **4.6.  Controlling Concurrency**

끝점은 피어가 열 수 있는 수신 스트림의 누적 수를 제한합니다. 스트림 ID가 "\(max\_streams \* 4 + first\_stream\_id\_of\_type\)" 미만인 스트림만 열 수 있습니다. 표 1 참조. 초기 제한은 전송 매개변수에 설정됩니다. 섹션 18.2를 참조하십시오. 후속 제한은 MAX\_STREAMS 프레임을 사용하여 알려집니다. 섹션 19.11을 참조하십시오. 단방향 및 양방향 스트림에는 별도의 제한이 적용됩니다.

max\_streams 전송 매개변수 또는 MAX\_STREAMS 프레임이 2^60보다 큰 값으로 수신되면 가변 길이 정수로 표현할 수 없는 최대 스트림 ID가 허용됩니다. 섹션 16 참조. 둘 중 하나가 수신되면 잘못된 값이 전송 매개변수에서 수신된 경우 TRANSPORT\_PARAMETER\_ERROR 유형의 연결 오류와 함께 연결이 즉시 닫혀야 하고 프레임에서 수신된 경우 FRAME\_ENCODING\_ERROR 유형의 연결 오류가 발생해야 합니다. 섹션 10.2를 참조하십시오.\(MUST\)

엔드포인트는 피어가 설정한 제한을 초과해서는 안 됩니다. 전송한 제한을 초과하는 스트림 ID를 가진 프레임을 수신하는 끝점은 이를 STREAM\_LIMIT\_ERROR 유형의 연결 오류로 처리해야 합니다. 오류 처리에 대한 자세한 내용은 섹션 11을 참조하십시오.\(MUST NOT, MUST\)

수신자가 MAX\_STREAMS 프레임을 사용하여 스트림 제한을 알리면 더 작은 제한을 알리는 것은 효과가 없습니다. 스트림 제한을 늘리지 않는 MAX\_STREAMS 프레임은 무시해야 합니다\(MUST\).\(MUST\)

스트림 및 연결 흐름 제어와 마찬가지로 이 문서는 MAX\_STREAMS를 통해 피어에 알려야 하는 스트림 수와 시기를 결정하는 구현을 남겨 둡니다. 구현은 피어가 사용할 수 있는 스트림의 수를 거의 일정하게 유지하기 위해 스트림이 닫힐 때 제한을 늘리도록 선택할 수 있습니다.

피어의 제한으로 인해 새 스트림을 열 수 없는 엔드포인트는 STREAMS\_BLOCKED 프레임\(섹션 19.14\)을 보내야 합니다\(SHOULD\). 이 신호는 디버깅에 유용한 것으로 간주됩니다. 엔드포인트는 추가 크레딧을 광고하기 전에 이 신호를 수신하기 위해 대기해서는 안 됩니다\(MUST NOT\). 그렇게 하면 피어가 적어도 전체 왕복 동안 차단되고 잠재적으로 피어가 STREAMS\_BLOCKED 프레임을 보내지 않기로 선택하는 경우 무기한 차단됨을 의미하기 때문입니다.\(SHOULD, MUST NOT\)

---
## **5.  Connections**

QUIC 연결은 클라이언트와 서버 간의 공유 상태입니다.

각 연결은 핸드셰이크 단계로 시작하며, 이 단계 동안 두 엔드포인트는 암호화 핸드셰이크 프로토콜\[QUIC-TLS\]을 사용하여 공유 비밀을 설정하고 애플리케이션 프로토콜을 협상합니다. 핸드셰이크\(섹션 7\)는 두 엔드포인트가 통신할 의향이 있음을 확인하고\(섹션 8.1\) 연결 매개 변수를 설정합니다\(섹션 7.4\).

애플리케이션 프로토콜은 몇 가지 제한 사항이 있는 핸드셰이크 단계 중에 연결을 사용할 수 있습니다. 0-RTT를 사용하면 서버에서 응답을 받기 전에 클라이언트가 애플리케이션 데이터를 보낼 수 있습니다. 그러나 0-RTT는 재생 공격에 대한 보호 기능을 제공하지 않습니다. \[QUIC-TLS\]의 섹션 9.2를 참조하십시오. 또한 서버는 클라이언트의 신원과 활동성을 확인할 수 있는 최종 암호화 핸드셰이크 메시지를 수신하기 전에 애플리케이션 데이터를 클라이언트에 보낼 수 있습니다. 이러한 기능을 통해 애플리케이션 프로토콜은 대기 시간 감소를 위해 일부 보안 보장을 거래하는 옵션을 제공할 수 있습니다.

연결 ID\(섹션 5.1\)를 사용하면 연결을 새 네트워크 경로로 마이그레이션할 수 있습니다. 엔드포인트를 직접 선택하거나 미들박스의 변경으로 인해 강제로 연결될 때 모두 가능합니다. 섹션 9에서는 마이그레이션과 관련된 보안 및 개인 정보 보호 문제에 대한 완화 조치를 설명합니다.

더 이상 필요하지 않거나 원하지 않는 연결의 경우 섹션 10에 설명된 대로 클라이언트와 서버가 연결을 종료하는 몇 가지 방법이 있습니다.

---
### **5.1.  Connection ID**

각 연결에는 각각 연결을 식별할 수 있는 연결 식별자 또는 연결 ID 집합이 있습니다. 연결 ID는 끝점에서 독립적으로 선택됩니다. 각 엔드포인트는 해당 피어가 사용하는 연결 ID를 선택합니다.

연결 ID의 주요 기능은 하위 프로토콜 계층\(UDP, IP\)의 주소 지정 변경으로 인해 QUIC 연결에 대한 패킷이 잘못된 엔드포인트로 전달되지 않도록 하는 것입니다. 각 엔드포인트는 해당 연결 ID가 있는 패킷을 엔드포인트로 다시 라우팅하고 수신 시 엔드포인트에서 식별할 수 있도록 하는 구현별\(또는 배포별\) 방법을 사용하여 연결 ID를 선택합니다.

엔드포인트가 엔드포인트의 협력 없이 동일한 연결에 대한 것으로 관찰자가 식별할 수 없는 패킷을 보낼 수 있도록 여러 연결 ID가 사용됩니다. 섹션 9.5를 참조하십시오.

연결 ID에는 동일한 연결에 대한 다른 연결 ID와 연결하기 위해 외부 관찰자\(즉, 발급자와 협력하지 않는 관찰자\)가 사용할 수 있는 정보가 포함되어서는 안 됩니다\(MUST NOT\). 간단한 예로, 이는 동일한 연결에서 동일한 연결 ID가 두 번 이상 발행되어서는 안 된다는 것을 의미합니다.\(MUST NOT, MUST NOT\)

헤더가 긴 패킷에는 소스 연결 ID 및 대상 연결 ID 필드가 포함됩니다. 이 필드는 새 연결에 대한 연결 ID를 설정하는 데 사용됩니다. 자세한 내용은 섹션 7.2를 참조하십시오.

짧은 헤더가 있는 패킷\(17.3절\)은 대상 연결 ID만 포함하고 명시적인 길이는 생략합니다. 대상 연결 ID 필드의 길이는 엔드포인트에 알려질 것으로 예상됩니다. 연결 ID를 기반으로 라우팅하는 로드 밸런서를 사용하는 엔드포인트는 연결 ID의 고정 길이에 대해 로드 밸런서와 동의하거나 인코딩 체계에 동의할 수 있습니다. 고정된 부분은 명시적 길이를 인코딩할 수 있으므로 전체 연결 ID의 길이가 달라지고 로드 밸런서에서 계속 사용할 수 있습니다.

버전 협상\(섹션 17.2.1\) 패킷은 클라이언트에 대한 올바른 라우팅을 보장하고 패킷이 클라이언트가 보낸 패킷에 대한 응답임을 입증하기 위해 클라이언트가 선택한 연결 ID를 반향합니다.

길이가 0인 연결 ID는 올바른 끝점으로 라우팅하는 데 연결 ID가 필요하지 않은 경우에 사용할 수 있습니다. 그러나 길이가 0인 연결 ID를 사용하는 동안 동일한 로컬 IP 주소 및 포트에서 연결을 다중화하면 피어 연결 마이그레이션, NAT 리바인딩 및 클라이언트 포트 재사용이 있는 경우 실패가 발생합니다. 엔드포인트는 길이가 0인 연결 ID가 있는 여러 동시 연결에 동일한 IP 주소와 포트를 사용해서는 안 됩니다.\(MUST NOT\)

엔드포인트가 길이가 0이 아닌 연결 ID를 사용하는 경우 피어가 엔드포인트로 전송되는 패킷에 대해 선택할 연결 ID를 제공하는지 확인해야 합니다. 이러한 연결 ID는 NEW\_CONNECTION\_ID 프레임\(19.15절\)을 사용하여 엔드포인트에서 제공합니다.

---
#### **5.1.1.  Issuing Connection IDs**

각 연결 ID에는 NEW\_CONNECTION\_ID 또는 RETIRE\_CONNECTION\_ID 프레임이 동일한 값을 참조할 때 감지하는 데 도움이 되는 관련 시퀀스 번호가 있습니다. 엔드포인트에서 발급한 초기 연결 ID는 핸드셰이크 중에 긴 패킷 헤더\(17.2절\)의 소스 연결 ID 필드에서 전송됩니다. 초기 연결 ID의 시퀀스 번호는 0입니다. preferred\_address 전송 매개변수가 전송되면 제공된 연결 ID의 시퀀스 번호는 1입니다.

추가 연결 ID는 NEW\_CONNECTION\_ID 프레임\(섹션 19.15\)을 사용하여 피어와 통신합니다. 새로 발급된 각 연결 ID의 시퀀스 번호는 1씩 증가해야 합니다. 클라이언트가 보내는 첫 번째 대상 연결 ID 필드에 대해 선택하는 연결 ID와 재시도 패킷에서 제공하는 모든 연결 ID에는 할당된 시퀀스 번호가 없습니다.\(MUST\)

엔드포인트가 연결 ID를 발급하면 연결 기간 동안 또는 해당 피어가 RETIRE\_CONNECTION\_ID 프레임\(섹션 19.16\)을 통해 연결 ID를 무효화할 때까지 이 연결 ID를 전달하는 패킷을 수락해야 합니다. 발급되었지만 폐기되지 않은 연결 ID는 활성 상태로 간주됩니다. 모든 활성 연결 ID는 모든 패킷 유형에서 언제든지 현재 연결과 함께 사용할 수 있습니다. 여기에는 preferred\_address 전송 매개변수를 통해 서버에서 발급한 연결 ID가 포함됩니다.\(MUST\)

엔드포인트는 피어가 충분한 수의 사용 가능하고 사용하지 않는 연결 ID를 가지고 있는지 확인해야 합니다\(SHOULD\). 엔드포인트는 active\_connection\_id\_limit 전송 매개변수를 사용하여 유지하려는 활성 연결 ID의 수를 알립니다. 끝점은 피어의 제한보다 더 많은 연결 ID를 제공하면 안 됩니다\(MUST NOT\). 엔드포인트는 NEW\_CONNECTION\_ID 프레임이 Retire Prior To 필드에 충분히 큰 값을 포함하여 초과분을 폐기해야 하는 경우 피어의 제한을 일시적으로 초과하는 연결 ID를 보낼 수 있습니다.\(SHOULD, MUST NOT, MAY\)

NEW\_CONNECTION\_ID 프레임으로 인해 끝점이 일부 활성 연결 ID를 추가하고 Retire Prior To 필드의 값에 따라 다른 연결 ID를 폐기할 수 있습니다. NEW\_CONNECTION\_ID 프레임을 처리하고 활성 연결 ID를 추가 및 폐기한 후 활성 연결 ID의 수가 active\_connection\_id\_limit 전송 매개변수에 광고된 값을 초과하는 경우 엔드포인트는 CONNECTION\_ID\_LIMIT\_ERROR 유형의 오류로 연결을 닫아야 합니다.\(MUST\)

엔드포인트는 피어가 연결 ID를 폐기할 때 새 연결 ID를 제공해야 합니다\(SHOULD\). 엔드포인트가 피어의 active\_connection\_id\_limit보다 적은 연결 ID를 제공한 경우 이전에 사용하지 않은 연결 ID가 있는 패킷을 수신할 때 새 연결 ID를 제공할 수 있습니다\(MAY\). 끝점은 연결 ID가 부족할 위험을 피하기 위해 각 연결에 대해 발급된 연결 ID의 총 수를 제한할 수 있습니다\(MAY\). 섹션 10.3.2를 참조하십시오. 끝점은 또한 피어가 발급된 연결 ID가 있는 만큼 많은 경로를 통해 엔드포인트와 상호 작용할 수 있으므로 경로 유효성 검사 상태와 같이 유지 관리하는 경로당 상태의 양을 줄이기 위해 연결 ID 발급을 제한할 수 있습니다\(MAY\).\(SHOULD, MAY, MAY, MAY\)

마이그레이션을 시작하고 길이가 0이 아닌 연결 ID가 필요한 엔드포인트는 해당 피어가 사용할 수 있는 연결 ID 풀이 마이그레이션 시 피어가 새 연결 ID를 사용할 수 있도록 해야 합니다. 탈진한.\(SHOULD\)

핸드셰이크 중에 길이가 0인 연결 ID를 선택하는 엔드포인트는 새 연결 ID를 발급할 수 없습니다. 길이가 0인 대상 연결 ID 필드는 모든 네트워크 경로를 통해 이러한 끝점으로 전송되는 모든 패킷에 사용됩니다.

---
#### **5.1.2.  Consuming and Retiring Connection IDs**

엔드포인트는 피어에 사용하는 연결 ID를 연결 중에 언제든지 사용 가능한 다른 ID로 변경할 수 있습니다. 엔드포인트는 마이그레이션하는 피어에 대한 응답으로 연결 ID를 사용합니다. 자세한 내용은 섹션 9.5를 참조하십시오.

끝점은 패킷을 보낼 때 사용할 수 있는 피어에서 받은 연결 ID 집합을 유지 관리합니다. 끝점이 사용에서 연결 ID를 제거하려는 경우 RETIRE\_CONNECTION\_ID 프레임을 해당 피어로 보냅니다. RETIRE\_CONNECTION\_ID 프레임을 보내는 것은 연결 ID가 다시 사용되지 않음을 나타내며 피어가 NEW\_CONNECTION\_ID 프레임을 사용하여 새 연결 ID로 교체하도록 요청합니다.

섹션 9.5에서 설명한 것처럼 끝점은 연결 ID의 사용을 단일 로컬 주소에서 단일 대상 주소로 보내는 패킷으로 제한합니다. 엔드포인트는 연결 ID가 사용된 로컬 또는 대상 주소를 더 이상 적극적으로 사용하지 않을 때 연결 ID를 폐기해야 합니다\(SHOULD\).\(SHOULD\)

엔드포인트는 특정 상황에서 이전에 발급된 연결 ID 수락을 중지해야 할 수 있습니다. 이러한 엔드포인트는 Retire Prior To 필드가 증가된 NEW\_CONNECTION\_ID 프레임을 전송하여 해당 피어가 연결 ID를 폐기하도록 할 수 있습니다. 엔드포인트는 피어가 폐기할 때까지 이전에 발급된 연결 ID를 계속 수락해야 합니다\(SHOULD\). 엔드포인트가 표시된 연결 ID를 더 이상 처리할 수 없는 경우 연결을 닫을 수 있습니다\(MAY\).\(SHOULD, MAY\)

증가된 Retire Prior To 필드를 수신하면 피어는 해당 연결 ID 사용을 중지하고 새로 제공된 연결 ID를 활성 연결 ID 세트에 추가하기 전에 RETIRE\_CONNECTION\_ID 프레임으로 사용을 중지해야 합니다. 이 순서를 사용하면 피어가 사용 가능한 연결 ID를 갖지 않고 피어가 active\_connection\_id\_limit 전송 매개변수에 설정한 제한을 초과하지 않고 엔드포인트가 모든 활성 연결 ID를 교체할 수 있습니다. 섹션 18.2를 참조하십시오. 요청 시 연결 ID 사용을 중단하지 않으면 발급 엔드포인트가 활성 연결이 있는 연결 ID를 계속 사용하지 못할 수 있으므로 연결 실패가 발생할 수 있습니다.\(MUST\)

엔드포인트는 RETIRE\_CONNECTION\_ID 프레임이 아직 승인되지 않은 로컬에서 폐기된 연결 ID의 수를 제한해야 합니다\(SHOULD\). 엔드포인트는 active\_connection\_id\_limit 전송 매개변수 값의 최소 두 배에 해당하는 다수의 RETIRE\_CONNECTION\_ID 프레임을 전송 및 추적할 수 있도록 허용해야 합니다\(SHOULD\). 엔드포인트는 종료하지 않고 연결 ID를 잊어서는 안 됩니다\(MUST NOT\). 이 제한을 초과하는 종료가 필요한 연결 ID가 있는 경우 CONNECTION\_ID\_LIMIT\_ERROR 유형의 연결 오류로 처리하도록 선택할 수 있습니다.\(SHOULD, SHOULD, MUST NOT\)

엔드포인트는 이전 Retire Prior To 값으로 표시된 모든 연결 ID를 폐기하는 RETIRE\_CONNECTION\_ID 프레임을 수신하기 전에 Retire Prior To 필드의 업데이트를 발행해서는 안 됩니다\(SHOULD NOT\).\(SHOULD NOT\)

---
### **5.2.  Matching Packets to Connections**

들어오는 패킷은 수신 시 분류됩니다. 패킷은 기존 연결과 연결되거나 서버의 경우 잠재적으로 새 연결을 생성할 수 있습니다.

끝점은 패킷을 기존 연결과 연결하려고 시도합니다. 패킷에 기존 연결에 해당하는 길이가 0이 아닌 대상 연결 ID가 있는 경우 QUIC는 그에 따라 해당 패킷을 처리합니다. 둘 이상의 연결 ID가 연결과 연결될 수 있습니다. 섹션 5.1을 참조하십시오.

대상 연결 ID의 길이가 0이고 패킷의 주소 지정 정보가 끝점이 길이가 0인 연결 ID가 있는 연결을 식별하는 데 사용하는 주소 지정 정보와 일치하는 경우 QUIC은 패킷을 해당 연결의 일부로 처리합니다. 엔드포인트는 식별을 위해 대상 IP 및 포트만 사용하거나 소스 및 대상 주소를 모두 사용할 수 있지만 이로 인해 섹션 5.1에 설명된 대로 연결이 취약해집니다.

엔드포인트는 기존 연결에 기인할 수 없는 모든 패킷에 대해 상태 비저장 재설정\(섹션 10.3\)을 보낼 수 있습니다. 상태 비저장 재설정을 사용하면 연결을 사용할 수 없게 될 때 피어가 더 빠르게 식별할 수 있습니다.

패킷이 해당 연결 상태와 일치하지 않으면 기존 연결과 일치하는 패킷이 삭제됩니다. 예를 들어 패킷이 연결 버전과 다른 프로토콜 버전을 나타내거나 예상 키를 사용할 수 있을 때 패킷 보호 제거에 실패하면 패킷이 삭제됩니다.

초기, 재시도 또는 버전 협상과 같은 강력한 무결성 보호가 부족한 잘못된 패킷은 폐기될 수 있습니다\(MAY\). 엔드포인트는 오류를 발견하기 전에 이러한 패킷의 내용을 처리하는 경우 연결 오류를 생성하거나 해당 처리 중에 변경된 사항을 완전히 되돌려야 합니다.\(MAY, MUST\)

---
#### **5.2.1.  Client Packet Handling**

클라이언트로 전송되는 유효한 패킷에는 항상 클라이언트가 선택한 값과 일치하는 대상 연결 ID가 포함됩니다. 길이가 0인 연결 ID를 수신하도록 선택한 클라이언트는 로컬 주소와 포트를 사용하여 연결을 식별할 수 있습니다. 대상 연결 ID 또는 이 값의 길이가 0인 경우 로컬 IP 주소 및 포트를 기반으로 하는 기존 연결과 일치하지 않는 패킷은 삭제됩니다.

패킷 재정렬 또는 손실로 인해 클라이언트는 아직 계산하지 않은 키로 암호화된 연결에 대한 패킷을 수신할 수 있습니다. 클라이언트는 이러한 패킷을 삭제하거나 키 계산을 허용하는 이후 패킷을 예상하여 버퍼링할 수 있습니다.\(MAY\)

클라이언트가 초기에 선택한 것과 다른 버전을 사용하는 패킷을 수신하는 경우 해당 패킷을 폐기해야 합니다.\(MUST\)

---
#### **5.2.2.  Server Packet Handling**

서버가 지원되지 않는 버전을 나타내는 패킷을 수신하고 패킷이 지원되는 버전에 대한 새 연결을 시작할 만큼 충분히 큰 경우 서버는 섹션 6.1에 설명된 대로 버전 협상 패킷을 보내야 합니다\(SHOULD\). 서버는 버전 협상 패킷으로 응답하는 패킷 수를 제한할 수 있습니다. 서버는 지원되지 않는 버전을 지정하는 더 작은 패킷을 삭제해야 합니다.\(SHOULD, MAY, MUST\)

지원되지 않는 버전의 첫 번째 패킷은 버전별 필드에 대해 다른 의미 체계 및 인코딩을 사용할 수 있습니다. 특히 버전마다 다른 패킷 보호 키가 사용될 수 있습니다. 특정 버전을 지원하지 않는 서버는 패킷의 페이로드를 해독하거나 결과를 적절하게 해석할 수 없을 것입니다. 서버는 데이터그램이 충분히 긴 경우 버전 협상 패킷으로 응답해야 합니다\(SHOULD\).\(SHOULD\)

지원되는 버전이 있거나 버전 필드가 없는 패킷은 연결 ID 또는 길이가 0인 연결 ID가 있는 패킷의 경우 로컬 주소 및 포트를 사용하여 연결과 일치합니다. 이러한 패킷은 선택한 연결을 사용하여 처리됩니다. 그렇지 않으면 아래 설명된 대로 서버가 계속됩니다.

패킷이 사양을 완전히 준수하는 초기 패킷인 경우 서버는 핸드셰이크를 진행합니다\(섹션 7\). 이렇게 하면 클라이언트가 선택한 버전으로 서버가 커밋됩니다.

서버가 새 연결 수락을 거부하면 오류 코드 CONNECTION\_REFUSED와 함께 CONNECTION\_CLOSE 프레임이 포함된 초기 패킷을 보내야 합니다\(SHOULD\).\(SHOULD\)

패킷이 0-RTT 패킷인 경우 서버는 늦게 도착하는 초기 패킷을 예상하여 제한된 수의 이러한 패킷을 버퍼링할 수 있습니다\(MAY\). 클라이언트는 서버 응답을 받기 전에 핸드셰이크 패킷을 보낼 수 없으므로 서버는 그러한 패킷을 무시해야 합니다.\(MAY, SHOULD\)

서버는 다른 모든 상황에서 들어오는 패킷을 삭제해야 합니다.\(MUST\)

---
#### **5.2.3.  Considerations for Simple Load Balancers**

서버 배포는 원본 및 대상 IP 주소와 포트만 사용하여 서버 간에 부하를 분산할 수 있습니다. 클라이언트의 IP 주소 또는 포트를 변경하면 패킷이 잘못된 서버로 전달될 수 있습니다. 이러한 서버 배포는 클라이언트의 주소가 변경될 때 연결 연속성을 위해 다음 방법 중 하나를 사용할 수 있습니다.

\* 서버는 대역 외 메커니즘을 사용하여 연결 ID를 기반으로 올바른 서버로 패킷을 전달할 수 있습니다.

\* 서버가 클라이언트가 처음에 연결한 것 이외의 전용 서버 IP 주소 또는 포트를 사용할 수 있는 경우 preferred\_address 전송 매개변수를 사용하여 클라이언트가 해당 전용 주소로 연결을 이동하도록 요청할 수 있습니다. 클라이언트는 기본 주소를 사용하지 않도록 선택할 수 있습니다.

클라이언트 주소가 변경될 때 연결 연속성을 유지하기 위한 솔루션을 구현하지 않는 배치의 서버는 disable\_active\_migration 전송 매개변수를 사용하여 마이그레이션이 지원되지 않음을 나타내야 합니다\(SHOULD\). disable\_active\_migration 전송 매개변수는 클라이언트가 preferred\_address 전송 매개변수에 대해 작업을 수행한 후 연결 마이그레이션을 금지하지 않습니다.\(SHOULD\)

이 단순한 형태의 로드 밸런싱을 사용하는 서버 배치는 상태 비저장 재설정 오라클의 생성을 피해야 합니다. 섹션 21.11을 참조하십시오.\(MUST\)

---
### **5.3.  Operations on Connections**

이 문서는 QUIC용 API를 정의하지 않습니다. 대신 애플리케이션 프로토콜이 의존할 수 있는 QUIC 연결을 위한 기능 집합을 정의합니다. 애플리케이션 프로토콜은 QUIC 구현이 이 섹션에서 설명하는 작업을 포함하는 인터페이스를 제공한다고 가정할 수 있습니다. 특정 애플리케이션 프로토콜과 함께 사용하도록 설계된 구현은 해당 프로토콜에서 사용되는 작업만 제공할 수 있습니다.

클라이언트 역할을 구현할 때 애플리케이션 프로토콜은 다음을 수행할 수 있습니다.

```text
   *  open a connection, which begins the exchange described in
      Section 7;
```

\* 가능한 경우 초기 데이터를 활성화합니다. 그리고

\* 조기 데이터가 서버에 의해 승인 또는 거부되었을 때 알림을 받습니다.

서버 역할을 구현할 때 애플리케이션 프로토콜은 다음을 수행할 수 있습니다.

```text
   *  listen for incoming connections, which prepares for the exchange
      described in Section 7;
```

\* 초기 데이터가 지원되는 경우 클라이언트로 전송되는 TLS 재개 티켓에 애플리케이션 제어 데이터를 포함합니다. 그리고

\* Early Data가 지원되는 경우 클라이언트의 재개 티켓에서 애플리케이션 제어 데이터를 검색하고 해당 정보를 기반으로 Early Data를 수락하거나 거부합니다.

어떤 역할에서든 애플리케이션 프로토콜은 다음을 수행할 수 있습니다.

```text
   *  configure minimum values for the initial number of permitted
      streams of each type, as communicated in the transport parameters
      (Section 7.4);

   *  control resource allocation for receive buffers by setting flow
      control limits both for streams and for the connection;

   *  identify whether the handshake has completed successfully or is
      still ongoing;
```

\* PING 프레임을 생성하거나\(19.2절\) 유휴 시간 제한이 만료되기 전에 추가 프레임을 전송하도록 요청하여\(10.1절\) 연결이 자동으로 닫히지 않도록 합니다. 그리고

\* 연결을 즉시 닫습니다\(섹션 10.2\).

---
## **6.  Version Negotiation**

버전 협상을 통해 서버는 클라이언트가 사용한 버전을 지원하지 않음을 나타낼 수 있습니다. 서버는 새 연결을 시작할 수 있는 각 패킷에 대한 응답으로 버전 협상 패킷을 보냅니다. 자세한 내용은 섹션 5.2를 참조하십시오.

클라이언트가 보낸 첫 번째 패킷의 크기는 서버가 버전 협상 패킷을 보낼지 여부를 결정합니다. 여러 QUIC 버전을 지원하는 클라이언트는 필요에 따라 PADDING 프레임\(섹션 19.1\)을 사용하여 전송하는 첫 번째 UDP 데이터그램이 지원하는 모든 버전의 최소 데이터그램 크기 중 가장 큰 크기인지 확인해야 합니다\(SHOULD\). 이렇게 하면 상호 지원되는 버전이 있는 경우 서버가 응답합니다. 서버는 수신하는 데이터그램이 다른 버전에 지정된 최소 크기보다 작은 경우 버전 협상 패킷을 보내지 않을 수 있습니다. 섹션 14.1을 참조하십시오.\(SHOULD\)

---
### **6.1.  Sending Version Negotiation Packets**

클라이언트가 선택한 버전이 서버에서 허용되지 않는 경우 서버는 버전 협상 패킷으로 응답합니다. 섹션 17.2.1을 참조하십시오. 여기에는 서버가 승인할 버전 목록이 포함됩니다. 엔드포인트는 버전 협상 패킷 수신에 대한 응답으로 버전 협상 패킷을 보내서는 안 됩니다\(MUST NOT\).\(MUST NOT\)

이 시스템을 통해 서버는 상태를 유지하지 않고 지원되지 않는 버전의 패킷을 처리할 수 있습니다. 응답으로 전송된 초기 패킷 또는 버전 협상 패킷이 손실될 수 있지만 클라이언트는 응답을 성공적으로 수신하거나 연결 시도를 포기할 때까지 새 패킷을 전송합니다.

서버는 자신이 보내는 버전 협상 패킷의 수를 제한할 수 있습니다\(MAY\). 예를 들어, 패킷을 0-RTT로 인식할 수 있는 서버는 결국 초기 패킷을 수신할 것이라는 기대와 함께 0-RTT 패킷에 대한 응답으로 버전 협상 패킷을 보내지 않도록 선택할 수 있습니다.\(MAY\)

---
### **6.2.  Handling Version Negotiation Packets**

버전 협상 패킷은 QUIC가 연결에 사용할 QUIC 버전을 협상할 수 있도록 기능을 향후에 정의할 수 있도록 설계되었습니다. 향후 표준 추적 사양은 여러 버전의 QUIC를 지원하는 구현이 이 버전을 사용하여 연결을 설정하려는 시도에 대한 응답으로 받은 버전 협상 패킷에 반응하는 방식을 변경할 수 있습니다.

이 버전의 QUIC만 지원하는 클라이언트는 다음 두 가지 예외를 제외하고 버전 협상 패킷을 수신하는 경우 현재 연결 시도를 포기해야 합니다. 클라이언트는 이전 버전 협상 패킷을 포함하여 다른 패킷을 수신하고 성공적으로 처리한 경우 모든 버전 협상 패킷을 폐기해야 합니다. 클라이언트는 클라이언트가 선택한 QUIC 버전을 나열하는 버전 협상 패킷을 폐기해야 합니다.\(MUST, MUST, MUST\)

버전 협상을 수행하는 방법은 향후 Standards Track 사양에 정의된 향후 작업으로 남겨둡니다. 특히 향후 작업은 버전 다운그레이드 공격에 대한 견고성을 보장할 것입니다. 섹션 21.12를 참조하십시오.

---
### **6.3.  Using Reserved Versions**

향후 서버에서 새 버전을 사용하려면 클라이언트가 지원되지 않는 버전을 올바르게 처리해야 합니다. 일부 버전 번호\(섹션 15에 정의된 0x?a?a?a?a\)는 버전 번호가 포함된 필드에 포함되도록 예약되어 있습니다.

끝점은 피어가 값을 올바르게 무시하는지 테스트하기 위해 알 수 없거나 지원되지 않는 버전이 무시되는 모든 필드에 예약된 버전을 추가할 수 있습니다\(MAY\). 예를 들어 엔드포인트는 버전 협상 패킷에 예약된 버전을 포함할 수 있습니다. 섹션 17.2.1을 참조하십시오. 끝점은 피어가 패킷을 올바르게 삭제하는지 테스트하기 위해 예약된 버전의 패킷을 보낼 수 있습니다\(MAY\).\(MAY, MAY\)

---
## **7.  Cryptographic and Transport Handshake**

QUIC은 결합된 암호화 및 전송 핸드셰이크를 사용하여 연결 설정 대기 시간을 최소화합니다. QUIC은 CRYPTO 프레임\(19.6절\)을 사용하여 암호화 핸드셰이크를 전송합니다. 이 문서에 정의된 QUIC 버전은 0x00000001로 식별되며 \[QUIC-TLS\]에 설명된 대로 TLS를 사용합니다. 다른 QUIC 버전은 다른 암호화 핸드셰이크 프로토콜이 사용 중임을 나타낼 수 있습니다.

QUIC은 암호화 핸드셰이크 데이터를 안정적이고 순서대로 전달합니다. QUIC 패킷 보호는 가능한 많은 핸드셰이크 프로토콜을 암호화하는 데 사용됩니다. 암호화 핸드셰이크는 다음 속성을 제공해야 합니다.\(MUST\)

```text
   *  authenticated key exchange, where
```

- - 서버는 항상 인증됩니다.

- - 클라이언트는 선택적으로 인증됩니다.

- - 모든 연결은 고유하고 관련 없는 키를 생성합니다.

- - 키 자료는 0-RTT 및 1-RTT 패킷 모두에 대한 패킷 보호에 사용할 수 있습니다.

\* 두 끝점의 전송 매개변수에 대한 값의 인증된 교환 및 서버 전송 매개변수에 대한 기밀 보호\(섹션 7.4 참조\).

\* 애플리케이션 프로토콜의 인증된 협상\(TLS는 이 목적을 위해 ALPN\(Application-Layer Protocol Negotiation\) \[ALPN\]을 사용함\).

CRYPTO 프레임은 다른 패킷 번호 공간에서 보낼 수 있습니다\(12.3절\). 암호화 핸드셰이크 데이터의 순서 있는 전달을 보장하기 위해 CRYPTO 프레임에서 사용하는 오프셋은 각 패킷 번호 공간에서 0부터 시작합니다.

그림 4는 간소화된 핸드셰이크와 핸드셰이크를 진행하는 데 사용되는 패킷 및 프레임의 교환을 보여줍니다. 가능한 경우 핸드셰이크 중 애플리케이션 데이터 교환이 활성화되며 별표\("\*"\)로 표시됩니다. 핸드셰이크가 완료되면 엔드포인트는 애플리케이션 데이터를 자유롭게 교환할 수 있습니다.

```text
   Client                                               Server

   Initial (CRYPTO)
   0-RTT (*)              ---------->
                                              Initial (CRYPTO)
                                            Handshake (CRYPTO)
                          <----------                1-RTT (*)
   Handshake (CRYPTO)
   1-RTT (*)              ---------->
                          <----------   1-RTT (HANDSHAKE_DONE)

   1-RTT                  <=========>                    1-RTT

                    Figure 4: Simplified QUIC Handshake
```

엔드포인트는 핸드셰이크 중에 전송된 패킷을 사용하여 ECN\(Explicit Congestion Notification\) 지원을 테스트할 수 있습니다. 섹션 13.4를 참조하십시오. 엔드포인트는 섹션 13.4.2에 설명된 대로 자신이 보내는 첫 번째 패킷을 승인하는 ACK 프레임이 ECN 카운트를 전달하는지 여부를 관찰하여 ECN에 대한 지원을 확인합니다.

엔드포인트는 애플리케이션 프로토콜을 명시적으로 협상해야 합니다. 이렇게 하면 사용 중인 프로토콜에 대해 의견 불일치가 있는 상황을 피할 수 있습니다.\(MUST\)

---
### **7.1.  Example Handshake Flows**

TLS가 QUIC와 어떻게 통합되는지에 대한 자세한 내용은 \[QUIC-TLS\]에서 제공되지만 여기에 몇 가지 예가 제공됩니다. 클라이언트 주소 확인을 지원하기 위한 이 교환의 확장은 섹션 8.1.2에 나와 있습니다.

주소 유효성 검사 교환이 완료되면 암호화 핸드셰이크를 사용하여 암호화 키에 동의합니다. 암호화 핸드셰이크는 초기\(섹션 17.2.2\) 및 핸드셰이크\(섹션 17.2.4\) 패킷으로 전달됩니다.

그림 5는 1-RTT 핸드셰이크의 개요를 제공합니다. 각 라인은 먼저 표시된 패킷 유형 및 패킷 번호와 함께 QUIC 패킷을 표시하고 그 뒤에 일반적으로 해당 패킷에 포함된 프레임을 표시합니다. 예를 들어, 첫 번째 패킷은 패킷 번호가 0인 초기 유형이며 ClientHello를 전달하는 CRYPTO 프레임을 포함합니다.

여러 QUIC 패킷\(패킷 유형이 다르더라도\)을 단일 UDP 데이터그램으로 통합할 수 있습니다. 섹션 12.2를 참조하십시오. 결과적으로 이 핸드셰이크는 최소 4개의 UDP 데이터그램 또는 그 이상으로 구성될 수 있습니다\(혼잡 제어 및 증폭 방지와 같은 프로토콜 고유의 제한에 따라 다름\). 예를 들어, 서버의 첫 번째 비행에는 초기 패킷, 핸드셰이크 패킷 및 1-RTT 패킷의 "0.5-RTT 데이터"가 포함됩니다.

```text
   Client                                                  Server

   Initial[0]: CRYPTO[CH] ->

                                    Initial[0]: CRYPTO[SH] ACK[0]
                          Handshake[0]: CRYPTO[EE, CERT, CV, FIN]
                                    <- 1-RTT[0]: STREAM[1, "..."]

   Initial[1]: ACK[0]
   Handshake[0]: CRYPTO[FIN], ACK[0]
   1-RTT[0]: STREAM[0, "..."], ACK[0] ->

                                             Handshake[1]: ACK[0]
            <- 1-RTT[1]: HANDSHAKE_DONE, STREAM[3, "..."], ACK[0]

                     Figure 5: Example 1-RTT Handshake
```

그림 6은 0-RTT 핸드셰이크와 0-RTT 데이터의 단일 패킷을 사용한 연결의 예를 보여줍니다. 섹션 12.3에서 설명한 것처럼 서버는 1-RTT 패킷의 0-RTT 데이터를 승인하고 클라이언트는 동일한 패킷 번호 공간에서 1-RTT 패킷을 보냅니다.

```text
   Client                                                  Server

   Initial[0]: CRYPTO[CH]
   0-RTT[0]: STREAM[0, "..."] ->

                                    Initial[0]: CRYPTO[SH] ACK[0]
                                     Handshake[0] CRYPTO[EE, FIN]
                             <- 1-RTT[0]: STREAM[1, "..."] ACK[0]

   Initial[1]: ACK[0]
   Handshake[0]: CRYPTO[FIN], ACK[0]
   1-RTT[1]: STREAM[0, "..."] ACK[0] ->

                                             Handshake[1]: ACK[0]
            <- 1-RTT[1]: HANDSHAKE_DONE, STREAM[3, "..."], ACK[1]

                     Figure 6: Example 0-RTT Handshake
```

---
### **7.2.  Negotiating Connection IDs**

연결 ID는 섹션 5.1에 설명된 대로 일관된 패킷 라우팅을 보장하는 데 사용됩니다. 긴 헤더에는 두 개의 연결 ID가 포함되어 있습니다. 대상 연결 ID는 패킷 수신자가 선택하며 일관된 라우팅을 제공하는 데 사용됩니다. 소스 연결 ID는 피어가 사용하는 대상 연결 ID를 설정하는 데 사용됩니다.

핸드셰이크 중에 긴 헤더\(17.2절\)가 있는 패킷은 두 엔드포인트에서 사용되는 연결 ID를 설정하는 데 사용됩니다. 각 끝점은 원본 연결 ID 필드를 사용하여 전송 중인 패킷의 대상 연결 ID 필드에 사용되는 연결 ID를 지정합니다. 첫 번째 초기 패킷을 처리한 후 각 엔드포인트는 수신한 소스 연결 ID 필드의 값으로 보내는 후속 패킷의 대상 연결 ID 필드를 설정합니다.

이전에 서버로부터 초기 또는 재시도 패킷을 받지 않은 클라이언트가 초기 패킷을 보낼 때 클라이언트는 대상 연결 ID 필드를 예측할 수 없는 값으로 채웁니다. 이 대상 연결 ID는 길이가 8바이트 이상이어야 합니다. 서버에서 패킷을 수신할 때까지 클라이언트는 이 연결의 모든 패킷에서 동일한 대상 연결 ID 값을 사용해야 합니다.\(MUST, MUST\)

클라이언트가 보낸 첫 번째 초기 패킷의 대상 연결 ID 필드는 초기 패킷에 대한 패킷 보호 키를 결정하는 데 사용됩니다. 이러한 키는 재시도 패킷을 수신한 후 변경됩니다. \[QUIC-TLS\]의 섹션 5.2를 참조하십시오.

클라이언트는 선택한 값으로 소스 연결 ID 필드를 채우고 길이를 나타내도록 소스 연결 ID 길이 필드를 설정합니다.

첫 번째 비행의 0-RTT 패킷은 클라이언트의 첫 번째 초기 패킷과 동일한 대상 연결 ID 및 소스 연결 ID 값을 사용합니다.

서버에서 초기 또는 재시도 패킷을 처음 수신하면 클라이언트는 0-RTT 패킷을 포함하여 후속 패킷에 대한 대상 연결 ID로 서버에서 제공한 소스 연결 ID를 사용합니다. 이는 클라이언트가 연결 설정 중에 대상 연결 ID 필드에 설정한 연결 ID를 두 번 변경해야 할 수 있음을 의미합니다. 한 번은 재시도 패킷에 대한 응답으로, 한 번은 서버의 초기 패킷에 대한 응답으로 변경해야 합니다. 클라이언트가 서버로부터 유효한 초기 패킷을 수신하면 다른 소스 연결 ID로 해당 연결에서 수신하는 모든 후속 패킷을 폐기해야 합니다.\(MUST\)

클라이언트는 처음 수신한 초기 또는 재시도 패킷에 대한 응답으로 패킷을 보내는 데 사용하는 대상 연결 ID를 변경해야 합니다. 서버는 처음 수신한 초기 패킷을 기반으로 패킷을 보내는 데 사용하는 대상 연결 ID를 설정해야 합니다. 대상 연결 ID에 대한 추가 변경은 값이 NEW\_CONNECTION\_ID 프레임에서 가져온 경우에만 허용됩니다. 후속 초기 패킷이 다른 소스 연결 ID를 포함하는 경우 폐기해야 합니다. 이렇게 하면 원본 연결 ID가 다른 여러 초기 패킷의 상태 비저장 처리로 인해 발생할 수 있는 예측할 수 없는 결과를 피할 수 있습니다.\(MUST, MUST, MUST\)

엔드포인트가 보내는 대상 연결 ID는 특히 연결 마이그레이션에 대한 응답으로 연결 수명 동안 변경될 수 있습니다\(섹션 9\). 자세한 내용은 섹션 5.1.1을 참조하십시오.

---
### **7.3.  Authenticating Connection IDs**

핸드쉐이크 중에 각 엔드포인트가 연결 ID에 대해 선택하는 것은 전송 매개변수에 모든 값을 포함하여 인증됩니다. 섹션 7.4를 참조하십시오. 이렇게 하면 핸드셰이크에 사용되는 모든 연결 ID가 암호화 핸드셰이크에서도 인증됩니다.

각 엔드포인트는 initial\_source\_connection\_id 전송 매개변수에서 보낸 첫 번째 초기 패킷의 소스 연결 ID 필드 값을 포함합니다. 섹션 18.2를 참조하십시오. 서버는 original\_destination\_connection\_id 전송 매개변수에 클라이언트로부터 수신한 첫 번째 초기 패킷의 대상 연결 ID 필드를 포함합니다. 서버가 Retry 패킷을 보낸 경우 Retry 패킷을 보내기 전에 받은 첫 번째 초기 패킷을 나타냅니다. 재시도 패킷을 보내는 경우 서버는 retry\_source\_connection\_id 전송 매개변수에 재시도 패킷의 소스 연결 ID 필드도 포함합니다.

이러한 전송 매개변수에 대해 피어가 제공한 값은 엔드포인트가 보낸\(및 서버의 경우 받은\) 초기 패킷의 대상 및 소스 연결 ID 필드에 사용된 값과 일치해야 합니다. 엔드포인트는 수신된 전송 매개변수가 수신된 연결 ID 값과 일치하는지 확인해야 합니다. 전송 매개변수에 연결 ID 값을 포함하고 확인하면 공격자가 핸드셰이크 중에 공격자가 선택한 연결 ID를 전달하는 패킷을 주입하여 성공적인 연결을 위한 연결 ID 선택에 영향을 미칠 수 없습니다.\(MUST, MUST\)

엔드포인트는 엔드포인트에서 initial\_source\_connection\_id 전송 매개변수가 없거나 서버에서 original\_destination\_connection\_id 전송 매개변수가 없는 경우 TRANSPORT\_PARAMETER\_ERROR 유형의 연결 오류로 처리해야 합니다\(MUST\).\(MUST\)

엔드포인트는 다음을 TRANSPORT\_PARAMETER\_ERROR 또는 PROTOCOL\_VIOLATION 유형의 연결 오류로 처리해야 합니다\(MUST\).\(MUST\)

\* 재시도 패킷을 수신한 후 서버에서 retry\_source\_connection\_id 전송 매개변수가 없는 경우,

\* 재시도 패킷이 수신되지 않았을 때 retry\_source\_connection\_id 전송 매개변수의 존재, 또는

\* 이러한 전송 매개변수에서 피어로부터 받은 값과 초기 패킷의 해당 대상 또는 소스 연결 ID 필드에서 보낸 값 사이의 불일치.

길이가 0인 연결 ID가 선택되면 해당 전송 매개변수가 길이가 0인 값과 함께 포함됩니다.

그림 7은 완전한 핸드셰이크에 사용되는 연결 ID\(DCID=대상 연결 ID, SCID=소스 연결 ID 포함\)를 보여줍니다. 초기 패킷의 교환과 핸드셰이크 중에 설정된 연결 ID를 포함하는 1-RTT 패킷의 이후 교환이 표시됩니다.

```text
   Client                                                  Server

   Initial: DCID=S1, SCID=C1 ->
                                     <- Initial: DCID=C1, SCID=S3
                                ...
   1-RTT: DCID=S3 ->
                                                <- 1-RTT: DCID=C1
```

- 그림 7: 핸드셰이크에서 연결 ID 사용

그림 8은 재시도 패킷을 포함하는 유사한 핸드셰이크를 보여줍니다.

```text
   Client                                                  Server

   Initial: DCID=S1, SCID=C1 ->
                                       <- Retry: DCID=C1, SCID=S2
   Initial: DCID=S2, SCID=C1 ->
                                     <- Initial: DCID=C1, SCID=S3
                                ...
   1-RTT: DCID=S3 ->
                                                <- 1-RTT: DCID=C1
```

- 그림 8: 재시도가 포함된 핸드셰이크에서 연결 ID 사용

두 경우 모두\(그림 7 및 8\) 클라이언트는 initial\_source\_connection\_id 전송 매개변수의 값을 "C1"로 설정합니다.

핸드셰이크에 재시도가 포함되지 않은 경우\(그림 7\) 서버는 original\_destination\_connection\_id를 "S1"로 설정하고\(이 값은 클라이언트에서 선택함\) initial\_source\_connection\_id를 "S3"으로 설정합니다. 이 경우 서버에는 retry\_source\_connection\_id 전송 매개변수가 포함되어 있지 않습니다.

핸드셰이크에 재시도가 포함된 경우\(그림 8\) 서버는 original\_destination\_connection\_id를 "S1"로, retry\_source\_connection\_id를 "S2"로, initial\_source\_connection\_id를 "S3"으로 설정합니다.

---
### **7.4.  Transport Parameters**

연결 설정 중에 두 엔드포인트는 전송 매개변수의 인증된 선언을 만듭니다. 끝점은 각 매개 변수가 정의하는 제한 사항을 준수해야 합니다. 각 매개변수의 설명에는 처리 규칙이 포함되어 있습니다.

전송 매개변수는 각 끝점이 일방적으로 만든 선언입니다. 각 엔드포인트는 해당 피어가 선택한 값과 관계없이 전송 매개변수 값을 선택할 수 있습니다.

전송 매개변수의 인코딩은 섹션 18에 자세히 설명되어 있습니다.

QUIC는 암호화 핸드셰이크에 인코딩된 전송 매개변수를 포함합니다. 핸드셰이크가 완료되면 피어가 선언한 전송 매개변수를 사용할 수 있습니다. 각 끝점은 피어에서 제공한 값의 유효성을 검사합니다.

정의된 각 전송 매개변수에 대한 정의는 섹션 18.2에 포함되어 있습니다.

엔드포인트는 유효하지 않은 값을 가진 전송 매개변수 수신을 TRANSPORT\_PARAMETER\_ERROR 유형의 연결 오류로 처리해야 합니다.\(MUST\)

엔드포인트는 지정된 전송 매개변수 확장에서 매개변수를 두 번 이상 보내면 안 됩니다\(MUST NOT\). 엔드포인트는 중복 전송 매개변수 수신을 TRANSPORT\_PARAMETER\_ERROR 유형의 연결 오류로 처리해야 합니다\(SHOULD\).\(MUST NOT, SHOULD\)

엔드포인트는 전송 매개변수를 사용하여 핸드셰이크 중에 연결 ID 협상을 인증합니다. 섹션 7.3을 참조하십시오.

ALPN\(\[ALPN\] 참조\)을 사용하면 연결 설정 중에 클라이언트가 여러 애플리케이션 프로토콜을 제공할 수 있습니다. 클라이언트가 핸드셰이크 중에 포함하는 전송 매개변수는 클라이언트가 제공하는 모든 애플리케이션 프로토콜에 적용됩니다. 애플리케이션 프로토콜은 초기 흐름 제어 제한과 같은 전송 매개변수에 대한 값을 권장할 수 있습니다. 그러나 전송 매개변수 값에 대한 제약 조건을 설정하는 애플리케이션 프로토콜은 이러한 제약 조건이 충돌하는 경우 클라이언트가 여러 애플리케이션 프로토콜을 제공하는 것을 불가능하게 만들 수 있습니다.

---
#### **7.4.1.  Values of Transport Parameters for 0-RTT**

0-RTT 사용은 이전 연결에서 협상된 프로토콜 매개변수를 사용하는 클라이언트와 서버 모두에 따라 달라집니다. 0-RTT를 활성화하기 위해 엔드포인트는 연결에서 수신하는 모든 세션 티켓과 함께 서버 전송 매개변수의 값을 저장합니다. 엔드포인트는 또한 애플리케이션 프로토콜 또는 암호화 핸드셰이크에 필요한 모든 정보를 저장합니다. \[QUIC-TLS\]의 섹션 4.6을 참조하십시오. 저장된 전송 매개변수의 값은 세션 티켓을 사용하여 0-RTT를 시도할 때 사용됩니다.

핸드셰이크가 완료되고 클라이언트가 1-RTT 패킷 전송을 시작할 때까지 기억된 전송 매개변수가 새 연결에 적용됩니다. 핸드셰이크가 완료되면 클라이언트는 핸드셰이크에 설정된 전송 매개변수를 사용합니다. 일부 전송 매개변수는 향후 연결에 적용되지 않거나 0-RTT 사용에 영향을 미치지 않기 때문에 모든 전송 매개변수가 기억되는 것은 아닙니다.

새로운 전송 매개변수의 정의\(섹션 7.4.2\)는 0-RTT에 대한 전송 매개변수 저장이 필수, 선택 또는 금지인지를 지정해야 합니다\(MUST\). 클라이언트는 처리할 수 없는 전송 매개변수를 저장할 필요가 없습니다.\(MUST\)

클라이언트는 다음 매개변수에 대해 기억된 값을 사용하면 안 됩니다. 클라이언트는 대신 핸드셰이크에서 서버의 새 값을 사용해야 합니다. 서버가 새 값을 제공하지 않으면 기본값이 사용됩니다.\(MUST NOT, MUST\)

0-RTT 데이터 전송을 시도하는 클라이언트는 처리할 수 있는 서버에서 사용하는 다른 모든 전송 매개변수를 기억해야 합니다. 서버는 이러한 전송 매개변수를 기억하거나 무결성 보호된 값의 복사본을 티켓에 저장하고 0-RTT 데이터를 수락할 때 정보를 복구할 수 있습니다. 서버는 0-RTT 데이터를 수락할지 여부를 결정할 때 전송 매개변수를 사용합니다.\(MUST\)

0-RTT 데이터가 서버에서 수락되면 서버는 0-RTT 데이터로 클라이언트가 위반할 수 있는 값을 변경하거나 제한을 줄여서는 안 됩니다\(MUST NOT\). 특히, 0-RTT 데이터를 받아들이는 서버는 다음 매개변수\(섹션 18.2\)에 대해 기억된 매개변수 값보다 작은 값을 설정하면 안 됩니다\(MUST NOT\).\(MUST NOT, MUST NOT\)

```text
   *  active_connection_id_limit

   *  initial_max_data

   *  initial_max_stream_data_bidi_local

   *  initial_max_stream_data_bidi_remote

   *  initial_max_stream_data_uni

   *  initial_max_streams_bidi

   *  initial_max_streams_uni
```

특정 전송 매개변수에 대해 0 값을 생략하거나 설정하면 0-RTT 데이터가 활성화되지만 사용할 수 없게 될 수 있습니다. 애플리케이션 데이터 전송을 허용하는 전송 매개변수의 적용 가능한 하위 집합은 0-RTT에 대해 0이 아닌 값으로 설정되어야 합니다\(SHOULD\). 여기에는 initial\_max\_data와 \(1\) initial\_max\_streams\_bidi 및 initial\_max\_stream\_data\_bidi\_remote 또는 \(2\) initial\_max\_streams\_uni 및 initial\_max\_stream\_data\_uni가 포함됩니다.\(SHOULD\)

서버는 0-RTT를 보낼 때 클라이언트가 적용하는 기억된 값보다 스트림에 대해 더 큰 초기 스트림 흐름 제어 제한을 제공할 수 있습니다. 핸드셰이크가 완료되면 클라이언트는 initial\_max\_stream\_data\_bidi\_remote 및 initial\_max\_stream\_data\_uni의 업데이트된 값을 사용하여 모든 전송 스트림의 흐름 제어 제한을 업데이트합니다.

서버는 max\_idle\_timeout, max\_udp\_payload\_size 및 disable\_active\_migration 매개변수의 이전에 전송된 값을 저장 및 복구할 수 있으며 더 작은 값을 선택하는 경우 0-RTT를 거부할 수 있습니다\(MAY\). 0-RTT 데이터를 수락하면서 이러한 매개변수의 값을 낮추면 연결 성능이 저하될 수 있습니다. 특히, max\_udp\_payload\_size를 낮추면 패킷이 손실되어 0-RTT 데이터를 완전히 거부하는 것과 비교하여 성능이 저하될 수 있습니다.\(MAY\)

전송 매개변수에 대해 복원된 값을 지원할 수 없는 경우 서버는 0-RTT 데이터를 거부해야 합니다.\(MUST\)

0-RTT 패킷으로 프레임을 보낼 때 클라이언트는 기억된 전송 매개변수만 사용해야 합니다. 중요한 것은 서버의 업데이트된 전송 매개변수 또는 1-RTT 패킷에서 수신된 프레임에서 학습한 업데이트된 값을 사용해서는 안 됩니다\(MUST NOT\). 핸드셰이크에서 업데이트된 전송 매개변수 값은 1-RTT 패킷에만 적용됩니다. 예를 들어 기억된 전송 매개변수의 흐름 제어 제한은 해당 값이 핸드셰이크 또는 1-RTT 패킷으로 전송된 프레임에 의해 증가하더라도 모든 0-RTT 패킷에 적용됩니다. 서버는 0-RTT에서 업데이트된 전송 매개변수의 사용을 PROTOCOL\_VIOLATION 유형의 연결 오류로 취급할 수 있습니다\(MAY\).\(MUST NOT, MAY\)

---
#### **7.4.2.  New Transport Parameters**

새 전송 매개변수를 사용하여 새 프로토콜 동작을 협상할 수 있습니다. 엔드포인트는 지원하지 않는 전송 매개변수를 무시해야 합니다. 따라서 전송 매개변수가 없으면 매개변수를 사용하여 협상되는 선택적 프로토콜 기능이 비활성화됩니다. 섹션 18.1에 설명된 대로 일부 식별자는 이 요구 사항을 실행하기 위해 예약되어 있습니다.\(MUST\)

전송 매개변수를 이해하지 못하는 클라이언트는 이를 버리고 후속 연결에서 0-RTT를 시도할 수 있습니다. 그러나 클라이언트가 폐기된 전송 매개변수에 대한 지원을 추가하면 0-RTT를 시도하는 경우 전송 매개변수가 설정하는 제약 조건을 위반할 위험이 있습니다. 새 전송 매개변수는 가장 보수적인 값의 기본값을 설정하여 이 문제를 방지할 수 있습니다. 클라이언트는 현재 지원되지 않는 매개변수를 포함하여 모든 매개변수를 기억함으로써 이 문제를 피할 수 있습니다.

22.3절의 규칙에 따라 새로운 전송 매개변수를 등록할 수 있습니다.

---
### **7.5.  Cryptographic Message Buffering**

구현은 잘못된 순서로 수신된 CRYPTO 데이터의 버퍼를 유지 관리해야 합니다. CRYPTO 프레임의 흐름 제어가 없기 때문에 엔드포인트는 잠재적으로 피어가 무한한 양의 데이터를 버퍼링하도록 강제할 수 있습니다.

구현은 비순차 CRYPTO 프레임에서 수신된 데이터의 최소 4096바이트 버퍼링을 지원해야 합니다\(MUST\). 엔드포인트는 핸드셰이크 중에 더 많은 데이터를 버퍼링하도록 선택할 수 있습니다\(MAY\). 핸드셰이크 동안 더 큰 제한을 사용하면 더 큰 키 또는 자격 증명을 교환할 수 있습니다. 끝점의 버퍼 크기는 연결 수명 동안 일정하게 유지될 필요가 없습니다.\(MUST, MAY\)

핸드셰이크 중에 CRYPTO 프레임을 버퍼링할 수 없으면 연결 오류가 발생할 수 있습니다. 핸드셰이크 중에 엔드포인트의 버퍼가 초과되면 일시적으로 버퍼를 확장하여 핸드셰이크를 완료할 수 있습니다. 엔드포인트가 버퍼를 확장하지 않으면 CRYPTO\_BUFFER\_EXCEEDED 오류 코드와 함께 연결을 닫아야 합니다.\(MUST\)

핸드셰이크가 완료되면 엔드포인트가 CRYPTO 프레임의 모든 데이터를 버퍼링할 수 없는 경우 해당 CRYPTO 프레임과 향후 수신된 모든 CRYPTO 프레임을 폐기하거나 CRYPTO\_BUFFER\_EXCEEDED 오류 코드와 함께 연결을 닫을 수 있습니다. 폐기된 CRYPTO 프레임을 포함하는 패킷은 CRYPTO 프레임이 폐기되더라도 전송에 의해 패킷이 수신되고 처리되었기 때문에 승인되어야 합니다.\(MAY, MUST\)

---
## **8.  Address Validation**

주소 유효성 검사는 엔드포인트가 트래픽 증폭 공격에 사용될 수 없도록 합니다. 이러한 공격에서는 피해자를 식별하는 스푸핑된 소스 주소 정보와 함께 패킷이 서버로 전송됩니다. 서버가 해당 패킷에 대한 응답으로 더 많은 또는 더 큰 패킷을 생성하는 경우 공격자는 서버를 사용하여 자체적으로 보낼 수 있는 것보다 더 많은 데이터를 피해자에게 보낼 수 있습니다.

증폭 공격에 대한 기본 방어는 피어가 주장하는 전송 주소에서 패킷을 수신할 수 있는지 확인하는 것입니다. 따라서 아직 검증되지 않은 주소에서 패킷을 수신한 후 엔드포인트는 검증되지 않은 주소로 전송하는 데이터 양을 해당 주소에서 수신한 데이터 양의 3배로 제한해야 합니다. 응답 크기에 대한 이 제한을 증폭 방지 제한이라고 합니다.\(MUST\)

주소 확인은 연결 설정\(섹션 8.1 참조\)과 연결 마이그레이션\(섹션 8.2 참조\) 중에 모두 수행됩니다.

---
### **8.1.  Address Validation during Connection Establishment**

연결 설정은 암시적으로 두 끝점에 대한 주소 유효성 검사를 제공합니다. 특히 핸드셰이크 키로 보호되는 패킷을 수신하면 피어가 초기 패킷을 성공적으로 처리했음을 확인할 수 있습니다. 엔드포인트가 피어의 핸드셰이크 패킷을 성공적으로 처리하면 피어 주소가 검증된 것으로 간주할 수 있습니다.

또한 엔드포인트는 피어가 엔드포인트에서 선택한 연결 ID를 사용하고 연결 ID에 최소 64비트의 엔트로피가 포함된 경우 유효성이 검증된 피어 주소를 고려할 수 있습니다\(MAY\).\(MAY\)

클라이언트의 경우 첫 번째 초기 패킷의 대상 연결 ID 필드 값을 통해 패킷을 성공적으로 처리하는 과정에서 서버 주소의 유효성을 검사할 수 있습니다. 서버의 초기 패킷은 이 값에서 파생된 키로 보호됩니다\(\[QUIC-TLS\]의 섹션 5.2 참조\). 또는 값이 버전 협상 패킷\(섹션 6\)의 서버에 의해 반향되거나 재시도 패킷\(\[QUIC-TLS\]의 섹션 5.8\)의 무결성 태그에 포함됩니다.

클라이언트 주소를 확인하기 전에 서버는 받은 바이트 수보다 3배 이상 많은 바이트를 보내서는 안 됩니다. 이렇게 하면 스푸핑된 소스 주소를 사용하여 탑재할 수 있는 모든 증폭 공격의 크기가 제한됩니다. 주소 유효성 검사 전에 증폭을 방지하기 위해 서버는 단일 연결에 고유하게 부여된 데이터그램에서 수신된 모든 페이로드 바이트를 계산해야 합니다. 여기에는 성공적으로 처리된 패킷이 포함된 데이터그램과 모두 폐기된 패킷이 포함된 데이터그램이 포함됩니다.\(MUST NOT, MUST\)

클라이언트는 필요에 따라 PADDING 프레임을 추가하여 초기 패킷을 포함하는 UDP 데이터그램이 최소 1200바이트의 UDP 페이로드를 갖도록 해야 합니다. 채워진 데이터그램을 보내는 클라이언트는 서버가 주소 유효성 검사를 완료하기 전에 더 많은 데이터를 보낼 수 있도록 합니다.\(MUST\)

서버에서 초기 또는 핸드셰이크 패킷이 손실되면 클라이언트가 추가 초기 또는 핸드셰이크 패킷을 보내지 않으면 교착 상태가 발생할 수 있습니다. 서버가 증폭 방지 한계에 도달하고 클라이언트가 보낸 모든 데이터에 대한 승인을 받으면 교착 상태가 발생할 수 있습니다. 이 경우 클라이언트가 추가 패킷을 보낼 이유가 없으면 서버는 클라이언트의 주소를 확인하지 않았기 때문에 더 많은 데이터를 보낼 수 없습니다. 이 교착 상태를 방지하기 위해 클라이언트는 PTO\(Probe Timeout\)에서 패킷을 보내야 합니다. \[빠른 복구\]의 섹션 6.2를 참조하십시오. 특히 클라이언트는 핸드셰이크 키가 없는 경우 최소 1200바이트를 포함하는 UDP 데이터그램의 초기 패킷을 보내야 하며, 그렇지 않으면 핸드셰이크 패킷을 보내야 합니다.\(MUST, MUST\)

서버는 암호화 핸드셰이크를 시작하기 전에 클라이언트 주소의 유효성을 검사하려고 할 수 있습니다. QUIC은 초기 패킷의 토큰을 사용하여 핸드셰이크를 완료하기 전에 주소 유효성 검사를 제공합니다. 이 토큰은 재시도 패킷\(섹션 8.1.2 참조\) 또는 NEW\_TOKEN 프레임을 사용하는 이전 연결\(섹션 8.1.3 참조\)로 연결을 설정하는 동안 클라이언트에 전달됩니다.

주소 유효성 검사 이전에 부과된 전송 제한 외에도 서버는 혼잡 컨트롤러에서 설정한 제한에 따라 전송할 수 있는 항목도 제한됩니다. 클라이언트는 혼잡 컨트롤러에 의해서만 제약을 받습니다.

---
#### **8.1.1.  Token Construction**

NEW\_TOKEN 프레임 또는 재시도 패킷에서 전송된 토큰은 서버가 클라이언트에게 제공된 방법을 식별할 수 있는 방식으로 구성되어야 합니다. 이러한 토큰은 동일한 필드에서 전달되지만 서버에서 다른 처리가 필요합니다.\(MUST\)

---
#### **8.1.2.  Address Validation Using Retry Packets**

클라이언트의 초기 패킷을 수신하면 서버는 토큰이 포함된 Retry 패킷\(17.2.5절\)을 전송하여 주소 유효성 검사를 요청할 수 있습니다. 이 토큰은 클라이언트가 재시도 패킷을 수신한 후 해당 연결에 대해 보내는 모든 초기 패킷에서 클라이언트에 의해 반복되어야 합니다.\(MUST\)

재시도 패킷에 제공된 토큰을 포함하는 초기 패킷 처리에 대한 응답으로 서버는 다른 재시도 패킷을 보낼 수 없습니다. 연결을 거부하거나 진행하도록 허용할 수만 있습니다.

공격자가 자신의 주소\(섹션 8.1.4 참조\)에 대해 유효한 토큰을 생성할 수 없고 클라이언트가 해당 토큰을 반환할 수 있는 한 서버에 토큰을 수신했음을 증명합니다.

서버는 연결 설정의 상태 및 처리 비용을 연기하기 위해 재시도 패킷을 사용할 수도 있습니다. 서버가 섹션 18.2에 정의된 original\_destination\_connection\_id 전송 매개변수와 함께 다른 연결 ID를 제공하도록 요구하면 서버 또는 서버와 협력하는 엔터티가 클라이언트로부터 원본 초기 패킷을 수신했음을 입증해야 합니다. 다른 연결 ID를 제공하면 후속 패킷이 라우팅되는 방식에 대한 일부 제어 권한도 서버에 부여됩니다. 이것은 다른 서버 인스턴스에 직접 연결하는 데 사용할 수 있습니다.

서버가 유효하지 않은 재시도 토큰을 포함하지만 그 외에는 유효한 클라이언트 이니셜을 수신하는 경우 클라이언트가 다른 재시도 토큰을 수락하지 않을 것임을 압니다. 서버는 그러한 패킷을 폐기하고 클라이언트가 핸드셰이크 실패를 감지하기 위해 시간 초과되도록 허용할 수 있지만 클라이언트에 상당한 대기 시간 패널티를 부과할 수 있습니다. 대신 서버는 INVALID\_TOKEN 오류로 연결을 즉시 닫아야 합니다\(10.2절\). 이 시점에서 서버는 연결 상태를 설정하지 않았으므로 종료 기간에 들어가지 않습니다.\(SHOULD\)

재시도 패킷의 사용을 보여주는 흐름이 그림 9에 나와 있습니다.

```text
   Client                                                  Server

   Initial[0]: CRYPTO[CH] ->

                                                   <- Retry+Token

   Initial+Token[1]: CRYPTO[CH] ->

                                    Initial[0]: CRYPTO[SH] ACK[1]
                          Handshake[0]: CRYPTO[EE, CERT, CV, FIN]
                                    <- 1-RTT[0]: STREAM[1, "..."]

                   Figure 9: Example Handshake with Retry
```

---
#### **8.1.3.  Address Validation for Future Connections**

서버는 후속 연결에서 사용할 수 있는 한 연결 동안 클라이언트에게 주소 유효성 검사 토큰을 제공할 수 있습니다\(MAY\). 서버가 잠재적으로 0-RTT 데이터에 대한 응답으로 상당한 양의 데이터를 클라이언트에 보내기 때문에 주소 유효성 검사는 0-RTT에서 특히 중요합니다.\(MAY\)

서버는 NEW\_TOKEN 프레임\(19.7절\)을 사용하여 향후 연결을 확인하는 데 사용할 수 있는 주소 확인 토큰을 클라이언트에 제공합니다. 향후 연결에서 클라이언트는 주소 유효성 검사를 제공하기 위해 초기 패킷에 이 토큰을 포함합니다. 클라이언트는 재시도가 토큰을 새로운 것으로 대체하지 않는 한 전송하는 모든 초기 패킷에 토큰을 포함해야 합니다. 클라이언트는 향후 연결을 위해 재시도에서 제공된 토큰을 사용해서는 안 됩니다\(MUST NOT\). 서버는 예상 토큰을 전달하지 않는 초기 패킷을 버릴 수 있습니다\(MAY\).\(MUST, MUST NOT, MAY\)

Retry 패킷에 대해 생성되어 즉시 사용되는 토큰과 달리 NEW\_TOKEN 프레임에 전송된 토큰은 일정 시간이 지난 후에 사용할 수 있습니다. 따라서 토큰에는 명시적인 만료 시간이거나 만료 시간을 동적으로 계산하는 데 사용할 수 있는 발행된 타임스탬프일 수 있는 만료 시간이 있어야 합니다\(SHOULD\). 서버는 만료 시간을 저장하거나 토큰에 암호화된 형태로 포함할 수 있습니다.\(SHOULD\)

NEW\_TOKEN으로 발행된 토큰은 관찰자가 발행된 연결에 값을 연결할 수 있도록 하는 정보를 포함해서는 안 됩니다\(MUST NOT\). 예를 들어 값이 암호화되지 않은 경우 이전 연결 ID 또는 주소 지정 정보를 포함할 수 없습니다. 서버는 전송하는 모든 NEW\_TOKEN 프레임이 이전에 전송된 NEW\_TOKEN 프레임의 손실을 복구하기 위해 전송된 프레임을 제외하고 모든 클라이언트에서 고유한지 확인해야 합니다. 서버가 재시도 토큰과 NEW\_TOKEN 토큰을 구별할 수 있도록 하는 정보는 서버 이외의 엔터티에서 액세스할 수 있습니다.\(MUST NOT, MUST, MAY\)

서로 다른 두 연결에서 클라이언트 포트 번호가 같을 가능성은 없습니다. 따라서 포트 유효성 검사는 성공할 가능성이 없습니다.

NEW\_TOKEN 프레임에서 수신된 토큰은 연결이 신뢰할 수 있는 것으로 간주되는 모든 서버\(예: 인증서에 포함된 서버 이름\)에 적용할 수 있습니다. 클라이언트가 적용 가능한 미사용 토큰을 보유하고 있는 서버에 연결할 때 초기 패킷의 토큰 필드에 해당 토큰을 포함해야 합니다. 토큰을 포함하면 서버가 추가 왕복 없이 클라이언트 주소의 유효성을 검사할 수 있습니다. 클라이언트는 토큰을 발행한 서버와 클라이언트가 연결하는 서버가 토큰을 공동으로 관리하고 있다는 사실을 클라이언트가 알지 못하는 한 연결하는 서버에 적용할 수 없는 토큰을 포함해서는 안 됩니다\(MUST NOT\). 클라이언트는 해당 서버에 대한 이전 연결의 토큰을 사용할 수 있습니다.\(SHOULD, MUST NOT, MAY\)

토큰을 사용하면 서버가 토큰이 발급된 연결과 토큰이 사용된 모든 연결 간의 활동을 연관시킬 수 있습니다. 서버와의 ID 연속성을 끊고자 하는 클라이언트는 NEW\_TOKEN 프레임을 사용하여 제공된 토큰을 폐기할 수 있습니다. 이에 비해 Retry 패킷에서 얻은 토큰은 연결 시도 중에 즉시 사용해야 하며 후속 연결 시도에서 사용할 수 없습니다.\(MUST\)

클라이언트는 다른 연결 시도에 대해 NEW\_TOKEN 프레임의 토큰을 재사용해서는 안 됩니다\(SHOULD NOT\). 토큰을 재사용하면 네트워크 경로의 엔터티가 연결을 연결할 수 있습니다. 섹션 9.5를 참조하십시오.\(SHOULD NOT\)

클라이언트는 단일 연결에서 여러 토큰을 받을 수 있습니다. 연결 가능성을 방지하는 것 외에도 모든 연결 시도에서 모든 토큰을 사용할 수 있습니다. 서버는 여러 연결 시도에 대한 주소 유효성 검사를 활성화하거나 유효하지 않게 될 수 있는 이전 토큰을 교체하기 위해 추가 토큰을 보낼 수 있습니다. 클라이언트의 경우 이러한 모호성은 가장 최근에 사용되지 않은 토큰을 보내는 것이 가장 효과적일 가능성이 높다는 것을 의미합니다. 이전 토큰을 저장하고 사용하는 것이 부정적인 결과를 초래하지는 않지만 클라이언트는 이전 토큰이 주소 유효성 검사를 위해 서버에 덜 유용하다고 간주할 수 있습니다.

서버가 주소 유효성 검사 토큰이 있는 초기 패킷을 수신하면 이미 주소 유효성 검사를 완료하지 않은 경우 토큰 유효성 검사를 시도해야 합니다. 토큰이 유효하지 않으면 서버는 잠재적으로 재시도 패킷을 보내는 것을 포함하여 클라이언트가 검증된 주소를 가지고 있지 않은 것처럼 진행해야 합니다\(SHOULD\). NEW\_TOKEN 프레임 및 Retry 패킷과 함께 제공되는 토큰은 서버에서 구별할 수 있으며\(섹션 8.1.1 참조\) 후자는 더 엄격하게 검증할 수 있습니다. 유효성 검사가 성공하면 서버는 핸드셰이크가 진행되도록 허용해야 합니다\(SHOULD\).\(MUST, SHOULD, SHOULD\)

- | 참고: 클라이언트를 검증되지 않은 것으로 취급하는 근거 | 패킷을 버리기보다는 클라이언트가 | NEW\_TOKEN | 그리고 서버가 상태를 잃어버리면 | 토큰의 유효성을 검사하면 연결 실패로 이어집니다. | 패킷은 폐기됩니다.

상태 비저장 설계에서 서버는 암호화되고 인증된 토큰을 사용하여 서버가 나중에 복구하고 클라이언트 주소의 유효성을 검사하는 데 사용할 수 있는 클라이언트에 정보를 전달할 수 있습니다. 토큰은 암호화 핸드셰이크에 통합되지 않으므로 인증되지 않습니다. 예를 들어 클라이언트는 토큰을 재사용할 수 있습니다. 이 속성을 악용하는 공격을 피하기 위해 서버는 클라이언트 주소의 유효성을 검사하는 데 필요한 정보로만 토큰 사용을 제한할 수 있습니다.

클라이언트는 동일한 버전을 사용하는 모든 연결 시도에 대해 하나의 연결에서 얻은 토큰을 사용할 수 있습니다\(MAY\). 사용할 토큰을 선택할 때 클라이언트는 가능한 응용 프로그램 프로토콜, 세션 티켓 또는 기타 연결 속성의 선택을 포함하여 시도 중인 연결의 다른 속성을 고려할 필요가 없습니다.\(MAY\)

---
#### **8.1.4.  Address Validation Token Integrity**

주소 유효성 검사 토큰은 추측하기 어려워야 합니다. 토큰에 최소 128비트의 엔트로피가 있는 임의의 값을 포함하는 것으로 충분하지만 이는 클라이언트에 보내는 값을 기억하는 서버에 따라 다릅니다.\(MUST\)

토큰 기반 체계를 통해 서버는 유효성 검사와 관련된 모든 상태를 클라이언트로 오프로드할 수 있습니다. 이 디자인이 작동하려면 토큰이 클라이언트에 의한 수정 또는 위조에 대한 무결성 보호로 덮여 있어야 합니다. 무결성 보호가 없으면 악의적인 클라이언트가 서버에서 허용하는 토큰 값을 생성하거나 추측할 수 있습니다. 서버에서만 토큰에 대한 무결성 보호 키에 대한 액세스가 필요합니다.\(MUST\)

토큰을 생성하는 서버도 토큰을 사용하기 때문에 토큰에 대해 잘 정의된 단일 형식이 필요하지 않습니다. 재시도 패킷으로 전송된 토큰에는 클라이언트 패킷의 소스 IP 주소와 포트가 일정하게 유지되는지 서버가 확인할 수 있는 정보가 포함되어야 합니다\(SHOULD\).\(SHOULD\)

NEW\_TOKEN 프레임으로 전송된 토큰은 클라이언트 IP 주소가 토큰이 발행된 시점에서 변경되지 않았음을 서버가 확인할 수 있도록 하는 정보를 포함해야 합니다. 서버는 클라이언트 주소가 변경된 경우에도 재시도 패킷을 보내지 않도록 결정할 때 NEW\_TOKEN 프레임의 토큰을 사용할 수 있습니다. 클라이언트 IP 주소가 변경된 경우 서버는 증폭 방지 제한을 준수해야 합니다. 섹션 8을 참조하십시오. NAT가 있는 경우 이 요구 사항은 NAT를 공유하는 다른 호스트를 증폭 공격으로부터 보호하는 데 충분하지 않을 수 있습니다.\(MUST, MUST\)

공격자는 서버를 DDoS 공격의 증폭기로 사용하기 위해 토큰을 재생할 수 있습니다. 이러한 공격으로부터 보호하기 위해 서버는 토큰 재생이 방지되거나 제한되도록 해야 합니다. 서버는 재시도 패킷으로 전송된 토큰이 클라이언트에 의해 즉시 반환되므로 짧은 시간 동안만 수락되도록 해야 합니다\(SHOULD\). NEW\_TOKEN 프레임\(섹션 19.7\)에서 제공되는 토큰은 더 오래 유효해야 하지만 여러 번 허용되어서는 안 됩니다. 서버는 가능한 경우 토큰을 한 번만 사용하도록 허용하는 것이 좋습니다. 토큰은 적용 범위를 좁히거나 재사용하기 위해 클라이언트에 대한 추가 정보를 포함할 수 있습니다.\(MUST, SHOULD, SHOULD NOT, MAY\)

---
### **8.2.  Path Validation**

주소 변경 후 도달 가능성을 확인하기 위해 연결 마이그레이션\(섹션 9 참조\) 동안 두 피어에서 경로 유효성 검사를 사용합니다. 경로 유효성 검사에서 끝점은 특정 로컬 주소와 특정 피어 주소 간의 도달 가능성을 테스트합니다. 여기서 주소는 IP 주소와 포트의 2튜플입니다.

피어에 대한 경로에서 전송된 패킷이 해당 피어에서 수신되는지 확인하는 경로 유효성 검사입니다. 경로 유효성 검사는 마이그레이션 피어에서 받은 패킷이 스푸핑된 소스 주소를 전달하지 않는지 확인하는 데 사용됩니다.

경로 유효성 검사는 피어가 반환 방향으로 보낼 수 있는지 확인하지 않습니다. 수신확인은 엔트로피가 충분하지 않고 스푸핑될 수 있으므로 반환 경로 유효성 검사에 사용할 수 없습니다. 엔드포인트는 경로의 각 방향에 대한 도달 가능성을 독립적으로 결정하므로 반환 도달 가능성은 피어에 의해서만 설정될 수 있습니다.

경로 유효성 검사는 엔드포인트에서 언제든지 사용할 수 있습니다. 예를 들어 엔드포인트는 피어가 정지 기간 이후에도 여전히 해당 주소를 소유하고 있는지 확인할 수 있습니다.

경로 유효성 검사는 NAT 순회 메커니즘으로 설계되지 않았습니다. 여기에 설명된 메커니즘은 NAT 통과를 지원하는 NAT 바인딩을 만드는 데 효과적일 수 있지만 한 끝점이 해당 경로에서 먼저 패킷을 보내지 않고도 패킷을 수신할 수 있을 것으로 예상됩니다. 효과적인 NAT 통과에는 여기에 제공되지 않은 추가 동기화 메커니즘이 필요합니다.

끝점은 경로 유효성 검사에 사용되는 PATH\_CHALLENGE 및 PATH\_RESPONSE 프레임이 있는 다른 프레임을 포함할 수 있습니다\(MAY\). 특히 엔드포인트는 PMTUD\(Path Maximum Transmission Unit Discovery\)를 위한 PATH\_CHALLENGE 프레임과 함께 PADDING 프레임을 포함할 수 있습니다. 섹션 14.2.1을 참조하십시오. 끝점은 PATH\_RESPONSE 프레임을 보낼 때 자체 PATH\_CHALLENGE 프레임을 포함할 수도 있습니다.\(MAY\)

끝점은 새 로컬 주소에서 보낸 프로브에 새 연결 ID를 사용합니다. 섹션 9.5를 참조하십시오. 새 경로를 조사할 때 엔드포인트는 피어가 응답에 사용 가능한 미사용 연결 ID를 가지고 있는지 확인할 수 있습니다. 동일한 패킷에서 NEW\_CONNECTION\_ID 및 PATH\_CHALLENGE 프레임을 전송하면 피어의 active\_connection\_id\_limit가 허용하는 경우 응답을 보낼 때 사용하지 않은 연결 ID를 피어에서 사용할 수 있습니다.

엔드포인트는 여러 경로를 동시에 조사하도록 선택할 수 있습니다. 프로브에 사용되는 동시 경로의 수는 피어가 이전에 제공한 추가 연결 ID의 수로 제한됩니다. 프로브에 사용되는 각각의 새 로컬 주소에는 이전에 사용되지 않은 연결 ID가 필요하기 때문입니다.

---
#### **8.2.1.  Initiating Path Validation**

경로 유효성 검사를 시작하기 위해 엔드포인트는 유효성을 검사할 경로에 예측할 수 없는 페이로드가 포함된 PATH\_CHALLENGE 프레임을 보냅니다.

끝점은 패킷 손실을 방지하기 위해 여러 PATH\_CHALLENGE 프레임을 보낼 수 있습니다. 그러나 끝점은 단일 패킷에서 여러 PATH\_CHALLENGE 프레임을 보내면 안 됩니다\(SHOULD NOT\).\(MAY, SHOULD NOT\)

종점은 초기 패킷을 보내는 것보다 더 자주 PATH\_CHALLENGE 프레임을 포함하는 패킷으로 새 경로를 조사하면 안 됩니다\(SHOULD NOT\). 이렇게 하면 새 연결을 설정하는 것보다 연결 마이그레이션이 새 경로에 더 이상 로드되지 않습니다.\(SHOULD NOT\)

엔드포인트는 피어의 응답을 해당 PATH\_CHALLENGE와 연결할 수 있도록 모든 PATH\_CHALLENGE 프레임에서 예측할 수 없는 데이터를 사용해야 합니다.\(MUST\)

경로에 대한 증폭 방지 제한이 이 크기의 데이터그램 전송을 허용하지 않는 한 엔드포인트는 PATH\_CHALLENGE 프레임을 포함하는 데이터그램을 최소 허용 최대 데이터그램 크기인 1200바이트로 확장해야 합니다. 이 크기의 UDP 데이터그램을 전송하면 엔드포인트에서 피어까지의 네트워크 경로를 QUIC에 사용할 수 있습니다. 섹션 14를 참조하십시오.\(MUST\)

증폭 방지 제한으로 인해 끝점이 데이터그램 크기를 1200바이트로 확장할 수 없는 경우 경로 MTU가 확인되지 않습니다. 경로 MTU가 충분히 큰지 확인하기 위해 엔드포인트는 최소 1200바이트의 데이터그램에서 PATH\_CHALLENGE 프레임을 전송하여 두 번째 경로 유효성 검사를 수행해야 합니다. 이 추가 유효성 검사는 PATH\_RESPONSE가 성공적으로 수신된 후 또는 더 큰 데이터그램을 전송해도 증폭 방지 제한을 초과하지 않는 경로에서 충분한 바이트가 수신되었을 때 수행할 수 있습니다.\(MUST\)

데이터그램이 확장되는 다른 경우와 달리 엔드포인트는 PATH\_CHALLENGE 또는 PATH\_RESPONSE를 포함할 때 너무 작아 보이는 데이터그램을 버리면 안 됩니다\(MUST NOT\).\(MUST NOT\)

---
#### **8.2.2.  Path Validation Responses**

PATH\_CHALLENGE 프레임을 수신하면 엔드포인트는 PATH\_RESPONSE 프레임의 PATH\_CHALLENGE 프레임에 포함된 데이터를 반향하여 응답해야 합니다. 엔드포인트는 혼잡 제어에 의해 제한되지 않는 한 PATH\_RESPONSE 프레임을 포함하는 패킷의 전송을 지연해서는 안 됩니다\(MUST NOT\).\(MUST, MUST NOT\)

PATH\_CHALLENGE 프레임이 수신된 네트워크 경로에서 PATH\_RESPONSE 프레임을 전송해야 합니다. 이렇게 하면 경로가 양방향으로 작동하는 경우에만 피어의 경로 유효성 검사가 성공합니다. 이 요구 사항은 마이그레이션에 대한 공격을 가능하게 하므로 경로 유효성 검사를 시작하는 끝점에 의해 시행되어서는 안 됩니다\(MUST NOT\). 섹션 9.3.3을 참조하십시오.\(MUST, MUST NOT\)

엔드포인트는 PATH\_RESPONSE 프레임을 포함하는 데이터그램을 최소 허용 최대 데이터그램 크기인 1200바이트로 확장해야 합니다. 이는 경로가 이 크기의 데이터그램을 양방향으로 전달할 수 있는지 확인합니다. 그러나 엔드포인트는 결과 데이터가 증폭 방지 제한을 초과하는 경우 PATH\_RESPONSE를 포함하는 데이터그램을 확장하면 안 됩니다\(MUST NOT\). 이는 수신된 PATH\_CHALLENGE가 확장된 데이터그램으로 전송되지 않은 경우에만 발생할 것으로 예상됩니다.\(MUST, MUST NOT\)

엔드포인트는 하나의 PATH\_CHALLENGE 프레임에 대한 응답으로 하나 이상의 PATH\_RESPONSE 프레임을 전송해서는 안 됩니다. 섹션 13.3을 참조하십시오. 피어는 추가 PATH\_RESPONSE 프레임을 호출하는 데 필요한 만큼 더 많은 PATH\_CHALLENGE 프레임을 보낼 것으로 예상됩니다.\(MUST NOT\)

---
#### **8.2.3.  Successful Path Validation**

이전 PATH\_CHALLENGE 프레임에서 전송된 데이터가 포함된 PATH\_RESPONSE 프레임이 수신되면 경로 유효성 검사가 성공합니다. 임의의 네트워크 경로에서 수신된 PATH\_RESPONSE 프레임은 PATH\_CHALLENGE가 전송된 경로의 유효성을 검사합니다.

엔드포인트가 최소 1200바이트로 확장되지 않은 데이터그램의 PATH\_CHALLENGE 프레임을 보내고 이에 대한 응답이 피어 주소의 유효성을 검사하는 경우 경로는 유효성이 검사되지만 경로 MTU는 유효성이 검사되지 않습니다. 결과적으로 엔드포인트는 이제 수신한 데이터 양의 3배 이상을 보낼 수 있습니다. 그러나 끝점은 확장된 데이터그램으로 다른 경로 유효성 검사를 시작하여 경로가 필요한 MTU를 지원하는지 확인해야 합니다.\(MUST\)

PATH\_CHALLENGE 프레임을 포함하는 패킷에 대한 승인 수신은 승인이 악의적인 피어에 의해 스푸핑될 수 있으므로 적절한 유효성 검사가 아닙니다.

---
#### **8.2.4.  Failed Path Validation**

경로 유효성 검사는 경로 유효성 검사를 시도하는 엔드포인트가 경로 유효성 검사 시도를 포기하는 경우에만 실패합니다.

끝점은 타이머를 기반으로 경로 유효성 검사를 포기해야 합니다\(SHOULD\). 이 타이머를 설정할 때 구현 시 새 경로의 왕복 시간이 원래 경로보다 길 수 있다는 점에 주의해야 합니다. 현재 PTO 또는 새 경로에 대한 PTO\(\[QUIC-RECOVERY\]에 정의된 대로 kInitialRtt 사용\)보다 큰 값의 3배 값이 권장됩니다.\(SHOULD, SHOULD\)

이 시간 초과는 경로 유효성 검사에 실패하기 전에 여러 PTO가 만료되도록 허용하므로 단일 PATH\_CHALLENGE 또는 PATH\_RESPONSE 프레임이 손실되어도 경로 유효성 검사 실패가 발생하지 않습니다.

엔드포인트는 새 경로에서 다른 프레임을 포함하는 패킷을 수신할 수 있지만 경로 유효성 검사가 성공하려면 적절한 데이터가 있는 PATH\_RESPONSE 프레임이 필요합니다.

엔드포인트가 경로 유효성 검사를 포기하면 경로를 사용할 수 없다고 판단합니다. 이것이 반드시 연결 실패를 의미하는 것은 아닙니다. 엔드포인트는 적절한 경우 다른 경로를 통해 패킷을 계속 보낼 수 있습니다. 사용 가능한 경로가 없으면 엔드포인트는 새 경로가 사용 가능해질 때까지 기다리거나 연결을 닫을 수 있습니다. 해당 피어에 대한 유효한 네트워크 경로가 없는 엔드포인트는 NO\_VIABLE\_PATH 연결 오류를 사용하여 이를 신호할 수 있으며, 이는 네트워크 경로가 존재하지만 필요한 MTU\(섹션 14\)를 지원하지 않는 경우에만 가능하다는 점에 유의하십시오.\(MAY\)

실패 이외의 다른 이유로 경로 유효성 검사가 중단될 수 있습니다. 주로 이전 경로에서 경로 유효성 검사가 진행되는 동안 새 경로로의 연결 마이그레이션이 시작된 경우에 발생합니다.

---
## **9.  Connection Migration**

연결 ID를 사용하면 연결이 새 네트워크로 마이그레이션하는 엔드포인트로 인해 발생하는 것과 같은 엔드포인트 주소\(IP 주소 및 포트\)에 대한 변경 사항을 유지할 수 있습니다. 이 섹션에서는 엔드포인트가 새 주소로 마이그레이션되는 프로세스에 대해 설명합니다.

QUIC의 설계는 핸드셰이크 기간 동안 안정적인 주소를 유지하는 엔드포인트에 의존합니다. 엔드포인트는 \[QUIC-TLS\]의 섹션 4.1.2에 정의된 대로 핸드셰이크가 확인되기 전에 연결 마이그레이션을 시작해서는 안 됩니다\(MUST NOT\).\(MUST NOT\)

피어가 disable\_active\_migration 전송 매개변수를 전송한 경우 엔드포인트는 선호하는 주소 전송 매개변수에 대해 작동하지 않는 한 다른 로컬 주소에서 핸드셰이크 중에 피어가 사용한 주소로 패킷\(프로빙 패킷 포함, 섹션 9.1 참조\)을 보내면 안 됩니다\(MUST NOT\). 피어에서. 피어가 이 요구 사항을 위반하는 경우 엔드포인트는 Stateless Reset을 생성하지 않고 해당 경로에서 들어오는 패킷을 삭제하거나 경로 유효성 검사를 진행하고 피어가 마이그레이션하도록 허용해야 합니다. 상태 비저장 재설정을 생성하거나 연결을 닫으면 네트워크의 제3자가 관찰된 트래픽을 스푸핑하거나 조작하여 연결을 닫을 수 있습니다.\(MUST NOT, MUST\)

피어 주소의 모든 변경 사항이 의도적이거나 활성인 마이그레이션은 아닙니다. 피어는 NAT 리바인딩을 경험할 수 있습니다. 미들박스\(일반적으로 NAT\)로 인한 주소 변경, 흐름에 대한 새 발신 포트 또는 새 발신 IP 주소 할당. 엔드포인트는 이전에 해당 주소를 검증하지 않은 경우 피어의 주소에 대한 변경 사항을 감지하면 경로 검증\(섹션 8.2\)을 수행해야 합니다.\(MUST\)

엔드포인트에 패킷을 보낼 검증된 경로가 없으면 연결 상태를 버릴 수 있습니다\(MAY\). 연결 마이그레이션이 가능한 끝점은 연결 상태를 버리기 전에 새 경로가 사용 가능해질 때까지 기다릴 수 있습니다\(MAY\).\(MAY, MAY\)

이 문서는 섹션 9.6에 설명된 경우를 제외하고 새 클라이언트 주소에 대한 연결 마이그레이션을 제한합니다. 클라이언트는 모든 마이그레이션을 시작할 책임이 있습니다. 서버는 해당 주소에서 비프로빙 패킷을 볼 때까지 클라이언트 주소로 비프로빙 패킷\(9.1절 참조\)을 보내지 않습니다. 클라이언트가 알 수 없는 서버 주소에서 패킷을 수신하는 경우 클라이언트는 이러한 패킷을 폐기해야 합니다.\(MUST\)

---
### **9.1.  Probing a New Path**

엔드포인트는 연결을 새 로컬 주소로 마이그레이션하기 전에 경로 유효성 검사\(섹션 8.2\)를 사용하여 새 로컬 주소에서 피어 도달 가능성을 조사할 수 있습니다\(MAY\). 경로 유효성 검사 실패는 단순히 이 연결에 새 경로를 사용할 수 없음을 의미합니다. 유효한 대체 경로가 없는 경우가 아니면 경로 유효성 검사 실패로 인해 연결이 종료되지 않습니다.\(MAY\)

PATH\_CHALLENGE, PATH\_RESPONSE, NEW\_CONNECTION\_ID 및 PADDING 프레임은 "프로빙 프레임"이고 다른 모든 프레임은 "비프로빙 프레임"입니다. 프로빙 프레임만 포함하는 패킷은 "프로빙 패킷"이고 다른 프레임을 포함하는 패킷은 "비프로빙 패킷"입니다.

---
### **9.2.  Initiating Connection Migration**

엔드포인트는 해당 주소에서 비프로빙 프레임이 포함된 패킷을 전송하여 새 로컬 주소로 연결을 마이그레이션할 수 있습니다.

각 끝점은 연결 설정 중에 피어의 주소를 확인합니다. 따라서 마이그레이션하는 엔드포인트는 피어가 피어의 현재 주소에서 수신할 의사가 있음을 알면서 피어에게 보낼 수 있습니다. 따라서 엔드포인트는 피어의 주소를 먼저 확인하지 않고 새 로컬 주소로 마이그레이션할 수 있습니다.

새 경로에서 도달 가능성을 설정하기 위해 엔드포인트는 새 경로에서 경로 유효성 검사\(8.2절\)를 시작합니다. 끝점은 피어가 다음 비프로빙 프레임을 새 주소로 보낼 때까지 경로 유효성 검사를 연기할 수 있습니다\(MAY\).\(MAY\)

마이그레이션할 때 새 경로가 엔드포인트의 현재 전송 속도를 지원하지 않을 수 있습니다. 따라서 엔드포인트는 9.4절에 설명된 대로 혼잡 컨트롤러 및 RTT 추정치를 재설정합니다.

새 경로에 동일한 ECN 기능이 없을 수 있습니다. 따라서 엔드포인트는 섹션 13.4에 설명된 대로 ECN 기능을 검증합니다.

---
### **9.3.  Responding to Connection Migration**

비프로빙 프레임이 포함된 새 피어 주소에서 패킷을 수신하면 피어가 해당 주소로 마이그레이션되었음을 나타냅니다.

수신자가 마이그레이션을 허용하면 후속 패킷을 새로운 피어 주소로 전송해야 하며 검증이 아직 진행되지 않은 경우 피어의 주소 소유권을 확인하기 위해 경로 검증\(섹션 8.2\)을 시작해야 합니다. 수신자가 피어에서 사용하지 않은 연결 ID가 없으면 피어가 제공할 때까지 새 경로에서 아무 것도 보낼 수 없습니다. 섹션 9.5를 참조하십시오.\(MUST\)

엔드포인트는 가장 높은 번호의 비프로빙 패킷에 대한 응답으로 패킷을 보내는 주소만 변경합니다. 이렇게 하면 엔드포인트가 재정렬된 패킷을 수신하는 경우 이전 피어 주소로 패킷을 보내지 않습니다.

엔드포인트는 검증되지 않은 피어 주소로 데이터를 보낼 수 있지만 섹션 9.3.1 및 9.3.2에 설명된 대로 잠재적인 공격으로부터 보호해야 합니다. 피어 주소가 최근에 확인된 경우 엔드포인트는 피어 주소의 유효성 검사를 건너뛸 수 있습니다\(MAY\). 특히 어떤 형태의 가짜 마이그레이션을 감지한 후 엔드포인트가 이전에 검증된 경로로 돌아가는 경우 주소 검증을 건너뛰고 손실 감지 및 혼잡 상태를 복원하면 공격의 성능 영향을 줄일 수 있습니다.\(MUST, MAY\)

비프로빙 패킷을 보내는 주소를 변경한 후 엔드포인트는 다른 주소에 대한 경로 유효성 검사를 포기할 수 있습니다.

새 피어 주소에서 패킷을 수신하는 것은 피어에서 NAT 리바인딩의 결과일 수 있습니다.

새 클라이언트 주소를 확인한 후 서버는 새 주소 유효성 검사 토큰\(섹션 8\)을 클라이언트에 보내야 합니다\(SHOULD\).\(SHOULD\)

---
#### **9.3.1.  Peer Address Spoofing**

피어가 소스 주소를 스푸핑하여 엔드포인트가 원치 않는 호스트에 과도한 양의 데이터를 보내도록 할 수 있습니다. 엔드포인트가 스푸핑 피어보다 훨씬 더 많은 데이터를 보내는 경우 연결 마이그레이션을 사용하여 공격자가 피해자에게 생성할 수 있는 데이터의 양을 증폭시킬 수 있습니다.

섹션 9.3에 설명된 대로 피어의 새 주소 소유를 확인하기 위해 피어의 새 주소를 확인하는 엔드포인트가 필요합니다. 피어의 주소가 유효한 것으로 간주될 때까지 엔드포인트는 해당 주소로 보내는 데이터의 양을 제한합니다. 섹션 8을 참조하십시오. 이 제한이 없으면 끝점이 순진한 피해자에 대한 서비스 거부 공격에 사용될 위험이 있습니다.

엔드포인트가 위에서 설명한 대로 피어 주소의 유효성 검사를 건너뛰는 경우 전송 속도를 제한할 필요가 없습니다.

---
#### **9.3.2.  On-Path Address Spoofing**

온패스 공격자는 원본 패킷보다 먼저 도착하도록 스푸핑된 주소가 있는 패킷을 복사 및 전달하여 가짜 연결 마이그레이션을 유발할 수 있습니다. 스푸핑된 주소가 있는 패킷은 마이그레이션 연결에서 오는 것으로 표시되고 원래 패킷은 복제된 것으로 표시되어 삭제됩니다. 가짜 마이그레이션 후에는 원본 주소의 엔터티가 원하는 경우에도 전송된 PATH\_CHALLENGE 프레임을 읽거나 이에 응답하는 데 필요한 암호화 키가 없기 때문에 원본 주소의 유효성 검사가 실패합니다.

이러한 가짜 마이그레이션으로 인해 연결이 실패하지 않도록 보호하려면 엔드포인트는 새 피어 주소의 유효성 검사가 실패할 때 마지막으로 유효성이 검사된 피어 주소를 사용하도록 되돌려야 합니다. 또한 합법적인 피어 주소에서 패킷 번호가 더 높은 패킷을 수신하면 다른 연결 마이그레이션이 트리거됩니다. 이로 인해 가짜 마이그레이션 주소의 유효성 검사가 중단되어 단일 패킷을 주입하는 공격자가 시작한 마이그레이션이 포함됩니다.\(MUST\)

끝점에 마지막으로 검증된 피어 주소에 대한 상태가 없으면 모든 연결 상태를 폐기하여 연결을 자동으로 닫아야 합니다. 이로 인해 연결의 새 패킷이 일반적으로 처리됩니다. 예를 들어, 엔드포인트는 추가 수신 패킷에 대한 응답으로 Stateless Reset을 보낼 수 있습니다\(MAY\).\(MUST, MAY\)

---
#### **9.3.3.  Off-Path Packet Forwarding**

패킷을 관찰할 수 있는 경로를 벗어난 공격자는 진짜 패킷의 복사본을 엔드포인트로 전달할 수 있습니다. 복사된 패킷이 정품 패킷보다 먼저 도착하면 NAT 리바인딩으로 나타납니다. 정품 패킷은 중복으로 폐기됩니다. 공격자가 패킷을 계속 전달할 수 있는 경우 공격자를 통해 경로로 마이그레이션할 수 있습니다. 이렇게 하면 공격자가 경로에 배치되어 모든 후속 패킷을 관찰하거나 삭제할 수 있습니다.

이 공격 스타일은 끝점 사이의 직접 경로와 거의 동일한 특성을 가진 경로를 사용하는 공격자에 의존합니다. 상대적으로 적은 수의 패킷이 전송되거나 시도된 공격과 패킷 손실이 일치하는 경우 공격이 더 안정적입니다.

수신된 최대 패킷 수를 늘리는 원래 경로에서 수신된 비프로빙 패킷은 엔드포인트가 해당 경로로 다시 이동하도록 합니다. 이 경로에서 패킷을 유도하면 공격이 실패할 가능성이 높아집니다. 따라서 이 공격의 완화는 패킷 교환 트리거에 의존합니다.

명백한 마이그레이션에 대한 응답으로 엔드포인트는 PATH\_CHALLENGE 프레임을 사용하여 이전 활성 경로를 확인해야 합니다. 이는 해당 경로에서 새 패킷 전송을 유도합니다. 경로가 더 이상 실행 가능하지 않으면 유효성 검사 시도가 시간 초과되어 실패합니다. 경로가 실행 가능하지만 더 이상 필요하지 않은 경우 유효성 검사는 성공하지만 경로에서 전송되는 프로브 패킷만 발생합니다.\(MUST\)

활성 경로에서 PATH\_CHALLENGE를 수신하는 엔드포인트는 비프로빙 패킷을 응답으로 보내야 합니다\(SHOULD\). 탐색하지 않는 패킷이 공격자가 만든 복사본보다 먼저 도착하면 연결이 원래 경로로 다시 마이그레이션됩니다. 다른 경로로의 후속 마이그레이션은 이 전체 프로세스를 다시 시작합니다.\(SHOULD\)

이 방어는 불완전하지만 심각한 문제로 간주되지 않습니다. 원래 경로를 사용하기 위해 여러 번 시도했지만 공격을 통한 경로가 원래 경로보다 안정적으로 빠르다면 공격과 라우팅 개선을 구분할 수 없습니다.

엔드포인트는 휴리스틱을 사용하여 이러한 유형의 공격 탐지를 개선할 수도 있습니다. 예를 들어 패킷이 이전 경로에서 최근에 수신된 경우 NAT 리바인딩이 불가능합니다. 마찬가지로 리바인딩은 IPv6 경로에서 거의 발생하지 않습니다. 엔드포인트는 중복 패킷도 찾을 수 있습니다. 반대로 연결 ID의 변경은 공격이 아니라 의도적인 마이그레이션을 나타낼 가능성이 더 큽니다.

---
### **9.4.  Loss Detection and Congestion Control**

새 경로에서 사용 가능한 용량은 이전 경로와 다를 수 있습니다. 이전 경로에서 전송된 패킷은 혼잡 제어 또는 새 경로에 대한 RTT 추정에 기여해서는 안 됩니다\(MUST NOT\).\(MUST NOT\)

새 주소에 대한 피어의 소유권을 확인하면 엔드포인트는 새 경로에 대한 혼잡 컨트롤러 및 왕복 시간 추정기를 초기 값으로 즉시 재설정해야 합니다\(\[빠른 복구\]의 부록 A.3 및 B.3 참조\). 피어 주소의 유일한 변경 사항은 해당 포트 번호입니다. 포트 전용 변경은 일반적으로 NAT 리바인딩 또는 기타 미들박스 활동의 결과이기 때문에 엔드포인트는 초기 값으로 되돌리는 대신 이러한 경우에 혼잡 제어 상태 및 왕복 추정치를 대신 유지할 수 있습니다\(MAY\). 기존 경로에서 유지된 혼잡 제어 상태가 실질적으로 다른 특성을 가진 새 경로에서 사용되는 경우 송신자는 혼잡 제어 장치와 RTT 추정기가 적응할 때까지 너무 적극적으로 전송할 수 있습니다. 일반적으로 구현은 새 경로에서 이전 값을 사용할 때 주의하는 것이 좋습니다.\(MUST, MAY\)

두 결과 경로의 왕복 시간이 다를 수 있으므로 엔드포인트가 마이그레이션 기간 동안 여러 주소에서 데이터 및 프로브를 보낼 때 수신자에서 명백한 재정렬이 있을 수 있습니다. 여러 경로에 있는 패킷의 수신자는 여전히 수신된 모든 패킷을 포함하는 ACK 프레임을 보냅니다.

연결 마이그레이션 중에 여러 경로가 사용될 수 있지만 단일 혼잡 제어 컨텍스트 및 단일 손실 복구 컨텍스트\(\[QUIC-RECOVERY\]에 설명된 대로\)가 적절할 수 있습니다. 예를 들어 종점은 이전 경로가 더 이상 필요하지 않다는 것이 확인될 때까지\(섹션 9.3.3에서 설명한 경우와 같이\) 새로운 혼잡 제어 컨텍스트로의 전환을 지연시킬 수 있습니다.

발신자는 프로브 패킷에 대한 예외를 만들 수 있으므로 패킷의 손실 감지가 독립적이고 정체 컨트롤러가 전송 속도를 과도하게 줄이지 않도록 합니다. 엔드포인트는 PATH\_CHALLENGE가 전송될 때 별도의 타이머를 설정할 수 있으며 해당 PATH\_RESPONSE가 수신되면 취소됩니다. PATH\_RESPONSE가 수신되기 전에 타이머가 실행되면 엔드포인트는 새 PATH\_CHALLENGE를 전송하고 더 오랜 시간 동안 타이머를 다시 시작할 수 있습니다. 이 타이머는 \[빠른 복구\]의 섹션 6.2.1에 설명된 대로 설정해야 하며 더 공격적으로 설정하면 안 됩니다\(MUST NOT\).\(MUST NOT\)

---
### **9.5.  Privacy Implications of Connection Migration**

여러 네트워크 경로에서 안정적인 연결 ID를 사용하면 수동 관찰자가 해당 경로 간의 활동을 연관시킬 수 있습니다. 네트워크 사이를 이동하는 엔드포인트는 자신의 활동이 피어 이외의 엔터티에 의해 상호 연관되는 것을 원하지 않을 수 있으므로 섹션 5.1에서 설명한 것처럼 다른 로컬 주소에서 보낼 때 다른 연결 ID가 사용됩니다. 이것이 효과적이려면 엔드포인트는 자신이 제공하는 연결 ID가 다른 엔터티에 의해 연결될 수 없도록 해야 합니다.

언제든지 엔드포인트는 전송 대상 연결 ID를 다른 경로에서 사용되지 않은 값으로 변경할 수 있습니다.\(MAY\)

끝점은 둘 이상의 로컬 주소에서 보낼 때 연결 ID를 재사용해서는 안 됩니다.\(MUST NOT\)

마찬가지로 엔드포인트는 둘 이상의 대상 주소로 보낼 때 연결 ID를 재사용해서는 안 됩니다\(MUST NOT\). 피어 제어 외부의 네트워크 변경으로 인해 엔드포인트는 동일한 대상 연결 ID 필드 값을 가진 새 소스 주소에서 패킷을 수신할 수 있습니다. 이 경우 여전히 전송하는 동안 새 원격 주소와 함께 현재 연결 ID를 계속 사용할 수 있습니다. 동일한 지역 주소에서.\(MUST NOT, MAY\)

연결 ID 재사용에 관한 이러한 요구 사항은 연결 ID 변경 없이 의도하지 않은 경로 변경이 가능하므로 패킷 전송에만 적용됩니다. 예를 들어 네트워크 비활성 기간이 지나면 NAT 리바인딩으로 인해 클라이언트가 전송을 재개할 때 패킷이 새 경로로 전송될 수 있습니다. 끝점은 섹션 9.3에 설명된 대로 이러한 이벤트에 응답합니다.

각각의 새로운 네트워크 경로에서 양방향으로 전송되는 패킷에 대해 서로 다른 연결 ID를 사용하면 서로 다른 네트워크 경로에서 동일한 연결의 패킷을 연결하기 위해 연결 ID를 사용할 필요가 없습니다. 헤더 보호 기능은 패킷 번호를 사용하여 활동을 연관시킬 수 없도록 합니다. 이것은 타이밍 및 크기와 같은 패킷의 다른 속성이 활동을 연관시키는 데 사용되는 것을 막지 않습니다.

엔드포인트는 길이가 0인 연결 ID를 요청한 피어와 마이그레이션을 시작하면 안 됩니다. 새 경로를 통한 트래픽이 이전 경로를 통한 트래픽에 사소하게 연결될 수 있기 때문입니다. 서버가 길이가 0인 연결 ID가 있는 패킷을 올바른 연결에 연결할 수 있는 경우 서버가 다른 정보를 사용하여 패킷을 역다중화하고 있음을 의미합니다. 예를 들어, 서버는 예를 들어 HTTP 대체 서비스\[ALTSVC\]를 사용하여 모든 클라이언트에 고유한 주소를 제공할 수 있습니다. 여러 네트워크 경로에서 패킷의 올바른 라우팅을 허용할 수 있는 정보는 해당 경로의 활동이 피어 이외의 엔터티에 의해 연결되도록 허용합니다.\(SHOULD NOT\)

클라이언트는 비활성 기간 후 트래픽을 보낼 때 새로운 연결 ID, 소스 UDP 포트 또는 IP 주소\(\[RFC8981\] 참조\)로 전환하여 연결 가능성을 줄이고자 할 수 있습니다. 동시에 패킷을 보내는 주소를 변경하면 서버에서 연결 마이그레이션을 감지할 수 있습니다. 이렇게 하면 NAT 리바인딩 또는 실제 마이그레이션을 경험하지 않는 클라이언트에 대해서도 마이그레이션을 지원하는 메커니즘이 실행됩니다. 주소를 변경하면 피어가 혼잡 제어 상태를 재설정할 수 있으므로\(섹션 9.4 참조\) 주소는 드물게 변경되어야 합니다.\(SHOULD\)

사용 가능한 연결 ID를 소진한 엔드포인트는 새 경로를 검색하거나 마이그레이션을 시작할 수 없으며 피어의 마이그레이션 시도 또는 프로브에 응답할 수 없습니다. 마이그레이션이 가능하고 다른 경로로 전송된 패킷이 상관될 수 없도록 하기 위해 엔드포인트는 피어가 마이그레이션하기 전에 새 연결 ID를 제공해야 합니다. 섹션 5.1.1을 참조하십시오. 피어가 사용 가능한 연결 ID를 소진한 경우 마이그레이션 엔드포인트는 새 네트워크 경로에서 전송된 모든 패킷에 NEW\_CONNECTION\_ID 프레임을 포함할 수 있습니다.\(SHOULD\)

---
### **9.6.  Server's Preferred Address**

QUIC을 사용하면 서버가 하나의 IP 주소에서 연결을 수락하고 핸드셰이크 직후 이러한 연결을 더 선호하는 주소로 전송하려고 시도할 수 있습니다. 이는 클라이언트가 처음에 여러 서버에서 공유하는 주소에 연결하지만 연결 안정성을 보장하기 위해 유니캐스트 주소를 사용하는 것을 선호할 때 특히 유용합니다. 이 섹션에서는 연결을 기본 서버 주소로 마이그레이션하기 위한 프로토콜에 대해 설명합니다.

이 문서에 지정된 QUIC 버전에서는 연결 중간에 새 서버 주소로 연결을 마이그레이션하는 기능이 지원되지 않습니다. 클라이언트가 해당 주소로 마이그레이션을 시작하지 않았을 때 클라이언트가 새 서버 주소에서 패킷을 수신하는 경우 클라이언트는 이러한 패킷을 폐기해야 합니다\(SHOULD\).\(SHOULD\)

---
#### **9.6.1.  Communicating a Preferred Address**

서버는 TLS 핸드셰이크에 preferred\_address 전송 매개변수를 포함하여 기본 주소를 전달합니다.

서버는 클라이언트가 네트워크 연결에 가장 적합한 주소를 선택할 수 있도록 각 주소 계열\(IPv4 및 IPv6\)의 선호 주소를 전달할 수 있습니다\(MAY\).\(MAY\)

핸드셰이크가 확인되면 클라이언트는 서버에서 제공한 두 주소 중 하나를 선택하고 경로 유효성 검사를 시작해야 합니다\(섹션 8.2 참조\). 클라이언트는 preferred\_address 전송 매개변수 또는 NEW\_CONNECTION\_ID 프레임에서 가져온 이전에 사용하지 않은 활성 연결 ID를 사용하여 패킷을 구성합니다.\(SHOULD\)

경로 유효성 검사가 성공하는 즉시 클라이언트는 새 연결 ID를 사용하여 새 서버 주소로 모든 향후 패킷 전송을 시작하고 이전 서버 주소 사용을 중단해야 합니다\(SHOULD\). 경로 유효성 검사가 실패하면 클라이언트는 이후의 모든 패킷을 서버의 원래 IP 주소로 계속 전송해야 합니다.\(SHOULD, MUST\)

---
#### **9.6.2.  Migration to a Preferred Address**

원하는 주소로 마이그레이션하는 클라이언트는 마이그레이션하기 전에 선택한 주소를 확인해야 합니다. 섹션 21.5.3 참조.\(MUST\)

서버는 연결을 수락한 후 언제든지 선호하는 IP 주소로 지정된 패킷을 수신할 수 있습니다. 이 패킷에 PATH\_CHALLENGE 프레임이 포함되어 있으면 서버는 섹션 8.2에 따라 PATH\_RESPONSE 프레임이 포함된 패킷을 보냅니다. 서버는 선호하는 주소에서 클라이언트로부터 비프로빙 패킷을 수신하고 서버가 새 경로를 확인할 때까지 원래 주소에서 비프로빙 패킷을 보내야 합니다.\(MUST\)

서버는 선호하는 주소에서 클라이언트로 향하는 경로를 조사해야 합니다. 이는 공격자가 시작한 가짜 마이그레이션을 방지하는 데 도움이 됩니다.\(MUST\)

서버가 경로 유효성 검사를 완료하고 기본 주소에서 가장 큰 패킷 번호가 있는 비프로빙 패킷을 수신하면 서버는 기본 IP 주소에서만 비프로빙 패킷을 클라이언트로 보내기 시작합니다. 서버는 이전 IP 주소에서 수신된 이 연결에 대한 최신 패킷을 삭제해야 합니다\(SHOULD\). 서버는 이전 IP 주소에서 수신된 지연된 패킷을 계속 처리할 수 있습니다\(MAY\).\(SHOULD, MAY\)

서버가 preferred\_address 전송 매개변수에 제공하는 주소는 제공된 연결에 대해서만 유효합니다. 클라이언트는 현재 연결에서 재개되는 연결을 포함하여 다른 연결에 대해 이들을 사용해서는 안 됩니다\(MUST NOT\).\(MUST NOT\)

---
#### **9.6.3.  Interaction of Client Migration and Preferred Address**

클라이언트는 서버의 기본 주소로 마이그레이션하기 전에 연결 마이그레이션을 수행해야 할 수 있습니다. 이 경우 클라이언트는 클라이언트의 새 주소에서 원래 서버 주소와 기본 서버 주소 모두에 대한 경로 유효성 검사를 동시에 수행해야 합니다\(SHOULD\).\(SHOULD\)

서버의 기본 주소에 대한 경로 유효성 검사가 성공하면 클라이언트는 원래 주소의 유효성 검사를 포기하고 서버의 기본 주소를 사용하도록 마이그레이션해야 합니다. 서버의 기본 주소에 대한 경로 검증이 실패했지만 서버의 원래 주소에 대한 검증이 성공한 경우 클라이언트는 새 주소로 마이그레이션하고 서버의 원래 주소로 계속 보낼 수 있습니다.\(MUST, MAY\)

서버의 기본 주소에서 수신된 패킷이 핸드셰이크 중에 클라이언트에서 관찰된 것과 다른 소스 주소를 갖는 경우 서버는 섹션 9.3.1 및 9.3.2에 설명된 대로 잠재적인 공격으로부터 보호해야 합니다. 의도적인 동시 마이그레이션 외에도 클라이언트의 액세스 네트워크가 서버의 기본 주소에 대해 다른 NAT 바인딩을 사용했기 때문에 이 문제가 발생할 수도 있습니다.\(MUST\)

서버는 다른 주소에서 프로브 패킷을 수신하면 클라이언트의 새 주소에 대한 경로 유효성 검사를 시작해야 합니다\(SHOULD\). 섹션 8을 참조하십시오.\(SHOULD\)

새 주소로 마이그레이션하는 클라이언트는 서버에 대해 동일한 주소 패밀리의 기본 주소를 사용해야 합니다.\(SHOULD\)

preferred\_address 전송 매개변수에 제공된 연결 ID는 제공된 주소에 특정하지 않습니다. 이 연결 ID는 클라이언트가 마이그레이션에 사용할 수 있는 연결 ID를 갖도록 하기 위해 제공되지만 클라이언트는 모든 경로에서 이 연결 ID를 사용할 수 있습니다.\(MAY\)

---
### **9.7.  Use of IPv6 Flow Label and Migration**

로컬 API가 IPv6 흐름 레이블 설정을 허용하지 않는 한 IPv6을 사용하여 데이터를 보내는 끝점은 \[RFC6437\]에 따라 IPv6 흐름 레이블을 적용해야 합니다\(SHOULD\).\(SHOULD\)

흐름 레이블 생성은 이전에 사용된 흐름 레이블과의 연결 가능성을 최소화하도록 설계되어야 합니다. 안정적인 흐름 레이블은 여러 경로에서 상관 관계 활동을 가능하게 하기 때문입니다. 섹션 9.5를 참조하십시오.\(MUST\)

\[RFC6437\]은 플로우 레이블을 생성하기 위해 의사 난수 함수를 사용하여 값을 도출할 것을 제안합니다. 흐름 레이블을 생성할 때 소스 및 대상 주소 외에 대상 연결 ID 필드를 포함하면 변경 사항이 관찰 가능한 다른 식별자의 변경 사항과 동기화됩니다. 이러한 입력을 로컬 암호와 결합하는 암호화 해시 함수는 이것이 구현될 수 있는 한 가지 방법입니다.

---
## **10.  Connection Termination**

설정된 QUIC 연결은 다음 세 가지 방법 중 하나로 종료할 수 있습니다.

```text
   *  idle timeout (Section 10.1)

   *  immediate close (Section 10.2)

   *  stateless reset (Section 10.3)
```

엔드포인트는 패킷을 보낼 수 있는 검증된 경로가 없는 경우 연결 상태를 버릴 수 있습니다\(MAY\). 섹션 8.2를 참조하십시오.\(MAY\)

---
### **10.1.  Idle Timeout**

max\_idle\_timeout이 전송 매개변수\(18.2절\)의 끝점에 의해 지정되면 연결이 자동으로 닫히고 두 끝점이 광고하는 max\_idle\_timeout 값의 최소값보다 더 오랫동안 유휴 상태를 유지하면 해당 상태가 삭제됩니다.

각 엔드포인트는 max\_idle\_timeout을 광고하지만 엔드포인트의 유효 값은 광고된 두 값\(또는 하나의 엔드포인트만 0이 아닌 값을 광고하는 경우 광고된 유일한 값\) 중 최소값으로 계산됩니다. max\_idle\_timeout을 발표함으로써 엔드포인트는 유효 값 이전에 연결을 포기하는 경우 즉시 닫기\(섹션 10.2\)를 시작하도록 커밋합니다.

엔드포인트는 피어로부터 패킷을 수신하고 성공적으로 처리하면 유휴 타이머를 다시 시작합니다. 마지막으로 패킷을 수신하고 처리한 이후 다른 응답 확인 패킷이 전송되지 않은 경우 응답 확인 패킷을 보낼 때 엔드포인트는 유휴 타이머를 다시 시작합니다. 패킷을 보낼 때 이 타이머를 다시 시작하면 새 활동이 시작된 후 연결이 닫히지 않습니다.

과도하게 작은 유휴 시간 초과 기간을 피하기 위해 엔드포인트는 유휴 시간 초과 기간을 현재 PTO\(Probe Timeout\)의 최소 3배로 늘려야 합니다. 이를 통해 여러 PTO가 만료될 수 있으므로 유휴 시간 초과 전에 여러 프로브가 전송되고 손실될 수 있습니다.\(MUST\)

---
#### **10.1.1.  Liveness Testing**

유휴 시간 초과 기간이 이러한 패킷이 도착하기 전에 피어에서 만료되었을 수 있기 때문에 유효 시간 초과에 가까운 패킷을 보내는 엔드포인트는 피어에서 패킷을 버릴 위험이 있습니다.

피어가 곧 시간 초과될 수 있는 경우\(예: PTO 내에서\) 연결이 활성 상태인지 테스트하기 위해 엔드포인트는 PING 또는 다른 ack-eliciting 프레임을 보낼 수 있습니다. \[빠른 복구\]의 섹션 6.2를 참조하십시오. 이는 사용 가능한 애플리케이션 데이터를 안전하게 재시도할 수 없는 경우에 특히 유용합니다. 재시도해도 안전한 데이터는 애플리케이션에서 결정합니다.

---
#### **10.1.2.  Deferring Idle Timeout**

엔드포인트는 응답 데이터를 기대하지만 응용 프로그램 데이터를 보내지 않거나 보낼 수 없는 경우 유휴 시간 제한을 피하기 위해 ack-eliciting 패킷을 보내야 할 수 있습니다.

QUIC 구현은 응용 프로그램에 유휴 제한 시간을 연기하는 옵션을 제공할 수 있습니다. 이 기능은 응용 프로그램이 열린 연결과 관련된 상태 손실을 피하려고 하지만 일정 시간 동안 응용 프로그램 데이터를 교환할 것으로 예상하지 않을 때 사용할 수 있습니다. 이 옵션을 사용하면 엔드포인트가 PING 프레임\(19.2절\)을 주기적으로 보낼 수 있으며, 이로 인해 피어가 유휴 시간 초과 기간을 다시 시작하게 됩니다. PING 프레임을 포함하는 패킷을 전송하면 이 패킷이 패킷을 수신한 이후 전송된 첫 번째 ack-eliciting 패킷인 경우에도 이 엔드포인트에 대한 유휴 시간 제한이 다시 시작됩니다. PING 프레임을 보내면 피어가 승인으로 응답하게 되고 엔드포인트에 대한 유휴 시간 초과도 다시 시작됩니다.

QUIC을 사용하는 애플리케이션 프로토콜은 유휴 시간 제한을 연기하는 것이 적절한 시기에 대한 지침을 제공해야 합니다. 불필요한 PING 프레임 전송은 성능에 해로운 영향을 미칠 수 있습니다.\(SHOULD\)

max\_idle\_timeout 전송 매개변수를 사용하여 협상한 시간보다 긴 기간 동안 패킷을 보내거나 받지 않으면 연결 시간이 초과됩니다. 섹션 10을 참조하십시오. 그러나 미들박스의 상태는 그보다 일찍 시간 초과될 수 있습니다. \[RFC4787\]의 REQ-5는 2분의 시간 초과 간격을 권장하지만 경험에 따르면 대부분의 미들박스가 UDP 흐름\[GATEWAY\]에 대한 상태를 잃지 않도록 하려면 30초마다 패킷을 전송해야 합니다.

---
### **10.2.  Immediate Close**

끝점은 연결을 즉시 종료하기 위해 CONNECTION\_CLOSE 프레임\(19.19절\)을 보냅니다. CONNECTION\_CLOSE 프레임은 모든 스트림이 즉시 닫히도록 합니다. 오픈 스트림은 암시적으로 재설정되는 것으로 가정할 수 있습니다.

CONNECTION\_CLOSE 프레임을 보낸 후 엔드포인트는 즉시 종료 상태로 들어갑니다. 섹션 10.2.1을 참조하십시오. CONNECTION\_CLOSE 프레임을 수신한 후 엔드포인트는 드레이닝 상태에 들어갑니다. 섹션 10.2.2를 참조하십시오.

프로토콜을 위반하면 즉시 종료됩니다.

애플리케이션 프로토콜이 연결을 종료하도록 정렬한 후에 즉시 종료를 사용할 수 있습니다. 애플리케이션 프로토콜이 정상적인 종료를 협상한 후일 수 있습니다. 애플리케이션 프로토콜은 두 애플리케이션 엔드포인트가 연결을 닫을 수 있다는 데 동의하는 데 필요한 메시지를 교환할 수 있으며, 그 후에 애플리케이션은 QUIC이 연결을 닫도록 요청합니다. 결과적으로 QUIC이 연결을 종료하면 애플리케이션 제공 오류 코드가 포함된 CONNECTION\_CLOSE 프레임을 사용하여 피어에 종료 신호를 보냅니다.

연결 닫기 및 배수 연결 상태는 연결이 완전히 닫히고 지연되거나 재정렬된 패킷이 적절하게 삭제되도록 하기 위해 존재합니다. 이러한 상태는 \[빠른 복구\]에 정의된 대로 현재 PTO 간격의 최소 3배 동안 지속되어야 합니다\(SHOULD\).\(SHOULD\)

닫기 또는 드레이닝 상태를 종료하기 전에 연결 상태를 처리하면 엔드포인트가 늦게 도착하는 패킷을 수신할 때 불필요하게 Stateless Reset을 생성할 수 있습니다. UDP 소켓을 닫을 수 있는 패킷과 같이 늦게 도착하는 패킷이 응답을 유도하지 않도록 하는 몇 가지 대체 수단이 있는 엔드포인트는 더 빠른 리소스 복구를 허용하기 위해 이러한 상태를 더 일찍 종료할 수 있습니다\(MAY\). 새 연결을 수락하기 위해 열린 소켓을 유지하는 서버는 닫힘 또는 드레이닝 상태를 조기에 종료하면 안 됩니다\(SHOULD NOT\).\(MAY, SHOULD NOT\)

닫힘 또는 드레이닝 상태가 종료되면 끝점은 모든 연결 상태를 폐기해야 합니다\(SHOULD\). 엔드포인트는 이 연결에 속하는 추가 수신 패킷에 대한 응답으로 Stateless Reset을 보낼 수 있습니다\(MAY\).\(SHOULD, MAY\)

---
#### **10.2.1.  Closing Connection State**

엔드포인트는 즉시 닫기를 시작한 후 닫기 상태로 들어갑니다.

종료 상태에서 끝점은 CONNECTION\_CLOSE 프레임을 포함하는 패킷을 생성하고 연결에 속하는 패킷을 식별하는 데 필요한 정보만 보유합니다. 닫힘 상태의 엔드포인트는 연결에 기인한 수신 패킷에 대한 응답으로 CONNECTION\_CLOSE 프레임이 포함된 패킷을 보냅니다.

엔드포인트는 종료 상태에서 패킷을 생성하는 속도를 제한해야 합니다\(SHOULD\). 예를 들어 엔드포인트는 수신된 패킷에 응답하기 전에 점진적으로 증가하는 수신 패킷 수 또는 시간을 기다릴 수 있습니다.\(SHOULD\)

엔드포인트의 선택된 연결 ID 및 QUIC 버전은 연결 종료를 위한 패킷을 식별하기에 충분한 정보입니다. 끝점은 다른 모든 연결 상태를 버릴 수 있습니다\(MAY\). 닫는 엔드포인트는 수신된 프레임을 처리하는 데 필요하지 않습니다. 엔드포인트는 CONNECTION\_CLOSE 프레임을 읽고 처리할 수 있도록 들어오는 패킷에 대한 패킷 보호 키를 보유할 수 있습니다\(MAY\).\(MAY, MAY\)

끝점은 종료 상태에 들어갈 때 패킷 보호 키를 삭제하고 수신된 UDP 데이터그램에 대한 응답으로 CONNECTION\_CLOSE 프레임을 포함하는 패킷을 보낼 수 있습니다. 그러나 패킷 보호 키를 폐기하는 엔드포인트는 유효하지 않은 패킷을 식별하고 폐기할 수 없습니다. 증폭 공격에 사용되는 것을 방지하기 위해 이러한 엔드포인트는 전송하는 패킷의 누적 크기를 수신되고 연결에 기인한 패킷의 누적 크기의 3배로 제한해야 합니다. 종료 연결에 대해 엔드포인트가 유지하는 상태를 최소화하기 위해 엔드포인트는 수신된 패킷에 대한 응답으로 정확히 동일한 패킷을 보낼 수 있습니다\(MAY\).\(MAY, MUST, MAY\)

- | 참고: 닫는 패킷의 재전송을 허용하는 것은 | 새 패킷 번호를 사용해야 한다는 요구 사항에 대한 예외 | 각 패킷에 대해; 섹션 12.3을 참조하십시오. 새 패킷 번호 보내기 | 주로 손실 복구 및 혼잡에 유리합니다 | 닫힌 제어와 관련이 없을 것으로 예상되는 | 연결. 최종 패킷을 재전송하는 데 더 적게 필요 | 상태.

종료 상태에 있는 동안 엔드포인트는 새 소스 주소에서 패킷을 수신할 수 있으며 이는 연결 마이그레이션을 나타낼 수 있습니다. 섹션 9를 참조하십시오. 종료 상태의 엔드포인트는 확인되지 않은 주소에서 수신한 패킷을 폐기하거나 확인되지 않은 주소로 보내는 패킷의 누적 크기를 해당 주소에서 수신한 패킷 크기의 3배로 제한해야 합니다.\(MUST\)

엔드포인트는 닫힐 때 키 업데이트를 처리할 것으로 예상되지 않습니다\(\[QUIC-TLS\]의 섹션 6\). 키 업데이트는 엔드포인트가 이후에 수신된 패킷을 처리할 수 없기 때문에 종료 상태에서 드레이닝 상태로 이동하는 것을 방지할 수 있지만 그렇지 않으면 영향을 미치지 않습니다.

---
#### **10.2.2.  Draining Connection State**

엔드포인트가 CONNECTION\_CLOSE 프레임을 수신하면 드레이닝 상태에 들어가며, 이는 해당 피어가 닫히거나 드레이닝 중임을 나타냅니다. 그 외에는 종료 상태와 동일하지만 드레이닝 상태의 엔드포인트는 패킷을 보내면 안 됩니다\(MUST NOT\). 연결이 드레이닝 상태에 있으면 패킷 보호 키를 유지할 필요가 없습니다.\(MUST NOT\)

CONNECTION\_CLOSE 프레임을 수신하는 엔드포인트는 적절한 경우 NO\_ERROR 코드를 사용하여 배출 상태에 들어가기 전에 CONNECTION\_CLOSE 프레임을 포함하는 단일 패킷을 보낼 수 있습니다. 엔드포인트는 추가 패킷을 보내면 안 됩니다\(MUST NOT\). 이렇게 하면 엔드포인트 중 하나가 종료 상태를 종료할 때까지 CONNECTION\_CLOSE 프레임이 지속적으로 교환될 수 있습니다.\(MAY, MUST NOT\)

엔드포인트는 CONNECTION\_CLOSE 프레임을 수신하는 경우 닫힘 상태에서 드레이닝 상태로 들어갈 수 있습니다. 이는 피어도 닫히거나 드레이닝 중임을 나타냅니다. 이 경우 폐쇄 상태가 종료되었을 때 배수 상태가 종료됩니다. 즉, 엔드포인트는 동일한 종료 시간을 사용하지만 이 연결에서 모든 패킷의 전송을 중단합니다.\(MAY\)

---
#### **10.2.3.  Immediate Close during the Handshake**

CONNECTION\_CLOSE 프레임을 보낼 때 목표는 피어가 프레임을 처리하도록 하는 것입니다. 일반적으로 이것은 패킷이 폐기되는 것을 방지하기 위해 패킷 보호 수준이 가장 높은 패킷의 프레임을 보내는 것을 의미합니다. 핸드셰이크가 확인된 후\(\[QUIC-TLS\]의 섹션 4.1.2 참조\) 엔드포인트는 1-RTT 패킷의 모든 CONNECTION\_CLOSE 프레임을 전송해야 합니다\(MUST\). 그러나 핸드셰이크를 확인하기 전에 피어에서 고급 패킷 보호 키를 사용할 수 없으므로 다른 CONNECTION\_CLOSE 프레임을 더 낮은 패킷 보호 수준을 사용하는 패킷으로 보낼 수 있습니다. 더 구체적으로:\(MUST, MAY\)

\* 클라이언트는 서버에 핸드셰이크 키가 있는지 항상 알 수 있지만\(섹션 17.2.2.1 참조\) 서버는 클라이언트에 핸드셰이크 키가 있는지 여부를 모를 수 있습니다. 이러한 상황에서 서버는 핸드셰이크 및 초기 패킷 모두에서 CONNECTION\_CLOSE 프레임을 보내어 적어도 하나는 클라이언트에서 처리할 수 있도록 해야 합니다.\(SHOULD\)

\* 0-RTT 패킷에서 CONNECTION\_CLOSE 프레임을 보내는 클라이언트는 서버가 0-RTT를 수락했는지 확인할 수 없습니다. 초기 패킷에서 CONNECTION\_CLOSE 프레임을 보내면 애플리케이션 오류 코드가 수신되지 않더라도 서버가 종료 신호를 수신할 가능성이 높아집니다.

\* 핸드셰이크를 확인하기 전에 피어는 1-RTT 패킷을 처리하지 못할 수 있으므로 엔드포인트는 핸드셰이크와 1-RTT 패킷 모두에서 CONNECTION\_CLOSE 프레임을 보내야 합니다. 서버는 또한 초기 패킷에서 CONNECTION\_CLOSE 프레임을 보내야 합니다\(SHOULD\).\(SHOULD, SHOULD\)

초기 또는 핸드셰이크 패킷에서 0x1d 유형의 CONNECTION\_CLOSE를 보내면 애플리케이션 상태가 노출되거나 애플리케이션 상태를 변경하는 데 사용될 수 있습니다. 0x1d 유형의 CONNECTION\_CLOSE는 초기 또는 핸드셰이크 패킷에서 프레임을 보낼 때 0x1c 유형의 CONNECTION\_CLOSE로 대체되어야 합니다. 그렇지 않으면 애플리케이션 상태에 대한 정보가 노출될 수 있습니다. Endpoints는 Reason Phrase 필드의 값을 지워야 하며 0x1c 유형의 CONNECTION\_CLOSE로 변환할 때 APPLICATION\_ERROR 코드를 사용해야 합니다\(SHOULD\).\(MUST, MUST\)

여러 패킷 유형으로 전송된 CONNECTION\_CLOSE 프레임은 단일 UDP 데이터그램으로 통합될 수 있습니다. 섹션 12.2를 참조하십시오.

끝점은 초기 패킷에서 CONNECTION\_CLOSE 프레임을 보낼 수 있습니다. 이는 초기 또는 핸드셰이크 패킷에서 수신된 인증되지 않은 정보에 대한 응답일 수 있습니다. 이러한 즉시 종료는 합법적인 연결을 서비스 거부에 노출시킬 수 있습니다. QUIC에는 핸드셰이크 중 온패스 공격에 대한 방어 조치가 포함되어 있지 않습니다. 섹션 21.2를 참조하십시오. 그러나 합법적인 피어에 대한 오류에 대한 피드백을 줄이는 대가로 엔드포인트가 CONNECTION\_CLOSE와의 연결을 종료하는 대신 불법 패킷을 폐기하는 경우 일부 형태의 서비스 거부가 공격자에게 더 어려워질 수 있습니다. 이러한 이유로 엔드포인트는 인증이 부족한 패킷에서 오류가 감지되면 즉시 닫히지 않고 패킷을 버릴 수 있습니다\(MAY\).\(MAY\)

초기 패킷에서 오류를 감지한 서버와 같이 상태가 설정되지 않은 엔드포인트는 종료 상태로 들어가지 않습니다. 연결 상태가 없는 끝점은 CONNECTION\_CLOSE 프레임을 보낼 때 닫힘 또는 드레이닝 기간에 들어가지 않습니다.

---
### **10.3.  Stateless Reset**

상태 비저장 재설정은 연결 상태에 대한 액세스 권한이 없는 엔드포인트에 대한 최후의 수단 옵션으로 제공됩니다. 충돌 또는 중단으로 인해 피어가 연결을 제대로 계속할 수 없는 끝점으로 데이터를 계속 보낼 수 있습니다. 엔드포인트는 활성 연결과 연결할 수 없는 패킷 수신에 대한 응답으로 Stateless Reset을 보낼 수 있습니다\(MAY\).\(MAY\)

상태 비저장 재설정은 활성 연결의 오류를 표시하는 데 적합하지 않습니다. 치명적인 연결 오류를 전달하려는 엔드포인트는 가능한 경우 CONNECTION\_CLOSE 프레임을 사용해야 합니다.\(MUST\)

이 프로세스를 지원하기 위해 엔드포인트는 추측하기 어려운 16바이트 값인 상태 비저장 재설정 토큰을 발행합니다. 이후에 피어가 상태 비저장 재설정 토큰에서 끝나는 UDP 데이터그램인 상태 비저장 재설정을 수신하면 피어는 즉시 연결을 종료합니다.

상태 비저장 재설정 토큰은 연결 ID에 따라 다릅니다. 엔드포인트는 NEW\_CONNECTION\_ID 프레임의 Stateless Reset Token 필드에 값을 포함하여 Stateless 재설정 토큰을 발행합니다. 서버는 또한 핸드셰이크 중에 선택한 연결 ID에 적용되는 핸드셰이크 중에 stateless\_reset\_token 전송 매개변수를 발행할 수 있습니다. 이러한 교환은 암호화로 보호되므로 클라이언트와 서버만 해당 값을 알 수 있습니다. 전송 매개변수에 기밀 보호가 없기 때문에 클라이언트는 stateless\_reset\_token 전송 매개변수를 사용할 수 없습니다.

관련 연결 ID가 RETIRE\_CONNECTION\_ID 프레임\(19.16절\)을 통해 만료되면 토큰이 무효화됩니다.

처리할 수 없는 패킷을 수신하는 끝점은 다음 레이아웃으로 패킷을 보냅니다\(섹션 1.3 참조\).

```text
   Stateless Reset {
     Fixed Bits (2) = 1,
     Unpredictable Bits (38..),
     Stateless Reset Token (128),
   }

                         Figure 10: Stateless Reset
```

이 디자인은 Stateless Reset이 가능한 한 짧은 헤더가 있는 일반 패킷과 구별할 수 없도록 합니다.

Stateless Reset은 패킷 헤더의 처음 두 비트부터 시작하여 전체 UDP 데이터그램을 사용합니다. 첫 번째 바이트의 나머지 부분과 그 뒤에 오는 임의의 바이트 수는 무작위와 구분할 수 없는 값으로 설정됩니다. 데이터그램의 마지막 16바이트는 상태 비저장 재설정 토큰을 포함합니다.\(SHOULD\)

의도된 수신자 이외의 엔터티에게는 Stateless Reset이 짧은 헤더가 있는 패킷으로 나타납니다. Stateless Reset이 유효한 QUIC 패킷으로 나타나려면 Unpredictable Bits 필드에 최소 38비트의 데이터\(또는 5바이트, 2개의 고정 비트를 뺀 값\)가 포함되어야 합니다.

21바이트의 결과 최소 크기는 수신자가 연결 ID를 사용해야 하는 경우 Stateless Reset이 다른 패킷과 구별하기 어렵다는 것을 보장하지 않습니다. 이를 달성하기 위해 엔드포인트는 보내는 모든 패킷이 피어가 패킷에 포함하도록 요청하는 최소 연결 ID 길이보다 최소 22바이트 더 길도록 해야 하며 필요에 따라 PADDING 프레임을 추가해야 합니다. 이렇게 하면 피어가 보낸 모든 상태 비저장 재설정이 끝점으로 보낸 유효한 패킷과 구별할 수 없습니다. 43바이트 이하의 패킷에 대한 응답으로 Stateless Reset을 보내는 엔드포인트는 응답하는 패킷보다 1바이트 더 짧은 Stateless Reset을 보내야 합니다\(SHOULD\).\(SHOULD, SHOULD\)

이러한 값은 상태 비저장 재설정 토큰이 패킷 보호 AEAD의 최소 확장과 동일한 길이라고 가정합니다. 끝점이 더 큰 최소 확장으로 패킷 보호 체계를 협상할 수 있는 경우 예측할 수 없는 추가 바이트가 필요합니다.

엔드포인트는 증폭에 사용되는 것을 피하기 위해 수신하는 패킷보다 3배 이상 큰 Stateless Reset을 보내면 안 됩니다\(MUST NOT\). 섹션 10.3.3은 Stateless Reset 크기에 대한 추가 제한을 설명합니다.\(MUST NOT\)

엔드포인트는 유효한 QUIC 패킷이 되기에는 너무 작은 패킷을 폐기해야 합니다\(MUST\). 예를 들어, \[QUIC-TLS\]에 정의된 AEAD 기능 세트를 사용하면 21바이트보다 작은 짧은 헤더 패킷은 유효하지 않습니다.\(MUST\)

엔드포인트는 짧은 헤더가 있는 패킷 형식의 상태 비저장 재설정을 보내야 합니다. 그러나 엔드포인트는 다른 QUIC 버전에서 긴 헤더의 사용을 허용할 수 있으므로 유효한 상태 비저장 재설정 토큰으로 끝나는 모든 패킷을 상태 비저장 재설정으로 처리해야 합니다\(MUST\).\(MUST, MUST\)

끝점은 긴 헤더가 있는 패킷에 대한 응답으로 Stateless Reset을 보낼 수 있습니다\(MAY\). 상태 비저장 재설정 전송은 피어에서 상태 비저장 재설정 토큰을 사용할 수 있기 전에는 유효하지 않습니다. 이 QUIC 버전에서 긴 헤더가 있는 패킷은 연결 설정 중에만 사용됩니다. 상태 비저장 재설정 토큰은 연결 설정이 완료되거나 거의 완료될 때까지 사용할 수 없기 때문에 헤더가 긴 알 수 없는 패킷을 무시하는 것은 상태 비저장 재설정을 보내는 것만큼 효과적일 수 있습니다.\(MAY\)

엔드포인트는 헤더가 짧은 패킷에서 소스 연결 ID를 결정할 수 없습니다. 따라서 Stateless Reset에서 대상 연결 ID를 설정할 수 없습니다. 따라서 대상 연결 ID는 이전 패킷에서 사용된 값과 다릅니다. 임의의 대상 연결 ID는 연결 ID가 NEW\_CONNECTION\_ID 프레임을 사용하여 제공된 새 연결 ID로 이동한 결과인 것처럼 보이게 합니다. 섹션 19.15를 참조하십시오.

무작위 연결 ID를 사용하면 두 가지 문제가 발생합니다.

\* 패킷이 피어에 도달하지 못할 수 있습니다. 목적지가

- 연결 ID는 피어를 향한 라우팅에 중요하므로 이 패킷이 잘못 라우팅될 수 있습니다. 이는 응답으로 또 다른 Stateless Reset을 트리거할 수도 있습니다. 섹션 10.3.3을 참조하십시오. 올바르게 라우팅되지 않은 상태 비저장 재설정은 비효율적인 오류 감지 및 복구 메커니즘입니다. 이 경우 엔드포인트는 연결 실패를 감지하기 위해 타이머와 같은 다른 방법에 의존해야 합니다.

\* 임의로 생성된 연결 ID는 피어 이외의 엔터티에서 이를 잠재적인 Stateless Reset으로 식별하는 데 사용할 수 있습니다. 때때로 다른 연결 ID를 사용하는 엔드포인트는 이에 대해 약간의 불확실성을 유발할 수 있습니다.

이 상태 비저장 재설정 설계는 QUIC 버전 1에만 적용됩니다. QUIC의 여러 버전을 지원하는 엔드포인트는 엔드포인트가 지원할 수 있는\(또는 상태를 잃기 전에 지원했을 수 있는\) 모든 버전을 지원하는 피어가 수락할 상태 비저장 재설정을 생성해야 합니다. . QUIC의 새 버전 설계자는 이를 인식하고 \(1\) 이 설계를 재사용하거나 \(2\) 데이터 전달을 위해 마지막 16바이트 이외의 패킷 부분을 사용해야 합니다.

---
#### **10.3.1.  Detecting a Stateless Reset**

엔드포인트는 UDP 데이터그램의 후행 16바이트를 사용하여 잠재적인 상태 비저장 재설정을 감지합니다. 끝점은 최근에 보낸 데이터그램의 연결 ID 및 원격 주소와 관련된 모든 상태 비저장 재설정 토큰을 기억합니다. 여기에는 NEW\_CONNECTION\_ID 프레임의 Stateless Reset Token 필드 값과 서버의 전송 매개변수가 포함되지만 사용되지 않거나 만료된 연결 ID와 연결된 Stateless 재설정 토큰은 제외됩니다. 끝점은 데이터그램의 마지막 16바이트를 데이터그램이 수신된 원격 주소와 관련된 모든 상태 비저장 재설정 토큰과 비교하여 수신된 데이터그램을 상태 비저장 재설정으로 식별합니다.

이 비교는 모든 인바운드 데이터그램에 대해 수행할 수 있습니다. 엔드포인트는 데이터그램의 패킷이 성공적으로 처리되면 이 검사를 건너뛸 수 있습니다\(MAY\). 그러나 들어오는 데이터그램의 첫 번째 패킷이 연결과 연관될 수 없거나 해독될 수 없을 때 비교를 수행해야 합니다.\(MAY, MUST\)

엔드포인트는 사용하지 않은 연결 ID 또는 만료된 연결 ID와 관련된 상태 비저장 재설정 토큰을 확인하면 안 됩니다\(MUST NOT\).\(MUST NOT\)

데이터그램을 무상태 재설정 토큰 값과 비교할 때 엔드포인트는 토큰 값에 대한 정보를 유출하지 않고 비교를 수행해야 합니다. 예를 들어, 일정한 시간에 이 비교를 수행하면 타이밍 사이드 채널을 통한 정보 유출로부터 개별 상태 비저장 재설정 토큰의 값을 보호할 수 있습니다. 또 다른 접근 방식은 원시 토큰 값 대신 상태 비저장 재설정 토큰의 변환된 값을 저장하고 비교하는 것입니다. 여기서 변환은 비밀 키\(예: 블록 암호, 해시 메시지 인증 코드\(HMAC\)\)를 사용하여 암호학적으로 안전한 의사 난수 함수로 정의됩니다. \[RFC2104\]\). 엔드포인트는 패킷이 성공적으로 해독되었는지 여부 또는 유효한 상태 비저장 재설정 토큰 수에 대한 정보를 보호할 것으로 예상되지 않습니다.\(MUST\)

데이터그램의 마지막 16바이트가 상태 비저장 재설정 토큰과 값이 동일하면 엔드포인트는 드레이닝 기간에 들어가야 하며 이 연결에서 더 이상 패킷을 보내지 않아야 합니다.\(MUST\)

---
#### **10.3.2.  Calculating a Stateless Reset Token**

상태 비저장 재설정 토큰은 추측하기 어려워야 합니다. 비상태 재설정 토큰을 생성하기 위해 엔드포인트는 생성하는 모든 연결에 대해 \[RANDOM\] 비밀을 무작위로 생성할 수 있습니다. 그러나 이것은 클러스터에 여러 인스턴스가 있는 경우 조정 문제 또는 상태를 잃을 수 있는 엔드포인트에 대한 스토리지 문제를 나타냅니다. 상태 비저장 재설정은 상태가 손실된 경우를 처리하기 위해 특별히 존재하므로 이 접근 방식은 차선책입니다.\(MUST\)

정적 키와 끝점에서 선택한 연결 ID\(섹션 5.1 참조\)를 입력으로 사용하는 의사 난수 함수를 사용하여 증명을 생성하여 동일한 끝점에 대한 모든 연결에서 단일 정적 키를 사용할 수 있습니다. 엔드포인트는 HMAC\[RFC2104\]\(예: HMAC\(static\_key, connection\_id\)\) 또는 HMAC 기반 키 파생 함수\(HKDF\)\[RFC5869\]\(예: 정적 키를 입력 키 자료로 사용, 연결 ID 포함\)를 사용할 수 있습니다. 소금으로\). 이 함수의 출력은 해당 연결에 대한 상태 비저장 재설정 토큰을 생성하기 위해 16바이트로 잘립니다.

상태를 잃은 엔드포인트는 동일한 방법을 사용하여 유효한 상태 비저장 재설정 토큰을 생성할 수 있습니다. 연결 ID는 엔드포인트가 수신하는 패킷에서 가져옵니다.

이 디자인은 엔드포인트가 패킷의 연결 ID를 사용하여 연결을 재설정할 수 있도록 항상 패킷의 연결 ID를 전송하는 피어에 의존합니다. 이 디자인을 사용하는 끝점은 모든 연결에 대해 동일한 연결 ID 길이를 사용하거나 상태 없이 복구될 수 있도록 연결 ID의 길이를 인코딩해야 합니다. 또한 길이가 0인 연결 ID를 제공할 수 없습니다.\(MUST\)

상태 비저장 재설정 토큰을 공개하면 모든 엔터티가 연결을 종료할 수 있으므로 값은 한 번만 사용할 수 있습니다. 비상태 재설정 토큰을 선택하는 이 방법은 연결 ID와 정적 키의 조합이 다른 연결에 사용되어서는 안 된다는 것을 의미합니다. 서비스 거부 공격은 정적 키를 공유하는 인스턴스에서 동일한 연결 ID를 사용하거나 공격자가 상태는 없지만 정적 키는 동일한 인스턴스로 패킷을 라우팅할 수 있는 경우 가능합니다. 섹션 21.11을 참조하십시오. 상태 비저장 재설정 토큰을 공개하여 재설정된 연결의 연결 ID는 정적 키를 공유하는 노드에서 새 연결에 재사용되어서는 안 됩니다\(MUST NOT\).\(MUST NOT, MUST NOT\)

동일한 상태 비저장 재설정 토큰을 여러 연결 ID에 사용해서는 안 됩니다\(MUST NOT\). 엔드포인트는 새 값을 모든 이전 값과 비교할 필요가 없지만 중복 값은 PROTOCOL\_VIOLATION 유형의 연결 오류로 처리될 수 있습니다\(MAY\).\(MUST NOT, MAY\)

상태 비저장 재설정에는 암호화 보호 기능이 없습니다.

---
#### **10.3.3.  Looping**

Stateless Reset의 설계는 Stateless 재설정 토큰을 모르면 유효한 패킷과 구별할 수 없도록 설계되었습니다. 예를 들어, 서버가 Stateless Reset을 다른 서버로 보내는 경우 응답으로 또 다른 Stateless Reset을 수신하여 무한 교환이 발생할 수 있습니다.

엔드포인트는 루핑을 방지하기에 충분한 상태를 유지하지 않는 한 자신이 전송하는 모든 Stateless Reset이 트리거한 패킷보다 작도록 해야 합니다\(MUST\). 루프가 발생하면 결과적으로 패킷이 너무 작아 응답을 트리거할 수 없게 됩니다.\(MUST\)

엔드포인트는 전송한 상태 비저장 재설정 수를 기억하고 한도에 도달하면 새 상태 비저장 재설정 생성을 중지할 수 있습니다. 서로 다른 원격 주소에 대해 별도의 제한을 사용하면 다른 피어 또는 연결이 제한을 소진했을 때 상태 비저장 재설정을 사용하여 연결을 닫을 수 있습니다.

41바이트보다 작은 상태 비저장 재설정은 피어의 연결 ID 길이에 따라 관찰자가 상태 비저장 재설정으로 식별할 수 있습니다. 반대로, 작은 패킷에 대한 응답으로 Stateless Reset을 보내지 않으면 매우 작은 패킷만 전송되는 끊어진 연결의 경우를 감지하는 데 Stateless Reset이 유용하지 않을 수 있습니다. 이러한 실패는 타이머와 같은 다른 수단에 의해서만 감지될 수 있습니다.

---
## **11.  Error Handling**

오류를 감지하는 엔드포인트는 해당 피어에 해당 오류의 존재를 알리는 신호를 보내야 합니다\(SHOULD\). 전송 수준 및 응용 프로그램 수준 오류는 모두 전체 연결에 영향을 줄 수 있습니다. 섹션 11.1을 참조하십시오. 애플리케이션 수준 오류만 단일 스트림으로 격리할 수 있습니다. 섹션 11.2를 참조하십시오.\(SHOULD\)

가장 적절한 오류 코드\(섹션 20\)는 오류를 알리는 프레임에 포함되어야 합니다\(SHOULD\). 이 사양이 오류 조건을 식별하는 경우 사용되는 오류 코드도 식별합니다. 이들은 요구 사항으로 표현되지만 다른 구현 전략으로 인해 다른 오류가 보고될 수 있습니다. 특히 엔드포인트는 오류 조건을 감지할 때 적용 가능한 모든 오류 코드를 사용할 수 있습니다\(MAY\). 일반 오류 코드\(예: PROTOCOL\_VIOLATION 또는 INTERNAL\_ERROR\)는 항상 특정 오류 코드 대신 사용할 수 있습니다.\(SHOULD, MAY\)

무상태 재설정\(섹션 10.3\)은 CONNECTION\_CLOSE 또는 RESET\_STREAM 프레임으로 신호를 보낼 수 있는 오류에는 적합하지 않습니다. 상태 비저장 재설정은 연결에서 프레임을 전송하는 데 필요한 상태가 있는 엔드포인트에서 사용해서는 안 됩니다\(MUST NOT\).\(MUST NOT\)

---
### **11.1.  Connection Errors**

프로토콜 의미론의 명백한 위반 또는 전체 연결에 영향을 미치는 상태 손상과 같이 연결을 사용할 수 없게 만드는 오류는 CONNECTION\_CLOSE 프레임\(섹션 19.19\)을 사용하여 신호를 보내야 합니다.\(MUST\)

애플리케이션별 프로토콜 오류는 프레임 유형이 0x1d인 CONNECTION\_CLOSE 프레임을 사용하여 신호를 보냅니다. 이 문서에 설명된 모든 오류를 포함하여 전송에 특정한 오류는 프레임 유형이 0x1c인 CONNECTION\_CLOSE 프레임에서 전달됩니다.

CONNECTION\_CLOSE 프레임이 손실된 패킷으로 전송될 수 있습니다. 끝점은 종료된 연결에서 더 많은 패킷을 수신하는 경우 CONNECTION\_CLOSE 프레임을 포함하는 패킷을 재전송하도록 준비해야 합니다\(SHOULD\). 재전송 횟수와 이 최종 패킷이 전송되는 시간을 제한하면 종료된 연결에 소요되는 노력이 제한됩니다.\(SHOULD\)

CONNECTION\_CLOSE 프레임을 포함하는 패킷을 재전송하지 않기로 선택한 엔드포인트는 피어가 그러한 첫 번째 패킷을 놓칠 위험이 있습니다. 종료된 연결에 대한 데이터를 계속 수신하는 끝점에 사용할 수 있는 유일한 메커니즘은 상태 비저장 재설정 프로세스를 시도하는 것입니다\(10.3절\).

초기 패킷에 대한 AEAD는 강력한 인증을 제공하지 않으므로 엔드포인트는 유효하지 않은 초기 패킷을 버릴 수 있습니다. 이 사양이 달리 연결 오류를 요구하는 경우에도 초기 패킷 폐기가 허용됩니다. 끝점은 패킷의 프레임을 처리하지 않거나 처리 결과를 되돌리는 경우에만 패킷을 버릴 수 있습니다. 유효하지 않은 초기 패킷 폐기는 서비스 거부에 대한 노출을 줄이는 데 사용될 수 있습니다. 섹션 21.2를 참조하십시오.\(MAY\)

---
### **11.2.  Stream Errors**

응용 프로그램 수준 오류가 단일 스트림에 영향을 주지만 그렇지 않으면 연결을 복구 가능한 상태로 유지하는 경우 끝점은 영향을 받는 스트림만 종료하기 위해 적절한 오류 코드와 함께 RESET\_STREAM 프레임\(19.4절\)을 보낼 수 있습니다.

응용 프로그램 프로토콜을 사용하지 않고 스트림을 재설정하면 응용 프로그램 프로토콜이 복구할 수 없는 상태가 될 수 있습니다. RESET\_STREAM은 QUIC를 사용하는 애플리케이션 프로토콜에 의해서만 시작되어야 합니다.\(MUST\)

RESET\_STREAM에 포함된 애플리케이션 오류 코드의 의미는 애플리케이션 프로토콜에 의해 정의됩니다. 애플리케이션 프로토콜만이 스트림을 종료시킬 수 있습니다. 애플리케이션 프로토콜의 로컬 인스턴스는 직접 API 호출을 사용하고 원격 인스턴스는 자동 RESET\_STREAM을 트리거하는 STOP\_SENDING 프레임을 사용합니다.

애플리케이션 프로토콜은 어느 한쪽 끝점에 의해 조기에 취소된 스트림을 처리하기 위한 규칙을 정의해야 합니다\(SHOULD\).\(SHOULD\)

---
## **12.  Packets and Frames**

QUIC 엔드포인트는 패킷을 교환하여 통신합니다. 패킷에는 기밀성과 무결성 보호 기능이 있습니다. 섹션 12.1을 참조하십시오. 패킷은 UDP 데이터그램으로 전달됩니다. 섹션 12.2를 참조하십시오.

이 QUIC 버전은 연결 설정 중에 긴 패킷 헤더를 사용합니다. 섹션 17.2를 참조하십시오. 헤더가 긴 패킷은 Initial\(17.2.2절\), 0-RTT\(17.2.3절\), Handshake\(17.2.4절\) 및 Retry\(17.2.5절\)입니다. 버전 협상은 긴 헤더가 있는 버전 독립적인 패킷을 사용합니다. 섹션 17.2.1을 참조하십시오.

짧은 헤더가 있는 패킷은 오버헤드를 최소화하도록 설계되었으며 연결이 설정되고 1-RTT 키를 사용할 수 있게 된 후에 사용됩니다. 섹션 17.3을 참조하십시오.

---
### **12.1.  Protected Packets**

QUIC 패킷에는 패킷 유형에 따라 다양한 수준의 암호화 보호가 있습니다. 패킷 보호에 대한 자세한 내용은 \[QUIC-TLS\]에서 확인할 수 있습니다. 이 섹션에는 제공되는 보호 기능에 대한 개요가 포함되어 있습니다.

버전 협상 패킷에는 암호화 보호 기능이 없습니다. \[빠른 불변량\]을 참조하십시오.

재시도 패킷은 우발적인 수정으로부터 보호하기 위해 AEAD 기능\[AEAD\]을 사용합니다.

초기 패킷은 유선에서 볼 수 있는 값을 사용하여 키가 파생되는 AEAD 기능을 사용합니다. 따라서 초기 패킷에는 효과적인 기밀 보호 기능이 없습니다. 패킷 발신자가 네트워크 경로에 있는지 확인하기 위한 초기 보호 기능이 있습니다. 클라이언트로부터 초기 패킷을 수신하는 모든 엔터티는 패킷의 내용을 읽고 양쪽 끝점에서 성공적으로 인증될 초기 패킷을 생성할 수 있도록 하는 키를 복구할 수 있습니다. AEAD는 또한 우발적인 수정으로부터 초기 패킷을 보호합니다.

다른 모든 패킷은 암호화 핸드셰이크에서 파생된 키로 보호됩니다. 암호화 핸드셰이크는 통신하는 엔드포인트만 핸드셰이크, 0-RTT 및 1-RTT 패킷에 해당하는 키를 수신하도록 합니다. 0-RTT 및 1-RTT 키로 보호되는 패킷은 강력한 기밀성과 무결성 보호 기능을 갖습니다.

일부 패킷 유형에 나타나는 패킷 번호 필드에는 헤더 보호의 일부로 적용되는 대체 기밀성 보호 기능이 있습니다. 자세한 내용은 \[QUIC-TLS\]의 섹션 5.4를 참조하십시오. 기본 패킷 번호는 지정된 패킷 번호 공간에서 전송된 각 패킷과 함께 증가합니다. 자세한 내용은 섹션 12.3을 참조하십시오.

---
### **12.2.  Coalescing Packets**

초기\(섹션 17.2.2\), 0-RTT\(섹션 17.2.3\) 및 핸드셰이크\(섹션 17.2.4\) 패킷에는 패킷의 끝을 결정하는 길이 필드가 포함되어 있습니다. 길이에는 패킷 번호 및 페이로드 필드가 모두 포함되며 둘 다 기밀로 보호되고 처음에는 길이를 알 수 없습니다. 페이로드 필드의 길이는 헤더 보호가 제거되면 학습됩니다.

송신자는 길이 필드를 사용하여 여러 QUIC 패킷을 하나의 UDP 데이터그램으로 병합할 수 있습니다. 이렇게 하면 암호화 핸드셰이크를 완료하고 데이터 전송을 시작하는 데 필요한 UDP 데이터그램의 수를 줄일 수 있습니다. PMTU\(경로 최대 전송 단위\) 프로브를 구성하는 데에도 사용할 수 있습니다. 섹션 14.4.1을 참조하십시오. 수신기는 병합된 패킷을 처리할 수 있어야 합니다.\(MUST\)

증가하는 암호화 수준\(초기, 0-RTT, 핸드셰이크, 1-RTT; \[QUIC-TLS\]의 섹션 4.1.4 참조\) 순서대로 패킷을 병합하면 수신자가 한 번에 모든 패킷을 처리할 수 있을 가능성이 높아집니다. 단일 패스. 짧은 헤더를 가진 패킷은 길이를 포함하지 않으므로 UDP 데이터그램에 포함된 마지막 패킷만 될 수 있습니다. 엔드포인트는 동일한 암호화 수준에서 여러 패킷을 병합하는 대신 동일한 암호화 수준에서 전송되는 경우 단일 패킷에 여러 프레임을 포함해야 합니다\(SHOULD\).\(SHOULD\)

수신자는 UDP 데이터그램에 포함된 첫 번째 패킷의 정보를 기반으로 라우팅할 수 있습니다. 발신자는 서로 다른 연결 ID를 가진 QUIC 패킷을 단일 UDP 데이터그램으로 통합해서는 안 됩니다\(MUST NOT\). 수신자는 데이터그램의 첫 번째 패킷과 다른 대상 연결 ID를 가진 모든 후속 패킷을 무시해야 합니다\(SHOULD\).\(MAY, MUST NOT, SHOULD\)

단일 UDP 데이터그램으로 병합되는 모든 QUIC 패킷은 분리되고 완전합니다. 병합된 QUIC 패킷의 수신자는 각 QUIC 패킷을 개별적으로 처리하고 서로 다른 UDP 데이터그램의 페이로드로 받은 것처럼 개별적으로 승인해야 합니다. 예를 들어, 암호 해독에 실패하는 경우\(키를 사용할 수 없거나 다른 이유로 인해\) 수신자는 나중에 처리하기 위해 패킷을 버리거나 버퍼링할 수 있으며 나머지 패킷 처리를 시도해야 합니다.\(MUST, MUST\)

재시도 패킷\(17.2.5절\), 버전 협상 패킷\(17.2.1절\) 및 짧은 헤더가 있는 패킷\(17.3절\)은 길이 필드를 포함하지 않으므로 동일한 UDP 데이터그램에서 다른 패킷이 뒤따를 수 없습니다. 또한 재시도 또는 버전 협상 패킷이 다른 패킷과 병합되는 상황은 없습니다.

---
### **12.3.  Packet Numbers**

패킷 번호는 0에서 2^62-1 범위의 정수입니다. 이 숫자는 패킷 보호를 위한 암호화 난스를 결정하는 데 사용됩니다. 각 엔드포인트는 전송 및 수신을 위해 별도의 패킷 번호를 유지합니다.

패킷 번호는 ACK 프레임의 Largest Acknowledged 필드\(섹션 19.3\)에서 전체적으로 표현할 수 있어야 하기 때문에 이 범위로 제한됩니다. 그러나 길거나 짧은 헤더에 있는 경우 패킷 번호가 줄어들고 1\~4바이트로 인코딩됩니다. 섹션 17.1을 참조하십시오.

버전 협상\(섹션 17.2.1\) 및 재시도\(섹션 17.2.5\) 패킷에는 패킷 번호가 포함되지 않습니다.

패킷 번호는 QUIC에서 세 개의 공간으로 나뉩니다.

초기 공간: 모든 초기 패킷\(섹션 17.2.2\)이 이 공간에 있습니다.

핸드셰이크 공간: 모든 핸드셰이크 패킷\(섹션 17.2.4\)이 이 공간에 있습니다.

응용 데이터 공간: 모든 0-RTT\(17.2.3절\) 및 1-RTT\(17.3.1절\) 패킷이 이 공간에 있습니다.

\[QUIC-TLS\]에서 설명한 것처럼 각 패킷 유형은 서로 다른 보호 키를 사용합니다.

개념적으로 패킷 번호 공간은 패킷이 처리되고 승인될 수 있는 컨텍스트입니다. 초기 패킷은 초기 패킷 보호 키로만 보낼 수 있으며 초기 패킷이기도 한 패킷에서 확인됩니다. 마찬가지로 Handshake 패킷은 Handshake 암호화 수준에서 전송되며 Handshake 패킷에서만 승인될 수 있습니다.

이는 서로 다른 패킷 번호 공간에서 전송된 데이터 간에 암호화 분리를 적용합니다. 각 공간의 패킷 번호는 패킷 번호 0에서 시작합니다. 동일한 패킷 번호 공간에서 전송되는 후속 패킷은 패킷 번호를 적어도 하나 증가시켜야 합니다.\(MUST\)

0-RTT 및 1-RTT 데이터는 두 패킷 유형 간에 손실 복구 알고리즘을 더 쉽게 구현할 수 있도록 동일한 패킷 번호 공간에 존재합니다.

QUIC 엔드포인트는 한 연결에서 동일한 패킷 번호 공간 내에서 패킷 번호를 재사용해서는 안 됩니다\(MUST NOT\). 전송을 위한 패킷 번호가 2^62-1에 도달하면 전송자는 CONNECTION\_CLOSE 프레임 또는 추가 패킷을 전송하지 않고 연결을 닫아야 합니다. 엔드포인트는 수신한 추가 패킷에 대한 응답으로 Stateless Reset\(섹션 10.3\)을 보낼 수 있습니다\(MAY\).\(MUST NOT, MUST\)

수신자는 동일한 패킷 번호 공간에서 동일한 패킷 번호를 가진 다른 패킷을 처리하지 않은 것이 확실하지 않는 한 새로 보호되지 않은 패킷을 폐기해야 합니다. \[QUIC-TLS\]의 섹션 9.5에 설명된 이유로 패킷 보호를 제거한 후에 중복 억제가 발생해야 합니다\(MUST\).\(MUST, MUST\)

중복을 탐지하기 위해 모든 개별 패킷을 추적하는 엔드포인트는 과도한 상태를 축적할 위험이 있습니다. 모든 패킷이 즉시 삭제되는 최소 패킷 수를 유지하여 중복을 감지하는 데 필요한 데이터를 제한할 수 있습니다. 최소값은 왕복 시간의 큰 변동을 고려해야 하며 여기에는 피어가 훨씬 더 긴 왕복 시간으로 네트워크 경로를 탐색할 가능성이 포함됩니다. 섹션 9를 참조하십시오.

송신측에서의 패킷 번호 인코딩과 수신측에서의 디코딩은 섹션 17.1에 설명되어 있습니다.

---
### **12.4.  Frames and Frame Types**

패킷 보호를 제거한 후 QUIC 패킷의 페이로드는 그림 11과 같이 일련의 완전한 프레임으로 구성됩니다. 버전 협상, 상태 비저장 재설정 및 재시도 패킷에는 프레임이 포함되어 있지 않습니다.

```text
   Packet Payload {
     Frame (8..) ...,
   }

                          Figure 11: QUIC Payload
```

프레임을 포함하는 패킷의 페이로드는 적어도 하나의 프레임을 포함해야 하며 여러 프레임과 여러 프레임 유형을 포함할 수 있습니다. 엔드포인트는 프레임이 없는 패킷 수신을 PROTOCOL\_VIOLATION 유형의 연결 오류로 처리해야 합니다. 프레임은 항상 단일 QUIC 패킷 내에 적합하며 여러 패킷에 걸쳐 있을 수 없습니다.\(MUST, MUST\)

각 프레임은 유형을 나타내는 프레임 유형으로 시작하고 그 뒤에 추가 유형 종속 필드가 옵니다.

```text
   Frame {
     Frame Type (i),
     Type-Dependent Fields (..),
   }

                      Figure 12: Generic Frame Layout
```

표 3은 본 명세서에서 정의된 각 프레임 유형에 대한 정보를 나열하고 요약한 것이다. 이 요약에 대한 설명은 표 뒤에 포함되어 있습니다.

```text
    +============+======================+===============+======+======+
    | Type Value | Frame Type Name      | Definition    | Pkts | Spec |
    +============+======================+===============+======+======+
    | 0x00       | PADDING              | Section 19.1  | IH01 | NP   |
    +------------+----------------------+---------------+------+------+
    | 0x01       | PING                 | Section 19.2  | IH01 |      |
    +------------+----------------------+---------------+------+------+
    | 0x02-0x03  | ACK                  | Section 19.3  | IH_1 | NC   |
    +------------+----------------------+---------------+------+------+
    | 0x04       | RESET_STREAM         | Section 19.4  | __01 |      |
    +------------+----------------------+---------------+------+------+
    | 0x05       | STOP_SENDING         | Section 19.5  | __01 |      |
    +------------+----------------------+---------------+------+------+
    | 0x06       | CRYPTO               | Section 19.6  | IH_1 |      |
    +------------+----------------------+---------------+------+------+
    | 0x07       | NEW_TOKEN            | Section 19.7  | ___1 |      |
    +------------+----------------------+---------------+------+------+
    | 0x08-0x0f  | STREAM               | Section 19.8  | __01 | F    |
    +------------+----------------------+---------------+------+------+
    | 0x10       | MAX_DATA             | Section 19.9  | __01 |      |
    +------------+----------------------+---------------+------+------+
    | 0x11       | MAX_STREAM_DATA      | Section 19.10 | __01 |      |
    +------------+----------------------+---------------+------+------+
    | 0x12-0x13  | MAX_STREAMS          | Section 19.11 | __01 |      |
    +------------+----------------------+---------------+------+------+
    | 0x14       | DATA_BLOCKED         | Section 19.12 | __01 |      |
    +------------+----------------------+---------------+------+------+
    | 0x15       | STREAM_DATA_BLOCKED  | Section 19.13 | __01 |      |
    +------------+----------------------+---------------+------+------+
    | 0x16-0x17  | STREAMS_BLOCKED      | Section 19.14 | __01 |      |
    +------------+----------------------+---------------+------+------+
    | 0x18       | NEW_CONNECTION_ID    | Section 19.15 | __01 | P    |
    +------------+----------------------+---------------+------+------+
    | 0x19       | RETIRE_CONNECTION_ID | Section 19.16 | __01 |      |
    +------------+----------------------+---------------+------+------+
    | 0x1a       | PATH_CHALLENGE       | Section 19.17 | __01 | P    |
    +------------+----------------------+---------------+------+------+
    | 0x1b       | PATH_RESPONSE        | Section 19.18 | ___1 | P    |
    +------------+----------------------+---------------+------+------+
    | 0x1c-0x1d  | CONNECTION_CLOSE     | Section 19.19 | ih01 | N    |
    +------------+----------------------+---------------+------+------+
    | 0x1e       | HANDSHAKE_DONE       | Section 19.20 | ___1 |      |
    +------------+----------------------+---------------+------+------+

                            Table 3: Frame Types
```

각 프레임 유형의 형식과 의미는 섹션 19에서 자세히 설명합니다. 이 섹션의 나머지 부분에서는 중요하고 일반적인 정보에 대한 요약을 제공합니다.

ACK, STREAM, MAX\_STREAMS, STREAMS\_BLOCKED 및 CONNECTION\_CLOSE 프레임의 프레임 유형은 다른 프레임별 플래그를 전달하는 데 사용됩니다. 다른 모든 프레임의 경우 프레임 유형 필드는 단순히 프레임을 식별합니다.

표 3의 "Pkts" 열에는 각 프레임 유형이 나타날 수 있는 패킷 유형이 나열되어 있으며 다음 문자로 표시됩니다.

```text
   I:   Initial (Section 17.2.2)

   H:   Handshake (Section 17.2.4)

   0:   0-RTT (Section 17.2.3)

   1:   1-RTT (Section 17.3.1)
```

ih: 0x1c 유형의 CONNECTION\_CLOSE 프레임만 초기 또는 핸드셰이크 패킷에 나타날 수 있습니다.

이러한 제한 사항에 대한 자세한 내용은 섹션 12.5를 참조하십시오. 모든 프레임은 1-RTT 패킷에 나타날 수 있습니다. 엔드포인트는 허용되지 않는 패킷 유형의 프레임 수신을 PROTOCOL\_VIOLATION 유형의 연결 오류로 처리해야 합니다.\(MUST\)

표 3의 "사양" 열에는 다음 문자로 표시된 대로 프레임 유형의 처리 또는 생성을 관리하는 특수 규칙이 요약되어 있습니다.

N: 이 표시가 있는 프레임만 포함하는 패킷은 승인되지 않습니다. 섹션 13.2를 참조하십시오.

C: 이 표시가 있는 프레임만 포함하는 패킷은 혼잡 제어 목적을 위해 전송 중인 바이트에 포함되지 않습니다. \[빠른 복구\]를 참조하십시오.

P: 이 표시가 있는 프레임만 포함하는 패킷은 연결 마이그레이션 중에 새 네트워크 경로를 검색하는 데 사용할 수 있습니다. 섹션 9.1을 참조하십시오.

F: 이 표시가 있는 프레임의 내용은 흐름 제어됩니다. 섹션 4를 참조하십시오.

표 3의 "Pkts" 및 "Spec" 열은 IANA 레지스트리의 일부를 구성하지 않습니다. 섹션 22.4를 참조하십시오.

엔드포인트는 알 수 없는 유형의 프레임 수신을 FRAME\_ENCODING\_ERROR 유형의 연결 오류로 처리해야 합니다.\(MUST\)

이 버전의 QUIC에서는 모든 프레임이 멱등적입니다. 즉, 유효한 프레임은 두 번 이상 수신되어도 바람직하지 않은 부작용이나 오류가 발생하지 않습니다.

프레임 유형 필드는 한 가지 예외를 제외하고 가변 길이 정수 인코딩\(섹션 16 참조\)을 사용합니다. 프레임 구문 분석의 간단하고 효율적인 구현을 보장하기 위해 프레임 유형은 가능한 가장 짧은 인코딩을 사용해야 합니다. 이 문서에 정의된 프레임 유형의 경우 이는 이러한 값을 2바이트, 4바이트 또는 8바이트 가변 길이 정수로 인코딩할 수 있지만 1바이트 인코딩을 의미합니다. 예를 들어, 0x4001은 값이 1인 가변 길이 정수에 대한 합법적인 2바이트 인코딩이지만 PING 프레임은 항상 값이 0x01인 단일 바이트로 인코딩됩니다. 이 규칙은 현재 및 미래의 모든 QUIC 프레임 유형에 적용됩니다. 끝점은 필요한 것보다 더 긴 인코딩을 사용하는 프레임 유형의 수신을 PROTOCOL\_VIOLATION 유형의 연결 오류로 처리할 수 있습니다\(MAY\).\(MUST, MAY\)

---
### **12.5.  Frames and Number Spaces**

일부 프레임은 다른 패킷 번호 공간에서 금지됩니다. 여기서 규칙은 연결 설정과 관련된 프레임이 일반적으로 모든 패킷 번호 공간의 패킷에 나타날 수 있는 반면 데이터 전송과 관련된 프레임은 애플리케이션 데이터 패킷 번호 공간에만 나타날 수 있다는 점에서 TLS의 규칙을 일반화합니다.

\* PADDING, PING 및 CRYPTO 프레임은 모든 패킷 번호 공간에 나타날 수 있습니다.\(MAY\)

\* QUIC 계층\(유형 0x1c\)의 CONNECTION\_CLOSE 프레임 신호 오류는 모든 패킷 번호 공간에 나타날 수 있습니다. 애플리케이션 오류\(유형 0x1d\)를 신호하는 CONNECTION\_CLOSE 프레임은 애플리케이션 데이터 패킷 번호 공간에만 나타나야 합니다.\(MAY, MUST\)

\* ACK 프레임은 모든 패킷 번호 공간에 나타날 수 있지만 해당 패킷 번호 공간에 나타난 패킷만 확인할 수 있습니다. 그러나 아래에 언급된 바와 같이 0-RTT 패킷은 ACK 프레임을 포함할 수 없습니다.\(MAY\)

\* 다른 모든 프레임 유형은 애플리케이션 데이터 패킷 번호 공간에서만 전송되어야 합니다.\(MUST\)

ACK, CRYPTO, HANDSHAKE\_DONE, NEW\_TOKEN, PATH\_RESPONSE 및 RETIRE\_CONNECTION\_ID와 같은 다양한 이유로 0-RTT 패킷에서 다음 프레임을 보낼 수 없습니다. 서버는 0-RTT 패킷의 이러한 프레임 수신을 PROTOCOL\_VIOLATION 유형의 연결 오류로 처리할 수 있습니다\(MAY\).\(MAY\)

---
## **13.  Packetization and Reliability**

발신자는 QUIC 패킷으로 하나 이상의 프레임을 보냅니다. 섹션 12.4를 참조하십시오.

발신자는 각 QUIC 패킷에 가능한 한 많은 프레임을 포함하여 패킷당 대역폭과 계산 비용을 최소화할 수 있습니다. 보낸 사람은 많은 수의 작은 패킷을 보내는 것을 피하기 위해 최대로 압축되지 않은 패킷을 보내기 전에 여러 프레임을 수집하기 위해 짧은 시간 동안 기다릴 수 있습니다\(MAY\). 구현은 애플리케이션 전송 동작 또는 휴리스틱에 대한 지식을 사용하여 대기 여부와 대기 시간을 결정할 수 있습니다\(MAY\). 이 대기 기간은 구현 결정이며 지연이 애플리케이션에 표시되는 대기 시간을 증가시킬 가능성이 높으므로 구현은 보수적으로 지연되도록 주의해야 합니다.\(MAY, MAY\)

스트림 다중화는 여러 스트림의 STREAM 프레임을 하나 이상의 QUIC 패킷으로 인터리빙하여 달성됩니다. 단일 QUIC 패킷은 하나 이상의 스트림에서 여러 STREAM 프레임을 포함할 수 있습니다.

QUIC의 이점 중 하나는 여러 스트림에서 HOL\(head-of-line\) 차단을 방지하는 것입니다. 패킷 손실이 발생하면 해당 패킷에 데이터가 있는 스트림만 차단되어 재전송이 수신되기를 기다리며 다른 스트림은 계속 진행할 수 있습니다. 여러 스트림의 데이터가 단일 QUIC 패킷에 포함된 경우 해당 패킷이 손실되면 모든 스트림이 진행되지 않습니다. 구현 시 덜 채워진 패킷으로 인한 전송 효율성 손실 없이 나가는 패킷에 필요한 만큼 적은 수의 스트림을 포함하는 것이 좋습니다.

---
### **13.1.  Packet Processing**

패킷 보호가 성공적으로 제거되고 패킷에 포함된 모든 프레임이 처리될 때까지 패킷은 승인되어서는 안 됩니다\(MUST NOT\). STREAM 프레임의 경우 이는 애플리케이션 프로토콜에서 수신할 준비를 위해 데이터가 대기열에 포함되었음을 의미하지만 데이터를 전달하고 소비할 필요는 없습니다.\(MUST NOT\)

패킷이 완전히 처리되면 수신자는 수신된 패킷의 패킷 번호가 포함된 하나 이상의 ACK 프레임을 전송하여 수신을 확인합니다.

엔드포인트는 조건을 감지할 수 있는 경우 PROTOCOL\_VIOLATION 유형의 연결 오류로 보내지 않은 패킷에 대한 확인 수신을 처리해야 합니다\(SHOULD\). 이를 달성하는 방법에 대한 추가 논의는 섹션 21.4를 참조하십시오.\(SHOULD\)

---
### **13.2.  Generating Acknowledgments**

엔드포인트는 수신하고 처리하는 모든 패킷을 승인합니다. 그러나 ack-eliciting 패킷만이 최대 ack 지연 내에서 ACK 프레임을 전송하도록 합니다. ack-eliciting이 아닌 패킷은 다른 이유로 ACK 프레임이 전송될 때만 확인됩니다.

어떤 이유로든 패킷을 보낼 때 엔드포인트는 최근에 보내지 않은 ACK 프레임을 포함하려고 시도해야 합니다\(SHOULD\). 이렇게 하면 피어에서 적시에 손실을 감지하는 데 도움이 됩니다.\(SHOULD\)

일반적으로 수신기의 피드백을 자주 하면 손실 및 혼잡 응답이 개선되지만 이는 모든 ack-eliciting 패킷에 대한 응답으로 ACK 프레임을 보내는 수신기에서 발생하는 과도한 부하와 균형을 이루어야 합니다. 아래에 제공된 지침은 이러한 균형을 유지하기 위한 것입니다.

---
#### **13.2.1.  Sending ACK Frames**

모든 패킷은 적어도 한 번은 확인되어야 하며, 확인을 유도하는 패킷은 종점이 max\_ack\_delay 전송 매개변수를 사용하여 통신하는 최대 지연 내에서 적어도 한 번 확인되어야 합니다. 섹션 18.2를 참조하십시오. max\_ack\_delay는 명시적 계약을 선언합니다. 끝점은 ack-eliciting 패킷의 승인을 표시된 값 이상으로 의도적으로 지연시키지 않을 것을 약속합니다. 그럴 경우 초과분은 RTT 추정치에 누적되며 피어로부터 가짜 또는 지연된 재전송이 발생할 수 있습니다. 발신자는 \[QUIC-RECOVERY\]의 섹션 6.2에 자세히 설명된 대로 타이머 기반 재전송에 대한 시간 초과를 결정하는 데 수신자의 max\_ack\_delay 값을 사용합니다.\(MUST\)

엔드포인트는 모든 ack-eliciting Initial 및 Handshake 패킷과 광고된 max\_ack\_delay 내에서 모든 ack-eliciting 0-RTT 및 1-RTT 패킷을 즉시 승인해야 합니다. 단, 다음은 예외입니다. 핸드셰이크 확인 전에 엔드포인트에는 핸드셰이크, 0-RTT 또는 1-RTT 패킷을 수신할 때 해독하기 위한 패킷 보호 키가 없을 수 있습니다. 따라서 필요한 키를 사용할 수 있게 되면 이를 버퍼링하고 승인할 수 있습니다.\(MUST\)

ACK 프레임만 포함하는 패킷은 혼잡 제어되지 않으므로 종단점은 ack-eliciting 패킷 수신에 대한 응답으로 이러한 패킷을 두 개 이상 보내면 안 됩니다\(MUST NOT\).\(MUST NOT\)

엔드포인트는 수신된 패킷 앞에 패킷 갭이 있더라도 비 ack-eliciting 패킷에 대한 응답으로 비 ack-eliciting 패킷을 전송해서는 안 됩니다\(MUST NOT\). 이렇게 하면 연결이 유휴 상태가 되는 것을 방지할 수 있는 승인의 무한 피드백 루프를 방지할 수 있습니다. 비확인 패킷은 종점이 다른 이벤트에 대한 응답으로 ACK 프레임을 보낼 때 결국 확인됩니다.\(MUST NOT\)

ACK 프레임만 전송하는 엔드포인트는 해당 승인이 ack-eliciting 프레임이 있는 패킷에 포함되지 않는 한 해당 피어로부터 승인을 수신하지 않습니다. 종점은 승인할 새 승인 유도 패킷이 있을 때 다른 프레임과 함께 ACK 프레임을 보내야 합니다\(SHOULD\). 확인을 유도하지 않는 패킷만 확인해야 하는 경우 종점은 확인을 유도하는 패킷이 수신될 때까지 나가는 프레임과 함께 ACK 프레임을 보내지 않도록 선택할 수 있습니다\(MAY\).\(SHOULD, MAY\)

ack-eliciting 패킷이 아닌 패킷만 전송하는 엔드포인트는 ack-eliciting 프레임을 해당 패킷에 추가하여 승인을 받을 수 있도록 선택할 수 있습니다. 섹션 13.2.4를 참조하십시오. 이 경우 엔드포인트는 승인의 무한 피드백 루프를 피하기 위해 승인을 유도하지 않는 모든 패킷에서 승인을 유도하는 프레임을 보내서는 안 됩니다\(MUST NOT\).\(MUST NOT\)

발신자에서 손실 감지를 지원하기 위해 종단점은 ack-eliciting 패킷을 수신할 때 지연 없이 ACK 프레임을 생성하고 보내야 합니다\(SHOULD\).\(SHOULD\)

\* 수신된 패킷이 수신된 다른 ack-eliciting 패킷보다 작은 패킷 번호를 가질 때, 또는

\* 패킷이 수신된 가장 높은 번호의 ack-eliciting 패킷보다 큰 패킷 번호를 가지고 있고 해당 패킷과 이 패킷 사이에 누락된 패킷이 있는 경우.

마찬가지로 IP 헤더에 ECN CE\(Congestion Experienced\) 코드포인트로 표시된 패킷은 혼잡 이벤트에 대한 피어의 응답 시간을 줄이기 위해 즉시 승인되어야 합니다\(SHOULD\).\(SHOULD\)

\[QUIC-RECOVERY\]의 알고리즘은 위에 제공된 지침을 따르지 않는 수신자에 대해 탄력적일 것으로 예상됩니다. 그러나 구현은 엔드포인트에서 만든 연결과 네트워크의 다른 사용자에 대한 변경의 성능 영향을 신중하게 고려한 후에만 이러한 요구 사항에서 벗어나야 합니다.

---
#### **13.2.2.  Acknowledgment Frequency**

수신자는 승인 유도 패킷에 대한 응답으로 승인을 보내는 빈도를 결정합니다. 이 결정에는 트레이드 오프가 포함됩니다.

엔드포인트는 손실을 감지하기 위해 시기적절한 확인에 의존합니다. \[빠른 복구\]의 섹션 6을 참조하십시오. \[QUIC-RECOVERY\]의 섹션 7에 설명된 것과 같은 창 기반 혼잡 컨트롤러는 확인에 의존하여 혼잡 창을 관리합니다. 두 경우 모두 확인을 지연하면 성능에 부정적인 영향을 미칠 수 있습니다.

반면에 승인만 전달하는 패킷의 빈도를 줄이면 두 엔드포인트에서 패킷 전송 및 처리 비용이 줄어듭니다. 심각한 비대칭 링크에서 연결 처리량을 개선하고 반환 경로 용량을 사용하여 승인 트래픽의 양을 줄일 수 있습니다. \[RFC3449\]의 섹션 3을 참조하십시오.

수신자는 적어도 두 개의 ack-eliciting 패킷을 수신한 후 ACK 프레임을 보내야 합니다\(SHOULD\). 이 권장 사항은 본질적으로 일반적이며 TCP 엔드포인트 동작에 대한 권장 사항\[RFC5681\]과 일치합니다. 네트워크 상태에 대한 지식, 피어의 혼잡 컨트롤러에 대한 지식 또는 추가 연구 및 실험을 통해 더 나은 성능 특성을 가진 대체 확인 전략을 제안할 수 있습니다.\(SHOULD\)

수신자는 응답으로 ACK 프레임을 보낼지 여부를 결정하기 전에 여러 사용 가능한 패킷을 처리할 수 있습니다\(MAY\).\(MAY\)

---
#### **13.2.3.  Managing ACK Ranges**

ACK 프레임이 전송될 때 하나 이상의 승인된 패킷 범위가 포함됩니다. 이전 패킷에 대한 승인을 포함하면 이전에 보낸 ACK 프레임 손실로 인해 더 큰 ACK 프레임을 사용하는 대신 잘못된 재전송 가능성이 줄어듭니다.

ACK 프레임은 항상 가장 최근에 수신된 패킷을 확인해야 하며, 패킷의 순서가 어긋날수록 업데이트된 ACK 프레임을 신속하게 전송하여 피어가 패킷을 손실된 것으로 선언하고 잘못된 프레임을 재전송하는 것을 방지하는 것이 더 중요합니다. 포함합니다. ACK 프레임은 단일 QUIC 패킷에 맞을 것으로 예상됩니다. 그렇지 않은 경우 이전 범위\(패킷 번호가 가장 작은 범위\)는 생략됩니다.\(SHOULD\)

수신자는 ACK 프레임의 크기를 제한하고 리소스 고갈을 피하기 위해 기억하고 ACK 프레임으로 보내는 ACK 범위\(19.3.1절\)의 수를 제한합니다. ACK 프레임에 대한 승인을 수신한 후 수신자는 승인된 ACK 범위 추적을 중지해야 합니다\(SHOULD\). 발신자는 대부분의 패킷에 대한 승인을 기대할 수 있지만 QUIC은 수신자가 처리하는 모든 패킷에 대한 승인 수신을 보장하지 않습니다.\(SHOULD\)

많은 ACK 범위를 유지하면 ACK 프레임이 너무 커질 수 있습니다. 수신자는 확인되지 않은 ACK 범위를 폐기하여 ACK 프레임 크기를 제한할 수 있지만 발신자의 재전송이 증가합니다. 이는 ACK 프레임이 너무 커서 패킷에 맞지 않는 경우에 필요합니다. 수신자는 또한 다른 프레임을 위한 공간을 보존하거나 승인이 소비하는 용량을 제한하기 위해 ACK 프레임 크기를 추가로 제한할 수 있습니다\(MAY\).\(MAY\)

수신기는 이후에 해당 범위의 숫자가 있는 패킷을 수락하지 않을 것임을 보장할 수 없는 한 ACK 범위를 유지해야 합니다. 범위가 삭제됨에 따라 증가하는 최소 패킷 수를 유지하는 것은 최소 상태로 이를 달성하는 한 가지 방법입니다.\(MUST\)

수신자는 모든 ACK 범위를 폐기할 수 있지만 후속 패킷에서 패킷 번호를 복구하는 데 사용되므로 성공적으로 처리된 가장 큰 패킷 번호를 유지해야 합니다. 섹션 17.1을 참조하십시오.\(MUST\)

수신기는 모든 ACK 프레임에서 가장 큰 수신 패킷 번호를 포함하는 ACK Range를 포함해야 합니다\(SHOULD\). 가장 큰 확인 필드는 발신자의 ECN 유효성 검사에 사용되며 이전 ACK 프레임에 포함된 것보다 낮은 값을 포함하면 ECN이 불필요하게 비활성화될 수 있습니다. 섹션 13.4.2를 참조하십시오.\(SHOULD\)

섹션 13.2.4는 각 ACK 프레임에서 확인 응답할 패킷을 결정하기 위한 예시적인 접근법을 설명합니다. 이 알고리즘의 목표는 처리되는 모든 패킷에 대한 승인을 생성하는 것이지만 여전히 승인이 손실될 수 있습니다.

---
#### **13.2.4.  Limiting Ranges by Tracking ACK Frames**

ACK 프레임이 포함된 패킷이 전송되면 해당 프레임의 Largest Acknowledged 필드를 저장할 수 있습니다. ACK 프레임을 포함하는 패킷이 확인되면 수신자는 보낸 ACK 프레임의 최대 확인 필드보다 작거나 같은 패킷 확인을 중지할 수 있습니다.

ACK 프레임과 같이 ACK를 유도하지 않는 패킷만 전송하는 수신자는 오랜 시간 동안 ACK를 받지 못할 수 있습니다. 이로 인해 수신기가 오랜 시간 동안 많은 수의 ACK 프레임에 대한 상태를 유지할 수 있으며 보내는 ACK 프레임이 불필요하게 커질 수 있습니다. 그러한 경우에 수신기는 PING 또는 다른 작은 ack-eliciting 프레임을 때때로\(예: 왕복당 한 번\) 전송하여 피어로부터 ACK를 이끌어낼 수 있습니다.

ACK 프레임 손실이 없는 경우 이 알고리즘은 최소 1 RTT 재정렬을 허용합니다. ACK 프레임 손실 및 재정렬이 있는 경우, 이 접근 방식은 더 이상 ACK 프레임에 포함되지 않기 전에 모든 승인이 발신자에게 표시된다는 것을 보장하지 않습니다. 패킷이 잘못된 순서로 수신될 수 있으며 이를 포함하는 모든 후속 ACK 프레임이 손실될 수 있습니다. 이 경우 손실 복구 알고리즘은 가짜 재전송을 유발할 수 있지만 발신자는 계속 진행합니다.

---
#### **13.2.5.  Measuring and Reporting Host Delay**

엔드포인트는 가장 큰 패킷 번호를 가진 패킷이 수신된 시간과 승인이 전송된 시간 사이에 의도적으로 도입된 지연을 측정합니다. 끝점은 ACK 프레임의 ACK 지연 필드에서 이 확인 지연을 인코딩합니다. 섹션 19.3을 참조하십시오. 이를 통해 ACK 프레임의 수신자는 의도적인 지연을 조정할 수 있습니다. 이는 승인이 지연될 때 경로 RTT의 더 나은 추정치를 얻는 데 중요합니다.

패킷은 처리되기 전에 OS 커널 또는 호스트의 다른 위치에 보관될 수 있습니다. 엔드포인트는 ACK 프레임의 ACK 지연 필드를 채울 때 제어하지 않는 지연을 포함해서는 안 됩니다\(MUST NOT\). 그러나 엔드포인트에는 암호 해독 키를 사용할 수 없어 발생하는 버퍼링 지연이 포함되어야 합니다\(SHOULD\). 이러한 지연은 클 수 있고 반복되지 않을 가능성이 높기 때문입니다.\(MUST NOT, SHOULD\)

측정된 승인 지연이 max\_ack\_delay보다 크면 엔드포인트는 측정된 지연을 보고해야 합니다\(SHOULD\). 이 정보는 지연이 클 수 있는 핸드셰이크 중에 특히 유용합니다. 섹션 13.2.1을 참조하십시오.\(SHOULD\)

---
#### **13.2.6.  ACK Frames and Packet Protection**

ACK 프레임은 확인된 패킷과 동일한 패킷 번호 공간을 가진 패킷에서만 전달되어야 합니다. 섹션 12.1을 참조하십시오. 예를 들어, 1-RTT 키로 보호되는 패킷은 1-RTT 키로 보호되는 패킷에서도 승인되어야 합니다.\(MUST, MUST\)

클라이언트가 0-RTT 패킷 보호로 보내는 패킷은 1-RTT 키로 보호되는 패킷에서 서버에 의해 확인되어야 합니다. 이는 서버 암호화 핸드셰이크 메시지가 지연되거나 손실된 경우 클라이언트가 이러한 승인을 사용할 수 없음을 의미할 수 있습니다. 1-RTT 키로 보호되는 서버에서 보낸 다른 데이터에도 동일한 제한이 적용됩니다.\(MUST\)

---
#### **13.2.7.  PADDING Frames Consume Congestion Window**

PADDING 프레임을 포함하는 패킷은 혼잡 제어 목적 \[QUIC-RECOVERY\]을 위해 전송 중인 것으로 간주됩니다. 따라서 PADDING 프레임만 포함하는 패킷은 혼잡 창을 소비하지만 혼잡 창을 여는 승인을 생성하지 않습니다. 교착 상태를 피하기 위해 발신자는 수신자로부터 승인을 이끌어내기 위해 PADDING 프레임 외에 다른 프레임이 주기적으로 전송되는지 확인해야 합니다\(SHOULD\).\(SHOULD\)

---
### **13.3.  Retransmission of Information**

손실된 것으로 판단되는 QUIC 패킷은 전체적으로 재전송되지 않습니다. 손실된 패킷에 포함된 프레임에도 동일하게 적용됩니다. 대신, 프레임으로 전달될 수 있는 정보는 필요에 따라 새 프레임으로 다시 전송됩니다.

손실된 것으로 확인된 정보를 전달하기 위해 새로운 프레임과 패킷이 사용됩니다. 일반적으로 해당 정보를 포함하는 패킷이 손실되었다고 판단되면 정보를 다시 보내고 해당 정보를 포함하는 패킷이 확인되면 전송을 중단합니다.

\* CRYPTO 프레임으로 전송된 데이터는 모든 데이터가 확인될 때까지 \[QUIC-RECOVERY\]의 규칙에 따라 재전송됩니다. 초기 및 핸드셰이크 패킷에 대한 CRYPTO 프레임의 데이터는 해당 패킷 번호 공간에 대한 키가 폐기될 때 폐기됩니다.

\* STREAM 프레임에서 전송된 응용 프로그램 데이터는 끝점이 해당 스트림에 대해 RESET\_STREAM을 전송하지 않는 한 새 STREAM 프레임에서 재전송됩니다. 엔드포인트가 RESET\_STREAM 프레임을 전송하면 더 이상 STREAM 프레임이 필요하지 않습니다.

\* ACK 프레임은 섹션 13.2.1에 설명된 대로 가장 최근의 승인 집합과 가장 큰 승인 패킷의 승인 지연을 전달합니다. ACK 프레임이 포함된 패킷의 전송을 지연하거나 이전 ACK 프레임을 다시 보내면 피어가 부풀려진 RTT 샘플을 생성하거나 ECN을 불필요하게 비활성화할 수 있습니다.

\* RESET\_STREAM 프레임에 포함된 스트림 전송 취소는 승인될 때까지 또는 모든 스트림 데이터가 피어에 의해 승인될 때까지 전송됩니다\(즉, "Reset Recvd" 또는 "Data Recvd" 상태가 전송 부분에서 도달됨\). 스트림\). RESET\_STREAM 프레임의 내용은 다시 전송될 때 변경되어서는 안 됩니다\(MUST NOT\).\(MUST NOT\)

\* 마찬가지로 STOP\_SENDING 프레임에 인코딩된 스트림 전송 취소 요청은 스트림의 수신 부분이 "Data Recvd" 또는 "Reset Recvd" 상태에 들어갈 때까지 전송됩니다. 섹션 3.5를 참조하십시오.

\* 다음을 포함하는 패킷을 포함한 연결 종료 신호

- CONNECTION\_CLOSE 프레임은 패킷 손실이 감지되면 다시 전송되지 않습니다. 이러한 신호를 재전송하는 방법은 섹션 10에 설명되어 있습니다.

\* 현재 연결 최대 데이터는 MAX\_DATA 프레임으로 전송됩니다. 가장 최근에 전송된 MAX\_DATA 프레임을 포함하는 패킷이 손실된 것으로 선언되거나 엔드포인트가 제한을 업데이트하기로 결정하면 업데이트된 값이 MAX\_DATA 프레임에서 전송됩니다. 한도가 자주 증가하여 불필요하게 많은 MAX\_DATA 프레임이 전송될 수 있으므로 이 프레임을 너무 자주 전송하지 않도록 주의해야 합니다. 섹션 4.2를 참조하십시오.

\* 현재 최대 스트림 데이터 오프셋은 MAX\_STREAM\_DATA 프레임으로 전송됩니다. MAX\_DATA와 마찬가지로 스트림에 대한 가장 최근의 MAX\_STREAM\_DATA 프레임이 포함된 패킷이 손실되거나 한계가 업데이트될 때 프레임이 너무 자주 전송되지 않도록 주의하여 업데이트된 값이 전송됩니다. 엔드포인트는 스트림의 수신 부분이 "알려진 크기" 또는 "수신 재설정" 상태에 들어갈 때 MAX\_STREAM\_DATA 프레임 전송을 중지해야 합니다\(SHOULD\).\(SHOULD\)

\* 주어진 유형의 스트림에 대한 제한은 MAX\_STREAMS 프레임으로 전송됩니다. MAX\_DATA와 마찬가지로 스트림 유형 프레임에 대한 가장 최근의 MAX\_STREAMS를 포함하는 패킷이 손실되었다고 선언되거나 제한이 업데이트될 때 업데이트된 값이 전송됩니다. 프레임이 너무 자주 전송되지 않도록 주의해야 합니다.

\* 차단된 신호는 DATA\_BLOCKED, STREAM\_DATA\_BLOCKED 및 STREAMS\_BLOCKED 프레임에서 전달됩니다. DATA\_BLOCKED 프레임에는 연결 범위가 있고 STREAM\_DATA\_BLOCKED 프레임에는 스트림 범위가 있으며 STREAMS\_BLOCKED 프레임에는 특정 스트림 유형으로 범위가 지정됩니다. 범위에 대한 가장 최근 프레임이 포함된 패킷이 손실된 경우 새 프레임이 전송되지만 엔드포인트가 해당 제한에서 차단되는 동안에만 전송됩니다. 이러한 프레임에는 전송 시 차단을 유발하는 제한이 항상 포함됩니다.

\* PATH\_CHALLENGE 프레임을 사용하는 활성 또는 경로 유효성 검사는 일치하는 PATH\_RESPONSE 프레임이 수신되거나 활성 또는 경로 유효성 검사가 더 이상 필요하지 않을 때까지 주기적으로 전송됩니다. PATH\_CHALLENGE 프레임은 전송될 때마다 다른 페이로드를 포함합니다.

\* PATH\_RESPONSE 프레임을 사용한 경로 유효성 검사에 대한 응답은 한 번만 전송됩니다. 피어는 추가 PATH\_RESPONSE 프레임을 호출하는 데 필요한 만큼 더 많은 PATH\_CHALLENGE 프레임을 보낼 것으로 예상됩니다.

\* 새 연결 ID는 NEW\_CONNECTION\_ID 프레임으로 전송되며 이를 포함하는 패킷이 손실된 경우 재전송됩니다. 이 프레임의 재전송은 동일한 시퀀스 번호 값을 전달합니다. 마찬가지로 폐기된 연결 ID는 RETIRE\_CONNECTION\_ID 프레임으로 전송되며 이를 포함하는 패킷이 손실된 경우 재전송됩니다.

\* NEW\_TOKEN 프레임은 해당 프레임이 포함된 패킷이 손실된 경우 재전송됩니다. 프레임 내용을 직접 비교하는 것 외에 재정렬되고 복제된 NEW\_TOKEN 프레임을 감지하기 위한 특별한 지원은 없습니다.

\* PING 및 PADDING 프레임에는 정보가 포함되어 있지 않으므로 손실된 PING 또는 PADDING 프레임은 복구할 필요가 없습니다.

\* HANDSHAKE\_DONE 프레임은 확인될 때까지 반드시 재전송되어야 합니다.\(MUST\)

엔드포인트는 애플리케이션에서 지정한 우선 순위가 달리 표시되지 않는 한 새 데이터를 보내는 것보다 데이터 재전송에 우선 순위를 두어야 합니다\(SHOULD\). 섹션 2.3을 참조하십시오.\(SHOULD\)

보낸 사람이 패킷을 보낼 때마다 최신 정보를 포함하는 프레임을 조립하도록 권장되지만 손실된 패킷에서 프레임의 복사본을 재전송하는 것이 금지되지는 않습니다. 프레임 사본을 재전송하는 발신자는 패킷 번호 길이, 연결 ID 길이 및 경로 MTU의 변경으로 인해 사용 가능한 페이로드 크기의 감소를 처리해야 합니다. 수신기는 이전 패킷에서 발견된 것보다 더 작은 최대 데이터 값을 전달하는 MAX\_DATA 프레임과 같은 오래된 프레임을 포함하는 패킷을 수락해야 합니다.\(MUST\)

보낸 사람은 확인된 패킷에서 정보를 재전송하는 것을 피해야 합니다\(SHOULD\). 여기에는 네트워크 재정렬이 있을 때 발생할 수 있는 손실 선언 후 승인된 패킷이 포함됩니다. 이렇게 하려면 보낸 사람이 패킷이 손실된 것으로 선언된 후 패킷에 대한 정보를 유지해야 합니다. 보낸 사람은 PTO\(\[빠른 복구\]의 섹션 6.2\)와 같이 재정렬을 적절하게 허용하는 시간이 경과한 후 또는 메모리 제한 도달과 같은 다른 이벤트를 기반으로 이 정보를 삭제할 수 있습니다.\(SHOULD\)

손실을 감지하면 발신자는 적절한 혼잡 제어 조치를 취해야 합니다. 손실 감지 및 혼잡 제어에 대한 자세한 내용은 \[QUIC-RECOVERY\]에 설명되어 있습니다.\(MUST\)

---
### **13.4.  Explicit Congestion Notification**

QUIC 엔드포인트는 ECN\[RFC3168\]을 사용하여 네트워크 정체를 감지하고 대응할 수 있습니다. ECN을 사용하면 끝점이 IP 패킷의 ECN 필드에 ECN 가능 전송\(ECT\) 코드 포인트를 설정할 수 있습니다. 그런 다음 네트워크 노드는 패킷을 삭제하는 대신 ECN 필드에 ECN-CE 코드포인트를 설정하여 정체를 나타낼 수 있습니다\[RFC8087\]. 엔드포인트는 \[빠른 복구\]에 설명된 대로 전송 속도를 줄임으로써 보고된 정체에 대응합니다.

ECN을 활성화하기 위해 송신 QUIC 끝점은 먼저 경로가 ECN 표시를 지원하는지 여부와 피어가 수신된 IP 헤더에서 ECN 값을 보고하는지 여부를 결정합니다. 섹션 13.4.2를 참조하십시오.

---
#### **13.4.1.  Reporting ECN Counts**

ECN을 사용하려면 수신 엔드포인트가 IP 패킷에서 ECN 필드를 읽어야 합니다. 이는 모든 플랫폼에서 가능하지 않습니다. 엔드포인트가 ECN 지원을 구현하지 않거나 수신된 ECN 필드에 대한 액세스 권한이 없는 경우 수신하는 패킷의 ECN 수를 보고하지 않습니다.

엔드포인트가 보내는 패킷에 ECT 필드를 설정하지 않더라도 엔드포인트는 액세스 가능한 경우 수신하는 ECN 표시에 대한 피드백을 제공해야 합니다. ECN 수를 보고하지 않으면 발신자가 이 연결에 대한 ECN 사용을 비활성화하게 됩니다.\(MUST\)

ECT\(0\), ECT\(1\) 또는 ECN-CE 코드포인트가 있는 IP 패킷을 수신하면 ECN 지원 엔드포인트는 ECN 필드에 액세스하고 해당 ECT\(0\), ECT\(1\) 또는 ECN-CE를 증가시킵니다. 세다. 이러한 ECN 수는 후속 ACK 프레임에 포함됩니다. 섹션 13.2 및 19.3을 참조하십시오.

각 패킷 번호 공간은 별도의 확인 상태와 별도의 ECN 카운트를 유지합니다. 통합된 QUIC 패킷\(섹션 12.2 참조\)은 동일한 IP 헤더를 공유하므로 통합된 각 QUIC 패킷에 대해 ECN 카운트가 한 번씩 증가합니다.

예를 들어, 초기, 핸드셰이크 및 1-RTT QUIC 패킷 각각이 단일 UDP 데이터그램으로 통합되는 경우 세 패킷 번호 공간 모두에 대한 ECN 카운트는 단일 데이터그램의 ECN 필드를 기준으로 각각 하나씩 증가합니다. IP 헤더.

ECN 카운트는 수신된 IP 패킷의 QUIC 패킷이 처리될 때만 증가합니다. 따라서 중복 QUIC 패킷은 처리되지 않으며 ECN 카운트를 증가시키지 않습니다. 관련 보안 문제는 섹션 21.10을 참조하십시오.

---
#### **13.4.2.  ECN Validation**

결함이 있는 네트워크 장치가 0이 아닌 ECN 코드 포인트를 전달하는 패킷을 손상시키거나 잘못 삭제할 수 있습니다. 이러한 장치가 있을 때 연결을 보장하기 위해 엔드포인트는 각 네트워크 경로에 대한 ECN 수를 확인하고 오류가 감지되면 해당 경로에서 ECN 사용을 비활성화합니다.

새 경로에 대해 ECN 유효성 검사를 수행하려면:

\* 종단점은 피어 \[RFC8311\]에 대한 새 경로에서 전송된 초기 발신 패킷의 IP 헤더에 ECT\(0\) 코드 포인트를 설정합니다.

\* 엔드포인트는 ECT 코드포인트와 함께 전송된 모든 패킷이 결국 손실된 것으로 간주되는지 여부를 모니터링하여\(\[빠른 복구\]의 섹션 6\) ECN 유효성 검사가 실패했음을 나타냅니다.

엔드포인트가 ECT 코드포인트가 있는 IP 패킷이 결함이 있는 네트워크 요소에 의해 삭제될 수 있다고 예상하는 원인이 있는 경우 엔드포인트는 경로에서 처음 10개의 발신 패킷에 대해서만 ECT 코드포인트를 설정하거나 3개의 PTO 기간 동안 설정할 수 있습니다\(참조: \[빠른 복구\]의 섹션 6.2\). 0이 아닌 ECN 코드 포인트로 표시된 모든 패킷이 나중에 손실되면 표시로 인해 손실이 발생했다는 가정하에 표시를 비활성화할 수 있습니다.

따라서 엔드포인트는 ECN 사용을 시도하고 서버의 기본 주소로 전환할 때와 새 경로로의 활성 연결 마이그레이션 시 각각의 새 연결에 대해 이를 검증합니다. 부록 A.4는 한 가지 가능한 알고리즘을 설명합니다.

다른 마킹 전략과 마찬가지로 ECN 지원 경로를 탐색하는 다른 방법도 가능합니다. 구현은 RFC에 정의된 다른 방법을 사용할 수 있습니다\(MAY\). \[RFC8311\] 참조. ECT\(1\) 코드포인트를 사용하는 구현은 보고된 ECT\(1\) 카운트를 사용하여 ECN 유효성 검사를 수행해야 합니다.\(MAY\)

---
##### **13.4.2.1.  Receiving ACK Frames with ECN Counts**

네트워크에서 ECN-CE 표시를 잘못 적용하면 연결 성능이 저하될 수 있습니다. 따라서 ECN 카운트가 포함된 ACK 프레임을 수신하는 엔드포인트는 카운트를 사용하기 전에 카운트를 확인합니다. 성공적으로 처리된 마지막 ACK 프레임의 새로 수신된 카운트와 비교하여 이 유효성 검사를 수행합니다. ECN 수의 증가는 ACK 프레임에서 새로 확인된 패킷에 적용된 ECN 표시를 기반으로 유효성이 검사됩니다.

ACK 프레임이 ECT\(0\) 또는 ECT\(1\) 코드포인트 세트와 함께 엔드포인트가 보낸 패킷을 새로 승인하는 경우 해당 ECN 카운트가 ACK 프레임에 없으면 ECN 유효성 검사가 실패합니다. 이 검사는 ECN 필드를 0으로 설정하는 네트워크 요소 또는 ECN 표시를 보고하지 않는 피어를 감지합니다.

ECT\(0\) 및 ECN-CE 카운트의 증가 합계가 원래 ECT\(0\) 표시와 함께 전송된 새로 승인된 패킷 수보다 작은 경우에도 ECN 유효성 검사가 실패합니다. 마찬가지로 ECT\(1\) 및 ECN-CE 카운트 증가의 합계가 ECT\(1\) 표시와 함께 전송된 새로 확인된 패킷 수보다 적은 경우 ECN 유효성 검사가 실패합니다. 이러한 검사를 통해 네트워크에서 ECN-CE 표시에 대한 언급을 감지할 수 있습니다.

ACK 프레임이 손실되면 끝점이 패킷에 대한 승인을 놓칠 수 있습니다. 따라서 ECT\(0\), ECT\(1\) 및 ECN-CE 카운트의 총 증가가 ACK 프레임에서 새로 확인된 패킷 수보다 클 수 있습니다. 이것이 ECN 카운트가 확인된 총 패킷 수보다 클 수 있도록 허용되는 이유입니다.

재정렬된 ACK 프레임에서 ECN 카운트를 검증하면 실패할 수 있습니다. 엔드포인트는 확인된 최대 패킷 수를 늘리지 않는 ACK 프레임을 처리한 결과로 ECN 유효성 검사에 실패해서는 안 됩니다\(MUST NOT\).\(MUST NOT\)

ECT\(0\) 또는 ECT\(1\)에 대해 수신된 총 수가 각 해당 ECT 코드포인트와 함께 전송된 총 패킷 수를 초과하는 경우 ECN 유효성 검사가 실패할 수 있습니다. 특히 엔드포인트가 적용되지 않은 ECT 코드포인트에 해당하는 0이 아닌 ECN 카운트를 수신하면 유효성 검사가 실패합니다. 이 검사는 패킷이 네트워크에서 ECT\(0\) 또는 ECT\(1\)로 표시되는 시기를 감지합니다.

---
##### **13.4.2.2.  ECN Validation Outcomes**

유효성 검사가 실패하면 엔드포인트는 ECN을 비활성화해야 합니다. 네트워크 경로 또는 피어가 ECN을 지원하지 않는다고 가정하여 전송하는 IP 패킷에서 ECT 코드 포인트 설정을 중지합니다.\(MUST\)

유효성 검사가 실패하더라도 엔드포인트는 나중에 연결에서 동일한 경로에 대해 ECN을 다시 유효성 검사할 수 있습니다. 엔드포인트는 주기적으로 유효성 검사를 계속 시도할 수 있습니다.\(MAY\)

유효성 검사에 성공하면 엔드포인트는 경로가 ECN을 사용할 수 있다는 기대와 함께 전송하는 후속 패킷에 ECT 코드포인트를 계속 설정할 수 있습니다\(MAY\). 네트워크 라우팅 및 경로 요소는 중간 연결을 변경할 수 있습니다. 나중에 검증이 실패하면 엔드포인트는 ECN을 비활성화해야 합니다.\(MAY, MUST\)

---
## **14.  Datagram Size**

UDP 데이터그램은 하나 이상의 QUIC 패킷을 포함할 수 있습니다. 데이터그램 크기는 QUIC 패킷을 전달하는 단일 UDP 데이터그램의 총 UDP 페이로드 크기를 나타냅니다. 데이터그램 크기에는 하나 이상의 QUIC 패킷 헤더와 보호된 페이로드가 포함되지만 UDP 또는 IP 헤더는 포함되지 않습니다.

최대 데이터그램 크기는 단일 UDP 데이터그램을 사용하여 네트워크 경로를 통해 보낼 수 있는 UDP 페이로드의 최대 크기로 정의됩니다. QUIC은 네트워크 경로가 최소 1200바이트의 최대 데이터그램 크기를 지원할 수 없는 경우 사용하면 안 됩니다.\(MUST NOT\)

QUIC은 최소 1280바이트의 최소 IP 패킷 크기를 가정합니다. 이것은 IPv6 최소 크기\[IPv6\]이며 대부분의 최신 IPv4 네트워크에서도 지원됩니다. 최소 IP 헤더 크기는 IPv6의 경우 40바이트, IPv4의 경우 20바이트, UDP 헤더 크기는 8바이트라고 가정하면 최대 데이터그램 크기는 IPv6의 경우 1232바이트, IPv4의 경우 1252바이트가 됩니다. 따라서 최신 IPv4 및 모든 IPv6 네트워크 경로는 QUIC를 지원할 수 있을 것으로 예상됩니다.

- | 참고: 1200바이트의 UDP 페이로드를 지원하기 위한 이 요구 사항 | 확장 헤더에 사용할 수 있는 공간을 32로 제한 | 경로가 | IPv6 최소 MTU는 1280바이트입니다. 이것은 초기 패킷에 영향을 미칩니다 | 및 경로 유효성 검사.

1200바이트보다 큰 최대 데이터그램 크기는 PMTUD\(Path Maximum Transmission Unit Discovery\)\(14.2.1절 참조\) 또는 DPLPMTUD\(Datagram Packetization Layer PMTU Discovery\)\(14.3절 참조\)를 사용하여 발견할 수 있습니다.

max\_udp\_payload\_size 전송 매개변수\(18.2절\)의 시행은 최대 데이터그램 크기에 대한 추가 제한으로 작용할 수 있습니다. 발신자는 값이 알려지면 이 제한을 초과하는 것을 방지할 수 있습니다. 그러나 전송 매개변수의 값을 학습하기 전에 엔드포인트가 허용되는 최소 최대 데이터그램 크기인 1200바이트보다 큰 데이터그램을 보낼 경우 데이터그램이 손실될 위험이 있습니다.

UDP 데이터그램은 IP 계층에서 단편화되어서는 안 됩니다\(MUST NOT\). IPv4\[IPv4\]에서는 경로에서 조각화를 방지하기 위해 가능한 경우 Don't Fragment\(DF\) 비트를 설정해야 합니다.\(MUST NOT, MUST\)

QUIC은 때때로 데이터그램이 특정 크기보다 작지 않아야 한다고 요구합니다. 예를 들어 섹션 8.1을 참조하십시오. 그러나 데이터그램의 크기는 인증되지 않습니다. 즉, 엔드포인트가 일정 크기의 데이터그램을 수신하면 발신자가 동일한 크기의 데이터그램을 보냈는지 알 수 없습니다. 따라서 엔드포인트는 크기 제한을 충족하지 않는 데이터그램을 수신할 때 연결을 닫아서는 안 됩니다\(MUST NOT\). 끝점은 그러한 데이터그램을 버릴 수 있습니다\(MAY\).\(MUST NOT\)

---
### **14.1.  Initial Datagram Size**

클라이언트는 초기 패킷에 PADDING 프레임을 추가하거나 초기 패킷을 병합하여 최소 허용 최대 데이터그램 크기인 1200바이트로 초기 패킷을 전달하는 모든 UDP 데이터그램의 페이로드를 확장해야 합니다. 섹션 12.2를 참조하십시오. 초기 패킷은 유효하지 않은 패킷과 병합될 수도 있으며 수신자는 이를 폐기합니다. 마찬가지로 서버는 ack-eliciting 초기 패킷을 전달하는 모든 UDP 데이터그램의 페이로드를 최소 허용 최대 데이터그램 크기인 1200바이트로 확장해야 합니다.\(MUST, MUST\)

이 크기의 UDP 데이터그램을 전송하면 네트워크 경로가 양 방향에서 적절한 PMTU\(경로 최대 전송 단위\)를 지원합니다. 또한 초기 패킷을 확장하는 클라이언트는 확인되지 않은 클라이언트 주소에 대한 서버 응답으로 인해 발생하는 증폭 공격의 진폭을 줄이는 데 도움이 됩니다. 섹션 8을 참조하십시오.

초기 패킷을 포함하는 데이터그램은 발신자가 네트워크 경로와 피어가 모두 선택한 크기를 지원한다고 믿는 경우 1200바이트를 초과할 수 있습니다.\(MAY\)

서버는 허용되는 최소 최대 데이터그램 크기인 1200바이트보다 작은 페이로드가 있는 UDP 데이터그램으로 운반되는 초기 패킷을 폐기해야 합니다. 또한 서버는 PROTOCOL\_VIOLATION 오류 코드와 함께 CONNECTION\_CLOSE 프레임을 전송하여 연결을 즉시 닫을 수도 있습니다. 섹션 10.2.3을 참조하십시오.\(MUST, MAY\)

서버는 또한 클라이언트의 주소를 확인하기 전에 전송하는 바이트 수를 제한해야 합니다. 섹션 8을 참조하십시오.\(MUST\)

---
### **14.2.  Path Maximum Transmission Unit**

PMTU는 IP 헤더, UDP 헤더 및 UDP 페이로드를 포함한 전체 IP 패킷의 최대 크기입니다. UDP 페이로드에는 하나 이상의 QUIC 패킷 헤더와 보호된 페이로드가 포함됩니다. PMTU는 경로 특성에 따라 달라질 수 있으므로 시간이 지남에 따라 변경될 수 있습니다. 엔드포인트가 주어진 시간에 보내는 가장 큰 UDP 페이로드를 엔드포인트의 최대 데이터그램 크기라고 합니다.

끝점은 DPLPMTUD\(섹션 14.3\) 또는 PMTUD\(섹션 14.2.1\)를 사용하여 대상에 대한 경로가 조각화 없이 원하는 최대 데이터그램 크기를 지원하는지 여부를 결정해야 합니다\(SHOULD\). 이러한 메커니즘이 없으면 QUIC 끝점은 허용되는 최소 최대 데이터그램 크기보다 큰 데이터그램을 보내면 안 됩니다\(SHOULD NOT\).\(SHOULD, SHOULD NOT\)

DPLPMTUD 및 PMTUD는 PMTU 프로브라고 하는 현재 최대 데이터그램 크기보다 큰 데이터그램을 보냅니다. PMTU 프로브에서 전송되지 않는 모든 QUIC 패킷은 데이터그램이 조각나거나 삭제되는 것을 방지하기 위해 최대 데이터그램 크기에 맞게 크기를 조정해야 합니다\[RFC8085\].\(SHOULD\)

QUIC 엔드포인트가 로컬 및 원격 IP 주소 쌍 사이의 PMTU가 허용되는 최소 최대 데이터그램 크기인 1200바이트를 지원할 수 없다고 판단하는 경우 PMTU 프로브 또는 CONNECTION\_CLOSE 프레임을 포함하는 패킷을 제외하고 QUIC 패킷 전송을 즉시 중단해야 합니다. 영향을 받는 경로. 엔드포인트는 대체 경로를 찾을 수 없는 경우 연결을 종료할 수 있습니다.\(MUST, MAY\)

각 쌍의 로컬 및 원격 주소는 서로 다른 PMTU를 가질 수 있습니다. 따라서 모든 종류의 PMTU 검색을 구현하는 QUIC 구현은 로컬 및 원격 IP 주소의 각 조합에 대해 최대 데이터그램 크기를 유지해야 합니다.\(SHOULD\)

QUIC 구현은 알 수 없는 터널 오버헤드 또는 IP 헤더 옵션/확장을 허용하기 위해 최대 데이터그램 크기를 계산하는 데 더 보수적일 수 있습니다.\(MAY\)

---
#### **14.2.1.  Handling of ICMP Messages by PMTUD**

PMTUD \[RFC1191\] \[RFC8201\]는 로컬 라우터 MTU보다 크기 때문에 IP 패킷이 삭제되는 시기를 나타내는 ICMP 메시지\(즉, IPv6 PTB\(Packet Too Big\) 메시지\) 수신에 의존합니다. DPLPMTUD는 선택적으로 이러한 메시지를 사용할 수도 있습니다. 이러한 ICMP 메시지 사용은 패킷을 관찰할 수 없지만 경로에 사용된 주소를 성공적으로 추측할 수 있는 엔터티의 공격에 잠재적으로 취약합니다. 이러한 공격은 PMTU를 대역폭 비효율적인 값으로 줄일 수 있습니다.

엔드포인트는 PMTU가 QUIC의 최소 허용 최대 데이터그램 크기 미만으로 감소했다고 주장하는 ICMP 메시지를 무시해야 합니다\(MUST\).\(MUST\)

ICMP \[RFC1812\] \[RFC4443\]를 생성하기 위한 요구 사항에는 인용된 패킷이 IP 버전의 최소 MTU를 초과하지 않고 가능한 한 많은 원래 패킷을 포함해야 한다고 명시되어 있습니다. \[DPLPMTUD\]의 섹션 1.1에 설명된 대로 인용된 패킷의 크기는 실제로 더 작거나 정보를 이해할 수 없습니다.

PMTUD를 사용하는 QUIC 엔드포인트는 \[RFC8201\] 및 \[RFC8085\]의 섹션 5.2에 지정된 대로 패킷 주입으로부터 보호하기 위해 ICMP 메시지를 검증해야 합니다. 이 유효성 검사는 메시지를 해당 전송 연결과 연결하기 위해 ICMP 메시지의 페이로드에 제공된 인용된 패킷을 사용해야 합니다\(\[DPLPMTUD\]의 섹션 4.6.1 참조\). ICMP 메시지 유효성 검사에는 일치하는 IP 주소 및 UDP 포트\[RFC8085\]가 포함되어야 하며 가능한 경우 활성 QUIC 세션에 대한 연결 ID가 포함되어야 합니다. 엔드포인트는 검증에 실패한 모든 ICMP 메시지를 무시해야 합니다\(SHOULD\).\(SHOULD, SHOULD, MUST, SHOULD\)

엔드포인트는 ICMP 메시지를 기반으로 PMTU를 증가시켜서는 안 됩니다\(MUST NOT\). \[DPLPMTUD\] 섹션 3의 항목 6을 참조하십시오. ICMP 메시지에 대한 응답으로 QUIC의 최대 데이터그램 크기를 줄이는 것은 QUIC의 손실 감지 알고리즘이 인용된 패킷이 실제로 손실되었다고 결정할 때까지 잠정적일 수 있습니다.\(MUST NOT, MAY\)

---
### **14.3.  Datagram Packetization Layer PMTU Discovery**

DPLPMTUD\[DPLPMTUD\]는 PMTU 프로브에서 전달되는 QUIC 패킷의 추적 손실 또는 승인에 의존합니다. PADDING 프레임을 사용하는 DPLPMTUD에 대한 PMTU 프로브는 \[DPLPMTUD\]의 섹션 4.1에 정의된 대로 "패딩 데이터를 사용하여 프로브"를 구현합니다.

엔드포인트는 QUIC의 최소 허용 최대 데이터그램 크기와 일치하도록 BASE\_PLPMTU\(\[DPLPMTUD\]의 섹션 5.1\)의 초기 값을 설정해야 합니다\(SHOULD\). MIN\_PLPMTU는 BASE\_PLPMTU와 동일합니다.\(SHOULD\)

DPLPMTUD를 구현하는 QUIC 끝점은 로컬 및 원격 IP 주소의 각 조합에 대해 DPLPMTUD 최대 패킷 크기\(MPS\)\(\[DPLPMTUD\]의 섹션 4.4\)를 유지합니다. 이것은 최대 데이터그램 크기에 해당합니다.

---
#### **14.3.1.  DPLPMTUD and Initial Connectivity**

DPLPMTUD의 관점에서 QUIC는 승인된 패킷화 계층\(PL\)입니다. 따라서 QUIC 발신자는 QUIC 연결 핸드셰이크가 완료되면 DPLPMTUD BASE 상태\(\[DPLPMTUD\]의 섹션 5.2\)에 들어갈 수 있습니다.

---
#### **14.3.2.  Validating the Network Path with DPLPMTUD**

QUIC는 승인된 PL입니다. 따라서 QUIC 발신자는 SEARCH\_COMPLETE 상태에 있는 동안 DPLPMTUD CONFIRMATION\_TIMER를 구현하지 않습니다. \[DPLPMTUD\]의 섹션 5.2를 참조하십시오.

---
#### **14.3.3.  Handling of ICMP Messages by DPLPMTUD**

DPLPMTUD를 사용하는 엔드포인트는 \[DPLPMTUD\]의 섹션 4.6에 정의된 대로 PTB 정보를 사용하기 전에 수신된 모든 ICMP PTB 메시지의 유효성을 검사해야 합니다. UDP 포트 유효성 검사 외에도 QUIC는 다른 PL 정보\(예: 수신된 ICMP 메시지의 인용된 패킷에서 연결 ID 유효성 검사\)를 사용하여 ICMP 메시지를 유효성 검사합니다.

섹션 14.2.1에 설명된 ICMP 메시지 처리에 대한 고려 사항은 이러한 메시지가 DPLPMTUD에서 사용되는 경우에도 적용됩니다.

---
### **14.4.  Sending QUIC PMTU Probes**

PMTU 프로브는 ack-eliciting 패킷입니다.

현재 최대 데이터그램 크기보다 큰 패킷이 네트워크에서 삭제될 가능성이 높기 때문에 엔드포인트는 PMTU 프로브의 콘텐츠를 PING 및 PADDING 프레임으로 제한할 수 있습니다. 따라서 PMTU 프로브에서 전달되는 QUIC 패킷의 손실은 혼잡의 신뢰할 수 있는 표시가 아니며 혼잡 제어 반응을 트리거해서는 안 됩니다. \[DPLPMTUD\] 섹션 3의 항목 7을 참조하십시오. 그러나 PMTU 프로브는 혼잡 창을 사용하므로 응용 프로그램의 후속 전송이 지연될 수 있습니다.\(SHOULD NOT\)

---
#### **14.4.1.  PMTU Probes Containing Source Connection ID**

들어오는 QUIC 패킷을 라우팅하기 위해 대상 연결 ID 필드에 의존하는 엔드포인트는 결과 ICMP 메시지\(섹션 14.2.1\)를 올바른 엔드포인트로 다시 라우팅하기 위해 연결 ID가 PMTU 프로브에 포함되도록 요구할 수 있습니다. 그러나 긴 헤더 패킷\(섹션 17.2\)에만 소스 연결 ID 필드가 포함되며 긴 헤더 패킷은 핸드셰이크가 완료되면 해독되거나 피어에서 확인되지 않습니다.

PMTU 프로브를 구성하는 한 가지 방법은 Handshake 또는 0-RTT 패킷\(17.2절\)과 같은 긴 헤더가 있는 패킷을 단일 UDP 데이터그램의 짧은 헤더 패킷과 병합\(12.2절 참조\)하는 것입니다. 결과 PMTU 프로브가 끝점에 도달하면 긴 헤더가 있는 패킷은 무시되지만 짧은 헤더 패킷은 확인됩니다. PMTU 프로브로 인해 ICMP 메시지가 전송되면 프로브의 첫 번째 부분이 해당 메시지에 인용됩니다. 소스 연결 ID 필드가 프로브의 인용된 부분 내에 있으면 ICMP 메시지의 라우팅 또는 유효성 검사에 사용될 수 있습니다.

- | 참고: 헤더가 긴 패킷을 사용하는 목적은 | 인용된 패킷이 ICMP 메시지에 포함되어 있는지 확인하려면 | 소스 연결 ID 필드를 포함합니다. 이 패킷은 | 유효한 패킷이어야 하며 | 해당 유형의 패킷은 현재 사용되지 않습니다.

---
## **15.  Versions**

QUIC 버전은 32비트 부호 없는 숫자를 사용하여 식별됩니다.

버전 0x00000000은 버전 협상을 나타내기 위해 예약되어 있습니다. 이 사양 버전은 번호 0x00000001로 식별됩니다.

QUIC의 다른 버전은 이 버전과 다른 속성을 가질 수 있습니다. 프로토콜의 모든 버전에서 일관성이 보장되는 QUIC의 속성은 \[QUIC-INVARIANTS\]에 설명되어 있습니다.

QUIC의 버전 0x00000001은 \[QUIC-TLS\]에 설명된 대로 TLS를 암호화 핸드셰이크 프로토콜로 사용합니다.

버전 번호의 가장 중요한 16비트가 지워진 버전은 향후 IETF 합의 문서에서 사용하기 위해 예약됩니다.

패턴 0x?a?a?a?a를 따르는 버전은 버전 협상을 실행하는 데 사용하도록 예약되어 있습니다. 즉, 모든 바이트의 하위 4비트가 1010\(바이너리\)인 버전 번호입니다. 클라이언트 또는 서버는 이러한 예약된 버전에 대한 지원을 광고할 수 있습니다\(MAY\).\(MAY\)

예약된 버전 번호는 실제 프로토콜을 나타내지 않습니다. 클라이언트는 서버가 버전 협상을 시작할 것이라는 기대와 함께 이러한 버전 번호 중 하나를 사용할 수 있습니다. 서버는 이러한 버전 중 하나에 대한 지원을 광고할 수 있으며 클라이언트가 값을 무시할 것으로 예상할 수 있습니다.\(MAY\)

---
## **16.  Variable-Length Integer Encoding**

QUIC 패킷 및 프레임은 일반적으로 음이 아닌 정수 값에 대해 가변 길이 인코딩을 사용합니다. 이 인코딩은 더 작은 정수 값을 인코딩하는 데 더 적은 바이트가 필요하도록 합니다.

QUIC 가변 길이 정수 인코딩은 정수 인코딩 길이의 밑이 2인 로그를 바이트 단위로 인코딩하기 위해 첫 번째 바이트의 최상위 2비트를 예약합니다. 정수 값은 나머지 비트에서 네트워크 바이트 순서로 인코딩됩니다.

이는 정수가 1, 2, 4 또는 8바이트로 인코딩되고 각각 6, 14, 30 또는 62비트 값을 인코딩할 수 있음을 의미합니다. 표 4는 인코딩 속성을 요약한 것입니다.

```text
          +======+========+=============+=======================+
          | 2MSB | Length | Usable Bits | Range                 |
          +======+========+=============+=======================+
          | 00   | 1      | 6           | 0-63                  |
          +------+--------+-------------+-----------------------+
          | 01   | 2      | 14          | 0-16383               |
          +------+--------+-------------+-----------------------+
          | 10   | 4      | 30          | 0-1073741823          |
          +------+--------+-------------+-----------------------+
          | 11   | 8      | 62          | 0-4611686018427387903 |
          +------+--------+-------------+-----------------------+

                   Table 4: Summary of Integer Encodings
```

디코딩 알고리즘 및 샘플 인코딩의 예는 부록 A.1에 나와 있습니다.

값은 프레임 유형 필드를 제외하고 필요한 최소 바이트 수로 인코딩할 필요가 없습니다. 섹션 12.4를 참조하십시오.

버전\(15절\), 헤더에서 보낸 패킷 번호\(17.1절\) 및 긴 헤더 패킷의 연결 ID 길이\(17.2절\)는 정수를 사용하여 설명하지만 이 인코딩을 사용하지 않습니다.

---
## **17.  Packet Formats**

모든 숫자 값은 네트워크 바이트 순서\(즉, 빅 엔디안\)로 인코딩되며 모든 필드 크기는 비트 단위입니다. 16진수 표기법은 필드 값을 설명하는 데 사용됩니다.

---
### **17.1.  Packet Number Encoding and Decoding**

패킷 번호는 0에서 2^62-1 범위의 정수입니다\(12.3절\). 길거나 짧은 패킷 헤더에 있는 경우 1\~4바이트로 인코딩됩니다. 패킷 번호를 나타내는 데 필요한 비트 수는 패킷 번호의 최하위 비트만 포함함으로써 줄어듭니다.

인코딩된 패킷 번호는 \[QUIC-TLS\]의 섹션 5.4에 설명된 대로 보호됩니다.

패킷 번호 공간에 대한 승인을 받기 전에 전체 패킷 번호가 포함되어야 합니다. 아래에 설명된 대로 잘리지 않습니다.\(MUST\)

패킷 번호 공간에 대한 승인을 받은 후 송신자는 가장 큰 승인 패킷 번호와 전송 중인 패킷 번호 간의 차이보다 두 배 이상 큰 범위를 나타낼 수 있는 패킷 번호 크기를 사용해야 합니다. 패킷을 수신하는 피어는 패킷이 많은 번호의 패킷이 수신된 후에 도착하도록 전송 중에 지연되지 않는 한 패킷 번호를 올바르게 디코딩합니다. 엔드포인트는 나중에 전송된 패킷 후에 패킷이 도착하더라도 패킷 번호를 복구할 수 있도록 충분히 큰 패킷 번호 인코딩을 사용해야 합니다\(SHOULD\).\(MUST, SHOULD\)

결과적으로, 패킷 번호 인코딩의 크기는 새로운 패킷을 포함하여 연속된 미확인 패킷 번호의 수의 밑이 2인 로그보다 적어도 1비트 이상 큽니다. 의사 코드와 패킷 번호 인코딩의 예는 부록 A.2에서 찾을 수 있습니다.

수신기에서 전체 패킷 번호를 복구하기 전에 패킷 번호 보호가 제거됩니다. 그런 다음 전체 패킷 번호는 존재하는 중요 비트의 수, 해당 비트의 값 및 성공적으로 인증된 패킷에서 수신된 가장 큰 패킷 번호를 기반으로 재구성됩니다. 패킷 보호 제거를 성공적으로 완료하려면 전체 패킷 번호를 복구해야 합니다.

헤더 보호가 제거되면 다음 예상 패킷에 가장 가까운 패킷 번호 값을 찾아 패킷 번호를 디코딩합니다. 다음 예상 패킷은 가장 높은 수신 패킷 번호에 1을 더한 값입니다. 의사 코드와 패킷 번호 디코딩의 예는 부록 A.3에서 찾을 수 있습니다.

---
### **17.2.  Long Header Packets**

```text
   Long Header Packet {
     Header Form (1) = 1,
     Fixed Bit (1) = 1,
     Long Packet Type (2),
     Type-Specific Bits (4),
     Version (32),
     Destination Connection ID Length (8),
     Destination Connection ID (0..160),
     Source Connection ID Length (8),
     Source Connection ID (0..160),
     Type-Specific Payload (..),
   }

                    Figure 13: Long Header Packet Format
```

긴 헤더는 1-RTT 키 설정 전에 전송되는 패킷에 사용됩니다. 1-RTT 키를 사용할 수 있게 되면 발신자는 짧은 헤더를 사용하여 패킷을 전송하도록 전환합니다\(17.3절\). 긴 형식을 사용하면 버전 협상 패킷과 같은 특수 패킷을 이 균일한 고정 길이 패킷 형식으로 표현할 수 있습니다. 긴 헤더를 사용하는 패킷에는 다음 필드가 포함됩니다.

헤더 형식: 바이트 0\(첫 번째 바이트\)의 최상위 비트\(0x80\)는 긴 헤더의 경우 1로 설정됩니다.

고정 비트: 패킷이 버전 협상 패킷이 아닌 경우 바이트 0의 다음 비트\(0x40\)는 1로 설정됩니다. 이 비트에 대해 0 값을 포함하는 패킷은 이 버전에서 유효한 패킷이 아니므로 폐기해야 합니다. 이 비트의 값이 1이면 QUIC이 다른 프로토콜과 공존할 수 있습니다. \[RFC7983\] 참조.\(MUST\)

긴 패킷 유형: 바이트 0의 다음 두 비트\(마스크가 0x30인 비트\)는 패킷 유형을 포함합니다. 패킷 유형은 표 5에 나열되어 있습니다.

유형별 비트: 바이트 0의 하위 4개 비트\(마스크가 0x0f인 비트\)의 의미 체계는 패킷 유형에 따라 결정됩니다.

버전: QUIC 버전은 첫 번째 바이트 뒤에 오는 32비트 필드입니다. 이 필드는 사용 중인 QUIC 버전을 나타내며 나머지 프로토콜 필드가 해석되는 방식을 결정합니다.

대상 연결 ID 길이: 버전 다음의 바이트에는 뒤따르는 대상 연결 ID 필드의 길이\(바이트\)가 포함됩니다. 이 길이는 8비트 부호 없는 정수로 인코딩됩니다. QUIC 버전 1에서 이 값은 20바이트를 초과하면 안 됩니다\(MUST NOT\). 값이 20보다 큰 버전 1 긴 헤더를 수신하는 엔드포인트는 패킷을 삭제해야 합니다. 버전 협상 패킷을 적절하게 형성하기 위해 서버는 다른 QUIC 버전에서 더 긴 연결 ID를 읽을 수 있어야 합니다\(SHOULD\).\(MUST NOT, MUST, SHOULD\)

대상 연결 ID: 대상 연결 ID 필드는 이 필드의 길이를 나타내는 대상 연결 ID 길이 필드 다음에 옵니다. 섹션 7.2에서 이 필드의 사용에 대해 자세히 설명합니다.

소스 연결 ID 길이: 대상 연결 ID 다음에 오는 바이트에는 뒤에 오는 소스 연결 ID 필드의 길이\(바이트\)가 포함됩니다. 이 길이는 8비트 부호 없는 정수로 인코딩됩니다. QUIC 버전 1에서 이 값은 20바이트를 초과하면 안 됩니다\(MUST NOT\). 값이 20보다 큰 버전 1 긴 헤더를 수신하는 엔드포인트는 패킷을 삭제해야 합니다. 버전 협상 패킷을 적절하게 형성하기 위해 서버는 다른 QUIC 버전에서 더 긴 연결 ID를 읽을 수 있어야 합니다\(SHOULD\).\(MUST NOT, MUST, SHOULD\)

소스 연결 ID: 소스 연결 ID 필드는 이 필드의 길이를 나타내는 소스 연결 ID 길이 필드 뒤에 옵니다. 섹션 7.2에서 이 필드의 사용에 대해 자세히 설명합니다.

유형별 페이로드: 패킷의 나머지 부분\(있는 경우\)은 유형별입니다.

이 버전의 QUIC에서는 긴 헤더가 있는 다음 패킷 유형이 정의됩니다.

```text
                   +======+===========+================+
                   | Type | Name      | Section        |
                   +======+===========+================+
                   | 0x00 | Initial   | Section 17.2.2 |
                   +------+-----------+----------------+
                   | 0x01 | 0-RTT     | Section 17.2.3 |
                   +------+-----------+----------------+
                   | 0x02 | Handshake | Section 17.2.4 |
                   +------+-----------+----------------+
                   | 0x03 | Retry     | Section 17.2.5 |
                   +------+-----------+----------------+

                     Table 5: Long Header Packet Types
```

긴 헤더 패킷의 헤더 형식 비트, 대상 및 소스 연결 ID 길이, 대상 및 소스 연결 ID 필드, 버전 필드는 버전 독립적입니다. 첫 번째 바이트의 다른 필드는 버전에 따라 다릅니다. 다른 버전의 QUIC에서 패킷이 해석되는 방법에 대한 자세한 내용은 \[QUIC-INVARIANTS\]를 참조하십시오.

필드 및 페이로드의 해석은 버전 및 패킷 유형에 따라 다릅니다. 이 버전의 유형별 의미 체계는 다음 섹션에서 설명하지만 이 버전의 QUIC에 있는 여러 긴 헤더 패킷에는 다음과 같은 추가 필드가 포함되어 있습니다.

예약된 비트: 바이트 0의 두 비트\(마스크가 0x0c인 비트\)는 여러 패킷 유형에 예약되어 있습니다. 이 비트는 헤더 보호를 사용하여 보호됩니다. \[QUIC-TLS\]의 섹션 5.4를 참조하십시오. 보호 이전에 포함된 값은 0으로 설정되어야 합니다. 엔드포인트는 패킷 및 헤더 보호를 모두 제거한 후 이러한 비트에 대해 0이 아닌 값을 갖는 패킷 수신을 PROTOCOL\_VIOLATION 유형의 연결 오류로 처리해야 합니다. 헤더 보호만 제거한 후 이러한 패킷을 폐기하면 엔드포인트가 공격에 노출될 수 있습니다. \[QUIC-TLS\]의 섹션 9.5를 참조하십시오.\(MUST, MUST\)

패킷 번호 길이: 패킷 번호 필드를 포함하는 패킷 유형에서 바이트 0의 최하위 2비트\(마스크가 0x03인 비트\)에는 1인 부호 없는 2비트 정수로 인코딩된 패킷 번호 필드의 길이가 포함됩니다. 패킷 번호 필드의 길이\(바이트\)보다 작습니다. 즉, 패킷 번호 필드의 길이는 이 필드 값에 1을 더한 값입니다. 이 비트는 헤더 보호를 사용하여 보호됩니다. \[QUIC-TLS\]의 섹션 5.4를 참조하십시오.

길이: 가변 길이 정수\(섹션 16\)로 인코딩된 바이트 단위의 나머지 패킷\(즉, 패킷 번호 및 페이로드 필드\)의 길이입니다.

패킷 번호: 이 필드의 길이는 1\~4바이트입니다. 패킷 번호는 헤더 보호를 사용하여 보호됩니다. \[QUIC-TLS\]의 섹션 5.4를 참조하십시오. 패킷 번호 필드의 길이는 바이트 0의 패킷 번호 길이 비트로 인코딩됩니다. 위 참조.

패킷 페이로드: 이것은 패킷 보호를 사용하여 보호되는 일련의 프레임을 포함하는 패킷의 페이로드입니다.

---
#### **17.2.1.  Version Negotiation Packet**

버전 협상 패킷은 본질적으로 특정 버전이 아닙니다. 클라이언트가 수신하면 값이 0인 Version 필드를 기반으로 하는 버전 협상 패킷으로 식별됩니다.

버전 협상 패킷은 서버에서 지원하지 않는 버전이 포함된 클라이언트 패킷에 대한 응답입니다. 서버에서만 전송됩니다.

버전 협상 패킷의 레이아웃은 다음과 같습니다.

```text
   Version Negotiation Packet {
     Header Form (1) = 1,
     Unused (7),
     Version (32) = 0,
     Destination Connection ID Length (8),
     Destination Connection ID (0..2040),
     Source Connection ID Length (8),
     Source Connection ID (0..2040),
     Supported Version (32) ...,
   }

                   Figure 14: Version Negotiation Packet
```

Unused 필드의 값은 서버에서 임의의 값으로 설정됩니다. 클라이언트는 이 필드의 값을 무시해야 합니다. QUIC가 다른 프로토콜과 다중화될 수 있는 경우\(\[RFC7983\] 참조\) 서버는 이 필드의 최상위 비트\(0x40\)를 1로 설정하여 버전 협상 패킷이 고정 비트 필드를 갖는 것으로 나타나도록 해야 합니다\(SHOULD\). QUIC의 다른 버전은 유사한 권장 사항을 제공하지 않을 수 있습니다.\(MUST, SHOULD\)

버전 협상 패킷의 버전 필드는 0x00000000으로 설정되어야 합니다.\(MUST\)

서버는 대상 연결 ID 필드에서 수신하는 패킷의 소스 연결 ID 필드 값을 포함해야 합니다. 소스 연결 ID의 값은 수신된 패킷의 대상 연결 ID에서 복사해야 하며, 처음에는 클라이언트가 무작위로 선택합니다. 두 연결 ID를 에코하면 서버가 패킷을 수신했으며 버전 협상 패킷이 초기 패킷을 관찰하지 않은 엔티티에 의해 생성되지 않았다는 확신을 클라이언트에 제공합니다.\(MUST, MUST\)

QUIC의 향후 버전은 연결 ID 길이에 대한 요구 사항이 다를 수 있습니다. 특히 연결 ID는 최소 길이가 더 짧거나 최대 길이가 더 길 수 있습니다. 따라서 연결 ID에 대한 버전별 규칙은 버전 협상 패킷을 보낼지 여부에 대한 결정에 영향을 주어서는 안 됩니다\(MUST NOT\).\(MUST NOT\)

버전 협상 패킷의 나머지 부분은 서버가 지원하는 32비트 버전 목록입니다.

버전 협상 패킷이 확인되지 않습니다. 지원되지 않는 버전을 나타내는 패킷에 대한 응답으로만 전송됩니다. 섹션 5.2.2를 참조하십시오.

버전 협상 패킷에는 긴 헤더 형식을 사용하는 다른 패킷에 있는 패킷 번호 및 길이 필드가 포함되지 않습니다. 따라서 버전 협상 패킷은 전체 UDP 데이터그램을 사용합니다.

서버는 단일 UDP 데이터그램에 대한 응답으로 버전 협상 패킷을 두 개 이상 보내면 안 됩니다\(MUST NOT\).\(MUST NOT\)

버전 협상 프로세스에 대한 설명은 섹션 6을 참조하십시오.

---
#### **17.2.2.  Initial Packet**

초기 패킷은 유형 값이 0x00인 긴 헤더를 사용합니다. 클라이언트와 서버가 키 교환을 수행하기 위해 보낸 첫 번째 CRYPTO 프레임을 전달하고 어느 방향으로든 ACK 프레임을 전달합니다.

```text
   Initial Packet {
     Header Form (1) = 1,
     Fixed Bit (1) = 1,
     Long Packet Type (2) = 0,
     Reserved Bits (2),
     Packet Number Length (2),
     Version (32),
     Destination Connection ID Length (8),
     Destination Connection ID (0..160),
     Source Connection ID Length (8),
     Source Connection ID (0..160),
     Token Length (i),
     Token (..),
     Length (i),
     Packet Number (8..32),
     Packet Payload (8..),
   }

                         Figure 15: Initial Packet
```

초기 패킷에는 긴 헤더와 길이 및 패킷 번호 필드가 포함되어 있습니다. 섹션 17.2를 참조하십시오. 첫 번째 바이트에는 예약 및 패킷 번호 길이 비트가 포함됩니다. 섹션 17.2도 참조하십시오. 소스 연결 ID와 길이 필드 사이에는 초기 패킷과 관련된 두 개의 추가 필드가 있습니다.

토큰 길이: 토큰 필드의 길이를 바이트 단위로 지정하는 가변 길이 정수입니다. 토큰이 없으면 이 값은 0입니다. 서버가 보낸 초기 패킷은 토큰 길이 필드를 0으로 설정해야 합니다. 0이 아닌 토큰 길이 필드가 있는 초기 패킷을 수신하는 클라이언트는 패킷을 폐기하거나 PROTOCOL\_VIOLATION 유형의 연결 오류를 생성해야 합니다.\(MUST\)

토큰: 재시도 패킷 또는 NEW\_TOKEN 프레임에서 이전에 제공된 토큰의 값입니다. 섹션 8.1을 참조하십시오.

버전을 인식하지 못하는 미들박스에 의한 변조를 방지하기 위해 초기 패킷은 \[QUIC-TLS\]에 설명된 대로 연결 및 버전별 키\(초기 키\)로 보호됩니다. 이 보호는 패킷을 관찰할 수 있는 공격자에 대해 기밀성 또는 무결성을 제공하지 않지만 패킷을 관찰할 수 없는 공격자가 초기 패킷을 스푸핑하는 것을 방지합니다.

클라이언트와 서버는 초기 암호화 핸드셰이크 메시지를 포함하는 모든 패킷에 대해 초기 패킷 유형을 사용합니다. 여기에는 재시도 패킷을 수신한 후 전송된 패킷과 같이 초기 암호화 메시지를 포함하는 새 패킷을 생성해야 하는 모든 경우가 포함됩니다. 섹션 17.2.5를 참조하십시오.

서버는 클라이언트 Initial에 대한 응답으로 첫 번째 Initial 패킷을 보냅니다. 서버는 여러 초기 패킷을 보낼 수 있습니다. 암호화 키 교환에는 이 데이터의 여러 왕복 또는 재전송이 필요할 수 있습니다.\(MAY\)

초기 패킷의 페이로드에는 암호화 핸드셰이크 메시지, ACK 프레임 또는 둘 다를 포함하는 CRYPTO 프레임\(또는 프레임\)이 포함됩니다. 0x1c 유형의 PING, PADDING 및 CONNECTION\_CLOSE 프레임도 허용됩니다. 다른 프레임을 포함하는 초기 패킷을 수신하는 끝점은 패킷을 가짜로 폐기하거나 연결 오류로 처리할 수 있습니다.

클라이언트가 보낸 첫 번째 패킷에는 항상 첫 번째 암호화 핸드셰이크 메시지의 시작 또는 전체를 포함하는 CRYPTO 프레임이 포함됩니다. 전송된 첫 번째 CRYPTO 프레임은 항상 오프셋 0에서 시작합니다. 섹션 7을 참조하십시오.

서버가 TLS HelloRetryRequest를 보내는 경우\(\[QUIC-TLS\]의 섹션 4.7 참조\) 클라이언트는 다른 일련의 초기 패킷을 보냅니다. 이러한 초기 패킷은 암호화 핸드셰이크를 계속하며 초기 패킷의 첫 번째 비행에서 전송된 CRYPTO 프레임의 크기와 일치하는 오프셋에서 시작하는 CRYPTO 프레임을 포함합니다.

---
##### **17.2.2.1.  Abandoning Initial Packets**

클라이언트는 첫 번째 핸드셰이크 패킷을 보낼 때 초기 패킷 전송 및 처리를 모두 중지합니다. 서버는 첫 번째 핸드셰이크 패킷을 받으면 초기 패킷 전송 및 처리를 중지합니다. 패킷이 아직 비행 중이거나 승인 대기 중일 수 있지만 이 시점 이후에는 더 이상 초기 패킷을 교환할 필요가 없습니다. 초기 패킷 보호 키는 손실 복구 및 혼잡 제어 상태와 함께 폐기됩니다\(\[QUIC-TLS\]의 섹션 4.9.1 참조\). \[빠른 복구\]의 섹션 6.4를 참조하십시오.

초기 키가 폐기되면 CRYPTO 프레임의 모든 데이터가 폐기되고 더 이상 재전송되지 않습니다.

---
#### **17.2.3.  0-RTT**

0-RTT 패킷은 유형 값이 0x01인 긴 헤더와 길이 및 패킷 번호 필드를 사용합니다. 섹션 17.2를 참조하십시오. 첫 번째 바이트에는 예약 및 패킷 번호 길이 비트가 포함됩니다. 섹션 17.2를 참조하십시오. 0-RTT 패킷은 핸드셰이크가 완료되기 전에 첫 비행의 일부로 클라이언트에서 서버로 "초기" 데이터를 전달하는 데 사용됩니다. TLS 핸드셰이크의 일부로 서버는 이 초기 데이터를 수락하거나 거부할 수 있습니다.

0-RTT 데이터 및 제한 사항에 대한 논의는 \[TLS13\]의 섹션 2.3을 참조하십시오.

```text
   0-RTT Packet {
     Header Form (1) = 1,
     Fixed Bit (1) = 1,
     Long Packet Type (2) = 1,
     Reserved Bits (2),
     Packet Number Length (2),
     Version (32),
     Destination Connection ID Length (8),
     Destination Connection ID (0..160),
     Source Connection ID Length (8),
     Source Connection ID (0..160),
     Length (i),
     Packet Number (8..32),
     Packet Payload (8..),
   }

                          Figure 16: 0-RTT Packet
```

0-RTT 보호 패킷의 패킷 번호는 1-RTT 보호 패킷과 동일한 공간을 사용합니다.

클라이언트가 재시도 패킷을 수신한 후 0-RTT 패킷은 서버에서 손실되거나 폐기되었을 수 있습니다. 클라이언트는 새로운 초기 패킷을 보낸 후 0-RTT 패킷의 데이터 재전송을 시도해야 합니다\(SHOULD\). 전송되는 모든 새 패킷에는 새 패킷 번호를 사용해야 합니다. 섹션 17.2.5.3에 설명된 대로 패킷 번호를 재사용하면 패킷 보호가 손상될 수 있습니다.\(SHOULD, MUST\)

클라이언트는 \[QUIC-TLS\]의 섹션 4.1.1에 정의된 대로 핸드셰이크가 완료되면 0-RTT 패킷에 대한 승인만 수신합니다.

클라이언트는 서버에서 1-RTT 패킷을 처리하기 시작하면 0-RTT 패킷을 전송해서는 안 됩니다\(MUST NOT\). 이는 0-RTT 패킷이 1-RTT 패킷의 프레임에 대한 응답을 포함할 수 없음을 의미합니다. 예를 들어 클라이언트는 1-RTT 패킷만 승인할 수 있기 때문에 0-RTT 패킷으로 ACK 프레임을 보낼 수 없습니다. 1-RTT 패킷에 대한 승인은 1-RTT 패킷으로 전달되어야 합니다.\(MUST NOT, MUST\)

서버는 적절한 유형의 연결 오류\(예: 스트림 데이터 제한을 초과하는 FLOW\_CONTROL\_ERROR\)로 기억된 제한\(섹션 7.4.1\) 위반을 처리해야 합니다\(SHOULD\).\(SHOULD\)

---
#### **17.2.4.  Handshake Packet**

핸드셰이크 패킷은 유형 값이 0x02인 긴 헤더와 길이 및 패킷 번호 필드를 사용합니다. 섹션 17.2를 참조하십시오. 첫 번째 바이트에는 예약 및 패킷 번호 길이 비트가 포함됩니다. 섹션 17.2를 참조하십시오. 서버와 클라이언트에서 암호화 핸드셰이크 메시지와 승인을 전달하는 데 사용됩니다.

```text
   Handshake Packet {
     Header Form (1) = 1,
     Fixed Bit (1) = 1,
     Long Packet Type (2) = 2,
     Reserved Bits (2),
     Packet Number Length (2),
     Version (32),
     Destination Connection ID Length (8),
     Destination Connection ID (0..160),
     Source Connection ID Length (8),
     Source Connection ID (0..160),
     Length (i),
     Packet Number (8..32),
     Packet Payload (8..),
   }

                   Figure 17: Handshake Protected Packet
```

클라이언트가 서버에서 핸드셰이크 패킷을 수신하면 핸드셰이크 패킷을 사용하여 후속 암호화 핸드셰이크 메시지와 승인을 서버에 보냅니다.

핸드셰이크 패킷의 대상 연결 ID 필드에는 패킷 수신자가 선택한 연결 ID가 포함됩니다. 소스 연결 ID에는 패킷 발신자가 사용하려는 연결 ID가 포함됩니다. 섹션 7.2를 참조하십시오.

Handshake 패킷은 고유의 패킷 번호 공간을 가지고 있으므로 서버에서 보내는 첫 번째 Handshake 패킷에는 패킷 번호 0이 포함됩니다.

이 패킷의 페이로드에는 CRYPTO 프레임이 포함되며 PING, PADDING 또는 ACK 프레임이 포함될 수 있습니다. 핸드셰이크 패킷은 0x1c 유형의 CONNECTION\_CLOSE 프레임을 포함할 수 있습니다\(MAY\). 엔드포인트는 다른 프레임이 포함된 핸드셰이크 패킷 수신을 PROTOCOL\_VIOLATION 유형의 연결 오류로 처리해야 합니다\(MUST\).\(MAY, MUST\)

초기 패킷\(섹션 17.2.2.1 참조\)과 마찬가지로 핸드셰이크 보호 키가 폐기되면 핸드셰이크 패킷에 대한 CRYPTO 프레임의 데이터가 폐기되고 더 이상 재전송되지 않습니다.

---
#### **17.2.5.  Retry Packet**

그림 18에 표시된 것처럼 재시도 패킷은 유형 값이 0x03인 긴 패킷 헤더를 사용합니다. 서버에서 생성한 주소 유효성 검사 토큰을 전달합니다. 재시도를 수행하려는 서버에서 사용합니다. 섹션 8.1을 참조하십시오.

```text
   Retry Packet {
     Header Form (1) = 1,
     Fixed Bit (1) = 1,
     Long Packet Type (2) = 3,
     Unused (4),
     Version (32),
     Destination Connection ID Length (8),
     Destination Connection ID (0..160),
     Source Connection ID Length (8),
     Source Connection ID (0..160),
     Retry Token (..),
     Retry Integrity Tag (128),
   }

                          Figure 18: Retry Packet
```

재시도 패킷에는 보호된 필드가 포함되어 있지 않습니다. Unused 필드의 값은 서버에 의해 임의의 값으로 설정됩니다. 클라이언트는 이러한 비트를 무시해야 합니다. 긴 머리글의 필드 외에도 다음과 같은 추가 필드가 포함되어 있습니다.\(MUST\)

재시도 토큰: 서버가 클라이언트 주소의 유효성을 검사하는 데 사용할 수 있는 불투명 토큰입니다.

재시도 무결성 태그: 섹션 5.8에 정의됨\("패킷 재시도

- \[QUIC-TLS\]의 무결성"\).

---
##### **17.2.5.1.  Sending a Retry Packet**

서버는 클라이언트가 초기 패킷의 소스 연결 ID에 포함된 연결 ID로 대상 연결 ID를 채웁니다.

서버는 소스 연결 ID 필드에서 선택한 연결 ID를 포함합니다. 이 값은 클라이언트가 보낸 패킷의 대상 연결 ID 필드와 같으면 안 됩니다. 클라이언트는 초기 패킷의 대상 연결 ID 필드와 동일한 소스 연결 ID 필드를 포함하는 재시도 패킷을 폐기해야 합니다. 클라이언트는 전송하는 후속 패킷의 대상 연결 ID 필드에 있는 재시도 패킷의 소스 연결 ID 필드 값을 사용해야 합니다.\(MUST NOT, MUST, MUST\)

서버는 초기 및 0-RTT 패킷에 대한 응답으로 재시도 패킷을 보낼 수 있습니다. 서버는 수신한 0-RTT 패킷을 버리거나 버퍼링할 수 있습니다. 서버는 초기 또는 0-RTT 패킷을 수신할 때 여러 재시도 패킷을 보낼 수 있습니다. 서버는 단일 UDP 데이터그램에 대한 응답으로 두 개 이상의 재시도 패킷을 전송해서는 안 됩니다\(MUST NOT\).\(MAY, MUST NOT\)

---
##### **17.2.5.2.  Handling a Retry Packet**

클라이언트는 각 연결 시도에 대해 최대 하나의 재시도 패킷을 수락하고 처리해야 합니다. 클라이언트가 서버로부터 초기 또는 재시도 패킷을 수신하고 처리한 후에 수신하는 모든 후속 재시도 패킷을 폐기해야 합니다.\(MUST, MUST\)

클라이언트는 검증할 수 없는 재시도 무결성 태그가 있는 재시도 패킷을 폐기해야 합니다. \[QUIC-TLS\]의 섹션 5.8을 참조하십시오. 이는 재시도 패킷을 주입하는 공격자의 능력을 감소시키고 우발적인 재시도 패킷 손상으로부터 보호합니다. 클라이언트는 길이가 0인 재시도 토큰 필드가 있는 재시도 패킷을 폐기해야 합니다.\(MUST, MUST\)

클라이언트는 연결 설정을 계속하기 위해 제공된 재시도 토큰을 포함하는 초기 패킷으로 재시도 패킷에 응답합니다.

클라이언트는 이 초기 패킷의 대상 연결 ID 필드를 재시도 패킷의 소스 연결 ID 필드 값으로 설정합니다. 대상 연결 ID 필드를 변경하면 초기 패킷을 보호하는 데 사용되는 키도 변경됩니다. 또한 Token 필드를 Retry 패킷에 제공된 토큰으로 설정합니다. 클라이언트는 서버가 토큰 유효성 검사 논리의 일부로 연결 ID를 포함할 수 있기 때문에 소스 연결 ID를 변경해서는 안 됩니다\(MUST NOT\). 섹션 8.1.4를 참조하십시오.\(MUST NOT\)

재시도 패킷에는 패킷 번호가 포함되지 않으며 클라이언트에서 명시적으로 확인할 수 없습니다.

---
##### **17.2.5.3.  Continuing a Handshake after Retry**

클라이언트의 후속 초기 패킷에는 재시도 패킷의 연결 ID 및 토큰 값이 포함됩니다. 클라이언트는 재시도 패킷에서 대상 연결 ID 필드로 소스 연결 ID 필드를 복사하고 업데이트된 값이 있는 초기 패킷을 수신할 때까지 이 값을 사용합니다. 섹션 7.2를 참조하십시오. 토큰 필드의 값은 모든 후속 초기 패킷에 복사됩니다. 섹션 8.1.2를 참조하십시오.

대상 연결 ID 및 토큰 필드를 업데이트하는 것 외에 클라이언트가 보낸 초기 패킷에는 첫 번째 초기 패킷과 동일한 제한이 적용됩니다. 클라이언트는 이 패킷에 포함된 것과 동일한 암호화 핸드셰이크 메시지를 사용해야 합니다. 서버는 다른 암호화 핸드셰이크 메시지를 포함하는 패킷을 연결 오류로 처리하거나 폐기할 수 있습니다\(MAY\). 토큰 필드를 포함하면 암호화 핸드셰이크 메시지에 사용할 수 있는 공간이 줄어들어 클라이언트가 여러 개의 초기 패킷을 보내야 할 수 있습니다.\(MUST, MAY\)

클라이언트는 서버에서 제공한 연결 ID로 0-RTT 패킷을 전송하여 재시도 패킷을 수신한 후 0-RTT를 시도할 수 있습니다\(MAY\).\(MAY\)

클라이언트는 재시도 패킷을 처리한 후 패킷 번호 공간에 대한 패킷 번호를 재설정하면 안 됩니다. 특히, 0-RTT 패킷에는 재시도 패킷 수신 시 재전송될 가능성이 가장 높은 기밀 정보가 포함되어 있습니다. 이러한 새로운 0-RTT 패킷을 보호하는 데 사용되는 키는 재시도 패킷에 대한 응답 결과로 변경되지 않습니다. 그러나 이러한 패킷으로 전송된 데이터는 이전에 전송된 것과 다를 수 있습니다. 동일한 패킷 번호를 가진 이러한 새 패킷을 전송하면 동일한 키와 nonce가 다른 콘텐츠를 보호하는 데 사용될 수 있기 때문에 해당 패킷에 대한 패킷 보호가 손상될 수 있습니다. 서버는 클라이언트가 패킷 번호를 재설정한 것을 감지하면 연결을 중단할 수 있습니다\(MAY\).\(MUST NOT, MAY\)

클라이언트와 서버 간에 교환되는 초기 및 재시도 패킷에 사용되는 연결 ID는 전송 매개변수에 복사되고 섹션 7.3에 설명된 대로 유효성이 검사됩니다.

---
### **17.3.  Short Header Packets**

이 QUIC 버전은 짧은 패킷 헤더를 사용하는 단일 패킷 유형을 정의합니다.

---
#### **17.3.1.  1-RTT Packet**

1-RTT 패킷은 짧은 패킷 헤더를 사용합니다. 버전과 1-RTT 키가 협상된 후에 사용됩니다.

```text
   1-RTT Packet {
     Header Form (1) = 0,
     Fixed Bit (1) = 1,
     Spin Bit (1),
     Reserved Bits (2),
     Key Phase (1),
     Packet Number Length (2),
     Destination Connection ID (0..160),
     Packet Number (8..32),
     Packet Payload (8..),
   }

                          Figure 19: 1-RTT Packet
```

1-RTT 패킷에는 다음 필드가 포함됩니다.

헤더 형식: 바이트 0의 최상위 비트\(0x80\)는 짧은 헤더에 대해 0으로 설정됩니다.

고정 비트: 바이트 0의 다음 비트\(0x40\)는 1로 설정됩니다. 이 비트에 대해 0 값을 포함하는 패킷은 이 버전에서 유효한 패킷이 아니므로 폐기해야 합니다. 이 비트의 값이 1이면 QUIC이 다른 프로토콜과 공존할 수 있습니다. \[RFC7983\] 참조.\(MUST\)

스핀 비트: 바이트 0의 세 번째 최상위 비트\(0x20\)는 레이턴시 스핀 비트이며 섹션 17.4에 설명된 대로 설정됩니다.

예약된 비트: 바이트 0의 다음 두 비트\(마스크가 0x18인 비트\)가 예약됩니다. 이 비트는 헤더 보호를 사용하여 보호됩니다. \[QUIC-TLS\]의 섹션 5.4를 참조하십시오. 보호 이전에 포함된 값은 0으로 설정되어야 합니다. 엔드포인트는 패킷 및 헤더 보호를 모두 제거한 후 이러한 비트에 대해 0이 아닌 값을 갖는 패킷 수신을 PROTOCOL\_VIOLATION 유형의 연결 오류로 처리해야 합니다. 헤더 보호만 제거한 후 이러한 패킷을 폐기하면 엔드포인트가 공격에 노출될 수 있습니다. \[QUIC-TLS\]의 섹션 9.5를 참조하십시오.\(MUST, MUST\)

키 단계: 바이트 0의 다음 비트\(0x04\)는 패킷 수신자가 패킷을 보호하는 데 사용되는 패킷 보호 키를 식별할 수 있도록 하는 키 단계를 나타냅니다. 자세한 내용은 \[QUIC-TLS\]를 참조하십시오. 이 비트는 헤더 보호를 사용하여 보호됩니다. \[QUIC-TLS\]의 섹션 5.4를 참조하십시오.

패킷 번호 길이: 바이트 0의 최하위 2비트\(마스크가 0x03인 비트\)는 패킷 번호 필드의 길이보다 하나 작은 부호 없는 2비트 정수로 인코딩된 패킷 번호 필드의 길이를 포함합니다. 바이트. 즉, 패킷 번호 필드의 길이는 이 필드 값에 1을 더한 값입니다. 이 비트는 헤더 보호를 사용하여 보호됩니다. \[QUIC-TLS\]의 섹션 5.4를 참조하십시오.

대상 연결 ID: 대상 연결 ID는 패킷의 의도된 수신자가 선택한 연결 ID입니다. 자세한 내용은 섹션 5.1을 참조하십시오.

패킷 번호: 패킷 번호 필드의 길이는 1\~4바이트입니다. 패킷 번호는 헤더 보호를 사용하여 보호됩니다. \[QUIC-TLS\]의 섹션 5.4를 참조하십시오. 패킷 번호 필드의 길이는 패킷 번호 길이 필드에 인코딩됩니다. 자세한 내용은 섹션 17.1을 참조하십시오.

패킷 페이로드: 1-RTT 패킷에는 항상 1-RTT 보호 페이로드가 포함됩니다.

짧은 헤더 패킷의 헤더 형식 비트와 대상 연결 ID 필드는 버전 독립적입니다. 나머지 필드는 선택한 QUIC 버전에 따라 다릅니다. 다른 버전의 QUIC에서 패킷이 해석되는 방법에 대한 자세한 내용은 \[QUIC-INVARIANTS\]를 참조하십시오.

---
### **17.4.  Latency Spin Bit**

1-RTT 패킷\(섹션 17.3.1\)에 대해 정의된 대기 시간 스핀 비트는 연결 기간 동안 네트워크 경로의 관찰 지점에서 수동 대기 시간 모니터링을 가능하게 합니다. 서버는 받은 회전 값을 반영하고 클라이언트는 한 RTT 후에 "회전"합니다. 경로 관찰자는 두 스핀 비트 토글 이벤트 사이의 시간을 측정하여 연결의 종단 간 RTT를 추정할 수 있습니다.

핸드셰이크를 관찰하여 연결의 초기 RTT를 측정할 수 있기 때문에 스핀 비트는 1-RTT 패킷에만 존재합니다. 따라서 버전 협상 및 연결 설정이 완료된 후에 스핀 비트를 사용할 수 있습니다. 온패스 측정 및 레이턴시 스핀 비트의 사용은 \[빠른 관리 능력\]에서 자세히 설명합니다.

스핀 비트는 이 QUIC 버전의 옵션 기능입니다. 이 기능을 지원하지 않는 엔드포인트는 아래에 정의된 대로 비활성화해야 합니다.\(MAY, MUST\)

각 엔드포인트는 스핀 비트가 연결에 대해 활성화 또는 비활성화되는지를 일방적으로 결정합니다. 구현은 클라이언트 및 서버의 관리자가 전체적으로 또는 연결별로 스핀 비트를 비활성화할 수 있도록 허용해야 합니다\(MUST\). 스핀 비트가 관리자에 의해 비활성화되지 않은 경우에도 엔드포인트는 QUIC를 보장하기 위해 적어도 16개의 네트워크 경로 중 하나 또는 16개의 연결 ID 중 하나의 임의 선택에 대해 스핀 비트 사용을 비활성화해야 합니다. 스핀 비트를 비활성화하는 연결은 일반적으로 네트워크에서 관찰됩니다. 각 엔드포인트가 스핀 비트를 독립적으로 비활성화하므로 스핀 비트 신호가 네트워크 경로 8개 중 약 1개에서 비활성화됩니다.\(MUST, MUST\)

스핀 비트가 비활성화되면 엔드포인트는 스핀 비트를 임의의 값으로 설정할 수 있으며 들어오는 값을 무시해야 합니다. 엔드포인트가 스핀 비트를 각 패킷에 대해 독립적으로 선택되거나 각 연결 ID에 대해 독립적으로 선택된 임의의 값으로 설정하는 것이 좋습니다\(RECOMMENDED\).\(MUST, SHOULD\)

스핀 비트가 연결에 대해 활성화된 경우 엔드포인트는 각 네트워크 경로에 대한 스핀 값을 유지하고 해당 경로에서 1-RTT 패킷이 전송될 때 패킷 헤더의 스핀 비트를 현재 저장된 값으로 설정합니다. 스핀 값은 각 네트워크 경로의 끝점에서 0으로 초기화됩니다. 각 끝점은 또한 각 경로의 피어에서 본 가장 높은 패킷 번호를 기억합니다.

서버가 주어진 네트워크 경로에서 클라이언트로부터 서버가 볼 수 있는 가장 높은 패킷 번호를 증가시키는 1-RTT 패킷을 수신하면 해당 경로의 스핀 값을 수신된 패킷의 스핀 비트와 동일하게 설정합니다.

클라이언트가 주어진 네트워크 경로에서 서버로부터 클라이언트가 볼 수 있는 가장 높은 패킷 번호를 증가시키는 1-RTT 패킷을 수신하면 해당 경로의 스핀 값을 수신된 패킷의 스핀 비트의 역으로 ​​설정합니다.

엔드포인트는 해당 네트워크 경로에서 사용 중인 연결 ID를 변경할 때 네트워크 경로의 스핀 값을 0으로 재설정합니다.

---
## **18.  Transport Parameter Encoding**

\[QUIC-TLS\]에 정의된 quic\_transport\_parameters 확장의 extension\_data 필드는 QUIC 전송 매개변수를 포함합니다. 그림 20과 같이 일련의 전송 매개변수로 인코딩됩니다.

```text
   Transport Parameters {
     Transport Parameter (..) ...,
   }

                Figure 20: Sequence of Transport Parameters
```

각 전송 매개변수는 그림 21과 같이 \(식별자, 길이, 값\) 튜플로 인코딩됩니다.

```text
   Transport Parameter {
     Transport Parameter ID (i),
     Transport Parameter Length (i),
     Transport Parameter Value (..),
   }

                  Figure 21: Transport Parameter Encoding
```

전송 매개변수 길이 필드에는 전송 매개변수 값 필드의 길이\(바이트\)가 포함됩니다.

QUIC는 전송 매개변수를 일련의 바이트로 인코딩한 다음 암호화 핸드셰이크에 포함합니다.

---
### **18.1.  Reserved Transport Parameters**

N의 정수 값에 대해 "31 \* N + 27" 형식의 식별자가 있는 전송 매개변수는 알 수 없는 전송 매개변수를 무시해야 한다는 요구 사항을 실행하기 위해 예약되어 있습니다. 이러한 전송 매개변수에는 의미 체계가 없으며 임의의 값을 전달할 수 있습니다.

---
### **18.2.  Transport Parameter Definitions**

이 섹션에서는 이 문서에 정의된 전송 매개변수에 대해 자세히 설명합니다.

여기에 나열된 많은 전송 매개변수에는 정수 값이 있습니다. 정수로 식별되는 전송 매개변수는 가변 길이 정수 인코딩을 사용합니다. 섹션 16을 참조하십시오. 달리 명시되지 않는 한 전송 매개변수가 없으면 전송 매개변수의 기본값은 0입니다.

다음 전송 매개변수가 정의됩니다.

original\_destination\_connection\_id\(0x00\): 이 매개변수는 클라이언트가 보낸 첫 번째 초기 패킷의 대상 연결 ID 필드 값입니다. 섹션 7.3을 참조하십시오. 이 전송 매개변수는 서버에서만 전송됩니다.

max\_idle\_timeout\(0x01\): 최대 유휴 시간 초과는 정수로 인코딩된 밀리초 단위의 값입니다. \(섹션 10.1\)을 참조하십시오. 두 끝점이 이 전송 매개변수를 생략하거나 값을 0으로 지정하면 유휴 시간 제한이 비활성화됩니다.

stateless\_reset\_token\(0x02\): 무상태 재설정 토큰은 무상태 재설정을 확인하는 데 사용됩니다. 섹션 10.3을 참조하십시오. 이 매개변수는 16바이트 시퀀스입니다. 이 전송 매개변수는 클라이언트에서 보내면 안 되며 서버에서 보낼 수도 있습니다. 이 전송 매개 변수를 보내지 않는 서버는 핸드셰이크 중에 협상된 연결 ID에 대해 상태 비저장 재설정\(섹션 10.3\)을 사용할 수 없습니다.\(MUST NOT\)

max\_udp\_payload\_size\(0x03\): 최대 UDP 페이로드 크기 매개변수는 엔드포인트가 수신하려는 UDP 페이로드의 크기를 제한하는 정수 값입니다. 이 제한보다 큰 페이로드가 있는 UDP 데이터그램은 수신자에 의해 처리될 가능성이 없습니다.

- 이 매개변수의 기본값은 65527의 최대 허용 UDP 페이로드입니다. 1200 미만의 값은 유효하지 않습니다.

- 이 제한은 경로 MTU와 같은 방식으로 데이터그램 크기에 대한 추가 제약으로 작용하지만 경로가 아닌 끝점의 속성입니다. 섹션 14를 참조하십시오. 엔드포인트가 수신 패킷을 보관하는 전용 공간이라고 예상됩니다.

initial\_max\_data\(0x04\): 초기 최대 데이터 매개 변수는 연결에서 보낼 수 있는 최대 데이터 양에 대한 초기 값을 포함하는 정수 값입니다. 이는 핸드셰이크를 완료한 직후 연결에 대한 MAX\_DATA\(19.9절\)를 보내는 것과 같습니다.

initial\_max\_stream\_data\_bidi\_local\(0x05\): 이 매개변수는 로컬에서 시작된 양방향 스트림에 대한 초기 흐름 제어 제한을 지정하는 정수 값입니다. 이 제한은 전송 매개변수를 전송하는 엔드포인트에서 여는 새로 생성된 양방향 스트림에 적용됩니다. 클라이언트 전송 매개변수에서 이는 최하위 2비트가 0x00으로 설정된 식별자가 있는 스트림에 적용됩니다. 서버 전송 매개변수에서 이는 최하위 2비트가 0x01로 설정된 스트림에 적용됩니다.

initial\_max\_stream\_data\_bidi\_remote\(0x06\): 이 매개변수는 피어 시작 양방향 스트림에 대한 초기 흐름 제어 제한을 지정하는 정수 값입니다. 이 제한은 전송 매개변수를 수신하는 엔드포인트에서 연 새로 생성된 양방향 스트림에 적용됩니다. 클라이언트 전송 매개변수에서 이는 최하위 2비트가 0x01로 설정된 식별자가 있는 스트림에 적용됩니다. 서버 전송 매개변수에서 이는 최하위 2비트가 0x00으로 설정된 스트림에 적용됩니다.

initial\_max\_stream\_data\_uni\(0x07\): 이 파라미터는 단방향 스트림에 대한 초기 흐름 제어 제한을 지정하는 정수 값입니다. 이 제한은 전송 매개변수를 수신하는 엔드포인트에서 연 새로 생성된 단방향 스트림에 적용됩니다. 클라이언트 전송 매개변수에서 이는 최하위 2비트가 0x03으로 설정된 식별자가 있는 스트림에 적용됩니다. 서버 전송 매개변수에서 이는 최하위 2비트가 0x02로 설정된 스트림에 적용됩니다.

initial\_max\_streams\_bidi\(0x08\): 초기 최대 양방향 스트림 매개변수는 이 전송 매개변수를 수신하는 엔드포인트가 시작할 수 있는 초기 최대 양방향 스트림 수를 포함하는 정수 값입니다. 이 매개변수가 없거나 0인 경우 피어는 MAX\_STREAMS 프레임이 전송될 때까지 양방향 스트림을 열 수 없습니다. 이 매개변수를 설정하는 것은 동일한 값을 가진 해당 유형의 MAX\_STREAMS\(19.11절\)를 보내는 것과 같습니다.

initial\_max\_streams\_uni\(0x09\): 초기 최대 단방향 스트림 매개변수는 이 전송 매개변수를 수신하는 엔드포인트가 시작할 수 있는 단방향 스트림의 초기 최대 수를 포함하는 정수 값입니다. 이 매개변수가 없거나 0인 경우 피어는 MAX\_STREAMS 프레임이 전송될 때까지 단방향 스트림을 열 수 없습니다. 이 매개변수를 설정하는 것은 동일한 값을 가진 해당 유형의 MAX\_STREAMS\(19.11절\)를 보내는 것과 같습니다.

ack\_delay\_exponent\(0x0a\): ACK 지연 지수는 ACK 프레임\(Section 19.3\)에서 ACK Delay 필드를 디코딩하기 위해 사용되는 지수를 나타내는 정수 값이다. 이 값이 없으면 기본값 3이 가정됩니다\(승수 8을 나타냄\). 20보다 큰 값은 유효하지 않습니다.

max\_ack\_delay\(0x0b\): 최대 승인 지연은 엔드포인트가 승인 전송을 지연시키는 최대 시간\(밀리초\)을 나타내는 정수 값입니다. 이 값은 알람 발생 시 수신기의 예상 지연을 포함해야 합니다\(SHOULD\). 예를 들어 수신기가 타이머를 5ms로 설정하고 알람이 일반적으로 최대 1ms 늦게 발생하는 경우 max\_ack\_delay를 6ms로 보내야 합니다. 이 값이 없으면 기본값 25밀리초로 가정합니다. 2^14 이상의 값은 유효하지 않습니다.\(SHOULD\)

disable\_active\_migration\(0x0c\): 비활성화 활성 마이그레이션 전송 매개변수는 엔드포인트가 핸드셰이크 중에 사용 중인 주소에서 활성 연결 마이그레이션\(섹션 9\)을 지원하지 않는 경우 포함됩니다. 이 전송 매개변수를 수신하는 끝점은 핸드셰이크 중에 피어가 사용한 주소로 보낼 때 새 로컬 주소를 사용해서는 안 됩니다. 이 전송 매개변수는 클라이언트가 preferred\_address 전송 매개변수에 대해 작업을 수행한 후 연결 마이그레이션을 금지하지 않습니다. 이 매개변수는 길이가 0인 값입니다.\(MUST NOT\)

Preferred\_address \(0x0d\): 서버의 선호 주소는 섹션 9.6에 설명된 대로 핸드셰이크 종료 시 서버 주소 변경에 영향을 미치는 데 사용됩니다. 이 전송 매개변수는 서버에서만 전송됩니다. 서버는 다른 패밀리에 대해 모두 0인 주소와 포트\(0.0.0.0:0 또는 \[::\]:0\)를 전송하여 한 주소 패밀리의 기본 주소만 전송하도록 선택할 수 있습니다\(MAY\). IP 주소는 네트워크 바이트 순서로 인코딩됩니다.\(MAY\)

- preferred\_address 전송 매개변수에는 IPv4 및 IPv6 모두에 대한 주소와 포트가 포함되어 있습니다. 4바이트 IPv4 주소 필드 다음에는 관련 2바이트 IPv4 포트 필드가 옵니다. 그 다음에는 16바이트 IPv6 주소 필드와 2바이트 IPv6 포트 필드가 옵니다. 주소 및 포트 쌍 뒤에 있는 연결 ID 길이 필드는 다음 연결 ID 필드의 길이를 설명합니다. 마지막으로 16바이트 상태 비저장 재설정 토큰 필드에는 연결 ID와 연결된 상태 비저장 재설정 토큰이 포함됩니다. 이 전송 매개변수의 형식은 아래 그림 22에 나와 있습니다.

- 연결 ID 필드와 상태 비저장 재설정 토큰 필드에는 시퀀스 번호가 1인 대체 연결 ID가 포함되어 있습니다. 섹션 5.1.1을 참조하십시오. 기본 주소와 함께 이러한 값을 전송하면 클라이언트가 기본 주소로 마이그레이션을 시작할 때 사용되지 않은 활성 연결 ID가 하나 이상 있게 됩니다.

- 선호 주소의 연결 ID 및 상태 비저장 재설정 토큰 필드는 NEW\_CONNECTION\_ID 프레임\(섹션 19.15\)의 해당 필드와 구문 및 의미가 동일합니다. 길이가 0인 연결 ID를 선택한 서버는 선호하는 주소를 제공하면 안 됩니다. 마찬가지로 서버는 이 전송 매개변수에 길이가 0인 연결 ID를 포함해서는 안 됩니다\(MUST NOT\). 클라이언트는 이러한 요구 사항 위반을 TRANSPORT\_PARAMETER\_ERROR 유형의 연결 오류로 처리해야 합니다.\(MUST NOT, MUST NOT, MUST\)

```text
   Preferred Address {
     IPv4 Address (32),
     IPv4 Port (16),
     IPv6 Address (128),
     IPv6 Port (16),
     Connection ID Length (8),
     Connection ID (..),
     Stateless Reset Token (128),
   }

                    Figure 22: Preferred Address Format
```

active\_connection\_id\_limit\(0x0e\): 정수 값입니다.

- 엔드포인트가 저장하려는 피어의 최대 연결 ID 수를 지정합니다. 이 값에는 핸드셰이크 중에 수신된 연결 ID, preferred\_address 전송 매개변수에서 수신된 연결 ID 및 NEW\_CONNECTION\_ID 프레임에서 수신된 연결 ID가 포함됩니다. active\_connection\_id\_limit 매개변수의 값은 2 이상이어야 합니다. 2 미만의 값을 수신하는 엔드포인트는 TRANSPORT\_PARAMETER\_ERROR 유형의 오류로 연결을 닫아야 합니다. 이 전송 매개변수가 없으면 기본값 2가 가정됩니다. 엔드포인트가 길이가 0인 연결 ID를 발급하면 NEW\_CONNECTION\_ID 프레임을 보내지 않으므로 피어에서 받은 active\_connection\_id\_limit 값을 무시합니다.\(MUST, MUST\)

initial\_source\_connection\_id\(0x0f\): 연결을 위해 전송하는 첫 번째 초기 패킷의 소스 연결 ID 필드에 포함된 엔드포인트 값입니다. 섹션 7.3을 참조하십시오.

retry\_source\_connection\_id\(0x10\): 이것은 서버가 재시도 패킷의 소스 연결 ID 필드에 포함시킨 값입니다. 섹션 7.3을 참조하십시오. 이 전송 매개변수는 서버에서만 전송됩니다.

존재하는 경우 초기 스트림별 흐름 제어 제한\(initial\_max\_stream\_data\_bidi\_local, initial\_max\_stream\_data\_bidi\_remote 및 initial\_max\_stream\_data\_uni\)을 설정하는 전송 매개변수는 개방 직후 해당 유형의 모든 스트림에서 MAX\_STREAM\_DATA 프레임\(19.10절\)을 보내는 것과 같습니다. 전송 매개변수가 없으면 해당 유형의 스트림은 흐름 제어 제한 0으로 시작합니다.

클라이언트는 original\_destination\_connection\_id, preferred\_address, retry\_source\_connection\_id 또는 stateless\_reset\_token과 같은 서버 전용 전송 매개변수를 포함하면 안 됩니다\(MUST NOT\). 서버는 이러한 전송 매개변수의 수신을 TRANSPORT\_PARAMETER\_ERROR 유형의 연결 오류로 처리해야 합니다.\(MUST NOT, MUST\)

---
## **19.  Frame Types and Formats**

12.4절에서 설명한 것처럼 패킷에는 하나 이상의 프레임이 포함됩니다. 이 섹션에서는 핵심 QUIC 프레임 유형의 형식과 의미를 설명합니다.

---
### **19.1.  PADDING Frames**

PADDING 프레임\(유형=0x00\)에는 의미론적 값이 없습니다. PADDING 프레임을 사용하여 패킷 크기를 늘릴 수 있습니다. 패딩을 사용하여 초기 패킷을 필요한 최소 크기로 늘리거나 보호된 패킷에 대한 트래픽 분석으로부터 보호를 제공할 수 있습니다.

PADDING 프레임은 PADDING 프레임에 내용이 없음을 보여주는 그림 23과 같이 형식이 지정됩니다. 즉, PADDING 프레임은 프레임을 PADDING 프레임으로 식별하는 단일 바이트로 구성됩니다.

```text
   PADDING Frame {
     Type (i) = 0x00,
   }

                      Figure 23: PADDING Frame Format
```

---
### **19.2.  PING Frames**

끝점은 PING 프레임\(유형=0x01\)을 사용하여 피어가 아직 살아 있는지 확인하거나 피어에 대한 도달 가능성을 확인할 수 있습니다.

PING 프레임은 PING 프레임에 콘텐츠가 없음을 보여주는 그림 24와 같이 형식이 지정됩니다.

```text
   PING Frame {
     Type (i) = 0x01,
   }

                        Figure 24: PING Frame Format
```

PING 프레임의 수신자는 이 프레임이 포함된 패킷을 승인하기만 하면 됩니다.

PING 프레임은 응용 프로그램 또는 응용 프로그램 프로토콜이 연결 시간 초과를 방지하려는 경우 연결을 활성 상태로 유지하는 데 사용할 수 있습니다. 섹션 10.1.2를 참조하십시오.

---
### **19.3.  ACK Frames**

수신자는 ACK 프레임\(유형 0x02 및 0x03\)을 전송하여 수신하고 처리한 패킷을 발신자에게 알립니다. ACK 프레임에는 하나 이상의 ACK 범위가 포함됩니다. ACK 범위는 확인된 패킷을 식별합니다. 프레임 유형이 0x03인 경우 ACK 프레임에는 이 시점까지 연결에서 수신된 관련 ECN 마크가 있는 QUIC 패킷의 누적 카운트도 포함됩니다. QUIC 구현은 두 가지 유형을 모두 적절하게 처리해야 하며, 전송하는 패킷에 대해 ECN을 활성화한 경우 ECN 섹션의 정보를 사용하여 정체 상태를 관리해야 합니다\(SHOULD\).\(MUST\)

QUIC 승인은 취소할 수 없습니다. 패킷이 확인되면 향후 ACK 프레임에 나타나지 않더라도 패킷은 확인된 상태로 유지됩니다. 이것은 TCP SACK\(Selective Acknowledgement\)\[RFC2018\]에 대한 갱신과 다릅니다.

다른 패킷 번호 공간의 패킷은 동일한 숫자 값을 사용하여 식별할 수 있습니다. 패킷에 대한 승인은 패킷 번호와 패킷 번호 공간을 모두 표시해야 합니다. 이는 각 ACK 프레임이 ACK 프레임이 포함된 패킷과 동일한 공간에 있는 승인 패킷 번호만 가짐으로써 달성됩니다.

Version Negotiation 및 Retry 패킷은 패킷 번호를 포함하지 않기 때문에 승인할 수 없습니다. ACK 프레임에 의존하지 않고 이러한 패킷은 클라이언트가 보낸 다음 초기 패킷에 의해 암시적으로 승인됩니다.

ACK 프레임은 그림 25와 같이 형식이 지정됩니다.

```text
   ACK Frame {
     Type (i) = 0x02..0x03,
     Largest Acknowledged (i),
     ACK Delay (i),
     ACK Range Count (i),
     First ACK Range (i),
     ACK Range (..) ...,
     [ECN Counts (..)],
   }

                        Figure 25: ACK Frame Format
```

ACK 프레임에는 다음 필드가 포함됩니다.

가장 큰 승인: 피어가 승인하는 가장 큰 패킷 번호를 나타내는 가변 길이 정수입니다. 이것은 일반적으로 피어가 ACK 프레임을 생성하기 전에 수신한 가장 큰 패킷 번호입니다. QUIC 긴 헤더 또는 짧은 헤더의 패킷 번호와 달리 ACK 프레임의 값은 잘리지 않습니다.

ACK 지연: 승인 지연을 마이크로초 단위로 인코딩하는 가변 길이 정수. 섹션 13.2.5를 참조하십시오. 필드의 값에 ACK 프레임의 송신자가 보낸 ack\_delay\_exponent 전송 매개변수의 거듭제곱에 2를 곱하여 디코딩됩니다. 섹션 18.2를 참조하십시오. 단순히 지연을 정수로 표현하는 것과 비교할 때, 이 인코딩은 더 낮은 해상도를 희생시키면서 동일한 바이트 수 내에서 더 넓은 범위의 값을 허용합니다.

ACK 범위 수: 프레임의 ACK 범위 필드 수를 지정하는 가변 길이 정수입니다.

첫 번째 ACK 범위: 확인 중인 가장 큰 확인 이전의 연속 패킷 수를 나타내는 가변 길이 정수입니다. 즉, 범위에서 확인된 가장 작은 패킷은 Largest Acknowledged 필드에서 First ACK Range 값을 빼서 결정됩니다.

ACK 범위: 패킷의 추가 범위를 포함합니다.

- 번갈아 승인되지 않음\(Gap\) 및 승인됨\(ACK Range\); 섹션 19.3.1을 참조하십시오.

ECN 카운트: 세 가지 ECN 카운트. 섹션 19.3.2를 참조하십시오.

---
#### **19.3.1.  ACK Ranges**

각 ACK 범위는 내림차순 패킷 번호 순서로 번갈아 나타나는 Gap 및 ACK 범위 길이 값으로 구성됩니다. ACK 범위는 반복될 수 있습니다. 간격 및 ACK 범위 길이 값의 수는 ACK 범위 수 필드에 의해 결정됩니다. 각 값 중 하나는 ACK 범위 카운트 필드의 각 값에 대해 존재합니다.

ACK 범위는 그림 26과 같이 구성됩니다.

```text
   ACK Range {
     Gap (i),
     ACK Range Length (i),
   }

                           Figure 26: ACK Ranges
```

각 ACK 범위를 구성하는 필드는 다음과 같습니다.

Gap: 이전 ACK 범위에서 가장 작은 패킷 번호보다 하나 낮은 패킷 번호 이전의 연속적인 미확인 패킷 수를 나타내는 가변 길이 정수입니다.

ACK 범위 길이: 앞선 Gap에 의해 결정된 대로 가장 큰 패킷 번호 앞에 있는 연속 확인 패킷의 수를 나타내는 가변 길이 정수입니다.

간격 및 ACK 범위 길이 값은 효율성을 위해 상대 정수 인코딩을 사용합니다. 각각의 인코딩된 값은 양수이지만 각 ACK 범위가 점진적으로 낮은 번호의 패킷을 설명하도록 값을 뺍니다.

각 ACK 범위는 해당 범위에서 가장 큰 패킷 번호 앞에 있는 확인된 패킷 수를 표시하여 패킷의 연속 범위를 확인합니다. 값 0은 가장 큰 패킷 번호만 승인됨을 나타냅니다. 더 큰 ACK 범위 값은 더 큰 범위를 나타내며 범위에서 가장 작은 패킷 번호에 해당하는 더 낮은 값을 갖습니다. 따라서 범위에 대해 가장 큰 패킷 번호가 주어지면 가장 작은 값은 다음 공식에 의해 결정됩니다.

```text
      smallest = largest - ack_range
```

ACK 범위는 가장 작은 패킷 번호와 가장 큰 패킷 번호 사이의 모든 패킷을 승인합니다.

ACK 범위의 가장 큰 값은 이전의 모든 ACK 범위 길이 및 간격의 크기를 누적하여 빼서 결정됩니다.

각 Gap은 승인되지 않은 패킷 범위를 나타냅니다. 간격의 패킷 수는 간격 필드의 인코딩된 값보다 하나 더 큽니다.

간격 필드의 값은 다음 공식을 사용하여 후속 ACK 범위에 대한 가장 큰 패킷 번호 값을 설정합니다.

```text
      largest = previous_smallest - gap - 2
```

계산된 패킷 번호가 음수인 경우 엔드포인트는 FRAME\_ENCODING\_ERROR 유형의 연결 오류를 생성해야 합니다.\(MUST\)

---
#### **19.3.2.  ECN Counts**

ACK 프레임은 유형 값\(즉, 유형 0x03\)의 최하위 비트를 사용하여 ECN 피드백을 나타내고 ECT\(0\), ECT\(1\) 또는 ECN-CE의 관련 ECN 코드포인트가 있는 QUIC 패킷의 수신을 보고합니다. 패킷의 IP 헤더 ECN 카운트는 ACK 프레임 유형이 0x03인 경우에만 존재합니다.

존재하는 경우 그림 27과 같이 3개의 ECN 카운트가 있습니다.

```text
   ECN Counts {
     ECT0 Count (i),
     ECT1 Count (i),
     ECN-CE Count (i),
   }

                        Figure 27: ECN Count Format
```

ECN 개수 필드는 다음과 같습니다.

ECT0 개수: ACK 프레임의 패킷 번호 공간에서 ECT\(0\) 코드포인트로 수신된 총 패킷 수를 나타내는 가변 길이 정수입니다.

ECT1 카운트: ACK 프레임의 패킷 번호 공간에서 ECT\(1\) 코드포인트로 수신된 총 패킷 수를 나타내는 가변 길이 정수입니다.

ECN-CE Count: ACK 프레임의 패킷 번호 공간에서 ECN-CE 코드포인트로 수신된 총 패킷 수를 나타내는 가변 길이 정수입니다.

ECN 수는 각 패킷 번호 공간에 대해 별도로 유지됩니다.

---
### **19.4.  RESET_STREAM Frames**

끝점은 RESET\_STREAM 프레임\(유형=0x04\)을 사용하여 스트림의 전송 부분을 갑자기 종료합니다.

RESET\_STREAM을 보낸 후 엔드포인트는 식별된 스트림에서 STREAM 프레임의 전송 및 재전송을 중단합니다. RESET\_STREAM의 수신자는 해당 스트림에서 이미 수신한 모든 데이터를 버릴 수 있습니다.

전송 전용 스트림에 대한 RESET\_STREAM 프레임을 수신하는 엔드포인트는 STREAM\_STATE\_ERROR 오류와 함께 연결을 종료해야 합니다.\(MUST\)

RESET\_STREAM 프레임은 그림 28과 같이 형식이 지정됩니다.

```text
   RESET_STREAM Frame {
     Type (i) = 0x04,
     Stream ID (i),
     Application Protocol Error Code (i),
     Final Size (i),
   }

                    Figure 28: RESET_STREAM Frame Format
```

RESET\_STREAM 프레임에는 다음 필드가 포함됩니다.

스트림 ID: 종료되는 스트림의 스트림 ID에 대한 가변 길이 정수 인코딩입니다.

애플리케이션 프로토콜 오류 코드: 가변 길이 정수

- 스트림이 닫히는 이유를 나타내는 애플리케이션 프로토콜 오류 코드\(섹션 20.2 참조\)를 포함합니다.

최종 크기: RESET\_STREAM 송신자에 의한 스트림의 최종 크기를 바이트 단위로 나타내는 가변 길이 정수. 섹션 4.5를 참조하십시오.

---
### **19.5.  STOP_SENDING Frames**

엔드포인트는 STOP\_SENDING 프레임\(유형=0x05\)을 사용하여 들어오는 데이터가 응용 프로그램 요청당 수신 시 삭제되고 있음을 전달합니다. STOP\_SENDING은 피어가 스트림에서 전송을 중지하도록 요청합니다.

"Recv" 또는 "Size Known" 상태의 스트림에 대해 STOP\_SENDING 프레임을 보낼 수 있습니다. 섹션 3.2를 참조하십시오. 아직 생성되지 않은 로컬에서 시작된 스트림에 대한 STOP\_SENDING 프레임 수신은 STREAM\_STATE\_ERROR 유형의 연결 오류로 처리되어야 합니다. 수신 전용 스트림에 대한 STOP\_SENDING 프레임을 수신하는 엔드포인트는 오류 STREAM\_STATE\_ERROR와 함께 연결을 종료해야 합니다.\(MUST, MUST\)

STOP\_SENDING 프레임은 그림 29와 같이 형식이 지정됩니다.

```text
   STOP_SENDING Frame {
     Type (i) = 0x05,
     Stream ID (i),
     Application Protocol Error Code (i),
   }

                    Figure 29: STOP_SENDING Frame Format
```

STOP\_SENDING 프레임에는 다음 필드가 포함됩니다.

스트림 ID: 무시되는 스트림의 스트림 ID를 전달하는 가변 길이 정수입니다.

애플리케이션 프로토콜 오류 코드: 가변 길이 정수

- 보낸 사람이 스트림을 무시하는 응용 프로그램 지정 이유를 포함합니다. 섹션 20.2를 참조하십시오.

---
### **19.6.  CRYPTO Frames**

CRYPTO 프레임\(유형=0x06\)은 암호화 핸드셰이크 메시지를 전송하는 데 사용됩니다. 0-RTT를 제외한 모든 패킷 유형으로 전송할 수 있습니다. CRYPTO 프레임은 암호화 프로토콜에 순서대로 바이트 스트림을 제공합니다. CRYPTO 프레임은 스트림 식별자가 없다는 점을 제외하면 STREAM 프레임과 기능적으로 동일합니다. 흐름이 제어되지 않습니다. 선택적 오프셋, 선택적 길이 및 스트림의 끝을 나타내는 마커를 포함하지 않습니다.

CRYPTO 프레임은 그림 30과 같이 포맷됩니다.

```text
   CRYPTO Frame {
     Type (i) = 0x06,
     Offset (i),
     Length (i),
     Crypto Data (..),
   }

                       Figure 30: CRYPTO Frame Format
```

CRYPTO 프레임에는 다음 필드가 포함됩니다.

오프셋: 이 CRYPTO 프레임의 데이터 스트림에서 바이트 오프셋을 지정하는 가변 길이 정수입니다.

길이: 이 CRYPTO 프레임에서 암호화 데이터 필드의 길이를 지정하는 가변 길이 정수입니다.

암호화 데이터: 암호화 메시지 데이터입니다.

각 암호화 수준에는 별도의 암호화 핸드셰이크 데이터 흐름이 있으며 각 흐름은 오프셋 0에서 시작합니다. 이는 각 암호화 수준이 별도의 CRYPTO 데이터 스트림으로 취급됨을 의미합니다.

스트림에서 전달되는 가장 큰 오프셋\(오프셋과 데이터 길이의 합\)은 2^62-1을 초과할 수 없습니다. 이 제한을 초과하는 프레임 수신은 FRAME\_ENCODING\_ERROR 또는 CRYPTO\_BUFFER\_EXCEEDED 유형의 연결 오류로 처리되어야 합니다.\(MUST\)

데이터가 속한 스트림을 나타내는 스트림 ID를 포함하는 STREAM 프레임과 달리 CRYPTO 프레임은 암호화 수준당 단일 스트림에 대한 데이터를 전달합니다. 스트림에는 명시적인 끝이 없으므로 CRYPTO 프레임에는 FIN 비트가 없습니다.

---
### **19.7.  NEW_TOKEN Frames**

서버는 NEW\_TOKEN 프레임\(유형=0x07\)을 전송하여 향후 연결을 위해 초기 패킷의 헤더에 보낼 토큰을 클라이언트에 제공합니다.

NEW\_TOKEN 프레임은 그림 31과 같이 형식이 지정됩니다.

```text
   NEW_TOKEN Frame {
     Type (i) = 0x07,
     Token Length (i),
     Token (..),
   }

                     Figure 31: NEW_TOKEN Frame Format
```

NEW\_TOKEN 프레임에는 다음 필드가 포함됩니다.

토큰 길이: 토큰 길이를 바이트 단위로 지정하는 가변 길이 정수입니다.

토큰: 클라이언트가 향후 초기 패킷과 함께 사용할 수 있는 불투명 blob입니다. 토큰은 비어 있으면 안 됩니다. 클라이언트는 빈 토큰 필드가 있는 NEW\_TOKEN 프레임의 수신을 FRAME\_ENCODING\_ERROR 유형의 연결 오류로 처리해야 합니다.\(MUST NOT, MUST\)

프레임을 포함하는 패킷이 손실된 것으로 잘못 판단되는 경우 클라이언트는 동일한 토큰 값을 포함하는 여러 NEW\_TOKEN 프레임을 수신할 수 있습니다. 클라이언트는 연결 시도를 연결하는 데 사용될 수 있는 중복 값을 버릴 책임이 있습니다. 섹션 8.1.3을 참조하십시오.

클라이언트는 NEW\_TOKEN 프레임을 보내면 안 됩니다. 서버는 NEW\_TOKEN 프레임 수신을 PROTOCOL\_VIOLATION 유형의 연결 오류로 처리해야 합니다.\(MUST NOT, MUST\)

---
### **19.8.  STREAM Frames**

STREAM 프레임은 암시적으로 스트림을 생성하고 스트림 데이터를 전달합니다. STREAM 프레임의 Type 필드는 0b00001XXX\(또는 0x08에서 0x0f까지의 값 집합\) 형식을 취합니다. 프레임 유형의 하위 3개 비트는 프레임에 있는 필드를 결정합니다.

\* 프레임 유형의 OFF 비트\(0x04\)는 오프셋 필드가 있음을 나타내도록 설정됩니다. 1로 설정하면 오프셋 필드가 나타납니다. 0으로 설정하면 오프셋 필드가 없고 스트림 데이터가 오프셋 0에서 시작합니다\(즉, 프레임에 스트림의 첫 번째 바이트가 포함되거나 데이터가 없는 스트림의 끝이 포함됨\).

\* 프레임 유형의 LEN 비트\(0x02\)는 길이 필드가 있음을 나타내도록 설정됩니다. 이 비트가 0으로 설정되면 길이 필드가 없고 스트림 데이터 필드가 패킷 끝까지 확장됩니다. 이 비트가 1로 설정되면 길이 필드가 있습니다.

\* FIN 비트\(0x01\)는 프레임이 스트림의 끝을 표시함을 나타냅니다. 스트림의 최종 크기는 이 프레임의 오프셋과 길이의 합입니다.

엔드포인트는 아직 생성되지 않은 로컬에서 시작된 스트림 또는 전송 전용 스트림에 대한 STREAM 프레임을 수신하는 경우 STREAM\_STATE\_ERROR 오류와 함께 연결을 종료해야 합니다\(MUST\).\(MUST\)

STREAM 프레임은 그림 32와 같이 형식이 지정됩니다.

```text
   STREAM Frame {
     Type (i) = 0x08..0x0f,
     Stream ID (i),
     [Offset (i)],
     [Length (i)],
     Stream Data (..),
   }

                       Figure 32: STREAM Frame Format
```

STREAM 프레임에는 다음 필드가 포함됩니다.

스트림 ID: 스트림의 스트림 ID를 나타내는 가변 길이 정수. 섹션 2.1을 참조하십시오.

오프셋: 이 STREAM 프레임의 데이터에 대한 스트림의 바이트 오프셋을 지정하는 가변 길이 정수입니다. 이 필드는 OFF 비트가 1로 설정된 경우 존재합니다. 오프셋 필드가 없으면 오프셋은 0입니다.

길이: 이 STREAM 프레임에서 스트림 데이터 필드의 길이를 지정하는 가변 길이 정수. 이 필드는 LEN 비트가 1로 설정된 경우 존재합니다. LEN 비트가 0으로 설정된 경우 스트림 데이터 필드는 패킷의 나머지 바이트를 모두 소비합니다.

스트림 데이터: 전달될 지정된 스트림의 바이트입니다.

스트림 데이터 필드의 길이가 0인 경우 STREAM 프레임의 오프셋은 전송될 다음 바이트의 오프셋입니다.

스트림의 첫 번째 바이트는 오프셋이 0입니다. 스트림에서 전달되는 최대 오프셋\(오프셋과 데이터 길이의 합\)은 흐름 제어 크레딧을 제공할 수 없으므로 2^62-1을 초과할 수 없습니다. 그 데이터. 이 제한을 초과하는 프레임 수신은 FRAME\_ENCODING\_ERROR 또는 FLOW\_CONTROL\_ERROR 유형의 연결 오류로 처리되어야 합니다.\(MUST\)

---
### **19.9.  MAX_DATA Frames**

MAX\_DATA 프레임\(유형=0x10\)은 전체적으로 연결에서 보낼 수 있는 최대 데이터 양을 피어에 알리기 위해 흐름 제어에 사용됩니다.

MAX\_DATA 프레임은 그림 33과 같이 형식이 지정됩니다.

```text
   MAX_DATA Frame {
     Type (i) = 0x10,
     Maximum Data (i),
   }

                      Figure 33: MAX_DATA Frame Format
```

MAX\_DATA 프레임에는 다음 필드가 포함됩니다.

최대 데이터: 전체 연결에서 전송할 수 있는 최대 데이터 양을 바이트 단위로 나타내는 가변 길이 정수.

STREAM 프레임에서 전송된 모든 데이터는 이 제한에 포함됩니다. 터미널 상태의 스트림을 포함하여 모든 스트림의 최종 크기 합계는 수신자가 광고한 값을 초과해서는 안 됩니다\(MUST NOT\). 엔드포인트는 전송한 최대 데이터 값보다 더 많은 데이터를 수신하는 경우 FLOW\_CONTROL\_ERROR 유형의 오류로 연결을 종료해야 합니다\(MUST\). 여기에는 초기 데이터의 기억된 한계 위반이 포함됩니다. 섹션 7.4.1을 참조하십시오.\(MUST NOT, MUST\)

---
### **19.10.  MAX_STREAM_DATA Frames**

MAX\_STREAM\_DATA 프레임\(유형=0x11\)은 스트림에서 보낼 수 있는 최대 데이터 양을 피어에게 알리기 위해 흐름 제어에 사용됩니다.

"Recv" 상태의 스트림에 대해 MAX\_STREAM\_DATA 프레임을 보낼 수 있습니다. 섹션 3.2를 참조하십시오. 아직 생성되지 않은 로컬 초기화 스트림에 대한 MAX\_STREAM\_DATA 프레임 수신은 STREAM\_STATE\_ERROR 유형의 연결 오류로 처리되어야 합니다. 수신 전용 스트림에 대한 MAX\_STREAM\_DATA 프레임을 수신하는 엔드포인트는 STREAM\_STATE\_ERROR 오류와 함께 연결을 종료해야 합니다.\(MUST, MUST\)

MAX\_STREAM\_DATA 프레임은 그림 34와 같이 형식이 지정됩니다.

```text
   MAX_STREAM_DATA Frame {
     Type (i) = 0x11,
     Stream ID (i),
     Maximum Stream Data (i),
   }

                  Figure 34: MAX_STREAM_DATA Frame Format
```

MAX\_STREAM\_DATA 프레임에는 다음 필드가 포함됩니다.

스트림 ID: 가변 길이 정수로 인코딩된 영향을 받는 스트림의 스트림 ID입니다.

최대 스트림 데이터: 식별된 스트림에서 전송할 수 있는 최대 데이터 양을 바이트 단위로 나타내는 가변 길이 정수입니다.

이 제한에 대한 데이터를 계산할 때 끝점은 스트림에서 보내거나 받은 데이터의 가장 큰 수신 오프셋을 설명합니다. 손실 또는 재정렬은 스트림에서 수신된 가장 큰 오프셋이 해당 스트림에서 수신된 데이터의 총 크기보다 클 수 있음을 의미할 수 있습니다. STREAM 프레임을 수신해도 수신된 최대 오프셋이 증가하지 않을 수 있습니다.

스트림에서 전송된 데이터는 수신자가 광고한 가장 큰 최대 스트림 데이터 값을 초과해서는 안 됩니다\(MUST NOT\). 엔드포인트는 영향을 받는 스트림에 대해 보낸 가장 큰 최대 스트림 데이터보다 더 많은 데이터를 수신하는 경우 FLOW\_CONTROL\_ERROR 유형의 오류로 연결을 종료해야 합니다\(MUST\). 여기에는 초기 데이터의 기억된 한계 위반이 포함됩니다. 섹션 7.4.1을 참조하십시오.\(MUST NOT, MUST\)

---
### **19.11.  MAX_STREAMS Frames**

MAX\_STREAMS 프레임\(유형=0x12 또는 0x13\)은 개방이 허용된 주어진 유형의 누적 스트림 수를 피어에게 알립니다. 0x12 유형의 MAX\_STREAMS 프레임은 양방향 스트림에 적용되고 0x13 유형의 MAX\_STREAMS 프레임은 단방향 스트림에 적용됩니다.

MAX\_STREAMS 프레임은 그림 35와 같이 형식이 지정됩니다.

```text
   MAX_STREAMS Frame {
     Type (i) = 0x12..0x13,
     Maximum Streams (i),
   }

                    Figure 35: MAX_STREAMS Frame Format
```

MAX\_STREAMS 프레임에는 다음 필드가 포함됩니다.

최대 스트림: 연결 수명 동안 열 수 있는 해당 유형의 누적 스트림 수입니다. 이 값은 2^62-1보다 큰 스트림 ID를 인코딩할 수 없으므로 2^60을 초과할 수 없습니다. 이 제한보다 큰 스트림 열기를 허용하는 프레임 수신은 FRAME\_ENCODING\_ERROR 유형의 연결 오류로 처리되어야 합니다.\(MUST\)

손실 또는 재정렬로 인해 끝점이 이전에 받은 것보다 스트림 제한이 낮은 MAX\_STREAMS 프레임을 받을 수 있습니다. 스트림 제한을 늘리지 않는 MAX\_STREAMS 프레임은 무시해야 합니다\(MUST\).\(MUST\)

엔드포인트는 피어가 설정한 현재 스트림 제한에서 허용하는 것보다 더 많은 스트림을 열면 안 됩니다\(MUST NOT\). 예를 들어 단방향 스트림 제한 3을 수신하는 서버는 스트림 3, 7, 11을 열 수 있지만 스트림 15는 열 수 없습니다. 종점은 피어가 열린 것보다 더 많은 스트림을 열면 STREAM\_LIMIT\_ERROR 유형의 오류로 연결을 종료해야 합니다. 허용. 여기에는 초기 데이터의 기억된 한계 위반이 포함됩니다. 섹션 7.4.1을 참조하십시오.\(MUST NOT, MUST\)

이러한 프레임\(및 해당 전송 매개변수\)은 동시에 열 수 있는 스트림 수를 설명하지 않습니다. 제한에는 닫힌 스트림과 열려 있는 스트림이 포함됩니다.

---
### **19.12.  DATA_BLOCKED Frames**

보낸 사람은 데이터를 보내고 싶지만 연결 수준 흐름 제어로 인해 그렇게 할 수 없는 경우 DATA\_BLOCKED 프레임\(유형=0x14\)을 보내야 합니다\(SHOULD\). 섹션 4를 참조하십시오. DATA\_BLOCKED 프레임은 흐름 제어 알고리즘을 조정하기 위한 입력으로 사용할 수 있습니다. 섹션 4.2를 참조하십시오.\(SHOULD\)

DATA\_BLOCKED 프레임은 그림 36과 같이 형식이 지정됩니다.

```text
   DATA_BLOCKED Frame {
     Type (i) = 0x14,
     Maximum Data (i),
   }

                    Figure 36: DATA_BLOCKED Frame Format
```

DATA\_BLOCKED 프레임에는 다음 필드가 포함됩니다.

최대 데이터: 차단이 발생한 연결 수준 제한을 나타내는 가변 길이 정수입니다.

---
### **19.13.  STREAM_DATA_BLOCKED Frames**

보낸 사람은 데이터를 보내고 싶지만 스트림 수준 흐름 제어로 인해 그렇게 할 수 없는 경우 STREAM\_DATA\_BLOCKED 프레임\(유형=0x15\)을 보내야 합니다\(SHOULD\). 이 프레임은 DATA\_BLOCKED\(19.12절\)와 유사합니다.\(SHOULD\)

전송 전용 스트림에 대한 STREAM\_DATA\_BLOCKED 프레임을 수신하는 엔드포인트는 STREAM\_STATE\_ERROR 오류와 함께 연결을 종료해야 합니다.\(MUST\)

STREAM\_DATA\_BLOCKED 프레임은 그림 37과 같이 형식이 지정됩니다.

```text
   STREAM_DATA_BLOCKED Frame {
     Type (i) = 0x15,
     Stream ID (i),
     Maximum Stream Data (i),
   }

                Figure 37: STREAM_DATA_BLOCKED Frame Format
```

STREAM\_DATA\_BLOCKED 프레임에는 다음 필드가 포함됩니다.

스트림 ID: 흐름 제어로 인해 차단된 스트림을 나타내는 가변 길이 정수입니다.

최대 스트림 데이터: 차단이 발생한 스트림의 오프셋을 나타내는 가변 길이 정수입니다.

---
### **19.14.  STREAMS_BLOCKED Frames**

송신자는 스트림을 열려고 하지만 피어가 설정한 최대 스트림 제한으로 인해 그렇게 할 수 없는 경우 STREAMS\_BLOCKED 프레임\(유형=0x16 또는 0x17\)을 보내야 합니다\(SHOULD\). 섹션 19.11을 참조하십시오. 0x16 유형의 STREAMS\_BLOCKED 프레임은 양방향 스트림 제한에 도달했음을 나타내는 데 사용되고 0x17 유형의 STREAMS\_BLOCKED 프레임은 단방향 스트림 제한에 도달했음을 나타내는 데 사용됩니다.\(SHOULD\)

STREAMS\_BLOCKED 프레임은 스트림을 열지 않지만 피어에게 새 스트림이 필요했고 스트림 제한으로 인해 스트림 생성이 금지되었음을 알립니다.

STREAMS\_BLOCKED 프레임은 그림 38과 같이 형식이 지정됩니다.

```text
   STREAMS_BLOCKED Frame {
     Type (i) = 0x16..0x17,
     Maximum Streams (i),
   }

                  Figure 38: STREAMS_BLOCKED Frame Format
```

STREAMS\_BLOCKED 프레임에는 다음 필드가 포함됩니다.

최대 스트림: 프레임이 전송된 시점에 허용된 최대 스트림 수를 나타내는 가변 길이 정수입니다. 이 값은 2^62-1보다 큰 스트림 ID를 인코딩할 수 없으므로 2^60을 초과할 수 없습니다. 더 큰 스트림 ID를 인코딩하는 프레임의 수신은 STREAM\_LIMIT\_ERROR 또는 FRAME\_ENCODING\_ERROR 유형의 연결 오류로 처리되어야 합니다.\(MUST\)

---
### **19.15.  NEW_CONNECTION_ID Frames**

끝점은 NEW\_CONNECTION\_ID 프레임\(유형=0x18\)을 전송하여 연결을 마이그레이션할 때 연결성을 끊는 데 사용할 수 있는 대체 연결 ID를 피어에 제공합니다. 섹션 9.5를 참조하십시오.

NEW\_CONNECTION\_ID 프레임은 그림 39와 같이 형식이 지정됩니다.

```text
   NEW_CONNECTION_ID Frame {
     Type (i) = 0x18,
     Sequence Number (i),
     Retire Prior To (i),
     Length (8),
     Connection ID (8..160),
     Stateless Reset Token (128),
   }

                 Figure 39: NEW_CONNECTION_ID Frame Format
```

NEW\_CONNECTION\_ID 프레임에는 다음 필드가 포함됩니다.

시퀀스 번호: 발신자가 연결 ID에 할당한 시퀀스 번호로 가변 길이 정수로 인코딩됩니다. 섹션 5.1.1을 참조하십시오.

Retire Prior To: 다음을 나타내는 가변 길이 정수

- 연결 ID는 폐기해야 합니다. 섹션 5.1.2를 참조하십시오.

길이: 연결 ID의 길이를 포함하는 8비트 부호 없는 정수입니다. 1보다 작고 20보다 큰 값은 유효하지 않으며 FRAME\_ENCODING\_ERROR 유형의 연결 오류로 처리되어야 합니다.\(MUST\)

연결 ID: 지정된 길이의 연결 ID입니다.

상태 비저장 재설정 토큰: 연결된 연결 ID가 사용될 때 상태 비저장 재설정에 사용되는 128비트 값입니다. 섹션 10.3을 참조하십시오.

엔드포인트는 현재 피어가 길이가 0인 대상 연결 ID가 있는 패킷을 보내야 하는 경우 이 프레임을 보내면 안 됩니다\(MUST NOT\). 연결 ID 길이를 0으로 또는 0에서 변경하면 연결 ID 값이 언제 변경되었는지 식별하기 어렵습니다. 길이가 0인 대상 연결 ID가 있는 패킷을 보내는 끝점은 NEW\_CONNECTION\_ID 프레임 수신을 PROTOCOL\_VIOLATION 유형의 연결 오류로 처리해야 합니다.\(MUST NOT, MUST\)

전송 오류, 시간 초과 및 재전송으로 인해 동일한 NEW\_CONNECTION\_ID 프레임이 여러 번 수신될 수 있습니다. 동일한 프레임을 여러 번 수신해도 연결 오류로 취급해서는 안 됩니다\(MUST NOT\). 수신기는 NEW\_CONNECTION\_ID 프레임에 제공된 시퀀스 번호를 사용하여 동일한 NEW\_CONNECTION\_ID 프레임을 여러 번 수신하는 것을 처리할 수 있습니다.\(MUST NOT\)

엔드포인트가 다른 Stateless Reset Token 필드 값 또는 다른 Sequence Number 필드 값으로 이전에 발행된 연결 ID를 반복하는 NEW\_CONNECTION\_ID 프레임을 수신하거나 다른 연결 ID에 시퀀스 번호가 사용되는 경우 엔드포인트는 해당 수신을 PROTOCOL\_VIOLATION 유형의 연결 오류입니다.\(MAY\)

Retire Prior To 필드는 연결 설정 중에 설정된 연결 ID 및 preferred\_address 전송 매개변수에 적용됩니다. 섹션 5.1.2를 참조하십시오. Retire Prior To 필드의 값은 Sequence Number 필드의 값보다 작거나 같아야 합니다. Sequence Number 필드의 값보다 큰 Retire Prior To 필드의 값을 받는 것은 FRAME\_ENCODING\_ERROR 유형의 연결 오류로 처리되어야 합니다.\(MUST, MUST\)

발신자가 Retire Prior To 값을 표시하면 후속 NEW\_CONNECTION\_ID 프레임에서 전송된 더 작은 값은 영향을 미치지 않습니다. 수신자는 가장 큰 수신 Retire Prior To 값을 증가시키지 않는 모든 Retire Prior To 필드를 무시해야 합니다.\(MUST\)

이전에 수신된 NEW\_CONNECTION\_ID 프레임의 Retire Prior To 필드보다 작은 시퀀스 번호를 가진 NEW\_CONNECTION\_ID 프레임을 수신하는 엔드포인트는 해당 시퀀스 번호에 대해 이미 그렇게 하지 않은 경우 새로 수신된 연결 ID를 폐기하는 해당 RETIRE\_CONNECTION\_ID 프레임을 보내야 합니다.\(MUST\)

---
### **19.16.  RETIRE_CONNECTION_ID Frames**

엔드포인트는 RETIRE\_CONNECTION\_ID 프레임\(유형=0x19\)을 전송하여 해당 피어에서 발급한 연결 ID를 더 이상 사용하지 않음을 나타냅니다. 여기에는 핸드셰이크 중에 제공된 연결 ID가 포함됩니다. RETIRE\_CONNECTION\_ID 프레임을 보내는 것은 나중에 사용할 수 있도록 추가 연결 ID를 보내도록 피어에 요청하는 역할도 합니다. 섹션 5.1을 참조하십시오. 새로운 연결 ID는 NEW\_CONNECTION\_ID 프레임\(섹션 19.15\)을 사용하여 피어에 전달할 수 있습니다.

연결 ID를 폐기하면 해당 연결 ID와 연결된 상태 비저장 재설정 토큰이 무효화됩니다.

RETIRE\_CONNECTION\_ID 프레임은 그림 40과 같이 형식이 지정됩니다.

```text
   RETIRE_CONNECTION_ID Frame {
     Type (i) = 0x19,
     Sequence Number (i),
   }

                Figure 40: RETIRE_CONNECTION_ID Frame Format
```

RETIRE\_CONNECTION\_ID 프레임에는 다음 필드가 포함됩니다.

시퀀스 번호: 폐기되는 연결 ID의 시퀀스 번호입니다. 섹션 5.1.2를 참조하십시오.

이전에 피어에게 전송된 것보다 큰 시퀀스 번호를 포함하는 RETIRE\_CONNECTION\_ID 프레임의 수신은 PROTOCOL\_VIOLATION 유형의 연결 오류로 처리되어야 합니다.\(MUST\)

RETIRE\_CONNECTION\_ID 프레임에 지정된 시퀀스 번호는 프레임이 포함된 패킷의 대상 연결 ID 필드를 참조해서는 안 됩니다. 피어는 이것을 PROTOCOL\_VIOLATION 유형의 연결 오류로 취급할 수 있습니다\(MAY\).\(MUST NOT, MAY\)

엔드포인트는 피어에서 길이가 0인 연결 ID를 제공한 경우 이 프레임을 보낼 수 없습니다. 길이가 0인 연결 ID를 제공하는 엔드포인트는 RETIRE\_CONNECTION\_ID 프레임 수신을 PROTOCOL\_VIOLATION 유형의 연결 오류로 처리해야 합니다.\(MUST\)

---
### **19.17.  PATH_CHALLENGE Frames**

끝점은 PATH\_CHALLENGE 프레임\(유형=0x1a\)을 사용하여 피어에 대한 도달 가능성을 확인하고 연결 마이그레이션 중에 경로 유효성을 검사할 수 있습니다.

PATH\_CHALLENGE 프레임은 그림 41과 같이 형식이 지정됩니다.

```text
   PATH_CHALLENGE Frame {
     Type (i) = 0x1a,
     Data (64),
   }

                   Figure 41: PATH_CHALLENGE Frame Format
```

PATH\_CHALLENGE 프레임에는 다음 필드가 포함됩니다.

데이터: 이 8바이트 필드에는 임의의 데이터가 포함됩니다.

PATH\_CHALLENGE 프레임에 64비트의 엔트로피를 포함하면 값을 올바르게 추측하는 것보다 패킷을 받는 것이 더 쉽습니다.

이 프레임의 수신자는 동일한 데이터 값을 포함하는 PATH\_RESPONSE 프레임\(19.18절\)을 생성해야 합니다.\(MUST\)

---
### **19.18.  PATH_RESPONSE Frames**

PATH\_CHALLENGE 프레임에 대한 응답으로 PATH\_RESPONSE 프레임\(유형=0x1b\)이 전송됩니다.

PATH\_RESPONSE 프레임은 그림 42와 같이 형식이 지정됩니다. PATH\_RESPONSE 프레임의 형식은 PATH\_CHALLENGE 프레임의 형식과 동일합니다. 섹션 19.17을 참조하십시오.

```text
   PATH_RESPONSE Frame {
     Type (i) = 0x1b,
     Data (64),
   }

                   Figure 42: PATH_RESPONSE Frame Format
```

PATH\_RESPONSE 프레임의 내용이 엔드포인트가 이전에 보낸 PATH\_CHALLENGE 프레임의 내용과 일치하지 않으면 엔드포인트는 PROTOCOL\_VIOLATION 유형의 연결 오류를 생성할 수 있습니다.\(MAY\)

---
### **19.19.  CONNECTION_CLOSE Frames**

엔드포인트는 CONNECTION\_CLOSE 프레임\(유형=0x1c 또는 0x1d\)을 전송하여 연결이 닫히고 있음을 피어에게 알립니다. 0x1c 유형의 CONNECTION\_CLOSE 프레임은 QUIC 계층에서만 오류를 알리거나 오류가 없음\(NO\_ERROR 코드 사용\)을 알리는 데 사용됩니다. 0x1d 유형의 CONNECTION\_CLOSE 프레임은 QUIC를 사용하는 응용 프로그램의 오류를 알리는 데 사용됩니다.

명시적으로 닫히지 않은 열린 스트림이 있는 경우 연결이 닫힐 때 암시적으로 닫힙니다.

CONNECTION\_CLOSE 프레임은 그림 43과 같이 형식이 지정됩니다.

```text
   CONNECTION_CLOSE Frame {
     Type (i) = 0x1c..0x1d,
     Error Code (i),
     [Frame Type (i)],
     Reason Phrase Length (i),
     Reason Phrase (..),
   }

                  Figure 43: CONNECTION_CLOSE Frame Format
```

CONNECTION\_CLOSE 프레임에는 다음 필드가 포함됩니다.

오류 코드: 이 연결을 닫는 이유를 나타내는 가변 길이 정수입니다. 0x1c 유형의 CONNECTION\_CLOSE 프레임은 섹션 20.1에 정의된 공간의 코드를 사용합니다. 0x1d 유형의 CONNECTION\_CLOSE 프레임은 애플리케이션 프로토콜에 의해 정의된 코드를 사용합니다. 섹션 20.2를 참조하십시오.

프레임 유형: 오류를 트리거한 프레임 유형을 인코딩하는 가변 길이 정수입니다. 프레임 유형을 알 수 없는 경우 값 0\(PADDING 프레임 언급과 동일\)이 사용됩니다. CONNECTION\_CLOSE\(유형 0x1d\)의 애플리케이션별 변형에는 이 필드가 포함되지 않습니다.

이유 문구 길이: 이유 문구의 길이를 바이트 단위로 지정하는 가변 길이 정수입니다. CONNECTION\_CLOSE 프레임은 패킷 간에 분할될 수 없기 때문에 패킷 크기에 대한 제한은 이유 문구에 사용할 수 있는 공간도 제한합니다.

이유 구문: 폐쇄에 대한 추가 진단 정보입니다. 보낸 사람이 오류 코드 값 이상의 세부 정보를 제공하지 않도록 선택한 경우 길이가 0이 될 수 있습니다. 이것은 UTF-8로 인코딩된 문자열\[RFC3629\]이어야 합니다\(SHOULD\). 그러나 프레임은 텍스트를 생성한 엔티티 이외의 엔티티가 이해하는 데 도움이 되는 언어 태그와 같은 정보를 전달하지 않습니다.\(SHOULD\)

CONNECTION\_CLOSE\(유형 0x1d\)의 애플리케이션별 변형은 0-RTT 또는 1-RTT 패킷을 사용해서만 보낼 수 있습니다. 섹션 12.5를 참조하십시오. 응용 프로그램이 핸드셰이크 중에 연결을 포기하려는 경우 엔드포인트는 초기 또는 핸드셰이크 패킷에서 APPLICATION\_ERROR 오류 코드와 함께 CONNECTION\_CLOSE 프레임\(유형 0x1c\)을 보낼 수 있습니다.

---
### **19.20.  HANDSHAKE_DONE Frames**

서버는 HANDSHAKE\_DONE 프레임\(유형=0x1e\)을 사용하여 클라이언트에게 핸드셰이크 확인 신호를 보냅니다.

HANDSHAKE\_DONE 프레임은 HANDSHAKE\_DONE 프레임에 내용이 없음을 보여주는 그림 44와 같이 형식이 지정됩니다.

```text
   HANDSHAKE_DONE Frame {
     Type (i) = 0x1e,
   }

                   Figure 44: HANDSHAKE_DONE Frame Format
```

HANDSHAKE\_DONE 프레임은 서버에서만 보낼 수 있습니다. 서버는 핸드셰이크를 완료하기 전에 HANDSHAKE\_DONE 프레임을 보내서는 안 됩니다\(MUST NOT\). 서버는 HANDSHAKE\_DONE 프레임 수신을 PROTOCOL\_VIOLATION 유형의 연결 오류로 처리해야 합니다.\(MUST NOT, MUST\)

---
### **19.21.  Extension Frames**

QUIC 프레임은 자체 설명 인코딩을 사용하지 않습니다. 따라서 엔드포인트는 패킷을 성공적으로 처리하기 전에 모든 프레임의 구문을 이해해야 합니다. 이렇게 하면 프레임을 효율적으로 인코딩할 수 있지만 끝점이 피어에 알려지지 않은 유형의 프레임을 보낼 수 없음을 의미합니다.

새로운 유형의 프레임을 사용하려는 QUIC의 확장은 피어가 프레임을 이해할 수 있는지 먼저 확인해야 합니다. 엔드포인트는 전송 매개변수를 사용하여 확장 프레임 유형을 수신하려는 의지를 알릴 수 있습니다. 하나의 전송 매개변수는 하나 이상의 확장 프레임 유형에 대한 지원을 나타낼 수 있습니다.\(MUST\)

핵심 프로토콜 기능\(프레임 유형 포함\)을 수정하거나 대체하는 확장은 조합 동작이 명시적으로 정의되지 않는 한 동일한 기능을 수정하거나 대체하는 다른 확장과 결합하기 어려울 것입니다. 이러한 확장은 동일한 프로토콜 구성 요소를 수정하는 이전에 정의된 확장과의 상호 작용을 정의해야 합니다\(SHOULD\).\(SHOULD\)

확장 프레임은 반드시 혼잡 제어되어야 하며 ACK 프레임이 전송되도록 해야 합니다. ACK 프레임을 대체하거나 보완하는 확장 프레임은 예외입니다. 확장 프레임은 확장에서 지정하지 않는 한 흐름 제어에 포함되지 않습니다.\(MUST\)

IANA 레지스트리는 프레임 유형 할당을 관리하는 데 사용됩니다. 섹션 22.4를 참조하십시오.

---
## **20.  Error Codes**

QUIC 전송 오류 코드 및 애플리케이션 오류 코드는 62비트 부호 없는 정수입니다.

---
### **20.1.  Transport Error Codes**

이 섹션은 0x1c 유형의 CONNECTION\_CLOSE 프레임에서 사용할 수 있는 정의된 QUIC 전송 오류 코드를 나열합니다. 이러한 오류는 전체 연결에 적용됩니다.

NO\_ERROR\(0x00\): 엔드포인트는 CONNECTION\_CLOSE와 함께 이것을 사용하여 오류가 없을 때 연결이 갑자기 닫히는 중이라는 신호를 보냅니다.

INTERNAL\_ERROR\(0x01\): 엔드포인트에 내부 오류가 발생하여 연결을 계속할 수 없습니다.

CONNECTION\_REFUSED\(0x02\): 서버가 새 연결 수락을 거부했습니다.

FLOW\_CONTROL\_ERROR\(0x03\): 엔드포인트가 알려진 데이터 제한에서 허용된 것보다 더 많은 데이터를 수신했습니다. 섹션 4를 참조하십시오.

STREAM\_LIMIT\_ERROR\(0x04\): 끝점이 해당 스트림 유형에 대해 알려진 스트림 제한을 초과한 스트림 식별자에 대한 프레임을 수신했습니다.

STREAM\_STATE\_ERROR\(0x05\): 끝점이 해당 프레임을 허용하는 상태가 아닌 스트림에 대한 프레임을 수신했습니다. 섹션 3을 참조하십시오.

FINAL\_SIZE\_ERROR\(0x06\): \(1\) 엔드포인트가 이전에 설정된 최종 크기를 초과하는 데이터를 포함하는 STREAM 프레임을 수신함, \(2\) 엔드포인트가 스트림 데이터의 크기보다 작은 최종 크기를 포함하는 STREAM 프레임 또는 RESET\_STREAM 프레임을 수신함 또는 \(3\) 엔드포인트가 이미 설정된 것과 다른 최종 크기를 포함하는 STREAM 프레임 또는 RESET\_STREAM 프레임을 수신했습니다.

FRAME\_ENCODING\_ERROR\(0x07\): 끝점이 잘못된 형식의 프레임을 수신했습니다. 예를 들어 알 수 없는 유형의 프레임 또는 나머지 패킷이 전달할 수 있는 것보다 더 많은 승인 범위가 있는 ACK 프레임입니다.

TRANSPORT\_PARAMETER\_ERROR\(0x08\): 엔드포인트가 형식이 잘못되었거나 유효하지 않은 값을 포함하거나 필수 전송 매개변수를 생략하거나 금지된 전송 매개변수를 포함하거나 오류가 있는 전송 매개변수를 수신했습니다.

CONNECTION\_ID\_LIMIT\_ERROR\(0x09\): 피어에서 제공한 연결 ID 수가 광고된 active\_connection\_id\_limit를 초과합니다.

PROTOCOL\_VIOLATION\(0x0a\): 엔드포인트에서 보다 구체적인 오류 코드로 다루지 않는 프로토콜 준수 오류를 감지했습니다.

INVALID\_TOKEN\(0x0b\): 서버가 유효하지 않은 토큰 필드가 포함된 클라이언트 이니셜을 수신했습니다.

APPLICATION\_ERROR\(0x0c\): 응용 프로그램 또는 응용 프로그램 프로토콜로 인해 연결이 끊어졌습니다.

CRYPTO\_BUFFER\_EXCEEDED\(0x0d\): 엔드포인트가 버퍼링할 수 있는 것보다 더 많은 CRYPTO 프레임의 데이터를 수신했습니다.

KEY\_UPDATE\_ERROR\(0x0e\): 엔드포인트가 키 업데이트 수행 중 오류를 감지했습니다. \[QUIC-TLS\]의 섹션 6을 참조하십시오.

AEAD\_LIMIT\_REACHED\(0x0f\): 엔드포인트가

- 주어진 연결에서 사용되는 AEAD 알고리즘에 대한 기밀성 또는 무결성 제한.

NO\_VIABLE\_PATH\(0x10\): 엔드포인트에서 네트워크 경로가 QUIC를 지원할 수 없음을 확인했습니다. 엔드포인트는 경로가 충분히 큰 MTU를 지원하지 않는 경우를 제외하고 이 코드를 전달하는 CONNECTION\_CLOSE 프레임을 수신할 가능성이 없습니다.

CRYPTO\_ERROR\(0x0100-0x01ff\): 암호화 핸드셰이크에 실패했습니다. 사용되는 암호화 핸드셰이크에 특정한 오류 코드를 전달하기 위해 256개의 값 범위가 예약되어 있습니다. 암호화 핸드셰이크에 TLS를 사용할 때 발생하는 오류에 대한 코드는 \[QUIC-TLS\]의 4.8절에 설명되어 있습니다.

새로운 오류 코드 등록에 대한 자세한 내용은 22.5절을 참조하십시오.

이러한 오류 코드를 정의할 때 몇 가지 원칙이 적용됩니다. 수신자의 특정 조치가 필요할 수 있는 오류 조건에는 고유 코드가 지정됩니다. 일반적인 조건을 나타내는 오류에는 특정 코드가 지정됩니다. 이러한 조건이 없으면 오류 코드는 흐름 제어 또는 전송 매개변수 처리와 같은 스택의 일반 기능을 식별하는 데 사용됩니다. 마지막으로, 구현이 더 구체적인 코드를 사용할 수 없거나 사용하지 않으려는 조건에 대해 일반 오류가 제공됩니다.

---
### **20.2.  Application Protocol Error Codes**

애플리케이션 오류 코드의 관리는 애플리케이션 프로토콜에 맡겨져 있습니다. 애플리케이션 프로토콜 오류 코드는 RESET\_STREAM 프레임\(19.4절\), STOP\_SENDING 프레임\(19.5절\) 및 0x1d 유형의 CONNECTION\_CLOSE 프레임\(19.19절\)에 사용됩니다.

---
## **21.  Security Considerations**

QUIC의 목표는 안전한 전송 연결을 제공하는 것입니다. 섹션 21.1은 이러한 속성에 대한 개요를 제공합니다. 후속 섹션에서는 알려진 공격 및 대책에 대한 설명을 포함하여 이러한 속성과 관련된 제약 조건 및 주의 사항에 대해 설명합니다.

---
### **21.1.  Overview of Security Properties**

QUIC의 완전한 보안 분석은 이 문서의 범위를 벗어납니다. 이 섹션에서는 구현자를 지원하고 프로토콜 분석을 안내하는 데 도움이 되도록 원하는 보안 속성에 대한 비공식 설명을 제공합니다.

QUIC은 \[SEC-CONS\]에 설명된 위협 모델을 가정하고 해당 모델에서 발생하는 많은 공격에 대한 보호를 제공합니다.

이를 위해 공격은 수동적 공격과 능동적 공격으로 구분된다. 수동적 공격자는 네트워크에서 패킷을 읽을 수 있는 반면 능동적 공격자는 네트워크에 패킷을 쓸 수 있습니다. 그러나 소극적 공격에는 연결을 구성하는 패킷이 취하는 경로에서 라우팅 변경 또는 기타 수정을 유발할 수 있는 능력을 가진 공격자가 포함될 수 있습니다.

공격자는 추가로 온패스 공격자 또는 오프패스 공격자로 분류됩니다. 온패스 공격자는 패킷이 더 이상 목적지에 도달하지 않도록 관찰하는 모든 패킷을 읽거나 수정하거나 제거할 수 있는 반면, 오프패스 공격자는 패킷을 관찰하지만 원래 패킷이 의도한 목적지에 도달하는 것을 막을 수는 없습니다. 두 유형의 공격자 모두 임의의 패킷을 전송할 수도 있습니다. 이 정의는 경로를 벗어난 공격자가 패킷을 관찰할 수 있다는 점에서 \[SEC-CONS\]의 섹션 3.5의 정의와 다릅니다.

핸드셰이크, 보호된 패킷 및 연결 마이그레이션의 속성은 별도로 고려됩니다.

---
#### **21.1.1.  Handshake**

QUIC 핸드셰이크는 TLS 1.3 핸드셰이크를 통합하고 \[TLS13\]의 부록 E.1에 설명된 암호화 속성을 상속합니다. QUIC의 많은 보안 속성은 이러한 속성을 제공하는 TLS 핸드셰이크에 의존합니다. TLS 핸드셰이크에 대한 모든 공격은 QUIC에 영향을 미칠 수 있습니다.

세션 키의 비밀성 또는 고유성 또는 참여 피어의 인증을 손상시키는 TLS 핸드셰이크에 대한 모든 공격은 해당 키에 의존하는 QUIC에서 제공하는 다른 보안 보장에 영향을 미칩니다. 예를 들어, 마이그레이션\(섹션 9\)은 TLS 핸드셰이크를 사용하는 키 협상과 QUIC 패킷 보호 모두에 대해 기밀 보호의 효율성에 따라 네트워크 경로를 통한 연결 가능성을 방지합니다.

TLS 핸드셰이크의 무결성에 대한 공격으로 인해 공격자가 애플리케이션 프로토콜 또는 QUIC 버전 선택에 영향을 미칠 수 있습니다.

TLS에서 제공하는 속성 외에도 QUIC 핸드셰이크는 핸드셰이크에 대한 DoS 공격에 대한 일부 방어 기능을 제공합니다.

---
##### **21.1.1.1.  Anti-Amplification**

주소 검증\(섹션 8\)은 주어진 주소를 주장하는 엔티티가 해당 주소에서 패킷을 수신할 수 있는지 확인하는 데 사용됩니다. 주소 유효성 검사는 증폭 공격 대상을 공격자가 패킷을 관찰할 수 있는 주소로 제한합니다.

주소 유효성 검사 전에 엔드포인트는 보낼 수 있는 항목이 제한됩니다. 끝점은 해당 주소에서 받은 데이터의 3배를 초과하여 확인되지 않은 주소로 데이터를 보낼 수 없습니다.

- | 참고: 증폭 방지 제한은 | 엔드포인트는 검증되지 않은 패킷으로부터 받은 패킷에 응답합니다. 주소. 증폭 방지 한계는 다음에 적용되지 않습니다. | 새 연결을 설정하거나 초기화할 때 | 연결 마이그레이션.

---
##### **21.1.1.2.  Server-Side DoS**

완전한 핸드셰이크를 위해 서버의 첫 번째 비행을 계산하는 것은 잠재적으로 비용이 많이 들며 서명과 키 교환 계산이 모두 필요합니다. 컴퓨팅 DoS 공격을 방지하기 위해 재시도 패킷은 비용이 많이 드는 계산을 수행하기 전에 서버가 클라이언트의 IP 주소를 확인할 수 있도록 하는 저렴한 토큰 교환 메커니즘을 제공합니다. 성공적인 핸드셰이크 후 서버는 클라이언트에 새 토큰을 발급할 수 있으며, 이 비용을 발생시키지 않고 새 연결을 설정할 수 있습니다.

---
##### **21.1.1.3.  On-Path Handshake Termination**

온패스\(on-path\) 또는 오프패스\(off-path\) 공격자는 초기 패킷을 교체하거나 경합하여 핸드셰이크가 실패하도록 강제할 수 있습니다. 유효한 초기 패킷이 교환되면 후속 핸드셰이크 패킷은 핸드셰이크 키로 보호되며 온패스 공격자는 패킷을 삭제하여 엔드포인트에서 시도를 포기하는 것 외에는 핸드셰이크 실패를 강제할 수 없습니다.

온패스\(on-path\) 공격자는 한쪽에서 패킷의 주소를 교체할 수 있으므로 클라이언트나 서버가 원격 주소를 잘못 볼 수 있습니다. 이러한 공격은 NAT가 수행하는 기능과 구별할 수 없습니다.

---
##### **21.1.1.4.  Parameter Negotiation**

전체 핸드셰이크는 암호화 방식으로 보호되며 초기 패킷은 버전별 키로 암호화되고 핸드셰이크 및 이후 패킷은 TLS 키 교환에서 파생된 키로 암호화됩니다. 또한 매개변수 협상은 TLS 성적표에 포함되므로 일반 TLS 협상과 동일한 무결성 보장을 제공합니다. 공격자는 클라이언트의 전송 매개변수\(버전별 솔트를 알고 있는 한\)를 관찰할 수 있지만 서버의 전송 매개변수를 관찰할 수 없으며 매개변수 협상에 영향을 미칠 수 없습니다.

연결 ID는 암호화되지 않지만 모든 패킷에서 무결성이 보호됩니다.

이 버전의 QUIC에는 버전 협상 메커니즘이 통합되어 있지 않습니다. 호환되지 않는 버전의 구현은 단순히 연결 설정에 실패합니다.

---
#### **21.1.2.  Protected Packets**

패킷 보호\(섹션 12.1\)는 버전 협상 패킷을 제외한 모든 패킷에 인증된 암호화를 적용하지만 초기 및 재시도 패킷은 버전별 키 자료의 사용으로 인해 보호가 제한됩니다. 자세한 내용은 \[QUIC-TLS\]를 참조하십시오. 이 섹션에서는 보호된 패킷에 대한 수동 및 능동 공격을 고려합니다.

온패스 및 오프패스 공격자 모두 향후 패킷 보호에 대한 오프라인 공격을 위해 관찰된 패킷을 저장하는 수동 공격을 수행할 수 있습니다. 이것은 모든 네트워크의 모든 패킷 관찰자에게 해당됩니다.

연결에 대한 유효한 패킷을 관찰할 수 없는 상태에서 패킷을 주입하는 공격자는 성공할 가능성이 없습니다. 섹션 7 및 21.1.1을 참조하십시오. 마찬가지로, 패킷을 관찰하고 해당 패킷에 새 데이터를 삽입하거나 기존 데이터를 수정하려고 시도하는 활성 공격자는 수신 엔드포인트에서 유효한 것으로 간주하는 초기 패킷 이외의 패킷을 생성할 수 없어야 합니다.

스푸핑 공격은 활성 공격자가 전달하거나 주입하는 패킷의 보호되지 않은 부분\(예: 원본 또는 대상 주소\)을 재작성하는 것으로, 공격자가 패킷을 원래 끝점으로 전달할 수 있는 경우에만 효과적입니다. 패킷 보호는 핸드셰이크를 완료한 끝점에서만 패킷 페이로드를 처리할 수 있도록 하며 유효하지 않은 패킷은 해당 끝점에서 무시합니다.

또한 공격자는 패킷과 UDP 데이터그램 사이의 경계를 수정하여 여러 패킷을 단일 데이터그램으로 통합하거나 통합된 패킷을 여러 데이터그램으로 분할할 수 있습니다. 패딩이 필요한 초기 패킷을 포함하는 데이터그램을 제외하고 패킷이 데이터그램에서 배열되는 방식을 수정하면 일부 성능 특성이 변경될 수 있지만 연결에 기능적인 영향을 미치지 않습니다.

---
#### **21.1.3.  Connection Migration**

연결 마이그레이션\(섹션 9\)은 비프로빙 프레임의 전송 및 수신을 위해 한 번에 하나의 경로를 사용하여 여러 경로의 IP 주소와 포트 간에 전환할 수 있는 기능을 엔드포인트에 제공합니다. 경로 유효성 검사\(섹션 8.2\)는 피어가 특정 경로에서 전송된 패킷을 수신할 의향이 있고 수신할 수 있음을 설정합니다. 이렇게 하면 스푸핑된 주소로 전송되는 패킷 수를 제한하여 주소 스푸핑의 영향을 줄이는 데 도움이 됩니다.

이 섹션에서는 다양한 유형의 DoS 공격에서 연결 마이그레이션의 의도된 보안 속성에 대해 설명합니다.

---
##### **21.1.3.1.  On-Path Active Attacks**

관찰한 패킷이 의도한 대상에 더 이상 도달하지 못하게 할 수 있는 공격자는 온패스 공격자로 간주됩니다. 클라이언트와 서버 사이에 공격자가 있는 경우 엔드포인트는 공격자를 통해 패킷을 보내 지정된 경로에서 연결을 설정해야 합니다.

온패스 공격자는 다음을 수행할 수 있습니다.

```text
   *  Inspect packets
```

\* IP 및 UDP 패킷 헤더 수정

```text
   *  Inject new packets

   *  Delay packets

   *  Reorder packets

   *  Drop packets
```

\* 패킷 경계를 따라 데이터그램 분할 및 병합

온패스 공격자는 다음을 수행할 수 없습니다.

\* 패킷의 인증된 부분을 수정하고

- 해당 패킷을 수락하는 수신자

온패스 공격자는 자신이 관찰하는 패킷을 수정할 기회가 있습니다. 그러나 패킷의 인증된 부분을 수정하면 패킷 페이로드가 인증되고 암호화되기 때문에 수신 엔드포인트에서 유효하지 않은 것으로 삭제됩니다.

QUIC은 다음과 같이 온패스 공격자의 기능을 제한하는 것을 목표로 합니다.

1. 온패스 공격자는 경로 사용을 방지할 수 있습니다.

- 공격자를 포함하지 않는 다른 경로를 사용할 수 없는 경우 연결 실패를 유발하는 연결. 이는 모든 패킷을 삭제하거나 해독에 실패하도록 수정하거나 다른 방법을 통해 달성할 수 있습니다.

2. 온패스 공격자는 새 경로에서 경로 유효성 검사가 실패하도록 하여 공격자가 온패스인 새 경로로의 마이그레이션을 방지할 수 있습니다.

3. 온패스 공격자는 공격자가 온패스가 아닌 경로로 클라이언트가 마이그레이션하는 것을 막을 수 없습니다.

4. 온패스 공격자는 패킷을 지연시키거나 삭제하여 연결 처리량을 줄일 수 있습니다.

5. 온패스 공격자는 엔드포인트가 해당 패킷의 인증된 부분을 수정한 패킷을 수락하도록 할 수 없습니다.

---
##### **21.1.3.2.  Off-Path Active Attacks**

경로를 벗어난 공격자는 클라이언트와 서버 사이의 경로에 직접 있지는 않지만 클라이언트와 서버 사이에 전송된 일부 또는 모든 패킷의 복사본을 얻을 수 있습니다. 또한 해당 패킷의 복사본을 양쪽 끝점으로 보낼 수 있습니다.

경로를 벗어난 공격자는 다음을 수행할 수 있습니다.

```text
   *  Inspect packets

   *  Inject new packets

   *  Reorder injected packets
```

경로를 벗어난 공격자는 다음을 수행할 수 없습니다.

\* 끝점에서 보낸 패킷 수정

```text
   *  Delay packets

   *  Drop packets

   *  Reorder original packets
```

경로를 벗어난 공격자는 자신이 관찰한 패킷의 수정된 복사본을 만들고 이러한 복사본을 잠재적으로 스푸핑된 소스 및 대상 주소와 함께 네트워크에 주입할 수 있습니다.

이 논의의 목적을 위해 경로를 벗어난 공격자는 공격자가 관찰한 원래 패킷이 도착하기 전에 대상 엔드포인트에 도달할 네트워크에 패킷의 수정된 복사본을 주입할 수 있는 능력이 있다고 가정합니다. 즉, 공격자는 엔드포인트 사이의 합법적인 패킷과의 경쟁에서 지속적으로 "승리"할 수 있는 능력이 있어 수신자가 원본 패킷을 무시할 가능성이 있습니다.

또한 공격자가 NAT 상태에 영향을 미치는 데 필요한 리소스를 가지고 있다고 가정합니다. 특히 공격자는 엔드포인트가 NAT 바인딩을 잃게 한 다음 자체 트래픽에 사용할 동일한 포트를 얻을 수 있습니다.

QUIC은 다음과 같이 경로를 벗어난 공격자의 기능을 제한하는 것을 목표로 합니다.

1. 경로를 벗어난 공격자는 패킷을 경쟁시키고 "제한된" 경로 공격자가 되려고 시도할 수 있습니다.

2. 경로를 벗어난 공격자는 클라이언트와 서버 사이에 개선된 연결을 제공할 수 있는 한 경로를 벗어난 공격자로 나열된 소스 주소를 사용하여 전달된 패킷에 대해 경로 유효성 검사가 성공하도록 할 수 있습니다.

3. 경로를 벗어난 공격자는 핸드셰이크가 완료되면 연결을 닫을 수 없습니다.

4. 경로를 벗어난 공격자는 새 경로를 관찰할 수 없는 경우 새 경로로의 마이그레이션이 실패하도록 할 수 없습니다.

5. 오프패스 공격자는 오프패스 공격자이기도 한 새로운 경로로 이동하는 동안 제한된 온패스 공격자가 될 수 있습니다.

6. 오프패스 공격자는 클라이언트가 원래 사용했던 동일한 IP 주소와 포트에서 서버로 패킷을 전송하도록 공유 NAT 상태에 영향을 미침으로써 제한된 온패스 공격자가 될 수 있습니다.

---
##### **21.1.3.3.  Limited On-Path Active Attacks**

제한된 온패스 공격자는 서버와 클라이언트 간에 원본 패킷을 복제하고 전달하여 해당 패킷이 원본보다 먼저 도착하도록 하여 원래 패킷이 삭제되도록 하여 향상된 패킷 라우팅을 제공하는 오프패스 공격자입니다. 대상 끝점.

제한된 온패스 공격자는 엔드포인트 사이의 원래 경로에 있지 않기 때문에 엔드포인트에서 보낸 원래 패킷이 여전히 목적지에 도달하고 있다는 점에서 온패스 공격자와 다릅니다. 즉, 복사된 패킷을 원래 경로보다 빠르게 대상으로 라우팅하지 못해도 원래 패킷이 대상에 도달하는 것을 막지 못합니다.

제한된 온패스 공격자는 다음을 수행할 수 있습니다.

```text
   *  Inspect packets

   *  Inject new packets

   *  Modify unencrypted packet headers

   *  Reorder packets
```

제한된 온패스 공격자는 다음을 수행할 수 없습니다.

\* 원래 경로로 보낸 패킷보다 늦게 도착하도록 패킷 지연

```text
   *  Drop packets
```

\* 패킷의 인증되고 암호화된 부분을 수정하고 수신자가 해당 패킷을 수락하도록 합니다.

제한된 경로 공격자는 원래 패킷이 중복 패킷보다 먼저 도착하는 지점까지만 패킷을 지연시킬 수 있습니다. 즉, 원래 경로보다 대기 시간이 더 나쁜 라우팅을 제공할 수 없습니다. 제한된 온패스 공격자가 패킷을 드롭하더라도 원본은 여전히 ​​대상 엔드포인트에 도착합니다.

QUIC은 다음과 같이 제한된 오프 경로 공격자의 기능을 제한하는 것을 목표로 합니다.

1. 제한된 온패스 공격자는 핸드셰이크가 완료되면 연결을 닫을 수 없습니다.

2. 제한된 온패스 공격자는 클라이언트가 먼저 활동을 재개하는 경우 유휴 연결을 닫을 수 없습니다.

3. 제한된 온패스 공격자는 서버가 처음으로 활동을 재개하는 경우 유휴 연결이 끊어진 것으로 간주되도록 할 수 있습니다.

이러한 보장은 같은 이유로 모든 NAT에 대해 제공되는 것과 동일한 보장입니다.

---
### **21.2.  Handshake Denial of Service**

암호화되고 인증된 전송으로서 QUIC는 서비스 거부에 대한 다양한 보호 기능을 제공합니다. 암호화 핸드셰이크가 완료되면 QUIC 엔드포인트는 인증되지 않은 대부분의 패킷을 폐기하여 공격자가 기존 연결을 방해하는 능력을 크게 제한합니다.

연결이 설정되면 QUIC 엔드포인트는 일부 인증되지 않은 ICMP 패킷을 수락할 수 있지만\(섹션 14.2.1 참조\) 이러한 패킷의 사용은 극히 제한됩니다. 엔드포인트가 수락할 수 있는 유일한 다른 유형의 패킷은 사용되기 전까지 비밀로 유지되는 토큰에 의존하는 상태 비저장 재설정\(10.3절\)입니다.

연결을 생성하는 동안 QUIC은 네트워크 경로 외부의 공격에 대한 보호만 제공합니다. 모든 QUIC 패킷에는 수신자가 피어로부터 이전 패킷을 보았다는 증거가 포함되어 있습니다.

핸드셰이크 중에는 주소를 변경할 수 없으므로 엔드포인트는 다른 네트워크 경로에서 수신된 패킷을 버릴 수 있습니다.

소스 및 대상 연결 ID 필드는 핸드셰이크 동안 오프 경로 공격에 대한 기본 보호 수단입니다. 섹션 8.1을 참조하십시오. 이는 피어가 설정한 것과 일치하는 데 필요합니다. 초기 및 상태 비저장 재설정을 제외하고 엔드포인트는 이전에 선택한 엔드포인트 값과 일치하는 대상 연결 ID 필드가 포함된 패킷만 수락합니다. 버전 협상 패킷에 대해 제공되는 유일한 보호 기능입니다.

클라이언트는 초기 패킷의 대상 연결 ID 필드를 예측할 수 없도록 선택하여 추가 용도로 사용합니다. 암호화 핸드셰이크를 전달하는 패킷은 이 연결 ID에서 파생된 키와 QUIC 버전에 특정한 솔트로 보호됩니다. 이를 통해 엔드포인트는 암호화 핸드셰이크가 완료된 후 사용할 때 수신하는 패킷 인증에 동일한 프로세스를 사용할 수 있습니다. 인증할 수 없는 패킷은 폐기됩니다. 이러한 방식으로 패킷을 보호하면 패킷 발신자가 초기 패킷을 보고 이해했다는 강력한 보증이 제공됩니다.

이러한 보호는 연결이 설정되기 전에 QUIC 패킷을 수신할 수 있는 공격자에 대해 효과적이지 않습니다. 이러한 공격자는 잠재적으로 QUIC 엔드포인트에서 수락할 패킷을 보낼 수 있습니다. 이 버전의 QUIC는 이러한 종류의 공격을 감지하려고 시도하지만 엔드포인트가 복구가 아닌 연결 설정에 실패할 것으로 예상합니다. 대부분의 경우 암호화 핸드셰이크 프로토콜\[QUIC-TLS\]은 핸드셰이크 중 변조 감지를 담당합니다.

엔드포인트는 다른 방법을 사용하여 핸드셰이크 간섭을 감지하고 복구를 시도할 수 있습니다. 유효하지 않은 패킷은 다른 방법을 사용하여 식별하고 폐기할 수 있지만 이 문서에서는 특정 방법을 요구하지 않습니다.

---
### **21.3.  Amplification Attack**

공격자는 서버에서 주소 유효성 검사 토큰\(섹션 8\)을 받은 다음 해당 토큰을 획득하는 데 사용한 IP 주소를 해제할 수 있습니다. 나중에 공격자는 이 동일한 주소를 스푸핑하여 서버와의 0-RTT 연결을 시작할 수 있으며 이제 다른 \(피해자\) 끝점을 처리할 수 있습니다. 따라서 공격자는 잠재적으로 서버가 초기 혼잡 창에 해당하는 데이터를 피해자에게 보내도록 할 수 있습니다.

서버는 주소 유효성 검사 토큰의 사용 및 수명을 제한하여 이 공격에 대한 완화 조치를 제공해야 합니다\(SHOULD\). 섹션 8.1.3을 참조하십시오.\(SHOULD\)

---
### **21.4.  Optimistic ACK Attack**

수신하지 않은 패킷을 승인하는 엔드포인트는 혼잡 컨트롤러가 네트워크가 지원하는 것 이상의 속도로 전송을 허용하도록 할 수 있습니다. 엔드포인트는 이 동작을 감지하기 위해 패킷을 보낼 때 패킷 번호를 건너뛸 수 있습니다\(MAY\). 그런 다음 엔드포인트는 PROTOCOL\_VIOLATION 유형의 연결 오류로 즉시 연결을 닫을 수 있습니다. 섹션 10.2를 참조하십시오.\(MAY\)

---
### **21.5.  Request Forgery Attacks**

요청 위조 공격은 엔드포인트가 해당 피어가 엔드포인트에 의해 제어되는 요청으로 피해자에게 요청을 발행하도록 하는 경우에 발생합니다. 요청 위조 공격은 공격자가 사용할 수 없는 피어의 기능에 대한 액세스 권한을 공격자에게 제공하는 것을 목표로 합니다. 네트워킹 프로토콜의 경우 요청 위조 공격은 네트워크에서 피어의 위치로 인해 피해자가 피어에 부여한 암시적 권한을 악용하는 데 자주 사용됩니다.

요청 위조가 효과적이려면 공격자가 피어가 보내는 패킷과 이러한 패킷이 전송되는 위치에 영향을 미칠 수 있어야 합니다. 공격자가 제어된 페이로드로 취약한 서비스를 대상으로 할 수 있는 경우 해당 서비스는 공격자의 피어에 기인하지만 공격자가 결정한 작업을 수행할 수 있습니다.

예를 들어 웹에서 교차 사이트 요청 위조\[CSRF\] 악용으로 인해 클라이언트는 인증 쿠키\[COOKIE\]를 포함하는 요청을 발행하여 한 사이트에서 다른 사이트로 제한하려는 정보 및 작업에 액세스할 수 있습니다.

QUIC이 UDP를 통해 실행되기 때문에 우려되는 주요 공격 방식은 공격자가 해당 피어가 UDP 데이터그램을 보내는 주소를 선택하고 해당 패킷의 보호되지 않은 일부 콘텐츠를 제어할 수 있는 것입니다. QUIC 엔드포인트에서 보낸 많은 데이터가 보호되므로 여기에는 암호문에 대한 제어가 포함됩니다. 공격자가 데이터그램의 콘텐츠를 기반으로 일부 작업을 수행할 호스트에 UDP 데이터그램을 보내도록 피어를 유발할 수 있는 경우 공격이 성공한 것입니다.

이 섹션에서는 요청 위조 공격에 QUIC을 사용할 수 있는 방법에 대해 설명합니다.

이 섹션에서는 QUIC 끝점에서 구현할 수 있는 제한된 대책도 설명합니다. 이러한 완화는 조치를 취하는 요청 위조 공격의 잠재적 대상 없이 QUIC 구현 또는 배포에 의해 일방적으로 사용될 수 있습니다. 그러나 UDP 기반 서비스가 요청을 제대로 승인하지 않는 경우 이러한 대책이 충분하지 않을 수 있습니다.

섹션 21.5.4에 설명된 마이그레이션 공격은 매우 강력하고 적절한 대응책이 없기 때문에 QUIC 서버 구현은 공격자가 임의의 대상으로 임의의 UDP 페이로드를 생성하도록 만들 수 있다고 가정해야 합니다. QUIC 서버는 유입 필터링\[BCP38\]을 배포하지 않고 부적절하게 보안된 UDP 엔드포인트가 있는 네트워크에 배포하면 안 됩니다\(SHOULD NOT\).\(SHOULD NOT\)

일반적으로 클라이언트가 취약한 엔드포인트와 같은 위치에 있지 않도록 보장할 수는 없지만 이 QUIC 버전은 서버 마이그레이션을 허용하지 않으므로 클라이언트에 대한 스푸핑 마이그레이션 공격을 방지합니다. 서버 마이그레이션을 허용하는 향후 확장은 위조 공격에 대한 대책도 정의해야 합니다.\(MUST\)

---
#### **21.5.1.  Control Options for Endpoints**

QUIC은 공격자가 피어가 UDP 데이터그램을 보내는 위치에 영향을 미치거나 제어할 수 있는 몇 가지 기회를 제공합니다.

```text
   *  initial connection establishment (Section 7), where a server is
      able to choose where a client sends datagrams -- for example, by
      populating DNS records;

   *  preferred addresses (Section 9.6), where a server is able to
      choose where a client sends datagrams;
```

\* 스푸핑된 연결 마이그레이션\(섹션 9.3.1\), 여기서 클라이언트는 서버가 후속 데이터그램을 보내는 위치를 선택하기 위해 소스 주소 스푸핑을 사용할 수 있습니다. 그리고

\* 서버가 버전 협상 패킷을 보내도록 하는 스푸핑된 패킷\(21.5.5절\).

모든 경우에 공격자는 피어가 QUIC를 이해하지 못하는 피해자에게 데이터그램을 보내도록 할 수 있습니다. 즉, 이러한 패킷은 주소 유효성 검사 전에 피어에 의해 전송됩니다. 섹션 8을 참조하십시오.

패킷의 암호화된 부분 외에 QUIC은 피어가 보내는 UDP 데이터그램의 내용을 제어하기 위한 몇 가지 옵션을 엔드포인트에 제공합니다. 대상 연결 ID 필드는 피어가 보낸 패킷의 초기에 나타나는 바이트에 대한 직접적인 제어를 제공합니다. 섹션 5.1을 참조하십시오. 초기 패킷의 토큰 필드는 초기 패킷의 다른 바이트에 대한 서버 제어를 제공합니다. 섹션 17.2.2를 참조하십시오.

이 버전의 QUIC에는 패킷의 암호화된 부분에 대한 간접적인 제어를 방지하는 조치가 없습니다. 엔드포인트는 피어가 보내는 프레임, 특히 STREAM 프레임과 같이 애플리케이션 데이터를 전달하는 프레임의 내용을 제어할 수 있다고 가정해야 합니다. 이는 애플리케이션 프로토콜의 세부 사항에 어느 정도 의존하지만 많은 프로토콜 사용 컨텍스트에서 일부 제어가 가능합니다. 공격자는 패킷 보호 키에 액세스할 수 있으므로 피어가 향후 패킷을 암호화하는 방법을 예측할 수 있습니다. 데이터그램 콘텐츠를 성공적으로 제어하려면 공격자가 어느 정도의 신뢰성을 가지고 패킷 번호와 패킷의 프레임 배치를 예측할 수 있어야 합니다.

이 섹션에서는 데이터그램 내용에 대한 제어를 제한하는 것이 가능하지 않다고 가정합니다. 후속 섹션의 완화 조치의 초점은 주소 유효성 검사 전에 전송된 데이터그램이 요청 위조에 사용될 수 있는 방식을 제한하는 것입니다.

---
#### **21.5.2.  Request Forgery with Client Initial Packets**

서버 역할을 하는 공격자는 가용성을 알리는 IP 주소와 포트를 선택할 수 있으므로 클라이언트의 초기 패킷은 이러한 종류의 공격에 사용할 수 있다고 가정합니다. 핸드셰이크에 포함된 주소 유효성 검사는 새 연결의 경우 클라이언트가 QUIC를 이해하지 못하거나 QUIC 연결을 수락하지 않는 대상에 다른 유형의 패킷을 보내지 않도록 합니다.

초기 패킷 보호\(\[QUIC-TLS\]의 섹션 5.2\)는 서버가 클라이언트가 보낸 초기 패킷의 내용을 제어하기 어렵게 만듭니다. 예측할 수 없는 대상 연결 ID를 선택하는 클라이언트는 서버가 클라이언트에서 보내는 초기 패킷의 암호화된 부분을 제어할 수 없도록 합니다.

그러나 토큰 필드는 서버 제어에 개방되어 있으며 서버가 클라이언트를 사용하여 요청 위조 공격을 마운트할 수 있도록 허용합니다. NEW\_TOKEN 프레임\(Section 8.1.3\)과 함께 제공되는 토큰의 사용은 연결 설정 중에 요청 위조에 대한 유일한 옵션을 제공합니다.

그러나 클라이언트는 NEW\_TOKEN 프레임을 사용할 의무가 없습니다. NEW\_TOKEN 프레임 수신 시 서버 주소가 변경된 경우 클라이언트가 빈 Token 필드를 보내면 Token 필드에 의존하는 요청 위조 공격을 피할 수 있습니다.

서버 주소가 변경되면 클라이언트는 NEW\_TOKEN 사용을 피할 수 있습니다. 그러나 Token 필드를 포함하지 않으면 성능에 부정적인 영향을 미칠 수 있습니다. 서버는 NEW\_TOKEN에 의존하여 데이터 전송에 대한 3회 제한을 초과하여 데이터를 전송할 수 있습니다. 섹션 8.1을 참조하십시오. 특히 이것은 클라이언트가 0-RTT를 사용하여 서버에서 데이터를 요청하는 경우에 영향을 미칩니다.

재시도 패킷 전송\(섹션 17.2.5\)은 서버에 토큰 필드를 변경하는 옵션을 제공합니다. 재시도를 보낸 후 서버는 클라이언트에서 오는 후속 초기 패킷의 대상 연결 ID 필드도 제어할 수 있습니다. 이것은 또한 초기 패킷의 암호화된 콘텐츠에 대한 간접적인 제어를 허용할 수 있습니다. 그러나 Retry 패킷 교환은 서버의 주소를 검증하여 이후의 Initial 패킷이 요청 위조에 사용되는 것을 방지합니다.

---
#### **21.5.3.  Request Forgery with Preferred Addresses**

서버는 선호하는 주소를 지정할 수 있으며 클라이언트는 핸드셰이크를 확인한 후 마이그레이션합니다. 섹션 9.6을 참조하십시오. 클라이언트가 원하는 주소로 보내는 패킷의 Destination Connection ID 필드는 요청 위조에 사용될 수 있습니다.

클라이언트는 해당 주소의 유효성을 검사하기 전에 선호하는 주소로 비프로빙 프레임을 보내면 안 됩니다\(MUST NOT\). 섹션 8을 참조하십시오. 이렇게 하면 서버가 데이터그램의 암호화된 부분을 제어해야 하는 옵션이 크게 줄어듭니다.\(MUST NOT\)

이 문서는 기본 주소 사용에 특정하고 엔드포인트에서 구현할 수 있는 추가 대책을 제공하지 않습니다. 섹션 21.5.6에 설명된 일반 조치를 추가 완화로 사용할 수 있습니다.

---
#### **21.5.4.  Request Forgery with Spoofed Migration**

클라이언트는 명백한 연결 마이그레이션의 일부로 스푸핑된 소스 주소를 제공하여 서버가 해당 주소로 데이터그램을 보내도록 할 수 있습니다.

서버가 이후에 이 스푸핑된 주소로 보내는 모든 패킷의 대상 연결 ID 필드는 요청 위조에 사용될 수 있습니다. 클라이언트도 암호문에 영향을 미칠 수 있습니다.

주소 확인 전에 탐색 패킷\(섹션 9.1\)만 주소로 보내는 서버는 공격자에게 데이터그램의 암호화된 부분에 대한 제한된 제어만 제공합니다. 그러나 특히 NAT 리바인딩의 경우 이는 성능에 부정적인 영향을 미칠 수 있습니다. 서버가 응용 프로그램 데이터를 전달하는 프레임을 보내는 경우 공격자는 대부분의 데이터그램 콘텐츠를 제어할 수 있습니다.

이 문서는 섹션 21.5.6에 설명된 일반적인 조치를 제외하고 엔드포인트에서 구현할 수 있는 특정 대책을 제공하지 않습니다. 그러나 네트워크 수준에서 주소 스푸핑에 대한 대응책, 특히 인그레스 필터링\[BCP38\]은 스푸핑을 사용하고 외부 네트워크에서 발생하는 공격에 특히 효과적입니다.

---
#### **21.5.5.  Request Forgery with Version Negotiation**

패킷에 스푸핑된 소스 주소를 제공할 수 있는 클라이언트는 서버가 버전 협상 패킷\(17.2.1절\)을 해당 주소로 보내도록 할 수 있습니다.

알 수 없는 버전의 패킷에 대한 연결 ID 필드에 대한 크기 제한이 없기 때문에 결과 데이터그램에서 클라이언트가 제어하는 ​​데이터의 양이 증가합니다. 이 패킷의 첫 번째 바이트는 클라이언트가 제어할 수 없으며 다음 4바이트는 0이지만 클라이언트는 다섯 번째 바이트부터 최대 512바이트까지 제어할 수 있습니다.

일반적인 보호\(섹션 21.5.6\)가 적용될 수 있지만 이 공격에 대한 특정 대책은 제공되지 않습니다. 이 경우 인그레스 필터링\[BCP38\]도 유효합니다.

---
#### **21.5.6.  Generic Request Forgery Countermeasures**

요청 위조 공격에 대한 가장 효과적인 방어는 강력한 인증을 사용하도록 취약한 서비스를 수정하는 것입니다. 그러나 이것이 항상 QUIC 배포의 제어 범위 내에 있는 것은 아닙니다. 이 섹션에서는 QUIC 엔드포인트가 일방적으로 취할 수 있는 몇 가지 다른 단계에 대해 설명합니다. 이러한 추가 단계는 상황에 따라 적법한 사용을 방해하거나 방해할 수 있으므로 모두 임의적입니다.

루프백 인터페이스를 통해 제공되는 서비스는 종종 적절한 인증이 부족합니다. 엔드포인트는 연결 시도 또는 루프백 주소로의 마이그레이션을 방지할 수 있습니다\(MAY\). 동일한 서비스가 이전에 다른 인터페이스에서 사용 가능했거나 루프백 주소가 아닌 서비스에서 주소를 제공한 경우 엔드포인트는 루프백 주소로의 연결 또는 마이그레이션을 허용해서는 안 됩니다\(SHOULD NOT\). 이러한 기능에 의존하는 엔드포인트는 이러한 보호를 비활성화하는 옵션을 제공할 수 있습니다.\(MAY, SHOULD NOT\)

유사하게 엔드포인트는 링크-로컬 주소\[RFC4291\] 또는 개인용 범위\[RFC1918\]의 주소가 글로벌 고유 로컬\[RFC4193\] 또는 비개인 주소에서 잠재적인 시도로 변경된 것으로 간주할 수 있습니다. 요청시 위조. 엔드포인트는 이러한 주소의 사용을 완전히 거부할 수 있지만 합법적인 사용을 방해할 상당한 위험이 따릅니다. 엔드포인트는 주어진 범위의 검증되지 않은 주소로 데이터그램을 보내는 것이 안전하지 않다는 것을 나타내는 네트워크에 대한 특정 지식이 없는 한 주소 사용을 거부해서는 안 됩니다\(SHOULD NOT\).\(SHOULD NOT\)

끝점은 초기 패킷에 NEW\_TOKEN 프레임의 값을 포함하지 않거나 주소 유효성 검사를 완료하기 전에 프로브 프레임만 패킷에 전송하여 요청 위조의 위험을 줄이기로 선택할 수 있습니다\(MAY\). 이것은 공격자가 공격을 위해 대상 연결 ID 필드를 사용하는 것을 방지하지 않습니다.\(MAY\)

끝점은 요청 위조 공격의 취약한 대상이 될 수 있는 서버 위치에 대한 특정 정보를 가질 것으로 예상되지 않습니다. 그러나 공격에 사용되는 데이터그램의 특정 패턴이나 일반적인 공격 대상인 특정 UDP 포트를 식별하는 것은 시간이 지남에 따라 가능할 수 있습니다. 끝점은 이러한 포트에 데이터그램을 보내는 것을 피하거나 대상 주소를 확인하기 전에 이러한 패턴과 일치하는 데이터그램을 보내지 않도록 선택할 수 있습니다\(MAY\). 엔드포인트는 문제가 있는 것으로 알려진 패턴이 포함된 연결 ID를 사용하지 않고 폐기할 수 있습니다\(MAY\).\(MAY, MAY\)

- | 참고: 이러한 보호를 적용하기 위해 엔드포인트를 수정하는 것은 | 네트워크 기반 보호를 배포하는 것보다 효율적입니다. | 엔드포인트는 추가 처리를 수행할 필요가 없습니다. | 검증된 주소로 발송합니다.

---
### **21.6.  Slowloris Attacks**

일반적으로 Slowloris\[SLOWLORIS\]라고 알려진 공격은 대상 엔드포인트에 대한 많은 연결을 열린 상태로 유지하고 가능한 한 오랫동안 열어 두려고 합니다. 이러한 공격은 비활성으로 인해 닫히는 것을 방지하는 데 필요한 최소한의 활동을 생성하여 QUIC 엔드포인트에 대해 실행할 수 있습니다. 여기에는 소량의 데이터 전송, 발신자 비율을 제어하기 위해 점진적으로 흐름 제어 창 열기 또는 높은 손실률을 시뮬레이트하는 ACK 프레임 제조가 포함될 수 있습니다.

QUIC 배포는 서버가 허용하는 최대 클라이언트 수 증가, 단일 IP 주소가 만들 수 있는 연결 수 제한, 연결이 허용되는 최소 전송 속도에 대한 제한 부과와 같은 Slowloris 공격에 대한 완화를 제공해야 합니다\(SHOULD\). , 엔드포인트가 연결 상태를 유지하도록 허용되는 시간을 제한합니다.\(SHOULD\)

---
### **21.7.  Stream Fragmentation and Reassembly Attacks**

적대적인 발신자는 의도적으로 스트림 데이터의 일부를 보내지 않아 수신자가 보내지 않은 데이터에 대한 리소스를 커밋하도록 할 수 있습니다. 이로 인해 불균형한 수신 버퍼 메모리 커밋 및/또는 수신기에서 크고 비효율적인 데이터 구조가 생성될 수 있습니다.

적대적 수신자는 보낸 사람이 재전송을 위해 확인되지 않은 스트림 데이터를 저장하도록 강제하기 위해 의도적으로 스트림 데이터가 포함된 패킷을 확인하지 않을 수 있습니다.

흐름 제어 창이 사용 가능한 메모리에 해당하는 경우 수신기에 대한 공격이 완화됩니다. 그러나 일부 수신기는 메모리를 오버커밋하고 실제 사용 가능한 메모리를 초과하는 집합의 흐름 제어 오프셋을 알립니다. 초과 커밋 전략은 엔드포인트가 제대로 작동할 때 더 나은 성능으로 이어질 수 있지만 엔드포인트를 스트림 조각화 공격에 취약하게 만듭니다.

QUIC 배포는 스트림 조각화 공격에 대한 완화를 제공해야 합니다\(SHOULD\). 완화 조치는 메모리 오버 커밋 방지, 추적 데이터 구조의 크기 제한, STREAM 프레임 재조립 지연, 재조립 구멍의 수명 및 지속 시간에 기반한 휴리스틱 구현 또는 이들의 일부 조합으로 구성될 수 있습니다.\(SHOULD\)

---
### **21.8.  Stream Commitment Attack**

적대적 끝점은 많은 수의 스트림을 열어 끝점의 상태를 고갈시킬 수 있습니다. 적대적 엔드포인트는 TCP의 SYN 플러딩 공격과 유사한 방식으로 많은 수의 연결에서 프로세스를 반복할 수 있습니다.

일반적으로 클라이언트는 섹션 2.1에서 설명한 대로 스트림을 순차적으로 엽니다. 그러나 여러 스트림이 짧은 간격으로 시작되면 손실 또는 재정렬로 인해 스트림을 여는 STREAM 프레임이 순서 없이 수신될 수 있습니다. 더 높은 번호의 스트림 ID를 수신하면 수신기는 동일한 유형의 모든 중간 스트림을 열어야 합니다. 섹션 3.2를 참조하십시오. 따라서 새 연결에서 스트림 4000000을 열면 100만 개의 클라이언트 시작 양방향 스트림이 열립니다.

활성 스트림의 수는 섹션 4.6에서 설명한 대로 수신된 MAX\_STREAMS 프레임에 의해 업데이트되는 initial\_max\_streams\_bidi 및 initial\_max\_streams\_uni 전송 매개변수에 의해 제한됩니다. 신중하게 선택한 경우 이러한 제한은 스트림 커밋 공격의 영향을 완화합니다. 그러나 제한을 너무 낮게 설정하면 애플리케이션이 많은 수의 스트림을 열 것으로 예상할 때 성능에 영향을 미칠 수 있습니다.

---
### **21.9.  Peer Denial of Service**

QUIC 및 TLS 모두 일부 컨텍스트에서 합법적으로 사용되는 프레임 또는 메시지를 포함하지만 이러한 프레임 또는 메시지를 남용하여 피어가 연결 상태에 눈에 띄는 영향을 미치지 않고 처리 리소스를 소비하도록 할 수 있습니다.

메시지는 흐름 제어 제한에 작은 증분을 보내는 것과 같이 작거나 중요하지 않은 방식으로 상태를 변경하고 되돌리는 데 사용할 수도 있습니다.

처리 비용이 대역폭 소비 또는 상태에 미치는 영향에 비해 불균형적으로 크면 악의적인 피어가 처리 용량을 소진할 수 있습니다.

모든 메시지에 대한 합법적인 사용이 있지만 구현은 진행률과 관련된 처리 비용을 추적하고 과도한 양의 비생산적인 패킷을 공격을 나타내는 것으로 취급해야 합니다. 끝점은 연결 오류 또는 패킷 삭제를 통해 이 조건에 응답할 수 있습니다\(MAY\).\(SHOULD, MAY\)

---
### **21.10.  Explicit Congestion Notification Attacks**

온패스 공격자는 발신자의 속도에 영향을 미치기 위해 IP 헤더의 ECN 필드 값을 조작할 수 있습니다. \[RFC3168\]은 조작과 그 효과에 대해 자세히 설명합니다.

제한된 온패스 공격자는 발신자의 속도에 영향을 미치기 위해 수정된 ECN 필드가 있는 패킷을 복제하고 전송할 수 있습니다. 중복 패킷이 수신자에 의해 폐기되는 경우 공격자는 이 공격에서 성공하기 위해 원본과 중복 패킷을 경쟁해야 합니다. 따라서 QUIC 엔드포인트는 해당 IP 패킷의 QUIC 패킷이 하나 이상 성공적으로 처리되지 않는 한 IP 패킷의 ECN 필드를 무시합니다. 섹션 13.4를 참조하십시오.

---
### **21.11.  Stateless Reset Oracle**

상태 비저장 재설정은 TCP 재설정 삽입과 유사한 서비스 거부 공격을 생성합니다. 이 공격은 공격자가 선택한 연결 ID가 있는 연결에 대해 상태 비저장 재설정 토큰을 생성할 수 있는 경우에 가능합니다. 이 토큰을 생성할 수 있는 공격자는 동일한 연결 ID로 활성 연결을 재설정할 수 있습니다.

정적 키를 공유하는 다른 인스턴스로 패킷을 라우팅할 수 있는 경우\(예: IP 주소 또는 포트 변경\) 공격자는 서버가 상태 비저장 재설정을 보내도록 할 수 있습니다. 이러한 스타일의 서비스 거부를 방어하기 위해 상태 비저장 재설정\(섹션 10.3.2 참조\)을 위한 정적 키를 공유하는 엔드포인트는 지정된 연결 ID를 가진 패킷이 해당 연결이 아닌 한 항상 연결 상태를 가진 인스턴스에 도착하도록 배열되어야 합니다. 더 이상 활성화되지 않습니다.\(MUST\)

보다 일반적으로, 해당 연결 ID와의 연결이 동일한 정적 키를 사용하는 엔드포인트에서 활성화될 수 있는 경우 서버는 상태 비저장 재설정을 생성해서는 안 됩니다\(MUST NOT\).\(MUST NOT\)

동적 로드 밸런싱을 사용하는 클러스터의 경우 활성 인스턴스가 연결 상태를 유지하는 동안 로드 밸런서 구성이 변경될 수 있습니다. 인스턴스가 연결 상태를 유지하더라도 라우팅 변경 및 결과 상태 비저장 재설정으로 인해 연결이 종료됩니다. 패킷이 올바른 인스턴스로 라우팅될 가능성이 없는 경우 연결이 시간 초과될 때까지 기다리는 것보다 상태 비저장 재설정을 보내는 것이 좋습니다. 그러나 이는 라우팅이 공격자의 영향을 받을 수 없는 경우에만 허용됩니다.

---
### **21.12.  Version Downgrade**

이 문서는 두 엔드포인트 간에 사용되는 QUIC 버전을 협상하는 데 사용할 수 있는 QUIC 버전 협상 패킷\(섹션 6\)을 정의합니다. 그러나 이 문서에서는 이 버전과 후속 버전 간에 이 협상이 수행되는 방법을 지정하지 않습니다. 특히 버전 협상 패킷에는 버전 다운그레이드 공격을 방지하는 메커니즘이 포함되어 있지 않습니다. 버전 협상 패킷을 사용하는 QUIC의 향후 버전은 버전 다운그레이드 공격에 대해 강력한 메커니즘을 정의해야 합니다.\(MUST\)

---
### **21.13.  Targeted Attacks by Routing**

배포는 특정 서버 인스턴스에 대한 새로운 연결을 목표로 하는 공격자의 능력을 제한해야 합니다. 이상적으로 라우팅 결정은 주소를 포함하여 클라이언트가 선택한 값과 독립적으로 이루어집니다. 인스턴스가 선택되면 이후 패킷이 동일한 인스턴스로 라우팅되도록 연결 ID를 선택할 수 있습니다.

---
### **21.14.  Traffic Analysis**

QUIC 패킷의 길이는 해당 패킷의 콘텐츠 길이에 대한 정보를 나타낼 수 있습니다. PADDING 프레임은 끝점이 패킷 내용의 길이를 모호하게 할 수 있도록 제공됩니다. 섹션 19.1을 참조하십시오.

트래픽 분석을 이기는 것은 어려운 일이며 활발한 연구 대상입니다. 길이만이 정보가 유출될 수 있는 유일한 방법은 아닙니다. 또한 엔드포인트는 패킷 타이밍과 같은 다른 측면 채널을 통해 중요한 정보를 공개할 수 있습니다.

---
## **22.  IANA Considerations**

이 문서는 QUIC에서 코드 포인트 관리를 위한 여러 레지스트리를 설정합니다. 이러한 레지스트리는 22.1절에 정의된 공통 정책 세트에서 작동합니다.

---
### **22.1.  Registration Policies for QUIC Registries**

모든 QUIC 레지스트리는 코드 포인트의 임시 및 영구 등록을 모두 허용합니다. 이 섹션에서는 이러한 레지스트리에 공통적인 정책을 설명합니다.

---
#### **22.1.1.  Provisional Registrations**

코드 포인트의 잠정 등록은 QUIC에 대한 확장으로 개인 사용 및 실험을 허용하기 위한 것입니다. 임시 등록에는 코드 포인트 값과 연락처 정보만 포함하면 됩니다. 그러나 임시 등록은 회수되어 다른 목적으로 재할당될 수 있습니다.

임시 등록에는 \[RFC8126\]의 섹션 4.5에 정의된 대로 전문가 검토가 필요합니다. 지정된 전문가 또는 전문가들은 잔여 코드포인트 공간의 과도한 비율 또는 맨 처음 할당되지 않은 값\(섹션 22.1.2 참조\)에 대한 등록만 거부될 수 있음을 알립니다.

임시 등록에는 등록이 마지막으로 업데이트된 날짜를 나타내는 날짜 필드가 포함됩니다. 임시 등록 날짜 업데이트 요청은 지정된 전문가의 검토 없이 할 수 있습니다.

모든 QUIC 레지스트리에는 임시 등록을 지원하기 위해 다음 필드가 포함됩니다.

값: 할당된 코드 포인트. 상태: "영구" 또는 "임시". 사양: 값에 대해 공개적으로 사용 가능한 사양에 대한 참조입니다. 날짜: 등록이 마지막으로 업데이트된 날짜입니다. 변경 컨트롤러: 등록 정의를 담당하는 엔터티입니다. 연락처: 등록자의 연락처 정보입니다. 참고: 등록에 대한 추가 참고 사항입니다.

임시 등록은 사양 및 참고 필드와 영구 등록에 필요할 수 있는 추가 필드를 생략할 수 있습니다\(MAY\). 날짜 필드는 등록이 생성되거나 업데이트된 날짜로 설정되므로 등록 요청의 일부로 필요하지 않습니다.\(MAY\)

---
#### **22.1.2.  Selecting Codepoints**

QUIC 레지스트리의 코드 포인트에 대한 새로운 요청은 기존 할당과 선택된 공간에서 할당되지 않은 첫 번째 코드 포인트를 모두 제외하는 무작위로 선택된 코드 포인트를 사용해야 합니다\(SHOULD\). 여러 코드 포인트에 대한 요청은 연속 범위를 사용할 수 있습니다\(MAY\). 이렇게 하면 서로 다른 구현에 의해 서로 다른 의미 체계가 동일한 코드 포인트에 귀속되는 위험이 최소화됩니다.\(SHOULD, MAY\)

할당되지 않은 첫 번째 코드포인트의 사용은 Standards Action 정책을 사용한 할당을 위해 예약되어 있습니다. \[RFC8126\]의 섹션 4.9를 참조하십시오. 이러한 값에 대해 초기 코드포인트 할당 프로세스\[EARLY-ASSIGN\]를 사용할 수 있습니다.

프레임 유형과 같은 가변 길이 정수\(섹션 16\)로 인코딩된 코드 포인트의 경우 4바이트 또는 8바이트\(즉, 값 2^14 이상\)로 인코딩되는 코드 포인트는 사용이 특별히 민감한 경우가 아니면 사용해야 합니다\(SHOULD\). 더 긴 인코딩.\(SHOULD\)

QUIC 레지스트리에 코드포인트를 등록하기 위한 애플리케이션은 요청된 코드포인트를 등록의 일부로 포함할 수 있습니다. IANA는 코드 포인트가 할당되지 않고 등록 정책의 요구 사항이 충족되는 경우 선택한 코드 포인트를 할당해야 합니다.\(MAY, MUST\)

---
#### **22.1.3.  Reclaiming Provisional Codepoints**

레지스트리 또는 레지스트리의 일부\(예: 가변 길이 인코딩을 사용하는 코드 포인트의 경우 64-16383 범위\)의 공간을 회수하기 위해 레지스트리에서 사용되지 않는 임시 등록을 제거하라는 요청이 이루어질 수 있습니다. 이것은 기록된 날짜가 가장 빠른 코드포인트에 대해서만 수행되어야 하며 업데이트된 지 1년 미만인 항목은 회수되어서는 안 됩니다\(SHOULD NOT\).\(SHOULD NOT\)

코드 포인트 제거 요청은 지정된 전문가가 검토해야 합니다. 전문가는 코드 포인트가 여전히 사용 중인지 확인해야 합니다. 전문가는 코드 포인트의 사용이 알려져 있는지 여부를 확인하기 위해 등록을 위해 나열된 연락처와 가능한 한 광범위한 프로토콜 구현자에게 문의하는 것이 좋습니다. 전문가들은 또한 응답에 최소 4주의 시간을 두도록 조언합니다.\(MUST, MUST\)

이 검색에서 코드 포인트의 사용이 식별되거나 등록 업데이트 요청이 이루어진 경우 코드 포인트를 회수해서는 안 됩니다\(MUST NOT\). 대신 등록 날짜가 업데이트됩니다. 배운 관련 정보를 기록하는 등록에 대한 메모가 추가될 수 있습니다.\(MUST NOT\)

코드 포인트의 사용이 확인되지 않고 등록 업데이트 요청이 없으면 코드 포인트가 레지스트리에서 제거될 수 있습니다\(MAY\).\(MAY\)

이 검토 및 협의 프로세스는 임시 등록을 영구 등록으로 변경하는 요청에도 적용됩니다. 단, 목표는 코드 포인트를 사용하지 않는지 여부를 결정하는 것이 아니라 등록이 배포된 사용을 정확하게 나타내는지 결정하는 것입니다.

---
#### **22.1.4.  Permanent Registrations**

달리 명시되지 않는 한 QUIC 레지스트리의 영구 등록은 사양 필수 정책\(\[RFC8126\]의 섹션 4.6\)을 사용합니다. 지정된 전문가는 사양이 존재하고 쉽게 액세스할 수 있는지 확인합니다. 전문가는 학대적이거나 경솔하거나 적극적으로 유해하지 않은 한\(단순히 미학적으로 불쾌하거나 구조적으로 의심스러운 것이 아닌\) 등록 승인에 편향되도록 권장됩니다. 레지스트리 생성은 영구 등록에 대한 추가 제약을 지정할 수 있습니다\(MAY\).\(MAY\)

레지스트리 생성은 등록이 다른 등록 정책에 의해 관리되는 코드 포인트 범위를 식별할 수 있습니다\(MAY\). 예를 들어 "QUIC 프레임 유형" 레지스트리\(섹션 22.4\)에는 0에서 63 범위의 코드 포인트에 대해 더 엄격한 정책이 있습니다.\(MAY\)

영구 등록에 대한 더 엄격한 요구 사항은 영향을 받는 코드 포인트에 대한 임시 등록을 금지하지 않습니다. 예를 들어, 프레임 유형 61에 대한 임시 등록을 요청할 수 있습니다.

Standards Track 간행물에 의한 모든 등록은 영구적이어야 합니다.\(MUST\)

이 문서의 모든 등록에는 영구적인 상태가 할당되며 IETF의 변경 컨트롤러와 QUIC 작업 그룹\(quic@ietf.org\)의 연락처가 나열됩니다.

---
### **22.2.  QUIC Versions Registry**

IANA는 "QUIC" 제목 아래에 "QUIC 버전"에 대한 레지스트리를 추가했습니다.

"QUIC 버전" 레지스트리는 32비트 공간을 관리합니다. 섹션 15를 참조하십시오. 이 레지스트리는 섹션 22.1의 등록 정책을 따릅니다. 이 레지스트리의 영구 등록은 사양 필수 정책\(\[RFC8126\]의 섹션 4.6\)을 사용하여 할당됩니다.

프로토콜에 대한 0x00000001의 코드포인트는 이 문서에서 정의된 프로토콜에 영구적인 상태로 할당됩니다. 0x00000000의 코드포인트는 영구적으로 예약되어 있습니다. 이 코드 포인트에 대한 메모는 이 버전이 버전 협상을 위해 예약되어 있음을 나타냅니다.

0x?a?a?a?a 패턴을 따르는 모든 코드포인트는 예약되어 있고 IANA에서 할당하면 안 되며 할당된 값 목록에 나타나지 않아야 합니다.\(MUST NOT\)

---
### **22.3.  QUIC Transport Parameters Registry**

IANA는 "QUIC" 제목 아래에 "QUIC 전송 매개변수"에 대한 레지스트리를 추가했습니다.

"QUIC 전송 매개변수" 레지스트리는 62비트 공간을 관리합니다. 이 레지스트리는 섹션 22.1의 등록 정책을 따릅니다. 이 레지스트리의 영구 등록은 사양 필수 정책\(\[RFC8126\]의 섹션 4.6\)을 사용하여 할당됩니다. 단, 섹션 4.9 및 \[RFC8126\]의 4.10.

섹션 22.1.1에 나열된 필드 외에도 이 레지스트리의 영구 등록에는 다음 필드가 포함되어야 합니다.\(MUST\)

매개변수 이름: 매개변수에 대한 짧은 니모닉입니다.

이 레지스트리의 초기 내용은 표 6에 나와 있습니다.

```text
      +=======+=====================================+===============+
      | Value | Parameter Name                      | Specification |
      +=======+=====================================+===============+
      | 0x00  | original_destination_connection_id  | Section 18.2  |
      +-------+-------------------------------------+---------------+
      | 0x01  | max_idle_timeout                    | Section 18.2  |
      +-------+-------------------------------------+---------------+
      | 0x02  | stateless_reset_token               | Section 18.2  |
      +-------+-------------------------------------+---------------+
      | 0x03  | max_udp_payload_size                | Section 18.2  |
      +-------+-------------------------------------+---------------+
      | 0x04  | initial_max_data                    | Section 18.2  |
      +-------+-------------------------------------+---------------+
      | 0x05  | initial_max_stream_data_bidi_local  | Section 18.2  |
      +-------+-------------------------------------+---------------+
      | 0x06  | initial_max_stream_data_bidi_remote | Section 18.2  |
      +-------+-------------------------------------+---------------+
      | 0x07  | initial_max_stream_data_uni         | Section 18.2  |
      +-------+-------------------------------------+---------------+
      | 0x08  | initial_max_streams_bidi            | Section 18.2  |
      +-------+-------------------------------------+---------------+
      | 0x09  | initial_max_streams_uni             | Section 18.2  |
      +-------+-------------------------------------+---------------+
      | 0x0a  | ack_delay_exponent                  | Section 18.2  |
      +-------+-------------------------------------+---------------+
      | 0x0b  | max_ack_delay                       | Section 18.2  |
      +-------+-------------------------------------+---------------+
      | 0x0c  | disable_active_migration            | Section 18.2  |
      +-------+-------------------------------------+---------------+
      | 0x0d  | preferred_address                   | Section 18.2  |
      +-------+-------------------------------------+---------------+
      | 0x0e  | active_connection_id_limit          | Section 18.2  |
      +-------+-------------------------------------+---------------+
      | 0x0f  | initial_source_connection_id        | Section 18.2  |
      +-------+-------------------------------------+---------------+
      | 0x10  | retry_source_connection_id          | Section 18.2  |
      +-------+-------------------------------------+---------------+

        Table 6: Initial QUIC Transport Parameters Registry Entries
```

N의 정수 값\(즉, 27, 58, 89, ...\)에 대한 "31 \* N + 27" 형식의 각 값은 예약되어 있습니다. 이러한 값은 IANA에 의해 할당되어서는 안 되며 할당된 값 목록에 나타나서는 안 됩니다\(MUST NOT\).\(MUST NOT\)

---
### **22.4.  QUIC Frame Types Registry**

IANA는 "QUIC" 제목 아래에 "QUIC 프레임 유형"에 대한 레지스트리를 추가했습니다.

"QUIC 프레임 유형" 레지스트리는 62비트 공간을 관리합니다. 이 레지스트리는 섹션 22.1의 등록 정책을 따릅니다. 이 레지스트리의 영구 등록은 사양 필수 정책\(\[RFC8126\]의 섹션 4.6\)을 사용하여 할당됩니다. 단, 섹션 4.9 및 \[RFC8126\]의 4.10.

섹션 22.1.1에 나열된 필드 외에도 이 레지스트리의 영구 등록에는 다음 필드가 포함되어야 합니다.\(MUST\)

프레임 유형 이름: 프레임 유형에 대한 짧은 니모닉입니다.

섹션 22.1의 조언 외에도 새로운 영구 등록에 대한 사양은 종점이 식별된 유형의 프레임을 보낼 수 있다고 결정할 수 있는 수단을 설명해야 합니다\(SHOULD\). 대부분의 등록에는 수반되는 전송 매개변수 등록이 예상됩니다. 섹션 22.3을 참조하십시오. 영구 등록에 대한 사양은 또한 프레임의 모든 필드에 대한 형식 및 할당된 의미를 설명해야 합니다.\(SHOULD\)

이 레지스트리의 초기 내용은 표 3에 나와 있습니다. 레지스트리에는 표 3의 "Pkts" 및 "Spec" 열이 포함되어 있지 않습니다.

---
### **22.5.  QUIC Transport Error Codes Registry**

IANA는 "QUIC" 제목 아래에 "QUIC 전송 오류 코드"에 대한 레지스트리를 추가했습니다.

"QUIC Transport Error Codes" 레지스트리는 62비트 공간을 관리합니다. 이 공간은 서로 다른 정책에 의해 관리되는 세 가지 범위로 나뉩니다. 이 레지스트리의 영구 등록은 사양 필수 정책\(\[RFC8126\]의 섹션 4.6\)을 사용하여 할당됩니다. 단, 섹션 4.9 및 \[RFC8126\]의 4.10.

섹션 22.1.1에 나열된 필드 외에도 이 레지스트리의 영구 등록에는 다음 필드가 포함되어야 합니다.\(MUST\)

코드: 매개변수에 대한 짧은 니모닉입니다.

설명: 사양 참조가 제공되는 경우 요약일 수 있는 오류 코드 의미 체계에 대한 간략한 설명입니다.\(MAY\)

이 레지스트리의 초기 내용은 표 7에 나와 있습니다.

```text
   +=======+===========================+================+==============+
   |Value  | Code                      |Description     |Specification |
   +=======+===========================+================+==============+
   |0x00   | NO_ERROR                  |No error        |Section 20    |
   +-------+---------------------------+----------------+--------------+
   |0x01   | INTERNAL_ERROR            |Implementation  |Section 20    |
   |       |                           |error           |              |
   +-------+---------------------------+----------------+--------------+
   |0x02   | CONNECTION_REFUSED        |Server refuses a|Section 20    |
   |       |                           |connection      |              |
   +-------+---------------------------+----------------+--------------+
   |0x03   | FLOW_CONTROL_ERROR        |Flow control    |Section 20    |
   |       |                           |error           |              |
   +-------+---------------------------+----------------+--------------+
   |0x04   | STREAM_LIMIT_ERROR        |Too many streams|Section 20    |
   |       |                           |opened          |              |
   +-------+---------------------------+----------------+--------------+
   |0x05   | STREAM_STATE_ERROR        |Frame received  |Section 20    |
   |       |                           |in invalid      |              |
   |       |                           |stream state    |              |
   +-------+---------------------------+----------------+--------------+
   |0x06   | FINAL_SIZE_ERROR          |Change to final |Section 20    |
   |       |                           |size            |              |
   +-------+---------------------------+----------------+--------------+
   |0x07   | FRAME_ENCODING_ERROR      |Frame encoding  |Section 20    |
   |       |                           |error           |              |
   +-------+---------------------------+----------------+--------------+
   |0x08   | TRANSPORT_PARAMETER_ERROR |Error in        |Section 20    |
   |       |                           |transport       |              |
   |       |                           |parameters      |              |
   +-------+---------------------------+----------------+--------------+
   |0x09   | CONNECTION_ID_LIMIT_ERROR |Too many        |Section 20    |
   |       |                           |connection IDs  |              |
   |       |                           |received        |              |
   +-------+---------------------------+----------------+--------------+
   |0x0a   | PROTOCOL_VIOLATION        |Generic protocol|Section 20    |
   |       |                           |violation       |              |
   +-------+---------------------------+----------------+--------------+
   |0x0b   | INVALID_TOKEN             |Invalid Token   |Section 20    |
   |       |                           |received        |              |
   +-------+---------------------------+----------------+--------------+
   |0x0c   | APPLICATION_ERROR         |Application     |Section 20    |
   |       |                           |error           |              |
   +-------+---------------------------+----------------+--------------+
   |0x0d   | CRYPTO_BUFFER_EXCEEDED    |CRYPTO data     |Section 20    |
   |       |                           |buffer          |              |
   |       |                           |overflowed      |              |
   +-------+---------------------------+----------------+--------------+
   |0x0e   | KEY_UPDATE_ERROR          |Invalid packet  |Section 20    |
   |       |                           |protection      |              |
   |       |                           |update          |              |
   +-------+---------------------------+----------------+--------------+
   |0x0f   | AEAD_LIMIT_REACHED        |Excessive use of|Section 20    |
   |       |                           |packet          |              |
   |       |                           |protection keys |              |
   +-------+---------------------------+----------------+--------------+
   |0x10   | NO_VIABLE_PATH            |No viable       |Section 20    |
   |       |                           |network path    |              |
   |       |                           |exists          |              |
   +-------+---------------------------+----------------+--------------+
   |0x0100-| CRYPTO_ERROR              |TLS alert code  |Section 20    |
   |0x01ff |                           |                |              |
   +-------+---------------------------+----------------+--------------+

        Table 7: Initial QUIC Transport Error Codes Registry Entries
```

---
## **23.  References**
---
### **23.1.  Normative References**

\[BCP38\] Ferguson, P. 및 D. Senie, "네트워크 수신 필터링: IP 소스 주소 스푸핑을 사용하는 서비스 거부 공격 차단", BCP 38, RFC 2827, 2000년 5월.

```text
              <https://www.rfc-editor.org/info/bcp38>

   [DPLPMTUD] Fairhurst, G., Jones, T., Tüxen, M., Rüngeler, I., and T.
              Völker, "Packetization Layer Path MTU Discovery for
              Datagram Transports", RFC 8899, DOI 10.17487/RFC8899,
              September 2020, <https://www.rfc-editor.org/info/rfc8899>.

   [EARLY-ASSIGN]
              Cotton, M., "Early IANA Allocation of Standards Track Code
              Points", BCP 100, RFC 7120, DOI 10.17487/RFC7120, January
              2014, <https://www.rfc-editor.org/info/rfc7120>.

   [IPv4]     Postel, J., "Internet Protocol", STD 5, RFC 791,
              DOI 10.17487/RFC0791, September 1981,
              <https://www.rfc-editor.org/info/rfc791>.

   [QUIC-INVARIANTS]
              Thomson, M., "Version-Independent Properties of QUIC",
              RFC 8999, DOI 10.17487/RFC8999, May 2021,
              <https://www.rfc-editor.org/info/rfc8999>.

   [QUIC-RECOVERY]
              Iyengar, J., Ed. and I. Swett, Ed., "QUIC Loss Detection
              and Congestion Control", RFC 9002, DOI 10.17487/RFC9002,
              May 2021, <https://www.rfc-editor.org/info/rfc9002>.

   [QUIC-TLS] Thomson, M., Ed. and S. Turner, Ed., "Using TLS to Secure
              QUIC", RFC 9001, DOI 10.17487/RFC9001, May 2021,
              <https://www.rfc-editor.org/info/rfc9001>.

   [RFC1191]  Mogul, J. and S. Deering, "Path MTU discovery", RFC 1191,
              DOI 10.17487/RFC1191, November 1990,
              <https://www.rfc-editor.org/info/rfc1191>.

   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", BCP 14, RFC 2119,
              DOI 10.17487/RFC2119, March 1997,
              <https://www.rfc-editor.org/info/rfc2119>.

   [RFC3168]  Ramakrishnan, K., Floyd, S., and D. Black, "The Addition
              of Explicit Congestion Notification (ECN) to IP",
              RFC 3168, DOI 10.17487/RFC3168, September 2001,
              <https://www.rfc-editor.org/info/rfc3168>.

   [RFC3629]  Yergeau, F., "UTF-8, a transformation format of ISO
              10646", STD 63, RFC 3629, DOI 10.17487/RFC3629, November
              2003, <https://www.rfc-editor.org/info/rfc3629>.

   [RFC6437]  Amante, S., Carpenter, B., Jiang, S., and J. Rajahalme,
              "IPv6 Flow Label Specification", RFC 6437,
              DOI 10.17487/RFC6437, November 2011,
              <https://www.rfc-editor.org/info/rfc6437>.

   [RFC8085]  Eggert, L., Fairhurst, G., and G. Shepherd, "UDP Usage
              Guidelines", BCP 145, RFC 8085, DOI 10.17487/RFC8085,
              March 2017, <https://www.rfc-editor.org/info/rfc8085>.

   [RFC8126]  Cotton, M., Leiba, B., and T. Narten, "Guidelines for
              Writing an IANA Considerations Section in RFCs", BCP 26,
              RFC 8126, DOI 10.17487/RFC8126, June 2017,
              <https://www.rfc-editor.org/info/rfc8126>.

   [RFC8174]  Leiba, B., "Ambiguity of Uppercase vs Lowercase in RFC
              2119 Key Words", BCP 14, RFC 8174, DOI 10.17487/RFC8174,
              May 2017, <https://www.rfc-editor.org/info/rfc8174>.

   [RFC8201]  McCann, J., Deering, S., Mogul, J., and R. Hinden, Ed.,
              "Path MTU Discovery for IP version 6", STD 87, RFC 8201,
              DOI 10.17487/RFC8201, July 2017,
              <https://www.rfc-editor.org/info/rfc8201>.

   [RFC8311]  Black, D., "Relaxing Restrictions on Explicit Congestion
              Notification (ECN) Experimentation", RFC 8311,
              DOI 10.17487/RFC8311, January 2018,
              <https://www.rfc-editor.org/info/rfc8311>.

   [TLS13]    Rescorla, E., "The Transport Layer Security (TLS) Protocol
              Version 1.3", RFC 8446, DOI 10.17487/RFC8446, August 2018,
              <https://www.rfc-editor.org/info/rfc8446>.

   [UDP]      Postel, J., "User Datagram Protocol", STD 6, RFC 768,
              DOI 10.17487/RFC0768, August 1980,
              <https://www.rfc-editor.org/info/rfc768>.
```

---
### **23.2.  Informative References**

```text
   [AEAD]     McGrew, D., "An Interface and Algorithms for Authenticated
              Encryption", RFC 5116, DOI 10.17487/RFC5116, January 2008,
              <https://www.rfc-editor.org/info/rfc5116>.

   [ALPN]     Friedl, S., Popov, A., Langley, A., and E. Stephan,
              "Transport Layer Security (TLS) Application-Layer Protocol
              Negotiation Extension", RFC 7301, DOI 10.17487/RFC7301,
              July 2014, <https://www.rfc-editor.org/info/rfc7301>.

   [ALTSVC]   Nottingham, M., McManus, P., and J. Reschke, "HTTP
              Alternative Services", RFC 7838, DOI 10.17487/RFC7838,
              April 2016, <https://www.rfc-editor.org/info/rfc7838>.

   [COOKIE]   Barth, A., "HTTP State Management Mechanism", RFC 6265,
              DOI 10.17487/RFC6265, April 2011,
              <https://www.rfc-editor.org/info/rfc6265>.

   [CSRF]     Barth, A., Jackson, C., and J. Mitchell, "Robust defenses
              for cross-site request forgery", Proceedings of the 15th
              ACM conference on Computer and communications security -
              CCS '08, DOI 10.1145/1455770.1455782, 2008,
              <https://doi.org/10.1145/1455770.1455782>.

   [EARLY-DESIGN]
              Roskind, J., "QUIC: Multiplexed Stream Transport Over
              UDP", 2 December 2013, <https://docs.google.com/document/
              d/1RNHkx_VvKWyWg6Lr8SZ-saqsQx7rFV-ev2jRFUoVD34/
              edit?usp=sharing>.

   [GATEWAY]  Hätönen, S., Nyrhinen, A., Eggert, L., Strowes, S.,
              Sarolahti, P., and M. Kojo, "An experimental study of home
              gateway characteristics", Proceedings of the 10th ACM
              SIGCOMM conference on Internet measurement - IMC '10,
              DOI 10.1145/1879141.1879174, November 2010,
              <https://doi.org/10.1145/1879141.1879174>.

   [HTTP2]    Belshe, M., Peon, R., and M. Thomson, Ed., "Hypertext
              Transfer Protocol Version 2 (HTTP/2)", RFC 7540,
              DOI 10.17487/RFC7540, May 2015,
              <https://www.rfc-editor.org/info/rfc7540>.

   [IPv6]     Deering, S. and R. Hinden, "Internet Protocol, Version 6
              (IPv6) Specification", STD 86, RFC 8200,
              DOI 10.17487/RFC8200, July 2017,
              <https://www.rfc-editor.org/info/rfc8200>.

   [QUIC-MANAGEABILITY]
              Kuehlewind, M. and B. Trammell, "Manageability of the QUIC
              Transport Protocol", Work in Progress, Internet-Draft,
              draft-ietf-quic-manageability-11, 21 April 2021,
              <https://tools.ietf.org/html/draft-ietf-quic-
              manageability-11>.

   [RANDOM]   Eastlake 3rd, D., Schiller, J., and S. Crocker,
              "Randomness Requirements for Security", BCP 106, RFC 4086,
              DOI 10.17487/RFC4086, June 2005,
              <https://www.rfc-editor.org/info/rfc4086>.

   [RFC1812]  Baker, F., Ed., "Requirements for IP Version 4 Routers",
              RFC 1812, DOI 10.17487/RFC1812, June 1995,
              <https://www.rfc-editor.org/info/rfc1812>.

   [RFC1918]  Rekhter, Y., Moskowitz, B., Karrenberg, D., de Groot, G.
              J., and E. Lear, "Address Allocation for Private
              Internets", BCP 5, RFC 1918, DOI 10.17487/RFC1918,
              February 1996, <https://www.rfc-editor.org/info/rfc1918>.

   [RFC2018]  Mathis, M., Mahdavi, J., Floyd, S., and A. Romanow, "TCP
              Selective Acknowledgment Options", RFC 2018,
              DOI 10.17487/RFC2018, October 1996,
              <https://www.rfc-editor.org/info/rfc2018>.

   [RFC2104]  Krawczyk, H., Bellare, M., and R. Canetti, "HMAC: Keyed-
              Hashing for Message Authentication", RFC 2104,
              DOI 10.17487/RFC2104, February 1997,
              <https://www.rfc-editor.org/info/rfc2104>.

   [RFC3449]  Balakrishnan, H., Padmanabhan, V., Fairhurst, G., and M.
              Sooriyabandara, "TCP Performance Implications of Network
              Path Asymmetry", BCP 69, RFC 3449, DOI 10.17487/RFC3449,
              December 2002, <https://www.rfc-editor.org/info/rfc3449>.

   [RFC4193]  Hinden, R. and B. Haberman, "Unique Local IPv6 Unicast
              Addresses", RFC 4193, DOI 10.17487/RFC4193, October 2005,
              <https://www.rfc-editor.org/info/rfc4193>.

   [RFC4291]  Hinden, R. and S. Deering, "IP Version 6 Addressing
              Architecture", RFC 4291, DOI 10.17487/RFC4291, February
              2006, <https://www.rfc-editor.org/info/rfc4291>.

   [RFC4443]  Conta, A., Deering, S., and M. Gupta, Ed., "Internet
              Control Message Protocol (ICMPv6) for the Internet
              Protocol Version 6 (IPv6) Specification", STD 89,
              RFC 4443, DOI 10.17487/RFC4443, March 2006,
              <https://www.rfc-editor.org/info/rfc4443>.

   [RFC4787]  Audet, F., Ed. and C. Jennings, "Network Address
              Translation (NAT) Behavioral Requirements for Unicast
              UDP", BCP 127, RFC 4787, DOI 10.17487/RFC4787, January
              2007, <https://www.rfc-editor.org/info/rfc4787>.

   [RFC5681]  Allman, M., Paxson, V., and E. Blanton, "TCP Congestion
              Control", RFC 5681, DOI 10.17487/RFC5681, September 2009,
              <https://www.rfc-editor.org/info/rfc5681>.

   [RFC5869]  Krawczyk, H. and P. Eronen, "HMAC-based Extract-and-Expand
              Key Derivation Function (HKDF)", RFC 5869,
              DOI 10.17487/RFC5869, May 2010,
              <https://www.rfc-editor.org/info/rfc5869>.

   [RFC7983]  Petit-Huguenin, M. and G. Salgueiro, "Multiplexing Scheme
              Updates for Secure Real-time Transport Protocol (SRTP)
              Extension for Datagram Transport Layer Security (DTLS)",
              RFC 7983, DOI 10.17487/RFC7983, September 2016,
              <https://www.rfc-editor.org/info/rfc7983>.

   [RFC8087]  Fairhurst, G. and M. Welzl, "The Benefits of Using
              Explicit Congestion Notification (ECN)", RFC 8087,
              DOI 10.17487/RFC8087, March 2017,
              <https://www.rfc-editor.org/info/rfc8087>.

   [RFC8981]  Gont, F., Krishnan, S., Narten, T., and R. Draves,
              "Temporary Address Extensions for Stateless Address
              Autoconfiguration in IPv6", RFC 8981,
              DOI 10.17487/RFC8981, February 2021,
              <https://www.rfc-editor.org/info/rfc8981>.

   [SEC-CONS] Rescorla, E. and B. Korver, "Guidelines for Writing RFC
              Text on Security Considerations", BCP 72, RFC 3552,
              DOI 10.17487/RFC3552, July 2003,
              <https://www.rfc-editor.org/info/rfc3552>.

   [SLOWLORIS]
              "RSnake" Hansen, R., "Welcome to Slowloris - the low
              bandwidth, yet greedy and poisonous HTTP client!", June
              2009, <https://web.archive.org/web/20150315054838/
              http://ha.ckers.org/slowloris/>.
```

---
# **Appendix A.  Pseudocode**

이 섹션의 의사 코드는 샘플 알고리즘을 설명합니다. 이러한 알고리즘은 최적의 성능을 발휘하기보다는 정확하고 명확하도록 의도되었습니다.

이 섹션의 의사 코드 세그먼트는 코드 구성 요소로 라이선스가 부여됩니다. 저작권 고지를 참조하십시오.

---
### **A.1.  Sample Variable-Length Integer Decoding**

그림 45의 의사 코드는 가변 길이 정수를 바이트 스트림에서 읽을 수 있는 방법을 보여줍니다. ReadVarint 함수는 네트워크 바이트 순서로 읽을 수 있는 일련의 바이트인 단일 인수를 사용합니다.

ReadVarint\(data\): // 가변 길이 정수의 길이는 // 첫 번째 바이트의 처음 두 비트에 인코딩됩니다. v = data.next\_byte\(\) 접두사 = v \>\> 6 길이 = 1 << 접두사

// 길이를 알게 되면 이 비트를 제거하고 // 나머지 바이트를 읽습니다. v = v & 0x3f 반복 길이-1회: v = \(v << 8\) + data.next\_byte\(\) return v

```text
        Figure 45: Sample Variable-Length Integer Decoding Algorithm
```

예를 들어, 8바이트 시퀀스 0xc2197c5eff14e88c는 10진수 값 151,288,809,941,952,652로 디코딩됩니다. 4바이트 시퀀스 0x9d7f3e7d는 494,878,333으로 디코딩됩니다. 2바이트 시퀀스 0x7bbd는 15,293으로 디코딩됩니다. 단일 바이트 0x25는 37로 디코딩됩니다\(2바이트 시퀀스 0x4025도 마찬가지임\).

---
### **A.2.  Sample Packet Number Encoding Algorithm**

그림 46의 의사 코드는 구현이 패킷 번호 인코딩을 위해 적절한 크기를 선택할 수 있는 방법을 보여줍니다.

EncodePacketNumber 함수는 두 개의 인수를 사용합니다.

\* full\_pn은 전송 중인 패킷의 전체 패킷 번호입니다.

\* Largest\_acked는 전송된 가장 큰 패킷 번호입니다.

- 현재 패킷 번호 공간\(있는 경우\)에서 피어에 의해 확인됨.

```text
   EncodePacketNumber(full_pn, largest_acked):
```

// 비트 수는 새 패킷을 포함하여 // 연속된 미확인 패킷 번호 수의 밑이 2인 // 로그보다 적어도 하나 더 많아야 합니다. Large\_acked가 None인 경우: num\_unacked = full\_pn + 1 그렇지 않은 경우: num\_unacked = full\_pn - maximum\_acked

```text
     min_bits = log(num_unacked, 2) + 1
     num_bytes = ceil(min_bits / 8)

     // Encode the integer value and truncate to
     // the num_bytes least significant bytes.
     return encode(full_pn, num_bytes)

             Figure 46: Sample Packet Number Encoding Algorithm
```

예를 들어 엔드포인트가 패킷 0xabe8b3에 대한 승인을 받고 번호가 0xac5c02인 패킷을 보내는 경우 29,519\(0x734f\)개의 미해결 패킷 번호가 있습니다. 이 범위의 최소 두 배\(59,038 패킷 또는 0xe69e\)를 나타내려면 16비트가 필요합니다.

동일한 상태에서 0xace8fe 개수의 패킷을 보내는 것은 24비트 인코딩을 사용합니다. 그 이유는 두 배의 범위\(131,222 패킷 또는 0x020096\)를 나타내려면 최소 18비트가 필요하기 때문입니다.

---
### **A.3.  Sample Packet Number Decoding Algorithm**

그림 47의 의사 코드에는 헤더 보호가 제거된 후 패킷 번호를 디코딩하기 위한 예제 알고리즘이 포함되어 있습니다.

DecodePacketNumber 함수는 세 가지 인수를 사용합니다.

\* large\_pn은 현재 패킷 번호 공간에서 성공적으로 처리된 가장 큰 패킷 번호입니다.

\* truncated\_pn은 패킷 번호 필드의 값입니다.

\* pn\_nbits는 패킷 번호 필드의 비트 수\(8, 16, 24 또는 32\)입니다.

```text
   DecodePacketNumber(largest_pn, truncated_pn, pn_nbits):
      expected_pn  = largest_pn + 1
      pn_win       = 1 << pn_nbits
      pn_hwin      = pn_win / 2
      pn_mask      = pn_win - 1
      // The incoming packet number should be greater than
      // expected_pn - pn_hwin and less than or equal to
      // expected_pn + pn_hwin
      //
      // This means we cannot just strip the trailing bits from
      // expected_pn and add the truncated_pn because that might
      // yield a value outside the window.
      //
      // The following code calculates a candidate value and
      // makes sure it's within the packet number window.
      // Note the extra checks to prevent overflow and underflow.
      candidate_pn = (expected_pn & ~pn_mask) | truncated_pn
      if candidate_pn <= expected_pn - pn_hwin and
         candidate_pn < (1 << 62) - pn_win:
         return candidate_pn + pn_win
      if candidate_pn > expected_pn + pn_hwin and
         candidate_pn >= pn_win:
         return candidate_pn - pn_win
      return candidate_pn

             Figure 47: Sample Packet Number Decoding Algorithm
```

예를 들어 성공적으로 인증된 가장 높은 패킷의 패킷 번호가 0xa82f30ea인 경우 16비트 값 0x9b32를 포함하는 패킷은 0xa82f9b32로 디코딩됩니다.

---
### **A.4.  Sample ECN Validation Algorithm**

엔드포인트가 새 네트워크 경로에서 전송을 시작할 때마다 경로가 ECN을 지원하는지 여부를 결정합니다. 섹션 13.4를 참조하십시오. 경로가 ECN을 지원하는 경우 목표는 ECN을 사용하는 것입니다. 엔드포인트는 ECN을 지원하지 않는 것으로 확인된 경로를 주기적으로 재평가할 수도 있습니다.

이 섹션에서는 새 경로를 테스트하는 한 가지 방법을 설명합니다. 이 알고리즘은 ECN 지원을 위해 경로를 테스트하는 방법을 보여주기 위한 것입니다. 엔드포인트는 다양한 방법을 구현할 수 있습니다.

경로에는 "테스트 중", "알 수 없음", "실패" 또는 "가능" 중 하나인 ECN 상태가 할당됩니다. "테스트 중" 또는 "가능" 상태의 경로에서 끝점은 ECT 표시가 있는 패킷을 보냅니다. 기본적으로 ECT\(0\)입니다. 그렇지 않으면 끝점이 표시되지 않은 패킷을 보냅니다.

경로 테스트를 시작하려면 ECN 상태를 "테스트 중"으로 설정하고 기존 ECN 수를 기준선으로 기억합니다.

테스트 기간은 끝점에서 결정한 패킷 수 또는 제한된 시간 동안 실행됩니다. 목표는 테스트 기간의 지속 시간을 제한하는 것이 아니라 경로가 표시된 패킷을 처리하는 방법에 대한 명확한 표시를 제공하기 위해 수신된 ECN 수에 대해 충분한 표시된 패킷이 전송되도록 하는 것입니다. 섹션 13.4.2에서는 이것을 10개의 패킷 또는 PTO의 3배로 제한할 것을 제안합니다.

테스트 기간이 끝나면 경로의 ECN 상태는 "알 수 없음"이 됩니다. "알 수 없음" 상태에서 ACK 프레임\(섹션 13.4.2.1 참조\)에서 ECN 카운트의 성공적인 유효성 검사는 표시된 패킷이 확인되지 않은 경우 경로에 대한 ECN 상태가 "사용 가능"이 되도록 합니다.

언제든지 ECN 수의 유효성 검사가 실패하면 영향을 받는 경로의 ECN 상태가 "실패"가 됩니다. 엔드포인트는 표시된 패킷이 모두 손실로 선언되거나 모두 ECN-CE로 표시된 경우 경로의 ECN 상태를 "실패"로 표시할 수도 있습니다.

이 알고리즘을 따르면 ECN을 제대로 지원하는 경로에 대해 ECN이 거의 비활성화되지 않습니다. 표시를 잘못 수정하는 경로로 인해 ECN이 비활성화됩니다. 표시된 패킷이 경로에 의해 폐기되는 드문 경우의 경우 짧은 테스트 기간이 발생하는 손실 수를 제한합니다.

---
# **Contributors**

이 프로토콜의 원래 디자인과 이론적 근거는 Jim Roskind \[초기 디자인\]의 작업에서 크게 가져옵니다.

IETF QUIC 워킹 그룹은 많은 사람들로부터 엄청난 지원을 받았습니다. 다음 사람들은 이 문서에 상당한 기여를 했습니다.

```text
   *  Alessandro Ghedini
   *  Alyssa Wilk
   *  Antoine Delignat-Lavaud
   *  Brian Trammell
   *  Christian Huitema
   *  Colin Perkins
   *  David Schinazi
   *  Dmitri Tikhonov
   *  Eric Kinnear
   *  Eric Rescorla
   *  Gorry Fairhurst
   *  Ian Swett
   *  Igor Lubashev
   *  奥 一穂 (Kazuho Oku)
   *  Lars Eggert
   *  Lucas Pardue
   *  Magnus Westerlund
   *  Marten Seemann
   *  Martin Duke
   *  Mike Bishop
   *  Mikkel Fahnøe Jørgensen
   *  Mirja Kühlewind
   *  Nick Banks
   *  Nick Harper
   *  Patrick McManus
   *  Roberto Peon
   *  Ryan Hamilton
   *  Subodh Iyengar
   *  Tatsuhiro Tsujikawa
   *  Ted Hardie
   *  Tom Jones
   *  Victor Vasiliev
```

---
# **Authors' Addresses**

```text
   Jana Iyengar (editor)
   Fastly

   Email: jri.ietf@gmail.com

   Martin Thomson (editor)
   Mozilla

   Email: mt@lowentropy.net
```


```text
Network Working Group                                        V. Jacobson
Request for Comments: 1323                                           LBL
Obsoletes: RFC 1072, RFC 1185                                  R. Braden
                                                                     ISI
                                                               D. Borman
                                                           Cray Research
                                                                May 1992
```

- 고성능을 위한 TCP 확장

---
# **Status of This Memo**

이 RFC는 인터넷 커뮤니티를 위한 IAB 표준 트랙 프로토콜을 지정하고 개선을 위한 토론과 제안을 요청합니다. 이 프로토콜의 표준화 상태 및 상태에 대해서는 "IAB 공식 프로토콜 표준" 최신판을 참조하십시오. 이 메모의 배포는 무제한입니다.

---
# **Abstract**

이 메모는 넓은 대역폭\*지연 제품 경로에서 성능을 향상시키고 초고속 경로에서 안정적인 작동을 제공하기 위한 일련의 TCP 확장을 제시합니다. 이는 확장을 구현하지 않는 TCP와의 호환 가능한 상호 작용을 제공하도록 설계된 확장된 창 및 타임스탬프에 대한 새로운 TCP 옵션을 정의합니다. 타임스탬프는 RTTM\(Round Trip Time Measurement\) 및 PAWS\(Protect Against Wrapped Sequences\)라는 두 가지 메커니즘에 사용됩니다. 이 메모에는 선택적 승인이 포함되지 않습니다.

이 메모는 RFC-1072와 RFC-1185를 결합하고 대체하여 추가 설명과 자세한 사양을 추가합니다. 부록 C에는 이전 RFC의 변경 사항이 요약되어 있습니다.

---
# **TABLE OF CONTENTS**

```text
   1.  Introduction .................................................  2
   2.  TCP Window Scale Option ......................................  8
   3.  RTTM -- Round-Trip Time Measurement .......................... 11
   4.  PAWS -- Protect Against Wrapped Sequence Numbers ............. 17
   5.  Conclusions and Acknowledgments .............................. 25
   6.  References ................................................... 25
   APPENDIX A: Implementation Suggestions ........................... 27
   APPENDIX B: Duplicates from Earlier Connection Incarnations ...... 27
   APPENDIX C: Changes from RFC-1072, RFC-1185 ...................... 30
   APPENDIX D: Summary of Notation .................................. 31
   APPENDIX E: Event Processing ..................................... 32
   Security Considerations .......................................... 37
   Authors' Addresses ............................................... 37
```

---
## **1. INTRODUCTION**

TCP 프로토콜 \[Postel81\]은 전송 속도, 지연, 손상, 복제 또는 세그먼트 재정렬에 관계없이 거의 모든 전송 매체에서 안정적으로 작동하도록 설계되었습니다. 프로덕션 TCP 구현은 현재 100bps\~10\*\*7bps 범위의 전송 속도와 1ms\~100초 범위의 왕복 지연에 적응합니다. TCP 성능에 대한 최근 연구에 따르면 TCP는 800Mbit/초 I/O 채널부터 300비트/초 전화 접속 모뎀까지 다양한 인터넷 경로에서 잘 작동할 수 있는 것으로 나타났습니다\[Jacobson88a\].

광섬유의 도입으로 인해 전송 속도가 점점 더 빨라지고 있으며 가장 빠른 경로는 TCP가 원래 설계된 영역 밖으로 이동하고 있습니다. 이 메모는 증가하는 네트워크 기능에 맞게 애플리케이션의 도메인을 확장하기 위해 TCP에 대한 적당한 확장 세트를 정의합니다. 이는 RFC-1072 \[Jacobson88b\] 및 RFC-1185 \[Jacobson90b\]를 기반으로 하며 더 이상 사용되지 않습니다.

"TCP는 얼마나 빨리 갈 수 있는가?"라는 질문에 대한 한 줄 대답은 없습니다. 문제에는 성능과 안정성이라는 두 가지 종류가 있으며 각각은 서로 다른 매개변수에 따라 달라집니다. 우리는 각각을 차례로 논의합니다.

```text
   1.1  TCP Performance
```

- TCP 성능은 전송 속도 자체에 좌우되는 것이 아니라 전송 속도와 왕복 지연의 곱에 따라 달라집니다. 이 "대역폭\*지연 곱"은 "파이프를 채우는" 데이터의 양을 측정합니다. 이는 경로를 통한 TCP 연결에서 최대 처리량을 얻기 위해 발신자와 수신자에게 필요한 버퍼 공간입니다. 즉, 파이프라인을 가득 채우기 위해 TCP가 처리해야 하는 승인되지 않은 데이터의 양입니다. 대역폭\*지연 곱이 클 때 TCP 성능 문제가 발생합니다. 우리는 이 지역에서 작동하는 인터넷 경로를 "길고 굵은 파이프"라고 하며, 이 경로를 포함하는 네트워크를 "LFN"\("elephan\(t\)"으로 발음\)이라고 합니다.

- 고용량 패킷 위성 채널\(예: DARPA의 Wideband Net\)은 LFN입니다. 예를 들어, DS1 속도 위성 채널의 대역폭\*지연 곱은 10\*\*6비트 이상입니다. 이는 각각 1200바이트의 미해결 TCP 세그먼트 100개에 해당합니다. 지상의 광섬유 경로도 LFN 클래스에 속합니다. 예를 들어 DS3 대역폭\(45Mbps\)에서 30ms의 국가 간 지연도 10\*\*6비트를 초과합니다.

- 현재 TCP over LFN 경로에는 세 가지 근본적인 성능 문제가 있습니다.

```text
      (1)  Window Size Limit
```

- TCP 헤더는 16비트 필드를 사용하여 수신 창 크기를 보낸 사람에게 보고합니다. 따라서 사용할 수 있는 가장 큰 창은 2\*\*16 = 65K 바이트입니다.

- 이 문제를 피하기 위해 이 메모의 섹션 2에서는 2\*\*16보다 큰 창을 허용하는 새로운 TCP 옵션인 "창 크기 조정"을 정의합니다. 이 옵션은 실제 창 크기를 얻기 위해 TCP 헤더에 있는 창 크기 값을 곱하는 데 사용되는 암시적 배율 인수를 정의합니다.

- \(2\) 손실회복

- LFN의 패킷 손실은 처리량에 치명적인 영향을 미칠 수 있습니다. 최근까지 제대로 작동하는 TCP 구현으로 인해 패킷이 손실될 때마다 데이터 파이프라인이 소모되고 복구하려면 느린 시작 작업이 필요했습니다. 최근에는 Fast Retransmit 및 Fast Recovery 알고리즘 \[Jacobson90c\]이 도입되었습니다. 이들의 결합 효과는 파이프라인을 소모하지 않고 창당 하나의 패킷 손실을 복구하는 것입니다. 그러나 창당 패킷 손실이 두 개 이상 발생하면 일반적으로 재전송 시간 초과가 발생하고 결과적으로 파이프라인이 소모되고 시작이 느려집니다.

- LFN의 용량에 맞게 창 크기를 확장하면 창당 두 개 이상의 패킷이 삭제될 확률이 그에 따라 증가합니다. 이는 LFN을 통한 TCP 처리량에 치명적인 영향을 미칠 수 있습니다. 또한, 어떤 형태의 무작위 삭제를 기반으로 하는 혼잡 제어 메커니즘이 게이트웨이에 도입되면 무작위 간격의 패킷 삭제가 일반화되어 창당 두 개 이상의 패킷이 삭제될 확률이 높아질 수 있습니다.

```text
           To generalize the Fast Retransmit/Fast Recovery mechanism to
           handle multiple packets dropped per window, selective
           acknowledgments are required.  Unlike the normal cumulative
           acknowledgments of TCP, selective acknowledgments give the
           sender a complete picture of which segments are queued at the
           receiver and which have not yet arrived.  Some evidence in
           favor of selective acknowledgments has been published
           [NBS85], and selective acknowledgments have been included in
           a number of experimental Internet protocols -- VMTP
           [Cheriton88], NETBLT [Clark87], and RDP [Velten84], and
           proposed for OSI TP4 [NBS85].  However, in the non-LFN
           regime, selective acknowledgments reduce the number of
```

패킷이 재전송되었지만 개선되지 않음

- 성능이 복잡하여 가치가 의심스럽습니다. 그러나 선택적 승인은 LFN 체제에서 훨씬 더 중요해질 것으로 예상됩니다.

- RFC-1072는 선택적 승인을 보내는 새로운 TCP "SACK" 옵션을 정의했습니다. 그러나 SACK 옵션의 형식과 의미에 관해 해결해야 할 중요한 기술 문제가 있습니다. 따라서 이 확장 패키지에서는 SACK가 생략되었습니다. 표준화 과정에서 SACK이 "따라잡을" 수 있기를 바랍니다.

```text
      (3)  Round-Trip Measurement
```

- TCP는 RTO\(재전송 시간 초과\) 간격 내에 승인되지 않은 세그먼트를 재전송하여 안정적인 데이터 전달을 구현합니다. 적절한 RTO의 정확한 동적 결정은 TCP 성능에 필수적입니다. RTO는 측정된 왕복 시간\(RTT\)의 평균과 분산, 즉 세그먼트 전송과 이에 대한 승인 수신 사이의 시간 간격을 추정하여 결정됩니다\[Jacobson88a\].

- 섹션 4에서는 새로운 TCP 옵션인 "타임스탬프"를 소개하고 이 옵션을 사용하여 무시할 수 있는 계산 비용으로 재전송을 포함한 거의 모든 세그먼트의 시간을 측정할 수 있는 메커니즘을 정의합니다. 이 메커니즘에는 니모닉 RTTM\(왕복 시간 측정\)을 사용하여 타임스탬프 옵션의 다른 용도와 구별합니다.

```text
   1.2 TCP Reliability
```

- 이제 성능에서 신뢰성으로 전환합니다. 높은 전송률은 대역폭\*지연 곱을 통해 TCP 성능에 들어갑니다. 그러나 높은 전송 속도만으로는 중복 감지 및 순서 지정을 위한 TCP 메커니즘의 가정을 위반하여 TCP 신뢰성을 위협할 수 있습니다.

- 데이터 세그먼트에서 TCP 시퀀스 번호를 실수로 재사용하면 특히 심각한 오류가 발생할 수 있습니다. 예를 들어 인터넷 대기열에서 지연된 중복 데이터 세그먼트와 같은 "오래된 중복 세그먼트"가 잘못된 순간에 수신자에게 전달되어 해당 시퀀스 번호가 현재 창 내의 어딘가에 있다고 가정합니다. 오류를 경고하는 체크섬 오류가 발생하지 않으며 그 결과 감지되지 않은 데이터 손상이 발생할 수 있습니다. 송신기에서 오래된 중복 ACK 세그먼트의 수신은 약간 덜 심각할 수 있습니다.

- 더 이상 진행되지 않도록 연결을 잠그고 연결에 대해 RST를 강제합니다.

- TCP 신뢰성은 세그먼트의 수명에 대한 경계\("최대 세그먼트 수명" 또는 MSL\)의 존재에 따라 달라집니다. MSL은 일반적으로 모든 신뢰할 수 있는 전송 프로토콜에 필요합니다. 모든 시퀀스 번호 필드는 유한해야 하고 따라서 모든 시퀀스 번호는 결국 재사용될 수 있기 때문입니다. 인터넷 프로토콜 제품군에서 MSL 바인딩은 IP 계층 메커니즘인 "Time-to-Live" 또는 TTL 필드에 의해 시행됩니다.

- 시퀀스 번호 중복은 다음 두 가지 방법 중 하나로 발생할 수 있습니다.

- \(1\) 현재 연결에 대한 시퀀스 번호 순환

- TCP 시퀀스 번호는 32비트를 포함합니다. 전송 속도가 충분히 높으면 32비트 시퀀스 공간은 세그먼트가 대기열에서 지연되는 시간 내에 "래핑"\(순환\)될 수 있습니다.

- \(2\) 연결의 초기 화신

- 적절한 종료 순서 또는 호스트 충돌로 인해 연결이 종료되고 동일한 연결\(즉, 동일한 소켓 쌍 사용\)이 즉시 다시 열린다고 가정합니다. 종료된 연결에서 지연된 세그먼트는 새로운 구현을 위한 현재 창에 속할 수 있으며 유효한 것으로 받아들여질 수 있습니다.

- 이전 구현의 중복인 사례 \(2\)는 섹션 5.3 및 부록 B에 설명된 대로 TCP 사양의 현재 고정 MSL을 적용하여 방지됩니다. 그러나 사례 \(1\)은 동일한 연결 내에서 시퀀스 번호의 재사용을 방지합니다. , 전송 속도에 따라 달라지는 MSL 경계가 필요하며 속도가 충분히 높으면 새로운 메커니즘이 필요합니다.

- 보다 구체적으로, TCP가 특정 경로를 통해 전송할 수 있는 최대 유효 대역폭이 초당 B바이트인 경우 오류 없는 작동을 위해서는 다음 제약 조건을 충족해야 합니다.

```text
          2**31 / B  > MSL (secs)                     [1]
```

- 다음 표는 대역폭 B의 일부 중요한 값에 대한 Twrap = 2\*\*31/B\(초\)의 값을 보여줍니다.

```text
           Network       B*8          B         Twrap
                      bits/sec   bytes/sec      secs
           _______    _______      ______       ______

           ARPANET       56kbps       7KBps    3*10**5 (~3.6 days)

           DS1          1.5Mbps     190KBps    10**4 (~3 hours)

           Ethernet      10Mbps    1.25MBps    1700 (~30 mins)

           DS3           45Mbps     5.6MBps    380

           FDDI         100Mbps    12.5MBps    170

           Gigabit        1Gbps     125MBps    17
```

- 시퀀스 공간의 랩어라운드는 56kbps 패킷 스위칭이나 심지어 10Mbps 이더넷에서도 문제가 되지 않는다는 것이 분명합니다. 반면, DS3 및 FDDI 속도에서 Twrap은 TCP 사양\[Postel81\]에서 가정하는 2분 MSL과 비슷합니다. 기가비트 속도로 이동하면 Twrap은 인터넷 TTL 메커니즘을 통해 안정적으로 적용하기에는 너무 작아집니다.

- TCP의 16비트 윈도우 필드는 유효 대역폭 B를 2\*\*16/RTT로 제한합니다. 여기서 RTT는 초 단위의 왕복 시간입니다\[McKenzie89\]. RTT가 충분히 크면 B는 큰 MSL 값에 대한 제약 조건 \[1\]을 충족하는 값으로 제한됩니다. 예를 들어, RTT가 60ms\(물리 법칙에 따라 설정됨\)인 대륙 횡단 백본을 생각해 보세요. 대역폭\*지연 곱이 TCP 창 크기에 따라 64KB로 제한되면 B는 경로의 이론적 전송 속도가 아무리 높더라도 1.1MBps로 제한됩니다. 이는 오늘날의 인터넷에서 안전한 Twrap= 2000초의 시퀀스 번호 공간 순환에 해당합니다.

- 원인은 더 큰 창이 아니라 높은 대역폭에 있다는 점을 이해하는 것이 중요합니다. 예를 들어, 직경이 10km인 \(매우 큰\) FDDI LAN을 생각해 보십시오. 빛의 속도를 사용하여 링 전체의 RTT를 \(2\*10\*\*4\)/\(3\*10\*\*8\) = 67마이크로초로 계산할 수 있으며 지연\*대역폭 곱은 833바이트입니다. 833바이트의 창만 사용하는 이 LAN을 통한 TCP 연결은 전체 100mbps에서 실행되며 TCP의 MSL에 매우 가까운 약 3분 안에 시퀀스 공간을 래핑할 수 있습니다. 따라서 확장된 창 없이도 고속만으로는 시퀀스 번호 순환에 대한 신뢰성 문제가 발생할 수 있습니다.

- Watson의 Delta-T 프로토콜\[Watson81\]에는 MSL의 정확한 시행을 위한 네트워크 계층 메커니즘이 포함되어 있습니다. 이에 비해 IP는

- MSL 시행 메커니즘은 느슨하게 정의되어 있으며 인터넷에서는 훨씬 더 느슨하게 구현됩니다. 따라서 TCP 연결에 대해 MSL을 적극적으로 적용하는 것은 현명하지 않으며, MSL을 현재 값\(예: TCP에 지정된 120초\)보다 작게 설정하는 것은 비현실적입니다.

- 시퀀스 공간 순환 문제에 대한 가능한 수정 방법은 TCP 시퀀스 번호 필드의 크기를 늘리는 것입니다. 예를 들어, 시퀀스 번호 필드\(및 승인 필드\)는 64비트로 확장될 수 있습니다. 이는 TCP 헤더를 변경하거나 추가 옵션을 통해 수행할 수 있습니다.

- 섹션 5에서는 예측 가능한 네트워크 대역폭 상한을 훨씬 뛰어넘는 전송 속도로 TCP 신뢰성을 확장하기 위해 PAWS\(Protect Against Wrapped Sequence Number\)라고 부르는 다른 메커니즘을 제시합니다. PAWS는 섹션 4에 정의된 TCP 타임스탬프 옵션을 사용하여 동일한 연결의 오래된 중복으로부터 보호합니다.

```text
   1.3 Using TCP options
```

- 이 메모에 정의된 확장은 모두 새로운 TCP 옵션을 사용합니다. 우리는 TCP 옵션 사용과 관련하여 \(1\) 호환성과 \(2\) 오버헤드라는 두 가지 가능한 문제를 해결해야 합니다.

우리는 호환성에 세심한 주의를 기울여야 합니다.

- 기존 구현과의 상호 운용. 이전에 정의된 유일한 TCP 옵션인 MSS는 SYN 세그먼트에만 나타날 수 있습니다. 모든 구현에서는 SYN 세그먼트에 대한 알려지지 않은 옵션을 무시해야 하며 대부분 그렇게 될 것으로 예상합니다. 그러나 일부 버그가 있는 TCP 구현은 비SYN 세그먼트에 옵션이 처음 나타나면 충돌이 발생할 수 있습니다. 따라서 아래에 정의된 각 확장에 대해 TCP 옵션은 SYN 세그먼트의 옵션 교환이 양측이 확장을 이해했음을 나타내는 경우에만 비SYN 세그먼트로 전송됩니다. 또한 확장 옵션은 해당 옵션이 초기 <SYN\> 세그먼트에 수신된 경우에만 <SYN,ACK\> 세그먼트에 전송됩니다.

- TCP 옵션의 대역폭 및 처리 오버헤드에 대한 의문이 제기될 수 있습니다. SYN 세그먼트에서 발생하는 옵션은 성능 문제를 일으킬 가능성이 없습니다. TCP 연결을 열려면 중요한 특수 사례 코드를 실행해야 하며 옵션 처리로 인해 해당 비용이 크게 증가할 가능성은 없습니다.

- 반면, 타임스탬프 옵션은 모든 데이터 또는 ACK 세그먼트에 나타날 수 있으며 20바이트 TCP 헤더에 12바이트를 추가합니다. 우리

불필요한 것을 줄임으로써 대역폭이 절약된다고 믿습니다.

- 재전송은 추가 헤더 대역폭에 대한 비용을 지불하는 것 이상입니다.

- 특히 RISC 아키텍처 CPU의 경우 가변 바이트 정렬 형식의 옵션을 구문 분석하기 위한 처리 오버헤드에 대한 문제도 있습니다. 이러한 문제를 해결하기 위해 부록 A에는 합리적인 데이터 필드 정렬을 달성하기 위한 TCP 헤더 옵션의 권장 레이아웃이 포함되어 있습니다. 헤더 예측의 정신에 따라 TCP는 이 레이아웃을 신속하게 테스트할 수 있으며, 확인되면 빠른 경로를 사용할 수 있습니다. 이 표준 레이아웃을 사용하는 호스트는 TCP 헤더에 추가된 고정 형식 필드 세트로 옵션을 효과적으로 사용합니다. 그러나 TCP 옵션의 철학적 및 프로토콜 프레임워크를 유지하려면 효율성은 떨어지더라도 TCP가 임의의 옵션 필드를 구문 분석할 수 있도록 준비해야 합니다.

- 마지막으로, 우리는 이 메모에 정의된 대부분의 메커니즘이 LFN 및/또는 초고속 네트워크에 중요하다는 점을 관찰했습니다. 저속 네트워크의 경우 이러한 메커니즘을 사용하지 않는 것이 성능 최적화일 수 있습니다. 저속 경로를 통한 최적의 성능을 염려하는 TCP 공급업체는 저속 경로에 대해 이러한 확장을 끄거나 사용자 또는 설치 관리자가 이를 비활성화하도록 허용할 수 있습니다.

---
## **2. TCP WINDOW SCALE OPTION**

```text
   2.1  Introduction
```

- 창 배율 확장은 TCP 창의 정의를 32비트로 확장한 다음 배율 인수를 사용하여 TCP 헤더의 16비트 창 필드\(RFC-793의 SEG.WND\)에 이 32비트 값을 전달합니다. 스케일 팩터는 새로운 TCP 옵션인 Window Scale로 전달됩니다. 이 옵션은 SYN 세그먼트\(SYN 비트가 켜져 있는 세그먼트\)에서만 전송되므로 연결이 열릴 때 창 크기가 각 방향으로 고정됩니다. \(또 다른 설계 선택은 모든 TCP 세그먼트에서 창 배율을 지정하는 것입니다. 배율 인수가 변경된 경우에만 창 배율 옵션을 보내는 것은 올바르지 않습니다. 승인 세그먼트의 TCP 옵션이 안정적으로 전달되지 않기 때문입니다\(ACK가 없는 한\). 다른 방향의 데이터에 피기백됩니다.\) 연결이 열릴 때 스케일을 고정하면 오버헤드가 낮다는 장점이 있지만 연결 중에 스케일 인수를 변경할 수 없다는 단점이 있습니다.\)

- 최대 수신 창 및 그에 따른 배율은 최대 수신 버퍼 공간에 의해 결정됩니다. 일반적인 최신 구현에서는 이 최대 버퍼 공간이 기본적으로 설정됩니다.

- 그러나 TCP 연결이 열리기 전에 사용자 프로그램에 의해 무시될 수 있습니다. 이는 축척 비율을 결정하므로 창 크기 조정에 새로운 사용자 인터페이스가 필요하지 않습니다.

```text
   2.2  Window Scale Option
```

- 3바이트 Window Scale 옵션은 TCP에 의해 SYN 세그먼트로 전송될 수 있습니다. 여기에는 두 가지 목적이 있습니다. \(1\) TCP가 송신 및 수신 창 크기 조정을 모두 수행할 준비가 되었음을 나타냅니다. \(2\) 수신 창에 적용할 배율 인수를 전달합니다. 따라서 창 크기 조정을 준비하는 TCP는 자체 크기 조정 요소가 1인 경우에도 옵션을 보내야 합니다. 크기 조정 요소는 2의 거듭제곱으로 제한되고 대수적으로 인코딩되므로 이진 이동 연산으로 구현될 수 있습니다.

```text
      TCP Window Scale Option (WSopt):

         Kind: 3 Length: 3 bytes

                +---------+---------+---------+
                | Kind=3  |Length=3 |shift.cnt|
                +---------+---------+---------+
```

- 이 옵션은 약속이 아닌 제안입니다. 창 크기 조정을 어느 방향으로든 활성화하려면 양쪽 모두 SYN 세그먼트에 창 크기 조정 옵션을 보내야 합니다. 창 크기 조정이 활성화된 경우 이 옵션을 보낸 TCP는 SEG.WND의 전송을 위해 'shift.cnt' 비트만큼 실제 수신 창 값을 오른쪽으로 이동합니다. 'shift.cnt' 값은 0일 수 있습니다\(수신 창에 1의 배율 인수를 적용하면서 배율을 제공\).

- 이 옵션은 초기 <SYN\> 세그먼트\(즉, SYN 비트가 켜져 있고 ACK 비트가 꺼져 있는 세그먼트\)에서 전송될 수 있습니다. <SYN,ACK\> 세그먼트로도 전송될 수 있지만 초기 <SYN\> 세그먼트에서 Window Scale 옵션을 수신한 경우에만 가능합니다. SYN 비트가 없는 세그먼트의 창 크기 조정 옵션은 무시되어야 합니다.

- SYN\(예: <SYN\> 또는 <SYN,ACK\>\) 세그먼트 자체의 창 필드는 크기가 조정되지 않습니다.

2.3 창 크기 조정 옵션 사용

- 창 크기 조정의 모델 구현은 RFC-793 \[Postel81\]의 표기법을 사용하여 다음과 같습니다.

- \* 모든 창은 32비트 수량으로 처리되어 저장됩니다.

- 연결 제어 블록 및 로컬 계산용. 여기에는 전송 창\(SND.WND\) 및 수신 창\(RCV.WND\) 값은 물론 정체 창도 포함됩니다.

- \* 연결 상태는 들어오는 창 필드와 나가는 창 필드에 각각 적용되는 두 개의 창 이동 횟수인 Snd.Wind.Scale 및 Rcv.Wind.Scale에 의해 증가됩니다.

- \* TCP가 Window Scale 옵션이 포함된 <SYN\> 세그먼트를 수신하면 <SYN,ACK\> 세그먼트에 자체 Window Scale 옵션을 보냅니다.

- \* Window Scale 옵션은 Shift.cnt = R로 전송됩니다. 여기서 R은 TCP가 수신 창에 사용하려는 값입니다.

- \* Shift.cnt = S를 포함하는 Window Scale 옵션이 있는 SYN 세그먼트를 수신하면 TCP는 Snd.Wind.Scale을 S로 설정하고 Rcv.Wind.Scale을 R로 설정합니다. 그렇지 않으면 Snd.Wind.Scale과 Rcv.Wind.Scale을 모두 0으로 설정합니다.

- \* SYN 세그먼트를 제외하고 모든 수신 세그먼트 헤더의 창 필드\(SEG.WND\)는 SND.WND를 업데이트하기 전에 Snd.Wind.Scale 비트에 의해 왼쪽으로 이동됩니다.

```text
              SND.WND = SEG.WND << Snd.Wind.Scale
```

- \(RFC793의 다른 조건이 충족된다고 가정하고 왼쪽 시프트에 "C" 표기법 "<<" 사용\)

- \* SYN 세그먼트를 제외하고 모든 나가는 세그먼트의 창 필드\(SEG.WND\)는 Rcv.Wind.Scale 비트에 의해 오른쪽으로 이동됩니다.

```text
              SEG.WND = RCV.WND >> Rcv.Wind.Scale.
```

- TCP는 해당 시퀀스 번호가 창 왼쪽 가장자리의 2\*\*31바이트 내에 있는지 테스트하여 데이터 세그먼트가 "이전"인지 "새"인지 결정하고, 그렇지 않은 경우 데이터를 "이전"으로 삭제합니다. 새 데이터가 오래된 데이터로 잘못 간주되는 일이 없도록 하려면 송신자 창의 왼쪽 가장자리가 수신자 창의 오른쪽 가장자리에서 최대 2\*\*31 떨어져 있어야 합니다. 송신자의 오른쪽 가장자리와 수신자의 왼쪽 가장자리도 마찬가지입니다. 송신자 또는 수신자 창의 오른쪽 및 왼쪽 가장자리는 창 크기에 따라 다르고 송신자와 수신자 창은 최대 창 크기만큼 위상이 다를 수 있으므로 위의 제약 조건은 2 \* 최대 창 크기를 의미합니다.

- 2\*\*31보다 작아야 합니다.

```text
           max window < 2**30
```

- 최대 창은 최대 2\*\*16 - 1\(배율 조정되지 않은 최대 창\)의 2\*\*S\(여기서 S는 스케일링 이동 횟수\) 배이므로 S <=인 경우 최대 창은 < 2\*30이 보장됩니다. 14. 따라서 시프트 수는 14로 제한되어야 합니다\(2\*\*30 = 1GB의 창 허용\). Shift.cnt 값이 14를 초과하는 Window Scale 옵션을 수신하면 TCP는 오류를 기록해야 하지만 지정된 값 대신 14를 사용해야 합니다.

- 스케일 팩터는 TCP 헤더에 전송된 창 필드에만 적용됩니다. 확장 창을 사용하는 각 TCP는 창 값을 로컬에서 32비트 숫자로 유지합니다. 예를 들어, 느린 시작 및 혼잡 회피로 계산된 "혼잡 창"은 배율 인수의 영향을 받지 않으므로 창 크기 조정은 혼잡 창에 양자화를 도입하지 않습니다.

---
## **3.  RTTM: ROUND-TRIP TIME MEASUREMENT**

```text
   3.1  Introduction
```

- 변화하는 교통 상황에 적응하고 사용량이 많은 네트워크에서 "혼잡 붕괴"\[Nagle84\]로 알려진 불안정성을 방지하려면 정확한 최신 RTT 추정이 필요합니다. 그러나 RTT의 정확한 측정은 이론과 구현 모두에서 어려울 수 있습니다.

- 많은 TCP 구현은 창당 단 하나의 패킷 샘플을 기반으로 RTT 측정을 기반으로 합니다. 이는 작은 창에 대한 RTT에 대한 적절한 근사치를 산출하지만 LFN에 대한 RTT 추정치는 수용할 수 없을 정도로 열악합니다. RTT 추정을 신호 처리 문제로 보면 패킷 속도라는 특정 주파수의 데이터 신호가 더 낮은 주파수인 윈도우 속도에서 샘플링됩니다. 이렇게 낮은 샘플링 주파수는 나이퀴스트 기준을 위반하므로 추정된 RTT에 "앨리어싱" 아티팩트가 발생할 수 있습니다\[Hamming77\].

- 보수적인 재전송 시간 제한 계산을 사용하는 우수한 RTT 추정기는 샘플링 주파수가 데이터 주파수에 "가까울" 때 앨리어싱을 허용할 수 있습니다. 예를 들어, 8개의 패킷 창에서 샘플링 속도는 데이터 주파수의 1/8입니다. 즉, 크기 차이보다 작습니다. 그러나 창이 수십 또는 수백 개의 패킷인 경우 RTT 추정기에 심각한 오류가 발생하여 허위 재전송이 발생할 수 있습니다.

- 드롭된 패킷이 있으면 문제가 더욱 악화됩니다. 장

- \[Zhang86\], Jain \[Jain86\] 및 Karn \[Karn87\]은 재전송된 세그먼트가 추정에 포함되는 경우 신뢰할 수 있는 RTT 추정을 축적하는 것이 불가능함을 보여주었습니다. 재전송 전에 전체 데이터 창을 전송했으므로 다음 RTT 샘플을 가져오기 전에 해당 창의 모든 세그먼트에 ACK를 보내야 합니다. 이는 RTT 측정 사이에 최소한 추가 시간이 필요함을 의미하며, 오류율이 데이터 창당 하나에 접근함에 따라\(예: 광대역 위성 네트워크의 경우 비트당 10\*\*-6 오류\) 오류율을 얻는 것이 사실상 불가능해집니다. 유효한 RTT 측정.

- 발신자를 실질적으로 단순화하는 이러한 문제에 대한 해결책은 다음과 같습니다. TCP 옵션을 사용하여 발신자는 각 데이터 세그먼트에 타임스탬프를 배치하고 수신자는 이러한 타임스탬프를 ACK 세그먼트에 다시 반영합니다. 그런 다음 단일 차감으로 발신자에게 모든 ACK 세그먼트\(합리적인 수신기를 사용하여 다른 모든 데이터 세그먼트에 해당\)에 대한 정확한 RTT 측정값을 제공합니다. 우리는 이것을 RTTM\(Round-Trip Time Measurement\) 메커니즘이라고 부릅니다.

- 큰 창에서 RTTM 메커니즘을 사용하는 것이 매우 중요합니다. 그렇지 않으면 앨리어싱으로 인해 위험한 불안정성이 발생할 수 있습니다. 게다가 이 옵션은 발신자를 단순화하므로 모든 TCP에 유용할 것입니다.

```text
   3.2  TCP Timestamps Option
```

- TCP는 대칭 프로토콜로 데이터가 언제든지 어느 방향으로든 전송될 수 있으므로 타임스탬프 에코가 어느 방향에서나 발생할 수 있습니다. 단순성과 대칭성을 위해 타임스탬프가 항상 양방향으로 전송되고 에코되도록 지정합니다. 효율성을 위해 타임스탬프와 타임스탬프 응답 필드를 단일 TCP 타임스탬프 옵션으로 결합합니다.

```text
      TCP Timestamps Option (TSopt):

         Kind: 8

         Length: 10 bytes

          +-------+-------+---------------------+---------------------+
          |Kind=8 |  10   |   TS Value (TSval)  |TS Echo Reply (TSecr)|
          +-------+-------+---------------------+---------------------+
              1       1              4                     4
```

- 타임스탬프 옵션에는 두 개의 4바이트 타임스탬프 필드가 있습니다. 타임스탬프 값 필드\(TSval\)에는 옵션을 보내는 TCP의 타임스탬프 시계의 현재 값이 포함됩니다.

- 타임스탬프 에코 응답 필드\(TSecr\)는 ACK 비트가 TCP 헤더에 설정된 경우에만 유효합니다. 유효한 경우 Timestamps 옵션의 TSval 필드에 원격 TCP가 보낸 타임스탬프 값을 반영합니다. TSecr이 유효하지 않은 경우 해당 값은 0이어야 합니다. TSecr 값은 일반적으로 수신된 가장 최근의 Timestamp 옵션에서 나옵니다. 그러나 아래에 설명된 예외가 있습니다.

- TCP는 초기 <SYN\> 세그먼트\(즉, ACK 비트가 없고 SYN 비트를 포함하는 세그먼트\)에서 타임스탬프 옵션\(TSopt\)을 보낼 수 있으며, TSopt를 수신한 경우에만 다른 세그먼트에서 TSopt를 보낼 수 있습니다. 연결을 위한 초기 <SYN\> 세그먼트입니다.

3.3 RTTM 메커니즘

- TSval에 전송될 타임스탬프 값은 "타임스탬프 시계"라고 하는 \(가상\) 시계에서 가져옵니다. 실제 RTT를 측정하려면 해당 값이 적어도 실시간에 대략 비례해야 합니다.

- 다음 예에서는 세그먼트가 손실 없이 순서대로 도착하는 단방향 데이터 흐름을 보여줍니다. 여기서 A, B, C...는 연속적인 시퀀스 번호 블록을 차지하는 데이터 블록을 나타내고, ACK\(A\),...는 해당 누적 승인을 나타냅니다. Timestamps 옵션의 두 타임스탬프 필드는 기호로 <TSval= x,TSecr=y\>로 표시됩니다. 각 TSecr 필드에는 TSval 필드에서 가장 최근에 수신된 값이 포함됩니다.

```text
         TCP  A                                          TCP B

                        <A,TSval=1,TSecr=120> ------>

             <---- <ACK(A),TSval=127,TSecr=1>

                        <B,TSval=5,TSecr=127> ------>

             <---- <ACK(B),TSval=131,TSecr=5>

             . . . . . . . . . . . . . . . . . . . . . .

                        <C,TSval=65,TSecr=131> ------>

             <---- <ACK(C),TSval=191,TSecr=65>

                        (etc)
```

- 점선은 A가 전송할 내용이 없는 일시 정지\(60시간 단위\)를 표시합니다. 이 일시 중지는 B가 데이터 세그먼트 C에서 TSecr=131을 수신하여 추론할 수 있는 RTT를 팽창시킵니다. 따라서 단방향 데이터 흐름에서 역방향의 RTTM은 데이터 전송의 간격으로 인해 팽창되는 값을 측정합니다. 그러나 다음 규칙은 측정된 RTT의 팽창을 방지합니다.

- 세그먼트에서 수신된 TSecr 값은 세그먼트가 일부 새로운 데이터를 승인하는 경우, 즉 전송 창의 왼쪽 가장자리로 이동하는 경우에만 평균 RTT 측정을 업데이트하는 데 사용됩니다.

- TCP B가 데이터를 전송하지 않기 때문에 데이터 세그먼트 C는 B에 도착할 때 새로운 데이터를 승인하지 않습니다. 따라서 팽창된 RTTM 측정은 B의 RTTM 측정을 업데이트하는 데 사용되지 않습니다.

3.4 에코할 타임스탬프

- 응답 세그먼트가 전송되기 전에 둘 이상의 타임스탬프 옵션이 수신되면 TCP는 TSval 중 하나만 선택하여 에코해야 하며 나머지는 무시해야 합니다. 수신기에 유지되는 상태\(즉, 처리되지 않은 TSval의 수\)를 최소화하려면 수신기는 연결 제어 블록에 최대 하나의 타임스탬프를 유지해야 합니다.

- 고려해야 할 세 가지 상황이 있습니다.

```text
      (A)  Delayed ACKs.
```

- 많은 TCP는 짧은 시간 간격 내에 도착하는 세그먼트 그룹 중 모든 K번째 세그먼트만 승인합니다. 이 정책은 일반적으로 "지연된 ACK"로 알려져 있습니다. 데이터 송신자 TCP는 지연된 ACK로 인한 추가 시간을 포함하여 유효 RTT를 측정해야 합니다. 그렇지 않으면 불필요하게 재전송하게 됩니다. 따라서 지연된 ACK가 사용 중인 경우 수신자는 승인되지 않은 가장 빠른 세그먼트의 TSval 필드로 응답해야 합니다.

- \(B\) 시퀀스 공간에 구멍이 있습니다\(세그먼트가 손실되었습니다\).

- 발신자는 창이 채워질 때까지 계속 전송하며, 수신자는 순서가 잘못된 세그먼트가 도착하면 ACK를 생성할 수 있습니다\(예: "빠른 재전송"을 돕기 위해\).

- 손실된 세그먼트는 혼잡의 신호일 수 있으며, 이러한 상황에서 발신자는 재전송에 대해 보수적인 태도를 취해야 합니다. 또한 RTT를 과소평가하는 것보다 과대평가하는 것이 더 좋습니다. 따라서 순서가 잘못된 세그먼트에 대한 ACK에는 기간을 앞당긴 가장 최근 세그먼트의 타임스탬프가 포함되어야 합니다.

- 네트워크에 의해 세그먼트가 재정렬되는 경우에도 동일한 상황이 발생합니다.

- \(C\) 시퀀스 공간에 채워진 구멍.

- 구멍을 채우는 세그먼트는 네트워크 특성에 대한 가장 최근의 측정값을 나타냅니다. 반면, 이전 세그먼트에서 계산된 RTT에는 발신자의 재전송 시간 제한이 포함되어 발신자의 평균 RTT 추정치가 심하게 편향될 수 있습니다. 따라서 구멍을 채운 최신 세그먼트의 타임스탬프가 에코되어야 합니다.

- 세 가지 경우를 모두 포괄하는 알고리즘은 동기화된 연결의 타임스탬프 옵션 처리에 대한 다음 규칙에 설명되어 있습니다.

- \(1\) 연결 상태는 두 개의 32비트 슬롯으로 강화됩니다. TS.Recent는 세그먼트가 전송될 때마다 TSecr에 반영될 타임스탬프를 보유하고 Last.ACK.sent는 전송된 마지막 세그먼트의 ACK 필드를 보유합니다. Last.ACK.sent는 ACK가 지연된 경우를 제외하고는 RCV.NXT와 동일합니다.

- \(2\) Last.ACK.sent가 수신 세그먼트의 시퀀스 번호 범위 내에 속하는 경우:

```text
              SEG.SEQ <= Last.ACK.sent < SEG.SEQ + SEG.LEN
```

- 그런 다음 세그먼트의 TSval이 TS.Recent에 복사됩니다. 그렇지 않으면 TSval이 무시됩니다.

- \(3\) TSopt가 전송되면 TSecr 필드는 현재 TS.Recent 값으로 설정됩니다.

- 다음 예에서는 이러한 규칙을 보여줍니다. 여기서 A, B, C...는 연속적인 시퀀스 번호 블록을 차지하는 데이터 세그먼트를 나타내고, ACK\(A\),...는 해당 승인 세그먼트를 나타냅니다. ACK\(A\)는 B와 동일한 시퀀스 번호를 가지고 있습니다. 명확성을 위해 타임스탬프 에코의 한 방향만 표시합니다.

- o 패킷이 순서대로 도착하고 일부 ACK가 지연됩니다.

- 사례\(A\)에서는 가장 오래된 승인되지 않은 세그먼트의 타임스탬프가 에코됩니다.

```text
                                                      TS.Recent
                    <A, TSval=1> ------------------->
                                                          1
                    <B, TSval=2> ------------------->
                                                          1
                    <C, TSval=3> ------------------->
                                                          1
                             <---- <ACK(C), TSecr=1>
                    (etc)
```

o 패킷이 순서대로 도착하지 않으며 모든 패킷은

- 인정.

```text
           By Case (B), the timestamp from the last segment that
           advanced the left window edge is echoed, until the missing
           segment arrives; it is echoed according to Case (C).  The
           same sequence would occur if segments B and D were lost and
           retransmitted..

                                                      TS.Recent
                    <A, TSval=1> ------------------->
                                                          1
                             <---- <ACK(A), TSecr=1>
                                                          1
                    <C, TSval=3> ------------------->
                                                          1
                             <---- <ACK(A), TSecr=1>
                                                          1
                    <B, TSval=2> ------------------->
                                                          2
                             <---- <ACK(C), TSecr=2>
                                                          2
                    <E, TSval=5> ------------------->
                                                          2
                             <---- <ACK(C), TSecr=2>
                                                          2
                    <D, TSval=4> ------------------->
                                                          4
                             <---- <ACK(E), TSecr=4>
                    (etc)
```

---
## **4.  PAWS: PROTECT AGAINST WRAPPED SEQUENCE NUMBERS**

```text
   4.1  Introduction
```

- 섹션 4.2에서는 열린 TCP 연결을 손상시킬 수 있는 오래된 중복 세그먼트를 거부하는 간단한 메커니즘을 설명합니다. 우리는 이 메커니즘을 PAWS\(Protect Against Wrapped Sequence Number\)라고 부릅니다. PAWS는 연결 제어 블록에 저장된 상태를 사용하여 단일 TCP 연결 내에서 작동합니다. 섹션 4.3과 부록 C에서는 동일한 연결의 이전 구현에서 오래된 중복을 방지하기 위한 PAWS 메커니즘의 의미를 논의합니다.

4.2 PAWS 메커니즘

- PAWS는 앞에서 설명한 RTTM 메커니즘과 동일한 TCP 타임스탬프 옵션을 사용하며, 수신된 모든 TCP 세그먼트\(데이터 및 ACK 세그먼트 포함\)에 값이 시간에 따라 감소하지 않는 단조로운 타임스탬프 SEG.TSval이 포함되어 있다고 가정합니다. 기본 아이디어는 이 연결에서 최근에 수신된 일부 타임스탬프보다 작은 타임스탬프 SEG.TSval로 수신된 세그먼트가 이전 복제본으로 폐기될 수 있다는 것입니다.

```text
      In both the PAWS and the RTTM mechanism, the "timestamps" are 32-
```

- 모듈식 32비트 공간의 비트 부호 없는 정수입니다. 따라서 "미만"은 TCP 시퀀스 번호와 동일한 방식으로 정의되며 동일한 구현 기술이 적용됩니다. s 및 t가 타임스탬프 값인 경우 0 < \(t - s\) < 2\*\*31인 경우 s < t이며 부호 없는 32비트 산술 연산으로 계산됩니다.

- 이 비교를 위해 저장할 수신 타임스탬프의 선택은 단조롭게 증가하는 값을 보장해야 합니다. 예를 들어, 수신 창의 왼쪽 가장자리를 마지막으로 진행한 세그먼트, 즉 가장 최근의 순서대로 세그먼트에서 타임스탬프를 저장할 수 있습니다. 대신 PAWS와 RTTM 모두에 공통 값을 사용하면 둘 다의 구현이 단순화되므로 RTTM 메커니즘에 대해 섹션 3.4에 소개된 TS.Recent 값을 선택합니다. 섹션 3.4에서 설명했듯이 TS.Recent는 지연된 ACK의 경우에만 마지막 순서 세그먼트의 타임스탬프와 다르므로 창 수가 1개 미만입니다. 따라서 어느 쪽을 선택하든 시퀀스 번호 순환을 방지할 수 있습니다.

RTTM은 대칭 방식으로 지정되었으므로 TSval

- 타임스탬프는 데이터와 ACK 세그먼트 모두에 전달되며 반환 ACK 또는 데이터 세그먼트에 전달되는 TSecr 필드에 반영됩니다. PAWS는 들어오는 모든 세그먼트를 동일한 테스트에 제출하므로 중복된 ACK 세그먼트와 데이터 세그먼트로부터 보호합니다. \(대체 비대칭 알고리즘은 오래된 중복 ACK로부터 보호합니다. 데이터 송신자는 ACK 필드가 전송 창의 왼쪽 가장자리로 진행된 마지막 세그먼트에서 저장된 TSecr보다 TSecr 값이 작은 수신 ACK 세그먼트를 거부합니다. 이 알고리즘 메커니즘의 경제성과 대칭성이 부족한 것으로 간주되었습니다.\)

- {SYN} 및 {SYN,ACK} 세그먼트에 전송된 TSval 타임스탬프는 PAWS를 초기화하는 데 사용됩니다. PAWS는 오래된 중복된 비SYN 세그먼트와 동기화된 연결이 있는 동안 수신된 중복된 SYN 세그먼트로부터 보호합니다. 연결이 없을 때 수신된 중복된 {SYN} 및 {SYN,ACK} 세그먼트는 일반적인 3방향 핸드셰이크 및 TCP의 시퀀스 번호 확인에 의해 삭제됩니다.

- RST 세그먼트에는 타임스탬프가 포함되지 않으며 RST 세그먼트는 타임스탬프에 관계없이 허용되는 것이 좋습니다. 오래된 중복 RST 세그먼트는 거의 발생하지 않으며 해당 정리 기능은 타임스탬프보다 우선해야 합니다.

```text
      4.2.1  Basic PAWS Algorithm
```

- PAWS 알고리즘은 동기화된 연결을 위해 들어오는 모든 세그먼트에 대해 다음 처리를 수행해야 합니다.

- R1\) 도착 세그먼트에 타임스탬프 옵션이 있고 SEG.TSval < TS.Recent가 있고 TS.Recent가 유효한 경우\(나중에 설명 참조\) 도착 세그먼트를 허용되지 않는 것으로 처리합니다.

- RFC-793 페이지 69에 지정된 대로 응답으로 승인을 보내고 세그먼트를 삭제합니다.

- 참고: 반개방 연결을 감지하고 복구하기 위한 TCP 메커니즘을 유지하려면 ACK 세그먼트를 보내야 합니다. 예를 들어 RFC-793의 그림 10을 참조하세요.

```text
         R2)  If the segment is outside the window, reject it (normal
              TCP processing)
```

- R3\) 도착 세그먼트가 SEG.SEQ <= Last.ACK.sent\(섹션 3.4 참조\)를 만족하는 경우 TS.Recent에 해당 타임스탬프를 기록합니다.

- R4\) 도착하는 세그먼트가 순서대로\(즉, 왼쪽 창 가장자리에\) 있는 경우 정상적으로 수락합니다.

- R5\) 그렇지 않으면 세그먼트를 일반 창 내, 순서 외 TCP 세그먼트로 처리합니다\(예: 나중에 사용자에게 전달하기 위해 대기열에 넣습니다\).

- R2, R4, R5 단계는 RFC-793에 지정된 일반적인 TCP 처리 단계입니다.

- 타임스탬프는 세그먼트가 순서대로인지 또는 나중에 전달하기 위해 대기열에 있어야 하는지에 관계없이 세그먼트가 수신기에 처음 도착할 때만 확인된다는 점에 유의하는 것이 중요합니다. 다음 예를 고려하십시오.

- 세그먼트 시퀀스 A.1, B.1, C.1, ..., Z.1이 전송되었다고 가정합니다. 여기서 문자는 시퀀스 번호를 나타내고 숫자는 타임스탬프를 나타냅니다. 또한 세그먼트 B.1이 손실되었다고 가정합니다. TS.TStamp의 타임스탬프는 1\(A.1에서\)이므로 C.1, ..., Z.1은 허용되는 것으로 간주되어 대기됩니다. B가 세그먼트 B.2\(최신 타임스탬프 사용\)로 재전송되면 공백이 채워지고 Z를 통한 모든 세그먼트가 승인되어 사용자에게 전달됩니다. 대기열에 있는 세그먼트의 타임스탬프는 이미 승인되었기 때문에 이번에는 다시 검사되지 \*않습니다\*. B.2가 승인되면 TS.Stamp가 2로 설정됩니다.

- 이 규칙은 손실 시 합리적인 성능을 허용합니다. 전체

- 데이터 창은 항상 전송 중이며, 손실 후에는 전체 창에서 하나 미만의 패킷이 순서 없이 표시되어 수신기에서 대기열에 추가됩니다\(예: 최대 2\*\*30바이트의 데이터\). 타임스탬프 옵션으로 인해 이 데이터가 삭제되어서는 안 됩니다.

- 가능성이 희박한 특정 상황에서는 R1-R4 규칙의 알고리즘으로 인해 다음 예와 같이 일부 세그먼트가 불필요하게 삭제될 수 있습니다.

- 세그먼트 A.1, B.1, C.1, ..., Z.1이 순서대로 전송되었고 세그먼트 B.1이 손실되었다고 다시 가정합니다. 더욱이, 재전송 B.2가 수신기에 도착할 때까지 C.1, ... Z.1 중 일부의 전달이 지연된다고 가정합니다. 이러한 지연된 세그먼트는 타임스탬프가 이제 오래되었기 때문에 도착 시 불필요하게 삭제됩니다.

- 이런 경우는 거의 발생하지 않습니다. 시간 초과로 인해 재전송이 트리거된 경우 세그먼트 C.1, ... Z.1 중 일부가 RTO 시간보다 오래 지연되었을 것입니다. 이는 가능성이 희박한 이벤트일 가능성이 높으며, 그렇지 않으면 허위 시간 초과 및 재전송이 많이 발생할 수 있습니다. B의 재전송이 "빠른 재전송" 알고리즘, 즉 중복 ACK에 의해 트리거된 경우 이러한 ACK를 발생시킨 대기열 세그먼트가 이미 수신되었을 것입니다.

세그먼트가 RTO를 초과하여 지연되더라도 Fast

- 재전송 메커니즘 \[Jacobson90c\]은 지연된 패킷이 B.2와 동시에 재전송되도록 하여 추가 RTT를 방지하므로 성능 저하가 매우 적습니다.

- 타임스탬프가 세그먼트를 불필요하게 폐기하여 성능 저하를 일으키는 발생 가능성이 큰 경우는 없는 것으로 알려져 있습니다.

```text
      4.2.2  Timestamp Clock
```

- PAWS 알고리즘에는 송신자와 수신자 간의 클럭 동기화가 필요하지 않다는 점을 이해하는 것이 중요합니다. 보낸 사람의 타임스탬프 시계는 세그먼트를 스탬프하는 데 사용되며 보낸 사람은 에코된 타임스탬프를 사용하여 RTT를 측정합니다. 그러나 수신기는 시계에 연결할 필요 없이 타임스탬프를 단순히 단조롭게 증가하는 일련 번호로 처리합니다. 수신자의 관점에서 타임스탬프는 시퀀스 번호의 상위 비트에 대한 논리적 확장 역할을 합니다.

- 수신기 알고리즘은 타임스탬프 클록의 주파수에 대한 몇 가지 요구 사항을 지정합니다.

- \(a\) 타임스탬프 시계는 "너무 느려"서는 안 됩니다.

- 전송된 각 2\*\*31바이트에 대해 적어도 한 번씩 선택해야 합니다. 실제로 발신자에게 왕복 타이밍을 유용하게 사용하려면 시계가 창 분량의 데이터당 적어도 한 번씩 작동해야 하며, RFC-1072 창 확장을 사용하더라도 2\*\*31바이트는 최소한 두 개의 창이어야 합니다. .

```text
              To make this more quantitative, any clock faster than 1
              tick/sec will reject old duplicate segments for link
              speeds of ~8 Gbps.  A 1ms timestamp clock will work at
              link speeds up to 8 Tbps (8*10**12) bps!
```

- \(b\) 타임스탬프 시계는 "너무 빠르지" 않아야 합니다.

- 재활용 시간은 MSL 초보다 커야 합니다. 클록\(타임스탬프\)은 32비트이고 최악의 MSL은 255초이므로 허용 가능한 최대 클록 주파수는 59ns마다 1틱입니다.

- 그러나 유휴 연결에서 오래된 타임스탬프를 처리하고\(섹션 4.2.3 참조\) 시퀀스 번호 순환을 방지하기 위한 MSL 요구 사항을 완화하려면 훨씬 더 긴 재활용 기간을 설정하는 것이 바람직합니다. 1ms 타임스탬프 시계를 사용하면 32비트 타임스탬프는 24.8일 만에 부호 비트를 래핑합니다. 따라서 MSL이 24.8일 이하인 경우 동일한 연결에서 이전 중복을 거부합니다. 이는 매우 안전한 수치로 보입니다. 24.8일 이상의 MSL은 IP 계층의 TTL 값에 의한 정확한 MSL 적용을 요구하지 않고도 게이트웨이 시스템에서 가정될 수 있습니다.

- 이러한 고려 사항을 바탕으로 틱당 1ms\~1초 범위의 타임스탬프 클럭 주파수를 선택합니다. 이 범위는 또한 재전송 타이머의 세분성\(예: 수십 또는 수백 밀리초\)보다 더 많은 해상도가 필요하지 않은 RTTM 메커니즘의 요구 사항과 일치합니다.

- PAWS 메커니즘은 또한 보낸 사람의 타임스탬프 시계에 강력한 단조성 요구 사항을 적용합니다. 이 요구 사항을 충족하기 위한 타임스탬프 클럭 구현 방법은 시스템 하드웨어 및 소프트웨어에 따라 다릅니다.

- \* 일부 호스트에는 하드웨어 재설정 간에 단조로움이 보장되는 하드웨어 시계가 있습니다.

- \* 클록 인터럽트는 이진수를 주기적으로 1씩 증가시키는 데 사용될 수 있습니다.

- \* 타임스탬프 클럭은 가변 오프셋 값을 추가하여 갑자기 변경될 수 있는 시스템 클럭에서 파생될 수 있습니다. 이 오프셋은 0으로 초기화됩니다. 새로운 타임스탬프 클럭 값이 필요한 경우 필요에 따라 오프셋을 조정하여 새 값을 이전 값\(이 목적으로 저장된\)과 같거나 크게 만들 수 있습니다.

```text
      4.2.3  Outdated Timestamps
```

- 다른 TCP의 타임스탬프 시계가 해당 부호 비트를 래핑할 때까지 연결이 충분히 오랫동안 유휴 상태로 유지되면 TS.Recent에 저장된 값이 너무 오래된 값이 됩니다. 결과적으로 PAWS 메커니즘은 모든 후속 세그먼트를 거부하게 하여 연결을 정지시킵니다\(타임스탬프 시계가 부호 비트를 다시 래핑할 때까지\).

- 선택한 타임스탬프 클럭 주파수 범위\(1초 \~ 1ms\)를 사용하면 부호 비트를 래핑하는 시간은 24.8일에서 24800일 사이가 됩니다. 24일 이상 유휴 상태였다가 다시 활성화되는 TCP 연결은 매우 이례적입니다. 그러나 원칙적으로 TCP 연결 수명에 제한을 두는 것은 바람직하지 않습니다.

- 따라서 PAWS 구현에는 연결이 24일 이상 유휴 상태일 때 TS.Recent 값을 "무효화"하는 메커니즘이 포함되어야 합니다. \(오래된 타임스탬프 문제에 대한 대안적인 해결책은 연결 유지 세그먼트를 매우 낮은 속도로 보내는 것이지만 타임스탬프의 랩 어라운드 시간보다 더 자주\(예: 하루에 한 번\) 전송하는 것입니다. 이는 무시할 만한 오버헤드를 부과합니다. 그러나 TCP 사양에는 연결 유지가 포함된 적이 없으므로 무효화에 기반한 솔루션이 선택되었습니다.\)

- TCP는 다른 TCP의 빈도와 순환 시간을 알지 못하므로 최악의 상황을 가정해야 합니다. TS.Recent의 유효성은 기본 PAWS 타임스탬프 확인이 실패한 경우, 즉 SEG.TSval < TS.Recent인 경우에만 확인해야 합니다. TS.Recent가 유효하지 않은 것으로 확인되면 타임스탬프 확인 실패에 관계없이 세그먼트가 허용되고 규칙 R3는 새 세그먼트의 TSval로 TS.Recent를 업데이트합니다.

- 연결이 유휴 상태인 기간을 감지하기 위해 TCP는 다음을 수행할 수 있습니다.

관련된 시계 또는 타임스탬프 값을 업데이트합니다.

- 예를 들어 TS.Recent가 업데이트될 때마다 연결됩니다. 세부 사항은 구현에 따라 다릅니다.

```text
      4.2.4  Header Prediction

         "Header prediction" [Jacobson90a] is a high-performance
         transport protocol implementation technique that is most
         important for high-speed links.  This technique optimizes the
         code for the most common case, receiving a segment correctly
         and in order.  Using header prediction, the receiver asks the
         question, "Is this segment the next in sequence?"  This
         question can be answered in fewer machine instructions than the
         question, "Is this segment within the window?"
```

- 타임스탬프 절차에 헤더 예측을 추가하면 도착하는 TCP 세그먼트를 처리하기 위해 다음과 같은 권장 순서가 발생합니다.

```text
         H1)  Check timestamp (same as step R1 above)
```

- H2\) 헤더 예측 수행: 세그먼트가 순서대로 다음이고 추가 처리가 필요한 특별한 조건이 없으면 세그먼트를 승인하고 해당 타임스탬프를 기록하고 H3을 건너뜁니다.

- H3\) RFC-793에 명시된 대로 세그먼트를 정상적으로 처리합니다. 여기에는 창 외부에 있는 세그먼트를 삭제하고 승인을 보낼 수 있으며 창 내에서 순서를 벗어난 세그먼트를 대기열에 추가하는 것이 포함됩니다.

- 또 다른 가능성은 H1 단계와 H2 단계를 교환하는 것입니다. 즉, 헤더 예측 단계 H2를 FIRST로 수행하고 헤더 예측이 실패하는 경우에만 H1과 H3을 수행하는 것입니다. H1 단계의 타임스탬프 확인은 실패할 가능성이 매우 낮고 상대적으로 비용이 많이 드는 작업인 유한 필드에 대한 간격 산술이 필요하므로 성능이 향상될 수 있습니다. 모든 단일 세그먼트에 대해 이 검사를 수행하는 것은 헤더 예측 철학에 위배됩니다. 우리는 이러한 변화로 인해 고속 네트워크에서 TCP 프로토콜 처리를 위한 CPU 시간이 최대 5\~10%까지 줄어들 수 있다고 믿습니다.

- 그러나 H2를 먼저 배치하면 위험이 발생합니다. 과거 2\*\*32바이트의 세그먼트가 정확히 잘못된 시간에 도착하여 헤더 예측 단계에서 실수로 받아들여질 수 있습니다. 이 실패 확률이 무시할 수 있음을 보여주기 위해 다음 추론이 도입되었습니다 \[Jacobson90b\].

- 모든 세그먼트가 이전 중복으로 나타날 확률이 동일하다면 왼쪽 창 가장자리와 정확히 일치하는 이전 중복이 발생할 확률은 최대 세그먼트 크기\(MSS\)를 시퀀스 공간의 크기로 나눈 값입니다. MSS는 < 2\*\*16이어야 하므로 이 비율은 2\*\*-16보다 작아야 합니다. 예를 들어 FDDI 링크의 경우 \(2\*\*12\)/\(2\*\*32\) = 2\*\*-20이 됩니다. 그러나 세그먼트가 오래될수록 인터넷에 유지될 가능성이 낮아지고 세그먼트 수명에 대한 합리적인 모델에서 정확히 왼쪽 창 가장자리에 오래된 복제본이 있을 확률은 2\*\*-16보다 훨씬 작아야 합니다. .

- 16비트 TCP 체크섬은 2\*\*16의 한 부분에 대한 기본적인 비신뢰성을 허용합니다. 신뢰성이 TCP 체크섬의 신뢰성을 초과하는 프로토콜 메커니즘은 "충분히 좋은" 것으로 간주되어야 합니다. 즉, 전체 오류율에 크게 기여하지 않습니다. 따라서 우리는 타임스탬프를 확인하기 전에 헤더 예측을 수행하여 오래된 중복이 허용되는 문제를 무시할 수 있다고 믿습니다.

- 그러나 이러한 확률론적 주장은 보편적으로 받아들여지지 않으며, 일반적인 경우 성능 향상이 위험을 정당화하지 못한다는 것이 현재 합의된 의견입니다. 따라서 H2가 H1 뒤에 오는 것이 좋습니다.

4.3. 이전 연결 화신의 중복

- PAWS 메커니즘은 고속 연결 시 시퀀스 번호 순환으로 인한 오류를 방지합니다. 동일한 연결의 이전 구현에서 나온 세그먼트도 오래된 중복 오류의 잠재적인 원인입니다. 두 경우 모두 이러한 오류를 방지하는 TCP 메커니즘은 IP\(인터넷\) 계층에 의한 MSL\(최대 세그먼트 수명\) 적용에 따라 달라집니다\(자세한 설명은 RFC-1185의 부록 참조\). 시퀀스 공간 랩 어라운드의 경우와 달리 이전 구현의 오래된 중복 오류를 방지하는 데 필요한 MSL은 전송 속도에 의존하지 않습니다. IP 계층이 TCP의 권장 2분 MSL을 적용하고 TCP 규칙을 따르면 네트워크 속도가 아무리 빠르더라도 TCP 연결은 이전 구현으로부터 안전합니다. 따라서 이 경우에는 PAWS 메커니즘이 필요하지 않습니다.

- PAWS 메커니즘이 이전 연결의 오래된 중복에 대해 추가 보안을 제공하여 IP 계층에 의한 MSL 적용을 완화할 수 있는지 여부에 대해 여전히 질문할 수 있습니다. 부록 B에서는 이 질문을 탐구하여 PAWS를 넘어서는 추가 가정 및/또는 메커니즘이 필요함을 보여줍니다. 이는 현재 확장의 일부가 아닙니다.

---
## **5.  CONCLUSIONS AND ACKNOWLEDGMENTS**

이 메모는 광대역\*지연 제품 경로에 대한 효율적인 작동과 초고속 경로에 대한 안정적인 작동을 제공하기 위해 TCP에 대한 일련의 확장을 제시했습니다. 이러한 확장은 확장을 구현하지 않는 TCP와의 호환 가능한 상호 작용을 제공하도록 설계되었습니다.

이러한 메커니즘은 확장된 창 및 타임스탬프에 대한 새로운 TCP 옵션을 사용하여 구현됩니다. 타임스탬프는 RTTM\(Round Trip Time Measurement\) 및 PAWS\(Protect Against Wrapped Sequences\)라는 두 가지 메커니즘에 사용됩니다.

Window Scale 옵션은 원래 USAF/DCA의 Mike St. Johns가 제안한 것입니다. 옵션의 현재 형태는 Van Jacobson이 정의한 보다 번거로운 계획에 대한 응답으로 UC Berkeley의 Mike Karels가 제안했습니다. Lixia Zhang은 RFC-1185에서 PAWS 메커니즘 설명을 공식화하는 데 도움을 주었습니다.

마지막으로, 이 작업의 대부분은 일반적인 전송 프로토콜과 특히 TCP의 이론적 한계에 대한 엔드투엔드 태스크 포스 내 논의의 결과로 시작되었습니다. 최근에는 태스크포스 구성원과 end2end-interest 목록에 있는 다른 사람들이 알고리즘과 문서의 결함을 지적함으로써 귀중한 기여를 했습니다. 저자는 이러한 모든 기여에 감사드립니다.

---
## **6.  REFERENCES**

- \[Clark87\] Clark, D., Lambert, M. 및 L. Zhang, "NETBLT: 대량 데이터 전송 프로토콜", RFC 998, MIT, 1987년 3월.

- \[Garlick77\] Garlick, L., R. Rom 및 J. Postel, "신뢰할 수 있는 호스트 간 프로토콜의 문제", Proc. 분산 데이터 관리 및 컴퓨터 네트워크에 관한 두 번째 버클리 워크숍, 1977년 5월.

```text
      [Hamming77]  Hamming, R., "Digital Filters", ISBN 0-13-212571-4,
      Prentice Hall, Englewood Cliffs, N.J., 1977.

      [Cheriton88]  Cheriton, D., "VMTP: Versatile Message Transaction
      Protocol", RFC 1045, Stanford University, February 1988.
```

- \[Jacobson88a\] Jacobson, V., "혼잡 방지 및 제어", SIGCOMM '88, Stanford, CA., 1988년 8월.

- \[Jacobson88b\] Jacobson, V. 및 R. Braden, "장기 지연 경로를 위한 TCP 확장", RFC-1072, LBL 및 USC/정보 과학 연구소, 1988년 10월.

```text
      [Jacobson90a]  Jacobson, V., "4BSD Header Prediction", ACM
      Computer Communication Review, April 1990.
```

- \[Jacobson90b\] Jacobson, V., Braden, R. 및 Zhang, L., "고속 경로를 위한 TCP 확장", RFC-1185, LBL 및 USC/정보 과학 연구소, 1990년 10월.

- \[Jacobson90c\] Jacobson, V., "수정된 TCP 혼잡 회피 알고리즘", end2end-interest 메일링 리스트에 보내는 메시지, 1990년 4월.

- \[Jain86\] Jain, R., "패킷 재전송을 위한 시간 제한 알고리즘의 차이", Proc. 다섯 번째 피닉스 컨퍼런스 Comp에. 및 Comm., 애리조나주 스코츠데일, 1986년 3월.

- \[Karn87\] Karn, P. 및 C. Partridge, "신뢰할 수 있는 전송 프로토콜에서 왕복 시간 추정", Proc. SIGCOMM '87, 버몬트주 스토우, 1987년 8월.

- \[McKenzie89\] McKenzie, A., "TCP Big Window 옵션의 문제", RFC 1110, BBN STC, 1989년 8월.

\[Nagle84\] Nagle, J., "IP/TCP의 혼잡 제어

- Internetworks", RFC 896, FACC, 1984년 1월.

- \[NBS85\] Colella, R., Aronoff, R., K. Mills, "ISO 전송 성능 개선", 제9차 데이터 통신 심포지엄, ACM SIGCOMM Comp Comm Review, vol. 15, 아니. 1985년 9월 5일.

```text
      [Postel81]  Postel, J., "Transmission Control Protocol - DARPA
      Internet Program Protocol Specification", RFC 793, DARPA,
      September 1981.
```

- \[Velten84\] Velten, D., Hinden, R. 및 J. Sax, "신뢰할 수 있는 데이터 프로토콜", RFC 908, BBN, 1984년 7월.

- \[Watson81\] Watson, R., "신뢰할 수 있는 전송 프로토콜 연결 관리의 타이머 기반 메커니즘", 컴퓨터 네트워크, Vol. 1981년 5월 5일.

```text
      [Zhang86]  Zhang, L., "Why TCP Timers Don't Work Well", Proc.
      SIGCOMM '86, Stowe, Vt., August 1986.
```

---
# **APPENDIX A:  IMPLEMENTATION SUGGESTIONS**

32비트 및 64비트 시스템의 실행 가능한 최대 정렬을 달성하기 위해 비SYN 세그먼트에서 옵션을 보내는 데 다음 레이아웃이 권장됩니다.

```text
       +--------+--------+--------+--------+
       |   NOP  |  NOP   |  TSopt |   10   |
       +--------+--------+--------+--------+
       |          TSval   timestamp        |
       +--------+--------+--------+--------+
       |          TSecr   timestamp        |
       +--------+--------+--------+--------+
```

---
# **APPENDIX B: DUPLICATES FROM EARLIER CONNECTION INCARNATIONS**

고려해야 할 두 가지 경우가 있습니다. \(1\) 시스템 충돌\(및 연결 상태 손실\) 및 다시 시작, \(2\) 호스트 상태 손실 없이 동일한 연결이 닫혔다가 다시 열리는 경우입니다. 이에 대해서는 다음 두 섹션에서 설명합니다.

B.1 상태 손실로 인한 시스템 충돌

- 시스템 시작 시 하나의 MSL의 TCP 조용한 시간은 시스템 충돌/다시 시작 시 연결 상태 손실을 처리합니다. 설명은 TCP 프로토콜 사양 \[Postel81\]의 "When to Keep Quiet"을 참조하세요. 여기에 필요한 MSL은 전송 속도에 의존하지 않습니다. 많은 호스트 시스템이 충돌 후 부팅하는 데 이만큼 오랜 시간이 걸리기 때문에 현재 2분의 TCP MSL은 운영상의 타협으로 받아들일 수 있는 것 같습니다.

그러나 MSL을 완화하기 위해 타임스탬프 옵션을 사용할 수 있습니다.

- 요구사항\(또는 데이터 손상에 대한 추가 보안 제공\) 타임스탬프가 사용되고 있고 시스템 충돌/재시작 시 타임스탬프 시계가 단조롭다는 것을 보장할 수 있는 경우, 즉 충돌/재시작 후 보낸 사람의 타임스탬프 시계의 첫 번째 값이 이전 마지막 값보다 크다고 보장할 수 있는 경우 다시 시작하면 조용한 시간이 필요하지 않습니다.

- 조용한 시간을 완전히 없애려면 호스트 시계가 충돌/재시작 기간 동안 안정적인 시간 소스에 동기화되어야 하며 정확도는 1타임스탬프 시계 틱 이상이어야 합니다. 대략적인 클럭 동기화를 활용하기 위해 이 엄격한 요구 사항에서 벗어날 수 있습니다. 시계가 N 타임스탬프 시계 내에서 항상 재동기화된다고 가정합니다.

- 틱 및 해당 부팅\(필요한 경우 조용한 시간으로 연장\)에는 N 틱 이상이 소요됩니다. 이는 타임스탬프의 단조성을 보장하며, 이는 강제 MSL 없이도 오래된 중복을 거부하는 데 사용될 수 있습니다.

B.2 연결 닫기 및 다시 열기

- TCP 연결이 닫히면 TIME-WAIT 상태에서 2\*MSL의 지연이 4분 동안 소켓 쌍을 묶습니다\(\[Postel81\]의 섹션 3.5 참조\). 하나의 연결을 닫고 새 연결을 여는 TCP 기반 애플리케이션\( 예를 들어 스트림 모드를 사용하는 FTP 데이터 전송 연결\)은 매번 새로운 소켓 쌍을 선택해야 합니다. TIME-WAIT 지연은 두 가지 다른 목적으로 사용됩니다.

- \(a\) TCP의 전이중 신뢰성 있는 클로즈 핸드셰이크를 구현합니다.

- 최종 마감 단계를 지연하는 적절한 시간은 실제로 MSL과 관련이 없습니다. 대신 FIN 세그먼트의 RTO에 따라 달라지므로 경로의 RTT에 따라 달라집니다. \(FIN을 보내는 쪽은 필요한 신뢰성 수준을 알고 있으므로 FIN 수신자의 TIME-WAIT 지연 길이를 결정할 수 있어야 한다고 주장할 수 있습니다. 이는 적절한 TCP를 사용하여 수행할 수 있습니다. FIN 세그먼트의 옵션입니다.\)

- RTT에 공식적인 상한선은 없지만 일반적인 네트워크 엔지니어링 관행으로 인해 RTT가 1분을 초과할 가능성은 거의 없습니다. 따라서 TIME-WAIT 상태의 4분 지연은 안정적인 전이중 TCP 닫기를 제공하기 위해 만족스럽게 작동합니다. 이는 MSL 적용 및 네트워크 속도와 무관하다는 점을 다시 한 번 참고하세요.

- TIME-WAIT 상태는 호스트에서 사용 가능한 TCP 포트 수가 2\*\*16보다 적기 때문에 애플리케이션이 매우 높은 빈도로 한 연결을 반복적으로 닫고 다른 연결을 열어야 하는 경우 간접적인 성능 문제를 일으킬 수 있습니다. 그러나 높은 네트워크 속도가 이 문제의 주요 원인은 아닙니다. RTT는 연결을 열고 닫는 속도를 제한하는 요소입니다. 따라서 이 문제는 높은 전송 속도에서도 악화되지 않습니다.

- \(b\) 오래된 중복 세그먼트가 만료되도록 허용합니다.

```text
           To replace this function of TIME-WAIT state, a mechanism
           would have to operate across connections.  PAWS is defined
           strictly within a single connection; the last timestamp is
           TS.Recent is kept in the connection control block, and
```

- 연결이 닫히면 삭제됩니다.

- 모든 연결에서 수신된 마지막 타임스탬프의 호스트별 캐시인 추가 메커니즘을 TCP에 추가할 수 있습니다. 그런 다음 이 값은 PAWS 메커니즘에서 사용되어 이전 연결이 열린 이후 타임스탬프 시계가 적어도 한 번 똑딱거렸다고 보장할 수 있는 경우 연결의 이전 구현에서 오래된 중복 세그먼트를 거부할 수 있습니다. 이를 위해서는 TIME-WAIT 지연과 RTT의 합이 최소한 발신자의 타임스탬프 시계 1틱 이상이어야 합니다. 이러한 확장은 이 RFC 제안의 일부가 아닙니다.

- 이는 Garlick, Rom 및 Postel \[Garlick77\]이 제안한 메커니즘의 변형이며, 각 호스트는 모든 연결에서 가장 높은 시퀀스 번호를 포함하는 연결 레코드를 유지해야 합니다. 대신 타임스탬프를 사용하면 해당 호스트에 대한 동시 연결 수에 관계없이 원격 호스트당 하나의 수량만 유지하면 됩니다.

---
# **APPENDIX C: CHANGES FROM RFC-1072, RFC-1185**

이 문서에 정의된 프로토콜 확장은 RFC-1072 및 RFC-1185에 정의된 것과 몇 가지 중요한 측면에서 다릅니다.

\(a\) SACK은 나중 메모로 연기되었습니다.

\(b\) 타임스탬프 응답\(섹션 3.4 참조\)을 보내는 세부 규칙은 중요한 면에서 다릅니다. 이전 규칙으로 인해 특정 경우\(패킷이 삭제되거나 순서가 잘못된 경우\) RTT가 과소평가될 수 있습니다.

\(c\) 동일한 값 TS.Recent는 이제 RTTM 및 PAWS의 두 가지 메커니즘에 의해 공유됩니다. 이러한 단순화는 \(b\)의 변화로 인해 가능해졌습니다.

\(d\) RFC-1185의 모호성은 ACK와 데이터 세그먼트에 타임스탬프를 추가하는 방향으로 해결되었습니다. 이는 기본 TCP 프로토콜의 대칭성을 지원합니다.

\(e\) 대칭성을 반영하고 처리를 단순화하기 위해 RFC-1072의 에코 및 에코 응답 옵션이 단일 타임스탬프 옵션으로 결합되었습니다.

\(f\) 섹션 4.2.2에서 논의된 장기 유휴 연결의 오래된 타임스탬프 문제가 실현되고 해결되었습니다.

\(g\) RFC-1185는 헤더 예측이 타임스탬프 확인보다 우선하도록 권장했습니다. 섹션 4.2.4에 제시된 확률론적 주장에 대한 일부 회의론을 바탕으로 타임스탬프 확인을 먼저 수행하도록 권장하기로 결정했습니다.

\(h\) 확장 옵션이 해당 <SYN\> 세그먼트에 수신된 경우에만 <SYN,ACK\> 세그먼트로 전송되도록 사양이 수정되었습니다. 이는 확장 없이 구현과의 상호 운용을 위한 가장 보수적인 가능한 조건을 제공합니다.

이러한 실질적인 변경 외에도 현재 RFC는 RFC-793의 이벤트 처리 규칙에 대한 수정 사항을 제시하여 알고리즘을 명확하게 지정하려고 시도합니다. 부록 E를 참조하세요.

---
# **APPENDIX D: SUMMARY OF NOTATION**

이 문서에서는 다음 표기법이 사용되었습니다.

```text
   Options

       WSopt:       TCP Window Scale Option
       TSopt:       TCP Timestamps Option

   Option Fields
```

Shift.cnt: WSopt의 창 크기 바이트입니다.

- TSval: TSopt의 32비트 타임스탬프 값 필드입니다. TSecr: TSopt의 32비트 타임스탬프 응답 필드입니다.

현재 세그먼트의 옵션 필드

```text
       SEG.TSval:   TSval field from TSopt in current segment.
       SEG.TSecr:   TSecr field from TSopt in current segment.
       SEG.WSopt:   8-bit value in WSopt

   Clock Values
```

my.TSclock: 32비트 타임스탬프 값의 로컬 소스

- my.TSclock.rate: my.TSclock의 주기\(1ms \~ 1초\).

```text
   Per-Connection State Variables

       TS.Recent:       Latest received Timestamp
       Last.ACK.sent:   Last ACK field sent

       Snd.TS.OK:       1-bit flag
       Snd.WS.OK:       1-bit flag

       Rcv.Wind.Scale:  Receive window scale power
       Snd.Wind.Scale:  Send window scale power
```

---
# **APPENDIX E: EVENT PROCESSING**
---
# **Event Processing**

```text
  OPEN Call
```

... 초기 전송 시퀀스 번호\(ISS\)가 선택되었습니다. 다음 형식의 SYN 세그먼트를 보냅니다.

```text
        <SEQ=ISS><CTL=SYN><TSval=my.TSclock><WSopt=Rcv.Wind.Scale>

      ...

  SEND Call

    CLOSED STATE (i.e., TCB does not exist)

      ...

    LISTEN STATE

      If the foreign socket is specified, then change the connection
      from passive to active, select an ISS.  Send a SYN segment
      containing the options: <TSval=my.TSclock> and
      <WSopt=Rcv.Wind.Scale>.  Set SND.UNA to ISS, SND.NXT to ISS+1.
      Enter SYN-SENT state. ...

    SYN-SENT STATE
    SYN-RECEIVED STATE

      ...

    ESTABLISHED STATE
    CLOSE-WAIT STATE

      Segmentize the buffer and send it with a piggybacked
      acknowledgment (acknowledgment value = RCV.NXT).  ...

      If the urgent flag is set ...
```

- Snd.TS.OK 플래그가 설정된 경우 각 데이터 세그먼트에 TCP 타임스탬프 옵션 <TSval=my.TSclock,TSecr=TS.Recent\>를 포함합니다.

- 세그먼트 헤더에서 전송을 위해 수신 창 크기를 조정합니다.

```text
            SEG.WND = (SND.WND >> Rcv.Wind.Scale).

  SEGMENT ARRIVES

     ...

    If the state is LISTEN then
```

- 먼저 RST 확인

```text
        ...
```

- ACK에 대한 두 번째 확인

```text
        ...
```

- SYN에 대한 세 번째 확인

```text
        if the SYN bit is set, check the security.  If the ...

         ...
```

- SEG.PRC가 TCB.PRC보다 작으면 계속합니다.

- 창 크기 조정 옵션\(WSopt\)을 확인하세요. 발견된 경우 Snd.Wind.Scale에 SEG.WSopt를 저장하고 Snd.WS.OK 플래그를 설정합니다. 그렇지 않으면 Snd.Wind.Scale과 Rcv.Wind.Scale을 모두 0으로 설정하고 Snd.WS.OK 플래그를 지웁니다.

- TSopt 옵션을 확인하세요. 발견되면 SEG.TSval을 TS.Recent 변수에 저장하고 Snd.TS.OK 비트를 켭니다.

- RCV.NXT를 SEG.SEQ+1로 설정하고, IRS는 SEG.SEQ로 설정하고 다른 컨트롤이나 텍스트는 나중에 처리하기 위해 대기해야 합니다. ISS를 선택하고 다음 형식의 SYN 세그먼트를 전송해야 합니다.

```text
          <SEQ=ISS><ACK=RCV.NXT><CTL=SYN,ACK>
```

Snd.WS.OK 비트가 켜져 있으면 WSopt 옵션을 포함하세요.

- 이 세그먼트의 <WSopt=Rcv.Wind.Scale\>입니다. Snd.TS.OK 비트가 켜져 있으면 이 세그먼트에 TSopt <TSval=my.TSclock,TSecr=TS.Recent\>를 포함합니다. Last.ACK.sent는 RCV.NXT로 설정됩니다.

- SND.NXT는 ISS+1로, SND.UNA는 ISS로 설정됩니다. 연결 상태를 SYN-RECEIVED로 변경해야 합니다. 들어오는 다른 제어 또는 데이터\(SYN과 결합\)는 SYN-RECEIVED 상태에서 처리되지만 SYN 및 ACK 처리는 반복되어서는 안 됩니다. 청취가 완전히 지정되지 않은 경우\(즉, 외부 소켓이 완전히 지정되지 않은 경우\) 지정되지 않은 필드를 지금 채워야 합니다.

- 네 번째 다른 텍스트 또는 컨트롤

```text
       ...

    If the state is SYN-SENT then
```

- 먼저 ACK 비트를 확인합니다.

```text
        ...
```

- 네 번째 SYN 비트 확인

```text
         ...
```

- SYN 비트가 켜져 있고 보안/구획 및 우선 순위가 허용 가능한 경우 RCV.NXT는 SEG.SEQ+1로 설정되고 IRS는 SEG.SEQ로 설정되며 이에 따라 확인되는 재전송 큐의 모든 확인은 다음과 같습니다. 제거됩니다.

- 창 크기 조정 옵션\(WSopt\)을 확인하세요. 발견되면 Snd.Wind.Scale에 SEG.WSopt를 저장합니다. 그렇지 않으면 Snd.Wind.Scale과 Rcv.Wind.Scale을 모두 0으로 설정합니다.

- TSopt 옵션을 확인하세요. 발견되면 SEG.TSval을 TS.Recent 변수에 저장하고 연결 제어 블록에서 Snd.TS.OK 비트를 켭니다. ACK 비트가 설정된 경우 my.TSclock - SEG.TSecr를 초기 RTT 추정치로 사용합니다.

- SND.UNA \> ISS\(SYN이 ACK됨\)인 경우 연결 상태를 ESTABLISHED로 변경하고 ACK 세그먼트를 형성합니다.

```text
            <SEQ=SND.NXT><ACK=RCV.NXT><CTL=ACK>
```

- 그리고 보내세요. Snd.Echo.OK 비트가 켜져 있으면 이 ACK 세그먼트에 TSopt 옵션 <TSval=my.TSclock,TSecr=TS.Recent\>를 포함합니다. Last.ACK.sent는 RCV.NXT로 설정됩니다.

- 전송 대기 중인 데이터나 컨트롤이 포함될 수 있습니다. 세그먼트에 다른 컨트롤이나 텍스트가 있는 경우 URG 비트가 확인되는 아래 6단계에서 처리를 계속하고, 그렇지 않으면 반환합니다.

- 그렇지 않으면 SYN-RECEIVED를 입력하고 SYN,ACK 세그먼트를 구성합니다.

```text
            <SEQ=ISS><ACK=RCV.NXT><CTL=SYN,ACK>

        and send it.  If the Snd.Echo.OK bit is on, include a TSopt
        option <TSval=my.TSclock,TSecr=TS.Recent> in this segment.  If
```

Snd.WS.OK 비트가 켜져 있고 WSopt 옵션을 포함합니다.

- 이 세그먼트의 <WSopt=Rcv.Wind.Scale\>입니다. Last.ACK.sent는 RCV.NXT로 설정됩니다.

- 세그먼트에 다른 컨트롤이나 텍스트가 있는 경우 ESTABLISHED 상태에 도달한 후 처리를 위해 대기열에 넣고 반환합니다.

- 다섯째, SYN 또는 RST 비트가 모두 설정되지 않은 경우 세그먼트를 삭제하고 반환합니다.

```text
    Otherwise,

    First, check sequence number

      SYN-RECEIVED STATE
      ESTABLISHED STATE
      FIN-WAIT-1 STATE
      FIN-WAIT-2 STATE
      CLOSE-WAIT STATE
      CLOSING STATE
      LAST-ACK STATE
      TIME-WAIT STATE
```

- 세그먼트는 순서대로 처리됩니다. 도착 시 초기 테스트는 이전 중복을 폐기하는 데 사용되지만 추가 처리는 SEG.SEQ 순서로 수행됩니다. 세그먼트의 내용이 이전 부분과 새 부분 사이의 경계에 걸쳐 있는 경우 새 부분만 처리해야 합니다.

- 수신된 창 필드의 크기를 조정합니다.

```text
            TrueWindow = SEG.WND << Snd.Wind.Scale,
```

- 다음 단계에서는 SEG.WND 대신 "TrueWindow"를 사용합니다.

- 세그먼트에 타임스탬프 옵션이 포함되어 있고 Snd.TS.OK 비트가 켜져 있는지 확인하세요. 그렇다면:

- SEG.TSval < TS.Recent인 경우 연결이 24일 미만 유휴 상태인지 테스트합니다. 둘 다 참이면 해당 세그먼트는 허용되지 않습니다. 허용되지 않는 세그먼트에 대해서는 아래 단계를 따르세요.

- SEG.SEQ가 Last.ACK.sent와 같으면 SEG.ECopt를 변수 TS.Recent에 저장합니다.

- 들어오는 세그먼트에 대한 적합성 테스트에는 네 가지 경우가 있습니다.

```text
          ...
```

- 들어오는 세그먼트가 허용되지 않는 경우 승인을 응답으로 보내야 합니다\(RST 비트가 설정되지 않은 경우 세그먼트를 삭제하고 반환\).

```text
          <SEQ=SND.NXT><ACK=RCV.NXT><CTL=ACK>
```

- Last.ACK.sent는 승인의 SEG.ACK로 설정됩니다. Snd.Echo.OK 비트가 켜져 있으면 이 ACK 세그먼트에 타임스탬프 옵션 <TSval=my.TSclock,TSecr=TS.Recent\>를 포함합니다. Last.ACK.sent를 SEG.ACK로 설정하고 ACK 세그먼트를 보냅니다. 승인을 보낸 후 허용되지 않는 세그먼트를 삭제하고 반환합니다.

```text
          ...
```

다섯 번째로 ACK 필드를 확인하세요.

- ACK 비트가 꺼져 있으면 세그먼트를 삭제하고 반환합니다.

- ACK 비트가 켜져 있는 경우

```text
        ...

        ESTABLISHED STATE

          If SND.UNA < SEG.ACK =< SND.NXT then, set SND.UNA <- SEG.ACK.
          Also compute a new estimate of round-trip time.  If Snd.TS.OK
          bit is on, use my.TSclock - SEG.TSecr; otherwise use the
          elapsed time since the first segment in the retransmission
          queue was sent.  Any segments on the retransmission queue
          which are thereby entirely acknowledged...

            ...
```

일곱째, 세그먼트 텍스트를 처리한다.

```text
      ESTABLISHED STATE
      FIN-WAIT-1 STATE
      FIN-WAIT-2 STATE

          ...
```

- 다음 양식에 대한 승인을 보냅니다.

```text
          <SEQ=SND.NXT><ACK=RCV.NXT><CTL=ACK>
```

Snd.TS.OK 비트가 켜져 있으면 타임스탬프 옵션을 포함합니다.

- 이 ACK 세그먼트의 <TSval=my.TSclock,TSecr=TS.Recent\>. Last.ACK.sent를 승인의 SEG.ACK로 설정하여 보냅니다. 이 승인은 가능하면 과도한 지연을 초래하지 않고 전송되는 세그먼트에 피기백되어야 합니다.

```text
         ...
```

---
# **Security Considerations**

보안 문제는 이 메모에서 논의되지 않습니다.

---
# **Authors' Addresses**

Van Jacobson 캘리포니아 대학교 로렌스 버클리 연구소 메일 중지 46A Berkeley, CA 94720

```text
   Phone: (415) 486-6411
   EMail: van@CSAM.LBL.GOV
```

Bob Braden University of Southern California 정보 과학 연구소 4676 Admiralty Way Marina del Rey, CA 90292

```text
   Phone: (310) 822-1511
   EMail: Braden@ISI.EDU

   Dave Borman
   Cray Research
   655-E Lone Oak Drive
   Eagan, MN 55121

   Phone: (612) 683-5571
   Email: dab@cray.com
```
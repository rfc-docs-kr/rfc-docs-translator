

```text
Internet Engineering Task Force (IETF)                  K. Moriarty, Ed.
Request for Comments: 8017                               EMC Corporation
Obsoletes: 3447                                               B. Kaliski
Category: Informational                                         Verisign
ISSN: 2070-1721                                               J. Jonsson
                                                               Subset AB
                                                                A. Rusch
                                                                     RSA
                                                           November 2016

          PKCS #1: RSA Cryptography Specifications Version 2.2
```

---
# **Abstract**

이 문서는 암호화 기본 요소, 암호화 체계, 부록이 포함된 서명 체계, 키 표시 및 체계 식별을 위한 ASN.1 구문을 다루는 RSA 알고리즘을 기반으로 하는 공개 키 암호화 구현에 대한 권장 사항을 제공합니다.

이 문서는 RSA Laboratories의 PKCS\(공개 키 암호화 표준\) 시리즈에서 PKCS #1 v2.2를 다시 발행한 것입니다. 이 RFC를 게시하면 변경 제어가 IETF로 이전됩니다.

이 문서는 또한 RFC 3447을 폐기합니다.

---
# **Status of This Memo**

이 문서는 인터넷 표준 트랙 사양이 아닙니다. 정보 제공의 목적으로 게시됩니다.

이 문서는 IETF\(Internet Engineering Task Force\)의 산물입니다. 이는 IETF 커뮤니티의 합의를 나타냅니다. 공개 검토를 받았으며 IESG\(Internet Engineering Steering Group\)의 게시 승인을 받았습니다. IESG가 승인한 모든 문서가 모든 수준의 인터넷 표준에 적합한 것은 아닙니다. RFC 7841의 섹션 2를 참조하세요.

이 문서의 현재 상태, 정오표, 피드백 제공 방법에 대한 정보는 http://www.rfc-editor.org/info/rfc8017에서 얻을 수 있습니다.

---
# **Copyright Notice**

Copyright \(c\) 2016 IETF Trust 및 문서 작성자로 식별된 사람. 판권 소유.

이 문서는 이 문서 발행일에 유효한 BCP 78 및 IETF 문서와 관련된 IETF Trust의 법적 조항\(http://trustee.ietf.org/license-info\)의 적용을 받습니다. 이 문서에 관한 귀하의 권리와 제한 사항이 설명되어 있으므로 이 문서를 주의 깊게 검토하십시오. 이 문서에서 추출된 코드 구성 요소는 신뢰 법률 조항의 섹션 4.e에 설명된 대로 단순화된 BSD 라이센스 텍스트를 포함해야 하며 단순화된 BSD 라이센스에 설명된 대로 보증 없이 제공됩니다.

---
# **Table of Contents**

```text
   1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   4
     1.1.  Requirements Language . . . . . . . . . . . . . . . . . .   5
   2.  Notation  . . . . . . . . . . . . . . . . . . . . . . . . . .   6
   3.  Key Types . . . . . . . . . . . . . . . . . . . . . . . . . .   8
     3.1.  RSA Public Key  . . . . . . . . . . . . . . . . . . . . .   8
     3.2.  RSA Private Key . . . . . . . . . . . . . . . . . . . . .   9
   4.  Data Conversion Primitives  . . . . . . . . . . . . . . . . .  11
     4.1.  I2OSP . . . . . . . . . . . . . . . . . . . . . . . . . .  11
     4.2.  OS2IP . . . . . . . . . . . . . . . . . . . . . . . . . .  12
   5.  Cryptographic Primitives  . . . . . . . . . . . . . . . . . .  12
     5.1.  Encryption and Decryption Primitives  . . . . . . . . . .  12
       5.1.1.  RSAEP . . . . . . . . . . . . . . . . . . . . . . . .  13
       5.1.2.  RSADP . . . . . . . . . . . . . . . . . . . . . . . .  13
     5.2.  Signature and Verification Primitives . . . . . . . . . .  15
       5.2.1.  RSASP1  . . . . . . . . . . . . . . . . . . . . . . .  15
       5.2.2.  RSAVP1  . . . . . . . . . . . . . . . . . . . . . . .  16
   6.  Overview of Schemes . . . . . . . . . . . . . . . . . . . . .  17
   7.  Encryption Schemes  . . . . . . . . . . . . . . . . . . . . .  18
     7.1.  RSAES-OAEP  . . . . . . . . . . . . . . . . . . . . . . .  19
       7.1.1.  Encryption Operation  . . . . . . . . . . . . . . . .  22
       7.1.2.  Decryption Operation  . . . . . . . . . . . . . . . .  25
     7.2.  RSAES-PKCS1-v1_5  . . . . . . . . . . . . . . . . . . . .  27
       7.2.1.  Encryption Operation  . . . . . . . . . . . . . . . .  28
       7.2.2.  Decryption Operation  . . . . . . . . . . . . . . . .  29
   8.  Signature Scheme with Appendix  . . . . . . . . . . . . . . .  31
     8.1.  RSASSA-PSS  . . . . . . . . . . . . . . . . . . . . . . .  32
       8.1.1.  Signature Generation Operation  . . . . . . . . . . .  33
       8.1.2.  Signature Verification Operation  . . . . . . . . . .  34
     8.2.  RSASSA-PKCS1-v1_5 . . . . . . . . . . . . . . . . . . . .  35
       8.2.1.  Signature Generation Operation  . . . . . . . . . . .  36
       8.2.2.  Signature Verification Operation  . . . . . . . . . .  37
   9.  Encoding Methods for Signatures with Appendix . . . . . . . .  39
     9.1.  EMSA-PSS  . . . . . . . . . . . . . . . . . . . . . . . .  40
       9.1.1.  Encoding Operation  . . . . . . . . . . . . . . . . .  42
       9.1.2.  Verification Operation  . . . . . . . . . . . . . . .  44
     9.2.  EMSA-PKCS1-v1_5 . . . . . . . . . . . . . . . . . . . . .  45
   10. Security Considerations . . . . . . . . . . . . . . . . . . .  47
   11. References  . . . . . . . . . . . . . . . . . . . . . . . . .  48
     11.1.  Normative References . . . . . . . . . . . . . . . . . .  48
     11.2.  Informative References . . . . . . . . . . . . . . . . .  48
   Appendix A.  ASN.1 Syntax . . . . . . . . . . . . . . . . . . . .  54
     A.1.  RSA Key Representation  . . . . . . . . . . . . . . . . .  54
       A.1.1.  RSA Public Key Syntax . . . . . . . . . . . . . . . .  54
       A.1.2.  RSA Private Key Syntax  . . . . . . . . . . . . . . .  55
     A.2.  Scheme Identification . . . . . . . . . . . . . . . . . .  57
       A.2.1.  RSAES-OAEP  . . . . . . . . . . . . . . . . . . . . .  57
       A.2.2.  RSAES-PKCS-v1_5 . . . . . . . . . . . . . . . . . . .  60
       A.2.3.  RSASSA-PSS  . . . . . . . . . . . . . . . . . . . . .  60
       A.2.4.  RSASSA-PKCS-v1_5  . . . . . . . . . . . . . . . . . .  62
   Appendix B.  Supporting Techniques  . . . . . . . . . . . . . . .  63
     B.1.  Hash Functions  . . . . . . . . . . . . . . . . . . . . .  63
     B.2.  Mask Generation Functions . . . . . . . . . . . . . . . .  66
       B.2.1.  MGF1  . . . . . . . . . . . . . . . . . . . . . . . .  67
   Appendix C.  ASN.1 Module . . . . . . . . . . . . . . . . . . . .  68
   Appendix D.  Revision History of PKCS #1  . . . . . . . . . . . .  76
   Appendix E.  About PKCS . . . . . . . . . . . . . . . . . . . . .  77
   Acknowledgements  . . . . . . . . . . . . . . . . . . . . . . . .  78
   Authors' Addresses  . . . . . . . . . . . . . . . . . . . . . . .  78
```

---
## **1.  Introduction**

이 문서는 다음 측면을 다루는 RSA 알고리즘\[RSA\]을 기반으로 하는 공개 키 암호화 구현에 대한 권장 사항을 제공합니다.

```text
   o  Cryptographic primitives

   o  Encryption schemes
```

- 부록이 포함된 서명 구성표

- 키를 표현하고 체계를 식별하기 위한 ASN.1 구문

권장 사항은 컴퓨터 및 통신 시스템 내의 일반적인 적용을 위한 것이므로 상당한 유연성을 포함합니다. 이러한 사양을 기반으로 한 응용 표준에는 추가적인 제약 사항이 포함될 것으로 예상됩니다. 권장 사항은 IEEE 1363 \[IEEE1363\], IEEE 1363a \[IEEE1363A\] 및 ANSI X9.44 \[ANSIX944\] 표준과 호환되도록 작성되었습니다.

이 문서는 PKCS #1 버전 2.1 \[RFC3447\]을 대체하지만 호환 가능한 기술을 포함합니다.

이 문서의 구성은 다음과 같습니다.

- 1절은 소개입니다.

- 섹션 2에서는 이 문서에 사용된 일부 표기법을 정의합니다.

- 섹션 3에서는 RSA 공개 및 개인 키 유형을 정의합니다.

- 섹션 4와 5에서는 여러 기본 요소 또는 기본 수학 연산을 정의합니다. 데이터 변환 기본 요소는 섹션 4에 있고 암호화 기본 요소\(암호화-복호화 및 서명-검증\)는 섹션 5에 있습니다.

- 섹션 6, 7, 8에서는 이 문서의 암호화 및 서명 체계를 다룹니다. 섹션 6에서는 개요를 제공합니다. PKCS #1 v1.5에 있는 방법들과 함께 7장에서는 OAEP\(Optimal Asymmetric Encryption Padding\) \[OAEP\] 기반의 암호화 방식을 정의하고, 8장에서는 PSS\(Probabilistic Signature Scheme\) 기반의 부록이 포함된 서명 방식을 정의합니다. \[르사라빈\] \[PSS\].

- 9절에서는 8절의 서명 체계에 대한 인코딩 방법을 정의합니다.

- 부록 A는 섹션 3에 정의된 키에 대한 ASN.1 구문과 섹션 7 및 8의 구성표를 정의합니다.

- 부록 B에서는 해당 기술에 대한 ASN.1 구문을 포함하여 본 문서에서 사용되는 해시 함수 및 마스크 생성 함수\(MGF\)를 정의합니다.

- 부록 C에는 ASN.1 모듈이 나와 있습니다.

- 부록 D와 E는 PKCS #1의 개정 내역을 간략하게 설명하고 공개 키 암호화 표준에 대한 일반 정보를 제공합니다.

이 문서는 RSA Laboratories의 PKCS\(공개 키 암호화 표준\) 시리즈에서 나온 PKCS #1 v2.2 \[PKCS1\_22\]의 재출판물을 나타냅니다.

---
### **1.1.  Requirements Language**

이 문서의 핵심 단어 "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY" 및 "OPTIONAL"은 다음과 같습니다. \[RFC2119\]에 설명된 대로 해석됩니다.

---
## **2.  Notation**

이 문서의 표기법에는 다음이 포함됩니다.

```text
      c              ciphertext representative, an integer between 0 and
                     n-1

      C              ciphertext, an octet string

      d              RSA private exponent

      d_i            additional factor r_i's CRT exponent,
                     a positive integer such that

                       e * d_i == 1 (mod (r_i-1)), i = 3, ..., u

      dP             p's CRT exponent, a positive integer such that

                       e * dP == 1 (mod (p-1))

      dQ             q's CRT exponent, a positive integer such that

                       e * dQ == 1 (mod (q-1))

      e              RSA public exponent

      EM             encoded message, an octet string

      emBits         (intended) length in bits of an encoded message EM

      emLen          (intended) length in octets of an encoded message
                     EM
```

- GCD\(. , .\) 음이 아닌 두 정수의 최대 공약수

```text
      Hash           hash function

      hLen           output length in octets of hash function Hash

      k              length in octets of the RSA modulus n

      K              RSA private key

      L              optional RSAES-OAEP label, an octet string

      LCM(., ..., .) least common multiple of a list of nonnegative
                     integers

      m              message representative, an integer between 0 and
                     n-1

      M              message, an octet string

      mask           MGF output, an octet string

      maskLen        (intended) length of the octet string mask

      MGF            mask generation function

      mgfSeed        seed from which mask is generated, an octet string

      mLen           length in octets of a message M

      n              RSA modulus, n = r_1 * r_2 * ... * r_u , u >= 2

      (n, e)         RSA public key

      p, q           first two prime factors of the RSA modulus n

      qInv           CRT coefficient, a positive integer less than
                     p such that q * qInv == 1 (mod p)

      r_i            prime factors of the RSA modulus n, including
                     r_1 = p, r_2 = q, and additional factors if any

      s              signature representative, an integer between 0 and
                     n-1

      S              signature, an octet string

      sLen           length in octets of the EMSA-PSS salt

      t_i            additional prime factor r_i's CRT coefficient, a
                     positive integer less than r_i such that

                       r_1 * r_2 * ... * r_(i-1) * t_i == 1 (mod r_i) ,

                     i = 3, ... , u

      u              number of prime factors of the RSA modulus, u >= 2

      x              a nonnegative integer

      X              an octet string corresponding to x

      xLen           (intended) length of the octet string X

      0x             indicator of hexadecimal representation of an octet
                     or an octet string: "0x48" denotes the octet with
                     hexadecimal value 48; "(0x)48 09 0e" denotes the
                     string of three consecutive octets with hexadecimal
                     values 48, 09, and 0e, respectively

      \lambda(n)     LCM(r_1-1, r_2-1, ... , r_u-1)

      \xor           bit-wise exclusive-or of two octet strings

      \ceil(.)       ceiling function; \ceil(x) is the smallest integer
                     larger than or equal to the real number x

      ||             concatenation operator

      ==             congruence symbol; a == b (mod n) means that the
                     integer n divides the integer a - b
```

참고: 중국 나머지 정리\(CRT\)는 비재귀적 방식뿐만 아니라 재귀적 방식으로도 적용될 수 있습니다. 이 문서에서는 Garner의 알고리즘 \[GARNER\]을 따르는 재귀적 접근 방식이 사용됩니다. 섹션 3.2의 참고 1도 참조하세요.

---
## **3.  Key Types**

이 문서에 정의된 기본 요소와 체계에는 RSA 공개 키와 RSA 개인 키라는 두 가지 키 유형이 사용됩니다. RSA 공개 키와 RSA 개인 키가 함께 RSA 키 쌍을 형성합니다.

이 사양은 계수가 2개 이상의 소인수를 가질 수 있는 소위 "다중 소수" RSA를 지원합니다. 다중 프라임 RSA의 이점은 CRT가 사용되는 경우 암호 해독 및 서명 프리미티브에 대한 계산 비용이 낮다는 것입니다. 단일 프로세서 플랫폼에서 더 나은 성능을 얻을 수 있지만, 관련된 모듈식 지수화가 병렬로 수행될 수 있는 다중 프로세서 플랫폼에서 더 나은 성능을 얻을 수 있습니다.

다중 소수가 RSA 암호 시스템의 보안에 어떤 영향을 미치는지에 대한 논의는 \[SILVERMAN\]을 참조하세요.

---
### **3.1.  RSA Public Key**

이 문서의 목적에 따라 RSA 공개 키는 두 가지 구성 요소로 구성됩니다.

```text
         n        the RSA modulus, a positive integer
         e        the RSA public exponent, a positive integer
```

유효한 RSA 공개 키에서 RSA 모듈러스 n은 u개의 고유한 홀수 소수 r\_i, i = 1, 2, ..., u의 곱입니다. 여기서 u \>= 2이고 RSA 공개 지수 e는 3 사이의 정수입니다. n - 1은 GCD\(e,\lambda\(n\)\) = 1을 만족하며, 여기서 \lambda\(n\) = LCM\(r\_1 - 1, ..., r\_u - 1\)입니다. 관례적으로, 처음 두 소수 r\_1과 r\_2는 각각 p와 q로 표시될 수도 있습니다.

구현 간 RSA 공개 키 교환에 권장되는 구문은 부록 A.1.1에 나와 있습니다. 구현의 내부 표현은 다를 수 있습니다.

---
### **3.2.  RSA Private Key**

이 문서의 목적에 따라 RSA 개인 키는 두 가지 표현 중 하나를 가질 수 있습니다.

1. 첫 번째 표현은 \(n, d\) 쌍으로 구성되며, 여기서 구성 요소는 다음과 같은 의미를 갖습니다.

```text
            n       the RSA modulus, a positive integer
            d       the RSA private exponent, a positive integer
```

1. 두 번째 표현은 5중\(p, q, dP, dQ, qInv\)과 3중\(r\_i, d\_i, t\_i\)의 \(아마도 비어 있는\) 시퀀스, i = 3, ..., u로 구성됩니다\(각각 하나씩\). 소수는 5중이 아닙니다. 여기서 구성 요소는 다음과 같은 의미를 갖습니다.

```text
            p      the first factor, a positive integer
            q      the second factor, a positive integer
            dP     the first factor's CRT exponent, a positive integer
            dQ     the second factor's CRT exponent, a positive integer
            qInv   the (first) CRT coefficient, a positive integer
            r_i    the i-th factor, a positive integer
            d_i    the i-th factor's CRT exponent, a positive integer
            t_i    the i-th factor's CRT coefficient, a positive integer
```

첫 번째 표현이 포함된 유효한 RSA 개인 키에서 RSA 모듈러스 n은 해당 RSA 공개 키와 동일하며 u개의 고유한 홀수 소수 r\_i, i = 1, 2, ..., u의 곱입니다. 여기서 u \>= 2. RSA 비공개 지수 d는 다음을 만족하는 n보다 작은 양의 정수입니다.

```text
      e * d == 1 (mod \lambda(n)),
```

여기서 e는 해당 RSA 공개 지수이고 \lambda\(n\)은 섹션 3.1에서와 같이 정의됩니다.

두 번째 표현을 사용하는 유효한 RSA 개인 키에서 두 요소 p와 q는 RSA 모듈러스 n의 처음 두 주요 요소\(즉, r\_1 및 r\_2\)입니다. CRT 지수 dP 및 dQ는 각각 p 및 q보다 작은 양의 정수입니다.

```text
      e * dP == 1 (mod (p-1))

      e * dQ == 1 (mod (q-1)) ,
```

CRT 계수 qInv는 다음을 만족하는 p보다 작은 양의 정수입니다.

```text
      q * qInv == 1 (mod p).
```

u \> 2인 경우 표현에는 하나 이상의 삼중항\(r\_i, d\_i, t\_i\), i = 3, ..., u가 포함됩니다. r\_i 인자는 RSA 모듈러스 n의 추가 소인수입니다. 각 CRT 지수 d\_i \(i = 3, ..., u\)는 다음을 충족합니다.

```text
      e * d_i == 1 (mod (r_i - 1)).
```

각 CRT 계수 t\_i\(i = 3, ..., u\)는 다음을 만족하는 r\_i보다 작은 양의 정수입니다.

```text
      R_i * t_i == 1 (mod r_i) ,
```

여기서 R\_i = r\_1 \* r\_2 \* ... \* r\_\(i-1\)입니다.

두 표현의 구성 요소를 모두 포함하는 구현 간에 RSA 개인 키를 교환하기 위한 권장 구문은 부록 A.1.2에 나와 있습니다. 구현의 내부 표현은 다를 수 있습니다.

```text
   Notes:
```

1. 여기서 CRT 계수의 정의와 섹션 5의 프리미티브에서 이를 사용하는 공식은 일반적으로 Garner의 알고리즘 \[GARNER\]을 따릅니다\(\[HANDBOOK\]의 알고리즘 14.71 참조\). 그러나 PKCS #1 v2.0 및 이전 버전의 RSA 개인 키 표현과의 호환성을 위해 p 및 q의 역할은 나머지 소수와 반대입니다. 따라서 첫 번째 CRT 계수 qInv는 R\_1 mod r\_2의 역, 즉 p mod q가 아니라 q mod p의 역으로 ​​정의됩니다.

1. Quisquater와 Couvreur \[FASTDEC\]는 CRT를 RSA 작업에 적용할 때의 이점을 관찰했습니다.

---
## **4.  Data Conversion Primitives**

이 문서에 정의된 체계에는 두 가지 데이터 변환 기본 요소가 사용됩니다.

```text
   o  I2OSP - Integer-to-Octet-String primitive

   o  OS2IP - Octet-String-to-Integer primitive
```

이 문서의 목적과 ASN.1 구문에 따라 옥텟 문자열은 순서가 지정된 옥텟\(8비트 바이트\) 시퀀스입니다. 시퀀스는 처음\(일반적으로 가장 왼쪽\)부터 마지막\(가장 오른쪽\)까지 인덱싱됩니다. 정수와의 변환을 위해 첫 번째 옥텟은 다음 변환 프리미티브에서 가장 중요한 것으로 간주됩니다.

---
### **4.1.  I2OSP**

I2OSP는 음이 아닌 정수를 지정된 길이의 옥텟 문자열로 변환합니다.

```text
   I2OSP (x, xLen)

   Input:

      x        nonnegative integer to be converted

      xLen     intended length of the resulting octet string

   Output:
```

- 길이가 xLen인 X 해당 옥텟 문자열

```text
   Error:  "integer too large"

   Steps:
```

1. x \>= 256^xLen인 경우 "정수가 너무 큼"을 출력하고 중지합니다.

```text
      2.  Write the integer x in its unique xLen-digit representation in
          base 256:

             x = x_(xLen-1) 256^(xLen-1) + x_(xLen-2) 256^(xLen-2) + ...
             + x_1 256 + x_0,

          where 0 <= x_i < 256 (note that one or more leading digits
          will be zero if x is less than 256^(xLen-1)).

      3.  Let the octet X_i have the integer value x_(xLen-i) for 1 <= i
          <= xLen.  Output the octet string

             X = X_1 X_2 ... X_xLen.
```

---
### **4.2.  OS2IP**

OS2IP는 옥텟 문자열을 음수가 아닌 정수로 변환합니다.

```text
   OS2IP (X)
```

입력: 변환할 X 옥텟 문자열

```text
   Output:  x corresponding nonnegative integer

   Steps:

      1.  Let X_1 X_2 ... X_xLen be the octets of X from first to last,
          and let x_(xLen-i) be the integer value of the octet X_i for 1
          <= i <= xLen.

      2.  Let x = x_(xLen-1) 256^(xLen-1) + x_(xLen-2) 256^(xLen-2) +
          ...  + x_1 256 + x_0.

      3.  Output x.
```

---
## **5.  Cryptographic Primitives**

암호화 프리미티브는 암호화 체계를 구축할 수 있는 기본적인 수학 연산입니다. 이는 하드웨어 또는 소프트웨어 모듈로 구현하기 위한 것이며 체계와 별개로 보안을 제공하기 위한 것이 아닙니다.

이 문서에는 네 가지 유형의 기본 요소가 쌍으로 구성되어 지정됩니다. 암호화 및 암호 해독; 서명 및 확인.

기본 요소의 사양에서는 입력이 특정 조건, 특히 RSA 공개 키와 개인 키가 유효하다고 가정합니다.

---
### **5.1.  Encryption and Decryption Primitives**

암호화 프리미티브는 공개 키의 제어하에 메시지 표현으로부터 암호문 표현을 생성하고, 복호화 프리미티브는 해당 개인 키의 제어하에 암호문 표현으로부터 메시지 표현을 복구합니다.

한 쌍의 암호화 및 암호 해독 기본 요소는 이 문서에 정의된 암호화 체계에 사용되며 RSAEP\(RSA Encryption Primitive\) / RSADP\(RSA Decryption Primitive\)에 지정되어 있습니다. RSAEP와 RSADP는 입력 키가 서로 다르지만 동일한 수학 연산을 사용합니다. 여기에 정의된 프리미티브는 IEEE 1363 \[IEEE1363\]의 RSA를 사용한 정수 분해 암호화 프리미티브\(IFEP-RSA\) / RSA를 사용한 정수 분해 복호화 프리미티브\(IFDP-RSA\)와 동일합니다\(멀티 프라임 RSA에 대한 지원이 추가된 점 제외\). PKCS #1 v1.5와 호환됩니다.

각 프리미티브의 주요 수학 연산은 지수입니다.

---
#### **5.1.1.  RSAEP**

```text
   RSAEP ((n, e), m)

   Input:

         (n, e) RSA public key
```

- m 메시지 대표, 0과 n - 1 사이의 정수

출력: c 암호문 대표, 0과 n - 1 사이의 정수

오류: "메시지 대표자가 범위를 벗어났습니다."

가정: RSA 공개 키\(n, e\)가 유효합니다.

```text
   Steps:

      1.  If the message representative m is not between 0 and n - 1,
          output "message representative out of range" and stop.

      2.  Let c = m^e mod n.

      3.  Output c.
```

---
#### **5.1.2.  RSADP**

```text
   RSADP (K, c)

   Input:
```

- K RSA 개인 키. 여기서 K는 다음 형식 중 하나를 갖습니다.

- + 쌍 \(n, d\)

```text
         +  a quintuple (p, q, dP, dQ, qInv) and a possibly empty
            sequence of triplets (r_i, d_i, t_i), i = 3, ..., u
```

- c 암호문 대표, 0과 n - 1 사이의 정수

출력: m 메시지 대표, 0과 n - 1 사이의 정수

오류: "암호문 대표가 범위를 벗어났습니다."

가정: RSA 개인 키 K가 유효합니다.

```text
   Steps:

      1.  If the ciphertext representative c is not between 0 and n - 1,
          output "ciphertext representative out of range" and stop.
```

1. 메시지 대표 m은 다음과 같이 계산됩니다.

- ㅏ. K의 첫 번째 형태\(n, d\)가 사용되는 경우 m = c^d mod n으로 둡니다.

```text
          b.  If the second form (p, q, dP, dQ, qInv) and (r_i, d_i,
              t_i) of K is used, proceed as follows:
```

- 나. m\_1 = c^dP mod p 및 m\_2 = c^dQ mod q라고 합니다.

- ii. u \> 2이면 m\_i = c^\(d\_i\) mod r\_i, i = 3, ..., u로 둡니다.

```text
              iii. Let h = (m_1 - m_2) * qInv mod p.

              iv.  Let m = m_2 + q * h.

              v.   If u > 2, let R = r_1 and for i = 3 to u do

                   1.  Let R = R * r_(i-1).

                   2.  Let h = (m_i - m) * t_i mod r_i.

                   3.  Let m = m + R * h.

      3.  Output m.
```

참고: 2.b 단계는 p와 q의 순서가 반대인 경우 단일 루프로 다시 작성할 수 있습니다. 그러나 PKCS #1 v2.0과의 일관성을 위해 처음 두 소수 p와 q는 추가 소수와 별도로 처리됩니다.

---
### **5.2.  Signature and Verification Primitives**

서명 프리미티브는 개인키의 제어를 받는 메시지 표현으로부터 서명 표현을 생성하고, 검증 프리미티브는 해당 공개키의 제어를 받는 서명 표현으로부터 메시지 표현을 복구합니다. 한 쌍의 서명 및 확인 기본 요소는 이 문서에 정의된 서명 체계에 사용되며 RSA 서명 기본 버전 1\(RSASP1\)/RSA 확인 기본 버전 1\(RSAVP1\)에 지정되어 있습니다.

여기에 정의된 프리미티브는 IEEE 1363 \[IEEE1363\]의 RSA 버전 1\(IFSP-RSA1\)을 사용하는 Integer Factorization Signature Primitive / IFVP-RSA1\(Integer Factorization Verification Primitive using RSA, version 1\)과 동일합니다. 프라임 RSA가 추가됨\) PKCS #1 v1.5와 호환됩니다.

각 기본 요소의 주요 수학적 연산은 섹션 5.1의 암호화 및 암호 해독 기본 요소에서와 같이 지수화입니다. RSASP1 및 RSAVP1은 입력 및 출력 인수의 이름을 제외하고 RSADP 및 RSAEP와 동일합니다. 그것들은 서로 다른 목적으로 사용되기 때문에 구별됩니다.

---
#### **5.2.1.  RSASP1**

```text
   RSASP1 (K, m)

   Input:

      K        RSA private key, where K has one of the following forms:
               - a pair (n, d)
               - a quintuple (p, q, dP, dQ, qInv) and a (possibly empty)
                 sequence of triplets (r_i, d_i, t_i), i = 3, ..., u
      m        message representative, an integer between 0 and n - 1

   Output:

      s        signature representative, an integer between 0 and n - 1
```

오류: "메시지 대표자가 범위를 벗어났습니다."

가정: RSA 개인 키 K가 유효합니다.

```text
   Steps:

      1.  If the message representative m is not between 0 and n - 1,
          output "message representative out of range" and stop.
```

1. 서명 대표자 s는 다음과 같이 계산됩니다.

- ㅏ. K의 첫 번째 형식\(n, d\)이 사용되는 경우 s = m^d mod n으로 둡니다.

```text
          b.  If the second form (p, q, dP, dQ, qInv) and (r_i, d_i,
              t_i) of K is used, proceed as follows:
```

- 1. s\_1 = m^dP mod p 및 s\_2 = m^dQ mod q라고 가정합니다.

- 2. u \> 2이면 s\_i = m^\(d\_i\) mod r\_i, i = 3, ..., u로 둡니다.

```text
              3.  Let h = (s_1 - s_2) * qInv mod p.

              4.  Let s = s_2 + q * h.
```

- 5. u \> 2이면 R = r\_1로 하고 i = 3이면 u는 다음을 수행합니다.

```text
                  a.  Let R = R * r_(i-1).

                  b.  Let h = (s_i - s) * t_i mod r_i.

                  c.  Let s = s + R * h.

      3.  Output s.
```

참고: 2.b 단계는 p와 q의 순서가 반대인 경우 단일 루프로 다시 작성할 수 있습니다. 그러나 PKCS #1 v2.0과의 일관성을 위해 처음 두 소수 p와 q는 추가 소수와 별도로 처리됩니다.

---
#### **5.2.2.  RSAVP1**

```text
   RSAVP1 ((n, e), s)

   Input:

         (n, e) RSA public key
```

- s 서명 대표, 0과 n - 1 사이의 정수

```text
   Output:
```

- m 메시지 대표, 0과 n - 1 사이의 정수

오류: "서명 대표가 범위를 벗어났습니다."

가정: RSA 공개 키\(n, e\)가 유효합니다.

```text
   Steps:

      1.  If the signature representative s is not between 0 and n - 1,
          output "signature representative out of range" and stop.

      2.  Let m = s^e mod n.

      3.  Output m.
```

---
## **6.  Overview of Schemes**

체계는 특정 보안 목표를 달성하기 위해 암호화 기본 요소와 기타 기술을 결합합니다. 이 문서에는 암호화 체계와 부록이 포함된 서명 체계라는 두 가지 유형의 체계가 지정되어 있습니다.

이 문서에 지정된 체계는 해당 작업이 RSA 공개 또는 개인 키를 사용하여 데이터를 처리하는 단계로만 구성되고 키를 얻거나 검증하는 단계를 포함하지 않는다는 점에서 범위가 제한됩니다. 따라서 계획 운영 외에도 애플리케이션에는 일반적으로 당사자가 계획 운영을 ​​위해 RSA 공개 키와 개인 키를 선택할 수 있는 키 관리 작업이 포함됩니다. 특정 추가 작업 및 기타 세부 정보는 이 문서의 범위를 벗어납니다.

암호화 기본 요소\(섹션 5\)의 경우와 마찬가지로 체계 작업 사양에서는 입력이 특정 조건, 특히 RSA 공개 키와 개인 키가 유효하다고 가정합니다. 따라서 키가 유효하지 않은 경우 구현 동작이 지정되지 않습니다. 이러한 지정되지 않은 동작의 영향은 애플리케이션에 따라 다릅니다. 키 유효성 검사를 처리하는 가능한 방법에는 애플리케이션에 의한 명시적인 키 유효성 검사가 포함됩니다. 공개 키 인프라 내 키 검증 유효하지 않은 키로 수행된 작업에 대한 책임은 키를 생성한 당사자에게 할당됩니다.

일반적으로 좋은 암호화 방법은 주어진 RSA 키 쌍을 하나의 체계에서만 사용하는 것입니다. 이는 한 체계의 취약성이 다른 체계의 보안을 손상시킬 수 있고 입증 가능한 보안을 유지하는 데 필수적일 수 있는 위험을 방지합니다. RSAES-PKCS1-v1\_5 동안

\(섹션 7.2\) 및 RSASSA-PKCS1-v1\_5 \(섹션 8.2\)는 전통적으로 알려진 나쁜 상호 작용 없이 함께 사용되었습니다\(실제로 이는 PKCS #1 v1.5에서 도입된 모델입니다\). 이러한 RSA 키 쌍의 결합 사용은 새로운 애플리케이션에는 권장되지 않습니다.

둘 이상의 체계에서 RSA 키 쌍 사용과 관련된 위험을 설명하기 위해 RSAES-OAEP\(섹션 7.1\) 및 RSAES-PKCS1-v1\_5 모두에서 RSA 키 쌍이 사용된다고 가정합니다. RSAES-OAEP 자체는 공격에 저항하지만 상대방은 RSAES-PKCS1-v1\_5 구현의 약점을 악용하여 두 체계 중 하나로 암호화된 메시지를 복구할 수 있습니다. 또 다른 예로, RSA 키 쌍이 RSASSA-PSS\(섹션 8.1\)와 RSASSA-PKCS1-v1\_5 모두에 사용된다고 가정해 보겠습니다. 그러면 RSASSA-PSS에 대한 보안 증명은 두 번째 체계로 서명이 생성될 가능성을 고려하지 않기 때문에 더 이상 충분하지 않습니다. RSA 키 쌍이 여기에 정의된 체계 중 하나와 다른 곳에 정의된 변형에 사용되는 경우 유사한 고려 사항이 적용될 수 있습니다.

---
## **7.  Encryption Schemes**

이 문서의 목적에 따라 암호화 체계는 암호화 작업과 암호 해독 작업으로 구성됩니다. 여기서 암호화 작업은 수신자의 RSA 공개 키가 있는 메시지에서 암호문을 생성하고 암호 해독 작업은 수신자의 RSA 공개 키가 있는 암호문에서 메시지를 복구합니다. 해당 RSA 개인 키.

암호화 체계는 다양한 애플리케이션에 사용될 수 있습니다. 일반적인 애플리케이션은 키 설정 프로토콜로, 메시지에는 한 당사자에서 다른 당사자에게 기밀로 전달되는 키 자료가 포함되어 있습니다. 예를 들어, PKCS #7 \[RFC2315\]은 콘텐츠 암호화 키를 보낸 사람에게서 받는 사람에게 전달하기 위해 이러한 프로토콜을 사용합니다. 여기에 정의된 암호화 체계는 해당 맥락에서 적합한 키 암호화 알고리즘이 될 것입니다.

이 문서에는 RSAES-OAEP 및 RSAES-PKCS1-v1\_5라는 두 가지 암호화 체계가 지정되어 있습니다. RSAES-OAEP는 새로운 애플리케이션에 대한 지원이 필수입니다. RSAES-PKCS1-v1\_5는 기존 애플리케이션과의 호환성을 위해서만 포함됩니다.

여기에 제공된 암호화 체계는 암호화 및 암호 해독 기본 요소와 암호화를 위한 인코딩 방법을 결합하는 IEEE 1363 \[IEEE1363\]에 사용된 것과 유사한 일반 모델을 따릅니다. 암호화 작업은 메시지 인코딩 작업을 메시지에 적용하여 인코딩된 메시지를 생성한 다음 정수 메시지 표현으로 변환합니다. 암호문을 생성하기 위해 암호화 프리미티브가 메시지 표현에 적용됩니다. 이를 반대로 하면 암호 해독 작업은 암호 해독 기본 요소를

암호문을 사용하여 메시지 표현을 복구한 다음 옥텟 문자열로 인코딩된 메시지로 변환합니다. 메시지를 복구하고 암호 해독의 정확성을 확인하기 위해 메시지 디코딩 작업이 인코딩된 메시지에 적용됩니다.

디코딩 작업 내에서 오류가 처리되는 방식과 관련된 구현 약점을 피하기 위해\(\[BLEICHENBACHER\] 및 \[MANGER\] 참조\) RSAES-OAEP 및 RSAES-PKCS1-v1\_5에 대한 인코딩 및 디코딩 작업은 해당 암호화 사양에 포함됩니다. 별도의 사양으로 정의되지 않고 체계로 구성됩니다. 두 암호화 체계 모두 PKCS #1 v2.1의 해당 체계와 호환됩니다.

---
### **7.1.  RSAES-OAEP**

RSAES-OAEP는 RSAEP 및 RSADP 기본 요소\(섹션 5.1.1 및 5.1.2\)를 EME-OAEP 인코딩 방법\(섹션 7.1.1의 2단계 및 섹션 7.1.2의 3단계\)과 결합합니다. EME-OAEP는 Bellare와 Rogaway의 OAEP\(Optimal Asymmetric Encryption Scheme\)를 기반으로 합니다. IEEE 1363 \[IEEE1363\]에 정의된 IFES\(Integer Factorization Encryption Scheme\)와 호환됩니다. 여기서 암호화 및 복호화 기본 요소는 IFEP-RSA 및 IFDP-RSA이고 메시지 인코딩 방법은 EME-OAEP입니다. RSAES-OAEP는 최대 k - 2hLen -2 옥텟 길이의 메시지에 대해 작동할 수 있습니다. 여기서 hLen은 기본 해시 함수의 출력 길이이고 k는 수신자의 RSA 모듈러스 옥텟 길이입니다.

e-th 루트 모듈로 n을 계산하는 것이 불가능하고 RSAES-OAEP의 마스크 생성 기능이 적절한 속성을 가지고 있다고 가정하면 RSAES-OAEP는 적응형 선택 암호문 공격에 대해 의미론적으로 안전합니다. 이 보증은 마스크 생성 기능이 블랙박스 또는 랜덤 오라클로 간주되는 경우 RSAES-OAEP를 깨는 어려움이 RSA 기능 반전의 어려움과 직접적으로 관련될 수 있다는 점에서 입증 가능합니다. 자세한 내용은 \[FOPS\] 및 아래 참고 사항을 참조하세요.

RSAES-OAEP의 암호화 및 복호화 작업은 모두 레이블 L 값을 입력으로 사용합니다. 이 버전의 PKCS #1에서 L은 빈 문자열입니다. 라벨의 다른 용도는 이 문서의 범위를 벗어납니다. 관련 ASN.1 구문은 부록 A.2.1을 참조하세요.

RSAES-OAEP는 해시 함수와 마스크 생성 함수를 선택하여 매개변수화됩니다. 이 선택은 특정 RSA 키에 대해 수정되어야 합니다. 제안된 해시 및 마스크 생성 기능은 부록 B에 나와 있습니다.

참고: 과거 결과는 OAEP 인코딩 방법\[OAEP\]\(대략 섹션 7.1.1의 2단계에 설명된 절차\)의 보안 속성을 명확하게 설명하는 데 도움이 되었습니다. 배경은 다음과 같습니다. 1994년에 Bellare와 Rogaway \[OAEP\]는 일반 텍스트 인식\(PA94\)을 나타내는 보안 개념을 도입했습니다. 그들은 결정론적 공개 키 암호화 기본 요소\(예: RSAEP\)가 개인 키 없이 반전하기 어려운 경우 해당 OAEP 기반 암호화 체계는 일반 텍스트를 인식\(임의의 오라클 모델에서\)한다는 것을 증명했습니다. 기본 일반 텍스트를 실제로 "알지" 않고도 유효한 암호문을 생성합니다. 암호화 체계에 대한 일반 텍스트 인식은 선택된 암호문 공격에 대한 체계의 저항과 밀접한 관련이 있습니다. 이러한 공격에서는 공격자에게 암호 해독 기본 요소를 시뮬레이션하는 오라클에 쿼리를 보낼 수 있는 기회가 제공됩니다. 공격자는 이러한 쿼리 결과를 사용하여 챌린지 암호문의 암호를 해독하려고 시도합니다.

그러나 선택 암호문 공격에는 두 가지 유형이 있으며 PA94는 그 중 하나만에 대한 보안을 의미합니다. 차이점은 공격자가 챌린지 암호문을 받은 후 무엇을 할 수 있는지에 따라 달라집니다. 무관심 공격 시나리오\(CCA1로 표시\)는 적에게 도전 암호문을 제공한 후 복호화 오라클에 대한 어떠한 쿼리도 허용하지 않는 반면, 적응형 시나리오\(CCA2로 표시\)는 허용합니다\(단, 복호화 오라클은 도전 암호문이 일단 해독되는 것을 거부합니다\) 출판\). 1998년에 Bellare와 Rogaway는 Desai 및 Pointcheval \[PA98\]과 함께 CCA2에 대한 보안을 암시하는 일반 텍스트 인식\(PA98\)에 대한 새롭고 강력한 개념을 제시했습니다.

요약하면, PA94와 PA98이 동등한 개념이거나 CCA1과 CCA2가 동등한 개념이라는 두 가지 오해의 잠재적 원인이 있습니다. 어느 가정이든 Bellare-Rogaway 논문은 CCA2에 대한 OAEP의 보안을 암시한다는 결론으로 ​​이어지지만 그렇지 않습니다.

\(각주: PKCS #1 v2.0은 \[OAEP\]를 인용하고 일반 텍스트 인식 종류를 지정하지 않고 "선택한 암호 텍스트 공격은 RSAES-OAEP와 같은 일반 텍스트 인식 암호화 체계에 대해 효과적이지 않습니다"라고 주장한다고 언급하는 것이 공정할 수 있습니다. 또는 선택한 암호문 공격이 고려됩니다.\)

OAEP는 CCA2에 대해 안전한 것으로 입증된 적이 없습니다. 실제로 Victor Shoup \[SHOUP\]은 일반적인 경우에는 그러한 증거가 존재하지 않음을 입증했습니다. 간단히 말해서 Shoup는 암호화 기본 요소를 부분적으로 반전시키는 방법을 알고 있지만 완전히 반전시키는 방법을 모르는 CCA2 시나리오의 공격자가 체계를 깨뜨릴 수 있음을 보여주었습니다. 예를 들어 공격자가 RSAES-OAEP를 제외한 모든 것을 복구하는 방법을 안다면 RSAES-OAEP를 깨뜨릴 수 있다고 상상할 수 있습니다.

RSAEP로 암호화된 임의 정수의 처음 20바이트입니다. 이러한 공격자는 공격에서 처음 20옥텟을 사용하지 않기 때문에 RSAEP를 완전히 반전시킬 수 있을 필요는 없습니다.

그럼에도 불구하고 RSAES-OAEP는 Shoup의 결과 발표 직후 Fujisaki, Okamoto, Pointcheval 및 Stern \[FOPS\]에 의해 입증된 CCA2에 대해 안전합니다. 영리한 격자 감소 기술을 사용하여 사전 이미지의 충분히 큰 부분이 주어지면 RSAEP를 완전히 반전시키는 방법을 보여주었습니다. 이 관찰은 기본 암호화 기본 요소를 부분적으로 반전시키기 어려운 경우 OAEP가 CCA2에 대해 안전하다는 증거와 결합되어 Bellare와 Rogaway가 RSAES-OAEP에 대해 증명한 것과 일부 사람들이 증명했다고 믿었던 것 사이의 격차를 메워줍니다. 다소 역설적이게도 RSAEP의 표면적인 약점으로 인해 우리는 구원을 받습니다\(즉, 전체 역은 RSAEP의 일부에서 추론될 수 있습니다\).

그러나 불행하게도 보안 감소는 구체적인 매개변수에 대해서는 효율적이지 않습니다. 증명은 RSAES-OAEP의 CCA2 보안에 대한 적 A를 RSA를 반전시키는 알고리즘 I과 성공적으로 연관시켰지만 I의 성공 확률은 대략 \epsilon^2 / 2^18에 불과합니다. 여기서 \epsilon은 다음의 성공 확률입니다. ㅏ.

\(각주: \[FOPS\]에서 인버터의 성공 확률은 \epsilon^2/4였습니다. 추가 요소 1/2^16은 인코딩된 메시지 EM의 시작 부분에 있는 8개의 고정 0 비트에 기인합니다. \[FOPS\]에서 고려되는 OAEP의 변형에는 존재하지 않습니다.\(RSA를 반전하려면 A를 두 번 적용해야 하며 각 적용은 요소 1/2^8에 해당합니다.\)

또한 I의 실행 시간은 대략 t^2이며, 여기서 t는 적의 실행 시간입니다. 결과적으로 RSAES-OAEP를 공격하는 것이 구체적인 매개변수에 대해 RSA를 반전시키는 것보다 훨씬 쉬울 가능성을 배제할 수 없습니다. 그럼에도 불구하고 보안 증명이 존재한다는 것은 RSAES-OAEP 구성이 RSAES-PKCS1-v1\_5와 같은 임시 구성보다 더 건전하다는 어느 정도 보증을 제공합니다.

RSA-KEM\(RSA Key Encapsulation Mechanism\) 패러다임을 기반으로 하는 하이브리드 암호화 체계는 구체적인 매개변수에 직접 적용할 수 있는 강력한 보안 증명을 제공합니다. 논의는 \[ISO18033\]을 참조하세요. PKCS #1의 향후 버전에서는 이 패러다임을 기반으로 하는 구성표를 지정할 수 있습니다.

---
#### **7.1.1.  Encryption Operation**

```text
   RSAES-OAEP-ENCRYPT ((n, e), M, L)

   Options:

      Hash     hash function (hLen denotes the length in octets of
               the hash function output)
      MGF      mask generation function

   Input:

      (n, e)   recipient's RSA public key (k denotes the length in
               octets of the RSA modulus n)
      M        message to be encrypted, an octet string of length mLen,
               where mLen <= k - 2hLen - 2
      L        optional label to be associated with the message; the
               default value for L, if L is not provided, is the empty
               string

   Output:

      C        ciphertext, an octet string of length k

   Errors:  "message too long"; "label too long"
```

가정: RSA 공개 키\(n, e\)가 유효합니다.

```text
   Steps:

      1.  Length checking:

          a.  If the length of L is greater than the input limitation
              for the hash function (2^61 - 1 octets for SHA-1), output
              "label too long" and stop.

          b.  If mLen > k - 2hLen - 2, output "message too long" and
              stop.

      2.  EME-OAEP encoding (see Figure 1 below):

          a.  If the label L is not provided, let L be the empty string.
              Let lHash = Hash(L), an octet string of length hLen (see
              the note below).

          b.  Generate a padding string PS consisting of k - mLen -
              2hLen - 2 zero octets.  The length of PS may be zero.

          c.  Concatenate lHash, PS, a single octet with hexadecimal
              value 0x01, and the message M to form a data block DB of
              length k - hLen - 1 octets as

                 DB = lHash || PS || 0x01 || M.
```

- 디. 길이가 hLen인 임의의 옥텟 문자열 시드를 생성합니다.

```text
          e.  Let dbMask = MGF(seed, k - hLen - 1).

          f.  Let maskedDB = DB \xor dbMask.

          g.  Let seedMask = MGF(maskedDB, hLen).

          h.  Let maskedSeed = seed \xor seedMask.

          i.  Concatenate a single octet with hexadecimal value 0x00,
              maskedSeed, and maskedDB to form an encoded message EM of
              length k octets as

                 EM = 0x00 || maskedSeed || maskedDB.

      3.  RSA encryption:

          a.  Convert the encoded message EM to an integer message
              representative m (see Section 4.2):

                 m = OS2IP (EM).

          b.  Apply the RSAEP encryption primitive (Section 5.1.1) to
              the RSA public key (n, e) and the message representative m
              to produce an integer ciphertext representative c:

                 c = RSAEP ((n, e), m).

          c.  Convert the ciphertext representative c to a ciphertext C
              of length k octets (see Section 4.1):

                 C = I2OSP (c, k).
```

1. 암호문 C를 출력합니다.

```text
      _________________________________________________________________

                                +----------+------+--+-------+
                           DB = |  lHash   |  PS  |01|   M   |
                                +----------+------+--+-------+
                                               |
                     +----------+              |
                     |   seed   |              |
                     +----------+              |
                           |                   |
                           |-------> MGF ---> xor
                           |                   |
                  +--+     V                   |
                  |00|    xor <----- MGF <-----|
                  +--+     |                   |
                    |      |                   |
                    V      V                   V
                  +--+----------+----------------------------+
            EM =  |00|maskedSeed|          maskedDB          |
                  +--+----------+----------------------------+
      _________________________________________________________________

                   Figure 1: EME-OAEP Encoding Operation

   Notes:
```

- lHash는 선택적 레이블 L의 해시입니다.

- 디코딩 작업은 M을 복구하고 lHash 및 PS를 확인하기 위해 역방향 단계를 따릅니다.

- L이 빈 문자열인 경우 해당 해시 값 lHash는 다양한 해시 선택에 대해 다음과 같은 16진수 표현을 갖습니다.

```text
      SHA-1:   (0x)da39a3ee 5e6b4b0d 3255bfef 95601890 afd80709
      SHA-256: (0x)e3b0c442 98fc1c14 9afbf4c8 996fb924 27ae41e4 649b934c
                   a495991b 7852b855
      SHA-384: (0x)38b060a7 51ac9638 4cd9327e b1b1e36a 21fdb711 14be0743
                   4c0cc7bf 63f6e1da 274edebf e76f65fb d51ad2f1 4898b95b
      SHA-512: (0x)cf83e135 7eefb8bd f1542850 d66d8007 d620e405 0b5715dc
                   83f4a921 d36ce9ce 47d0d13c 5d85f2b0 ff8318d2 877eec2f
                   63b931bd 47417a81 a538327a f927da3e
```

---
#### **7.1.2.  Decryption Operation**

```text
   RSAES-OAEP-DECRYPT (K, C, L)

   Options:

      Hash     hash function (hLen denotes the length in octets of
               the hash function output)
      MGF      mask generation function

   Input:

      K        recipient's RSA private key (k denotes the length in
               octets of the RSA modulus n), where k >= 2hLen + 2
      C        ciphertext to be decrypted, an octet string of length k
      L        optional label whose association with the message is to
               be verified; the default value for L, if L is not
               provided, is the empty string

   Output:

      M        message, an octet string of length mLen, where
               mLen <= k - 2hLen - 2

   Error:  "decryption error"

   Steps:

      1.  Length checking:

          a.  If the length of L is greater than the input limitation
              for the hash function (2^61 - 1 octets for SHA-1), output
              "decryption error" and stop.

          b.  If the length of the ciphertext C is not k octets, output
              "decryption error" and stop.
```

- 씨. k < 2hLen + 2이면 "decryption error"를 출력하고 중지합니다.

```text
      2.  RSA decryption:

          a.  Convert the ciphertext C to an integer ciphertext
              representative c (see Section 4.2):

                 c = OS2IP (C).

          b.  Apply the RSADP decryption primitive (Section 5.1.2) to
              the RSA private key K and the ciphertext representative c
              to produce an integer message representative m:

                 m = RSADP (K, c).

              If RSADP outputs "ciphertext representative out of range"
              (meaning that c >= n), output "decryption error" and stop.

          c.  Convert the message representative m to an encoded message
              EM of length k octets (see Section 4.1):

                 EM = I2OSP (m, k).

      3.  EME-OAEP decoding:

          a.  If the label L is not provided, let L be the empty string.
              Let lHash = Hash(L), an octet string of length hLen (see
              the note in Section 7.1.1).

          b.  Separate the encoded message EM into a single octet Y, an
              octet string maskedSeed of length hLen, and an octet
              string maskedDB of length k - hLen - 1 as

                 EM = Y || maskedSeed || maskedDB.

          c.  Let seedMask = MGF(maskedDB, hLen).

          d.  Let seed = maskedSeed \xor seedMask.

          e.  Let dbMask = MGF(seed, k - hLen - 1).

          f.  Let DB = maskedDB \xor dbMask.

          g.  Separate DB into an octet string lHash' of length hLen, a
              (possibly empty) padding string PS consisting of octets
              with hexadecimal value 0x00, and a message M as

                 DB = lHash' || PS || 0x01 || M.

              If there is no octet with hexadecimal value 0x01 to
              separate PS from M, if lHash does not equal lHash', or if
              Y is nonzero, output "decryption error" and stop.  (See
              the note below.)
```

1. M 메시지를 출력합니다.

- 참고: 상대방이 오류 메시지 또는 타이밍에 따라 3.g단계의 다양한 오류 조건을 구별할 수 없도록 주의해야 하며, 보다 일반적으로는 상대방이 인코딩된 메시지 EM에 대한 부분적인 정보를 알 수 없도록 해야 합니다. 그렇지 않으면 상대는 암호문 C의 해독에 대한 유용한 정보를 얻을 수 있으며 Manger\[MANGER\]가 관찰한 것과 같은 선택 암호문 공격으로 이어질 수 있습니다.

---
### **7.2.  RSAES-PKCS1-v1_5**

RSAES-PKCS1-v1\_5는 RSAEP 및 RSADP 기본 요소\(섹션 5.1.1 및 5.1.2\)를 EME-PKCS1-v1\_5 인코딩 방법\(섹션 7.2.1의 2단계 및 섹션 7.2.2의 3단계\)과 결합합니다. 이는 PKCS #1 v1.5의 암호화 체계와 수학적으로 동일합니다. RSAES-PKCS1-v1\_5는 최대 k - 11 옥텟\(k는 RSA 모듈러스의 옥텟 길이\) 길이의 메시지에서 작동할 수 있지만 Coppersmith, Franklin, Patarin으로 인해 낮은 지수 RSA에 대한 특정 공격을 피하기 위해 주의를 기울여야 합니다. , 긴 메시지가 암호화된 경우 Reiter\(아래 참고 사항의 세 번째 글머리 기호 및 \[LOWEXP\]; \[NEWATTACK\]에는 향상된 공격이 포함되어 있음 참조\) 일반적으로 무작위로 생성된 키와 달리 임의의 메시지를 암호화하는 데 이 체계를 사용하는 것은 권장되지 않습니다.

합리적인 성공 확률로 해당 일반 텍스트를 모르더라도 유효한 RSAES-PKCS1-v1\_5 암호문을 생성할 수 있습니다. 이 능력은 \[BLEICHENBACHER\]에 표시된 대로 선택 암호문 공격에서 악용될 수 있습니다. 따라서 RSAES-PKCS1-v1\_5를 사용하려면 \[BLEICHENBACHER\]에서 발견된 공격을 저지하기 위해 쉽게 구현 가능한 특정 대책을 취해야 합니다. 일반적인 예로는 인코딩할 데이터에 구조 추가, 해독된 메시지의 PKCS #1 v1.5 적합성\(및 기타 중복성\)에 대한 엄격한 검사, PKCS #1을 기반으로 하는 클라이언트-서버 프로토콜의 오류 메시지 통합 등이 있습니다. v1.5. 이는 모두 효과적인 대응책이 될 수 있으며 PKCS #1 v1.5를 기반으로 하는 프로토콜 변경을 포함하지 않습니다. 이러한 대책과 기타 대책에 대한 자세한 내용은 \[BKS\]를 참조하세요. RSAES-PKCS1-v1\_5 및 특정 대책을 사용하는 SSL/TLS 핸드셰이크 프로토콜 \[RFC5246\]의 보안이 RSA 문제의 변형과 관련될 수 있다는 것이 최근 밝혀졌습니다. 토론은 \[RSATLS\]를 참조하세요.

참고: 다음 구절에서는 RSAES-PKCS1-v1\_5 사용과 관련된 몇 가지 보안 권장 사항을 설명합니다. PKCS #1 v1.5의 권장 사항과 그 사이에 이루어진 암호화 분석의 발전에 따른 새로운 권장 사항이 포함되어 있습니다.

- 특히 동일한 데이터가 둘 이상의 암호화 프로세스에 입력되는 경우 섹션 7.2.1의 2단계에서 의사 난수 옥텟을 각 암호화 프로세스마다 독립적으로 생성하는 것이 좋습니다. Haastad의 결과 \[HAASTAD\]는 이 권장 사항에 대한 하나의 동기입니다.

- 섹션 7.2.1의 2단계에서 패딩 문자열 PS는 길이가 최소 8옥텟입니다. 이는 공격자가 가능한 모든 암호화 블록을 시도하여 데이터를 복구하기 어렵게 만드는 공개 키 작업에 대한 보안 조건입니다.

- 의사 난수 옥텟은 Coppersmith et al.에 의한 공격을 저지하는 데 도움이 될 수도 있습니다. \[LOWEXP\] \(공격 개선은 \[NEWATTACK\] 참조\) 암호화할 메시지의 크기가 작게 유지되는 경우. 이 공격은 유사한 메시지가 동일한 RSA 공개 키로 암호화된 경우 낮은 지수 RSA에서 작동합니다. 보다 구체적으로 공격의 한 가지 유형에서 RSAEP에 대한 두 입력이 많은 비트\(8/9\)에 동의하고 낮은 지수 RSA\(e = 3\)가 두 입력을 모두 암호화하는 데 사용되는 경우 다음이 가능할 수 있습니다. 공격으로 두 입력을 모두 복구합니다. 공격의 또 다른 특징은 RSAEP에 대한 입력의 큰 부분\(2/3\)이 이미 알려진 경우 단일 암호문을 성공적으로 해독하는 것입니다. 일반적인 애플리케이션의 경우 암호화할 메시지가 짧기 때문에\(예: 128비트 대칭 키\) 공격을 활성화할 만큼 두 메시지 간에 알려진 정보가 충분하지 않거나 공통되지 않습니다. 그러나 긴 메시지가 암호화되어 있거나 메시지의 일부가 알려진 경우에는 공격이 문제가 될 수 있습니다. 어쨌든 RSAES-OAEP 방식은 공격을 극복합니다.

---
#### **7.2.1.  Encryption Operation**

```text
   RSAES-PKCS1-V1_5-ENCRYPT ((n, e), M)

   Input:

      (n, e)   recipient's RSA public key (k denotes the length in
               octets of the modulus n)
      M        message to be encrypted, an octet string of length
               mLen, where mLen <= k - 11

   Output:

      C        ciphertext, an octet string of length k

   Error:  "message too long"

   Steps:

      1.  Length checking: If mLen > k - 11, output "message too long"
          and stop.

      2.  EME-PKCS1-v1_5 encoding:

          a.  Generate an octet string PS of length k - mLen - 3
              consisting of pseudo-randomly generated nonzero octets.
              The length of PS will be at least eight octets.

          b.  Concatenate PS, the message M, and other padding to form
              an encoded message EM of length k octets as

                 EM = 0x00 || 0x02 || PS || 0x00 || M.

      3.  RSA encryption:

          a.  Convert the encoded message EM to an integer message
              representative m (see Section 4.2):

                 m = OS2IP (EM).

          b.  Apply the RSAEP encryption primitive (Section 5.1.1) to
              the RSA public key (n, e) and the message representative m
              to produce an integer ciphertext representative c:

                 c = RSAEP ((n, e), m).

          c.  Convert the ciphertext representative c to a ciphertext C
              of length k octets (see Section 4.1):

                 C = I2OSP (c, k).
```

1. 암호문 C를 출력합니다.

---
#### **7.2.2.  Decryption Operation**

```text
   RSAES-PKCS1-V1_5-DECRYPT (K, C)

   Input:

      K        recipient's RSA private key
      C        ciphertext to be decrypted, an octet string of length k,
               where k is the length in octets of the RSA modulus n

   Output:

      M        message, an octet string of length at most k - 11

   Error:  "decryption error"

   Steps:

      1.  Length checking: If the length of the ciphertext C is not k
          octets (or if k < 11), output "decryption error" and stop.

      2.  RSA decryption:

          a.  Convert the ciphertext C to an integer ciphertext
              representative c (see Section 4.2):

                 c = OS2IP (C).

          b.  Apply the RSADP decryption primitive (Section 5.1.2) to
              the RSA private key (n, d) and the ciphertext
              representative c to produce an integer message
              representative m:

                 m = RSADP ((n, d), c).

              If RSADP outputs "ciphertext representative out of range"
              (meaning that c >= n), output "decryption error" and stop.

          c.  Convert the message representative m to an encoded message
              EM of length k octets (see Section 4.1):

                 EM = I2OSP (m, k).

      3.  EME-PKCS1-v1_5 decoding: Separate the encoded message EM into
          an octet string PS consisting of nonzero octets and a message
          M as

             EM = 0x00 || 0x02 || PS || 0x00 || M.

          If the first octet of EM does not have hexadecimal value 0x00,
          if the second octet of EM does not have hexadecimal value
          0x02, if there is no octet with hexadecimal value 0x00 to
          separate PS from M, or if the length of PS is less than 8
          octets, output "decryption error" and stop.  (See the note
          below.)

      4.  Output M.
```

- 참고: 상대가 오류 메시지나 타이밍으로 3단계의 다양한 오류 조건을 구별할 수 없도록 주의해야 합니다. 그렇지 않으면 상대방이 암호문 C의 해독에 대한 유용한 정보를 얻을 수 있어 Bleichenbacher 공격의 강화된 버전으로 이어질 수 있습니다 \[BLEICHENBACHER\]. Manger의 공격 \[MANGER\]과 비교해보세요.

---
## **8.  Signature Scheme with Appendix**

이 문서의 목적에 따라 부록이 있는 서명 체계는 서명 생성 작업과 서명 확인 작업으로 구성됩니다. 여기서 서명 생성 작업은 서명자의 RSA 개인 키가 있는 메시지에서 서명을 생성하고 서명 확인 작업은 서명을 확인합니다. 서명자의 해당 RSA 공개 키를 사용하여 메시지에 표시됩니다. 이러한 유형의 체계로 구성된 서명을 확인하려면 메시지 자체가 필요합니다. 이러한 방식으로 부록이 있는 서명 체계는 이 문서에서 지원되지 않는 메시지 복구가 있는 서명 체계와 구별됩니다.

부록이 포함된 서명 체계는 다양한 응용 프로그램에 사용될 수 있습니다. 예를 들어, 여기에 정의된 부록이 있는 서명 체계는 X.509 인증서\[ISO9594\]에 적합한 서명 알고리즘이 될 것입니다. 관련 서명 체계는 PKCS #7 \[RFC2315\]에서 사용될 수 있지만, 기술적인 이유로 현재 버전의 PKCS #7은 해시 함수를 서명 체계에서 분리하는데, 이는 여기에서 수행되는 것과 다릅니다. 자세한 내용은 부록 A.2.3의 참고 사항을 참조하세요.

이 문서에는 RSASSA-PSS 및 RSASSA-PKCS1-v1\_5라는 두 가지 서명 체계\(부록 포함\)가 지정되어 있습니다. RSASSA-PKCS1-v1\_5에 대한 공격은 알려져 있지 않지만 견고성을 높이기 위해 새 응용 프로그램에는 RSASSA-PSS가 필요합니다. RSASSA-PKCS1-v1\_5는 기존 애플리케이션과의 호환성을 위해서만 포함됩니다.

여기에 제공된 부록이 있는 서명 체계는 서명 및 검증 기본 요소를 서명에 대한 인코딩 방법과 결합하는 IEEE 1363 \[IEEE1363\]에 사용된 것과 유사한 일반 모델을 따릅니다. 서명 생성 작업은 메시지 인코딩 작업을 메시지에 적용하여 인코딩된 메시지를 생성한 다음 정수 메시지 표현으로 변환합니다. 서명을 생성하기 위해 서명 프리미티브가 메시지 표현에 적용됩니다. 이를 반대로, 서명 확인 작업은 서명 확인 기본 요소를 서명에 적용하여 메시지 표현을 복구한 다음 옥텟 문자열로 인코딩된 메시지로 변환합니다. 일치 여부를 확인하기 위해 메시지와 인코딩된 메시지에 확인 작업이 적용됩니다.

인코딩 방법이 결정적\(예: EMSA-PKCS1-v1\_5\)인 경우 확인 작업은 메시지 인코딩 작업을 메시지에 적용하고 결과 인코딩 메시지를 이전에 파생된 인코딩 메시지와 비교할 수 있습니다. 일치하는 것이 있으면 서명이 유효한 것으로 간주됩니다. 방법이 무작위화된 경우\(예: EMSA-PSS\) 일반적으로 검증 작업이 더 복잡합니다. 예를 들어 EMSA-PSS의 검증 작업은 인코딩된 메시지에서 무작위 솔트와 해시 출력을 추출하고 해시 출력, 솔트 및 메시지가 일치하는지 확인합니다. 해시 출력은 메시지와 솔트 측면에서 결정적인 함수입니다. 이 문서에 정의된 부록이 있는 두 가지 서명 체계 모두 서명 생성 및 서명 확인 작업은 서명이 메시지 뒤에 배치되면 "단일 패스" 작업으로 쉽게 구현됩니다. RSASSA-PKCS1-v1\_5의 경우 형식 예는 PKCS #7 \[RFC2315\]를 참조하세요.

---
### **8.1.  RSASSA-PSS**

RSASSA-PSS는 RSASP1 및 RSAVP1 프리미티브를 EMSA-PSS 인코딩 방법과 결합합니다. 이는 IEEE 1363a \[IEEE1363A\]에서 개정된 IFSSA\(Integer Factorization Signature Scheme with 부록\)와 호환됩니다. 여기서 서명 및 검증 기본 요소는 IEEE 1363 \[IEEE1363\]에 정의된 IFSP-RSA1 및 IFVP-RSA1이며 메시지 인코딩은 방법은 EMSA4입니다. EMSA4는 옥텟 문자열이 아닌 비트 문자열에서 작동하므로 EMSA-PSS보다 약간 더 일반적입니다. EMSA-PSS는 피연산자, 해시 및 솔트 값이 옥텟 문자열인 경우로 제한되는 EMSA4와 동일합니다.

RSASSA-PSS가 작동할 수 있는 메시지 길이는 EMSA-PSS 인코딩 방법의 기반이 되는 해시 함수에 따라 제한이 없거나 매우 큰 수로 제한됩니다.

e-th 루트 모듈론 계산이 불가능하고 EMSA-PSS의 해시 및 마스크 생성 기능에 적절한 속성이 있다고 가정하면 RSASSA-PSS는 보안 서명을 제공합니다. 이러한 보증은 해시 및 마스크 생성 기능을 블랙박스 또는 무작위 오라클로 간주하는 경우 서명 위조의 어려움이 RSA 기능 반전의 어려움과 직접적으로 관련될 수 있다는 점에서 입증 가능합니다. 보안 증명의 경계는 본질적으로 "엄격"합니다. 즉, RSASSA-PSS에 대한 최고의 위조자의 성공 확률과 실행 시간은 최고의 RSA 반전 알고리즘에 대한 해당 매개변수에 매우 가깝습니다. 자세한 내용은 \[RSARABIN\] \[PSSPROOF\] \[JONSSON\]을 참조하세요.

RSASSA-PKCS1-v1\_5 서명 방식과 달리 해시 함수 식별자는 EMSA-PSS로 인코딩된 메시지에 내장되어 있지 않으므로 이론적으로 공격자가 서명을 대체할 수 있습니다.

서명자가 선택한 것과 다른\(그리고 잠재적으로 더 약한\) 해시 함수입니다. 따라서 EMSA-PSS 마스크 생성 기능은 동일한 해시 기능을 기반으로 하는 것을 권장합니다. 이러한 방식으로 인코딩된 메시지 전체는 해시 함수에 따라 달라지며 상대방이 서명자가 의도한 것과 다른 해시 함수를 대체하기가 어렵습니다. 이러한 해시 함수 일치는 해시 함수 대체를 방지하기 위한 목적으로만 수행되며 해시 함수 대체가 다른 수단으로 해결되는 경우\(예: 검증자가 지정된 해시 함수만 허용하는 경우\) 필요하지 않습니다. 이러한 사항에 대한 자세한 내용은 \[HASHID\]를 참조하세요. RSASSA-PSS의 입증 가능한 보안은 메시지에 적용되는 해시 함수와 동일한 마스크 생성 기능의 해시 함수에 의존하지 않습니다.

RSASSA-PSS는 무작위로 생성된 솔트 값을 통합하여 결정론적이기보다는 확률적이라는 점에서 다른 RSA 기반 서명 체계와 다릅니다. 솔트 값은 FDH\(Full Domain Hashing\)와 같은 결정론적 대안보다 "더 엄격한" 보안 증명을 제공하여 체계의 보안을 강화합니다. 토론은 \[RSARABIN\]을 참조하세요. 그러나 무작위성은 보안에 중요하지 않습니다. 무작위 생성이 불가능한 상황에서는 고정된 값이나 시퀀스 번호를 대신 사용할 수 있으며 결과적으로 FDH\[FDH\]와 유사한 입증 가능한 보안을 얻을 수 있습니다.

---
#### **8.1.1.  Signature Generation Operation**

```text
   RSASSA-PSS-SIGN (K, M)

   Input:

      K        signer's RSA private key
      M        message to be signed, an octet string

   Output:

      S        signature, an octet string of length k, where k is the
               length in octets of the RSA modulus n

   Errors:  "message too long;" "encoding error"

   Steps:

      1.  EMSA-PSS encoding: Apply the EMSA-PSS encoding operation
          (Section 9.1.1) to the message M to produce an encoded message
          EM of length \ceil ((modBits - 1)/8) octets such that the bit
          length of the integer OS2IP (EM) (see Section 4.2) is at most
          modBits - 1, where modBits is the length in bits of the RSA
          modulus n:

             EM = EMSA-PSS-ENCODE (M, modBits - 1).

          Note that the octet length of EM will be one less than k if
          modBits - 1 is divisible by 8 and equal to k otherwise.  If
          the encoding operation outputs "message too long", output
          "message too long" and stop.  If the encoding operation
          outputs "encoding error", output "encoding error" and stop.

      2.  RSA signature:

          a.  Convert the encoded message EM to an integer message
              representative m (see Section 4.2):

                 m = OS2IP (EM).

          b.  Apply the RSASP1 signature primitive (Section 5.2.1) to
              the RSA private key K and the message representative m to
              produce an integer signature representative s:

                 s = RSASP1 (K, m).

          c.  Convert the signature representative s to a signature S of
              length k octets (see Section 4.1):

                 S = I2OSP (s, k).
```

1. 서명 S를 출력합니다.

---
#### **8.1.2.  Signature Verification Operation**

```text
   RSASSA-PSS-VERIFY ((n, e), M, S)

   Input:

      (n, e)  signer's RSA public key
      M       message whose signature is to be verified, an octet string
      S       signature to be verified, an octet string of length k,
              where k is the length in octets of the RSA modulus n
```

출력: "유효한 서명" 또는 "잘못된 서명"

```text
   Steps:

      1.  Length checking: If the length of the signature S is not k
          octets, output "invalid signature" and stop.

      2.  RSA verification:

          a.  Convert the signature S to an integer signature
              representative s (see Section 4.2):

                 s = OS2IP (S).

          b.  Apply the RSAVP1 verification primitive (Section 5.2.2) to
              the RSA public key (n, e) and the signature representative
              s to produce an integer message representative m:

                 m = RSAVP1 ((n, e), s).

              If RSAVP1 output "signature representative out of range",
              output "invalid signature" and stop.

          c.  Convert the message representative m to an encoded message
              EM of length emLen = \ceil ((modBits - 1)/8) octets, where
              modBits is the length in bits of the RSA modulus n (see
              Section 4.1):

                 EM = I2OSP (m, emLen).

              Note that emLen will be one less than k if modBits - 1 is
              divisible by 8 and equal to k otherwise.  If I2OSP outputs
              "integer too large", output "invalid signature" and stop.

      3.  EMSA-PSS verification: Apply the EMSA-PSS verification
          operation (Section 9.1.2) to the message M and the encoded
          message EM to determine whether they are consistent:

             Result = EMSA-PSS-VERIFY (M, EM, modBits - 1).

      4.  If Result = "consistent", output "valid signature".
          Otherwise, output "invalid signature".
```

---
### **8.2.  RSASSA-PKCS1-v1_5**

RSASSA-PKCS1-v1\_5는 RSASP1 및 RSAVP1 프리미티브를 EMSA-PKCS1-v1\_5 인코딩 방법과 결합합니다. IEEE 1363 \[IEEE1363\]에 정의된 IFSSA 방식과 호환되며 서명 및 검증 프리미티브는 IFSP-RSA1 및 IFVP-RSA1이고 메시지 인코딩 방법은 EMSA-PKCS1-v1\_5\(IEEE 1363에서는 정의되지 않았지만 IEEE 1363a \[IEEE1363A\]에 있음\).

RSASSA-PKCS1-v1\_5가 작동할 수 있는 메시지 길이는 EMSA-PKCS1-v1\_5 방법의 기반이 되는 해시 함수에 따라 무제한이거나 매우 큰 수로 제한됩니다.

n번째 루트 계산이 불가능하고 EMSA-PKCS1-v1\_5의 해시 함수에 적절한 속성이 있다고 가정하면 RSASSA-PKCS1-v1\_5는 보안 서명을 제공하는 것으로 추측됩니다. 보다 정확하게는 RSA 개인 키를 모르고 서명을 위조하는 것은 계산상 불가능하다고 추측됩니다. 또한 EMSA-PKCS1-v1\_5 인코딩 방식에는 해시 함수 식별자가 인코딩에 내장되어 있습니다. 이 기능으로 인해 이전에 서명된 메시지와 동일한 서명이 있는 메시지를 찾으려는 공격자는 사용 중인 특정 해시 함수의 충돌을 찾아야 합니다. 서명자가 선택한 것과 다른 해시 함수를 공격하는 것은 적에게 유용하지 않습니다. 자세한 내용은 \[HASHID\]를 참조하세요.

참고: PKCS #1 v1.5에 명시된 대로 EMSA-PKCS1-v1\_5 인코딩 방법에는 정수 메시지 표현으로 변환된 인코딩된 메시지가 크고 적어도 어느 정도 "무작위"임을 보장하는 속성이 있습니다. 이는 메시지 표현을 작은 값 세트\(예: 작은 소수 세트\)로 인수분해하여 메시지 표현 간의 곱셈 관계가 개발되는 Desmedt 및 Odlyzko \[CHOSEN\]가 제안한 종류의 공격을 방지합니다. Coron, Naccache 및 Stern \[PADDING\]은 이러한 유형의 공격의 더 강력한 형태가 ISO/IEC 9796-2 서명 체계의 일부 인스턴스에 대해 매우 효과적일 수 있음을 보여주었습니다. 또한 EMSA-PKCS1-v1\_5 인코딩 방법에 대한 이러한 유형의 공격의 복잡성을 분석하고 공격이 비실용적이며 기본 해시 함수에 대한 충돌 검색보다 더 많은 작업\(즉, 2^80개 이상의 작업\)이 필요하다는 결론을 내렸습니다. . Coppersmith, Halevi 및 Jutla \[FORGERY\]는 이후 Coron 등의 공격을 확장하여 메시지 복구를 통해 ISO/IEC 9796-1 서명 체계를 깨뜨렸습니다. 다양한 공격은 특히 메시지 복구 기능이 있는 서명 체계에서 RSA 서명 프리미티브에 대한 입력을 신중하게 구성하는 것의 중요성을 보여줍니다. 따라서 EMSA-PKCS-v1\_5 인코딩 방법은 해시 작업을 명시적으로 포함하며 메시지 복구가 포함된 서명 체계에는 적합하지 않습니다. 또한 EMSA-PKCS-v1\_5 인코딩 방법에 대한 공격은 알려져 있지 않지만 향후 개발에 대한 예방 조치로 EMSA-PSS로 점진적으로 전환하는 것이 좋습니다.

---
#### **8.2.1.  Signature Generation Operation**

```text
   RSASSA-PKCS1-V1_5-SIGN (K, M)

   Input:

      K        signer's RSA private key
      M        message to be signed, an octet string

   Output:

      S        signature, an octet string of length k, where k is the
               length in octets of the RSA modulus n

   Errors:  "message too long"; "RSA modulus too short"

   Steps:

      1.  EMSA-PKCS1-v1_5 encoding: Apply the EMSA-PKCS1-v1_5 encoding
          operation (Section 9.2) to the message M to produce an encoded
          message EM of length k octets:

             EM = EMSA-PKCS1-V1_5-ENCODE (M, k).

          If the encoding operation outputs "message too long", output
          "message too long" and stop.  If the encoding operation
          outputs "intended encoded message length too short", output
          "RSA modulus too short" and stop.

      2.  RSA signature:

          a.  Convert the encoded message EM to an integer message
              representative m (see Section 4.2):

                 m = OS2IP (EM).

          b.  Apply the RSASP1 signature primitive (Section 5.2.1) to
              the RSA private key K and the message representative m to
              produce an integer signature representative s:

                 s = RSASP1 (K, m).

          c.  Convert the signature representative s to a signature S of
              length k octets (see Section 4.1):

                 S = I2OSP (s, k).
```

1. 서명 S를 출력합니다.

---
#### **8.2.2.  Signature Verification Operation**

```text
   RSASSA-PKCS1-V1_5-VERIFY ((n, e), M, S)

   Input:

      (n, e)  signer's RSA public key
      M       message whose signature is to be verified, an octet string

      S       signature to be verified, an octet string of length k,
              where k is the length in octets of the RSA modulus n
```

"유효한 서명" 또는 "잘못된 서명" 출력

```text
   Errors:  "message too long"; "RSA modulus too short"

   Steps:

      1.  Length checking: If the length of the signature S is not k
          octets, output "invalid signature" and stop.

      2.  RSA verification:

          a.  Convert the signature S to an integer signature
              representative s (see Section 4.2):

                 s = OS2IP (S).

          b.  Apply the RSAVP1 verification primitive (Section 5.2.2) to
              the RSA public key (n, e) and the signature representative
              s to produce an integer message representative m:

                 m = RSAVP1 ((n, e), s).

              If RSAVP1 outputs "signature representative out of range",
              output "invalid signature" and stop.

          c.  Convert the message representative m to an encoded message
              EM of length k octets (see Section 4.1):

                 EM = I2OSP (m, k).

              If I2OSP outputs "integer too large", output "invalid
              signature" and stop.

      3.  EMSA-PKCS1-v1_5 encoding: Apply the EMSA-PKCS1-v1_5 encoding
          operation (Section 9.2) to the message M to produce a second
          encoded message EM' of length k octets:

             EM' = EMSA-PKCS1-V1_5-ENCODE (M, k).

          If the encoding operation outputs "message too long", output
          "message too long" and stop.  If the encoding operation
          outputs "intended encoded message length too short", output
          "RSA modulus too short" and stop.

      4.  Compare the encoded message EM and the second encoded message
          EM'.  If they are the same, output "valid signature";
          otherwise, output "invalid signature".
```

- 참고: 서명 확인 작업을 구현하는 또 다른 방법은 인코딩된 메시지에 "디코딩" 작업\(이 문서에 지정되지 않음\)을 적용하여 기본 해시 값을 복구한 다음 이를 새로 계산된 해시 값과 비교하는 것입니다. 이는 중간 저장소\(2개의 인코딩된 메시지가 아닌 2개의 해시 값\)가 덜 필요하다는 장점이 있지만 추가 코드가 필요하다는 단점이 있습니다.

---
## **9.  Encoding Methods for Signatures with Appendix**

인코딩 방법은 옥텟 문자열 메시지와 옥텟 문자열 인코딩 메시지 사이를 매핑하는 작업으로 구성되며, 이 메시지는 구성표의 정수 메시지 표현 간에 변환됩니다. 정수 메시지 표현은 기본 요소를 통해 처리됩니다. 따라서 인코딩 방법은 메시지를 처리하는 체계와 기본 요소 간의 연결을 제공합니다.

본 문서의 목적에 따라 부록이 포함된 서명의 인코딩 방법은 인코딩 작업과 선택적으로 확인 작업으로 구성됩니다. 인코딩 작업은 메시지 M을 지정된 길이의 인코딩된 메시지 EM에 매핑합니다. 검증 동작은 메시지 M과 인코딩된 메시지 EM이 일치하는지, 즉 인코딩된 메시지 EM이 메시지 M의 유효한 인코딩인지 여부를 결정한다.

인코딩 작업은 임의성을 도입할 수 있으므로 동일한 메시지에 대한 인코딩 작업의 서로 다른 적용이 서로 다른 인코딩된 메시지를 생성하게 되며 이는 입증 가능한 보안에 이점이 있습니다. 이러한 인코딩 방법의 경우 검증자가 무작위성을 재현할 수 없으면\(예: 서명자로부터 솔트 값을 얻음\) 인코딩과 검증 작업이 모두 필요합니다. 결정적 인코딩 방법의 경우 인코딩 작업만 필요합니다.

부록이 있는 서명에 대한 두 가지 인코딩 방법이 서명 체계에 사용되며 여기에서 지정됩니다: EMSA-PSS 및 EMSA-PKCS1-v1\_5.

---
### **9.1.  EMSA-PSS**

이 인코딩 방법은 해시 함수, 마스크 생성 함수 및 솔트 길이를 선택하여 매개변수화됩니다. 이러한 옵션은 솔트 길이가 가변적일 수 있다는 점을 제외하고는 주어진 RSA 키에 대해 수정되어야 합니다\(토론은 \[JONSSON\] 참조\). 제안된 해시 및 마스크 생성 기능은 부록 B에 나와 있습니다. 인코딩 방법은 Bellare와 Rogaway의 PSS\(Probabilistic Signature Scheme\) \[RSARABIN\]\[PSS\]를 기반으로 합니다. 무작위로 이루어지며 인코딩 작업과 검증 작업이 있습니다.

그림 2는 인코딩 작업을 보여줍니다.

```text
      __________________________________________________________________

                                     +-----------+
                                     |     M     |
                                     +-----------+
                                           |
                                           V
                                         Hash
                                           |
                                           V
                             +--------+----------+----------+
                        M' = |Padding1|  mHash   |   salt   |
                             +--------+----------+----------+
                                            |
                  +--------+----------+     V
            DB =  |Padding2|   salt   |   Hash
                  +--------+----------+     |
                            |               |
                            V               |
                           xor <--- MGF <---|
                            |               |
                            |               |
                            V               V
                  +-------------------+----------+--+
            EM =  |    maskedDB       |     H    |bc|
                  +-------------------+----------+--+
      __________________________________________________________________

   Figure 2: EMSA-PSS Encoding Operation
```

검증 작업은 소금을 회수하기 위한 역방향 단계를 따른 다음, H를 다시 ​​계산하고 비교하기 위한 전진 단계를 따른다는 점에 유의하십시오.

```text
   Notes:
```

1. 여기에 정의된 인코딩 방법은 Bellare와 Rogaway가 IEEE 1363a \[PSS\]에 제출한 방법과 세 가지 측면에서 다릅니다.

```text
       *  It applies a hash function rather than a mask generation
          function to the message.  Even though the mask generation
          function is based on a hash function, it seems more natural to
          apply a hash function directly.

       *  The value that is hashed together with the salt value is the
          string (0x)00 00 00 00 00 00 00 00 || mHash rather than the
          message M itself.  Here, mHash is the hash of M.  Note that
          the hash function is the same in both steps.  See Note 3 below
          for further discussion.  (Also, the name "salt" is used
          instead of "seed", as it is more reflective of the value's
          role.)

       *  The encoded message in EMSA-PSS has nine fixed bits; the first
          bit is 0 and the last eight bits form a "trailer field", the
          octet 0xbc.  In the original scheme, only the first bit is
          fixed.  The rationale for the trailer field is for
          compatibility with the Integer Factorization Signature
          Primitive using Rabin-Williams (IFSP-RW) in IEEE 1363
          [IEEE1363] and the corresponding primitive in ISO/IEC
          9796-2:2010 [ISO9796].
```

1. 마스크 생성 기능이 해시 함수 기반이라고 가정할 때, 해시 함수는 메시지에 적용되는 것과 동일할 것을 권장한다\(RECOMMENDED\). 자세한 내용은 섹션 8.1을 참조하세요.

1. RSASSA-PSS에 대한 보안 증명을 손상시키지 않으면서 나머지를 계산하는 모듈 외부에서 EMSA-PSS-ENCODE 및 EMSA-PSS-VERIFY\(메시지에 해시 함수 적용\)의 1단계와 2단계를 수행할 수 있습니다. 메시지 M 자체가 아닌 mHash가 모듈에 입력되도록 서명 작업을 수행합니다. 즉, 상대방이 mHash의 가치를 통제할 수 있더라도 RSASSA-PSS의 보안 증명은 여전히 ​​유효합니다. 이는 모듈\(예: 스마트 카드\)에 제한된 I/O 대역폭이 있는 경우 편리합니다. PSS \[RSARABIN\]\[PSS\]의 이전 버전에는 이 속성이 없었습니다. 물론, 다른 보안상의 이유로 모듈이 전체 메시지를 처리하도록 하는 것이 바람직할 수도 있습니다. 예를 들어 모듈은 해시 값을 계산하는 구성 요소를 신뢰하지 않는 경우 서명 내용을 "확인"해야 할 수 있습니다.

1. 옥텟 단위의 일반적인 솔트 길이는 hLen\(해시 함수 Hash의 출력 길이\)과 0입니다. 두 경우 모두 RSASSA-PSS의 보안은 RSAVP1 반전의 경도와 밀접한 관련이 있을 수 있습니다. Bellare와 Rogaway \[RSARABIN\]는 원본 RSA-PSS 체계의 보안에 대한 엄격한 하한을 제공하며 이는 대략 전자의 경우에 해당하는 반면 Coron \[FDH\]는 관련 Full Domain Hashing 체계에 대한 하한을 제공합니다. 후자의 경우. \[PSSPROOF\]에서 Coron은 0에서 hLen까지 다양한 염 길이로 일반적인 처리를 제공합니다. 논의는 \[IEEE1363A\]를 참조하세요. 위의 참고 1에 나열된 RSA-PSS의 원본 버전과 현재 버전 간의 차이점을 해결하기 위해 \[RSARABIN\] \[PSSPROOF\]의 보안 증명을 조정하는 \[JONSSON\]도 참조하세요.

1. IEEE 1363a \[IEEE1363A\]에 명시된 바와 같이 EMSA-PSS의 솔트 값과 같은 서명 방식의 무작위화 사용은 서명되는 메시지 이외의 정보를 전송하기 위한 "은밀한 채널"을 제공할 수 있습니다. 비밀채널에 대한 자세한 내용은 \[시몬스\]를 참고하세요.

---
#### **9.1.1.  Encoding Operation**

```text
   EMSA-PSS-ENCODE (M, emBits)

   Options:

      Hash     hash function (hLen denotes the length in octets of
               the hash function output)
      MGF      mask generation function
      sLen     intended length in octets of the salt

   Input:

      M        message to be encoded, an octet string
      emBits   maximal bit length of the integer OS2IP (EM) (see Section
               4.2), at least 8hLen + 8sLen + 9

   Output:

      EM       encoded message, an octet string of length emLen = \ceil
               (emBits/8)

   Errors:  "Encoding error"; "message too long"

   Steps:

      1.   If the length of M is greater than the input limitation for
           the hash function (2^61 - 1 octets for SHA-1), output
           "message too long" and stop.
```

1. 길이가 hLen인 옥텟 문자열인 mHash = Hash\(M\)로 설정합니다.

1. emLen < hLen + sLen + 2이면 "encoding error"를 출력하고 중지합니다.

```text
      4.   Generate a random octet string salt of length sLen; if sLen =
           0, then salt is the empty string.

      5.   Let

              M' = (0x)00 00 00 00 00 00 00 00 || mHash || salt;

           M' is an octet string of length 8 + hLen + sLen with eight
           initial zero octets.
```

1. 길이가 hLen인 옥텟 문자열인 H = Hash\(M'\)로 설정합니다.

```text
      7.   Generate an octet string PS consisting of emLen - sLen - hLen
           - 2 zero octets.  The length of PS may be 0.

      8.   Let DB = PS || 0x01 || salt; DB is an octet string of length
           emLen - hLen - 1.

      9.   Let dbMask = MGF(H, emLen - hLen - 1).

      10.  Let maskedDB = DB \xor dbMask.

      11.  Set the leftmost 8emLen - emBits bits of the leftmost octet
           in maskedDB to zero.

      12.  Let EM = maskedDB || H || 0xbc.

      13.  Output EM.
```

---
#### **9.1.2.  Verification Operation**

```text
   EMSA-PSS-VERIFY (M, EM, emBits)

   Options:

      Hash     hash function (hLen denotes the length in octets of
               the hash function output)
      MGF      mask generation function
      sLen     intended length in octets of the salt

   Input:

      M        message to be verified, an octet string
      EM       encoded message, an octet string of length emLen = \ceil
               (emBits/8)
      emBits   maximal bit length of the integer OS2IP (EM) (see Section
               4.2), at least 8hLen + 8sLen + 9
```

출력: "일관됨" 또는 "일관되지 않음"

```text
   Steps:

      1.   If the length of M is greater than the input limitation for
           the hash function (2^61 - 1 octets for SHA-1), output
           "inconsistent" and stop.
```

1. 길이가 hLen인 옥텟 문자열인 mHash = Hash\(M\)로 설정합니다.

1. emLen < hLen + sLen + 2이면 "inconsilient"를 출력하고 중지합니다.

```text
      4.   If the rightmost octet of EM does not have hexadecimal value
           0xbc, output "inconsistent" and stop.

      5.   Let maskedDB be the leftmost emLen - hLen - 1 octets of EM,
           and let H be the next hLen octets.

      6.   If the leftmost 8emLen - emBits bits of the leftmost octet in
           maskedDB are not all equal to zero, output "inconsistent" and
           stop.

      7.   Let dbMask = MGF(H, emLen - hLen - 1).

      8.   Let DB = maskedDB \xor dbMask.

      9.   Set the leftmost 8emLen - emBits bits of the leftmost octet
           in DB to zero.

      10.  If the emLen - hLen - sLen - 2 leftmost octets of DB are not
           zero or if the octet at position emLen - hLen - sLen - 1 (the
           leftmost position is "position 1") does not have hexadecimal
           value 0x01, output "inconsistent" and stop.
```

1. 솔트를 DB의 마지막 sLen 옥텟으로 둡니다.

```text
      12.  Let

              M' = (0x)00 00 00 00 00 00 00 00 || mHash || salt ;

           M' is an octet string of length 8 + hLen + sLen with eight
           initial zero octets.
```

1. 길이가 hLen인 옥텟 문자열인 H' = Hash\(M'\)로 설정합니다.

```text
      14.  If H = H', output "consistent".  Otherwise, output
           "inconsistent".
```

---
### **9.2.  EMSA-PKCS1-v1_5**

이 인코딩 방법은 결정적이며 인코딩 작업만 포함합니다.

```text
   EMSA-PKCS1-v1_5-ENCODE (M, emLen)

   Option:

      Hash     hash function (hLen denotes the length in octets of
               the hash function output)

   Input:

      M        message to be encoded
      emLen    intended length in octets of the encoded message, at
               least tLen + 11, where tLen is the octet length of the
               Distinguished Encoding Rules (DER) encoding T of
               a certain value computed during the encoding operation

   Output:

      EM       encoded message, an octet string of length emLen

   Errors:  "message too long"; "intended encoded message length too
      short"

   Steps:

      1.  Apply the hash function to the message M to produce a hash
          value H:

             H = Hash(M).

          If the hash function outputs "message too long", output
          "message too long" and stop.

      2.  Encode the algorithm ID for the hash function and the hash
          value into an ASN.1 value of type DigestInfo (see
          Appendix A.2.4) with the DER, where the type DigestInfo has
          the syntax

               DigestInfo ::= SEQUENCE {
                   digestAlgorithm AlgorithmIdentifier,
                   digest OCTET STRING
               }

          The first field identifies the hash function and the second
          contains the hash value.  Let T be the DER encoding of the
          DigestInfo value (see the notes below), and let tLen be the
          length in octets of T.

      3.  If emLen < tLen + 11, output "intended encoded message length
          too short" and stop.

      4.  Generate an octet string PS consisting of emLen - tLen - 3
          octets with hexadecimal value 0xff.  The length of PS will be
          at least 8 octets.

      5.  Concatenate PS, the DER encoding T, and other padding to form
          the encoded message EM as

             EM = 0x00 || 0x01 || PS || 0x00 || T.

      6.  Output EM.

   Notes:
```

1. 부록 B.1에 언급된 9가지 해시 함수의 경우 DigestInfo 값의 DER 인코딩 T는 다음과 같습니다.

```text
         MD2:     (0x)30 20 30 0c 06 08 2a 86 48 86 f7 0d 02 02 05 00 04
                      10 || H.
         MD5:     (0x)30 20 30 0c 06 08 2a 86 48 86 f7 0d 02 05 05 00 04
                      10 || H.
         SHA-1:   (0x)30 21 30 09 06 05 2b 0e 03 02 1a 05 00 04 14 || H.
         SHA-224:  (0x)30 2d 30 0d 06 09 60 86 48 01 65 03 04 02 04
                      05 00 04 1c || H.
         SHA-256: (0x)30 31 30 0d 06 09 60 86 48 01 65 03 04 02 01 05 00
                      04 20 || H.
         SHA-384: (0x)30 41 30 0d 06 09 60 86 48 01 65 03 04 02 02 05 00
                      04 30 || H.
         SHA-512: (0x)30 51 30 0d 06 09 60 86 48 01 65 03 04 02 03 05 00
                      04 40 || H.
         SHA-512/224:  (0x)30 2d 30 0d 06 09 60 86 48 01 65 03 04 02 05
                           05 00 04 1c || H.
         SHA-512/256:  (0x)30 31 30 0d 06 09 60 86 48 01 65 03 04 02 06
                           05 00 04 20 || H.
```

1. 이 문서의 버전 1.5에서는 T가 DigestInfo 값의 DER 인코딩이 아닌 BER 인코딩으로 정의되었습니다. 특히, 적어도 이론상으로는 이 문서\(및 버전 2.0\)에 정의된 확인 작업이 PKCS #1 v1.5에 제공된 사양과 관련하여 유효한 서명을 거부하는 것이 가능합니다. 이는 DER 이외의 다른 규칙이 DigestInfo에 적용되는 경우에 발생합니다\(예: 기본 SEQUENCE 유형의 무한 길이 인코딩\). 이것이 실제로 문제가 될 가능성은 낮지만, 신중한 구현자는 PKCS #1 v1.5에 지정된 대로 BER 디코딩 작업을 기반으로 검증 작업을 채택하도록 선택할 수 있습니다. 이러한 방식으로 PKCS #1 v1.5를 기반으로 하는 모든 유효한 구현과의 호환성이 확보됩니다. 이러한 검증 작업은 기본 BER 인코딩이 DER 인코딩인지 여부와 서명이 이 문서에 제공된 사양과 관련하여 유효한지 여부를 나타내야 합니다.

---
## **10.  Security Considerations**

보안 고려 사항은 이 메모 전반에 걸쳐 논의됩니다.

---
## **11.  References**
---
### **11.1.  Normative References**

```text
   [GARNER]   Garner, H., "The Residue Number System", IRE Transactions
              on Electronic Computers, Volume EC-8, Issue 2, pp.
              140-147, DOI 10.1109/TEC.1959.5219515, June 1959.

   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", BCP 14, RFC 2119,
              DOI 10.17487/RFC2119, March 1997,
              <http://www.rfc-editor.org/info/rfc2119>.

   [RSA]      Rivest, R., Shamir, A., and L. Adleman, "A Method for
              Obtaining Digital Signatures and Public-Key
              Cryptosystems", Communications of the ACM, Volume 21,
              Issue 2, pp. 120-126, DOI 10.1145/359340.359342, February
              1978.
```

---
### **11.2.  Informative References**

```text
   [ANSIX944] ANSI, "Key Establishment Using Integer Factorization
              Cryptography", ANSI X9.44-2007, August 2007.

   [BKS]      Bleichenbacher, D., Kaliski, B., and J. Staddon, "Recent
              Results on PKCS #1: RSA Encryption Standard", RSA
              Laboratories, Bulletin No. 7, June 1998.

   [BLEICHENBACHER]
              Bleichenbacher, D., "Chosen Ciphertext Attacks Against
              Protocols Based on the RSA Encryption Standard PKCS #1",
              Lecture Notes in Computer Science, Volume 1462, pp. 1-12,
              1998.

   [CHOSEN]   Desmedt, Y. and A. Odlyzko, "A Chosen Text Attack on the
              RSA Cryptosystem and Some Discrete Logarithm Schemes",
              Lecture Notes in Computer Science, Volume 218, pp.
              516-522, 1985.

   [COCHRAN]  Cochran, M., "Notes on the Wang et al. 2^63 SHA-1
              Differential Path", Cryptology ePrint Archive: Report
              2007/474, August 2008, <http://eprint.iacr.org/2007/474>.

   [FASTDEC]  Quisquater, J. and C. Couvreur, "Fast Decipherment
              Algorithm for RSA Public-Key Cryptosystem", Electronic
              Letters, Volume 18, Issue 21, pp. 905-907,
              DOI 10.1049/el:19820617, October 1982.

   [FDH]      Coron, J., "On the Exact Security of Full Domain Hash",
              Lecture Notes in Computer Science, Volume 1880, pp.
              229-235, 2000.

   [FOPS]     Fujisaki, E., Okamoto, T., Pointcheval, D., and J. Stern,
              "RSA-OAEP is Secure under the RSA Assumption", Lecture
              Notes in Computer Science, Volume 2139, pp. 260-274,
              August 2001.

   [FORGERY]  Coppersmith, D., Halevi, S., and C. Jutla, "ISO 9796-1 and
              the new forgery strategy", rump session of Crypto, August
              1999.

   [HAASTAD]  Haastad, J., "Solving Simultaneous Modular Equations of
              Low Degree", SIAM Journal on Computing, Volume 17,
              Issue 2, pp. 336-341, DOI 10.1137/0217019, April 1988.

   [HANDBOOK] Menezes, A., van Oorschot, P., and S. Vanstone, "Handbook
              of Applied Cryptography", CRC Press, ISBN: 0849385237,
              1996.

   [HASHID]   Kaliski, B., "On Hash Function Firewalls in Signature
              Schemes", Lecture Notes in Computer Science, Volume 2271,
              pp. 1-16, DOI 10.1007/3-540-45760-7_1, February 2002.

   [IEEE1363] IEEE, "Standard Specifications for Public Key
              Cryptography", IEEE Std 1363-2000,
              DOI 10.1109/IEEESTD.2000.92292, August 2000,
              <http://ieeexplore.ieee.org/document/891000/>.

   [IEEE1363A]
              IEEE, "Standard Specifications for Public Key Cryptography
              - Amendment 1: Additional Techniques", IEEE Std 1363a-
              2004, DOI 10.1109/IEEESTD.2004.94612, September 2004,
              <http://ieeexplore.ieee.org/document/1335427/>.

   [ISO18033] International Organization for Standardization,
              "Information technology -- Security techniques --
              Encryption algorithms - Part 2: Asymmetric ciphers", ISO/
              IEC 18033-2:2006, May 2006.

   [ISO9594]  International Organization for Standardization,
              "Information technology - Open Systems Interconnection -
              The Directory: Public-key and attribute certificate
              frameworks", ISO/IEC 9594-8:2008, December 2008.

   [ISO9796]  International Organization for Standardization,
              "Information technology - Security techniques - Digital
              signature schemes giving message recovery - Part 2:
              Integer factorization based mechanisms",
              ISO/IEC 9796-2:2010, December 2010.

   [JONSSON]  Jonsson, J., "Security Proofs for the RSA-PSS Signature
              Scheme and Its Variants", Cryptology ePrint
              Archive: Report 2001/053, March 2002,
              <http://eprint.iacr.org/2001/053>.

   [LOWEXP]   Coppersmith, D., Franklin, M., Patarin, J., and M. Reiter,
              "Low-Exponent RSA with Related Messages", Lecture Notes in
              Computer Science, Volume 1070, pp. 1-9, 1996.

   [MANGER]   Manger, J., "A Chosen Ciphertext Attack on RSA Optimal
              Asymmetric Encryption Padding (OAEP) as Standardized in
              PKCS #1 v2.0", Lecture Notes in Computer Science, Volume
              2139, pp. 230-238, DOI 10.1007/3-540-44647-8_14, 2001.

   [MD4]      Dobbertin, H., "Cryptanalysis of MD4", Lecture Notes in
              Computer Science, Volume 1039, pp. 53-69,
              DOI 10.1007/3-540-60865-6_43, 1996.

   [MD4FIRST] Dobbertin, H., "The First Two Rounds of MD4 are Not One-
              Way", Lecture Notes in Computer Science, Volume 1372, pp.
              284-292, DOI 10.1007/3-540-69710-1_19, March 1998.

   [MD4LAST]  den Boer, B. and A. Bosselaers, "An Attack on the Last Two
              Rounds of MD4", Lecture Notes in Computer Science, Volume
              576, pp. 194-203, DOI 10.1007/3-540-46766-1_14, 1992.

   [NEWATTACK]
              Coron, J., Joye, M., Naccache, D., and P. Paillier, "New
              Attacks on PKCS #1 v1.5 Encryption", Lecture Notes in
              Computer Science, Volume 1807, pp. 369-381,
              DOI 10.1007/3-540-45539-6_25, May 2000.

   [OAEP]     Bellare, M. and P. Rogaway, "Optimal Asymmetric Encryption
              - How to Encrypt with RSA", Lecture Notes in Computer
              Science, Volume 950, pp. 92-111, November 1995.

   [PA98]     Bellare, M., Desai, A., Pointcheval, D., and P. Rogaway,
              "Relations Among Notions of Security for Public-Key
              Encryption Schemes", Lecture Notes in Computer
              Science, Volume 1462, pp. 26-45, DOI 10.1007/BFb0055718,
              1998.

   [PADDING]  Coron, J., Naccache, D., and J. Stern, "On the Security of
              RSA Padding", Lecture Notes in Computer Science, Volume
              1666, pp. 1-18, DOI 10.1007/3-540-48405-1_1, December
              1999.

   [PKCS1_22] RSA Laboratories, "PKCS #1: RSA Cryptography Standard
              Version 2.2", October 2012.

   [PREFIX]   Stevens, M., Lenstra, A., and B. de Weger, "Chosen-prefix
              collisions for MD5 and applications", International
              Journal of Applied Cryptography, Volume 2, No. 4, pp.
              322-359, July 2012.

   [PSS]      Bellare, M. and P. Rogaway, "PSS: Provably Secure Encoding
              Method for Digital Signatures", Submission to IEEE P1363a,
              August 1998, <http://grouper.ieee.org/groups/1363/
              P1363a/contributions/pss-submission.pdf>.

   [PSSPROOF] Coron, J., "Optimal Security Proofs for PSS and Other
              Signature Schemes", Lecture Notes in Computer
              Science, Volume 2332, pp. 272-287,
              DOI 10.1007/3-540-46035-7_18, 2002.

   [RFC1319]  Kaliski, B., "The MD2 Message-Digest Algorithm", RFC 1319,
              DOI 10.17487/RFC1319, April 1992,
              <http://www.rfc-editor.org/info/rfc1319>.

   [RFC1321]  Rivest, R., "The MD5 Message-Digest Algorithm", RFC 1321,
              DOI 10.17487/RFC1321, April 1992,
              <http://www.rfc-editor.org/info/rfc1321>.

   [RFC2313]  Kaliski, B., "PKCS #1: RSA Encryption Version 1.5",
              RFC 2313, DOI 10.17487/RFC2313, March 1998,
              <http://www.rfc-editor.org/info/rfc2313>.

   [RFC2315]  Kaliski, B., "PKCS #7: Cryptographic Message Syntax
              Version 1.5", RFC 2315, DOI 10.17487/RFC2315, March 1998,
              <http://www.rfc-editor.org/info/rfc2315>.

   [RFC2437]  Kaliski, B. and J. Staddon, "PKCS #1: RSA Cryptography
              Specifications Version 2.0", RFC 2437,
              DOI 10.17487/RFC2437, October 1998,
              <http://www.rfc-editor.org/info/rfc2437>.

   [RFC3447]  Jonsson, J. and B. Kaliski, "Public-Key Cryptography
              Standards (PKCS) #1: RSA Cryptography Specifications
              Version 2.1", RFC 3447, DOI 10.17487/RFC3447, February
              2003, <http://www.rfc-editor.org/info/rfc3447>.

   [RFC5246]  Dierks, T. and E. Rescorla, "The Transport Layer Security
              (TLS) Protocol Version 1.2", RFC 5246,
              DOI 10.17487/RFC5246, August 2008,
              <http://www.rfc-editor.org/info/rfc5246>.

   [RFC5652]  Housley, R., "Cryptographic Message Syntax (CMS)", STD 70,
              RFC 5652, DOI 10.17487/RFC5652, September 2009,
              <http://www.rfc-editor.org/info/rfc5652>.

   [RFC5958]  Turner, S., "Asymmetric Key Packages", RFC 5958,
              DOI 10.17487/RFC5958, August 2010,
              <http://www.rfc-editor.org/info/rfc5958>.

   [RFC6149]  Turner, S. and L. Chen, "MD2 to Historic Status",
              RFC 6149, DOI 10.17487/RFC6149, March 2011,
              <http://www.rfc-editor.org/info/rfc6149>.

   [RFC7292]  Moriarty, K., Ed., Nystrom, M., Parkinson, S., Rusch, A.,
              and M. Scott, "PKCS #12: Personal Information Exchange
              Syntax v1.1", RFC 7292, DOI 10.17487/RFC7292, July 2014,
              <http://www.rfc-editor.org/info/rfc7292>.

   [RSARABIN] Bellare, M. and P. Rogaway, "The Exact Security of Digital
              Signatures - How to Sign with RSA and Rabin", Lecture
              Notes in Computer Science, Volume 1070, pp. 399-416,
              DOI 10.1007/3-540-68339-9_34, 1996.

   [RSATLS]   Jonsson, J. and B. Kaliski, "On the Security of RSA
              Encryption in TLS", Lecture Notes in Computer
              Science, Volume 2442, pp. 127-142,
              DOI 10.1007/3-540-45708-9_9, 2002.

   [SHA1CRYPT]
              Wang, X., Yao, A., and F. Yao, "Cryptanalysis on SHA-1",
              Lecture Notes in Computer Science, Volume 2442, pp.
              127-142, February 2005,
              <http://csrc.nist.gov/groups/ST/hash/documents/
              Wang_SHA1-New-Result.pdf>.

   [SHOUP]    Shoup, V., "OAEP Reconsidered (Extended Abstract)",
              Lecture Notes in Computer Science, Volume 2139, pp.
              239-259, DOI 10.1007/3-540-44647-8_15, 2001.

   [SHS]      National Institute of Standards and Technology, "Secure
              Hash Standard (SHS)", FIPS PUB 180-4, August 2015,
              <http://dx.doi.org/10.6028/NIST.FIPS.180-4>.

   [SILVERMAN]
              Silverman, R., "A Cost-Based Security Analysis of
              Symmetric and Asymmetric Key Lengths", RSA
              Laboratories, Bulletin No. 13, 2000.

   [SIMMONS]  Simmons, G., "Subliminal Communication is Easy Using the
              DSA", Lecture Notes in Computer Science, Volume 765, pp.
              218-232, DOI 10.1007/3-540-48285-7_18, 1994.
```

---
# **Appendix A.  ASN.1 Syntax**
---
### **A.1.  RSA Key Representation**

이 섹션에서는 RSA 공개 및 개인 키에 대한 ASN.1 개체 식별자를 정의하고 RSAPublicKey 및 RSAPrivateKey 유형을 정의합니다. 이러한 정의의 의도된 적용에는 X.509 인증서, PKCS #8 \[RFC5958\] 및 PKCS #12 \[RFC7292\]가 포함됩니다.

객체 식별자 rsaEncryption은 부록 A.1.1 및 A.1.2에 정의된 대로 RSA 공개 키와 개인 키를 식별합니다. AlgorithmIdentifier 유형의 값에서 이 OID와 연관된 매개변수 필드는 NULL 유형의 값을 가져야 합니다.

```text
      rsaEncryption    OBJECT IDENTIFIER ::= { pkcs-1 1 }
```

이 섹션의 정의는 다중 프라임 RSA를 지원하도록 확장되었지만 이전 버전과도 호환됩니다.

---
#### **A.1.1.  RSA Public Key Syntax**

RSA 공개 키는 ASN.1 유형 RSAPublicKey로 표시되어야 합니다.

```text
         RSAPublicKey ::= SEQUENCE {
             modulus           INTEGER,  -- n
             publicExponent    INTEGER   -- e
         }
```

RSAPublicKey 유형의 필드는 다음과 같은 의미를 갖습니다.

- 모듈러스는 RSA 모듈러스 n입니다.

- publicExComponent는 RSA 공개 지수 e입니다.

---
#### **A.1.2.  RSA Private Key Syntax**

RSA 개인 키는 ASN.1 유형 RSAPrivateKey로 표시되어야 합니다.

```text
         RSAPrivateKey ::= SEQUENCE {
             version           Version,
             modulus           INTEGER,  -- n
             publicExponent    INTEGER,  -- e
             privateExponent   INTEGER,  -- d
             prime1            INTEGER,  -- p
             prime2            INTEGER,  -- q
             exponent1         INTEGER,  -- d mod (p-1)
             exponent2         INTEGER,  -- d mod (q-1)
             coefficient       INTEGER,  -- (inverse of q) mod p
             otherPrimeInfos   OtherPrimeInfos OPTIONAL
         }
```

RSAPrivateKey 유형의 필드는 다음과 같은 의미를 갖습니다.

- 버전은 이 문서의 향후 개정판과의 호환성을 위한 버전 번호입니다. 다중 소수가 사용되지 않는 한 이 버전의 문서에서는 0이 되어야 합니다. 이 경우에는 1이어야 합니다.

```text
            Version ::= INTEGER { two-prime(0), multi(1) }
               (CONSTRAINED BY
               {-- version must be multi if otherPrimeInfos present --})
```

- 모듈러스는 RSA 모듈러스 n입니다.

- publicExComponent는 RSA 공개 지수 e입니다.

- privateExComponent는 RSA 개인 지수입니다. d.

- prime1은 n의 소인수 p입니다.

- prime2는 n의 소인수 q입니다.

- 지수1은 d mod\(p - 1\)입니다.

- 지수2는 d mod\(q - 1\)입니다.

- 계수는 CRT 계수 q^\(-1\) mod p입니다.

- otherPrimeInfos에는 추가 소수 r\_3, ..., r\_u에 대한 정보가 순서대로 포함되어 있습니다. 버전이 0이면 생략되어야 하며 버전이 1이면 최소한 하나의 OtherPrimeInfo 인스턴스를 포함해야 합니다.

- OtherPrimeInfos ::= OtherPrimeInfo의 시퀀스 크기\(1..MAX\)

```text
            OtherPrimeInfo ::= SEQUENCE {
                prime             INTEGER,  -- ri
                exponent          INTEGER,  -- di
                coefficient       INTEGER   -- ti
            }
```

OtherPrimeInfo 유형의 필드에는 다음과 같은 의미가 있습니다.

- 소수는 n의 소인수 r\_i이며, 여기서 i \>= 3입니다.

- 지수는 d\_i = d mod \(r\_i - 1\)입니다.

- 계수는 CRT 계수입니다. t\_i = \(r\_1 \* r\_2 \* ... \* r\_\(i-1\)\)^\(-1\) mod r\_i.

참고: RSA 개인 키가 공개되거나 수정되지 않도록 보호하는 것이 중요합니다. 이러한 보호 기술은 이 문서의 범위를 벗어납니다. 개인 키 및 기타 암호화 데이터를 저장하고 배포하는 방법은 PKCS #12 및 #15에 설명되어 있습니다.

---
### **A.2.  Scheme Identification**

이 섹션에서는 암호화 및 서명 체계에 대한 개체 식별자를 정의합니다. PKCS #1 v1.5와 호환되는 구성표는 PKCS #1 v1.5와 동일한 정의를 갖습니다. 이러한 정의의 의도된 적용에는 X.509 인증서 및 PKCS #7이 포함됩니다.

다음은 PKCS #1 OID에 대한 유형 식별자 정의입니다.

```text
   PKCS1Algorithms    ALGORITHM-IDENTIFIER ::= {
       { OID rsaEncryption                PARAMETERS NULL } |
       { OID md2WithRSAEncryption         PARAMETERS NULL } |
       { OID md5WithRSAEncryption         PARAMETERS NULL } |
       { OID sha1WithRSAEncryption        PARAMETERS NULL } |
       { OID sha224WithRSAEncryption      PARAMETERS NULL } |
       { OID sha256WithRSAEncryption      PARAMETERS NULL } |
       { OID sha384WithRSAEncryption      PARAMETERS NULL } |
       { OID sha512WithRSAEncryption      PARAMETERS NULL } |
       { OID sha512-224WithRSAEncryption  PARAMETERS NULL } |
       { OID sha512-256WithRSAEncryption  PARAMETERS NULL } |
       { OID id-RSAES-OAEP   PARAMETERS RSAES-OAEP-params } |
       PKCS1PSourceAlgorithms                               |
       { OID id-RSASSA-PSS   PARAMETERS RSASSA-PSS-params },
       ...  -- Allows for future expansion --
   }
```

---
#### **A.2.1.  RSAES-OAEP**

객체 식별자 id-RSAES-OAEP는 RSAES-OAEP 암호화 체계를 식별합니다.

```text
       id-RSAES-OAEP    OBJECT IDENTIFIER ::= { pkcs-1 7 }
```

AlgorithmIdentifier 유형의 값에서 이 OID와 연관된 매개변수 필드는 RSAES-OAEP-params 유형의 값을 가져야 합니다.

```text
   RSAES-OAEP-params ::= SEQUENCE {
       hashAlgorithm      [0] HashAlgorithm     DEFAULT sha1,
       maskGenAlgorithm   [1] MaskGenAlgorithm  DEFAULT mgf1SHA1,
       pSourceAlgorithm   [2] PSourceAlgorithm  DEFAULT pSpecifiedEmpty
   }
```

RSAES-OAEP-params 유형의 필드는 다음과 같은 의미를 갖습니다.

- hashAlgorithm은 해시 함수를 식별합니다. 이는 OAEP-PSSDigestAlgorithms 세트에 OID가 있는 알고리즘 ID여야 합니다. 지원되는 해시 함수에 대한 설명은 부록 B.1을 참조하세요.

```text
       HashAlgorithm ::= AlgorithmIdentifier {
          {OAEP-PSSDigestAlgorithms}
       }

       OAEP-PSSDigestAlgorithms    ALGORITHM-IDENTIFIER ::= {
           { OID id-sha1       PARAMETERS NULL }|
           { OID id-sha224     PARAMETERS NULL }|
           { OID id-sha256     PARAMETERS NULL }|
           { OID id-sha384     PARAMETERS NULL }|
           { OID id-sha512     PARAMETERS NULL }|
           { OID id-sha512-224 PARAMETERS NULL }|
           { OID id-sha512-256 PARAMETERS NULL },
           ...  -- Allows for future expansion --
       }
```

기본 해시 함수는 SHA-1입니다.

```text
       sha1    HashAlgorithm ::= {
           algorithm   id-sha1,
           parameters  SHA1Parameters : NULL
       }

       SHA1Parameters ::= NULL
```

- MaskGenAlgorithm은 마스크 생성 기능을 식별합니다. 이는 PKCS1MGFAlgorithms 세트에서 OID를 갖는 알고리즘 ID여야 하며, 이 버전에서는 MGF1 마스크 생성 기능을 식별하는 id-mgf1로 구성됩니다\(부록 B.2.1 참조\). id-mgf1과 연관된 매개변수 필드는 MGF1이 기반으로 하는 해시 함수를 식별하는 OAEP-PSSDigestAlgorithms 세트의 OID가 있는 알고리즘 ID여야 합니다.

```text
       MaskGenAlgorithm ::= AlgorithmIdentifier { {PKCS1MGFAlgorithms} }

       PKCS1MGFAlgorithms    ALGORITHM-IDENTIFIER ::= {
           { OID id-mgf1 PARAMETERS HashAlgorithm },
           ...  -- Allows for future expansion --
       }
```

- 기본 마스크 생성 기능은 SHA-1이 포함된 MGF1입니다.

```text
       mgf1SHA1    MaskGenAlgorithm ::= {
           algorithm   id-mgf1,
           parameters  HashAlgorithm : sha1
       }
```

- pSourceAlgorithm은 레이블 L의 소스\(및 값\)를 식별합니다. 이는 PKCS1PSourceAlgorithms 세트의 OID가 있는 알고리즘 ID여야 하며, 이 버전의 경우 레이블이 명시적으로 지정되었음을 나타내는 id-pSpecified로 구성됩니다. id-pSpecified와 연관된 매개변수 필드는 레이블을 포함하는 OCTET STRING 유형의 값을 가져야 합니다. 이 사양의 이전 버전에서는 "레이블" 대신 "인코딩 매개변수"라는 용어가 사용되었으므로 아래 유형의 이름이 사용되었습니다.

```text
       PSourceAlgorithm ::= AlgorithmIdentifier {
          {PKCS1PSourceAlgorithms}
       }

       PKCS1PSourceAlgorithms    ALGORITHM-IDENTIFIER ::= {
           { OID id-pSpecified PARAMETERS EncodingParameters },
           ...  -- Allows for future expansion --
       }

       id-pSpecified    OBJECT IDENTIFIER ::= { pkcs-1 9 }

       EncodingParameters ::= OCTET STRING(SIZE(0..MAX))
```

- 기본 레이블은 빈 문자열입니다\(따라서 lHash에는 빈 문자열의 해시가 포함됩니다\).

```text
       pSpecifiedEmpty    PSourceAlgorithm ::= {
           algorithm   id-pSpecified,
           parameters  EncodingParameters : emptyString
       }

       emptyString    EncodingParameters ::= ''H
```

RSAES-OAEP-params에 있는 필드의 모든 기본값이 사용되는 경우 알고리즘 식별자는 다음 값을 갖습니다.

```text
       rSAES-OAEP-Default-Identifier    RSAES-AlgorithmIdentifier ::= {
           algorithm   id-RSAES-OAEP,
           parameters  RSAES-OAEP-params : {
               hashAlgorithm       sha1,
               maskGenAlgorithm    mgf1SHA1,
               pSourceAlgorithm    pSpecifiedEmpty
           }
       }

       RSAES-AlgorithmIdentifier ::= AlgorithmIdentifier  {
           {PKCS1Algorithms}
       }
```

---
#### **A.2.2.  RSAES-PKCS-v1_5**

객체 식별자 rsaEncryption\(부록 A.1 참조\)은 RSAES-PKCS1-v1\_5 암호화 체계를 식별합니다. AlgorithmIdentifier 유형의 값에서 이 OID와 연관된 매개변수 필드는 NULL 유형의 값을 가져야 합니다. 이는 PKCS #1 v1.5와 동일합니다.

```text
       rsaEncryption    OBJECT IDENTIFIER ::= { pkcs-1 1 }
```

---
#### **A.2.3.  RSASSA-PSS**

개체 식별자 id-RSASSA-PSS는 RSASSA-PSS 암호화 체계를 식별합니다.

```text
       id-RSASSA-PSS    OBJECT IDENTIFIER ::= { pkcs-1 10 }
```

AlgorithmIdentifier 유형의 값에서 이 OID와 연관된 매개변수 필드는 RSASSA-PSS-params 유형의 값을 가져야 합니다.

```text
   RSASSA-PSS-params ::= SEQUENCE {
       hashAlgorithm      [0] HashAlgorithm      DEFAULT sha1,
       maskGenAlgorithm   [1] MaskGenAlgorithm   DEFAULT mgf1SHA1,
       saltLength         [2] INTEGER            DEFAULT 20,
       trailerField       [3] TrailerField       DEFAULT trailerFieldBC
   }
```

RSASSA-PSS-params 유형의 필드는 다음과 같은 의미를 갖습니다.

- hashAlgorithm은 해시 함수를 식별합니다. 이는 OAEP-PSSDigestAlgorithms 집합의 OID가 있는 알고리즘 ID여야 합니다\(부록 A.2.1 참조\). 기본 해시 함수는 SHA-1입니다.

- MaskGenAlgorithm은 마스크 생성 기능을 식별합니다. 이는 PKCS1MGFAlgorithms 세트의 OID를 갖는 알고리즘 ID여야 합니다\(부록 A.2.1 참조\). 기본 마스크 생성 기능은 SHA-1이 포함된 MGF1입니다. MGF1의 경우\(더 일반적으로는 해시 함수를 기반으로 하는 다른 마스크 생성 함수의 경우\) 기본 해시 함수가 hashAlgorithm에 의해 식별된 것과 동일할 것을 권장합니다. 추가 설명은 섹션 9.1의 참고 2를 참조하십시오.

- saltLength는 솔트의 옥텟 길이입니다. 이는 정수여야 합니다. 지정된 hashAlgorithm의 경우 saltLength의 기본값은 해시 값의 옥텟 길이입니다. RSASSA-PSS-params 유형의 다른 필드와 달리 saltLength는 지정된 RSA 키 쌍에 대해 수정될 필요가 없습니다.

- trailField는 IEEE 1363a \[IEEE1363A\]와의 호환성을 위한 트레일러 필드 번호입니다. 이 버전의 문서에서는 16진수 값 0xbc를 갖는 트레일러 필드를 나타내는 1이어야 합니다. 다른 트레일러 필드\(IEEE 1363a의 트레일러 필드 HashID || 0xcc 포함\)는 이 문서에서 지원되지 않습니다.

```text
       TrailerField ::= INTEGER { trailerFieldBC(1) }
```

RSASSA-PSS-params의 hashAlgorithm, MaskGenAlgorithm 및 trailField 필드의 기본값이 사용되는 경우 알고리즘 식별자는 다음 값을 갖습니다.

```text
       rSASSA-PSS-Default-Identifier    RSASSA-AlgorithmIdentifier ::= {
           algorithm   id-RSASSA-PSS,
           parameters  RSASSA-PSS-params : {
               hashAlgorithm       sha1,
               maskGenAlgorithm    mgf1SHA1,
               saltLength          20,
               trailerField        trailerFieldBC
           }
       }

       RSASSA-AlgorithmIdentifier ::= AlgorithmIdentifier {
           {PKCS1Algorithms}
       }
```

참고: 일부 응용 프로그램에서는 서명 체계의 기본 해시 함수가 서명 체계의 나머지 작업과 별도로 식별됩니다. 예를 들어, PKCS #7 \[RFC2315\]에서는 해시 함수 식별자가 메시지 앞에 배치되고 "다이제스트 암호화" 알고리즘 식별자\(나머지 작업을 나타냄\)가 서명과 함께 전달됩니다. PKCS #7이 RSASSA-PSS 서명 체계를 지원하려면 해시 함수 다음에 RSASSA-PSS의 작업에 대해 개체 식별자를 정의해야 합니다\(RSASSA-PKCS1-v1\_5 체계의 RSAEncryption OID와 유사\). S/MIME CMS\(암호화 메시지 구문\) \[RFC5652\]는 다른 접근 방식을 취합니다. 해시 함수 식별자가 메시지 앞에 배치되더라도 전체 서명 체계에 대한 알고리즘 식별자는 CMS 서명과 함께 전달될 수 있습니다\(DSA 서명의 경우 수행됨\). 이 규칙에 따라 id-RSASSA-PSS OID를 사용하여 CMS에서 RSASSA-PSS 서명을 식별할 수 있습니다. CMS는 PKCS #7의 후속 버전으로 간주되고 RSASSA-PSS에 대한 지원 추가와 같은 새로운 개발이 PKCS #7이 아닌 CMS에 대해 추진될 예정이므로 "나머지" RSASSA-PSS에 대한 OID는 정의되지 않습니다. 이 버전의 PKCS #1에서는.

---
#### **A.2.4.  RSASSA-PKCS-v1_5**

RSASSA-PKCS1-v1\_5의 객체 식별자는 다음 중 하나여야 합니다. OID 선택은 해시 알고리즘 선택\(MD2, MD5, SHA-1, SHA-224, SHA-256, SHA-384, SHA-512, SHA-512/224 또는 SHA-512/256\)에 따라 달라집니다. MD2 또는 MD5를 사용하는 경우 OID는 PKCS #1 v1.5와 동일합니다. 각 OID에 대해 AlgorithmIdentifier 유형의 값에서 이 OID와 연관된 매개변수 필드는 NULL 유형의 값을 가져야 합니다. OID는 다음 표에 따라 선택해야 합니다.

```text
         Hash algorithm   OID
         ------------------------------------------------------------
         MD2              md2WithRSAEncryption        ::= {pkcs-1 2}
         MD5              md5WithRSAEncryption        ::= {pkcs-1 4}
         SHA-1            sha1WithRSAEncryption       ::= {pkcs-1 5}
         SHA-256          sha224WithRSAEncryption     ::= {pkcs-1 14}
         SHA-256          sha256WithRSAEncryption     ::= {pkcs-1 11}
         SHA-384          sha384WithRSAEncryption     ::= {pkcs-1 12}
         SHA-512          sha512WithRSAEncryption     ::= {pkcs-1 13}
         SHA-512/224      sha512-224WithRSAEncryption ::= {pkcs-1 15}
         SHA-512/256      sha512-256WithRSAEncryption ::= {pkcs-1 16}
```

EMSA-PKCS1-v1\_5 인코딩 방법에는 DigestInfo 유형의 ASN.1 값이 포함됩니다. 여기서 DigestInfo 유형에는 다음 구문이 있습니다.

```text
       DigestInfo ::= SEQUENCE {
           digestAlgorithm DigestAlgorithm,
           digest OCTET STRING
       }
```

DigestAlgorithm은 해시 함수를 식별하며 PKCS1-v1-5DigestAlgorithms 세트의 OID가 있는 알고리즘 ID여야 합니다. 지원되는 해시 함수에 대한 설명은 부록 B.1을 참조하세요.

```text
       DigestAlgorithm ::= AlgorithmIdentifier {
          {PKCS1-v1-5DigestAlgorithms}
       }

       PKCS1-v1-5DigestAlgorithms    ALGORITHM-IDENTIFIER ::= {
           { OID id-md2        PARAMETERS NULL }|
           { OID id-md5        PARAMETERS NULL }|
           { OID id-sha1       PARAMETERS NULL }|
           { OID id-sha224     PARAMETERS NULL }|
           { OID id-sha256     PARAMETERS NULL }|
           { OID id-sha384     PARAMETERS NULL }|
           { OID id-sha512     PARAMETERS NULL }|
           { OID id-sha512-224 PARAMETERS NULL }|
           { OID id-sha512-256 PARAMETERS NULL }
       }
```

---
# **Appendix B.  Supporting Techniques**

이 섹션에서는 섹션 7의 암호화 체계와 섹션 9의 인코딩 방법을 지원하는 기본 기능의 몇 가지 예를 제공합니다. 여기에는 기존 애플리케이션과의 호환성 및 새로운 기술로의 마이그레이션을 허용하는 다양한 기술이 제공됩니다. 이러한 지원 기술은 애플리케이션을 구현하는 데 적합하지만 어느 것도 구현해야 하는 것은 아닙니다. 특정 지원 기술을 지정하는 PKCS #1 v2.2용 프로필이 개발될 것으로 예상됩니다.

이 섹션에서는 지원 기술에 대한 개체 식별자도 제공합니다.

---
### **B.1.  Hash Functions**

해시 함수는 섹션 7과 9에 포함된 작업에 사용됩니다. 해시 함수는 결정적입니다. 즉, 출력이 입력에 의해 완전히 결정된다는 의미입니다. 해시 함수는 가변 길이의 옥텟 문자열을 사용하여 고정 길이 옥텟 문자열을 생성합니다. 섹션 7과 9에 포함된 작업에 사용되는 해시 함수는 일반적으로 충돌 방지 기능을 갖추어야 합니다. 이는 동일한 출력을 생성하는 해시 함수에 대한 두 개의 서로 다른 입력을 찾는 것이 불가능하다는 것을 의미합니다. 충돌 방지 해시 함수는 단방향이라는 바람직한 속성도 가지고 있습니다. 이는 출력이 주어지면 해시가 지정된 출력인 입력을 찾는 것이 불가능하다는 것을 의미합니다. 요구 사항 외에도 해시 함수는 의사 난수 출력이 있는 마스크 생성 함수\(부록 B.2\)를 생성해야 합니다.

이 문서의 인코딩 방법에 대한 예로 MD2 \[RFC1319\]\(\[RFC6149\]에 의해 폐기됨\), MD5 \[RFC1321\], SHA-1, SHA-224, SHA-256, SHA-384, SHA-512, SHA-512/224 및 SHA-512/256 \[SHS\]. RSAES-OAEP 암호화 방식 및 EMSA-PSS 인코딩 방법의 경우 SHA-1, SHA-224, SHA-256, SHA-384, SHA-512, SHA-512/224 및 SHA-512/256만 권장됩니다. EMSA-PKCS1-v1\_5 인코딩 방법의 경우 SHA-224, SHA-256, SHA-384, SHA-512, SHA-512/224 및 SHA-512/256이 새 애플리케이션에 권장됩니다. MD2, MD5 및 SHA-1은 PKCS #1 v1.5를 기반으로 하는 기존 애플리케이션과의 호환성을 위해서만 권장됩니다.

객체 식별자 id-md2, id-md5, id-sha1, id-sha224, id-sha256, id-sha384, id-sha512, id-sha512/224 및 id-sha512/256은 각각의 해시 함수를 식별합니다.

```text
       id-md2      OBJECT IDENTIFIER ::= {
           iso (1) member-body (2) us (840) rsadsi (113549)
           digestAlgorithm (2) 2
       }

       id-md5      OBJECT IDENTIFIER ::= {
           iso (1) member-body (2) us (840) rsadsi (113549)
           digestAlgorithm (2) 5
       }

       id-sha1    OBJECT IDENTIFIER ::= {
           iso(1) identified-organization(3) oiw(14) secsig(3)
            algorithms(2) 26
       }

       id-sha224    OBJECT IDENTIFIER ::= {
           joint-iso-itu-t (2) country (16) us (840) organization (1)
           gov (101) csor (3) nistalgorithm (4) hashalgs (2) 4
       }

       id-sha256    OBJECT IDENTIFIER ::= {
           joint-iso-itu-t (2) country (16) us (840) organization (1)
           gov (101) csor (3) nistalgorithm (4) hashalgs (2) 1
       }

       id-sha384    OBJECT IDENTIFIER ::= {
           joint-iso-itu-t (2) country (16) us (840) organization (1)
           gov (101) csor (3) nistalgorithm (4) hashalgs (2) 2
       }

       id-sha512    OBJECT IDENTIFIER ::= {
           joint-iso-itu-t (2) country (16) us (840) organization (1)
           gov (101) csor (3) nistalgorithm (4) hashalgs (2) 3
       }

       id-sha512-224    OBJECT IDENTIFIER ::= {
           joint-iso-itu-t (2) country (16) us (840) organization (1)
           gov (101) csor (3) nistalgorithm (4) hashalgs (2) 5
       }

       id-sha512-256    OBJECT IDENTIFIER ::= {
           joint-iso-itu-t (2) country (16) us (840) organization (1)
           gov (101) csor (3) nistalgorithm (4) hashalgs (2) 6
       }
```

AlgorithmIdentifier 유형의 값에서 이러한 OID와 연관된 매개변수 필드는 NULL 유형의 값을 가져야 합니다.

AlgorithmIdentifier 유형의 값에서 id-md2 및 id-md5와 연관된 매개변수 필드는 NULL 유형의 값을 가져야 합니다.

id-sha1, id-sha224, id-sha256, id-sha384, id-sha512, id-sha512/224 및 id-sha512/256과 관련된 매개변수 필드는 일반적으로 생략되어야 하지만, 있는 경우 NULL 유형의 값입니다.

이는 NIST가 원래 발표한 정의와 일치하기 위한 것입니다. SHA 알고리즘의 경우 구현은 매개변수 없이 및 NULL 매개변수를 사용하여 AlgorithmIdentifier 값을 허용해야 합니다.

예외: EMSA-PKCS1-v1\_5\(섹션 9.2 참조\)에서 DigestInfoValue 형식을 지정할 때 id-sha1, id-sha224, id-sha256, id-sha384, id-sha512, id-sha512/224 및 id-sha512/256은 NULL 유형의 값을 가져야 합니다. 이는 기존 구현과 IEEE 1363a \[IEEE1363A\]에도 반영된 EMSA-PKCS1-v1\_5에 대해 이미 공개된 수치 정보 값과의 호환성을 유지하기 위한 것입니다.

참고: PKCS #1 버전 1.5에서는 서명 체계에 MD4를 사용할 수도 있습니다. MD4의 암호 분석은 그 사이에 크게 발전했습니다. 예를 들어, Dobbertin \[MD4\]는 MD4에 대한 충돌을 찾는 방법과 MD4의 처음 두 라운드가 단방향 \[MD4FIRST\]이 아님을 보여주었습니다. 이러한 결과와 기타 결과\(예: \[MD4LAST\]\)로 인해 MD4는 권장되지 않습니다.

특히 Stevens et al.의 발견 이후 MD2 및 MD5의 암호 분석이 더욱 발전했습니다. \[PREFIX\] 선택됨-

MD5의 접두사 충돌. MD2 및 MD5는 암호화된 것으로 간주되어 기존 애플리케이션에서 제거되어야 합니다. 이 표준 버전은 이전 버전과의 호환성을 이유로 MD2 및 MD5를 지원합니다.

SHA-1의 암호화 분석에도 발전이 있었습니다. 특히 Wang et al. \[SHA1CRYPT\]\(M. Cochran의 분석 \[COCHRAN\]에서 독립적으로 검증됨\)은 SHA-1에서 충돌을 찾기 위해 차등 경로를 사용하는 것에 대해 연구했으며, 이는 SHA-1 해싱 알고리즘의 보안 강도가 크게 감소했다는 결론을 내렸습니다. 그러나 이러한 감소는 기존 애플리케이션에서 SHA-1을 제거할 만큼 충분히 중요하지 않으며 이전 버전과의 호환성을 위해서만 사용이 권장됩니다.

이러한 문제를 해결하기 위해 새 애플리케이션에는 SHA-224, SHA-256, SHA-384, SHA-512, SHA-512/224 및 SHA-512/256만 권장됩니다. 현재 이러한 해시 함수에 대한 가장 잘 알려진 충돌 공격은 복잡성이 2L/2인 일반 공격입니다. 여기서 L은 해시 출력의 비트 길이입니다. 이 문서의 서명 체계의 경우 충돌 공격은 서명 위조로 쉽게 변환됩니다. 따라서 L/2 값은 최소한 서명 방식의 비트 단위로 원하는 보안 수준과 같아야 합니다\(B 비트의 보안 수준은 최선의 공격이 복잡도 2B를 가짐을 의미함\). RSAES-OAEP에도 동일한 경험 법칙을 적용할 수 있습니다. 시드의 비트 길이\(해시 출력의 비트 길이와 동일\)가 원하는 보안 수준\(비트\)의 두 배인 것이 권장됩니다.

---
### **B.2.  Mask Generation Functions**

마스크 생성 기능은 가변 길이의 옥텟 문자열과 원하는 출력 길이를 입력으로 받아 원하는 길이의 옥텟 문자열을 출력합니다. 입력 및 출력 옥텟 문자열의 길이에 제한이 있을 수 있지만 일반적으로 이러한 범위는 매우 큽니다. 마스크 생성 기능은 결정적입니다. 옥텟 문자열 출력은 입력 옥텟 문자열에 의해 완전히 결정됩니다. 마스크 생성 함수의 출력은 의사 난수여야 합니다. 출력의 한 부분이 주어지고 입력이 아닌 경우 출력의 다른 부분을 예측하는 것이 불가능해야 합니다. RSAES-OAEP 및 RSASSA-PSS의 입증 가능한 보안은 마스크 생성 기능 출력의 무작위 특성에 의존하며, 이는 다시 기본 해시의 무작위 특성에 의존합니다.

여기에 하나의 마스크 생성 함수가 제공됩니다: MGF1은 해시 함수를 기반으로 합니다. MGF1은 IEEE 1363 \[IEEE1363\] 및 ANSI X9.44 \[ANSIX944\]에 정의된 마스크 생성 기능과 일치합니다. 이 문서의 향후 버전에서는 다른 마스크 생성 기능을 정의할 수 있습니다.

---
#### **B.2.1.  MGF1**

MGF1은 해시 함수를 기반으로 한 마스크 생성 함수입니다.

```text
   MGF1 (mgfSeed, maskLen)

   Options:

      Hash     hash function (hLen denotes the length in octets of
               the hash function output)

   Input:
```

- 마스크가 생성되는 mgfSeed 시드, 옥텟 문자열 마스크Len 의도된 길이\(마스크 옥텟 단위\), 최대 2^32 hLen

```text
   Output:

      mask     mask, an octet string of length maskLen

   Error: "mask too long"

   Steps:
```

1. MaskLen \> 2^32 hLen인 경우 "mask too long"을 출력하고 중지합니다.

1. T를 빈 옥텟 문자열로 둡니다.

1. 0에서 \ceil \(maskLen / hLen\) - 1까지의 카운터에 대해 다음을 수행합니다.

```text
       A.  Convert counter to an octet string C of length 4 octets (see
           Section 4.1):

              C = I2OSP (counter, 4) .

       B.  Concatenate the hash of the seed mgfSeed and C to the octet
           string T:

              T = T || Hash(mgfSeed || C) .
```

1. T의 선행 마스크 길이 옥텟을 옥텟 문자열 마스크로 출력합니다.

객체 식별자 id-mgf1은 MGF1 마스크 생성 기능을 식별합니다.

```text
      id-mgf1    OBJECT IDENTIFIER ::= { pkcs-1 8 }
```

AlgorithmIdentifier 유형의 값에서 이 OID와 연관된 매개변수 필드는 MGF1이 기반으로 하는 해시 함수를 식별하는 hashAlgorithm 유형의 값을 가져야 합니다.

---
# **Appendix C.  ASN.1 Module**

```text
   -- PKCS #1 v2.2 ASN.1 Module
   -- Revised October 27, 2012
```

-- 이 모듈은 OSS ASN.1 도구에 의해 -- ASN.1 표준을 준수하는지 확인되었습니다.

```text
   PKCS-1 {
       iso(1) member-body(2) us(840) rsadsi(113549) pkcs(1) pkcs-1(1)
       modules(0) pkcs-1(1)
   }

   DEFINITIONS EXPLICIT TAGS ::=

   BEGIN
```

-- 모두 내보내기 -- 이 모듈에 정의된 모든 유형과 값은 다른 ASN.1 모듈에서 사용하기 위해 내보내집니다.

```text
   IMPORTS

   id-sha224, id-sha256, id-sha384, id-sha512, id-sha512-224,
   id-sha512-256
       FROM NIST-SHA2 {
           joint-iso-itu-t(2) country(16) us(840) organization(1)
           gov(101) csor(3) nistalgorithm(4) hashAlgs(2)
       };

   -- ============================
   --   Basic object identifiers
   -- ============================

   -- The DER encoding of this in hexadecimal is:
   -- (0x)06 08
   --        2A 86 48 86 F7 0D 01 01
   --
   pkcs-1    OBJECT IDENTIFIER ::= {
       iso(1) member-body(2) us(840) rsadsi(113549) pkcs(1) 1
   }
```

-- -- AlgorithmIdentifier에서 rsaEncryption이 사용되는 경우,

```text
   -- the parameters MUST be present and MUST be NULL.
   --
   rsaEncryption    OBJECT IDENTIFIER ::= { pkcs-1 1 }

   --
   -- When id-RSAES-OAEP is used in an AlgorithmIdentifier, the
   -- parameters MUST be present and MUST be RSAES-OAEP-params.
   --
   id-RSAES-OAEP    OBJECT IDENTIFIER ::= { pkcs-1 7 }

   --
   -- When id-pSpecified is used in an AlgorithmIdentifier, the
   -- parameters MUST be an OCTET STRING.
   --
   id-pSpecified    OBJECT IDENTIFIER ::= { pkcs-1 9 }

   --
   -- When id-RSASSA-PSS is used in an AlgorithmIdentifier, the
   -- parameters MUST be present and MUST be RSASSA-PSS-params.
   --
   id-RSASSA-PSS    OBJECT IDENTIFIER ::= { pkcs-1 10 }

   --
   -- When the following OIDs are used in an AlgorithmIdentifier,
   -- the parameters MUST be present and MUST be NULL.
   --
   md2WithRSAEncryption         OBJECT IDENTIFIER ::= { pkcs-1 2 }
   md5WithRSAEncryption         OBJECT IDENTIFIER ::= { pkcs-1 4 }
   sha1WithRSAEncryption        OBJECT IDENTIFIER ::= { pkcs-1 5 }
   sha224WithRSAEncryption      OBJECT IDENTIFIER ::= { pkcs-1 14 }
   sha256WithRSAEncryption      OBJECT IDENTIFIER ::= { pkcs-1 11 }
   sha384WithRSAEncryption      OBJECT IDENTIFIER ::= { pkcs-1 12 }
   sha512WithRSAEncryption      OBJECT IDENTIFIER ::= { pkcs-1 13 }
   sha512-224WithRSAEncryption  OBJECT IDENTIFIER ::= { pkcs-1 15 }
   sha512-256WithRSAEncryption  OBJECT IDENTIFIER ::= { pkcs-1 16 }

   --
   -- This OID really belongs in a module with the secsig OIDs.
   --
   id-sha1    OBJECT IDENTIFIER ::= {
       iso(1) identified-organization(3) oiw(14) secsig(3) algorithms(2)
       26
   }
```

-- -- MD2 및 MD5에 대한 OID는 EMSA-PKCS1-v1\_5에서만 허용됩니다. -- id-md2 객체 식별자 ::= {

```text
       iso(1) member-body(2) us(840) rsadsi(113549) digestAlgorithm(2) 2
   }

   id-md5 OBJECT IDENTIFIER ::= {
       iso(1) member-body(2) us(840) rsadsi(113549) digestAlgorithm(2) 5
   }

   --
   -- When id-mgf1 is used in an AlgorithmIdentifier, the parameters
   -- MUST be present and MUST be a HashAlgorithm, for example, sha1.
   --
   id-mgf1    OBJECT IDENTIFIER ::= { pkcs-1 8 }

   -- ================
   --   Useful types
   -- ================

   ALGORITHM-IDENTIFIER ::= CLASS {
       &id    OBJECT IDENTIFIER  UNIQUE,
       &Type  OPTIONAL
   }
       WITH SYNTAX { OID &id [PARAMETERS &Type] }

   -- Note: the parameter InfoObjectSet in the following definitions
   -- allows a distinct information object set to be specified for sets
   -- of algorithms such as:
   -- DigestAlgorithms    ALGORITHM-IDENTIFIER ::= {
   --     { OID id-md2  PARAMETERS NULL }|
   --     { OID id-md5  PARAMETERS NULL }|
   --     { OID id-sha1 PARAMETERS NULL }
   -- }
   --

   AlgorithmIdentifier { ALGORITHM-IDENTIFIER:InfoObjectSet } ::=
       SEQUENCE {
         algorithm
             ALGORITHM-IDENTIFIER.&id({InfoObjectSet}),
         parameters
             ALGORITHM-IDENTIFIER.&Type({InfoObjectSet}{@.algorithm})
               OPTIONAL
   }

   -- ==============
   --   Algorithms
   -- ==============
```

-- -- EME-OAEP 및 EMSA-PSS 다이제스트 알고리즘이 허용됩니다.

```text
   --
   OAEP-PSSDigestAlgorithms    ALGORITHM-IDENTIFIER ::= {
       { OID id-sha1       PARAMETERS NULL }|
       { OID id-sha224     PARAMETERS NULL }|
       { OID id-sha256     PARAMETERS NULL }|
       { OID id-sha384     PARAMETERS NULL }|
       { OID id-sha512     PARAMETERS NULL }|
       { OID id-sha512-224 PARAMETERS NULL }|
       { OID id-sha512-256 PARAMETERS NULL },
       ...  -- Allows for future expansion --
   }

   --
   -- Allowed EMSA-PKCS1-v1_5 digest algorithms.
   --
   PKCS1-v1-5DigestAlgorithms    ALGORITHM-IDENTIFIER ::= {
       { OID id-md2        PARAMETERS NULL }|
       { OID id-md5        PARAMETERS NULL }|
       { OID id-sha1       PARAMETERS NULL }|
       { OID id-sha224     PARAMETERS NULL }|
       { OID id-sha256     PARAMETERS NULL }|
       { OID id-sha384     PARAMETERS NULL }|
       { OID id-sha512     PARAMETERS NULL }|
       { OID id-sha512-224 PARAMETERS NULL }|
       { OID id-sha512-256 PARAMETERS NULL }
   }
```

-- AlgorithmIdentifier에서 id-md2 및 id-md5가 사용되는 경우 -- 매개변수 필드는 NULL 유형의 값을 가져야 합니다.

-- id-sha1, id-sha224, id-sha256, id-sha384, id-sha512, -- id-sha512-224 및 id-sha512-256이 AlgorithmIdentifier에서 사용되는 경우 -- 매개변수\( 선택사항\) 생략되어야 합니다\(SHOULD\). 하지만 존재하는 경우 NULL 유형의 값을 가져야 합니다. -- 그러나 구현은 매개변수가 없는 경우와 NULL 매개변수가 있는 경우 모두 AlgorithmIdentifier 값을 허용해야 합니다.

-- 예외: EMSA-PKCS1-v1\_5에서 DigestInfoValue 형식을 지정하는 경우 --\(섹션 9.2 참조\), id-sha1, -- id-sha224, id-sha256, id-sha384, id-sha512, id와 관련된 매개변수 필드 -sha512-224 및 -- id-sha512-256은 NULL 유형의 값을 가져야 합니다. 이는 - 기존 구현 및 IEEE 1363a에도 반영된 EMSA-PKCS1-v1\_5에 대해 이미 공개된 수치 정보 값과의 호환성을 유지하기 위한 것입니다.

```text
   sha1    HashAlgorithm ::= {
       algorithm   id-sha1,
       parameters  SHA1Parameters : NULL

   }

   HashAlgorithm ::= AlgorithmIdentifier { {OAEP-PSSDigestAlgorithms} }

   SHA1Parameters ::= NULL

   --
   -- Allowed mask generation function algorithms.
   -- If the identifier is id-mgf1, the parameters are a HashAlgorithm.
   --
   PKCS1MGFAlgorithms    ALGORITHM-IDENTIFIER ::= {
       { OID id-mgf1 PARAMETERS HashAlgorithm },
       ...  -- Allows for future expansion --
   }

   --
   -- Default AlgorithmIdentifier for id-RSAES-OAEP.maskGenAlgorithm and
   -- id-RSASSA-PSS.maskGenAlgorithm.
   --
   mgf1SHA1    MaskGenAlgorithm ::= {
       algorithm   id-mgf1,
       parameters  HashAlgorithm : sha1
   }

   MaskGenAlgorithm ::= AlgorithmIdentifier { {PKCS1MGFAlgorithms} }

   --
   -- Allowed algorithms for pSourceAlgorithm.
   --
   PKCS1PSourceAlgorithms    ALGORITHM-IDENTIFIER ::= {
       { OID id-pSpecified PARAMETERS EncodingParameters },
       ...  -- Allows for future expansion --
   }

   EncodingParameters ::= OCTET STRING(SIZE(0..MAX))
```

-- -- 이 식별자는 레이블 L이 빈 문자열이므로 빈 문자열의 -- 다이제스트가 -- 마스킹 전에 RSA 블록에 나타남을 의미합니다. --

```text
   pSpecifiedEmpty    PSourceAlgorithm ::= {
       algorithm   id-pSpecified,
       parameters  EncodingParameters : emptyString
   }

   PSourceAlgorithm ::= AlgorithmIdentifier { {PKCS1PSourceAlgorithms} }

   emptyString    EncodingParameters ::= ''H

   --
   -- Type identifier definitions for the PKCS #1 OIDs.
   --
   PKCS1Algorithms    ALGORITHM-IDENTIFIER ::= {
       { OID rsaEncryption                PARAMETERS NULL } |
       { OID md2WithRSAEncryption         PARAMETERS NULL } |
       { OID md5WithRSAEncryption         PARAMETERS NULL } |
       { OID sha1WithRSAEncryption        PARAMETERS NULL } |
       { OID sha224WithRSAEncryption      PARAMETERS NULL } |
       { OID sha256WithRSAEncryption      PARAMETERS NULL } |
       { OID sha384WithRSAEncryption      PARAMETERS NULL } |
       { OID sha512WithRSAEncryption      PARAMETERS NULL } |
       { OID sha512-224WithRSAEncryption  PARAMETERS NULL } |
       { OID sha512-256WithRSAEncryption  PARAMETERS NULL } |
       { OID id-RSAES-OAEP   PARAMETERS RSAES-OAEP-params } |
       PKCS1PSourceAlgorithms                               |
       { OID id-RSASSA-PSS   PARAMETERS RSASSA-PSS-params },
       ...  -- Allows for future expansion --
   }

   -- ===================
   --   Main structures
   -- ===================

   RSAPublicKey ::= SEQUENCE {
       modulus           INTEGER,  -- n
       publicExponent    INTEGER   -- e
   }

   --
   -- Representation of RSA private key with information for the CRT
   -- algorithm.
   --
   RSAPrivateKey ::= SEQUENCE {
       version           Version,
       modulus           INTEGER,  -- n
       publicExponent    INTEGER,  -- e
       privateExponent   INTEGER,  -- d
       prime1            INTEGER,  -- p
       prime2            INTEGER,  -- q
       exponent1         INTEGER,  -- d mod (p-1)
       exponent2         INTEGER,  -- d mod (q-1)
       coefficient       INTEGER,  -- (inverse of q) mod p
       otherPrimeInfos   OtherPrimeInfos OPTIONAL
   }
```

버전 ::= INTEGER { two-prime\(0\), multi\(1\) } - \(CONSTRAINED BY {-- otherPrimeInfos가 있는 경우 버전은 다중이어야 합니다 --}\)

OtherPrimeInfos ::= OtherPrimeInfo의 시퀀스 크기\(1..MAX\)

```text
   OtherPrimeInfo ::= SEQUENCE {
       prime             INTEGER,  -- ri
       exponent          INTEGER,  -- di
       coefficient       INTEGER   -- ti
   }

   --
   -- AlgorithmIdentifier.parameters for id-RSAES-OAEP.
   -- Note that the tags in this Sequence are explicit.
   --
   RSAES-OAEP-params ::= SEQUENCE {
       hashAlgorithm      [0] HashAlgorithm     DEFAULT sha1,
       maskGenAlgorithm   [1] MaskGenAlgorithm  DEFAULT mgf1SHA1,
       pSourceAlgorithm   [2] PSourceAlgorithm  DEFAULT pSpecifiedEmpty
   }
```

-- -- 기본 RSAES-OAEP 알고리즘 식별자에 대한 식별자입니다. -- DER 인코딩은 16진수입니다. -- \(0x\)30 0D -- 06 09 -- 2A 86 48 86 F7 0D 01 01 07 -- 30 00 -- 기본값의 DER 인코딩은 "empty"입니다. ". --

```text
   rSAES-OAEP-Default-Identifier    RSAES-AlgorithmIdentifier ::= {
       algorithm   id-RSAES-OAEP,
       parameters  RSAES-OAEP-params : {
           hashAlgorithm       sha1,
           maskGenAlgorithm    mgf1SHA1,
           pSourceAlgorithm    pSpecifiedEmpty
       }
   }

   RSAES-AlgorithmIdentifier ::= AlgorithmIdentifier {
       {PKCS1Algorithms}
   }

   --

   -- AlgorithmIdentifier.parameters for id-RSASSA-PSS.
   -- Note that the tags in this Sequence are explicit.
   --
   RSASSA-PSS-params ::= SEQUENCE {
       hashAlgorithm      [0] HashAlgorithm      DEFAULT sha1,
       maskGenAlgorithm   [1] MaskGenAlgorithm   DEFAULT mgf1SHA1,
       saltLength         [2] INTEGER            DEFAULT 20,
       trailerField       [3] TrailerField       DEFAULT trailerFieldBC
   }

   TrailerField ::= INTEGER { trailerFieldBC(1) }

   --
   -- Identifier for default RSASSA-PSS algorithm identifier
   -- The DER encoding of this is in hexadecimal:
   -- (0x)30 0D
   --        06 09
   --           2A 86 48 86 F7 0D 01 01 0A
   --        30 00
   -- Notice that the DER encoding of default values is "empty".
   --
   rSASSA-PSS-Default-Identifier    RSASSA-AlgorithmIdentifier ::= {
       algorithm   id-RSASSA-PSS,
       parameters  RSASSA-PSS-params : {
           hashAlgorithm       sha1,
           maskGenAlgorithm    mgf1SHA1,
           saltLength          20,
           trailerField        trailerFieldBC
       }
   }

   RSASSA-AlgorithmIdentifier ::= AlgorithmIdentifier {
       {PKCS1Algorithms}
   }
```

-- -- EMSA-PKCS1-v1\_5 해시 식별자에 대한 구문입니다. -- DigestInfo ::= SEQUENCE { 다이제스트알고리즘 다이제스트알고리즘, 다이제스트 OCTET 문자열 }

```text
   DigestAlgorithm ::= AlgorithmIdentifier {
       {PKCS1-v1-5DigestAlgorithms}
   }

   END
```

---
# **Appendix D.  Revision History of PKCS #1**

```text
   Versions 1.0 - 1.5:
```

- 버전 1.0 - 1.3은 1991년 2월과 3월에 RSA Data Security, Inc.의 공개 키 암호화 표준 회의 참가자에게 배포되었습니다.

- 버전 1.4는 1991년 6월 3일 PKCS 최초 공개 릴리스의 일부였습니다. 버전 1.4는 NIST/OSI 구현자 워크숍 문서 SEC-SIG-91-18로 게시되었습니다.

- 버전 1.5에는 참조 업데이트 및 개정 내역 추가를 포함하여 몇 가지 편집 변경 사항이 통합되었습니다. 다음과 같은 실질적인 변경이 이루어졌습니다.

- \* 섹션 10: "RSA가 포함된 MD4" 서명 및 확인 프로세스가 추가되었습니다.

- \* 섹션 11: md4WithRSAEncryption 개체 식별자가 추가되었습니다.

- 버전 1.5는 \[RFC2313\]으로 다시 게시되었습니다\(나중에 \[RFC2437\]에 의해 폐기됨\).

```text
   Version 2.0:
```

- 버전 2.0은 문서 구조 측면에서 주요 편집 변경 사항을 통합하고 RSAES-OAEP 암호화 체계를 도입했습니다. 이 버전은 버전 1.5의 암호화 및 서명 프로세스를 계속 지원했지만, 그 사이에 암호화 분석의 발전으로 인해 해시 알고리즘 MD4가 더 이상 허용되지 않았습니다. 버전 2.0은 \[RFC2437\]로 다시 출판되었습니다\(나중에 \[RFC3447\]에 의해 폐기됨\).

```text
   Version 2.1:
```

- 버전 2.1에는 여러 편집 개선 사항과 함께 부록이 포함된 다중 프라임 RSA 및 RSASSA-PSS 서명 체계가 도입되었습니다. 이 버전은 버전 2.0의 구성표를 계속 지원합니다. 버전 2.1이 \[RFC3447\]로 다시 게시되었습니다.

```text
   Version 2.2:
```

- 버전 2.2에서는 FIPS 180-4 \[SHS\]에 맞춰 허용되는 해싱 알고리즘 목록을 업데이트하여 SHA-224, SHA-512/224 및 SHA-512/256을 추가합니다. 다음과 같은 실질적인 변경이 이루어졌습니다.

- \* sha224WithRSAEncryption, sha512-224WithRSAEncryption 및 sha512-256WithRSAEncryption에 대한 개체 식별자가 추가되었습니다.

- \* 이 버전은 버전 2.1의 구성표를 계속 지원합니다.

---
# **Appendix E.  About PKCS**

공개 키 암호화 표준은 공개 키 암호화 배포를 가속화할 목적으로 전 세계 보안 시스템 개발자와 협력하여 RSA 연구소에서 제작한 사양입니다. 공개 키 기술을 조기에 채택한 소규모 그룹과의 회의 결과로 1991년에 처음 출판된 PKCS 문서는 널리 참조되고 구현되었습니다. PKCS 시리즈의 기여는 ANSI X9 및 IEEE P1363 문서, PKIX, SET\(Secure Electronic Transaction\), S/MIME, SSL/TLS 및 WAP\(Wireless Application Protocol\)/WAP를 비롯한 많은 공식 및 사실상 표준의 일부가 되었습니다. 전송 계층 보안\(WTLS\).

대부분의 PKCS 문서의 추가 개발은 IETF를 통해 이루어집니다. 개선을 위한 제안을 환영합니다.

---
# **Acknowledgements**

이 문서는 RSA Security Inc.의 연구 센터인 RSA Laboratories의 기고를 바탕으로 작성되었습니다.

---
# **Authors' Addresses**

Kathleen M. Moriarty\(편집자\) EMC Corporation 176 South Street Hopkinton, MA 01748 United States of America

```text
   Email: kathleen.moriarty@emc.com
```

Burt Kaliski Verisign 12061 Bluemont Way 레스턴, VA 20190 미국

```text
   Email: bkaliski@verisign.com
   URI:   http://verisignlabs.com

   Jakob Jonsson
   Subset AB
   Munkbrogtan 4
   Stockholm  SE-11127
   Sweden

   Phone: +46 8 428 687 43
   Email: jakob.jonsson@subset.se

   Andreas Rusch
   RSA
   345 Queen Street
   Brisbane, QLD  4000
   Australia

   Email: andreas.rusch@rsa.com
```h@rsa.com
```
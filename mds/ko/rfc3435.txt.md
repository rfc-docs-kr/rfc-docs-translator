

```text
Network Working Group                                       F. Andreasen
Request for Comments: 3435                                     B. Foster
Obsoletes: 2705                                            Cisco Systems
Category: Informational                                     January 2003

                 Media Gateway Control Protocol (MGCP)
                              Version 1.0
```

---
# **Status of this Memo**

이 메모는 인터넷 커뮤니티에 대한 정보를 제공합니다. 어떤 종류의 인터넷 표준도 지정하지 않습니다. 이 메모의 배포는 무제한입니다.

---
# **Copyright Notice**

저작권\(C\)인터넷학회\(2003\). 판권 소유.

---
# **IESG Note**

이 문서는 커뮤니티에 정보를 제공하기 위해 게시되었습니다. 현재 여러 제품에 배포되고 있는 프로토콜을 설명합니다. 구현자는 IETF Megaco Working Group 및 ITU-T SG16에서 개발되었으며 IETF 및 ITU-T에서 요구 사항을 충족하는 표준 기반\(검토된 보안 고려 사항 포함\) 방식으로 간주되는 RFC 3015를 알고 있어야 합니다. MGCP가 해결하도록 설계된 요구 사항입니다.

---
# **Abstract**

본 문서에서는 분해된 멀티미디어 게이트웨이의 요소들 사이에 사용되는 응용 프로그래밍 인터페이스와 해당 프로토콜\(MGCP\)에 대해 설명합니다. 분해된 멀티미디어 게이트웨이는 통화 제어 "지능"을 포함하는 통화 에이전트와 TDM 음성에서 VoIP로의 변환과 같은 미디어 기능을 포함하는 미디어 게이트웨이로 구성됩니다.

미디어 게이트웨이에는 통화 에이전트가 다른 멀티미디어 엔드포인트와의 미디어 세션을 설정하고 제어하기 위해 연결을 생성, 수정 및 삭제할 수 있는 엔드포인트가 포함되어 있습니다. 또한 통화 에이전트는 엔드포인트에 특정 이벤트를 감지하고 신호를 생성하도록 지시할 수 있습니다. 엔드포인트는 서비스 상태의 변경 사항을 통화 에이전트에 자동으로 전달합니다. 또한 통화 에이전트는 엔드포인트와 엔드포인트의 연결을 감사할 수 있습니다.

기본 및 일반 MGCP 프로토콜은 이 문서에 정의되어 있지만 대부분의 미디어 게이트웨이는 특정 유형의 미디어 게이트웨이와 함께 사용하기에 적합한 프로토콜 확장을 정의하는 하나 이상의 MGCP 패키지를 구현해야 합니다. 이러한 패키지는 별도의 문서에 정의되어 있습니다.

---
# **Table of Contents**

```text
   1.     Introduction.................................................5
   1.1    Relation with the H.323 Standards............................7
   1.2    Relation with the IETF Standards.............................8
   1.3    Definitions..................................................9
   1.4    Conventions used in this Document............................9
   2.     Media Gateway Control Interface.............................10
   2.1    Model and Naming Conventions................................10
   2.1.1  Types of Endpoints..........................................10
   2.1.2  Endpoint Identifiers........................................14
   2.1.3  Calls and Connections.......................................16
   2.1.4  Names of Call Agents and Other Entities.....................22
   2.1.5  Digit Maps..................................................23
   2.1.6  Packages....................................................26
   2.1.7  Events and Signals..........................................28
   2.2    Usage of SDP................................................33
   2.3    Gateway Control Commands....................................33
   2.3.1  Overview of Commands........................................33
   2.3.2  EndpointConfiguration.......................................36
   2.3.3  NotificationRequest.........................................37
   2.3.4  Notify......................................................44
   2.3.5  CreateConnection............................................46
   2.3.6  ModifyConnection............................................52
   2.3.7  DeleteConnection (from the Call Agent)......................54
   2.3.8  DeleteConnection (from the gateway).........................58
   2.3.9  DeleteConnection (multiple connections from the Call Agent) 59
   2.3.10 AuditEndpoint...............................................60
   2.3.11 AuditConnection.............................................65
   2.3.12 RestartInProgress...........................................66
   2.4    Return Codes and Error Codes................................69
   2.5    Reason Codes................................................74
   2.6    Use of Local Connection Options and Connection Descriptors..75
   2.7    Resource Reservations.......................................77
   3.     Media Gateway Control Protocol..............................77
   3.1    General Description.........................................78
   3.2    Command Header..............................................79
   3.2.1  Command Line................................................79
   3.2.2  Parameter Lines.............................................82
   3.3    Format of response headers.................................101
   3.3.1  CreateConnection Response..................................104
   3.3.2  ModifyConnection Response..................................105
   3.3.3  DeleteConnection Response..................................106
   3.3.4  NotificationRequest Response...............................106
   3.3.5  Notify Response............................................106
   3.3.6  AuditEndpoint Response.....................................106
   3.3.7  AuditConnection Response...................................107
   3.3.8  RestartInProgress Response.................................108
   3.4    Encoding of the Session Description (SDP)..................108
   3.4.1  Usage of SDP for an Audio Service..........................110
   3.4.2  Usage of SDP for LOCAL Connections.........................110
   3.5    Transmission over UDP......................................111
   3.5.1  Providing the At-Most-Once Functionality...................112
   3.5.2  Transaction Identifiers and Three Ways Handshake...........113
   3.5.3  Computing Retransmission Timers............................114
   3.5.4  Maximum Datagram Size, Fragmentation and Reassembly........115
   3.5.5  Piggybacking...............................................116
   3.5.6  Provisional Responses......................................117
   4.     States, Failover and Race Conditions.......................119
   4.1    Failover Assumptions and Highlights........................119
   4.2    Communicating with Gateways................................121
   4.3    Retransmission, and Detection of Lost Associations:........122
   4.4    Race Conditions............................................126
   4.4.1  Quarantine List............................................127
   4.4.2  Explicit Detection.........................................133
   4.4.3  Transactional Semantics....................................134
   4.4.4  Ordering of Commands, and Treatment of Misorder............135
   4.4.5  Endpoint Service States....................................137
   4.4.6  Fighting the Restart Avalanche.............................140
   4.4.7  Disconnected Endpoints.....................................143
   4.4.8  Load Control in General....................................146
   5.     Security Requirements......................................147
   5.1    Protection of Media Connections............................148
   6.     Packages...................................................148
   6.1    Actions....................................................150
   6.2    BearerInformation..........................................150
   6.3    ConnectionModes............................................151
   6.4    ConnectionParameters.......................................151
   6.5    DigitMapLetters............................................151
   6.6    Events and Signals.........................................152
   6.6.1  Default and Reserved Events................................155
   6.7    ExtensionParameters........................................156
   6.8    LocalConnectionOptions.....................................157
   6.9    Reason Codes...............................................157
   6.10   RestartMethods.............................................158
   6.11   Return Codes...............................................158
   7.     Versions and Compatibility.................................158
   7.1    Changes from RFC 2705......................................158
   8.     Security Considerations....................................164
   9.     Acknowledgments............................................164
   10.    References.................................................164
   Appendix A: Formal Syntax Description of the Protocol.............167
   Appendix B: Base Package..........................................175
   B.1    Events.....................................................175
   B.2    Extension Parameters.......................................176
   B.2.1  PersistentEvents...........................................176
   B.2.2  NotificationState..........................................177
   B.3    Verbs......................................................177
   Appendix C: IANA Considerations...................................179
   C.1    New MGCP Package Sub-Registry..............................179
   C.2    New MGCP Package...........................................179
   C.3    New MGCP LocalConnectionOptions Sub-Registry...............179
   Appendix D: Mode Interactions.....................................180
   Appendix E: Endpoint Naming Conventions...........................182
   E.1    Analog Access Line Endpoints...............................182
   E.2    Digital Trunks.............................................182
   E.3    Virtual Endpoints..........................................183
   E.4    Media Gateway..............................................184
   E.5    Range Wildcards............................................184
   Appendix F: Example Command Encodings.............................185
   F.1    NotificationRequest........................................185
   F.2    Notify.....................................................186
   F.3    CreateConnection...........................................186
   F.4    ModifyConnection...........................................189
   F.5    DeleteConnection (from the Call Agent).....................189
   F.6    DeleteConnection (from the gateway)........................190
   F.7    DeleteConnection (multiple connections
          from the Call Agent).......................................190
   F.8    AuditEndpoint..............................................191
   F.9    AuditConnection............................................192
   F.10   RestartInProgress..........................................193
   Appendix G: Example Call Flows....................................194
   G.1    Restart....................................................195
   G.1.1  Residential Gateway Restart................................195
   G.1.2  Call Agent Restart.........................................198
   G.2    Connection Creation........................................200
   G.2.1  Residential Gateway to Residential Gateway.................200
   G.3    Connection Deletion........................................206
   G.3.1  Residential Gateway to Residential Gateway.................206
   Authors' Addresses................................................209
   Full Copyright Statement..........................................210
```

---
## **1. Introduction**

이 문서에서는 미디어 게이트웨이 컨트롤러 또는 통화 에이전트라고 하는 외부 통화 제어 요소에서 미디어 게이트웨이를 제어하기 위한 MGCI\(추상 애플리케이션 프로그래밍 인터페이스\) 및 해당 프로토콜\(MGCP\)에 대해 설명합니다. 미디어 게이트웨이는 일반적으로 전화 회선을 통해 전달되는 오디오 신호와 인터넷이나 다른 패킷 네트워크를 통해 전달되는 데이터 패킷 간의 변환을 제공하는 네트워크 요소입니다. 미디어 게이트웨이의 예는 다음과 같습니다.

\* 전화 네트워크와 VoIP\(Voice over IP\) 네트워크 사이를 인터페이스하는 트렁킹 게이트웨이. 이러한 게이트웨이는 일반적으로 다수의 디지털 회선을 관리합니다.

\* ATM 네트워크에 접속한다는 점을 제외하면 VoIP\(Voice over IP\) 트렁킹 게이트웨이와 거의 동일한 방식으로 작동하는 Voice over ATM 게이트웨이.

\* VoIP\(Voice over IP\) 네트워크에 기존 아날로그\(RJ11\) 인터페이스를 제공하는 주거용 게이트웨이. 주거용 게이트웨이의 예로는 케이블 모뎀/케이블 셋톱박스, xDSL 장치, 광대역 무선 장치 등이 있습니다.

\* VoIP 네트워크에 기존 아날로그\(RJ11\) 또는 디지털 PBX 인터페이스를 제공하는 액세스 게이트웨이. 액세스 게이트웨이의 예로는 소규모 VoIP 게이트웨이가 있습니다.

\* 기존 디지털 PBX 인터페이스 또는 VoIP 네트워크에 통합된 "소프트 PBX" 인터페이스를 제공하는 비즈니스 게이트웨이.

\* "모뎀"을 전화 회선에 연결하고 인터넷에 대한 데이터 액세스를 제공할 수 있는 네트워크 액세스 서버. 우리는 미래에는 동일한 게이트웨이가 VoIP\(Voice over IP\) 서비스와 네트워크 액세스 서비스를 결합할 것으로 예상합니다.

\* 외부 호출 제어 요소에 대한 제어 인터페이스를 제공할 수 있는 회로 스위치 또는 패킷 스위치.

MGCP는 통화 제어 "지능"이 게이트웨이 외부에 있고 통화 에이전트라고 알려진 외부 통화 제어 요소에 의해 처리되는 통화 제어 아키텍처를 가정합니다. MGCP는 이러한 통화 제어 요소, 즉 통화 에이전트가 서로 동기화되어 자신이 제어하는 ​​게이트웨이에 일관된 명령과 응답을 보낼 것이라고 가정합니다. 이 가정을 위반하면 일관되지 않은 동작이 예상됩니다. MGCP는 통화 에이전트 동기화 메커니즘을 정의하지 않습니다. MGCP는 본질적으로 게이트웨이가 통화 에이전트가 보낸 명령을 실행할 것으로 예상되는 마스터/슬레이브 프로토콜입니다. 결과적으로 이 문서에서는 다음과 같은 사항을 명시하고 있습니다.

게이트웨이의 예상되는 동작을 자세히 설명하지만 타이머 관리와 같이 프로토콜의 올바른 작동을 위해 요구되는 호출 에이전트 구현 부분만 지정합니다.

MGCP는 기본 구성이 끝점과 연결인 연결 모델을 가정합니다. 엔드포인트는 데이터의 소스 및/또는 싱크이며 물리적이거나 가상일 수 있습니다. 물리적 엔드포인트의 예는 다음과 같습니다.

\* PSTN 스위치\(예: 클래스 5, 클래스 4 등\)에 연결된 트렁크를 종료하는 게이트웨이의 인터페이스입니다. 트렁크를 종료하는 게이트웨이를 트렁킹 게이트웨이라고 합니다.

\* 전화, 키 시스템, PBX 등에 대한 아날로그 POTS 연결을 종료하는 게이트웨이의 인터페이스입니다. 주거용 POTS 회선\(전화\)을 종료하는 게이트웨이를 주거용 게이트웨이라고 합니다.

가상 끝점의 예로는 오디오 콘텐츠 서버의 오디오 소스가 있습니다. 물리적 엔드포인트를 생성하려면 하드웨어 설치가 필요하지만, 가상 엔드포인트 생성은 소프트웨어로 수행할 수 있습니다.

연결은 지점 간 연결이거나 다중 지점일 수 있습니다. 지점 간 연결은 두 끝점 간에 데이터를 전송하기 위한 목적으로 두 끝점 간의 연결입니다. 두 끝점 모두에 대해 이 연결이 설정되면 이러한 끝점 간의 데이터 전송이 발생할 수 있습니다. 다중 지점 연결은 끝점을 다중 지점 세션에 연결하여 설정됩니다.

다음과 같은 여러 유형의 베어러 네트워크를 통해 연결을 설정할 수 있습니다.

\* IP 네트워크를 통해 RTP 및 UDP를 사용하여 오디오 패킷을 전송합니다.

\* ATM 네트워크를 통해 AAL2 또는 다른 적응 계층을 사용하여 오디오 패킷을 전송합니다.

\* 내부 연결\(예: TDM 백플레인 또는 게이트웨이의 상호 연결 버스\)을 통한 패킷 전송. 이는 특히 게이트웨이에서 종료되지만 전화 네트워크를 통해 즉시 경로가 변경되는 연결인 "헤어핀" 연결에 사용됩니다.

지점 간 연결의 경우 연결 끝점이 별도의 게이트웨이에 있거나 동일한 게이트웨이에 있을 수 있습니다.

---
## **1.1 Relation with the H.323 Standards**

MGCP는 외부에 단일 VoIP 게이트웨이로 나타나는 분산 시스템 내의 내부 프로토콜로 설계되었습니다. 이 시스템은 여러 컴퓨터 플랫폼에 배포되거나 배포되지 않을 수 있는 통화 에이전트와 회선과 패킷 간의 미디어 신호 변환을 수행하는 적어도 하나의 "미디어 게이트웨이"를 포함하는 일련의 게이트웨이로 구성됩니다. SS7 제어 네트워크에 연결할 때 하나 이상의 "신호 게이트웨이". 일반적인 구성에서 이 분산 게이트웨이 시스템은 다음 표에 표시된 대로 한쪽은 하나 이상의 전화 통신\(예: 회선\) 스위치와 인터페이스하고 다른 쪽은 H.323 규격 시스템과 인터페이스합니다.

```text
    ------------------------------------------------------------------
   | Functional|  Phone     |  Terminating    |  H.323 conformant     |
   | Plane     |  switch    |  Entity         |  systems              |
   |-----------|------------|-----------------|-----------------------|
   | Signaling |  Signaling |  Call agent     |  Signaling exchanges  |
   | Plane     |  exchanges |                 |  with the Call Agent  |
   |           |  through   |                 |  through H.225/RAS and|
   |           |  SS7/ISUP  |                 |  H.225/Q.931.         |
   |-----------|------------|-----------------|-----------------------|
   |           |            |                 |  Possible negotiation |
   |           |            |                 |  of logical channels  |
   |           |            |                 |  and transmission     |
   |           |            |                 |  parameters through   |
   |           |            |                 |  H.245 with the call  |
   |           |            |                 |  agent.               |
   |-----------|------------|-----------------|-----------------------|
   |           |            |  Internal       |                       |
   |           |            |  synchronization|                       |
   |           |            |  through MGCP   |                       |
   |-----------|------------|-----------------|-----------------------|
   | Bearer    |  Connection|  Telephony      |  Transmission of VoIP |
   | Data      |  through   |  gateways       |  data using RTP       |
   | Transport |  high speed|                 |  directly between the |
   | Plane     |  trunk     |                 |  H.323 station and the|
   |           |  groups    |                 |  gateway.             |
    ------------------------------------------------------------------
```

MGCP 모델에서 게이트웨이는 오디오 신호 변환 기능에 중점을 두는 반면 통화 에이전트는 통화 신호 및 통화 처리 기능을 처리합니다. 결과적으로 통화 에이전트는 H.323 표준의 "신호" 계층을 구현하고 H.323 시스템에 대해 "H.323 게이트키퍼" 또는 하나 이상의 "H.323 엔드포인트"로 표시됩니다.

---
## **1.2  Relation with the IETF Standards**

H.323은 VoIP 터미널의 표준으로 인정받고 있지만 IETF는 다른 유형의 멀티미디어 애플리케이션에 대한 사양도 개발했습니다. 기타 사양은 다음과 같습니다.

\* 세션 설명 프로토콜\(SDP\), RFC 2327

\* 세션 발표 프로토콜\(SAP\), RFC 2974

\* 세션 시작 프로토콜\(SIP\), RFC 3261

\* 실시간 스트리밍 프로토콜\(RTSP\), RFC 2326.

후자의 세 가지 사양은 실제로 관심 있는 당사자에게 세션 설명을 전송할 수 있는 대체 신호 표준입니다. SAP는 멀티캐스트 세션 관리자가 멀티캐스트 세션 설명을 대규모 수신자 그룹에 배포하는 데 사용되며, SIP는 개별 사용자를 지점 간 또는 유니캐스트 세션에 참여하도록 초대하는 데 사용되며, RTSP는 서버와 인터페이스하는 데 사용됩니다. 실시간 데이터를 제공합니다. 세 가지 경우 모두 세션 설명은 SDP에 따라 설명됩니다. 오디오가 전송되면 실시간 전송 프로토콜\(RTP\)을 통해 전송됩니다.

분산 게이트웨이 시스템과 MGCP를 통해 PSTN 전화 통신 사용자는 SAP, SIP 또는 RTSP를 사용하여 설정된 세션에 액세스할 수 있습니다. 통화 에이전트는 다음 표에 따라 신호 변환을 제공합니다.

```text
    ------------------------------------------------------------------
   | Functional|  Phone     |  Terminating  |  IETF conforming systems|
   | Plane     |  switch    |  Entity       |                         |
   |-----------|------------|---------------|-------------------------|
   | Signaling |  Signaling |  Call agent   |  Signaling exchanges    |
   | Plane     |  exchanges |               |  with the Call Agent    |
   |           |  through   |               |  through SAP, SIP or    |
   |           |  SS7/ISUP  |               |  RTSP.                  |
   |-----------|------------|---------------|-------------------------|
   |           |            |               |  Negotiation of session |
   |           |            |               |  description parameters |
   |           |            |               |  through SDP (telephony |
   |           |            |               |  gateway terminated but |
   |           |            |               |  passed via the call    |
   |           |            |               |  agent to and from the  |
   |           |            |               |  IETF conforming system)|
   |-----------|------------|---------------|-------------------------|
   |           |            | Internal syn- |                         |
   |           |            | chronization  |                         |
   |           |            | through MGCP  |                         |
   |-----------|------------|---------------|-------------------------|
   | Bearer    |  Connection|  Telephony    |  Transmission of VoIP   |
   | Data      |  through   |  gateways     |  data using RTP,        |
   | Transport |  high speed|               |  directly between the   |
   | Plane     |  trunk     |               |  remote IP end system   |
   |           |  groups    |               |  and the gateway.       |
    ------------------------------------------------------------------
```

SDP 표준은 이 아키텍처에서 중추적인 역할을 합니다. 다음 설명에서는 이를 MGCP에서 세션 설명을 전달하는 데 사용하는 방법도 살펴보겠습니다.

---
## **1.3 Definitions**

트렁크: 두 스위칭 시스템 간의 통신 채널\(예: T1 또는 E1 회선의 DS0\)

---
## **1.4 Conventions used in this Document**

키워드 "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED, "MAY" 및 "OPTIONAL" 이 문서의 내용은 BCP 14, RFC 2119 \[2\]에 설명된 대로 해석됩니다.\(MUST NOT\)

---
## **2. Media Gateway Control Interface**

인터페이스 기능은 연결 제어 및 엔드포인트 제어를 제공합니다. 둘 다 동일한 시스템 모델과 동일한 명명 규칙을 사용합니다.

---
## **2.1 Model and Naming Conventions**

MGCP는 기본 구성이 끝점과 연결인 연결 모델을 가정합니다. 연결은 통화로 그룹화됩니다. 하나 이상의 연결이 하나의 통화에 속할 수 있습니다. 연결 및 통화는 하나 이상의 통화 상담원이 주도하여 설정됩니다.

---
### **2.1.1 Types of Endpoints**

소개에서 우리는 여러 종류의 게이트웨이를 제시했습니다. 그러나 그러한 분류는 오해를 불러일으킬 수 있습니다. 제조업체는 단일 패키지로 여러 유형의 서비스를 제공하기로 임의로 결정할 수 있습니다. 예를 들어, 단일 제품은 전화 스위치에 대한 일부 트렁크 연결, 일부 기본 속도 연결 및 일부 아날로그 회선 인터페이스를 제공하여 소개에서 "트렁킹", "액세스" 및 "주거용"으로 설명한 특성을 공유할 수 있습니다. 게이트웨이. MGCP는 그러한 그룹화에 대해 가정을 하지 않습니다. 우리는 단순히 미디어 게이트웨이가 엔드포인트 컬렉션을 지원한다고 가정합니다. 엔드포인트 유형에 따라 기능이 결정됩니다. 지금까지 분석을 통해 다음과 같은 기본 엔드포인트 유형을 분리했습니다.

```text
   * Digital channel (DS0),

   * Analog line,

   * Announcement server access point,

   * Interactive Voice Response access point,

   * Conference bridge access point,

   * Packet relay,

   * ATM "trunk side" interface.
```

이 섹션에서는 이러한 엔드포인트의 예상되는 동작을 설명합니다.

이 목록은 최종 목록이 아닙니다. 미래에는 다른 유형의 엔드포인트가 정의될 ​​수 있습니다. 예를 들어 네트워크 품질을 확인하는 데 사용할 수 있는 테스트 엔드포인트 또는 프레임 릴레이 가상 회선을 통해 다중화된 오디오 채널을 관리하는 데 사용할 수 있는 프레임 릴레이 엔드포인트가 있습니다.

---
#### **2.1.1.1 Digital Channel (DS0)**

디지털 채널은 64Kbps 서비스를 제공합니다. 이러한 채널은 트렁크 및 ISDN 인터페이스에서 찾을 수 있습니다. 이는 일반적으로 T1, E1, T3 또는 E3 인터페이스와 같은 디지털 멀티플렉스의 일부입니다. 이러한 채널을 지원하는 미디어 게이트웨이는 채널에서 수신된 디지털 신호를 변환할 수 있습니다. 이 신호는 샘플당 8비트 전체 세트 또는 이 비트 중 7비트만 사용하여 A-law 또는 mu-law에 따라 인코딩될 수 있습니다. 오디오 패킷. 미디어 게이트웨이가 네트워크 액세스 서버\(NAS\) 서비스도 지원하는 경우 게이트웨이는 오디오 인코딩된 데이터\(모뎀 연결\) 또는 바이너리 데이터\(ISDN 연결\)를 수신하고 이를 데이터 패킷으로 변환할 수 있어야 합니다.

```text
                                         +-------
                           +------------+|
              (channel) ===|DS0 endpoint| -------- Connections
                           +------------+|
                                         +-------
```

미디어 게이트웨이는 엔드포인트와 패킷 네트워크 사이 또는 엔드포인트와 동일한 게이트웨이의 다른 엔드포인트 사이에 여러 연결을 설정할 수 있어야 합니다. 이러한 연결에서 발생하는 신호는 이 문서의 뒷부분에 지정된 대로 연결 "모드"에 따라 혼합되어야 합니다. 엔드포인트가 지원하는 정확한 연결 수는 게이트웨이의 특성이며 실제로 게이트웨이 내의 리소스 할당에 따라 달라질 수 있습니다.

어떤 경우에는 신호를 전달하기 위해 디지털 채널이 사용됩니다. 예를 들어 SS7 "F" 링크 또는 ISDN "D" 채널의 경우입니다. 이러한 신호 기능을 지원하는 미디어 게이트웨이는 IETF의 SIGTRAN 작업 그룹에서 정의한 "백홀" 절차를 사용하여 통화 에이전트와 신호 패킷을 주고받을 수 있어야 합니다. 디지털 채널은 때때로 "MF R2"와 같은 채널 관련 신호와 함께 사용됩니다. 이러한 신호 기능을 지원하는 미디어 게이트웨이는 MGCP에 정의된 이벤트 신호 및 보고 절차에 따라 "윙크" 또는 "A"와 같은 해당 신호를 감지하고 생성할 수 있어야 합니다.

---
#### **2.1.1.2 Analog Line**

아날로그 회선은 "클라이언트" 인터페이스로 사용되어 일반 전화 장치에 서비스를 제공하거나 "서비스" 인터페이스로 사용되어 게이트웨이에서 아날로그 호출을 보내고 받을 수 있습니다. 미디어 게이트웨이가 NAS 서비스도 지원하는 경우 게이트웨이는 오디오 인코딩된 데이터\(모뎀 연결\)를 수신하고 이를 데이터 패킷으로 변환할 수 있어야 합니다.

```text
                                         +-------
                        +---------------+|
              (line) ===|analog endpoint| -------- Connections
                        +---------------+|
                                         +-------
```

미디어 게이트웨이는 엔드포인트와 패킷 네트워크 사이 또는 엔드포인트와 동일한 게이트웨이의 다른 엔드포인트 사이에 여러 연결을 설정할 수 있어야 합니다. 이러한 연결에서 발생하는 오디오 신호는 이 문서의 뒷부분에 지정된 대로 연결 "모드"에 따라 믹싱되어야 합니다. 엔드포인트가 지원하는 정확한 연결 수는 게이트웨이의 특성이며 실제로 게이트웨이 내의 리소스 할당에 따라 달라질 수 있습니다. 그러나 일반적인 게이트웨이는 "통화 대기" 또는 "3자 통화"와 같은 서비스를 지원하기 위해 엔드포인트당 2\~3개의 연결을 지원할 수 있어야 합니다.

---
#### **2.1.1.3 Announcement Server Access Point**

알림 서버 엔드포인트는 알림 서비스에 대한 액세스를 제공합니다. 통화 에이전트의 요청에 따라 알림 서버는 지정된 알림을 "재생"합니다. 통화 에이전트의 요청은 MGCP에 정의된 이벤트 신호 및 보고 절차를 따릅니다.

```text
                  +----------------------+
                  | Announcement endpoint| -------- Connection
                  +----------------------+
```

지정된 공지 엔드포인트는 한 번에 둘 이상의 연결을 지원할 것으로 예상되지 않습니다. 동일한 끝점에 여러 연결이 설정된 경우 동일한 알림이 모든 연결을 통해 동시에 재생됩니다.

알림 서버에 대한 연결은 일반적으로 단방향 또는 "반이중"입니다. 즉, 알림 서버는 연결의 오디오 신호를 듣지 않을 것으로 예상됩니다.

---
#### **2.1.1.4 Interactive Voice Response Access Point**

IVR\(대화형 음성 응답\) 끝점은 IVR 서비스에 대한 액세스를 제공합니다. 통화 에이전트의 요청에 따라 IVR 서버는 공지 사항 및 신호음을 "재생"하고 DTMF 입력 또는 음성 메시지와 같은 사용자의 응답을 "듣습니다". 통화 에이전트의 요청은 MGCP에 정의된 이벤트 신호 및 보고 절차를 따릅니다.

```text
                      +-------------+
                      | IVR endpoint| -------- Connection
                      +-------------+
```

특정 IVR 엔드포인트는 한 번에 둘 이상의 연결을 지원할 것으로 예상되지 않습니다. 동일한 끝점에 여러 연결이 설정된 경우 모든 연결을 통해 동일한 신호음과 알림이 동시에 재생됩니다.

---
#### **2.1.1.5 Conference Bridge Access Point**

컨퍼런스 브리지 엔드포인트는 특정 컨퍼런스에 대한 액세스를 제공하는 데 사용됩니다.

```text
                                           +-------
               +--------------------------+|
               |Conference bridge endpoint| -------- Connections
               +--------------------------+|
                                           +-------
```

미디어 게이트웨이는 엔드포인트와 패킷 네트워크 사이 또는 엔드포인트와 동일한 게이트웨이의 다른 엔드포인트 사이에 여러 연결을 설정할 수 있어야 합니다. 이러한 연결에서 발생하는 신호는 이 문서의 뒷부분에 지정된 대로 연결 "모드"에 따라 혼합되어야 합니다. 엔드포인트가 지원하는 정확한 연결 수는 게이트웨이의 특성이며 실제로 게이트웨이 내의 리소스 할당에 따라 달라질 수 있습니다.

---
#### **2.1.1.6 Packet Relay**

패킷 릴레이 끝점은 일반적으로 두 개의 연결만 지원하는 특정 형태의 컨퍼런스 브리지입니다. 패킷 릴레이는 보호된 네트워크와 개방형 네트워크 사이의 방화벽에서 찾을 수 있으며, 호환되지 않는 게이트웨이\(예: 호환되는 압축 알고리즘을 지원하지 않는 게이트웨이 또는 IP와 같은 다른 전송 네트워크에서 작동하는 게이트웨이\) 간의 상호 운용을 제공하는 데 사용되는 트랜스코딩 서버에서 찾을 수 있습니다. ATM.

```text
                                           +-------
                   +---------------------+ |
                   |Packet relay endpoint|  2 connections
                   +---------------------+ |
                                           +-------
```

---
#### **2.1.1.7 ATM "trunk side" Interface**

ATM "트렁크 측" 엔드포인트는 일반적으로 하나 이상의 ATM 영구 가상 회선이 기존 "TDM" 트렁크 연결 스위치 대신 사용될 때 발견됩니다. ATM/AAL2를 사용하는 경우 여러 트렁크 또는 채널이 단일 가상 회선에서 다중화됩니다. 이러한 각 트렁크는 단일 끝점에 해당합니다.

```text
                                          +-------
                      +------------------+|
          (channel) = |ATM trunk endpoint| -------- Connections
                      +------------------+|
                                          +-------
```

미디어 게이트웨이는 엔드포인트와 패킷 네트워크 사이 또는 엔드포인트와 동일한 게이트웨이의 다른 엔드포인트 사이에 여러 연결을 설정할 수 있어야 합니다. 이러한 연결에서 발생하는 신호는 이 문서의 뒷부분에 지정된 대로 연결 "모드"에 따라 혼합되어야 합니다. 엔드포인트가 지원하는 정확한 연결 수는 게이트웨이의 특성이며 실제로 게이트웨이 내의 리소스 할당에 따라 달라질 수 있습니다.

---
### **2.1.2 Endpoint Identifiers**

엔드포인트 식별자에는 대소문자를 구분하지 않는 두 가지 구성 요소가 있습니다.

\* 엔드포인트를 관리하는 게이트웨이의 도메인 이름

\* 해당 게이트웨이 내의 로컬 이름

엔드포인트 이름의 형식은 다음과 같습니다.

```text
      local-endpoint-name@domain-name
```

여기서 domain-name은 RFC 1034에 정의된 절대 도메인 이름이고 호스트 부분을 포함합니다. 따라서 domain-name의 예는 다음과 같습니다.

```text
      mygateway.whatever.net
```

또한 domain-name은 RFC 821에서 도메인 이름에 대해 정의된 형식의 IP 주소일 수 있으므로 다른 예는 다음과 같습니다\(자세한 내용은 RFC 821 참조\).

```text
      [192.168.1.2]
```

IPv4 및 IPv6 주소를 모두 지정할 수 있지만 IP 주소를 끝점 식별자로 사용하는 것은 일반적으로 권장되지 않습니다.

도메인 이름 부분은 엔드포인트 식별자의 일부이므로 동일한 엔터티를 참조하는 다른 형식이나 다른 값을 자유롭게 교환할 수 없습니다. 가장 최근에 제공된 형식과 값을 항상 사용해야 합니다.\(MUST\)

로컬 엔드포인트 이름은 대소문자를 구분하지 않습니다. 로컬 끝점 이름의 구문은 계층적입니다. 여기서 이름의 가장 구체적인 구성 요소는 가장 왼쪽의 용어이고 가장 구체적인 구성 요소는 가장 오른쪽의 용어입니다. 정확한 구문은 명명되는 엔드포인트 유형에 따라 다르며 엔드포인트 유형을 식별하는 용어로 시작할 수 있습니다. 어떤 경우든 로컬 엔드포인트 이름은 다음 명명 규칙을 준수해야 합니다.\(MAY, MUST\)

1\) 이름 지정 경로의 개별 용어는 단일 슬래시\("/", ASCII 2F 16진수\)로 구분되어야 합니다.\(MUST\)

2\) 개별 용어는 문자, 숫자 또는 기타 인쇄 가능한 문자로 구성된 문자열입니다. 단, 구분 기호로 사용되는 문자\("/", "@"\), 와일드카드에 사용되는 문자\("\*", "$"\) 및 공백.

3\) 와일드카드는 와일드카드를 사용하는 명명 경로의 용어를 별표\("\*"\) 또는 달러 기호\("$"\)로 표시합니다. 따라서 전체 로컬 엔드포인트 이름의 형식은 다음과 같습니다.

```text
          term1/term2/term3
```

- 와일드카드가 사용된 용어에 따라 엔터티 이름 필드는 다음과 같습니다.

\*/term2/term3\(term1이 와일드카드인 경우\)

- term1/\*/term3 term2가 와일드카드인 경우 term1/term2/\* term3이 와일드카드인 경우 term1/\*/\* term2와 term3이 와일드카드인 경우 등

- 각 예에서는 별표 대신 달러 기호가 나타날 수 있습니다.

4\) 별표\("\*"\)로 표시된 용어는 "미디어 게이트웨이 범위 내에서 알려진 이 용어의 모든 값을 사용합니다"로 해석됩니다. 별도로 지정하지 않는 한 이는 실제 서비스 상태\(즉, 서비스 중 또는 서비스 중단\)에 관계없이 서비스를 위해 구성된 모든 엔드포인트를 나타냅니다.

5\) 달러 기호\("$"\)로 표시되는 용어는 "미디어 게이트웨이 범위 내에서 알려진 이 용어의 하나의 값을 사용하십시오"로 해석됩니다. 별도로 지정하지 않는 한 이는 서비스 중인 엔드포인트만 나타냅니다.

또한 통화 상담원은 다음 사항을 준수하는 것이 좋습니다.\(SHOULD\)

\* 와일드카드는 오른쪽에서만 사용해야 합니다. 따라서 용어가 와일드카드인 경우 해당 용어의 오른쪽에 있는 모든 용어도 와일드카드를 사용해야 합니다.

\* 달러 기호와 별표 와일드카드를 혼합하여 사용하는 경우 달러 기호는 오른쪽에서만 사용해야 하므로 용어에 달러 기호 와일드카드가 있는 경우 해당 용어 오른쪽에 있는 모든 용어에도 달러가 포함되어야 함 와일드카드에 서명하세요.

특정 명령에 대한 설명은 위에 제공된 일반 규칙 내에서 선택을 위한 추가 기준을 추가할 수 있습니다.

와일드카드는 둘 이상의 용어에 적용될 수 있으며, 이 경우 왼쪽에서 오른쪽으로 평가되어야 합니다. 예를 들어 엔드포인트 이름이 "a/1", "a/2", "b/1" 및 "b/2"인 경우 "$/\*"\(권장되지 않음\)는 다음 중 하나로 평가됩니다. "a/1, a/2" 또는 "b/1, b/2". 그러나 "\*/$"는 "a/1, b/1", "a/1, b/2", "a/2, b/1" 또는 "a/2, b/2"로 평가될 수 있습니다. . 명령에 와일드카드를 혼합하여 사용하는 것은 오류가 발생하기 쉬운 것으로 간주되므로 권장되지 않습니다.

와일드카드 문자로만 구성된 로컬 이름은 미디어 게이트웨이 내의 모든\(\*\) 또는 임의\($\) 엔드포인트를 나타냅니다.

---
### **2.1.3 Calls and Connections**

연결은 "통화"에 포함될 각 끝점의 통화 에이전트에서 생성됩니다. 두 개의 "DS0" 끝점\(EP1 및 EP2\) 간의 연결에 대한 일반적인 예에서 끝점을 제어하는 ​​통화 에이전트는 두 개의 연결\(C1 및 C2\)을 설정합니다.

```text
                  +---+                            +---+
    (channel1) ===|EP1|--(C1)--...        ...(C2)--|EP2|===(channel2)
                  +---+                            +---+
```

각 연결은 끝점 고유 연결 식별자에 의해 로컬로 지정되며 연결 속성으로 특징지어집니다.

두 엔드포인트가 동일한 통화 에이전트에 의해 관리되는 게이트웨이에 있는 경우 다음 세 단계를 통해 생성이 수행됩니다.

1\) 통화 에이전트는 첫 번째 게이트웨이에 첫 번째 엔드포인트에서 "연결 생성"을 요청합니다. 게이트웨이는 해당 연결에 리소스를 할당하고 "세션 설명"을 제공하여 명령에 응답합니다. 세션 설명에는 IP 주소, UDP 포트, 코덱 매개변수 등 제3자가 새로 생성된 연결을 향해 패킷을 보내는 데 필요한 정보가 포함되어 있습니다.

2\) 그런 다음 통화 에이전트는 두 번째 게이트웨이에 "생성"을 요청합니다.

- 두 번째 끝점의 "연결". 명령은 첫 번째 게이트웨이에서 제공한 "세션 설명"을 전달합니다. 게이트웨이는 해당 연결에 리소스를 할당하고 자체 "세션 설명"을 제공하여 명령에 응답합니다.

3\) 그런 다음 통화 에이전트는 "연결 수정" 명령을 사용하여 이 두 번째 "세션 설명"을 첫 번째 끝점에 제공합니다. 이 작업이 완료되면 통신은 양방향으로 진행될 수 있습니다.

두 엔드포인트가 두 개의 서로 다른 통화 에이전트에 의해 관리되는 게이트웨이에 있는 경우 통화 에이전트는 연결 생성을 동기화하기 위해 통화 에이전트와 통화 에이전트 신호 프로토콜\(예: SIP\[7\]\)을 통해 정보를 교환합니다. 두 끝점에서.

연결이 설정되면 "연결 수정" 명령을 사용하여 언제든지 연결 매개변수를 수정할 수 있습니다. 예를 들어 통화 에이전트는 연결에 사용되는 코덱을 변경하거나 연결이 "리디렉션"된 경우 데이터가 전송되어야 하는 IP 주소 및 UDP 포트를 수정하도록 게이트웨이에 지시할 수 있습니다.

통화 에이전트는 게이트웨이에 "연결 삭제" 명령을 보내 연결을 제거합니다. 또한 게이트웨이는 일부 상황에서 연결을 유지할 수 없음을 게이트웨이에 알릴 수도 있습니다.

다음 다이어그램은 게이트웨이에서 본 연결 상태의 보기를 제공합니다.

```text
           Create connection
              received
                  |
                  V
         +-------------------+
         |resource allocation|-(failed)-+
         +-------------------+          |
                  |           (connection refused)
            (successful)
                  |
                  v
     +----------->+
     |            |
     |   +-------------------+
     |   |  remote session   |
     |   |   description     |----------(yes)--------+
     |   |    available ?    |                       |
     |   +-------------------+                       |
     |            |                                  |
     |          (no)                                 |
     |            |                                  |
     |      +-----------+                         +------+
     | +--->| half open |------> Delete   <-------| open |<----------+
     | |    |  (wait)   |      Connection         |(wait)|           |
     | |    +-----------+       received          +------+           |
     | |          |                 |                |               |
     | |   Modify Connection        |         Modify Connection      |
     | |      received              |            received            |
     | |          |                 |                |               |
     | | +--------------------+     |       +--------------------+   |
     | | |assess modification |     |       |assess modification |   |
     | | +--------------------+     |       +--------------------+   |
     | |    |             |         |          |             |       |
     | |(failed)     (successful)   |      (failed)     (successful) |
     | |    |             |         |          |             |       |
     | +<---+             |         |          +-------------+-------+
     |                    |         |
     +<-------------------+         |
                                    |
                           +-----------------+
                           | Free connection |
                           | resources.      |
                           | Report.         |
                           +-----------------+
                                    |
                                    V
```

---
#### **2.1.3.1 Names of Calls**

각 연결의 속성 중 하나는 "호출 식별자"입니다. MGCP 프로토콜에 관한 한 이는 의미론적 의미가 거의 없으며 주로 이전 버전과의 호환성을 위해 유지됩니다.

통화는 기본 플랫폼이나 에이전트와 관계없이 고유 식별자로 식별됩니다. 통화 식별자는 통화 에이전트에 의해 생성된 16진수 문자열입니다. 통화 식별자의 최대 길이는 32자입니다.

통화 식별자는 시스템 내에서 고유하거나 최소한 동일한 게이트웨이를 제어하는 ​​통화 에이전트 모음 내에서 고유해야 합니다. 따라서 게이트웨이의 관점에서 통화 식별자는 고유합니다. 통화 에이전트가 동일한 게이트웨이 또는 다른 게이트웨이에서 동일한 통화와 관련된 여러 연결을 구축하는 경우 동일한 통화에 속하는 이러한 연결은 동일한 통화 ID를 공유해야 합니다. 이 식별자는 MGCP 범위를 벗어나는 회계 또는 관리 절차에서 사용될 수 있습니다.

---
#### **2.1.3.2 Names of Connections**

연결 식별자는 연결 생성을 요청받을 때 게이트웨이에 의해 생성됩니다. 엔드포인트 컨텍스트 내에서 연결을 식별합니다. 연결 식별자는 MGCP에서 16진수 문자열로 처리됩니다. 게이트웨이는 이 식별자를 사용한 연결 종료와 동일한 끝점에 대한 새 연결에서의 사용 사이에 최소 3분의 적절한 대기 기간이 경과하는지 확인해야 합니다\(게이트웨이는 해당 식별자 내에서 고유한 식별자를 사용하도록 결정할 수 있음\). 게이트웨이의 컨텍스트\). 연결 식별자의 최대 길이는 32자입니다.\(MUST\)

---
#### **2.1.3.3 Management of Resources, Attributes of Connections**

특정 신호 처리 기능이나 패킷화 기능과 같은 다양한 유형의 리소스가 연결과 연관됩니다. 일반적으로 이러한 리소스는 두 가지 범주로 분류됩니다.

1\) "네트워크의 비트" 형식에 영향을 미치고 연결과 관련된 두 번째 끝점으로 전달되어야 하는 외부에서 볼 수 있는 리소스입니다.

2\) 연결을 통해 전송되는 신호와 수신된 신호가 엔드포인트에서 처리되는 방법을 결정하는 내부 리소스입니다.

연결에 할당된 리소스, 더 일반적으로는 연결 처리는 통화 에이전트의 지시에 따라 게이트웨이에 의해 선택됩니다. 통화 에이전트는 두 가지 매개변수 세트를 게이트웨이로 전송하여 이러한 지침을 제공합니다.

1\) 로컬 지시문은 연결에 사용해야 하는 리소스 선택에 대해 게이트웨이에 지시합니다.

2\) 가능한 경우 연결의 다른 쪽 끝에서 제공되는 "세션 설명"\(원격 세션 설명이라고 함\).

로컬 지시문은 연결 모드\(예: 보내기 전용 또는 보내기-받기\), 선호하는 코딩 또는 패킷화 방법, 반향 제거 또는 묵음 억제 사용과 같은 매개변수를 지정합니다. \(자세한 목록은 CreateConnection 명령의 LocalConnectionOptions 매개변수 사양에서 찾을 수 있습니다.\) 매개변수에 따라 통화 에이전트는 값, 값 범위를 지정하거나 값을 전혀 지정하지 않을 수도 있습니다. 이를 통해 호출 에이전트가 연결 처리의 세부 사항을 지정하는 매우 엄격한 제어부터 호출 에이전트가 최대 대역폭과 같은 광범위한 지침만 지정하고 게이트웨이는 지침에 따라 세부 값을 선택합니다.\(MAY\)

로컬 지시문의 값에 따라 게이트웨이는 연결에 할당할 리소스를 결정합니다. 이것이 가능하면 게이트웨이는 원격 세션 설명과 일치하는 값을 선택합니다. 그러나 매개변수가 정확히 동일해야 한다는 절대적인 요구 사항은 없습니다.

리소스가 할당되면 게이트웨이는 패킷을 보내고 받는 방법을 설명하는 "세션 설명"을 구성합니다. 경우에 따라 세션 설명에 다양한 값이 표시될 수 있습니다. 예를 들어, 게이트웨이가 여러 압축 알고리즘 중 하나를 받아들일 준비가 되면 이러한 허용된 알고리즘 목록을 제공할 수 있습니다.

```text
                 Local Directives
                (from Call Agent 1)
                        |
                        V
                 +-------------+
                 | resource    |
                 | allocation  |
                 | (gateway 1) |
                 +-------------+
                   |         |
                   V         |
                 Local       |
              Parameters     V
                   |      Session
                   |    Description               Local Directives
                   |         |                   (from Call Agent 2)
                   |         +---> Transmission----+      |
                   |                (CA to CA)     |      |
                   |                               V      V
                   |                           +-------------+
                   |                           | resource    |
                   |                           | allocation  |
                   |                           | (gateway 2) |
                   |                           +-------------+
                   |                               |      |
                   |                               |      V
                   |                               |    Local
                   |                               |  Parameters
                   |                            Session
                   |                          Description
                   |         +---- Transmission<---+
                   |         |      (CA to CA)
                   V         V
                 +-------------+
                 | modification|
                 | (gateway 1) |
                 +-------------+
                   |
                   V
                 Local
              Parameters

      -- Information flow: local directives & session descriptions --
```

---
#### **2.1.3.4 Special Case of Local Connections**

대규모 게이트웨이에는 종종 다양한 유형의 엔드포인트가 많이 포함됩니다. 일부 네트워크에서는 동일한 게이트웨이 내에 있는 엔드포인트 간에 연결을 설정해야 하는 경우가 많습니다. 이러한 연결의 예는 다음과 같습니다.

\* 대화형 음성 응답 장치에 통화 연결,

\* 회의 장치에 통화 연결,

\* 한 끝점에서 다른 끝점으로 통화 라우팅\(종종 "헤어핀" 연결이라고 설명됨\)

로컬 연결은 네트워크 연결보다 설정이 훨씬 간단합니다. 대부분의 경우 연결은 TDM 버스와 같은 일부 로컬 상호 연결 장치를 통해 설정됩니다.

두 엔드포인트가 동일한 게이트웨이에 의해 관리되는 경우 연결될 두 엔드포인트의 이름을 전달하는 단일 명령으로 연결을 지정할 수 있습니다. 이 명령은 본질적으로 "원격 세션 설명" 대신 두 번째 끝점의 이름을 포함하는 "연결 만들기" 명령입니다.

---
### **2.1.4 Names of Call Agents and Other Entities**

미디어 게이트웨이 제어 프로토콜은 향상된 네트워크 안정성을 위해 중복 통화 에이전트를 구현할 수 있도록 설계되었습니다. 이는 엔터티와 하드웨어 플랫폼 또는 네트워크 인터페이스 간에 고정된 바인딩이 없음을 의미합니다.

통화 상담원 이름은 엔드포인트 이름과 비슷하게 두 부분으로 구성됩니다. 의미상 이름의 로컬 부분은 내부 구조를 나타내지 않습니다. 통화 상담원 이름의 예는 다음과 같습니다.

```text
      ca1@ca.whatever.net
```

로컬 부분과 도메인 이름을 모두 제공해야 합니다. 그럼에도 불구하고 도메인 이름만으로 구성된 호출 에이전트 이름을 허용하도록 구현하는 것이 좋습니다.

다음 절차를 사용하면 신뢰성을 향상시킬 수 있습니다.

\* 엔드포인트나 통화 상담원과 같은 엔터티는 네트워크 주소가 아닌 도메인 이름으로 식별됩니다. 주소는 여러 개일 수 있습니다.

도메인 이름과 연결되어 있습니다. 명령이나 응답을 네트워크 주소 중 하나로 전달할 수 없는 경우 구현에서는 다른 주소를 사용하여 전송을 다시 시도해야 합니다.\(MUST\)

\* 기업은 다른 플랫폼으로 이동할 수 있습니다. 논리적 이름\(도메인 이름\)과 실제 플랫폼 간의 연결은 도메인 이름 서비스에 유지됩니다. 통화 에이전트와 게이트웨이는 DNS에서 읽은 레코드의 수명을 추적해야 합니다. TTL\(Time to Live\)이 만료된 경우 정보를 새로 고치려면 DNS에 쿼리해야 합니다.\(MAY, MUST, MUST\)

도메인 이름과 DNS를 사용하여 제공되는 간접 참조 외에도 "통지된 엔터티" 개념은 MGCP의 안정성과 장애 조치의 핵심입니다. 엔드포인트에 대한 "알림 엔터티"는 현재 해당 엔드포인트를 제어하는 ​​통화 에이전트입니다. 어느 시점에서든 엔드포인트에는 단 하나의 "알림 엔터티"가 연결되어 있습니다. "통지된 엔터티"는 엔드포인트가 명령을 보낼 위치를 결정합니다. 엔드포인트가 호출 에이전트에 명령을 보내야 하는 경우 현재 "통지된 엔터티"에 명령을 보내야 합니다. 그러나 "통지된 엔터티"는 명령을 수신할 수 있는 위치를 결정하지 않습니다. 모든 통화 에이전트는 엔드포인트에 명령을 보낼 수 있습니다. 관련 보안 고려 사항은 섹션 5를 참조하십시오.\(MUST\)

시작 시 "알림 엔터티"는 프로비저닝된 값으로 설정되어야 합니다. 통화 에이전트가 전송하는 대부분의 명령에는 "NotifiedEntity" 매개변수를 사용하여 "통지된 엔터티"의 이름을 명시적으로 지정하는 기능이 포함되어 있습니다. "알림 엔터티"는 새로운 "NotifiedEntity" 매개변수가 수신되거나 엔드포인트가 웜 또는 콜드\(전원 주기\) 재시작을 수행할 때까지 동일하게 유지됩니다.\(MUST\)

"NotifiedEntity" 매개변수가 "빈" 값과 함께 전송되면 엔드포인트의 "알림 엔터티"가 비어 있는 것으로 설정됩니다. 엔드포인트에 대한 "알림 엔터티"가 비어 있거나 명시적으로 설정되지 않은 경우\(명령이나 프로비저닝을 통해\) "알림 엔터티"는 기본적으로 다음의 소스 주소\(예: IP 주소 및 UDP 포트 번호\)를 사용합니다. 끝점에 대해 수신된 마지막 성공적인 비감사 명령입니다. 따라서 감사는 "통지된 엔터티"를 변경하지 않습니다. 빈 "NotifiedEntity" 매개변수 값을 사용하는 것은 오류가 발생하기 쉽고 DNS 기반 장애 조치 및 안정성 메커니즘을 제거하므로 사용하지 않는 것이 좋습니다.

---
### **2.1.5 Digit Maps**

통화 에이전트는 사용자가 다이얼한 숫자를 수집하도록 게이트웨이에 요청할 수 있습니다. 이 기능은 사용자가 다이얼하는 번호를 수집하기 위해 주거용 게이트웨이와 함께 사용하도록 고안되었습니다. 그것은 또한 함께 사용될 수 있습니다

통화 제어 서비스에서 요청하는 액세스 코드, 신용 카드 번호 및 기타 번호를 수집하기 위한 트렁킹 게이트웨이 및 액세스 게이트웨이.

한 가지 절차는 전화를 걸자마자 게이트웨이가 전화를 건 각 개별 숫자를 통화 에이전트에게 알리는 것입니다. 그러나 이러한 절차는 많은 수의 상호 작용을 생성합니다. 전화를 건 번호를 버퍼에 모아서 단일 메시지로 전송하는 것이 바람직합니다.

그러나 이러한 누적 접근 방식의 문제점은 게이트웨이가 전송 전에 얼마나 많은 숫자를 누적해야 하는지 예측하기 어렵다는 것입니다. 예를 들어, 책상에 있는 전화기를 사용하여 다음 번호로 전화를 걸 수 있습니다.

```text
        ------------------------------------------------------
       |  0                     |  Local operator             |
       |  00                    |  Long distance operator     |
       |  xxxx                  |  Local extension number     |
       |  8xxxxxxx              |  Local number               |
       |  #xxxxxxx              |  Shortcut to local number at|
       |                        |  other corporate sites      |
       |  *xx                   |  Star services              |
       |  91xxxxxxxxxx          |  Long distance number       |
       |  9011 + up to 15 digits|  International number       |
        ------------------------------------------------------
```

이 문제에 대한 해결책은 통화 에이전트가 다이얼 계획에 해당할 수 있는 숫자 맵을 사용하여 게이트웨이를 로드하도록 하는 것입니다. 이 숫자 맵은 Unix 시스템 명령인 egrep에서 파생된 구문을 사용하여 표현됩니다. 예를 들어 위에서 설명한 다이얼 플랜은 다음과 같은 숫자 맵을 생성합니다.

```text
      (0T|00T|[1-7]xxx|8xxxxxxx|#xxxxxxx|*xx|91xxxxxxxxxx|9011x.T)
```

숫자표의 형식적 구문은 프로토콜의 형식적 구문 설명\(부록 A 참조\)의 DigitMap 규칙에 의해 설명됩니다. 기본 숫자표 문자에 대한 지원은 필수이고 확장 숫자표 문자에 대한 지원은 선택사항입니다. 지원되지 않는 확장 숫자 지도 문자가 포함된 숫자 지도를 수신하는 게이트웨이는 오류 코드 537\(알 수 없는 숫자 지도 확장\)을 반환해야 합니다.\(MUST, SHOULD\)

이 구문에 따라 숫자 맵은 \(대소문자 구분 안 함\) "문자열" 또는 문자열 목록으로 정의됩니다. 목록의 각 문자열은 숫자 또는 타이머 집합으로 지정되거나 게이트웨이가 가능한 가장 짧은 일치 항목을 찾으려고 시도하는 표현식으로 지정되는 대체 번호 지정 체계입니다. 각 번호 매기기 체계에서는 다음 구성을 사용할 수 있습니다.

\* 숫자 : "0"부터 "9"까지의 숫자입니다. \* 타이머: 타이머 만료와 일치하는 기호 "T". \* DTMF: 숫자, 타이머 또는 "A", "B", "C", "D", "#" 또는 "\*" 기호 중 하나입니다. 확장이 정의될 수 있습니다. \* 와일드카드: 임의의 숫자\("0" \~ "9"\)와 일치하는 기호 "x"입니다. \* 범위: 대괄호\("\[" 및 "\]"\)로 묶인 하나 이상의 DTMF 기호입니다. \* 하위 범위: 하이픈\("-"\)으로 구분된 두 자리 숫자는 두 자리 사이 및 두 자리 사이의 모든 숫자와 일치합니다. 하위 범위 구성은 범위 구성 내부, 즉 "\["와 "\]" 사이에서만 사용할 수 있습니다. \* 위치: 이전 구문의 발생 횟수 0을 포함하여 임의의 숫자와 일치하는 마침표\("."\)입니다.

숫자 지도와 일치시킬 이벤트를 감지하는 게이트웨이는 다음을 수행해야 합니다.\(MUST\)

1\) "현재 다이얼 문자열"이라는 엔드포인트에 대한 내부 상태 변수 끝에 이벤트 코드를 토큰으로 추가합니다.

2\) 현재 다이얼 문자열을 숫자 지도 테이블에 적용하여 숫자 지도의 각 표현과 일치하는지 시도합니다.

3\) 결과가 자격 미달인 경우\(디지트 맵의 하나 이상의 항목과 부분적으로 일치하고 다른 항목과 완전히 일치하지 않음\) 더 이상 수행할 작업이 없습니다.

결과가 항목과 일치하거나 자격이 초과된 경우\(즉, 더 이상 일치하는 숫자가 없을 수 있는 경우\) 누적된 이벤트 목록을 통화 에이전트에 보냅니다. 이 사양에서 일치는 지정된 대안 중 하나와 정확히 일치하는 "완벽한 일치"이거나 다이얼 문자열이 어떤 대안과도 일치하지 않을 때 발생하는 불가능한 일치일 수 있습니다. 예를 들어, 예상치 못한 타이머로 인해 "불가능한 일치"가 발생할 수 있습니다. 완벽한 일치와 불가능한 일치 모두 누적된 숫자에 대한 알림을 트리거합니다\(다른 이벤트가 포함될 수 있음 - 섹션 2.3.3 참조\).

다음 예에서는 위의 내용을 보여줍니다. 숫자 맵이 있다고 가정합니다.

```text
      (xxxxxxx|x11)
```

현재 다이얼 문자열은 "41"입니다. 입력이 "1"이면 현재 다이얼 문자열은 "411"이 됩니다. "xxxxxxx"와 부분적으로 일치하지만 "x11"과 완전히 일치하므로 통화 에이전트에 "411"을 보냅니다.

다음 숫자 맵 예는 더 미묘합니다.

```text
     (0[12].|00|1[12].1|2x.#)
```

입력 "0"이 주어지면 위치\("."\)는 이전 구문의 0번 발생을 허용하므로 일치가 즉시 발생합니다. 따라서 이 숫자 맵에서는 입력 "00"이 생성될 수 없습니다.

입력이 "1"인 경우 부분 일치만 존재합니다. 입력 "12"도 부분적으로만 일치하지만 "11"과 "121"은 모두 일치합니다.

입력 "2"가 주어지면 부분 일치가 존재합니다. 입력 "23", "234", "2345" 등에 대한 부분 일치도 존재합니다. 여기서는 "#"\(예: "2345#"\)이 생성될 때까지 전체 일치가 발생하지 않습니다. 입력 "2#"도 일치했을 것입니다.

숫자 맵은 단순히 문법에 대해 이벤트 코드 시퀀스를 일치시키는 방법을 정의합니다. 여기에 정의된 숫자 맵은 DTMF 입력용이지만, 이러한 이벤트 코드에 대해 이미 정의된 숫자 맵 구문을 준수하는 이벤트 코드로 표시되는 다른 유형의 입력에 숫자 맵을 사용할 수 있도록 확장 패키지를 정의할 수도 있습니다\(예: " 1" 또는 "T"\). 그러한 사용법이 구상되는 경우, 특정 이벤트의 정의는 이를 패키지 정의에 명시적으로 명시해야 합니다.\(SHOULD\)

숫자 지도의 크기는 제한되지 않으므로 게이트웨이는 끝점당 최대 2048바이트까지 숫자 지도를 지원하는 것이 좋습니다.\(SHOULD\)

---
### **2.1.6 Packages**

MGCP는 모듈식 확장 가능한 프로토콜이지만 확장성을 위해서는 개별 확장을 관리, 식별 및 이름 지정해야 합니다. 이는 단순히 잘 정의된 확장 기능 그룹인 패키지 개념을 통해 달성됩니다. 예를 들어, 하나의 패키지는 아날로그 액세스 회선에 대한 특정 이벤트 및 신호 그룹\(예: 오프 후크 및 벨 울림\)을 지원할 수 있습니다. 다른 패키지는 아날로그 액세스 회선이나 비디오와 같은 다른 유형의 엔드포인트에 대해 다른 이벤트 및 신호 그룹을 지원할 수 있습니다. 특정 엔드포인트에서 하나 이상의 패키지를 지원할 수 있습니다.

MGCP를 사용하면 다음 유형의 확장을 패키지에 정의할 수 있습니다.

```text
   * BearerInformation

   * LocalConnectionOptions

   * ExtensionParameters

   * ConnectionModes

   * Events

   * Signals

   * Actions

   * DigitMapLetters

   * ConnectionParameters

   * RestartMethods

   * ReasonCodes

   * Return codes
```

각각에 대해서는 아래에서 더 자세히 설명하겠습니다. 패키지에서 이러한 각 확장을 정의하는 규칙은 섹션 6에 설명되어 있으며 인코딩 및 구문은 섹션 3과 부록 A에 정의되어 있습니다.

DigitMapLetters를 제외하고 패키지는 패키지 이름을 확장의 접두사로 추가하여 각 확장 유형에 대해 별도의 네임 스페이스를 정의합니다. 예:

```text
      package-name/extension
```

따라서 패키지 이름 뒤에는 슬래시\("/"\)와 확장명 이름이 옵니다.

하나 이상의 패키지를 지원하는 엔드포인트는 해당 패키지 중 하나를 엔드포인트의 기본 패키지로 정의할 수 있습니다. 엔드포인트에 대한 기본 패키지의 이벤트 및 신호에 패키지 이름을 사용하는 것은 선택 사항이지만 항상 패키지 이름을 포함하는 것이 좋습니다. 패키지에 정의된 DigitMapLetter를 제외한 다른 모든 확장은 확장을 참조할 때 패키지 이름을 포함해야 합니다.\(SHOULD, MUST\)

패키지 이름은 대소문자를 구분하지 않는 문자, 하이픈, 숫자로 구성되며 하이픈은 이름의 첫 번째 또는 마지막 문자가 될 수 없습니다. 패키지 이름의 예로는 "D", "T" 및 "XYZ"가 있습니다. 패키지 이름은 대소문자를 구분하지 않습니다. "XYZ", "xyz" 및 "xYz"와 같은 이름은 동일합니다.

패키지 정의는 IANA에 등록된 패키지 이름 및 확장명과 함께 다른 문서에서 제공됩니다. 자세한 내용은 섹션 6을 참조하세요.

구현자는 실험적 패키지를 사용하여 경험을 쌓을 수 있습니다. 실험 패키지의 이름은 "x-"라는 두 문자로 시작해야 합니다. IANA는 이러한 문자 또는 예약된 문자 "x+"로 시작하는 패키지 이름을 등록해서는 안 됩니다. 지원되지 않는 패키지를 참조하는 명령을 수신하는 게이트웨이는 반드시 오류를 반환해야 합니다\(오류 코드 518 - 지원되지 않는 패키지는 권장됨\).\(MUST NOT, MUST\)

---
### **2.1.7 Events and Signals**

이벤트와 신호의 개념은 MGCP의 핵심입니다. 통화 에이전트는 RequestedEvents 매개변수\(NotificationRequest 명령 - 섹션 2.3.3 참조\)에 이벤트 이름을 포함하여 엔드포인트에서 발생하는 특정 이벤트\(예: 오프후크 이벤트\)에 대한 알림을 받도록 요청할 수 있습니다.

통화 에이전트는 SignalRequests 매개변수에 이벤트 이름을 제공하여 특정 신호가 엔드포인트\(예: 발신음\)에 적용되도록 요청할 수도 있습니다.

이벤트와 신호는 패키지로 그룹화되어 있으며, 그 안에서는 다음에서 이벤트 이름으로 참조할 동일한 이름 공간을 공유합니다. 이벤트 이름은 대소문자를 구분하지 않는 문자, 하이픈, 숫자로 구성된 문자열이며, 하이픈은 이름의 첫 번째 또는 마지막 문자가 될 수 없다는 제한사항이 있습니다. 일부 이벤트 코드는 추가 데이터로 매개변수화해야 할 수 있으며, 이는 괄호 세트 사이에 매개변수를 추가하여 수행됩니다. 이벤트 이름은 대소문자를 구분하지 않습니다. "hu", "Hu", "HU" 또는 "hU"와 같은 값은 동일합니다.\(MUST NOT\)

이벤트 이름의 예로는 "hu"\(오프 후크 또는 "끊기" 전환\), "hf"\(후크 플래시\) 또는 "0"\(숫자 0\)이 있습니다.

엔드포인트에 대한 기본 패키지의 이벤트에 대한 패키지 이름은 선택 사항이지만 항상 패키지 이름을 포함하는 것이 좋습니다. 패키지 이름이 이벤트 이름에서 제외되는 경우 해당 엔드포인트의 기본 패키지 이름을 가정해야 합니다. 예를 들어, 기본적으로 회선 패키지\("L"\)가 있고 해당 패키지의 이벤트 중 하나로 발신음\("dl"\)이 있는 아날로그 액세스 회선의 경우 다음 두 이벤트 이름은 동일합니다.\(SHOULD, MUST\)

```text
      L/dl

   and

      dl
```

해당 엔드포인트와 연결된 기타 기본이 아닌 패키지\(예: 아날로그 액세스 엔드포인트 유형에 대한 일반 패키지\)의 경우 패키지 이름이 이벤트 이름에 포함되어야 합니다. 다시 한번 말하지만, 패키지 이름을 무조건 포함하는 것이 좋습니다.\(MUST, SHOULD\)

숫자나 문자는 일부 패키지, 특히 "DTMF"에서 지원됩니다. 숫자와 문자는 숫자 맵 정의의 "숫자" 및 "문자" 규칙에 따라 정의됩니다. 이 정의는 숫자\(0\~9\), 별표 또는 별표\("\*"\), 직교, 숫자 또는 파운드 기호\("#"\), 문자 "A", "B", "C"를 나타냅니다. 및 "D", 타이머 표시 "T". 이러한 문자는 사용자가 다이얼을 누른 키를 나타내는 "숫자 문자열"로 결합될 수 있습니다. 또한 문자 "X"는 모든 숫자\(0\~9\)를 나타내는 데 사용할 수 있습니다. 또한 확장은 다른 문자의 사용을 정의할 수도 있습니다. 이전 버전의 프로토콜에서 숫자 문자열을 쉽게 표현해야 하는 필요성은 이벤트 이름의 형식에 영향을 미칩니다.\(MAY\)

숫자를 나타내지 않는 이벤트 이름은 숫자도 아니고 문자 A, B, C, D, T 또는 X 중 하나도 아닌 문자를 항상 하나 이상 포함해야 합니다\(이러한 이름에는 특수 기호 "만 ​​포함해서는 안 됩니다. \*", 또는 "#"\). 그러나 두 개 이상의 문자로 구성된 이벤트 이름은 위의 문자 중 하나를 사용할 수 있습니다.\(MUST NOT\)

통화 에이전트는 이벤트 그룹을 감지하기 위해 게이트웨이에 요청해야 하는 경우가 많습니다. 이러한 그룹을 나타내는 데 두 가지 규칙을 사용할 수 있습니다.

\* "\*" 및 "all" 와일드카드 규칙\(아래 참조\)을 사용하여 패키지에 속한 이벤트, 여러 패키지의 특정 이벤트 또는 게이트웨이가 지원하는 모든 패키지의 이벤트를 검색할 수 있습니다.

\* 정규식 범위 표기법을 사용하여 숫자 범위를 감지할 수 있습니다.

별표\(\*\)를 패키지 이름 대신 와일드카드로 사용할 수 있으며, "all" 키워드를 이벤트 이름 대신 와일드카드로 사용할 수 있습니다.

\* "foo/all"과 같은 이름은 "foo" 패키지의 모든 이벤트를 나타냅니다.

\* "\*/bar"와 같은 이름은 게이트웨이에서 지원하는 모든 패키지의 이벤트 "bar"를 나타냅니다.

\* "\*/all"이라는 이름은 엔드포인트에서 지원하는 모든 이벤트를 나타냅니다.

이 사양은 의도적으로 "모든 패키지" 및 "모든 이벤트" 와일드카드에 대한 추가 세부 정보를 정의하지 않습니다. 이점은 제한적이지만 오류 가능성과 함께 상당한 복잡성이 발생합니다. 따라서 이들의 사용은 강력히 권장되지 않습니다.

통화 에이전트는 해당 문자를 개별적으로 설명하거나 숫자 문자열 구문에 정의된 "범위" 표기법을 사용하여 일련의 숫자 또는 문자를 감지하도록 게이트웨이에 요청할 수 있습니다. 예를 들어 통화 상담원은 다음을 수행할 수 있습니다.

\* 문자 "x"를 사용하여 0부터 9까지의 숫자를 나타냅니다. \* "\[0-9#\]" 표기법을 사용하여 숫자 0부터 9와 파운드 기호를 나타냅니다.

그러나 개별 이벤트 코드는 여전히 패키지\(예: "DTMF" 패키지\)에 정의되어 있습니다.

이벤트는 기본적으로 엔드포인트에서만 생성되고 감지될 수 있지만 엔드포인트 자체가 아닌 연결에서 생성되거나 감지될 수 있도록 이벤트를 정의할 수도 있습니다\(섹션 6.6 참조\). 예를 들어, 게이트웨이는 연결 시 통화 연결음을 제공하도록 요청받을 수 있습니다. 이벤트가 연결에 적용되는 경우 다음과 같이 "at" 기호\(@\)를 구분 기호로 사용하여 연결 이름을 이벤트 이름에 추가해야 합니다.\(MUST\)

```text
      G/rt@0A3F58
```

여기서 "G"는 패키지 이름이고 "rt"는 이벤트 이름입니다. 이벤트 또는 신호가 감지되거나 적용되는 동안 연결이 삭제되면 해당 특정 이벤트 감지 또는 신호 생성이 중지됩니다. 신호에 따라 오류가 발생할 수 있습니다\(아래 참조\).

와일드카드 문자 "\*"\(별표\)를 사용하여 "모든 연결"을 나타낼 수 있습니다. 이 규칙을 사용하면 게이트웨이는 엔드포인트에 연결된 모든 연결에서 이벤트를 생성하거나 감지합니다. 이는 끝점에 생성되는 기존 연결은 물론 향후 연결에도 적용됩니다. 이 규칙의 예는 다음과 같습니다.

```text
      R/qa@*
```

여기서 "R"은 패키지 이름이고 "qa"는 이벤트 이름입니다.

"모든 연결" 와일드카드를 사용하여 명령을 처리할 때 "\*" 와일드카드 문자는 엔드포인트의 모든 현재 및 미래 연결에 적용되지만 확장되지는 않습니다. 후속 명령이 명시적으로\(예: 감사를 통해\) 또는 암시적으로\(예: 지속성을 통해\) 해당 이벤트를 참조하는 경우 "\*" 값이 사용됩니다. 그러나 이벤트가 실제로 관찰되면 해당 이벤트의 특정 발생에는 해당 이벤트가 발생한 특정 연결의 이름이 포함됩니다.

와일드카드 문자 "$"를 사용하여 "현재 연결"을 나타낼 수 있습니다. 이벤트 알림 요청이 연결 생성 또는 수정 명령 내에서 "캡슐화"된 경우 호출 에이전트에서만 사용할 수 있습니다. 이 규칙을 사용하면 게이트웨이는 현재 생성되거나 수정되는 연결에서 이벤트를 생성하거나 감지합니다. 이 규칙의 예는 다음과 같습니다.

```text
      G/rt@$
```

"현재 연결" 와일드카드를 사용하여 명령을 처리할 때 "$" 와일드카드 문자는 현재 연결 값으로 확장됩니다. 후속 명령이 명시적으로\(예: 감사를 통해\) 또는 암시적으로\(예: 지속성을 통해\) 해당 이벤트를 참조하는 경우 확장된 값이 사용됩니다. 즉, "현재 연결" 와일드카드는 명시적으로 포함된 명령의 초기 처리 시 한 번 확장됩니다.

연결 ID 또는 와일드카드 대체는 "모든 패키지" 및 "모든 이벤트" 규칙과 함께 사용할 수 있습니다. 예를 들어 다음과 같은 표기법이 있습니다.

```text
      */all@*
```

끝점의 모든 현재 및 미래 연결에 대한 모든 이벤트를 지정하는 데 사용할 수 있습니다. 그러나 앞서 언급한 것처럼 "모든 패키지" 및 "모든 이벤트" 와일드카드는 사용하지 않는 것이 좋습니다.

신호는 동작에 따라 다양한 유형으로 구분됩니다.

\* 온/오프\(OO\): 한번 적용되면 이 신호는 꺼질 때까지 지속됩니다. 이는 재부팅/재시작 또는 신호가 명시적으로 꺼진 새 SignalRequests의 결과로만 발생할 수 있습니다\(나중에 참조\). OO 유형의 신호는 멱등성으로 정의되므로 주어진 OO 신호를 켜거나 끄기 위한 여러 요청은 다음과 같습니다.

완벽하게 유효하며 오류가 발생해서는 안 됩니다. 켜기/끄기 신호는 VMWI\(시각적 메시지 대기 표시기\)일 수 있습니다. 일단 켜지면 통화 에이전트가 명시적으로 지시할 때까지 또는 엔드포인트 재시작의 결과로 꺼지면 안 됩니다. 즉, 이러한 신호는 요청된 이벤트 감지의 결과로 꺼지지 않습니다.\(MUST NOT, MUST NOT\)

\* 타임아웃\(TO\): 일단 적용되면 이러한 신호는 취소되거나\(이벤트 발생 또는 후속 신호 목록\(비어 있을 수 있음\)에 포함되지 않음\) 또는 신호별 기간이 끝날 때까지 지속됩니다. 시간이 지났습니다. 시간 초과된 TO 신호는 "작업 완료" 이벤트를 생성합니다. TO 신호는 180초 후에 "링백" 시간 초과될 수 있습니다. 180초 이전에 이벤트가 발생하면 기본적으로 신호가 중지됩니다\("신호 활성 유지" 작업\(섹션 2.3.3 참조\)이 이 동작을 무시합니다\). 신호가 중지되지 않으면 신호는 시간 초과되고 중지되며 "작업 완료" 이벤트가 생성됩니다. 이에 대해 통화 에이전트가 알림을 요청하거나 요청하지 않았을 수 있습니다. 호출 에이전트가 "작업 완료" 이벤트를 알리도록 요청한 경우 호출 에이전트로 전송된 "작업 완료" 이벤트에는 시간 초과된 신호의 이름이 포함되어야 합니다\(매개변수가 신호에 전달되면 매개변수가 보고되지 않습니다. 신호가 연결에서 생성된 경우 연결 이름은 위에서 설명한 대로 포함되어야 합니다. 시간 초과 신호에는 기본 시간 초과 값이 정의되어 있으며 이는 프로비저닝 프로세스에 의해 변경될 수 있습니다. 또한, 타임아웃 기간은 신호에 대한 매개변수로 제공될 수 있습니다\(섹션 3.2.2.4 참조\). 0 값은 제한 시간이 무한하다는 것을 나타냅니다. 시작된 후 "작업 완료" 이벤트를 생성하기 전에 실패한 TO 신호는 실패한 신호의 이름을 포함하는 "작업 실패" 이벤트를 생성합니다. 활성 TO 신호가 있는 연결을 삭제하면 이러한 오류가 발생합니다.\(MUST, MUST, MAY\)

\* 브리프\(BR\): 이러한 신호의 지속 시간은 일반적으로 너무 짧아서 저절로 멈춥니다. 신호 중지 이벤트가 발생하거나 새로운 SignalRequests가 적용되면 현재 활성화된 BR 신호는 중지되지 않습니다. 그러나 아직 적용되지 않은 보류 중인 BR 신호는 취소되어야 합니다. \(NotificationRequest에 BR 신호가 포함되어 있고 이미 활성 BR 신호가 있는 경우 BR 신호는 보류 상태가 됩니다.\) 예를 들어, 짧은 톤은 DTMF 숫자일 수 있습니다. DTMF 숫자 "1"이 현재 재생되고 있고 신호 중지 이벤트가 발생하면 "1"이 완료될 때까지 재생됩니다. DTMF 숫자 "1"의 재생이 끝나기 전에 DTMF 숫자 "2" 재생 요청이 도착하면 DTMF 숫자 "2"가 보류 상태가 됩니다.\(MUST\)

연결에서 생성된 신호에는 해당 연결의 이름이 포함되어야 합니다.\(MUST\)

---
## **2.2 Usage of SDP**

통화 에이전트는 MGCP를 사용하여 IP 주소, UDP 포트, RTP 프로필과 같은 연결 매개 변수에 대한 설명을 엔드포인트에 제공합니다. 이러한 설명은 RFC 2327에 문서화된 IETF 제안 표준인 세션 설명 프로토콜에 설명된 규칙을 따릅니다.

---
## **2.3 Gateway Control Commands**
---
### **2.3.1 Overview of Commands**

이 섹션에서는 MGCP의 명령에 대해 설명합니다. 서비스는 연결 처리 및 엔드포인트 처리 명령으로 구성됩니다. 현재 프로토콜에는 9개의 명령이 있습니다.

\* 통화 에이전트는 게이트웨이에 EndpointConfiguration 명령을 발행하여 엔드포인트의 "회선 측"에서 예상되는 코딩 특성에 대해 게이트웨이에 지시할 수 있습니다.

\* 통화 에이전트는 지정된 엔드포인트에서 후크 작업이나 DTMF 신호음과 같은 특정 이벤트를 감시하도록 게이트웨이에 지시하여 게이트웨이에 통지 요청 명령을 실행할 수 있습니다.

\* 그런 다음 게이트웨이는 Notify 명령을 사용하여 요청된 이벤트가 발생할 때 호출 에이전트에 알립니다.

\* 통화 에이전트는 CreateConnection 명령을 사용하여 게이트웨이 내부의 "엔드포인트"에서 종료되는 연결을 생성할 수 있습니다.

\* 통화 에이전트는 ModifyConnection 명령을 사용하여 이전에 설정된 연결과 관련된 매개변수를 변경할 수 있습니다.

\* 통화 에이전트는 DeleteConnection 명령을 사용하여 기존 연결을 삭제할 수 있습니다. DeleteConnection 명령은 연결이 더 이상 지속될 수 없음을 나타내기 위해 게이트웨이에서 사용될 수도 있습니다.

\* 통화 에이전트는 AuditEndpoint 및 AuditConnection 명령을 사용하여 "엔드포인트" 및 이와 관련된 모든 연결의 상태를 감사할 수 있습니다. 일반적으로 이러한 명령이 제공하는 기능 이상의 네트워크 관리가 바람직합니다. 이러한 기능은 SNMP\(Simple Network Management Protocol\)를 사용하고 본 사양의 범위를 벗어나는 MIB 정의를 통해 지원될 것으로 예상됩니다.

\* 게이트웨이는 RestartInProgress 명령을 사용하여 게이트웨이에서 관리하는 엔드포인트 그룹이 서비스에서 제외되거나 다시 서비스로 전환되고 있음을 통화 에이전트에 알릴 수 있습니다.

이러한 서비스를 통해 컨트롤러\(일반적으로 호출 에이전트\)는 게이트웨이에 연결된 "엔드포인트"에서 종료되는 연결 생성에 대해 게이트웨이에 지시하고 엔드포인트에서 발생하는 이벤트에 대한 정보를 받을 수 있습니다. 엔드포인트의 예는 다음과 같습니다.

\* 게이트웨이에서 끝나는 트렁크 그룹 내의 특정 트렁크 회로,

\* 공지 서버에서 처리하는 특정 공지입니다.

연결은 논리적으로 "호출"로 그룹화됩니다\(그러나 "호출"의 개념은 MGCP 자체에서는 의미론적 의미가 거의 없습니다\). 동일한 통화에 속하거나 속하지 않을 수 있는 여러 연결이 동일한 끝점에서 종료될 수 있습니다. 각 연결은 "보내기 전용"\(sendonly\), "수신 전용"\(recvonly\), "보내기/수신"\(sendrecv\), "회의"\(confrnce\), "비활성"으로 설정할 수 있는 "모드" 매개변수로 한정됩니다. "\(비활성\), "루프백", "연속성 테스트"\(conttest\), "네트워크 루프백"\(netwloop\) 또는 "네트워크 연속성 테스트"\(netwtest\).

엔드포인트에서 생성된 미디어는 엔드포인트에 "루프백" 또는 "연속성 테스트" 모드의 연결이 없는 경우 모드가 "보내기 전용", "보내기/수신" 또는 "회의"인 연결을 통해 전송됩니다. 그러나 연결에 신호를 적용하여 생성된 미디어는 모드에 관계없이 항상 연결을 통해 전송됩니다.

연결에서 수신된 미디어 스트림의 처리는 모드 매개변수에 의해 결정됩니다.

\* "수신", "회의" 또는 "전송/수신" 모드의 연결을 통해 수신된 미디어 스트림은 엔드포인트에 "루프백" 또는 "연속성 테스트" 모드의 다른 연결이 없는 한 혼합되어 엔드포인트로 전송됩니다.

\* 엔드포인트에서 시작되는 미디어 스트림은 엔드포인트에 "루프백" 또는 "연속성 테스트" 모드의 다른 연결이 없는 한 모드가 "보내기", "회의" 또는 "보내기/수신"인 모든 연결을 통해 전송됩니다.

\* 엔드포인트로 전송되는 것 외에도 "회의" 모드의 연결을 통해 수신된 미디어 스트림은 모드가 "회의"인 다른 모든 연결로 전달됩니다. 이는 또한 적용됩니다

엔드포인트가 "루프백" 또는 "연속성 테스트" 모드로 연결되어 있는 경우. RTP 변환기 또는 믹서 등 이 전달의 세부 사항은 이 문서의 범위를 벗어납니다.

연결에서 이벤트를 감지하려면 연결이 기본적으로 "수신", "회의", "보내기/수신", "네트워크 루프백" 또는 "네트워크 연속성 테스트" 모드 중 하나에 있어야 합니다. 이벤트 감지는 수신 미디어에만 적용됩니다. 따라서 "sendonly", "inactive", "loopback" 또는 "continuity test" 모드의 연결은 일반적으로 이벤트를 감지하지 못하지만 그렇게 하도록 요청하는 것은 오류로 간주되지 않습니다.

"루프백" 및 "연속성 테스트" 모드는 유지 관리 및 연속성 테스트 작업 중에 사용됩니다. 엔드포인트는 "루프백" 또는 "연속성 테스트" 모드에서 둘 이상의 연결을 가질 수 있습니다. 해당 특정 모드에 하나의 연결이 있고 엔드포인트의 다른 연결이 다른 유지 관리 또는 테스트 모드에 있지 않은 한 유지 관리 또는 테스트 작업은 방해받지 않고 계속되어야 합니다. 연속성 테스트에는 두 가지 종류가 있습니다. 하나는 ITU에서 지정하고 다른 하나는 미국에서 사용됩니다. 첫 번째 경우 테스트는 루프백 테스트입니다. 발신 스위치는 베어러 회로에 톤\(진행 톤\)을 보내고 종료 스위치가 톤을 루프백할 것으로 예상합니다. 원래 스위치에서 반환된 동일한 톤\(반환 톤\)을 확인하면 COT가 통과된 것입니다. 그렇지 않은 경우 COT가 실패한 것입니다. 두 번째 경우에는 이동 톤과 복귀 톤이 다릅니다. 발신 스위치는 특정 이동 신호음을 보냅니다. 종료 스위치는 이동 톤을 감지하고 역방향으로 다른 복귀 톤을 나타냅니다. 원래 스위치가 반환 톤을 감지하면 COT가 전달됩니다. 원래 스위치가 반환 톤을 감지하지 못하면 COT가 실패한 것입니다.

모드가 "루프백"으로 설정된 경우 게이트웨이는 엔드포인트에서 들어오는 신호를 동일한 엔드포인트로 반환해야 합니다. 이 절차는 일반적으로 ITU 사양에 따라 트렁크 회로의 연속성을 테스트하는 데 사용됩니다. 모드가 "연속성 테스트"로 설정된 경우 회로의 다른 쪽 끝이 GR 사양에 따라 연속성 테스트 절차를 시작했다는 알림이 게이트웨이에 전달됩니다\(\[22\] 참조\). 게이트웨이는 이중 톤 연속성 테스트에 필요한 응답기 모드에 회로를 배치합니다.

모드가 "네트워크 루프백"으로 설정된 경우 연결에서 수신된 오디오 신호는 동일한 연결에서 다시 에코됩니다. 미디어가 끝점으로 전달되지 않습니다.

모드가 "네트워크 연속성 테스트"로 설정된 경우 게이트웨이는 듀얼 톤 연속성 테스트에 필요한 트랜스폰더 모드에 따라 연결에서 수신된 패킷을 처리하고 처리된 신호를 연결로 다시 보냅니다. 미디어가 전달되지 않습니다.

끝점에. "네트워크 연속성 테스트" 모드는 이전 버전과의 호환성을 위해서만 포함되며 사용이 권장되지 않습니다.

---
### **2.3.2 EndpointConfiguration**

EndpointConfiguration 명령을 사용하여 엔드포인트에서 수신할 신호의 인코딩을 지정할 수 있습니다. 예를 들어, 특정 국제 전화 통신 구성에서 일부 통화는 mu-law로 인코딩된 오디오 신호를 전달하고 다른 통화는 A-law를 사용합니다. 통화 에이전트는 EndpointConfiguration 명령을 사용하여 이 정보를 게이트웨이에 전달할 수 있습니다. 구성은 통화별로 다를 수 있지만 연결이 없는 경우에도 사용할 수 있습니다.

```text
         ReturnCode,
         [PackageList]
         <-- EndpointConfiguration(EndpointId,
                                   [BearerInformation])
```

EndpointId는 EndpointConfiguration이 실행되는 게이트웨이의 엔드포인트 이름입니다. "다음 중 하나" 와일드카드 규칙은 사용하면 안 됩니다. "모두" 와일드카드 규칙을 사용하는 경우 이름이 와일드카드와 일치하는 모든 엔드포인트에 명령이 적용됩니다.\(MUST NOT\)

BearerInformation은 회선측으로 송수신되는 데이터의 코딩을 정의하는 매개변수입니다. 정보는 하위 매개변수 목록으로 인코딩됩니다. 이 사양 버전에서 정의된 유일한 하위 매개변수는 베어러 인코딩이며, 그 값은 "A-law" 또는 "mu-law"로 설정될 수 있습니다. 하위 매개변수 세트는 확장될 수 있습니다.

확장성을 허용하면서 이전 버전과의 호환성을 유지하기 위해 BearerInformation 매개변수는 다음 조건에 따라 조건부 선택 사항입니다.

\* 확장 매개변수\(공급업체, 패키지 또는 기타\)가 사용되지 않는 경우 BearerInformation 매개변수가 필수입니다.\(MUST\)

\* 그렇지 않은 경우 BearerInformation 매개변수는 선택사항입니다.\(MAY\)

생략되면 BearerInformation은 현재 값을 유지해야 합니다.\(MUST\)

ReturnCode는 게이트웨이에서 반환하는 매개변수입니다. 이는 명령의 결과를 나타내며 선택적으로 설명이 뒤따르는 정수로 구성됩니다.

PackageList는 오류 코드 518\(지원되지 않는 패키지\)과 함께 포함될 수 있는 지원 패키지 목록입니다.\(MAY\)

---
### **2.3.3 NotificationRequest**

NotificationRequest 명령은 엔드포인트에서 지정된 이벤트가 발생할 때 알림을 보내도록 게이트웨이에 요청하는 데 사용됩니다. 예를 들어, 엔드포인트가 팩스 통신과 관련된 신호음을 수신하고 있음을 게이트웨이가 감지한 경우 알림이 요청될 수 있습니다. 이 알림을 수신하는 엔터티는 이 끝점에 바인딩된 연결에서 다른 유형의 인코딩 방법 사용을 지정하기로 결정하고 그에 따라 ModifyConnection 명령을 사용하여 게이트웨이에 지시할 수 있습니다.

```text
         ReturnCode,
         [PackageList]
         <-- NotificationRequest(EndpointId,
                                 [NotifiedEntity,]
                                 [RequestedEvents,]
                                 RequestIdentifier,
                                 [DigitMap,]
                                 [SignalRequests,]
                                 [QuarantineHandling,]
                                 [DetectEvents,]
                                 [encapsulated EndpointConfiguration])
```

EndpointId는 알림 요청이 실행되는 게이트웨이의 엔드포인트에 대한 식별자입니다. "다음 중 하나" 와일드카드는 사용하면 안 됩니다.\(MUST NOT\)

NotifiedEntity는 엔드포인트에 대한 새로운 "알림 엔터티"를 지정하는 선택적 매개 변수입니다.

RequestIdentifier는 이 요청을 트리거하는 알림과 연관시키는 데 사용됩니다. 해당 알림 명령에서 반복됩니다.

RequestedEvents는 게이트웨이가 감지하고 보고하도록 요청되는 이벤트 매개변수\(섹션 3.2.2.4 참조\)로 한정될 수 있는 이벤트 목록입니다. 이러한 이벤트에는 팩스 신호음, 연속 신호음 또는 온훅 전환 등이 포함될 수 있습니다. 별도로 지정하지 않는 한 이벤트는 엔드포인트에서 감지되지만 일부 이벤트는 연결에서 감지될 수 있습니다. 주어진 이벤트는 RequestedEvents에 두 번 이상 나타나서는 안 됩니다. 매개변수가 생략되면 기본값은 비어 있습니다.\(MUST NOT\)

각 이벤트에는 다음과 같은 하나 이상의 작업이 연결됩니다.

\* 누적된 관찰 이벤트 목록과 함께 해당 이벤트를 즉시 알려드리며,

```text
   * Swap audio,
```

\* 이벤트 버퍼에 이벤트를 누적하지만 아직 알리지는 않습니다.

\* 숫자 지도에 따라 누적되며,

```text
   * Keep Signal(s) active,
```

\* 포함된 알림 요청을 처리합니다.

\* 이벤트를 무시합니다.

알림, 누적, 신호 활성 유지, 내장된 알림 요청 및 무시에 대한 지원이 필요합니다. DTMF를 감지할 수 있는 모든 엔드포인트에서는 숫자 맵에 따른 누적에 대한 지원이 필요합니다. 다른 작업에 대한 지원은 선택 사항입니다. 일련의 작업을 확장할 수 있습니다.\(MUST, MUST, MAY\)

특정 작업은 기본적으로 모든 이벤트에 대해 지정될 수 있지만 일부 작업은 모든 이벤트에 적합하지 않습니다. 예를 들어 숫자 지도에 따라 누적 작업이 포함된 오프 후크 이벤트는 유효하지만 물론 오프 후크 이벤트가 발생하면 숫자 지도 불일치가 즉시 트리거됩니다. 말할 필요도 없이 그러한 관행은 권장되지 않습니다.

일부 작업은 아래 표에 표시된 대로 결합될 수 있습니다. 여기서 "Y"는 두 작업을 결합할 수 있음을 의미하고 "N"은 결합할 수 없음을 의미합니다.

```text
       --------------------------------------------------------------
      |       | Notif | Swap | Accum | AccDi | KeSiA | EmbNo | Ignor |
      |--------------------------------------------------------------|
      | Notif |   N   |   Y  |   N   |   N   |   Y   |   Y*  |   N   |
      | Swap  |   -   |   N  |   Y   |   N   |   N   |   N   |   Y   |
      | Accum |   -   |   -  |   N   |   N   |   Y   |   Y   |   N   |
      | AccDi |   -   |   -  |   -   |   N   |   Y   |   N   |   N   |
      | KeSiA |   -   |   -  |   -   |   -   |   N   |   Y   |   Y   |
      | EmbNo |   -   |   -  |   -   |   -   |   -   |   N   |   N   |
      | Ignor |   -   |   -  |   -   |   -   |   -   |   -   |   N   |
       --------------------------------------------------------------
```

- 참고\(\*\): 게이트웨이가 알림 요청당 둘 이상의 알림 명령을 실행할 수 있도록 허용된 경우 "내장 알림 요청"은 "알림"과만 결합될 수 있습니다\(아래 및 섹션 4.4.1 참조\).

작업을 지정하지 않으면 알림 작업이 적용됩니다. 하나 이상의 작업이 지정된 경우 해당 작업만 적용됩니다. 두 개 이상의 작업이 지정되면 각 작업은 모든 작업과 결합되어야 합니다.\(MUST\)

위의 표에 정의된 기타 작업 - 개별 작업은 동시에 발생하는 것으로 가정됩니다.

클라이언트가 유효하지 않거나 지원되지 않는 작업 또는 불법적인 작업 조합이 포함된 요청을 수신하는 경우 호출 에이전트에 오류를 반환해야 합니다\(오류 코드 523 - 알 수 없거나 불법적인 작업 조합이 권장됨\).\(MUST\)

명령에 지정된 RequestedEvents 매개변수 외에도 일부 MGCP 패키지에는 "지속적 이벤트"가 포함될 수 있습니다\(그러나 이는 일반적으로 권장되지 않습니다. 대안은 부록 B 참조\). 지정된 패키지의 지속성 이벤트는 해당 패키지를 구현하는 엔드포인트에서 항상 감지됩니다. RequestedEvents 목록에 지속성 이벤트가 포함되어 있지 않은데 해당 이벤트가 발생하면 해당 이벤트가 감지되어 다른 모든 이벤트처럼 처리됩니다. 마치 지속성 이벤트가 알림 작업을 통해 요청된 것처럼 처리됩니다. 하지만 지속적인 이벤트가 알림을 트리거하려면 알림 요청이 계속 존재해야 합니다. 따라서 비공식적으로 지속성 이벤트는 눈부심 감지 등이 수행되지 않더라도 알림 작업과 함께 RequestedEvents 목록에 항상 암시적으로 포함되는 것으로 볼 수 있습니다.\(MUST\)

비지속적 이벤트는 RequestedEvents 목록에 명시적으로 포함되어야 하는 이벤트입니다. 요청된 이벤트의 \(비어 있을 수도 있음\) 목록은 요청된 이벤트의 이전 목록을 완전히 대체합니다. 영구 이벤트 외에도 요청된 이벤트 목록에 지정된 이벤트만 엔드포인트에서 감지됩니다. RequestedEvents 목록에 지속적인 이벤트가 포함되어 있는 경우 지정된 작업은 RequestedEvents 목록의 수명 동안 이벤트와 연결된 기본 작업을 대체하며 그 후에는 기본 작업이 복원됩니다. 예를 들어 "오프 후크"가 지속적인 이벤트이고 "오프 후크 무시" 작업이 지정되었으며 오프 후크 지침이 없는 새 요청이 수신된 경우 기본 "오프 후크 알림" 작업이 복원됩니다. .

게이트웨이는 지속적 이벤트와 요청된 이벤트의 결합을 감지합니다. 이벤트가 두 목록 모두에 포함되어 있지 않으면 무시됩니다.

통화 에이전트는 비어 있는\(또는 생략된\) RequestedEvents 목록이 포함된 알림 요청을 게이트웨이로 보낼 수 있습니다. 예를 들어 통화 에이전트는 더 이상 DTMF 숫자를 수집하지 않으려는 경우 게이트웨이에 그렇게 할 수 있습니다. 그러나 지속적인 이벤트는 계속 감지되고 통보됩니다.

오디오 교체 작업은 게이트웨이가 엔드포인트에서 둘 이상의 연결을 처리할 때 사용할 수 있습니다. 이는 통화 대기 및 기타 기능 시나리오의 경우입니다. 피하기 위해

엔드포인트의 오디오 기능에 연결된 연결을 변경할 때 통화 에이전트로의 왕복 여행을 하면,NotificationRequest는 이벤트\(일반적으로 후크 플래시이지만 다른 이벤트일 수도 있음\)를 로컬 스왑 오디오 기능에 매핑할 수 있습니다. 라운드 로빈 방식의 "다음" 연결입니다. 연결이 하나만 있는 경우 이 작업은 사실상 아무 작업도 수행하지 않습니다. 연결이 2개 이상인 경우 순서는 정의되지 않습니다. 엔드포인트에 정확히 두 개의 연결이 있고 그 중 하나는 "비활성"이고 다른 하나는 "보내기/수신" 모드인 경우 스왑 오디오는 "보내기/수신" 연결을 "비활성화"로 만들려고 시도하며 그 반대의 경우도 마찬가지입니다. . 이 사양은 의도적으로 오디오 교체 작업에 대한 추가 세부 정보를 제공하지 않습니다.

찾고 있는 이벤트가 발생할 때 신호를 시작하려면 "EmbeddedNotificationRequest" 작업을 사용할 수 있습니다. 내장된 알림 요청에는 새로운 RequestedEvents 목록, SignalRequests 및 새로운 숫자 지도도 포함될 수 있습니다. 내장된 알림 요청의 의미는 마치 동일한 NotifiedEntity, RequestIdentifier, QuarantineHandling 및 DetectEvents를 사용하여 새 알림 요청이 방금 수신된 것과 같습니다. "내장된 알림 요청"이 활성화되면 "현재 다이얼 문자열"이 지워집니다. 그러나 관찰된 이벤트 목록과 격리 버퍼는 영향을 받지 않습니다\(노티파이와 결합된 경우 알림은 관찰된 이벤트 목록을 지웁니다. 섹션 4.4.1 참조\). EmbeddedNotificationRequest 작업은 트리거 이벤트를 누적하지 않지만 이를 달성하기 위해 Accumulate 작업과 결합할 수 있습니다. EmbeddedNotificationRequest가 실패하면 EmbeddedNotificationRequest실패 이벤트가 생성되어야 합니다\(부록 B 참조\).\(SHOULD\)

MGCP 구현은 적어도 한 수준의 삽입을 지원할 수 있어야 합니다. 이 제한 사항을 존중하는 내장된 알림 요청은 다른 내장된 알림 요청을 포함해서는 안 됩니다.\(MUST, MUST NOT\)

DigitMap은 통화 에이전트가 어떤 숫자가 누적될지에 따라 숫자 맵으로 엔드포인트를 프로비저닝할 수 있도록 하는 선택적 매개변수입니다. 이 선택적 매개변수가 없으면 이전에 정의된 값이 유지됩니다. RequestedEvents 매개변수에 "숫자 지도에 따라 누적" 요청이 포함된 경우 이 매개변수는 명시적으로 또는 이전 명령을 통해 정의되어야 합니다. 이러한 숫자를 모으면 숫자 문자열이 생성됩니다. 숫자 문자열은 NotionRequest 수신 시 null 문자열로 초기화되므로 후속 알림에서는 이 요청 이후에 수집된 숫자만 반환됩니다. 숫자 맵에 따라 누적된 숫자는 발생한 순서대로 다른 누적 이벤트로 보고됩니다. 따라서 누적된 다른 이벤트가 발생할 수도 있습니다.\(MUST\)

숫자 목록 사이에서 발견되었습니다. 게이트웨이가 "숫자 맵에 따라 누적"하도록 요청되고 게이트웨이에 현재 문제의 엔드포인트에 대한 숫자 맵이 없는 경우 게이트웨이는 오류를 반환해야 합니다\(오류 코드 519 - 엔드포인트에 숫자 맵이 없음, 권장됨\). \).\(MUST\)

SignalRequests는 게이트웨이에 적용하도록 요청되는 신호 세트가 포함된 선택적 매개변수입니다. 생략하면 기본값은 비어 있습니다. 여러 신호가 지정되면 신호를 병렬로 적용해야 합니다. 달리 지정하지 않는 한 신호는 끝점에 적용됩니다. 그러나 일부 신호는 연결에 적용될 수 있습니다. 신호는 이벤트 이름인 이름으로 식별되며 신호 매개변수로 한정될 수 있습니다\(섹션 3.2.2.4 참조\). 다음은 신호의 예입니다.\(MUST\)

```text
   * Ringing,

   * Busy tone,

   * Call waiting tone,
```

\* 오프훅 경고음,

\* 연결 시 링백 톤.

신호의 이름과 설명은 해당 패키지에 정의되어 있습니다.

신호는 기본적으로 엔드포인트에 적용됩니다. 엔드포인트에 적용된 신호로 인해 미디어 스트림\(오디오, 비디오 등\)이 생성되는 경우 기본적으로 미디어 스트림은 연결 모드에 관계없이 해당 엔드포인트와 관련된 모든 연결에서 전달되어서는 안 됩니다. 예를 들어, 활성 통화에 관련된 엔드포인트에 통화 대기 신호음이 적용되면 해당 엔드포인트를 사용하는 당사자만 통화 대기 신호음을 듣게 됩니다. 그러나 개별 신호는 다른 동작을 정의할 수 있습니다.\(MUST NOT\)

RemoteConnectionDescriptor를 수신한 연결에 신호가 적용되면 해당 신호에 의해 생성된 미디어 스트림은 현재 연결 모드\(루프백 및 연속성 테스트 포함\)에 관계없이 연결을 통해 전달됩니다. RemoteConnectionDescriptor가 수신되지 않은 경우 게이트웨이는 오류를 반환해야 합니다\(오류 코드 527 - RemoteConnectionDescriptor 누락, 권장\). 이 제한은 연결에서 이벤트를 감지하는 데 적용되지 않습니다.\(MUST\)

비어 있을 수도 있는 신호 목록이 제공되면 이 목록은 현재 활성 시간 초과 신호 목록을 완전히 대체합니다. 새 목록에 제공되지 않은 현재 활성 타임아웃 신호는 반드시 중지되어야 하며 제공된 새 신호는 이제 활성화됩니다. 새로운 신호 목록에 제공되는 현재 활성 타임아웃 신호는 중단 없이 활성 상태를 유지해야 하므로 해당 타임아웃 신호에 대한 타이머는 영향을 받지 않습니다. 결과적으로, 먼저 신호를 끄지 않고는 현재 활성화된 타임아웃 신호에 대해 타이머를 다시 시작할 수 있는 방법이 현재로서는 없습니다. 타임아웃 신호가 매개변수화되면, 이후에 어떤 값이 제공되는지에 관계없이 원래 매개변수 세트가 계속 유효해야 합니다. 주어진 신호는 SignalRequests에서 두 번 이상 나타나서는 안 됩니다. 신호 S를 끝점인 연결 C1과 연결 C2에 적용하면 세 가지 서로 다른 독립적인 신호가 구성됩니다.\(MUST, MUST, MUST, MUST NOT\)

SignalRequests에 의해 트리거된 작업은 RequestedEvents 매개변수에 지정된 이벤트 컬렉션과 동기화됩니다. 예를 들어, 통지 요청이 "벨 울림"을 요구하고 RequestedEvents가 "오프 후크" 이벤트를 찾도록 요청하는 경우, 게이트웨이가 오프 후크 이벤트를 감지하는 즉시 벨 울림이 중지되어야 합니다. 공식적인 정의는 "신호 활성 유지" 작업이 감지된 이벤트와 연관되지 않는 한 요청된 이벤트 중 하나가 감지되자마자 모든 "시간 초과" 신호의 생성이 중지되어야 한다는 것입니다. RequestedEvents 및 SignalRequests는 동일한 이벤트 정의를 참조할 수 있습니다. 어떤 경우에는 게이트웨이에게 이벤트 발생을 감지하도록 요청하고, 다른 경우에는 이벤트를 생성하도록 요청합니다. 특정 엔드포인트가 감지하거나 수행할 수 있는 특정 이벤트 및 신호는 해당 엔드포인트에서 지원하는 패키지 목록에 따라 결정됩니다. 각 패키지는 감지하거나 수행할 수 있는 이벤트 및 신호 목록을 지정합니다. 지정된 엔드포인트에서 지원하지 않는 패키지에 속하는 이벤트를 감지하거나 수행하도록 요청된 게이트웨이는 오류를 반환해야 합니다\(오류 코드 518 - 지원되지 않거나 알 수 없는 패키지, 권장\). 이벤트 이름이 패키지 이름으로 한정되지 않으면 엔드포인트의 기본 패키지 이름이 가정됩니다. 이벤트 이름이 이 기본 패키지에 등록되지 않은 경우 게이트웨이는 오류를 반환해야 합니다\(오류 코드 522 - 해당 이벤트 또는 신호 없음, 권장\).\(MUST, MUST, MUST, MUST\)

통화 에이전트는 요청된 신호 목록이 비어 있는 알림 요청을 보낼 수 있습니다. 예를 들어 타임아웃 신호가 중지되어야 할 때 그렇게 합니다.

"찾은" 이벤트가 발생하자마자 신호를 시작하려는 경우 "EmbeddedNotificationRequest" 작업을 사용할 수 있습니다. 내장된 알림 요청에는 새로운 RequestedEvents 목록, SignalRequests 및 새로운 Digit Map도 포함될 수 있습니다. 내장된 NotificationRequest 작업을 통해 통화 에이전트는

관련 이벤트가 감지된 후 즉시 게이트웨이에서 처리할 "미니 스크립트"입니다. 내장된NotificationRequest에 지정된 모든 SignalRequest는 즉시 시작됩니다. 통화 에이전트와 게이트웨이 간의 불일치를 방지하려면 상당한 주의를 기울여야 합니다. 그러나 새로운 SignalRequests가 이전 활성 시간 초과 신호 목록을 완전히 대체하고 BR 유형 신호가 항상 자체적으로 중지되므로 장기적인 불일치가 발생해서는 안 됩니다. On/Off 유형 신호의 수를 제한하는 것이 좋습니다. 통화 에이전트는 때때로 켜져 있어야 하는 모든 켜기/끄기 신호를 켜고, 꺼져야 하는 모든 켜기/끄기 신호를 끄는 것이 좋은 관행으로 간주됩니다.

무시 작업을 사용하여 이벤트를 무시할 수 있습니다\(예: 지속적인 이벤트가 알림을 받지 않도록 방지\). 그러나 이벤트와 활성 시간 초과 신호 사이의 동기화는 기본적으로 계속 발생합니다. 예를 들어 오프 후크가 작업을 통해 요청된 이벤트인 경우에도 오프 후크가 발생하면 시간 초과 발신음 신호가 중지됩니다. 무시하다"\). 이러한 동기화가 발생하지 않도록 하려면 "신호 활성 유지" 작업도 지정해야 합니다.

선택적 QuarantineHandling 매개변수는 "격리" 이벤트, 즉 이 NotificationRequest 명령이 도착하기 전에 게이트웨이에서 감지되었지만 아직 통화 에이전트에 알리지 않은 이벤트의 처리를 지정합니다. 매개변수는 일련의 처리 옵션을 제공합니다\(자세한 내용은 섹션 4.4.1 참조\).

\* 격리된 이벤트를 처리할지 아니면 폐기할지 여부\(기본값은 이벤트를 처리하는 것임\)

\* 게이트웨이가 이 요청에 대한 응답으로 최대 하나의 알림\(단계별\)을 생성할지 아니면 여러 알림\(루프\)을 생성할지 여부\(기본값은 최대 하나\)

매개변수가 없으면 기본값이 가정됩니다.

격리 처리 매개변수는 감지 및 처리되었지만 명령이 수신될 때 아직 알림을 받지 못한 이벤트의 처리도 제어한다는 점에 유의해야 합니다.

DetectEvents는 격리 기간 동안 게이트웨이가 감지하도록 요청되는 이벤트 목록을 지정하는 선택적 매개변수\(이벤트 매개변수로 한정될 수 있음\)입니다. 이 매개변수가 없으면 격리 기간에 감지할 이벤트는 마지막으로 수신된 DetectEvents 목록에 나열된 이벤트입니다. 또한 게이트웨이는 "무시" 작업이 지정된 이벤트를 포함하여 RequestedEvents 목록에 지정된 이벤트와 지속적인 이벤트도 감지합니다.

인라인 링백 또는 품질 경고와 같은 일부 이벤트 및 신호는 엔드포인트 자체가 아닌 엔드포인트에서 종료되는 연결에서 수행되거나 감지됩니다. 이벤트 이름의 구조\(섹션 2.1.7 참조\)를 통해 호출 에이전트는 이벤트를 수행하거나 감지해야 하는 연결을 지정할 수 있습니다.

NotificationRequest 명령은 동일한 끝점에 적용되는 캡슐화된 EndpointConfiguration 명령을 전달할 수 있습니다. 이 명령이 있는 경우 EndpointConfiguration 명령의 매개변수는 복제되지 않는 EndpointId를 제외하고 NotificationRequest의 일반 매개변수와 함께 포함됩니다.

캡슐화된 EndpointConfiguration 명령은NotificationRequest 명령의 운명을 공유합니다. 알림 요청이 거부되면 EndpointConfiguration이 실행되지 않습니다.

ReturnCode는 게이트웨이에서 반환하는 매개변수입니다. 이는 명령의 결과를 나타내며 선택적으로 설명이 뒤따르는 정수로 구성됩니다.

PackageList는 오류 코드 518\(지원되지 않는 패키지\)과 함께 포함될 수 있는 지원 패키지 목록입니다.\(MAY\)

---
### **2.3.4 Notify**

관찰된 이벤트가 포함된 알림은 트리거 이벤트가 발생할 때 Notify 명령을 통해 게이트웨이에서 전송됩니다.

```text
         ReturnCode,
         [PackageList]
         <-- Notify(EndpointId,
                    [NotifiedEntity,]
                    RequestIdentifier,
                    ObservedEvents)
```

EndpointId는 알림 명령을 실행하는 게이트웨이의 엔드포인트 이름입니다. 식별자는 게이트웨이의 도메인 이름을 포함하여 정규화된 엔드포인트 식별자여야 합니다. 이름의 로컬 부분에는 와일드카드 규칙을 사용하면 안 됩니다.\(MUST, MUST NOT\)

NotifiedEntity는 알림을 요청한 엔터티를 식별하는 매개변수입니다. 이 매개변수는 이 알림을 트리거한 NotifiedEntity 매개변수와 동일합니다. 트리거 요청에 해당 매개변수가 없으면 매개변수가 없습니다. NotifiedEntity 매개변수의 값에 관계없이 알림은 끝점에 대한 현재 "통지 엔터티"로 전송되어야 합니다.\(MUST\)

RequestIdentifier는 이 알림을 트리거한NotificationRequest의 RequestIdentifier 매개 변수를 반복하는 매개 변수입니다. 이 알림을 이를 트리거한 요청과 연관시키는 데 사용됩니다. 지속성 이벤트는 마지막 알림 요청에 포함된 것처럼 여기에서 표시됩니다. 암시적 알림 요청은 재시작 직후에 위치할 수 있습니다. 이에 사용되는 RequestIdentifier는 0\("0"\)이 됩니다. 자세한 내용은 섹션 4.4.1을 참조하세요.\(MAY\)

ObservedEvents는 게이트웨이가 감지하고 축적한 이벤트 목록입니다. 단일 알림은 감지된 순서대로\(FIFO\) 보고될 이벤트 목록을 보고할 수 있습니다.

목록에는 Triggering RequestedRequest의 RequestedEvents 매개변수에서 요청된 이벤트의 식별 정보만 포함됩니다. 여기에는 누적된\(알려지지 않았지만\) 숫자 맵에 따라 처리된\(아직 일치하지 않음\) 이벤트와 알림을 트리거했거나 숫자 맵에서 최종 일치를 제공한 최종 이벤트가 포함됩니다. 숫자 지도에 따라 숫자가 누적되는지 여부에 관계없이 숫자가 누적되면 관찰된 이벤트 목록에 숫자를 추가해야 한다는 점에 유의해야 합니다. 예를 들어, 사용자가 숫자 "1234"를 입력하고 입력된 숫자 "3"과 "4" 사이에 일부 이벤트 E가 누적되면 관찰된 이벤트 목록은 "1, 2, 3, E, 4"가 됩니다. 연결에서 감지된 이벤트에는 "R/qa@0A3F58"과 같은 해당 연결 이름이 포함되어야 합니다\(섹션 2.1.7 참조\).\(MUST, MUST\)

ObservedEvents 목록이 엔드포인트의 용량에 도달하면 ObservedEvents Full 이벤트\(부록 B 참조\)가 생성되어야 합니다\(엔드포인트는 ObservedEvents 목록에 이 이벤트를 포함할 수 있는 용량이 있는지 확인해야 합니다\). ObservedEvents Full 이벤트가 Notify를 트리거하는 데 사용되지 않는 경우 이벤트 처리는 이전과 같이 계속됩니다\(숫자 맵 일치 포함\). 그러나 후속 이벤트는 ObservedEvents 목록에 포함되지 않습니다.\(SHOULD\)

ReturnCode는 통화 에이전트가 반환하는 매개변수입니다. 이는 명령의 결과를 나타내며 선택적으로 설명이 뒤따르는 정수로 구성됩니다.

PackageList는 오류 코드 518\(지원되지 않는 패키지\)과 함께 포함될 수 있는 지원 패키지 목록입니다.\(MAY\)

---
### **2.3.5 CreateConnection**

이 명령은 두 끝점 간의 연결을 만드는 데 사용됩니다.

```text
         ReturnCode,
         [ConnectionId,]
         [SpecificEndPointId,]
         [LocalConnectionDescriptor,]
         [SecondEndPointId,]
         [SecondConnectionId,]
         [PackageList]
         <-- CreateConnection(CallId,
                              EndpointId,
                              [NotifiedEntity,]
                              [LocalConnectionOptions,]
                              Mode,
                              [{RemoteConnectionDescriptor |
                              SecondEndpointId}, ]
                              [Encapsulated NotificationRequest,]
                              [Encapsulated EndpointConfiguration])
```

연결은 끝점에 의해 정의됩니다. CreateConnection의 입력 매개변수는 게이트웨이의 연결 "보기"를 구축하는 데 필요한 데이터를 제공합니다.

CallId는 이 연결이 속한 통화\(또는 세션\)를 식별하는 매개변수입니다. 이 매개변수는 최소한 동일한 게이트웨이를 제어하는 ​​통화 에이전트 모음 내에서 고유해야 합니다. 동일한 호출에 속하는 연결은 동일한 호출 ID를 공유해야 합니다. 호출 ID는 프로토콜에서 의미론적 의미가 거의 없습니다. 그러나 보고 및 회계 목적으로 통화를 식별하는 데 사용될 수 있습니다. 게이트웨이의 연결 처리에는 영향을 주지 않습니다.\(SHOULD, SHOULD\)

EndpointId는 CreateConnection이 실행되는 게이트웨이의 연결 끝점에 대한 식별자입니다. EndpointId는 함수 호출에서 매개 변수 EndpointId에 값을 할당하여 완전히 지정하거나 "다음 중 하나" 와일드카드 규칙을 사용하여 과소 지정될 수 있습니다. 엔드포인트가 과소 지정되면 게이트웨이는 엔드포인트 식별자를 할당해야 하며 응답의 특정EndPointId 매개변수에 전체 값이 반환되어야 합니다. "다음 중 하나" 와일드카드가 사용되면 할당된 엔드포인트는 서비스 중이어야 하며 이미 연결이 있어서는 안 됩니다. 그러한 엔드포인트를 사용할 수 없는 경우 오류 코드 410\(사용 가능한 엔드포인트 없음\)이 반환되어야 합니다. "모두" 와일드카드는 사용하면 안 됩니다.\(MUST, MUST NOT, SHOULD, MUST NOT\)

NotifiedEntity는 엔드포인트에 대한 새로운 "알림 엔터티"를 지정하는 선택적 매개 변수입니다.

LocalConnectionOptions는 통화 에이전트가 게이트웨이의 연결 처리를 지시하기 위해 사용하는 선택적 구조입니다. LocalConnectionOptions 구조에 포함된 필드에는 다음 중 하나 이상이 포함될 수 있습니다\(각 필드는 두 번 이상 제공되어서는 안 됩니다\).\(MUST NOT\)

\* 코덱 압축 알고리즘: 하나 이상의 코덱이 선호하는 순서대로 나열됩니다. 상호 운용성을 위해 G.711 mu-law 인코딩\("PCMU"\)을 지원하는 것이 권장됩니다. 코덱 선택 과정에 대한 자세한 내용은 섹션 2.6을 참조하세요.\(SHOULD\)

\* 패킷화 기간: 단일 밀리초 값 또는 범위를 지정할 수 있습니다. 패킷화 기간은 코덱 압축 알고리즘의 사양과 모순되어서는 안 됩니다. 패킷화 주기와 일치하지 않는 프레임 크기를 갖는 코덱을 지정하고 해당 코덱을 선택하면 게이트웨이는 지정된 프레임 크기와 다르더라도 프레임 크기와 일치하는 패킷화 주기를 사용하도록 인가됩니다. 그렇게 할 때 게이트웨이는 가능한 한 지정된 기간에 가깝게 0이 아닌 패킷화 기간을 선택해야 합니다. 패킷화 기간이 지정되지 않은 경우 엔드포인트는 선택한 코덱에 대한 기본 패킷화 기간을 사용해야 합니다\(SHOULD\).\(SHOULD NOT, SHOULD, SHOULD\)

\* 대역폭: 허용되는 대역폭, 즉 페이로드와 전송 계층 이상의 헤더 오버헤드\(예: IP, UDP, RTP\)입니다. 대역폭 사양은 코덱 압축 알고리즘 또는 패킷화 기간 사양과 모순되어서는 안 됩니다. 코덱이 지정되면 지정된 것보다 더 큰 대역폭을 사용하게 되더라도 게이트웨이는 이를 사용할 권한이 부여됩니다. 대역폭과 코덱 사양 간의 불일치는 오류로 보고되지 않습니다.\(SHOULD NOT\)

\* 서비스 유형: 이 연결에 사용될 서비스 클래스를 나타냅니다. 서비스 유형이 지정되지 않은 경우 게이트웨이는 달리 프로비저닝되지 않는 한 기본값 0을 사용해야 합니다.\(MUST\)

\* 반향 제거 사용법: 기본적으로 전화 통신 게이트웨이는 항상 끝점에서 반향 제거를 수행합니다. 그러나 일부 통화의 경우 이러한 작업을 꺼야 할 수도 있습니다. 반향 제거 매개변수는 "on"\(반향 제거가 요청된 경우\)과 "off"\(꺼진 경우\)의 두 가지 값을 가질 수 있습니다. 매개변수는 선택사항입니다. 연결을 생성할 때 매개변수가 생략되고 끝점에 다른 연결이 없는 경우 끝점은 처음에 반향 제거를 적용해야 합니다. 연결을 생성할 때 매개변수를 생략하고 엔드포인트에 기존 연결이 있는 경우 에코 제거는 변경되지 않습니다. 엔드포인트는 이후에 에코를 활성화하거나 비활성화해야 합니다.\(MUST, SHOULD\)

음성 대역 데이터가 감지되면 취소 - 예를 들어 ITU-T 권장사항 V.8, V.25 및 G.168을 참조하세요. 음성대역 데이터가 종료된 후 반향 제거 처리는 반향 제거 매개변수의 현재 값으로 되돌아가야 합니다. 통화 에이전트가 이 매개변수를 지정하지 않고 에코 취소 처리를 게이트웨이에 맡길 것을 권장합니다.\(MUST, SHOULD\)

\* 침묵 억제: 전화 통신 게이트웨이는 음성 활동 감지를 수행하고 침묵 기간 동안 패킷 전송을 피할 수 있습니다. 그러나 예를 들어 모뎀 호출의 경우 이 감지를 꺼야 합니다. 묵음 억제 매개변수는 "on"\(감지가 요청된 경우\)과 "off"\(요청되지 않은 경우\)의 두 가지 값을 가질 수 있습니다. 기본값은 "off"입니다\(별도로 프로비저닝되지 않는 한\). 음성 대역 데이터를 감지하면 엔드포인트는 묵음 억제를 비활성화해야 합니다\(SHOULD\). 음성대역 데이터가 종료된 후, 묵음 억제 처리는 묵음 억제 매개변수의 현재 값으로 되돌아가야 합니다.\(SHOULD, MUST\)

\* 게인 제어: 전화 통신 게이트웨이는 신호 레벨을 조정하기 위해 엔드포인트에서 게인 제어를 수행할 수 있습니다. 그러나 예를 들어 일부 모뎀 호출의 경우 이 기능을 꺼야 합니다. 이득 제어 매개변수는 "자동"으로 지정되거나 명시적인 이득 데시벨 수로 지정될 수 있습니다. 지정된 게인은 연결이 아닌 끝점을 통해 전송된 미디어에 추가되고 끝점에서 수신된 미디어에서는 뺍니다. 매개변수는 선택사항입니다. 엔드포인트에 다른 연결이 없고 매개변수가 생략된 경우 기본값은 게인 제어를 수행하지 않는 것입니다\(별도로 프로비저닝되지 않는 한\). 이는 0데시벨의 게인을 지정하는 것과 같습니다. 엔드포인트에 다른 연결이 있고 매개변수가 생략된 경우 게인 제어는 변경되지 않습니다. 음성 대역 데이터를 감지하면 엔드포인트는 필요한 경우 이득 제어를 비활성화해야 합니다\(SHOULD\). 음성 대역 데이터가 종료된 후 이득 제어 처리는 이득 제어 매개변수의 현재 값으로 되돌아가야 합니다. 게인 제어 처리는 일반적으로 게이트웨이에 맡기는 것이 가장 좋으므로 이 매개변수의 사용은 권장되지 않습니다.\(SHOULD, MUST, SHOULD NOT\)

\* RTP 보안: 통화 에이전트는 게이트웨이에 오디오 패킷 암호화를 활성화하도록 요청할 수 있습니다. RFC 2327에 지정된 대로 키 사양을 제공하여 이를 수행합니다. 기본적으로 암호화는 수행되지 않습니다.

\* 네트워크 유형: 통화 에이전트는 게이트웨이에 지정된 유형의 네트워크에서 연결을 준비하도록 지시할 수 있습니다. 없는 경우 값은 사용 중인 게이트웨이의 네트워크 유형을 기반으로 합니다.

\* 리소스 예약: 통화 에이전트는 연결을 위해 네트워크 리소스 예약을 사용하도록 게이트웨이에 지시할 수 있습니다. 자세한 내용은 섹션 2.7을 참조하세요.

통화 에이전트는 명령에서 관심을 갖는 관련 필드를 지정하고 나머지는 게이트웨이의 재량에 맡깁니다. 명시적으로 포함되지 않은 위 매개변수의 경우 게이트웨이는 가능하면 기본값을 사용해야 합니다. 이 사양에 포함된 로컬 연결 옵션의 자세한 목록은 섹션 3.2.2.10을 참조하세요. 로컬 연결 옵션 세트를 확장할 수 있습니다.\(SHOULD\)

모드는 연결의 이쪽에 대한 작동 모드를 나타냅니다. 기본 모드는 "보내기", "받기", "보내기/받기", "회의", "비활성", "루프백", "연속성 테스트", "네트워크 루프백" 및 "네트워크 연속성 테스트"입니다. 이러한 모드의 예상 처리는 섹션 2.3의 "게이트웨이 제어 명령" 소개에 지정되어 있습니다. 연결에 적용되는 신호는 연결 모드를 따르지 않습니다. 일부 엔드포인트는 모든 모드를 지원하지 못할 수도 있습니다. 명령이 엔드포인트가 지원하지 않는 모드를 지정하는 경우 오류가 반환됩니다\(오류 517 - 지원되지 않는 모드는 권장됨\). 또한 연결이 아직 RemoteConnectionDescriptor를 수신하지 않은 경우 연결이 "전송 전용", "전송/수신", "회의", "네트워크 루프백" 모드 중 하나에 배치되려고 하면 오류가 반환되어야 합니다. "네트워크 연속성 테스트" 또는 신호\(이벤트 감지와 반대\)가 연결에 적용되는 경우\(오류 코드 527 - RemoteConnectionDescriptor 누락, 권장\) 모드 세트를 확장할 수 있습니다.\(MUST, MUST\)

게이트웨이는 엔드포인트 내의 연결을 고유하게 식별하는 ConnectionId와 SDP에 정의된 미디어의 IP 주소 및 포트와 같은 연결에 대한 정보가 포함된 세션 설명인 LocalConnectionDescriptor를 반환합니다.

특정EndPointId는 응답 엔드포인트를 식별하는 선택적 매개변수입니다. EndpointId 인수가 "다음 중 하나" 와일드카드 이름을 참조하고 명령이 성공하면 반환됩니다. 특정EndPointId가 반환되면 통화 에이전트는 이 연결을 참조하는 연속 명령에서 이를 EndpointId 값으로 사용해야 합니다.\(MUST\)

RemoteConnectionDescriptor 대신 SecondEndpointId를 사용하여 동일한 게이트웨이에 있는 두 엔드포인트 간의 연결을 설정할 수 있습니다. 연결은 정의상 로컬 연결입니다. SecondEndpointId는 매개변수 SecondEndpointId에 값을 할당하여 완전히 지정할 수 있습니다.

함수 호출 또는 "다음 중 하나" 와일드카드 규칙을 사용하여 과소 지정될 수 있습니다. SecondEndpointId가 과소 지정되면 게이트웨이가 두 번째 엔드포인트 식별자를 할당하고 해당 전체 값이 응답의 SecondEndPointId 매개 변수에 반환됩니다.

SecondEndpointId가 지정되면 이 명령은 실제로 ModifyConnection 및 DeleteConnection 명령을 통해 별도로 조작할 수 있는 두 개의 연결을 생성합니다. 첫 번째 연결에 대한 ConnectionId 및 LocalConnectionDescriptor 외에도 생성에 대한 응답은 두 번째 연결을 식별하는 SecondConnectionId 매개 변수를 제공합니다. 두 번째 연결은 "보내기/받기" 모드에서 설정됩니다.

RemoteConnectionDescriptor 매개변수가 포함되지 않은 "CreateConnection" 요청을 수신한 후 게이트웨이는 모호한 상황에 처하게 됩니다. LocalConnectionDescriptor 매개변수를 내보냈으므로 잠재적으로 패킷을 수신할 수 있습니다. 다른 게이트웨이의 RemoteConnectionDescriptor 매개변수를 아직 수신하지 않았기 때문에 수신한 패킷이 통화 에이전트에 의해 승인되었는지 여부를 알 수 없습니다. 따라서 중요한 발표 내용을 잘라내거나 이상한 데이터를 듣는 등 두 가지 위험 사이를 탐색해야 합니다. 게이트웨이의 동작은 Mode 매개변수의 값에 따라 결정됩니다.

\* 모드가 ReceiverOnly로 설정된 경우 게이트웨이는 미디어를 수락하고 엔드포인트를 통해 전송해야 합니다.\(MUST\)

\* 모드가 비활성, 루프백 또는 연속성 테스트로 설정된 경우 게이트웨이는 엔드포인트를 통해 미디어를 전송해서는 안 됩니다.\(MUST NOT\)

SendReceive, Conference, SendOnly, Network Loopback 및 Network Continuity Test 모드 값은 이 상황에서 의미가 없습니다. 이는 오류로 처리되어야 하며 명령은 거부되어야 합니다\(오류 코드 527 - RemoteConnectionDescriptor 누락, 권장됨\).\(MUST\)

명령에는 EndpointId에 적용되는 캡슐화된 알림 요청 명령이 선택적으로 포함될 수 있습니다. 이 경우 RequestIdentifier 매개변수가 있어야 하며 선택적으로 복제되지 않는 EndpointId를 제외하고 알림 요청의 다른 매개변수도 있어야 합니다. 캡슐화된 알림 요청은 연결 생성과 동시에 실행됩니다. 예를 들어 통화 에이전트가 주거용 게이트웨이에 통화를 시작하려는 경우 다음을 수행할 수 있습니다.\(MUST\)

\* 전화가 끊기는 즉시 사용자가 말할 수 있도록 주거용 게이트웨이에 연결 준비를 요청합니다.

\* 주거용 게이트웨이에 벨이 울리도록 요청하고,

\* 전화가 오프훅 상태가 되면 주거용 게이트웨이에 통화 상담원에게 알리도록 요청하세요.

이는 오프후크 이벤트에 대한 RequestedEvents 매개변수와 벨소리 신호에 대한 SignalRequests 매개변수도 전송하여 단일 CreateConnection 명령으로 수행할 수 있습니다.

이러한 매개변수가 존재하는 경우 생성 및 알림 요청이 동기화되어야 합니다. 즉, 둘 다 수락해야 하거나 둘 다 거부해야 함을 의미합니다. 이 예에서는 게이트웨이에 리소스가 충분하지 않거나 로컬 네트워크 액세스에서 적절한 리소스를 얻을 수 없는 경우 CreateConnection이 거부될 수 있으며, 사용자가 이미 꺼져 있는 경우 글레어 조건에서 오프 후크 알림 요청이 거부될 수 있습니다. 훅. 이 예에서 연결을 설정할 수 없는 경우 전화 벨이 울리면 안 되며, 사용자가 이미 오프훅 상태인 경우에는 연결이 설정되어서는 안 됩니다.\(MUST\)

NotifiedEntity 매개변수가 있는 경우 엔드포인트에 대한 새로운 "알림 엔터티"를 정의합니다.

이 명령은 EndpointId에 적용되는 캡슐화된 EndpointConfiguration 명령을 전달할 수 있습니다. 이 명령이 있는 경우 EndpointConfiguration 명령의 매개변수는 복제되지 않는 EndpointId를 제외하고 CreateConnection의 일반 매개변수와 함께 포함됩니다. EndpointConfiguration 명령은 캡슐화된NotificationRequest 명령과 함께 캡슐화될 수 있습니다. 이 두 가지 모두 EndpointId에만 적용됩니다.

캡슐화된 EndpointConfiguration 명령은 CreateConnection 명령의 운명을 공유합니다. CreateConnection이 거부되면 EndpointConfiguration이 실행되지 않습니다.

ReturnCode는 게이트웨이에서 반환하는 매개변수입니다. 이는 명령의 결과를 나타내며 선택적으로 설명이 뒤따르는 정수로 구성됩니다.

PackageList는 오류 코드 518\(지원되지 않는 패키지\)과 함께 포함될 수 있는 지원 패키지 목록입니다.\(MAY\)

---
### **2.3.6 ModifyConnection**

이 명령은 연결에 대한 게이트웨이의 "보기" 특성을 수정하는 데 사용됩니다. 호출의 이 "보기"에는 로컬 연결 설명자와 원격 연결 설명자가 모두 포함됩니다.

```text
         ReturnCode,
         [LocalConnectionDescriptor,]
         [PackageList]
         <-- ModifyConnection(CallId,
                              EndpointId,
                              ConnectionId,
                              [NotifiedEntity,]
                              [LocalConnectionOptions,]
                              [Mode,]
                              [RemoteConnectionDescriptor,]
                              [Encapsulated NotificationRequest,]
                              [Encapsulated EndpointConfiguration])
```

사용되는 매개 변수는 CreateConnection 명령과 동일하며 끝점 내에서 연결을 식별하는 ConnectionId가 추가됩니다. 이 매개변수는 로컬 연결 설명자 외에 CreateConnection 명령에 의해 반환되었습니다. 엔드포인트 컨텍스트 내에서 연결을 고유하게 식별합니다. 연결이 생성될 때 사용된 CallId도 포함되어야 합니다.\(MUST\)

EndpointId는 정규화된 엔드포인트 식별자여야 합니다. 로컬 이름은 와일드카드 규칙을 사용하면 안 됩니다.\(MUST, MUST NOT\)

ModifyConnection 명령을 사용하면 다음과 같은 방법으로 연결 매개변수에 영향을 줄 수 있습니다.

\* RemoteConnectionDescriptor를 통해 연결의 반대쪽에 대한 정보를 제공합니다. 매개변수를 생략하면 현재 값이 유지됩니다.

\* 모드 매개변수의 값을 변경하여 연결을 활성화하거나 비활성화합니다. 이는 임의의 매개변수 값을 사용하여 연결 중 언제든지 발생할 수 있습니다. 매개변수를 생략하면 현재 값이 유지됩니다.

\* LocalConnectionOptions를 통해 연결 매개변수를 변경합니다. 예를 들어 다른 코딩 방식으로 전환하거나, 패킷화 기간을 변경하거나, 에코 제거 처리를 수정합니다. 하나 이상의 LocalConnectionOptions 매개변수가 생략되면 게이트웨이는

그러한 변경을 필요로 하는 다른 매개변수가 명시적으로 제공되지 않는 한, 해당 매개변수를 현재 값에서 변경하는 것을 삼가야 합니다\(SHOULD\). 예를 들어 코덱을 변경하려면 묵음 억제를 변경해야 할 수 있습니다. RemoteConnectionDescriptor가 제공되면 실제로 ModifyConnection 명령과 함께 제공되는 LocalConnectionOptions만 코덱 협상에 영향을 미칩니다\(섹션 2.6에 설명되어 있음\).\(SHOULD\)

RemoteConnectionDescriptor가 게이트웨이에 제공된 경우에만 연결이 완전히 활성화될 수 있습니다. 그러나 수신 전용 모드는 이 설명자를 제공하지 않고도 활성화될 수 있습니다.

이 명령은 RTP 포트와 같은 로컬 연결 매개변수가 수정된 경우에만 LocalConnectionDescriptor를 반환합니다. 따라서 예를 들어 연결 모드만 변경되면 LocalConnectionDescriptor가 반환되지 않습니다. 그러나 명령에 LocalConnectionOptions를 포함한다고 해서 로컬 연결 매개 변수가 변경되는 것은 아닙니다. 연결 매개변수가 생략된 경우\(예: 무음 억제\) 가능하면 해당 매개변수의 이전 값이 유지됩니다. 매개변수 변경으로 인해 하나 이상의 지정되지 않은 매개변수가 변경되어야 하는 경우 게이트웨이는 변경해야 하는 지정되지 않은 매개변수에 대해 적절한 값을 자유롭게 선택할 수 있습니다. 예를 들어 패킷화 기간이 지정되지 않은 경우 이런 일이 발생할 수 있습니다. 새 코덱이 이전 패킷화 기간을 지원하는 경우 이 매개변수의 값은 변경이 필요하지 않으므로 변경되지 않습니다. 그러나 이전 패킷화 기간을 지원하지 않는 경우 적절한 값을 선택합니다.

명령에는 캡슐화된 알림 요청 명령이 선택적으로 포함될 수 있습니다. 이 경우 RequestIdentifier 매개변수가 있어야 하며 선택적으로 복제되지 않는 EndpointId를 제외하고 알림 요청의 다른 매개변수도 있어야 합니다. 캡슐화된 알림요청\(NotificationRequest\)은 연결 수정과 동시에 실행됩니다. 예를 들어, 연결이 승인되면 호출 게이트웨이는 회로를 전송-수신 모드로 설정하고 벨소리 제공을 중지하도록 지시해야 합니다. 이는 온후크 이벤트에 대한 RequestedEvents 매개변수와 벨소리 제공을 중지하기 위한 빈 SignalRequests 매개변수도 전송하여 단일 ModifyConnection 명령으로 수행할 수 있습니다.\(MUST\)

이러한 매개변수가 존재하는 경우 수정 및 통지요청은 동기화되어야 합니다. 이는 둘 다 승인해야 하거나 둘 다 거부해야 함을 의미합니다.\(MUST\)

NotifiedEntity 매개변수가 있는 경우 엔드포인트에 대한 새로운 "알림 엔터티"를 정의합니다.

이 명령은 동일한 엔드포인트에 적용되는 캡슐화된 EndpointConfiguration 명령을 전달할 수 있습니다. 이 명령이 있는 경우 EndpointConfiguration 명령의 매개변수는 복제되지 않는 EndpointId를 제외하고 ModifyConnection의 일반 매개변수와 함께 포함됩니다. EndpointConfiguration 명령은 캡슐화된NotificationRequest 명령과 함께 캡슐화될 수 있습니다.

캡슐화된 EndpointConfiguration 명령은 ModifyConnection 명령의 운명을 공유합니다. ModifyConnection이 거부되면 EndpointConfiguration이 실행되지 않습니다.

ReturnCode는 게이트웨이에서 반환하는 매개변수입니다. 이는 명령의 결과를 나타내며 선택적으로 설명이 뒤따르는 정수로 구성됩니다.

PackageList는 오류 코드 518\(지원되지 않는 패키지\)과 함께 포함될 수 있는 지원 패키지 목록입니다.\(MAY\)

---
### **2.3.7 DeleteConnection (from the Call Agent)**

이 명령은 연결을 종료하는 데 사용됩니다. 부작용으로 연결 실행에 대한 통계를 수집합니다.

```text
         ReturnCode,
         ConnectionParameters,
         [PackageList]
         <-- DeleteConnection(CallId,
                              EndpointId,
                              ConnectionId,
                              [NotifiedEntity,]
                              [Encapsulated NotificationRequest,]
                              [Encapsulated EndpointConfiguration])
```

이 DeleteConnection 명령 형식의 엔드포인트 식별자는 정규화되어야 합니다. 와일드카드 규칙은 사용하면 안 됩니다.\(MUST, MUST NOT\)

ConnectionId는 삭제할 연결을 식별합니다. 연결이 생성될 때 사용된 CallId도 포함됩니다.

NotifiedEntity 매개변수가 있는 경우 엔드포인트에 대한 새로운 "알림 엔터티"를 정의합니다.

IP 멀티캐스트의 경우 연결을 개별적으로, 독립적으로 삭제할 수 있습니다. 그러나 연결의 끝이 두 개인 유니캐스트의 경우 연결에 관련된 두 게이트웨이 모두에 DeleteConnection 명령을 보내야 합니다. 연결이 삭제되면 이전에 해당 연결에서 지원되었던 미디어 스트림을 더 이상 사용할 수 없습니다. 이전 연결에 대해 수신된 미디어 패킷은 모두 삭제되고 스트림에 대한 새 미디어 패킷은 전송되지 않습니다.

연결이 삭제된 후에는 해당 연결에 대해 요청된 모든 루프백을 취소해야 합니다\(엔드포인트에 루프백을 요청하는 다른 연결이 있는 경우 제외\).

DeleteConnection 명령에 대한 응답으로 게이트웨이는 연결에 대한 통계를 설명하는 연결 매개변수 목록을 반환합니다.

인터넷 미디어 스트림에 대한 연결인 경우 이러한 매개변수는 다음과 같습니다.

전송된 패킷 수:

- 이 연결에서 전송을 시작한 이후 보낸 사람이 전송한 총 미디어 패킷 수입니다. RTP의 경우 송신자가 동기화 소스 식별자\(RTP에 정의된 SSRC\)를 변경하는 경우\(예: ModifyConnection 명령의 결과\) 카운트가 재설정되지 않습니다. 연결이 항상 "수신 전용" 모드로 설정되고 연결에 신호가 적용되지 않은 경우 값은 0입니다.

전송된 옥텟 수:

- 이 연결에서 전송을 시작한 이후 발신자가 미디어 패킷으로 전송한 페이로드 옥텟\(즉, 헤더 또는 패딩을 포함하지 않음\)의 총 수입니다. RTP의 경우 송신자가 SSRC 식별자를 변경하는 경우\(예: ModifyConnection 명령의 결과\) 카운트가 재설정되지 않습니다. 연결이 항상 "수신 전용" 모드로 설정되고 연결에 신호가 적용되지 않은 경우 값은 0입니다.

수신된 패킷 수:

- 이 연결에서 수신을 시작한 이후 발신자가 수신한 총 미디어 패킷 수입니다. RTP의 경우 보낸 사람이 여러 값을 사용한 경우 다른 SSRC에서 받은 패킷도 개수에 포함됩니다. 연결이 항상 "전송 전용" 모드로 설정된 경우 값은 0입니다.

수신된 옥텟 수:

- 이 연결에서 전송을 시작한 이후 발신자가 미디어 패킷으로 전송한 페이로드 옥텟\(예: RTP 또는 패딩과 같은 헤더를 포함하지 않음\)의 총 수입니다. RTP의 경우 보낸 사람이 여러 값을 사용한 경우 다른 SSRC에서 받은 패킷도 개수에 포함됩니다. 연결이 항상 "전송 전용" 모드로 설정된 경우 값은 0입니다.

손실된 패킷 수:

- 수신 시작 이후 손실된 미디어 패킷의 총 개수입니다. 이 숫자는 예상되는 패킷 수에서 실제로 수신된 패킷 수를 뺀 값으로 정의됩니다. 여기서 수신된 패킷 수에는 지연되었거나 중복된 패킷이 포함됩니다. RTP의 경우 보낸 사람이 여러 값을 사용한 경우 다른 SSRC에서 받은 패킷이 개수에 포함됩니다. 따라서 늦게 도착하는 패킷은 손실된 것으로 간주되지 않으며 중복된 패킷이 있는 경우 손실이 음수가 될 수 있습니다. 보낸 사람이 여러 값을 사용한 경우 이 개수에는 다른 SSRC에서 수신한 패킷이 포함됩니다. 예상되는 패킷 수는 다음에 정의된 것처럼 수신된 확장된 마지막 시퀀스 번호에서 수신된 초기 시퀀스 번호를 뺀 값으로 정의됩니다. 보낸 사람이 여러 값을 사용한 경우 이 개수에는 다른 SSRC에서 수신한 패킷이 포함됩니다. 연결이 항상 "전송 전용" 모드로 설정된 경우 값은 0입니다.

```text
   Interarrival jitter:
```

- 밀리초 단위로 측정되고 부호 없는 정수로 표현되는 미디어 패킷 간격 도착 시간의 통계적 변동 추정치입니다. RTP의 경우 도착 간 지터 J는 한 쌍의 패킷에 대해 송신자와 비교하여 수신자에서의 패킷 간격 차이 D의 평균 편차\(평활화된 절대값\)로 정의됩니다. 자세한 계산 알고리즘은 RFC 1889에 나와 있습니다. 보낸 사람이 여러 값을 사용한 경우 개수에는 다른 SSRC에서 수신한 패킷이 포함됩니다. 연결이 항상 "전송 전용" 모드로 설정된 경우 값은 0입니다.

```text
   Average transmission delay:
```

- 밀리초 단위로 표현되는 네트워크 대기 시간의 추정치입니다. RTP의 경우 이는 RTCP 메시지의 발신자가 나타내는 NTP 타임스탬프와 수신자의 NTP 타임스탬프 간의 차이를 메시지 수신 시 측정한 평균값입니다. 평균은 모든 추정치를 합산하여 얻습니다.

- 그런 다음 수신된 RTCP 메시지 수로 나눕니다. 게이트웨이의 시계가 NTP에 의해 동기화되지 않은 경우 대기 시간 값은 RTCP를 통해 측정된 왕복 지연의 절반으로 계산될 수 있습니다. 게이트웨이가 단방향 지연이나 왕복 지연을 계산할 수 없는 경우 매개변수는 null 값을 전달합니다.

이러한 변수에 대한 자세한 정의는 RFC 1889를 참조하세요.

LOCAL 상호 연결을 통해 연결이 설정된 경우 이러한 매개변수의 의미는 다음과 같이 정의됩니다.

전송된 패킷 수:

- 중요하지 않음 - 생략될 수 있습니다.\(MAY\)

전송된 옥텟 수:

- 로컬 연결을 통해 전송된 페이로드 옥텟의 총 개수입니다.

수신된 패킷 수:

- 중요하지 않음 - 생략될 수 있습니다.\(MAY\)

수신된 옥텟 수:

- 연결을 통해 수신된 페이로드 옥텟의 총 수입니다.

손실된 패킷 수:

- 중요하지 않음 - 생략될 수 있습니다. 0 값이 가정됩니다.\(MAY\)

도착간 지터:

- 중요하지 않음 - 생략될 수 있습니다. 0 값이 가정됩니다.\(MAY\)

평균 전송 지연:

- 중요하지 않음 - 생략될 수 있습니다. 0 값이 가정됩니다.\(MAY\)

연결 매개변수 세트를 확장할 수 있습니다. 또한, 그 의미는 위에 지정된 매개변수 중 전부 또는 심지어 일부를 반환하지 않도록 선택할 수 있는 다른 유형의 네트워크에 의해 추가로 정의될 수 있습니다.\(MAY\)

명령에는 캡슐화된 알림 요청 명령이 선택적으로 포함될 수 있습니다. 이 경우 RequestIdentifier 매개변수가 있어야 하며 선택적으로 복제되지 않는 EndpointId를 제외하고 알림 요청의 다른 매개변수도 있어야 합니다. 캡슐화된 알림 요청은 연결 삭제와 동시에 실행됩니다. 예를 들어, 사용자 끊김이 통보되면 게이트웨이에 연결을 삭제하고 오프훅 이벤트 검색을 시작하도록 지시해야 합니다.\(MUST\)

이는 오프후크 이벤트에 대한 RequestedEvents 매개변수와 빈 SignalRequests 매개변수도 전송하여 단일 DeleteConnection 명령으로 수행할 수 있습니다.

이러한 매개변수가 존재하는 경우, DeleteConnection 및 NotificationRequest를 동기화해야 합니다. 이는 둘 다 승인해야 하거나 둘 다 거부해야 함을 의미합니다.\(MUST\)

이 명령은 동일한 엔드포인트에 적용되는 캡슐화된 EndpointConfiguration 명령을 전달할 수 있습니다. 이 명령이 있는 경우 EndpointConfiguration 명령의 매개 변수는 복제되지 않는 EndpointId를 제외하고 DeleteConnection의 일반 매개 변수와 함께 포함됩니다. EndpointConfiguration 명령은 캡슐화된NotificationRequest 명령과 함께 캡슐화될 수 있습니다.

캡슐화된 EndpointConfiguration 명령은 DeleteConnection 명령의 운명을 공유합니다. DeleteConnection이 거부되면 EndpointConfiguration이 실행되지 않습니다.

ReturnCode는 게이트웨이에서 반환하는 매개변수입니다. 이는 명령의 결과를 나타내며 선택적으로 설명이 뒤따르는 정수로 구성됩니다.

PackageList는 오류 코드 518\(지원되지 않는 패키지\)과 함께 포함될 수 있는 지원 패키지 목록입니다.\(MAY\)

---
### **2.3.8 DeleteConnection (from the gateway)**

드문 경우지만 게이트웨이는 연결과 관련된 리소스를 잃어버렸거나 엔드포인트가 더 이상 미디어를 보내거나 받을 의향이 없다는 것을 감지했기 때문에 연결을 지워야 할 수도 있습니다. 그런 다음 게이트웨이는 DeleteConnection 명령의 변형을 사용하여 연결을 종료할 수 있습니다.

```text
         ReturnCode,
         [PackageList]
         <-- DeleteConnection(CallId,
                              EndpointId,
                              ConnectionId,
                              ReasonCode,
                              Connection-parameters)
```

이 DeleteConnection 명령 형식의 EndpointId는 정규화되어야 합니다. 와일드카드 규칙은 사용하면 안 됩니다.\(MUST, MUST NOT\)

ReasonCode는 숫자 이유 코드로 시작하고 선택적으로 설명 텍스트 문자열이 뒤에 오는 텍스트 문자열입니다. 이유 코드는 DeleteConnection의 원인을 나타냅니다. 이유 코드 목록은 섹션 2.5에서 확인할 수 있습니다.

통화, 엔드포인트 및 연결 식별자 외에도 게이트웨이는 DeleteConnection 명령에 대한 응답으로 통화 에이전트에 반환되었을 연결 매개변수도 보냅니다.

ReturnCode는 통화 에이전트가 반환하는 매개변수입니다. 이는 명령의 결과를 나타내며 선택적으로 설명이 뒤따르는 정수로 구성됩니다.

PackageList는 오류 코드 518\(지원되지 않는 패키지\)과 함께 포함될 수 있는 지원 패키지 목록입니다.\(MAY\)

이 명령의 사용은 일반적으로 권장되지 않으며 최후의 수단으로만 수행해야 합니다. 연결이 지속될 수 있는 경우 연결 삭제는 이 영역에서 지능적인 결정을 내릴 수 있는 훨씬 더 나은 위치에 있는 통화 에이전트의 재량에 맡겨야 합니다.

---
### **2.3.9 DeleteConnection (multiple connections from the Call Agent)**

호출 에이전트는 여러 연결을 동시에 삭제하기 위해 변형된 DeleteConnection 함수를 사용할 수 있습니다. DeleteConnection 명령의 이러한 변형으로 다른 명령을 캡슐화하는 것은 허용되지 않습니다. 이 명령은 엔드포인트 호출과 관련된 모든 연결을 삭제하는 데 사용할 수 있습니다.

```text
         ReturnCode,
         [PackageList]
         <-- DeleteConnection(CallId,
                              EndpointId)
```

이 형태의 DeleteConnection 명령에서 EndpointId는 "다음 중 하나" 와일드카드를 사용해서는 안 됩니다. 지정된 CallId가 있는 끝점에 대한 모든 연결이 삭제됩니다. EndpointId가 유효한 동안에는 지정된 CallId와의 연결이 없는 경우에도 명령이 계속 성공합니다. 그러나 EndpointId가 유효하지 않으면 명령이 실패합니다. 이 명령은 개별 통계나 호출 매개변수를 반환하지 않습니다.\(MUST NOT\)

특정 끝점에서 종료되는 모든 연결을 삭제하는 데에도 사용할 수 있습니다.

```text
         ReturnCode,
         [PackageList]
         <-- DeleteConnection(EndpointId)
```

이 형태의 DeleteConnection 명령에서 EndpointId는 "다음 중 하나" 와일드카드를 사용해서는 안 됩니다. 다시 말하지만, 엔드포인트에 연결이 없더라도 명령은 성공합니다.\(MUST NOT\)

마지막으로 통화 상담원은 엔드포인트 이름의 계층 구조를 활용하여 엔드포인트 그룹에 속한 모든 연결을 삭제할 수 있습니다. 이 경우 EndpointId의 "로컬 이름" 구성 요소는 "모두" 와일드카드 규칙을 사용하여 지정됩니다. "다음 중 하나" 규칙은 사용하면 안 됩니다. 예를 들어 엔드포인트 이름이 "X35V3+A4/13"과 같이 물리적 인터페이스 이름과 회선 번호의 조합으로 구성된 경우 통화 에이전트는 회선 번호를 "all of" 와일드카드 문자 "\*로 바꿀 수 있습니다. ", "X35V3+A4/\*"와 같습니다. 이 "와일드카드" 명령은 물리적 인터페이스 "X35V3+A4"에 연결된 회로에 연결된 모든 연결을 삭제하도록 게이트웨이에 지시합니다.\(MUST NOT\)

모든 연결이 삭제된 후에는 연결에 대해 요청된 모든 루프백이 게이트웨이에 의해 취소되어야 합니다.\(MUST\)

이 명령은 개별 통계나 호출 매개변수를 반환하지 않습니다.

ReturnCode는 게이트웨이에서 반환하는 매개변수입니다. 이는 명령의 결과를 나타내며 선택적으로 설명이 뒤따르는 정수로 구성됩니다.

PackageList는 오류 코드 518\(지원되지 않는 패키지\)과 함께 포함될 수 있는 지원 패키지 목록입니다.\(MAY\)

---
### **2.3.10 AuditEndpoint**

AuditEndPoint 명령은 호출 에이전트에서 특정 엔드포인트의 상태를 확인하는 데 사용할 수 있습니다.

```text
         ReturnCode,
         EndPointIdList,|{
         [RequestedEvents,]
         [QuarantineHandling,]
         [DigitMap,]
         [SignalRequests,]
         [RequestIdentifier,]
         [NotifiedEntity,]
         [ConnectionIdentifiers,]
         [DetectEvents,]
         [ObservedEvents,]
         [EventStates,]
         [BearerInformation,]
         [RestartMethod,]
         [RestartDelay,]
         [ReasonCode,]
         [MaxMGCPDatagram,]
         [Capabilities]}
         [PackageList]
         <-- AuditEndPoint(EndpointId,
                           [RequestedInfo])
```

EndpointId는 감사 중인 끝점을 식별합니다. "다음 중 하나" 와일드카드 규칙은 사용하면 안 됩니다.\(MUST NOT\)

EndpointId는 감사 중인 끝점을 식별합니다. "모두" 와일드카드 규칙을 사용하여 서비스 상태에 관계없이 끝점 그룹에 대한 감사를 시작할 수 있습니다. 이 규칙이 사용되는 경우 게이트웨이는 EndPointIdList 매개변수의 와일드카드와 일치하는 엔드포인트 식별자 목록을 반환해야 합니다. 이는 단순히 하나 이상의 특정EndpointId\(각각 별도로 제공됨\)입니다. "모두" 와일드카드가 사용되는 경우 RequestedInfo는 포함되어서는 안 됩니다\(포함되는 경우에는 무시되어야 합니다\). "모두" 와일드카드를 사용하면 잠재적으로 큰 EndPointIdList가 생성될 수 있습니다. 결과 EndPointIdList가 너무 큰 것으로 간주되면 게이트웨이는 오류를 반환합니다\(오류 코드 533 - 응답이 너무 큼, 권장됨\).\(MUST, MUST, SHOULD\)

와일드카드가 아닌 EndpointId가 지정되면 \(비어 있을 수도 있음\) RequestedInfo 매개변수는 지정된 EndpointId에 대해 요청되는 정보를 설명합니다. 이 명령을 사용하면 다음 엔드포인트 정보를 감사할 수 있습니다.

- RequestedEvents, DigitMap, SignalRequests, RequestIdentifier, QuarantineHandling, NotifiedEntity, ConnectionIdentifiers, DetectEvents, ObservedEvents, EventStates, BearerInformation, RestartMethod, RestartDelay, ReasonCode, PackageList, MaxMGCPDatagram 및 기능.

목록은 확장 매개변수로 확장될 수 있습니다. 응답에는 감사 정보가 요청된 각 항목에 대한 정보가 포함됩니다. 빈 값으로 지원되는 매개변수는 항상 반환되어야 합니다. 그러나 엔드포인트가 이해하지 못하는 매개변수에 대해 쿼리하는 경우 엔드포인트는 오류를 생성해서는 안 됩니다. 대신 매개변수는 응답에서 생략되어야 합니다.\(MUST, MUST NOT\)

\* RequestedEvents: 각 이벤트와 관련된 작업 및 이벤트 매개변수를 포함하여 엔드포인트가 사용하고 있는 RequestedEvents의 현재 값입니다. 작업이 포함되지 않은 경우 기본 작업이 가정됩니다. 지속적인 이벤트가 목록에 포함됩니다. 포함된 알림 요청이 활성화된 경우 RequestedEvents는 주변 RequestedEvents\(포함 여부에 관계없이\)가 아닌 포함된 알림 요청에서 요청된 이벤트를 반영합니다.

\* DigitMap: 엔드포인트가 현재 사용 중인 숫자 맵입니다. 엔드포인트에 숫자 맵이 없으면 매개변수는 비어 있습니다.

\* SignalRequests: 다음의 목록입니다. 현재 활성화된 타임아웃 신호, 엔드포인트에 대해 현재 "켜져 있는" 켜짐/꺼짐 신호\(매개변수 유무와 상관없이\), 보류 중인 간략 신호. 타임아웃된 신호와 현재 재생 중인 짧은 신호는 포함되지 않습니다. 원래 SignalRequests에 포함된 모든 신호 매개변수가 포함됩니다.

\* RequestIdentifier: 이 끝점에서 수신한 마지막 알림 요청에 대한 RequestIdentifier입니다\(다른 명령에 캡슐화된 알림 요청 포함\). 재부팅/재시작 이후에 알림요청\(NotificationRequest\)이 수신되지 않으면 값 0이 반환됩니다.

\* QuarantineHandling: 이 끝점에서 수신한 마지막 알림 요청에 대한 QuarantineHandling입니다. QuarantineHandling이 포함되지 않았거나 알림 요청이 수신되지 않은 경우 기본값이 반환됩니다.

\* DetectEvents: 가장 최근에 수신된 DetectEvents 매개변수 값과 엔드포인트에서 구현된 지속성 이벤트의 값입니다. DetectEvents 매개변수가 수신되지 않은 경우\(비어 있을 수 있음\) 목록에는 지속 이벤트만 포함됩니다.

\* NotifiedEntity: 엔드포인트에 대한 현재 "통지된 엔터티"입니다.

\* ConnectionIdentifiers: 지정된 끝점에 대해 현재 존재하는 모든 연결에 대한 ConnectionIdentifiers 목록입니다.

\* ObservedEvents: 엔드포인트에 대해 관찰된 이벤트의 현재 목록입니다.

\* EventStates: 감사 가능한 상태가 연결된 이벤트의 경우 엔드포인트의 상태에 해당하는 이벤트입니다\(예: 엔드포인트가 오프후크인 ​​경우 오프후크\). 개별 이벤트의 정의에는 해당 이벤트에 감사 가능한 상태가 연결되어 있는지 명시되어 있습니다.

\* BearerInformation: 이 엔드포인트에 대해 마지막으로 수신된 BearerInformation 매개변수의 값입니다\(여기에는 BearerInformation이 프로비저닝된 경우가 포함됩니다\). 엔드포인트가 BearerInformation 매개변수를 수신하지 않았고 값도 프로비저닝되지 않은 경우 매개변수는 비어 있습니다.

\* RestartMethod: 엔드포인트가 서비스 중이고 작업이 정상적이거나 엔드포인트가 서비스 중이 되는 과정에 있는 경우 "다시 시작"입니다\(0이 아닌 RestartDelay는 후자를 나타냄\). 그렇지 않은 경우 엔드포인트에서 실행한\(또는 실행했어야 했던\) 마지막 RestartInProgress 명령의 재시작 메서드 매개변수 값입니다. 따라서 "연결 끊김" 끝점은 실제로 연결이 끊어진 동안에만 "연결 끊김"을 보고하고 더 이상 연결이 끊어지지 않으면 "다시 시작"이 보고된다는 점에 유의하세요. 마찬가지로 "cancel-graceful"은 보고되지 않지만 "graceful"은 보고될 수 있습니다\(자세한 내용은 섹션 4.4.5 참조\).

\* RestartDelay: RestartInProgress 명령이 이 응답 시점에 엔드포인트에 의해 실행된 경우 재시작 지연 매개변수의 값이고, 명령에 이 매개변수가 포함되지 않은 경우 0입니다.

\* ReasonCode: 엔드포인트에 대해 게이트웨이가 실행한 마지막 RestartInProgress 또는 DeleteConnection 명령의 ReasonCode 매개변수 값 또는 엔드포인트 상태가 정상인 경우 특수 값 000입니다.

\* PackageList: 패키지 버전 번호를 포함하여 엔드포인트에서 지원하는 패키지입니다. 이전 버전과의 호환성을 위해 매개변수에 대한 지원은 선택사항이지만 패키지 버전이 0보다 높은 구현에서는 이를 지원해야 합니다.\(SHOULD\)

\* MaxMGCPDatagram: 엔드포인트가 수신할 수 있는 바이트 단위의 MGCP 데이터그램의 최대 크기\(섹션 3.5.4 참조\). 이 값은 하위 레이어 오버헤드를 제외합니다. 이전 버전과의 호환성을 위해 이 매개변수에 대한 지원은 선택사항입니다. 값이 반환되지 않으면 기본 최대 MGCP 데이터그램 크기를 가정해야 합니다.\(MAY, SHOULD\)

\* 기능: LocalConnectionOptions 매개변수와 유사하며 패키지 및 연결 모드를 포함하는 엔드포인트에 대한 기능입니다. 확장 기능도 포함될 수 있습니다. 알 수 없는 기능이 보고되면 무시해야 합니다. 침묵 억제와 같은 일부 매개변수가 일부 코덱과만 호환되도록 지정해야 하는 경우 게이트웨이는 각각 다음을 포함할 수 있는 여러 기능 세트를 반환해야 합니다.\(MAY, MUST, MUST\)

- 압축 알고리즘: 지원되는 코덱 목록입니다. 기능 세트의 나머지 매개변수는 이 목록에 지정된 모든 코덱에 적용됩니다.

- 패킷화 기간: 단일 값 또는 범위가 가능합니다.

- 지정됨.

- 대역폭: 단일 값 또는 패킷화 기간 범위에 해당하는 범위가 지정될 수 있습니다\(무음 억제가 없다고 가정\).

- 에코 취소: 엔드포인트에 대한 에코 취소 지원 여부입니다.

- 무음 억제: 무음 억제를 지원하는지 여부입니다.

- 게인 제어: 게인 제어 지원 여부입니다.

- 서비스 유형: 서비스 유형이 지원되는지 여부입니다.

- 리소스 예약 : 리소스 예약 지원 여부를 나타냅니다.

- 보안: 미디어 암호화 지원 여부.

- 네트워크 유형: 지원되는 네트워크 유형입니다.

- 패키지: 지원되는 패키지 목록입니다. 목록의 첫 번째 패키지가 기본 패키지가 됩니다.

- 모드: 지원되는 연결 모드 목록입니다.

그런 다음 통화 에이전트는 AuditConnection 명령을 사용하여 연결에 대한 추가 정보를 얻기로 결정할 수 있습니다.

요청된 정보가 없고 EndpointId가 유효한 엔드포인트\(서비스 중인지 여부\)를 참조하는 경우 게이트웨이는 단순히 긍정적인 승인을 반환합니다.

ReturnCode는 게이트웨이에서 반환하는 매개변수입니다. 이는 명령의 결과를 나타내며 선택적으로 설명이 뒤따르는 정수로 구성됩니다.

PackageList는 오류 코드 518\(지원되지 않는 패키지\)과 함께 포함될 수도 있습니다.\(MAY\)

---
### **2.3.11 AuditConnection**

호출 에이전트는 AuditConnection 명령을 사용하여 연결에 연결된 매개변수를 검색할 수 있습니다.

```text
         ReturnCode,
         [CallId,]
         [NotifiedEntity,]
         [LocalConnectionOptions,]
         [Mode,]
         [RemoteConnectionDescriptor,]
         [LocalConnectionDescriptor,]
         [ConnectionParameters,]
         [PackageList]
         <-- AuditConnection(EndpointId,
                             ConnectionId,
                             RequestedInfo)
```

EndpointId 매개변수는 연결을 처리하는 엔드포인트를 지정합니다. 와일드카드 규칙은 사용하면 안 됩니다.\(MUST NOT\)

ConnectionId 매개 변수는 지정된 끝점의 컨텍스트 내에서 감사된 연결의 식별자입니다.

\(비어 있을 수도 있음\) RequestedInfo는 지정된 EndpointId 내의 ConnectionId에 대해 요청된 정보를 설명합니다. 이 명령을 사용하면 다음 연결 정보를 감사할 수 있습니다.

```text
      CallId, NotifiedEntity, LocalConnectionOptions, Mode,
      RemoteConnectionDescriptor, LocalConnectionDescriptor,
      ConnectionParameters
```

AuditConnection 응답에는 다음과 같은 감사 정보가 요청된 각 항목에 대한 정보가 포함됩니다.

\* CallId, 연결이 속한 통화에 대한 CallId입니다.

\* NotifiedEntity, 연결에 대한 현재 "알림 엔터티"입니다. 이는 끝점에 대한 "알림 엔터티"와 동일합니다\(이전 버전과의 호환성을 위해 여기에 포함됨\).

\* LocalConnectionOptions, 연결에 실제로 제공된 가장 최근의 LocalConnectionOptions 매개변수\(명령에서 LocalConnectionOptions를 생략해도 이 값은 변경되지 않음\) 가장 최근의 LocalConnectionOptions에서 생략된 기본 매개변수는 포함되지 않습니다. ModifyConnection 명령 전체에서 해당 값을 유지하고 연결에 대한 이전 명령에 포함된 LocalConnectionOptions도 최근 LocalConnectionOptions에 제공되었는지 여부에 관계없이 포함됩니다.

\* 모드, 현재 연결 모드입니다.

\* RemoteConnectionDescriptor, 연결을 위해 게이트웨이에 제공된 RemoteConnectionDescriptor입니다.

\* LocalConnectionDescriptor, 연결을 위해 제공된 게이트웨이인 LocalConnectionDescriptor입니다.

\* ConnectionParameters, 연결에 대한 연결 매개변수의 현재 값입니다.

요청된 정보가 없고 EndpointId가 유효한 경우 게이트웨이는 단순히 연결이 존재하는지 확인하고, 그렇다면 긍정적인 승인을 반환합니다. 서비스 외부 엔드포인트에는 연결이 없기 때문에 정의에 따라 이 일이 발생하려면 엔드포인트가 서비스 중이어야 합니다.

ReturnCode는 게이트웨이에서 반환하는 매개변수입니다. 이는 명령의 결과를 나타내며 선택적으로 설명이 뒤따르는 정수로 구성됩니다.

PackageList는 오류 코드 518\(지원되지 않는 패키지\)과 함께 포함될 수 있는 지원 패키지 목록입니다.\(MAY\)

---
### **2.3.12 RestartInProgress**

RestartInProgress 명령은 엔드포인트 또는 엔드포인트 그룹이 서비스 중이거나 서비스 중단되었음을 알리기 위해 게이트웨이에서 사용됩니다.

```text
         ReturnCode,
         [NotifiedEntity,]
         [PackageList]
         <-- RestartInProgress(EndPointId,
                               RestartMethod,
                               [RestartDelay,]
                               [ReasonCode])
```

EndPointId는 서비스 중이거나 서비스가 중단된 엔드포인트를 식별합니다. "모두" 와일드카드 규칙을 사용하여 동일한 통화 에이전트가 관리하는 엔드포인트 그룹\(예: 지정된 인터페이스에 연결된 모든 엔드포인트 또는 지정된 인터페이스에 연결된 모든 엔드포인트\)에 명령을 적용할 수 있습니다. 게이트웨이. "다음 중 하나" 와일드카드 규칙은 사용하면 안 됩니다.\(MUST NOT\)

RestartMethod 매개 변수는 다시 시작 유형을 지정합니다. 다음 값이 정의되었습니다.

\* "graceful" 다시 시작 방법은 지정된 지연 후에 지정된 엔드포인트의 서비스가 중단됨을 나타냅니다. 설정된 연결은 아직 영향을 받지 않지만 통화 에이전트는 새로운 연결 설정을 삼가야 하며 기존 연결을 정상적으로 해제하려고 시도해야 합니다.\(SHOULD\)

\* "강제" 다시 시작 방법은 지정된 엔드포인트의 서비스가 갑자기 중단됨을 나타냅니다. 설정된 연결이 있는 경우 손실됩니다.

\* "다시 시작" 방법은 지정된 "다시 시작 지연" 후에 엔드포인트에서 서비스가 복원됨을 나타냅니다. 즉, 엔드포인트가 서비스 중이 됩니다. 끝점이 깨끗한 기본 상태이고 현재 끝점에 설정된 연결이 없습니다.

\* "연결 끊김" 방법은 엔드포인트의 연결이 끊어졌고 이제 연결 설정을 시도하고 있음을 나타냅니다\(섹션 4.4.7 참조\). "다시 시작 지연"은 엔드포인트의 연결이 끊어진 시간\(초\)을 지정합니다. 설정된 연결은 영향을 받지 않습니다.

\* "cancel-graceful" 방법은 게이트웨이가 이전에 실행된 "graceful" 재시작 명령을 취소하고 있음을 나타냅니다. 엔드포인트는 아직 서비스 중입니다.

다시 시작 방법 목록이 확장될 수 있습니다.

```text
   The optional "restart delay" parameter is expressed as a number of
   seconds.  If the number is absent, the delay value MUST be considered
   null (i.e., zero).  In the case of the "graceful" method, a null
   delay indicates that the Call Agent SHOULD simply wait for the
   natural termination of the existing connections, without establishing
   new connections.  The restart delay is always considered null in the
   case of the "forced" and "cancel-graceful" methods, and hence the
   "restart delay" parameter MUST NOT be used with these restart
   methods.  When the gateway sends a "restart" or "graceful"
```

재시작 지연이 0이 아닌 RestartInProgress 메시지가 있는 경우, 게이트웨이는 "재시작 지연"이 지난 후 업데이트된 RestartInProgress 메시지를 보내야 합니다.\(SHOULD\)

"restart" 메소드에 대한 재시작 지연이 null이면 서비스가 이미 복원되었음을 나타냅니다. 이는 일반적으로 게이트웨이 시작/재부팅 후에 발생합니다. 재부팅으로 인한 게이트웨이 IP 주소 변경의 영향을 완화하기 위해 호출 에이전트는 게이트웨이의 도메인 이름에 대한 DNS 캐시를 플러시하거나 TTL에 관계없이 DNS를 쿼리하여 게이트웨이의 도메인 이름을 확인하려고 할 수 있습니다. 다시 시작된 게이트웨이에 대한 현재 DNS 리소스 레코드.\(MAY\)

선택적 이유 코드 매개변수는 다시 시작의 원인을 나타냅니다.

게이트웨이는 서비스가 중단될 때\(예: 종료되거나 다음에 의해 서비스가 중단될 때\) 통화 에이전트에 대한 호의로 "정상적" 또는 "강제" RestartInProgress 메시지\(관련 엔드포인트에 대해\)를 보내야 합니다. 네트워크 관리 시스템이지만 통화 에이전트가 항상 그러한 메시지 수신에 의존할 수는 없습니다. 게이트웨이는 섹션 4.4.6에 지정된 다시 시작 절차에 따라 서비스가 다시 시작될 때 호출 에이전트에 null 지연이 포함된 "다시 시작" RestartInProgress 메시지\(관련 엔드포인트에 대해\)를 보내야 합니다. 호출 에이전트는 이 메시지 수신에 의존할 수 있습니다. . 또한 게이트웨이는 섹션 4.4.7에 지정된 "연결 끊김" 절차에 따라 "연결 끊김" RestartInProgress 메시지\(관련 엔드포인트에 대해\)를 현재 "통지 엔터티"로 보내야 합니다.\(SHOULD, MUST, MUST\)

RestartInProgress 메시지는 문제의 EndpointId에 대한 현재 "알림 엔터티"로 전송됩니다. 기본 통화 에이전트, 즉 "알림 엔터티"가 프로비저닝되어 재부팅/다시 시작 후 기본 통화 에이전트가 항상 엔드포인트에 대한 "알림 엔터티"가 될 것으로 예상됩니다. 게이트웨이는 게이트웨이의 여러 엔드포인트가 다시 시작되고 해당 엔드포인트가 동일한 호출 에이전트에 의해 관리될 때 생성되는 RestartInProgress 메시지 수를 최소화하기 위해 와일드카드를 최대한 활용해야 합니다.\(SHOULD\)

ReturnCode는 통화 에이전트가 반환하는 매개변수입니다. 이는 명령의 결과를 나타내며 선택적으로 설명이 뒤따르는 정수로 구성됩니다.

NotifiedEntity는 호출 에이전트의 RestartInProgress에 대한 응답과 함께 추가로 반환될 수 있습니다. 이는 일반적으로 "다시 시작" 또는 "연결 끊김"에 대한 응답으로만 수행되어야 합니다\(섹션 4.4.6 및 4.4.7 참조\).\(SHOULD\)

\* 응답에 성공\(반환 코드 200 - 트랜잭션 실행\)이 표시되면 해당 재시작이 성공적으로 완료된 것이며 반환된 NotifiedEntity는 엔드포인트에 대한 새로운 "알림 엔터티"입니다.

\* 통화 상담원의 응답에 오류가 표시된 경우 해당 재시작이 성공적으로 완료되지 않은 것입니다. NotifiedEntity 매개변수가 반환된 응답에 포함된 경우 엔드포인트에 대한 새로운 "통지 엔터티"를 지정합니다. 이는 문제의 다시 시작을 재시도할 때\(새 트랜잭션으로\) 사용해야 합니다. 이 작업은 오류 코드 521\(엔드포인트 리디렉션됨\)에서만 수행되어야 합니다.\(MUST, SHOULD\)

응답에서 NotifiedEntity를 반환하기 위한 위의 동작은 RestartInProgress 응답에 대해서만 정의되며 다른 명령에 대한 응답에 대해 수행되어서는 안 됩니다. 다른 동작은 정의되지 않습니다.\(SHOULD NOT\)

PackageList는 오류 코드 518\(지원되지 않는 패키지\)과 함께 포함될 수 있는 지원 패키지 목록입니다.\(MAY\)

---
## **2.4 Return Codes and Error Codes**

모든 MGCP 명령이 승인됩니다. 승인에는 명령 상태를 나타내는 반환 코드가 포함됩니다. 반환 코드는 다음과 같은 값 범위가 정의된 정수입니다.

\* 000에서 099 사이의 값은 응답 확인을 나타냅니다.

\* 100에서 199 사이의 값은 잠정적 반응을 나타냅니다.

\* 200에서 299 사이의 값은 성공적인 완료를 나타냅니다.

\* 400에서 499 사이의 값은 일시적인 오류를 나타냅니다.

\* 500에서 599 사이의 값은 영구적인 오류를 나타냅니다.

\* 800에서 899 사이의 값은 패키지별 응답 코드입니다.

일시적 오류\(4XX 오류 코드\)와 영구 오류\(5XX 오류 코드\)에 대한 광범위한 설명은 다음과 같습니다.

\* 통화 에이전트가 일시적인 오류를 수신하는 경우 향후 유사한 요청이 엔드포인트에서 수락될 가능성이 예상됩니다. 경우에 따라 엔드포인트 환경의 일부 상태 변경이 필요할 수 있습니다\(예: 오류 코드 401 또는 402의 경우 후크 상태, 오류 코드 403의 경우 리소스 가용성 또는 경우의 대역폭 가용성\). 오류 코드 404\).

\* 영구 오류\(오류 코드 500\~599\)는 프로토콜 오류나 엔드포인트와 통화 에이전트 간의 비호환성 또는 통화 에이전트가 제어할 수 없는 일부 오류 조건으로 인해 하나 이상의 영구적인 조건을 나타냅니다. 예를 들어 프로토콜 오류, 존재하지 않는 엔드포인트 기능에 대한 요청, 엔드포인트와 연결된 인터페이스의 오류, 요청에 누락되거나 잘못된 정보 또는 시간이 지나도 사라지지 않는 기타 여러 조건이 있습니다.

이미 정의된 값은 다음과 같습니다.

```text
   000 Response Acknowledgement.
```

100 현재 트랜잭션이 실행 중입니다. 실제

- 완료 메시지는 추후에 안내드리겠습니다.

101 트랜잭션이 실행 대기 중입니다. 실제 완료 메시지는 나중에 표시됩니다.

200 요청한 트랜잭션이 정상적으로 실행되었습니다. 이 반환 코드는 모든 명령에 대한 성공적인 응답에 사용될 수 있습니다.

250 연결이 삭제되었습니다. 이 반환 코드는 DeleteConnection 명령에 대한 성공적인 응답에만 사용할 수 있습니다.

400 지정되지 않은 일시적인 오류로 인해 트랜잭션을 실행할 수 없습니다.

401 전화가 이미 연결 해제되었습니다.

402 전화기가 이미 연결되어 있습니다.

403 현재 엔드포인트에 충분한 리소스가 없기 때문에 트랜잭션을 실행할 수 없습니다.

404 현재 대역폭이 부족합니다.

405 엔드포인트가 "다시 시작" 중이므로 트랜잭션을 실행할 수 없습니다.

406 트랜잭션 시간 초과. 거래가 합리적인 시간 내에 완료되지 않아 중단되었습니다.

407 거래가 중단되었습니다. 일부 외부 작업\(예: DeleteConnection 명령에 의해 중단된 ModifyConnection 명령\)으로 인해 트랜잭션이 중단되었습니다.

409 내부 과부하로 인해 트랜잭션을 실행할 수 없습니다.

410 사용 가능한 엔드포인트가 없습니다. 유효한 "다음 중 하나" 와일드카드가 사용되었지만 요청을 충족하는 데 사용할 수 있는 엔드포인트가 없습니다.

500 엔드포인트를 알 수 없기 때문에 트랜잭션을 실행할 수 없습니다.

501 엔드포인트가 준비되지 않았기 때문에 트랜잭션을 실행할 수 없습니다. 여기에는 엔드포인트가 서비스되지 않는 경우도 포함됩니다.

502 엔드포인트에 충분한 리소스가 없기 때문에 트랜잭션을 실행할 수 없습니다\(영구적 조건\).

```text
   503 "All of" wildcard too complicated.
```

504 알 수 없거나 지원되지 않는 명령입니다.

505 지원되지 않는 RemoteConnectionDescriptor입니다. 이는 RemoteConnectionDescriptor의 하나 이상의 필수 매개변수 또는 값이 지원되지 않을 때 사용해야 합니다.\(SHOULD\)

506 LocalConnectionOptions와 LocalConnectionOptions를 모두 만족할 수 없습니다.

-RemoteConnectionDescriptor. 이는 LocalConnectionOptions 및 RemoteConnectionDescriptor에 서로 충돌하거나 동시에 지원할 수 없는 하나 이상의 필수 매개변수 또는 값이 포함된 경우 사용해야 합니다\(코덱 협상 실패 제외 - 오류 코드 534 참조\).\(SHOULD\)

507 지원되지 않는 기능입니다. 명령을 수행하는 데 필요한 지정되지 않은 일부 기능은 지원되지 않습니다. 지원되지 않는 기능의 특정 영역\(예: 508, 511 등\)에 대해 여러 가지 다른 오류 코드가 정의되었으며 이 오류 코드는 지원되지 않는 기능에 대해 더 구체적인 오류 코드가 없는 경우에만 사용해야 합니다.\(SHOULD\)

508 알 수 없거나 지원되지 않는 격리 처리입니다.

509 RemoteConnectionDescriptor에 오류가 있습니다. 이는 RemoteConnectionDescriptor에 구문이나 의미 오류가 있는 경우 사용해야 합니다.\(SHOULD\)

510 지정되지 않은 프로토콜 오류가 감지되어 트랜잭션을 실행할 수 없습니다. 이러한 오류로부터의 자동 복구는 매우 어려우므로 이 코드는 최후의 수단으로만 사용해야 합니다.\(SHOULD\)

511 명령에 인식할 수 없는 확장자가 포함되어 있어 트랜잭션을 실행할 수 없습니다. 이 코드는 지원되지 않는 중요 매개변수 확장\("X+"\)에 사용해야 합니다.\(SHOULD\)

512 요청된 이벤트 중 하나를 감지할 수 있는 장치가 게이트웨이에 없기 때문에 트랜잭션을 실행할 수 없습니다.

513 요청된 신호 중 하나를 생성할 수 있는 장비가 게이트웨이에 없기 때문에 트랜잭션을 실행할 수 없습니다.

514 게이트웨이가 지정된 알림을 보낼 수 없기 때문에 트랜잭션을 실행할 수 없습니다.

515 트랜잭션이 잘못된 연결 ID를 참조합니다\(이미 삭제되었을 수 있음\).

516 트랜잭션이 알 수 없는 호출 ID를 참조하거나 제공된 호출 ID가 올바르지 않습니다\(예: 이 호출 ID와 연결되지 않은 연결 ID\).

517 지원되지 않거나 잘못된 모드입니다.

518 지원되지 않거나 알 수 없는 패키지입니다. 특히 호출 에이전트에 의해 응답이 생성되는 경우 응답에 지원되는 패키지 목록과 함께 PackageList 매개 변수를 포함하는 것이 좋습니다.\(SHOULD\)

519 끝점에 숫자 맵이 없습니다.

520 엔드포인트가 "다시 시작" 중이므로 트랜잭션을 실행할 수 없습니다. 대부분의 경우 이는 일시적인 오류이며, 이 경우 오류 코드 405를 대신 사용해야 합니다. 오류 코드는 이전 버전과의 호환성을 위해서만 여기에 포함되었습니다.\(SHOULD\)

521 엔드포인트가 다른 통화 에이전트로 리디렉션되었습니다. 관련 리디렉션 동작은 RestartInProgress 명령에 대해 이 응답이 실행될 때만 잘 정의됩니다.

522 해당 이벤트나 신호가 없습니다. 요청이 관련 패키지\(기본 패키지일 수 있음\)에 정의되지 않은 이벤트 또는 신호를 참조했습니다.

523 알 수 없는 동작이거나 불법적인 동작의 조합입니다.

524 LocalConnectionOptions의 내부 불일치입니다.

525 LocalConnectionOptions의 알 수 없는 확장입니다. 이 코드는 지원되지 않는 필수 공급업체 확장\("x+"\)에 사용해야 합니다.\(SHOULD\)

526 대역폭이 부족합니다. 일시적인 오류인 경우 오류 코드 404를 대신 사용해야 합니다.\(SHOULD\)

```text
   527 Missing RemoteConnectionDescriptor.

   528 Incompatible protocol version.

   529 Internal hardware failure.

   530 CAS signaling protocol error.
```

531 트렁크 그룹화 오류\(예: 시설 오류\)

532 LocalConnectionOptions에 지원되지 않는 값이 있습니다.

```text
   533 Response too large.

   534 Codec negotiation failure.

   535 Packetization period not supported.
```

536 알 수 없거나 지원되지 않는 RestartMethod입니다.

537 알 수 없거나 지원되지 않는 숫자 지도 확장입니다.

```text
   538 Event/signal parameter error (e.g., missing, erroneous,
       unsupported, unknown, etc.).
```

539 잘못되었거나 지원되지 않는 명령 매개변수입니다. 이 코드는 매개변수가 패키지 또는 공급업체 확장 매개변수가 아닌 경우에만 사용해야 합니다.\(SHOULD\)

540 엔드포인트당 연결 제한이 초과되었습니다.

541 유효하지 않거나 지원되지 않는 LocalConnectionOptions입니다. 이 코드는 LocalConnectionOptions가 패키지도 아니고 공급업체 확장 LocalConnectionOptions도 아닌 경우에만 사용해야 합니다.\(SHOULD\)

반환 코드 집합은 프로토콜의 향후 버전에서 확장될 수 있습니다. 알 수 없거나 지원되지 않는 반환 코드를 수신하는 구현은 반환 코드를 다음과 같이 처리해야 합니다.\(SHOULD\)

\* 알 수 없는 0xx 코드는 000으로 처리됩니다.

\* 알 수 없는 1xx 코드는 100으로 처리됩니다.

\* 알 수 없는 2xx 코드는 200으로 처리됩니다.

\* 알 수 없는 3xx 코드는 521로 처리됩니다.

\* 알 수 없는 4xx 코드는 400으로 처리됩니다.

\* 알 수 없는 5xx-9xx 코드는 510으로 처리됩니다.

---
## **2.5 Reason Codes**

이유 코드는 연결을 삭제할 때 게이트웨이에서 연결 삭제 이유를 통화 에이전트에 알리는 데 사용됩니다. RestartInProgress 명령에서 통화 에이전트에게 RestartInProgress 이유를 알리는 데 사용될 수도 있습니다.

이유 코드는 정수이며 다음 값이 정의되었습니다.

000 엔드포인트 상태가 정상입니다\(이 코드는 감사 요청에 대한 응답으로만 사용됩니다\).

```text
   900 Endpoint malfunctioning.

   901 Endpoint taken out-of-service.
```

902 하위 레이어 연결 손실\(예: 다운스트림 동기화\)

903 QoS 리소스 예약이 손실되었습니다.

```text
   904 Manual intervention.

   905 Facility failure (e.g., DS-0 failure).
```

이유 코드 세트는 확장될 수 있습니다.

---
## **2.6 Use of Local Connection Options and Connection Descriptors**

앞에서 설명한 것처럼 양방향 연결을 설정하는 일반적인 순서에는 최소한 3단계가 포함됩니다.

1\) 통화 에이전트는 첫 번째 게이트웨이에 엔드포인트에서 "연결 생성"을 요청합니다. 게이트웨이는 해당 연결에 리소스를 할당하고 "세션 설명"\(LocalConnectionDescriptor라고 함\)을 제공하여 명령에 응답합니다. 세션 설명에는 다른 당사자가 새로 생성된 연결을 향해 패킷을 보내는 데 필요한 정보가 포함되어 있습니다.

2\) 그런 다음 통화 에이전트는 두 번째 게이트웨이에 "생성"을 요청합니다.

- 엔드포인트의 "연결". 명령은 첫 번째 게이트웨이\(현재 RemoteConnectionDescriptor라고 함\)에서 제공한 "세션 설명"을 전달합니다. 게이트웨이는 해당 연결에 리소스를 할당하고 자체 "세션 설명"을 제공하여 명령에 응답합니다. \(로컬 연결 설명자\).

3\) 통화 에이전트는 "연결 수정" 명령을 사용하여 이 두 번째 "세션 설명"\(현재 RemoteConnectionDescriptor 라고 함\)을 첫 번째 끝점에 제공합니다. 이 작업이 완료되면 통신은 양방향으로 진행될 수 있습니다.

통화 에이전트가 연결 생성 또는 수정 명령을 실행하면 해당 연결에서 지원되는 미디어를 결정하는 세 가지 매개 변수가 있습니다.

\* LocalConnectionOptions: 연결을 위해 게이트웨이에서 사용하는 미디어 매개변수를 제어하기 위해 통화 에이전트에서 제공됩니다. 제공된 경우 게이트웨이는 연결이 삭제되거나 새 미디어 매개변수\(LocalConnectionOptions 또는 RemoteConnectionDescriptor\)가 포함된 ModifyConnection 명령이 수신될 때까지 이러한 미디어 매개변수를 준수해야 합니다.\(MUST\)

\* RemoteConnectionDescriptor: 통화 에이전트가 제공하여 연결의 상대방이 지원하는 미디어 매개변수를 전달합니다. 제공된 경우 게이트웨이는 연결이 삭제되거나 새 미디어 매개변수\(LocalConnectionOptions 또는 RemoteConnectionDescriptor\)가 포함된 ModifyConnection 명령이 수신될 때까지 이러한 미디어 매개변수를 준수해야 합니다.\(MUST\)

\* LocalConnectionDescriptor: 연결을 위해 지원하는 미디어 매개변수를 전달하기 위해 게이트웨이에서 통화 에이전트에 제공됩니다. 제공된 경우 게이트웨이는 연결이 삭제되거나 게이트웨이가 해당 연결에 대해 새 LocalConnectionDescriptor를 발행할 때까지 미디어 매개변수를 준수해야 합니다.\(MUST\)

LocalConnectionDescriptor에 제공할 코덱을 결정할 때 게이트웨이가 고려해야 할 세 가지 코덱 목록이 있습니다.

\* 현재 명령의 LocalConnectionOptions에서 허용하는 코덱 목록입니다\(인코딩 방법을 통해 명시적으로 또는 대역폭 및/또는 패킷화 기간을 통해 암시적으로\).

\* 현재 명령의 RemoteConnectionDescriptor에 있는 코덱 목록입니다.

\* 게이트웨이가 연결을 지원할 수 있는 내부 코덱 목록입니다. 게이트웨이는 특정 연결에 대해 하나 이상의 코덱을 지원할 수 있습니다.\(MAY\)

코덱 선택\(모든 관련 미디어 매개변수 포함\)은 다음 단계로 설명할 수 있습니다.

1. 승인된 코덱 목록은 내부 코덱 목록과 LocalConnectionOptions에서 허용하는 코덱의 교차점을 취하여 구성됩니다. 현재 명령에 LocalConnectionOptions가 제공되지 않은 경우 승인된 코덱 목록에는 내부 코덱 목록이 포함됩니다.

2. 승인된 코덱 목록이 비어 있는 경우 코덱 협상 실패가 발생한 것이며 오류 응답이 생성됩니다\(오류 코드 534 - 코덱 협상 실패, 권장\).\(SHOULD\)

3. 그렇지 않으면 승인된 코덱 목록과 RemoteConnectionDescriptor에서 허용하는 코덱의 교차점을 취하여 협상된 코덱 목록이 형성됩니다. 현재 명령에 RemoteConnectionDescriptor가 제공되지 않은 경우 협상된 코덱 목록에는 승인된 코덱 목록이 포함됩니다.

4. 협상된 코덱 목록이 비어 있으면 코덱 협상 실패가 발생한 것이며 오류 응답이 생성됩니다\(오류 코드 534 - 코덱 협상 실패, 권장\).\(SHOULD\)

5. 그렇지 않으면 코덱 협상이 성공하고 협상된 코덱 목록이 LocalConnectionDescriptor에 반환됩니다.

LocalConnectionOptions와 RemoteConnectionDescriptor 모두 기본 설정에 따라 정렬된 코덱 목록을 포함할 수 있습니다. 현재 명령에 둘 다 제공되면 게이트웨이는 LocalConnectionOptions에 제공된 기본 설정을 준수해야 합니다.\(MUST\)

---
## **2.7 Resource Reservations**

예를 들어 RSVP를 사용하여 지정된 연결에서 예약을 수행하도록 게이트웨이에 지시할 수 있습니다. 예약이 필요한 경우 통화 에이전트는 사용할 예약 프로필\("제어된 부하" 또는 "보장된 서비스"\)을 지정합니다. 예약이 없다는 것은 CreateConnection 명령에서 이 매개변수의 기본값인 "최선의 노력" 서비스를 요청하여 나타낼 수 있습니다. ModifyConnection 명령의 경우 기본값은 단순히 현재 값을 유지하는 것입니다. 연결에 대한 예약이 요청되면 게이트웨이는 다음을 수행합니다.

\* 연결이 "보내기 전용", "보내기-받기", "회의", "네트워크 루프백" 또는 "네트워크 연속성 테스트" 모드인 경우 RSVP "PATH" 메시지 보내기 시작\(적절한 원격 연결 설명자가 있는 경우\) 받았다,\).

\* 연결이 "수신 전용", "보내기-수신", "회의", "네트워크 루프백" 또는 "네트워크 연속성 테스트" 모드인 경우 "PATH" 메시지를 수신하자마자 RSVP "RESV" 메시지 보내기 시작 .

RSVP 필터는 연결의 특성에서 추론됩니다. RSVP 리소스 프로필은 연결의 코덱, 대역폭 및 패킷화 기간에서 추론됩니다.

---
## **3. Media Gateway Control Protocol**

MGCP\(미디어 게이트웨이 제어 프로토콜\)는 미디어 게이트웨이 제어 인터페이스를 일련의 트랜잭션으로 구현합니다. 트랜잭션은 명령과 필수 응답으로 구성됩니다. 9개의 명령이 있습니다:

```text
   * EndpointConfiguration

   * CreateConnection

   * ModifyConnection

   * DeleteConnection

   * NotificationRequest

   * Notify

   * AuditEndpoint

   * AuditConnection

   * RestartInProgress
```

처음 5개 명령은 통화 에이전트에 의해 게이트웨이로 전송됩니다. 알림 명령은 게이트웨이를 통해 통화 에이전트로 전송됩니다. 게이트웨이는 섹션 2.3.8에 정의된 대로 DeleteConnection을 보낼 수도 있습니다. 통화 에이전트는 감사 명령 중 하나를 게이트웨이로 보낼 수 있고, 게이트웨이는 RestartInProgress 명령을 통화 에이전트로 보낼 수 있습니다.

---
## **3.1 General Description**

모든 명령은 명령 헤더와 선택적으로 세션 설명으로 구성됩니다.

모든 응답은 응답 헤더로 구성되며 선택적으로 세션 설명 정보가 뒤따릅니다.

헤더와 세션 설명은 캐리지 리턴 및 줄 바꿈 문자\(또는 선택적으로 단일 줄 바꿈 문자\)로 구분된 일련의 텍스트 줄로 인코딩됩니다. 세션 설명 앞에는 빈 줄이 옵니다.

MGCP는 트랜잭션 식별자를 사용하여 명령과 응답을 연관시킵니다. 트랜잭션 식별자는 명령 헤더의 구성 요소로 인코딩되고 응답 헤더의 구성 요소로 반복됩니다\(섹션 3.2.1.2 및 3.3 참조\).

MGCP에 대한 ABNF 문법은 부록 A에 제공됩니다. 명령과 응답은 RFC 2234에 따라 SDP 부분을 제외하고 대소문자를 구분하지 않는 문법에 따라 인코딩되어야 합니다. 마찬가지로 구현은 문법을 따르는 명령과 응답을 디코딩할 수 있어야 합니다. 또한 구현 시 추가 선형 공백을 허용하는 것이 권장됩니다\(RECOMMENDED\).\(MUST, MUST, SHOULD\)

일부 프로덕션에서는 구문 문제를 방지하는 데 필요할 수 있는 인용 문자열 사용을 허용합니다. 인용된 문자열 형식이 사용되는 경우 내용은 UTF-8로 인코딩되며\[20\] 제공되는 실제 값은 인용되지 않은 문자열\(UTF-8 인코딩\)입니다. 인용된 문자열 형식과 인용되지 않은 문자열 형식이 모두 허용되는 경우 문법을 위반하지 않는 한 두 형식 중 하나를 사용할 수 있습니다.

다음에서는 MGCP 명령 및 응답 형식에 대한 추가 세부 정보를 제공합니다.

---
## **3.2 Command Header**

명령 헤더는 다음으로 구성됩니다.

\* 요청된 작업 또는 동사, 트랜잭션 식별자, 작업이 요청된 엔드포인트 및 MGCP 프로토콜 버전을 식별하는 명령줄,

\* 매개변수 이름과 매개변수 값으로 구성된 0개 이상의 매개변수 라인 세트입니다.

다른 참조 표준\(예: SDP\)에서 달리 명시하거나 지시하지 않는 한, 명령 헤더의 각 구성 요소는 대소문자를 구분하지 않습니다. 이는 동사는 물론 매개변수와 값에도 적용됩니다. 따라서 모든 비교에서는 대문자와 소문자뿐 아니라 이들의 조합도 동일한 것으로 취급해야 합니다.\(MUST\)

---
### **3.2.1 Command Line**

명령줄은 다음으로 구성됩니다.

\* 요청된 동사의 이름,

\* 거래 신원,

```text
   * The name of the endpoint(s) that are to execute the command (in
     notifications or restarts, the name of the endpoint(s) that is
     issuing the command),
```

\* 프로토콜 버전.

이 네 가지 항목은 공백\(예: ASCII 공백\(0x20\) 또는 표 형식\(0x09\) 문자\)으로 구분된 인쇄 가능한 ASCII 문자의 문자열로 인코딩됩니다. 정확히 하나의 ASCII 공백 구분 기호를 사용하는 것이 좋습니다. 그러나 MGCP 엔터티는 추가 공백 문자가 포함된 메시지를 구문 분석할 수 있어야 합니다.\(SHOULD, MUST\)

---
#### **3.2.1.1 Coding of the Requested Verb**

요청할 수 있는 동사는 다음 표에 정의된 대로 4자리 대문자 또는 소문자 ASCII 코드\(비교는 대소문자를 구분하지 않음\)로 인코딩됩니다.\(MUST\)

```text
                  -----------------------------
                 |       Verb           | Code |
                 |----------------------|------|
                 | EndpointConfiguration| EPCF |
                 | CreateConnection     | CRCX |
                 | ModifyConnection     | MDCX |
                 | DeleteConnection     | DLCX |
                 | NotificationRequest  | RQNT |
                 | Notify               | NTFY |
                 | AuditEndpoint        | AUEP |
                 | AuditConnection      | AUCX |
                 | RestartInProgress    | RSIP |
                  -----------------------------
```

거래 식별자는 최대 9자리의 십진수 문자열로 인코딩됩니다. 명령줄에서는 동사 코딩 바로 뒤에 옵니다.

프로토콜의 추가 버전에서는 새로운 동사가 정의될 ​​수 있습니다. 실험 목적으로 이 프로토콜의 게시된 버전에서 승인되기 전에 새로운 동사를 사용해야 할 수도 있습니다. 실험 동사는 XPER와 같이 문자 X로 시작하는 4자 코드로 식별되어야 합니다.\(MUST\)

---
#### **3.2.1.2 Transaction Identifiers**

MGCP는 트랜잭션 식별자를 사용하여 명령과 응답을 연관시킵니다. 게이트웨이는 두 개의 별도 트랜잭션 식별자 네임스페이스를 지원합니다.

\* 트랜잭션 전송을 위한 트랜잭션 식별자 네임스페이스, 그리고

\* 트랜잭션을 수신하기 위한 트랜잭션 식별자 네임스페이스.

최소한 지정된 게이트웨이로 전송된 명령에 대한 트랜잭션 식별자는 해당 게이트웨이를 제어하는 ​​호출 에이전트 모음 내에서 트랜잭션의 최대 수명 동안 고유해야 합니다. 따라서 송신 호출 에이전트에 관계없이 게이트웨이는 단순히 트랜잭션 식별자를 검사하여 항상 중복 트랜잭션을 감지할 수 있습니다. 그러나 통화 에이전트 간의 이러한 트랜잭션 식별자 조정은 이 사양의 범위를 벗어납니다.\(MUST\)

지정된 게이트웨이에서 전송된 모든 명령에 대한 트랜잭션 식별자는 명령이 전송된 호출 에이전트에 관계없이 트랜잭션의 최대 수명 동안 고유해야 합니다. 따라서 통화 에이전트는 엔드포인트의 도메인 이름과 트랜잭션 식별자의 조합을 통해 항상 게이트웨이에서 중복 트랜잭션을 감지할 수 있습니다.\(MUST\)

거래 식별자는 최대 9자리의 십진수 문자열로 인코딩됩니다. 명령줄에서는 동사 코딩 바로 뒤에 옵니다.

거래 식별자의 값은 1에서 999,999,999\(둘 다 포함\) 사이입니다. 트랜잭션 식별자는 숫자 값을 기준으로 동일성이 결정되더라도 앞에 오는 0을 사용해서는 안 됩니다. 즉, 앞에 오는 0은 무시됩니다. MGCP 엔터티는 식별자가 사용된 이전 명령이 완료된 후 3분보다 더 빠르게 트랜잭션 식별자를 재사용해서는 안 됩니다.\(SHOULD NOT, MUST NOT\)

---
#### **3.2.1.3 Coding of the Endpoint Identifiers and Entity Names**

끝점 식별자와 엔터티 이름은 RFC 821에 정의된 대로 대소문자를 구분하지 않는 전자 메일 주소로 인코딩되지만 이름의 로컬 부분에는 일부 구문 제한이 있습니다. 또한 로컬 끝점 이름 부분과 도메인 이름 부분 모두 각각 최대 255자일 수 있습니다. 이러한 주소에서 도메인 이름은 엔드포인트가 연결된 시스템을 식별하는 반면, 왼쪽은 해당 시스템의 특정 엔드포인트 또는 엔터티를 식별합니다.

이러한 주소의 예는 다음과 같습니다.

```text
    ------------------------------------------------------------------
   | hrd4/56@gw23.example.net     |  Circuit number 56 in             |
   |                              |  interface "hrd4" of the Gateway  |
   |                              |  23 of the "Example" network      |
   | Call-agent@ca.example.net    |  Call Agent for the               |
   |                              |  "example" network                |
   | Busy-signal@ann12.example.net|  The "busy signal" virtual        |
   |                              |  endpoint in the announcement     |
   |                              |  server number 12.                |
    ------------------------------------------------------------------
```

통지된 엔터티의 이름은 다음과 같이 포트 번호를 추가하여 동일한 구문으로 표현됩니다.

```text
      Call-agent@ca.example.net:5234
```

통지된 엔터티에서 포트 번호가 생략된 경우 기본 MGCP 통화 에이전트 포트\(2727\)를 사용해야 합니다.\(MUST\)

---
#### **3.2.1.4 Coding of the Protocol Version**

프로토콜 버전은 MGCP 키워드, 공백 및 버전 번호, 그리고 선택적으로 프로필 이름으로 코딩됩니다. 버전 번호는 십진수로 코딩된 메이저 버전, 점, 십진수로 코딩된 마이너 버전 번호로 구성됩니다. 이 문서에 설명된 버전은 버전 1.0입니다.

프로필 이름\(있는 경우\)은 줄 끝까지 확장되는 표시\(인쇄 가능\) 문자의 공백으로 구분된 문자열로 표시됩니다. MGCP에 제한 사항이나 기타 프로파일링을 적용하려는 사용자 커뮤니티에 대해 프로필 이름을 정의할 수 있습니다.

초기 메시지에서 버전은 다음과 같이 코딩됩니다.

```text
      MGCP 1.0
```

지원하지 않는 프로토콜 버전이 포함된 명령을 수신하는 엔터티는 오류로 응답해야 합니다\(오류 코드 528 - 호환되지 않는 프로토콜 버전, 권장\). 이는 지원되지 않는 프로필에도 적용됩니다.\(MUST\)

---
### **3.2.2 Parameter Lines**

매개변수 줄은 매개변수 이름으로 구성되며, 대부분의 경우 하나 또는 두 개의 문자와 그 뒤에 콜론, 선택적 공백, 매개변수 값이 옵니다. 명령에 나타날 수 있는 매개변수는 다음 표에 정의되어 있습니다.

```text
    ------------------------------------------------------------------
   |Parameter name        | Code |  Parameter value                   |
   |----------------------|------|------------------------------------|
   |BearerInformation     |   B  |  See description (3.2.2.1).        |
   |CallId                |   C  |  See description (3.2.2.2).        |
   |Capabilities          |   A  |  See description (3.2.2.3).        |
   |ConnectionId          |   I  |  See description (3.2.2.5).        |
   |ConnectionMode        |   M  |  See description (3.2.2.6).        |
   |ConnectionParameters  |   P  |  See description (3.2.2.7).        |
   |DetectEvents          |   T  |  See description (3.2.2.8).        |
   |DigitMap              |   D  |  A text encoding of a digit map.   |
   |EventStates           |   ES |  See description (3.2.2.9).        |
   |LocalConnectionOptions|   L  |  See description (3.2.2.10).       |
   |MaxMGCPDatagram       |   MD |  See description (3.2.2.11).       |
   |NotifiedEntity        |   N  |  An identifier, in RFC 821 format, |
   |                      |      |  composed of an arbitrary string   |
   |                      |      |  and of the domain name of the     |
   |                      |      |  requesting entity, possibly com-  |
   |                      |      |  pleted by a port number, as in:   |
   |                      |      |    Call-agent@ca.example.net:5234  |
   |                      |      |  See also Section 3.2.1.3.         |
   |ObservedEvents        |   O  |  See description (3.2.2.12).       |
   |PackageList           |   PL |  See description (3.2.2.13).       |
   |QuarantineHandling    |   Q  |  See description (3.2.2.14).       |
   |ReasonCode            |   E  |  A string with a 3 digit integer   |
   |                      |      |  optionally followed by a set of   |
   |                      |      |  arbitrary characters (3.2.2.15).  |
   |RequestedEvents       |   R  |  See description (3.2.2.16).       |
   |RequestedInfo         |   F  |  See description (3.2.2.17).       |
   |RequestIdentifier     |   X  |  See description (3.2.2.18).       |
   |ResponseAck           |   K  |  See description (3.2.2.19).       |
   |RestartDelay          |   RD |  A number of seconds, encoded as   |
   |                      |      |  a decimal number.                 |
   |RestartMethod         |   RM |  See description (3.2.2.20).       |
   |SecondConnectionId    |   I2 |  Connection Id.                    |
   |SecondEndpointId      |   Z2 |  Endpoint Id.                      |
   |SignalRequests        |   S  |  See description (3.2.2.21).       |
   |SpecificEndPointId    |   Z  |  An identifier, in RFC 821 format, |
   |                      |      |  composed of an arbitrary string,  |
   |                      |      |  followed by an "@" followed by    |
   |                      |      |  the domain name of the gateway to |
   |                      |      |  which this endpoint is attached.  |
   |                      |      |  See also Section 3.2.1.3.         |
   |----------------------|------|------------------------------------|

   |RemoteConnection-     |   RC |  Session Description.              |
   |         Descriptor   |      |                                    |
   |LocalConnection-      |   LC |  Session Description.              |
   |         Descriptor   |      |                                    |
    ------------------------------------------------------------------
```

매개변수가 반드시 모든 명령에 존재하는 것은 아닙니다. 다음 표에서는 매개변수와 명령 간의 연관성을 제공합니다. 문자 M은 필수, O는 선택, F는 금지를 나타냅니다. 달리 지정하지 않는 한 매개변수는 두 번 이상 존재해서는 안 됩니다.\(MUST NOT\)

```text
    ------------------------------------------------------------------
   | Parameter name      | EP | CR | MD | DL | RQ | NT | AU | AU | RS |
   |                     | CF | CX | CX | CX | NT | FY | EP | CX | IP |
   |---------------------|----|----|----|----|----|----|----|----|----|
   | BearerInformation   |  O*|  O |  O |  O |  O |  F |  F |  F |  F |
   | CallId              |  F |  M |  M |  O |  F |  F |  F |  F |  F |
   | Capabilities        |  F |  F |  F |  F |  F |  F |  F |  F |  F |
   | ConnectionId        |  F |  F |  M |  O |  F |  F |  F |  M |  F |
   | ConnectionMode      |  F |  M |  O |  F |  F |  F |  F |  F |  F |
   | Connection-         |  F |  F |  F |  O*|  F |  F |  F |  F |  F |
   |   Parameters        |    |    |    |    |    |    |    |    |    |
   | DetectEvents        |  F |  O |  O |  O |  O |  F |  F |  F |  F |
   | DigitMap            |  F |  O |  O |  O |  O |  F |  F |  F |  F |
   | EventStates         |  F |  F |  F |  F |  F |  F |  F |  F |  F |
   | LocalConnection-    |  F |  O |  O |  F |  F |  F |  F |  F |  F |
   |            Options  |    |    |    |    |    |    |    |    |    |
   | MaxMGCPDatagram     |  F |  F |  F |  F |  F |  F |  F |  F |  F |
   | NotifiedEntity      |  F |  O |  O |  O |  O |  O |  F |  F |  F |
   | ObservedEvents      |  F |  F |  F |  F |  F |  M |  F |  F |  F |
   | PackageList         |  F |  F |  F |  F |  F |  F |  F |  F |  F |
   | QuarantineHandling  |  F |  O |  O |  O |  O |  F |  F |  F |  F |
   | ReasonCode          |  F |  F |  F |  O |  F |  F |  F |  F |  O |
   | RequestedEvents     |  F |  O |  O |  O |  O*|  F |  F |  F |  F |
   | RequestIdentifier   |  F |  O*|  O*|  O*|  M |  M |  F |  F |  F |
   | RequestedInfo       |  F |  F |  F |  F |  F |  F |  O |  M |  F |
   | ResponseAck         |  O |  O |  O |  O |  O |  O |  O |  O |  O |
   | RestartDelay        |  F |  F |  F |  F |  F |  F |  F |  F |  O |
   | RestartMethod       |  F |  F |  F |  F |  F |  F |  F |  F |  M |
   | SecondConnectionId  |  F |  F |  F |  F |  F |  F |  F |  F |  F |
   | SecondEndpointId    |  F |  O |  F |  F |  F |  F |  F |  F |  F |
   | SignalRequests      |  F |  O |  O |  O |  O*|  F |  F |  F |  F |
   | SpecificEndpointId  |  F |  F |  F |  F |  F |  F |  F |  F |  F |
   |---------------------|----|----|----|----|----|----|----|----|----|
   | RemoteConnection-   |  F |  O |  O |  F |  F |  F |  F |  F |  F |
   |          Descriptor |    |    |    |    |    |    |    |    |    |
   | LocalConnection-    |  F |  F |  F |  F |  F |  F |  F |  F |  F |
   |          Descriptor |    |    |    |    |    |    |    |    |    |
    ------------------------------------------------------------------

   Notes (*):
```

\* BearerInformation 매개변수는 섹션 2.3.2에 설명된 대로 조건부 선택 사항일 뿐입니다.

\* RequestIdentifier 매개변수는 연결 생성, 수정 및 삭제 명령에서 선택 사항이지만 명령에 캡슐화된 알림 요청이 포함된 경우 필수가 됩니다.\(MUST\)

\* RequestedEvents 및 SignalRequests 매개변수는 알림요청에서 선택사항입니다. 이러한 매개변수가 생략되면 해당 목록은 비어 있는 것으로 간주됩니다.

\* ConnectionParameters 매개변수는 게이트웨이에서 보낸 DeleteConnection 요청에서만 유효합니다.

매개변수 세트는 두 가지 방법으로 확장될 수 있습니다.

```text
   * Package Extension Parameters (preferred)

   * Vendor Extension Parameters
```

패키지 확장 매개변수는 다음과 같은 이점을 제공하는 패키지에 정의됩니다.

\* 패키지 이름에 대한 등록 메커니즘\(IANA\).

\* 매개변수에 대한 별도의 이름 공간.

\* 확장 기능을 편리하게 그룹화합니다.

\* 감사를 통해 지원 여부를 결정하는 간단한 방법입니다.

패키지 확장 메커니즘이 선호되는 확장 방법입니다.

구현자가 새로운 매개변수를 실험해야 하는 경우\(예: MGCP의 새 애플리케이션을 개발할 때\) 공급업체 확장 매개변수를 사용할 수 있습니다. 공급업체 확장 매개변수는 문자열 "X-" 또는 "X+"로 시작하는 이름으로 식별되어야 합니다. 예를 들면 다음과 같습니다.\(MUST\)

```text
      X-Flower: Daisy
```

"X+"로 시작하는 매개변수 이름은 중요한 매개변수 확장입니다. 이해할 수 없는 중요한 매개변수 확장을 수신한 MGCP 엔터티는 명령 실행을 거부해야 합니다. 오류 코드 511\(인식할 수 없는 확장명\)로 응답해야 합니다\(SHOULD\).\(MUST, SHOULD\)

"X-"로 시작하는 매개변수 이름은 중요하지 않은 매개변수 확장입니다. 이해할 수 없는 중요하지 않은 매개변수 확장을 수신하는 MGCP 엔터티는 해당 매개변수를 단순히 무시해야 합니다.\(MUST\)

공급업체 확장 매개변수는 관리되지 않는 네임스페이스를 사용하므로 이름이 충돌할 가능성이 있습니다. 따라서 공급업체는 공급업체 확장에 일부 공급업체별 문자열\(예: 공급업체 이름\)을 포함하는 것이 좋습니다.

---
#### **3.2.2.1 BearerInformation**

베어러 정보의 값은 쉼표로 구분된 속성 목록으로 인코딩되며, 속성 이름으로 표시되고 그 뒤에 콜론과 속성 값이 올 수도 있습니다.

정의된 유일한 속성은 "인코딩"\(코드 "e"\) 속성이며, 이 속성은 "A"\(A-law\) 또는 "mu"\(mu-law\) 값 중 하나를 가져야 합니다.\(MUST\)

베어러 정보 인코딩의 예는 다음과 같습니다.

```text
      B: e:mu
```

베어러 정보 속성 세트는 패키지를 통해 확장될 수 있습니다.

---
#### **3.2.2.2 CallId**

통화 식별자는 최대 32자 길이의 16진수 문자열로 인코딩됩니다. 통화 식별자는 숫자 값이 아닌 문자열로 비교됩니다.

---
#### **3.2.2.3 Capabilities**

기능은 감사 시 엔드포인트의 기능에 대해 호출 에이전트에 알립니다. 기능 인코딩은 서로 다른 매개변수 줄 코드\("A"\)가 사용되지만 두 가지 모두에 공통된 매개변수에 대한 로컬 연결 옵션 인코딩을 기반으로 합니다. 또한 기능에는 지원되는 패키지 목록과 지원되는 모드 목록도 포함될 수 있습니다.

사용되는 매개변수는 다음과 같습니다.

지원되는 코덱 목록입니다.

- 다음 매개변수는 이 목록에 지정된 모든 코덱에 적용됩니다. 침묵 억제와 같은 일부 매개변수가 일부 코덱과만 호환되도록 지정해야 하는 경우 게이트웨이는 여러 Capability 매개변수를 반환합니다. 각 코덱 세트마다 하나씩.

패킷화 기간:

- 범위를 지정할 수 있습니다.

대역폭:

- 패킷화 기간 범위에 해당하는 범위가 지정될 수 있습니다\(무음 억제가 없다고 가정\). 없는 경우 코덱 유형에서 값이 추론됩니다.

에코 제거:

- 반향 제거가 지원되면 "on"이고 그렇지 않으면 "off"입니다. 기본값은 지원입니다.

침묵 억제:

- 이 코덱에 무음 억제가 지원되면 "on"이고, 그렇지 않으면 "off"입니다. 기본값은 지원입니다.

제어권을 얻다:

- 게인 제어가 지원되지 않는 경우 "0", 다른 모든 값은 게인 제어 지원을 나타냅니다. 기본값은 지원입니다.

서비스 유형:

- 값 "0"은 서비스 유형을 지원하지 않음을 나타내고, 다른 모든 값은 서비스 유형을 지원함을 나타냅니다. 기본값은 지원입니다.

자원 예약 서비스:

- 최선의 노력 외에 지원되는 예약 서비스를 나타내는 매개변수입니다. 게이트웨이가 보장된 로드 서비스와 제어된 로드 서비스를 모두 지원하는 경우 값 "g"가 인코딩되고, 제어된 로드 서비스만 지원되는 경우 "cl" 값이 인코딩됩니다. 기본값은 "최선의 노력"입니다.

암호화 키:

- 값을 인코딩하면 암호화 지원을 나타냅니다. 기본값은 매개변수를 생략함으로써 암시되는 지원 없음입니다.

네트워크 유형:

- 키워드 "nt" 뒤에 콜론과 세미콜론으로 구분된 지원되는 네트워크 유형 목록이 옵니다. 이 매개변수는 선택사항입니다.

패키지:

- 콜론과 문자열이 뒤에 오는 키워드 "v"로 인코딩된 엔드포인트에서 지원하는 패키지입니다. 값 목록이 지정된 경우 이러한 값은 세미콜론으로 구분됩니다. 지정된 첫 번째 값은 엔드포인트의 기본 패키지가 됩니다.

모드:

- 이 끝점에서 지원되는 모드는 키워드 "m"으로 인코딩되며 그 뒤에 콜론과 이 끝점에 대해 지원되는 연결 모드의 세미콜론으로 구분된 목록이 옵니다.

기능에 대한 지원 부족은 기능 집합에서 매개변수를 제외하여 표시될 수도 있습니다.

예시 기능은 다음과 같습니다.

```text
     A: a:PCMU;G728, p:10-100, e:on, s:off, t:1, v:L,
                              m:sendonly;recvonly;sendrecv;inactive
```

위의 캐리지 리턴은 형식 지정 목적으로만 포함되었으며 실제 구현에서는 허용되지 않습니다.

여러 기능이 반환되는 경우 각 기능은 별도의 기능 줄로 반환됩니다.

로컬 연결 옵션을 확장할 수 있으므로 기능 매개변수 목록도 확장할 수 있습니다. 개별 확장은 기능으로 보고되는 방식을 정의할 수 있습니다. 해당 정의가 제공되지 않으면 다음 기본값이 적용됩니다.

\* 패키지 확장 속성: 개별 속성은 보고되지 않습니다. 대신 패키지 이름이 지원되는 패키지 목록에 보고됩니다.

\* 공급업체 확장 속성: 속성 이름은 값 없이 보고됩니다.

\* 기타 확장 속성: 속성 이름은 값 없이 보고됩니다.

---
#### **3.2.2.4 Coding of Event Names**

이벤트 이름은 실제 이벤트 이름과 슬래시\(/\)로 구분된 선택적 패키지 이름으로 구성됩니다\(섹션 2.1.7 참조\). 와일드카드 문자 별표\("\*"\)는 모든 패키지를 참조하는 데 사용할 수 있습니다. 이벤트 이름 뒤에는 선택적으로 at 기호\(@\)와 이벤트를 관찰해야 하는 연결 식별자\(와일드카드 사용 가능\)가 올 수 있습니다. 이벤트 이름은 RequestedEvents, SignalRequests, ObservedEvents, DetectEvents 및 EventStates 매개변수에 사용됩니다.

이벤트와 신호는 이벤트/신호에 대해 정의된 매개변수로 한정될 수 있습니다. 이러한 매개변수는 큰따옴표로 묶일 수 있습니다\(실제로 일부 매개변수는 구문 제한으로 인해 큰따옴표로 묶어야 함\). 이 경우 UTF-8로 인코딩됩니다\[20\].\(MUST\)

매개변수 이름 "!" \(느낌표\)는 이벤트와 신호 모두에 대해 향후 사용을 위해 예약되어 있습니다.

각 신호에는 켜기/끄기\(OO\), 타임아웃\(TO\) 또는 간략\(BR\)과 같은 신호 유형 중 하나가 있습니다. \(이러한 신호 유형은 패키지 정의에 지정되며 메시지에는 없습니다.\) 켜기/끄기 신호는 신호를 켜려면 "+"로, 신호를 끄려면 "-"로 매개변수화할 수 있습니다. 켜기/끄기 신호가 매개변수화되지 않은 경우 신호가 켜집니다. 다음 두 가지 모두 vmwi 신호\(라인 패키지 "L"에서\)를 켭니다.

```text
      L/vmwi(+)
      L/vmwi
```

"!", "+" 및 "-" 외에도 신호 매개변수 "to"도 예약되어 있습니다. 현재 요청에 대한 기본 시간 초과 값을 무시하기 위해 Time-Out 신호와 함께 사용할 수 있습니다. 밀리초 단위의 10진수 값이 제공됩니다. 개별 신호 및/또는 패키지 정의는 이 매개변수가 패키지에 있는 하나 이상의 TO 신호에 대해 지원되는지 여부를 나타내야 합니다. 표시되지 않은 경우 패키지 버전 0의 TO 신호는 이를 지원하지 않는 것으로 간주되는 반면, 패키지 버전 1 이상의 TO 신호는 이를 지원하는 것으로 가정됩니다. 기본적으로 제공된 시간 초과 값은 1000으로 나눌 수 있는 가장 가까운 0이 아닌 값, 즉 전체 초로 반올림될 수 있습니다. 개별 신호 및/또는 패키지 정의는 다른 반올림 규칙을 정의할 수 있습니다. 모든 새로운 패키지 및 TO 신호 정의는 "to" 신호 매개변수를 지원하는 것이 좋습니다.\(SHOULD, MAY\)

다음 예에서는 "to" 매개변수를 사용하여 6초 동안 신호를 적용하는 방법을 보여줍니다.

```text
      L/rg(to=6000)
      L/rg(to(6000))
```

다음은 이벤트 이름의 예입니다.

```text
      -----------------------------------------------------------
     | L/hu        |   on-hook transition, in the line package   |
     | F/0         |   digit 0 in the MF package                 |
     | hf          |   Hook-flash, assuming that the line package|
     |             |   is the default package for the endpoint.  |
     | G/rt@0A3F58 |   Ring back signal on connection "0A3F58"   |
      -----------------------------------------------------------
```

또한 RequestedEvents 및 DetectEvents 매개변수에서는 개별 이름 대신 이벤트의 범위 및 와일드카드 표기법을 사용할 수 있습니다. 이벤트 코드 "all"은 예약되어 있으며 패키지의 모든 이벤트 또는 신호를 나타냅니다. 별표\("\*"\)는 "모든 연결"을 나타내는 데 사용할 수 있으며 달러 기호\("$"\)는 "현재" 연결을 나타내는 데 사용할 수 있습니다\(자세한 내용은 섹션 2.1.7 참조\).

다음은 그러한 표기법의 예입니다.

```text
      ---------------------------------------------------------
     | M/[0-9]   |   Digits 0 to 9 in the MF package.          |
     | hf        |   Hook-flash, assuming that the line package|
     |           |   is a default package for the endpoint.    |
     | [0-9*#A-D]|   All digits and letters in the DTMF        |
     |           |   packages (default for endpoint).          |
     | T/all     |   All events in the trunk package.          |
     | R/qa@*    |   The quality alert event on all            |
     |           |   connections.                              |
     | G/rt@$    |   Ringback on current connection.           |
      ---------------------------------------------------------
```

---
#### **3.2.2.5 ConnectionId**

연결 식별자는 최대 32자 길이의 16진수 문자열로 인코딩됩니다. 연결 식별자는 숫자 값이 아닌 문자열로 비교됩니다.

---
#### **3.2.2.6 ConnectionMode**

연결 모드는 연결 작동 모드를 설명합니다. 가능한 값은 다음과 같습니다.

```text
      --------------------------------------------------------
     |    Mode     |               Meaning                    |
     |-------------|------------------------------------------|
     | M: sendonly |  The gateway should only send packets    |
     | M: recvonly |  The gateway should only receive packets |
     | M: sendrecv |  The gateway should send                 |
     |             |  and receive packets                     |
     | M: confrnce |  The gateway should place                |
     |             |  the connection in conference mode       |
     | M: inactive |  The gateway should neither              |
     |             |  send nor receive packets                |
     | M: loopback |  The gateway should place                |
     |             |  the circuit in loopback mode.           |
     | M: conttest |  The gateway should place                |
     |             |  the circuit in test mode.               |
     | M: netwloop |  The gateway should place                |
     |             |  the connection in network loopback mode.|
     | M: netwtest |  The gateway should place the connection |
     |             |  in network continuity test mode.        |
      --------------------------------------------------------
```

연결 모드에 관계없이 연결에 적용된 신호는 여전히 패킷이 전송된다는 점에 유의하십시오\(섹션 2.3.1 참조\).

연결 모드 세트는 패키지를 통해 확장될 수 있습니다.

---
#### **3.2.2.7 ConnectionParameters**

연결 매개변수는 유형 및 값 쌍의 문자열로 인코딩됩니다. 여기서 유형은 매개변수 또는 확장 유형의 두 글자 식별자이고 값은 10진수 정수입니다. 유형은 '=' 기호로 값과 구분됩니다. 매개변수는 쉼표로 서로 구분됩니다. 연결 매개변수 값은 최대 9자리를 포함할 수 있습니다. 최대값에 도달하면 카운터는 더 이상 업데이트되지 않습니다. 즉, 래핑되거나 오버플로되지 않습니다.

연결 매개변수 유형은 다음 표에 지정되어 있습니다.

```text
    -----------------------------------------------------------------
   | Connection parameter| Code |  Connection parameter              |
   | name                |      |  value                             |
   |---------------------|------|------------------------------------|
   | Packets sent        |  PS  |  The number of packets that        |
   |                     |      |  were sent on the connection.      |
   | Octets sent         |  OS  |  The number of octets that         |
   |                     |      |  were sent on the connection.      |
   | Packets received    |  PR  |  The number of packets that        |
   |                     |      |  were received on the connection.  |
   | Octets received     |  OR  |  The number of octets that         |
   |                     |      |  were received on the connection.  |
   | Packets lost        |  PL  |  The number of packets that        |
   |                     |      |  were lost on the connection       |
   |                     |      |  as deduced from gaps in the       |
   |                     |      |  RTP sequence number.              |
   | Jitter              |  JI  |  The average inter-packet arrival  |
   |                     |      |  jitter, in milliseconds,          |
   |                     |      |  expressed as an integer number.   |
   | Latency             |  LA  |  Average latency, in milliseconds, |
   |                     |      |  expressed as an integer number.   |
    -----------------------------------------------------------------
```

연결 매개변수 세트는 두 가지 방법으로 확장될 수 있습니다.

```text
   * Package Extension Parameters (preferred)

   * Vendor Extension Parameters
```

패키지 확장 연결 매개 변수는 다음과 같은 이점을 제공하는 패키지에 정의됩니다.

\* 패키지 이름에 대한 등록 메커니즘\(IANA\)입니다.

\* 매개변수에 대한 별도의 네임스페이스입니다.

\* 확장 기능을 편리하게 그룹화합니다.

\* 감사를 통해 지원 여부를 결정하는 간단한 방법입니다.

패키지 확장 메커니즘이 선호되는 확장 방법입니다.

공급업체 확장 매개변수 이름은 문자열 "X-"와 두 글자 이상의 확장 매개변수 이름으로 구성됩니다.

인식되지 않은 패키지 또는 벤더 연결 매개변수 확장을 수신하는 통화 에이전트는 이러한 매개변수를 자동으로 무시해야 합니다.\(MUST\)

연결 매개변수 인코딩의 예는 다음과 같습니다.

```text
      P: PS=1245, OS=62345, PR=0, OR=0, PL=0, JI=0, LA=48
```

---
#### **3.2.2.8 DetectEvents**

DetectEvents 매개변수는 쉼표로 구분된 이벤트 목록\(섹션 3.2.2.4 참조\)으로 인코딩됩니다. 예를 들면 다음과 같습니다.

```text
      T: L/hu,L/hd,L/hf,D/[0-9#*]
```

어떤 작업도 이벤트와 연관될 수 없지만 이벤트 매개변수가 제공될 수 있다는 점에 유의해야 합니다.

---
#### **3.2.2.9 EventStates**

EventStates 매개변수는 쉼표로 구분된 이벤트 목록\(섹션 3.2.2.4 참조\)으로 인코딩됩니다. 예를 들면 다음과 같습니다.

```text
      ES: L/hu
```

어떤 작업도 이벤트와 연관될 수 없지만 이벤트 매개변수가 제공될 수 있다는 점에 유의해야 합니다.

---
#### **3.2.2.10 LocalConnectionOptions**

로컬 연결 옵션은 통화 에이전트가 연결 처리 명령에서 게이트웨이에 제공하는 작동 매개변수를 설명합니다. 여기에는 다음이 포함됩니다.

\* 허용되는 코덱은 키워드 "a"로 인코딩되고 그 뒤에 콜론과 문자열이 옵니다. 통화 상담원이 값 목록을 지정하는 경우 이러한 값은 세미콜론으로 구분됩니다. RTP의 경우 오디오 코덱은 RTP AV 프로필\[4\]에 정의된 인코딩 이름이나 그 대체 이름을 사용하거나 IANA에 등록된 인코딩 이름을 사용하여 지정해야 합니다. MIME 유형으로 등록된 비오디오 미디어는 "image/t38"과 같이 "<MIME 유형\>/<MIME 하위 유형\>" 형식을 사용해야 합니다.\(MUST, MUST\)

\* 패킷화 기간\(밀리초\)은 키워드 "p"로 인코딩되고 그 뒤에 콜론과 십진수가 옵니다. 통화 에이전트가 값 범위를 지정하는 경우 범위는 하이픈으로 구분된 두 개의 십진수로 지정됩니다\(SDP의 "ptime" 매개변수에 지정된 대로\).

\* 대역폭은 초당 킬로비트\(초당 1000비트\)로, 키워드 "b"로 인코딩되고 그 뒤에 콜론과 십진수가 옵니다. 통화 상담원이 값 범위를 지정하는 경우 범위는 하이픈으로 구분된 두 개의 십진수로 지정됩니다.

\* 서비스 매개변수 유형은 키워드 "t"로 인코딩되고 그 뒤에 콜론과 두 개의 16진수 숫자로 인코딩된 값이 옵니다. 연결이 IP 네트워크를 통해 전송되는 경우 매개변수는 IP 헤더\(DiffServ 필드라고도 함\)의 8비트 유형의 서비스 값 매개변수를 인코딩합니다. 매개변수의 가장 왼쪽 "비트"는 IP 헤더의 최하위 비트에 해당합니다.

\* 에코 제거 매개변수는 키워드 "e"로 인코딩되고 그 뒤에 콜론과 "on" 또는 "off" 값이 옵니다.

\* 게인 제어 매개변수는 키워드 "gc"로 인코딩되고 그 뒤에 콜론과 게인 데시벨 수를 나타내는 십진수\(양수 또는 음수\) 또는 키워드 "auto"일 수 있는 값이 옵니다.

\* 묵음 억제 매개변수는 키워드 "s"로 인코딩되고 그 뒤에 콜론과 "on" 또는 "off" 값이 옵니다.

\* 리소스 예약 매개변수는 키워드 "r"로 인코딩되고 그 뒤에 콜론과 값 "g"\(서비스 보장\), "cl"\(제어된 로드\) 또는 "be"\(최선의 노력\)가 옵니다.

\* SDP\(RFC 2327\)의 매개변수 "K"에 대해 정의된 대로 키워드 "k" 뒤에 콜론과 키 사양이 오는 방식으로 인코딩된 암호화 키입니다.

\* 네트워크 유형은 키워드 "nt" 다음에 콜론으로 인코딩되고 키워드 "IN"\(인터넷\), "ATM", "LOCAL"\(로컬 연결의 경우\) 또는 기타 키워드로 인코딩된 네트워크 유형입니다. SDP\(RFC 2327\)에 따라 IANA에 등록된 네트워크 유형입니다.

\* 리소스 예약 매개변수는 키워드 "r"로 인코딩되고 그 뒤에 콜론과 값 "g"\(서비스 보장\), "cl"\(제어된 로드\) 또는 "be"\(최선의 노력\)가 옵니다.

처음 세 가지 속성의 인코딩은 SDP 및 RTP 프로필과 호환됩니다. 각 속성은 선택 사항입니다. 여러 속성이 있는 경우 쉼표로 구분됩니다.

로컬 연결 옵션의 예는 다음과 같습니다.

```text
      L: p:10, a:PCMU
      L: p:10, a:G726-32
      L: p:10-20, b:64
      L: b:32-64, e:off
```

로컬 연결 옵션 속성 세트는 세 가지 방법으로 확장될 수 있습니다.

```text
   * Package Extension attributes (preferred)

   * Vendor Extension attributes

   * Other Extension attributes
```

패키지 확장 로컬 연결 옵션 속성은 다음과 같은 이점을 제공하는 패키지에 정의됩니다.

\* 패키지 이름에 대한 등록 메커니즘\(IANA\)입니다.

\* 속성에 대한 별도의 이름 공간입니다.

\* 확장 기능을 편리하게 그룹화합니다.

\* 감사를 통해 지원 여부를 결정하는 간단한 방법입니다.

패키지 확장 메커니즘이 선호되는 확장 방법입니다.

공급업체 확장 속성은 속성 이름으로 구성되며 그 뒤에 콜론과 속성 값이 올 수도 있습니다. 속성 이름은 필수 확장의 경우 "x+" 두 문자로 시작해야 하며, 비필수 확장의 경우 "x-"로 시작해야 합니다. 게이트웨이가 인식하지 못하는 필수 확장 속성을 수신하는 경우 명령을 거부해야 합니다\(오류 코드 525 - LocalConnectionOptions의 알 수 없는 확장은 권장됨\).\(MUST, MUST\)

공급업체 확장 특성은 관리되지 않는 네임스페이스를 사용하므로 이름이 충돌할 가능성이 있습니다. 따라서 공급업체는 공급업체 확장에 일부 공급업체별 문자열\(예: 공급업체 이름\)을 포함하는 것이 좋습니다.

마지막으로, 일부 기존 구현과의 하위 호환성을 위해 MGCP는 다른 확장 속성도 허용합니다\(부록 A의 문법 참조\). 그러나 이러한 특성 확장은 패키지 확장 특성 이점을 제공하지 않습니다. 새로운 확장에 이 메커니즘을 사용하는 것은 권장되지 않습니다.

---
#### **3.2.2.11 MaxMGCPDatagram**

MaxMGCPDatagram은 감사에만 사용할 수 있습니다. 즉, 유효한 RequestedInfo 코드이며 응답 매개변수로 제공될 수 있습니다.

응답에서 MaxMGCPDatagram 값은 최대 9자리의 10진수 문자열로 인코딩됩니다. 선행 0은 허용되지 않습니다. 다음 예에서는 이 매개변수의 사용을 보여줍니다.

```text
      MD: 8100
```

---
#### **3.2.2.12 ObservedEvents**

관찰된 이벤트 매개변수는 관찰된 이벤트 목록을 제공합니다. 이벤트 코드는NotificationRequest에 사용된 것과 동일합니다. 숫자 맵에 따라 누적된 이벤트는 단일 문자열로 그룹화될 수 있지만 이러한 방식은 권장되지 않습니다. 숫자 축적 중에 다른 이벤트가 감지된 경우 격리된 이벤트 목록으로 보고되어야 합니다. 관찰된 사건의 예는 다음과 같습니다:\(SHOULD\)

```text
      O: L/hu
      O: D/8295555T
      O: D/8,D/2,D/9,D/5,D/5,L/hf,D/5,D/5,D/T
      O: L/hf, L/hf, L/hu
```

---
#### **3.2.2.13 PackageList**

패키지 목록은 감사에만 사용할 수 있습니다. 즉, 유효한 RequestedInfo 코드이며 응답 매개변수로 제공될 수 있습니다.

응답 매개변수는 지원되는 패키지의 쉼표로 구분된 목록으로 구성됩니다. 목록에 반환된 첫 번째 패키지가 기본 패키지입니다. 목록의 각 패키지는 패키지 이름, 콜론, 지원되는 패키지의 최고 버전 번호로 구성됩니다.

패키지 목록의 예는 다음과 같습니다.

```text
     PL: L:1,G:1,D:0,FOO:2,T:1
```

이전 버전과의 호환성을 위해 이 매개변수에 대한 지원은 선택 사항입니다.\(MAY\)

---
#### **3.2.2.14 QuarantineHandling**

격리 처리 매개변수에는 쉼표로 구분된 키워드 목록이 포함되어 있습니다.

\* 키워드 "프로세스" 또는 "폐기"는 격리되고 관찰된 이벤트의 처리를 나타냅니다. "process"나 "discard"가 모두 없으면 "process"로 간주됩니다.

\* "step" 또는 "loop"라는 키워드는 알림 요청당 최대 하나의 알림이 허용되는지 또는 알림 요청당 여러 알림이 허용되는지 여부를 나타냅니다. "step"이나 "loop"가 모두 없으면 "step"으로 간주됩니다.

다음 값은 유효한 예입니다.

```text
      Q: loop
      Q: process
      Q: loop,discard
```

---
#### **3.2.2.15 ReasonCode**

이유 코드는 세 자리 숫자 값입니다. 이유 코드 뒤에는 선택적으로 공백과 설명이 옵니다. 예:

```text
      E: 900 Endpoint malfunctioning
```

이유 코드 목록은 섹션 2.5에서 확인할 수 있습니다.

이유 코드 세트는 패키지를 통해 확장될 수 있습니다.

---
#### **3.2.2.16 RequestedEvents**

RequestedEvents 매개변수는 요청된 이벤트 목록을 제공합니다. 이벤트 코드는 섹션 3.2.2.4에 설명되어 있습니다.

각 이벤트는 요청된 작업 또는 작업 목록에 따라 한정될 수 있습니다. 지정된 작업은 괄호로 묶이고 쉼표로 구분된 키워드 목록으로 인코딩됩니다. 다양한 작업에 대한 코드는 다음과 같습니다.

```text
                -------------------------------------
               |          Action              | Code |
               |------------------------------|------|
               | Notify immediately           |  N   |
               | Accumulate                   |  A   |
               | Treat according to digit map |  D   |
               | Swap                         |  S   |
               | Ignore                       |  I   |
               | Keep Signal(s) active        |  K   |
               | Embedded Notification Request|  E   |
                -------------------------------------
```

작업이 지정되지 않은 경우 기본 작업은 이벤트를 알리는 것입니다. 이는 예를 들어 ft와 ft\(N\)이 동일하다는 것을 의미합니다. 나열되지 않은 이벤트는 무시됩니다\(지속되지 않는 한\).

숫자 매핑 작업은 숫자, 문자 및 타이머\(확장 숫자 맵 문자 포함\)의 인코딩을 정의하는 패키지의 숫자, 문자 및 숫자 간 타이머에 대해서만 지정되어야 합니다.\(SHOULD\)

요청된 이벤트 목록은 이벤트/작업 그룹이 쉼표로 구분되어 한 줄에 인코딩됩니다. RequestedEvents 인코딩의 예는 다음과 같습니다.

```text
      R: L/hu(N), L/hf(S,N)
      R: L/hu(N), D/[0-9#T](D)
```

"포함된 알림 요청" 작업의 경우 포함된 알림 요청 매개변수는 쉼표로 구분된 최대 3개의 매개변수 그룹 목록으로 인코딩됩니다. 각 그룹은 한 글자의 식별자로 시작하고 그 뒤에 괄호로 묶인 매개변수 목록이 옵니다. 문자 "R"로 식별되는 첫 번째 선택적 매개변수 그룹은 포함된 RequestedEvents 매개변수의 값입니다. 문자 "S"로 식별되는 두 번째 선택적 그룹은 SignalRequests 매개변수의 포함된 값입니다. 세 번째

문자 "D"로 식별되는 선택적 그룹은 DigitMap의 포함된 값입니다. \(일부 기존 구현 및 프로필은 이러한 세 가지 구성 요소를 다른 순서로 인코딩할 수 있습니다. 구현자는 이러한 인코딩을 허용하는 것이 좋지만 생성해서는 안 됩니다.\)\(SHOULD NOT\)

RequestedEvents 매개변수가 없으면 매개변수는 널값으로 설정됩니다. SignalRequests 매개변수가 없으면 매개변수는 null 값으로 설정됩니다. DigitMap이 없으면 현재 값을 사용해야 합니다. 다음은 포함된 요청의 유효한 예입니다.\(MUST\)

```text
      R: L/hd(E(R(D/[0-9#T](D),L/hu(N)),S(L/dl),D([0-9].[#T])))
      R: L/hd(E(R(D/[0-9#T](D),L/hu(N)),S(L/dl)))
```

일부 이벤트는 추가 이벤트 매개변수로 한정될 수 있습니다. 이러한 이벤트 매개변수는 쉼표로 구분되고 괄호 안에 표시됩니다. 이벤트 매개변수는 큰따옴표로 묶일 수 있습니다\(실제로 일부 이벤트 매개변수는 구문 제한으로 인해 큰따옴표로 묶어야 합니다\). 이 경우 따옴표 붙은 문자열 자체는 UTF-8로 인코딩됩니다. 이벤트 매개변수에 대한 자세한 내용은 섹션 3.2.2.4를 참조하세요.\(MUST\)

다음 예에서는 이벤트 매개변수 "epar"가 있는 foobar 이벤트를 보여줍니다.

```text
      R: X/foobar(N)(epar=2)
```

기본 알림 작업임에도 불구하고 작업이 포함되었습니다. 이는 문법에 따라 필요합니다.

---
#### **3.2.2.17 RequestedInfo**

RequestedInfo 매개변수에는 섹션 3.2.2에 정의된 대로 쉼표로 구분된 매개변수 코드 목록이 포함되어 있습니다. 예를 들어 NotifiedEntity, RequestIdentifier, RequestedEvents, SignalRequests, DigitMap, QuarantineHandling 및 DetectEvents 매개변수의 값을 감사하려는 경우 RequestedInfo 매개변수의 값은 다음과 같습니다.

```text
      F: N,X,R,S,D,Q,T
```

일반적으로 확장 매개변수도 감사될 수 있습니다. 개별 확장은 감사 작업을 정의합니다.

AuditEndPoint 명령의 기능 요청은 다음과 같이 매개변수 코드 "A"로 인코딩됩니다.

```text
      F: A
```

---
#### **3.2.2.18 RequestIdentifier**

요청 식별자는 알림 명령을 이를 트리거한 알림 요청과 연관시킵니다. RequestIdentifier는 최대 32자 길이의 16진수 문자열입니다. RequestIdentifier는 숫자 값이 아닌 문자열로 비교됩니다. 문자열 "0"은 다시 시작한 후 알림 요청이 아직 수신되지 않은 경우 지속적인 이벤트를 보고하기 위해 예약되어 있습니다.

---
#### **3.2.2.19 ResponseAck**

응답 확인 매개변수는 섹션 3.5에 설명된 "최대 1회" 기능을 관리하는 데 사용됩니다. 여기에는 "확인된 거래 ID 범위"의 쉼표로 구분된 목록이 포함되어 있습니다.

각 "확인된 거래 ID 범위"는 범위에 정확히 하나의 거래가 포함된 경우 하나의 십진수 또는 단일 하이픈으로 구분된 두 개의 십진수로 구성되어 범위에 포함된 하위 및 상위 거래 식별자를 설명합니다.

응답 확인의 예는 다음과 같습니다.

```text
      K: 6234-6255, 6257, 19030-19044
```

---
#### **3.2.2.20 RestartMethod**

RestartMethod 매개변수는 예를 들어 "graceful", "forced", "restart", "disconnected" 또는 "cancel-graceful" 키워드 중 하나로 인코딩됩니다.

```text
      RM: restart
```

재시작 방법 세트는 패키지를 통해 확장될 수 있습니다.

---
#### **3.2.2.21 SignalRequests**

SignalRequests 매개변수는 요청된 신호의 이름을 제공합니다. 각 신호는 섹션 3.2.2.4에 설명된 대로 이름으로 식별됩니다.

예를 들어 안내 방송이나 ADSI 디스플레이와 같은 일부 신호는 다음과 같은 추가 매개변수로 한정될 수 있습니다.

\* 공지사항의 이름과 매개변수,

\* 표시되어야 하는 문자열입니다.

이러한 매개변수는 다음과 같이 쉼표로 구분되고 괄호 안에 표시됩니다.

```text
      S: L/adsi("123456 Francois Gerard")
      S: A/ann(http://ann.example.net/no-such-number.au, 1234567)
```

인용 문자열이 제공되면 문자열 자체는 UTF-8로 인코딩됩니다\[20\].

여러 신호가 요청되면 해당 코드는 다음과 같이 쉼표로 구분됩니다.

```text
      S: L/adsi("123456 Your friend"), L/rg
```

신호 매개변수에 대한 자세한 내용은 섹션 3.2.2.4를 참조하십시오.

---
## **3.3 Format of response headers**

응답 헤더는 응답 라인으로 구성되며 선택적으로 응답 매개변수를 인코딩하는 헤더가 뒤따릅니다.

응답 헤더의 예는 다음과 같습니다.

```text
      200 1203 OK
```

응답 줄은 세 자리 숫자 값인 응답 코드로 시작됩니다. 코드 뒤에는 공백과 거래 식별자가 옵니다. 패키지\(8xx\)에 정의된 응답 코드 뒤에는 공백, 슬래시\("/"\) 및 패키지 이름이 옵니다. 또한 모든 응답 코드 뒤에는 공백 뒤에 선택적 설명이 올 수 있습니다.

다음 표에서는 응답을 트리거한 명령의 기능에 따라 응답 헤더에 필수 또는 선택 사항으로 존재하는 매개 변수를 설명합니다. 문자 M은 필수, O는 선택, F는 금지를 나타냅니다. 달리 지정하지 않는 한 매개변수는 두 번 이상 존재해서는 안 됩니다. 표에는 다른 동작을 정의하지 않은 응답에 대한 기본값만 반영됩니다. 이해되지 않거나 금지된 것으로 표시된 매개변수가 포함된 응답이 수신되면 문제가 되는 매개변수를 무시해야 합니다.\(MUST NOT, MUST\)

```text
    ------------------------------------------------------------------
   | Parameter name      | EP | CR | MD | DL | RQ | NT | AU | AU | RS |
   |                     | CF | CX | CX | CX | NT | FY | EP | CX | IP |
   |---------------------|----|----|----|----|----|----|----|----|----|
   | BearerInformation   |  F |  F |  F |  F |  F |  F |  O |  F |  F |
   | CallId              |  F |  F |  F |  F |  F |  F |  F |  O |  F |
   | Capabilities        |  F |  F |  F |  F |  F |  F |  O*|  F |  F |
   | ConnectionId        |  F |  O*|  F |  F |  F |  F |  O*|  F |  F |
   | ConnectionMode      |  F |  F |  F |  F |  F |  F |  F |  O |  F |
   | Connection-         |  F |  F |  F |  O*|  F |  F |  F |  O |  F |
   |   Parameters        |    |    |    |    |    |    |    |    |    |
   | DetectEvents        |  F |  F |  F |  F |  F |  F |  O |  F |  F |
   | DigitMap            |  F |  F |  F |  F |  F |  F |  O |  F |  F |
   | EventStates         |  F |  F |  F |  F |  F |  F |  O |  F |  F |
   | LocalConnection-    |  F |  F |  F |  F |  F |  F |  F |  O |  F |
   |            Options  |    |    |    |    |    |    |    |    |    |
   | MaxMGCPDatagram     |  F |  F |  F |  F |  F |  F |  O |  F |  F |
   | NotifiedEntity      |  F |  F |  F |  F |  F |  F |  O |  O |  O |
   | ObservedEvents      |  F |  F |  F |  F |  F |  F |  O |  F |  F |
   | QuarantineHandling  |  F |  F |  F |  F |  F |  F |  O |  F |  F |
   | PackageList         |  O*|  O*|  O*|  O*|  O*|  O*|  O |  O*|  O*|
   | ReasonCode          |  F |  F |  F |  F |  F |  F |  O |  F |  F |
   | RequestIdentifier   |  F |  F |  F |  F |  F |  F |  O |  F |  F |
   | ResponseAck         |  O*|  O*|  O*|  O*|  O*|  O*|  O*|  O*|  O*|
   | RestartDelay        |  F |  F |  F |  F |  F |  F |  O |  F |  F |
   | RestartMethod       |  F |  F |  F |  F |  F |  F |  O |  F |  F |
   | RequestedEvents     |  F |  F |  F |  F |  F |  F |  O |  F |  F |
   | RequestedInfo       |  F |  F |  F |  F |  F |  F |  F |  F |  F |
   | SecondConnectionId  |  F |  O |  F |  F |  F |  F |  F |  F |  F |
   | SecondEndpointId    |  F |  O |  F |  F |  F |  F |  F |  F |  F |
   | SignalRequests      |  F |  F |  F |  F |  F |  F |  O |  F |  F |
   | SpecificEndpointId  |  F |  O |  F |  F |  F |  F |  O*|  F |  F |
   |---------------------|----|----|----|----|----|----|----|----|----|
   | LocalConnection-    |  F |  O*|  O |  F |  F |  F |  F |  O*|  F |
   |         Descriptor  |    |    |    |    |    |    |    |    |    |
   | RemoteConnection-   |  F |  F |  F |  F |  F |  F |  F |  O*|  F |
   |         Descriptor  |    |    |    |    |    |    |    |    |    |
    ------------------------------------------------------------------

   Notes (*):
```

\* PackageList 매개변수는 반환 코드 518\(지원되지 않는 패키지\)에만 허용됩니다. 단, 감사되는 경우에도 반환될 수 있는 AuditEndpoint는 제외됩니다.

\* ResponseAck 매개변수는 문제의 트랜잭션에 대한 임시 응답 이후에 발행된 최종 응답 이외의 다른 응답과 함께 사용되어서는 안 됩니다. 이 경우 ResponseAck 매개변수가 있으면 응답 승인을 트리거해야 합니다. 제공된 모든 ResponseAck 값은 무시됩니다.\(MUST NOT, SHOULD\)

\* CreateConnection 메시지의 경우 응답 줄 뒤에 Connection-Id 매개변수와 LocalConnectionDescriptor가 옵니다. 생성 요청이 와일드카드 Endpoint-Id로 전송된 경우에는 특정-Endpoint-Id 매개변수가 뒤에 올 수도 있습니다. Connection-Id 및 LocalConnectionDescriptor 매개변수는 표에서 선택사항으로 표시됩니다. 실제로 연결이 생성된 경우 모든 긍정적인 응답에는 필수이며, 응답이 부정적이고 연결이 생성되지 않은 경우에는 금지됩니다.

\* LocalConnectionDescriptor는 CreateConnection에 대한 긍정적인 응답\(코드 200\)과 함께 전송되어야 합니다. 또한 수정으로 인해 세션 매개변수가 수정된 경우 ModifyConnection 명령에 대한 응답으로 전송되어야 합니다. LocalConnectionDescriptor는 섹션 3.4에 정의된 대로 "세션 설명"으로 인코딩됩니다. 응답 헤더와 빈 줄로 구분됩니다.\(MUST, MUST\)

\* 연결 매개변수는 통화 에이전트가 전송한 와일드카드가 아닌 DeleteConnection 명령에 대한 응답에서만 유효합니다.

\* AuditEndpoint 명령에 대한 응답에 여러 ConnectionId, 특정EndpointId 및 기능 매개변수가 있을 수 있습니다.

\* 여러 세션 설명자가 동일한 응답으로 인코딩되는 경우 빈 줄로 구분하여 하나씩 인코딩됩니다. 예를 들어 감사 연결 요청에 대한 응답이 다음과 같이 로컬 세션 설명과 원격 세션 설명을 모두 전달하는 경우입니다.

```text
          200 1203 OK
          C: A3C47F21456789F0
          N: [128.96.41.12]
          L: p:10, a:PCMU;G726-32
          M: sendrecv
          P: PS=1245, OS=62345, PR=780, OR=45123, PL=10, JI=27,LA=48

          v=0
          o=- 25678 753849 IN IP4 128.96.41.1
          s=-
          c=IN IP4 128.96.41.1
          t=0 0
          m=audio 1296 RTP/AVP 0

          v=0
          o=- 33343 346463 IN IP4 128.96.63.25
          s=-
          c=IN IP4 128.96.63.25
          t=0 0
          m=audio 1296 RTP/AVP 0 96
          a=rtpmap:96 G726-32/8000
```

이 예에서 SDP 구문에 따라 각 설명은 "버전" 줄\(v=...\)로 시작됩니다. 로컬 설명은 항상 원격 설명보다 먼저 전송됩니다. 연결 설명자가 요청되었지만 감사된 연결에 대해 존재하지 않는 경우 해당 연결 설명자는 SDP 프로토콜 버전 필드에만 나타납니다.

다음은 각 명령에 대한 응답 매개변수를 설명합니다.

---
### **3.3.1 CreateConnection Response**

CreateConnection 메시지의 경우 응답 줄 뒤에는 성공적인 응답\(코드 200\)이 포함된 Connection-Id 매개 변수가 옵니다. 또한 LocalConnectionDescriptor는 긍정적인 응답과 함께 전송됩니다. LocalConnectionDescriptor는 SDP\(RFC 2327\)에 정의된 대로 "세션 설명"으로 인코딩됩니다. 응답 헤더와 빈 줄로 구분됩니다. 예:

```text
      200 1204 OK
      I: FDE234C8
```

v=0

- o=- 25678 753849 IN IP4 128.96.41.1 s=- c=IN IP4 128.96.41.1 t=0 0 m=오디오 3456 RTP/AVP 96 a=rtpmap:96 G726-32/8000

임시 응답이 이전에 발행된 경우 최종 응답에는 응답 승인 매개변수도 포함되어야 합니다\(이 사양을 준수하는 엔터티가 발행한 최종 응답에는 매개변수가 포함되지만 이전 RFC 2705 구현은 포함되지 않을 수 있습니다\).\(SHOULD\)

```text
      200 1204 OK
      K:
      I: FDE234C8
```

v=0

- o=- 25678 753849 IN IP4 128.96.41.1 s=- c=IN IP4 128.96.41.1 t=0 0 m=오디오 3456 RTP/AVP 96 a=rtpmap:96 G726-32/8000

그런 다음 최종 응답은 응답 확인을 통해 확인되어야 합니다.\(SHOULD\)

```text
      000 1204
```

---
### **3.3.2 ModifyConnection Response**

성공적인 ModifyConnection 메시지의 경우, 수정으로 인해 세션 매개변수가 수정된 경우\(예: 연결 모드만 변경해도 세션 매개변수가 변경되지 않음\) 응답 줄 뒤에 LocalConnectionDescriptor가 옵니다. LocalConnectionDescriptor는 SDP에서 정의한 대로 "세션 설명"으로 인코딩됩니다. 응답 헤더와 빈 줄로 구분됩니다.

```text
      200 1207 OK
```

v=0

- o=- 25678 753849 IN IP4 128.96.41.1 s=- c=IN IP4 128.96.41.1 t=0 0 m=오디오 3456 RTP/AVP 0

임시 응답이 이전에 발행된 경우 최종 응답에는 다음과 같이 응답 승인 매개변수가 추가로 포함되어야 합니다.\(SHOULD\)

```text
      200 1207 OK
      K:
```

그런 다음 최종 응답은 응답 확인을 통해 확인되어야 합니다.\(SHOULD\)

```text
      000 1207 OK
```

---
### **3.3.3 DeleteConnection Response**

DeleteConnection 메시지의 변형에 따라 섹션 3.2.2.7에 정의된 대로 응답 줄 뒤에 연결 매개변수 매개변수 줄이 올 수 있습니다.

```text
      250 1210 OK
      P: PS=1245, OS=62345, PR=780, OR=45123, PL=10, JI=27, LA=48
```

---
### **3.3.4 NotificationRequest Response**

성공적인 알림 요청 응답에는 추가 응답 매개변수가 포함되지 않습니다.

---
### **3.3.5 Notify Response**

성공적인 알림 응답에는 추가 응답 매개변수가 포함되지 않습니다.

---
### **3.3.6 AuditEndpoint Response**

AuditEndPoint가 성공한 경우 응답 줄 뒤에는 요청된 각 매개변수에 대한 정보가 올 수 있습니다. 각 매개변수는 별도의 줄에 표시됩니다. 매개변수

현재 존재하는 값\(예: 숫자 지도\)은 계속 제공되지만 값은 비어 있습니다. 와일드카드 문자로 "확장"된 각 로컬 엔드포인트 이름은 "SpecificEndPointId" 매개변수 코드를 사용하여 별도의 줄에 표시됩니다. 예:

```text
      200 1200 OK
      Z: aaln/1@rgw.whatever.net
      Z: aaln/2@rgw.whatever.net
```

연결 식별자가 감사되고 끝점에 여러 연결이 있는 경우 쉼표로 구분된 연결 식별자 목록이 다음과 같이 반환되어야 합니다.\(SHOULD\)

```text
      200 1200 OK
      I: FDE234C8, DFE233D1
```

또는 여러 연결 ID 매개변수 행이 반환될 수 있습니다. 두 형식을 혼합해도 오류가 발생하지는 않지만 혼합해서는 안 됩니다.

기능이 감사되면 응답에는 다음과 같이 여러 기능 매개변수 행이 포함될 수 있습니다.

```text
      200 1200 OK
      A: a:PCMU;G728, p:10-100, e:on, s:off, t:1, v:L,
          m:sendonly;recvonly;sendrecv;inactive
      A: a:G729, p:30-90, e:on, s:on, t:1, v:L,
          m:sendonly;recvonly;sendrecv;inactive;confrnce
```

참고: 위에 표시된 기능에 대한 캐리지 리턴은 형식 지정 목적으로만 제공됩니다. 실제 명령 인코딩에서는 허용되지 않습니다.

---
### **3.3.7 AuditConnection Response**

AuditConnection이 성공한 경우 요청된 각 매개변수에 대한 정보가 응답 뒤에 올 수 있습니다. 현재 값이 없는 매개변수는 계속 제공됩니다. 연결 설명자는 항상 마지막에 나타나며 각 설명 앞에는 빈 줄이 옵니다. 예를 들면 다음과 같습니다.

```text
      200 1203 OK
      C: A3C47F21456789F0
      N: [128.96.41.12]
      L: p:10, a:PCMU;G728
      M: sendrecv
      P: PS=622, OS=31172, PR=390, OR=22561, PL=5, JI=29, LA=50
```

v=0

- o=- 4723891 7428910 IN IP4 128.96.63.25 s=- c=IN IP4 128.96.63.25 t=0 0 m=오디오 1296 RTP/AVP 96 a=rtpmap:96 G726-32/8000

로컬 및 원격 연결 설명자가 모두 제공되는 경우 로컬 연결 설명자는 둘 중 첫 번째가 됩니다. 연결 설명자가 요청되었지만 감사된 연결에 대해 존재하지 않는 경우 해당 연결 설명자는 다음과 같이 SDP 프로토콜 버전 필드만\("v=0"\)과 함께 표시됩니다.

```text
      200 1203 OK

      v=0
```

---
### **3.3.8 RestartInProgress Response**

성공적인 RestartInProgress 응답에는 NotifiedEntity 매개변수가 포함될 수 있지만, 그 외에는 추가 응답 매개변수가 포함되지 않습니다.

또한 RestartInProgress에 대한 521 응답에는 다음과 같이 첫 번째 통화 에이전트가 엔드포인트를 다른 통화 에이전트로 리디렉션할 때 연결할 다른 통화 에이전트의 이름과 함께 NotifiedEntity 매개 변수가 포함되어야 합니다.\(MUST\)

```text
      521 1204 Redirect
      N: CA-1@whatever.net
```

---
## **3.4 Encoding of the Session Description (SDP)**

세션 설명\(SDP\)은 세션 설명 프로토콜인 SDP에 따라 인코딩됩니다. MGCP 구현은 모든 준수 SDP 메시지를 완전히 구문 분석할 수 있어야 하며 SDP 표준을 엄격하게 준수하는 세션 설명을 보내야 합니다\(MUST\).\(MUST\)

SDP 매개변수에 대한 일반적인 설명 및 설명은 RFC 2327\(또는 후속 버전\)에서 찾을 수 있습니다. 특히, 다음 사항에 유의해야 합니다.

```text
   * Origin ("o="),

   * Session Name ("s="), and

   * Time active ("t=")
```

RFC 2327에서는 모두 필수입니다. MGCP에서는 거의 사용되지 않지만 그럼에도 불구하고 RFC 2327을 준수하여 제공되어야 합니다. 다음은 각 필드에 사용할 값을 제안합니다. 그러나 자세한 내용은 RFC 2327\(또는 후속 버전\)을 참조하는 것이 좋습니다.\(MUST\)

```text
   Origin
   o = <username> <session id> <version> <network type> <address type>
       <address>
```

\* 사용자 이름은 하이픈\("-"\)으로 설정되어야 합니다.\(SHOULD\)

\* 세션 ID는 RFC 2327에서 제안된 대로 NTP 타임스탬프를 사용하는 것이 좋습니다.\(SHOULD\)

\* 버전은 SDP가 변경될 때마다 증가해야 하는 버전 번호입니다. RFC 2327에서 제안된 대로 0 또는 NTP 타임스탬프로 초기화된 카운터를 권장합니다.\(MUST, SHOULD\)

\* 네트워크 유형은 네트워크 유형을 정의합니다. RTP 세션의 경우 네트워크 유형은 "IN"이어야 합니다.\(SHOULD\)

\* 주소 유형은 주소 유형을 정의합니다. RTP 세션의 경우 주소 유형은 "IP4"\(또는 "IP6"\)여야 합니다.\(SHOULD\)

\* 주소는 연결 정보\("c="\) 필드에 제공된 주소와 동일해야 합니다.\(SHOULD\)

```text
   Session Name
   s = <session name>
```

세션 이름은 하이픈\("-"\)이어야 합니다.

```text
   Time active
   t = <start time> <stop time>
```

\* 시작 시간은 0으로 설정될 수 있습니다.

\* 정지 시간은 0으로 설정되어야 합니다.

세 필드 각각은 수신 시 무시될 수 있습니다.

MGCP의 확장성 원칙을 더욱 수용하기 위해 구현에서는 PINT "a=require" 속성을 지원하도록 권장됩니다. 자세한 내용은 RFC 2848을 참조하세요.

SDP의 사용은 실제로 설정되는 세션 유형에 따라 다릅니다. 아래에서는 RTP/AVP 프로필\[4\] 또는 이 문서에 정의된 LOCAL 상호 연결을 사용하여 오디오 서비스에 SDP를 사용하는 방법을 설명합니다. 아래 설명된 내용과 SDP\(RFC 2327 또는 후속 버전\)가 충돌하는 경우 SDP 사양이 우선적으로 적용됩니다.

---
### **3.4.1 Usage of SDP for an Audio Service**

전화 통신 게이트웨이에서는 정확히 하나의 미디어인 오디오를 사용하는 세션만 설명하면 됩니다. 이를 위한 SDP의 사용법은 간단하며 RFC 2327에 자세히 설명되어 있습니다.

다음은 오디오 연결에 대한 RFC 2327 준수 세션 설명의 예입니다.

v=0

- o=- A7453949499 0 IN IP4 128.96.41.1 s=- c=IN IP4 128.96.41.1 t=0 0 m=오디오 3456 RTP/AVP 0 96 a=rtpmap:96 G726-32/8000

---
### **3.4.2 Usage of SDP for LOCAL Connections**

MGCP를 사용하여 단일 게이트웨이 내에서 내부 연결을 설정하는 경우 해당 연결의 매개변수를 인코딩하는 데 SDP 형식이 사용됩니다. 연결 및 미디어 매개변수는 다음과 같이 사용됩니다:

\* 연결 매개변수\(c=\)는 네트워크 유형으로 키워드 "LOCAL", 주소 유형으로 키워드 "EPN"\(엔드포인트 이름\), 연결로 엔드포인트의 로컬 이름을 사용하여 연결이 로컬임을 지정합니다. 주소.

\* "m=audio" 매개변수는 RTP AVP 프로필에 사용되는 것과 동일한 규칙을 사용하여 포트 번호\(항상 0으로 설정됨\), 프로토콜 유형\(항상 LOCAL 키워드로 설정됨\), 인코딩 유형을 지정합니다. \(RTP 페이로드 번호\). 인코딩 유형은 일반적으로 0\(PCMU\)으로 설정되어야 합니다.

연결을 식별하는 세션 수준 속성도 존재할 수 있습니다. 이를 통해 끝점은 여러 LOCAL 연결을 지원할 수 있습니다. 이 속성의 사용은 선택사항이며 단일 LOCAL 연결만 지원하는 엔드포인트에는 실제로 필요하지 않습니다. 속성은 다음과 같이 정의됩니다.\(MAY, MAY\)

a=MGCPlocalcx:<연결 ID\>

- MGCP 로컬 연결 속성은 연결 정보에서 식별된 엔드포인트에서 SDP가 적용되는 MGCP LOCAL 연결을 식별하는 세션 수준 전용 속성으로, 대소문자를 구분하지 않습니다. ConnectionId는 최대 32자를 포함하는 16진수 문자열입니다. ConnectionId 자체는 대소문자를 구분하지 않습니다. MGCP 로컬 연결 속성은 charset 속성의 적용을 받지 않습니다.

LOCAL 세션 설명의 예는 다음과 같습니다.

```text
      v=0
      o=- A7453949499 0 LOCAL EPN X35V3+A4/13
      s=-
      c=LOCAL EPN X35V3+A4/13
      t=0 0
      a=MGCPlocalcx:FDE234C8
      m=audio 0 LOCAL 0
```

MGCP 로컬 연결 속성은 세션 수준에서 지정되며 엔드포인트당 단일 LOCAL 연결만 지원되는 경우 생략될 수 있습니다.

---
## **3.5 Transmission over UDP**

MGCP 메시지는 UDP를 통해 전송됩니다. 명령은 지정된 엔드포인트에 대해 DNS에 정의된 IP 주소 중 하나로 전송됩니다. 응답은 명령의 소스 주소\(예: IP 주소 및 UDP 포트 번호\)로 다시 전송됩니다. 응답은 명령이 전송된 주소와 동일한 주소에서 도착할 수도 있고 도착하지 않을 수도 있습니다.

엔드포인트에 포트가 지정되지 않은 경우 기본적으로 다음 명령을 전송해야 합니다.\(MUST\)

\* 통화 에이전트에 의해 게이트웨이용 기본 MGCP 포트인 2427로 연결됩니다.

\* 게이트웨이를 통해 통화 에이전트용 기본 MGCP 포트인 2727로 연결됩니다.

---
### **3.5.1 Providing the At-Most-Once Functionality**

UDP를 통해 전달되는 MGCP 메시지는 손실될 수 있습니다. 시기적절한 응답이 없으면 명령이 재전송됩니다. 대부분의 MGCP 명령은 멱등성이 없습니다. 예를 들어 CreateConnection 명령이 여러 번 실행되면 게이트웨이 상태를 예측할 수 없게 됩니다. 따라서 전송 절차는 "최대 1회" 기능을 제공해야 합니다.\(MUST\)

MGCP 엔터티는 최근 트랜잭션에 보낸 응답 목록과 현재 실행 중인 트랜잭션 목록을 메모리에 보관해야 합니다. 들어오는 명령의 트랜잭션 식별자 숫자 값은 최근 응답의 트랜잭션 식별자와 비교됩니다. 일치하는 항목이 발견되면 MGCP 엔터티는 트랜잭션을 다시 실행하지 않고 단순히 응답을 다시 보냅니다. 나머지 명령은 현재 트랜잭션 목록, 즉 이전에 수신되어 아직 실행이 완료되지 않은 트랜잭션 목록과 비교됩니다. 일치하는 항목이 발견되면 MGCP 엔터티는 트랜잭션을 다시 실행하지 않지만 명령 수신을 확인하기 위해 임시 응답\(섹션 3.5.5\)을 발행해야 합니다.\(SHOULD\)

이 절차는 다음에 T-HIST로 언급된 긴 타이머 값을 사용합니다. 타이머는 트랜잭션의 최대 지속 시간보다 크게 설정되어야 하며, 이는 최대 반복 횟수, 반복 타이머의 최대값 및 네트워크 내 패킷의 최대 전파 지연을 고려해야 합니다. 권장 값은 30초입니다.\(MUST\)

응답 사본은 응답이 발행된 후 T-HIST 초 후에 또는 게이트웨이\(또는 호출 에이전트\)가 "응답 승인"을 통해 응답이 수신되었다는 확인을 수신할 때 파기될 수 있습니다. 이 속성을 통해 승인된 트랜잭션의 경우 게이트웨이는 응답이 발행된 후 T-HIST 초 동안 트랜잭션 ID의 복사본\(전체 트랜잭션 응답과 반대\)을 유지해야 합니다. 네트워크에서 생성될 수 있는 거래 요청입니다.\(MAY, MUST\)

---
### **3.5.2 Transaction Identifiers and Three Ways Handshake**

거래 식별자는 1\~999,999,999\(둘 다 포함\) 범위의 정수입니다. 통화 상담원은 자신이 관리하는 각 게이트웨이에 대해 특정 번호 공간을 사용하거나 임의의 그룹에 속하는 모든 게이트웨이에 대해 동일한 번호 공간을 사용하기로 결정할 수 있습니다. 통화 상담원은 여러 독립 프로세스 간에 대규모 게이트웨이 관리 부하를 공유하기로 결정할 수 있습니다. 그런 다음 이러한 프로세스는 트랜잭션 번호 공간을 공유해야 합니다. 트랜잭션 식별자를 중앙 집중식으로 할당하거나 서로 다른 프로세스에 식별자의 겹치지 않는 범위를 사전 할당하는 등 이러한 공유에는 여러 가지 가능한 구현이 있습니다. 구현은 섹션 4에 정의된 대로 논리적 호출 에이전트에서 발생하는 모든 트랜잭션에 고유한 트랜잭션 식별자가 할당되도록 보장해야 합니다. 게이트웨이는 트랜잭션 식별자만 보고 중복 트랜잭션을 간단히 감지할 수 있습니다.\(MUST, MUST\)

응답 승인 속성은 모든 명령에서 찾을 수 있습니다. 수신된 최종 응답에 대해 "확인된 트랜잭션 ID 범위" 세트를 전달합니다. 임시 응답은 확인되어서는 안 됩니다. 주어진 응답은 두 개의 별도 메시지로 확인되어서는 안 됩니다.\(MUST NOT, SHOULD NOT\)

MGCP 엔터티는 응답 확인 메시지\(명령 또는 응답\)에서 수신된 "확인된 트랜잭션 ID 범위"에 ID가 포함된 트랜잭션에 대한 응답 복사본\(transaction-id는 제외\)을 삭제하도록 선택할 수 있습니다. 그런 다음 트랜잭션 ID가 이 범위 내에 속하고 응답이 T-HIST 초 이내에 발행되면 해당 엔터티의 추가 명령을 자동으로 폐기해야 합니다.\(MAY, SHOULD\)

엔터티는 응답을 승인할 때 적절한 주의를 기울여야 합니다. 특히 응답 확인은 해당 명령\(즉, 응답이 확인되는 명령\)과 동일한 엔터티로 전송된 경우에만 확인되어야 합니다.\(MUST, SHOULD\)

마찬가지로, 엔터티는 주어진 응답에 대한 응답 확인을 맹목적으로 수락해서는 안 됩니다. 그러나 해당 응답을 생성한 명령과 동일한 엔터티에 의해 해당 응답 확인이 전송된 경우 해당 응답에 대한 응답 확인을 수락하는 것이 안전한 것으로 간주됩니다.\(SHOULD NOT\)

명령에서 응답 승인을 사용하는 것은\(임시 응답에 따른 응답 승인 응답과 반대\) 선택사항이라는 점에 유의해야 합니다. 이를 사용하면 전체 메모리 소비가 줄어드는 이점이 있습니다. 그러나 큰 메시지를 피하기 위해 구현에서는 큰 응답을 생성해서는 안 됩니다.\(MAY, SHOULD NOT\)

승인 목록. 한 가지 전략은 엔드포인트별로 명령에 대한 응답을 관리하는 것입니다. 엔드포인트에 대한 명령은 동일한 엔드포인트에 대한 이전 명령에 대한 응답을 확인할 수 있습니다. 와일드카드 끝점 이름이 포함된 명령에 대한 응답은 메시지 크기를 고려하여 선택적으로 확인되거나 단순히 승인되지 않을 수 있습니다\(응답에 명시적으로 응답 승인이 필요한 경우 제외\). 동일한 응답을 두 번 확인하거나 T-HIST 초가 지난 응답을 확인하지 않도록 주의해야 합니다.

"확인된 트랜잭션 ID 범위" 값은 엔터티가 다른 엔터티에 대한 마지막 응답을 발행한 이후 T-HIST 초 이상이 경과했거나 엔터티가 작업을 재개할 때 사용되어서는 안 됩니다. 이 상황에서는 transaction-id에 대한 테스트 없이 명령을 수락하고 처리해야 합니다.\(MUST NOT, MUST\)

"응답 승인 속성"을 포함하는 명령이 무질서하게 전송될 수 있습니다. 최근 메시지에서 수신된 "확인된 트랜잭션 ID 범위"의 결합은 유지되어야 합니다.\(MUST\)

---
### **3.5.3 Computing Retransmission Timers**

모든 처리되지 않은 명령에 대해 적절한 시간 초과를 제공하고 시간 초과가 초과된 경우 명령을 재시도하는 것은 요청 엔터티의 책임입니다. 또한 반복된 명령이 승인되지 않는 경우 중복 서비스를 찾거나 기존 또는 보류 중인 연결을 삭제하는 것은 요청 엔터티의 책임입니다.

사양에서는 의도적으로 재전송 타이머 값을 지정하지 않습니다. 이러한 값은 일반적으로 네트워크에 따라 다릅니다. 재전송 타이머는 일반적으로 명령 전송과 명령에 대한 첫 번째 응답 반환 사이에 소요된 시간을 측정하여 타이머를 추정해야 합니다. 최소한 지수 백오프를 포함하는 재전송 전략을 구현해야 합니다. 한 가지 가능성은 두 가지 변수를 사용하는 TCP/IP에 구현된 알고리즘을 사용하는 것입니다.\(SHOULD, MUST\)

\* 관찰된 지연의 지수 평활 평균을 통해 추정된 평균 승인 지연 AAD,

\* 관찰된 지연과 현재 평균 간의 차이의 절대값을 지수 평활 평균하여 추정한 평균 편차 ADEV.

TCP의 재전송 타이머 RTO는 평균 지연의 합과 평균 편차의 N 배로 설정됩니다. 여기서 N은 상수입니다. 그러나 MGCP에서는 T-HIST 초 후에 게이트웨이가 반복되는 패킷을 수신하지 않도록 보장하기 위해 타이머의 최대값을 제한해야 합니다. RTO\(RTO-MAX\)의 권장 최대값은 4초입니다. 구현자는 이 타이머의 최소값 제한도 고려해야 합니다\[19\].\(SHOULD, SHOULD\)

재전송 후에 MGCP 엔터티는 다음을 수행해야 합니다.\(SHOULD\)

\* 이 트랜잭션에 대한 승인 지연 예상 값인 T-DELAY를 두 배로 늘려야 합니다.

\* 0.5 T-DELAY와 T-DELAY 사이에 균일하게 분포된 임의의 값을 계산해야 합니다.

\* 재전송 타이머\(RTO\)를 다음 중 최소값으로 설정해야 합니다. - 해당 무작위 값과 평균 편차의 N배의 합, - RTO-MAX.

이 절차에는 두 가지 효과가 있습니다. 기하급수적으로 증가하는 구성 요소를 포함하기 때문에 정체가 발생할 경우 메시지 스트림이 자동으로 느려집니다. 임의의 구성 요소가 포함되어 있기 때문에 동일한 외부 이벤트에 의해 트리거된 알림 간의 잠재적인 동기화가 중단됩니다.

재전송이 포함된 트랜잭션에 대해서는 추정기 AAD 및 ADEV를 업데이트해서는 안 됩니다. 또한 성공적인 재전송 이후 첫 번째 새로운 전송은 마지막 재전송에 대해 RTO를 사용해야 합니다. 이 전송이 재전송 없이 성공하면 AAD 및 ADEV 추정기가 업데이트되고 RTO가 평소와 같이 다시 결정됩니다. 자세한 내용은 예를 들어 \[18\]을 참조하세요.\(SHOULD NOT, SHOULD\)

---
### **3.5.4 Maximum Datagram Size, Fragmentation and Reassembly**

UDP를 통해 전송되는 MGCP 메시지는 대규모 데이터그램의 조각화 및 재조립을 위해 IP를 사용합니다. IP 데이터그램의 이론적 최대 크기는 65535바이트입니다. 20바이트 IP 헤더와 8바이트 UDP 헤더를 사용하면 UDP를 사용할 때 이론적으로 최대 MGCP 메시지 크기가 65507바이트가 됩니다.

그러나 IP에서는 호스트가 576바이트보다 큰 IP 데이터그램을 수신할 것을 요구하지 않으며\[21\] 이는 수용할 수 없을 정도로 작은 MGCP 메시지 크기를 제공합니다. 결과적으로 MGCP는 구현이 최소 4000바이트까지 MGCP 데이터그램을 지원해야 한다고 요구합니다.\(MUST\)

해당 IP 조각화 및 리어셈블리가 지원됩니다. MGCP 레벨에는 4000바이트 제한이 적용됩니다. 낮은 계층 오버헤드에는 이보다 큰 IP 데이터그램에 대한 지원이 필요합니다. UDP 및 IP 오버헤드는 최소 28바이트이며, 예를 들어 IPSec를 사용하면 추가 오버헤드가 추가됩니다.

위의 내용은 통화 상담원과 엔드포인트 모두에 적용된다는 점에 유의해야 합니다. 통화 에이전트는 엔드포인트를 감사하여 위에 지정된 것보다 더 큰 MGCP 데이터그램을 지원하는지 확인할 수 있습니다. 현재 엔드포인트에는 통화 에이전트가 더 큰 MGCP 데이터그램 크기를 지원하는지 확인하는 유사한 기능이 없습니다.

---
### **3.5.5 Piggybacking**

통화 에이전트가 동일한 게이트웨이에 동시에 여러 메시지를 보내려는 경우가 있고 그 반대의 경우도 있습니다. 여러 MGCP 메시지를 동일한 데이터그램으로 전송해야 하는 경우 다음 예와 같이 단일 점이 포함된 텍스트 줄로 구분해야 합니다.\(MUST\)

```text
      200 2005 OK
      .
      DLCX 1244 card23/21@tgw-7.example.net MGCP 1.0
      C: A3C47F21456789F0
      I: FDE234C8
```

피기백된 메시지는 여러 개의 개별 데이터그램에서 한 번에 하나씩 수신된 것처럼 정확하게 처리되어야 합니다. 데이터그램의 각 메시지는 첫 번째 메시지부터 시작하여 완료될 때까지 처리되어야 하며 각 명령에 응답해야 합니다. 피기백된 메시지에서 발생한 오류는 해당 데이터그램에서 수신된 다른 메시지에 영향을 주어서는 안 됩니다. 각 메시지는 자체적으로 처리됩니다.\(MUST, MUST, MUST NOT\)

피기백을 사용하면 다음 두 가지를 달성할 수 있습니다.

\* 메시지의 순차적 전달 및 처리를 보장합니다.

\* 메시지 전달의 운명 공유.

메시지의 순차적 전달을 보장하기 위해 피기백\(piggybacking\)이 사용되는 경우, 엔터티는 개별 메시지의 재전송 시 이 순차적 전달 속성이 유지되도록 해야 합니다. 이에 대한 예는 \(섹션 4.4.1에 설명된 대로\) 피기백을 사용하여 여러 알림이 전송되는 경우입니다.\(MUST\)

메시지 전달의 운명 공유는 모든 메시지가 전달되거나 메시지 중 하나도 전달되지 않도록 보장합니다. 이러한 운명 공유를 보장하기 위해 피기백을 사용하는 경우 엔터티는 재전송 시 이 속성이 유지되도록 해야 합니다. 예를 들어, 잠금 단계 모드에서 작동하는 엔드포인트로부터 알림을 수신하면 통화 에이전트는 메시지 전달 운명을 공유하기 위해 단일 데이터그램으로 응답과 새 알림 요청 명령을 보낼 수 있습니다.\(MUST\)

---
### **3.5.6 Provisional Responses**

일부 트랜잭션을 실행하는 데 시간이 오래 걸릴 수 있습니다. 긴 실행 시간은 타이머 기반 재전송 절차와 상호 작용할 수 있습니다.

이로 인해 과도한 재전송 횟수가 발생하거나 타이머 값이 너무 길어져 효율성이 떨어질 수 있습니다.

트랜잭션에 긴 실행 시간이 필요할 것이라고 예측할 수 있는 게이트웨이\(및 통화 에이전트\)는 응답 코드 100이 포함된 임시 응답을 보내야 합니다. 지침에 따라 네트워크 리소스 예약과 같이 완료하기 위해 외부 통신이 필요한 트랜잭션은 잠정적 대응. 또한 엔터티는 아직 실행이 완료되지 않은 트랜잭션의 반복을 수신하는 경우 임시 응답을 보내야 합니다.\(SHOULD, SHOULD, SHOULD\)

실행할 트랜잭션 대기열을 구축하기 시작하는 게이트웨이\(또는 호출 에이전트\)는 이를 표시하기 위해 응답 코드 101과 함께 임시 응답을 보낼 수 있습니다\(자세한 내용은 섹션 4.4.8 참조\).

순수한 트랜잭션 의미론은 임시 응답이 트랜잭션이 현재 실행 중이라는 사실 이외의 다른 정보를 반환해서는 안 된다는 것을 의미합니다. 그러나 일부 정보가 반환되도록 허용하는 낙관적 접근 방식을 사용하면 시스템에서 발생할 수 있는 지연을 줄일 수 있습니다.\(SHOULD NOT\)

시스템의 지연을 줄이려면 CreateConnection 명령에 대한 임시 응답에 연결 식별자와 세션 설명을 포함하는 것이 좋습니다. 세션 설명이 ModifyConnection 명령에 의해 반환되는 경우 세션 설명은 여기의 임시 응답에도 포함되어야 합니다. 트랜잭션이 성공적으로 완료되면 임시 응답에서 반환된 정보가 최종 응답에서 반복되어야 합니다. 성공적인 응답에서 이 정보를 반복하지 않거나 이전에 제공된 정보를 변경하지 않는 것은 프로토콜 오류로 간주됩니다. 거래가 실패하면 오류 코드가 반환됩니다. 이전에 반환된 정보는 더 이상 유효하지 않습니다.\(SHOULD, SHOULD, MUST\)

엔드포인트에 대한 DeleteConnection 명령이 수신되면 현재 실행 중인 CreateConnection 또는 ModifyConnection 트랜잭션을 취소해야 합니다. 이 경우 취소된 트랜잭션에 대한 최종 응답은 자동으로 반환되어야 하며\(오류 코드 407 - 트랜잭션이 중단됨, 권장됨\) 취소된 트랜잭션의 재전송이 감지되면 취소된 트랜잭션에 대한 최종 응답이 반환되어야 합니다\(MUST 참조\). 또한 섹션 4.4.4\).\(MUST, MUST\)

임시 응답을 수신한 MGCP 엔터티는 해당 트랜잭션에 대해 더 긴 반복 타이머\(LONGTRAN-TIMER\)로 전환해야 합니다. 이 타이머의 목적은 주로 처리 실패를 감지하는 것입니다. LONGTRAN-TIMER의 기본값은 5초이지만 프로비저닝 프로세스에 따라 이 값이 변경될 수 있습니다. 재전송은 여전히 ​​섹션 3.5.1 및 3.5.3에 지정된 타이밍 요구 사항을 충족해야 합니다. 결과적으로 LONGTRAN-TIMER는 T-HIST보다 작아야 합니다\(실제로는 상당히 작아야 합니다\). 또한 엔터티는 트랜잭션이 영원히 실행되도록 해서는 안 됩니다. 엔터티에 의해 시간 초과된 트랜잭션은 오류 코드 406\(트랜잭션 시간 초과\)을 반환해야 합니다. T-HIST의 정의\(Section 3.5.1\)에 따라 최대 트랜잭션 실행 시간은 T-HIST보다 작습니다\(지연이 낮은 네트워크에서는 T-HIST에서 T-MAX를 뺀 값으로 합리적으로 안전하게 근사화할 수 있음\). 최종 응답은 명령이 처음 전송된 후 T-HIST 초 이내에 수신되어야 합니다. 그럼에도 불구하고, 엔터티는 최종 응답 수신을 포기하기 전에 2\*T-HIST 초를 기다려야 합니다. 하지만 명령 재전송은 T-MAX 초 이후에도 중단되어야 합니다. 응답을 받지 못하면 트랜잭션 결과를 알 수 없습니다. 명령을 보내는 엔터티가 게이트웨이라면 이제 "연결 해제"되고 "연결 해제" 절차를 시작해야 합니다\(섹션 4.4.7 참조\).\(MUST, MUST, MUST, MUST NOT, SHOULD, SHOULD, MUST, MUST\)

트랜잭션 실행이 완료되면 최종 응답이 전송되고 지금은 사용되지 않는 임시 응답이 삭제됩니다. 손실된 최종 응답을 신속하게 감지하려면 트랜잭션에 대한 임시 응답 이후에 발행된 최종 응답을 승인해야 합니다\(불행히도 이전 RFC 2705 구현에서는 이를 수행하지 않을 수 있으며 이것이 절대 요구 사항이 아닌 유일한 이유입니다\).\(SHOULD\)

따라서 엔드포인트는 해당 최종 응답에만 빈 "ResponseAck" 매개변수를 포함해야 합니다. 최종 응답에 "ResponseAck" 매개변수가 있으면 "응답 승인" 응답이 엔드포인트로 다시 전송되도록 트리거해야 합니다. 응답 승인" 응답은 응답 헤더에 승인한 응답의 트랜잭션 ID를 포함합니다. 이전 버전과의 호환성을 위해 엔터티는 이러한 "응답 승인" 수신에 의존할 수 없지만 이 동작을 지원할 것을 강력히 권장합니다. , 패킷 손실의 경우 과도한 지연이 발생하고 그렇지 않은 경우 과도한 재전송이 발생할 수 있습니다.\(SHOULD, SHOULD, SHOULD\)

"응답 승인" 응답 수신에는 명령에 대한 응답과 동일한 시간 제한 및 재전송 전략 및 절차가 적용됩니다. 즉, "응답 승인"이 제 시간에 수신되지 않으면 최종 응답의 보낸 사람이 이를 재전송합니다. 이전 버전과의 호환성을 위해 "응답 확인" 수신 실패는 후속 명령에 대한 왕복 시간 추정에 영향을 주어서는 안 되며, 더 나아가 엔드포인트가 "연결 해제"되는 결과를 초래해서는 안 됩니다. "응답 승인" 응답은 승인되지 않습니다.\(MUST NOT\)

---
## **4. States, Failover and Race Conditions**

적절한 통화 신호를 구현하기 위해 통화 에이전트는 엔드포인트의 상태를 추적해야 하며 게이트웨이는 이벤트가 통화 에이전트에 적절하게 통보되는지 확인해야 합니다. 게이트웨이 또는 통화 에이전트가 다시 시작될 때 특별한 조건이 존재합니다. "장애 조치" 절차 중에 게이트웨이를 새 통화 에이전트로 리디렉션해야 하며, 통화 에이전트는 게이트웨이가 오프라인이 되거나 다시 시작될 때 특별한 조치를 취해야 합니다.

---
## **4.1 Failover Assumptions and Highlights**

다음 프로토콜 하이라이트는 통화 에이전트 장애 조치 메커니즘을 이해하는 데 중요합니다.

\* 통화 에이전트는 네트워크 주소가 아닌 도메인 이름\(및 선택적 포트\)으로 식별되며 여러 주소가 도메인 이름과 연결될 수 있습니다.

\* 엔드포인트에는 특정 시점에 단 하나의 통화 에이전트가 연결되어 있습니다. 엔드포인트와 연결된 통화 에이전트는 "통지된 엔터티"의 현재 값입니다. "통지된 엔터티"는 게이트웨이가 명령을 보낼 위치를 결정합니다. "통지된 엔터티"에 포트 번호가 포함되어 있지 않으면 기본 통화 에이전트 포트 번호\(2727\)가 가정됩니다.

\* NotifiedEntity는 엔드포인트에 대한 "통지 엔터티"를 설정하기 위해 통화 에이전트가 게이트웨이로 전송하는 매개변수입니다.

\* 엔드포인트의 "알림 엔터티"는 이 엔드포인트에 대해 수신된 NotifiedEntity 매개변수의 마지막 값입니다. 명시적인 NotifiedEntity 매개변수가 수신되지 않은 경우 "알림 엔터티"는 기본적으로 프로비저닝된 값으로 설정됩니다. 값이 프로비저닝되지 않았거나 빈 NotifiedEntity 매개변수가 제공되어\(둘 다 권장되지 않음\) "알림 엔터티"가 비어 있는 경우 "알림 엔터티"는 엔드포인트에 대한 마지막 비감사 명령의 소스 주소로 설정됩니다. 따라서 감사는 "신고된 엔터티"를 변경하지 않습니다.

\* 명령에 대한 응답은 현재 "통지된 엔터티"에 관계없이 명령의 소스 주소로 전송됩니다. 알림 메시지가 응답과 함께 피기백되어야 하는 경우 데이터그램은 현재 "통지된 엔터티"에 관계없이 수신된 새 명령의 소스 주소로 계속 전송됩니다.

여러 네트워크 주소를 확인하는 "통지 엔터티"의 기능을 통해 "통지 엔터티"는 여러 물리적 인터페이스가 있는 통화 에이전트 및/또는 여러 물리적 시스템으로 구성된 논리적 통화 에이전트를 나타낼 수 있습니다. DNS 이름이 여러 주소로 확인될 때 네트워크 주소의 순서는 비결정적이므로 호출 에이전트 장애 조치 체계는 어떤 순서에도 의존해서는 안 됩니다. 예를 들어 게이트웨이는 확인된 네트워크 중 하나에 "알림"을 보낼 수 있어야 합니다. 구애\). 반면, 게이트웨이가 이미 현재 연결되어 있는 인터페이스에 명령을 보내는 경우 시스템이 가장 효율적일 수 있습니다. 해당 목표를 달성하려면 게이트웨이에서 다음 알고리즘을 사용하는 것이 좋습니다.\(MUST NOT, SHOULD\)

\* "통지된 엔터티"가 여러 네트워크 주소로 확인되고 요청의 소스 주소가 해당 주소 중 하나인 경우 해당 네트워크 주소는 명령의 기본 대상 주소입니다.

\* 반면에 요청의 소스 주소가 확인된 주소 중 하나가 아닌 경우 게이트웨이는 명령에 대해 확인된 주소 중 하나를 선택해야 합니다.

\* 게이트웨이가 선택한 네트워크 주소에 연결하지 못하는 경우 섹션 4.3에 설명된 대로 확인된 목록의 대안을 시도해야 합니다.\(MUST\)

전체 통화 에이전트를 사용할 수 없게 되면 해당 통화 에이전트가 관리하는 엔드포인트는 결국 "연결이 끊어집니다". 이러한 엔드포인트를 다시 연결하는 유일한 방법은 실패한 통화 에이전트를 사용할 수 있게 하거나 백업 통화 에이전트가 영향을 받은 엔드포인트에 새로운 "알림 엔터티"를 연결하는 것입니다.

백업 통화 에이전트가 엔드포인트 그룹의 제어권을 인수하면 실패한 통화 에이전트는 영향을 받은 엔드포인트에 대한 제어권을 원래 통화 에이전트로 다시 이전하기 위해 백업 통화 에이전트와 통신하고 동기화한다고 가정합니다. 또는 실패한 통화 에이전트가 단순히 백업 통화 에이전트가 될 수도 있습니다.

별도의 CA 간의 핸드오버 충돌 해결 방법은 마련되어 있지 않습니다. 우리는 CA가 자신이 수행하는 작업을 알고 서로 통신하는 것에 엄격하게 의존하고 있습니다\(AuditEndpoint를 사용하여 현재 "알려진 엔터티"에 대해 알아볼 수 있음\). 그렇지 않은 경우 예기치 않은 동작이 발생할 수 있습니다.

앞서 언급한 대로 기본 "알림 엔터티"가 제공되며 도메인 이름과 포트가 모두 포함될 수 있습니다. 소규모 게이트웨이의 경우 엔드포인트별로 프로비저닝이 수행될 수 있습니다. 훨씬 더 큰 게이트웨이의 경우 여러 엔드포인트 또는 전체 게이트웨이 자체에 대해 단일 프로비저닝 요소가 제공될 수 있습니다. 두 경우 모두, 게이트웨이의 전원이 켜지면 각 엔드포인트에는 자체 "알림 엔터티"가 있어야 하므로 엔드포인트 집합에 대해 프로비저닝된 값은 작업이 진행되기 전에 집합의 각 엔드포인트에 대한 "알림 엔터티"에 복사되어야 합니다. 가능한 경우 재시작 시 RestartInProgress 명령은 "전체" 와일드카드 사용을 허용하는 집계를 기반으로 프로비저닝된 "통지 엔터티"로 전송되어야 합니다. 이렇게 하면 RestartInProgress 메시지 수가 줄어듭니다.\(MUST, SHOULD\)

"통지된 엔터티"의 사용을 보는 또 다른 방법은 게이트웨이와 통화 에이전트 간의 연결 측면에서 볼 수 있습니다. "통지된 엔터티"는 해당 연결을 설정하는 수단이며 게이트웨이가 명령을 보낼 위치를 관리합니다. 그러나 게이트웨이가 수신한 명령은 모든 소스에서 나올 수 있습니다. 연결은 초기에 프로비저닝된 "알림 엔터티"로 프로비저닝되므로 전원을 켤 때 RestartInProgress 및 통화 에이전트의 첫 번째 알림 요청 이전에 발생하는 지속적인 이벤트가 프로비저닝된 통화 에이전트로 전송됩니다. 그러나 통화 에이전트가 요청하면 NotifiedEntity 매개변수를 포함하고 새 연결을 설정할 수 있습니다. "알림 엔터티"는 호출 전반에 걸쳐 지속되므로 새로운 "알림 엔터티"가 제공될 때까지 연결은 그대로 유지됩니다.

---
## **4.2 Communicating with Gateways**

게이트웨이의 엔드포인트 이름에는 특정 엔드포인트를 나타내는 로컬 이름과 엔드포인트가 있는 호스트/게이트웨이를 나타내는 도메인 이름이 포함됩니다. 게이트웨이에는 중복성을 위해 여러 인터페이스가 있을 수 있습니다.

라우팅 기능이 있는 게이트웨이에서 도메인 이름은 게이트웨이 인터페이스 중 하나에서 해당 주소로 내부 라우팅을 사용하여 단일 네트워크 주소로 확인될 수 있습니다. 다른 경우에는 도메인 이름이 각 인터페이스마다 하나씩 여러 네트워크 주소로 확인될 수 있습니다. 후자의 경우 통화 에이전트가 주소 중 하나에서 게이트웨이에 연결하는 데 실패하면 대체 주소를 시도해야 합니다.\(MUST\)

---
## **4.3 Retransmission, and Detection of Lost Associations:**

미디어 게이트웨이 제어 프로토콜은 일련의 트랜잭션으로 구성되며, 각 트랜잭션은 일반적으로 승인이라고 하는 명령과 응답으로 구성됩니다. UDP를 통해 전달되는 MGCP 메시지는 손실될 수 있습니다. 시기적절한 응답이 없으면 명령이 재전송됩니다. MGCP 엔터티는 최근 트랜잭션에 보낸 응답 목록, 즉 지난 T-HIST 초 동안 보낸 모든 응답 목록과 아직 실행이 완료되지 않은 트랜잭션 목록을 메모리에 유지해야 합니다.\(MUST\)

들어오는 명령의 트랜잭션 식별자는 최근 응답의 트랜잭션 식별자와 비교됩니다. 일치하는 항목이 발견되면 MGCP 엔터티는 트랜잭션을 실행하지 않고 단순히 응답을 반복합니다. 이전에 응답한 트랜잭션과 일치하는 항목을 찾을 수 없으면 들어오는 명령의 트랜잭션 식별자를 아직 실행이 완료되지 않은 트랜잭션 목록과 비교됩니다. 일치하는 항목이 발견되면 MGCP 엔터티는 트랜잭션을 다시 실행하지 않고 단순히 임시 응답을 보내야 합니다. 명령 실행이 완료되면 최종 응답이 제공됩니다\(자세한 내용은 섹션 3.5.6 참조\).\(SHOULD\)

반복 메커니즘은 네 가지 유형의 가능한 오류를 방지하는 데 사용됩니다.

\* 전송 오류\(예: 회선의 잡음이나 대기열의 혼잡으로 인해 패킷이 손실된 경우\)

\* 구성 요소 오류\(예: 통화 에이전트에 대한 인터페이스를 사용할 수 없게 되는 경우\)

\* 통화 에이전트 오류\(예: 전체 통화 에이전트를 사용할 수 없게 되는 경우\)

\* 장애 조치\(failover\), 새 통화 에이전트가 투명하게 "인계"되는 경우입니다.

요소는 과거 이력으로부터 전송 오류로 인한 패킷 손실률 추정치를 도출할 수 있어야 합니다. 적절하게 구성된 시스템에서 이 손실률은 일반적으로 1% 미만으로 매우 낮아야 합니다. 통화 에이전트나 게이트웨이가 메시지를 여러 번 반복해야 하는 경우 전송 오류가 아닌 다른 문제가 발생했다고 가정하는 것이 매우 타당합니다. 예를 들어 손실률이 1%인 경우 5번의 연속 전송 시도가 실패할 확률은 1,000억분의 1입니다. 이는 초당 1,000개의 트랜잭션을 처리하는 통화 에이전트의 경우 10일에 한 번 미만으로 발생해야 하는 이벤트입니다. \(실제로 과도한 것으로 간주되는 재전송 횟수는 다음의 함수여야 합니다.

일반적인 패킷 손실률.\) "Max1"이라고 부르는 "의심 임계값"은 일반적으로 "Max2"라고 하는 "연결 끊김 임계값"보다 낮다는 점에 유의해야 합니다. Max2는 Max1보다 큰 값으로 설정되어야 합니다.\(MUST\)

MGCP 재전송 알고리즘은 아래 그림에 설명되어 있으며 다음에서 자세히 설명됩니다.

```text
      Command issued: N=0, T=0
              |
              |  +------------ retransmission: N++ <--------------+
              |  |                                                |
              |  |     if T <= T-Max then                         |
              |  |      transmission                              |
              |  |  +-- to new address, <-+<----------------------|--+
              |  |  |       N=0           |                       |  |
              V  V  V                     |                       |  |
          +-----------+                   |                       |  |
      +-->| awaiting  |- new Call Agent ->+   +------------+      |  |
      |   |  response |--- timer elapsed  --->| T > T-Max ?|      |  |
      |   +-----------+                       +------------+      ^  ^
      |          |                             |    |             |  |
      |          v             +-----(yes)-----+   (no)           |  |
      |      (response         |                    |             |  |
      |       received)        |              +------------+      |  |
      |          |             |              | N >= Max1 ?|-(no)>+  |
      |          v             |              +------------+      ^  ^
      |      +--------+        |                    |             |  |
      +<(no)-| final ?|        |                  (yes)           |  |
      ^      +--------+        |                    |             |  |
      |          |             |     (if first address & N=Max1,  |  |
      |          v             |      or last address & N=Max2    |  |
      |        (yes)           |               check DNS)         |  |
      |          |             |                    |             |  |
      |          v             V           +---------------+      |  |
      |        (end)           |           |more addresses?|(yes)-|->+
      |                        |           +---------------+      |
      |                        |                    |             ^
      |                        |                  (no)            |
      |                        |                    |             |
      |                        |              +------------+      |
      |                        |              | N >= Max2 ?|(no)--+
      |                        |              +------------+
      |                        |                    |
      |                        |                  (yes)
      |                        |                    |
      |                        |            +----------------+
      |                        +----------->| T >= 2*T-HIST ?|
      |                                     +----------------+
      |                                       |       |
      |                                     (no)    (yes)
      +---------------<-----------------------+       |
                                                      v
                                                (disconnected)
```

전통적인 재전송 알고리즘은 단순히 연속적인 반복 횟수를 계산하고 패킷을 과도한 횟수\(일반적으로 7\~11회\) 재전송한 후에 연결이 끊어졌다는 결론을 내립니다. 감지되지 않았거나 진행 중인 "장애 조치"의 가능성을 설명하기 위해 다음과 같이 기본 알고리즘을 수정합니다.

\* 게이트웨이는 항상 새로운 통화 에이전트가 있는지 확인해야 합니다. 다음 중 하나로 확인할 수 있습니다.

- NotifiedEntity가 새 통화 에이전트를 가리키는 명령을 수신하거나

- 새로운 통화 에이전트를 가리키는 리디렉션 응답을 받습니다.

새로운 통화 에이전트가 감지되면 게이트웨이는 해당 새로운 통화 에이전트로 리디렉션된 엔드포인트에 대해 처리되지 않은 명령을 재전송하기 시작해야 합니다. 새 명령이나 이전 명령에 대한 응답은 여전히 ​​명령의 소스 주소로 전송됩니다.\(MUST\)

\* 재전송에 앞서 초기 데이터그램 전송 이후 경과된 시간이 T-MAX보다 크지 않은지 확인합니다. T-MAX 시간 이상이 경과하면 재전송을 중단해야 합니다. 2\*T-HIST 이상이 경과하면 엔드포인트의 연결이 끊어집니다.\(MUST\)

\* 이 호출 에이전트의 반복 횟수가 "Max1"과 같고 해당 도메인 이름이 최근\(예: 지난 5초 이내 또는 다른 방식으로 프로비저닝됨\) 확인되지 않았고 확인 과정에 있지 않은 경우 게이트웨이는 통화 에이전트 인터페이스의 변경 가능성을 감지하기 위해 도메인 이름 서버에 적극적으로 쿼리할 수 있습니다. 첫 번째 반복이 두 번째 전송이라는 점에 유의하세요.\(MAY\)

\* 게이트웨이는 통화 에이전트에 대해 여러 IP 주소를 학습했을 수 있습니다. 이 IP 주소에 대한 반복 횟수가 "Max1"보다 크거나 같고 "Max2"보다 작고 시도되지 않은 주소가 더 많은 경우 게이트웨이는 재전송을 대체 주소로 보내야 합니다. 또한 ICMP 네트워크, 호스트, 프로토콜 또는 연결할 수 없는 포트와 같은 명시적인 네트워크 알림을 수신하면 게이트웨이가 대체 주소를 시도해야 합니다\(가능한 보안 문제를 적절히 고려하여\).\(MUST, SHOULD\)

\* 시도할 인터페이스가 더 이상 없고 이 주소에 대한 반복 횟수가 Max2인 경우, 게이트웨이는 도메인 이름이 최근에 확인되지 않은 한\(예: , 지난 5초 이내 또는 다른 방법으로 프로비저닝됨\) 또는 이미 해결 과정에 있습니다. 시도할 인터페이스가 더 이상 없으면 게이트웨이의 연결이 끊어지고 "연결 끊김" 절차를 시작해야 합니다\(섹션 4.4.7 참조\).\(SHOULD, MUST\)

네트워크 부하에 자동으로 적응하기 위해 MGCP는 기하급수적으로 증가하는 타이머를 지정합니다. 초기 타이머가 200밀리초로 설정된 경우 다섯 번째 재전송 손실은 약 6초 후에 감지됩니다. 이는 아마도 장애 조치를 감지하기 위해 허용되는 대기 지연일 것입니다. 일시적인 연결 문제를 극복할 뿐만 아니라 장애 조치 실행에 더 많은 시간을 허용하기 위해 해당 지연 이후에도 반복을 계속해야 합니다. 총 30초의 지연을 기다리는 것이 허용될 수 있습니다.

그러나 재전송의 최대 지연을 제한하는 것이 중요합니다. 재전송에 앞서 초기 데이터그램 전송 이후 경과된 시간\(T\)이 T-MAX보다 크지 않은지 확인합니다. T-MAX 시간 이상이 경과하면 재전송을 중단해야 합니다. 2\*T-HIST 시간 이상이 경과되면 엔드포인트의 연결이 끊어집니다. T-MAX 값은 T-HIST 값과 관련됩니다. T-HIST 값은 T-MAX에 네트워크의 최대 전파 지연을 더한 값보다 크거나 같아야 합니다.\(MUST, MUST\)

T-MAX의 기본값은 20초입니다. 따라서 가정된 최대 전파 지연이 10초라면 이전 트랜잭션에 대한 응답은 최소 30초 동안 유지되어야 합니다. 발신자와 수신자가 이러한 가치에 동의하는 것의 중요성은 아무리 강조해도 지나치지 않습니다.

Max1의 기본값은 5번의 재전송이고 Max2의 기본값은 7번의 재전송입니다. 이 두 값은 모두 프로비저닝 프로세스에 의해 변경될 수 있습니다.

프로비저닝 프로세스는 Max1 및 Max2 DNS 쿼리 중 하나 또는 둘 다를 비활성화할 수 있어야 합니다.\(MUST\)

---
## **4.4 Race Conditions**

MGCP는 "격리 목록"이라는 개념과 비동기화의 명시적인 감지\(예: 엔드포인트의 눈부심으로 인한 불일치 후크 상태\)를 통해 경쟁 조건을 처리합니다.

MGCP는 전송 메커니즘이 명령과 응답의 순서를 유지할 것이라고 가정하지 않습니다. 이로 인해 경쟁 조건이 발생할 수 있으며 이는 호출 에이전트의 적절한 동작을 통해 방지할 수 있습니다. \(일부 경쟁 조건은 분산 시스템에 내재되어 있으며 명령이 엄격한 순서로 전송되더라도 여전히 발생합니다.\)

경우에 따라 많은 게이트웨이가 동시에 작업을 다시 시작하기로 결정할 수도 있습니다. 예를 들어, 지진이나 얼음 폭풍으로 인해 특정 지역에서 전력이나 송전 능력이 손실되는 경우 이러한 상황이 발생할 수 있습니다. 전원과 전송이 다시 설정되면 많은 게이트웨이가 "RestartInProgress" 명령을 동시에 전송하기로 결정하여 작동이 매우 불안정해질 수 있습니다.

---
### **4.4.1 Quarantine List**

MGCP 제어 게이트웨이는 "이벤트" 목록을 감시하도록 요청하는 "알림 요청"을 수신합니다. 이러한 이벤트 처리를 결정하는 프로토콜 요소는 "요청된 이벤트" 목록, "숫자 지도", "격리 처리" 및 "이벤트 검색" 목록입니다.

엔드포인트가 초기화되면 요청된 이벤트 목록은 엔드포인트에 대한 영구 이벤트로만 구성되며 숫자 맵은 비어 있는 것으로 간주됩니다. 이 시점에서 엔드포인트는 예약된 RequestIdentifier 0\("0"\)과 함께 암시적 알림 요청을 사용하여 지속적인 이벤트\(예: 오프 후크\)를 감지하고 보고할 수 있습니다. 기존의 오프 후크 조건으로 인해 오프 후크 이벤트도 생성되어야 합니다.\(MAY, MUST\)

엔드포인트는 통지요청\(NotificationRequest\) 명령의 수신을 기다립니다. 그 후 게이트웨이는 지속성 이벤트를 포함하여 목록에 언급된 이벤트의 발생에 대해 엔드포인트를 관찰하기 시작합니다.

이벤트가 발생하면 검사됩니다. 다음 작업은 요청된 이벤트 목록의 이벤트와 연결된 "action" 매개변수와 숫자 맵에 의해 결정됩니다. "누적" 또는 "숫자 지도에 따라 누적"으로 정의된 이벤트는 이벤트 목록에 누적되며, "숫자 지도에 따라 누적"으로 표시된 이벤트는 "현재 다이얼 문자열"에 추가로 누적됩니다. . 이는 현재 "통지된 엔터티"에 전송될 알림을 트리거하는 하나의 이벤트가 발생할 때까지 계속됩니다.

```text
   The gateway, at this point, will transmit the Notify command and will
   place the endpoint in a "notification" state.  As long as the
   endpoint is in this notification state, the events that are to be
   detected on the endpoint are stored in a "quarantine" buffer (FIFO)
```

나중에 처리하기 위해. 이벤트는 어떤 의미에서 "격리"됩니다. RequestedEvents 매개변수와 가장 최근에 수신된 DetectEvents 매개변수의 결합으로 지정된 모든 이벤트 또는 후자가 없는 경우 RequestedEvents에서 참조되는 모든 이벤트는 관련된 작업에 관계없이 감지되고 격리되어야 합니다. 이벤트. 여기서 지속 이벤트는 RequestedEvents에 암시적으로 포함된 것으로 간주됩니다. 격리 버퍼가 엔드포인트의 용량에 도달하면 격리 버퍼 오버플로 이벤트\(부록 B 참조\)가 생성되어야 합니다\(이 이벤트가 지원되면 엔드포인트는 격리 버퍼에 이벤트를 포함할 수 있는 용량이 있는지 확인해야 합니다\). 초과 이벤트는 이제 삭제됩니다.\(MUST, MUST\)

Notify 명령에 대한 응답\(성공 또는 실패 여부\)이 수신되면 엔드포인트는 "알림 상태"를 종료합니다. Notify 명령은 섹션 3.5 및 4에 지정된 대로 "알림 상태"에서 재전송될 수 있습니다. 이 동안 엔드포인트의 연결이 끊어지거나 연결이 끊어지면\(섹션 4.3 참조\) Notify 명령에 대한 응답은 절대 수신되지 않습니다. 그러면 알림 명령이 손실되어 더 이상 보류 중인 것으로 간주되지 않지만 끝점은 여전히 ​​"알림 상태"에 있습니다. 그런 일이 발생하면 섹션 4.4.7에 지정된 연결 해제 절차가 완료되면 엔드포인트가 "통지 상태"를 종료해야 합니다.\(MUST\)

엔드포인트가 "알림 상태"를 종료하면 관찰된 이벤트 목록과 엔드포인트의 "현재 다이얼 문자열"이 null 값으로 재설정됩니다.

해당 시점 이후에는 게이트웨이의 동작이 TriggeringNotificationRequest 명령의 QuarantineHandling 매개 변수 값에 따라 달라집니다.

호출 에이전트가 알림 요청 명령에 대한 응답으로 최대 하나의 알림을 예상한다고 지정한 경우 게이트웨이는 다음 알림 요청 명령을 수신할 때까지 격리 버퍼에 이벤트를 계속 축적해야 합니다.\(MUST\)

그러나 게이트웨이가 여러 개의 연속적인 알림 명령을 보낼 권한이 있는 경우 다음과 같이 진행됩니다. 게이트웨이가 "알림 상태"를 종료하면 관찰된 이벤트 목록과 엔드포인트의 "현재 다이얼 문자열"을 null 값으로 재설정하고 이미 수신된 요청 이벤트 목록과 숫자를 사용하여 격리된 이벤트 목록 처리를 시작합니다. 지도. 이러한 이벤트를 처리할 때 게이트웨이는 알림 명령이 전송되도록 트리거하는 이벤트를 만날 수 있습니다. 이 경우 게이트웨이는 다음 두 가지 동작 중 하나를 채택할 수 있습니다.

\* 트리거 이벤트까지 관찰된 이벤트 목록에 누적된 모든 이벤트를 보고하는 Notify 명령을 즉시 전송할 수 있으며, 처리되지 않은 이벤트는 격리 버퍼에 남겨두고,

\* 또는 격리 버퍼를 비우고 여러 이벤트 세트\(관찰된 이벤트의 단일 목록\)와 여러 다이얼 문자열을 보고하는 단일 알림 명령을 전송할 수 있습니다. "현재 다이얼 문자열"은 각 트리거 이벤트 후에 null 값으로 재설정됩니다. 마지막 트리거 이벤트 이후의 이벤트는 격리 버퍼에 남아 있습니다.

게이트웨이가 알림 명령을 전송하면 엔드포인트는 다시 들어가고 승인이 수신될 때까지 "알림 상태"를 유지합니다\(위에 설명된 대로\). 게이트웨이가 알림 명령을 트리거하는 격리된 이벤트를 찾지 못하면 엔드포인트를 정상 상태로 전환합니다. 그런 다음 알림 요청 명령이 방금 수신된 것과 똑같은 방식으로 이벤트가 발생하면 처리됩니다.

게이트웨이는 엔드포인트 연결이 끊어진 경우를 포함하여 언제든지 엔드포인트에 대한 새로운 알림 요청 명령을 받을 수 있습니다. 포함된 알림 요청을 활성화하는 것은 ObservedEvents의 현재 목록이 다시 처리되지 않고 수정되지 않은 상태로 유지된다는 점을 제외하면 여기서는 새 알림 요청도 수신하는 것으로 간주됩니다. 알림 상태에서 새 알림 요청이 수신되면 게이트웨이는 보류 중인 알림이 새 알림 이전에 호출 에이전트에 의해 수신되었는지 확인해야 합니다\(연결이 끊어져 손실된 알림은 더 이상 보류 중인 것으로 간주되지 않음\). . 이는 프로토콜의 "피기백" 기능을 사용하여 수행됩니다. 그런 다음 메시지는 단일 패킷으로 현재 "통지된 엔터티"로 전송됩니다. 관련된 단계는 다음과 같습니다.\(MUST\)

a\) 게이트웨이는 새 알림 요청에 대한 응답을 보냅니다.

b\) 엔드포인트는 보류 중인 알림 명령의 승인을 기다리지 않고 "알림 상태"에서 벗어납니다.

c\) 승인되지 않은 알림 명령의 복사본은 승인이 수신될 때까지 보관됩니다. 타이머가 경과하면 알림이 다시 전송됩니다.

d\) 게이트웨이가 이전 알림이 승인되기 전에 새 알림을 전송해야 하는 경우 이전 알림과 새 알림\(오래된 알림부터 순서대로 정렬\)의 반복을 피기백하는 패킷을 구성합니다. 이 데이터그램은 현재 "통지된 엔터티"로 전송됩니다.

f\) 동일한 데이터그램에 있는 여러 메시지를 피기백할 수 없어 두 개\(또는 그 이상\) Notify의 순차적 전달을 보장할 수 없는 게이트웨이는 마지막 Notify가 승인되지 않는 한 엔드포인트를 "notification" 상태로 남겨 두어야 합니다.\(MUST\)

절차는 다음 다이어그램에 설명되어 있습니다.

```text
    +-------------------+
    | Processing Events |<--------------------------------------+
    +-------------------+                                       |
             |                                                  |
     Need to send NTFY                                          |
             |                                                  |
             v                                                  |
    +-------------------+                                       |
    | Outstanding NTFY  |---- No -------+                       |
    |                   |               |                       |
    +-------------------+               v                       |
             |                    +-----------+                 |
            Yes                   | Send NTFY |                 |
             |                    +-----------+                 |
             v                          |                       |
    +--------------------+              v                       |
    | Piggyback new NTFY |     +--------------------+           |
    | w. old outstanding |---->| Notification State |           |
    | NTFY(s)            |     +--------------------+           |
    +--------------------+       |               |              |
                             new RQNT        NTFY response      |
                             received        received           |
                                 |               |              |
                                 |               v              |
                                 |        +-------------+       |
                                 |        | Step mode ? |- No ->+
                                 |        +-------------+       ^
                                 |               |              |
                                 |              Yes             |
                                 |               |              |
                                 |               v              |
                                 |       +---------------+      |
                                 |       | Wait for RQNT |      |
                                 |       +---------------+      |
                                 |               |              |
                                 |         RQNT received        |
                                 |               |              |
                                 |               v              |
                                 |       +---------------+      |
                                 +------>| Apply RQNT and|----->+
                                         | send response |
                                         +---------------+
```

게이트웨이는 프로토콜의 "피기백\(piggybacking\)" 기능을 사용하여 새 알림 요청에 대한 성공적인 응답 전에 보류 중인 알림 전달을 시도할 수도 있습니다. 이는 실제로 RFC 2705에서 요구되는 동작이었지만 이를 수행하는 데는 몇 가지 복잡한 문제가 있으며 이점이 의심스럽습니다. 특히, RFC 2705 메커니즘은 일반적으로 Notify의 순차적 전달과NotificationRequests에 대한 응답을 보장하지 않으므로 통화 에이전트는 어쨌든 이러한 메시지의 비순차적 전달을 처리해야 했습니다. 따라서 선택적 상태로의 변경은 복잡성을 크게 줄이면서 이전 버전과 호환됩니다.

알림 요청 명령을 받은 후 요청된 이벤트 목록과 숫자 맵\(새 항목이 제공된 경우\)은 새로 수신된 매개변수로 대체되고 현재 다이얼 문자열은 null 값으로 재설정됩니다. 또한 "알림 상태"에서 알림 요청이 수신되면 관찰된 이벤트 목록이 null 값으로 재설정됩니다. 후속 동작은 QuarantineHandling 매개 변수의 값에 따라 결정됩니다. 매개변수는 격리된 이벤트\(및 이 경우 현재 빈 목록인 관찰된 이벤트\)를 삭제하도록 지정할 수 있으며, 이 경우 삭제됩니다. 매개변수가 격리된\(및 관찰된\) 이벤트가 처리되도록 지정하는 경우 게이트웨이는 새로 수신된 요청 이벤트 목록 및 숫자 맵\(제공된 경우\)을 사용하여 격리된\(및 관찰된\) 이벤트 목록 처리를 시작합니다. 이러한 이벤트를 처리할 때 게이트웨이에서 알림 명령을 보내야 하는 이벤트가 발생할 수 있습니다. 이 경우 게이트웨이는 트리거 이벤트까지 관찰된 이벤트 목록에 누적된 모든 이벤트를 보고하고 처리되지 않은 이벤트를 격리 버퍼에 남겨 두는 알림 명령을 즉시 전송하고 "알림 상태"로 진입합니다. ".

게이트웨이가 이전 알림 요청에 따라 이벤트를 누적했지만 알림을 트리거하는 이벤트를 아직 감지하지 않은 경우, 즉 엔드포인트가 "알림 상태"가 아닌 경우 새 알림 요청이 수신될 수 있습니다. 아직 통보되지 않은 이벤트의 처리는 격리된 이벤트와 마찬가지로 격리 처리 매개변수에 의해 결정됩니다.

\* 격리 처리 매개변수에서 격리된 이벤트를 무시하도록 지정하면 관찰된 이벤트 목록이 재설정됩니다.

\* 격리 처리 매개 변수에 격리된 이벤트를 처리하도록 지정하면 관찰된 이벤트 목록이 격리된 이벤트 목록으로 전송됩니다. 그러면 관찰된 이벤트 목록이 재설정되고 격리된 이벤트 목록이 처리됩니다.

잠금 단계 모드에서 끝점을 제어하는 ​​호출 에이전트는 피기백 메커니즘을 사용하여 동일한 데이터그램에서 성공적인 알림 메시지와 새 알림 요청에 대한 응답을 제공해야 합니다\(SHOULD\).\(SHOULD\)

---
### **4.4.2 Explicit Detection**

여러 엔드포인트 상태의 핵심 요소는 후크의 위치입니다. 통화 에이전트가 게이트웨이에 오프 후크 이벤트\(전화 통신에서 잘 알려진 "눈부심" 조건\)를 알리도록 요청할 시간을 갖기 전에 사용자가 오프 후크 상태로 전환하기로 결정하거나 사용자가 계속해서 오프 후크 상태로 전환하면 경쟁 조건이 발생할 수 있습니다. -통화 에이전트가 이벤트 알림을 요청할 시간을 갖기 전에 후크합니다.

이러한 경합 상태를 방지하려면 게이트웨이는 알림 요청을 승인하기 전에 엔드포인트의 상태를 확인해야 합니다. 반드시 오류를 반환해야 합니다.\(MUST, MUST\)

```text
   1. If the gateway is requested to notify an "off-hook" transition
      while the phone is already off-hook, (error code 401 - phone off
      hook)
```

2. 전화기가 이미 온훅 상태인 동안 게이트웨이에 "온훅" 또는 "플래시훅" 조건을 알리도록 요청된 경우\(오류 코드 402 - 전화기 온훅\).

또한 개별 신호 정의에서는 신호가 특정 조건에서만 작동하도록 지정할 수 있습니다. 예를 들어 전화가 이미 오프 후크 상태인 경우에만 벨이 울릴 수 있습니다. 주어진 신호에 대해 이러한 전제 조건이 존재하는 경우 게이트웨이는 전제 조건이 충족되지 않으면 신호 정의에 지정된 오류를 반환해야 합니다.\(MUST\)

상태 확인은 알림 요청이 수신된 시점에 수행되는 반면, 현재 상태를 발생시킨 실제 이벤트는 이전에 보고되었거나 무시되었거나 현재 격리될 수 있다는 점에 유의해야 합니다.

RequestedEvents 목록 또는 요청된 신호 목록과 같은 게이트웨이의 다른 상태 변수는 각 성공적인 알림 요청 후에 완전히 대체되므로 통화 에이전트와 게이트웨이 간의 장기적인 불일치가 방지됩니다.

연결 처리 명령에 포함되어 있는지 여부에 관계없이 알림 요청이 실패하면 게이트웨이는 명령이 전혀 수신되지 않은 것처럼 계속 진행해야 합니다. 다른 모든 트랜잭션과 마찬가지로 통지요청도 원자성 트랜잭션으로 작동해야 하므로 명령의 결과로 시작된 모든 변경 사항을 되돌려야 합니다.\(MUST, MUST\)

게이트웨이가 GatewayRequest를 수신하기 직전에 Notify가 발행되면 또 다른 경쟁 조건이 발생할 수 있습니다. RequestIdentifier는 알림 명령을 알림 요청 명령과 연관시키는 데 사용됩니다. 이를 통해 호출 에이전트는 게이트웨이가 새 알림 요청을 수신하기 전이나 후에 알림 명령이 생성되었는지 확인할 수 있습니다. 이는 "단계" 모드에서 교착 상태를 방지하는 데 특히 중요합니다.

---
### **4.4.3 Transactional Semantics**

예를 들어 외부 리소스 예약으로 인해 잠재적인 트랜잭션 완료 시간이 증가함에 따라 트랜잭션 의미론을 주의 깊게 정의하는 것이 점점 더 중요해지고 있습니다. 특히, 후크 상태와 관련된 경쟁 조건 문제는 신중하게 정의되어야 합니다.

고려해야 할 중요한 점은 사전 조건\(예: 후크 상태\)의 상태가 실제로 트랜잭션이 시작되는 시간과 성공적으로 완료\(트랜잭션 커밋\)되거나 실패하는 시간 사이에 변경될 수 있다는 것입니다. 일반적으로 트랜잭션의 성공적인 실행은 하나 이상의 사전 조건 상태가 트랜잭션 시작과 트랜잭션 커밋 사이에 동적으로 변경될 수 있는 하나 이상의 사전 조건에 달려 있다고 말할 수 있습니다.

이에 대한 가장 간단한 의미는 트랜잭션이 시작된 시간부터 트랜잭션이 커밋될 때까지 모든 사전 조건이 충족되도록 요구하는 것입니다. 트랜잭션이 완료되기 전에 사전 조건이 충족되지 않으면 트랜잭션도 실패합니다.

예를 들어, "오프훅" 이벤트에 대한 요청을 포함하는 트랜잭션을 생각해 보세요. 거래가 시작되면 전화기는 "온훅" 상태가 되므로 이 전제 조건이 충족됩니다. 트랜잭션이 완료되기 전에 후크 상태가 "오프 후크"로 변경되면 전제 조건이 더 이상 충족되지 않으므로 트랜잭션이 즉시 실패합니다.

마지막으로, 새로운 트랜잭션이 적용되고 이전 트랜잭션에 따른 엔드포인트 처리가 중지되는 시점을 고려해야 합니다. 예를 들어, 트랜잭션 T1이 성공적으로 실행되었고, 현재 트랜잭션 T1에 따라 이벤트 처리가 진행되고 있다고 가정해 보겠습니다. 이제 우리는 새로운 이벤트 처리를 지정하는 새로운 트랜잭션 T2를 수신합니다\(예: 캡슐화된 알림 요청이 있는 CreateConnection\). T2가 성공적으로 완료될지 여부를 알 수 없으므로 T2의 결과가 알려질 때까지 T2에 따른 이벤트 처리를 시작할 수 없습니다. T2의 결과가 알려질 때까지 모든 이벤트 처리를 일시 중지할 수 있지만 이렇게 하면 시스템의 응답성이 떨어지므로 수행해서는 안 됩니다. 대신, 새로운 거래 Ty가 수신되고 Ty가 수정되면\(SHOULD NOT\)

이전 트랜잭션 Tx에 따른 처리, Tx에 따른 처리는 Ty의 성공적인 결과가 발생할 것으로 알려질 때까지 가능한 한 오랫동안 활성 상태를 유지해야 합니다. Ty가 실패하면 Tx에 따른 처리는 물론 평소대로 계속됩니다. Ty에 의해 발생한 모든 변경 사항은 Ty가 커밋될 때 논리적으로 적용됩니다. 따라서 Ty가 커밋할 때 엔드포인트가 알림 상태에 있었고 Ty가 알림 요청을 포함했다면 Ty가 커밋할 때 엔드포인트는 알림 상태에서 벗어납니다. 이는 Ty가 시작되었을 때 엔드포인트가 알림 상태에 있었는지 여부와 무관합니다. 예를 들어 Ty의 시작과 커밋 사이의 Tx에 따른 처리로 인해 Notify가 생성될 수 있습니다. Ty 커밋으로 인해 엔드포인트가 알림 상태로 전환되는 경우 알림 상태를 종료하려면 새 알림 요청\(Tz\)이 필요합니다. 이는 트랜잭션 실행이 인과적 순서를 존중한다는 사실에서 비롯됩니다.\(SHOULD\)

또 다른 관련 문제는 와일드카드, 특히 둘 이상의 엔드포인트와 일치할 수 있는 "모두" 와일드카드를 사용하는 것입니다. 명령이 요청되고 엔드포인트 식별자가 둘 이상의 엔드포인트와 일치하는 경우 트랜잭션 의미 체계가 계속 적용됩니다. 따라서 명령은 모든 엔드포인트에 대해 성공해야 하거나 모든 엔드포인트에 대해 실패해야 합니다\(MUST\). 결과적으로 항상 단일 응답이 발행됩니다.\(MUST\)

---
### **4.4.4 Ordering of Commands, and Treatment of Misorder**

MGCP는 기본 전송 프로토콜이 게이트웨이나 엔드포인트에 대한 명령의 순차적 전달을 보장하도록 요구하지 않습니다. 이 속성은 작업의 적시성을 극대화하는 경향이 있지만 몇 가지 단점이 있습니다. 예를 들어:

\* 알림 명령은 새로운 알림 요청 명령 전송 후 지연되어 Call Agent에 도착할 수 있으며,

\* 이전 알림 요청이 승인되기 전에 새 알림 요청이 전송되는 경우 새 알림 이후에 이전 알림이 수신되어 실행되지 않는다는 보장은 없습니다.

엔드포인트의 일관된 작동을 보장하려는 통화 상담원은 다음 규칙을 사용할 수 있습니다.

1\) 게이트웨이가 여러 엔드포인트를 처리하는 경우 서로 다른 엔드포인트에 관련된 명령이 병렬로 전송될 수 있습니다. 예를 들어 각 엔드포인트가 자체 프로세스 또는 자체 스레드에 의해 제어되는 모델을 따르면 됩니다.

2\) 동일한 엔드포인트에 여러 개의 연결이 생성되면 서로 다른 연결에 관련된 명령을 병렬로 보낼 수 있습니다.

3\) 주어진 연결에는 일반적으로 하나만 있어야 합니다.

- 뛰어난 명령\(생성 또는 수정\). 그러나 언제든지 DeleteConnection 명령을 실행할 수 있습니다. 결과적으로 게이트웨이는 이전에 삭제된 연결에 적용되는 ModifyConnection 명령을 수신할 수도 있습니다. 이러한 명령은 실패하며 오류 코드가 반환되어야 합니다\(오류 코드 515 - 잘못된 연결 ID, 권장\).\(MUST\)

4\) 특정 엔드포인트에는 일반적으로 언제든지 미해결 알림 요청 명령이 하나만 있어야 합니다. RequestId 매개변수는 알림 명령을 트리거 알림 요청과 연관시키는 데 사용해야 합니다.\(MUST\)

5\) 어떤 경우에는 암시적 또는 명시적으로 와일드카드가 사용됩니다.

- 끝점 그룹에 적용되는 DeleteConnection 명령은 보류 중인 CreateConnection 명령보다 먼저 진행될 수 있습니다. 통화 에이전트는 전역 DeleteConnection 명령 시 완료가 보류 중인 모든 연결을 개별적으로 삭제해야 합니다. 또한 와일드카드로 명명된 끝점에 대한 새 CreateConnection 명령은 와일드카드 DeleteConnection 명령이 승인될 때까지 전송되어서는 안 됩니다.\(SHOULD NOT\)

6\) 명령어들이 서로 내장되어 있을 때, 시퀀싱

- 모든 명령에 대한 요구 사항을 준수해야 합니다. 예를 들어 알림 요청이 포함된 연결 만들기 명령은 CreateConnection 및 알림 요청과 관련된 순서 요구 사항을 동시에 준수해야 합니다.

7\) AuditEndpoint 및 AuditConnection은 어떠한 영향도 받지 않습니다.

- 순서 요구 사항.

8\) RestartInProgress는 항상 재시작 절차에 정의된 대로 엔드포인트가 보낸 첫 번째 명령이어야 합니다. 감사에 대한 응답을 제외한 모든 다른 명령 또는 재시작하지 않는 응답\(섹션 4.4.6 참조\)은 이 RestartInProgress 명령\(피기백 허용\) 후에 전달되어야 합니다.\(MUST, MUST\)

9\) 여러 메시지가 하나의 패킷에 피기백되는 경우 메시지는 항상 순서대로 처리됩니다.

10\) 특정 엔드포인트에는 일반적으로 하나만 있어야 합니다.

- 언제든지 뛰어난 EndpointConfiguration 명령.

게이트웨이는 통화 상담원이 이러한 규칙을 따르는지 여부에 대해 어떤 가정도 해서는 안 됩니다. 결과적으로 게이트웨이는 위 규칙을 준수하는지 여부에 관계없이 항상 명령에 응답해야 합니다. 일관된 작동을 보장하기 위해 게이트웨이는 위 규칙 중 하나 이상이 따르지 않을 때 아래 지정된 대로 동작해야 합니다.\(MUST NOT, MUST, SHOULD\)

\* 단일 미해결 명령\(ModifyConnection, NotifyRequest 및 EndpointConfiguration\)이 예상되지만 이전 트랜잭션의 실행이 완료되기 전에 동일한 명령이 새 트랜잭션에서 수신되는 경우 게이트웨이는 이전 명령을 실패해야 합니다\(SHOULD\). 여기에는 하나 이상의 명령이 캡슐화된 경우가 포함됩니다. 오류 코드 407\(트랜잭션 중단됨\)을 사용하는 것이 좋습니다.\(SHOULD, SHOULD\)

\* 보류 중인 CreateConnection 명령에 대해 ModifyConnection 명령이 수신되면 ModifyConnection 명령은 단순히 거부되어야 합니다. 오류 코드 400\(일시적 오류\)을 사용하는 것이 좋습니다. 이 상황은 통화 에이전트 프로그래밍 오류를 구성합니다.\(SHOULD, SHOULD\)

\* 보류 중인 CreateConnection 또는 ModifyConnection 명령에 대해 DeleteConnection 명령이 수신되면 보류 중인 명령을 중단해야 합니다. 오류 코드 407\(트랜잭션 중단됨\)을 사용하는 것이 좋습니다.\(MUST, SHOULD\)

새 명령을 수신하면 이전 명령이 중단되는 경우 새 명령의 성공 여부에 관계없이 이전 명령을 중단해야 합니다. 예를 들어, 캡슐화된 알림 요청으로 인해 자체적으로 실패하는 DeleteConnection 명령에 의해 ModifyConnection 명령이 중단된 경우 ModifyConnection 명령은 계속 중단됩니다.\(SHOULD\)

---
### **4.4.5 Endpoint Service States**

앞에서 설명한 대로 작동하도록 구성된 엔드포인트는 서비스 중이거나 서비스가 중단된 상태일 수 있습니다. 엔드포인트의 실제 서비스 상태는 RestartInProgress 명령\(섹션 2.3.12\)과 함께 전송되고 더 나아가 AuditEndpoint 명령\(섹션 2.3.10\)에서 감사될 수 있는 RestartMethod 및 RestartDelay 매개 변수의 조합에 의해 반영됩니다.

엔드포인트의 서비스 상태는 명령을 처리하는 방법에 영향을 미칩니다. 서비스 중인 엔드포인트는 수신된 모든 명령을 처리해야 하며\(MUST\), 서비스 외부인 엔드포인트는 비감사 명령을 거부해야 하지만 가능하다면 감사 명령을 처리해야 합니다\(SHOULD\). 이전 버전과의 호환성을 위해 서비스 중단 끝점에 대한 감사 명령도 거부될 수도 있습니다. 서비스가 중단된 엔드포인트로 인해 거부된 모든 명령은 오류 코드 501\(엔드포인트가 준비되지 않음/서비스가 중단됨\)을 생성해야 합니다.\(MUST, SHOULD\)

\(섹션 2.1.2에 따라\) 명령에 대해 달리 지정하지 않는 한 "다음 중 하나" 와일드카드가 포함된 엔드포인트 이름은 서비스 중인 엔드포인트만 참조하는 반면, "모두" 와일드카드가 포함된 엔드포인트 이름은 관계없이 모든 엔드포인트를 참조합니다. 서비스 상태.

위의 관계는 전송된 RestartInProgress 명령과 그에 대해 수신된 응답\(있는 경우\)의 함수로서 명령의 현재 서비스 상태 및 게이트웨이 처리를 보여주는 아래 표에 설명되어 있습니다. 마지막 열에는 감사 시 반환될 RestartMethod도 괄호 안에 나열되어 있습니다.

```text
    ------------------------------------------------------------------
   | Restart-  | Restart- |    2xx    | Service- |   Response to      |
   |    Method |    Delay | received ?|    State |   new command      |
   |------------------------------------------------------------------|
   | graceful  |   zero   |   Yes/No  |   In     | non-audit: 2xx     |
   |           |          |           |          | audit:     2xx     |
   |           |          |           |          |        (graceful)  |
   |-----------+----------+-----------+----------+--------------------|
   | graceful  | non-zero |   Yes/No  |   In*    | non-audit: 2xx     |
   |           |          |           |          | audit:     2xx     |
   |           |          |           |          |        (graceful)  |
   |-----------+----------+-----------+----------+--------------------|
   | forced    |   N/A    |   Yes/No  |   Out    | non-audit: 501     |
   |           |          |           |          | audit:     2xx     |
   |           |          |           |          |         (forced)   |
   |-----------+----------+-----------+----------+--------------------|
   | restart   |   zero   |    No     |   In     | non-audit: 2xx,405*|
   |           |          |           |          | audit:     2xx     |
   |           |          |           |          |         (restart)  |
   |-----------+----------+-----------+----------+--------------------|
   | restart   |   zero   |    Yes    |   In     | non-audit: 2xx     |
   |           |          |           |          | audit:     2xx     |
   |           |          |           |          |         (restart)  |
   |-----------+----------+-----------+----------+--------------------|
   | restart   | non-zero |    No     |   Out*   | non-audit: 501*    |
   |           |          |           |          | audit:     2xx     |
   |           |          |           |          |         (restart)  |
   |-----------+----------+-----------+----------+--------------------|
   | restart   | non-zero |    Yes    |   Out*   | non-audit: 501*    |
   |           |          |           |          | audit:     2xx     |
   |           |          |           |          |         (restart)  |
   |-----------+----------+-----------+----------+--------------------|
   | discon-   |   zero/  |    No     |   In     | non-audit: 2xx,    |
   |    nected | non-zero |           |          | audit:     2xx     |
   |           |          |           |          |      (disconnected)|
   |-----------+----------+-----------+----------+--------------------|
   | discon-   |   zero/  |    Yes    |   In     | non-audit: 2xx     |
   |    nected | non-zero |           |          | audit:     2xx     |
   |           |          |           |          |         (restart)  |
   |-----------+----------+-----------+----------+--------------------|
   | cancel-   |   N/A    |   Yes/No  |   In     | non-audit: 2xx     |
   |  graceful |          |           |          | audit:     2xx     |
   |           |          |           |          |         (restart)  |
    ------------------------------------------------------------------

   Notes (*):
```

\* "\*"로 표시된 세 가지 서비스 상태는 업데이트된 RestartInProgress 명령이 전송되어야 하는 RestartDelay가 만료된 후에 변경됩니다.\(SHOULD\)

\* 재시작 절차가 아직 완료되지 않았을 때 엔드포인트가 2xx를 반환하는 경우 순서대로 전달이 여전히 충족되어야 합니다. 즉, 피기백이 사용됩니다. 대신 명령이 처리되지 않으면 405가 반환되어야 합니다.\(MUST, SHOULD\)

\* RestartDelay가 0이 아닌 "재시작" RestartInProgress 이후에는 엔드포인트가 서비스를 개시할 때까지, 즉 RestartDelay가 만료될 때까지만 오류 코드 501이 반환됩니다.

---
### **4.4.6 Fighting the Restart Avalanche**

다수의 게이트웨이에 동시에 전원이 공급된다고 가정해 보겠습니다. RestartInProgress 트랜잭션을 모두 시작한다면 호출 에이전트가 쇄도하여 서비스 복원의 중요한 기간 동안 메시지 손실과 네트워크 정체로 이어질 가능성이 높습니다. 이러한 눈사태를 방지하려면 다음 동작이 필요합니다.\(MUST\)

1\) 게이트웨이의 전원이 켜지면 0과 최대 대기 지연\(MWD\) 사이에 균일하게 분포된 임의의 값으로 재시작 타이머를 시작해야 합니다. 동일한 알고리즘을 사용하는 여러 게이트웨이 간의 난수 생성이 동시에 발생하지 않도록 주의해야 합니다.\(MUST\)

2\) 그런 다음 게이트웨이는 이 타이머가 끝나거나 통화 에이전트로부터 명령이 수신되거나 주거용 게이트웨이의 오프훅 전환과 같은 로컬 사용자 활동이 감지될 때까지 기다려야 합니다.\(MUST\)

3\) 타이머가 경과하거나 명령이 수신되거나 활동이 감지되면 게이트웨이는 재시작 절차를 시작해야 합니다.\(MUST\)

다시 시작 절차를 수행하려면 엔드포인트가 첫 번째 오류를 보장해야 합니다.

```text
   * non-audit command, or
```

\* 비감사 명령에 대한 비다시 시작 응답\(예: 405, 501 및 520 이외의 오류 코드\)

통화 에이전트가 이 끝점에서 보는 것은 "다시 시작" RestartInProgress 명령입니다. 엔드포인트는 이를 달성하기 위해 피기백\(piggybacking\)을 최대한 활용할 수 있습니다. 서비스 중인 것으로 간주되는 엔드포인트는 RestartMethod가 "restart"인 반면, 서비스가 중단된 것으로 간주되는 엔드포인트는 RestartMethod가 "forced"입니다\(섹션 4.4.5 참조\). 아직 재시작 절차를 완료하지 않은 엔드포인트로 인해 거부된 명령은 오류 코드 405\(엔드포인트 "재시작"\)를 사용해야 합니다.\(SHOULD\)

성공 응답을 받으면 다시 시작 절차가 완료됩니다. 오류 응답이 수신되면 후속 동작은 문제의 오류 코드에 따라 달라집니다.

\* 오류 코드가 일시적인 오류\(4xx\)를 나타내는 경우 재시작 절차를 다시 시작해야 합니다\(새 트랜잭션으로\).\(MUST\)

\* 오류 코드가 521이면 엔드포인트가 리디렉션되고 다시 시작 절차가 \(새 트랜잭션으로\) 다시 시작되어야 합니다. 521 응답에는 재시작이 시작되는 "알림 엔터티"인 NotifiedEntity가 포함되어 있어야 합니다. NotifiedEntity가 포함되지 않은 경우 응답은 다른 영구 오류로 처리됩니다\(아래 참조\).\(MUST, MUST\)

\* 오류가 다른 영구 오류\(5xx\)이고 엔드포인트가 오류를 수정할 수 없는 경우 달리 지정하지 않는 한 엔드포인트는 더 이상 자체적으로 다시 시작 절차를 시작하지 않습니다\(재부팅/다시 시작될 때까지\). 엔드포인트에 대한 명령이 수신되면 엔드포인트는 다시 시작 절차를 다시 시작해야 합니다.\(MUST\)

RestartInProgress가 다시 시작하는 동안 수신된 명령에 대한 응답\(R\)과 함께 피기백되는 경우 RestartInProgress의 재전송에는 응답 R의 피기백이 필요하지 않습니다. 그러나 엔드포인트가 다시 시작되는 동안 응답 R의 재전송에는 필요하지 않습니다. 두 가지가 순서대로 전달되도록 RestartInProgress를 피기백합니다.

다시 시작 절차를 수행하는 동안 게이트웨이가 "연결 끊김" 상태에 들어가면 절차 중에 "연결 끊김" 메시지가 아닌 "다시 시작"이 전송된다는 점을 제외하고 섹션 4.4.7에 지정된 연결 끊김 절차를 수행해야 합니다.\(MUST\)

게이트웨이의 각 엔드포인트에는 초기 재시작 메시지를 전달할 프로비저닝 가능한 통화 에이전트\(예: "알림 엔터티"\)가 있습니다. 게이트웨이의 엔드포인트 컬렉션이 둘 이상의 통화 에이전트에 의해 관리되는 경우 지정된 통화 에이전트에 의해 관리되는 각 엔드포인트 컬렉션에 대해 위 절차를 수행해야 합니다. 게이트웨이는 와일드카드를 최대한 활용하여\(MUST, MUST\)

게이트웨이의 여러 엔드포인트가 다시 시작되고 해당 엔드포인트가 동일한 통화 에이전트에 의해 관리될 때 생성되는 RestartInProgress 메시지 수입니다. 시작하는 동안 엔드포인트가 서비스가 중단된 상태로 시작된 다음 게이트웨이 초기화 절차의 일부로 서비스가 중단될 수 있습니다. 따라서 게이트웨이는 먼저 모든 엔드포인트에 대해 "강제" RestartInProgress를 전송하고 이어서 서비스 중인 엔드포인트에 대해 "재시작" RestartInProgress를 전송하도록 선택할 수 있습니다. 또는 게이트웨이는 서비스 중인 엔드포인트에 대해서만 "다시 시작" RestartInProgress를 보내고 서비스가 중단된 특정 엔드포인트에 대해서는 RestartInProgress를 "강제"할 수 있습니다. 그래도 전송되는 메시지 수를 최소화하려면 와일드카드를 사용해야 합니다.\(MUST\)

MWD 값은 게이트웨이 유형에 따라 달라지는 구성 매개변수입니다. 주거용 게이트웨이의 지연 값을 결정하기 위해 다음 추론을 사용할 수 있습니다.

통화 상담원은 일반적으로 피크 시간 트래픽 부하를 처리하도록 구성되며, 이 기간 동안 평균 10%의 회선이 통화 중이며 평균 지속 시간은 일반적으로 3분입니다. 통화 처리에는 일반적으로 각 엔드포인트와 통화 에이전트 사이에 5\~6개의 MGCP 트랜잭션이 포함됩니다. 이 간단한 계산은 통화 에이전트가 평균 30분마다 각 엔드포인트에 대해 5\~6개의 트랜잭션을 처리하거나, 다르게 말하면 평균 5\~6분마다 엔드포인트당 약 1개의 트랜잭션을 처리할 것으로 예상된다는 것을 보여줍니다. 이는 주거용 게이트웨이에 대한 합리적인 MWD 값이 10\~12분임을 시사합니다. 명시적인 구성이 없는 경우 주거용 게이트웨이는 MWD에 대해 600초 값을 채택해야 합니다.

동일한 추론에 따르면 트렁킹 게이트웨이나 비즈니스 게이트웨이의 경우 MWD의 값이 훨씬 짧아야 합니다. 이는 이들이 많은 수의 엔드포인트를 처리하고 또한 이러한 엔드포인트의 사용률이 피크 최번시 동안 10%보다 훨씬 높기 때문입니다. , 일반적인 값은 60%입니다. 따라서 피크 시간 동안 이러한 엔드포인트는 통화 에이전트 로드에 분당 약 1개의 트랜잭션을 기여할 것으로 예상됩니다. 합리적인 알고리즘은 "트렁크" 엔드포인트당 MWD 값을 주거용 게이트웨이당 MWD보다 6배 짧게 만들고 다시 시작되는 엔드포인트 수에 반비례하도록 만드는 것입니다. 예를 들어 T1 회선을 처리하는 게이트웨이의 경우 MWD를 2.5초로 설정해야 하고, T3 회선을 처리하는 게이트웨이의 경우 60밀리초로 설정해야 합니다.

---
### **4.4.7 Disconnected Endpoints**

재시작 절차 외에도 게이트웨이에는 섹션 4.3에 설명된 대로 엔드포인트가 "연결 해제"될 때 시작되어야 하는 "연결 해제" 절차도 있습니다. 엔드포인트는 통화 에이전트와 통신을 시도할 때만 연결이 끊어질 수 있다는 점에 유의해야 합니다. 다음 단계는 반드시 "연결이 끊어진" 엔드포인트가 뒤따라야 합니다.\(MUST, MUST\)

1. "연결 해제된" 타이머는 1과 프로비저닝 가능한 "연결 해제된" 초기 대기 지연\(Tdinit\)\(예: 15초\) 사이에 균일하게 분포된 임의의 값으로 초기화됩니다. 동일한 알고리즘을 사용하는 여러 게이트웨이와 엔드포인트 간의 난수 생성이 동기화되지 않도록 주의해야 합니다.\(MUST\)

2. 그런 다음 게이트웨이는 이 타이머가 끝나거나 통화 에이전트로부터 엔드포인트에 대한 명령이 수신되거나 엔드포인트에 대한 로컬 사용자 활동\(예: 오프 후크 전환\)이 감지될 때까지 기다립니다.

3. 엔드포인트에 대해 "연결 끊김" 타이머가 경과하거나 엔드포인트에 대한 명령이 수신되거나 엔드포인트에 대한 로컬 사용자 활동이 감지되면 게이트웨이는 엔드포인트에 대해 "연결 끊김" 절차를 시작합니다. 끝점에 대해 이미 진행 중인 경우 단순히 새 끝점으로 대체됩니다. 또한 로컬 사용자 활동의 경우 프로시저가 실행되는 속도를 제한하기 위해 엔드포인트가 연결 해제되었거나 마지막으로 "연결 해제" 절차를 종료한 이후 프로비저닝 가능한 "연결 해제된" 최소 대기 지연\(Tdmin\)이 경과되어야 합니다. 수행됩니다. Tdmin이 통과하지 못한 경우 엔드포인트는 이미 진행 중인 연결 해제 절차에 영향을 주지 않고 단순히 2단계로 다시 진행합니다.\(MUST\)

4. "연결 끊김" 프로시저가 여전히 엔드포인트를 벗어나는 경우

- 연결이 끊어지면 "연결이 끊어진" 타이머는 프로비저닝 가능한 "연결이 끊긴" 최대 대기 지연\(Tdmax\)\(예: 600초\)에 따라 두 배로 늘어나고 게이트웨이는 2단계를 다시 진행합니다\(새 트랜잭션 ID를 사용하여\).

```text
   The "disconnected" procedure is similar to the restart procedure in
   that it simply states that the endpoint MUST send a RestartInProgress
   command to the Call Agent informing it that the endpoint was
   disconnected.  Furthermore, the endpoint MUST guarantee that the
   first non-audit message (non-audit command or response to non-audit
   command) that the Call Agent sees from this endpoint MUST inform the
   Call Agent that the endpoint is disconnected (unless the endpoint
   goes out-of-service).  When a command (C) is received, this is
   achieved by sending a piggy-backed datagram with a "disconnected"
```

RestartInProgress 명령과 현재 "통지된 엔터티"가 아닌 명령 C의 소스 주소에 대한 명령 C에 대한 응답입니다. 이 피기백된 RestartInProgress는 엔드포인트에 의해 자동으로 재전송되지 않고 단순히 피기백된 응답과의 운명 공유에 의존하여 순서대로 전달 요구 사항을 보장합니다. 통화 에이전트는 여전히 피기백된 RestartInProgress에 응답을 보내지만 평소와 같이 응답이 손실될 수 있습니다. 피기백된 RestartInProgress 명령 외에도 수신된 명령에 의해 새로운 "연결 끊김" 절차가 트리거됩니다. 이로 인해 "연결이 끊긴" RestartInProgress 명령의 피기백되지 않은 복사본\(즉, 동일한 트랜잭션\)이 현재 "통지된 엔터티"에 안정적으로 전송됩니다.

통화 에이전트가 엔드포인트의 연결이 끊어졌다는 사실을 알게 되면 예를 들어 통화 에이전트는 엔드포인트를 감사하기로 결정하거나 간단히 엔드포인트에 대한 모든 연결을 삭제할 수 있습니다. 이러한 "연결이 끊긴" 각 절차는 새로운 RestartInProgress 명령을 생성하며, 이는 섹션 4.3에 지정된 일반적인 재전송 절차의 적용을 받습니다. 절차가 끝나면 끝점은 여전히 ​​"연결이 끊어진" 상태일 수 있습니다. 연결이 끊어진 동안 엔드포인트가 서비스를 벗어나면 섹션 2.3.12에 설명된 대로 "강제" RestartInProgress 메시지를 보내야 합니다.\(SHOULD\)

연결 끊김 절차는 성공 응답이 수신되면 완료됩니다. 오류 응답은 재시작 절차\(섹션 4.4.6\)와 유사하게 처리됩니다. 오류 응답 후 "연결 끊김" 절차가 다시 시작되는 경우 위에 지정된 속도 제한 타이머 고려 사항이 계속 적용됩니다.

RestartInProgress가 연결이 끊어진 동안 수신된 명령에 대한 응답\(R\)과 함께 피기백되는 경우 이 특정 RestartInProgress의 재전송에는 응답 R의 피기백이 필요하지 않습니다. 그러나 엔드포인트의 연결이 끊어진 동안 응답 R을 다시 보내면 RestartInProgress가 응답과 함께 피기백되어 두 항목이 순서대로 전달되도록 해야 합니다.

연결이 끊긴 엔드포인트 집합이 동일한 "통지된 엔터티"를 갖고 엔드포인트 집합에 와일드카드로 이름을 지정할 수 있는 경우 게이트웨이는 개별 연결이 끊긴 프로시저를 적절하게 와일드카드로 연결된 연결이 끊긴 프로시저로 대체할 수 있습니다. 이 경우 와일드카드 "연결 끊김" RestartInProgress 명령에 대한 재시작 지연은 교체된 가장 오래된 연결 끊김 프로시저에 해당하는 재시작 지연이어야 합니다. 나중에 이러한 엔드포인트의 하위 집합만 해당 "알림 엔터티"가 변경되거나 더 이상 연결이 끊어지지 않으면 해당 와일드카드 연결 끊김 절차를 더 이상 사용할 수 없습니다. 그런 다음 나머지 개별 연결 해제 절차를 다시 재개해야 합니다.\(MAY, MUST, MUST\)

연결이 끊어진 엔드포인트는 연결이 끊어진 동안 RestartInProgress 외에 명령을 보내려고 할 수 있습니다. 그렇게 하면 통화 에이전트에 다시 연결할 수 있게 된 후에만 성공할 수 있으며, 그 동안 해당 명령으로 무엇을 해야 할지에 대한 의문이 제기됩니다. 극단적인 경우에는 엔드포인트가 명령을 즉시 삭제할 수 있지만 호출 에이전트가 실제로 사용 가능하고 엔드포인트가 아직 "연결 끊김" 절차를 완료하지 않은 경우에는 제대로 작동하지 않습니다\(예를 들어,NotificationRequest가 방금 수신되었으며 즉시 알림이 생성되었습니다\). 이러한 시나리오를 방지하기 위해 연결이 끊긴 엔드포인트는 비감사 명령을 받은 후 T-MAX 초 동안 전송될 새 명령을 맹목적으로 삭제해서는 안 됩니다.\(MUST NOT\)

이 요구 사항을 충족하는 한 가지 방법은 전송될 명령의 임시 버퍼링을 사용하는 것입니다. 그러나 그렇게 하는 경우 엔드포인트는 다음을 보장해야 합니다.\(MUST\)

\* 보낼 명령의 긴 대기열을 만들지 않습니다.

\*는 다시 연결되면 너무 많은 명령을 빠르게 전송하여 통화 에이전트를 압도하지 않습니다.

T-MAX 초 동안 명령을 버퍼링하고 엔드포인트가 다시 연결되면 버퍼링된 명령이 엔드포인트당 하나의 미해결 명령으로 전송되는 속도를 제한하는 것이 허용 가능한 것으로 간주됩니다\(특히 와일드카드를 사용하는 경우 섹션 4.4.8 참조\). 엔드포인트가 T-MAX 초 내에 연결되지 않았지만 "연결 끊김" 절차가 T-MAX 초 내에 시작되면 엔드포인트는 해당 RestartInProgress를 사용하여 버퍼링된 명령을 피기백할 수 있습니다. 명령이 전송되면 처음에 버퍼링되었는지 또는 이전에 피기백되었는지에 관계없이 해당 명령의 재전송은 섹션 4.3에 설명된 대로 초기 전송 후 T-MAX 초 후에 중단되어야 합니다.\(MAY, MUST\)

이 사양은 의도적으로 연결이 끊긴 끝점에 대한 추가 동작을 지정하지 않습니다. 예를 들어 공급업체는 무음 제공, 재주문 신호음 재생, 다운로드한 wav 파일 재생 활성화 등을 선택할 수 있습니다.\(MAY\)

Tdinit의 기본값은 15초, Tdmin의 기본값은 15초, Tdmax의 기본값은 600초입니다.

---
### **4.4.8 Load Control in General**

이전 섹션에서는 혼잡과 과부하를 처리하기 위한 여러 MGCP 메커니즘을 설명했습니다.

\* 엔드포인트별로 네트워크 및 통화 에이전트 정체에 적응하는 UDP 재전송 전략,

\* 병렬로 실행되는 명령의 수를 제한하는 명령 순서에 대한 지침,

\* 재가동 눈사태 발생 시 홍수를 방지하는 재가동 절차

\* 연결이 끊긴 엔드포인트 수가 많은 경우 플러딩을 방지하는 연결 끊김 절차.

그러나 동일하거나 다른 게이트웨이에 있는 특정 엔드포인트 세트가 특정 시점에 하나 이상의 명령을 발행하는 것은 여전히 ​​가능합니다. 통화 에이전트는 특정 시점에 서비스된 엔드포인트당 하나의 메시지를 처리할 수 있도록 크기를 조정해야 한다고 주장할 수 있지만 실제로는 항상 그런 것은 아닙니다. 마찬가지로 게이트웨이는 특정 시점에 모든 엔드포인트에 대한 메시지를 처리하지 못할 수도 있습니다. 일반적으로 이러한 문제는 신용 기반 메커니즘을 사용하거나 관찰된 행동을 모니터링하고 자동으로 조정하여 처리할 수 있습니다. 우리는 다음과 같이 후자의 접근 방식을 선택합니다.

개념적으로 우리는 통화 에이전트와 게이트웨이가 실행될 들어오는 트랜잭션의 대기열을 유지한다고 가정합니다. 이 트랜잭션 큐와 연관된 것은 최고 수위 표시와 최저 수위 표시입니다. 대기열 길이가 최고 수위 표시에 도달하면 엔터티는 대기열 길이가 최저 수위 표시로 떨어질 때까지 101개의 임시 응답\(트랜잭션 대기열에 있음\) 발행을 시작해야 합니다. 이는 재전송뿐만 아니라 새로운 트랜잭션에도 적용됩니다. 엔터티가 현재 새로운 트랜잭션을 처리할 수 없는 경우 오류 코드 409\(처리 과부하\)를 반환해야 합니다.\(SHOULD, SHOULD\)

또한 게이트웨이는 해당 호출 에이전트에서 엔드포인트 \*세트\*에 대해 관찰된 응답 시간을 모니터링하여 지정된 호출 에이전트에 대한 새 명령의 전송 속도를 조정해야 합니다. 관찰된 평탄화 평균 응답 시간이 갑자기 일부 임계값을 크게 초과하거나 게이트웨이가 101\(트랜잭션 대기\) 또는 409\(과부하\) 응답을 수신하는 경우 게이트웨이는 그에 따라 해당 호출 에이전트에 대한 새 명령의 전송 속도를 조정해야 합니다. 평활 평균 알고리즘, 속도 조정 및 관련된 임계값의 세부 사항은 추가 연구를 위한 것이지만 구성 가능해야 합니다.\(SHOULD, SHOULD, MUST\)

마찬가지로 통화 에이전트는 엔드포인트 \*세트\*에 대해 해당 게이트웨이에서 관찰된 응답 시간을 모니터링하여 특정 게이트웨이에 대한 새 트랜잭션의 전송 속도를 조정해야 합니다. 관찰된 평탄화된 평균 응답 시간이 갑자기 일부 임계값을 크게 초과하거나 호출 에이전트가 101\(트랜잭션 대기열에 있음\) 또는 409\(오버로드됨\)를 수신하는 경우 호출 에이전트는 이에 따라 해당 게이트웨이에 대한 새 명령의 전송 속도를 조정해야 합니다. 평활 평균 알고리즘, 속도 조정 및 관련된 임계값의 세부 사항은 추가 연구를 위한 것이지만 구성 가능해야 합니다.\(SHOULD, SHOULD, MUST\)

---
## **5. Security Requirements**

모든 엔터티는 MGCP 엔드포인트에 명령을 보낼 수 있습니다. 승인되지 않은 개체가 MGCP를 사용할 수 있는 경우 승인되지 않은 통화를 설정하거나 승인된 통화를 방해할 수 있습니다. 우리는 MGCP 메시지가 RFC 2402에 정의된 IP 인증 헤더 또는 RFC 2406에 정의된 IP 캡슐화 보안 페이로드를 사용하여 RFC 2401에 정의된 IP 보안 아키텍처에 정의된 대로 보안 인터넷 연결을 통해 항상 전달될 것으로 기대합니다. 따라서 전체 MGCP 프로토콜 스택에는 다음 계층이 포함됩니다.

```text
                -------------------------------
               |              MGCP             |
               |-------------------------------|
               |              UDP              |
               |-------------------------------|
               |          IP security          |
               | (authentication or encryption)|
               |-------------------------------|
               |              IP               |
               |-------------------------------|
               |       transmission media      |
                -------------------------------
```

게이트웨이와 통화 에이전트가 IP 보안이 인증 서비스를 제공한 메시지만 수락하는 경우 연결이 적절하게 보호됩니다. 암호화 서비스는 도청에 대한 추가 보호 기능을 제공하여 제3자가 특정 엔드포인트에서 설정된 연결을 모니터링하는 것을 방지합니다.

SDP에 정의된 대로 세션 설명을 사용하여 세션 키를 전달하는 경우에도 암호화 서비스가 요청됩니다.

이러한 절차는 오작동하는 게이트웨이나 오작동하는 통화 에이전트에 의한 서비스 거부 공격으로부터 반드시 보호하지는 않습니다. 그러나 이러한 오작동하는 엔터티에 대한 식별 정보를 제공하며 유지 관리 절차를 통해 해당 엔터티의 승인을 박탈해야 합니다.

---
## **5.1 Protection of Media Connections**

MGCP를 사용하면 통화 에이전트가 오디오 메시지를 암호화하여 도청을 방지하는 데 사용할 수 있는 "세션 키"를 게이트웨이에 제공할 수 있습니다.

패킷 네트워크의 특정 문제는 "통제되지 않은 참여"입니다. 이 공격은 미디어 패킷을 연결에 사용되는 IP 주소와 UDP 포트로 전달하여 수행될 수 있습니다. 보호 기능이 구현되지 않으면 패킷이 디코딩되고 신호가 "회선 측"에서 재생됩니다.

이 공격에 대한 기본 보호는 알려진 소스의 패킷만 허용하는 것이지만 이는 RTP 원칙과 충돌하는 경향이 있습니다. 여기에는 두 가지 불편한 점도 있습니다. 연결 설정 속도가 느려지고 소스 스푸핑에 속을 수 있습니다.

\* 주소 기반 보호를 활성화하려면 통화 에이전트가 송신 게이트웨이의 소스 주소를 가져와 수신 게이트웨이에 전달해야 합니다. 이를 위해서는 최소한 한 번의 네트워크 왕복이 필요하며 딜레마에 빠지게 됩니다. 왕복이 완료될 때까지 기다리지 않고 통화가 진행되도록 허용하거나 원격 알림을 "클리핑"하는 등의 위험이 있거나 전체 왕복을 기다리고 느린 통화 설정 절차에 만족하십시오.

\* 소스 스푸핑은 공격자가 트래픽의 일부를 수신하여 소스 및 대상 주소와 포트의 유효한 쌍을 얻을 수 있는 경우에만 효과적입니다. 소스 스푸핑에 맞서기 위해 네트워크에 대한 모든 액세스 포인트를 제어할 수 있습니다. 그러나 이는 실제로 달성하기가 매우 어렵습니다.

소스 주소를 확인하는 대신 통화 설정 절차 중에 전달되는 비밀 키를 사용하여 패킷을 암호화하고 인증하는 것입니다. 이렇게 하면 통화 설정 속도가 느려지지 않으며 주소 스푸핑에 대한 강력한 보호 기능을 제공합니다.

---
## **6. Packages**

섹션 2.1.6에 설명된 대로 패키지는 MGCP를 확장하는 데 선호되는 방법입니다. 이 섹션에서는 패키지 정의와 관련된 요구 사항을 설명합니다.

패키지에는 고유한 패키지 이름이 정의되어 있어야 합니다. 패키지 이름은 실험용 패키지용으로 예약된 "x-" 또는 "x+" 문자로 시작하지 않는 한 IANA에 등록되어야 합니다. IANA 고려 사항은 부록 C를 참조하세요.\(MUST, MUST\)

패키지에는 단순히 음수가 아닌 정수인 버전이 정의되어 있어야 합니다. 패키지의 기본 및 초기 버전은 0이고 다음 버전은 1입니다. 새 패키지 버전은 이전 버전과 완전히 호환되어야 합니다. 즉, 패키지의 새 버전은 이전 버전에 제공된 확장을 재정의하거나 제거해서는 안 됩니다. 패키지의. 그러한 필요성이 발생하면 대신 새 패키지 이름을 사용해야 합니다.\(MUST, MUST NOT, MUST\)

시간 초과 유형의 신호를 포함하는 패키지는 패키지의 모든 시간 초과 신호에 대해 "to" 매개변수가 지원되는지 여부와 이와 관련된 기본 반올림 규칙을 나타낼 수 있습니다\(섹션 3.2.2.4 참조\). 그러한 정의가 제공되지 않으면 각 타임아웃 신호는 이러한 정의를 제공해야 합니다.\(MAY, SHOULD\)

패키지는 다음 확장 중 하나 이상을 정의합니다.

```text
   * Actions

   * BearerInformation

   * ConnectionModes

   * ConnectionParameters

   * DigitMapLetters
```

\* 이벤트 및 신호

```text
   * ExtensionParameters

   * LocalConnectionOptions

   * ReasonCodes

   * RestartMethods

   * Return codes
```

패키지에서 지원하는 위의 확장 유형 각각에 대해 패키지 정의에는 다음 섹션에 정의된 확장에 대한 설명이 포함되어야 합니다. 다른 확장과 마찬가지로 패키지 확장도 MGCP 문법을 준수해야 합니다.\(MUST, MUST\)

---
## **6.1 Actions**

```text
   Extension Actions SHALL include:
```

\* 확장 작업의 이름과 인코딩입니다.

\* 확장 작업이 작업 매개변수를 취하는 경우 해당 매개변수의 이름, 인코딩 및 가능한 값.

\* 확장 액션의 동작에 대한 설명입니다.

\* 본 사양의 확장 기능과 결합할 수 있는 작업 목록입니다. 그러한 목록이 제공되지 않으면 확장 작업은 본 사양의 다른 작업과 결합될 수 없는 것으로 가정됩니다.

\* 패키지에 둘 이상의 확장 작업이 정의된 경우 확장과 결합될 수 있는 패키지의 작업 목록이 표시됩니다. 해당 목록이 제공되지 않는 경우 확장 작업은 패키지의 다른 작업과 결합될 수 없는 것으로 간주됩니다.

두 개 이상의 서로 다른 패키지에 정의된 확장 작업은 잠재적인 상호 작용과 부작용을 매우 신중하게 고려하지 않는 한 동시에 사용해서는 안 됩니다.\(SHOULD NOT\)

---
## **6.2 BearerInformation**

```text
   BearerInformation extensions SHALL include:
```

\* BearerInformation 확장의 이름과 인코딩.

\* BearerInformation 확장에 할당할 수 있는 가능한 값 및 해당 값의 인코딩입니다.

\* BearerInformation 확장 기능의 동작에 대한 설명입니다. 이 설명의 일부로 EndpointConfiguration 명령에서 확장이 생략된 경우 기본값\(있는 경우\)을 정의해야 합니다. 매개변수를 처음 적용하기 전과 후에 기본값을 구별해야 할 수도 있습니다. 예를 들어 매개변수가 명시적으로 변경될 때까지 매개변수가 지정된 후 이전 값을 유지하는 경우입니다. 기본값이 설명되지 않으면 모든 EndpointConfiguration 명령에서 확장 매개변수의 기본값은 비어 있습니다.\(MUST\)

확장은 BearerInformation을 감사하는 AuditEndpoint 명령의 결과에 포함되어야 합니다.\(MUST\)

---
## **6.3 ConnectionModes**

```text
   Extension Connection Modes SHALL include:
```

\* 확장 연결 모드의 이름과 인코딩입니다.

\* 확장 연결 모드 동작에 대한 설명입니다.

\* 확장 연결 모드의 연결이 본 사양에 정의된 각 모드의 다른 연결과 상호 작용에 대한 설명입니다. 그러한 설명이 제공되지 않으면 확장 연결 모드는 엔드포인트의 다른 연결과 상호 작용하면 안 됩니다.\(MUST NOT\)

확장 연결 모드는 기능에 대한 AuditEndpoint에 대한 응답의 모드 목록에 포함되어서는 안 됩니다. 패키지가 패키지 목록에 보고되기 때문입니다.\(MUST NOT\)

---
## **6.4 ConnectionParameters**

```text
   Extension Connection Parameters SHALL include:
```

\* 연결 매개변수 확장의 이름 및 인코딩.

\* 연결 매개변수 확장에 할당할 수 있는 가능한 값 및 해당 값의 인코딩입니다.

\* 해당 값이 어떻게 파생되는지에 대한 설명입니다.

확장 연결 매개변수는 연결 매개변수를 감사하는 AuditConnection 명령의 결과에 포함되어야 합니다.\(MUST\)

---
## **6.5 DigitMapLetters**

```text
   Extension Digit Map Letters SHALL include:
```

\* 확장 숫자 지도 문자의 이름과 인코딩입니다.

\* 확장자 자리표 문자의 의미에 대한 설명입니다.

숫자 지도의 확장 DigitMapLetters는 패키지에 정의된 확장에 대한 일반적인 명명 규칙을 따르지 않습니다. 보다 구체적으로 패키지 이름과 슬래시\("/"\)는 확장 이름의 일부가 아니므로 잠재적인 이름 충돌이 있는 단순하고 제한된 이름 공간을 형성합니다.

따라서 패키지는 인코딩이 이미 다른 패키지에서 사용된 숫자 지도 문자 확장을 정의해서는 안 됩니다. 두 패키지가 숫자 매핑 문자 확장에 대해 동일한 인코딩을 사용하고 해당 두 패키지가 동일한 끝점에서 지원되는 경우 해당 숫자 매핑 문자 확장을 사용한 결과는 정의되지 않습니다.\(MUST NOT\)

확장 DigitMapLetter에는 숫자 맵 내 확장 이름의 일부로 패키지 이름 접두사 및 슬래시\("/"\)가 포함되지 않지만 DigitMapLetter와 일치하는 이벤트에 대한 이벤트 코드가 있을 때 패키지 이름 접두사 및 슬래시가 포함됩니다. 관찰된 사건으로 보고됩니다. 즉, 숫자 맵은 일치 규칙만 정의하지만 이벤트는 여전히 다른 이벤트처럼 보고됩니다.

---
## **6.6 Events and Signals**

이벤트/신호 정의에는 이벤트/신호의 정확한 이름\(즉, MGCP에서 사용되는 코드\), 이벤트/신호의 일반 텍스트 정의, 그리고 적절한 경우 해당 이벤트/신호의 정확한 정의가 포함되어야 합니다. 예를 들어 발신음이나 DTMF 톤과 같은 오디오 신호의 정확한 주파수입니다.\(MUST\)

패키지 설명은 각 이벤트/신호에 대해 다음 정보를 제공해야 합니다.\(MUST\)

\* 이벤트/신호 및 그 목적에 대한 설명에는 클라이언트에서 생성된 실제 신호\(예: xxms FSK 톤\)와 사용자가 관찰한 결과\(예: 메시지 대기 표시등 켜기/끄기\)가 포함되어야 합니다. .\(SHOULD\)

이벤트/신호에 사용되는 이벤트 코드입니다.

\* 오디오 신호의 주파수 및 진폭, 변조 및 반복과 같은 이벤트/신호의 세부 특성. 이러한 세부정보는 국가마다 다를 수 있습니다.

\* 해당되는 경우 이벤트/신호의 일반적인 및 최대 지속 시간입니다.

\* 신호나 이벤트가 미디어 스트림을 통한 연결에 적용될 수 있는 경우 명시적으로 표시되어야 합니다. 그러한 표시가 제공되지 않으면 신호나 이벤트를 연결에 적용할 수 없는 것으로 간주됩니다.\(MUST\)

이벤트의 경우 다음 사항도 제공해야 합니다.\(MUST\)

\* 이벤트가 지속되는지 여부를 나타냅니다. 기본적으로 이벤트는 지속되지 않습니다. 이벤트를 지속성으로 정의하는 것은 권장되지 않습니다\(선호되는 대안은 부록 B 참조\). 끈질긴 점 참고하세요

통화 에이전트가 엔드포인트에 명시적으로 지시하지 않는 한, 이벤트는 발생 시 자동으로 알림을 트리거합니다. 이는 일반적인 MGCP 모델을 위반할 뿐만 아니라 통화 에이전트가 문제의 패키지를 지원한다고 가정합니다. 그러한 가정은 일반적으로 성립되지 않을 것입니다.

\* 이벤트와 연관된 감사 가능한 이벤트 상태가 있는지 여부를 나타냅니다. 기본적으로 이벤트에는 감사 가능한 이벤트 상태가 없습니다.

\* 이벤트 매개변수가 지원되는 경우 명시적으로 명시해야 합니다. 그런 다음 이들의 정확한 구문과 의미를 제공해야 합니다\(부록 A에 제공된 문법에 따라\). 또한 이러한 매개변수가 RequestedEvents, ObservedEvents, DetectEvents 및 EventStates에 적용되는지 여부도 지정해야 합니다. 별도로 지정하지 않으면 다음과 같이 가정됩니다.\(MUST, MUST, SHOULD\)

\* RequestedEvents에는 적용되지 않습니다.

\* ObservedEvents에 적용됩니다.

\* DetectEvents에도 같은 방식으로 적용됩니다.

- 특정 이벤트 매개변수에 대한 RequestedEvents,

\* EventStates에도 같은 방식으로 적용됩니다.

- 주어진 이벤트 매개변수에 대한 ObservedEvents.

\* 이벤트가 숫자 지도 일치에 사용될 것으로 예상되는 경우 이를 명시적으로 명시해야 합니다. 단일 문자 또는 숫자 매개변수 코드가 있는 이벤트만 이를 수행할 수 있습니다. 자세한 내용은 섹션 2.1.5를 참조하세요.\(SHOULD\)

신호의 경우 다음도 제공되어야 합니다.\(MUST\)

\* 신호 유형\(OO, TO, BR\).

\* 타임아웃 신호에는 기본 타임아웃 값이 표시되어야 합니다. 어떤 경우에는 시간 초과 값이 가변적일 수 있습니다\(숫자 출력 펄스와 같이 완료해야 할 일부 작업에 따라 달라지는 경우\).\(SHOULD\)

\* 신호 매개변수가 지원되는 경우 이를 명시적으로 명시해야 합니다. 그런 다음 이들의 정확한 구문과 의미를 제공해야 합니다\(부록 A에 제공된 문법에 따라\).\(MUST, MUST\)

```text
   * Time-Out signals may also indicate whether the "to" parameter is
     supported or not as well as what the rounding rules associated with
     them are.  If omitted from the signal definition, the package-wide
     definition is assumed (see Section 6).  If the package definition
     did not specify this, rounding rules default to the nearest non-
```

0초인 반면, "to" 매개변수에 대한 지원은 패키지 버전 0의 경우 기본적으로 "no"이고, 패키지 버전 1 이상에서는 "yes"입니다.

위의 내용에 따라 이벤트 및 신호를 정의하려면 다음 형식을 권장합니다.\(SHOULD\)

```text
    ------------------------------------------------------------------
   | Symbol  |   Definition               |  R  |   S     Duration    |
   |---------|----------------------------|-----|---------------------|
   |         |                            |     |                     |
   |         |                            |     |                     |
    ------------------------------------------------------------------

   where:
```

\* 기호는 이벤트/신호에 사용되는 이벤트 코드를 나타냅니다\(예: "hd"\).

\* 정의는 이벤트/신호에 대한 간략한 정의를 제공합니다.

\* R에는 이벤트가 감지될 수 있는 경우 "x"가 포함되거나 다음 기호 중 하나 이상이 포함됩니다.

- 이벤트가 지속되는 경우 "P"입니다.

- 이벤트가 감사될 수 있는 이벤트 상태인 경우 "S"입니다.

- 연결에서 이벤트를 감지할 수 있는 경우 "C"입니다.

\* S는 신호인 경우 다음 중 하나를 포함합니다.

- 신호가 On/Off 신호인 경우 "OO"입니다.

- 신호가 타임아웃 신호인 경우 "TO"입니다.

- 신호가 짧은 신호인 경우 "BR"입니다.

```text
   * S also contains:
```

- 연결에 신호를 적용할 수 있는 경우 "C"입니다.

그런 다음 테이블 뒤에는 정의된 각 이벤트/신호에 대한 보다 포괄적인 설명이 와야 합니다.\(SHOULD\)

---
### **6.6.1 Default and Reserved Events**

시간 초과 유형 신호를 포함하는 모든 패키지에는 패키지 설명의 일부로 제공되는지 여부에 관계없이 작업 실패\("of"\) 및 작업 완료\("oc"\) 이벤트가 포함되어 있습니다. 이러한 이벤트는 Time-Out 신호를 지원하는 데 필요하며 Time-Out 신호가 있는 패키지에서는 재정의될 수 없습니다. 필요한 경우 연장할 수 있지만 그러한 관행은 권장되지 않습니다.\(MAY\)

시간 초과 신호가 없는 패키지에 "oc" 및 "of" 이벤트에 대한 정의가 포함되어 있는 경우 패키지에 제공된 이벤트 정의가 여기에 표시된 정의보다 우선할 수 있습니다. 그러나 이러한 관행은 권장되지 않으며 잠재적인 이전 버전과의 호환성 문제를 피하기 위해서만 허용됩니다.\(MAY\)

두 이벤트는 다음과 같은 기본 정의에 따라 지원된다는 점을 명시적으로 언급하는 것이 좋습니다.

```text
    ------------------------------------------------------------------
   | Symbol  |   Definition               |  R  |   S     Duration    |
   |---------|----------------------------|-----|---------------------|
   | oc      | Operation Complete         |  x  |                     |
   | of      | Operation Failure          |  x  |                     |
    ------------------------------------------------------------------
```

작업 완료\(oc\): 작업 완료 이벤트는 게이트웨이가 엔드포인트 또는 연결에 TO 유형의 하나 이상의 신호를 적용하도록 요청받았을 때 생성되며 해당 신호 중 하나 이상이 요청된 이벤트 감지에 의해 중지되지 않고 완료되었습니다. 오프훅 전환이나 전화를 건 숫자 등. 완료 보고서는 다음과 같이 라이브 시간이 끝난 신호의 이름을 매개변수로 전달해야 합니다.

```text
      O: G/oc(G/rt)
```

이 경우 "G" 패키지의 "rt" 신호가 시간 초과되었기 때문에 관찰된 이벤트가 발생했습니다.

보고된 신호가 연결에 적용된 경우 제공된 매개변수에는 다음과 같이 연결 이름도 포함됩니다.

```text
      O: G/oc(G/rt@0A3F58)
```

작업 완료 이벤트가 요청되면 어떤 이벤트 매개변수로도 매개변수화할 수 없습니다. 신호 이름의 일부로 패키지 이름을 생략하면\(권장되지 않음\) 기본 패키지가 가정됩니다.

작업 실패\(of\): 작업 실패 이벤트는 끝점이 끝점이나 연결에 TO 유형의 하나 이상의 신호를 적용하라는 요청을 받았고 해당 신호 중 하나 이상이 시간 초과되기 전에 실패했을 때 생성됩니다. 완료 보고서는 다음과 같이 실패한 신호의 이름을 매개변수로 전달해야 합니다.

```text
      O: G/of(G/rt)
```

이 경우 "G" 패키지에서 "rt" 신호를 생성하는 중에 오류가 발생했습니다.

보고된 신호가 연결에 적용될 때 제공된 매개변수에는 다음과 같이 연결 이름도 포함됩니다.

```text
      O: G/of(G/rt@0A3F58)
```

작업 실패 이벤트 요청 시 이벤트 매개변수를 지정할 수 없습니다. 패키지 이름을 생략하면\(권장되지 않음\) 기본 패키지 이름이 사용됩니다.

---
## **6.7 ExtensionParameters**

```text
   Extension parameter extensions SHALL include:
```

\* 확장 매개변수의 이름과 인코딩.

\* 확장 매개변수에 할당할 수 있는 가능한 값 및 해당 값의 인코딩입니다.

\* 본 사양에 정의된 각 명령에 대해 요청 및 응답에서 확장 매개변수가 Mandatory, Optional, Forbidden인지 여부. 확장 매개변수는 일반적으로 필수가 아니어야 합니다.\(SHOULD NOT\)

\* 확장 매개변수의 동작에 대한 설명입니다. 이 설명의 일부로 명령에서 확장이 생략된 경우 기본값\(있는 경우\)을 정의해야 합니다. 매개변수를 처음 적용하기 전과 후에 기본값을 구별해야 할 수도 있습니다. 예를 들어 매개변수가 명시적으로 변경될 때까지 매개변수가 지정된 후 이전 값을 유지하는 경우입니다. 기본값이 설명되지 않으면 확장 매개변수는 모든 명령에서 기본값이 비어 있습니다.\(MUST\)

\* AuditEndpoint 및/또는 AuditConnection에서 확장을 감사할 수 있는지 여부와 반환된 값입니다. 아무것도 지정하지 않으면 확장 매개변수 감사는 AuditEndpoint에 대해서만 수행될 수 있으며 반환된 값은 확장의 현재 값이어야 합니다. 비어 있을 수 있습니다.\(MUST\)

---
## **6.8 LocalConnectionOptions**

```text
   LocalConnectionOptions extensions SHALL include:
```

\* LocalConnectionOptions 확장의 이름과 인코딩입니다.

\* LocalConnectionOptions 확장에 할당할 수 있는 가능한 값 및 해당 값의 인코딩입니다.

\* LocalConnectionOptions 확장의 동작에 대한 설명입니다. 이 설명의 일부로 다음 사항을 지정해야 합니다.\(MUST\)

- CreateConnection 명령에서 확장이 생략된 경우 기본값\(있는 경우\)입니다.

- ModifyConnection 명령에서 생략된 경우 기본값입니다. 이는 단순히 이전 값\(있는 경우\)을 유지하거나 기본값을 적용하는 것일 수 있습니다. 아무것도 지정하지 않으면 가능하면 현재 값이 유지됩니다.

- 기능 감사로 인해 확장이 반환되는 경우 해당 효과에 대한 설명과 가능한 값 및 해당 인코딩에 대한 설명\(패키지 자체는 항상 반환됩니다\). 아무것도 지정하지 않으면 기능을 감사할 때 확장이 반환되지 않습니다.\(MUST NOT\)

또한 확장은 LocalConnectionOptions를 감사하는 AuditConnection 명령의 결과에 포함되어야 합니다.\(MUST\)

---
## **6.9 Reason Codes**

```text
   Extension reason codes SHALL include:
```

\* 이유 코드의 번호입니다. 숫자는 800\~899 범위에 있어야 합니다.\(MUST\)

\* 이유코드가 생성된 상황을 포함한 확장 이유코드에 대한 설명입니다. 이러한 상황은 수신자가 확장 이유 코드를 올바르게 해석할 수 있도록 패키지에 정의된 다른 확장으로 인해 발생하는 이벤트로 제한되어야 합니다.\(SHOULD\)

이유 코드를 감사하는 AuditEndpoint 명령의 결과에 확장 이유 코드를 제공해야 할 수도 있습니다.

---
## **6.10 RestartMethods**

```text
   Extension Restart Methods SHALL include:
```

\* 재시작 방법의 이름과 인코딩입니다.

\* 재시작 방법이 생성된 상황을 포함한 재시작 방법에 대한 설명입니다. 이러한 상황은 수신자가 확장 다시 시작 방법을 올바르게 해석할 수 있도록 패키지에 정의된 다른 확장으로 인해 발생하는 이벤트로 제한되어야 합니다.\(SHOULD\)

\* RestartDelay 매개변수가 확장과 함께 사용되는지 여부를 나타냅니다. 아무것도 지정하지 않으면 사용하지 않는 것으로 간주됩니다. 이 경우 RestartDelay가 있으면 무시해야 합니다.\(MUST\)

\* 재시작 메소드가 서비스 상태를 정의하는 경우 설명은 이를 명시적으로 명시하고 설명해야 합니다. 이 경우 다시 시작 방법을 감사하는 AuditEndpoint 명령의 결과에 확장 다시 시작 방법이 제공될 수 있습니다.\(MUST\)

---
## **6.11 Return Codes**

```text
   Extension Return Codes SHALL include:
```

\* 확장 반환 코드의 번호입니다. 숫자는 800\~899 범위에 있어야 합니다.\(MUST\)

\* 확장 반환 코드가 생성되는 상황을 포함한 확장 반환 코드에 대한 설명입니다. 이러한 상황은 수신자가 확장 반환 코드를 올바르게 해석할 수 있도록 패키지에 정의된 다른 확장으로 인해 발생하는 이벤트로 제한되어야 합니다.\(SHOULD\)

---
## **7. Versions and Compatibility**
---
## **7.1 Changes from RFC 2705**

RFC 2705는 초안 버전 0.5의 마지막 업데이트로 1999년 10월에 발행되었습니다. 이 업데이트된 문서는 추가 구현 경험을 통해 도움이 됩니다. RFC 2705의 주요 변경 사항은 다음과 같습니다.

\* 몇 가지 설명, 편집 변경 사항 및 알려진 불일치에 대한 해결 방법이 포함되어 있습니다.

\* RFC 2119에 따라 사양 언어를 확정하고 RFC 2119 규칙 섹션을 추가했습니다.

\* 끝점 이름에서 혼합 와일드카드 동작이 명확해졌습니다.

\* 게이트웨이가 여러 물리적 게이트웨이로 구성된 경우 첫 번째 용어가 물리적 게이트웨이를 식별하도록 하는 명명 요구 사항이 삭제되었습니다. 또한 혼합된 와일드카드 사용뿐만 아니라 오른쪽의 와일드카드 명명 사용에 대한 권장 사항도 추가되었습니다.

\* 끝점 이름의 동의어 형식과 값을 자유롭게 교환할 수 없다는 점을 명확히 했습니다.

\* 엔드포인트 이름에 IPv6 주소가 허용됩니다.

```text
   * Clarified Digit Map matching rules.
```

\* 숫자 지도에 사용된 기호에 대해 누락된 의미를 추가했습니다.

\* 숫자 지도에 타이머 T 설명이 추가되었습니다.

\* 엔드포인트당 최소 2048바이트의 숫자 맵 크기를 지원하는 권장 사항이 추가되었습니다.

\* 여러 명령에서 와일드카드 사용을 명확하게 했습니다.

\* 이벤트 및 신호에 대해 공식적으로 정의된 이벤트 및 신호 매개변수입니다.

\* 이제 기본 MGCP 프로토콜에서 지속적인 이벤트가 허용됩니다.

\* 연결 와일드카드에 대한 추가 세부정보가 추가되었습니다.

\* 루프백의 동작을 명확하게 하고 해당 모드에서 혼합 및 다중 연결을 위한 연속성 테스트 연결 모드를 제공합니다.

\* EndpointConfiguration 명령에서 조건부 선택 사항이 되도록 BearerInformation을 수정했습니다.

\* 하나의 특정 시나리오에 대한 "오디오 교환" 작업 작업을 명확히 하고 다른 시나리오에 대한 작업은 정의되지 않았다는 점을 언급했습니다.

\* 상호 운용성을 위해 모든 구현에서 PCMU 인코딩을 지원하는 권장 사항이 추가되었습니다.

\* SDP와의 일관성을 위해 대역폭 LocalConnectionOptions 값을 제외에서 IP 계층의 오버헤드 포함으로 변경했습니다.

\* CreateConnection 명령의 두 번째 연결 모드가 "보내기/받기"로 설정된다는 점을 명확히 했습니다.

\* 서비스 유형 기본값이 0으로 변경되었습니다.

\* 반향 제거, 묵음 억제 및 이득 제어에 대한 추가 세부정보입니다. 또한 에코 제거 및 제어권 획득 처리를 지정하지 않도록 통화 에이전트에 대한 권장 사항을 추가했습니다.

\* "네트워크 루프백" 및 "네트워크 연속성 테스트" 모드를 사용하기 위해 연결에 RemoteConnectionDescriptor가 있어야 한다는 요구 사항이 추가되었습니다.

\* NAS에 대한 절차 및 사양이 제거되었습니다\(대신 패키지로 제공됩니다\).

\* ATM에 대한 절차 및 사양이 제거되었습니다\(대신 패키지로 제공됩니다\).

\* 누락된 선택적 NotifiedEntity 매개변수를 DeleteConnection\(통화 에이전트에서\) MGCI 명령에 추가했습니다.

\* 지원되는 MGCP 데이터그램의 최대 크기를 감사할 수 있도록 AuditEndpoint에 대한 선택적 새 MaxMGCPDatagram RequestedInfo 코드가 추가되었습니다.

\* 패키지 버전 번호가 있는 패키지 감사를 활성화하기 위해 AuditEndpoint에 대한 선택적 새 PackageList RequestedInfo 코드가 추가되었습니다. 반환 코드 518\(지원되지 않는 패키지\)에도 PackageList 매개 변수가 허용됩니다.

\* 기능에 누락된 속성이 추가되었습니다.

\* 0이 아닌 재시작 지연이 만료되면 업데이트된 RestartInProgress가 전송되어야 함을 명확히 했습니다. 또한 새로운 NotifiedEntity는 RestartInProgress 명령에 대한 응답으로만 반환될 수 있음을 명시했습니다.

\* 응답 승인 응답\(반환 코드 000\)을 추가하고 3방향 핸드셰이크에 포함했습니다.

\* ResponseAck 파라미터가 모든 명령어에서 허용되도록 변경되었습니다.

\* 반환 코드 101, 405, 406, 407, 409, 410, 503, 504, 505, 506, 507, 508, 509, 533, 534, 535, 536, 537, 538, 539, 540, 541을 추가하고 정의했습니다. 800-899 범위의 반환 코드는 패키지별 반환 코드입니다. 일부 반환 코드에 대해 추가 텍스트가 제공되고 알 수 없는 반환 코드를 처리하는 방법에 대한 추가 세부 정보가 추가되었습니다.

\* 이유 코드 903, 904, 905를 추가하고 이유 코드 800-899를 패키지별 이유 코드로 정의했습니다.

```text
   * Added section clarifying codec negotiation procedure.
```

\* ModifyConnection 명령의 리소스 예약 매개변수의 기본값이 현재 사용된 값이라는 점을 명확히 했습니다.

\* ModifyConnection 명령에서 연결 모드가 선택 사항임을 명확히 했습니다.

\* CreateConnection 명령에 대한 응답으로 LocalConnectionDescriptor가 선택 사항이 되도록 수정했습니다\(실패한 경우\).

\* 인용 문자열은 UTF-8로 인코딩되고 인용 문자열과 인용되지 않은 문자열의 상호 교환이 가능하다는 점을 명확히 했습니다.

\* 거래 식별자가 숫자 값으로 비교된다는 점을 명확히 했습니다.

\* 서비스 유형 LocalConnectionOptions에 대한 비트 순서가 명확해졌습니다.

\* RequestIdentifier 0의 사용을 명확히 했습니다.

\* 명령, 응답 및 일부 통화 흐름에 대한 예제 섹션이 추가되었습니다.

\* RFC 2327을 엄격하게 준수하도록 SDP의 사용 및 요구 사항을 수정했습니다.

\* 모든 MGCP 구현이 최소 4000바이트의 MGCP 데이터그램을 지원해야 한다는 요구 사항이 추가되었습니다. 또한 최대 데이터그램 크기, 조각화 및 재조립에 대한 새로운 섹션이 추가되었습니다.

\* 충족해야 할 기본 요구 사항만 명시하는 일반화된 피기백 재전송 방식입니다.

\* 재전송 타이머 계산 섹션을 명확하게 했습니다.

\* 임시 응답, 재전송 및 실패를 포함하여 장기 실행 트랜잭션의 작동을 명확히 했습니다.

\* 임시 응답 및 3방향 핸드셰이크와의 상호 작용에 대한 설명이 향상되었습니다.

\* 장애 조치 및 "통지된 엔터티"의 역할에 대한 설명이 강화되었습니다. 빈 "통지된 엔터티"가 허용되었지만 강력히 권장되지 않습니다.

\* 재전송 절차를 명확하게 하고 "잘못된 키" 고려 사항을 제거했습니다. 또한 Max1과 Max2 재전송 경계 및 관련 흐름도 간의 불일치가 수정되었습니다.

\* 여러 엔드포인트가 재전송될 때 오버헤드가 덜 발생하도록 재전송 절차에 대한 도메인 이름 확인을 업데이트했습니다.

\* NotifyRequests 응답 및 Notify 명령을 순서대로 전달하기 위한 요구 사항이 제거되었습니다. 알림 명령은 여전히 ​​순서대로 전달됩니다.

\* 포함된 알림 요청을 활성화해도 ObservedEvents 목록이 지워지지 않는다는 점을 명확히 했습니다.

\* 연결이 끊어진 상태와 알림 상태 간의 상호 작용을 정의했습니다.

\* 트랜잭션 의미에 대한 섹션이 추가되었습니다.

\* 여러 상호 작용 트랜잭션이 수신될 때 게이트웨이 동작을 정의했습니다.

\* 서비스 상태에 대한 추가 세부정보가 제공됩니다. 엔드포인트 서비스 상태, 다시 시작 방법 및 관련 명령 처리 간의 관계가 명확해졌습니다.

\* "재시작 절차"에서 "연결 끊김 상태"로 전환하는 작업을 명확하게 했습니다.

\* 감사 명령 및 응답이 "다시 시작" 및 "연결 끊김" 절차를 우회하도록 허용되었습니다.

\* "연결이 끊긴 프로시저"의 작동과 특히 피기백된 "연결이 끊긴" RestartInProgress 메시지의 작동을 명확하게 했습니다.

\* 메시지 볼륨을 줄이기 위해 특정 조건에서 "연결이 끊긴" RestartInProgress 메시지를 집계하는 옵션이 추가되었습니다.

\* "연결 끊김" 상태에 있는 동안 명령을 보내려는 엔드포인트에 대한 추가 동작을 정의했습니다.

\* 과부하를 처리하기 위한 두 개의 새로운 오류 코드\(101 및 409\)를 포함하는 일반 부하 제어에 대한 새로운 섹션이 추가되었습니다.

\* "제안된 MoveConnection 명령"을 삭제했습니다.

\* 프로토콜 사양에서 패키지가 제거되었습니다\(대신 별도의 문서로 제공됩니다\).

\* 공식적으로 기본 확장 메커니즘으로 확장된 패키지 개념은 이제 다음 항목에 대한 확장도 패키지에 정의할 수 있도록 허용합니다.

```text
     - BearerInformation

     - LocalConnectionOptions

     - ExtensionParameters

     - Connection Modes

     - Actions

     - Digit Map Letters

     - Connection Parameters

     - Restart Methods

     - Reason Codes

     - Return Codes
```

\* 패키지 정의에 대한 요구 사항 및 제안 형식이 추가되었습니다.

\* 시간 초과 신호와 함께 패키지에 자동으로 표시되도록 "작업 완료" 및 "작업 실패" 이벤트를 정의했습니다.

\* RFC 2705 이전의 차이점 목록은 삭제되었습니다.

\* 격리 버퍼 오버플로, ObservedEvents 오버플로, 내장된 알림 요청 실패를 처리하고 이벤트를 지속적으로 요청할 수 있도록 기본 패키지가 추가되었습니다. 새로운 "메시지" 명령도 포함되어 있습니다.

\* 패키지 및 기타 확장에 대한 IANA 등록 절차가 추가되었습니다.

\* 알려진 오류를 수정하고 이전 버전과 호환되는 방식으로 새로운 확장을 지원하기 위해 문법을 업데이트했습니다. 감사를 위해 새로운\(선택 사항\) PackageList 및 MaxMGCPDatagram을 추가했습니다. 문법을 보다 일관되게 만들기 위해 일부 프로덕션에서 명시적인 공백 규칙을 변경했습니다.

```text
   * Connection Mode interaction table added.
```

\* 가상 엔드포인트 명명 규칙에 대한 추가 세부정보가 추가되었습니다. 또한 제안된 게이트웨이 끝점 규칙과 끝점 명명 규칙에 "범위 와일드카드" 옵션이 추가되었습니다.

---
## **8. Security Considerations**

보안 문제는 섹션 5에서 논의됩니다.

---
## **9. Acknowledgements**

원래 MGCP 1.0 사양의 작성자인 Mauricio Arango, Andrew Dugan, Isaac Elliott, Christian Huitema 및 Scott Picket에게 특별한 감사를 드립니다.

또한 SGCP와 MGCP의 설계에 조언을 제공한 많은 리뷰어들, 특히 Sankar Ardhanari, Francois Berard, David Auerbach, Bob Biskner, David Bukovinsky, Charles Eckel, Mario Edini, Ed Guy, Barry Hoffner, Jerry Kamitses에게도 감사의 말씀을 전하고 싶습니다. , Oren Kudevitzki, Rajesh Kumar, Troy Morley, Dave Oran, Jeff Orwick, John Pickens, Lou Rubin, Chip Sharp, Paul Sijben, Kurt Steinbrenner, Joe Stone 및 Stuart Wray.

MGCP 버전 0.1은 Level 3 Communications가 설립한 기술 자문 위원회가 설계한 "인터넷 프로토콜 장치 제어"\(IPDC\)에서 많은 영감을 받았습니다. 전체 텍스트 세트는 IP 연결 제어 프로토콜, IP 미디어 제어 프로토콜 및 IP 장치 관리에서 검색되었습니다. 저자는 Ilya Akramovich, Bob Bell, Dan Brendes, Peter Chung, John Clark, Russ Dehlinger, Andrew Dugan, Isaac Elliott, Cary FitzGerald, Jan Gronski, Tom Hess, Geoff Jordan, Tony Lam이 이 프로토콜에 기여한 것에 대해 감사를 표하고 싶습니다. , Shawn Lewis, Dave Mazik, Alan Mikhak, Pete O'Connell, Scott Pickett, Shyamal Prasad, Eric Presworsky, Paul Richards, Dale Skran, Louise Spergel, David Sprague, Raj Srinivasan, Tom Taylor 및 Michael Thomas.

---
## **10. References**

```text
   [1]  Bradner, S., "The Internet Standards Process -- Revision 3", BCP
        9, RFC 2026, October 1996.
```

\[2\] Bradner, S., "요구 사항 수준을 나타 내기 위해 RFC에 사용되는 핵심 단어", BCP 14, RFC 2119, 1997년 3월.

\[3\] Schulzrinne, H., Casner, S., Frederick, R. 및 V. Jacobson, "RTP: 실시간 애플리케이션을 위한 전송 프로토콜", RFC 1889, 1996년 1월.

\[4\] Schulzrinne, H., "최소 제어를 통한 오디오 및 비디오 회의용 RTP 프로필", RFC 1890, 1996년 1월.

\[5\] Handley, M. 및 V. Jacobson, "SDP: 세션 설명

- 프로토콜", RFC 2327, 1998년 4월.

\[6\] Handley, M., Perkins, C. 및 E. Whelan, "세션 발표 프로토콜", RFC 2974, 2000년 10월.

\[7\] Rosenberg, J., Camarillo, G., Johnston, A., Peterson, J., Sparks, R., Handley, M., Schulzrinne, H. 및 E. Schooler, "SIP\(세션 시작 프로토콜\)" , RFC 3261, 2002년 6월.

\[8\] Schulzrinne, H., Rao, A. 및 R. Lanphier, "실시간 스트리밍 프로토콜\(RTSP\)", RFC 2326, 1998년 4월.

\[9\] ITU-T, 권고 사항 Q.761, "신호 시스템 No. 7의 ISDN 사용자 부분에 대한 기능 설명"\(Malaga-Torremolinos, 1984; Helsinki에서 수정, 1993\).

\[10\] ITU-T, 권고 사항 Q.762, "신호 시스템 No. 7의 ISDN 사용자 부분의 메시지 및 신호의 일반 기능"\(MalagaTorremolinos, 1984; Helsinki에서 수정, 1993\).

```text
   [11] ITU-T, Recommendation H.323 (02/98), "PACKET-BASED MULTIMEDIA
        COMMUNICATIONS SYSTEMS".
```

\[12\] ITU-T, 권고사항 H.225, "패킷 기반 멀티미디어 통신 시스템을 위한 호 신호 프로토콜 및 미디어 스트림 패킷화".

\[13\] ITU-T, 권고사항 H.245\(02/98\), "멀티미디어 통신을 위한 제어 프로토콜".

\[14\] Kent, S. 및 R. Atkinson, "인터넷 프로토콜을 위한 보안 아키텍처", RFC 2401, 1998년 11월.

\[15\] Kent, S. 및 R. Atkinson, "IP 인증 헤더", RFC 2402, 1998년 11월.

\[16\] Kent, S. 및 R. Atkinson, "IP ESP\(보안 페이로드 캡슐화\)", RFC 2406, 1998년 11월.

\[17\] Crocker, D. 및 P. Overell, "구문을 위한 증강된 BNF

- 사양: ABNF", RFC 2234, 1997년 11월.

\[18\] Stevens, W. Richard, "TCP/IP 일러스트, 1권, The

- 프로토콜", Addison-Wesley, 1994.

```text
   [19] Allman, M., Paxson, V. "On Estimating End-to-End Network Path
        Properties", Proc. SIGCOMM'99, 1999.
```

\[20\] Yergeau, F., "UTF-8, ISO 10646의 변환 형식", RFC 2279, 1998년 1월.

\[21\] Braden, R., "인터넷 호스트에 대한 요구 사항 - 통신 계층", STD 3, RFC 1122, 1989년 10월.

\[22\] Bellcore, "LSSGR: 통합 서비스 디지털 네트워크 사용자 부분\(ISDNUP\)을 사용하는 통화 제어를 위한 스위칭 시스템 일반 요구 사항", GR-317-CORE, 2호, 1997년 12월.

\[23\] Narten, T. 및 Alvestrand H., "RFC에서 IANA 고려 사항 섹션 작성 지침", RFC 2434, 1998년 10월.

---
# **Appendix A: Formal Syntax Description of the Protocol**

이 섹션에서는 RFC 2234에 정의된 "구문 사양을 위한 증강 BNF"에 따라 프로토콜 구문에 대한 공식적인 설명을 제공합니다. 구문은 여기에 포함되지 않은 RFC 2234, 섹션 6.1에 정의된 핵심 규칙을 사용합니다. 또한 구문은 RFC 2234의 대소문자 구분 규칙을 따릅니다. 즉, MGCP는 대소문자를 구분하지 않습니다\(그러나 SDP는 그렇지 않습니다\). ABNF는 선형 공백의 암시적 사양을 제공하지 않으며 MGCP 메시지는 따라서 아래 문법에 제공된 명시적인 선형 공백 규칙을 따라야 한다는 점에 유의해야 합니다. 그러나 일반적인 견고성 원칙에 따라 구현자는 수신된 메시지에서 추가 선형 공백을 허용하는 것이 좋습니다.\(MUST\)

---
# **MGCPMessage = MGCPCommand / MGCPResponse**
---
# **MGCPCommand = MGCPCommandLine 0*(MGCPParameter) [EOL *SDPinformation]**

```text
MGCPCommandLine = MGCPVerb 1*(WSP) transaction-id 1*(WSP)
                        endpointName 1*(WSP) MGCPversion EOL

MGCPVerb = "EPCF" / "CRCX" / "MDCX" / "DLCX" / "RQNT"
         / "NTFY" / "AUEP" / "AUCX" / "RSIP" / extensionVerb
```

---
# **extensionVerb  = ALPHA 3(ALPHA / DIGIT) ; experimental starts with X**
---
# **transaction-id = 1*9(DIGIT)**

```text
endpointName      = LocalEndpointName "@" DomainName
LocalEndpointName = LocalNamePart 0*("/" LocalNamePart)
LocalNamePart     = AnyName / AllName / NameString
AnyName           = "$"
AllName           = "*"
NameString        = 1*(range-of-allowed-characters)
; VCHAR except "$", "*", "/", "@"
range-of-allowed-characters  = %x21-23 / %x25-29 / %x2B-2E
                             / %x30-3F / %x41-7E

DomainName = 1*255(ALPHA / DIGIT / "." / "-")    ; as defined
           / "#" number                          ; in RFC 821
           / "[" IPv4address / IPv6address "]"   ; see RFC 2373
```

; RFC 821에서 ABNF로 다시 작성됨
숫자 = 1\*DIGIT

```text
;From RFC 2373
IPv6address = hexpart [ ":" IPv4address ]
IPv4address = 1*3DIGIT "." 1*3DIGIT "." 1*3DIGIT "." 1*3DIGIT

; this production, while occurring in RFC2373, is not referenced
; IPv6prefix  = hexpart "/" 1*2DIGIT
hexpart = hexseq / hexseq "::" [ hexseq ] / "::" [ hexseq ]
hexseq  = hex4 *( ":" hex4)
hex4    = 1*4HEXDIG

MGCPversion = "MGCP" 1*(WSP) 1*(DIGIT) "." 1*(DIGIT)
                            [1*(WSP) ProfileName]
ProfileName = VCHAR *( WSP / VCHAR)
```

---
# **MGCPParameter = ParameterValue EOL**

```text
; Check infoCode if more parameter values defined
; Most optional values can only be omitted when auditing
ParameterValue = ("K"  ":" 0*(WSP)  [ResponseAck])
               / ("B"  ":" 0*(WSP)  [BearerInformation])
               / ("C"  ":" 0*(WSP)  CallId)
               / ("I"  ":" 0*(WSP)  [ConnectionId])
               / ("N"  ":" 0*(WSP)  [NotifiedEntity])
               / ("X"  ":" 0*(WSP)  [RequestIdentifier])
               / ("L"  ":" 0*(WSP)  [LocalConnectionOptions])
               / ("M"  ":" 0*(WSP)  ConnectionMode)
               / ("R"  ":" 0*(WSP)  [RequestedEvents])
               / ("S"  ":" 0*(WSP)  [SignalRequests])
               / ("D"  ":" 0*(WSP)  [DigitMap])
               / ("O"  ":" 0*(WSP)  [ObservedEvents])
               / ("P"  ":" 0*(WSP)  [ConnectionParameters])
               / ("E"  ":" 0*(WSP)  ReasonCode)
               / ("Z"  ":" 0*(WSP)  [SpecificEndpointID])
               / ("Z2" ":" 0*(WSP)  SecondEndpointID)
               / ("I2" ":" 0*(WSP)  SecondConnectionID)
               / ("F"  ":" 0*(WSP)  [RequestedInfo])
               / ("Q"  ":" 0*(WSP)  QuarantineHandling)
               / ("T"  ":" 0*(WSP)  [DetectEvents])
               / ("RM" ":" 0*(WSP)  RestartMethod)
               / ("RD" ":" 0*(WSP)  RestartDelay)
               / ("A"  ":" 0*(WSP)  [Capabilities])
               / ("ES" ":" 0*(WSP)  [EventStates])
               / ("PL" ":" 0*(WSP)  [PackageList])    ; Auditing only
               / ("MD" ":" 0*(WSP)  MaxMGCPDatagram)  ; Auditing only
               / (extensionParameter ":" 0*(WSP) [parameterString])

; A final response may include an empty ResponseAck
ResponseAck =  confirmedTransactionIdRange
               *( ","  0*(WSP) confirmedTransactionIdRange )
```

---
# **confirmedTransactionIdRange = transaction-id ["-" transaction-id]**

```text
BearerInformation = BearerAttribute 0*("," 0*(WSP) BearerAttribute)
BearerAttribute   = ("e" ":" BearerEncoding)
                  / (BearerExtensionName [":" BearerExtensionValue])
BearerExtensionName  = PackageLCOExtensionName
BearerExtensionValue = LocalOptionExtensionValue
BearerEncoding = "A" / "mu"
```

---
# **CallId = 1*32(HEXDIG)**

; 감사 요청 응답에는 식별자 목록이 포함될 수 있습니다.
연결 ID = 1\*32\(HEXDIG\) 0\*\("," 0\*\(WSP\) 1\*32\(HEXDIG\)\)
SecondConnectionID = 연결 ID

```text
NotifiedEntity = [LocalName "@"] DomainName [":" portNumber]
LocalName  = LocalEndpointName            ; No internal structure
```

---
# **portNumber = 1*5(DIGIT)**
---
# **RequestIdentifier = 1*32(HEXDIG)**

```text
LocalConnectionOptions = LocalOptionValue 0*(WSP)
                           0*("," 0*(WSP) LocalOptionValue 0*(WSP))
LocalOptionValue = ("p"  ":" packetizationPeriod)
                 / ("a"  ":" compressionAlgorithm)
                 / ("b"  ":" bandwidth)
                 / ("e"  ":" echoCancellation)
                 / ("gc" ":" gainControl)
                 / ("s"  ":" silenceSuppression)
                 / ("t"  ":" typeOfService)
                 / ("r"  ":" resourceReservation)
                 / ("k"  ":" encryptiondata)
                 / ("nt" ":" ( typeOfNetwork /
                                    supportedTypeOfNetwork))
                 / (LocalOptionExtensionName
                         [":" LocalOptionExtensionValue])

Capabilities    =  CapabilityValue 0*(WSP)
                     0*("," 0*(WSP) CapabilityValue 0*(WSP))
CapabilityValue = LocalOptionValue
                / ("v" ":" supportedPackages)
                / ("m" ":" supportedModes)

PackageList     = pkgNameAndVers 0*("," pkgNameAndVers)
pkgNameAndVers  = packageName ":" packageVersion
packageVersion  = 1*(DIGIT)

packetizationPeriod  = 1*4(DIGIT) ["-" 1*4(DIGIT)]
compressionAlgorithm = algorithmName 0*(";" algorithmName)

algorithmName        = 1*(SuitableLCOCharacter)
bandwidth            = 1*4(DIGIT) ["-" 1*4(DIGIT)]
echoCancellation     = "on" / "off"
gainControl          = "auto" / ["-"] 1*4(DIGIT)
silenceSuppression   = "on" / "off"
typeOfService        = 1*2(HEXDIG)     ; 1 hex only for capabilities
resourceReservation  = "g" / "cl" / "be"

;encryption parameters are coded as in SDP (RFC 2327)
;NOTE: encryption key may contain an algorithm as specified in RFC 1890
encryptiondata = ( "clear" ":" encryptionKey )
               / ( "base64" ":" encodedEncryptionKey )
               / ( "uri" ":" URItoObtainKey )
               / ( "prompt" ) ; defined in SDP, not usable in MGCP!

encryptionKey = 1*(SuitableLCOCharacter) / quotedString
; See RFC 2045
encodedEncryptionKey = 1*(ALPHA / DIGIT / "+" / "/" / "=")
URItoObtainKey = 1*(SuitableLCOCharacter) / quotedString

typeOfNetwork = "IN" / "ATM" / "LOCAL" / OtherTypeOfNetwork
; Registered with IANA - see RFC 2327
OtherTypeOfNetwork     = 1*(SuitableLCOCharacter)
supportedTypeOfNetwork = typeOfNetwork *(";" typeOfNetwork)
```

---
# **supportedModes    = ConnectionMode 0*(";" ConnectionMode)**
---
# **supportedPackages = packageName 0*(";" packageName)**
---
# **packageName = 1*(ALPHA / DIGIT / HYPHEN) ; Hyphen neither first or last**

```text
LocalOptionExtensionName = VendorLCOExtensionName
                         / PackageLCOExtensionName
                         / OtherLCOExtensionName
VendorLCOExtensionName   = "x" ("+"/"-") 1*32(SuitableExtLCOCharacter)
PackageLCOExtensionName  = packageName "/"
                            1*32(SuitablePkgExtLCOCharacter)
; must not start with "x-" or "x+"
OtherLCOExtensionName    = 1*32(SuitableExtLCOCharacter)

LocalOptionExtensionValue = (1*(SuitableExtLCOValChar)
                                                    / quotedString)
                              *(";" (1*(SuitableExtLCOValChar)
                                                      / quotedString))

;Note: No "data" mode.
ConnectionMode = "sendonly" / "recvonly" / "sendrecv"
               / "confrnce" / "inactive" / "loopback"

               / "conttest" / "netwloop" / "netwtest"
               / ExtensionConnectionMode
ExtensionConnectionMode = PkgExtConnectionMode
PkgExtConnectionMode    = packageName "/" 1*(ALPHA / DIGIT)

RequestedEvents = requestedEvent 0*("," 0*(WSP) requestedEvent)
requestedEvent  = (eventName ["(" requestedActions ")"])
                / (eventName "(" requestedActions ")"
                                       "(" eventParameters ")" )
eventName = [(packageName / "*") "/"]
                (eventId / "all" / eventRange
                                        / "*" / "#") ; for DTMF
                              ["@" (ConnectionId / "$" / "*")]
eventId = 1*(ALPHA / DIGIT / HYPHEN)   ; Hyphen neither first nor last
eventRange = "[" 1*(DigitMapLetter / (DIGIT "-" DIGIT) /
                        (DTMFLetter "-" DTMFLetter)) "]"
DTMFLetter = "A" / "B" / "C" / "D"

requestedActions = requestedAction 0*("," 0*(WSP) requestedAction)
requestedAction  = "N" / "A" / "D" / "S" / "I" / "K"
                 / "E" "(" EmbeddedRequest ")"
                 / ExtensionAction
ExtensionAction  = PackageExtAction
PackageExtAction = packageName "/" Action ["(" ActionParameters ")"]
Action           = 1*ALPHA
ActionParameters = eventParameters        ; May contain actions

;NOTE: Should tolerate different order when receiving, e.g., for NCS.
EmbeddedRequest = (      "R" "(" EmbeddedRequestList ")"
                    ["," 0*(WSP) "S" "(" EmbeddedSignalRequest ")"]
                    ["," 0*(WSP) "D" "(" EmbeddedDigitMap ")"]      )
                / (      "S" "(" EmbeddedSignalRequest ")"
                    ["," 0*(WSP) "D" "(" EmbeddedDigitMap ")"] )
                / (      "D" "(" EmbeddedDigitMap ")" )

EmbeddedRequestList   = RequestedEvents
EmbeddedSignalRequest = SignalRequests
EmbeddedDigitMap = DigitMap

SignalRequests   = SignalRequest 0*("," 0*(WSP) SignalRequest )
SignalRequest    = eventName [ "(" eventParameters ")" ]

eventParameters  = eventParameter 0*("," 0*(WSP) eventParameter)
eventParameter   = eventParameterValue
                 / eventParameterName "=" eventParameter
                 / eventParameterName "(" eventParameters ")"
eventParameterString = 1*(SuitableEventParamCharacter)
eventParameterName   = eventParameterString
```

---
# **eventParameterValue  = eventParameterString / quotedString**

```text
DigitMap           = DigitString  / "(" DigitStringList ")"
DigitStringList    = DigitString 0*( "|" DigitString )
DigitString        = 1*(DigitStringElement)
DigitStringElement = DigitPosition ["."]
DigitPosition      = DigitMapLetter / DigitMapRange
; NOTE "X" is now included
DigitMapLetter     = DIGIT / "#" / "*" / "A" / "B" / "C" / "D" / "T"
                   / "X" / ExtensionDigitMapLetter
ExtensionDigitMapLetter = "E" / "F" / "G" / "H" / "I" / "J" / "K"
                        / "L" / "M" / "N" / "O" / "P" / "Q" / "R"
                        / "S" / "U" / "V" / "W" / "Y" / "Z"
; NOTE "[x]" is now allowed
DigitMapRange = "[" 1*DigitLetter "]"
DigitLetter   = *((DIGIT "-" DIGIT) / DigitMapLetter)
```

---
# **ObservedEvents = SignalRequests**
---
# **EventStates    = SignalRequests**

```text
ConnectionParameters = ConnectionParameter
                        0*( "," 0*(WSP) ConnectionParameter )

ConnectionParameter  = ( "PS" "=" packetsSent )
                     / ( "OS" "=" octetsSent )
                     / ( "PR" "=" packetsReceived )
                     / ( "OR" "=" octetsReceived )
                     / ( "PL" "=" packetsLost )
                     / ( "JI" "=" jitter )
                     / ( "LA" "=" averageLatency )
                     / ( ConnectionParameterExtensionName
                              "=" ConnectionParameterExtensionValue )
packetsSent     = 1*9(DIGIT)
octetsSent      = 1*9(DIGIT)
packetsReceived = 1*9(DIGIT)
octetsReceived  = 1*9(DIGIT)
packetsLost     = 1*9(DIGIT)
jitter          = 1*9(DIGIT)
averageLatency  = 1*9(DIGIT)

ConnectionParameterExtensionName = VendorCPExtensionName
                                 /    PackageCPExtensionName
VendorCPExtensionName  = "X" "-" 2*ALPHA
PackageCPExtensionName = packageName "/" CPName
CPName = 1*(ALPHA / DIGIT / HYPHEN)
ConnectionParameterExtensionValue = 1*9(DIGIT)
```

---
# **MaxMGCPDatagram = 1*9(DIGIT)**

ReasonCode = 3DIGIT \[1\*\(WSP\) "/" 패키지명\] ; 8xx \[WSP 1\*\(%x20-7E\)\]에만 해당

```text
SpecificEndpointID = endpointName
SecondEndpointID   = endpointName
```

---
# **RequestedInfo = infoCode 0*("," 0*(WSP) infoCode)**

```text
infoCode = "B" / "C" / "I" / "N" / "X" / "L" / "M" / "R" / "S"
         / "D" / "O" / "P" / "E" / "Z" / "Q" / "T" / "RC" / "LC"
         / "A" / "ES" / "RM" / "RD" / "PL" / "MD" / extensionParameter

QuarantineHandling = loopControl / processControl
                   / (loopControl "," 0*(WSP) processControl )
loopControl    = "step" / "loop"
processControl = "process" / "discard"
```

---
# **DetectEvents = SignalRequests**

```text
RestartMethod = "graceful" / "forced" / "restart" / "disconnected"
              / "cancel-graceful" / extensionRestartMethod
extensionRestartMethod = PackageExtensionRM
PackageExtensionRM     = packageName "/" 1*32(ALPHA / DIGIT / HYPHEN)
RestartDelay = 1*6(DIGIT)

extensionParameter = VendorExtensionParameter
                   / PackageExtensionParameter
                   / OtherExtensionParameter
VendorExtensionParameter  = "X" ("-"/"+") 1*6(ALPHA / DIGIT)
PackageExtensionParameter = packageName "/"
                            1*32(ALPHA / DIGIT / HYPHEN)
; must not start with "x-" or x+"
OtherExtensionParameter   = 1*32(ALPHA / DIGIT / HYPHEN)
```

;첫 번째 문자가 큰따옴표이면 따옴표로 묶인 문자열입니다.
매개변수 문자열 = \(%x21 / %x23-7F\) \*\(%x20-7F\) ; 첫 번째와 마지막은 해서는 안 됩니다. 공백/quotedString이어야 함

```text
MGCPResponse = MGCPResponseLine 0*(MGCPParameter)
                                        *2(EOL *SDPinformation)
```

MGCPResponseLine = responseCode 1\*\(WSP\) 트랜잭션 ID \[1\*\(WSP\) "/" packageName\] ; 8xx \[WSP responseString\] EOL에만 해당

```text
responseCode = 3DIGIT
responseString = *(%x20-7E)
```

---
# **SuitablePkgExtLCOCharacter =  SuitableLCOCharacter**

```text
SuitableExtLCOCharacter = DIGIT / ALPHA / "+" / "-" / "_" / "&"
              / "!" / "'" / "|" / "=" / "#" / "?"
              / "." / "$" / "*" /       "@" / "[" / "]"
              / "^" / "`" / "{" / "}" / "~"
```

---
# **SuitableLCOCharacter   = SuitableExtLCOCharacter / "/"**
---
# **SuitableExtLCOValChar  = SuitableLCOCharacter / ":"**

; """, "\(", "\)", "," 및 "="를 제외한 VCHAR
적합한EventParamCharacter = %x21 / %x23-27 / %x2A-2B / %x2D-3C / %x3E-7E

```text
; NOTE: UTF8 encoded
quotedString  = DQUOTE 0*(quoteEscape / quoteChar) DQUOTE
quoteEscape   = DQUOTE DQUOTE
quoteChar = (%x00-21 / %x23-FF)
```

---
# **EOL = CRLF / LF**
---
# **HYPHEN = "-"**

; 대신 적절한 SDP 문법은 RFC 2327을 참조하세요.
SDPinformation = SDPLine CRLF \*\(SDPLine CRLF\) ; RFC 2327 참조
SDDPLine = 1\*\(%x01-09 / %x0B / %x0C / %x0E-FF\) ; 적절한 방어를 위해.

---
# **Appendix B: Base Package**

```text
   Package name: B
   Version: 0
```

MGCP 사양은 프로토콜에 일반적으로 사용되는 이벤트 및 확장 매개변수 집합을 포함하는 기본 패키지를 정의합니다. 필수는 아니지만 기본 프로토콜에 중요한 기능을 제공하므로 이 패키지를 지원하는 것이 좋습니다.\(SHOULD\)

---
## **B.1 Events**

아래 표에는 이벤트가 나열되어 있습니다.

```text
    ------------------------------------------------------------------
   | Symbol  |   Definition               |  R  |   S     Duration    |
   |---------|----------------------------|-----|---------------------|
   | enf(##) | embedded RQNT failure      |  x  |                     |
   | oef     | observed events full       |  x  |                     |
   | qbo     | quarantine buffer overflow |  x  |                     |
    ------------------------------------------------------------------
```

이벤트는 다음과 같이 정의됩니다.

임베디드 알림 요청 실패\(enf\): 임베디드 알림 요청 실패가 발생하면 임베디드 알림 요청 실패\(enf\) 이벤트가 생성됩니다. 이벤트가 요청되면 이는 EmbeddedNotificationRequest 자체의 일부여야 합니다. 이벤트가 보고되면 발생한 오류를 자세히 설명하는 오류 코드\(섹션 2.4 참조\)로 매개변수화될 수 있습니다. 요청 시 매개변수화할 수 없습니다.

관찰된 이벤트 가득 참\(oef\): 엔드포인트가 ObservedEvents 목록에 더 이상 이벤트를 누적할 수 없을 때 이벤트가 생성됩니다. 이 이벤트가 발생하고 알림을 트리거하는 데 사용되지 않으면 목록에 추가되어야 하는 후속 이벤트가 손실됩니다.

격리 버퍼 오버플로\(qbo\): 격리 버퍼가 오버플로되고 하나 이상의 이벤트가 손실되면 이벤트가 생성됩니다.

---
## **B.2 Extension Parameters**
---
### **B.2.1 PersistentEvents**

PertantEvents: 게이트웨이가 지속적으로 감지하고 보고하도록 요청되는 이벤트 목록입니다. 매개변수는 선택사항이지만 DetectEvents 매개변수가 제공될 수 있는 모든 명령에 제공될 수 있습니다. 매개변수의 초기 기본값은 비어 있습니다. 매개변수가 명령에서 생략되면 현재 값이 유지됩니다. 매개변수가 제공되면 현재 값이 완전히 대체됩니다. 이 목록에 이벤트를 제공하는 것은 해당 특정 이벤트를 지속되는 것으로 정의하는 것과 유사하지만 바람직합니다. PertantEvents의 현재 목록은 현재 및 후속 알림 요청에 암시적으로 적용되지만 눈부심 감지 등은 수행되지 않습니다\(DetectEvents와 유사\). 이 목록에 제공된 이벤트가 RequestedEvents 목록에 포함된 경우 RequestedEvents에 사용된 작업 및 이벤트 매개변수는 RequestedEvents 목록의 수명 동안 PertantEvents 목록의 이벤트와 연결된 작업 및 이벤트 매개변수를 대체합니다. 작업 및 이벤트 매개변수가 복원됩니다. 이 매개변수를 통해 요청된 이벤트 상태가 있는 이벤트는 감사되면 EventStates 목록에 포함됩니다.

PertantEvents를 사용하여 연결에서 이벤트를 감지할 수도 있습니다. "모든 연결" 와일드카드 사용은 간단하지만 하나 이상의 특정 연결과 함께 PertantEvents를 사용하는 것은 신중하게 고려해야 합니다. 문제의 연결이 삭제되면 새 PertantEvents 값이 없는 후속 알림 요청은 암시적으로 삭제된 연결을 참조하므로 실패합니다\(오류 코드 515 - 잘못된 연결 ID, 권장\).\(SHOULD\)

매개변수는 기본 프로토콜에서 관련 오류 코드를 생성합니다\(예: 알 수 없는 이벤트가 지정된 경우 오류 코드 512\).

PertantEvents 매개변수는 감사될 수 있으며, 이 경우 현재 값을 반환합니다. RequestedEvents 감사는 이 확장의 영향을 받지 않습니다. 즉, 이 목록에 지정된 이벤트는 RequestedEvents 감사 시 자동으로 보고되지 않습니다.

PertantEvents의 매개변수 이름은 "PR"이며 프로덕션에서 정의됩니다.

```text
     PersistentEvents = "PR" ":" 0*WSP  [RequestedEvents]
```

다음 예에서는 매개변수 사용을 보여줍니다.

```text
     B/PR: L/hd(N), L/hf(N), L/hu(N), B/enf, B/oef, B/qbo
```

이는 엔드포인트에 오프훅, 후크플래시 및 온훅을 지속적으로 감지하고 보고하도록 지시합니다. 또한 포함된 알림 요청 실패, 관찰된 이벤트 가득 참 및 격리 버퍼 오버플로를 지속적으로 감지하고 보고하도록 엔드포인트에 지시합니다.

---
### **B.2.2 NotificationState**

NotificationState는 AuditEndpoint 명령으로 감사할 수 있는 RequestedInfo 매개 변수입니다. 엔드포인트가 알림 상태인지 여부를 확인하는 데 사용할 수 있습니다.

이 매개변수는 모든 명령에서 금지됩니다. 응답에서는 AuditEndpoint에만 유효한 응답 매개변수입니다.

이는 다음 문법으로 정의됩니다.

```text
     NotificationState        = "NS" ":" 0*WSP NotificationStateValue
     NotificationStateValue   = "ns" / "ls" / "o"
```

다음과 같이 RequestedInfo에 매개변수 코드를 포함하여 감사의 일부로 요청됩니다.

```text
     F: B/NS
```

엔드포인트가 "통지 상태"에 있으면 응답 매개변수에는 "ns" 값이 포함되고, 엔드포인트가 "lockstep 상태"에 있으면 값 "ls"가 포함됩니다\(즉, NTFY에 대한 응답 후 RQNT를 기다리는 경우\). "step" 모드에서 작동할 때 수신됨\), 그렇지 않은 경우 "o" 값이 수신됩니다. 예를 들면 다음과 같습니다.

```text
     B/NS: ns
```

---
## **B.3 Verbs**

MGCP 패키지는 새 명령을 정의하기 위한 것이 아니지만 현재 누락된 중요한 일반 기능, 즉 게이트웨이가 호출 에이전트에 일반 메시지를 보내는 기능을 추가하기 위해 이 경우 예외가 발생합니다.

새 명령의 정의는 다음과 같습니다.

```text
          ReturnCode
          <-- Message(EndpointId
                         [, ...])
```

EndpointId는 메시지 명령을 실행하는 게이트웨이의 엔드포인트 이름입니다. 식별자는 게이트웨이의 도메인 이름을 포함하여 정규화된 엔드포인트 식별자여야 합니다. 엔드포인트 이름의 로컬 부분은 "다음 중 하나" 와일드카드를 사용하면 안 됩니다.\(MUST, MUST NOT\)

Message 명령의 정의에 지정된 유일한 매개 변수는 EndpointId입니다. 그러나 확장에서는 Message 명령과 함께 사용할 추가 매개 변수를 정의할 것으로 예상됩니다. 이러한 확장은 기본 MGCP 프로토콜의 정상적인 작동을 변경하거나 방해해서는 안 됩니다. 그러나 기본 MGCP 프로토콜에서 제공하는 것 이상의 추가 기능을 정의할 수도 있습니다. 예를 들어, 호출 에이전트가 지원하는 패키지를 감사할 수 있도록 게이트웨이를 활성화하는 확장을 정의할 수 있지만, 관찰된 이벤트를 보고하는 대체 방법으로 메시지 명령을 사용하는 것은 정상적인 MGCP 프로토콜 동작을 변경하므로 불법입니다.\(MUST NOT\)

정상적인 MGCP 작동을 방해하지 않으려면 메시지 명령에 대한 응답이 부족하여 엔드포인트의 연결이 끊어져서는 안 됩니다. 엔드포인트는 이를 투명하게 처리하고 영향을 받지 않고 정상적인 처리를 계속할 수 있도록 준비되어야 합니다.\(MUST NOT, MUST\)

엔드포인트가 호출 에이전트가 메시지 명령을 지원하지 않는다는 응답을 수신하면 엔드포인트는 현재 "통지된 엔터티"가 변경될 때까지 메시지 명령을 다시 전송해서는 안 됩니다. 마찬가지로 엔드포인트가 호출 에이전트가 메시지 명령에서 하나 이상의 매개변수를 지원하지 않는다는 것을 나타내는 응답을 수신하는 경우 엔드포인트는 현재 "통지된 엔터티"가 나올 때까지 해당 매개변수가 포함된 메시지 명령을 다시 전송해서는 안 됩니다. 변경되었습니다.\(MUST NOT, MUST NOT\)

메시지 명령은 다음 예와 같이 MESG로 인코딩됩니다.

```text
      MESG 1200 aaln/1@rgw.whatever.net MGCP 1.0
```

---
# **Appendix C: IANA Considerations**
---
## **C.1 New MGCP Package Sub-Registry**

IANA는 http://www.iana.org/locationments/mgcp-packages 아래에 MGCP 패키지에 대한 새로운 하위 레지스트리를 구축했습니다.

패키지는 다음 절차에 따라 IANA에 등록할 수 있습니다.

패키지에는 "x-" 또는 "x+"라는 두 문자로 시작하면 안 되는 고유한 문자열 이름이 있어야 합니다.\(MUST NOT\)

패키지 제목, 이름, 버전\(기본적으로 0으로 가정\)은 패키지를 설명하는 문서에 대한 참조뿐만 아니라 IANA에 등록되어야 합니다. 문서는 안정적인 URL을 가지고 있어야 하며 공개 웹 서버에 포함되어 있어야 합니다.\(MUST, MUST\)

패키지는 하나 이상의 확장 숫자 맵 문자를 정의할 수 있지만 이는 제한적이고 평면적인 이름 공간에서 가져옵니다. 이름 충돌을 방지하기 위해 IANA는 IANA가 등록한 다른 패키지에 이미 정의된 확장 숫자 맵 문자를 정의하는 패키지를 등록해서는 안 됩니다. 이 작업을 쉽게 하기 위해 해당 패키지에는 "확장 숫자 맵 문자:" 행과 패키지 정의 시작 부분에 정의된 확장 숫자 맵 문자 목록이 포함되어야 합니다.\(MUST NOT, MUST\)

패키지에 대한 연락처 이름, 이메일 및 우편 주소를 제공해야 합니다. 연락처 정보는 필요에 따라 정의 조직에 의해 업데이트되어야 합니다.\(MUST, MUST\)

마지막으로, 패키지를 등록하기 전에 IANA는 지정된 전문가\[23\]가 패키지를 검토하도록 해야 합니다. 전문 검토자는 전반적인 검토 결정에 대해 IANA에 이메일을 보냅니다.\(MUST\)

---
## **C.2 New MGCP Package**

이 문서는 IANA에 등록된 부록 B의 새로운 MGCP 기본 패키지를 정의합니다.

---
## **C.3 New MGCP LocalConnectionOptions Sub-Registry**

IANA는 http://www.iana.org/locationments/mgcp-localconnectionoptions 아래에 MGCP LocalConnectionOptions에 대한 새로운 하위 레지스트리를 구축했습니다.

패키지는 선호되는 확장 메커니즘이지만 이전 버전과의 호환성을 위해 이 사양에 제공된 것 이상의 로컬 연결 옵션을 IANA에 등록할 수 있습니다. 이러한 각 로컬 연결 옵션에는 "x-" 또는 "x+"로 시작하면 안 되는 고유한 문자열 이름이 있어야 합니다. 로컬 연결 옵션 필드 이름과 인코딩 이름은 IANA에 등록되어야 하며 로컬 연결 옵션을 설명하는 문서에 대한 참조도 등록되어야 합니다. 문서는 안정적인 URL을 가지고 있어야 하며 공개 웹 서버에 포함되어 있어야 합니다.\(MUST NOT, MUST, MUST\)

로컬 연결 옵션에 대한 연락처 이름, 이메일 및 우편 주소를 제공해야 합니다. 연락처 정보는 필요에 따라 정의 조직에 의해 업데이트되어야 합니다.\(MUST, MUST\)

마지막으로, LocalConnectionOption을 등록하기 전에 IANA는 지정된 전문가\[23\]가 LocalConnectionOption을 검토하도록 해야 합니다. 전문 검토자는 전반적인 검토 결정에 대해 IANA에 이메일을 보냅니다.\(MUST\)

---
# **Appendix D: Mode Interactions**

MGCP 엔드포인트는 하나 이상의 미디어 스트림을 설정할 수 있습니다. 이러한 스트림은 수신\(원격 끝점에서\) 또는 발신\(핸드셋 마이크에서 생성\)됩니다. "연결 모드" 매개변수는 이러한 스트림의 방향과 생성을 설정합니다. 엔드포인트에 대한 연결이 하나만 있는 경우 이러한 스트림의 매핑은 간단합니다. 핸드셋은 모드 매개변수에 따라 핸드셋 스피커를 통해 수신 스트림을 재생하고 핸드셋 마이크 신호에서 나가는 스트림을 생성합니다.

그러나 엔드포인트에 여러 연결이 설정되면 들어오고 나가는 스트림이 많아질 수 있습니다. 사용된 연결 모드에 따라 이러한 스트림은 서로 다르게 상호 작용할 수 있으며 핸드셋에서 들어오고 나가는 스트림도 다를 수 있습니다.

아래 표는 하나 이상의 연결이 동시에 "활성"일 때 서로 다른 연결을 혼합하는 방법을 설명합니다. 여기에서 활성 연결은 다음 모드 중 하나에 있는 연결로 정의됩니다.\(MUST\)

```text
   *  "send/receive"
   *  "send only"
   *  "receive only"
   *  "conference"
```

"네트워크 루프백", "네트워크 연속성 테스트" 또는 "비활성" 모드의 연결은 "활성" 모드의 연결에 영향을 받지 않습니다. 표에서는 다음 규칙을 사용합니다.

```text
   *  Ai is the incoming media stream from Connection A
   *  Bi is the incoming media stream from Connection B
   *  Hi is the incoming media stream from the Handset Microphone
   *  Ao is the outgoing media stream to Connection A
   *  Bo is the outgoing media stream to Connection B
   *  Ho is the outgoing media stream to the Handset earpiece
   *  NA indicates no stream whatsoever (assuming there are no signals
      applied on the connection)
```

다음 표의 "netw"는 "netwloop" 또는 "netwtest" 모드를 나타냅니다.

```text
     -------------------------------------------------------------
    |       |               Connection A Mode                     |
    |       |-----------------------------------------------------
    |       |sendonly|recvonly|sendrecv|confrnce|inactive|  netw  |
    |-------|-----------------------------------------------------|
    | |Send | Ao=Hi  | Ao=NA  | Ao=Hi  | Ao=Hi  | Ao=NA  | Ao=Ai  |
    |C|only | Bo=Hi  | Bo=Hi  | Bo=Hi  | Bo=Hi  | Bo=Hi  | Bo=Hi  |
    |o|     | Ho=NA  | Ho=Ai  | Ho=Ai  | Ho=Ai  | Ho=NA  | Ho=NA  |
    |n|-----------------------------------------------------------
    |n|recv |        |Ao=NA   |Ao=Hi   |Ao=Hi   | Ao=NA  | Ao=Ai  |
    |e|only |        |Bo=NA   |Bo=NA   |Bo=NA   | Bo=NA  | Bo=NA  |
    |c|     |        |Ho=Ai+Bi|Ho=Ai+Bi|Ho=Ai+Bi| Ho=Bi  | Ho=Bi  |
    |t|-----------------------------------------------------------|
    |i|send |        |        |Ao=Hi   |Ao=Hi   | Ao=NA  | Ao=Ai  |
    |o|recv |        |        |Bo=Hi   |Bo=Hi   | Bo=Hi  | Bo=Hi  |
    |n|     |        |        |Ho=Ai+Bi|Ho=Ai+Bi| Ho=Bi  | Ho=Bi  |
    | |-----------------------------------------------------------|
    |B|conf |        |        |        |Ao=Hi+Bi| Ao=NA  | Ao=Ai  |
    | |rnce |        |        |        |Bo=Hi+Ai| Bo=Hi  | Bo=Hi  |
    |M|     |        |        |        |Ho=Ai+Bi| Ho=Bi  | Ho=Bi  |
    |o|-----------------------------------------------------------|
    |d|Inac |        |        |        |        | Ao=NA  | Ao=Ai  |
    |e|tive |        |        |        |        | Bo=NA  | Bo=NA  |
    | |     |        |        |        |        | Ho=NA  | Ho=NA  |
    | |-----------------------------------------------------------|
    | |netw |        |        |        |        |        | Ao=Ai  |
    | |     |        |        |        |        |        | Bo=Bi  |
    | |     |        |        |        |        |        | Ho=NA  |
     -------------------------------------------------------------
```

3개 이상의 "활성" 연결이 있는 경우 위 표에 정의된 대로 각 상호 작용\(모든 스트림 통합\)에 대해 혼합된 나가는 미디어 스트림과 계속 상호 작용합니다. 내부 리소스가 모두 사용되어 스트림을 혼합할 수 없는 경우 게이트웨이는 오류를 반환해야 합니다\(리소스가 충분하지 않은 오류 코드 403 또는 502를 권장함\).\(MUST\)

---
# **Appendix E: Endpoint Naming Conventions**

다음 섹션에서는 몇 가지 권장되는 엔드포인트 명명 규칙을 제공합니다.\(SHOULD\)

---
## **E.1 Analog Access Line Endpoints**

문자열 "aaln"은 아날로그 액세스 회선 끝점에 대한 로컬 끝점 이름의 첫 번째 용어로 사용되어야 합니다. "aaln" 뒤에 오는 용어는 게이트웨이의 물리적 계층 구조를 따라야 하므로 게이트웨이에 RJ11 포트 수가 있는 경우 로컬 엔드포인트 이름은 다음과 같을 수 있습니다.

```text
      aaln/#
```

여기서 "#"은 게이트웨이의 아날로그 회선\(RJ11 포트\) 번호입니다.

반면에 게이트웨이에는 여러 개의 물리적 플러그인 장치가 있을 수 있으며 각 플러그인 장치에는 일정 수의 RJ11 포트가 포함되어 있습니다. 이 경우 로컬 엔드포인트 이름은 다음과 같습니다.

```text
      aaln/<unit #>/#
```

여기서 <장치 #\>는 게이트웨이에 있는 플러그인 장치의 번호이고 "#"은 해당 장치에 있는 아날로그 회선\(RJ11 포트\)의 번호입니다. 위의 숫자\("#"\)에는 앞에 0을 사용하면 안 됩니다.\(MUST NOT\)

---
## **E.2 Digital Trunks**

문자열 "ds"는 다음과 같이 물리적 및 디지털 계층 구조를 따르는 명명 규칙을 사용하여 디지털 엔드포인트의 첫 번째 용어에 사용되어야 합니다.

```text
      ds/<unit-type1>-<unit #>/<unit-type2>-<unit #>/.../<channel #>
```

여기서: <unit-type\>은 특정 계층 구조 수준을 식별합니다. <unit-type\>의 몇 가지 예시 값은 다음과 같습니다: "s", "su", "oc3", "ds3", "e3", "ds2", "e2", "ds1", "e1" 여기서 "s" 는 슬롯 번호를 나타내고 "su"는 슬롯 내의 하위 단위를 나타냅니다. 위의 숫자\("#"\)에는 앞에 0을 사용하면 안 됩니다.\(MUST NOT\)

<단위 #\>는 해당 계층 수준에서 <단위 유형\>의 특정 인스턴스를 참조하는 데 사용되는 십진수입니다. 레벨 수와 해당 레벨의 이름 지정은 미디어 게이트웨이 내의 물리적 계층 구조를 기반으로 합니다.

---
## **E.3 Virtual Endpoints**

또 다른 유형의 엔드포인트는 물리적 인터페이스\(예: 아날로그 또는 디지털 엔드포인트\)와 연결되지 않은 엔드포인트입니다. 이러한 유형의 엔드포인트를 가상 엔드포인트라고 하며 엔드포인트에 일부 기능을 제공하는 일부 DSP 리소스를 나타내는 데 종종 사용됩니다. 예를 들어 공지 사항, IVR 또는 회의 브리지 장치가 있습니다. 이러한 장치에는 DSP 기능의 여러 인스턴스가 있을 수 있으므로 가능한 명명 규칙은 다음과 같습니다.

```text
      <virtual-endpoint-type>/<endpoint-#>
```

여기서 <virtual-endpoint-type\>은 엔드포인트 유형을 나타내는 문자열\(예: 공지 서버의 경우 "ann", 회의 서버의 경우 "cnf"\)일 수 있으며 <endpoint-#\>은 장치 내의 특정 가상 엔드포인트를 식별합니다. 위의 숫자\("#"\)에는 선행 0을 사용하면 안 됩니다. 서버의 물리적 계층 구조에 플러그인 DSP 카드가 포함된 경우 로컬 엔드포인트 이름의 다른 계층 구조 레벨을 사용하여 플러그인 장치를 설명할 수 있습니다.\(MUST NOT\)

"다음 중 하나" 와일드카드를 사용한 결과로 가상 엔드포인트가 생성될 수 있습니다. 마찬가지로, 가상 엔드포인트의 마지막 연결이 삭제되면 가상 엔드포인트가 더 이상 존재하지 않을 수 있습니다. 가상 엔드포인트의 정의는 이러한 측면을 모두 자세히 설명해야 합니다.\(MUST\)

<virtual-endpoint-type\>이 가상 엔드포인트를 자동으로 생성 및 삭제하는 경우 RestartInProgress 명령이 실행될 때 가상 엔드포인트가 존재하지 않는 경우가 있습니다. 이러한 경우 게이트웨이는 다음과 같이 특정 <endpoint-#\> 대신 "all of" 와일드카드를 사용해야 합니다.\(SHOULD\)

```text
     ann/*@mygateway.whatever.net
```

RestartInProgress 명령이 게이트웨이\(가상이든 아니든\)의 모든 엔드포인트를 참조하는 경우 <virtual-endpoint-id\>는 다음과 같이 생략될 수 있습니다.

```text
     *@mygateway.whatever.net
```

그러나 명령이 처리되려면 게이트웨이에서 수신한 명령이 실제 엔드포인트\("다음 중 하나" 와일드카드를 사용하여 해당 명령에 의해 생성되었을 수 있음\)를 참조해야 합니다.

---
## **E.4 Media Gateway**

MGCP는 미디어 게이트웨이의 엔드포인트에 대한 작업만 정의합니다. 게이트웨이가 관리하는 엔드포인트가 아닌 게이트웨이 자체를 나타내는 엔드포인트를 정의하는 것이 유리할 수 있습니다. 이를 원하는 구현에서는 다음과 같이 로컬 엔드포인트 이름 "mg"\(미디어 게이트웨이의 경우\)를 사용해야 합니다.

```text
     mg@mygateway.whatever.net
```

이러한 엔드포인트를 정의해도 프로토콜 의미는 변경되지 않습니다. 즉, 게이트웨이의 "mg" 엔드포인트와 기타 엔드포인트\(예: 디지털 트렁크\)는 여전히 독립적인 엔드포인트이므로 그렇게 처리되어야 합니다. 예를 들어 RestartInProgress 명령은 평소와 같이 게이트웨이의 모든 엔드포인트에 대해 계속 실행되어야 합니다.\(MUST, MUST\)

---
## **E.5 Range Wildcards**

섹션 2.1.2에 설명된 대로 MGCP 엔드포인트 명명 체계는 로컬 엔드포인트 이름의 개별 용어에 대해 "모두" 및 "다음 중 하나" 와일드카드를 정의합니다. "all of" 와일드카드는 메시지 수를 줄이는 데 매우 유용하지만 정의상 로컬 엔드포인트 이름에서 특정 용어의 모든 인스턴스를 참조하려는 경우에만 사용할 수 있습니다. 또한 명령이 게이트웨이에서 호출 에이전트로 전송되는 경우 "all of" 와일드카드는 해당 와일드카드로 명명된 모든 엔드포인트가 동일한 "알림 엔터티"를 갖는 경우에만 사용할 수 있습니다. 보다 세분화된 와일드카드 구성표를 선호하는 구현에서는 여기에 설명된 범위 와일드카드 구성표를 사용할 수 있습니다.

범위 와일드카드는 다음과 같이 정의됩니다.

```text
   RangeWildcard    = "[" NumericalRange *( "," NumericalRange ) "]"
   NumericalRange   = 1*(DIGIT) [ "-" 1*(DIGIT) ]
```

공백은 허용되지 않습니다. 또한 범위 와일드카드는 "\[" 문자를 사용하여 범위의 시작을 나타내므로 "\[" 문자는 범위 와일드카드를 사용하는 끝점 이름에 사용되어서는 안 됩니다. 범위 와일드카드의 길이는 합리적으로 작은 값\(예: 128자\)으로 제한되어야 합니다.\(MUST NOT, SHOULD\)

범위 와일드카드는 "전체" 와일드카드를 사용할 수 있는 모든 곳에서 사용할 수 있습니다. 이름이 지정된 엔드포인트의 의미는 동일합니다. 그러나 범위 와일드카드 구성표를 사용하려면 게이트웨이와 통화 에이전트 모두에서 지원이 필요하다는 점에 유의해야 합니다. 따라서 게이트웨이는 통화 에이전트가 범위 와일드카드를 지원한다고 가정해서는 안 되며 그 반대의 경우도 마찬가지입니다. 실제로 이는 일반적으로 게이트웨이와 통화 에이전트가 모두 일관되게 프로비저닝되어야 함을 의미합니다.\(MUST, MUST NOT\)

범위 와일드카드를 사용하세요. 또한 범위 와일드카드를 사용하는 게이트웨이나 통화 에이전트가 가능한 엔드포인트 명명 문제를 나타낼 수 있는 오류 응답을 수신하는 경우 자동으로 범위 와일드카드를 사용하지 않는 상태로 되돌릴 수 있어야 합니다.\(MUST\)

다음 예에서는 범위 와일드카드 사용을 보여줍니다.

```text
      ds/ds1-1/[1-12]
      ds/ds1-1/[1,3,20-24]
      ds/ds1-[1-2]/*
      ds/ds3-1/[1-96]
```

다음 예에서는 명령에서 이를 사용하는 방법을 보여줍니다.

```text
      RSIP 1204 ds/ds3-1/[1-96]@tgw-18.whatever.net MGCP 1.0
      RM: restart
      RD: 0
```

---
# **Appendix F: Example Command Encodings**

이 부록에서는 사용된 실제 인코딩과 함께 표시되는 명령 및 응답의 예를 제공합니다. 각 명령에 대한 예가 제공됩니다. 명령과 응답에 표시된 모든 설명은 선택 사항입니다.

---
## **F.1 NotificationRequest**

첫 번째 예는 전화 벨을 울리고 오프 후크 이벤트를 찾는 알림 요청을 보여줍니다.

```text
      RQNT 1201 aaln/1@rgw-2567.whatever.net MGCP 1.0
      N: ca@ca1.whatever.net:5678
      X: 0123456789AC
      R: l/hd(N)
      S: l/rg
```

응답은 트랜잭션이 성공했음을 나타냅니다.

```text
      200 1201 OK
```

두 번째 예에서는 오프 후크 이벤트를 찾아 누적한 다음 발신음을 제공하고 제공된 숫자 맵에 따라 숫자를 누적하는 NotificationRequest를 보여줍니다. "통지된 엔터티"는 "ca@ca1.whatever.net:5678"로 설정되고 SignalRequests 매개변수가 비어 있으므로\(생략될 수도 있음\) 현재 활성화된 모든 TO 신호가 중지됩니다. 격리 버퍼의 모든 이벤트가 처리되며 "알림" 상태에서 검색할 이벤트 목록에는 "요청된 이벤트" 및 지속 이벤트 외에 팩스 톤이 포함됩니다.

```text
      RQNT 1202 aaln/1@rgw-2567.whatever.net MGCP 1.0
      N: ca@ca1.whatever.net:5678
      X: 0123456789AC
      R: L/hd(A, E(S(L/dl),R(L/oc, L/hu, D/[0-9#*T](D))))
      D: (0T|00T|#xxxxxxx|*xx|91xxxxxxxxxx|9011x.T)
      S:
      Q: process
      T: G/ft
```

응답은 트랜잭션이 성공했음을 나타냅니다.

```text
      200 1202 OK
```

---
## **F.2 Notify**

아래 예에서는 "91"로 시작하는 12자리 숫자가 뒤에 오는 오프후크 이벤트를 알리는 알림 메시지를 보여줍니다. Notify와 그 결과인NotificationRequest를 연관시키는 트랜잭션 식별자가 포함됩니다. 명령은 일반적으로 NotifiedEntity 매개변수에 제공된 실제 값\(예: "ca@ca1.whatever.net:5678"\)이 되는 현재 "알림 엔터티"로 전송됩니다. 장애 조치 상황으로 인해 다음이 변경되었을 수 있습니다.

```text
      NTFY 2002 aaln/1@rgw-2567.whatever.net MGCP 1.0
      N: ca@ca1.whatever.net:5678
      X: 0123456789AC
      O: L/hd,D/9,D/1,D/2,D/0,D/1,D/8,D/2,D/9,D/4,D/2,D/6,D/6
```

Notify 응답은 트랜잭션이 성공했음을 나타냅니다.

```text
      200 2002 OK
```

---
## **F.3 CreateConnection**

첫 번째 예에서는 지정된 엔드포인트에 연결을 생성하는 CreateConnection 명령을 보여줍니다. 연결은 지정된 CallId의 일부가 됩니다. LocalConnectionOptions는 G.711 mu-law가 사용되는 코덱이고 패킷화 기간이 10ms임을 지정합니다. 연결 모드는 "수신 전용"입니다.

```text
      CRCX 1204 aaln/1@rgw-2567.whatever.net MGCP 1.0
      C: A3C47F21456789F0
      L: p:10, a:PCMU
      M: recvonly
```

응답은 트랜잭션이 성공했음을 나타내며 새로 생성된 연결에 대한 연결 식별자가 포함됩니다. 새 연결에 대한 세션 설명도 포함됩니다. 앞에는 빈 줄이 있습니다.

```text
      200 1204 OK
      I: FDE234C8
```

v=0

- o=- 25678 753849 IN IP4 128.96.41.1 s=- c=IN IP4 128.96.41.1 t=0 0 m=오디오 3456 RTP/AVP 0

두 번째 예에서는 알림 요청과 RemoteConnectionDescriptor가 포함된 CreateConnection 명령을 보여줍니다.

```text
      CRCX 1205 aaln/1@rgw-2569.whatever.net MGCP 1.0
      C: A3C47F21456789F0
      L: p:10, a:PCMU
      M: sendrecv
      X: 0123456789AD
      R: L/hd
      S: L/rg
```

v=0

- o=- 25678 753849 IN IP4 128.96.41.1 s=- c=IN IP4 128.96.41.1 t=0 0 m=오디오 3456 RTP/AVP 0

응답은 전화기가 이미 오프훅 상태였기 때문에 거래가 실패했음을 나타냅니다. 결과적으로 연결 ID나 세션 설명이 반환되지 않습니다.

```text
      401 1205 Phone off-hook
```

세 번째 예는 임시 응답과 3방향 핸드셰이크의 사용을 보여줍니다. 또 다른 연결을 생성하고 응답 확인 매개변수를 사용하여 수신된 이전 응답을 확인합니다.

```text
      CRCX 1206 aaln/1@rgw-2569.whatever.net MGCP 1.0
      K: 1205
      C: A3C47F21456789F0
      L: p:10, a:PCMU
      M: inactive
```

v=0

- o=- 25678 753849 IN IP4 128.96.41.1 s=- c=IN IP4 128.96.41.1 t=0 0 m=오디오 3456 RTP/AVP 0

처음에는 임시 응답이 반환됩니다.

```text
      100 1206 Pending
      I: DFE233D1
```

v=0

- o=- 4723891 7428910 IP4 128.96.63.25 s=- c=IN IP4 128.96.63.25 t=0 0 m=오디오 3456 RTP/AVP 0

잠시 후 최종 응답이 수신됩니다.

```text
      200 1206 OK
      K:
      I: DFE233D1
```

v=0

- o=- 4723891 7428910 IP4 128.96.63.25 s=- c=IN IP4 128.96.63.25 t=0 0 m=오디오 3456 RTP/AVP 0

통화 에이전트는 요청에 따라 최종 응답을 확인합니다.

```text
      000 1206
```

거래가 완료되었습니다.

---
## **F.4 ModifyConnection**

첫 번째 예는 단순히 연결의 연결 모드를 "보내기/받기"로 설정하는 ModifyConnection 명령을 보여줍니다. "알림 엔터티"도 설정됩니다.

```text
      MDCX 1209 aaln/1@rgw-2567.whatever.net MGCP 1.0
      C: A3C47F21456789F0
      I: FDE234C8
      N: ca@ca1.whatever.net
      M: sendrecv
```

응답은 트랜잭션이 성공했음을 나타냅니다.

```text
      200 1209 OK
```

두 번째 예에서는 세션 설명을 전달하고 ModifyConnection 명령에 알림 요청을 포함합니다. 엔드포인트는 사용자에게 전화 연결음을 재생하기 시작합니다.

```text
      MDCX 1210 aaln/1@rgw-2567.whatever.net MGCP 1.0
      C: A3C47F21456789F0
      I: FDE234C8
      M: recvonly
      X: 0123456789AE
      R: L/hu
      S: G/rt
```

v=0

- o=- 4723891 7428910 IP4 128.96.63.25 s=- c=IN IP4 128.96.63.25 t=0 0 m=오디오 3456 RTP/AVP 0

응답은 트랜잭션이 성공했음을 나타냅니다.

```text
      200 1206 OK
```

---
## **F.5 DeleteConnection (from the Call Agent)**

이 예에서 통화 에이전트는 지정된 엔드포인트에서 "FDE234C8" 연결을 삭제하도록 게이트웨이에 지시합니다.

```text
      DLCX 1210 aaln/1@rgw-2567.whatever.net MGCP 1.0
      C: A3C47F21456789F0
      I: FDE234C8
```

응답은 성공을 나타내며 연결이 삭제되었음을 나타냅니다. 따라서 연결에 대한 연결 매개변수도 포함됩니다.

```text
      250 1210 OK
      P: PS=1245, OS=62345, PR=780, OR=45123, PL=10, JI=27, LA=48
```

---
## **F.6 DeleteConnection (from the gateway)**

이 예에서 게이트웨이는 호출 에이전트에 DeleteConnection 명령을 보내 지정된 엔드포인트의 연결이 삭제되었음을 지시합니다. ReasonCode는 삭제 이유를 지정하고 연결에 대한 연결 매개변수도 제공됩니다.

```text
      DLCX 1210 aaln/1@rgw-2567.whatever.net MGCP 1.0
      C: A3C47F21456789F0
      I: FDE234C8
      E: 900 - Hardware error
      P: PS=1245, OS=62345, PR=780, OR=45123, PL=10, JI=27, LA=48
```

통화 에이전트는 게이트웨이에 성공 응답을 보냅니다.

```text
      200 1210 OK
```

---
## **F.7 DeleteConnection (multiple connections from the Call Agent)**

첫 번째 예에서 통화 에이전트는 지정된 엔드포인트에서 "A3C47F21456789F0" 통화와 관련된 모든 연결을 삭제하도록 게이트웨이에 지시합니다.

```text
      DLCX 1210 aaln/1@rgw-2567.whatever.net MGCP 1.0
      C: A3C47F21456789F0
```

응답은 성공과 연결이 삭제되었음을 나타냅니다.

```text
      250 1210 OK
```

두 번째 예에서 통화 에이전트는 지정된 모든 엔드포인트와 관련된 모든 연결을 삭제하도록 게이트웨이에 지시합니다.

```text
      DLCX 1210 aaln/*@rgw-2567.whatever.net MGCP 1.0
```

응답은 성공을 나타냅니다.

```text
      250 1210 OK
```

---
## **F.8 AuditEndpoint**

첫 번째 예에서 통화 에이전트는 지정된 게이트웨이에 어떤 엔드포인트가 있는지 확인하려고 하므로 엔드포인트 이름의 로컬 부분에 "all of" 와일드카드를 사용합니다.

```text
      AUEP 1200 *@rgw-2567.whatever.net MGCP 1.0
```

게이트웨이는 성공을 나타내며 엔드포인트 이름 목록을 포함합니다.

```text
      200 1200 OK
      Z: aaln/1@rgw-2567.whatever.net
      Z: aaln/2@rgw-2567.whatever.net
```

두 번째 예에서는 엔드포인트 중 하나의 기능이 요청됩니다.

```text
      AUEP 1201 aaln/1@rgw-2567.whatever.net MGCP 1.0
      F: A
```

응답은 성공과 능력도 나타냅니다. 두 가지 코덱이 지원되지만 기능은 다릅니다. 결과적으로 두 개의 별도 기능 세트가 반환됩니다.

```text
      200 1201 OK
      A: a:PCMU, p:10-100, e:on, s:off, v:L;S, m:sendonly;
               recvonly;sendrecv;inactive;netwloop;netwtest
      A: a:G729, p:30-90, e:on, s:on, v:L;S, m:sendonly;
               recvonly;sendrecv;inactive;confrnce;netwloop
```

기능 행의 캐리지 리턴은 형식 지정 목적으로만 표시되며 실제 구현에서는 허용되지 않습니다.

세 번째 예에서 통화 에이전트는 엔드포인트에 대한 여러 유형의 정보를 감사합니다.

```text
      AUEP 2002 aaln/1@rgw-2567.whatever.net MGCP 1.0
      F: R,D,S,X,N,I,T,O,ES
```

응답은 성공을 나타냅니다.

```text
      200 2002 OK
      R: L/hu,L/oc(N),D/[0-9](N)
      D:
      S: L/vmwi(+)
      X: 0123456789B1
      N: [128.96.41.12]
      I: 32F345E2
      T: G/ft
      O: L/hd,D/9,D/1,D/2
      ES: L/hd
```

요청된 이벤트 목록에는 세 가지 이벤트가 포함되어 있습니다. 패키지 이름을 지정하지 않으면 기본 패키지가 사용됩니다. 작업에도 동일하게 적용되므로 "L/hu" 이벤트에 대해 기본 작업인 알림을 가정해야 합니다. "숫자 지도" 값이 생략된다는 것은 현재 엔드포인트에 숫자 지도가 없다는 의미입니다. 현재 활성 시간 초과 신호는 없지만 OO 신호 "vmwi"가 현재 켜져 있으므로 결과적으로 포함됩니다. 이 경우 매개변수화되었지만 매개변수가 제외되었을 수 있습니다. 현재 "통지된 엔터티"는 IP 주소를 참조하며 끝점에 대한 단일 연결만 존재합니다. DetectEvents의 현재 값은 "G/ft"이고 ObservedEvents 목록에는 지정된 4개의 이벤트가 포함되어 있습니다. 마지막으로, 감사된 이벤트 상태는 거래가 처리될 당시 전화기가 오프훅 상태였음을 보여줍니다.

---
## **F.9 AuditConnection**

첫 번째 예에서는 CallId, NotifiedEntity, LocalConnectionOptions, 연결 모드, LocalConnectionDescriptor 및 연결 매개 변수를 감사하는 AuditConnection 명령을 보여줍니다.

```text
      AUCX 2003 aaln/1@rgw-2567.whatever.net MGCP 1.0
      I: 32F345E2
      F: C,N,L,M,LC,P
```

응답은 성공을 나타내며 RequestedInfo에 대한 정보를 포함합니다.

```text
      200 2003 OK
      C: A3C47F21456789F0
      N: ca@ca1.whatever.net
      L: p:10, a:PCMU
      M: sendrecv
      P: PS=395, OS=22850, PR=615, OR=30937, PL=7, JI=26, LA=47
```

v=0

- o=- 4723891 7428910 IN IP4 128.96.63.25 s=- c=IN IP4 128.96.63.25 t=0 0 m=오디오 1296 RTP/AVP 0

두 번째 예에서는 RemoteConnectionDescriptor 및 LocalConnectionDescriptor 감사를 요청합니다.

```text
      AUCX 1203 aaln/2@rgw-2567.whatever.net MGCP 1.0
      I: FDE234C8
      F: RC,LC
```

응답은 성공을 나타내며 RequestedInfo에 대한 정보를 포함합니다. 이 경우 RemoteConnectionDescriptor가 존재하지 않으므로 RemoteConnectionDescriptor에는 프로토콜 버전 필드만 포함됩니다.

```text
      200 1203 OK
```

v=0

- o=- 4723891 7428910 IN IP4 128.96.63.25 s=- c=IN IP4 128.96.63.25 t=0 0 m=오디오 1296 RTP/AVP 0

```text
      v=0
```

---
## **F.10 RestartInProgress**

첫 번째 예는 지정된 엔드포인트가 300초 내에 서비스가 중단될 것임을 통화 에이전트에 알리기 위해 게이트웨이에서 보낸 RestartInProgress 메시지를 보여줍니다.

```text
      RSIP 1200 aaln/1@rgw-2567.whatever.net MGCP 1.0
      RM: graceful
      RD: 300
```

통화 상담원의 응답은 거래가 성공했음을 나타냅니다.

```text
      200 1200 OK
```

두 번째 예에서 게이트웨이가 전송한 RestartInProgress 메시지는 호출 에이전트에게 게이트웨이의 모든 엔드포인트가 0초 내에 서비스 상태로 전환된다는 사실, 즉 현재 서비스 상태에 있음을 알립니다. 재시작 지연도 생략될 수 있습니다.

```text
      RSIP 1204 *@rgw-2567.whatever.net MGCP 1.0
      RM: restart
      RD: 0
```

통화 에이전트의 응답은 성공을 나타내며 더 나아가 문제의 엔드포인트에 새로운 "알림 엔터티"를 제공합니다.

```text
      200 1204 OK
      N: CA-1@whatever.net
```

또는 다음과 같이 새로운 "알림 엔터티"로 인해 명령이 실패했을 수 있습니다.

```text
      521 1204 OK
      N: CA-1@whatever.net
```

이 경우 "다시 시작 절차"를 충족하기 위해 명령을 다시 시도해야 하며, 이번에는 호출 에이전트 "CA-1@whatever.net"으로 이동합니다.

---
# **Appendix G: Example Call Flows**

이 섹션의 메시지 플로우 테이블은 다음 약어를 사용합니다.

```text
   * rgw = Residential Gateway

   * ca  = Call Agent
```

\* n+ = 'n' 단계가 한 번 이상 반복됩니다.

메시지 텍스트 내에서 대문자와 소문자를 사용하는 것은 가독성을 돕기 위한 것이며 어떤 방식으로든 요구 사항이 아니라는 점에 유의하십시오. 대소문자와 관련된 유일한 요구 사항은 항상 대소문자를 구분하지 않는다는 것입니다.

---
## **G.1 Restart**
---
### **G.1.1 Residential Gateway Restart**

다음 표는 다시 시작된 두 개의 독립 주거용 게이트웨이\(rgw1 및 rgw2\)가 통화 에이전트\(ca\)에 접속할 때 발생할 수 있는 메시지 순서를 보여줍니다.

```text
                  Table F.1: Residential Gateway Restart

 ---------------------------------------------------------------------
|step#|    usr1    |    rgw1    |     ca     |    rgw2    |    usr2   |
|=====|============|============|============|============|===========|
|  1  |            |    rsip -> |            |            |           |
|     |            |            | <- ack     |            |           |
|-----|------------|------------|------------|------------|-----------|
|  2  |            |            | <- auep    |            |           |
|     |            |     ack -> |            |            |           |
|-----|------------|------------|------------|------------|-----------|
|  3+ |            |            | <- rqnt    |            |           |
|     |            |     ack -> |            |            |           |
|-----|------------|------------|------------|------------|-----------|
|  4  |            |            |            | <- rsip    |           |
|     |            |            |     ack -> |            |           |
|-----|------------|------------|------------|------------|-----------|
|  5  |            |            |    auep -> |            |           |
|     |            |            |            | <- ack     |           |
|-----|------------|------------|------------|------------|-----------|
|  6+ |            |            |    rqnt -> |            |           |
|     |            |            |            | <- ack     |           |
 ---------------------------------------------------------------------
```

1단계 - rgw1에서 ca로 RestartInProgress\(rsip\)

rgw1은 DNS를 사용하여 ca의 도메인 이름을 확인하고 기본 포트 2727로 보냅니다. 명령은 다음으로 구성됩니다.

```text
      rsip 1 *@rgw1.whatever.net mgcp 1.0
      rm: restart
```

"\*"는 rgw1의 모든 끝점이 다시 시작되고 있음을 ca에 알리는 데 사용되며 "restart"는 다시 시작 방법으로 지정됩니다. 호출 에이전트 "ca"는 명령에 대한 트랜잭션 ID\(이 경우 1\)가 포함된 확인 메시지로 명령을 확인합니다. rsip의 소스 포트로 지정된 동일한 포트를 사용하여 rgw1에 승인을 보냅니다. 아무 것도 표시되지 않으면 기본 포트인 2727을 사용합니다.

```text
      200 1 ok
```

응답 코드는 필수입니다. 이 경우 "200"은 "요청한 트랜잭션이 정상적으로 실행되었습니다"를 의미합니다. 응답 문자열은 선택 사항입니다. 이 경우 추가 설명으로 "ok"가 포함됩니다.

2단계 - ca에서 rgw1로의 AuditEndpoint\(auep\)

명령은 다음으로 구성됩니다.

```text
      auep 153 *@rgw1.whatever.net mgcp 1.0
```

"\*"는 모든 엔드포인트의 rgw1에서 감사 정보를 요청하는 데 사용됩니다. rgw1은 명령의 트랜잭션 ID\(이 경우 153\)가 포함된 승인 메시지로 명령을 승인하며 엔드포인트 목록이 포함됩니다. 이 예에서 rgw1에는 aaln/1과 aaln/2라는 두 개의 엔드포인트가 있습니다.

```text
      200 153 ok
      Z: aaln/1@rgw1.whatever.net
      Z: aaln/2@rgw1.whatever.net
```

끝점 ID 목록이 있으면 ca는 "\*"가 지정된 끝점의 ID로 대체되는 개별 AuditEndpoint 명령을 보낼 수 있습니다. 이에 대한 응답으로 rgw1은 예제에 반환된 엔드포인트 ID 목록을 엔드포인트에 대해 요청된 정보로 바꿉니다. 이 선택적 메시지 교환은 이 예에 표시되지 않습니다.

3단계 - ca에서 rgw1의 각 엔드포인트로의 알림 요청\(rqnt\)

이 경우 ca는 aaln/1에 대해 하나씩 두 개의 rqnt를 보냅니다.

```text
      rqnt 154 aaln/1@rgw1.whatever.net mgcp 1.0
      r: l/hd(n)
      x: 3456789a0
```

aaln/2에 대한 두 번째:

```text
      rqnt 155 aaln/2@rgw1.whatever.net mgcp 1.0
      r: l/hd(n)
      x: 3456789a1
```

요청된 이벤트 매개변수 행에서 이벤트는 잠재적인 모호성을 피하기 위해 패키지 이름과 함께 "l/hd"로 완전히 지정됩니다. 이는 권장되는 동작입니다. 명확성을 위해 이 경우 알림에 대한 작업은 "\(n\)"을 포함하여 명시적으로 지정됩니다. 동작을 지정하지 않으면 이벤트에 관계없이 알림이 기본값으로 간주됩니다. 다른 조치를 원할 경우 명시적으로 명시해야 합니다.

이러한 요청에 대한 rgw1의 예상 응답은 다음과 같은 aaln/1의 승인입니다.

```text
      200 154 ok
```

그리고 aaln/2에서:

```text
      200 155 ok
```

4단계 RestartInProgress\(rsip\)를 rgw2에서 ca로

```text
      rsip 0 *@rgw2.whatever.net mgcp 1.0
      rm: restart
```

CA로부터의 승인이 뒤따릅니다.

```text
      200 0 ok
```

5단계 - ca에서 rgw2로의 AuditEndpoint\(auep\)

```text
      auep 156 *@rgw2.whatever.net mgcp 1.0
```

rgw2로부터의 승인이 뒤따릅니다:

```text
      200 156 ok
      z: aaln/1@rgw2.whatever.net
      z: aaln/2@rgw2.whatever.net
```

6단계 - ca에서 rgw2의 각 엔드포인트로의 알림 요청\(rqnt\)

```text
      rqnt 157 aaln/1@rgw2.whatever.net mgcp 1.0
      r: l/hd(n)
      x: 3456789a2

   followed by:

      rqnt 158 aaln/2@rgw2.whatever.net mgcp 1.0
      r: l/hd(n)
      x: 3456789a3
```

aaln/1을 승인하는 rgw2를 사용하여:

```text
      200 157 ok
```

그리고 aaln/2의 경우:

```text
      200 158 ok
```

---
### **G.1.2 Call Agent Restart**

다음 표는 통화 에이전트\(ca\)가 다시 시작될 때 발생하는 메시지 순서를 보여줍니다. 게이트웨이\(이 경우 rgw1 및 rgw2\)의 주소 정보를 결정하는 방법은 이 문서에서 다루지 않습니다. 상호 운용성을 위해 통화 에이전트가 AUEP\(\*\)를 특정 주소 및 포트로 보내도록 구성하는 기능을 제공하는 것이 좋습니다.\(SHOULD\)

```text
                  Table F.2: Residential Gateway Restart

 ---------------------------------------------------------------------
| # |     usr1    |    rgw1    |     ca     |    rgw2    |     usr2   |
|===|=============|============|============|============|============|
| 1 |             |            | <- auep    |            |            |
|   |             |     ack -> |            |            |            |
|---|-------------|------------|------------|------------|------------|
| 2+|             |            | <- rqnt    |            |            |
|   |             |     ack -> |            |            |            |
|---|-------------|------------|------------|------------|------------|
| 3 |             |            |    auep -> |            |            |
|   |             |            |            | <- ack     |            |
|---|-------------|------------|------------|------------|------------|
| 4+|             |            |    rqnt -> |            |            |
|   |             |            |            | <- ack     |            |
 ---------------------------------------------------------------------
```

1단계 - ca에서 rgw1로의 AuditEndpoint\(auep\)

명령은 다음으로 구성됩니다.

```text
      auep 0 *@rgw1.whatever.net mgcp 1.0
```

"\*"는 모든 엔드포인트의 rgw1에서 감사 정보를 요청하는 데 사용됩니다. rgw1은 명령의 트랜잭션 ID\(이 경우 0\)가 포함된 승인 메시지로 명령을 승인하며 엔드포인트 목록이 포함됩니다. 이 예에서 rgw1에는 aaln/1과 aaln/2라는 두 개의 엔드포인트가 있습니다.

```text
      200 0 ok
      z: aaln/1@rgw1.whatever.net
      z: aaln/2@rgw1.whatever.net
```

끝점 ID 목록이 있으면 ca는 "\*"가 지정된 끝점의 ID로 대체되는 개별 AuditEndpoint 명령을 보낼 수 있습니다. 이에 대한 응답으로 rgw1은 예제에 반환된 엔드포인트 ID 목록을 엔드포인트에 대해 요청된 정보로 바꿉니다. 이 선택적 메시지 교환은 이 예에 표시되지 않습니다.

2단계 - ca에서 rgw1로의 알림 요청\(rqnt\) 오프훅

이 경우 ca는 aaln/1에 대해 하나씩 두 개의 rqnt를 보냅니다.

```text
      rqnt 1 aaln/1@rgw1.whatever.net mgcp 1.0
      r: l/hd(n)
      x: 234567890
```

aaln/2에 대한 두 번째:

```text
      rqnt 2 aaln/2@rgw1.whatever.net mgcp 1.0
      r: l/hd(n)
      x: 234567891
```

이러한 요청에 대한 rgw1의 예상 응답은 다음과 같은 aaln/1의 승인입니다.

```text
      200 1 ok
```

그리고 aaln/2에서:

```text
      200 2 ok
```

3단계 - ca에서 rgw2로의 AuditEndpoint\(auep\)

```text
      auep 3 *@rgw2.whatever.net mgcp 1.0
```

rgw2로부터의 승인이 뒤따릅니다:

```text
      200 3 ok
      z: aaln/1@rgw2.whatever.net
      z: aaln/2@rgw2.whatever.net
```

4단계 - ca에서 rgw2의 각 엔드포인트로의 알림 요청\(rqnt\)

```text
      rqnt 4 aaln/1@rgw2.whatever.net mgcp 1.0
      r: l/hd(n)
      x: 234567892

   followed by:

      rqnt 5 aaln/2@rgw2.whatever.net mgcp 1.0
      r: l/hd(n)
      x: 234567893
```

aaln/1을 승인하는 rgw2를 사용하여:

```text
      200 4 ok
```

그리고 aaln/2의 경우:

```text
      200 5 ok
G.2 Connection Creation
```

---
### **G.2.1 Residential Gateway to Residential Gateway**

다음 표는 사용자\(usr1\)가 주거용 게이트웨이\(rgw1\)를 통해 다른 주거용 게이트웨이\(rgw2\)의 서비스를 받는 사용자에게 전화를 걸 때 발생하는 메시지 순서를 보여줍니다. 이 예에서는 주거용 게이트웨이와 통화 에이전트\(ca\) 간의 통신만 보여줍니다. 이 예에서 엔드포인트의 로컬 이름은 두 게이트웨이 모두에 대해 aaln/1이며, rgw1 및 rgw2에 대한 단계 설명 내 참조는 rgw1의 aaln/1 및 rgw2의 aaln/1을 참조하는 것으로 가정할 수 있습니다. 이는 단지 예시일 뿐이며 유일한 법적 통화 시나리오는 아닙니다.

```text
            Table F.3: Residential Gateway Connection Creation

 ---------------------------------------------------------------------
| # |     usr1    |    rgw1    |     ca     |    rgw2    |     usr2   |
|===|=============|============|============|============|============|
| 1 |  offhook -> |    ntfy -> |            |            |            |
|   |             |            | <- ack     |            |            |
|---|-------------|------------|------------|------------|------------|
| 2 | <- dialtone |            | <- rqnt    |            |            |
|   |             |     ack -> |            |            |            |
|---|-------------|------------|------------|------------|------------|
| 3 |   digits -> |    ntfy -> |            |            |            |
|   |             |            | <- ack     |            |            |
|---|-------------|------------|------------|------------|------------|
| 4 |             |            | <- rqnt    |            |            |
|   |             |     ack -> |            |            |            |
|---|-------------|------------|------------|------------|------------|
| 5 | <- recvonly |            | <- crcx    |            |            |
|   |             |     ack -> |            |            |            |
|---|-------------|------------|------------|------------|------------|
| 6 |             |            |    crcx -> |            | sendrcv -> |
|   |             |            |            | <- ack     |            |
|---|-------------|------------|------------|------------|------------|
| 7 | <- recvonly |            | <- mdcx    |            |            |
|   |             |     ack -> |            |            |            |
|---|-------------|------------|------------|------------|------------|
| 8 | <- ringback |            | <- rqnt    |            |            |
|   |             |     ack -> |            |            |            |
|---|-------------|------------|------------|------------|------------|
| 9 |             |            |    rqnt -> |            | ringing -> |
|   |             |            |            | <- ack     |            |
|---|-------------|------------|------------|------------|------------|
|10 |             |            |            | <- ntfy    | <- offhook |
|   |             |            |     ack -> |            |            |
|---|-------------|------------|------------|------------|------------|
|11 |             |            |    rqnt -> |            |            |
|   |             |            |            | <- ack     |            |
|---|-------------|------------|------------|------------|------------|
|12 |             |            | <- rqnt    |            |            |
|   |             |     ack -> |            |            |            |
|---|-------------|------------|------------|------------|------------|
|13 | <- sendrcv  |            | <- mdcx    |            |            |
|   |             |     ack -> |            |            |            |
 ---------------------------------------------------------------------
```

1단계 - rgw1에서 ca로 오프훅 알림\(ntfy\)

이 ntfy는 usr1이 오프훅 상태가 된 결과이며 ca가 이전에 오프훅이 발생할 경우 알림을 요청하는 rgw1에 RequestId "445678944"가 포함된 rqnt를 보냈다고 가정합니다.

```text
      ntfy 12 aaln/1@rgw1.whatever.net mgcp 1.0
      o: l/hd
      x: 445678944
```

CA의 승인:

```text
      200 12 ok
```

2단계 - ca에서 rgw1까지의 숫자에 대한 요청 알림\(rqnt\)

온훅 여부를 알리고 숫자 맵에 따라 숫자를 수집하고 발신음을 제공하도록 rgw1에 요청합니다.

```text
      rqnt 1057 aaln/1@rgw1.whatever.net mgcp 1.0
      r: l/hu(n), d/[0-9#*T](d)
      s: l/dl
      x: 445678945
      d: 5xxx
```

rgw1의 승인:

```text
      200 1057 ok
```

3단계 - rgw1의 숫자를 ca에 알림\(ntfy\)

```text
      ntfy 13 aaln/1@rgw1.whatever.net mgcp 1.0
      o: d/5, d/0, d/0, d/1
      x: 445678945
```

CA의 승인:

```text
      200 13 ok
```

4단계 - ca에서 rgw1로 알림\(rqnt\) 요청

온훅 전환 시 rgw1에 알리도록 요청합니다.

```text
      rqnt 1058 aaln/1@rgw1.whatever.net mgcp 1.0
      r: l/hu(n)
      x: 445678946
```

rgw1의 승인:

```text
      200 1058 ok
```

5단계 - ca에서 rgw1로의 연결\(crcx\) 만들기

패킷화 기간으로 20msec, 코덱으로 G.711 mu-law를 포함하여 지정된 로컬 연결 옵션을 사용하여 rgw1에서 새 연결을 요청하고 모드로만 수신합니다.

```text
      crcx 1059 aaln/1@rgw1.whatever.net mgcp 1.0
      c: 9876543210abcdef
      l: p:20, a:PCMU
      m: recvonly
```

새로운 연결 "456789fedcba5"가 생성되었음을 rgw1에서 확인하고 그 뒤에 빈 줄과 SDP 매개변수가 표시됩니다.

```text
      200 1059 ok
      i: 456789fedcba5
```

v=0

- o=- 23456789 98765432 IN IP4 192.168.5.7 s=- c=IN IP4 192.168.5.7 t=0 0 m=오디오 6058 RTP/AVP 0

6단계 - ca에서 rgw2로의 연결\(crcx\) 만들기

rgw2에서 새 연결을 요청합니다. 요청에는 양방향 연결이 시작될 수 있도록 rgw1에서 반환된 세션 설명이 포함됩니다.

```text
      crcx 2052 aaln/1@rgw2.whatever.net mgcp 1.0
      c: 9876543210abcdef
      l: p:20, a:PCMU
      m: sendrecv
```

v=0

- o=- 23456789 98765432 IN IP4 192.168.5.7 s=- c=IN IP4 192.168.5.7 t=0 0 m=오디오 6058 RTP/AVP 0

새로운 연결 "67890af54c9"가 생성되었음을 rgw2에서 확인합니다. 그 뒤에는 빈 줄이 있고 그 다음에는 SDP 매개변수가 있습니다.

```text
      200 2052 ok
      i: 67890af54c9
```

v=0

- o=- 23456889 98865432 IN IP4 192.168.5.8 s=- c=IN IP4 192.168.5.8 t=0 0 m=오디오 6166 RTP/AVP 0

7단계 - ca에서 rgw1로의 연결\(mdcx\) 수정

rgw1에게 기존 연결 "456789fedcba5"를 수정하도록 요청하여 rgw2가 반환한 세션 설명을 사용하여 반이중 연결을 설정합니다. 이 예에서는 사용되지 않았지만 usr1에 대역 내 링백 톤, 알림 등을 제공하는 데 사용할 수 있습니다.

```text
      mdcx 1060 aaln/1@rgw1.whatever.net mgcp 1.0
      c: 9876543210abcdef
      i: 456789fedcba5
      l: p:20, a:PCMU
      M: recvonly
```

v=0

- o=- 23456889 98865432 IN IP4 192.168.5.8 s=- c=IN IP4 192.168.5.8 t=0 0 m=오디오 6166 RTP/AVP 0

rgw1의 승인:

```text
      200 1060 ok
```

8단계 - 링백을 제공하기 위해 rgw1에 대해 ca에 알림\(rqnt\)을 요청합니다.

온훅 전환 시 이를 알리고 통화 연결음도 제공하도록 rgw1에 요청합니다.

```text
      rqnt 1061 aaln/1@rgw1.whatever.net mgcp 1.0
      r: l/hu(n)
      s: g/rt
      x: 445678947
```

rgw1의 승인:

```text
      200 1061 ok
```

9단계 - 벨소리 제공을 위해 ca에서 rgw2로 알림\(rqnt\) 요청

계속해서 오프훅을 찾고 벨소리를 제공하도록 rgw2에 요청합니다.

```text
      rqnt 2053 aaln/1@rgw2.whatever.net mgcp 1.0
      r: l/hd(n)
      s: l/rg
      x: 445678948
```

rgw2의 승인:

```text
      200 2053 ok
```

10단계 - rgw2에서 ca로 오프훅 알림\(ntfy\)

```text
      ntfy 27 aaln/1@rgw2.whatever.net mgcp 1.0
      o: l/hd
      x: 445678948
```

CA의 승인:

```text
      200 27 ok
```

11단계 - ca에서 rgw2로의 온훅 알림\(rqnt\) 요청

```text
      rqnt 2054 aaln/1@rgw2.whatever.net mgcp 1.0
      r: l/hu(n)
      x: 445678949
```

rgw2의 승인:

```text
      200 2054 ok
```

12단계 - ca에서 rgw1로의 온훅 알림\(rqnt\) 요청

```text
      rqnt 1062 aaln/1@rgw1.whatever.net mgcp 1.0
      r: l/hu(n)
      x: 445678950
```

rgw1의 승인:

```text
      200 1062 ok
```

13단계 - ca에서 rgw1로의 연결\(mdcx\) 수정

전이중 연결이 시작되도록 sendrecv에 대한 기존 연결 "456789fedcba5"를 수정하도록 rgw1에 요청합니다.

```text
      mdcx 1063 aaln/1@rgw1.whatever.net mgcp 1.0
      c: 9876543210abcdef
      i: 456789fedcba5
      m: sendrecv
```

rgw1의 승인:

```text
      200 1063 ok
```

---
## **G.3 Connection Deletion**
---
### **G.3.1 Residential Gateway to Residential Gateway**

다음 표는 사용자\(usr2\)가 다른 주거용 게이트웨이\(rgw1\)에서 서비스를 제공하는 사용자와 주거용 게이트웨이\(rgw2\)에서 기존 연결 삭제를 시작할 때 발생하는 메시지 순서를 보여줍니다. 이 예에서는 주거용 게이트웨이와 통화 에이전트\(ca\) 간의 통신만 보여줍니다. 이 예에서 엔드포인트의 로컬 이름은 두 게이트웨이 모두에 대해 aaln/1이며, rgw1 및 rgw2에 대한 단계 설명 내 참조는 rgw1의 aaln/1 및 rgw2의 aaln/1을 참조하는 것으로 가정할 수 있습니다.

```text
            Table F.4: Residential Gateway Connection Deletion

 ---------------------------------------------------------------------
| # |     usr1    |    rgw1    |     ca     |    rgw2    |     usr2   |
|===|=============|============|============|============|============|
| 1 |             |            |            | <- ntfy    | <- on-hook |
|   |             |            |     ack -> |            |            |
|---|-------------|------------|------------|------------|------------|
| 2 |             |            |    dlcx -> |            |            |
|   |             |            |            | <- ack     |            |
|---|-------------|------------|------------|------------|------------|
| 3 |             |            | <- dlcx    |            |            |
|   |             |     ack -> |            |            |            |
|---|-------------|------------|------------|------------|------------|
| 4 |             |            |    rqnt -> |            |            |
|   |             |            |            | <- ack     |            |
|---|-------------|------------|------------|------------|------------|
| 5 |  on-hook -> |    ntfy -> |            |            |            |
|   |             |            | <- ack     |            |            |
|---|-------------|------------|------------|------------|------------|
| 6 |             |            | <- rqnt    |            |            |
|   |             |     ack -> |            |            |            |
 ---------------------------------------------------------------------
```

1단계 - rgw1에서 ca로 오프훅 알림\(ntfy\)

이 ntfy는 usr2가 온훅된 결과이며 ca가 이전에 온훅 시 알림을 요청하는 rqnt를 rgw2에 보냈다고 가정합니다\(연결 생성 시퀀스의 끝 참조\).

```text
      ntfy 28 aaln/1@rgw2.whatever.net mgcp 1.0
      o: l/hu
      x: 445678949
```

CA의 승인:

```text
      200 28 ok
```

2단계 - ca에서 rgw2로의 연결\(dlcx\) 삭제

rgw2에 "67890af54c9" 연결을 삭제하도록 요청합니다.

```text
      dlcx 2055 aaln/1@rgw1.whatever.net mgcp 1.0
      c: 9876543210abcdef
      i: 67890af54c9
```

rgw2로부터의 승인. "연결이 삭제되었습니다"를 의미하는 응답 코드 "250"을 참고하세요.

```text
      250 2055 ok
```

3단계 - ca에서 rgw1로의 연결\(dlcx\) 삭제

rgw1에 "456789fedcba5" 연결을 삭제하도록 요청합니다.

```text
      dlcx 1064 aaln/1@rgw1.whatever.net mgcp 1.0
      c: 9876543210abcdef
      i: 456789fedcba5
```

rgw1의 승인:

```text
      250 1064 ok
```

4단계 - ca에서 rgw2로의 알림 요청\(rqnt\)

오프훅 전환 시 ca에 알리도록 rgw2에 요청합니다.

```text
      rqnt 2056 aaln/1@rgw2.whatever.net mgcp 1.0
      r: l/hd(n)
      x: 445678951
```

rgw2의 승인:

```text
      200 2056 ok
```

5단계 - rgw1에서 ca로 온훅 알림\(ntfy\)

rgw1의 usr1이 온훅 상태로 돌아갔음을 CA에 알립니다.

```text
      ntfy 15 aaln/1@rgw1.whatever.net mgcp 1.0
      o: l/hu
      x: 445678950
```

CA의 승인:

```text
      200 15 ok
```

6단계 - ca에서 rgw1로의 알림 요청\(rqnt\) 오프훅

오프훅 전환 시 ca에 알리도록 rgw1에 요청합니다.

```text
      rqnt 1065 aaln/1@rgw1.whatever.net mgcp 1.0
      r: l/hd(n)
      x: 445678952
```

rgw1의 승인:

```text
      200 1065 ok
```

---
# **Authors' Addresses**

```text
   Flemming Andreasen
   Cisco Systems
   499 Thornall Street, 8th Floor
   Edison, NJ 08837

   EMail: fandreas@cisco.com

   Bill Foster
   Cisco Systems
   771 Alder Drive
   Milpitas, CA 95035

   EMail: bfoster@cisco.com
```

---
# **Full Copyright Statement**

저작권\(C\)인터넷학회\(2003\). 판권 소유.

이 문서와 그 번역본은 복사되어 타인에게 제공될 수 있으며, 이에 대해 설명하거나 설명하거나 구현을 지원하는 파생물은 어떤 종류의 제한 없이 전체적으로 또는 부분적으로 준비, 복사, 출판 및 배포될 수 있습니다. , 단, 위의 저작권 표시와 이 단락은 그러한 모든 사본 및 파생물에 포함됩니다. 그러나 이 문서 자체는 인터넷 표준 개발 목적으로 필요한 경우를 제외하고는 저작권 표시를 제거하거나 Internet Society 또는 기타 인터넷 조직에 대한 참조를 제거하는 등 어떤 식으로든 수정할 수 없습니다. 인터넷 표준 프로세스를 따르거나 영어 이외의 언어로 번역하는 데 필요한 대로 따라야 합니다.

위에서 부여된 제한된 권한은 영구적이며 Internet Society 또는 그 승계자 또는 양수인에 의해 취소되지 않습니다.

이 문서와 여기에 포함된 정보는 "있는 그대로" 제공되며 인터넷 사회 및 인터넷 공학 태스크포스는 여기에 포함된 정보의 사용이 상품성 또는 특정 목적에의 적합성에 대한 권리 또는 묵시적 보증을 침해하는 행위.

---
# **Acknowledgement**

RFC 편집기 기능에 대한 자금은 현재 Internet Society에서 제공하고 있습니다.
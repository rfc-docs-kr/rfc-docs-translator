

```text
Internet Engineering Task Force (IETF)                  R. Fielding, Ed.
Request for Comments: 7232                                         Adobe
Obsoletes: 2616                                          J. Reschke, Ed.
Category: Standards Track                                     greenbytes
ISSN: 2070-1721                                                June 2014

      Hypertext Transfer Protocol (HTTP/1.1): Conditional Requests
```

---
# **Abstract**

HTTP\(Hypertext Transfer Protocol\)는 분산, 협업, 하이퍼텍스트 정보 시스템을 위한 상태 비저장 애플리케이션 수준 프로토콜입니다. 이 문서는 상태 변경을 나타내는 메타데이터 헤더 필드, 그러한 상태에 대한 전제 조건을 만들기 위한 요청 헤더 필드, 하나 이상의 전제 조건이 false로 평가될 때 조건부 요청에 대한 응답을 구성하기 위한 규칙을 포함하여 HTTP/1.1 조건부 요청을 정의합니다.

---
# **Status of This Memo**

이것은 인터넷 표준 추적 문서입니다.

이 문서는 IETF\(Internet Engineering Task Force\)의 제품입니다. 이는 IETF 커뮤니티의 합의를 나타냅니다. 공개 검토를 받았으며 IESG\(Internet Engineering Steering Group\)의 출판 승인을 받았습니다. 인터넷 표준에 대한 자세한 내용은 RFC 5741의 섹션 2에서 확인할 수 있습니다.

이 문서의 현재 상태, 정오표, 피드백 제공 방법에 대한 정보는 http://www.rfc-editor.org/info/rfc7232에서 얻을 수 있습니다.

---
# **Copyright Notice**

Copyright \(c\) 2014 IETF Trust 및 문서 작성자로 식별된 사람. 판권 소유.

이 문서는 이 문서의 발행일에 유효한 BCP 78 및 IETF 문서에 관한 IETF 트러스트의 법적 조항\(http://trustee.ietf.org/license-info\)의 적용을 받습니다. 이 문서와 관련된 귀하의 권리 및 제한 사항을 설명하므로 이 문서를 주의 깊게 검토하십시오. 이 문서에서 추출한 코드 구성 요소는 Trust Legal Provisions의 섹션 4.e에 설명된 대로 Simplified BSD License 텍스트를 포함해야 하며 Simplified BSD License에 설명된 대로 보증 없이 제공됩니다.

이 문서에는 2008년 11월 10일 이전에 공개되거나 공개된 IETF 문서 또는 IETF 기고문의 자료가 포함될 수 있습니다. 이 자료의 일부에 대한 저작권을 제어하는 ​​사람은 해당 자료의 수정을 허용할 권리를 IETF 트러스트에 부여하지 않았을 수 있습니다. IETF 표준 프로세스 외부. 이러한 자료의 저작권을 관리하는 사람으로부터 적절한 라이센스를 얻지 않고 이 문서는 IETF 표준 프로세스 외부에서 수정할 수 없으며 IETF 표준 프로세스 외부에서 이 문서의 파생물을 생성할 수 없습니다. RFC로 게시하거나 영어 이외의 언어로 번역합니다.

---
# **Table of Contents**

```text
   1. Introduction ....................................................4
      1.1. Conformance and Error Handling .............................4
      1.2. Syntax Notation ............................................4
   2. Validators ......................................................5
      2.1. Weak versus Strong .........................................5
      2.2. Last-Modified ..............................................7
           2.2.1. Generation ..........................................7
           2.2.2. Comparison ..........................................8
      2.3. ETag .......................................................9
           2.3.1. Generation .........................................10
           2.3.2. Comparison .........................................10
           2.3.3. Example: Entity-Tags Varying on
                  Content-Negotiated Resources .......................11
      2.4. When to Use Entity-Tags and Last-Modified Dates ...........12
   3. Precondition Header Fields .....................................13
      3.1. If-Match ..................................................13
      3.2. If-None-Match .............................................14
      3.3. If-Modified-Since .........................................16
      3.4. If-Unmodified-Since .......................................17
      3.5. If-Range ..................................................18
   4. Status Code Definitions ........................................18
      4.1. 304 Not Modified ..........................................18
      4.2. 412 Precondition Failed ...................................19
   5. Evaluation .....................................................19
   6. Precedence .....................................................20
   7. IANA Considerations ............................................22
      7.1. Status Code Registration ..................................22
      7.2. Header Field Registration .................................22
   8. Security Considerations ........................................22
   9. Acknowledgments ................................................23
   10. References ....................................................24
      10.1. Normative References .....................................24
      10.2. Informative References ...................................24
   Appendix A. Changes from RFC 2616 .................................25
   Appendix B. Imported ABNF .........................................25
   Appendix C. Collected ABNF ........................................26
   Index .............................................................27
```

---
## **1.  Introduction**

조건부 요청은 대상 리소스에 메서드 의미론을 적용하기 전에 테스트할 전제 조건을 나타내는 하나 이상의 헤더 필드를 포함하는 HTTP 요청\[RFC7231\]입니다. 이 문서는 \[RFC7230\]에 정의된 아키텍처, 구문 표기 및 적합성 기준 측면에서 HTTP/1.1 조건부 요청 메커니즘을 정의합니다.

조건부 GET 요청은 HTTP 캐시 업데이트\[RFC7234\]를 위한 가장 효율적인 메커니즘입니다. "업데이트 손실" 문제를 방지하기 위해 PUT 및 DELETE와 같은 상태 변경 메서드에 조건문을 적용할 수도 있습니다. 즉, 한 클라이언트가 병렬로 작동하던 다른 클라이언트의 작업을 실수로 덮어쓰는 문제입니다.

조건부 요청 사전 조건은 전체 대상 리소스의 상태\(현재 값 세트\) 또는 이전에 얻은 표현에서 관찰된 상태\(해당 세트의 하나의 값\)를 기반으로 합니다. 리소스에는 각각 관찰 가능한 상태가 있는 여러 현재 표현이 있을 수 있습니다. 조건부 요청 메커니즘은 서버가 조건을 활용하려는 경우 "선택된 표현"\(\[RFC7231\]의 섹션 3\)에 대한 요청 매핑이 시간이 지남에 따라 일관될 것이라고 가정합니다. 그럼에도 불구하고 매핑이 일관되지 않고 서버가 적절한 표현을 선택할 수 없는 경우 전제 조건이 false로 평가되면 아무런 해가 발생하지 않습니다.

본 사양\(섹션 3\)에 정의된 조건부 요청 전제 조건은 우선 순위\(섹션 6\)에 따라 수신자\(섹션 5\)에 적용될 때 평가됩니다.

---
### **1.1.  Conformance and Error Handling**

이 문서에서 키워드 "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY" 및 "OPTIONAL"은 다음과 같습니다. \[RFC2119\]에 설명된 대로 해석됩니다.\(MUST NOT\)

오류 처리에 관한 적합성 기준 및 고려 사항은 \[RFC7230\]의 섹션 2.5에 정의되어 있습니다.

---
### **1.2.  Syntax Notation**

이 사양은 \[RFC7230\]의 섹션 7에 정의된 목록 확장과 함께 \[RFC5234\]의 ABNF\(Augmented Backus-Naur Form\) 표기법을 사용합니다. 이는 '#' 연산자를 사용하여 쉼표로 구분된 목록의 간결한 정의를 허용합니다\( '\*' 연산자가 나타내는 방법

되풀이\). 부록 B에서는 다른 문서에서 가져온 규칙을 설명합니다. 부록 C는 표준 ABNF 표기법으로 확장된 모든 목록 연산자와 함께 수집된 문법을 보여줍니다.

---
## **2.  Validators**

이 사양은 리소스 상태를 관찰하고 전제 조건을 테스트하는 데 일반적으로 사용되는 두 가지 형태의 메타데이터, 즉 수정 날짜\(섹션 2.2\)와 불투명 엔터티 태그\(섹션 2.3\)를 정의합니다. 리소스 상태를 반영하는 추가 메타데이터는 이 사양의 범위를 벗어나는 WebDAV, \[RFC4918\]\(Web Distributed Authoring and Versioning\)과 같은 다양한 HTTP 확장에 의해 정의되었습니다. 리소스 메타데이터 값은 전제 조건 내에서 사용될 때 "유효성 검사기"라고 합니다.

---
### **2.1.  Weak versus Strong**

유효성 검사기는 강함과 약함의 두 가지 형태로 제공됩니다. 약한 유효성 검사기는 생성하기 쉽지만 비교에 훨씬 덜 유용합니다. 강력한 유효성 검사기는 비교에 이상적이지만 효율적으로 생성하기가 매우 어려울 수 있습니다\(때로는 불가능할 수도 있음\). 모든 형태의 리소스가 동일한 유효성 검사기 강도를 준수하도록 강요하는 대신 HTTP는 사용 중인 유효성 검사기 유형을 노출하고 약한 유효성 검사기를 전제 조건으로 사용할 수 있는 경우에 대한 제한을 부과합니다.

"강력한 유효성 검사기"는 GET에 대한 200\(OK\) 응답의 페이로드 본문에서 관찰할 수 있는 표현 데이터에 변경이 발생할 때마다 값을 변경하는 표현 메타데이터입니다.

강력한 유효성 검사기는 표현 메타데이터의 의미상 중요한 부분\(예: Content-Type\)이 변경되는 경우와 같이 표현 데이터 변경 이외의 이유로 변경될 수 있지만 원서버의 최선의 이익은 다음과 같습니다. 원격 캐시 및 작성 도구에 저장된 응답을 무효화해야 하는 경우 값을 변경하십시오.

캐시 항목은 만료 시간에 관계없이 임의로 장기간 지속될 수 있습니다. 따라서 캐시는 먼 과거에 얻은 유효성 검사기를 사용하여 항목의 유효성을 검사하려고 시도할 수 있습니다. 강력한 유효성 검사기는 시간이 지남에 따라 특정 리소스와 관련된 모든 표현의 모든 버전에서 고유합니다. 그러나 서로 다른 리소스의 표현에 걸쳐 고유성을 암시하는 것은 없습니다\(즉, 동일한 강력한 유효성 검사기가 여러 리소스의 표현에 동시에 사용될 수 있으며 해당 표현이 동일하다는 것을 의미하지 않습니다\).

실제로 사용되는 다양한 강력한 유효성 검사기가 있습니다. 가장 좋은 방법은 엄격한 개정 제어를 기반으로 하며, 표현에 대한 각 변경으로 인해 해당 표현이 GET에 액세스 가능해지기 전에 항상 고유한 노드 이름과 개정 식별자가 할당됩니다. 응답 헤더 필드가 전송되기 전에 데이터를 사용할 수 있고 유효성 검사 요청이 수신될 때마다 다이제스트를 다시 계산할 필요가 없는 경우 표현 데이터에 적용되는 충돌 방지 해시 함수로도 충분합니다. 그러나 리소스에 메타데이터만 다른 고유한 표현이 있는 경우\(예: 동일한 데이터 형식을 공유하는 미디어 유형에 대한 콘텐츠 협상에서 발생할 수 있음\) 원서버는 해당 표현을 구별하기 위해 유효성 검사기에 추가 정보를 통합해야 합니다. .

이와 대조적으로 "약한 유효성 검사기"는 표현 데이터가 변경될 때마다 변경되지 않을 수 있는 표현 메타데이터입니다. 이 약점은 클록 분해능, 리소스의 가능한 모든 표현에 대한 고유성을 보장할 수 없음, 리소스 소유자가 자체적으로 결정한 등가성 집합으로 표현을 그룹화하려는 욕구 등 값 계산 방법의 제한으로 인해 발생할 수 있습니다. 고유한 데이터 시퀀스가 ​​아닌 원서버는 이전 표현이 현재 표현을 대체할 수 없다고 생각할 때마다 약한 엔터티 태그를 변경해야 합니다\(SHOULD\). 즉, 약한 엔터티 태그는 원본 서버가 캐시를 통해 이전 응답을 무효화하기를 원할 때마다 변경되어야 합니다.\(SHOULD\)

예를 들어, 동적 측정을 기반으로 매초 콘텐츠가 변경되는 일기 예보의 표현은 캐시된 표현이 유효하도록 허용하기 위해 동일한 약한 유효성 검사기를 사용하여 원본 서버의 관점에서 동등한 표현 세트로 그룹화될 수 있습니다. 합리적인 기간 동안\(서버 로드나 날씨 품질에 따라 동적으로 조정될 수 있음\) 마찬가지로 표현의 수정 시간은 1초 분해능으로만 정의된 경우 표현이 1초 동안 두 번 수정되고 해당 수정 사이에서 검색될 수 있는 경우 약한 유효성 검사기가 될 수 있습니다.

마찬가지로, 해당 표현이 동일한 표현 데이터를 갖지 않는 한, 주어진 리소스에 대한 두 개 이상의 표현이 동시에 공유되는 경우 유효성 검사기는 약합니다. 예를 들어 원본 서버가 콘텐츠 코딩이 없는 표현과 마찬가지로 gzip 콘텐츠 코딩이 적용된 표현에 대해 동일한 유효성 검사기를 보내는 경우 해당 유효성 검사기는 약합니다. 그러나 두 개의 동시 표현은 동일한 표현 데이터에 대해 두 개의 다른 미디어 유형을 사용할 수 있는 경우와 같이 표현 메타데이터만 다른 경우 동일한 강력한 유효성 검사기를 공유할 수 있습니다.

캐시 유효성 검사, 부분 콘텐츠 범위 및 "업데이트 손실" 방지를 포함한 모든 조건부 요청에 대해 강력한 유효성 검사기를 사용할 수 있습니다. 약한 유효성 검사기는 캐시 항목의 유효성을 검사하거나 웹 탐색을 최근 변경 사항으로 제한하는 경우와 같이 클라이언트가 이전에 얻은 표현 데이터와의 정확한 동일성을 요구하지 않는 경우에만 사용할 수 있습니다.

---
### **2.2.  Last-Modified**

응답의 "Last-Modified" 헤더 필드는 요청 처리가 끝날 때 결정된 대로 원서버가 선택한 표현이 마지막으로 수정되었다고 믿는 날짜와 시간을 나타내는 타임스탬프를 제공합니다.

```text
     Last-Modified = HTTP-date
```

그 사용 예는 다음과 같습니다.

```text
     Last-Modified: Tue, 15 Nov 1994 12:45:26 GMT
```

---
#### **2.2.1.  Generation**

원서버는 마지막 수정 날짜가 합리적이고 일관되게 결정될 수 있는 선택된 표현에 대해 Last-Modified를 전송해야 합니다. 왜냐하면 조건부 요청 및 캐시 신선도 평가\(\[RFC7234\]\)에 사용하면 HTTP 트래픽이 크게 감소하기 때문입니다. 인터넷은 서비스 확장성과 안정성을 향상시키는 중요한 요소가 될 수 있습니다.\(SHOULD\)

표현은 일반적으로 리소스 인터페이스 뒤에 있는 여러 부분의 합계입니다. 마지막 수정 시간은 일반적으로 해당 부분이 변경된 가장 최근 시간입니다. 특정 리소스에 대해 해당 값이 결정되는 방법은 이 사양의 범위를 벗어나는 구현 세부 사항입니다. HTTP에 중요한 것은 Last-Modified 헤더 필드의 수신자가 해당 값을 사용하여 조건부 요청을 만들고 로컬로 캐시된 응답의 유효성을 테스트하는 방법입니다.

원서버는 응답에 대한 Date 필드 값을 생성하는 시간에 최대한 가까운 표현의 Last-Modified 값을 얻어야 합니다\(SHOULD\). 이를 통해 수신자는 특히 응답이 생성되는 시간 근처에 표현이 변경되는 경우 표현의 수정 시간을 정확하게 평가할 수 있습니다.\(SHOULD\)

시계가 있는 원서버는 서버의 메시지 발생 시간\(날짜\)보다 이후의 최종 수정 날짜를 보내서는 안 됩니다. 마지막 수정 시간이 구현별 시간에서 파생된 경우\(MUST NOT\)

원서버의 시계에 따라 미래의 특정 시간으로 평가되는 메타데이터인 경우 원서버는 해당 값을 메시지 발생 날짜로 바꿔야 합니다. 이렇게 하면 향후 수정 날짜가 캐시 유효성 검사에 부정적인 영향을 미치는 것을 방지할 수 있습니다.\(MUST\)

시계가 없는 원서버는 이러한 값이 신뢰할 수 있는 시계를 가진 다른 시스템이나 사용자에 의해 리소스와 연결되지 않는 한 응답에 Last-Modified 값을 할당해서는 안 됩니다.\(MUST NOT\)

---
#### **2.2.2.  Comparison**

요청에서 유효성 검사기로 사용되는 Last-Modified 시간은 다음 규칙을 사용하여 강력하다고 추론할 수 없는 한 암시적으로 약합니다.

o 유효성 검사기는 원서버에 의해 표현에 대한 실제 현재 유효성 검사기와 비교됩니다.

o 해당 원본 서버는 관련 항목이 무엇인지 확실하게 알고 있습니다.

- 제시된 검증자가 두 번째로 커버하는 동안 표현은 두 번 변경되지 않았습니다.

```text
   or
```

o 검증자는 클라이언트에 의해 곧 사용될 예정입니다.

- If-Modified-Since, If-Unmodified-Since 또는 If-Range 헤더 필드\(클라이언트가 관련 표현에 대한 캐시 항목을 갖고 있기 때문\)

o 해당 캐시 항목에는 원본 서버가 원래 응답을 보낸 시간을 제공하는 날짜 값이 포함되어 있습니다.

o 표시된 최종 수정 시간은 날짜 값보다 최소 60초 전입니다.

```text
   or
```

o 검증자는 중간 캐시에 의해 표현을 위한 캐시 항목에 저장된 검증자와 비교됩니다.

o 해당 캐시 항목에는 원본 서버가 원래 응답을 보낸 시간을 제공하는 날짜 값이 포함되어 있습니다.

o 표시된 최종 수정 시간은 날짜 값보다 최소 60초 전입니다.

이 방법은 동일한 초 동안 원본 서버에서 두 개의 서로 다른 응답을 보냈지만 둘 다 동일한 Last-Modified 시간을 가졌다면 해당 응답 중 적어도 하나는 Last-Modified와 동일한 Date 값을 갖는다는 사실에 의존합니다. 시간. 임의의 60초 제한은 응답을 준비하는 동안 Date 및 Last-Modified 값이 다른 시계 또는 다소 다른 시간에 생성될 가능성을 방지합니다. 60초가 너무 짧다고 판단되는 경우 구현에서는 60초보다 큰 값을 사용할 수 있습니다.\(MAY\)

---
### **2.3.  ETag**

응답의 "ETag" 헤더 필드는 요청 처리가 끝날 때 결정된 대로 선택된 표현에 대한 현재 엔터티 태그를 제공합니다. 엔터티 태그는 시간이 지남에 따라 여러 표현이 리소스 상태 변경으로 인한 것인지, 여러 표현이 동시에 유효한 콘텐츠 협상으로 인한 것인지, 또는 둘 다로 인한 것인지 여부에 관계없이 동일한 리소스의 여러 표현을 구별하기 위한 불투명한 유효성 검사기입니다. 엔터티 태그는 불투명한 인용 문자열로 구성되며, 앞에 약점 표시자가 붙을 수도 있습니다.

```text
     ETag       = entity-tag

     entity-tag = [ weak ] opaque-tag
     weak       = %x57.2F ; "W/", case-sensitive
     opaque-tag = DQUOTE *etagc DQUOTE
     etagc      = %x21 / %x23-7E / obs-text
                ; VCHAR except double quotes, plus obs-text
```

- 참고: 이전에는 opaque-tag가 quoted-string으로 정의되었습니다\(\[RFC2616\], 섹션 3.11\). 따라서 일부 수신자는 백슬래시 이스케이프 해제를 수행할 수 있습니다. 따라서 서버는 엔터티 태그에 백슬래시 문자를 사용하지 않아야 합니다.

수정 날짜를 저장하는 것이 불편하거나, HTTP 날짜 값의 1초 해상도가 충분하지 않거나, 수정 날짜가 일관되게 유지되지 않는 상황에서 엔터티 태그는 수정 날짜보다 유효성 검사에 더 신뢰할 수 있습니다.

```text
   Examples:

     ETag: "xyzzy"
     ETag: W/"xyzzy"
     ETag: ""
```

엔터티 태그는 약하거나 강한 유효성 검사기일 수 있으며 기본값은 강함입니다. 원서버가 표현을 위해 엔터티 태그를 제공하고 해당 엔터티 태그의 생성이 강력한 유효성 검사기\(섹션 2.1\)의 모든 특성을 충족하지 않는 경우 원서버는 접두사를 붙여 엔터티 태그를 약한 것으로 표시해야 합니다. 불투명한 값은 "W/"\(대소문자 구분\)입니다.\(MUST\)

---
#### **2.3.1.  Generation**

엔터티 태그의 기본 원칙은 서비스 작성자만이 해당 리소스에 대해 가장 정확하고 효율적인 유효성 검사 메커니즘을 선택할 수 있을 만큼 리소스의 구현을 잘 알고 있으며 이러한 메커니즘은 쉽게 비교할 수 있도록 간단한 옥텟 시퀀스에 매핑될 수 있다는 것입니다. . 값이 불투명하기 때문에 클라이언트는 각 엔터티 태그가 어떻게 구성되는지 알 필요가 없습니다.

예를 들어, 모든 변경 사항에 구현별 버전 관리가 적용되는 리소스는 표현을 정확하게 구별하기 위해 콘텐츠 협상을 위한 차이 식별자와 결합된 내부 개정 번호를 사용할 수 있습니다. 다른 구현에서는 표현 콘텐츠의 충돌 방지 해시, 다양한 파일 속성의 조합 또는 1초 미만의 해상도를 갖는 수정 타임스탬프를 사용할 수 있습니다.

조건부 요청 및 캐시 신선도 평가\(\[RFC7234\]\)에서 엔터티 태그를 사용하면 HTTP 네트워크가 크게 줄어들 수 있으므로 원서버는 변경 감지가 합리적이고 일관되게 결정될 수 있는 선택된 표현에 대해 ETag를 보내야 합니다. 트래픽을 증가시키며 서비스 확장성과 안정성을 향상시키는 중요한 요소가 될 수 있습니다.\(SHOULD\)

---
#### **2.3.2.  Comparison**

비교 컨텍스트가 약한 유효성 검사기 사용을 허용하는지 여부에 따라 두 가지 엔터티 태그 비교 함수가 있습니다.

o 강력한 비교: 두 엔터티 태그가 모두 약하지 않고 불투명 태그가 문자별로 일치하는 경우 두 엔터티 태그는 동일합니다.

o 약한 비교: 두 개의 엔터티 태그는 다음과 같은 경우 동일합니다.

- 불투명 태그는 둘 중 하나 또는 둘 모두가 "약함"으로 태그 지정되었는지 여부에 관계없이 문자별로 일치합니다.

아래 예는 엔터티-태그 쌍 집합에 대한 결과와 약한 비교 함수 결과와 강한 비교 함수 결과를 보여줍니다.

```text
   +--------+--------+-------------------+-----------------+
   | ETag 1 | ETag 2 | Strong Comparison | Weak Comparison |
   +--------+--------+-------------------+-----------------+
   | W/"1"  | W/"1"  | no match          | match           |
   | W/"1"  | W/"2"  | no match          | no match        |
   | W/"1"  | "1"    | no match          | match           |
   | "1"    | "1"    | match             | match           |
   +--------+--------+-------------------+-----------------+
```

---
#### **2.3.3.  Example: Entity-Tags Varying on Content-Negotiated Resources**

콘텐츠 협상\(\[RFC7231\]의 섹션 3.4\)이 적용되고 GET 요청에 대한 응답으로 전송된 표현이 Accept-Encoding 요청 헤더 필드\(\[RFC7231\]의 섹션 5.3.4\)에 따라 달라지는 리소스를 고려해보세요.

```text
   >> Request:

     GET /index HTTP/1.1
     Host: www.example.com
     Accept-Encoding: gzip
```

이 경우 응답은 gzip 콘텐츠 코딩을 사용할 수도 있고 사용하지 않을 수도 있습니다. 그렇지 않은 경우 응답은 다음과 같습니다.

```text
   >> Response:

     HTTP/1.1 200 OK
     Date: Fri, 26 Mar 2010 00:05:00 GMT
     ETag: "123-a"
     Content-Length: 70
     Vary: Accept-Encoding
     Content-Type: text/plain

     Hello World!
     Hello World!
     Hello World!
     Hello World!
     Hello World!
```

gzip 콘텐츠 코딩을 사용하는 대체 표현은 다음과 같습니다.

```text
   >> Response:

     HTTP/1.1 200 OK
     Date: Fri, 26 Mar 2010 00:05:00 GMT
     ETag: "123-b"
     Content-Length: 43
     Vary: Accept-Encoding
     Content-Type: text/plain
     Content-Encoding: gzip

     ...binary data...
```

- 참고: 콘텐츠 코딩은 표현 데이터의 속성이므로 콘텐츠 인코딩 표현에 대한 강력한 엔터티 태그는 캐시 업데이트 및 범위 요청 중에 잠재적인 충돌을 방지하기 위해 인코딩되지 않은 표현의 엔터티 태그와 구별되어야 합니다. 대조적으로, 전송 코딩\(\[RFC7230\]의 섹션 4\)은 메시지 전송 중에만 적용되며 별개의 엔터티 태그가 생성되지 않습니다.

---
### **2.4.  When to Use Entity-Tags and Last-Modified Dates**

GET 또는 HEAD에 대한 200\(OK\) 응답에서 원본 서버는 다음을 수행합니다.

o 엔터티 태그 유효성 검사기를 생성하는 것이 가능하지 않은 한 엔터티 태그 유효성 검사기를 보내야 합니다.\(SHOULD\)

o 성능 고려 사항이 약한 엔터티 태그 사용을 지원하거나 강력한 엔터티 태그를 보내는 것이 실행 불가능한 경우 강력한 엔터티 태그 대신 약한 엔터티 태그를 보낼 수 있습니다.\(MAY\)

o 전송이 가능하다면 Last-Modified 값을 전송해야 합니다\(SHOULD\).\(SHOULD\)

즉, 원본 서버에서 선호되는 동작은 검색 요청에 대한 성공적인 응답으로 강력한 엔터티 태그와 Last-Modified 값을 모두 보내는 것입니다.

클라이언트:

o 원본 서버에서 엔터티 태그를 제공한 경우 모든 캐시 유효성 검사 요청\(If-Match 또는 If-None-Match 사용\)에서 해당 엔터티 태그를 보내야 합니다.\(MUST\)

o 하위 범위가 아닌 캐시에 마지막 수정 값을 보내야 합니다\(SHOULD\).

- 원본 서버에서 Last-Modified 값만 제공한 경우 유효성 검사 요청\(If-Modified-Since 사용\)\(SHOULD\)

o HTTP/1.0 원본 서버에서 Last-Modified 값만 제공한 경우 하위 범위 캐시 유효성 검사 요청에서 Last-Modified 값을 보낼 수 있습니다\(If-Unmodified-Since 사용\). 사용자 에이전트는 어려움이 있는 경우 이를 비활성화하는 방법을 제공해야 합니다\(SHOULD\).\(MAY, SHOULD\)

o 원본 서버에서 엔터티 태그와 Last-Modified 값을 모두 제공한 경우 캐시 유효성 검사 요청에 두 유효성 검사기를 모두 보내야 합니다. 이를 통해 HTTP/1.0 및 HTTP/1.1 캐시가 모두 적절하게 응답할 수 있습니다.\(SHOULD\)

---
## **3.  Precondition Header Fields**

이 섹션에서는 요청에 전제 조건을 적용하기 위한 HTTP/1.1 헤더 필드의 구문과 의미를 정의합니다. 5절에서는 전제조건이 적용되는 시기를 정의합니다. 섹션 6에서는 둘 이상의 전제 조건이 존재할 때 평가 순서를 정의합니다.

---
### **3.1.  If-Match**

"If-Match" 헤더 필드는 필드 값이 "\*"일 때 대상 리소스의 현재 표현을 하나 이상 가지거나, 대상 리소스의 현재 표현을 가지거나 수신자 원본 서버에서 요청 방법을 조건부로 만듭니다. 필드 값에 제공된 엔터티 태그 목록의 구성원과 일치하는 엔터티 태그가 있습니다.

원서버는 If-Match\(Section 2.3.2\)에 대한 엔터티 태그를 비교할 때 강력한 비교 기능을 사용해야 합니다. 클라이언트는 표현 데이터에 변경 사항이 있는 경우 메서드가 적용되는 것을 방지하기 위해 이 전제 조건을 의도하기 때문입니다.\(MUST\)

```text
     If-Match = "*" / 1#entity-tag

   Examples:

     If-Match: "xyzzy"
     If-Match: "xyzzy", "r2d2xxxx", "c3piozzzz"
     If-Match: *
```

If-Match는 여러 사용자 에이전트가 동일한 리소스\(예:

"업데이트 손실" 문제를 방지하세요\). 선택한 표현이 이전 요청에서 이미 저장된\(또는 부분적으로 저장된\) 표현과 일치하지 않는 경우 요청을 중단하는 안전한 방법과 함께 사용할 수도 있습니다.

If-Match 헤더 필드를 수신한 원서버는 방법을 수행하기 전에 조건을 평가해야 합니다\(Section 5\). field-value가 "\*"인 경우 원본 서버에 대상 리소스에 대한 현재 표현이 없으면 조건은 false입니다. field-value가 엔터티 태그 목록인 경우 나열된 태그 중 선택한 표현의 엔터티 태그와 일치하는 태그가 없으면 조건은 false입니다.\(MUST\)

수신된 If-Match 조건이 false로 평가되는 경우 원서버는 요청된 방법을 수행해서는 안 됩니다. 대신, 원서버는 상태 변경이 요청되고 있고 최종 상태가 이미 있음을 원서버가 확인한 경우 a\) 412\(전제조건 실패\) 상태 코드 또는 b\) 2xx\(성공\) 상태 코드 중 하나로 응답해야 합니다. 대상 리소스의 현재 상태에 반영됩니다. 즉, 사용자 에이전트가 요청한 변경이 이미 성공했지만 사용자 에이전트는 이를 인식하지 못할 수 있습니다. 아마도 이전 응답이 손실되었거나 다른 사용자에 의해 호환 가능한 변경이 이루어졌기 때문일 수 있습니다. 사용자 에이전트\). 후자의 경우, 원서버는 요청이 동일한 사용자 에이전트에 의해 수행된 직전 변경 사항과 중복된다는 것을 확인할 수 없는 한 응답에 유효성 검사기 헤더 필드를 전송해서는 안 됩니다.\(MUST NOT, MUST NOT\)

If-Match 헤더 필드는 저장된 응답에 적용할 수 없기 때문에 캐시와 중개자에 의해 무시될 수 있습니다.

---
### **3.2.  If-None-Match**

"If-None-Match" 헤더 필드는 필드 값이 "\*"일 때 대상 리소스에 대한 현재 표현이 없거나 선택된 표현이 있는 수신자 캐시 또는 원서버에 대한 요청 방법을 조건부로 만듭니다. 필드 값에 나열된 항목과 일치하지 않는 엔터티 태그입니다.

수신자는 If-None-Match\(섹션 2.3.2\)에 대한 엔터티 태그를 비교할 때 약한 비교 기능을 사용해야 합니다. 약한 엔터티 태그는 표현 데이터가 변경된 경우에도 캐시 유효성 검사에 사용될 수 있기 때문입니다.\(MUST\)

```text
     If-None-Match = "*" / 1#entity-tag

   Examples:

     If-None-Match: "xyzzy"
     If-None-Match: W/"xyzzy"
     If-None-Match: "xyzzy", "r2d2xxxx", "c3piozzzz"
     If-None-Match: W/"xyzzy", W/"r2d2xxxx", W/"c3piozzzz"
     If-None-Match: *
```

If-None-Match는 최소한의 트랜잭션 오버헤드로 캐시된 정보를 효율적으로 업데이트할 수 있도록 조건부 GET 요청에 주로 사용됩니다. 클라이언트가 엔터티 태그가 있는 하나 이상의 저장된 응답을 업데이트하려는 경우 클라이언트는 GET 요청을 할 때 해당 엔터티 태그 목록이 포함된 If-None-Match 헤더 필드를 생성해야 합니다. 이를 통해 수신자 서버는 저장된 응답 중 하나가 선택한 표현과 일치하는 경우를 나타내기 위해 304\(수정되지 않음\) 응답을 보낼 수 있습니다.\(SHOULD\)

If-None-Match는 클라이언트가 리소스에 현재 표현이 없다고 믿을 때 안전하지 않은 요청 메서드\(예: PUT\)가 대상 리소스의 기존 표현을 실수로 수정하는 것을 방지하기 위해 "\*" 값과 함께 사용할 수도 있습니다. \(\[RFC7231\]의 섹션 4.2.1\). 이는 둘 이상의 클라이언트가 대상 리소스에 대한 초기 표현을 생성하려고 시도하는 경우 발생할 수 있는 "업데이트 손실" 문제의 변형입니다.

If-None-Match 헤더 필드를 수신한 원서버는 방법을 수행하기 전에 조건을 평가해야 합니다\(Section 5\). field-value가 "\*"인 경우 원본 서버에 대상 리소스에 대한 현재 표현이 있으면 조건은 false입니다. field-value가 엔터티 태그 목록인 경우 나열된 태그 중 하나가 선택한 표현의 엔터티 태그와 일치하면 조건은 false입니다.\(MUST\)

조건이 false로 평가되면 원본 서버는 요청된 메서드를 수행해서는 안 됩니다. 대신 원서버는 a\) 요청 방법이 GET 또는 HEAD인 경우 304\(수정되지 않음\) 상태 코드 또는 b\) 다른 모든 요청 방법에 대해 412\(전제 조건 실패\) 상태 코드로 응답해야 합니다.\(MUST NOT\)

수신된 If-None-Match 헤더 필드의 캐시 처리에 대한 요구 사항은 \[RFC7234\]의 섹션 4.3.2에 정의되어 있습니다.

---
### **3.3.  If-Modified-Since**

"If-Modified-Since" 헤더 필드는 선택된 표현의 수정 날짜가 필드 값에 제공된 날짜보다 더 최근이라는 조건에 따라 GET 또는 HEAD 요청 메소드를 조건부로 만듭니다. 해당 데이터가 변경되지 않은 경우 선택한 표현의 데이터 전송이 방지됩니다.

```text
     If-Modified-Since = HTTP-date
```

필드의 예는 다음과 같습니다.

```text
     If-Modified-Since: Sat, 29 Oct 1994 19:43:31 GMT
```

요청에 If-None-Match 헤더 필드가 포함된 경우 수신자는 If-Modified-Since를 무시해야 합니다. If-None-Match의 조건은 If-Modified-Since의 조건을 보다 정확하게 대체하는 것으로 간주되며, If-None-Match를 구현하지 않을 수 있는 이전 중개자와의 상호 운용을 위해서만 두 가지가 결합됩니다.\(MUST\)

수신자는 수신된 field-value가 유효한 HTTP 날짜가 아니거나 요청 방법이 GET 또는 HEAD가 아닌 경우 If-Modified-Since 헤더 필드를 무시해야 합니다.\(MUST\)

수신자는 원본 서버의 시계 측면에서 If-Modified-Since 필드 값의 타임스탬프를 해석해야 합니다.\(MUST\)

If-Modified-Since는 일반적으로 두 가지 별개의 목적으로 사용됩니다. 1\) 엔터티 태그가 없는 캐시된 표현의 효율적인 업데이트를 허용하고 2\) 웹 탐색 범위를 최근 변경된 리소스로 제한합니다.

캐시 업데이트에 사용되는 경우 캐시는 일반적으로 캐시된 메시지의 Last-Modified 필드 값을 사용하여 If-Modified-Since 필드 값을 생성합니다. 이 동작은 시계가 제대로 동기화되지 않은 경우 또는 서버가 정확한 타임스탬프 일치만 따르도록 선택한 경우\(원본 서버의 시계가 수정될 때 "시간을 거슬러" 돌아가는 것처럼 보이는 Last-Modified 날짜 문제로 인해\) 가장 상호 운용 가능합니다. 또는 보관된 백업에서 표현이 복원됩니다. 그러나 캐시는 캐시된 메시지의 Date 헤더 필드 또는 메시지가 수신된 로컬 시계 시간과 같은 다른 데이터를 기반으로 필드 값을 생성하는 경우가 있습니다. 특히 캐시된 메시지에 Last-Modified 필드가 포함되지 않은 경우 더욱 그렇습니다.

검색 범위를 최근 기간으로 제한하는 데 사용되는 경우 사용자 에이전트는 자체 로컬 시계 또는 이전 응답에서 서버로부터 수신된 Date 헤더 필드를 기반으로 If-Modified-Since 필드 값을 생성합니다. 선택한 표현의 Last-Modified 필드를 기반으로 정확한 타임스탬프 일치를 선택하는 원본 서버는 사용자 에이전트가 지정된 기간 동안 변경된 데이터로만 데이터 전송을 제한하는 데 도움을 줄 수 없습니다.

If-Modified-Since 헤더 필드를 수신하는 원서버는 방법\(섹션 5\)을 수행하기 전에 조건을 평가해야 합니다. 선택한 표현의 마지막 수정 날짜가 field-value에 제공된 날짜보다 빠르거나 같은 경우 원서버는 요청된 방법을 수행해서는 안 됩니다. 대신 원본 서버는 이전에 캐시된 응답을 식별하거나 업데이트하는 데 유용한 메타데이터만 포함하여 304\(수정되지 않음\) 응답을 생성해야 합니다\(SHOULD\).\(SHOULD, SHOULD NOT\)

수신된 If-Modified-Since 헤더 필드의 캐시 처리에 대한 요구 사항은 \[RFC7234\]의 섹션 4.3.2에 정의되어 있습니다.

---
### **3.4.  If-Unmodified-Since**

"If-Unmodified-Since" 헤더 필드는 선택한 표현의 마지막 수정 날짜가 필드 값에 제공된 날짜와 같거나 이전인 것을 조건으로 요청 방법을 만듭니다. 이 필드는 사용자 에이전트에 표현에 대한 엔터티 태그가 없는 경우 If-Match와 동일한 목적을 수행합니다.

```text
     If-Unmodified-Since = HTTP-date
```

필드의 예는 다음과 같습니다.

```text
     If-Unmodified-Since: Sat, 29 Oct 1994 19:43:31 GMT
```

요청에 If-Match 헤더 필드가 포함되어 있으면 수신자는 If-Unmodified-Since를 무시해야 합니다. If-Match의 조건은 If-Unmodified-Since의 조건을 보다 정확하게 대체하는 것으로 간주되며, If-Match를 구현하지 않을 수 있는 이전 중개자와의 상호 운용을 위해서만 두 가지가 결합됩니다.\(MUST\)

수신자는 수신된 field-value가 유효한 HTTP 날짜가 아닌 경우 If-Unmodified-Since 헤더 필드를 무시해야 합니다.\(MUST\)

수신자는 원본 서버의 시계 측면에서 If-Unmodified-Since 필드 값의 타임스탬프를 해석해야 합니다.\(MUST\)

If-Unmodified-Since는 상태 변경 방법\(예: POST, PUT, DELETE\)과 함께 가장 자주 사용되어 여러 사용자 에이전트가 해당 표현과 함께 엔터티 태그를 제공하지 않는 리소스에서 병렬로 작동할 수 있는 경우 우발적인 덮어쓰기를 방지합니다\( 즉, "업데이트 손실" 문제를 방지하기 위해\). 선택한 표현이 이전 요청에서 이미 저장된\(또는 부분적으로 저장된\) 표현과 일치하지 않는 경우 요청을 중단하는 안전한 방법과 함께 사용할 수도 있습니다.

If-Unmodified-Since 헤더 필드를 수신한 원서버는 방법을 수행하기 전에 조건을 평가해야 합니다\(Section 5\). 선택된 표현의 마지막 수정 날짜가 field-value에 제공된 날짜보다 더 최근인 경우 원서버는 요청된 방법을 수행해서는 안 됩니다. 대신 원서버가 상태 변경이 요청되고 최종 상태가 이미 반영되었음을 확인한 경우 원서버는 a\) 412\(전제조건 실패\) 상태 코드 또는 b\) 2xx\(성공\) 상태 코드 중 하나로 응답해야 합니다. 대상 리소스의 현재 상태\(예: 사용자 에이전트가 요청한 변경이 이미 성공했지만 이전 응답 메시지가 손실되었거나 다른 사용자 에이전트에 의해 호환 가능한 변경이 이루어졌기 때문에 사용자 에이전트는 이를 인식하지 못할 수 있음\) \). 후자의 경우, 원서버는 요청이 동일한 사용자 에이전트에 의해 수행된 직전 변경 사항과 중복된다는 것을 확인할 수 없는 한 응답에 유효성 검사기 헤더 필드를 전송해서는 안 됩니다.\(MUST, MUST NOT, MUST NOT\)

If-Unmodified-Since 헤더 필드는 저장된 응답에 적용할 수 없기 때문에 캐시와 중개자에 의해 무시될 수 있습니다.

---
### **3.5.  If-Range**

"If-Range" 헤더 필드는 If-Match 및 If-Unmodified-Since 헤더 필드와 유사하지만 유효성 검사기가 일치하지 않는 경우 수신자에게 Range 헤더 필드를 무시하도록 지시하는 특수 조건부 요청 메커니즘을 제공합니다. 412\(전제 조건 실패\) 응답 대신 새로 선택한 표현을 전송하는 중입니다. If-Range는 \[RFC7233\]의 섹션 3.2에 정의되어 있습니다.

---
## **4.  Status Code Definitions**
---
### **4.1.  304 Not Modified**

304\(수정되지 않음\) 상태 코드는 조건부 GET 또는 HEAD 요청이 수신되었으며 조건이 false로 평가되지 않았다면 200\(OK\) 응답이 발생했음을 나타냅니다. 즉, 요청은 요청을 한 클라이언트가 이를 나타내기 때문에 서버가 대상 리소스의 표현을 전송할 필요가 없습니다.

조건부, 이미 유효한 표현이 있습니다. 따라서 서버는 마치 200\(OK\) 응답의 페이로드인 것처럼 저장된 표현을 사용하도록 클라이언트를 리디렉션합니다.

304 응답을 생성하는 서버는 동일한 요청에 대한 200\(OK\) 응답으로 전송되었을 헤더 필드\(Cache-Control, Content-Location, Date, ETag, Expires 및 Vary\) 중 하나를 생성해야 합니다.\(MUST\)

304 응답의 목표는 수신자가 이미 하나 이상의 캐시된 표현을 가지고 있을 때 정보 전송을 최소화하는 것이므로, 캐시 업데이트를 안내할 목적으로 해당 메타데이터가 존재하지 않는 한 발신자는 위에 나열된 필드 이외의 표현 메타데이터를 생성해서는 안 됩니다\(예: 응답에 ETag 필드가 없는 경우 Last-Modified가 유용할 수 있습니다.\(SHOULD NOT\)

304 응답을 수신하는 캐시에 대한 요구 사항은 \[RFC7234\]의 섹션 4.3.4에 정의되어 있습니다. 조건부 요청이 아웃바운드 클라이언트에서 시작된 경우\(예: 자체 캐시가 있는 사용자 에이전트가 공유 프록시에 조건부 GET을 보내는 경우\) 프록시는 304 응답을 해당 클라이언트에 전달해야 합니다.\(SHOULD\)

304 응답에는 메시지 본문이 포함될 수 없습니다. 항상 헤더 필드 뒤의 첫 번째 빈 줄로 종료됩니다.

---
### **4.2.  412 Precondition Failed**

412\(전제 조건 실패\) 상태 코드는 요청 헤더 필드에 제공된 하나 이상의 조건이 서버에서 테스트될 때 false로 평가되었음을 나타냅니다. 이 응답 코드를 사용하면 클라이언트는 현재 리소스 상태\(현재 표현 및 메타데이터\)에 전제 조건을 배치할 수 있으므로 대상 리소스가 예상치 못한 상태에 있을 경우 요청 메서드가 적용되는 것을 방지할 수 있습니다.

---
## **5.  Evaluation**

아래에서 제외된 경우를 제외하고, 수신자 캐시 또는 원서버는 정상적인 요청 확인을 성공적으로 수행한 후 요청 방법과 관련된 작업을 수행하기 직전에 수신된 요청 전제 조건을 평가해야 합니다. 서버는 해당 조건 없이 동일한 요청에 대한 응답이 2xx\(성공\) 또는 412\(전제 조건 실패\)가 아닌 상태 코드인 경우 수신된 모든 전제 조건을 무시해야 합니다. 즉, 리디렉션 및 실패는 조건부 요청의 전제 조건 평가보다 우선합니다.\(MUST, MUST\)

대상 리소스에 대한 원서버가 아니고 대상 리소스에 대한 요청에 대한 캐시 역할을 할 수 없는 서버는 이 사양에 정의된 조건부 요청 헤더 필드를 평가해서는 안 되며, 요청이 전달되면 이를 전달해야 합니다. 클라이언트를 생성하는 것은 현재 표현을 제공할 수 있는 서버에 의해 평가되도록 의도합니다. 마찬가지로, 서버는 CONNECT, OPTIONS 또는 TRACE와 같은 선택된 표현의 선택이나 수정을 포함하지 않는 요청 방법으로 수신될 때 이 사양에 의해 정의된 조건부 요청 헤더 필드를 무시해야 합니다\(MUST\).\(MUST NOT, MUST\)

HTTP 확장으로 정의된 조건부 요청 헤더 필드는 모든 수신자, 일반적인 대상 리소스 상태 또는 리소스 그룹에 조건을 지정할 수 있습니다. 예를 들어 WebDAV의 "If" 헤더 필드는 수신자가 해당 필드를 이해하고 구현하는 경우 잠금과 같은 여러 리소스의 다양한 측면에 대한 조건부 요청을 만들 수 있습니다\(\[RFC4918\], 섹션 10.4\).

조건부 요청 헤더 필드는 HEAD 메서드와 함께 사용할 수 있도록 정의되어 있지만\(HEAD의 의미를 GET의 의미와 일관되게 유지하기 위해\) 성공적인 응답의 크기는 304\(수정되지 않음\)와 거의 같기 때문에 조건부 HEAD를 보내는 것은 의미가 없습니다. \) 응답이며 412\(전제 조건 실패\) 응답보다 더 유용합니다.

---
## **6.  Precedence**

요청에 둘 이상의 조건부 요청 헤더 필드가 있는 경우 필드가 평가되는 순서가 중요해집니다. 실제로 이 문서에 정의된 필드는 단일 논리적 순서로 일관되게 구현됩니다. 왜냐하면 "업데이트 손실" 전제 조건은 캐시 유효성 검사보다 더 엄격한 요구 사항을 갖고 있고, 검증된 캐시는 부분 응답보다 효율적이며, 엔터티 태그는 다음과 같은 것으로 가정되기 때문입니다. 날짜 유효성 검사기보다 더 정확합니다.

수신자 캐시 또는 원서버는 이 사양에 정의된 요청 전제 조건을 다음 순서로 평가해야 합니다.\(MUST\)

1. 수신자가 원본 서버이고 If-Match가 존재하는 경우 If-Match 전제 조건을 평가합니다.

- \* true인 경우 3단계로 진행합니다.

```text
       *  if false, respond 412 (Precondition Failed) unless it can be
          determined that the state-changing request has already
          succeeded (see Section 3.1)
```

2. 수신자가 원본 서버이고 If-Match가 존재하지 않고 If-Unmodified-Since가 존재하는 경우 If-Unmodified-Since 전제 조건을 평가합니다.

- \* true인 경우 3단계로 진행합니다.

```text
       *  if false, respond 412 (Precondition Failed) unless it can be
          determined that the state-changing request has already
          succeeded (see Section 3.4)
```

3. If-None-Match가 있는 경우 If-None-Match 전제 조건을 평가합니다.

- \* true인 경우 5단계로 진행합니다.

```text
       *  if false for GET/HEAD, respond 304 (Not Modified)

       *  if false for other methods, respond 412 (Precondition Failed)
```

4. 메서드가 GET 또는 HEAD이고 If-None-Match가 존재하지 않고 If-Modified-Since가 존재하는 경우 If-Modified-Since 전제 조건을 평가합니다.

- \* true인 경우 5단계로 진행합니다.

```text
       *  if false, respond 304 (Not Modified)
```

5. 메서드가 GET이고 Range와 If-Range가 모두 존재하는 경우 If-Range 전제 조건을 평가합니다.

- \* 유효성 검사기가 일치하고 범위 사양이 선택한 표현에 적용 가능한 경우 206\(부분 콘텐츠\) \[RFC7233\]에 응답합니다.

```text
   6.  Otherwise,
```

- \* 모든 조건이 충족되었으므로 요청한 작업을 수행하고 성공 또는 실패에 따라 응답합니다.

추가 조건부 요청 헤더 필드를 정의하는 HTTP/1.1의 모든 확장은 이 문서에 정의된 필드 및 실제로 발견될 수 있는 기타 조건과 관련하여 해당 필드를 평가하는 순서에 관한 자체 기대치를 정의해야 합니다.

---
## **7.  IANA Considerations**
---
### **7.1.  Status Code Registration**

<http://www.iana.org/locationments/http-status-codes\>에 있는 "HTTP\(Hypertext Transfer Protocol\) 상태 코드 레지스트리"가 아래 등록으로 업데이트되었습니다.

```text
   +-------+---------------------+-------------+
   | Value | Description         | Reference   |
   +-------+---------------------+-------------+
   | 304   | Not Modified        | Section 4.1 |
   | 412   | Precondition Failed | Section 4.2 |
   +-------+---------------------+-------------+
```

---
### **7.2.  Header Field Registration**

```text
   HTTP header fields are registered within the "Message Headers"
   registry maintained at
   <http://www.iana.org/assignments/message-headers/>.
```

이 문서는 다음 HTTP 헤더 필드를 정의하므로 관련 레지스트리 항목이 아래 영구 등록에 따라 업데이트되었습니다\(\[BCP90\] 참조\).

```text
   +---------------------+----------+----------+-------------+
   | Header Field Name   | Protocol | Status   | Reference   |
   +---------------------+----------+----------+-------------+
   | ETag                | http     | standard | Section 2.3 |
   | If-Match            | http     | standard | Section 3.1 |
   | If-Modified-Since   | http     | standard | Section 3.3 |
   | If-None-Match       | http     | standard | Section 3.2 |
   | If-Unmodified-Since | http     | standard | Section 3.4 |
   | Last-Modified       | http     | standard | Section 2.2 |
   +---------------------+----------+----------+-------------+
```

변경 컨트롤러는 "IETF\(iesg@ietf.org\) - 인터넷 엔지니어링 태스크 포스"입니다.

---
## **8.  Security Considerations**

이 섹션은 개발자, 정보 제공자 및 사용자에게 HTTP 조건부 요청 메커니즘과 관련된 알려진 보안 문제를 알리기 위한 것입니다. 보다 일반적인 보안 고려사항은 HTTP "메시지 구문 및 라우팅" \[RFC7230\] 및 "의미론 및 콘텐츠" \[RFC7231\]에 설명되어 있습니다.

이 사양에서 정의한 유효성 검사기는 표현의 유효성을 보장하거나 악의적인 변경을 방지하거나 중간자 공격을 감지하기 위한 것이 아닙니다. 기껏해야 모든 참가자가 정상적으로 작동할 때 보다 효율적인 캐시 업데이트와 낙관적인 동시 쓰기가 가능합니다. 최악의 경우 조건이 실패하고 클라이언트는 조건부 요청이 없는 HTTP 교환보다 더 해롭지 않은 응답을 받게 됩니다.

엔터티 태그는 개인 정보 보호 위험을 초래하는 방식으로 남용될 수 있습니다. 예를 들어, 사이트는 사용자 또는 사용자 에이전트에 고유한 의미상 유효하지 않은 엔터티 태그를 의도적으로 구성하고 이를 긴 신선도 시간으로 캐시 가능한 응답으로 보낸 다음 나중에 조건부 요청에서 해당 엔터티 태그를 수단으로 읽을 수 있습니다. 해당 사용자 또는 사용자 에이전트를 재식별합니다. 이러한 식별 태그는 사용자 에이전트가 원래 캐시 항목을 유지하는 한 영구 식별자가 됩니다. 표현을 캐시하는 사용자 에이전트는 사용자가 저장된 쿠키를 지우거나 개인 브라우징 모드로 변경하는 등 개인 정보 보호 작업을 수행할 때마다 캐시가 지워지거나 교체되도록 해야 합니다.

---
## **9.  Acknowledgments**

\[RFC7230\]의 섹션 10을 참조하세요.

---
## **10.  References**
---
### **10.1.  Normative References**

\[RFC2119\] Bradner, S., "요구 사항 수준을 나타내기 위해 RFC에서 사용할 핵심 단어", BCP 14, RFC 2119, 1997년 3월.

\[RFC5234\] Crocker, D., Ed. 및 P. Overell, "구문 사양을 위한 보강된 BNF: ABNF", STD 68, RFC 5234, 2008년 1월.

\[RFC7230\] Fielding, R., Ed. 및 J. Reschke, Ed., "하이퍼텍스트 전송 프로토콜\(HTTP/1.1\): 메시지 구문 및 라우팅", RFC 7230, 2014년 6월.

\[RFC7231\] Fielding, R., Ed. 및 J. Reschke, Ed., "하이퍼텍스트 전송 프로토콜\(HTTP/1.1\): 의미 및 콘텐츠", RFC 7231, 2014년 6월.

\[RFC7233\] Fielding, R., Ed., Lafon, Y., Ed. 및 J. Reschke, Ed., "하이퍼텍스트 전송 프로토콜\(HTTP/1.1\): 범위 요청", RFC 7233, 2014년 6월.

\[RFC7234\] Fielding, R., Ed., Nottingham, M., Ed. 및 J. Reschke, Ed., "하이퍼텍스트 전송 프로토콜\(HTTP/1.1\): 캐싱", RFC 7234, 2014년 6월.

---
### **10.2.  Informative References**

\[BCP90\] Klyne, G., Nottingham, M. 및 J. Mogul, "메시지 헤더 필드 등록 절차", BCP 90, RFC 3864, 2004년 9월.

\[RFC2616\] Fielding, R., Gettys, J., Mogul, J., Frystyk, H.,

- Masinter, L., Leach, P. 및 T. Berners-Lee, "Hypertext Transfer Protocol -- HTTP/1.1", RFC 2616, 1999년 6월.

\[RFC4918\] Dusseault, L., Ed., "WebDAV\(웹 분산 작성 및 버전 관리\)를 위한 HTTP 확장", RFC 4918, 2007년 6월.

---
# **Appendix A.  Changes from RFC 2616**

```text
   The definition of validator weakness has been expanded and clarified.
   (Section 2.1)

   Weak entity-tags are now allowed in all requests except range
   requests.  (Sections 2.1 and 3.2)

   The ETag header field ABNF has been changed to not use quoted-string,
   thus avoiding escaping issues.  (Section 2.3)

   ETag is defined to provide an entity tag for the selected
   representation, thereby clarifying what it applies to in various
   situations (such as a PUT response).  (Section 2.3)

   The precedence for evaluation of conditional requests has been
   defined.  (Section 6)
```

---
# **Appendix B.  Imported ABNF**

\[RFC5234\]의 부록 B.1에 정의된 대로 다음 핵심 규칙이 참조로 포함됩니다: ALPHA\(문자\), CR\(캐리지 리턴\), CRLF\(CR LF\), CTL\(컨트롤\), DIGIT\(십진수 0-9\) , DQUOTE\(큰따옴표\), HEXDIG\(16진수 0-9/A-F/a-f\), LF\(줄 바꿈\), OCTET\(8비트 데이터 시퀀스\), SP\(공백\) 및 VCHAR\(표시되는 모든 US-ASCII 문자 \).

아래 규칙은 \[RFC7230\]에 정의되어 있습니다.

```text
     OWS           = <OWS, see [RFC7230], Section 3.2.3>
     obs-text      = <obs-text, see [RFC7230], Section 3.2.6>
```

아래 규칙은 다른 부분에서 정의됩니다.

```text
     HTTP-date     = <HTTP-date, see [RFC7231], Section 7.1.1.1>
```

---
# **Appendix C.  Collected ABNF**

아래 수집된 ABNF에서 목록 규칙은 \[RFC7230\]의 섹션 1.2에 따라 확장됩니다.

```text
   ETag = entity-tag

   HTTP-date = <HTTP-date, see [RFC7231], Section 7.1.1.1>

   If-Match = "*" / ( *( "," OWS ) entity-tag *( OWS "," [ OWS
    entity-tag ] ) )
   If-Modified-Since = HTTP-date
   If-None-Match = "*" / ( *( "," OWS ) entity-tag *( OWS "," [ OWS
    entity-tag ] ) )
   If-Unmodified-Since = HTTP-date

   Last-Modified = HTTP-date

   OWS = <OWS, see [RFC7230], Section 3.2.3>

   entity-tag = [ weak ] opaque-tag
   etagc = "!" / %x23-7E ; '#'-'~'
    / obs-text

   obs-text = <obs-text, see [RFC7230], Section 3.2.6>
   opaque-tag = DQUOTE *etagc DQUOTE

   weak = %x57.2F ; W/
```

---
# **Index**

```text
   3
      304 Not Modified (status code)  19

   4
      412 Precondition Failed (status code)  18

   E
      ETag header field  9

   G
      Grammar
         entity-tag  9
         ETag  9
         etagc  9
         If-Match  13
         If-Modified-Since  15
         If-None-Match  14
         If-Unmodified-Since  17
         Last-Modified  7
         opaque-tag  9
         weak  9

   I
      If-Match header field  13
      If-Modified-Since header field  16
      If-None-Match header field  14
      If-Unmodified-Since header field  17

   L
      Last-Modified header field  7

   M
      metadata  5

   S
      selected representation  4

   V
      validator  5
         strong  5
         weak  5
```

---
# **Authors' Addresses**

```text
   Roy T. Fielding (editor)
   Adobe Systems Incorporated
   345 Park Ave
   San Jose, CA  95110
   USA

   EMail: fielding@gbiv.com
   URI:   http://roy.gbiv.com/

   Julian F. Reschke (editor)
   greenbytes GmbH
   Hafenweg 16
   Muenster, NW  48155
   Germany

   EMail: julian.reschke@greenbytes.de
   URI:   http://greenbytes.de/tech/webdav/
```
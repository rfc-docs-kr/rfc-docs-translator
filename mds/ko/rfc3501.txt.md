

```text
Network Working Group                                         M. Crispin
Request for Comments: 3501                      University of Washington
Obsoletes: 2060                                               March 2003
Category: Standards Track

            INTERNET MESSAGE ACCESS PROTOCOL - VERSION 4rev1
```

---
# **Status of this Memo**

이 문서는 인터넷 커뮤니티를 위한 인터넷 표준 추적 프로토콜을 지정하고 개선을 위한 토론 및 제안을 요청합니다. 이 프로토콜의 표준화 상태 및 상태에 대해서는 "Internet Official Protocol Standards"\(STD 1\) 최신판을 참조하십시오. 이 메모의 배포는 무제한입니다.

---
# **Copyright Notice**

저작권\(C\)인터넷학회\(2003\). 판권 소유.

---
# **Abstract**

IMAP4rev1\(Internet Message Access Protocol, 버전 4rev1\)을 사용하면 클라이언트가 서버의 전자 메일 메시지에 액세스하고 조작할 수 있습니다. IMAP4rev1을 사용하면 로컬 폴더와 기능적으로 동일한 방식으로 사서함\(원격 메시지 폴더\)을 조작할 수 있습니다. IMAP4rev1은 오프라인 클라이언트가 서버와 재동기화하는 기능도 제공합니다.

IMAP4rev1에는 사서함 생성, 삭제 및 이름 바꾸기, 새 메시지 확인, 메시지 영구 제거, 플래그 설정 및 지우기, RFC 2822 및 RFC 2045 구문 분석, 검색 및 메시지 속성, 텍스트 및 해당 부분의 선택적 가져오기를 위한 작업이 포함되어 있습니다. IMAP4rev1의 메시지는 숫자를 사용하여 액세스됩니다. 이 번호는 메시지 시퀀스 번호이거나 고유 식별자입니다.

IMAP4rev1은 단일 서버를 지원합니다. 여러 IMAP4rev1 서버를 지원하기 위해 구성 정보에 액세스하는 메커니즘은 RFC 2244에 설명되어 있습니다.

IMAP4rev1은 메일 게시 방법을 지정하지 않습니다. 이 기능은 RFC 2821과 같은 메일 전송 프로토콜에 의해 처리됩니다.

---
# **Table of Contents**

```text
   IMAP4rev1 Protocol Specification ................................  4
   1.      How to Read This Document ...............................  4
   1.1.    Organization of This Document ...........................  4
   1.2.    Conventions Used in This Document .......................  4
   1.3.    Special Notes to Implementors ...........................  5
   2.      Protocol Overview .......................................  6
   2.1.    Link Level ..............................................  6
   2.2.    Commands and Responses ..................................  6
   2.2.1.  Client Protocol Sender and Server Protocol Receiver .....  6
   2.2.2.  Server Protocol Sender and Client Protocol Receiver .....  7
   2.3.    Message Attributes ......................................  8
   2.3.1.  Message Numbers .........................................  8
   2.3.1.1.        Unique Identifier (UID) Message Attribute .......  8
   2.3.1.2.        Message Sequence Number Message Attribute ....... 10
   2.3.2.  Flags Message Attribute ................................. 11
   2.3.3.  Internal Date Message Attribute ......................... 12
   2.3.4.  [RFC-2822] Size Message Attribute ....................... 12
   2.3.5.  Envelope Structure Message Attribute .................... 12
   2.3.6.  Body Structure Message Attribute ........................ 12
   2.4.    Message Texts ........................................... 13
   3.      State and Flow Diagram .................................. 13
   3.1.    Not Authenticated State ................................. 13
   3.2.    Authenticated State ..................................... 13
   3.3.    Selected State .......................................... 13
   3.4.    Logout State ............................................ 14
   4.      Data Formats ............................................ 16
   4.1.    Atom .................................................... 16
   4.2.    Number .................................................. 16
   4.3.    String .................................................. 16
   4.3.1.  8-bit and Binary Strings ................................ 17
   4.4.    Parenthesized List ...................................... 17
   4.5.    NIL ..................................................... 17
   5.      Operational Considerations .............................. 18
   5.1.    Mailbox Naming .......................................... 18
   5.1.1.  Mailbox Hierarchy Naming ................................ 19
   5.1.2.  Mailbox Namespace Naming Convention ..................... 19
   5.1.3.  Mailbox International Naming Convention ................. 19
   5.2.    Mailbox Size and Message Status Updates ................. 21
   5.3.    Response when no Command in Progress .................... 21
   5.4.    Autologout Timer ........................................ 22
   5.5.    Multiple Commands in Progress ........................... 22
   6.      Client Commands ........................................  23
   6.1.    Client Commands - Any State ............................  24
   6.1.1.  CAPABILITY Command .....................................  24
   6.1.2.  NOOP Command ...........................................  25
   6.1.3.  LOGOUT Command .........................................  26
   6.2.    Client Commands - Not Authenticated State ..............  26
   6.2.1.  STARTTLS Command .......................................  27
   6.2.2.  AUTHENTICATE Command ...................................  28
   6.2.3.  LOGIN Command ..........................................  30
   6.3.    Client Commands - Authenticated State ..................  31
   6.3.1.  SELECT Command .........................................  32
   6.3.2.  EXAMINE Command ........................................  34
   6.3.3.  CREATE Command .........................................  34
   6.3.4.  DELETE Command .........................................  35
   6.3.5.  RENAME Command .........................................  37
   6.3.6.  SUBSCRIBE Command ......................................  39
   6.3.7.  UNSUBSCRIBE Command ....................................  39
   6.3.8.  LIST Command ...........................................  40
   6.3.9.  LSUB Command ...........................................  43
   6.3.10. STATUS Command .........................................  44
   6.3.11. APPEND Command .........................................  46
   6.4.    Client Commands - Selected State .......................  47
   6.4.1.  CHECK Command ..........................................  47
   6.4.2.  CLOSE Command ..........................................  48
   6.4.3.  EXPUNGE Command ........................................  49
   6.4.4.  SEARCH Command .........................................  49
   6.4.5.  FETCH Command ..........................................  54
   6.4.6.  STORE Command ..........................................  58
   6.4.7.  COPY Command ...........................................  59
   6.4.8.  UID Command ............................................  60
   6.5.    Client Commands - Experimental/Expansion ...............  62
   6.5.1.  X<atom> Command ........................................  62
   7.      Server Responses .......................................  62
   7.1.    Server Responses - Status Responses ....................  63
   7.1.1.  OK Response ............................................  65
   7.1.2.  NO Response ............................................  66
   7.1.3.  BAD Response ...........................................  66
   7.1.4.  PREAUTH Response .......................................  67
   7.1.5.  BYE Response ...........................................  67
   7.2.    Server Responses - Server and Mailbox Status ...........  68
   7.2.1.  CAPABILITY Response ....................................  68
   7.2.2.  LIST Response ..........................................  69
   7.2.3.  LSUB Response ..........................................  70
   7.2.4   STATUS Response ........................................  70
   7.2.5.  SEARCH Response ........................................  71
   7.2.6.  FLAGS Response .........................................  71
   7.3.    Server Responses - Mailbox Size ........................  71
   7.3.1.  EXISTS Response ........................................  71
   7.3.2.  RECENT Response ........................................  72
   7.4.    Server Responses - Message Status ......................  72
   7.4.1.  EXPUNGE Response .......................................  72
   7.4.2.  FETCH Response .........................................  73
   7.5.    Server Responses - Command Continuation Request ........  79
   8.      Sample IMAP4rev1 connection ............................  80
   9.      Formal Syntax ..........................................  81
   10.     Author's Note ..........................................  92
   11.     Security Considerations ................................  92
   11.1.   STARTTLS Security Considerations .......................  92
   11.2.   Other Security Considerations ..........................  93
   12.     IANA Considerations ....................................  94
   Appendices .....................................................  95
   A.      References .............................................  95
   B.      Changes from RFC 2060 ..................................  97
   C.      Key Word Index ......................................... 103
   Author's Address ............................................... 107
   Full Copyright Statement ....................................... 108
```

---
# **IMAP4rev1 Protocol Specification**
---
## **1.      How to Read This Document**
---
### **1.1.    Organization of This Document**

이 문서는 IMAP4rev1 클라이언트 또는 서버 구현자의 관점에서 작성되었습니다. 섹션 2의 프로토콜 개요 외에는 프로토콜 작동을 이해하려는 사람에게 최적화되어 있지 않습니다. 섹션 3부터 5까지의 자료는 IMAP4rev1이 작동하는 일반적인 맥락과 정의를 제공합니다.

섹션 6, 7, 9에서는 각각 IMAP 명령, 응답 및 구문을 설명합니다. 이들 사이의 관계는 어느 하나를 개별적으로 이해하는 것이 거의 불가능할 정도입니다. 특히, 명령 섹션에서만 명령 구문을 추론하려고 시도하지 마십시오. 대신 형식 구문 섹션을 참조하세요.

---
### **1.2.    Conventions Used in This Document**

"협약"은 기본 원칙 또는 절차입니다. 이 섹션에는 문서 규칙이 설명되어 있습니다.

예에서 "C:" 및 "S:"는 각각 클라이언트와 서버에서 보낸 행을 나타냅니다.

이 문서의 핵심 단어 "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "MAY" 및 "OPTIONAL"은 다음과 같이 해석됩니다. \[키워드\]에 설명되어 있습니다.\(MUST NOT\)

"할 수 있다"\("할 수 있다" 아님\)라는 단어는 프로토콜의 선택적 기능과 달리 가능한 상황이나 상황을 나타내는 데 사용됩니다.

"사용자"는 인간 사용자를 나타내는 데 사용되는 반면, "클라이언트"는 사용자가 실행하는 소프트웨어를 나타냅니다.

"연결"은 네트워크 연결의 초기 설정부터 종료까지 클라이언트/서버 상호 작용의 전체 순서를 나타냅니다.

"세션"은 사서함이 선택된 시간\(SELECT 또는 EXAMINE 명령\)부터 선택이 종료되는 시간\(다른 사서함의 SELECT 또는 EXAMINE, CLOSE 명령 또는 연결 종료\)까지 일련의 클라이언트/서버 상호 작용을 나타냅니다.

별도로 지정하지 않는 한 문자는 7비트 US-ASCII입니다. 다른 문자 집합은 \[MIME-IMT\]에 설명되고 \[CHARSET\]에 정의된 대로 "CHARSET"을 사용하여 표시됩니다. CHARSET에는 문자 집합을 정의하는 것 외에도 중요한 추가 의미가 있습니다. 자세한 내용은 이 문서를 참조하세요.

IMAP에는 몇 가지 프로토콜 규칙이 있습니다. 이는 엄밀히 말하면 IMAP 프로토콜의 일부는 아니지만 일반적으로 수용되는 관행을 반영하는 사양의 측면을 나타냅니다. 구현에서는 이러한 규칙을 인식하고 규칙 구현 여부에 관계없이 충돌을 피해야 합니다. 예를 들어 "&"는 사서함 국제 명명 규칙과 충돌하므로 계층 구분 기호로 사용할 수 없으며 사서함 이름에 "&"를 다른 방식으로 사용하는 경우에도 영향을 받습니다.

---
### **1.3.    Special Notes to Implementors**

IMAP 프로토콜 구현자는 이 프로토콜의 복잡성과 상호 운용 가능한 제품을 구축하는 최선의 방법을 이해하는 데 도움이 되도록 이 문서와 함께 IMAP 구현 권장 사항 문서 \[IMAP-IMPLEMENTATION\]를 읽어볼 것을 강력히 권장합니다.

IMAP4rev1은 \[IMAP2\] 및 게시되지 않은 IMAP2bis 프로토콜과 상위 호환되도록 설계되었습니다. IMAP4rev1은 RFC 1730에 설명된 IMAP4 프로토콜과 대부분 호환됩니다. RFC 1730에 추가되어 문제가 있는 것으로 판명되어 이후에 제거된 특정 기능의 경우는 예외입니다. IMAP4rev1이 발전하는 과정에서 이전 프로토콜의 일부 측면은 더 이상 사용되지 않게 되었습니다. IMAP4rev1 구현이 이전 구현과 함께 사용될 때 발생할 수 있는 더 이상 사용되지 않는 명령, 응답 및 데이터 형식은 \[IMAP-OBSOLETE\]에 설명되어 있습니다.

```text
   Other compatibility issues with IMAP2bis, the most common variant of
   the earlier protocol, are discussed in [IMAP-COMPAT].  A full
   discussion of compatibility issues with rare (and presumed extinct)
```

\[IMAP2\]의 변형은 \[IMAP-HISTORICAL\]에 있습니다. 이 문서는 주로 역사적인 관심사입니다.

IMAP은 원래 이전 \[RFC-822\] 표준을 위해 개발되었으므로 결과적으로 IMAP의 여러 가져오기 항목은 이름에 "RFC822"를 포함합니다. RFC822.SIZE를 제외하고 더 현대적인 대체품이 있습니다. 예를 들어 RFC822.HEADER의 최신 버전은 BODY.PEEK\[HEADER\]입니다. 모든 경우에 "RFC822"는 업데이트된 \[RFC-2822\] 표준에 대한 참조로 해석되어야 합니다.

---
## **2.      Protocol Overview**
---
### **2.1.    Link Level**

IMAP4rev1 프로토콜은 TCP에서 제공하는 것과 같은 안정적인 데이터 스트림을 가정합니다. TCP가 사용되면 IMAP4rev1 서버는 포트 143에서 수신 대기합니다.

---
### **2.2.    Commands and Responses**

IMAP4rev1 연결은 클라이언트/서버 네트워크 연결 설정, 서버의 초기 인사말 및 클라이언트/서버 상호 작용으로 구성됩니다. 이러한 클라이언트/서버 상호 작용은 클라이언트 명령, 서버 데이터 및 서버 완료 결과 응답으로 구성됩니다.

클라이언트와 서버가 전송하는 모든 상호 작용은 줄, 즉 CRLF로 끝나는 문자열 형식입니다. IMAP4rev1 클라이언트 또는 서버의 프로토콜 수신기는 한 줄을 읽고 있거나 알려진 개수와 한 줄이 뒤따르는 일련의 옥텟을 읽고 있습니다.

---
#### **2.2.1.  Client Protocol Sender and Server Protocol Receiver**

클라이언트 명령이 작업을 시작합니다. 각 클라이언트 명령에는 "태그"라는 식별자\(일반적으로 짧은 영숫자 문자열, 예: A0001, A0002 등\)가 접두사로 붙습니다. 클라이언트는 각 명령마다 다른 태그를 생성합니다.

클라이언트는 이 사양에 설명된 구문을 엄격하게 따라야 합니다. 누락되거나 불필요한 공백이나 인수가 포함된 명령을 보내는 것은 구문 오류입니다.\(MUST\)

클라이언트의 줄이 완전한 명령을 나타내지 않는 두 가지 경우가 있습니다. 어떤 경우에는 명령 인수가 옥텟 수로 인용됩니다\(데이터 형식의 문자열에서 리터럴에 대한 설명 참조\). 다른 경우에는 명령 인수에 서버 피드백이 필요합니다\(AUTHENTICATE 명령 참조\). 두 경우 모두,

서버는 옥텟\(적절한 경우\)과 명령의 나머지 부분에 대한 준비가 되면 명령 연속 요청 응답을 보냅니다. 이 응답에는 토큰 "+"가 접두어로 붙습니다.

참고: 대신 서버가 다음에서 오류를 감지한 경우

- 명령을 실행하면 명령과 일치하는 태그\(아래 설명 참조\)와 함께 BAD 완료 응답을 보내 명령을 거부하고 클라이언트가 더 이상 명령을 보내지 못하도록 합니다.

서버가 완료 메시지를 보내는 것도 가능합니다.

- 다른 명령에 대한 응답\(여러 명령이 진행 중인 경우\) 또는 태그가 지정되지 않은 데이터입니다. 두 경우 모두 명령 계속 요청이 여전히 보류 중입니다. 클라이언트는 응답에 대해 적절한 조치를 취하고 서버에서 다른 응답을 읽습니다. 모든 경우에 클라이언트는 새 명령을 시작하기 전에 완전한 명령\(모든 명령 연속 요청 응답 및 명령에 대한 명령 연속 수신 포함\)을 보내야 합니다.\(MUST\)

IMAP4rev1 서버의 프로토콜 수신자는 클라이언트로부터 명령줄을 읽고, 명령과 해당 인수를 구문 분석하고, 서버 데이터와 서버 명령 완료 결과 응답을 전송합니다.

---
#### **2.2.2.  Server Protocol Sender and Client Protocol Receiver**

서버에서 클라이언트로 전송되는 데이터와 명령 완료를 나타내지 않는 상태 응답에는 토큰 "\*"이 접두사로 붙으며 태그가 없는 응답이라고 합니다.

서버 데이터는 클라이언트 명령의 결과로 전송되거나 서버에 의해 일방적으로 전송될 수 있습니다. 특정 명령에 의해 생성된 서버 데이터와 일방적으로 전송된 서버 데이터 간에는 구문상 차이가 없습니다.\(MAY\)

서버 완료 결과 응답은 작업의 성공 또는 실패를 나타냅니다. 작업을 시작한 클라이언트 명령과 동일한 태그가 지정됩니다. 따라서 둘 이상의 명령이 진행 중인 경우 서버 완료 응답의 태그는 응답이 적용되는 명령을 식별합니다. 가능한 서버 완료 응답에는 OK\(성공을 나타냄\), NO\(실패를 나타냄\) 또는 BAD\(인식할 수 없는 명령 또는 명령 구문 오류와 같은 프로토콜 오류를 나타냄\)의 세 가지 응답이 있습니다.

서버는 이 사양에 설명된 구문을 엄격하게 적용해야 합니다. 누락되거나 불필요한 공백 또는 인수를 포함하되 이에 국한되지 않는 프로토콜 구문 오류가 있는 클라이언트 명령\(SHOULD\)

거부되어야 하며 클라이언트는 BAD 서버 완료 응답을 받았습니다.\(SHOULD\)

IMAP4rev1 클라이언트의 프로토콜 수신기는 서버로부터 응답 라인을 읽습니다. 그런 다음 태그, "\*" 또는 "+"일 수 있는 응답의 첫 번째 토큰을 기반으로 응답에 대한 조치를 취합니다.

클라이언트는 항상 모든 서버 응답을 수락할 준비가 되어 있어야 합니다. 여기에는 요청되지 않은 서버 데이터가 포함됩니다. 서버 데이터는 클라이언트가 데이터를 요청하기 위해 서버에 명령을 보내는 대신 기록된 복사본을 참조할 수 있도록 기록되어야 합니다. 특정 서버 데이터의 경우 데이터를 기록해야 합니다.\(MUST, SHOULD, MUST\)

이 주제는 서버 응답 섹션에서 더 자세히 논의됩니다.

---
### **2.3.    Message Attributes**

메시지 텍스트 외에도 각 메시지에는 이와 관련된 여러 속성이 있습니다. 이러한 속성은 개별적으로 검색하거나 다른 속성이나 메시지 텍스트와 함께 검색할 수 있습니다.

---
#### **2.3.1.  Message Numbers**

IMAP4rev1의 메시지는 두 숫자 중 하나로 액세스됩니다. 고유 식별자 또는 메시지 시퀀스 번호.

---
##### **2.3.1.1.        Unique Identifier (UID) Message Attribute**

각 메시지에 할당된 32비트 값은 고유 식별자 유효성 값\(아래 참조\)과 함께 사용될 때 사서함의 다른 메시지나 동일한 이름을 가진 후속 사서함을 영원히 참조해서는 안 되는 64비트 값을 형성합니다. 고유 식별자는 사서함에서 엄격한 오름차순으로 할당됩니다. 각 메시지가 사서함에 추가되면 이전에 추가된 메시지보다 더 높은 UID가 할당됩니다. 메시지 시퀀스 번호와 달리 고유 식별자는 반드시 연속적일 필요는 없습니다.\(MUST NOT\)

메시지의 고유 식별자는 세션 중에 변경되어서는 안 되며, 세션 간에도 변경되어서는 안 됩니다. 세션 간의 고유 식별자 변경은 아래에 설명된 UIDVALIDITY 메커니즘을 사용하여 감지할 수 있어야 합니다. 클라이언트가 이전 세션의 상태를 서버와 다시 동기화하려면 지속적인 고유 식별자가 필요합니다\(예: 연결이 끊어졌거나 오프라인 액세스 클라이언트\). 이에 대해서는 \[IMAP-DISC\]에서 자세히 설명합니다.\(MUST NOT, MUST\)

모든 사서함에는 고유 식별자 처리를 지원하는 두 가지 값, 즉 다음 고유 식별자 값과 고유 식별자 유효성 값이 연결되어 있습니다.

다음 고유 식별자 값은 사서함의 새 메시지에 할당될 예측 값입니다. 고유 식별자 유효성도 변경되지 않는 한\(아래 참조\) 다음 고유 식별자 값은 다음 두 가지 특성을 가져야 합니다. 첫째, 새 메시지가 메일박스에 추가되지 않는 한 다음 고유 식별자 값은 변경되어서는 안 됩니다. 둘째, 새 메시지가 나중에 삭제되더라도 사서함에 새 메시지가 추가될 때마다 다음 고유 식별자 값을 변경해야 합니다.\(MUST, MUST NOT\)

참고: 다음 고유 식별자 값은

- 클라이언트가 이전에 이 값을 확인한 이후 메일함으로 배달된 메시지가 있는지 여부를 확인할 수 있는 수단을 제공합니다. 모든 메시지에 이 고유 식별자가 있다는 보장은 제공되지 않습니다. 클라이언트는 다음 고유 식별자 값을 얻을 때 그 시간 이후에 도착하는 메시지가 해당 값보다 크거나 같은 UID를 갖게 될 것이라고 가정할 수 있습니다.

고유 식별자 유효성 값은 사서함 선택 시 태그가 지정되지 않은 OK 응답의 UIDVALIDITY 응답 코드로 전송됩니다. 이전 세션의 고유 식별자가 이 세션에서 유지되지 않는 경우 고유 식별자 유효성 값은 이전 세션에서 사용된 값보다 커야 합니다.\(MUST\)

참고: 이상적으로는 고유 식별자가 지속되어야 합니다.

- 시간. 이 사양은 특정 서버 환경에서 지속 실패가 불가피할 수 있다는 점을 인식하고 있지만 이 문제를 방지하는 메시지 저장소 구현 기술을 강력히 권장합니다. 예를 들어:\(SHOULD\)

- 1\) 고유 식별자는 항상 사서함에서 엄격하게 오름차순이어야 합니다. IMAP이 아닌 에이전트에 의해 물리적 메시지 저장소가 다시 정렬되는 경우 이전 고유 식별자는 다시 정렬의 결과로 더 이상 엄격하게 오름차순이 아니기 때문에 사서함의 고유 식별자를 다시 생성해야 합니다.\(MUST\)

- 2\) 메시지 저장소에 고유 식별자를 저장하는 메커니즘이 없는 경우 각 세션에서 고유 식별자를 다시 생성해야 하며 각 세션에는 고유한 UIDVALIDITY 값이 있어야 합니다.

- 3\) 사서함이 삭제되고 나중에 동일한 이름의 새 사서함이 생성되는 경우 서버는 이전 사서함 인스턴스의 고유 식별자를 추적하거나 새 UIDVALIDITY 값을 사서함에 할당해야 합니다. 사서함의 새 인스턴스입니다. 이 경우에 사용하기에 좋은 UIDVALIDITY 값은 사서함 생성 날짜/시간을 32비트로 표현하는 것입니다. 1과 같은 상수를 사용하는 것은 괜찮지만, 사서함이 삭제되거나 이름이 바뀌고 나중에 같은 이름의 새 사서함이 생성되는 경우에도 고유 식별자가 재사용되지 않는다는 것이 보장되는 경우에만 가능합니다. .

- 4\) 사서함 이름, UIDVALIDITY 및 UID의 조합은 해당 서버에서 영원히 단일 불변 메시지를 참조해야 합니다. 특히 내부 날짜, \[RFC-2822\] 크기, 봉투, 본문 구조 및 메시지 텍스트\(RFC822, RFC822.HEADER, RFC822.TEXT 및 모든 BODY\[...\] 가져오기 데이터 항목\)는 절대 변경되어서는 안 됩니다. 여기에는 메시지 번호가 포함되지 않으며 STORE 명령\(예: FLAGS\)으로 설정할 수 있는 속성도 포함되지 않습니다.

---
##### **2.3.1.2.        Message Sequence Number Message Attribute**

1부터 사서함의 메시지 수까지의 상대 위치입니다. 이 위치는 고유 식별자의 오름차순으로 정렬되어야 합니다. 각각의 새 메시지가 추가될 때마다 새 메시지가 추가되기 전 사서함에 있던 메시지 수보다 1 더 큰 메시지 시퀀스 번호가 할당됩니다.\(MUST\)

세션 중에 메시지 시퀀스 번호를 재할당할 수 있습니다. 예를 들어, 메시지가 편지함에서 영구적으로 제거\(말소\)되면 모든 후속 메시지의 메시지 시퀀스 번호가 감소됩니다. 사서함의 메시지 수도 감소합니다. 마찬가지로, 삭제되기 전에 다른 메시지에 한때 보관되었던 메시지 시퀀스 번호가 새 메시지에 할당될 수 있습니다.

사서함의 상대적 위치를 기준으로 메시지에 액세스하는 것 외에도 수학적 계산에 메시지 시퀀스 번호를 사용할 수 있습니다. 예를 들어 태그가 지정되지 않은 "11 EXISTS"가 수신되고 이전에 태그가 지정되지 않은 "8 EXISTS"가 수신된 경우 메시지 시퀀스 번호가 9, 10 및 11인 세 개의 새 메시지가 도착했습니다. 또 다른 예를 들어, 523의 메시지 287인 경우 메시지 사서함의 UID는 12345이며, ​​정확히 286개의 메시지가 더 작은 UID를 갖고 236개의 메시지가 더 큰 UID를 가지고 있습니다.

---
#### **2.3.2.  Flags Message Attribute**

메시지와 연관된 0개 이상의 명명된 토큰 목록입니다. 플래그는 이 목록에 추가되면 설정되고 제거되면 지워집니다. IMAP4rev1에는 두 가지 유형의 플래그가 있습니다. 두 유형의 플래그는 영구적이거나 세션 전용일 수 있습니다.

시스템 플래그는 본 명세서에 미리 정의되어 있는 플래그 이름이다. 모든 시스템 플래그는 "\"로 시작됩니다. 특정 시스템 플래그\(\Deleted 및 \Seen\)에는 다른 곳에 설명된 특별한 의미가 있습니다. 현재 정의된 시스템 플래그는 다음과 같습니다.

\본

- 메시지를 읽었습니다.

\답변

- 메시지에 답변되었습니다.

\플래그됨

- 메시지는 긴급/특별 주의를 위해 "플래그"됩니다.

\삭제됨

- 메시지는 나중에 EXPUNGE로 제거하기 위해 "삭제"됩니다.

\초안

- 메시지 작성이 완료되지 않았습니다\(초안으로 표시됨\).

\최근의

- 메시지는 "최근"에 이 사서함에 도착했습니다. 이 세션은 이 메시지에 대한 알림을 받은 첫 번째 세션입니다. 세션이 읽기-쓰기인 경우 후속 세션에서는 이 메시지에 대해 설정된 \Recent를 볼 수 없습니다. 이 플래그는 클라이언트에서 변경할 수 없습니다.

- 이 세션이 메시지에 대해 알림을 받는 첫 번째 세션인지 여부를 결정하는 것이 불가능한 경우 해당 메시지는 최근 메시지로 간주되어야 합니다.\(SHOULD\)

- 여러 연결에 동일한 사서함이 동시에 선택된 경우 이러한 연결 중 어떤 연결이 \Recent가 설정된 새로 도착한 메시지를 볼 것인지, \Recent가 설정되지 않은 메시지를 볼 것인지는 정의되지 않습니다.

키워드는 서버 구현에 의해 정의됩니다. 키워드는 "\"로 시작하지 않습니다. 서버는 클라이언트가 메일함에서 새 키워드를 정의하도록 허용할 수 있습니다\(자세한 내용은 PERMANENTFLAGS 응답 코드 설명 참조\).\(MAY\)

플래그는 플래그별로 영구적이거나 세션 전용일 수 있습니다. 영구 플래그는 클라이언트가 메시지 플래그에 영구적으로 추가하거나 제거할 수 있는 플래그입니다. 즉, 동시 및 후속 세션에서는 영구 플래그가 변경됩니다. 세션 플래그에 대한 변경 사항은 해당 세션에서만 유효합니다.

참고: \Recent 시스템 플래그는

- 세션 플래그. \Recent는 STORE 또는 APPEND 명령에서 인수로 사용할 수 없으므로 전혀 변경할 수 없습니다.

---
#### **2.3.3.  Internal Date Message Attribute**

서버에 있는 메시지의 내부 날짜 및 시간입니다. 이는 \[RFC-2822\] 헤더의 날짜와 시간이 아니라 메시지가 수신된 시간을 반영하는 날짜와 시간입니다. \[SMTP\]를 통해 전달된 메시지의 경우 이는 \[SMTP\]에 정의된 메시지의 최종 전달 날짜 및 시간이어야 합니다. IMAP4rev1 COPY 명령으로 전달된 메시지의 경우 이는 소스 메시지의 내부 날짜 및 시간이어야 합니다. IMAP4rev1 APPEND 명령에 의해 전달된 메시지의 경우 이는 APPEND 명령 설명에 지정된 날짜 및 시간이어야 합니다. 다른 모든 경우는 구현이 정의됩니다.\(SHOULD, SHOULD, SHOULD\)

---
#### **2.3.4.  [RFC-2822] Size Message Attribute**

\[RFC-2822\] 형식으로 표현된 메시지의 옥텟 수입니다.

---
#### **2.3.5.  Envelope Structure Message Attribute**

메시지의 \[RFC-2822\] 헤더에 대한 구문 분석된 표현입니다. IMAP 봉투 구조는 \[SMTP\] 봉투와 동일하지 않습니다.

---
#### **2.3.6.  Body Structure Message Attribute**

메시지의 \[MIME-IMB\] 본문 구조 정보에 대한 구문 분석된 표현입니다.

---
### **2.4.    Message Texts**

IMAP4rev1은 메시지의 전체 \[RFC-2822\] 텍스트를 가져올 수 있을 뿐만 아니라 전체 메시지 텍스트의 일부를 가져올 수도 있습니다. 구체적으로 \[RFC-2822\] 메시지 헤더, \[RFC-2822\] 메시지 본문, \[MIME-IMB\] 본문 부분 또는 \[MIME-IMB\] 헤더를 가져오는 것이 가능합니다.

---
## **3.      State and Flow Diagram**

클라이언트와 서버 간의 연결이 설정되면 IMAP4rev1 연결은 네 가지 상태 중 하나가 됩니다. 초기 상태는 서버 인사말에서 식별됩니다. 대부분의 명령은 특정 상태에서만 유효합니다. 연결이 부적절한 상태에 있는 동안 클라이언트가 명령을 시도하는 것은 프로토콜 오류이며, 서버는 BAD 또는 NO\(서버 구현에 따라 다름\) 명령 완료 결과로 응답합니다.

---
### **3.1.    Not Authenticated State**

인증되지 않은 상태에서 클라이언트는 대부분의 명령이 허용되기 전에 인증 자격 증명을 제공해야 합니다. 연결이 사전 인증되지 않은 경우 연결이 시작되면 이 상태로 들어갑니다.\(MUST\)

---
### **3.2.    Authenticated State**

인증된 상태에서 클라이언트는 인증되었으며 메시지에 영향을 미치는 명령이 허용되기 전에 액세스할 사서함을 선택해야 합니다. 이 상태는 사전 인증된 연결이 시작될 때, 허용 가능한 인증 자격 증명이 제공되었을 때, 사서함 선택 시 오류가 발생한 후 또는 성공적인 CLOSE 명령 후에 입력됩니다.\(MUST\)

---
### **3.3.    Selected State**

선택 상태에서는 액세스할 사서함이 선택되었습니다. 이 상태는 사서함이 성공적으로 선택되면 시작됩니다.

---
### **3.4.    Logout State**

로그아웃 상태에서는 접속이 종료됩니다. 이 상태는 클라이언트 요청\(LOGOUT 명령을 통해\)의 결과로 입력되거나 클라이언트나 서버 측의 일방적 작업에 의해 입력될 수 있습니다.

클라이언트가 로그아웃 상태를 요청하는 경우 서버는 연결을 닫기 전에 태그가 지정되지 않은 BYE 응답과 태그가 지정된 OK 응답을 LOGOUT 명령에 보내야 합니다. 클라이언트는 연결을 닫기 전에 LOGOUT 명령에 대한 태그된 OK 응답을 읽어야 합니다.\(MUST\)

서버는 그렇게 한 이유가 포함된 태그가 지정되지 않은 BYE 응답을 보내지 않고 일방적으로 연결을 닫아서는 안 됩니다. 클라이언트는 일방적으로 연결을 닫아서는 안 되며, 대신 LOGOUT 명령을 실행해야 합니다. 클라이언트가 일방적으로 연결을 닫은 것을 서버가 감지하면 서버는 태그가 지정되지 않은 BYE 응답을 생략하고 연결을 닫을 수도 있습니다.\(MUST NOT, SHOULD NOT, MAY\)

```text
                   +----------------------+
                   |connection established|
                   +----------------------+
                              ||
                              \/
            +--------------------------------------+
            |          server greeting             |
            +--------------------------------------+
                      || (1)       || (2)        || (3)
                      \/           ||            ||
            +-----------------+    ||            ||
            |Not Authenticated|    ||            ||
            +-----------------+    ||            ||
             || (7)   || (4)       ||            ||
             ||       \/           \/            ||
             ||     +----------------+           ||
             ||     | Authenticated  |<=++       ||
             ||     +----------------+  ||       ||
             ||       || (7)   || (5)   || (6)   ||
             ||       ||       \/       ||       ||
             ||       ||    +--------+  ||       ||
             ||       ||    |Selected|==++       ||
             ||       ||    +--------+           ||
             ||       ||       || (7)            ||
             \/       \/       \/                \/
            +--------------------------------------+
            |               Logout                 |
            +--------------------------------------+
                              ||
                              \/
                +-------------------------------+
                |both sides close the connection|
                +-------------------------------+
```

- \(1\) 사전 인증 없이 연결\(OK 인사말\) \(2\) 사전 인증된 연결\(PREAUTH 인사말\) \(3\) 연결 거부\(BYE 인사말\) \(4\) LOGIN 또는 AUTHENTICATE 명령 성공 \(5\) SELECT 또는 EXAMINE 명령 성공 \( 6\) CLOSE 명령 또는 SELECT 또는 EXAMINE 명령 실패 \(7\) LOGOUT 명령, 서버 종료 또는 연결 종료

---
## **4.      Data Formats**

IMAP4rev1은 텍스트 명령과 응답을 사용합니다. IMAP4rev1의 데이터는 원자, 숫자, 문자열, 괄호로 묶인 목록 또는 NIL 등 여러 형식 중 하나일 수 있습니다. 특정 데이터 항목은 두 가지 이상의 형식을 취할 수 있습니다. 예를 들어, "astring" 구문을 사용하여 정의된 데이터 항목은 원자 또는 문자열일 수 있습니다.

---
### **4.1.    Atom**

원자는 하나 이상의 특수 문자가 아닌 문자로 구성됩니다.

---
### **4.2.    Number**

숫자는 하나 이상의 숫자 문자로 구성되며 숫자 값을 나타냅니다.

---
### **4.3.    String**

문자열은 리터럴 또는 따옴표 붙은 문자열의 두 가지 형식 중 하나입니다. 리터럴 형식은 문자열의 일반적인 형식입니다. 인용된 문자열 형식은 사용할 수 있는 문자를 제한하여 리터럴을 처리하는 오버헤드를 방지하는 대안입니다.

리터럴은 여는 중괄호\("{"\), 옥텟 수, 닫는 중괄호\("}"\) 형식의 옥텟 수로 접두사로 묶인 0개 이상의 옥텟\(CR 및 LF 포함\)의 시퀀스입니다. 그리고 CRLF. 서버에서 클라이언트로 리터럴이 전송되는 경우 CRLF 바로 뒤에 옥텟 데이터가 옵니다. 클라이언트에서 서버로 전송되는 리터럴의 경우 클라이언트는 옥텟 데이터\(및 명령의 나머지 부분\)를 보내기 전에 명령 연속 요청\(이 문서의 뒷부분에 설명됨\)을 수신할 때까지 기다려야 합니다.\(MUST\)

따옴표 붙은 문자열은 CR 및 LF를 제외하고 각 끝에 큰따옴표\(<"\>\) 문자가 있는 0개 이상의 7비트 문자 시퀀스입니다.

빈 문자열은 ""\(큰따옴표 사이에 0개의 문자가 있는 따옴표 붙은 문자열\) 또는 {0} 다음에 CRLF\(옥텟 수가 0인 리터럴\)로 표시됩니다.

참고: 옥텟 수가 0이더라도 리터럴을 전송하는 클라이언트는 명령 연속 요청을 수신할 때까지 기다려야 합니다.\(MUST\)

---
#### **4.3.1.  8-bit and Binary Strings**

8비트 텍스트 및 바이너리 메일은 \[MIME-IMB\] 콘텐츠 전송 인코딩을 사용하여 지원됩니다. IMAP4rev1 구현은 리터럴로 8비트 또는 다중 옥텟 문자를 전송할 수 있지만 \[CHARSET\]이 식별된 경우에만 그렇게 해야 합니다.\(SHOULD\)

BINARY 본문 인코딩이 정의되었더라도 인코딩되지 않은 이진 문자열은 허용되지 않습니다. "이진 문자열"은 NUL 문자가 포함된 문자열입니다. 구현에서는 데이터를 전송하기 전에 바이너리 데이터를 BASE64와 같은 텍스트 형식으로 인코딩해야 합니다. CTL 문자 수가 너무 많은 문자열도 바이너리로 간주될 수 있습니다.\(MUST, MAY\)

---
### **4.4.    Parenthesized List**

데이터 구조는 "괄호로 묶인 목록"으로 표시됩니다. 공백으로 구분되고 각 끝이 괄호로 묶인 일련의 데이터 항목입니다. 괄호로 묶인 목록에는 중첩을 나타내기 위해 여러 수준의 괄호를 사용하여 괄호로 묶인 다른 목록이 포함될 수 있습니다.

빈 목록은 \(\)로 표시됩니다. 즉, 구성원이 없는 괄호로 묶인 목록입니다.

---
### **4.5.    NIL**

특수 형식 "NIL"은 빈 문자열 "" 또는 빈 괄호로 묶인 목록\(\)과 구별되는 문자열 또는 괄호로 묶인 목록으로 표시되는 특정 데이터 항목이 존재하지 않음을 나타냅니다.

- 참고: NIL은 원자 형태를 취하는 데이터 항목에는 절대 사용되지 않습니다. 예를 들어 "NIL"이라는 사서함 이름은 존재하지 않는 사서함 이름이 아닌 NIL이라는 사서함입니다. 이는 메일박스가 원자 또는 문자열인 "astring" 구문을 사용하기 때문입니다. 반대로 NIL의 addr-name은 존재하지 않는 개인 이름입니다. 왜냐하면 addr-name은 NIL 또는 문자열인 "nstring" 구문을 사용하지만 원자는 결코 사용하지 않기 때문입니다.

---
## **5.      Operational Considerations**

모든 IMAP4rev1 구현이 올바르게 상호 운용되도록 하기 위해 다음 규칙이 여기에 나열되어 있습니다.

---
### **5.1.    Mailbox Naming**

사서함 이름은 7비트입니다. 클라이언트 구현은 8비트 메일함 이름을 생성하려고 시도해서는 안 되며\(MUST NOT\) LIST 또는 LSUB에서 반환된 8비트 메일함 이름을 UTF-8로 해석해야 합니다\(SHOULD\). 서버 구현은 8비트 메일함 이름 생성을 금지해야 하며\(SHOULD\) LIST 또는 LSUB에 8비트 메일함 이름을 반환해서는 안 됩니다. 비ASCII 메일함 이름을 표시하는 방법에 대한 자세한 내용은 섹션 5.1.3을 참조하십시오.\(MUST NOT, SHOULD NOT\)

참고: 8비트 사서함 이름은 이전 버전에서 정의되지 않았습니다.

- 이 프로토콜의 버전. 일부 사이트에서는 ASCII가 아닌 사서함 이름을 나타내기 위해 로컬 8비트 문자 집합을 사용했습니다. 이러한 사용법은 상호 운용이 불가능하며 이제 공식적으로 더 이상 사용되지 않습니다.

대소문자를 구분하지 않는 사서함 이름 INBOX는 "이 서버에 있는 이 사용자의 기본 사서함"을 의미하기 위해 예약된 특수 이름입니다. 다른 모든 이름의 해석은 구현에 따라 다릅니다.

특히 이 사양은 INBOX가 아닌 메일함 이름의 대소문자 구분에 대해 어떠한 입장도 취하지 않습니다. 일부 서버 구현은 대소문자를 완전히 구분합니다. 다른 것들은 새로 생성된 이름의 대소문자를 유지하지만 그렇지 않은 경우에는 대소문자를 구분하지 않습니다. 또 다른 사람들은 특정 사례에 이름을 강요합니다. 클라이언트 구현은 이들 중 하나와 상호 작용해야 합니다. 서버 구현이 INBOX가 아닌 사서함 이름을 대소문자를 구분하지 않는 것으로 해석하는 경우 섹션 5.1.3에 설명된 대로 특별히 국제 명명 규칙을 사용하여 이름을 처리해야 합니다\(MUST\).\(MUST, MUST\)

새 사서함 이름을 만들 때 특정 클라이언트 고려 사항이 있습니다.

1\) 특수 원자 중 하나인 모든 문자\(형식 구문 참조\)에는 사서함 이름이 인용된 문자열이나 리터럴로 표시되어야 합니다.

2\) CTL 및 기타 그래픽이 아닌 문자는 사용자 인터페이스에서 표현하기 어려우므로 사용하지 않는 것이 가장 좋습니다.

3\) 메일함 이름에는 목록-와일드카드 문자\("%" 및 "\*"\)가 유효하지만 와일드카드 해석과의 충돌로 인해 LIST 및 LSUB 명령에서 이러한 메일함 이름을 사용하기가 어렵습니다.

4\) 일반적으로 문자\(서버 구현에 의해 결정됨\)는 계층 수준을 구분하기 위해 예약되어 있습니다.

5\) "#"과 "&"라는 두 문자는 관례에 따른 의미를 가지며 해당 관례에서 사용되는 경우를 제외하고는 사용하지 않아야 합니다.

---
#### **5.1.1.  Mailbox Hierarchy Naming**

계층적 사서함 이름을 내보내려는 경우 사서함 이름은 계층 수준을 구분하기 위해 단일 문자를 사용하여 왼쪽에서 오른쪽으로 계층적이어야 합니다. 단일 이름 내의 모든 계층 수준에 동일한 계층 구분 문자가 사용됩니다.\(MUST\)

---
#### **5.1.2.  Mailbox Namespace Naming Convention**

관례적으로 "#"으로 시작하는 사서함 이름의 첫 번째 계층 요소는 나머지 이름의 "네임스페이스"를 식별합니다. 이를 통해 각각 고유한 네임스페이스를 갖는 다양한 유형의 사서함 저장소를 명확하게 구분할 수 있습니다.

- 예를 들어, USENET 뉴스그룹에 대한 액세스를 제공하는 구현은 "#news" 네임스페이스를 사용하여 USENET 뉴스그룹 네임스페이스를 다른 메일박스의 네임스페이스와 분할할 수 있습니다. 따라서 comp.mail.misc 뉴스그룹은 "#news.comp.mail.misc"라는 사서함 이름을 가지며 "comp.mail.misc"라는 이름은 다른 개체\(예: 사용자의 개인 사서함\)를 참조할 수 있습니다. .\(MAY\)

---
#### **5.1.3.  Mailbox International Naming Convention**

관례적으로 IMAP4rev1의 국제 메일함 이름은 \[UTF-7\]에 설명된 UTF-7 인코딩의 수정된 버전을 사용하여 지정됩니다. 수정된 UTF-7은 이 프로토콜의 이전 버전을 구현하는 서버에서도 사용할 수 있습니다.

수정된 UTF-7에서는 "&"를 제외한 인쇄 가능한 US-ASCII 문자가 그 자체를 나타냅니다. 즉, 옥텟 값이 0x20-0x25 및 0x27-0x7e인 문자입니다. 문자 "&"\(0x26\)는 2옥텟 시퀀스 "&-"로 표시됩니다.

다른 모든 문자\(옥텟 값 0x00-0x1f 및 0x7f-0xff\)는 "/" 대신 ","가 사용되는 \[UTF-7\]의 추가 수정을 통해 수정된 BASE64로 표시됩니다. 수정된 BASE64는 자신을 나타낼 수 있는 인쇄 US-ASCII 문자를 나타내는 데 사용되어서는 안 됩니다.\(MUST NOT\)

"&"는 수정된 BASE64로 이동하는 데 사용되고 "-"는 US-ASCII로 다시 이동하는 데 사용됩니다. BASE64에서 US-ASCII로의 암시적 이동은 없으며 널 이동\(BASE64에서는 "-&", US-ASCII에서 "&-"는 "&"를 의미함\)은 허용되지 않습니다. 그러나 모든 이름은 US-ASCII로 시작하고 US-ASCII로 끝나야 합니다. 즉, ASCII가 아닌 ISO-10646 문자로 끝나는 이름은 "-"로 끝나야 합니다.\(MUST\)

이러한 수정의 목적은 UTF-7의 다음 문제를 해결하는 것입니다.

- 1\) UTF-7은 이동에 "+" 문자를 사용합니다. 이는 사서함 이름, 특히 USENET 뉴스 그룹 이름에서 "+"를 일반적으로 사용하는 것과 충돌합니다.

- 2\) UTF-7의 인코딩은 "/" 문자를 사용하는 BASE64입니다. 이는 널리 사용되는 계층 구분 기호로 "/"를 사용하는 것과 충돌합니다.

- 3\) UTF-7은 "\"의 인코딩되지 않은 사용을 금지합니다. 이는 널리 사용되는 계층 구분 기호로 "\"를 사용하는 것과 충돌합니다.

- 4\) UTF-7은 "\~"의 인코딩되지 않은 사용을 금지합니다. 이는 일부 서버에서 홈 디렉터리 표시기로 "\~"를 사용하는 것과 충돌합니다.

- 5\) UTF-7은 동일한 문자열을 나타내는 여러 대체 형식을 허용합니다. 특히 인쇄 가능한 US-ASCII 문자는 인코딩된 형식으로 표시될 수 있습니다.

- 수정된 UTF-7은 규칙이지만 "&" 문자가 포함된 사서함 이름을 처리하는 서버에 대한 특정 요구 사항을 설정합니다. 특히 서버 구현은 수정된 UTF-7 이름의 수정된 BASE64 부분의 정확한 형식을 유지해야 하며 이름이 대소문자를 구분하지 않거나 대소문자를 접는 경우에도 해당 텍스트를 대소문자를 구분하여 처리해야 합니다.\(MUST\)

- 서버 구현은 CREATE에 대한 인수로 사용되는 "&" 문자가 포함된 모든 메일함 이름이 올바르게 수정된 UTF-7 구문에 있는지, 불필요한 시프트가 없는지, 수정된 BASE64 인쇄에 인코딩이 없는지 확인해야 합니다. 자신을 나타낼 수 있는 US-ASCII 문자입니다. 그러나 클라이언트 구현은 이를 수행하는 서버에 의존해서는 안 되며, 수정된 UTF-7 구문을 준수하지 않는 한 "&" 문자가 포함된 메일함 이름을 생성하려고 시도해서는 안 됩니다.\(SHOULD, MUST NOT\)

- 수정된 UTF-7 규칙을 따르지 않는 메일 저장소를 내보내는 서버 구현은 비ASCII 문자 또는 "&" 문자가 포함된 모든 메일함 이름을 수정된 UTF-7로 변환해야 합니다.\(MUST\)

```text
           For example, here is a mailbox name which mixes English,
           Chinese, and Japanese text:
           ~peter/mail/&U,BTFw-/&ZeVnLIqe-
```

- 예를 들어 문자열 "&Jjo!" "!" 앞에 US-ASCII로의 이동이 포함되어 있지 않기 때문에 유효한 사서함 이름이 아닙니다. 올바른 형식은 "&Jjo-!"입니다. 문자열 "&U,BTFw-&ZeVnLIqe-"에는 불필요한 시프트가 포함되어 있으므로 허용되지 않습니다. 올바른 형식은 "&U,BTF2XlZyyKng-"입니다.

---
### **5.2.    Mailbox Size and Message Status Updates**

언제든지 서버는 클라이언트가 요청하지 않은 데이터를 보낼 수 있습니다. 때로는 그러한 행동이 필요합니다. 예를 들어, 서버 이외의 에이전트는 사서함에 메시지를 추가하거나\(예: 새 메시지 전달\), 사서함에 있는 메시지의 플래그를 변경하거나\(예: 여러 에이전트가 동일한 사서함에 동시에 액세스\), 심지어 메시지를 제거할 수도 있습니다. 사서함. 명령을 처리하는 동안 메일함 크기 변경이 관찰되면 서버는 메일함 크기 업데이트를 자동으로 보내야 합니다. 서버는 클라이언트가 그러한 업데이트를 명시적으로 요청할 필요 없이 자동으로 메시지 플래그 업데이트를 보내야 합니다.\(MUST, MAY, MUST, SHOULD\)

동기화 오류를 방지하기 위해 메시지 제거에 대한 클라이언트의 서버 알림에 대한 특별한 규칙이 있습니다. 자세한 내용은 말소 대응 설명을 참조하세요. 특히 사서함의 메시지 수를 줄이는 EXISTS 응답을 보내는 것은 허용되지 않습니다. EXPUNGE 응답만이 이를 수행할 수 있습니다.

클라이언트가 서버의 데이터 기억에 대해 어떤 구현 결정을 내리는지에 관계없이 클라이언트 구현은 메일박스 크기 업데이트를 기록해야 합니다. 초기 메일박스 선택 이후의 모든 명령이 메일박스의 크기를 반환한다고 가정해서는 안 됩니다.\(MUST, MUST NOT\)

---
### **5.3.    Response when no Command in Progress**

서버 구현에서는 진행 중인 명령이 없는 동안 태그가 지정되지 않은 응답\(EXUNGE 제외\)을 보내는 것이 허용됩니다. 그러한 응답을 보내는 서버 구현은 흐름 제어 고려 사항을 처리해야 합니다. 특히 \(1\) 데이터 크기가 기본 전송의 사용 가능한 창 크기를 초과하지 않는지 확인하거나 \(2\) 비차단 쓰기를 사용해야 합니다.\(MUST, MUST\)

---
### **5.4.    Autologout Timer**

서버에 비활성 자동 로그아웃 타이머가 있는 경우 해당 타이머의 지속 시간은 최소 30분이어야 합니다. 해당 간격 동안 클라이언트로부터 모든 명령을 수신하면 자동 로그아웃 타이머를 재설정하는 데 충분해야 합니다.\(MUST, SHOULD\)

---
### **5.5.    Multiple Commands in Progress**

클라이언트는 기본 데이터 스트림에 대한 모호성 규칙\(아래 참조\) 및 흐름 제어 제약 조건에 따라 명령의 완료 결과 응답을 기다리지 않고 다른 명령을 보낼 수 있습니다. 마찬가지로, 서버는 모호성 규칙에 따라 현재 명령을 완료하기 전에 다른 명령 처리를 시작할 수 있습니다. 그러나 모든 명령 연속 요청 응답과 명령 연속은 후속 명령이 시작되기 전에 협상되어야 합니다.\(MAY, MAY, MUST\)

다른 명령의 결과에 영향을 미치는 명령으로 인해 모호성이 발생하는 경우는 예외입니다. 클라이언트는 모호성이 발생할 경우 기다리지 않고 여러 명령을 보내서는 안 됩니다. 서버가 모호함을 감지한 경우 클라이언트가 지정한 순서대로 명령을 실행하여 완료해야 합니다.\(MUST NOT, MUST\)

모호성의 가장 명백한 예는 명령이 다른 명령의 결과에 영향을 미치는 경우입니다\(예: 메시지 플래그의 FETCH 및 동일한 메시지 플래그의 STORE\).

태그가 지정되지 않은 EXPUNGE 응답을 허용하는 명령\(FETCH, STORE 및 SEARCH 이외의 명령\)에서는 명확하지 않은 모호성이 발생합니다. 태그가 지정되지 않은 EXPUNGE 응답은 후속 명령의 시퀀스 번호를 무효화할 수 있기 때문입니다. FETCH, STORE 또는 SEARCH 명령의 경우 이러한 명령이 진행 중인 동안에는 서버가 EXPUNGE 응답을 보내는 것이 금지되어 있으므로 이는 문제가 되지 않습니다. 따라서 클라이언트가 FETCH, STORE 또는 SEARCH 이외의 명령을 보내는 경우 메시지 시퀀스 번호가 포함된 명령을 보내기 전에 완료 결과 응답을 기다려야 합니다.\(MUST\)

- 참고: UID FETCH, UID STORE 및 UID SEARCH는 FETCH, STORE 및 SEARCH와 다른 명령입니다. 클라이언트가 UID 명령을 보내는 경우 메시지 시퀀스 번호가 포함된 명령을 보내기 전에 완료 결과 응답을 기다려야 합니다.

예를 들어, 다음과 같은 대기하지 않는 명령 시퀀스는 유효하지 않습니다.

```text
      FETCH + NOOP + STORE
      STORE + COPY + FETCH
      COPY + COPY
      CHECK + FETCH
```

다음은 대기하지 않는 유효한 명령 시퀀스의 예입니다.

```text
      FETCH + STORE + SEARCH + CHECK
      STORE + COPY + EXPUNGE
```

- UID SEARCH + UID SEARCH는 두 번째 UID SEARCH에 메시지 시퀀스 번호가 포함되어 있는지 여부에 따라 대기 명령 시퀀스로 유효하거나 유효하지 않을 수 있습니다.

---
## **6.      Client Commands**

이 섹션에서는 IMAP4rev1 명령에 대해 설명합니다. 명령은 명령이 허용되는 상태에 따라 구성됩니다. 여러 상태에서 허용되는 명령은 최소 허용 상태에 나열됩니다\(예: 인증된 상태 및 선택됨 상태에서 유효한 명령은 인증된 상태 명령에 나열됩니다\).

아래 명령 설명에서 "인수:"로 식별되는 명령 인수는 구문이 아닌 기능으로 설명됩니다. 명령 인수의 정확한 구문은 형식 구문 섹션에 설명되어 있습니다.

일부 명령은 특정 서버 응답을 반환하게 합니다. 이는 아래 명령 설명에서 "응답:"으로 식별됩니다. 이러한 응답에 대한 정보는 응답 섹션의 응답 설명을 참조하고, 이러한 응답의 정확한 구문은 형식 구문 섹션을 참조하세요. 모든 명령의 결과로 서버 데이터가 전송될 수 있습니다. 따라서 서버 데이터가 특별히 필요하지 않은 명령은 "없음" 대신 "이 명령에 대한 특정 응답 없음"을 지정합니다.

명령 설명의 "결과:"는 명령에 대해 태그가 지정된 상태 응답과 이러한 상태 응답의 특별한 해석을 나타냅니다.

연결 상태는 상태 변경으로 문서화된 성공적인 명령에 의해서만 변경됩니다. 거부된 명령\(BAD 응답\)은 연결 상태나 선택한 사서함의 상태를 변경하지 않습니다. 실패한 명령\(NO 응답\)은 일반적으로 연결 상태나 선택한 메일함의 상태를 변경하지 않습니다. SELECT 및 EXAMINE 명령은 예외입니다.

---
### **6.1.    Client Commands - Any State**

CAPABILITY, NOOP, LOGOUT 명령은 모든 상태에서 유효합니다.

---
#### **6.1.1.  CAPABILITY Command**

```text
   Arguments:  none

   Responses:  REQUIRED untagged response: CAPABILITY
```

결과: OK - 기능이 완료되었습니다.

- BAD - 명령을 알 수 없거나 인수가 잘못되었습니다.

- CAPABILITY 명령은 서버가 지원하는 기능 목록을 요청합니다. 서버는 \(태그가 지정된\) OK 응답 전에 나열된 기능 중 하나로 "IMAP4rev1"과 함께 태그가 지정되지 않은 단일 CAPABILITY 응답을 보내야 합니다.\(MUST\)

- "AUTH="로 시작하는 기능 이름은 서버가 특정 인증 메커니즘을 지원함을 나타냅니다. 이러한 모든 이름은 정의에 따라 이 사양의 일부입니다. 예를 들어, 실험적인 "blurdybloop" 인증자에 대한 권한 부여 기능은 "XAUTH=BLURDYBLOOP" 또는 "XAUTH=XBLURDYBLOOP"가 아니라 "AUTH=XBLURDYBLOOP"입니다.

다른 기능 이름은 확장, 개정 또는

- 이 사양에 대한 개정. 추가 정보는 CAPABILITY 응답 문서를 참조하세요. 이 사양에 정의된 기본 IMAP4rev1 세트 이상의 기능은 해당 기능을 호출하기 위한 명시적인 클라이언트 작업 없이는 활성화되지 않습니다.

- 클라이언트 및 서버 구현은 STARTTLS, LOGINDISABLED 및 AUTH=PLAIN\(\[IMAP-TLS\]에 설명됨\) 기능을 구현해야 합니다. 중요한 정보는 보안 고려 사항 섹션을 참조하세요.\(MUST\)

"클라이언트 명령 -

- 실험/확장'을 참조하여 사이트 형태 또는 구현별 기능에 대한 정보를 확인하세요.

예: C: abcd 기능

- S: \* CAPABILITY IMAP4rev1 STARTTLS AUTH=GSSAPI LOGINDISABLED S: abcd OK CAPABILITY 완료 C: efgh STARTTLS S: efgh OK STARTLS 완료 <TLS 협상, 추가 명령은 \[TLS\] 레이어 아래에 있습니다.\> C: ijkl CAPABILITY S: \* CAPABILITY IMAP4rev1 AUTH =GSSAPI AUTH=PLAIN S: ijkl OK 기능 완료

---
#### **6.1.2.  NOOP Command**

```text
   Arguments:  none

   Responses:  no specific responses for this command (but see below)
```

결과: OK - 아니요 완료됨

- BAD - 명령을 알 수 없거나 인수가 잘못되었습니다.

- NOOP 명령은 항상 성공합니다. 아무것도 하지 않습니다.

- 모든 명령은 상태 업데이트를 태그 없는 데이터로 반환할 수 있으므로 NOOP 명령은 비활성 기간 동안 새 메시지 또는 메시지 상태 업데이트에 대한 주기적인 폴링으로 사용될 수 있습니다\(이를 수행하는 데 선호되는 방법입니다\). NOOP 명령을 사용하여 서버의 비활성 자동 로그아웃 타이머를 재설정할 수도 있습니다.

```text
   Example:    C: a002 NOOP
               S: a002 OK NOOP completed
                  . . .
               C: a047 NOOP
               S: * 22 EXPUNGE
               S: * 23 EXISTS
               S: * 3 RECENT
               S: * 14 FETCH (FLAGS (\Seen \Deleted))
               S: a047 OK NOOP completed
```

---
#### **6.1.3.  LOGOUT Command**

```text
   Arguments:  none

   Responses:  REQUIRED untagged response: BYE
```

결과: OK - 로그아웃 완료

- BAD - 명령을 알 수 없거나 인수가 잘못되었습니다.

- LOGOUT 명령은 클라이언트의 연결이 완료되었음을 서버에 알립니다. 서버는 \(태그된\) OK 응답 전에 BYE 태그 없는 응답을 보낸 다음 네트워크 연결을 닫아야 합니다.\(MUST\)

```text
   Example:    C: A023 LOGOUT
               S: * BYE IMAP4rev1 Server logging out
               S: A023 OK LOGOUT completed
               (Server and client then close the connection)
```

---
### **6.2.    Client Commands - Not Authenticated State**

인증되지 않은 상태에서는 AUTHENTICATE 또는 LOGIN 명령을 통해 인증을 설정하고 인증된 상태로 들어갑니다. AUTHENTICATE 명령은 다양한 인증 기술, 개인 정보 보호 및 무결성 검사를 위한 일반적인 메커니즘을 제공합니다. LOGIN 명령은 기존 사용자 이름과 일반 텍스트 비밀번호 쌍을 사용하며 개인 정보 보호 또는 무결성 검사를 설정할 수 있는 수단이 없습니다.

STARTTLS 명령은 세션 개인 정보 보호 및 무결성 검사를 설정하는 대체 형식이지만 인증을 설정하거나 인증된 상태로 들어가지 않습니다.

서버 구현은 인증을 설정하지 않고도 특정 사서함에 대한 액세스를 허용할 수 있습니다. 이는 \[ANONYMOUS\]에 설명된 ANONYMOUS \[SASL\] 인증자를 통해 수행될 수 있습니다. 이전 규칙은 사용자 ID "anonymous"를 사용하는 LOGIN 명령입니다. 이 경우 서버가 모든 비밀번호를 허용하도록 선택할 수 있지만 비밀번호가 필요합니다. 익명 사용자에 대한 제한은 구현에 따라 다릅니다.\(MAY\)

한번 인증\(익명 포함\)된 후에는 미인증 상태로 다시 진입할 수 없습니다.

범용 명령\(CAPABILITY, NOOP 및 LOGOUT\) 외에도 인증되지 않은 상태에서는 STARTTLS, AUTHENTICATE 및 LOGIN 명령이 유효합니다. 이러한 명령에 대한 중요한 정보는 보안 고려 사항 섹션을 참조하세요.

---
#### **6.2.1.  STARTTLS Command**

```text
   Arguments:  none
```

응답: 이 명령에 대한 구체적인 응답이 없습니다.

결과: OK - starttls 완료, TLS 협상 시작

- BAD - 명령을 알 수 없거나 인수가 잘못되었습니다.

- \[TLS\] 협상은 서버로부터 태그가 지정된 OK 응답이 끝나는 CRLF 직후에 시작됩니다. 클라이언트가 STARTTLS 명령을 실행하면 서버 응답이 표시되고 \[TLS\] 협상이 완료될 때까지 추가 명령을 실행해서는 안 됩니다.\(MUST NOT\)

- \[TLS\] 협상 중에 클라이언트 자격 증명이 제공되더라도 서버는 인증되지 않은 상태로 유지됩니다. 이는 EXTERNAL\(\[SASL\]에 정의됨\)과 같은 인증 메커니즘이 \[TLS\] 협상에 의해 결정된 클라이언트 ID를 사용하는 것을 배제하지 않습니다.

- \[TLS\]가 시작되면 클라이언트는 서버 기능에 대해 캐시된 정보를 폐기해야 하며 CAPABILITY 명령을 다시 실행해야 합니다. 이는 STARTTLS 이전에 기능 목록을 변경하는 중간자 공격으로부터 보호하는 데 필요합니다. 서버는 STARTTLS 이후에 다른 기능을 광고할 수 있습니다.\(MUST, MAY\)

예: C: a001 기능

- S: \* CAPABILITY IMAP4rev1 STARTTLS LOGINDISABLED S: a001 OK CAPABILITY Complete C: a002 STARTTLS S: a002 OK 지금 TLS 협상 시작 <TLS 협상, 추가 명령은 \[TLS\] 레이어 아래에 있습니다.\> C: a003 CAPABILITY S: \* CAPABILITY IMAP4rev1 AUTH= 일반 S: a003 OK CAPABILITY 완료 C: a004 로그인 조 비밀번호 S: a004 OK 로그인 완료

---
#### **6.2.2.  AUTHENTICATE Command**

```text
   Arguments:  authentication mechanism name
```

응답: 연속 데이터를 요청할 수 있습니다.

결과: OK - 인증 완료, 이제 인증된 상태임 NO - 인증 실패: 지원되지 않는 인증 메커니즘, 자격 증명이 거부됨 BAD - 알 수 없는 명령 또는 잘못된 인수, 인증 교환이 취소됨

- AUTHENTICATE 명령은 서버에 대한 \[SASL\] 인증 메커니즘을 나타냅니다. 서버가 요청된 인증 메커니즘을 지원하는 경우 클라이언트를 인증하고 식별하기 위해 인증 프로토콜 교환을 수행합니다. 또한 후속 프로토콜 상호 작용을 위해 선택적 보안 계층을 협상할 수도 있습니다. 요청된 인증 메커니즘이 지원되지 않는 경우 서버는 태그가 지정된 NO 응답을 전송하여 AUTHENTICATE 명령을 거부해야 합니다.\(MAY, SHOULD\)

- AUTHENTICATE 명령은 \[SASL\]의 선택적 "초기 응답" 기능을 지원하지 않습니다. \[SASL\]의 섹션 5.1은 초기 응답을 사용하는 인증 메커니즘을 처리하는 방법을 지정합니다.

- \[SASL\]의 이 프로토콜 프로파일에 지정된 서비스 이름은 "imap"입니다.

- 인증 프로토콜 교환은 인증 메커니즘에 특정한 일련의 서버 챌린지 및 클라이언트 응답으로 구성됩니다. 서버 챌린지는 "+" 토큰과 그 뒤에 BASE64로 인코딩된 문자열이 포함된 명령 연속 요청 응답으로 구성됩니다. 클라이언트 응답은 BASE64로 인코딩된 문자열로 구성된 단일 라인으로 구성됩니다. 클라이언트가 인증 교환을 취소하려는 경우 단일 "\*"로 구성된 줄을 발행합니다. 서버가 그러한 응답을 수신하면 태그가 지정된 BAD 응답을 전송하여 AUTHENTICATE 명령을 거부해야 합니다.\(MUST\)

\[SASL\]을 통해 보안 레이어를 협상하는 경우

- 인증 교환, 클라이언트에 대한 인증 교환을 완료하는 CRLF와 서버에 대한 태그된 OK 응답의 CRLF 직후에 적용됩니다.

- 클라이언트 및 서버 구현은 AUTHENTICATE 명령 자체를 구현해야 하지만 설명된 PLAIN 메커니즘 이외의 인증 메커니즘을 구현할 필요는 없습니다.\(MUST\)

- \[IMAP-TLS\]에서. 또한 보안 계층을 지원하기 위해 인증 메커니즘이 필요하지 않습니다.

참고: 서버 구현은 다음을 구현해야 합니다.

- STARTTLS 명령이 협상되거나 비밀번호 스누핑으로부터 세션을 보호하는 다른 메커니즘이 제공되지 않는 한 일반 텍스트 비밀번호 메커니즘을 허용하지 않는 구성입니다. 서버 사이트는 비밀번호 스누핑에 대한 보호 메커니즘 없이 일반 텍스트 비밀번호 메커니즘을 허용하는 구성을 사용해서는 안 됩니다. 클라이언트 및 서버 구현은 \[SASL\] 및/또는 \[DIGEST-MD5\] 메커니즘에 설명된 GSSAPI 메커니즘과 같이 일반 텍스트 비밀번호를 사용하지 않는 추가 \[SASL\] 메커니즘을 구현해야 합니다\(SHOULD\).\(MUST, SHOULD NOT, SHOULD\)

서버와 클라이언트는 다중 인증을 지원할 수 있습니다.

- 메커니즘. 서버는 클라이언트가 사용할 인증 메커니즘을 알 수 있도록 CAPABILITY 명령에 대한 응답으로 지원되는 인증 메커니즘을 나열해야 합니다.\(SHOULD\)

- 서버는 기능을 자동으로 전송하기 위해 성공적인 AUTHENTICATE 명령의 태그된 OK 응답에 CAPABILITY 응답 코드를 포함할 수 있습니다. 클라이언트가 이러한 자동 기능을 인식하는 경우 별도의 CAPABILITY 명령을 보낼 필요가 없습니다. AUTHENTICATE 명령의 일부로 태그가 지정된 OK 응답은 암호화/무결성 검사로 보호되지 않기 때문에 보안 계층이 AUTHENTICATE 명령으로 협상되지 않은 경우에만 이 작업을 수행해야 합니다. \[SASL\]에서는 이 경우 클라이언트가 CAPABILITY 명령을 다시 발행하도록 요구합니다.\(MAY\)

- AUTHENTICATE 명령이 NO 응답으로 실패하는 경우 클라이언트는 다른 AUTHENTICATE 명령을 발행하여 다른 인증 메커니즘을 시도할 수 있습니다. 또한 LOGIN 명령을 사용하여 인증을 시도할 수도 있습니다\(자세한 내용은 섹션 6.2.3 참조\). 즉, 클라이언트는 최후의 수단으로 LOGIN 명령을 사용하여 선호도가 감소하는 순서로 인증 유형을 요청할 수 있습니다.\(MAY, MAY, MAY\)

- 인증 교환 중에 클라이언트에서 서버로 전달된 인증 ID는 서버에서 클라이언트가 요청하는 권한을 가진 사용자 이름으로 해석됩니다.

```text
   Example:    S: * OK IMAP4rev1 Server
               C: A001 AUTHENTICATE GSSAPI
               S: +
               C: YIIB+wYJKoZIhvcSAQICAQBuggHqMIIB5qADAgEFoQMCAQ6iBw
                  MFACAAAACjggEmYYIBIjCCAR6gAwIBBaESGxB1Lndhc2hpbmd0
                  b24uZWR1oi0wK6ADAgEDoSQwIhsEaW1hcBsac2hpdmFtcy5jYW
                  Mud2FzaGluZ3Rvbi5lZHWjgdMwgdCgAwIBAaEDAgEDooHDBIHA
                  cS1GSa5b+fXnPZNmXB9SjL8Ollj2SKyb+3S0iXMljen/jNkpJX
                  AleKTz6BQPzj8duz8EtoOuNfKgweViyn/9B9bccy1uuAE2HI0y
                  C/PHXNNU9ZrBziJ8Lm0tTNc98kUpjXnHZhsMcz5Mx2GR6dGknb
                  I0iaGcRerMUsWOuBmKKKRmVMMdR9T3EZdpqsBd7jZCNMWotjhi
                  vd5zovQlFqQ2Wjc2+y46vKP/iXxWIuQJuDiisyXF0Y8+5GTpAL
                  pHDc1/pIGmMIGjoAMCAQGigZsEgZg2on5mSuxoDHEA1w9bcW9n
                  FdFxDKpdrQhVGVRDIzcCMCTzvUboqb5KjY1NJKJsfjRQiBYBdE
                  NKfzK+g5DlV8nrw81uOcP8NOQCLR5XkoMHC0Dr/80ziQzbNqhx
                  O6652Npft0LQwJvenwDI13YxpwOdMXzkWZN/XrEqOWp6GCgXTB
                  vCyLWLlWnbaUkZdEYbKHBPjd8t/1x5Yg==
               S: + YGgGCSqGSIb3EgECAgIAb1kwV6ADAgEFoQMCAQ+iSzBJoAMC
                  AQGiQgRAtHTEuOP2BXb9sBYFR4SJlDZxmg39IxmRBOhXRKdDA0
                  uHTCOT9Bq3OsUTXUlk0CsFLoa8j+gvGDlgHuqzWHPSQg==
               C:
               S: + YDMGCSqGSIb3EgECAgIBAAD/////6jcyG4GE3KkTzBeBiVHe
                  ceP2CWY0SR0fAQAgAAQEBAQ=
               C: YDMGCSqGSIb3EgECAgIBAAD/////3LQBHXTpFfZgrejpLlLImP
                  wkhbfa2QteAQAgAG1yYwE=
               S: A001 OK GSSAPI authentication successful
```

- 참고: 서버 챌린지 및 클라이언트 응답 내의 줄 바꿈은 편집상의 명확성을 위한 것이며 실제 인증자가 아닙니다.

---
#### **6.2.3.  LOGIN Command**

```text
   Arguments:  user name
               password
```

응답: 이 명령에 대한 구체적인 응답이 없습니다.

결과: OK - 로그인이 완료되었으며 이제 인증된 상태입니다.

- 아니요 - 로그인 실패: 사용자 이름 또는 비밀번호가 거부됨 BAD - 알 수 없는 명령 또는 잘못된 인수

- LOGIN 명령은 서버에 대해 클라이언트를 식별하고 이 사용자를 인증하는 일반 텍스트 비밀번호를 전달합니다.

- 서버는 기능을 자동으로 전송하기 위해 성공적인 LOGIN 명령에 대한 태그된 OK 응답에 CAPABILITY 응답 코드를 포함할 수 있습니다. 클라이언트가 이러한 자동 기능을 인식하는 경우 별도의 CAPABILITY 명령을 보낼 필요가 없습니다.\(MAY\)

```text
   Example:    C: a001 LOGIN SMITH SESAME
               S: a001 OK LOGIN completed
```

참고: 안전하지 않은 네트워크에서 LOGIN 명령 사용

- \(인터넷 등\) 네트워크 트래픽을 모니터링하는 사람은 누구나 일반 텍스트 비밀번호를 얻을 수 있으므로 보안 위험이 있습니다. LOGIN 명령은 최후의 수단을 제외하고는 사용되어서는 안 되며, 클라이언트 구현에는 LOGIN 명령의 자동 사용을 비활성화하는 수단이 있는 것이 좋습니다.\(SHOULD NOT\)

- STARTTLS 명령이 협상되었거나 비밀번호 스누핑으로부터 세션을 보호하는 다른 메커니즘이 제공되지 않는 한, 서버 구현은 LOGINDISABLED 기능을 광고하고 LOGIN 명령을 허용하지 않는 구성을 구현해야 합니다. 서버 사이트는 비밀번호 스누핑에 대한 보호 메커니즘 없이 LOGIN 명령을 허용하는 구성을 사용해서는 안 됩니다. 클라이언트 구현은 LOGINDISABLED 기능이 광고되는 경우 LOGIN 명령을 보내서는 안 됩니다.\(MUST, SHOULD NOT, MUST NOT\)

---
### **6.3.    Client Commands - Authenticated State**

인증된 상태에서는 사서함을 원자적 엔터티로 조작하는 명령이 허용됩니다. 이러한 명령 중에서 SELECT 및 EXAMINE 명령은 액세스할 사서함을 선택하고 선택된 상태로 들어갑니다.

범용 명령\(CAPABILITY, NOOP 및 LOGOUT\) 외에도 SELECT, EXAMINE, CREATE, DELETE, RENAME, SUBSCRIBE, UNSUBSCRIBE, LIST, LSUB, STATUS 및 APPEND 명령이 인증된 상태에서 유효합니다.

---
#### **6.3.1.  SELECT Command**

```text
   Arguments:  mailbox name

   Responses:  REQUIRED untagged responses: FLAGS, EXISTS, RECENT
               REQUIRED OK untagged responses:  UNSEEN,  PERMANENTFLAGS,
               UIDNEXT, UIDVALIDITY
```

결과: OK - 선택이 완료되었습니다. 이제 선택 상태입니다.

- 아니요 - 선택 실패, 현재 인증된 상태: 해당 사서함이 없으며 사서함에 액세스할 수 없습니다. BAD - 알 수 없는 명령 또는 잘못된 인수

- SELECT 명령은 사서함에 있는 메시지에 액세스할 수 있도록 사서함을 선택합니다. 클라이언트에 OK를 반환하기 전에 서버는 태그가 지정되지 않은 다음 데이터를 클라이언트에 보내야 합니다. 이 프로토콜의 이전 버전에는 태그가 지정되지 않은 FLAGS, EXISTS 및 RECENT 데이터만 필요했습니다. 결과적으로 클라이언트 구현은 개별 항목과 논의된 대로 누락된 데이터에 대한 기본 동작을 구현해야 합니다\(SHOULD\).\(MUST, SHOULD\)

- FLAGS 사서함에 정의된 플래그입니다. 자세한 내용은 FLAGS 응답 설명을 참조하세요.

- <n\> EXISTS 사서함에 있는 메시지 수입니다. 자세한 내용은 EXISTS 응답 설명을 참조하세요.

- <n\> RECENT \Recent 플래그가 설정된 메시지 수입니다. 자세한 내용은 RECENT 응답 설명을 참조하세요.

확인 \[보이지 않음 <n\>\]

- 사서함에서 확인되지 않은 첫 번째 메시지의 메시지 시퀀스 번호입니다. 이것이 누락된 경우 클라이언트는 사서함에서 처음으로 확인되지 않은 메시지에 대해 어떤 가정도 할 수 없으며 해당 메시지를 찾으려면 SEARCH 명령을 실행해야 합니다.

확인 \[PERMANENTFLAGS \(<플래그 목록\>\)\]

- 클라이언트가 영구적으로 변경할 수 있는 메시지 플래그 목록입니다. 이것이 누락된 경우 클라이언트는 모든 플래그가 영구적으로 변경될 수 있다고 가정해야 합니다.

확인 \[UIDNEXT <n\>\]

- 다음 고유 식별자 값입니다. 자세한 내용은 섹션 2.3.1.1을 참조하세요. 이것이 누락되면 클라이언트는 다음 고유 식별자 값에 대해 어떠한 가정도 할 수 없습니다.

확인 \[UIDVALIDITY <n\>\]

- 고유 식별자 유효성 값입니다. 자세한 내용은 섹션 2.3.1.1을 참조하세요. 이것이 누락되면 서버가 고유 식별자를 지원하지 않는 것입니다.

- 연결 시 한 번에 하나의 사서함만 선택할 수 있습니다. 여러 사서함에 동시에 액세스하려면 여러 연결이 필요합니다. SELECT 명령은 새 선택을 시도하기 전에 현재 선택된 사서함을 자동으로 선택 취소합니다. 따라서 사서함을 선택하고 실패한 SELECT 명령을 시도하면 사서함이 선택되지 않습니다.

- 클라이언트가 사서함을 수정하도록 허용된 경우 서버는 태그가 지정된 OK 응답의 텍스트 앞에 "\[READ-WRITE\]" 응답 코드를 붙여야 합니다.\(SHOULD\)

- 클라이언트가 메일함 수정은 허용되지 않지만 읽기 액세스는 허용된 경우 메일함은 읽기 전용으로 선택되고 서버는 태그가 지정된 OK 응답의 텍스트 앞에 "\[READ-ONLY\]" 응답을 SELECT 앞에 붙여야 합니다. 암호. SELECT를 통한 읽기 전용 액세스는 특정 읽기 전용 사서함이 사용자별\(전역이 아닌\) 영구 상태 변경을 허용할 수 있다는 점에서 EXAMINE 명령과 다릅니다. 서버 기반 .newsrc 파일에 표시된 Netnews 메시지는 읽기 전용 메일함으로 수정될 수 있는 사용자별 영구 상태의 예입니다.\(MUST, MAY\)

예: C: A142 받은 편지함 선택

- S: \* 172 존재 S: \* 1 최근 S: \* 확인 \[UNSEEN 12\] 메시지 12가 처음으로 표시되지 않음 S: \* 확인 \[UIDVALIDITY 3857529045\] 유효한 UID S: \* 확인 \[UIDNEXT 4392\] 예측된 다음 UID S: \* FLAGS \( \답변 \플래그됨 \삭제됨 \본 \초안\) S: \* 확인 \[PERMANENTFLAGS \(\삭제됨 \본 \*\)\] 제한됨 S: A142 확인 \[읽기-쓰기\] 선택 완료

---
#### **6.3.2.  EXAMINE Command**

```text
   Arguments:  mailbox name

   Responses:  REQUIRED untagged responses: FLAGS, EXISTS, RECENT
               REQUIRED OK untagged responses:  UNSEEN,  PERMANENTFLAGS,
               UIDNEXT, UIDVALIDITY
```

결과: OK - 검사가 완료되었으며 이제 선택된 상태입니다.

- 아니요 - 검사 실패, 현재 인증된 상태: 해당 사서함이 없으며 사서함에 액세스할 수 없습니다. BAD - 알 수 없는 명령 또는 잘못된 인수

- EXAMINE 명령은 SELECT와 동일하며 동일한 출력을 반환합니다. 그러나 선택한 사서함은 읽기 전용으로 식별됩니다. 사용자별 상태를 포함하여 사서함의 영구 상태에 대한 변경은 허용되지 않습니다. 특히 EXAMINE으로 인해 메시지의 \Recent 플래그가 손실되어서는 안 됩니다.\(MUST NOT\)

- EXAMINE 명령에 대한 태그가 지정된 OK 응답의 텍스트는 "\[READ-ONLY\]" 응답 코드로 시작해야 합니다.\(MUST\)

예: C: A932 EXAMINE 블러디블루프

- S: \* 17 존재 S: \* 2 최근 S: \* 확인 \[UNSEEN 8\] 메시지 8이 처음으로 표시되지 않음 S: \* 확인 \[UIDVALIDITY 3857529045\] 유효한 UID S: \* 확인 \[UIDNEXT 4392\] 예측된 다음 UID S: \* FLAGS \( \답변 \플래그됨 \삭제됨 \본 \초안\) S: \* 확인 \[PERMANENTFLAGS \(\)\] 영구 플래그가 허용되지 않음 S: A932 확인 \[읽기 전용\] 검사 완료됨

---
#### **6.3.3.  CREATE Command**

```text
   Arguments:  mailbox name
```

응답: 이 명령에 대한 구체적인 응답이 없습니다.

결과: 확인 - 생성이 완료되었습니다.

- 아니요 - 생성 실패: 해당 이름으로 사서함을 생성할 수 없습니다. BAD - 알 수 없는 명령 또는 잘못된 인수

- CREATE 명령은 주어진 이름으로 메일함을 생성합니다. 해당 이름의 새 사서함이 생성된 경우에만 OK 응답이 반환됩니다. 기존 메일함을 참조하는 이름으로 INBOX 또는 메일함을 생성하려고 하면 오류가 발생합니다. 생성 중 오류가 발생하면 태그가 지정된 NO 응답이 반환됩니다.

- 사서함 이름에 서버의 계층 구분 문자\(LIST 명령에 의해 서버에서 반환됨\)가 접미사로 붙는 경우 이는 클라이언트가 계층에서 이 이름 아래에 사서함 이름을 만들려는 선언입니다. 이 선언이 필요하지 않은 서버 구현은 선언을 무시해야 합니다\(MUST\). 어떤 경우든 생성된 이름에는 후행 계층 구분 기호가 없습니다.\(MUST\)

- 서버의 계층 구분 문자가 이름의 다른 곳에 나타나면 서버는 CREATE 명령을 성공적으로 완료하는 데 필요한 상위 계층 이름을 생성해야 합니다. 즉, "/"가 계층 구분 문자인 서버에서 "foo/bar/zap"을 생성하려는 시도는 foo/ 및 foo/bar/가 아직 존재하지 않는 경우 생성해야 합니다.\(SHOULD, SHOULD\)

- 삭제된 사서함과 동일한 이름으로 새 사서함이 생성된 경우 새 사서함의 고유 식별자 유효성 값이 다른 경우를 제외하고 해당 사서함의 고유 식별자는 사서함의 이전 구현에 사용된 고유 식별자보다 커야 합니다. 자세한 내용은 UID 명령 설명을 참조하세요.\(MUST\)

```text
   Example:    C: A003 CREATE owatagusiam/
               S: A003 OK CREATE completed
               C: A004 CREATE owatagusiam/blurdybloop
               S: A004 OK CREATE completed
```

- 참고: 이 예의 해석은 "/"가 LIST에서 계층 구분 기호로 반환되었는지 여부에 따라 달라집니다. "/"가 계층 구분 기호인 경우 "blurdybloop"라는 멤버가 포함된 "owatagusiam"이라는 새 계층 수준이 생성됩니다. 그렇지 않으면 동일한 계층 구조 수준에 두 개의 사서함이 생성됩니다.

---
#### **6.3.4.  DELETE Command**

```text
   Arguments:  mailbox name
```

응답: 이 명령에 대한 구체적인 응답이 없습니다.

결과: 확인 - 삭제 완료

- 아니요 - 삭제 실패: 해당 이름의 사서함을 삭제할 수 없습니다. BAD - 명령을 알 수 없거나 인수가 잘못되었습니다.

- DELETE 명령은 해당 이름의 사서함을 영구적으로 제거합니다. 사서함이 삭제된 경우에만 태그가 지정된 OK 응답이 반환됩니다. INBOX나 존재하지 않는 편지함 이름을 삭제하려고 하면 오류가 발생합니다.

- DELETE 명령은 하위 계층 이름을 제거해서는 안 됩니다. 예를 들어, 메일함 "foo"에 하위 "foo.bar"가 있는 경우\("."가 계층 구분 문자라고 가정\) "foo"를 제거해도 "foo.bar"는 제거되어서는 안 됩니다. 하위 계층 이름이 있고 \Noselect 사서함 이름 속성도 있는 이름을 삭제하려고 하면 오류가 발생합니다\(자세한 내용은 LIST 응답 설명 참조\).\(MUST NOT, MUST NOT\)

- 하위 계층 이름이 있고 \Noselect 사서함 이름 속성이 없는 이름을 삭제할 수 있습니다. 이 경우 해당 사서함의 모든 메시지가 제거되고 이름은 \Noselect 사서함 이름 특성을 갖게 됩니다.

- 삭제된 사서함의 가장 많이 사용된 고유 식별자 값은 새 구현이 다른 고유 식별자 유효성 값을 가지지 않는 한 동일한 이름으로 생성된 새 사서함이 이전 구현의 식별자를 재사용하지 않도록 보존되어야 합니다. 자세한 내용은 UID 명령 설명을 참조하세요.\(MUST\)

예: C: A682 LIST "" \*

- S: \* LIST \(\) "/" Blurdybloop S: \* LIST \(\Noselect\) "/" foo S: \* LIST \(\) "/" foo/bar S: A682 OK LIST 완료 C: A683 DELETE Blurdybloop S: A683 OK DELETE 완료됨 C: A684 DELETE foo S: A684 NO 이름 "foo"에 하위 계층 이름이 있습니다. C: A685 DELETE foo/bar S: A685 OK DELETE 완료됨 C: A686 LIST "" \* S: \* LIST \(\Noselect\) "/" foo S: A686 OK LIST 완료 C: A687 DELETE foo S: A687 OK DELETE 완료

```text
               C: A82 LIST "" *
               S: * LIST () "." blurdybloop
               S: * LIST () "." foo
               S: * LIST () "." foo.bar
               S: A82 OK LIST completed
               C: A83 DELETE blurdybloop
               S: A83 OK DELETE completed
               C: A84 DELETE foo
               S: A84 OK DELETE Completed
               C: A85 LIST "" *
               S: * LIST () "." foo.bar
               S: A85 OK LIST completed
               C: A86 LIST "" %
               S: * LIST (\Noselect) "." foo
               S: A86 OK LIST completed
```

---
#### **6.3.5.  RENAME Command**

```text
   Arguments:  existing mailbox name
               new mailbox name
```

응답: 이 명령에 대한 구체적인 응답이 없습니다.

결과: 확인 - 이름 바꾸기 완료

- 아니요 - 이름 바꾸기 실패: 해당 이름의 사서함 이름을 바꿀 수 없습니다. 해당 이름의 사서함으로 이름을 바꿀 수 없습니다. BAD - 알 수 없는 명령 또는 잘못된 인수

- RENAME 명령은 사서함 이름을 변경합니다. 태그가 지정된 OK 응답은 사서함 이름이 변경된 경우에만 반환됩니다. 존재하지 않는 편지함 이름에서 또는 이미 존재하는 편지함 이름으로 이름을 바꾸려고 하면 오류입니다. 이름을 바꾸는 동안 오류가 발생하면 태그된 NO 응답이 반환됩니다.

- 이름에 하위 계층 이름이 있는 경우 하위 계층 이름도 이름을 바꿔야 합니다. 예를 들어, "foo"의 이름을 "zap"으로 바꾸면 "foo/bar"\("/"가 계층 구분 문자라고 가정\)의 이름이 "zap/bar"로 변경됩니다.\(MUST\)

- 서버의 계층 구분 문자가 이름에 나타나면 서버는 RENAME 명령을 성공적으로 완료하는 데 필요한 상위 계층 이름을 생성해야 합니다. 즉, "/"가 계층 구분 문자인 서버에서 "foo/bar/zap"의 이름을 baz/rag/zowie로 바꾸려는 시도는 baz/ 및 baz/rag/가 아직 존재하지 않는 경우 생성되어야 합니다.\(SHOULD, SHOULD\)

- 새로운 구현이 다른 고유 식별자 유효성 값을 가지지 않는 한, 동일한 이름으로 생성된 새 사서함이 이전 구현의 식별자를 재사용하지 않도록 이전 사서함 이름의 가장 많이 사용된 고유 식별자 값을 보존해야 합니다. 자세한 내용은 UID 명령 설명을 참조하세요.\(MUST\)

- INBOX 이름 변경이 허용되며 특별한 동작이 있습니다. INBOX의 모든 메시지를 지정된 이름의 새 메일함으로 이동하고 INBOX를 비워 둡니다. 서버 구현이 INBOX의 하위 계층 이름을 지원하는 경우 INBOX의 이름 변경으로 인해 영향을 받지 않습니다.

```text
   Examples:   C: A682 LIST "" *
               S: * LIST () "/" blurdybloop
               S: * LIST (\Noselect) "/" foo
               S: * LIST () "/" foo/bar
               S: A682 OK LIST completed
               C: A683 RENAME blurdybloop sarasoop
               S: A683 OK RENAME completed
               C: A684 RENAME foo zowie
               S: A684 OK RENAME Completed
               C: A685 LIST "" *
               S: * LIST () "/" sarasoop
               S: * LIST (\Noselect) "/" zowie
               S: * LIST () "/" zowie/bar
               S: A685 OK LIST completed

               C: Z432 LIST "" *
               S: * LIST () "." INBOX
               S: * LIST () "." INBOX.bar
               S: Z432 OK LIST completed
               C: Z433 RENAME INBOX old-mail
               S: Z433 OK RENAME completed
               C: Z434 LIST "" *
               S: * LIST () "." INBOX
               S: * LIST () "." INBOX.bar
               S: * LIST () "." old-mail
               S: Z434 OK LIST completed
```

---
#### **6.3.6.  SUBSCRIBE Command**

```text
   Arguments:  mailbox
```

응답: 이 명령에 대한 구체적인 응답이 없습니다.

결과: 확인 - 구독 완료

- 아니요 - 구독 실패: 해당 이름을 구독할 수 없습니다. BAD - 알 수 없는 명령 또는 잘못된 인수

- SUBSCRIBE 명령은 LSUB 명령에 의해 반환된 대로 서버의 "활성" 또는 "가입" 사서함 집합에 지정된 사서함 이름을 추가합니다. 이 명령은 구독이 성공한 경우에만 태그가 지정된 OK 응답을 반환합니다.

- 서버는 SUBSCRIBE에 대한 메일함 인수의 유효성을 검사하여 그것이 존재하는지 확인할 수 있습니다. 그러나 해당 이름의 사서함이 더 이상 존재하지 않는 경우에도 구독 목록에서 기존 사서함 이름을 일방적으로 제거해서는 안 됩니다.\(MAY, MUST NOT\)

참고: 이 요구 사항은 서버 사이트가

- 내용이 만료된 후 잘 알려진 이름\(예: "system-alerts"\)을 가진 사서함을 정기적으로 제거하고 새 내용이 적절할 때 다시 만들도록 선택합니다.

```text
   Example:    C: A002 SUBSCRIBE #news.comp.mail.mime
               S: A002 OK SUBSCRIBE completed
```

---
#### **6.3.7.  UNSUBSCRIBE Command**

```text
   Arguments:  mailbox name
```

응답: 이 명령에 대한 구체적인 응답이 없습니다.

결과: 확인 - 구독 취소가 완료되었습니다.

- 아니요 - 구독 취소 실패: 해당 이름을 구독 취소할 수 없습니다. BAD - 명령을 알 수 없거나 인수가 잘못되었습니다.

- UNSUBSCRIBE 명령은 LSUB 명령에 의해 반환된 서버의 "활성" 또는 "가입" 사서함 집합에서 지정된 사서함 이름을 제거합니다. 이 명령은 구독 취소가 성공한 경우에만 태그가 지정된 OK 응답을 반환합니다.

```text
   Example:    C: A002 UNSUBSCRIBE #news.comp.mail.mime
               S: A002 OK UNSUBSCRIBE completed
```

---
#### **6.3.8.  LIST Command**

인수: 참조 이름

- 가능한 와일드카드가 포함된 사서함 이름

```text
   Responses:  untagged responses: LIST
```

결과: OK - 목록이 완료되었습니다.

- 아니요 - 목록 실패: 해당 참조 또는 이름을 나열할 수 없습니다. BAD - 명령을 알 수 없거나 인수가 잘못되었습니다.

- LIST 명령은 클라이언트가 사용할 수 있는 모든 이름의 전체 집합에서 이름의 하위 집합을 반환합니다. 이름 속성, 계층 구분 기호 및 이름을 포함하는 0개 이상의 태그가 지정되지 않은 LIST 응답이 반환됩니다. 자세한 내용은 LIST 응답 설명을 참조하세요.

```text
      The LIST command SHOULD return its data quickly, without undue
      delay.  For example, it SHOULD NOT go to excess trouble to
      calculate the \Marked or \Unmarked status or perform other
      processing; if each name requires 1 second of processing, then a
      list of 1200 names would take 20 minutes!
```

- 빈\("" 문자열\) 참조 이름 인수는 사서함 이름이 SELECT에 의해 해석됨을 나타냅니다. 반환된 사서함 이름은 제공된 사서함 이름 패턴과 일치해야 합니다. 비어 있지 않은 참조 이름 인수는 사서함 이름 또는 사서함 계층 구조 수준이며 사서함 이름이 해석되는 컨텍스트를 나타냅니다.\(MUST\)

- 빈\("" 문자열\) 사서함 이름 인수는 참조에 제공된 이름의 루트 이름과 계층 구분 기호를 반환하기 위한 특별 요청입니다. 참조가 루트가 아니거나 빈 문자열인 경우 루트로 반환된 값은 빈 문자열일 수 있습니다. 모든 경우에 계층 구분 기호\(또는 계층이 없는 경우 NIL\)가 반환됩니다. 이를 통해 클라이언트는 해당 이름의 사서함이 현재 존재하지 않는 경우에도 계층 구분 기호를 얻을 수 있습니다\(또는 사서함 이름이 단순하다는 것을 알 수 있습니다\).\(MAY\)

- 참조 및 사서함 이름 인수는 왼쪽에서 오른쪽으로의 명확한 계층 구조를 나타내는 정식 형식으로 해석됩니다. 반환된 사서함 이름은 해석된 형식입니다.

- 참고: 참조 인수의 해석은 구현에 따라 정의됩니다. 이는 서버 구현에 "현재 작업 디렉터리" 개념과 현재 작업 디렉터리를 재정의하는 "돌출 문자"라는 개념이 있는지 여부에 따라 달라집니다.

예를 들어 UNIX 또는 NT를 내보내는 서버의 경우

- 파일 시스템에서 참조 인수에는 현재 작업 디렉터리가 포함되고 메일함 이름 인수에는 현재 작업 디렉터리에서 해석된 이름이 포함됩니다.

- 서버 구현에 문자 분리 개념이 없는 경우 표준 형식은 일반적으로 사서함 이름이 추가된 참조 이름입니다. 서버가 네임스페이스 규칙\(섹션 5.1.2\)을 구현하는 경우 "#"은 구분 문자이므로 그렇게 처리되어야 합니다.

참조 인수가 메일함 수준이 아닌 경우

- 계층 구조\(즉, \NoInferiors 이름\) 및/또는 참조 인수가 계층 구조 구분 기호로 끝나지 않는 경우 이것이 해석되는 방식은 구현에 따라 다릅니다. 예를 들어, "foo/bar" 참조와 "rag/baz"라는 사서함 이름은 "foo/bar/rag/baz", "foo/barrag/baz" 또는 "foo/rag/baz"로 해석될 수 있습니다. . 클라이언트는 사용자의 명시적인 요청이 있는 경우를 제외하고는 그러한 참조 인수를 사용해서는 안 됩니다. 계층적 브라우저는 참조가 메일함 계층 구조의 수준이고 계층 구분 기호로 끝나지 않는 한 참조의 서버 해석에 대해 어떤 가정도 해서는 안 됩니다.\(SHOULD NOT, MUST NOT\)

- 해석된 형식에 포함된 참조 인수의 모든 부분은 해석된 형식의 접두사여야 합니다. 또한 참조 이름 인수와 동일한 형식이어야 합니다. 이 규칙을 사용하면 클라이언트는 반환된 사서함 이름이 참조 인수의 컨텍스트에 있는지 또는 사서함 인수에 대한 내용이 참조 인수를 재정의하는지 확인할 수 있습니다. 이 규칙이 없으면 클라이언트는 명명 컨텍스트를 재정의하는 "돌출" 문자를 포함하여 서버의 명명 의미 체계에 대한 지식을 가지고 있어야 합니다.\(SHOULD, SHOULD\)

- 예를 들어 다음은 UNIX 기반 서버에서 참조 및 사서함 이름이 해석될 수 있는 방법에 대한 몇 가지 예입니다.

```text
               Reference     Mailbox Name  Interpretation
               ------------  ------------  --------------
               ~smith/Mail/  foo.*         ~smith/Mail/foo.*
               archive/      %             archive/%
               #news.        comp.mail.*   #news.comp.mail.*
               ~smith/Mail/  /usr/doc/foo  /usr/doc/foo
               archive/      ~fred/Mail/*  ~fred/Mail/*
```

- 처음 세 가지 예는 참조 주장의 맥락에서 해석을 보여줍니다. "\~smith/Mail"은 "/u2/users/smith/Mail"과 같은 것으로 변환되어서는 안 됩니다. 그렇지 않으면 클라이언트가 해당 해석이 참조의 맥락에 있는지 판단하는 것이 불가능합니다.\(SHOULD NOT\)

문자 "\*"는 와일드카드이며 0개 이상과 일치합니다.

- 이 위치에 있는 캐릭터. "%" 문자는 "\*"와 유사하지만 계층 구분 기호와 일치하지 않습니다. "%" 와일드카드가 사서함 이름 인수의 마지막 문자인 경우 일치하는 계층 구조 수준도 반환됩니다. 이러한 계층 구조 수준이 선택 가능한 사서함이 아닌 경우 \Noselect 사서함 이름 특성과 함께 반환됩니다\(자세한 내용은 LIST 응답 설명 참조\).

서버 구현은 그렇지 않은 경우 "숨기기"가 허용됩니다.

- 특정 상황에서 특정 문자나 이름이 와일드카드와 일치하지 않도록 방지하여 와일드카드 문자로 사서함에 액세스할 수 있습니다. 예를 들어 UNIX 기반 서버에서는 첫 번째 "/" 문자가 일치하지 않도록 "\*"의 해석을 제한할 수 있습니다.

- 이 서버에서 이 사용자에 대해 INBOX를 지원하고 대문자 문자열 "INBOX"가 위에서 설명한 대로 해석된 참조 및 와일드카드가 포함된 사서함 이름 인수와 일치하는 경우 특수 이름 INBOX가 LIST의 출력에 포함됩니다. INBOX를 생략하는 기준은 SELECT INBOX가 실패를 반환할지 여부입니다. 사용자의 실제 INBOX가 이 서버에 있는지 아니면 다른 서버에 있는지는 중요하지 않습니다.

```text
   Example:    C: A101 LIST "" ""
               S: * LIST (\Noselect) "/" ""
               S: A101 OK LIST Completed
               C: A102 LIST #news.comp.mail.misc ""
               S: * LIST (\Noselect) "." #news.
               S: A102 OK LIST Completed
               C: A103 LIST /usr/staff/jones ""
               S: * LIST (\Noselect) "/" /
               S: A103 OK LIST Completed
               C: A202 LIST ~/Mail/ %
               S: * LIST (\Noselect) "/" ~/Mail/foo
               S: * LIST () "/" ~/Mail/meetings
               S: A202 OK LIST completed
```

---
#### **6.3.9.  LSUB Command**

인수: 참조 이름

- 가능한 와일드카드가 포함된 사서함 이름

```text
   Responses:  untagged responses: LSUB
```

결과: OK - lsub 완료

- 아니요 - lsub 실패: 해당 참조 또는 이름을 나열할 수 없습니다. BAD - 명령을 알 수 없거나 인수가 잘못되었습니다.

- LSUB 명령은 사용자가 "활성" 또는 "가입"으로 선언한 이름 집합에서 이름의 하위 집합을 반환합니다. 0개 이상의 태그가 지정되지 않은 LSUB 응답이 반환됩니다. LSUB에 대한 인수는 LIST에 대한 인수와 동일한 형식입니다.

- 반환된 태그 없는 LSUB 응답에는 태그 없는 LIST 응답과 다른 메일박스 플래그가 포함될 수 있습니다. 이런 일이 발생하면 태그가 지정되지 않은 LIST의 플래그가 더 권위 있는 것으로 간주됩니다.\(MAY\)

- % 와일드카드와 함께 LSUB를 사용할 때 특별한 상황이 발생합니다. "foo/bar"\("/" 계층 구분 기호 포함\)는 구독되지만 "foo"는 구독되지 않는 경우 어떻게 되는지 생각해 보세요. LSUB에 대한 "%" 와일드카드는 LSUB 응답에서 foo/bar가 아닌 foo를 반환해야 하며 \Noselect 속성으로 플래그를 지정해야 합니다.\(MUST\)

- 서버는 해당 이름의 사서함이 더 이상 존재하지 않는 경우에도 구독 목록에서 기존 사서함 이름을 일방적으로 제거해서는 안 됩니다.\(MUST NOT\)

```text
   Example:    C: A002 LSUB "#news." "comp.mail.*"
               S: * LSUB () "." #news.comp.mail.mime
               S: * LSUB () "." #news.comp.mail.misc
               S: A002 OK LSUB completed
               C: A003 LSUB "#news." "comp.%"
               S: * LSUB (\NoSelect) "." #news.comp.mail
               S: A003 OK LSUB completed
```

---
#### **6.3.10. STATUS Command**

```text
   Arguments:  mailbox name
               status data item names

   Responses:  untagged responses: STATUS
```

결과: OK - 상태 완료

- NO - 상태 실패: 해당 이름에 대한 상태가 없습니다 BAD - 알 수 없는 명령 또는 잘못된 인수

- STATUS 명령은 표시된 사서함의 상태를 요청합니다. 현재 선택된 메일함을 변경하지 않으며 쿼리된 메일함의 메시지 상태에 영향을 주지 않습니다. 특히 STATUS는 메시지의 \Recent 플래그를 잃어서는 안 됩니다.\(MUST NOT\)

- STATUS 명령은 두 번째 IMAP4rev1 연결을 열고 사서함에서 EXAMINE 명령을 수행하여 첫 번째 IMAP4rev1 연결에서 현재 사서함을 선택 취소하지 않고 해당 사서함의 상태를 쿼리하는 대신 사용할 수 있습니다.

- LIST 명령과 달리 STATUS 명령은 응답 속도가 빠르다고 보장되지 않습니다. 특정 상황에서는 상당히 느릴 수 있습니다. 일부 구현에서는 서버가 특정 상태 정보를 얻기 위해 내부적으로 사서함을 읽기 전용으로 열어야 합니다. 또한 LIST 명령과 달리 STATUS 명령은 와일드카드를 허용하지 않습니다.

참고: STATUS 명령은

- 현재 선택된 편지함 외의 편지함 상태. STATUS 명령으로 인해 사서함이 내부적으로 열릴 수 있고 이 정보는 선택한 사서함에서 다른 방법으로 사용할 수 있으므로 현재 선택한 사서함에서 STATUS 명령을 사용하면 안 됩니다.\(SHOULD NOT\)

- STATUS 명령은 "선택한 메일함에서 새 메시지 확인" 작업으로 사용되어서는 안 됩니다\(새 메시지 확인을 위한 적절한 방법에 대한 자세한 내용은 섹션 7, 7.3.1 및 7.3.2 참조\).\(MUST NOT\)

- STATUS 명령의 결과가 빠르다고 보장할 수 없기 때문에 클라이언트는 연속적인 STATUS 명령을 많이 실행하고 합리적인 성능을 얻을 수 있다고 기대해서는 안 됩니다.\(SHOULD NOT\)

- 요청할 수 있는 현재 정의된 상태 데이터 항목은 다음과 같습니다.

메시지

- 사서함에 있는 메시지 수입니다.

최근의

- \Recent 플래그가 설정된 메시지 수입니다.

UIDNEXT

- 사서함의 다음 고유 식별자 값입니다. 자세한 내용은 섹션 2.3.1.1을 참조하세요.

UIDVALIDITY

- 사서함의 고유 식별자 유효성 값입니다. 자세한 내용은 섹션 2.3.1.1을 참조하세요.

보이지 않는 것

- \Seen 플래그가 설정되지 않은 메시지 수입니다.

```text
   Example:    C: A042 STATUS blurdybloop (UIDNEXT MESSAGES)
               S: * STATUS blurdybloop (MESSAGES 231 UIDNEXT 44292)
               S: A042 OK STATUS completed
```

---
#### **6.3.11. APPEND Command**

```text
   Arguments:  mailbox name
               OPTIONAL flag parenthesized list
               OPTIONAL date/time string
               message literal
```

응답: 이 명령에 대한 구체적인 응답이 없습니다.

결과: OK - 추가 완료

- 아니요 - 추가 오류: 해당 사서함에 추가할 수 없습니다. 플래그, 날짜/시간 또는 메시지 텍스트에 오류가 있습니다. BAD - 알 수 없는 명령 또는 잘못된 인수

- APPEND 명령은 리터럴 인수를 지정된 대상 사서함의 끝에 새 메시지로 추가합니다. 이 인수는 \[RFC-2822\] 메시지 형식이어야 합니다. 메시지에는 8비트 문자가 허용됩니다. 8비트 데이터를 적절하게 보존할 수 없는 서버 구현은 \[MIME-IMB\] 콘텐츠 전송 인코딩을 사용하여 8비트 APPEND 데이터를 7비트로 역으로 변환할 수 있어야 합니다.\(SHOULD, MUST\)

- 참고: 필수 \[RFC-2822\] 헤더 행이 APPEND에 대한 메시지 리터럴 인수에서 생략되는 초안 메시지와 같은 예외가 있을 수 있습니다. 그렇게 하는 것의 전체 의미를 이해하고 주의 깊게 평가해야 합니다.\(MAY, MUST\)

- 괄호로 묶인 플래그 목록이 지정되면 결과 메시지에 플래그가 설정되어야 합니다. 그렇지 않으면 결과 메시지의 플래그 목록이 기본적으로 비어 있는 것으로 설정됩니다. 두 경우 모두 최근 플래그도 설정됩니다.\(SHOULD\)

- 날짜-시간이 지정되면 결과 메시지에 내부 날짜가 설정되어야 합니다. 그렇지 않으면 결과 메시지의 내부 날짜가 기본적으로 현재 날짜 및 시간으로 설정됩니다.\(SHOULD\)

- 어떤 이유로든 추가에 실패하면 사서함을 APPEND 시도 이전의 상태로 복원해야 합니다. 부분 추가는 허용되지 않습니다.\(MUST\)

- 대상 사서함이 존재하지 않는 경우 서버는 오류를 반환해야 하며 자동으로 사서함을 생성해서는 안 됩니다. 대상 사서함을 만들 수 없다는 것이 확실하지 않은 한 서버는 태그가 지정된 NO 응답 텍스트의 접두사로 응답 코드 "\[TRYCREATE\]"를 보내야 합니다. 이는 CREATE 명령을 시도하고 CREATE가 성공하면 APPEND를 다시 시도할 수 있다는 힌트를 클라이언트에 제공합니다.\(MUST NOT, MUST\)

- 현재 사서함이 선택되어 있으면 일반적인 새 메시지 작업이 발생해야 합니다. 특히 서버는 태그가 지정되지 않은 EXISTS 응답을 통해 즉시 클라이언트에 알려야 합니다. 서버가 그렇게 하지 않으면 클라이언트는 하나 이상의 APPEND 명령 후에 NOOP 명령\(또는 실패하면 CHECK 명령\)을 발행할 수 있습니다.\(SHOULD, SHOULD, MAY\)

예: C: A003 APPEND 저장된 메시지\(\Seen\) {310}

- S: + 리터럴 데이터 준비 C: 날짜: 1994년 2월 7일 월요일 21:52:25 -0800\(PST\) C: 보낸 사람: Fred Foobar <foobar@Blurdybloop.COM\> C: 제목: 오후 회의 C: 받는 사람: mooch@owatagu.siam.edu C: 메시지 ID: <B27397-0100000@Blurdybloop.COM\> C: MIME 버전: 1.0 C: 콘텐츠 유형: TEXT/PLAIN; CHARSET=US-ASCII C: C: 안녕하세요 Joe, 내일 3시 30분에 만날 수 있을까요? C: S: A003 OK APPEND 완료

- 참고: APPEND 명령은 \[SMTP\] 봉투 정보를 전송하는 메커니즘을 제공하지 않으므로 메시지 전달에 사용되지 않습니다.

---
### **6.4.    Client Commands - Selected State**

선택된 상태에서는 메일함의 메시지를 조작하는 명령이 허용됩니다.

범용 명령\(CAPABILITY, NOOP 및 LOGOUT\)과 인증된 상태 명령\(SELECT, EXAMINE, CREATE, DELETE, RENAME, SUBSCRIBE, UNSUBSCRIBE, LIST, LSUB, STATUS 및 APPEND\) 외에도 다음 명령이 유효합니다. 선택한 상태에서: CHECK, CLOSE, EXPUNGE, SEARCH, FETCH, STORE, COPY 및 UID.

---
#### **6.4.1.  CHECK Command**

```text
   Arguments:  none
```

응답: 이 명령에 대한 구체적인 응답이 없습니다.

결과: OK - 확인 완료

- BAD - 명령을 알 수 없거나 인수가 잘못되었습니다.

- CHECK 명령은 현재 선택된 메일함의 체크포인트를 요청합니다. 체크포인트는 사서함과 관련된 모든 구현 종속 관리를 나타냅니다\(예: 사서함의 서버 메모리 내 상태를 해당 사서함의 상태로 확인\).

- 디스크\)는 일반적으로 각 명령의 일부로 실행되지 않습니다. 체크포인트를 완료하는 데는 순간적이지 않은 실시간 시간이 걸릴 수 있습니다. 서버 구현에 이러한 관리 고려 사항이 없는 경우 CHECK는 NOOP와 동일합니다.\(MAY\)

- CHECK의 결과로 태그가 지정되지 않은 EXISTS개의 응답이 발생한다는 보장은 없습니다. 새로운 메시지 폴링에는 CHECK가 아닌 NOOP를 사용해야 합니다.\(SHOULD\)

```text
   Example:    C: FXXZ CHECK
               S: FXXZ OK CHECK Completed
```

---
#### **6.4.2.  CLOSE Command**

```text
   Arguments:  none
```

응답: 이 명령에 대한 구체적인 응답이 없습니다.

결과: OK - 닫기가 완료되었으며 이제 인증된 상태입니다.

- BAD - 명령을 알 수 없거나 인수가 잘못되었습니다.

- CLOSE 명령은 현재 선택한 사서함에서 \Deleted 플래그가 설정된 모든 메시지를 영구적으로 제거하고 선택한 상태에서 인증된 상태로 돌아갑니다. 태그가 지정되지 않은 EXPUNGE 응답은 전송되지 않습니다.

- 사서함이 EXAMINE 명령으로 선택되거나 읽기 전용으로 선택된 경우 메시지가 제거되지 않으며 오류가 발생하지 않습니다.

- 메일함을 선택하더라도 이전에 CLOSE 명령을 실행하지 않고 SELECT, EXAMINE 또는 LOGOUT 명령을 실행할 수 있습니다. SELECT, EXAMINE 및 LOGOUT 명령은 삭제를 수행하지 않고 현재 선택된 편지함을 암시적으로 닫습니다. 그러나 많은 메시지가 삭제되면 CLOSE-LOGOUT 또는 CLOSE-SELECT 시퀀스는 태그가 지정되지 않은 EXPUNGE 응답\(클라이언트가 무시할 수 있음\)이 전송되지 않기 때문에 EXPUNGE-LOGOUT 또는 EXPUNGE-SELECT보다 상당히 빠릅니다.\(MAY\)

```text
   Example:    C: A341 CLOSE
               S: A341 OK CLOSE completed
```

---
#### **6.4.3.  EXPUNGE Command**

```text
   Arguments:  none

   Responses:  untagged responses: EXPUNGE
```

결과: 확인 - 삭제가 완료되었습니다.

- 아니요 - 말소 실패: 말소할 수 없습니다\(예: 권한 거부\) BAD - 알 수 없는 명령 또는 잘못된 인수

- EXPUNGE 명령은 현재 선택한 사서함에서 \Deleted 플래그가 설정된 모든 메시지를 영구적으로 제거합니다. 클라이언트에 확인을 반환하기 전에 제거된 각 메시지에 대해 태그가 지정되지 않은 EXPUNGE 응답이 전송됩니다.

```text
   Example:    C: A202 EXPUNGE
               S: * 3 EXPUNGE
               S: * 3 EXPUNGE
               S: * 5 EXPUNGE
               S: * 8 EXPUNGE
               S: A202 OK EXPUNGE completed
```

참고: 이 예에서 메시지 3, 4, 7, 11에는

- \Deleted 플래그가 설정되었습니다. 자세한 설명은 말소 대응 설명을 참조하세요.

---
#### **6.4.4.  SEARCH Command**

```text
   Arguments:  OPTIONAL [CHARSET] specification
               searching criteria (one or more)

   Responses:  REQUIRED untagged response: SEARCH
```

결과: OK - 검색 완료

- 아니요 - 검색 오류: 해당 \[CHARSET\] 또는 기준을 검색할 수 없습니다. BAD - 명령을 알 수 없거나 인수가 잘못되었습니다.

- SEARCH 명령은 사서함에서 지정된 검색 기준과 일치하는 메시지를 검색합니다. 검색 기준은 하나 이상의 검색 키로 구성됩니다. 서버의 태그가 지정되지 않은 SEARCH 응답에는 검색 기준과 일치하는 메시지에 해당하는 메시지 시퀀스 번호 목록이 포함되어 있습니다.

- 여러 키가 지정된 경우 결과는 해당 키와 일치하는 모든 메시지의 교집합\(AND 기능\)입니다. 예를 들어, DELETED FROM "SMITH" SINCE 1-Feb-1994라는 기준은 1994년 2월 1일 이후 편지함에 있던 Smith가 보낸 삭제된 모든 메시지를 나타냅니다. 검색 키는 하나 이상의 검색 키를 괄호로 묶은 목록일 수도 있습니다. \(예: OR 및 NOT 키와 함께 사용\)

- 서버 구현은 TEXT 및 MESSAGE 이외의 터미널 콘텐츠 미디어 유형이 있는 \[MIME-IMB\] 본문 부분을 검색 일치 고려 사항에서 제외할 수 있습니다.\(MAY\)

OPTIONAL \[CHARSET\] 사양은 다음 단어로 구성됩니다.

- "CHARSET" 뒤에 등록된 \[CHARSET\]이 옵니다. 검색기준에 나타나는 문자열의 \[CHARSET\]을 나타냅니다. \[MIME-IMB\] 콘텐츠 전송 인코딩과 \[RFC-2822\]/\[MIME-IMB\] 헤더의 \[MIME-HDRS\] 문자열은 US-ASCII가 아닌 \[CHARSET\]의 텍스트를 비교하기 전에 디코딩되어야 합니다. US-ASCII는 반드시 지원되어야 합니다. 다른 \[CHARSET\]도 지원될 수 있습니다.\(MAY, MUST, MUST\)

- 서버가 지정된 \[CHARSET\]을 지원하지 않는 경우 태그가 지정된 NO 응답\(BAD 아님\)을 반환해야 합니다. 이 응답에는 서버가 지원하는 \[CHARSET\]을 나열할 수 있는 BADCHARSET 응답 코드가 포함되어야 합니다.\(MUST, SHOULD\)

- 문자열을 사용하는 모든 검색 키에서 문자열이 필드의 하위 문자열인 경우 메시지는 키와 일치합니다. 일치는 대소문자를 구분하지 않습니다.

- 정의된 검색키는 다음과 같습니다. 인수의 정확한 구문 정의는 형식 구문 섹션을 참조하세요.

<시퀀스 세트\>

- 지정된 메시지 시퀀스 번호 세트에 해당하는 메시지 시퀀스 번호가 있는 메시지입니다.

모두

- 사서함의 모든 메시지; ANDing의 기본 초기 키입니다.

답변됨

- \Answered 플래그가 설정된 메시지.

숨은참조 <문자열\>

- 봉투 구조의 BCC 필드에 지정된 문자열이 포함된 메시지입니다.

<날짜\> 이전

- 내부 날짜\(시간 및 시간대 무시\)가 지정된 날짜보다 이전인 메시지입니다.

본체 <문자열\>

- 메시지 본문에 지정된 문자열이 포함된 메시지입니다.

CC <문자열\>

- 봉투 구조의 CC 필드에 지정된 문자열이 포함된 메시지입니다.

삭제됨

- \Deleted 플래그가 설정된 메시지.

초안

- \Draft 플래그가 설정된 메시지.

신고됨

- \Flagged 플래그가 설정된 메시지.

<문자열\>에서

- 봉투 구조의 FROM 필드에 지정된 문자열이 포함된 메시지입니다.

HEADER <필드 이름\> <문자열\>

- 지정된 필드 이름\(\[RFC-2822\]에 정의된 대로\)이 있는 헤더가 있고 헤더 텍스트에 지정된 문자열\(콜론 뒤에 오는 내용\)이 포함된 메시지입니다. 검색할 문자열의 길이가 0인 경우 내용에 관계없이 지정된 field-name이 있는 헤더 줄이 있는 모든 메시지와 일치합니다.

키워드 <플래그\>

- 지정된 키워드 플래그가 설정된 메시지.

더 큰 <n\>

- \[RFC-2822\] 크기가 지정된 옥텟 수보다 큰 메시지.

새로운

- \Recent 플래그가 설정되어 있지만 \Seen 플래그는 설정되어 있지 않은 메시지. 이는 기능적으로 "\(RECENT UNSEEN\)"과 동일합니다.

NOT <검색 키\>

- 지정된 검색 키와 일치하지 않는 메시지입니다.

오래된

- \Recent 플래그가 설정되지 않은 메시지입니다. 이는 기능적으로 "NOT NEW"\("NOT NEW"와 반대\)와 동일합니다.

켜짐 <날짜\>

- 내부 날짜\(시간 및 시간대 무시\)가 지정된 날짜 내에 있는 메시지입니다.

또는 <검색 키1\> <검색 키2\>

- 검색 키와 일치하는 메시지입니다.

최근의

- \Recent 플래그가 설정된 메시지.

본

- \Seen 플래그가 설정된 메시지.

<날짜\> 이전에 보냄

- \[RFC-2822\] 날짜: 헤더\(시간 및 시간대 무시\)가 지정된 날짜보다 이전인 메시지.

센톤 <날짜\>

- \[RFC-2822\] Date: 헤더\(시간 및 시간대 무시\)가 지정된 날짜 내에 있는 메시지.

문장 <날짜\>

- \[RFC-2822\] 날짜: 헤더\(시간 및 시간대 무시\)가 지정된 날짜 이내이거나 이후인 메시지.

<날짜\> 이후

- 내부 날짜\(시간 및 시간대 무시\)가 지정된 날짜 이내이거나 이후인 메시지입니다.

더 작음 <n\>

- \[RFC-2822\] 크기가 지정된 옥텟 수보다 작은 메시지.

제목 <문자열\>

- 봉투 구조의 SUBJECT 필드에 지정된 문자열이 포함된 메시지입니다.

텍스트 <문자열\>

- 메시지의 헤더나 본문에 지정된 문자열이 포함된 메시지입니다.

TO <문자열\>

- 봉투 구조의 TO 필드에 지정된 문자열이 포함된 메시지입니다.

UID <시퀀스 세트\>

- 지정된 고유 식별자 집합에 해당하는 고유 식별자가 포함된 메시지입니다. 시퀀스 세트 범위가 허용됩니다.

보답 없는

- \Answered 플래그가 설정되지 않은 메시지입니다.

삭제 취소됨

- \Deleted 플래그가 설정되지 않은 메시지입니다.

언드래프트

- \Draft 플래그가 설정되지 않은 메시지입니다.

플래그가 지정되지 않음

- \Flagged 플래그가 설정되지 않은 메시지입니다.

UNKEYWORD <플래그\>

- 지정된 키워드 플래그가 설정되지 않은 메시지입니다.

보이지 않는 것

- \Seen 플래그가 설정되지 않은 메시지.

예: C: A282 SEARCH FLAGGED SINCE 1-2-Feb-1994 NOT FROM "Smith" S: \* SEARCH 2 84 882 S: A282 OK SEARCH 완료 C: A283 SEARCH TEXT "문자열이 사서함에 없음" S: \* SEARCH S: A283 OK SEARCH 완료 C: A284 SEARCH CHARSET UTF-8 TEXT {6} C: XXXXXX S: \* SEARCH 43 S: A284 OK SEARCH 완료

참고: 이 문서는 7비트 ASCII로 제한되어 있으므로

- 텍스트의 경우 실제 UTF-8 데이터를 표시할 수 없습니다. "XXXXXX"는 실제 트랜잭션에서 8비트 데이터의 6옥텟에 대한 자리 표시자입니다.

---
#### **6.4.5.  FETCH Command**

인수: 시퀀스 세트

- 메시지 데이터 항목 이름 또는 매크로

```text
   Responses:  untagged responses: FETCH
```

결과: 확인 - 가져오기 완료

- 아니요 - 가져오기 오류: 해당 데이터를 가져올 수 없습니다. BAD - 알 수 없는 명령 또는 잘못된 인수

- FETCH 명령은 메일함의 메시지와 연관된 데이터를 검색합니다. 가져올 데이터 항목은 단일 원자이거나 괄호로 묶인 목록일 수 있습니다.

- msg-att-static 규칙에 따른 형식 구문에서 식별된 대부분의 데이터 항목은 정적이며 특정 메시지에 대해 변경되어서는 안 됩니다. msg-att-dynamic 규칙에 따른 공식 구문에서 식별된 기타 데이터 항목은 STORE 명령의 결과 또는 외부 이벤트로 인해 변경될 수 있습니다.\(MUST NOT, MAY\)

예를 들어, 클라이언트가 ENVELOPE를 수신한 경우

- 메시지가 이미 봉투를 알고 있으면 새로 전송된 봉투를 안전하게 무시할 수 있습니다.

- 일반적으로 사용되는 데이터 항목 집합을 지정하고 데이터 항목 대신 사용할 수 있는 세 가지 매크로가 있습니다. 매크로는 단독으로 사용해야 하며 다른 매크로나 데이터 항목과 함께 사용해서는 안 됩니다.

```text
      ALL
         Macro equivalent to: (FLAGS INTERNALDATE RFC822.SIZE ENVELOPE)

      FAST
         Macro equivalent to: (FLAGS INTERNALDATE RFC822.SIZE)

      FULL
         Macro equivalent to: (FLAGS INTERNALDATE RFC822.SIZE ENVELOPE
         BODY)
```

- 현재 가져올 수 있는 정의된 데이터 항목은 다음과 같습니다.

몸

- 확장 불가능한 형태의 BODYSTRUCTURE.

BODY\[<섹션\>\]<<부분\>\>

- 특정 본문 섹션의 텍스트입니다. 섹션 사양은 마침표로 구분된 0개 이상의 부분 지정자 집합입니다. 부품 지정자는 부품 번호이거나 HEADER, HEADER.FIELDS, HEADER.FIELDS.NOT, MIME 및 TEXT 중 하나입니다. 빈 섹션 사양은 헤더를 포함한 전체 메시지를 나타냅니다.

- 모든 메시지에는 최소한 하나의 부품 번호가 있습니다. 비\[MIME-IMB\] 메시지 및 캡슐화된 메시지가 없는 비다중 부분 \[MIME-IMB\] 메시지에는 파트 1만 있습니다.

- 다중 부분 메시지에는 메시지에 나타나는 대로 연속적인 부분 번호가 할당됩니다. 특정 부분이 메시지 또는 멀티파트 유형인 경우 해당 부분은 마침표와 중첩된 멀티파트 부분 내의 부품 번호로 표시되어야 합니다.\(MUST\)

- MESSAGE/RFC822 유형의 일부에는 MESSAGE 부분의 본문 부분을 참조하는 중첩된 부품 번호가 있습니다.

- HEADER, HEADER.FIELDS, HEADER.FIELDS.NOT 및 TEXT 부분 지정자는 유일한 부분 지정자이거나 숫자 부분 지정자가 MESSAGE/ 유형의 부분을 참조하는 경우 하나 이상의 숫자 부분 지정자가 앞에 올 수 있습니다. RFC822. MIME 부분 지정자 앞에는 하나 이상의 숫자 부분 지정자가 와야 합니다.\(MUST\)

HEADER, HEADER.FIELDS 및 HEADER.FIELDS.NOT 부분

- 지정자는 메시지 또는 캡슐화된 \[MIME-IMT\] MESSAGE/RFC822 메시지의 \[RFC-2822\] 헤더를 참조합니다. HEADER.FIELDS 및 HEADER.FIELDS.NOT 뒤에는 필드 이름\(\[RFC-2822\]에 정의된 대로\) 이름 목록이 오고

- 헤더의 하위 집합입니다. HEADER.FIELDS에 의해 반환된 하위 집합에는 목록의 이름 중 하나와 일치하는 field-name이 있는 헤더 필드만 포함됩니다. 마찬가지로 HEADER.FIELDS.NOT에서 반환된 하위 집합에는 일치하지 않는 field-name이 있는 헤더 필드만 포함됩니다. 필드 일치는 대소문자를 구분하지 않지만 그 외에는 정확합니다. 하위 설정은 헤더와 본문 사이의 빈 줄을 구분하는 \[RFC-2822\]를 제외하지 않습니다. 본문이나 빈 줄이 없는 메시지의 경우를 제외하고 빈 줄은 모든 헤더 페치에 포함됩니다.

- MIME 부분 지정자는 이 부분에 대한 \[MIME-IMB\] 헤더를 참조합니다.

- TEXT 부분 지정자는 \[RFC-2822\] 헤더를 생략하고 메시지의 텍스트 본문을 참조합니다.

- 다음은 일부 부분 지정자가 포함된 복잡한 메시지의 예입니다.

```text
       HEADER     ([RFC-2822] header of the message)
       TEXT       ([RFC-2822] text body of the message) MULTIPART/MIXED
       1          TEXT/PLAIN
       2          APPLICATION/OCTET-STREAM
       3          MESSAGE/RFC822
       3.HEADER   ([RFC-2822] header of the message)
       3.TEXT     ([RFC-2822] text body of the message) MULTIPART/MIXED
       3.1        TEXT/PLAIN
       3.2        APPLICATION/OCTET-STREAM
       4          MULTIPART/MIXED
       4.1        IMAGE/GIF
       4.1.MIME   ([MIME-IMB] header for the IMAGE/GIF)
       4.2        MESSAGE/RFC822
       4.2.HEADER ([RFC-2822] header of the message)
       4.2.TEXT   ([RFC-2822] text body of the message) MULTIPART/MIXED
       4.2.1      TEXT/PLAIN
       4.2.2      MULTIPART/ALTERNATIVE
       4.2.2.1    TEXT/PLAIN
       4.2.2.2    TEXT/RICHTEXT
```

- 지정된 텍스트의 부분 문자열을 가져오는 것이 가능합니다. 이는 여는 꺾쇠 괄호\("<"\), 원하는 첫 번째 옥텟의 옥텟 위치, 마침표, 원하는 최대 옥텟 수 및 닫는 꺾쇠 괄호\("\>"\)를 부분 지정자에 추가하여 수행됩니다. 시작 옥텟이 텍스트 끝을 벗어나면 빈 문자열이 반환됩니다.

- 텍스트 끝을 넘어서 읽으려고 시도하는 부분 가져오기는 적절하게 잘립니다. 옥텟 0에서 시작하는 부분 가져오기는 이러한 잘림이 발생하더라도 부분 가져오기로 반환됩니다.

- 참고: 이는 1500옥텟 메시지의 BODY\[\]<0.2048\>가 BODY\[\]가 아닌 리터럴 크기 1500의 BODY\[\]<0\>을 반환한다는 의미입니다.

참고: HEADER.FIELDS의 하위 문자열 가져오기 또는

- HEADER.FIELDS.NOT 부분 지정자는 헤더를 부분 집합화한 후 계산됩니다.

- \Seen 플래그는 암시적으로 설정됩니다. 이로 인해 플래그가 변경되면 해당 플래그를 FETCH 응답의 일부로 포함해야 합니다.\(SHOULD\)

BODY.PEEK\[<섹션\>\]<<부분\>\>

- \Seen 플래그를 암시적으로 설정하지 않는 BODY\[<section\>\]의 대체 형식입니다.

신체구조

- 메시지의 \[MIME-IMB\] 본문 구조. 이는 \[RFC-2822\] 헤더와 \[MIME-IMB\] 헤더의 \[MIME-IMB\] 헤더 필드를 구문 분석하여 서버에서 계산됩니다.

봉투

- 메시지의 봉투 구조. 이는 \[RFC-2822\] 헤더를 구성 요소 부분으로 구문 분석하고 필요에 따라 다양한 필드를 기본값으로 설정하여 서버에서 계산됩니다.

플래그

- 이 메시지에 대해 설정된 플래그입니다.

내부 날짜

- 메시지의 내부 날짜입니다.

RFC822

- 기능적으로는 BODY\[\]와 동일하지만 태그가 지정되지 않은 결과 FETCH 데이터의 구문이 다릅니다\(RFC822가 반환됨\).

RFC822.헤더

- 기능적으로는 BODY.PEEK\[HEADER\]와 동일하지만 태그가 지정되지 않은 결과 FETCH 데이터의 구문이 다릅니다\(RFC822.HEADER가 반환됨\).

RFC822.SIZE

- 메시지의 \[RFC-2822\] 크기.

RFC822.TEXT

- 기능적으로는 BODY\[TEXT\]와 동일하지만 태그가 지정되지 않은 결과 FETCH 데이터의 구문이 다릅니다\(RFC822.TEXT가 반환됨\).

UID

- 메시지의 고유 식별자입니다.

```text
   Example:    C: A654 FETCH 2:4 (FLAGS BODY[HEADER.FIELDS (DATE FROM)])
               S: * 2 FETCH ....
               S: * 3 FETCH ....
               S: * 4 FETCH ....
               S: A654 OK FETCH completed
```

---
#### **6.4.6.  STORE Command**

인수: 시퀀스 세트

- 메시지 데이터 항목에 대한 메시지 데이터 항목 이름 값

```text
   Responses:  untagged responses: FETCH
```

결과: OK - 저장 완료

- 아니요 - 저장 오류: 해당 데이터를 저장할 수 없습니다. 불량 - 명령을 알 수 없거나 인수가 잘못되었습니다.

- STORE 명령은 사서함의 메시지와 관련된 데이터를 변경합니다. 일반적으로 STORE는 태그가 지정되지 않은 FETCH 응답으로 업데이트된 데이터 값을 반환합니다. 데이터 항목 이름의 접미사 ".SILENT"는 태그가 지정되지 않은 FETCH를 방지하며 서버는 클라이언트가 업데이트된 값 자체를 결정했거나 업데이트된 값에 관심이 없다고 가정해야 합니다.\(SHOULD\)

- 참고: ".SILENT" 접미사가 사용되었는지 여부에 관계없이 외부 소스에서 메시지 플래그에 대한 변경 사항이 관찰되면 서버는 태그가 지정되지 않은 FETCH 응답을 보내야 합니다. 이는 플래그의 상태가 경쟁 조건 없이 결정된다는 것입니다.\(SHOULD\)

- 저장할 수 있는 현재 정의된 데이터 항목은 다음과 같습니다.

FLAGS <플래그 목록\>

- 메시지의 플래그\(\Recent 제외\)를 인수로 바꿉니다. 해당 플래그의 FETCH가 완료된 것처럼 플래그의 새 값이 반환됩니다.

FLAGS.SILENT <플래그 목록\>

- FLAGS와 동일하지만 새 값을 반환하지 않습니다.

+FLAGS <플래그 목록\>

- 메시지 플래그에 인수를 추가합니다. 해당 플래그의 FETCH가 완료된 것처럼 플래그의 새 값이 반환됩니다.

+FLAGS.SILENT <플래그 목록\>

- +FLAGS와 동일하지만 새 값을 반환하지 않습니다.

-FLAGS <플래그 목록\>

- 메시지 플래그에서 인수를 제거합니다. 해당 플래그의 FETCH가 완료된 것처럼 플래그의 새 값이 반환됩니다.

-FLAGS.SILENT <플래그 목록\>

- -FLAGS와 동일하지만 새 값을 반환하지 않습니다.

```text
   Example:    C: A003 STORE 2:4 +FLAGS (\Deleted)
               S: * 2 FETCH (FLAGS (\Deleted \Seen))
               S: * 3 FETCH (FLAGS (\Deleted))
               S: * 4 FETCH (FLAGS (\Deleted \Flagged \Seen))
               S: A003 OK STORE completed
```

---
#### **6.4.7.  COPY Command**

```text
   Arguments:  sequence set
               mailbox name
```

응답: 이 명령에 대한 구체적인 응답이 없습니다.

결과: OK - 복사가 완료되었습니다.

- 아니요 - 복사 오류: 해당 메시지를 복사하거나 해당 이름으로 복사할 수 없습니다. 불량 - 명령을 알 수 없거나 인수가 잘못되었습니다.

- COPY 명령은 지정된 메시지를 지정된 대상 사서함의 끝에 복사합니다. 메시지의 플래그와 내부 날짜는 보존되어야 하며, 최근 플래그는 복사본에 설정되어야 합니다.\(SHOULD\)

- 대상 사서함이 존재하지 않으면 서버는 오류를 반환해야 합니다. 사서함을 자동으로 생성해서는 안 됩니다. 대상 사서함을 만들 수 없다는 것이 확실하지 않은 한 서버는 태그가 지정된 NO 응답 텍스트의 접두사로 응답 코드 "\[TRYCREATE\]"를 보내야 합니다. 이는 CREATE 명령을 시도하고 CREATE가 성공하면 COPY를 다시 시도할 수 있다는 힌트를 클라이언트에 제공합니다.\(SHOULD, SHOULD NOT, MUST\)

- 어떤 이유로든 COPY 명령이 실패하는 경우 서버 구현은 대상 사서함을 COPY 시도 이전의 상태로 복원해야 합니다.\(MUST\)

```text
   Example:    C: A003 COPY 2:4 MEETING
               S: A003 OK COPY completed
```

---
#### **6.4.8.  UID Command**

```text
   Arguments:  command name
               command arguments

   Responses:  untagged responses: FETCH, SEARCH
```

결과: OK - UID 명령이 완료되었습니다.

- NO - UID 명령 오류 BAD - 명령을 알 수 없거나 인수가 잘못되었습니다.

- UID 명령에는 두 가지 형태가 있습니다. 첫 번째 형식에서는 연관된 명령에 적합한 인수가 있는 COPY, FETCH 또는 STORE 명령을 인수로 사용합니다. 그러나 시퀀스 집합 인수의 숫자는 메시지 시퀀스 번호가 아닌 고유 식별자입니다. 시퀀스 세트 범위는 허용되지만 고유 식별자가 연속된다는 보장은 없습니다.

- 존재하지 않는 고유 식별자는 오류 메시지가 생성되지 않고 무시됩니다. 따라서 UID FETCH 명령이 데이터 없이 OK를 반환하거나 UID COPY 또는 UID STORE가 어떤 작업도 수행하지 않고 OK를 반환하는 것이 가능합니다.

- 두 번째 형식에서 UID 명령은 SEARCH 명령 인수와 함께 SEARCH 명령을 사용합니다. 인수의 해석은 SEARCH와 동일합니다. 그러나 UID SEARCH 명령에 대한 SEARCH 응답에서 반환된 숫자는 대신 고유 식별자입니다.

- 메시지 시퀀스 번호. 예를 들어, UID SEARCH 1:100 UID 443:557 명령은 두 시퀀스 세트의 교집합, 메시지 시퀀스 번호 범위 1:100 및 UID 범위 443:557에 해당하는 고유 식별자를 반환합니다.

참고: 위 예에서 UID 범위는 443:557입니다.

- 나타납니다. 존재하지 않는 고유 식별자가 오류 메시지 없이 무시된다는 동일한 설명이 여기에도 적용됩니다. 따라서 UID 443이나 557이 모두 존재하지 않더라도 이 범위는 유효하며 기존 UID 495를 포함합니다.

- 또한 559:\*의 UID 범위에는 559가 할당된 UID 값보다 높은 경우에도 항상 사서함에 있는 마지막 메시지의 UID가 포함됩니다. 이는 범위의 내용이 범위 끝점의 순서와 무관하기 때문입니다. 따라서 끝점 중 하나로 \*가 있는 UID 범위는 사서함이 비어 있지 않은 한 적어도 하나의 메시지\(UID 번호가 가장 높은 메시지\)를 나타냅니다.

- 태그가 지정되지 않은 FETCH 응답에서 "\*" 뒤의 숫자는 UID 명령 응답의 경우에도 항상 고유 식별자가 아닌 메시지 시퀀스 번호입니다. 그러나 서버 구현은 UID가 FETCH에 대한 메시지 데이터 항목으로 지정되었는지 여부에 관계없이 UID 명령으로 인한 FETCH 응답의 일부로 UID 메시지 데이터 항목을 암시적으로 포함해야 합니다.\(MUST\)

- 참고: FETCH 응답의 일부로 UID 메시지 데이터 항목을 포함하는 규칙은 주로 UID를 메시지 데이터 항목으로 포함하지 않는 UID FETCH 명령을 포함하여 UID FETCH 및 UID STORE 명령에 적용됩니다. 다른 UID 명령으로 인해 태그가 지정되지 않은 FETCH가 발생할 가능성은 없지만 이 규칙은 이러한 명령에도 적용됩니다.

```text
   Example:    C: A999 UID FETCH 4827313:4828442 FLAGS
               S: * 23 FETCH (FLAGS (\Seen) UID 4827313)
               S: * 24 FETCH (FLAGS (\Seen) UID 4827943)
               S: * 25 FETCH (FLAGS (\Seen) UID 4828442)
               S: A999 OK UID FETCH completed
```

---
### **6.5.    Client Commands - Experimental/Expansion**
---
#### **6.5.1.  X<atom> Command**

```text
   Arguments:  implementation defined

   Responses:  implementation defined
```

결과: OK - 명령이 완료되었습니다.

- NO - 실패 BAD - 알 수 없는 명령 또는 잘못된 인수

- 접두사 X가 붙은 명령은 실험적인 명령입니다. 이 사양, 이 사양의 표준 또는 표준 추적 개정판, IESG 승인 실험 프로토콜의 일부가 아닌 명령은 X 접두사를 사용해야 합니다.\(MUST\)

- 실험적 명령으로 발행된 추가된 태그 없는 응답에는 X 접두사가 붙어야 합니다. 서버 구현은 클라이언트가 관련 실험적 명령을 발행하여 요청하지 않는 한 이러한 태그 없는 응답을 보내서는 안 됩니다.\(MUST, MUST NOT\)

```text
   Example:    C: a441 CAPABILITY
               S: * CAPABILITY IMAP4rev1 XPIG-LATIN
               S: a441 OK CAPABILITY completed
               C: A442 XPIG-LATIN
               S: * XPIG-LATIN ow-nay eaking-spay ig-pay atin-lay
               S: A442 OK XPIG-LATIN ompleted-cay
```

---
## **7.      Server Responses**

서버 응답은 상태 응답, 서버 데이터, 명령 계속 요청의 세 가지 형태로 이루어집니다. 아래 응답 설명에서 "Contents:"로 식별되는 서버 응답에 포함된 정보는 구문이 아닌 기능으로 설명됩니다. 서버 응답의 정확한 구문은 형식 구문 섹션에 설명되어 있습니다.

클라이언트는 항상 모든 응답을 수락할 준비가 되어 있어야 합니다.\(MUST\)

상태 응답에는 태그가 지정되거나 태그가 지정되지 않을 수 있습니다. 태그된 상태 응답은 클라이언트 명령의 완료 결과\(OK, NO 또는 BAD 상태\)를 나타내며 명령과 일치하는 태그를 갖습니다.

일부 상태 응답과 모든 서버 데이터에는 태그가 지정되지 않습니다. 태그가 지정되지 않은 응답은 태그 대신 "\*" 토큰으로 표시됩니다. 태그가 지정되지 않은 상태 응답은 서버 인사말 또는 서버 상태를 나타냅니다.

이는 명령 완료를 나타내지 않습니다\(예: 임박한 시스템 종료 경고\). 역사적 이유로 태그가 지정되지 않은 서버 데이터 응답은 "요청되지 않은 데이터"라고도 합니다. 엄밀히 말하면 일방적인 서버 데이터만 실제로 "요청되지 않은" 데이터입니다.

특정 서버 데이터는 수신 시 클라이언트에 의해 기록되어야 합니다. 이는 해당 데이터 설명에 명시되어 있습니다. 이러한 데이터는 모든 후속 명령 및 응답\(예: 메시지 생성 또는 파괴를 반영하는 업데이트\)의 해석에 영향을 미치는 중요한 정보를 전달합니다.\(MUST\)

다른 서버 데이터는 나중에 참조할 수 있도록 기록해야 합니다. 클라이언트가 데이터를 기록할 필요가 없거나 데이터 기록에 명확한 목적이 없는 경우\(예: SEARCH 명령이 진행 중이지 않을 때 SEARCH 응답\) 데이터를 무시해야 합니다.\(SHOULD\)

일방적으로 태그가 지정되지 않은 서버 데이터의 예는 IMAP 연결이 선택된 상태일 때 발생합니다. 선택된 상태에서 서버는 명령 실행의 일부로 사서함에서 새 메시지를 확인합니다. 일반적으로 이는 모든 명령 실행의 일부입니다. 따라서 새 메시지를 확인하는 데는 NOOP 명령으로 충분합니다. 새 메시지가 발견되면 서버는 사서함의 새 크기를 반영하여 태그가 지정되지 않은 EXISTS 및 RECENT 응답을 보냅니다. 동일한 사서함에 대한 다중 동시 액세스를 제공하는 서버 구현은 다른 에이전트가 메시지 플래그의 상태를 변경하거나 메시지를 삭제하는 경우 태그가 지정되지 않은 적절한 일방적 FETCH 및 EXPUNGE 응답도 보내야 합니다\(SHOULD\).\(SHOULD\)

명령 연속 요청 응답은 태그 대신 "+" 토큰을 사용합니다. 이러한 응답은 불완전한 클라이언트 명령을 수락하고 명령의 나머지 부분에 대한 준비가 되었음을 나타내기 위해 서버에서 전송됩니다.

---
### **7.1.    Server Responses - Status Responses**

상태 응답은 OK, NO, BAD, PREAUTH 및 BYE입니다. OK, NO, BAD에 태그를 지정하거나 태그를 지정하지 않을 수 있습니다. PREAUTH 및 BYE는 항상 태그가 지정되지 않습니다.

상태 응답에는 선택적인 "응답 코드"가 포함될 수 있습니다. 응답 코드는 원자 형태의 대괄호 안의 데이터로 구성되며 그 뒤에 공백과 인수가 올 수 있습니다. 응답 코드에는 OK/NO/BAD 조건 이외의 클라이언트 소프트웨어에 대한 추가 정보 또는 상태 코드가 포함되어 있으며, 추가 정보를 기반으로 클라이언트가 수행할 수 있는 특정 작업이 있는 경우 정의됩니다.\(MAY\)

현재 정의된 응답 코드는 다음과 같습니다.

```text
      ALERT
```

- 사람이 읽을 수 있는 텍스트에는 메시지에 대한 사용자의 주의를 환기시키는 방식으로 사용자에게 표시되어야 하는 특별한 경고가 포함되어 있습니다.\(MUST\)

```text
      BADCHARSET
```

- 선택적으로 뒤에 괄호로 묶인 문자 세트 목록이 옵니다. 이 구현에서는 지정된 문자 세트를 지원하지 않기 때문에 검색에 실패했습니다. 선택적 문자 집합 목록이 제공되면 이 구현에서 지원되는 문자 집합이 나열됩니다.

```text
      CAPABILITY
```

- 기능 목록이 이어집니다. 이는 초기 기능 목록을 전송하기 위한 초기 OK 또는 PREAUTH 응답에 나타날 수 있습니다. 이렇게 하면 클라이언트가 이 응답을 인식하는 경우 별도의 CAPABILITY 명령을 보낼 필요가 없습니다.

```text
      PARSE
```

- 사람이 읽을 수 있는 텍스트는 사서함에 있는 메시지의 \[RFC-2822\] 헤더 또는 \[MIME-IMB\] 헤더를 구문 분석하는 중 오류를 나타냅니다.

```text
      PERMANENTFLAGS
```

- 뒤에 괄호로 묶인 플래그 목록이 표시되며 클라이언트가 영구적으로 변경할 수 있는 알려진 플래그가 무엇인지 나타냅니다. FLAGS 태그가 지정되지 않은 응답에는 있지만 PERMANENTFLAGS 목록에는 없는 플래그는 영구적으로 설정할 수 없습니다. 클라이언트가 PERMANENTFLAGS 목록에 없는 플래그를 저장하려고 시도하면 서버는 변경 사항을 무시하거나 현재 세션의 나머지 부분에 대해서만 상태 변경 사항을 저장합니다. PERMANENTFLAGS 목록에는 특수 플래그 \*도 포함될 수 있습니다. 이는 해당 플래그를 사서함에 저장하려고 시도하여 새 키워드를 생성할 수 있음을 나타냅니다.

```text
      READ-ONLY
```

- 사서함이 읽기 전용으로 선택되었거나 선택된 동안의 액세스 권한이 읽기-쓰기에서 읽기 전용으로 변경되었습니다.

```text
      READ-WRITE
```

- 사서함이 읽기-쓰기로 선택되었거나 선택된 동안의 액세스가 읽기 전용에서 읽기-쓰기로 변경되었습니다.

```text
      TRYCREATE
```

- 다른 이유와는 반대로 대상 사서함이 존재하지 않기 때문에 APPEND 또는 COPY 시도가 실패합니다. 이는 CREATE 명령으로 사서함을 처음 생성한 경우 작업이 성공할 수 있다는 것을 클라이언트에게 알려주는 힌트입니다.

```text
      UIDNEXT
```

- 뒤에 10진수가 따라오며 다음 고유 식별자 값을 나타냅니다. 자세한 내용은 섹션 2.3.1.1을 참조하세요.

```text
      UIDVALIDITY
```

- 뒤에 십진수가 따라오며 고유 식별자 유효성 값을 나타냅니다. 자세한 내용은 섹션 2.3.1.1을 참조하세요.

```text
      UNSEEN
```

- 뒤에 10진수가 따라오며, \Seen 플래그가 설정되지 않은 첫 번째 메시지의 번호를 나타냅니다.

- 특정 클라이언트 또는 서버 구현에 의해 정의된 추가 응답 코드는 이 프로토콜의 개정판에 추가될 때까지 "X" 접두사가 붙어야 합니다. 클라이언트 구현은 인식하지 못하는 응답 코드를 무시해야 합니다\(SHOULD\).\(SHOULD, SHOULD\)

---
#### **7.1.1.  OK Response**

```text
   Contents:   OPTIONAL response code
               human-readable text
```

- OK 응답은 서버로부터의 정보 메시지를 나타냅니다. 태그가 지정되면 관련 명령이 성공적으로 완료되었음을 나타냅니다. 사람이 읽을 수 있는 텍스트는 정보 메시지로 사용자에게 표시될 수 있습니다. 태그가 지정되지 않은 양식은 다음을 나타냅니다.\(MAY\)

- 정보 전용 메시지 정보의 성격은 응답 코드로 표시될 수 있습니다.\(MAY\)

- 태그되지 않은 형식은 연결 시작 시 가능한 세 가지 인사말 중 하나로도 사용됩니다. 이는 연결이 아직 인증되지 않았으며 LOGIN 명령이 필요함을 나타냅니다.

예: S: \* OK IMAP4rev1 서버 준비됨

- C: A001 LOGIN fred Bludybloop S: \* OK \[ALERT\] 10분 후 시스템 종료 S: A001 OK 로그인 완료

---
#### **7.1.2.  NO Response**

```text
   Contents:   OPTIONAL response code
               human-readable text
```

- NO 응답은 서버의 작동 오류 메시지를 나타냅니다. 태그가 지정되면 관련 명령이 성공적으로 완료되지 않았음을 나타냅니다. 태그가 지정되지 않은 양식은 경고를 나타냅니다. 명령은 여전히 ​​성공적으로 완료될 수 있습니다. 사람이 읽을 수 있는 텍스트는 조건을 설명합니다.

예: C: A222 COPY 1:2 오와타구시암

- S: \* NO 디스크가 98% 찼습니다. 불필요한 데이터를 삭제하십시오 S: A222 OK COPY 완료 C: A223 COPY 3:200 Blurdybloop S: \* NO 디스크가 98% 찼습니다. 불필요한 데이터를 삭제하십시오 S: \* NO 디스크는 99입니다. % 가득 찼습니다. 불필요한 데이터를 삭제하십시오. S: A223 NO COPY 실패: 디스크가 꽉 찼습니다.

---
#### **7.1.3.  BAD Response**

```text
   Contents:   OPTIONAL response code
               human-readable text
```

- BAD 응답은 서버의 오류 메시지를 나타냅니다. 태그가 지정되면 클라이언트 명령의 프로토콜 수준 오류를 보고합니다. 태그는 오류를 일으킨 명령을 나타냅니다. 태그가 지정되지 않은 형식은 관련 명령을 확인할 수 없는 프로토콜 수준 오류를 나타냅니다. 내부 서버 오류를 나타낼 수도 있습니다. 사람이 읽을 수 있는 텍스트는 조건을 설명합니다.

예: C: ...매우 긴 명령줄...

- S: \* BAD 명령줄이 너무 깁니다. C: ...빈 줄... S: \* BAD 빈 명령줄 C: A443 EXPUNGE S: \* BAD 디스크 충돌, 새 디스크 복구 시도! S: \* 확인 회수 성공, 데이터 손실 없음 S: A443 확인 삭제 완료

---
#### **7.1.4.  PREAUTH Response**

```text
   Contents:   OPTIONAL response code
               human-readable text
```

- PREAUTH 응답은 항상 태그가 지정되지 않으며 연결 시작 시 가능한 세 가지 인사말 중 하나입니다. 이는 연결이 이미 외부 수단에 의해 인증되었음을 나타냅니다. 따라서 LOGIN 명령이 필요하지 않습니다.

예: S: \* PREAUTH IMAP4rev1 서버가 Smith로 로그인됨

---
#### **7.1.5.  BYE Response**

```text
   Contents:   OPTIONAL response code
               human-readable text
```

- BYE 응답은 항상 태그가 지정되지 않으며 서버가 곧 연결을 닫을 것임을 나타냅니다. 사람이 읽을 수 있는 텍스트는 클라이언트의 상태 보고서에서 사용자에게 표시될 수 있습니다. BYE 응답은 다음 네 가지 조건 중 하나에서 전송됩니다.\(MAY\)

- 1\) 일반적인 로그아웃 시퀀스의 일부로. 서버는 LOGOUT 명령에 대해 태그된 OK 응답을 보낸 후 연결을 닫습니다.

- 2\) 패닉 셧다운 공지로. 서버는 즉시 연결을 닫습니다.

- 3\) 비활성 자동 로그아웃을 공지합니다. 서버는 즉시 연결을 닫습니다.

- 4\) 연결 시작 시 가능한 세 가지 인사말 중 하나로 서버가 이 클라이언트의 연결을 수락할 의사가 없음을 나타냅니다. 서버는 즉시 연결을 닫습니다.

- 일반적인 LOGOUT 시퀀스의 일부로 발생하는 BYE\(첫 번째 경우\)와 실패로 인해 발생하는 BYE\(나머지 세 가지 경우\)의 차이점은 실패 시 연결이 즉시 종료된다는 것입니다. 모든 경우에 클라이언트는 연결이 닫힐 때까지 서버에서 응답 데이터를 계속 읽어야 합니다. 이렇게 하면 보류 중인 태그가 지정되지 않았거나 완료 응답을 읽고 처리할 수 있습니다.\(SHOULD\)

예: S: \* BYE 자동 로그아웃; 너무 오랫동안 유휴 상태

---
### **7.2.    Server Responses - Server and Mailbox Status**

이러한 응답에는 항상 태그가 지정되지 않습니다. 이는 서버 및 사서함 상태 데이터가 서버에서 클라이언트로 전송되는 방식입니다. 이러한 응답 중 다수는 일반적으로 동일한 이름을 가진 명령으로 인해 발생합니다.

---
#### **7.2.1.  CAPABILITY Response**

```text
   Contents:   capability listing
```

- CAPABILITY 응답은 CAPABILITY 명령의 결과로 발생합니다. 기능 목록에는 서버가 지원하는 기능 이름의 공백으로 구분된 목록이 포함되어 있습니다. 기능 목록에는 "IMAP4rev1" 원자가 포함되어야 합니다.\(MUST\)

- 또한 클라이언트 및 서버 구현은 STARTTLS, LOGINDISABLED 및 AUTH=PLAIN\(\[IMAP-TLS\]에 설명됨\) 기능을 구현해야 합니다. 중요한 정보는 보안 고려 사항 섹션을 참조하세요.\(MUST\)

- "AUTH="로 시작하는 기능 이름은 서버가 특정 인증 메커니즘을 지원함을 나타냅니다.

- LOGINDISABLED 기능은 LOGIN 명령이 비활성화되어 있으며 사용자 이름과 암호가 유효한 경우에도 LOGIN 명령을 사용하려는 시도에 대해 서버가 태그된 NO 응답으로 응답함을 나타냅니다. 서버가 LOGINDISABLED 기능을 광고하는 경우 IMAP 클라이언트는 LOGIN 명령을 발행해서는 안 됩니다.\(MUST NOT\)

- 다른 기능 이름은 서버가 IMAP4rev1 프로토콜에 대한 확장, 개정 또는 개정을 지원함을 나타냅니다. 서버 응답은 클라이언트가 관련 기능을 사용하는 명령을 발행할 때까지 이 문서를 준수해야 합니다.\(MUST\)

- 기능 이름은 "X"로 시작하거나 IANA에 등록된 표준 또는 표준 추적 IMAP4rev1 확장, 개정 또는 개정판이어야 합니다. 서버는 등록되지 않은 또는\(MUST, MUST NOT\)

- 이름 앞에 "X"가 붙지 않는 한 비표준 기능 이름입니다.

- 클라이언트 구현은 "IMAP4rev1" 이외의 기능 이름을 요구해서는 안 되며, 알 수 없는 기능 이름을 무시해야 합니다.\(MUST\)

- 서버는 초기 PREAUTH 또는 OK 응답에서 CAPABILITY 응답 코드를 사용하고 성공적인 인증의 일부로 태그가 지정된 OK 응답에서 업데이트된 CAPABILITY 응답 코드를 보내 자동으로 기능을 보낼 수 있습니다. 클라이언트가 이러한 자동 기능을 인식하는 경우 별도의 CAPABILITY 명령을 보낼 필요가 없습니다.\(MAY\)

```text
   Example:    S: * CAPABILITY IMAP4rev1 STARTTLS AUTH=GSSAPI XPIG-LATIN
```

---
#### **7.2.2.  LIST Response**

```text
   Contents:   name attributes
               hierarchy delimiter
               name
```

- LIST 명령의 결과로 LIST 응답이 발생합니다. LIST 사양과 일치하는 단일 이름을 반환합니다. 단일 LIST 명령에 대해 여러 LIST 응답이 있을 수 있습니다.

- 네 가지 이름 속성이 정의됩니다.

\Noinferiors

- 이 이름 아래에는 하위 계층 수준이 존재할 수 없습니다. 현재 하위 수준은 존재하지 않으며 앞으로도 만들 수 없습니다.

\No선택

- 이 이름은 선택 가능한 사서함으로 사용할 수 없습니다.

\두드러진

- 서버가 메일함을 "흥미로움"으로 표시했습니다. 사서함에는 마지막으로 사서함을 선택한 이후 추가된 메시지가 포함되어 있을 수 있습니다.

\표시되지 않음

- 사서함을 마지막으로 선택한 이후 사서함에는 추가 메시지가 포함되어 있지 않습니다.

- 서버가 사서함이 "흥미로운"지 여부를 결정하는 것이 가능하지 않거나 이름이 \Noselect 이름인 경우 서버는 \Marked 또는 \Unmarked를 전송해서는 안 됩니다.\(SHOULD NOT\)

- 계층 구분 기호는 사서함 이름의 계층 수준을 구분하는 데 사용되는 문자입니다. 클라이언트는 이를 사용하여 하위 사서함을 만들고 더 높거나 낮은 수준의 이름 지정 계층을 검색할 수 있습니다. 최상위 계층 노드의 모든 하위 항목은 동일한 구분 문자를 사용해야 합니다. NIL 계층 구조 구분 기호는 계층 구조가 존재하지 않음을 의미합니다. 이름은 "단순한" 이름입니다.\(MUST\)

- 이름은 왼쪽에서 오른쪽으로의 명확한 계층 구조를 나타내며 LIST 및 LSUB 명령에서 참조로 사용하기에 유효해야 합니다. \Noselect가 표시되지 않는 한 이름은 사서함 이름을 허용하는 SELECT와 같은 명령의 인수로도 유효해야 합니다.\(MUST, MUST\)

```text
   Example:    S: * LIST (\Noselect) "/" ~/Mail/foo
```

---
#### **7.2.3.  LSUB Response**

```text
   Contents:   name attributes
               hierarchy delimiter
               name
```

- LSUB 명령의 결과로 LSUB 응답이 발생합니다. LSUB 사양과 일치하는 단일 이름을 반환합니다. 단일 LSUB 명령에 대해 여러 LSUB 응답이 있을 수 있습니다. 데이터는 LIST 응답과 형식이 동일합니다.

```text
   Example:    S: * LSUB () "." #news.comp.mail.misc
```

---
### **7.2.4   STATUS Response**

```text
   Contents:   name
               status parenthesized list
```

- STATUS 응답은 STATUS 명령의 결과로 발생합니다. STATUS 사양과 일치하는 사서함 이름과 요청된 사서함 상태 정보를 반환합니다.

```text
   Example:    S: * STATUS blurdybloop (MESSAGES 231 UIDNEXT 44292)
```

---
#### **7.2.5.  SEARCH Response**

내용: 0개 이상의 숫자

- SEARCH 응답은 SEARCH 또는 UID SEARCH 명령의 결과로 발생합니다. 숫자는 검색 기준과 일치하는 메시지를 나타냅니다. SEARCH의 경우 이는 메시지 시퀀스 번호입니다. UID 검색의 경우 이는 고유 식별자입니다. 각 숫자는 공백으로 구분됩니다.

```text
   Example:    S: * SEARCH 2 3 6
```

---
#### **7.2.6.  FLAGS Response**

```text
   Contents:   flag parenthesized list
```

- FLAGS 응답은 SELECT 또는 EXAMINE 명령의 결과로 발생합니다. 괄호로 묶인 플래그 목록은 이 사서함에 적용할 수 있는 플래그\(최소한 시스템 정의 플래그\)를 식별합니다. 서버 구현에 따라 시스템 플래그 이외의 플래그도 존재할 수 있습니다.

- FLAGS 응답의 업데이트는 클라이언트에 의해 기록되어야 합니다.\(MUST\)

```text
   Example:    S: * FLAGS (\Answered \Flagged \Deleted \Seen \Draft)
```

---
### **7.3.    Server Responses - Mailbox Size**

이러한 응답에는 항상 태그가 지정되지 않습니다. 이것이 메일박스 크기의 변화가 서버에서 클라이언트로 전송되는 방식입니다. "\*" 토큰 바로 뒤에는 메시지 수를 나타내는 숫자가 있습니다.

---
#### **7.3.1.  EXISTS Response**

```text
   Contents:   none
```

- EXISTS 응답은 사서함에 있는 메시지 수를 보고합니다. 이 응답은 SELECT 또는 EXAMINE 명령의 결과로 그리고 메일함의 크기가 변경된 경우\(예: 새 메시지\) 발생합니다.

- EXISTS 응답의 업데이트는 클라이언트에 의해 기록되어야 합니다.\(MUST\)

```text
   Example:    S: * 23 EXISTS
```

---
#### **7.3.2.  RECENT Response**

```text
   Contents:   none
```

- RECENT 응답은 \Recent 플래그가 설정된 메시지 수를 보고합니다. 이 응답은 SELECT 또는 EXAMINE 명령의 결과로 그리고 메일함의 크기가 변경된 경우\(예: 새 메시지\) 발생합니다.

참고: 메시지 순서가 보장되지는 않습니다.

- 최근 메시지 수는 사서함에서 가장 높은 n개 메시지의 연속 범위가 됩니다. 여기서 n은 RECENT 응답에서 보고된 값입니다. 그렇지 않은 상황의 예는 다음과 같습니다. 동일한 사서함이 열려 있는 여러 클라이언트\(알림을 받는 첫 번째 세션에서는 이를 최신으로 보고 다른 세션에서는 최신이 아닌 것으로 볼 수 있음\) 및 사서함이 다시 열리는 경우입니다. IMAP가 아닌 에이전트에 의해 주문되었습니다.

- 최근 메시지를 식별하는 신뢰할 수 있는 유일한 방법은 메시지 플래그를 보고 \Recent 플래그가 설정되어 있는지 확인하거나 최근 검색을 수행하는 것입니다.

- 최근 응답의 업데이트는 클라이언트에 의해 기록되어야 합니다.\(MUST\)

```text
   Example:    S: * 5 RECENT
```

---
### **7.4.    Server Responses - Message Status**

이러한 응답에는 항상 태그가 지정되지 않습니다. 이는 동일한 이름을 가진 명령의 결과로 메시지 데이터가 서버에서 클라이언트로 전송되는 방식입니다. "\*" 토큰 바로 뒤에는 메시지 시퀀스 번호를 나타내는 숫자가 있습니다.

---
#### **7.4.1.  EXPUNGE Response**

```text
   Contents:   none
```

- EXPUNGE 응답은 지정된 메시지 시퀀스 번호가 사서함에서 영구적으로 제거되었음을 보고합니다. 메일함의 각 연속 메시지에 대한 메시지 시퀀스 번호는 즉시 1씩 감소하며, 이 감소는 후속 응답\(태그가 지정되지 않은 다른 EXPUNGE 응답 포함\)의 메시지 시퀀스 번호에 반영됩니다.

- EXPUNGE 응답은 메일함의 메시지 수도 줄입니다. 새로운 값으로 EXISTS 응답을 보낼 필요는 없습니다.

- 즉시 감소 규칙의 결과로 일련의 연속적인 말소 응답에 나타나는 메시지 시퀀스 번호는 메시지가 낮은 숫자에서 높은 숫자로 제거되는지, 아니면 높은 숫자에서 낮은 숫자로 제거되는지에 따라 달라집니다. 예를 들어, 9개 메시지로 구성된 사서함의 마지막 5개 메시지가 삭제되는 경우 "낮은 쪽에서 높은 쪽으로" 서버는 메시지 시퀀스 번호 5에 대해 태그가 지정되지 않은 5개의 EXPUNGE 응답을 보내는 반면, "높은 쪽에서 낮은 서버로"는 태그 없는 연속적인 EXPUNGE 응답을 보냅니다. 메시지 시퀀스 번호 9, 8, 7, 6 및 5의 경우.

- 진행 중인 명령이 없거나 FETCH, STORE 또는 SEARCH 명령에 응답하는 동안에는 EXPUNGE 응답을 전송해서는 안 됩니다. 이 규칙은 클라이언트와 서버 간의 메시지 시퀀스 번호 동기화 손실을 방지하는 데 필요합니다. 완전한 명령이 수신될 때까지 명령은 "진행 중"이 아닙니다. 특히 명령 지속 협상 중에는 명령이 "진행 중"이 아닙니다.\(MUST NOT\)

- 참고: UID FETCH, UID STORE 및 UID SEARCH는 FETCH, STORE 및 SEARCH와 다른 명령입니다. EXPUNGE 응답은 UID 명령 중에 전송될 수 있습니다.\(MAY\)

- 말소 응답의 업데이트는 클라이언트에 의해 기록되어야 합니다.\(MUST\)

```text
   Example:    S: * 44 EXPUNGE
```

---
#### **7.4.2.  FETCH Response**

```text
   Contents:   message data
```

- FETCH 응답은 메시지에 대한 데이터를 클라이언트에 반환합니다. 데이터는 데이터 항목 이름과 괄호 안의 해당 값의 쌍입니다. 이 응답은 FETCH 또는 STORE 명령의 결과뿐만 아니라 일방적인 서버 결정\(예: 플래그 업데이트\)에 의해 발생합니다.

- 현재 데이터 항목은 다음과 같습니다.

몸

- 확장 데이터가 없는 BODYSTRUCTURE 형태입니다.

BODY\[<섹션\>\]<<원본 옥텟\>\>

- 지정된 섹션의 본문 내용을 표현하는 문자열입니다. 문자열은 콘텐츠 전송 인코딩, 본문 유형 및 하위 유형에 따라 클라이언트에 의해 해석되어야 합니다.\(SHOULD\)

- 원본 옥텟이 지정된 경우 이 문자열은 해당 원본 옥텟에서 시작하는 전체 본문 내용의 하위 문자열입니다. 즉, BODY\[\]<0\>은 잘릴 수 있지만 BODY\[\]는 절대 잘리지 않습니다.\(MAY\)

- 참고: 클라이언트가 BODY\[<section\>\]<<partial\>\> 데이터 항목의 FETCH를 통해 특별히 요청하지 않는 한 원본 옥텟 기능은 FETCH 응답에서 서버에 의해 사용되어서는 안 됩니다.\(MUST NOT\)

- \[CHARSET\] 식별자가 이 섹션에 대해 괄호로 묶인 본문 매개변수 목록의 일부인 경우 8비트 텍스트 데이터가 허용됩니다. 헤더\(부분 지정자 HEADER 또는 MIME 또는 MESSAGE/RFC822 부분의 헤더 부분\)는 7비트여야 합니다. 헤더에는 8비트 문자가 허용되지 않습니다. 헤더와 본문 사이의 빈 줄을 구분하는 \[RFC-2822\]는 헤더 줄 하위 집합의 영향을 받지 않습니다. 빈 줄은 본문이나 빈 줄이 없는 메시지의 경우를 제외하고 항상 헤더 데이터의 일부로 포함됩니다.\(MUST\)

- 바이너리 데이터와 같은 비텍스트 데이터는 클라이언트에 전송되기 전에 BASE64와 같은 텍스트 형식으로 전송 인코딩되어야 합니다. 원본 바이너리 데이터를 파생하려면 클라이언트가 전송 인코딩된 문자열을 디코딩해야 합니다.\(MUST, MUST\)

신체구조

- 메시지의 \[MIME-IMB\] 본문 구조를 설명하는 괄호로 묶인 목록입니다. 이는 \[MIME-IMB\] 헤더 필드를 구문 분석하고 필요에 따라 다양한 필드를 기본값으로 설정하여 서버에서 계산됩니다.

```text
         For example, a simple text message of 48 lines and 2279 octets
         can have a body structure of: ("TEXT" "PLAIN" ("CHARSET"
         "US-ASCII") NIL NIL "7BIT" 2279 48)
```

- 여러 부분은 괄호 중첩으로 표시됩니다. 괄호로 묶인 목록의 첫 번째 요소인 신체 유형 대신 하나 이상의 중첩된 신체 구조의 시퀀스가 ​​있습니다. 괄호 안에 있는 목록의 두 번째 요소는 다중 부분 하위 유형\(혼합, 다이제스트, 병렬, 대체 등\)입니다.

```text
         For example, a two part message consisting of a text and a
         BASE64-encoded text attachment can have a body structure of:
         (("TEXT" "PLAIN" ("CHARSET" "US-ASCII") NIL NIL "7BIT" 1152
         23)("TEXT" "PLAIN" ("CHARSET" "US-ASCII" "NAME" "cc.diff")
         "<960723163407.20117h@cac.washington.edu>" "Compiler diff"
         "BASE64" 4554 73) "MIXED")
```

- 확장 데이터는 다중 부분 하위 유형을 따릅니다. 확장 데이터는 BODY 가져오기를 통해 반환되지 않지만 BODYSTRUCTURE 가져오기를 통해 반환될 수 있습니다. 확장 데이터가 있는 경우 정의된 순서대로 있어야 합니다. 다중 부분 본문 부분의 확장 데이터는 다음 순서로 되어 있습니다.\(MUST\)

본문 매개변수 괄호로 묶인 목록

- 속성/값 쌍의 괄호로 묶인 목록\[예: \("foo" "bar" "baz" "rag"\) 여기서 "bar"는 "foo"의 값이고 "rag"는 "baz"의 값임\] \[MIME-IMB\]에 정의된 대로입니다.

신체 성향

- 처리 유형 문자열과 그 뒤에 \[DISPOSITION\]에 정의된 대로 처리 특성/값 쌍의 괄호로 묶인 목록으로 구성된 괄호로 묶인 목록입니다.

신체 언어

- \[LANGUAGE-TAGS\]에 정의된 신체 언어 값을 제공하는 문자열 또는 괄호로 묶인 목록입니다.

신체 위치

- \[LOCATION\]에 정의된 본문 콘텐츠 URI를 제공하는 문자열 목록입니다.

- 다음 확장 데이터는 이 프로토콜 버전에서 아직 정의되지 않았습니다. 이러한 확장 데이터는 0개 이상의 NIL, 문자열, 숫자 또는 잠재적으로 중첩된 괄호로 묶인 해당 데이터 목록으로 구성될 수 있습니다. BODYSTRUCTURE 가져오기를 수행하는 클라이언트 구현은 이러한 확장 데이터를 허용하도록 준비되어야 합니다. 서버 구현은 이 프로토콜의 개정판에 의해 정의될 때까지 그러한 확장 데이터를 전송해서는 안 됩니다.\(MUST, MUST NOT\)

- 다중 부분이 아닌 본문 부분의 기본 필드는 다음과 같은 순서로 되어 있습니다.

체형

- \[MIME-IMB\]에 정의된 콘텐츠 미디어 유형 이름을 제공하는 문자열입니다.

신체 하위 유형

- \[MIME-IMB\]에 정의된 콘텐츠 하위 유형 이름을 제공하는 문자열입니다.

본문 매개변수 괄호로 묶인 목록

- 속성/값 쌍의 괄호로 묶인 목록\[예: \("foo" "bar" "baz" "rag"\) 여기서 "bar"는 "foo"의 값이고 "rag"는 "baz"의 값임\] \[MIME-IMB\]에 정의되어 있습니다.

신체 ID

- \[MIME-IMB\]에 정의된 콘텐츠 ID를 제공하는 문자열입니다.

신체 설명

- \[MIME-IMB\]에 정의된 콘텐츠 설명을 제공하는 문자열입니다.

본문 인코딩

- \[MIME-IMB\]에 정의된 콘텐츠 전송 인코딩을 제공하는 문자열입니다.

몸 사이즈

- 몸체의 크기를 옥텟 단위로 나타내는 숫자입니다. 이 크기는 전송 인코딩의 크기이지 디코딩 후의 결과 크기가 아닙니다.

- MESSAGE 유형 및 하위 유형 RFC822의 본문 유형에는 기본 필드 바로 뒤에 봉투 구조, 본문 구조 및 캡슐화된 메시지의 텍스트 줄 크기가 포함됩니다.

- TEXT 유형의 본문 유형에는 기본 필드 바로 뒤에 텍스트 줄의 본문 크기가 포함됩니다. 이 크기는 콘텐츠 전송 인코딩의 크기이지 디코딩 후 결과 크기가 아닙니다.

- 확장 데이터는 위에 나열된 기본 필드와 유형별 필드를 따릅니다. 확장 데이터는 BODY 가져오기를 통해 반환되지 않지만 BODYSTRUCTURE 가져오기를 통해 반환될 수 있습니다. 확장 데이터가 있는 경우 정의된 순서대로 있어야 합니다.\(MUST\)

- 다중 부분이 아닌 본문 부분의 확장 데이터는 다음과 같은 순서로 되어 있습니다.

바디 MD5

- \[MD5\]에 정의된 대로 본문 MD5 값을 제공하는 문자열입니다.

신체 성향

- 다중 부분 본문 부분에 대한 본문 처리와 동일한 내용 및 기능을 포함하는 괄호로 묶인 목록입니다.

신체 언어

- \[LANGUAGE-TAGS\]에 정의된 신체 언어 값을 제공하는 문자열 또는 괄호로 묶인 목록입니다.

신체 위치

- \[LOCATION\]에 정의된 본문 콘텐츠 URI를 제공하는 문자열 목록입니다.

- 다음 확장 데이터는 이 버전의 프로토콜에서 아직 정의되지 않았으며 위의 다중 부분 확장 데이터에서 설명한 것과 같습니다.

봉투

- 메시지의 봉투 구조를 설명하는 괄호로 묶인 목록입니다. 이는 \[RFC-2822\] 헤더를 구성 요소 부분으로 구문 분석하고 필요에 따라 다양한 필드를 기본값으로 설정하여 서버에서 계산됩니다.

- 봉투 구조의 필드는 날짜, 제목, 보낸 사람, 보낸 사람, 회신 대상, 받는 사람, 참조, 숨은 참조, 회신 대상, 메시지 ID의 순서로 되어 있습니다. 날짜, 제목, 회신 대상 및 메시지 ID 필드는 문자열입니다. from, sender, reply-to, to, cc 및 bcc 필드는 괄호로 묶인 주소 구조 목록입니다.

- 주소 구조는 전자 메일 주소를 설명하는 괄호 안의 목록입니다. 주소 구조의 필드는 개인 이름, \[SMTP\] at-domain-list\(소스 경로\), 메일함 이름, 호스트 이름의 순서로 되어 있습니다.

- \[RFC-2822\] 그룹 구문은 호스트 이름 필드가 NIL인 특수한 형태의 주소 구조로 표시됩니다. 사서함 이름 필드도 NIL인 경우 이는 그룹 끝 표시\(RFC 822 구문의 세미콜론\)입니다. 사서함 이름 필드가 NIL이 아닌 경우 이는 그룹 표시의 시작이고 사서함 이름 필드에는 그룹 이름 문구가 포함됩니다.

- \[RFC-2822\] 헤더에 Date, Subject, In-Reply-To 및 Message-ID 헤더 행이 없으면 봉투의 해당 구성원은 NIL입니다. 이러한 헤더 행이 존재하지만 비어 있는 경우 봉투의 해당 구성원은 빈 문자열입니다.

- 참고: 일부 서버는 "현재는 있지만 비어 있는" 경우 NIL 봉투 멤버를 반환할 수 있습니다. 클라이언트는 NIL과 빈 문자열을 동일하게 처리해야 합니다\(SHOULD\).\(SHOULD\)

- 참고: \[RFC-2822\]에서는 모든 메시지에 유효한 날짜 헤더가 있어야 합니다. 따라서 봉투의 날짜 멤버는 NIL이거나 빈 문자열일 수 없습니다.

참고: \[RFC-2822\]에서는 In-Reply-To 및

- 메시지 ID 헤더가 있는 경우 비어 있지 않은 콘텐츠를 갖습니다. 따라서 봉투의 in-reply-to 및 message-id 멤버는 빈 문자열이 될 수 없습니다.

- \[RFC-2822\] 헤더에 From, To, cc 및 bcc 헤더 행이 없거나 존재하지만 비어 있는 경우 봉투의 해당 구성원은 NIL입니다.

- \[RFC-2822\] 헤더에 Sender 또는 Reply-To 줄이 없거나 존재하지만 비어 있는 경우 서버는 봉투의 해당 구성원을 from 구성원과 동일한 값으로 설정합니다\(클라이언트는 예상하지 않음\). 이를 수행하는 방법을 알아보세요\).

- 참고: \[RFC-2822\]에서는 모든 메시지에 유효한 From 헤더가 있어야 합니다. 따라서 봉투의 보낸 사람, 보낸 사람 및 회신 구성원은 NIL일 수 없습니다.

플래그

- 이 메시지에 대해 설정된 플래그의 괄호 안에 있는 목록입니다.

내부 날짜

- 메시지의 내부 날짜를 나타내는 문자열입니다.

RFC822

- BODY\[\]와 동일합니다.

RFC822.헤더

- BODY\[HEADER\]와 동일합니다. RFC822.HEADER 응답 데이터는 RFC822.HEADER의 FETCH 결과로 발생하므로 \Seen이 설정되지는 않았습니다. BODY\[HEADER\] 응답 데이터는 BODY\[HEADER\]\(\Seen 설정\) 또는 BODY.PEEK\[HEADER\]\(\Seen을 설정하지 않음\)의 FETCH 결과로 발생합니다.

RFC822.SIZE

- 메시지의 \[RFC-2822\] 크기를 나타내는 숫자입니다.

RFC822.TEXT

- BODY\[TEXT\]와 동일합니다.

UID

- 메시지의 고유 식별자를 나타내는 숫자입니다.

```text
   Example:    S: * 23 FETCH (FLAGS (\Seen) RFC822.SIZE 44827)
```

---
### **7.5.    Server Responses - Command Continuation Request**

명령 계속 요청 응답은 태그 대신 "+" 토큰으로 표시됩니다. 이 응답 형식은 서버가 클라이언트의 명령을 계속 받아들일 준비가 되었음을 나타냅니다. 이 응답의 나머지 부분은 텍스트 한 줄입니다.

이 응답은 AUTHENTICATE 명령에서 서버 데이터를 클라이언트에 전송하고 추가 클라이언트 데이터를 요청하는 데 사용됩니다. 이 응답은 명령에 대한 인수가 리터럴인 경우에도 사용됩니다.

서버가 예상되는 것으로 나타내지 않는 한 클라이언트는 리터럴의 옥텟을 보내는 것이 허용되지 않습니다. 이를 통해 서버는 한 줄씩 명령을 처리하고 오류를 거부할 수 있습니다. 명령을 종료하는 CRLF를 포함하여 명령의 나머지 부분은 리터럴의 옥텟 뒤에 옵니다. 추가 명령 인수가 있는 경우 리터럴 옥텟 뒤에 공백과 해당 인수가 옵니다.

```text
   Example:    C: A001 LOGIN {11}
               S: + Ready for additional command text
               C: FRED FOOBAR {7}
               S: + Ready for additional command text
               C: fat man
               S: A001 OK LOGIN completed
               C: A044 BLURDYBLOOP {102856}
               S: A044 BAD No such command as "BLURDYBLOOP"
```

---
## **8.      Sample IMAP4rev1 connection**

다음은 IMAP4rev1 연결의 기록입니다. 편집의 명확성을 위해 이 샘플의 긴 줄은 끊어졌습니다.

S: \* 확인 IMAP4rev1 서비스 준비됨
C: a001 로그인 MRC 비밀
S: a001 OK 로그인 완료
C: a002 받은편지함 선택
S: \* 18개 존재
S: \* 플래그\(\답변\플래그됨\삭제됨\본\초안\)
S: \* 최근 2개
S: \* OK \[UNSEEN 17\] 메시지 17은 첫 번째로 보지 못한 메시지입니다.
S: \* 확인 \[UIDVALIDITY 3857529045\] UID가 유효함
S: a002 OK \[읽기-쓰기\] 선택 완료
C: a003 12개 전체 가져오기
S: \* 12 가져오기 \(FLAGS \(\Seen\) INTERNALDATE "1996년 7월 17일 02:44:25 -0700" RFC822.SIZE 4286 ENVELOPE \("1996년 7월 17일 수요일 02:23:25 -0700 \(PDT\)" " IMAP4rev1 WG mtg 요약 및 분" \(\("Terry Gray" NIL "gray" "cac.washington.edu"\)\) \(\("Terry Gray" NIL "gray" "cac.washington.edu"\)\) \(\("Terry Gray " NIL "회색" "cac.washington.edu"\)\) \(\(NIL NIL "imap" "cac.washington.edu"\)\) \(\(NIL NIL "분" "CNRI.Reston.VA.US"\) \("John Klensin" NIL "KLENSIN" "MIT.EDU"\)\) NIL NIL "<B27397-0100000@cac.washington.edu\>"\) BODY \("TEXT" "PLAIN" \("CHARSET" "US-ASCII"\) NIL NIL " 7비트" 3028 92\)\)
S: a003 OK 가져오기 완료됨
C: a004 12개 본문\[헤더\] 가져오기
S: \* 12 가져오기\(본문\[헤더\] {342}
S: 날짜: 1996년 7월 17일 수요일 02:23:25 -0700\(PDT\)
수신자: 보낸 사람: Terry Gray <gray@cac.washington.edu\>
S: 제목: IMAP4rev1 WG mtg 요약 및 회의록
S: 받는 사람: imap@cac.washington.edu
S: 참조: Minute@CNRI.Reston.VA.US, John Klensin <KLENSIN@MIT.EDU\>
S: 메시지 ID: <B27397-0100000@cac.washington.edu\>
S: MIME 버전: 1.0
S: 콘텐츠 유형: TEXT/PLAIN; 문자세트=US-ASCII
에스:
님: \)
S: a004 OK 가져오기 완료됨
C: a005 저장소 12 +플래그 \삭제됨
S: \* 12 가져오기 \(플래그 \(\표시 \삭제됨\)\)
S: a005 OK +FLAGS 완료
C: a006 로그아웃
S: \* BYE IMAP4rev1 서버 연결을 종료합니다
S: a006 OK 로그아웃 완료

---
## **9.      Formal Syntax**

다음 구문 사양은 \[ABNF\]에 지정된 ABNF\(Augmented Backus-Naur Form\) 표기법을 사용합니다.

이후 규칙이 이전 규칙과 겹치는 대체 또는 선택적 규칙의 경우 먼저 나열된 규칙이 우선순위를 가져야 합니다. 예를 들어, 플래그로 구문 분석될 때 "\Seen"은 플래그 확장이 아닌 \Seen 플래그 이름입니다. 하지만 "\Seen"은 플래그 확장으로 구문 분석될 수 있습니다. 전부는 아니지만 이 규칙의 일부 사례가 아래에 설명되어 있습니다.\(MUST\)

참고: \[ABNF\] 규칙을 엄격히 준수해야 합니다. \~에

-    특정한:\(MUST\)

- \(1\) 달리 명시된 경우를 제외하고 모든 알파벳 문자는 대소문자를 구분하지 않습니다. 토큰 문자열을 정의하기 위해 대문자 또는 소문자를 사용하는 것은 편집상의 명확성을 위해서만 사용됩니다. 구현에서는 이러한 문자열을 대소문자를 구분하지 않고 허용해야 합니다.\(MUST\)

- \(2\) 모든 경우에 SP는 정확히 하나의 공백을 의미합니다. TAB을 대체하거나 추가 공백을 삽입하거나 SP를 LWSP와 동일하게 취급하는 것은 허용되지 않습니다.

- \(3\) ASCII NUL 문자 %x00은 절대로 사용하면 안 됩니다.\(MUST NOT\)

```text
address         = "(" addr-name SP addr-adl SP addr-mailbox SP
                  addr-host ")"

addr-adl        = nstring
                    ; Holds route from [RFC-2822] route-addr if
                    ; non-NIL

addr-host       = nstring
                    ; NIL indicates [RFC-2822] group syntax.
                    ; Otherwise, holds [RFC-2822] domain name

addr-mailbox    = nstring
                    ; NIL indicates end of [RFC-2822] group; if
                    ; non-NIL and addr-host is NIL, holds
                    ; [RFC-2822] group name.
                    ; Otherwise, holds [RFC-2822] local-part
                    ; after removing [RFC-2822] quoting

addr-name       = nstring
                    ; If non-NIL, holds phrase from [RFC-2822]
                    ; mailbox after removing [RFC-2822] quoting

append          = "APPEND" SP mailbox [SP flag-list] [SP date-time] SP
                  literal
```

---
# **astring         = 1*ASTRING-CHAR / string**
---
# **ASTRING-CHAR   = ATOM-CHAR / resp-specials**
---
# **atom            = 1*ATOM-CHAR**
---
# **ATOM-CHAR       = <any CHAR except atom-specials>**

```text
atom-specials   = "(" / ")" / "{" / SP / CTL / list-wildcards /
                  quoted-specials / resp-specials
```

---
# **authenticate    = "AUTHENTICATE" SP auth-type *(CRLF base64)**

```text
auth-type       = atom
                    ; Defined by [SASL]
```

---
# **base64          = *(4base64-char) [base64-terminal]**

```text
base64-char     = ALPHA / DIGIT / "+" / "/"
                    ; Case-sensitive
```

---
# **base64-terminal = (2base64-char "==") / (3base64-char "=")**
---
# **body            = "(" (body-type-1part / body-type-mpart) ")"**

body-extension = nstring / number / "\(" body-extension \*\(SP body-extension\) "\)" ; 향후 확장. 클라이언트 구현 ; 본문 확장 필드를 허용해야 합니다. 서버 ; 구현은 생성해서는 안 됩니다. 에 의해 정의된 것을 제외한 본문 확장 필드; 미래 표준 또는 표준 트랙 ; 이 사양의 개정.\(MUST, MUST NOT\)

body-ext-1part = body-fld-md5 \[SP body-fld-dsp \[SP body-fld-lang \[SP body-fld-loc \*\(SP body-extension\)\]\]\] ; 확장할 수 없는 경우에는 반환하면 안 됩니다. "BODY" 가져오기\(MUST NOT\)

body-ext-mpart = body-fld-param \[SP body-fld-dsp \[SP body-fld-lang \[SP body-fld-loc \*\(SP body-extension\)\]\]\] ; 확장할 수 없는 경우에는 반환하면 안 됩니다. "BODY" 가져오기\(MUST NOT\)

```text
body-fields     = body-fld-param SP body-fld-id SP body-fld-desc SP
                  body-fld-enc SP body-fld-octets
```

---
# **body-fld-desc   = nstring**
---
# **body-fld-dsp    = "(" string SP body-fld-param ")" / nil**

```text
body-fld-enc    = (DQUOTE ("7BIT" / "8BIT" / "BINARY" / "BASE64"/
                  "QUOTED-PRINTABLE") DQUOTE) / string
```

---
# **body-fld-id     = nstring**
---
# **body-fld-lang   = nstring / "(" string *(SP string) ")"**
---
# **body-fld-loc    = nstring**
---
# **body-fld-lines  = number**
---
# **body-fld-md5    = nstring**
---
# **body-fld-octets = number**
---
# **body-fld-param  = "(" string SP string *(SP string SP string) ")" / nil**

```text
body-type-1part = (body-type-basic / body-type-msg / body-type-text)
                  [SP body-ext-1part]

body-type-basic = media-basic SP body-fields
                    ; MESSAGE subtype MUST NOT be "RFC822"

body-type-mpart = 1*body SP media-subtype
                  [SP body-ext-mpart]

body-type-msg   = media-message SP body-fields SP envelope
                  SP body SP body-fld-lines
```

---
# **body-type-text  = media-text SP body-fields SP body-fld-lines**

```text
capability      = ("AUTH=" auth-type) / atom
                    ; New capabilities MUST begin with "X" or be
                    ; registered with IANA as standard or
                    ; standards-track
```

기능 데이터 = "CAPABILITY" \*\(SP 기능\) SP "IMAP4rev1" \*\(SP 기능\) ; 서버는 STARTTLS, AUTH=PLAIN, ;을 구현해야 합니다. 및 LOGINDISABLED 기능; RFC 1730 호환성을 제공하는 서버는 다음과 같습니다. 첫 번째 기능으로 "IMAP4"를 나열합니다.\(MUST\)

```text
CHAR8           = %x01-ff
                    ; any OCTET except NUL, %x00

command         = tag SP (command-any / command-auth / command-nonauth /
                  command-select) CRLF
                    ; Modal based on state

command-any     = "CAPABILITY" / "LOGOUT" / "NOOP" / x-command
                    ; Valid in all states

command-auth    = append / create / delete / examine / list / lsub /
                  rename / select / status / subscribe / unsubscribe
                    ; Valid only in Authenticated or Selected state
```

command-nonauth = 로그인 / 인증 / "STARTTLS" ; 인증되지 않음 상태인 경우에만 유효합니다.

명령 선택 = "CHECK" / "CLOSE" / "EXPUNGE" / 복사 / 가져오기 / 저장 / uid / 검색 ; 선택됨 상태일 때만 유효합니다.

---
# **continue-req    = "+" SP (resp-text / base64) CRLF**
---
# **copy            = "COPY" SP sequence-set SP mailbox**

```text
create          = "CREATE" SP mailbox
                    ; Use of INBOX gives a NO error
```

---
# **date            = date-text / DQUOTE date-text DQUOTE**

```text
date-day        = 1*2DIGIT
                    ; Day of month
```

날짜-일-고정 = \(SP DIGIT\) / 2DIGIT ; 날짜-요일의 고정 형식 버전

```text
date-month      = "Jan" / "Feb" / "Mar" / "Apr" / "May" / "Jun" /
                  "Jul" / "Aug" / "Sep" / "Oct" / "Nov" / "Dec"
```

---
# **date-text       = date-day "-" date-month "-" date-year**
---
# **date-year       = 4DIGIT**

```text
date-time       = DQUOTE date-day-fixed "-" date-month "-" date-year
                  SP time SP zone DQUOTE

delete          = "DELETE" SP mailbox
                    ; Use of INBOX gives a NO error

digit-nz        = %x31-39
                    ; 1-9

envelope        = "(" env-date SP env-subject SP env-from SP
                  env-sender SP env-reply-to SP env-to SP env-cc SP
                  env-bcc SP env-in-reply-to SP env-message-id ")"
```

---
# **env-bcc         = "(" 1*address ")" / nil**
---
# **env-cc          = "(" 1*address ")" / nil**
---
# **env-date        = nstring**
---
# **env-from        = "(" 1*address ")" / nil**
---
# **env-in-reply-to = nstring**
---
# **env-message-id  = nstring**
---
# **env-reply-to    = "(" 1*address ")" / nil**
---
# **env-sender      = "(" 1*address ")" / nil**
---
# **env-subject     = nstring**
---
# **env-to          = "(" 1*address ")" / nil**
---
# **examine         = "EXAMINE" SP mailbox**

```text
fetch           = "FETCH" SP sequence-set SP ("ALL" / "FULL" / "FAST" /
                  fetch-att / "(" fetch-att *(SP fetch-att) ")")

fetch-att       = "ENVELOPE" / "FLAGS" / "INTERNALDATE" /
                  "RFC822" [".HEADER" / ".SIZE" / ".TEXT"] /
                  "BODY" ["STRUCTURE"] / "UID" /
                  "BODY" section ["<" number "." nz-number ">"] /
                  "BODY.PEEK" section ["<" number "." nz-number ">"]

flag            = "\Answered" / "\Flagged" / "\Deleted" /
                  "\Seen" / "\Draft" / flag-keyword / flag-extension
                    ; Does not include "\Recent"
```

플래그 확장 = "\" 원자 ; 향후 확장. 클라이언트 구현 ; 플래그 확장 플래그를 허용해야 합니다. 서버 ; 구현은 생성해서는 안 됩니다. 에 의해 정의된 것을 제외한 플래그 확장 플래그; 미래 표준 또는 표준 트랙 ; 이 사양의 개정.\(MUST, MUST NOT\)

---
# **flag-fetch      = flag / "\Recent"**
---
# **flag-keyword    = atom**
---
# **flag-list       = "(" [flag *(SP flag)] ")"**
---
# **flag-perm       = flag / "\*"**
---
# **greeting        = "*" SP (resp-cond-auth / resp-cond-bye) CRLF**
---
# **header-fld-name = astring**
---
# **header-list     = "(" header-fld-name *(SP header-fld-name) ")"**
---
# **list            = "LIST" SP mailbox SP list-mailbox**
---
# **list-mailbox    = 1*list-char / string**
---
# **list-char       = ATOM-CHAR / list-wildcards / resp-specials**
---
# **list-wildcards  = "%" / "*"**

```text
literal         = "{" number "}" CRLF *CHAR8
                    ; Number represents the number of CHAR8s
```

---
# **login           = "LOGIN" SP userid SP password**
---
# **lsub            = "LSUB" SP mailbox SP list-mailbox**

메일함 = "INBOX" / 문자열 ; INBOX는 대소문자를 구분하지 않습니다. 의 모든 대소문자 변형; INBOX\(예: "iNbOx"\)는 INBOX로 해석되어야 합니다. 아스트링이 아닙니다. 다음으로 구성된 문자열입니다. 대소문자를 구분하지 않는 시퀀스 "I" "N" "B" "O" "X" ; 문자열이 아닌 INBOX로 간주됩니다. ; 자세한 내용은 섹션 5.1을 참조하십시오. 사서함 이름의 의미적 세부정보입니다.\(MUST\)

```text
mailbox-data    =  "FLAGS" SP flag-list / "LIST" SP mailbox-list /
                   "LSUB" SP mailbox-list / "SEARCH" *(SP nz-number) /
                   "STATUS" SP mailbox SP "(" [status-att-list] ")" /
                   number SP "EXISTS" / number SP "RECENT"

mailbox-list    = "(" [mbx-list-flags] ")" SP
                   (DQUOTE QUOTED-CHAR DQUOTE / nil) SP mailbox

mbx-list-flags  = *(mbx-list-oflag SP) mbx-list-sflag
                  *(SP mbx-list-oflag) /
                  mbx-list-oflag *(SP mbx-list-oflag)
```

mbx-list-oflag = "\Noinferiors" / 플래그 확장 ; 기타 플래그; LIST 응답당 여러 개 가능

mbx-list-sflag = "\Noselect" / "\표시됨" / "\표시되지 않음" ; 선택성 플래그; LIST 응답당 하나만

```text
media-basic     = ((DQUOTE ("APPLICATION" / "AUDIO" / "IMAGE" /
                  "MESSAGE" / "VIDEO") DQUOTE) / string) SP
                  media-subtype
                    ; Defined in [MIME-IMT]
```

미디어 메시지 = DQUOTE "MESSAGE" DQUOTE SP DQUOTE "RFC822" DQUOTE ; \[MIME-IMT\]에 정의됨

미디어 하위 유형 = 문자열; \[MIME-IMT\]에 정의됨

```text
media-text      = DQUOTE "TEXT" DQUOTE SP media-subtype
                    ; Defined in [MIME-IMT]
```

---
# **message-data    = nz-number SP ("EXPUNGE" / ("FETCH" SP msg-att))**

```text
msg-att         = "(" (msg-att-dynamic / msg-att-static)
                   *(SP (msg-att-dynamic / msg-att-static)) ")"
```

msg-att-dynamic = "FLAGS" SP "\(" \[플래그-페치 \*\(SP 플래그-페치\)\] "\)" ; 메시지가 변경될 수 있습니다.\(MAY\)

msg-att-static = "ENVELOPE" SP 봉투 / "INTERNALDATE" SP 날짜-시간 / "RFC822" \[".HEADER" / ".TEXT"\] SP nstring / "RFC822.SIZE" SP 번호 / "BODY" \[" STRUCTURE"\] SP 본문 / "BODY" 섹션 \["<" 숫자 "\>"\] SP nstring / "UID" SP 고유 ID ; 메시지를 변경하면 안 됩니다.\(MUST NOT\)

---
# **nil             = "NIL"**
---
# **nstring         = string / nil**

```text
number          = 1*DIGIT
                    ; Unsigned 32-bit integer
                    ; (0 <= n < 4,294,967,296)

nz-number       = digit-nz *DIGIT
                    ; Non-zero unsigned 32-bit integer
                    ; (0 < n < 4,294,967,296)
```

---
# **password        = astring**
---
# **quoted          = DQUOTE *QUOTED-CHAR DQUOTE**

```text
QUOTED-CHAR     = <any TEXT-CHAR except quoted-specials> /
                  "\" quoted-specials
```

---
# **quoted-specials = DQUOTE / "\"**

```text
rename          = "RENAME" SP mailbox SP mailbox
                    ; Use of INBOX as a destination gives a NO error
```

---
# **response        = *(continue-req / response-data) response-done**

```text
response-data   = "*" SP (resp-cond-state / resp-cond-bye /
                  mailbox-data / message-data / capability-data) CRLF
```

---
# **response-done   = response-tagged / response-fatal**

```text
response-fatal  = "*" SP resp-cond-bye CRLF
                    ; Server closes connection immediately
```

---
# **response-tagged = tag SP resp-cond-state CRLF**

```text
resp-cond-auth  = ("OK" / "PREAUTH") SP resp-text
                    ; Authentication condition
```

---
# **resp-cond-bye   = "BYE" SP resp-text**

```text
resp-cond-state = ("OK" / "NO" / "BAD") SP resp-text
                    ; Status condition
```

---
# **resp-specials   = "]"**
---
# **resp-text       = ["[" resp-text-code "]" SP] text**

resp-text-code = "ALERT" / "BADCHARSET" \[SP "\(" astring \*\(SP astring\) "\)" \] / 기능 데이터 / "PARSE" / "PERMANENTFLAGS" SP "\(" \[flag-perm \*\( SP 플래그-perm\)\] "\)" / "READ-ONLY" / "READ-WRITE" / "TRYCREATE" / "UIDNEXT" SP nz-번호 / "UIDVALIDITY" SP nz-번호 / "UNSEEN" SP nz-번호 / 원자 \[SP 1\*<"\]"\>를 제외한 모든 TEXT-CHAR

```text
search          = "SEARCH" [SP "CHARSET" SP astring] 1*(SP search-key)
                    ; CHARSET argument to MUST be registered with IANA

search-key      = "ALL" / "ANSWERED" / "BCC" SP astring /
                  "BEFORE" SP date / "BODY" SP astring /
                  "CC" SP astring / "DELETED" / "FLAGGED" /
                  "FROM" SP astring / "KEYWORD" SP flag-keyword /
                  "NEW" / "OLD" / "ON" SP date / "RECENT" / "SEEN" /
                  "SINCE" SP date / "SUBJECT" SP astring /
                  "TEXT" SP astring / "TO" SP astring /
                  "UNANSWERED" / "UNDELETED" / "UNFLAGGED" /
                  "UNKEYWORD" SP flag-keyword / "UNSEEN" /
                    ; Above this line were in [IMAP2]
                  "DRAFT" / "HEADER" SP header-fld-name SP astring /
                  "LARGER" SP number / "NOT" SP search-key /
                  "OR" SP search-key SP search-key /
                  "SENTBEFORE" SP date / "SENTON" SP date /
                  "SENTSINCE" SP date / "SMALLER" SP number /
                  "UID" SP sequence-set / "UNDRAFT" / sequence-set /
                  "(" search-key *(SP search-key) ")"
```

---
# **section         = "[" [section-spec] "]"**

section-msgtext = "HEADER" / "HEADER.FIELDS" \[".NOT"\] SP 헤더 목록 / "TEXT" ; 최상위 또는 MESSAGE/RFC822 부분

```text
section-part    = nz-number *("." nz-number)
                    ; body part nesting
```

---
# **section-spec    = section-msgtext / (section-part ["." section-text])**

```text
section-text    = section-msgtext / "MIME"
                    ; text other than actual body part (headers, etc.)
```

---
# **select          = "SELECT" SP mailbox**

시퀀스 번호 = nz 번호 / "\*" ; 메시지 시퀀스 번호\(COPY, FETCH, STORE ; 명령\) 또는 고유 식별자\(UID COPY, ; UID FETCH, UID STORE 명령\). ; \*는 사용 중인 가장 큰 숫자를 나타냅니다. 안에 ; 메시지 시퀀스 번호의 경우는 입니다. 비어 있지 않은 메일함의 메시지 수. ; 고유 식별자의 경우 ; 에 있는 마지막 메시지의 고유 식별자입니다. 사서함 또는 사서함이 비어 있는 경우 ; 사서함의 현재 UIDNEXT 값입니다. ; 서버는 BAD 태그로 응답해야 합니다. 메시지를 사용하는 명령에 대한 응답; 의 수보다 큰 시퀀스 번호 ; 선택한 메일함의 메시지. 이것 ; 선택한 사서함이 비어 있으면 "\*"가 포함됩니다.

seq-범위 = seq-번호 ":" seq-number ; 두 개의 시퀀스 번호 값과 사이의 모든 값; 순서 상관없이 둘. ; 예: 2:4와 4:2는 동일하며 다음을 나타냅니다. 값 2, 3, 4. ; 예: 고유 식별자 시퀀스 범위: ; 3291:\*에는 마지막 메시지의 UID가 포함됩니다. 해당 값이 3291보다 작은 경우에도 사서함.

시퀀스 세트 = \(시퀀스 번호 / 시퀀스 범위\) \*\("," 시퀀스 세트\) ; 순서에 관계없이 일련번호 값의 집합입니다. ; 서버는 겹침을 병합하거나 실행할 수 있습니다. 어떤 순서로든. ; 예: 메시지 시퀀스 번호 세트 ; 15개의 메시지가 있는 사서함의 경우 2,4:7,9,12:\*는 입니다. 2,4,5,6,7,9,12,13,14,15 와 동일합니다. 예: \*:4,5:7로 설정된 메시지 시퀀스 번호; 10개의 메시지가 있는 사서함의 경우 ; 10,9,8,7,6,5,4,5,6,7 및 재정렬 가능 및 ; 4,5,6,7,8,9,10으로 합쳐졌습니다.\(MAY, MAY\)

```text
status          = "STATUS" SP mailbox SP
                  "(" status-att *(SP status-att) ")"

status-att      = "MESSAGES" / "RECENT" / "UIDNEXT" / "UIDVALIDITY" /
                  "UNSEEN"
```

---
# **status-att-list =  status-att SP number *(SP status-att SP number)**
---
# **store           = "STORE" SP sequence-set SP store-att-flags**

```text
store-att-flags = (["+" / "-"] "FLAGS" [".SILENT"]) SP
                  (flag-list / (flag *(SP flag)))
```

---
# **string          = quoted / literal**
---
# **subscribe       = "SUBSCRIBE" SP mailbox**
---
# **tag             = 1*<any ASTRING-CHAR except "+">**
---
# **text            = 1*TEXT-CHAR**
---
# **TEXT-CHAR       = <any CHAR except CR and LF>**

```text
time            = 2DIGIT ":" 2DIGIT ":" 2DIGIT
                    ; Hours minutes seconds

uid             = "UID" SP (copy / fetch / search / store)
                    ; Unique identifiers used instead of message
                    ; sequence numbers

uniqueid        = nz-number
                    ; Strictly ascending
```

---
# **unsubscribe     = "UNSUBSCRIBE" SP mailbox**
---
# **userid          = astring**
---
# **x-command       = "X" atom <experimental command arguments>**

구역 = \("+" / "-"\) 4DIGIT ; 를 나타내는 hhmm의 부호 있는 4자리 값; 그리니치 동쪽의 시와 분\(즉, 주어진 시간이 세계시와 다른 양\). 시간대 빼기 ; 주어진 시간부터 UT 양식을 제공합니다. ; 세계 표준시\(Universal Time Zone\)는 "+0000"입니다.

---
## **10.     Author's Note**

이 문서는 이전 문서의 개정판이거나 재작성되었으며 RFC 2060, RFC 1730, 게시되지 않은 IMAP2bis.TXT 문서, RFC 1176 및 RFC 1064 문서의 프로토콜 사양을 대체합니다.

---
## **11.     Security Considerations**

전자 메일 데이터를 포함한 IMAP4rev1 프로토콜 트랜잭션은 스누핑 방지가 협상되지 않는 한 네트워크를 통해 암호화되지 않은 상태로 전송됩니다. 이는 STARTTLS, AUTHENTICATE 명령의 협상된 개인 정보 보호 또는 기타 보호 메커니즘을 사용하여 수행할 수 있습니다.

---
### **11.1.   STARTTLS Security Considerations**

이 문서의 STARTTLS 명령 및 LOGINDISABLED 기능 사양은 \[IMAP-TLS\]의 사양을 대체합니다. \[IMAP-TLS\]는 PLAIN \[SASL\] 인증자에 대한 표준으로 남아 있습니다.

IMAP 클라이언트 및 서버 구현은 TLS\_RSA\_WITH\_RC4\_128\_MD5 \[TLS\] 암호 모음을 구현해야 하며\(MUST\) TLS\_DHE\_DSS\_WITH\_3DES\_EDE\_CBC\_SHA \[TLS\] 암호 모음을 구현해야 합니다\(SHOULD\). 이는 두 개의 호환 구현이 상호 운용되도록 구성할 수 있으므로 중요합니다. 다른 모든 암호 제품군은 선택 사항입니다. 이는 \[IMAP-TLS\] 섹션 2.1에서 변경된 사항입니다.\(MUST, MAY\)

\[TLS\] 협상 중에 클라이언트는 중간자 공격을 방지하기 위해 서버 인증서 메시지에 표시된 서버의 ID와 비교하여 서버 호스트 이름에 대한 이해를 확인해야 합니다. 일치가 실패하면 클라이언트는 명시적인 사용자 확인을 요청하거나 연결을 종료하고 서버의 신원이 의심스럽다는 것을 나타내야 합니다. 일치는 다음 규칙에 따라 수행됩니다.\(MUST, SHOULD\)

- 클라이언트는 연결을 여는 데 사용한 서버 호스트 이름을 서버 인증서에 표시된 서버 이름과 비교할 값으로 사용해야 합니다. 클라이언트는 안전하지 않은 원격 소스\(예: 안전하지 않은 DNS 조회\)에서 파생된 서버 호스트 이름의 어떤 형태도 사용해서는 안 됩니다. CNAME 표준화가 완료되지 않았습니다.\(MUST, MUST NOT\)

- dNSName 유형의 subjectAltName 확장이 인증서에 있는 경우 이를 서버 ID의 소스로 사용해야 합니다.\(SHOULD\)

- 일치는 대소문자를 구분하지 않습니다.

- "\*" 와일드카드 문자는 인증서의 가장 왼쪽 이름 구성 요소로 사용될 수 있습니다. 예를 들어 \*.example.com은 a.example.com, foo.example.com 등과 일치하지만 example.com과 일치하지 않습니다.\(MAY\)

- 인증서에 여러 이름이 포함된 경우\(예: 둘 이상의 dNSName 필드\) 필드 중 하나와 일치하는 것이 허용되는 것으로 간주됩니다.

클라이언트와 서버 모두 STARTTLS 명령과 후속 \[TLS\] 협상의 결과를 확인하여 허용 가능한 인증 또는 개인 정보 보호가 달성되었는지 확인해야 합니다.\(MUST\)

---
### **11.2.   Other Security Considerations**

유효하지 않은 자격 증명으로 인해 실패한 AUTHENTICATE 명령에 대한 서버 오류 메시지에는 자격 증명이 유효하지 않은 이유를 자세히 설명해서는 안 됩니다.\(SHOULD NOT\)

LOGIN 명령을 사용하면 비밀번호가 암호화되지 않은 상태로 전송됩니다. 이는 일반 텍스트 비밀번호를 사용하지 않는 \[SASL\] 메커니즘과 함께 AUTHENTICATE 명령을 사용하고 먼저 STARTTLS 또는 기타 보호 메커니즘을 통해 암호화를 협상함으로써 방지할 수 있습니다.

서버 구현은 인증 시 다음을 요구하는 구성을 구현해야 합니다. \(1\) STARTTLS 명령이 협상되었습니다. 또는 \(2\) 비밀번호 스누핑으로부터 세션을 보호하는 다른 메커니즘이 제공되었습니다. 또는 \(3\) 다음 조치가 적용됩니다. \(a\) LOGINDISABLED 기능이 광고되고 일반 텍스트 비밀번호를 사용하는 \[SASL\] 메커니즘\(예: PLAIN\)이 CAPABILITY 목록에 광고되지 않습니다. AND \(b\) LOGIN 명령은 비밀번호가 정확하더라도 오류를 반환합니다. AND \(c\) AUTHENTICATE 명령은 비밀번호가 올바른 경우에도 일반 텍스트 비밀번호를 사용하는 모든 \[SASL\] 메커니즘에서 오류를 반환합니다.\(MUST\)

실패한 LOGIN 명령에 대한 서버 오류 메시지는 비밀번호가 아닌 사용자 이름이 유효하지 않다고 지정해서는 안 됩니다.\(SHOULD NOT\)

서버에는 실패한 AUTHENTICATE/LOGIN 시도를 제한하거나 지연하는 메커니즘이 있어야 합니다.\(SHOULD\)

추가 보안 고려 사항은 AUTHENTICATE 및 LOGIN 명령을 설명하는 섹션에서 설명합니다.

---
## **12.     IANA Considerations**

IMAP4 기능은 표준 트랙 또는 IESG 승인 실험적 RFC를 게시하여 등록됩니다. 레지스트리는 현재 다음 위치에 있습니다.

```text
        http://www.iana.org/assignments/imap4-capabilities
```

이 사양은 이전에 \[IMAP-TLS\]에 정의된 STARTTLS 및 LOGINDISABLED 확장을 개정하므로 이에 따라 레지스트리가 업데이트됩니다.

---
# **Appendices**
---
## **A.      Normative References**

다음 문서에는 이 문서를 올바르게 이해하는 데 필요한 정의 또는 사양이 포함되어 있습니다. \[ABNF\] Crocker, D. 및 P. Overell, "구문 사양에 대한 Augmented BNF: ABNF", RFC 2234, 1997년 11월.

```text
   [ANONYMOUS]           Newman, C., "Anonymous SASL Mechanism", RFC
                         2245, November 1997.
```

\[CHARSET\] Freed, N. 및 J. Postel, "IANA 문자 집합 등록 절차", RFC 2978, 2000년 10월.

\[DIGEST-MD5\] Leach, P. 및 C. Newman, "다이제스트 사용

- SASL 메커니즘으로 인증", RFC 2831, 2000년 5월.

\[처분\] Troost, R., Dorner, S. 및 K. Moore,

- "인터넷 메시지에서 프레젠테이션 정보 전달: 콘텐츠 처리 헤더", RFC 2183, 1997년 8월.

\[IMAP-TLS\] Newman, C., "IMAP, POP3 및 ACAP에서 TLS 사용", RFC 2595, 1999년 6월.

\[키워드\] Bradner, S., "요구 수준을 나타내기 위해 RFC에서 사용할 수 있는 키워드", BCP 14, RFC 2119, 1997년 3월.

\[언어 태그\] Alvestrand, H., "언어 식별을 위한 태그", BCP 47, RFC 3066, 2001년 1월.

\[위치\] Palme, J., Hopmann, A. 및 N. Shelness, "HTML\(MHTML\)과 같은 집계 문서의 MIME 캡슐화", RFC 2557, 1999년 3월.

\[MD5\] Myers, J. 및 M. Rose, "Content-MD5 헤더 필드", RFC 1864, 1995년 10월.

\[MIME-HDRS\] Moore, K., "MIME\(다목적 인터넷 메일 확장\) 3부: 비ASCII 텍스트에 대한 메시지 헤더 확장", RFC 2047, 1996년 11월.

\[MIME-IMB\] Freed, N. 및 N. Borenstein, "MIME

- \(다목적 인터넷 메일 확장\) 1부: 인터넷 메시지 본문 형식", RFC 2045, 1996년 11월.

\[MIME-IMT\] Freed, N. 및 N. Borenstein, "MIME

- \(다목적 인터넷 메일 확장\) 2부: 미디어 유형", RFC 2046, 1996년 11월.

```text
   [RFC-2822]            Resnick, P., "Internet Message Format", RFC
                         2822, April 2001.
```

\[SASL\] Myers, J., "Simple Authentication and Security Layer\(SASL\)", RFC 2222, 1997년 10월.

\[TLS\] Dierks, T. 및 C. Allen, "TLS 프로토콜 버전 1.0", RFC 2246, 1999년 1월.

\[UTF-7\] Goldsmith, D. 및 M. Davis, "UTF-7: 유니코드의 메일 안전 변환 형식", RFC 2152, 1997년 5월.

다음 문서에서는 이 프로토콜을 구현할 때 신중하게 고려해야 하는 구현 품질 문제에 대해 설명합니다.

```text
   [IMAP-IMPLEMENTATION] Leiba, B., "IMAP Implementation
                         Recommendations", RFC 2683, September 1999.

   [IMAP-MULTIACCESS]    Gahrns, M., "IMAP4 Multi-Accessed Mailbox
                         Practice", RFC 2180, July 1997.
```

---
## **A.1     Informative References**

다음 문서에서는 관련 프로토콜을 설명합니다.

\[IMAP-DISC\] Austein, R., "연결이 끊긴 IMAP4 클라이언트에 대한 동기화 작업", 작업 진행 중.

\[IMAP-모델\] Crispin, M., "IMAP4의 분산 전자 메일 모델", RFC 1733, 1994년 12월.

\[ACAP\] Newman, C. 및 J. Myers, "ACAP - 애플리케이션 구성 액세스 프로토콜", RFC 2244, 1997년 11월.

```text
   [SMTP]                Klensin, J., "Simple Mail Transfer Protocol",
                         STD 10, RFC 2821, April 2001.
```

다음 문서는 역사적이거나 이 프로토콜의 역사적 측면을 설명합니다.

\[IMAP-COMPAT\] Crispin, M., "IMAP4 호환성

- IMAP2bis", RFC 2061, 1996년 12월.

\[IMAP-역사\] Crispin, M., "IMAP2 및 IMAP2bis와의 IMAP4 호환성", RFC 1732, 1994년 12월.

```text
   [IMAP-OBSOLETE]       Crispin, M., "Internet Message Access Protocol
                         - Obsolete Syntax", RFC 2062, December 1996.

   [IMAP2]               Crispin, M., "Interactive Mail Access Protocol
                         - Version 2", RFC 1176, August 1990.
```

\[RFC-822\] Crocker, D., "ARPA 인터넷 문자 메시지 형식에 대한 표준", STD 11, RFC 822, 1982년 8월.

```text
   [RFC-821]             Postel, J., "Simple Mail Transfer Protocol",
                         STD 10, RFC 821, August 1982.
```

---
## **B.      Changes from RFC 2060**

1\) 고유 식별자와 그 의미에 대한 설명을 명확히 합니다.

2\) SELECT 및 EXAMINE 응답에 UIDVALIDITY가 필요하다는 점을 명확히 하기 위해 SELECT 설명을 수정합니다.

3\) 검색 실패 예시를 추가했습니다.

4\) 올바른 store-att-flags: "#flag"는 "1#flag"여야 합니다.

5\) 검색 및 섹션 규칙이 더욱 명확해졌습니다.

6\) STORE 예시를 수정하세요.

```text
   7) Correct "BASE645" misspelling.
```

8\) 텍스트와 BASE64 첨부 파일이 있는 두 부분으로 구성된 메시지의 예에서 불필요한 닫는 괄호를 제거합니다.

9\) 메일박스 데이터에서 더 이상 사용되지 않는 "MAILBOX" 응답을 제거합니다.

10\) 메일함 데이터 규칙에서 가짜 "<"가 제거되었습니다.

11\) continue-req에 CRLF를 추가합니다.

12\) resp-text-code의 원자에서 "\]"를 구체적으로 제외합니다.

13\) 클라이언트와 서버가 프로토콜 구문을 엄격하게 준수해야 함을 명확히 합니다.

14\) 5.2에서는 EXISTS를 사용하여 메일함을 축소할 수 없다는 점을 강조합니다.

15\) resp-text-code에 NEWNAME을 추가합니다.

16\) NIL이 아닌 빈 문자열이 LIST에 대한 인수로 사용된다는 점을 명확히 합니다.

17\) 사서함 네임스페이스가 단순할 경우 NIL이 빈 문자열 사서함 이름 인수에 대한 계층 구분 기호로 반환될 수 있음을 명확히 합니다.

18\) addr-mailbox 및 addr-name에서 RFC-2822 인용이 제거되었음을 명확히 합니다.

```text
   19) Update UTF-7 reference.
```

20\) 6.3.11의 예제를 수정합니다.

21\) 존재하지 않는 UID는 무시된다는 점을 명확히 합니다.

```text
   22) Update DISPOSITION reference.

   23) Expand state diagram.
```

24\) 부분 가져오기 응답은 부분 가져오기 명령에 대한 응답으로만 반환된다는 점을 명확히 합니다.

```text
   25) Add UIDNEXT response code.  Correct UIDVALIDITY definition
   reference.
```

26\) "can"과 "MAY"에 대한 추가 설명.\(MAY\)

```text
   27) Reference RFC-2119.
```

28\) 수정된 UTF-7에서는 불필요한 이동이 허용되지 않음을 명확히 합니다.

29\) 수정된 UTF-7에는 암시적 이동이 없음을 명확히 합니다.

30\) 메일함 이름의 "INBOX"는 문자열로 제공되더라도 항상 INBOX임을 명시합니다.

31\) 미디어 기본 문법 규칙에 누락된 여는 괄호를 추가합니다.

32\) 메일박스 데이터의 속성 구문을 수정하세요.

33\) EXAMINE 응답에 UIDNEXT를 추가합니다.

34\) SELECT 및 EXAMINE에서 UNSEEN, PERMANENTFLAGS, UIDVALIDITY 및 UIDNEXT 응답을 명확히 합니다. 지금은 필요하지만 이전 버전에는 없었습니다.

35\) RFC 번호로 참조를 업데이트합니다.

```text
   36) Flush text-mime2.
```

37\) 수정된 UTF-7 이름은 대소문자를 구분해야 하며 규칙을 위반하는 것은 피해야 함을 명확히 합니다.

```text
   38) Correct UID FETCH example.
```

39\) UID FETCH, UID STORE, UID SEARCH와 태그가 지정되지 않은 EXPUNGE 응답을 명확히 합니다.

40\) "협약"이라는 단어의 사용을 명확히 하세요.

41\) 명령이 완전히 수신될 때까지 명령이 "진행 중"이 아니라는 점을 명확히 합니다\(구체적으로 명령 지속 협상 중에 명령이 "진행 중"이 아니라는 점\).

```text
   42) Clarify envelope defaulting.
```

43\) SP는 단 하나의 공백 문자를 의미함을 명확히 합니다.

44\) LIST 응답에서 어리석은 상태를 금지합니다.

45\) 메시지의 ENVELOPE, INTERNALDATE, RFC822\*, BODY\* 및 UID가 정적임을 명확히 합니다.

```text
   46) Add BADCHARSET response code.
```

47\) 형식 구문을 \[ABNF\] 규칙으로 업데이트합니다.

48\) CREATE 의미론에서 후행 계층 구분 기호를 명확히 합니다.

49\) "빈 줄"이 \[RFC-2822\] 구분 빈 줄임을 명확히 합니다.

50\) RENAME은 명령을 완료하는 데 필요한 계층 구조도 생성해야 함을 명확히 합니다.

51\) 처리가 있는 경우 언어가 필요하지 않도록 body-ext-mpart를 수정합니다.

52\) RFC822.HEADER 응답을 명확히 하세요.

53\) 검색에서 charset astring 뒤에 누락된 공백을 수정합니다.

54\) resp-text-code에서 BADCHARSET에 대한 누락된 따옴표를 수정합니다.

55\) ALL, FAST, FULL은 다른 데이터 항목이 표시되지 않는다는 점을 명확히 합니다.

56\) LIST에서 참조 인수의 의미를 명확히 합니다.

57\) SEARCH HEADER X-FOO에 대한 널 문자열은 헤더의 텍스트와 관계없이 X-FOO라는 필드 이름을 가진 헤더 행이 있는 모든 메시지를 의미함을 명확히 합니다.

58\) 나중에 UTF-8로 사용할 수 있도록 8비트 메일박스 이름을 특별히 예약하세요.

59\) 클라이언트가 PERMANENTFLAGS 목록에 없는 플래그를 저장하는 것은 오류가 아닙니다. 그러나 서버는 변경 사항을 무시하거나 세션에서만 변경합니다.

60\) 불필요한 교대근무에 관한 텍스트를 수정/명확하게 하세요.

61\) '변경사항' 섹션의 인쇄상의 오류를 수정하세요.

62\) 선택한 메일함에서 새 메시지를 확인하는 데 STATUS를 사용하면 안 된다는 점을 명확히 합니다.

63\) "%" 와일드카드를 사용하여 LSUB 동작을 명확하게 합니다.

64\) 섹션 7.5에서 AUTHORIZATION을 AUTHENTICATE로 변경합니다.

65\) 다중 부분 본문 유형에 대한 설명을 명확하게 합니다.

66\) STORE FLAGS가 \Recent에 영향을 주지 않는다는 점을 명확히 합니다.

67\) 시간대 설명에서 "west"를 "east"로 변경합니다.

68\) 명령 파이프라인을 중단하는 명령은 완료 결과 응답을 기다려야 함을 명확히 합니다.

69\) EXAMINE이 \Recent에 영향을 미치지 않음을 명확히 합니다.

70\) MIME 구조 설명을 일관되게 만드세요.

71\) 날짜 검색에서는 INTERNALDATE 또는 Date: 헤더의 시간과 시간대를 무시한다는 점을 명확히 합니다. 즉, "ON 13-APR-2000"은 "13-APR-2000"으로 시작하는 INTERNALDATE 텍스트가 포함된 메시지를 의미합니다. 이는 현지 시간대와의 시간대 차이가 해당 INTERNALDATE를 이전 또는 다음 날로 이동하기에 충분하더라도 마찬가지입니다.

72\) 헤더 페치 시 \[RFC-2822\] 메시지에 빈 줄이 없으면 빈 줄을 추가하지 않는다는 점을 명확히 하세요.

73\) \(UID에 대한 논의에서\) 메시지가 불변이라는 점을 명확히 하세요.

74\) CHARSET 검색 예시를 추가하세요.

75\) SEARCH에서 키워드는 일종의 플래그라는 점을 명확히 하세요.

76\) SELECT 데이터 응답의 필수 특성을 명확히 합니다.

77\) 초기 OK 또는 PREAUTH에 선택적 CAPABILITY 응답 코드를 추가하세요.

78\) 서버가 AUTHENTICATE 및 LOGIN에 대한 응답의 일부로 태그가 지정되지 않은 CAPABILITY 명령을 보낼 수 있다는 메모를 추가합니다.

79\) 연결에서 CAPABILITY 명령을 두 번 이상 실행할 필요가 없다는 설명을 제거합니다. 그 말은 더 이상 사실이 아닙니다.

80\) 태그가 지정되지 않은 EXPUNGE는 메일함의 메시지 수를 감소시킨다는 점을 명확히 합니다.

81\) "본문"의 정의를 수정합니다\(연결은 교대보다 더 긴밀한 바인딩을 갖습니다\).

82\) \[IMAP-IMPLEMENTATION\]을 참조하여 새로운 "구현자를 위한 특별 참고 사항" 섹션을 추가합니다.

83\) AUTHENTICATE 명령에 대한 태그가 지정되지 않은 CAPABILITY 응답은 보안 계층이 협상되지 않은 경우에만 수행되어야 함을 명확히 합니다.

84\) "\]"를 제외하도록 원자의 정의를 변경하십시오. 과거와의 호환성을 위해 "\]"를 포함하도록 문자열을 업데이트합니다. resp-text-atom을 제거하십시오.

85\) NEWNAME을 제거합니다. 사서함 이름은 리터럴일 수 있고 "\]"를 포함할 수 있으므로 작동할 수 없습니다. 기능은 추천을 통해 해결될 수 있습니다.

86\) 보다 논리적인 단락 흐름을 갖기 위해 수정된 UTF-7 근거를 이동합니다.

87\) MUST를 사용하여 UID 고유성 보장을 명확히 합니다.\(MUST\)

88\) 클라이언트는 BYE에서 즉시 연결을 닫는 대신 연결이 닫힐 때까지 응답 데이터를 읽어야 합니다.

89\) RFC-822 참조를 RFC-2822로 변경합니다.

90\) RFC-822 대신 RFC-2822를 따라야 함을 명확히 하세요.

91\) 태그된 OK에서 CAPABILITY 응답 코드를 사용하도록 LOGIN 및 AUTHENTICATE의 선택적 자동 기능 권장 사항을 변경합니다. 이는 요청되지 않은 태그가 지정되지 않은 CAPABILITY 응답보다 상호 운용성이 뛰어납니다.

92\) STARTTLS 및 AUTH=PLAIN은 필수 구현입니다. 다른 \[SASL\] 메커니즘에 대한 권장 사항을 추가합니다.

93\) "연결"\("서버" 또는 "명령"과 반대\)이 네 가지 상태 중 하나에 있음을 명확히 하십시오.

94\) 실패하거나 거부된 명령은 상태를 변경하지 않는다는 점을 명확히 하세요.

95\) 규범적인 것과 유익한 것 사이에서 참고문헌을 분리하세요.

96\) 보안 섹션에서 인증 실패 문제를 논의하세요.

97\) 데이터 항목이 반드시 하나의 데이터 유형일 필요는 없음을 명확히 하십시오.

98\) 시퀀스 범위는 순서와 무관하다는 점을 명확히 하세요.

99\) Modified-UTF7의 불필요한 이동은 단지 이동을 생략하는 것만으로는 해결될 수 없음을 명확히 하기 위해 예를 변경합니다. 전체 문자열을 다시 계산해야 합니다.

100\) \[RFC-2822\]는 \[RFC-2822\] 헤더에 나타나는 봉투 데이터가 아닌 \[SMTP\] 봉투를 참조하기 위해 "봉투"를 사용하므로 봉투 구조 정의를 변경합니다.

101\) RFC822.HEADER 응답 데이터와 BODY\[HEADER\]를 확장합니다.

```text
   102) Clarify Logout state semantics, change ASCII art.
```

103\) IESG 요구 사항을 준수하기 위한 보안 변경.

104\) 본문 URI에 대한 정의를 추가합니다.

105\) 브레이크 시퀀스 범위 정의를 세 가지 규칙으로 나누고 각 규칙에 대한 설명을 다시 작성했습니다.

106\) \[IMAP-TLS\]에서 STARTTLS 및 LOGINDISABLED를 여기로 이동하세요.

```text
   107) Add IANA Considerations section.
```

108\) 새 메시지 UID와 UIDNEXT에 대한 유효한 클라이언트 가정을 명확히 합니다.

109\) 영구 플래그에 대한 변경 사항은 후속 세션뿐만 아니라 동시 세션에도 영향을 미친다는 점을 명확히 합니다.

110\) CLOSE 명령으로 인증된 상태로 들어갈 수 있음을 명확히 합니다.

111\) SELECT 및 EXAMINE은 실패한 명령이 상태를 변경하지 않는다는 규칙의 예외임을 강조합니다.

112\) 새로 추가된 메시지에는 최근 플래그가 설정되어 있음을 명확히 합니다.

113\) 새로 복사된 메시지에는 최근 플래그가 설정되어야 함을 명확히 합니다.\(SHOULD\)

114\) UID 명령은 항상 FETCH 응답에서 UID를 반환한다는 점을 명확히 합니다.

---
## **C.      Key Word Index**

```text
       +FLAGS <flag list> (store command data item) ...............   59
       +FLAGS.SILENT <flag list> (store command data item) ........   59
       -FLAGS <flag list> (store command data item) ...............   59
       -FLAGS.SILENT <flag list> (store command data item) ........   59
       ALERT (response code) ......................................   64
       ALL (fetch item) ...........................................   55
       ALL (search key) ...........................................   50
       ANSWERED (search key) ......................................   50
       APPEND (command) ...........................................   45
       AUTHENTICATE (command) .....................................   27
       BAD (response) .............................................   66
       BADCHARSET (response code) .................................   64
       BCC <string> (search key) ..................................   51
       BEFORE <date> (search key) .................................   51
       BODY (fetch item) ..........................................   55
       BODY (fetch result) ........................................   73
       BODY <string> (search key) .................................   51
       BODY.PEEK[<section>]<<partial>> (fetch item) ...............   57
       BODYSTRUCTURE (fetch item) .................................   57
       BODYSTRUCTURE (fetch result) ...............................   74
       BODY[<section>]<<origin octet>> (fetch result) .............   74
       BODY[<section>]<<partial>> (fetch item) ....................   55
       BYE (response) .............................................   67
       Body Structure (message attribute) .........................   12
       CAPABILITY (command) .......................................   24
       CAPABILITY (response code) .................................   64
       CAPABILITY (response) ......................................   68
       CC <string> (search key) ...................................   51
       CHECK (command) ............................................   47
       CLOSE (command) ............................................   48
       COPY (command) .............................................   59
       CREATE (command) ...........................................   34
       DELETE (command) ...........................................   35
       DELETED (search key) .......................................   51
       DRAFT (search key) .........................................   51
       ENVELOPE (fetch item) ......................................   57
       ENVELOPE (fetch result) ....................................   77
       EXAMINE (command) ..........................................   33
       EXISTS (response) ..........................................   71
       EXPUNGE (command) ..........................................   48
       EXPUNGE (response) .........................................   72
       Envelope Structure (message attribute) .....................   12
       FAST (fetch item) ..........................................   55
       FETCH (command) ............................................   54
       FETCH (response) ...........................................   73
       FLAGGED (search key) .......................................   51
       FLAGS (fetch item) .........................................   57
       FLAGS (fetch result) .......................................   78
       FLAGS (response) ...........................................   71
       FLAGS <flag list> (store command data item) ................   59
       FLAGS.SILENT <flag list> (store command data item) .........   59
       FROM <string> (search key) .................................   51
       FULL (fetch item) ..........................................   55
       Flags (message attribute) ..................................   11
       HEADER (part specifier) ....................................   55
       HEADER <field-name> <string> (search key) ..................   51
       HEADER.FIELDS <header-list> (part specifier) ...............   55
       HEADER.FIELDS.NOT <header-list> (part specifier) ...........   55
       INTERNALDATE (fetch item) ..................................   57
       INTERNALDATE (fetch result) ................................   78
       Internal Date (message attribute) ..........................   12
       KEYWORD <flag> (search key) ................................   51
       Keyword (type of flag) .....................................   11
       LARGER <n> (search key) ....................................   51
       LIST (command) .............................................   40
       LIST (response) ............................................   69
       LOGIN (command) ............................................   30
       LOGOUT (command) ...........................................   25
       LSUB (command) .............................................   43
       LSUB (response) ............................................   70
       MAY (specification requirement term) .......................    4
       MESSAGES (status item) .....................................   45
       MIME (part specifier) ......................................   56
       MUST (specification requirement term) ......................    4
       MUST NOT (specification requirement term) ..................    4
       Message Sequence Number (message attribute) ................   10
       NEW (search key) ...........................................   51
       NO (response) ..............................................   66
       NOOP (command) .............................................   25
       NOT <search-key> (search key) ..............................   52
       OK (response) ..............................................   65
       OLD (search key) ...........................................   52
       ON <date> (search key) .....................................   52
       OPTIONAL (specification requirement term) ..................    4
       OR <search-key1> <search-key2> (search key) ................   52
       PARSE (response code) ......................................   64
       PERMANENTFLAGS (response code) .............................   64
       PREAUTH (response) .........................................   67
       Permanent Flag (class of flag) .............................   12
       READ-ONLY (response code) ..................................   65
       READ-WRITE (response code) .................................   65
       RECENT (response) ..........................................   72
       RECENT (search key) ........................................   52
       RECENT (status item) .......................................   45
       RENAME (command) ...........................................   37
       REQUIRED (specification requirement term) ..................    4
       RFC822 (fetch item) ........................................   57
       RFC822 (fetch result) ......................................   78
       RFC822.HEADER (fetch item) .................................   57
       RFC822.HEADER (fetch result) ...............................   78
       RFC822.SIZE (fetch item) ...................................   57
       RFC822.SIZE (fetch result) .................................   78
       RFC822.TEXT (fetch item) ...................................   58
       RFC822.TEXT (fetch result) .................................   79
       SEARCH (command) ...........................................   49
       SEARCH (response) ..........................................   71
       SEEN (search key) ..........................................   52
       SELECT (command) ...........................................   31
       SENTBEFORE <date> (search key) .............................   52
       SENTON <date> (search key) .................................   52
       SENTSINCE <date> (search key) ..............................   52
       SHOULD (specification requirement term) ....................    4
       SHOULD NOT (specification requirement term) ................    4
       SINCE <date> (search key) ..................................   52
       SMALLER <n> (search key) ...................................   52
       STARTTLS (command) .........................................   27
       STATUS (command) ...........................................   44
       STATUS (response) ..........................................   70
       STORE (command) ............................................   58
       SUBJECT <string> (search key) ..............................   53
       SUBSCRIBE (command) ........................................   38
       Session Flag (class of flag) ...............................   12
       System Flag (type of flag) .................................   11
       TEXT (part specifier) ......................................   56
       TEXT <string> (search key) .................................   53
       TO <string> (search key) ...................................   53
       TRYCREATE (response code) ..................................   65
       UID (command) ..............................................   60
       UID (fetch item) ...........................................   58
       UID (fetch result) .........................................   79
       UID <sequence set> (search key) ............................   53
       UIDNEXT (response code) ....................................   65
       UIDNEXT (status item) ......................................   45
       UIDVALIDITY (response code) ................................   65
       UIDVALIDITY (status item) ..................................   45
       UNANSWERED (search key) ....................................   53
       UNDELETED (search key) .....................................   53
       UNDRAFT (search key) .......................................   53
       UNFLAGGED (search key) .....................................   53
       UNKEYWORD <flag> (search key) ..............................   53
       UNSEEN (response code) .....................................   65
       UNSEEN (search key) ........................................   53
       UNSEEN (status item) .......................................   45
       UNSUBSCRIBE (command) ......................................   39
       Unique Identifier (UID) (message attribute) ................    8
       X<atom> (command) ..........................................   62
       [RFC-2822] Size (message attribute) ........................   12
       \Answered (system flag) ....................................   11
       \Deleted (system flag) .....................................   11
       \Draft (system flag) .......................................   11
       \Flagged (system flag) .....................................   11
       \Marked (mailbox name attribute) ...........................   69
       \Noinferiors (mailbox name attribute) ......................   69
       \Noselect (mailbox name attribute) .........................   69
       \Recent (system flag) ......................................   11
       \Seen (system flag) ........................................   11
       \Unmarked (mailbox name attribute) .........................   69
```

---
# **Author's Address**

Mark R. Crispin Networks 및 분산 컴퓨팅 University of Washington 4545 15th Avenue NE Seattle, WA 98105-4527

```text
   Phone: (206) 543-5762

   EMail: MRC@CAC.Washington.EDU
```

---
# **Full Copyright Statement**

저작권\(C\)인터넷학회\(2003\). 판권 소유.

이 문서와 그 번역본은 복사되어 타인에게 제공될 수 있으며, 이에 대해 설명하거나 설명하거나 구현을 지원하는 파생물은 어떤 종류의 제한 없이 전체적으로 또는 부분적으로 준비, 복사, 출판 및 배포될 수 있습니다. , 단, 위의 저작권 표시와 이 단락은 그러한 모든 사본 및 파생물에 포함됩니다. 그러나 이 문서 자체는 인터넷 표준 개발 목적으로 필요한 경우를 제외하고는 저작권 표시를 제거하거나 Internet Society 또는 기타 인터넷 조직에 대한 참조를 제거하는 등 어떤 식으로든 수정할 수 없습니다. 인터넷 표준 프로세스를 따르거나 영어 이외의 언어로 번역하는 데 필요한 대로 따라야 합니다.

위에 부여된 제한된 권한은 영구적이며 Internet Society 또는 그 승계자 또는 양수인에 의해 취소되지 않습니다. v 이 문서와 여기에 포함된 정보는 "있는 그대로" 제공되며 인터넷 사회와 인터넷 엔지니어링 태스크 포스는 여기에 있는 정보의 사용에 대한 보증을 포함하되 이에 국한되지 않고 명시적이거나 묵시적인 모든 보증을 부인합니다. 특정 목적에 대한 상품성이나 적합성에 대한 어떠한 권리나 묵시적인 보증도 침해하지 않습니다.

---
# **Acknowledgement**

RFC 편집기 기능에 대한 자금은 현재 Internet Society에서 제공하고 있습니다.


```text
﻿

Internet Engineering Task Force (IETF)                   M. Thomson, Ed.
Request for Comments: 9113                                       Mozilla
Obsoletes: 7540, 8740                                   C. Benfield, Ed.
Category: Standards Track                                     Apple Inc.
ISSN: 2070-1721                                                June 2022

                                 HTTP/2
```

---
# **Abstract**

이 사양은 HTTP 버전 2\(HTTP/2\)라고 하는 HTTP\(Hypertext Transfer Protocol\) 의미론의 최적화된 표현을 설명합니다. HTTP/2는 필드 압축을 도입하고 동일한 연결에서 여러 동시 교환을 허용함으로써 네트워크 리소스를 보다 효율적으로 사용하고 대기 시간을 줄일 수 있습니다.

이 문서는 RFC 7540 및 8740을 폐기합니다.

---
# **Status of This Memo**

이것은 인터넷 표준 추적 문서입니다.

이 문서는 IETF\(Internet Engineering Task Force\)의 제품입니다. 이는 IETF 커뮤니티의 합의를 나타냅니다. 공개 검토를 받았으며 IESG\(Internet Engineering Steering Group\)의 출판 승인을 받았습니다. 인터넷 표준에 대한 자세한 내용은 RFC 7841의 섹션 2에서 확인할 수 있습니다.

이 문서의 현재 상태, 정오표 및 피드백 제공 방법에 대한 정보는 https://www.rfc-editor.org/info/rfc9113에서 얻을 수 있습니다.

---
# **Copyright Notice**

Copyright \(c\) 2022 IETF Trust 및 문서 작성자로 확인된 사람. 판권 소유.

이 문서는 이 문서의 발행일에 유효한 BCP 78 및 IETF 문서에 관한 IETF 트러스트의 법적 조항\(https://trustee.ietf.org/license-info\)의 적용을 받습니다. 이 문서와 관련된 귀하의 권리 및 제한 사항을 설명하므로 이 문서를 주의 깊게 검토하십시오. 이 문서에서 추출한 코드 구성요소는 Trust Legal Provisions의 섹션 4.e에 설명된 대로 개정된 BSD 라이센스 텍스트를 포함해야 하며 개정된 BSD 라이센스에 설명된 대로 보증 없이 제공됩니다.

---
# **Table of Contents**

```text
   1.  Introduction
   2.  HTTP/2 Protocol Overview
     2.1.  Document Organization
     2.2.  Conventions and Terminology
   3.  Starting HTTP/2
     3.1.  HTTP/2 Version Identification
     3.2.  Starting HTTP/2 for "https" URIs
     3.3.  Starting HTTP/2 with Prior Knowledge
     3.4.  HTTP/2 Connection Preface
   4.  HTTP Frames
     4.1.  Frame Format
     4.2.  Frame Size
     4.3.  Field Section Compression and Decompression
       4.3.1.  Compression State
   5.  Streams and Multiplexing
     5.1.  Stream States
       5.1.1.  Stream Identifiers
       5.1.2.  Stream Concurrency
     5.2.  Flow Control
       5.2.1.  Flow-Control Principles
       5.2.2.  Appropriate Use of Flow Control
       5.2.3.  Flow-Control Performance
     5.3.  Prioritization
       5.3.1.  Background on Priority in RFC 7540
       5.3.2.  Priority Signaling in This Document
     5.4.  Error Handling
       5.4.1.  Connection Error Handling
       5.4.2.  Stream Error Handling
       5.4.3.  Connection Termination
     5.5.  Extending HTTP/2
   6.  Frame Definitions
     6.1.  DATA
     6.2.  HEADERS
     6.3.  PRIORITY
     6.4.  RST_STREAM
     6.5.  SETTINGS
       6.5.1.  SETTINGS Format
       6.5.2.  Defined Settings
       6.5.3.  Settings Synchronization
     6.6.  PUSH_PROMISE
     6.7.  PING
     6.8.  GOAWAY
     6.9.  WINDOW_UPDATE
       6.9.1.  The Flow-Control Window
       6.9.2.  Initial Flow-Control Window Size
       6.9.3.  Reducing the Stream Window Size
     6.10. CONTINUATION
   7.  Error Codes
   8.  Expressing HTTP Semantics in HTTP/2
     8.1.  HTTP Message Framing
       8.1.1.  Malformed Messages
     8.2.  HTTP Fields
       8.2.1.  Field Validity
       8.2.2.  Connection-Specific Header Fields
       8.2.3.  Compressing the Cookie Header Field
     8.3.  HTTP Control Data
       8.3.1.  Request Pseudo-Header Fields
       8.3.2.  Response Pseudo-Header Fields
     8.4.  Server Push
       8.4.1.  Push Requests
       8.4.2.  Push Responses
     8.5.  The CONNECT Method
     8.6.  The Upgrade Header Field
     8.7.  Request Reliability
     8.8.  Examples
       8.8.1.  Simple Request
       8.8.2.  Simple Response
       8.8.3.  Complex Request
       8.8.4.  Response with Body
       8.8.5.  Informational Responses
   9.  HTTP/2 Connections
     9.1.  Connection Management
       9.1.1.  Connection Reuse
     9.2.  Use of TLS Features
       9.2.1.  TLS 1.2 Features
       9.2.2.  TLS 1.2 Cipher Suites
       9.2.3.  TLS 1.3 Features
   10. Security Considerations
     10.1.  Server Authority
     10.2.  Cross-Protocol Attacks
     10.3.  Intermediary Encapsulation Attacks
     10.4.  Cacheability of Pushed Responses
     10.5.  Denial-of-Service Considerations
       10.5.1.  Limits on Field Block Size
       10.5.2.  CONNECT Issues
     10.6.  Use of Compression
     10.7.  Use of Padding
     10.8.  Privacy Considerations
     10.9.  Remote Timing Attacks
   11. IANA Considerations
     11.1.  HTTP2-Settings Header Field Registration
     11.2.  The h2c Upgrade Token
   12. References
     12.1.  Normative References
     12.2.  Informative References
   Appendix A.  Prohibited TLS 1.2 Cipher Suites
   Appendix B.  Changes from RFC 7540
   Acknowledgments
   Contributors
   Authors' Addresses
```

---
## **1.  Introduction**

하이퍼텍스트 전송 프로토콜\(HTTP, \[HTTP\]\)을 사용하는 애플리케이션의 성능은 각 HTTP 버전이 기본 전송을 사용하는 방식과 전송이 작동하는 조건에 연결되어 있습니다.

여러 동시 요청을 하면 대기 시간을 줄이고 애플리케이션 성능을 향상시킬 수 있습니다. HTTP/1.0은 주어진 TCP\[TCP\] 연결에서 한 번에 하나의 요청만 미결 상태로 허용했습니다. HTTP/1.1\[HTTP/1.1\]은 요청 파이프라이닝을 추가했지만 이것은 요청 동시성을 부분적으로만 처리했으며 여전히 응용 프로그램 계층 헤드 오브 라인 차단 문제를 겪고 있습니다. 따라서 HTTP/1.0 및 HTTP/1.1 클라이언트는 서버에 대한 다중 연결을 사용하여 동시 요청을 만듭니다.

또한 HTTP 필드는 종종 반복적이고 장황하여 불필요한 네트워크 트래픽을 유발하고 초기 TCP 정체 기간이 빠르게 채워지게 합니다. 이로 인해 새 TCP 연결에서 여러 요청이 생성될 때 과도한 대기 시간이 발생할 수 있습니다.

HTTP/2는 기본 연결에 대한 HTTP 의미 체계의 최적화된 매핑을 정의하여 이러한 문제를 해결합니다. 특히 동일한 연결에서 메시지 인터리빙을 허용하고 HTTP 필드에 효율적인 코딩을 사용합니다. 또한 요청의 우선 순위를 지정하여 더 중요한 요청을 더 빨리 완료할 수 있도록 하여 성능을 더욱 향상시킵니다.

결과 프로토콜은 HTTP/1.x에 비해 더 적은 TCP 연결을 사용할 수 있기 때문에 네트워크에 더 친숙합니다. 이것은 다른 흐름과의 경쟁이 적고 수명이 긴 연결을 의미하므로 사용 가능한 네트워크 용량을 더 잘 활용할 수 있습니다. 그러나 TCP HOL\(head-of-line\) 차단은 이 프로토콜에서 다루지 않습니다.

마지막으로 HTTP/2는 바이너리 메시지 프레이밍을 사용하여 보다 효율적인 메시지 처리를 가능하게 합니다.

이 문서는 RFC 7540 및 8740을 폐기합니다. 부록 B에는 주목할 만한 변경 사항이 나열되어 있습니다.

---
## **2.  HTTP/2 Protocol Overview**

HTTP/2는 HTTP 의미 체계에 최적화된 전송을 제공합니다. HTTP/2는 HTTP의 모든 핵심 기능을 지원하지만 HTTP/1.1보다 더 효율적인 것을 목표로 합니다.

HTTP/2는 TCP 연결\(\[TCP\]\)을 통해 실행되는 연결 지향 애플리케이션 계층 프로토콜입니다. 클라이언트는 TCP 연결 개시자입니다.

HTTP/2의 기본 프로토콜 단위는 프레임입니다\(4.1절\). 각 프레임 유형은 다른 용도로 사용됩니다. 예를 들어, HEADERS 및 DATA 프레임은 HTTP 요청 및 응답의 기초를 형성합니다\(섹션 8.1\). SETTINGS, WINDOW\_UPDATE 및 PUSH\_PROMISE와 같은 다른 프레임 유형은 다른 HTTP/2 기능을 지원하는 데 사용됩니다.

요청의 다중화는 자체 스트림과 연결된 각 HTTP 요청/응답 교환을 가짐으로써 달성됩니다\(섹션 5\). 스트림은 대체로 서로 독립적이므로 차단되거나 중단된 요청 또는 응답이 다른 스트림의 진행을 방해하지 않습니다.

다중화의 효과적인 사용은 흐름 제어 및 우선 순위 지정에 따라 달라집니다. 흐름 제어\(섹션 5.2\)는 전송되는 데이터를 수신자가 처리할 수 있는 것으로 제한하여 다중화된 스트림을 효율적으로 사용할 수 있도록 합니다. 우선 순위 지정\(섹션 5.3\)은 제한된 리소스를 가장 효과적으로 사용하도록 합니다. 이 HTTP/2 개정판은 \[RFC7540\]의 우선 순위 신호 체계를 더 이상 사용하지 않습니다.

연결에 사용되는 HTTP 필드에는 많은 양의 중복 데이터가 포함될 수 있으므로 이를 포함하는 프레임은 압축됩니다\(섹션 4.3\). 이는 일반적인 경우 요청 크기에 특히 유리한 영향을 미치므로 많은 요청을 하나의 패킷으로 압축할 수 있습니다.

마지막으로 HTTP/2는 서버가 클라이언트에 응답을 푸시할 수 있는 새로운 선택적 상호 작용 모드를 추가합니다\(섹션 8.4\). 이는 서버가 클라이언트가 필요로 할 것으로 예상하는 데이터를 추측에 따라 클라이언트에 보낼 수 있도록 하여 일부 네트워크 사용량을 잠재적 대기 시간 증가와 교환할 수 있도록 하기 위한 것입니다. 서버는 PUSH\_PROMISE 프레임으로 보내는 요청을 합성하여 이를 수행합니다. 그런 다음 서버는 별도의 스트림에서 합성 요청에 대한 응답을 보낼 수 있습니다.

---
### **2.1.  Document Organization**

HTTP/2 사양은 네 부분으로 나뉩니다.

\* HTTP/2 시작\(섹션 3\)에서는 HTTP/2 연결이 시작되는 방법을 다룹니다.

\* 프레임\(섹션 4\) 및 스트림\(섹션 5\) 계층은 HTTP/2 프레임이 구조화되고 다중화된 스트림으로 형성되는 방식을 설명합니다.

\* 프레임\(섹션 6\) 및 오류\(섹션 7\) 정의에는 HTTP/2에서 사용되는 프레임 및 오류 유형에 대한 세부 정보가 포함됩니다.

\* HTTP 매핑\(섹션 8\) 및 추가 요구 사항\(섹션 9\)은 프레임과 스트림을 사용하여 HTTP 의미 체계를 표현하는 방법을 설명합니다.

일부 프레임 및 스트림 계층 개념은 HTTP와 분리되어 있지만 이 사양은 완전히 일반적인 프레임 계층을 정의하지 않습니다. 프레임 및 스트림 계층은 HTTP의 요구에 맞게 조정됩니다.

---
### **2.2.  Conventions and Terminology**

키워드 "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY" 및 "OPTIONAL" "는 BCP 14 \[RFC2119\] \[RFC8174\]에 설명된 대로 여기에 표시된 것처럼 모두 대문자로 표시되는 경우에만 해석됩니다.\(MUST NOT\)

모든 숫자 값은 네트워크 바이트 순서입니다. 달리 명시되지 않는 한 값은 부호가 없습니다. 리터럴 값은 적절하게 10진수 또는 16진수로 제공됩니다. 16진수 리터럴은 10진수 리터럴과 구별하기 위해 접두사 "0x"가 붙습니다.

이 사양은 RFC 9000\[QUIC\]의 섹션 1.3에 설명된 규칙을 사용하여 이진 형식을 설명합니다. 이 형식은 네트워크 바이트 순서를 사용하며 높은 값의 비트는 낮은 값의 비트 앞에 나열됩니다.

다음 용어가 사용됩니다.

클라이언트: HTTP/2 연결을 시작하는 끝점입니다. 클라이언트는 HTTP 요청을 보내고 HTTP 응답을 받습니다.

연결: 두 끝점 간의 전송 계층 연결입니다.

연결 오류: 전체 HTTP/2에 영향을 미치는 오류

-  연결.

끝점: 연결의 클라이언트 또는 서버입니다.

프레임: HTTP/2 내에서 가장 작은 통신 단위

- 헤더와 프레임 유형에 따라 구조화된 옥텟의 가변 길이 시퀀스로 구성된 연결.

피어: 끝점입니다. 특정 엔드포인트를 논의할 때 "피어"는 논의의 기본 주제에 대해 원격인 엔드포인트를 나타냅니다.

수신기: 프레임을 수신하는 끝점입니다.

보낸 사람: 프레임을 전송하는 끝점입니다.

서버: HTTP/2 연결을 수락하는 끝점입니다. 서버는 HTTP 요청을 받고 HTTP 응답을 보냅니다.

스트림: HTTP/2 연결 내에서 프레임의 양방향 흐름입니다.

스트림 오류: 개별 HTTP/2 스트림의 오류입니다.

마지막으로 "게이트웨이", "중개자", "프록시" 및 "터널"이라는 용어는 \[HTTP\]의 섹션 3.7에 정의되어 있습니다. 중개자는 서로 다른 시간에 클라이언트와 서버 역할을 모두 수행합니다.

메시지 본문에 적용되는 "내용"이라는 용어는 \[HTTP\]의 섹션 6.4에 정의되어 있습니다.

---
## **3.  Starting HTTP/2**

HTTP 요청을 생성하는 구현은 서버가 HTTP/2를 지원하는지 여부를 검색해야 합니다.

HTTP/2는 \[HTTP\]의 섹션 4.2에 정의된 "http" 및 "https" URI 체계를 사용하며 HTTP/1.1 \[HTTP/1.1\]과 동일한 기본 포트 번호를 사용합니다. 이러한 URI에는 업스트림 서버\(클라이언트가 연결을 설정하려는 직접 피어\)가 지원하는 HTTP 버전에 대한 표시가 포함되어 있지 않습니다.

HTTP/2에 대한 지원을 결정하는 방법은 "http" 및 "https" URI에 따라 다릅니다. "https" URI에 대한 검색은 섹션 3.2에 설명되어 있습니다. "http" URI에 대한 HTTP/2 지원은 대역 외 수단으로만 검색할 수 있으며 섹션 3.3에 설명된 지원에 대한 사전 지식이 필요합니다.

---
### **3.1.  HTTP/2 Version Identification**

이 문서에 정의된 프로토콜에는 두 개의 식별자가 있습니다. 둘 중 하나를 기반으로 연결을 생성한다는 것은 이 문서에 설명된 전송, 프레이밍 및 메시지 의미 체계의 사용을 의미합니다.

\* 문자열 "h2"는 HTTP/2가 사용하는 프로토콜을 식별합니다.

- 전송 계층 보안\(TLS\) 섹션 9.2를 참조하십시오. 이 식별자는 TLS ALPN\(Application-Layer Protocol Negotiation\) 확장 \[TLS-ALPN\] 필드와 TLS를 통한 HTTP/2가 식별되는 모든 위치에서 사용됩니다.

- "h2" 문자열은 ALPN 프로토콜 식별자로 2옥텟 시퀀스\(0x68, 0x32\)로 직렬화됩니다.

\* "h2c" 문자열은 이전에 HTTP 업그레이드 메커니즘의 업그레이드 헤더 필드\(\[HTTP\]의 섹션 7.8\)에서 사용하기 위한 토큰으로 사용되었습니다. 이 사용법은 널리 배포된 적이 없으며 이 문서에서 더 이상 사용되지 않습니다. "h2c"로의 업그레이드와 함께 사용된 HTTP2-Settings 헤더 필드에도 동일하게 적용됩니다.

---
### **3.2.  Starting HTTP/2 for "https" URIs**

"https" URI에 요청하는 클라이언트는 ALPN 확장자\[TLS-ALPN\]와 함께 TLS\[TLS13\]를 사용합니다.

TLS를 통한 HTTP/2는 "h2" 프로토콜 식별자를 사용합니다. "h2c" 프로토콜 식별자는 클라이언트가 보내거나 서버가 선택해서는 안 됩니다. "h2c" 프로토콜 식별자는 TLS를 사용하지 않는 프로토콜을 나타냅니다.\(MUST NOT\)

TLS 협상이 완료되면 클라이언트와 서버 모두 연결 서문을 보내야 합니다\(섹션 3.4\).\(MUST\)

---
### **3.3.  Starting HTTP/2 with Prior Knowledge**

클라이언트는 특정 서버가 다른 방법으로 HTTP/2를 지원한다는 것을 알 수 있습니다. 예를 들어, 서버가 HTTP/2를 지원한다는 사실을 알고 클라이언트를 구성할 수 있습니다.

서버가 HTTP/2를 지원한다는 것을 알고 있는 클라이언트는 TCP 연결을 설정하고 연결 서문\(섹션 3.4\)과 HTTP/2 프레임을 보낼 수 있습니다. 서버는 연결 서문의 존재로 이러한 연결을 식별할 수 있습니다. 이는 일반 텍스트 TCP를 통한 HTTP/2 연결 설정에만 영향을 미칩니다. TLS를 통한 HTTP/2 연결은 TLS\[TLS-ALPN\]에서 프로토콜 협상을 사용해야 합니다.\(MUST\)

마찬가지로 서버는 연결 서문을 보내야 합니다\(섹션 3.4\).\(MUST\)

추가 정보가 없다면 HTTP/2에 대한 사전 지원은 해당 서버가 향후 연결을 위해 HTTP/2를 지원할 것이라는 강력한 신호가 아닙니다. 예를 들어 서버 구성이 변경되거나, 클러스터링된 서버의 인스턴스 간에 구성이 달라지거나, 네트워크 조건이 변경될 수 있습니다.

---
### **3.4.  HTTP/2 Connection Preface**

HTTP/2에서 각 끝점은 사용 중인 프로토콜의 최종 확인으로 연결 서문을 보내고 HTTP/2 연결에 대한 초기 설정을 설정해야 합니다. 클라이언트와 서버는 각각 다른 연결 서문을 보냅니다.

클라이언트 연결 서문은 24옥텟 시퀀스로 시작하며 16진 표기법은 다음과 같습니다.

```text
     0x505249202a20485454502f322e300d0a0d0a534d0d0a0d0a
```

즉, 연결 서문은 "PRI \* HTTP/2.0\r\n\r\nSM\r\n\r\n" 문자열로 시작합니다. 이 시퀀스 뒤에는 비어 있을 수 있는 SETTINGS 프레임\(섹션 6.5\)이 뒤따라야 합니다. 클라이언트는 연결의 첫 번째 응용 프로그램 데이터 옥텟으로 클라이언트 연결 서문을 보냅니다.\(MUST\)

- | 참고: 클라이언트 연결 서문은 큰 | HTTP/1.1 또는 HTTP/1.0 서버 및 중개자의 비율 | 추가 프레임 처리를 시도하지 마십시오. 이것은 | \[TALKING\]에서 제기된 문제를 해결하지 않습니다.

서버 연결 서문은 HTTP/2 연결에서 서버가 보내는 첫 번째 프레임이어야 하는 잠재적으로 비어 있는 SETTINGS 프레임\(섹션 6.5\)으로 구성됩니다.\(MUST\)

연결 서문의 일부로 피어로부터 수신한 SETTINGS 프레임은 연결 서문을 보낸 후 승인되어야 합니다\(섹션 6.5.3 참조\).\(MUST\)

불필요한 대기 시간을 피하기 위해 클라이언트는 서버 연결 서문을 받을 때까지 기다리지 않고 클라이언트 연결 서문을 보낸 직후 서버에 추가 프레임을 보낼 수 있습니다. 그러나 서버 연결 서문 SETTINGS 프레임에는 클라이언트가 서버와 통신하는 방법을 반드시 변경하는 설정이 포함될 수 있다는 점에 유의해야 합니다. SETTINGS 프레임을 수신하면 클라이언트는 설정된 모든 설정을 존중해야 합니다. 일부 구성에서는 클라이언트가 추가 프레임을 보내기 전에 서버가 SETTINGS를 전송하여 이 문제를 피할 수 있는 기회를 제공할 수 있습니다.

클라이언트와 서버는 잘못된 연결 서문을 PROTOCOL\_ERROR 유형의 연결 오류\(섹션 5.4.1\)로 처리해야 합니다. GOAWAY 프레임\(섹션 6.8\)은 피어가 HTTP/2를 사용하지 않는다는 잘못된 서문을 나타내므로 이 경우 생략될 수 있습니다.\(MUST, MAY\)

---
## **4.  HTTP Frames**

HTTP/2 연결이 설정되면 끝점에서 프레임 교환을 시작할 수 있습니다.

---
### **4.1.  Frame Format**

모든 프레임은 고정된 9옥텟 헤더와 가변 길이 프레임 페이로드로 시작됩니다.

```text
   HTTP Frame {
     Length (24),
     Type (8),

     Flags (8),

     Reserved (1),
     Stream Identifier (31),

     Frame Payload (..),
   }

                           Figure 1: Frame Layout
```

프레임 헤더의 필드는 다음과 같이 정의됩니다.

길이: 옥텟 단위의 부호 없는 24비트 정수로 표현되는 프레임 페이로드의 길이. 2^14\(16,384\)보다 큰 값은 수신자가 SETTINGS\_MAX\_FRAME\_SIZE에 대해 더 큰 값을 설정하지 않는 한 보내서는 안 됩니다\(MUST NOT\).\(MUST NOT\)

- 프레임 헤더의 9 옥텟은 이 값에 포함되지 않습니다.

유형: 프레임의 8비트 유형입니다. 프레임 유형은 프레임의 형식과 의미를 결정합니다. 이 문서에 정의된 프레임은 섹션 6에 나열되어 있습니다. 구현은 알 수 없는 유형의 프레임을 무시하고 폐기해야 합니다.\(MUST\)

플래그: 프레임 유형에 특정한 부울 플래그용으로 예약된 8비트 필드입니다.

- 플래그는 표시된 프레임 유형에 특정한 시맨틱이 할당됩니다. 미사용 플래그는 특정 프레임 유형에 대해 정의된 의미 체계가 없는 플래그입니다. 미사용 플래그는 수신 시 무시해야 하며 보낼 때 설정하지 않은 상태\(0x00\)로 두어야 합니다.\(MUST\)

예약됨: 예약된 1비트 필드입니다. 이 비트의 의미는 정의되지 않았으며 비트는 전송 시 설정되지 않은 상태\(0x00\)로 유지되어야 하며 수신 시 무시되어야 합니다.\(MUST\)

스트림 식별자: 부호 없는 31비트 정수로 표현되는 스트림 식별자\(섹션 5.1.1 참조\). 값 0x00은 개별 스트림이 아닌 전체 연결과 관련된 프레임용으로 예약되어 있습니다.

프레임 페이로드의 구조와 내용은 전적으로 프레임 유형에 따라 다릅니다.

---
### **4.2.  Frame Size**

프레임 페이로드의 크기는 수신기가 SETTINGS\_MAX\_FRAME\_SIZE 설정에서 알리는 최대 크기로 제한됩니다. 이 설정은 2^14\(16,384\)에서 2^24-1\(16,777,215\) 옥텟 사이의 값을 가질 수 있습니다.

모든 구현은 최대 2^14 옥텟 길이의 프레임과 9 옥텟 프레임 헤더\(섹션 4.1\)를 수신하고 최소한으로 처리할 수 있어야 합니다\(MUST\). 프레임 크기를 설명할 때 프레임 헤더의 크기는 포함되지 않습니다.\(MUST\)

- | 참고: PING\(섹션 6.7\)과 같은 특정 프레임 유형은 | 허용되는 프레임 페이로드 데이터 양에 대한 추가 제한.

프레임이 SETTINGS\_MAX\_FRAME\_SIZE에 정의된 크기를 초과하거나, 프레임 유형에 대해 정의된 제한을 초과하거나, 필수 프레임 데이터를 포함하기에 너무 작은 경우 엔드포인트는 FRAME\_SIZE\_ERROR의 오류 코드를 보내야 합니다\(MUST\). 전체 연결 상태를 변경할 수 있는 프레임의 프레임 크기 오류는 연결 오류로 취급되어야 합니다\(섹션 5.4.1\). 여기에는 필드 블록\(섹션 4.3\)\(즉, HEADERS, PUSH\_PROMISE 및 CONTINUATION\)을 전달하는 모든 프레임, SETTINGS 프레임 및 스트림 식별자가 0인 모든 프레임이 포함됩니다.\(MUST, MUST\)

끝점은 프레임에서 사용 가능한 모든 공간을 사용할 의무가 없습니다. 허용된 최대 크기보다 작은 프레임을 사용하여 응답성을 향상시킬 수 있습니다. 큰 프레임을 보내면 시간에 민감한 프레임\(예: RST\_STREAM, WINDOW\_UPDATE 또는 PRIORITY\)을 보내는 데 지연이 발생할 수 있으며, 큰 프레임의 전송에 의해 차단되면 성능에 영향을 미칠 수 있습니다.

---
### **4.3.  Field Section Compression and Decompression**

필드 섹션 압축은 필드 블록을 형성하기 위해 일련의 필드 라인\(\[HTTP\]의 섹션 5.2\)을 압축하는 프로세스입니다. 필드 섹션 압축 해제는 필드 블록을 일련의 필드 라인으로 디코딩하는 프로세스입니다. HTTP/2 필드 섹션 압축 및 압축 해제에 대한 자세한 내용은 \[COMPRESSION\]에 정의되어 있으며 역사적 이유로 이러한 프로세스를 헤더 압축 및 압축 해제라고 합니다.

각 필드 블록은 단일 필드 섹션의 모든 압축된 필드 라인을 전달합니다. 헤더 섹션에는 필드 라인과 동일한 형식을 사용하는 의사 헤더 필드\(섹션 8.3\)의 형태로 메시지와 관련된 제어 데이터도 포함됩니다.

- | 참고: RFC 7540\[RFC7540\]에서는 "헤더 블록"이라는 용어를 사용했습니다. | 보다 일반적인 "필드 블록"의

필드 블록은 요청, 응답, 약속된 요청 및 푸시된 응답에 대한 제어 데이터 및 헤더 섹션을 전달합니다\(섹션 8.4 참조\). PUSH\_PROMISE\(섹션 6.6\) 프레임에 포함된 중간 응답 및 요청을 제외한 모든 메시지는 트레일러 섹션을 전달하는 필드 블록을 선택적으로 포함할 수 있습니다.

필드 섹션은 필드 라인의 모음입니다. 필드 블록의 각 필드 라인은 단일 값을 전달합니다. 그런 다음 직렬화된 필드 블록은 필드 블록 조각이라고 하는 하나 이상의 옥텟 시퀀스로 나뉩니다. 첫 번째 필드 블록 조각은 HEADERS\(섹션 6.2\) 또는 PUSH\_PROMISE\(섹션 6.6\)의 프레임 페이로드 내에서 전송되며, 각 프레임 뒤에는 후속 필드 블록 조각을 전달하기 위한 CONTINUATION\(섹션 6.10\) 프레임이 뒤따를 수 있습니다.

쿠키 헤더 필드\[COOKIE\]는 HTTP 매핑에 의해 특별히 처리됩니다\(섹션 8.2.3 참조\).

수신 엔드포인트는 조각을 연결하여 필드 블록을 재조립한 다음 블록을 압축 해제하여 필드 섹션을 재구성합니다.

전체 필드 섹션은 다음 중 하나로 구성됩니다.

\* END\_HEADERS 플래그가 설정된 단일 HEADERS 또는 PUSH\_PROMISE 프레임, 또는

\* END\_HEADERS 플래그가 설정되지 않은 HEADERS 또는 PUSH\_PROMISE 프레임과 하나 이상의 CONTINUATION 프레임\(마지막 CONTINUATION 프레임에 END\_HEADERS 플래그가 설정됨\).

각 필드 블록은 개별 단위로 처리됩니다. 필드 블록은 연속적인 프레임 시퀀스로 전송되어야 하며, 다른 유형이나 다른 스트림의 인터리브 프레임이 없어야 합니다. HEADERS 또는 CONTINUATION 프레임 시퀀스의 마지막 프레임에는 END\_HEADERS 플래그가 설정되어 있습니다. PUSH\_PROMISE 또는 CONTINUATION 프레임 시퀀스의 마지막 프레임에는 END\_HEADERS 플래그가 설정되어 있습니다. 이를 통해 필드 블록이 단일 프레임과 논리적으로 동일할 수 있습니다.\(MUST\)

필드 블록 조각은 HEADERS, PUSH\_PROMISE 또는 CONTINUATION 프레임의 프레임 페이로드로만 보낼 수 있습니다. 이러한 프레임은 수신자가 유지 관리하는 압축 컨텍스트를 수정할 수 있는 데이터를 전달하기 때문입니다. HEADERS, PUSH\_PROMISE 또는 CONTINUATION 프레임을 수신하는 엔드포인트는 프레임을 폐기해야 하는 경우에도 필드 블록을 재조립하고 압축 해제를 수행해야 합니다. 수신자는 필드 블록을 압축 해제하지 않으면 COMPRESSION\_ERROR 유형의 연결 오류\(섹션 5.4.1\)로 연결을 종료해야 합니다.\(MUST\)

필드 블록의 디코딩 오류는 COMPRESSION\_ERROR 유형의 연결 오류\(섹션 5.4.1\)로 처리되어야 합니다.\(MUST\)

---
#### **4.3.1.  Compression State**

필드 압축은 상태 저장입니다. 각 끝점에는 연결의 모든 필드 블록을 인코딩 및 디코딩하는 데 사용되는 HPACK 인코더 컨텍스트 및 HPACK 디코더 컨텍스트가 있습니다. \[COMPRESSION\]의 섹션 4는 각 컨텍스트의 기본 상태인 동적 테이블을 정의합니다.

동적 테이블에는 HPACK 디코더에서 설정한 최대 크기가 있습니다. 끝점은 SETTINGS\_HEADER\_TABLE\_SIZE 설정을 사용하여 HPACK 디코더 컨텍스트에서 선택한 크기를 전달합니다. 섹션 6.5.2를 참조하십시오. 연결이 설정되면 두 끝점에서 HPACK 디코더 및 인코더의 동적 테이블 크기는 SETTINGS\_HEADER\_TABLE\_SIZE 설정의 초기 값인 4,096바이트에서 시작합니다.

SETTINGS\_HEADER\_TABLE\_SIZE를 사용하여 설정된 최대값에 대한 모든 변경 사항은 엔드포인트가 설정을 승인할 때 적용됩니다\(섹션 6.5.3\). 해당 엔드포인트의 HPACK 인코더는 동적 테이블을 디코더가 설정한 최대값까지 모든 크기로 설정할 수 있습니다. HPACK 인코더는 동적 테이블 크기 업데이트 명령\(\[COMPRESSION\]의 섹션 6.3\)으로 동적 테이블의 크기를 선언합니다.

엔드포인트가 동적 테이블의 현재 크기 이하로 최대값을 줄이는 SETTINGS\_HEADER\_TABLE\_SIZE에 대한 변경을 확인하면 HPACK 인코더는 동적 테이블을 다음 크기보다 작은 크기로 설정하는 동적 테이블 크기 업데이트 명령으로 다음 필드 블록을 시작해야 합니다. 감소된 최대값과 같음; \[압축\]의 섹션 4.2를 참조하십시오. 종점은 일치하는 동적 테이블 크기 업데이트 명령으로 시작하지 않는 경우 COMPRESSION\_ERROR 유형의 연결 오류\(섹션 5.4.1\)로 최대 동적 테이블 크기 감소에 대한 승인을 따르는 필드 블록을 처리해야 합니다\(MUST\).\(MUST, MUST\)

| 구현자는

- | SETTINGS\_HEADER\_TABLE\_SIZE는 광범위하게 상호 운용되지 않습니다. 사용 | 초기 | 값 4,096이 다소 더 잘 지원되지만 | 일부 구현에서는 실패합니다.

---
## **5.  Streams and Multiplexing**

"스트림"은 HTTP/2 연결 내에서 클라이언트와 서버 간에 교환되는 독립적인 양방향 프레임 시퀀스입니다. 스트림에는 몇 가지 중요한 특성이 있습니다.

\* 단일 HTTP/2 연결은 여러 스트림의 프레임을 인터리빙하는 엔드포인트와 함께 여러 개의 동시에 열린 스트림을 포함할 수 있습니다.

\* 스트림은 일방적으로 설정 및 사용하거나 양쪽 끝점에서 공유할 수 있습니다.

\* 스트림은 양쪽 끝점에서 닫힐 수 있습니다.

\* 프레임이 전송되는 순서가 중요합니다. 수신자는 수신된 순서대로 프레임을 처리합니다. 특히 HEADERS와 DATA 프레임의 순서는 의미론적으로 중요하다.

\* 스트림은 정수로 식별됩니다. 스트림 식별자는 스트림을 시작하는 엔드포인트에 의해 스트림에 할당됩니다.

---
### **5.1.  Stream States**

스트림의 수명 주기는 그림 2에 나와 있습니다.

```text
                                +--------+
                        send PP |        | recv PP
                       ,--------+  idle  +--------.
                      /         |        |         \
                     v          +--------+          v
              +----------+          |           +----------+
              |          |          | send H /  |          |
       ,------+ reserved |          | recv H    | reserved +------.
       |      | (local)  |          |           | (remote) |      |
       |      +---+------+          v           +------+---+      |
       |          |             +--------+             |          |
       |          |     recv ES |        | send ES     |          |
       |   send H |     ,-------+  open  +-------.     | recv H   |
       |          |    /        |        |        \    |          |
       |          v   v         +---+----+         v   v          |
       |      +----------+          |           +----------+      |
       |      |   half-  |          |           |   half-  |      |
       |      |  closed  |          | send R /  |  closed  |      |
       |      | (remote) |          | recv R    | (local)  |      |
       |      +----+-----+          |           +-----+----+      |
       |           |                |                 |           |
       |           | send ES /      |       recv ES / |           |
       |           |  send R /      v        send R / |           |
       |           |  recv R    +--------+   recv R   |           |
       | send R /  `----------->|        |<-----------'  send R / |
       | recv R                 | closed |               recv R   |
       `----------------------->|        |<-----------------------'
                                +--------+

                          Figure 2: Stream States
```

보내기: 엔드포인트가 이 프레임을 보냅니다. recv: 엔드포인트가 이 프레임을 받습니다. H: HEADERS 프레임\(내포된 CONTINUATION 프레임 포함\) ES: END\_STREAM 플래그 R: RST\_STREAM 프레임 PP: PUSH\_PROMISE 프레임\(내포된 CONTINUATION 프레임 포함\); 상태 전환은 약속된 스트림을 위한 것입니다.

이 다이어그램은 스트림 상태 전환과 이러한 전환에만 영향을 미치는 프레임 및 플래그를 보여줍니다. 이와 관련하여 CONTINUATION 프레임은 상태 전환을 초래하지 않습니다. 그들은 사실상 그들이 따르는 HEADERS 또는 PUSH\_PROMISE의 일부입니다. 상태 전환을 위해 END\_STREAM 플래그는 이를 포함하는 프레임에 대한 별도의 이벤트로 처리됩니다. END\_STREAM 플래그가 설정된 HEADERS 프레임은 두 가지 상태 전환을 유발할 수 있습니다.

두 끝점에는 프레임이 전송 중일 때 다를 수 있는 스트림 상태에 대한 주관적인 보기가 있습니다. 끝점은 스트림 생성을 조정하지 않습니다. 끝점 중 하나에 의해 일방적으로 생성됩니다. 상태 불일치의 부정적인 결과는 RST\_STREAM을 보낸 후 "닫힌" 상태로 제한되며, 여기서 프레임은 닫힌 후 얼마 동안 수신될 수 있습니다.

스트림의 상태는 다음과 같습니다.

유휴: 모든 스트림이 "유휴" 상태에서 시작됩니다.

- 이 상태에서 다음 전환이 유효합니다.

- \* HEADERS 프레임을 클라이언트로 전송하거나 HEADERS 프레임을 서버로 수신하면 스트림이 "개방"됩니다. 스트림 식별자는 섹션 5.1.1에 설명된 대로 선택됩니다. 동일한 HEADERS 프레임으로 인해 스트림이 즉시 "절반 폐쇄"될 수도 있습니다.

- \* 다른 스트림에서 PUSH\_PROMISE 프레임을 전송하면 나중에 사용하기 위해 식별된 유휴 스트림이 예약됩니다. 예약된 스트림의 스트림 상태가 "예약됨\(로컬\)"으로 전환됩니다. 서버만 PUSH\_PROMISE 프레임을 보낼 수 있습니다.

- \* 다른 스트림에서 PUSH\_PROMISE 프레임을 수신하면 나중에 사용하기 위해 식별되는 유휴 스트림을 예약합니다. 예약된 스트림의 스트림 상태가 "예약됨\(원격\)"으로 전환됩니다. 클라이언트만 PUSH\_PROMISE 프레임을 수신할 수 있습니다.

- \* PUSH\_PROMISE 프레임은 유휴 스트림에서 전송되지 않지만 Promised Stream ID 필드에서 새로 예약된 스트림을 참조합니다.

- \* 더 높은 값의 스트림 식별자로 스트림을 열면 스트림이 즉시 "닫힌" 상태로 전환됩니다. 이 전환은 다이어그램에 표시되지 않습니다.

- 이 상태의 스트림에서 HEADERS 또는 PRIORITY 이외의 프레임을 수신하면 PROTOCOL\_ERROR 유형의 연결 오류\(섹션 5.4.1\)로 처리해야 합니다. 이 스트림이 5.1.1절에 설명된 대로 서버에 의해 시작되면 HEADERS 프레임 수신도 PROTOCOL\_ERROR 유형의 연결 오류\(5.4.1절\)로 처리되어야 합니다.\(MUST, MUST\)

reserved\(local\): "reserved\(local\)" 상태의 스트림은 PUSH\_PROMISE 프레임을 전송하여 약속된 스트림입니다. PUSH\_PROMISE 프레임은 스트림을 원격 피어에 의해 시작된 오픈 스트림과 연결하여 유휴 스트림을 예약합니다\(섹션 8.4 참조\).

- 이 상태에서는 다음 전환만 가능합니다.

- \* 엔드포인트는 HEADERS 프레임을 보낼 수 있습니다. 이로 인해 스트림이 "반쯤 닫힌\(원격\)" 상태로 열립니다.

- \* 어느 끝점이든 RST\_STREAM 프레임을 보내 스트림을 "닫히게" 할 수 있습니다. 이렇게 하면 스트림 예약이 해제됩니다.

- 엔드포인트는 이 상태에서 HEADERS, RST\_STREAM 또는 PRIORITY 이외의 프레임 유형을 보내면 안 됩니다\(MUST NOT\).\(MUST NOT\)

- 이 상태에서 PRIORITY 또는 WINDOW\_UPDATE 프레임이 수신될 수 있습니다. 이 상태의 스트림에서 RST\_STREAM, PRIORITY 또는 WINDOW\_UPDATE 이외의 프레임 유형을 수신하면 PROTOCOL\_ERROR 유형의 연결 오류\(섹션 5.4.1\)로 처리해야 합니다.\(MAY, MUST\)

reserved\(remote\): "reserved\(remote\)" 상태의 스트림은 원격 피어에 의해 예약되었습니다.

- 이 상태에서는 다음 전환만 가능합니다.

- \* HEADERS 프레임을 수신하면 스트림이 "반 폐쇄\(로컬\)"로 전환됩니다.

- \* 어느 끝점이든 RST\_STREAM 프레임을 보내 스트림을 "닫히게" 할 수 있습니다. 이렇게 하면 스트림 예약이 해제됩니다.

- 엔드포인트는 이 상태에서 RST\_STREAM, WINDOW\_UPDATE 또는 PRIORITY 이외의 프레임 유형을 보내면 안 됩니다\(MUST NOT\).\(MUST NOT\)

- 이 상태의 스트림에서 HEADERS, RST\_STREAM 또는 PRIORITY 이외의 프레임 유형을 수신하면 PROTOCOL\_ERROR 유형의 연결 오류\(섹션 5.4.1\)로 처리해야 합니다.\(MUST\)

open: "open" 상태의 스트림은 모든 유형의 프레임을 전송하기 위해 두 피어 모두에서 사용할 수 있습니다. 이 상태에서 보내는 피어는 알려진 스트림 수준 흐름 제어 제한\(섹션 5.2\)을 준수합니다.

이 상태에서 두 엔드포인트는 다음과 같은 프레임을 보낼 수 있습니다.

- END\_STREAM 플래그가 설정되어 스트림이 "절반 폐쇄" 상태 중 하나로 전환됩니다. END\_STREAM 플래그를 보내는 엔드포인트는 스트림 상태를 "반 폐쇄\(로컬\)"로 만듭니다. END\_STREAM 플래그를 수신하는 엔드포인트는 스트림 상태를 "반쯤 닫힘\(원격\)"으로 만듭니다.

- 두 끝점 중 하나가 이 상태에서 RST\_STREAM 프레임을 보낼 수 있으므로 즉시 "닫힘" 상태로 전환됩니다.

반 폐쇄\(로컬\): "반 폐쇄\(로컬\)" 상태인 스트림은 WINDOW\_UPDATE, PRIORITY 및 RST\_STREAM 이외의 프레임 전송에 사용할 수 없습니다.

- END\_STREAM 플래그가 설정된 프레임이 수신되거나 피어가 RST\_STREAM 프레임을 보낼 때 스트림이 이 상태에서 "닫힘"으로 전환됩니다.

엔드포인트는 이 상태에서 모든 유형의 프레임을 수신할 수 있습니다.

- 흐름 제어 프레임을 계속 수신하려면 WINDOW\_UPDATE 프레임을 사용하여 흐름 제어 크레딧을 제공해야 합니다. 이 상태에서 수신자는 END\_STREAM 플래그가 설정된 프레임이 전송된 후 짧은 기간 동안 도착할 수 있는 WINDOW\_UPDATE 프레임을 무시할 수 있습니다.

- 이 상태에서 PRIORITY 프레임을 수신할 수 있습니다.

반 폐쇄\(원격\): "반 폐쇄\(원격\)"인 스트림은 더 이상 피어에서 프레임을 전송하는 데 사용되지 않습니다. 이 상태에서 엔드포인트는 더 이상 수신기 흐름 제어 창을 유지할 의무가 없습니다.

끝점에서 이외의 추가 프레임을 수신하는 경우

- 이 상태에 있는 스트림의 경우 WINDOW\_UPDATE, PRIORITY 또는 RST\_STREAM은 STREAM\_CLOSED 유형의 스트림 오류\(섹션 5.4.2\)로 응답해야 합니다.\(MUST\)

- "반 폐쇄\(원격\)"인 스트림은 엔드포인트에서 모든 유형의 프레임을 보내는 데 사용할 수 있습니다. 이 상태에서 끝점은 알려진 스트림 수준 흐름 제어 제한\(섹션 5.2\)을 계속 관찰합니다.

- 스트림은 END\_STREAM 플래그가 설정된 프레임을 보내거나 피어가 RST\_STREAM 프레임을 보낼 때 이 상태에서 "닫힘" 상태로 전환할 수 있습니다.

닫힘: "닫힘" 상태는 최종 상태입니다.

- 엔드포인트가 END\_STREAM 플래그가 설정된 프레임을 보내고 받은 후 스트림이 "닫힌" 상태로 들어갑니다. 끝점이 RST\_STREAM 프레임을 보내거나 받은 후에도 스트림은 "닫힌" 상태로 들어갑니다.

- 끝점은 닫힌 스트림에서 PRIORITY 이외의 프레임을 보내면 안 됩니다. 끝점은 닫힌 스트림에서 다른 유형의 프레임 수신을 아래에 명시된 경우를 제외하고 STREAM\_CLOSED 유형의 연결 오류\(섹션 5.4.1\)로 처리할 수 있습니다\(MAY\).\(MUST NOT, MAY\)

- END\_STREAM 플래그가 설정된 프레임 또는 RST\_STREAM 프레임을 보내는 엔드포인트는 피어가 스트림을 닫는 프레임을 수신하고 처리하기 전에 해당 피어로부터 WINDOW\_UPDATE 또는 RST\_STREAM 프레임을 수신할 수 있습니다.

- "open" 또는 "half-closed \(local\)" 상태에 있는 스트림에서 RST\_STREAM 프레임을 전송하는 엔드포인트는 모든 유형의 프레임을 수신할 수 있습니다. 피어는 RST\_STREAM 프레임을 처리하기 전에 이러한 프레임을 전송하거나 전송하기 위해 대기열에 넣었을 수 있습니다. 엔드포인트는 이 상태에서 수신하는 모든 프레임을 최소한으로 처리한 다음 폐기해야 합니다. 이는 HEADERS 및 PUSH\_PROMISE 프레임의 헤더 압축 상태를 업데이트하는 것을 의미합니다. PUSH\_PROMISE 프레임을 수신하면 닫힌 스트림에서 PUSH\_PROMISE 프레임을 수신하더라도 약속된 스트림이 "예약\(원격\)" 상태가 됩니다. 또한 DATA 프레임의 내용은 연결 흐름 제어 창에 포함됩니다.\(MUST\)

- 엔드포인트는 "닫힌" 상태에 있는 모든 스트림에 대해 이 최소 처리를 수행할 수 있습니다. 끝점은 다른 신호를 사용하여 피어가 스트림이 "닫힌" 상태로 들어가고 PRIORITY 이외의 프레임 수신을 PROTOCOL\_ERROR 유형의 연결 오류\(섹션 5.4.1\)로 처리하는 프레임을 수신했음을 감지할 수 있습니다\(MAY\). 끝점은 피어가 이를 구동하기 위해 종료 신호를 수신했음을 나타내는 프레임을 사용할 수 있습니다. 엔드포인트는 이 목적을 위해 타이머를 사용해서는 안 됩니다\(SHOULD NOT\). 예를 들어, 스트림을 닫은 후 SETTINGS 프레임을 보내는 엔드포인트는 설정 승인을 받은 후 해당 스트림에서 DATA 프레임 수신을 오류로 안전하게 처리할 수 있습니다. 사용할 수 있는 다른 것들은 PING 프레임, 스트림을 닫은 후 생성된 스트림에서 데이터 수신 또는 스트림을 닫은 후 생성된 요청에 대한 응답입니다.\(MAY, SHOULD NOT\)

보다 구체적인 규칙이 없는 경우 구현은 상태 설명에서 명시적으로 허용되지 않는 프레임 수신을 PROTOCOL\_ERROR 유형의 연결 오류\(섹션 5.4.1\)로 처리해야 합니다\(SHOULD\). PRIORITY는 모든 스트림 상태에서 보내고 받을 수 있습니다.\(SHOULD\)

이 섹션의 규칙은 이 문서에 정의된 프레임에만 적용됩니다. 의미 체계를 알 수 없는 프레임 수신은 해당 프레임을 보내고 받는 조건도 알 수 없으므로 오류로 처리할 수 없습니다. 섹션 5.5를 참조하십시오.

HTTP 요청/응답 교환에 대한 상태 전환의 예는 섹션 8.8에서 찾을 수 있습니다. 서버 푸시에 대한 상태 전환의 예는 섹션 8.4.1 및 8.4.2에서 찾을 수 있습니다.

---
#### **5.1.1.  Stream Identifiers**

스트림은 부호 없는 31비트 정수로 식별됩니다. 클라이언트에 의해 시작된 스트림은 반드시 홀수 번호의 스트림 식별자를 사용해야 합니다. 서버에 의해 시작된 스트림 식별자는 반드시 짝수 번호의 스트림 식별자를 사용해야 합니다. 연결 제어 메시지에는 스트림 식별자 0\(0x00\)이 사용됩니다. 스트림 식별자 0은 새 스트림을 설정하는 데 사용할 수 없습니다.\(MUST\)

새로 설정된 스트림의 식별자는 시작 엔드포인트가 열거나 예약한 모든 스트림보다 수치적으로 커야 합니다. 이는 HEADERS 프레임을 사용하여 열린 스트림과 PUSH\_PROMISE를 사용하여 예약된 스트림을 제어합니다. 예기치 않은 스트림 식별자를 수신하는 끝점은 PROTOCOL\_ERROR 유형의 연결 오류\(섹션 5.4.1\)로 응답해야 합니다.\(MUST, MUST\)

HEADERS 프레임은 프레임 헤더의 스트림 식별자로 식별되는 클라이언트 시작 스트림을 "유휴"에서 "열림"으로 전환합니다. PUSH\_PROMISE 프레임은 프레임 페이로드의 Promised Stream ID 필드로 식별되는 서버 시작 스트림을 "유휴"에서 "예약됨\(로컬\)" 또는 "예약됨\(원격\)"으로 전환합니다. 스트림이 "유휴" 상태에서 전환되면 낮은 값의 스트림 식별자를 가진 피어가 열었을 수 있는 "유휴" 상태의 모든 스트림이 즉시 "닫힘"으로 전환됩니다. 즉, 엔드포인트는 스트림 식별자를 건너뛸 수 있으며 그 결과 건너뛴 스트림이 즉시 닫힙니다.

스트림 식별자는 재사용할 수 없습니다. 수명이 긴 연결로 인해 끝점이 사용 가능한 스트림 식별자 범위를 소진할 수 있습니다. 새 스트림 식별자를 설정할 수 없는 클라이언트는 새 스트림에 대한 새 연결을 설정할 수 있습니다. 새 스트림 식별자를 설정할 수 없는 서버는 GOAWAY 프레임을 보내 클라이언트가 새 스트림에 대한 새 연결을 강제로 열도록 할 수 있습니다.

---
#### **5.1.2.  Stream Concurrency**

피어는 SETTINGS 프레임 내에서 SETTINGS\_MAX\_CONCURRENT\_STREAMS 매개변수\(섹션 6.5.2 참조\)를 사용하여 동시 활성 스트림의 수를 제한할 수 있습니다. 최대 동시 스트림 설정은 각 끝점에 따라 다르며 설정을 수신하는 피어에만 적용됩니다. 즉, 클라이언트는 서버가 시작할 수 있는 최대 동시 스트림 수를 지정하고 서버는 클라이언트가 시작할 수 있는 최대 동시 스트림 수를 지정합니다.

"개방" 상태 또는 "반 폐쇄" 상태에 있는 스트림은 엔드포인트가 열 수 있는 최대 스트림 수에 포함됩니다. 이 세 가지 상태의 스트림은 SETTINGS\_MAX\_CONCURRENT\_STREAMS 설정에 알려진 제한에 포함됩니다. "예약됨" 상태의 스트림은 스트림 제한에 포함되지 않습니다.

엔드포인트는 피어가 설정한 제한을 초과해서는 안 됩니다. 광고된 동시 스트림 제한을 초과하는 HEADERS 프레임을 수신하는 엔드포인트는 이를 PROTOCOL\_ERROR 또는 REFUSED\_STREAM 유형의 스트림 오류\(섹션 5.4.2\)로 처리해야 합니다. 오류 코드의 선택에 따라 엔드포인트가 자동 재시도를 활성화할지 여부가 결정됩니다\(자세한 내용은 섹션 8.7 참조\).\(MUST NOT, MUST\)

SETTINGS\_MAX\_CONCURRENT\_STREAMS의 값을 현재 열린 스트림 수보다 낮은 값으로 줄이려는 엔드포인트는 새 값을 초과하는 스트림을 닫거나 스트림이 완료되도록 허용할 수 있습니다.

---
### **5.2.  Flow Control**

멀티플렉싱에 스트림을 사용하면 TCP 연결 사용에 대한 경합이 발생하여 스트림이 차단됩니다. 흐름 제어 체계는 동일한 연결의 스트림이 서로 파괴적으로 간섭하지 않도록 합니다. 흐름 제어는 개별 스트림과 전체 연결 모두에 사용됩니다.

HTTP/2는 WINDOW\_UPDATE 프레임\(섹션 6.9\)을 사용하여 흐름 제어를 제공합니다.

---
#### **5.2.1.  Flow-Control Principles**

HTTP/2 스트림 흐름 제어는 프로토콜 변경 없이 다양한 흐름 제어 알고리즘을 사용할 수 있도록 하는 것을 목표로 합니다. HTTP/2의 흐름 제어에는 다음과 같은 특징이 있습니다.

1. 흐름 제어는 연결에 따라 다릅니다. HTTP/2 흐름 제어는 전체 종단 간 경로가 아닌 단일 홉의 끝점 간에 작동합니다.

2. 흐름 제어는 WINDOW\_UPDATE 프레임을 기반으로 합니다. 수신기는 스트림과 전체 연결에 대해 수신할 준비가 된 옥텟 수를 알립니다. 이것은 신용 기반 제도입니다.

3. 흐름 제어는 수신기에서 제공하는 전체 제어와 함께 방향성입니다. 수신기는 각 스트림과 전체 연결에 대해 원하는 창 크기를 설정하도록 선택할 수 있습니다. 발신자는 수신자가 부과한 흐름 제어 제한을 준수해야 합니다. 클라이언트, 서버 및 중개자는 모두 독립적으로 흐름 제어 창을 수신기로 알리고 보낼 때 피어가 설정한 흐름 제어 제한을 준수합니다.\(MAY, MUST\)

4. 흐름 제어 창의 초기 값은 새 스트림과 전체 연결 모두에 대해 65,535옥텟입니다.

5. 프레임 유형은 흐름 제어가 프레임에 적용되는지 여부를 결정합니다. 이 문서에 지정된 프레임 중에서 DATA 프레임만 흐름 제어의 대상입니다. 다른 모든 프레임 유형은 알려진 흐름 제어 창에서 공간을 사용하지 않습니다. 이렇게 하면 중요한 제어 프레임이 흐름 제어에 의해 차단되지 않습니다.

6. 엔드포인트는 자체 흐름 제어를 비활성화하도록 선택할 수 있지만 엔드포인트는 피어의 흐름 제어 신호를 무시할 수 없습니다.

7. HTTP/2는 WINDOW\_UPDATE 프레임의 형식과 의미만 정의합니다\(섹션 6.9\). 이 문서는 수신자가 이 프레임을 보낼 시기나 보내는 값을 결정하는 방법을 규정하지 않으며 발신자가 패킷을 보내기 위해 선택하는 방법도 지정하지 않습니다. 구현은 필요에 맞는 알고리즘을 선택할 수 있습니다.

또한 구현은 요청 및 응답 전송의 우선 순위를 지정하고 요청에 대한 HOL\(head-of-line\) 차단을 피하는 방법을 선택하고 새 스트림 생성을 관리할 책임이 있습니다. 이에 대한 알고리즘 선택은 모든 흐름 제어 알고리즘과 상호 작용할 수 있습니다.

---
#### **5.2.2.  Appropriate Use of Flow Control**

흐름 제어는 리소스 제약 조건 하에서 작동하는 엔드포인트를 보호하기 위해 정의됩니다. 예를 들어 프록시는 많은 연결 간에 메모리를 공유해야 하며 느린 업스트림 연결과 빠른 다운스트림 연결이 있을 수 있습니다. 흐름 제어는 수신자가 한 스트림에서 데이터를 처리할 수 없지만 동일한 연결에서 다른 스트림을 계속 처리하려는 경우를 해결합니다.

이 기능이 필요하지 않은 배포는 최대 크기\(2^31-1\)의 흐름 제어 창을 알릴 수 있으며 데이터가 수신될 때 WINDOW\_UPDATE 프레임을 전송하여 이 창을 유지할 수 있습니다. 이는 해당 수신기에 대한 흐름 제어를 효과적으로 비활성화합니다. 반대로 발신자는 항상 수신자가 알리는 흐름 제어 창의 영향을 받습니다.

제한된 리소스\(예: 메모리\)가 있는 배포에서는 흐름 제어를 사용하여 피어가 사용할 수 있는 메모리 양을 제한할 수 있습니다. 그러나 이것은 대역폭 \* 지연 곱\(\[RFC7323\] 참조\)에 대한 지식 없이 흐름 제어가 활성화된 경우 사용 가능한 네트워크 리소스를 차선책으로 사용할 수 있다는 점에 유의하십시오.

현재 대역폭 \* 지연 제품을 완전히 인식하더라도 흐름 제어 구현이 어려울 수 있습니다. 끝점은 데이터를 사용할 수 있는 즉시 TCP 수신 버퍼에서 HTTP/2 프레임을 읽고 처리해야 합니다. 즉시 읽지 못하면 WINDOW\_UPDATE와 같은 중요한 프레임을 읽지 않고 조치를 취하지 않을 때 교착 상태가 발생할 수 있습니다. 프레임 읽기는 HTTP/2 흐름 제어가 리소스 커밋을 제한하므로 엔드포인트를 리소스 고갈 공격에 즉시 노출하지 않습니다.\(MUST\)

---
#### **5.2.3.  Flow-Control Performance**

엔드포인트가 해당 피어가 이 연결에서 피어의 대역폭 \* 지연 제품보다 큰 사용 가능한 흐름 제어 창 공간을 항상 가지고 있는지 확인할 수 없는 경우 수신 처리량은 HTTP/2 흐름 제어에 의해 제한됩니다. 이로 인해 성능이 저하됩니다.

적시에 WINDOW\_UPDATE 프레임을 전송하면 성능이 향상될 수 있습니다. 엔드포인트는 수신 처리량을 개선해야 할 필요성과 리소스 고갈 위험을 관리해야 할 필요성 사이의 균형을 맞추기를 원할 것이며 창 크기를 관리하기 위한 전략을 정의할 때 섹션 10.5를 주의 깊게 참고해야 합니다.

---
### **5.3.  Prioritization**

HTTP/2와 같은 다중화 프로토콜에서 스트림에 대한 대역폭 및 계산 리소스 할당의 우선 순위를 지정하는 것은 우수한 성능을 달성하는 데 중요할 수 있습니다. 잘못된 우선 순위 체계는 HTTP/2가 낮은 성능을 제공하는 결과를 초래할 수 있습니다. TCP 계층에 병렬 처리가 없으면 HTTP/1.1보다 성능이 크게 저하될 수 있습니다.

좋은 우선 순위 지정 체계는 자원의 내용, 자원이 상호 연관되는 방식, 해당 자원이 동료에 의해 사용되는 방식과 같은 상황에 맞는 지식을 적용함으로써 이점을 얻습니다. 특히 클라이언트는 서버 우선 순위 지정과 관련된 요청 우선 순위에 대한 지식을 보유할 수 있습니다. 이러한 경우 클라이언트가 우선 순위 정보를 제공하도록 하면 성능이 향상될 수 있습니다.

---
#### **5.3.1.  Background on Priority in RFC 7540**

RFC 7540은 요청의 우선 순위 신호를 위한 풍부한 시스템을 정의했습니다. 그러나 이 시스템은 복잡하고 일률적으로 구현되지 않았습니다.

유연한 체계는 고객이 채택된 접근 방식의 일관성이 거의 없이 매우 다양한 방식으로 우선 순위를 표현할 수 있음을 의미했습니다. 서버의 경우 스키마에 대한 일반 지원을 구현하는 것이 복잡했습니다. 우선 순위 구현은 클라이언트와 서버 모두에서 고르지 않았습니다. 많은 서버 배포는 요청 처리의 우선 순위를 지정할 때 클라이언트 신호를 무시했습니다.

즉, RFC 7540\[RFC7540\]의 우선 순위 지정 신호가 성공적이지 않았습니다.

---
#### **5.3.2.  Priority Signaling in This Document**

이 HTTP/2 업데이트는 RFC 7540\[RFC7540\]에 정의된 우선 순위 신호를 더 이상 사용하지 않습니다. 우선 순위 신호와 관련된 대부분의 텍스트는 이 문서에 포함되어 있지 않습니다. 프레임 필드 및 일부 필수 처리에 대한 설명은 이 문서의 구현이 RFC 7540에 설명된 우선 순위 신호를 사용하는 구현과 상호 운용 가능하도록 유지됩니다.

RFC 7540 우선 순위 체계에 대한 자세한 설명은 \[RFC7540\]의 섹션 5.3에 남아 있습니다.

좋은 성능을 얻기 위해서는 많은 경우 신호 우선 순위 정보가 필요합니다. 시그널링 우선순위 정보가 중요한 경우 엔드포인트는 \[HTTP-PRIORITY\]에 설명된 방식과 같은 대체 방식을 사용하도록 권장됩니다.

RFC 7540의 우선순위 신호가 널리 채택되지는 않았지만, 더 나은 정보가 없는 경우에도 RFC 7540이 제공하는 정보는 여전히 유용할 수 있습니다. HEADERS 또는 PRIORITY 프레임에서 우선 순위 신호를 수신하는 엔드포인트는 해당 정보를 적용하면 이점을 얻을 수 있습니다. 특히 이러한 신호를 사용하는 구현은 대안이 없는 경우 이러한 우선 순위 신호를 폐기해도 이점이 없습니다.

서버는 우선 순위 신호가 없는 경우 요청 우선 순위를 결정할 때 다른 컨텍스트 정보를 사용해야 합니다. 서버는 신호의 완전한 부재를 클라이언트가 기능을 구현하지 않았다는 표시로 해석할 수 있습니다\(MAY\). \[RFC7540\]의 섹션 5.3.5에 설명된 기본값은 대부분의 조건에서 성능이 좋지 않은 것으로 알려져 있으며 의도적으로 사용할 가능성이 낮습니다.\(SHOULD, MAY\)

---
### **5.4.  Error Handling**

HTTP/2 프레이밍은 두 종류의 오류를 허용합니다.

\* 전체 연결을 사용할 수 없게 만드는 오류 상태는 연결 오류입니다.

\* 개별 스트림의 오류는 스트림 오류입니다.

오류 코드 목록은 섹션 7에 포함되어 있습니다.

끝점이 여러 오류를 일으키는 프레임을 만날 수 있습니다. 구현은 처리 중에 여러 오류를 발견할 수 있지만 결과적으로 최대 하나의 스트림과 하나의 연결 오류를 보고해야 합니다.\(SHOULD\)

지정된 스트림에 대해 보고된 첫 번째 스트림 오류는 해당 스트림의 다른 오류가 보고되지 않도록 합니다. 그에 비해 프로토콜은 다중 GOAWAY 프레임을 허용하지만 종점은 정상적으로 종료하는 동안 오류가 발생하지 않는 한 한 가지 유형의 연결 오류만 보고해야 합니다. 이 경우 엔드포인트는 NO\_ERROR를 포함하는 이전 GOAWAY에 추가하여 새 오류 코드가 포함된 추가 GOAWAY 프레임을 보낼 수 있습니다\(MAY\).\(SHOULD, MAY\)

엔드포인트가 여러 다른 오류를 감지하면 해당 오류 중 하나를 보고하도록 선택할 수 있습니다. 프레임으로 인해 연결 오류가 발생하면 해당 오류를 보고해야 합니다. 또한 엔드포인트는 오류 조건을 감지할 때 적용 가능한 모든 오류 코드를 사용할 수 있습니다\(MAY\). 보다 구체적인 오류 코드 대신 일반 오류 코드\(예: PROTOCOL\_ERROR 또는 INTERNAL\_ERROR\)를 항상 사용할 수 있습니다.\(MAY, MUST, MAY\)

---
#### **5.4.1.  Connection Error Handling**

연결 오류는 프레임 계층의 추가 처리를 방해하거나 연결 상태를 손상시키는 모든 오류입니다.

연결 오류가 발생한 엔드포인트는 피어로부터 성공적으로 수신한 마지막 스트림의 스트림 식별자와 함께 GOAWAY 프레임\(섹션 6.8\)을 먼저 보내야 합니다\(SHOULD\). GOAWAY 프레임에는 연결이 종료되는 이유를 나타내는 오류 코드\(섹션 7\)가 포함됩니다. 오류 조건에 대해 GOAWAY 프레임을 보낸 후 엔드포인트는 TCP 연결을 닫아야 합니다.\(SHOULD, MUST\)

수신 엔드포인트에서 GOAWAY를 안정적으로 수신하지 못할 수 있습니다. 연결 오류가 발생하는 경우 GOAWAY는 연결이 종료되는 이유에 대해 피어와 통신하기 위한 최선의 시도만 제공합니다.

엔드포인트는 언제든지 연결을 종료할 수 있습니다. 특히 엔드포인트는 스트림 오류를 연결 오류로 처리하도록 선택할 수 있습니다. 끝점은 연결을 종료할 때 상황이 허용한다면 GOAWAY 프레임을 보내야 합니다\(SHOULD\).\(MAY, SHOULD\)

---
#### **5.4.2.  Stream Error Handling**

스트림 오류는 다른 스트림의 처리에 영향을 미치지 않는 특정 스트림과 관련된 오류입니다.

스트림 오류를 감지한 끝점은 오류가 발생한 스트림의 스트림 식별자를 포함하는 RST\_STREAM 프레임\(섹션 6.4\)을 보냅니다. RST\_STREAM 프레임에는 오류의 종류를 나타내는 오류 코드가 포함되어 있습니다.

RST\_STREAM은 끝점이 스트림에서 보낼 수 있는 마지막 프레임입니다. RST\_STREAM 프레임을 전송하는 피어는 원격 피어가 전송했거나 전송을 위해 대기열에 넣은 모든 프레임을 수신할 준비가 되어 있어야 합니다. 이러한 프레임은 연결 상태를 수정하는 경우를 제외하고 무시할 수 있습니다\(예: 필드 섹션 압축\(섹션 4.3\) 또는 흐름 제어를 위해 유지되는 상태\).\(MUST\)

일반적으로 엔드포인트는 모든 스트림에 대해 둘 이상의 RST\_STREAM 프레임을 보내면 안 됩니다\(SHOULD NOT\). 그러나 엔드포인트는 왕복 시간보다 긴 시간 후에 닫힌 스트림에서 프레임을 수신하는 경우 추가 RST\_STREAM 프레임을 보낼 수 있습니다\(MAY\). 이 동작은 오작동하는 구현을 처리하기 위해 허용됩니다.\(SHOULD NOT, MAY\)

루핑을 피하기 위해 엔드포인트는 RST\_STREAM 프레임에 대한 응답으로 RST\_STREAM을 보내면 안 됩니다\(MUST NOT\).\(MUST NOT\)

---
#### **5.4.3.  Connection Termination**

스트림이 "개방" 또는 "반 폐쇄" 상태에 있는 동안 TCP 연결이 닫히거나 재설정되면 영향을 받는 스트림을 자동으로 재시도할 수 없습니다\(자세한 내용은 섹션 8.7 참조\).

---
### **5.5.  Extending HTTP/2**

HTTP/2는 프로토콜의 확장을 허용합니다. 이 섹션에 설명된 제한 내에서 프로토콜 확장을 사용하여 추가 서비스를 제공하거나 프로토콜의 모든 측면을 변경할 수 있습니다. 확장은 단일 HTTP/2 연결 범위 내에서만 유효합니다.

이는 이 문서에 정의된 프로토콜 요소에 적용됩니다. 이는 새 메소드, 상태 코드 또는 필드 정의와 같은 HTTP 확장을 위한 기존 옵션에 영향을 미치지 않습니다\(\[HTTP\]의 섹션 16 참조\).

확장 프로그램은 새 프레임 유형\(섹션 4.1\), 새 설정\(섹션 6.5\) 또는 새 오류 코드\(섹션 7\)를 사용할 수 있습니다. 이러한 확장 지점을 관리하기 위한 레지스트리는 \[RFC7540\]의 섹션 11에 정의되어 있습니다.

구현은 모든 확장 가능한 프로토콜 요소에서 알 수 없거나 지원되지 않는 값을 무시해야 합니다\(MUST\). 구현은 알 수 없거나 지원되지 않는 유형이 있는 프레임을 폐기해야 합니다\(MUST\). 이는 이러한 확장 지점 중 어느 것이든 사전 협의나 협상 없이 확장에서 안전하게 사용할 수 있음을 의미합니다. 그러나 필드 블록 중간에 나타나는 확장 프레임\(섹션 4.3\)은 허용되지 않습니다. 이들은 PROTOCOL\_ERROR 유형의 연결 오류\(섹션 5.4.1\)로 처리되어야 합니다.\(MUST, MUST, MUST\)

확장은 이 문서에 정의된 프로토콜 요소 또는 확장 메커니즘이 정의되지 않은 요소를 변경하는 것을 피해야 합니다\(SHOULD\). 여기에는 프레임 레이아웃에 대한 변경, 프레임이 HTTP 메시지로 구성되는 방식에 대한 추가 또는 변경\(8.1절\), 의사 헤더 필드의 정의 또는 호환 엔드포인트가 연결로 처리할 수 있는 프로토콜 요소에 대한 변경이 포함됩니다. 오류\(섹션 5.4.1\).\(SHOULD\)

기존 프로토콜 요소 또는 상태를 변경하는 확장은 사용되기 전에 반드시 협상되어야 합니다. 예를 들어 HEADERS 프레임의 레이아웃을 변경하는 확장은 피어가 이것이 허용된다는 긍정적인 신호를 제공할 때까지 사용할 수 없습니다. 이 경우 수정된 레이아웃이 적용되는 시점을 조정해야 할 수도 있습니다. 예를 들어 DATA 프레임 이외의 프레임을 흐름 제어로 처리하려면 두 엔드포인트가 이해해야 하는 의미 체계의 변경이 필요하므로 이는 협상을 통해서만 수행할 수 있습니다.\(MUST\)

이 문서는 확장 사용을 협상하기 위한 특정 방법을 요구하지 않지만 해당 목적을 위해 설정\(섹션 6.5.2\)을 사용할 수 있음을 언급합니다. 두 피어 모두 확장을 사용할 의사가 있음을 나타내는 값을 설정하면 확장을 사용할 수 있습니다. 확장 협상에 설정을 사용하는 경우 확장이 처음에 비활성화되는 방식으로 초기 값을 정의해야 합니다.\(MUST\)

---
## **6.  Frame Definitions**

이 사양은 각각 고유한 8비트 유형 코드로 식별되는 여러 프레임 유형을 정의합니다. 각 프레임 유형은 연결 전체 또는 개별 스트림의 설정 및 관리에서 고유한 목적을 제공합니다.

특정 프레임 유형의 전송은 연결 상태를 변경할 수 있습니다. 엔드포인트가 연결 상태의 동기화된 보기를 유지하지 못하면 연결 내에서 성공적인 통신이 더 이상 가능하지 않습니다. 따라서 엔드포인트가 주어진 프레임의 사용에 의해 상태가 어떻게 영향을 받는지에 대한 이해를 공유하는 것이 중요합니다.

---
### **6.1.  DATA**

DATA 프레임\(유형=0x00\)은 스트림과 관련된 임의의 가변 길이 옥텟 시퀀스를 전달합니다. 예를 들어 HTTP 요청 또는 응답 메시지 내용을 전달하기 위해 하나 이상의 DATA 프레임이 사용됩니다.

데이터 프레임에는 패딩도 포함될 수 있습니다\(MAY\). 메시지 크기를 가리기 위해 패딩을 DATA 프레임에 추가할 수 있습니다. 패딩은 보안 기능입니다. 섹션 10.7을 참조하십시오.\(MAY\)

```text
   DATA Frame {
     Length (24),
     Type (8) = 0x00,

     Unused Flags (4),
     PADDED Flag (1),
     Unused Flags (2),
     END_STREAM Flag (1),

     Reserved (1),
     Stream Identifier (31),

     [Pad Length (8)],
     Data (..),
     Padding (..2040),
   }

                        Figure 3: DATA Frame Format
```

길이, 유형, 미사용 플래그, 예약됨 및 스트림 식별자 필드는 섹션 4에서 설명합니다. DATA 프레임에는 다음과 같은 추가 필드가 포함됩니다.

패드 길이: 옥텟 단위의 프레임 패딩 길이를 포함하는 8비트 필드입니다. 이 필드는 조건부이며 PADDED 플래그가 설정된 경우에만 존재합니다.

데이터: 애플리케이션 데이터. 데이터의 양은 존재하는 다른 필드의 길이를 뺀 후 프레임 페이로드의 나머지 부분입니다.

패딩: 애플리케이션 시맨틱 값을 포함하지 않는 패딩 옥텟. 보낼 때 패딩 옥텟을 0으로 설정해야 합니다. 수신자는 패딩을 확인할 의무가 없지만 0이 아닌 패딩을 PROTOCOL\_ERROR 유형의 연결 오류\(섹션 5.4.1\)로 처리할 수 있습니다\(MAY\).\(MUST, MAY\)

DATA 프레임은 다음 플래그를 정의합니다.

PADDED\(0x08\): 설정되면 PADDED 플래그는 패드 길이 필드와 여기에 설명된 패딩이 있음을 나타냅니다.

END\_STREAM\(0x01\): 설정되면 END\_STREAM 플래그는 이 프레임이 엔드포인트가 식별된 스트림에 대해 보낼 마지막 프레임임을 나타냅니다. 이 플래그를 설정하면 스트림이 "반쯤 닫힌" 상태 또는 "닫힌" 상태\(섹션 5.1\) 중 하나로 들어가게 됩니다.

- | 참고: 전송 후 스트림 종료를 학습하는 엔드포인트 | 모든 데이터는 STREAM 프레임을 | 길이가 0인 데이터 필드 및 END\_STREAM 플래그 세트. 이것은 | 엔드포인트가 트레일러를 보내지 않는 경우에만 | 이 경우 HEADERS 프레임에 END\_STREAM 플래그가 나타납니다. 참조 | 섹션 8.1.

DATA 프레임은 반드시 스트림과 연결되어야 합니다. 스트림 식별자 필드가 0x00인 DATA 프레임이 수신되면 수신자는 PROTOCOL\_ERROR 유형의 연결 오류\(섹션 5.4.1\)로 응답해야 합니다.\(MUST, MUST\)

DATA 프레임은 흐름 제어의 대상이며 스트림이 "개방" 또는 "반폐쇄\(원격\)" 상태일 때만 보낼 수 있습니다. 전체 DATA 프레임 페이로드는 패드 길이 및 패딩 필드\(있는 경우\)를 포함하여 흐름 제어에 포함됩니다. 스트림이 "open" 또는 "half-closed \(local\)" 상태가 아닌 DATA 프레임이 수신되면 수신자는 STREAM\_CLOSED 유형의 스트림 오류\(섹션 5.4.2\)로 응답해야 합니다.\(MUST\)

패딩 옥텟의 총 수는 패드 길이 필드의 값으로 결정됩니다. 패딩 길이가 프레임 페이로드 길이 이상인 경우 수신자는 이를 PROTOCOL\_ERROR 유형의 연결 오류\(섹션 5.4.1\)로 처리해야 합니다.\(MUST\)

| 참고: 프레임 크기는 한 옥텟씩 증가할 수 있습니다.

- | 값이 0인 패드 길이 필드를 포함합니다.

---
### **6.2.  HEADERS**

HEADERS 프레임\(유형=0x01\)은 스트림\(섹션 5.1\)을 여는 데 사용되며 추가로 필드 블록 조각을 전달합니다. 이름에도 불구하고 HEADERS 프레임은 헤더 섹션이나 트레일러 섹션을 포함할 수 있습니다. HEADERS 프레임은 "idle", "reserved\(local\)", "open" 또는 "half-closed\(remote\)" 상태의 스트림에서 전송될 수 있습니다.

```text
   HEADERS Frame {
     Length (24),
     Type (8) = 0x01,

     Unused Flags (2),
     PRIORITY Flag (1),
     Unused Flag (1),
     PADDED Flag (1),
     END_HEADERS Flag (1),
     Unused Flag (1),
     END_STREAM Flag (1),

     Reserved (1),
     Stream Identifier (31),

     [Pad Length (8)],
     [Exclusive (1)],
     [Stream Dependency (31)],
     [Weight (8)],
     Field Block Fragment (..),
     Padding (..2040),
   }

                       Figure 4: HEADERS Frame Format
```

길이, 유형, 미사용 플래그, 예약됨 및 스트림 식별자 필드는 섹션 4에서 설명합니다. HEADERS 프레임 페이로드에는 다음과 같은 추가 필드가 있습니다.

패드 길이: 옥텟 단위의 프레임 패딩 길이를 포함하는 8비트 필드입니다. 이 필드는 PADDED 플래그가 설정된 경우에만 존재합니다.

독점: 단일 비트 플래그입니다. 이 필드는 PRIORITY 플래그가 설정된 경우에만 존재합니다. HEADERS 프레임의 우선 순위 신호는 더 이상 사용되지 않습니다. 섹션 5.3.2를 참조하십시오.

스트림 종속성: 31비트 스트림 식별자입니다. 이 필드는 PRIORITY 플래그가 설정된 경우에만 존재합니다.

가중치: 부호 없는 8비트 정수. 이 필드는 PRIORITY 플래그가 설정된 경우에만 존재합니다.

필드 블록 조각: 필드 블록 조각\(섹션 4.3\).

패딩: 애플리케이션 시맨틱 값을 포함하지 않는 패딩 옥텟. 보낼 때 패딩 옥텟을 0으로 설정해야 합니다. 수신자는 패딩을 확인할 의무가 없지만 0이 아닌 패딩을 PROTOCOL\_ERROR 유형의 연결 오류\(섹션 5.4.1\)로 처리할 수 있습니다\(MAY\).\(MUST, MAY\)

HEADERS 프레임은 다음 플래그를 정의합니다.

PRIORITY\(0x20\): 설정되면 PRIORITY 플래그는 Exclusive, Stream Dependency 및 Weight 필드가 있음을 나타냅니다.

PADDED\(0x08\): 설정되면 PADDED 플래그는 패드 길이 필드와 여기에 설명된 패딩이 있음을 나타냅니다.

END\_HEADERS\(0x04\): 설정되면 END\_HEADERS 플래그는 이 프레임이 전체 필드 블록\(섹션 4.3\)을 포함하고 어떤 CONTINUATION 프레임도 뒤따르지 않는다는 것을 나타냅니다.

- END\_HEADERS 플래그가 설정되지 않은 HEADERS 프레임 뒤에는 동일한 스트림에 대한 CONTINUATION 프레임이 와야 합니다. 수신기는 다른 유형의 프레임 또는 다른 스트림의 프레임 수신을 PROTOCOL\_ERROR 유형의 연결 오류\(섹션 5.4.1\)로 처리해야 합니다.\(MUST, MUST\)

END\_STREAM\(0x01\): 설정되면 END\_STREAM 플래그는 필드 블록\(섹션 4.3\)이 엔드포인트가 식별된 스트림에 대해 보낼 마지막 블록임을 나타냅니다.

- END\_STREAM 플래그가 설정된 HEADERS 프레임은 스트림의 끝을 알립니다. 그러나 END\_STREAM 플래그가 설정된 HEADERS 프레임 뒤에는 동일한 스트림의 CONTINUATION 프레임이 올 수 있습니다. 논리적으로 CONTINUATION 프레임은 HEADERS 프레임의 일부입니다.

HEADERS 프레임의 프레임 페이로드에는 필드 블록 조각이 포함됩니다\(섹션 4.3\). HEADERS 프레임에 맞지 않는 필드 블록은 CONTINUATION 프레임에서 계속됩니다\(섹션 6.10\).

HEADERS 프레임은 스트림과 연결되어야 합니다. Stream Identifier 필드가 0x00인 HEADERS 프레임이 수신되면 수신자는 PROTOCOL\_ERROR 유형의 연결 오류\(섹션 5.4.1\)로 응답해야 합니다.\(MUST, MUST\)

HEADERS 프레임은 섹션 4.3에서 설명한 대로 연결 상태를 변경합니다.

패딩 옥텟의 총 수는 패드 길이 필드의 값으로 결정됩니다. 패딩 길이가 프레임 페이로드 길이 이상인 경우 수신자는 이를 PROTOCOL\_ERROR 유형의 연결 오류\(섹션 5.4.1\)로 처리해야 합니다.\(MUST\)

| 참고: 프레임 크기는 한 옥텟씩 증가할 수 있습니다.

- | 값이 0인 패드 길이 필드를 포함합니다.

---
### **6.3.  PRIORITY**

PRIORITY 프레임\(유형=0x02\)은 더 이상 사용되지 않습니다. 섹션 5.3.2를 참조하십시오. PRIORITY 프레임은 유휴 또는 닫힌 스트림을 포함하여 모든 스트림 상태에서 보낼 수 있습니다.

```text
   PRIORITY Frame {
     Length (24) = 0x05,
     Type (8) = 0x02,

     Unused Flags (8),

     Reserved (1),
     Stream Identifier (31),

     Exclusive (1),
     Stream Dependency (31),
     Weight (8),
   }

                      Figure 5: PRIORITY Frame Format
```

길이, 유형, 미사용 플래그, 예약됨 및 스트림 식별자 필드는 섹션 4에서 설명합니다. PRIORITY 프레임의 프레임 페이로드에는 다음과 같은 추가 필드가 포함됩니다.

독점: 단일 비트 플래그입니다.

스트림 종속성: 31비트 스트림 식별자입니다.

가중치: 부호 없는 8비트 정수.

PRIORITY 프레임은 플래그를 정의하지 않습니다.

PRIORITY 프레임은 항상 스트림을 식별합니다. 스트림 식별자 0x00으로 PRIORITY 프레임이 수신되면 수신자는 PROTOCOL\_ERROR 유형의 연결 오류\(섹션 5.4.1\)로 응답해야 합니다.\(MUST\)

PRIORITY 프레임을 보내거나 받는 것은 스트림의 상태에 영향을 미치지 않습니다\(섹션 5.1\). PRIORITY 프레임은 "idle" 또는 "closed"를 포함한 모든 상태의 스트림에서 전송될 수 있습니다. 단일 필드 블록\(섹션 4.3\)을 구성하는 연속 프레임 간에는 PRIORITY 프레임을 보낼 수 없습니다.

길이가 5 옥텟이 아닌 PRIORITY 프레임은 FRAME\_SIZE\_ERROR 유형의 스트림 오류\(섹션 5.4.2\)로 처리해야 합니다.\(MUST\)

---
### **6.4.  RST_STREAM**

RST\_STREAM 프레임\(유형=0x03\)을 사용하면 스트림을 즉시 종료할 수 있습니다. RST\_STREAM은 스트림 취소를 요청하거나 오류 조건이 발생했음을 나타내기 위해 전송됩니다.

```text
   RST_STREAM Frame {
     Length (24) = 0x04,
     Type (8) = 0x03,

     Unused Flags (8),

     Reserved (1),
     Stream Identifier (31),

     Error Code (32),
   }

                     Figure 6: RST_STREAM Frame Format
```

길이, 유형, 미사용 플래그, 예약됨 및 스트림 식별자 필드는 섹션 4에서 설명합니다. 또한 RST\_STREAM 프레임에는 오류 코드를 식별하는 단일 부호 없는 32비트 정수가 포함됩니다\(섹션 7\). 오류 코드는 스트림이 종료되는 이유를 나타냅니다.

RST\_STREAM 프레임은 플래그를 정의하지 않습니다.

RST\_STREAM 프레임은 참조된 스트림을 완전히 종료하고 "닫힌" 상태로 들어가게 합니다. 스트림에서 RST\_STREAM을 수신한 후 수신자는 PRIORITY를 제외하고 해당 스트림에 대한 추가 프레임을 보내면 안 됩니다. 그러나 RST\_STREAM을 전송한 후 전송 엔드포인트는 RST\_STREAM이 도착하기 전에 피어가 전송했을 수 있는 스트림에서 전송된 추가 프레임을 수신하고 처리할 수 있도록 준비해야 합니다.\(MUST NOT, MUST\)

RST\_STREAM 프레임은 스트림과 연결되어야 합니다. RST\_STREAM 프레임이 스트림 식별자 0x00으로 수신되면 수신자는 이를 PROTOCOL\_ERROR 유형의 연결 오류\(섹션 5.4.1\)로 처리해야 합니다.\(MUST, MUST\)

"유휴" 상태의 스트림에 대해 RST\_STREAM 프레임을 보내서는 안 됩니다\(MUST NOT\). 유휴 스트림을 식별하는 RST\_STREAM 프레임이 수신되면 수신자는 이를 PROTOCOL\_ERROR 유형의 연결 오류\(섹션 5.4.1\)로 처리해야 합니다.\(MUST NOT, MUST\)

길이가 4 옥텟이 아닌 RST\_STREAM 프레임은 FRAME\_SIZE\_ERROR 유형의 연결 오류\(섹션 5.4.1\)로 처리해야 합니다.\(MUST\)

---
### **6.5.  SETTINGS**

SETTINGS 프레임\(유형=0x04\)은 피어 동작에 대한 기본 설정 및 제약과 같이 끝점이 통신하는 방식에 영향을 미치는 구성 매개 변수를 전달합니다. SETTINGS 프레임은 해당 설정 수신을 확인하는 데에도 사용됩니다. 개별적으로 SETTINGS 프레임의 구성 매개변수를 "설정"이라고 합니다.

설정은 협상되지 않습니다. 수신 피어가 사용하는 송신 피어의 특성을 설명합니다. 동일한 설정에 대해 서로 다른 값을 각 피어에서 알릴 수 있습니다. 예를 들어 클라이언트는 초기 흐름 제어 창을 높게 설정하는 반면 서버는 리소스를 절약하기 위해 더 낮은 값을 설정할 수 있습니다.

SETTINGS 프레임은 연결 시작 시 두 엔드포인트에서 전송해야 하며 연결 ​​수명 동안 어느 한 엔드포인트에서 다른 시간에 전송할 수 있습니다. 구현은 이 사양에 정의된 모든 설정을 지원해야 합니다\(MUST\).\(MUST, MUST\)

SETTINGS 프레임의 각 매개변수는 해당 매개변수의 기존 값을 대체합니다. 설정은 나타나는 순서대로 처리되며 SETTINGS 프레임의 수신자는 각 설정의 현재 값 이외의 상태를 유지할 필요가 없습니다. 따라서 SETTINGS 매개변수의 값은 수신기에 표시되는 마지막 값입니다.

SETTINGS 프레임은 수신 피어에서 승인됩니다. 이를 활성화하기 위해 SETTINGS 프레임은 ACK 플래그를 정의합니다.

ACK\(0x01\): 설정되면 ACK 플래그는 이 프레임이 피어의 SETTINGS 프레임 수신 및 적용을 확인했음을 나타냅니다. 이 비트가 설정되면 SETTINGS 프레임의 프레임 페이로드가 비어 있어야 합니다. ACK 플래그가 설정되고 길이 필드 값이 0이 아닌 SETTINGS 프레임의 수신은 FRAME\_SIZE\_ERROR 유형의 연결 오류\(섹션 5.4.1\)로 처리되어야 합니다. 자세한 내용은 섹션 6.5.3\("설정 동기화"\)을 참조하십시오.\(MUST, MUST\)

SETTINGS 프레임은 항상 단일 스트림이 아닌 연결에 적용됩니다. SETTINGS 프레임의 스트림 식별자는 0\(0x00\)이어야 합니다. 엔드포인트가 스트림 식별자 필드가 0x00이 아닌 SETTINGS 프레임을 수신하는 경우 엔드포인트는 PROTOCOL\_ERROR 유형의 연결 오류\(섹션 5.4.1\)로 응답해야 합니다.\(MUST, MUST\)

SETTINGS 프레임은 연결 상태에 영향을 미칩니다. 잘못 구성되었거나 불완전한 SETTINGS 프레임은 PROTOCOL\_ERROR 유형의 연결 오류\(섹션 5.4.1\)로 처리되어야 합니다.\(MUST\)

길이가 6 옥텟의 배수가 아닌 SETTINGS 프레임은 FRAME\_SIZE\_ERROR 유형의 연결 오류\(섹션 5.4.1\)로 처리해야 합니다.\(MUST\)

---
#### **6.5.1.  SETTINGS Format**

SETTINGS 프레임의 프레임 페이로드는 0개 이상의 설정으로 구성되며, 각각은 부호 없는 16비트 설정 식별자와 부호 없는 32비트 값으로 구성됩니다.

```text
   SETTINGS Frame {
     Length (24),
     Type (8) = 0x04,

     Unused Flags (7),
     ACK Flag (1),

     Reserved (1),
     Stream Identifier (31) = 0,

     Setting (48) ...,
   }

   Setting {
     Identifier (16),
     Value (32),
   }

                      Figure 7: SETTINGS Frame Format
```

길이, 유형, 미사용 플래그\(들\), 예약됨 및 스트림 식별자 필드는 섹션 4에서 설명합니다. SETTINGS 프레임의 프레임 페이로드에는 원하는 수의 설정 필드가 포함되며 각 필드는 다음으로 구성됩니다.

식별자: 16비트 설정 식별자. 섹션 6.5.2를 참조하십시오.

값: 설정에 대한 32비트 값입니다.

---
#### **6.5.2.  Defined Settings**

다음 설정이 정의됩니다.

SETTINGS\_HEADER\_TABLE\_SIZE\(0x01\): 이 설정을 사용하면 발신자가 옥텟 단위로 필드 블록을 디코딩하는 데 사용되는 압축 테이블의 최대 크기를 원격 엔드포인트에 알릴 수 있습니다. 인코더는 필드 블록 내부의 압축 형식에 특정한 신호를 사용하여 이 값 이하의 크기를 선택할 수 있습니다\(\[COMPRESSION\] 참조\). 초기 값은 4,096 옥텟입니다.

SETTINGS\_ENABLE\_PUSH\(0x02\): 이 설정은 서버 푸시를 활성화 또는 비활성화하는 데 사용할 수 있습니다. 서버는 값이 0으로 설정된 이 매개변수를 수신하는 경우 PUSH\_PROMISE 프레임을 보내면 안 됩니다\(MUST NOT\). 섹션 8.4를 참조하십시오. 이 매개변수를 0으로 설정하고 승인을 받은 클라이언트는 PUSH\_PROMISE 프레임 수신을 PROTOCOL\_ERROR 유형의 연결 오류\(섹션 5.4.1\)로 처리해야 합니다.\(MUST NOT, MUST\)

- SETTINGS\_ENABLE\_PUSH의 초기값은 1입니다. 클라이언트의 경우 이 값은 PUSH\_PROMISE 프레임을 수신할 의향이 있음을 나타냅니다. 서버의 경우 이 초기 값은 영향을 미치지 않으며 값 0과 동일합니다. 0 또는 1 이외의 모든 값은 PROTOCOL\_ERROR 유형의 연결 오류\(섹션 5.4.1\)로 처리되어야 합니다.\(MUST\)

- 서버는 이 값을 명시적으로 1로 설정해서는 안 됩니다. 서버는 SETTINGS 프레임을 보낼 때 이 설정을 생략하도록 선택할 수 있지만 서버가 값을 포함하는 경우 0이어야 합니다. 클라이언트는 SETTINGS 프레임 수신을 처리해야 합니다. PROTOCOL\_ERROR 유형의 연결 오류\(섹션 5.4.1\)로 SETTINGS\_ENABLE\_PUSH가 1로 설정됩니다.\(MUST NOT, MUST, MUST\)

SETTINGS\_MAX\_CONCURRENT\_STREAMS\(0x03\): 이 설정은 발신자가 허용할 최대 동시 스트림 수를 나타냅니다. 이 제한은 방향적입니다. 발신자가 수신자가 생성하도록 허용하는 스트림 수에 적용됩니다. 처음에는 이 값에 제한이 없습니다. 불필요하게 병렬 처리를 제한하지 않도록 이 값은 100보다 작지 않은 것이 좋습니다.

- SETTINGS\_MAX\_CONCURRENT\_STREAMS에 대한 0 값은 끝점에서 특수한 것으로 취급되어서는 안 됩니다\(SHOULD NOT\). 값이 0이면 새 스트림이 생성되지 않습니다. 그러나 이는 활성 스트림으로 소진된 제한에 대해서도 발생할 수 있습니다. 서버는 짧은 기간 동안만 0 값을 설정해야 합니다. 서버가 요청을 수락하지 않으려면 연결을 닫는 것이 더 적절합니다.\(SHOULD NOT, SHOULD\)

SETTINGS\_INITIAL\_WINDOW\_SIZE\(0x04\): 이 설정은 스트림 수준 흐름 제어를 위한 발신자의 초기 창 크기\(옥텟 단위\)를 나타냅니다. 초기 값은 2^16-1\(65,535\) 옥텟입니다.

이 설정은 모든 스트림의 창 크기에 영향을 미칩니다\(

- 섹션 6.9.2\).

- 2^31-1의 최대 흐름 제어 창 크기를 초과하는 값은 FLOW\_CONTROL\_ERROR 유형의 연결 오류\(섹션 5.4.1\)로 처리되어야 합니다.\(MUST\)

SETTINGS\_MAX\_FRAME\_SIZE\(0x05\): 이 설정은 송신자가 수신하고자 하는 가장 큰 프레임 페이로드의 크기를 옥텟 단위로 나타냅니다.

- 초기값은 2^14\(16,384\) 옥텟입니다. 끝점에서 광고하는 값은 이 초기 값과 최대 허용 프레임 크기\(2^24-1 또는 16,777,215 옥텟\) 사이여야 합니다. 이 범위 밖의 값은 PROTOCOL\_ERROR 유형의 연결 오류\(섹션 5.4.1\)로 처리해야 합니다.\(MUST, MUST\)

SETTINGS\_MAX\_HEADER\_LIST\_SIZE \(0x06\): 이 권고 설정은 송신자가 수락할 준비가 된 최대 필드 섹션 크기를 옥텟 단위로 피어에게 알려줍니다. 이 값은 각 필드 라인에 대한 32옥텟의 오버헤드를 더한 옥텟 단위의 이름 및 값 길이를 포함하여 필드 라인의 압축되지 않은 크기를 기반으로 합니다.

- 주어진 요청에 대해 광고된 것보다 더 낮은 제한이 적용될 수 있습니다. 이 설정의 초기 값은 무제한입니다.\(MAY\)

알 수 없거나 지원되지 않는 식별자가 있는 SETTINGS 프레임을 수신하는 엔드포인트는 해당 설정을 무시해야 합니다.\(MUST\)

---
#### **6.5.3.  Settings Synchronization**

SETTINGS의 대부분의 값은 피어가 변경된 매개변수 값을 수신하고 적용한 시기를 이해하거나 이해해야 합니다. 이러한 동기화 시점을 제공하기 위해 ACK 플래그가 설정되지 않은 SETTINGS 프레임의 수신자는 수신 즉시 업데이트된 설정을 적용해야 합니다. SETTINGS 프레임은 수신된 순서대로 승인됩니다.\(MUST\)

SETTINGS 프레임의 값은 값 사이에 다른 프레임 처리 없이 나타나는 순서대로 처리되어야 합니다. 지원되지 않는 설정은 무시해야 합니다. 모든 값이 처리되면 수신자는 즉시 ACK 플래그가 설정된 SETTINGS 프레임을 내보내야 합니다. ACK 플래그가 설정된 SETTINGS 프레임을 수신하면 변경된 설정의 발신자는 적용된 승인되지 않은 가장 오래된 SETTINGS 프레임의 값에 의존할 수 있습니다.\(MUST, MUST, MUST\)

SETTINGS 프레임의 발신자가 합리적인 시간 내에 승인을 받지 못하면 SETTINGS\_TIMEOUT 유형의 연결 오류\(섹션 5.4.1\)를 발행할 수 있습니다. 타임아웃을 설정할 때 피어에서 처리 지연을 어느 정도 허용해야 합니다. 엔드포인트 간의 왕복 시간만을 기준으로 하는 제한 시간은 가짜 오류를 유발할 수 있습니다.\(MAY\)

---
### **6.6.  PUSH_PROMISE**

PUSH\_PROMISE 프레임\(유형=0x05\)은 발신자가 시작하려는 스트림에 앞서 피어 엔드포인트에 알리는 데 사용됩니다. PUSH\_PROMISE 프레임에는 끝점이 스트림에 대한 추가 컨텍스트를 제공하는 필드 섹션과 함께 생성할 계획인 스트림의 서명되지 않은 31비트 식별자가 포함됩니다. 섹션 8.4에는 PUSH\_PROMISE 프레임 사용에 대한 자세한 설명이 포함되어 있습니다.

```text
   PUSH_PROMISE Frame {
     Length (24),
     Type (8) = 0x05,

     Unused Flags (4),
     PADDED Flag (1),
     END_HEADERS Flag (1),
     Unused Flags (2),

     Reserved (1),
     Stream Identifier (31),

     [Pad Length (8)],
     Reserved (1),
     Promised Stream ID (31),
     Field Block Fragment (..),
     Padding (..2040),
   }

                    Figure 8: PUSH_PROMISE Frame Format
```

길이, 유형, 미사용 플래그, 예약됨 및 스트림 식별자 필드는 섹션 4에서 설명합니다. PUSH\_PROMISE 프레임 페이로드에는 다음과 같은 추가 필드가 있습니다.

패드 길이: 옥텟 단위의 프레임 패딩 길이를 포함하는 8비트 필드입니다. 이 필드는 PADDED 플래그가 설정된 경우에만 존재합니다.

약속된 스트림 ID: PUSH\_PROMISE에 의해 예약된 스트림을 식별하는 부호 없는 31비트 정수입니다. 약속된 스트림 식별자는 발신자가 보낸 다음 스트림에 대해 유효한 선택이어야 합니다\(섹션 5.1.1의 "새 스트림 식별자" 참조\).\(MUST\)

필드 블록 조각: 필드 블록 조각\(섹션 4.3\)

- 요청 제어 데이터 및 헤더 섹션을 포함합니다.

패딩: 애플리케이션 시맨틱 값을 포함하지 않는 패딩 옥텟. 보낼 때 패딩 옥텟을 0으로 설정해야 합니다. 수신자는 패딩을 확인할 의무가 없지만 0이 아닌 패딩을 PROTOCOL\_ERROR 유형의 연결 오류\(섹션 5.4.1\)로 처리할 수 있습니다\(MAY\).\(MUST, MAY\)

PUSH\_PROMISE 프레임은 다음 플래그를 정의합니다.

PADDED\(0x08\): 설정되면 PADDED 플래그는 패드 길이 필드와 여기에 설명된 패딩이 있음을 나타냅니다.

END\_HEADERS\(0x04\): 설정되면 END\_HEADERS 플래그는 이 프레임이 전체 필드 블록\(섹션 4.3\)을 포함하고 어떤 CONTINUATION 프레임도 뒤따르지 않는다는 것을 나타냅니다.

- END\_HEADERS 플래그가 설정되지 않은 PUSH\_PROMISE 프레임 뒤에는 동일한 스트림에 대한 CONTINUATION 프레임이 와야 합니다. 수신기는 다른 유형의 프레임 또는 다른 스트림의 프레임 수신을 PROTOCOL\_ERROR 유형의 연결 오류\(섹션 5.4.1\)로 처리해야 합니다.\(MUST, MUST\)

PUSH\_PROMISE 프레임은 "개방" 또는 "반폐쇄\(원격\)" 상태에 있는 피어 시작 스트림에서만 전송되어야 합니다. PUSH\_PROMISE 프레임의 스트림 식별자는 연결된 스트림을 나타냅니다. 스트림 식별자 필드가 값 0x00을 지정하는 경우 수신자는 PROTOCOL\_ERROR 유형의 연결 오류\(섹션 5.4.1\)로 응답해야 합니다.\(MUST, MUST\)

약속된 스트림은 약속된 순서대로 사용할 필요가 없습니다. PUSH\_PROMISE는 나중에 사용할 수 있도록 스트림 식별자만 예약합니다.

피어 끝점의 SETTINGS\_ENABLE\_PUSH 설정이 0으로 설정된 경우 PUSH\_PROMISE를 보내면 안 됩니다. 이 설정을 설정하고 승인을 받은 끝점은 PUSH\_PROMISE 프레임 수신을 PROTOCOL\_ERROR 유형의 연결 오류\(섹션 5.4.1\)로 처리해야 합니다. .\(MUST NOT, MUST\)

PUSH\_PROMISE 프레임의 수신자는 약속된 스트림 식별자를 참조하는 RST\_STREAM을 PUSH\_PROMISE의 발신자에게 다시 반환하여 약속된 스트림을 거부하도록 선택할 수 있습니다.

PUSH\_PROMISE 프레임은 두 가지 방식으로 연결 상태를 수정합니다. 첫째, 필드 블록\(섹션 4.3\)의 포함은 필드 섹션 압축을 위해 유지되는 상태를 잠재적으로 수정합니다. 둘째, PUSH\_PROMISE는 나중에 사용할 수 있도록 스트림을 예약하여 약속된 스트림이 "예약됨\(로컬\)" 또는 "예약됨\(원격\)" 상태가 되도록 합니다. 송신자는 스트림이 "개방" 또는 "반 폐쇄\(원격\)"가 아닌 한 스트림에서 PUSH\_PROMISE를 보내면 안 됩니다\(MUST NOT\). 발신자는 약속된 스트림이 새로운 스트림 식별자\(섹션 5.1.1\)에 대해 유효한 선택인지 확인해야 합니다\(즉, 약속된 스트림이 "유휴" 상태에 있어야 함\).\(MUST NOT\)

PUSH\_PROMISE는 스트림을 예약하므로 PUSH\_PROMISE 프레임을 무시하면 스트림 상태가 불확실해집니다. 수신자는 PROTOCOL\_ERROR 유형의 연결 오류\(섹션 5.4.1\)로 "개방"도 "반폐쇄\(로컬\)"도 아닌 스트림에서 PUSH\_PROMISE 수신을 처리해야 합니다. 그러나 연결된 스트림에서 RST\_STREAM을 보낸 엔드포인트는 RST\_STREAM 프레임을 수신하고 처리하기 전에 생성되었을 수 있는 PUSH\_PROMISE 프레임을 처리해야 합니다.\(MUST, MUST\)

수신자는 잘못된 스트림 식별자\(섹션 5.1.1\)를 약속하는 PUSH\_PROMISE의 수신을 PROTOCOL\_ERROR 유형의 연결 오류\(섹션 5.4.1\)로 처리해야 합니다. 잘못된 스트림 식별자는 현재 "유휴" 상태가 아닌 스트림의 식별자입니다.\(MUST\)

패딩 옥텟의 총 수는 패드 길이 필드의 값으로 결정됩니다. 패딩 길이가 프레임 페이로드 길이 이상인 경우 수신자는 이를 PROTOCOL\_ERROR 유형의 연결 오류\(섹션 5.4.1\)로 처리해야 합니다.\(MUST\)

| 참고: 프레임 크기는 한 옥텟씩 증가할 수 있습니다.

- | 값이 0인 패드 길이 필드를 포함합니다.

---
### **6.7.  PING**

PING 프레임\(유형=0x06\)은 발신자로부터의 최소 왕복 시간을 측정하고 유휴 연결이 여전히 작동하는지 여부를 결정하기 위한 메커니즘입니다. PING 프레임은 모든 끝점에서 보낼 수 있습니다.

```text
   PING Frame {
     Length (24) = 0x08,
     Type (8) = 0x06,

     Unused Flags (7),
     ACK Flag (1),

     Reserved (1),
     Stream Identifier (31) = 0,

     Opaque Data (64),
   }

                        Figure 9: PING Frame Format
```

길이, 유형, 미사용 플래그, 예약됨 및 스트림 식별자 필드는 섹션 4에서 설명합니다.

프레임 헤더 외에도 PING 프레임은 프레임 페이로드에 8옥텟의 불투명 데이터를 포함해야 합니다. 발신자는 선택한 모든 값을 포함할 수 있으며 해당 옥텟을 어떤 방식으로든 사용할 수 있습니다.\(MUST\)

ACK 플래그를 포함하지 않는 PING 프레임의 수신자는 응답으로 동일한 프레임 페이로드와 함께 ACK 플래그가 설정된 PING 프레임을 보내야 합니다. PING 응답은 다른 프레임보다 높은 우선 순위를 부여받아야 합니다\(SHOULD\).\(MUST, SHOULD\)

PING 프레임은 다음 플래그를 정의합니다.

ACK\(0x01\): 설정되면 ACK 플래그는 이 PING 프레임이 PING 응답임을 나타냅니다. 엔드포인트는 PING 응답에서 이 플래그를 설정해야 합니다. 엔드포인트는 이 플래그를 포함하는 PING 프레임에 응답하면 안 됩니다\(MUST NOT\).\(MUST, MUST NOT\)

PING 프레임은 개별 스트림과 연결되지 않습니다. 스트림 식별자 필드 값이 0x00이 아닌 PING 프레임이 수신되면 수신자는 PROTOCOL\_ERROR 유형의 연결 오류\(섹션 5.4.1\)로 응답해야 합니다.\(MUST\)

길이 필드 값이 8이 아닌 PING 프레임의 수신은 FRAME\_SIZE\_ERROR 유형의 연결 오류\(섹션 5.4.1\)로 처리되어야 합니다.\(MUST\)

---
### **6.8.  GOAWAY**

GOAWAY 프레임\(유형=0x07\)은 연결 종료를 시작하거나 심각한 오류 상태를 알리는 데 사용됩니다. GOAWAY를 사용하면 엔드포인트가 이전에 설정된 스트림의 처리를 계속 완료하면서 새 스트림 수락을 정상적으로 중지할 수 있습니다. 이를 통해 서버 유지 관리와 같은 관리 작업을 수행할 수 있습니다.

새 스트림을 시작하는 끝점과 GOAWAY 프레임을 보내는 원격 피어 사이에는 고유한 경쟁 조건이 있습니다. 이 경우를 처리하기 위해 GOAWAY에는 이 연결의 송신 끝점에서 처리되었거나 처리될 수 있는 마지막 피어 시작 스트림의 스트림 식별자가 포함됩니다. 예를 들어 서버가 GOAWAY 프레임을 보내는 경우 식별된 스트림은 클라이언트에서 시작한 가장 높은 번호의 스트림입니다.

GOAWAY가 전송되면 스트림에 포함된 마지막 스트림 식별자보다 높은 식별자가 있는 경우 보낸 사람은 수신자가 시작한 스트림에서 보낸 프레임을 무시합니다. GOAWAY 프레임의 수신기는 새 스트림에 대해 새 연결을 설정할 수 있지만 연결에서 추가 스트림을 열면 안 됩니다\(MUST NOT\).\(MUST NOT\)

GOAWAY의 수신자가 GOAWAY 프레임에 표시된 것보다 더 높은 스트림 식별자가 있는 스트림에서 데이터를 보낸 경우 해당 스트림은 처리되지 않거나 처리되지 않습니다. GOAWAY 프레임의 수신자는 스트림을 전혀 생성되지 않은 것처럼 처리할 수 있으므로 나중에 새 연결에서 해당 스트림을 다시 시도할 수 있습니다.

엔드포인트는 원격 피어가 스트림이 부분적으로 처리되었는지 여부를 알 수 있도록 연결을 닫기 전에 항상 GOAWAY 프레임을 보내야 합니다\(SHOULD\). 예를 들어 HTTP 클라이언트가 서버가 연결을 닫는 것과 동시에 POST를 보내는 경우 서버가 어떤 스트림이 있는지 표시하기 위해 GOAWAY 프레임을 보내지 않으면 클라이언트는 서버가 해당 POST 요청을 처리하기 시작했는지 알 수 없습니다. 행동했다.\(SHOULD\)

엔드포인트는 오작동하는 피어에 대해 GOAWAY를 보내지 않고 연결을 닫도록 선택할 수 있습니다.

GOAWAY 프레임은 연결 종료 바로 앞에 있지 않을 수 있습니다. 더 이상 연결을 사용하지 않는 GOAWAY의 수신기는 연결을 종료하기 전에 여전히 GOAWAY 프레임을 보내야 합니다\(SHOULD\).\(SHOULD\)

```text
   GOAWAY Frame {
     Length (24),
     Type (8) = 0x07,

     Unused Flags (8),

     Reserved (1),
     Stream Identifier (31) = 0,

     Reserved (1),
     Last-Stream-ID (31),
     Error Code (32),
     Additional Debug Data (..),
   }

                       Figure 10: GOAWAY Frame Format
```

길이, 유형, 미사용 플래그, 예약됨 및 스트림 식별자 필드는 섹션 4에서 설명합니다.

GOAWAY 프레임은 플래그를 정의하지 않습니다.

GOAWAY 프레임은 특정 스트림이 아닌 연결에 적용됩니다. 끝점은 0x00 이외의 스트림 식별자를 가진 GOAWAY 프레임을 PROTOCOL\_ERROR 유형의 연결 오류\(섹션 5.4.1\)로 처리해야 합니다.\(MUST\)

GOAWAY 프레임의 마지막 스트림 식별자에는 GOAWAY 프레임의 발신자가 조치를 취했거나 아직 조치를 취하지 않은 가장 높은 번호의 스트림 식별자가 포함됩니다. 식별된 스트림까지의 모든 스트림은 어떤 방식으로든 처리되었을 수 있습니다. 스트림이 처리되지 않은 경우 마지막 스트림 식별자를 0으로 설정할 수 있습니다.

- | 참고: 이 문맥에서 "처리됨"은 | 스트림은 소프트웨어의 일부 상위 계층으로 전달되었습니다. | 결과적으로 조치를 취했을 수 있습니다.

GOAWAY 프레임 없이 연결이 종료되면 마지막 스트림 식별자는 사실상 가능한 가장 높은 스트림 식별자입니다.

연결이 닫히기 전에 완전히 닫히지 않은 더 낮거나 같은 번호의 식별자가 있는 스트림에서는 HTTP GET, PUT 또는 DELETE와 같은 idempotent 작업을 제외하고 요청, 트랜잭션 또는 프로토콜 활동을 다시 시도할 수 없습니다. 더 높은 번호의 스트림을 사용하는 모든 프로토콜 활동은 새 연결을 사용하여 안전하게 재시도할 수 있습니다.

마지막 스트림 식별자보다 작거나 같은 번호가 매겨진 스트림의 활동은 여전히 ​​성공적으로 완료될 수 있습니다. GOAWAY 프레임의 발신자는 진행 중인 모든 스트림이 완료될 때까지 연결을 "열린" 상태로 유지하면서 GOAWAY 프레임을 전송하여 연결을 정상적으로 종료할 수 있습니다.

엔드포인트는 상황이 바뀌면 여러 GOAWAY 프레임을 보낼 수 있습니다. 예를 들어 정상적인 종료 중에 NO\_ERROR와 함께 GOAWAY를 전송하는 엔드포인트는 이후 연결을 즉시 종료해야 하는 상황에 직면할 수 있습니다. 수신된 마지막 GOAWAY 프레임의 마지막 스트림 식별자는 어떤 스트림이 작동될 수 있었는지 나타냅니다. 엔드포인트는 피어가 이미 다른 연결에서 처리되지 않은 요청을 재시도했을 수 있으므로 마지막 스트림 식별자에서 보내는 값을 증가시켜서는 안 됩니다\(MUST NOT\).\(MAY, MUST NOT\)

요청을 재시도할 수 없는 클라이언트는 서버가 연결을 닫을 때 진행 중인 모든 요청을 잃게 됩니다. 이것은 특히 HTTP/2를 사용하여 클라이언트에 서비스를 제공하지 않을 수 있는 중개자에게 해당됩니다. 연결을 정상적으로 종료하려고 시도하는 서버는 마지막 스트림 식별자가 2^31-1로 설정된 초기 GOAWAY 프레임과 NO\_ERROR 코드를 보내야 합니다\(SHOULD\). 이는 종료가 임박했으며 추가 요청 시작이 금지됨을 클라이언트에 알립니다. 진행 중인 스트림 생성을 위한 시간\(적어도 한 번의 왕복 시간\)을 허용한 후 서버는 업데이트된 마지막 스트림 식별자와 함께 다른 GOAWAY 프레임을 보낼 수 있습니다. 이렇게 하면 요청 손실 없이 연결을 완전히 종료할 수 있습니다.\(SHOULD, MAY\)

GOAWAY 프레임을 보낸 후 발신자는 식별된 마지막 스트림보다 높은 식별자를 가진 수신자가 시작한 스트림의 프레임을 버릴 수 있습니다. 그러나 연결 상태를 변경하는 프레임은 완전히 무시할 수 없습니다. 예를 들어 HEADERS, PUSH\_PROMISE 및 CONTINUATION 프레임은 필드 섹션 압축을 위해 유지되는 상태가 일관되도록 최소한으로 처리되어야 합니다\(섹션 4.3 참조\). 마찬가지로 DATA 프레임은 연결 흐름 제어 창으로 계산되어야 합니다. 이러한 프레임을 처리하지 못하면 흐름 제어 또는 필드 섹션 압축 상태가 동기화되지 않을 수 있습니다.\(MUST\)

GOAWAY 프레임에는 연결 종료 이유가 포함된 32비트 오류 코드\(섹션 7\)도 포함되어 있습니다.

엔드포인트는 모든 GOAWAY 프레임의 프레임 페이로드에 불투명 데이터를 추가할 수 있습니다\(MAY\). 추가 디버그 데이터는 진단 목적으로만 사용되며 의미론적 값을 전달하지 않습니다. 디버그 정보에는 보안 또는 개인 정보에 민감한 데이터가 포함될 수 있습니다. 기록되거나 지속적으로 저장된 디버그 데이터에는 무단 액세스를 방지하기 위한 적절한 보호 장치가 있어야 합니다.\(MAY, MUST\)

---
### **6.9.  WINDOW_UPDATE**

WINDOW\_UPDATE 프레임\(유형=0x08\)은 흐름 제어를 구현하는 데 사용됩니다. 개요는 섹션 5.2를 참조하십시오.

흐름 제어는 각 개별 스트림과 전체 연결의 두 가지 수준에서 작동합니다.

두 흐름 제어 유형 모두 홉 바이 홉입니다. 즉, 두 끝점 사이에서만 가능합니다. 중개자는 종속 연결 간에 WINDOW\_UPDATE 프레임을 전달하지 않습니다. 그러나 수신자에 의한 데이터 전송 제한은 간접적으로 원래 발신자를 향한 흐름 제어 정보의 전파를 유발할 수 있습니다.

흐름 제어는 흐름 제어 대상으로 식별된 프레임에만 적용됩니다. 이 문서에 정의된 프레임 유형 중 DATA 프레임만 포함됩니다. 흐름 제어에서 제외된 프레임은 수신기가 프레임 처리에 리소스를 할당할 수 없는 경우가 아니면 수락 및 처리되어야 합니다. 수신기는 프레임을 수락할 수 없는 경우 FLOW\_CONTROL\_ERROR 유형의 스트림 오류\(섹션 5.4.2\) 또는 연결 오류\(섹션 5.4.1\)로 응답할 수 있습니다\(MAY\).\(MUST, MAY\)

```text
   WINDOW_UPDATE Frame {
     Length (24) = 0x04,
     Type (8) = 0x08,

     Unused Flags (8),

     Reserved (1),
     Stream Identifier (31),

     Reserved (1),
     Window Size Increment (31),
   }

                   Figure 11: WINDOW_UPDATE Frame Format
```

길이, 유형, 미사용 플래그\(들\), 예약됨 및 스트림 식별자 필드는 섹션 4에서 설명합니다. WINDOW\_UPDATE 프레임의 프레임 페이로드는 예약된 비트 1개와 송신자가 보낼 수 있는 옥텟 수를 나타내는 부호 없는 31비트 정수입니다. 기존 흐름 제어 창에 추가로 전송합니다. 흐름 제어 창에 대한 증분의 법적 범위는 1에서 2^31-1\(2,147,483,647\) 옥텟입니다.

WINDOW\_UPDATE 프레임은 플래그를 정의하지 않습니다.

WINDOW\_UPDATE 프레임은 스트림 또는 전체 연결에 고유할 수 있습니다. 전자의 경우 프레임의 스트림 식별자는 영향을 받는 스트림을 나타냅니다. 후자에서 값 "0"은 전체 연결이 프레임의 주체임을 나타냅니다.

수신기는 흐름 제어 창 증분이 0인 WINDOW\_UPDATE 프레임의 수신을 PROTOCOL\_ERROR 유형의 스트림 오류\(섹션 5.4.2\)로 처리해야 합니다. 연결 흐름 제어 창의 오류는 연결 오류로 처리되어야 합니다\(섹션 5.4.1\).\(MUST\)

WINDOW\_UPDATE는 END\_STREAM 플래그가 설정된 프레임을 보낸 피어가 보낼 수 있습니다. 이는 수신자가 "반쯤 닫힌\(원격\)" 또는 "닫힌" 상태의 스트림에서 WINDOW\_UPDATE 프레임을 수신할 수 있음을 의미합니다. 수신기는 이것을 오류로 취급해서는 안 됩니다\(섹션 5.1 참조\).\(MUST NOT\)

흐름 제어 프레임을 수신하는 수신자는 수신자가 이를 연결 오류\(섹션 5.4.1\)로 처리하지 않는 한 연결 흐름 제어 창에 대한 기여도를 항상 설명해야 합니다. 이는 프레임에 오류가 있는 경우에도 필요합니다. 발신자는 흐름 제어 창을 향해 프레임을 계산하지만 수신자가 계산하지 않으면 발신자와 수신자의 흐름 제어 창이 달라질 수 있습니다.\(MUST\)

길이가 4 옥텟이 아닌 WINDOW\_UPDATE 프레임은 FRAME\_SIZE\_ERROR 유형의 연결 오류\(섹션 5.4.1\)로 처리해야 합니다.\(MUST\)

---
#### **6.9.1.  The Flow-Control Window**

HTTP/2의 흐름 제어는 모든 스트림에서 각 발신자가 보관하는 창을 사용하여 구현됩니다. 흐름 제어 창은 보낸 사람이 전송할 수 있는 데이터 옥텟 수를 나타내는 간단한 정수 값입니다. 따라서 그 크기는 수신기의 버퍼링 용량을 측정한 것입니다.

스트림 흐름 제어 창과 연결 흐름 제어 창의 두 가지 흐름 제어 창을 적용할 수 있습니다. 발신자는 수신자가 광고한 흐름 제어 창 중 하나에서 사용 가능한 공간을 초과하는 길이의 흐름 제어 프레임을 보내면 안 됩니다\(MUST NOT\). END\_STREAM 플래그가 설정된 길이가 0인 프레임\(즉, 빈 DATA 프레임\)은 흐름 제어 창에 사용 가능한 공간이 없는 경우 전송될 수 있습니다\(MAY\).\(MUST NOT, MAY\)

흐름 제어 계산의 경우 9옥텟 프레임 헤더는 계산되지 않습니다.

흐름 제어 프레임을 보낸 후 보낸 사람은 전송된 프레임의 길이만큼 두 창에서 사용 가능한 공간을 줄입니다.

프레임의 수신자는 데이터를 소비하고 흐름 제어 창의 공간을 확보하면서 WINDOW\_UPDATE 프레임을 보냅니다. 스트림 및 연결 수준 흐름 제어 창에 대해 별도의 WINDOW\_UPDATE 프레임이 전송됩니다. 수신자는 매우 작은 증분으로 WINDOW\_UPDATE 프레임을 전송하지 않도록 메커니즘을 마련하는 것이 좋습니다. \[RFC1122\]의 섹션 4.2.3.3을 참조하십시오.

WINDOW\_UPDATE 프레임을 수신한 발신자는 프레임에 지정된 양만큼 해당 창을 업데이트합니다.

발신자는 흐름 제어 창이 2^31-1 옥텟을 초과하도록 허용해서는 안 됩니다\(MUST NOT\). 발신자가 흐름 제어 창이 이 최대값을 초과하게 하는 WINDOW\_UPDATE를 수신하는 경우 스트림 또는 연결을 적절하게 종료해야 합니다. 스트림의 경우 발신자는 오류 코드가 FLOW\_CONTROL\_ERROR인 RST\_STREAM을 보냅니다. 연결을 위해 오류 코드가 FLOW\_CONTROL\_ERROR인 GOAWAY 프레임이 전송됩니다.\(MUST NOT, MUST\)

송신자의 흐름 제어 프레임과 수신자의 WINDOW\_UPDATE 프레임은 서로 완전히 비동기식입니다. 이 속성을 사용하면 수신자가 송신자가 유지하는 창 크기를 적극적으로 업데이트하여 스트림이 중단되지 않도록 할 수 있습니다.

---
#### **6.9.2.  Initial Flow-Control Window Size**

HTTP/2 연결이 처음 설정되면 초기 흐름 제어 창 크기가 65,535옥텟인 새 스트림이 생성됩니다. 연결 흐름 제어 창도 65,535옥텟입니다. 두 끝점 모두 SETTINGS 프레임에 SETTINGS\_INITIAL\_WINDOW\_SIZE 값을 포함하여 새 스트림의 초기 창 크기를 조정할 수 있습니다. 연결 흐름 제어 창은 WINDOW\_UPDATE 프레임을 사용해서만 변경할 수 있습니다.

SETTINGS\_INITIAL\_WINDOW\_SIZE에 대한 값을 설정하는 SETTINGS 프레임을 수신하기 전에 엔드포인트는 흐름 제어 프레임을 보낼 때 기본 초기 창 크기만 사용할 수 있습니다. 마찬가지로 연결 흐름 제어 창은 WINDOW\_UPDATE 프레임이 수신될 때까지 기본 초기 창 크기를 기반으로 설정됩니다.

아직 활성화되지 않은 스트림에 대한 흐름 제어 창을 변경하는 것 외에도 SETTINGS 프레임은 활성 흐름 제어 창이 있는 스트림의 초기 흐름 제어 창 크기를 변경할 수 있습니다. -폐쇄\(원격\)" 상태\). SETTINGS\_INITIAL\_WINDOW\_SIZE 값이 변경되면 수신기는 새 값과 이전 값의 차이만큼 유지하는 모든 스트림 흐름 제어 창의 크기를 조정해야 합니다.\(MUST\)

SETTINGS\_INITIAL\_WINDOW\_SIZE를 변경하면 흐름 제어 창에서 사용 가능한 공간이 음수가 될 수 있습니다. 발신자는 음의 흐름 제어 창을 추적해야 하며 흐름 제어 창이 양수가 되도록 하는 WINDOW\_UPDATE 프레임을 수신할 때까지 새 흐름 제어 프레임을 보내서는 안 됩니다\(MUST NOT\).\(MUST NOT\)

예를 들어 클라이언트가 연결 설정 즉시 60KB를 보내고 서버가 초기 창 크기를 16KB로 설정하면 클라이언트는 SETTINGS 프레임 수신 시 사용 가능한 흐름 제어 창을 -44KB로 다시 계산합니다. 클라이언트는 WINDOW\_UPDATE 프레임이 창을 양수로 복원할 때까지 음수 흐름 제어 창을 유지한 후 클라이언트가 전송을 재개할 수 있습니다.

SETTINGS 프레임은 연결 흐름 제어 창을 변경할 수 없습니다.

엔드포인트는 흐름 제어 창이 최대 크기를 초과하도록 하는 SETTINGS\_INITIAL\_WINDOW\_SIZE의 변경을 FLOW\_CONTROL\_ERROR 유형의 연결 오류\(섹션 5.4.1\)로 처리해야 합니다.\(MUST\)

---
#### **6.9.3.  Reducing the Stream Window Size**

현재 크기보다 작은 흐름 제어 창을 사용하려는 수신기는 새 SETTINGS 프레임을 보낼 수 있습니다. 그러나 송신자가 SETTINGS 프레임을 처리하기 전에 하한을 초과하는 데이터를 보낼 수 있으므로 수신자는 이 창 크기를 초과하는 데이터를 수신할 준비가 되어 있어야 합니다.\(MUST\)

초기 흐름 제어 창 크기를 줄이는 SETTINGS 프레임을 보낸 후 수신기는 흐름 제어 제한을 초과하는 스트림을 계속 처리할 수 있습니다. 스트림이 계속되도록 허용해도 수신자는 흐름 제어 창을 위해 예약한 공간을 즉시 줄일 수 없습니다. 발신자가 전송을 다시 시작하려면 WINDOW\_UPDATE 프레임이 필요하기 때문에 이러한 스트림의 진행이 지연될 수도 있습니다. 수신자는 대신 영향을 받는 스트림에 대해 오류 코드 FLOW\_CONTROL\_ERROR와 함께 RST\_STREAM을 보낼 수 있습니다\(MAY\).\(MAY, MAY\)

---
### **6.10.  CONTINUATION**

CONTINUATION 프레임\(유형=0x09\)은 일련의 필드 블록 조각을 계속하는 데 사용됩니다\(섹션 4.3\). 이전 프레임이 동일한 스트림에 있고 END\_HEADERS 플래그가 설정되지 않은 HEADERS, PUSH\_PROMISE 또는 CONTINUATION 프레임인 한 개수에 관계없이 CONTINUATION 프레임을 보낼 수 있습니다.

```text
   CONTINUATION Frame {
     Length (24),
     Type (8) = 0x09,

     Unused Flags (5),
     END_HEADERS Flag (1),
     Unused Flags (2),

     Reserved (1),
     Stream Identifier (31),

     Field Block Fragment (..),
   }

                    Figure 12: CONTINUATION Frame Format
```

길이, 유형, 미사용 플래그, 예약됨 및 스트림 식별자 필드는 섹션 4에서 설명합니다. CONTINUATION 프레임 페이로드에는 필드 블록 조각\(섹션 4.3\)이 포함됩니다.

CONTINUATION 프레임은 다음 플래그를 정의합니다.

END\_HEADERS\(0x04\): 설정되면 END\_HEADERS 플래그는 이 프레임이 필드 블록을 종료함을 나타냅니다\(섹션 4.3\).

- END\_HEADERS 플래그가 설정되지 않은 경우 이 프레임 다음에 다른 CONTINUATION 프레임이 와야 합니다. 수신기는 다른 유형의 프레임 또는 다른 스트림의 프레임 수신을 PROTOCOL\_ERROR 유형의 연결 오류\(섹션 5.4.1\)로 처리해야 합니다.\(MUST, MUST\)

CONTINUATION 프레임은 섹션 4.3에 정의된 대로 연결 상태를 변경합니다.

CONTINUATION 프레임은 반드시 스트림과 연결되어야 합니다. 연속 프레임이 스트림 식별자 필드 0x00으로 수신되면 수신자는 PROTOCOL\_ERROR 유형의 연결 오류\(섹션 5.4.1\)로 응답해야 합니다.\(MUST, MUST\)

CONTINUATION 프레임 앞에는 END\_HEADERS 플래그가 설정되지 않은 HEADERS, PUSH\_PROMISE 또는 CONTINUATION 프레임이 있어야 합니다. 이 규칙 위반을 관찰한 수신자는 PROTOCOL\_ERROR 유형의 연결 오류\(섹션 5.4.1\)로 응답해야 합니다.\(MUST, MUST\)

---
## **7.  Error Codes**

오류 코드는 스트림 또는 연결 오류의 원인을 전달하기 위해 RST\_STREAM 및 GOAWAY 프레임에 사용되는 32비트 필드입니다.

오류 코드는 공통 코드 공간을 공유합니다. 일부 오류 코드는 스트림 또는 전체 연결에만 적용되며 다른 컨텍스트에는 정의된 의미 체계가 없습니다.

다음 오류 코드가 정의됩니다.

NO\_ERROR\(0x00\): 연결된 조건이 오류의 결과가 아닙니다. 예를 들어 GOAWAY에는 연결의 정상적인 종료를 나타내기 위해 이 코드가 포함될 수 있습니다.

PROTOCOL\_ERROR\(0x01\): 엔드포인트에서 불특정 프로토콜 오류를 감지했습니다. 이 오류는 더 구체적인 오류 코드를 사용할 수 없을 때 사용합니다.

INTERNAL\_ERROR\(0x02\): 엔드포인트에 예기치 않은 내부 오류가 발생했습니다.

FLOW\_CONTROL\_ERROR\(0x03\): 엔드포인트에서 피어가 흐름 제어 프로토콜을 위반했음을 감지했습니다.

SETTINGS\_TIMEOUT\(0x04\): 엔드포인트가 SETTINGS 프레임을 보냈지만 적시에 응답을 받지 못했습니다. 섹션 6.5.3\("설정 동기화"\)을 참조하십시오.

STREAM\_CLOSED\(0x05\): 스트림이 반쯤 닫힌 후 끝점이 프레임을 수신했습니다.

FRAME\_SIZE\_ERROR\(0x06\): 엔드포인트가 유효하지 않은 크기의 프레임을 수신했습니다.

REFUSED\_STREAM\(0x07\): 엔드포인트가 애플리케이션 처리를 수행하기 전에 스트림을 거부했습니다\(자세한 내용은 섹션 8.7 참조\).

CANCEL\(0x08\): 엔드포인트는 이 오류 코드를 사용하여 스트림이 더 이상 필요하지 않음을 나타냅니다.

COMPRESSION\_ERROR\(0x09\): 끝점이 연결에 대한 필드 섹션 압축 컨텍스트를 유지할 수 없습니다.

CONNECT\_ERROR\(0x0a\): CONNECT 요청\(섹션 8.5\)에 대한 응답으로 설정된 연결이 재설정되었거나 비정상적으로 닫혔습니다.

ENHANCE\_YOUR\_CALM\(0x0b\): 엔드포인트에서 피어가 과도한 로드를 생성할 수 있는 동작을 나타내고 있음을 감지했습니다.

INADEQUATE\_SECURITY\(0x0c\): 기본 전송에 최소 보안 요구 사항을 충족하지 않는 속성이 있습니다\(섹션 9.2 참조\).

HTTP\_1\_1\_REQUIRED\(0x0d\): 끝점에서 HTTP/2 대신 HTTP/1.1을 사용해야 합니다.\(MUST\)

알 수 없거나 지원되지 않는 오류 코드는 특별한 동작을 트리거해서는 안 됩니다\(MUST NOT\). 이들은 구현에 의해 INTERNAL\_ERROR와 동등한 것으로 처리될 수 있습니다\(MAY\).\(MUST NOT, MAY\)

---
## **8.  Expressing HTTP Semantics in HTTP/2**

HTTP/2는 HTTP 메시지 추상화\(\[HTTP\]의 섹션 6\)의 인스턴스화입니다.

---
### **8.1.  HTTP Message Framing**

클라이언트는 이전에 사용하지 않은 스트림 식별자\(섹션 5.1.1\)를 사용하여 새 스트림에서 HTTP 요청을 보냅니다. 서버는 요청과 동일한 스트림에서 HTTP 응답을 보냅니다.

HTTP 메시지\(요청 또는 응답\)는 다음으로 구성됩니다.

```text
   1.  one HEADERS frame (followed by zero or more CONTINUATION frames)
       containing the header section (see Section 6.3 of [HTTP]),
```

2. 메시지 내용을 포함하는 0개 이상의 DATA 프레임\(\[HTTP\]의 섹션 6.4 참조\)

3. 선택적으로, 하나의 HEADERS 프레임\(0 또는 그 이상

- CONTINUATION 프레임\) 트레일러 섹션이 있는 경우 이를 포함합니다\(\[HTTP\]의 섹션 6.5 참조\).

응답의 경우에만 서버가 최종 응답을 포함하는 HEADERS 프레임 전에 임시 응답을 얼마든지 보낼 수 있습니다. 중간 응답은 중간\(1xx\) HTTP 응답의 제어 데이터 및 헤더 섹션을 포함하는 HEADERS 프레임\(0개 이상의 CONTINUATION 프레임이 뒤따를 수 있음\)으로 구성됩니다\(\[HTTP\]의 섹션 15 참조\). 정보 상태 코드를 전달하는 END\_STREAM 플래그 세트가 있는 HEADERS 프레임은 잘못된 형식입니다\(섹션 8.1.1\).\(MAY\)

시퀀스의 마지막 프레임에는 END\_STREAM 플래그가 있습니다. 즉, END\_STREAM 플래그가 설정된 HEADERS 프레임 뒤에는 필드 블록의 나머지 조각을 전달하는 CONTINUATION 프레임이 올 수 있습니다.

다른 프레임\(모든 스트림의\)은 HEADERS 프레임과 뒤따를 수 있는 CONTINUATION 프레임 사이에 발생해서는 안 됩니다.\(MUST NOT\)

HTTP/2는 DATA 프레임을 사용하여 메시지 내용을 전달합니다. \[HTTP/1.1\]의 섹션 7.1에 정의된 청크 분할 전송 인코딩은 HTTP/2에서 사용할 수 없습니다. 섹션 8.2.2를 참조하십시오.

트레일러 필드는 스트림을 종료하는 필드 블록에서 전달됩니다. 즉, 트레일러 필드는 HEADERS 프레임으로 시작하여 0개 이상의 CONTINUATION 프레임이 뒤따르는 시퀀스로 구성되며, HEADERS 프레임에는 END\_STREAM 플래그가 포함됩니다. 트레일러는 의사 헤더 필드를 포함하면 안 됩니다\(섹션 8.3\). 트레일러에서 의사 헤더 필드를 수신하는 엔드포인트는 요청 또는 응답을 잘못된 형식으로 처리해야 합니다\(섹션 8.1.1\).\(MUST NOT, MUST\)

요청을 여는 HEADERS 프레임을 수신한 후 또는 최종\(정보가 아닌\) 상태 코드를 수신한 후 END\_STREAM 플래그 세트 없이 HEADERS 프레임을 수신하는 엔드포인트는 해당 요청 또는 응답을 잘못된 형식으로 처리해야 합니다\(섹션 8.1.1\).\(MUST\)

HTTP 요청/응답 교환은 단일 스트림을 완전히 사용합니다. 요청은 스트림을 "열림" 상태로 만드는 HEADERS 프레임으로 시작됩니다. 요청은 END\_STREAM 플래그가 설정된 프레임으로 끝납니다. 이로 인해 스트림이 클라이언트에 대해 "반 폐쇄\(로컬\)"되고 서버에 대해 "반 폐쇄\(원격\)"가 됩니다. 응답 스트림은 HEADERS 프레임에서 0개 이상의 중간 응답으로 시작하고 최종 상태 코드를 포함하는 HEADERS 프레임이 이어집니다.

HTTP 응답은 서버가 END\_STREAM 플래그가 설정된 프레임\(필드 블록을 완료하는 데 필요한 모든 CONTINUATION 프레임 포함\)을 전송하거나 클라이언트가 수신한 후에 완료됩니다. 응답이 전송 및 수신되지 않은 요청 부분에 의존하지 않는 경우 서버는 클라이언트가 전체 요청을 전송하기 전에 완전한 응답을 전송할 수 있습니다. 이것이 참일 때 서버는 완전한 응답\(즉, END\_STREAM 플래그가 설정된 프레임\)을 보낸 후 오류 코드가 NO\_ERROR인 RST\_STREAM을 보내 클라이언트가 오류 없이 요청 전송을 중단하도록 요청할 수 있습니다\(MAY\). 클라이언트는 이러한 RST\_STREAM을 수신한 결과로 응답을 버리면 안 됩니다\(MUST NOT\). 클라이언트는 다른 이유로 항상 재량에 따라 응답을 버릴 수 있습니다.\(MAY, MUST NOT\)

---
#### **8.1.1.  Malformed Messages**

잘못된 형식의 요청 또는 응답은 HTTP/2 프레임의 유효한 시퀀스이지만 관련 없는 프레임, 금지된 필드 또는 의사 헤더 필드, 필수 의사 헤더 필드의 부재, 대문자 포함으로 인해 유효하지 않은 요청 또는 응답입니다. 필드 이름 또는 유효하지 않은 필드 이름 및/또는 값\(특정 상황에서; 섹션 8.2 참조\).

메시지 콘텐츠를 포함하는 요청 또는 응답에는 콘텐츠 길이 헤더 필드가 포함될 수 있습니다. 메시지가 콘텐츠가 없는 것으로 정의되지 않는 한 콘텐츠 길이 헤더 필드의 값이 콘텐츠를 구성하는 DATA 프레임 페이로드 길이의 합과 같지 않으면 요청 또는 응답도 잘못된 형식입니다. 예를 들어 204 또는 304 응답에는 HEAD 요청에 대한 응답과 마찬가지로 콘텐츠가 없습니다. \[HTTP\]의 섹션 6.4.1에 설명된 대로 내용이 없는 것으로 정의된 응답은 DATA 프레임에 내용이 포함되어 있지 않더라도 0이 아닌 내용 길이 헤더 필드를 가질 수 있습니다\(MAY\).\(MAY\)

HTTP 요청 또는 응답을 처리하는 중개자\(즉, 터널 역할을 하지 않는 중개자\)는 형식이 잘못된 요청 또는 응답을 전달해서는 안 됩니다\(MUST NOT\). 감지된 잘못된 요청 또는 응답은 PROTOCOL\_ERROR 유형의 스트림 오류\(섹션 5.4.2\)로 처리되어야 합니다.\(MUST NOT, MUST\)

형식이 잘못된 요청의 경우 서버는 스트림을 닫거나 재설정하기 전에 HTTP 응답을 보낼 수 있습니다\(MAY\). 클라이언트는 형식이 잘못된 응답을 수락해서는 안 됩니다\(MUST NOT\).\(MAY, MUST NOT\)

점진적으로 메시지를 처리하는 엔드포인트는 잘못된 형식의 요청 또는 응답을 식별하기 전에 일부 처리를 수행했을 수 있습니다. 예를 들어 완전한 요청을 받지 않고도 정보 또는 404 상태 코드를 생성할 수 있습니다. 마찬가지로 중개자는 오류를 감지하기 전에 불완전한 메시지를 전달할 수 있습니다. 응답이 올바른 요청의 나머지 부분에 의존하지 않는 경우 서버는 전체 요청을 수신하기 전에 최종 응답을 생성할 수 있습니다\(MAY\).\(MAY\)

이러한 요구 사항은 HTTP에 대한 여러 유형의 일반적인 공격으로부터 보호하기 위한 것입니다. 관대하면 구현이 이러한 취약점에 노출될 수 있기 때문에 의도적으로 엄격합니다.

---
### **8.2.  HTTP Fields**

HTTP 필드\(\[HTTP\]의 섹션 5\)는 HPACK \[COMPRESSION\]으로 압축된 HEADERS, CONTINUATION 및 PUSH\_PROMISE 프레임에서 HTTP/2에 의해 전달됩니다.

필드 이름은 HTTP/2 메시지를 구성할 때 소문자로 변환해야 합니다.\(MUST\)

---
#### **8.2.1.  Field Validity**

HTTP의 필드 이름 및 값 정의는 HPACK이 전달할 수 있는 일부 문자를 금지합니다. HTTP/2 구현은 각각 \[HTTP\]의 섹션 5.1과 5.5의 정의에 따라 필드 이름과 값을 검증하고 금지된 문자를 포함하는 메시지를 잘못된 형식으로 처리해야 합니다\(섹션 8.1.1\).\(SHOULD\)

필드 유효성 검사 실패는 요청 밀수 공격에 악용될 수 있습니다. 특히 캐리지 리턴\(CR\), 라인 피드\(LF\) 및 COLON과 같은 문자가 구분 기호로 사용되는 HTTP/1.1\[HTTP/1.1\]을 사용하여 메시지가 전달될 때 검증되지 않은 필드는 공격을 가능하게 할 수 있습니다. 구현은 필드 이름 및 값에 대해 다음과 같은 최소한의 유효성 검사를 수행해야 합니다.\(MUST\)

\* 필드 이름은 0x00-0x20, 0x41-0x5a 또는 0x7f-0xff 범위\(모든 범위 포함\)의 문자를 포함하면 안 됩니다. 이것은 특히 보이지 않는 모든 ASCII 문자, ASCII SP\(0x20\) 및 대문자\('A'에서 'Z', ASCII 0x41에서 0x5a\)를 제외합니다.\(MUST NOT\)

\* 하나의 콜론으로 시작하는 이름이 있는 의사 헤더 필드\(섹션 8.3\)를 제외하고 필드 이름에는 콜론\(ASCII COLON, 0x3a\)이 포함되어서는 안 됩니다.\(MUST NOT\)

\* 필드 값은 어떤 위치에서도 0 값\(ASCII NUL, 0x00\), 줄 바꿈\(ASCII LF, 0x0a\) 또는 캐리지 리턴\(ASCII CR, 0x0d\)을 포함하면 안 됩니다.\(MUST NOT\)

\* 필드 값은 ASCII 공백 문자\(ASCII SP 또는 HTAB, 0x20 또는 0x09\)로 시작하거나 끝나서는 안 됩니다\(MUST NOT\).\(MUST NOT\)

- | 참고: |에 따라 필드의 유효성을 검사하는 구현입니다. \[HTTP\] 섹션 5.1 및 5.5의 정의에는 | 필드 이름에 대문자가 포함되지 않는지 추가 확인 | 문자.

이러한 조건을 위반하는 필드를 포함하는 요청 또는 응답은 형식이 잘못된 것으로 처리해야 합니다\(섹션 8.1.1\). 특히, 메시지를 전달할 때 필드를 처리하지 않는 중개자는 위에 금지된 것으로 나열된 값을 포함하는 필드를 전달하면 안 됩니다\(MUST NOT\).\(MUST, MUST NOT\)

요청 메시지가 이러한 요구 사항 중 하나를 위반하면 구현은 400\(잘못된 요청\) 상태 코드\(\[HTTP\]의 섹션 15.5.1 참조\)를 생성해야 합니다. 예를 들어 트레일러 필드에서 오류가 발생하기 때문에\).\(SHOULD\)

| 참고: 에 따라 유효하지 않은 필드 값

- | 해당 필드의 정의로 인해 요청이 발생하지 않습니다. | 형식이 잘못되었습니다. 위의 요구 사항은 일반 | \[HTTP\]의 섹션 5에 정의된 필드 구문.

---
#### **8.2.2.  Connection-Specific Header Fields**

HTTP/2는 연결 관련 헤더 필드를 나타내기 위해 연결 헤더 필드\(\[HTTP\]의 섹션 7.6.1\)를 사용하지 않습니다. 이 프로토콜에서 연결별 메타데이터는 다른 수단으로 전달됩니다. 끝점은 연결별 헤더 필드를 포함하는 HTTP/2 메시지를 생성하면 안 됩니다\(MUST NOT\). 여기에는 연결 헤더 필드와 \[HTTP\]의 섹션 7.6.1에 연결 관련 의미 체계가 있는 것으로 나열된 항목\(즉, Proxy-Connection, Keep-Alive, Transfer-Encoding 및 Upgrade\)이 포함됩니다. 연결별 헤더 필드를 포함하는 모든 메시지는 잘못된 형식으로 처리되어야 합니다\(섹션 8.1.1\).\(MUST NOT, MUST\)

이에 대한 유일한 예외는 HTTP/2 요청에 존재할 수 있는 TE 헤더 필드입니다. 이 경우 "트레일러" 이외의 값을 포함해서는 안 됩니다\(MUST NOT\).\(MUST NOT\)

HTTP/1.x 메시지를 HTTP/2로 변환하는 중개자는 \[HTTP\]의 섹션 7.6.1에서 설명한 대로 연결별 헤더 필드를 제거해야 합니다. .1\).\(MUST\)

- | 참고: HTTP/2는 의도적으로 다른 버전으로의 업그레이드를 지원하지 않습니다. | 규약. 섹션 3에 설명된 핸드셰이크 방법은 다음과 같습니다. 대안의 사용을 협상하기에 충분하다고 믿는 | 프로토콜.

---
#### **8.2.3.  Compressing the Cookie Header Field**

쿠키 헤더 필드\[COOKIE\]는 세미콜론\(";"\)을 사용하여 쿠키 쌍\(또는 "부스러기"\)을 구분합니다. 이 헤더 필드는 여러 값을 포함하지만 쉼표\(","\)를 구분 기호로 사용하지 않으므로 쿠키 쌍이 여러 필드 행에 전송되는 것을 방지합니다\(\[HTTP\]의 섹션 5.2 참조\). 이렇게 하면 개별 쿠키 쌍에 대한 업데이트가 HPACK 테이블에 저장된 모든 필드 행을 무효화하므로 압축 효율성이 크게 감소할 수 있습니다.

더 나은 압축 효율성을 위해 쿠키 헤더 필드는 각각 하나 이상의 쿠키 쌍이 있는 별도의 헤더 필드로 분할될 수 있습니다. 압축 해제 후 쿠키 헤더 필드가 여러 개 있는 경우 이러한 필드는 HTTP/2가 아닌 컨텍스트로 전달되기 전에 0x3b, 0x20\(ASCII 문자열 "; "\)의 2옥텟 구분 기호를 사용하여 단일 옥텟 문자열로 연결되어야 합니다. HTTP/1.1 연결 또는 일반 HTTP 서버 애플리케이션으로.\(MAY, MUST\)

따라서 쿠키 헤더 필드의 다음 두 목록은 의미상 동일합니다.

```text
   cookie: a=b; c=d; e=f

   cookie: a=b
   cookie: c=d
   cookie: e=f
```

---
### **8.3.  HTTP Control Data**

HTTP/2는 메시지 제어 데이터를 전달하기 위해 ':' 문자\(ASCII 0x3a\)로 시작하는 특수 의사 헤더 필드를 사용합니다\(\[HTTP\]의 섹션 6.2 참조\).

의사 헤더 필드는 HTTP 헤더 필드가 아닙니다. 끝점은 이 문서에 정의된 것 이외의 의사 헤더 필드를 생성하면 안 됩니다\(MUST NOT\). 확장은 추가 의사 헤더 필드의 사용을 협상할 수 있습니다. 섹션 5.5를 참조하십시오.\(MUST NOT\)

의사 헤더 필드는 정의된 컨텍스트에서만 유효합니다. 요청에 대해 정의된 의사 헤더 필드는 응답에 나타나지 않아야 합니다. 응답에 대해 정의된 의사 헤더 필드는 요청에 나타나지 않아야 합니다\(MUST NOT\). 의사 헤더 필드는 트레일러 섹션에 나타나지 않아야 합니다\(MUST NOT\). 엔드포인트는 정의되지 않았거나 유효하지 않은 의사 헤더 필드를 포함하는 요청 또는 응답을 잘못된 형식으로 처리해야 합니다\(섹션 8.1.1\).\(MUST NOT, MUST NOT, MUST\)

모든 pseudo-header 필드는 모든 일반 필드 행 앞에 필드 블록에 나타나야 합니다. 일반 필드 라인 다음에 필드 블록에 나타나는 의사 헤더 필드를 포함하는 모든 요청 또는 응답은 잘못된 형식으로 처리되어야 합니다\(섹션 8.1.1\).\(MUST, MUST\)

동일한 의사 헤더 필드 이름이 필드 블록에 두 번 이상 나타나지 않아야 합니다. 반복되는 의사 헤더 필드 이름을 포함하는 HTTP 요청 또는 응답에 대한 필드 블록은 잘못된 형식으로 처리되어야 합니다\(섹션 8.1.1\).\(MUST NOT, MUST\)

---
#### **8.3.1.  Request Pseudo-Header Fields**

다음 의사 헤더 필드는 HTTP/2 요청에 대해 정의됩니다.

\* ":method" 의사 헤더 필드에는 HTTP 메서드가 포함됩니다\(\[HTTP\]의 섹션 9\).

\* ":scheme" 의사 헤더 필드에는 요청 대상의 scheme 부분이 포함됩니다. 스키마는 요청을 직접 생성할 때 대상 URI\(\[RFC3986\]의 섹션 3.1\) 또는 변환된 요청의 스키마\(예: \[HTTP/1.1\]의 섹션 3.3 참조\)에서 가져옵니다. CONNECT 요청\(섹션 8.5\)에 대한 체계는 생략됩니다.

- ":scheme"은 "http" 및 "https" 스키마 URI로 제한되지 않습니다. 프록시 또는 게이트웨이는 비 HTTP 체계에 대한 요청을 변환하여 HTTP를 사용하여 비 HTTP 서비스와 상호 작용할 수 있습니다.

\* ":authority" 의사 헤더 필드는 대상 URI\(\[HTTP\]의 섹션 7.1\)의 권한 부분\(\[RFC3986\]의 섹션 3.2\)을 전달합니다. HTTP/2 요청의 수신자는 ":authority"가 있는 경우 대상 URI를 결정하기 위해 Host 헤더 필드를 사용해서는 안 됩니다\(MUST NOT\).\(MUST NOT\)

- HTTP/2 요청을 직접 생성하는 클라이언트는 전달할 권한 정보가 없는 경우\(이 경우 ":authority"를 생성하면 안 됨\) 권한 정보를 전달하기 위해 ":authority" 의사 헤더 필드를 사용해야 합니다.\(MUST NOT\)

- 클라이언트는 ":authority" 의사 헤더 필드와 다른 호스트 헤더 필드로 요청을 생성해서는 안 됩니다\(MUST NOT\). 서버는 요청이 ":authority" 의사 헤더 필드의 엔티티와 다른 엔티티를 식별하는 호스트 헤더 필드를 포함하는 경우 요청을 잘못된 형식으로 처리해야 합니다\(SHOULD\). 필드 값을 비교하려면 정규화해야 합니다\(\[RFC3986\]의 섹션 6.2 참조\). 원본 서버는 모든 정규화 방법을 적용할 수 있지만 다른 서버는 두 필드의 체계 기반 정규화\(\[RFC3986\]의 섹션 6.2.3 참조\)를 수행해야 합니다.\(MUST NOT, SHOULD, MUST\)

- HTTP/2를 통해 요청을 전달하는 중개자는 원래 요청의 대상 URI가 권한 정보를 포함하지 않는 한 원래 요청의 제어 데이터에서 권한 정보를 사용하여 ":authority" 의사 헤더 필드를 구성해야 합니다. ":authority"를 생성하면 안 됩니다. 호스트 헤더 필드는 이 정보의 유일한 소스가 아닙니다. \[HTTP\]의 섹션 7.2를 참조하십시오.\(MUST NOT\)

- 호스트 헤더 필드\(HTTP/1.1 요청을 구성하는 데 필요할 수 있음\)를 생성해야 하는 중개자는 ":authority" 의사 헤더 필드의 값을 호스트 필드의 값으로 사용해야 합니다. 요청 대상을 변경합니다. 이는 HTTP 라우팅의 잠재적 취약성을 방지하기 위해 기존 호스트 필드를 대체합니다.\(MUST\)

- HTTP/2를 통해 요청을 전달하는 중개자는 호스트 헤더 필드를 유지할 수 있습니다.\(MAY\)

- CONNECT 또는 별표 형식 OPTIONS 요청의 요청 대상에는 권한 정보가 포함되지 않습니다. \[HTTP\]의 섹션 7.1 및 7.2를 참조하십시오.

- ":authority"는 "http" 또는 "https" 스키마 URI에 대해 더 이상 사용되지 않는 userinfo 하위 구성 요소를 포함해서는 안 됩니다\(MUST NOT\).\(MUST NOT\)

\* ":path" 의사 헤더 필드는 대상 URI의 경로 및 쿼리 부분을 포함합니다\(절대 경로 생성 및 선택적으로 쿼리 생성이 뒤따르는 '?' 문자; \[HTTP\]의 섹션 4.1 참조\). 별표 형식의 요청\(OPTIONS용\)에는 ":path" 의사 헤더 필드에 대한 '\*' 값이 포함됩니다.

- 이 의사 헤더 필드는 "http" 또는 "https" URI에 대해 비어 있으면 안 됩니다. 경로 구성요소를 포함하지 않는 "http" 또는 "https" URI는 '/' 값을 포함해야 합니다. 이 규칙의 예외는 다음과 같습니다.\(MUST NOT\)

- - 경로 구성 요소를 포함하지 않는 "http" 또는 "https" URI에 대한 OPTIONS 요청 여기에는 값이 '\*'인 ":path" 의사 헤더 필드가 포함되어야 합니다\(\[HTTP\]의 섹션 7.1 참조\).\(MUST\)

- - ":path" 의사 헤더 필드가 생략된 CONNECT 요청\(섹션 8.5\).

모든 HTTP/2 요청은 CONNECT 요청이 아닌 한 ":method", ":scheme" 및 ":path" 의사 헤더 필드에 대해 정확히 하나의 유효한 값을 포함해야 합니다\(섹션 8.5\). 필수 의사 헤더 필드를 생략하는 HTTP 요청은 잘못된 형식입니다\(섹션 8.1.1\).\(MUST\)

개별 HTTP/2 요청에는 프로토콜 버전에 대한 명시적인 표시기가 없습니다. 모든 HTTP/2 요청은 암시적으로 "2.0"의 프로토콜 버전을 가집니다\(\[HTTP\]의 섹션 6.2 참조\).

---
#### **8.3.2.  Response Pseudo-Header Fields**

HTTP/2 응답의 경우 HTTP 상태 코드 필드를 전달하는 단일 ":status" 의사 헤더 필드가 정의됩니다\(\[HTTP\]의 섹션 15 참조\). 이 의사 헤더 필드는 중간 응답을 포함한 모든 응답에 반드시 포함되어야 합니다. 그렇지 않으면 응답 형식이 잘못되었습니다\(섹션 8.1.1\).\(MUST\)

HTTP/2 응답에는 암시적으로 "2.0"의 프로토콜 버전이 있습니다.

---
### **8.4.  Server Push**

HTTP/2는 서버가 이전 클라이언트가 시작한 요청과 관련하여 클라이언트에 대응하는 "약속된" 요청과 함께 응답을 선제적으로 전송\(또는 "푸시"\)할 수 있도록 합니다.

서버 푸시는 수신한 요청을 따를 요청을 예측함으로써 서버가 클라이언트가 인식하는 성능을 개선할 수 있도록 설계되어 왕복을 제거합니다. 예를 들어 HTML에 대한 요청 뒤에는 해당 페이지에서 참조하는 스타일시트 및 스크립트에 대한 요청이 뒤따르는 경우가 많습니다. 이러한 요청이 푸시되면 클라이언트는 HTML에서 이에 대한 참조를 수신하고 별도의 요청을 발행하기 위해 기다릴 필요가 없습니다.

실제로 서버 푸시는 캐싱, 콘텐츠 협상 및 사용자 행동과 같은 요소를 고려하여 클라이언트가 만들 추가 요청을 서버가 올바르게 예상해야 하기 때문에 효과적으로 사용하기 어렵습니다. 예측 오류는 유선의 추가 데이터가 나타내는 기회 비용으로 인해 성능 저하로 이어질 수 있습니다. 특히 상당한 양의 데이터를 푸시하면 더 중요한 응답과 경합 문제가 발생할 수 있습니다.

클라이언트는 서버 푸시를 비활성화하도록 요청할 수 있지만 이는 각 홉에 대해 독립적으로 협상됩니다. SETTINGS\_ENABLE\_PUSH 설정을 0으로 설정하여 서버 푸시가 비활성화되었음을 나타낼 수 있습니다.

약속된 요청은 안전하고\(\[HTTP\]의 섹션 9.2.1 참조\) 캐시 가능해야 합니다\(\[HTTP\]의 섹션 9.2.3 참조\). 약속된 요청에는 콘텐츠나 예고편 섹션이 포함될 수 없습니다. 캐시할 수 없거나 안전한 것으로 알려지지 않았거나 요청 내용이 있음을 나타내는 약속된 요청을 수신하는 클라이언트는 PROTOCOL\_ERROR 유형의 스트림 오류\(섹션 5.4.2\)로 약속된 스트림을 재설정해야 합니다. 이로 인해 클라이언트가 새로 정의된 메서드가 안전한 것으로 인식하지 못하는 경우 약속된 스트림이 재설정될 수 있습니다.\(MUST, MUST\)

캐시 가능한 푸시 응답\(\[CACHING\]의 섹션 3 참조\)은 HTTP 캐시를 구현하는 경우 클라이언트에 의해 저장될 수 있습니다. 푸시된 응답은 약속된 스트림 식별자로 식별된 스트림이 아직 열려 있는 동안 원본 서버에서 성공적으로 검증된 것으로 간주됩니다\(예: "no-cache" 캐시 응답 지시문이 있는 경우, \[CACHING\]의 섹션 5.2.2.4 참조\).

캐시할 수 없는 푸시된 응답은 HTTP 캐시에 의해 저장되어서는 안 됩니다\(MUST NOT\). 응용 프로그램에서 별도로 사용할 수 있습니다.\(MUST NOT, MAY\)

서버는 서버가 신뢰할 수 있는 ":authority" 의사 헤더 필드에 값을 포함해야 합니다\(섹션 10.1 참조\). 클라이언트는 서버가 권한이 없는 PUSH\_PROMISE를 PROTOCOL\_ERROR 유형의 스트림 오류\(섹션 5.4.2\)로 처리해야 합니다.\(MUST, MUST\)

중개자는 서버에서 푸시를 수신하고 클라이언트에 전달하지 않도록 선택할 수 있습니다. 즉, 푸시된 정보를 어떻게 활용하느냐는 중개인의 몫이다. 마찬가지로 중개자는 서버가 수행하는 작업 없이 클라이언트에 추가 푸시를 수행하도록 선택할 수 있습니다.

클라이언트는 푸시할 수 없습니다. 따라서 서버는 PUSH\_PROMISE 프레임의 수신을 PROTOCOL\_ERROR 유형의 연결 오류\(섹션 5.4.1\)로 처리해야 합니다. 서버는 SETTINGS\_ENABLE\_PUSH 설정을 0 이외의 값으로 설정할 수 없습니다\(섹션 6.5.2 참조\).\(MUST\)

---
#### **8.4.1.  Push Requests**

서버 푸시는 요청에 응답하는 서버와 의미상 동일합니다. 그러나 이 경우 해당 요청은 서버에서 PUSH\_PROMISE 프레임으로 전송됩니다.

PUSH\_PROMISE 프레임에는 제어 데이터가 포함된 필드 블록과 서버가 요청에 속성을 부여하는 완전한 요청 헤더 필드 세트가 포함됩니다. 메시지 콘텐츠가 포함된 요청에 대한 응답을 푸시할 수 없습니다.

약속된 요청은 항상 클라이언트의 명시적 요청과 연결됩니다. 서버에서 보낸 PUSH\_PROMISE 프레임은 해당 명시적 요청의 스트림에서 전송됩니다. PUSH\_PROMISE 프레임에는 서버에서 사용할 수 있는 스트림 식별자에서 선택한 약속된 스트림 식별자도 포함됩니다\(섹션 5.1.1 참조\).

PUSH\_PROMISE 및 후속 CONTINUATION 프레임의 헤더 필드는 유효하고 완전한 요청 헤더 필드 집합이어야 합니다\(섹션 8.3.1\). 서버는 ":method" 의사 헤더 필드에 안전하고 캐시 가능한 메소드를 포함해야 합니다. 클라이언트가 완전하고 유효한 헤더 필드 집합을 포함하지 않는 PUSH\_PROMISE를 수신하거나 ":method" 의사 헤더 필드가 안전하지 않은 메서드를 식별하는 경우 약속된 스트림에서 스트림 오류로 응답해야 합니다\(5.4절 .2\) PROTOCOL\_ERROR 유형.\(MUST, MUST, MUST\)

서버는 약속된 응답을 참조하는 프레임을 보내기 전에 PUSH\_PROMISE\(섹션 6.6\) 프레임을 보내야 합니다\(SHOULD\). 이렇게 하면 클라이언트가 PUSH\_PROMISE 프레임을 수신하기 전에 요청을 발행하는 경쟁을 피할 수 있습니다.\(SHOULD\)

예를 들어, 서버가 여러 이미지 파일에 대한 포함된 링크가 포함된 문서에 대한 요청을 수신하고 서버가 이러한 추가 이미지를 클라이언트에 푸시하기로 선택한 경우 이미지 링크가 포함된 DATA 프레임 전에 PUSH\_PROMISE 프레임을 보내면 클라이언트가 다음을 수행할 수 있습니다. 포함된 링크를 검색하기 전에 리소스가 푸시되는지 확인합니다. 마찬가지로 서버가 필드 블록\(예: 링크 헤더 필드\)에서 참조하는 리소스를 푸시하는 경우 헤더를 보내기 전에 PUSH\_PROMISE를 보내면 클라이언트가 해당 리소스를 요청하지 않습니다.

PUSH\_PROMISE 프레임은 클라이언트에 의해 전송되어서는 안됩니다\(MUST NOT\).\(MUST NOT\)

PUSH\_PROMISE 프레임은 클라이언트가 시작한 모든 스트림에서 서버에 의해 전송될 수 있지만 스트림은 서버에 대해 "개방" 또는 "절반 폐쇄\(원격\)" 상태에 있어야 합니다. PUSH\_PROMISE 프레임은 단일 필드 블록을 구성하는 HEADERS 및 CONTINUATION 프레임과 함께 배치될 수 없지만 응답을 구성하는 프레임과 함께 배치됩니다.\(MUST\)

PUSH\_PROMISE 프레임을 전송하면 새 스트림이 생성되고 스트림이 서버에 대해 "예약됨\(로컬\)" 상태가 되고 클라이언트에 대해 "예약됨\(원격\)" 상태가 됩니다.

---
#### **8.4.2.  Push Responses**

PUSH\_PROMISE 프레임을 보낸 후 서버는 약속된 스트림 식별자를 사용하는 서버 시작 스트림에 대한 응답\(섹션 8.3.2\)으로 푸시된 응답 전달을 시작할 수 있습니다. 서버는 섹션 8.1에서 정의된 것과 동일한 프레임 시퀀스를 사용하여 HTTP 응답을 전송하기 위해 이 스트림을 사용합니다. 이 스트림은 초기 HEADERS 프레임이 전송된 후 클라이언트\(섹션 5.1\)에 대해 "절반 폐쇄"됩니다.

클라이언트가 PUSH\_PROMISE 프레임을 수신하고 푸시된 응답을 수락하기로 선택하면 클라이언트는 약속된 스트림이 닫힐 때까지 약속된 응답에 대한 요청을 발행해서는 안 됩니다\(SHOULD NOT\).\(SHOULD NOT\)

어떤 이유로든 클라이언트가 서버로부터 푸시된 응답을 받고 싶지 않다고 결정하거나 서버가 약속된 응답 전송을 시작하는 데 너무 오래 걸리는 경우 클라이언트는 CANCEL 또는 REFUSED\_STREAM을 사용하여 RST\_STREAM 프레임을 보낼 수 있습니다. 코드 및 푸시된 스트림의 식별자를 참조합니다.

클라이언트는 SETTINGS\_MAX\_CONCURRENT\_STREAMS 설정을 사용하여 서버에서 동시에 푸시할 수 있는 응답 수를 제한할 수 있습니다. SETTINGS\_MAX\_CONCURRENT\_STREAMS 값을 0으로 광고하면 서버가 응답을 푸시하는 데 필요한 스트림을 열 수 없습니다. 그러나 이것은 서버가 PUSH\_PROMISE 프레임을 사용하여 스트림을 예약하는 것을 막지는 않습니다. 예약된 스트림은 동시 스트림 제한에 포함되지 않기 때문입니다. 푸시된 리소스를 수신하지 않으려는 클라이언트는 원치 않는 예약 스트림을 재설정하거나 SETTINGS\_ENABLE\_PUSH를 0으로 설정해야 합니다.

```text
   Clients receiving a pushed response MUST validate that either the
   server is authoritative (see Section 10.1) or the proxy that provided
   the pushed response is configured for the corresponding request.  For
   example, a server that offers a certificate for only the example.com
   DNS-ID (see [RFC6125]) is not permitted to push a response for
   <https://www.example.org/doc>.
```

PUSH\_PROMISE 스트림에 대한 응답은 HEADERS 프레임으로 시작하여 스트림을 즉시 서버의 경우 "반 폐쇄\(원격\)" 상태로, 클라이언트의 경우 "반 폐쇄\(로컬\)" 상태로 만들고 프레임으로 끝납니다. END\_STREAM 플래그가 설정되어 스트림이 "닫힌" 상태가 됩니다.

- | 참고: 클라이언트는 END\_STREAM 플래그 | 서버 푸시로 설정합니다.

---
### **8.5.  The CONNECT Method**

CONNECT 방법\(\[HTTP\]의 섹션 9.3.6\)은 HTTP 연결을 원격 호스트에 대한 터널로 변환하는 데 사용됩니다. CONNECT는 주로 HTTP 프록시와 함께 사용되어 "https" 리소스와 상호 작용할 목적으로 원본 서버와 TLS 세션을 설정합니다.

HTTP/2에서 CONNECT 메서드는 전체 연결을 터널로 변환하는 대신 단일 HTTP/2 스트림을 통해 원격 호스트로 터널을 설정합니다. CONNECT 헤더 섹션은 섹션 8.3.1\("의사 헤더 필드 요청"\)에 정의된 대로 구성되지만 몇 가지 차이점이 있습니다. 구체적으로:

\* ":method" 의사 헤더 필드는 CONNECT로 설정됩니다.

\* ":scheme" 및 ":path" 의사 헤더 필드는 생략해야 합니다.\(MUST\)

\* ":authority" 의사 헤더 필드는 연결할 호스트와 포트를 포함합니다\(CONNECT 요청의 요청 대상의 권한 형식과 동일; \[HTTP/1.1\]의 섹션 3.2.3 참조\).

이러한 제한 사항을 준수하지 않는 CONNECT 요청은 잘못된 형식입니다\(섹션 8.1.1\).

CONNECT를 지원하는 프록시는 ":authority" 의사 헤더 필드에서 식별된 호스트 및 포트에 대한 TCP 연결\[TCP\]을 설정합니다. 이 연결이 성공적으로 설정되면 프록시는 \[HTTP\]의 섹션 9.3.6에 정의된 대로 클라이언트에 2xx 시리즈 상태 코드가 포함된 HEADERS 프레임을 보냅니다.

각 피어가 보낸 초기 HEADERS 프레임 이후의 모든 후속 DATA 프레임은 TCP 연결에서 보낸 데이터에 해당합니다. 클라이언트가 보낸 모든 DATA 프레임의 프레임 페이로드는 프록시에 의해 TCP 서버로 전송됩니다. TCP 서버에서 받은 데이터는 프록시에 의해 DATA 프레임으로 어셈블됩니다. DATA 또는 스트림 관리 프레임\(RST\_STREAM, WINDOW\_UPDATE 및 PRIORITY\) 이외의 프레임 유형은 연결된 스트림에서 보내서는 안 되며 수신된 경우 스트림 오류\(섹션 5.4.2\)로 처리해야 합니다.\(MUST NOT\)

TCP 연결은 두 피어 중 하나에서 닫을 수 있습니다. DATA 프레임의 END\_STREAM 플래그는 TCP FIN 비트와 동일한 것으로 취급됩니다. 클라이언트는 END\_STREAM 플래그가 설정된 프레임을 수신한 후 END\_STREAM 플래그가 설정된 DATA 프레임을 보낼 것으로 예상됩니다. END\_STREAM 플래그가 설정된 DATA 프레임을 수신한 프록시는 마지막 TCP 세그먼트에 FIN 비트가 설정된 첨부된 데이터를 보냅니다. FIN 비트가 설정된 TCP 세그먼트를 수신하는 프록시는 END\_STREAM 플래그가 설정된 DATA 프레임을 보냅니다. 마지막 TCP 세그먼트 또는 DATA 프레임이 비어 있을 수 있습니다.

TCP 연결 오류는 RST\_STREAM으로 신호를 받습니다. 프록시는 RST 비트가 설정된 TCP 세그먼트 수신을 포함하는 TCP 연결의 모든 오류를 CONNECT\_ERROR 유형의 스트림 오류\(섹션 5.4.2\)로 처리합니다. 이에 따라 프록시는 스트림 또는 HTTP/2 연결에서 오류를 감지한 경우 RST 비트가 설정된 TCP 세그먼트를 보내야 합니다.\(MUST\)

---
### **8.6.  The Upgrade Header Field**

HTTP/2는 101\(스위칭 프로토콜\) 정보 상태 코드\(\[HTTP\]의 섹션 15.2.2\)를 지원하지 않습니다.

101\(Switching Protocols\)의 의미는 다중화된 프로토콜에 적용할 수 없습니다. 유사한 기능이 확장된 CONNECT\[RFC8441\]를 사용하여 활성화될 수 있으며 다른 프로토콜은 HTTP/2가 사용을 협상하는 데 사용하는 것과 동일한 메커니즘을 사용할 수 있습니다\(섹션 3 참조\).

---
### **8.7.  Request Reliability**

일반적으로 HTTP 클라이언트는 오류의 특성을 확인할 방법이 없기 때문에 오류가 발생하면 멱등성이 아닌 요청을 재시도할 수 없습니다\(\[HTTP\]의 섹션 9.2.2 참조\). 오류가 발생하기 전에 일부 서버 처리가 발생했을 수 있으며 이로 인해 요청을 다시 시도하면 바람직하지 않은 결과가 발생할 수 있습니다.

HTTP/2는 클라이언트에게 요청이 처리되지 않았음을 보장하는 두 가지 메커니즘을 제공합니다.

\* GOAWAY 프레임은 처리되었을 수 있는 가장 높은 스트림 번호를 나타냅니다. 따라서 더 높은 숫자의 스트림에 대한 요청은 안전하게 재시도할 수 있습니다.

\* REFUSED\_STREAM 오류 코드는 처리가 발생하기 전에 스트림이 닫히고 있음을 나타내기 위해 RST\_STREAM 프레임에 포함될 수 있습니다. 재설정 스트림에서 전송된 모든 요청은 안전하게 재시도할 수 있습니다.

처리되지 않은 요청은 실패한 것이 아닙니다. 클라이언트는 멱등성이 아닌 메서드를 사용하더라도 자동으로 재시도할 수 있습니다.\(MAY\)

서버는 사실을 보장할 수 없는 한 스트림이 처리되지 않았음을 나타내서는 안 됩니다\(MUST NOT\). 스트림에 있는 프레임이 임의의 스트림에 대한 애플리케이션 계층으로 전달되는 경우 해당 스트림에 REFUSED\_STREAM을 사용해서는 안 되며 GOAWAY 프레임에는 지정된 스트림 식별자보다 크거나 같은 스트림 식별자가 포함되어야 합니다.\(MUST NOT, MUST NOT\)

이러한 메커니즘 외에도 PING 프레임은 클라이언트가 연결을 쉽게 테스트할 수 있는 방법을 제공합니다. 일부 미들박스\(예: 네트워크 주소 변환기 또는 로드 밸런서\)가 자동으로 연결 바인딩을 버리기 때문에 유휴 상태로 남아 있는 연결이 끊어질 수 있습니다. PING 프레임을 사용하면 클라이언트가 요청을 보내지 않고도 연결이 여전히 활성화되어 있는지 여부를 안전하게 테스트할 수 있습니다.

---
### **8.8.  Examples**

이 섹션에서는 HTTP/1.1 요청 및 응답을 동등한 HTTP/2 요청 및 응답 그림과 함께 보여줍니다.

---
#### **8.8.1.  Simple Request**

HTTP GET 요청에는 제어 데이터와 메시지 콘텐츠가 없는 요청 헤더가 포함되어 있으므로 단일 HEADERS 프레임으로 전송되며, 요청 헤더 필드의 직렬화된 블록을 포함하는 0개 이상의 CONTINUATION 프레임이 이어집니다. 다음의 HEADERS 프레임에는 END\_HEADERS 및 END\_STREAM 플래그가 모두 설정되어 있습니다. CONTINUATION 프레임이 전송되지 않습니다.

```text
     GET /resource HTTP/1.1           HEADERS
     Host: example.org          ==>     + END_STREAM
     Accept: image/jpeg                 + END_HEADERS
                                          :method = GET
                                          :scheme = https
                                          :authority = example.org
                                          :path = /resource
                                          host = example.org
                                          accept = image/jpeg
```

---
#### **8.8.2.  Simple Response**

유사하게 제어 데이터와 응답 헤더만 포함하는 응답은 응답 헤더 필드의 직렬화된 블록을 포함하는 HEADERS 프레임\(다시 0개 이상의 CONTINUATION 프레임이 뒤따름\)으로 전송됩니다.

```text
     HTTP/1.1 304 Not Modified        HEADERS
     ETag: "xyzzy"              ==>     + END_STREAM
     Expires: Thu, 23 Jan ...           + END_HEADERS
                                          :status = 304
                                          etag = "xyzzy"
                                          expires = Thu, 23 Jan ...
```

---
#### **8.8.3.  Complex Request**

제어 데이터와 메시지 콘텐츠가 포함된 요청 헤더를 포함하는 HTTP POST 요청은 하나의 HEADERS 프레임으로 전송되며, 요청 헤더를 포함하는 0개 이상의 CONTINUATION 프레임, 마지막 CONTINUATION\(또는 HEADERS\)이 포함된 하나 이상의 DATA 프레임이 뒤따릅니다. END\_HEADERS 플래그가 설정된 프레임과 END\_STREAM 플래그가 설정된 마지막 DATA 프레임:

```text
     POST /resource HTTP/1.1          HEADERS
     Host: example.org          ==>     - END_STREAM
     Content-Type: image/jpeg           - END_HEADERS
     Content-Length: 123                  :method = POST
                                          :authority = example.org
                                          :path = /resource
     {binary data}                        :scheme = https

                                      CONTINUATION
                                        + END_HEADERS
                                          content-type = image/jpeg
                                          host = example.org
                                          content-length = 123

                                      DATA
                                        + END_STREAM
                                      {binary data}
```

주어진 필드 라인에 기여하는 데이터는 필드 블록 조각 사이에 분산될 수 있습니다. 이 예에서 필드 라인을 프레임에 할당하는 것은 예시일 뿐입니다.

---
#### **8.8.4.  Response with Body**

제어 데이터와 메시지 콘텐츠가 포함된 응답 헤더를 포함하는 응답은 HEADERS 프레임으로 전송되며, 0개 이상의 CONTINUATION 프레임과 하나 이상의 DATA 프레임이 이어지며 시퀀스의 마지막 DATA 프레임에는 END\_STREAM 플래그가 설정됩니다.

```text
     HTTP/1.1 200 OK                  HEADERS
     Content-Type: image/jpeg   ==>     - END_STREAM
     Content-Length: 123                + END_HEADERS
                                          :status = 200
     {binary data}                        content-type = image/jpeg
                                          content-length = 123

                                      DATA
                                        + END_STREAM
                                      {binary data}
```

---
#### **8.8.5.  Informational Responses**

101 이외의 1xx 상태 코드를 사용하는 정보 응답은 HEADERS 프레임으로 전송되고 그 뒤에 0개 이상의 CONTINUATION 프레임이 이어집니다.

트레일러 섹션은 요청 또는 응답 필드 블록과 모든 DATA 프레임이 전송된 후 필드 블록으로 전송됩니다. 트레일러 섹션을 구성하는 필드 블록을 시작하는 HEADERS 프레임에는 END\_STREAM 플래그가 설정되어 있습니다.

다음 예제에는 Expect 헤더 필드에 "100-continue" 토큰이 포함된 요청에 대한 응답으로 전송되는 100\(계속\) 상태 코드와 트레일러 섹션이 모두 포함되어 있습니다.

```text
     HTTP/1.1 100 Continue            HEADERS
     Extension-Field: bar       ==>     - END_STREAM
                                        + END_HEADERS
                                          :status = 100
                                          extension-field = bar

     HTTP/1.1 200 OK                  HEADERS
     Content-Type: image/jpeg   ==>     - END_STREAM
     Transfer-Encoding: chunked         + END_HEADERS
     Trailer: Foo                         :status = 200
                                          content-type = image/jpeg
     123                                  trailer = Foo
     {binary data}
     0                                DATA
     Foo: bar                           - END_STREAM
                                      {binary data}

                                      HEADERS
                                        + END_STREAM
                                        + END_HEADERS
                                          foo = bar
```

---
## **9.  HTTP/2 Connections**

이 섹션에서는 상호 운용성을 개선하고, 알려진 보안 취약점에 대한 노출을 줄이거나, 구현 변동 가능성을 줄이는 HTTP 속성에 대해 간략하게 설명합니다.

---
### **9.1.  Connection Management**

HTTP/2 연결은 지속적입니다. 최상의 성능을 위해 클라이언트는 서버와의 추가 통신이 필요하지 않다고 판단될 때까지\(예: 사용자가 특정 웹 페이지에서 다른 곳으로 이동하는 경우\) 또는 서버가 연결을 닫을 때까지 연결을 닫지 않을 것으로 예상됩니다.

클라이언트는 호스트가 URI, 선택된 대체 서비스\[ALT-SVC\] 또는 구성된 프록시에서 파생되는 지정된 호스트 및 포트 쌍에 대해 둘 이상의 HTTP/2 연결을 열면 안 됩니다\(SHOULD NOT\).\(SHOULD NOT\)

클라이언트는 사용 가능한 스트림 식별자 공간을 거의 소진하는 연결을 교체하거나\(섹션 5.1.1\), TLS 연결에 대한 키 자료를 새로 고치거나, 오류가 발생한 연결을 교체\(섹션 5.4.1\).

클라이언트는 다른 서버 이름 표시\[TLS-EXT\] 값을 사용하거나 다른 TLS 클라이언트 인증서를 제공하기 위해 동일한 IP 주소 및 TCP 포트에 대한 여러 연결을 열 수 있지만 동일한 구성으로 여러 연결을 만드는 것을 피해야 합니다\(SHOULD\).\(SHOULD\)

서버는 가능한 한 오랫동안 열린 연결을 유지하도록 권장되지만 필요한 경우 유휴 연결을 종료할 수 있습니다. 끝점이 전송 계층 TCP 연결을 닫도록 선택하면 종료 끝점은 먼저 GOAWAY\(6.8절\) 프레임을 보내서 두 끝점이 이전에 보낸 프레임이 처리되었는지 여부를 안정적으로 결정하고 필요한 나머지 작업을 정상적으로 완료하거나 종료할 수 있도록 해야 합니다.\(SHOULD\)

---
#### **9.1.1.  Connection Reuse**

CONNECT 방법\(섹션 8.5\)을 사용하여 생성된 터널을 통해 또는 직접적으로 원서버에 대한 연결은 여러 다른 URI 권한 구성 요소가 있는 요청에 재사용될 수 있습니다\(MAY\). 원본 서버가 신뢰할 수 있는 한 연결을 재사용할 수 있습니다\(10.1절\). TLS가 없는 TCP 연결의 경우 이는 동일한 IP 주소로 확인된 호스트에 따라 다릅니다.\(MAY\)

"https" 리소스의 경우 연결 재사용은 추가로 URI의 호스트에 유효한 인증서가 있는지 여부에 따라 달라집니다. 서버에서 제공하는 인증서는 URI에서 호스트에 대한 새 TLS 연결을 형성할 때 클라이언트가 수행하는 모든 검사를 충족해야 합니다. 단일 인증서를 사용하여 여러 원본에 대한 권한을 설정할 수 있습니다. \[HTTP\]의 섹션 4.3은 클라이언트가 서버가 URI에 대해 권한이 있는지 여부를 결정하는 방법을 설명합니다.\(MUST\)

일부 배포에서 여러 오리진에 대한 연결을 재사용하면 요청이 잘못된 오리진 서버로 전달될 수 있습니다. 예를 들어 TLS 서버 이름 표시\[TLS-EXT\] 확장을 사용하여 원본 서버를 선택하는 미들박스에서 TLS 종료를 수행할 수 있습니다. 즉, 서버가 권한이 있는 경우에도 클라이언트가 의도한 요청 대상이 아닐 수 있는 서버에 요청을 보낼 수 있습니다.

클라이언트가 연결을 재사용하는 것을 원하지 않는 서버는 요청에 대한 응답으로 421\(잘못 지정된 요청\) 상태 코드를 전송하여 요청에 대해 권한이 없음을 나타낼 수 있습니다\(\[HTTP\]의 섹션 15.5.20 참조\).

HTTP/2를 통해 프록시를 사용하도록 구성된 클라이언트는 단일 연결을 통해 요청을 해당 프록시로 보냅니다. 즉, 프록시를 통해 전송된 모든 요청은 프록시에 대한 연결을 재사용합니다.

---
### **9.2.  Use of TLS Features**

HTTP/2 구현은 TLS를 통한 HTTP/2에 대해 TLS 버전 1.2\[TLS12\] 이상을 사용해야 합니다\(MUST\). \[TLSBCP\]의 일반 TLS 사용 지침을 따라야 하며 HTTP/2에 특정한 몇 가지 추가 제한 사항이 있습니다.\(MUST, SHOULD\)

TLS 구현은 TLS에 대한 SNI\(Server Name Indication\) \[TLS-EXT\] 확장을 지원해야 합니다. 서버가 도메인 이름\[DNS-TERMS\]으로 식별되는 경우 클라이언트는 대상 호스트를 나타내는 대체 메커니즘이 사용되지 않는 한 server\_name TLS 확장을 보내야 합니다.\(MUST, MUST\)

TLS 1.3\[TLS13\]을 협상하는 HTTP/2 배포에 대한 요구 사항은 섹션 9.2.3에 포함되어 있습니다. TLS 1.2 배포에는 섹션 9.2.1 및 9.2.2의 요구 사항이 적용됩니다. 구현은 준수하는 기본값을 제공하도록 권장되지만 궁극적으로 준수에 대한 책임은 배포에 있음을 인식합니다.

---
#### **9.2.1.  TLS 1.2 Features**

이 섹션에서는 HTTP/2와 함께 사용할 수 있는 TLS 1.2 기능 세트에 대한 제한 사항을 설명합니다. 배포 제한으로 인해 이러한 제한이 충족되지 않으면 TLS 협상에 실패하지 못할 수 있습니다. 엔드포인트는 INADEQUATE\_SECURITY 유형의 연결 오류\(섹션 5.4.1\)와 함께 이러한 TLS 요구 사항을 충족하지 않는 HTTP/2 연결을 즉시 종료할 수 있습니다\(MAY\).\(MAY\)

TLS 1.2를 통한 HTTP/2 배포는 압축을 비활성화해야 합니다. TLS 압축은 그렇지 않으면 공개되지 않는 정보의 노출로 이어질 수 있습니다\[RFC3749\]. 일반 압축은 필요하지 않습니다. HTTP/2는 컨텍스트를 더 잘 인식하고 성능, 보안 또는 기타 이유로 사용하기에 더 적합한 압축 기능을 제공하기 때문입니다.\(MUST\)

TLS 1.2를 통한 HTTP/2 배포는 재협상을 비활성화해야 합니다. 엔드포인트는 TLS 재협상을 PROTOCOL\_ERROR 유형의 연결 오류\(섹션 5.4.1\)로 처리해야 합니다. 재협상을 비활성화하면 기본 암호 그룹이 암호화할 수 있는 메시지 수 제한으로 인해 수명이 긴 연결을 사용할 수 없게 될 수 있습니다.\(MUST, MUST\)

엔드포인트는 재협상을 사용하여 핸드셰이크에서 제공되는 클라이언트 자격 증명에 대한 기밀 보호를 제공할 수 있지만 재협상은 반드시 연결 서문을 보내기 전에 이루어져야 합니다. 서버는 연결을 설정한 직후에 재협상 요청을 본 경우 클라이언트 인증서를 요청해야 합니다\(SHOULD\).\(MUST, SHOULD\)

이렇게 하면 특정 보호 리소스에 대한 요청에 대한 응답으로 재협상을 사용하는 것을 효과적으로 방지할 수 있습니다. 향후 사양은 이 사용 사례를 지원하는 방법을 제공할 수 있습니다. 또는 서버가 HTTP\_1\_1\_REQUIRED 유형의 오류\(섹션 5.4\)를 사용하여 클라이언트가 재협상을 지원하는 프로토콜을 사용하도록 요청할 수 있습니다.\(MUST\)

구현은 임시 유한 필드 Diffie-Hellman\(DHE\)\(\[TLS12\]의 섹션 8.1.2\)을 사용하는 암호군의 경우 최소 2048비트의 임시 키 교환 크기를 지원해야 하며 임시 타원 곡선 Diffie-Hellman을 사용하는 암호군의 경우 224비트를 지원해야 합니다\(MUST\). \(ECDHE\) \[RFC8422\]. 클라이언트는 최대 4096비트의 DHE 크기를 수락해야 합니다. 엔드포인트는 하한보다 작은 키 크기 협상을 INADEQUATE\_SECURITY 유형의 연결 오류\(섹션 5.4.1\)로 처리할 수 있습니다\(MAY\).\(MUST, MUST, MAY\)

---
#### **9.2.2.  TLS 1.2 Cipher Suites**

TLS 1.2를 통한 HTTP/2 배포는 부록 A에 나열된 금지된 암호화 제품군을 사용해서는 안 됩니다\(SHOULD NOT\).\(SHOULD NOT\)

엔드포인트는 금지된 암호화 제품군 중 하나가 협상되는 경우 INADEQUATE\_SECURITY 유형의 연결 오류\(섹션 5.4.1\)를 생성하도록 선택할 수 있습니다\(MAY\). 금지된 암호화 제품군을 사용하도록 선택한 배포는 잠재적인 피어 집합이 해당 암호화 제품군을 수락하는 것으로 알려지지 않는 한 연결 오류를 트리거할 위험이 있습니다.\(MAY\)

구현은 금지되지 않은 암호 제품군의 협상에 대한 반응으로 이 오류를 생성해서는 안 됩니다\(MUST NOT\). 결과적으로 클라이언트가 금지되지 않은 암호화 제품군을 제공하는 경우 HTTP/2와 함께 해당 암호화 제품군을 사용할 준비가 되어 있어야 합니다.\(MUST NOT\)

금지된 암호화 제품군 목록에는 TLS 1.2에서 필수로 지정하는 암호화 제품군이 포함되어 있습니다. 즉, TLS 1.2 배포에는 교차하지 않는 허용된 암호화 제품군 집합이 있을 수 있습니다. TLS 핸드셰이크 실패를 유발하는 이 문제를 방지하기 위해 TLS 1.2를 사용하는 HTTP/2 배포는 P-256 타원 곡선\[RFC8422\]과 함께 TLS\_ECDHE\_RSA\_WITH\_AES\_128\_GCM\_SHA256\[TLS-ECDHE\]를 지원해야 합니다.\(MUST\)

클라이언트는 HTTP/2를 지원하지 않는 서버에 대한 연결을 허용하기 위해 금지된 암호화 제품군 지원을 알릴 수 있습니다. 이를 통해 서버는 HTTP/2에서 금지된 암호화 제품군이 포함된 HTTP/1.1을 선택할 수 있습니다. 그러나 이로 인해 애플리케이션 프로토콜과 암호화 제품군이 독립적으로 선택된 경우 HTTP/2가 금지된 암호화 제품군과 협상될 수 있습니다.

---
#### **9.2.3.  TLS 1.3 Features**

TLS 1.3에는 이전 버전에서 사용할 수 없는 여러 기능이 포함되어 있습니다. 이 섹션에서는 이러한 기능의 사용에 대해 설명합니다.

HTTP/2 서버는 사후 핸드셰이크 TLS 1.3 CertificateRequest 메시지를 보내면 안 됩니다\(MUST NOT\). HTTP/2 클라이언트는 TLS 사후 핸드셰이크 CertificateRequest 메시지를 PROTOCOL\_ERROR 유형의 연결 오류\(섹션 5.4.1\)로 처리해야 합니다.\(MUST NOT, MUST\)

사후 핸드셰이크 인증에 대한 금지는 클라이언트가 "post\_handshake\_auth" TLS 확장을 제공한 경우에도 적용됩니다. 사후 핸드셰이크 인증 지원은 ALPN\[TLS-ALPN\]과 독립적으로 광고될 수 있습니다. 클라이언트는 다른 프로토콜에서 사용할 수 있는 기능을 제공할 수 있지만 확장 기능을 포함한다고 해서 HTTP/2 내에서의 지원을 의미할 수는 없습니다.

\[TLS13\]은 HTTP/2와 직접적인 상호 작용이 없기 때문에 사용할 수 있는 다른 사후 핸드셰이크 메시지인 NewSessionTicket 및 KeyUpdate를 정의합니다. 새로운 유형의 TLS 메시지 사용이 응용 프로그램 계층 프로토콜과의 상호 작용에 의존하지 않는 한 핸드셰이크가 완료된 후 해당 TLS 메시지를 보낼 수 있습니다.

\[RFC8470\]의 지침을 준수하는 경우 TLS 초기 데이터를 사용하여 요청을 보낼 수 있습니다\(MAY\). 클라이언트는 모든 서버 설정에 대한 초기 값을 가정하여 초기 데이터로 요청을 보냅니다.\(MAY\)

---
## **10.  Security Considerations**

이 프로토콜의 많은 보안 속성을 제공하려면 TLS를 사용해야 합니다. 이 섹션의 많은 주장은 섹션 9.2에 설명된 대로 TLS가 사용되지 않는 한 유효하지 않습니다.

---
### **10.1.  Server Authority**

HTTP/2는 서버가 주어진 응답을 제공할 때 권한이 있는지 여부를 결정하기 위해 권한의 HTTP 정의에 의존합니다\(\[HTTP\]의 섹션 4.3 참조\). 이는 "http" URI 체계에 대한 로컬 이름 확인과 "https" 체계에 대한 인증된 서버 ID에 의존합니다.

---
### **10.2.  Cross-Protocol Attacks**

교차 프로토콜 공격에서 공격자는 클라이언트가 다른 프로토콜을 이해하는 서버를 향해 한 프로토콜에서 트랜잭션을 시작하도록 합니다. 공격자는 트랜잭션이 두 번째 프로토콜에서 유효한 트랜잭션으로 나타나도록 할 수 있습니다. 웹 컨텍스트의 기능과 결합하여 사설 네트워크에서 제대로 보호되지 않는 서버와 상호 작용하는 데 사용할 수 있습니다.

HTTP/2용 ALPN 식별자로 TLS 핸드셰이크를 완료하는 것은 교차 프로토콜 공격에 대한 충분한 보호로 간주될 수 있습니다. ALPN은 서버가 다른 TLS 기반 프로토콜에 대한 공격을 방지하는 HTTP/2로 진행할 의사가 있다는 긍정적인 표시를 제공합니다.

TLS의 암호화는 공격자가 일반 텍스트 프로토콜에 대한 교차 프로토콜 공격에 사용될 수 있는 데이터를 제어하기 어렵게 만듭니다.

HTTP/2의 일반 텍스트 버전은 교차 프로토콜 공격에 대해 최소한의 보호 기능을 제공합니다. 연결 서문\(섹션 3.4\)에는 HTTP/1.1 서버를 혼동하도록 설계된 문자열이 포함되어 있지만 다른 프로토콜에 대해서는 특별한 보호가 제공되지 않습니다.

---
### **10.3.  Intermediary Encapsulation Attacks**

HPACK은 다른 HTTP 버전에서 구분 기호로 처리될 수 있는 필드 이름 및 값의 인코딩을 허용합니다. HTTP/2 요청 또는 응답을 변환하는 중개자는 메시지를 다른 HTTP 버전으로 변환하기 전에 섹션 8.2의 규칙에 따라 필드를 검증해야 합니다. 유효하지 않은 구분 기호가 포함된 필드를 번역하면 수신자가 메시지를 잘못 해석하여 공격자가 이를 악용할 수 있습니다.\(MUST\)

섹션 8.2에는 의사 헤더 필드의 유효성 검사에 대한 특정 규칙이 포함되어 있지 않습니다. 이러한 필드의 값을 사용하는 경우 추가 유효성 검사가 필요합니다. 이는 ":scheme", ":authority" 및 ":path"가 결합되어 단일 URI 문자열\[RFC3986\]을 형성하는 경우에 특히 중요합니다. 해당 URI 또는 ​​":path"가 ":method"와 결합되어 요청 라인을 구성할 때 유사한 문제가 발생할 수 있습니다\(\[HTTP/1.1\]의 섹션 3 참조\). 입력 값이 완전히 검증되지 않으면 단순 연결은 안전하지 않습니다.

중개자는 다른 이유로 유효하지 않은 필드 이름이나 값을 포함하는 필드를 거부할 수 있습니다. 특히 \[HTTP\] 섹션 5의 HTTP ABNF 문법을 준수하지 않는 필드가 그렇습니다. 섹션 8.2에서 요구하는 최소값 이외의 필드 유효성 검사를 수행하지 않는 중개자는 잘못된 필드 이름 또는 값이 포함된 메시지를 전달할 수 있습니다.

전달하기 전에 제거가 필요한 필드를 수신하는 중개자\(\[HTTP\]의 섹션 7.6.1 참조\)는 메시지를 전달할 때 해당 헤더 필드를 제거하거나 교체해야 합니다. 또한 중간자는 Content-Length 필드가 포함된 메시지를 전달할 때 메시지가 올바른 형식인지 확인하기 위해 주의를 기울여야 합니다\(섹션 8.1.1\). 이렇게 하면 메시지가 어느 시점에서든 HTTP/1.1로 변환되는 경우 프레이밍이 올바릅니다.\(MUST\)

---
### **10.4.  Cacheability of Pushed Responses**

푸시된 응답에는 클라이언트의 명시적 요청이 없습니다. 요청은 PUSH\_PROMISE 프레임에서 서버에 의해 제공됩니다.

Cache-Control 헤더 필드의 원본 서버에서 제공하는 지침에 따라 푸시되는 응답을 캐싱할 수 있습니다. 그러나 단일 서버가 둘 이상의 테넌트를 호스트하는 경우 문제가 발생할 수 있습니다. 예를 들어 서버는 여러 사용자에게 각각 URI 공간의 작은 부분을 제공할 수 있습니다.

여러 테넌트가 동일한 서버에서 공간을 공유하는 경우 해당 서버는 테넌트가 권한이 없는 리소스 표현을 푸시할 수 없도록 해야 합니다. 이를 적용하지 않으면 테넌트가 권한 있는 테넌트가 제공하는 실제 표현을 무시하고 캐시에서 제공되는 표현을 제공할 수 있습니다.\(MUST\)

원본 서버가 권한이 없는 푸시된 응답\(섹션 10.1 참조\)을 사용하거나 캐시하면 안 됩니다\(MUST NOT\).\(MUST NOT\)

---
### **10.5.  Denial-of-Service Considerations**

HTTP/2 연결은 HTTP/1.1 연결보다 작동하기 위해 더 많은 리소스를 요구할 수 있습니다. 필드 섹션 압축 및 흐름 제어는 모두 더 많은 양의 상태에 대한 약속에 따라 달라집니다. 이러한 기능에 대한 설정은 이러한 기능에 대한 메모리 약정이 엄격하게 제한되도록 합니다.

PUSH\_PROMISE 프레임의 수는 같은 방식으로 제한되지 않습니다. 서버 푸시를 수락하는 클라이언트는 "예약\(원격\)" 상태에 있도록 허용하는 스트림 수를 제한해야 합니다\(SHOULD\). 과도한 수의 서버 푸시 스트림은 ENHANCE\_YOUR\_CALM 유형의 스트림 오류\(섹션 5.4.2\)로 처리될 수 있습니다.\(SHOULD\)

많은 HTTP/2 구현이 서비스 거부에 취약한 것으로 밝혀졌습니다\[NFLX-2019-002\]. 다음은 구현이 서비스 거부 공격을 받을 수 있는 알려진 방법 목록입니다.

\* 미해결 아웃바운드 프레임의 비효율적인 추적은 공격자가 전송을 위해 많은 수의 프레임을 대기열에 추가할 수 있는 경우 과부하로 이어질 수 있습니다. 피어는 여러 기술 중 하나를 사용하여 많은 수의 프레임을 생성할 수 있습니다.

- - WINDOW\_UPDATE 프레임에서 흐름 제어에 작은 증분을 제공하면 발신자가 많은 수의 DATA 프레임을 생성할 수 있습니다.

- - PING 프레임에 응답하려면 엔드포인트가 필요합니다.

```text
      -  Each SETTINGS frame requires acknowledgment.
```

- - 유효하지 않은 요청\(또는 서버 푸시\)으로 인해 피어가 응답으로 RST\_STREAM 프레임을 보낼 수 있습니다.

\* 공격자는 HTTP/2 계층에서 많은 양의 흐름 제어 크레딧을 제공할 수 있지만 TCP 계층에서는 크레딧을 보류하여 프레임이 전송되지 않도록 합니다. TCP 제한을 고려하지 않고 전송할 프레임을 구성하고 기억하는 엔드포인트는 리소스가 고갈될 수 있습니다.

\* 많은 수의 작거나 비어 있는 프레임을 악용하여 피어가 프레임 헤더를 처리하는 데 시간을 소비하게 할 수 있습니다. 작은 프레임의 일부 사용은 스트림 끝에서 빈 DATA 또는 CONTINUATION 프레임을 보내는 것과 같이 완전히 합법적이므로 주의가 필요합니다.

\* SETTINGS 프레임은 피어가 추가 처리 시간을 소비하도록 남용될 수도 있습니다. 무의미하게 설정을 변경하거나, 정의되지 않은 여러 설정을 보내거나, 동일한 프레임에서 동일한 설정을 여러 번 변경하여 이를 수행할 수 있습니다.

\* PRIORITY 프레임으로 우선 순위 재지정을 처리하려면 상당한 처리 시간이 필요할 수 있으며 많은 PRIORITY 프레임이 전송되는 경우 과부하가 발생할 수 있습니다.

\* 필드 섹션 압축은 또한 공격자가 처리 리소스를 낭비할 수 있는 기회를 제공합니다. 잠재적 남용에 대한 자세한 내용은 \[COMPRESSION\]의 섹션 7을 참조하십시오.

\* SETTINGS의 제한은 즉시 감소할 수 없으므로 엔드포인트가 새로운 제한을 초과할 수 있는 피어의 동작에 노출됩니다. 특히, 연결을 설정한 직후 서버에서 설정한 제한은 클라이언트에 알려지지 않으며 명백한 프로토콜 위반 없이 초과될 수 있습니다.

서비스 거부에 악용될 수 있는 대부분의 기능\(예: 설정 변경, 작은 프레임, 필드 섹션 압축\)은 합법적으로 사용됩니다. 이러한 기능은 불필요하게 사용하거나 과도하게 사용할 때만 부담이 됩니다.

이러한 기능의 사용을 모니터링하지 않는 엔드포인트는 서비스 거부 위험에 노출됩니다. 구현은 이러한 기능의 사용을 추적하고 사용 제한을 설정해야 합니다. 엔드포인트는 의심스러운 활동을 ENHANCE\_YOUR\_CALM 유형의 연결 오류\(섹션 5.4.1\)로 처리할 수 있습니다\(MAY\).\(SHOULD, MAY\)

---
#### **10.5.1.  Limits on Field Block Size**

큰 필드 블록\(섹션 4.3\)은 구현이 많은 양의 상태를 커밋하도록 만들 수 있습니다. 라우팅에 중요한 필드 라인은 필드 블록의 끝에 나타날 수 있으며, 이는 필드가 최종 목적지로 스트리밍되는 것을 방지합니다. 이 순서 및 캐시 정확성 보장과 같은 기타 이유는 엔드포인트가 전체 필드 블록을 버퍼링해야 할 수도 있음을 의미합니다. 필드 블록의 크기에 엄격한 제한이 없기 때문에 일부 엔드포인트는 필드 블록에 사용 가능한 많은 양의 메모리를 커밋해야 할 수 있습니다.

끝점은 SETTINGS\_MAX\_HEADER\_LIST\_SIZE를 사용하여 압축되지 않은 필드 블록의 크기에 적용될 수 있는 제한을 동료에게 알릴 수 있습니다. 이 설정은 권고 사항일 뿐이므로 엔드포인트는 이 제한을 초과하는 필드 블록을 보내도록 선택할 수 있으며 요청 또는 응답이 잘못된 형식으로 처리될 위험이 있습니다. 이 설정은 연결에 따라 다르므로 모든 요청 또는 응답에서 더 낮고 알 수 없는 제한이 있는 홉이 발생할 수 있습니다. 중개자는 다른 피어가 제시한 값을 전달하여 이 문제를 피하려고 시도할 수 있지만 그렇게 할 의무는 없습니다.\(MAY\)

처리할 수 있는 것보다 더 큰 필드 블록을 수신하는 서버는 HTTP 431\(요청 헤더 필드가 너무 큼\) 상태 코드\[RFC6585\]를 보낼 수 있습니다. 클라이언트는 처리할 수 없는 응답을 삭제할 수 있습니다. 연결이 닫히지 않는 한 일관된 연결 상태를 보장하기 위해 필드 블록을 처리해야 합니다.\(MUST\)

---
#### **10.5.2.  CONNECT Issues**

TCP 연결의 생성 및 유지 관리에 비해 스트림 생성이 상대적으로 저렴하기 때문에 CONNECT 방법을 사용하여 프록시에 불균형적인 로드를 생성할 수 있습니다. 나가는 TCP 연결이 TIME\_WAIT 상태로 남아 있기 때문에 프록시는 CONNECT 요청을 전달하는 스트림을 닫는 것 이상으로 TCP 연결에 대한 일부 리소스를 유지할 수도 있습니다. 따라서 프록시는 CONNECT 요청에 사용되는 리소스를 제한하기 위해 SETTINGS\_MAX\_CONCURRENT\_STREAMS에만 의존할 수 없습니다.

---
### **10.6.  Use of Compression**

압축을 사용하면 공격자가 제어하는 ​​데이터와 동일한 컨텍스트에서 압축될 때 공격자가 비밀 데이터를 복구할 수 있습니다. HTTP/2는 필드 라인의 압축을 가능하게 합니다\(섹션 4.3\). 다음 문제는 HTTP 압축 콘텐츠 코딩\(\[HTTP\]의 섹션 8.4.1\)의 사용에도 적용됩니다.

웹의 특성을 악용하는 압축에 대한 입증 가능한 공격이 있습니다\(예: \[BREACH\]\). 공격자는 다양한 일반 텍스트를 포함하는 여러 요청을 유도하고 각각의 결과 암호문 길이를 관찰하여 비밀에 대한 추측이 맞을 때 더 짧은 길이를 나타냅니다.

보안 채널에서 통신하는 구현은 각 데이터 소스에 대해 별도의 압축 사전이 사용되지 않는 한 기밀 데이터와 공격자가 제어하는 ​​데이터를 모두 포함하는 콘텐츠를 압축하면 안 됩니다\(MUST NOT\). 데이터 소스를 안정적으로 결정할 수 없는 경우 압축을 사용해서는 안 됩니다. TLS에서 제공하는 것과 같은 일반 스트림 압축은 HTTP/2와 함께 사용하면 안 됩니다\(9.2절 참조\).\(MUST NOT, MUST NOT, MUST NOT\)

헤더 필드의 압축에 관한 추가 고려 사항은 \[COMPRESSION\]에 설명되어 있습니다.

---
### **10.7.  Use of Padding**

HTTP/2 내의 패딩은 TLS\[TLS13\]에서 제공하는 것과 같은 범용 패딩을 대체하기 위한 것이 아닙니다. 중복 패딩은 비생산적일 수도 있습니다. 올바른 적용은 채워지는 데이터에 대한 특정 지식이 있는지 여부에 따라 달라질 수 있습니다.

압축에 의존하는 공격을 완화하려면 패딩을 사용하는 것보다 압축을 비활성화하거나 제한하는 것이 대책으로 더 나을 수 있습니다.

패딩은 프레임 콘텐츠의 정확한 크기를 숨기는 데 사용할 수 있으며 HTTP 내의 특정 공격을 완화하기 위해 제공됩니다. 예를 들어 압축 콘텐츠에 공격자가 제어하는 ​​일반 텍스트와 비밀 데이터가 모두 포함되는 공격\(예: \[BREACH\]\)이 있습니다.

패딩을 사용하면 즉시 명백해 보이는 것보다 보호 수준이 떨어질 수 있습니다. 기껏해야 패딩은 공격자가 관찰해야 하는 프레임 수를 늘려 공격자가 길이 정보를 유추하는 것을 더 어렵게 만듭니다. 잘못 구현된 패딩 체계는 쉽게 무효화될 수 있습니다. 특히 예측 가능한 분포를 가진 무작위 패딩은 거의 보호를 제공하지 않습니다. 마찬가지로 프레임 페이로드를 고정 크기로 패딩하면 프레임 페이로드 크기가 고정 크기 경계를 넘어갈 때 정보가 노출되며, 이는 공격자가 일반 텍스트를 제어할 수 있는 경우 가능할 수 있습니다.

중개자는 DATA 프레임에 대한 패딩을 유지해야 하지만\(SHOULD\) HEADERS 및 PUSH\_PROMISE 프레임에 대한 패딩을 삭제할 수 있습니다\(MAY\). 중개인이 프레임의 패딩 양을 변경하는 타당한 이유는 패딩이 제공하는 보호 기능을 개선하기 위해서입니다.\(SHOULD\)

---
### **10.8.  Privacy Considerations**

HTTP/2의 몇 가지 특성은 관찰자에게 시간이 지남에 따라 단일 클라이언트 또는 서버의 작업을 상호 연관시킬 수 있는 기회를 제공합니다. 여기에는 설정 값, 흐름 제어 창이 관리되는 방식, 스트림에 우선순위가 할당되는 방식, 자극에 대한 반응 타이밍 및 설정에 의해 제어되는 모든 기능의 처리가 포함됩니다.

이것이 관찰 가능한 동작의 차이를 만드는 한, \[개인정보 보호\]의 섹션 3.2에 정의된 대로 특정 클라이언트에 대한 지문을 찍는 기준으로 사용할 수 있습니다.

단일 TCP 연결을 사용하는 HTTP/2의 기본 설정은 사이트에서 사용자 활동의 상관 관계를 허용합니다. 다른 출처에 대한 연결을 재사용하면 해당 출처를 추적할 수 있습니다.

PING 및 SETTINGS 프레임은 즉각적인 응답을 요청하기 때문에 엔드포인트에서 피어에 대한 대기 시간을 측정하는 데 사용할 수 있습니다. 이는 특정 시나리오에서 개인 정보 보호에 영향을 미칠 수 있습니다.

---
### **10.9.  Remote Timing Attacks**

원격 타이밍 공격은 서버가 비밀을 사용하는 요청을 처리할 때 걸리는 시간의 변화를 관찰하여 서버에서 비밀을 추출합니다. HTTP/2는 동시 요청 생성 및 처리를 가능하게 하여 공격자가 요청 처리가 시작되는 시기를 더 잘 제어할 수 있습니다. 여러 HTTP/2 요청이 동일한 IP 패킷 또는 TLS 레코드에 포함될 수 있습니다. 따라서 HTTP/2는 요청 전달의 가변성을 제거하고 요청 순서와 응답 전달만 타이밍 가변성의 소스로 남겨둠으로써 원격 타이밍 공격을 보다 효율적으로 만들 수 있습니다.

처리 시간이 비밀 값에 의존하지 않도록 하는 것이 모든 형태의 타이밍 공격에 대한 최선의 방어입니다.

---
## **11.  IANA Considerations**

이 HTTP/2 개정판은 \[RFC7540\]에 정의된 HTTP2-Settings 헤더 필드와 h2c 업그레이드 토큰을 구식으로 표시합니다.

\[RFC7540\]의 섹션 11은 PRI HTTP 메서드와 함께 h2 및 h2c ALPN 식별자를 등록했습니다. RFC 7540은 또한 프레임 유형, 설정 및 오류 코드에 대한 레지스트리를 설정했습니다. 이러한 등록 및 레지스트리는 HTTP/2에 적용되지만 이 문서에서 다시 정의되지는 않습니다.

IANA는 "TLS ALPN\(Application-Layer Protocol Negotiation\) 프로토콜 ID", "HTTP/2 프레임 유형", "HTTP/2 설정", "HTTP/2 오류 코드" 및 "HTTP 메서드 레지스트리". PRI 방법 등록이 섹션 3.4를 참조하도록 업데이트되었습니다. 다른 모든 섹션 번호는 변경되지 않았습니다.

IANA는 RFC 7540에서 실험용으로 예약된 "HTTP/2 프레임 유형" 및 "HTTP/2 설정" 레지스트리 부분에 대한 정책을 변경했습니다. 레지스트리의 이러한 부분은 나머지 부분과 동일한 정책에서 작동해야 합니다. 각 레지스트리.

---
### **11.1.  HTTP2-Settings Header Field Registration**

이 섹션은 "HTTP\(Hypertext Transfer Protocol\) 필드 이름 레지스트리"에서 \[RFC7540\]의 섹션 11.5에 의해 등록된 HTTP2-Settings 헤더 필드를 폐기된 것으로 표시합니다. 이 기능은 제거되었습니다. 섹션 3.1을 참조하십시오. \[HTTP\]의 섹션 18.4에서 요구하는 세부 정보를 포함하도록 등록이 업데이트됩니다.

```text
   Field Name:  HTTP2-Settings

   Status:  obsoleted
```

참조: \[RFC7540\]의 섹션 3.2.1

의견: 구식; 이 문서의 섹션 11.1을 참조하십시오.

---
### **11.2.  The h2c Upgrade Token**

이 섹션은 "HTTP\(Hypertext Transfer Protocol\) Upgrade Token Registry"에서 \[RFC7540\]의 섹션 11.8에 의해 등록된 h2c 업그레이드 토큰을 폐기된 것으로 기록합니다. 이 기능은 제거되었습니다. 섹션 3.1을 참조하십시오. 등록이 다음과 같이 업데이트됩니다.

```text
   Value:  h2c

   Description:  (OBSOLETE) Hypertext Transfer Protocol version 2
      (HTTP/2)

   Expected Version Tokens:  None
```

참조: 이 문서의 섹션 3.1

---
## **12.  References**
---
### **12.1.  Normative References**

```text
   [CACHING]  Fielding, R., Ed., Nottingham, M., Ed., and J. Reschke,
              Ed., "HTTP Caching", STD 98, RFC 9111,
              DOI 10.17487/RFC9111, June 2022,
              <https://www.rfc-editor.org/info/rfc9111>.

   [COMPRESSION]
              Peon, R. and H. Ruellan, "HPACK: Header Compression for
              HTTP/2", RFC 7541, DOI 10.17487/RFC7541, May 2015,
              <https://www.rfc-editor.org/info/rfc7541>.

   [COOKIE]   Barth, A., "HTTP State Management Mechanism", RFC 6265,
              DOI 10.17487/RFC6265, April 2011,
              <https://www.rfc-editor.org/info/rfc6265>.

   [HTTP]     Fielding, R., Ed., Nottingham, M., Ed., and J. Reschke,
              Ed., "HTTP Semantics", STD 97, RFC 9110,
              DOI 10.17487/RFC9110, June 2022,
              <https://www.rfc-editor.org/info/rfc9110>.

   [QUIC]     Iyengar, J., Ed. and M. Thomson, Ed., "QUIC: A UDP-Based
              Multiplexed and Secure Transport", RFC 9000,
              DOI 10.17487/RFC9000, May 2021,
              <https://www.rfc-editor.org/info/rfc9000>.

   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", BCP 14, RFC 2119,
              DOI 10.17487/RFC2119, March 1997,
              <https://www.rfc-editor.org/info/rfc2119>.

   [RFC3986]  Berners-Lee, T., Fielding, R., and L. Masinter, "Uniform
              Resource Identifier (URI): Generic Syntax", STD 66,
              RFC 3986, DOI 10.17487/RFC3986, January 2005,
              <https://www.rfc-editor.org/info/rfc3986>.

   [RFC8174]  Leiba, B., "Ambiguity of Uppercase vs Lowercase in RFC
              2119 Key Words", BCP 14, RFC 8174, DOI 10.17487/RFC8174,
              May 2017, <https://www.rfc-editor.org/info/rfc8174>.

   [RFC8422]  Nir, Y., Josefsson, S., and M. Pegourie-Gonnard, "Elliptic
              Curve Cryptography (ECC) Cipher Suites for Transport Layer
              Security (TLS) Versions 1.2 and Earlier", RFC 8422,
              DOI 10.17487/RFC8422, August 2018,
              <https://www.rfc-editor.org/info/rfc8422>.

   [RFC8470]  Thomson, M., Nottingham, M., and W. Tarreau, "Using Early
              Data in HTTP", RFC 8470, DOI 10.17487/RFC8470, September
              2018, <https://www.rfc-editor.org/info/rfc8470>.

   [TCP]      Postel, J., "Transmission Control Protocol", STD 7,
              RFC 793, DOI 10.17487/RFC0793, September 1981,
              <https://www.rfc-editor.org/info/rfc793>.

   [TLS-ALPN] Friedl, S., Popov, A., Langley, A., and E. Stephan,
              "Transport Layer Security (TLS) Application-Layer Protocol
              Negotiation Extension", RFC 7301, DOI 10.17487/RFC7301,
              July 2014, <https://www.rfc-editor.org/info/rfc7301>.

   [TLS-ECDHE]
              Rescorla, E., "TLS Elliptic Curve Cipher Suites with SHA-
              256/384 and AES Galois Counter Mode (GCM)", RFC 5289,
              DOI 10.17487/RFC5289, August 2008,
              <https://www.rfc-editor.org/info/rfc5289>.

   [TLS-EXT]  Eastlake 3rd, D., "Transport Layer Security (TLS)
              Extensions: Extension Definitions", RFC 6066,
              DOI 10.17487/RFC6066, January 2011,
              <https://www.rfc-editor.org/info/rfc6066>.

   [TLS12]    Dierks, T. and E. Rescorla, "The Transport Layer Security
              (TLS) Protocol Version 1.2", RFC 5246,
              DOI 10.17487/RFC5246, August 2008,
              <https://www.rfc-editor.org/info/rfc5246>.

   [TLS13]    Rescorla, E., "The Transport Layer Security (TLS) Protocol
              Version 1.3", RFC 8446, DOI 10.17487/RFC8446, August 2018,
              <https://www.rfc-editor.org/info/rfc8446>.

   [TLSBCP]   Sheffer, Y., Holz, R., and P. Saint-Andre,
              "Recommendations for Secure Use of Transport Layer
              Security (TLS) and Datagram Transport Layer Security
              (DTLS)", BCP 195, RFC 7525, DOI 10.17487/RFC7525, May
              2015, <https://www.rfc-editor.org/info/rfc7525>.
```

---
### **12.2.  Informative References**

```text
   [ALT-SVC]  Nottingham, M., McManus, P., and J. Reschke, "HTTP
              Alternative Services", RFC 7838, DOI 10.17487/RFC7838,
              April 2016, <https://www.rfc-editor.org/info/rfc7838>.

   [BREACH]   Gluck, Y., Harris, N., and A. Prado, "BREACH: Reviving the
              CRIME Attack", 12 July 2013,
              <https://breachattack.com/resources/
              BREACH%20-%20SSL,%20gone%20in%2030%20seconds.pdf>.

   [DNS-TERMS]
              Hoffman, P., Sullivan, A., and K. Fujiwara, "DNS
              Terminology", BCP 219, RFC 8499, DOI 10.17487/RFC8499,
              January 2019, <https://www.rfc-editor.org/info/rfc8499>.

   [HTTP-PRIORITY]
              Oku, K. and L. Pardue, "Extensible Prioritization Scheme
              for HTTP", RFC 9218, DOI 10.17487/RFC9218, June 2022,
              <https://www.rfc-editor.org/info/rfc9218>.

   [HTTP/1.1] Fielding, R., Ed., Nottingham, M., Ed., and J. Reschke,
              Ed., "HTTP/1.1", STD 99, RFC 9112, DOI 10.17487/RFC9112,
              June 2022, <https://www.rfc-editor.org/info/rfc9112>.

   [NFLX-2019-002]
              Netflix, "HTTP/2 Denial of Service Advisory", 13 August
              2019, <https://github.com/Netflix/security-
              bulletins/blob/master/advisories/third-party/2019-002.md>.

   [PRIVACY]  Cooper, A., Tschofenig, H., Aboba, B., Peterson, J.,
              Morris, J., Hansen, M., and R. Smith, "Privacy
              Considerations for Internet Protocols", RFC 6973,
              DOI 10.17487/RFC6973, July 2013,
              <https://www.rfc-editor.org/info/rfc6973>.

   [RFC1122]  Braden, R., Ed., "Requirements for Internet Hosts -
              Communication Layers", STD 3, RFC 1122,
              DOI 10.17487/RFC1122, October 1989,
              <https://www.rfc-editor.org/info/rfc1122>.

   [RFC3749]  Hollenbeck, S., "Transport Layer Security Protocol
              Compression Methods", RFC 3749, DOI 10.17487/RFC3749, May
              2004, <https://www.rfc-editor.org/info/rfc3749>.

   [RFC6125]  Saint-Andre, P. and J. Hodges, "Representation and
              Verification of Domain-Based Application Service Identity
              within Internet Public Key Infrastructure Using X.509
              (PKIX) Certificates in the Context of Transport Layer
              Security (TLS)", RFC 6125, DOI 10.17487/RFC6125, March
              2011, <https://www.rfc-editor.org/info/rfc6125>.

   [RFC6585]  Nottingham, M. and R. Fielding, "Additional HTTP Status
              Codes", RFC 6585, DOI 10.17487/RFC6585, April 2012,
              <https://www.rfc-editor.org/info/rfc6585>.

   [RFC7323]  Borman, D., Braden, B., Jacobson, V., and R.
              Scheffenegger, Ed., "TCP Extensions for High Performance",
              RFC 7323, DOI 10.17487/RFC7323, September 2014,
              <https://www.rfc-editor.org/info/rfc7323>.

   [RFC7540]  Belshe, M., Peon, R., and M. Thomson, Ed., "Hypertext
              Transfer Protocol Version 2 (HTTP/2)", RFC 7540,
              DOI 10.17487/RFC7540, May 2015,
              <https://www.rfc-editor.org/info/rfc7540>.

   [RFC8441]  McManus, P., "Bootstrapping WebSockets with HTTP/2",
              RFC 8441, DOI 10.17487/RFC8441, September 2018,
              <https://www.rfc-editor.org/info/rfc8441>.

   [RFC8740]  Benjamin, D., "Using TLS 1.3 with HTTP/2", RFC 8740,
              DOI 10.17487/RFC8740, February 2020,
              <https://www.rfc-editor.org/info/rfc8740>.

   [TALKING]  Huang, L., Chen, E., Barth, A., Rescorla, E., and C.
              Jackson, "Talking to Yourself for Fun and Profit", 2011,
              <https://www.adambarth.com/papers/2011/huang-chen-barth-
              rescorla-jackson.pdf>.
```

---
# **Appendix A.  Prohibited TLS 1.2 Cipher Suites**

HTTP/2 구현은 INADEQUATE\_SECURITY 유형의 연결 오류\(섹션 5.4.1\)로 TLS 1.2를 사용한 다음 암호 제품군의 협상을 처리할 수 있습니다\(MAY\).\(MAY\)

```text
   *  TLS_NULL_WITH_NULL_NULL
   *  TLS_RSA_WITH_NULL_MD5
   *  TLS_RSA_WITH_NULL_SHA
   *  TLS_RSA_EXPORT_WITH_RC4_40_MD5
   *  TLS_RSA_WITH_RC4_128_MD5
   *  TLS_RSA_WITH_RC4_128_SHA
   *  TLS_RSA_EXPORT_WITH_RC2_CBC_40_MD5
   *  TLS_RSA_WITH_IDEA_CBC_SHA
   *  TLS_RSA_EXPORT_WITH_DES40_CBC_SHA
   *  TLS_RSA_WITH_DES_CBC_SHA
   *  TLS_RSA_WITH_3DES_EDE_CBC_SHA
   *  TLS_DH_DSS_EXPORT_WITH_DES40_CBC_SHA
   *  TLS_DH_DSS_WITH_DES_CBC_SHA
   *  TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA
   *  TLS_DH_RSA_EXPORT_WITH_DES40_CBC_SHA
   *  TLS_DH_RSA_WITH_DES_CBC_SHA
   *  TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA
   *  TLS_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA
   *  TLS_DHE_DSS_WITH_DES_CBC_SHA
   *  TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA
   *  TLS_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA
   *  TLS_DHE_RSA_WITH_DES_CBC_SHA
   *  TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA
   *  TLS_DH_anon_EXPORT_WITH_RC4_40_MD5
   *  TLS_DH_anon_WITH_RC4_128_MD5
   *  TLS_DH_anon_EXPORT_WITH_DES40_CBC_SHA
   *  TLS_DH_anon_WITH_DES_CBC_SHA
   *  TLS_DH_anon_WITH_3DES_EDE_CBC_SHA
   *  TLS_KRB5_WITH_DES_CBC_SHA
   *  TLS_KRB5_WITH_3DES_EDE_CBC_SHA
   *  TLS_KRB5_WITH_RC4_128_SHA
   *  TLS_KRB5_WITH_IDEA_CBC_SHA
   *  TLS_KRB5_WITH_DES_CBC_MD5
   *  TLS_KRB5_WITH_3DES_EDE_CBC_MD5
   *  TLS_KRB5_WITH_RC4_128_MD5
   *  TLS_KRB5_WITH_IDEA_CBC_MD5
   *  TLS_KRB5_EXPORT_WITH_DES_CBC_40_SHA
   *  TLS_KRB5_EXPORT_WITH_RC2_CBC_40_SHA
   *  TLS_KRB5_EXPORT_WITH_RC4_40_SHA
   *  TLS_KRB5_EXPORT_WITH_DES_CBC_40_MD5
   *  TLS_KRB5_EXPORT_WITH_RC2_CBC_40_MD5
   *  TLS_KRB5_EXPORT_WITH_RC4_40_MD5
   *  TLS_PSK_WITH_NULL_SHA
   *  TLS_DHE_PSK_WITH_NULL_SHA
   *  TLS_RSA_PSK_WITH_NULL_SHA
   *  TLS_RSA_WITH_AES_128_CBC_SHA
   *  TLS_DH_DSS_WITH_AES_128_CBC_SHA
   *  TLS_DH_RSA_WITH_AES_128_CBC_SHA
   *  TLS_DHE_DSS_WITH_AES_128_CBC_SHA
   *  TLS_DHE_RSA_WITH_AES_128_CBC_SHA
   *  TLS_DH_anon_WITH_AES_128_CBC_SHA
   *  TLS_RSA_WITH_AES_256_CBC_SHA
   *  TLS_DH_DSS_WITH_AES_256_CBC_SHA
   *  TLS_DH_RSA_WITH_AES_256_CBC_SHA
   *  TLS_DHE_DSS_WITH_AES_256_CBC_SHA
   *  TLS_DHE_RSA_WITH_AES_256_CBC_SHA
   *  TLS_DH_anon_WITH_AES_256_CBC_SHA
   *  TLS_RSA_WITH_NULL_SHA256
   *  TLS_RSA_WITH_AES_128_CBC_SHA256
   *  TLS_RSA_WITH_AES_256_CBC_SHA256
   *  TLS_DH_DSS_WITH_AES_128_CBC_SHA256
   *  TLS_DH_RSA_WITH_AES_128_CBC_SHA256
   *  TLS_DHE_DSS_WITH_AES_128_CBC_SHA256
   *  TLS_RSA_WITH_CAMELLIA_128_CBC_SHA
   *  TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA
   *  TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA
   *  TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA
   *  TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA
   *  TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA
   *  TLS_DHE_RSA_WITH_AES_128_CBC_SHA256
   *  TLS_DH_DSS_WITH_AES_256_CBC_SHA256
   *  TLS_DH_RSA_WITH_AES_256_CBC_SHA256
   *  TLS_DHE_DSS_WITH_AES_256_CBC_SHA256
   *  TLS_DHE_RSA_WITH_AES_256_CBC_SHA256
   *  TLS_DH_anon_WITH_AES_128_CBC_SHA256
   *  TLS_DH_anon_WITH_AES_256_CBC_SHA256
   *  TLS_RSA_WITH_CAMELLIA_256_CBC_SHA
   *  TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA
   *  TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA
   *  TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA
   *  TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA
   *  TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA
   *  TLS_PSK_WITH_RC4_128_SHA
   *  TLS_PSK_WITH_3DES_EDE_CBC_SHA
   *  TLS_PSK_WITH_AES_128_CBC_SHA
   *  TLS_PSK_WITH_AES_256_CBC_SHA
   *  TLS_DHE_PSK_WITH_RC4_128_SHA
   *  TLS_DHE_PSK_WITH_3DES_EDE_CBC_SHA
   *  TLS_DHE_PSK_WITH_AES_128_CBC_SHA
   *  TLS_DHE_PSK_WITH_AES_256_CBC_SHA
   *  TLS_RSA_PSK_WITH_RC4_128_SHA
   *  TLS_RSA_PSK_WITH_3DES_EDE_CBC_SHA
   *  TLS_RSA_PSK_WITH_AES_128_CBC_SHA
   *  TLS_RSA_PSK_WITH_AES_256_CBC_SHA
   *  TLS_RSA_WITH_SEED_CBC_SHA
   *  TLS_DH_DSS_WITH_SEED_CBC_SHA
   *  TLS_DH_RSA_WITH_SEED_CBC_SHA
   *  TLS_DHE_DSS_WITH_SEED_CBC_SHA
   *  TLS_DHE_RSA_WITH_SEED_CBC_SHA
   *  TLS_DH_anon_WITH_SEED_CBC_SHA
   *  TLS_RSA_WITH_AES_128_GCM_SHA256
   *  TLS_RSA_WITH_AES_256_GCM_SHA384
   *  TLS_DH_RSA_WITH_AES_128_GCM_SHA256
   *  TLS_DH_RSA_WITH_AES_256_GCM_SHA384
   *  TLS_DH_DSS_WITH_AES_128_GCM_SHA256
   *  TLS_DH_DSS_WITH_AES_256_GCM_SHA384
   *  TLS_DH_anon_WITH_AES_128_GCM_SHA256
   *  TLS_DH_anon_WITH_AES_256_GCM_SHA384
   *  TLS_PSK_WITH_AES_128_GCM_SHA256
   *  TLS_PSK_WITH_AES_256_GCM_SHA384
   *  TLS_RSA_PSK_WITH_AES_128_GCM_SHA256
   *  TLS_RSA_PSK_WITH_AES_256_GCM_SHA384
   *  TLS_PSK_WITH_AES_128_CBC_SHA256
   *  TLS_PSK_WITH_AES_256_CBC_SHA384
   *  TLS_PSK_WITH_NULL_SHA256
   *  TLS_PSK_WITH_NULL_SHA384
   *  TLS_DHE_PSK_WITH_AES_128_CBC_SHA256
   *  TLS_DHE_PSK_WITH_AES_256_CBC_SHA384
   *  TLS_DHE_PSK_WITH_NULL_SHA256
   *  TLS_DHE_PSK_WITH_NULL_SHA384
   *  TLS_RSA_PSK_WITH_AES_128_CBC_SHA256
   *  TLS_RSA_PSK_WITH_AES_256_CBC_SHA384
   *  TLS_RSA_PSK_WITH_NULL_SHA256
   *  TLS_RSA_PSK_WITH_NULL_SHA384
   *  TLS_RSA_WITH_CAMELLIA_128_CBC_SHA256
   *  TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA256
   *  TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA256
   *  TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA256
   *  TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA256
   *  TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA256
   *  TLS_RSA_WITH_CAMELLIA_256_CBC_SHA256
   *  TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA256
   *  TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA256
   *  TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA256
   *  TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA256
   *  TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA256
   *  TLS_EMPTY_RENEGOTIATION_INFO_SCSV
   *  TLS_ECDH_ECDSA_WITH_NULL_SHA
   *  TLS_ECDH_ECDSA_WITH_RC4_128_SHA
   *  TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA
   *  TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA
   *  TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA
   *  TLS_ECDHE_ECDSA_WITH_NULL_SHA
   *  TLS_ECDHE_ECDSA_WITH_RC4_128_SHA
   *  TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA
   *  TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA
   *  TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA
   *  TLS_ECDH_RSA_WITH_NULL_SHA
   *  TLS_ECDH_RSA_WITH_RC4_128_SHA
   *  TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA
   *  TLS_ECDH_RSA_WITH_AES_128_CBC_SHA
   *  TLS_ECDH_RSA_WITH_AES_256_CBC_SHA
   *  TLS_ECDHE_RSA_WITH_NULL_SHA
   *  TLS_ECDHE_RSA_WITH_RC4_128_SHA
   *  TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA
   *  TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA
   *  TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA
   *  TLS_ECDH_anon_WITH_NULL_SHA
   *  TLS_ECDH_anon_WITH_RC4_128_SHA
   *  TLS_ECDH_anon_WITH_3DES_EDE_CBC_SHA
   *  TLS_ECDH_anon_WITH_AES_128_CBC_SHA
   *  TLS_ECDH_anon_WITH_AES_256_CBC_SHA
   *  TLS_SRP_SHA_WITH_3DES_EDE_CBC_SHA
   *  TLS_SRP_SHA_RSA_WITH_3DES_EDE_CBC_SHA
   *  TLS_SRP_SHA_DSS_WITH_3DES_EDE_CBC_SHA
   *  TLS_SRP_SHA_WITH_AES_128_CBC_SHA
   *  TLS_SRP_SHA_RSA_WITH_AES_128_CBC_SHA
   *  TLS_SRP_SHA_DSS_WITH_AES_128_CBC_SHA
   *  TLS_SRP_SHA_WITH_AES_256_CBC_SHA
   *  TLS_SRP_SHA_RSA_WITH_AES_256_CBC_SHA
   *  TLS_SRP_SHA_DSS_WITH_AES_256_CBC_SHA
   *  TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256
   *  TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384
   *  TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256
   *  TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384
   *  TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256
   *  TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384
   *  TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256
   *  TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384
   *  TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256
   *  TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384
   *  TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256
   *  TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384
   *  TLS_ECDHE_PSK_WITH_RC4_128_SHA
   *  TLS_ECDHE_PSK_WITH_3DES_EDE_CBC_SHA
   *  TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA
   *  TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA
   *  TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA256
   *  TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA384
   *  TLS_ECDHE_PSK_WITH_NULL_SHA
   *  TLS_ECDHE_PSK_WITH_NULL_SHA256
   *  TLS_ECDHE_PSK_WITH_NULL_SHA384
   *  TLS_RSA_WITH_ARIA_128_CBC_SHA256
   *  TLS_RSA_WITH_ARIA_256_CBC_SHA384
   *  TLS_DH_DSS_WITH_ARIA_128_CBC_SHA256
   *  TLS_DH_DSS_WITH_ARIA_256_CBC_SHA384
   *  TLS_DH_RSA_WITH_ARIA_128_CBC_SHA256
   *  TLS_DH_RSA_WITH_ARIA_256_CBC_SHA384
   *  TLS_DHE_DSS_WITH_ARIA_128_CBC_SHA256
   *  TLS_DHE_DSS_WITH_ARIA_256_CBC_SHA384
   *  TLS_DHE_RSA_WITH_ARIA_128_CBC_SHA256
   *  TLS_DHE_RSA_WITH_ARIA_256_CBC_SHA384
   *  TLS_DH_anon_WITH_ARIA_128_CBC_SHA256
   *  TLS_DH_anon_WITH_ARIA_256_CBC_SHA384
   *  TLS_ECDHE_ECDSA_WITH_ARIA_128_CBC_SHA256
   *  TLS_ECDHE_ECDSA_WITH_ARIA_256_CBC_SHA384
   *  TLS_ECDH_ECDSA_WITH_ARIA_128_CBC_SHA256
   *  TLS_ECDH_ECDSA_WITH_ARIA_256_CBC_SHA384
   *  TLS_ECDHE_RSA_WITH_ARIA_128_CBC_SHA256
   *  TLS_ECDHE_RSA_WITH_ARIA_256_CBC_SHA384
   *  TLS_ECDH_RSA_WITH_ARIA_128_CBC_SHA256
   *  TLS_ECDH_RSA_WITH_ARIA_256_CBC_SHA384
   *  TLS_RSA_WITH_ARIA_128_GCM_SHA256
   *  TLS_RSA_WITH_ARIA_256_GCM_SHA384
   *  TLS_DH_RSA_WITH_ARIA_128_GCM_SHA256
   *  TLS_DH_RSA_WITH_ARIA_256_GCM_SHA384
   *  TLS_DH_DSS_WITH_ARIA_128_GCM_SHA256
   *  TLS_DH_DSS_WITH_ARIA_256_GCM_SHA384
   *  TLS_DH_anon_WITH_ARIA_128_GCM_SHA256
   *  TLS_DH_anon_WITH_ARIA_256_GCM_SHA384
   *  TLS_ECDH_ECDSA_WITH_ARIA_128_GCM_SHA256
   *  TLS_ECDH_ECDSA_WITH_ARIA_256_GCM_SHA384
   *  TLS_ECDH_RSA_WITH_ARIA_128_GCM_SHA256
   *  TLS_ECDH_RSA_WITH_ARIA_256_GCM_SHA384
   *  TLS_PSK_WITH_ARIA_128_CBC_SHA256
   *  TLS_PSK_WITH_ARIA_256_CBC_SHA384
   *  TLS_DHE_PSK_WITH_ARIA_128_CBC_SHA256
   *  TLS_DHE_PSK_WITH_ARIA_256_CBC_SHA384
   *  TLS_RSA_PSK_WITH_ARIA_128_CBC_SHA256
   *  TLS_RSA_PSK_WITH_ARIA_256_CBC_SHA384
   *  TLS_PSK_WITH_ARIA_128_GCM_SHA256
   *  TLS_PSK_WITH_ARIA_256_GCM_SHA384
   *  TLS_RSA_PSK_WITH_ARIA_128_GCM_SHA256
   *  TLS_RSA_PSK_WITH_ARIA_256_GCM_SHA384
   *  TLS_ECDHE_PSK_WITH_ARIA_128_CBC_SHA256
   *  TLS_ECDHE_PSK_WITH_ARIA_256_CBC_SHA384
   *  TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_CBC_SHA256
   *  TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_CBC_SHA384
   *  TLS_ECDH_ECDSA_WITH_CAMELLIA_128_CBC_SHA256
   *  TLS_ECDH_ECDSA_WITH_CAMELLIA_256_CBC_SHA384
   *  TLS_ECDHE_RSA_WITH_CAMELLIA_128_CBC_SHA256
   *  TLS_ECDHE_RSA_WITH_CAMELLIA_256_CBC_SHA384
   *  TLS_ECDH_RSA_WITH_CAMELLIA_128_CBC_SHA256
   *  TLS_ECDH_RSA_WITH_CAMELLIA_256_CBC_SHA384
   *  TLS_RSA_WITH_CAMELLIA_128_GCM_SHA256
   *  TLS_RSA_WITH_CAMELLIA_256_GCM_SHA384
   *  TLS_DH_RSA_WITH_CAMELLIA_128_GCM_SHA256
   *  TLS_DH_RSA_WITH_CAMELLIA_256_GCM_SHA384
   *  TLS_DH_DSS_WITH_CAMELLIA_128_GCM_SHA256
   *  TLS_DH_DSS_WITH_CAMELLIA_256_GCM_SHA384
   *  TLS_DH_anon_WITH_CAMELLIA_128_GCM_SHA256
   *  TLS_DH_anon_WITH_CAMELLIA_256_GCM_SHA384
   *  TLS_ECDH_ECDSA_WITH_CAMELLIA_128_GCM_SHA256
   *  TLS_ECDH_ECDSA_WITH_CAMELLIA_256_GCM_SHA384
   *  TLS_ECDH_RSA_WITH_CAMELLIA_128_GCM_SHA256
   *  TLS_ECDH_RSA_WITH_CAMELLIA_256_GCM_SHA384
   *  TLS_PSK_WITH_CAMELLIA_128_GCM_SHA256
   *  TLS_PSK_WITH_CAMELLIA_256_GCM_SHA384
   *  TLS_RSA_PSK_WITH_CAMELLIA_128_GCM_SHA256
   *  TLS_RSA_PSK_WITH_CAMELLIA_256_GCM_SHA384
   *  TLS_PSK_WITH_CAMELLIA_128_CBC_SHA256
   *  TLS_PSK_WITH_CAMELLIA_256_CBC_SHA384
   *  TLS_DHE_PSK_WITH_CAMELLIA_128_CBC_SHA256
   *  TLS_DHE_PSK_WITH_CAMELLIA_256_CBC_SHA384
   *  TLS_RSA_PSK_WITH_CAMELLIA_128_CBC_SHA256
   *  TLS_RSA_PSK_WITH_CAMELLIA_256_CBC_SHA384
   *  TLS_ECDHE_PSK_WITH_CAMELLIA_128_CBC_SHA256
   *  TLS_ECDHE_PSK_WITH_CAMELLIA_256_CBC_SHA384
   *  TLS_RSA_WITH_AES_128_CCM
   *  TLS_RSA_WITH_AES_256_CCM
   *  TLS_RSA_WITH_AES_128_CCM_8
   *  TLS_RSA_WITH_AES_256_CCM_8
   *  TLS_PSK_WITH_AES_128_CCM
   *  TLS_PSK_WITH_AES_256_CCM
   *  TLS_PSK_WITH_AES_128_CCM_8
   *  TLS_PSK_WITH_AES_256_CCM_8
```

- | 참고: 이 목록은 등록된 TLS | \[RFC7540\]이 개발되었을 때 암호 제품군. 이 목록에는 | 임시 키 교환을 제공하지 않는 암호 제품군 | 및 TLS null, 스트림 또는 블록을 기반으로 하는 것 | 암호 유형\(\[TLS12\]의 섹션 6.2.3에 정의됨\). | 이러한 속성을 가진 추가 암호 제품군은 다음과 같을 수 있습니다. | 한정된; 이는 명시적으로 금지되지 않습니다.

자세한 내용은 섹션 9.2.2를 참조하십시오.

---
# **Appendix B.  Changes from RFC 7540**

이 개정에는 다음과 같은 실질적인 변경 사항이 포함됩니다.

\* TLS 1.3 사용은 이 문서에서 폐기된 \[RFC8740\]을 기반으로 정의되었습니다.

\* RFC 7540에 정의된 우선 순위 체계는 더 이상 사용되지 않습니다.

- PRIORITY 프레임의 형식 및 HEADERS 프레임의 우선 순위 필드에 대한 정의와 PRIORITY 프레임을 보내고 받을 수 있는 시기를 관리하는 규칙이 유지되었지만 이러한 필드의 의미 체계는 RFC 7540에만 설명되어 있습니다. 우선 순위 신호 RFC 7540의 체계는 성공하지 못했습니다. \[HTTP-PRIORITY\]에서 더 간단한 시그널링을 사용하는 것이 좋습니다.

\* HTTP/1.1 업그레이드 메커니즘은 더 이상 사용되지 않으며 이 문서에 더 이상 지정되지 않습니다. 일반 텍스트 HTTP/2 사용자가 대신 사전 지식 구현을 사용하기로 선택했기 때문에 널리 배포되지 않았습니다.

\* 필드 이름 및 값에 대한 유효성 검사 범위가 좁아졌습니다. 중개자에게 필수인 유효성 검사가 정확하게 정의되었으며 요청에 대한 오류 보고가 400 시리즈 상태 코드 전송을 장려하도록 수정되었습니다.

\* 실험용으로 예약된 설정 및 프레임 유형의 코드 포인트 범위를 이제 일반 용도로 사용할 수 있습니다.

\* 금지된 연결별 헤더 필드가 보다 정확하고 포괄적으로 식별됩니다.

\* 호스트와 ":authority"는 더 이상 동의할 수 없습니다.

\* 설정 변경 후 동적 테이블 크기 업데이트 지침을 보내는 규칙은 섹션 4.3.1에 명시되어 있습니다.

편집 변경 사항도 포함됩니다. 특히 용어 및 문서 구조에 대한 변경 사항은 핵심 HTTP 의미\[HTTP\]에 대한 업데이트에 대한 응답입니다. 이러한 문서에는 이제 421 상태 코드 또는 연결 통합과 같이 RFC 7540에서 처음 정의된 몇 가지 개념이 포함됩니다.

---
# **Acknowledgments**

이 문서에 적지 않은 정보를 제공한 것은 수년 동안 HTTP 워킹 그룹에 기여한 많은 사람들 덕분입니다. \[RFC7540\]에는 그들의 기여에 대해 인정받을 자격이 있는 사람들의 보다 광범위한 목록이 포함되어 있습니다.

---
# **Contributors**

Mike Belshe와 Roberto Peon은 이 문서의 기반이 되는 텍스트를 작성했습니다.

---
# **Authors' Addresses**

```text
   Martin Thomson (editor)
   Mozilla
   Australia
   Email: mt@lowentropy.net

   Cory Benfield (editor)
   Apple Inc.
   Email: cbenfield@apple.com
```


```text
Internet Engineering Task Force (IETF)                    M. Chadalapaka
Request for Comments: 7143                                     Microsoft
Obsoletes: 3720, 3980, 4850, 5048                              J. Satran
Updates: 3721                                             Infinidat Ltd.
Category: Standards Track                                        K. Meth
ISSN: 2070-1721                                                      IBM
                                                                D. Black
                                                                     EMC
                                                              April 2014

       Internet Small Computer System Interface (iSCSI) Protocol
                             (Consolidated)
```

---
# **Abstract**

이 문서에서는 TCP 위에서 작동하는 SCSI용 전송 프로토콜을 설명합니다. iSCSI 프로토콜은 표준화된 SCSI 아키텍처 모델\(SAM-2\)과 완벽하게 호환되는 것을 목표로 합니다. RFC 3720은 원래 iSCSI 프로토콜을 정의했습니다. RFC 3721에서는 iSCSI 이름 지정 예와 검색 기술에 대해 설명합니다. 이후 RFC 3980은 iSCSI 프로토콜에 추가 명명 형식을 추가했습니다. RFC 4850에서는 iSCSI에 새로운 공개 확장 키를 추가했습니다. RFC 5048은 원래 iSCSI 프로토콜에 대한 몇 가지 개선 사항과 수정 사항뿐만 아니라 여러 가지 설명을 제공했습니다.

이 문서는 RFC 3720, 3980, 4850 및 5048을 단일 문서로 통합하고 통합 사양을 추가로 업데이트하여 더 이상 사용되지 않습니다. 이 문서는 RFC 3721도 업데이트합니다. 따라서 의미 체계에 차이가 있는 경우 이 문서의 텍스트가 언급된 모든 RFC의 텍스트를 대체합니다.

---
# **Status of This Memo**

이것은 인터넷 표준 추적 문서입니다.

이 문서는 IETF\(Internet Engineering Task Force\)의 제품입니다. 이는 IETF 커뮤니티의 합의를 나타냅니다. 공개 검토를 받았으며 IESG\(Internet Engineering Steering Group\)의 출판 승인을 받았습니다. 인터넷 표준에 대한 자세한 내용은 RFC 5741의 섹션 2에서 확인할 수 있습니다.

이 문서의 현재 상태, 정오표, 피드백 제공 방법에 대한 정보는 http://www.rfc-editor.org/info/rfc7143에서 얻을 수 있습니다.

---
# **Copyright Notice**

Copyright \(c\) 2014 IETF Trust 및 문서 작성자로 식별된 사람. 판권 소유.

이 문서는 이 문서의 발행일에 유효한 BCP 78 및 IETF 문서에 관한 IETF 트러스트의 법적 조항\(http://trustee.ietf.org/license-info\)의 적용을 받습니다. 이 문서와 관련된 귀하의 권리 및 제한 사항을 설명하므로 이 문서를 주의 깊게 검토하십시오. 이 문서에서 추출한 코드 구성 요소는 Trust Legal Provisions의 섹션 4.e에 설명된 대로 Simplified BSD License 텍스트를 포함해야 하며 Simplified BSD License에 설명된 대로 보증 없이 제공됩니다.

---
# **Table of Contents**

```text
   1. Introduction ...................................................11
   2. Acronyms, Definitions, and Document Summary ....................11
      2.1. Acronyms ..................................................11
      2.2. Definitions ...............................................13
      2.3. Summary of Changes ........................................19
      2.4. Conventions ...............................................20
   3. UML Conventions ................................................20
      3.1. UML Conventions Overview ..................................20
      3.2. Multiplicity Notion .......................................21
      3.3. Class Diagram Conventions .................................22
      3.4. Class Diagram Notation for Associations ...................23
      3.5. Class Diagram Notation for Aggregations ...................24
      3.6. Class Diagram Notation for Generalizations ................25
   4. Overview .......................................................25
      4.1. SCSI Concepts .............................................25
      4.2. iSCSI Concepts and Functional Overview ....................26
           4.2.1. Layers and Sessions ................................27
           4.2.2. Ordering and iSCSI Numbering .......................28
                  4.2.2.1. Command Numbering and Acknowledging .......28
                  4.2.2.2. Response/Status Numbering and
                           Acknowledging .............................32
                  4.2.2.3. Response Ordering .........................32
                           4.2.2.3.1. Need for Response Ordering .....32
                           4.2.2.3.2. Response Ordering Model
                                      Description ....................33
                           4.2.2.3.3. iSCSI Semantics with
                                      the Interface Model ............33
                           4.2.2.3.4. Current List of Fenced
                                      Response Use Cases .............34
                  4.2.2.4. Data Sequencing ...........................35
           4.2.3. iSCSI Task Management ..............................36
                  4.2.3.1. Task Management Overview ..................36
                  4.2.3.2. Notion of Affected Tasks ..................36
                  4.2.3.3. Standard Multi-Task Abort Semantics .......37
                  4.2.3.4. FastAbort Multi-Task Abort Semantics ......38
                  4.2.3.5. Affected Tasks Shared across
                           Standard and FastAbort Sessions ...........40
                  4.2.3.6. Rationale behind the FastAbort Semantics ..41
           4.2.4. iSCSI Login ........................................42
           4.2.5. iSCSI Full Feature Phase ...........................44
                  4.2.5.1. Command Connection Allegiance .............44
                  4.2.5.2. Data Transfer Overview ....................45
                  4.2.5.3. Tags and Integrity Checks .................46
                  4.2.5.4. SCSI Task Management during iSCSI
                           Full Feature Phase ........................47
           4.2.6. iSCSI Connection Termination .......................47
           4.2.7. iSCSI Names ........................................47
                  4.2.7.1. iSCSI Name Properties .....................48
                  4.2.7.2. iSCSI Name Encoding .......................50
                  4.2.7.3. iSCSI Name Structure ......................51
                  4.2.7.4. Type "iqn." (iSCSI Qualified Name) ........52
                  4.2.7.5. Type "eui." (IEEE EUI-64 Format) ..........53
                  4.2.7.6. Type "naa." (Network Address Authority) ...54
           4.2.8. Persistent State ...................................55
           4.2.9. Message Synchronization and Steering ...............55
                  4.2.9.1. Sync/Steering and iSCSI PDU Length ........56
      4.3. iSCSI Session Types .......................................56
      4.4. SCSI-to-iSCSI Concepts Mapping Model ......................57
           4.4.1. iSCSI Architecture Model ...........................58
           4.4.2. SCSI Architecture Model ............................59
           4.4.3. Consequences of the Model ..........................61
                  4.4.3.1. I_T Nexus State ...........................62
                  4.4.3.2. Reservations ..............................63
      4.5. iSCSI UML Model ...........................................64
      4.6. Request/Response Summary ..................................66
           4.6.1. Request/Response Types Carrying SCSI Payload .......66
                  4.6.1.1. SCSI Command ..............................66
                  4.6.1.2. SCSI Response .............................66
                  4.6.1.3. Task Management Function Request ..........67
                  4.6.1.4. Task Management Function Response .........68
                  4.6.1.5. SCSI Data-Out and SCSI Data-In ............68
                  4.6.1.6. Ready To Transfer (R2T) ...................69
           4.6.2. Requests/Responses Carrying SCSI and iSCSI
                  Payload ............................................69
                  4.6.2.1. Asynchronous Message ......................69
           4.6.3. Requests/Responses Carrying iSCSI-Only Payload .....69
                  4.6.3.1. Text Requests and Text Responses ..........69
                  4.6.3.2. Login Requests and Login Responses ........70
                  4.6.3.3. Logout Requests and Logout Responses ......71
                  4.6.3.4. SNACK Request .............................71
                  4.6.3.5. Reject ....................................71
                  4.6.3.6. NOP-Out Request and NOP-In Response .......71
   5. SCSI Mode Parameters for iSCSI .................................72
   6. Login and Full Feature Phase Negotiation .......................72
      6.1. Text Format ...............................................73
      6.2. Text Mode Negotiation .....................................76
           6.2.1. List Negotiations ..................................80
           6.2.2. Simple-Value Negotiations ..........................80
      6.3. Login Phase ...............................................81
           6.3.1. Login Phase Start ..................................84
           6.3.2. iSCSI Security Negotiation .........................87
           6.3.3. Operational Parameter Negotiation during
                  the Login Phase ....................................87
           6.3.4. Connection Reinstatement ...........................88
           6.3.5. Session Reinstatement, Closure, and Timeout ........89
                  6.3.5.1. Loss of Nexus Notification ................90
           6.3.6. Session Continuation and Failure ...................90
      6.4. Operational Parameter Negotiation outside the
           Login Phase ...............................................90
   7. iSCSI Error Handling and Recovery ..............................92
      7.1. Overview ..................................................92
           7.1.1. Background .........................................92
           7.1.2. Goals ..............................................92
           7.1.3. Protocol Features and State Expectations ...........93
           7.1.4. Recovery Classes ...................................94
                  7.1.4.1. Recovery Within-command ...................95
                  7.1.4.2. Recovery Within-connection ................96
                  7.1.4.3. Connection Recovery .......................96
                  7.1.4.4. Session Recovery ..........................97
           7.1.5. Error Recovery Hierarchy ...........................97
      7.2. Retry and Reassign in Recovery ............................99
           7.2.1. Usage of Retry .....................................99
           7.2.2. Allegiance Reassignment ...........................100
      7.3. Usage of Reject PDU in Recovery ..........................101
      7.4. Error Recovery Considerations for Discovery Sessions .....102
           7.4.1. ErrorRecoveryLevel for Discovery Sessions .........102
           7.4.2. Reinstatement Semantics for Discovery Sessions ....102
                  7.4.2.1. Unnamed Discovery Sessions ...............103
                  7.4.2.2. Named Discovery Sessions .................103
           7.4.3. Target PDUs during Discovery ......................103
      7.5. Connection Timeout Management ............................104
           7.5.1. Timeouts on Transport Exception Events ............104
           7.5.2. Timeouts on Planned Decommissioning ...............104
      7.6. Implicit Termination of Tasks ............................104
      7.7. Format Errors ............................................105
      7.8. Digest Errors ............................................106
      7.9. Sequence Errors ..........................................107
      7.10. Message Error Checking ..................................108
      7.11. SCSI Timeouts ...........................................108
      7.12. Negotiation Failures ....................................109
      7.13. Protocol Errors .........................................110
      7.14. Connection Failures .....................................110
      7.15. Session Errors ..........................................111
   8. State Transitions .............................................112
      8.1. Standard Connection State Diagrams .......................112
           8.1.1. State Descriptions for Initiators and Targets .....112
           8.1.2. State Transition Descriptions for
                  Initiators and Targets ............................114
           8.1.3. Standard Connection State Diagram for an
                  Initiator .........................................118
           8.1.4. Standard Connection State Diagram for a Target ....120
      8.2. Connection Cleanup State Diagram for Initiators
           and Targets ..............................................122
           8.2.1. State Descriptions for Initiators and Targets .....124
           8.2.2. State Transition Descriptions for
                  Initiators and Targets ............................124
      8.3. Session State Diagrams ...................................126
           8.3.1. Session State Diagram for an Initiator ............126
           8.3.2. Session State Diagram for a Target ................127
           8.3.3. State Descriptions for Initiators and Targets .....129
           8.3.4. State Transition Descriptions for
                  Initiators and Targets ............................129
   9. Security Considerations .......................................131
      9.1. iSCSI Security Mechanisms ................................132
      9.2. In-Band Initiator-Target Authentication ..................132
           9.2.1. CHAP Considerations ...............................134
           9.2.2. SRP Considerations ................................136
           9.2.3. Kerberos Considerations ...........................136
      9.3. IPsec ....................................................137
           9.3.1. Data Authentication and Integrity .................137
           9.3.2. Confidentiality ...................................138
           9.3.3. Policy, Security Associations, and
                  Cryptographic Key Management ......................139
      9.4. Security Considerations for the X#NodeArchitecture Key ...141
      9.5. SCSI Access Control Considerations .......................143
   10. Notes to Implementers ........................................143
      10.1. Multiple Network Adapters ...............................143
           10.1.1. Conservative Reuse of ISIDs ......................143
           10.1.2. iSCSI Name, ISID, and TPGT Use ...................144
      10.2. Autosense and Auto Contingent Allegiance (ACA) ..........146
      10.3. iSCSI Timeouts ..........................................146
      10.4. Command Retry and Cleaning Old Command Instances ........147
      10.5. Sync and Steering Layer, and Performance ................147
      10.6. Considerations for State-Dependent Devices and
            Long-Lasting SCSI Operations ............................147
           10.6.1. Determining the Proper ErrorRecoveryLevel ........148
      10.7. Multi-Task Abort Implementation Considerations ..........149
   11. iSCSI PDU Formats ............................................150
      11.1. iSCSI PDU Length and Padding ............................150
      11.2. PDU Template, Header, and Opcodes .......................150
           11.2.1. Basic Header Segment (BHS) .......................152
                  11.2.1.1. I (Immediate) Bit .......................152
                  11.2.1.2. Opcode ..................................152
                  11.2.1.3. F (Final) Bit ...........................154
                  11.2.1.4. Opcode-Specific Fields ..................154
                  11.2.1.5. TotalAHSLength ..........................154
                  11.2.1.6. DataSegmentLength .......................154
                  11.2.1.7. LUN .....................................154
                  11.2.1.8. Initiator Task Tag ......................154
           11.2.2. Additional Header Segment (AHS) ..................155
                  11.2.2.1. AHSType .................................155
                  11.2.2.2. AHSLength ...............................155
                  11.2.2.3. Extended CDB AHS ........................156
                  11.2.2.4. Bidirectional Read Expected Data
                            Transfer Length AHS .....................156
           11.2.3. Header Digest and Data Digest ....................156
           11.2.4. Data Segment .....................................157
      11.3. SCSI Command ............................................158
           11.3.1. Flags and Task Attributes (Byte 1) ...............159
           11.3.2. CmdSN - Command Sequence Number ..................159
           11.3.3. ExpStatSN ........................................160
           11.3.4. Expected Data Transfer Length ....................160
           11.3.5. CDB - SCSI Command Descriptor Block ..............160
           11.3.6. Data Segment - Command Data ......................161
      11.4. SCSI Response ...........................................161
           11.4.1. Flags (Byte 1) ...................................162
           11.4.2. Status ...........................................163
           11.4.3. Response .........................................163
           11.4.4. SNACK Tag ........................................164
           11.4.5. Residual Count ...................................164
                  11.4.5.1. Field Semantics .........................164
                  11.4.5.2. Residuals Concepts Overview .............164
                  11.4.5.3. SCSI REPORT LUNS Command and
                            Residual Overflow .......................165
           11.4.6. Bidirectional Read Residual Count ................166
           11.4.7. Data Segment - Sense and Response Data Segment ...167
                  11.4.7.1. SenseLength .............................167
                  11.4.7.2. Sense Data ..............................168
           11.4.8. ExpDataSN ........................................168
           11.4.9. StatSN - Status Sequence Number ..................168
           11.4.10. ExpCmdSN - Next Expected CmdSN from This
                    Initiator .......................................169
           11.4.11. MaxCmdSN - Maximum CmdSN from This Initiator ....169
      11.5. Task Management Function Request ........................170
           11.5.1. Function .........................................170
           11.5.2. TotalAHSLength and DataSegmentLength .............173
           11.5.3. LUN ..............................................173
           11.5.4. Referenced Task Tag ..............................173
           11.5.5. RefCmdSN .........................................174
           11.5.6. ExpDataSN ........................................174
      11.6. Task Management Function Response .......................175
           11.6.1. Response .........................................176
           11.6.2. TotalAHSLength and DataSegmentLength .............177
      11.7. SCSI Data-Out and SCSI Data-In ..........................178
           11.7.1. F (Final) Bit ....................................180
           11.7.2. A (Acknowledge) Bit ..............................180
           11.7.3. Flags (Byte 1) ...................................181
           11.7.4. Target Transfer Tag and LUN ......................181
           11.7.5. DataSN ...........................................182
           11.7.6. Buffer Offset ....................................182
           11.7.7. DataSegmentLength ................................182
      11.8. Ready To Transfer (R2T) .................................183
           11.8.1. TotalAHSLength and DataSegmentLength .............184
           11.8.2. R2TSN ............................................184
           11.8.3. StatSN ...........................................185
           11.8.4. Desired Data Transfer Length and Buffer Offset ...185
           11.8.5. Target Transfer Tag ..............................185
      11.9. Asynchronous Message ....................................186
           11.9.1. AsyncEvent .......................................187
           11.9.2. AsyncVCode .......................................189
           11.9.3. LUN ..............................................189
           11.9.4. Sense Data and iSCSI Event Data ..................190
                  11.9.4.1. SenseLength .............................190
      11.10. Text Request ...........................................191
           11.10.1. F (Final) Bit ...................................192
           11.10.2. C (Continue) Bit ................................192
           11.10.3. Initiator Task Tag ..............................192
           11.10.4. Target Transfer Tag .............................192
           11.10.5. Text ............................................193
      11.11. Text Response ..........................................194
           11.11.1. F (Final) Bit ...................................194
           11.11.2. C (Continue) Bit ................................195
           11.11.3. Initiator Task Tag ..............................195
           11.11.4. Target Transfer Tag .............................195
           11.11.5. StatSN ..........................................196
           11.11.6. Text Response Data ..............................196
      11.12. Login Request ..........................................196
           11.12.1. T (Transit) Bit .................................197
           11.12.2. C (Continue) Bit ................................197
           11.12.3. CSG and NSG .....................................198
           11.12.4. Version .........................................198
                  11.12.4.1. Version-max ............................198
                  11.12.4.2. Version-min ............................198
           11.12.5. ISID ............................................199
           11.12.6. TSIH ............................................200
           11.12.7. Connection ID (CID) .............................200
           11.12.8. CmdSN ...........................................201
           11.12.9. ExpStatSN .......................................201
           11.12.10. Login Parameters ...............................201
      11.13. Login Response .........................................202
           11.13.1. Version-max .....................................202
           11.13.2. Version-active ..................................203
           11.13.3. TSIH ............................................203
           11.13.4. StatSN ..........................................203
           11.13.5. Status-Class and Status-Detail ..................203
           11.13.6. T (Transit) Bit .................................206
           11.13.7. C (Continue) Bit ................................206
           11.13.8. Login Parameters ................................207
      11.14. Logout Request .........................................207
           11.14.1. Reason Code .....................................209
           11.14.2. TotalAHSLength and DataSegmentLength ............209
           11.14.3. CID .............................................210
           11.14.4. ExpStatSN .......................................210
           11.14.5. Implicit Termination of Tasks ...................210
      11.15. Logout Response ........................................211
           11.15.1. Response ........................................212
           11.15.2. TotalAHSLength and DataSegmentLength ............212
           11.15.3. Time2Wait .......................................212
           11.15.4. Time2Retain .....................................212
      11.16. SNACK Request ..........................................213
           11.16.1. Type ............................................214
           11.16.2. Data Acknowledgment .............................215
           11.16.3. Resegmentation ..................................215
           11.16.4. Initiator Task Tag ..............................216
           11.16.5. Target Transfer Tag or SNACK Tag ................216
           11.16.6. BegRun ..........................................216
           11.16.7. RunLength .......................................216
      11.17. Reject .................................................217
           11.17.1. Reason ..........................................218
           11.17.2. DataSN/R2TSN ....................................219
           11.17.3. StatSN, ExpCmdSN, and MaxCmdSN ..................219
           11.17.4. Complete Header of Bad PDU ......................219
      11.18. NOP-Out ................................................220
           11.18.1. Initiator Task Tag ..............................221
           11.18.2. Target Transfer Tag .............................221
           11.18.3. Ping Data .......................................221
      11.19. NOP-In .................................................222
           11.19.1. Target Transfer Tag .............................223
           11.19.2. StatSN ..........................................223
           11.19.3. LUN .............................................223
   12. iSCSI Security Text Keys and Authentication Methods ..........223
      12.1. AuthMethod ..............................................224
           12.1.1. Kerberos .........................................226
           12.1.2. Secure Remote Password (SRP) .....................226
           12.1.3. Challenge Handshake Authentication
                   Protocol (CHAP) ..................................228
   13. Login/Text Operational Text Keys .............................229
      13.1. HeaderDigest and DataDigest .............................230
      13.2. MaxConnections ..........................................232
      13.3. SendTargets .............................................232
      13.4. TargetName ..............................................232
      13.5. InitiatorName ...........................................233
      13.6. TargetAlias .............................................233
      13.7. InitiatorAlias ..........................................234
      13.8. TargetAddress ...........................................234
      13.9. TargetPortalGroupTag ....................................235
      13.10. InitialR2T .............................................236
      13.11. ImmediateData ..........................................236
      13.12. MaxRecvDataSegmentLength ...............................237
      13.13. MaxBurstLength .........................................238
      13.14. FirstBurstLength .......................................238
      13.15. DefaultTime2Wait .......................................239
      13.16. DefaultTime2Retain .....................................239
      13.17. MaxOutstandingR2T ......................................239
      13.18. DataPDUInOrder .........................................240
      13.19. DataSequenceInOrder ....................................240
      13.20. ErrorRecoveryLevel .....................................241
      13.21. SessionType ............................................241
      13.22. The Private Extension Key Format .......................242
      13.23. TaskReporting ..........................................242
      13.24. iSCSIProtocolLevel Negotiation .........................243
      13.25. Obsoleted Keys .........................................243
      13.26. X#NodeArchitecture .....................................244
           13.26.1. Definition ......................................244
           13.26.2. Implementation Requirements .....................244
   14. Rationale for Revised IANA Considerations ....................245
   15. IANA Considerations ..........................................246
   16. References ...................................................248
      16.1. Normative References ....................................248
      16.2. Informative References ..................................251
   Appendix A. Examples .............................................254
     A.1. Read Operation Example ....................................254
     A.2. Write Operation Example ...................................255
     A.3. R2TSN/DataSN Use Examples .................................256
          A.3.1. Output (Write) Data DataSN/R2TSN Example ...........256
          A.3.2. Input (Read) Data DataSN Example ...................257
          A.3.3. Bidirectional DataSN Example .......................258
          A.3.4. Unsolicited and Immediate Output (Write) Data
                 with DataSN Example ................................259
     A.4. CRC Examples ..............................................259
   Appendix B. Login Phase Examples .................................261
   Appendix C. SendTargets Operation ................................268
   Appendix D. Algorithmic Presentation of Error Recovery
               Classes ..............................................272
     D.1. General Data Structure and Procedure Description ..........273
     D.2. Within-command Error Recovery Algorithms ..................274
          D.2.1. Procedure Descriptions .............................274
          D.2.2. Initiator Algorithms ...............................275
          D.2.3. Target Algorithms ..................................277
     D.3. Within-connection Recovery Algorithms .....................279
          D.3.1. Procedure Descriptions .............................279
          D.3.2. Initiator Algorithms ...............................280
          D.3.3. Target Algorithms ..................................283
     D.4. Connection Recovery Algorithms ............................283
          D.4.1. Procedure Descriptions .............................283
          D.4.2. Initiator Algorithms ...............................284
          D.4.3. Target Algorithms ..................................286
   Appendix E. Clearing Effects of Various Events on Targets ........288
     E.1. Clearing Effects on iSCSI Objects .........................288
     E.2. Clearing Effects on SCSI Objects ..........................293
   Acknowledgments ..................................................294
```

---
## **1.  Introduction**

SCSI\(Small Computer System Interface\)는 I/O 장치, 특히 저장 장치와 통신하는 데 널리 사용되는 프로토콜 제품군입니다. SCSI는 클라이언트-서버 아키텍처입니다. SCSI 인터페이스의 클라이언트를 "초기자"라고 합니다. 초기자는 SCSI "명령"을 실행하여 "대상"으로 알려진 서버의 논리 단위인 구성 요소로부터 서비스를 요청합니다. "SCSI 전송"은 클라이언트-서버 SCSI 프로토콜을 특정 상호 연결에 매핑합니다. 개시자는 SCSI 전송의 한 끝점이고 대상은 다른 끝점입니다.

SCSI 프로토콜은 병렬 SCSI, IPI\(Intelligent Peripheral Interface\), IEEE 1394\(FireWire\) 및 파이버 채널을 포함한 다양한 전송을 통해 매핑되었습니다. 이러한 전송은 I/O에 특정하며 거리 기능이 제한되어 있습니다.

이 문서에 정의된 iSCSI 프로토콜은 TCP/IP를 통해 SCSI 패킷을 전송하는 방법을 설명하고 기존 인터넷 인프라, 인터넷 관리 기능 및 주소 거리 제한을 활용할 수 있는 상호 운용 가능한 솔루션을 제공합니다.

---
## **2.  Acronyms, Definitions, and Document Summary**
---
### **2.1.  Acronyms**

```text
   Acronym     Definition
   --------------------------------------------------------------
   3DES        Triple Data Encryption Standard
   ACA         Auto Contingent Allegiance
   AEN         Asynchronous Event Notification
   AES         Advanced Encryption Standard
   AH          Additional Header (not the IPsec AH!)
   AHS         Additional Header Segment
   API         Application Programming Interface
   ASC         Additional Sense Code
   ASCII       American Standard Code for Information Interchange
   ASCQ        Additional Sense Code Qualifier
   ATA         AT Attachment
   BHS         Basic Header Segment
   CBC         Cipher Block Chaining
   CD          Compact Disk
   CDB         Command Descriptor Block
   CHAP        Challenge Handshake Authentication Protocol
   CID         Connection ID
   CO          Connection Only
   CRC         Cyclic Redundancy Check
   CRL         Certificate Revocation List
   CSG         Current Stage

   CSM         Connection State Machine
   DES         Data Encryption Standard
   DNS         Domain Name Server
   DOI         Domain of Interpretation
   DVD         Digital Versatile Disk
   EDTL        Expected Data Transfer Length
   ESP         Encapsulating Security Payload
   EUI         Extended Unique Identifier
   FFP         Full Feature Phase
   FFPO        Full Feature Phase Only
   HBA         Host Bus Adapter
   HMAC        Hashed Message Authentication Code
   I_T         Initiator_Target
   I_T_L       Initiator_Target_LUN
   IANA        Internet Assigned Numbers Authority
   IB          InfiniBand
   ID          Identifier
   IDN         Internationalized Domain Name
   IEEE        Institute of Electrical and Electronics Engineers
   IETF        Internet Engineering Task Force
   IKE         Internet Key Exchange
   I/O         Input-Output
   IO          Initialize Only
   IP          Internet Protocol
   IPsec       Internet Protocol Security
   IPv4        Internet Protocol Version 4
   IPv6        Internet Protocol Version 6
   IQN         iSCSI Qualified Name
   iSCSI       Internet SCSI
   iSER        iSCSI Extensions for RDMA (see [RFC7145])
   ISID        Initiator Session ID
   iSNS        Internet Storage Name Service (see [RFC4171])
   ITN         iSCSI Target Name
   ITT         Initiator Task Tag
   KRB5        Kerberos V5
   LFL         Lower Functional Layer
   LTDS        Logical-Text-Data-Segment
   LO          Leading Only
   LU          Logical Unit
   LUN         Logical Unit Number
   MAC         Message Authentication Code
   NA          Not Applicable
   NAA         Network Address Authority
   NIC         Network Interface Card
   NOP         No Operation
   NSG         Next Stage
   OCSP        Online Certificate Status Protocol
   OS          Operating System

   PDU         Protocol Data Unit
   PKI         Public Key Infrastructure
   R2T         Ready To Transfer
   R2TSN       Ready To Transfer Sequence Number
   RDMA        Remote Direct Memory Access
   RFC         Request For Comments
   SA          Security Association
   SAM         SCSI Architecture Model
   SAM-2       SCSI Architecture Model - 2
   SAN         Storage Area Network
   SAS         Serial Attached SCSI
   SATA        Serial AT Attachment
   SCSI        Small Computer System Interface
   SLP         Service Location Protocol
   SN          Sequence Number
   SNACK       Selective Negative Acknowledgment - also
               Sequence Number Acknowledgement for data
   SPDTL       SCSI-Presented Data Transfer Length
   SPKM        Simple Public-Key Mechanism
   SRP         Secure Remote Password
   SSID        Session ID
   SW          Session-Wide
   TCB         Task Control Block
   TCP         Transmission Control Protocol
   TMF         Task Management Function
   TPGT        Target Portal Group Tag
   TSIH        Target Session Identifying Handle
   TTT         Target Transfer Tag
   UA          Unit Attention
   UFL         Upper Functional Layer
   ULP         Upper Level Protocol
   URN         Uniform Resource Name
   UTF         Universal Transformation Format
   WG          Working Group
```

---
### **2.2.  Definitions**

- 별칭: 별칭 문자열을 iSCSI 노드와 연결할 수도 있습니다. 별칭을 사용하면 조직에서 사용자에게 친숙한 문자열을 iSCSI 이름과 연결할 수 있습니다. 그러나 별칭 문자열은 iSCSI 이름을 대체하지 않습니다.

- CID\(연결 ID\): 세션 내 연결은 연결 ID로 식별됩니다. 개시자의 세션 내에서 이 연결에 대한 고유 ID입니다. 이는 개시자에 의해 생성되며 로그인 요청 중 및 연결을 닫는 로그아웃 중에 대상에 제공됩니다.

- 연결: 연결은 TCP 연결입니다. 개시자와 대상 간의 통신은 하나 이상의 TCP 연결을 통해 발생합니다. TCP 연결은 iSCSI PDU\(iSCSI 프로토콜 데이터 단위\) 내에서 제어 메시지, SCSI 명령, 매개변수 및 데이터를 전달합니다.

- I/O 버퍼: I/O 버퍼는 SCSI 읽기 또는 쓰기 작업에 사용되는 버퍼로, SCSI 데이터가 해당 버퍼에서 전송되거나 수신될 수 있습니다. 작업에 대해 읽기 또는 쓰기 데이터 전송이 발생하려면 이니시에이터에 I/O 버퍼가 필요하고 대상에도 하나 이상의 버퍼가 필요합니다.

```text
   - INCITS: "INCITS" stands for InterNational Committee for Information
     Technology Standards.  The INCITS has a broad standardization scope
     within the field of Information and Communications Technologies
     (ICT), encompassing storage, processing, transfer, display,
     management, organization, and retrieval of information.  INCITS
     serves as ANSI's Technical Advisory Group for the ISO/IEC Joint
     Technical Committee 1 (JTC 1).  See <http://www.incits.org>.
```

- InfiniBand: InfiniBand는 원래 PCI\(Peripheral Component Interconnect\)를 대체하고 고성능 서버 상호 연결성\[IB\]을 해결하기 위한 I/O 아키텍처입니다.

- iSCSI 장치: iSCSI 장치는 iSCSI 서비스 제공 하위 시스템을 사용하는 SCSI 장치입니다. 서비스 전달 하위 시스템은 \[SAM2\]에 의해 SCSI 명령 및 응답을 위한 전송 메커니즘으로 정의됩니다.

- iSCSI 개시자 이름: iSCSI 개시자 이름은 개시자의 전 세계 고유 이름을 지정합니다.

- iSCSI 개시자 노드: iSCSI 개시자 노드는 "초기자" 장치입니다. 문맥이 모호할 경우 "초기자"라는 단어는 문서의 나머지 부분에서 포트 또는 장치로 적절하게 한정되었습니다. "초기자"의 규정되지 않은 모든 사용법은 상황에 따라 개시자 포트\(또는 장치\)를 나타냅니다.

- iSCSI 레이어: 이 레이어는 iSCSI PDU를 구축/수신하고 개시자-대상 "세션"을 형성하는 하나 이상의 TCP 연결과 이를 중계/수신합니다.

- iSCSI 이름: iSCSI 개시자 또는 iSCSI 대상의 이름입니다.

- iSCSI 노드: iSCSI 노드는 단일 iSCSI 개시자, iSCSI 대상, 또는 각각의 단일 인스턴스를 나타냅니다. 네트워크 엔터티 내에 하나 이상의 iSCSI 노드가 있습니다. iSCSI 노드는 하나 이상의 네트워크 포털을 통해 액세스할 수 있습니다. iSCSI 노드는 다음으로 식별됩니다.

iSCSI 이름입니다. iSCSI 이름과 iSCSI 노드에 사용되는 주소를 분리하면 여러 iSCSI 노드가 동일한 주소를 사용하고 동일한 iSCSI 노드가 여러 주소를 사용할 수 있습니다.

- iSCSI 대상 이름: iSCSI 대상 이름은 대상의 전 세계 고유 이름을 지정합니다.

- iSCSI 대상 노드: iSCSI 대상 노드는 "대상" 장치입니다. 문맥이 모호할 경우 "대상"이라는 단어는 문서의 나머지 부분에서 포트 또는 장치로 적절하게 한정되었습니다. "대상"의 규정되지 않은 모든 사용법은 상황에 따라 대상 포트\(또는 장치\)를 나타냅니다.

- iSCSI 작업: iSCSI 작업은 응답이 예상되는 iSCSI 요청입니다.

- iSCSI 전송 방향: iSCSI 전송 방향은 개시자를 기준으로 정의됩니다. 아웃바운드 또는 아웃바운드 전송은 개시자에서 대상으로의 전송이고, 인바운드 또는 수신 전송은 대상에서 개시자로의 전송입니다.

- ISID: ISID는 세션 식별자의 개시자 부분입니다. 로그인 중에 개시자가 명시적으로 지정합니다.

- I\_T 넥서스: \[SAM2\]에 따르면 I\_T 넥서스는 SCSI 개시자 포트와 SCSI 대상 포트 간의 관계입니다. iSCSI의 경우 이 관계는 iSCSI 개시자의 세션 끝\(SCSI 개시자 포트\)과 iSCSI 대상의 포털 그룹 간의 관계로 정의되는 세션입니다. I\_T 연결은 SCSI 포트 이름을 조합하여 식별할 수 있습니다. 즉, I\_T 넥서스 식별자는 튜플\(iSCSI 초기자 이름 + ',i,' + ISID, iSCSI 대상 이름 + ',t,' + 대상 포털 그룹 태그\)입니다.

- I\_T\_L 넥서스: I\_T\_L 넥서스는 SCSI 개념이며 SCSI 개시자 포트, SCSI 대상 포트 및 LU\(논리 단위\) 간의 관계로 정의됩니다.

- NAA: "NAA"는 INCITS T11 파이버 채널 프로토콜\[FC-FS3\]에 의해 정의된 명명 형식인 네트워크 주소 기관을 나타냅니다.

- 네트워크 엔터티: 네트워크 엔터티는 IP 네트워크에서 액세스할 수 있는 장치 또는 게이트웨이를 나타냅니다. 네트워크 엔터티에는 하나 이상의 네트워크 포털이 있어야 하며, 각 포털은 해당 네트워크 엔터티에 포함된 일부 iSCSI 노드가 IP 네트워크에 액세스하는 데 사용할 수 있습니다.

- 네트워크 포털: 네트워크 포털은 TCP/IP 네트워크 주소가 있고 해당 네트워크 엔터티 내의 iSCSI 노드가 iSCSI 세션 중 하나 내 연결을 위해 사용할 수 있는 네트워크 엔터티의 구성 요소입니다. 개시자의 네트워크 포털은 해당 IP 주소로 식별됩니다. 대상의 네트워크 포털은 해당 IP 주소와 수신 TCP 포트로 식별됩니다.

- 발신자: 협상이나 교환에서 발신자는 협상이나 교환을 시작하는 당사자입니다.

- PDU\(Protocol Data Unit\): 개시자와 대상이 통신을 메시지로 나눕니다. 이러한 메시지에는 "iSCSI 프로토콜 데이터 단위"\(iSCSI PDU\)라는 용어가 사용됩니다.

- 포털 그룹: iSCSI는 동일한 세션 내에서 다중 연결을 지원합니다. 일부 구현에는 여러 네트워크 포털의 세션에서 연결을 결합하는 기능이 있습니다. 포털 그룹은 이러한 포털에 걸쳐 있는 연결을 사용하여 세션을 조정하는 기능을 집합적으로 지원하는 iSCSI 네트워크 엔터티 내의 네트워크 포털 집합을 정의합니다. 포털 그룹 내의 모든 네트워크 포털이 해당 포털 그룹을 통해 연결된 모든 세션에 참여할 필요는 없습니다. 하나 이상의 포털 그룹이 iSCSI 노드에 대한 액세스를 제공할 수 있습니다. 지정된 iSCSI 노드에서 활용되는 각 네트워크 포털은 해당 노드 내의 정확히 하나의 포털 그룹에 속합니다.

- 포털 그룹 태그: 이 16비트 수량은 iSCSI 노드 내의 포털 그룹을 식별합니다. 지정된 iSCSI 노드의 컨텍스트에서 동일한 포털 그룹 태그를 가진 모든 네트워크 포털은 동일한 포털 그룹에 있습니다.

- 복구 R2T: 복구 R2T는 다이제스트 오류, 시퀀스 오류 또는 시퀀스 수신 타임아웃 중 하나를 통해 하나 이상의 Data-Out PDU 손실을 감지한 경우 대상에서 생성된 R2T입니다. 복구 R2T는 사용되지 않은 다음 R2TSN을 전달하지만 이전 R2T\(낮은 R2TSN 포함\)가 이미 요청한 데이터 버스트의 전부 또는 일부를 요청합니다.

- 응답자: 협상이나 교환에서 응답자는 협상이나 교환의 발신자에게 응답하는 당사자입니다.

- SAS: SAS\(Serial Attached SCSI\) 표준에는 직렬 ATA와 호환되는 물리적 계층과 SCSI 명령을 SAS 장치로 전송하고 ATA 명령을 SATA 장치\[SAS\] \[SPL\]로 전송하기 위한 프로토콜이 모두 포함되어 있습니다.

- SCSI 장치: 이는 서비스 제공 하위 시스템에 연결되고 SCSI 애플리케이션 프로토콜을 지원하는 하나 이상의 SCSI 포트를 포함하는 엔터티에 대한 SAM-2 용어입니다. 예를 들어, SCSI 개시자 장치에는 하나 이상의 SCSI 개시자 포트와 0개 이상의 애플리케이션 클라이언트가 포함되어 있습니다. 대상 장치에는 하나 이상의 SCSI 대상 포트와 하나 이상의 장치 서버 및 연관된 LU가 포함되어 있습니다. iSCSI의 경우 SCSI 장치는 SCSI 기능을 제공하는 iSCSI 노드 내의 구성 요소입니다. 따라서 특정 iSCSI 노드 내에는 최대 하나의 SCSI 장치가 있을 수 있습니다. SCSI 장치에 대한 액세스는 iSCSI 일반 작동 세션에서만 가능합니다. SCSI 장치 이름은 노드의 iSCSI 이름으로 정의됩니다.

- SCSI 레이어: 이는 SCSI CDB\(명령 설명자 블록\)를 구축/수신하고 나머지 실행 명령\[SAM2\] 매개변수와 함께 이를 iSCSI 레이어와 중계/수신합니다.

- 세션: 개시자와 대상을 연결하는 TCP 연결 그룹으로 세션을 형성합니다\(SCSI I\_T 넥서스와 대략 동일함\). 세션에서 TCP 연결을 추가하고 제거할 수 있습니다. 세션 내의 모든 연결에서 개시자는 하나의 동일한 대상을 봅니다.

- SCSI 포트: 이는 서비스 전달 하위 시스템과 인터페이스하기 위해 SCSI 기능을 제공하는 SCSI 장치의 엔터티에 대한 SAM-2 용어입니다. iSCSI의 경우 SCSI 개시자 포트와 SCSI 대상 포트의 정의가 다릅니다.

- SCSI 개시자 포트: 이는 iSCSI 일반 작동 세션의 끝점에 매핑됩니다. iSCSI 일반 작동 세션은 iSCSI 개시자 노드와 iSCSI 대상 노드 간의 로그인 프로세스를 통해 협상됩니다. 이 프로세스가 성공적으로 완료되면 SCSI 개시 장치 내에 SCSI 개시 장치 포트가 생성됩니다. SCSI 개시자 포트 이름과 SCSI 개시자 포트 식별자는 모두 \(a\) 개시자 포트 이름/식별자로 식별하는 레이블 및 \(b\) 세션 식별자의 ISID 부분과 함께 iSCSI 개시자 이름으로 정의됩니다.

- SCSI 포트 이름: 유니코드\[UNICODE\] 문자의 UTF-8 \[RFC3629\] 인코딩으로 구성된 이름으로, iSCSI 이름 + 'i' 또는 't' + ISID 또는 대상 포털 그룹 태그를 포함합니다.

- SCSI 표시 데이터 전송 길이\(SPDTL\): SPDTL은 SCSI 작업의 맥락에서 데이터 입력 또는 데이터 출력 전송을 위해 SCSI 계층이 iSCSI 계층에 논리적으로 "표시"하는 데이터의 총 데이터 길이입니다. 양방향 작업의 경우 두 개의 SPDTL 값이 있습니다. 하나는 데이터 입력용이고 다른 하나는 데이터 출력용입니다. "제시"라는 개념에는 데이터당 즉각적인 데이터가 포함됩니다.

\[SAM2\]의 전송 모델을 사용하고 SCSI 계층에서 요청한 중복되는 데이터 전송을 제외합니다.

- SCSI 대상 포트: 이는 iSCSI 대상 포털 그룹에 매핑됩니다.

- SCSI 대상 포트 이름 및 SCSI 대상 포트 식별자: 둘 다 \(a\) 대상 포트 이름/식별자로 식별하는 레이블 및 \(b\) 대상 포털 그룹 태그와 함께 iSCSI 대상 이름으로 정의됩니다.

- SSID\(세션 ID\): iSCSI 개시자와 iSCSI 대상 간의 세션은 개시자 부분\(ISID\)과 대상 부분\(Target Portal Group Tag\)으로 구성된 튜플인 세션 ID로 정의됩니다. ISID는 세션 설정 시 개시자가 명시적으로 지정합니다. 대상 포털 그룹 태그는 연결 설정 시 TCP 끝점 선택을 통해 개시자에 의해 암시됩니다. TargetPortalGroupTag 키도 연결 설정 중 확인으로 대상에서 반환되어야 합니다.

```text
   - T10: T10 is a technical committee within INCITS that develops
     standards and technical reports on I/O interfaces, particularly the
     series of SCSI (Small Computer System Interface) standards.  See
     <http://www.t10.org>.

   - T11: T11 is a technical committee within INCITS responsible for
     standards development in the areas of Intelligent Peripheral
     Interface (IPI), High-Performance Parallel Interface (HIPPI), and
     Fibre Channel (FC).  See <http://www.t11.org>.
```

- 대상 포털 그룹 태그: iSCSI 대상 포털 그룹에 대한 숫자 식별자\(16비트\)입니다.

- TTT\(대상 전송 태그\): TTT는 항상 대상에서 개시자로 먼저 전송된 다음 개시자에서 참조로 인용되는 몇 가지 iSCSI PDU\(예: R2T, NOP-In\)에 사용되는 iSCSI 프로토콜 필드입니다. 동일한 작업/교환과 관련된 PDU를 대상으로 다시 보냈습니다. 따라서 TTT는 기존 작업/교환에 대한 불투명 핸들 역할을 효과적으로 수행하여 대상이 개시자로부터 들어오는 PDU를 적절한 실행 컨텍스트에 연결하도록 돕습니다.

- 타사: 이 용어는 이 문서에서 넥서스 개체\(I\_T 또는 I\_T\_L\) 및 iSCSI 세션에 대한 한정자로 사용됩니다. 이는 이러한 개체와 세션이 별도의 iSCSI 컨텍스트에서 발생하는 작업의 부작용을 가져온다는 것을 나타냅니다. 세션. 타사 세션의 한 가지 예는 별도의 I\_T 넥서스를 통해 조정된 LU 재설정 작업으로 인해 LU에 대한 I\_T\_L 넥서스가 재설정되었음을 발견한 iSCSI 세션입니다.

- TSIH\(Target Session Identification Handle\): 특정 명명된 개시자가 있는 세션에 대해 대상에 할당된 태그입니다. 대상은 세션 설정 중에 이를 생성합니다. 16비트 이진 문자열로 정의하는 것 외에 내부 형식과 내용은 이 프로토콜에 의해 정의되지 않지만 모든 비트가 0으로 설정된 값에 대해 예약되어 새 세션을 나타내기 위해 개시자가 사용합니다. 동일한 세션에 대한 추가 연결 수립 시 대상에게 부여됩니다.

---
### **2.3.  Summary of Changes**

1\) RFC 3720, 3980, 4850 및 5048을 통합하고 필요한 편집 변경을 수행했습니다.

2\) 섹션 13.24에서 iSCSIProtocolLevel을 "1"로 지정하고 \[RFC7144\]에 관련 규범 참조를 추가했습니다.

3\) 마커 및 관련 키가 제거되었습니다.

4\) SPKM 인증 및 관련 키를 제거했습니다.

5\) 사용되지 않는 키에 대한 응답에 대한 새로운 섹션 13.25를 추가했습니다.

6\) 개시자+대상 구현을 명시적으로 허용했습니다.

- 본문 전반에 걸쳐.

7\) 구현이 SLP 기반 검색에 의존해서는 안 된다는 점을 섹션 4.2.7에서 명확히 했습니다.\(SHOULD NOT\)

8\) 섹션 3에 UML\(Unified Modeling Language\) 다이어그램 및 관련 규칙을 추가했습니다.

9\) FastAbort 구현을 "SHOULD" 요구 사항으로 만들었습니다.

- 이전의 "MUST" 요구 사항이 아닌 섹션 4.2.3.4.\(MUST\)

10\) 섹션 4.2.7.1에서는 iSCSI 대상 이름이 두 역할을 모두 갖춘 SCSI\(복합\) 장치의 iSCSI 개시자 이름과 동일해야 한다는 요구사항이 있습니다.

11\) iSCSI 이름의 구두점과 같은 문자 사용과 관련하여 섹션 4.2.7.2의 "해서는 안 됩니다"를 "피해야 합니다"로 변경했습니다.\(MUST NOT\)

12\) 다음을 요구하도록 섹션 9.3을 업데이트했습니다. IPsec, 2400 시리즈 RFC\(IPsec v2, IKEv1\)를 구현해야 합니다. IPsec, 4300 시리즈 RFC\(IPsec v3, IKEv2\)를 구현해야 합니다\(SHOULD\).\(MUST\)

13\) ACA는 iSCSI 대상에 대해서만 "SHOULD"라는 점을 섹션 10.2에서 명확히 했습니다.\(SHOULD\)

14\) 섹션 6.2에서는 새 공개 키에 X# 이름 접두사 사용을 금지했습니다.

15\) 섹션 13.1의 새 다이제스트 확장에 대한 Y# 이름 접두사 및 섹션 12.1의 새 인증 방법 확장에 대한 Z# 이름 접두사의 사용이 금지되었습니다.

16\) 개시자와 대상이 텍스트 협상 중에 최소 6회의 교환을 지원해야 한다는 "SHOULD"를 섹션 6.2에 추가했습니다.\(SHOULD\)

17\) 부록 C가 규범적이라는 설명을 추가했습니다.

18\) \[RFC7146\]에 규범적 요구 사항을 추가하고 이 문서의 텍스트를 \[RFC7146\]의 텍스트와 정렬하기 위해 섹션 9.3에서 몇 가지 관련 변경 사항을 적용했습니다.

19\) Kerberos 인증 고려 사항을 다루는 새로운 섹션 9.2.3을 추가했습니다.

20\) 섹션 9.3.3에 CRL 사용 외에도 IPsec과 함께 사용되는 인증서를 확인하는 데 OCSP가 허용된다는 내용이 추가되었습니다.

21\) 이제 ESPv2\(IPsec v2의 일부\)에 확장 시퀀스 번호\(ESN\)가 필요함을 지정하는 텍스트가 섹션 9.3.1에 추가되었습니다.

---
### **2.4.  Conventions**

예에서 "I-\>" 및 "T-\>"는 각각 개시자와 대상이 보낸 iSCSI PDU를 표시합니다.

이 문서에서 키워드 "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY" 및 "OPTIONAL"은 다음과 같습니다. RFC 2119\[RFC2119\]에 설명된 대로 해석됩니다.\(MUST NOT\)

---
## **3.  UML Conventions**
---
### **3.1.  UML Conventions Overview**

SAM\(SCSI 아키텍처 모델\)은 UML\(Unified Modeling Language\)을 기반으로 한 표기법이 포함된 클래스 다이어그램과 개체 다이어그램을 사용합니다. 따라서 이 문서에서는 UML을 사용하여 SCSI 및 iSCSI 개체의 관계를 모델링합니다.

UML에서 사용되는 그래픽 표기법에 대한 논문은 이 문서의 범위를 벗어납니다. 그러나 UML 정적 클래스 다이어그램에 ASCII 드로잉을 사용하는 경우 이 문서에 사용된 표기 규칙에 대한 설명이 이 섹션의 나머지 부분에 포함됩니다.

---
### **3.2.  Multiplicity Notion**

지정되지 않음 속성의 인스턴스 수가 지정되지 않았습니다.

- 1 클래스 또는 특성의 인스턴스가 1개 존재합니다.

- 0..\* 0개 이상의 클래스 또는 특성 인스턴스가 존재합니다.

- 1..\* 클래스 또는 특성의 인스턴스가 하나 이상 존재합니다.

- 0..1 클래스 또는 특성의 인스턴스가 0개 또는 1개 존재합니다.

- n..m 클래스 또는 속성의 인스턴스가 n\~m개 존재합니다\(예: 2..8\).

x, n..m 클래스의 여러 분리된 인스턴스 또는

- 속성이 존재합니다\(예: 2, 8..15\).

---
### **3.3.  Class Diagram Conventions**

```text
     +--------------+    +--------------+       +--------------+
     |  Class Name  |    |  Class Name  |       |  Class Name  |
     +--------------+    +--------------+       +--------------+
     |              |    |              |
     +--------------+    +--------------+
     |              |
     +--------------+
```

앞의 세 다이어그램은 속성과 작업이 없는 클래스의 예입니다.

```text
     +-------------------+    +-------------------+
     |    Class Name     |    |    Class Name     |
     +-------------------+    +-------------------+
     | attribute 01[1]   |    |   attribute 01[1] |
     | attribute 02[1]   |    |   attribute 02[1] |
     +-------------------+    +-------------------+
     |                   |
     +-------------------+
```

앞의 두 다이어그램은 속성은 있지만 작업은 없는 클래스의 예입니다.

```text
     +------------------------+
     |      Class Name        |
     +------------------------+
     |    attribute 01[1..*]  |
     |    attribute 02[1]     |
     +------------------------+
     |    operation 01()      |
     |    operation 02()      |
     +------------------------+
```

앞의 다이어그램은 지정된 다중성과 작업을 갖는 속성이 있는 클래스의 예입니다.

---
### **3.4.  Class Diagram Notation for Associations**

```text
     +-----------------+
     |     Class A     |
     +-----------------+ association_name   +-----------------+
     | attribute 01[1] |<------------------>|     Class B     |
     | attribute 02[1] | 1..*          0..1 +-----------------+
     +-----------------+                    | attribute 03[1] |
     | operation 1()   |                    +-----------------+
     +-----------------+
```

앞의 다이어그램은 클래스 A가 클래스 B에 대해 알고\(즉, "클래스 A 연관\_이름 클래스 B"로 읽음\) 클래스 B가 클래스 A에 대해 알고\(즉, "클래스 B 연관\_이름 클래스 A"로 읽음\) 예입니다. Association\_name의 사용은 선택 사항입니다. 다중성 표기법\(1..\* 및 0..1\)은 개체의 인스턴스 수를 나타냅니다.

```text
     +--------------------+
     |      Class A       |
     +--------------------+              +--------------------+
     | attribute 01[1]    |<-------------|      Class B       |
     | attribute 02[1]    | 1      0..1  +--------------------+
     +--------------------+              | attribute 03[1]    |
     | operation 1()      |              +--------------------+
     +--------------------+
```

앞의 다이어그램은 클래스 B가 클래스 A에 대해 알고 있지만\(즉, "클래스 B는 클래스 A에 대해 알고 있습니다"라고 읽음\) 클래스 A는 클래스 B에 대해 알지 못하는 예입니다.

```text
     +----------------------+
     |       Class A        |
     +----------------------+            +--------------------+
     |   attribute 01[1]    |----------->|      Class B       |
     |   attribute 02[1]    | 0..*     1 +--------------------+
     +----------------------+            | attribute 03[1]    |
     |    operation 1()     |            +--------------------+
     +----------------------+
```

앞의 다이어그램은 클래스 A가 클래스 B에 대해 알고 있지만\(즉, "클래스 A가 클래스 B에 대해 알고 있음"으로 읽음\) 클래스 B는 클래스 A에 대해 알지 못하는 예입니다.

---
### **3.5.  Class Diagram Notation for Aggregations**

```text
     +---------------+             +--------------+
     |  Class whole  |o------------|  Class part  |
     +---------------+             +--------------+
```

앞의 다이어그램은 클래스 전체가 클래스 부분을 포함하는 집계이고 클래스 전체가 제거되더라도 클래스 부분이 계속 존재할 수 있는 예입니다\(즉, "전체가 부분을 포함합니다"로 읽음\).

```text
     +---------------+             +--------------+
     |  Class whole  |@------------|  Class part  |
     +---------------+             +--------------+
```

앞의 다이어그램은 클래스 전체가 클래스 부분을 포함하는 집계이고, 클래스 부분은 하나의 클래스 전체에만 속하고, 클래스 부분은 클래스 전체가 제거되면 계속 존재하지 않는 예입니다\(예: "전체가 포함됨"으로 읽음\). 부분"\).

```text
     +-------------+
     |             |
     +-------------+
        |       |
        + =(a)= +
        |       |
```

앞의 다이어그램은 연관 사이에 제약이 있는 예입니다. 여기서 \(a\) 각주는 제약을 설명합니다.

---
### **3.6.  Class Diagram Notation for Generalizations**

```text
     +---------------+
     |  Superclass   |
     +-------^-------+
            /_\
             |
     +---------------+
     |    Subclass   |
     +---------------+
```

앞의 다이어그램은 서브클래스가 일종의 슈퍼클래스인 예입니다. 서브클래스는 슈퍼클래스의 모든 속성과 작업을 공유합니다\(즉, 서브클래스는 슈퍼클래스에서 상속됩니다\).

---
## **4.  Overview**
---
### **4.1.  SCSI Concepts**

SCSI 아키텍처 모델 - 2 \[SAM2\]는 SCSI I/O 프로토콜 제품군의 아키텍처를 자세히 설명합니다. 이 섹션에서는 SCSI 아키텍처에 대한 간략한 배경을 제공하고 독자가 해당 용어에 익숙해지도록 돕기 위해 작성되었습니다.

가장 높은 수준에서 SCSI는 하드 드라이브, 테이프 드라이브, CD 및 DVD 드라이브, 프린터 및 스캐너를 포함한 I/O 장치에서 서비스를 요청하기 위한 인터페이스 제품군입니다. SCSI 용어에서는 개별 I/O 장치를 "논리 장치"\(LU\)라고 합니다.

SCSI는 클라이언트-서버 아키텍처입니다. SCSI 인터페이스의 클라이언트를 "초기자"라고 합니다. 초기자는 SCSI "명령"을 실행하여 구성 요소\("대상"으로 알려진 서버의 LU\)에서 서비스를 요청합니다. LU의 "장치 서버"는 SCSI 명령을 받아들이고 처리합니다.

"SCSI 전송"은 클라이언트-서버 SCSI 프로토콜을 특정 상호 연결에 매핑합니다. 개시자는 SCSI 전송의 한 끝점입니다. "대상"은 다른 끝점입니다. 대상에는 여러 LU가 포함될 수 있습니다. 각 LU에는 LUN\(Logical Unit Number\)이라는 대상 내의 주소가 있습니다.

SCSI 작업은 SCSI 명령이거나 연결된 SCSI 명령 집합일 수도 있습니다. 일부 LU는 여러 보류\(대기열\) 작업을 지원하지만 작업 대기열은 LU에 의해 관리됩니다. 대상은 개시자가 제공한 "작업 태그"를 사용하여 작업을 구별합니다. 주어진 시간에 작업에서 단 하나의 명령만 미해결 상태일 수 있습니다.

각 SCSI 명령에는 선택적 데이터 단계와 필수 응답 단계가 발생합니다. 데이터 단계에서 정보는 개시자에서 대상으로\(예: 쓰기\), 대상에서 개시자로\(예: 읽기\) 또는 양방향으로 이동할 수 있습니다. 응답 단계에서 대상은 오류를 포함하여 작업의 최종 상태를 반환합니다.

CDB\(명령 설명자 블록\)는 개시자가 대상에 보내는 명령 매개변수를 포함하는 데 사용되는 데이터 구조입니다. CDB 내용과 구조는 \[SAM2\] 및 장치 유형별 SCSI 표준에 의해 정의됩니다.

---
### **4.2.  iSCSI Concepts and Functional Overview**

iSCSI 프로토콜은 TCP 프로토콜을 통한 SCSI 명령, 이벤트 및 작업 관리 모델\(\[SAM2\] 참조\)을 매핑한 것입니다. SCSI 명령은 iSCSI 요청에 의해 전달되고, SCSI 응답 및 상태는 iSCSI 응답에 의해 전달됩니다. iSCSI는 또한 iSCSI 프로토콜 메커니즘에 대한 요청-응답 메커니즘을 사용합니다.

이 문서의 나머지 부분에서 "초기자" 및 "대상"이라는 용어는 달리 한정되지 않는 한 각각 "iSCSI 개시자 노드" 및 "iSCSI 대상 노드"를 의미합니다\(iSCSI 참조\).

제목에서 알 수 있듯이 섹션 4는 iSCSI 개념에 대한 개요를 제공하며 나머지 사양의 이후 섹션에는 표준 요구 사항이 포함되어 있습니다. 대부분의 경우 섹션 4에서 설명한 것과 동일한 개념을 다루고 있습니다. 이러한 표준 요구 사항 텍스트는 개요 텍스트보다 우선합니다. 두 사람 사이에 불일치가 있는 경우 섹션 4에서.

유사한 프로토콜을 유지하면서 개시자와 대상은 통신을 메시지로 나눕니다. 이 문서에서는 이러한 메시지에 대해 "iSCSI 프로토콜 데이터 단위"\(iSCSI PDU\)라는 용어를 사용합니다.

성능상의 이유로 iSCSI는 "단계 축소"를 허용합니다. 명령 및 관련 데이터는 개시자에서 대상으로 함께 배송될 수 있으며, 데이터와 응답은 대상에서 함께 배송될 수 있습니다.

iSCSI 전송 방향은 개시자를 기준으로 정의됩니다. 아웃바운드 또는 아웃바운드 전송은 개시자에서 대상으로의 전송이고, 인바운드 또는 수신 전송은 대상에서 개시자로의 전송입니다.

iSCSI 작업은 응답이 예상되는 iSCSI 요청입니다.

이 문서에서 "iSCSI 요청", "iSCSI 명령", 요청 또는 \(정규화되지 않은\) 명령은 동일한 의미를 갖습니다. 또한 별도로 지정하지 않는 한 상태, 응답 또는 번호가 매겨진 응답은 동일한 의미를 갖습니다.

---
#### **4.2.1.  Layers and Sessions**

다음 개념적 계층화 모델은 개시자 및 대상 작업과 전송 및 수신된 프로토콜 데이터 단위와 관련된 방식을 지정하는 데 사용됩니다.

- - SCSI 레이어는 SCSI CDB\(명령 설명자 블록\)를 구축/수신하고 나머지 실행 명령\[SAM2\] 매개변수와 함께 CDB를 전달/수신합니다.

- iSCSI PDU를 구축/수신하는 iSCSI 계층

- 하나 이상의 TCP 연결로/로부터 이를 중계/수신합니다. 연결 그룹은 개시자-대상 "세션"을 형성합니다.

개시자와 대상 간의 통신은 하나 이상의 TCP 연결을 통해 발생합니다. TCP 연결은 iSCSI PDU\(iSCSI 프로토콜 데이터 단위\) 내에서 제어 메시지, SCSI 명령, 매개변수 및 데이터를 전달합니다. 개시자와 대상을 연결하는 TCP 연결 그룹은 세션을 형성합니다\(SCSI I\_T 넥서스와 동일, 섹션 4.4.2 참조\). 세션은 개시자 부분과 대상 부분으로 구성된 세션 ID로 정의됩니다. 세션에서 TCP 연결을 추가하고 제거할 수 있습니다. 세션 내의 각 연결은 연결 ID\(CID\)로 식별됩니다.

세션 내의 모든 연결에서 개시자는 하나의 "대상 이미지"를 봅니다. LUN과 같은 모든 대상 식별 요소는 동일합니다. 또한 대상은 세션 내의 모든 연결에서 하나의 "개시자 이미지"를 봅니다. 개시자 작업 태그와 같은 개시자 식별 요소는 전송 또는 수신되는 연결에 관계없이 세션 전반에 걸쳐 전역적입니다.

iSCSI 대상 및 개시자는 최소한 하나의 TCP 연결을 지원해야 하며 세션에서 여러 연결을 지원할 수 있습니다. 오류 복구 목적을 위해 세션에서 단일 활성 연결을 지원하는 대상 및 개시자는 복구 중에 두 개의 연결을 지원해야 합니다.\(MUST, SHOULD\)

---
#### **4.2.2.  Ordering and iSCSI Numbering**

iSCSI는 명령 및 상태 번호 지정 체계와 데이터 순서 체계를 사용합니다.

명령 번호 지정은 세션 전체에 적용되며 여러 연결을 통해 순서대로 명령을 전달하는 데 사용됩니다. 또한 세션에 대한 명령 흐름 제어를 위한 메커니즘으로 사용될 수도 있습니다.

상태 번호는 연결별로 지정되며 일시적이거나 영구적인 통신 오류가 있는 경우 누락된 상태를 감지하고 복구하는 데 사용됩니다.

데이터 시퀀싱은 명령별로 또는 명령의 일부\(R2T 트리거 시퀀스\)로 수행되며 헤더 다이제스트 오류로 인해 누락된 데이터 및/또는 R2T PDU를 감지하는 데 사용됩니다.

일반적으로 iSCSI PDU의 필드는 개시자와 대상 간의 시퀀스 번호를 전달합니다. 연결 트래픽이 단방향인 기간에는 iSCSI NOP-Out/NOP-In PDU를 사용하여 대상과 개시자의 명령 및 상태 순서 카운터를 동기화할 수 있습니다.

iSCSI 세션 추상화는 SCSI I\_T 연결과 동일하며 iSCSI 세션은 SCSI 개시자에서 SCSI 대상으로 순서대로 명령을 전달합니다. 여기에 정의된 iSCSI 세션 모델을 만든 자세한 설계 고려 사항과 SCSI 사양에 정의된 SCSI 명령 순서 지정 기능을 iSCSI 개념과 연관시키는 방법은 \[RFC3783\]을 참조하세요.

---
##### **4.2.2.1.  Command Numbering and Acknowledging**

iSCSI는 세션 내에서 순서가 지정된 명령 전달을 수행합니다. 이니시에이터에서 대상으로 전송 중인 모든 명령\(이니시에이터에서 대상으로의 PDU\)에는 번호가 지정됩니다.

iSCSI는 개시자가 발행한 모든 요청에 ​​대한 응답으로 대상에서 작업이 인스턴스화되는 것으로 간주합니다. 중단 및 재할당\(섹션 11.5 참조\)을 포함한 일련의 작업 관리 작업은 iSCSI 작업에서 수행될 수 있습니다. 그러나 작업 관리 작업에서는 중단 작업을 수행할 수 없으며 재할당 작업 사용에는 특정 제약이 있습니다. 자세한 내용은 섹션 11.5.1을 참조하세요.

일부 iSCSI 작업은 SCSI 작업이고 많은 SCSI 활동은 SCSI 작업\(\[SAM2\]\)과 관련되어 있습니다. 모든 경우에 작업은 작업 수명 동안 개시자 작업 태그로 식별됩니다.

명령 번호는 iSCSI PDU에 의해 CmdSN\(명령 시퀀스 번호\)으로 전달됩니다. 번호 지정은 세션 전체에 적용됩니다. 나가는 iSCSI PDU에는 이 번호가 있습니다. iSCSI 초기자는 32비트 부호 없는 카운터\(모듈로 2\*\*32\)를 사용하여 CmdSN을 할당합니다. CmdSN에 대한 비교 및 ​​산술은 \[RFC1982\]에 정의된 일련 번호 산술을 사용합니다. 여기서 SERIAL\_BITS = 32입니다.

즉시 전달을 의미하는 명령에는 즉시 전달 플래그가 표시됩니다. 또한 현재 CmdSN을 전달해야 합니다. CmdSN은 즉시 전달로 표시된 명령이 전송된 후에 진행되어서는 안 됩니다.\(MUST, MUST NOT\)

명령 번호 지정은 세션의 첫 번째 연결\(선행 연결의 선행 로그인\)에서 첫 번째 로그인 요청으로 시작하며, CmdSN은 \[RFC1982\]에 정의된 대로 일련 번호 산술적 의미에서 1씩 증가해야 합니다. - 그 이후에 즉시 명령이 내려졌습니다.\(MUST\)

작업 관리 명령과 함께 즉시 전달을 사용하는 경우 이러한 명령은 수행해야 하는 작업보다 먼저 대상에 도달할 수 있습니다. 그러나 CmdSN은 명령 스트림에서 위치를 나타내는 표시 역할을 합니다. 개시자와 대상은 \[SAM2\]에 지정된 SCSI 작업 관리 기능이 \[SAM2\] 사양에 따라 작동하는지 확인해야 합니다. 예를 들어 명령과 응답이 모두 순서대로 전달된 것처럼 나타납니다. 나가는 PDU에 대한 CmdSN이 명시적인 규칙에 의해 지정되지 않을 때마다 CmdSN은 로컬 CmdSN 변수의 현재 값을 전달합니다\(이 섹션의 뒷부분 참조\).\(MUST\)

구현 시 즉시 전달을 위해 PDU를 표시하기로 결정하거나 iSCSI가 PDU를 즉시 전달을 위해 자체적으로 표시하기로 결정하는 방법은 이 문서의 범위를 벗어납니다.

즉시 전달에 사용되는 명령의 수는 제한되지 않으며 실행 전달은 번호 지정 방식을 통해 승인되지 않습니다. iSCSI 대상은 추가 명령을 수용할 리소스 부족 등의 이유로 즉각적인 명령을 거부할 수 있습니다. iSCSI 대상은 언제든지 연결당 최소 하나의 즉각적인 작업 관리 명령과 하나의 즉각적인 비작업 관리 iSCSI 명령을 처리할 수 있어야 합니다.\(MAY, MUST\)

이 문서에서 실행을 위한 전달은 SCSI 실행 엔진 또는 iSCSI 프로토콜별 실행 엔진\(예: 실행 구성 요소와 관련된 공개 또는 개인 확장 키가 있는 텍스트 요청\)으로의 전달을 의미합니다. 즉시 전달로 표시된 명령을 제외하고 iSCSI 대상 계층은 CmdSN에서 지정한 순서대로 실행할 명령을 전달해야 합니다. 즉시 전달로 표시된 명령은 다음에 의해 전달될 수 있습니다.\(MUST\)

감지되는 즉시 실행을 위한 iSCSI 대상 레이어. iSCSI는 이전 SCSI 또는 iSCSI 작업\(예: 작동해야 하는 모든 명령 이전에 수신된 CLEAR TASK SET 작업 관리 요청\)에 필요한 경우 일부 명령을 SCSI 대상 계층에 전달하지 않을 수 있습니다.

모든 연결에서 iSCSI 초기자는 다이제스트 오류 복구 및 연결 복구로 인해 재전송되는 명령을 제외하고 CmdSN의 오름차순으로 명령을 보내야 합니다.\(MUST\)

번호 지정 메커니즘의 경우 개시자와 대상은 각 세션에 대해 다음 세 가지 변수를 유지합니다.

- - CmdSN: 위에서 설명한 즉시 전달용으로 표시된 명령을 제외하고 전달된 각 명령에서 1씩 증가하는 현재 명령 시퀀스 번호입니다. CmdSN에는 항상 다음 명령 PDU에 할당될 번호가 포함됩니다.

- - ExpCmdSN: 대상이 예상하는 다음 명령입니다. 대상은 이 숫자까지\(포함하지 않음\)의 모든 명령을 승인합니다. 개시자는 CmdSN이 ExpCmdSN보다 작은 모든 명령을 승인된 것으로 처리합니다. 대상 iSCSI 계층은 ExpCmdSN을 \[RFC1982\]에 따라 실행 "+ 1"을 위해 전달할 수 있는 가장 큰 비즉시 CmdSN으로 설정합니다. 승인된 CmdSN 시퀀스에는 구멍이 있어서는 안 됩니다.\(MUST NOT\)

- - MaxCmdSN: 배송될 최대 개수입니다. 수신 iSCSI 레이어의 대기열 용량은 MaxCmdSN - ExpCmdSN + 1입니다.

개시자의 ExpCmdSN 및 MaxCmdSN은 대상-초기자 PDU 필드에서 파생됩니다. ExpCmdSN 및 MaxCmdSN에 대한 비교 및 ​​산술은 SERIAL\_BITS = 32인 \[RFC1982\]에 정의된 일련 번호 산술을 사용해야 합니다.\(MUST\)

대상은 ExpCmdSN - 1보다 작은 MaxCmdSN을 전송해서는 안 됩니다. 즉각적이지 않은 명령의 경우 CmdSN 필드는 ExpCmdSN에서 MaxCmdSN까지의 모든 값을 취할 수 있습니다. 대상은 이 범위 밖의 모든 즉각적이지 않은 명령이나 범위 내에서 즉각적이지 않은 중복을 자동으로 무시해야 합니다. 즉각적인 명령에 의해 전달되는 CmdSN은 ExpCmdSN-MaxCmdSN 범위 밖에 있을 수 있습니다. 예를 들어, 개시자가 이전에 MaxCmdSN과 동일한 CmdSN을 전달하는 비즉시 명령을 보낸 경우 대상 창이 닫힙니다. 즉시 명령으로 실행된 그룹 작업 관리 명령의 경우 CmdSN은 그룹 작업의 범위를 나타냅니다\(예: ABORT TASK SET은 어떤 명령이 중단되는지 나타냅니다\).\(MUST NOT, MUST\)

MaxCmdSN 및 ExpCmdSN 필드는 개시자에 의해 다음과 같이 처리됩니다.

- - PDU MaxCmdSN이 PDU ExpCmdSN - 1\(일련 번호 산술적 의미에서\)보다 작으면 둘 다 무시됩니다.

- - PDU MaxCmdSN이 로컬 MaxCmdSN보다 큰 경우\(일련 번호 산술적 의미에서\) 로컬 MaxCmdSN을 업데이트합니다. 그렇지 않으면 무시됩니다.

- - PDU ExpCmdSN이 로컬 ExpCmdSN보다 크면\(일련 번호 산술적 의미에서\) 로컬 ExpCmdSN을 업데이트합니다. 그렇지 않으면 무시됩니다.

업데이트가 순서 없이 도착할 수 있으므로 이 순서가 필요합니다\(예: 업데이트가 다른 TCP 연결을 통해 전송됨\).

iSCSI 개시자와 대상은 명령 번호 지정 체계를 지원해야 합니다.\(MUST\)

번호가 지정된 iSCSI 요청은 재발행 횟수 및 상황에 관계없이 할당된 CmdSN을 변경하지 않습니다\(섹션 7.2.1 참조\). 대상에서 CmdSN은 명령이 실행과 관련된 상태\(실행 상태\)를 생성하지 않은 동안에만 관련됩니다. 그 후에는 CmdSN이 관련이 없게 됩니다. 실행 상태 테스트\(이니시에이터 작업 태그 식별로 표시\)는 대상의 다른 작업보다 먼저 수행되어야 합니다. 실행 상태가 발견되지 않으면 주문 및 배송이 이어집니다. 실행 상태가 발견되면 아직 전달되지 않은 경우 전달됩니다.\(MUST\)

세션 CmdSN 값이 Q일 때 개시자가 연결에서 CmdSN R을 사용하여 명령에 대한 명령 재시도를 발행하는 경우, CmdSN을 R + 2\*\*31 - 1을 지나서 진행해서는 안 됩니다.\(MUST NOT\)

```text
      - the connection is no longer operational (i.e., it has returned
        to the FREE state; see Section 8.1.3),
```

- - 연결이 복원되었습니다\(섹션 6.3.4 참조\). 또는

- - Q보다 크거나 같은 CmdSN을 가진 비즉시 명령이 동일한 연결에 대한 명령 재시도 이후에 발행되었으며 해당 명령의 수신이 대상에 의해 승인되었습니다\(섹션 10.4 참조\).

상태가 있는 대상 명령 응답 또는 Data-In PDU는 명령 승인보다 앞서서는 안 됩니다. 그러나 승인은 응답이나 Data-In PDU에 포함될 수 있습니다.\(MUST NOT, MAY\)

---
##### **4.2.2.2.  Response/Status Numbering and Acknowledging**

대상에서 개시자로 전송 중인 응답에는 번호가 지정됩니다. StatSN\(상태 일련 번호\)이 이 목적으로 사용됩니다. StatSN은 연결별로 유지되는 카운터입니다. ExpStatSN은 개시자가 상태를 확인하는 데 사용됩니다. 상태 시퀀스 번호 공간은 32비트 부호 없는 정수이고 산술 연산은 일반 mod\(2\*\*32\) 산술입니다.

상태 번호 지정은 연결의 첫 번째 로그인 요청에 대한 로그인 응답으로 시작됩니다. 로그인 응답에는 상태 번호 지정에 대한 초기 값이 포함됩니다\(모든 초기 값이 유효함\).

명령 복구를 활성화하기 위해 대상은 연결 실패 후 데이터 및 상태 복구를 위한 충분한 상태 정보를 유지할 수 있습니다. 이를 수행하는 대상은 ExpStatSN을 통해 명령에 대한 상태\(StatSN 번호\) 전달이 확인된 후 명령 복구를 위해 유지되는 모든 상태 정보를 안전하게 삭제할 수 있습니다.\(MAY\)

StatSN과 ExpStatSN 사이의 큰 절대 차이는 연결 실패를 나타낼 수 있습니다. 차이가 2\*\*31 - 1을 초과해서는 안 되는 구현 정의 상수보다 큰 경우 개시자는 복구 작업을 수행해야 합니다\(MUST\).\(MUST NOT\)

개시자와 대상은 응답 번호 지정 체계를 지원해야 합니다.\(MUST\)

---
##### **4.2.2.3.  Response Ordering**
---
###### **4.2.2.3.1.  Need for Response Ordering**

iSCSI 세션이 여러 연결로 구성될 때마다 대상 SCSI 계층에서 발생하는 응답 PDU\(작업 응답 또는 TMF 응답\)는 iSCSI 연결 충성 규칙에 따라 대상 iSCSI 계층에 의해 여러 연결로 배포됩니다. 이 프로세스는 일반적으로 개시자 SCSI 계층에 응답이 전달될 때 응답의 순서를 유지하지 못할 수 있습니다.

어쨌든 SCSI 응답 PDU 전체에서는 순서가 예상되지 않으므로 이 접근 방식은 일반적인 경우에 잘 작동합니다. 그러나 SCSI 계층에서 일부 순서를 지정해야 하는 특별한 경우를 해결하기 위해 "응답 펜스"라는 개념을 도입합니다. 응답 펜스는 논리적으로 대상 iSCSI 계층으로 전달되는 SCSI 응답 메시지의 속성/속성입니다. 이 특정 응답 메시지와 관련된 특별한 SCSI 수준 주문 고려 사항이 있음을 나타냅니다. 응답 펜스가 설정되거나 필요할 때마다

SCSI 응답 메시지에 대한 대상 iSCSI 계층의 이러한 SCSI 응답 메시지 처리와 관련하여 섹션 4.2.2.3.2의 의미를 정의합니다.

---
###### **4.2.2.3.2.  Response Ordering Model Description**

대상 SCSI 프로토콜 계층은 "명령 완료 보내기" 프로토콜 데이터 서비스\(\[SAM2\], 절 5.4.2\) 및 "작업 관리 기능 실행됨"\(\[SAM2\], 절\)을 호출하여 SCSI 응답 메시지를 대상 iSCSI 계층으로 전달합니다. 6.9\) 서비스. SCSI 응답 메시지를 수신하면 iSCSI 계층은 특정 SCSI 응답 메시지에 대해 응답 펜스 동작을 나타냅니다\(섹션 4.2.2.3.4에서는 의미가 실현되어야 하는 특정 인스턴스를 설명합니다\).

SCSI 응답 메시지에 응답 펜스 동작이 필요할 때마다 대상 iSCSI 계층은 응답 메시지를 개시자 iSCSI 계층에 전달할 때 다음 조건이 충족되는지 확인해야 합니다.\(MUST\)

- 응답 펜스가 포함된 응답이 전달되어야 합니다.

- 이전 응답이 개시자 iSCSI 계층으로 전달되는 경우 I\_T\_L 넥서스의 모든 "이전" 응답 이후 시간순으로.\(MUST\)

- 응답 펜스가 포함된 응답이 전달되어야 합니다.

- I\_T\_L 넥서스에 대한 모든 "다음" 응답보다 시간순으로 앞선 것입니다.\(MUST\)

"선행" 및 "다음"이라는 개념은 대상 SCSI 프로토콜 계층에서 대상 iSCSI 계층으로 응답 메시지가 전달되는 순서를 나타냅니다.

---
###### **4.2.2.3.3.  iSCSI Semantics with the Interface Model**

TaskReporting 키\(섹션 13.23\)가 iSCSI 세션에 대해 ResponseFence 또는 FastAbort로 협상되고 Response Fence 동작이 SCSI 응답 메시지에 필요할 때마다 대상 iSCSI 레이어는 해당 세션에 대해 이 섹션에 설명된 작업을 수행해야 합니다.\(MUST\)

- a\) 단일 연결 세션인 경우 특별한 처리가 필요하지 않습니다. 표준 SCSI 응답 PDU 빌드 및 디스패치 프로세스가 발생합니다.

- b\) 다중 연결 세션인 경우 대상 iSCSI 레이어는 iSCSI 세션의 각 연결에서 마지막으로 전송되었으며 승인되지 않은 StatSN을 기록하고

승인\(NOP-In PDU는 요청하는 데 사용될 수 있음\)

- 이 프로세스를 가속화하기 위해 필요한 경우\) 각 StatSN을 승인하여 펜스를 정리합니다. 응답 펜스 동작을 요구하는 SCSI 응답 PDU는 승인되지 않은 각 StatSN에 대해 승인이 수신되기 전에 개시자에게 전송되어서는 안 됩니다.\(MAY, MUST NOT\)

- c\) 대상 iSCSI 레이어는 응답 펜스 동작을 요구하는 SCSI 응답을 전달한 SCSI 응답 PDU의 승인을 기다려야 합니다. 울타리는 승인을 받은 후에만 지워진 것으로 간주되어야 합니다.\(MUST\)

- d\) LU에 대한 모든 추가 상태 처리는 펜스를 지운 후에만 재개됩니다. 펜스가 지워지기 전에 I\_T\_L 넥서스에 대한 새로운 응답이 SCSI 레이어로부터 수신되면 해당 응답 PDU는 펜스가 지워질 때까지 iSCSI 레이어에 보관되어 대기열에 있어야 합니다.\(MUST\)

---
###### **4.2.2.3.4.  Current List of Fenced Response Use Cases**

이 섹션에는 iSCSI 대상 구현에서 분리 응답 동작이 필요한 상황이 나열되어 있습니다. 다음 목록은 현재 확인된 전체 목록입니다. SCSI 프로토콜 사양이 발전함에 따라 사례별로 응답 펜싱이 필요한 경우 사양이 열거될 것으로 예상됩니다.\(MUST\)

TaskReporting 키\(섹션 13.23\)가 iSCSI 세션에 대해 ResponseFence 또는 FastAbort로 협상될 때마다 대상 iSCSI 계층은 다음 SCSI 완료 메시지에 대해 응답 펜스가 필요하다고 가정해야 합니다.\(MUST\)

- a\) 발행 및 제3자 세션에서 다중 작업 중단 후 UA를 전달하는 첫 번째 완료 메시지. 관련 TMF 논의는 섹션 4.2.3.2를 참조하십시오.

- b\) 발행 세션에서 다중 작업 TMF 응답을 전달하는 TMF 응답.

- c\) 발급 세션에서 ACA 수립을 나타내는 완료 메시지.

- d\) 발급 및 제3자 세션에 대한 ACA 설정 후 ACA ACTIVE 상태를 전달하는 첫 번째 완료 메시지입니다.

- e\) 발행 세션에서 CLEAR ACA 응답을 전달하는 TMF 응답.

- f\) PERSISTENT RESERVE OUT/PREEMPT AND ABORT 명령에 대한 응답.

```text
   Notes:
```

- - \[RFC3720\]에는 ACA 관련 펜싱 요구 사항이 없기 때문에 개시자 구현은 \[RFC3720\]만 준수하는 대상이 있는 다중 연결 iSCSI 세션에서 ACA를 사용해서는 안 됩니다. 이는 협상 결과가 "RFC3720" 또는 "NotUnderstood"인 경우 TaskReporting 키\(섹션 13.23\) 협상을 통해 확인할 수 있습니다.\(SHOULD NOT\)

- - 다중 연결 iSCSI 세션에서 ACA를 사용하려는 초기자는 먼저 TaskReporting\(섹션 13.23\) 키의 "ResponseFence" 또는 "FastAbort" 값에 대한 협상을 통해 응답 차단 동작을 평가해야 합니다.\(SHOULD\)

---
##### **4.2.2.4.  Data Sequencing**

일부 명령 실행의 일부로 전송된 데이터 및 R2T PDU는 순서가 지정되어야 합니다. DataSN 필드는 데이터 시퀀싱에 사용됩니다. 입력\(읽기\) 데이터 PDU의 경우 DataSN은 입력 명령의 첫 번째 데이터 PDU에 대해 0부터 시작하고 각 후속 데이터 PDU에 대해 1씩 증가합니다. 출력 데이터 PDU의 경우 DataSN은 시퀀스의 첫 번째 데이터 PDU\(초기 요청되지 않은 시퀀스 또는 R2T를 충족하기 위해 발행된 데이터 PDU 시퀀스\)에 대해 0부터 시작하고 각 후속 데이터 PDU에 대해 1씩 증가합니다. R2T도 명령별로 순서가 지정됩니다. 예를 들어 첫 번째 R2T의 R2TSN은 0이고 후속 R2T마다 1씩 증가합니다. 양방향 명령의 경우 대상은 DataSN/R2TSN을 사용하여 하나의 연속 시퀀스\(미분화\)로 Data-In 및 R2T PDU의 시퀀스를 지정합니다. 명령 및 상태와 달리 데이터 PDU 및 R2T는 일반 발신 PDU의 필드에서 승인되지 않습니다. Data-In PDU는 SNACK PDU의 특별한 형태를 통해 요청 시 인식될 수 있습니다. 데이터 및 R2T PDU는 명령 상태에 따라 암시적으로 승인됩니다. DataSN/R2TSN 필드를 사용하면 개시자가 누락된 데이터 또는 R2T PDU를 감지할 수 있습니다.\(MUST\)

읽기 또는 양방향 명령의 경우 대상은 R2T 및 Data-In PDU를 결합한 2\*\*32개 미만을 발행해야 합니다. 모든 출력 데이터 시퀀스에는 2\*\*32개 미만의 데이터 출력 PDU가 포함되어야 합니다.\(MUST, MUST\)

---
#### **4.2.3.  iSCSI Task Management**
---
##### **4.2.3.1.  Task Management Overview**

iSCSI 작업 관리 기능을 사용하면 개시자가 iSCSI 대상과 함께 운영 중인 iSCSI 세션에서 활성 iSCSI 작업을 제어할 수 있습니다. 섹션 11.5는 이 사양이 정의하는 작업 관리 기능 유형\(ABORT TASK, ABORT TASK SET, CLEAR ACA, CLEAR TASK SET, LOGICAL UNIT RESET, TARGET WARM RESET, TARGET COLD RESET 및 TASK REASSIGN\)을 정의합니다.

이러한 함수 유형 중에서 ABORT TASK 및 TASK REASSIGN 함수는 단일 활성 작업을 관리하는 반면, ABORT TASK SET, CLEAR TASK SET, LOGICAL UNIT RESET, TARGET WARM RESET 및 TARGET COLD RESET 함수는 각각 잠재적으로 여러 활성 작업에 영향을 미칠 수 있습니다.

---
##### **4.2.3.2.  Notion of Affected Tasks**

이 섹션에서는 다중 작업 중단 시나리오에서 "영향을 받는 작업"이라는 개념을 정의합니다. 이 섹션의 범위 정의는 표준 다중 작업 중단 의미 체계\(섹션 4.2.3.3\)와 FastAbort 다중 작업 중단 의미 체계 동작\(섹션 4.2.3.4\) 모두에 적용됩니다.

ABORT TASK SET: ABORT TASK SET TMF 요청 PDU의 LUN 필드로 식별되는 I\_T\_L 넥서스에 대한 모든 미해결 작업입니다.

CLEAR TASK SET: CLEAR TASK SET TMF 요청 PDU의 LUN 필드로 식별되는 LU에 대한 작업 세트의 모든 미해결 작업입니다. "작업 세트"의 정의는 \[SPC3\]을 참조하세요.

LOGICAL UNIT RESET: LOGICAL UNIT RESET 요청 PDU의 LUN 필드로 식별되는 LU에 대한 모든 개시자의 모든 미해결 작업입니다.

TARGET WARM RESET/TARGET COLD RESET: TMF 발행 세션이 iSCSI 세션을 호스팅하는 SCSI 대상 장치에 액세스할 수 있는 모든 LU의 모든 개시자의 모든 미해결 작업입니다.

사용법: 이전 텍스트의 "ABORT TASK SET TMF 요청 PDU"는 섹션 11.5에 정의된 대로 "ABORT TASK SET"로 설정된 "기능" 필드가 있는 iSCSI TMF 요청 PDU입니다. 다른 범위 설명에도 유사한 사용법이 사용됩니다.

---
##### **4.2.3.3.  Standard Multi-Task Abort Semantics**

모든 iSCSI 구현은 이 섹션에 기본 동작으로 정의된 프로토콜 동작을 지원해야 합니다. ABORT TASK SET, CLEAR TASK SET, LOGICAL UNIT RESET, TARGET WARM RESET 및 TARGET COLD RESET TMF 요청의 실행은 지정된 당사자에서 지정된 순서로 다음 작업 시퀀스로 구성됩니다.\(MUST\)

개시자 iSCSI 계층:

- a\) 영향을 받은 작업에 대해 수신된 각 TTT에 계속 응답해야 합니다.\(MUST\)

- b\) 영향을 받은 작업에 대해 수신된 모든 응답을 일반적인 방식으로 처리해야 합니다\(SHOULD\). 이는 응답이 TMF 응답 이전에 전송되었음을 보장하기 때문에 허용됩니다.\(SHOULD\)

- c\) 개시자가 TMF 응답의 전송 또는 수신을 방해할 수 있는 작업\(예: LU 재설정, 연결 삭제\)을 수행하지 않는 한 영향을 받는 작업 집합의 모든 작업을 완료하는 TMF 응답을 수신해야 합니다. 따라서 개시자는 두 경우 모두 이 단계의 일부로 영향을 받는 모든 작업을 종료해야 하며 영향을 받는 작업이 완료된 후 수신된 모든 TMF 응답을 폐기해야 합니다.\(SHOULD, MUST\)

대상 iSCSI 계층:

- a\) 발행 개시자로부터 영향을 받는 작업의 현재 유효한 대상 전송 태그에 대한 응답을 기다려야 합니다. 제3자 개시자로부터 영향을 받는 작업의 현재 유효한 대상 전송 태그에 대한 응답을 기다릴 수 있습니다.\(MUST, MAY\)

- b\) 영향을 받는 작업의 모든 명령이 CmdSN 순서에 따라 수신될 때까지 기다려야 합니다\(a 단계의 대기와 동시에\). 영향을 받는 타사 세션에서 새 명령을 기다리면 안 됩니다. 영향을 받는 작업을 결정하기 위해 인스턴스화된 작업만 고려해야 합니다. 그러나 대상 범위 요청\(예: TARGET WARM RESET 및 TARGET COLD RESET\)의 경우 명령 스트림의 발급 세션에서 아직 수신되지 않은 모든 명령은 대기 중인 명령 없이 수신된 것으로 간주될 수 있습니다. 기간 - 즉, 작업 관리 기능의 CmdSN까지 전체 CmdSN 공간을 "플러그"할 수 있습니다.\(MUST, SHOULD NOT\)

- c\) TMF 요청을 대상 SCSI 계층으로 전파하고 대상 SCSI 계층으로부터 응답을 받아야 합니다.\(MUST\)

- d\) 섹션 4.2.2.3.2에 지정된 대로 발행 세션에서 TMF 응답에 대한 응답 펜스 동작을 제공해야 합니다.\(MUST\)

- e\) 섹션 4.2.2.3.3에 지정된 대로 제3자 세션의 첫 번째 사후 TMF 응답에 응답 펜스 동작을 제공해야 합니다. 일부 작업이 비-iSCSI I\_T\_L 넥서스에서 시작된 경우 대상이 영향을 받는 모든 작업이 해당 상태를 개시자에게 반환했는지 확인하는 수단은 특정 비-iSCSI 전송 프로토콜에 의해 정의됩니다.\(MUST\)

기술적으로 TMF 서비스는 d\)단계에서 완료됩니다. 그러나 종료된 작업에 해당하는 데이터 전송은 e\) 단계가 끝난 후에도 타사 iSCSI 세션에서 계속 진행 중일 수 있습니다. TMF 응답은 단계 d\)가 끝나기 전에 대상 iSCSI 계층에 의해 전송되어서는 안 되며, 단계 e\) 이후까지 이러한 미해결 데이터 전송에도 불구하고 단계 d\)가 끝날 때 전송될 수 있습니다.\(MUST NOT\)

---
##### **4.2.3.4.  FastAbort Multi-Task Abort Semantics**

이 섹션에 정의된 프로토콜 동작은 이 문서를 준수하는 모든 iSCSI 구현으로 구현되어야 하며, 아래 일부 단계는 \[RFC3720\] 의미 체계와 호환되지 않을 수 있다는 점에 유의하세요. 그러나 이 섹션에 정의된 프로토콜 동작은 해당 세션에서 TaskReporting\(섹션 13.23\) 키를 "FastAbort"로 협상할 때 iSCSI 세션의 iSCSI 구현에 의해 표시되어야 합니다. ABORT TASK SET, CLEAR TASK SET, LOGICAL UNIT RESET, TARGET WARM RESET 및 TARGET COLD RESET TMF 요청의 실행은 지정된 당사자에서 지정된 순서로 다음 작업 시퀀스로 구성됩니다.\(SHOULD, MUST\)

개시자 iSCSI 계층:

- a\) TMF가 대상으로 전송되면 발행 iSCSI 세션의 발행 연결에서 영향을 받는 작업에 대해 더 이상 데이터 출력 PDU를 보내서는 안 됩니다.\(MUST NOT\)

- b\) 영향을 받은 작업에 대해 수신된 모든 응답을 일반적인 방식으로 처리해야 합니다\(SHOULD\). 이는 응답이 TMF 응답 이전에 전송되었음을 보장하기 때문에 허용됩니다.\(SHOULD\)

- c\) 섹션 11.9에 정의된 대로 작업 종료 AsyncEvent\(5\)를 사용하여 각 비동기 메시지 PDU에 응답해야 합니다.\(MUST\)

- d\) TMF 응답을 응답이 수신되지 않은 모든 영향을 받는 작업을 종료하는 것으로 처리해야 하며 TMF 응답이 SCSI 계층에 전달된 후에 수신된 영향을 받는 작업에 대한 모든 응답을 폐기해야 합니다\(이 섹션에 정의된 의미론은 다음과 같은 것을 보장합니다\). 규정을 준수하는 대상 구현에서는 순서가 잘못된 시나리오가 절대 발생하지 않습니다.\(MUST\)

대상 iSCSI 계층:

- a\) 영향을 받는 작업의 모든 명령이 발급 세션의 CmdSN 순서에 따라 수신될 때까지 기다려야 합니다. 영향을 받는 타사 세션에서 새 명령을 기다리면 안 됩니다. 영향을 받는 작업을 결정하기 위해 인스턴스화된 작업만 고려해야 합니다. 대상 범위 요청\(예: TARGET WARM RESET 및 TARGET COLD RESET\)의 경우 명령 스트림의 발급 세션에서 아직 수신되지 않은 모든 명령은 명령 대기 기간 없이 수신된 것으로 간주될 수 있습니다. 즉, 작업 관리 기능의 CmdSN까지 전체 CmdSN 공간을 "플러그"할 수 있습니다.\(MUST, SHOULD NOT\)

- b\) TMF 요청을 대상 SCSI 계층으로 전파하고 대상 SCSI 계층으로부터 응답을 받아야 합니다.\(MUST\)

- c\) 모든 활성 "영향을 받는 TTT"\(즉, 영향을 받는 작업과 관련된 활성 TTT\)를 유효한 상태로 두어야 합니다.\(MUST\)

- d\) 다음에서 AsyncEvent=5\(섹션 11.9\)를 사용하여 비동기 메시지 PDU를 보내야 합니다.\(MUST\)

- 1\) TaskReporting=FastAbort가 해당 타사 세션에서 작동하는 경우 적어도 하나의 영향을 받는 작업이 적용되는 각 타사 세션의 각 연결, 그리고

- 2\) 적어도 하나의 관련 영향을 받는 작업이 있는 발급 세션의 발급 연결을 제외한 각 연결.

- 영향을 받는 LU가 여러 개 있는 경우\(예를 들어 대상 재설정으로 인해\) 하나 이상의 비동기 메시지 PDU가 영향을 받는 할당 작업이 하나 이상 있는 각 연결의 각 LU에 대해 전송되어야 합니다. 비동기 메시지 PDU의 LUN 필드는 각 LU의 ​​LUN과 일치하도록 설정되어야 합니다.\(MUST, MUST\)

- e\) 섹션 4.2.2.3.3에 정의된 대로 발행 세션의 TMF 응답에 대한 응답 펜스 플래그를 처리해야 합니다.\(MUST\)

- f\) 섹션 4.2.2.3.3에 정의된 대로 제3자 세션의 첫 번째 TMF 이후 응답에서 응답 펜스 플래그를 처리해야 합니다. 일부 작업이 비-iSCSI I\_T\_L 넥서스에서 시작된 경우 대상이 영향을 받는 모든 작업이 해당 상태를 개시자에게 반환했는지 확인하는 수단은 특정 비-iSCSI 전송 프로토콜에 의해 정의됩니다.\(MUST\)

g\) 영향을 받은 TTT\(및 iSER의 STag\)를 해제해야 합니다.

- 해당\) 및 해당 버퍼\(있는 경우\)는 개시자가 각 비동기 메시지에 대한 응답으로 생성한 연결된 각 NOP-Out 승인을 수신한 후 수행됩니다.\(MUST\)

기술적으로 TMF 서비스는 e\) 단계에서 완료됩니다. 그러나 종료된 작업에 해당하는 데이터 전송은 f\)단계가 종료된 후에도 계속 진행 중일 수 있습니다. TMF 응답은 e\) 단계가 끝나기 전에 대상 iSCSI 계층에 의해 전송되어서는 안 되며, g\) 단계까지 처리되지 않은 데이터 전송에도 불구하고 e\) 단계가 끝날 때 전송될 수 있습니다. g\) 단계는 뛰어난 데이터 전송을 지원하기 위해 예약되었을 수 있는 리소스를 확보하는 이벤트를 지정합니다.\(MUST NOT\)

---
##### **4.2.3.5.  Affected Tasks Shared across Standard and FastAbort Sessions**

iSCSI 대상 구현이 TaskReporting=FastAbort 기능\(섹션 13.23\)을 지원할 수 있는 경우 일부 세션에서는 TaskReporting=RFC3720 작동\(RFC 3720 세션\)이 있는 반면 일부 다른 세션에서는 TaskReporting=FastAbort 작동\(FastAbort 세션\)이 있는 상황이 발생할 수 있습니다. \) 영향을 받는 작업의 공유 세트에 액세스하는 동안에도 마찬가지입니다\(섹션 4.2.3.2\). 발급 세션이 RFC 3720 세션이고 iSCSI 대상 구현이 FastAbort 가능하며 영향을 받는 타사 세션이 FastAbort 세션인 경우 iSCSI 대상 계층에서 다음 동작이 나타나야 합니다.\(SHOULD\)

a\) 목표 행동의 c\)와 d\) 단계 사이

- 섹션 4.2.3.3, 적어도 하나의 영향을 받는 작업이 관련되는 각 타사 세션의 각 연결에서 AsyncEvent=5\(섹션 11.9\)를 사용하여 비동기 메시지 PDU를 보냅니다. 영향을 받는 LU가 여러 개인 경우 영향을 받는 충성 작업이 하나 이상 있는 각 연결에서 해당 LU마다 하나의 비동기 메시지 PDU를 보냅니다. 전송되면 비동기 메시지 PDU의 LUN 필드는 각 LU의 ​​LUN과 일치하도록 설정되어야 합니다.\(MUST\)

- b\) 섹션 4.2.3.3의 대상 동작 e\) 단계 이후, 연결된 각 NOP-Out 승인이 수신되면 영향을 받은 TTT\(및 해당되는 경우 iSER의 STag\)와 해당 버퍼\(있는 경우\)를 해제합니다. a\) 단계에서 전송된 각 비동기 메시지에 대한 응답으로 생성된 타사 개시자입니다.

발행 세션이 FastAbort 세션이고 iSCSI 대상 구현이 FastAbort 가능하며 영향을 받는 타사 세션이 RFC 3720 세션인 경우 iSCSI 대상 계층은 타사 세션에서 비동기 메시지 PDU를 전송하여 메시지를 표시해서는 안 됩니다. FastAbort 동작.\(MUST NOT\)

영향을 받는 제3자 세션이 FastAbort 세션이고 발행 세션이 FastAbort 세션인 경우, 제3자 역할의 개시자는 섹션 11.9에 정의된 대로 AsyncEvent=5로 각 비동기 메시지 PDU에 응답해야 합니다. 따라서 개시자는 세션이 단일 연결 세션인 경우에도 영향을 받는 제3자 세션에서 이러한 비동기 메시지를 수신할 수 있습니다.\(MUST, MAY\)

---
##### **4.2.3.6.  Rationale behind the FastAbort Semantics**

섹션 4.2.3.3 및 4.2.3.4에 지정된 의미론 뒤에는 기본적으로 세 가지 기본 목표가 있습니다.

- a\) 다중 연결 세션에서도 대상 SCSI 계층에 대한 순서 있는 명령 흐름 I\_T 넥서스 추상화를 유지합니다.

- - TMF 요청의 대상 iSCSI 처리는 단일 흐름 환상을 유지해야 합니다. 섹션 4.2.3.3의 단계 b\)의 목표 동작과 섹션 4.2.3.4의 단계 a\)의 목표 동작은 이 목표에 해당합니다.

b\) 단일 순서 응답 흐름 I\_T 넥서스 유지

- 하나의 응답\(예: TMF 응답\)이 개시자의 관점에서 완료되지 않은 다른 작업의 상태를 암시할 수 있는 경우 다중 연결 세션에서도 개시자 SCSI 계층으로 추상화합니다.

- - 대상은 개시자가 TMF 응답을 본 후 "오래된" 작업 응답\(TMF 응답보다 연대순으로 이전에 배치된\)을 보지 않도록 해야 합니다. 섹션 4.2.3.3의 단계 d\)의 목표 행동과 섹션 4.2.3.4의 단계 e\)의 목표 행동은 이 목표에 해당합니다.

- - TMF 작업의 결과가 여러 I\_T\_L 넥서스에서 표시될 때마다 \[SAM2\]는 SCSI 장치 서버가 다른 I\_T\_L 넥서스 각각에서 UA를 트리거하도록 요구합니다. 개시자가 그러한 UA에 대해 통보받으면 수신 개시자의 애플리케이션 클라이언트는 영향을 받는 작업에 대한 작업 상태\(\[SAM2\]의 5.5절\)를 지워야 합니다. 따라서 개시자에서 작업 상태가 지워진 후, 즉 UA에 통보된 후 작업에 대한 SCSI 응답을 전달하는 것은 부적절합니다. UA 알림은 다음에 포함되어 있습니다.

- TMF 작업 이후 영향을 받는 각 타사 I\_T\_L 넥서스의 첫 번째 SCSI 응답 PDU는 따라서 LU에 액세스하는 모든 iSCSI 세션에서 영향을 받는 작업 응답을 전달해서는 안 됩니다. 섹션 4.2.3.3의 e\) 단계의 목표 동작과 섹션 4.2.3.4의 단계 f\)의 목표 동작은 이 목표에 해당합니다.\(MUST NOT\)

- c\) 결정론적인 방식으로 영향을 받는 작업에 해당하는 모든 활성 TTT를 배출합니다.

- - 작업이 종료된 후 오래된 TTT가 도착하는 데이터 출력 PDU는 기존 iSCSI 구현에서도 버퍼 관리 문제를 일으킬 수 있으며 iSCSI/iSER 구현 연결에 치명적입니다. 영향을 받는 작업의 종료는 TTT가 폐기될 때까지 연기되거나\(섹션 4.2.3.3의 단계 a\)\) TTT와 버퍼는 작업 종료 이후에 할당된 상태를 유지하여 나중에 결정론적으로 해제되어야 합니다\(단계 c에서와 같이\). \) 및 g\) 섹션 4.2.3.4\).

유일하게 주목할만한 최적화는 연결입니다. I\_T 넥서스의 모든 작업이 어쨌든 중단되는 경우\(대상 재설정과 마찬가지로\) CmdSN 구멍을 연결하는 모든 명령을 수신할 때까지 기다릴 필요가 없습니다. 대상 iSCSI 계층은 누락된 모든 CmdSN 슬롯을 연결하고 TMF 처리를 계속 진행할 수 있습니다. 첫 번째 목표\(순서가 지정된 단일 명령 흐름 유지\)는 대상 SCSI 계층이 순서가 지정된 명령만 볼 수 있기 때문에 이 최적화를 통해 여전히 충족됩니다.

---
#### **4.2.4.  iSCSI Login**

iSCSI 로그인의 목적은 iSCSI 사용을 위한 TCP 연결, 당사자 인증, 세션 매개변수 협상 및 연결을 iSCSI 세션에 속하는 것으로 표시하는 것입니다.

세션은 동일한 I\_T 넥서스에 속하는 지정된 개시자와의 모든 연결을 대상에 식별하는 데 사용됩니다. \(세션이 I\_T 넥서스와 어떻게 관련되는지에 대한 자세한 내용은 섹션 4.4.2를 참조하세요.\)

대상은 잘 알려진 TCP 포트나 다른 TCP 포트에서 들어오는 연결을 수신합니다. 개시자는 이러한 TCP 포트 중 하나에 연결하여 로그인 프로세스를 시작합니다.

로그인 프로세스의 일부로 개시자와 대상은 서로를 인증해야 하며 세션에 대한 보안 연결 프로토콜을 설정할 수 있습니다. 이는 다양한 방식으로 발생할 수 있으며 협상 대상입니다. 섹션 12를 참조하세요.\(SHOULD\)

TCP 연결을 보호하기 위해 로그인 요청 전에 IPsec 보안 연결을 설정할 수 있습니다. iSCSI에 IPsec 보안을 사용하는 방법에 대한 자세한 내용은 섹션 9, \[RFC3723\] 및 \[RFC7146\]을 참조하세요.\(MAY\)

iSCSI 로그인 단계는 로그인 요청 및 응답을 통해 수행됩니다. 적절한 인증이 이루어지고 작동 매개변수가 설정되면 세션은 전체 기능 단계로 전환되고 개시자는 SCSI 명령 전송을 시작할 수 있습니다. 대상이 개시자 인증을 선택하는지 여부와 그 수단에 대한 보안 정책은 이 문서의 범위를 벗어납니다. 로그인 단계에 대한 자세한 설명은 섹션 6을 참조하세요.

로그인 PDU에는 세션 ID\(SSID\)의 ISID 부분이 포함됩니다. 로그인을 서비스하는 대상 포털 그룹은 연결 끝점 선택에 의해 암시됩니다. 새 세션의 경우 TSIH는 0입니다. 응답의 일부로 대상은 TSIH를 생성합니다.

세션 설정 중에 대상은 값 쌍\(InitiatorName, ISID\)을 통해 SCSI 개시자 포트\("I\_T 넥서스"의 "I"\)를 식별합니다. 이 섹션의 뒷부분에서 InitiatorName에 대해 설명합니다. SCSI 개시자 포트와 연관된 대상의 모든 지속 상태\(예: 지속 예약\)는 이 값 쌍을 기반으로 식별됩니다. SCSI 대상 포트\("I\_T 넥서스"의 "T"\)와 관련된 모든 상태는 TargetName 및 대상 포털 그룹 태그에 의해 외부적으로 식별됩니다\(섹션 4.4.1 참조\). ISID는 지속 상태를 식별하는 데 사용되므로 재사용 제한이 적용됩니다\(섹션 4.4.3 참조\).

전체 기능 단계가 설정되기 전에는 로그인 요청 및 로그인 응답 PDU만 허용됩니다. 로그인 요청 및 응답은 로그인 중에만 사용해야 합니다. 모든 연결에서 로그인 단계는 TCP 연결 설정 직후에 이루어져야 하며, 연결을 끊기 전에 후속 로그인 단계가 발생해서는 안 됩니다.\(MUST, MUST NOT\)

로그인 단계가 시작되기 전에 로그인 요청을 제외한 모든 PDU를 수신하는 대상은 PDU가 수신된 연결을 즉시 종료해야 합니다. 로그인 단계가 시작되면 대상이 로그인 요청을 제외한 PDU를 수신하는 경우 반드시 로그인 거부\("로그인 중 유효하지 않음" 상태\)를 보낸 다음 연결을 끊어야 합니다. 개시자가 로그인 응답을 제외한 PDU를 수신하면 즉시 연결을 종료해야 합니다.\(MUST, MUST, MUST\)

---
#### **4.2.5.  iSCSI Full Feature Phase**

양측이 세션의 첫 번째 연결\(리딩이라고도 함\)에서 성공적으로 로그인을 완료하면 iSCSI 세션은 iSCSI 전체 기능 단계에 있게 됩니다. 세션이 전체 기능 단계에 있고 연결 로그인이 성공적으로 완료되면 연결은 전체 기능 단계에 있는 것입니다. 다음 경우에는 iSCSI 연결이 전체 기능 단계에 있지 않습니다.

- a\) 확립된 전송 연결이 없거나, 또는

- b\) 유효한 전송 연결이 있지만 성공적인 로그인이 수행되지 않았거나 연결이 현재 로그아웃된 경우.

일반적인 전체 기능 단계에서 개시자는 설정된 iSCSI 세션을 통과하는 iSCSI PDU에 SCSI 명령과 데이터를 캡슐화하여 대상의 다양한 LU에 보낼 수 있습니다.

---
##### **4.2.5.1.  Command Connection Allegiance**

TCP 연결을 통해 발행된 모든 iSCSI 요청의 경우 해당 응답 및/또는 기타 관련 PDU가 동일한 연결을 통해 전송되어야 합니다. 우리는 이것을 "연결 충성"이라고 부릅니다. 명령이 완료되기 전에 원래 연결이 실패하면 명령의 연결 충성은 섹션 7.2에 자세히 설명된 대로 다른 전송 연결에 명시적으로 재할당될 수 있습니다.\(MUST\)

따라서 개시자가 읽기 명령을 발행하는 경우 대상은 요청된 데이터\(있는 경우\)와 함께 상태를 SCSI 명령 전달에 사용된 것과 동일한 TCP 연결을 통해 개시자에게 보내야 합니다. 개시자가 쓰기 명령을 발행하는 경우 개시자는 SCSI 명령을 전달하는 데 사용된 동일한 TCP 연결을 통해 해당 명령에 대한 데이터\(있는 경우\)를 보내야 합니다. 대상은 R2T\(전송 준비\)\(있는 경우\)와 SCSI 명령을 전달하는 데 사용된 동일한 TCP 연결을 통한 상태를 반환해야 합니다. 재전송 요청\(SNACK PDU\)과 이들이 생성하는 데이터 및 상태도 동일한 연결을 사용해야 합니다.\(MUST, MUST, MUST, MUST\)

그러나 SCSI 연결 명령 체인 작업\(\[SAM2\] 참조\)의 일부인 연속 명령은 다른 연결을 사용할 수 있습니다. 연결 충성은 작업별로가 아니라 명령별로 엄격하게 적용됩니다. iSCSI 전체 기능 단계 동안 개시자와 대상은 관련되지 않은 SCSI 명령, 해당 SCSI 데이터 및 세션에 대한 응답을 인터리브할 수 있습니다.\(MAY, MAY\)

---
##### **4.2.5.2.  Data Transfer Overview**

나가는 SCSI 데이터\(초기자에서 대상으로의 사용자 데이터 또는 명령 매개변수\)는 요청된 데이터 또는 요청되지 않은 데이터로 전송됩니다. 요청된 데이터는 R2T PDU에 대한 응답으로 전송됩니다. 원치 않는 데이터는 iSCSI 명령 PDU\("즉시 데이터"\)의 일부로 전송되거나 별도의 iSCSI 데이터 PDU로 전송될 수 있습니다.

즉시 데이터는 개시자 SCSI 쓰기 버퍼\(송신 데이터 버퍼\)의 오프셋 0에서 시작되는 것으로 가정됩니다. 다른 모든 데이터 PDU에는 PDU 헤더에 버퍼 오프셋이 명시적으로 설정되어 있습니다.

개시자는 원치 않는 데이터를 FirstBurstLength\(13.14절 참조\)까지 즉시\(협상된 최대 PDU 길이까지\), 별도의 PDU 시퀀스로, 또는 둘 다로 전송할 수 있습니다. 모든 후속 데이터를 요청해야 합니다. 개별 데이터 PDU의 최대 길이 또는 첫 번째 원치 않는 버스트의 직접 부분은 로그인 시 협상될 수 있습니다.\(MUST, MAY\)

명령으로 전송될 수 있는 원치 않는 데이터의 최대량은 로그인 시 FirstBurstLength\(섹션 13.14 참조\) 키를 통해 협상됩니다. 대상은 원치 않는 데이터의 보다 일반적인\(별도의 데이터 PDU\) 형태\(InitialR2T 키를 통해\)를 활성화하지 않고\(ImmediateData 키를 통해\) 즉시 데이터를 별도로 활성화할 수 있습니다.\(MAY\)

쓰기에 대한 원치 않는 데이터는 대기 시간이 처리량에 미치는 영향을 줄이기 위한 것입니다\(데이터 전송을 시작하는 데 R2T가 필요하지 않음\). 또한 즉각적인 데이터는 프로토콜 오버헤드\(대역폭과 실행 시간 모두\)를 줄이기 위한 것입니다.

iSCSI 초기자는 원치 않는 데이터를 보내지 않고 명령을 통해 즉각적인 데이터 또는 FirstBurstLength 바이트의 원치 않는 데이터만 보내도록 선택할 수 있습니다. 즉각적이지 않은 원치 않는 데이터가 전송되는 경우 총 원치 않는 데이터는 FirstBurstLength이거나 총량이 FirstBurstLength보다 작은 경우 전체 데이터여야 합니다.\(MAY, MUST\)

개시자가 요청하지 않은 데이터 PDU를 R2T 모드에서 작동하는 대상에 보내는 것은 오류로 간주됩니다\(요청된 데이터만 허용됨\). 개시자가 즉시 또는 별도의 PDU로 FirstBurstLength보다 더 많은 원치 않는 데이터를 보내는 것도 오류입니다.

이니시에이터는 유효한 미해결 명령\(즉, 유효한 이니시에이터 작업 태그 전달\)에 대한 R2T 데이터 요청을 수락하고 명령이 전달되어야 하는 경우 요청된 모든 데이터를 전달해야 합니다.\(MUST\)

나가는 데이터와 R2T는 명령 범위 내의 데이터를 지정합니다. 명령 범위 외부의 데이터 전체 또는 일부를 지정하는 R2T 요청을 수신하기 위한 개시자 작업이 지정되지 않았습니다.

대상은 자동으로 데이터를 삭제한 다음 R2T를 통해 재전송을 요청해서는 안 됩니다. 개시자는 대상과 주고받는 데이터를 추적해서는 안 됩니다\(점수판 작성\). SCSI 타겟은 잔여 개수 계산을 수행하여 명령에 의해 장치로 또는 장치에서 실제로 전송된 데이터의 양을 확인합니다. 이는 재전송, 오류 등의 이유로 개시자가 전송 및/또는 수신한 금액과 다를 수 있습니다. 읽기 또는 양방향 명령은 해당 명령이 다루는 전체 데이터 양의 전송을 암시적으로 요청합니다. SCSI 데이터 패킷은 프로토콜에 지정된 태그를 사용하여 해당 SCSI 명령과 일치됩니다.\(SHOULD NOT, SHOULD NOT\)

또한 iSCSI 개시자와 대상은 일부 순서 규칙을 시행해야 합니다. 원치 않는 데이터가 사용되는 경우 각 연결의 원치 않는 데이터 순서는 해당 연결에서 명령이 전송되는 순서와 일치해야 합니다. 명령 및 요청되지 않은 데이터 PDU는 각각의 순서 요구 사항이 유지되는 한 단일 연결에서 인터리브될 수 있습니다\(예: 명령 N + 1은 명령 N에 대한 요청되지 않은 데이터 출력 PDU 이전에 전송될 수 있지만 요청되지 않은 데이터 출력 PDU는 명령 N의 경우 명령 N + 1의 요청되지 않은 데이터 출력 PDU보다 앞에 있어야 합니다. 순서가 잘못된 데이터를 수신하는 대상은 세션을 종료할 수 있습니다.\(MUST, MUST, MUST, MAY\)

---
##### **4.2.5.3.  Tags and Integrity Checks**

보류 중인 명령에 대한 개시자 태그는 세션에 대해 개시자 전체에서 고유합니다. 대상 태그는 프로토콜에 의해 엄격하게 지정되지 않습니다. 대상 태그는 대상에서 요청된 데이터에 태그를 지정하기 위해\(단독으로 또는 LUN과 함께\) 사용되는 것으로 가정됩니다. 대상 태그는 대상에 의해 생성되고 개시자에 의해 "반향"됩니다.

이러한 메커니즘은 데이터 흐름에 대한 광범위한 제어와 함께 효율적인 데이터 전달을 달성하도록 설계되었습니다.

개시자 작업 태그는 실행 중에 작업을 식별하는 데 사용되므로 iSCSI 개시자와 대상은 작업 관련 PDU에 사용된 다른 모든 필드가 개시자 태그를 기반으로 작업 인스턴스화에 사용된 값과 일치하는 값을 가지고 있는지 확인해야 합니다. 작업 태그\(예: R2T PDU에 사용되는 LUN은 작업을 인스턴스화하는 데 사용되는 SCSI 명령 PDU에 사용되는 LUN과 동일해야 합니다\). 일관되지 않은 필드 값을 사용하는 것은 프로토콜 오류로 간주됩니다.\(MUST\)

---
##### **4.2.5.4.  SCSI Task Management during iSCSI Full Feature Phase**

SCSI 작업 관리는 개별 작업 및 작업 그룹이 작업 태그\(개별 작업의 경우\) 또는 작업 관리 명령의 타이밍\(작업 그룹의 경우\)만을 기반으로 중단될 수 있고 작업 관리 작업이 동기적으로 실행된다고 가정합니다. 즉, 중단된 작업과 관련된 메시지는 작업 관리 응답을 받은 후 SCSI 개시자에게 표시되지 않습니다. iSCSI에서는 개시자와 대상이 여러 연결을 통해 비동기적으로 상호 작용합니다. iSCSI는 비동기식 iSCSI 인프라를 사용하는 동안 동기식 SCSI 보기를 제공하는 데 필요한 프로토콜 메커니즘과 구현 요구 사항을 지정합니다.

---
#### **4.2.6.  iSCSI Connection Termination**

전송 연결 종료 또는 전송 재설정을 통해 iSCSI 연결이 종료될 수 있습니다. 전송 재설정은 예외적인 이벤트로 간주됩니다.

TCP FIN을 보내면 TCP 연결을 정상적으로 종료할 수 있습니다. 정상적인 전송 연결 종료는 연결이 iSCSI 전체 기능 단계에 있지 않을 때 한쪽 당사자에 의해서만 시작되어야 합니다. 타겟은 내부 예외 이벤트에서 전체 기능 단계 연결을 종료할 수 있지만 비동기 메시지 PDU를 통해 사실을 알려야 합니다. 처리되지 않은 명령으로 인한 연결 종료에는 복구 작업이 필요할 수 있습니다.\(SHOULD, SHOULD\)

전체 기능 단계에서 연결이 종료된 경우 복구하기 전에 연결 정리\(섹션 7.14 참조\)가 필요합니다. 복구를 시작하기 전에 연결 정리를 수행하면 개시자와 대상이 복구 후 오래된 PDU 수신을 방지할 수 있습니다.

---
#### **4.2.7.  iSCSI Names**

대상과 개시자 모두 식별을 위해 이름이 필요합니다. 또한 이름을 사용하면 위치\(주소\)에 관계없이 iSCSI 스토리지 리소스를 관리할 수 있습니다. iSCSI 노드 이름은 iSCSI 노드에 포함된 SCSI 장치 이름이기도 합니다. SCSI 장치의 iSCSI 이름은 개시자에 대한 대상 및 대상에 대한 개시자를 인증하는 데 사용되는 주요 개체입니다. 이 이름은 iSCSI 스토리지 리소스를 식별하고 관리하는 데에도 사용됩니다.

iSCSI 이름은 최종 사용자의 작업 도메인 내에서 고유해야 합니다. 그러나 IP 네트워크의 작동 도메인은 잠재적으로 전 세계적이므로 iSCSI 이름 형식은 전 세계적으로 고유하도록 설계되었습니다. 전 세계적으로 고유한 이름을 구성하는 명명 기관을 지원하기 위해 iSCSI는 다양한 명명 기관 유형에 대해 세 가지 이름 형식을 제공합니다.

iSCSI 이름은 iSCSI 네트워크 어댑터 카드가 아닌 iSCSI 노드와 연결되므로 네트워크 어댑터 카드 교체 시 모든 SCSI 및 iSCSI 리소스 할당 정보를 재구성할 필요가 없습니다.

일부 SCSI 명령을 사용하려면 프로토콜별 식별자가 SCSI CDB 내에서 전달되어야 합니다. iSCSI 포트의 SCSI 포트 이름/식별자의 정의는 섹션 2.2를 참조하십시오.

개시자는 SendTargets 텍스트 요청 또는 \[RFC3721\]에 설명된 기타 기술을 사용하여 해당 주소와 함께 액세스 권한이 있는 iSCSI 대상 이름을 검색할 수 있습니다.

SendTargets 이상의 검색 기능이 필요한 iSCSI 장비는 확장된 검색 관리 기능 및 상호 운용성을 위해 iSNS\(\[RFC4171\] 참조\)를 구현해야 합니다. \[RFC3721\]은 SLP\(\[RFC2608\]\) 구현 요구 사항을 암시하지만 SLP는 실제로 iSCSI와 함께 사용하기 위해 널리 구현되거나 배포되지 않았습니다. 따라서 iSCSI 구현은 SLP 기반 검색 상호 운용성에 의존해서는 안 됩니다.\(SHOULD, SHOULD NOT\)

---
##### **4.2.7.1.  iSCSI Name Properties**

개시자, 대상 또는 둘 다인지 여부에 관계없이 각 iSCSI 노드에는 iSCSI 이름이 있어야 합니다. iSCSI 노드에 iSCSI 개시자 노드와 iSCSI 대상 노드가 포함될 때마다 iSCSI 개시자 이름은 전체 iSCSI 노드에 대해 하나의 iSCSI 노드 이름만 있도록 포함된 노드의 iSCSI 대상 이름과 동일해야 합니다. 이러한 시나리오에서 CHAP 이름을 iSCSI 이름에 매핑하는 방법에 대해서는 섹션 9.2.1의 관련 요구 사항을 참조하십시오.\(MUST, MUST\)

개시자와 대상은 최대 길이 223바이트의 iSCSI 이름 수신을 지원해야 합니다.\(MUST\)

개시자는 새 세션 또는 연결의 첫 번째 로그인 요청에서 연결하려는 iSCSI 개시자 이름과 iSCSI 대상 이름을 모두 제시해야 합니다. 유일한 예외는 Discovery 세션\(섹션 4.3 참조\)이 설정되는 경우입니다. 이 경우에도 iSCSI 초기자 이름이 필요하지만 iSCSI 대상 이름은 생략할 수 있습니다.\(MUST, MAY\)

iSCSI 이름에는 다음과 같은 속성이 있습니다.

- - iSCSI 이름은 전역적으로 고유합니다. 두 개의 개시자 또는 대상이 동일한 이름을 가질 수 없습니다.

- - iSCSI 이름은 영구적입니다. iSCSI 개시자 노드 또는 대상 노드는 수명 동안 동일한 이름을 갖습니다.

- - iSCSI 이름은 위치나 주소를 암시하지 않습니다. iSCSI 개시자 또는 대상은 여러 주소를 이동하거나 가질 수 있습니다. 주소 변경은 이름 변경을 의미하지 않습니다.

- - iSCSI 이름은 중앙 이름 브로커에 의존하지 않습니다. 명명 권한이 분산됩니다.

- - iSCSI 이름은 기존 고유 명명 체계와의 통합을 지원합니다.

- - iSCSI 이름은 기존 명명 기관을 따릅니다. iSCSI는 새로운 명명 권한을 생성하지 않습니다.

iSCSI 이름 인코딩에는 다음과 같은 속성이 있습니다.

- - iSCSI 이름은 기본 프로토콜에 관계없이 동일한 인코딩 방법을 갖습니다.

- - iSCSI 이름은 상대적으로 비교가 간단합니다. 두 개의 iSCSI 이름이 동일한지 비교하는 알고리즘은 외부 서버에 의존하지 않습니다.

- - iSCSI 이름은 인쇄 가능한 ASCII 및 유니코드 문자로만 구성됩니다. iSCSI 이름에는 국제 문자 집합을 사용할 수 있지만 대문자는 금지됩니다. iSCSI stringprep 프로필 \[RFC3722\]은 대문자를 소문자로 매핑하고 대문자를 포함할 수 있는 입력에서 iSCSI 이름을 준비하는 데 사용해야 합니다. iSCSI 이름에는 공백 문자가 사용되지 않습니다. 자세한 내용은 \[RFC3722\]를 참조하세요.\(SHOULD\)

- - iSCSI 이름은 바이너리 및 ASCII 기반 프로토콜을 모두 사용하여 전송될 수 있습니다.

iSCSI 이름은 실제로 논리적 소프트웨어 엔터티의 이름이며 변경할 수 있는 포트나 기타 하드웨어에 연결되어 있지 않습니다. 예를 들어 개시자 이름은 특정 NIC 또는 HBA가 아닌 iSCSI 개시자 노드의 이름을 지정해야 합니다. 여러 개의 NIC를 사용하는 경우 일반적으로 대상에 모두 동일한 iSCSI 초기자 이름을 표시해야 합니다. 이는 단순히 동일한 SCSI 계층에 대한 경로이기 때문입니다. 대부분의 운영 체제에서 명명된 엔터티는 운영 체제 이미지입니다.

마찬가지로 대상 이름은 변경될 수 있는 하드웨어 인터페이스에 연결되어서는 안 됩니다. 대상 이름은 논리적 대상을 식별해야 하며 주소 지정되는 물리적 부분에 관계없이 대상에 대해 동일해야 합니다. 이는 iSCSI 초기자가 발견한 두 대상이 실제로 동일한 대상에 대한 두 경로인지 확인하는 데 도움이 됩니다.

iSCSI 이름은 URN\(Uniform Resource Names\) \[RFC1737\]에 대한 기능 요구 사항을 충족하도록 설계되었습니다. 예를 들어, 이름은 전역 범위를 갖고, 주소나 위치에 독립적이어야 하며, 지속적이고 전역적으로 고유해야 합니다. 이름은 명명 권한을 사용하여 확장 가능해야 합니다. 이름 인코딩은 사람과 기계가 모두 읽을 수 있어야 합니다. 추가 요구사항은 \[RFC1737\]을 참조하세요.

---
##### **4.2.7.2.  iSCSI Name Encoding**

iSCSI 이름은 다음 속성을 가진 유니코드 문자열의 UTF-8\(\[RFC3629\] 참조\) 인코딩이어야 합니다.\(MUST\)

- - 정규화 형식 C입니다\("유니코드 정규화 형식" \[UNICODE\] 참조\).

- - iSCSI stringprep 템플릿\(\[RFC3722\]에 설명됨\)의 출력에서 ​​허용되는 문자만 포함합니다.

- - iSCSI 이름 형식을 지정하는 데 다음 문자가 사용됩니다.

```text
           dash ('-'=U+002d)

           dot ('.'=U+002e)

           colon (':'=U+003a)
```

- - 이름의 UTF-8 인코딩은 223바이트보다 크지 않습니다.

stringprep 프로세스는 \[RFC3454\]에 설명되어 있습니다. iSCSI의 stringprep 프로세스 사용은 \[RFC3722\]에 설명되어 있습니다. stringprep 프로세스는 사람이 입력한 문자열을 불투명 문자열과 비교할 수 있는 형식으로 변환하기 위해 IDN\(Internationalized Domain Name\) 작업 그룹에서 설계한 방법입니다. iSCSI 이름은 관리자가 시스템 구성과 같은 목적으로 사용할 것으로 예상됩니다. 이러한 이유로 \[RFC3722\]에 의해 stringprep 처리 출력으로 허용된 문자라도 다른 iSCSI 이름 사이에서 혼동을 일으킬 수 있는 문자\(예: 구두점, 공백, 발음 구별 부호\)는 피해야 합니다. stringprep 프로세스는 또한 문자열을 해당하는 소문자 문자열로 변환합니다.

\[RFC3722\]에 지정된 stringprep 처리에 의해 출력으로 허용되는 문자만 사용하여 이름이 생성되는 경우 stringprep 프로세스를 구현할 필요가 없습니다. 허용되는 문자에는 모든 ASCII 소문자 및 숫자뿐만 아니라 \[RFC3722\]에 지정된 소문자 유니코드 문자도 포함됩니다. UTF-8로 인코딩된 iSCSI 이름이 이 섹션에 설명된 대로 "정규화"되면 바이트 단위로 안전하게 비교할 수 있습니다.

---
##### **4.2.7.3.  iSCSI Name Structure**

iSCSI 이름은 유형 지정자와 고유 이름 문자열의 두 부분으로 구성됩니다.

iSCSI는 전역적으로 고유한 iSCSI 이름을 구성할 때 세 가지 기존 명명 권한을 사용합니다. iSCSI 이름의 유형 지정자는 이름의 기반이 되는 명명 권한을 나타냅니다. 세 가지 iSCSI 이름 형식은 다음과 같습니다.

- a\) iSCSI 정규 이름: 도메인 이름을 기반으로 명명 기관을 식별합니다.

```text
      b) NAA format Name: based on a naming format defined by [FC-FS3]
         for constructing globally unique identifiers, referred to as
         the Network Address Authority (NAA)

      c) EUI format Name: based on EUI names, where the IEEE
         Registration Authority assists in the formation of worldwide
         unique names (EUI-64 format)
```

현재 정의된 해당 유형 지정자 문자열은 다음과 같습니다.

```text
      a) iqn. - iSCSI Qualified name
```

-b\) 아니. - 문자열의 나머지 부분은 ASCII로 인코딩된 16진수 형식의 INCITS T11 정의 네트워크 주소 기관 식별자입니다.

-c\) 에우이. - 문자열의 나머지 부분은 ASCII로 인코딩된 16진수 형식의 IEEE EUI-64 식별자입니다.

이 문서를 작성할 당시에는 이 세 가지 명명 권한 지정자로 충분하다고 간주되었습니다. iSCSI에 대한 추가 명명 유형 지정자의 생성은 IETF에서 고려될 수 있으며 별도의 RFC에 자세히 설명되어 있습니다.

다음 표에는 현재 SCSI 전송 프로토콜과 해당 이름 지정 형식이 요약되어 있습니다.

```text
        SCSI Transport Protocol       Naming Format
     +----------------------------+-------+-----+----+
     |                            | EUI-64| NAA |IQN |
     |----------------------------|-------|-----|----|
     | iSCSI (Internet SCSI)      |   X   |  X  | X  |
     |----------------------------|-------|-----|----|
     | FCP (Fibre Channel)        |       |  X  |    |
     |----------------------------|-------|-----|----|
     | SAS (Serial Attached SCSI) |       |  X  |    |
     +----------------------------+-------+-----+----+
```

---
##### **4.2.7.4.  Type "iqn." (iSCSI Qualified Name)**

이 iSCSI 이름 유형은 도메인 이름을 소유한 모든 조직에서 사용할 수 있습니다. 이 이름 지정 형식은 최종 사용자나 서비스 제공자가 대상 및/또는 개시자에 대해 iSCSI 이름을 할당하려는 경우 유용합니다.

이 유형의 이름을 생성하려면 이름을 생성하는 개인이나 조직이 등록된 도메인 이름을 소유해야 합니다. 이 도메인 이름은 주소로 확인될 필요가 없습니다. 다른 사람이 동일한 도메인 이름을 사용하여 iSCSI 이름을 생성하지 못하도록 예약하면 됩니다.

도메인 이름은 만료되거나, 다른 개체에 의해 획득되거나, 두 소유자 모두에 의해 iSCSI 이름을 생성하는 데 사용될 수 있으므로 도메인 이름은 명명 기관이 도메인 이름을 소유한 날짜까지 추가로 한정되어야 합니다. 날짜 코드는 "iqn"의 일부로 제공됩니다. 이런 이유로 형식을 지정합니다.

iSCSI 정규화된 이름 문자열은 다음으로 구성됩니다.

- - 이러한 이름을 "eui"와 구별하는 데 사용되는 문자열 "iqn." 형식화된 이름.

- - yyyy-mm 형식의 날짜 코드입니다. 이 날짜는 명명 기관이 이 형식에 사용된 도메인 이름을 소유한 날짜여야 하며 해당 달의 1일 00:01 GMT에 이 명명 기관이 도메인 이름을 소유한 첫 번째 달이어야 합니다. 이 날짜 코드는 그레고리력을 사용합니다. 연도의 네 자리 숫자가 모두 있어야 합니다. 1월 == "01" 및 12월 == "12"와 같이 월의 두 자리 숫자가 모두 있어야 합니다. 대시가 포함되어야 합니다.\(MUST\)

```text
      - A dot "."
```

- - 이 iSCSI 이름을 생성하는 명명 권한\(개인 또는 조직\)의 역방향 도메인 이름입니다.

- - 도메인 이름 소유자가 적절하다고 판단하는 문자 집합 및 길이 경계 내의 선택적인 콜론\(:\) 접두사 문자열입니다. 여기에는 제품 유형, 일련 번호, 호스트 식별자 또는 소프트웨어 키가 포함될 수 있습니다\(예: 조직 경계를 구분하는 콜론이 포함될 수 있음\). 콜론 접두사를 제외하고 도메인 이름 소유자는 역방향 도메인 이름 뒤의 모든 항목을 원하는 대로 할당할 수 있습니다. 할당한 iSCSI 이름이 전 세계적으로 고유한지 확인하는 것은 명명 권한을 가진 개체의 책임입니다. 예: "예제 Storage Arrays, Inc." 도메인 이름 "example.com"을 소유할 수 있습니다.

```text
   The following are examples of iSCSI qualified names that might be
   generated by "EXAMPLE Storage Arrays, Inc."

                    Naming     String defined by
      Type  Date     Auth      "example.com" naming authority
      +--++-----+ +---------+ +--------------------------------+
      | ||      | |         | |                                |

      iqn.2001-04.com.example:storage:diskarrays-sn-a8675309
      iqn.2001-04.com.example
      iqn.2001-04.com.example:storage.tape1.sys1.xyz
      iqn.2001-04.com.example:storage.disk2.sys1.xyz
```

---
##### **4.2.7.5.  Type "eui." (IEEE EUI-64 Format)**

IEEE 등록 기관은 EUI\(Globally Unique Identifier\)를 할당하는 서비스를 제공합니다. EUI-64 형식은 다른 네트워크 프로토콜에서 전역 식별자를 구축하는 데 사용됩니다. 예를 들어 파이버 채널은 이를 WorldWideName으로 인코딩하는 방법을 정의합니다. EUI 식별자 등록에 대한 자세한 내용은 \[OUI\]를 참조하세요.

형식은 "eui"입니다. 그 뒤에는 EUI-64 식별자\(ASCII로 인코딩된 16진수 16자리\)가 옵니다.

```text
      Example iSCSI name:

         Type   EUI-64 identifier (ASCII-encoded hexadecimal)
         +--++--------------+
         |  ||              |
         eui.02004567A425678D
```

IEEE EUI-64 iSCSI 이름 형식은 제조업체가 이미 IEEE 등록 기관에 등록되어 있고 해당 제품에 대해 EUI-64 형식의 전 세계 고유 이름을 사용하는 경우 사용될 수 있습니다.

이름 구성에 대한 더 많은 예는 \[RFC3721\]에서 논의됩니다.

---
##### **4.2.7.6.  Type "naa." (Network Address Authority)**

INCITS T11 프레이밍 및 신호 사양\[FC-FS3\]은 다양한 식별자 등록 기관을 사용하는 전 세계 고유 식별자를 구성하기 위한 NAA\(네트워크 주소 기관\) 형식이라는 형식을 정의합니다. 이 식별자 형식은 파이버 채널 및 SAS SCSI 전송 프로토콜에서 사용됩니다. FC와 SAS는 네트워크로 연결된 SCSI 포트의 상당 부분을 구성하므로 NAA 형식은 SCSI 전송에 널리 사용되는 형식입니다. NAA 형식 이름의 직접적인 표현을 지원하는 iSCSI의 목적은 다양한 전송에서 제공되는 포트가 포함된 SCSI 저장 장치에 대해 여러 네임스페이스에 걸쳐 쉽게 변환되는 대상 장치 이름의 구성을 용이하게 하는 것입니다. 보다 구체적으로, 이 형식을 사용하면 하나의 NAA 식별자를 SAS 포트와 iSCSI 포트가 모두 있는 SCSI 대상에 대한 SCSI 장치 이름의 기초로 할당할 수 있는 구현이 가능합니다.

iSCSI NAA 이름 지정 형식은 "naa."이며, 그 뒤에는 ASCII로 인코딩된 16진수 숫자로 표시되는 NAA 식별자가 옵니다.

64비트 NAA 값이 있는 iSCSI 이름의 예는 다음과 같습니다.

```text
      Type  NAA identifier (ASCII-encoded hexadecimal)
      +--++--------------+
      |  ||              |
      naa.52004567BA64678D
```

128비트 NAA 값을 갖는 iSCSI 이름의 예는 다음과 같습니다.

```text
      Type  NAA identifier (ASCII-encoded hexadecimal)
      +--++------------------------------+
      |  ||                              |
      naa.62004567BA64678D0123456789ABCDEF
```

장치에 SAS 및 iSCSI SCSI 포트가 모두 포함되어 있으므로 NAA 전 세계 고유 이름을 생성하기 위한 인프라가 이미 마련되어 있는 경우 iSCSI NAA 명명 형식을 구현에 사용할 수 있습니다.

ASCII-16진수 표현으로 형식화된 NAA 식별자의 최대 크기는 32자입니다\(128비트 NAA 형식\). 결과적으로 이 이름 지정 형식이 iSCSI 노드 이름의 최대 크기를 초과하는 문제는 없습니다.

---
#### **4.2.8.  Persistent State**

iSCSI는 세션 전반에 걸쳐 지속적인 상태 유지 관리가 필요하지 않습니다. 그러나 경우에 따라 SCSI에서는 SCSI 개시자 포트 이름의 지속적인 식별이 필요합니다\(섹션 4.4.2 및 4.4.3 참조\).

iSCSI 세션은 전원을 껐다 켜거나 부팅하는 동안 지속되지 않습니다.

모든 iSCSI 세션 및 연결 매개변수는 세션 및 연결 생성 시 다시 초기화됩니다.

세션이 지속되고 세션 내 명령 복구가 지원되는 경우 명령은 연결 종료 이후에도 지속됩니다. 그러나 연결이 끊어지면 "TASK REASSIGN" 작업 관리 기능에 의해 새로운 충성이 설정될 때까지 iSCSI에서 인식되는 명령 실행\(즉, 영향을 받는 작업에 대한 iSCSI 프로토콜 교환 포함\)이 일시 중지됩니다. 섹션 11.5를 참조하세요.

---
#### **4.2.9.  Message Synchronization and Steering**

iSCSI는 SCSI 프로토콜을 TCP에 매핑하는 것입니다. 이 캡슐화는 다양한 길이의 iSCSI PDU를 전송하여 수행됩니다. 불행하게도 TCP에는 TCP 계층에서 메시지 경계를 알리는 기본 제공 메커니즘이 없습니다. iSCSI는 메시지 길이를 iSCSI 메시지 헤더에 배치하여 이러한 장애물을 극복합니다. 이는 현재 메시지의 끝과 다음 메시지의 시작을 나타내는 역할을 합니다.

IP 패킷이 네트워크에서 순서대로 전달되는 상황에서는 iSCSI 메시지 프레이밍이 문제가 되지 않으며 메시지가 차례로 처리됩니다. IP 패킷 재정렬\(즉, 프레임 삭제\)이 있는 경우 레거시 TCP 구현은 누락된 TCP 세그먼트가 도착할 때까지 "순서가 잘못된" TCP 세그먼트를 임시 버퍼에 저장합니다. 이때 데이터는 애플리케이션 버퍼에 복사되어야 합니다. iSCSI에서는 이러한 순서가 잘못된 TCP 세그먼트 내의 SCSI 데이터를 임시 버퍼에 저장하는 대신 사전 할당된 SCSI 버퍼로 이동하는 것이 바람직합니다. 이를 통해 전용 리어셈블리 버퍼의 필요성은 물론 추가 복사본과 관련된 대기 시간 및 대역폭도 줄어듭니다.

iSCSI 메시지 헤더의 "메시지 길이" 정보에만 의존하면 iSCSI 메시지 길이가 포함된 TCP 세그먼트의 손실로 인해 후속 TCP 세그먼트에서 iSCSI 메시지 경계를 찾는 것이 불가능해질 수 있습니다. 다음 세그먼트 중 하나가 올바른 SCSI 버퍼로 조정되기 전에 누락된 TCP 세그먼트를 수신해야 합니다\(iSCSI 메시지 경계를 결정할 수 없기 때문에\). 이러한 세그먼트는 올바른 위치로 조정될 수 없으므로 임시 버퍼에 저장한 다음 SCSI 버퍼에 복사해야 합니다.

동기화를 복구하기 위해 다양한 구성표를 사용할 수 있습니다. 이러한 체계의 세부 사항은 이 프로토콜 사양을 벗어나지만 \[RFC4297\]은 IP 네트워크의 직접 데이터 배치 문제에 대한 개요를 제공하고 \[RFC5046\]은 이러한 직접 데이터 배치를 용이하게 하는 iSCSI에 대한 프로토콜 확장을 지정한다는 점만 알아두면 충분합니다. 목적. 이 문서의 나머지 부분에서는 "동기화 및 조정 계층"의 예로 이러한 직접 데이터 배치 프로토콜 사용을 참조합니다.

정상적인 상황\(PDU 손실 또는 잘못된 데이터 수신 없음\)에서는 TCP 헤더의 TCP 시퀀스 번호 외에 iSCSI 헤더의 식별 태그와 데이터 오프셋 필드를 사용하여 iSCSI 데이터 조정을 수행할 수 있습니다. 식별 태그는 PDU를 SCSI 버퍼 주소와 연결하는 데 도움이 되며, 데이터 오프셋과 TCP 시퀀스 번호는 버퍼 내의 오프셋을 결정하는 데 사용됩니다.

---
##### **4.2.9.1.  Sync/Steering and iSCSI PDU Length**

큰 iSCSI 메시지가 전송되면 iSCSI 헤더가 포함된 TCP 세그먼트가 손실될 수 있습니다. 다음 iSCSI 메시지까지 나머지 TCP 세그먼트는 데이터가 조정될 SCSI 버퍼를 나타내는 iSCSI 헤더가 손실되었기 때문에 임시 버퍼에 버퍼링되어야 합니다. 버퍼링 양을 최소화하려면 iSCSI PDU 길이를 작은 값\(대개 몇 개의 TCP 세그먼트 길이\)으로 제한하는 것이 좋습니다. 로그인하는 동안 iSCSI 세션의 각 끝은 허용되는 최대 iSCSI PDU 길이를 지정합니다.

---
### **4.3.  iSCSI Session Types**

iSCSI는 두 가지 유형의 세션을 정의합니다.

- a\) 일반 운영 세션 - 무제한 세션.

- b\) 탐색 세션 - 대상 탐색을 위해서만 열리는 세션입니다. 대상은 SendTargets 키가 있는 텍스트 요청과 "세션 닫기"라는 이유가 있는 로그아웃 요청만 수락해야 합니다. 다른 모든 요청은 반드시 거부되어야 합니다.\(MUST, MUST\)

세션 유형은 로그인 명령의 SessionType=value 매개변수를 사용하여 로그인하는 동안 정의됩니다.

---
### **4.4.  SCSI-to-iSCSI Concepts Mapping Model**

다음 다이어그램은 여러 iSCSI 노드\(이 경우 대상\)가 동일한 네트워크 엔터티 내에 공존하고 네트워크 포털\(IP 주소 및 TCP 포트\)을 공유할 수 있는 방법의 예를 보여줍니다. 다른 더 복잡한 구성도 가능합니다. 이 다이어그램의 구성 요소에 대한 자세한 설명은 섹션 4.4.1을 참조하세요.

```text
                 +-----------------------------------+
                 | Network Entity (iSCSI Client)     |
                 |                                   |
                 |          +-------------+          |
                 |          | iSCSI Node  |          |
                 |          | (Initiator) |          |
                 |          +-------------+          |
                 |              |      |             |
                 | +--------------+ +--------------+ |
                 | |Network Portal| |Network Portal| |
                 | |   192.0.2.4  | |   192.0.2.5  | |
                 +-+--------------+-+--------------+-+
                          |                  |
                          |   IP Networks    |
                          |                  |
                 +-+--------------+-+--------------+-+
                 | |Network Portal| |Network Portal| |
                 | |198.51.100.21 | |198.51.100.3  | |
                 | | TCP Port 3260| | TCP Port 3260| |
                 | +--------------+ +--------------+ |
                 |        |                  |       |
                 |         ------------------        |
                 |            |          |           |
                 | +-------------+ +--------------+  |
                 | | iSCSI Node  | | iSCSI Node   |  |
                 | | (Target)    | | (Target)     |  |
                 | +-------------+ +--------------+  |
                 |                                   |
                 |   Network Entity (iSCSI Server)   |
                 +-----------------------------------+
```

---
#### **4.4.1.  iSCSI Architecture Model**

이 섹션에서는 iSCSI와 SCSI 아키텍처 모델 간의 관계에 가장 큰 영향을 미치는 iSCSI 아키텍처 모델의 일부를 설명합니다.

- 네트워크 엔터티 - 장치 또는 게이트웨이를 나타냅니다.

- IP 네트워크에서 접근 가능합니다. 네트워크 엔터티에는 하나 이상의 네트워크 포털\(아래 "네트워크 포털" 항목 참조\)이 있어야 하며, 각 포털은 해당 네트워크 엔터티에 포함된 일부 iSCSI 노드\(다음 항목 참조\)에서 IP 네트워크에 액세스하는 데 사용될 수 있습니다.

- - iSCSI 노드 - 단일 iSCSI 초기자, iSCSI 대상 또는 각각의 인스턴스를 나타냅니다. 네트워크 엔터티 내에 하나 이상의 iSCSI 노드가 있습니다. iSCSI 노드는 하나 이상의 네트워크 포털을 통해 액세스할 수 있습니다\(아래 참조\). iSCSI 노드는 iSCSI 이름으로 식별됩니다\(섹션 4.2.7 및 13 참조\). iSCSI 이름과 iSCSI 노드에 사용되는 주소를 분리하면 여러 iSCSI 노드가 동일한 주소를 사용할 수 있고 동일한 iSCSI 노드가 여러 주소를 사용할 수 있습니다.

- - 별칭 문자열이 iSCSI 노드와 연결될 수도 있습니다. 별칭을 사용하면 조직에서 사용자에게 친숙한 문자열을 iSCSI 이름과 연결할 수 있습니다. 그러나 별칭 문자열은 iSCSI 이름을 대체하지 않습니다.

- - 네트워크 포털 - TCP/IP 네트워크 주소가 있고 해당 네트워크 엔터티 내의 iSCSI 노드가 iSCSI 세션 중 하나 내 연결을 위해 사용할 수 있는 네트워크 엔터티의 구성 요소입니다. 개시자에서는 IP 주소로 식별됩니다. 대상에서는 IP 주소와 수신 TCP 포트로 식별됩니다.

- - 포털 그룹 - iSCSI는 동일한 세션 내에서 다중 연결을 지원합니다. 일부 구현에는 여러 네트워크 포털의 세션에서 연결을 결합하는 기능이 있습니다. 포털 그룹은 이러한 포털에 걸쳐 있는 연결을 사용하여 세션을 조정하는 기능을 집합적으로 지원하는 iSCSI 노드 내의 네트워크 포털 집합을 정의합니다. 포털 그룹 내의 모든 네트워크 포털이 해당 포털 그룹을 통해 연결된 모든 세션에 참여할 필요는 없습니다. 하나 이상의 포털 그룹이 iSCSI 노드에 대한 액세스를 제공할 수 있습니다. 지정된 iSCSI 노드에서 활용되는 각 네트워크 포털은 해당 노드 내의 정확히 하나의 포털 그룹에 속합니다. 포털 그룹은 iSCSI 노드 내에서 0\~65535 사이의 부호 없는 단순 정수인 포털 그룹 태그로 식별됩니다\(참조:

- 섹션 13.9\). 지정된 iSCSI 노드의 컨텍스트에서 동일한 포털 그룹 태그를 가진 모든 네트워크 포털은 동일한 포털 그룹에 있습니다.

- iSCSI 개시자와 iSCSI 대상 모두 포털 그룹을 갖고 있지만 iSCSI 대상 포털 그룹만 iSCSI 프로토콜\(예: SendTargets\)에서 직접 사용됩니다. 개시자 포털 그룹에 대한 참조는 섹션 10.1.2를 참조하십시오.

- - 포털 그룹 내의 포털은 공통 세션에 참여할 수 있으므로 유사한 세션 매개변수를 지원해야 합니다.

다음 다이어그램은 대상에 대한 이러한 구성 중 하나의 예와 포털 그룹 내에서 네트워크 포털을 공유하는 세션이 설정될 수 있는 방법을 보여줍니다.

```text
       ----------------------------IP Network---------------------
              |                |                  |
         +----|----------------|----+        +----|---------+
         | +---------+ +---------+  |        | +---------+  |
         | | Network | | Network |  |        | | Network |  |
         | | Portal  | | Portal  |  |        | | Portal  |  |
         | +---------+ +---------+  |        | +---------+  |
         |    |                |    |        |    |         |
         |    |    Portal      |    |        |    | Portal  |
         |    |    Group 1     |    |        |    | Group 2 |
         +--------------------------+        +--------------+
              |                |                  |
     +--------|----------------|------------------|------------------+
     |        |                |                  |                  |
     | +----------------------------+ +----------------------------+ |
     | | iSCSI Session (Target side)| | iSCSI Session (Target side)| |
     | |                            | |                            | |
     | |        (TSIH = 56)         | |        (TSIH = 48)         | |
     | +----------------------------+ +----------------------------+ |
     |                                                               |
     |                      iSCSI Target Node                        |
     |             (within Network Entity, not shown)                |
     +---------------------------------------------------------------+
```

---
#### **4.4.2.  SCSI Architecture Model**

이 섹션에서는 SCSI 아키텍처 모델\[SAM2\]과 SCSI 장치 구성, SCSI 포트 및 I\_T 넥서스, 그리고 섹션 4.4.1에 설명된 iSCSI 구성 사이의 관계를 설명합니다.

이 관계는 SAM-2 모델 및 기타 SCSI 작동 기능을 준수하기 위한 구현 요구 사항을 의미합니다.

이러한 요구 사항은 섹션 4.4.3에 자세히 설명되어 있습니다.

다음 목록에서는 SCSI 아키텍처 요소를 iSCSI에 매핑하는 방법을 간략하게 설명합니다.

- a\) SCSI 장치 - 이는 서비스 제공 하위 시스템에 연결되고 SCSI 애플리케이션 프로토콜을 지원하는 하나 이상의 SCSI 포트를 포함하는 엔터티에 대한 SAM-2 용어입니다. 예를 들어, SCSI 개시자 장치에는 하나 이상의 SCSI 개시자 포트와 0개 이상의 애플리케이션 클라이언트가 포함되어 있습니다. SCSI 대상 장치에는 하나 이상의 SCSI 대상 포트와 하나 이상의 LU가 포함되어 있습니다. iSCSI의 경우 SCSI 장치는 SCSI 기능을 제공하는 iSCSI 노드 내의 구성 요소입니다. 따라서 iSCSI 노드 내에는 최대 하나의 SCSI 장치가 있을 수 있습니다. SCSI 장치에 대한 액세스는 iSCSI 일반 작동 세션에서만 가능합니다\(섹션 4.3 참조\). SCSI 장치 이름은 노드의 iSCSI 이름으로 정의되며 iSCSI 프로토콜에서 사용해야 합니다.\(MUST\)

- b\) SCSI 포트 - 이는 서비스 전달 하위 시스템 또는 전송과 인터페이스하기 위해 SCSI 기능을 제공하는 SCSI 장치의 엔터티에 대한 SAM-2 용어입니다. iSCSI의 경우 SCSI 개시자 포트와 SCSI 대상 포트의 정의가 다릅니다.

- SCSI 개시자 포트: 이는 iSCSI 일반 작동 세션의 한 끝점에 매핑됩니다\(섹션 4.3 참조\). iSCSI 일반 작동 세션은 iSCSI 개시자 노드와 iSCSI 대상 노드 간의 로그인 프로세스를 통해 협상됩니다. 이 프로세스가 성공적으로 완료되면 SCSI 개시 장치 내에 SCSI 개시 장치 포트가 생성됩니다. SCSI 개시자 포트 이름 및 SCSI 개시자 포트 식별자는 모두 \(a\) 개시자 포트 이름/식별자로 식별하는 레이블 및 \(b\) 세션 식별자의 ISID 부분과 함께 iSCSI 개시자 이름으로 정의됩니다.

- SCSI 대상 포트: 이는 iSCSI 대상 포털 그룹에 매핑됩니다. SCSI 대상 포트 이름과 SCSI 대상 포트 식별자는 모두 \(a\) 대상 포트 이름/식별자로 식별하는 레이블 및 \(b\) 대상 포털 그룹 태그와 함께 iSCSI 대상 이름으로 정의됩니다.

- SCSI 포트 이름은 iSCSI에서 사용해야 합니다. SCSI 매개변수 데이터에 사용되는 경우 SCSI 포트 이름은 다음과 같이 인코딩되어야 합니다.\(MUST, MUST\)

- 1\) UTF-8 형식의 iSCSI 이름과 그 뒤에 오는 이름

- 2\) 쉼표 구분 기호\(1바이트\), 그 뒤에

- 3\) ASCII 문자 'i'\(SCSI 개시자 포트용\) 또는 ASCII 문자 't'\(SCSI 대상 포트용\)\(1바이트\), 그 뒤에

- 4\) 쉼표 구분 기호\(1바이트\), 그 뒤에

- 5\) 초기 0X 또는 0x 및 종료 null\(15\)을 포함하여 ISID\(SCSI 개시자 포트의 경우\) 또는 대상 포털 그룹 태그\(SCSI 대상 포트의 경우\)의 16진수 상수\(섹션 6.1 참조\)로 텍스트 인코딩 iSCSI 개시자 포트의 경우 바이트, iSCSI 대상 포트의 경우 7바이트\).

- ASCII 문자 'i' 또는 't'는 이 포트를 SCSI 개시자 포트 또는 SCSI 대상 포트로 식별하는 레이블입니다.

- c\) I\_T 넥서스 - \[SAM2\]에 따라 SCSI 개시자 포트와 SCSI 대상 포트 간의 관계를 나타냅니다. iSCSI의 경우 이 관계는 iSCSI 개시자의 세션 끝\(SCSI 개시자 포트\)과 iSCSI 대상의 포털 그룹 간의 관계로 정의되는 세션입니다. I\_T 넥서스는 SCSI 포트 이름의 조합이나 iSCSI 세션 식별자\(SSID\)로 식별할 수 있습니다. iSCSI는 I\_T 넥서스 식별자를 튜플\(iSCSI 초기자 이름 + ",i,0x" + 텍스트 형식의 ISID, iSCSI 대상 이름 + ",t,0x" + 텍스트 형식의 대상 포털 그룹 태그\)로 정의합니다. "0x" 대신 대문자 16진수 접두사 "0X"를 사용할 수도 있습니다.

- 참고: I\_T 넥서스 식별자는 SSID와 동일하지 않습니다.

---
#### **4.4.3.  Consequences of the Model**

이 섹션에서는 위에 정의된 iSCSI 구성에 대한 SCSI 구성 매핑의 결과로 발생하는 구현 및 동작 요구 사항에 대해 설명합니다. 지정된 SCSI 개시자 포트와 지정된 SCSI 대상 포트 사이에는 하나의 I\_T 넥서스\(세션\)만 존재할 수 있습니다. \[SAM2\]에서는 하나 이상의 넥서스 관계\(병렬 넥서스\)를 허용하지 않습니다. 따라서 특정 시간에 특정 iSCSI 개시자 노드와 iSCSI 대상 노드 사이에는 동일한 SSID를 가진 하나의 세션만 존재할 수 있습니다.

이러한 가정은 다음과 같은 결론과 요구 사항으로 이어집니다.

ISID 규칙: 지정된 iSCSI 개시자와 iSCSI 대상 포털 그룹\(SCSI 대상 포트\) 사이에는 SCSI 개시자 포트를 식별하는 ISID에 대해 지정된 값을 가진 세션이 하나만 있을 수 있습니다. 섹션 11.12.5를 참조하십시오.

명명 권한 구성 요소\(섹션 11.12.5 및 \[RFC3721\] 참조\)를 포함하는 ISID의 구조는 ISID RULE 준수를 용이하게 하는 메커니즘을 제공합니다. 섹션 10.1.1을 참조하십시오.

iSCSI 개시자 노드는 세션이 시작되기 전에 ISID 할당을 관리해야 합니다. "ISID 규칙"은 동일한 iSCSI 대상 또는 다른 iSCSI 대상의 다른 대상 포털 그룹과 동일한 iSCSI 개시자의 동일한 ISID 사용을 배제하지 않습니다\(섹션 10.1.1 참조\). 이를 허용하는 것은 동일한 SCSI 대상 장치의 여러 SCSI 대상 포트 또는 다른 SCSI 대상 장치의 SCSI 대상 포트와 관계\(넥서스\)를 갖는 단일 SCSI 개시자 포트와 유사합니다. 동일한 대상 포털 그룹에 대해 서로 다른 ISID를 사용하는 여러 세션을 가질 수도 있습니다. 이러한 각 세션은 세션이 동일한 개시자 장치에서 시작된 경우에도 다른 개시자와 함께 있는 것으로 간주됩니다. SCSI 개시자 포트를 식별하는 ISID와 함께 iSCSI 이름이기 때문에 동일한 ISID가 다른 iSCSI 개시자에 의해 사용될 수 있습니다.

참고: ISID 규칙과 I\_T 넥서스 식별자에 대한 사양의 결과는 동일한 식별자를 가진 두 개의 넥서스가 동시에 존재해서는 안 된다는 것입니다.

TSIH 규칙: iSCSI 대상은 세션 생성 시 TSIH에 대해 0이 아닌 값을 선택합니다\(개시자가 로그인 시 0 값을 제공하는 경우\). 선택된 후에는 개시자 또는 대상이 세션을 참조하고 TSIH가 필요할 때마다 동일한 TSIH 값을 사용해야 합니다.\(MUST\)

---
##### **4.4.3.1.  I_T Nexus State**

특정 넥서스 관계에는 iSCSI 계층의 변경 또는 오류\(예: 세션 오류\)를 통해 LU의 장치 서버\[SAM2\]에서 보존해야 할 수 있는 명시적 상태\(예: 개시자별 모드 페이지\)가 포함되어 있습니다. 해당 상태를 복원하려면 iSCSI 초기자가 이전 ISID를 사용하여 동일한 대상 포털 그룹에 대한 세션을 다시 설정\(다시 로그인\)해야 합니다. 즉, iSCSI 세션 복원\(섹션 6.3.5\)을 통해 세션을 복원하거나 세션 연속\(섹션 6.3.6\)을 통해 계속해야 합니다. 이는 SCSI 개시자 포트 식별자와 SCSI 대상 포트 식별자\(또는 상대 대상 포트\)가 SCSI LU 장치 서버가 I\_T 연계를 식별하는 데 사용하는 데이터를 형성하기 때문입니다.

---
##### **4.4.3.2.  Reservations**

SCSI 표준에는 두 가지 예약 관리 방법이 정의되어 있습니다. RESERVE 및 RELEASE 명령\[SPC2\]을 기반으로 하는 예약/해제 예약; PERSISTENT RESERVE IN 및 PERSISTENT RESERVE OUT 명령 \[SPC3\]을 기반으로 한 영구 예약. 예약/해제 예약은 더 이상 사용되지 않으며\[SPC3\] 사용해서는 안 됩니다. 대안으로 지속적인 예약이 제안됩니다. \[SPC4\]의 부록 B를 참조하십시오.

I\_T 넥서스 오류를 초래하는 iSCSI 계층의 변경 및 오류에도 지속하려면 영구 예약 상태가 필요합니다. 자세한 내용과 특정 요구 사항은 \[SPC3\]을 참조하세요.

대조적으로, \[SPC2\]는 I\_T 넥서스 실패 후 예약/해제 예약 상태에 대한 자세한 지속성 요구 사항을 지정하지 않습니다. 그럼에도 불구하고, iSCSI 대상이 예약/해제 예약을 지원하는 경우 선호되는 구현 접근 방식은 iSCSI 세션 복원\(섹션 6.3.5 참조\) 또는 세션 지속\(섹션 6.3.6 참조\)을 위해 예약/해제 예약 상태를 보존하는 것입니다.

예약/해제 예약에는 두 가지 추가 주의 사항이 적용됩니다.

- - 실패한 iSCSI 세션이 복원되거나 계속되지 않은 후에도 iSCSI 대상이 실패한 세션의 예약/해제 예약 상태를 유지하려면 개시자가 재설정\(예: 논리 장치 재설정, 섹션 11.5 참조\)을 실행해야 할 수도 있습니다. 해당 예약 상태를 제거합니다.

- - 동일한 LU에서 영구 예약도 사용되는 경우 예약/해제 예약이 예상대로 작동하지 않을 수 있습니다. \[SPC4\]의 "SPC-2 RESERVE 및 RELEASE 동작에 대한 예외"에 대한 설명을 참조하세요.

---
### **4.5.  iSCSI UML Model**

이 섹션에서는 섹션 3에서 설명한 UML 모델링 개념을 섹션 4.4에서 설명한 iSCSI 및 SCSI 아키텍처 모델에 적용하는 방법을 제시합니다.

```text
                       +----------------+
                       | Network Entity |
                       +----------------+
                            @ 1     @ 1
                            |       |
     +----------------------+       |
     |                              |
     |                              | 0..*
     |                   +------------------+
     |                   | iSCSI Node       |
     |                   +------------------+
     |                       @       @
     |                       |       |
     |           +-----------+ =(a)= +-----------+
     |           |                               |
     |           | 0..1                          | 0..1
     | +------------------------+       +----------------------+
     | |    iSCSI Target Node   |       | iSCSI Initiator Node |
     | +------------------------+       +----------------------+
     |             @ 1                            @ 1
     |             +---------------+              |
     |                        1..* |              | 1..*
     |                    +-----------------------------+
     |                    |         Portal Group        |
     |                    +-----------------------------+
     |                                     O 1
     |                                     |
     |                                     | 1..*
     |               1..* +------------------------+
     +--------------------|        Network Portal  |
                          +------------------------+
```

\(a\) iSCSI 노드 클래스의 각 인스턴스는 하나의 iSCSI 대상 노드 인스턴스, 하나의 iSCSI 개시자 노드 인스턴스 또는 둘 다를 포함해야 합니다.\(MUST\)

```text
                    +----------------+
                    | Network Entity |
                    +----------------+
                         @ 1         @ 1
                         |           |              +------------------+
   +---------------------+           |              |   iSCSI Session  |
   |                                 |              +------------------+
   |                                 | 0..*         |     SSID[1]      |
   |                  +--------------------+        |     ISID[1]      |
   |                  |      iSCSI Node    |        +------------------+
   |                  +--------------------+                   @ 1
   |                  | iSCSI Node Name[1] |                   |
   |                  |    Alias [0..1]    |                   | 0..*
   |                  +--------------------+        +------------------+
   |                  |                    |        | iSCSI Connection |
   |                  +--------------------+        +------------------+
   |                         @ 1         @ 1        |      CID[1]      |
   |                         |           |          +------------------+
   |           +-------------+ ==(b)==   +---------+              0..* |
   |           | 1                                 | 1                 |
   | +------------------------+             +------------------------+ |
   | |   iSCSI Target Node    |             | iSCSI Initiator Node   | |
   | +------------------------+             +------------------------+ |
   | | iSCSI Target Name [1]  |             |iSCSI Initiator Name [1]| |
   | +------------------------+             +------------------------+ |
   |            @ 1                                    @ 1             |
   |            | 1..*                                 | 1..*          |
   | +--------------------------+           +------------------------+ |
   | |   Target Portal Group    |           | Initiator Portal Group | |
   | +--------------------------+           +------------------------+ |
   | |Target Portal Group Tag[1]|           | Portal Group Tag[1]    | |
   | +--------------------------+           +------------------------+ |
   |            o 1                                    o 1             |
   |            +------------+              +----------+               |
   |                    1..* |              | 1..*                     |
   |                +-------------------------+                        |
   |                |          Network Portal |                        |
   |                +-------------------------+                        |
   |          1..*  |         IP Address [1]  | 1                      |
   +----------------|         TCP Port [0..1] |<-----------------------+
                    +-------------------------+
```

\(b\) iSCSI 노드 클래스의 각 인스턴스는 하나의 iSCSI 대상 노드 인스턴스, 하나의 iSCSI 개시자 노드 인스턴스 또는 둘 다를 포함해야 합니다. 그러나 모든 시나리오에서 iSCSI 노드에는 단일 iSCSI 이름만 있어야 합니다. 섹션 4.2.7.1의 관련 요구 사항에 유의하십시오.\(MUST, MUST\)

---
### **4.6.  Request/Response Summary**

이 섹션에서는 모든 iSCSI PDU 유형\(요청 및 응답\)을 나열하고 간략하게 설명합니다.

모든 iSCSI PDU는 하나 이상의 헤더 세그먼트\(기본 및 보조\)와 0개 또는 1개의 데이터 세그먼트 세트로 구성됩니다. 헤더 그룹과 데이터 세그먼트 뒤에는 각각 CRC\(다이제스트\)가 올 수 있습니다.

기본 헤더 세그먼트의 길이는 48바이트로 고정되어 있습니다.

---
#### **4.6.1.  Request/Response Types Carrying SCSI Payload**
---
##### **4.6.1.1.  SCSI Command**

이 요청은 SCSI CDB 및 작업 속성, 하나 또는 두 전송 방향에 대한 예상 데이터 전송 길이\(양방향 명령의 경우 후자\) 및 작업 태그\(예: I\_T\_L\_x 넥서스의 일부\). I\_T\_L 넥서스는 요청의 LUN 필드에서 개시자와 대상에 의해 파생되며 I\_T 넥서스는 세션 식별에 내재되어 있습니다.

또한 SCSI 명령 PDU는 iSCSI 프로토콜의 올바른 작동에 필요한 정보\(명령 시퀀스 번호\(CmdSN\) 및 실행된 연결에 대한 예상 상태 시퀀스 번호\(ExpStatSN\)\)를 전달합니다.

SCSI 명령과 관련된 SCSI 출력\(쓰기\) 데이터의 전부 또는 일부는 데이터 세그먼트로서 SCSI 명령 PDU의 일부로 전송될 수 있습니다.

---
##### **4.6.1.2.  SCSI Response**

SCSI 응답은 모든 SCSI 실행 명령 프로시저 호출\(\[SAM2\] 참조\) OUT 인수와 SCSI 실행 명령 프로시저 호출 반환 값을 전달합니다.

SCSI 응답에는 작업의 잔여 수가 포함됩니다\(있는 경우\). 카운트가 오버플로 또는 언더플로를 나타내는지 여부를 나타냅니다. 상태가 유효한 경우 SCSI 상태, 상태가 유효하지 않은 경우 응답 코드\(명령 실행 프로시저 호출에 대한 0이 아닌 반환 값\)입니다.

명령이 처리되었지만 예외\(예: SCSI CHECK CONDITION\)가 발생했음을 나타내는 유효한 상태의 경우 PDU 데이터 세그먼트에는 관련 감지 데이터가 포함됩니다. iSCSI에서는 자동 감지\(\[SAM2\]\)를 사용해야 합니다.\(MUST\)

일부 데이터 세그먼트 콘텐츠는 \(데이터 세그먼트에서\) 0이 아닌 응답 코드와 연관될 수도 있습니다.

또한 SCSI 응답 PDU는 iSCSI 프로토콜의 올바른 작동에 필요한 정보를 전달합니다.

```text
      - ExpDataSN - the number of Data-In PDUs that a target has sent
        (to enable the initiator to check that all have arrived)
```

- - StatSN - 이 연결의 상태 시퀀스 번호

- - ExpCmdSN - 대상에서 다음으로 예상되는 명령 시퀀스 번호

- - MaxCmdSN - 이 개시자의 대상에서 허용되는 최대 CmdSN

---
##### **4.6.1.3.  Task Management Function Request**

작업 관리 기능 요청은 개시자에게 하나 이상의 SCSI 작업 또는 iSCSI 기능의 실행을 명시적으로 제어하는 ​​방법을 제공합니다. PDU는 기능 식별자\(즉, 수행할 작업 관리 기능\)와 작업을 수행할 작업이 아직 도착하지 않았거나 도착하지 않았더라도 작업을 수행할 작업 세트를 명확하게 식별할 수 있는 충분한 정보를 전달합니다. 오류로 인해 삭제되었습니다.

함수가 개별 작업을 참조하는 경우 참조된 태그는 개별 작업을 식별합니다.

I\_T\_L 넥서스는 작업 세트를 식별합니다. iSCSI에서 I\_T\_L 넥서스는 LUN과 세션 식별로 식별됩니다\(세션은 I\_T 넥서스를 식별함\).

작업 세트의 경우 작업 관리 기능 요청의 CmdSN은 수행할 작업, 즉 LUN과 연결되어 있고 작업 관리 기능 요청 CmdSN 앞에 CmdSN이 있는 모든 작업을 식별하는 데 도움이 됩니다.

작업 관리 기능의 경우 영향을 받는 작업에 대한 응답과 작업 관리 기능 응답 간의 조정은 대상에 의해 수행됩니다.

---
##### **4.6.1.4.  Task Management Function Response**

작업 관리 기능 응답은 완료 방법\(응답 및 한정자\)과 실패 응답에 대한 추가 정보를 포함하여 작업 관리 기능 요청에 대한 기능 완료 표시를 전달합니다.

작업 관리 기능 응답이 작업 관리 기능 완료를 표시한 후 개시자는 영향을 받은 작업으로부터 추가 응답을 받지 않습니다.

---
##### **4.6.1.5.  SCSI Data-Out and SCSI Data-In**

SCSI 데이터 출력 및 SCSI 데이터 입력은 개시자와 대상 사이에서 SCSI 데이터 페이로드를 전달하는 주요 수단입니다. 데이터 페이로드는 개시자 작업 태그를 통해 특정 SCSI 명령과 연결됩니다. 대상의 편의를 위해 나가는 요청 데이터에는 대상 전송 태그\(R2T에서 복사됨\)와 LUN도 포함됩니다. 각 PDU에는 페이로드 길이와 SCSI 실행 명령 프로시저 호출에 포함된 버퍼 주소에 상대적인 데이터 오프셋이 포함되어 있습니다.

각 방향에서 데이터 전송은 "시퀀스"로 분할됩니다. 시퀀스의 끝은 F 비트로 표시됩니다.

나가는 시퀀스는 요청되지 않거나\(첫 번째 시퀀스만 요청되지 않음\) R2T에 대한 응답으로 전송된 모든 데이터 출력 PDU로 구성됩니다.

입력 순서를 통해 필요에 따라 양방향 명령의 방향을 전환할 수 있습니다.

입력의 경우 대상은 입력 데이터에 대한 긍정적인 승인을 요청할 수 있습니다. 이는 오류 복구를 지원하는 세션으로 제한되며 SCSI Data-In PDU 헤더의 A 비트를 통해 구현됩니다.

데이터 입력 및 데이터 출력 PDU에는 개시자와 대상이 누락된 PDU\(오류로 인해 폐기됨\)를 감지할 수 있도록 DataSN도 포함됩니다.

또한 StatSN은 Data-In PDU에 의해 전달됩니다.

최소한의 메시지 수를 포함하면서 SCSI 명령을 처리할 수 있도록 하기 위해 상태가 예외 없이 종료를 나타내는 경우\(감지 또는 응답 관련 없음\) 명령에 대해 전달된 마지막 SCSI 데이터 입력 PDU에도 상태가 포함될 수 있습니다.

---
##### **4.6.1.6.  Ready To Transfer (R2T)**

R2T는 SCSI 대상이 개시자에게 출력 데이터를 "요청"하는 메커니즘입니다. R2T는 실행 명령 프로시저 호출의 버퍼 주소와 요청된 데이터의 길이를 기준으로 요청된 데이터의 오프셋을 개시자에게 지정합니다.

SCSI 대상이 결과 Data-Out을 R2T와 연결하는 데 도움을 주기 위해 R2T는 요청된 SCSI Data-Out PDU의 개시자가 복사할 대상 전송 태그를 전달합니다. 이러한 태그 값과 관련된 프로토콜별 요구 사항은 없지만 LUN과 함께 대상이 데이터를 R2T와 연결할 수 있다고 가정합니다.

R2T는 또한 다음과 같이 iSCSI 프로토콜의 올바른 작동에 필요한 정보를 전달합니다.

```text
      - R2TSN (to enable an initiator to detect a missing R2T)

      - StatSN

      - ExpCmdSN

      - MaxCmdSN
```

---
#### **4.6.2.  Requests/Responses Carrying SCSI and iSCSI Payload**
---
##### **4.6.2.1.  Asynchronous Message**

비동기 메시지 PDU는 SCSI 비동기 이벤트 알림\(AEN\) 및 iSCSI 비동기 메시지를 전달하는 데 사용됩니다.

AEN을 운반할 때 이벤트 세부 정보는 데이터 세그먼트에 감지 데이터로 보고됩니다.

---
#### **4.6.3.  Requests/Responses Carrying iSCSI-Only Payload**
---
##### **4.6.3.1.  Text Requests and Text Responses**

텍스트 요청 및 응답은 매개변수 협상 수단 및 향후 확장을 위한 수단으로 설계되었습니다.

데이터 세그먼트에서 텍스트 요청/응답은 간단한 "키=값" 구문을 사용하여 텍스트 정보를 전달합니다.

텍스트 요청/응답은 동일한 개시자 작업 태그를 사용하여 확장된 시퀀스를 형성할 수 있습니다. 개시자는 텍스트 요청 헤더의 F\(최종\) 플래그 비트를 사용하여 시퀀스를 종료할 준비가 되었음을 나타냅니다. 대상은 텍스트 응답 헤더의 F 비트를 사용하여 시퀀스 종료에 대한 동의를 나타냅니다.

텍스트 요청 및 응답은 또한 대상 전송 태그를 사용하여 작업의 계속 또는 새로운 시작을 나타냅니다. 작업을 계속하려는 대상은 텍스트 응답의 대상 전송 태그를 기본값 0xffffffff와 다른 값으로 설정합니다. 계속하려는 개시자는 이 값을 다음 텍스트 요청의 대상 전송 태그에 복사합니다. 개시자가 현재 대상 협상을 다시 시작\(새로 시작\)하려는 경우 대상 전송 태그를 0xffffffff로 설정합니다.

완전한 교환은 항상 개시자에 의해 시작되지만 특정 매개변수 협상은 개시자 또는 대상에 의해 개시될 수 있습니다.

---
##### **4.6.3.2.  Login Requests and Login Responses**

로그인 요청 및 응답은 세션 및 연결 매개변수를 설정하기 위해 각 연결의 로그인 단계 중에 독점적으로 사용됩니다. \(로그인 단계는 동일한 초기자 작업 태그를 전달하는 일련의 로그인 요청 및 응답으로 구성됩니다.\)

연결은 세션 내에서 고유하고 임의로 선택된 연결 ID\(CID\)로 식별됩니다.

텍스트 요청 및 응답과 마찬가지로 로그인 요청/응답은 데이터 세그먼트에 간단한 구문을 사용하여 키=값 텍스트 정보를 전달합니다.

로그인 단계는 헤더에 두 개의 이진 코드 필드\(현재 단계\(CSG\) 및 다음 단계\(NSG\)\)를 사용하여 선택되는 여러 단계\(보안 협상, 운영 매개 변수 협상\)를 통해 진행됩니다. "Transit" 플래그\(T\)로 표시됩니다.

세션의 첫 번째 로그인 단계는 일부 헤더 필드\(예: 버전 번호, 최대 연결 수 및 세션 ID\)를 결정하는 선행 로그인이라는 특별한 역할을 수행합니다.

CmdSN 초기값도 선행 로그인에 의해 설정됩니다.

각 연결에 대한 StatSN은 연결 로그인에 의해 시작됩니다.

로그인 요청은 기존 연결과 동일한 연결 ID\(CID\)는 물론 해당 세션의 동일한 세션 식별 요소를 사용하여 로그인할 연결\(연결 다시 시작\)의 묵시적 로그아웃\(정리\)을 나타낼 수 있습니다. 이전 연결이 연결되었습니다.

---
##### **4.6.3.3.  Logout Requests and Logout Responses**

로그아웃 요청 및 응답은 복구 또는 유지 관리를 위해 연결을 순차적으로 종료하는 데 사용됩니다. 로그아웃 요청은 대상 프롬프트\(비동기 메시지를 통해\) 이후 또는 개시자의 주도로 발행될 수 있습니다. 로그아웃할 연결에서 실행되면 다른 요청이 뒤따라올 수 없습니다.

로그아웃 응답은 연결 또는 세션 정리가 완료되었으며 해당 연결에 다른 응답이 도착하지 않음을 나타냅니다\(로그아웃 연결에서 수신된 경우\). 또한 로그아웃 응답은 Time2Retain 필드에서 대상이 복구를 위해 리소스\(예: 새 연결에서 계속되는 명령 실행\)를 계속 보유하는 기간과 Time2Wait 필드에서 복구를 진행하기 전에 개시자가 기다려야 하는 기간을 나타냅니다.

---
##### **4.6.3.4.  SNACK Request**

SNACK 요청을 통해 개시자는 대상으로부터 번호가 매겨진 응답이나 데이터의 재전송을 요청합니다. 단일 SNACK 요청은 특정 유형의 항목 중 실행이라고 하는 연속된 누락 항목 세트를 다룹니다. 유형은 PDU 헤더의 유형 필드에 표시됩니다. 실행은 초기 항목\(StatSN, DataSN, R2TSN\)과 누락된 상태, 데이터 또는 R2T PDU 수로 구성됩니다. 긴 Data-In 시퀀스의 경우 대상은 전송된 데이터에 대한 긍정적인 승인을 \(미리 정의된 최소 간격으로\) 요청할 수 있습니다. ACK와 확인된 Data-In PDU의 수를 나타내는 유형 필드가 있는 SNACK 요청은 이러한 긍정적인 확인을 전달합니다.

---
##### **4.6.3.5.  Reject**

거부를 사용하면 대상이 PDU 헤더의 이유 필드를 사용하고 거부 PDU 데이터 세그먼트에 잘못된 PDU의 전체 헤더를 포함하는 iSCSI 오류 조건\(예: 프로토콜, 지원되지 않는 옵션\)을 보고할 수 있습니다.

---
##### **4.6.3.6.  NOP-Out Request and NOP-In Response**

이 요청/응답 쌍은 연결/세션이 여전히 활성 상태이고 해당 구성 요소가 모두 작동하는지 확인하기 위한 "ping" 메커니즘으로 개시자와 대상에 의해 사용될 수 있습니다. 이러한 핑은 다음과 같습니다.

개시자 또는 대상에 의해 트리거됩니다. 트리거링 당사자는 해당 개시자/대상 전송 태그에서 기본 0xffffffff와 다른 값을 설정하여 응답을 원함을 나타냅니다.

NOP-In/NOP-Out은 다른 "캐리어"가 없고 개시자/대상을 업데이트해야 할 때 개시자/대상 명령, 상태 또는 데이터 카운터 값을 전달하기 위해 "단방향" 방식으로 사용될 수도 있습니다. .

---
## **5.  SCSI Mode Parameters for iSCSI**

iSCSI 특정 모드 페이지는 없습니다.

---
## **6.  Login and Full Feature Phase Negotiation**

iSCSI 매개변수는 로그인 요청 및 응답\(섹션 4.2.4 참조\)을 사용하여 세션 또는 연결 설정 시 그리고 전체 기능 단계\(섹션 4.2.5\) 동안 텍스트 요청 및 응답을 사용하여 협상됩니다. 두 경우 모두 사용되는 메커니즘은 iSCSI-텍스트-키=값 쌍의 교환입니다. 간결하게 하기 위해 이 문서의 나머지 부분에서는 iSCSI 텍스트 키를 "키"라고 부릅니다.

키는 선언적이거나 협상이 필요하며 키 설명은 키가 선언적이거나 협상이 필요한지 여부를 나타냅니다.

선언적 키의 경우 선언 당사자가 키 값을 설정합니다. 키 사양은 개시자, 대상 또는 둘 다에서 키를 선언할 수 있는지 여부를 나타냅니다.

협상이 필요한 키의 경우 당사자 중 하나\(제안 당사자\)는 로그인 또는 텍스트 요청 또는 응답의 데이터 부분에 키=값을 포함하여 값 또는 값 세트를 제안합니다. 상대방\(수락 당사자\)은 제안된 값 또는 값 목록을 기반으로 선택하고 다음 로그인, 텍스트 응답 또는 요청의 데이터 부분에 있는 키=값에 선택한 값을 포함합니다. 대부분의 키의 경우 개시자와 대상 모두 제안 당사자가 될 수 있습니다.

로그인 프로세스는 보안 협상 단계와 운영 매개변수 협상 단계의 두 단계로 진행됩니다. 두 단계 모두 선택 사항이지만 일부 필수 매개변수를 설정할 수 있으려면 둘 중 하나 이상이 있어야 합니다.

존재하는 경우 보안 협상 단계가 운영 매개변수 협상 단계보다 우선합니다.

단계 간 진행은 로그인 요청/응답 PDU 헤더의 T\(전송\) 비트에 의해 제어됩니다. 1로 설정된 T 비트를 통해 개시자는 전환을 원한다는 것을 나타냅니다. 대상은 준비가 되면 전환에 동의하고 다음 단계를 선택합니다. 로그인 PDU 헤더의 필드는 현재 단계\(CSG\)를 나타내고, 전환 중에 다른 필드는 제안된\(initiator\) 및 선택된\(target\) 다음 단계\(NSG\)를 나타냅니다.

텍스트 협상 프로세스는 작동 매개변수를 협상하거나 선언하는 데 사용됩니다. 협상 프로세스는 PDU 헤더의 F\(최종\) 비트에 의해 제어됩니다. 텍스트 협상 중에 F 비트는 개시자가 협상을 완료할 준비가 되었음을 표시하고 대상이 협상 종료를 승인하는 데 사용됩니다.

일부 키=값 쌍은 단일 PDU에 완전히 맞지 않을 수 있으므로 C\(계속\) 비트가 로그인 및 텍스트 모두에서 사용되어 "추가 항목"을 나타냅니다.

텍스트 협상에서는 대상이 문의 개시자에게 더 많은 양의 데이터를 전달할 수 있는 추가 메커니즘을 사용합니다. 대상은 개시자가 반환할 때 "계속"을 의미하는 책갈피로 사용될 대상 작업 태그를 설정합니다. "중립 값"으로 재설정하면 "나머지는 잊어버리세요"라는 뜻입니다.

이 섹션에서는 사용되는 키와 값의 유형, 매개변수 형성을 위한 구문 규칙, 다양한 유형의 매개변수와 함께 사용되는 협상 체계에 대해 자세히 설명합니다.

---
### **6.1.  Text Format**

개시자와 대상은 UTF-8 유니코드로 인코딩된 키=값 쌍 세트를 보냅니다. 이 문서에 지정된 모든 텍스트 키와 텍스트 값은 대소문자를 구분합니다. 대소문자를 바꾸지 않고 이 문서에 표시된 대로 제시하고 해석해야 합니다.

이 문서에서는 텍스트 항목에 대해 다음 문자 기호가 사용됩니다\(16진수 값은 유니코드 코드 포인트를 나타냄\).

\(a-z, A-Z\) \(0x61-0x7a, 0x41-0x5a\) - 문자

- \(0-9\) \(0x30-0x39\) - 숫자 " " \(0x20\) - 공백 "." \(0x2e\) - 점 "-"\(0x2d\) - 빼기 "+"\(0x2b\) - 더하기 "@"\(0x40\) - "\_"의 광고\(0x5f\) - 밑줄 "="\(0x3d\) - 같음 ":" \( 0x3a\) - 콜론

"/" \(0x2f\) - 사선 또는 슬래시

- "\["\(0x5b\) - 왼쪽 브래킷 "\]"\(0x5d\) - 오른쪽 브래킷 null\(0x00\) - null 구분 기호 ","\(0x2c\) - 쉼표 "\~"\(0x7e\) - 물결표

키=값 쌍은 PDU 경계에 걸쳐 있을 수 있습니다. PDU 내에서 부분 키=값 텍스트를 전송하는 개시자 또는 대상은 텍스트 또는 로그인 요청 또는 텍스트 또는 로그인 응답의 C 비트를 1로 설정하여 더 많은 텍스트가 뒤따른다는 것을 나타냅니다. C가 있는 일련의 PDU의 데이터 세그먼트 비트가 1로 설정되고 C 비트가 0으로 설정된 PDU로 끝나거나 C 비트가 0으로 설정된 단일 PDU를 포함하는 PDU는 단일 논리 텍스트 데이터 세그먼트\(LTDS\)를 형성하는 것으로 간주되어야 합니다. \).

LTDS의 마지막 또는 유일한 쌍을 포함하여 모든 키=값 쌍 뒤에는 하나의 null\(0x00\) 구분 기호가 와야 합니다.\(MUST\)

키 이름은 키=값 쌍에서 첫 번째 "=" 앞에 오는 모든 것입니다. 이 문서에서는 "키 이름" 대신 "키"라는 용어가 자주 사용됩니다.

값은 key=value 쌍의 첫 번째 "=" 다음에 key=value 쌍의 끝까지 포함되지만 null 구분 기호는 포함되지 않습니다.

이 문서의 나머지 부분에서는 다음 정의가 사용됩니다.

- - 표준 라벨: 문자, 숫자, 점, 빼기, 더하기, 상용 또는 밑줄로 구성된 하나 이상의 문자로 구성된 문자열입니다. 표준 라벨은 대문자로 시작해야 하며 63자를 초과할 수 없습니다.\(MUST\)

- - 키 이름: 표준 라벨입니다.

- - 텍스트 값: 문자, 숫자, 점, 빼기, 더하기, 상업용, 밑줄, 슬래시, 왼쪽 대괄호, 오른쪽 대괄호 또는 콜론으로 구성된 0개 이상의 문자로 구성된 문자열입니다.

- - iSCSI-이름-값: 빼기, 점, 콜론 또는 \[RFC3722\]에 지정된 iSCSI stringprep 템플릿의 출력에서 ​​허용되는 모든 문자로 구성된 하나 이상의 문자로 구성된 문자열\(섹션 4.2.7.2도 참조\) .

- - iSCSI-로컬 이름-값: UTF-8 문자열; 문자열에는 null 문자가 허용되지 않습니다. 이 인코딩은 지역화된\(국제화된\) 별칭에 사용됩니다.

- - 부울 값: "예" 또는 "아니요" 문자열입니다.

- - 16진수 상수: "0x" 또는 "0X"로 시작하고 그 뒤에 하나 이상의 숫자 또는 문자 a, b, c, d, e, f, A, B, C, D, E 또는 F. 16진수 상수는 숫자 값이나 이진 문자열을 인코딩하는 데 사용됩니다. 숫자 값을 인코딩하는 데 사용되는 경우 선행 0 숫자를 과도하게 사용하는 것은 권장되지 않습니다. 0X\(또는 0x\) 뒤에 오는 문자열은 가장 중요한 base16 숫자로 시작하고 그 뒤에 다른 모든 숫자가 의미의 내림차순으로 나타나고 가장 중요하지 않은 base16 숫자로 끝나는 base16 숫자를 나타냅니다. 이진 문자열을 인코딩하는 데 사용되는 경우 16진수 상수는 선행 0을 포함하여 상수의 모든 16진수에 대해 4비트를 포함하는 암시적 바이트 길이를 갖습니다. 예를 들어, n개의 16진수 숫자로 구성된 16진수 상수의 바이트 길이는 \(정수 부분\) \(n + 1\)/2입니다.

- - 소수 상수: 숫자 0이 있는 부호 없는 십진수 또는 0이 아닌 숫자로 시작하는 하나 이상의 숫자로 구성된 문자열입니다. 소수 상수는 숫자 값이나 이진 문자열을 인코딩하는 데 사용됩니다. 소수 상수는 문자열 길이가 명시적으로 지정된 경우에만 이진 문자열을 인코딩하는 데 사용할 수 있습니다. 10진수 문자열에는 암시적 길이가 없습니다. 값이 2\*\*64\(숫자\) 이상일 수 있거나 64비트보다 길 수 있는 이진 문자열의 경우 매개변수 값에 소수 상수를 사용하면 안 됩니다.\(MUST NOT\)

- - base64-constant: "0b" 또는 "0B"로 시작하고 뒤에 하나 이상의 숫자, 문자, 더하기 기호, 슬래시 또는 등호가 오는 문자열로 인코딩된 Base64 상수입니다. 인코딩은 \[RFC4648\]에 따라 수행됩니다.

- - 숫자 값: 소수 상수 또는 16진 상수로 인코딩된 항상 2\*\*64보다 작은 부호 없는 정수입니다. 부호 없는 정수 산술은 숫자 값에 적용됩니다.

- - 큰 숫자 값: 16진수 또는 base64 상수로 인코딩된 2\*\*64보다 크거나 같을 수 있는 부호 없는 정수입니다. 부호 없는 정수 산술은 큰 숫자 값에 적용됩니다.

- - 숫자 범위: 물결표로 구분된 두 개의 숫자 값. 여기서 물결표 오른쪽의 값은 왼쪽의 값보다 낮을 수 없습니다.

- - 일반 이진 값: 십진 상수, 16진 상수 또는 base64 상수로 인코딩된 64비트보다 길지 않은 이진 문자열입니다. 문자열의 길이는 키 정의에 의해 지정되거나 인코딩된 문자열의 암시적 바이트 길이입니다.

- - 대형 이진 값: 16진수 또는 base64 상수로 인코딩된 64비트보다 긴 이진 문자열입니다. 문자열의 길이는 키 정의에 의해 지정되거나 인코딩된 문자열의 암시적 바이트 길이입니다.

- - 이진 값: 일반 이진 값 또는 큰 이진 값입니다. 이진 값에 대한 작업은 키별로 다릅니다.

- - 단순 값: 텍스트 값, iSCSI 이름 값, 부울 값, 숫자 값, 숫자 범위 또는 이진 값입니다.

- - 값 목록: 쉼표로 구분된 일련의 텍스트 값입니다.

별도로 지정하지 않는 경우 단순 값\(인코딩된 표현 아님\)의 최대 길이는 구분 기호\(쉼표 또는 0바이트\)를 포함하지 않고 255바이트입니다.

모든 iSCSI 대상 또는 개시자는 협상 시퀀스에서 최소 8192바이트의 키=값 데이터 수신을 지원해야 합니다. 매우 긴 인증 항목에 대한 지원을 명시적으로 요구하는 인증 방법을 제안하거나 수락할 때 개시자와 대상은 최소 64KB의 키=값 데이터 수신을 지원해야 합니다.\(MUST, MUST\)

---
### **6.2.  Text Mode Negotiation**

로그인 중 및 그 이후에는 일부 세션 또는 연결 매개변수가 선언되거나 텍스트 정보 교환을 통해 협상됩니다.

개시자는 텍스트 또는 로그인 요청을 통해 협상 및/또는 선언을 시작하고 완료 준비가 되었음을 나타냅니다\(텍스트 요청에서 F 비트를 1로 설정하고 이를 1로 유지하거나 로그인 요청에서 T 비트로 유지\). . 협상 텍스트는 PDU 경계에 걸쳐 있을 수 있으므로 C 비트가 1로 설정된 텍스트 또는 로그인 요청이나 텍스트 또는 로그인 응답 PDU는 F 비트 또는 T 비트를 1로 설정해서는 안 됩니다.\(MUST NOT\)

C 비트가 1로 설정된 텍스트 또는 로그인 요청을 수신하는 대상은 데이터 세그먼트\(DataSegmentLength 0\)가 없는 텍스트 또는 로그인 응답으로 응답해야 합니다. C 비트가 1로 설정된 텍스트 또는 로그인 응답을 수신하는 초기자는 데이터 세그먼트\(DataSegmentLength 0\)가 없는 텍스트 또는 로그인 요청으로 응답해야 합니다.\(MUST, MUST\)

대상 또는 개시자는 일반 또는 키별 협상 규칙에서 명시적으로 요구하지 않는 한 데이터 세그먼트\(DataSegmentLength 0\)가 없는 텍스트 또는 로그인 응답이나 텍스트 또는 로그인 요청을 사용해서는 안 됩니다.\(SHOULD NOT\)

iSCSI 연결에는 처리되지 않은 텍스트 요청 또는 텍스트 응답 PDU가 두 개 이상 있어서는 안 됩니다. 이 맥락에서 미해결 PDU는 원격 iSCSI 측에서 승인되지 않은 PDU입니다.\(MUST NOT\)

선언의 형식은 다음과 같습니다.

```text
      Declarer-> <key>=<valuex>
```

텍스트 협상의 일반적인 형식은 다음과 같습니다.

```text
      Proposer-> <key>=<valuex>

      Acceptor-> <key>={<valuey>|NotUnderstood|Irrelevant|Reject}
```

따라서 선언은 단방향 텍스트 교환\(수신자가 키를 이해하지 못하는 경우 제외\)인 반면 협상은 양방향 교환입니다.

제안자 또는 선언자는 개시자 또는 대상이 될 수 있으며 수락자는 각각 대상 또는 개시자가 될 수 있습니다. 대상은 개시자가 제안한 대로 키=값 쌍에 응답하도록 제한되지 않습니다. 대상은 자체적인 키=값 쌍을 제안할 수 있습니다.

모든 협상은 명시적입니다\(즉, 결과는 새로 교환되거나 선언된 값에만 기반해야 합니다\). 암시적인 제안은 없습니다. 제안이 이루어지지 않으면 답변을 기대할 수 없습니다. 또한 보수적인 설계에서는 다른 값을 사용할 경우 심각한 결과가 발생할 경우 기본값에 의존하지 않아야 합니다.\(MUST\)

제안되거나 선언된 값은 숫자 값, 물결표로 구분된 두 정수를 사용하여 하한값과 상한값으로 정의된 숫자 범위, 이진 값, 텍스트 값, iSCSI 이름 값, iSCSI-값이 될 수 있습니다. 로컬 이름 값, 부울 값\(예 또는 아니요\) 또는 쉼표로 구분된 텍스트 값 목록입니다. 범위, 큰 숫자 값, iSCSI 이름 값 및 iSCSI 로컬 이름 값은 명시적으로 허용되는 경우에만 사용할 수 있습니다. 허용되는 값은 숫자 값, 큰 숫자 값, 텍스트 값 또는 부울 값일 수 있습니다.\(MAY\)

특정 키가 현재 협상과 관련이 없는 경우 Acceptor는 모든 유형의 협상에 대해 상수 "Irrelevant"로 응답할 수 있습니다. 다만, "부적절하다"라고 답변한 경우에는 협상이 실패한 것으로 간주되지 않습니다. "부적절함" 답변은 제안 당사자가 여러 개의 키를 제시했지만 수락자가 다음 중 하나를 선택한 경우를 의미합니다.

키는 다른 키를 관련성이 없게 만듭니다. 다음 예에서는 "Irrelevant"의 사용을 보여줍니다.

```text
      I->T InitialR2T=No,ImmediateData=Yes,FirstBurstLength=4192
      T->I InitialR2T=Yes,ImmediateData=No,FirstBurstLength=Irrelevant
      I->T X-rdname-vkey1=(bla,alb,None), X-rdname-vkey2=(bla,alb)
      T->I X-rdname-vkey1=None, X-rdname-vkey2=Irrelevant
```

Acceptor가 이해하지 못하는 키는 기본 기능에 영향을 주지 않고 Acceptor에 의해 무시될 수 있습니다. 그러나 이해되지 않은 키에 대한 대답은 key=NotUnderstood여야 합니다. NotUnderstood는 선언적 키와 협상된 키 모두에 대해 유효한 답변입니다. 일반적인 iSCSI 철학은 모든 iSCSI 키에 대한 처리보다 이해가 선행된다는 것입니다. 따라서 텍스트 키 교환에서 협상되거나 선언적인 iSCSI 키 제안자는 NotUnderstood 응답을 적절하게 처리할 수 있어야 합니다.\(MUST, MUST\)

NotUnderstood 응답을 처리하는 적절한 방법은 키가 지정된 위치와 키가 선언적인지 협상되는지 여부에 따라 달라집니다. iSCSI 구현은 이 문서에 정의된 모든 텍스트 키를 이해해야 합니다. 따라서 이러한 텍스트 키에 대해 NotUnderstood 응답을 반환하는 것은 반드시 프로토콜 오류로 간주되어 그에 따라 처리되어야 합니다. 다른 모든 "나중" 키, 즉 이후 사양에 정의된 텍스트 키의 경우 NotUnderstood 응답은 협상된 키에 대한 협상을 마무리하는 반면, 선언적 키의 경우 NotUnderstood 응답은 단순히 선언자에게 수신자의 이해 부족을 알립니다.\(MUST, MUST\)

두 경우 모두 NotUnderstood 응답에서는 해당 키와 관련된 프로토콜 동작이 어느 쪽이든 키 범위\(연결/세션\) 내에서 사용되지 않도록 항상 요구합니다.

"None", "Reject", "Irrelevant" 및 "NotUnderstood" 상수는 예약되어 있으며 여기에 설명된 대로만 사용해야 합니다. 이 규칙을 위반하는 것은 프로토콜 오류입니다\(특히 제안된 값으로 "거부", "관련 없음" 및 "이해되지 않음" 사용\).\(MUST\)

"거부" 또는 "부적절"은 허용되는 경우 합법적인 협상 옵션이지만 과도한 사용은 권장되지 않습니다. 값이 "Reject", "Irrelevant" 또는 "NotUnderstood"인 경우에도 Acceptor가 키 값 쌍을 전송하면 협상이 완료된 것으로 간주됩니다. 키를 다시 보내는 것은 재협상이 되며 많은 키에 대해 금지됩니다.

수락자가 응답으로 "거부"를 보내는 경우 협상된 키는 현재 값\(또는 값이 설정되지 않은 경우 기본값\)으로 유지됩니다. 현재 값이 연결 또는 전송된 세션의 제안자에게 허용되지 않는 경우 제안자는 연결 또는 세션을 종료하도록 선택할 수 있습니다.\(MAY\)

이 문서의 모든 키는 여기에 지정된 대로 사용될 때 iSCSI 개시자와 대상에서 지원되어야 합니다. 지정된 대로 사용하는 경우 이 키는 NotUnderstood로 응답되어서는 안 됩니다.\(MUST, MUST NOT\)

구현자는 앞에 X-를 붙이고 그 뒤에 \(역방향\) 도메인 이름을 붙이거나 IANA에 등록된 새 공개 키를 붙여 새로운 개인 키를 도입할 수 있습니다. 예를 들어 example.com 도메인을 소유한 엔터티는 다음을 발행할 수 있습니다.

```text
      X-com.example.bar.foo.do_something=3
```

표준화 과정에서 각각의 새로운 공개 키는 적절하게 NotUnderstood를 포함하여 키에 대해 허용 가능한 응답을 정의해야 합니다. \[RFC3720\]과 달리 이 문서에서는 새 공개 키에 X# 접두사를 금지합니다. iSCSI 구현 경험을 바탕으로 우리는 NotUnderstood 응답을 허용하는 키에 대한 표준 이름 접두사가 더 이상 필요하지 않다는 것을 알고 있습니다. NotUnderstood는 일반적으로 이전 버전과의 호환성을 위해 새로운 공개 키와 개인 X 키에 대해 허용되어야 합니다. 따라서 새 공개 키 이름의 이름 접두사 "X#"은 아무런 의미가 없습니다. 혼동을 피하기 위해 새로운 공개 키 이름은 "X#" 접두사로 시작하면 안 됩니다.\(MUST, MUST NOT\)

구현자는 또한 새로운 값을 도입할 수 있지만, 이는 새로운 키나 인증 방법\(섹션 12 참조\) 또는 다이제스트\(섹션 13.1 참조\)에 대해서만 가능합니다.\(MAY\)

매개변수 작업이나 승인이 다른 매개변수에 종속될 때마다 종속성 규칙과 매개변수 순서를 매개변수와 함께 지정해야 합니다.

로그인 단계\(섹션 6.3 참조\)에서 모든 단계는 별도의 협상입니다. 전체 기능 단계에서는 텍스트 요청/응답 순서가 협상입니다. 협상은 원자적 작업으로 처리되어야 합니다. 예를 들어, 협상된 모든 가치는 협상이 합의에 도달한 후에 적용되거나 협상이 실패할 경우 무시됩니다.\(MUST\)

일부 매개변수는 무결성 규칙의 적용을 받을 수 있습니다\(예: 매개변수-x는 매개변수-y를 초과해서는 안 됩니다. 또는 매개변수-u가 1이 아니면 매개변수-v가 예임을 의미합니다\). 필요할 때마다 키를 사용하여 무결성 규칙이 지정됩니다. 무결성 준수 여부 확인

규칙은 모든 매개변수\(기존 매개변수 및 새로 협상된 매개변수\)를 사용할 수 있게 된 후에만 수행되어야 합니다. iSCSI 대상은 새 매개변수가 적용되기 전에 무결성 검사를 수행해야 합니다. 개시자는 무결성 검사를 수행할 수 있습니다.\(MUST, MAY\)

iSCSI 개시자 또는 대상은 구현에 따른 합리적인 시간 또는 교환 횟수 내에 종료되지 않는 협상을 종료할 수 있지만 최소 6회의 교환을 허용해야 합니다.\(SHOULD\)

---
#### **6.2.1.  List Negotiations**

목록 협상에서 발신자는 선호하는 순서대로 값 목록\("없음"을 포함할 수 있음\)을 보냅니다.

응답 당사자는 발신자 목록에서 선택한 동일한 키와 지원하는\(특정 발신자에 대해 사용이 허용된\) 첫 번째 값으로 응답해야 합니다.\(MUST\)

누락된 기능을 나타내기 위해서는 항상 "None" 상수를 사용해야 합니다. 그러나 "없음"은 명시적으로 제안된 경우에만 유효한 선택입니다. 키에 대한 협상에서 선택 항목으로 "None"이 제안되면 해당 키와 관련된 기능을 지원하지 않는 것이 합법적임을 응답자에게 알리고, "None"이 해당 키에 대한 협상 결과인 경우 키별 의미 체계는 해당 키의 협상 범위\(연결 또는 세션\)에 대해 작동하지 않습니다.\(MUST\)

Acceptor가 목록의 특정 값을 이해하지 못하는 경우 이를 무시해야 합니다. Acceptor가 특정 발신자와 함께 제안된 옵션을 지원하지 않거나 이해하지 못하거나 사용이 허용되지 않는 경우 상수 "Reject"를 사용하거나 협상을 종료할 수 있습니다. 제안되지 않은 값의 선택은 발신자에 의해 프로토콜 오류로 처리되어야 합니다.\(MUST, MUST\)

---
#### **6.2.2.  Simple-Value Negotiations**

단순 값 협상의 경우 수락 당사자는 동일한 키로 응답해야 합니다. 선택한 값이 협상 결과가 됩니다.\(MUST\)

허용되지 않는 값\(예: 지정된 범위 내에 있지 않음\)을 제안하면 상수 "거부"로 응답될 수 있습니다. 그렇지 않으면 승인자는 허용 가능한 값을 선택해야 합니다.\(MUST\)

수락자가 선택 규칙에 따라 허용되지 않는 값을 선택하는 것은 프로토콜 오류로 간주됩니다. 선택 규칙은 키별로 다릅니다.

숫자 범위의 경우 선택한 값은 제안된 범위 내의 정수이거나 "거부"\(범위가 허용되지 않는 경우\)여야 합니다.\(MUST\)

부울 협상\(즉, "예" 또는 "아니요" 값을 갖는 키\)의 경우, 수신된 값이 자체적으로 결과를 결정하지 않는 경우 수락 당사자는 동일한 키와 협상 결과로 응답해야 합니다. 전송된 마지막 값이 협상 결과가 됩니다. 답변할 값을 선택하는 규칙은 수신된 값과 선택이 주어졌을 경우 수락하는 당사자가 선택했을 값의 부울 함수로 표현됩니다.\(MUST\)

특히 답변이 선택사항인 두 가지 경우는 다음과 같습니다.\(MAY\)

- - 부울 함수는 "AND"이고 "No" 값이 수신됩니다. 협상 결과는 'No'다.

- - 부울 함수는 "OR"이고 "Yes" 값이 수신됩니다. 협상 결과는 '예'다.

다른 모든 경우에는 응답이 필요하며 수락자가 선택하고 전송한 값이 협상의 결과가 됩니다.\(MUST\)

---
### **6.3.  Login Phase**

로그인 단계에서는 개시자와 대상 사이에 iSCSI 연결을 설정합니다. 또한 새 세션을 생성하거나 연결을 기존 세션에 연결합니다. 로그인 단계에서는 iSCSI 프로토콜 매개변수와 보안 매개변수를 설정하고 개시자와 대상을 서로 인증합니다.

로그인 단계는 로그인 요청 및 응답을 통해서만 구현됩니다. 전체 로그인 단계는 단일 작업으로 간주되며 단일 개시자 작업 태그\(링크된 SCSI 명령과 유사\)를 갖습니다.

iSCSI 연결에는 처리되지 않은 로그인 요청 또는 로그인 응답이 두 개 이상 있어서는 안 됩니다. 이 맥락에서 미해결 PDU는 원격 iSCSI 측에서 승인되지 않은 PDU입니다.\(MUST NOT\)

기본 MaxRecvDataSegmentLength는 로그인 중에 사용됩니다.

요청 및 응답의 로그인 단계 순서는 다음과 같이 진행됩니다.

```text
      - Login initial request

      - Login partial response (optional)

      - More Login Requests and Responses (optional)

      - Login Final-Response (mandatory)
```

모든 연결의 초기 로그인 요청에는 InitiatorName 키=값 쌍이 포함되어야 합니다. 세션의 첫 번째 연결에 대한 초기 로그인 요청에는 SessionType key=value 쌍도 포함될 수 있습니다. 유형이 "검색"이 아닌 세션 내 연결의 경우 첫 번째 로그인 요청에는 TargetName 키=값 쌍도 포함되어야 합니다.\(MUST, MAY, MUST\)

로그인 최종 응답은 로그인 요청을 수락하거나 거부합니다.

로그인 단계는 SecurityNegotiation 단계와 LoginOperationalNegotiation 단계를 포함할 수 있으며 그 중 적어도 하나를 포함해야 하지만 포함된 단계는 필수 이름을 제외하고는 비어 있을 수 있습니다.\(MUST\)

로그인 요청 및 응답에는 현재 협상 단계\(SecurityNegotiation 또는 LoginOperationalNegotiation\)를 나타내는 필드\(CSG\)가 포함되어 있습니다. 두 단계가 모두 사용되는 경우 SecurityNegotiation은 LoginOperationalNegotiation보다 선행해야 합니다.\(MUST\)

일부 작동 매개변수는 텍스트 요청 및 응답을 통해 로그인 외부에서 협상될 수 있습니다.

인증 관련 보안 키\(섹션 12\)는 로그인 단계 내에서 완전히 협상되어야 합니다. 기본 IPsec 보안의 사용은 섹션 9.3, \[RFC3723\] 및 \[RFC7146\]에 지정되어 있습니다. 프로토콜 내 보안을 위한 iSCSI 지원은 로그인 단계의 인증으로만 구성됩니다.\(MUST\)

일부 환경에서는 대상이나 개시자가 상대방을 인증하는 데 관심이 없습니다. 로그인 요청 및 응답을 통해 인증을 우회할 수 있습니다.

개시자와 대상은 iSCSI 인증 매개변수를 협상하기를 원할 수도 있습니다. 이 협상이 완료되면 해당 채널은 안전한 것으로 간주됩니다.\(MAY\)

대부분의 협상 키는 특정 단계에서만 허용됩니다. SecurityNegotiation 단계에서 사용되는 키는 섹션 12에 나열되어 있으며 LoginOperationalNegotiation 단계에서 사용되는 키는 섹션 13에서 논의됩니다. 제한된 키 세트\(섹션 13에서 모든 단계로 표시됨\)만이 다음 중 하나에서 사용될 수 있습니다. 두 단계.

특정 로그인 요청 또는 응답은 특정 단계에 속합니다. 이는 요청 또는 응답에 허용되는 협상 키를 결정합니다. 현재 단계에서 허용되지 않는 키를 보내는 것은 프로토콜 오류로 간주됩니다.

단계 전환은 T 비트와 동일한 CSG 코드를 전달하는 명령 교환\(요청/응답\)을 통해 수행됩니다. 이 교환 중에 대상은 다음 단계 코드\(NSG\)를 통해 다음 단계를 선택합니다. 선택한 NSG는 개시자가 명시한 값을 초과해서는 안 됩니다. 개시자는 준비가 될 때마다 전환을 요청할 수 있지만 대상은 개시자가 제안한 전환에만 응답할 수 있습니다.\(MUST NOT\)

협상 순서에서 하나의 로그인 요청-로그인 응답 쌍의 T 비트 설정은 다음 쌍의 T 비트 설정과 관련이 없습니다. 한 쌍에서 T 비트가 1로 설정되어 있고 T 비트 설정이 0으로 응답된 개시자는 T 비트가 0으로 설정된 다음 요청을 발행할 수 있습니다.

개시자가 전환을 요청하고 대상이 승인하면 개시자와 대상 모두 선택한 단계로 전환됩니다.

대상은 T 비트가 1로 설정된 로그인 응답에서 추가 개시자 로그인 요청을 요구하는 매개변수를 제출해서는 안 됩니다.\(MUST NOT\)

로그인 중 단계 전환\(들어가기 및 나가기 포함\)은 다음 표에 설명된 대로만 가능합니다.

```text
     +-----------------------------------------------------------+
     |From      To ->  | Security    | Operational | FullFeature |
     | |               |             |             |             |
     | V               |             |             |             |
     +-----------------------------------------------------------+
     | (start)         | yes         | yes         | no          |
     +-----------------------------------------------------------+
     | Security        | no          | yes         | yes         |
     +-----------------------------------------------------------+
     | Operational     | no          | no          | yes         |
     +-----------------------------------------------------------+
```

로그인 요청을 수락하는 로그인 최종 응답은 T 비트가 1로 설정된 로그인 요청에 대한 응답으로만 올 수 있으며 요청과 응답 모두 NSG 필드를 통해 FullFeaturePhase를 다음 단계로 나타내야 합니다.\(MUST\)

반복되는 키 선언을 명시적으로 허용하는 특정 키\(예: TargetAddress\)에 대한 응답을 제외하고, 개시자와 대상 모두 로그인 중에 매개변수를 두 번 이상 선언하거나 협상하려고 시도해서는 안 됩니다. 특별히 허용되지 않은 매개변수를 재협상/재선언하려는 시도는 개시자와 대상에 의해 감지되어야 합니다. 이러한 시도가 대상에 의해 감지되면 대상은 로그인 거부\(개시자 오류\)로 응답해야 합니다. 개시자가 감지하면 개시자는 연결을 끊어야 합니다.\(MUST, MUST\)

---
#### **6.3.1.  Login Phase Start**

로그인 단계는 개시자에서 대상으로의 로그인 요청으로 시작됩니다. 초기 로그인 요청에는 다음이 포함됩니다.

- - 개시자가 지원하는 프로토콜 버전

- - iSCSI 초기자 이름 및 iSCSI 대상 이름

- - ISID, TSIH 및 연결 ID

- - 개시자가 진입할 준비가 된 협상 단계

로그인을 통해 새 세션이 생성되거나 기존 세션에 연결이 추가될 수 있습니다. 지정된 iSCSI 개시자 노드\(InitiatorName으로만 선택됨\)와 iSCSI TargetName 및 대상 포털 그룹 태그로 정의된 지정된 iSCSI 대상 간의 로그인 결과는 다음 표에 정의되어 있습니다.

```text
    +----------------------------------------------------------------+
    |ISID    | TSIH        | CID    |   Target Action                |
    +----------------------------------------------------------------+
    |new     | non-zero    | any    |   fail the login               |
    |        |             |        |   ("session does not exist")   |
    +----------------------------------------------------------------+
    |new     | zero        | any    |   instantiate a new session    |
    +----------------------------------------------------------------+
    |existing| zero        | any    |   do session reinstatement     |
    |        |             |        |   (see Section 6.3.5)          |
    +----------------------------------------------------------------+
    |existing| non-zero    | new    |   add a new connection to      |
    |        | existing    |        |   the session                  |
    +----------------------------------------------------------------+
    |existing| non-zero    |existing|   do connection reinstatement  |
    |        | existing    |        |   (see Section 7.1.4.3)        |
    +----------------------------------------------------------------+
    |existing| non-zero    | any    |   fail the login               |
    |        | new         |        |   ("session does not exist")   |
    +----------------------------------------------------------------+
```

"기존" 또는 "새"의 결정은 대상에 의해 이루어집니다.

선택적으로 로그인 요청에는 다음이 포함될 수 있습니다.

```text
      - Security parameters OR

      - iSCSI operational parameters AND/OR
```

- - 개시자가 진입할 준비가 된 다음 협상 단계

대상은 다음과 같은 방법으로 로그인에 응답할 수 있습니다.

- 로그인 거부에 대한 로그인 응답. 이는 즉시

- 연결이 종료되도록 하는 대상으로부터의 거부 및 이것이 새 세션의 첫 번째\(또는 유일한\) 연결인 경우 세션이 종료됩니다. T 비트, CSG 필드 및 NSG 필드는 예약되어 있습니다.

- - 로그인이 포함된 로그인 응답은 최종 응답으로 허용됩니다\(T 비트는 1로 설정되고 요청 및 응답 모두의 NSG는 FullFeaturePhase로 설정됨\). 응답에는 대상에서 지원하는 프로토콜 버전과 세션 ID가 포함되며 iSCSI 운영 또는 보안 매개변수\(현재 단계에 따라 다름\)가 포함될 수 있습니다.

- - 로그인이 포함된 로그인 응답은 협상 시퀀스의 시작을 나타내는 부분 응답\(요청 및 응답 모두에서 FullFeaturePhase로 설정되지 않은 NSG\)으로 허용됩니다. 응답에는 대상에서 지원하는 프로토콜 버전과 대상에서 지원하는 보안 또는 iSCSI 매개변수\(보안 메커니즘을 선택하지 않은 경우\)가 포함됩니다.

개시자가 SecurityNegotiation 단계를 포기하기로 결정한 경우 CSG가 LoginOperationalNegotiation으로 설정된 로그인을 발행하고 대상은 SecurityNegotiation 없이 연결\(11.13절 참조\)을 수락하지 않고 종료됨을 나타내는 로그인 응답으로 응답할 수 있습니다. 인증 실패 응답으로 연결\(섹션 11.13.5 참조\).

개시자가 iSCSI 보안을 협상할 의향이 있지만 초기 매개변수 제안을 할 의향이 없고 iSCSI 보안 없이 연결을 수락할 수 있는 경우 T 비트가 1로 설정되고 CSG가 SecurityNegotiation으로 설정되고 NSG가 설정된 로그인을 발행합니다. LoginOperationalNegotiation에. 대상이 보안을 건너뛸 준비가 된 경우 로그인 응답에는 TargetPortalGroupTag 키\(섹션 13.9 참조\), T 비트가 1로 설정, CSG는 SecurityNegotiation으로 설정, NSG는 LoginOperationalNegotiation으로 설정만 포함됩니다.

iSCSI 보안 없이 작동하고 모든 작동 매개변수가 기본값을 사용하도록 선택한 초기자는 T 비트가 1로 설정되고 CSG가 LoginOperationalNegotiation으로 설정되고 NSG가 FullFeaturePhase로 설정된 로그인을 실행합니다. 대상이 보안을 포기할 준비가 되어 있고 LoginOperationalNegotiation을 완료할 수 있는 경우 다음 단계에서 로그인 응답의 T 비트는 1로 설정되고 CSG는 LoginOperationalNegotiation으로 설정되며 NSG는 FullFeaturePhase로 설정됩니다.

로그인 단계 동안 iSCSI 대상은 모든 대상에 대해 허용된 첫 번째 로그인 응답 PDU\(즉, C 비트가 0으로 설정된 첫 번째 로그인 요청 이후에 발행된 첫 번째 로그인 응답\)와 함께 TargetPortalGroupTag 키를 반환해야 합니다. 세션 유형. TargetPortalGroupTag 키 값은 로그인 요청 PDU를 서비스하는 iSCSI 포털 그룹을 나타냅니다. 특정 환경에서 iSCSI 포털 그룹 재구성이 문제가 되는 경우 iSCSI 초기자는 이 키를 사용하여 의도한 대상 포털 그룹으로 로그인 단계를 실제로 시작했는지 확인해야 합니다.\(MUST\)

---
#### **6.3.2.  iSCSI Security Negotiation**

보안 교환은 보안 메커니즘을 설정하고 개시자와 대상을 서로 인증합니다. 교환은 협상 단계에서 선택한 인증 방법에 따라 진행되며 로그인 요청 및 응답에 포함된 key=value 매개변수를 사용하여 수행됩니다.

개시자 주도 협상은 다음과 같이 진행됩니다.

- - 개시자는 지원하는 옵션\(인증 알고리즘\)의 정렬된 목록과 함께 로그인 요청을 보냅니다. 옵션은 개시자의 기본 설정 순서에 따라 나열됩니다. 개시자는 또한 비공개 또는 공개 확장 옵션을 보낼 수도 있습니다.\(MAY\)

- - 대상은 지원하는 목록의 첫 번째 옵션으로 응답해야 하며 특정 개시자에 대해 사용이 허용됩니다. 단, 지원하지 않는 경우에는 "거부"로 응답해야 합니다\(섹션 6.2 참조\). 매개변수는 키=값으로 UTF-8로 인코딩됩니다. 보안 매개변수는 섹션 12를 참조하세요.\(MUST\)

- - 개시자는 SecurityNegotiation 단계를 완료할 준비가 되었다고 생각하면 T 비트를 1로 설정하고 NSG를 원하는 다음 단계로 설정합니다. 그런 다음 대상은 T 비트를 1로 설정하고 보안 키 전송이 완료되면 로그인 응답의 다음 단계로 NSG를 설정합니다. 선택한 다음 단계는 대상이 선택한 단계가 됩니다. 다음 단계가 FullFeaturePhase인 경우 대상은 TSIH 값이 포함된 로그인 응답으로 응답해야 합니다.\(MUST\)

보안 협상이 대상에서 실패하면 대상은 적절한 로그인 응답 PDU를 보내야 합니다. 개시자에서 보안 협상이 실패하면 개시자는 연결을 닫아야 합니다.\(MUST, SHOULD\)

개시자가 보안을 지원하지만 협상을 지시할 준비가 되지 않은 경우\(옵션 제안\) 협상이 대상에 의해 지시될 수도 있다는 점에 유의해야 합니다. 예를 보려면 부록 B를 참조하세요.

---
#### **6.3.3.  Operational Parameter Negotiation during the Login Phase**

로그인 단계 동안 작동 매개변수 협상이 수행될 수 있습니다.\(MAY\)

- - 개시자가 보안/무결성 옵션을 제안하지 않는 경우 첫 번째 로그인 요청부터 시작합니다.

- - 개시자와 대상이 그러한 협상을 수행하는 경우 보안 협상 직후부터 시작됩니다.

작동 매개변수 협상에는 개시자에 의해 시작되고 종료되는 여러 로그인 요청-로그인 응답 교환이 포함될 수 있습니다. 개시자는 T 비트를 1로 설정하여 협상을 종료하려는 의도를 나타내야 합니다. 타겟은 마지막 응답에서 T 비트를 1로 설정합니다.\(MAY, MUST\)

개시자가 로그인 요청에서 T 비트를 1로 설정하여 단계를 전환하려는 의도를 나타내는 경우에도 대상은 T 비트가 0으로 설정된 로그인 응답으로 응답할 수 있습니다. 이 경우 개시자는 계속해서 T를 설정해야 합니다. 대상이 T 비트를 1로 설정한 로그인 응답을 보내거나 개시자가 T 비트를 0으로 설정하도록 요구하는 키를 보낼 때까지 전송하는 후속 로그인 요청\(비어 있는 요청이라도\)에서 비트를 1로 설정합니다.\(MAY, SHOULD\)

일부 세션별 매개변수는 세션의 첫 번째 연결\(즉, 값이 0인 TSIH를 포함하는 로그인 요청에 의해 시작됨\)의 로그인 단계\(예: 선행 로그인 단계\(예: 최대 연결 수\)\) 동안에만 지정할 수 있습니다. 이 세션에 사용할 수 있습니다\).

전체 기능 단계에서 하나 이상의 연결이 있으면 세션이 작동됩니다. 새 연결이나 대체 연결은 세션이 작동된 후에만 세션에 추가할 수 있습니다.

작동 매개변수는 섹션 13을 참조하십시오.

---
#### **6.3.4.  Connection Reinstatement**

연결 복원은 대상의 관점에서 활성화될 수 있는 ISID-TSIH-CID 조합을 사용하여 초기자가 로그인하는 프로세스로, 이로 인해 CID에 해당하는 연결에서 암시적으로 로그아웃되고 새로운 전체 기능 단계 iSCSI 연결이 복원됩니다. 그 자리에\(동일한 CID를 사용하여\) 따라서 로그인 요청 PDU의 TSIH는 0이 아니어야 하며 CID는 연결 복원 중에 변경되지 않습니다. 로그인 요청은 이전에 명시적인 로그아웃이 수행되지 않은 경우 이전 연결의 로그아웃 기능을 수행합니다. 단일 연결이 있는 세션에서는 첫 번째 연결을 정리할 목적으로 두 번째 연결이 열리는 것을 의미할 수 있습니다. Target은 ErrorRecoveryLevel이 2인 경우 전체 기능 단계에서 여러 연결을 지원하지 않는 경우에도 두 번째 연결 열기를 지원해야 하며 ErrorRecoveryLevel이 2보다 작은 경우 두 번째 연결 열기를 지원해야 합니다\(SHOULD\).\(MUST, MUST\)

작동 가능한 ErrorRecoveryLevel이 2인 경우 연결 복원을 통해 향후 작업 재할당이 가능해집니다. 운영 ErrorRecoveryLevel이 2 미만인 경우 연결 복원은

작업 재할당을 활성화하지 않고 기존 CID를 교체합니다. 이 경우 이전 CID에서 활성화된 모든 작업은 개시자에게 추가 통지 없이 즉시 종료되어야 합니다.

개시자가 연결 복원을 시도할 때 개시자 연결 상태는 반드시 CLEANUP\_WAIT\(8.1.3절\)이어야 합니다.\(MUST\)

실제로 복원은 이전 연결의 암시적 로그아웃 외에 새 연결 로그인과 동일합니다.

---
#### **6.3.5.  Session Reinstatement, Closure, and Timeout**

세션 복원은 초기자가 대상의 관점에서 활성 상태일 수 있는 ISID로 로그인하여 ISID에 해당하는 세션을 암시적으로 로그아웃하고 그 자리에\(동일한 ISID를 사용하여\) 새 iSCSI 세션을 복원하는 프로세스입니다. \). 따라서 세션 복원 신호를 보내려면 로그인 PDU의 TSIH가 0이어야 합니다. 세션 복원을 사용하면 이전 세션에서 활성화된 모든 작업이 개시자에게 추가 통지 없이 대상에 의해 즉시 종료됩니다.\(MUST\)

개시자가 세션 복원을 시도할 때 개시자 세션 상태는 FAILED\(8.3절\)여야 합니다.\(MUST\)

세션 종료는 다음 중 하나로 정의된 이벤트입니다.

- - 성공적인 "세션 종료" 로그아웃.

- - 세션에 정리를 기다리는 다른 연결이 없고\(8.2절\) 세션에 재할당을 기다리는 작업이 없는 경우 마지막 전체 기능 단계 연결에 대한 성공적인 "연결 닫기" 로그아웃입니다.

세션 시간 초과는 마지막 연결 상태 시간 초과가 만료되고 재할당을 기다리는 작업이 없을 때 발생하도록 정의된 이벤트입니다. 이렇게 하면 세션이 FREE 상태가 됩니다\(섹션 8.3의 세션 상태 다이어그램 참조\).

---
##### **6.3.5.1.  Loss of Nexus Notification**

iSCSI 계층은 다음 이벤트 중 하나가 발생할 때 "I\_T 넥서스 손실" 알림을 SCSI 계층에 제공합니다.

- - 세션 복원이 성공적으로 완료되었습니다.

```text
      - session closure event

      - session timeout event
```

부록 E에 설명된 대로 특정 SCSI 개체 지우기 작업은 SCSI 끝 노드의 알림으로 인해 발생할 수 있습니다.

---
#### **6.3.6.  Session Continuation and Failure**

세션 연속은 연결 복원\(6.3.4절\) 또는 새 CID와의 연결 추가를 통해 기존 세션의 상태를 계속 사용하는 프로세스입니다. 이러한 작업 중 하나는 새 전송 연결을 세션 상태와 연결합니다.

세션 실패는 마지막 전체 기능 단계 연결이 CLEANUP\_WAIT 상태\(섹션 8.2\)에 도달하거나 성공적인 복구 로그아웃을 완료하여 모든 활성 작업\(이전에 연결에 충실했던\)이 작업 재할당을 기다리기 시작하는 이벤트입니다.

---
### **6.4.  Operational Parameter Negotiation outside the Login Phase**

일부 운영 매개변수는 로그인 단계 외부\(이후\)에서 협상될 수 있습니다.\(MAY\)

전체 기능 단계의 매개변수 협상은 텍스트 요청 및 응답을 통해 수행됩니다. 운영 매개변수 협상에는 여러 개의 텍스트 요청-텍스트 응답 교환이 포함될 수 있으며, 모두 동일한 개시자 작업 태그를 사용합니다. 개시자는 항상 이러한 각 교환을 시작하고 종료합니다. 개시자는 F 비트를 1로 설정하여 협상을 완료하려는 의도를 나타내야 합니다. 타겟은 마지막 응답에서 F 비트를 1로 설정합니다.\(MAY, MUST\)

대상이 F 비트가 1로 설정된 텍스트 요청에 F 비트가 0으로 설정된 텍스트 응답으로 응답하는 경우 개시자는 F 비트가 1로 설정된 텍스트 요청\(빈 요청도 포함\)을 계속 보내야 합니다. F 비트가 1로 설정된 텍스트 응답을 수신할 때까지 협상을 완료하려고 합니다. F 비트가 0으로 설정된 빈\(키=값 쌍 없음\) 응답으로 F 비트가 1로 설정된 텍스트 요청에 응답합니다. 낙담합니다.

개시자가 텍스트 요청에서 F 비트를 1로 설정하여 협상을 완료하겠다는 의도를 표시하는 경우에도 대상은 F 비트가 0으로 설정된 텍스트 응답으로 응답할 수 있습니다. 이 경우 개시자는 계속해서 대상이 F 비트가 1로 설정된 최종 텍스트 응답을 보낼 때까지 보내는 후속 텍스트 요청\(비어 있는 요청이라도\)에서 F 비트를 1로 설정합니다. 동일한 경우 F 비트가 1로 설정된 텍스트 요청에 유의하세요. , 대상은 F 비트가 0으로 설정된 빈\(키=값 쌍 없음\) 텍스트 응답으로 응답해서는 안 됩니다. 이러한 응답으로 인해 개시자가 협상을 포기할 수 있기 때문입니다.\(MAY, SHOULD, SHOULD NOT\)

대상은 F 비트가 1로 설정된 텍스트 응답에서 추가 개시자 텍스트 요청을 요구하는 매개변수를 제출해서는 안 됩니다.\(MUST NOT\)

협상 순서에서 하나의 텍스트 요청-텍스트 응답 쌍의 F 비트 설정은 다음 쌍의 F 비트 설정과 관련이 없습니다. 요청의 F 비트가 1로 설정되어 있고 F 비트 설정이 0인 응답을 받는 개시자는 F 비트가 0으로 설정된 다음 요청을 발행할 수 있습니다.

대상이 0으로 설정된 F 비트로 응답할 때마다 대상 전송 태그를 기본 0xffffffff 이외의 값으로 설정해야 합니다.\(MUST\)

개시자는 0xffffffff 이외의 값으로 설정된 대상 전송 태그가 있는 응답을 수신한 후 0xffffffff 값으로 설정된 대상 전송 태그로 텍스트 요청을 발행하여 작동 매개변수 협상을 재설정할 수 있습니다. 대상은 PDU 거부로 텍스트 요청에 응답하여 작동 매개변수 협상을 재설정할 수 있습니다.\(MAY\)

반복되는 키 선언\(예: TargetAddress\)을 명시적으로 허용하는 특정 키에 대한 응답을 제외하고 개시자와 대상은 협상 시퀀스 중에 매개변수를 두 번 이상 선언하거나 협상하려고 시도해서는 안 됩니다. 이러한 시도가 대상에 의해 감지되면 대상은 "프로토콜 오류"라는 이유로 PDU 거부로 응답해야 합니다. 개시자는 위에 설명된 대로 협상을 재설정해야 합니다.\(MUST, MUST\)

텍스트 교환 협상 순서에 의해 협상된 매개변수는 협상 순서가 완료된 후에만 유효합니다.

---
## **7.  iSCSI Error Handling and Recovery**
---
### **7.1.  Overview**
---
#### **7.1.1.  Background**

다음 두 가지 고려 사항으로 인해 iSCSI의 오류 복구 기능이 대부분 설계되었습니다.

- - iSCSI PDU는 TCP 계층에서 수신되었음에도 불구하고 다이제스트 검사에 실패하여 삭제될 수 있습니다. iSCSI 계층은 선택적으로 이러한 삭제된 PDU를 복구하도록 허용되어야 합니다.

- - 데이터 전송 중 언제든지 TCP 연결이 실패할 수 있습니다. 모든 활성 작업은 선택적으로 동일한 세션 내의 다른 TCP 연결에서 계속되도록 허용되어야 합니다.

구현에서는 지원할 오류 복구 수준, 사용 시기, 필요한 동작을 달성하기 위한 메커니즘을 결정하는 데 상당한 유연성을 갖습니다. 상호 운용성을 보장하려면 오류 복구 메커니즘의 외부에서 볼 수 있는 작업만 표준화해야 합니다.

이 섹션에서는 상호 운용성을 지원하는 일반적인 복구 모델을 설명합니다. 설명된 모델을 구현하는 방법에 대한 자세한 내용은 부록 D를 참조하세요. 준수 구현은 제시된 대로 이 모델의 구현 세부 사항과 일치할 필요는 없지만, 그러한 구현의 외부 동작은 제시된 모델의 외부에서 관찰 가능한 특성과 일치해야 합니다.

---
#### **7.1.2.  Goals**

iSCSI 오류 복구 체계의 주요 설계 목표는 다음과 같습니다.

- - 구현 시 선택할 수 있는 오류 복구 메커니즘 모음을 정의하여 iSCSI 구현이 다양한 요구 사항을 충족할 수 있도록 합니다.

- 두 구현 간의 상호 운용성을 보장합니다.

- 다양한 오류 복구 기능 세트를 지원합니다.

- - 오류가 발생한 경우에도 순서를 요구하는 개시자에 대해 명령 순서를 보장하기 위한 오류 복구 메커니즘을 정의합니다.

- - 빠른 경로에 추가하지 말고 오류 복구 경로에 적당한 복잡성을 허용하십시오.

- - 개시자와 대상이 동시에 동일한 PDU 세트를 복구하려고 시도하는 것을 방지합니다. 예를 들어 개시자와 대상 사이에 명확한 "오류 복구 기능 배포"가 있어야 합니다.

---
#### **7.1.3.  Protocol Features and State Expectations**

오류 복구와 관련하여 정의된 개시자 메커니즘은 다음과 같습니다.

```text
      a) NOP-Out to probe sequence numbers of the target (Section 11.18)

      b) Command retry (Section 7.2.1)

      c) Recovery R2T support (Section 7.8)

      d) Requesting retransmission of status/data/R2T using the SNACK
         facility (Section 11.16)

      e) Acknowledging the receipt of the data (Section 11.16)

      f) Reassigning the connection allegiance of a task to a different
         TCP connection (Section 7.2.2)

      g) Terminating the entire iSCSI session to start afresh
         (Section 7.1.4.4)
```

오류 복구와 관련하여 정의된 대상 메커니즘은 다음과 같습니다.

```text
      a) NOP-In to probe sequence numbers of the initiator
         (Section 11.19)

      b) Requesting retransmission of data using the recovery R2T
         feature (Section 7.8)

      c) SNACK support (Section 11.16)

      d) Requesting that parts of read data be acknowledged
         (Section 11.7.2)

      e) Allegiance reassignment support (Section 7.2.2)

      f) Terminating the entire iSCSI session to force the initiator to
         start over (Section 7.1.4.4)
```

처리되지 않은 SCSI 명령의 경우 iSCSI는 개시자에서 SCSI와 함께 명령 PDU와 나가는 명령을 재구축할 수 있을 만큼 충분한 정보를 유지할 수 있다고 가정합니다.

명령이 처리되지 않은 동안 데이터를 재전송할 수 있습니다\(호스트 메모리에서\). 또한 대상에서 들어오는 데이터\(읽은 데이터\)를 복구를 위해 보관하거나 장치 서버에서 다시 읽을 수 있다고 가정합니다.\(MAY\)

또한 대상이 상태 재전송을 지원하는 경우 실행한 명령에 대한 "상태 및 감지"를 유지할 것이라고 가정합니다.

데이터 재전송 지원에 동의한 대상은 완료된 명령의 상태가 확인되거나 문제의 데이터가 별도로 확인될 때까지 요청 시 나가는 데이터\(즉, Data-In\)를 재전송할 준비가 되어 있어야 합니다.

---
#### **7.1.4.  Recovery Classes**

iSCSI를 사용하면 다음과 같은 복구 클래스가 가능합니다\(영향을 받는 iSCSI 작업의 범위가 증가하는 순서대로\).

```text
      - within a command (i.e., without requiring command restart)

      - within a connection (i.e., without requiring the connection to
        be rebuilt, but perhaps requiring command restart)

      - connection recovery (i.e., perhaps requiring connections to be
        rebuilt and commands to be reissued)

      - session recovery
```

이 섹션의 나머지 부분에 자세히 설명된 복구 시나리오는 배타적인 것이 아니라 대표적인 것입니다. 모든 경우에 시도할 수 있는 가장 낮은 복구 등급을 자세히 설명합니다. 구현자는 어떤 상황에서 다음 복구 클래스로 에스컬레이션할지 및/또는 어떤 복구 클래스를 구현할지 결정해야 합니다. iSCSI 대상과 개시자 모두 오류 처리를 오류 복구 클래스로 확대할 수 있으며, 이는 다음 설명에서 확인된 사례에서 더 많은 수의 iSCSI 작업에 영향을 미칩니다.\(MAY, MAY\)

모든 클래스에서 구현자는 오류를 SCSI 개시자\(적절한 응답 코드 사용\)로 연기할 수 있으며, 이 경우 작업이 있는 경우 대상에서 제거되어야 하며 ACA와 같은 모든 부작용도 제거되어야 합니다. 고려해야합니다.

연결 내 및 명령 내 복구 클래스의 사용은 연결이 전체 기능 단계에 있기 전에 시도되어서는 안 됩니다.\(MUST NOT\)

복구 클래스에 대한 자세한 설명에서 명령 용어\(MUST, SHOULD, MAY 등\)는 복구 클래스가 지원되고\(관련 협상 의미에 대해서는 섹션 7.1.5 참조\) 실행될 규범적 작업을 나타냅니다.\(MUST\)

---
##### **7.1.4.1.  Recovery Within-command**

대상에서는 다음과 같은 경우 명령 내 복구가 가능합니다.

- 데이터 손실 PDU - 다음 중 하나를 통해 실현됩니다.

- a\) 데이터 다이제스트 오류 - 복구 R2T 옵션을 사용하여 섹션 7.8에 지정된 대로 처리됩니다.

- b\) 시퀀스 수신 타임아웃\(데이터 없음 또는 부분 데이터 및 F 비트 없음\) - 암시적 시퀀스 오류로 간주되고 복구 R2T 옵션을 사용하여 섹션 7.9에 지정된 대로 처리됩니다.

- c\) 시퀀스 수신 시간 초과 또는 시퀀스 오류로 나타나는 헤더 다이제스트 오류 - 복구 R2T 옵션을 사용하여 섹션 7.9에 지정된 대로 처리됩니다.

개시자에서는 다음과 같은 경우에 명령 내 복구가 가능합니다.

- 데이터 PDU 손실 또는 R2T 손실 - 다음 중 하나를 통해 실현됩니다.

- a\) 데이터 다이제스트 오류 - SNACK 옵션을 사용하여 섹션 7.8에 지정된 대로 처리됩니다.

- b\) 시퀀스 수신 타임아웃\(상태 없음\) 또는 응답 수신 타임아웃 - SNACK 옵션을 사용하여 섹션 7.9에 지정된 대로 처리됩니다.

- c\) 시퀀스 수신 시간 초과 또는 시퀀스 오류로 나타나는 헤더 다이제스트 오류 - SNACK 옵션을 사용하여 섹션 7.9에 지정된 대로 처리됩니다.

이미 복구 R2T 또는 종료 응답이 있을 수 있는 대상과의 경합을 피하기 위해 개시자는 내부 시간 초과\(있는 경우\)를 기반으로 R2T에 대한 SNACK을 시작해서는 안 됩니다. 이 경우 복구는 대상에게 맡기는 것이 좋습니다.\(SHOULD NOT\)

개시자와 대상에서 사용되는 시간 초과 값은 이 문서의 범위를 벗어납니다. 시퀀스 수신 시간 초과는 일반적으로 데이터 시퀀스 전송이 완료될 수 있을 만큼 충분히 큰 값입니다.

---
##### **7.1.4.2.  Recovery Within-connection**

개시자에서는 다음과 같은 경우에 연결 내 복구가 가능합니다.

- a\) 오랫동안 요청이 승인되지 않았습니다. 요청은 ExpCmdSN을 통해 명시적으로 승인되거나 데이터 및/또는 상태 수신을 통해 암시적으로 승인됩니다. 개시자는 섹션 7.2에 지정된 대로 승인되지 않은 명령을 재시도할 수 있습니다.\(MAY\)

- b\) iSCSI 번호가 매겨진 응답이 손실되었습니다. 이는 상태를 전달하는 응답 PDU 또는 Data-In PDU에서 데이터 다이제스트 오류를 ​​식별하거나 예상보다 높은 StatSN이 있는 응답 PDU를 수신하여 인식됩니다. 첫 번째 경우 다이제스트 오류 처리는 SNACK 옵션을 사용하여 섹션 7.8에 지정된 대로 수행됩니다. 두 번째 경우에는 SNACK 옵션을 사용하여 섹션 7.9에 지정된 대로 시퀀스 오류 처리가 수행됩니다.

대상에서 다음과 같은 경우는 연결 내 복구에 적합합니다.

- - 오랫동안 상태/응답이 인식되지 않았습니다. 대상은 StatSN 필드에서 사용할 다음 상태 시퀀스 번호를 전달하는 NOP-In\(유효한 대상 전송 태그 또는 기타 포함\)을 발행할 수 있습니다. 이는 개시자가 누락된 StatSN을 감지하고 상태에 대한 SNACK을 발행하는 데 도움이 됩니다.\(MAY\)

개시자와 대상이 사용하는 시간 초과 값은 이 문서의 범위를 벗어납니다.

---
##### **7.1.4.3.  Connection Recovery**

iSCSI 개시자에서는 다음과 같은 경우에 연결 복구가 가능합니다.

a\) TCP 연결 실패: 개시자는 반드시 TCP 연결을 닫아야 합니다.

-     연결. 그런 다음 "복구를 위해 연결 제거"라는 이유 코드와 함께 실패한 연결을 암시적으로 또는 명시적으로 로그아웃하고 하나 이상의 연결에서 실패한 연결과 관련하여 아직 진행 중인 모든 명령에 대한 연결 충성을 다시 할당해야 합니다\(일부 또는 전부는 새로 설정된 연결\) "TASK REASSIGN" 작업 관리 기능을 사용합니다\(섹션 11.5.1 참조\). Initiator의 경우 응답이나 상태가 포함된 Data-In PDU를 수신하지 않는 한 명령이 진행 중입니다.\(MUST, MUST\)

- 참고: 로그아웃 기능은 필수입니다. 그러나 실패한 연결이 세션의 마지막 연결이거나 유일한 연결인 경우에만 새 연결 설정이 필수입니다.

- b\) 세션의 하나 또는 모든 연결이 삭제되었음을 나타내는 비동기 메시지를 수신합니다. 개시자는 이를 메시지에 언급된 연결에 대한 TCP 연결 실패로 처리해야 합니다.\(MUST\)

iSCSI 대상에서 다음과 같은 경우는 연결 복구에 적합합니다.

- - TCP 연결 실패: 대상은 연결을 닫아야 하며, 둘 이상의 연결이 사용 가능한 경우 대상은 연결이 삭제되었음을 나타내는 비동기 메시지를 보내야 합니다. 그런 다음 대상은 개시자가 복구를 계속할 때까지 기다립니다.\(MUST\)

---
##### **7.1.4.4.  Session Recovery**

다른 모든 복구 시도가 실패한 경우 세션 복구를 수행해야 합니다. 매우 간단한 개시자와 대상은 모든 iSCSI 오류에 대해 세션 복구를 수행할 수 있으며 SCSI 계층 이상의 복구에 의존할 수 있습니다.\(MAY\)

세션 복구는 모든 TCP 연결을 닫고, 대상에서 지정된 개시자에 대해 실행 중이거나 대기열에 있는 모든 작업을 내부적으로 중단하고, 개시자에서 적절한 SCSI 서비스 응답으로 처리되지 않은 모든 SCSI 명령을 종료하고, 새로운 연결 세트에서 세션을 다시 시작하는 것을 의미합니다. \(s\) \(TCP 연결 설정 및 모든 새 연결에 대한 로그인\).

SCSI 및 iSCSI 개체에 대한 세션 복구의 가능한 지우기 효과에 대해서는 부록 E를 참조하십시오.

---
#### **7.1.5.  Error Recovery Hierarchy**

지금까지 설명한 오류 복구 클래스는 이해하기 쉽고 구현의 복잡성을 제한하기 위해 계층 구조로 구성됩니다. 몇 가지 잘 정의된 복구 수준을 사용하면 상호 운용성을 더 쉽게 얻을 수 있습니다. 이 계층 구조의 속성은 다음과 같습니다.

- a\) 각 레벨은 이전 레벨 기능의 상위 집합입니다. 예를 들어, 레벨 1 지원은 레벨 0 이상의 모든 기능을 지원함을 의미합니다.

- b\) 결과적으로 더 높은 오류 복구 수준을 지원한다는 것은 복잡성이 증가하고 리소스 요구 사항이 증가할 수 있음을 의미합니다.

c\) 지원 오류 복구 수준 "n"이 광고되고

- 텍스트 키 "ErrorRecoveryLevel=n"을 교환하여 각 iSCSI 엔터티에서 협상합니다. 교환된 두 값 중 낮은 값이 해당 세션의 작동 ErrorRecoveryLevel입니다.

다음 다이어그램은 오류 복구 계층 구조를 나타냅니다.

```text
                            +
                           / \
                          / 2 \      <-- Connection recovery
                         +-----+
                        /   1   \    <-- Digest failure recovery
                       +---------+
                      /     0     \  <-- Session failure recovery
                     +-------------+
```

다음 표에는 각 오류 복구 수준을 지원하는 구현에서 예상되는 오류 복구\(ER\) 기능이 나열되어 있습니다.

```text
    +-------------------+--------------------------------------------+
    |ErrorRecoveryLevel | Associated Error Recovery Capabilities     |
    +-------------------+--------------------------------------------+
    |        0          | Session recovery class                     |
    |                   | (Session Recovery)                         |
    +-------------------+--------------------------------------------+
    |        1          | Digest failure recovery (see Note below)   |
    |                   | plus the capabilities of ER Level 0        |
    +-------------------+--------------------------------------------+
    |        2          | Connection recovery class                  |
    |                   | (Connection Recovery)                      |
    |                   | plus the capabilities of ER Level 1        |
    +-------------------+--------------------------------------------+
```

참고: 다이제스트 실패 복구는 연결 내 복구 클래스\(연결 내 복구\)와 명령 내 복구 클래스\(명령 내 복구\)의 두 가지 복구 클래스로 구성됩니다.

ErrorRecoveryLevel의 정의된 값이 텍스트 협상에서 발신자에 의해 제안된 경우 발신자는 제안된 값에 대해 정의된 기능을 지원해야 하며, 추가적으로 제안된 값보다 수치적으로 더 작은 정의된 값에 해당하는 기능도 지원해야 합니다. ErrorRecoveryLevel의 정의된 값이\(MUST\)

텍스트 협상에서 응답자가 반환하는 경우 응답자는 허용하는 ErrorRecoveryLevel에 해당하는 기능을 지원해야 합니다.\(MUST\)

한쪽 당사자가 협상된 범위를 넘어서 오류 복구 기능을 사용하려고 시도하는 경우 복구 시도는 실패할 수 있습니다. 단, 이러한 지원을 제공하기 위해 두 당사자 간에 이 문서의 범위를 벗어나는 선험적 합의가 존재하는 경우는 예외입니다.\(MAY\)

구현은 오류 복구 수준 "0"을 지원해야 하며 나머지는 선택적으로 구현할 수 있습니다. 구현 측면에서 위의 줄무늬는 각 수준마다 다음과 같은 점진적인 정교함이 필요함을 의미합니다.\(MUST\)

```text
    +-------------------+--------------------------------------------+
    | Level Transition  | Incremental Requirement                    |
    +-------------------+--------------------------------------------+
    |        0->1       | PDU retransmissions on the same connection |
    +-------------------+--------------------------------------------+
    |        1->2       | Retransmission across connections and      |
    |                   | allegiance reassignment                    |
    +-------------------+--------------------------------------------+
```

---
### **7.2.  Retry and Reassign in Recovery**

이 섹션에서는 오류 복구에 사용되는 두 가지 중요하고 다소 관련된 iSCSI 프로토콜 기능을 요약합니다.

---
#### **7.2.1.  Usage of Retry**

명령 승인\(ExpCmdSN 업데이트를 통해\) 또는 응답이 없을 때 동일한 iSCSI 명령 PDU\("재시도"\)를 다시 전송함으로써 개시자는 CmdSN 주문의 불연속성을 "연결"\(생각하는 것\)하려고 시도합니다. 목표 끝. 다이제스트 오류로 인해 폐기된 명령 PDU로 인해 이러한 불연속성이 발생할 수 있습니다.

재시도는 명령 시퀀스 갭 연결 이외의 이유로 사용되어서는 안 되며, 특히 대상에서 PDU 재전송을 요청하는 데 사용할 수 없습니다. 현재 진행 중인 명령에 대한 PDU 재전송 요청은 섹션 11.16에 설명된 SNACK 메커니즘을 사용하여 이루어질 수 있지만 SNACK의 사용은 선택 사항입니다.\(MUST NOT, MAY\)

위에 설명된 명령 시퀀스 간격 연결의 일부로 개시자가 이미 진행 중인 동맹 명령에 대해 실수로 재시도를 실행하는 경우\(즉, 대상이 CmdSN 순서에서 불연속성을 확인하지 못한 경우\) 섹션 4.2에 지정된 대로 대상에서 중복 명령이 자동으로 무시됩니다. .2.1.

iSCSI 명령이 재시도되면 명령 PDU는 원래 CmdSN뿐만 아니라 원래 개시자 작업 태그와 원래 작동 속성\(예: 플래그, 기능 이름, LUN, CDB 등\)을 전달해야 합니다. 재시도되는 명령은 원래 연결이 이미 성공적으로 로그아웃되지 않은 한 원래 명령과 동일한 연결에서 전송되어야 합니다.\(MUST, MUST\)

---
#### **7.2.2.  Allegiance Reassignment**

"TASK REASSIGN" 작업 관리 요청\(섹션 11.5.1\)을 발행함으로써 개시자는 연결 복구의 일부로 이미 활성 명령\(그러나 현재 연결 충성은 없음\)을 계속하겠다는 의도를 알립니다. 이는 작업 관리 요청이 실행되는 연결에 연결하려고 하는 명령에 대해 새로운 연결 충성이 요청됨을 의미합니다. 작업에 대한 충성 재할당을 시도하기 전에 "복구를 위한 연결 제거"\(섹션 11.14.1 참조\) 이유 코드와 함께 암시적 또는 명시적 로그아웃이 작업이 충성이었던 이전 연결에 대해 성공적으로 완료되어야 합니다.\(MUST\)

명령에 대한 연결 충성을 재할당할 때 대상은 현재 상태에서 명령을 계속해야 합니다. 예를 들어 읽기 명령을 재할당할 때 대상은 작업 관리 기능 요청\(데이터 전송이 없는 경우 0으로 설정되어야 함\)에서 제공하는 ExpDataSN 필드를 활용하고 나머지 데이터를 전송하여 읽기 명령을 완료해야 합니다. 상태를 전송\(또는 재전송\)합니다. ExpDataSN은 ExpDataSN과 동일한 DataSN\(또는 R2TSN\)이 있는 Data-In PDU 및/또는 R2T까지\(포함하지 않음\) 전송된 모든 데이터를 승인합니다. 그러나 대상은 정확한 상태를 복구하거나 유지할 수 없는 경우 승인되지 않은 모든 데이터 또는 연결 충성 재할당 시 모든 데이터를 전송/수신하도록 선택할 수 있습니다. 개시자는 이후에 ExpDataSN보다 번호가 낮은\(즉, 승인된 시퀀스 번호 이전\) PDU에 대해 Data SNACK을 통해 데이터 재전송을 요청해서는 안 됩니다. 모든 유형의 명령에 대해 재할당 요청은 작업이 개시자에 의해 여전히 진행 중인 것으로 간주되고 대상이 재할당 요청에 대해 "기능 완료" 응답을 반환하는 경우 작업을 적절하게 종료해야 함을 의미합니다. 이는 필요에 따라 데이터/R2T/상태 PDU의 재전송을 포함할 수 있지만 상태 PDU의 \(재\)전송을 포함해야 합니다.\(SHOULD, SHOULD, MUST NOT, MUST\)

대상이 충성 재할당을 지원하는 것은 선택 사항입니다. 이 기능은 로그인 중에 ErrorRecoveryLevel 텍스트 키를 통해 협상됩니다. 대상이 충성 재할당을 지원하지 않는 경우 "작업 충성 재할당이 지원되지 않음"이라는 작업 관리 응답 코드로 응답해야 합니다. 충성 재할당이 대상에서 지원되지만 작업이 여전히 다른 연결에 충실하거나 이전에 충실한 연결의 성공적인 복구 로그아웃이 수행되지 않은 경우 대상은 "Task still allegiant"의 작업 관리 응답 코드로 응답해야 합니다.\(MAY, MUST, MUST\)

대상에서 충성 재할당을 지원하는 경우 재할당이 유효해지기 전에 재할당 요청에 대한 작업 관리 응답을 발행해야 합니다.\(MUST\)

데이터 입력과 관련된 SCSI 명령이 재할당되면 원래 연결의 최종 응답을 위해 보유하고 있는 모든 SNACK 태그가 삭제되고 대신 기본값인 0을 사용해야 합니다.\(MUST\)

---
### **7.3.  Usage of Reject PDU in Recovery**

타겟은 작업 수명 동안 교환된 PDU에 대해 거부 PDU를 전송하여 활성 작업을 암시적으로 종료해서는 안 됩니다. 대상이 작업을 종료하기로 결정한 경우 작업을 완료하려면 응답 PDU\(SCSI, 텍스트, 작업 등\)가 대상에서 반환되어야 합니다. 거부 이전에 작업이 활성화된 적이 없는 경우\(즉, 거부가 명령 PDU에 있는 경우\) 명령 자체가 삭제되므로 대상은 더 이상 응답을 보내서는 안 됩니다.\(MUST NOT\)

위의 규칙은 수신된 거부가 명령 PDU 자체가 아닌 PDU에 대한 것일 경우 개시자가 결국 거부 수신에 대한 응답을 기대할 수 있음을 의미합니다. 비명령 거부는 오류 기록 시 진단 값만 가지며 개시자의 재전송 결정에 사용될 수 있습니다.

거부된 명령 PDU의 CmdSN\(즉시 명령이 아닌 경우\)은 거부된 명령 PDU의 CmdSN이 대상에 의해 수신된 것으로 간주되어서는 안 됩니다\(즉, CmdSN에 대해 명령 시퀀스 갭이 가정되어야 함\). 확실하게 확인할 수 있습니다. 거부를 수신한 후 개시자는 세션을 계속 사용하려면 CmdSN 간격을 연결해야 합니다. 동일한 CmdSN을 사용하여 명령 PDU를 전송하거나 작업을 중단하여 간격을 막을 수 있습니다\(중단이 CmdSN 간격을 막는 방법에 대한 정보는 섹션 7.11 참조\).\(MUST NOT, MUST\)

데이터 PDU가 거부되고 해당 DataSN이 확인될 수 있는 경우 복구 R2T가 생성되는 경우 대상은 현재 데이터 버스트에 대한 ExpDataSN을 진행해야 합니다. 대상은 손실된 데이터 PDU를 복구하려고 시도하지 않는 경우 ExpDataSN을 진행할 수 있습니다.\(MUST, MAY\)

---
### **7.4.  Error Recovery Considerations for Discovery Sessions**
---
#### **7.4.1.  ErrorRecoveryLevel for Discovery Sessions**

검색 세션\(예: "SessionType=Discovery"를 협상한 세션\)에는 ErrorRecoveryLevel 키 협상이 필요하지 않습니다. 검색 세션에는 기본값 0이 필요하고 충분하기 때문입니다. 그러나 일부 레거시 iSCSI 구현에서는 검색 세션에서 ErrorRecoveryLevel 키 협상을 시도할 수도 있습니다. 원격 측에서 이러한 협상을 시도하는 경우 호환되는 iSCSI 구현은 응답으로 0\(영\) 값을 제안해야 합니다. 따라서 Discovery 세션에 대한 운영 ErrorRecoveryLevel은 0이어야 합니다. 이는 자연스럽게 섹션 4.3이 Discovery 세션에 부과하는 기능 제약 조건을 따릅니다.\(MUST, MUST\)

---
#### **7.4.2.  Reinstatement Semantics for Discovery Sessions**

검색 세션은 상대적으로 수명이 짧습니다. 개시자는 동일한 iSCSI 네트워크 포털에 대해 여러 검색 세션을 설정할 것으로 예상되지 않습니다. 개시자는 서로 다른 대상 및/또는 서로 다른 포털 그룹으로 서로 다른 고유 세션을 설정할 때 동일한 iSCSI 개시자 이름 및 ISID를 사용할 수 있습니다. 이 동작은 섹션 10.1.1에서 논의되며 실제로 ISID의 보수적인 재사용을 권장합니다.

섹션 4.4.3의 ISID 규칙에는 일치하는 4-튜플\(<InitiatorName, ISID, TargetName, TargetPortalGroupTag\>\)이 있는 세션이 두 개 이상 있어서는 안 된다고 명시되어 있습니다. ISID RULE의 정신은 일반 세션과 동일하게 Discovery 세션에 적용되지만 일부 Discovery 세션은 두 가지 중요한 측면에서 일반 세션과 다릅니다.

- a\) 부록 C에서는 로그인 요청 PDU에 TargetName 키를 지정하지 않고 검색 세션을 설정할 수 있으므로\(이러한 세션을 "이름 없는" 검색 세션이라고 함\) ISID 규칙을 적용할 대상 노드 컨텍스트가 없습니다.

- b\) 포털 그룹은 대상 노드의 컨텍스트에서만 정의됩니다. TargetName 키가 NULL 값인 경우\(즉, 지정되지 않음\) ISID 규칙을 적용하기 위해 TargetPortalGroupTag를 확인할 수 없습니다.

다음 두 섹션에서는 각각 명명된 검색 세션과 명명된 검색 세션을 설명합니다.

---
##### **7.4.2.1.  Unnamed Discovery Sessions**

이름 없는 검색 세션의 경우 ISID 규칙을 적용하기 위해 TargetName이나 TargetPortalGroupTag를 대상에 사용할 수 없습니다. 따라서 다음 규칙이 적용됩니다.

이름 없는 ISID 규칙: 대상은 이름 없는 검색 세션에 대해 <InitiatorName, ISID, NULL, TargetAddress\> 4개 튜플의 고유성을 적용해야 합니다. 이 고유성 요구 사항은 다음과 같은 의미를 암시합니다.\(MUST\)

대상은 지정된 iSCSI 노드 이름과 ISID를 가진 동일한 개시자 포트를 통해 각 네트워크 포털과 하나의 검색 세션을 동시에 설정할 수 있도록 허용해야 합니다\(SHOULD\). 동일한 개시자 포트에 의해 다른 네트워크 포털에 설정된 경우 각각의 동시 검색 세션은 독립적인 세션으로 처리되어야 합니다. 즉, 한 세션이 다른 세션을 복원해서는 안 됩니다.\(SHOULD, MUST NOT\)

<InitiatorName, ISID, NULL, TargetAddress\>가 기존 Discovery 세션과 일치하는 새로운 명명되지 않은 Discovery 세션은 기존 명명되지 않은 Discovery 세션을 복원해야 합니다. 따라서 이름 없는 검색 세션만 다른 이름 없는 검색 세션을 복원할 수 있습니다.\(MUST\)

---
##### **7.4.2.2.  Named Discovery Sessions**

명명된 검색 세션의 경우 TargetName 키는 개시자에 의해 지정되므로 대상은 TargetPortalGroupTag도 명확하게 확인할 수 있습니다. 4-튜플의 네 가지 요소가 모두 알려져 있으므로 ISID 규칙은 섹션 4.4.3 의미 체계를 변경하지 않고 대상에 의해 시행되어야 합니다. 따라서 <InitiatorName, ISID, TargetName, TargetPortalGroupTag\>가 일치하는 새 세션은 기존 세션을 복원합니다. 이 경우 일치하는 4-튜플이 있는 새 iSCSI 세션\(검색 또는 일반\)은 기존 명명된 검색 iSCSI 세션을 복원할 수 있습니다.\(MUST\)

---
#### **7.4.3.  Target PDUs during Discovery**

대상은 전체 기능 단계에서 검색 세션에 대한 텍스트 응답 및 로그아웃 응답 이외의 응답을 보내면 안 됩니다.\(SHOULD NOT\)

구현 참고 사항: 대상은 일반 세션에서 비동기 메시지를 통해 로그아웃을 요청한 경우 검색 세션에서 단순히 연결을 끊을 수 있습니다.

---
### **7.5.  Connection Timeout Management**

iSCSI는 iSCSI 전체 기능 단계 연결이 의도적으로 또는 예외로 인해 서비스가 중단될 때 적용할 수 있는 두 가지 세션 전역 시간 초과 값\(초\), 즉 Time2Wait 및 Time2Retain을 정의합니다. Time2Wait는 문제의 CID에 대해 명시적/암시적 로그아웃을 시도하거나 영향을 받는 작업\(있는 경우\)에 대한 작업 재할당을 시도하기 전의 초기 "휴식 시간"입니다. Time2Retain은 가능한 복구 시도를 제공하기 위해 작업 및/또는 연결 상태가 대상에서 유지되도록 보장되는 초기 휴식 간격 이후의 최대 시간입니다. 연결 및/또는 작업에 대한 복구 시도는 Time2Wait 초 이전에 이루어져서는 안 되지만 초기 Time2Wait 대기 기간 이후 Time2Retain 초 이내에 완료되어야 합니다.\(MUST\)

---
#### **7.5.1.  Timeouts on Transport Exception Events**

이전 iSCSI 프로토콜 상호 작용 없이 전송 연결을 종료하거나 전송을 재설정하면 엔드포인트에 사실을 알리면 전체 기능 단계 iSCSI 연결이 갑자기 종료됩니다. 이 경우 사용되는 시간 초과 값은 세션에 대해 협상된 DefaultTime2Wait\(섹션 13.15\) 및 DefaultTime2Retain\(섹션 13.16\) 텍스트 키 값입니다.

---
#### **7.5.2.  Timeouts on Planned Decommissioning**

전체 기능 단계 iSCSI 연결의 계획된 폐기는 로그아웃 응답 PDU 또는 비동기 메시지 PDU가 선행됩니다. 로그아웃 응답 PDU의 Time2Wait 및 Time2Retain 필드 값\(섹션 11.15\)과 비동기 메시지의 Parameter2 및 Parameter3 필드\(AsyncEvent 유형은 "연결 끊기" 또는 "모든 연결 끊기", 섹션 11.9.1 참조\)를 지정합니다. 이러한 각 경우에 사용되는 시간 초과 값입니다.

이러한 시간 초과 값은 영향을 받는 연결과 해당 연결에서 활성화된 작업에만 적용됩니다. 이러한 시간 초과 값은 해당 세션과 관련된 연결이나 작업에서 이미 실행 중인 개시자 타이머\(있는 경우\)와 관련이 없습니다.

---
### **7.6.  Implicit Termination of Tasks**

다음과 같은 경우 iSCSI 프로토콜 역학으로 인해 대상이 활성 작업을 암시적으로 종료합니다.

- a\) "연결 종료"라는 이유 코드와 함께 연결이 암시적 또는 명시적으로 로그아웃되고 해당 연결과 관련된 활성 작업이 있는 경우.

- b\) 연결이 실패하고 결국 연결 상태가 시간 초과되고\(섹션 8.2.2의 상태 전환 M1\) 해당 연결에 해당하는 활성 작업이 있는 경우.

- c\) 해당 연결과 관련된 활성 작업이 있는 동안 "복구를 위해 연결 제거"라는 이유 코드와 함께 성공적인 로그아웃이 수행되고 해당 작업이 결국 충성 재할당 없이 Time2Wait 및 Time2Retain 기간 후에 시간 초과되는 경우.

- d\) "세션 종료"라는 이유 코드와 함께 연결이 암시적 또는 명시적으로 로그아웃되고 해당 세션에 활성 작업이 있는 경우.

위의 a\), b\), c\), d\)의 경우에 종료된 작업이 SCSI 작업인 경우에는 CHECK CONDITION 상태와 마찬가지로 내부적으로 종료되어야 합니다. 이 상태는 내부 SCSI 상태 및 주문과 관련된 SCSI 부작용을 적절하게 처리하는 데에만 의미가 있습니다. 왜냐하면 이 상태는 개시자에게 종료 상태로 다시 전달되지 않기 때문입니다. 그러나 SCSI 표준에 정의된 SCSI 컨텍스트\(예: 대기 중인 명령 및 ACA, a\), b\)의 경우 I\_T 넥서스의 다음 명령에 대한 UA에 따라 SCSI 수준에서 추가 작업을 수행해야 할 수도 있습니다. 그리고 c\) 등 - \[SAM2\] 및 \[SPC3\] 참조\).

---
### **7.7.  Format Errors**

PDU 레이아웃 규칙에 대한 다음 두 가지 명시적인 위반은 형식 오류입니다.

- a\) Opcode를 제외한 모든 PDU 헤더 필드의 잘못된 내용\(합법적인 값은 섹션 11에 명시되어 있음\)

- b\) 일관되지 않은 필드 내용\(일관적인 필드 내용은 섹션 11에 지정되어 있음\).

형식 오류는 당사자 중 하나의 주요 구현 결함을 나타냅니다.

대상 또는 개시자가 형식 오류가 있는 iSCSI PDU를 수신하면 연결 닫기 또는 연결 재설정을 통해 세션의 모든 전송 연결을 즉시 종료하고 형식 오류를 세션 복구로 에스컬레이션해야 합니다\(섹션 7.1.4.4 참조\). .\(MUST\)

모든 개시자 감지 PDU 구성 오류는 형식 오류로 간주되어야 합니다. 이러한 오류의 몇 가지 예는 다음과 같습니다.\(MUST\)

- - TTT는 유효하지만 LUN이 유효하지 않은 NOP-In

- - 유효한 ITT\(예: NOP-In 응답\) 및 유효한 TTT를 사용한 NOP-In

- Status=CHECK CONDITION인 SCSI 응답 PDU, 그러나

- DataSegmentLength = 0

---
### **7.8.  Digest Errors**

다이제스트 오류 처리 시 법적 선택에 관한 아래 논의에서는 세션 복구를 명시적 옵션으로 제외하지만 다이제스트 오류를 ​​감지한 당사자 중 어느 쪽이든 오류를 세션 복구로 에스컬레이션하도록 선택할 수 있습니다.

대상 또는 개시자가 헤더 다이제스트 오류가 있는 iSCSI PDU를 수신하면 헤더와 이후 PDU 시작 부분까지의 모든 데이터를 삭제하거나 연결을 닫아야 합니다. 다이제스트 오류는 헤더의 길이 필드가 손상되었을 수 있음을 나타내기 때문에 이후 PDU의 시작 위치는 동기화 및 조정 계층의 작동과 같은 다른 수단을 통해 안정적으로 확인되어야 합니다.\(MUST\)

대상이 페이로드 다이제스트 오류가 있는 iSCSI PDU를 수신하면 이유 코드가 Data-Digest-Error인 PDU 거부로 응답하고 PDU를 폐기해야 합니다.\(MUST\)

- 폐기된 PDU가 요청 또는 요청되지 않은 iSCSI 데이터 PDU인 경우\(명령 PDU의 즉각적인 데이터에 대해 아래의 비데이터 PDU 규칙이 적용됨\) 대상은 다음 중 하나를 수행해야 합니다.\(MUST\)

a\) 복구 R2T를 사용하여 재전송을 요청합니다.

b\) CHECK CONDITION 상태 및 iSCSI 조건이 "프로토콜 서비스 CRC 오류"인 SCSI 응답 PDU를 사용하여 작업을 종료합니다\(섹션 11.4.7.2\). 대상이 이 옵션을 구현하기로 선택한 경우 SCSI 응답 PDU를 전송하기 전에 모든 데이터\(모든 미해결 R2T에 대해 최종 비트가 설정된 데이터 PDU에 의해 신호됨\)를 수신할 때까지 기다려야 합니다. 이 대기 중에 개시자의 작업 관리 명령\(예: ABORT TASK\)으로 인해 작업이 종료될 수도 있습니다.\(MUST\)

- 폐기된 PDU가 비데이터 PDU인 경우 대상에 대한 추가 조치가 필요하지 않습니다. 폐기된 명령에 즉시 데이터가 존재하는 경우 작업이 재시도되면 즉시 데이터가 암시적으로 복구되고\(섹션 7.2.1 참조\) 작업에 대한 전체 데이터 전송이 이어집니다.

개시자가 페이로드 다이제스트 오류가 있는 iSCSI PDU를 수신하면 PDU를 폐기해야 합니다.\(MUST\)

- - 폐기된 PDU가 iSCSI 데이터 PDU인 경우 개시자는 다음 중 하나를 수행해야 합니다.\(MUST\)

- a\) SNACK을 통해 원하는 데이터 PDU를 요청합니다. SNACK에 대한 응답으로 타겟은 데이터 PDU를 재전송하거나 이유 코드가 "SNACK 거절"인 거부 PDU를 사용하여 SNACK을 거부해야 합니다. 이 경우:\(MUST\)

- a.1\) 명령에 대한 상태가 아직 전송되지 않은 경우 대상은 CHECK CONDITION 상태 및 iSCSI 조건 "SNACK 거부됨"\(섹션 11.4.7.2\)으로 명령을 종료해야 합니다.\(MUST\)

- a.2\) 상태가 이미 전송된 경우 대상에 대한 추가 조치가 필요하지 않습니다. 이 경우 개시자는 상태가 수신될 때까지 기다린 다음 이를 폐기해야 합니다. 그래야 내부적으로 CHECK CONDITION 상태 및 "프로토콜 서비스 CRC 오류"\(섹션 11.4.7.2\)의 iSCSI 조건으로 완료를 알릴 수 있습니다.\(MUST\)

- b\) 작업을 중단하고 오류와 함께 명령을 종료합니다.

- - 폐기된 PDU가 응답 PDU이거나 요청되지 않은 PDU\(예: 비동기, 거부\)인 경우 개시자는 다음 중 하나를 수행해야 합니다.\(MUST\)

- a\) SNACK 상태로 PDU 재전송을 요청합니다.

- b\) 복구를 위해 연결을 로그아웃하고 섹션 7.2에 설명된 대로 다른 연결 인스턴스에서 작업을 계속합니다.

- c\) 연결을 종료하려면 로그아웃합니다\(연결과 관련된 모든 명령을 중단합니다\).

- 원치 않는 PDU는 iSCSI 연결에서 다음 StatSN 값을 전달하여 StatSN을 향상시킵니다. 개시자가 페이로드 다이제스트 오류로 인해 이러한 PDU 중 하나를 폐기하는 경우 헤더를 포함한 전체 PDU를 폐기해야 합니다. 결과적으로 개시자는 예외를 요청된 다른 응답 PDU의 손실처럼 처리해야 합니다.\(MUST, MUST\)

---
### **7.9.  Sequence Errors**

개시자가 잘못된 R2TSN/DataSN이 포함된 iSCSI R2T/데이터 PDU 또는 누락된 데이터 PDU를 암시하는 ExpDataSN이 포함된 SCSI 응답 PDU를 수신하는 경우 이는 개시자가 헤더 또는 페이로드 다이제스트를 감지했음을 의미합니다. 하나 이상의 이전 R2T/데이터 PDU에서 오류가 발생했습니다.

개시자는 섹션 7.8에 설명된 대로 이러한 묵시적인 다이제스트 오류를 ​​해결해야 합니다. 대상이 순서가 잘못된 DataSN이 포함된 데이터 PDU를 수신하는 경우 이는 대상이 이전 데이터 PDU 중 하나 이상에서 헤더 또는 페이로드 다이제스트 오류에 도달했음을 의미합니다. 타겟은 섹션 7.8에 설명된 대로 이러한 묵시적인 다이제스트 오류를 ​​해결해야 합니다.\(MUST, MUST\)

개시자가 누락된 응답을 암시하는 순서가 잘못된 StatSN이 있는 iSCSI 상태 PDU를 수신하면 섹션 7.8에 설명된 대로 하나 이상의 누락된 상태 PDU를 처리해야 합니다. 누락된 응답 수신의 부작용으로 개시자는 누락된 데이터 PDU를 발견할 수 있습니다. 개시자가 명령에 대해 누락된 데이터를 복구하려는 경우 명령의 모든 데이터 PDU 수신을 완료할 때까지 관련 명령의 StatSN에서 시작하는 수신 응답을 확인해서는 안 됩니다.\(MUST, MUST NOT\)

개시자가 중복 R2TSN\(대상에 의한 사전 R2T 재전송으로 인해\) 또는 중복 DataSN\(초기자에 의한 사전 SNACK으로 인해\)을 수신하는 경우 중복 항목을 폐기해야 합니다.\(MUST\)

---
### **7.10.  Message Error Checking**

현재까지의 iSCSI 구현에서는 인바운드 메시지를 처리하는 데 엄격하게 요구되는 것 이상으로 들어오는 메시지에서 프로토콜 오류를 확인해야 하는 범위와 관련하여 약간의 불확실성이 있었습니다. 이 섹션에서는 이 질문을 다룹니다.

이 문서에서 요구하지 않는 한, 들어오는 iSCSI PDU에 대한 철저한 프로토콜 적합성 검사를 수행하기 위해 iSCSI 구현이 필요하지 않습니다. 특히 iSCSI 구현에서는 원격 iSCSI 구현이 프로토콜 요구 사항을 준수하는지 다시 확인하는 데 필요하지 않습니다.

---
### **7.11.  SCSI Timeouts**

iSCSI 초기자는 섹션 7.2에 설명된 대로 승인되지 않은 명령을 재시도하여 ULP 시간 초과 전에 대상 끝에서 명령 시퀀스 간격을 연결하려고 시도할 수 있습니다\(ExpCmdSN을 통한 명령 승인이 없는 경우\).\(MAY\)

명령\(n의 CmdSN을 전달하는\)에 대한 ULP 시간 초과 시 iSCSI 초기자가 세션을 계속하려는 경우 특정 명령에 대한 적절한 작업 관리 기능 요청 또는 "연결 닫기"를 사용하여 명령을 중단해야 합니다. 로그 아웃.\(MUST\)

ABORT TASK를 사용할 때 ExpCmdSN이 여전히 \(n + 1\)보다 작으면 대상은 다음 이유 중 하나로 인해 원래 명령 자체가 누락된 채 중단 요청을 볼 수 있습니다.

- - 다이제스트 오류로 인해 원래 명령이 삭제되었습니다.

- - 원래 명령이 전송된 연결이 성공적으로 로그아웃되었습니다. 로그아웃 시, 로그아웃 중인 연결에서 실행된 승인되지 않은 명령은 삭제됩니다.

중단 요청이 수신되고 원래 명령이 누락된 경우 대상은 해당 RefCmdSN이 포함된 원래 명령을 수신된 것으로 간주하고 응답 코드 "기능 완료"와 함께 작업 관리 응답을 발행해야 합니다. 이 응답으로 양쪽 끝에서 작업이 종료됩니다. 중단 요청이 수신되고 대상이 명령이 수신 및 실행되었으며 응답이 중단 이전에 전송되었음을 확인할 수 있는 경우\(참조된 작업 태그를 기반으로\) 대상은 응답 코드 "Task"로 응답해야 합니다. 존재하지 않는다".\(MUST, MUST\)

---
### **7.12.  Negotiation Failures**

작동 매개변수를 설정/협상하는 데 사용되는 텍스트 요청 및 응답 시퀀스는 협상/매개변수 설정을 구성합니다. 협상 실패는 다음 중 하나 이상으로 간주됩니다.

- - 협상된 키의 경우 협상 당사자 중 어느 쪽도 선택 사항을 받아들일 수 없습니다.

- - 선언적 키의 경우 선언된 값은 협상 상대방이 수락할 수 없습니다.

- - 텍스트 요청 시간이 초과되어 종료되었을 수 있습니다.

- - 문자 요청이 거부 PDU로 응답되었습니다.

협상 실패를 해결하려면 다음 두 가지 규칙을 사용해야 합니다.

- a\) 로그인 중 협상 실패는 반드시 로그인 프로세스 실패로 간주되어야 합니다. 연결과 함께 로그인 단계를 종료해야 합니다. 대상이 실패를 감지하면 적절한 로그인 응답 코드를 사용하여 로그인을 종료해야 합니다.\(MUST\)

- b\) 전체 기능 단계 중 협상이 실패하면 동일한 개시자 작업 태그를 사용하는 일련의 텍스트 요청으로 구성될 수 있는 전체 협상 순서가 종료됩니다. 세션 또는 연결의 작동 매개변수는 이전의 성공적인 협상 중에 합의된 값이어야 합니다\(즉, 이 실패한 협상의 모든 부분 결과는 적용되어서는 안 되며 폐기되어야 합니다\).\(MUST NOT\)

---
### **7.13.  Protocol Errors**

TCP와 같은 "스트리밍" 연결을 통해 프레임 메시지를 매핑하면 제안된 메커니즘이 단순한 소프트웨어 프레이밍 오류에 취약해집니다. 반면에 이러한 오류의 영향을 제한하기 위해 프레이밍 메커니즘을 도입하면 간단한 구현의 경우 성능에 부담을 줄 수 있습니다. 명령 시퀀스 번호와 연결 삭제 및 재설정 메커니즘\(앞의 섹션 7 및 하위 섹션에서 설명\)은 이러한 유형의 매핑 오류를 처리하는 데 도움이 됩니다.

이 문서에 지정된 iSCSI PDU 교환 순서에 대한 모든 위반도 프로토콜 오류입니다. 이 오류 범주는 구현을 수정해야만 해결할 수 있습니다. iSCSI는 이를 활성화하기 위해 거부 및 응답 코드를 정의합니다.

---
### **7.14.  Connection Failures**

iSCSI는 개시자와 대상 사이에 적시에 하나 이상의 TCP 연결을 유지/설정할 수 있는 경우 세션을 계속 작동할 수 있습니다. 대상 및/또는 개시자는 전송 수준 수단\(TCP\), 명령 시퀀스 번호의 공백, 오랫동안 채워지지 않은 응답 스트림 또는 실패한 iSCSI NOP\(핑 역할을 함\)를 통해 연결 실패를 인식할 수 있습니다. \). 후자는 연결 실패 감지 속도와 가능성을 높이기 위해 주기적으로 사용될 수 있습니다. 전송 수준 수단의 예로서 개시자와 대상은 유휴 링크에서 조기 링크 실패 감지를 활성화하기 위해 TCP 연결에서 연결 유지 옵션\(\[RFC1122\] 참조\)을 사용할 수도 있습니다.\(MAY, MAY\)

연결 실패 시 개시자와 대상은 다음 중 하나를 수행해야 합니다.\(MUST\)

- a\) 세션 내에서 연결 복구를 시도합니다\(연결 복구\).

b\) "close the"라는 이유 코드로 연결을 로그아웃합니다.

- 연결"\(섹션 11.14.5\), 누락된 명령을 재발행하고 모든 활성 명령을 암시적으로 종료합니다. 이 옵션에는 연결 내 복구 클래스\(연결 내 복구\)에 대한 지원이 필요합니다.

```text
      c) Perform session recovery (Session Recovery).
```

어느 쪽이든 세션 복구로 에스컬레이션하도록 선택할 수 있으며\(모든 연결을 삭제하는 개시자를 통해 또는 대상의 유사한 의도를 알리는 비동기 메시지를 통해\), 다른 쪽은 이에 우선 순위를 부여해야 합니다. 연결 실패 시 대상은 위의 옵션 중 어떤 옵션이 사용되는지에 관계없이 모든 활성 즉시 명령을 종료 및/또는 폐기해야 합니다\(즉, 연결 실패 시 즉시 명령을 복구할 수 없음\).\(MUST, MUST\)

---
### **7.15.  Session Errors**

세션의 모든 연결이 실패하여 짧은 시간 내에 다시 설정할 수 없는 경우 또는 개시자가 프로토콜 오류를 반복적으로 감지하는 경우 개시자는 세션을 종료하고 새 세션을 설정하도록 선택할 수 있습니다.

이 경우 개시자는 다음 작업을 수행합니다.

- - 모든 전송 연결을 재설정하거나 닫습니다.

- - 새 세션을 시작하기 전에 적절한 응답으로 미해결 요청을 모두 종료합니다. 동일한 I\_T 넥서스를 재설정하려는 경우 개시자는 세션 복원을 사용해야 합니다\(섹션 6.3.5 참조\).\(MUST\)

대상에서 세션 시간 초과\(마지막 실패한 연결에 대한 연결 상태 시간 초과\)가 발생하면 다음 작업을 수행합니다.

- - TCP 연결을 재설정하거나 닫습니다\(세션을 닫습니다\).

-에 충실한 모든 활성 작업을 종료합니다.

- 세션을 구성한 연결.

또한 대상은 세션 오류를 해결할 수 있는 개시자의 세션 복원 요청을 처리할 준비가 되어 있어야 합니다.\(MUST\)

---
## **8.  State Transitions**

iSCSI 연결 및 iSCSI 세션은 생성된 시점부터 삭제되는 시점까지 잘 정의된 여러 상태를 거칩니다.

연결 상태 전환은 이해하기 쉽도록 두 개의 개별적이지만 종속적인 상태 다이어그램 세트로 설명됩니다. 첫 번째 다이어그램 세트인 "표준 연결 상태 다이어그램"은 iSCSI 연결이 명시적 또는 암시적 로그아웃을 통한 정리를 기다리거나 진행 중이지 않을 때의 연결 상태 전환을 설명합니다. 두 번째 세트인 "연결 정리 상태 다이어그램"은 iSCSI 연결 정리를 수행하는 동안의 연결 상태 전환을 설명합니다. 첫 번째 세트에는 개시자와 대상에 대해 각각 하나씩 두 개의 다이어그램이 있는 반면, 두 번째 세트에는 개시자와 대상 모두에 적용할 수 있는 단일 다이어그램이 있습니다.

"세션 상태 다이어그램"은 iSCSI 세션이 수명 동안 거치는 상태 전환을 설명하며 세션에 참여하는 여러 iSCSI 연결의 상태에 따라 달라집니다.

상태와 전환은 텍스트, 표, 다이어그램으로 설명됩니다. 다이어그램은 설명을 위해 사용됩니다. 텍스트와 표가 주요 사양입니다.

---
### **8.1.  Standard Connection State Diagrams**
---
#### **8.1.1.  State Descriptions for Initiators and Targets**

표준 연결 상태 다이어그램의 상태 설명은 다음과 같습니다.

```text
   S1: FREE
```

- 개시자: 인스턴스화 시 또는 성공 후의 상태

- 연결 종료.

- 대상: 인스턴스화 시 또는 성공 후 상태

- 연결 종료.

```text
   S2: XPT_WAIT
```

- 개시자: 전송에 대한 응답을 기다리는 중입니다.

- 연결 설정 요청.

```text
       - target: Illegal.

   S3: XPT_UP

       - initiator: Illegal.
```

- - 대상: 로그인 프로세스가 시작되기를 기다리는 중입니다.

```text
   S4: IN_LOGIN
```

- 개시자: 로그인 프로세스가 완료되기를 기다리는 중,

- 여러 PDU 교환이 포함될 수 있습니다.

- 대상: 로그인 프로세스가 완료되기를 기다리는 중,

- 여러 PDU 교환이 포함될 수 있습니다.

```text
   S5: LOGGED_IN
```

- 개시자: 전체 기능 단계에서 모든 기능을 기다리는 중입니다.

- 내부, iSCSI 및 전송 이벤트.

- - 대상: 전체 기능 단계에서 모든 내부, iSCSI 및 전송 이벤트를 기다립니다.

```text
   S6: IN_LOGOUT
```

- - 개시자: 로그아웃 응답을 기다리는 중입니다.

- - 대상: 로그아웃 처리 완료를 알리는 내부 이벤트를 기다리는 중입니다.

```text
   S7: LOGOUT_REQUESTED
```

- 개시자: 내부 이벤트 신호를 기다리는 중

- 로그아웃을 진행할 준비가 되었습니다.

- 대상: 로그아웃 프로세스가 시작되기를 기다리는 중

- 비동기 메시지를 통해 로그아웃을 요청한 경우.

```text
   S8: CLEANUP_WAIT
```

- 개시자: 컨텍스트 및/또는 리소스가

- 이 CSM에 대한 정리 처리를 시작합니다.

- - 대상: 이 CSM에 대한 정리 프로세스가 시작되기를 기다리는 중입니다.

---
#### **8.1.2.  State Transition Descriptions for Initiators and Targets**

```text
   T1:
```

- - 개시자: 전송 연결 요청이 이루어졌습니다\(예: TCP SYN 전송\).

```text
       - target: Illegal.

   T2:
```

- 개시자: 전송 연결 요청 시간이 초과되었습니다.

- 전송 재설정이 수신되었거나 "세션 종료" 로그아웃 요청에 대한 다른 연결에서 로그아웃 응답\(성공\)을 수신하는 내부 이벤트가 수신되었습니다.

```text
       - target: Illegal.

   T3:

       - initiator: Illegal.
```

- - 대상: 전송 연결을 설정하는 유효한 전송 연결 요청을 받았습니다.

```text
   T4:
```

- 개시자: 전송 연결이 설정되었으므로

- 개시자에게 iSCSI 로그인을 시작하라는 메시지를 표시합니다.

- - 대상: 초기 iSCSI 로그인 요청이 수신되었습니다.

```text
   T5:
```

- - 개시자: 상태 클래스가 0인 최종 iSCSI 로그인 응답을 받았습니다.

- 대상: 최종 iSCSI 로그인 요청을 마무리합니다.

- 로그인 단계가 수신되었으므로 대상이 상태 클래스가 0인 최종 iSCSI 로그인 응답을 보내도록 요청합니다.

```text
   T6:

       - initiator: Illegal.
```

- - 대상: iSCSI 로그인 대기 시간이 초과되었거나, 전송 연결 해제 표시가 수신되었거나, 전송 재설정이 수신되었거나, 전송 시간 초과를 나타내는 내부 이벤트가 수신되었습니다. 이 모든 경우에는 연결이 닫혀야 합니다.

```text
   T7:
```

- - 개시자: 다음 이벤트 중 하나로 전환이 발생했습니다.

a\) 최종 iSCSI 로그인 응답이 다음과 함께 수신되었습니다.

- 0이 아닌 상태 클래스.

```text
         b) Login timed out.
```

- c\) 전송 연결 끊김 표시가 수신되었습니다.

- d\) 전송 재설정이 수신되었습니다.

- e\) 전송 시간 초과를 나타내는 내부 이벤트가 수신되었습니다.

f\) 로그아웃 응답을 수신하는 내부 이벤트

- \(성공\) 다른 연결에서 "세션 닫기" 로그아웃 요청이 수신되었습니다.

- 이 모든 경우에는 운송 연결이 종료됩니다.

- - 대상: 다음 이벤트 중 하나로 전환이 발생했습니다.

a\) 로그인을 완료하기 위한 최종 iSCSI 로그인 요청

- 단계가 수신되었으며 대상이 0이 아닌 상태 클래스로 최종 iSCSI 로그인 응답을 보내도록 요청했습니다.

```text
         b) Login timed out.
```

- c\) 전송 연결 끊김 표시가 수신되었습니다.

- d\) 전송 재설정이 수신되었습니다.

- e\) 전송 시간 초과를 나타내는 내부 이벤트가 수신되었습니다.

- f\) 다른 연결에서 "세션 닫기" 로그아웃 요청이 수신되었습니다.

- 이 모든 경우에는 연결이 종료됩니다.

```text
   T8:
```

- 개시자: 로그아웃을 수신하는 내부 이벤트

- "세션 닫기"에 대한 다른 연결의 응답\(성공\) 로그아웃 요청이 수신되었으므로 이 연결이 닫히고 추가 정리가 필요하지 않습니다.

- 대상 : 로그아웃 응답을 보내는 내부 이벤트

- \(성공\) "세션 닫기"에 대한 다른 연결에서 로그아웃 요청이 수신되었거나 성공적인 연결/세션 복원에 대한 내부 이벤트가 수신되어 대상이 이 연결을 완전히 닫도록 요청합니다.

```text
   T9, T10:
```

- - 개시자: 로그아웃 프로세스를 시작할 준비가 되었음을 나타내는 내부 이벤트가 수신되어 개시자가 iSCSI 로그아웃을 보내도록 요청합니다.

- - 대상: iSCSI 로그아웃 요청이 수신되었습니다.

```text
   T11, T12:
```

- - 개시자: AsyncEvent "로그아웃 요청"이 포함된 비동기 PDU가 수신되었습니다.

- - 대상: 연결 해제가 필요한 내부 이벤트가 수신되어 AsyncEvent "로그아웃 요청"이 포함된 비동기 PDU가 전송되었습니다.

```text
   T13:
```

- - 개시자: iSCSI 로그아웃 응답\(성공\)을 수신했거나 "세션 종료" 로그아웃 요청에 대한 다른 연결에서 로그아웃 응답\(성공\)을 수신하는 내부 이벤트를 수신했습니다.

- 대상: 다음을 나타내는 내부 이벤트가 수신되었습니다.

- 로그아웃이 성공적으로 처리되어 iSCSI 로그아웃 응답\(성공\)이 전송됩니다. "세션 종료" 로그아웃 요청에 대한 다른 연결에서 로그아웃 응답\(성공\)을 보내는 내부 이벤트가 수신되었습니다. 또는

성공적인 연결/세션의 내부 이벤트

- 복원이 접수되었습니다. 이 모든 경우에 전송 연결이 닫힙니다.

```text
   T14:
```

- - 개시자: AsyncEvent "로그아웃 요청"이 포함된 비동기 PDU가 다시 수신되었습니다.

```text
       - target: Illegal.

   T15, T16:
```

- - 개시자: 다음 이벤트 중 하나 이상이 이 전환을 일으켰습니다.

- a\) 전송 연결 시간 초과를 나타내는 내부 이벤트가 수신되어 전송 재설정 또는 전송 연결 종료가 발생했습니다.

- b\) 전송 재설정이 수신되었습니다.

- c\) 전송 연결 끊김 표시가 수신되었습니다.

- d\) AsyncEvent "연결 끊기"\(이 CID에 대한\)가 포함된 비동기 PDU가 수신되었습니다.

- e\) AsyncEvent "모든 연결 삭제"가 포함된 비동기 PDU가 수신되었습니다.

- - 대상: 다음 이벤트 중 하나 이상으로 인해 이 전환이 발생했습니다.

- a\) 전송 연결 시간 초과가 수신되어 전송 재설정 또는 전송 연결 종료가 발생했음을 나타내는 내부 이벤트입니다.

b\) 실패한 연결/세션의 내부 이벤트

- 복원이 접수되었습니다.

- c\) 전송 재설정이 수신되었습니다.

- d\) 전송 연결 끊김 표시가 수신되었습니다.

- e\) AsyncEvent "연결 끊기"\(이 CID에 대해\) 또는 "모든 연결 끊기" 이벤트와 함께 비동기 PDU를 표시하는 내부 긴급 정리 이벤트가 수신되었습니다.

```text
   T17:
```

- - 개시자: 다음 이벤트 중 하나 이상이 이 전환을 일으켰습니다.

- a\) 로그아웃 응답\(실패, 즉 0이 아닌 상태\)이 수신되었거나 로그아웃 시간이 초과되었습니다.

- b\) T15 및 T16에 지정된 이벤트가 발생했습니다.

- - 대상: 다음 이벤트 중 하나 이상으로 인해 이 전환이 발생했습니다.

a\) 장치의 실패를 나타내는 내부 이벤트

- 로그아웃 처리가 수신되었습니다. 이는 로그아웃 응답\(실패, 즉 0이 아닌 상태\)을 전송하라는 메시지를 표시합니다.

- b\) T15 및 T16에 지정된 이벤트가 발생했습니다.

```text
   T18:
```

- 개시자: 로그아웃을 수신하는 내부 이벤트

- 다른 연결에서 "세션 종료" 로그아웃 요청에 대한 응답\(성공\)이 수신되었습니다.

- 대상 : 로그아웃 응답을 보내는 내부 이벤트

- \(성공\) "세션 닫기"에 대한 다른 연결에서 로그아웃 요청이 수신되었거나 성공적인 연결/세션 복원에 대한 내부 이벤트가 수신되었습니다. 두 경우 모두 연결이 닫힙니다.

CLEANUP\_WAIT 상태\(S8\)는 결론에 도달하지 않았으며 여전히 사용 중인 것으로 간주되는 iSCSI 작업이 있음을 의미합니다.

---
#### **8.1.3.  Standard Connection State Diagram for an Initiator**

상태의 상징적 이름:

```text
      S1: FREE

      S2: XPT_WAIT

      S4: IN_LOGIN

      S5: LOGGED_IN

      S6: IN_LOGOUT

      S7: LOGOUT_REQUESTED

      S8: CLEANUP_WAIT
```

상태 S5, S6 및 S7은 연결의 전체 기능 단계 작업을 구성합니다.

상태 다이어그램은 다음과 같습니다.

```text
                        -------<-------------+
            +--------->/ S1    \<----+       |
         T13|       +->\       /<-+   \      |
            |      /    ---+---    \   \     |
            |     /        |     T2 \   |    |
            |  T8 |        |T1       |  |    |
            |     |        |        /   |T7  |
            |     |        |       /    |    |
            |     |        |      /     |    |
            |     |        V     /     /     |
            |     |     ------- /     /      |
            |     |    / S2    \     /       |
            |     |    \       /    /        |
            |     |     ---+---    /         |
            |     |        |T4    /          |
            |     |        V     /           | T18
            |     |     ------- /            |
            |     |    / S4    \             |
            |     |    \       /             |
            |     |     ---+---              |         T15
            |     |        |T5      +--------+---------+
            |     |        |       /T16+-----+------+  |
            |     |        |      /   -+-----+--+   |  |
            |     |        |     /   /  S7   \  |T12|  |
            |     |        |    / +->\       /<-+   V  V
            |     |        |   / /    -+-----       -------
            |     |        |  / /T11   |T10        /  S8   \
            |     |        V / /       V  +----+   \       /
            |     |      ---+-+-      ----+--  |    -------
            |     |     / S5    \T9  / S6    \<+      ^
            |     +-----\       /--->\       / T14    |
            |            -------      --+---+---------+T17
            +---------------------------+
```

다음 상태 천이 테이블은 위의 다이어그램을 나타냅니다. 각 행은 주어진 전환의 시작 상태를 나타내며, 테이블 셀에 표시된 전환을 수행한 후 셀의 열로 표시된 상태에서 종료됩니다. 예를 들어, 상태 S1에서 연결은 상태 S2에 도달하기 위해 T1 전환을 수행합니다. "-"로 표시된 필드는 정의되지 않은 전환에 해당합니다.

```text
      +----+---+---+---+---+----+---+
      |S1  |S2 |S4 |S5 |S6 |S7  |S8 |
   ---+----+---+---+---+---+----+---+
    S1| -  |T1 | - | - | - | -  | - |
   ---+----+---+---+---+---+----+---+
    S2|T2  |-  |T4 | - | - | -  | - |
   ---+----+---+---+---+---+----+---+
    S4|T7  |-  |-  |T5 | - | -  | - |
   ---+----+---+---+---+---+----+---+
    S5|T8  |-  |-  | - |T9 |T11 |T15|
   ---+----+---+---+---+---+----+---+
    S6|T13 |-  |-  | - |T14|-   |T17|
   ---+----+---+---+---+---+----+---+
    S7|T18 |-  |-  | - |T10|T12 |T16|
   ---+----+---+---+---+---+----+---+
    S8| -  |-  |-  | - | - | -  | - |
   ---+----+---+---+---+---+----+---+
```

---
#### **8.1.4.  Standard Connection State Diagram for a Target**

상태의 상징적 이름:

```text
      S1: FREE

      S3: XPT_UP

      S4: IN_LOGIN

      S5: LOGGED_IN

      S6: IN_LOGOUT

      S7: LOGOUT_REQUESTED

      S8: CLEANUP_WAIT
```

상태 S5, S6 및 S7은 연결의 전체 기능 단계 작업을 구성합니다.

상태 다이어그램은 다음과 같습니다.

```text
                           -------<-------------+
               +--------->/ S1    \<----+       |
            T13|       +->\       /<-+   \      |
               |      /    ---+---    \   \     |
               |     /        |     T6 \   |    |
               |  T8 |        |T3       |  |    |
               |     |        |        /   |T7  |
               |     |        |       /    |    |
               |     |        |      /     |    |
               |     |        V     /     /     |
               |     |     ------- /     /      |
               |     |    / S3    \     /       |
               |     |    \       /    /        | T18
               |     |     ---+---    /         |
               |     |        |T4    /          |
               |     |        V     /           |
               |     |     ------- /            |
               |     |    / S4    \             |
               |     |    \       /             |
               |     |     ---+---         T15  |
               |     |        |T5      +--------+---------+
               |     |        |       /T16+-----+------+  |
               |     |        |      /  -+-----+---+   |  |
               |     |        |     /   /  S7   \  |T12|  |
               |     |        |    / +->\       /<-+   V  V
               |     |        |   / /    -+-----       -------
               |     |        |  / /T11   |T10        /  S8   \
               |     |        V / /       V           \       /
               |     |      ---+-+-      -------       -------
               |     |     / S5    \T9  / S6    \        ^
               |     +-----\       /--->\       /        |
               |            -------      --+---+---------+T17
               +---------------------------+
```

다음 상태 전이 테이블은 위의 다이어그램을 나타내며 개시자 다이어그램에 대해 설명된 규칙을 따릅니다.

```text
      +----+---+---+---+---+----+---+
      |S1  |S3 |S4 |S5 |S6 |S7  |S8 |
   ---+----+---+---+---+---+----+---+
    S1| -  |T3 | - | - | - | -  | - |
   ---+----+---+---+---+---+----+---+
    S3|T6  |-  |T4 | - | - | -  | - |
   ---+----+---+---+---+---+----+---+
    S4|T7  |-  |-  |T5 | - | -  | - |
   ---+----+---+---+---+---+----+---+
    S5|T8  |-  |-  | - |T9 |T11 |T15|
   ---+----+---+---+---+---+----+---+
    S6|T13 |-  |-  | - |-  |-   |T17|
   ---+----+---+---+---+---+----+---+
    S7|T18 |-  |-  | - |T10|T12 |T16|
   ---+----+---+---+---+---+----+---+
    S8| -  |-  |-  | - | - | -  | - |
   ---+----+---+---+---+---+----+---+
```

---
### **8.2.  Connection Cleanup State Diagram for Initiators and Targets**

상태의 상징적 이름:

```text
      R1: CLEANUP_WAIT (same as S8)

      R2: IN_CLEANUP

      R3: FREE (same as S1)
```

정리 중인 연결 상태 머신\(CSM-C라고 함\)이 CLEANUP\_WAIT 상태\(S8\)에 들어갈 때마다 다음 중 하나를 사용하여 연결 정리 상태 다이어그램에 설명된 상태 전환을 거쳐야 합니다. 동일한 세션의 LOGGED\_IN 상태에서 이를 CSM-E\(명시적인 경우\)라고 부르거나 b\) 동일한 세션에 추가될 FREE 상태의 새로운 전송 연결\(암시적인 경우 CSM-I라고 부르겠습니다\)입니다. CSM-E의 경우 정리를 완료하려면 CSM-C에 해당하는 CID에 대해 명시적인 로그아웃\(연결 또는 세션 로그아웃\)을 수행해야 합니다. CSM-I의 경우 CSM-C에 해당하는 CID에 대한 암시적 로그아웃은 해당 CID에 대한 연결 복원\(6.3.4절\)을 통해 수행되어야 합니다. 두 경우 모두 CSM-E 또는 CSM-I의 프로토콜 교환에 따라 CSM-C의 상태 전환이 결정됩니다. 따라서 이 정리 상태 다이어그램은 정리에 있는 연결 인스턴스\(즉, CSM-C\)에만 적용 가능합니다. 암시적 로그아웃의 경우\(예: CSM-C\)

CSM-I가 LOGGED\_IN에 도달할 때 FREE\(R3\)에 도달합니다. 명시적 로그아웃의 경우, CSM-E가 LOGGED\_IN 상태를 계속 유지하면서 성공적인 로그아웃 응답을 수신하면 CSM-C는 FREE\(R3\)에 도달합니다.

개시자가 연결된 iSCSI 세션을 계속 사용하려는 경우 개시자는 CLEANUP\_WAIT 상태의 연결에 대해 명시적 또는 암시적 연결 로그아웃을 시작해야 합니다.

다음 상태 다이어그램은 개시자와 대상 모두에 적용됩니다. \(M1, M2, M3, M4는 섹션 8.2.2에 정의되어 있습니다.\)

```text
                           ---------
                          / R1      \
                      +---\         /<-+
                     /     ----+----    \
                    /          |         \ M3
                 M1 |          |M2        |
                    |          |         /
                    |          |        /
                    |          |       /
                    |          V      /
                    |       ---------/
                    |      / R2      \
                    |      \         /
                    |       ---------
                    |          |
                    |          |M4
                    |          |
                    |          |
                    |          |
                    |          V
                    |       --------
                    |      / R3     \
                    +----->\        /
                            --------
```

다음 상태 전이 테이블은 위 다이어그램을 나타내며 이전 섹션과 동일한 규칙을 따릅니다.

```text
        +----+----+----+
        |R1  |R2  |R3  |
   -----+----+----+----+
    R1  | -  |M2  |M1  |
   -----+----+----+----+
    R2  |M3  | -  |M4  |
   -----+----+----+----+
    R3  | -  | -  | -  |
   -----+----+----+----+
```

---
#### **8.2.1.  State Descriptions for Initiators and Targets**

```text
   R1: CLEANUP_WAIT (same as S8)
```

- - 개시자: CSM-C에 대한 정리 처리를 시작하기 위해 내부 이벤트를 기다리는 중입니다.

- - 대상: CSM-C에 대한 정리 프로세스가 시작되기를 기다리는 중입니다.

```text
   R2: IN_CLEANUP
```

- - 개시자: CSM-C에 대한 연결 정리 프로세스가 완료되기를 기다리는 중입니다.

- - 대상: CSM-C에 대한 연결 정리 프로세스가 완료되기를 기다리는 중입니다.

```text
   R3: FREE (same as S1)
```

- - 개시자: CSM-C의 종료 상태입니다.

- - 대상: CSM-C의 종료 상태입니다.

---
#### **8.2.2.  State Transition Descriptions for Initiators and Targets**

M1: 다음 이벤트 중 하나 이상이 수신되었습니다.

```text
       - initiator:
```

- \* 연결 상태 시간 초과를 나타내는 내부 이벤트입니다.

- \* "세션 종료" 로그아웃에 대해 다른 연결에서 성공적인 로그아웃 응답을 수신하는 내부 이벤트입니다.

```text
       - target:
```

- \* 연결 상태 시간 초과를 나타내는 내부 이벤트입니다.

- \* "세션 종료" 로그아웃 요청에 대해 다른 연결에서 로그아웃 응답\(성공\)을 보내는 내부 이벤트입니다.

M2: 암시적/명시적 로그아웃 프로세스가 다음에 의해 시작되었습니다.

- 개시자.

- - CSM-I 사용 시:

- \* 개시자: 연결\(또는 세션\) 복원을 요청하는 내부 이벤트가 수신되어 연결\(또는 세션\) 복원 로그인이 전송되도록 요청하고 CSM-I를 IN\_LOGIN 상태로 전환합니다.

- \* 대상: XPT\_UP 상태에서 연결/세션 복원 로그인이 수신되었습니다.

- - CSM-E 사용 시:

- \* 개시자: LOGGED\_IN 상태에서 이 CID에 대해 명시적 로그아웃이 전송되었음을 나타내는 내부 이벤트가 수신되었습니다.

- \* 대상: LOGGED\_IN 상태에서 이 CID에 대해 명시적인 로그아웃이 수신되었습니다.

M3: 로그아웃 실패가 감지되었습니다.

- - CSM-I 사용 시:

- \* 개시자: CSM-I가 LOGGED\_IN에 도달하지 못하고 대신 FREE에 도착했습니다.

- \* 대상: CSM-I가 LOGGED\_IN에 도달하지 못하고 대신 FREE에 도착했습니다.

- - CSM-E 사용 시:

- \* 개시자: CSM-E가 LOGGED\_IN 밖으로 이동했거나, 로그아웃 시간 초과 및/또는 중단되었거나, 로그아웃 응답\(실패\)을 수신했습니다.

- \* 대상: CSM-E가 LOGGED\_IN 밖으로 이동했거나, 로그아웃 시간 초과 및/또는 중단되었거나, 실패한 로그아웃 처리가 수신되었음을 나타내는 내부 이벤트입니다. 마지막 경우에는 로그아웃 응답\(실패\)이 전송되었습니다.

M4: 암시적/명시적 로그아웃이 성공적으로 수행되었습니다.

- - CSM-I 사용 시:

- \* 개시자: CSM-I가 LOGGED\_IN 상태에 도달했거나 "세션 닫기" 로그아웃 요청에 대한 다른 연결에서 로그아웃 응답\(성공\)을 수신하는 내부 이벤트가 수신되었습니다.

- \* 대상: CSM-I가 LOGGED\_IN 상태에 도달했거나 "세션 종료" 로그아웃 요청에 대해 다른 연결에서 로그아웃 응답\(성공\)을 보내는 내부 이벤트가 수신되었습니다.

- - CSM-E 사용 시:

- \* 개시자: CSM-E가 LOGGED\_IN에 머물면서 로그아웃 응답\(성공\)을 수신했거나, "세션 종료" 로그아웃 요청에 대한 다른 연결에서 로그아웃 응답\(성공\)을 수신하는 내부 이벤트가 수신되었습니다.

- \* 대상: CSM-E가 LOGGED\_IN에 머무르고 성공적인 로그아웃 처리를 나타내는 내부 이벤트가 수신되었거나 "세션 종료" 로그아웃 요청에 대해 다른 연결에서 로그아웃 응답\(성공\)을 보내는 내부 이벤트가 수신되었습니다.

---
### **8.3.  Session State Diagrams**
---
#### **8.3.1.  Session State Diagram for an Initiator**

상태의 상징적 이름:

```text
      Q1: FREE

      Q3: LOGGED_IN

      Q4: FAILED
```

상태 Q3은 세션의 전체 기능 단계 작업을 나타냅니다.

상태 다이어그램은 다음과 같습니다. \(N1, N3, N4, N5 및 N6은 섹션 8.3.4에 정의되어 있습니다.\)

```text
                                   ---------
                                  / Q1      \
                      +---------->\         /<-+
                     /             ----+----   |
                    /                  |       |N3
                N6  |                  |N1     |
                    |                  |       |
                    |       N4         |       |
                    | +------------+   |      /
                    | |            |   |     /
                    | |            |   |    /
                    | |            V   V   /
                  --+-+---         -------+-
                 / Q4     \ N5    / Q3      \
                 \        /<------\         /
                  --------         ---------
```

상태 전이 테이블은 다음과 같습니다.

```text
        +---+---+---+
        |Q1 |Q3 |Q4 |
   -----+---+---+---+
    Q1  | - |N1 | - |
   -----+---+---+---+
    Q3  |N3 | - |N5 |
   -----+---+---+---+
    Q4  |N6 |N4 | - |
   -----+---+---+---+
```

---
#### **8.3.2.  Session State Diagram for a Target**

상태의 상징적 이름:

```text
      Q1: FREE

      Q2: ACTIVE

      Q3: LOGGED_IN

      Q4: FAILED

      Q5: IN_CONTINUE
```

상태 Q3은 세션의 전체 기능 단계 작업을 나타냅니다.

상태 다이어그램은 다음과 같습니다.

```text
                                           ---------
                     +------------------->/ Q1      \
                    /     +-------------->\         /<-+
                    |     |                ---+-----   |
                    |     |                 ^ |        |N3
                 N6 |     |N11            N9| V N1     |
                    |     |                 +--------  |
                    |     |                / Q2      \ |
                    |     |                \         / |
                    |  ---+-----            +--+-----  |
                    | / Q5      \              |       |
                    | \         / N10          |       |
                    |  -+-+----+-----------+   | N2   /
                    |   ^ |                |   |     /
                    | N7| |N8              |   |    /
                    |   | |                |   V   /
                  --+---+-V                V------+-
                 / Q4      \ N5           / Q3      \
                 \         /<-------------\         /
                  ---------                ---------
```

상태 전이 테이블은 다음과 같습니다.

```text
        +----+----+----+----+----+
        |Q1  |Q2  |Q3  |Q4  |Q5  |
   -----+----+----+----+----+----+
    Q1  | -  |N1  | -  | -  | -  |
   -----+----+----+----+----+----+
    Q2  |N9  | -  |N2  | -  | -  |
   -----+----+----+----+----+----+
    Q3  |N3  | -  | -  |N5  | -  |
   -----+----+----+----+----+----+
    Q4  |N6  | -  | -  | -  |N7  |
   -----+----+----+----+----+----+
    Q5  |N11 | -  |N10 |N8  | -  |
   -----+----+----+----+----+----+
```

---
#### **8.3.3.  State Descriptions for Initiators and Targets**

```text
   Q1: FREE
```

- - 개시자: 인스턴스화 시 또는 정리 후의 상태입니다.

- - 대상: 인스턴스화 시 또는 정리 후 상태입니다.

```text
   Q2: ACTIVE

       - initiator: Illegal.
```

- - 대상: 세션의 첫 번째 iSCSI 연결이 IN\_LOGIN으로 전환되어 로그인 프로세스가 완료되기를 기다리고 있습니다.

```text
   Q3: LOGGED_IN
```

- - 개시자: 모든 세션 이벤트를 기다리는 중입니다.

- - 대상: 모든 세션 이벤트를 기다리는 중입니다.

```text
   Q4: FAILED
```

- 개시자: 세션 복구 또는 세션을 기다리는 중

- 계속.

- - 대상: 세션 복구 또는 세션 지속을 기다리는 중입니다.

```text
   Q5: IN_CONTINUE

       - initiator: Illegal.
```

- - 대상: 세션 지속 시도가 결론에 도달할 때까지 기다리고 있습니다.

---
#### **8.3.4.  State Transition Descriptions for Initiators and Targets**

```text
   N1:
```

- - 개시자: 하나 이상의 전송 연결이 LOGGED\_IN 상태에 도달했습니다.

- - 대상: 세션의 첫 번째 iSCSI 연결이 IN\_LOGIN 상태에 도달했습니다.

```text
   N2:

       - initiator: Illegal.
```

- - 대상: 하나 이상의 iSCSI 연결이 LOGGED\_IN 상태에 도달했습니다.

```text
   N3:
```

- - 개시자: 세션 종료를 통한 세션의 정상 종료\(6.3.6절\).

- - 대상: 세션 종료\(6.3.6절\)를 통한 세션의 정상 종료 또는 성공적인 세션 복원으로 세션이 완전히 종료되었습니다.

```text
   N4:
```

- - 개시자: 세션 연속 시도가 성공했습니다.

```text
       - target: Illegal.

   N5:
       - initiator: Session failure (Section 6.3.6) occurred.

       - target: Session failure (Section 6.3.6) occurred.

   N6:
```

- - 개시자: 세션 상태 시간 초과가 발생했거나 세션 복원으로 인해 이 세션 인스턴스가 지워졌습니다. 이로 인해 연결된 모든 리소스가 해제되고 세션 상태가 삭제됩니다.

- 대상: 세션 상태 시간 초과가 발생했거나 세션

- 복원으로 인해 이 세션 인스턴스가 지워졌습니다. 이로 인해 연결된 모든 리소스가 해제되고 세션 상태가 삭제됩니다.

```text
   N7:

       - initiator: Illegal.
```

- - 대상: 세션 연속 시도가 시작되었습니다.

```text
   N8:

       - initiator: Illegal.
```

- - 대상: 마지막 세션 연속 시도가 실패했습니다.

```text
   N9:

       - initiator: Illegal.
```

- - 대상: 선행 연결에 대한 로그인 시도가 실패했습니다.

```text
   N10:

       - initiator: Illegal.
```

- - 대상: 세션 연속 시도가 성공했습니다.

```text
   N11:

       - initiator: Illegal.
```

- - 대상: 성공적인 세션 복원으로 세션이 완전히 종료되었습니다.

---
## **9.  Security Considerations**

역사적으로 기본 스토리지 시스템은 환경에 최소한의 보안 위험이 있었기 때문에 보안을 고려할 필요가 없었습니다. 즉, 이러한 환경은 호스트에 직접 연결되거나 통신 네트워크와는 별개로 SAN\(Storage Area Network\)을 통해 연결된 저장 장치로 구성됩니다. IP 네트워크를 통해 SCSI와 같은 스토리지 프로토콜을 사용하려면 보안 문제를 해결해야 합니다. iSCSI 구현은 능동적 공격\(예: 다른 ID로 가장, 메시지 삽입, 삭제, 수정 및 재생\)과 수동적 공격\(예: 도청, 회선을 통해 전송된 데이터를 분석하여 이점 얻기\)에 대한 보호 수단을 제공해야 합니다.

기술적으로는 가능하지만 보안, 특히 대역 내 인증 없이 iSCSI를 구성하면 안 됩니다. 섹션 9.2를 참조하세요. 보안 없이 구성된 iSCSI는 보안 위험이 매우 제한적이고 잘 제어되는 폐쇄된 환경으로 제한되어야 합니다. \[RFC3723\]은 해당 문서에 완전히 설명된 위험을 완화하기 위해 사용해야 하는 메커니즘을 지정합니다.\(SHOULD NOT\)

다음 섹션에서는 iSCSI 구현에서 제공되는 보안 메커니즘에 대해 설명합니다.

---
### **9.1.  iSCSI Security Mechanisms**

iSCSI 보안과 관련된 엔터티는 개시자, 대상 및 IP 통신 끝점입니다. 여러 개시자 또는 대상이 단일 통신 끝점을 공유하는 iSCSI 시나리오가 예상됩니다. 이러한 시나리오를 수용하기 위해 iSCSI는 두 가지 별도의 보안 메커니즘, 즉 iSCSI 연결 수준에서 개시자와 대상 간의 대역 내 인증\(iSCSI 로그인 PDU 교환을 통해 수행됨\)과 패킷 보호\(무결성, 인증 및 기밀성\)를 지원합니다. IP 수준의 IPsec. 두 가지 보안 메커니즘은 서로를 보완합니다. 대역 내 인증은 iSCSI 개시자와 대상 사이에 종단 간 신뢰\(로그인 시\)를 제공하는 반면, IPsec은 IP 통신 끝점 사이에 보안 채널을 제공합니다. iSCSI는 상당한 보안 보호가 필요한 민감한 정보에 액세스하는 데 사용될 수 있습니다. 이 보안 고려 사항 섹션의 나머지 부분에 자세히 명시되어 있듯이 두 가지 iSCSI 보안 메커니즘을 모두 반드시 구현해야 합니다\(MUST\). 대역 내 인증 사용을 적극 권장합니다\(SHOULD\). 이와 대조적으로, IPsec의 사용은 선택 사항입니다\(MAY\). IPsec이 해결하는 보안 위험은 iSCSI 연결 또는 세션에서 사용되는 네트워크의 하위 집합을 통해서만 나타날 수 있습니다. 구체적인 예는 iSCSI 세션이 데이터 센터에 걸쳐 있을 때 데이터 센터 간 WAN 연결을 보호하기 위해 데이터 센터 경계에 있는 IPsec VPN 게이트웨이가 대역 내 iSCSI 인증과 결합되어 적합할 수 있다는 것입니다.\(MUST, SHOULD, MAY\)

일반적인 iSCSI 시나리오와 개시자, 대상 및 통신 끝점 간의 관계에 대한 자세한 내용은 \[RFC3723\]에서 확인할 수 있습니다.

---
### **9.2.  In-Band Initiator-Target Authentication**

로그인하는 동안 대상은 개시자를 인증할 수 있고 개시자는 대상을 인증할 수 있습니다. 인증은 협상된 인증 방법을 사용하여 iSCSI 로그인 PDU를 교환함으로써 모든 새로운 iSCSI 연결에서 수행됩니다.\(MAY\)

IPsec은 선택적으로 사용할 수 있으므로 인증 방법은 기본 IPsec 보호를 가정할 수 없습니다. 공격자는 인증 단계 PDU를 검사하여 가능한 한 적은 이점을 얻어야 합니다. 따라서 일반 텍스트\(또는 이에 상응하는\) 비밀번호를 사용하는 방법은 사용하면 안 됩니다. 반면에 신원 보호는 엄격하게 요구되지 않습니다.\(MUST NOT\)

인증 메커니즘은 허위 ID\(스푸핑\)를 사용하여 스토리지 리소스에 대한 무단 로그인을 방지합니다. 인증 단계가 완료되면 기본 IPsec이 사용되지 않으면 모든 PDU가 일반 형식으로 전송 및 수신됩니다. 그만큼

인증 메커니즘만\(기본 IPsec 없이\) 도청이나 메시지 삽입, 삭제, 수정 및 재생의 위험이 없는 경우에만 사용해야 합니다.

섹션 12에서는 iSCSI 텍스트 키와 각 단계에서 허용되는 값을 포함하여 여러 가지 인증 방법과 각 인증 방법에서 따라야 하는 정확한 단계를 정의합니다. iSCSI 개시자가 키 또는 해당 값이 단계 정의에 따르지 않는 응답을 받을 때마다 연결을 중단해야 합니다.\(MUST\)

iSCSI 대상이 단계 정의에 따르지 않는 키나 값을 포함하는 요청이나 응답을 받을 때마다 "초기자 오류" 또는 "매개변수 누락" 상태와 함께 로그인 거부로 응답해야 합니다. 이러한 상태는 "인증 실패" 상태를 지정해야 하는 CHAP 응답과 같이 암호화된 잘못된 값을 위한 것이 아닙니다. 이 규칙의 중요성은 대상 인증을 사용하는 CHAP\(섹션 12.1.3 참조\)에서 설명할 수 있습니다. 여기서 개시자는 대상과 동일한 CHAP 챌린지를 사용하여 응답 키\(CHAP\_R\)를 생략하여 반사 공격을 수행할 수 있었습니다. 그리고 타겟의 반응을 다시 타겟에 반영합니다. CHAP에서는 대상이 "매개변수 누락" 상태의 로그인 거부와 함께 누락된 CHAP\_R 키에 응답해야 하기 때문에 이를 방지합니다.\(MUST, MUST\)

일부 인증 방법의 경우 키는 인증 목적으로 iSCSI 초기자 또는 대상의 ID를 지정합니다. 해당 키와 연결된 값은 iSCSI 이름과 다를 수 있으며 구성 가능해야 합니다\(CHAP\_N: 섹션 12.1.3 참조, SRP\_U: 섹션 12.1.2 참조\). 이러한 이유로 iSCSI 구현은 이러한 인증 ID를 통한 iSCSI 이름 전체의 가장이 불가능한 방식으로 인증을 관리해야 합니다. 특히, 구현은 이름이 다른 경우 이름에 대한 인증 ID 구성과 해당 ID에 대한 인증 자격 증명 구성을 허용해야 합니다\(SHOULD\). 로그인 시간 동안 구현은 협상된 인증 방법을 통해 ID를 인증하는 것 외에도 이름-ID 관계를 확인해야 합니다.\(SHOULD, SHOULD, SHOULD, SHOULD\)

iSCSI 세션에 동시에 또는 순차적으로 여러 TCP 연결이 있는 경우 인증 방법과 ID는 연결마다 달라서는 안 됩니다. 따라서 iSCSI 세션의 모든 연결은 동일한 인증 방법, iSCSI 이름 및 인증 ID\(인증 ID를 사용하는 인증 방법의 경우\)를 사용해야 합니다. 구현에서는 이를 확인하고 세션에서 이미 사용된 것과 다른 인증 방법, iSCSI 이름 또는 인증 ID를 사용하는 새 연결에서 인증 실패를 발생시켜야 합니다. \~ 안에\(SHOULD, SHOULD\)

또한 구현은 세션에 동시에 또는 순차적으로 추가되는 동일한 iSCSI 세션에서 인증된 TCP 연결과 인증되지 않은 TCP 연결을 모두 지원해서는 안 됩니다.\(SHOULD NOT\)

---
#### **9.2.1.  CHAP Considerations**

규정을 준수하는 iSCSI 개시자와 대상은 CHAP 인증 방법 \[RFC1994\]\(대상 인증 옵션을 포함하여 섹션 12.1.3에 따름\)을 구현해야 합니다.\(MUST\)

암호화되지 않은 채널을 통해 CHAP를 수행하는 경우 오프라인 사전 공격에 취약합니다. 구현에서는 이러한 비밀을 생성하고 외부 생성 소스에서 이를 수락하는 수단을 포함하여 최대 128비트 무작위 CHAP 비밀의 사용을 지원해야 합니다. 구현은 무작위 생성 이외의 비밀 생성\(또는 확장\) 수단을 제공해서는 안 됩니다.\(MUST, MUST NOT\)

CHAP가 96개 미만의 임의 비트를 갖는 비밀과 함께 사용되는 환경의 관리 엔터티는 연결을 보호하기 위해 IPsec 암호화\(섹션 9.3.2의 구현 요구 사항에 따라\)를 시행해야 합니다. 더욱이 이 경우 그룹 사전 공유 암호화 키를 사용한 IKE 인증은 다른 구성원의 오프라인 사전 공격으로부터 그룹 구성원을 보호하는 데 필수적이지 않은 한 사용해서는 안 됩니다.\(MUST, SHOULD NOT\)

CHAP 비밀은 정수 바이트\(옥텟\)여야 합니다. 규정을 준수하는 구현은 CHAP 비밀이 최소 96비트인지 또는 IPsec 암호화가 IPsec 암호화를 사용하여 보호하는지 확인할 수 없는 한 CHAP 응답\(CHAP\_R, 섹션 12.1.3 참조\)을 보내야 하는 로그인 단계를 계속해서는 안 됩니다. 연결.\(MUST, SHOULD NOT\)

개시자 인증에 사용되는 CHAP 비밀은 대상 인증을 위해 구성되어서는 안 되며, 대상 인증에 사용되는 CHAP 비밀은 개시자 인증을 위해 구성되어서는 안 됩니다. iSCSI 연결의 한쪽 끝에서 수신한 CHAP 응답이 수신 끝점이 동일한 CHAP 챌린지에 대해 생성한 CHAP 응답과 동일한 경우 해당 응답은 인증 실패로 처리되어야 하며 연결이 닫혀야 합니다. 동일한 CHAP 비밀이 양방향 인증에 사용되지 않음\). 또한 iSCSI 구현이 개시자와 대상 모두로 작동할 수 있는 경우 이 두 역할에 대해 서로 다른 CHAP 암호와 ID를 구성해야 합니다. 다음은 위의 요구 사항으로 방지되는 공격의 예입니다.\(MUST NOT, MUST, MUST\)

- a\) "Rogue"는 "Storage"를 Alice로 가장하려고 하며 Storage-Alice 인증의 양방향에 단일 비밀이 사용된다는 것을 알고 있습니다.

- b\) Rogue는 Alice가 자신에 대한 두 개의 연결을 열도록 설득하고 두 연결 모두에서 자신을 저장소로 식별합니다.

- c\) Rogue는 연결 1에서 CHAP 챌린지를 발행하고 Alice의 응답을 기다린 다음 Alice의 챌린지를 연결 2의 Alice에 대한 초기 챌린지로 반영합니다.

- d\) Alice가 연결 전반에 걸쳐 반영을 확인하지 않는 경우 Rogue가 Alice-Storage CHAP 비밀을 모르더라도 연결 2에 대한 Alice의 응답을 통해 Rogue가 연결 1의 저장소를 가장할 수 있습니다.

발신자는 양방향 인증의 다른 방향에 대해 응답자가 보낸 CHAP 요청을 재사용해서는 안 됩니다. 응답자는 이 조건을 확인하고 해당 조건이 발생할 경우 iSCSI TCP 연결을 닫아야 합니다.\(MUST NOT, MUST\)

여러 개시자 또는 여러 대상의 인증을 위해 동일한 CHAP 비밀을 구성해서는 안 됩니다. 이렇게 하면 둘 중 하나가 다른 하나를 가장할 수 있고, 그 중 하나를 손상시키면 공격자가 둘 중 하나를 가장할 수 있습니다. 확인이 가능한 경우 iSCSI 구현에서는 서로 다른 피어가 동일한 CHAP 암호를 사용하는지 확인하고 이러한 사실이 발견되면 사용자 및/또는 관리자에게 경고하는 적절한 조치를 취하는 것이 좋습니다.\(SHOULD NOT\)

iSCSI 초기자 또는 대상이 여러 관리 도메인의 상대방에 대해 자신을 인증할 때 도메인 전체에 보안 손상이 전파되는 것을 방지하기 위해 각 관리 도메인에 대해 서로 다른 CHAP 비밀을 사용해야 합니다.\(SHOULD\)

단일 관리 도메인 내에서:

- - 단일 CHAP 비밀은 여러 대상에 대한 개시자를 인증하는 데 사용될 수 있습니다.\(MAY\)

- - 개시자가 대상의 CHAP 응답을 확인하기 위해 외부 서버\(예: RADIUS \[RFC2865\]\)를 사용하고 대상의 CHAP 비밀을 모르는 경우 여러 개시자에 대한 대상 인증에 단일 CHAP 비밀을 사용할 수 있습니다.\(MAY\)

외부 응답 확인 서버\(예: RADIUS\)를 사용하지 않는 경우 여러 개시자에 대한 대상 인증을 위해 단일 CHAP 암호를 사용하려면 모든 개시자가 해당 대상의 암호를 알고 있어야 합니다. 이러한 개시자는 다른 개시자에게 대상을 가장할 수 있으며, 그러한 개시자가 손상되면 공격자는 모든 개시자에게 대상을 가장할 수 있습니다. 대상은 각각에 대한 인증을 위해 별도의 CHAP 비밀을 사용해야 합니다\(SHOULD\).\(SHOULD\)

그러한 위험이 우려되는 경우 개시자 이 상황에서는 분리가 필요한 각 개시자 또는 개시자 그룹에 대해 고유한 iSCSI 노드 이름을 사용하여 별도의 논리적 iSCSI 대상을 구성하는 것이 유용할 수 있습니다.

위 요구 사항은 기본 CHAP 인증 메커니즘\[RFC1994\]과 비교하여 iSCSI에 대한 CHAP 인증의 보안 속성을 강화합니다. 강력한 CHAP 암호를 사용하지 못한 iSCSI 구현 및 배포는 CHAP 암호에 대한 오프라인 사전 공격에 매우 취약할 수 있으므로 이러한 요구 사항, 특히 강력한\(임의로 생성된 대규모\) CHAP 암호에 대한 요구 사항을 준수하는 것이 매우 중요합니다. .

향후 버전의 iSCSI에서는 CHAP가 더 나은 인증 메커니즘으로 대체될 것으로 예상됩니다. FC-SP-2 표준\[FC-SP-2\]은 Fibre Channel의 유사한 기술에 대한 대안\(향후 대체 가능\)으로 EAP-GPSK\(Extensible Authentication Protocol - Generalized Pre-Shared Key\) 인증 메커니즘\[RFC5433\]을 지정했습니다. 강화된 CHAP 활용 CHAP를 대체할 수 있는 또 다른 방법은 안전한 비밀번호 메커니즘\(예: iSCSI의 현재 SRP 인증 메커니즘의 업데이트 버전\)입니다.

---
#### **9.2.2.  SRP Considerations**

SRP 인증 방법\(\[RFC2945\]에 지정됨\)의 강도는 사용되는 그룹의 특성\(즉, 주요 모듈러스 N 및 생성기 g\)에 따라 달라집니다. \[RFC2945\]에 설명된 대로 N은 Sophie Germain 소수\(N = 2q + 1 형식, 여기서 q도 소수임\)여야 하며 생성기 g는 GF\(N\)의 원시근입니다. iSCSI 인증에서 소수 모듈러스 N은 최소 768비트여야 합니다.\(MUST\)

허용되는 SRP 그룹 목록은 \[RFC3723\]에 제공됩니다.

---
#### **9.2.3.  Kerberos Considerations**

iSCSI는 클라이언트\(iSCSI 개시자\) 주체를 서비스\(iSCSI 대상\) 주체로 인증하기 위해 원시 Kerberos V5 \[RFC4120\]를 사용합니다. iSCSI는 일반 보안 서비스 응용 프로그램 인터페이스\(GSS-API\) \[RFC2743\] 또는 Kerberos V5 GSS-API 보안 메커니즘 \[RFC4121\]을 사용하지 않습니다. 이는 KRB5 AuthMethod\(섹션 12.1\)를 지원하는 iSCSI 구현이 Kerberos 프로토콜에 직접적으로 관련되어 있음을 의미합니다. Kerberos V5가 인증에 사용되는 경우 \[RFC4120\]에 지정된 대로 다음 작업을 수행해야 합니다.\(MUST\)

- - 대상은 개시자를 신뢰할 수 있는지 확인하기 위해 KRB\_AP\_REQ를 검증해야 합니다.\(MUST\)

- - 상호 인증이 선택되면 개시자는 상호 인증 결과를 결정하기 위해 KRB\_AP\_REP를 검증해야 합니다.\(MUST\)

Kerberos V5는 상호 인증을 제공할 수 있으므로 구현에서는 로그인 인증을 위해 기본적으로 상호 인증을 지원해야 합니다.\(SHOULD\)

그러나 Kerberos 인증은 Kerberos 클라이언트\(개시자\)가 서버\(iSCSI 대상\)를 신뢰할 수 있고 그 반대의 경우도 보장할 뿐입니다. 개시자는 의도된 대상 주체와 통신하고 있는지 확인하기 위해 적절하게 보안된 서비스 검색 기술\(예: iSNS, 섹션 4.2.7 참조\)을 사용해야 합니다.

iSCSI는 iSCSI 프로토콜의 무결성이나 기밀성 보호를 위해 Kerberos v5를 사용하지 않습니다. iSCSI는 섹션 9.3에 지정된 목적으로 IPsec을 사용합니다.

---
### **9.3.  IPsec**

iSCSI는 iSCSI 통신 끝점 사이의 IP 수준에서 패킷 보호\(암호화 무결성, 인증 및 기밀성\)를 위해 IPsec 메커니즘을 사용합니다. 다음 섹션에서는 데이터 인증 및 무결성을 위해 구현해야 하는 IPsec 프로토콜에 대해 설명합니다. 기밀성; 및 암호화 키 관리.

iSCSI 초기자 또는 대상은 완전히 통합되거나 IPsec 프런트엔드 장치와 함께 필요한 IPsec 지원을 제공할 수 있습니다. 후자의 경우 IPsec 지원과 관련된 규정 준수 요구 사항이 "결합된 장치"에 적용됩니다. "결합된 장치"만 iSCSI 장치로 간주됩니다.

iSCSI용 IPsec 사용에 대한 자세한 고려 사항 및 권장 사항은 \[RFC7146\]에 의해 업데이트된 \[RFC3723\]에 제공됩니다. IPsec 요구 사항은 편의를 위해 여기에 재현되었으며 \[RFC7146\]의 요구 사항과 일치하도록 의도되었습니다. 불일치가 있는 경우 \[RFC7146\]의 요구 사항이 적용됩니다.

---
#### **9.3.1.  Data Authentication and Integrity**

데이터 인증 및 무결성은 전송된 모든 패킷의 암호화 키 메시지 인증 코드를 통해 제공됩니다. 이 코드는 메시지 삽입, 삭제 및 수정을 방지합니다. 메시지 재생에 대한 보호는 시퀀스 카운터를 사용하여 실현됩니다.

iSCSI 호환 개시자 또는 대상은 터널 모드에서 ESPv2\[RFC2406\]와 함께 IPsec v2\[RFC2401\]를 구현하여 데이터 인증 및 무결성을 제공해야 하며\(MUST\) 터널 모드에서 ESPv3\[RFC4303\]과 함께 IPsec v3\[RFC4301\]을 구현하여 데이터 인증 및 무결성을 제공해야 합니다\(SHOULD\). , 전송 모드에서 적절한 ESP 버전으로 IPsec v2 또는 v3를 구현하여 데이터 인증 및 무결성을 제공할 수 있습니다. IPsec 구현은 다음과 같은 iSCSI 관련 요구 사항을 충족해야 합니다.\(MUST, MUST\)

- HMAC-SHA1은 다음과 같은 특정 형태로 구현되어야 합니다.

- HMAC-SHA-1-96 \[RFC2404\].\(MUST\)

- - 128비트 키를 사용하는 XCBC 확장이 포함된 AES CBC MAC는 \[RFC3566\]을 구현해야 합니다.\(SHOULD\)

- - IKEv2 \[RFC5996\]를 지원하는 구현은 128비트 키를 사용하여 AES GMAC\(Galois 메시지 인증 코드\) \[RFC4543\]도 구현해야 합니다.\(SHOULD\)

ESP 재생 방지 서비스도 구현해야 합니다.\(MUST\)

iSCSI가 작동할 것으로 예상되는 고속에서는 단일 IPsec SA가 ESP 32비트 시퀀스 번호 공간을 빠르게 소진할 수 있으며, 이로 인해 SA를 자주 다시 입력해야 합니다. 단일 SA 내의 ESP 시퀀스 번호 롤오버는 두 SA 모두에 대해 금지되기 때문입니다. ESPv2 \[RFC2406\] 및 ESPv3 \[RFC4303\]. 이러한 잠재적으로 바람직하지 않은 빈번한 키 재생성을 방지하기 위한 수단을 제공하기 위해 1기가비트/초 이상의 속도로 작동할 수 있는 구현은 ESPv2\(및 지원되는 경우 ESPv3\)에 대한 확장\(64비트\) 시퀀스 번호를 구현해야 하며 반드시\(SHOULD\) 모든 iSCSI 트래픽에 확장된 시퀀스 번호를 사용합니다. 보안 연관 설정의 일부로 확장된 시퀀스 번호 협상은 IKEv1의 경우 \[RFC4304\], IKEv2의 경우 \[RFC5996\]에 지정되어 있습니다.\(MUST\)

---
#### **9.3.2.  Confidentiality**

모든 패킷의 데이터를 암호화하여 기밀성이 제공됩니다. 기밀성이 사용되는 경우 도청 및 메시지 삽입, 삭제, 수정 및 재생에 대한 포괄적인 보호를 제공하기 위해 데이터 인증 및 무결성이 수반되어야 합니다.\(MUST\)

iSCSI 호환 개시자 또는 대상은 터널 모드에서 ESPv2\[RFC2406\]와 함께 IPsec v2\[RFC2401\]를 구현하여 기밀성을 제공해야 하며\(MUST\) 터널 모드에서 ESPv3\[RFC4303\]과 함께 IPsec v3\[RFC4301\]을 구현하여 기밀성을 제공해야 하며\(MAY\) 다음을 제공할 수 있습니다.\(MUST\)

IPsec v2 및 IPsec v3에 적용되는 다음과 같은 iSCSI 특정 요구 사항을 사용하여 전송 모드에서 적절한 ESP 버전으로 IPsec v2 또는 v3을 구현하여 기밀성을 유지합니다.

- - CBC 모드의 3DES는 \[RFC2451\] 구현될 수 있습니다.\(MAY\)

- - 128비트 키를 사용하는 CBC 모드의 AES는 \[RFC3602\]를 구현해야 합니다. 다른 키 크기도 지원될 수 있습니다.\(MUST\)

- - 카운터 모드의 AES는 \[RFC3686\]을 구현할 수 있습니다.\(MAY\)

- - IKEv2 \[RFC5996\]를 지원하는 구현은 128비트 키 \[RFC4106\]를 사용하여 AES Galois/Counter Mode\(GCM\)도 구현해야 합니다. 다른 키 크기도 지원될 수 있습니다.\(SHOULD\)

고유한 약점으로 인해 CBC 모드의 DES는 사용하면 안 됩니다.\(MUST NOT\)

NULL 암호화 알고리즘도 구현해야 합니다.\(MUST\)

---
#### **9.3.3.  Policy, Security Associations, and Cryptographic Key Management**

규정을 준수하는 iSCSI 구현은 IPsec 프로토콜 제품군의 암호화 키 관리 요구 사항을 충족해야 합니다. 인증, 보안 연결 협상 및 암호화 키 관리는 IPsec DOI \[RFC2407\]을 사용하여 IKE \[RFC2409\]를 구현하여 제공해야 하며 다음 iSCSI 관련 요구 사항과 함께 IKEv2 \[RFC5996\]을 구현하여 제공해야 합니다.\(MUST, MUST\)

- a\) 사전 공유된 암호화 키를 사용한 피어 인증이 지원되어야 합니다. 디지털 서명을 사용한 인증서 기반 피어 인증이 지원될 수 있습니다. IKEv1\(\[RFC2409\]\)의 경우 \[RFC2409\]의 섹션 5.2 및 5.3에 설명된 공개 키 암호화 방법을 사용하는 피어 인증을 사용하면 안 됩니다.\(MUST, MAY, SHOULD NOT\)

- b\) 인증을 달성하기 위해 디지털 서명이 사용되는 경우 IKE 협상자는 IKE 인증서 요청 페이로드를 사용하여 인증 기관을 지정해야 합니다. IKE 협상자는 IKE 인증 절차에 사용하기 위해 PKI 인증서를 수락하기 전에 관련 CRL\(인증서 해지 목록\) 또는 온라인 인증서 상태 프로토콜\(OCSP\) \[RFC6960\]을 통해 인증서 유효성을 확인해야 합니다. IKEv2 프로토콜 내 OCSP 지원은 \[RFC4806\]에 지정되어 있습니다. 소수의 인증서가 트러스트 앵커로 정적으로 구성된 환경에서는 이러한 검사가 필요하지 않을 수 있습니다.\(SHOULD, SHOULD\)

- c\) IKEv1의 준수 iSCSI 구현은 기본 모드를 지원해야 하며 공격적 모드를 지원해야 합니다\(SHOULD\). 사전 공유 키 인증 방법을 사용하는 기본 모드는 개시자 또는 대상이 동적으로 할당된 주소를 사용할 때 사용되어서는 안 됩니다. 대부분의 경우 사전 공유 키는 우수한 보안을 제공하지만 동적으로 할당된 주소가 사용되는 상황에서는 그룹 사전 공유 키를 강제로 사용하게 되어 중간자 공격에 취약해집니다.\(MUST, SHOULD NOT\)

- d\) IKEv1 2단계 빠른 모드에서는 2단계 SA를 생성하는 대신 식별 페이로드가 있어야 합니다.\(MUST\)

- e\) IKEv1에는 다음 식별 유형 요구 사항이 적용됩니다. ID\_IPV4\_ADDR, ID\_IPV6\_ADDR\(프로토콜 스택이 IPv6을 지원하는 경우\) 및 ID\_FQDN 식별 유형이 지원되어야 합니다. ID\_USER\_FQDN이 지원되어야 합니다. IP 서브넷, IP 주소 범위, ID\_DER\_ASN1\_DN 및 ID\_DER\_ASN1\_GN 식별 유형은 사용하면 안 됩니다. ID\_KEY\_ID 식별 유형은 사용하면 안 됩니다.\(MUST, SHOULD NOT, MUST NOT\)

f\) IKEv2가 지원되는 경우 다음 식별

- 요구 사항 적용: ID\_IPV4\_ADDR, ID\_IPV6\_ADDR\(프로토콜 스택이 IPv6을 지원하는 경우\) 및 ID\_FQDN 식별 유형이 지원되어야 합니다. ID\_RFC822\_ADDR이 지원되어야 합니다. ID\_DER\_ASN1\_DN 및 ID\_DER\_ASN1\_GN 식별 유형은 사용되어서는 안 됩니다. ID\_KEY\_ID 식별 유형은 사용하면 안 됩니다.\(MUST, SHOULD NOT, MUST NOT\)

이전 글머리 기호 e\) 및 f\)의 식별 유형 요구 사항에 대해 "해서는 안 됩니다" 및 "해서는 안 됩니다"에 대한 이유는 다음과 같습니다.\(MUST NOT\)

- - IP 서브넷과 IP 주소 범위가 너무 넓어서 iSCSI 끝점을 효과적으로 식별할 수 없습니다.

- - DN 및 GN 유형은 X.500 ID입니다. 일반적으로 PKI 인증서에서 subjectAltName의 ID를 사용하는 것이 더 좋습니다.

- - ID\_KEY\_ID는 지정된 대로 상호 운용되지 않습니다.

수동 암호화 키잉은 필요한 키 재생성 지원을 제공하지 않으므로 사용해서는 안 됩니다.\(MUST NOT\)

DH\(Diffie-Hellman\) 그룹을 사용하는 경우 IKEv1 및 IKEv2 모두에서 iSCSI 트래픽을 보호하기 위해 IPsec 보안 연결을 생성하기 위한 모든 제안의 일부로 최소 2048비트의 DH 그룹을 제공해야 합니다.\(SHOULD\)

IPsec을 사용하는 경우 IKEv1 Phase 2 삭제 메시지 수신 또는 SA를 삭제하는 IKEv2 INFORMATIONAL 교환이 iSCSI TCP 연결을 끊는 이유로 해석되어서는 안 됩니다. 추가 트래픽이 전송되면 이를 보호하기 위해 새로운 IKE SA가 생성됩니다.\(SHOULD NOT\)

IPsec을 사용하여 대상을 연결해야 하는지 여부를 결정하기 위해 초기자가 사용하는 방법은 IPsec 정책 관리의 문제로 간주되므로 iSCSI 표준에는 정의되어 있지 않습니다.

IPsec v2와 v3을 모두 지원하는 이니시에이터가 대상에서 지원하는 IPsec 버전을 확인하는 방법도 IPsec 정책 관리의 문제로 간주되므로 iSCSI 표준에는 정의되어 있지 않습니다. 개시자와 대상 모두에서 IPsec v2와 v3을 모두 지원하는 경우 IPsec v3을 사용하는 것이 좋습니다.

IPsec을 사용하지 않는 검색 세션에서 SendTargets 요청을 통해 iSCSI 대상이 검색된 경우 초기자는 해당 대상에 대한 세션을 설정하는 데 IPsec이 필요하지 않다고 가정해야 합니다. IPsec을 사용하는 검색 세션을 사용하여 iSCSI 대상이 검색된 경우 개시자는 해당 대상에 대한 세션을 설정할 때 IPsec을 사용해야 합니다.\(SHOULD\)

---
### **9.4.  Security Considerations for the X#NodeArchitecture Key**

이 섹션의 보안 고려 사항은 섹션 13.26에서 설명한 X#NodeArchitecture에만 적용됩니다.

이 확장 키는 이를 보내는 노드에 대한 특정 구현 세부 정보를 전송합니다. 이러한 세부 정보는 일부 환경에서 민감한 것으로 간주될 수 있습니다. 예를 들어, 특정 소프트웨어나 펌웨어 버전에 보안 취약점이 있는 것으로 알려진 경우 이 키를 통해 해당 버전의 존재를 알리는 것은 바람직하지 않을 수 있습니다. 이 보안 문제에 대한 대책은 다음과 같습니다.

- a\) 키 값에 대해 덜 자세한 정보를 전송합니다.

- b\) 확장 키를 보내지 않거나

- c\) IPsec\(\[RFC4303\]\)을 사용하여 키가 전송되는 iSCSI 연결에 대한 기밀성을 제공합니다.

첫 번째와 두 번째 대책을 지원하려면 이 확장 키의 모든 구현은 키 전송을 비활성화하는 관리 메커니즘을 제공해야 합니다. 또한 모든 구현은 키 값의 상세 수준을 구성하여 전송되는 정보의 양을 제어하는 ​​관리 메커니즘을 제공해야 합니다\(SHOULD\).\(MUST, SHOULD\)

예를 들어, 더 낮은 상세 수준에서는 노드 아키텍처 구성 요소 이름만 전송하고 버전 번호는 전송할 수 없습니다. 어떤 대책이 가장 적절한지는 환경에 따라 선택됩니다. 그러나 키 값에 덜 자세한 정보를 보내는 것은 너무 많은 정보를 보내는 것과 키를 전혀 보내지 않거나 IPsec을 사용하는 보다 완전한 다른 대책 사이의 절충안을 제공하므로 많은 환경에서 허용되는 대책이 될 수 있습니다.

키 콘텐츠 전송과 관련된 보안 고려 사항 외에도 키 값에 사용되는 모든 로깅 방법은 침입자로부터 정보를 안전하게 유지해야 합니다. 모든 구현에서 이 보안 문제를 해결하기 위한 요구 사항은 다음과 같습니다.\(MUST\)

- a\) 로그 표시는 노드에 대한 관리 권한이 있는 경우에만 가능해야 합니다.\(MUST\)

- b\) 디스크에 대한 로깅을 비활성화하고 고정된 기간 동안 로그를 유지하는 옵션을 제공해야 합니다.\(SHOULD\)

마지막으로, 노드마다 위험 수준이 다를 수 있으며 이러한 차이가 구현에 영향을 미칠 수 있다는 점에 유의하는 것이 중요합니다. 위험의 구성요소에는 자산, 위협, 취약점이 포함됩니다. 노드의 자산 및 취약성 차이와 그에 따른 구현 차이를 보여주는 다음 예시 iSCSI 노드를 고려해보세요.

- a\) 특수 목적 운영 체제 기반의 단일 iSCSI 대상: iSCSI 대상은 회사 자산이 포함된 데이터 저장소에 대한 액세스를 제어하므로 자산 수준이 매우 높은 것으로 보입니다. 또한 특수목적의 운영체제이기 때문에 취약점이 잘 알려지지 않아 취약점 수준이 낮은 것으로 평가된다.

- b\) 각각 범용 운영 체제를 실행하는 블레이드 팜의 여러 iSCSI 이니시에이터: 블레이드는 교체 가능하고 비용이 저렴하므로 각 노드의 자산 수준은 낮은 것으로 간주됩니다. 그러나 해당 범용 운영 체제에는 잘 알려진 취약점이 많이 있을 수 있으므로 취약점 수준이 높은 것으로 간주됩니다. 이 대상의 경우 적절한 구현은 수신된 키 값을 기록하지만 키를 전송하지 않는 것일 수 있습니다. 이 개시자의 경우 키를 전송하지만 수신된 키 값을 기록하지 않는 것이 적절한 구현일 수 있습니다.

---
### **9.5.  SCSI Access Control Considerations**

iSCSI는 SCSI 전송 프로토콜이므로 SCSI 작업 관리 기능\(예: LU 재설정, 섹션 11.5.1 참조\)과 같은 SCSI 수준 작업에 대한 액세스 제어를 적용하지 않습니다. 이전 섹션에서 이미 논의한 iSCSI 연결 및 패킷 보호 메커니즘을 통한 보안 외에도 SCSI 수준 보안 고려 사항을 해결하기 위해 SCSI 수준 액세스 제어\(예: ACCESS Control OUT, \[SPC3\] 참조\)를 실제로 적절하게 배포해야 합니다. .

---
## **10.  Notes to Implementers**

이 섹션에서는 iSCSI 프로토콜의 성능 및 안정성 고려 사항 중 일부를 설명합니다. 이 프로토콜은 효율적인 실리콘 및 소프트웨어 구현을 허용하도록 설계되었습니다. iSCSI 작업 태그 메커니즘은 iSCSI 수준 이하에서 DDP\(DMA 형식\)를 활성화하도록 설계되었습니다.

이 프로토콜 설계 전반에 걸쳐 기본 가정은 대상이 개시자에 비해 리소스가 제한되어 있다는 것입니다.

또한 구현자는 섹션 4.4.3에 설명된 대로 iSCSI-SCSI 매핑 모델의 구현 결과를 고려하는 것이 좋습니다.

---
### **10.1.  Multiple Network Adapters**

iSCSI 프로토콜은 다중 연결을 허용하지만 모든 연결이 동일한 네트워크 어댑터를 통과할 필요는 없습니다. 하드웨어 지원과 함께 여러 네트워크 연결을 활용해야 하는 경우 하나의 TCP 연결에 대한 iSCSI 프로토콜 명령-데이터-상태 충성을 통해 네트워크 어댑터 간에 정보를 복제하거나 협력을 요구할 필요가 없습니다.

그러나 일부 작업 관리 명령에는 적어도 대상에서 느슨한 형태의 협력 또는 복제가 필요할 수 있습니다.

---
#### **10.1.1.  Conservative Reuse of ISIDs**

역사적으로 SCSI 모델\(및 해당 모델을 기반으로 한 구현 및 애플리케이션\)에서는 SCSI 포트가 정적, 물리적 개체라고 가정했습니다. 최근 SCSI 모델 확장에서는 이러한 포트에 대해 전 세계적으로 고유한 영구 이름을 활용했습니다. 그러나 iSCSI에서는 SCSI 개시자 포트가 동적으로 생성된 세션의 끝점이므로 "정적 및 물리적"이라는 가정이 적용되지 않습니다. 어떤 경우든 "모델" 섹션\(특히,

섹션 4.4.1\)은 이러한 이름에 바인딩된 물리적 엔터티가 필요하지 않더라도 iSCSI 유형 SCSI 개시자 포트에 대해 지속적이고 재사용 가능한 이름을 제공합니다.

레거시 애플리케이션의 중단을 최소화하고 SCSI 포트의 영구 이름에 의존하는 SCSI 기능을 보다 효과적으로 활용하기 위해 iSCSI 구현은 SCSI 개시자 포트\(상위 OS 레이어와 연결되는 대상 모두\)의 안정적인 표시를 제공해야 합니다. \). 이는 ISID를 보수적으로 재사용하여 개시자 구현에서 달성할 수 있습니다. 즉, 여러 대상 포털 그룹\(동일한 iSCSI 대상 또는 다른 iSCSI 대상\)에 대한 로그인 프로세스에서 동일한 ISID를 사용해야 합니다. ISID 규칙\(섹션 4.4.3\)은 동일한 대상 포털 그룹에 대한 재사용만 금지합니다. 다른 대상 포털 그룹에 대한 재사용을 "방지"하지 않습니다. 보수적인 재사용 원칙은 다른 대상 포털 그룹에 대한 재사용을 "장려"합니다. SCSI 대상 장치가 다른 대상 포털 그룹에 대한 다른 세션에서 동일한\(InitiatorName, ISID\) 쌍을 볼 때 각 세션의 기본 SCSI 개시자 포트를 동일한 SCSI 포트로 식별할 수 있습니다. 실제로 동일한 소스에서 여러 경로를 인식할 수 있습니다.\(SHOULD\)

---
#### **10.1.2.  iSCSI Name, ISID, and TPGT Use**

iSCSI 프로토콜 설계자는 레거시 SCSI 전송이 개시자 ID를 사용하여 스토리지 리소스에 대한 액세스를 할당한다는 사실을 알고 있습니다. 액세스 제어를 단순화하는 최신 기술을 사용할 수 있지만 레거시 시스템 및 관리 소프트웨어를 지원하려면 초기자 ID를 기반으로 하는 구성 및 인증 체계에 대한 지원이 중요한 것으로 간주됩니다. 따라서 iSCSI는 "초기 장치" ID를 기반으로 스토리지 리소스에 대한 액세스를 할당할 수 있어야 한다는 개념을 지원합니다.

단일 iSCSI 노드로 조정되는 여러 하드웨어 또는 소프트웨어 구성 요소가 있는 경우 세션 생성 및 로그인과 관련된 모든 구성 요소에서 iSCSI 노드 이름을 사용할 수 있도록 하는 iSCSI 노드를 나타내는 일부 \(논리적\) 엔터티가 있어야 합니다. 마찬가지로, iSCSI 노드를 나타내는 이 엔터티는 ISID RULE과 TSIH RULE을 모두 적용하기 위해 세션 식별자 리소스\(초기자의 ISID\)를 조정할 수 있어야 합니다\(섹션 4.4.3 참조\).

대상의 경우 폐쇄된 환경으로 인해 이 엔터티의 구현이 간단해야 합니다. 그러나 대상을 위한 iSCSI 하드웨어\(예: NIC 또는 HBA\) 공급업체는 대상 내 이러한 구성 요소의 여러 인스턴스에 의해 인스턴스화된 포털 그룹 전체에서 iSCSI 노드 이름 구성을 위한 메커니즘을 제공해야 합니다.\(SHOULD\)

그러나 여러 대상 포털 그룹 태그를 사용하는 복잡한 대상은 다양한 품질 목표를 달성하기 위해 태그를 재구성할 수 있습니다. 개시자에는 재구성 대상을 검색 및/또는 확인하기 위한 두 가지 메커니즘, 즉 검색 세션 유형과 TPGT를 확인하기 위해 로그인 중에 대상이 반환하는 키가 있습니다. 개시자는 세션이 예기치 않게 종료될 때마다 대상 구성을 "재검색"하려고 시도해야 합니다.

초기자의 경우 장기적으로 운영 체제 공급업체가 이 엔터티의 역할을 맡아 구성 요소에 iSCSI 노드 이름을 알리고 ISID 할당, 사용 및 재사용을 구성 및/또는 조정할 수 있는 표준 API를 제공할 것으로 예상됩니다. .

현재 이러한 개시자 API를 사용할 수 없다는 점을 인식하면 이 엔터티 역할의 다른 구현이 가능합니다. 예를 들어, 사람은 세션 생성 및 로그인과 관련된 각 iSCSI 구성 요소의 설치 프로세스의 일부로 \(공통\) 노드 이름을 인스턴스화할 수 있습니다. 이는 구성 요소가 이 데이텀에 대한 공급업체별 위치나 시스템 전체 위치를 가리키도록 하여 수행할 수 있습니다. ISID 네임스페이스\(섹션 11.12.5 및 \[RFC3721\] 참조\)의 구조는 각 구성 요소 공급업체가 독립적으로\(다른 공급업체의 구성 요소에 대해\) 자체 ISID 파티션 할당, 사용 및 재사용을 조정할 수 있도록 함으로써 ISID 조정 구현을 용이하게 합니다. 공급업체별 방식으로 네임스페이스를 지정합니다. 해당 공급업체가 관리하는 개시자 포털 그룹 내에서 ISID 네임스페이스를 분할하면 로그인을 위해 ISID를 선택할 때 각 개시자 포털 그룹이 다른 모든 포털 그룹과 독립적으로 작동할 수 있습니다. 이는 개시자에서 ISID 규칙\(섹션 4.4.3 참조\)의 시행을 용이하게 합니다.

이니시에이터에서 사용하도록 고안된 iSCSI 하드웨어\(예: NIC 또는 HBA\) 공급업체는 iSCSI 노드 이름을 구성하기 위한 메커니즘을 구현해야 합니다. 공급업체와 관리자는 iSCSI 노드 이름이 전 세계적으로 고유한지 확인해야 합니다. 따라서 비활성화된 장치의 iSCSI 노드 이름을 재사용하기로 선택한 경우 해당 장치의 전 세계적 고유성이 다시 확인되지 않는 한 해당 이름을 원래 장치에 다시 할당하지 않는 것이 중요합니다.\(MUST\)

또한, iSCSI 하드웨어 공급업체는 지정된 iSCSI 노드 내에서 해당 하드웨어의 여러 인스턴스가 관리하는 모든 세션에 대해 ISID를 구성 및/또는 조정하는 메커니즘을 구현해야 합니다. 이러한 구성은 공장에서 영구적으로 사전 할당되거나\(반드시 전역적으로 고유한 방식으로\) 정적으로 할당되거나\(예: 초기화 시 로컬에서 고유한 방식으로 모든 NIC에 걸쳐 분할됨\) 동적으로 할당될 수 있습니다\(예: 온라인 할당자, 지역적으로 고유한 방식으로\). 후자의 두 경우에는 구성이 가능합니다.

공개 API\(아마도 OS 공급업체와 같은 독립 공급업체의 소프트웨어에 의해 구동됨\) 또는 공급업체 자체 소프트웨어에 의해 구동되는 개인 API를 통해 가능합니다.

이름 지정 및 조정 프로세스는 가능한 한 포괄적이고 자동화되어야 합니다. 수년간의 레거시 사용을 통해 오류가 발생하기 쉬운 것으로 나타났기 때문입니다. 오늘날 SCSI에는 모든 전송에서 사용할 수 있는 대체 액세스 제어 체계가 있으며 해당 보안은 엄격한 명명 조정에 의존하지 않는다는 점을 언급해야 합니다.

---
### **10.2.  Autosense and Auto Contingent Allegiance (ACA)**

"자동 감지"는 명령이 성공적으로 완료되지 않은 경우 감지 데이터를 개시자에게 자동으로 반환하는 것을 의미합니다. iSCSI 개시자와 대상은 자동 감지를 지원하고 사용해야 합니다.\(MUST\)

ACA는 오류가 있는 경우 명령 실행을 순서대로 유지하는 데 도움이 됩니다. 개시자와 대상 사이에 진행 중인 많은 명령이 있을 수 있으므로 일부 운영 체제의 SCSI 개시자 기능은 ACA에 의존하여 오류 복구 중에 순서화된 명령 실행을 시행하므로 해당 운영 체제에 대한 iSCSI 개시자 구현은 ACA를 지원해야 합니다. 이러한 운영 체제 및 iSCSI 초기자에 대한 오류 복구를 지원하려면 iSCSI 대상이 ACA를 지원해야 합니다.\(SHOULD\)

---
### **10.3.  iSCSI Timeouts**

iSCSI 복구 작업은 SCSI 시간 초과 이전에 인식되고 조치를 취하는 iSCSI 시간 초과에 따라 달라지는 경우가 많습니다. 다양한 iSCSI 작업\(예상되는 명령 승인, 상태 승인 등\)에 사용할 적절한 시간 제한을 결정하는 것은 인프라\(예: 하드웨어, 링크, TCP/IP 스택, iSCSI 드라이버\)에 따라 크게 달라집니다. 참고로, 구현자는 특정 연결에 대한 iSCSI 스택의 기본 지연에 대한 적절한 추정치로 "안전 계수"\(예: 4\)를 곱한 평균 NOP-Out/NOP-In 전환 지연을 사용할 수 있습니다. 안전계수는 네트워크 부하 변동성을 고려해야 합니다. 연결 해제를 위해 구현자는 주어진 인프라에 대한 TCP 일반적인 관행을 고려할 수도 있습니다.

문자 협상에는 시간 제한이나 교환 횟수 제한이 적용될 수도 있습니다. 이러한 제한은 상호 운용성에 영향을 주지 않을 만큼 충분히 관대해야 합니다\(예: 각 키를 별도의 교환에서 협상할 수 있도록 허용\).\(MAY, SHOULD\)

iSCSI 시간 초과와 SCSI 시간 초과 간의 관계도 고려해야 합니다. SCSI 시간 초과는 iSCSI 시간 초과보다 길어야 하며 iSCSI 복구가 실행될 때마다 iSCSI 복구에 필요한 시간을 더해야 합니다.

계획. 또는 구현자는 iSCSI 시간 초과 및 복구를 SCSI 시간 초과와 연동하도록 선택하여 iSCSI가 복구할 계획이 없거나 복구에 실패한 경우에만 SCSI 복구가 활성화되도록 할 수 있습니다.

구현자는 다이제스트 실패와 같은 다양한 iSCSI 예외 이벤트와 후속 시간 초과 간의 상호 작용을 고려할 수도 있습니다. iSCSI 오류 복구가 활성화되면 다이제스트 오류로 인해 누락된 명령이나 데이터 PDU가 검색될 가능성이 높습니다. 이러한 경우 구현자는 복구 절차를 더 빠르게 시작할 수 있도록 시간 초과 값을 낮출 수 있습니다.

---
### **10.4.  Command Retry and Cleaning Old Command Instances**

오래되고 재시도된 명령 인스턴스가 명령 시퀀스 번호 랩어라운드 이후 유효한 명령 창에 나타나는 것을 방지하기 위해 프로토콜은 재시도가 실행된 모든 연결에서 즉각적이지 않은 명령이 실행되도록 요구합니다\(섹션 4.2.2.1 참조\). 재시도된 명령의 CmdSN에서 2\*\*31 - 1개의 명령 간격 내에 승인됩니다. 이 요구 사항은 여러 가지 방법으로 구현하여 충족할 수 있습니다.

사용하기 가장 간단한 기술은 재시도가 시도된 연결에서 모든 명령 재시도 후에 \(재시도가 아닌\) 즉각적이지 않은 SCSI 명령\(또는 한동안 사용할 수 있는 SCSI 명령이 없는 경우 NOP\)을 보내는 것입니다. 오류는 드문 이벤트로 간주되므로 명령을 실행할 때 개시자에서 추가 검사가 필요하지 않기 때문에 이 기술이 아마도 가장 효과적일 것입니다.

---
### **10.5.  Sync and Steering Layer, and Performance**

동기화 및 조정 계층은 선택 사항이지만 동기화 및 조정을 요구하는 대상/개시자에 대해 작동하지 않는 시작자/대상은 패킷 재정렬 및 ​​손실로 인해 성능 저하가 발생할 수 있습니다. 모든 고속 구현에는 동기화 및 조정 메커니즘을 제공하는 것이 좋습니다.

10.6. 상태 종속 장치 및 오래 지속되는 SCSI 작업에 대한 고려 사항

순차 액세스 장치는 장치의 위치가 처리된 마지막 명령을 기반으로 한다는 원칙에 따라 작동합니다. 이처럼 명령 처리 순서와 이전 명령의 처리 여부를 아는 것은 데이터 무결성을 유지하는 데 가장 중요합니다. 예를 들어, 이전 SCSI 명령이 처리되었는지 알 수 없을 때 SCSI 명령을 실수로 재시도하는 것은 잠재적인 데이터 무결성 위험입니다.

순차 액세스 장치의 경우 하나의 파일 표시를 백스페이스하는 SCSI SPACE 명령이 실행된 다음 명령에 대해 수신된 상태가 없기 때문에 다시 실행되는 시나리오를 고려하십시오. 첫 번째 SPACE 명령이 실제로 처리된 경우 재발행된 SPACE 명령이 처리되면 위치가 변경됩니다. 따라서 후속 쓰기 작업에서는 데이터가 잘못된 위치에 기록되고 해당 위치의 이전 데이터는 덮어쓰게 됩니다.

미디어 체인저 장치의 경우 EXCHANGE MEDIUM 명령\(SOURCE ADDRESS와 DESTINATION ADDRESS가 동일하여 스왑 수행\)이 실행된 후 해당 명령에 대해 수신된 상태가 없기 때문에 다시 실행되는 시나리오를 고려하십시오. 첫 번째 EXCHANGE MEDIUM 명령이 실제로 처리된 경우 재발행된 EXCHANGE MEDIUM 명령이 처리되면 스왑을 다시 수행합니다. 결과적으로 스왑이 수행되지 않아 데이터 무결성이 위험해집니다.

장치의 상태를 변경하는 모든 명령\(예: 순차 액세스 장치의 SPACE 명령 및 미디어 체인저 장치의 EXCHANGE MEDIUM 명령\)은 iSCSI 대상에 대한 결정적이고 순차적인 전달을 위해 즉각적이지 않은 명령으로 실행되어야 합니다.\(MUST\)

상태를 변경하는 많은 명령의 경우 실행 모델에서는 명령이 정확히 한 번 실행된다고 가정합니다. READ POSITION 및 LOCATE를 구현하는 장치는 SCSI 수준 명령 복구 수단을 제공하며 새로운 테이프 클래스 장치는 이러한 명령을 지원해야 합니다. 부재 시에는 SCSI 수준에서 재시도가 어려우므로 iSCSI 수준에서 오류 복구를 수행하는 것이 좋습니다.

지연 시간이 긴 전달 하위 시스템에서 작동하고 오래 지속되는 SCSI 작업을 수행하는 장치에는 명령이 실행되는 동안\(예: 확장된 복사 작업 중\) 연결 교체를 가능하게 하는 메커니즘이 필요할 수 있습니다.

---
#### **10.6.1.  Determining the Proper ErrorRecoveryLevel**

특정 ErrorRecoveryLevel의 구현 및 사용은 지정된 iSCSI 구현의 배포 시나리오를 기반으로 결정되어야 합니다. 일반적으로 적절한 복구 수준을 결정하기 전에 다음 요소를 고려해야 합니다.

- a\) I/O 오류에 대한 애플리케이션 복원력.

- b\) 전송 연결 실패 시 필요한 가용성 수준.

- c\) 전송 계층 "체크섬 이스케이프"\(TCP 체크섬에 의해 감지되지 않은 메시지 오류 - 관련 논의는 \[RFC3385\] 참조\)의 확률. 이에 따라 iSCSI 다이제스트 실패 빈도와 iSCSI 수준 오류 복구의 중요성이 결정됩니다. 이 확률을 추정하는 세부 사항은 이 문서의 범위를 벗어납니다.

예를 들어 SCSI 테이프 장치에 대한 위 요소를 고려하면 전송 연결 오류가 문제가 되지 않고 SCSI 수준 복구를 사용할 수 없는 경우 구현에서는 ErrorRecoveryLevel=1을 사용해야 하고, 연결 오류 가능성이 높은 경우 ErrorRecoveryLevel=2를 사용해야 합니다. 백업/검색 중.\(SHOULD\)

확장된 복사 작업의 경우 연결 실패 가능성이 상대적으로 높을 때마다 구현에서는 ErrorRecoveryLevel=2를 사용해야 합니다.\(SHOULD\)

---
### **10.7.  Multi-Task Abort Implementation Considerations**

다중 작업 중단 작업은 일반적으로 장치 잠금 해제, HA 장애 조치/장애 복구 등과 같은 긴급 상황에서 실행됩니다. 이러한 상황에서는 대상이 대기하는 대신 오류 처리 프로세스를 신속하게 진행하는 것이 바람직합니다. 더 이상 작동하지 않을 수도 있는 여러 타사 개시자\(특히 그러한 개시자 실패로 인해 이 긴급 상황이 발생하는 경우\) 따라서 iSCSI 대상 및 개시자 구현은 모두 FastAbort 다중 작업 중단 의미 체계\(섹션 4.2.3.4\)를 지원해야 합니다.\(SHOULD\)

표준 의미론\(Section 4.2.3.3\)과 FastAbort 의미론\(Section 4.2.3.4\) 모두에서 TMF 완료가 발급 세션에서 보고된 후에도 미해결 데이터 전송이 있을 수 있습니다. iSCSI/iSER \[RFC7145\]의 경우 이는 활성 작업이 소유하지 않은 STag에 대한 데이터 전송 태그가 지정됩니다. 실제 버퍼가 이러한 데이터 전송을 지원하는지 여부는 구현에 따라 다릅니다. 그러나 데이터 전송은 모든 경우에 대상 iSCSI 계층에 의해 논리적으로 자동으로 삭제되어야 합니다. 구현에 정의된 내부 시간 초과 시 타겟은 예상되는 Data-Out 시퀀스\(섹션 4.2.3.3\) 또는 NOP-Out 승인\(섹션 4.2.3.4\)을 수신하지 못한 연결을 삭제하도록 선택할 수도 있습니다. 관련 버퍼, STag 및 TTT 리소스를 적절하게 회수합니다.\(MUST, MAY\)

---
## **11.  iSCSI PDU Formats**

이 문서에 정의된 형식으로 지정된 모든 멀티바이트 정수는 네트워크 바이트 순서\(예: 빅엔디안\)로 표시됩니다. 이 문서에 나타나는 모든 필드는 달리 지정하지 않는 한 최상위 바이트가 가장 낮은 번호의 바이트이고 최상위 비트\(바이트 또는 필드 내\)가 가장 낮은 번호의 비트라고 가정합니다.

모든 규정을 준수하는 발신자는 별도로 지정하지 않는 한 정의되지 않은 모든 비트와 모든 예약된 필드를 0으로 설정해야 합니다. 호환되는 모든 수신기는 달리 지정되지 않는 한 정의되지 않은 모든 비트와 모든 예약된 필드를 무시해야 합니다. 정의된 필드에서 예약된 코드 값을 수신하면 프로토콜 오류로 보고되어야 합니다.\(MUST, MUST, MUST\)

예약된 필드는 "reserved"라는 단어, "reserved"의 약어 또는 "."로 표시됩니다. 다른 형태의 표시가 기술적으로 가능하지 않은 경우 개별 비트에 대해.

---
### **11.1.  iSCSI PDU Length and Padding**

iSCSI PDU는 4바이트 단어 중 가장 가까운 정수로 채워집니다. 패딩 바이트는 0으로 전송되어야 합니다.\(SHOULD\)

---
### **11.2.  PDU Template, Header, and Opcodes**

모든 iSCSI PDU에는 하나 이상의 헤더 세그먼트가 있으며 선택적으로 데이터 세그먼트도 있습니다. 전체 헤더 세그먼트 그룹 뒤에는 헤더 다이제스트가 뒤따를 수 있습니다. 데이터 세그먼트 뒤에는 데이터 다이제스트가 올 수도 있습니다.\(MAY, MAY\)

BHS\(기본 헤더 세그먼트\)는 모든 iSCSI PDU의 첫 번째 세그먼트입니다. BHS는 고정 길이 48바이트 헤더 세그먼트입니다. AHS\(추가 헤더 세그먼트\), 헤더 다이제스트, 데이터 세그먼트 및/또는 데이터 다이제스트가 뒤따를 수 있습니다.\(MAY\)

iSCSI PDU의 전체 구조는 다음과 같습니다.

```text
   Byte/     0       |       1       |       2       |       3       |
      /              |               |               |               |
     |0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|
     +---------------+---------------+---------------+---------------+
    0/ Basic Header Segment (BHS)                                    /
    +/                                                               /
     +---------------+---------------+---------------+---------------+
   48/ Additional Header Segment 1 (AHS) (optional)                  /
    +/                                                               /
     +---------------+---------------+---------------+---------------+
     / Additional Header Segment 2 (AHS) (optional)                  /
    +/                                                               /
     +---------------+---------------+---------------+---------------+
     +---------------+---------------+---------------+---------------+
     / Additional Header Segment n (AHS) (optional)                  /
    +/                                                               /
     +---------------+---------------+---------------+---------------+
    k/ Header-Digest (optional)                                      /
    +/                                                               /
     +---------------+---------------+---------------+---------------+
    l/ Data Segment (optional)                                       /
    +/                                                               /
     +---------------+---------------+---------------+---------------+
    m/ Data-Digest (optional)                                        /
    +/                                                               /
     +---------------+---------------+---------------+---------------+
```

모든 PDU 세그먼트와 다이제스트는 4바이트 단어의 가장 가까운 정수로 채워집니다. 예를 들어 모든 PDU 세그먼트와 다이제스트는 4바이트 단어 경계에서 시작하고 패딩 범위는 0\~3바이트입니다. 패딩 바이트는 0으로 전송되어야 합니다.\(SHOULD\)

iSCSI 응답 PDU에는 AH 세그먼트가 없습니다.

---
#### **11.2.1.  Basic Header Segment (BHS)**

BHS의 길이는 48바이트입니다. Opcode 및 DataSegmentLength 필드는 모든 iSCSI PDU에 나타납니다. 또한 사용 시 개시자 작업 태그와 논리 장치 번호는 항상 헤더의 동일한 위치에 나타납니다.

BHS의 형식은 다음과 같습니다.

```text
   Byte/     0       |       1       |       2       |       3       |
      /              |               |               |               |
     |0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|
     +---------------+---------------+---------------+---------------+
    0|.|I| Opcode    |F| Opcode-specific fields                      |
     +---------------+---------------+---------------+---------------+
    4|TotalAHSLength | DataSegmentLength                             |
     +---------------+---------------+---------------+---------------+
    8| LUN or Opcode-specific fields                                 |
     +                                                               +
   12|                                                               |
     +---------------+---------------+---------------+---------------+
   16| Initiator Task Tag                                            |
     +---------------+---------------+---------------+---------------+
   20/ Opcode-specific fields                                        /
    +/                                                               /
     +---------------+---------------+---------------+---------------+
   48
```

---
##### **11.2.1.1.  I (Immediate) Bit**

요청 PDU의 경우 1로 설정된 I 비트는 즉시 전달 표시입니다.

---
##### **11.2.1.2.  Opcode**

Opcode는 헤더가 캡슐화하는 iSCSI PDU의 유형을 나타냅니다.

Opcode는 개시자 Opcode와 대상 Opcode의 두 가지 범주로 나뉩니다. 개시자 Opcode는 개시자가 보낸 PDU\(요청 PDU\)에 있습니다. 대상 Opcode는 대상이 보낸 PDU\(응답 PDU\)에 있습니다.

개시자는 대상 Opcode를 사용해서는 안 되며, 대상은 개시자 Opcode를 사용해서는 안 됩니다.\(MUST NOT\)

이 사양에 정의된 개시자 Opcode는 다음과 같습니다.

```text
      0x00 NOP-Out

      0x01 SCSI Command (encapsulates a SCSI Command Descriptor
           Block)

      0x02 SCSI Task Management Function Request

      0x03 Login Request

      0x04 Text Request

      0x05 SCSI Data-Out (for write operations)

      0x06 Logout Request

      0x10 SNACK Request

      0x1c-0x1e Vendor-specific codes

   Target Opcodes are:

      0x20 NOP-In
```

- 0x21 SCSI 응답 - SCSI 상태 및 감지 정보 또는 기타 응답 정보를 포함합니다.

```text
      0x22 SCSI Task Management Function Response

      0x23 Login Response

      0x24 Text Response

      0x25 SCSI Data-In (for read operations)

      0x26 Logout Response
```

- 0x31 R2T\(Ready To Transfer\) - 데이터를 수신할 준비가 되면 대상에서 전송됩니다.

- 0x32 비동기 메시지 - 특정 특수 조건을 나타내기 위해 대상에서 전송됨

```text
      0x3c-0x3e Vendor-specific codes

      0x3f Reject
```

다른 모든 Opcode는 할당되지 않습니다.

---
##### **11.2.1.3.  F (Final) Bit**

1로 설정되면 시퀀스의 마지막\(또는 유일한\) PDU를 나타냅니다.

---
##### **11.2.1.4.  Opcode-Specific Fields**

이러한 필드는 다양한 Opcode 유형에 대해 서로 다른 의미를 갖습니다.

---
##### **11.2.1.5.  TotalAHSLength**

패딩이 있는 경우 이를 포함하여 4바이트 단어 단위의 모든 AHS 헤더 세그먼트의 총 길이입니다.

TotalAHSLength는 AHS가 있는 PDU에만 사용되며 다른 모든 PDU에서는 0이어야 합니다.\(MUST\)

---
##### **11.2.1.6.  DataSegmentLength**

이는 데이터 세그먼트 페이로드 길이\(바이트\)입니다\(패딩 제외\). DataSegmentLength는 PDU에 데이터 세그먼트가 없을 때마다 0이어야 합니다.\(MUST\)

---
##### **11.2.1.7.  LUN**

일부 Opcode는 특정 LU에서 작동합니다. LUN\(논리 단위 번호\) 필드는 어떤 LU를 식별합니다. Opcode가 LU와 관련되지 않은 경우 이 필드는 무시되거나 Opcode별 방식으로 사용될 수 있습니다. LUN 필드는 64비트이며 \[SAM2\]에 따라 형식이 지정되어야 합니다. 예를 들어 \[SAM2\]의 LUN\[0\]은 BHS 바이트 8이고 BHS 바이트 15인 \[SAM2\]의 LUN\[7\]까지입니다.

---
##### **11.2.1.8.  Initiator Task Tag**

개시자는 발행하는 각 iSCSI 작업에 작업 태그를 할당합니다. 작업이 존재하는 동안 이 태그는 세션 전체에서 작업을 고유하게 식별해야 합니다. SCSI는 또한 iSCSI 개시자 작업 태그가 고유해야 하는 기간이 SCSI 작업 태그가 고유해야 하는 기간보다 연장되는 경우 SCSI 작업 식별자의 일부로 개시자 작업 태그를 사용할 수도 있습니다. 그러나 iSCSI 초기자 작업 태그는 태그가 지정되지 않은 SCSI 명령의 경우에도 존재하고 고유해야 합니다.\(MUST\)

0xffffffff의 ITT 값은 예약되어 있으며 개시자가 작업에 할당해서는 안 됩니다. 회선에서 볼 수 있는 유일한 경우는 대상이 시작한 NOP-In PDU\(11.19절\)와 필요한 경우 해당 PDU에 대한 개시자 응답입니다.\(MUST NOT\)

---
#### **11.2.2.  Additional Header Segment (AHS)**

AHS의 일반적인 형식은 다음과 같습니다.

```text
   Byte/     0       |       1       |       2       |       3       |
      /              |               |               |               |
     |0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|
     +---------------+---------------+---------------+---------------+
    0| AHSLength                     | AHSType       | AHS-Specific  |
     +---------------+---------------+---------------+---------------+
    4/ AHS-Specific                                                  /
    +/                                                               /
     +---------------+---------------+---------------+---------------+
    x
```

---
##### **11.2.2.1.  AHSType**

AHSType 필드는 다음과 같이 코딩됩니다.

```text
      bit 0-1 - Reserved

      bit 2-7 - AHS code

      0 - Reserved

      1 - Extended CDB

      2 - Bidirectional Read Expected Data Transfer Length

      3 - 63 Reserved
```

---
##### **11.2.2.2.  AHSLength**

이 필드에는 AHSType, AHSLEngth 및 패딩\(있는 경우\)을 제외한 AHS의 유효 길이\(바이트\)가 포함됩니다. AHS는 4바이트 단어 중 가장 작은 정수\(즉, 0에서 3까지의 패딩 바이트\)로 채워집니다.

---
##### **11.2.2.3.  Extended CDB AHS**

확장 CDB AHS의 형식은 다음과 같습니다.

```text
   Byte/     0       |       1       |       2       |       3       |
      /              |               |               |               |
     |0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|
     +---------------+---------------+---------------+---------------+
    0| AHSLength (CDBLength - 15)    | 0x01          |  Reserved     |
     +---------------+---------------+---------------+---------------+
    4/ ExtendedCDB...+padding                                        /
    +/                                                               /
     +---------------+---------------+---------------+---------------+
    x
```

CDBLength가 17보다 작은 경우 이 유형의 AHS를 사용하면 안 됩니다.\(MUST NOT\)

길이에는 예약된 바이트 3이 포함됩니다.

---
##### **11.2.2.4.  Bidirectional Read Expected Data Transfer Length AHS**

양방향 읽기 예상 데이터 전송 길이 AHS의 형식은 다음과 같습니다.

```text
   Byte/     0       |       1       |       2       |       3       |
      /              |               |               |               |
     |0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|
     +---------------+---------------+---------------+---------------+
    0| AHSLength (0x0005)            | 0x02          | Reserved      |
     +---------------+---------------+---------------+---------------+
    4| Bidirectional Read Expected Data Transfer Length              |
     +---------------+---------------+---------------+---------------+
    8
```

---
#### **11.2.3.  Header Digest and Data Digest**

선택적 헤더 및 데이터 다이제스트는 각각 헤더와 데이터의 무결성을 보호합니다. 다이제스트가 존재하는 경우 헤더 및 PDU 특정 데이터 뒤에 각각 위치하며 각각 패딩 바이트를 포함하는 헤더 및 PDU 데이터를 각각 포함합니다.

다이제스트의 존재와 유형은 로그인 단계에서 협상됩니다.

헤더와 데이터 다이제스트의 분리는 메시지가 전달될 때 헤더만 변경되는 iSCSI 라우팅 애플리케이션에 유용합니다. 이 경우 헤더 다이제스트만 다시 계산해야 합니다.

다이제스트는 데이터 또는 헤더 길이 필드에 포함되지 않습니다.

길이가 0인 데이터 세그먼트는 길이가 0인 데이터 다이제스트도 의미합니다.

---
#### **11.2.4.  Data Segment**

\(선택사항\) 데이터 세그먼트에는 PDU 관련 데이터가 포함됩니다. 페이로드 유효 길이는 BHS 필드\(DataSegmentLength\)에 제공됩니다. 데이터 세그먼트는 4바이트 단어의 정수로 채워집니다.

---
### **11.3.  SCSI Command**

SCSI 명령 PDU의 형식은 다음과 같습니다.

```text
   Byte/     0       |       1       |       2       |       3       |
      /              |               |               |               |
     |0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|
     +---------------+---------------+---------------+---------------+
    0|.|I| 0x01      |F|R|W|. .|ATTR | Reserved                      |
     +---------------+---------------+---------------+---------------+
    4|TotalAHSLength | DataSegmentLength                             |
     +---------------+---------------+---------------+---------------+
    8| Logical Unit Number (LUN)                                     |
     +                                                               +
   12|                                                               |
     +---------------+---------------+---------------+---------------+
   16| Initiator Task Tag                                            |
     +---------------+---------------+---------------+---------------+
   20| Expected Data Transfer Length                                 |
     +---------------+---------------+---------------+---------------+
   24| CmdSN                                                         |
     +---------------+---------------+---------------+---------------+
   28| ExpStatSN                                                     |
     +---------------+---------------+---------------+---------------+
   32/ SCSI Command Descriptor Block (CDB)                           /
    +/                                                               /
     +---------------+---------------+---------------+---------------+
   48/ AHS (optional)                                                /
     +---------------+---------------+---------------+---------------+
    x/ Header-Digest (optional)                                      /
     +---------------+---------------+---------------+---------------+
    y/ (DataSegment, Command Data) (optional)                        /
    +/                                                               /
     +---------------+---------------+---------------+---------------+
    z/ Data-Digest (optional)                                        /
     +---------------+---------------+---------------+---------------+
```

---
#### **11.3.1.  Flags and Task Attributes (Byte 1)**

SCSI 명령 PDU의 플래그는 다음과 같습니다.

- 이 PDU 뒤에 요청되지 않은 SCSI 데이터 출력 PDU가 없으면 비트 0\(F\)이 1로 설정됩니다. 쓰기에 대해 F = 1이고 예상 데이터 전송 길이가 DataSegmentLength보다 큰 경우 대상은 R2T를 통해 추가 데이터를 요청할 수 있습니다.

- 명령이 데이터를 입력할 것으로 예상되면 비트 1\(R\)이 1로 설정됩니다.

- 명령이 데이터를 출력할 것으로 예상되면 비트 2\(W\)가 1로 설정됩니다.

```text
      bit 3-4  Reserved.

      bit 5-7  contains Task Attributes.
```

작업 속성\(ATTR\)은 다음 정수 값 중 하나를 갖습니다\(자세한 내용은 \[SAM2\] 참조\).

```text
        0 - Untagged

        1 - Simple

        2 - Ordered
```

- 3 - 대기열 책임자

```text
        4 - ACA

      5-7 - Reserved
```

W 및 F 비트 중 적어도 하나는 1로 설정되어야 합니다.\(MUST\)

예상 데이터 전송 길이 및/또는 양방향 읽기 예상 데이터 전송 길이가 0인 경우 R과 W 중 하나 또는 둘 다 1일 수 있지만, 예상 데이터 전송 길이 및/또는 양방향 읽기 예상 데이터 전송인 경우 둘 다 0이 되어서는 안 됩니다. 길이가 0이 아닙니다. 즉, 일부 데이터 전송이 예상되는 경우 전송 방향은 R 및/또는 W 비트로 표시됩니다.\(MUST NOT\)

---
#### **11.3.2.  CmdSN - Command Sequence Number**

CmdSN을 사용하면 단일 세션의 여러 연결에 걸쳐 순차적인 전달이 가능합니다.

---
#### **11.3.3.  ExpStatSN**

ExpStatSN - 1\(모듈로 2\*\*32\)까지의 명령 응답이 연결에서 수신되었습니다\(상태를 확인함\).

---
#### **11.3.4.  Expected Data Transfer Length**

단방향 작업의 경우 예상 데이터 전송 길이 필드에는 이 SCSI 작업과 관련된 데이터 바이트 수가 포함됩니다. 단방향 쓰기 작업\(W 플래그는 1로 설정되고 R 플래그는 0으로 설정\)의 경우 개시자는 이 필드를 사용하여 이 작업에 대해 전송할 것으로 예상되는 데이터 바이트 수를 지정합니다. 단방향 읽기 작업\(W 플래그는 0으로 설정되고 R 플래그는 1로 설정\)의 경우 개시자는 이 필드를 사용하여 대상이 개시자로 전송할 것으로 예상되는 데이터 바이트 수를 지정합니다. 이는 SAM-2 바이트 수에 해당합니다.

양방향 작업\(R 및 W 플래그 모두 1로 설정됨\)의 경우 이 필드에는 쓰기 전송과 관련된 데이터 바이트 수가 포함됩니다. 양방향 작업의 경우 양방향 읽기 예상 데이터 전송 길이를 나타내는 추가 헤더 세그먼트가 헤더 시퀀스에 있어야 합니다. 예상 데이터 전송 길이 필드와 양방향 읽기 예상 데이터 전송 길이 필드는 SAM-2 바이트 수에 해당합니다.\(MUST\)

쓰기에 대한 예상 데이터 전송 길이와 명령 다음에 나오는 즉시 데이터 부분의 길이\(있는 경우\)가 동일한 경우 더 이상 데이터 PDU가 뒤따르지 않을 것으로 예상됩니다. 이 경우 F 비트를 1로 설정해야 합니다.\(MUST\)

예상 데이터 전송 길이가 FirstBurstLength\(대상이 허용할 원치 않는 데이터의 협상된 최대량\)보다 큰 경우 개시자는 원치 않는 데이터의 최대량을 보내거나 즉각적인 데이터만 보내야 합니다\(있는 경우\).\(MUST\)

데이터 전송이 완료되면 대상은 대상에서 실제로 처리\(전송 및/또는 수신\)된 바이트 수를 잔여 카운트를 통해 개시자에게 알립니다.

---
#### **11.3.5.  CDB - SCSI Command Descriptor Block**

일반적으로 사용되는 CDB를 수용하기 위해 CDB 필드에는 16바이트가 있습니다. CDB가 16바이트보다 클 때마다 CDB 스필오버를 포함하기 위해 확장 CDB AHS를 사용해야 합니다.\(MUST\)

---
#### **11.3.6.  Data Segment - Command Data**

일부 SCSI 명령에는 SCSI 명령과 함께 사용할 추가 매개변수 데이터가 필요합니다. 이 데이터는 데이터 세그먼트의 iSCSI 헤더 경계 너머에 배치될 수 있습니다. 또는 사용자 데이터\(예: 쓰기 작업의 데이터\)를 데이터 세그먼트에 배치할 수 있습니다\(두 경우 모두 즉시 데이터라고 함\). 이러한 데이터는 섹션 4.2.5.2에 설명된 요청된 데이터와 요청되지 않은 데이터에 대한 규칙에 따라 관리됩니다.

---
### **11.4.  SCSI Response**

SCSI 응답 PDU의 형식은 다음과 같습니다.

```text
   Byte/     0       |       1       |       2       |       3       |
      /              |               |               |               |
     |0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|
     +---------------+---------------+---------------+---------------+
    0|.|.| 0x21      |1|. .|o|u|O|U|.| Response      | Status        |
     +---------------+---------------+---------------+---------------+
    4|TotalAHSLength | DataSegmentLength                             |
     +---------------+---------------+---------------+---------------+
    8| Reserved                                                      |
     +                                                               +
   12|                                                               |
     +---------------+---------------+---------------+---------------+
   16| Initiator Task Tag                                            |
     +---------------+---------------+---------------+---------------+
   20| SNACK Tag or Reserved                                         |
     +---------------+---------------+---------------+---------------+
   24| StatSN                                                        |
     +---------------+---------------+---------------+---------------+
   28| ExpCmdSN                                                      |
     +---------------+---------------+---------------+---------------+
   32| MaxCmdSN                                                      |
     +---------------+---------------+---------------+---------------+
   36| ExpDataSN or Reserved                                         |
     +---------------+---------------+---------------+---------------+
   40| Bidirectional Read Residual Count or Reserved                 |
     +---------------+---------------+---------------+---------------+
   44| Residual Count or Reserved                                    |
     +---------------+---------------+---------------+---------------+
   48| Header-Digest (optional)                                      |
     +---------------+---------------+---------------+---------------+
     / Data Segment (optional)                                       /
    +/                                                               /
     +---------------+---------------+---------------+---------------+
     | Data-Digest (optional)                                        |
     +---------------+---------------+---------------+---------------+
```

---
#### **11.4.1.  Flags (Byte 1)**

```text
   bit 1-2     Reserved.
```

비트 3 - \(o\) 양방향 읽기 잔여 오버플로에 대해 설정됩니다. 이 경우 양방향 읽기 잔여 개수는 개시자의 양방향 읽기 예상 데이터 전송 길이가 충분하지 않아 개시자로 전송되지 않은 바이트 수를 나타냅니다.

비트 4 - \(u\) 양방향 읽기 잔여 언더플로우에 대해 설정됩니다. 이 경우 양방향 읽기 잔여 개수는 전송될 것으로 예상되는 바이트 수 중 개시자로 전송되지 않은 바이트 수를 나타냅니다.

비트 5 - \(O\) 잔여 오버플로를 위해 설정됩니다. 이 경우 잔여 개수는 개시자의 예상 데이터 전송 길이가 충분하지 않아 전송되지 않은 바이트 수를 나타냅니다. 양방향 작업의 경우 잔여 개수에는 쓰기 작업에 대한 잔여가 포함됩니다.

비트 6 - \(U\) 잔여 언더플로우로 설정됩니다. 이 경우 Residual Count는 전송될 것으로 예상되는 바이트 수 중 전송되지 않은 바이트 수를 나타냅니다. 양방향 작업의 경우 잔여 개수에는 쓰기 작업에 대한 잔여가 포함됩니다.

```text
   bit 7 - (0) Reserved.
```

비트 O와 U 및 비트 o와 u는 상호 배타적입니다\(즉, o와 u가 모두 있거나 O와 U가 모두 1로 설정된 것은 프로토콜 오류입니다\).

"명령이 대상에서 완료됨" 이외의 응답의 경우 비트 3-6은 0이어야 합니다.\(MUST\)

---
#### **11.4.2.  Status**

상태 필드는 명령의 SCSI 상태\(\[SAM2\]에 지정된 대로\)를 보고하는 데 사용되며 응답 코드가 대상에서 명령 완료인 경우에만 유효합니다.

\[SAM2\]에 정의된 일부 상태 코드는 다음과 같습니다.

```text
      0x00 GOOD

      0x02 CHECK CONDITION

      0x08 BUSY

      0x18 RESERVATION CONFLICT

      0x28 TASK SET FULL

      0x30 ACA ACTIVE

      0x40 TASK ABORTED
```

전체 목록과 정의는 \[SAM2\]를 참조하세요.

개시자의 데이터가 여전히 예상되는 동안 SCSI 장치 오류가 감지되면\(명령 PDU에 모든 데이터가 포함되지 않았고 대상이 최종 비트가 설정된 데이터 PDU를 수신하지 않은 경우\) 대상은 데이터를 수신할 때까지 기다려야 합니다. 응답 PDU를 전송하기 전 마지막 예상 시퀀스에 F 비트가 설정된 PDU.\(MUST\)

---
#### **11.4.3.  Response**

이 필드에는 iSCSI 서비스 응답이 포함됩니다.

본 사양에 정의된 iSCSI 서비스 응답 코드는 다음과 같습니다.

- 0x00 - 대상에서 명령이 완료되었습니다.

```text
      0x01 - Target Failure

      0x80-0xff - Vendor specific
```

다른 모든 응답 코드는 예약되어 있습니다.

응답 필드는 서비스 응답을 보고하는 데 사용됩니다. 필요한 경우 응답 코드를 SCSI 서비스 응답 코드 값으로 매핑하는 것은 이 문서의 범위를 벗어납니다. 그러나 기호 측면에서 응답 값 0x00은 SCSI 서비스 응답에 매핑됩니다\(참조:

\[SAM2\] 및 \[SPC3\]\) TASK COMPLETE 또는 LINKED COMMAND COMPLETE. 다른 모든 응답 값은 SERVICE DELIVERY OR TARGET FAILURE의 SCSI 서비스 응답에 매핑됩니다.

세션이 종료되기 전에 SCSI 응답 PDU가 도착하지 않으면 SCSI 서비스 응답은 SERVICE DELIVERY OR TARGET FAILURE입니다.

0이 아닌 응답 필드는 명령 실행 실패를 나타내며, 이 경우 상태 및 플래그 필드는 정의되지 않으며 수신 시 무시되어야 합니다.\(MUST\)

---
#### **11.4.4.  SNACK Tag**

이 필드에는 응답이 실행되는 명령에 대해 동일한 연결에서 대상이 수락한 마지막 SNACK 태그의 복사본이 포함됩니다. 그렇지 않으면 예약되어 있으므로 0으로 설정해야 합니다.

R-Data SNACK을 발행한 후 개시자는 현재 연결에서 SCSI 명령에 대해 마지막으로 발행된 R-Data SNACK과 동일한 SNACK 태그를 운반하는 SCSI 응답 PDU에 포함되어 있지 않은 모든 SCSI 상태를 폐기해야 합니다.

R-Data SNACK에 대한 자세한 내용은 섹션 11.16.3을 참조하세요.

---
#### **11.4.5.  Residual Count**
---
##### **11.4.5.1.  Field Semantics**

잔여 카운트 필드는 U 비트 또는 O 비트가 설정된 경우 유효해야 합니다. 두 비트 모두 설정되지 않은 경우 잔여 카운트 필드는 수신 시 무시되어야 하며 송신 시 0으로 설정되어야 합니다. 대상은 잔여 개수를 설정할 수 있으며, 개시자는 응답 코드가 대상에서 명령 완료일 때\(반환된 상태가 GOOD가 아닌 경우에도\) 이를 사용할 수 있습니다. O 비트가 설정된 경우 잔여 개수는 개시자의 예상 데이터 전송 길이가 충분하지 않아 전송되지 않은 바이트 수를 나타냅니다. U 비트가 설정된 경우 잔여 개수는 전송될 것으로 예상되는 바이트 수 중 전송되지 않은 바이트 수를 나타냅니다.\(MUST, MUST\)

---
##### **11.4.5.2.  Residuals Concepts Overview**

"SCSI 표시 데이터 전송 길이\(SPDTL\)"는 대상 SCSI 계층이 작업을 위해 로컬 iSCSI 계층을 사용하여 전송하려고 시도하는 총 데이터 길이를 나타내기 위해 이 문서에서 사용하는 용어입니다\(정의는 섹션 2.2 참조\). "예상되는 데이터 전송

길이\(EDTL\)"는 iSCSI 계층이 작업을 위해 전송할 것으로 예상하는 데이터의 길이를 나타내는 iSCSI 용어입니다. EDTL은 SCSI 명령 PDU에 지정됩니다.

작업에 대해 SPDTL = EDTL인 경우 대상 iSCSI 계층은 잔여 항목 없이 작업을 완료합니다. 작업에 대해 SPDTL이 EDTL과 다를 때마다 해당 작업에 잔차가 있다고 합니다.

작업에 대해 SPDTL \> EDTL인 경우 섹션 11.4.5.1에 ​​지정된 대로 SCSI 응답 PDU에서 iSCSI 오버플로를 신호로 보내야 합니다. 잔여 카운트는 \(SPDTL - EDTL\)의 숫자 값으로 설정되어야 합니다.\(MUST, MUST\)

작업에 대해 SPDTL < EDTL인 경우 섹션 11.4.5.1에 ​​지정된 대로 SCSI 응답 PDU에서 iSCSI 언더플로우를 신호로 보내야 합니다. 잔여 카운트는 \(EDTL - SPDTL\)의 숫자 값으로 설정되어야 합니다.\(MUST, MUST\)

오버플로 및 언더플로 시나리오는 데이터 입력 및 데이터 출력과 별개입니다. 두 시나리오는 데이터 전송의 어느 방향에서나 논리적으로 가능합니다.

---
##### **11.4.5.3.  SCSI REPORT LUNS Command and Residual Overflow**

이 섹션에서는 SCSI REPORT LUNS 명령의 예를 인용하여 잔여 오버플로 문제에 대해 설명합니다. 그러나 동일한 기본 규칙을 따르는 ALLOCATION LENGTH 필드가 있는 여러 SCSI 명령\(예: INQUIRY\)이 있다는 점에 유의하십시오. 섹션의 나머지 부분에 있는 의미는 이러한 모든 SCSI 명령에 적용됩니다.

SCSI REPORT LUNS 명령의 사양에서는 SCSI 대상이 REPORT LUNS CDB의 개시자가 제공한 최대 크기\(할당 길이\)로 전송되는 데이터 양을 제한해야 합니다.

REPORT LUNS 명령에 대한 SCSI 명령 PDU의 iSCSI 헤더에 있는 EDTL\(예상 데이터 전송 길이\)이 최소한 해당 ALLOCATION LENGTH만큼 설정된 경우 SCSI 계층 잘림으로 인해 iSCSI 잔여 오버플로가 발생하지 않습니다. SCSI 개시자는 SCSI 계층의 다른 정보를 통해 이러한 잘림이 발생했음을 감지할 수 있습니다. 섹션의 나머지 부분에서는 이 필수 동작에 대해 자세히 설명합니다.

SCSI REPORT LUNS 명령은 대상 SCSI 계층에 LU 인벤토리\(LUN 목록\)를 개시자 SCSI 계층으로 반환하도록 요청합니다\(\[SPC3\]의 절 6.21 참조\). 이 LUN 목록의 크기는 REPORT LUNS 명령을 실행할 때 개시자 SCSI 계층에 알려지지 않을 수 있습니다. 개시자가 준비된 것보다 더 많은 LUN 목록 데이터를 전송하지 않도록 REPORT LUNS CDB에는 이 명령에 대해 개시자로 전송될 최대 데이터 양을 지정하는 ALLOCATION LENGTH 필드가 포함되어 있습니다. 개시자 SCSI 계층이 과소평가된 경우

대상의 LU 수가 너무 많으면 전체 LU 인벤토리가 지정된 ALLOCATION LENGTH에 맞지 않을 수도 있습니다. 이 상황에서 \[SPC3\]의 4.3.4.6절에서는 ALLOCATION LENGTH 필드에 지정된 바이트 수가 전송되면 대상 SCSI 계층이 "데이터 입력 버퍼로의 전송을 종료해야 한다"고 요구합니다.

따라서 REPORT LUNS 명령에 대한 응답으로 대상의 SCSI 계층은 개시자로 전송하기 위해 최대 ALLOCATION LENGTH바이트의 데이터\(LU 인벤토리\)를 iSCSI에 제공합니다. REPORT LUNS 명령의 경우 iSCSI EDTL이 최소한 ALLOCATION LENGTH만큼 큰 경우 SCSI 잘림을 통해 EDTL이 전송될 모든 데이터를 수용할 수 있습니다. iSCSI 계층에 제공된 모든 LU 인벤토리 데이터\(예: SCSI 잘림 이후 남은 데이터\)가 iSCSI 계층에 의해 개시자에게 전송되는 경우 iSCSI 잔여 오버플로가 발생하지 않았으며 iSCSI\(O\) 비트가 반드시 필요합니다. SCSI 응답 또는 최종 SCSI 데이터 출력 PDU에 설정하면 안 됩니다. 이 동작은 \[SPC3\]의 REPORT LUNS 명령 사양과 함께 섹션 11.4.5.1에 ​​암시되어 있습니다. 그러나 이 시나리오에서 iSCSI EDTL이 ALLOCATION LENGTH보다 큰 경우 SCSI 응답 PDU에서 iSCSI 언더플로우를 신호로 보내야 합니다. iSCSI EDTL이 ALLOCATION LENGTH와 동일하지만 iSCSI 레이어에 제공되는 LU 인벤토리 데이터가 ALLOCATION LENGTH보다 작은 경우에도 iSCSI 언더플로우를 신호로 보내야 합니다.\(MUST NOT, MUST, MUST\)

LU 인벤토리의 LUN LIST LENGTH 필드\(인벤토리의 첫 번째 필드\)는 ALLOCATION LENGTH에 맞게 인벤토리가 잘려도 영향을 받지 않습니다. 이를 통해 SCSI 개시자는 인벤토리의 LUN LIST LENGTH가 REPORT LUNS CDB에서 전송된 ALLOCATION LENGTH보다 크다는 것을 확인하여 수신된 인벤토리가 불완전하다는 것을 결정할 수 있습니다. 이 상황에서 일반적인 초기자 동작은 더 큰 ALLOCATION LENGTH를 사용하여 REPORT LUNS 명령을 다시 실행하는 것입니다.

---
#### **11.4.6.  Bidirectional Read Residual Count**

양방향 읽기 잔여 개수 필드는 u 비트 또는 o 비트가 설정된 경우 유효해야 합니다. 두 비트 모두 설정되지 않은 경우 양방향 읽기 잔여 개수 필드가 예약됩니다. 대상은 양방향 읽기 잔여 개수를 설정할 수 있으며, 개시자는 응답 코드가 대상에서 명령 완료일 때 이를 사용할 수 있습니다. o 비트가 설정된 경우 양방향 읽기 잔여 개수는 개시자의 양방향 읽기 예상 데이터 전송 길이가 충분하지 않아 개시자로 전송되지 않은 바이트 수를 나타냅니다. u 비트가 설정된 경우 양방향 읽기 잔여 개수는 전송될 것으로 예상되는 바이트 수 중에서 개시자로 전송되지 않은 바이트 수를 나타냅니다.\(MUST\)

---
#### **11.4.7.  Data Segment - Sense and Response Data Segment**

iSCSI 대상은 자동 감지를 지원하고 활성화해야 합니다. Status가 CHECK CONDITION\(0x02\)인 경우 데이터 세그먼트에는 실패한 명령에 대한 감지 데이터가 포함되어야 합니다.\(MUST, MUST\)

일부 iSCSI 응답의 경우 응답 데이터 세그먼트에 일부 응답 관련 정보가 포함될 수 있습니다\(예: 대상 오류의 경우 오류에 대한 공급업체별 세부 설명이 포함될 수 있음\).\(MAY\)

DataSegmentLength가 0이 아닌 경우 데이터 세그먼트의 형식은 다음과 같습니다.

```text
   Byte/     0       |       1       |       2       |       3       |
      /              |               |               |               |
     |0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|
     +---------------+---------------+---------------+---------------+
    0|SenseLength                    | Sense Data                    |
     +---------------+---------------+---------------+---------------+
    x/ Sense Data                                                    /
     +---------------+---------------+---------------+---------------+
    y/ Response Data                                                 /
     /                                                               /
     +---------------+---------------+---------------+---------------+
```

---
##### **11.4.7.1.  SenseLength**

이 필드는 감지 데이터의 길이를 나타냅니다.

---
##### **11.4.7.2.  Sense Data**

감지 데이터에는 확인 조건에 대한 자세한 정보가 포함되어 있습니다. \[SPC3\]은 감지 데이터의 형식과 내용을 지정합니다.

특정 iSCSI 조건으로 인해 다음 표에 설명된 대로 SCSI CHECK CONDITION 상태와 함께 대상\(대상에서 완료된 명령의 응답 코드\)에서 명령이 종료됩니다.

```text
   +--------------------------+-----------+---------------------------+
   | iSCSI Condition          |Sense      | Additional Sense Code and |
   |                          |Key        | Qualifier                 |
   +--------------------------+-----------+---------------------------+
   | Unexpected unsolicited   |Aborted    | ASC = 0x0c ASCQ = 0x0c    |
   | data                     |Command-0B | Write Error               |
   +--------------------------+-----------+---------------------------+
   | Incorrect amount of data |Aborted    | ASC = 0x0c ASCQ = 0x0d    |
   |                          |Command-0B | Write Error               |
   +--------------------------+-----------+---------------------------+
   | Protocol Service CRC     |Aborted    | ASC = 0x47 ASCQ = 0x05    |
   | error                    |Command-0B | CRC Error Detected        |
   +--------------------------+-----------+---------------------------+
   | SNACK rejected           |Aborted    | ASC = 0x11 ASCQ = 0x13    |
   |                          |Command-0B | Read Error                |
   +--------------------------+-----------+---------------------------+
```

데이터 출력 중에 출력할 총 데이터 길이가 FirstBurstLength보다 크고 개시자가 원치 않는 비즉시 데이터를 보냈지만 원치 않는 데이터의 총량이 FirstBurstLength와 다른 경우 대상은 "잘못된 데이터 양" 조건을 보고합니다. R2T에 대한 응답으로 전송된 데이터 양이 요청한 양과 일치하지 않으면 대상에서 동일한 오류를 보고합니다.

---
#### **11.4.8.  ExpDataSN**

이 필드는 대상이 명령을 위해 보낸 Data-In\(읽기\) PDU의 수를 나타냅니다.

응답 코드가 대상에서 명령 완료가 아니거나 대상이 명령에 대해 Data-In PDU를 전송하지 않은 경우 이 필드는 0이어야 합니다.\(MUST\)

---
#### **11.4.9.  StatSN - Status Sequence Number**

StatSN은 대상 iSCSI 계층이 연결별로 생성하고 이를 통해 개시자가 상태 수신을 확인할 수 있도록 하는 시퀀스 번호입니다. StatSN은 연결에서 전송된 모든 응답/상태에 대해 1씩 증가합니다.

재시도 또는 SNACK의 결과. 재전송 요청으로 인해 전송된 응답의 경우 연결이 다시 시작되지 않는 한 StatSN은 PDU가 처음 전송되었을 때와 동일해야 합니다.\(MUST\)

---
#### **11.4.10.  ExpCmdSN - Next Expected CmdSN from This Initiator**

ExpCmdSN은 명령 수신을 확인하기 위해 대상 iSCSI가 개시자에게 반환하는 시퀀스 번호입니다. 동일한 이름을 가진 지역 변수를 업데이트하는 데 사용됩니다. MaxCmdSN + 1과 동일한 ExpCmdSN은 대상이 새 명령을 받아들일 수 없음을 나타냅니다.

---
#### **11.4.11.  MaxCmdSN - Maximum CmdSN from This Initiator**

MaxCmdSN은 개시자가 보낼 수 있는 최대 CmdSN을 나타내기 위해 대상 iSCSI가 개시자에게 반환하는 시퀀스 번호입니다. 동일한 이름을 가진 지역 변수를 업데이트하는 데 사용됩니다. MaxCmdSN이 ExpCmdSN - 1과 같은 경우 이는 대상이 추가 명령을 받을 수 없음을 개시자에게 나타냅니다. 대상에 개시자에게 이 정보를 전달하기 위한 보류 중인 PDU가 없는 동안 MaxCmdSN이 대상에서 변경되면 새로운 MaxCmdSN을 전달하기 위해 NOP-In을 생성해야 합니다.\(MUST\)

---
### **11.5.  Task Management Function Request**

```text
   Byte/     0       |       1       |       2       |       3       |
      /              |               |               |               |
     |0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|
     +---------------+---------------+---------------+---------------+
    0|.|I| 0x02      |1| Function    | Reserved                      |
     +---------------+---------------+---------------+---------------+
    4|TotalAHSLength | DataSegmentLength                             |
     +---------------+---------------+---------------+---------------+
    8| Logical Unit Number (LUN) or Reserved                         |
     +                                                               +
   12|                                                               |
     +---------------+---------------+---------------+---------------+
   16| Initiator Task Tag                                            |
     +---------------+---------------+---------------+---------------+
   20| Referenced Task Tag or 0xffffffff                             |
     +---------------+---------------+---------------+---------------+
   24| CmdSN                                                         |
     +---------------+---------------+---------------+---------------+
   28| ExpStatSN                                                     |
     +---------------+---------------+---------------+---------------+
   32| RefCmdSN or Reserved                                          |
     +---------------+---------------+---------------+---------------+
   36| ExpDataSN or Reserved                                         |
     +---------------+---------------+---------------+---------------+
   40/ Reserved                                                      /
    +/                                                               /
     +---------------+---------------+---------------+---------------+
   48| Header-Digest (optional)                                      |
     +---------------+---------------+---------------+---------------+
```

---
#### **11.5.1.  Function**

작업 관리 기능은 개시자에게 하나 이상의 작업\(SCSI 및 iSCSI 작업\)의 실행을 명시적으로 제어하는 ​​방법을 제공합니다. 작업 관리 기능 코드는 다음과 같습니다. SCSI 작업 관리에 대한 자세한 설명은 \[SAM2\]를 참조하세요.

- 1 ABORT TASK - 참조된 작업 태그 필드로 식별된 작업을 중단합니다.

- 2 ABORT TASK SET - LU에서 이 세션을 통해 실행된 모든 작업을 중단합니다.

- 3 CLEAR ACA - 자동 조건부 충성 조건을 지웁니다.

- 4 CLEAR TASK SET - 제어 모드 페이지의 TST 필드에 정의된 대로 해당 작업 세트의 모든 작업을 중단합니다\(\[SPC3\] 참조\).

```text
      5  LOGICAL UNIT RESET

      6  TARGET WARM RESET

      7  TARGET COLD RESET
```

- 8 작업 재할당 - 개시자 작업 태그 필드로 식별된 작업에 대한 연결 충성을 이 연결에 재할당하여 해당 작업에 대한 iSCSI 교환을 재개합니다.

값 9-12는 \[RFC7144\]에 할당됩니다. 기능 필드에 사용할 수 있는 다른 모든 값은 할당되지 않습니다.

이러한 모든 기능에 대해 작업 관리 기능 응답은 섹션 11.6에 설명된 대로 반환되어야 합니다. 이러한 모든 기능은 적절한 SCSI 작업인지 또는 태그가 지정된 iSCSI 작업인지에 관계없이 참조된 작업에 적용됩니다. 작업 관리 요청은 작업 관리 CmdSN보다 낮은 CmdSN을 갖는 동일한 세션의 모든 명령에 대해 작동해야 합니다. LOGICAL UNIT RESET, TARGET WARM RESET 및 TARGET COLD RESET은 CmdSN 값에 관계없이 다른 세션의 명령이나 동일한 세션의 명령에 영향을 미칠 수 있습니다.\(MUST\)

작업 관리 요청이 즉시 전달되도록 표시된 경우 즉시 실행을 고려해야 하지만 관련된 작업\(전체 또는 일부\)은 대상이 모든 관련 작업을 받을 수 있도록 연기될 수 있습니다. \[SAM2\]에 따르면, 작업 관리 응답이 적용되는 모든 작업\(즉, 작업 관리 명령 CmdSN보다 낮은 CmdSN\)에 대해 TASK REASSIGN에 대한 작업 관리 응답을 제외하고 추가 응답은 SAM2에 전달되어서는 안 됩니다. 작업 관리 응답 후의 SCSI 레이어입니다. iSCSI 개시자는 작업 관리 응답 이전에 수신된 모든 응답을 SCSI 계층에 전달할 수 있습니다. 즉, 작업 관리 응답 이전에 수신되었지만 작업 관리 요청이 발행된 후에 수신된 SCSI 응답이 서버에 전달되는지는 구현의 문제입니다. 개시자의 iSCSI 계층에 의한 SCSI 계층\). iSCSI 대상은 TASK REASSIGN에 포함된 작업을 제외하고 작업 관리 응답 후에 작업 관리 기능에 포함된 작업에 대한 응답이 iSCSI 개시자에 전달되지 않도록 해야 합니다.\(MUST NOT, MAY, MUST\)

ABORT TASK SET 및 CLEAR TASK SET의 경우, 발행 개시자는 영향을 받은 작업 세트와 관련된 모든 유효한 대상 전송 태그\(R2T, 텍스트 응답, NOP-In 또는 SCSI Data-In PDU를 통해 수신됨\)에 계속 응답해야 합니다. 작업 관리 요청을 발행합니다.\(MUST\)

그러나 발행 개시자는 이러한 응답 시퀀스를 가능한 한 빨리 종료해야 합니다\(즉, F 비트를 1로 설정하여\). 해당 부분의 대상은 이러한 두 가지 작업 관리 요청 중 하나를 수행하기 전에 영향을 받는 모든 대상 전송 태그에 대한 응답을 기다려야 합니다. 유효한 TTT에 대한 응답 시퀀스의 전부 또는 일부가 수신되지 않은 경우\(다이제스트 오류로 인해\) 대상은 이를 명령 내 오류 복구 클래스\(섹션 7.1.4.1 참조\)의 경우로 처리할 수 있습니다. \>= 1 또는 요청된 작업 세트 기능을 완료하기 위해 연결을 끊을 수도 있습니다.\(SHOULD, MUST, MAY\)

즉시 명령에 의해 생성된 작업에 대해 ABORT TASK가 발행된 경우 RefCmdSN은 작업 관리 요청 자체의 것이어야 합니다\(즉, CmdSN과 RefCmdSN이 동일함\). 그렇지 않으면 RefCmdSN을 중단할 작업의 CmdSN\(CmdSN보다 낮은 값\)으로 설정해야 합니다.\(MUST\)

연결이 여전히 활성 상태인 경우\(즉, 암시적 또는 명시적 로그아웃이 진행되지 않는 경우\) ABORT TASK는 작업 관리 요청이 발행될 때 중단될 작업이 적합한 동일한 연결에서 발행되어야 합니다. 연결이 암시적으로 또는 명시적으로 로그아웃된 경우\(즉, 실패한 연결에 대해 다른 요청이 발행되지 않고 실패한 연결에 대해 다른 응답이 수신되지 않음\) ABORT TASK 함수 요청이 다른 연결에서 발행될 수 있습니다. 그런 다음 이 작업 관리 요청은 중단할 명령에 대한 새로운 충성을 설정하고 중단합니다\(즉, 중단할 작업을 재시도하거나 재할당할 필요가 없으며 전송되었으나 확인되지 않은 경우 해당 상태는 다음과 같습니다\). 재전송 다음에 작업 관리 응답이 옵니다\).\(MUST\)

대상에서 ABORT TASK 기능은 작업 관리 요청에 대해 실행되어서는 안 됩니다. 이러한 요청은 "함수 거부됨"이라는 작업 관리 응답을 초래해야 합니다.\(MUST NOT\)

논리 단위 재설정 기능의 경우 대상은 \[SAM2\]의 논리 단위 재설정 기능에 의해 지시된 대로 동작해야 합니다.\(MUST\)

TARGET WARM RESET 기능과 TARGET COLD RESET 기능의 구현은 선택 사항이며 구현 시 아래 설명된 대로 작동해야 합니다. TARGET WARM RESET은 또한 \[SPC3\]에 정의된 대로 요청 개시자에 대한 SCSI 액세스 제어의 적용을 받습니다. 인증이 대상에서 실패하면 섹션 11.6.1에 설명된 적절한 응답이 대상에 의해 반환되어야 합니다. TARGET COLD RESET 기능은 SCSI 액세스 제어의 대상이 아니지만 해당 실행 권한은 로그인 인증과 같은 iSCSI 메커니즘을 통해 관리될 수 있습니다.\(MAY, MUST\)

TARGET WARM RESET 및 TARGET COLD RESET 기능을 실행할 때 대상은 발행 개시자가 알고 있는 모든 LU에서 보류 중인 모든 작업을 취소합니다. 두 기능 모두 \[SAM2\]에 지정된 TARGET RESET 기능과 동일합니다. 이는 서비스 SCSI 대상 포트에 로그인된 다른 많은 초기자에 영향을 미칠 수 있습니다.

또한 대상은 TARGET COLD RESET 기능을 전원 켜기 이벤트로 처리해야 하므로 모든 개시자에 대한 모든 TCP 연결이 종료됩니다\(모든 세션이 종료됨\). 이러한 이유로 이 SCSI 작업 관리 기능에 대한 서비스 응답\(\[SAM2\]에서 정의\)이 발급 개시자 포트에 안정적으로 전달되지 않을 수 있습니다.\(MUST\)

TASK REASSIGN 기능의 경우 대상은 이 새 연결에 대한 연결 충성을 재할당해야 합니다\(따라서 해당 작업에 대한 iSCSI 교환을 재개해야 합니다\). TASK REASSIGN은 이전에 명령이 실행되었던 연결이 성공적으로 로그아웃된 후에만 대상에서 수신되어야 합니다. 작업 관리 응답은 재할당이 유효해지기 전에 발행되어야 합니다.\(MUST, MUST\)

추가적인 사용법 의미에 대해서는 섹션 7.2를 참조하세요.

대상에서 작업 관리 기능 요청, 활성 텍스트 협상 작업 또는 로그아웃 작업의 연결 충성을 재할당하기 위해 TASK REASSIGN 기능 요청을 실행해서는 안 됩니다. 이러한 요청은 "함수 거부됨"이라는 작업 관리 응답을 초래해야 합니다.\(MUST NOT\)

TASK REASSIGN은 즉각적인 명령으로 실행되어야 합니다.\(MUST\)

---
#### **11.5.2.  TotalAHSLength and DataSegmentLength**

이 PDU의 경우 TotalAHSLength 및 DataSegmentLength는 0이어야 합니다.\(MUST\)

---
#### **11.5.3.  LUN**

이 필드는 특정 LU\(ABORT TASK, CLEAR TASK SET, ABORT TASK SET, CLEAR ACA, LOGICAL UNIT RESET\)를 처리하는 기능에 필요하며 다른 모든 기능에는 예약되어 있습니다.

---
#### **11.5.4.  Referenced Task Tag**

ABORT TASK 기능을 위해 중단되거나 TASK REASSIGN 기능을 위해 재할당될 작업의 Initiator Task Tag입니다. 다른 모든 기능의 경우 이 필드는 예약된 값 0xffffffff로 설정되어야 합니다.\(MUST\)

---
#### **11.5.5.  RefCmdSN**

ABORT TASK가 즉시 명령에 의해 생성된 작업에 대해 실행된 경우 RefCmdSN은 작업 관리 요청 자체의 것이어야 합니다\(즉, CmdSN과 RefCmdSN이 동일함\).\(MUST\)

즉각적이지 않은 명령으로 생성된 작업의 ABORT TASK의 경우 RefCmdSN은 참조된 작업 태그 필드에 의해 식별된 작업의 CmdSN으로 설정되어야 합니다. 참조된 작업 태그 필드에 의해 식별된 작업이 대상과 함께 있지 않은 경우 대상은 섹션 11.6.1에 설명된 대로 이 필드를 사용해야 합니다.\(MUST\)

그렇지 않은 경우 이 필드는 예약되어 있습니다.

---
#### **11.5.6.  ExpDataSN**

복구 목적을 위해 iSCSI 대상과 개시자는 데이터 승인 참조 번호\(초기자가 승인하지 않은 첫 번째 입력 DataSN 번호\)를 유지합니다. 새 명령을 실행할 때 이 숫자는 0으로 설정됩니다. 기능이 이전에 실행된 읽기 또는 양방향 명령에 대한 새로운 연결 충성을 설정하는 TASK REASSIGN인 경우 ExpDataSN에는 업데이트된 데이터 승인 참조 번호 또는 값 0이 포함됩니다. 후자는 데이터 확인 참조 번호가 변경되지 않았음을 나타냅니다. 개시자는 확인하지 않은 이전 실행의 모든 ​​데이터 PDU를 폐기해야 하며, 대상은 데이터 확인 참조 번호로 시작하는 모든 Data-In PDU\(있는 경우\)를 전송해야 합니다. 재전송된 PDU의 수는 재할당 시 MaxRecvDataSegmentLength가 변경되었는지 여부에 따라 원래 전송과 동일할 수도 있고 동일하지 않을 수도 있습니다. 모든 데이터가 승인된 경우 대상은 더 이상 Data-In PDU를 보내지 않을 수도 있습니다.\(MUST, MAY\)

ExpDataSN의 값은 반드시 마지막으로 확인된 Data-In PDU의 DataSN보다 0 이상이어야 하지만 대상이 보낸 마지막 Data-IN PDU의 DataSN + 1보다 커서는 안 됩니다. 다른 값은 대상에서 무시되어야 합니다.\(MUST, MUST\)

다른 기능을 위해 이 필드는 예약되어 있습니다.

---
### **11.6.  Task Management Function Response**

```text
   Byte/     0       |       1       |       2       |       3       |
      /              |               |               |               |
     |0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|
     +---------------+---------------+---------------+---------------+
    0|.|.| 0x22      |1| Reserved    | Response      | Reserved      |
     +---------------+---------------+---------------+---------------+
    4|TotalAHSLength | DataSegmentLength                             |
     +---------------------------------------------------------------+
    8/ Reserved                                                      /
     /                                                               /
     +---------------+---------------+---------------+---------------+
   16| Initiator Task Tag                                            |
     +---------------+---------------+---------------+---------------+
   20| Reserved                                                      |
     +---------------+---------------+---------------+---------------+
   24| StatSN                                                        |
     +---------------+---------------+---------------+---------------+
   28| ExpCmdSN                                                      |
     +---------------+---------------+---------------+---------------+
   32| MaxCmdSN                                                      |
     +---------------+---------------+---------------+---------------+
   36/ Reserved                                                      /
    +/                                                               /
     +---------------+---------------+---------------+---------------+
   48| Header-Digest (optional)                                      |
     +---------------+---------------+---------------+---------------+
```

ABORT TASK, ABORT TASK SET, CLEAR ACA, CLEAR TASK SET, LOGICAL UNIT RESET, TARGET COLD RESET, TARGET WARM RESET, TASK REASSIGN 기능에 대해 대상은 요청된 작업 관리 기능을 수행하고 작업 관리 응답을 다시 보냅니다. 창시자. TASK REASSIGN의 경우, 새로운 연결 충성은 대상이 작업 관리 응답을 발행한 후에만 대상에서 유효해야 합니다.\(MUST\)

---
#### **11.6.1.  Response**

대상은 다음 값을 취할 수 있는 응답을 제공합니다.

```text
       0 - Function complete
       1 - Task does not exist
       2 - LUN does not exist
       3 - Task still allegiant
       4 - Task allegiance reassignment not supported
       5 - Task management function not supported
       6 - Function authorization failed
     255 - Function rejected
```

위의 값 외에도 \[RFC7144\]에서는 값 7을 정의하고 있다.

응답 코드 3과 4의 사용에 대한 논의는 섹션 7.2.2를 참조하세요.

TARGET COLD RESET 및 TARGET WARM RESET 기능의 경우 대상은 발행 개시자에 알려진 모든 LU에서 보류 중인 모든 작업을 취소합니다. TARGET COLD RESET 기능의 경우 대상은 모든 개시자에 대한 모든 TCP 연결을 닫아야 합니다\(모든 세션을 종료함\).\(MUST\)

필요한 경우 응답 코드를 SCSI 서비스 응답 코드 값으로 매핑하는 것은 이 문서의 범위를 벗어납니다. 그러나 기호 측면에서 응답 값 0과 1은 FUNCTION COMPLETE의 SCSI 서비스 응답에 매핑됩니다. 응답 값 2는 INCORRECT LOGICAL UNIT NUMBER의 SCSI 서비스 응답에 매핑됩니다. 다른 모든 응답 값은 FUNCTION REJECTED의 SCSI 서비스 응답에 매핑됩니다. 세션이 종료되기 전에 작업 관리 기능 응답 PDU가 도착하지 않으면 SCSI 서비스 응답은 SERVICE DELIVERY OR TARGET FAILURE입니다.

ABORT TASK SET 및 CLEAR TASK SET에 대한 응답은 영향을 받는 모든 명령이 대상에 의해 수신되고, 해당 작업 관리 기능이 SCSI 대상에 의해 실행되고, 모든 응답이 전달된 후에만 대상에 의해 발행되어야 합니다. 이 세션의 모든 연결에 대해 개시자가 작업 관리 기능 완료를 확인\(ExpStatSN을 통해 승인\)할 때까지. 이벤트의 정확한 타임라인은 섹션 4.2.3.3 및 4.2.3.4를 참조하세요.\(MUST\)

ABORT TASK 기능의 경우,

- a\) 참조된 작업 태그가 성공적인 종료로 이어지는 유효한 작업을 식별하는 경우 대상은 "기능 완료" 응답을 반환해야 합니다.

- b\) 참조된 작업 태그가 기존 작업을 식별하지 않지만 작업 관리 기능 요청의 RefCmdSN 필드에 표시된 CmdSN이 유효한 CmdSN 창 내에 있고 작업 관리 기능 요청 자체의 CmdSN보다 작은 경우 대상은 다음을 수행해야 합니다. CmdSN이 수신된 것으로 간주하고 "기능 완료" 응답을 반환합니다.

- c\) 참조된 작업 태그가 기존 작업을 식별하지 못하고 작업 관리 기능 요청의 RefCmdSN 필드에 표시된 CmdSN이 유효한 CmdSN 창 밖에 있는 경우 대상은 "작업이 존재하지 않음" 응답을 반환해야 합니다.

대상의 여러 활성 작업에 잠재적으로 영향을 미칠 수 있는 함수 유형에 대한 응답 의미는 섹션 4.2.3을 참조하세요.

---
#### **11.6.2.  TotalAHSLength and DataSegmentLength**

이 PDU의 경우 TotalAHSLength 및 DataSegmentLength는 0이어야 합니다.\(MUST\)

---
### **11.7.  SCSI Data-Out and SCSI Data-In**

쓰기 작업을 위한 SCSI 데이터 출력 PDU의 형식은 다음과 같습니다.

```text
   Byte/     0       |       1       |       2       |       3       |
      /              |               |               |               |
     |0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|
     +---------------+---------------+---------------+---------------+
    0|.|.| 0x05      |F| Reserved                                    |
     +---------------+---------------+---------------+---------------+
    4|TotalAHSLength | DataSegmentLength                             |
     +---------------+---------------+---------------+---------------+
    8| LUN or Reserved                                               |
     +                                                               +
   12|                                                               |
     +---------------+---------------+---------------+---------------+
   16| Initiator Task Tag                                            |
     +---------------+---------------+---------------+---------------+
   20| Target Transfer Tag or 0xffffffff                             |
     +---------------+---------------+---------------+---------------+
   24| Reserved                                                      |
     +---------------+---------------+---------------+---------------+
   28| ExpStatSN                                                     |
     +---------------+---------------+---------------+---------------+
   32| Reserved                                                      |
     +---------------+---------------+---------------+---------------+
   36| DataSN                                                        |
     +---------------+---------------+---------------+---------------+
   40| Buffer Offset                                                 |
     +---------------+---------------+---------------+---------------+
   44| Reserved                                                      |
     +---------------+---------------+---------------+---------------+
   48| Header-Digest (optional)                                      |
     +---------------+---------------+---------------+---------------+
     / DataSegment                                                   /
    +/                                                               /
     +---------------+---------------+---------------+---------------+
     | Data-Digest (optional)                                        |
     +---------------+---------------+---------------+---------------+
```

읽기 작업을 위한 SCSI Data-In PDU의 형식은 다음과 같습니다.

```text
   Byte/     0       |       1       |       2       |       3       |
      /              |               |               |               |
     |0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|
     +---------------+---------------+---------------+---------------+
    0|.|.| 0x25      |F|A|0 0 0|O|U|S| Reserved      |Status or Rsvd |
     +---------------+---------------+---------------+---------------+
    4|TotalAHSLength | DataSegmentLength                             |
     +---------------+---------------+---------------+---------------+
    8| LUN or Reserved                                               |
     +                                                               +
   12|                                                               |
     +---------------+---------------+---------------+---------------+
   16| Initiator Task Tag                                            |
     +---------------+---------------+---------------+---------------+
   20| Target Transfer Tag or 0xffffffff                             |
     +---------------+---------------+---------------+---------------+
   24| StatSN or Reserved                                            |
     +---------------+---------------+---------------+---------------+
   28| ExpCmdSN                                                      |
     +---------------+---------------+---------------+---------------+
   32| MaxCmdSN                                                      |
     +---------------+---------------+---------------+---------------+
   36| DataSN                                                        |
     +---------------+---------------+---------------+---------------+
   40| Buffer Offset                                                 |
     +---------------+---------------+---------------+---------------+
   44| Residual Count                                                |
     +---------------+---------------+---------------+---------------+
   48| Header-Digest (optional)                                      |
     +---------------+---------------+---------------+---------------+
     / DataSegment                                                   /
    +/                                                               /
     +---------------+---------------+---------------+---------------+
     | Data-Digest (optional)                                        |
     +---------------+---------------+---------------+---------------+
```

명령이 예외로 끝나지 않은 경우 상태는 마지막 Data-In PDU와 함께 표시될 수 있습니다\(예: 상태가 "양호한 상태" - GOOD, CONDITION MET 또는 INTERMEDIATE-CONDITION MET\). 상태\(및 잔여 카운트\)의 존재는 S 플래그 비트를 통해 신호됩니다. 대상은 별도의 응답으로 비예외 상태도 전송하도록 선택할 수 있지만 개시자는 Data-In PDU에서 비예외 상태를 지원해야 합니다.\(MUST\)

---
#### **11.7.1.  F (Final) Bit**

나가는 데이터의 경우 요청되지 않은 데이터의 마지막 PDU 또는 R2T에 응답하는 시퀀스의 마지막 PDU에 대해 이 비트는 1입니다.

들어오는 데이터의 경우 시퀀스의 마지막 입력\(읽기\) 데이터 PDU에 대해 이 비트는 1입니다. 입력은 각각 자체 F 비트를 갖는 여러 시퀀스로 분할될 수 있습니다. 데이터 스트림을 시퀀스로 분할해도 Data-In PDU의 DataSN 계산에는 영향을 미치지 않습니다. 이러한 변경이 필요한 양방향 작업에 대한 "방향 변경" 표시로 사용될 수 있습니다.\(MAY\)

DataSegmentLength는 전송 방향에 대해 MaxRecvDataSegmentLength를 초과해서는 안 되며, 시퀀스에 있는 모든 PDU의 모든 DataSegmentLength의 총계는 MaxBurstLength\(또는 원치 않는 데이터의 경우 FirstBurstLength\)를 초과해서는 안 됩니다. 그러나 시퀀스\(또는 전체\)의 개별 PDU 수는 MaxBurstLength\(또는 FirstBurstLength\) 대 MaxRecvDataSegmentLength의 비율보다 높을 수 있습니다\(PDU의 길이는 발신자의 기능에 따라 제한될 수 있음\). DataSegmentLength를 0으로 사용하면 PDU 수에 대한 합리적인 수준 이상으로 증가할 수 있으므로 피해야 합니다.\(MUST NOT\)

양방향 작업의 경우 입력 시퀀스의 끝과 출력 시퀀스의 끝 모두 F 비트가 1입니다.

---
#### **11.7.2.  A (Acknowledge) Bit**

ErrorRecoveryLevel=1 이상인 세션의 경우 대상은 이 비트를 1로 설정하여 수신된 데이터에 대해 개시자로부터 긍정적인 승인을 요청함을 나타냅니다. 대상은 A 비트를 적당히 사용해야 합니다. MaxBurstLength 바이트마다 또는 대상의 관점에서 작업에 대해 요청된 전체 읽기 데이터 전송을 마무리하는 마지막 Data-In PDU에서만 A 비트를 1로 설정할 수 있으며 더 자주 설정해서는 안 됩니다. Target은 ErrorRecoveryLevel=0인 세션에 대해 A 비트를 1로 설정해서는 안 됩니다. 개시자는 ErrorRecoveryLevel=0인 세션에 대해 1로 설정된 A 비트를 무시해야 합니다.\(MUST NOT, MUST NOT, MUST\)

ErrorRecoveryLevel이 0보다 큰 세션에서 A 비트가 1로 설정된 Data-In PDU를 수신할 때 해당 Data-In PDU까지 읽기 데이터에 구멍이 없으면 개시자는 DataACK 유형의 SNACK을 발행해야 합니다. 작업 상태도 수신된 경우 다른 아웃바운드 PDU의 ExpStatSN을 통해 즉시 작업 상태를 확인할 수 있는 경우. 후자의 경우\(ExpStatSN을 통한 승인\) A 비트에 대한 응답으로 DataACK 유형의 SNACK을 보내는 것은 선택 사항이지만, 그렇게 한 경우에는\(MUST, MAY\)

ExpStatSN. 개시자가 Data-In PDU 이전에 읽기 데이터에서 홀을 감지한 경우 홀이 채워질 때까지 DataACK 유형의 SNACK 발행을 연기해야 ​​합니다. 또한 개시자는 해당 홀이 채워지기 전에 작업 상태를 승인해서는 안 됩니다. Data-In PDU를 생성한 작업에 대한 상태 확인은 대상이 해당 확인을 요청한 경우 Data-In PDU의 암시적 확인으로 대상에서 간주됩니다.\(MUST, MUST NOT\)

---
#### **11.7.3.  Flags (Byte 1)**

성공적으로 완료된\(GOOD, CONDITION MET, INTERMEDIATE 또는 INTERMEDIATE-CONDITION MET 상태\) SCSI 명령에 대해 대상에서 개시자로 전송된 마지막 SCSI 데이터 패킷에는 선택적으로 데이터 전송 상태가 포함될 수도 있습니다. 이 경우 Command Status와 함께 Sense Data를 전송할 수 없습니다. 명령이 오류와 함께 완료되면 응답 및 감지 데이터는 SCSI 응답 PDU로 전송되어야 합니다\(즉, SCSI 데이터 패킷으로 전송되어서는 안 됩니다\). 양방향 명령의 경우 상태는 SCSI 응답 PDU로 전송되어야 합니다.\(MUST NOT, MUST\)

```text
      bit 2-4          - Reserved.
```

- 비트 5-6 - SCSI 응답과 동일하게 사용됩니다. 이 비트는 S가 1로 설정된 경우에만 유효합니다. 자세한 내용은 11.4.1항을 참조하십시오.

- 비트 7 S\(상태\) - 명령 상태 필드에 상태가 포함되어 있음을 나타내도록 설정됩니다. 이 비트가 1로 설정되면 F 비트도 1로 설정되어야 합니다.\(MUST\)

StatSN, Status 및 Residual Count 필드는 S 비트가 1로 설정된 경우에만 의미 있는 내용을 갖습니다. 이러한 필드의 값은 섹션 11.4에 정의되어 있습니다.

---
#### **11.7.4.  Target Transfer Tag and LUN**

나가는 데이터에서 전송이 R2T를 준수하는 경우 대상 전송 태그가 대상에 제공됩니다. 이 경우 Target Transfer Tag 필드는 R2T와 함께 제공되는 Target Transfer Tag의 복제본입니다.

수신 데이터에서 A 비트가 1로 설정된 경우 대상 전송 태그 및 LUN은 대상에서 제공되어야 합니다. 그렇지 않으면 예약되어 있습니다. 대상 전송 태그와 LUN은 개시자에 의해 A 비트가 1로 설정된 SCSI Data-In PDU를 수신한 결과로 발행되는 DataACK 유형의 SNACK에 복사됩니다.\(MUST\)

대상 전송 태그 값은 0xffffffff 값이 예약되어 있고 대상 전송 태그가 제공되지 않음을 의미한다는 점을 제외하면 이 프로토콜에서 지정되지 않습니다. 대상 전송 태그가 제공되면 LUN 필드는 유효한 값을 보유해야 하며 명령에 지정된 내용과 일치해야 합니다. 그렇지 않으면 LUN 필드가 예약됩니다.\(MUST\)

---
#### **11.7.5.  DataSN**

입력\(읽기\) 또는 양방향 Data-In PDU의 경우 DataSN은 개시자 작업 태그로 식별되는 명령에 대한 데이터 전송 내의 입력 PDU 번호입니다.

R2T 및 Data-In PDU는 양방향 명령의 맥락에서 번호 지정 순서를 공유합니다\(섹션 4.2.2.4 참조\).

출력\(쓰기\) 데이터 PDU의 경우 DataSN은 현재 출력 시퀀스 내의 데이터 출력 PDU 번호입니다. 현재 출력 시퀀스는 개시자 작업 태그\(요청되지 않은 데이터의 경우\)로 식별되거나 하나의 R2T에 대해 생성된 데이터 시퀀스\(R2T를 통해 요청된 데이터의 경우\)입니다.

---
#### **11.7.6.  Buffer Offset**

버퍼 오프셋 필드에는 전체 데이터 전송 내에서 이 PDU 페이로드 데이터의 오프셋이 포함됩니다. 버퍼 오프셋과 길이의 합은 명령의 예상 전송 길이를 초과해서는 안 됩니다.

시퀀스 내 데이터 PDU의 순서는 DataPDUInOrder에 의해 결정됩니다. Yes로 설정하면 PDU가 버퍼 오프셋 순서가 증가해야 하며 오버레이가 금지됨을 의미합니다.

시퀀스 간의 순서는 DataSequenceInOrder에 의해 결정됩니다. 예로 설정하면 시퀀스가 ​​버퍼 오프셋 순서가 증가해야 하며 오버레이가 금지됨을 의미합니다.

---
#### **11.7.7.  DataSegmentLength**

이는 SCSI 데이터 입력 또는 SCSI 데이터 출력 PDU의 데이터 페이로드 길이입니다. 길이가 0인 데이터 세그먼트의 전송은 피해야 하지만 개시자와 대상은 길이가 0인 데이터 세그먼트를 올바르게 수신할 수 있어야 합니다.\(MUST\)

F 비트가 1로 설정되지 않는 한 Data-In 및 Data-Out PDU의 데이터 세그먼트는 4바이트 단어\(실제 페이로드\)의 정수로 채워져야 합니다.\(SHOULD\)

---
### **11.8.  Ready To Transfer (R2T)**

```text
   Byte/     0       |       1       |       2       |       3       |
      /              |               |               |               |
     |0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|
     +---------------+---------------+---------------+---------------+
    0|.|.| 0x31      |1| Reserved                                    |
     +---------------+---------------+---------------+---------------+
    4|TotalAHSLength | DataSegmentLength                             |
     +---------------+---------------+---------------+---------------+
    8| LUN                                                           |
     +                                                               +
   12|                                                               |
     +---------------+---------------+---------------+---------------+
   16| Initiator Task Tag                                            |
     +---------------+---------------+---------------+---------------+
   20| Target Transfer Tag                                           |
     +---------------+---------------+---------------+---------------+
   24| StatSN                                                        |
     +---------------+---------------+---------------+---------------+
   28| ExpCmdSN                                                      |
     +---------------+---------------+---------------+---------------+
   32| MaxCmdSN                                                      |
     +---------------+---------------+---------------+---------------+
   36| R2TSN                                                         |
     +---------------+---------------+---------------+---------------+
   40| Buffer Offset                                                 |
     +---------------+---------------+---------------+---------------+
   44| Desired Data Transfer Length                                  |
     +---------------------------------------------------------------+
   48| Header-Digest (optional)                                      |
     +---------------+---------------+---------------+---------------+
```

개시자가 개시자에서 대상으로 전달되는\(쓰기\) 데이터와 함께 SCSI 명령을 제출하면 대상은 수신할 준비가 된 데이터 블록을 지정할 수 있습니다. 타겟은 특정 순간에 타겟에게 편리한 순서로 데이터 블록이 전달되도록 요청할 수 있습니다. 이 정보는 R2T\(Ready To Transfer\) PDU를 통해 대상에서 개시자로 전달됩니다.

명시적인 초기 R2T 없이 쓰기 작업을 허용하려면 개시자와 대상이 로그인 중에 초기 R2T 키를 아니요로 협상해야 합니다.\(MUST\)

R2T는 일치하는 대상 전송 태그가 있는 하나 이상의 SCSI 데이터 출력 PDU로 응답할 수 있습니다. R2T가 단일 데이터 출력 PDU로 응답되는 경우 데이터 PDU의 버퍼 오프셋은 다음과 같아야 합니다.\(MAY, MUST\)

R2T에 의해 지정된 것과 데이터 PDU의 데이터 길이는 R2T에 지정된 원하는 데이터 전송 길이와 동일해야 합니다. R2T가 데이터 PDU 시퀀스로 응답하는 경우 버퍼 오프셋과 길이는 R2T에서 지정한 범위 내에 있어야 하며 마지막 PDU의 F 비트는 1로 설정되어야 합니다. F 비트\)가 원하는 데이터 전송 길이가 전송되기 전에 수신되면 대상은 "프로토콜 오류" 이유 코드와 함께 해당 PDU를 거부하도록 선택할 수 있습니다. DataPDUInOrder는 데이터 출력 PDU 순서를 관리합니다. DataPDUInOrder가 Yes로 설정된 경우 연속 PDU에 대한 버퍼 오프셋과 길이는 연속적인 비중첩 범위를 형성해야 하며 PDU는 오프셋 증가 순서로 전송되어야 합니다.\(MUST, MUST, MAY, MUST\)

대상은 여러 R2T PDU를 보낼 수 있습니다. 따라서 보류 중인 데이터 전송 수가 많을 수 있습니다. 미해결 R2T PDU 수는 협상된 키 MaxOutstandingR2T의 값으로 제한됩니다. 작업 내에서 미해결 R2T는 수신된 순서대로 개시자에 의해 이행되어야 합니다.\(MUST\)

R2T PDU는 데이터 출력 PDU를 복구하는 데에도 사용될 수 있습니다. 이러한 R2T\(Recovery-R2T\)는 다음으로 인해 하나 이상의 Data-Out PDU 손실이 감지되면 대상에 의해 생성됩니다.\(MAY\)

```text
      - Digest error

      - Sequence error

      - Sequence reception timeout
```

Recovery-R2T는 사용되지 않은 다음 R2TSN을 전달하지만 이전 R2T\(더 낮은 R2TSN 포함\)가 이미 요청한 데이터 버스트의 일부 또는 전체를 요청합니다.

DataSequenceInOrder는 연속 R2T의 버퍼 오프셋 순서를 제어합니다. DataSequenceInOrder가 Yes인 경우 연속 R2T는 Recovery-R2T를 제외하고 연속적이고 겹치지 않는 범위를 참조해야 합니다.\(MUST\)

---
#### **11.8.1.  TotalAHSLength and DataSegmentLength**

이 PDU의 경우 TotalAHSLength 및 DataSegmentLength는 0이어야 합니다.\(MUST\)

---
#### **11.8.2.  R2TSN**

R2TSN은 개시자 작업 태그로 식별되는 명령 내의 R2T PDU 입력 PDU 번호입니다.

양방향 명령의 경우 R2T 및 Data-In PDU는 입력 PDU 번호 지정 순서를 공유합니다\(섹션 4.2.2.4 참조\).

---
#### **11.8.3.  StatSN**

StatSN 필드에는 다음 StatSN이 포함됩니다. 이 연결에 대한 StatSN은 이 PDU가 전송된 후에 진행되지 않습니다.

---
#### **11.8.4.  Desired Data Transfer Length and Buffer Offset**

대상은 이 R2T PDU로 인해 개시자가 전송하기를 원하는 바이트 수를 지정합니다. 대상은 데이터의 원래 순서가 아닌 여러 청크의 데이터를 개시자에게 요청할 수 있습니다. 따라서 대상은 전체 데이터 전송의 시작을 기준으로 데이터 전송이 시작되어야 하는 지점을 나타내는 버퍼 오프셋도 지정합니다. 원하는 데이터 전송 길이는 0이 아니어야 하며 MaxBurstLength를 초과해서는 안 됩니다.\(MUST NOT\)

---
#### **11.8.5.  Target Transfer Tag**

대상은 개시자에게 보내는 각 R2T 요청에 자체 태그를 할당합니다. 이 태그는 대상이 수신하는 데이터를 쉽게 식별하는 데 사용될 수 있습니다. 대상 전송 태그 및 LUN은 나가는 데이터 PDU에 복사되며 대상에서만 사용됩니다. 0xffffffff 값이 예약되어 있고 R2T의 대상에 의해 전송되어서는 안 된다는 점을 제외하고는 대상 전송 태그에 대한 프로토콜 규칙이 없습니다.\(MUST NOT\)

---
### **11.9.  Asynchronous Message**

특정 명령에 대응하지 않고 비동기 메시지가 대상에서 개시자로 전송될 수 있습니다. 타겟은 이벤트의 원인과 감지 데이터를 지정합니다.

```text
   Byte/     0       |       1       |       2       |       3       |
      /              |               |               |               |
     |0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|
     +---------------+---------------+---------------+---------------+
    0|.|.| 0x32      |1| Reserved                                    |
     +---------------+---------------+---------------+---------------+
    4|TotalAHSLength | DataSegmentLength                             |
     +---------------+---------------+---------------+---------------+
    8| LUN or Reserved                                               |
     +                                                               +
   12|                                                               |
     +---------------+---------------+---------------+---------------+
   16| 0xffffffff                                                    |
     +---------------+---------------+---------------+---------------+
   20| Reserved                                                      |
     +---------------+---------------+---------------+---------------+
   24| StatSN                                                        |
     +---------------+---------------+---------------+---------------+
   28| ExpCmdSN                                                      |
     +---------------+---------------+---------------+---------------+
   32| MaxCmdSN                                                      |
     +---------------+---------------+---------------+---------------+
   36| AsyncEvent    | AsyncVCode    | Parameter1 or Reserved        |
     +---------------+---------------+---------------+---------------+
   40| Parameter2 or Reserved        | Parameter3 or Reserved        |
     +---------------+---------------+---------------+---------------+
   44| Reserved                                                      |
     +---------------+---------------+---------------+---------------+
   48| Header-Digest (optional)                                      |
     +---------------+---------------+---------------+---------------+
     / DataSegment - Sense Data and iSCSI Event Data                 /
    +/                                                               /
     +---------------+---------------+---------------+---------------+
     | Data-Digest (optional)                                        |
     +---------------+---------------+---------------+---------------+
```

일부 비동기 메시지는 iSCSI와 엄격하게 관련되어 있는 반면 다른 메시지는 SCSI\[SAM2\]와 관련되어 있습니다.

StatSN은 이 PDU를 승인 가능한 이벤트\(StatSN은 고급\)로 계산하여 개시자와 대상 상태 동기화를 허용합니다.

---
#### **11.9.1.  AsyncEvent**

iSCSI 비동기 메시지\(이벤트\)에 사용되는 코드는 다음과 같습니다.

- 0\(SCSI 비동기 이벤트\) - SCSI 비동기 이벤트가 감지 데이터에 보고됩니다. 데이터 세그먼트에서 보고서와 함께 제공되는 감지 데이터는 조건을 식별합니다. SCSI 이벤트\(SCSI 용어로 "비동기 이벤트 보고"\) 전송은 표준 INQUIRY 데이터\(\[SPC3\] 참조\)에 표시된 대로 SCSI 비동기 이벤트 보고\(\[SAM2\] 참조\)에 대한 대상 지원에 따라 달라집니다. SCSI 제어 모드 페이지\(\[SPC3\] 참조\)의 매개변수에 의해 사용이 활성화될 수 있습니다.

- 1\(로그아웃 요청\) - 대상이 로그아웃을 요청합니다. 이 비동기 메시지는 로그아웃을 요청하는 것과 동일한 연결에서 전송되어야 합니다. 개시자는 가능한 빨리, 늦어도 Parameter3초 이내에 로그아웃을 발행하여 이 요청을 존중해야 합니다. 개시자는 모든 연결을 닫으려면 "연결 닫기" 또는 "세션 닫기"라는 이유 코드와 함께 로그아웃을 보내야 합니다. 이 메시지가 수신되면 개시자는 로그아웃할 연결에 대해 새로운 iSCSI 명령을 실행해서는 안 됩니다. 대상은 "로그아웃 대기 중"이라는 이유 코드와 함께 이 메시지 이후에 수신되는 모든 새 I/O 요청을 거부할 수 있습니다. 이니시에이터가 Parameter3초 내에 로그아웃하지 않으면 대상은 가능한 경우 iSCSI 이벤트 코드 "연결 끊김"과 함께 비동기 PDU를 보내거나 간단히 전송 연결을 종료해야 합니다. Parameter1과 Parameter2는 예약되어 있습니다.\(MUST, MUST, MUST, SHOULD NOT, MAY\)

- 2\(연결 끊김 알림\) - 대상이 연결을 끊을 것임을 나타냅니다.

- Parameter1 필드는 끊어질 연결의 CID를 나타냅니다.

- Parameter2 필드\(Time2Wait\)는 재연결 또는 재할당을 시도하기 전에 대기하는 최소 시간을 초 단위로 나타냅니다.

- Parameter3 필드\(Time2Retain\)는 초기 대기\(Parameter2에서\) 후 명령을 재할당하는 데 허용되는 최대 시간을 나타냅니다.

```text
          If the initiator does not attempt to reconnect and/or reassign
          the outstanding commands within the time specified by
          Parameter3, or if Parameter3 is 0, the target will terminate
```

- 이 연결에서 처리되지 않은 모든 명령입니다. 이 경우 이 연결에서 처리되지 않은 명령에 대해 대상으로부터 다른 응답이 예상되어서는 안 됩니다.

- Parameter2의 값이 0이면 즉시 재연결을 시도할 수 있음을 나타냅니다.

- 3\(세션 삭제 알림\) - 대상은 이 세션의 모든 연결을 삭제할 것임을 나타냅니다.

- Parameter1 필드는 예약되어 있습니다.

- Parameter2 필드\(Time2Wait\)는 재연결을 시도하기 전에 대기하는 최소 시간을 초 단위로 나타냅니다.

- Parameter3 필드\(Time2Retain\)는 초기 대기\(Parameter2에서\) 후 명령을 재할당하는 데 허용되는 최대 시간을 나타냅니다.

- Initiator가 Parameter3에 지정된 시간 내에 미해결 명령을 재연결 및/또는 재할당을 시도하지 않거나 Parameter3이 0인 경우 세션이 종료됩니다. 이 경우 대상은 이 세션에서 처리되지 않은 모든 명령을 종료합니다. 이 세션에서 처리되지 않은 명령에 대해 대상으로부터 다른 응답이 예상되어서는 안 됩니다. Parameter2의 값이 0이면 즉시 재연결을 시도할 수 있음을 나타냅니다.

4\(협상 요청\) - 대상 요청 매개변수

- 이 연결에 대한 협상입니다. 개시자는 가능한 한 빨리 동일한 연결에서 텍스트 요청\(비어 있을 수 있음\)을 발행하여\(비어 있을 수 있음\) 이 요청을 존중해야 합니다. 단, 텍스트 요청이 연결에서 이미 보류 중인 경우가 아니면 로그아웃 요청을 발행하여 Parameter3 초 이내에 해야 합니다. . 개시자가 텍스트 요청을 발행하지 않으면 대상은 매개변수 협상을 요청하는 비동기 메시지를 다시 발행할 수 있습니다.\(MUST\)

- 5\(작업 종료\) - 비동기 메시지 PDU의 일치하는 LUN 필드가 있는 LU에 대한 모든 활성 작업이 종료됩니다. 수신 개시자 iSCSI 계층은 다음 단계를 순서대로 수행하여 이 메시지에 응답해야 합니다.\(MUST\)

- - 비동기 메시지 PDU에 인용된 영향을 받는 LUN에 대한 모든 활성 TTT에 대해 해당 연결에서 데이터 출력 전송을 중지합니다.

- - LUN 필드를 비동기 메시지에서 NOP-Out으로 복사하는 동안 ITT=0xffffffff\(즉, ​​비핑 방식\)인 NOP-Out PDU를 통해 비동기 메시지 PDU의 StatSN을 인식합니다.

- 그러나 이 AsyncEvent 값은 섹션 13.23에 정의된 새로운 TaskReporting 텍스트 키가 세션에서 FastAbort와 협상되지 않는 한 iSCSI 세션에서 사용되어서는 안 됩니다.\(MUST NOT\)

248-255\(공급업체 고유\) - 공급업체별 iSCSI 이벤트입니다. 그만큼

- AsyncVCode는 공급업체 코드를 자세히 설명하며 데이터가 보고서와 함께 제공될 수 있습니다.\(MAY\)

다른 모든 이벤트 코드는 할당되지 않습니다.

---
#### **11.9.2.  AsyncVCode**

AsyncVCode는 AsyncEvent 필드가 공급업체별 이벤트를 나타내는 경우에만 유효한 공급업체별 세부 코드입니다. 그렇지 않으면 예약되어 있습니다.

---
#### **11.9.3.  LUN**

AsyncEvent가 0인 경우 LUN 필드가 유효해야 합니다. 그렇지 않은 경우 이 필드는 예약되어 있습니다.\(MUST\)

---
#### **11.9.4.  Sense Data and iSCSI Event Data**

SCSI 이벤트의 경우 이 데이터는 데이터 세그먼트의 보고서와 함께 제공되며 조건을 식별합니다.

iSCSI 이벤트의 경우 추가 공급업체 고유 데이터가 비동기 이벤트와 함께 제공될 수 있습니다. 개시자는 PDU의 나머지 부분을 처리하는 동안 이해되지 않은 데이터를 무시할 수 있습니다.\(MAY, MAY\)

DataSegmentLength가 0이 아닌 경우 DataSegment의 형식은 다음과 같습니다.

```text
   Byte/     0       |       1       |       2       |       3       |
      /              |               |               |               |
     |0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|
     +---------------+---------------+---------------+---------------+
    0|SenseLength                    | Sense Data                    |
     +---------------+---------------+---------------+---------------+
    x/ Sense Data                                                    /
     +---------------+---------------+---------------+---------------+
    y/ iSCSI Event Data                                              /
     /                                                               /
     +---------------+---------------+---------------+---------------+
    z|
```

---
##### **11.9.4.1.  SenseLength**

Sense Data의 길이입니다. 감지 데이터 필드가 비어 있으면\(예: 이벤트가 SCSI 이벤트가 아닌 경우\) SenseLength는 0입니다.

---
### **11.10.  Text Request**

정보 교환과 향후 확장을 위해 텍스트 요청이 제공됩니다. 이를 통해 개시자는 대상에게 자신의 기능을 알리거나 일부 특수 작업을 요청할 수 있습니다.

```text
   Byte/     0       |       1       |       2       |       3       |
      /              |               |               |               |
     |0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|
     +---------------+---------------+---------------+---------------+
    0|.|I| 0x04      |F|C| Reserved                                  |
     +---------------+---------------+---------------+---------------+
    4|TotalAHSLength | DataSegmentLength                             |
     +---------------+---------------+---------------+---------------+
    8| LUN or Reserved                                               |
     +                                                               +
   12|                                                               |
     +---------------+---------------+---------------+---------------+
   16| Initiator Task Tag                                            |
     +---------------+---------------+---------------+---------------+
   20| Target Transfer Tag or 0xffffffff                             |
     +---------------+---------------+---------------+---------------+
   24| CmdSN                                                         |
     +---------------+---------------+---------------+---------------+
   28| ExpStatSN                                                     |
     +---------------+---------------+---------------+---------------+
   32/ Reserved                                                      /
    +/                                                               /
     +---------------+---------------+---------------+---------------+
   48| Header-Digest (optional)                                      |
     +---------------+---------------+---------------+---------------+
     / DataSegment (Text)                                            /
    +/                                                               /
     +---------------+---------------+---------------+---------------+
     | Data-Digest (optional)                                        |
     +---------------+---------------+---------------+---------------+
```

개시자는 주어진 시간에 연결에 대해 하나 이상의 미해결 텍스트 요청을 가져서는 안 됩니다.\(MUST NOT\)

연결이 실패하면 개시자는 활성 충성 텍스트 협상 작업을 명시적으로 중단하거나 해당 작업이 대상에 의해 암시적으로 종료되도록 해야 합니다.

---
#### **11.10.1.  F (Final) Bit**

1로 설정된 경우 이 비트는 이것이 텍스트 요청 시퀀스의 마지막 또는 유일한 텍스트 요청임을 나타냅니다. 그렇지 않으면 더 많은 텍스트 요청이 뒤따를 것임을 나타냅니다.

---
#### **11.10.2.  C (Continue) Bit**

1로 설정되면 이 비트는 이 텍스트 요청의 텍스트\(키=값 쌍 집합\)가 완전하지 않음을 나타냅니다\(이후 텍스트 요청에서 계속됨\). 그렇지 않으면 이 텍스트 요청이 일련의 키=값 쌍을 종료함을 나타냅니다. C 비트가 1로 설정된 텍스트 요청은 F 비트를 0으로 설정해야 합니다.\(MUST\)

---
#### **11.10.3.  Initiator Task Tag**

이 텍스트 요청에 대해 개시자가 할당한 식별자입니다. 명령이 텍스트 요청 및 응답 시퀀스의 일부로 전송되는 경우 개시자 작업 태그는 시퀀스 내의 모든 요청에 ​​대해 동일해야 합니다\(링크된 SCSI 명령과 유사\). 시퀀스의 모든 요청에 ​​대한 I 비트도 동일해야 합니다.\(MUST, MUST\)

---
#### **11.10.4.  Target Transfer Tag**

대상 전송 태그가 예약된 값 0xffffffff로 설정되면 대상에 이것이 새 요청임을 알리고 대상은 개시자 작업 태그와 연결된 모든 내부 상태를 재설정합니다\(현재 협상 상태 재설정\).

대상은 지정된 개시자 작업 태그와 관련하여 전송할 데이터가 더 많거나 수행할 작업이 더 많다는 것을 나타낼 때마다 텍스트 응답의 대상 전송 태그를 예약된 값 0xffffffff가 아닌 다른 값으로 설정합니다. 응답에서 F 비트를 0으로 설정할 때마다 그렇게 해야 합니다. 개시자는 다음 텍스트 요청에 대한 응답에서 대상 전송 태그를 복사함으로써 대상에게 특정 개시자 작업 태그에 대한 작업을 계속하도록 지시합니다. F 비트가 1로 설정된 경우 개시자는 텍스트 응답의 대상 전송 태그를 무시해야 합니다.\(MUST, MUST\)

이 메커니즘을 사용하면 개시자와 대상이 일련의 텍스트 명령/텍스트 응답 교환을 통해 대량의 텍스트 데이터를 전송하거나 확장된 협상 시퀀스를 수행할 수 있습니다.

대상 전송 태그가 0xffffffff가 아닌 경우 대상은 텍스트 응답으로 LUN 필드를 전송해야 합니다.\(MUST\)

교환이 개시자에 의해 오랫동안 지연되거나 자원이 부족한 경우 대상은 내부 협상 상태를 재설정할 수 있습니다.\(MAY\)

긴 텍스트 응답은 다음 예와 같이 처리됩니다.

```text
      I->T Text SendTargets=All (F = 1, TTT = 0xffffffff)

      T->I Text <part 1> (F = 0, TTT = 0x12345678)

      I->T Text <empty> (F = 1, TTT = 0x12345678)

      T->I Text <part 2> (F = 0, TTT = 0x12345678)

      I->T Text <empty> (F = 1, TTT = 0x12345678)

      ...

      T->I Text <part n> (F = 1, TTT = 0xffffffff)
```

---
#### **11.10.5.  Text**

텍스트 요청의 데이터 길이는 iSCSI 대상 MaxRecvDataSegmentLength\(연결 및 방향별로 협상되는 매개변수\)를 초과해서는 안 됩니다. 텍스트 형식은 섹션 6.2에 지정되어 있습니다.\(MUST NOT\)

섹션 12와 13에는 몇 가지 기본 텍스트 키=값 쌍이 나열되어 있으며, 그 중 일부는 로그인 요청/응답에 사용할 수 있고 일부는 텍스트 요청/응답에 사용할 수 있습니다.

키=값 쌍은 텍스트 요청 또는 텍스트 응답 경계에 걸쳐 있을 수 있습니다. 키=값 쌍은 하나의 PDU에서 시작하여 다음 PDU에서 계속될 수 있습니다. 즉, PDU의 끝이 반드시 키=값 쌍의 끝을 알리는 것은 아닙니다.

대상은 개시자에게 응답을 다시 보내 응답합니다. 응답 텍스트 형식은 요청 텍스트 형식과 유사합니다. 텍스트 응답은 이전 텍스트 요청에 표시된 키=값 쌍을 참조할 수 있으며, 요청의 텍스트는 이전 응답을 참조할 수 있습니다.\(MAY\)

섹션 6.2에서는 텍스트 요청 및 응답에 대한 규칙을 자세히 설명합니다.

텍스트 작업은 일반적으로 매개 변수 설정/협상을 위한 것이지만 일부 오래 지속되는 작업을 수행하는 데에도 사용할 수 있습니다.

시간이 오래 걸리는 텍스트 작업은 자체 텍스트 요청에 배치해야 합니다.

---
### **11.11.  Text Response**

텍스트 응답 PDU에는 개시자의 텍스트 요청에 대한 대상의 응답이 포함되어 있습니다. 텍스트 필드의 형식은 텍스트 요청의 형식과 일치합니다.

```text
   Byte/     0       |       1       |       2       |       3       |
      /              |               |               |               |
     |0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|
     +---------------+---------------+---------------+---------------+
    0|.|.| 0x24      |F|C| Reserved                                  |
     +---------------+---------------+---------------+---------------+
    4|TotalAHSLength | DataSegmentLength                             |
     +---------------+---------------+---------------+---------------+
    8| LUN or Reserved                                               |
     +                                                               +
   12|                                                               |
     +---------------+---------------+---------------+---------------+
   16| Initiator Task Tag                                            |
     +---------------+---------------+---------------+---------------+
   20| Target Transfer Tag or 0xffffffff                             |
     +---------------+---------------+---------------+---------------+
   24| StatSN                                                        |
     +---------------+---------------+---------------+---------------+
   28| ExpCmdSN                                                      |
     +---------------+---------------+---------------+---------------+
   32| MaxCmdSN                                                      |
     +---------------+---------------+---------------+---------------+
   36/ Reserved                                                      /
    +/                                                               /
     +---------------+---------------+---------------+---------------+
   48| Header-Digest (optional)                                      |
     +---------------+---------------+---------------+---------------+
     / DataSegment (Text)                                            /
    +/                                                               /
     +---------------+---------------+---------------+---------------+
     | Data-Digest (optional)                                        |
     +---------------+---------------+---------------+---------------+
```

---
#### **11.11.1.  F (Final) Bit**

1로 설정되면 최종 비트가 1로 설정된 텍스트 요청에 대한 응답으로 F 비트는 대상이 전체 작업을 완료했음을 나타냅니다. 그렇지 않고 최종 비트가 1로 설정된 텍스트 요청에 대한 응답으로 0으로 설정되면 대상에 더 많은 작업이 있음을 나타냅니다.

\(후속 문자 요청을 초대합니다\). F 비트가 0으로 설정된 텍스트 요청에 대한 응답으로 F 비트가 1로 설정된 텍스트 응답은 프로토콜 오류입니다.

F 비트가 1로 설정된 텍스트 응답에는 개시자의 추가 응답이 필요할 수 있는 키=값 쌍이 포함되어서는 안 됩니다.\(MUST NOT\)

F 비트가 1로 설정된 텍스트 응답에는 예약된 값 0xffffffff로 설정된 대상 전송 태그 필드가 있어야 합니다.\(MUST\)

F 비트가 0으로 설정된 텍스트 응답에는 예약된 값 0xffffffff 이외의 값으로 설정된 대상 전송 태그 필드가 있어야 합니다.\(MUST\)

---
#### **11.11.2.  C (Continue) Bit**

1로 설정되면 이 비트는 이 텍스트 응답의 텍스트\(키=값 쌍 집합\)가 완전하지 않음을 나타냅니다\(이는 후속 텍스트 응답에서 계속됩니다\). 그렇지 않으면 이 텍스트 응답이 키=값 쌍 세트를 종료함을 나타냅니다. C 비트가 1로 설정된 텍스트 응답은 F 비트를 0으로 설정해야 합니다.\(MUST\)

---
#### **11.11.3.  Initiator Task Tag**

개시자 작업 태그는 초기 텍스트 요청에 사용된 태그와 일치합니다.

---
#### **11.11.4.  Target Transfer Tag**

대상이 수행할 작업이 더 많고\(예: 단일 텍스트 응답의 나머지 텍스트 데이터를 모두 전송할 수 없거나 협상을 계속해야 함\) 진행하기에 충분한 리소스가 있는 경우 대상 전송 태그를 다음 값이 아닌 다른 값으로 설정해야 합니다. 예약된 값 0xffffffff. 그렇지 않으면 대상 전송 태그를 0xffffffff로 설정해야 합니다.\(MUST, MUST\)

대상 전송 태그가 0xffffffff가 아닌 경우 LUN 필드가 중요할 수 있습니다.

개시자는 나머지 데이터를 원한다는 것을 나타내기 위해 다음 요청에서 대상 전송 태그와 LUN을 복사해야 합니다.\(MUST\)

대상이 예약된 값 0xffffffff로 설정된 대상 전송 태그가 있는 텍스트 요청을 수신하면 지정된 개시자 작업 태그와 연결된 내부 정보\(상태 재설정\)를 재설정합니다\(협상을 다시 시작합니다\).

대상이 단일 텍스트 응답으로 작업을 완료할 수 없고 계속할 리소스가 충분하지 않은 경우 적절한 거부 코드를 사용하여 텍스트 요청을 거부합니다.

개시자가 한동안 교환을 계속하지 못하는 경우 대상은 대상 전송 태그를 통해 표현된 대로 개시자 작업 태그와 연관된 내부 상태\(현재 협상 상태\)를 재설정할 수 있습니다. 대상은 "오래된" 값으로 설정된 대상 전송 태그를 사용하여 후속 텍스트 요청을 거부할 수 있습니다.

---
#### **11.11.5.  StatSN**

대상 StatSN 변수는 전송된 각 텍스트 응답에 의해 향상됩니다.

---
#### **11.11.6.  Text Response Data**

텍스트 응답의 데이터 길이는 iSCSI 개시자 MaxRecvDataSegmentLength\(연결 및 방향별로 협상되는 매개변수\)를 초과해서는 안 됩니다.\(MUST NOT\)

텍스트 응답 데이터의 텍스트는 텍스트 요청 데이터의 텍스트와 동일한 규칙에 의해 관리됩니다\(섹션 11.11.2 참조\).

개시자는 요청 당사자이고 요청-응답 시작 및 종료를 제어하지만 대상은 개시자에 대한 응답뿐만 아니라 시퀀스의 일부로 자체 키=값 쌍을 제공할 수 있습니다.

---
### **11.12.  Login Request**

개시자와 대상 사이에 TCP 연결을 설정한 후 개시자는 대상의 리소스에 대한 추가 액세스 권한을 얻기 위해 로그인 단계를 시작해야 합니다.\(MUST\)

로그인 단계\(섹션 6.3 참조\)는 동일한 개시자 작업 태그를 전달하는 일련의 로그인 요청 및 로그인 응답으로 구성됩니다.

로그인 요청은 항상 즉시 요청으로 간주됩니다.

```text
   Byte/     0       |       1       |       2       |       3       |
      /              |               |               |               |
     |0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|
     +---------------+---------------+---------------+---------------+
    0|.|1| 0x03      |T|C|.|.|CSG|NSG| Version-max   | Version-min   |
     +---------------+---------------+---------------+---------------+
    4|TotalAHSLength | DataSegmentLength                             |
     +---------------+---------------+---------------+---------------+
    8| ISID                                                          |
     +                               +---------------+---------------+
   12|                               | TSIH                          |
     +---------------+---------------+---------------+---------------+
   16| Initiator Task Tag                                            |
     +---------------+---------------+---------------+---------------+
   20| CID                           | Reserved                      |
     +---------------+---------------+---------------+---------------+
   24| CmdSN                                                         |
     +---------------+---------------+---------------+---------------+
   28| ExpStatSN or Reserved                                         |
     +---------------+---------------+---------------+---------------+
   32| Reserved                                                      |
     +---------------+---------------+---------------+---------------+
   36| Reserved                                                      |
     +---------------+---------------+---------------+---------------+
   40/ Reserved                                                      /
    +/                                                               /
     +---------------+---------------+---------------+---------------+
   48/ DataSegment - Login Parameters in Text Request Format         /
    +/                                                               /
     +---------------+---------------+---------------+---------------+
```

---
#### **11.12.1.  T (Transit) Bit**

1로 설정된 경우 이 비트는 개시자가 다음 단계로 전환할 준비가 되었음을 나타냅니다.

T 비트가 1로 설정되고 NSG가 FullFeaturePhase로 설정된 경우 이는 개시자가 로그인 최종 응답에 대한 준비가 되었음을 나타냅니다\(섹션 6.3 참조\).

---
#### **11.12.2.  C (Continue) Bit**

1로 설정되면 이 비트는 이 로그인 요청의 텍스트\(키=값 쌍 세트\)가 완전하지 않음을 나타냅니다\(이후 로그인 요청에서 계속됨\). 그렇지 않으면 이 로그인 요청이 일련의 키=값 쌍을 종료함을 나타냅니다. C 비트가 1로 설정된 로그인 요청은 T 비트를 0으로 설정해야 합니다.\(MUST\)

---
#### **11.12.3.  CSG and NSG**

현재 단계\(CSG\) 및 다음 단계\(NSG\) 필드를 통해 로그인 협상 요청 및 응답은 세션의 특정 단계\(SecurityNegotiation, LoginOperationalNegotiation, FullFeaturePhase\)와 연결되며 원하는 다음 단계를 나타낼 수 있습니다. 이동합니다\(섹션 6.3 참조\). 다음 단계 값은 T 비트가 1일 때만 유효합니다. 그렇지 않으면 예약되어 있습니다.

스테이지 코드는 다음과 같습니다.

```text
      0 - SecurityNegotiation

      1 - LoginOperationalNegotiation

      3 - FullFeaturePhase
```

다른 모든 코드는 예약되어 있습니다.

---
#### **11.12.4.  Version**

이 문서의 버전 번호는 0x00입니다. 따라서 Version-min과 Version-max는 모두 0x00으로 설정되어야 합니다.\(MUST\)

---
##### **11.12.4.1.  Version-max**

Version-max는 지원되는 최대 버전 번호를 나타냅니다.

로그인 단계 내의 모든 로그인 요청은 동일한 최대 버전을 전달해야 합니다.\(MUST\)

대상은 첫 번째 로그인 요청에 제공된 값을 사용해야 합니다.\(MUST\)

---
##### **11.12.4.2.  Version-min**

로그인 단계 내의 모든 로그인 요청은 동일한 최소 버전을 전달해야 합니다. 대상은 첫 번째 로그인 요청에 제공된 값을 사용해야 합니다.\(MUST, MUST\)

---
#### **11.12.5.  ISID**

이는 세션 식별자의 개시자 정의 구성 요소이며 다음과 같이 구성됩니다\(자세한 내용은 섹션 10.1.1 참조\).

```text
   Byte/     0       |       1       |       2       |       3       |
      /              |               |               |               |
     |0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|
     +---------------+---------------+---------------+---------------+
    8| T |     A     |              B                |      C        |
     +---------------+---------------+---------------+---------------+
   12|               D               |
     +---------------+---------------+
```

T 필드는 아래와 같이 A, B, C, D의 형식과 사용법을 식별합니다.

```text
      T

      00b    OUI-Format

             A and B: 22-bit OUI

             (the I/G and U/L bits are omitted)

             C and D: 24-bit Qualifier

      01b    EN: Format (IANA Enterprise Number)

             A: Reserved

             B and C: EN (IANA Enterprise Number)

             D: Qualifier

      10b    "Random"

             A: Reserved

             B and C: Random

             D: Qualifier

      11b    A, B, C, and D: Reserved
```

T 필드 값 00b 및 01b의 경우 A와 B\(00b의 경우\) 또는 B와 C\(01b의 경우\)의 조합은 해당 구성 요소\(소프트웨어 또는 하드웨어\)가 이 ISID를 생성하는 공급업체 또는 조직을 식별합니다. 공급업체 또는

하나 이상의 OUI 또는 하나 이상의 기업 번호가 있는 조직은 이러한 번호 중 최소한 하나를 사용해야 하며 구성 요소가 ISID를 생성할 때 T 필드에 대한 적절한 값을 선택해야 합니다. OUI 또는 EN은 해당 필드에 네트워크 바이트 순서\(바이트 빅엔디안\)로 설정되어야 합니다.\(MUST, MUST\)

T 필드가 10b인 경우 B와 C는 네트워크 바이트 순서\(바이트 빅엔디안\)에 따라 임의의 24비트 부호 없는 정수 값으로 설정됩니다. 이것이 "보수적 재사용" 원칙에 어떤 영향을 미치는지는 \[RFC3721\]을 참조하세요.

한정자 필드는 선택한 네임스페이스 내의 ISID에 대해 가능한 값 범위를 제공하는 16비트 또는 24비트 부호 없는 정수 값입니다. iSCSI 프로토콜에 지정된 제약 조건 내에서 어떤 값으로든 설정할 수 있습니다\(섹션 4.4.3 및 10.1.1 참조\).

T 필드 값 11b는 예약되어 있습니다.

ISID가 공급업체가 미리 설정된 기본값으로 하드웨어 어댑터나 인터페이스에 할당한 것에서 파생된 경우 ISID가 설치된 시스템에서 원하는 SCSI 포트 동작에 따라 할당된 값으로 구성 가능해야 합니다\(섹션 10.1 참조\). .1 및 10.1.2\). 결과 ISID는 전원 주기, 재부팅, 카드 교체 등 후에도 지속되어야 합니다.\(MUST, MUST\)

---
#### **11.12.6.  TSIH**

TSIH는 첫 번째 로그인 요청에서 설정되어야 합니다. 예약된 값 0은 새 세션의 첫 번째 연결에서 사용해야 합니다. 그렇지 않으면 이 세션에 대한 첫 번째 연결의 성공적인 로그인이 끝날 때 대상이 보낸 TSIH를 사용해야 합니다. TSIH는 이 새로운 연결에 대해 연결된 기존 세션을 대상에 식별합니다.\(MUST, MUST\)

로그인 단계 내의 모든 로그인 요청은 동일한 TSIH를 전달해야 합니다.\(MUST\)

대상은 첫 번째 로그인 요청에 제공된 값을 확인하고 섹션 6.3.1에 지정된 대로 작동해야 합니다.\(MUST\)

---
#### **11.12.7.  Connection ID (CID)**

CID는 세션 내에서 이 연결에 대한 고유 ID를 제공합니다.

로그인 단계 내의 모든 로그인 요청은 동일한 CID를 전달해야 합니다.\(MUST\)

대상은 첫 번째 로그인 요청에 제공된 값을 사용해야 합니다.\(MUST\)

0이 아닌 TSIH 및 기존 연결의 CID와 동일한 로그인 요청은 로그인이 뒤따르는 연결의 로그아웃을 의미합니다\(섹션 6.3.4 참조\). 암시적 로그아웃 요청에 대한 자세한 내용은 섹션 11.14를 참조하세요.

---
#### **11.12.8.  CmdSN**

CmdSN은 세션의 초기 명령 시퀀스 번호\(세션의 첫 번째 로그인 요청의 경우 - "선행" 로그인\)이거나 로그인이 기존 세션의 새 연결에 대한 것인 경우 명령 스트림의 명령 시퀀스 번호입니다. .

```text
   Examples:
```

- 선행 연결에 대한 로그인: 선행 로그인이 CmdSN 123을 전달하는 경우 동일한 로그인 단계의 다른 모든 로그인 요청은 CmdSN 123을 전달하고 전체 기능 단계의 첫 번째 비즉시 명령도 CmdSN 123을 전달합니다.

- 선행 연결 이외의 로그인: 연결에서 첫 번째 로그인이 실행될 때 현재 CmdSN이 500이면 해당 PDU는 CmdSN=500을 전달합니다. 동일한 세션의 다른 연결에서 발행된 즉각적이지 않은 요청이 CmdSN을 향상시키는 경우 이 로그인 단계를 완료하는 데 필요한 후속 로그인 요청은 500보다 높은 CmdSN을 전달할 수 있습니다.

로그인 요청이 선행 로그인 요청인 경우 대상은 CmdSN에 제시된 값을 ExpCmdSN의 대상 값으로 사용해야 합니다.\(MUST\)

---
#### **11.12.9.  ExpStatSN**

연결의 첫 번째 로그인 요청의 경우 이는 이전 연결의 ExpStatSN이며 이 필드는 로그인 요청이 연결을 다시 시작하는 경우에만 유효합니다\(섹션 6.3.4 참조\).

후속 로그인 요청의 경우 증가하는 StatSN 값으로 로그인 응답을 확인하는 데 사용됩니다.

---
#### **11.12.10.  Login Parameters**

개시자는 보안 교환을 위해 대상의 리소스와 초기 텍스트 매개변수를 사용할 수 있는지 여부를 대상이 결정할 수 있도록 몇 가지 기본 매개변수를 제공해야 합니다.\(MUST\)

텍스트 요청에 대해 섹션 11.10.5에 지정된 모든 규칙은 로그인 요청에도 적용됩니다. 키와 해당 설명은 섹션 12\(보안 협상 키\) 및 섹션 13\(작동 키\)에 나열되어 있습니다.

매개변수 협상 키\). X 확장 형식을 제외하고 섹션 13에 나열된 모든 키는 iSCSI 초기자 및 대상에서 지원되어야 합니다. 섹션 12에 나열된 키는 참조하는 기능이 반드시 구현되어야 하는 경우에만 지원되어야 합니다.\(MUST\)

---
### **11.13.  Login Response**

로그인 응답은 로그인 단계의 진행 및/또는 종료를 나타냅니다.

```text
   Byte/     0       |       1       |       2       |       3       |
      /              |               |               |               |
     |0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|
     +---------------+---------------+---------------+---------------+
    0|.|.| 0x23      |T|C|.|.|CSG|NSG| Version-max   |Version-active |
     +---------------+---------------+---------------+---------------+
    4|TotalAHSLength | DataSegmentLength                             |
     +---------------+---------------+---------------+---------------+
    8| ISID                                                          |
     +                               +---------------+---------------+
   12|                               | TSIH                          |
     +---------------+---------------+---------------+---------------+
   16| Initiator Task Tag                                            |
     +---------------+---------------+---------------+---------------+
   20| Reserved                                                      |
     +---------------+---------------+---------------+---------------+
   24| StatSN                                                        |
     +---------------+---------------+---------------+---------------+
   28| ExpCmdSN                                                      |
     +---------------+---------------+---------------+---------------+
   32| MaxCmdSN                                                      |
     +---------------+---------------+---------------+---------------+
   36| Status-Class  | Status-Detail | Reserved                      |
     +---------------+---------------+---------------+---------------+
   40/ Reserved                                                      /
    +/                                                               /
     +---------------+---------------+---------------+---------------+
   48/ DataSegment - Login Parameters in Text Request Format         /
    +/                                                               /
     +---------------+---------------+---------------+---------------+
```

---
#### **11.13.1.  Version-max**

이는 대상에서 지원하는 가장 높은 버전 번호입니다.

로그인 단계 내의 모든 로그인 응답은 동일한 Version-max를 전달해야 합니다.\(MUST\)

개시자는 첫 번째 로그인 요청에 대한 응답으로 제시된 값을 사용해야 합니다.\(MUST\)

---
#### **11.13.2.  Version-active**

버전 활성은 대상과 개시자가 지원하는 가장 높은 버전을 나타냅니다. 대상이 개시자가 지정한 범위 내의 버전을 지원하지 않는 경우 대상은 로그인을 거부하며 이 필드는 대상이 지원하는 가장 낮은 버전을 나타냅니다.

로그인 단계 내의 모든 로그인 응답은 동일한 활성 버전을 전달해야 합니다.\(MUST\)

개시자는 첫 번째 로그인 요청에 대한 응답으로 제시된 값을 사용해야 합니다.\(MUST\)

---
#### **11.13.3.  TSIH**

TSIH는 대상에 할당된 세션 식별 핸들입니다. 예약된 값 0을 제외하고는 내부 형식과 내용이 이 프로토콜에 의해 정의되지 않습니다. 새 세션의 로그인 최종 응답을 제외하고 이 필드는 로그인 요청에서 개시자가 제공한 TSIH로 설정되어야 합니다. 새 세션의 경우 대상은 0이 아닌 TSIH를 생성해야 하며 이를 로그인 최종 응답에서만 반환해야 합니다\(섹션 6.3 참조\).\(MUST\)

---
#### **11.13.4.  StatSN**

첫 번째 로그인 응답\(첫 번째 로그인 요청에 대한 응답\)의 경우 연결의 시작 상태 시퀀스 번호입니다. 동일한 로그인 단계에서 다음 로그인 응답을 포함하여 모든 종류의 다음 응답은 이 숫자 + 1을 전달합니다. 이 필드는 Status-Class가 0인 경우에만 유효합니다.

---
#### **11.13.5.  Status-Class and Status-Detail**

로그인 응답으로 반환된 상태는 로그인 단계의 실행 상태를 나타냅니다. 상태에는 다음이 포함됩니다.

```text
      Status-Class

      Status-Detail
```

Status-Class 0은 성공을 나타냅니다.

0이 아닌 상태 클래스는 예외를 나타냅니다. 이 경우, Status-Detail을 볼 필요 없이 예외를 처리할 때 간단한 개시자가 사용하기에 Status-Class이면 충분합니다.

Status-Detail을 사용하면 보다 정교한 개시자와 더 나은 로깅 정보를 위해 보다 세부적인 예외 처리가 가능합니다.

상태 클래스는 다음과 같습니다:

0 성공 - iSCSI 대상이 성공적으로 완료되었음을 나타냅니다.

- 요청을 받고, 이해하고, 수락했습니다. 번호 매기기 필드\(StatSN, ExpCmdSN, MaxCmdSN\)는 StatusClass가 0인 경우에만 유효합니다.

- 1 리디렉션 - 개시자가 요청을 완료하기 위해 추가 조치를 취해야 함을 나타냅니다. 이는 일반적으로 대상이 다른 주소로 이동하기 때문입니다. 모든 리디렉션 Status-Class 응답은 대상의 새 주소를 나타내는 "TargetAddress" 유형의 하나 이상의 텍스트 키 매개변수를 반환해야 합니다. 보안 협상이 필요한 경우 보안 협상을 완료하기 전이나 완료한 후에 대상에서 리디렉션 응답을 발행할 수 있습니다. 보안 협상이 필요한 경우 대상이 보안 협상을 완료하지 않고도 개시자가 리디렉션을 수락해야 하며, 보안 협상이 필요한 경우 보안 협상이 완료된 후 개시자가 리디렉션을 수락해야 합니다.\(MUST, MAY, MUST\)

- 2 개시자 오류\(형식 오류 아님\) - 개시자가 오류를 일으켰을 가능성이 가장 높음을 나타냅니다. 이는 개시자가 권한을 갖고 있지 않은 리소스에 대한 요청 때문일 수 있습니다. 요청을 다시 시도하면 안 됩니다.\(MAY\)

- 3 대상 오류 - 대상이 개시자의 로그인 요청에서 오류를 발견하지 못했지만 현재 요청을 이행할 수 없음을 나타냅니다. 개시자는 나중에 동일한 로그인 요청을 다시 시도할 수 있습니다.

아래 표는 현재 할당된 상태 코드를 모두 보여줍니다. 코드는 16진수입니다. 첫 번째 바이트는 상태 클래스이고 두 번째 바이트는 상태 세부 정보입니다.

```text
     -----------------------------------------------------------------
     Status        | Code | Description
                   |(hex) |
     -----------------------------------------------------------------
     Success       | 0000 | Login is proceeding OK (*1).
     -----------------------------------------------------------------
     Target moved  | 0101 | The requested iSCSI Target Name (ITN)
     temporarily   |      | has temporarily moved
                   |      | to the address provided.
     -----------------------------------------------------------------
     Target moved  | 0102 | The requested ITN has permanently moved
     permanently   |      | to the address provided.
     -----------------------------------------------------------------
     Initiator     | 0200 | Miscellaneous iSCSI initiator
     error         |      | errors.
     -----------------------------------------------------------------
     Authentication| 0201 | The initiator could not be
     failure       |      | successfully authenticated or target
                   |      | authentication is not supported.
     -----------------------------------------------------------------
     Authorization | 0202 | The initiator is not allowed access
     failure       |      | to the given target.
     -----------------------------------------------------------------
     Not found     | 0203 | The requested ITN does not
                   |      | exist at this address.
     -----------------------------------------------------------------
     Target removed| 0204 | The requested ITN has been removed, and
                   |      | no forwarding address is provided.
     -----------------------------------------------------------------
     Unsupported   | 0205 | The requested iSCSI version range is
     version       |      | not supported by the target.
     -----------------------------------------------------------------
     Too many      | 0206 | Too many connections on this SSID.
     connections   |      |
     -----------------------------------------------------------------
     Missing       | 0207 | Missing parameters (e.g., iSCSI
     parameter     |      | Initiator Name and/or Target Name).
     -----------------------------------------------------------------
     Can't include | 0208 | Target does not support session
     in session    |      | spanning to this connection (address).
     -----------------------------------------------------------------
     Session type  | 0209 | Target does not support this type of
     not supported |      | session or not from this initiator.
     -----------------------------------------------------------------

     Session does  | 020a | Attempt to add a connection
     not exist     |      | to a non-existent session.
     -----------------------------------------------------------------
     Invalid during| 020b | Invalid request type during login.
     login         |      |
     -----------------------------------------------------------------
     Target error  | 0300 | Target hardware or software error.
     -----------------------------------------------------------------
     Service       | 0301 | The iSCSI service or target is not
     unavailable   |      | currently operational.
     -----------------------------------------------------------------
     Out of        | 0302 | The target has insufficient session,
     resources     |      | connection, or other resources.
     -----------------------------------------------------------------
```

\(\*1\) 요청과 일치하는 응답 모두에서 응답 T 비트가 1로 설정되고, 요청과 일치하는 응답 모두에서 NSG가 FullFeaturePhase로 설정된 경우 로그인 단계가 완료되고 Initiator는 다음 단계로 진행할 수 있습니다. SCSI 명령을 실행합니다.

Status-Class가 0이 아닌 경우 개시자와 대상은 TCP 연결을 닫아야 합니다.\(MUST\)

대상이 두 가지 이상의 이유로 로그인 요청을 거부하려는 경우 거부에 대한 주요 이유를 반환해야 합니다.

---
#### **11.13.6.  T (Transit) Bit**

T 비트는 스테이지 종료를 나타내는 표시로 1로 설정됩니다. T 비트가 1로 설정되고 NSG가 FullFeaturePhase로 설정된 경우 이는 로그인 최종 응답이기도 합니다\(섹션 6.3 참조\). T 비트가 0이면 "부분" 응답을 나타내며 "더 많은 협상이 필요함"을 의미합니다.

T 비트가 1로 설정된 로그인 응답에는 동일한 단계 내 개시자의 추가 응답이 필요할 수 있는 키=값 쌍이 포함되어서는 안 됩니다.\(MUST NOT\)

Status-Class가 0인 경우 요청의 T 비트가 0으로 설정된 경우 T 비트는 1로 설정되어서는 안 됩니다.\(MUST NOT\)

---
#### **11.13.7.  C (Continue) Bit**

1로 설정되면 이 비트는 이 로그인 응답의 텍스트\(키=값 쌍 세트\)가 완전하지 않음을 나타냅니다\(이후 로그인 응답에서 계속됨\). 그렇지 않으면 이 로그인 응답이 일련의 키=값 쌍을 종료함을 나타냅니다. C 비트가 1로 설정된 로그인 응답은 T 비트를 0으로 설정해야 합니다.\(MUST\)

---
#### **11.13.8.  Login Parameters**

대상은 초기자가 올바른 포트에 연결되어 있는지 확인할 수 있도록 몇 가지 기본 매개변수와 보안 교환을 위한 초기 텍스트 매개변수를 제공해야 합니다.\(MUST\)

텍스트 응답에 대해 섹션 11.11.6에 지정된 모든 규칙은 로그인 응답에도 적용됩니다. 키와 해당 설명은 섹션 12\(보안 협상 키\) 및 섹션 13\(작동 매개변수 협상 키\)에 나열되어 있습니다. X 확장 형식을 제외하고 섹션 13에 나열된 모든 키는 iSCSI 초기자 및 대상에서 지원되어야 합니다. 섹션 12에 나열된 키는 참조하는 기능이 반드시 구현되어야 하는 경우에만 지원되어야 합니다.\(MUST\)

---
### **11.14.  Logout Request**

로그아웃 요청은 연결 종료를 제어하는 ​​데 사용됩니다.

개시자는 로그아웃 요청을 사용하여 세션에서 연결을 제거하거나 전체 세션을 닫을 수 있습니다.\(MAY\)

로그아웃 요청 PDU를 보낸 후 개시자는 연결 종료 시 새로운 iSCSI 요청을 보내서는 안 됩니다. 로그아웃 요청이 세션을 닫도록 의도된 경우 세션에 참여하는 어떤 연결에서도 새 iSCSI 요청을 보내서는 안 됩니다.\(MUST NOT, MUST NOT\)

"연결 닫기" 또는 "세션 닫기"라는 이유 코드가 포함된 로그아웃 요청을 수신하면 대상은 ExpCmdSN을 통해 승인되었는지 여부에 관계없이 해당 연결이나 세션에서 보류 중인 모든 명령을 각각 종료해야 합니다.\(MUST\)

"복구를 위해 연결 제거"라는 이유 코드가 포함된 로그아웃 요청을 수신하면 대상은 지정된 연결에서 발행된 ExpCmdSN을 통해 아직 확인되지 않은 모든 요청을 삭제하고 보류 중인 명령을 대신하여 모든 데이터/상태/R2T 전송을 일시 중단해야 합니다. 지정된 연결에서.\(MUST\)

그런 다음 대상은 로그아웃 응답을 발행하고 TCP 연결을 절반 닫습니다\(FIN 전송\). 로그아웃 응답을 수신하고 FIN 수신을 시도한 후\(여전히 가능한 경우\) 개시자는 로그아웃 연결을 완전히 닫아야 합니다. 종료된 명령의 경우 추가 응답이 예상되지 않습니다.\(MUST\)

CID에 대한 TCP 연결이 이미 종료된 경우 다른 전송 연결에서 CID에 대한 로그아웃이 수행될 수 있습니다. 이러한 경우 로그아웃에는 CID에 대한 iSCSI 연결의 논리적 "닫기"만 암시됩니다.

종료되지 않았거나 완료되지 않았으며\(상태 포함\) 연결이 완전히 닫혔을 때 승인된 모든 명령은 대상이 연결 복구를 지원하는 경우 새 연결에 다시 할당될 수 있습니다.

개시자가 실패한 연결에 대한 복구를 시작하려는 경우 로그아웃 요청을 사용하여 실패한 연결의 대상 끝을 "정리"하고 복구를 시작하도록 활성화하거나 0이 아닌 TSIH 및 동일한 로그인 요청을 사용해야 합니다. 동일한 효과를 위해 새 연결의 CID입니다. 단일 연결이 있는 세션에서는 연결을 닫은 다음 새 연결을 다시 열 수 있습니다. 복구를 위해 연결 복원 로그인을 사용할 수 있습니다\(섹션 6.3.4 참조\).\(MUST\)

이유 코드가 "연결 닫기" 또는 "복구를 위해 연결 제거"인 로그아웃 요청이 성공적으로 완료되면 대상에서는 로그아웃 중인 연결에서 수신된 승인되지 않은 명령이 삭제됩니다. 이는 로그아웃 중인 연결에 도착했지만 CmdSN이 더 작은 하나 이상의 명령이 iSCSI에서 수신되지 않았기 때문에 SCSI에 전달되지 않은 명령입니다. 섹션 4.2.2.1을 참조하십시오. 세션도 닫히지 않는 한, 명령 시퀀스 번호에 나타나는 구멍은 적절한 복구\(섹션 7 참조\)를 통해 처리되어야 합니다.

이 섹션의 전체 로그아웃 논의는 연결 복원 또는 세션 복원을 통해 실현된 암시적 로그아웃에도 적용 가능합니다. 로그인 요청이 암시적 로그아웃을 수행하는 경우 암시적 로그아웃은 아래에 지정된 이유 코드가 있는 것처럼 수행됩니다.

```text
     Reason Code     Type of Implicit Logout
     -------------------------------------------------------------

          0          session reinstatement

          1          connection reinstatement when the operational
                     ErrorRecoveryLevel < 2

          2          connection reinstatement when the operational
                     ErrorRecoveryLevel = 2

   Byte/     0       |       1       |       2       |       3       |
      /              |               |               |               |
     |0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|
     +---------------+---------------+---------------+---------------+
    0|.|I| 0x06      |1| Reason Code | Reserved                      |
     +---------------+---------------+---------------+---------------+
    4|TotalAHSLength | DataSegmentLength                             |
     +---------------------------------------------------------------+
    8/ Reserved                                                      /
    +/                                                               /
     +---------------+---------------+---------------+---------------+
   16| Initiator Task Tag                                            |
     +---------------+---------------+---------------+---------------+
   20| CID or Reserved               | Reserved                      |
     +---------------+---------------+---------------+---------------+
   24| CmdSN                                                         |
     +---------------+---------------+---------------+---------------+
   28| ExpStatSN                                                     |
     +---------------+---------------+---------------+---------------+
   32/ Reserved                                                      /
    +/                                                               /
     +---------------+---------------+---------------+---------------+
   48| Header-Digest (optional)                                      |
     +---------------+---------------+---------------+---------------+
```

---
#### **11.14.1.  Reason Code**

이유 코드 필드는 다음과 같이 로그아웃 이유를 나타냅니다.

0 - 세션을 닫습니다. 와 관련된 모든 명령

- 세션\(있는 경우\)이 종료됩니다.

- 1 - 연결을 닫습니다. 연결과 관련된 모든 명령\(있는 경우\)이 종료됩니다.

- 2 - 복구를 위해 연결을 제거합니다. 연결이 닫히고, 연결과 관련된 모든 명령이 있는 경우 새로운 충성을 준비해야 합니다.

다른 모든 값은 예약되어 있습니다.

---
#### **11.14.2.  TotalAHSLength and DataSegmentLength**

이 PDU의 경우 TotalAHSLength 및 DataSegmentLength는 0이어야 합니다.\(MUST\)

---
#### **11.14.3.  CID**

닫힐 연결의 연결 ID입니다\(TCP 스트림 닫기 포함\). 이 필드는 이유 코드가 "세션 종료"가 아닌 경우에만 유효합니다.

---
#### **11.14.4.  ExpStatSN**

닫힐 연결의 마지막 ExpStatSN 값입니다.

---
#### **11.14.5.  Implicit Termination of Tasks**

다음과 같은 경우 대상은 iSCSI 프로토콜로 인해 활성 작업을 암시적으로 종료합니다.

- a\) "연결 종료"라는 이유 코드와 함께 연결이 암시적 또는 명시적으로 로그아웃되고 해당 연결과 관련된 활성 작업이 있는 경우.

- b\) 연결이 실패하고 결국 연결 상태가 시간 초과되고\(섹션 8.2.2의 상태 전환 M1\) 해당 연결에 해당하는 활성 작업이 있는 경우.

- c\) 성공적인 복구 로그아웃이 해당 연결과 관련된 활성 작업이 있는 동안 수행되고 해당 작업은 결국 충성 재할당 없이 Time2Wait 및 Time2Retain 기간 후에 시간 초과됩니다.

- d\) "세션 종료"라는 이유 코드와 함께 연결이 암시적 또는 명시적으로 로그아웃되고 해당 세션에 활성 작업이 있는 경우.

위의 경우에 종료된 작업이 SCSI 작업인 경우에는 CHECK CONDITION 상태와 마찬가지로 내부적으로 종료되어야 합니다. 이 상태는 내부 SCSI 상태 및 주문과 관련된 SCSI 부작용을 적절하게 처리하는 데에만 의미가 있습니다. 왜냐하면 이 상태는 개시자에게 종료 상태로 다시 전달되지 않기 때문입니다. 그러나 SCSI 표준에 정의된 SCSI 컨텍스트\(예: 대기열에 있는 명령 및 ACA, a\), b\)의 경우 I\_T 넥서스의 다음 명령에 대한 UA에 따라 SCSI 수준에서 추가 작업을 수행해야 할 수도 있습니다. c\) 위\). 작업이 종료된 후 대상은 CHECK CONDITION 상태, ASC/ASCQ 값 47h/7Fh\("SOME COMMANDS CLEARED BY ISCSI 프로토콜 이벤트'\) 등; \[SPC3\]을 참조하세요.\(MUST\)

---
### **11.15.  Logout Response**

로그아웃 응답은 연결에 대한 정리 작업이 완료되었는지 여부를 나타내기 위해 대상에서 사용됩니다.

로그아웃 후에는 CID가 참조하는 TCP 연결이 양쪽 끝에서 모두 닫혀야 합니다\(또는 로그아웃 이유가 세션 닫힘인 경우 모든 연결을 닫아야 함\).\(MUST\)

```text
   Byte/     0       |       1       |       2       |       3       |
      /              |               |               |               |
     |0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|
     +---------------+---------------+---------------+---------------+
    0|.|.| 0x26      |1| Reserved    | Response      | Reserved      |
     +---------------+---------------+---------------+---------------+
    4|TotalAHSLength | DataSegmentLength                             |
     +---------------------------------------------------------------+
    8/ Reserved                                                      /
    +/                                                               /
     +---------------+---------------+---------------+---------------+
   16| Initiator Task Tag                                            |
     +---------------+---------------+---------------+---------------+
   20| Reserved                                                      |
     +---------------+---------------+---------------+---------------+
   24| StatSN                                                        |
     +---------------+---------------+---------------+---------------+
   28| ExpCmdSN                                                      |
     +---------------+---------------+---------------+---------------+
   32| MaxCmdSN                                                      |
     +---------------+---------------+---------------+---------------+
   36| Reserved                                                      |
     +---------------------------------------------------------------+
   40| Time2Wait                     | Time2Retain                   |
     +---------------+---------------+---------------+---------------+
   44| Reserved                                                      |
     +---------------+---------------+---------------+---------------+
   48| Header-Digest (optional)                                      |
     +---------------+---------------+---------------+---------------+
```

---
#### **11.15.1.  Response**

응답 필드 설정은 다음과 같습니다.

- 0 - 연결 또는 세션이 성공적으로 닫혔습니다.

```text
      1 - CID not found.
```

- 2 - 연결 복구는 지원되지 않습니다\(예: 로그아웃 이유 코드는 "복구를 위해 연결 제거"였으며 대상은 운영 ErrorRecoveryLevel에 표시된 대로 이를 지원하지 않습니다\).

- 3 - 여러 가지 이유로 정리에 실패했습니다.

---
#### **11.15.2.  TotalAHSLength and DataSegmentLength**

이 PDU의 경우 TotalAHSLength 및 DataSegmentLength는 0이어야 합니다.\(MUST\)

---
#### **11.15.3.  Time2Wait**

로그아웃 응답 코드가 0이고 작동 ErrorRecoveryLevel이 2인 경우 이는 작업 재할당을 시도하기 전에 기다려야 하는 최소 시간\(초\)입니다. 로그아웃 응답 코드가 0이고 작동 ErrorRecoveryLevel이 2 미만인 경우 이 필드는 무시됩니다.

로그아웃 응답 코드가 1인 경우 이 필드는 유효하지 않습니다.

로그아웃 응답 코드가 2 또는 3인 경우 이 필드는 새로운 암시적 또는 명시적 로그아웃을 시도하기 전에 대기할 최소 시간을 지정합니다.

Time2Wait가 0이면 즉시 재할당이나 새로운 로그아웃을 시도할 수 있습니다.

---
#### **11.15.4.  Time2Retain**

로그아웃 응답 코드가 0이고 작동 ErrorRecoveryLevel이 2인 경우 이는 대상이 활성 작업에 대한 충성 재할당을 기다리는 초기 대기\(Time2Wait\) 후의 최대 시간\(초\)입니다. 폐기됩니다. 로그아웃 응답 코드가 0이고 작동 ErrorRecoveryLevel이 2 미만인 경우 이 필드는 무시됩니다.

로그아웃 응답 코드가 1인 경우 이 필드는 유효하지 않습니다.

로그아웃 응답 코드가 2 또는 3인 경우 이 필드는 대상이 새로운 암시적 또는 명시적 로그아웃을 기다리는 초기 대기\(Time2Wait\) 이후의 최대 시간\(초\)을 지정합니다.

세션의 마지막 연결인 경우 Time2Retain 이후 전체 세션 상태가 삭제됩니다.

Time2Retain이 0이면 대상이 작업 상태와 함께 연결\(및 세션\) 상태를 이미 삭제한 것입니다. 이 경우 재할당이나 로그아웃이 필요하지 않습니다.

---
### **11.16.  SNACK Request**

```text
   Byte/     0       |       1       |       2       |       3       |
      /              |               |               |               |
     |0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|
     +---------------+---------------+---------------+---------------+
    0|.|.| 0x10      |1|.|.|.| Type  | Reserved                      |
     +---------------+---------------+---------------+---------------+
    4|TotalAHSLength | DataSegmentLength                             |
     +---------------+---------------+---------------+---------------+
    8| LUN or Reserved                                               |
     +                                                               +
   12|                                                               |
     +---------------+---------------+---------------+---------------+
   16| Initiator Task Tag or 0xffffffff                              |
     +---------------+---------------+---------------+---------------+
   20| Target Transfer Tag or SNACK Tag or 0xffffffff                |
     +---------------+---------------+---------------+---------------+
   24| Reserved                                                      |
     +---------------+---------------+---------------+---------------+
   28| ExpStatSN                                                     |
     +---------------+---------------+---------------+---------------+
   32/ Reserved                                                      /
    +/                                                               /
     +---------------+---------------+---------------+---------------+
   40| BegRun                                                        |
     +---------------------------------------------------------------+
   44| RunLength                                                     |
     +---------------------------------------------------------------+
   48| Header-Digest (optional)                                      |
     +---------------+---------------+---------------+---------------+
```

구현이 0보다 큰 ErrorRecoveryLevel을 지원하는 경우 모든 SNACK 유형을 지원해야 합니다.\(MUST\)

SNACK은 개시자가 대상으로부터 번호가 매겨진 응답, 데이터 또는 R2T PDU의 재전송을 요청하는 데 사용됩니다. SNACK 요청은 재전송이 요청된 번호가 매겨진 응답 또는 데이터 "실행"을 나타냅니다. 여기서 실행은 재전송이 요청된 첫 번째 StatSN, DataSN 또는 R2TSN으로 시작되며 요청된 상태, 데이터 또는 R2T PDU의 수를 나타냅니다. 첫 번째. 0은 시작 숫자와 길이로 사용될 때 특별한 의미를 갖습니다.

- - RunLength에서 사용될 경우 이니셜부터 시작하는 모든 PDU를 의미합니다.

- BegRun과 RunLength에서 모두 사용될 경우,

- 승인되지 않은 PDU.

SNACK에 의해 요청된 번호가 매겨진 응답 또는 R2T는 현재 값을 전달해야 하는 ExpCmdSN, MaxCmdSN 및 ExpDataSN 필드를 제외하고 대상이 원래 전송한 응답의 정확한 복제본으로 전달되어야 합니다. SNACK이 요청한 R2T는 StatSN의 현재 값도 전달해야 합니다.\(MUST, MUST\)

Data SNACK에 의해 요청된 번호가 지정된 Data-In PDU는 현재 값을 전달해야 하는 ExpCmdSN 및 MaxCmdSN 필드를 제외하고 대상이 원래 전송한 PDU의 정확한 복제본으로 전달되어야 합니다. 재분할은 제외됩니다\(섹션 11.16.3 참조\).\(MUST\)

대상이 전송하지 않았거나 개시자가 이미 승인한 번호가 매겨진 응답, 데이터 또는 R2T를 요청하는 모든 SNACK은 "프로토콜 오류"라는 이유 코드와 함께 거부되어야 합니다.\(MUST\)

---
#### **11.16.1.  Type**

이 필드는 SNACK 함수를 다음과 같이 인코딩합니다.

- 0 - Data/R2T SNACK: 하나 이상의 Data-In 또는 R2T PDU의 재전송을 요청합니다.

- 1 - Status SNACK: 하나 이상의 번호가 매겨진 응답의 재전송을 요청합니다.

```text
      2 - DataACK: positively acknowledges Data-In PDUs.
```

- 3 - R-Data SNACK: 재분할 및 상태 태깅이 가능한 Data-In PDU의 재전송을 요청합니다.

다른 모든 값은 예약되어 있습니다.

명령에 대한 데이터/R2T SNACK, 상태 SNACK 또는 R-데이터 SNACK은 해당 명령에 대한 상태 승인보다 먼저 이루어져야 합니다.\(MUST\)

---
#### **11.16.2.  Data Acknowledgment**

개시자가 ErrorRecoveryLevel 1 이상에서 작동하는 경우 A 비트가 1로 설정된 Data-In PDU를 수신한 후 DataACK 유형의 SNACK을 발행해야 합니다. 그러나 개시자가 입력 시퀀스에서 홀을 감지한 경우 발행을 연기해야 ​​합니다. 구멍이 채워질 때까지 DataACK 유형의 SNACK. 개시자는 비트가 대상에 의해 공격적으로 설정되고 있다고 판단되는 경우\(즉, MaxBurstLength 제한에 도달하기 전\) A 비트를 무시할 수 있습니다.\(MUST, MUST, MAY\)

DataACK는 대상에서 리소스를 해제하는 데 사용되며 데이터 재전송을 요청하거나 암시하는 데 사용되지 않습니다.

개시자는 이미 승인한 데이터에 대해 재전송을 요청해서는 안 됩니다.\(MUST NOT\)

---
#### **11.16.3.  Resegmentation**

개시자 MaxRecvDataSegmentLength가 원래 전송과 개시자가 재전송을 요청하는 시간 사이에 변경된 경우 개시자는 R-Data SNACK을 발행해야 합니다\(섹션 11.16.1 참조\). R-Data SNACK을 사용하면 개시자는 확인되지 않은 모든 데이터를 삭제하고 대상이 이를 다시 보낼 것으로 예상함을 나타냅니다. 또한 재분할을 기대합니다. 이 경우 MaxRecvDataSegmentLength의 변경 사항을 반영하기 위해 재전송된 Data-In PDU는 원래 전송된 PDU와 다를 수 있습니다. DataSN은 대상이 수신한 마지막 DataACK의 BegRun으로 시작합니다. 그렇지 않으면 0부터 시작하여 각 재전송 Data-In PDU에 대해 1씩 증가합니다.\(MUST, MAY\)

R-데이터 SNACK을 수신한 대상은 마지막 또는 유일한 응답으로 SCSI 응답 SNACK 태그 필드에 있는 R-데이터 SNACK의 SNACK 태그 필드 복사본을 포함하는 SCSI 응답을 반환해야 합니다. 예를 들어, SNACK Tag 필드에 다른 값이 포함된 응답을 이미 보냈거나 마지막 Data-In PDU에 상태가 포함된 경우 새 SCSI 응답 PDU를 보내야 합니다. 이 규칙으로 인해 대상이 두 개 이상의 SCSI 응답 PDU를 보내는 경우 모든 SCSI 응답 PDU는 동일한 StatSN을 전달해야 합니다\(섹션 11.4.4 참조\). 둘 이상의 응답이 전송되었을 때 개시자가 손실된 SCSI 응답\(Status-SNACK 포함, 섹션 11.16.1 참조\)을 복구하려고 시도하는 경우 대상은 다음을 포함하여 대상에 알려진 최신 콘텐츠와 함께 SCSI 응답을 보냅니다. 명령의 마지막 SNACK 태그입니다.\(MUST\)

다른 MaxRecvDataSegmentLength와의 연결에 대한 작업의 충성 재할당에 대한 고려 사항은 섹션 7.2.2를 참조하세요.

---
#### **11.16.4.  Initiator Task Tag**

상태 SNACK 및 DataACK의 경우 개시자 작업 태그는 예약된 값 0xffffffff로 설정되어야 합니다. 다른 모든 경우에는 개시자 작업 태그 필드를 참조된 명령의 개시자 작업 태그로 설정해야 합니다.\(MUST, MUST\)

---
#### **11.16.5.  Target Transfer Tag or SNACK Tag**

R-Data SNACK의 경우 이 필드는 0 또는 0xffffffff와 다르고 작업에 대해 고유한 값을 포함해야 합니다\(개시자 작업 태그로 식별됨\). 이 값은 명령에 대해 실행되는 마지막 또는 유일한 SCSI 응답 PDU의 iSCSI 대상에 의해 복사되어야 합니다.\(MUST, MUST\)

DataACK의 경우 대상 전송 태그에는 A 비트가 1로 설정된 SCSI 데이터 입력 PDU와 함께 제공되는 대상 전송 태그 및 LUN의 복사본이 포함되어야 합니다.\(MUST\)

다른 모든 경우에는 대상 전송 태그 필드를 예약된 값 0xffffffff로 설정해야 합니다.\(MUST\)

---
#### **11.16.6.  BegRun**

이 필드는 재전송이 요청된 첫 번째 PDU\(Data/R2T 및 Status SNACK\)의 DataSN, R2TSN, StatSN 또는 다음으로 예상되는 DataSN\(DataACK SNACK\)을 나타냅니다.

BegRun이 0인 경우 RunLength가 0인 것과 함께 사용되는 경우 "확인되지 않은 모든 Data-In, R2T 또는 응답 PDU를 다시 보냅니다"를 의미합니다.

R-Data SNACK의 경우 BegRun은 0이어야 합니다.\(MUST\)

---
#### **11.16.7.  RunLength**

이 필드는 재전송이 요청된 PDU의 수를 나타냅니다.

RunLength가 0이면 BegRun보다 크거나 같은 숫자를 전달하는 모든 Data-In, R2T 또는 응답 PDU를 다시 보내야 한다는 신호입니다.

R-Data SNACK 외에 DataACK SNACK에 대해서도 RunLength가 0이어야 합니다.\(MUST\)

---
### **11.17.  Reject**

```text
   Byte/     0       |       1       |       2       |       3       |
      /              |               |               |               |
     |0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|
     +---------------+---------------+---------------+---------------+
    0|.|.| 0x3f      |1| Reserved    | Reason        | Reserved      |
     +---------------+---------------+---------------+---------------+
    4|TotalAHSLength | DataSegmentLength                             |
     +---------------+---------------+---------------+---------------+
    8/ Reserved                                                      /
    +/                                                               /
     +---------------+---------------+---------------+---------------+
   16| 0xffffffff                                                    |
     +---------------+---------------+---------------+---------------+
   20| Reserved                                                      |
     +---------------+---------------+---------------+---------------+
   24| StatSN                                                        |
     +---------------+---------------+---------------+---------------+
   28| ExpCmdSN                                                      |
     +---------------+---------------+---------------+---------------+
   32| MaxCmdSN                                                      |
     +---------------+---------------+---------------+---------------+
   36| DataSN/R2TSN or Reserved                                      |
     +---------------+---------------+---------------+---------------+
   40| Reserved                                                      |
     +---------------+---------------+---------------+---------------+
   44| Reserved                                                      |
     +---------------+---------------+---------------+---------------+
   48| Header-Digest (optional)                                      |
     +---------------+---------------+---------------+---------------+
   xx/ Complete Header of Bad PDU                                    /
    +/                                                               /
     +---------------+---------------+---------------+---------------+
   yy/Vendor-specific data (if any)                                  /
     /                                                               /
     +---------------+---------------+---------------+---------------+
   zz| Data-Digest (optional)                                        |
     +---------------+---------------+---------------+---------------+
```

거부는 iSCSI 오류 조건\(프로토콜, 지원되지 않는 옵션 등\)을 나타내는 데 사용됩니다.

---
#### **11.17.1.  Reason**

거부 이유는 다음과 같이 코딩됩니다.

```text
   +------+----------------------------------------+----------------+
   | Code | Explanation                            |Can the original|
   | (hex)|                                        |PDU be resent?  |
   +------+----------------------------------------+----------------+
   | 0x01 | Reserved                               | no             |
   |      |                                        |                |
   | 0x02 | Data (payload) digest error            | yes (Note 1)   |
   |      |                                        |                |
   | 0x03 | SNACK Reject                           | yes            |
   |      |                                        |                |
   | 0x04 | Protocol Error (e.g., SNACK Request for| no             |
   |      | a status that was already acknowledged)|                |
   |      |                                        |                |
   | 0x05 | Command not supported                  | no             |
   |      |                                        |                |
   | 0x06 | Immediate command reject - too many    | yes            |
   |      | immediate commands                     |                |
   |      |                                        |                |
   | 0x07 | Task in progress                       | no             |
   |      |                                        |                |
   | 0x08 | Invalid data ack                       | no             |
   |      |                                        |                |
   | 0x09 | Invalid PDU field                      | no (Note 2)    |
   |      |                                        |                |
   | 0x0a | Long op reject - Can't generate Target | yes            |
   |      | Transfer Tag - out of resources        |                |
   |      |                                        |                |
   | 0x0b | Deprecated; MUST NOT be used           | N/A (Note 3)   |
   |      |                                        |                |
   | 0x0c | Waiting for Logout                     | no             |
   +------+----------------------------------------+----------------+
```

참고 1: iSCSI의 경우 Data-Out PDU 재전송은 대상이 복구 R2T를 사용한 재전송을 요청하는 경우에만 수행됩니다. 그러나 이것이 즉시 데이터에 대한 데이터 다이제스트 오류인 경우 개시자는 즉시 데이터를 포함하여 전체 PDU를 재전송하도록 선택할 수 있습니다.

참고 2: 대상은 작업, 응답 또는 데이터 전송을 설명하기 위한 PDU 필드의 모든 유효하지 않은 값에 대해 이 이유 코드를 사용해야 합니다. 몇 가지 예로는 유효하지 않은 TTT/ITT, 버퍼 오프셋, TTT를 규정하는 LUN, SNACK의 유효하지 않은 시퀀스 번호 등이 있습니다.

참고 3: 다음에 정의된 이유 코드 0x0b\("협상 재설정"\)

- \[RFC3720\]의 섹션 10.17.1은 더 이상 사용되지 않으며 구현에 사용되어서는 안 됩니다. 이유 코드 0x0b를 수신하는 구현은 이를 섹션 7.12에 지정된 대로 로그인 단계 및 TCP 연결을 종료하는 협상 실패로 처리해야 합니다.\(MUST NOT, MUST\)

이유에 대한 다른 모든 값은 할당되지 않습니다.

거부로 인해 사전 인스턴스화된 SCSI 작업이 종료되는 모든 경우에 대상은 섹션 11.4.3에 설명된 대로 CHECK CONDITION과 함께 적절한 SCSI 명령 응답을 발행해야 합니다. 거부 전에 SCSI 작업 상태가 이미 전송된 경우에는 추가 상태가 필요하지 않습니다. 개시자의 데이터가 여전히 예상되는 동안 오류가 감지된 경우\(예: 명령 PDU에 모든 데이터가 포함되지 않았고 대상이 원치 않는 데이터에 대해 최종 비트가 1로 설정된 데이터 출력 PDU를 수신하지 않은 경우\) 및 모든 미해결 R2T\(있는 경우\)\) 대상은 응답 PDU를 보내기 전에 F 비트가 1로 설정된 마지막 예상 Data-Out PDU를 수신할 때까지 기다려야 합니다.\(MUST, MUST\)

Reject PDU의 추가적인 사용법 의미에 대해서는 섹션 7.3을 참조하십시오.

---
#### **11.17.2.  DataSN/R2TSN**

이 필드는 거부된 PDU가 데이터/R2T SNACK이고 거부 이유 코드가 "프로토콜 오류"인 경우에만 유효합니다\(섹션 11.16 참조\). DataSN/R2TSN은 대상이 작업을 위해 보내는 다음 Data/R2T 시퀀스 번호입니다.

---
#### **11.17.3.  StatSN, ExpCmdSN, and MaxCmdSN**

이러한 필드는 일반적인 값을 가지며 거부된 명령과 관련이 없습니다. StatSN은 거부 후 진행됩니다.

---
#### **11.17.4.  Complete Header of Bad PDU**

타겟은 오류가 발생한 PDU의 헤더\(다이제스트를 포함하지 않음\)를 응답 데이터로 반환합니다.

---
### **11.18.  NOP-Out**

```text
   Byte/     0       |       1       |       2       |       3       |
      /              |               |               |               |
     |0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|
     +---------------+---------------+---------------+---------------+
    0|.|I| 0x00      |1| Reserved                                    |
     +---------------+---------------+---------------+---------------+
    4|TotalAHSLength | DataSegmentLength                             |
     +---------------+---------------+---------------+---------------+
    8| LUN or Reserved                                               |
     +                                                               +
   12|                                                               |
     +---------------+---------------+---------------+---------------+
   16| Initiator Task Tag or 0xffffffff                              |
     +---------------+---------------+---------------+---------------+
   20| Target Transfer Tag or 0xffffffff                             |
     +---------------+---------------+---------------+---------------+
   24| CmdSN                                                         |
     +---------------+---------------+---------------+---------------+
   28| ExpStatSN                                                     |
     +---------------+---------------+---------------+---------------+
   32/ Reserved                                                      /
    +/                                                               /
     +---------------+---------------+---------------+---------------+
   48| Header-Digest (optional)                                      |
     +---------------+---------------+---------------+---------------+
     / DataSegment - Ping Data (optional)                            /
    +/                                                               /
     +---------------+---------------+---------------+---------------+
     | Data-Digest (optional)                                        |
     +---------------+---------------+---------------+---------------+
```

NOP-Out은 연결/세션이 여전히 활성 상태이고 모든 구성 요소가 작동하는지 확인하기 위해 개시자에 의해 "핑 요청"으로 사용될 수 있습니다. NOP-In 응답은 "핑 에코"입니다.

NOP-Out은 NOP-In에 대한 응답으로 개시자에 의해 전송됩니다.

장기간 다른 PDU를 사용할 수 없는 경우 NOP-Out을 사용하여 변경된 ExpStatSN을 확인할 수도 있습니다.

유효한 값\(예약된 값 0xffffffff 아님\)으로 설정된 대상 전송 태그가 있는 NOP-In을 수신하면 개시자는 NOP-Out으로 응답해야 합니다. 이 경우 NOP-Out 대상 전송 태그에는 NOP-In 대상 전송 태그의 복사본이 포함되어야 합니다. 개시자\(MUST, MUST\)

서로 응답하여 전송된 NOP-In 및 NOP-Out PDU의 긴 시퀀스를 피하기 위해 수신된 다른 NOP-In에 대한 응답으로 NOP-Out을 전송해서는 안 됩니다.\(SHOULD NOT\)

---
#### **11.18.1.  Initiator Task Tag**

NOP-Out에는 NOP-In 형식의 응답이 요청되는 경우에만 유효한 값으로 설정된 개시자 작업 태그가 있어야 합니다\(즉, NOP-Out이 핑 요청으로 사용됨\). 그렇지 않으면 개시자 작업 태그를 0xffffffff로 설정해야 합니다.\(MUST, MUST\)

대상이 유효한 개시자 작업 태그와 함께 NOP-Out을 수신하면 NOP-In 응답으로 응답해야 합니다\(섹션 4.6.3.6 참조\).\(MUST\)

개시자 작업 태그에 0xffffffff가 포함된 경우 I 비트는 1로 설정되어야 하며 CmdSN은 이 PDU가 전송된 후 진행되지 않습니다.\(MUST\)

---
#### **11.18.2.  Target Transfer Tag**

대상 전송 태그는 작업에 대해 대상에 할당된 식별자입니다.

NOP-Out에는 유효한 대상 전송 태그가 있는 NOP-In에 대한 응답으로 발행된 경우에만 대상 전송 태그 세트가 있어야 합니다. 이 경우 NOP-In PDU에서 대상 전송 태그를 복사합니다. 그렇지 않으면 대상 전송 태그를 0xffffffff로 설정해야 합니다.\(MUST, MUST\)

대상 전송 태그가 0xffffffff 이외의 값으로 설정된 경우 LUN 필드도 NOP-In에서 복사되어야 합니다.\(MUST\)

---
#### **11.18.3.  Ping Data**

Ping 데이터는 NOP-In 응답에 반영됩니다. 반영되는 데이터의 길이는 MaxRecvDataSegmentLength로 제한됩니다. 핑 데이터의 길이는 DataSegmentLength로 표시됩니다. 0은 DataSegmentLength의 유효한 값이며 ping 데이터가 없음을 나타냅니다.

---
### **11.19.  NOP-In**

```text
   Byte/     0       |       1       |       2       |       3       |
      /              |               |               |               |
     |0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|
     +---------------+---------------+---------------+---------------+
    0|.|.| 0x20      |1| Reserved                                    |
     +---------------+---------------+---------------+---------------+
    4|TotalAHSLength | DataSegmentLength                             |
     +---------------+---------------+---------------+---------------+
    8| LUN or Reserved                                               |
     +                                                               +
   12|                                                               |
     +---------------+---------------+---------------+---------------+
   16| Initiator Task Tag or 0xffffffff                              |
     +---------------+---------------+---------------+---------------+
   20| Target Transfer Tag or 0xffffffff                             |
     +---------------+---------------+---------------+---------------+
   24| StatSN                                                        |
     +---------------+---------------+---------------+---------------+
   28| ExpCmdSN                                                      |
     +---------------+---------------+---------------+---------------+
   32| MaxCmdSN                                                      |
     +---------------+---------------+---------------+---------------+
   36/ Reserved                                                      /
    +/                                                               /
     +---------------+---------------+---------------+---------------+
   48| Header-Digest (optional)                                      |
     +---------------+---------------+---------------+---------------+
     / DataSegment - Return Ping Data                                /
    +/                                                               /
     +---------------+---------------+---------------+---------------+
     | Data-Digest (optional)                                        |
     +---------------+---------------+---------------+---------------+
```

NOP-In은 NOP-Out에 대한 응답, 개시자에 대한 "핑" 또는 다른 PDU를 오랫동안 사용할 수 없는 경우 변경된 ExpCmdSN 및/또는 MaxCmdSN을 전달하는 수단으로 대상에 의해 전송됩니다\( 목표에 따라 결정됨\).

대상이 유효한 개시자 작업 태그\(예약된 값 0xffffffff 아님\)가 있는 NOP-Out을 수신하면 NOP-Out 요청에 제공된 것과 동일한 개시자 작업 태그가 있는 NOP-In으로 응답해야 합니다. 또한 개시자가 제공한 Ping 데이터의 첫 번째 MaxRecvDataSegmentLength 바이트까지 복제해야 합니다. 이러한 응답의 경우 대상 전송 태그는 0xffffffff여야 합니다. 그만큼\(MUST, MUST, MUST\)

타겟은 서로 응답하여 전송된 NOP-In 및 NOP-Out PDU의 긴 시퀀스를 피하기 위해 수신된 다른 NOP-Out에 대한 응답으로 NOP-In을 전송해서는 안 됩니다.\(SHOULD NOT\)

그렇지 않고 대상이 개시자로부터 수신된 NOP-Out에 대한 응답이 아닌 NOP-In을 보낼 때 개시자 작업 태그는 0xffffffff로 설정되어야 하며 데이터 세그먼트는 어떠한 데이터도 포함해서는 안 됩니다\(DataSegmentLength는 0이어야 합니다\). .\(MUST NOT\)

---
#### **11.19.1.  Target Transfer Tag**

대상이 NOP-Out에 응답하는 경우 이 필드는 예약된 값 0xffffffff로 설정됩니다.

대상이 NOP-In을 ping으로 보내는 경우\(해당 NOP-Out을 수신하려는 의도\) 이 필드는 유효한 값\(예약된 값 0xffffffff 아님\)으로 설정됩니다.

대상이 해당 NOP-Out 수신을 원하지 않고 NOP-In을 시작하는 경우 이 필드는 예약된 값 0xffffffff를 보유해야 합니다.\(MUST\)

---
#### **11.19.2.  StatSN**

StatSN 필드에는 항상 다음 StatSN이 포함됩니다. 그러나 개시자 작업 태그가 0xffffffff로 설정된 경우 이 PDU가 전송된 후 연결에 대한 StatSN이 진행되지 않습니다.

---
#### **11.19.3.  LUN**

대상 전송 태그가 유효한 경우 LUN을 올바른 값으로 설정해야 합니다\(예약된 값 0xffffffff 아님\).\(MUST\)

---
## **12.  iSCSI Security Text Keys and Authentication Methods**

로그인 단계의 SecurityNegoiation 단계에서는 다음 키만 사용됩니다.

```text
      SessionType

      InitiatorName

      TargetName

      TargetAddress

      InitiatorAlias

      TargetAlias

      TargetPortalGroupTag
```

- AuthMethod 및 섹션 12.1에 지정된 인증 방법에 사용되는 키, 모든 관련 키 및 공급업체별 인증 방법.

다른 키는 사용하면 안 됩니다.\(MUST NOT\)

SessionType, InitiatorName, TargetName, InitiatorAlias, TargetAlias ​​및 TargetPortalGroupTag는 OperationalNegotiation 단계에서도 사용할 수 있으므로 섹션 13에 설명되어 있습니다.

모든 보안 키는 연결 전체에 적용됩니다.

---
### **12.1.  AuthMethod**

사용: 로그인 중 - 보안 협상 발신자: 개시자 및 대상 범위: 연결

```text
   AuthMethod = <list-of-values>
```

보안 협상의 주요 항목은 인증 방식\(AuthMethod\)이다.

사용할 수 있는\(값 목록에 표시됨\) 인증 방법은 공급업체 고유 방법이거나 다음 표에 나열된 방법입니다.

```text
    +--------------------------------------------------------------+
    | Name         | Description                                   |
    +--------------------------------------------------------------+
    | KRB5         | Kerberos V5 - defined in [RFC4120]            |
    +--------------------------------------------------------------+
    | SRP          | Secure Remote Password -                      |
    |              | defined in [RFC2945]                          |
    +--------------------------------------------------------------+
    | CHAP         | Challenge Handshake Authentication Protocol - |
    |              | defined in [RFC1994]                          |
    +--------------------------------------------------------------+
    | None         | No authentication                             |
    +--------------------------------------------------------------+
```

AuthMethod를 선택한 다음에는 선택한 인증 방법과 관련된 "인증 교환"이 이어집니다.

인증 방법 제안은 개시자 또는 대상에 의해 이루어질 수 있습니다. 그러나 개시자는 선택한 인증 방법이 선택되는 즉시 해당 인증 방법에 특정한 첫 번째 단계를 수행해야 합니다. 대상이 인증 방법을 제안하면 개시자는 인증 방법 선택과 함께 교환의 첫 번째 키를 보냅니다.\(MUST\)

인증 교환은 개시자를 대상에 인증하고, 선택적으로 대상을 개시자에게 인증합니다. 인증은 선택 사항이지만 대상과 개시자에서 지원해야 합니다.\(MUST\)

개시자와 대상은 CHAP를 구현해야 합니다. 다른 모든 인증 방법은 선택 사항입니다.\(MUST, MAY\)

비공개 또는 공개 확장 알고리즘도 인증 방법에 대해 협상될 수 있습니다. 개인 또는 공용 확장 알고리즘이 기본 제안\(명시적인 관리 조치가 없는 경우 제공\)의 일부일 때마다 구현자는 CHAP가 기본 제안의 대안으로 나열되고 "없음"이 일부가 아닌지 확인해야 합니다. 기본 제안.\(MAY, MUST\)

확장 인증 방법은 다음 두 가지 형식 중 하나를 사용하여 이름을 지정해야 합니다.\(MUST\)

```text
      1) Z-reversed.vendor.dns_name.do_something=
```

- 2\) 이름 접두사 제약이 없는 새로운 공개 키

Z 형식을 사용하여 명명된 인증 방법은 개인 확장으로 사용됩니다. 새로운 공개 키는 IETF 검토 프로세스\(\[RFC5226\]\)를 사용하여 IANA에 등록되어야 합니다. 인증 방법에 대한 새로운 공개 확장은 Z# 이름 접두사를 사용해서는 안 됩니다.\(MUST NOT\)

모든 공개 또는 비공개 확장 인증 방법에 대해 방법별 키는 표준 레이블에 대해 섹션 6.1에 지정된 형식을 준수해야 합니다.\(MUST\)

개인 확장 인증 방법의 공급업체를 식별하려면 역방향 DNS 이름을 적절한 다이제스트 이름의 접두사로 사용하는 것이 좋습니다.

Z- 다음의 다이제스트 이름 부분은 섹션 6.1에 지정된 표준 라벨의 형식을 준수해야 합니다.\(MUST\)

공개 또는 비공개 확장 인증 방법에 대한 지원은 선택 사항입니다.\(MAY\)

다음 하위 섹션에서는 표준화된 각 인증 방법에 대한 특정 교환을 정의합니다. 앞서 언급했듯이 첫 번째 단계는 항상 개시자가 수행합니다.

---
#### **12.1.1.  Kerberos**

KRB5\(Kerberos V5\) \[RFC4120\] \[RFC1964\]의 경우 개시자는 다음을 사용해야 합니다.\(MUST\)

```text
      KRB_AP_REQ=<KRB_AP_REQ>
```

여기서 KRB\_AP\_REQ는 \[RFC4120\]에 정의된 클라이언트 메시지입니다.

iSCSI 개시자 또는 대상\(관리 구성 작업 이전\)이 가정하는 기본 주체 이름은 각각 문자열 "iscsi/"가 앞에 붙은 iSCSI 개시자 이름 또는 iSCSI 대상 이름이어야 합니다.\(MUST\)

개시자 인증이 실패하면 대상은 "인증 실패" 상태의 로그인 거부로 응답해야 합니다. 그렇지 않고 개시자가 상호 인증 옵션을 선택한 경우\(KRB\_AP\_REQ의 ap-options 필드에 MUTUAL-REQUIRED를 설정하여\) 대상은 다음과 같이 응답해야 합니다.\(MUST, MUST\)

```text
      KRB_AP_REP=<KRB_AP_REP>
```

여기서 KRB\_AP\_REP는 \[RFC4120\]에 정의된 서버의 응답 메시지입니다.

상호 인증이 선택되었고 대상 인증이 실패하면 개시자는 연결을 닫아야 합니다.\(MUST\)

KRB\_AP\_REQ 및 KRB\_AP\_REP는 이진 값이며 해당 이진 길이\(인코딩된 형식으로 나타내는 문자열의 길이가 아님\)는 65536바이트를 초과해서는 안 됩니다. KRB\_AP\_REQ 및 KRB\_AP\_REP에는 Hex 또는 Base64 인코딩이 사용될 수 있습니다. 섹션 6.1을 참조하세요.\(MUST NOT\)

---
#### **12.1.2.  Secure Remote Password (SRP)**

SRP \[RFC2945\]의 경우 개시자는 다음을 사용해야 합니다.\(MUST\)

```text
      SRP_U=<U> TargetAuth=Yes     /* or TargetAuth=No */
```

대상은 "Authorization Failure" 상태의 로그인 거부로 응답하거나 다음과 같이 응답해야 합니다.\(MUST\)

```text
      SRP_GROUP=<G1,G2...> SRP_s=<s>
```

여기서 G1,G2...는 선호도에 따라 제안된 그룹입니다.

개시자는 연결을 닫거나 다음을 계속해야 합니다.\(MUST\)

```text
      SRP_A=<A> SRP_GROUP=<G>
```

여기서 G는 타겟이 제안한 G1,G2... 중 하나입니다.

대상은 "인증 실패" 상태와 함께 로그인 거부로 응답하거나 다음으로 응답해야 합니다.\(MUST\)

```text
      SRP_B=<B>
```

개시자는 연결을 종료하거나 다음을 계속해야 합니다.\(MUST\)

```text
      SRP_M=<M>
```

개시자 인증이 실패하면 대상은 "인증 실패" 상태의 로그인 거부로 응답해야 합니다. 그렇지 않고 개시자가 첫 번째 메시지에서 TargetAuth=Yes를 보낸 경우\(대상 인증 필요\) 대상은 다음과 같이 응답해야 합니다.\(MUST, MUST\)

```text
      SRP_HM=<H(A | M | K)>
```

대상 인증이 실패하면 개시자는 연결을 닫아야 합니다.\(MUST\)

```text
   where U, s, A, B, M, and H(A | M | K) are defined in [RFC2945] (using
   the SHA1 hash function, such as SRP-SHA1)

   and
```

G, Gn\("Gn"은 G1,G2...를 나타냄\)은 \[RFC3723\]에 지정된 SRP 그룹의 식별자입니다.

G, Gn 및 U는 텍스트 문자열입니다. s,A,B,M 및 H\(A | M | K\)는 이진 값입니다. 바이너리 형식의 s,A,B,M 및 H\(A | M | K\)의 길이\(인코딩된 형식으로 이를 나타내는 문자열의 길이가 아님\)는 1024바이트를 초과해서는 안 됩니다. 16진수 또는 Base64 인코딩은 s,A,B,M 및 H\(A | M | K\)에 사용될 수 있습니다. 섹션 6.1을 참조하세요.\(MUST NOT\)

관련 로그인 예는 부록 B를 참조하세요.

SRP\_GROUP의 경우 \[RFC3723\]에 최대 1536비트까지 지정된 모든 그룹\(예: SRP-768, SRP-1024, SRP-1280, SRP-1536\)이 개시자와 대상에서 지원되어야 합니다. 상호 운용성을 보장하려면 대상은 항상 제안된 그룹 중 하나로 "SRP-1536"을 제공해야 합니다.\(MUST\)

---
#### **12.1.3.  Challenge Handshake Authentication Protocol (CHAP)**

CHAP \[RFC1994\]의 경우 개시자는 다음을 사용해야 합니다.\(MUST\)

```text
      CHAP_A=<A1,A2...>
```

여기서 A1,A2...는 선호도 순으로 제안된 알고리즘입니다.

대상은 "인증 실패" 상태와 함께 로그인 거부로 응답하거나 다음으로 응답해야 합니다.\(MUST\)

```text
      CHAP_A=<A> CHAP_I=<I> CHAP_C=<C>
```

여기서 A는 개시자가 제안한 A1,A2... 중 하나입니다.

개시자는 다음을 계속해야 합니다.\(MUST\)

```text
      CHAP_N=<N> CHAP_R=<R>
```

또는 대상 인증이 필요한 경우 다음을 사용합니다.

```text
      CHAP_N=<N> CHAP_R=<R> CHAP_I=<I> CHAP_C=<C>
```

개시자 인증이 실패하면 대상은 "인증 실패" 상태의 로그인 거부로 응답해야 합니다. 그렇지 않고 개시자가 대상 인증을 요구하는 경우 대상은 "인증 실패"로 로그인 거부로 응답하거나 다음으로 응답해야 합니다.\(MUST, MUST\)

```text
      CHAP_N=<N> CHAP_R=<R>
```

대상 인증이 실패하면 개시자는 연결을 닫아야 합니다.\(MUST\)

여기서 N, \(A,A1,A2\), I, C 및 R은 \[RFC1994\]에 정의된 이름, 알고리즘, 식별자, 챌린지 및 응답입니다.

N은 텍스트 문자열입니다. A, A1, A2 및 I는 숫자입니다. C와 R은 이진 값입니다. 바이너리 길이\(인코딩된 형식으로 나타내는 문자열의 길이가 아님\)는 1024바이트를 초과해서는 안 됩니다. C와 R에는 Hex 또는 Base64 인코딩이 사용될 수 있습니다. 섹션 6.1을 참조하세요.\(MUST NOT\)

관련 로그인 예는 부록 B를 참조하세요.

\[RFC1994\]에 명시된 대로 알고리즘의 경우 하나의 값을 구현해야 합니다.

```text
      5     (CHAP with MD5)
```

상호 운용성을 보장하기 위해 개시자는 항상 이를 제안된 알고리즘 중 하나로 제공해야 합니다.\(MUST\)

---
## **13.  Login/Text Operational Text Keys**

일부 세션별 매개변수는 선행 연결에서만 전달되어야 하며 선행 연결 로그인 후에는 변경할 수 없습니다\(예: MaxConnections - 최대 연결 수\). 이는 연결 다시 시작과 관련하여 단일 연결 세션에 적용됩니다. 이 범주에 속하는 키에는 "use: LO"\(Leading Only\)가 있습니다.\(MUST\)

로그인 중에만 사용할 수 있는 키에는 "use: IO"\(초기화 전용\)가 있고, 로그인 단계와 전체 기능 단계에서 모두 사용할 수 있는 키에는 "use: ALL"이 있습니다.

전체 기능 단계에서만 사용할 수 있는 키는 FFPO\(전체 기능 단계만\)를 사용합니다.

Any-Stage로 표시된 키는 SecurityNegotiation 단계에도 나타날 수 있으며, 이 섹션에 설명된 다른 모든 키는 작동 키입니다.

답변이 필요하지 않은 키는 선언형으로 표시됩니다.

키 범위는 세션 전체\(SW\) 또는 연결 전용\(CO\)으로 표시됩니다.

언급된 곳마다 "결과 함수"는 응답자 선택의 유효성을 확인하기 위해 적용할 수 있는 함수를 나타냅니다. "최소"는 선택한 값이 제공된 값을 초과할 수 없음을 의미합니다. "최대"는 선택한 값이 제공된 값보다 낮을 수 없음을 의미합니다. "AND"는 선택한 값이 임의의 부울 값이 있는 부울 "and" 함수의 가능한 결과여야 함을 의미합니다\(예: 제공된 값이 No인 경우 선택한 값은 No여야 함\). "OR"은 선택한 값이 임의의 부울 값이 있는 부울 "or" 함수의 가능한 결과여야 함을 의미합니다\(예: 제공된 값이 Yes인 경우 선택한 값은 Yes여야 함\).

---
### **13.1.  HeaderDigest and DataDigest**

사용: IO 발신자: 개시자 및 대상 범위: CO HeaderDigest = <값 목록\> DataDigest = <값 목록\>

HeaderDigest와 DataDigest 모두 기본값은 None입니다.

다이제스트를 사용하면 링크 계층에서 제공하는 무결성 검사와 라우터와 같이 네트워크 수준 PDU를 변경할 수 있는 모든 요소를 ​​포함하여 전체 통신 경로를 포괄하는 것 이상으로 종단 간 비암호화 데이터 무결성을 검사할 수 있습니다. 스위치 및 프록시.

다음 표에는 다이제스트에 대해 협상할 수 있고 모든 iSCSI 개시자와 대상에서 구현해야 하는 순환 무결성 체크섬이 나열되어 있습니다. 이러한 다이제스트 옵션에는 오류 감지 중요성만 있습니다.\(MUST\)

```text
     +---------------------------------------------+
     | Name          | Description     | Generator |
     +---------------------------------------------+
     | CRC32C        | 32-bit CRC      |0x11edc6f41|
     +---------------------------------------------+
     | None          | no digest                   |
     +---------------------------------------------+
```

이 다이제스트에 대한 생성 다항식 G\(x\)는 16진수 표기법으로 제공됩니다\(예: "0x3b"는 0011 1011을 나타내고 다항식은 x\*\*5 + x\*\*4 + x\*\*3 + x + 1입니다\).

개시자와 대상이 다이제스트에 동의하면 전체 기능 단계의 모든 PDU에 이 다이제스트를 사용해야 합니다.\(MUST\)

CRC가 적용되는 세그먼트에 있는 패딩 바이트는 0으로 설정되어야 하며 CRC에 포함되어야 합니다.\(SHOULD\)

CRC는 다음 프로세스와 동일한 결과를 생성하는 방법으로 계산되어야 합니다.\(MUST\)

- PDU 비트는 n - 1차 다항식 M\(x\)의 계수로 간주됩니다. 가장 낮은 번호의 바이트의 비트 7이 최상위 비트\(x\*\*n - 1\)로 간주되고, 그 다음에는 가장 낮은 번호의 바이트의 비트 6부터 가장 높은 번호의 바이트의 비트 0\(x\*\*0\)이 이어집니다.

- 최상위 32비트가 보완됩니다.

- 다항식에 x\*\*32를 곱한 다음 G\(x\)로 나눕니다. 생성기 다항식은 <= 31 차수의 나머지 R\(x\)를 생성합니다.

- R\(x\)의 계수는 32비트 시퀀스로 구성됩니다.

- 비트 시퀀스가 ​​보완되고 그 결과가 CRC입니다.

- CRC 비트는 다이제스트 워드에 매핑됩니다. x\*\*31 계수는 다이제스트의 가장 낮은 번호가 지정된 바이트의 비트 7에 매핑되고 x\*\*24 계수가 가장 낮은 번호가 지정된 바이트의 비트 0에 매핑되도록 매핑은 연속적인 계수 및 비트로 계속됩니다. x\*\*0 계수가 다이제스트의 가장 높은 번호의 바이트의 비트 0에 매핑될 때까지 x\*\*23 계수가 다이제스트의 다음 바이트의 비트 7에 매핑되어 매핑이 계속됩니다.

- 생성기 0x11edc6f41을 사용하여 구축된 CRC를 포함하도록 확장된 모든 세그먼트\(데이터 또는 헤더\)에 대해 CRC를 계산하면 항상 최종 나머지\(R\(x\)\)로 0x1c2d19ed 값을 얻습니다. 이 값은 여기에 다항식 형태로 제공됩니다\(즉, 다이제스트 단어로 매핑되지 않음\).

CRC 선택 기준에 대한 논의는 \[RFC3385\]를 참조하세요. iSCSI 다항식에 대한 자세한 분석은 \[Castagnoli93\]을 참조하세요.

비공개 또는 공개 확장 알고리즘도 다이제스트에 대해 협상될 수 있습니다. 개인 또는 공용 다이제스트 확장 알고리즘이 기본 제안\(명시적인 관리 조치가 없는 경우 제공\)의 일부일 때마다 구현자는 CRC32C가 기본 제안의 대안으로 나열되고 "없음"이 일부가 아닌지 확인해야 합니다. 기본 제안.\(MAY, MUST\)

확장 다이제스트 알고리즘은 다음 두 가지 형식 중 하나를 사용하여 이름을 지정해야 합니다.\(MUST\)

```text
      1) Y-reversed.vendor.dns_name.do_something=
```

- 2\) 이름 접두사 제약이 없는 새로운 공개 키

Y 형식을 사용하여 명명된 다이제스트는 개인용으로 사용됩니다\(등록되지 않음\). 새로운 공개 키는 IETF 검토 프로세스\(\[RFC5226\]\)를 사용하여 IANA에 등록되어야 합니다. 다이제스트에 대한 새로운 공개 확장은 Y# 이름 접두사를 사용하면 안 됩니다.\(MUST NOT\)

개인 확장 다이제스트의 경우 공급업체를 식별하려면 역방향 DNS 이름을 적절한 다이제스트 이름의 접두사로 사용하는 것이 좋습니다.

Y- 다음의 Digest-name 부분은 섹션 6.1에 지정된 표준 라벨의 형식을 준수해야 합니다.\(MUST\)

공개 또는 비공개 확장 다이제스트에 대한 지원은 선택 사항입니다.\(MAY\)

---
### **13.2.  MaxConnections**

사용: LO 발신자: 개시자 및 대상 범위: SW 다음과 같은 경우에는 관련이 없습니다: SessionType=Discovery

```text
   MaxConnections=<numerical-value-from-1-to-65535>
```

기본값은 1입니다. 결과 함수는 최소값입니다.

개시자와 대상은 요청/허용 가능한 최대 연결 수를 협상합니다.

---
### **13.3.  SendTargets**

```text
   Use: FFPO
   Senders: Initiator
   Scope: SW
```

전체 설명은 부록 C를 참조하세요.

---
### **13.4.  TargetName**

사용: 개시자별 IO, 대상별 FFPO -- SendTargets에 대한 응답으로만, 선언적, 모든 단계 발신자: 개시자 및 대상 범위: SW

```text
   TargetName=<iSCSI-name-value>

   Examples:

      TargetName=iqn.1993-11.com.disk-vendor:diskarrays.sn.45678

      TargetName=eui.020000023B040506

      TargetName=naa.62004567BA64678D0123456789ABCDEF
```

TCP 연결 개시자는 발견 세션을 설정하지 않는 경우 첫 번째 로그인 요청에서 원격 엔드포인트에 이 키를 제공해야 합니다. iSCSI 대상 이름은 대상의 전 세계 고유 이름을 지정합니다.\(MUST\)

TargetName 키는 SendTargets 텍스트 요청에 의해 반환될 수도 있습니다\(대상에서 발행할 때만 사용됨\).

TargetName은 로그인 단계 내에서 다시 선언되어서는 안 됩니다.\(MUST NOT\)

---
### **13.5.  InitiatorName**

```text
   Use: IO, Declarative, Any-Stage
   Senders: Initiator
   Scope: SW

   InitiatorName=<iSCSI-name-value>

   Examples:

      InitiatorName=iqn.1992-04.com.os-vendor.plan9:cdrom.12345

      InitiatorName=iqn.2001-02.com.ssp.users:customer235.host90

      InitiatorName=naa.52004567BA64678D
```

TCP 연결 개시자는 모든 연결에 대한 로그인 단계의 첫 번째 로그인 시 원격 엔드포인트에 이 키를 제공해야 합니다. InitiatorName 키를 사용하면 개시자가 원격 끝점에서 자신을 식별할 수 있습니다.\(MUST\)

InitiatorName은 로그인 단계 내에서 다시 선언되어서는 안 됩니다.\(MUST NOT\)

---
### **13.6.  TargetAlias**

```text
   Use: ALL, Declarative, Any-Stage
   Senders: Target
   Scope: SW

   TargetAlias=<iSCSI-local-name-value>

   Examples:

      TargetAlias=Bob-s Disk

      TargetAlias=Database Server 1 Log Disk

      TargetAlias=Web Server 3 Disk 20
```

대상이 사람이 읽을 수 있는 이름이나 설명으로 구성된 경우 SessionType=Normal\(섹션 13.21 참조\)인 경우 로그인 응답 PDU 중에 이 이름이 개시자에게 전달되어야 합니다. 이 문자열은 식별자로 사용되지 않으며 인증이나 권한 부여 결정에 사용되지도 않습니다. 연결된 대상 목록에서 개시자의 사용자 인터페이스에 의해 표시될 수 있습니다.\(SHOULD\)

---
### **13.7.  InitiatorAlias**

```text
   Use: ALL, Declarative, Any-Stage
   Senders: Initiator
   Scope: SW

   InitiatorAlias=<iSCSI-local-name-value>

   Examples:

      InitiatorAlias=Web Server 4

      InitiatorAlias=spyalley.nsa.gov

      InitiatorAlias=Exchange Server
```

개시자가 사람이 읽을 수 있는 이름이나 설명으로 구성된 경우 로그인 요청 PDU 중에 대상과 통신해야 합니다. 그렇지 않은 경우 호스트 이름을 대신 사용할 수 있습니다. 이 문자열은 식별자로 사용되지 않으며 인증이나 권한 부여 결정에 사용되지도 않습니다. 연결된 개시자 목록의 대상 사용자 인터페이스에 표시될 수 있습니다.\(SHOULD\)

---
### **13.8.  TargetAddress**

```text
   Use: ALL, Declarative, Any-Stage
   Senders: Target
   Scope: SW

   TargetAddress=domainname[:port][,portal-group-tag]
```

도메인 이름은 \[RFC3986\]에 지정된 대로 DNS 호스트 이름, 점분리 십진수 IPv4 주소 또는 대괄호로 묶인 IPv6 주소로 지정할 수 있습니다.

TCP 포트가 지정되지 않은 경우 IANA가 할당한 iSCSI용 기본 포트로 간주됩니다\(섹션 14 참조\).

로그인 응답의 리디렉션 상태 결과로 TargetAddress가 반환되는 경우 쉼표와 Portal-group-tag를 생략해야 합니다.\(MUST\)

SendTargets 응답 내에서 TargetAddress가 반환되는 경우 Portal-group-tag가 포함되어야 합니다.\(MUST\)

```text
   Examples:

      TargetAddress=10.0.0.1:5003,1

      TargetAddress=[1080:0:0:0:8:800:200C:417A],65

      TargetAddress=[1080::8:800:200C:417A]:5003,1

      TargetAddress=computingcenter.example.com,23
```

Portal-group-tag의 사용은 부록 C에 설명되어 있습니다. 포트 및 Portal-group-tag의 형식은 TargetPortalGroupTag에 지정된 것과 동일합니다.

---
### **13.9.  TargetPortalGroupTag**

사용: 대상별 IO, 선언적, 모든 단계 발신자: 대상 범위: SW

```text
   TargetPortalGroupTag=<16-bit-binary-value>

   Example:

      TargetPortalGroupTag=1
```

TargetPortalGroupTag 키는 iSCSI 대상 노드 내에서 포털 그룹을 고유하게 식별하는 16비트 이진 값입니다. 이 키는 로그인 요청을 서비스하는 포털 그룹의 태그 값을 전달합니다. iSCSI 대상은 개시자가 TargetName을 제공할 때 C 비트가 0으로 설정된 첫 번째 로그인 요청 PDU에 대한 로그인 응답 PDU의 개시자에게 이 키를 반환합니다.

\[SAM2\]는 정보 텍스트에 TPGT 값이 0이 아니어야 한다고 명시합니다. 이는 잘못된 내용입니다. TPGT의 법적 값으로 0 값이 허용됩니다. 이 불일치는 현재 \[SAM4\]에서 수정되었습니다.

이 키의 전체 사용법에 대해서는 섹션 6.3을 참조하세요.

---
### **13.10.  InitialR2T**

사용: LO 발신자: 개시자 및 대상 범위: SW 다음과 같은 경우에는 관련이 없습니다: SessionType=Discovery

```text
   InitialR2T=<boolean-value>

   Examples:

      I->InitialR2T=No

      T->InitialR2T=No
```

기본값은 예입니다. 결과 함수는 OR입니다.

InitialR2T 키는 단방향 작업에 대한 R2T의 기본 사용과 양방향 명령의 출력 부분을 끄는 데 사용됩니다. 따라서 개시자는 버퍼 오프셋=즉시 데이터 길이를 사용하여 초기 R2T를 수신한 것처럼 대상으로 데이터 전송을 시작할 수 있습니다. 및 원하는 데이터 전송 길이=\(min\(FirstBurstLength, 예상 데이터 전송 길이\) - 수신된 즉시 데이터 길이\).

기본 작업은 개시자와 대상 모두가 초기R2T=No를 지정하는 이 키 쌍 속성을 보내지 않는 한 R2T가 필수라는 것입니다. 첫 번째로 나가는 데이터 버스트\(즉시 데이터 및/또는 별도의 PDU\)만 원치 않는 방식으로 전송될 수 있습니다\(즉, 명시적인 R2T가 필요하지 않음\).

---
### **13.11.  ImmediateData**

사용: LO 발신자: 개시자 및 대상 범위: SW 다음과 같은 경우에는 관련이 없습니다: SessionType=Discovery

```text
   ImmediateData=<boolean-value>
```

기본값은 예입니다. 결과 함수는 AND입니다.

개시자와 대상은 즉각적인 데이터 지원을 협상합니다. 즉시 데이터를 끄려면 개시자 또는 대상이 그렇게 하겠다는 뜻을 명시해야 합니다. 개시자와 대상 모두 ImmediateData=Yes인 경우 ImmediateData를 켤 수 있습니다.

ImmediateData가 Yes로 설정되고 InitialR2T가 Yes\(기본값\)로 설정된 경우 첫 번째 버스트에서는 즉시 데이터만 허용됩니다.

ImmediateData가 No로 설정되고 InitialR2T가 Yes로 설정된 경우 개시자는 원치 않는 데이터를 전송해서는 안 되며 대상은 해당 응답 코드와 함께 원치 않는 데이터를 거부해야 합니다\(MUST\).\(MUST NOT\)

ImmediateData가 No로 설정되고 InitialR2T가 No로 설정된 경우 개시자는 원치 않는 즉시 데이터를 전송해서는 안 되지만 Data-OUT PDU의 원치 않는 버스트 하나를 보낼 수 있습니다.\(MUST NOT\)

ImmediateData가 Yes로 설정되고 InitialR2T가 No로 설정된 경우 개시자는 원치 않는 즉시 데이터 및/또는 Data-OUT PDU의 원치 않는 버스트 하나를 보낼 수 있습니다.\(MAY\)

다음 표는 원치 않는 데이터 옵션을 요약한 것입니다.

```text
     +----------+-------------+------------------+-------------+
     |InitialR2T|ImmediateData|    Unsolicited   |ImmediateData|
     |          |             |   Data-Out PDUs  |             |
     +----------+-------------+------------------+-------------+
     | No       | No          | Yes              | No          |
     +----------+-------------+------------------+-------------+
     | No       | Yes         | Yes              | Yes         |
     +----------+-------------+------------------+-------------+
     | Yes      | No          | No               | No          |
     +----------+-------------+------------------+-------------+
     | Yes      | Yes         | No               | Yes         |
     +----------+-------------+------------------+-------------+
```

---
### **13.12.  MaxRecvDataSegmentLength**

사용: ALL, 선언적 발신자: 개시자 및 대상 범위: CO

```text
   MaxRecvDataSegmentLength=<numerical-value-512-to-(2**24 - 1)>
```

기본값은 8192바이트입니다.

개시자 또는 대상은 iSCSI PDU에서 수신할 수 있는 최대 데이터 세그먼트 길이\(바이트\)를 선언합니다.

송신기\(initiator 또는 target\)는 수신기의 MaxRecvDataSegmentLength를 초과하지 않는 데이터 세그먼트가 포함된 PDU를 보내야 합니다.

대상 수신기는 요청된 데이터의 경우 MaxBurstLength, 요청되지 않은 데이터의 경우 FirstBurstLength로 추가로 제한됩니다. 개시자는 MaxBurstLength를 초과하는 요청된 PDU나 FirstBurstLength\(또는 즉시 데이터가 전송된 경우 FirstBurstLength-Immediate Data Length\)를 초과하는 요청되지 않은 PDU를 전송해서는 안 됩니다.\(MUST NOT\)

---
### **13.13.  MaxBurstLength**

사용: LO 발신자: 개시자 및 대상 범위: SW 다음과 같은 경우에는 관련이 없습니다: SessionType=Discovery

```text
   MaxBurstLength=<numerical-value-512-to-(2**24 - 1)>
```

기본값은 262144\(256KB\)입니다. 결과 함수는 최소값입니다.

개시자와 대상은 데이터 입력 또는 요청된 데이터 출력 iSCSI 시퀀스에서 최대 SCSI 데이터 페이로드\(바이트\)를 협상합니다. 시퀀스는 F 비트가 1로 설정된 Data-In 또는 Data-Out PDU로 끝나는 하나 이상의 연속적인 Data-In 또는 Data-Out PDU로 구성됩니다.

---
### **13.14.  FirstBurstLength**

```text
   Use: LO
   Senders: Initiator and target
   Scope: SW
   Irrelevant when: SessionType=Discovery
   Irrelevant when: ( InitialR2T=Yes and ImmediateData=No )

   FirstBurstLength=<numerical-value-512-to-(2**24 - 1)>
```

기본값은 65536\(64KB\)입니다. 결과 함수는 최소값입니다.

개시자와 대상은 단일 SCSI 명령을 실행하는 동안 iSCSI 개시자가 대상에 보낼 수 있는 원치 않는 데이터의 최대량\(바이트\)을 협상합니다. 여기에는 명령을 따르는 즉시 데이터\(있는 경우\)와 요청되지 않은 데이터 출력 PDU\(있는 경우\)의 시퀀스가 ​​포함됩니다.

```text
   FirstBurstLength MUST NOT exceed MaxBurstLength.
```

---
### **13.15.  DefaultTime2Wait**

사용: LO 발신자: 개시자 및 대상 범위: SW

```text
   DefaultTime2Wait=<numerical-value-0-to-3600>
```

기본값은 2입니다. 결과 함수는 최대값입니다.

개시자와 대상은 명시적/암시적 로그아웃을 시도하거나 예기치 않은 연결 종료 또는 연결 재설정 후 활성 작업 재할당을 시도하기 전에 대기할 최소 시간\(초\)을 협상합니다.

값 0은 로그아웃 또는 활성 작업 재할당을 즉시 시도할 수 있음을 나타냅니다.

---
### **13.16.  DefaultTime2Retain**

사용: LO 발신자: 개시자 및 대상 범위: SW

```text
   DefaultTime2Retain=<numerical-value-0-to-3600>
```

기본값은 20입니다. 결과 함수는 최소값입니다.

개시자와 대상은 초기 대기\(Time2Wait\) 후 최대 시간\(초\)을 협상합니다. 그 전까지는 예기치 않은 연결 종료 또는 연결 재설정 후에도 활성 작업 재할당이 가능합니다.

문제의 연결이 세션의 마지막 LOGGED\_IN 연결인 경우 이 값은 세션 상태 시간 초과이기도 합니다.

0 값은 연결/작업 상태가 대상에 의해 즉시 삭제됨을 나타냅니다.

---
### **13.17.  MaxOutstandingR2T**

사용: LO 발신자: 개시자 및 대상 범위: SW

```text
   MaxOutstandingR2T=<numerical-value-from-1-to-65535>

   Irrelevant when: SessionType=Discovery
```

기본값은 1입니다. 결과 함수는 최소값입니다.

개시자와 대상은 해당 작업의 일부일 수 있는 묵시적인 초기 R2T를 제외하고 작업당 미해결 R2T의 최대 수를 협상합니다. R2T는 마지막 데이터 PDU\(F 비트가 1로 설정됨\)가 전송되거나 해당 데이터 시퀀스에 대해 시퀀스 수신 시간 초과\(섹션 7.1.4.1\)가 발생할 때까지 미해결 상태로 간주됩니다.

---
### **13.18.  DataPDUInOrder**

사용: LO 발신자: 개시자 및 대상 범위: SW 다음과 같은 경우에는 관련이 없습니다: SessionType=Discovery

```text
   DataPDUInOrder=<boolean-value>
```

기본값은 예입니다. 결과 함수는 OR입니다.

"아니요"는 시퀀스 내 데이터 PDU의 순서가 임의임을 나타내기 위해 iSCSI에서 사용됩니다. "예"는 시퀀스 내의 데이터 PDU가 지속적으로 증가하는 주소에 있어야 하며 오버레이가 금지됨을 나타내는 데 사용됩니다.

---
### **13.19.  DataSequenceInOrder**

사용: LO 발신자: 개시자 및 대상 범위: SW 다음과 같은 경우에는 관련이 없습니다: SessionType=Discovery

```text
   DataSequenceInOrder=<boolean-value>
```

기본값은 예입니다. 결과 함수는 OR입니다.

데이터 시퀀스는 F 비트가 1로 설정된 Data-In 또는 Data-Out PDU로 끝나는 Data-In 또는 Data-Out PDU의 시퀀스입니다. 데이터 출력 시퀀스는 요청되지 않거나 R2T에 대한 응답으로 전송됩니다. . 시퀀스는 오프셋 범위를 포함합니다.

DataSequenceInOrder가 No로 설정된 경우 데이터 PDU 시퀀스는 어떤 순서로든 전송될 수 있습니다.

DataSequenceInOrder가 Yes로 설정된 경우 데이터 시퀀스는 지속적으로 감소하지 않는 시퀀스 오프셋\(쓰기용 R2T 버퍼 오프셋 또는 읽기 데이터 시퀀스 내의 가장 작은 SCSI Data-In 버퍼 오프셋\)을 사용하여 전송되어야 합니다.\(MUST\)

DataSequenceInOrder가 Yes로 설정된 경우 대상은 최대 마지막 R2T까지 재시도할 수 있으며 개시자는 마지막으로 읽은 데이터 시퀀스에 대한 재전송을 요청할 수 있습니다. 이러한 이유로 ErrorRecoveryLevel이 0이 아니고 DataSequenceInOrder가 Yes로 설정된 경우 MaxOutstandingR2T를 1로 설정해야 합니다.\(MUST\)

---
### **13.20.  ErrorRecoveryLevel**

사용: LO 발신자: 개시자 및 대상 범위: SW

```text
   ErrorRecoveryLevel=<numerical-value-0-to-2>
```

기본값은 0입니다. 결과 함수는 최소값입니다.

개시자와 대상은 지원되는 복구 수준을 협상합니다.

복구 수준은 복구 기능의 조합을 나타냅니다. 각 복구 수준에는 하위 복구 수준의 모든 기능이 포함되어 있으며 여기에 몇 가지 새로운 기능이 추가됩니다.

복구 메커니즘 설명에는 특정 복구 클래스가 지정되어 있습니다. 7.1.5절에서는 클래스와 레벨 간의 매핑을 설명합니다.

---
### **13.21.  SessionType**

```text
   Use: LO, Declarative, Any-Stage
   Senders: Initiator
   Scope: SW

   SessionType=<Discovery|Normal>
```

기본값은 보통입니다.

개시자는 생성하려는 세션 유형을 나타냅니다. 대상은 이를 수락하거나 거부할 수 있습니다.

검색 세션은 이 세션의 유일한 목적이 검색임을 대상에 나타냅니다. 이 유형의 세션에서 대상이 수락하는 유일한 요청은 SendTargets 키가 있는 텍스트 요청과 "세션 종료"라는 이유가 있는 로그아웃 요청입니다.

Discovery 세션은 MaxConnections = 1을 의미하며 기본 설정과 명시적 설정을 모두 재정의합니다. 섹션 7.4.1에 명시된 대로 ErrorRecoveryLevel은 검색 세션에 대해 0\(영\)이어야 합니다.\(MUST\)

세션 유형에 따라 대상은 세션에 할당할 리소스, 적용할 보안 등을 결정할 수 있습니다. SessionType 키가 "Discovery"로 제공될 경우 개시자의 초기 로그인 요청에서 제공되어야 합니다.\(SHOULD\)

---
### **13.22.  The Private Extension Key Format**

사용: 모든 발신자: 개시자 및 대상 범위: 특정 키에 따라 다름

```text
   X-reversed.vendor.dns_name.do_something=
```

이 형식의 키는 개인 확장 목적으로 사용됩니다. IANA\(비공개\)에 등록되지 않은 경우 이러한 키는 항상 X-로 시작합니다. 새로운 공개 키\(IETF 검토 \[RFC5226\]를 통해 IANA에 등록된 경우\)에는 더 이상 X# 이름 접두사 요구 사항이 없습니다. 구현자는 직관적이고 고유한 이름을 제안할 수 있습니다.

등록되지 않은 키의 경우 공급업체를 식별하려면 역방향 DNS 이름을 키 고유의 접두사로 사용하는 것이 좋습니다.

X- 다음의 key-name 부분은 섹션 6.1에 지정된 key-name 형식을 준수해야 합니다.\(MUST\)

공급업체별 키는 일반 세션에서만 사용해야 합니다.\(MUST\)

공개 또는 비공개 확장 키에 대한 지원은 선택 사항입니다.\(MAY\)

---
### **13.23.  TaskReporting**

사용: LO 발신자: 개시자 및 대상 범위: SW 관련 없는 경우: SessionType=Discovery TaskReporting=<값 목록\>

기본값은 RFC3720입니다.

이 키는 SCSI 대상에서 작업 완료 보고 의미를 협상하는 데 사용됩니다. 다음 표에서는 iSCSI 대상이 각각의 협상된 키 값에 대해 지원해야 하는 의미를 설명합니다. 이 키가 협상될 때마다 적어도 RFC3720 및 ResponseFence 값은 협상 개시자가 옵션으로 제공해야 합니다.\(MUST, MUST\)

```text
     +--------------+------------------------------------------+
     | Name         |             Description                  |
     +--------------+------------------------------------------+
     | RFC3720      | RFC 3720-compliant semantics.  Response  |
     |              | fencing is not guaranteed, and fast      |
     |              | completion of multi-task aborting is not |
     |              | supported.                               |
     +--------------+------------------------------------------+
     | ResponseFence| Response Fence (Section 4.2.2.3.3)       |
     |              | semantics MUST be supported in reporting |
     |              | task completions.                        |
     +--------------+------------------------------------------+
     | FastAbort    | Updated fast multi-task abort semantics  |
     |              | defined in Section 4.2.3.4 MUST be       |
     |              | supported.  Support for the Response     |
     |              | Fence is implied -- i.e., semantics as   |
     |              | described in Section 4.2.2.3.3 MUST be   |
     |              | supported as well.                       |
     +--------------+------------------------------------------+
```

TaskReporting이 FastAbort와 협상되지 않은 경우 섹션 4.2.3.3의 표준 다중 작업 중단 의미 체계를 사용해야 합니다.\(MUST\)

---
### **13.24.  iSCSIProtocolLevel Negotiation**

이 문서와 연결된 iSCSIProtocolLevel은 "1"입니다. 이 키 협상의 응답자 또는 발신자로서 향후 프로토콜 확장 없이 이 문서만을 준수하는 iSCSI 구현은 \[RFC7144\]에 정의된 대로 이 값을 사용해야 합니다.\(MUST\)

---
### **13.25.  Obsoleted Keys**

이 문서는 \[RFC3720\]에 정의된 IFMarker, OFMarker, OFMarkInt 및 IFMarkInt 키를 더 이상 사용하지 않습니다. 그러나 이 문서를 준수하는 iSCSI 구현에서는 텍스트 협상을 통해 이러한 사용되지 않는 키\(예: 응답자 역할\)를 계속 수신할 수 있습니다.

IFMarker 또는 OFMarker 키가 수신되면 호환되는 iSCSI 구현은 일정한 "거부" 값으로 응답해야 합니다. 구현은 "아니요" 값으로 응답할 수도 있습니다.\(SHOULD, MAY\)

그러나 구현은 이러한 키 중 하나에 대해 "NotUnderstood" 값으로 응답해서는 안 됩니다.\(MUST NOT\)

IFMarkInt 또는 OFMarkInt 키가 수신되면 호환 iSCSI 구현은 일정한 "거부" 값으로 응답해야 합니다. 구현은 이러한 키 중 하나에 대해 "NotUnderstood" 값으로 응답해서는 안 됩니다.\(MUST, MUST NOT\)

---
### **13.26.  X#NodeArchitecture**
---
#### **13.26.1.  Definition**

사용: LO, 선언적 발신자: 개시자 및 대상 범위: SW

```text
   X#NodeArchitecture=<list-of-values>
```

기본값은 없음입니다.

```text
   Examples:

      X#NodeArchitecture=ExampleOS/v1234,ExampleInc_SW_Initiator/1.05a

      X#NodeArchitecture=ExampleInc_HW_Initiator/4010,Firmware/2.0.0.5

      X#NodeArchitecture=ExampleInc_SW_Initiator/2.1,CPU_Arch/i686
```

이 문서는 값 목록의 구조나 내용을 정의하지 않습니다.

개시자 또는 대상은 해당 iSCSI 노드 아키텍처의 세부 정보를 원격 끝점에 선언합니다. 이러한 세부 정보에는 iSCSI 공급업체 소프트웨어, 펌웨어 또는 하드웨어 버전이 포함되지만 이에 국한되지는 않습니다. OS 버전; 또는 하드웨어 아키텍처. 이 키는 검색 세션이나 일반 세션에서 선언될 수 있습니다.

키 값의 길이\(값 목록의 전체 길이\)는 255바이트를 초과하면 안 됩니다.\(MUST NOT\)

X#NodeArchitecture는 로그인 단계 중에 다시 선언되어서는 안 됩니다.\(MUST NOT\)

---
#### **13.26.2.  Implementation Requirements**

iSCSI 노드의 기능적 동작\(여기에는 iSCSI 프로토콜 로직\(SCSI, iSCSI 및 TCP/IP 프로토콜\) 포함\)이 X#NodeArchitecture 키의 존재, 부재 또는 내용에 의존해서는 안 됩니다. 키는 상호 운용성 또는 상호 운용성을 위해 iSCSI 노드에서 사용되어서는 안 됩니다.\(MUST NOT, MUST NOT\)

다른 노드를 제외하기 위해. 적절한 사용을 보장하려면 키 값이 노드 자체에 의해 설정되어야 하며 사용자 정의 텍스트를 포함하는 키 값에 대한 규정이 있어서는 안 됩니다.\(SHOULD NOT\)

이 키를 구현하는 노드는 다음 구현 옵션 중 하나를 선택해야 합니다.\(MUST\)

- - 키만 전송합니다.

- - 다른 노드에서 받은 키 값만 기록합니다. 또는

- - 키 값을 전송하고 기록합니다.

키 값 전송을 구현하기로 선택한 각 노드는 키를 이해하지 못하는 iSCSI 노드의 응답을 처리할 준비를 해야 합니다.\(MUST\)

키 값의 전송 및/또는 로깅을 구현하는 노드는 로깅 및 키 전송 세부 정보를 비활성화 및/또는 변경하는 관리 메커니즘도 구현할 수 있습니다\(섹션 9.4 참조\). 따라서 이 키에 대한 유효한 동작은 노드가 완전히 침묵하는 것입니다\(노드는 키 값을 전송하지 않고 단순히 NotUnderstood 응답을 발행하지 않고 수신한 키 값을 버립니다\).

---
## **14.  Rationale for Revised IANA Considerations**

이 문서에서는 이 영역에 상당한 변경이 이루어졌으며, 이 섹션에서는 변경 이유를 간략하게 설명합니다. 이전에 \[RFC3720\]에 지정된 대로 iSCSI는 확장된 로그인/텍스트 키, 다이제스트 알고리즘 및 인증 방법을 표준화된 대응 항목과 구별하기 위해 X- 및 X#과 같은 텍스트 문자열 접두사를 사용했습니다. 그러나 다른 프로토콜의 경험을 바탕으로 \[RFC6648\]에서는 이러한 접두사를 사용하는 확장이 시간이 지남에 따라 표준이 될 수 있으므로 이 관행을 강력히 권장합니다. 기존 텍스트 문자열 이름으로 사용됩니다.

공개 확장에 대한 iSCSI의 경험은 IANA에 등록된 유일한 확장 항목인 X#NodeArchitecture 키가 표준 트랙 RFC \[RFC4850\]에서 표준 키로 지정되었으므로 X#이 필요하지 않았기 때문에 \[RFC6648\]의 권장 사항을 지원합니다. 접두사. 또한 해당 키는 RFC 3720이 처음 게시된 이후 IANA에 등록된 유일한 공개 iSCSI 확장이므로 X#, Y# 및 Z# 공개 확장 형식은 사실상 사용되지 않았습니다.

따라서 이 문서에서는 iSCSI에 대한 IANA 등록 절차를 다음과 같이 변경합니다.

- 1\) X#, Y# 및 Z# 공개 확장에 대한 별도의 레지스트리가 제거됩니다. X# 로그인/텍스트 키\(X#NodeArchitecture\)에 대한 레지스트리의 단일 항목이 기본 "iSCSI 로그인/텍스트 키" 레지스트리로 전송됩니다. IANA는 후자의 두 레지스트리에 대한 등록 요청이 없기 때문에 생성한 적이 없습니다. 기존 X#NodeArchitecture 키를 제외하고 이러한 공개 확장 형식\(X#, Y#, Z#\)은 사용하면 안 됩니다.\(MUST NOT\)

- 2\) 주요 "iSCSI 로그인/텍스트 키", "iSCSI 다이제스트" 및 "iSCSI 인증 방법" IANA 레지스트리에 대한 등록 절차는 향후 iSCSI 확장이 가능하도록 IETF 검토 \[RFC5226\]로 변경되었습니다. 이 변경에는 RFC 편집자 독립 제출을 통해 게시된 RFC에서 IANA 등록 iSCSI 확장을 지정할 가능성을 제거하려는 의도적인 결정이 포함됩니다. 해당 프로세스의 검토 수준이 iSCSI 확장에 대해 충분하지 않기 때문입니다.

- 3\) 기본 IANA 레지스트리에서 개인 확장 형식\(X-, Y-, Z-\)을 사용하여 항목을 등록하는 것에 대한 제한이 제거됩니다. 이러한 형식을 사용하는 확장은 IETF 검토 등록 절차에 따라 등록될 수 있지만 각 형식은 이 RFC에 지정된 확장 유형으로 제한되며 다른 유형에 사용되어서는 안 됩니다. 예를 들어, 확장 로그인/텍스트 키에 대한 X 확장 형식은 다이제스트 알고리즘이나 인증 방법에 사용되어서는 안 됩니다.\(MUST NOT, MUST NOT\)

---
## **15.  IANA Considerations**

IANA에서 할당한 iSCSI 연결용으로 잘 알려진 TCP 포트 번호는 3260이며 이것이 기본 iSCSI 포트입니다. 시스템 TCP 포트 번호가 필요한 구현에서는 IANA가 iSCSI 시스템 포트로 할당한 포트인 포트 860을 사용할 수 있습니다. 그러나 포트 860을 사용하려면 명시적으로 지정해야 합니다. 구현 시 기본적으로 포트 860을 사용해서는 안 됩니다. 3260이 허용되는 유일한 기본값이기 때문입니다.\(MUST NOT\)

IANA는 TCP와 UDP 포트 860 및 3260에 대한 참조를 이 문서에 대한 참조로 대체했습니다. http://www.iana.org/locationments/service-names-port-numbers를 참조하십시오.

IANA는 "iSCSI\(인터넷 소형 컴퓨터 시스템 인터페이스\) 매개변수" 레지스트리 집합의 일부인 모든 iSCSI 레지스트리에서 이 RFC를 참조하도록 RFC 3720, RFC 4850 및 RFC 5048에 대한 모든 참조를 업데이트했습니다. 이 변화는 다음과 같은 사실을 반영합니다.

이 세 가지 RFC는 이 RFC에 의해 더 이상 사용되지 않습니다. 더 이상 사용되지 않는 다른 RFC\(예: RFC 3723, RFC 5046\)에 대한 참조는 변경하면 안 됩니다.

IANA는 "iSCSI 로그인/텍스트 키" 레지스트리에 대해 다음 작업을 수행했습니다.

- - 등록 절차를 표준 필수에서 IETF 검토로 변경했습니다.

- - 이 RFC를 참조하도록 레지스트리에 대한 RFC 5048 참조를 변경했습니다.

- - "iSCSI 확장 키" 레지스트리에서 X#NodeArchitecture 키를 추가하고 이 RFC에 대한 참조를 변경했습니다.

- - RFC 3720 및 RFC 5048에 대한 모든 참조를 대신 이 RFC를 참조하도록 변경했습니다.

IANA는 "iSCSI 인증 방법" 및 "iSCSI 다이제스트" 레지스트리에 대한 등록 절차를 RFC 필수에서 IETF 검토로 변경했습니다.

IANA는 "iSCSI 로그인/텍스트 키" 레지스트리에 하나의 항목이 추가됨에 따라 "iSCSI 확장 키" 레지스트리를 제거했습니다.

IANA는 "iSCSI\(Internet Small Computer System Interface\) 매개변수" 레지스트리 세트의 "iSCSI 인증 방법" 하위 레지스트리에서 각각 SPKM1 및 SPKM2에 대해 값 4 및 5를 더 이상 사용되지 않는 것으로 표시했습니다.

IANA는 섹션 13.24에 언급된 대로 이 문서를 "iSCSI 프로토콜 수준" 레지스트리에 값 1로 추가했습니다.

\[RFC3720\] 및 \[RFC5048\]에 명시된 다른 모든 IANA 고려 사항은 변경되지 않습니다. 다음 하위 레지스트리에 포함된 할당은 이 문서에서 반복되지 않습니다.

```text
      - iSCSI authentication methods (from Section 13 of [RFC3720])

      - iSCSI digests (from Section 13 of [RFC3720])
```

이 문서에서는 AuthMethod 텍스트 키에 대한 SPKM1 및 SPKM2 키 값을 더 이상 사용하지 않습니다. 결과적으로 SPKM\_ 텍스트 키 접두사는 더 이상 사용되지 않는 것으로 처리되어야 하며 재사용되어서는 안 됩니다.\(MUST\)

---
## **16.  References**
---
### **16.1.  Normative References**

```text
   [EUI]      "Guidelines for 64-bit Global Identifier (EUI-64(TM))",
              <http://standards.ieee.org/regauth/oui/tutorials/
              EUI64.html>.
```

\[FC-FS3\] INCITS 기술 위원회 T11, "파이버 채널 - 프레이밍 및 신호 - 3\(FC-FS-3\)", ANSI INCITS 470-2011, 2011.

```text
   [OUI]      "IEEE OUI and "company_id" Assignments",
              <http://standards.ieee.org/regauth/oui>.
```

\[RFC1122\] Braden, R., Ed., "인터넷 호스트에 대한 요구 사항 - 통신 계층", STD 3, RFC 1122, 1989년 10월.

```text
   [RFC1964]  Linn, J., "The Kerberos Version 5 GSS-API Mechanism",
              RFC 1964, June 1996.
```

\[RFC1982\] Elz, R. 및 R. Bush, "일련 번호 산술", RFC 1982, 1996년 8월.

```text
   [RFC1994]  Simpson, W., "PPP Challenge Handshake Authentication
              Protocol (CHAP)", RFC 1994, August 1996.
```

\[RFC2119\] Bradner, S., "요구 사항 수준을 나타내기 위해 RFC에서 사용할 핵심 단어", BCP 14, RFC 2119, 1997년 3월.

\[RFC2404\] Madson, C. 및 R. Glenn, "ESP 및 AH 내에서 HMAC-SHA-1-96의 사용", RFC 2404, 1998년 11월.

\[RFC2406\] Kent, S. 및 R. Atkinson, "IP ESP\(보안 페이로드 캡슐화\)", RFC 2406, 1998년 11월.

\[RFC2451\] Pereira, R. 및 R. Adams, "ESP CBC 모드 암호화 알고리즘", RFC 2451, 1998년 11월.

\[RFC2945\] Wu, T., "SRP 인증 및 키 교환 시스템", RFC 2945, 2000년 9월.

\[RFC3454\] Hoffman, P. 및 M. Blanchet, "준비

- 국제화된 문자열\("stringprep"\)", RFC 3454, 2002년 12월.

\[RFC3566\] Frankel, S. 및 H. Herbert, "AES-XCBC-MAC-96 알고리즘 및 IPsec에서의 사용", RFC 3566, 2003년 9월.

\[RFC3629\] Yergeau, F., "UTF-8, 변환 형식

- ISO 10646", STD 63, RFC 3629, 2003년 11월.

\[RFC3686\] Housley, R., "IPsec ESP\(캡슐화 보안 페이로드\)와 함께 AES\(고급 암호화 표준\) 카운터 모드 사용", RFC 3686, 2004년 1월.

\[RFC3722\] Bakke, M., "iSCSI\(인터넷 소형 컴퓨터 시스템 인터페이스\) 이름에 대한 문자열 프로필", RFC 3722, 2004년 4월.

\[RFC3723\] Aboba, B., Tseng, J., Walker, J., Rangan, V. 및 F. Travostino, "IP를 통한 블록 스토리지 프로토콜 보안", RFC 3723, 2004년 4월.

\[RFC3986\] Berners-Lee, T., Fielding, R. 및 L. Masinter, "Uniform Resource Identifier\(URI\): 일반 구문", STD 66, RFC 3986, 2005년 1월.

\[RFC4106\] Viega, J. 및 D. McGrew, "IPsec ESP\(보안 페이로드 캡슐화\)에서 Galois/카운터 모드\(GCM\) 사용", RFC 4106, 2005년 6월.

\[RFC4120\] Neuman, C., Yu, T., Hartman, S. 및 K. Raeburn, "The Kerberos 네트워크 인증 서비스\(V5\)", RFC 4120, 2005년 7월.

\[RFC4171\] Tseng, J., Gibbons, K., Travostino, F., Du Laney, C. 및 J. Souza, "iSNS\(인터넷 저장소 이름 서비스\)", RFC 4171, 2005년 9월.

\[RFC4291\] Hinden, R. 및 S. Deering, "IP 버전 6 주소 지정 아키텍처", RFC 4291, 2006년 2월.

\[RFC4301\] Kent, S. 및 K. Seo, "인터넷 프로토콜을 위한 보안 아키텍처", RFC 4301, 2005년 12월.

```text
   [RFC4303]  Kent, S., "IP Encapsulating Security Payload (ESP)",
              RFC 4303, December 2005.
```

\[RFC4304\] Kent, S., "ISAKMP\(인터넷 보안 협회 및 키 관리 프로토콜\)에 대한 IPsec 해석 도메인\(DOI\)에 대한 확장된 시퀀스 번호\(ESN\) 부록", RFC 4304, 2005년 12월.

\[RFC4543\] McGrew, D. 및 J. Viega, "IPsec ESP 및 AH에서 GMAC\(Galois 메시지 인증 코드\) 사용", RFC 4543, 2006년 5월.

\[RFC4648\] Josefsson, S., "Base16, Base32 및 Base64 데이터 인코딩", RFC 4648, 2006년 10월.

\[RFC5226\] Narten, T. 및 H. Alvestrand, "RFC에서 IANA 고려 사항 섹션 작성 지침", BCP 26, RFC 5226, 2008년 5월.

\[RFC5996\] Kaufman, C., Hoffman, P., Nir, Y. 및 P. Eronen,

- "IKEv2\(인터넷 키 교환 프로토콜 버전 2\)", RFC 5996, 2010년 9월.

\[RFC6960\] Santesson, S., Myers, M., Ankney, R., Malpani, A., Galperin, S. 및 C. Adams, "X.509 인터넷 공개 키 인프라 온라인 인증서 상태 프로토콜 - OCSP", RFC 6960, 2013년 6월.

\[RFC7144\] Knight, F. 및 M. Chadalapaka, "iSCSI\(인터넷 소형 컴퓨터 시스템 인터페이스\) SCSI 기능 업데이트", RFC 7144, 2014년 4월.

\[RFC7145\] Ko, M. 및 A. Nezhinsky, "RDMA\(원격 직접 메모리 액세스\) 사양을 위한 iSCSI\(인터넷 소형 컴퓨터 시스템 인터페이스\) 확장", RFC 7145, 2014년 4월.

\[RFC7146\] Black, D. 및 P. Koning, "IP를 통한 블록 스토리지 프로토콜 보안: IPsec v3에 대한 RFC 3723 요구 사항 업데이트", RFC 7146, 2014년 4월.

```text
   [SAM2]     INCITS Technical Committee T10, "SCSI Architecture Model -
              2 (SAM-2)", ANSI INCITS 366-2003, ISO/IEC 14776-412, 2003.

   [SAM4]     INCITS Technical Committee T10, "SCSI Architecture Model -
              4 (SAM-4)", ANSI INCITS 447-2008, ISO/IEC 14776-414, 2008.

   [SPC2]     INCITS Technical Committee T10, "SCSI Primary Commands -
              2", ANSI INCITS 351-2001, ISO/IEC 14776-452, 2001.

   [SPC3]     INCITS Technical Committee T10, "SCSI Primary Commands -
              3", ANSI INCITS 408-2005, ISO/IEC 14776-453, 2005.

   [UML]      ISO, "Unified Modeling Language (UML) Version 1.4.2",
              ISO/IEC 19501:2005.

   [UNICODE]  The Unicode Consortium, "Unicode Standard Annex #15:
              Unicode Normalization Forms", 2013,
              <http://www.unicode.org/unicode/reports/tr15>.
```

---
### **16.2.  Informative References**

\[카스타뇰리93\]

- Castagnoli, G., Brauer, S. 및 M. Herrmann, "24 및 32 패리티 비트를 사용한 순환 중복 검사 코드 최적화", IEEE Transact. 커뮤니케이션에 관한 것, Vol. 41, 6호, 1993년 6월.

```text
   [FC-SP-2]  INCITS Technical Committee T11, "Fibre Channel Security
              Protocols 2", ANSI INCITS 496-2012, 2012.

   [IB]       InfiniBand, "InfiniBand(TM) Architecture Specification",
              Vol. 1, Rel. 1.2.1, InfiniBand Trade Association,
              <http://www.infinibandta.org>.
```

\[RFC1737\] Sollins, K. 및 L. Masinter, "Uniform Resource Names에 대한 기능 요구 사항", RFC 1737, 1994년 12월.

\[RFC2401\] Kent, S. 및 R. Atkinson, "인터넷 프로토콜을 위한 보안 아키텍처", RFC 2401, 1998년 11월.

\[RFC2407\] Piper, D., "인터넷 IP 보안 도메인

- ISAKMP에 대한 해석", RFC 2407, 1998년 11월.

\[RFC2409\] Harkins, D. 및 D. Carrel, "인터넷 키 교환\(IKE\)", RFC 2409, 1998년 11월.

\[RFC2608\] Guttman, E., Perkins, C., Veizades, J. 및 M. Day, "서비스 위치 프로토콜, 버전 2", RFC 2608, 1999년 6월.

```text
   [RFC2743]  Linn, J., "Generic Security Service Application Program
              Interface Version 2, Update  ", RFC 2743, January 2000.
```

\[RFC2865\] Rigney, C., Willens, S., Rubens, A. 및 W. Simpson, "RADIUS\(원격 인증 다이얼 인 사용자 서비스\)", RFC 2865, 2000년 6월.

\[RFC3385\] Sheinwald, D., Satran, J., Thaler, P. 및 V. Cavanna, "iSCSI\(인터넷 프로토콜 소형 컴퓨터 시스템 인터페이스\) CRC\(순환 중복 검사\)/체크섬 고려 사항", RFC 3385, 2002년 9월.

\[RFC3602\] Frankel, S., Glenn, R. 및 S. Kelly, "AES-CBC 암호 알고리즘 및 IPsec에서의 사용", RFC 3602, 2003년 9월.

\[RFC3720\] Satran, J., Meth, K., Sapuntzakis, C., Chadalapaka, M. 및 E. Zeidner, "iSCSI\(인터넷 소형 컴퓨터 시스템 인터페이스\)", RFC 3720, 2004년 4월.

\[RFC3721\] Bakke, M., Hafner, J., Hufferd, J., Voruganti, K. 및 M. Krueger, "iSCSI\(인터넷 소형 컴퓨터 시스템 인터페이스\) 명명 및 검색", RFC 3721, 2004년 4월.

\[RFC3783\] Chadalapaka, M. 및 R. Elliott, "iSCSI의 SCSI\(소형 컴퓨터 시스템 인터페이스\) 명령 순서 고려 사항", RFC 3783, 2004년 5월.

\[RFC4121\] Zhu, L., Jaganathan, K. 및 S. Hartman, "Kerberos 버전 5 일반 보안 서비스 응용 프로그램 인터페이스\(GSS-API\) 메커니즘: 버전 2", RFC 4121, 2005년 7월.

\[RFC4297\] Romanow, A., Mogul, J., Talpey, T. 및 S. Bailey, "IP 문제 설명을 통한 RDMA\(원격 직접 메모리 액세스\)", RFC 4297, 2005년 12월.

\[RFC4806\] Myers, M. 및 H. Tschofenig, "IKEv2에 대한 OCSP\(온라인 인증서 상태 프로토콜\) 확장", RFC 4806, 2007년 2월.

\[RFC4850\] Wysochanski, D., "iSCSI\(인터넷 소형 컴퓨터 시스템 인터페이스\) 노드 아키텍처를 위한 선언적 공개 확장 키", RFC 4850, 2007년 4월.

\[RFC5046\] Ko, M., Chadalapaka, M., Hufferd, J., Elzur, U., Shah, H. 및 P. Thaler, "RDMA\(원격 직접 메모리 액세스\)를 위한 iSCSI\(인터넷 소형 컴퓨터 시스템 인터페이스\) 확장 \)", RFC 5046, 2007년 10월.

\[RFC5048\] Chadalapaka, M., Ed., "iSCSI\(인터넷 소형 컴퓨터 시스템 인터페이스\) 수정 및 설명", RFC 5048, 2007년 10월.

\[RFC5433\] Clancy, T. 및 H. Tschofenig, "확장 가능 인증 프로토콜 - 일반화된 사전 공유 키\(EAP-GPSK\) 방법", RFC 5433, 2009년 2월.

\[RFC6648\] Saint-Andre, P., Crocker, D. 및 M. Nottingham,

- "애플리케이션 프로토콜에서 "X-" 접두사 및 유사 구문 사용 중단", BCP 178, RFC 6648, 2012년 6월.

```text
   [SAS]      INCITS Technical Committee T10, "Serial Attached SCSI -
              2.1 (SAS-2.1)", ANSI INCITS 457-2010, 2010.

   [SBC2]     INCITS Technical Committee T10, "SCSI Block Commands - 2
              (SBC-2)", ANSI INCITS 405-2005, ISO/IEC 14776-322, 2005.

   [SPC4]     INCITS Technical Committee T10, "SCSI Primary Commands -
              4", ANSI INCITS 513-201x.

   [SPL]      INCITS Technical Committee T10, "SAS Protocol Layer - 2
              (SPL-2)", ANSI INCITS 505-2013, ISO/IEC 14776-262, 2013.
```

---
# **Appendix A.  Examples**
---
### **A.1.  Read Operation Example**

```text
   +------------------+-----------------------+---------------------+
   |Initiator Function|       PDU Type        |   Target Function   |
   +------------------+-----------------------+---------------------+
   | Command request  |SCSI Command (read)>>> |                     |
   | (read)           |                       |                     |
   +------------------+-----------------------+---------------------+
   |                  |                       |Prepare Data Transfer|
   +------------------+-----------------------+---------------------+
   |   Receive Data   |   <<< SCSI Data-In    |   Send Data         |
   +------------------+-----------------------+---------------------+
   |   Receive Data   |   <<< SCSI Data-In    |   Send Data         |
   +------------------+-----------------------+---------------------+
   |   Receive Data   |   <<< SCSI Data-In    |   Send Data         |
   +------------------+-----------------------+---------------------+
   |                  |   <<< SCSI Response   |Send Status and Sense|
   +------------------+-----------------------+---------------------+
   | Command Complete |                       |                     |
   +------------------+-----------------------+---------------------+
```

---
### **A.2.  Write Operation Example**

```text
   +------------------+-----------------------+---------------------+
   |Initiator Function|       PDU Type        |   Target Function   |
   +------------------+-----------------------+---------------------+
   | Command request  |SCSI Command (write)>>>| Receive command     |
   | (write)          |                       | and queue it        |
   +------------------+-----------------------+---------------------+
   |                  |                       | Process old commands|
   +------------------+-----------------------+---------------------+
   |                  |                       | Ready to process    |
   |                  |   <<< R2T             | write command       |
   +------------------+-----------------------+---------------------+
   |   Send Data      |   SCSI Data-Out >>>   |   Receive Data      |
   +------------------+-----------------------+---------------------+
   |                  |   <<< R2T             | Ready for data      |
   +------------------+-----------------------+---------------------+
   |                  |   <<< R2T             | Ready for data      |
   +------------------+-----------------------+---------------------+
   |   Send Data      |   SCSI Data-Out >>>   |   Receive Data      |
   +------------------+-----------------------+---------------------+
   |   Send Data      |   SCSI Data-Out >>>   |   Receive Data      |
   +------------------+-----------------------+---------------------+
   |                  |   <<< SCSI Response   |Send Status and Sense|
   +------------------+-----------------------+---------------------+
   | Command Complete |                       |                     |
   +------------------+-----------------------+---------------------+
```

---
### **A.3.  R2TSN/DataSN Use Examples**
---
#### **A.3.1.  Output (Write) Data DataSN/R2TSN Example**

```text
   +-------------------+------------------------+---------------------+
   |Initiator Function |  PDU Type and Content  |   Target Function   |
   +-------------------+------------------------+---------------------+
   | Command request   |SCSI Command (write)>>> | Receive command     |
   | (write)           |                        | and queue it        |
   +-------------------+------------------------+---------------------+
   |                   |                        | Process old commands|
   +-------------------+------------------------+---------------------+
   |                   |   <<< R2T              | Ready for data      |
   |                   |   R2TSN = 0            |                     |
   +-------------------+------------------------+---------------------+
   |                   |   <<< R2T              | Ready for more data |
   |                   |   R2TSN = 1            |                     |
   +-------------------+------------------------+---------------------+
   | Send Data         |   SCSI Data-Out >>>    |   Receive Data      |
   | for R2TSN 0       |   DataSN = 0, F = 0    |                     |
   +-------------------+------------------------+---------------------+
   | Send Data         |   SCSI Data-Out >>>    |   Receive Data      |
   | for R2TSN 0       |   DataSN = 1, F = 1    |                     |
   +-------------------+------------------------+---------------------+
   | Send Data         |   SCSI Data >>>        |   Receive Data      |
   | for R2TSN 1       |   DataSN = 0, F = 1    |                     |
   +-------------------+------------------------+---------------------+
   |                   |   <<< SCSI Response    |Send Status and Sense|
   |                   |   ExpDataSN = 0        |                     |
   +-------------------+------------------------+---------------------+
   | Command Complete  |                        |                     |
   +-------------------+------------------------+---------------------+
```

---
#### **A.3.2.  Input (Read) Data DataSN Example**

```text
   +------------------+-----------------------+----------------------+
   |Initiator Function|        PDU Type       |    Target Function   |
   +------------------+-----------------------+----------------------+
   | Command request  |SCSI Command (read)>>> |                      |
   | (read)           |                       |                      |
   +------------------+-----------------------+----------------------+
   |                  |                       |Prepare Data Transfer |
   +------------------+-----------------------+----------------------+
   |   Receive Data   |   <<< SCSI Data-In    |   Send Data          |
   |                  |   DataSN = 0, F = 0   |                      |
   +------------------+-----------------------+----------------------+
   |   Receive Data   |   <<< SCSI Data-In    |   Send Data          |
   |                  |   DataSN = 1, F = 0   |                      |
   +------------------+-----------------------+----------------------+
   |   Receive Data   |   <<< SCSI Data-In    |   Send Data          |
   |                  |   DataSN = 2, F = 1   |                      |
   +------------------+-----------------------+----------------------+
   |                  |   <<< SCSI Response   |Send Status and Sense |
   |                  |   ExpDataSN = 3       |                      |
   +------------------+-----------------------+----------------------+
   | Command Complete |                       |                      |
   +------------------+-----------------------+----------------------+
```

---
#### **A.3.3.  Bidirectional DataSN Example**

```text
   +------------------+-----------------------+---------------------+
   |Initiator Function|       PDU Type        |   Target Function   |
   +------------------+-----------------------+---------------------+
   | Command request  |SCSI Command >>>       |                     |
   | (Read-Write)     | Read-Write            |                     |
   +------------------+-----------------------+---------------------+
   |                  |                       | Process old commands|
   +------------------+-----------------------+---------------------+
   |                  |   <<< R2T             | Ready to process    |
   |                  |   R2TSN = 0           | write command       |
   +------------------+-----------------------+---------------------+
   | * Receive Data   |   <<< SCSI Data-In    |   Send Data         |
   |                  |   DataSN = 0, F = 0   |                     |
   +------------------+-----------------------+---------------------+
   | * Receive Data   |   <<< SCSI Data-In    |   Send Data         |
   |                  |   DataSN = 1, F = 1   |                     |
   +------------------+-----------------------+---------------------+
   | * Send Data      |   SCSI Data-Out >>>   |   Receive Data      |
   | for R2TSN 0      |   DataSN = 0, F = 1   |                     |
   +------------------+-----------------------+---------------------+
   |                  |   <<< SCSI Response   |Send Status and Sense|
   |                  |   ExpDataSN = 2       |                     |
   +------------------+-----------------------+---------------------+
   | Command Complete |                       |                     |
   +------------------+-----------------------+---------------------+
```

\* 데이터 전송 및 수신 데이터는 원자적인 Read-Old-Write-New처럼 동시에 전송되거나 원자적인 읽기-업데이트-쓰기처럼 순차적으로 전송될 수 있습니다\(후자의 경우 R2T가 수신된 데이터를 따를 수 있음\).

A.3.4. DataSN을 사용한 원치 않는 즉시 출력\(쓰기\) 데이터 예

```text
   +------------------+------------------------+----------------------+
   |Initiator Function|  PDU Type and Content  |   Target Function    |
   +------------------+------------------------+----------------------+
   | Command request  |SCSI Command (write)>>> | Receive command      |
   | (write)          |F = 0                   | and data             |
   |+ immediate data  |                        | and queue it         |
   +------------------+------------------------+----------------------+
   | Send Unsolicited |    SCSI Write Data >>> | Receive more Data    |
   | Data             |    DataSN = 0, F = 1   |                      |
   +------------------+------------------------+----------------------+
   |                  |                        | Process old commands |
   +------------------+------------------------+----------------------+
   |                  |    <<< R2T             | Ready for more data  |
   |                  |    R2TSN = 0           |                      |
   +------------------+------------------------+----------------------+
   | Send Data        |    SCSI Write Data >>> |   Receive Data       |
   | for R2TSN 0      |    DataSN = 0, F = 1   |                      |
   +------------------+------------------------+----------------------+
   |                  |    <<< SCSI Response   |Send Status and Sense |
   |                  |                        |                      |
   +------------------+------------------------+----------------------+
   | Command Complete |                        |                      |
   +------------------+------------------------+----------------------+
```

---
### **A.4.  CRC Examples**

참고: 모든 값은 16진수입니다.

32바이트의 0:

```text
      Byte:        0  1  2  3

         0:       00 00 00 00
       ...
        28:       00 00 00 00

       CRC:       aa 36 91 8a
```

32바이트:

```text
      Byte:        0  1  2  3

         0:       ff ff ff ff
       ...
        28:       ff ff ff ff

       CRC:       43 ab a8 62
```

00..1f 증가 32바이트:

```text
      Byte:        0  1  2  3

         0:       00 01 02 03
       ...
        28:       1c 1d 1e 1f

       CRC:       4e 79 dd 46
```

1f..00 감소의 32바이트:

```text
      Byte:        0  1  2  3

         0:       1f 1e 1d 1c
       ...
        28:       03 02 01 00

       CRC:       5c db 3f 11
```

iSCSI - SCSI 읽기\(10\) 명령 PDU:

```text
     Byte:        0     1    2    3

        0:       01    c0   00   00
        4:       00    00   00   00
        8:       00    00   00   00
       12:       00    00   00   00
       16:       14    00   00   00
       20:       00    00   04   00
       24:       00    00   00   14
       28:       00    00   00   18
       32:       28    00   00   00
       36:       00    00   00   00
       40:       02    00   00   00
       44:       00    00   00   00

      CRC:       56    3a   96   d9
```

---
# **Appendix B.  Login Phase Examples**

첫 번째 예에서는 개시자와 대상이 Kerberos를 통해 서로를 인증합니다.

```text
      I-> Login (CSG,NSG=0,1 T=1)
          InitiatorName=iqn.1999-07.com.os:hostid.77
          TargetName=iqn.1999-07.com.example:diskarray.sn.88
          AuthMethod=KRB5,SRP,None

      T-> Login (CSG,NSG=0,0 T=0)
          AuthMethod=KRB5

      I-> Login (CSG,NSG=0,1 T=1)
          KRB_AP_REQ=<krb_ap_req>

   (krb_ap_req contains the Kerberos V5 ticket and authenticator with
   MUTUAL-REQUIRED set in the ap-options field)
```

인증이 성공하면 대상은 다음을 진행합니다.

```text
      T-> Login (CSG,NSG=0,1 T=1)
          KRB_AP_REP=<krb_ap_rep>

   (krb_ap_rep is the Kerberos V5 mutual authentication reply)
```

인증이 성공하면 개시자는 다음을 진행할 수 있습니다.

```text
      I-> Login (CSG,NSG=1,0 T=0) FirstBurstLength=8192

      T-> Login (CSG,NSG=1,0 T=0) FirstBurstLength=4096
          MaxBurstLength=8192

      I-> Login (CSG,NSG=1,0 T=0) MaxBurstLength=8192
          ... more iSCSI Operational Parameters

      T-> Login (CSG,NSG=1,0 T=0)
          ... more iSCSI Operational Parameters
```

- 그리고 마지막에는:

```text
      I-> Login (CSG,NSG=1,3 T=1)
          optional iSCSI parameters

      T-> Login (CSG,NSG=1,3 T=1) "login accept"
```

대상에 의한 개시자의 인증이 실패하면 대상은 다음과 같이 응답합니다.

```text
      T-> Login "login reject"
```

Login KRB\_AP\_REP 메시지 대신 연결을 종료합니다.

Initiator에 의한 대상 인증이 성공하지 못한 경우 Initiator는 Login KRB\_AP\_REP 메시지에 응답하지 않고 연결을 종료합니다.

다음 예에서는 개시자만 Kerberos를 통해 대상에 의해 인증됩니다.

```text
      I-> Login (CSG,NSG=0,1 T=1)
          InitiatorName=iqn.1999-07.com.os:hostid.77
          TargetName=iqn.1999-07.com.example:diskarray.sn.88
          AuthMethod=SRP,KRB5,None

      T-> Login-PR (CSG,NSG=0,0 T=0)
          AuthMethod=KRB5

      I-> Login (CSG,NSG=0,1 T=1)
          KRB_AP_REQ=krb_ap_req

   (MUTUAL-REQUIRED not set in the ap-options field of krb_ap_req)
```

인증이 성공하면 대상은 다음을 진행합니다.

```text
      T-> Login (CSG,NSG=0,1 T=1)

      I-> Login (CSG,NSG=1,0 T=0)
          ... iSCSI parameters

      T-> Login (CSG,NSG=1,0 T=0)
          ... iSCSI parameters

      . . .

      T-> Login (CSG,NSG=1,3 T=1)"login accept"
```

다음 예에서는 개시자와 대상이 SRP를 통해 서로를 인증합니다.

```text
      I-> Login (CSG,NSG=0,1 T=1)
          InitiatorName=iqn.1999-07.com.os:hostid.77
          TargetName=iqn.1999-07.com.example:diskarray.sn.88
          AuthMethod=KRB5,SRP,None

      T-> Login-PR (CSG,NSG=0,0 T=0)
          AuthMethod=SRP

      I-> Login (CSG,NSG=0,0 T=0)
          SRP_U=<user>
          TargetAuth=Yes

      T-> Login (CSG,NSG=0,0 T=0)
          SRP_N=<N>
          SRP_g=<g>
          SRP_s=<s>

      I-> Login (CSG,NSG=0,0 T=0)
          SRP_A=<A>

      T-> Login (CSG,NSG=0,0 T=0)
          SRP_B=<B>

      I-> Login (CSG,NSG=0,1 T=1)
          SRP_M=<M>
```

개시자 인증이 성공하면 대상은 다음을 진행합니다.

```text
      T-> Login (CSG,NSG=0,1 T=1)
          SRP_HM=<H(A | M | K)>
```

여기서 N, g, s, A, B, M 및 H\(A | M | K\)는 \[RFC2945\]에 정의되어 있습니다.

대상 인증에 실패하면 개시자는 연결을 종료합니다. 그렇지 않으면 진행됩니다.

```text
      I-> Login (CSG,NSG=1,0 T=0)
          ... iSCSI parameters

      T-> Login (CSG,NSG=1,0 T=0)
          ... iSCSI parameters
```

- 그리고 마지막에는:

```text
      I-> Login (CSG,NSG=1,3 T=1)
          optional iSCSI parameters

      T-> Login (CSG,NSG=1,3 T=1) "login accept"
```

개시자 인증이 실패하면 대상은 다음과 같이 응답합니다.

```text
      T-> Login "login reject"
```

T-\> Login SRP\_HM=<H\(A | M | K\)\> 메시지 대신 연결을 종료합니다.

다음 예에서는 개시자만 SRP를 통해 대상에 의해 인증됩니다.

```text
      I-> Login (CSG,NSG=0,1 T=1)
          InitiatorName=iqn.1999-07.com.os:hostid.77
          TargetName=iqn.1999-07.com.example:diskarray.sn.88
          AuthMethod=KRB5,SRP,None

      T-> Login-PR (CSG,NSG=0,0 T=0)
          AuthMethod=SRP

      I-> Login (CSG,NSG=0,0 T=0)
          SRP_U=<user>
          TargetAuth=No

      T-> Login (CSG,NSG=0,0 T=0)
          SRP_N=<N>
          SRP_g=<g>
          SRP_s=<s>

      I-> Login (CSG,NSG=0,0 T=0)
          SRP_A=<A>

      T-> Login (CSG,NSG=0,0 T=0)
          SRP_B=<B>

      I-> Login (CSG,NSG=0,1 T=1)
           SRP_M=<M>
```

개시자 인증이 성공하면 대상은 다음을 진행합니다.

```text
      T-> Login (CSG,NSG=0,1 T=1)

      I-> Login (CSG,NSG=1,0 T=0)
          ... iSCSI parameters

      T-> Login (CSG,NSG=1,0 T=0)
          ... iSCSI parameters
```

- 그리고 마지막에는:

```text
      I-> Login (CSG,NSG=1,3 T=1)
          optional iSCSI parameters

      T-> Login (CSG,NSG=1,3 T=1) "login accept"
```

다음 예에서는 개시자와 대상이 CHAP를 통해 서로를 인증합니다.

```text
      I-> Login (CSG,NSG=0,0 T=0)
          InitiatorName=iqn.1999-07.com.os:hostid.77
          TargetName=iqn.1999-07.com.example:diskarray.sn.88
          AuthMethod=KRB5,CHAP,None

      T-> Login-PR (CSG,NSG=0,0 T=0)
          AuthMethod=CHAP

      I-> Login (CSG,NSG=0,0 T=0)
          CHAP_A=<A1,A2>

      T-> Login (CSG,NSG=0,0 T=0)
          CHAP_A=<A1>
          CHAP_I=<I>
          CHAP_C=<C>

      I-> Login (CSG,NSG=0,1 T=1)
          CHAP_N=<N>
          CHAP_R=<R>
          CHAP_I=<I>
          CHAP_C=<C>
```

개시자 인증이 성공하면 대상은 다음을 진행합니다.

```text
      T-> Login (CSG,NSG=0,1 T=1)
          CHAP_N=<N>
          CHAP_R=<R>
```

대상 인증이 성공하지 못하면 개시자는 연결을 중단합니다. 그렇지 않으면 진행됩니다.

```text
      I-> Login (CSG,NSG=1,0 T=0)
          ... iSCSI parameters

      T-> Login (CSG,NSG=1,0 T=0)
          ... iSCSI parameters
```

- 그리고 마지막에는:

```text
      I-> Login (CSG,NSG=1,3 T=1)
          optional iSCSI parameters

      T-> Login (CSG,NSG=1,3 T=1) "login accept"
```

개시자 인증이 실패하면 대상은 다음과 같이 응답합니다.

```text
      T-> Login "login reject"
```

Login CHAP\_R=<response\> "진행 및 변경 단계" 메시지 대신 연결을 종료합니다.

다음 예에서는 CHAP를 통해 대상에서 개시자만 인증됩니다.

```text
      I-> Login (CSG,NSG=0,1 T=0)
          InitiatorName=iqn.1999-07.com.os:hostid.77
          TargetName=iqn.1999-07.com.example:diskarray.sn.88
          AuthMethod=KRB5,CHAP,None

      T-> Login-PR (CSG,NSG=0,0 T=0)
          AuthMethod=CHAP

      I-> Login (CSG,NSG=0,0 T=0)
          CHAP_A=<A1,A2>

      T-> Login (CSG,NSG=0,0 T=0)
          CHAP_A=<A1>
          CHAP_I=<I>
          CHAP_C=<C>

      I-> Login (CSG,NSG=0,1 T=1)
          CHAP_N=<N>
          CHAP_R=<R>
```

개시자 인증이 성공하면 대상은 다음을 진행합니다.

```text
      T-> Login (CSG,NSG=0,1 T=1)

      I-> Login (CSG,NSG=1,0 T=0)
          ... iSCSI parameters

      T-> Login (CSG,NSG=1,0 T=0)
          ... iSCSI parameters
```

- 그리고 마지막에는:

```text
      I-> Login (CSG,NSG=1,3 T=1)
          optional iSCSI parameters

      T-> Login (CSG,NSG=1,3 T=1) "login accept"
```

다음 예에서는 개시자가 보안 매개변수를 제공하지 않습니다. 따라서 T 비트가 1로 설정된 로그인 PDU에 iSCSI 매개변수를 제공할 수 있으며 대상은 최종 로그인 응답 PDU로 즉시 응답할 수 있습니다.

```text
      I-> Login (CSG,NSG=1,3 T=1)
          InitiatorName=iqn.1999-07.com.os:hostid.77
          TargetName=iqn.1999-07.com.example:diskarray.sn.88
          ... iSCSI parameters

      T-> Login (CSG,NSG=1,3 T=1) "login accept"
          ... ISCSI parameters
```

다음 예에서는 개시자가 로그인 PDU에 보안 매개변수를 제공하지만 대상은 아무 것도 선택하지 않습니다\(즉, "없음" 값을 선택함\).

```text
      I-> Login (CSG,NSG=0,1 T=1)
          InitiatorName=iqn.1999-07.com.os:hostid.77
          TargetName=iqn.1999-07.com.example:diskarray.sn.88
          AuthMethod=KRB5,SRP,None

      T-> Login-PR (CSG,NSG=0,1 T=1)
          AuthMethod=None

      I-> Login (CSG,NSG=1,0 T=0)
          ... iSCSI parameters

      T-> Login (CSG,NSG=1,0 T=0)
          ... iSCSI parameters
```

- 그리고 마지막에는:

```text
      I-> Login (CSG,NSG=1,3 T=1)
          optional iSCSI parameters

      T-> Login (CSG,NSG=1,3 T=1) "login accept"
```

---
# **Appendix C.  SendTargets Operation**

이 부록의 텍스트는 이 문서의 규범적인 부분입니다.

개시자에 필요한 구성 양을 줄이기 위해 iSCSI는 SendTargets 텍스트 요청을 제공합니다. 개시자는 SendTargets 요청을 사용하여 액세스할 수 있는 대상 목록과 이러한 대상에 액세스할 수 있는 주소 목록\(IP 주소 및 TCP 포트\)을 가져옵니다.

SendTargets을 사용하려면 개시자는 먼저 두 가지 유형의 세션 중 하나를 설정해야 합니다. 개시자가 "SessionType=Discovery" 키를 사용하여 세션을 설정하는 경우 세션은 검색 세션이므로 대상 이름을 지정할 필요가 없습니다. 그렇지 않으면 세션은 일반 작동 세션입니다. SendTargets 명령은 일반 또는 검색 세션의 전체 기능 단계 중에만 전송되어야 합니다.\(MUST\)

대상을 포함하는 시스템은 각 iSCSI IP 주소-포트 쌍에서 검색 세션을 지원해야 하며 검색 세션에서 SendTargets 명령을 지원해야 합니다. 검색 세션에서 대상은 요청 개시자가 액세스 권한을 부여받은 대상 네트워크 엔터티의 대상에 대한 모든 경로 정보\(IP 주소-포트 쌍 및 대상 포털 그룹 태그\)를 반환해야 합니다.\(MUST, MUST\)

대상은 운영 세션에서 SendTargets 명령을 지원해야 합니다. 이는 세션이 연결된 대상에 대한 경로 정보만 반환하며 응답 시스템에 정의될 수 있는 다른 대상 이름에 대한 정보는 반환할 필요가 없습니다.\(MUST\)

개시자는 적절하다고 판단되는 대로 SendTargets 명령을 사용할 수 있습니다.\(MAY\)

SendTargets 명령은 단일 텍스트 요청 PDU로 구성됩니다. 이 PDU에는 정확히 하나의 텍스트 키와 값이 포함되어 있습니다. 텍스트 키는 SendTargets이어야 합니다. 예상되는 응답은 값과 세션이 검색 세션인지 운영 세션인지에 따라 달라집니다.\(MUST\)

값은 다음 중 하나여야 합니다.

```text
      All
```

- 개시자는 구현에 알려진 모든 관련 대상에 대한 정보가 반환되도록 요청합니다. 이 값은 검색 세션에서 지원되어야 하며 운영 세션에서는 지원되어서는 안 됩니다.\(MUST NOT\)

```text
      <iSCSI-target-name>
```

- iSCSI 대상 이름이 지정된 경우 세션은 가능하면 명명된 대상에 대해서만 주소로 응답해야 합니다. 이 값은 Discovery 세션에서 지원되어야 합니다. Discovery 세션은 value=All이 지정된 경우 반환되었을 대상에 대한 주소를 반환할 수 있어야 합니다.\(MUST, MUST\)

```text
      <nothing>
```

- 세션은 세션이 로그인된 대상에 대한 주소로만 응답해야 합니다. 이는 운영 세션에서 지원되어야 하며 세션이 로그인된 대상 이외의 대상을 반환해서는 안 됩니다.\(MUST NOT\)

이 명령에 대한 응답은 0개 이상의 대상 목록과 선택적으로 해당 주소를 포함하는 텍스트 응답입니다. 각 대상은 대상 레코드로 반환됩니다. 대상 레코드는 TargetName 텍스트 키로 시작하고 그 뒤에 TargetAddress 텍스트 키 목록이 오고 새 레코드를 시작하는 텍스트 응답 또는 다음 TargetName 키의 끝으로 제한됩니다. SendTargets 응답에는 TargetName 및 TargetAddress 이외의 텍스트 키가 허용되지 않습니다.

TargetName의 형식은 섹션 13.4를 참조하세요.

Discovery 세션은 전체 대상 목록 또는 세션에 로그인한 개시자의 이름을 기반으로 하는 대상 목록을 사용하여 SendTargets 요청에 응답할 수 있습니다.\(MAY\)

요청 개시자가 액세스할 대상이 없는 경우 SendTargets 응답에는 대상 이름이 포함되어서는 안 됩니다.\(MUST NOT\)

반환된 각 대상 레코드에는 0개 이상의 TargetAddress 필드가 포함되어 있습니다.

각 대상 레코드는 다음 형식의 하나의 텍스트 키로 시작됩니다.

```text
      TargetName=<target-name-goes-here>
```

그 뒤에는 다음 형식의 0개 이상의 주소 키가 옵니다.

```text
   TargetAddress=<hostname-or-ipaddress>[:<tcp-port>],
      <portal-group-tag>
```

호스트 이름 또는 ipaddress에는 TargetAddress 키에 지정된 대로 도메인 이름, IPv4 주소 또는 IPv6 주소\(\[RFC4291\]\)가 포함됩니다.

특정 노드\(포트가 없거나 같음\)에 대한 TargetAddress 응답에 중복된 호스트 이름 또는 ipaddress는 여러 주소 계열이 동시에 사용 중임을 나타낼 수 있습니다\(IPv6 및 IPv4\).

각 TargetAddress는 숫자로 된 대상 포털 그룹 태그\(섹션 13.9 참조\)로 식별되는 포털 그룹에 속합니다. iSCSI 대상 이름은 이 태그와 함께 SCSI 포트 식별자를 구성합니다. 태그는 지정된 대상의 주소 이름 목록 내에서만 고유해야 합니다.

다중 연결 세션은 동일한 포털 그룹에 속하는 iSCSI 주소에 걸쳐 있을 수 있습니다.

다중 연결 세션은 다른 포털 그룹에 속하는 iSCSI 주소로 확장될 수 없습니다.

SendTargets 응답이 대상에 대한 iSCSI 주소를 보고하는 경우 동일한 응답에서 포털 그룹의 다른 모든 주소도 보고해야 합니다.\(SHOULD\)

SendTargets 텍스트 응답은 단일 텍스트 응답 PDU보다 길 수 있으며 지정된 대로 긴 텍스트 응답을 사용합니다.

검색 세션에서 대상 목록을 얻은 후 iSCSI 초기자는 전체 작업을 위해 검색된 대상에 로그인하기 위해 새 세션을 시작할 수 있습니다. 개시자는 Discovery 세션을 열어두고 후속 SendTargets 명령을 보내 새로운 대상을 발견할 수 있습니다.\(MAY\)

```text
   Examples:
```

이 예는 다른 인터페이스 포트가 없는 단일 대상의 SendTargets 응답입니다.

개시자는 다음을 포함하는 텍스트 요청을 보냅니다.

```text
      SendTargets=All
```

대상은 다음을 포함하는 텍스트 응답을 보냅니다.

```text
      TargetName=iqn.1993-11.com.example:diskarray.sn.8675309
```

이 간단한 경우에 반환해야 하는 모든 대상은 대상 이름뿐이었습니다. 개시자는 이 대상의 IP 주소와 TCP 포트가 기본 iSCSI 대상에 대한 현재 연결에 사용되는 것과 동일하다고 가정합니다.

다음 예에는 두 개의 내부 iSCSI 대상이 있으며, 각각은 서로 다른 IP 주소를 가진 두 개의 서로 다른 포트를 통해 액세스할 수 있습니다. 다음은 텍스트 응답입니다.

```text
      TargetName=iqn.1993-11.com.example:diskarray.sn.8675309

      TargetAddress=10.1.0.45:3000,1

      TargetAddress=10.1.1.45:3000,2

      TargetName=iqn.1993-11.com.example:diskarray.sn.1234567

      TargetAddress=10.1.0.45:3000,1

      TargetAddress=10.1.1.45:3000,2
```

두 대상 모두 두 주소를 모두 공유합니다. 다중 주소는 다중 경로 지원을 제공하는 데 사용될 가능성이 높습니다. 개시자는 두 주소 중 하나의 대상 이름에 연결할 수 있습니다. 각 주소에는 자체 대상 포털 그룹 태그가 있습니다. 서로의 다중 연결 세션 확장을 지원하지 않습니다. 두 개의 명명된 대상에 대한 대상 포털 그룹 태그는 서로 독립적이라는 점을 명심하십시오. 첫 번째 대상의 포털 그룹 "1"은 두 번째 대상의 포털 그룹 "1"과 반드시 ​​동일할 필요는 없습니다.

위의 예에서는 IPv4 주소 대신 DNS 호스트 이름이나 IPv6 주소가 반환되었을 수 있습니다.

다음 텍스트 응답은 여러 주소에 걸쳐 세션 확장을 지원하는 대상을 보여주고 대상 포털 그룹 태그의 사용을 자세히 보여줍니다.

```text
      TargetName=iqn.1993-11.com.example:diskarray.sn.8675309

      TargetAddress=10.1.0.45:3000,1

      TargetAddress=10.1.1.46:3000,1

      TargetAddress=10.1.0.47:3000,2

      TargetAddress=10.1.1.48:3000,2

      TargetAddress=10.1.1.49:3000,3
```

이 예에서는 모든 대상 주소를 사용하여 동일한 대상에 도달할 수 있습니다. 단일 연결 세션은 이러한 TCP 주소 중 하나로 설정될 수 있습니다. 다중 연결 세션은 주소 .45와 .46 또는 .47과 .48에 걸쳐 있을 수 있지만 다른 조합에는 걸쳐 있을 수 없습니다. 자체 태그\(.49\)가 있는 TargetAddress는 동일한 세션 내의 다른 주소와 결합될 수 없습니다.

이 SendTargets 응답은 .49가 세션당 여러 연결을 지원하는지 여부를 나타내지 않습니다. 이는 대상에 로그인할 때 MaxConnections 텍스트 키를 통해 전달됩니다.

---
# **Appendix D.  Algorithmic Presentation of Error Recovery Classes**

이 부록에서는 의사 프로그래밍 언어를 사용하는 오류 복구 클래스를 보여줍니다. 프로시저 이름은 대부분의 구현자에게 명확하게 선택됩니다. 설명된 각 복구 클래스에는 개시자 프로시저와 대상 프로시저가 있습니다. 이러한 알고리즘은 오류 복구 클래스의 메커니즘을 간략하게 설명하는 데 중점을 두고 있으며 다른 모든 측면/사례를 철저하게 설명하지는 않습니다. 이 접근 방식의 예는 다음과 같습니다.

- - 특정 Opcode 유형에 대한 처리만 표시됩니다.

- - 특정 이유 코드\(예: 로그아웃 시 복구 명령\)만 설명됩니다.

- - 헤더 다이제스트 오류에 대한 동기화 복구와 같은 결과 사례는 이러한 알고리즘의 범위를 벗어난 것으로 간주됩니다. 이 특정 예에서 일부 유형의 동기화 및 조정 계층이 구현되지 않은 경우 헤더 다이제스트 오류로 인해 연결이 복구될 수 있습니다.

이러한 알고리즘은 가장 간단한 용어로 iSCSI 오류 복구 개념을 전달하려고 노력하며 최적으로 설계되지 않았습니다.

---
### **D.1.  General Data Structure and Procedure Description**

이 섹션에서는 모든 오류 복구 알고리즘에서 일반적으로 사용되는 절차와 데이터 구조를 정의합니다. 구조는 일반적인 구현에 필요한 사항을 철저하게 표현하지 못할 수도 있습니다.

```text
   Data structure definitions:

   struct TransferContext {
           int TargetTransferTag;
           int ExpectedDataSN;
   };

   struct TCB {              /* task control block */
           Boolean SoFarInOrder;
           int ExpectedDataSN; /* used for both R2Ts and Data */
           int MissingDataSNList[MaxMissingDPDU];
           Boolean FbitReceived;
           Boolean StatusXferd;
           Boolean CurrentlyAllegiant;
           int ActiveR2Ts;
           int Response;
           char *Reason;
           struct TransferContext
                       TransferContextList[MaxOutstandingR2T];
           int InitiatorTaskTag;
           int CmdSN;
           int SNACK_Tag;
   };

   struct Connection {
           struct Session SessionReference;
           Boolean SoFarInOrder;
           int CID;
           int State;
           int CurrentTimeout;
           int ExpectedStatSN;
           int MissingStatSNList[MaxMissingSPDU];
           Boolean PerformConnectionCleanup;
   };

   struct Session {
           int NumConnections;
           int CmdSN;
           int Maxconnections;
           int ErrorRecoveryLevel;
           struct iSCSIEndpoint OtherEndInfo;
           struct Connection ConnectionList[MaxSupportedConns];
   };

   Procedure descriptions:

   Receive-an-In-PDU(transport connection, inbound PDU);
   check-basic-validity(inbound PDU);
   Start-Timer(timeout handler, argument, timeout value);
   Build-And-Send-Reject(transport connection, bad PDU, reason code);
```

---
### **D.2.  Within-command Error Recovery Algorithms**
---
#### **D.2.1.  Procedure Descriptions**

```text
   Recover-Data-if-Possible(last required DataSN, task control block);
   Build-And-Send-DSnack(task control block);
   Build-And-Send-RDSnack(task control block);
   Build-And-Send-Abort(task control block);
   SCSI-Task-Completion(task control block);
   Build-And-Send-A-Data-Burst(transport connection, data-descriptor,
      task control block);
   Build-And-Send-R2T(transport connection, data-descriptor,
      task control block);
   Build-And-Send-Status(transport connection, task control block);
   Transfer-Context-Timeout-Handler(transfer context);

   Notes:
```

- 이 섹션에서 사용된 절차 중 하나: Handle-Status-SNACK-요청은 부록 D.3에 정의되어 있습니다.

- 대상 알고리즘에 표시된 응답 처리 의사코드는 StatSN\(SCSI 응답, 텍스트 응답 등\)을 전달하는 모든 요청된 PDU에 적용됩니다.

---
#### **D.2.2.  Initiator Algorithms**

```text
   Recover-Data-if-Possible(LastRequiredDataSN, TCB)
   {
       if (operational ErrorRecoveryLevel > 0) {
            if (# of missing PDUs is trackable) {
                  Note the missing DataSNs in TCB.
                  if (the task spanned a change in
                             MaxRecvDataSegmentLength) {
                       if (TCB.StatusXferd is TRUE)
                           drop the status PDU;
                       Build-And-Send-RDSnack(TCB);
                  } else {
                       Build-And-Send-DSnack(TCB);
                  }

            } else {
                TCB.Reason = "Protocol Service CRC error";
                     }
       } else {
             TCB.Reason = "Protocol Service CRC error";
       }
       if (TCB.Reason == "Protocol Service CRC error") {
             Clear the missing PDU list in the TCB.
             if (TCB.StatusXferd is not TRUE)
                Build-And-Send-Abort(TCB);
       }
   }

   Receive-an-In-PDU(Connection, CurrentPDU)
   {
    check-basic-validity(CurrentPDU);
    if (Header-Digest-Bad) discard, return;
    Retrieve TCB for CurrentPDU.InitiatorTaskTag.
    if ((CurrentPDU.type == Data)
                or (CurrentPDU.type = R2T)) {
       if (Data-Digest-Bad for Data) {
                 send-data-SNACK = TRUE;
         LastRequiredDataSN = CurrentPDU.DataSN;
               } else {
             if (TCB.SoFarInOrder = TRUE) {
                 if (current DataSN is expected) {
                      Increment TCB.ExpectedDataSN.
                 } else {
                         TCB.SoFarInOrder = FALSE;
                         send-data-SNACK = TRUE;
                        }

             } else {
                     if (current DataSN was considered missing) {
                        remove current DataSN from missing PDU list.
                    } else if (current DataSN is higher than expected) {
                                send-data-SNACK = TRUE;
                         } else {
                               discard, return;
                         }
                         Adjust TCB.ExpectedDataSN if appropriate.
                }
                LastRequiredDataSN = CurrentPDU.DataSN - 1;
                  }
                  if (send-data-SNACK is TRUE and
                    task is not already considered failed) {
                Recover-Data-if-Possible(LastRequiredDataSN, TCB);
       }
               if (missing data PDU list is empty) {
                  TCB.SoFarInOrder = TRUE;
               }
       if (CurrentPDU.type == R2T) {
          Increment ActiveR2Ts for this task.
          Create a data-descriptor for the data burst.
          Build-And-Send-A-Data-Burst(Connection, data-descriptor, TCB);
        }
     } else if (CurrentPDU.type == Response) {
        if (Data-Digest-Bad) {
                   send-status-SNACK = TRUE;
                } else {
           TCB.StatusXferd = TRUE;
           Store the status information in TCB.
           if (ExpDataSN does not match) {
                TCB.SoFarInOrder = FALSE;
                Recover-Data-if-Possible(current DataSN, TCB);
           }
                   if (missing data PDU list is empty) {
                        TCB.SoFarInOrder = TRUE;
                   }
        }
     } else { /* REST UNRELATED TO WITHIN-COMMAND-RECOVERY, NOT SHOWN */
     }
     if ((TCB.SoFarInOrder == TRUE) and
                           (TCB.StatusXferd == TRUE)) {
             SCSI-Task-Completion(TCB);
      }
   }
```

---
#### **D.2.3.  Target Algorithms**

```text
   Receive-an-In-PDU(Connection, CurrentPDU)
   {
     check-basic-validity(CurrentPDU);
     if (Header-Digest-Bad) discard, return;
     Retrieve TCB for CurrentPDU.InitiatorTaskTag.
     if (CurrentPDU.type == Data) {
         Retrieve TContext from CurrentPDU.TargetTransferTag;
         if (Data-Digest-Bad) {
                     Build-And-Send-Reject(Connection, CurrentPDU,
                                  Payload-Digest-Error);
            Note the missing data PDUs in MissingDataRange[].
                     send-recovery-R2T = TRUE;
                  } else {
            if (current DataSN is not expected) {
                Note the missing data PDUs in MissingDataRange[].
                         send-recovery-R2T = TRUE;
                     }
            if (CurrentPDU.Fbit == TRUE) {
                if (current PDU is solicited) {
                        Decrement TCB.ActiveR2Ts.
                }
                if ((current PDU is unsolicited and
                        data received is less than I/O length and
                          data received is less than FirstBurstLength)
                     or (current PDU is solicited and the length of
                          this burst is less than expected)) {
                     send-recovery-R2T = TRUE;
                     Note the missing data in MissingDataRange[].
                }
                     }
                  }
                  Increment TContext.ExpectedDataSN.
         if (send-recovery-R2T is TRUE and
                   task is not already considered failed) {
            if (operational ErrorRecoveryLevel > 0) {
                Increment TCB.ActiveR2Ts.
                Create a data-descriptor for the data burst
                           from MissingDataRange.
                Build-And-Send-R2T(Connection, data-descriptor, TCB);
            } else {
                 if (current PDU is the last unsolicited)
                     TCB.Reason = "Not enough unsolicited data";
                 else
                     TCB.Reason = "Protocol Service CRC error";
            }
         }

         if (TCB.ActiveR2Ts == 0) {
            Build-And-Send-Status(Connection, TCB);
         }
     } else if (CurrentPDU.type == SNACK) {
         snack-failure = FALSE;
         if (operational ErrorRecoveryLevel > 0) {
            if (CurrentPDU.type == Data/R2T) {
                if (the request is satisfiable) {
                   if (request for Data) {
                      Create a data-descriptor for the data burst
                          from BegRun and RunLength.
                      Build-And-Send-A-Data-Burst(Connection,
                         data-descriptor, TCB);
                   } else { /* R2T */
                      Create a data-descriptor for the data burst
                          from BegRun and RunLength.
                      Build-And-Send-R2T(Connection, data-descriptor,
                         TCB);
                    }
                 } else {
                       snack-failure = TRUE;
                 }
            } else if (CurrentPDU.type == status) {
                 Handle-Status-SNACK-request(Connection, CurrentPDU);
            } else if (CurrentPDU.type == DataACK) {
                   Consider all data up to CurrentPDU.BegRun as
                   acknowledged.
                   Free up the retransmission resources for that data.
              } else if (CurrentPDU.type == R-Data SNACK) {
                            Create a data descriptor for a data burst
                            covering all unacknowledged data.
                  Build-And-Send-A-Data-Burst(Connection,
                     data-descriptor, TCB);
                  TCB.SNACK_Tag = CurrentPDU.SNACK_Tag;
                  if (there's no more data to send) {
                     Build-And-Send-Status(Connection, TCB);
                  }
            }
         } else { /* operational ErrorRecoveryLevel = 0 */
                  snack-failure = TRUE;
         }
         if (snack-failure == TRUE) {
              Build-And-Send-Reject(Connection, CurrentPDU,
                  SNACK-Reject);
              if (TCB.StatusXferd != TRUE) {
                  TCB.Reason = "SNACK rejected";
                  Build-And-Send-Status(Connection, TCB);
              }

         }

     } else { /* REST UNRELATED TO WITHIN-COMMAND-RECOVERY, NOT SHOWN */
     }
   }

   Transfer-Context-Timeout-Handler(TContext)
   {
     Retrieve TCB and Connection from TContext.
     Decrement TCB.ActiveR2Ts.
     if (operational ErrorRecoveryLevel > 0 and
                   task is not already considered failed) {
         Note the missing data PDUs in MissingDataRange[].
         Create a data-descriptor for the data burst
                           from MissingDataRange[].
         Build-And-Send-R2T(Connection, data-descriptor, TCB);

       } else {
           TCB.Reason = "Protocol Service CRC error";
           if (TCB.ActiveR2Ts = 0) {
              Build-And-Send-Status(Connection, TCB);
           }
       }
   }
```

---
### **D.3.  Within-connection Recovery Algorithms**
---
#### **D.3.1.  Procedure Descriptions**

```text
   Procedure descriptions:

   Recover-Status-if-Possible(transport connection,
      currently received PDU);
   Evaluate-a-StatSN(transport connection, currently received PDU);
   Retransmit-Command-if-Possible(transport connection, CmdSN);
   Build-And-Send-SSnack(transport connection);
   Build-And-Send-Command(transport connection,
      task control block);
   Command-Acknowledge-Timeout-Handler(task control block);
   Status-Expect-Timeout-Handler(transport connection);
   Build-And-Send-NOP-Out(transport connection);
   Handle-Status-SNACK-request(transport connection,
      Status SNACK PDU);
   Retransmit-Status-Burst(Status SNACK, task control block);
   Is-Acknowledged(beginning StatSN, run length);
```

조정 가능한 구현별 매개변수:

```text
   InitiatorProactiveSNACKEnabled

   Notes:
```

- 개시자 알고리즘은 Status SNACK을 생성하기 위해 원치 않는 NOP-In PDU만 처리합니다. 요청된 NOP-In PDU에는 순서가 잘못된 경우 명령 내 알고리즘에서 잘못된 순서의 StatSN 처리를 트리거하여 다시 Recover-Status-if-Possible로 이어질 수 있는 할당된 StatSN이 있습니다.

- 표시된 의사코드로 인해 필요한 것보다 더 많은 경우 승인되지 않은 명령이 재전송될 수 있습니다. 그러나 대상이 중복된 CmdSN을 삭제해야 하므로 작업의 정확성에는 영향을 미치지 않습니다.

- Build-And-Send-Async 절차는 연결 복구 알고리즘에 정의되어 있습니다.

- Status-Expect-Timeout-Handler 절차는 개시자가 선택한 경우 상태 검색을 사전에 시도할 수 있는 방법을 설명합니다. 이 절차는 표준 ULP 시간 초과보다 훨씬 전에 트리거되는 것으로 가정됩니다.

---
#### **D.3.2.  Initiator Algorithms**

```text
     Recover-Status-if-Possible(Connection, CurrentPDU)
     {
         if ((Connection.state == LOGGED_IN) and
                     connection is not already considered failed) {
            if (operational ErrorRecoveryLevel > 0) {
               if (# of missing PDUs is trackable) {
                     Note the missing StatSNs in Connection
                     that were not already requested with SNACK;
                 Build-And-Send-SSnack(Connection);
                       } else {
                         Connection.PerformConnectionCleanup = TRUE;
               }
            } else {
                       Connection.PerformConnectionCleanup = TRUE;
            }
            if (Connection.PerformConnectionCleanup == TRUE) {
               Start-Timer(Connection-Cleanup-Handler, Connection, 0);
                     }
         }

     }

     Retransmit-Command-if-Possible(Connection, CmdSN)
     {
         if (operational ErrorRecoveryLevel > 0) {
            Retrieve the InitiatorTaskTag, and thus TCB for the CmdSN.
            Build-And-Send-Command(Connection, TCB);
         }
     }

     Evaluate-a-StatSN(Connection, CurrentPDU)
     {
         send-status-SNACK = FALSE;
         if (Connection.SoFarInOrder == TRUE) {
            if (current StatSN is the expected) {
                 Increment Connection.ExpectedStatSN.
            } else {
                          Connection.SoFarInOrder = FALSE;
                          send-status-SNACK = TRUE;
                     }
         } else {
            if (current StatSN was considered missing) {
                 remove current StatSN from the missing list.
            } else {
                          if (current StatSN is higher than expected){
                              send-status-SNACK = TRUE;
                          } else {
                              send-status-SNACK = FALSE;
                      discard the PDU;
                 }
            }
            Adjust Connection.ExpectedStatSN if appropriate.
            if (missing StatSN list is empty) {
                 Connection.SoFarInOrder = TRUE;
                     }
         }
         return send-status-SNACK;
     }

     Receive-an-In-PDU(Connection, CurrentPDU)
     {
         check-basic-validity(CurrentPDU);
         if (Header-Digest-Bad) discard, return;
         Retrieve TCB for CurrentPDU.InitiatorTaskTag.
         if (CurrentPDU.type == NOP-In) {
               if (the PDU is unsolicited) {
                     if (current StatSN is not expected) {
                          Recover-Status-if-Possible(Connection,
                                       CurrentPDU);
                     }

                     if (current ExpCmdSN is not Session.CmdSN) {
                          Retransmit-Command-if-Possible(Connection,
                                       CurrentPDU.ExpCmdSN);
                     }
               }
         } else if (CurrentPDU.type == Reject) {
               if (it is a data digest error on immediate data) {
                     Retransmit-Command-if-Possible(Connection,
                                       CurrentPDU.BadPDUHeader.CmdSN);
               }
         } else if (CurrentPDU.type == Response) {
              send-status-SNACK = Evaluate-a-StatSN(Connection,
                                             CurrentPDU);
              if (send-status-SNACK == TRUE)
                  Recover-Status-if-Possible(Connection, CurrentPDU);
         } else { /* REST UNRELATED TO WITHIN-CONNECTION-RECOVERY,
                   * NOT SHOWN */
         }
     }

     Command-Acknowledge-Timeout-Handler(TCB)
     {
         Retrieve the Connection for TCB.
         Retransmit-Command-if-Possible(Connection, TCB.CmdSN);
     }

     Status-Expect-Timeout-Handler(Connection)
     {

         if (operational ErrorRecoveryLevel > 0) {
             Build-And-Send-NOP-Out(Connection);
         } else if (InitiatorProactiveSNACKEnabled){
             if ((Connection.state == LOGGED_IN) and
                          connection is not already considered failed) {
                  Build-And-Send-SSnack(Connection);
             }
         }
     }
```

---
#### **D.3.3.  Target Algorithms**

```text
   Handle-Status-SNACK-request(Connection, CurrentPDU)
     {
         if (operational ErrorRecoveryLevel > 0) {
            if (request for an acknowledged run) {
                Build-And-Send-Reject(Connection, CurrentPDU,
                                              Protocol-Error);
            } else if (request for an untransmitted run) {
                discard, return;
            } else {
                Retransmit-Status-Burst(CurrentPDU, TCB);
            }
         } else {
            Build-And-Send-Async(Connection, DroppedConnection,
                                  DefaultTime2Wait, DefaultTime2Retain);
         }
     }
```

---
### **D.4.  Connection Recovery Algorithms**
---
#### **D.4.1.  Procedure Descriptions**

```text
   Build-And-Send-Async(transport connection, reason code,
      minimum time, maximum time);
   Pick-A-Logged-In-Connection(session);
   Build-And-Send-Logout(transport connection,
      logout connection identifier, reason code);
   PerformImplicitLogout(transport connection,
      logout connection identifier, target information);
   PerformLogin(transport connection, target information);
   CreateNewTransportConnection(target information);
   Build-And-Send-Command(transport connection, task control block);
   Connection-Cleanup-Handler(transport connection);
   Connection-Resource-Timeout-Handler(transport connection);
   Quiesce-And-Prepare-for-New-Allegiance(session, task control block);
   Build-And-Send-Logout-Response(transport connection,
      CID of connection in recovery, reason code);
   Build-And-Send-TaskMgmt-Response(transport connection,
      task mgmt command PDU, response code);
   Establish-New-Allegiance(task control block, transport connection);
   Schedule-Command-To-Continue(task control block);

   Note:
```

- 연결이 전체 기능 단계에 있는 동안 예기치 않은 연결 종료, 연결 재설정, 연결 중단과 같은 전송 예외 조건은 모두 Transport\_Exception\_Handler 프로시저를 사용하여 iSCSI 계층에 비동기식으로 신호를 보내는 것으로 가정됩니다.

---
#### **D.4.2.  Initiator Algorithms**

```text
     Receive-an-In-PDU(Connection, CurrentPDU)
     {
         check-basic-validity(CurrentPDU);
         if (Header-Digest-Bad) discard, return;
         Retrieve TCB from CurrentPDU.InitiatorTaskTag.
         if (CurrentPDU.type == Async) {
             if (CurrentPDU.AsyncEvent == ConnectionDropped) {
                Retrieve the AffectedConnection for
                   CurrentPDU.Parameter1.
                AffectedConnection.CurrentTimeout =
                   CurrentPDU.Parameter3;
               AffectedConnection.State = CLEANUP_WAIT;
               Start-Timer(Connection-Cleanup-Handler,
                            AffectedConnection, CurrentPDU.Parameter2);
             } else if (CurrentPDU.AsyncEvent == LogoutRequest)) {
               AffectedConnection = Connection;
               AffectedConnection.State = LOGOUT_REQUESTED;
               AffectedConnection.PerformConnectionCleanup = TRUE;
                        AffectedConnection.CurrentTimeout =
                           CurrentPDU.Parameter3;
               Start-Timer(Connection-Cleanup-Handler,
                             AffectedConnection, 0);
             } else if (CurrentPDU.AsyncEvent == SessionDropped)) {
               for (each Connection) {
                   Connection.State = CLEANUP_WAIT;
                   Connection.CurrentTimeout = CurrentPDU.Parameter3;
                   Start-Timer(Connection-Cleanup-Handler,
                             Connection, CurrentPDU.Parameter2);
               }
               Session.state = FAILED;
             }

         } else if (CurrentPDU.type == LogoutResponse) {
             Retrieve the CleanupConnection for CurrentPDU.CID.
             if (CurrentPDU.Response = failure) {
                CleanupConnection.State = CLEANUP_WAIT;

             } else {
                 CleanupConnection.State = FREE;
             }
         } else if (CurrentPDU.type == LoginResponse) {
              if (this is a response to an implicit Logout) {
                 Retrieve the CleanupConnection.
                 if (successful) {
                     CleanupConnection.State = FREE;
                     Connection.State = LOGGED_IN;
                 } else {
                      CleanupConnection.State = CLEANUP_WAIT;
                      DestroyTransportConnection(Connection);
                 }
              }
         } else { /* REST UNRELATED TO CONNECTION-RECOVERY,
                   * NOT SHOWN */
         }
         if (CleanupConnection.State == FREE) {
            for (each command that was active on CleanupConnection) {
            /* Establish new connection allegiance */
                 NewConnection = Pick-A-Logged-In-Connection(Session);
                 Build-And-Send-Command(NewConnection, TCB);
             }
         }
     }

     Connection-Cleanup-Handler(Connection)
     {
         Retrieve Session from Connection.
         if (Connection can still exchange iSCSI PDUs) {
             NewConnection = Connection;
         } else {
             Start-Timer(Connection-Resource-Timeout-Handler,
                   Connection, Connection.CurrentTimeout);
             if (there are other logged-in connections) {
                  NewConnection = Pick-A-Logged-In-Connection(Session);
             } else {
                  NewConnection =
                     CreateTransportConnection(Session.OtherEndInfo);
                  Initiate an implicit Logout on NewConnection for
                     Connection.CID.
                  return;
             }
         }
         Build-And-Send-Logout(NewConnection, Connection.CID,
                                             RecoveryRemove);
     }

     Transport_Exception_Handler(Connection)
     {
         Connection.PerformConnectionCleanup = TRUE;
         if (the event is an unexpected transport disconnect) {
             Connection.State = CLEANUP_WAIT;
             Connection.CurrentTimeout = DefaultTime2Retain;
             Start-Timer(Connection-Cleanup-Handler, Connection,
                            DefaultTime2Wait);
         } else {
             Connection.State = FREE;
         }
     }
```

---
#### **D.4.3.  Target Algorithms**

```text
     Receive-an-In-PDU(Connection, CurrentPDU)
     {
         check-basic-validity(CurrentPDU);
         if (Header-Digest-Bad) discard, return;
         else if (Data-Digest-Bad) {
                   Build-And-Send-Reject(Connection, CurrentPDU,
                                            Payload-Digest-Error);
                   discard, return;
         }
         Retrieve TCB and Session.
         if (CurrentPDU.type == Logout) {
            if (CurrentPDU.ReasonCode = RecoveryRemove) {
                Retrieve the CleanupConnection from CurrentPDU.CID).
                for (each command active on CleanupConnection) {
                     Quiesce-And-Prepare-for-New-Allegiance(Session,
                        TCB);
                     TCB.CurrentlyAllegiant = FALSE;
                }
                Cleanup-Connection-State(CleanupConnection);
                if ((quiescing successful) and (cleanup successful))
     {
                     Build-And-Send-Logout-Response(Connection,
                                       CleanupConnection.CID, Success);
                } else {
                     Build-And-Send-Logout-Response(Connection,
                                       CleanupConnection.CID, Failure);
                }

             }

         } else if ((CurrentPDU.type == Login) and
                              operational ErrorRecoveryLevel == 2) {
                 Retrieve the CleanupConnection from CurrentPDU.CID).
                 for (each command active on CleanupConnection) {
                       Quiesce-And-Prepare-for-New-Allegiance(Session,
                          TCB);
                       TCB.CurrentlyAllegiant = FALSE;
                 }
                 Cleanup-Connection-State(CleanupConnection);
                 if ((quiescing successful) and (cleanup successful))
     {
                       Continue with the rest of the login processing;
                 } else {
                       Build-And-Send-Login-Response(Connection,
                                  CleanupConnection.CID, Target Error);
                 }
             }
         } else if (CurrentPDU.type == TaskManagement) {
               if (CurrentPDU.function == "TaskReassign") {
                     if (Session.ErrorRecoveryLevel < 2) {
                         Build-And-Send-TaskMgmt-Response(Connection,
                            CurrentPDU,
                               "Task allegiance reassignment not
                                                   supported");
                     } else if (task is not found) {
                         Build-And-Send-TaskMgmt-Response(Connection,
                            CurrentPDU, "Task not in task set");
                     } else if (task is currently allegiant) {
                         Build-And-Send-TaskMgmt-Response(Connection,
                            CurrentPDU, "Task still allegiant");
                     } else {
                         Establish-New-Allegiance(TCB, Connection);
                         TCB.CurrentlyAllegiant = TRUE;
                         Schedule-Command-To-Continue(TCB);
                     }
               }
         } else { /* REST UNRELATED TO CONNECTION-RECOVERY,
                   * NOT SHOWN */
         }

     }

     Transport_Exception_Handler(Connection)
     {
         Connection.PerformConnectionCleanup = TRUE;
         if (the event is an unexpected transport disconnect) {
             Connection.State = CLEANUP_WAIT;
              Start-Timer(Connection-Resource-Timeout-Handler,
                 Connection, (DefaultTime2Wait+DefaultTime2Retain));
               if (this Session has Full Feature Phase connections
                     left) {
                   DifferentConnection =
                      Pick-A-Logged-In-Connection(Session);
                    Build-And-Send-Async(DifferentConnection,
                          DroppedConnection, DefaultTime2Wait,
                            DefaultTime2Retain);
             }
         } else {
               Connection.State = FREE;
         }
     }
```

---
# **Appendix E.  Clearing Effects of Various Events on Targets**
---
### **E.1.  Clearing Effects on iSCSI Objects**

다음 표에서는 표 행에 지정된 이벤트 수신 시 대상 동작을 설명합니다. 두 번째 테이블은 첫 번째 테이블의 확장이며 동일한 이벤트에서 더 많은 개체에 대한 지우기 작업을 정의합니다. 전설은 다음과 같습니다

Y = 예\(행에 지정된 이벤트에 대해 지워짐/폐기됨/재설정됨\) 별도로 명시하지 않는 한, 청산 작업은 발행 개시자 포트에만 적용됩니다.

N = 아니요\(행에 지정된 이벤트에 영향을 받지 않음, 즉 이전 값을 유지함\)

NA = 해당 사항 없음 또는 정의되지 않음.

```text
                            +------+------+------+------+------+
                            |IT (1)|IC (2)|CT (5)|ST (6)|PP (7)|
     +----------------------+------+------+------+------+------+
     |connection failure (8)|Y     |Y     |N     |N     |Y     |
     +----------------------+------+------+------+------+------+
     |connection state      |NA    |NA    |Y     |N     |NA    |
     |timeout (9)           |      |      |      |      |      |
     +----------------------+------+------+------+------+------+
     |session timeout/      |Y     |Y     |Y     |Y     |Y (14)|
     |closure/reinstatement |      |      |      |      |      |
     |(10)                  |      |      |      |      |      |
     +----------------------+------+------+------+------+------+
     |session continuation  |NA    |NA    |N (11)|N     |NA    |
     |(12)                  |      |      |      |      |      |
     +----------------------+------+------+------+------+------+
     |successful connection |Y     |Y     |Y     |N     |Y (13)|
     |close logout          |      |      |      |      |      |
     +----------------------+------+------+------+------+------+
     |session failure (18)  |Y     |Y     |N     |N     |Y     |
     +----------------------+------+------+------+------+------+
     |successful recovery   |Y     |Y     |N     |N     |Y (13)|
     |Logout                |      |      |      |      |      |
     +----------------------+------+------+------+------+------+
     |failed Logout         |Y     |Y     |N     |N     |Y     |
     +----------------------+------+------+------+------+------+
     |connection Login      |NA    |NA    |NA    |Y (15)|NA    |
     |(leading)             |      |      |      |      |      |
     +----------------------+------+------+------+------+------+
     |connection Login      |NA    |NA    |N (11)|N     |Y     |
     |(non-leading)         |      |      |      |      |      |
     +----------------------+------+------+------+------+------+
     |TARGET COLD RESET (16)|Y (20)|Y     |Y     |Y     |Y     |
     +----------------------+------+------+------+------+------+
     |TARGET WARM RESET (16)|Y (20)|Y     |Y     |Y     |Y     |
     +----------------------+------+------+------+------+------+
     |LU reset (19)         |Y (20)|Y     |Y     |Y     |Y     |
     +----------------------+------+------+------+------+------+
     |power cycle (16)      |Y     |Y     |Y     |Y     |Y     |
     +----------------------+------+------+------+------+------+
```

\(1\) 불완전한 TTT\(IT\)는 대상이 여전히 PDU 수신을 기대하는 대상 전송 태그입니다. 예로는 R2T, NOP-In 등을 통해 수신된 TTT가 있습니다.

\(2\) 즉시 명령\(IC\)은 즉시 명령이지만 대상에서 실행을 기다리고 있습니다\(예: ABORT TASK SET\).

\(5\) 연결 작업\(CT\)은 해당 iSCSI 연결에서 활성화되는 작업입니다.

\(6\) 세션 작업\(ST\)은 전체 iSCSI 세션에서 활성화되는 작업입니다. 참여하는 모든 연결에 대한 "연결 작업"의 통합입니다.

\(7\) 부분 PDU\(PP\)\(있는 경우\)는 부분적으로 전송되고 전송 창 크레딧이 전송을 완료할 때까지 기다리는 PDU입니다.

\(8\) 연결 실패는 연결 예외 조건입니다. 전송 연결 중 하나가 종료되거나, 전송 연결이 재설정되거나, 전송 연결 시간이 초과되어 iSCSI 전체 기능 단계 연결이 갑자기 종료되었습니다. 연결 실패는 항상 연결 상태 머신을 CLEANUP\_WAIT 상태로 만듭니다.

\(9\) 연결 상태 타임아웃은 CLEANUP\_WAIT 상태에서 로그인 협상 중에 연결이 합의된 시간보다 더 많은 시간을 소비하는 경우 발생하며, 이로 인해 연결은 FREE 상태로 전환됩니다\(연결 정리 상태 다이어그램의 M1 전환, 섹션 8.2 참조\).

\(10\) 세션 시간 초과, 종료 및 복원은 섹션 6.3.5에 정의되어 있습니다.

\(11\) 이 제거 효과는 연결 복원이고 작동 ErrorRecoveryLevel이 2보다 작은 경우에만 "Y"입니다.

\(12\) 세션 연속은 섹션 6.3.6에 정의되어 있습니다.

\(13\) 이 제거 효과는 해당 연결이 다른 연결에서 로그아웃되고 있고 대상에서 로그아웃 중인 연결에 전송 대기 중인 일부 부분 PDU가 있을 경우에만 유효합니다. 다른 모든 경우에는 효과가 "NA"입니다.

\(14\) 이 지우기 효과는 다중 연결 세션에서 "세션 종료" 로그아웃에만 유효합니다. 다른 모든 경우에는 효과가 "NA"입니다.

\(15\) 이 주요 연결 로그인이 세션 복원인 경우에만 적용 가능합니다. 그렇지 않은 경우에는 "NA"입니다.

\(16\) 이 작업은 로그인된 모든 개시자에게 영향을 미칩니다.

\(18\) 세션 실패는 6.3.6절에 정의되어 있습니다.

\(19\) 이 작업은 로그인된 모든 개시자에게 영향을 미치며, 지우기 효과는 재설정 중인 LU에만 적용됩니다.

\(20\) 표준 다중 작업 중단 의미\(섹션 4.2.3.3\)를 사용하면 TARGET WARM RESET, TARGET COLD RESET 또는 LU 재설정이 완료 시 활성 TTT를 지웁니다. 그러나 섹션 4.2.3.4에 정의된 FastAbort 다중 작업 중단 의미 체계는 재설정 작업이 끝날 때 활성 TTT가 지워지는 것을 보장하지 않습니다. 실제로 FastAbort 의미론은 TMF 응답이 전달된 후 "게으른" 방식으로 TTT를 지울 수 있도록 설계되었습니다. 따라서 TaskReporting=FastAbort\(섹션 13.23\)가 세션에서 작동하는 경우 "불완전한 TTT"에 대한 재설정 작업의 지우기 효과는 "N"입니다.

```text
                           +------+-------+------+------+-------+
                           |DC (1)|DD (2) |SS (3)|CS (4)|DS (5) |
     +---------------------+------+-------+------+------+-------+
     |connection failure   |N     |Y      |N     |N     |N      |
     +---------------------+------+-------+------+------+-------+
     |connection state     |Y     |NA     |Y     |N     |NA     |
     |timeout              |      |       |      |      |       |
     +---------------------+------+-------+------+------+-------+
     |session timeout/     |Y     |Y      |Y (7) |Y     |NA     |
     |closure/reinstatement|      |       |      |      |       |
     +---------------------+------+-------+------+------+-------+
     |session continuation |N (11)|NA (12)|NA    |N     |NA (13)|
     +---------------------+------+-------+------+------+-------+
     |successful connection|Y     |Y      |Y     |N     |NA     |
     |close Logout         |      |       |      |      |       |
     +---------------------+------+-------+------+------+-------+
     |session failure      |N     |Y      |N     |N     |N      |
     +---------------------+------+-------+------+------+-------+
     |successful recovery  |Y     |Y      |Y     |N     |N      |
     |Logout               |      |       |      |      |       |
     +---------------------+------+-------+------+------+-------+
     |failed Logout        |N     |Y (9)  |N     |N     |N      |
     +---------------------+------+-------+------+------+-------+
     |connection Login     |NA    |NA     |N (8) |N (8) |NA     |
     |(leading             |      |       |      |      |       |
     +---------------------+------+-------+------+------+-------+
     |connection Login     |N (11)|NA (12)|N (8) |N     |NA (13)|
     |(non-leading)        |      |       |      |      |       |
     +---------------------+------+-------+------+------+-------+
     |TARGET COLD RESET    |Y     |Y      |Y     |Y (10)|NA     |
     +---------------------+------+-------+------+------+-------+
     |TARGET WARM RESET    |Y     |Y      |N     |N     |NA     |
     +---------------------+------+-------+------+------+-------+
     |LU reset             |N     |Y      |N     |N     |N      |
     +---------------------+------+-------+------+------+-------+
     |power cycle          |Y     |Y      |Y     |Y (10)|NA     |
     +---------------------+------+-------+------+------+-------+
```

\(1\) 불연속 명령\(DC\)은 문제의 연결에 부합하고 iSCSI 계층에서 재정렬되기를 기다리는 명령입니다. 이 열의 모든 "Y"는 이벤트를 발생시키는 작업\(실제로 이벤트가 작업의 결과인 경우\)이 즉각적인 명령으로 실행된다고 가정합니다. 왜냐하면 불일치가 작업보다 앞서 있을 수 있기 때문입니다.

\(2\) 불연속 데이터\(DD\)는 문제의 작업에 대해 수신되었으며 DataSN의 이전 불연속으로 인해 재정렬을 기다리는 데이터 PDU입니다.

\(3\) "SS"는 StatSN을 나타냅니다.

\(4\) "CS"는 CmdSN을 나타냅니다.

\(5\) "DS"는 DataSN을 의미합니다.

\(7\) 이 작업을 수행하면 모든 연결에서 StatSN이 지워집니다.

\(8\) 이 시퀀스 번호는 이 이벤트에서 인스턴스화됩니다.

\(9\) 로그아웃 실패는 연결 실패 이벤트와 유사하게 연결 상태 머신을 CLEANUP\_WAIT 상태로 만듭니다. 따라서 이는 이것과 다른 여러 프로토콜 측면에 유사한 영향을 미칩니다.

\(10\) 이는 모든 개시자와의 모든 세션이 종료된다는 사실로 인해 해결됩니다.

\(11\) 이 제거 효과는 연결인 경우 "Y"입니다.

- 복직.

\(12\) 이 제거 효과는 연결 복원이고 작동 ErrorRecoveryLevel이 2인 경우에만 "Y"입니다.

\(13\) 이 제거 효과는 연결 복원이고 작동 ErrorRecoveryLevel이 2인 경우에만 "N"입니다.

---
### **E.2.  Clearing Effects on SCSI Objects**

SCSI 개체에 대한 지우기 작업에 영향을 줄 수 있는 유일한 iSCSI 프로토콜 작업은 "I\_T 넥서스 손실" 알림입니다\(섹션 6.3.5.1\("Nexus 손실 알림"\)\). \[SPC3\]에서는 다양한 SCSI 속성에 대한 이 알림의 제거 효과를 설명합니다. 또한 SCSI 표준 문서\(예: \[SAM2\] 및 \[SBC2\]\)에서는 LU 재설정 및 전원 켜기 재설정과 같은 SCSI 이벤트 시 여러 SCSI 개체에 대해 발생할 수 있는 추가 지우기 작업을 정의합니다.

iSCSI는 TARGET COLD RESET을 대상 전원 주기에 대한 "프로토콜과 동등한" 것으로 정의하므로 SCSI 표준에 정의된 작업을 해석할 때 iSCSI TARGET COLD RESET도 전원 켜기 재설정 이벤트로 간주되어야 합니다.

동일한 I\_T 넥서스를 재설정하여 iSCSI 세션이 재구성되면\(동일한 넥서스 식별자를 가진 동일한 SCSI 포트 사이에서\) 영구 예약과 같은 "I\_T 넥서스 손실" 알림 이벤트에서 지워지지 않도록 정의된 모든 SCSI 개체가 자동으로 이 새 세션과 연결됩니다.

---
# **Acknowledgments**

원래 IPS 작업 그룹의 여러 개인은 원래 RFC 3720, 3980, 4850 및 5048에 상당한 기여를 했습니다.

구체적으로, 단일 문서로 통합된 원본 RFC의 작성자는 다음과 같습니다.

```text
      RFC 3720: Julian Satran, Kalman Meth, Costa Sapuntzakis,
      Mallikarjun Chadalapaka, Efri Zeidner

      RFC 3980: Marjorie Krueger, Mallikarjun Chadalapaka, Rob Elliott

      RFC 4850: David Wysochanski

      RFC 5048: Mallikarjun Chadalapaka
```

이 문서의 UML 표기법과 그림에 기여한 Fred Knight에게 많은 감사를 드립니다.

또한 이 개정 문서에 기여한 David Harrington, Paul Koning, Mark Edwards, Rob Elliott 및 Martin Stiemerling에게도 감사를 표하고 싶습니다.

Kerberos 관련 보안 고려 사항 텍스트를 제안 및/또는 검토해 주신 Yi Zeng 및 Nico Williams에게 감사드립니다.

저자들은 라스트 콜 검토 과정에서 여러 개인이 보내주신 소중한 피드백에 감사드립니다. 그들의 피드백은 이 문서를 크게 향상시켰습니다. 개인은 Stephen Farrell, Brian Haberman, Barry Leiba, Pete Resnick, Sean Turner, Alexey Melnikov, Kathleen Moriarty, Fred Knight, Mike Christie, Qiang Wang, Shiv Rajpal 및 Andy Banta였습니다.

마지막으로, 이 문서는 Storm Working Group의 상당한 검토 기여로부터 큰 도움을 받았습니다.

의견은 Mallikarjun Chadalapaka에게 보내질 수 있습니다.

---
# **Authors' Addresses**

```text
   Mallikarjun Chadalapaka
   Microsoft
   One Microsoft Way
   Redmond, WA  98052
   USA

   EMail: cbm@chadalapaka.com

   Julian Satran
   Infinidat Ltd.

   EMail: julians@infinidat.com, julian@satran.net

   Kalman Meth
   IBM Haifa Research Lab
   Haifa University Campus - Mount Carmel
   Haifa 31905, Israel

   Phone +972.4.829.6341
   EMail: meth@il.ibm.com

   David L. Black
   EMC Corporation
   176 South St.
   Hopkinton, MA  01748
   USA

   Phone +1 (508) 293-7953
   EMail: david.black@emc.com
```
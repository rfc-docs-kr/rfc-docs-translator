

```text
Internet Engineering Task Force (IETF)                       E. Rescorla
Request for Comments: 8446                                       Mozilla
Obsoletes: 5077, 5246, 6961                                  August 2018
Updates: 5705, 6066
Category: Standards Track
ISSN: 2070-1721

        The Transport Layer Security (TLS) Protocol Version 1.3
```

---
# **Abstract**

이 문서에서는 TLS\(Transport Layer Security\) 프로토콜 버전 1.3을 지정합니다. TLS를 사용하면 클라이언트/서버 애플리케이션이 도청, 변조 및 메시지 위조를 방지하도록 설계된 방식으로 인터넷을 통해 통신할 수 있습니다.

이 문서는 RFC 5705 및 6066을 업데이트하고 RFC 5077, 5246 및 6961을 폐기합니다. 또한 이 문서는 TLS 1.2 구현에 대한 새로운 요구 사항을 지정합니다.

---
# **Status of This Memo**

이것은 인터넷 표준 추적 문서입니다.

이 문서는 IETF\(Internet Engineering Task Force\)의 산물입니다. 이는 IETF 커뮤니티의 합의를 나타냅니다. 공개 검토를 받았으며 IESG\(Internet Engineering Steering Group\)의 게시 승인을 받았습니다. 인터넷 표준에 대한 추가 정보는 RFC 7841의 섹션 2에서 확인할 수 있습니다.

이 문서의 현재 상태, 정오표, 피드백 제공 방법에 대한 정보는 https://www.rfc-editor.org/info/rfc8446에서 얻을 수 있습니다.

---
# **Copyright Notice**

Copyright \(c\) 2018 IETF Trust 및 문서 작성자로 식별된 사람. 판권 소유.

이 문서에는 이 문서 발행일에 유효한 BCP 78 및 IETF 문서와 관련된 IETF Trust의 법적 조항\(https://trustee.ietf.org/license-info\)이 적용됩니다. 이 문서에 관한 귀하의 권리와 제한 사항이 설명되어 있으므로 이 문서를 주의 깊게 검토하십시오. 이 문서에서 추출된 코드 구성 요소는 신뢰 법률 조항의 섹션 4.e에 설명된 대로 단순화된 BSD 라이센스 텍스트를 포함해야 하며 단순화된 BSD 라이센스에 설명된 대로 보증 없이 제공됩니다.

이 문서에는 2008년 11월 10일 이전에 공개되거나 공개된 IETF 문서 또는 IETF 기여의 자료가 포함될 수 있습니다. 이 자료 중 일부의 저작권을 관리하는 사람은 IETF Trust에 해당 자료의 수정을 허용할 권한을 부여하지 않았을 수 있습니다. IETF 표준 프로세스 외부. 해당 자료의 저작권을 관리하는 사람으로부터 적절한 라이센스를 얻지 않은 경우 이 문서는 IETF 표준 프로세스 외부에서 수정될 수 없으며 해당 문서의 파생물은 형식을 지정하는 경우를 제외하고 IETF 표준 프로세스 외부에서 생성될 수 없습니다. RFC로 출판하거나 영어 이외의 언어로 번역합니다.

---
# **Table of Contents**

```text
   1. Introduction ....................................................6
      1.1. Conventions and Terminology ................................7
      1.2. Major Differences from TLS 1.2 .............................8
      1.3. Updates Affecting TLS 1.2 ..................................9
   2. Protocol Overview ..............................................10
      2.1. Incorrect DHE Share .......................................14
      2.2. Resumption and Pre-Shared Key (PSK) .......................15
      2.3. 0-RTT Data ................................................17
   3. Presentation Language ..........................................19
      3.1. Basic Block Size ..........................................19
      3.2. Miscellaneous .............................................20
      3.3. Numbers ...................................................20
      3.4. Vectors ...................................................20
      3.5. Enumerateds ...............................................21
      3.6. Constructed Types .........................................22
      3.7. Constants .................................................23
      3.8. Variants ..................................................23
   4. Handshake Protocol .............................................24
      4.1. Key Exchange Messages .....................................25
           4.1.1. Cryptographic Negotiation ..........................26
           4.1.2. Client Hello .......................................27
           4.1.3. Server Hello .......................................31
           4.1.4. Hello Retry Request ................................33
      4.2. Extensions ................................................35
           4.2.1. Supported Versions .................................39
           4.2.2. Cookie .............................................40
           4.2.3. Signature Algorithms ...............................41
           4.2.4. Certificate Authorities ............................45
           4.2.5. OID Filters ........................................45
           4.2.6. Post-Handshake Client Authentication ...............47
           4.2.7. Supported Groups ...................................47
           4.2.8. Key Share ..........................................48
           4.2.9. Pre-Shared Key Exchange Modes ......................51
           4.2.10. Early Data Indication .............................52
           4.2.11. Pre-Shared Key Extension ..........................55
      4.3. Server Parameters .........................................59
           4.3.1. Encrypted Extensions ...............................60
           4.3.2. Certificate Request ................................60
      4.4. Authentication Messages ...................................61
           4.4.1. The Transcript Hash ................................63
           4.4.2. Certificate ........................................64
           4.4.3. Certificate Verify .................................69
           4.4.4. Finished ...........................................71
      4.5. End of Early Data .........................................72
      4.6. Post-Handshake Messages ...................................73
           4.6.1. New Session Ticket Message .........................73
           4.6.2. Post-Handshake Authentication ......................75
           4.6.3. Key and Initialization Vector Update ...............76
   5. Record Protocol ................................................77
      5.1. Record Layer ..............................................78
      5.2. Record Payload Protection .................................80
      5.3. Per-Record Nonce ..........................................82
      5.4. Record Padding ............................................83
      5.5. Limits on Key Usage .......................................84
   6. Alert Protocol .................................................85
      6.1. Closure Alerts ............................................87
      6.2. Error Alerts ..............................................88
   7. Cryptographic Computations .....................................90
      7.1. Key Schedule ..............................................91
      7.2. Updating Traffic Secrets ..................................94
      7.3. Traffic Key Calculation ...................................95
      7.4. (EC)DHE Shared Secret Calculation .........................95
           7.4.1. Finite Field Diffie-Hellman ........................95
           7.4.2. Elliptic Curve Diffie-Hellman ......................96
      7.5. Exporters .................................................97
   8. 0-RTT and Anti-Replay ..........................................98
      8.1. Single-Use Tickets ........................................99
      8.2. Client Hello Recording ....................................99
      8.3. Freshness Checks .........................................101
   9. Compliance Requirements .......................................102
      9.1. Mandatory-to-Implement Cipher Suites .....................102
      9.2. Mandatory-to-Implement Extensions ........................103
      9.3. Protocol Invariants ......................................104
   10. Security Considerations ......................................106
   11. IANA Considerations ..........................................106
   12. References ...................................................109
      12.1. Normative References ....................................109
      12.2. Informative References ..................................112
   Appendix A. State Machine ........................................120
     A.1. Client ....................................................120
     A.2. Server ....................................................121
   Appendix B. Protocol Data Structures and Constant Values .........122
     B.1. Record Layer ..............................................122
     B.2. Alert Messages ............................................123
     B.3. Handshake Protocol ........................................124
       B.3.1. Key Exchange Messages .................................125
       B.3.2. Server Parameters Messages ............................131
       B.3.3. Authentication Messages ...............................132
       B.3.4. Ticket Establishment ..................................132
       B.3.5. Updating Keys .........................................133
     B.4. Cipher Suites .............................................133
   Appendix C. Implementation Notes .................................134
     C.1. Random Number Generation and Seeding ......................134
     C.2. Certificates and Authentication ...........................135
     C.3. Implementation Pitfalls ...................................135
     C.4. Client Tracking Prevention ................................137
     C.5. Unauthenticated Operation .................................137
   Appendix D. Backward Compatibility ...............................138
     D.1. Negotiating with an Older Server ..........................139
     D.2. Negotiating with an Older Client ..........................139
     D.3. 0-RTT Backward Compatibility ..............................140
     D.4. Middlebox Compatibility Mode ..............................140
     D.5. Security Restrictions Related to Backward Compatibility ...141
   Appendix E. Overview of Security Properties ......................142
     E.1. Handshake .................................................142
       E.1.1. Key Derivation and HKDF ...............................145
       E.1.2. Client Authentication .................................146
       E.1.3. 0-RTT .................................................146
       E.1.4. Exporter Independence .................................146
       E.1.5. Post-Compromise Security ..............................146
       E.1.6. External References ...................................147
     E.2. Record Layer ..............................................147
       E.2.1. External References ...................................148
     E.3. Traffic Analysis ..........................................148
     E.4. Side-Channel Attacks ......................................149
     E.5. Replay Attacks on 0-RTT ...................................150
       E.5.1. Replay and Exporters ..................................151
     E.6. PSK Identity Exposure .....................................152
     E.7. Sharing PSKs ..............................................152
     E.8. Attacks on Static RSA .....................................152
   Contributors .....................................................153
   Author's Address .................................................160
```

---
## **1.  Introduction**

TLS의 주요 목표는 두 통신 피어 간에 보안 채널을 제공하는 것입니다. 기본 전송의 유일한 요구 사항은 신뢰할 수 있는 순서대로 데이터 스트림입니다. 특히 보안 채널은 다음 속성을 제공해야 합니다.

- 인증: 채널의 서버 측이 항상 인증됩니다. 클라이언트 측은 선택적으로 인증됩니다. 인증은 비대칭 암호화\(예: RSA \[RSA\], 타원 곡선 디지털 서명 알고리즘\(ECDSA\) \[ECDSA\] 또는 Edwards-Curve 디지털 서명 알고리즘\(EdDSA\) \[RFC8032\]\) 또는 대칭 사전 공유 키\( PSK\).

- 기밀성: 설정 후 채널을 통해 전송된 데이터는 엔드포인트에서만 볼 수 있습니다. TLS는 전송하는 데이터의 길이를 숨기지 않습니다. 하지만 엔드포인트는 길이를 모호하게 하고 트래픽 분석 기술에 대한 보호를 강화하기 위해 TLS 레코드를 채울 수 있습니다.

- 무결성: 설정 후 채널을 통해 전송된 데이터는 탐지 없이 공격자에 의해 수정될 수 없습니다.

이러한 속성은 \[RFC3552\]에 설명된 대로 네트워크를 완전히 제어할 수 있는 공격자가 있는 경우에도 적용됩니다. 관련 보안 속성에 대한 보다 완전한 설명은 부록 E를 참조하십시오.

TLS는 두 가지 기본 구성 요소로 구성됩니다.

- 통신 당사자를 인증하고, 암호화 모드 및 매개변수를 협상하고, 공유 키 자료를 설정하는 핸드셰이크 프로토콜\(섹션 4\). 핸드셰이크 프로토콜은 변조를 방지하도록 설계되었습니다. 적극적인 공격자는 연결이 공격을 받지 않는 경우와 다른 매개변수를 협상하도록 피어에게 강요할 수 없어야 합니다.

- 통신 피어 간의 트래픽을 보호하기 위해 핸드셰이크 프로토콜에 의해 설정된 매개변수를 사용하는 기록 프로토콜\(섹션 5\). 레코드 프로토콜은 트래픽을 일련의 레코드로 나누고, 각 레코드는 트래픽 키를 사용하여 독립적으로 보호됩니다.

TLS는 애플리케이션 프로토콜에 독립적입니다. 더 높은 수준의 프로토콜은 TLS 위에 투명하게 계층화될 수 있습니다. 그러나 TLS 표준은 프로토콜이 TLS로 보안을 추가하는 방법을 지정하지 않습니다. TLS 핸드셰이킹을 시작하는 방법과 교환된 인증 인증서를 해석하는 방법은 TLS 위에서 실행되는 프로토콜의 설계자와 구현자의 판단에 달려 있습니다.

이 문서는 TLS 버전 1.3을 정의합니다. TLS 1.3은 이전 버전과 직접적으로 호환되지 않지만 모든 TLS 버전에는 클라이언트와 서버가 두 피어 모두에서 지원하는 공통 버전을 상호 운용적으로 협상할 수 있는 버전 관리 메커니즘이 통합되어 있습니다.

이 문서는 버전 1.2 \[RFC5246\]를 포함한 이전 버전의 TLS를 대체하고 더 이상 사용되지 않습니다. 또한 \[RFC5077\]에 정의된 TLS 티켓 메커니즘을 폐기하고 이를 섹션 2.2에 정의된 메커니즘으로 대체합니다. TLS 1.3은 키 파생 방식을 변경하므로 섹션 7.5에 설명된 대로 \[RFC5705\]를 업데이트합니다. 또한 OCSP\(온라인 인증서 상태 프로토콜\) 메시지가 전달되는 방식을 변경하므로 섹션 4.4.2.1에 설명된 대로 \[RFC6066\]을 업데이트하고 \[RFC6961\]을 폐기합니다.

---
### **1.1.  Conventions and Terminology**

핵심 단어 "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY" 및 "OPTIONAL 이 문서의 "는 여기에 표시된 대로 모두 대문자로 표시되는 경우에만 BCP 14 \[RFC2119\] \[RFC8174\]에 설명된 대로 해석됩니다.

다음 용어가 사용됩니다.

클라이언트: TLS 연결을 시작하는 엔드포인트입니다.

연결: 두 끝점 간의 전송 계층 연결입니다.

끝점: 연결의 클라이언트 또는 서버입니다.

핸드셰이크: TLS 내에서 후속 상호 작용의 매개 변수를 설정하는 클라이언트와 서버 간의 초기 협상입니다.

피어: 엔드포인트입니다. 특정 엔드포인트를 논의할 때 "피어"는 주요 논의 주제가 아닌 엔드포인트를 나타냅니다.

수신자: 레코드를 수신하는 엔드포인트입니다.

발신자: 레코드를 전송하는 엔드포인트입니다.

서버: TLS 연결을 시작하지 않은 엔드포인트입니다.

---
### **1.2.  Major Differences from TLS 1.2**

다음은 TLS 1.2와 TLS 1.3의 주요 기능적 차이점 목록입니다. 모든 내용을 완벽하게 설명하려는 의도는 없으며 사소한 차이점이 많이 있습니다.

- 지원되는 대칭 암호화 알고리즘 목록에서 레거시로 간주되는 모든 알고리즘이 제거되었습니다. 남아 있는 것은 모두 AEAD\(Authenticated Encryption with Associated Data\) 알고리즘입니다. 인증 및 키 교환 메커니즘을 기록 보호 알고리즘\(비밀 키 길이 포함\)과 키 파생 기능 및 MAC\(핸드셰이크 메시지 인증 코드\) 모두와 함께 사용되는 해시에서 분리하도록 암호 제품군 개념이 변경되었습니다.

- 특정 보안 속성을 희생하면서 일부 애플리케이션 데이터에 대한 연결 설정 시 왕복 시간을 절약하는 제로 왕복 시간\(0-RTT\) 모드가 추가되었습니다.

- 정적 RSA 및 Diffie-Hellman 암호화 제품군이 제거되었습니다. 이제 모든 공개 키 기반 키 교환 메커니즘은 순방향 비밀성을 제공합니다.

- 이제 ServerHello 이후의 모든 핸드셰이크 메시지가 암호화됩니다. 새로 도입된 EncryptedExtensions 메시지를 사용하면 이전에 ServerHello에서 일반 형식으로 전송된 다양한 확장도 기밀 보호를 누릴 수 있습니다.

- 주요 파생 기능이 재설계되었습니다. 새로운 디자인을 사용하면 향상된 키 분리 속성으로 인해 암호 작성자가 더 쉽게 분석할 수 있습니다. HMAC 기반 HKDF\(추출 및 확장 키 파생 함수\)가 기본 기본 요소로 사용됩니다.

- 핸드셰이크 상태 머신은 보다 일관성을 유지하고 ChangeCipherSpec과 같은 불필요한 메시지를 제거하기 위해 크게 재구성되었습니다\(미들박스 호환성을 위해 필요한 경우 제외\).

- 이제 타원 곡선 알고리즘이 기본 사양에 포함되었으며 EdDSA와 같은 새로운 서명 알고리즘이 포함되었습니다. TLS 1.3에서는 각 곡선에 대한 단일 포인트 형식을 선호하여 포인트 형식 협상을 제거했습니다.

- RSASSA-PSS\(RSA 확률적 서명 체계\)를 사용하도록 RSA 패딩 변경, 압축 제거, DSA\(디지털 서명 알고리즘\) 및 사용자 정의 DHE\(임시 Diffie-Hellman\) 그룹을 포함하여 기타 암호화 개선이 이루어졌습니다.

- 확장의 버전 목록을 위해 TLS 1.2 버전 협상 메커니즘이 더 이상 사용되지 않습니다. 이를 통해 버전 협상을 잘못 구현한 기존 서버와의 호환성이 향상됩니다.

- 이전 TLS 버전의 PSK 기반 암호화 제품군뿐만 아니라 서버 측 상태 유무에 관계없이 세션 재개가 단일 새로운 PSK 교환으로 대체되었습니다.

- RFC의 업데이트된 버전을 적절하게 가리키도록 참조가 업데이트되었습니다\(예: RFC 3280이 아닌 RFC 5280\).

---
### **1.3.  Updates Affecting TLS 1.2**

이 문서는 TLS 1.3도 지원하지 않는 변경 사항을 포함하여 TLS 1.2 구현에 선택적으로 영향을 미치는 몇 가지 변경 사항을 정의합니다.

- 버전 다운그레이드 보호 메커니즘은 섹션 4.1.3에 설명되어 있습니다.

- RSASSA-PSS 서명 체계는 섹션 4.2.3에 정의되어 있습니다.

- "supported\_versions" ClientHello 확장을 사용하면 ClientHello의 Legacy\_version 필드보다 사용할 TLS 버전을 협상할 수 있습니다.

- "signature\_algorithms\_cert" 확장을 사용하면 클라이언트가 X.509 인증서에서 유효성을 검사할 수 있는 서명 알고리즘을 나타낼 수 있습니다.

또한 이 문서에서는 이전 버전의 TLS에 대한 일부 규정 준수 요구 사항을 명확히 설명합니다. 섹션 9.3을 참조하세요.

---
## **2.  Protocol Overview**

보안 채널에서 사용되는 암호화 매개변수는 TLS 핸드셰이크 프로토콜에 의해 생성됩니다. TLS의 이 하위 프로토콜은 클라이언트와 서버가 처음으로 서로 통신할 때 사용됩니다. 핸드셰이크 프로토콜을 사용하면 피어는 프로토콜 버전을 협상하고, 암호화 알고리즘을 선택하고, 선택적으로 서로를 인증하고, 공유 비밀 키 자료를 설정할 수 있습니다. 핸드셰이크가 완료되면 피어는 설정된 키를 사용하여 애플리케이션 계층 트래픽을 보호합니다.

핸드셰이크 실패 또는 기타 프로토콜 오류로 인해 연결이 종료되고 선택적으로 경고 메시지가 표시됩니다\(섹션 6\).

```text
   TLS supports three basic key exchange modes:
```

- \(EC\)DHE\(유한장 또는 타원 곡선에 대한 Diffie-Hellman\)

```text
   -  PSK-only
```

- \(EC\)DHE를 사용한 PSK

아래 그림 1은 기본 전체 TLS 핸드셰이크를 보여줍니다.

```text
       Client                                           Server

Key  ^ ClientHello
Exch | + key_share*
     | + signature_algorithms*
     | + psk_key_exchange_modes*
     v + pre_shared_key*       -------->
                                                  ServerHello  ^ Key
                                                 + key_share*  | Exch
                                            + pre_shared_key*  v
                                        {EncryptedExtensions}  ^  Server
                                        {CertificateRequest*}  v  Params
                                               {Certificate*}  ^
                                         {CertificateVerify*}  | Auth
                                                   {Finished}  v
                               <--------  [Application Data*]
     ^ {Certificate*}
Auth | {CertificateVerify*}
     v {Finished}              -------->
       [Application Data]      <------->  [Application Data]

              +  Indicates noteworthy extensions sent in the
                 previously noted message.

              *  Indicates optional or situation-dependent
                 messages/extensions that are not always sent.

              {} Indicates messages protected using keys
                 derived from a [sender]_handshake_traffic_secret.

              [] Indicates messages protected using keys
                 derived from [sender]_application_traffic_secret_N.

               Figure 1: Message Flow for Full TLS Handshake
```

핸드셰이크는 세 단계로 구성됩니다\(위 다이어그램에 표시됨\).

- 키 교환: 공유 키 자료를 설정하고 암호화 매개변수를 선택합니다. 이 단계 이후의 모든 내용은 암호화됩니다.

- 서버 매개변수: 기타 핸드셰이크 매개변수\(클라이언트 인증 여부, 애플리케이션 계층 프로토콜 지원 등\)를 설정합니다.

- 인증: 서버\(및 선택적으로 클라이언트\)를 인증하고 키 확인 및 핸드셰이크 무결성을 제공합니다.

키 교환 단계에서 클라이언트는 임의의 nonce\(ClientHello.random\)가 포함된 ClientHello\(섹션 4.1.2\) 메시지를 보냅니다. 제공되는 프로토콜 버전 대칭 암호/HKDF 해시 쌍 목록 Diffie-Hellman 키 공유 세트\("key\_share"\(섹션 4.2.8\) 확장\), 사전 공유 키 레이블 세트\("pre\_shared\_key"\(섹션 4.2.11\) 확장\) 또는 둘 다. 잠재적으로 추가 확장이 가능합니다. 미들박스 호환성을 위해 추가 필드 및/또는 메시지가 있을 수도 있습니다.

서버는 ClientHello를 처리하고 연결에 적합한 암호화 매개변수를 결정합니다. 그런 다음 협상된 연결 매개변수를 나타내는 자체 ServerHello\(섹션 4.1.3\)로 응답합니다. ClientHello와 ServerHello의 조합에 따라 공유 키가 결정됩니다. \(EC\)DHE 키 설정이 사용 중인 경우 ServerHello에는 서버의 임시 Diffie-Hellman 공유와 함께 "key\_share" 확장이 포함됩니다. 서버의 공유는 클라이언트의 공유 중 하나와 동일한 그룹에 있어야 합니다. PSK 키 설정이 사용 중인 경우 ServerHello에는 클라이언트가 제공하는 PSK 중 어느 것이 선택되었는지 나타내는 "pre\_shared\_key" 확장이 포함됩니다. 구현에서는 \(EC\)DHE와 PSK를 함께 사용할 수 있으며, 이 경우 두 확장이 모두 제공됩니다.

그런 다음 서버는 서버 매개변수를 설정하기 위해 두 개의 메시지를 보냅니다.

EncryptedExtensions: 개별 인증서에 특정한 매개변수 외에 암호화 매개변수를 결정하는 데 필요하지 않은 ClientHello 확장에 대한 응답입니다. \[4.3.1항\]

CertificateRequest: 인증서 기반 클라이언트 인증이 필요한 경우 해당 인증서에 대해 원하는 매개변수입니다. 클라이언트 인증을 원하지 않는 경우 이 메시지는 생략됩니다. \[4.3.2항\]

마지막으로 클라이언트와 서버는 인증 메시지를 교환합니다. TLS는 인증서 기반 인증이 필요할 때마다 동일한 메시지 세트를 사용합니다. \(PSK 기반 인증은 키 교환의 부작용으로 발생합니다.\) 구체적으로 다음과 같습니다.

인증서: 끝점 및 인증서별 확장의 인증서입니다. 이 메시지는 인증서로 인증하지 않은 경우 서버에 의해 생략되고 서버가 CertificateRequest를 보내지 않은 경우\(따라서 클라이언트가 인증서로 인증해서는 안 됨을 나타냄\) 클라이언트에 의해 생략됩니다. 원시 공개 키 \[RFC7250\] 또는 캐시된 정보 확장 \[RFC7924\]이 사용 중인 경우 이 메시지에는 인증서가 포함되지 않고 서버의 장기 키에 해당하는 다른 값이 포함됩니다. \[4.4.2항\]

CertificateVerify: 인증서 메시지의 공개 키에 해당하는 개인 키를 사용하여 전체 핸드셰이크에 대한 서명입니다. 끝점이 인증서를 통해 인증되지 않는 경우 이 메시지는 생략됩니다. \[4.4.3항\]

완료됨: 전체 핸드셰이크에 대한 MAC\(메시지 인증 코드\)입니다. 이 메시지는 키 확인을 제공하고 끝점의 ID를 교환된 키에 바인딩하며 PSK 모드에서는 핸드셰이크도 인증합니다. \[4.4.4항\]

서버의 메시지를 수신하면 클라이언트는 인증서 및 인증서 확인\(요청된 경우\) 및 완료라는 인증 메시지로 응답합니다.

이 시점에서 핸드셰이크가 완료되고 클라이언트와 서버는 인증된 암호화를 통해 보호되는 애플리케이션 계층 데이터를 교환하기 위해 레코드 계층에 필요한 키 자료를 파생합니다. 섹션 2.3에 지정된 경우를 제외하고는 완료 메시지를 보내기 전에 애플리케이션 데이터를 보내서는 안 됩니다. 서버는 클라이언트의 인증 메시지를 받기 전에 애플리케이션 데이터를 보낼 수 있지만 해당 시점에 전송된 모든 데이터는 물론 인증되지 않은 피어로 전송됩니다.

---
### **2.1.  Incorrect DHE Share**

클라이언트가 충분한 "key\_share" 확장을 제공하지 않은 경우\(예: 서버에서 허용할 수 없거나 지원하지 않는 DHE 또는 ECDHE 그룹만 포함\) 서버는 HelloRetryRequest와의 불일치를 수정하고 클라이언트는 적절한 방법으로 핸드셰이크를 다시 시작해야 합니다. "key\_share" 확장\(그림 2 참조\). 공통 암호화 매개변수를 협상할 수 없는 경우 서버는 적절한 경고와 함께 핸드셰이크를 중단해야 합니다.

```text
        Client                                               Server

        ClientHello
        + key_share             -------->
                                                  HelloRetryRequest
                                <--------               + key_share
        ClientHello
        + key_share             -------->
                                                        ServerHello
                                                        + key_share
                                              {EncryptedExtensions}
                                              {CertificateRequest*}
                                                     {Certificate*}
                                               {CertificateVerify*}
                                                         {Finished}
                                <--------       [Application Data*]
        {Certificate*}
        {CertificateVerify*}
        {Finished}              -------->
        [Application Data]      <------->        [Application Data]

             Figure 2: Message Flow for a Full Handshake with
                           Mismatched Parameters
```

참고: 핸드셰이크 기록에는 초기 ClientHello/HelloRetryRequest 교환이 포함되어 있습니다. 새로운 ClientHello로 재설정되지 않습니다.

또한 TLS는 다음 섹션에 설명된 대로 기본 핸드셰이크의 여러 가지 최적화된 변형을 허용합니다.

---
### **2.2.  Resumption and Pre-Shared Key (PSK)**

TLS PSK는 대역 외에서 설정할 수 있지만 이전 연결에서 PSK를 설정한 다음 새 연결을 설정하는 데 사용할 수도 있습니다\("세션 재개" 또는 PSK를 사용한 "재개"\). 핸드셰이크가 완료되면 서버는 초기 핸드셰이크에서 파생된 고유 키에 해당하는 PSK ID를 클라이언트에 보낼 수 있습니다\(섹션 4.6.1 참조\). 그런 다음 클라이언트는 향후 핸드셰이크에서 해당 PSK ID를 사용하여 연결된 PSK 사용을 협상할 수 있습니다. 서버가 PSK를 수락하면 새 연결의 보안 컨텍스트가 원래 연결에 암호화되어 연결되고 전체 핸드셰이크 대신 초기 핸드셰이크에서 파생된 키가 암호화 상태를 부트스트랩하는 데 사용됩니다. TLS 1.2 이하에서는 이 기능이 "세션 ID" 및 "세션 티켓"\[RFC5077\]을 통해 제공되었습니다. TLS 1.3에서는 두 메커니즘 모두 더 이상 사용되지 않습니다.

PSK는 공유 키와 함께 순방향 비밀성을 제공하기 위해 \(EC\)DHE 키 교환과 함께 사용하거나, 애플리케이션 데이터에 대한 순방향 비밀성을 유지하면서 단독으로 사용할 수 있습니다.

그림 3은 첫 번째 핸드셰이크가 PSK를 설정하고 두 번째 핸드셰이크가 이를 사용하는 한 쌍의 핸드셰이크를 보여줍니다.

```text
          Client                                               Server

   Initial Handshake:
          ClientHello
          + key_share               -------->
                                                          ServerHello
                                                          + key_share
                                                {EncryptedExtensions}
                                                {CertificateRequest*}
                                                       {Certificate*}
                                                 {CertificateVerify*}
                                                           {Finished}
                                    <--------     [Application Data*]
          {Certificate*}
          {CertificateVerify*}
          {Finished}                -------->
                                    <--------      [NewSessionTicket]
          [Application Data]        <------->      [Application Data]

   Subsequent Handshake:
          ClientHello
          + key_share*
          + pre_shared_key          -------->
                                                          ServerHello
                                                     + pre_shared_key
                                                         + key_share*
                                                {EncryptedExtensions}
                                                           {Finished}
                                    <--------     [Application Data*]
          {Finished}                -------->
          [Application Data]        <------->      [Application Data]

               Figure 3: Message Flow for Resumption and PSK
```

서버는 PSK를 통해 인증하므로 인증서 또는 CertificateVerify 메시지를 보내지 않습니다. 클라이언트가 PSK를 통해 재개를 제공하는 경우 서버가 재개를 거부하고 필요한 경우 전체 핸드셰이크로 폴백할 수 있도록 서버에 "key\_share" 확장도 제공해야 합니다\(SHOULD\). 서버는 PSK 키 설정 사용을 협상하기 위해 "pre\_shared\_key" 확장으로 응답하고 \(여기에 표시된 대로\) \(EC\)DHE 키 설정을 수행하기 위해 "key\_share" 확장으로 응답하여 순방향 보안을 제공할 수 있습니다.

PSK가 대역 외 프로비저닝되는 경우 PSK와 함께 사용할 PSK ID 및 KDF 해시 알고리즘도 프로비저닝되어야 합니다.

참고: 대역 외 프로비저닝된 사전 공유 비밀을 사용할 때 중요한 고려 사항은 \[RFC4086\]에 설명된 대로 키 생성 중에 충분한 엔트로피를 사용하는 것입니다. 비밀번호나 기타 낮은 엔트로피 소스에서 공유 비밀을 파생시키는 것은 안전하지 않습니다. 낮은 엔트로피 비밀 또는 비밀번호는 PSK 바인더를 기반으로 하는 사전 공격을 받기 쉽습니다. 지정된 PSK 인증은 Diffie-Hellman 키 설정과 함께 사용되는 경우에도 강력한 비밀번호 기반 인증 키 교환이 아닙니다. 특히, 핸드셰이크를 관찰할 수 있는 공격자가 비밀번호/사전 공유 키에 대해 무차별 대입 공격을 수행하는 것을 막지는 못합니다.

---
### **2.3.  0-RTT Data**

클라이언트와 서버가 PSK\(외부에서 얻거나 이전 핸드셰이크를 통해 얻은\)를 공유하는 경우 TLS 1.3을 사용하면 클라이언트가 첫 번째 비행에서 데이터\("초기 데이터"\)를 보낼 수 있습니다. 클라이언트는 PSK를 사용하여 서버를 인증하고 초기 데이터를 암호화합니다.

그림 4에서 볼 수 있듯이 0-RTT 데이터는 첫 번째 비행에서 1-RTT 핸드셰이크에 추가됩니다. 나머지 핸드셰이크에서는 PSK 재개가 포함된 1-RTT 핸드셰이크와 동일한 메시지를 사용합니다.

```text
         Client                                               Server

         ClientHello
         + early_data
         + key_share*
         + psk_key_exchange_modes
         + pre_shared_key
         (Application Data*)     -------->
                                                         ServerHello
                                                    + pre_shared_key
                                                        + key_share*
                                               {EncryptedExtensions}
                                                       + early_data*
                                                          {Finished}
                                 <--------       [Application Data*]
         (EndOfEarlyData)
         {Finished}              -------->
         [Application Data]      <------->        [Application Data]

               +  Indicates noteworthy extensions sent in the
                  previously noted message.

               *  Indicates optional or situation-dependent
                  messages/extensions that are not always sent.

               () Indicates messages protected using keys
                  derived from a client_early_traffic_secret.

               {} Indicates messages protected using keys
                  derived from a [sender]_handshake_traffic_secret.

               [] Indicates messages protected using keys
                  derived from [sender]_application_traffic_secret_N.

               Figure 4: Message Flow for a 0-RTT Handshake
```

중요 참고 사항: 0-RTT 데이터의 보안 속성은 다른 종류의 TLS 데이터에 대한 보안 속성보다 약합니다. 구체적으로:

1. 이 데이터는 제공된 PSK를 사용하여 파생된 키로만 암호화되므로 순방향 비밀이 아닙니다.

1. 연결 간 재생이 불가능하다는 보장은 없습니다. 일반 TLS 1.3 1-RTT 데이터에 대한 재생 방지는 서버의 Random 값을 통해 제공되지만 0-RTT 데이터는 ServerHello에 의존하지 않으므로 보장이 약합니다. 이는 TLS 클라이언트 인증이나 애플리케이션 프로토콜 내부에서 데이터가 인증되는 경우 특히 중요합니다. early\_exporter\_master\_secret 사용에도 동일한 경고가 적용됩니다.

0-RTT 데이터는 연결 내에서 복제될 수 없으며\(즉, 서버는 동일한 연결에 대해 동일한 데이터를 두 번 처리하지 않습니다\), 공격자는 0-RTT 데이터를 1-RTT 데이터인 것처럼 보이게 만들 수 없습니다\(왜냐하면\). 다른 키로 보호됩니다.\) 부록 E.5에는 잠재적인 공격에 대한 설명이 포함되어 있으며 섹션 8에서는 서버가 재생의 영향을 제한하는 데 사용할 수 있는 메커니즘에 대해 설명합니다.

---
## **3.  Presentation Language**

이 문서는 외부 표현의 데이터 형식을 다룹니다. 다음과 같은 매우 기본적이고 다소 캐주얼하게 정의된 프레젠테이션 구문이 사용됩니다.

---
### **3.1.  Basic Block Size**

모든 데이터 항목의 표현은 명시적으로 지정됩니다. 기본 데이터 블록 크기는 1바이트\(즉, 8비트\)입니다. 다중 바이트 데이터 항목은 왼쪽에서 오른쪽으로, 위에서 아래로 바이트를 연결한 것입니다. 바이트 스트림에서 멀티바이트 항목\(다음 예의 숫자\)은 다음과 같이 구성됩니다\(C 표기법 사용\).

```text
      value = (byte[0] << 8*(n-1)) | (byte[1] << 8*(n-2)) |
              ... | byte[n-1];
```

다중 바이트 값의 바이트 순서는 일반적인 네트워크 바이트 순서 또는 빅엔디안 형식입니다.

---
### **3.2.  Miscellaneous**

주석은 "/\*"로 시작하고 "\*/"로 끝납니다.

선택적 구성 요소는 "\[\[ \]\]"\(이중 괄호\)로 묶어 표시됩니다.

해석되지 않은 데이터를 포함하는 단일 바이트 엔터티는 불투명 유형입니다.

기존 유형 T에 대한 유형 별칭 T'는 다음과 같이 정의됩니다.

```text
      T T';
```

---
### **3.3.  Numbers**

기본 숫자 데이터 유형은 부호 없는 바이트\(uint8\)입니다. 더 큰 모든 숫자 데이터 유형은 섹션 3.1에 설명된 대로 연결된 고정 길이 일련의 바이트로 구성되며 역시 부호가 없습니다. 다음 숫자 유형이 사전 정의되어 있습니다.

```text
      uint8 uint16[2];
      uint8 uint24[3];
      uint8 uint32[4];
      uint8 uint64[8];
```

여기와 사양의 다른 부분에 있는 모든 값은 네트워크 바이트\(빅 엔디안\) 순서로 전송됩니다. 16진수 바이트 01 02 03 04로 표시되는 uint32는 10진수 값 16909060과 동일합니다.

---
### **3.4.  Vectors**

벡터\(단일 차원 배열\)는 동종 데이터 요소의 스트림입니다. 벡터의 크기는 문서화 시 지정되거나 런타임까지 지정되지 않은 채로 남아 있을 수 있습니다. 두 경우 모두 길이는 벡터의 요소 수가 아닌 바이트 수를 선언합니다. T 유형의 고정 길이 벡터인 새로운 유형 T'를 지정하는 구문은 다음과 같습니다.

```text
      T T'[n];
```

여기서 T'는 데이터 스트림에서 n바이트를 차지하며, 여기서 n은 T 크기의 배수입니다. 벡터의 길이는 인코딩된 스트림에 포함되지 않습니다.

다음 예에서 Datum은 프로토콜이 해석하지 않는 3개의 연속 바이트로 정의되는 반면, Data는 3개의 연속 Datum으로 총 9바이트를 사용합니다.

```text
      opaque Datum[3];      /* three uninterpreted bytes */
      Datum Data[9];        /* three consecutive 3-byte vectors */
```

가변 길이 벡터는 <floor..ceiling\> 표기법을 사용하여 유효한 길이의 하위 범위를 지정하여 정의됩니다. 이것이 인코딩되면 실제 길이는 바이트 스트림에서 벡터의 내용보다 앞에 옵니다. 길이는 벡터의 지정된 최대\(천장\) 길이를 유지하는 데 필요한 만큼의 바이트를 소비하는 숫자 형식입니다. 실제 길이 필드가 0인 가변 길이 벡터를 빈 벡터라고 합니다.

```text
      T T'<floor..ceiling>;
```

다음 예에서 "필수"는 불투명 유형의 300\~400바이트를 포함해야 하는 벡터입니다. 결코 비워둘 수 없습니다. 실제 길이 필드는 값 400을 나타내는 데 충분한 uint16이라는 2바이트를 사용합니다\(섹션 3.3 참조\). 마찬가지로 "longer"는 최대 800바이트의 데이터 또는 400개의 uint16 요소를 나타낼 수 있으며 비어 있을 수 있습니다. 해당 인코딩에는 벡터 앞에 추가된 2바이트 실제 길이 필드가 포함됩니다. 인코딩된 벡터의 길이는 단일 요소 길이의 정확한 배수여야 합니다\(예: uint16의 17바이트 벡터는 불법입니다\).

```text
      opaque mandatory<300..400>;
            /* length field is two bytes, cannot be empty */
      uint16 longer<0..800>;
            /* zero to 400 16-bit unsigned integers */
```

---
### **3.5.  Enumerateds**

"enum" 또는 "enumerated"라는 추가적인 희소 데이터 유형을 사용할 수 있습니다. 각 정의는 다른 유형입니다. 동일한 유형의 열거형만 할당하거나 비교할 수 있습니다. 다음 예에 설명된 것처럼 열거형의 모든 요소에는 값이 할당되어야 합니다. 열거된 요소는 순서가 지정되어 있지 않으므로 순서에 관계없이 고유한 값을 할당할 수 있습니다.

```text
      enum { e1(v1), e2(v2), ... , en(vn) [[, (n)]] } Te;
```

향후 프로토콜 확장이나 추가로 새로운 값이 정의될 수 있습니다. 구현에서는 필드 정의에 달리 명시되지 않는 한 알 수 없는 값을 구문 분석하고 무시할 수 있어야 합니다.

열거형은 정의된 최대 서수 값만큼 바이트 스트림에서 많은 공간을 차지합니다. 다음 정의에서는 Color 유형의 필드를 전달하는 데 1바이트가 사용됩니다.

```text
      enum { red(3), blue(5), white(7) } Color;
```

불필요한 요소를 정의하지 않고 너비 정의를 강제하기 위해 선택적으로 관련 태그 없이 값을 지정할 수 있습니다.

다음 예에서 Taste는 데이터 스트림에서 2바이트를 사용하지만 현재 버전의 프로토콜에서는 값 1, 2 또는 4만 가정할 수 있습니다.

```text
      enum { sweet(1), sour(2), bitter(4), (32000) } Taste;
```

열거형 요소의 이름은 정의된 유형 내에서 범위가 지정됩니다. 첫 번째 예에서 열거형의 두 번째 요소에 대한 정규화된 참조는 Color.blue입니다. 과제의 대상이 잘 명시되어 있으면 그러한 자격은 필요하지 않습니다.

```text
      Color color = Color.blue;     /* overspecified, legal */
      Color color = blue;           /* correct, type implicit */
```

열거된 항목에 할당된 이름은 고유할 필요가 없습니다. 숫자 값은 동일한 이름이 적용되는 범위를 설명할 수 있습니다. 값에는 두 개의 마침표 문자로 구분된 해당 범위의 최소 및 최대 포함 값이 포함됩니다. 이는 주로 공간 영역을 예약하는 데 유용합니다.

```text
      enum { sad(0), meh(1..254), happy(255) } Mood;
```

---
### **3.6.  Constructed Types**

편의를 위해 구조 유형은 기본 유형에서 구성될 수 있습니다. 각 사양은 새롭고 고유한 유형을 선언합니다. 정의에 사용되는 구문은 C의 구문과 매우 유사합니다.

```text
      struct {
          T1 f1;
          T2 f2;
          ...
          Tn fn;
      } T;
```

고정 및 가변 길이 벡터 필드는 표준 벡터 구문을 사용하여 허용됩니다. 변형 예제\(섹션 3.8\)의 구조 V1 및 V2가 이를 보여줍니다.

구조 내의 필드는 열거형에 사용할 수 있는 것과 매우 유사한 구문을 사용하여 유형 이름을 사용하여 한정될 수 있습니다. 예를 들어, T.f2는 이전 선언의 두 번째 필드를 나타냅니다.

---
### **3.7.  Constants**

다음과 같이 "="를 사용하여 필드와 변수에 고정 값을 할당할 수 있습니다.

```text
      struct {
          T1 f1 = 8;  /* T.f1 must always be 8 */
          T2 f2;
      } T;
```

---
### **3.8.  Variants**

정의된 구조에는 환경 내에서 사용 가능한 일부 지식을 기반으로 하는 변형이 있을 수 있습니다. 선택기는 구조가 정의하는 가능한 변형을 정의하는 열거형 유형이어야 합니다. 선택 항목\(아래\)의 각 부문은 해당 변형 필드의 유형과 선택적 필드 레이블을 지정합니다. 런타임 시 변형이 선택되는 메커니즘은 표시 언어에 의해 규정되지 않습니다.

```text
      struct {
          T1 f1;
          T2 f2;
          ....
          Tn fn;
          select (E) {
              case e1: Te1 [[fe1]];
              case e2: Te2 [[fe2]];
              ....
              case en: Ten [[fen]];
          };
      } Tv;
```

예를 들어:

```text
      enum { apple(0), orange(1) } VariantTag;

      struct {
          uint16 number;
          opaque string<0..10>; /* variable length */
      } V1;

      struct {
          uint32 number;
          opaque string[10];    /* fixed length */
      } V2;

      struct {
          VariantTag type;
          select (VariantRecord.type) {
              case apple:  V1;
              case orange: V2;
          };
      } VariantRecord;
```

---
## **4.  Handshake Protocol**

핸드셰이크 프로토콜은 연결의 보안 매개변수를 협상하는 데 사용됩니다. 핸드셰이크 메시지는 TLS 레코드 계층에 제공되며, 현재 활성 연결 상태에 지정된 대로 처리 및 전송되는 하나 이상의 TLSPlaintext 또는 TLSCiphertext 구조 내에 캡슐화됩니다.

```text
      enum {
          client_hello(1),
          server_hello(2),
          new_session_ticket(4),
          end_of_early_data(5),
          encrypted_extensions(8),
          certificate(11),
          certificate_request(13),
          certificate_verify(15),
          finished(20),
          key_update(24),
          message_hash(254),
          (255)
      } HandshakeType;

      struct {
          HandshakeType msg_type;    /* handshake type */
          uint24 length;             /* remaining bytes in message */
          select (Handshake.msg_type) {
              case client_hello:          ClientHello;
              case server_hello:          ServerHello;
              case end_of_early_data:     EndOfEarlyData;
              case encrypted_extensions:  EncryptedExtensions;
              case certificate_request:   CertificateRequest;
              case certificate:           Certificate;
              case certificate_verify:    CertificateVerify;
              case finished:              Finished;
              case new_session_ticket:    NewSessionTicket;
              case key_update:            KeyUpdate;
          };
      } Handshake;
```

프로토콜 메시지는 섹션 4.4.1에 정의되고 섹션 2의 다이어그램에 표시된 순서대로 전송되어야 합니다. 예상치 못한 순서로 핸드셰이크 메시지를 수신하는 피어는 "unexpected\_message" 경고와 함께 핸드셰이크를 중단해야 합니다.

새로운 핸드셰이크 메시지 유형은 섹션 11에 설명된 대로 IANA에 의해 할당됩니다.

---
### **4.1.  Key Exchange Messages**

키 교환 메시지는 클라이언트와 서버의 보안 기능을 결정하고 나머지 핸드셰이크와 데이터를 보호하는 데 사용되는 트래픽 키를 포함하여 공유 비밀을 설정하는 데 사용됩니다.

---
#### **4.1.1.  Cryptographic Negotiation**

TLS에서는 ClientHello에서 다음 네 가지 옵션 세트를 제공하는 클라이언트에 의해 암호화 협상이 진행됩니다.

- 클라이언트가 지원하는 AEAD 알고리즘/HKDF 해시 쌍을 나타내는 암호 제품군 목록입니다.

- 클라이언트가 지원하는 \(EC\)DHE 그룹을 나타내는 "supported\_groups"\(섹션 4.2.7\) 확장 및 이러한 그룹 중 일부 또는 전부에 대한 \(EC\)DHE 공유를 포함하는 "key\_share"\(섹션 4.2.8\) 확장 .

- 클라이언트가 수락할 수 있는 서명 알고리즘을 나타내는 "signature\_algorithms"\(섹션 4.2.3\) 확장입니다. 인증서별 서명 알고리즘을 나타내기 위해 "signature\_algorithms\_cert" 확장\(섹션 4.2.3\)을 추가할 수도 있습니다.

- 클라이언트에 알려진 대칭 키 ID 목록을 포함하는 "pre\_shared\_key"\(섹션 4.2.11\) 확장과 PSK와 함께 사용할 수 있는 키 교환 모드를 나타내는 "psk\_key\_exchange\_modes"\(섹션 4.2.9\) 확장.

서버가 PSK를 선택하지 않으면 이러한 옵션 중 처음 세 가지는 완전히 직교합니다. 서버는 키 설정을 위한 암호화 제품군, \(EC\)DHE 그룹 및 키 공유, 인증을 위한 서명 알고리즘/인증서 쌍을 독립적으로 선택합니다. 그 자체를 클라이언트에게. 수신된 "supported\_groups"와 서버가 지원하는 그룹 사이에 중복이 없으면 서버는 "handshake\_failure" 또는 "insufficient\_security" 경고와 함께 핸드셰이크를 중단해야 합니다.

서버가 PSK를 선택하는 경우 클라이언트의 "psk\_key\_exchange\_modes" 확장\(현재는 PSK 단독 또는 \(EC\)DHE와 함께\)에 표시된 세트에서 키 설정 모드도 선택해야 합니다. \(EC\)DHE 없이 PSK를 사용할 수 있는 경우 "supported\_groups" 매개변수의 비중첩이 치명적일 필요는 없습니다. 이는 이전 단락에서 설명한 PSK가 아닌 경우와 같습니다.

서버가 \(EC\)DHE 그룹을 선택하고 클라이언트가 초기 ClientHello에서 호환 가능한 "key\_share" 확장을 제공하지 않은 경우 서버는 HelloRetryRequest\(섹션 4.1.4\) 메시지로 응답해야 합니다.

서버가 매개변수를 성공적으로 선택하고 HelloRetryRequest가 필요하지 않은 경우 다음과 같이 ServerHello에 선택된 매개변수가 표시됩니다.

- PSK를 사용하는 경우 서버는 선택한 키를 나타내는 "pre\_shared\_key" 확장을 보냅니다.

- \(EC\)DHE를 사용하는 경우 서버는 "key\_share" 확장도 제공합니다. PSK를 사용하지 않는 경우 \(EC\)DHE 및 인증서 기반 인증이 항상 사용됩니다.

- 인증서를 통해 인증할 때 서버는 인증서\(섹션 4.4.2\) 및 CertificateVerify\(섹션 4.4.3\) 메시지를 보냅니다. 이 문서에 정의된 대로 TLS 1.3에서는 PSK 또는 인증서 중 하나가 항상 사용되지만 둘 다 사용되지는 않습니다. 향후 문서에서는 이를 함께 사용하는 방법을 정의할 수 있습니다.

서버가 지원되는 매개변수 세트를 협상할 수 없는 경우\(즉, 클라이언트와 서버 매개변수 사이에 중복이 없는 경우\) "handshake\_failure" 또는 "insufficient\_security" 치명적인 경고로 핸드셰이크를 중단해야 합니다\(섹션 6 참조\).

---
#### **4.1.2.  Client Hello**

클라이언트가 처음 서버에 연결되면 첫 번째 TLS 메시지로 ClientHello를 보내는 것이 필수입니다. 서버가 HelloRetryRequest로 ClientHello에 응답하면 클라이언트도 ClientHello를 보냅니다. 이 경우 클라이언트는 다음을 제외하고 수정 없이 동일한 ClientHello를 보내야 합니다.

- HelloRetryRequest에 "key\_share" 확장이 제공된 경우 공유 목록을 표시된 그룹의 단일 KeyShareEntry가 포함된 목록으로 바꿉니다.

- "early\_data" 확장\(섹션 4.2.10\)이 있는 경우 제거합니다. HelloRetryRequest 이후에는 초기 데이터가 허용되지 않습니다.

- HelloRetryRequest에 제공된 경우 "쿠키" 확장을 포함합니다.

- "obfuscated\_ticket\_age" 및 바인더 값을 다시 계산하고 \(선택적으로\) 서버에 표시된 암호화 제품군과 호환되지 않는 PSK를 제거하여 "pre\_shared\_key" 확장이 있는 경우 업데이트합니다.

- 선택적으로 "패딩" 확장 \[RFC7685\]의 길이를 추가, 제거 또는 변경합니다.

- 향후 정의되고 HelloRetryRequest에 있는 확장에 의해 허용될 수 있는 기타 수정.

TLS 1.3은 재협상을 금지하기 때문에 서버가 TLS 1.3을 협상하고 언제든지 ClientHello를 수신하는 경우 "unexpected\_message" 경고와 함께 연결을 종료해야 합니다.

서버가 이전 버전의 TLS와 TLS 연결을 설정하고 재협상에서 TLS 1.3 ClientHello를 수신하는 경우 이전 프로토콜 버전을 유지해야 합니다. 특히 TLS 1.3을 협상해서는 안 됩니다.

이 메시지의 구조:

```text
      uint16 ProtocolVersion;
      opaque Random[32];

      uint8 CipherSuite[2];    /* Cryptographic suite selector */

      struct {
          ProtocolVersion legacy_version = 0x0303;    /* TLS v1.2 */
          Random random;
          opaque legacy_session_id<0..32>;
          CipherSuite cipher_suites<2..2^16-2>;
          opaque legacy_compression_methods<1..2^8-1>;
          Extension extensions<8..2^16-1>;
      } ClientHello;
```

Legacy\_version: 이전 버전의 TLS에서 이 필드는 버전 협상에 사용되었으며 클라이언트가 지원하는 가장 높은 버전 번호를 나타냅니다. 경험에 따르면 많은 서버가 버전 협상을 제대로 구현하지 않아 서버가 지원하는 것보다 높은 버전 번호를 사용하여 허용되는 ClientHello를 거부하는 "버전 불내성"이 발생하는 것으로 나타났습니다. TLS 1.3에서 클라이언트는 "supported\_versions" 확장\(섹션 4.2.1\)에 버전 기본 설정을 표시하고 Legacy\_version 필드는 TLS 1.2의 버전 번호인 0x0303으로 설정되어야 합니다. TLS 1.3 ClientHellos는 0x0303의 레거시 버전과 여기에 표시된 가장 높은 버전으로 0x0304와 함께 존재하는 Supported\_versions 확장을 갖는 것으로 식별됩니다. \(이전 버전과의 호환성에 대한 자세한 내용은 부록 D를 참조하세요.\)

무작위: 보안 난수 생성기에 의해 생성된 32바이트입니다. 자세한 내용은 부록 C를 참조하세요.

Legacy\_session\_id: TLS 1.3 이전의 TLS 버전은 이 버전의 사전 공유 키와 병합된 "세션 재개" 기능을 지원했습니다\(섹션 2.2 참조\). TLS 1.3 이전 서버에 의해 설정된 캐시된 세션 ID를 가진 클라이언트는 이 필드를 해당 값으로 설정해야 합니다. 호환 모드\(부록 D.4 참조\)에서 이 필드는 비어 있지 않아야 하므로 TLS 1.3 이전 세션을 제공하지 않는 클라이언트는 새로운 32바이트 값을 생성해야 합니다. 이 값은 무작위일 필요는 없지만 특정 값에 고정되는 구현\(골화라고도 함\)을 방지하려면 예측할 수 없어야 합니다. 그렇지 않으면 길이가 0인 벡터\(즉, 값이 0인 단일 바이트 길이 필드\)로 설정되어야 합니다.

cipher\_suites: 클라이언트가 지원하는 대칭 암호 옵션 목록, 특히 레코드 보호 알고리즘\(비밀 키 길이 포함\) 및 HKDF와 함께 사용할 해시\(클라이언트 선호도 내림차순\)입니다. 값은 부록 B.4에 정의되어 있습니다. 목록에 서버가 인식하지 못하거나 지원하지 않거나 사용하려는 암호 모음이 포함된 경우 서버는 해당 암호 모음을 무시하고 나머지 암호 모음을 평소대로 처리해야 합니다. 클라이언트가 PSK 키 설정을 시도하는 경우 PSK와 관련된 해시를 나타내는 하나 이상의 암호 제품군을 광고해야 합니다.

Legacy\_compression\_methods: 1.3 이전의 TLS 버전은 이 필드에 전송되는 지원되는 압축 방법 목록과 함께 압축을 지원했습니다. 모든 TLS 1.3 ClientHello에 대해 이 벡터는 이전 TLS 버전의 "null" 압축 방법에 해당하는 0으로 설정된 정확히 1바이트를 포함해야 합니다. 이 필드에 다른 값이 포함된 TLS 1.3 ClientHello가 수신되면 서버는 "illegal\_parameter" 경고와 함께 핸드셰이크를 중단해야 합니다. TLS 1.3 서버는 다른 압축 방법이 포함된 TLS 1.2 또는 이전 ClientHellos를 수신할 수 있으며 \(이전 버전을 협상하는 경우\) 적절한 이전 버전의 TLS에 대한 절차를 따라야 합니다.

확장: 클라이언트는 확장 필드에 데이터를 전송하여 서버에서 확장된 기능을 요청합니다. 실제 "확장" 형식은 섹션 4.2에 정의되어 있습니다. TLS 1.3에서는 이전 버전의 TLS와의 ClientHello 호환성을 유지하기 위해 기능이 확장으로 이동했기 때문에 특정 확장의 사용이 필수입니다. 서버는 인식할 수 없는 확장을 무시해야 합니다.

TLS의 모든 버전에서는 확장 필드가 선택적으로 압축 방법 필드 뒤에 오는 것을 허용합니다. TLS 1.3 ClientHello 메시지에는 항상 확장이 포함됩니다\(최소 "supported\_versions", 그렇지 않으면 TLS 1.2 ClientHello 메시지로 해석됨\). 그러나 TLS 1.3 서버는 이전 버전의 TLS에서 확장 필드 없이 ClientHello 메시지를 수신할 수 있습니다. 확장 기능의 존재 여부는 ClientHello 끝의 압축\_메소드 필드 뒤에 바이트가 있는지 확인하여 감지할 수 있습니다. 선택적 데이터를 감지하는 이 방법은 가변 길이 필드를 갖는 일반적인 TLS 방법과 다르지만 확장이 정의되기 전에 TLS와의 호환성을 위해 사용됩니다. TLS 1.3 서버는 먼저 이 검사를 수행해야 하며 "supported\_versions" 확장이 있는 경우에만 TLS 1.3 협상을 시도해야 합니다. 1.3 이전 버전의 TLS를 협상하는 경우 서버는 메시지에 Legacy\_compression\_methods 이후에 데이터가 포함되어 있지 않거나 뒤에 오는 데이터가 없는 유효한 확장 블록이 포함되어 있는지 확인해야 합니다. 그렇지 않은 경우 "decode\_error" 경고와 함께 핸드셰이크를 중단해야 합니다.

클라이언트가 확장을 사용하여 추가 기능을 요청하고 서버에서 이 기능을 제공하지 않는 경우 클라이언트는 핸드셰이크를 중단할 수 있습니다.

ClientHello 메시지를 보낸 후 클라이언트는 ServerHello 또는 HelloRetryRequest 메시지를 기다립니다. 초기 데이터가 사용 중인 경우 클라이언트는 다음 핸드셰이크 메시지를 기다리는 동안 초기 애플리케이션 데이터\(섹션 2.3\)를 전송할 수 있습니다.

---
#### **4.1.3.  Server Hello**

서버는 ClientHello를 기반으로 허용 가능한 핸드셰이크 매개변수 집합을 협상할 수 있는 경우 핸드셰이크를 진행하기 위해 ClientHello 메시지에 대한 응답으로 이 메시지를 보냅니다.

이 메시지의 구조:

```text
      struct {
          ProtocolVersion legacy_version = 0x0303;    /* TLS v1.2 */
          Random random;
          opaque legacy_session_id_echo<0..32>;
          CipherSuite cipher_suite;
          uint8 legacy_compression_method = 0;
          Extension extensions<6..2^16-1>;
      } ServerHello;
```

Legacy\_version: 이전 버전의 TLS에서는 이 필드가 버전 협상에 사용되었으며 연결을 위해 선택된 버전 번호를 나타냈습니다. 불행하게도 일부 미들박스는 새로운 값이 제공될 때 실패합니다. TLS 1.3에서 TLS 서버는 "supported\_versions" 확장\(섹션 4.2.1\)을 사용하여 해당 버전을 나타내며, Legacy\_version 필드는 TLS 1.2의 버전 번호인 0x0303으로 설정되어야 합니다. \(이전 버전과의 호환성에 대한 자세한 내용은 부록 D를 참조하세요.\)

무작위: 보안 난수 생성기에 의해 생성된 32바이트입니다. 자세한 내용은 부록 C를 참조하세요. TLS 1.2 또는 TLS 1.1을 협상하는 경우 마지막 8바이트는 아래 설명된 대로 덮어써야 하지만 나머지 바이트는 무작위여야 합니다. 이 구조는 서버에 의해 생성되며 ClientHello.random과 독립적으로 생성되어야 합니다.

Legacy\_session\_id\_echo: 클라이언트의 Legacy\_session\_id 필드 내용입니다. 클라이언트의 값이 서버가 재개하지 않기로 선택한 캐시된 TLS 1.3 이전 세션에 해당하는 경우에도 이 필드는 에코됩니다. ClientHello에서 전송한 내용과 일치하지 않는 Legacy\_session\_id\_echo 필드를 수신한 클라이언트는 "illegal\_parameter" 경고와 함께 핸드셰이크를 중단해야 합니다.

cipher\_suite: ClientHello.cipher\_suites의 목록에서 서버가 선택한 단일 암호 제품군입니다. 제공되지 않은 암호 모음을 수신한 클라이언트는 "illegal\_parameter" 경고와 함께 핸드셰이크를 중단해야 합니다.

Legacy\_compression\_method: 값이 0이어야 하는 단일 바이트입니다.

확장: 확장 목록입니다. ServerHello는 암호화 컨텍스트를 설정하고 프로토콜 버전을 협상하는 데 필요한 확장만 포함해야 합니다. 모든 TLS 1.3 ServerHello 메시지에는 "supported\_versions" 확장이 포함되어야 합니다. 현재 ServerHello 메시지에는 "pre\_shared\_key" 확장이나 "key\_share" 확장 또는 둘 다 포함됩니다\(\(EC\)DHE 키 설정과 함께 PSK를 사용하는 경우\). 다른 확장\(섹션 4.2 참조\)은 EncryptedExtensions 메시지에서 별도로 전송됩니다.

미들박스와의 하위 호환성\(부록 D.4 참조\)으로 인해 HelloRetryRequest 메시지는 ServerHello와 동일한 구조를 사용하지만 Random은 "HelloRetryRequest"의 SHA-256 특수 값으로 설정됩니다.

```text
     CF 21 AD 74 E5 9A 61 11 BE 1D 8C 02 1E 65 B8 91
     C2 A2 11 16 7A BB 8C 5E 07 9E 09 E2 C8 A8 33 9C
```

server\_hello 유형의 메시지를 수신하면 구현은 먼저 Random 값을 검사하고 이 값이 일치하는 경우 섹션 4.1.4에 설명된 대로 처리해야 합니다.

TLS 1.3에는 서버의 임의 값에 다운그레이드 방지 메커니즘이 내장되어 있습니다. ClientHello에 응답하여 TLS 1.2 이하를 협상하는 TLS 1.3 서버는 특히 ServerHello에서 Random 값의 마지막 8바이트를 설정해야 합니다.

TLS 1.2를 협상하는 경우 TLS 1.3 서버는 Random 값의 마지막 8바이트를 바이트로 설정해야 합니다.

```text
     44 4F 57 4E 47 52 44 01
```

TLS 1.1 이하를 협상하는 경우 TLS 1.3 서버는 반드시, TLS 1.2 서버는 반드시 ServerHello.Random 값의 마지막 8바이트를 바이트로 설정해야 합니다.

```text
     44 4F 57 4E 47 52 44 00
```

TLS 1.2 이하를 나타내는 ServerHello를 수신하는 TLS 1.3 클라이언트는 마지막 8바이트가 이러한 값 중 하나와 같지 않은지 확인해야 합니다. TLS 1.2 클라이언트는 또한 ServerHello가 TLS 1.1 이하를 나타내는 경우 마지막 8바이트가 두 번째 값과 같지 않은지 확인해야 합니다. 일치하는 항목이 발견되면 클라이언트는 "illegal\_parameter" 경고와 함께 핸드셰이크를 중단해야 합니다. 이 메커니즘은 Finished 교환에서 제공하는 것 이상의 다운그레이드 공격에 대해 제한적인 보호를 제공합니다. TLS 1.2 이하에 있는 메시지인 ServerKeyExchange에는 두 임의 값에 대한 서명이 포함되어 있으므로 활성 공격자가 수정할 수 없습니다. 그만큼

임시 암호를 사용하는 한 감지되지 않는 임의의 값입니다. 정적 RSA가 사용되는 경우 다운그레이드 보호를 제공하지 않습니다.

참고: 이는 \[RFC5246\]의 변경 사항이므로 실제로 많은 TLS 1.2 클라이언트와 서버는 위에 지정된 대로 작동하지 않습니다.

TLS 1.2 이하 버전으로 재협상을 수행하고 재협상 중에 TLS 1.3 ServerHello를 수신하는 레거시 TLS 클라이언트는 "protocol\_version" 경고와 함께 핸드셰이크를 중단해야 합니다. TLS 1.3이 협상되면 재협상이 불가능합니다.

---
#### **4.1.4.  Hello Retry Request**

서버는 허용 가능한 매개변수 세트를 찾을 수 있지만 ClientHello에 핸드셰이크를 진행하기에 충분한 정보가 포함되어 있지 않은 경우 ClientHello 메시지에 대한 응답으로 이 메시지를 보냅니다. 4.1.3절에서 설명한 것처럼 HelloRetryRequest는 ServerHello 메시지와 동일한 형식을 가지며, Legacy\_version, Legacy\_session\_id\_echo, cipher\_suite 및 Legacy\_compression\_method 필드는 동일한 의미를 갖습니다. 그러나 편의상 이 문서 전체에서 "HelloRetryRequest"가 별도의 메시지인 것처럼 설명합니다.

서버의 확장에는 "supported\_versions"가 포함되어야 합니다. 또한 클라이언트가 올바른 ClientHello 쌍을 생성하는 데 필요한 최소한의 확장 세트를 포함해야 합니다\(SHOULD\). ServerHello와 마찬가지로 HelloRetryRequest는 선택적으로 "쿠키"\(섹션 4.2.2 참조\) 확장을 제외하고 클라이언트가 ClientHello에서 처음 제공하지 않은 확장을 포함해서는 안 됩니다.

HelloRetryRequest를 수신한 클라이언트는 반드시 섹션 4.1.3에 지정된 대로 레거시\_버전, 레거시\_세션\_id\_echo, cipher\_suite 및 레거시\_compression\_method를 확인한 다음 "supported\_versions"를 사용하여 버전 결정부터 시작하여 확장을 처리해야 합니다. HelloRetryRequest로 인해 ClientHello가 변경되지 않으면 클라이언트는 "illegal\_parameter" 경고로 핸드셰이크를 중단해야 합니다. 클라이언트가 동일한 연결에서 두 번째 HelloRetryRequest를 수신하는 경우\(즉, ClientHello 자체가 HelloRetryRequest에 대한 응답인 경우\) "unexpected\_message" 경고와 함께 핸드셰이크를 중단해야 합니다.

그렇지 않으면 클라이언트는 HelloRetryRequest의 모든 확장을 처리하고 두 번째 업데이트된 ClientHello를 보내야 합니다. 이 사양에 정의된 HelloRetryRequest 확장은 다음과 같습니다.

```text
   -  supported_versions (see Section 4.2.1)

   -  cookie (see Section 4.2.2)

   -  key_share (see Section 4.2.8)
```

제공되지 않은 암호 모음을 수신한 클라이언트는 핸드셰이크를 중단해야 합니다. 서버는 적합하게 업데이트된 ClientHello를 수신할 때 동일한 암호 제품군을 협상하는지 확인해야 합니다\(서버가 협상의 첫 번째 단계로 암호 제품군을 선택한 경우 이는 자동으로 발생합니다\). ServerHello를 수신하면 클라이언트는 ServerHello에 제공된 암호 그룹이 HelloRetryRequest의 암호 그룹과 동일한지 확인해야 하며, 그렇지 않으면 "illegal\_parameter" 경고와 함께 핸드셰이크를 중단해야 합니다.

또한 업데이트된 ClientHello에서 클라이언트는 선택한 암호화 제품군의 해시 이외의 해시와 관련된 사전 공유 키를 제공해서는 안 됩니다. 이를 통해 클라이언트는 두 번째 ClientHello에서 여러 해시에 대한 부분 해시 기록을 계산하지 않아도 됩니다.

HelloRetryRequest "supported\_versions" 확장의 selected\_version 값은 ServerHello에 유지되어야 하며, 값이 변경되면 클라이언트는 "illegal\_parameter" 경고와 함께 핸드셰이크를 중단해야 합니다.

---
### **4.2.  Extensions**

다수의 TLS 메시지에는 태그 길이 값으로 인코딩된 확장 구조가 포함되어 있습니다.

```text
    struct {
        ExtensionType extension_type;
        opaque extension_data<0..2^16-1>;
    } Extension;

    enum {
        server_name(0),                             /* RFC 6066 */
        max_fragment_length(1),                     /* RFC 6066 */
        status_request(5),                          /* RFC 6066 */
        supported_groups(10),                       /* RFC 8422, 7919 */
        signature_algorithms(13),                   /* RFC 8446 */
        use_srtp(14),                               /* RFC 5764 */
        heartbeat(15),                              /* RFC 6520 */
        application_layer_protocol_negotiation(16), /* RFC 7301 */
        signed_certificate_timestamp(18),           /* RFC 6962 */
        client_certificate_type(19),                /* RFC 7250 */
        server_certificate_type(20),                /* RFC 7250 */
        padding(21),                                /* RFC 7685 */
        pre_shared_key(41),                         /* RFC 8446 */
        early_data(42),                             /* RFC 8446 */
        supported_versions(43),                     /* RFC 8446 */
        cookie(44),                                 /* RFC 8446 */
        psk_key_exchange_modes(45),                 /* RFC 8446 */
        certificate_authorities(47),                /* RFC 8446 */
        oid_filters(48),                            /* RFC 8446 */
        post_handshake_auth(49),                    /* RFC 8446 */
        signature_algorithms_cert(50),              /* RFC 8446 */
        key_share(51),                              /* RFC 8446 */
        (65535)
    } ExtensionType;

   Here:
```

- "extension\_type"은 특정 확장 유형을 식별합니다.

- "extension\_data"에는 특정 확장 유형과 관련된 정보가 포함됩니다.

확장 유형 목록은 섹션 11에 설명된 대로 IANA에서 관리합니다.

확장은 일반적으로 요청/응답 방식으로 구성되지만 일부 확장은 해당 응답이 없는 표시일 뿐입니다. 클라이언트는 ClientHello 메시지를 통해 확장 요청을 보내고, 서버는 ServerHello, EncryptedExtensions, HelloRetryRequest 및 Certificate 메시지를 통해 확장 응답을 보냅니다. 서버는 클라이언트가 인증서 메시지로 응답할 수 있는 CertificateRequest 메시지에 확장 요청을 보냅니다. 클라이언트가 이에 직접 응답하지 않더라도 서버는 NewSessionTicket에서 원치 않는 확장을 보낼 수도 있습니다.

HelloRetryRequest의 "쿠키" 확장을 제외하고 원격 엔드포인트가 해당 확장 요청을 보내지 않은 경우 구현에서는 확장 응답을 보내서는 안 됩니다. 그러한 확장을 수신하면 엔드포인트는 "unsupported\_extension" 경고와 함께 핸드셰이크를 중단해야 합니다.

아래 표는 CH\(ClientHello\), SH\(ServerHello\), EE\(EncryptedExtensions\), CT\(인증서\), CR\(CertificateRequest\), NST\(NewSessionTicket\) 및 HRR 표기법을 사용하여 특정 확장이 나타날 수 있는 메시지를 나타냅니다. \(HelloRetry요청\). 구현이 인식하고 나타나는 메시지에 대해 지정되지 않은 확장을 수신하는 경우 "illegal\_parameter" 경고와 함께 핸드셰이크를 중단해야 합니다.

```text
   +--------------------------------------------------+-------------+
   | Extension                                        |     TLS 1.3 |
   +--------------------------------------------------+-------------+
   | server_name [RFC6066]                            |      CH, EE |
   |                                                  |             |
   | max_fragment_length [RFC6066]                    |      CH, EE |
   |                                                  |             |
   | status_request [RFC6066]                         |  CH, CR, CT |
   |                                                  |             |
   | supported_groups [RFC7919]                       |      CH, EE |
   |                                                  |             |
   | signature_algorithms (RFC 8446)                  |      CH, CR |
   |                                                  |             |
   | use_srtp [RFC5764]                               |      CH, EE |
   |                                                  |             |
   | heartbeat [RFC6520]                              |      CH, EE |
   |                                                  |             |
   | application_layer_protocol_negotiation [RFC7301] |      CH, EE |
   |                                                  |             |
   | signed_certificate_timestamp [RFC6962]           |  CH, CR, CT |
   |                                                  |             |
   | client_certificate_type [RFC7250]                |      CH, EE |
   |                                                  |             |
   | server_certificate_type [RFC7250]                |      CH, EE |
   |                                                  |             |
   | padding [RFC7685]                                |          CH |
   |                                                  |             |
   | key_share (RFC 8446)                             | CH, SH, HRR |
   |                                                  |             |
   | pre_shared_key (RFC 8446)                        |      CH, SH |
   |                                                  |             |
   | psk_key_exchange_modes (RFC 8446)                |          CH |
   |                                                  |             |
   | early_data (RFC 8446)                            | CH, EE, NST |
   |                                                  |             |
   | cookie (RFC 8446)                                |     CH, HRR |
   |                                                  |             |
   | supported_versions (RFC 8446)                    | CH, SH, HRR |
   |                                                  |             |
   | certificate_authorities (RFC 8446)               |      CH, CR |
   |                                                  |             |
   | oid_filters (RFC 8446)                           |          CR |
   |                                                  |             |
   | post_handshake_auth (RFC 8446)                   |          CH |
   |                                                  |             |
   | signature_algorithms_cert (RFC 8446)             |      CH, CR |
   +--------------------------------------------------+-------------+
```

서로 다른 유형의 여러 확장이 있는 경우 확장은 ClientHello의 마지막 확장이어야 하는 "pre\_shared\_key"\(섹션 4.2.11\)를 제외하고 순서에 관계없이 나타날 수 있습니다\(그러나 ServerHello 확장 블록의 어느 곳에나 나타날 수 있음\). . 주어진 확장 블록에는 동일한 유형의 확장이 두 개 이상 있어서는 안 됩니다.

TLS 1.3에서는 TLS 1.2와 달리 재개-PSK 모드에서도 각 핸드셰이크에 대해 확장이 협상됩니다. 그러나 0-RTT 매개변수는 이전 핸드셰이크에서 협상된 매개변수입니다. 불일치로 인해 0-RTT를 거부해야 할 수도 있습니다\(섹션 4.2.10 참조\).

이 프로토콜에서는 새로운 기능과 기존 기능 사이에 미묘한\(그리 미묘하지는 않은\) 상호 작용이 발생할 수 있으며 이로 인해 전체 보안이 크게 저하될 수 있습니다. 새로운 확장을 디자인할 때 다음 사항을 고려해야 합니다.

- 서버가 확장에 동의하지 않는 경우는 오류 조건\(예: 핸드셰이크를 계속할 수 없음\)이고 일부는 단순히 특정 기능 지원을 거부하는 경우입니다. 일반적으로 전자에는 오류 경고를 사용해야 하고 후자에는 서버 확장 응답의 필드를 사용해야 합니다.

- 확장은 가능한 한 핸드셰이크 메시지를 조작하여 특정 기능을 강제로 사용\(또는 사용하지 않음\)하는 공격을 방지하도록 설계되어야 합니다. 해당 기능이 보안 문제를 일으키는 것으로 판단되는지 여부에 관계없이 이 원칙을 따라야 합니다. 종료된 메시지 해시에 대한 입력에 확장 필드가 포함되어 있다는 사실만으로도 충분할 수 있지만 확장이 핸드셰이크 단계에서 전송된 메시지의 의미를 변경할 때는 각별한 주의가 필요합니다. 설계자와 구현자는 핸드셰이크가 인증될 때까지 적극적인 공격자가 메시지를 수정하고 확장을 삽입, 제거 또는 교체할 수 있다는 사실을 알고 있어야 합니다.

---
#### **4.2.1.  Supported Versions**

```text
      struct {
          select (Handshake.msg_type) {
              case client_hello:
                   ProtocolVersion versions<2..254>;

              case server_hello: /* and HelloRetryRequest */
                   ProtocolVersion selected_version;
          };
      } SupportedVersions;
```

"supported\_versions" 확장은 클라이언트가 지원하는 TLS 버전을 나타내고 서버가 사용 중인 버전을 나타내는 데 사용됩니다. 확장에는 지원되는 버전 목록이 기본 설정 순서대로 포함되어 있으며 가장 선호하는 버전이 먼저 표시됩니다. 이 사양의 구현은 협상할 준비가 된 모든 버전의 TLS를 포함하는 ClientHello에서 이 확장을 보내야 합니다\(이 사양의 경우 최소 0x0304를 의미하지만 이전 버전의 TLS가 협상되도록 허용된 경우 해당 버전도 있어야 합니다\). \).

이 확장이 없으면 이 사양을 준수하고 TLS 1.2도 지원하는 서버는 ClientHello.legacy\_version이 0x0304 이상인 경우에도 \[RFC5246\]에 지정된 대로 TLS 1.2 이하를 협상해야 합니다. 서버는 Legacy\_version 0x0304 이상의 ClientHello를 수신하면 핸드셰이크를 중단할 수 있습니다.

이 확장이 ClientHello에 있는 경우 서버는 버전 협상을 위해 ClientHello.legacy\_version 값을 사용해서는 안 되며 클라이언트 기본 설정을 결정하기 위해 "supported\_versions" 확장만 사용해야 합니다. 서버는 해당 확장에 있는 TLS 버전만 선택해야 하며 해당 확장에 있는 알 수 없는 버전은 무시해야 합니다. 이 메커니즘을 사용하면 한쪽이 희소 범위를 지원하는 경우 TLS 1.2 이전 버전을 협상할 수 있습니다. 이전 버전의 TLS를 지원하기로 선택한 TLS 1.3의 구현은 TLS 1.2를 지원해야 합니다\(SHOULD\). 서버는 이 확장을 포함하지만 버전 목록에 0x0304를 포함하지 않는 ClientHellos를 수신할 준비를 해야 합니다.

TLS 1.3 이전의 TLS 버전을 협상하는 서버는 ServerHello.version을 설정해야 하며 "supported\_versions" 확장을 보내서는 안 됩니다. TLS 1.3을 협상하는 서버는 선택된 버전 값\(0x0304\)이 포함된 "supported\_versions" 확장을 전송하여 응답해야 합니다. ServerHello.legacy\_version 필드를 0x0303\(TLS 1.2\)으로 설정해야 합니다. 클라이언트는 ServerHello의 나머지 부분을 처리하기 전에 이 확장을 확인해야 합니다.

확장을 읽기 위해 ServerHello를 구문 분석합니다.\) 이 확장이 있는 경우 클라이언트는 ServerHello.legacy\_version 값을 무시해야 하며 "supported\_versions" 확장만 사용하여 선택한 버전을 결정해야 합니다. ServerHello의 "supported\_versions" 확장에 클라이언트가 제공하지 않은 버전이 포함되어 있거나 TLS 1.3 이전 버전이 포함되어 있는 경우 클라이언트는 "illegal\_parameter" 경고와 함께 핸드셰이크를 중단해야 합니다.

---
#### **4.2.2.  Cookie**

```text
      struct {
          opaque cookie<1..2^16-1>;
      } Cookie;

   Cookies serve two primary purposes:
```

- 서버가 클라이언트가 명백한 네트워크 주소에서 연결 가능성을 입증하도록 허용합니다\(따라서 DoS 보호 수단 제공\). 이는 주로 비연결 지향 전송에 유용합니다\(이에 대한 예는 \[RFC6347\] 참조\).

- 서버가 상태를 클라이언트로 오프로드하여 상태를 저장하지 않고 HelloRetryRequest를 보낼 수 있도록 허용합니다. 서버는 HelloRetryRequest 쿠키\(적절한 무결성 보호 알고리즘으로 보호됨\)에 ClientHello의 해시를 저장하여 이를 수행할 수 있습니다.

HelloRetryRequest를 보낼 때 서버는 클라이언트에 "쿠키" 확장을 제공할 수 있습니다\(이는 ClientHello에 나타나는 확장만이 전송될 수 있다는 일반적인 규칙에 대한 예외입니다\). 새 ClientHello를 보낼 때 클라이언트는 HelloRetryRequest에서 수신된 확장의 콘텐츠를 새 ClientHello의 "쿠키" 확장에 복사해야 합니다. 클라이언트는 후속 연결의 초기 ClientHello에서 쿠키를 사용해서는 안 됩니다.

서버가 상태 없이 작동하는 경우 첫 번째 ClientHello와 두 번째 ClientHello 사이에서 변경\_cipher\_spec 유형의 보호되지 않은 레코드를 수신할 수 있습니다\(섹션 5 참조\). 서버는 어떤 상태도 저장하지 않으므로 이는 수신된 첫 번째 메시지인 것처럼 나타납니다. 상태 없이 작동하는 서버는 이러한 레코드를 무시해야 합니다.

---
#### **4.2.3.  Signature Algorithms**

TLS 1.3은 디지털 서명에 사용할 수 있는 서명 알고리즘을 나타내는 두 가지 확장을 제공합니다. "signature\_algorithms\_cert" 확장은 인증서의 서명에 적용되며 원래 TLS 1.2에 나타난 "signature\_algorithms" 확장은 CertificateVerify 메시지의 서명에 적용됩니다. 인증서에 있는 키는 함께 사용되는 서명 알고리즘에 적합한 유형이어야 합니다. 이는 아래에 설명된 대로 RSA 키 및 PSS 서명에 대한 특정 문제입니다. "signature\_algorithms\_cert" 확장이 없으면 "signature\_algorithms" 확장은 인증서에 나타나는 서명에도 적용됩니다. 서버가 인증서를 통해 자신을 인증하기를 원하는 클라이언트는 "signature\_algorithms" 확장을 보내야 합니다. 서버가 인증서를 통해 인증하고 클라이언트가 "signature\_algorithms" 확장을 전송하지 않은 경우 서버는 "missing\_extension" 경고와 함께 핸드셰이크를 중단해야 합니다\(섹션 9.2 참조\).

"signature\_algorithms\_cert" 확장은 인증서에 대한 다양한 알고리즘 세트를 지원하는 구현과 TLS 자체에서 해당 기능을 명확하게 알리는 구현을 허용하기 위해 추가되었습니다. TLS 1.2 구현은 이 확장도 처리해야 합니다\(SHOULD\). 두 경우 모두 동일한 정책을 갖는 구현에서는 "signature\_algorithms\_cert" 확장을 생략할 수 있습니다.

이러한 확장의 "extension\_data" 필드에는 SignatureSchemeList 값이 포함되어 있습니다.

```text
      enum {
          /* RSASSA-PKCS1-v1_5 algorithms */
          rsa_pkcs1_sha256(0x0401),
          rsa_pkcs1_sha384(0x0501),
          rsa_pkcs1_sha512(0x0601),

          /* ECDSA algorithms */
          ecdsa_secp256r1_sha256(0x0403),
          ecdsa_secp384r1_sha384(0x0503),
          ecdsa_secp521r1_sha512(0x0603),

          /* RSASSA-PSS algorithms with public key OID rsaEncryption */
          rsa_pss_rsae_sha256(0x0804),
          rsa_pss_rsae_sha384(0x0805),
          rsa_pss_rsae_sha512(0x0806),

          /* EdDSA algorithms */
          ed25519(0x0807),
          ed448(0x0808),

          /* RSASSA-PSS algorithms with public key OID RSASSA-PSS */
          rsa_pss_pss_sha256(0x0809),
          rsa_pss_pss_sha384(0x080a),
          rsa_pss_pss_sha512(0x080b),

          /* Legacy algorithms */
          rsa_pkcs1_sha1(0x0201),
          ecdsa_sha1(0x0203),

          /* Reserved Code Points */
          private_use(0xFE00..0xFFFF),
          (0xFFFF)
      } SignatureScheme;

      struct {
          SignatureScheme supported_signature_algorithms<2..2^16-2>;
      } SignatureSchemeList;
```

참고: TLS 1.2에는 이를 대체하는 "SignatureAlgorithm" 유형이 이미 있으므로 이 열거형의 이름은 "SignatureScheme"입니다. 우리는 본문 전반에 걸쳐 "서명 알고리즘"이라는 용어를 사용합니다.

각 SignatureScheme 값은 클라이언트가 확인하려는 단일 서명 알고리즘을 나열합니다. 값은 선호도가 높은 순서대로 표시됩니다. 서명 알고리즘은 다이제스트가 아닌 임의 길이의 메시지를 입력으로 사용합니다. 전통적으로 다이제스트에 작용하는 알고리즘은 먼저 지정된 해시 알고리즘으로 입력을 해시한 다음 평소대로 진행하도록 TLS에 정의되어야 합니다. 위에 나열된 코드 포인트 그룹의 의미는 다음과 같습니다.

RSASSA-PKCS1-v1\_5 알고리즘: \[SHS\]에 정의된 해당 해시 알고리즘과 함께 RSASSA-PKCS1-v1\_5 \[RFC8017\]을 사용하는 서명 알고리즘을 나타냅니다. 이러한 값은 인증서에 나타나는 서명만을 참조하며\(섹션 4.4.2.2 참조\) 서명된 TLS 핸드셰이크 메시지에 사용하도록 정의되지 않습니다. 하지만 TLS 1.2와의 하위 호환성을 위해 "signature\_algorithms" 및 "signature\_algorithms\_cert"에 나타날 수 있습니다.

ECDSA 알고리즘: ECDSA \[ECDSA\], ANSI X9.62 \[ECDSA\] 및 FIPS 186-4 \[DSS\]에 정의된 해당 곡선, \[SHS\]에 정의된 해당 해시 알고리즘을 사용하는 서명 알고리즘을 나타냅니다. 서명은 DER로 인코딩된 \[X690\] ECDSA-Sig-Value 구조로 표시됩니다.

RSASSA-PSS RSAE 알고리즘: 마스크 생성 기능 1을 갖춘 RSASSA-PSS \[RFC8017\]를 사용하는 서명 알고리즘을 나타냅니다. 마스크 생성 기능에 사용되는 다이제스트와 서명되는 다이제스트는 모두 \[SHS\]에 정의된 해당 해시 알고리즘입니다. 솔트의 길이는 다이제스트 알고리즘의 출력 길이와 같아야 합니다. 공개 키가 X.509 인증서에 포함된 경우 rsaEncryption OID \[RFC5280\]를 사용해야 합니다.

EdDSA 알고리즘: \[RFC8032\] 또는 그 후속 항목에 정의된 대로 EdDSA를 사용하는 서명 알고리즘을 나타냅니다. 이는 "prehash" 변형이 아니라 "PureEdDSA" 알고리즘에 해당합니다.

RSASSA-PSS PSS 알고리즘: 마스크 생성 기능 1을 갖춘 RSASSA-PSS \[RFC8017\]를 사용하는 서명 알고리즘을 나타냅니다. 마스크 생성 기능에 사용되는 다이제스트와 서명되는 다이제스트는 모두 \[SHS\]에 정의된 해당 해시 알고리즘입니다. 솔트의 길이는 다이제스트 알고리즘의 길이와 같아야 합니다. 공개 키가 X.509 인증서에 포함된 경우 RSASSA-PSS OID \[RFC5756\]를 사용해야 합니다. 인증서 서명에 사용되는 경우 알고리즘 매개변수는 DER로 인코딩되어야 합니다. 해당 공개 키의 매개변수가 존재하는 경우 서명의 매개변수는 공개 키의 매개변수와 동일해야 합니다.

레거시 알고리즘: 알려진 약점이 있는 알고리즘, 특히 \(1\) RSASSA-PKCS1-v1\_5를 사용하는 RSA 또는 \(2\) ECDSA와 함께 이 컨텍스트에서 사용되는 SHA-1을 사용하기 때문에 더 이상 사용되지 않는 알고리즘을 나타냅니다. 이러한 값은 인증서에 나타나는 서명만을 참조하며\(섹션 4.4.2.2 참조\) 서명된 TLS 핸드셰이크 메시지에 사용하도록 정의되지 않습니다. 하지만 TLS 1.2와의 하위 호환성을 위해 "signature\_algorithms" 및 "signature\_algorithms\_cert"에 나타날 수 있습니다. 엔드포인트는 이러한 알고리즘을 협상해서는 안 되지만 이전 버전과의 호환성을 위해서만 그렇게 하는 것이 허용됩니다. 이러한 값을 제공하는 클라이언트는 이를 가장 낮은 우선순위로 나열해야 합니다\(SignatureSchemeList의 다른 모든 알고리즘 다음에 나열됨\). TLS 1.3 서버는 SHA-1 서명 인증서 없이 유효한 인증서 체인을 생성할 수 없는 한 SHA-1 서명 인증서를 제공해서는 안 됩니다\(섹션 4.4.2.2 참조\).

자체 서명된 인증서 또는 트러스트 앵커인 인증서의 서명은 인증 경로를 시작하므로 검증되지 않습니다\(\[RFC5280\], 섹션 3.2 참조\). 인증 경로를 시작하는 인증서는 "signature\_algorithms" 확장에서 지원되는 것으로 광고되지 않은 서명 알고리즘을 사용할 수 있습니다.

TLS 1.2는 이 확장을 다르게 정의합니다. TLS 1.2를 협상하려는 TLS 1.3 구현은 해당 버전을 협상할 때 \[RFC5246\]의 요구 사항에 따라 작동해야 합니다. 특히:

- TLS 1.2 ClientHellos는 이 확장을 생략할 수 있습니다.

- TLS 1.2에서는 확장에 해시/서명 쌍이 포함되었습니다. 쌍은 두 개의 옥텟으로 인코딩되므로 TLS 1.2의 인코딩에 맞춰 SignatureScheme 값이 할당되었습니다. 일부 레거시 쌍은 할당되지 않은 상태로 남아 있습니다. 이러한 알고리즘은 TLS 1.3부터 ​​더 이상 사용되지 않습니다. 어떠한 구현에서도 이를 제안하거나 협상해서는 안 됩니다. 특히 MD5 \[SLOTH\], SHA-224 및 DSA는 사용하면 안 됩니다.

- ECDSA 서명 체계는 TLS 1.2의 ECDSA 해시/서명 쌍과 일치합니다. 그러나 이전 의미론은 서명 곡선을 제한하지 않았습니다. TLS 1.2가 협상되는 경우 구현은 "supported\_groups" 확장에서 광고한 모든 곡선을 사용하는 서명을 수락하도록 준비되어야 합니다.

- RSASSA-PSS\(TLS 1.3에서 필수\)에 대한 지원을 광고하는 구현은 TLS 1.2가 협상되는 경우에도 해당 체계를 사용하여 서명을 수락할 준비를 해야 합니다. TLS 1.2에서는 RSASSA-PSS가 RSA 암호화 제품군과 함께 사용됩니다.

---
#### **4.2.4.  Certificate Authorities**

"certificate\_authorities" 확장은 엔드포인트가 지원하고 인증서 선택을 안내하기 위해 수신 엔드포인트에서 사용해야 하는 CA\(인증 기관\)를 나타내는 데 사용됩니다.

"certificate\_authorities" 확장의 본문은 CertificateAuthoritiesExtension 구조로 구성됩니다.

```text
      opaque DistinguishedName<1..2^16-1>;

      struct {
          DistinguishedName authorities<3..2^16-1>;
      } CertificateAuthoritiesExtension;
```

Authority: DER로 인코딩된 \[X690\] 형식으로 표시되는 허용되는 인증 기관의 고유 이름 \[X501\] 목록입니다. 이러한 고유 이름은 트러스트 앵커 또는 하위 CA에 대해 원하는 고유 이름을 지정합니다. 따라서 이 메시지는 알려진 트러스트 앵커와 원하는 인증 공간을 설명하는 데 사용될 수 있습니다.

클라이언트는 ClientHello 메시지에 "certificate\_authorities" 확장을 보낼 수 있습니다. 서버는 이를 CertificateRequest 메시지로 보낼 수도 있습니다.

유사한 목적을 제공하지만 더 복잡한 "trusted\_ca\_keys" 확장 \[RFC6066\]은 TLS 1.3에서 사용되지 않습니다\(단, 이전 버전의 TLS를 제공하는 클라이언트의 ClientHello 메시지에 나타날 수 있음\).

---
#### **4.2.5.  OID Filters**

"oid\_filters" 확장을 사용하면 서버는 클라이언트의 인증서와 일치시키려는 OID/값 쌍 집합을 제공할 수 있습니다. 이 확장은 서버에서 제공하는 경우 CertificateRequest 메시지로만 전송되어야 합니다.

```text
      struct {
          opaque certificate_extension_oid<1..2^8-1>;
          opaque certificate_extension_values<0..2^16-1>;
      } OIDFilter;

      struct {
          OIDFilter filters<0..2^16-1>;
      } OIDFilterExtension;
```

필터: 허용되는 값을 포함하고 DER 인코딩 \[X690\] 형식으로 표현되는 인증서 확장 OID \[RFC5280\] 목록입니다. 일부 인증서 확장 OID는 여러 값\(예: 확장 키 사용\)을 허용합니다. 서버가 비어 있지 않은 필터 목록을 포함했다면 응답에 포함된 클라이언트 인증서에는 클라이언트가 인식하는 지정된 확장 OID가 모두 포함되어야 합니다. 클라이언트가 인식하는 각 확장 OID에 대해 지정된 모든 값은 클라이언트 인증서에 있어야 합니다\(그러나 인증서에는 다른 값도 있을 수 있습니다\). 그러나 클라이언트는 인식되지 않은 인증서 확장 OID를 무시하고 건너뛰어야 합니다. 클라이언트가 필수 인증서 확장 OID 중 일부를 무시하고 요청을 충족하지 않는 인증서를 제공한 경우 서버는 재량에 따라 클라이언트 인증 없이 연결을 계속하거나 "unsupported\_certificate" 경고와 함께 핸드셰이크를 중단할 수 있습니다. 주어진 OID는 필터 목록에 두 번 이상 나타나서는 안 됩니다.

PKIX RFC는 다양한 인증서 확장 OID와 해당 값 유형을 정의합니다. 유형에 따라 일치하는 인증서 확장 값이 반드시 비트 단위로 같지는 않습니다. TLS 구현은 인증서 확장 OID를 사용하여 인증서 선택을 수행하기 위해 PKI 라이브러리에 의존할 것으로 예상됩니다.

이 문서는 \[RFC5280\]에 정의된 두 가지 표준 인증서 확장에 대한 일치 규칙을 정의합니다.

- 요청에서 주장된 모든 키 사용 비트가 키 사용 인증서 확장에서도 주장될 때 인증서의 키 사용 확장은 요청과 일치합니다.

- 요청에 존재하는 모든 키 목적 OID가 확장 키 사용 인증서 확장에서도 발견되면 인증서의 확장 키 사용 확장이 요청과 일치합니다. 특별한 anyExtendedKeyUsage OID는 요청에 사용되어서는 안 됩니다.

별도의 사양은 다른 인증서 확장에 대한 일치 규칙을 정의할 수 있습니다.

---
#### **4.2.6.  Post-Handshake Client Authentication**

"post\_handshake\_auth" 확장은 클라이언트가 핸드셰이크 후 인증을 수행할 의사가 있음을 나타내는 데 사용됩니다\(섹션 4.6.2\). 서버는 이 확장을 제공하지 않는 클라이언트에 핸드셰이크 후 CertificateRequest를 보내면 안 됩니다. 서버는 이 확장을 보내면 안 됩니다.

```text
      struct {} PostHandshakeAuth;
```

"post\_handshake\_auth" 확장의 "extension\_data" 필드 길이가 0입니다.

---
#### **4.2.7.  Supported Groups**

클라이언트가 전송하는 경우 "supported\_groups" 확장은 클라이언트가 키 교환을 지원하는 명명된 그룹을 나타내며 가장 선호하는 것부터 가장 선호하지 않는 것 순으로 정렬됩니다.

참고: TLS 1.3 이전 버전의 TLS에서는 이 확장의 이름이 "elliptic\_curves"로 지정되었으며 타원 곡선 그룹만 포함되었습니다. \[RFC8422\] 및 \[RFC7919\]를 참조하세요. 이 확장은 ECDSA 곡선을 협상하는 데에도 사용되었습니다. 서명 알고리즘은 이제 독립적으로 협상됩니다\(섹션 4.2.3 참조\).

이 확장의 "extension\_data" 필드에는 "NamedGroupList" 값이 포함되어 있습니다.

```text
      enum {

          /* Elliptic Curve Groups (ECDHE) */
          secp256r1(0x0017), secp384r1(0x0018), secp521r1(0x0019),
          x25519(0x001D), x448(0x001E),

          /* Finite Field Groups (DHE) */
          ffdhe2048(0x0100), ffdhe3072(0x0101), ffdhe4096(0x0102),
          ffdhe6144(0x0103), ffdhe8192(0x0104),

          /* Reserved Code Points */
          ffdhe_private_use(0x01FC..0x01FF),
          ecdhe_private_use(0xFE00..0xFEFF),
          (0xFFFF)
      } NamedGroup;

      struct {
          NamedGroup named_group_list<2..2^16-1>;
      } NamedGroupList;
```

ECDHE\(타원 곡선 그룹\): FIPS 186-4 \[DSS\] 또는 \[RFC7748\]에 정의된 해당 명명된 곡선에 대한 지원을 나타냅니다. 0xFE00부터 0xFEFF까지의 값은 개인용으로 예약되어 있습니다\[RFC8126\].

유한 필드 그룹\(DHE\): \[RFC7919\]에 정의된 해당 유한 필드 그룹에 대한 지원을 나타냅니다. 0x01FC부터 0x01FF까지의 값은 개인용으로 예약되어 있습니다.

명명된\_그룹\_목록의 항목은 보낸 사람의 기본 설정에 따라 순서가 지정됩니다\(가장 선호하는 항목부터\).

TLS 1.3부터 ​​서버는 "supported\_groups" 확장을 클라이언트에 보내는 것이 허용됩니다. 클라이언트는 핸드셰이크가 성공적으로 완료되기 전에 "supported\_groups"에서 발견된 정보에 따라 조치를 취해서는 안 되지만\(MUST NOT\) 성공적으로 완료된 핸드셰이크에서 배운 정보를 사용하여 후속 연결의 "key\_share" 확장에서 사용하는 그룹을 변경할 수 있습니다. 서버에 "key\_share" 확장의 그룹보다 선호하는 그룹이 있지만 여전히 ClientHello를 수락할 의향이 있는 경우 "supported\_groups"를 전송하여 클라이언트의 기본 설정 보기를 업데이트해야 합니다. 이 확장은 클라이언트가 현재 지원하는지 여부에 관계없이 서버가 지원하는 모든 그룹을 포함해야 합니다.

---
#### **4.2.8.  Key Share**

"key\_share" 확장에는 엔드포인트의 암호화 매개변수가 포함되어 있습니다.

클라이언트는 추가 왕복 비용으로 서버에서 그룹 선택을 요청하기 위해 빈 client\_shares 벡터를 보낼 수 있습니다\(섹션 4.1.4 참조\).

```text
      struct {
          NamedGroup group;
          opaque key_exchange<1..2^16-1>;
      } KeyShareEntry;
```

그룹: 교환되는 키에 대해 명명된 그룹입니다.

key\_exchange: 키 교환 정보입니다. 이 필드의 내용은 지정된 그룹 및 해당 정의에 따라 결정됩니다. 유한 필드 Diffie-Hellman \[DH76\] 매개변수는 섹션 4.2.8.1에 설명되어 있습니다. 타원 곡선 Diffie-Hellman 매개변수는 섹션 4.2.8.2에 설명되어 있습니다.

ClientHello 메시지에서 이 확장의 "extension\_data" 필드에는 "KeyShareClientHello" 값이 포함되어 있습니다.

```text
      struct {
          KeyShareEntry client_shares<0..2^16-1>;
      } KeyShareClientHello;
```

client\_shares: 클라이언트 선호도 내림차순으로 제공되는 KeyShareEntry 값 목록입니다.

클라이언트가 HelloRetryRequest를 요청하는 경우 이 벡터는 비어 있을 수 있습니다. 각 KeyShareEntry 값은 "supported\_groups" 확장에서 제공되는 그룹과 일치해야 하며 동일한 순서로 나타나야 합니다. 그러나 값은 "supported\_groups" 확장의 연속되지 않은 하위 집합일 수 있으며 가장 선호하는 그룹을 생략할 수 있습니다. 이러한 상황은 가장 선호하는 그룹이 새로운 그룹이고 사전 생성된 주요 공유를 효율적으로 만들 수 있는 충분한 장소에서 지원되지 않을 경우 발생할 수 있습니다.

클라이언트는 지원되는 그룹 수만큼 많은 KeyShareEntry 값을 제공할 수 있으며, 각 값은 단일 키 교환 매개변수 세트를 나타냅니다. 예를 들어 클라이언트는 여러 타원 곡선 또는 여러 FFDHE 그룹에 대한 공유를 제공할 수 있습니다. 각 KeyShareEntry에 대한 key\_exchange 값은 독립적으로 생성되어야 합니다. 클라이언트는 동일한 그룹에 대해 여러 KeyShareEntry 값을 제공해서는 안 됩니다. 클라이언트는 클라이언트의 "supported\_groups" 확장에 나열되지 않은 그룹에 대해 KeyShareEntry 값을 제공해서는 안 됩니다. 서버는 이러한 규칙 위반을 확인하고 위반할 경우 "illegal\_parameter" 경고와 함께 핸드셰이크를 중단할 수 있습니다.

HelloRetryRequest 메시지에서 이 확장의 "extension\_data" 필드에는 KeyShareHelloRetryRequest 값이 포함되어 있습니다.

```text
      struct {
          NamedGroup selected_group;
      } KeyShareHelloRetryRequest;
```

selected\_group: 서버가 협상하려고 하며 재시도된 ClientHello/KeyShare를 요청하는 상호 지원되는 그룹입니다.

HelloRetryRequest에서 이 확장을 수신하면 클라이언트는 \(1\) selected\_group 필드가 원래 ClientHello의 "supported\_groups" 확장에 제공된 그룹에 해당하고 \(2\) selected\_group 필드가 그룹에 해당하지 않는지 확인해야 합니다. 이는 원래 ClientHello의 "key\_share" 확장에 제공되었습니다. 이러한 검사 중 하나라도 실패하면 클라이언트는 "illegal\_parameter" 경고와 함께 핸드셰이크를 중단해야 합니다. 그렇지 않으면 새 ClientHello를 보낼 때 클라이언트는 반드시

원래 "key\_share" 확장을 트리거하는 HelloRetryRequest의 selected\_group 필드에 표시된 그룹에 대한 새 KeyShareEntry만 포함하는 확장으로 바꿉니다.

ServerHello 메시지에서 이 확장의 "extension\_data" 필드에는 KeyShareServerHello 값이 포함됩니다.

```text
      struct {
          KeyShareEntry server_share;
      } KeyShareServerHello;
```

server\_share: 클라이언트 공유 중 하나와 동일한 그룹에 있는 단일 KeyShareEntry 값입니다.

\(EC\)DHE 키 설정을 사용하는 경우 서버는 ServerHello에서 정확히 하나의 KeyShareEntry를 제공합니다. 이 값은 서버가 협상된 키 교환을 위해 선택한 클라이언트가 제공하는 KeyShareEntry 값과 동일한 그룹에 있어야 합니다. 서버는 클라이언트의 "supported\_groups" 확장에 표시되지 않은 그룹에 대해 KeyShareEntry를 보내서는 안 되며 "psk\_ke" PskKeyExchangeMode를 사용할 때 KeyShareEntry를 보내서는 안 됩니다. \(EC\)DHE 키 설정을 사용하고 "key\_share" 확장이 포함된 HelloRetryRequest가 클라이언트에 의해 수신된 경우 클라이언트는 ServerHello에서 선택된 NamedGroup이 HelloRetryRequest의 것과 동일한지 확인해야 합니다. 이 확인이 실패하면 클라이언트는 "illegal\_parameter" 경고와 함께 핸드셰이크를 중단해야 합니다.

---
##### **4.2.8.1.  Diffie-Hellman Parameters**

클라이언트와 서버 모두에 대한 Diffie-Hellman \[DH76\] 매개변수는 KeyShare 구조에 있는 KeyShareEntry의 불투명 key\_exchange 필드에 인코딩됩니다. 불투명 값에는 빅 엔디안 정수로 인코딩된 지정된 그룹\(그룹 정의는 \[RFC7919\] 참조\)에 대한 Diffie-Hellman 공개 값\(Y = g^X mod p\)이 포함되며 왼쪽에는 다음 크기만큼 0이 채워집니다. p\(바이트\)입니다.

참고: 특정 Diffie-Hellman 그룹의 경우 패딩으로 인해 모든 공개 키의 길이가 동일해집니다.

피어는 1 < Y ​​< p-1을 보장하여 서로의 공개 키 Y를 검증해야 합니다. 이 검사를 통해 원격 피어가 제대로 작동하고 로컬 시스템을 작은 하위 그룹으로 강제로 분류하지 않는지 확인합니다.

---
##### **4.2.8.2.  ECDHE Parameters**

클라이언트와 서버 모두에 대한 ECDHE 매개변수는 KeyShare 구조에 있는 KeyShareEntry의 불투명 key\_exchange 필드에 인코딩됩니다.

secp256r1, secp384r1 및 secp521r1의 경우 내용은 다음 구조체의 직렬화된 값입니다.

```text
      struct {
          uint8 legacy_form = 4;
          opaque X[coordinate_length];
          opaque Y[coordinate_length];
      } UncompressedPointRepresentation;
```

X와 Y는 각각 네트워크 바이트 순서로 된 x와 y 값의 이진 표현입니다. 내부 길이 표시가 없으므로 각 숫자 표현은 곡선 매개변수에 의해 암시된 만큼의 옥텟을 차지합니다. P-256의 경우 이는 X와 Y 각각이 32옥텟을 사용하고 필요한 경우 왼쪽이 0으로 채워짐을 의미합니다. P-384의 경우 각각 48옥텟을 사용합니다. P-521의 경우 각각 66옥텟을 사용합니다.

곡선 secp256r1, secp384r1 및 secp521r1의 경우 피어는 해당 점이 타원 곡선의 유효한 점인지 확인하여 서로의 공개 값 Q를 검증해야 합니다. 적절한 검증 절차는 \[ECDSA\]의 섹션 4.3.7과 \[KEYAGREEMENT\]의 섹션 5.6.2.3에 정의되어 있습니다. 이 프로세스는 세 단계로 구성됩니다. \(1\) Q가 무한대\(O\)에 있는 점이 아닌지 확인하고, \(2\) Q = \(x, y\)에 대해 정수 x와 y가 모두 올바른 구간에 있는지 확인하고, \(3\) \) \(x, y\)가 타원 곡선 방정식에 대한 올바른 해인지 확인합니다. 이러한 곡선의 경우 구현자는 올바른 하위 그룹의 구성원인지 확인할 필요가 없습니다.

X25519 및 X448의 경우 공개 값의 내용은 \[RFC7748\]에 정의된 해당 함수의 바이트 문자열 입력 및 출력입니다. X25519의 경우 32바이트, X448의 경우 56바이트입니다.

참고: 1.3 이전 TLS 버전에서는 포인트 형식 협상이 허용되었습니다. TLS 1.3에서는 각 곡선에 대한 단일 포인트 형식을 선호하여 이 기능을 제거했습니다.

---
#### **4.2.9.  Pre-Shared Key Exchange Modes**

PSK를 사용하려면 클라이언트가 "psk\_key\_exchange\_modes" 확장도 보내야 합니다. 이 확장의 의미는 클라이언트가 이러한 모드의 PSK 사용만 지원한다는 것입니다. 이는 이 ClientHello에서 제공되는 PSK의 사용과 서버가 NewSessionTicket을 통해 제공할 수 있는 PSK의 사용을 모두 제한합니다.

클라이언트는 "pre\_shared\_key" 확장을 제공하는 경우 "psk\_key\_exchange\_modes" 확장을 제공해야 합니다. 클라이언트가 "psk\_key\_exchange\_modes" 확장 없이 "pre\_shared\_key"를 제공하는 경우 서버는 핸드셰이크를 중단해야 합니다. 서버는 클라이언트에 나열되지 않은 키 교환 모드를 선택해서는 안 됩니다. 이 확장은 PSK 재개에 사용할 모드도 제한합니다. 서버는 광고 모드와 호환되지 않는 티켓과 함께 NewSessionTicket을 보내면 안 됩니다. 그러나 서버가 그렇게 하면 클라이언트의 재개 시도가 실패하게 됩니다.

서버는 "psk\_key\_exchange\_modes" 확장을 보내면 안 됩니다.

```text
      enum { psk_ke(0), psk_dhe_ke(1), (255) } PskKeyExchangeMode;

      struct {
          PskKeyExchangeMode ke_modes<1..255>;
      } PskKeyExchangeModes;
```

psk\_ke: PSK 전용 키 설정입니다. 이 모드에서 서버는 "key\_share" 값을 제공하면 안 됩니다.

psk\_dhe\_ke: \(EC\)DHE 키가 설정된 PSK입니다. 이 모드에서 클라이언트와 서버는 섹션 4.2.8에 설명된 대로 "key\_share" 값을 제공해야 합니다.

할당되는 모든 미래 값은 전송된 프로토콜 메시지가 서버에서 선택한 모드를 명확하게 식별하도록 보장해야 합니다. 현재 이는 ServerHello에 "key\_share"가 있음으로 표시됩니다.

---
#### **4.2.10.  Early Data Indication**

PSK가 사용되고 해당 PSK에 대한 초기 데이터가 허용되면 클라이언트는 첫 번째 메시지에서 애플리케이션 데이터를 보낼 수 있습니다. 클라이언트가 그렇게 하기로 선택한 경우 "pre\_shared\_key" 및 "early\_data" 확장을 모두 제공해야 합니다.

이 확장의 "extension\_data" 필드에는 "EarlyDataIndication" 값이 포함되어 있습니다.

```text
      struct {} Empty;

      struct {
          select (Handshake.msg_type) {
              case new_session_ticket:   uint32 max_early_data_size;
              case client_hello:         Empty;
              case encrypted_extensions: Empty;
          };
      } EarlyDataIndication;
```

max\_early\_data\_size 필드 사용에 대한 자세한 내용은 섹션 4.6.1을 참조하세요.

0-RTT 데이터\(버전, 대칭 암호화 제품군, ALPN\(Application-Layer Protocol Negotiation\) \[RFC7301\] 프로토콜 등\)에 대한 매개변수는 사용 중인 PSK와 관련된 매개변수입니다. 외부에서 프로비저닝된 PSK의 경우 관련 값은 키와 함께 프로비저닝된 값입니다. NewSessionTicket 메시지를 통해 설정된 PSK의 경우 관련 값은 PSK를 설정한 연결에서 협상된 값입니다. 초기 데이터를 암호화하는 데 사용되는 PSK는 클라이언트의 "pre\_shared\_key" 확장에 나열된 첫 번째 PSK여야 합니다.

NewSessionTicket을 통해 프로비저닝된 PSK의 경우, 서버는 선택한 PSK ID의 티켓 수명\(PskIdentity.obfuscated\_ticket\_age 모듈로 2^32에서 ticket\_age\_add를 빼서 계산\)이 티켓이 발행된 이후 시간의 작은 허용 범위 내에 있는지 확인해야 합니다\(섹션 8 참조\). \). 그렇지 않은 경우 서버는 핸드셰이크를 진행해야 하지만 0-RTT를 거부해야 하며 이 ClientHello가 신선하다고 가정하는 다른 조치를 취해서는 안 됩니다.

첫 번째 플라이트에서 전송된 0-RTT 메시지는 다른 플라이트에서 전송된 동일한 유형의 메시지\(핸드셰이크 및 애플리케이션\_데이터\)와 동일한\(암호화된\) 콘텐츠 유형을 가지지만 다른 키로 보호됩니다. 서버의 Finished 메시지를 수신한 후 서버가 초기 데이터를 수락한 경우 EndOfEarlyData 메시지가 전송되어 키 변경을 나타냅니다. 이 메시지는 0-RTT 트래픽 키로 암호화됩니다.

"early\_data" 확장을 수신하는 서버는 다음 세 가지 방법 중 하나로 동작해야 합니다.

- 확장명을 무시하고 일반 1-RTT 응답을 반환합니다. 그런 다음 서버는 핸드셰이크 트래픽 키를 사용하여 수신된 레코드의 보호 해제를 시도하고 보호 해제에 실패한 레코드를 삭제하여 이전 초기 데이터를 건너뜁니다\(구성된 max\_early\_data\_size까지\). 레코드의 보호가 성공적으로 해제되면 이는 클라이언트의 두 번째 비행이 시작된 것으로 간주되고 서버는 일반 1-RTT 핸드셰이크와 마찬가지로 진행됩니다.

- 클라이언트가 HelloRetryRequest로 응답하여 다른 ClientHello를 보내도록 요청합니다. 클라이언트는 후속 ClientHello에 "early\_data" 확장을 포함하면 안 됩니다. 그런 다음 서버는 구성된 max\_early\_data\_size까지 외부 콘텐츠 유형이 "application\_data"\(암호화되었음을 나타냄\)인 모든 레코드를 건너뛰어 초기 데이터를 무시합니다.

- EncryptedExtensions에 자체 "early\_data" 확장을 반환하여 초기 데이터를 처리할 것임을 나타냅니다. 서버가 초기 데이터 메시지의 하위 집합만 수락하는 것은 불가능합니다. 서버가 초기 데이터를 수락하는 메시지를 보내더라도 서버가 이 메시지를 생성할 때 실제 초기 데이터 자체가 이미 비행 중일 수 있습니다.

초기 데이터를 수락하려면 서버가 PSK 암호화 제품군을 수락하고 클라이언트의 "pre\_shared\_key" 확장에 제공된 첫 번째 키를 선택해야 합니다. 또한 다음 값이 선택한 PSK와 관련된 값과 동일한지 확인해야 합니다.

- TLS 버전 번호

- 선택한 암호 제품군

- 선택한 ALPN \[RFC7301\] 프로토콜\(있는 경우\)

이러한 요구 사항은 해당 PSK를 사용하여 1-RTT 핸드셰이크를 수행하는 데 필요한 요구 사항의 상위 집합입니다. 외부에서 설정된 PSK의 경우 관련 값은 키와 함께 프로비저닝된 값입니다. NewSessionTicket 메시지를 통해 설정된 PSK의 경우 관련 값은 티켓이 설정된 동안 연결에서 협상된 값입니다.

향후 확장은 0-RTT와의 상호 작용을 정의해야 합니다.

이러한 검사 중 하나라도 실패하면 서버는 확장으로 응답해서는 안 되며 위에 나열된 처음 두 메커니즘 중 하나를 사용하여 모든 첫 번째 비행 데이터를 삭제해야 합니다\(따라서 1-RTT 또는 2-RTT로 대체\). 클라이언트가 0-RTT 핸드셰이크를 시도하지만 서버가 이를 거부하는 경우 서버는 일반적으로 0-RTT 레코드 보호 키를 갖지 않으며 대신 시험 복호화\(1-RTT 핸드셰이크 키를 사용하거나 일반 텍스트 ClientHello를 검색하여\)를 사용해야 합니다. HelloRetryRequest의 경우\) 0-RTT가 아닌 첫 번째 메시지를 찾습니다.

서버가 "early\_data" 확장을 허용하기로 선택한 경우, 초기 데이터 레코드를 처리할 때 모든 레코드에 대해 지정된 동일한 오류 처리 요구 사항을 준수해야 합니다. 특히, 서버가 허용된 "early\_data" 확장에 이어 0-RTT 레코드의 암호 해독에 실패하는 경우 섹션 5.2에 따라 "bad\_record\_mac" 경고와 함께 연결을 종료해야 합니다.

서버가 "early\_data" 확장을 거부하는 경우 클라이언트 애플리케이션은 핸드셰이크가 완료된 후 이전에 초기 데이터로 전송된 애플리케이션 데이터를 재전송하도록 선택할 수 있습니다. 초기 데이터의 자동 재전송으로 인해 연결 상태에 관한 잘못된 가정이 발생할 수 있습니다. 예를 들어 협상된 연결이 초기 데이터에 사용된 것과 다른 ALPN 프로토콜을 선택하는 경우 애플리케이션은 다른 메시지를 구성해야 할 수도 있습니다. 마찬가지로 초기 데이터가 연결 상태에 대해 가정하는 경우 핸드셰이크가 완료된 후 오류가 발생하여 전송될 수 있습니다.

TLS 구현은 초기 데이터를 자동으로 다시 전송해서는 안 됩니다. 애플리케이션은 재전송이 적절한 시기를 결정하는 데 더 나은 위치에 있습니다. TLS 구현은 협상된 연결이 동일한 ALPN 프로토콜을 선택하지 않는 한 초기 데이터를 자동으로 다시 전송해서는 안 됩니다.

---
#### **4.2.11.  Pre-Shared Key Extension**

"pre\_shared\_key" 확장은 PSK 키 설정과 관련하여 특정 핸드셰이크에 사용할 사전 공유 키의 ID를 협상하는 데 사용됩니다.

이 확장 프로그램의 "extension\_data" 필드에는 "PreSharedKeyExtension" 값이 포함되어 있습니다.

```text
      struct {
          opaque identity<1..2^16-1>;
          uint32 obfuscated_ticket_age;
      } PskIdentity;

      opaque PskBinderEntry<32..255>;

      struct {
          PskIdentity identities<7..2^16-1>;
          PskBinderEntry binders<33..2^16-1>;
      } OfferedPsks;

      struct {
          select (Handshake.msg_type) {
              case client_hello: OfferedPsks;
              case server_hello: uint16 selected_identity;
          };
      } PreSharedKeyExtension;
```

ID: 키에 대한 레이블입니다. 예를 들어 티켓\(부록 B.3.4에 정의됨\) 또는 외부에서 설정된 사전 공유 키에 대한 레이블이 있습니다.

obfuscated\_ticket\_age: 키 수명의 난독화된 버전입니다. 섹션 4.2.11.1에서는 NewSessionTicket 메시지를 통해 설정된 ID에 대해 이 값을 구성하는 방법을 설명합니다. 외부적으로 설정된 ID의 경우 obfuscated\_ticket\_age가 0이어야 하며 서버는 이 값을 무시해야 합니다.

ID: 클라이언트가 서버와 협상하려는 ID 목록입니다. "early\_data" 확장명\(섹션 4.2.10 참조\)과 함께 전송되는 경우 첫 번째 ID는 0-RTT 데이터에 사용되는 ID입니다.

바인더: 일련의 HMAC 값\(ID 목록의 각 값에 대해 하나씩, 동일한 순서로, 아래 설명된 대로 계산됨\)

selected\_identity: 클라이언트 목록의 ID에 대한 \(0 기반\) 인덱스로 표현되는 서버가 선택한 ID입니다.

각 PSK는 단일 해시 알고리즘과 연결됩니다. 티켓 메커니즘\(섹션 4.6.1\)을 통해 설정된 PSK의 경우 이는 티켓이 설정된 연결의 KDF 해시 알고리즘입니다. 외부에서 설정된 PSK의 경우 다음과 같은 경우 해시 알고리즘을 설정해야 합니다.

해당 알고리즘이 정의되지 않은 경우 PSK가 설정되거나 기본적으로 SHA-256으로 설정됩니다. 서버는 호환 가능한 PSK\(있는 경우\) 및 암호화 제품군을 선택하는지 확인해야 합니다.

TLS 1.3 이전의 TLS 버전에서는 서버 이름 식별\(SNI\) 값이 세션과 연결되도록 의도되었으며\(\[RFC6066\]의 섹션 3\), 서버는 세션과 연결된 SNI 값이 세션과 일치하도록 강제해야 합니다. 재개 핸드셰이크에 지정된 것입니다. 그러나 실제로 구현은 제공된 두 SNI 값 중 어떤 값을 사용할지 일관성이 없었으며, 이로 인해 일관성 요구 사항이 클라이언트에 의해 사실상 강제되었습니다. TLS 1.3에서는 SNI 값이 항상 재개 핸드셰이크에 명시적으로 지정되므로 서버가 SNI 값을 티켓과 연결할 필요가 없습니다. 그러나 클라이언트는 섹션 4.6.1의 요구 사항을 충족하기 위해 SNI를 PSK와 함께 저장해야 합니다.

구현자 참고 사항: 세션 재개가 PSK의 기본 사용 사례인 경우 PSK/암호화 모음 일치 요구 사항을 구현하는 가장 간단한 방법은 먼저 암호 모음을 협상한 다음 호환되지 않는 PSK를 제외하는 것입니다. 알 수 없는 PSK\(예: PSK 데이터베이스에 없거나 알 수 없는 키로 암호화된 PSK\)는 무시해야 합니다. 허용 가능한 PSK가 발견되지 않으면 서버는 가능하면 PSK가 아닌 핸드셰이크를 수행해야 합니다\(SHOULD\). 이전 버전과의 호환성이 중요한 경우 클라이언트가 제공하고 외부에서 설정된 PSK가 암호 제품군 선택에 영향을 주어야 합니다.

PSK 키 설정을 수락하기 전에 서버는 해당 바인더 값을 검증해야 합니다\(아래 섹션 4.2.11.2 참조\). 이 값이 없거나 유효성을 검사하지 않으면 서버는 핸드셰이크를 중단해야 합니다. 서버는 여러 바인더의 유효성을 검사하려고 시도해서는 안 됩니다. 오히려 단일 PSK를 선택하고 해당 PSK에 해당하는 바인더만 유효성을 검사해야 합니다. 이 요구 사항에 대한 보안 근거는 섹션 8.2 및 부록 E.6을 참조하세요. PSK 키 설정을 수락하기 위해 서버는 선택된 ID를 나타내는 "pre\_shared\_key" 확장을 보냅니다.

클라이언트는 서버의 selected\_identity가 클라이언트가 제공한 범위 내에 있는지, 서버가 PSK와 관련된 해시를 나타내는 암호 그룹을 선택했는지, ClientHello "psk\_key\_exchange\_modes" 확장에 필요한 경우 서버 "key\_share" 확장이 존재하는지 확인해야 합니다. . 이러한 값이 일관성이 없으면 클라이언트는 "illegal\_parameter" 경고와 함께 핸드셰이크를 중단해야 합니다.

서버가 "early\_data" 확장을 제공하는 경우 클라이언트는 서버의 selected\_identity가 0인지 확인해야 합니다. 다른 값이 반환되면 클라이언트는 "illegal\_parameter" 경고와 함께 핸드셰이크를 중단해야 합니다.

"pre\_shared\_key" 확장은 ClientHello의 마지막 확장이어야 합니다\(이것은 아래 설명된 구현을 용이하게 합니다\). 서버는 반드시 그것이 마지막 확장인지 확인해야 하며, 그렇지 않으면 "illegal\_parameter" 경고와 함께 핸드셰이크가 실패합니다.

---
##### **4.2.11.1.  Ticket Age**

클라이언트가 보는 티켓 기간은 NewSessionTicket 메시지를 받은 이후의 시간입니다. 클라이언트는 티켓과 함께 제공된 "ticket\_lifetime" 값보다 오래 지속되는 티켓을 사용하려고 시도해서는 안 됩니다. 각 PskIdentity의 "obfuscated\_ticket\_age" 필드에는 밀리초 단위의 기간을 취하고 티켓에 포함된 "ticket\_age\_add" 값\(섹션 4.6.1 참조\)을 모듈로 2^32로 추가하여 형성된 티켓 기간의 난독화된 버전이 포함되어 있습니다. 이렇게 추가하면 티켓이 재사용되지 않는 한 수동적 관찰자가 연결을 연관시키는 것을 방지할 수 있습니다. NewSessionTicket 메시지의 "ticket\_lifetime" 필드는 초 단위이지만 "obfuscated\_ticket\_age"는 밀리초 단위입니다. 티켓 수명은 일주일로 제한되어 있으므로 32비트이면 모든 가능한 연령을 밀리초 단위로 표현하는 데 충분합니다.

---
##### **4.2.11.2.  PSK Binder**

PSK 바인더 값은 PSK와 현재 핸드셰이크 간의 바인딩뿐만 아니라 PSK가 생성된 핸드셰이크\(NewSessionTicket 메시지를 통한 경우\)와 현재 핸드셰이크 간의 바인딩도 형성합니다. 바인더 목록의 각 항목은 PreSharedKeyExtension.identities 필드까지 부분 ClientHello를 포함하는 기록 해시\(섹션 4.4.1 참조\)에 대한 HMAC로 계산됩니다. 즉, 모든 ClientHello를 포함하지만 바인더 목록 자체는 포함하지 않습니다. 메시지의 길이 필드\(전체 길이, 확장 블록의 길이 및 "pre\_shared\_key" 확장의 길이 포함\)는 모두 올바른 길이의 바인더가 있는 것처럼 설정됩니다.

PskBinderEntry는 완료 메시지\(섹션 4.4.4\)와 동일한 방식으로 계산되지만 BaseKey는 제공되는 해당 PSK의 키 일정을 통해 파생된 바인더\_키입니다\(섹션 7.1 참조\).

핸드셰이크에 HelloRetryRequest가 포함된 경우 초기 ClientHello 및 HelloRetryRequest가 새 ClientHello와 함께 기록에 포함됩니다. 예를 들어 클라이언트가 ClientHello1을 보내는 경우 해당 바인더는 다음을 통해 계산됩니다.

```text
      Transcript-Hash(Truncate(ClientHello1))
```

Truncate\(\)는 ClientHello에서 바인더 목록을 제거합니다.

서버가 HelloRetryRequest로 응답하고 클라이언트가 ClientHello2를 보내는 경우 해당 바인더는 다음을 통해 계산됩니다.

```text
      Transcript-Hash(ClientHello1,
                      HelloRetryRequest,
                      Truncate(ClientHello2))
```

전체 ClientHello1/ClientHello2는 다른 모든 핸드셰이크 해시 계산에 포함됩니다. 첫 번째 단계에서는 Truncate\(ClientHello1\)가 직접 해시되지만 두 번째 단계에서는 섹션 4.4.1에 설명된 대로 ClientHello1이 해시된 다음 "message\_hash" 메시지로 다시 주입됩니다.

---
##### **4.2.11.3.  Processing Order**

클라이언트는 서버의 Finished를 수신할 때까지 0-RTT 데이터를 "스트리밍"한 다음 EndOfEarlyData 메시지를 전송하고 나머지 핸드셰이크를 전송하는 것이 허용됩니다. 교착 상태를 피하기 위해 "early\_data"를 수락할 때 서버는 ServerHello를 보내기 전에 클라이언트의 EndOfEarlyData 메시지를 기다리는 대신 클라이언트의 ClientHello를 처리한 다음 즉시 메시지 비행을 보내야 합니다.

---
### **4.3.  Server Parameters**

서버의 다음 두 메시지인 EncryptedExtensions 및 CertificateRequest에는 나머지 핸드셰이크를 결정하는 서버의 정보가 포함되어 있습니다. 이러한 메시지는 server\_handshake\_traffic\_secret에서 파생된 키로 암호화됩니다.

---
#### **4.3.1.  Encrypted Extensions**

모든 핸드셰이크에서 서버는 ServerHello 메시지 바로 다음에 EncryptedExtensions 메시지를 보내야 합니다. 이는 server\_handshake\_traffic\_secret에서 파생된 키로 암호화된 첫 번째 메시지입니다.

EncryptedExtensions 메시지에는 보호할 수 있는 확장, 즉 암호화 컨텍스트를 설정하는 데 필요하지 않지만 개별 인증서와 연결되지 않은 확장이 포함되어 있습니다. 클라이언트는 금지된 확장이 있는지 EncryptedExtensions를 확인해야 하며, 발견된 경우 "illegal\_parameter" 경고와 함께 핸드셰이크를 중단해야 합니다.

이 메시지의 구조:

```text
      struct {
          Extension extensions<0..2^16-1>;
      } EncryptedExtensions;
```

확장: 확장 목록입니다. 자세한 내용은 섹션 4.2의 표를 참조하세요.

---
#### **4.3.2.  Certificate Request**

인증서로 인증하는 서버는 선택적으로 클라이언트에게 인증서를 요청할 수 있습니다. 이 메시지가 전송되는 경우 EncryptedExtensions를 따라야 합니다.

이 메시지의 구조:

```text
      struct {
          opaque certificate_request_context<0..2^8-1>;
          Extension extensions<2..2^16-1>;
      } CertificateRequest;
```

Certificate\_request\_context: 인증서 요청을 식별하고 클라이언트의 인증서 메시지에 반영되는 불투명 문자열입니다. Certificate\_request\_context는 이 연결 범위 내에서 고유해야 합니다\(따라서 클라이언트 CertificateVerify 메시지의 재생을 방지함\). 이 필드는 섹션 4.6.2에 설명된 핸드셰이크 후 인증 교환에 사용되지 않는 한 길이가 0이어야 합니다. 핸드셰이크 후 인증을 요청할 때 서버는 클라이언트의 개인 키에 임시로 액세스하는 공격자가 유효한 CertificateVerify 메시지를 미리 계산하는 것을 방지하기 위해 클라이언트가 컨텍스트를 예측할 수 없도록\(예: 임의로 생성하여\) 만들어야 합니다.

확장: 요청되는 인증서의 매개변수를 설명하는 확장 세트입니다. "signature\_algorithms" 확장은 반드시 지정되어야 하며, 이 메시지에 대해 정의된 경우 다른 확장이 선택적으로 포함될 수 있습니다. 클라이언트는 인식할 수 없는 확장을 무시해야 합니다.

이전 버전의 TLS에서는 CertificateRequest 메시지에 서버가 수락하는 서명 알고리즘 및 인증 기관 목록이 포함되었습니다. TLS 1.3에서 전자는 "signature\_algorithms" 및 선택적으로 "signature\_algorithms\_cert" 확장을 전송하여 표현됩니다. 후자는 "certificate\_authorities" 확장을 전송하여 표현됩니다\(섹션 4.2.4 참조\).

PSK로 인증하는 서버는 클라이언트가 "post\_handshake\_auth" 확장\(섹션 4.2 참조\)을 보낸 경우 사후 핸드셰이크 인증\(섹션 4.6.2 참조\)으로 보낼 수 있지만 기본 핸드셰이크에서 CertificateRequest 메시지를 보내서는 안 됩니다. .6\).

---
### **4.4.  Authentication Messages**

섹션 2에서 설명한 것처럼 TLS는 일반적으로 인증, 키 확인 및 핸드셰이크 무결성을 위해 인증서, 인증서 확인 및 완료됨이라는 공통 메시지 세트를 사용합니다. \(PSK 바인더도 비슷한 방식으로 키 확인을 수행합니다.\) 이 세 가지 메시지는 항상 핸드셰이크 비행의 마지막 메시지로 전송됩니다. Certificate 및 CertificateVerify 메시지는 아래 정의된 특정 상황에서만 전송됩니다. 완료 메시지는 항상 인증 블록의 일부로 전송됩니다. 이러한 메시지는 \[sender\]\_handshake\_traffic\_secret에서 파생된 키로 암호화됩니다.

인증 메시지에 대한 계산은 모두 다음과 같은 입력을 균일하게 사용합니다.

- 사용할 인증서 및 서명 키입니다.

- 성적 해시에 포함될 메시지 세트로 구성된 핸드셰이크 컨텍스트.

- MAC 키를 계산하는 데 사용되는 기본 키입니다.

이러한 입력을 기반으로 메시지에는 다음이 포함됩니다.

인증서: 인증에 사용되는 인증서 및 체인의 모든 지원 인증서입니다. PSK 핸드셰이크 흐름\(0-RTT 포함\)에서는 인증서 기반 클라이언트 인증을 사용할 수 없습니다.

CertificateVerify: Transcript-Hash\(Handshake Context, Certificate\) 값에 대한 서명입니다.

완료: 기본 키에서 파생된 MAC 키를 사용하여 Transcript-Hash\(Handshake Context, Certificate, CertificateVerify\) 값에 대한 MAC입니다.

다음 표에는 각 시나리오에 대한 핸드셰이크 컨텍스트 및 MAC 기본 키가 정의되어 있습니다.

```text
   +-----------+-------------------------+-----------------------------+
   | Mode      | Handshake Context       | Base Key                    |
   +-----------+-------------------------+-----------------------------+
   | Server    | ClientHello ... later   | server_handshake_traffic_   |
   |           | of EncryptedExtensions/ | secret                      |
   |           | CertificateRequest      |                             |
   |           |                         |                             |
   | Client    | ClientHello ... later   | client_handshake_traffic_   |
   |           | of server               | secret                      |
   |           | Finished/EndOfEarlyData |                             |
   |           |                         |                             |
   | Post-     | ClientHello ... client  | client_application_traffic_ |
   | Handshake | Finished +              | secret_N                    |
   |           | CertificateRequest      |                             |
   +-----------+-------------------------+-----------------------------+
```

---
#### **4.4.1.  The Transcript Hash**

TLS의 많은 암호화 계산은 성적표 해시를 사용합니다. 이 값은 핸드셰이크 메시지 유형 및 길이 필드를 전달하는 핸드셰이크 메시지 헤더를 포함하지만 레코드 계층 헤더는 포함하지 않는 포함된 각 핸드셰이크 메시지의 연결을 해싱하여 계산됩니다. 즉.,

```text
    Transcript-Hash(M1, M2, ... Mn) = Hash(M1 || M2 || ... || Mn)
```

이 일반 규칙의 예외로, 서버가 HelloRetryRequest를 사용하여 ClientHello에 응답할 때 ClientHello1의 값은 Hash\(ClientHello1\)를 포함하는 핸드셰이크 유형 "message\_hash"의 특수 합성 핸드셰이크 메시지로 대체됩니다. 즉.,

```text
  Transcript-Hash(ClientHello1, HelloRetryRequest, ... Mn) =
      Hash(message_hash ||        /* Handshake type */
           00 00 Hash.length  ||  /* Handshake message length (bytes) */
           Hash(ClientHello1) ||  /* Hash of ClientHello1 */
           HelloRetryRequest  || ... || Mn)
```

이 구성의 이유는 서버가 전체 중간 해시 상태를 내보내도록 요구하는 대신 쿠키에 ClientHello1의 해시만 저장하여 상태 비저장 HelloRetryRequest를 수행할 수 있도록 하기 위한 것입니다\(섹션 4.2.2 참조\).

구체적으로 말하면, 기록 해시는 항상 첫 번째 ClientHello에서 시작하여 전송된 메시지만 포함하는 다음 핸드셰이크 메시지 시퀀스에서 가져옵니다. ClientHello, HelloRetryRequest, ClientHello, ServerHello, EncryptedExtensions, 서버 CertificateRequest, 서버 인증서, 서버 CertificateVerify, 서버 완료, EndOfEarlyData, 클라이언트 인증서, 클라이언트 CertificateVerify, 클라이언트 완료.

일반적으로 구현에서는 협상된 해시를 기반으로 실행 중인 기록 해시 값을 유지하여 기록을 구현할 수 있습니다. 그러나 후속 핸드셰이크 후 인증에는 서로가 포함되지 않고 기본 핸드셰이크가 끝날 때까지의 메시지만 포함됩니다.

---
#### **4.4.2.  Certificate**

이 메시지는 엔드포인트의 인증서 체인을 피어에게 전달합니다.

서버는 합의된 키 교환 방법이 인증을 위해 인증서를 사용할 때마다 인증서 메시지를 보내야 합니다\(여기에는 PSK를 제외하고 이 문서에 정의된 모든 키 교환 방법이 포함됩니다\).

클라이언트는 서버가 CertificateRequest 메시지\(섹션 4.3.2\)를 통해 클라이언트 인증을 요청한 경우에만 인증서 메시지를 보내야 합니다. 서버가 클라이언트 인증을 요청했지만 적합한 인증서를 사용할 수 없는 경우 클라이언트는 인증서가 포함되지 않은\(즉, "certificate\_list" 필드의 길이가 0인\) 인증서 메시지를 보내야 합니다. 완료 메시지는 인증서 메시지가 비어 있는지 여부에 관계없이 전송되어야 합니다.

이 메시지의 구조:

```text
      enum {
          X509(0),
          RawPublicKey(2),
          (255)
      } CertificateType;

      struct {
          select (certificate_type) {
              case RawPublicKey:
                /* From RFC 7250 ASN.1_subjectPublicKeyInfo */
                opaque ASN1_subjectPublicKeyInfo<1..2^24-1>;

              case X509:
                opaque cert_data<1..2^24-1>;
          };
          Extension extensions<0..2^16-1>;
      } CertificateEntry;

      struct {
          opaque certificate_request_context<0..2^8-1>;
          CertificateEntry certificate_list<0..2^24-1>;
      } Certificate;
```

Certificate\_request\_context: 이 메시지가 CertificateRequest에 대한 응답인 경우 해당 메시지의 Certificate\_request\_context 값입니다. 그렇지 않은 경우\(서버 인증의 경우\) 이 필드의 길이는 0이어야 합니다.

Certificate\_list: 각각 단일 인증서와 확장 세트를 포함하는 CertificateEntry 구조의 시퀀스\(체인\)입니다.

확장: CertificateEntry에 대한 확장 값 세트입니다. "확장" 형식은 섹션 4.2에 정의되어 있습니다. 현재 서버 인증서의 유효한 확장에는 OCSP 상태 확장 \[RFC6066\] 및 SignedCertificateTimestamp 확장 \[RFC6962\]이 포함됩니다. 이 메시지에 대한 향후 확장도 정의될 수 있습니다. 서버의 인증서 메시지 확장은 ClientHello 메시지의 확장과 일치해야 합니다. 클라이언트의 인증서 메시지 확장은 서버의 CertificateRequest 메시지 확장과 일치해야 합니다. 확장이 전체 체인에 적용되는 경우 첫 번째 CertificateEntry에 포함되어야 합니다.

해당 인증서 유형 확장\("server\_certificate\_type" 또는 "client\_certificate\_type"\)이 EncryptedExtensions에서 협상되지 않았거나 X.509 인증서 유형이 협상된 경우 각 CertificateEntry에는 DER로 인코딩된 X.509 인증서가 포함됩니다. 보낸 사람의 인증서는 목록의 첫 번째 CertificateEntry에 와야 합니다. 다음의 각 인증서는 바로 앞의 인증서를 직접 인증해야 합니다. 인증서 유효성 검사에서는 트러스트 앵커를 독립적으로 배포해야 하기 때문에 지원되는 피어가 생략된 인증서를 소유한 것으로 알려진 경우 트러스트 앵커를 지정하는 인증서가 체인에서 생략될 수 있습니다.

참고: TLS 1.3 이전에는 "certificate\_list" 주문 시 각 인증서가 바로 앞의 인증서를 인증해야 했습니다. 그러나 일부 구현에서는 어느 정도 유연성이 허용되었습니다. 서버는 때때로 전환 ​​목적으로 현재 중간과 더 이상 사용되지 않는 중간을 모두 보내고 다른 것들은 단순히 잘못 구성되어 있지만 그럼에도 불구하고 이러한 경우는 적절하게 검증될 수 있습니다. 호환성을 최대화하기 위해 모든 구현은 반드시 첫 번째여야 하는 최종 엔터티 인증서를 제외하고 잠재적으로 관련 없는 인증서와 모든 TLS 버전의 임의 순서를 처리할 수 있도록 준비해야 합니다.

RawPublicKey 인증서 유형이 협상된 경우 인증서 목록에는 \[RFC7250\], 섹션 3에 정의된 ASN1\_subjectPublicKeyInfo 값을 포함하는 CertificateEntry가 하나만 포함되어야 합니다.

OpenPGP 인증서 유형 \[RFC6091\]은 TLS 1.3과 함께 사용하면 안 됩니다.

서버의 인증서 목록은 항상 비어 있지 않아야 합니다. 클라이언트는 서버의 인증 요청에 대한 응답으로 보낼 적절한 인증서가 없는 경우 빈 인증서 목록을 보냅니다.

---
##### **4.4.2.1.  OCSP Status and SCT Extensions**

\[RFC6066\] 및 \[RFC6961\]은 클라이언트에 OCSP 응답을 보내는 서버를 협상하기 위한 확장을 제공합니다. TLS 1.2 이하에서는 서버가 이 확장의 협상을 나타내기 위해 빈 확장으로 응답하고 OCSP 정보는 CertificateStatus 메시지에 전달됩니다. TLS 1.3에서 서버의 OCSP 정보는 관련 인증서가 포함된 CertificateEntry의 확장으로 전달됩니다. 특히, 서버의 "status\_request" 확장 본문은 \[RFC6060\]에 정의된 대로 해석되는 \[RFC6066\]에 정의된 CertificateStatus 구조여야 합니다.

참고: status\_request\_v2 확장 \[RFC6961\]은 더 이상 사용되지 않습니다. TLS 1.3 서버는 ClientHello 메시지를 처리할 때 서버의 존재나 정보에 따라 행동해서는 안 됩니다. 특히 EncryptedExtensions, CertificateRequest 또는 Certificate 메시지에 status\_request\_v2 확장을 전송해서는 안 됩니다. TLS 1.3 서버는 이를 포함하는 ClientHello 메시지를 처리할 수 있어야 합니다. 이는 이전 프로토콜 버전에서 이를 사용하려는 클라이언트에 의해 전송될 수 있기 때문입니다.

서버는 CertificateRequest 메시지에 빈 "status\_request" 확장을 전송하여 클라이언트가 인증서와 함께 OCSP 응답을 제시하도록 요청할 수 있습니다. 클라이언트가 OCSP 응답을 보내기로 선택한 경우 "status\_request" 확장의 본문은 \[RFC6066\]에 정의된 대로 CertificateStatus 구조여야 합니다.

마찬가지로 \[RFC6962\]는 서버가 TLS 1.2 이하의 ServerHello에서 확장으로 서명된 인증서 타임스탬프\(SCT\)를 보내는 메커니즘을 제공합니다. TLS 1.3에서는 서버의 SCT 정보가 CertificateEntry의 확장으로 전달됩니다.

---
##### **4.4.2.2.  Server Certificate Selection**

서버에서 보낸 인증서에는 다음 규칙이 적용됩니다.

- 달리 명시적으로 협상되지 않는 한\(예: \[RFC7250\]\) 인증서 유형은 X.509v3 \[RFC5280\]이어야 합니다.

- 서버의 최종 엔터티 인증서의 공개 키\(및 관련 제한 사항\)는 클라이언트의 "signature\_algorithms" 확장\(현재 RSA, ECDSA 또는 EdDSA\)에서 선택한 인증 알고리즘과 호환되어야 합니다.

- 인증서는 클라이언트의 "signature\_algorithms"/"signature\_algorithms\_cert" 확장에 표시된 서명 체계를 사용하여 서명에 키를 사용할 수 있도록 허용해야 합니다\(즉, 키 사용 확장이 있는 경우 digitalSignature 비트를 설정해야 함\)\(섹션 4.2. 삼\).

- "server\_name" \[RFC6066\] 및 "certificate\_authorities" 확장은 인증서 선택을 안내하는 데 사용됩니다. 서버는 "server\_name" 확장의 존재를 요구할 수 있으므로 클라이언트는 해당되는 경우 이 확장을 보내야 합니다.

서버가 제공하는 모든 인증서는 클라이언트가 그러한 체인을 제공할 수 있는 경우 클라이언트가 광고하는 서명 알고리즘으로 서명되어야 합니다\(섹션 4.2.3 참조\). 자체 서명된 인증서 또는 트러스트 앵커로 예상되는 인증서는 체인의 일부로 검증되지 않으므로 어떤 알고리즘으로도 서명될 수 있습니다.

서버가 표시된 지원 알고리즘을 통해서만 서명된 인증서 체인을 생성할 수 없는 경우 클라이언트가 지원하는 것으로 알려지지 않은 알고리즘을 포함할 수 있는 선택한 인증서 체인을 클라이언트에 보내 핸드셰이크를 계속해야 합니다. 이 폴백 체인은 일반적으로 더 이상 사용되지 않는 SHA-1 해시 알고리즘을 사용해서는 안 되지만, 클라이언트의 광고가 허용하는 경우에는 사용할 수 있고 그렇지 않은 경우에는 사용하면 안 됩니다.

클라이언트가 제공된 인증서를 사용하여 허용 가능한 체인을 구성할 수 없고 핸드셰이크를 중단하기로 결정한 경우 적절한 인증서 관련 경고\(기본적으로 "unsupported\_certificate", 자세한 내용은 섹션 6.2 참조\)를 사용하여 핸드셰이크를 중단해야 합니다.

서버에 여러 개의 인증서가 있는 경우 위에서 언급한 기준\(전송 계층 끝점, 로컬 구성 및 기본 설정과 같은 다른 기준 외에도\)에 따라 인증서 중 하나를 선택합니다.

---
##### **4.4.2.3.  Client Certificate Selection**

클라이언트가 보낸 인증서에는 다음 규칙이 적용됩니다.

- 달리 명시적으로 협상되지 않는 한\(예: \[RFC7250\]\) 인증서 유형은 X.509v3 \[RFC5280\]이어야 합니다.

- CertificateRequest 메시지에 "certificate\_authorities" 확장이 있는 경우 인증서 체인에 있는 인증서 중 적어도 하나는 나열된 CA 중 하나에서 발급되어야 합니다.

- 인증서는 섹션 4.3.2에 설명된 대로 허용 가능한 서명 알고리즘을 사용하여 서명되어야 합니다. 이는 이전 버전의 TLS에서 발견된 인증서 서명 알고리즘에 대한 제약을 완화합니다.

- CertificateRequest 메시지에 비어 있지 않은 "oid\_filters" 확장이 포함된 경우 최종 엔터티 인증서는 섹션 4.2.5에 설명된 대로 클라이언트가 인식하는 확장 OID와 일치해야 합니다.

---
##### **4.4.2.4.  Receiving a Certificate Message**

일반적으로 자세한 인증서 유효성 검사 절차는 TLS의 범위를 벗어납니다\(\[RFC5280\] 참조\). 이 섹션에서는 TLS 관련 요구 사항을 제공합니다.

서버가 빈 인증서 메시지를 제공하는 경우 클라이언트는 "decode\_error" 경고와 함께 핸드셰이크를 중단해야 합니다.

클라이언트가 인증서를 보내지 않는 경우\(즉, 빈 인증서 메시지를 보내는 경우\) 서버는 재량에 따라 클라이언트 인증 없이 핸드셰이크를 계속하거나 "certificate\_required" 경고와 함께 핸드셰이크를 중단할 수 있습니다. 또한 인증서 체인의 일부 측면이 허용되지 않는 경우\(예: 알려진 신뢰할 수 있는 CA에 의해 서명되지 않은 경우\) 서버는 재량에 따라 핸드셰이크를 계속하거나\(클라이언트가 인증되지 않은 것으로 간주하여\) 핸드셰이크를 중단할 수 있습니다.

MD5 해시를 사용하는 서명 알고리즘을 사용하여 유효성을 검사해야 하는 인증서를 수신하는 모든 엔드포인트는 "bad\_certificate" 경고와 함께 핸드셰이크를 중단해야 합니다. SHA-1은 더 이상 사용되지 않으며 SHA-1 해시를 사용하는 서명 알고리즘을 사용하여 유효성을 검사해야 하는 인증서를 수신하는 엔드포인트는 "bad\_certificate" 경고와 함께 핸드셰이크를 중단하는 것이 좋습니다. 명확하게 말하면 이는 엔드포인트가 자체 서명된 인증서 또는 트러스트 앵커인 인증서에 대해 이러한 알고리즘을 수락할 수 있음을 의미합니다.

현재 SHA-1 지원을 단계적으로 중단하는 과정에 있는 구현과의 상호 운용성을 유지하려면 모든 엔드포인트를 가능한 한 빨리 SHA-256 이상으로 전환하는 것이 좋습니다.

하나의 서명 알고리즘에 대한 키를 포함하는 인증서는 다른 서명 알고리즘\(예: ECDSA 키로 서명된 RSA 키\)을 사용하여 서명될 수 있습니다.

---
#### **4.4.3.  Certificate Verify**

이 메시지는 엔드포인트가 해당 인증서에 해당하는 개인 키를 소유하고 있다는 명시적인 증거를 제공하는 데 사용됩니다. CertificateVerify 메시지는 이 지점까지의 핸드셰이크에 대한 무결성도 제공합니다. 서버는 인증서를 통해 인증할 때 이 메시지를 보내야 합니다. 클라이언트는 인증서를 통해 인증할 때마다\(즉, 인증서 메시지가 비어 있지 않은 경우\) 이 메시지를 보내야 합니다. 전송되면 이 메시지는 인증서 메시지 바로 뒤와 완료 메시지 바로 앞에 나타나야 합니다.

이 메시지의 구조:

```text
      struct {
          SignatureScheme algorithm;
          opaque signature<0..2^16-1>;
      } CertificateVerify;
```

알고리즘 필드는 사용된 서명 알고리즘을 지정합니다\(이 유형의 정의는 섹션 4.2.3 참조\). 서명은 해당 알고리즘을 사용하는 디지털 서명입니다. 서명에 포함되는 콘텐츠는 섹션 4.4.1에 설명된 해시 출력입니다. 즉,

```text
      Transcript-Hash(Handshake Context, Certificate)
```

그런 다음 디지털 서명은 다음을 연결하여 계산됩니다.

- 64번 반복되는 옥텟 32\(0x20\)로 구성된 문자열

- 컨텍스트 문자열

- 구분 기호로 사용되는 단일 0바이트

- 서명할 내용

이 구조는 ServerKeyExchange 형식을 통해 공격자가 선택한 32바이트 접두사\(ClientHello.random\)가 있는 메시지 서명을 얻을 수 있었던 이전 버전의 TLS에 대한 공격을 방지하기 위한 것입니다. 초기 64바이트 패드는 서버 제어 ServerHello.random과 함께 해당 접두사를 지웁니다.

서버 서명의 컨텍스트 문자열은 "TLS 1.3, 서버 CertificateVerify"입니다. 클라이언트 서명의 컨텍스트 문자열은 "TLS 1.3, client CertificateVerify"입니다. 이는 서로 다른 컨텍스트에서 작성된 서명을 분리하여 잠재적인 프로토콜 간 공격을 방지하는 데 사용됩니다.

예를 들어 성적 해시가 01의 32바이트인 경우\(이 길이는 SHA-256에 적합함\) 서버 CertificateVerify의 디지털 서명이 적용되는 콘텐츠는 다음과 같습니다.

```text
      2020202020202020202020202020202020202020202020202020202020202020
      2020202020202020202020202020202020202020202020202020202020202020
      544c5320312e332c207365727665722043657274696669636174655665726966
      79
      00
      0101010101010101010101010101010101010101010101010101010101010101
```

발신자 측에서 CertificateVerify 메시지의 서명 필드를 계산하는 프로세스는 다음을 입력으로 사용합니다.

- 디지털 서명이 적용되는 내용

- 이전 메시지에서 보낸 인증서에 해당하는 개인 서명 키

CertificateVerify 메시지가 서버에 의해 전송되는 경우 서명 알고리즘은 지원되지 않는 알고리즘 없이는 유효한 인증서 체인을 생성할 수 없는 한 클라이언트의 "signature\_algorithms" 확장에서 제공되는 것이어야 합니다\(섹션 4.2.3 참조\).

클라이언트가 보낸 경우 서명에 사용되는 서명 알고리즘은 CertificateRequest 메시지에 있는 "signature\_algorithms" 확장의 support\_signature\_algorithms 필드에 있는 알고리즘 중 하나여야 합니다.

또한 서명 알고리즘은 보낸 사람의 최종 엔터티 인증서에 있는 키와 호환되어야 합니다. RSA 서명은 RSASSA-PKCS1-v1\_5 알고리즘이 "signature\_algorithms"에 나타나는지 여부에 관계없이 RSASSA-PSS 알고리즘을 사용해야 합니다. SHA-1 알고리즘은 CertificateVerify 메시지의 서명에 사용되어서는 안 됩니다.

이 사양의 모든 SHA-1 서명 알고리즘은 레거시 인증서에만 사용하도록 정의되었으며 CertificateVerify 서명에는 유효하지 않습니다.

CertificateVerify 메시지의 수신자는 서명 필드를 확인해야 합니다. 확인 프로세스는 다음을 입력으로 사용합니다.

- 디지털 서명이 적용되는 내용

- 관련 인증서 메시지에 있는 최종 엔터티 인증서에 포함된 공개 키

- CertificateVerify 메시지의 서명 필드에 수신된 디지털 서명

확인이 실패하면 수신자는 "decrypt\_error" 경고와 함께 핸드셰이크를 종료해야 합니다.

---
#### **4.4.4.  Finished**

완료됨 메시지는 인증 블록의 마지막 메시지입니다. 이는 핸드셰이크 및 계산된 키에 대한 인증을 제공하는 데 필수적입니다.

Finished 메시지의 수신자는 내용이 올바른지 확인해야 하며, 잘못된 경우 "decrypt\_error" 경고와 함께 연결을 종료해야 합니다.

어느 쪽에서 완료 메시지를 보내고 피어로부터 완료 메시지를 수신하고 확인한 후에는 연결을 통해 애플리케이션 데이터를 보내고 받기 시작할 수 있습니다. 피어의 Finished를 수신하기 전에 데이터 전송을 허용하는 두 가지 설정이 있습니다.

1. 섹션 4.2.10에 설명된 대로 0-RTT 데이터를 보내는 클라이언트.

1. 서버는 첫 번째 비행을 보낸 후 데이터를 보낼 수 있지만 핸드셰이크가 아직 완료되지 않았기 때문에 피어의 신원이나 활성 상태를 보장할 수 없습니다\(예: ClientHello가 재생되었을 수 있음\).

Finished 메시지를 계산하는 데 사용되는 키는 HKDF를 사용하여 섹션 4.4에 정의된 기본 키에서 계산됩니다\(섹션 7.1 참조\). 구체적으로:

```text
   finished_key =
       HKDF-Expand-Label(BaseKey, "finished", "", Hash.length)
```

이 메시지의 구조:

```text
      struct {
          opaque verify_data[Hash.length];
      } Finished;
```

verify\_data 값은 다음과 같이 계산됩니다.

```text
      verify_data =
          HMAC(finished_key,
               Transcript-Hash(Handshake Context,
                               Certificate*, CertificateVerify*))
```

- \* 있는 경우에만 포함됩니다.

HMAC \[RFC2104\]는 핸드셰이크에 해시 알고리즘을 사용합니다. 위에서 언급한 것처럼 HMAC 입력은 일반적으로 실행 중인 해시, 즉 이 시점에서는 핸드셰이크 해시에 의해 구현될 수 있습니다.

이전 버전의 TLS에서는 verify\_data의 길이가 항상 12옥텟이었습니다. TLS 1.3에서는 핸드셰이크에 사용되는 해시에 대한 HMAC 출력의 크기입니다.

참고: 경고 및 기타 핸드셰이크가 아닌 레코드 유형은 핸드셰이크 메시지가 아니며 해시 계산에 포함되지 않습니다.

완료 메시지 이후의 모든 기록은 섹션 7.2에 설명된 대로 적절한 애플리케이션 트래픽 키로 암호화되어야 합니다. 특히 여기에는 클라이언트 인증서 및 인증서 확인 메시지에 대한 응답으로 서버에서 보낸 모든 경고가 포함됩니다.

---
### **4.5.  End of Early Data**

```text
      struct {} EndOfEarlyData;
```

서버가 EncryptedExtensions에서 "early\_data" 확장을 보낸 경우 클라이언트는 서버 Finished를 수신한 후 EndOfEarlyData 메시지를 보내야 합니다. 서버가 EncryptedExtensions에서 "early\_data" 확장을 보내지 않으면 클라이언트는 EndOfEarlyData 메시지를 보내서는 안 됩니다. 이 메시지는 모든 0-RTT application\_data 메시지가 전송되었음을 나타냅니다.

다음 레코드는 핸드셰이크 트래픽 키로 보호됩니다. 서버는 이 메시지를 보내면 안 되며, 이를 수신하는 클라이언트는 "unexpected\_message" 경고와 함께 연결을 종료해야 합니다. 이 메시지는 client\_early\_traffic\_secret에서 파생된 키로 암호화됩니다.

---
### **4.6.  Post-Handshake Messages**

TLS는 또한 기본 핸드셰이크 후에 다른 메시지가 전송되도록 허용합니다. 이러한 메시지는 핸드셰이크 콘텐츠 유형을 사용하며 적절한 애플리케이션 트래픽 키로 암호화됩니다.

---
#### **4.6.1.  New Session Ticket Message**

서버가 클라이언트 Finished 메시지를 수신한 후 언제든지 NewSessionTicket 메시지를 보낼 수 있습니다. 이 메시지는 티켓 값과 재개 마스터 비밀에서 파생된 비밀 PSK 사이에 고유한 연결을 생성합니다\(섹션 7 참조\).

클라이언트는 ClientHello의 "pre\_shared\_key" 확장에 티켓 값을 포함하여 향후 핸드셰이크에 이 PSK를 사용할 수 있습니다\(섹션 4.2.11\). 서버는 단일 연결에서 서로 즉시 또는 특정 이벤트 후에 여러 티켓을 보낼 수 있습니다\(부록 C.4 참조\). 예를 들어 서버는 추가 클라이언트 인증 상태를 캡슐화하기 위해 핸드셰이크 후 인증 후에 새 티켓을 보낼 수 있습니다. 다중 티켓은 다음을 포함하여 다양한 목적으로 고객에게 유용합니다.

```text
   -  Opening multiple parallel HTTP connections.
```

- \(예를 들어\) Happy Eyeballs \[RFC8305\] 또는 관련 기술을 통해 인터페이스 및 주소 계열 전반에 걸쳐 연결 레이싱을 수행합니다.

모든 티켓은 원래 연결을 설정하는 데 사용된 것과 동일한 KDF 해시 알고리즘을 가진 암호화 제품군을 통해서만 재개되어야 합니다.

클라이언트는 새 SNI 값이 원래 세션에 제공된 서버 인증서에 유효한 경우에만 재개해야 하며 SNI 값이 원래 세션에 사용된 값과 일치하는 경우에만 재개해야 합니다. 후자는 성능 최적화입니다. 일반적으로 단일 인증서로 보호되는 여러 서버가 서로의 티켓을 수락할 수 있다고 기대할 이유가 없습니다. 따라서 이 경우 재개를 시도하면 일회용 티켓이 낭비됩니다. 그러한 표시가 \(외부적으로 또는 다른 수단으로\) 제공되면 클라이언트는 다른 SNI 값으로 재개할 수 있습니다.

재개 시 SNI 값을 호출 애플리케이션에 보고하는 경우 구현은 이전 세션에서 전송된 값이 아닌 재개 ClientHello에서 전송된 값을 사용해야 합니다. 서버 구현이 SNI 값이 다른 모든 PSK ID를 거부하는 경우 이 두 값은 항상 동일합니다.

참고: 재개 마스터 비밀은 클라이언트의 두 번째 항공편에 따라 다르지만 클라이언트 인증을 요청하지 않는 서버는 기록의 나머지 부분을 독립적으로 계산한 다음 클라이언트가 완료될 때까지 기다리지 않고 완료됨을 보내는 즉시 NewSessionTicket을 보낼 수 있습니다. 예를 들어 클라이언트가 여러 TLS 연결을 병렬로 열어야 하고 재개 핸드셰이크의 오버헤드가 줄어드는 이점이 있는 경우에 이는 적합할 수 있습니다.

```text
      struct {
          uint32 ticket_lifetime;
          uint32 ticket_age_add;
          opaque ticket_nonce<0..255>;
          opaque ticket<1..2^16-1>;
          Extension extensions<0..2^16-2>;
      } NewSessionTicket;
```

ticket\_lifetime: 티켓 발행 시점부터 네트워크 바이트 순서로 된 32비트 부호 없는 정수로 수명\(초\)을 나타냅니다. 서버는 604800초\(7일\)보다 큰 값을 사용하면 안 됩니다. 0 값은 티켓을 즉시 폐기해야 함을 나타냅니다. 클라이언트는 ticket\_lifetime에 관계없이 7일 이상 티켓을 캐시해서는 안 되며, 로컬 정책에 따라 더 일찍 티켓을 삭제할 수도 있습니다. 서버는 ticket\_lifetime에 명시된 것보다 짧은 기간 동안 티켓을 유효한 것으로 처리할 수 있습니다.

ticket\_age\_add: 클라이언트가 "pre\_shared\_key" 확장에 포함하는 티켓의 수명을 모호하게 하는 데 사용되는 안전하게 생성된 임의의 32비트 값입니다. 클라이언트가 전송하는 값을 얻기 위해 클라이언트측 티켓 유효 기간을 이 값\(모듈로 2^32\)에 추가합니다. 서버는 보내는 각 티켓에 대해 새로운 값을 생성해야 합니다.

ticket\_nonce: 이 연결에서 발행된 모든 티켓에 걸쳐 고유한 티켓당 값입니다.

ticket: PSK ID로 사용될 티켓의 값입니다. 티켓 자체는 불투명한 라벨입니다. 이는 데이터베이스 조회 키이거나 자체 암호화 및 자체 인증된 값일 수 있습니다.

확장: 티켓의 확장 값 세트입니다. "확장" 형식은 섹션 4.2에 정의되어 있습니다. 클라이언트는 인식할 수 없는 확장을 무시해야 합니다.

현재 NewSessionTicket에 정의된 유일한 확장자는 "early\_data"이며, 이는 티켓이 0-RTT 데이터를 전송하는 데 사용될 수 있음을 나타냅니다\(섹션 4.2.10\). 여기에는 다음 값이 포함됩니다.

max\_early\_data\_size: 이 티켓을 사용할 때 클라이언트가 전송할 수 있는 0-RTT 데이터의 최대량\(바이트\)입니다. 애플리케이션 데이터 페이로드\(즉, 패딩이나 내부 콘텐츠 유형 바이트가 아닌 일반 텍스트\)만 계산됩니다. max\_early\_data\_size 바이트 이상의 0-RTT 데이터를 수신하는 서버는 "unexpected\_message" 경고와 함께 연결을 종료해야 합니다. 암호화 자료 부족으로 인해 초기 데이터를 거부하는 서버는 패딩을 콘텐츠와 구별할 수 없으므로 클라이언트는 초기 데이터 레코드에서 대량의 패딩을 보낼 수 있다고 의존해서는 안 됩니다.

티켓과 관련된 PSK는 다음과 같이 계산됩니다.

```text
       HKDF-Expand-Label(resumption_master_secret,
                        "resumption", ticket_nonce, Hash.length)
```

ticket\_nonce 값은 각 NewSessionTicket 메시지마다 고유하므로 각 티켓마다 다른 PSK가 파생됩니다.

원칙적으로 초기 비PSK 핸드셰이크\(피어 인증서에 연결되었을 가능성이 높음\)에서 원래 파생된 키 자료의 수명을 무기한 연장하는 새 티켓을 계속 발행하는 것이 가능합니다. 구현 시 이러한 키 자료의 전체 수명에 제한을 두는 것이 권장됩니다. 이러한 제한은 피어 인증서의 수명, 해지 개입 가능성 및 피어의 온라인 CertificateVerify 서명 이후의 시간을 고려해야 합니다.

---
#### **4.6.2.  Post-Handshake Authentication**

클라이언트가 "post\_handshake\_auth" 확장\(섹션 4.2.6 참조\)을 전송한 경우 서버는 핸드셰이크가 완료된 후 언제든지 CertificateRequest 메시지를 전송하여 클라이언트 인증을 요청할 수 있습니다. 클라이언트는 적절한 인증 메시지로 응답해야 합니다\(섹션 4.4 참조\). 클라이언트가 인증을 선택하면 인증서, 인증서 확인,

완료되었습니다. 거절하는 경우 인증서가 포함되지 않은 인증서 메시지와 완료됨이 포함된 인증서 메시지를 보내야 합니다. 주어진 응답에 대한 클라이언트의 모든 메시지는 다른 유형의 메시지가 개입되지 않고 연속적으로 연결되어 나타나야 합니다.

"post\_handshake\_auth" 확장을 전송하지 않고 CertificateRequest 메시지를 수신한 클라이언트는 "unexpected\_message" 치명적인 경고를 전송해야 합니다.

참고: 클라이언트 인증에는 사용자에게 메시지를 표시하는 작업이 포함될 수 있으므로 서버는 CertificateRequest 전송과 응답 수신 사이에 임의의 수의 다른 메시지 수신을 포함하여 약간의 지연에 대비해야 합니다. 또한 여러 개의 CertificateRequest를 연속적으로 수신하는 클라이언트는 수신된 순서와 다른 순서로 응답할 수 있습니다\(certificate\_request\_context 값을 사용하면 서버가 응답을 명확하게 할 수 있습니다\).

---
#### **4.6.3.  Key and Initialization Vector Update**

KeyUpdate 핸드셰이크 메시지는 보낸 사람이 보내는 암호화 키를 업데이트하고 있음을 나타내는 데 사용됩니다. 이 메시지는 Finished 메시지를 보낸 후 피어 중 하나에 의해 전송될 수 있습니다. Finished 메시지를 수신하기 전에 KeyUpdate 메시지를 수신하는 구현은 "unexpected\_message" 경고와 함께 연결을 종료해야 합니다. KeyUpdate 메시지를 보낸 후 발신자는 섹션 7.2에 설명된 대로 계산된 차세대 키를 사용하여 모든 트래픽을 전송해야 합니다. KeyUpdate를 수신하면 수신자는 수신 키를 업데이트해야 합니다.

```text
      enum {
          update_not_requested(0), update_requested(1), (255)
      } KeyUpdateRequest;

      struct {
          KeyUpdateRequest request_update;
      } KeyUpdate;
```

request\_update: KeyUpdate 수신자가 자체 KeyUpdate로 응답해야 하는지 여부를 나타냅니다. 구현이 다른 값을 수신하는 경우 "illegal\_parameter" 경고와 함께 연결을 종료해야 합니다.

request\_update 필드가 "update\_requested"로 설정된 경우 수신자는 다음 애플리케이션 데이터 레코드를 보내기 전에 request\_update가 "update\_not\_requested"로 설정된 자체 KeyUpdate를 보내야 합니다. 이 메커니즘을 사용하면 어느 쪽이든 전체 연결을 강제로 업데이트할 수 있지만 구현에서는 수신되는 결과가 발생합니다.

단일 업데이트로 응답하기 위해 자동으로 여러 KeyUpdate를 수행합니다. 구현에서는 request\_update를 "update\_requested"로 설정하여 KeyUpdate를 보내는 것과 피어의 KeyUpdate를 받는 사이에 임의의 수의 메시지를 받을 수 있습니다. 해당 메시지가 이미 전송 중일 수 있기 때문입니다. 그러나 송신 및 수신 키는 독립적인 트래픽 비밀에서 파생되므로 수신 트래픽 비밀을 유지해도 보낸 사람이 키를 변경하기 전에 전송된 데이터의 전달 비밀이 위협받지 않습니다.

구현이 request\_update를 "update\_requested"로 설정하여 자체 KeyUpdate를 독립적으로 전송하고 비행 중에 교차하는 경우 각 측면도 응답을 전송하며 결과는 각 측면에서 2세대씩 증가합니다.

발신자와 수신자 모두 이전 키를 사용하여 KeyUpdate 메시지를 암호화해야 합니다. 또한 양측은 새 키로 암호화된 메시지를 수락하기 전에 이전 키가 포함된 KeyUpdate가 수신되도록 강제해야 합니다. 그렇지 않으면 메시지 잘림 공격이 허용될 수 있습니다.

---
## **5.  Record Protocol**

TLS 레코드 프로토콜은 전송할 메시지를 취하고, 데이터를 관리 가능한 블록으로 조각화하고, 레코드를 보호하고, 결과를 전송합니다. 수신된 데이터는 검증, 암호 해독, 재조립된 후 상위 클라이언트로 전달됩니다.

TLS 레코드는 유형이 지정되어 있어 여러 상위 수준 프로토콜이 동일한 레코드 계층을 통해 다중화될 수 있습니다. 이 문서에서는 handshake, application\_data, 경고 및change\_cipher\_spec의 네 가지 콘텐츠 유형을 지정합니다. Change\_cipher\_spec 레코드는 호환성 목적으로만 사용됩니다\(부록 D.4 참조\).

구현은 첫 번째 ClientHello 메시지가 전송 또는 수신된 후, 그리고 피어의 Finished 메시지가 수신되기 전에 언제든지 단일 바이트 값 0x01로 구성된 Change\_cipher\_spec 유형의 암호화되지 않은 레코드를 수신할 수 있으며 추가 처리 없이 이를 삭제해야 합니다\(MUST\). 이 레코드는 구현이 보호된 레코드를 기대하는 핸드셰이크 지점에 나타날 수 있으므로 레코드 보호 해제를 시도하기 전에 이 조건을 검색해야 합니다. 다른 Change\_cipher\_spec 값을 수신하거나 보호된 Change\_cipher\_spec 레코드를 수신하는 구현은 "unexpected\_message" 경고와 함께 핸드셰이크를 중단해야 합니다\(MUST\). 구현이 첫 번째 ClientHello 메시지 이전이나 피어의 Finished 메시지 이후에 수신된change\_cipher\_spec 레코드를 감지하는 경우 이는 예상치 못한 레코드 유형으로 처리되어야 합니다\(비상태 서버는 이러한 사례를 허용된 사례와 구별하지 못할 수도 있음\).

구현은 일부 확장에 의해 협상되지 않는 한 이 문서에 정의되지 않은 레코드 유형을 전송해서는 안 됩니다. TLS 구현이 예기치 않은 레코드 유형을 수신하는 경우 "unexpected\_message" 경고와 함께 연결을 종료해야 합니다. 새로운 레코드 콘텐츠 유형 값은 섹션 11에 설명된 대로 TLS ContentType 레지스트리의 IANA에 의해 할당됩니다.

---
### **5.1.  Record Layer**

레코드 계층은 정보 블록을 2^14바이트 이하의 청크로 데이터를 전달하는 TLSPlaintext 레코드로 조각화합니다. 메시지 경계는 기본 ContentType에 따라 다르게 처리됩니다. 모든 향후 콘텐츠 유형은 적절한 규칙을 지정해야 합니다. 이러한 규칙은 TLS 1.2에서 시행된 것보다 더 엄격합니다.

다음과 같은 경우 핸드셰이크 메시지는 단일 TLSPlaintext 레코드로 통합되거나 여러 레코드에 걸쳐 조각화될 수 있습니다.

- 핸드셰이크 메시지는 다른 레코드 유형과 인터리브되어서는 안 됩니다. 즉, 핸드셰이크 메시지가 두 개 이상의 레코드로 분할된 경우 그 사이에 다른 레코드가 있어서는 안 됩니다.

- 핸드셰이크 메시지는 키 변경을 포괄해서는 안 됩니다. 구현에서는 키 변경 직전의 모든 메시지가 레코드 경계와 일치하는지 확인해야 합니다. 그렇지 않은 경우 "unexpected\_message" 경고와 함께 연결을 종료해야 합니다. ClientHello, EndOfEarlyData, ServerHello, Finished 및 KeyUpdate 메시지는 키 변경 바로 앞에 올 수 있으므로 구현에서는 레코드 경계에 맞춰 이러한 메시지를 보내야 합니다.

구현에서는 길이가 0인 Handshake 유형의 조각을 전송해서는 안 됩니다. 이는 해당 조각에 패딩이 포함되어 있는 경우에도 마찬가지입니다.

경고 메시지\(섹션 6\)는 레코드 전체에 걸쳐 조각화되어서는 안 되며, 여러 경고 메시지가 단일 TLSPlaintext 레코드로 통합되어서는 안 됩니다. 즉, 경고 유형의 레코드에는 정확히 하나의 메시지가 포함되어야 합니다.

애플리케이션 데이터 메시지에는 TLS에 불투명한 데이터가 포함되어 있습니다. 애플리케이션 데이터 메시지는 항상 보호됩니다. 길이가 0인 응용 프로그램 데이터 조각은 잠재적으로 트래픽 분석 대책으로 유용하므로 전송될 수 있습니다. 애플리케이션 데이터 조각은 여러 레코드로 분할되거나 단일 레코드로 통합될 수 있습니다.

```text
      enum {
          invalid(0),
          change_cipher_spec(20),
          alert(21),
          handshake(22),
          application_data(23),
          (255)
      } ContentType;

      struct {
          ContentType type;
          ProtocolVersion legacy_record_version;
          uint16 length;
          opaque fragment[TLSPlaintext.length];
      } TLSPlaintext;
```

유형: 포함된 조각을 처리하는 데 사용되는 상위 수준 프로토콜입니다.

Legacy\_record\_version: 초기 ClientHello\(즉, HelloRetryRequest 이후 생성되지 않은 레코드\) 이외의 TLS 1.3 구현에 의해 생성된 모든 레코드에 대해 0x0303으로 설정해야 하며, 호환성을 위해 0x0301일 수도 있습니다. 이 필드는 더 이상 사용되지 않으며 모든 목적에 대해 무시되어야 합니다. 이전 버전의 TLS는 일부 상황에서 이 필드에 다른 값을 사용했습니다.

길이: 다음 TLSPlaintext.fragment의 길이\(바이트\)입니다. 길이는 2^14바이트를 초과하면 안 됩니다. 이 길이를 초과하는 레코드를 수신하는 엔드포인트는 반드시 "record\_overflow" 경고와 함께 연결을 종료해야 합니다.

조각: 전송되는 데이터입니다. 이 값은 투명하며 유형 필드에 지정된 상위 레벨 프로토콜에 의해 처리되는 독립 블록으로 처리됩니다.

이 문서에서는 버전 0x0304를 사용하는 TLS 1.3에 대해 설명합니다. 이 버전 값은 TLS 1.0의 경우 0x0301, SSL 3.0의 경우 0x0300 사용에서 파생된 기록 값입니다. 이전 버전과의 호환성을 최대화하려면 초기 ClientHello를 포함하는 레코드는 버전 0x0301\(TLS 1.0 반영\)을 가져야 하고 두 번째 ClientHello 또는 ServerHello를 포함하는 레코드는 버전 0x0303\(TLS 1.2 반영\)을 가져야 합니다. 이전 버전의 TLS를 협상할 때 엔드포인트는 부록 D에 제공된 절차와 요구 사항을 따릅니다.

기록 보호가 아직 실행되지 않은 경우 TLSPlaintext 구조가 연결에 직접 기록됩니다. 레코드 보호가 시작되면 TLSPlaintext 레코드는 다음 섹션에 설명된 대로 보호되고 전송됩니다. 애플리케이션 데이터 기록은 보호되지 않은 전선에 기록되어서는 안 됩니다\(자세한 내용은 섹션 2 참조\).

---
### **5.2.  Record Payload Protection**

기록 보호 기능은 TLSPlaintext 구조를 TLSCiphertext 구조로 변환합니다. 탈보호 기능은 이 과정을 반대로 합니다. 이전 버전의 TLS와 달리 TLS 1.3에서는 모든 암호가 "AEAD\(Authenticated Encryption with Associated Data\)"\[RFC5116\]로 모델링됩니다. AEAD 기능은 일반 텍스트를 인증된 암호 텍스트로 변환하고 다시 변환하는 통합 암호화 및 인증 작업을 제공합니다. 암호화된 각 레코드는 일반 텍스트 헤더와 그 뒤에 오는 암호화된 본문으로 구성되며, 그 자체에는 유형과 선택적 패딩이 포함되어 있습니다.

```text
      struct {
          opaque content[TLSPlaintext.length];
          ContentType type;
          uint8 zeros[length_of_padding];
      } TLSInnerPlaintext;

      struct {
          ContentType opaque_type = application_data; /* 23 */
          ProtocolVersion legacy_record_version = 0x0303; /* TLS v1.2 */
          uint16 length;
          opaque encrypted_record[TLSCiphertext.length];
      } TLSCiphertext;
```

콘텐츠: 핸드셰이크나 경고 메시지의 바이트 인코딩 또는 보낼 애플리케이션 데이터의 원시 바이트를 포함하는 TLSPlaintext.fragment 값입니다.

유형: 레코드의 콘텐츠 유형을 포함하는 TLSPlaintext.type 값입니다.

0: 값이 0인 바이트의 임의 길이 실행이 유형 필드 뒤의 일반 텍스트에 나타날 수 있습니다. 이는 총계가 레코드 크기 제한 내에 있는 한 발신자가 선택한 양만큼 TLS 레코드를 채울 수 있는 기회를 제공합니다. 자세한 내용은 섹션 5.4를 참조하세요.

opaque\_type: TLSCiphertext 레코드의 외부 opaque\_type 필드는 이전 버전의 TLS를 구문 분석하는 데 익숙한 미들박스와의 외부 호환성을 위해 항상 값 23\(application\_data\)으로 설정됩니다. 레코드의 실제 콘텐츠 유형은 암호 해독 후 TLSInnerPlaintext.type에서 찾을 수 있습니다.

Legacy\_record\_version: Legacy\_record\_version 필드는 항상 0x0303입니다. TLS 1.3 TLSCiphertexts는 TLS 1.3이 협상될 때까지 생성되지 않으므로 다른 값이 수신될 수 있는 기록 호환성 문제는 없습니다. ClientHello 및 ServerHello 메시지를 포함한 핸드셰이크 프로토콜은 프로토콜 버전을 인증하므로 이 값은 중복됩니다.

길이: 다음 TLSCiphertext.encrypted\_record의 길이\(바이트\)입니다. 이는 콘텐츠와 패딩의 길이에 내부 콘텐츠 유형에 대한 1과 AEAD 알고리즘에 의해 추가된 모든 확장의 합계입니다. 길이는 2^14 + 256바이트를 초과하면 안 됩니다. 이 길이를 초과하는 레코드를 수신하는 엔드포인트는 반드시 "record\_overflow" 경고와 함께 연결을 종료해야 합니다.

crypto\_record: 직렬화된 TLSInnerPlaintext 구조의 AEAD 암호화 형식입니다.

AEAD 알고리즘은 \[RFC5116\]의 섹션 2.1에 설명된 대로 인증 확인에 포함될 단일 키, nonce, 일반 텍스트 및 "추가 데이터"를 입력으로 사용합니다. 키는 client\_write\_key 또는 server\_write\_key이고 nonce는 시퀀스 번호와 client\_write\_iv 또는 server\_write\_iv\(섹션 5.3 참조\)에서 파생되며 추가 데이터 입력은 레코드 헤더입니다.

```text
   I.e.,

      additional_data = TLSCiphertext.opaque_type ||
                        TLSCiphertext.legacy_record_version ||
                        TLSCiphertext.length
```

AEAD 알고리즘에 대한 일반 텍스트 입력은 인코딩된 TLSInnerPlaintext 구조입니다. 트래픽 키의 파생은 섹션 7.3에 정의되어 있습니다.

AEAD 출력은 AEAD 암호화 작업의 암호문 출력으로 구성됩니다. 일반 텍스트의 길이는 TLSInnerPlaintext.type 및 보낸 사람이 제공한 패딩이 포함되어 있기 때문에 해당 TLSPlaintext.length보다 큽니다. AEAD 출력의 길이는 일반적으로 일반 텍스트보다 길지만 AEAD 알고리즘에 따라 그 길이가 달라집니다.

암호에는 패딩이 포함될 수 있으므로 오버헤드의 양은 일반 텍스트의 길이에 따라 달라질 수 있습니다. 상징적으로,

```text
      AEADEncrypted =
          AEAD-Encrypt(write_key, nonce, additional_data, plaintext)
```

TLSCiphertext의 crypto\_record 필드는 AEADencrypted로 설정됩니다.

암호를 해독하고 확인하기 위해 암호는 키, nonce, 추가 데이터 및 AEADEncrypted 값을 입력으로 사용합니다. 출력은 일반 텍스트이거나 암호 해독이 실패했음을 나타내는 오류입니다. 별도의 무결성 검사는 없습니다. 상징적으로,

```text
      plaintext of encrypted_record =
          AEAD-Decrypt(peer_write_key, nonce,
                       additional_data, AEADEncrypted)
```

암호 해독에 실패하면 수신자는 "bad\_record\_mac" 경고와 함께 연결을 종료해야 합니다.

TLS 1.3에서 사용되는 AEAD 알고리즘은 255옥텟보다 큰 확장을 생성해서는 안 됩니다. TLSCiphertext.length가 2^14 + 256 옥텟보다 큰 피어로부터 레코드를 수신하는 엔드포인트는 "record\_overflow" 경고와 함께 연결을 종료해야 합니다. 이 제한은 최대 TLSInnerPlaintext 길이인 2^14옥텟 + ContentType의 1옥텟 + 최대 AEAD 확장인 255옥텟에서 파생됩니다.

---
### **5.3.  Per-Record Nonce**

64비트 시퀀스 번호는 레코드 읽기 및 쓰기를 위해 별도로 유지됩니다. 각 레코드를 읽거나 쓴 후에 적절한 시퀀스 번호가 1씩 증가합니다. 각 시퀀스 번호는 연결 시작 시와 키가 변경될 때마다 0으로 설정됩니다. 특정 트래픽 키로 전송된 첫 번째 레코드는 시퀀스 번호 0을 사용해야 합니다.

시퀀스 번호의 크기는 64비트이므로 줄 바꿈되어서는 안 됩니다. TLS 구현이 시퀀스 번호를 래핑해야 하는 경우 키를 다시 입력하거나\(섹션 4.6.3\) 연결을 종료해야 합니다.

각 AEAD 알고리즘은 입력 \[RFC5116\]의 N\_MIN바이트에서 N\_MAX바이트까지 레코드당 nonce에 대해 가능한 길이 범위를 지정합니다. TLS 레코드별 nonce\(iv\_length\)의 길이는 AEAD 알고리즘의 경우 8바이트와 N\_MIN 중 더 큰 값으로 설정됩니다\(\[RFC5116\], 섹션 4 참조\). N\_MAX가 8바이트 미만인 AEAD 알고리즘은 TLS와 함께 사용하면 안 됩니다. AEAD 구성에 대한 레코드별 임시값은 다음과 같이 구성됩니다.

1. 64비트 레코드 시퀀스 번호는 네트워크 바이트 순서로 인코딩되고 iv\_length의 왼쪽에 0이 채워집니다.

1. 패딩된 시퀀스 번호는 정적 client\_write\_iv 또는 server\_write\_iv\(역할에 따라\)와 XOR됩니다.

결과 수량\(길이 iv\_length\)은 레코드별 nonce로 사용됩니다.

참고: 이는 부분적으로 명시적인 nonce를 지정한 TLS 1.2의 구조와는 다릅니다.

---
### **5.4.  Record Padding**

암호화된 모든 TLS 레코드는 TLSCiphertext의 크기를 늘리기 위해 채워질 수 있습니다. 이를 통해 발신자는 관찰자에게 트래픽 크기를 숨길 수 있습니다.

TLSCiphertext 레코드를 생성할 때 구현에서는 패딩을 선택할 수 있습니다. 패딩되지 않은 레코드는 패딩 길이가 0인 레코드입니다. 패딩은 암호화 전에 ContentType 필드에 추가된 0값 바이트 문자열입니다. 구현에서는 암호화하기 전에 패딩 옥텟을 모두 0으로 설정해야 합니다.

발신자가 원하는 경우 애플리케이션 데이터 레코드에는 길이가 0인 TLSInnerPlaintext.content가 포함될 수 있습니다. 이를 통해 활동 유무가 민감한 상황에서 그럴듯한 크기의 커버 트래픽을 생성할 수 있습니다. 구현은 길이가 0인 TLSInnerPlaintext.content가 있는 핸드셰이크 및 경고 레코드를 전송해서는 안 됩니다. 그러한 메시지가 수신되면 수신 구현은 "unexpected\_message" 경고와 함께 연결을 종료해야 합니다.

전송된 패딩은 기록 보호 메커니즘에 의해 자동으로 확인됩니다. TLSCiphertext.encrypted\_record의 암호 해독이 성공하면 수신 구현은 0이 아닌 옥텟을 찾을 때까지 끝에서 시작 방향으로 필드를 스캔합니다. 0이 아닌 이 옥텟은 메시지의 콘텐츠 유형입니다. 이 패딩 구성표는 새로운 콘텐츠 유형을 도입하지 않고도 암호화된 TLS 레코드를 임의의 크기\(0부터 TLS 레코드 크기 제한까지\)로 패딩할 수 있기 때문에 선택되었습니다. 또한 이 설계에서는 패딩 오류를 신속하게 감지할 수 있도록 모두 제로 패딩 옥텟을 적용합니다.

구현에서는 AEAD 암호 해독에서 반환된 일반 텍스트로 검색을 제한해야 합니다. 수신 구현이 일반 텍스트에서 0이 아닌 옥텟을 찾지 못하면 "unexpected\_message" 경고와 함께 연결을 종료해야 합니다.

패딩이 있어도 전체 레코드 크기 제한은 변경되지 않습니다. 전체 인코딩된 TLSInnerPlaintext는 2^14 + 1 옥텟을 초과해서는 안 됩니다. 예를 들어 \[RFC8449\]의 Record\_size\_limit 확장에 의해 최대 조각 길이가 감소하면 감소된 제한은 콘텐츠 유형 및 패딩을 포함한 전체 일반 텍스트에 적용됩니다.

패딩 시기와 양을 제안하는 패딩 정책을 선택하는 것은 복잡한 주제이며 이 사양의 범위를 벗어납니다. TLS 위에 있는 애플리케이션 계층 프로토콜에 자체 패딩이 있는 경우 애플리케이션 계층 내에서 애플리케이션 데이터 TLS 레코드를 패딩하는 것이 더 나을 수 있습니다. 하지만 암호화된 핸드셰이크 또는 경고 레코드에 대한 패딩은 여전히 ​​TLS 계층에서 처리되어야 합니다. 이후 문서에서는 패딩 선택 알고리즘을 정의하거나 TLS 확장 또는 기타 수단을 통해 패딩 정책 요청 메커니즘을 정의할 수 있습니다.

---
### **5.5.  Limits on Key Usage**

특정 키 세트로 안전하게 암호화할 수 있는 일반 텍스트의 양에는 암호화 제한이 있습니다. \[AEAD-LIMITS\]는 기본 프리미티브\(AES 또는 ChaCha20\)에 약점이 없다는 가정하에 이러한 제한에 대한 분석을 제공합니다. 구현은 이러한 제한에 도달하기 전에 섹션 4.6.3에 설명된 대로 주요 업데이트를 수행해야 합니다.

AES-GCM의 경우 AE\(인증된 암호화\) 보안을 위해 약 2^-57의 안전 여유를 유지하면서 최대 2^24.5개의 전체 크기 레코드\(약 2,400만 개\)를 특정 연결에서 암호화할 수 있습니다. ChaCha20/Poly1305의 경우 안전 한계에 도달하기 전에 레코드 시퀀스 번호가 줄바꿈됩니다.

---
## **6.  Alert Protocol**

TLS는 종료 정보 및 오류를 나타내는 경고 콘텐츠 유형을 제공합니다. 다른 메시지와 마찬가지로 경고 메시지도 현재 연결 상태에 따라 암호화됩니다.

경고 메시지는 경고에 대한 설명과 이전 버전의 TLS에서 메시지의 심각도 수준을 전달한 레거시 필드를 전달합니다. 경고는 종료 경고와 오류 경고의 두 가지 클래스로 구분됩니다. TLS 1.3에서는 심각도가 전송되는 경고 유형에 내재되어 있으며 "수준" 필드는 무시해도 됩니다. "close\_notify" 경고는 연결의 한 방향이 순차적으로 종료되었음을 나타내는 데 사용됩니다. 이러한 경고를 수신하면 TLS 구현은 애플리케이션에 데이터 끝을 표시해야 합니다.

오류 경고는 연결 종료가 중단되었음을 나타냅니다\(섹션 6.2 참조\). 오류 경고를 수신하면 TLS 구현은 애플리케이션에 오류를 표시해야 하며 연결에서 추가 데이터가 전송되거나 수신되도록 허용해서는 안 됩니다. 서버와 클라이언트는 세션 티켓과 관련된 PSK를 제외하고 실패한 연결에서 설정된 비밀 값과 키를 잊어야 하며 가능하면 폐기해야 합니다.

섹션 6.2에 나열된 모든 경고는 AlertLevel=fatal로 전송되어야 하며 메시지의 AlertLevel에 관계없이 수신되면 오류 경고로 처리되어야 합니다. 알 수 없는 경고 유형은 오류 경고로 처리되어야 합니다.

참고: TLS는 메시지 구문 분석 실패 시 사용할 두 가지 일반 경고\(섹션 6 참조\)를 정의합니다. 구문에 따라 구문 분석할 수 없는 메시지\(예: 메시지 경계를 넘어서는 길이를 가지거나 범위를 벗어난 길이를 포함하는 메시지\)를 수신하는 피어는 "decode\_error" 경고와 함께 연결을 종료해야 합니다. 구문상으로는 정확하지만 의미상 유효하지 않은 메시지\(예: p - 1의 DHE 공유 또는 유효하지 않은 열거형\)를 수신한 피어는 "illegal\_parameter" 경고와 함께 연결을 종료해야 합니다.

```text
      enum { warning(1), fatal(2), (255) } AlertLevel;

      enum {
          close_notify(0),
          unexpected_message(10),
          bad_record_mac(20),
          record_overflow(22),
          handshake_failure(40),
          bad_certificate(42),
          unsupported_certificate(43),
          certificate_revoked(44),
          certificate_expired(45),
          certificate_unknown(46),
          illegal_parameter(47),
          unknown_ca(48),
          access_denied(49),
          decode_error(50),
          decrypt_error(51),
          protocol_version(70),
          insufficient_security(71),
          internal_error(80),
          inappropriate_fallback(86),
          user_canceled(90),
          missing_extension(109),
          unsupported_extension(110),
          unrecognized_name(112),
          bad_certificate_status_response(113),
          unknown_psk_identity(115),
          certificate_required(116),
          no_application_protocol(120),
          (255)
      } AlertDescription;

      struct {
          AlertLevel level;
          AlertDescription description;
      } Alert;
```

---
### **6.1.  Closure Alerts**

클라이언트와 서버는 잘림 공격을 피하기 위해 연결이 종료되고 있다는 정보를 공유해야 합니다.

close\_notify: 이 경고는 발신자가 이 연결에서 더 이상 메시지를 보내지 않을 것임을 수신자에게 알립니다. 폐쇄 경고가 수신된 후 수신된 모든 데이터는 무시되어야 합니다.

user\_canceled: 이 경고는 발신자가 프로토콜 오류와 관련 없는 어떤 이유로 핸드셰이크를 취소하고 있음을 수신자에게 알립니다. 핸드셰이크가 완료된 후 사용자가 작업을 취소하는 경우 "close\_notify"를 전송하여 연결을 종료하는 것이 더 적절합니다. 이 경고 뒤에는 "close\_notify"가 와야 합니다. 이 경고에는 일반적으로 AlertLevel=warning이 있습니다.

각 당사자는 "close\_notify" 경고를 전송하여 연결의 쓰기 측 닫기를 시작할 수 있습니다. 폐쇄 경고가 수신된 후 수신된 모든 데이터는 무시되어야 합니다. "close\_notify" 이전에 전송 수준 닫기가 수신되면 수신자는 전송된 모든 데이터가 수신되었는지 알 수 없습니다.

각 당사자는 이미 일부 오류 경고를 보낸 경우를 제외하고 연결의 쓰기 측을 닫기 전에 "close\_notify" 경고를 보내야 합니다. 이는 연결의 읽기 측면에는 아무런 영향을 미치지 않습니다. 이는 구현이 보류 중인 쓰기를 삭제하고 자체적으로 즉시 "close\_notify" 경고를 보내 "close\_notify"에 반응해야 했던 TLS 1.3 이전 버전의 TLS에서 변경된 사항입니다. 이전 요구 사항으로 인해 읽기 측에서 잘림이 발생할 수 있습니다. 두 당사자 모두 연결의 읽기 측을 닫기 전에 "close\_notify" 경고를 수신할 때까지 기다릴 필요는 없지만 그렇게 하면 잘릴 가능성이 있습니다.

TLS를 사용하는 애플리케이션 프로토콜이 TLS 연결이 닫힌 후 기본 전송을 통해 모든 데이터가 전달될 수 있다고 제공하는 경우 TLS 구현은 애플리케이션 계층에 데이터 끝을 알리기 전에 "close\_notify" 경고를 수신해야 합니다. 이 표준의 어떤 부분도 연결이 열리거나 닫힐 때를 포함하여 TLS에 대한 사용 프로필이 데이터 전송을 관리하는 방식을 지시하는 데 사용되어서는 안 됩니다.

참고: 연결의 쓰기 측을 닫으면 전송이 파괴되기 전에 보류 중인 데이터가 안정적으로 전달된다고 가정합니다.

---
### **6.2.  Error Alerts**

TLS의 오류 처리는 매우 간단합니다. 오류가 감지되면 감지 당사자는 피어에게 메시지를 보냅니다. 치명적인 경고 메시지를 전송하거나 수신하면 양 당사자는 즉시 연결을 종료해야 합니다.

구현에서 치명적인 오류 조건이 발생할 때마다 적절한 치명적인 경고를 보내야 하며 추가 데이터를 보내거나 받지 않고 연결을 닫아야 합니다\(MUST\). 이 사양의 나머지 부분에서 "연결 종료" 및 "핸드셰이크 중단"이라는 문구가 특정 경고 없이 사용되는 경우 이는 구현이 아래 설명에 표시된 경고를 보내야 함을 의미합니다. "X 경고로 연결 종료" 및 "X 경고로 핸드쉐이크 중단"이라는 문구는 구현이 경고를 보내는 경우 경고 X를 보내야 함을 의미합니다. 이 섹션 아래에 정의된 모든 경고와 알 수 없는 모든 경고는 TLS 1.3부터 ​​보편적으로 치명적인 것으로 간주됩니다\(섹션 6 참조\). 구현 시 경보 전송 및 수신을 쉽게 기록할 수 있는 방법을 제공해야 합니다\(SHOULD\).

다음 오류 경고가 정의됩니다.

예기치 않은\_message: 부적절한 메시지\(예: 잘못된 핸드셰이크 메시지, 조기 애플리케이션 데이터 등\)가 수신되었습니다. 이 경고는 적절한 구현 간의 통신에서 관찰되어서는 안 됩니다.

bad\_record\_mac: 보호 해제할 수 없는 레코드가 수신되면 이 경고가 반환됩니다. AEAD 알고리즘은 암호 해독과 확인을 결합하고 부채널 공격을 방지하기 때문에 모든 보호 해제 실패에 대해 이 경고가 사용됩니다. 네트워크에서 메시지가 손상된 경우를 제외하고는 적절한 구현 간의 통신에서 이 경고를 관찰해서는 안 됩니다.

Record\_overflow: 길이가 2^14 + 256바이트를 초과하는 TLSCiphertext 레코드가 수신되었거나 2^14바이트\(또는 기타 협상된 제한\)를 초과하는 TLSPlaintext 레코드로 해독된 레코드가 수신되었습니다. 네트워크에서 메시지가 손상된 경우를 제외하고는 적절한 구현 간의 통신에서 이 경고를 관찰해서는 안 됩니다.

handshake\_failure: "handshake\_failure" 경고 메시지 수신은 발신자가 사용 가능한 옵션이 제공되는 경우 허용되는 보안 매개변수 집합을 협상할 수 없음을 나타냅니다.

bad\_certificate: 인증서가 손상되었거나 올바르게 확인되지 않은 서명이 포함되어 있습니다.

unsupported\_certificate: 인증서가 지원되지 않는 유형이었습니다.

Certificate\_revoked: 서명자가 인증서를 취소했습니다.

Certificate\_expired: 인증서가 만료되었거나 현재 유효하지 않습니다.

Certificate\_unknown: 인증서를 처리하는 중에 다른\(지정되지 않은\) 문제가 발생하여 승인할 수 없게 되었습니다.

불법\_파라미터: 핸드셰이크의 필드가 올바르지 않거나 다른 필드와 일치하지 않습니다. 이 경고는 공식 프로토콜 구문을 준수하지만 그렇지 않은 경우 잘못된 오류에 사용됩니다.

unknown\_ca: 유효한 인증서 체인 또는 부분 체인을 수신했지만 CA 인증서를 찾을 수 없거나 알려진 트러스트 앵커와 일치할 수 없기 때문에 인증서가 승인되지 않았습니다.

access\_denied: 유효한 인증서 또는 PSK를 받았으나 접근 제어가 적용되었을 때 발신자가 협상을 진행하지 않기로 결정했습니다.

decode\_error: 일부 필드가 지정된 범위를 벗어났거나 메시지 길이가 올바르지 않아 메시지를 디코딩할 수 없습니다. 이 경고는 메시지가 공식 프로토콜 구문을 따르지 않는 오류에 사용됩니다. 네트워크에서 메시지가 손상된 경우를 제외하고는 적절한 구현 간의 통신에서 이 경고를 관찰해서는 안 됩니다.

decrypt\_error: 서명을 올바르게 확인하거나 완료된 메시지 또는 PSK 바인더를 확인할 수 없는 것을 포함하여 핸드셰이크\(레코드 레이어 아님\) 암호화 작업이 실패했습니다.

프로토콜\_버전: 피어가 협상을 시도한 프로토콜 버전이 인식되지만 지원되지 않습니다\(부록 D 참조\).

불충분한\_보안: 서버가 클라이언트가 지원하는 것보다 더 안전한 매개변수를 요구하기 때문에 특히 협상이 실패한 경우 "handshake\_failure" 대신 반환됩니다.

Internal\_error: 피어와 관련되지 않은 내부 오류 또는 프로토콜의 정확성\(예: 메모리 할당 실패\)으로 인해 계속할 수 없습니다.

inproper\_fallback: 클라이언트의 잘못된 연결 재시도 시도에 대한 응답으로 서버에서 전송합니다\(\[RFC7507\] 참조\).

missing\_extension: 제공된 TLS 버전 또는 기타 협상된 매개변수에 대해 전송해야 하는 필수 확장이 포함되지 않은 핸드셰이크 메시지를 수신하는 엔드포인트에서 전송됩니다.

unsupported\_extension: 지정된 핸드셰이크 메시지에 포함이 금지된 것으로 알려진 확장이 포함된 핸드셰이크 메시지를 수신하거나 해당 ClientHello 또는 CertificateRequest에서 처음 제공되지 않은 ServerHello 또는 인증서의 확장을 포함하는 핸드셰이크 메시지를 수신하는 엔드포인트에 의해 전송됩니다.

unrecognized\_name: "server\_name" 확장을 통해 클라이언트가 제공한 이름으로 식별되는 서버가 없을 때 서버에서 전송합니다\(\[RFC6066\] 참조\).

bad\_certificate\_status\_response: 유효하지 않거나 허용할 수 없는 OCSP 응답이 "status\_request" 확장을 통해 서버에서 제공될 때 클라이언트가 전송합니다\(\[RFC6066\] 참조\).

known\_psk\_identity: PSK 키 설정이 필요하지만 클라이언트가 허용 가능한 PSK ID를 제공하지 않을 때 서버에서 전송됩니다. 이 경고를 보내는 것은 선택 사항입니다. 대신 서버는 잘못된 PSK ID를 나타내기 위해 "decrypt\_error" 경고를 보내도록 선택할 수 있습니다.

Certificate\_required: 클라이언트 인증서가 필요하지만 클라이언트가 아무것도 제공하지 않은 경우 서버에서 전송됩니다.

no\_application\_protocol: 클라이언트 "application\_layer\_protocol\_negotiation" 확장이 서버가 지원하지 않는 프로토콜만 광고할 때 서버에서 전송됩니다\(\[RFC7301\] 참조\).

새로운 경고 값은 섹션 11에 설명된 대로 IANA에 의해 할당됩니다.

---
## **7.  Cryptographic Computations**

TLS 핸드셰이크는 아래에 설명된 대로 실제 작동하는 키 자료를 생성하기 위해 결합되는 하나 이상의 입력 비밀을 설정합니다. 키 파생 프로세스에는 입력 비밀과 핸드셰이크 기록이 모두 포함됩니다. 핸드셰이크 기록에는 Hello 메시지의 임의 값이 포함되어 있으므로 동일한 PSK가 여러 연결에 사용되는 경우와 같이 동일한 입력 비밀이 사용되더라도 특정 핸드셰이크에는 다른 트래픽 비밀이 있습니다.

---
### **7.1.  Key Schedule**

키 파생 프로세스에서는 HKDF \[RFC5869\]에 대해 정의된 HKDF-Extract 및 HKDF-Expand 함수와 아래에 정의된 함수를 사용합니다.

```text
       HKDF-Expand-Label(Secret, Label, Context, Length) =
            HKDF-Expand(Secret, HkdfLabel, Length)
```

- HkdfLabel은 다음과 같이 지정됩니다.

```text
       struct {
           uint16 length = Length;
           opaque label<7..255> = "tls13 " + Label;
           opaque context<0..255> = Context;
       } HkdfLabel;

       Derive-Secret(Secret, Label, Messages) =
            HKDF-Expand-Label(Secret, Label,
                              Transcript-Hash(Messages), Hash.length)
```

Transcript-Hash 및 HKDF에서 사용하는 해시 함수는 암호 제품군 해시 알고리즘입니다. Hash.length는 출력 길이\(바이트\)입니다. 메시지는 핸드셰이크 메시지 유형 및 길이 필드를 포함하지만 레코드 레이어 헤더는 포함하지 않는 표시된 핸드셰이크 메시지의 연결입니다. 어떤 경우에는 길이가 0인 Context\(""로 표시\)가 HKDF-Expand-Label에 전달됩니다. 이 문서에 지정된 레이블은 모두 ASCII 문자열이며 후행 NUL 바이트를 포함하지 않습니다.

참고: 일반적인 해시 함수를 사용하면 12자를 초과하는 모든 레이블을 계산하려면 해시 함수를 추가로 반복해야 합니다. 이 사양의 라벨은 모두 이 제한에 맞게 선택되었습니다.

키는 HKDF-Extract 및 Derive-Secret 함수를 사용하여 두 개의 입력 비밀에서 파생됩니다. 새 비밀을 추가하는 일반적인 패턴은 Salt가 현재 비밀 상태이고 IKM\(Input Keying Material\)이 추가될 새 비밀인 HKDF-Extract를 사용하는 것입니다. 이 버전의 TLS 1.3에서 두 가지 입력 비밀은 다음과 같습니다.

- PSK\(외부적으로 설정되거나 이전 연결의 resumption\_master\_secret 값에서 파생된 사전 공유 키\)

```text
   -  (EC)DHE shared secret (Section 7.4)
```

그러면 아래 다이어그램에 표시된 전체 키 파생 일정이 생성됩니다. 이 다이어그램에서는 다음 형식 지정 규칙이 적용됩니다.

- HKDF-Extract는 상단에서 Salt 인수를, 왼쪽에서 IKM 인수를 취하여 출력을 하단으로, 출력 이름을 오른쪽으로 가져오는 방식으로 그려집니다.

- Derive-Secret의 Secret 인수는 들어오는 화살표로 표시됩니다. 예를 들어 Early Secret은 client\_early\_traffic\_secret을 생성하기 위한 Secret입니다.

- "0"은 0으로 설정된 Hash.length 바이트의 문자열을 나타냅니다.

```text
             0
             |
             v
   PSK ->  HKDF-Extract = Early Secret
             |
             +-----> Derive-Secret(., "ext binder" | "res binder", "")
             |                     = binder_key
             |
             +-----> Derive-Secret(., "c e traffic", ClientHello)
             |                     = client_early_traffic_secret
             |
             +-----> Derive-Secret(., "e exp master", ClientHello)
             |                     = early_exporter_master_secret
             v
       Derive-Secret(., "derived", "")
             |
             v
   (EC)DHE -> HKDF-Extract = Handshake Secret
             |
             +-----> Derive-Secret(., "c hs traffic",
             |                     ClientHello...ServerHello)
             |                     = client_handshake_traffic_secret
             |
             +-----> Derive-Secret(., "s hs traffic",
             |                     ClientHello...ServerHello)
             |                     = server_handshake_traffic_secret
             v
       Derive-Secret(., "derived", "")
             |
             v
   0 -> HKDF-Extract = Master Secret
             |
             +-----> Derive-Secret(., "c ap traffic",
             |                     ClientHello...server Finished)
             |                     = client_application_traffic_secret_0
             |
             +-----> Derive-Secret(., "s ap traffic",
             |                     ClientHello...server Finished)
             |                     = server_application_traffic_secret_0
             |
             +-----> Derive-Secret(., "exp master",
             |                     ClientHello...server Finished)
             |                     = exporter_master_secret
             |
             +-----> Derive-Secret(., "res master",
                                   ClientHello...client Finished)
                                   = resumption_master_secret
```

여기서 일반적인 패턴은 다이어그램 왼쪽에 표시된 비밀은 컨텍스트가 없는 원시 엔트로피인 반면, 오른쪽 아래의 비밀은 핸드셰이크 컨텍스트를 포함하므로 추가 컨텍스트 없이 작업 키를 파생하는 데 사용할 수 있다는 것입니다. Derive-Secret에 대한 다른 호출은 동일한 비밀을 사용하더라도 다른 메시지 인수를 사용할 수 있습니다. 0-RTT 교환에서는 Derive-Secret이 4개의 개별 성적표와 함께 호출됩니다. 1-RTT 전용 교환에서는 세 가지 별도의 기록으로 호출됩니다.

특정 비밀을 사용할 수 없는 경우 0으로 설정된 Hash.length 바이트 문자열로 구성된 0 값이 사용됩니다. 이는 라운드를 건너뛰는 것을 의미하지 않으므로 PSK를 사용하지 않는 경우 Early Secret은 여전히 ​​HKDF-Extract\(0, 0\)입니다. Binder\_key 계산의 경우 레이블은 외부 PSK\(TLS 외부에서 프로비저닝된 PSK\)의 경우 "ext Binder"이고 재개 PSK\(이전 핸드셰이크의 재개 마스터 암호로 프로비저닝된 PSK\)의 경우 "res Binder"입니다. 서로 다른 레이블은 한 유형의 PSK를 다른 PSK로 대체하는 것을 방지합니다.

서버가 최종적으로 선택하는 PSK에 따라 여러 가지 잠재적 Early Secret 값이 있습니다. 클라이언트는 잠재적 PSK마다 하나씩 계산해야 합니다. PSK를 선택하지 않은 경우 PSK 0에 해당하는 Early Secret을 계산해야 합니다.

주어진 비밀에서 파생될 모든 값이 계산되면 해당 비밀은 삭제되어야 합니다.

---
### **7.2.  Updating Traffic Secrets**

핸드셰이크가 완료되면 어느 쪽이든 섹션 4.6.3에 정의된 KeyUpdate 핸드셰이크 메시지를 사용하여 전송 트래픽 키를 업데이트할 수 있습니다. 차세대 트래픽 키는 이 섹션에 설명된 대로 client\_/server\_application\_traffic\_secret\_N에서 client\_/server\_application\_traffic\_secret\_N+1을 생성한 다음 섹션 7.3에 설명된 대로 트래픽 키를 다시 파생하여 계산됩니다.

차세대 application\_traffic\_secret은 다음과 같이 계산됩니다.

```text
       application_traffic_secret_N+1 =
           HKDF-Expand-Label(application_traffic_secret_N,
                             "traffic upd", "", Hash.length)
```

client\_/server\_application\_traffic\_secret\_N+1 및 관련 트래픽 키가 계산되면 구현에서는 client\_/server\_application\_traffic\_secret\_N 및 관련 트래픽 키를 삭제해야 합니다\(SHOULD\).

---
### **7.3.  Traffic Key Calculation**

트래픽 키 자료는 다음 입력 값에서 생성됩니다.

- 비밀 값

- 생성되는 특정 가치를 나타내는 목적 값

- 생성되는 키의 길이

트래픽 키 자료는 다음을 사용하여 입력 트래픽 비밀 값에서 생성됩니다.

```text
   [sender]_write_key = HKDF-Expand-Label(Secret, "key", "", key_length)
   [sender]_write_iv  = HKDF-Expand-Label(Secret, "iv", "", iv_length)
```

\[보내는 사람\]은 보내는 쪽을 나타냅니다. 각 레코드 유형에 대한 Secret 값은 아래 표에 나와 있습니다.

```text
       +-------------------+---------------------------------------+
       | Record Type       | Secret                                |
       +-------------------+---------------------------------------+
       | 0-RTT Application | client_early_traffic_secret           |
       |                   |                                       |
       | Handshake         | [sender]_handshake_traffic_secret     |
       |                   |                                       |
       | Application Data  | [sender]_application_traffic_secret_N |
       +-------------------+---------------------------------------+
```

기본 보안 비밀이 변경될 때마다\(예: 핸드셰이크에서 애플리케이션 데이터 키로 변경하거나 키 업데이트 시\) 모든 트래픽 키 자료가 다시 계산됩니다.

---
### **7.4.  (EC)DHE Shared Secret Calculation**
---
#### **7.4.1.  Finite Field Diffie-Hellman**

유한 필드 그룹의 경우 기존 Diffie-Hellman \[DH76\] 계산이 수행됩니다. 협상된 키\(Z\)는 빅 엔디안 형식으로 인코딩하여 바이트 문자열로 변환되고 소수 크기까지 0으로 왼쪽이 채워집니다. 이 바이트 문자열은 위에 지정된 키 일정의 공유 비밀로 사용됩니다.

이 구성은 선행 0을 제거한 이전 버전의 TLS와 다릅니다.

---
#### **7.4.2.  Elliptic Curve Diffie-Hellman**

secp256r1, secp384r1 및 secp521r1의 경우 ECDH 계산\(매개변수 및 키 생성, 공유 비밀 계산 포함\)은 ID 맵을 키 파생 함수\(KDF\)로 사용하는 ECKAS-DH1 체계를 사용하여 \[IEEE1363\]에 따라 수행됩니다. 공유 비밀은 옥텟 문자열로 표현되는 ECDH 공유 비밀 타원 곡선 점의 x 좌표입니다. FE2OSP\(필드 요소에서 옥텟 문자열 변환 프리미티브\)의 출력인 이 옥텟 문자열\(IEEE 1363 용어로 "Z"\)은 지정된 필드에 대해 일정한 길이를 갖습니다. 이 옥텟 문자열에서 발견된 선행 0은 잘려서는 안 됩니다.

\(이러한 ID KDF 사용은 기술적인 문제입니다. TLS는 다른 비밀을 계산하는 것 이외의 다른 용도로 이 비밀을 직접 사용하지 않기 때문에 ECDH가 중요한 KDF와 함께 사용된다는 점에 유의하십시오.\)

X25519 및 X448의 경우 ECDH 계산은 다음과 같습니다.

- KeyShareEntry.key\_exchange 구조에 넣을 공개키는 적절한 길이의 비밀키\(스칼라 입력\)와 표준 공개 기준점\(u-좌표점 입력\)에 ECDH 스칼라 곱셈 함수를 적용한 결과입니다.

- ECDH 공유 비밀은 비밀 키\(스칼라 입력\)와 피어의 공개 키\(u 좌표점 입력\)에 ECDH 스칼라 곱셈 함수를 적용한 결과입니다. 출력은 처리 없이 원시로 사용됩니다.

이러한 곡선의 경우 구현 시 \[RFC7748\]에 지정된 접근 방식을 사용하여 Diffie-Hellman 공유 비밀을 계산해야 합니다. 구현에서는 \[RFC7748\]의 섹션 6에 설명된 대로 계산된 Diffie-Hellman 공유 비밀이 모두 0 값인지 확인하고 그렇다면 중단해야 합니다. 구현자가 이러한 타원 곡선의 대체 구현을 사용하는 경우 \[RFC7748\]의 섹션 7에 지정된 추가 검사를 수행해야 합니다.

---
### **7.5.  Exporters**

\[RFC5705\]는 TLS 의사 난수 함수\(PRF\) 측면에서 TLS용 키 자료 내보내기를 정의합니다. 이 문서는 PRF를 HKDF로 대체하므로 새로운 구성이 필요합니다. 내보내기 인터페이스는 동일하게 유지됩니다.

내보내기 값은 다음과 같이 계산됩니다.

```text
   TLS-Exporter(label, context_value, key_length) =
       HKDF-Expand-Label(Derive-Secret(Secret, label, ""),
                         "exporter", Hash(context_value), key_length)
```

여기서 Secret은 early\_exporter\_master\_secret 또는 importer\_master\_secret입니다. 구현은 애플리케이션에서 명시적으로 지정하지 않는 한 반드시 importer\_master\_secret을 사용해야 합니다. early\_exporter\_master\_secret은 0-RTT 데이터에 내보내기가 필요한 설정에 사용하도록 정의됩니다. 초기 내보내기를 위한 별도의 인터페이스를 권장합니다. 이렇게 하면 내보내기 사용자가 일반 내보내기를 원할 때 실수로 초기 내보내기를 사용하거나 그 반대의 경우도 방지할 수 있습니다.

컨텍스트가 제공되지 않으면 context\_value의 길이는 0입니다. 결과적으로 컨텍스트를 제공하지 않으면 빈 컨텍스트를 제공하는 것과 동일한 값이 계산됩니다. 이는 빈 컨텍스트가 없는 컨텍스트와 다른 출력을 생성하는 이전 버전의 TLS에서 변경된 사항입니다. 이 문서의 발행 시점에서는 컨텍스트 유무에 관계없이 할당된 수출업체 라벨이 사용되지 않습니다. 향후 사양은 빈 컨텍스트와 동일한 레이블이 있는 컨텍스트를 허용하지 않는 내보내기의 사용을 정의해서는 안 됩니다. 내보내기의 새로운 사용은 모든 내보내기 계산에 컨텍스트를 제공해야 하지만 값은 비어 있을 수 있습니다.

수출자 라벨 형식에 대한 요구 사항은 \[RFC5705\]의 섹션 4에 정의되어 있습니다.

---
## **8.  0-RTT and Anti-Replay**

섹션 2.3 및 부록 E.5에 명시된 대로 TLS는 0-RTT 데이터에 대한 고유한 재생 보호 기능을 제공하지 않습니다. 우려해야 할 두 가지 잠재적인 위협이 있습니다.

- 단순히 0-RTT 데이터의 비행을 복제하여 재생 공격을 수행하는 네트워크 공격자.

- 클라이언트 재시도 동작을 이용하여 서버가 응용 프로그램 메시지의 여러 복사본을 받도록 준비하는 네트워크 공격자. 견고성을 중시하는 클라이언트가 요청을 재시도하여 네트워크 오류에 응답하기 때문에 이 위협은 이미 어느 정도 존재합니다. 그러나 0-RTT는 전역적으로 일관된 서버 상태를 유지하지 않는 모든 서버 시스템에 추가적인 차원을 추가합니다. 특히 서버 시스템에 영역 A의 티켓이 영역 B에서 허용되지 않는 여러 영역이 있는 경우 공격자는 A와 B 모두에 ClientHello 및 초기 데이터를 복제할 수 있습니다. A에서 데이터는 다음에서 허용됩니다. 0-RTT, 그러나 B에서는 서버가 0-RTT 데이터를 거부하고 대신 전체 핸드셰이크를 강제합니다. 공격자가 A에서 ServerHello를 차단하면 클라이언트는 B와의 핸드셰이크를 완료하고 아마도 요청을 다시 시도하여 서버 시스템 전체에서 중복이 발생하게 됩니다.

0-RTT 데이터가 최대 한 번만 허용되도록 상태를 공유함으로써 첫 번째 유형의 공격을 방지할 수 있습니다. 서버는 이 섹션에 설명된 방법 중 하나를 구현하거나 동등한 수단을 통해 해당 수준의 재생 안전성을 제공해야 합니다. 그러나 운영 문제로 인해 모든 배포가 해당 수준에서 상태를 유지하지는 않는다는 점을 이해합니다. 따라서 정상적인 작동에서 클라이언트는 이러한 메커니즘 중 서버가 실제로 구현하는 메커니즘이 무엇인지 알 수 없으므로 재생하기에 안전하다고 판단되는 초기 데이터만 보내야 합니다.

재생의 직접적인 효과 외에도 일반적으로 멱등성으로 간주되는 작업조차도 다수의 재생\(부록 E.5에 설명된 타이밍 공격, 리소스 제한 고갈 및 기타\)에 의해 악용될 수 있는 공격 클래스가 있습니다. 모든 0-RTT 페이로드가 제한된 횟수만 재생될 수 있도록 함으로써 이러한 문제를 완화할 수 있습니다. 서버는 모든 인스턴스\(머신, 스레드 또는 관련 제공 인프라 내의 다른 엔터티\)가 최대 한 번 동일한 0-RTT 핸드셰이크에 대해 0-RTT를 허용하도록 해야 합니다. 이는 재생 횟수를 배포의 서버 인스턴스 수로 제한합니다. 이러한 보장은 최근 수신된 ClientHellos의 데이터를 로컬로 기록하고 반복을 거부하거나 다른 방법을 사용하여 수행할 수 있습니다.

동일하거나 더 강력한 보증을 제공합니다. "서버 인스턴스당 최대 한 번" 보장은 최소 요구 사항입니다. 서버는 가능한 경우 0-RTT 재생을 추가로 제한해야 합니다.

두 번째 유형의 공격은 TLS 계층에서 예방할 수 없으며 모든 애플리케이션에서 처리해야 합니다. 클라이언트가 재시도 동작을 구현하는 모든 애플리케이션은 이미 일종의 재생 방지 방어를 구현해야 합니다.

---
### **8.1.  Single-Use Tickets**

재생 방지 방어의 가장 간단한 형태는 서버가 각 세션 티켓을 한 번만 사용하도록 허용하는 것입니다. 예를 들어, 서버는 사용되는 모든 티켓을 데이터베이스에서 삭제하여 모든 미해결 유효한 티켓의 데이터베이스를 유지 관리할 수 있습니다. 알 수 없는 티켓이 제공되면 서버는 전체 핸드셰이크로 돌아갑니다.

티켓이 자체 포함되지 않고 오히려 데이터베이스 키이고 해당 PSK가 사용 시 삭제되는 경우 PSK를 사용하여 설정된 연결은 순방향 보안을 누리게 됩니다. 이는 \(EC\)DHE 없이 PSK를 사용할 때 모든 0-RTT 데이터 및 PSK 사용에 대한 보안을 향상시킵니다.

이 메커니즘은 여러 분산 서버가 있는 환경에서 서버 노드 간에 세션 데이터베이스를 공유해야 하기 때문에 자체 암호화된 티켓과 비교할 때 PSK 0-RTT 연결 성공률을 높이기가 어려울 수 있습니다. 세션 데이터베이스와 달리 세션 티켓은 일관된 저장소 없이도 PSK 기반 세션 설정을 성공적으로 수행할 수 있지만, 0-RTT가 허용되는 경우 다음 섹션에 설명된 대로 0-RTT 데이터의 재생 방지를 위해 여전히 일관된 저장소가 필요합니다.

---
### **8.2.  Client Hello Recording**

재생 방지의 또 다른 형태는 ClientHello에서 파생된 고유 값\(일반적으로 임의 값 또는 PSK 바인더\)을 기록하고 중복을 거부하는 것입니다. 모든 ClientHellos를 기록하면 상태가 제한 없이 증가하지만, 대신 서버는 주어진 기간 내에 ClientHellos를 기록하고 "obfuscated\_ticket\_age"를 사용하여 해당 기간 외부에서 티켓이 재사용되지 않도록 할 수 있습니다.

이를 구현하기 위해 ClientHello가 수신되면 서버는 먼저 섹션 4.2.11에 설명된 대로 PSK 바인더를 확인합니다. 그런 다음 다음 섹션에 설명된 대로 Expect\_arrival\_time을 계산하고 기록 기간을 벗어나면 0-RTT를 거부하고 1-RTT 핸드셰이크로 돌아갑니다.

예상\_도착\_시간이 창에 있으면 서버는 일치하는 ClientHello를 기록했는지 확인합니다. 발견되면 "illegal\_parameter" 경고와 함께 핸드셰이크를 중단하거나 PSK를 수락하지만 0-RTT를 거부합니다. 일치하는 ClientHello가 없으면 0-RTT를 수락한 다음 예상 도착\_시간이 창 내에 있는 동안 ClientHello를 저장합니다. 서버는 또한 Bloom 필터와 같은 거짓 긍정을 사용하여 데이터 저장소를 구현할 수도 있습니다. 이 경우 0-RTT를 거부하여 명백한 재생에 응답해야 하지만 핸드셰이크를 중단해서는 안 됩니다.

서버는 ClientHello의 검증된 섹션에서만 스토리지 키를 파생해야 합니다. ClientHello에 여러 PSK ID가 포함되어 있는 경우 공격자는 서버가 이를 확인하지 않는다는 가정하에\(섹션 4.2.11에서 권장하는 대로\) 덜 선호하는 ID에 대해 서로 다른 바인더 값을 사용하여 여러 ClientHello를 생성할 수 있습니다. 즉, 클라이언트가 PSK A와 B를 전송하지만 서버가 A를 선호하는 경우 공격자는 A의 바인더에 영향을 주지 않고 B의 바인더를 변경할 수 있습니다. B의 바인더가 저장소 키의 일부인 경우 이 ClientHello는 나타나지 않습니다. 이는 ClientHello가 허용되도록 하고 재생 캐시 오염과 같은 부작용을 일으킬 수 있지만 0-RTT 데이터는 다른 키를 사용하기 때문에 해독할 수 없습니다. 검증된 바인더 또는 ClientHello.random이 저장소 키로 사용되는 경우 이 공격은 불가능합니다.

이 메커니즘은 미해결 티켓을 모두 저장할 필요가 없기 때문에 재개율이 높고 0-RTT인 분산 시스템에서 구현하는 것이 더 쉬울 수 있습니다. 단, 티켓을 안정적으로 저장하고 검색하는 것이 어렵기 때문에 잠재적으로 재생 방지 방어가 약할 수 있습니다. ClientHello 메시지를 받았습니다. 이러한 많은 시스템에서는 수신된 모든 ClientHello를 전역적으로 일관된 저장소로 유지하는 것은 비현실적입니다. 이 경우 단일 저장 영역이 특정 티켓에 대해 권한을 부여하고 다른 영역에서는 해당 티켓에 대해 0-RTT를 거부함으로써 최상의 재생 방지 보호가 제공됩니다. 이 접근 방식은 단 하나의 영역만 0-RTT 데이터를 허용하므로 공격자의 단순 재생을 방지합니다. 더 약한 설계는 각 영역에 대해 별도의 스토리지를 구현하지만 모든 영역에서 0-RTT를 허용하는 것입니다. 이 접근 방식은 재생 횟수를 영역당 한 번으로 제한합니다. 물론 응용 프로그램 메시지 복제는 어느 디자인에서나 가능합니다.

구현이 새로 시작되면 기록 창의 일부가 시작 시간과 겹치는 한 0-RTT를 거부해야 합니다\(SHOULD\). 그렇지 않으면 해당 기간 동안 원래 전송된 재생을 수락할 위험이 있습니다.

참고: 클라이언트의 시계가 서버의 시계보다 훨씬 빠르게 실행되는 경우 나중에 창 외부에서 ClientHello가 수신될 수 있습니다. 이 경우 1-RTT에 대해 허용되어 클라이언트 재시도가 발생하고 나중에 허용될 수 있습니다. 0-RTT의 경우. 이는 섹션 8에 설명된 두 번째 공격 형태의 또 다른 변형입니다.

---
### **8.3.  Freshness Checks**

ClientHello는 클라이언트가 보낸 시간을 나타내기 때문에 ClientHello가 최근에 합리적으로 전송되었는지 여부를 효율적으로 판단하고 그러한 ClientHello에 대해 0-RTT만 허용하고, 그렇지 않으면 1-RTT 핸드셰이크로 폴백하는 것이 가능합니다. 이는 섹션 8.2에 설명된 ClientHello 저장 메커니즘에 필요합니다. 그렇지 않으면 서버가 ClientHellos를 무제한으로 저장해야 하고, 사용할 수 없는 ClientHellos를 효율적으로 거부할 수 있으므로 자체 포함된 일회용 티켓에 유용한 최적화입니다. 0-RTT.

이 메커니즘을 구현하려면 서버는 서버가 세션 티켓을 생성한 시간을 클라이언트와 서버 간의 예상 왕복 시간으로 오프셋하여 저장해야 합니다. 즉.,

```text
       adjusted_creation_time = creation_time + estimated_RTT
```

이 값은 티켓에 인코딩될 수 있으므로 미해결 티켓마다 상태를 유지할 필요가 없습니다. 서버는 클라이언트의 "pre\_shared\_key" 확장에 있는 "obfuscated\_ticket\_age" 매개변수에서 티켓의 "ticket\_age\_add" 값을 빼서 클라이언트의 티켓 수명 보기를 결정할 수 있습니다. 서버는 ClientHello의 예상\_도착\_시간을 다음과 같이 결정할 수 있습니다.

```text
     expected_arrival_time = adjusted_creation_time + clients_ticket_age
```

새로운 ClientHello가 수신되면 Expect\_arrival\_time을 현재 서버 벽시계 시간과 비교하여 일정량 이상 차이가 나면 0-RTT가 거부되지만 1-RTT 핸드셰이크는 완료될 수 있습니다.

예상 도착\_시간과 측정된 시간 사이의 불일치를 유발할 수 있는 몇 가지 잠재적인 오류 원인이 있습니다. 클라이언트 및 서버 클럭 속도의 변화는 최소화될 가능성이 높지만 잠재적으로 절대 시간은 큰 값으로 벗어날 수 있습니다. 네트워크 전파 지연은 경과 시간에 대한 적법한 값이 일치하지 않는 가장 큰 원인입니다. NewSessionTicket 및 ClientHello 메시지는 모두 재전송되어 지연될 수 있으며 이는 TCP에 의해 숨겨질 수 있습니다. 인터넷 클라이언트의 경우 이는 시계의 오류와 측정값의 변화를 설명하기 위해 10초 정도의 창이 있음을 의미합니다. 다른 배포 시나리오에는 요구 사항이 다를 수 있습니다. 클록 스큐 분포는 대칭이 아니므로 최적의 절충에는 허용되는 불일치 값의 비대칭 범위가 포함될 수 있습니다.

대역폭 및 시스템 용량에 따라 실제 설정에서 수십억 개의 재생이 포함될 수 있는 오류 기간 동안에는 신선도 확인만으로는 재생을 감지하지 못하기 때문에 재생을 방지하는 데 충분하지 않습니다. 또한 이 최신성 확인은 ClientHello가 수신될 때만 수행되며 후속 초기 애플리케이션 데이터 레코드가 수신될 때는 수행되지 않습니다. 초기 데이터가 승인된 후에도 레코드는 장기간에 걸쳐 계속해서 서버로 스트리밍될 수 있습니다.

---
## **9.  Compliance Requirements**
---
### **9.1.  Mandatory-to-Implement Cipher Suites**

달리 지정하는 애플리케이션 프로필 표준이 없는 경우:

TLS 호환 애플리케이션은 TLS\_AES\_128\_GCM\_SHA256 \[GCM\] 암호 모음을 구현해야 하며\(MUST\) TLS\_AES\_256\_GCM\_SHA384 \[GCM\] 및 TLS\_CHACHA20\_POLY1305\_SHA256 \[RFC8439\] 암호 모음을 구현해야 합니다\(부록 B.4 참조\).

TLS 호환 애플리케이션은 rsa\_pkcs1\_sha256\(인증서용\), rsa\_pss\_rsae\_sha256\(CertificateVerify 및 인증서용\) 및 ecdsa\_secp256r1\_sha256을 사용하여 디지털 서명을 지원해야 합니다. TLS 호환 애플리케이션은 secp256r1\(NIST P-256\)과의 키 교환을 지원해야 하며\(MUST\) X25519\[RFC7748\]와의 키 교환을 지원해야 합니다\(SHOULD\).

---
### **9.2.  Mandatory-to-Implement Extensions**

달리 지정하는 애플리케이션 프로필 표준이 없는 경우 TLS 호환 애플리케이션은 다음 TLS 확장을 구현해야 합니다.

```text
   -  Supported Versions ("supported_versions"; Section 4.2.1)

   -  Cookie ("cookie"; Section 4.2.2)

   -  Signature Algorithms ("signature_algorithms"; Section 4.2.3)

   -  Signature Algorithms Certificate ("signature_algorithms_cert";
      Section 4.2.3)

   -  Negotiated Groups ("supported_groups"; Section 4.2.7)

   -  Key Share ("key_share"; Section 4.2.8)
```

- 서버 이름 표시\("server\_name"; \[RFC6066\]의 섹션 3\)

모든 구현은 적용 가능한 기능을 제공할 때 다음 확장을 전송하고 사용해야 합니다.

- 모든 ClientHello, ServerHello 및 HelloRetryRequest 메시지에 대해 "supported\_versions"가 필수입니다.

- 인증서 인증을 위해서는 "signature\_algorithms"가 필수입니다.

- DHE 또는 ECDHE 키 교환을 사용하는 ClientHello 메시지에는 "supported\_groups"가 필수입니다.

- DHE 또는 ECDHE 키 교환에는 "key\_share"가 필요합니다.

- PSK 키 계약에는 "pre\_shared\_key"가 필수입니다.

- PSK 키 계약에는 "psk\_key\_exchange\_modes"가 필수입니다.

ClientHello의 본문에 0x0304가 포함된 "supported\_versions" 확장이 포함된 경우 클라이언트는 이 사양을 사용하여 협상을 시도하는 것으로 간주됩니다. 이러한 ClientHello 메시지는 다음 요구 사항을 충족해야 합니다.

- "pre\_shared\_key" 확장을 포함하지 않는 경우 "signature\_algorithms" 확장과 "supported\_groups" 확장을 모두 포함해야 합니다.

- "supported\_groups" 확장을 포함하는 경우 "key\_share" 확장도 포함해야 하며 그 반대의 경우도 마찬가지입니다. 빈 KeyShare.client\_shares 벡터가 허용됩니다.

이러한 요구 사항을 준수하지 않는 ClientHello를 수신하는 서버는 "missing\_extension" 경고와 함께 핸드셰이크를 중단해야 합니다.

또한 모든 구현은 이를 사용할 수 있는 애플리케이션에서 "server\_name" 확장의 사용을 지원해야 합니다. 서버는 클라이언트가 유효한 "server\_name" 확장자를 보내도록 요구할 수 있습니다. 이 확장이 필요한 서버는 "missing\_extension" 경고로 연결을 종료하여 "server\_name" 확장이 없는 ClientHello에 응답해야 합니다.

---
### **9.3.  Protocol Invariants**

이 섹션에서는 TLS 엔드포인트와 미들박스가 반드시 따라야 하는 불변성을 설명합니다. 이전 버전의 TLS에도 적용됩니다.

TLS는 안전하고 호환 가능하게 확장 가능하도록 설계되었습니다. 최신 클라이언트나 서버는 최신 피어와 통신할 때 가장 선호하는 공통 매개변수를 협상해야 합니다. TLS 핸드셰이크는 다운그레이드 보호 기능을 제공합니다. TLS를 종료하지 않고 최신 클라이언트와 최신 서버 간에 트래픽을 전달하는 미들박스는 핸드셰이크에 영향을 줄 수 없습니다\(부록 E.1 참조\). 동시에 배포는 서로 다른 속도로 업데이트되므로 최신 클라이언트 또는 서버는 이전 매개변수를 계속 지원할 수 있으며 이를 통해 이전 엔드포인트와 상호 운용할 수 있습니다.

이것이 작동하려면 구현 시 확장 가능한 필드를 올바르게 처리해야 합니다.

- ClientHello를 보내는 클라이언트는 여기에 광고된 모든 매개변수를 지원해야 합니다. 그렇지 않으면 해당 매개변수 중 하나를 선택하여 서버가 상호 운용되지 않을 수 있습니다.

- ClientHello를 수신하는 서버는 인식할 수 없는 모든 암호화 제품군, 확장 및 기타 매개변수를 올바르게 무시해야 합니다. 그렇지 않으면 최신 클라이언트와 상호 운용되지 않을 수 있습니다. TLS 1.3에서 CertificateRequest 또는 NewSessionTicket을 수신하는 클라이언트는 인식할 수 없는 모든 확장도 무시해야 합니다.

- TLS 연결을 종료하는 미들박스는 클라이언트가 기꺼이 수락할 인증서를 갖는 것을 포함하여 \(원래 클라이언트에 대해\) 호환 TLS 서버로 작동해야 하며, 확인을 포함하여 \(원래 서버에 대해\) 호환 TLS 클라이언트로도 작동해야 합니다. 원본 서버의 인증서. 특히, 이해하는 매개변수만 포함하는 자체 ClientHello를 생성해야 하며, 엔드포인트의 값을 전달하는 대신 새로운 ServerHello 임의 값을 생성해야 합니다.

- TLS의 프로토콜 요구 사항 및 보안 분석은 두 연결에만 별도로 적용됩니다. TLS 종결자를 안전하게 배포하려면 이 문서의 범위를 벗어나는 추가 보안 고려 사항이 필요합니다.

- 이해하지 못하는 ClientHello 매개변수를 전달하는 미들박스는 해당 ClientHello 이외의 메시지를 처리해서는 안 됩니다. 모든 후속 트래픽을 수정되지 않은 상태로 전달해야 합니다. 그렇지 않으면 최신 클라이언트 및 서버와 상호 운용되지 않을 수 있습니다.

- 전달된 ClientHellos에는 미들박스에서 지원하지 않는 기능에 대한 광고가 포함될 수 있으므로 응답에는 미들박스가 인식하지 못하는 향후 TLS 추가 사항이 포함될 수 있습니다. 이러한 추가 사항은 ClientHello 이외의 메시지를 임의로 변경할 수 있습니다. 특히, ServerHello에서 전송된 값이 변경될 수 있고, ServerHello 형식이 변경될 수 있으며, TLSCiphertext 형식이 변경될 수 있습니다.

TLS 1.3의 설계는 널리 배포된 비준수 TLS 미들박스로 인해 제한되었습니다\(부록 D.4 참조\). 그러나 불변성을 완화하지는 않습니다. 해당 미들박스는 계속해서 규정을 준수하지 않습니다.

---
## **10.  Security Considerations**

보안 문제는 이 메모 전체, 특히 부록 C, D 및 E에서 논의됩니다.

---
## **11.  IANA Considerations**

이 문서는 원래 \[RFC4346\]에서 생성되고 \[RFC8447\]에서 업데이트된 여러 레지스트리를 사용합니다. IANA는 이 문서를 참조하기 위해 이를 업데이트했습니다. 레지스트리 및 해당 할당 정책은 다음과 같습니다.

- TLS Cipher Suites 레지스트리: 0-254\(십진수\) 범위의 첫 번째 바이트 값은 사양 필수 \[RFC8126\]를 통해 할당됩니다. 첫 번째 바이트 255\(10진수\)의 값은 개인용으로 예약되어 있습니다\[RFC8126\].

- IANA는 부록 B.4에 나열된 암호 제품군을 레지스트리에 추가했습니다. "값" 및 "설명" 열은 표에서 가져옵니다. 각각의 새로운 암호화 제품군에 대해 "DTLS-OK" 및 "권장" 열은 모두 "Y"로 표시됩니다.

- TLS ContentType 레지스트리: 표준 조치 \[RFC8126\]를 통해 미래 값이 할당됩니다.

- TLS 경고 레지스트리: 표준 조치 \[RFC8126\]를 통해 미래 값이 할당됩니다. IANA는 이 레지스트리를 부록 B.2의 값으로 채웠습니다. 이러한 모든 값에 대해 "DTLS-OK" 열은 "Y"로 표시됩니다. "\_RESERVED"로 표시된 값에는 이전 사용법을 설명하는 설명이 있습니다.

- TLS HandshakeType 레지스트리: 표준 작업 \[RFC8126\]을 통해 미래 값이 할당됩니다. IANA는 이 레지스트리를 업데이트하여 항목 4의 이름을 "NewSessionTicket"에서 "new\_session\_ticket"으로 바꾸고 이 레지스트리를 부록 B.3의 값으로 채웠습니다. 이러한 모든 값에 대해 "DTLS-OK" 열은 "Y"로 표시됩니다. "\_RESERVED"로 표시된 값에는 이전 또는 임시 사용법을 설명하는 설명이 있습니다.

이 문서는 또한 원래 \[RFC4366\]에서 생성된 TLS ExtensionType Values ​​레지스트리를 사용합니다. IANA는 이 문서를 참조하도록 업데이트했습니다. 레지스트리 변경 사항은 다음과 같습니다.

- IANA는 등록 정책을 다음과 같이 업데이트했습니다.

- 0-254\(십진수\) 범위의 첫 번째 바이트 값은 사양 필수 \[RFC8126\]을 통해 할당됩니다. 첫 번째 바이트 255\(10진수\)의 값은 개인용으로 예약되어 있습니다\[RFC8126\].

- IANA는 "key\_share", "pre\_shared\_key", "psk\_key\_exchange\_modes", "early\_data", "cookie", "supported\_versions", "certificate\_authorities", "oid\_filters", "post\_handshake\_auth" 및 "signature\_algorithms\_cert" 확장을 포함하도록 이 레지스트리를 업데이트했습니다. 이 문서에 정의된 값과 "권장" 값 "Y"를 사용합니다.

- IANA는 확장이 나타날 수 있는 메시지를 나열하는 "TLS 1.3" 열을 포함하도록 이 레지스트리를 업데이트했습니다. 이 열은 처음에 섹션 4.2의 표에서 채워졌으며, 여기에 나열되지 않은 확장자는 TLS 1.3에서 사용되지 않음을 나타내기 위해 "-"로 표시되었습니다.

이 문서는 원래 \[RFC6091\]에서 생성되고 \[RFC8447\]에서 업데이트된 TLS 인증서 유형 레지스트리의 항목을 업데이트합니다. IANA는 값 1에 대한 항목을 업데이트하여 이름이 "OpenPGP\_RESERVED", "권장" 값 "N" 및 "1.3 이전 TLS 버전에서 사용됨"이라는 설명을 갖습니다.

이 문서는 \[RFC6961\]에서 원래 생성된 TLS 인증서 상태 유형 레지스트리의 항목을 업데이트합니다. IANA는 값 2에 대한 항목을 업데이트하여 이름이 "ocsp\_multi\_RESERVED"이고 주석이 "1.3 이전 TLS 버전에서 사용됨"입니다.

이 문서는 TLS 지원 그룹 레지스트리\(\[RFC4492\]에 의해 다른 이름으로 생성되었으며 현재 \[RFC8422\]에 의해 유지 관리됨\)의 두 항목을 업데이트하고 \[RFC7919\] 및 \[RFC8447\]에 의해 업데이트됩니다. 값 29 및 30\(x25519 및 x448\)에 대한 항목도 이 문서를 참조하도록 업데이트되었습니다.

또한 이 문서는 IANA에서 관리하는 두 가지 새로운 레지스트리를 정의합니다.

- TLS SignatureScheme 레지스트리: 0-253\(십진수\) 범위의 첫 번째 바이트 값은 사양 필수 \[RFC8126\]을 통해 할당됩니다. 첫 번째 바이트가 254 또는 255\(10진수\)인 값은 개인용으로 예약되어 있습니다\[RFC8126\]. 현재 할당되지 않은 0-6 범위의 첫 번째 바이트 또는 0-3 범위의 두 번째 바이트가 있는 값은 이전 버전과의 호환성을 위해 예약되어 있습니다. 이 레지스트리에는 "권장" 열이 있습니다. 레지스트리는 처음에 섹션 4.2.3에 설명된 값으로 채워졌습니다. 다음 값은 "권장"으로 표시됩니다: ecdsa\_secp256r1\_sha256, ecdsa\_secp384r1\_sha384, rsa\_pss\_rsae\_sha256, rsa\_pss\_rsae\_sha384, rsa\_pss\_rsae\_sha512, rsa\_pss\_pss\_sha256, rsa\_pss\_pss\_sha384, rsa\_pss \_pss\_sha512 및 ed25519. 명시적으로 요청하지 않는 한 "권장" 열에는 "N" 값이 할당되며 "권장" 값 "Y"가 있는 값을 추가하려면 표준 조치 \[RFC8126\]가 필요합니다. Y-\>N 전환에는 IESG 승인이 필요합니다.

- TLS PskKeyExchangeMode 레지스트리: 0-253\(십진수\) 범위의 값은 사양 필수 \[RFC8126\]를 통해 할당됩니다. 값 254 및 255\(10진수\)는 개인용으로 예약되어 있습니다\[RFC8126\]. 이 레지스트리에는 "권장" 열이 있습니다. 레지스트리는 처음에 psk\_ke\(0\) 및 psk\_dhe\_ke\(1\)로 채워졌습니다. 둘 다 "권장"으로 표시되어 있습니다. 명시적으로 요청하지 않는 한 "권장" 열에는 "N" 값이 할당되며 "권장" 값 "Y"가 있는 값을 추가하려면 표준 조치 \[RFC8126\]가 필요합니다. Y-\>N 전환에는 IESG 승인이 필요합니다.

---
## **12.  References**
---
### **12.1.  Normative References**

```text
   [DH76]     Diffie, W. and M. Hellman, "New directions in
              cryptography", IEEE Transactions on Information
              Theory, Vol. 22 No. 6, pp. 644-654,
              DOI 10.1109/TIT.1976.1055638, November 1976.

   [ECDSA]    American National Standards Institute, "Public Key
              Cryptography for the Financial Services Industry: The
              Elliptic Curve Digital Signature Algorithm (ECDSA)",
              ANSI ANS X9.62-2005, November 2005.

   [GCM]      Dworkin, M., "Recommendation for Block Cipher Modes of
              Operation: Galois/Counter Mode (GCM) and GMAC",
              NIST Special Publication 800-38D,
              DOI 10.6028/NIST.SP.800-38D, November 2007.

   [RFC2104]  Krawczyk, H., Bellare, M., and R. Canetti, "HMAC: Keyed-
              Hashing for Message Authentication", RFC 2104,
              DOI 10.17487/RFC2104, February 1997,
              <https://www.rfc-editor.org/info/rfc2104>.

   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", BCP 14, RFC 2119,
              DOI 10.17487/RFC2119, March 1997,
              <https://www.rfc-editor.org/info/rfc2119>.

   [RFC5116]  McGrew, D., "An Interface and Algorithms for Authenticated
              Encryption", RFC 5116, DOI 10.17487/RFC5116, January 2008,
              <https://www.rfc-editor.org/info/rfc5116>.

   [RFC5280]  Cooper, D., Santesson, S., Farrell, S., Boeyen, S.,
              Housley, R., and W. Polk, "Internet X.509 Public Key
              Infrastructure Certificate and Certificate Revocation List
              (CRL) Profile", RFC 5280, DOI 10.17487/RFC5280, May 2008,
              <https://www.rfc-editor.org/info/rfc5280>.

   [RFC5705]  Rescorla, E., "Keying Material Exporters for Transport
              Layer Security (TLS)", RFC 5705, DOI 10.17487/RFC5705,
              March 2010, <https://www.rfc-editor.org/info/rfc5705>.

   [RFC5756]  Turner, S., Brown, D., Yiu, K., Housley, R., and T. Polk,
              "Updates for RSAES-OAEP and RSASSA-PSS Algorithm
              Parameters", RFC 5756, DOI 10.17487/RFC5756, January 2010,
              <https://www.rfc-editor.org/info/rfc5756>.

   [RFC5869]  Krawczyk, H. and P. Eronen, "HMAC-based Extract-and-Expand
              Key Derivation Function (HKDF)", RFC 5869,
              DOI 10.17487/RFC5869, May 2010,
              <https://www.rfc-editor.org/info/rfc5869>.

   [RFC6066]  Eastlake 3rd, D., "Transport Layer Security (TLS)
              Extensions: Extension Definitions", RFC 6066,
              DOI 10.17487/RFC6066, January 2011,
              <https://www.rfc-editor.org/info/rfc6066>.

   [RFC6655]  McGrew, D. and D. Bailey, "AES-CCM Cipher Suites for
              Transport Layer Security (TLS)", RFC 6655,
              DOI 10.17487/RFC6655, July 2012,
              <https://www.rfc-editor.org/info/rfc6655>.

   [RFC6960]  Santesson, S., Myers, M., Ankney, R., Malpani, A.,
              Galperin, S., and C. Adams, "X.509 Internet Public Key
              Infrastructure Online Certificate Status Protocol - OCSP",
              RFC 6960, DOI 10.17487/RFC6960, June 2013,
              <https://www.rfc-editor.org/info/rfc6960>.

   [RFC6961]  Pettersen, Y., "The Transport Layer Security (TLS)
              Multiple Certificate Status Request Extension", RFC 6961,
              DOI 10.17487/RFC6961, June 2013,
              <https://www.rfc-editor.org/info/rfc6961>.

   [RFC6962]  Laurie, B., Langley, A., and E. Kasper, "Certificate
              Transparency", RFC 6962, DOI 10.17487/RFC6962, June 2013,
              <https://www.rfc-editor.org/info/rfc6962>.

   [RFC6979]  Pornin, T., "Deterministic Usage of the Digital Signature
              Algorithm (DSA) and Elliptic Curve Digital Signature
              Algorithm (ECDSA)", RFC 6979, DOI 10.17487/RFC6979,
              August 2013, <https://www.rfc-editor.org/info/rfc6979>.

   [RFC7301]  Friedl, S., Popov, A., Langley, A., and E. Stephan,
              "Transport Layer Security (TLS) Application-Layer Protocol
              Negotiation Extension", RFC 7301, DOI 10.17487/RFC7301,
              July 2014, <https://www.rfc-editor.org/info/rfc7301>.

   [RFC7507]  Moeller, B. and A. Langley, "TLS Fallback Signaling Cipher
              Suite Value (SCSV) for Preventing Protocol Downgrade
              Attacks", RFC 7507, DOI 10.17487/RFC7507, April 2015,
              <https://www.rfc-editor.org/info/rfc7507>.

   [RFC7748]  Langley, A., Hamburg, M., and S. Turner, "Elliptic Curves
              for Security", RFC 7748, DOI 10.17487/RFC7748,
              January 2016, <https://www.rfc-editor.org/info/rfc7748>.

   [RFC7919]  Gillmor, D., "Negotiated Finite Field Diffie-Hellman
              Ephemeral Parameters for Transport Layer Security (TLS)",
              RFC 7919, DOI 10.17487/RFC7919, August 2016,
              <https://www.rfc-editor.org/info/rfc7919>.

   [RFC8017]  Moriarty, K., Ed., Kaliski, B., Jonsson, J., and A. Rusch,
              "PKCS #1: RSA Cryptography Specifications Version 2.2",
              RFC 8017, DOI 10.17487/RFC8017, November 2016,
              <https://www.rfc-editor.org/info/rfc8017>.

   [RFC8032]  Josefsson, S. and I. Liusvaara, "Edwards-Curve Digital
              Signature Algorithm (EdDSA)", RFC 8032,
              DOI 10.17487/RFC8032, January 2017,
              <https://www.rfc-editor.org/info/rfc8032>.

   [RFC8126]  Cotton, M., Leiba, B., and T. Narten, "Guidelines for
              Writing an IANA Considerations Section in RFCs", BCP 26,
              RFC 8126, DOI 10.17487/RFC8126, June 2017,
              <https://www.rfc-editor.org/info/rfc8126>.

   [RFC8174]  Leiba, B., "Ambiguity of Uppercase vs Lowercase in
              RFC 2119 Key Words", BCP 14, RFC 8174,
              DOI 10.17487/RFC8174, May 2017,
              <https://www.rfc-editor.org/info/rfc8174>.

   [RFC8439]  Nir, Y. and A. Langley, "ChaCha20 and Poly1305 for IETF
              Protocols", RFC 8439, DOI 10.17487/RFC8439, June 2018,
              <https://www.rfc-editor.org/info/rfc8439>.

   [SHS]      Dang, Q., "Secure Hash Standard (SHS)", National Institute
              of Standards and Technology report,
              DOI 10.6028/NIST.FIPS.180-4, August 2015.

   [X690]     ITU-T, "Information technology -- ASN.1 encoding rules:
              Specification of Basic Encoding Rules (BER), Canonical
              Encoding Rules (CER) and Distinguished Encoding Rules
              (DER)", ISO/IEC 8825-1:2015, November 2015.
```

---
### **12.2.  Informative References**

```text
   [AEAD-LIMITS]
              Luykx, A. and K. Paterson, "Limits on Authenticated
              Encryption Use in TLS", August 2017,
              <http://www.isg.rhul.ac.uk/~kp/TLS-AEbounds.pdf>.

   [BBFGKZ16]
              Bhargavan, K., Brzuska, C., Fournet, C., Green, M.,
              Kohlweiss, M., and S. Zanella-Beguelin, "Downgrade
              Resilience in Key-Exchange Protocols", Proceedings of IEEE
              Symposium on Security and Privacy (San Jose),
              DOI 10.1109/SP.2016.37, May 2016.

   [BBK17]    Bhargavan, K., Blanchet, B., and N. Kobeissi, "Verified
              Models and Reference Implementations for the TLS 1.3
              Standard Candidate", Proceedings of IEEE Symposium on
              Security and Privacy (San Jose), DOI 10.1109/SP.2017.26,
              May 2017.

   [BDFKPPRSZZ16]
              Bhargavan, K., Delignat-Lavaud, A., Fournet, C.,
              Kohlweiss, M., Pan, J., Protzenko, J., Rastogi, A., Swamy,
              N., Zanella-Beguelin, S., and J. Zinzindohoue,
              "Implementing and Proving the TLS 1.3 Record Layer",
              Proceedings of IEEE Symposium on Security and Privacy (San
              Jose), May 2017, <https://eprint.iacr.org/2016/1178>.

   [Ben17a]   Benjamin, D., "Presentation before the TLS WG at
              IETF 100", November 2017,
              <https://datatracker.ietf.org/meeting/100/materials/
              slides-100-tls-sessa-tls13/>.

   [Ben17b]   Benjamin, D., "Additional TLS 1.3 results from Chrome",
              message to the TLS mailing list, 18 December 2017,
              <https://www.ietf.org/mail-archive/web/tls/current/
              msg25168.html>.

   [Blei98]   Bleichenbacher, D., "Chosen Ciphertext Attacks against
              Protocols Based on RSA Encryption Standard PKCS #1",
              Proceedings of CRYPTO '98, 1998.

   [BMMRT15]  Badertscher, C., Matt, C., Maurer, U., Rogaway, P., and B.
              Tackmann, "Augmented Secure Channels and the Goal of the
              TLS 1.3 Record Layer", ProvSec 2015, September 2015,
              <https://eprint.iacr.org/2015/394>.

   [BT16]     Bellare, M. and B. Tackmann, "The Multi-User Security of
              Authenticated Encryption: AES-GCM in TLS 1.3", Proceedings
              of CRYPTO 2016, July 2016,
              <https://eprint.iacr.org/2016/564>.

   [CCG16]    Cohn-Gordon, K., Cremers, C., and L. Garratt, "On
              Post-compromise Security", IEEE Computer Security
              Foundations Symposium, DOI 10.1109/CSF.2016.19, July 2015.

   [CHECKOWAY]
              Checkoway, S., Maskiewicz, J., Garman, C., Fried, J.,
              Cohney, S., Green, M., Heninger, N., Weinmann, R.,
              Rescorla, E., and H. Shacham, "A Systematic Analysis of
              the Juniper Dual EC Incident", Proceedings of the 2016 ACM
              SIGSAC Conference on Computer and Communications Security
              - CCS '16, DOI 10.1145/2976749.2978395, October 2016.

   [CHHSV17]  Cremers, C., Horvat, M., Hoyland, J., Scott, S., and T.
              van der Merwe, "Awkward Handshake: Possible mismatch of
              client/server view on client authentication in
              post-handshake mode in Revision 18", message to the TLS
              mailing list, 10 February 2017, <https://www.ietf.org/
              mail-archive/web/tls/current/msg22382.html>.

   [CHSV16]   Cremers, C., Horvat, M., Scott, S., and T. van der Merwe,
              "Automated Analysis and Verification of TLS 1.3: 0-RTT,
              Resumption and Delayed Authentication", Proceedings of
              IEEE Symposium on Security and Privacy (San Jose),
              DOI 10.1109/SP.2016.35, May 2016,
              <https://ieeexplore.ieee.org/document/7546518/>.

   [CK01]     Canetti, R. and H. Krawczyk, "Analysis of Key-Exchange
              Protocols and Their Use for Building Secure Channels",
              Proceedings of Eurocrypt 2001,
              DOI 10.1007/3-540-44987-6_28, April 2001.

   [CLINIC]   Miller, B., Huang, L., Joseph, A., and J. Tygar, "I Know
              Why You Went to the Clinic: Risks and Realization of HTTPS
              Traffic Analysis", Privacy Enhancing Technologies, pp.
              143-163, DOI 10.1007/978-3-319-08506-7_8, 2014.

   [DFGS15]   Dowling, B., Fischlin, M., Guenther, F., and D. Stebila,
              "A Cryptographic Analysis of the TLS 1.3 Handshake
              Protocol Candidates", Proceedings of ACM CCS 2015,
              October 2015, <https://eprint.iacr.org/2015/914>.

   [DFGS16]   Dowling, B., Fischlin, M., Guenther, F., and D. Stebila,
              "A Cryptographic Analysis of the TLS 1.3 Full and
              Pre-shared Key Handshake Protocol", TRON 2016,
              February 2016, <https://eprint.iacr.org/2016/081>.

   [DOW92]    Diffie, W., van Oorschot, P., and M. Wiener,
              "Authentication and authenticated key exchanges", Designs,
              Codes and Cryptography, DOI 10.1007/BF00124891, June 1992.

   [DSS]      National Institute of Standards and Technology, U.S.
              Department of Commerce, "Digital Signature Standard
              (DSS)", NIST FIPS PUB 186-4, DOI 10.6028/NIST.FIPS.186-4,
              July 2013.

   [FG17]     Fischlin, M. and F. Guenther, "Replay Attacks on Zero
              Round-Trip Time: The Case of the TLS 1.3 Handshake
              Candidates", Proceedings of EuroS&P 2017, April 2017,
              <https://eprint.iacr.org/2017/082>.

   [FGSW16]   Fischlin, M., Guenther, F., Schmidt, B., and B. Warinschi,
              "Key Confirmation in Key Exchange: A Formal Treatment and
              Implications for TLS 1.3", Proceedings of IEEE Symposium
              on Security and Privacy (San Jose),
              DOI 10.1109/SP.2016.34, May 2016,
              <https://ieeexplore.ieee.org/document/7546517/>.

   [FW15]     Weimer, F., "Factoring RSA Keys With TLS Perfect Forward
              Secrecy", September 2015.

   [HCJC16]   Husak, M., Cermak, M., Jirsik, T., and P. Celeda, "HTTPS
              traffic analysis and client identification using passive
              SSL/TLS fingerprinting", EURASIP Journal on Information
              Security, Vol. 2016, DOI 10.1186/s13635-016-0030-7,
              February 2016.

   [HGFS15]   Hlauschek, C., Gruber, M., Fankhauser, F., and C. Schanes,
              "Prying Open Pandora's Box: KCI Attacks against TLS",
              Proceedings of USENIX Workshop on Offensive Technologies,
              August 2015.

   [IEEE1363]
              IEEE, "IEEE Standard Specifications for Public Key
              Cryptography", IEEE Std. 1363-2000,
              DOI 10.1109/IEEESTD.2000.92292.

   [JSS15]    Jager, T., Schwenk, J., and J. Somorovsky, "On the
              Security of TLS 1.3 and QUIC Against Weaknesses in PKCS#1
              v1.5 Encryption", Proceedings of ACM CCS 2015,
              DOI 10.1145/2810103.2813657, October 2015,
              <https://www.nds.rub.de/media/nds/
              veroeffentlichungen/2015/08/21/Tls13QuicAttacks.pdf>.

   [KEYAGREEMENT]
              Barker, E., Chen, L., Roginsky, A., Vassilev, A., and R.
              Davis, "Recommendation for Pair-Wise Key Establishment
              Schemes Using Discrete Logarithm Cryptography", National
              Institute of Standards and Technology,
              DOI 10.6028/NIST.SP.800-56Ar3, April 2018.

   [Kraw10]   Krawczyk, H., "Cryptographic Extraction and Key
              Derivation: The HKDF Scheme", Proceedings of CRYPTO 2010,
              August 2010, <https://eprint.iacr.org/2010/264>.

   [Kraw16]   Krawczyk, H., "A Unilateral-to-Mutual Authentication
              Compiler for Key Exchange (with Applications to Client
              Authentication in TLS 1.3", Proceedings of ACM CCS 2016,
              October 2016, <https://eprint.iacr.org/2016/711>.

   [KW16]     Krawczyk, H. and H. Wee, "The OPTLS Protocol and TLS 1.3",
              Proceedings of EuroS&P 2016, March 2016,
              <https://eprint.iacr.org/2015/978>.

   [LXZFH16]  Li, X., Xu, J., Zhang, Z., Feng, D., and H. Hu, "Multiple
              Handshakes Security of TLS 1.3 Candidates", Proceedings of
              IEEE Symposium on Security and Privacy (San Jose),
              DOI 10.1109/SP.2016.36, May 2016,
              <https://ieeexplore.ieee.org/document/7546519/>.

   [Mac17]    MacCarthaigh, C., "Security Review of TLS1.3 0-RTT",
              March 2017, <https://github.com/tlswg/tls13-spec/
              issues/1001>.

   [PS18]     Patton, C. and T. Shrimpton, "Partially specified
              channels: The TLS 1.3 record layer without elision", 2018,
              <https://eprint.iacr.org/2018/634>.

   [PSK-FINISHED]
              Scott, S., Cremers, C., Horvat, M., and T. van der Merwe,
              "Revision 10: possible attack if client authentication is
              allowed during PSK", message to the TLS mailing list,
              31 October 2015, <https://www.ietf.org/
              mail-archive/web/tls/current/msg18215.html>.

   [REKEY]    Abdalla, M. and M. Bellare, "Increasing the Lifetime of a
              Key: A Comparative Analysis of the Security of Re-keying
              Techniques", ASIACRYPT 2000, DOI 10.1007/3-540-44448-3_42,
              October 2000.

   [Res17a]   Rescorla, E., "Preliminary data on Firefox TLS 1.3
              Middlebox experiment", message to the TLS mailing list,
              5 December 2017, <https://www.ietf.org/
              mail-archive/web/tls/current/msg25091.html>.

   [Res17b]   Rescorla, E., "More compatibility measurement results",
              message to the TLS mailing list, 22 December 2017,
              <https://www.ietf.org/mail-archive/web/tls/current/
              msg25179.html>.

   [RFC3552]  Rescorla, E. and B. Korver, "Guidelines for Writing RFC
              Text on Security Considerations", BCP 72, RFC 3552,
              DOI 10.17487/RFC3552, July 2003,
              <https://www.rfc-editor.org/info/rfc3552>.

   [RFC4086]  Eastlake 3rd, D., Schiller, J., and S. Crocker,
              "Randomness Requirements for Security", BCP 106, RFC 4086,
              DOI 10.17487/RFC4086, June 2005,
              <https://www.rfc-editor.org/info/rfc4086>.

   [RFC4346]  Dierks, T. and E. Rescorla, "The Transport Layer Security
              (TLS) Protocol Version 1.1", RFC 4346,
              DOI 10.17487/RFC4346, April 2006,
              <https://www.rfc-editor.org/info/rfc4346>.

   [RFC4366]  Blake-Wilson, S., Nystrom, M., Hopwood, D., Mikkelsen, J.,
              and T. Wright, "Transport Layer Security (TLS)
              Extensions", RFC 4366, DOI 10.17487/RFC4366, April 2006,
              <https://www.rfc-editor.org/info/rfc4366>.

   [RFC4492]  Blake-Wilson, S., Bolyard, N., Gupta, V., Hawk, C., and B.
              Moeller, "Elliptic Curve Cryptography (ECC) Cipher Suites
              for Transport Layer Security (TLS)", RFC 4492,
              DOI 10.17487/RFC4492, May 2006,
              <https://www.rfc-editor.org/info/rfc4492>.

   [RFC5077]  Salowey, J., Zhou, H., Eronen, P., and H. Tschofenig,
              "Transport Layer Security (TLS) Session Resumption without
              Server-Side State", RFC 5077, DOI 10.17487/RFC5077,
              January 2008, <https://www.rfc-editor.org/info/rfc5077>.

   [RFC5246]  Dierks, T. and E. Rescorla, "The Transport Layer Security
              (TLS) Protocol Version 1.2", RFC 5246,
              DOI 10.17487/RFC5246, August 2008,
              <https://www.rfc-editor.org/info/rfc5246>.

   [RFC5764]  McGrew, D. and E. Rescorla, "Datagram Transport Layer
              Security (DTLS) Extension to Establish Keys for the Secure
              Real-time Transport Protocol (SRTP)", RFC 5764,
              DOI 10.17487/RFC5764, May 2010,
              <https://www.rfc-editor.org/info/rfc5764>.

   [RFC5929]  Altman, J., Williams, N., and L. Zhu, "Channel Bindings
              for TLS", RFC 5929, DOI 10.17487/RFC5929, July 2010,
              <https://www.rfc-editor.org/info/rfc5929>.

   [RFC6091]  Mavrogiannopoulos, N. and D. Gillmor, "Using OpenPGP Keys
              for Transport Layer Security (TLS) Authentication",
              RFC 6091, DOI 10.17487/RFC6091, February 2011,
              <https://www.rfc-editor.org/info/rfc6091>.

   [RFC6101]  Freier, A., Karlton, P., and P. Kocher, "The Secure
              Sockets Layer (SSL) Protocol Version 3.0", RFC 6101,
              DOI 10.17487/RFC6101, August 2011,
              <https://www.rfc-editor.org/info/rfc6101>.

   [RFC6176]  Turner, S. and T. Polk, "Prohibiting Secure Sockets Layer
              (SSL) Version 2.0", RFC 6176, DOI 10.17487/RFC6176,
              March 2011, <https://www.rfc-editor.org/info/rfc6176>.

   [RFC6347]  Rescorla, E. and N. Modadugu, "Datagram Transport Layer
              Security Version 1.2", RFC 6347, DOI 10.17487/RFC6347,
              January 2012, <https://www.rfc-editor.org/info/rfc6347>.

   [RFC6520]  Seggelmann, R., Tuexen, M., and M. Williams, "Transport
              Layer Security (TLS) and Datagram Transport Layer Security
              (DTLS) Heartbeat Extension", RFC 6520,
              DOI 10.17487/RFC6520, February 2012,
              <https://www.rfc-editor.org/info/rfc6520>.

   [RFC7230]  Fielding, R., Ed. and J. Reschke, Ed., "Hypertext Transfer
              Protocol (HTTP/1.1): Message Syntax and Routing",
              RFC 7230, DOI 10.17487/RFC7230, June 2014,
              <https://www.rfc-editor.org/info/rfc7230>.

   [RFC7250]  Wouters, P., Ed., Tschofenig, H., Ed., Gilmore, J.,
              Weiler, S., and T. Kivinen, "Using Raw Public Keys in
              Transport Layer Security (TLS) and Datagram Transport
              Layer Security (DTLS)", RFC 7250, DOI 10.17487/RFC7250,
              June 2014, <https://www.rfc-editor.org/info/rfc7250>.

   [RFC7465]  Popov, A., "Prohibiting RC4 Cipher Suites", RFC 7465,
              DOI 10.17487/RFC7465, February 2015,
              <https://www.rfc-editor.org/info/rfc7465>.

   [RFC7568]  Barnes, R., Thomson, M., Pironti, A., and A. Langley,
              "Deprecating Secure Sockets Layer Version 3.0", RFC 7568,
              DOI 10.17487/RFC7568, June 2015,
              <https://www.rfc-editor.org/info/rfc7568>.

   [RFC7627]  Bhargavan, K., Ed., Delignat-Lavaud, A., Pironti, A.,
              Langley, A., and M. Ray, "Transport Layer Security (TLS)
              Session Hash and Extended Master Secret Extension",
              RFC 7627, DOI 10.17487/RFC7627, September 2015,
              <https://www.rfc-editor.org/info/rfc7627>.

   [RFC7685]  Langley, A., "A Transport Layer Security (TLS) ClientHello
              Padding Extension", RFC 7685, DOI 10.17487/RFC7685,
              October 2015, <https://www.rfc-editor.org/info/rfc7685>.

   [RFC7924]  Santesson, S. and H. Tschofenig, "Transport Layer Security
              (TLS) Cached Information Extension", RFC 7924,
              DOI 10.17487/RFC7924, July 2016,
              <https://www.rfc-editor.org/info/rfc7924>.

   [RFC8305]  Schinazi, D. and T. Pauly, "Happy Eyeballs Version 2:
              Better Connectivity Using Concurrency", RFC 8305,
              DOI 10.17487/RFC8305, December 2017,
              <https://www.rfc-editor.org/info/rfc8305>.

   [RFC8422]  Nir, Y., Josefsson, S., and M. Pegourie-Gonnard, "Elliptic
              Curve Cryptography (ECC) Cipher Suites for Transport Layer
              Security (TLS) Versions 1.2 and Earlier", RFC 8422,
              DOI 10.17487/RFC8422, August 2018,
              <https://www.rfc-editor.org/info/rfc8422>.

   [RFC8447]  Salowey, J. and S. Turner, "IANA Registry Updates for TLS
              and DTLS", RFC 8447, DOI 10.17487/RFC8447, August 2018,
              <https://www.rfc-editor.org/info/rfc8447>.

   [RFC8449]  Thomson, M., "Record Size Limit Extension for TLS",
              RFC 8449, DOI 10.17487/RFC8449, August 2018,
              <https://www.rfc-editor.org/info/rfc8449>.

   [RSA]      Rivest, R., Shamir, A., and L. Adleman, "A Method for
              Obtaining Digital Signatures and Public-Key
              Cryptosystems", Communications of the ACM, Vol. 21 No. 2,
              pp. 120-126, DOI 10.1145/359340.359342, February 1978.

   [SIGMA]    Krawczyk, H., "SIGMA: The 'SIGn-and-MAc' Approach to
              Authenticated Diffie-Hellman and its Use in the IKE
              Protocols", Proceedings of CRYPTO 2003,
              DOI 10.1007/978-3-540-45146-4_24, August 2003.

   [SLOTH]    Bhargavan, K. and G. Leurent, "Transcript Collision
              Attacks: Breaking Authentication in TLS, IKE, and SSH",
              Network and Distributed System Security
              Symposium (NDSS 2016), DOI 10.14722/ndss.2016.23418,
              February 2016.

   [SSL2]     Hickman, K., "The SSL Protocol", February 1995.

   [TIMING]   Boneh, D. and D. Brumley, "Remote Timing Attacks Are
              Practical", USENIX Security Symposium, August 2003.

   [TLS13-TRACES]
              Thomson, M., "Example Handshake Traces for TLS 1.3", Work
              in Progress, draft-ietf-tls-tls13-vectors-06, July 2018.

   [X501]     ITU-T, "Information Technology - Open Systems
              Interconnection - The Directory: Models", ITU-T X.501,
              October 2016, <https://www.itu.int/rec/T-REC-X.501/en>.
```

---
# **Appendix A.  State Machine**

이 부록은 클라이언트 및 서버 핸드셰이크에 대한 법적 상태 전환에 대한 요약을 제공합니다. 상태 이름\(모두 대문자로 표시\(예: START\)\)은 공식적인 의미는 없지만 이해하기 쉽도록 제공됩니다. 특정 상황에서만 취해지는 조치는 \[\] 안에 표시됩니다. "K\_{send,recv} = foo"라는 표기는 "send/recv 키를 주어진 키로 설정한다"는 의미입니다.

---
### **A.1.  Client**

```text
                              START <----+
               Send ClientHello |        | Recv HelloRetryRequest
          [K_send = early data] |        |
                                v        |
           /                 WAIT_SH ----+
           |                    | Recv ServerHello
           |                    | K_recv = handshake
       Can |                    V
      send |                 WAIT_EE
     early |                    | Recv EncryptedExtensions
      data |           +--------+--------+
           |     Using |                 | Using certificate
           |       PSK |                 v
           |           |            WAIT_CERT_CR
           |           |        Recv |       | Recv CertificateRequest
           |           | Certificate |       v
           |           |             |    WAIT_CERT
           |           |             |       | Recv Certificate
           |           |             v       v
           |           |              WAIT_CV
           |           |                 | Recv CertificateVerify
           |           +> WAIT_FINISHED <+
           |                  | Recv Finished
           \                  | [Send EndOfEarlyData]
                              | K_send = handshake
                              | [Send Certificate [+ CertificateVerify]]
    Can send                  | Send Finished
    app data   -->            | K_send = K_recv = application
    after here                v
                          CONNECTED
```

위에 표시된 전환을 통해 클라이언트는 일반 또는 초기 데이터 키를 사용하여 사후 ServerHello 메시지에서 파생된 경고를 보낼 수 있습니다. 클라이언트가 그러한 경고를 보내야 하는 경우 가능하면 먼저 핸드셰이크 키를 다시 입력해야 합니다.

---
### **A.2.  Server**

```text
                              START <-----+
               Recv ClientHello |         | Send HelloRetryRequest
                                v         |
                             RECVD_CH ----+
                                | Select parameters
                                v
                             NEGOTIATED
                                | Send ServerHello
                                | K_send = handshake
                                | Send EncryptedExtensions
                                | [Send CertificateRequest]
 Can send                       | [Send Certificate + CertificateVerify]
 app data                       | Send Finished
 after   -->                    | K_send = application
 here                  +--------+--------+
              No 0-RTT |                 | 0-RTT
                       |                 |
   K_recv = handshake  |                 | K_recv = early data
 [Skip decrypt errors] |    +------> WAIT_EOED -+
                       |    |       Recv |      | Recv EndOfEarlyData
                       |    | early data |      | K_recv = handshake
                       |    +------------+      |
                       |                        |
                       +> WAIT_FLIGHT2 <--------+
                                |
                       +--------+--------+
               No auth |                 | Client auth
                       |                 |
                       |                 v
                       |             WAIT_CERT
                       |        Recv |       | Recv Certificate
                       |       empty |       v
                       | Certificate |    WAIT_CV
                       |             |       | Recv
                       |             v       | CertificateVerify
                       +-> WAIT_FINISHED <---+
                                | Recv Finished
                                | K_recv = application
                                v
                            CONNECTED
```

---
# **Appendix B.  Protocol Data Structures and Constant Values**

이 부록은 규범적인 프로토콜 유형과 상수에 대한 정의를 제공합니다. "\_RESERVED"로 나열된 값은 이전 버전의 TLS에서 사용되었으며 완전성을 위해 여기에 나열되었습니다. TLS 1.3 구현은 이를 전송해서는 안 되지만 이전 TLS 구현에서 수신할 수 있습니다.

---
### **B.1.  Record Layer**

```text
      enum {
          invalid(0),
          change_cipher_spec(20),
          alert(21),
          handshake(22),
          application_data(23),
          heartbeat(24),  /* RFC 6520 */
          (255)
      } ContentType;

      struct {
          ContentType type;
          ProtocolVersion legacy_record_version;
          uint16 length;
          opaque fragment[TLSPlaintext.length];
      } TLSPlaintext;

      struct {
          opaque content[TLSPlaintext.length];
          ContentType type;
          uint8 zeros[length_of_padding];
      } TLSInnerPlaintext;

      struct {
          ContentType opaque_type = application_data; /* 23 */
          ProtocolVersion legacy_record_version = 0x0303; /* TLS v1.2 */
          uint16 length;
          opaque encrypted_record[TLSCiphertext.length];
      } TLSCiphertext;
```

---
### **B.2.  Alert Messages**

```text
      enum { warning(1), fatal(2), (255) } AlertLevel;

      enum {
          close_notify(0),
          unexpected_message(10),
          bad_record_mac(20),
          decryption_failed_RESERVED(21),
          record_overflow(22),
          decompression_failure_RESERVED(30),
          handshake_failure(40),
          no_certificate_RESERVED(41),
          bad_certificate(42),
          unsupported_certificate(43),
          certificate_revoked(44),
          certificate_expired(45),
          certificate_unknown(46),
          illegal_parameter(47),
          unknown_ca(48),
          access_denied(49),
          decode_error(50),
          decrypt_error(51),
          export_restriction_RESERVED(60),
          protocol_version(70),
          insufficient_security(71),
          internal_error(80),
          inappropriate_fallback(86),
          user_canceled(90),
          no_renegotiation_RESERVED(100),
          missing_extension(109),
          unsupported_extension(110),
          certificate_unobtainable_RESERVED(111),
          unrecognized_name(112),
          bad_certificate_status_response(113),
          bad_certificate_hash_value_RESERVED(114),
          unknown_psk_identity(115),
          certificate_required(116),
          no_application_protocol(120),
          (255)
      } AlertDescription;

      struct {
          AlertLevel level;
          AlertDescription description;
      } Alert;
```

---
### **B.3.  Handshake Protocol**

```text
      enum {
          hello_request_RESERVED(0),
          client_hello(1),
          server_hello(2),
          hello_verify_request_RESERVED(3),
          new_session_ticket(4),
          end_of_early_data(5),
          hello_retry_request_RESERVED(6),
          encrypted_extensions(8),
          certificate(11),
          server_key_exchange_RESERVED(12),
          certificate_request(13),
          server_hello_done_RESERVED(14),
          certificate_verify(15),
          client_key_exchange_RESERVED(16),
          finished(20),
          certificate_url_RESERVED(21),
          certificate_status_RESERVED(22),
          supplemental_data_RESERVED(23),
          key_update(24),
          message_hash(254),
          (255)
      } HandshakeType;

      struct {
          HandshakeType msg_type;    /* handshake type */
          uint24 length;             /* bytes in message */
          select (Handshake.msg_type) {
              case client_hello:          ClientHello;
              case server_hello:          ServerHello;
              case end_of_early_data:     EndOfEarlyData;
              case encrypted_extensions:  EncryptedExtensions;
              case certificate_request:   CertificateRequest;
              case certificate:           Certificate;
              case certificate_verify:    CertificateVerify;
              case finished:              Finished;
              case new_session_ticket:    NewSessionTicket;
              case key_update:            KeyUpdate;
          };
      } Handshake;
```

---
#### **B.3.1.  Key Exchange Messages**

```text
    uint16 ProtocolVersion;
    opaque Random[32];

    uint8 CipherSuite[2];    /* Cryptographic suite selector */

    struct {
        ProtocolVersion legacy_version = 0x0303;    /* TLS v1.2 */
        Random random;
        opaque legacy_session_id<0..32>;
        CipherSuite cipher_suites<2..2^16-2>;
        opaque legacy_compression_methods<1..2^8-1>;
        Extension extensions<8..2^16-1>;
    } ClientHello;

    struct {
        ProtocolVersion legacy_version = 0x0303;    /* TLS v1.2 */
        Random random;
        opaque legacy_session_id_echo<0..32>;
        CipherSuite cipher_suite;
        uint8 legacy_compression_method = 0;
        Extension extensions<6..2^16-1>;
    } ServerHello;

    struct {
        ExtensionType extension_type;
        opaque extension_data<0..2^16-1>;
    } Extension;

    enum {
        server_name(0),                             /* RFC 6066 */
        max_fragment_length(1),                     /* RFC 6066 */
        status_request(5),                          /* RFC 6066 */
        supported_groups(10),                       /* RFC 8422, 7919 */
        signature_algorithms(13),                   /* RFC 8446 */
        use_srtp(14),                               /* RFC 5764 */
        heartbeat(15),                              /* RFC 6520 */
        application_layer_protocol_negotiation(16), /* RFC 7301 */
        signed_certificate_timestamp(18),           /* RFC 6962 */
        client_certificate_type(19),                /* RFC 7250 */
        server_certificate_type(20),                /* RFC 7250 */
        padding(21),                                /* RFC 7685 */
        RESERVED(40),                               /* Used but never
                                                       assigned */
        pre_shared_key(41),                         /* RFC 8446 */
        early_data(42),                             /* RFC 8446 */
        supported_versions(43),                     /* RFC 8446 */
        cookie(44),                                 /* RFC 8446 */
        psk_key_exchange_modes(45),                 /* RFC 8446 */
        RESERVED(46),                               /* Used but never
                                                       assigned */
        certificate_authorities(47),                /* RFC 8446 */
        oid_filters(48),                            /* RFC 8446 */
        post_handshake_auth(49),                    /* RFC 8446 */
        signature_algorithms_cert(50),              /* RFC 8446 */
        key_share(51),                              /* RFC 8446 */
        (65535)
    } ExtensionType;

    struct {
        NamedGroup group;
        opaque key_exchange<1..2^16-1>;
    } KeyShareEntry;

    struct {
        KeyShareEntry client_shares<0..2^16-1>;
    } KeyShareClientHello;

    struct {
        NamedGroup selected_group;
    } KeyShareHelloRetryRequest;

    struct {
        KeyShareEntry server_share;
    } KeyShareServerHello;

    struct {
        uint8 legacy_form = 4;
        opaque X[coordinate_length];
        opaque Y[coordinate_length];
    } UncompressedPointRepresentation;

    enum { psk_ke(0), psk_dhe_ke(1), (255) } PskKeyExchangeMode;

    struct {
        PskKeyExchangeMode ke_modes<1..255>;
    } PskKeyExchangeModes;

    struct {} Empty;

    struct {
        select (Handshake.msg_type) {
            case new_session_ticket:   uint32 max_early_data_size;
            case client_hello:         Empty;
            case encrypted_extensions: Empty;
        };
    } EarlyDataIndication;

    struct {
        opaque identity<1..2^16-1>;
        uint32 obfuscated_ticket_age;
    } PskIdentity;

    opaque PskBinderEntry<32..255>;

    struct {
        PskIdentity identities<7..2^16-1>;
        PskBinderEntry binders<33..2^16-1>;
    } OfferedPsks;

    struct {
        select (Handshake.msg_type) {
            case client_hello: OfferedPsks;
            case server_hello: uint16 selected_identity;
        };
    } PreSharedKeyExtension;
```

---
##### **B.3.1.1.  Version Extension**

```text
      struct {
          select (Handshake.msg_type) {
              case client_hello:
                   ProtocolVersion versions<2..254>;

              case server_hello: /* and HelloRetryRequest */
                   ProtocolVersion selected_version;
          };
      } SupportedVersions;
```

---
##### **B.3.1.2.  Cookie Extension**

```text
      struct {
          opaque cookie<1..2^16-1>;
      } Cookie;
```

---
##### **B.3.1.3.  Signature Algorithm Extension**

```text
      enum {
          /* RSASSA-PKCS1-v1_5 algorithms */
          rsa_pkcs1_sha256(0x0401),
          rsa_pkcs1_sha384(0x0501),
          rsa_pkcs1_sha512(0x0601),

          /* ECDSA algorithms */
          ecdsa_secp256r1_sha256(0x0403),
          ecdsa_secp384r1_sha384(0x0503),
          ecdsa_secp521r1_sha512(0x0603),

          /* RSASSA-PSS algorithms with public key OID rsaEncryption */
          rsa_pss_rsae_sha256(0x0804),
          rsa_pss_rsae_sha384(0x0805),
          rsa_pss_rsae_sha512(0x0806),

          /* EdDSA algorithms */
          ed25519(0x0807),
          ed448(0x0808),

          /* RSASSA-PSS algorithms with public key OID RSASSA-PSS */
          rsa_pss_pss_sha256(0x0809),
          rsa_pss_pss_sha384(0x080a),
          rsa_pss_pss_sha512(0x080b),

          /* Legacy algorithms */
          rsa_pkcs1_sha1(0x0201),
          ecdsa_sha1(0x0203),

          /* Reserved Code Points */
          obsolete_RESERVED(0x0000..0x0200),
          dsa_sha1_RESERVED(0x0202),
          obsolete_RESERVED(0x0204..0x0400),
          dsa_sha256_RESERVED(0x0402),
          obsolete_RESERVED(0x0404..0x0500),
          dsa_sha384_RESERVED(0x0502),
          obsolete_RESERVED(0x0504..0x0600),
          dsa_sha512_RESERVED(0x0602),
          obsolete_RESERVED(0x0604..0x06FF),
          private_use(0xFE00..0xFFFF),
          (0xFFFF)
      } SignatureScheme;

      struct {
          SignatureScheme supported_signature_algorithms<2..2^16-2>;
      } SignatureSchemeList;
```

---
##### **B.3.1.4.  Supported Groups Extension**

```text
      enum {
          unallocated_RESERVED(0x0000),

          /* Elliptic Curve Groups (ECDHE) */
          obsolete_RESERVED(0x0001..0x0016),
          secp256r1(0x0017), secp384r1(0x0018), secp521r1(0x0019),
          obsolete_RESERVED(0x001A..0x001C),
          x25519(0x001D), x448(0x001E),

          /* Finite Field Groups (DHE) */
          ffdhe2048(0x0100), ffdhe3072(0x0101), ffdhe4096(0x0102),
          ffdhe6144(0x0103), ffdhe8192(0x0104),

          /* Reserved Code Points */
          ffdhe_private_use(0x01FC..0x01FF),
          ecdhe_private_use(0xFE00..0xFEFF),
          obsolete_RESERVED(0xFF01..0xFF02),
          (0xFFFF)
      } NamedGroup;

      struct {
          NamedGroup named_group_list<2..2^16-1>;
      } NamedGroupList;
```

"obsolete\_RESERVED" 범위 내의 값은 이전 버전의 TLS에서 사용되며 TLS 1.3 구현에서 제공되거나 협상되어서는 안 됩니다. 사용되지 않는 곡선에는 다양한 알려진/이론적 약점이 있거나 일부 경우에는 의도하지 않은 서버 구성 문제로 인해 거의 사용되지 않았습니다. 더 이상 일반적인 사용에 적합하지 않으며 잠재적으로 안전하지 않다고 가정해야 합니다. 여기에 지정된 곡선 세트는 현재 배포되고 적절하게 구성된 모든 TLS 구현과의 상호 운용성에 충분합니다.

---
#### **B.3.2.  Server Parameters Messages**

```text
      opaque DistinguishedName<1..2^16-1>;

      struct {
          DistinguishedName authorities<3..2^16-1>;
      } CertificateAuthoritiesExtension;

      struct {
          opaque certificate_extension_oid<1..2^8-1>;
          opaque certificate_extension_values<0..2^16-1>;
      } OIDFilter;

      struct {
          OIDFilter filters<0..2^16-1>;
      } OIDFilterExtension;

      struct {} PostHandshakeAuth;

      struct {
          Extension extensions<0..2^16-1>;
      } EncryptedExtensions;

      struct {
          opaque certificate_request_context<0..2^8-1>;
          Extension extensions<2..2^16-1>;
      } CertificateRequest;
```

---
#### **B.3.3.  Authentication Messages**

```text
      enum {
          X509(0),
          OpenPGP_RESERVED(1),
          RawPublicKey(2),
          (255)
      } CertificateType;

      struct {
          select (certificate_type) {
              case RawPublicKey:
                /* From RFC 7250 ASN.1_subjectPublicKeyInfo */
                opaque ASN1_subjectPublicKeyInfo<1..2^24-1>;

              case X509:
                opaque cert_data<1..2^24-1>;
          };
          Extension extensions<0..2^16-1>;
      } CertificateEntry;

      struct {
          opaque certificate_request_context<0..2^8-1>;
          CertificateEntry certificate_list<0..2^24-1>;
      } Certificate;

      struct {
          SignatureScheme algorithm;
          opaque signature<0..2^16-1>;
      } CertificateVerify;

      struct {
          opaque verify_data[Hash.length];
      } Finished;
```

---
#### **B.3.4.  Ticket Establishment**

```text
      struct {
          uint32 ticket_lifetime;
          uint32 ticket_age_add;
          opaque ticket_nonce<0..255>;
          opaque ticket<1..2^16-1>;
          Extension extensions<0..2^16-2>;
      } NewSessionTicket;
```

---
#### **B.3.5.  Updating Keys**

```text
      struct {} EndOfEarlyData;

      enum {
          update_not_requested(0), update_requested(1), (255)
      } KeyUpdateRequest;

      struct {
          KeyUpdateRequest request_update;
      } KeyUpdate;
```

---
### **B.4.  Cipher Suites**

대칭 암호화 제품군은 HKDF와 함께 사용할 AEAD 알고리즘과 해시 알고리즘의 쌍을 정의합니다. 암호화 제품군 이름은 명명 규칙을 따릅니다.

```text
      CipherSuite TLS_AEAD_HASH = VALUE;

      +-----------+------------------------------------------------+
      | Component | Contents                                       |
      +-----------+------------------------------------------------+
      | TLS       | The string "TLS"                               |
      |           |                                                |
      | AEAD      | The AEAD algorithm used for record protection  |
      |           |                                                |
      | HASH      | The hash algorithm used with HKDF              |
      |           |                                                |
      | VALUE     | The two-byte ID assigned for this cipher suite |
      +-----------+------------------------------------------------+
```

이 사양은 TLS 1.3과 함께 사용할 다음 암호화 제품군을 정의합니다.

```text
              +------------------------------+-------------+
              | Description                  | Value       |
              +------------------------------+-------------+
              | TLS_AES_128_GCM_SHA256       | {0x13,0x01} |
              |                              |             |
              | TLS_AES_256_GCM_SHA384       | {0x13,0x02} |
              |                              |             |
              | TLS_CHACHA20_POLY1305_SHA256 | {0x13,0x03} |
              |                              |             |
              | TLS_AES_128_CCM_SHA256       | {0x13,0x04} |
              |                              |             |
              | TLS_AES_128_CCM_8_SHA256     | {0x13,0x05} |
              +------------------------------+-------------+
```

해당 AEAD 알고리즘 AEAD\_AES\_128\_GCM, AEAD\_AES\_256\_GCM 및 AEAD\_AES\_128\_CCM은 \[RFC5116\]에 정의되어 있습니다. AEAD\_CHACHA20\_POLY1305는 \[RFC8439\]에 정의되어 있습니다. AEAD\_AES\_128\_CCM\_8은 \[RFC6655\]에 정의되어 있습니다. 해당 해시 알고리즘은 \[SHS\]에 정의되어 있습니다.

TLS 1.3은 이전 버전의 TLS와 동일한 암호 모음 공간을 사용하지만 TLS 1.3 암호 모음은 대칭 암호만 지정하여 다르게 정의되며 TLS 1.2에는 사용할 수 없습니다. 마찬가지로 TLS 1.2 이하의 암호화 제품군은 TLS 1.3과 함께 사용할 수 없습니다.

새로운 암호 그룹 값은 섹션 11에 설명된 대로 IANA에 의해 할당됩니다.

---
# **Appendix C.  Implementation Notes**

TLS 프로토콜은 흔히 발생하는 많은 보안 실수를 방지할 수 없습니다. 이 부록에서는 구현자를 지원하기 위한 몇 가지 권장 사항을 제공합니다. \[TLS13-TRACES\]는 TLS 1.3 핸드셰이크에 대한 테스트 벡터를 제공합니다.

---
### **C.1.  Random Number Generation and Seeding**

TLS에는 암호화된 보안 의사 난수 생성기\(CSPRNG\)가 필요합니다. 대부분의 경우 운영 체제는 다른\(예: 성능\) 문제 없이 사용해야 하는 /dev/urandom과 같은 적절한 기능을 제공합니다. 새로운 구현을 작성하는 것보다 기존 CSPRNG 구현을 사용하는 것이 좋습니다. 적절한 라이선스 조건에 따라 이미 많은 적절한 암호화 라이브러리를 사용할 수 있습니다. 이것이 만족스럽지 못한 것으로 판명되면 \[RFC4086\]은 무작위 값 생성에 대한 지침을 제공합니다.

TLS는 ClientHello 및 ServerHello의 공개 무작위 값과 같은 공개 프로토콜 필드에서 무작위 값\(1\)을 사용하고 \(2\) 키 자료를 생성합니다. 제대로 작동하는 CSPRNG를 사용하면 출력에서 ​​CSPRNG 상태를 확인할 수 없으므로 보안 문제가 발생하지 않습니다. 그러나 손상된 CSPRNG를 사용하면 공격자가 공개 출력을 사용하여 CSPRNG 내부 상태를 확인하고 이에 따라 \[CHECKOWAY\]에 문서화된 키 자료를 예측할 수 있습니다. 구현에서는 별도의 CSPRNG를 사용하여 공개 및 비공개 값을 생성함으로써 이러한 형태의 공격에 대해 추가 보안을 제공할 수 있습니다.

---
### **C.2.  Certificates and Authentication**

구현에서는 인증서의 무결성을 확인할 책임이 있으며 일반적으로 인증서 해지 메시지를 지원해야 합니다. 애플리케이션 프로필에 특정 표시가 없으면 인증서는 항상 신뢰할 수 있는 인증 기관\(CA\)의 적절한 서명을 확인해야 합니다. 트러스트 앵커의 선택과 추가는 매우 신중하게 이루어져야 합니다. 사용자는 인증서 및 트러스트 앵커에 대한 정보를 볼 수 있어야 합니다. 애플리케이션은 또한 최소 및 최대 키 크기를 적용해야 합니다\(SHOULD\). 예를 들어, 2048비트 RSA 또는 224비트 ECDSA보다 약한 키나 서명이 포함된 인증 경로는 보안 애플리케이션에 적합하지 않습니다.

---
### **C.3.  Implementation Pitfalls**

구현 경험에 따르면 이전 TLS 사양의 특정 부분은 이해하기 쉽지 않으며 상호 운용성 및 보안 문제의 원인이 되어 왔습니다. 이러한 영역 중 많은 부분이 이 문서에서 명확하게 설명되어 있지만 이 부록에는 구현자의 특별한 주의가 필요한 가장 중요한 사항에 대한 간단한 목록이 포함되어 있습니다.

```text
   TLS protocol issues:
```

- 여러 TLS 레코드로 조각화된 핸드셰이크 메시지를 올바르게 처리합니까\(섹션 5.1 참조\)? 여러 개의 작은 조각으로 분할된 ClientHello와 같은 특수 사례를 올바르게 처리합니까? 최대 조각 크기를 초과하는 핸드셰이크 메시지를 조각화합니까? 특히, Certificate 및 CertificateRequest 핸드셰이크 메시지는 조각화가 필요할 만큼 커질 수 있습니다.

- 암호화되지 않은 모든 TLS 레코드에서 TLS 레코드 레이어 버전 번호를 무시합니까\(부록 D 참조\)?

- SSL, RC4, EXPORT 암호 및 MD5\("signature\_algorithms" 확장을 통해\)에 대한 모든 지원이 TLS 1.3 이상을 지원하는 가능한 모든 구성에서 완전히 제거되었는지, 그리고 이러한 사용되지 않는 기능을 사용하려는 시도가 올바르게 실패하는지 확인했습니까?\( 부록 D 참조\)?

- 알 수 없는 확장을 포함하여 ClientHellos에서 TLS 확장을 올바르게 처리합니까?

- 서버가 클라이언트 인증서를 요청했지만 적합한 인증서를 사용할 수 없는 경우 전체 메시지를 생략하는 대신 빈 인증서 메시지를 올바르게 보내나요\(섹션 4.4.2 참조\)?

- AEAD-Decrypt에서 생성된 일반 텍스트 조각을 처리하고 ContentType의 끝부터 스캔할 때 피어가 모두 0으로 구성된 잘못된 일반 텍스트를 보낸 경우 일반 텍스트의 시작 부분을 지나 스캔하는 것을 방지합니까?

- 인식할 수 없는 암호 제품군\(섹션 4.1.2\), hello 확장\(섹션 4.2\), 명명된 그룹\(섹션 4.2.7\), 키 공유\(섹션 4.2.8\), 지원되는 버전\(섹션 4.2.1\) 및 ClientHello?의 서명 알고리즘\(섹션 4.2.3\)

- 서버로서 호환되는 \(EC\)DHE 그룹을 지원하지만 "key\_share" 확장에서 이를 예측하지 않는 클라이언트에 HelloRetryRequest를 보내나요? 클라이언트로서 서버의 HelloRetryRequest를 올바르게 처리합니까?

```text
   Cryptographic details:
```

- 타이밍 공격 \[TIMING\]을 방지하기 위해 어떤 대응책을 사용합니까?

- Diffie-Hellman 키 교환을 사용할 때 협상된 키의 선행 0바이트를 올바르게 유지합니까\(섹션 7.4.1 참조\)?

- TLS 클라이언트는 서버에서 보낸 Diffie-Hellman 매개변수가 허용되는지 확인합니까\(섹션 4.2.8.1 참조\)?

- Diffie-Hellman 개인 값, ECDSA "k" 매개변수 및 기타 보안에 중요한 값을 생성할 때 강력하고 가장 중요하게 적절하게 시드된 난수 생성기\(부록 C.1 참조\)를 사용합니까? \[RFC6979\]에 지정된 대로 구현 시 "결정론적 ECDSA"를 구현하는 것이 권장됩니다.

- 그룹 크기에 따라 Diffie-Hellman 공개 키 값과 공유 비밀을 제로 패드합니까\(섹션 4.2.8.1 및 섹션 7.4.1 참조\)?

- RSA-CRT 키 유출을 방지하기 위해 서명을 만든 후 확인합니까? \[FW15\]

---
### **C.4.  Client Tracking Prevention**

클라이언트는 다중 연결에 티켓을 재사용해서는 안 됩니다. 티켓을 재사용하면 수동적인 관찰자가 서로 다른 연결을 상호 연관시킬 수 있습니다. 티켓을 발행하는 서버는 적어도 클라이언트가 사용할 수 있는 연결 수만큼 많은 티켓을 제공해야 합니다. 예를 들어, HTTP/1.1 \[RFC7230\]을 사용하는 웹 브라우저는 서버에 대한 6개의 연결을 열 수 있습니다. 서버는 연결될 때마다 새로운 티켓을 발행해야 합니다. 이렇게 하면 클라이언트가 새 연결을 만들 때 항상 새 티켓을 사용할 수 있습니다.

---
### **C.5.  Unauthenticated Operation**

이전 버전의 TLS는 익명의 Diffie-Hellman을 기반으로 명시적으로 인증되지 않은 암호 제품군을 제공했습니다. 이러한 모드는 TLS 1.3에서 더 이상 사용되지 않습니다. 그러나 다음을 포함한 여러 방법을 통해 검증 가능한 서버 인증을 제공하지 않는 매개변수를 협상하는 것은 여전히 ​​가능합니다.

```text
   -  Raw public keys [RFC7250].
```

- 인증서에 포함되어 있지만 인증서 체인이나 그 내용에 대한 유효성 검사 없이 공개 키를 사용합니다.

단독으로 사용되는 기술은 중간자 공격에 취약하므로 일반적인 사용에는 안전하지 않습니다. 그러나 서버 공개 키의 대역 외 검증, 최초 사용 시 신뢰 또는 채널 바인딩\(\[RFC5929\]에 설명된 채널 바인딩과 같은 메커니즘\)을 통해 이러한 연결을 외부 인증 메커니즘에 바인딩하는 것도 가능합니다. TLS 1.3에는 정의되지 않았습니다\). 그러한 메커니즘이 사용되지 않으면 연결은 활성 중간자 공격으로부터 보호되지 않습니다. 애플리케이션은 명시적인 구성이나 특정 애플리케이션 프로필이 없는 방식으로 TLS를 사용해서는 안 됩니다.

---
# **Appendix D.  Backward Compatibility**

TLS 프로토콜은 잠재적으로 서로 다른 버전의 TLS를 지원할 수 있는 엔드포인트 간의 버전 협상을 위한 내장 메커니즘을 제공합니다.

TLS 1.x 및 SSL 3.0은 호환되는 ClientHello 메시지를 사용합니다. 또한 서버는 ClientHello 형식이 호환 가능하고 클라이언트와 서버 모두에서 지원되는 프로토콜 버전이 하나 이상 있는 한 TLS의 향후 버전을 사용하려는 클라이언트를 처리할 수도 있습니다.

이전 버전의 TLS는 다양한 목적으로 레코드 계층 버전 번호\(TLSPlaintext.legacy\_record\_version 및 TLSCiphertext.legacy\_record\_version\)를 사용했습니다. TLS 1.3부터 ​​이 필드는 더 이상 사용되지 않습니다. TLSPlaintext.legacy\_record\_version 값은 모든 구현에서 무시되어야 합니다. TLSCiphertext.legacy\_record\_version의 값은 보호 해제를 위한 추가 데이터에 포함되지만 그렇지 않으면 무시되거나 고정 상수 값과 일치하도록 검증될 수 있습니다. 버전 협상은 핸드셰이크 버전\(ClientHello.legacy\_version 및 ServerHello.legacy\_version과 ClientHello, HelloRetryRequest 및 ServerHello "supported\_versions" 확장\)만 사용하여 수행됩니다. 이전 엔드포인트와의 상호 운용성을 최대화하기 위해 TLS 1.0-1.2 사용을 협상하는 구현은 레코드 계층 버전 번호를 ServerHello 및 그 이후의 모든 레코드에 대해 협상된 버전으로 설정해야 합니다.

이전의 비표준 동작 및 잘못 구성된 배포와의 최대 호환성을 위해 모든 구현은 이전 TLS 버전의 핸드셰이크를 처리할 때에도 이 문서의 기대치를 기반으로 인증 경로의 유효성 검사를 지원해야 합니다\(섹션 4.4.2.2 참조\).

TLS 1.2 및 이전 버전은 핸드셰이크 기록의 상당 부분을 마스터 비밀로 소화하는 "확장 마스터 비밀" \[RFC7627\] 확장을 지원했습니다. TLS 1.3은 항상 서버 완료까지 기록에서 해시하기 때문에 TLS 1.3과 이전 버전을 모두 지원하는 구현은 TLS 1.3이 사용될 때마다 API에서 확장 마스터 비밀 확장의 사용을 표시해야 합니다.

---
### **D.1.  Negotiating with an Older Server**

TLS 1.3을 지원하지 않는 서버와 협상하려는 TLS 1.3 클라이언트는 ClientHello.legacy\_version에 0x0303\(TLS 1.2\)이 포함되어 있지만 "supported\_versions" 확장에 올바른 버전이 포함된 일반 TLS 1.3 ClientHello를 보냅니다. 서버가 TLS 1.3을 지원하지 않으면 이전 버전 번호가 포함된 ServerHello로 응답합니다. 클라이언트가 이 버전을 사용하는 데 동의하면 협상된 프로토콜에 맞게 협상이 진행됩니다. 재개를 위한 티켓을 사용하는 클라이언트는 이전에 협상된 버전을 사용하여 연결을 시작해야 합니다.

0-RTT 데이터는 이전 서버와 호환되지 않으며 서버가 TLS 1.3을 지원한다는 사실을 알지 못한 채 전송되어서는 안 됩니다. 부록 D.3을 참조하세요.

서버가 선택한 버전이 클라이언트에서 지원되지 않는 경우\(또는 허용되지 않는 경우\) 클라이언트는 "protocol\_version" 경고와 함께 핸드셰이크를 중단해야 합니다.

일부 레거시 서버 구현은 TLS 사양을 제대로 구현하지 않는 것으로 알려져 있으며, 인식하지 못하는 TLS 확장이나 버전이 나타나면 연결을 중단할 수 있습니다. 버그가 있는 서버와의 상호 운용성은 이 문서의 범위를 벗어나는 복잡한 주제입니다. 이전 버전과 호환되는 연결을 협상하려면 여러 번의 연결 시도가 필요할 수 있습니다. 그러나 이 방법은 다운그레이드 공격에 취약하므로 권장되지 않습니다.

---
### **D.2.  Negotiating with an Older Client**

TLS 서버는 지원되는 가장 높은 버전보다 작은 버전 번호를 나타내는 ClientHello를 수신할 수도 있습니다. "supported\_versions" 확장이 있는 경우 서버는 섹션 4.2.1에 설명된 대로 해당 확장을 사용하여 협상해야 합니다. "supported\_versions" 확장이 없으면 서버는 최소 ClientHello.legacy\_version 및 TLS 1.2를 협상해야 합니다. 예를 들어 서버가 TLS 1.0, 1.1, 1.2를 지원하고 Legacy\_version이 TLS 1.0인 경우 서버는 TLS 1.0 ServerHello를 진행합니다. "supported\_versions" 확장이 없고 서버가 ClientHello.legacy\_version보다 높은 버전만 지원하는 경우 서버는 "protocol\_version" 경고와 함께 핸드셰이크를 중단해야 합니다.

이전 버전의 TLS에서는 모든 경우에 레코드 계층 버전 번호 값\(TLSPlaintext.legacy\_record\_version\)을 명확하게 지정하지 않았습니다. 서버는 이 필드에서 다양한 TLS 1.x 버전을 수신하지만 해당 값은 항상 무시되어야 합니다.

---
### **D.3.  0-RTT Backward Compatibility**

0-RTT 데이터는 이전 서버와 호환되지 않습니다. 이전 서버는 이전 ServerHello로 ClientHello에 응답하지만 0-RTT 데이터를 올바르게 건너뛰지 못하고 핸드셰이크를 완료하지 못합니다. 이로 인해 클라이언트가 특히 다중 서버 배포에 대해 0-RTT를 사용하려고 시도할 때 문제가 발생할 수 있습니다. 예를 들어 일부 서버는 TLS 1.3을 구현하고 일부는 TLS 1.2를 구현하여 TLS 1.3을 점진적으로 배포하거나 TLS 1.3 배포를 TLS 1.2로 다운그레이드할 수 있습니다.

0-RTT 데이터 전송을 시도하는 클라이언트는 TLS 1.2 이하 버전의 ServerHello를 수신하는 경우 연결에 실패해야 합니다. 그런 다음 0-RTT가 비활성화된 상태에서 연결을 다시 시도할 수 있습니다. 다운그레이드 공격을 방지하려면 클라이언트는 TLS 1.3을 비활성화해서는 안 되며 0-RTT만 비활성화해야 합니다.

이러한 오류 조건을 방지하려면 다중 서버 배포에서는 0-RTT를 활성화하기 전에 0-RTT 없이 TLS 1.3의 균일하고 안정적인 배포를 보장해야 합니다.

---
### **D.4.  Middlebox Compatibility Mode**

현장 측정 \[Ben17a\] \[Ben17b\] \[Res17a\] \[Res17b\]는 TLS 클라이언트/서버 쌍이 TLS 1.3을 협상할 때 상당수의 미들박스가 오작동하는 것을 발견했습니다. 구현에서는 TLS 1.3 핸드셰이크를 TLS 1.2 핸드셰이크처럼 보이게 만들어 해당 미들박스를 통해 연결할 가능성을 높일 수 있습니다.

- 클라이언트는 섹션 4.1.2의 Legacy\_session\_id 섹션에 설명된 대로 항상 ClientHello에 비어 있지 않은 세션 ID를 제공합니다.

- 초기 데이터를 제공하지 않는 경우 클라이언트는 두 번째 비행 직전에 더미change\_cipher\_spec 기록\(섹션 5의 세 번째 단락 참조\)을 보냅니다. 이는 두 번째 ClientHello 이전이거나 암호화된 핸드셰이크 비행 이전일 수 있습니다. 초기 데이터를 제공하는 경우 첫 번째 ClientHello 바로 뒤에 레코드가 배치됩니다.

- 서버는 첫 번째 핸드셰이크 메시지 직후 더미change\_cipher\_spec 레코드를 보냅니다. 이는 ServerHello 또는 HelloRetryRequest 이후일 수 있습니다.

이러한 변경 사항을 종합하면 TLS 1.3 핸드셰이크가 TLS 1.2 세션 재개와 유사해 미들박스를 통해 성공적으로 연결할 가능성이 높아집니다. 이 "호환성 모드"는 부분적으로 협상됩니다. 클라이언트는 세션 ID 제공 여부를 선택할 수 있으며 서버는 이를 반영해야 합니다. 어느 쪽이든 보낼 수 있습니다

Change\_cipher\_spec은 핸드셰이크 중 언제든지 피어에 의해 무시되어야 하기 때문에 클라이언트가 비어 있지 않은 세션 ID를 보내는 경우 서버는 이 부록에 설명된 대로 Change\_cipher\_spec을 보내야 합니다.

---
### **D.5.  Security Restrictions Related to Backward Compatibility**

이전 버전의 TLS 사용을 협상하는 구현은 가능한 경우 순방향 비밀 및 AEAD 암호화 제품군을 선호해야 합니다\(SHOULD\).

RC4 암호 그룹의 보안은 \[RFC7465\]에 인용된 이유로 충분하지 않은 것으로 간주됩니다. 구현은 어떤 이유로든 TLS의 모든 버전에 대해 RC4 암호화 제품군을 제공하거나 협상해서는 안 됩니다.

이전 버전의 TLS에서는 강도가 매우 낮은 암호 사용을 허용했습니다. 112비트 미만의 강도를 가진 암호는 어떤 이유로든 TLS의 모든 버전에 대해 제공되거나 협상되어서는 안 됩니다.

SSL 3.0 \[RFC6101\]의 보안은 \[RFC7568\]에 열거된 이유로 불충분한 것으로 간주되며 어떤 이유로든 협상해서는 안 됩니다.

SSL 2.0 \[SSL2\]의 보안은 \[RFC6176\]에 열거된 이유로 불충분한 것으로 간주되며 어떤 이유로든 협상되어서는 안 됩니다.

구현 시 SSL 버전 2.0 호환 CLIENT-HELLO를 보내면 안 됩니다. 구현은 SSL 버전 2.0 호환 CLIENT-HELLO를 사용하여 TLS 1.3 이상을 협상해서는 안 됩니다. 이전 버전의 TLS를 협상하기 위해 SSL 버전 2.0 호환 CLIENT-HELLO를 허용하는 구현은 권장되지 않습니다.

구현 시 0x0300 이하로 설정된 ClientHello.legacy\_version 또는 ServerHello.legacy\_version을 보내면 안 됩니다. ClientHello.legacy\_version 또는 ServerHello.legacy\_version이 0x0300으로 설정된 Hello 메시지를 수신하는 모든 엔드포인트는 "protocol\_version" 경고와 함께 핸드셰이크를 중단해야 합니다.

구현 시 버전이 0x0300보다 작은 레코드를 보내면 안 됩니다. 구현은 0x0300보다 낮은 버전의 레코드를 허용해서는 안 됩니다\(그러나 레코드 버전 번호가 완전히 무시되는 경우 실수로 허용할 수 있음\).

구현 시 \[RFC6066\]의 섹션 7에 정의된 Truncated HMAC 확장을 사용하면 안 됩니다. 이는 AEAD 알고리즘에 적용할 수 없고 일부 시나리오에서 안전하지 않은 것으로 나타났기 때문입니다.

---
# **Appendix E.  Overview of Security Properties**

TLS에 대한 완전한 보안 분석은 이 문서의 범위를 벗어납니다. 이 부록에서는 원하는 속성에 대한 비공식적 설명과 보다 공식적인 정의를 제공하는 연구 문헌의 보다 자세한 작업에 대한 참조를 제공합니다.

우리는 레코드 레이어의 속성과 별도로 핸드셰이크의 속성을 다룹니다.

---
### **E.1.  Handshake**

TLS 핸드셰이크는 단방향 인증\(서버 전용\) 기능과 상호 인증\(클라이언트 및 서버\) 기능을 모두 제공하기 위한 AKE\(Authenticated Key Exchange\) 프로토콜입니다. 핸드셰이크가 완료되면 각 측은 다음 값에 대한 보기를 출력합니다.

- 작업 키 세트를 파생할 수 있는 "세션 키" 세트\(마스터 비밀에서 파생된 다양한 비밀\).

- 암호화 매개변수 세트\(알고리즘 등\).

- 통신 당사자의 신원.

우리는 공격자가 활동적인 네트워크 공격자라고 가정합니다. 이는 공격자가 당사자 간 통신에 사용되는 네트워크를 완전히 제어할 수 있음을 의미합니다\[RFC3552\]. 이러한 조건에서도 핸드셰이크는 아래 나열된 속성을 제공해야 합니다. 이러한 속성은 반드시 독립적일 필요는 없지만 프로토콜 소비자의 요구 사항을 반영합니다.

동일한 세션 키 설정: 핸드셰이크는 각 끝점에서 성공적으로 완료되는 경우 핸드셰이크의 양쪽에서 동일한 세션 키 세트를 출력해야 합니다\(\[CK01\], 정의 1, 파트 1 참조\).

세션 키의 비밀성: 공유 세션 키는 공격자가 아닌 통신 당사자에게만 알려야 합니다\(\[CK01\], 정의 1, 파트 2 참조\). 일방적으로 인증된 연결에서 공격자는 서버와 자신의 세션 키를 설정할 수 있지만 해당 세션 키는 클라이언트가 설정한 것과 다릅니다.

피어 인증: 클라이언트의 피어 ID 보기는 서버의 ID를 반영해야 합니다. 클라이언트가 인증된 경우 서버의 피어 ID 보기는 클라이언트의 ID와 일치해야 합니다.

세션 키의 고유성: 두 개의 서로 다른 핸드셰이크는 서로 관련되지 않은 별개의 세션 키를 생성해야 합니다. 핸드셰이크에 의해 생성된 개별 세션 키도 고유하고 독립적이어야 합니다.

다운그레이드 보호: 암호화 매개변수는 양쪽에서 동일해야 하며 공격이 없을 때 피어가 통신했던 것과 동일해야 합니다\(\[BBFGKZ16\], 정의 8 및 9 참조\).

장기 키에 관한 전달 비밀: 장기 키 자료\(이 경우 인증서 기반 인증 모드의 서명 키 또는 \(EC\)DHE 모드를 사용하는 PSK의 외부/재개 PSK\)가 핸드셰이크 후에 손상된 경우 완료되면 세션 키 자체가 지워지는 한 세션 키의 보안이 손상되지 않습니다\(\[DOW92\] 참조\). "psk\_ke" PskKeyExchangeMode에서 PSK를 사용하는 경우 순방향 비밀성 속성이 충족되지 않습니다.

KCI\(Key Compromise Impersonation\) 저항: 인증서를 사용한 상호 인증 연결에서 한 행위자의 장기 비밀이 손상되더라도 해당 연결에서 피어에 대한 해당 행위자의 인증이 중단되어서는 안 됩니다\(\[HGFS15\] 참조\). 예를 들어 클라이언트의 서명 키가 손상된 경우 후속 핸드셰이크에서 임의의 서버를 해당 클라이언트로 가장하는 것이 불가능해야 합니다.

엔드포인트 ID 보호: 서버의 ID\(인증서\)는 수동적 공격자로부터 보호되어야 합니다. 클라이언트의 신원은 수동적 공격자와 능동적 공격자 모두로부터 보호되어야 합니다.

비공식적으로, TLS 1.3의 서명 기반 모드는 \(EC\)DHE 키 교환에 의해 설정되고 핸드셰이크 기록을 통해 서버 서명으로 인증되며 서버의 ID에 연결된 고유한 비밀 공유 키의 설정을 제공합니다. MAC으로. 클라이언트가 인증서로 인증되면 핸드셰이크 기록에 서명하고 두 ID에 연결된 MAC도 제공합니다. \[SIGMA\]는 이러한 유형의 키 교환 프로토콜의 설계 및 분석을 설명합니다. 각 연결에 새로운 \(EC\)DHE 키가 사용되는 경우 출력 키는 전달 비밀입니다.

외부 PSK 및 재개 PSK 부트스트랩은 장기 공유 비밀에서 고유한 연결별 단기 세션 키 세트로 전환됩니다. 이 비밀은 이전 핸드셰이크에서 설정되었을 수 있습니다. \(EC\)DHE 키 설정이 포함된 PSK를 사용하는 경우 이러한 세션 키도 전달 비밀이 됩니다. 재개 PSK는 연결 N에 의해 ​​계산되고 연결 N+1을 형성하는 데 필요한 재개 마스터 비밀이 연결 N+1에서 사용되는 트래픽 키와 분리되도록 설계되었습니다.

연결 N을 사용하여 연결 간에 순방향 비밀성을 제공합니다. 또한 동일한 연결에 여러 티켓이 설정된 경우 서로 다른 키와 연결되므로 하나의 티켓과 연결된 PSK가 손상되더라도 다른 티켓과 연결된 PSK로 설정된 연결이 손상되지 않습니다. 이 속성은 티켓이 자체 암호화된 경우보다 데이터베이스에 저장되어 삭제될 수 있는 경우에 가장 흥미롭습니다.

PSK 바인더 값은 PSK와 현재 핸드셰이크 간뿐만 아니라 PSK가 설정된 세션과 현재 세션 간 바인딩을 형성합니다. 이 바인딩에는 원본 핸드셰이크 기록이 전이적으로 포함됩니다. 그 이유는 해당 기록이 재개 마스터 암호를 생성하는 값으로 소화되기 때문입니다. 이를 위해서는 재개 마스터 암호를 생성하는 데 사용되는 KDF와 바인더를 계산하는 데 사용되는 MAC가 모두 충돌 방지 기능을 갖추어야 합니다. 이에 대한 자세한 내용은 부록 E.1.1을 참조하세요. 참고: 다른 PSK의 바인더 값은 Finished MAC에 포함되어 있지만 바인더는 이를 포함하지 않습니다.

TLS는 현재 서버가 인증서 기반이 아닌 핸드셰이크\(예: PSK\)로 인증서 요청 메시지를 보내는 것을 허용하지 않습니다. 나중에 이 제한이 완화된다면 클라이언트의 서명이 서버의 인증서를 직접적으로 포함하지 않게 됩니다. 그러나 PSK가 NewSessionTicket을 통해 설정된 경우 클라이언트의 서명은 PSK 바인더를 통해 서버의 인증서를 전이적으로 포함합니다. \[PSK-FINISHED\]는 서버의 인증서에 바인딩되지 않은 구성에 대한 구체적인 공격을 설명합니다\(\[Kraw16\] 참조\). 클라이언트가 잠재적으로 두 개의 다른 끝점과 동일한 PSK/키 ID 쌍을 공유할 수 있는 경우 인증서 기반 클라이언트 인증을 사용하는 것은 안전하지 않습니다. 구현 시 일부 확장 프로그램에 의해 협상되지 않는 한 외부 PSK를 클라이언트 또는 서버의 인증서 기반 인증과 결합해서는 안 됩니다.

내보내기를 사용하면 고유하고 비밀스러운 값이 생성됩니다\(고유한 세션 키에서 생성되기 때문입니다\). 서로 다른 레이블과 컨텍스트로 계산된 내보내기는 계산적으로 독립적이므로 내보낸 값에서 세션 암호를 계산하거나 다른 레이블에서 계산하는 것은 불가능합니다. 참고: 내보내기에서는 임의 길이의 값을 생성할 수 있습니다. 내보내기를 채널 바인딩으로 사용하려면 내보낸 값이 충돌 저항을 제공할 만큼 충분히 커야 합니다. TLS 1.3에서 제공되는 내보내기는 각각 초기 트래픽 키 및 애플리케이션 트래픽 키와 동일한 Handshake Context에서 파생되므로 유사한 보안 속성을 갖습니다. 여기에는 클라이언트의 인증서가 포함되어 있지 않습니다. 클라이언트의 인증서에 바인딩하려는 향후 애플리케이션은 전체 핸드셰이크 기록을 포함하는 새로운 내보내기를 정의해야 할 수도 있습니다.

모든 핸드셰이크 모드에서 Finished MAC\(및 서명이 있는 경우\)는 다운그레이드 공격을 방지합니다. 또한 섹션 4.1.3에 설명된 대로 임의 nonce의 특정 바이트를 사용하면 이전 TLS 버전으로의 다운그레이드를 감지할 수 있습니다. TLS 1.3 및 다운그레이드에 대한 자세한 내용은 \[BBFGKZ16\]을 참조하세요.

클라이언트와 서버가 공유 키를 설정하기에 충분한 정보를 교환하자마자 나머지 핸드셰이크가 암호화되어 계산된 공유 키가 인증되지 않은 경우에도 수동적 공격자로부터 보호할 수 있습니다. 서버가 클라이언트보다 먼저 인증하기 때문에 클라이언트는 서버에 인증하는 경우 인증된 서버에만 해당 ID를 공개하도록 할 수 있습니다. 구현 시에는 길이로 인해 ID에 대한 정보가 유출되는 것을 방지하기 위해 핸드셰이크 중에 제공된 레코드 패딩 메커니즘을 사용해야 합니다. 클라이언트가 제안한 PSK ID는 암호화되지 않으며 서버가 선택하는 ID도 아닙니다.

---
#### **E.1.1.  Key Derivation and HKDF**

TLS 1.3의 키 파생은 \[RFC5869\]에 정의된 HKDF와 두 구성 요소인 HKDF-Extract 및 HKDF-Expand를 사용합니다. HKDF 구성에 대한 전체 근거는 \[Kraw10\]에서 찾을 수 있으며, 이것이 \[KW16\]의 TLS 1.3에서 사용되는 방식에 대한 근거를 찾을 수 있습니다. 이 문서 전체에서 HKDF-Extract를 적용할 때마다 HKDF-Expand가 하나 이상 호출됩니다. 이 순서는 항상 따라야 합니다\(이 문서의 향후 개정판 포함\). 특히, 중간에 HKDF-Expand 없이 HKDF-Extract의 출력을 다른 HKDF-Extract 애플리케이션의 입력으로 사용하면 안 됩니다. 키 및/또는 라벨을 통해 구별되는 한 동일한 입력 중 일부에 HKDF-Expand를 여러 번 적용하는 것이 허용됩니다.

HKDF-Expand는 가변 길이의 입력과 출력 모두를 사용하여 의사 난수 함수\(PRF\)를 구현합니다. 이 문서에서 HKDF를 사용하는 일부 경우\(예: 내보내기 및 resumption\_master\_secret 생성\) HKDF-Expand 애플리케이션은 충돌 방지 기능을 갖추어야 합니다. 즉, 동일한 값을 출력하는 HKDF-Expand에 대한 두 개의 서로 다른 입력을 찾는 것이 불가능해야 합니다. 이를 위해서는 기본 해시 함수가 충돌 방지 기능을 갖추고 HKDF-Expand의 출력 길이가 최소 256비트\(또는 충돌 발견을 방지하기 위해 해시 함수에 필요한 만큼\)의 크기여야 합니다.

---
#### **E.1.2.  Client Authentication**

핸드셰이크 도중이나 핸드셰이크 후 인증에서 서버에 인증 데이터를 보낸 클라이언트는 나중에 서버가 클라이언트를 인증된 것으로 간주하는지 여부를 확신할 수 없습니다. 클라이언트가 서버가 연결을 일방적으로 인증할지 상호 인증으로 간주할지 결정해야 하는 경우 이는 애플리케이션 계층에서 제공되어야 합니다. 자세한 내용은 \[CHHSV17\]을 참조하세요. 또한, \[Kraw16\]의 사후 핸드셰이크 인증 분석에서는 사후 핸드셰이크 단계에서 전송된 인증서로 식별된 클라이언트가 트래픽 키를 소유하고 있음을 보여줍니다. 따라서 이 당사자는 원래 핸드셰이크에 참여한 클라이언트이거나 원래 클라이언트가 트래픽 키를 위임한 클라이언트입니다\(트래픽 키가 손상되지 않았다고 가정\).

---
#### **E.1.3.  0-RTT**

0-RTT 작동 모드는 일반적으로 0-RTT 암호화 키가 완전한 순방향 비밀성을 제공하지 않으며 서버가 핸드셰이크의 고유성을 보장할 수 없다는 두 가지 예외를 제외하고는 1-RTT 데이터와 유사한 보안 속성을 제공합니다. \(재생 불가능\) 잠재적으로 과도한 양의 상태를 유지하지 않고. 재생 노출을 제한하는 메커니즘은 섹션 8을 참조하세요.

---
#### **E.1.4.  Exporter Independence**

importer\_master\_secret 및 early\_exporter\_master\_secret은 트래픽 키와 독립적으로 파생되므로 해당 키로 암호화된 트래픽 보안에 대한 위협을 나타내지 않습니다. 그러나 이러한 비밀은 수출업체 값을 계산하는 데 사용될 수 있으므로 가능한 한 빨리 삭제해야 합니다. 내보내기 레이블의 전체 집합이 알려진 경우 구현에서는 모든 레이블에 대한 내보내기 계산의 내부 Derive-Secret 단계를 미리 계산한 다음 \[early\_\]exporter\_master\_secret를 삭제하고 각 내부 값이 알려지는 즉시 삭제해야 합니다. 다시는 필요하지 않을 것이라는 것입니다.

---
#### **E.1.5.  Post-Compromise Security**

TLS는 피어의 장기 비밀\(서명 키 또는 외부 PSK\)이 손상된 후 발생하는 핸드셰이크에 대한 보안을 제공하지 않습니다. 따라서 때로는 역방향 또는 미래 비밀성이라고도 하는 손상 후 보안\[CCG16\]을 제공하지 않습니다. 이는 당사자의 장기적인 비밀이 훼손된 후 당사자가 갖는 보안 보장을 설명하는 KCI 저항과 대조됩니다.

---
#### **E.1.6.  External References**

독자는 TLS 핸드셰이크 분석을 위해 다음 참고 자료를 참조해야 합니다: \[DFGS15\], \[CHSV16\], \[DFGS16\], \[KW16\], \[Kraw16\], \[FGSW16\], \[LXZFH16\], \[FG17\] 및 \[BBK17 \].

---
### **E.2.  Record Layer**

레코드 계층은 양방향 암호화 키와 nonce를 파생하는 데 사용할 수 있는 강력한 트래픽 비밀을 생성하는 핸드셰이크에 의존합니다. 이것이 사실이고 키가 섹션 5.5에 표시된 것보다 더 많은 데이터에 사용되지 않는다고 가정하면 레코드 계층은 다음 보장을 제공해야 합니다.

기밀성: 공격자는 주어진 기록의 일반 텍스트 내용을 확인할 수 없어야 합니다.

무결성: 공격자는 수신자가 수락할 기존 레코드와 다른 새로운 레코드를 만들 수 없어야 합니다.

주문 보호/재생 불가능성: 공격자는 수신자가 이미 수락한 레코드를 수락하도록 하거나 레코드 N을 먼저 처리하지 않은 채 수신자가 레코드 N+1을 수락하도록 할 수 없습니다.

길이 은폐: 주어진 외부 길이를 가진 레코드가 주어지면 공격자는 내용과 패딩이 있는 레코드의 양을 결정할 수 없어야 합니다.

키 변경 후 순방향 보안: 섹션 4.6.3에 설명된 트래픽 키 업데이트 메커니즘이 사용되었고 이전 세대 키가 삭제된 경우 엔드포인트를 손상시키는 공격자는 이전 키로 암호화된 트래픽을 해독할 수 없어야 합니다.

비공식적으로 TLS 1.3은 강력한 키로 일반 텍스트를 AEAD로 보호하여 이러한 속성을 제공합니다. AEAD 암호화 \[RFC5116\]는 데이터에 대한 기밀성과 무결성을 제공합니다. 재생 불가능성은 각 레코드에 대해 별도의 nonce를 사용하여 제공됩니다. nonce는 레코드 시퀀스 번호\(섹션 5.3\)에서 파생되고 시퀀스 번호는 양쪽에서 독립적으로 유지됩니다. 따라서 순서에 맞지 않게 전달된 레코드는 AEAD 보호 해제 실패를 초래합니다. 동일한 일반 텍스트가 동일한 키로 다른 사용자에 의해 반복적으로 암호화되는 경우\(일반적으로 HTTP의 경우\) 대량 암호 분석을 방지하기 위해 nonce는 다음을 혼합하여 형성됩니다.

트래픽 키와 함께 파생된 연결별 비밀 초기화 벡터가 포함된 시퀀스 번호입니다. 이 구성에 대한 분석은 \[BT16\]을 참조하세요.

TLS 1.3의 키 재생성 기술\(7.2절 참조\)은 \[REKEY\]에서 설명한 직렬 생성기의 구성을 따릅니다. 이는 키 재생을 통해 키 재생이 없을 때보다 더 많은 수의 암호화에 키를 사용할 수 있음을 보여줍니다. 이는 의사 난수 함수\(PRF\)로서 HKDF-Expand-Label 함수의 보안에 의존합니다. 또한 이 기능이 실제로 단방향인 한 키 변경 이전의 트래픽 키를 계산하는 것은 불가능합니다\(순방향 비밀성\).

TLS는 해당 연결의 트래픽 비밀이 손상된 후 연결을 통해 전달되는 데이터에 대한 보안을 제공하지 않습니다. 즉, TLS는 트래픽 비밀과 관련하여 손상 후 보안/미래 보안/역방향 보안을 제공하지 않습니다. 실제로 트래픽 비밀을 알아낸 공격자는 해당 연결에서 향후 모든 트래픽 비밀을 계산할 수 있습니다. 이러한 보장을 원하는 시스템은 새로운 핸드셰이크를 수행하고 \(EC\)DHE 교환과 새로운 연결을 설정해야 합니다.

---
#### **E.2.1.  External References**

독자는 TLS 레코드 계층 분석을 위해 \[BMMRT15\], \[BT16\], \[BDFKPPRSZZ16\], \[BBK17\] 및 \[PS18\] 참조 자료를 참조해야 합니다.

---
### **E.3.  Traffic Analysis**

TLS는 암호화된 패킷의 길이와 타이밍을 관찰하여 다양한 트래픽 분석 공격에 취약합니다\[CLINIC\]\[HCJC16\]. 이는 고정된 콘텐츠 모음을 호스팅하는 비디오 서버와 같이 구별할 수 있는 작은 메시지 집합이 있을 때 특히 쉽지만 더 복잡한 시나리오에서도 여전히 유용한 정보를 제공합니다.

TLS는 이러한 형태의 공격에 대해 특정 방어 기능을 제공하지 않지만 애플리케이션에서 사용할 패딩 메커니즘을 포함합니다. AEAD 기능으로 보호되는 일반 텍스트는 콘텐츠와 가변 길이 패딩으로 구성되어 애플리케이션이 임의 길이의 암호화된 레코드를 생성할 수 있습니다. 전송 기간과 침묵 기간의 차이를 숨기기 위한 패딩 전용 커버 트래픽도 포함됩니다. 패딩은 실제 콘텐츠와 함께 암호화되기 때문에 공격자가 패딩의 길이를 직접 확인할 수는 없지만 레코드 처리 중에 노출된 타이밍 채널을 사용하여 간접적으로 측정할 수 있습니다\(예: 레코드를 처리하는 데 걸리는 시간 확인\). 아니면 기록을 조금씩 살펴보거나

서버로부터 응답을 이끌어내는 것\). 일반적으로 이러한 채널을 모두 제거하는 방법은 알려져 있지 않습니다. 왜냐하면 상수 시간 패딩 제거 함수라도 콘텐츠를 데이터 종속 함수에 공급할 가능성이 높기 때문입니다. 최소한 완전한 상수 시간 서버 또는 클라이언트는 더 높은 수준의 프로토콜 상수 시간을 만드는 것을 포함하여 애플리케이션 계층 프로토콜 구현과의 긴밀한 협력이 필요합니다.

참고: 강력한 트래픽 분석 방어는 패킷 전송 지연 및 트래픽 볼륨 증가로 인해 성능 저하로 이어질 수 있습니다.

---
### **E.4.  Side-Channel Attacks**

일반적으로 TLS에는 부채널 공격\(예: 타이밍과 같은 보조 채널을 통해 통신을 공격하는 공격\)에 대한 특정 방어 기능이 없으므로 관련 암호화 기본 요소의 구현에 맡깁니다. 그러나 TLS의 특정 기능은 부채널 방지 코드를 더 쉽게 작성할 수 있도록 설계되었습니다.

- 복합 MAC 후 암호화 구조를 사용한 이전 버전의 TLS와 달리 TLS 1.3은 AEAD 알고리즘만 사용하므로 구현에서는 해당 기본 요소의 자체 포함 상수 시간 구현을 사용할 수 있습니다.

- TLS는 모든 암호 해독 오류에 대해 균일한 "bad\_record\_mac" 경고를 사용합니다. 이는 공격자가 메시지 부분에 대한 부분적인 통찰력을 얻는 것을 방지하기 위한 것입니다. 이러한 오류에 대한 연결을 종료하면 추가 저항이 제공됩니다. 새로운 연결에는 다양한 암호화 자료가 포함되어 여러 번의 시도가 필요한 암호화 기본 요소에 대한 공격을 방지합니다.

사이드 채널을 통한 정보 유출은 TLS 위 계층, 애플리케이션 프로토콜 및 이를 사용하는 애플리케이션에서 발생할 수 있습니다. 부채널 공격에 대한 저항은 기밀 정보가 실수로 유출되지 않도록 보장하는 애플리케이션 및 애플리케이션 프로토콜에 따라 달라집니다.

---
### **E.5.  Replay Attacks on 0-RTT**

재생 가능한 0-RTT 데이터는 해당 애플리케이션이 재생 시 안전하도록 특별히 설계되지 않은 한 TLS를 사용하는 애플리케이션에 여러 가지 보안 위협을 제공합니다\(최소한 이는 멱등성을 의미하지만 많은 경우 상수-RTT와 같은 다른 더 강력한 조건이 필요할 수도 있음\) 시간 응답\). 잠재적인 공격은 다음과 같습니다:

- 아이템 구매, 송금 등 부작용을 일으키는 행위를 중복하여 사이트 또는 이용자에게 피해를 주는 행위

- 공격자는 다른 메시지와 관련하여 순서를 변경하기 위해 0-RTT 메시지를 저장하고 재생할 수 있습니다\(예: 삭제를 생성 후로 이동\).

- 캐시 타이밍 동작을 활용하여 0-RTT 메시지를 다른 캐시 노드에 재생한 다음 별도의 연결을 사용하여 요청 대기 시간을 측정하고 두 요청이 동일한 리소스를 처리하는지 확인함으로써 0-RTT 메시지의 내용을 검색합니다.

데이터를 여러 번 재생할 수 있으면 암호화 작업 속도를 반복적으로 측정하는 등 추가 공격이 가능해집니다. 또한 속도 제한 시스템에 과부하가 걸릴 수도 있습니다. 이러한 공격에 대한 자세한 설명은 \[Mac17\]을 참조하세요.

궁극적으로 서버는 0-RTT 데이터 복제를 사용하는 공격으로부터 자신을 보호할 책임이 있습니다. 섹션 8에 설명된 메커니즘은 TLS 계층에서 재생을 방지하기 위한 것이지만 클라이언트 데이터의 여러 복사본 수신에 대한 완전한 보호를 제공하지는 않습니다. TLS 1.3은 서버에 클라이언트에 대한 정보가 없는 경우\(예: 상태를 공유하지 않는 다른 클러스터에 있거나 섹션 8.1에 설명된 대로 티켓이 삭제된 경우\) 1-RTT 핸드셰이크로 대체됩니다. 애플리케이션 계층 프로토콜이 이 설정에서 데이터를 재전송하는 경우 공격자가 원래 클러스터\(데이터를 즉시 처리함\)와 1-RTT로 폴백할 다른 클러스터 모두에 ClientHello를 전송하여 메시지 복제를 유도할 수 있습니다. 애플리케이션 계층 재생 시 데이터를 처리합니다. 이 공격의 규모는 트랜잭션을 재시도하려는 클라이언트의 의지에 따라 제한되므로 제한된 양의 복제만 허용되며 각 복사본은 서버에서 새로운 연결로 나타납니다.

올바르게 구현된 경우 섹션 8.1 및 8.2에 설명된 메커니즘은 재생된 ClientHello 및 관련 0-RTT 데이터가 일관된 상태의 클러스터에서 여러 번 수락되는 것을 방지합니다. 단일 티켓에 대해 0-RTT 사용을 하나의 클러스터로 제한하는 서버의 경우 지정된 ClientHello 및 관련 0-RTT 데이터는 한 번만 허용됩니다. 그러나 상태가 완전히 일관되지 않은 경우 공격자는 복제 기간 동안 여러 개의 데이터 복사본을 허용할 수 있습니다. 클라이언트는 서버 동작의 정확한 세부 사항을 모르기 때문에 재생하기에 안전하지 않고 여러 1-RTT 연결을 통해 재시도할 의사가 없는 초기 데이터의 메시지를 보내서는 안 됩니다.

애플리케이션 프로토콜은 용도를 정의하는 프로필 없이 0-RTT 데이터를 사용해서는 안 됩니다. 해당 프로필은 0-RTT와 함께 사용하기에 안전한 메시지나 상호 작용과 서버가 0-RTT를 거부하고 1-RTT로 폴백할 때 상황을 처리하는 방법을 식별해야 합니다.

또한 실수로 인한 오용을 방지하기 위해 TLS 구현은 애플리케이션에서 특별히 요청하지 않는 한 0-RTT\(전송 또는 수락\)를 활성화해서는 안 되며, 애플리케이션에서 지시하지 않는 한 서버에서 거부하는 경우 0-RTT 데이터를 자동으로 다시 전송해서는 안 됩니다. 서버 측 애플리케이션은 일부 애플리케이션 트래픽에 대해 0-RTT 데이터에 대한 특수 처리를 구현하려고 할 수 있습니다\(예: 연결 중단, 애플리케이션 계층에서 데이터 재전송 요청, 핸드셰이크가 완료될 때까지 처리 지연\). 애플리케이션이 이러한 종류의 처리를 구현할 수 있도록 하려면 TLS 구현은 애플리케이션이 핸드셰이크가 완료되었는지 확인할 수 있는 방법을 제공해야 합니다.

---
#### **E.5.1.  Replay and Exporters**

ClientHello의 재생은 동일한 초기 내보내기를 생성하므로 이러한 내보내기를 사용하는 애플리케이션에서는 추가적인 주의가 필요합니다. 특히 이러한 내보내기가 인증 채널 바인딩으로 사용되는 경우\(예: 내보내기의 출력에 서명\) PSK를 손상시키는 공격자는 인증 키를 손상시키지 않고 연결 간에 인증자를 이식할 수 있습니다.

또한 서버-클라이언트 암호화 키를 생성하는 데 초기 내보내기를 사용해서는 안 됩니다. 왜냐하면 해당 키의 재사용이 수반되기 때문입니다. 이는 클라이언트에서 서버 방향으로만 초기 애플리케이션 트래픽 키를 사용하는 것과 유사합니다.

---
### **E.6.  PSK Identity Exposure**

구현에서는 핸드셰이크를 중단하여 잘못된 PSK 바인더에 응답하기 때문에 공격자가 지정된 PSK ID가 유효한지 여부를 확인할 수 있습니다. 특히, 서버가 외부 PSK 핸드셰이크와 인증서 기반 핸드셰이크를 모두 허용하는 경우 유효한 PSK ID로 인해 핸드셰이크가 실패하는 반면, 유효하지 않은 ID는 건너뛰고 인증서 핸드셰이크에 성공하게 됩니다. PSK 핸드셰이크만 지원하는 서버는 유효한 PSK ID가 없는 경우와 ID는 있지만 유효하지 않은 바인더가 있는 경우를 동일하게 처리하여 이러한 형태의 공격에 저항할 수 있습니다.

---
### **E.7.  Sharing PSKs**

TLS 1.3은 PSK를 특정 KDF에 바인딩하여 PSK에 대해 보수적인 접근 방식을 취합니다. 이와 대조적으로 TLS 1.2에서는 PSK를 모든 해시 함수 및 TLS 1.2 PRF와 함께 사용할 수 있습니다. 따라서 TLS 1.2 및 TLS 1.3 모두와 함께 사용되는 모든 PSK는 TLS 1.3에서 하나의 해시와 함께 사용해야 하며, 이는 사용자가 단일 PSK를 프로비저닝하려는 경우 최적이 아닙니다. TLS 1.2와 TLS 1.3의 구성은 서로 다르지만 둘 다 HMAC를 기반으로 합니다. 동일한 PSK가 두 버전 모두에서 관련 출력을 생성할 수 있는 알려진 방법은 없지만 제한된 분석만 수행되었습니다. 구현에서는 TLS 1.3과 TLS 1.2 사이에서 PSK를 재사용하지 않음으로써 프로토콜 간 관련 출력의 안전성을 보장할 수 있습니다.

---
### **E.8.  Attacks on Static RSA**

TLS 1.3은 RSA 키 전송을 사용하지 않으므로 Bleichenbacher 유형 공격\[Blei98\]에 직접적으로 취약하지 않지만 TLS 1.3 서버가 이전 TLS 버전의 컨텍스트에서 정적 RSA를 지원하는 경우 서버를 가장하는 것이 가능할 수 있습니다. TLS 1.3 연결 \[JSS15\]의 경우. TLS 1.3 구현은 모든 TLS 버전에서 정적 RSA에 대한 지원을 비활성화하여 이 공격을 방지할 수 있습니다. 원칙적으로 구현 시 정적 RSA 복호화 및 RSA 서명에 대해 서로 다른 keyUsage 비트를 사용하여 인증서를 분리할 수도 있지만 이 기술은 클라이언트가 digitalSignature 비트가 설정되지 않은 인증서의 키를 사용하여 서명을 수락하는 것을 거부하고 많은 클라이언트가 이를 수행합니다. 이 제한을 시행하지 마세요.

---
# **Contributors**

마틴 아바디 캘리포니아 대학교, 산타 크루즈 abadi@cs.ucsc.edu

Christopher Allen\(TLS 1.0 공동 편집자\) Alacrity Ventures ChristopherA@AlacrityManagement.com

```text
   Richard Barnes
   Cisco
   rlb@ipv.sx

   Steven M. Bellovin
   Columbia University
   smb@cs.columbia.edu

   David Benjamin
   Google
   davidben@google.com

   Benjamin Beurdouche
   INRIA & Microsoft Research
   benjamin.beurdouche@ens.fr
```

Karthikeyan Bhargavan\(\[RFC7627\] 편집자\) INRIA karthikeyan.bhargavan@inria.fr

Simon Blake-Wilson\(\[RFC4492\] 공동 저자\) BCI sblakewilson@bcisse.com

Nelson Bolyard\(\[RFC4492\] 공동 저자\) Sun Microsystems, Inc. nelson@bolyard.com

```text
   Ran Canetti
   IBM
   canetti@watson.ibm.com

   Matt Caswell
   OpenSSL
   matt@openssl.org
```

스티븐 체코웨이 일리노이 대학교 시카고 sfc@uic.edu

```text
   Pete Chown
   Skygate Technology Ltd
   pc@skygate.co.uk
```

카트리엘 콘-고든 옥스퍼드 대학교 me@katriel.co.uk

카스 크레머스 옥스퍼드 대학교 cas.cremers@cs.ox.ac.uk

Antoine Delignat-Lavaud\(\[RFC7627\] 공동 저자\) INRIA antdl@microsoft.com

Tim Dierks\(TLS 1.0 공동 저자, TLS 1.1 및 1.2 공동 편집자\) 독립 tim@dierks.org

```text
   Roelof DuToit
   Symantec Corporation
   roelof_dutoit@symantec.com

   Taher Elgamal
   Securify
   taher@securify.com

   Pasi Eronen
   Nokia
   pasi.eronen@nokia.com

   Cedric Fournet
   Microsoft
   fournet@microsoft.com

   Anil Gangolli
   anil@busybuddha.org

   David M. Garrett
   dave@nulldereference.com

   Illya Gerasymchuk
   Independent
   illya@iluxonchik.me

   Alessandro Ghedini
   Cloudflare Inc.
   alessandro@cloudflare.com

   Daniel Kahn Gillmor
   ACLU
   dkg@fifthhorseman.net

   Matthew Green
   Johns Hopkins University
   mgreen@cs.jhu.edu

   Jens Guballa
   ETAS
   jens.guballa@etas.com

   Felix Guenther
   TU Darmstadt
   mail@felixguenther.info
```

Vipul Gupta\(\[RFC4492\]의 공동 저자\) Sun Microsystems Laboratories vipul.gupta@sun.com

Chris Hawk\(\[RFC4492\] 공동 저자\) Corriente Networks LLC chris@corriente.net

```text
   Kipp Hickman

   Alfred Hoenes

   David Hopwood
   Independent Consultant
   david.hopwood@blueyonder.co.uk

   Marko Horvat
   MPI-SWS
   mhorvat@mpi-sws.org
```

조나단 호이랜드 로열 홀로웨이, 런던대학교 jonathan.hoyland@gmail.com

```text
   Subodh Iyengar
   Facebook
   subodh@fb.com

   Benjamin Kaduk
   Akamai Technologies
   kaduk@mit.edu

   Hubert Kario
   Red Hat Inc.
   hkario@redhat.com
```

Phil Karlton\(SSL 3.0 공동 저자\)

```text
   Leon Klingele
   Independent
   mail@leonklingele.de
```

Paul Kocher\(SSL 3.0 공동 저자\) 암호화 연구 paul@cryptography.com

```text
   Hugo Krawczyk
   IBM
   hugokraw@us.ibm.com
```

Adam Langley\(\[RFC7627\]의 공동 저자\) Google agl@google.com

```text
   Olivier Levillain
   ANSSI
   olivier.levillain@ssi.gouv.fr
```

샤오인 리우 노스캐롤라이나대학교 채플힐 xiaoyin.l@outlook.com

```text
   Ilari Liusvaara
   Independent
   ilariliusvaara@welho.com

   Atul Luykx
   K.U. Leuven
   atul.luykx@kuleuven.be

   Colm MacCarthaigh
   Amazon Web Services
   colm@allcosts.net

   Carl Mehner
   USAA
   carl.mehner@usaa.com

   Jan Mikkelsen
   Transactionware
   janm@transactionware.com
```

Bodo Moeller\(\[RFC4492\]의 공동 저자\) Google bodo@acm.org

```text
   Kyle Nekritz
   Facebook
   knekritz@fb.com

   Erik Nygren
   Akamai Technologies
   erik+ietf@nygren.org

   Magnus Nystrom
   Microsoft
   mnystrom@microsoft.com

   Kazuho Oku
   DeNA Co., Ltd.
   kazuhooku@gmail.com
```

Kenny Paterson Royal Holloway, 런던 대학교 kenny.paterson@rhul.ac.uk

크리스토퍼 패튼 플로리다 대학교 cjpatton@ufl.edu

Alfredo Pironti\(\[RFC7627\]의 공동 저자\) INRIA alfredo.pironti@inria.fr

```text
   Andrei Popov
   Microsoft
   andrei.popov@microsoft.com
```

Marsh Ray\(\[RFC7627\] 공동 저자\) Microsoft maray@microsoft.com

```text
   Robert Relyea
   Netscape Communications
   relyea@netscape.com

   Kyle Rose
   Akamai Technologies
   krose@krose.org

   Jim Roskind
   Amazon
   jroskind@amazon.com

   Michael Sabin

   Joe Salowey
   Tableau Software
   joe@salowey.net

   Rich Salz
   Akamai
   rsalz@akamai.com

   David Schinazi
   Apple Inc.
   dschinazi@apple.com
```

Sam Scott Royal Holloway, 런던대학교 me@samjs.co.uk

플로리다 토마스 슈림프턴 대학교 teshrim@ufl.edu

```text
   Dan Simon
   Microsoft, Inc.
   dansimon@microsoft.com

   Brian Smith
   Independent
   brian@briansmith.org

   Brian Sniffen
   Akamai Technologies
   ietf@bts.evenmere.org

   Nick Sullivan
   Cloudflare Inc.
   nick@cloudflare.com
```

Bjoern Tackmann 캘리포니아 대학교, 샌디에이고 btackmann@eng.ucsd.edu

```text
   Tim Taubert
   Mozilla
   ttaubert@mozilla.com

   Martin Thomson
   Mozilla
   mt@mozilla.com

   Hannes Tschofenig
   Arm Limited
   Hannes.Tschofenig@arm.com

   Sean Turner
   sn3rd
   sean@sn3rd.com

   Steven Valdez
   Google
   svaldez@google.com

   Filippo Valsorda
   Cloudflare Inc.
   filippo@cloudflare.com
```

Thyla van der Merwe Royal Holloway, 런던대학교 tjvdmerwe@gmail.com

```text
   Victor Vasiliev
   Google
   vasilvv@google.com

   Hoeteck Wee
   Ecole Normale Superieure, Paris
   hoeteck@alum.mit.edu

   Tom Weinstein

   David Wong
   NCC Group
   david.wong@nccgroup.trust

   Christopher A. Wood
   Apple Inc.
   cawood@apple.com

   Tim Wright
   Vodafone
   timothy.wright@vodafone.com

   Peter Wu
   Independent
   peter@lekensteyn.nl

   Kazu Yamamoto
   Internet Initiative Japan Inc.
   kazu@iij.ad.jp
```

---
# **Author's Address**

```text
   Eric Rescorla
   Mozilla

   Email: ekr@rtfm.com
```
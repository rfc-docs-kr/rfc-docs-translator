

```text
Network Working Group                                       S. Josefsson
Request for Comments: 4648                                           SJD
Obsoletes: 3548                                             October 2006
Category: Standards Track

             The Base16, Base32, and Base64 Data Encodings
```

---
# **Status of This Memo**

이 문서는 인터넷 커뮤니티를 위한 인터넷 표준 추적 프로토콜을 지정하고 개선을 위한 토론 및 제안을 요청합니다. 이 프로토콜의 표준화 상태 및 상태에 대해서는 "Internet Official Protocol Standards"\(STD 1\) 최신판을 참조하십시오. 이 메모의 배포는 무제한입니다.

---
# **Copyright Notice**

Copyright \(C\) The Internet Society \(2006\).

---
# **Abstract**

이 문서에서는 일반적으로 사용되는 기본 64, 기본 32 및 기본 16 인코딩 체계에 대해 설명합니다. 또한 인코딩된 데이터에서 줄 바꿈 사용, 인코딩된 데이터에서 패딩 사용, 인코딩된 데이터에서 알파벳이 아닌 문자 사용, 다른 인코딩 알파벳 사용 및 표준 인코딩에 대해 설명합니다.

---
# **Table of Contents**

```text
   1. Introduction ....................................................3
   2. Conventions Used in This Document ...............................3
   3. Implementation Discrepancies ....................................3
      3.1. Line Feeds in Encoded Data .................................3
      3.2. Padding of Encoded Data ....................................4
      3.3. Interpretation of Non-Alphabet Characters in Encoded Data ..4
      3.4. Choosing the Alphabet ......................................4
      3.5. Canonical Encoding .........................................5
   4. Base 64 Encoding ................................................5
   5. Base 64 Encoding with URL and Filename Safe Alphabet ............7
   6. Base 32 Encoding ................................................8
   7. Base 32 Encoding with Extended Hex Alphabet ....................10
   8. Base 16 Encoding ...............................................10
   9. Illustrations and Examples .....................................11
   10. Test Vectors ..................................................12
   11. ISO C99 Implementation of Base64 ..............................14
   12. Security Considerations .......................................14
   13. Changes Since RFC 3548 ........................................15
   14. Acknowledgements ..............................................15
   15. Copying Conditions ............................................15
   16. References ....................................................16
      16.1. Normative References .....................................16
      16.2. Informative References ...................................16
```

---
## **1.  Introduction**

데이터의 기본 인코딩은 레거시 이유로 인해 US-ASCII \[1\] 데이터로 제한되는 환경에서 데이터를 저장하거나 전송하기 위해 많은 상황에서 사용됩니다. 기본 인코딩은 텍스트 편집기로 개체를 조작할 수 있게 해주기 때문에 레거시 제한이 없는 새로운 응용 프로그램에서도 사용할 수 있습니다.

과거에는 다양한 애플리케이션의 요구 사항이 다르기 때문에 때로는 약간 다른 방식으로 기본 인코딩을 구현했습니다. 오늘날 프로토콜 사양에서는 정확한 설명이나 참조 없이 일반적으로 기본 인코딩, 특히 "base64"를 사용하는 경우가 있습니다. 다목적 인터넷 메일 확장\(MIME\) \[4\]은 줄 바꿈이나 알파벳이 아닌 문자에 대한 결과를 고려하지 않고 base64에 대한 참조로 자주 사용됩니다. 이 사양의 목적은 공통 알파벳 및 인코딩 고려 사항을 설정하는 것입니다. 이렇게 하면 다른 문서의 모호함이 줄어들어 상호 운용성이 향상될 것입니다.

---
## **2.  Conventions Used in This Document**

이 문서의 핵심 단어 "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY" 및 "OPTIONAL"은 다음과 같습니다. \[2\]에 설명된 대로 해석됩니다.\(MUST NOT\)

---
## **3.  Implementation Discrepancies**

여기서는 과거의 기본 인코딩 구현 간의 불일치에 대해 논의하고, 적절한 경우 미래에 대한 특정 권장 동작을 요구합니다.

---
### **3.1.  Line Feeds in Encoded Data**

MIME \[4\]는 종종 Base 64 인코딩에 대한 참조로 사용됩니다. 그러나 MIME은 "base 64" 자체를 정의하지 않고 MIME 내에서 사용하기 위한 "base 64 콘텐츠 전송 인코딩"을 정의합니다. 따라서 MIME은 Base 64로 인코딩된 데이터의 줄 길이를 76자로 제한합니다. MIME은 PEM\(Privacy Enhanced Mail\) \[3\]의 인코딩을 상속하여 "사실상 동일하다"고 명시합니다. 그러나 PEM은 64자의 줄 길이를 사용합니다. MIME 및 PEM 제한은 모두 SMTP 내의 제한으로 인해 발생합니다.

구현 시 이 문서를 참조하는 사양이 기본 인코더가 특정 문자 수 뒤에 줄 바꿈을 추가하도록 명시적으로 지시하지 않는 한 기본 인코딩된 데이터에 줄 바꿈을 추가해서는 안 됩니다.\(MUST NOT\)

---
### **3.2.  Padding of Encoded Data**

어떤 상황에서는 기본 인코딩된 데이터에서 패딩\("="\) 사용이 필요하지 않거나 사용되지 않습니다. 일반적인 경우 전송된 데이터의 크기에 대한 가정을 할 수 없는 경우 올바른 디코딩된 데이터를 생성하기 위해 패딩이 필요합니다.

구현 시 이 문서를 참조하는 사양에서 명시적으로 다르게 명시하지 않는 한 인코딩된 데이터 끝에 적절한 패드 문자를 포함해야 합니다.\(MUST\)

base64 및 base32 알파벳은 아래 섹션 4와 6에 설명된 대로 패딩을 사용하지만 base16 알파벳에는 패딩이 필요하지 않습니다. 섹션 8을 참조하세요.

---
### **3.3.  Interpretation of Non-Alphabet Characters in Encoded Data**

기본 인코딩은 특정 축소 알파벳을 사용하여 이진 데이터를 인코딩합니다. 데이터 손상이나 설계로 인해 기본 인코딩된 데이터 내에 알파벳이 아닌 문자가 존재할 수 있습니다. 알파벳이 아닌 문자는 비프로토콜 데이터가 악의적인 목적으로 전송될 수 있는 "비밀 채널"로 악용될 수 있습니다. 예를 들어 버퍼 오버플로 공격으로 이어지는 구현 오류를 이용하기 위해 알파벳이 아닌 문자가 전송될 수도 있습니다.

이 문서를 참조하는 사양에서 명시적으로 다르게 명시하지 않는 한, 기본 인코딩된 데이터를 해석할 때 기본 알파벳 외부 문자가 포함된 경우 구현에서는 인코딩된 데이터를 거부해야 합니다. 대신 이러한 사양에서는 MIME처럼 기본 인코딩 알파벳 외부의 문자는 데이터를 해석할 때 무시해야 한다고 명시할 수 있습니다\("허용하는 내용은 자유로워야 합니다"\). 이는 인접한 CRLF\(캐리지 리턴/줄 바꿈\) 문자가 "비알파벳 문자"를 구성하고 무시된다는 것을 의미합니다. 또한 이러한 사양은 패드 문자 "="를 무시할 수 있으며, 인코딩된 데이터가 끝나기 전에 패드 문자가 있는 경우 이를 알파벳이 아닌 데이터로 처리할 수 있습니다. 문자열 끝에 허용된 패드 문자 수보다 많은 경우\(예: "==="로 끝나는 기본 64 문자열\) 초과된 패드 문자도 무시될 수 있습니다.\(MUST, MAY, MAY\)

---
### **3.4.  Choosing the Alphabet**

애플리케이션마다 알파벳 문자에 대한 요구 사항이 다릅니다. 어떤 알파벳을 사용해야 하는지 결정하는 몇 가지 요구 사항은 다음과 같습니다.

o 인간이 처리합니다. 문자 "0"과 "O"는 쉽게

- "1", "l", "I"와 마찬가지로 혼란스럽습니다. 아래의 base32 알파벳에서 0\(영\)과 1\(1\)이 존재하지 않는 경우, 디코더는 대소문자에 따라 0을 O로, 1을 I 또는 L로 해석할 수 있습니다. \(그러나 기본적으로는 그렇지 않아야 합니다. 이전 섹션을 참조하십시오.\)

o 다른 요구 사항을 요구하는 구조로 인코딩됩니다. 기본 16 및 기본 32의 경우 대문자 또는 소문자 알파벳 사용을 결정합니다. Base 64의 경우 영숫자가 아닌 문자\(특히 "/"\)가 파일 이름과 URL에 문제가 될 수 있습니다.

o 식별자로 사용됩니다. 특정 문자\(특히 기본 64 알파벳의 "+" 및 "/"\)는 기존 텍스트 검색/색인 도구에서 단어 분리로 처리됩니다.

모든 요구 사항을 충족하는 보편적으로 허용되는 알파벳은 없습니다. 고도로 전문화된 변형의 예를 보려면 IMAP \[8\]을 참조하세요. 이 문서에서는 현재 사용되는 일부 알파벳을 문서화하고 이름을 지정합니다.

---
### **3.5.  Canonical Encoding**

베이스 64 및 베이스 32 인코딩의 패딩 단계는 부적절하게 구현될 경우 인코딩된 데이터가 중요하지 않게 변경될 수 있습니다. 예를 들어, 기본 64 인코딩에 대해 입력이 1옥텟인 경우 첫 번째 기호의 6비트가 모두 사용되지만 다음 기호의 처음 2비트만 사용됩니다. 이러한 패드 비트는 아래 패딩에 대한 설명에 설명된 인코더를 준수하여 0으로 설정되어야 합니다. 이 속성이 유지되지 않으면 기본 인코딩된 데이터의 정식 표현이 없으며 여러 기본 인코딩 문자열이 동일한 이진 데이터로 디코딩될 수 있습니다. 이 속성\(및 이 문서에서 설명하는 다른 속성\)이 유지되면 표준 인코딩이 보장됩니다.\(MUST\)

일부 환경에서는 변경이 중요하므로 디코더는 패드 비트가 0으로 설정되지 않은 경우 인코딩을 거부하도록 선택할 수 있습니다. 이를 참조하는 사양에서는 특정 동작을 요구할 수 있습니다.\(MAY\)

---
## **4.  Base 64 Encoding**

밑수 64에 대한 다음 설명은 \[3\], \[4\], \[5\] 및 \[6\]에서 파생됩니다. 이 인코딩은 "base64"라고 할 수 있습니다.

Base 64 인코딩은 대문자와 소문자를 모두 사용할 수 있지만 사람이 읽을 필요는 없는 형식으로 임의의 옥텟 시퀀스를 나타내도록 설계되었습니다.

US-ASCII의 65자 하위 집합이 사용되어 인쇄 가능한 문자당 6비트를 표현할 수 있습니다. \(추가 65번째 문자 "="는 특수 처리 기능을 나타내는 데 사용됩니다.\)

인코딩 프로세스는 입력 비트의 24비트 그룹을 4개의 인코딩된 문자의 출력 문자열로 나타냅니다. 왼쪽에서 오른쪽으로 3개의 8비트 입력 그룹을 연결하여 24비트 입력 그룹이 형성됩니다. 이 24비트는 4개의 연결된 6비트 그룹으로 처리되며, 각 그룹은 기본 64 알파벳의 단일 문자로 변환됩니다.

각 6비트 그룹은 인쇄 가능한 64개의 문자 배열에 대한 인덱스로 사용됩니다. 인덱스에서 참조하는 문자는 출력 문자열에 배치됩니다.

```text
                      Table 1: The Base 64 Alphabet

     Value Encoding  Value Encoding  Value Encoding  Value Encoding
         0 A            17 R            34 i            51 z
         1 B            18 S            35 j            52 0
         2 C            19 T            36 k            53 1
         3 D            20 U            37 l            54 2
         4 E            21 V            38 m            55 3
         5 F            22 W            39 n            56 4
         6 G            23 X            40 o            57 5
         7 H            24 Y            41 p            58 6
         8 I            25 Z            42 q            59 7
         9 J            26 a            43 r            60 8
        10 K            27 b            44 s            61 9
        11 L            28 c            45 t            62 +
        12 M            29 d            46 u            63 /
        13 N            30 e            47 v
        14 O            31 f            48 w         (pad) =
        15 P            32 g            49 x
        16 Q            33 h            50 y
```

인코딩되는 데이터의 끝에서 사용 가능한 비트가 24비트 미만인 경우 특수 처리가 수행됩니다. 전체 인코딩 퀀텀은 항상 수량의 끝에서 완료됩니다. 입력 그룹에서 24개 미만의 입력 비트를 사용할 수 있는 경우 값이 0인 비트가 오른쪽에 추가되어 6비트 그룹의 정수를 형성합니다. 데이터 끝 부분의 패딩은 '=' 문자를 사용하여 수행됩니다. 모든 기본 64 입력은 옥텟의 정수이므로 다음과 같은 경우만 발생할 수 있습니다.

\(1\) 인코딩 입력의 최종 양자는 24비트의 정수배입니다. 여기서 인코딩된 출력의 최종 단위는 "=" 패딩이 없는 4자의 정수배입니다.

\(2\) 인코딩 입력의 최종 양자는 정확히 8비트입니다. 여기서 인코딩된 출력의 최종 단위는 두 문자 뒤에 두 개의 "=" 패딩 문자가 오는 것입니다.

\(3\) 인코딩 입력의 최종 양자는 정확히 16비트입니다. 여기서 인코딩된 출력의 최종 단위는 3개의 문자와 그 뒤에 하나의 "=" 패딩 문자가 됩니다.

---
## **5.  Base 64 Encoding with URL and Filename Safe Alphabet**

URL 및 파일 이름 안전 알파벳을 사용한 Base 64 인코딩이 \[12\]에서 사용되었습니다.

63번째 문자로 "\~"를 사용하는 대체 알파벳이 제안되었습니다. "\~" 문자는 일부 파일 시스템 환경에서 특별한 의미를 갖기 때문에 대신 이 섹션에서 설명하는 인코딩을 권장합니다. 예약되지 않은 나머지 URI 문자는 "."이지만 일부 파일 시스템 환경에서는 여러 개의 "."를 허용하지 않습니다. 파일 이름에 "." 성격도 매력없어요.

패드 문자 "="는 URI \[9\]에서 사용될 때 일반적으로 백분율로 인코딩되지만 데이터 길이가 암시적으로 알려진 경우 패딩을 건너뛰어 이를 피할 수 있습니다. 섹션 3.2를 참조하세요.

이 인코딩은 "base64url"이라고 할 수 있습니다. 이 인코딩은 "base64" 인코딩과 동일하게 간주되어서는 안 되며 단지 "base64"로만 참조되어서는 안 됩니다. 달리 명시하지 않는 한 "base64"는 이전 섹션의 기본 64를 나타냅니다.

이 인코딩은 표 2에 표시된 대로 62:nd 및 63:rd 알파벳 문자를 제외하고 이전 인코딩과 기술적으로 동일합니다.

- 표 2: "URL 및 파일 이름 안전" Base 64 알파벳

```text
     Value Encoding  Value Encoding  Value Encoding  Value Encoding
         0 A            17 R            34 i            51 z
         1 B            18 S            35 j            52 0
         2 C            19 T            36 k            53 1
         3 D            20 U            37 l            54 2
         4 E            21 V            38 m            55 3
         5 F            22 W            39 n            56 4
         6 G            23 X            40 o            57 5
         7 H            24 Y            41 p            58 6
         8 I            25 Z            42 q            59 7
         9 J            26 a            43 r            60 8
        10 K            27 b            44 s            61 9
        11 L            28 c            45 t            62 - (minus)
        12 M            29 d            46 u            63 _
        13 N            30 e            47 v           (underline)
        14 O            31 f            48 w
        15 P            32 g            49 x
        16 Q            33 h            50 y         (pad) =
```

---
## **6.  Base 32 Encoding**

밑수 32에 대한 다음 설명은 \[11\]\(수정 사항 포함\)에서 파생되었습니다. 이 인코딩은 "base32"라고 할 수 있습니다.

Base 32 인코딩은 대소문자를 구분해야 하지만 사람이 읽을 수는 없는 형식으로 임의의 옥텟 시퀀스를 나타내도록 설계되었습니다.

US-ASCII의 33자 하위 집합이 사용되어 인쇄 가능한 문자당 5비트를 표현할 수 있습니다. \(추가 33번째 문자 "="는 특수 처리 기능을 나타내는 데 사용됩니다.\)

인코딩 프로세스는 40비트 입력 비트 그룹을 8개의 인코딩된 문자의 출력 문자열로 나타냅니다. 왼쪽에서 오른쪽으로 5개의 8비트 입력 그룹을 연결하여 40비트 입력 그룹이 구성됩니다. 이 40비트는 8개의 연결된 5비트 그룹으로 처리되며, 각 그룹은 기본 32 알파벳의 단일 문자로 변환됩니다. 비트 스트림이 기본 32 인코딩을 통해 인코딩되는 경우 비트 스트림은 최상위 비트부터 순서가 지정되는 것으로 가정되어야 합니다. 즉, 스트림의 첫 번째 비트는 첫 번째 8비트 바이트의 상위 비트가 되고, 8번째 비트는 첫 번째 8비트 바이트의 하위 비트가 되는 식입니다.

각 5비트 그룹은 인쇄 가능한 32개의 문자 배열에 대한 인덱스로 사용됩니다. 인덱스에서 참조하는 문자는 출력 문자열에 배치됩니다. 아래 표 3에서 식별되는 이러한 문자는 US-ASCII 숫자와 대문자 중에서 선택됩니다.

- 표 3: 기본 32 알파벳

```text
     Value Encoding  Value Encoding  Value Encoding  Value Encoding
         0 A             9 J            18 S            27 3
         1 B            10 K            19 T            28 4
         2 C            11 L            20 U            29 5
         3 D            12 M            21 V            30 6
         4 E            13 N            22 W            31 7
         5 F            14 O            23 X
         6 G            15 P            24 Y         (pad) =
         7 H            16 Q            25 Z
         8 I            17 R            26 2
```

인코딩되는 데이터의 끝에서 사용 가능한 비트가 40비트 미만인 경우 특수 처리가 수행됩니다. 전체 인코딩 퀀텀은 항상 본문 끝에서 완료됩니다. 입력 그룹에서 사용할 수 있는 입력 비트가 40개 미만인 경우 값이 0인 비트가 오른쪽에 추가되어 5비트 그룹의 정수를 형성합니다. 데이터 끝 부분의 패딩은 "=" 문자를 사용하여 수행됩니다. 모든 기본 32 입력은 정수 옥텟이므로 다음과 같은 경우만 발생할 수 있습니다.

\(1\) 인코딩 입력의 최종 양자는 40비트의 정수배입니다. 여기서 인코딩된 출력의 최종 단위는 "=" 패딩이 없는 8자의 정수배입니다.

\(2\) 인코딩 입력의 최종 양자는 정확히 8비트입니다. 여기서 인코딩된 출력의 최종 단위는 2개의 문자 뒤에 6개의 "=" 패딩 문자가 오는 것입니다.

\(3\) 인코딩 입력의 최종 양자는 정확히 16비트입니다. 여기서 인코딩된 출력의 최종 단위는 4개의 문자와 4개의 "=" 패딩 문자가 뒤따르는 것입니다.

\(4\) 인코딩 입력의 최종 양자는 정확히 24비트입니다. 여기서 인코딩된 출력의 최종 단위는 5개의 문자와 3개의 "=" 패딩 문자가 뒤따르는 것입니다.

\(5\) 인코딩 입력의 최종 양자는 정확히 32비트입니다. 여기서 인코딩된 출력의 최종 단위는 7개 문자 뒤에 1개의 "=" 패딩 문자가 오는 것입니다.

---
## **7.  Base 32 Encoding with Extended Hex Alphabet**

밑수 32에 대한 다음 설명은 \[7\]에서 파생되었습니다. 이 인코딩은 "base32hex"라고 할 수 있습니다. 이 인코딩은 "base32" 인코딩과 동일하게 간주되어서는 안 되며 단지 "base32"로만 참조되어서는 안 됩니다. 이 인코딩은 예를 들어 NextSECure3\(NSEC3\)\[10\]에서 사용됩니다.

base64 및 base32 알파벳에는 없는 이 알파벳의 한 가지 속성은 인코딩된 데이터를 비트 단위로 비교할 때 인코딩된 데이터가 정렬 순서를 유지한다는 것입니다.

이 인코딩은 알파벳을 제외하고 이전 인코딩과 동일합니다. 새로운 알파벳은 표 4에 나와 있습니다.

```text
                 Table 4: The "Extended Hex" Base 32 Alphabet

         Value Encoding  Value Encoding  Value Encoding  Value Encoding
             0 0             9 9            18 I            27 R
             1 1            10 A            19 J            28 S
             2 2            11 B            20 K            29 T
             3 3            12 C            21 L            30 U
             4 4            13 D            22 M            31 V
             5 5            14 E            23 N
             6 6            15 F            24 O         (pad) =
             7 7            16 G            25 P
             8 8            17 H            26 Q
```

---
## **8.  Base 16 Encoding**

다음 설명은 원본이지만 이전 설명과 유사합니다. 기본적으로 Base 16 인코딩은 대소문자를 구분하지 않는 표준 16진수 인코딩이며 "base16" 또는 "16진수"라고도 합니다.

US-ASCII의 16자 하위 집합이 사용되어 인쇄 가능한 문자당 4비트를 표현할 수 있습니다.

인코딩 프로세스는 입력 비트의 8비트 그룹\(옥텟\)을 2개의 인코딩된 문자의 출력 문자열로 나타냅니다. 왼쪽에서 오른쪽으로 진행하면서 입력 데이터에서 8비트 입력을 가져옵니다. 그런 다음 이 8비트는 2개의 연결된 4비트 그룹으로 처리되며, 각 그룹은 기본 16 알파벳의 단일 문자로 변환됩니다.

각 4비트 그룹은 인쇄 가능한 16개의 문자 배열에 대한 인덱스로 사용됩니다. 인덱스에서 참조하는 문자는 출력 문자열에 배치됩니다.

```text
                         Table 5: The Base 16 Alphabet

         Value Encoding  Value Encoding  Value Encoding  Value Encoding
             0 0             4 4             8 8            12 C
             1 1             5 5             9 9            13 D
             2 2             6 6            10 A            14 E
             3 3             7 7            11 B            15 F
```

기본 32 및 기본 64와 달리 전체 코드 단어를 항상 사용할 수 있으므로 특별한 패딩이 필요하지 않습니다.

---
## **9.  Illustrations and Examples**

이진 인코딩과 기본 인코딩 간을 변환하기 위해 입력이 구조에 저장되고 출력이 추출됩니다. 밑수 64의 경우는 \[5\]에서 가져온 다음 그림에 표시됩니다.

```text
            +--first octet--+-second octet--+--third octet--+
            |7 6 5 4 3 2 1 0|7 6 5 4 3 2 1 0|7 6 5 4 3 2 1 0|
            +-----------+---+-------+-------+---+-----------+
            |5 4 3 2 1 0|5 4 3 2 1 0|5 4 3 2 1 0|5 4 3 2 1 0|
            +--1.index--+--2.index--+--3.index--+--4.index--+
```

베이스 32의 경우는 \[7\]에서 차용한 다음 그림에 나와 있습니다. 기본 32 값의 각 연속 문자는 기본 옥텟 시퀀스의 연속 5비트를 나타냅니다. 따라서 8개 문자로 구성된 각 그룹은 5옥텟\(40비트\)의 시퀀스를 나타냅니다.

```text
                        1          2          3
             01234567 89012345 67890123 45678901 23456789
            +--------+--------+--------+--------+--------+
            |< 1 >< 2| >< 3 ><|.4 >< 5.|>< 6 ><.|7 >< 8 >|
            +--------+--------+--------+--------+--------+
                                                    <===> 8th character
                                              <====> 7th character
                                         <===> 6th character
                                   <====> 5th character
                             <====> 4th character
                        <===> 3rd character
                  <====> 2nd character
             <===> 1st character
```

다음 Base64 데이터 예는 \[5\]에서 수정된 것입니다.

```text
      Input data:  0x14fb9c03d97e
      Hex:     1   4    f   b    9   c     | 0   3    d   9    7   e
      8-bit:   00010100 11111011 10011100  | 00000011 11011001 01111110
      6-bit:   000101 001111 101110 011100 | 000000 111101 100101 111110
      Decimal: 5      15     46     28       0      61     37     62
      Output:  F      P      u      c        A      9      l      +

      Input data:  0x14fb9c03d9
      Hex:     1   4    f   b    9   c     | 0   3    d   9
      8-bit:   00010100 11111011 10011100  | 00000011 11011001
                                                      pad with 00
      6-bit:   000101 001111 101110 011100 | 000000 111101 100100
      Decimal: 5      15     46     28       0      61     36
                                                         pad with =
      Output:  F      P      u      c        A      9      k      =

      Input data:  0x14fb9c03
      Hex:     1   4    f   b    9   c     | 0   3
      8-bit:   00010100 11111011 10011100  | 00000011
                                             pad with 0000
      6-bit:   000101 001111 101110 011100 | 000000 110000
      Decimal: 5      15     46     28       0      48
                                                  pad with =      =
      Output:  F      P      u      c        A      w      =      =
```

---
## **10.  Test Vectors**

```text
   BASE64("") = ""

   BASE64("f") = "Zg=="

   BASE64("fo") = "Zm8="

   BASE64("foo") = "Zm9v"

   BASE64("foob") = "Zm9vYg=="

   BASE64("fooba") = "Zm9vYmE="

   BASE64("foobar") = "Zm9vYmFy"

   BASE32("") = ""

   BASE32("f") = "MY======"

   BASE32("fo") = "MZXQ===="

   BASE32("foo") = "MZXW6==="

   BASE32("foob") = "MZXW6YQ="

   BASE32("fooba") = "MZXW6YTB"

   BASE32("foobar") = "MZXW6YTBOI======"

   BASE32-HEX("") = ""

   BASE32-HEX("f") = "CO======"

   BASE32-HEX("fo") = "CPNG===="

   BASE32-HEX("foo") = "CPNMU==="

   BASE32-HEX("foob") = "CPNMUOG="

   BASE32-HEX("fooba") = "CPNMUOJ1"

   BASE32-HEX("foobar") = "CPNMUOJ1E8======"

   BASE16("") = ""

   BASE16("f") = "66"

   BASE16("fo") = "666F"

   BASE16("foo") = "666F6F"

   BASE16("foob") = "666F6F62"

   BASE16("fooba") = "666F6F6261"

   BASE16("foobar") = "666F6F626172"
```

---
## **11.  ISO C99 Implementation of Base64**

이 RFC의 모든 권장 사항을 따르는 것으로 여겨지는 Base64 인코딩 및 디코딩의 ISO C99 구현은 다음에서 제공됩니다.

```text
      http://josefsson.org/base-encoding/
```

이 코드는 규범적이지 않습니다.

절차상의 이유로 이 RFC에 코드를 포함할 수 없습니다\(RFC 3978 섹션 5.4\).

---
## **12.  Security Considerations**

기본 인코딩 및 디코딩을 구현할 때 버퍼 오버플로 공격이나 구현에 대한 기타 공격에 대한 취약점이 발생하지 않도록 주의해야 합니다. 디코더는 내장된 NUL 문자\(ASCII 0\) 등을 포함하여 유효하지 않은 입력으로 인해 중단되어서는 안 됩니다.

알파벳이 아닌 문자를 무시하면 전체 인코딩을 거부하는 대신\(권장 사항\) 정보를 "유출"하는 데 사용할 수 있는 비밀 채널이 가능해집니다. 무시된 문자는 문자열 동등 비교를 피하거나 구현 버그를 유발하는 등의 다른 사악한 목적으로 사용될 수도 있습니다. 권장되는 방식을 따르지 않는 애플리케이션에서는 알파벳이 아닌 문자를 무시한다는 의미를 이해해야 합니다. 마찬가지로, 16진수와 32진수 알파벳이 대소문자를 구분하지 않고 처리되면 대소문자 변경을 통해 정보가 유출되거나 문자열 동일 비교가 실패하게 될 수 있습니다.

패딩을 사용할 때 정보 유출에 남용되거나 문자열 동등 비교를 우회하거나 구현 문제를 유발하는 데 사용될 수 있으므로 보안 문제를 보장하는 중요하지 않은 비트가 있습니다.

기본 인코딩은 비밀번호와 같이 쉽게 인식할 수 있는 정보를 시각적으로 숨기지만 계산상의 기밀성을 제공하지는 않습니다. 이는 예를 들어 사용자가 네트워크 프로토콜 교환의 세부사항\(아마도 다른 문제를 설명하기 위해\)을 보고하고 기본 인코딩이 비밀번호를 보호하지 않는다는 사실을 모르기 때문에 실수로 비밀번호를 공개할 때 보안 사고를 일으키는 것으로 알려져 있습니다.

기본 인코딩은 일반 텍스트에 엔트로피를 추가하지 않지만 사용 가능한 일반 텍스트의 양을 늘리고 특징적인 확률 분포 형태로 암호 분석을 위한 서명을 제공합니다.

---
## **13.  Changes Since RFC 3548**

인코딩된 데이터의 정렬 순서를 유지하는 데 필요한 "base32 확장 16진수 알파벳"을 추가했습니다.

거기에 사용된 특수 Base64 인코딩에 대해 IMAP을 참조했습니다.

RFC 2440에서 복사된 예제를 수정했습니다.

암호화 분석을 위한 서명 제공에 대한 보안 고려 사항이 추가되었습니다.

```text
   Added test vectors.

   Fixed typos.
```

---
## **14.  Acknowledgements**

John E. Hadstate, Tony Hansen, Gordon Mohr, John Myers, Chris Newman 및 Andrew Sieber를 포함한 몇몇 사람들이 의견 및/또는 제안을 제공했습니다. 이 문서에 사용된 텍스트는 다양한 기본 인코딩의 구체적인 용도를 설명하는 이전 RFC를 기반으로 합니다. 저자는 이 문서를 작성하는 데 도움을 준 RSA 연구소에 감사를 표합니다.

이 개정판은 Roy Arends, Eric Blake, Brian E Carpenter, Elwyn Davies, Bill Fenner, Sam Hartman, Ted Hardie, Per Hygum, Jelte Jansen, Clement Kent, Tero Kivinen, Paul의 의견 및/또는 제안을 일부 기반으로 합니다. Kwiatkowski, 벤 로리.

---
## **15.  Copying Conditions**

```text
   Copyright (c) 2000-2006 Simon Josefsson
```

Simon Josefsson\(이 섹션의 나머지 부분에서는 "저자"\)이 작성한 이 문서의 초록과 섹션 1, 3, 8, 10, 12, 13 및 14에 대해 저자는 어떠한 보장도 하지 않습니다. 사용으로 인한 피해에 대해서는 책임을 지지 않습니다. 재배포된 파생 저작물에 오해의 소지가 있는 저자 또는 버전 정보가 포함되어 있지 않은 경우, 저자는 다른 사람의 사용, 수정 및 배포 권한을 감소시키지 않는 방식으로 모든 사람에게 이를 사용, 수정 및 배포할 수 있는 취소 불가능한 권한을 부여합니다. IETF RFC 문서인 것처럼 거짓으로 주장하지 마십시오. 파생 저작물은 유사한 조건으로 라이선스를 받을 필요가 없습니다.

---
## **16.  References**
---
### **16.1.  Normative References**

\[1\] Cerf, V., "네트워크 교환을 위한 ASCII 형식", RFC 20, 1969년 10월.

\[2\] Bradner, S., "요구 사항 수준을 나타 내기 위해 RFC에 사용되는 핵심 단어", BCP 14, RFC 2119, 1997년 3월.

---
### **16.2.  Informative References**

\[3\] Linn, J., "인터넷 전자 메일의 개인 정보 보호 강화: 1부: 메시지 암호화 및 인증 절차", RFC 1421, 1993년 2월.

\[4\] Freed, N. 및 N. Borenstein, "다목적 인터넷 메일 확장\(MIME\) 1부: 인터넷 메시지 본문 형식", RFC 2045, 1996년 11월.

\[5\] Callas, J., Donnerhacke, L., Finney, H. 및 R. Thayer, "OpenPGP 메시지 형식", RFC 2440, 1998년 11월.

\[6\] Arends, R., Austein, R., Larson, M., Massey, D. 및 S. Rose, "DNS 보안 소개 및 요구 사항", RFC 4033, 2005년 3월.

\[7\] Klyne, G. 및 L. Masinter, "복합 미디어 기능 식별", RFC 2938, 2000년 9월.

```text
   [8]   Crispin, M., "INTERNET MESSAGE ACCESS PROTOCOL - VERSION
         4rev1", RFC 3501, March 2003.
```

\[9\] Berners-Lee, T., Fielding, R. 및 L. Masinter, "URI\(Uniform Resource Identifier\): 일반 구문", STD 66, RFC 3986, 2005년 1월.

\[10\] Laurie, B., Sisson, G., Arends, R. 및 D. Blacka, "DNSSEC 해시 인증 존재 거부", 진행 중인 작업, 2006년 6월.

\[11\] Myers, J., "SASL GSSAPI 메커니즘", 진행 중인 작업, 2000년 5월.

\[12\] Wilcox-O'Hearn, B., "P2P-hackers 메일링 리스트에 게시", http://zgp.org/pipermail/p2p-hackers/2001-September/000315.html, 2001년 9월.

---
# **Author's Address**

```text
   Simon Josefsson
   SJD
   EMail: simon@josefsson.org
```

---
# **Full Copyright Statement**

Copyright \(C\) The Internet Society \(2006\).

이 문서는 BCP 78에 포함된 권리, 라이선스 및 제한 사항의 적용을 받으며 여기에 명시된 경우를 제외하고 작성자는 모든 권리를 보유합니다.

이 문서 및 여기에 포함된 정보는 "있는 그대로" 제공되며 기여자, 기여자가 대표하거나 후원하는 조직\(있는 경우\), 인터넷 사회 및 인터넷 공학 태스크포스는 모든 명시적 또는 묵시적 보증을 부인합니다. 여기에서 구성은 상품성 또는 특정 목적에의 적합성에 대한 권리 또는 묵시적 보증을 침해하지 않습니다.

---
# **Intellectual Property**

IETF는 이 문서에 설명된 기술의 구현 또는 사용과 관련이 있다고 주장할 수 있는 지적 재산권 또는 기타 권리의 유효성 또는 범위 또는 그러한 권리에 따른 라이센스의 범위에 대해 어떠한 입장도 취하지 않습니다. 는 가능하다; 또한 그러한 권리를 식별하기 위해 독립적인 노력을 기울였다는 것을 나타내지 않습니다. RFC 문서의 권리와 관련된 절차에 대한 정보는 BCP 78 및 BCP 79에서 찾을 수 있습니다.

IETF 사무국에 제출된 IPR 공개 사본 및 사용 가능한 라이선스에 대한 보증 또는 이 사양의 구현자 또는 사용자가 이러한 독점권 사용에 대한 일반 라이선스 또는 허가를 얻으려는 시도의 결과를 얻을 수 있습니다. http://www.ietf.org/ipr의 IETF 온라인 IPR 저장소에서.

IETF는 이 표준을 구현하는 데 필요할 수 있는 기술을 포함할 수 있는 저작권, 특허 또는 특허 출원 또는 기타 소유권에 관심을 갖도록 이해 당사자를 초대합니다. 정보를 IETF\(ietf-ipr@ietf.org\)로 보내주십시오.

---
# **Acknowledgement**

RFC 편집기 기능에 대한 자금은 IETF 행정 지원 활동\(IASA\)에서 제공합니다.